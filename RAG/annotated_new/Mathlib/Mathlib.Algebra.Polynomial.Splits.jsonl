{"name":"Polynomial.splits_zero","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\n⊢ Polynomial.Splits i 0","decl":"@[simp]\ntheorem splits_zero : Splits i (0 : K[X]) :=\n  Or.inl (Polynomial.map_zero i)\n\n"}
{"name":"Polynomial.splits_of_map_eq_C","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\nf : Polynomial K\na : L\nh : Eq (Polynomial.map i f) (Polynomial.C a)\n⊢ Polynomial.Splits i f","decl":"theorem splits_of_map_eq_C {f : K[X]} {a : L} (h : f.map i = C a) : Splits i f :=\n  letI := Classical.decEq L\n  if ha : a = 0 then Or.inl (h.trans (ha.symm ▸ C_0))\n  else\n    Or.inr fun hg ⟨p, hp⟩ =>\n      absurd hg.1 <|\n        Classical.not_not.2 <|\n          isUnit_iff_degree_eq_zero.2 <| by\n            have := congr_arg degree hp\n            rw [h, degree_C ha, degree_mul, @eq_comm (WithBot ℕ) 0,\n                Nat.WithBot.add_eq_zero_iff] at this\n            exact this.1\n\n"}
{"name":"Polynomial.splits_C","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\na : K\n⊢ Polynomial.Splits i (Polynomial.C a)","decl":"@[simp]\ntheorem splits_C (a : K) : Splits i (C a) :=\n  splits_of_map_eq_C i (map_C i)\n\n"}
{"name":"Polynomial.splits_of_map_degree_eq_one","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\nf : Polynomial K\nhf : Eq (Polynomial.map i f).degree 1\n⊢ Polynomial.Splits i f","decl":"theorem splits_of_map_degree_eq_one {f : K[X]} (hf : degree (f.map i) = 1) : Splits i f :=\n  Or.inr fun hg ⟨p, hp⟩ => by\n    have := congr_arg degree hp\n    simp [Nat.WithBot.add_eq_one_iff, hf, @eq_comm (WithBot ℕ) 1,\n        mt isUnit_iff_degree_eq_zero.2 hg.1] at this\n    tauto\n\n"}
{"name":"Polynomial.splits_of_degree_le_one","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\nf : Polynomial K\nhf : LE.le f.degree 1\n⊢ Polynomial.Splits i f","decl":"theorem splits_of_degree_le_one {f : K[X]} (hf : degree f ≤ 1) : Splits i f :=\n  if hif : degree (f.map i) ≤ 0 then splits_of_map_eq_C i (degree_le_zero_iff.mp hif)\n  else by\n    push_neg at hif\n    rw [← Order.succ_le_iff, ← WithBot.coe_zero, WithBot.orderSucc_coe, Nat.succ_eq_succ] at hif\n    exact splits_of_map_degree_eq_one i ((degree_map_le.trans hf).antisymm hif)\n\n"}
{"name":"Polynomial.splits_of_degree_eq_one","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\nf : Polynomial K\nhf : Eq f.degree 1\n⊢ Polynomial.Splits i f","decl":"theorem splits_of_degree_eq_one {f : K[X]} (hf : degree f = 1) : Splits i f :=\n  splits_of_degree_le_one i hf.le\n\n"}
{"name":"Polynomial.splits_of_natDegree_le_one","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\nf : Polynomial K\nhf : LE.le f.natDegree 1\n⊢ Polynomial.Splits i f","decl":"theorem splits_of_natDegree_le_one {f : K[X]} (hf : natDegree f ≤ 1) : Splits i f :=\n  splits_of_degree_le_one i (degree_le_of_natDegree_le hf)\n\n"}
{"name":"Polynomial.splits_of_natDegree_eq_one","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\nf : Polynomial K\nhf : Eq f.natDegree 1\n⊢ Polynomial.Splits i f","decl":"theorem splits_of_natDegree_eq_one {f : K[X]} (hf : natDegree f = 1) : Splits i f :=\n  splits_of_natDegree_le_one i (le_of_eq hf)\n\n"}
{"name":"Polynomial.splits_mul","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\nf g : Polynomial K\nhf : Polynomial.Splits i f\nhg : Polynomial.Splits i g\n⊢ Polynomial.Splits i (HMul.hMul f g)","decl":"theorem splits_mul {f g : K[X]} (hf : Splits i f) (hg : Splits i g) : Splits i (f * g) :=\n  letI := Classical.decEq L\n  if h : (f * g).map i = 0 then Or.inl h\n  else\n    Or.inr @fun p hp hpf =>\n      ((irreducible_iff_prime.1 hp).2.2 _ _\n            (show p ∣ map i f * map i g by convert hpf; rw [Polynomial.map_mul])).elim\n        (hf.resolve_left (fun hf => by simp [hf] at h) hp)\n        (hg.resolve_left (fun hg => by simp [hg] at h) hp)\n\n"}
{"name":"Polynomial.splits_of_splits_mul'","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\nf g : Polynomial K\nhfg : Ne (Polynomial.map i (HMul.hMul f g)) 0\nh : Polynomial.Splits i (HMul.hMul f g)\n⊢ And (Polynomial.Splits i f) (Polynomial.Splits i g)","decl":"theorem splits_of_splits_mul' {f g : K[X]} (hfg : (f * g).map i ≠ 0) (h : Splits i (f * g)) :\n    Splits i f ∧ Splits i g :=\n  ⟨Or.inr @fun g hgi hg =>\n      Or.resolve_left h hfg hgi (by rw [Polynomial.map_mul]; exact hg.trans (dvd_mul_right _ _)),\n    Or.inr @fun g hgi hg =>\n      Or.resolve_left h hfg hgi (by rw [Polynomial.map_mul]; exact hg.trans (dvd_mul_left _ _))⟩\n\n"}
{"name":"Polynomial.splits_map_iff","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"F : Type u\nK : Type v\nL : Type w\ninst✝² : CommRing K\ninst✝¹ : Field L\ninst✝ : Field F\ni : RingHom K L\nj : RingHom L F\nf : Polynomial K\n⊢ Iff (Polynomial.Splits j (Polynomial.map i f)) (Polynomial.Splits (j.comp i) f)","decl":"theorem splits_map_iff (j : L →+* F) {f : K[X]} : Splits j (f.map i) ↔ Splits (j.comp i) f := by\n  simp [Splits, Polynomial.map_map]\n\n"}
{"name":"Polynomial.splits_one","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\n⊢ Polynomial.Splits i 1","decl":"theorem splits_one : Splits i 1 :=\n  splits_C i 1\n\n"}
{"name":"Polynomial.splits_of_isUnit","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝² : CommRing K\ninst✝¹ : Field L\ni : RingHom K L\ninst✝ : IsDomain K\nu : Polynomial K\nhu : IsUnit u\n⊢ Polynomial.Splits i u","decl":"theorem splits_of_isUnit [IsDomain K] {u : K[X]} (hu : IsUnit u) : u.Splits i :=\n  (isUnit_iff.mp hu).choose_spec.2 ▸ splits_C _ _\n\n"}
{"name":"Polynomial.splits_X_sub_C","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\nx : K\n⊢ Polynomial.Splits i (HSub.hSub Polynomial.X (Polynomial.C x))","decl":"theorem splits_X_sub_C {x : K} : (X - C x).Splits i :=\n  splits_of_degree_le_one _ <| degree_X_sub_C_le _\n\n"}
{"name":"Polynomial.splits_X","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\n⊢ Polynomial.Splits i Polynomial.X","decl":"theorem splits_X : X.Splits i :=\n  splits_of_degree_le_one _ degree_X_le\n\n"}
{"name":"Polynomial.splits_prod","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\nι : Type u\ns : ι → Polynomial K\nt : Finset ι\na✝ : ∀ (j : ι), Membership.mem t j → Polynomial.Splits i (s j)\n⊢ Polynomial.Splits i (t.prod fun x => s x)","decl":"theorem splits_prod {ι : Type u} {s : ι → K[X]} {t : Finset ι} :\n    (∀ j ∈ t, (s j).Splits i) → (∏ x ∈ t, s x).Splits i := by\n  classical\n  refine Finset.induction_on t (fun _ => splits_one i) fun a t hat ih ht => ?_\n  rw [Finset.forall_mem_insert] at ht; rw [Finset.prod_insert hat]\n  exact splits_mul i ht.1 (ih ht.2)\n\n"}
{"name":"Polynomial.splits_pow","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\nf : Polynomial K\nhf : Polynomial.Splits i f\nn : Nat\n⊢ Polynomial.Splits i (HPow.hPow f n)","decl":"theorem splits_pow {f : K[X]} (hf : f.Splits i) (n : ℕ) : (f ^ n).Splits i := by\n  rw [← Finset.card_range n, ← Finset.prod_const]\n  exact splits_prod i fun j _ => hf\n\n"}
{"name":"Polynomial.splits_X_pow","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\nn : Nat\n⊢ Polynomial.Splits i (HPow.hPow Polynomial.X n)","decl":"theorem splits_X_pow (n : ℕ) : (X ^ n).Splits i :=\n  splits_pow i (splits_X i) n\n\n"}
{"name":"Polynomial.splits_id_iff_splits","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\nf : Polynomial K\n⊢ Iff (Polynomial.Splits (RingHom.id L) (Polynomial.map i f)) (Polynomial.Splits i f)","decl":"theorem splits_id_iff_splits {f : K[X]} : (f.map i).Splits (RingHom.id L) ↔ f.Splits i := by\n  rw [splits_map_iff, RingHom.id_comp]\n\n"}
{"name":"Polynomial.Splits.comp_of_map_degree_le_one","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\nf p : Polynomial K\nhd : LE.le (Polynomial.map i p).degree 1\nh : Polynomial.Splits i f\n⊢ Polynomial.Splits i (f.comp p)","decl":"theorem Splits.comp_of_map_degree_le_one {f : K[X]} {p : K[X]} (hd : (p.map i).degree ≤ 1)\n    (h : f.Splits i) : (f.comp p).Splits i := by\n  by_cases hzero : map i (f.comp p) = 0\n  · exact Or.inl hzero\n  cases h with\n  | inl h0 =>\n    exact Or.inl <| map_comp i _ _ ▸ h0.symm ▸ zero_comp\n  | inr h =>\n    right\n    intro g irr dvd\n    rw [map_comp] at dvd hzero\n    cases lt_or_eq_of_le hd with\n    | inl hd =>\n      rw [eq_C_of_degree_le_zero (Nat.WithBot.lt_one_iff_le_zero.mp hd), comp_C] at dvd hzero\n      refine False.elim (irr.1 (isUnit_of_dvd_unit dvd ?_))\n      simpa using hzero\n    | inr hd =>\n      let _ := invertibleOfNonzero (leadingCoeff_ne_zero.mpr\n          (ne_zero_of_degree_gt (n := ⊥) (by rw [hd]; decide)))\n      rw [eq_X_add_C_of_degree_eq_one hd, dvd_comp_C_mul_X_add_C_iff _ _] at dvd\n      have := h (irr.map (algEquivCMulXAddC _ _).symm) dvd\n      rw [degree_eq_natDegree irr.ne_zero]\n      rwa [algEquivCMulXAddC_symm_apply, ← comp_eq_aeval,\n        degree_eq_natDegree (fun h => WithBot.bot_ne_one (h ▸ this)),\n        natDegree_comp, natDegree_C_mul (invertibleInvOf.ne_zero),\n        natDegree_X_sub_C, mul_one] at this\n\n"}
{"name":"Polynomial.splits_iff_comp_splits_of_degree_eq_one","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\nf p : Polynomial K\nhd : Eq (Polynomial.map i p).degree 1\n⊢ Iff (Polynomial.Splits i f) (Polynomial.Splits i (f.comp p))","decl":"theorem splits_iff_comp_splits_of_degree_eq_one {f : K[X]} {p : K[X]} (hd : (p.map i).degree = 1) :\n    f.Splits i ↔ (f.comp p).Splits i := by\n  rw [← splits_id_iff_splits, ← splits_id_iff_splits (f := f.comp p), map_comp]\n  refine ⟨fun h => Splits.comp_of_map_degree_le_one\n    (le_of_eq (map_id (R := L) ▸ hd)) h, fun h => ?_⟩\n  let _ := invertibleOfNonzero (leadingCoeff_ne_zero.mpr\n      (ne_zero_of_degree_gt (n := ⊥) (by rw [hd]; decide)))\n  have : (map i f) = ((map i f).comp (map i p)).comp ((C ⅟ (map i p).leadingCoeff *\n      (X - C ((map i p).coeff 0)))) := by\n    rw [comp_assoc]\n    nth_rw 1 [eq_X_add_C_of_degree_eq_one hd]\n    simp only [coeff_map, invOf_eq_inv, mul_sub, ← C_mul, add_comp, mul_comp, C_comp, X_comp,\n      ← mul_assoc]\n    simp\n  refine this ▸ Splits.comp_of_map_degree_le_one ?_ h\n  simp [degree_C (inv_ne_zero (Invertible.ne_zero (a := (map i p).leadingCoeff)))]\n\n"}
{"name":"Polynomial.Splits.comp_of_degree_le_one","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\nf p : Polynomial K\nhd : LE.le p.degree 1\nh : Polynomial.Splits i f\n⊢ Polynomial.Splits i (f.comp p)","decl":"/--\nThis is a weaker variant of `Splits.comp_of_map_degree_le_one`,\nbut its conditions are easier to check.\n-/\ntheorem Splits.comp_of_degree_le_one {f : K[X]} {p : K[X]} (hd : p.degree ≤ 1)\n    (h : f.Splits i) : (f.comp p).Splits i :=\n  Splits.comp_of_map_degree_le_one (degree_map_le.trans hd) h\n\n"}
{"name":"Polynomial.Splits.comp_X_sub_C","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\na : K\nf : Polynomial K\nh : Polynomial.Splits i f\n⊢ Polynomial.Splits i (f.comp (HSub.hSub Polynomial.X (Polynomial.C a)))","decl":"theorem Splits.comp_X_sub_C (a : K) {f : K[X]}\n    (h : f.Splits i) : (f.comp (X - C a)).Splits i :=\n  Splits.comp_of_degree_le_one (degree_X_sub_C_le _) h\n\n"}
{"name":"Polynomial.Splits.comp_X_add_C","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\na : K\nf : Polynomial K\nh : Polynomial.Splits i f\n⊢ Polynomial.Splits i (f.comp (HAdd.hAdd Polynomial.X (Polynomial.C a)))","decl":"theorem Splits.comp_X_add_C (a : K) {f : K[X]}\n    (h : f.Splits i) : (f.comp (X + C a)).Splits i :=\n  Splits.comp_of_degree_le_one (by simpa using degree_X_sub_C_le (-a)) h\n\n"}
{"name":"Polynomial.Splits.comp_neg_X","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\nf : Polynomial K\nh : Polynomial.Splits i f\n⊢ Polynomial.Splits i (f.comp (Neg.neg Polynomial.X))","decl":"theorem Splits.comp_neg_X {f : K[X]} (h : f.Splits i) : (f.comp (-X)).Splits i :=\n  Splits.comp_of_degree_le_one (by simpa using degree_X_sub_C_le (0 : K)) h\n\n"}
{"name":"Polynomial.exists_root_of_splits'","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\nf : Polynomial K\nhs : Polynomial.Splits i f\nhf0 : Ne (Polynomial.map i f).degree 0\n⊢ Exists fun x => Eq (Polynomial.eval₂ i x f) 0","decl":"theorem exists_root_of_splits' {f : K[X]} (hs : Splits i f) (hf0 : degree (f.map i) ≠ 0) :\n    ∃ x, eval₂ i x f = 0 :=\n  letI := Classical.decEq L\n  if hf0' : f.map i = 0 then by simp [eval₂_eq_eval_map, hf0']\n  else\n    let ⟨g, hg⟩ :=\n      WfDvdMonoid.exists_irreducible_factor\n        (show ¬IsUnit (f.map i) from mt isUnit_iff_degree_eq_zero.1 hf0) hf0'\n    let ⟨x, hx⟩ := exists_root_of_degree_eq_one (hs.resolve_left hf0' hg.1 hg.2)\n    let ⟨i, hi⟩ := hg.2\n    ⟨x, by rw [← eval_map, hi, eval_mul, show _ = _ from hx, zero_mul]⟩\n\n"}
{"name":"Polynomial.roots_ne_zero_of_splits'","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\nf : Polynomial K\nhs : Polynomial.Splits i f\nhf0 : Ne (Polynomial.map i f).natDegree 0\n⊢ Ne (Polynomial.map i f).roots 0","decl":"theorem roots_ne_zero_of_splits' {f : K[X]} (hs : Splits i f) (hf0 : natDegree (f.map i) ≠ 0) :\n    (f.map i).roots ≠ 0 :=\n  let ⟨x, hx⟩ := exists_root_of_splits' i hs fun h => hf0 <| natDegree_eq_of_degree_eq_some h\n  fun h => by\n  rw [← eval_map] at hx\n  have : f.map i ≠ 0 := by intro; simp_all\n  cases h.subst ((mem_roots this).2 hx)\n\n"}
{"name":"Polynomial.map_rootOfSplits'","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\ni : RingHom K L\nf : Polynomial K\nhf : Polynomial.Splits i f\nhfd : Ne (Polynomial.map i f).degree 0\n⊢ Eq (Polynomial.eval₂ i (Polynomial.rootOfSplits' i hf hfd) f) 0","decl":"theorem map_rootOfSplits' {f : K[X]} (hf : f.Splits i) (hfd) :\n    f.eval₂ i (rootOfSplits' i hf hfd) = 0 :=\n  Classical.choose_spec <| exists_root_of_splits' i hf hfd\n\n"}
{"name":"Polynomial.natDegree_eq_card_roots'","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\np : Polynomial K\ni : RingHom K L\nhsplit : Polynomial.Splits i p\n⊢ Eq (Polynomial.map i p).natDegree (Polynomial.map i p).roots.card","decl":"theorem natDegree_eq_card_roots' {p : K[X]} {i : K →+* L} (hsplit : Splits i p) :\n    (p.map i).natDegree = Multiset.card (p.map i).roots := by\n  by_cases hp : p.map i = 0\n  · rw [hp, natDegree_zero, roots_zero, Multiset.card_zero]\n  obtain ⟨q, he, hd, hr⟩ := exists_prod_multiset_X_sub_C_mul (p.map i)\n  rw [← splits_id_iff_splits, ← he] at hsplit\n  rw [← he] at hp\n  have hq : q ≠ 0 := fun h => hp (by rw [h, mul_zero])\n  rw [← hd, add_right_eq_self]\n  by_contra h\n  have h' : (map (RingHom.id L) q).natDegree ≠ 0 := by simp [h]\n  have := roots_ne_zero_of_splits' (RingHom.id L) (splits_of_splits_mul' _ ?_ hsplit).2 h'\n  · rw [map_id] at this\n    exact this hr\n  · rw [map_id]\n    exact mul_ne_zero monic_prod_multiset_X_sub_C.ne_zero hq\n\n"}
{"name":"Polynomial.degree_eq_card_roots'","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : CommRing K\ninst✝ : Field L\np : Polynomial K\ni : RingHom K L\np_ne_zero : Ne (Polynomial.map i p) 0\nhsplit : Polynomial.Splits i p\n⊢ Eq (Polynomial.map i p).degree ↑(Polynomial.map i p).roots.card","decl":"theorem degree_eq_card_roots' {p : K[X]} {i : K →+* L} (p_ne_zero : p.map i ≠ 0)\n    (hsplit : Splits i p) : (p.map i).degree = Multiset.card (p.map i).roots := by\n  simp [degree_eq_natDegree p_ne_zero, natDegree_eq_card_roots' hsplit]\n\n"}
{"name":"Polynomial.splits_iff","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : Field K\ninst✝ : Field L\ni : RingHom K L\nf : Polynomial K\n⊢ Iff (Polynomial.Splits i f) (Or (Eq f 0) (∀ {g : Polynomial L}, Irreducible g → Dvd.dvd g (Polynomial.map i f) → Eq g.degree 1))","decl":"/-- This lemma is for polynomials over a field. -/\ntheorem splits_iff (f : K[X]) :\n    Splits i f ↔ f = 0 ∨ ∀ {g : L[X]}, Irreducible g → g ∣ f.map i → degree g = 1 := by\n  rw [Splits, Polynomial.map_eq_zero]\n\n"}
{"name":"Polynomial.Splits.def","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : Field K\ninst✝ : Field L\ni : RingHom K L\nf : Polynomial K\nh : Polynomial.Splits i f\n⊢ Or (Eq f 0) (∀ {g : Polynomial L}, Irreducible g → Dvd.dvd g (Polynomial.map i f) → Eq g.degree 1)","decl":"/-- This lemma is for polynomials over a field. -/\ntheorem Splits.def {i : K →+* L} {f : K[X]} (h : Splits i f) :\n    f = 0 ∨ ∀ {g : L[X]}, Irreducible g → g ∣ f.map i → degree g = 1 :=\n  (splits_iff i f).mp h\n\n"}
{"name":"Polynomial.splits_of_splits_mul","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : Field K\ninst✝ : Field L\ni : RingHom K L\nf g : Polynomial K\nhfg : Ne (HMul.hMul f g) 0\nh : Polynomial.Splits i (HMul.hMul f g)\n⊢ And (Polynomial.Splits i f) (Polynomial.Splits i g)","decl":"theorem splits_of_splits_mul {f g : K[X]} (hfg : f * g ≠ 0) (h : Splits i (f * g)) :\n    Splits i f ∧ Splits i g :=\n  splits_of_splits_mul' i (map_ne_zero hfg) h\n\n"}
{"name":"Polynomial.splits_of_splits_of_dvd","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : Field K\ninst✝ : Field L\ni : RingHom K L\nf g : Polynomial K\nhf0 : Ne f 0\nhf : Polynomial.Splits i f\nhgf : Dvd.dvd g f\n⊢ Polynomial.Splits i g","decl":"theorem splits_of_splits_of_dvd {f g : K[X]} (hf0 : f ≠ 0) (hf : Splits i f) (hgf : g ∣ f) :\n    Splits i g := by\n  obtain ⟨f, rfl⟩ := hgf\n  exact (splits_of_splits_mul i hf0 hf).1\n\n"}
{"name":"Polynomial.splits_of_splits_gcd_left","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝² : Field K\ninst✝¹ : Field L\ni : RingHom K L\ninst✝ : DecidableEq K\nf g : Polynomial K\nhf0 : Ne f 0\nhf : Polynomial.Splits i f\n⊢ Polynomial.Splits i (EuclideanDomain.gcd f g)","decl":"theorem splits_of_splits_gcd_left [DecidableEq K] {f g : K[X]} (hf0 : f ≠ 0) (hf : Splits i f) :\n    Splits i (EuclideanDomain.gcd f g) :=\n  Polynomial.splits_of_splits_of_dvd i hf0 hf (EuclideanDomain.gcd_dvd_left f g)\n\n"}
{"name":"Polynomial.splits_of_splits_gcd_right","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝² : Field K\ninst✝¹ : Field L\ni : RingHom K L\ninst✝ : DecidableEq K\nf g : Polynomial K\nhg0 : Ne g 0\nhg : Polynomial.Splits i g\n⊢ Polynomial.Splits i (EuclideanDomain.gcd f g)","decl":"theorem splits_of_splits_gcd_right [DecidableEq K] {f g : K[X]} (hg0 : g ≠ 0) (hg : Splits i g) :\n    Splits i (EuclideanDomain.gcd f g) :=\n  Polynomial.splits_of_splits_of_dvd i hg0 hg (EuclideanDomain.gcd_dvd_right f g)\n\n"}
{"name":"Polynomial.splits_mul_iff","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : Field K\ninst✝ : Field L\ni : RingHom K L\nf g : Polynomial K\nhf : Ne f 0\nhg : Ne g 0\n⊢ Iff (Polynomial.Splits i (HMul.hMul f g)) (And (Polynomial.Splits i f) (Polynomial.Splits i g))","decl":"theorem splits_mul_iff {f g : K[X]} (hf : f ≠ 0) (hg : g ≠ 0) :\n    (f * g).Splits i ↔ f.Splits i ∧ g.Splits i :=\n  ⟨splits_of_splits_mul i (mul_ne_zero hf hg), fun ⟨hfs, hgs⟩ => splits_mul i hfs hgs⟩\n\n"}
{"name":"Polynomial.splits_prod_iff","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : Field K\ninst✝ : Field L\ni : RingHom K L\nι : Type u\ns : ι → Polynomial K\nt : Finset ι\na✝ : ∀ (j : ι), Membership.mem t j → Ne (s j) 0\n⊢ Iff (Polynomial.Splits i (t.prod fun x => s x)) (∀ (j : ι), Membership.mem t j → Polynomial.Splits i (s j))","decl":"theorem splits_prod_iff {ι : Type u} {s : ι → K[X]} {t : Finset ι} :\n    (∀ j ∈ t, s j ≠ 0) → ((∏ x ∈ t, s x).Splits i ↔ ∀ j ∈ t, (s j).Splits i) := by\n  classical\n  refine\n    Finset.induction_on t (fun _ =>\n        ⟨fun _ _ h => by simp only [Finset.not_mem_empty] at h, fun _ => splits_one i⟩)\n      fun a t hat ih ht => ?_\n  rw [Finset.forall_mem_insert] at ht ⊢\n  rw [Finset.prod_insert hat, splits_mul_iff i ht.1 (Finset.prod_ne_zero_iff.2 ht.2), ih ht.2]\n\n"}
{"name":"Polynomial.degree_eq_one_of_irreducible_of_splits","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\ninst✝ : Field K\np : Polynomial K\nhp : Irreducible p\nhp_splits : Polynomial.Splits (RingHom.id K) p\n⊢ Eq p.degree 1","decl":"theorem degree_eq_one_of_irreducible_of_splits {p : K[X]} (hp : Irreducible p)\n    (hp_splits : Splits (RingHom.id K) p) : p.degree = 1 := by\n  rcases hp_splits with ⟨⟩ | hp_splits\n  · exfalso\n    simp_all\n  · apply hp_splits hp\n    simp\n\n"}
{"name":"Polynomial.exists_root_of_splits","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : Field K\ninst✝ : Field L\ni : RingHom K L\nf : Polynomial K\nhs : Polynomial.Splits i f\nhf0 : Ne f.degree 0\n⊢ Exists fun x => Eq (Polynomial.eval₂ i x f) 0","decl":"theorem exists_root_of_splits {f : K[X]} (hs : Splits i f) (hf0 : degree f ≠ 0) :\n    ∃ x, eval₂ i x f = 0 :=\n  exists_root_of_splits' i hs ((f.degree_map i).symm ▸ hf0)\n\n"}
{"name":"Polynomial.roots_ne_zero_of_splits","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : Field K\ninst✝ : Field L\ni : RingHom K L\nf : Polynomial K\nhs : Polynomial.Splits i f\nhf0 : Ne f.natDegree 0\n⊢ Ne (Polynomial.map i f).roots 0","decl":"theorem roots_ne_zero_of_splits {f : K[X]} (hs : Splits i f) (hf0 : natDegree f ≠ 0) :\n    (f.map i).roots ≠ 0 :=\n  roots_ne_zero_of_splits' i hs (ne_of_eq_of_ne (natDegree_map i) hf0)\n\n"}
{"name":"Polynomial.rootOfSplits'_eq_rootOfSplits","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : Field K\ninst✝ : Field L\ni : RingHom K L\nf : Polynomial K\nhf : Polynomial.Splits i f\nhfd : Ne (Polynomial.map i f).degree 0\n⊢ Eq (Polynomial.rootOfSplits' i hf hfd) (Polynomial.rootOfSplits i hf ⋯)","decl":"/-- `rootOfSplits'` is definitionally equal to `rootOfSplits`. -/\ntheorem rootOfSplits'_eq_rootOfSplits {f : K[X]} (hf : f.Splits i) (hfd) :\n    rootOfSplits' i hf hfd = rootOfSplits i hf (f.degree_map i ▸ hfd) :=\n  rfl\n\n"}
{"name":"Polynomial.map_rootOfSplits","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : Field K\ninst✝ : Field L\ni : RingHom K L\nf : Polynomial K\nhf : Polynomial.Splits i f\nhfd : Ne f.degree 0\n⊢ Eq (Polynomial.eval₂ i (Polynomial.rootOfSplits i hf hfd) f) 0","decl":"theorem map_rootOfSplits {f : K[X]} (hf : f.Splits i) (hfd) :\n    f.eval₂ i (rootOfSplits i hf hfd) = 0 :=\n  map_rootOfSplits' i hf (ne_of_eq_of_ne (degree_map f i) hfd)\n\n"}
{"name":"Polynomial.natDegree_eq_card_roots","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : Field K\ninst✝ : Field L\np : Polynomial K\ni : RingHom K L\nhsplit : Polynomial.Splits i p\n⊢ Eq p.natDegree (Polynomial.map i p).roots.card","decl":"theorem natDegree_eq_card_roots {p : K[X]} {i : K →+* L} (hsplit : Splits i p) :\n    p.natDegree = Multiset.card (p.map i).roots :=\n  (natDegree_map i).symm.trans <| natDegree_eq_card_roots' hsplit\n\n"}
{"name":"Polynomial.degree_eq_card_roots","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : Field K\ninst✝ : Field L\np : Polynomial K\ni : RingHom K L\np_ne_zero : Ne p 0\nhsplit : Polynomial.Splits i p\n⊢ Eq p.degree ↑(Polynomial.map i p).roots.card","decl":"theorem degree_eq_card_roots {p : K[X]} {i : K →+* L} (p_ne_zero : p ≠ 0) (hsplit : Splits i p) :\n    p.degree = Multiset.card (p.map i).roots := by\n  rw [degree_eq_natDegree p_ne_zero, natDegree_eq_card_roots hsplit]\n\n"}
{"name":"Polynomial.roots_map","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : Field K\ninst✝ : Field L\ni : RingHom K L\nf : Polynomial K\nhf : Polynomial.Splits (RingHom.id K) f\n⊢ Eq (Polynomial.map i f).roots (Multiset.map (⇑i) f.roots)","decl":"theorem roots_map {f : K[X]} (hf : f.Splits <| RingHom.id K) : (f.map i).roots = f.roots.map i :=\n  (roots_map_of_injective_of_card_eq_natDegree i.injective <| by\n      convert (natDegree_eq_card_roots hf).symm\n      rw [map_id]).symm\n\n"}
{"name":"Polynomial.image_rootSet","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"R : Type u_1\nK : Type v\nL : Type w\ninst✝⁴ : CommRing R\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra R K\ninst✝ : Algebra R L\np : Polynomial R\nh : Polynomial.Splits (algebraMap R K) p\nf : AlgHom R K L\n⊢ Eq (Set.image (⇑f) (p.rootSet K)) (p.rootSet L)","decl":"theorem image_rootSet [Algebra R K] [Algebra R L] {p : R[X]} (h : p.Splits (algebraMap R K))\n    (f : K →ₐ[R] L) : f '' p.rootSet K = p.rootSet L := by\n  classical\n    rw [rootSet, ← Finset.coe_image, ← Multiset.toFinset_map, ← f.coe_toRingHom,\n      ← roots_map _ ((splits_id_iff_splits (algebraMap R K)).mpr h), map_map, f.comp_algebraMap,\n      ← rootSet]\n\n"}
{"name":"Polynomial.adjoin_rootSet_eq_range","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"R : Type u_1\nK : Type v\nL : Type w\ninst✝⁴ : CommRing R\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra R K\ninst✝ : Algebra R L\np : Polynomial R\nh : Polynomial.Splits (algebraMap R K) p\nf : AlgHom R K L\n⊢ Iff (Eq (Algebra.adjoin R (p.rootSet L)) f.range) (Eq (Algebra.adjoin R (p.rootSet K)) Top.top)","decl":"theorem adjoin_rootSet_eq_range [Algebra R K] [Algebra R L] {p : R[X]}\n    (h : p.Splits (algebraMap R K)) (f : K →ₐ[R] L) :\n    Algebra.adjoin R (p.rootSet L) = f.range ↔ Algebra.adjoin R (p.rootSet K) = ⊤ := by\n  rw [← image_rootSet h f, Algebra.adjoin_image, ← Algebra.map_top]\n  exact (Subalgebra.map_injective f.toRingHom.injective).eq_iff\n\n"}
{"name":"Polynomial.eq_prod_roots_of_splits","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : Field K\ninst✝ : Field L\np : Polynomial K\ni : RingHom K L\nhsplit : Polynomial.Splits i p\n⊢ Eq (Polynomial.map i p) (HMul.hMul (Polynomial.C (i p.leadingCoeff)) (Multiset.map (fun a => HSub.hSub Polynomial.X (Polynomial.C a)) (Polynomial.map i p).roots).prod)","decl":"theorem eq_prod_roots_of_splits {p : K[X]} {i : K →+* L} (hsplit : Splits i p) :\n    p.map i = C (i p.leadingCoeff) * ((p.map i).roots.map fun a => X - C a).prod := by\n  rw [← leadingCoeff_map]; symm\n  apply C_leadingCoeff_mul_prod_multiset_X_sub_C\n  rw [natDegree_map]; exact (natDegree_eq_card_roots hsplit).symm\n\n"}
{"name":"Polynomial.eq_prod_roots_of_splits_id","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\ninst✝ : Field K\np : Polynomial K\nhsplit : Polynomial.Splits (RingHom.id K) p\n⊢ Eq p (HMul.hMul (Polynomial.C p.leadingCoeff) (Multiset.map (fun a => HSub.hSub Polynomial.X (Polynomial.C a)) p.roots).prod)","decl":"theorem eq_prod_roots_of_splits_id {p : K[X]} (hsplit : Splits (RingHom.id K) p) :\n    p = C p.leadingCoeff * (p.roots.map fun a => X - C a).prod := by\n  simpa using eq_prod_roots_of_splits hsplit\n\n"}
{"name":"Polynomial.Splits.dvd_of_roots_le_roots","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\ninst✝ : Field K\np q : Polynomial K\nhp : Polynomial.Splits (RingHom.id K) p\nhp0 : Ne p 0\nhq : LE.le p.roots q.roots\n⊢ Dvd.dvd p q","decl":"theorem Splits.dvd_of_roots_le_roots {p q : K[X]} (hp : p.Splits (RingHom.id _)) (hp0 : p ≠ 0)\n    (hq : p.roots ≤ q.roots) : p ∣ q := by\n  rw [eq_prod_roots_of_splits_id hp, C_mul_dvd (leadingCoeff_ne_zero.2 hp0)]\n  exact dvd_trans\n    (Multiset.prod_dvd_prod_of_le (Multiset.map_le_map hq))\n    (prod_multiset_X_sub_C_dvd _)\n\n"}
{"name":"Polynomial.Splits.dvd_iff_roots_le_roots","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\ninst✝ : Field K\np q : Polynomial K\nhp : Polynomial.Splits (RingHom.id K) p\nhp0 : Ne p 0\nhq0 : Ne q 0\n⊢ Iff (Dvd.dvd p q) (LE.le p.roots q.roots)","decl":"theorem Splits.dvd_iff_roots_le_roots {p q : K[X]}\n    (hp : p.Splits (RingHom.id _)) (hp0 : p ≠ 0) (hq0 : q ≠ 0) :\n    p ∣ q ↔ p.roots ≤ q.roots :=\n  ⟨Polynomial.roots.le_of_dvd hq0, hp.dvd_of_roots_le_roots hp0⟩\n\n"}
{"name":"Polynomial.aeval_eq_prod_aroots_sub_of_splits","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\np : Polynomial K\nhsplit : Polynomial.Splits (algebraMap K L) p\nv : L\n⊢ Eq ((Polynomial.aeval v) p) (HMul.hMul ((algebraMap K L) p.leadingCoeff) (Multiset.map (fun a => HSub.hSub v a) (p.aroots L)).prod)","decl":"theorem aeval_eq_prod_aroots_sub_of_splits [Algebra K L] {p : K[X]}\n    (hsplit : Splits (algebraMap K L) p) (v : L) :\n    aeval v p = algebraMap K L p.leadingCoeff * ((p.aroots L).map fun a ↦ v - a).prod := by\n  rw [← eval_map_algebraMap, eq_prod_roots_of_splits hsplit]\n  simp [eval_multiset_prod]\n\n"}
{"name":"Polynomial.eval_eq_prod_roots_sub_of_splits_id","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\ninst✝ : Field K\np : Polynomial K\nhsplit : Polynomial.Splits (RingHom.id K) p\nv : K\n⊢ Eq (Polynomial.eval v p) (HMul.hMul p.leadingCoeff (Multiset.map (fun a => HSub.hSub v a) p.roots).prod)","decl":"theorem eval_eq_prod_roots_sub_of_splits_id {p : K[X]}\n    (hsplit : Splits (RingHom.id K) p) (v : K) :\n    eval v p = p.leadingCoeff * (p.roots.map fun a ↦ v - a).prod := by\n  convert aeval_eq_prod_aroots_sub_of_splits hsplit v\n  rw [Algebra.id.map_eq_id, map_id]\n\n"}
{"name":"Polynomial.eq_prod_roots_of_monic_of_splits_id","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\ninst✝ : Field K\np : Polynomial K\nm : p.Monic\nhsplit : Polynomial.Splits (RingHom.id K) p\n⊢ Eq p (Multiset.map (fun a => HSub.hSub Polynomial.X (Polynomial.C a)) p.roots).prod","decl":"theorem eq_prod_roots_of_monic_of_splits_id {p : K[X]} (m : Monic p)\n    (hsplit : Splits (RingHom.id K) p) : p = (p.roots.map fun a => X - C a).prod := by\n  convert eq_prod_roots_of_splits_id hsplit\n  simp [m]\n\n"}
{"name":"Polynomial.aeval_eq_prod_aroots_sub_of_monic_of_splits","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\np : Polynomial K\nm : p.Monic\nhsplit : Polynomial.Splits (algebraMap K L) p\nv : L\n⊢ Eq ((Polynomial.aeval v) p) (Multiset.map (fun a => HSub.hSub v a) (p.aroots L)).prod","decl":"theorem aeval_eq_prod_aroots_sub_of_monic_of_splits [Algebra K L] {p : K[X]} (m : Monic p)\n    (hsplit : Splits (algebraMap K L) p) (v : L) :\n    aeval v p = ((p.aroots L).map fun a ↦ v - a).prod := by\n  simp [aeval_eq_prod_aroots_sub_of_splits hsplit, m]\n\n"}
{"name":"Polynomial.eval_eq_prod_roots_sub_of_monic_of_splits_id","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\ninst✝ : Field K\np : Polynomial K\nm : p.Monic\nhsplit : Polynomial.Splits (RingHom.id K) p\nv : K\n⊢ Eq (Polynomial.eval v p) (Multiset.map (fun a => HSub.hSub v a) p.roots).prod","decl":"theorem eval_eq_prod_roots_sub_of_monic_of_splits_id {p : K[X]} (m : Monic p)\n    (hsplit : Splits (RingHom.id K) p) (v : K) :\n    eval v p = (p.roots.map fun a ↦ v - a).prod := by\n  simp [eval_eq_prod_roots_sub_of_splits_id hsplit, m]\n\n"}
{"name":"Polynomial.eq_X_sub_C_of_splits_of_single_root","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : Field K\ninst✝ : Field L\ni : RingHom K L\nx : K\nh : Polynomial K\nh_splits : Polynomial.Splits i h\nh_roots : Eq (Polynomial.map i h).roots (Singleton.singleton (i x))\n⊢ Eq h (HMul.hMul (Polynomial.C h.leadingCoeff) (HSub.hSub Polynomial.X (Polynomial.C x)))","decl":"theorem eq_X_sub_C_of_splits_of_single_root {x : K} {h : K[X]} (h_splits : Splits i h)\n    (h_roots : (h.map i).roots = {i x}) : h = C h.leadingCoeff * (X - C x) := by\n  apply Polynomial.map_injective _ i.injective\n  rw [eq_prod_roots_of_splits h_splits, h_roots]\n  simp\n\n"}
{"name":"Polynomial.mem_lift_of_splits_of_roots_mem_range","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"R : Type u_1\nK : Type v\ninst✝² : CommRing R\ninst✝¹ : Field K\ninst✝ : Algebra R K\nf : Polynomial K\nhs : Polynomial.Splits (RingHom.id K) f\nhm : f.Monic\nhr : ∀ (a : K), Membership.mem f.roots a → Membership.mem (algebraMap R K).range a\n⊢ Membership.mem (Polynomial.lifts (algebraMap R K)) f","decl":"variable (R) in\ntheorem mem_lift_of_splits_of_roots_mem_range [Algebra R K] {f : K[X]}\n    (hs : f.Splits (RingHom.id K)) (hm : f.Monic) (hr : ∀ a ∈ f.roots, a ∈ (algebraMap R K).range) :\n    f ∈ Polynomial.lifts (algebraMap R K) := by\n  rw [eq_prod_roots_of_monic_of_splits_id hm hs, lifts_iff_liftsRing]\n  refine Subring.multiset_prod_mem _ _ fun P hP => ?_\n  obtain ⟨b, hb, rfl⟩ := Multiset.mem_map.1 hP\n  exact Subring.sub_mem _ (X_mem_lifts _) (C'_mem_lifts (hr _ hb))\n\n"}
{"name":"Polynomial.splits_of_exists_multiset","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : Field K\ninst✝ : Field L\ni : RingHom K L\nf : Polynomial K\ns : Multiset L\nhs : Eq (Polynomial.map i f) (HMul.hMul (Polynomial.C (i f.leadingCoeff)) (Multiset.map (fun a => HSub.hSub Polynomial.X (Polynomial.C a)) s).prod)\n⊢ Polynomial.Splits i f","decl":"theorem splits_of_exists_multiset {f : K[X]} {s : Multiset L}\n    (hs : f.map i = C (i f.leadingCoeff) * (s.map fun a : L => X - C a).prod) : Splits i f :=\n  letI := Classical.decEq K\n  if hf0 : f = 0 then hf0.symm ▸ splits_zero i\n  else\n    Or.inr @fun p hp hdp => by\n      rw [irreducible_iff_prime] at hp\n      rw [hs, ← Multiset.prod_toList] at hdp\n      obtain hd | hd := hp.2.2 _ _ hdp\n      · refine (hp.2.1 <| isUnit_of_dvd_unit hd ?_).elim\n        exact isUnit_C.2 ((leadingCoeff_ne_zero.2 hf0).isUnit.map i)\n      · obtain ⟨q, hq, hd⟩ := hp.dvd_prod_iff.1 hd\n        obtain ⟨a, _, rfl⟩ := Multiset.mem_map.1 (Multiset.mem_toList.1 hq)\n        rw [degree_eq_degree_of_associated ((hp.dvd_prime_iff_associated <| prime_X_sub_C a).1 hd)]\n        exact degree_X_sub_C a\n\n"}
{"name":"Polynomial.splits_of_splits_id","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : Field K\ninst✝ : Field L\ni : RingHom K L\nf : Polynomial K\na✝ : Polynomial.Splits (RingHom.id K) f\n⊢ Polynomial.Splits i f","decl":"theorem splits_of_splits_id {f : K[X]} : Splits (RingHom.id K) f → Splits i f :=\n  UniqueFactorizationMonoid.induction_on_prime f (fun _ => splits_zero _)\n    (fun _ hu _ => splits_of_degree_le_one _ ((isUnit_iff_degree_eq_zero.1 hu).symm ▸ by decide))\n    fun _ p ha0 hp ih hfi =>\n    splits_mul _\n      (splits_of_degree_eq_one _\n        ((splits_of_splits_mul _ (mul_ne_zero hp.1 ha0) hfi).1.def.resolve_left hp.1 hp.irreducible\n          (by rw [map_id])))\n      (ih (splits_of_splits_mul _ (mul_ne_zero hp.1 ha0) hfi).2)\n\n"}
{"name":"Polynomial.splits_iff_exists_multiset","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : Field K\ninst✝ : Field L\ni : RingHom K L\nf : Polynomial K\n⊢ Iff (Polynomial.Splits i f) (Exists fun s => Eq (Polynomial.map i f) (HMul.hMul (Polynomial.C (i f.leadingCoeff)) (Multiset.map (fun a => HSub.hSub Polynomial.X (Polynomial.C a)) s).prod))","decl":"theorem splits_iff_exists_multiset {f : K[X]} :\n    Splits i f ↔\n      ∃ s : Multiset L, f.map i = C (i f.leadingCoeff) * (s.map fun a : L => X - C a).prod :=\n  ⟨fun hf => ⟨(f.map i).roots, eq_prod_roots_of_splits hf⟩, fun ⟨_, hs⟩ =>\n    splits_of_exists_multiset i hs⟩\n\n"}
{"name":"Polynomial.splits_of_comp","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"F : Type u\nK : Type v\nL : Type w\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Field F\ni : RingHom K L\nj : RingHom L F\nf : Polynomial K\nh : Polynomial.Splits (j.comp i) f\nroots_mem_range : ∀ (a : F), Membership.mem (Polynomial.map (j.comp i) f).roots a → Membership.mem j.range a\n⊢ Polynomial.Splits i f","decl":"theorem splits_of_comp (j : L →+* F) {f : K[X]} (h : Splits (j.comp i) f)\n    (roots_mem_range : ∀ a ∈ (f.map (j.comp i)).roots, a ∈ j.range) : Splits i f := by\n  choose lift lift_eq using roots_mem_range\n  rw [splits_iff_exists_multiset]\n  refine ⟨(f.map (j.comp i)).roots.pmap lift fun _ ↦ id, map_injective _ j.injective ?_⟩\n  conv_lhs => rw [Polynomial.map_map, eq_prod_roots_of_splits h]\n  simp_rw [Polynomial.map_mul, Polynomial.map_multiset_prod, Multiset.map_pmap, Polynomial.map_sub,\n    map_C, map_X, lift_eq, Multiset.pmap_eq_map]\n  rfl\n\n"}
{"name":"Polynomial.splits_id_of_splits","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝¹ : Field K\ninst✝ : Field L\ni : RingHom K L\nf : Polynomial K\nh : Polynomial.Splits i f\nroots_mem_range : ∀ (a : L), Membership.mem (Polynomial.map i f).roots a → Membership.mem i.range a\n⊢ Polynomial.Splits (RingHom.id K) f","decl":"theorem splits_id_of_splits {f : K[X]} (h : Splits i f)\n    (roots_mem_range : ∀ a ∈ (f.map i).roots, a ∈ i.range) : Splits (RingHom.id K) f :=\n  splits_of_comp (RingHom.id K) i h roots_mem_range\n\n"}
{"name":"Polynomial.splits_comp_of_splits","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"R : Type u_1\nK : Type v\nL : Type w\ninst✝² : CommRing R\ninst✝¹ : Field K\ninst✝ : Field L\ni : RingHom R K\nj : RingHom K L\nf : Polynomial R\nh : Polynomial.Splits i f\n⊢ Polynomial.Splits (j.comp i) f","decl":"theorem splits_comp_of_splits (i : R →+* K) (j : K →+* L) {f : R[X]} (h : Splits i f) :\n    Splits (j.comp i) f :=\n  (splits_map_iff i j).mp (splits_of_splits_id _ <| (splits_map_iff i <| .id K).mpr h)\n\n"}
{"name":"Polynomial.splits_of_algHom","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"R : Type u_1\nK : Type v\nL : Type w\ninst✝⁴ : CommRing R\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra R K\ninst✝ : Algebra R L\nf : Polynomial R\nh : Polynomial.Splits (algebraMap R K) f\ne : AlgHom R K L\n⊢ Polynomial.Splits (algebraMap R L) f","decl":"theorem splits_of_algHom {f : R[X]} (h : Splits (algebraMap R K) f) (e : K →ₐ[R] L) :\n    Splits (algebraMap R L) f := by\n  rw [← e.comp_algebraMap_of_tower R]; exact splits_comp_of_splits _ _ h\n\n"}
{"name":"Polynomial.splits_of_isScalarTower","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"R : Type u_1\nK : Type v\nL : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : Field K\ninst✝⁴ : Field L\ninst✝³ : Algebra R K\ninst✝² : Algebra R L\nf : Polynomial R\ninst✝¹ : Algebra K L\ninst✝ : IsScalarTower R K L\nh : Polynomial.Splits (algebraMap R K) f\n⊢ Polynomial.Splits (algebraMap R L) f","decl":"variable (L) in\ntheorem splits_of_isScalarTower {f : R[X]} [Algebra K L] [IsScalarTower R K L]\n    (h : Splits (algebraMap R K) f) : Splits (algebraMap R L) f :=\n  splits_of_algHom h (IsScalarTower.toAlgHom R K L)\n\n"}
{"name":"Polynomial.splits_iff_card_roots","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\ninst✝ : Field K\np : Polynomial K\n⊢ Iff (Polynomial.Splits (RingHom.id K) p) (Eq p.roots.card p.natDegree)","decl":"/-- A polynomial splits if and only if it has as many roots as its degree. -/\ntheorem splits_iff_card_roots {p : K[X]} :\n    Splits (RingHom.id K) p ↔ Multiset.card p.roots = p.natDegree := by\n  constructor\n  · intro H\n    rw [natDegree_eq_card_roots H, map_id]\n  · intro hroots\n    rw [splits_iff_exists_multiset (RingHom.id K)]\n    use p.roots\n    simp only [RingHom.id_apply, map_id]\n    exact (C_leadingCoeff_mul_prod_multiset_X_sub_C hroots).symm\n\n"}
{"name":"Polynomial.aeval_root_derivative_of_splits","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\nL : Type w\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\ninst✝ : DecidableEq L\nP : Polynomial K\nhmo : P.Monic\nhP : Polynomial.Splits (algebraMap K L) P\nr : L\nhr : Membership.mem (P.aroots L) r\n⊢ Eq ((Polynomial.aeval r) (Polynomial.derivative P)) (Multiset.map (fun a => HSub.hSub r a) ((P.aroots L).erase r)).prod","decl":"theorem aeval_root_derivative_of_splits [Algebra K L] [DecidableEq L] {P : K[X]} (hmo : P.Monic)\n    (hP : P.Splits (algebraMap K L)) {r : L} (hr : r ∈ P.aroots L) :\n    aeval r (Polynomial.derivative P) =\n    (((P.aroots L).erase r).map fun a => r - a).prod := by\n  replace hmo := hmo.map (algebraMap K L)\n  replace hP := (splits_id_iff_splits (algebraMap K L)).2 hP\n  rw [aeval_def, ← eval_map, ← derivative_map]\n  nth_rw 1 [eq_prod_roots_of_monic_of_splits_id hmo hP]\n  rw [eval_multiset_prod_X_sub_C_derivative hr]\n\n"}
{"name":"Polynomial.prod_roots_eq_coeff_zero_of_monic_of_splits","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\ninst✝ : Field K\nP : Polynomial K\nhmo : P.Monic\nhP : Polynomial.Splits (RingHom.id K) P\n⊢ Eq (P.coeff 0) (HMul.hMul (HPow.hPow (-1) P.natDegree) P.roots.prod)","decl":"/-- If `P` is a monic polynomial that splits, then `coeff P 0` equals the product of the roots. -/\ntheorem prod_roots_eq_coeff_zero_of_monic_of_splits {P : K[X]} (hmo : P.Monic)\n    (hP : P.Splits (RingHom.id K)) : coeff P 0 = (-1) ^ P.natDegree * P.roots.prod := by\n  nth_rw 1 [eq_prod_roots_of_monic_of_splits_id hmo hP]\n  rw [coeff_zero_eq_eval_zero, eval_multiset_prod, Multiset.map_map]\n  simp_rw [Function.comp_apply, eval_sub, eval_X, zero_sub, eval_C]\n  conv_lhs =>\n    congr\n    congr\n    ext\n    rw [neg_eq_neg_one_mul]\n  simp only [splits_iff_card_roots.1 hP, neg_mul, one_mul, Multiset.prod_map_neg]\n\n"}
{"name":"Polynomial.prod_roots_eq_coeff_zero_of_monic_of_split","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\ninst✝ : Field K\nP : Polynomial K\nhmo : P.Monic\nhP : Polynomial.Splits (RingHom.id K) P\n⊢ Eq (P.coeff 0) (HMul.hMul (HPow.hPow (-1) P.natDegree) P.roots.prod)","decl":"@[deprecated (since := \"2024-10-01\")]\nalias prod_roots_eq_coeff_zero_of_monic_of_split := prod_roots_eq_coeff_zero_of_monic_of_splits\n\n"}
{"name":"Polynomial.sum_roots_eq_nextCoeff_of_monic_of_split","module":"Mathlib.Algebra.Polynomial.Splits","initialProofState":"K : Type v\ninst✝ : Field K\nP : Polynomial K\nhmo : P.Monic\nhP : Polynomial.Splits (RingHom.id K) P\n⊢ Eq P.nextCoeff (Neg.neg P.roots.sum)","decl":"/-- If `P` is a monic polynomial that splits, then `P.nextCoeff` equals the sum of the roots. -/\ntheorem sum_roots_eq_nextCoeff_of_monic_of_split {P : K[X]} (hmo : P.Monic)\n    (hP : P.Splits (RingHom.id K)) : P.nextCoeff = -P.roots.sum := by\n  nth_rw 1 [eq_prod_roots_of_monic_of_splits_id hmo hP]\n  rw [Monic.nextCoeff_multiset_prod _ _ fun a ha => _]\n  · simp_rw [nextCoeff_X_sub_C, Multiset.sum_map_neg']\n  · simp only [monic_X_sub_C, implies_true]\n\n"}
