{"name":"IsDedekindDomainDvr.is_dvr_at_nonzero_prime","module":"Mathlib.RingTheory.DedekindDomain.Dvr","initialProofState":"A : Type u_1\ninst✝¹ : CommRing A\ninst✝ : IsDomain A\nself : IsDedekindDomainDvr A\nP : Ideal A\na✝ : Ne P Bot.bot\nx✝ : P.IsPrime\n⊢ IsDiscreteValuationRing (Localization.AtPrime P)","decl":"/-- A Dedekind domain is an integral domain that is Noetherian, and the\nlocalization at every nonzero prime is a discrete valuation ring.\n\nThis is equivalent to `IsDedekindDomain`.\n-/\nclass IsDedekindDomainDvr extends IsNoetherian A A : Prop where\n  is_dvr_at_nonzero_prime : ∀ P ≠ (⊥ : Ideal A), ∀ _ : P.IsPrime,\n    IsDiscreteValuationRing (Localization.AtPrime P)\n\n"}
{"name":"IsDedekindDomainDvr.toIsNoetherian","module":"Mathlib.RingTheory.DedekindDomain.Dvr","initialProofState":"A : Type u_1\ninst✝¹ : CommRing A\ninst✝ : IsDomain A\nself : IsDedekindDomainDvr A\n⊢ IsNoetherian A A","decl":"/-- A Dedekind domain is an integral domain that is Noetherian, and the\nlocalization at every nonzero prime is a discrete valuation ring.\n\nThis is equivalent to `IsDedekindDomain`.\n-/\nclass IsDedekindDomainDvr extends IsNoetherian A A : Prop where\n  is_dvr_at_nonzero_prime : ∀ P ≠ (⊥ : Ideal A), ∀ _ : P.IsPrime,\n    IsDiscreteValuationRing (Localization.AtPrime P)\n\n"}
{"name":"Ring.DimensionLEOne.localization","module":"Mathlib.RingTheory.DedekindDomain.Dvr","initialProofState":"R : Type u_2\nRₘ : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : IsDomain R\ninst✝² : CommRing Rₘ\ninst✝¹ : Algebra R Rₘ\nM : Submonoid R\ninst✝ : IsLocalization M Rₘ\nhM : LE.le M (nonZeroDivisors R)\nh : Ring.DimensionLEOne R\n⊢ Ring.DimensionLEOne Rₘ","decl":"/-- Localizing a domain of Krull dimension `≤ 1` gives another ring of Krull dimension `≤ 1`.\n\nNote that the same proof can/should be generalized to preserving any Krull dimension,\nonce we have a suitable definition.\n-/\ntheorem Ring.DimensionLEOne.localization {R : Type*} (Rₘ : Type*) [CommRing R] [IsDomain R]\n    [CommRing Rₘ] [Algebra R Rₘ] {M : Submonoid R} [IsLocalization M Rₘ] (hM : M ≤ R⁰)\n    [h : Ring.DimensionLEOne R] : Ring.DimensionLEOne Rₘ := ⟨by\n  intro p hp0 hpp\n  refine Ideal.isMaximal_def.mpr ⟨hpp.ne_top, Ideal.maximal_of_no_maximal fun P hpP hPm => ?_⟩\n  have hpP' : (⟨p, hpp⟩ : { p : Ideal Rₘ // p.IsPrime }) < ⟨P, hPm.isPrime⟩ := hpP\n  rw [← (IsLocalization.orderIsoOfPrime M Rₘ).lt_iff_lt] at hpP'\n  haveI : Ideal.IsPrime (Ideal.comap (algebraMap R Rₘ) p) :=\n    ((IsLocalization.orderIsoOfPrime M Rₘ) ⟨p, hpp⟩).2.1\n  haveI : Ideal.IsPrime (Ideal.comap (algebraMap R Rₘ) P) :=\n    ((IsLocalization.orderIsoOfPrime M Rₘ) ⟨P, hPm.isPrime⟩).2.1\n  have hlt : Ideal.comap (algebraMap R Rₘ) p < Ideal.comap (algebraMap R Rₘ) P := hpP'\n  refine h.not_lt_lt ⊥ (Ideal.comap _ _) (Ideal.comap _ _) ⟨?_, hlt⟩\n  exact IsLocalization.bot_lt_comap_prime _ _ hM _ hp0⟩\n\n"}
{"name":"IsLocalization.isDedekindDomain","module":"Mathlib.RingTheory.DedekindDomain.Dvr","initialProofState":"A : Type u_1\ninst✝⁶ : CommRing A\ninst✝⁵ : IsDomain A\ninst✝⁴ : IsDedekindDomain A\nM : Submonoid A\nhM : LE.le M (nonZeroDivisors A)\nAₘ : Type u_2\ninst✝³ : CommRing Aₘ\ninst✝² : IsDomain Aₘ\ninst✝¹ : Algebra A Aₘ\ninst✝ : IsLocalization M Aₘ\n⊢ IsDedekindDomain Aₘ","decl":"/-- The localization of a Dedekind domain is a Dedekind domain. -/\ntheorem IsLocalization.isDedekindDomain [IsDedekindDomain A] {M : Submonoid A} (hM : M ≤ A⁰)\n    (Aₘ : Type*) [CommRing Aₘ] [IsDomain Aₘ] [Algebra A Aₘ] [IsLocalization M Aₘ] :\n    IsDedekindDomain Aₘ := by\n  have h : ∀ y : M, IsUnit (algebraMap A (FractionRing A) y) := by\n    rintro ⟨y, hy⟩\n    exact IsUnit.mk0 _ (mt IsFractionRing.to_map_eq_zero_iff.mp (nonZeroDivisors.ne_zero (hM hy)))\n  letI : Algebra Aₘ (FractionRing A) := RingHom.toAlgebra (IsLocalization.lift h)\n  haveI : IsScalarTower A Aₘ (FractionRing A) :=\n    IsScalarTower.of_algebraMap_eq fun x => (IsLocalization.lift_eq h x).symm\n  haveI : IsFractionRing Aₘ (FractionRing A) :=\n    IsFractionRing.isFractionRing_of_isDomain_of_isLocalization M _ _\n  refine (isDedekindDomain_iff _ (FractionRing A)).mpr ⟨?_, ?_, ?_, ?_⟩\n  · infer_instance\n  · exact IsLocalization.isNoetherianRing M _ inferInstance\n  · exact Ring.DimensionLEOne.localization Aₘ hM\n  · intro x hx\n    obtain ⟨⟨y, y_mem⟩, hy⟩ := hx.exists_multiple_integral_of_isLocalization M _\n    obtain ⟨z, hz⟩ := (isIntegrallyClosed_iff _).mp IsDedekindRing.toIsIntegralClosure hy\n    refine ⟨IsLocalization.mk' Aₘ z ⟨y, y_mem⟩, (IsLocalization.lift_mk'_spec _ _ _ _).mpr ?_⟩\n    rw [hz, ← Algebra.smul_def]\n    rfl\n\n"}
{"name":"IsLocalization.AtPrime.isDedekindDomain","module":"Mathlib.RingTheory.DedekindDomain.Dvr","initialProofState":"A : Type u_1\ninst✝⁷ : CommRing A\ninst✝⁶ : IsDomain A\ninst✝⁵ : IsDedekindDomain A\nP : Ideal A\ninst✝⁴ : P.IsPrime\nAₘ : Type u_2\ninst✝³ : CommRing Aₘ\ninst✝² : IsDomain Aₘ\ninst✝¹ : Algebra A Aₘ\ninst✝ : IsLocalization.AtPrime Aₘ P\n⊢ IsDedekindDomain Aₘ","decl":"/-- The localization of a Dedekind domain at every nonzero prime ideal is a Dedekind domain. -/\ntheorem IsLocalization.AtPrime.isDedekindDomain [IsDedekindDomain A] (P : Ideal A) [P.IsPrime]\n    (Aₘ : Type*) [CommRing Aₘ] [IsDomain Aₘ] [Algebra A Aₘ] [IsLocalization.AtPrime Aₘ P] :\n    IsDedekindDomain Aₘ :=\n  IsLocalization.isDedekindDomain A P.primeCompl_le_nonZeroDivisors Aₘ\n\n"}
{"name":"Localization.AtPrime.isDedekindDomain","module":"Mathlib.RingTheory.DedekindDomain.Dvr","initialProofState":"A : Type u_1\ninst✝³ : CommRing A\ninst✝² : IsDomain A\ninst✝¹ : IsDedekindDomain A\nP : Ideal A\ninst✝ : P.IsPrime\n⊢ IsDedekindDomain (Localization.AtPrime P)","decl":"instance Localization.AtPrime.isDedekindDomain [IsDedekindDomain A] (P : Ideal A) [P.IsPrime] :\n    IsDedekindDomain (Localization.AtPrime P) :=\n  IsLocalization.AtPrime.isDedekindDomain A P _\n\n"}
{"name":"IsLocalization.AtPrime.not_isField","module":"Mathlib.RingTheory.DedekindDomain.Dvr","initialProofState":"A : Type u_1\ninst✝⁴ : CommRing A\ninst✝³ : IsDomain A\nP : Ideal A\nhP : Ne P Bot.bot\npP : P.IsPrime\nAₘ : Type u_2\ninst✝² : CommRing Aₘ\ninst✝¹ : Algebra A Aₘ\ninst✝ : IsLocalization.AtPrime Aₘ P\n⊢ Not (IsField Aₘ)","decl":"theorem IsLocalization.AtPrime.not_isField {P : Ideal A} (hP : P ≠ ⊥) [pP : P.IsPrime] (Aₘ : Type*)\n    [CommRing Aₘ] [Algebra A Aₘ] [IsLocalization.AtPrime Aₘ P] : ¬ IsField Aₘ := by\n  intro h\n  letI := h.toField\n  obtain ⟨x, x_mem, x_ne⟩ := P.ne_bot_iff.mp hP\n  exact\n    (IsLocalRing.maximalIdeal.isMaximal _).ne_top\n      (Ideal.eq_top_of_isUnit_mem _\n        ((IsLocalization.AtPrime.to_map_mem_maximal_iff Aₘ P _).mpr x_mem)\n        (isUnit_iff_ne_zero.mpr\n          ((map_ne_zero_iff (algebraMap A Aₘ)\n                (IsLocalization.injective Aₘ P.primeCompl_le_nonZeroDivisors)).mpr\n            x_ne)))\n\n"}
{"name":"IsLocalization.AtPrime.isDiscreteValuationRing_of_dedekind_domain","module":"Mathlib.RingTheory.DedekindDomain.Dvr","initialProofState":"A : Type u_1\ninst✝⁶ : CommRing A\ninst✝⁵ : IsDomain A\ninst✝⁴ : IsDedekindDomain A\nP : Ideal A\nhP : Ne P Bot.bot\npP : P.IsPrime\nAₘ : Type u_2\ninst✝³ : CommRing Aₘ\ninst✝² : IsDomain Aₘ\ninst✝¹ : Algebra A Aₘ\ninst✝ : IsLocalization.AtPrime Aₘ P\n⊢ IsDiscreteValuationRing Aₘ","decl":"/-- In a Dedekind domain, the localization at every nonzero prime ideal is a DVR. -/\ntheorem IsLocalization.AtPrime.isDiscreteValuationRing_of_dedekind_domain [IsDedekindDomain A]\n    {P : Ideal A} (hP : P ≠ ⊥) [pP : P.IsPrime] (Aₘ : Type*) [CommRing Aₘ] [IsDomain Aₘ]\n    [Algebra A Aₘ] [IsLocalization.AtPrime Aₘ P] : IsDiscreteValuationRing Aₘ := by\n  classical\n  letI : IsNoetherianRing Aₘ :=\n    IsLocalization.isNoetherianRing P.primeCompl _ IsDedekindRing.toIsNoetherian\n  letI : IsLocalRing Aₘ := IsLocalization.AtPrime.isLocalRing Aₘ P\n  have hnf := IsLocalization.AtPrime.not_isField A hP Aₘ\n  exact\n    ((IsDiscreteValuationRing.TFAE Aₘ hnf).out 0 2).mpr\n      (IsLocalization.AtPrime.isDedekindDomain A P _)\n\n"}
{"name":"IsDedekindDomain.isDedekindDomainDvr","module":"Mathlib.RingTheory.DedekindDomain.Dvr","initialProofState":"A : Type u_1\ninst✝² : CommRing A\ninst✝¹ : IsDomain A\ninst✝ : IsDedekindDomain A\n⊢ IsDedekindDomainDvr A","decl":"/-- Dedekind domains, in the sense of Noetherian integrally closed domains of Krull dimension ≤ 1,\nare also Dedekind domains in the sense of Noetherian domains where the localization at every\nnonzero prime ideal is a DVR. -/\ninstance IsDedekindDomain.isDedekindDomainDvr [IsDedekindDomain A] : IsDedekindDomainDvr A where\n  is_dvr_at_nonzero_prime := fun _ hP _ =>\n    IsLocalization.AtPrime.isDiscreteValuationRing_of_dedekind_domain A hP _\n\n"}
{"name":"IsDedekindDomainDvr.ring_dimensionLEOne","module":"Mathlib.RingTheory.DedekindDomain.Dvr","initialProofState":"A : Type u_1\ninst✝¹ : CommRing A\ninst✝ : IsDomain A\nh : IsDedekindDomainDvr A\n⊢ Ring.DimensionLEOne A","decl":"instance IsDedekindDomainDvr.ring_dimensionLEOne [h : IsDedekindDomainDvr A] :\n    Ring.DimensionLEOne A where\n  maximalOfPrime := by\n    intro p hp hpp\n    rcases p.exists_le_maximal (Ideal.IsPrime.ne_top hpp) with ⟨q, hq, hpq⟩\n    let f := (IsLocalization.orderIsoOfPrime q.primeCompl (Localization.AtPrime q)).symm\n    let P := f ⟨p, hpp, hpq.disjoint_compl_left⟩\n    let Q := f ⟨q, hq.isPrime, Set.disjoint_left.mpr fun _ a => a⟩\n    have hinj : Function.Injective (algebraMap A (Localization.AtPrime q)) :=\n      IsLocalization.injective (Localization.AtPrime q) q.primeCompl_le_nonZeroDivisors\n    have hp1 : P.1 ≠ ⊥ := fun x => hp ((p.map_eq_bot_iff_of_injective hinj).mp x)\n    have hq1 : Q.1 ≠ ⊥ :=\n      fun x => (ne_bot_of_le_ne_bot hp hpq) ((q.map_eq_bot_iff_of_injective hinj).mp x)\n    rcases (IsDiscreteValuationRing.iff_pid_with_one_nonzero_prime (Localization.AtPrime q)).mp\n      (h.is_dvr_at_nonzero_prime q (ne_bot_of_le_ne_bot hp hpq) hq.isPrime) with ⟨_, huq⟩\n    rw [show p = q from Subtype.val_inj.mpr <| f.injective <|\n      Subtype.val_inj.mp (huq.unique ⟨hp1, P.2⟩ ⟨hq1, Q.2⟩)]\n    exact hq\n\n"}
{"name":"IsDedekindDomainDvr.isIntegrallyClosed","module":"Mathlib.RingTheory.DedekindDomain.Dvr","initialProofState":"A : Type u_1\ninst✝¹ : CommRing A\ninst✝ : IsDomain A\nh : IsDedekindDomainDvr A\n⊢ IsIntegrallyClosed A","decl":"instance IsDedekindDomainDvr.isIntegrallyClosed [h : IsDedekindDomainDvr A] :\n    IsIntegrallyClosed A :=\n  IsIntegrallyClosed.of_localization_maximal <| fun p hp0 hpm ↦\n    let ⟨_, _⟩ := (IsDiscreteValuationRing.iff_pid_with_one_nonzero_prime\n      (Localization.AtPrime p)).mp (h.is_dvr_at_nonzero_prime p hp0 hpm.isPrime)\n    inferInstance\n\n"}
{"name":"IsDedekindDomainDvr.isDedekindDomain","module":"Mathlib.RingTheory.DedekindDomain.Dvr","initialProofState":"A : Type u_1\ninst✝² : CommRing A\ninst✝¹ : IsDomain A\ninst✝ : IsDedekindDomainDvr A\n⊢ IsDedekindDomain A","decl":"/-- If an integral domain is Noetherian, and the localization at every nonzero prime is\na discrete valuation ring, then it is a Dedekind domain. -/\ninstance IsDedekindDomainDvr.isDedekindDomain [IsDedekindDomainDvr A] : IsDedekindDomain A where\n"}
