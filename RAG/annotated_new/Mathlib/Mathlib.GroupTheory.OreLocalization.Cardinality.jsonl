{"name":"OreLocalization.oreDiv_one_surjective_of_finite_left","module":"Mathlib.GroupTheory.OreLocalization.Cardinality","initialProofState":"R : Type u\ninst✝³ : Monoid R\nS : Submonoid R\ninst✝² : OreLocalization.OreSet S\nX : Type v\ninst✝¹ : MulAction R X\ninst✝ : Finite (Subtype fun x => Membership.mem S x)\n⊢ Function.Surjective fun x => OreLocalization.oreDiv x 1","decl":"@[to_additive]\ntheorem oreDiv_one_surjective_of_finite_left [Finite S] :\n    Surjective (fun x ↦ x /ₒ (1 : ↥S) : X → OreLocalization S X) := by\n  refine OreLocalization.ind fun x s ↦ ?_\n  obtain ⟨i, j, hne, heq⟩ := Finite.exists_ne_map_eq_of_infinite (α := ℕ) (s ^ ·)\n  wlog hlt : j < i generalizing i j\n  · exact this j i hne.symm heq.symm (hne.lt_of_le (not_lt.1 hlt))\n  use s ^ (i - (j + 1)) • x\n  rw [oreDiv_eq_iff]\n  refine ⟨s ^ j, (s ^ (j + 1)).1, ?_, ?_⟩\n  · change s ^ j • x = s ^ (j + 1) • s ^ (i - (j + 1)) • x\n    rw [← mul_smul, ← pow_add, Nat.add_sub_cancel' hlt, heq]\n  · simp_rw [SubmonoidClass.coe_pow, OneMemClass.coe_one, mul_one, pow_succ]\n\n"}
{"name":"AddOreLocalization.oreSub_zero_surjective_of_finite_left","module":"Mathlib.GroupTheory.OreLocalization.Cardinality","initialProofState":"R : Type u\ninst✝³ : AddMonoid R\nS : AddSubmonoid R\ninst✝² : AddOreLocalization.AddOreSet S\nX : Type v\ninst✝¹ : AddAction R X\ninst✝ : Finite (Subtype fun x => Membership.mem S x)\n⊢ Function.Surjective fun x => AddOreLocalization.oreSub x 0","decl":"@[to_additive]\ntheorem oreDiv_one_surjective_of_finite_left [Finite S] :\n    Surjective (fun x ↦ x /ₒ (1 : ↥S) : X → OreLocalization S X) := by\n  refine OreLocalization.ind fun x s ↦ ?_\n  obtain ⟨i, j, hne, heq⟩ := Finite.exists_ne_map_eq_of_infinite (α := ℕ) (s ^ ·)\n  wlog hlt : j < i generalizing i j\n  · exact this j i hne.symm heq.symm (hne.lt_of_le (not_lt.1 hlt))\n  use s ^ (i - (j + 1)) • x\n  rw [oreDiv_eq_iff]\n  refine ⟨s ^ j, (s ^ (j + 1)).1, ?_, ?_⟩\n  · change s ^ j • x = s ^ (j + 1) • s ^ (i - (j + 1)) • x\n    rw [← mul_smul, ← pow_add, Nat.add_sub_cancel' hlt, heq]\n  · simp_rw [SubmonoidClass.coe_pow, OneMemClass.coe_one, mul_one, pow_succ]\n\n"}
{"name":"OreLocalization.oreDiv_one_surjective_of_finite_right","module":"Mathlib.GroupTheory.OreLocalization.Cardinality","initialProofState":"R : Type u\ninst✝³ : Monoid R\nS : Submonoid R\ninst✝² : OreLocalization.OreSet S\nX : Type v\ninst✝¹ : MulAction R X\ninst✝ : Finite X\n⊢ Function.Surjective fun x => OreLocalization.oreDiv x 1","decl":"@[to_additive]\ntheorem oreDiv_one_surjective_of_finite_right [Finite X] :\n    Surjective (fun x ↦ x /ₒ (1 : ↥S) : X → OreLocalization S X) := by\n  refine OreLocalization.ind fun x s ↦ ?_\n  obtain ⟨i, j, hne, heq⟩ := Finite.exists_ne_map_eq_of_infinite (α := ℕ) (s ^ · • x)\n  wlog hlt : j < i generalizing i j\n  · exact this j i hne.symm heq.symm (hne.lt_of_le (not_lt.1 hlt))\n  use s ^ (i - (j + 1)) • x\n  rw [oreDiv_eq_iff]\n  refine ⟨s ^ j, (s ^ (j + 1)).1, ?_, ?_⟩\n  · change s ^ j • x = s ^ (j + 1) • s ^ (i - (j + 1)) • x\n    rw [← mul_smul, ← pow_add, Nat.add_sub_cancel' hlt, heq]\n  · simp_rw [SubmonoidClass.coe_pow, OneMemClass.coe_one, mul_one, pow_succ]\n\n"}
{"name":"AddOreLocalization.oreSub_zero_surjective_of_finite_right","module":"Mathlib.GroupTheory.OreLocalization.Cardinality","initialProofState":"R : Type u\ninst✝³ : AddMonoid R\nS : AddSubmonoid R\ninst✝² : AddOreLocalization.AddOreSet S\nX : Type v\ninst✝¹ : AddAction R X\ninst✝ : Finite X\n⊢ Function.Surjective fun x => AddOreLocalization.oreSub x 0","decl":"@[to_additive]\ntheorem oreDiv_one_surjective_of_finite_right [Finite X] :\n    Surjective (fun x ↦ x /ₒ (1 : ↥S) : X → OreLocalization S X) := by\n  refine OreLocalization.ind fun x s ↦ ?_\n  obtain ⟨i, j, hne, heq⟩ := Finite.exists_ne_map_eq_of_infinite (α := ℕ) (s ^ · • x)\n  wlog hlt : j < i generalizing i j\n  · exact this j i hne.symm heq.symm (hne.lt_of_le (not_lt.1 hlt))\n  use s ^ (i - (j + 1)) • x\n  rw [oreDiv_eq_iff]\n  refine ⟨s ^ j, (s ^ (j + 1)).1, ?_, ?_⟩\n  · change s ^ j • x = s ^ (j + 1) • s ^ (i - (j + 1)) • x\n    rw [← mul_smul, ← pow_add, Nat.add_sub_cancel' hlt, heq]\n  · simp_rw [SubmonoidClass.coe_pow, OneMemClass.coe_one, mul_one, pow_succ]\n\n"}
{"name":"AddOreLocalization.numeratorHom_surjective_of_finite","module":"Mathlib.GroupTheory.OreLocalization.Cardinality","initialProofState":"R : Type u\ninst✝² : AddMonoid R\nS : AddSubmonoid R\ninst✝¹ : AddOreLocalization.AddOreSet S\ninst✝ : Finite (Subtype fun x => Membership.mem S x)\n⊢ Function.Surjective ⇑AddOreLocalization.numeratorHom","decl":"@[to_additive]\ntheorem numeratorHom_surjective_of_finite [Finite S] : Surjective (numeratorHom (S := S)) :=\n  oreDiv_one_surjective_of_finite_left S R\n\n"}
{"name":"OreLocalization.numeratorHom_surjective_of_finite","module":"Mathlib.GroupTheory.OreLocalization.Cardinality","initialProofState":"R : Type u\ninst✝² : Monoid R\nS : Submonoid R\ninst✝¹ : OreLocalization.OreSet S\ninst✝ : Finite (Subtype fun x => Membership.mem S x)\n⊢ Function.Surjective ⇑OreLocalization.numeratorHom","decl":"@[to_additive]\ntheorem numeratorHom_surjective_of_finite [Finite S] : Surjective (numeratorHom (S := S)) :=\n  oreDiv_one_surjective_of_finite_left S R\n\n"}
{"name":"AddOreLocalization.cardinalMk_le_max","module":"Mathlib.GroupTheory.OreLocalization.Cardinality","initialProofState":"R : Type u\ninst✝² : AddMonoid R\nS : AddSubmonoid R\ninst✝¹ : AddOreLocalization.AddOreSet S\nX : Type v\ninst✝ : AddAction R X\n⊢ LE.le (Cardinal.mk (AddOreLocalization S X)) (Max.max (Cardinal.lift.{v, u} (Cardinal.mk (Subtype fun x => Membership.mem S x))) (Cardinal.lift.{u, v} (Cardinal.mk X)))","decl":"@[to_additive]\ntheorem cardinalMk_le_max : #(OreLocalization S X) ≤ max (lift.{v} #S) (lift.{u} #X) := by\n  rcases finite_or_infinite X with _ | _\n  · have := lift_mk_le_lift_mk_of_surjective (oreDiv_one_surjective_of_finite_right S X)\n    rw [lift_umax.{v, u}, lift_id'] at this\n    exact le_max_of_le_right this\n  rcases finite_or_infinite S with _ | _\n  · have := lift_mk_le_lift_mk_of_surjective (oreDiv_one_surjective_of_finite_left S X)\n    rw [lift_umax.{v, u}, lift_id'] at this\n    exact le_max_of_le_right this\n  convert ← mk_le_of_surjective (show Surjective fun x : X × S ↦ x.1 /ₒ x.2 from\n    Quotient.mk''_surjective)\n  rw [mk_prod, mul_comm]\n  refine mul_eq_max ?_ ?_ <;> simp\n\n"}
{"name":"OreLocalization.cardinalMk_le_max","module":"Mathlib.GroupTheory.OreLocalization.Cardinality","initialProofState":"R : Type u\ninst✝² : Monoid R\nS : Submonoid R\ninst✝¹ : OreLocalization.OreSet S\nX : Type v\ninst✝ : MulAction R X\n⊢ LE.le (Cardinal.mk (OreLocalization S X)) (Max.max (Cardinal.lift.{v, u} (Cardinal.mk (Subtype fun x => Membership.mem S x))) (Cardinal.lift.{u, v} (Cardinal.mk X)))","decl":"@[to_additive]\ntheorem cardinalMk_le_max : #(OreLocalization S X) ≤ max (lift.{v} #S) (lift.{u} #X) := by\n  rcases finite_or_infinite X with _ | _\n  · have := lift_mk_le_lift_mk_of_surjective (oreDiv_one_surjective_of_finite_right S X)\n    rw [lift_umax.{v, u}, lift_id'] at this\n    exact le_max_of_le_right this\n  rcases finite_or_infinite S with _ | _\n  · have := lift_mk_le_lift_mk_of_surjective (oreDiv_one_surjective_of_finite_left S X)\n    rw [lift_umax.{v, u}, lift_id'] at this\n    exact le_max_of_le_right this\n  convert ← mk_le_of_surjective (show Surjective fun x : X × S ↦ x.1 /ₒ x.2 from\n    Quotient.mk''_surjective)\n  rw [mk_prod, mul_comm]\n  refine mul_eq_max ?_ ?_ <;> simp\n\n"}
{"name":"OreLocalization.cardinalMk_le","module":"Mathlib.GroupTheory.OreLocalization.Cardinality","initialProofState":"R : Type u\ninst✝¹ : Monoid R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\n⊢ LE.le (Cardinal.mk (OreLocalization S R)) (Cardinal.mk R)","decl":"@[to_additive]\ntheorem cardinalMk_le : #(OreLocalization S R) ≤ #R := by\n  convert ← cardinalMk_le_max S R\n  simp_rw [lift_id, max_eq_right_iff, mk_subtype_le]\n\n-- TODO: remove the `Commute` assumption\n"}
{"name":"AddOreLocalization.cardinalMk_le","module":"Mathlib.GroupTheory.OreLocalization.Cardinality","initialProofState":"R : Type u\ninst✝¹ : AddMonoid R\nS : AddSubmonoid R\ninst✝ : AddOreLocalization.AddOreSet S\n⊢ LE.le (Cardinal.mk (AddOreLocalization S R)) (Cardinal.mk R)","decl":"@[to_additive]\ntheorem cardinalMk_le : #(OreLocalization S R) ≤ #R := by\n  convert ← cardinalMk_le_max S R\n  simp_rw [lift_id, max_eq_right_iff, mk_subtype_le]\n\n-- TODO: remove the `Commute` assumption\n"}
{"name":"OreLocalization.cardinalMk_le_lift_cardinalMk_of_commute","module":"Mathlib.GroupTheory.OreLocalization.Cardinality","initialProofState":"R : Type u\ninst✝² : Monoid R\nS : Submonoid R\ninst✝¹ : OreLocalization.OreSet S\nX : Type v\ninst✝ : MulAction R X\nhc : ∀ (s s' : Subtype fun x => Membership.mem S x), Commute s s'\n⊢ LE.le (Cardinal.mk (OreLocalization S X)) (Cardinal.lift.{u, v} (Cardinal.mk X))","decl":"@[to_additive]\ntheorem cardinalMk_le_lift_cardinalMk_of_commute (hc : ∀ s s' : S, Commute s s') :\n    #(OreLocalization S X) ≤ lift.{u} #X := by\n  rcases finite_or_infinite X with _ | _\n  · have := lift_mk_le_lift_mk_of_surjective (oreDiv_one_surjective_of_finite_right S X)\n    rwa [lift_umax.{v, u}, lift_id'] at this\n  have key (x : X) (s s' : S) (h : s • x = s' • x) (hc : Commute s s') : x /ₒ s = x /ₒ s' := by\n    rw [oreDiv_eq_iff]\n    refine ⟨s, s'.1, h, ?_⟩\n    · exact_mod_cast hc\n  let i (x : X × S) := x.1 /ₒ x.2\n  have hsurj : Surjective i := Quotient.mk''_surjective\n  have hi := rightInverse_surjInv hsurj\n  let j := (fun x : X × S ↦ (x.1, x.2 • x.1)) ∘ surjInv hsurj\n  suffices Injective j by\n    have := lift_mk_le_lift_mk_of_injective this\n    rwa [lift_umax.{v, u}, lift_id', mk_prod, lift_id, lift_mul, mul_eq_self (by simp)] at this\n  intro y y' heq\n  rw [← hi y, ← hi y']\n  simp_rw [j, comp_apply, Prod.ext_iff] at heq\n  simp_rw [i]\n  set x := surjInv hsurj y\n  set x' := surjInv hsurj y'\n  obtain ⟨h1, h2⟩ := heq\n  rw [← h1] at h2 ⊢\n  exact key x.1 x.2 x'.2 h2 (hc _ _)\n\n"}
{"name":"AddOreLocalization.cardinalMk_le_lift_cardinalMk_of_addCommute","module":"Mathlib.GroupTheory.OreLocalization.Cardinality","initialProofState":"R : Type u\ninst✝² : AddMonoid R\nS : AddSubmonoid R\ninst✝¹ : AddOreLocalization.AddOreSet S\nX : Type v\ninst✝ : AddAction R X\nhc : ∀ (s s' : Subtype fun x => Membership.mem S x), AddCommute s s'\n⊢ LE.le (Cardinal.mk (AddOreLocalization S X)) (Cardinal.lift.{u, v} (Cardinal.mk X))","decl":"@[to_additive]\ntheorem cardinalMk_le_lift_cardinalMk_of_commute (hc : ∀ s s' : S, Commute s s') :\n    #(OreLocalization S X) ≤ lift.{u} #X := by\n  rcases finite_or_infinite X with _ | _\n  · have := lift_mk_le_lift_mk_of_surjective (oreDiv_one_surjective_of_finite_right S X)\n    rwa [lift_umax.{v, u}, lift_id'] at this\n  have key (x : X) (s s' : S) (h : s • x = s' • x) (hc : Commute s s') : x /ₒ s = x /ₒ s' := by\n    rw [oreDiv_eq_iff]\n    refine ⟨s, s'.1, h, ?_⟩\n    · exact_mod_cast hc\n  let i (x : X × S) := x.1 /ₒ x.2\n  have hsurj : Surjective i := Quotient.mk''_surjective\n  have hi := rightInverse_surjInv hsurj\n  let j := (fun x : X × S ↦ (x.1, x.2 • x.1)) ∘ surjInv hsurj\n  suffices Injective j by\n    have := lift_mk_le_lift_mk_of_injective this\n    rwa [lift_umax.{v, u}, lift_id', mk_prod, lift_id, lift_mul, mul_eq_self (by simp)] at this\n  intro y y' heq\n  rw [← hi y, ← hi y']\n  simp_rw [j, comp_apply, Prod.ext_iff] at heq\n  simp_rw [i]\n  set x := surjInv hsurj y\n  set x' := surjInv hsurj y'\n  obtain ⟨h1, h2⟩ := heq\n  rw [← h1] at h2 ⊢\n  exact key x.1 x.2 x'.2 h2 (hc _ _)\n\n"}
