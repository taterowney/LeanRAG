{"name":"List.length_flatten'","module":"Mathlib.Data.List.Flatten","initialProofState":"α : Type u_1\nL : List (List α)\n⊢ Eq L.flatten.length (Nat.sum (List.map List.length L))","decl":"set_option linter.deprecated false in\n/-- See `List.length_flatten` for the corresponding statement using `List.sum`. -/\n@[deprecated length_flatten (since := \"2024-10-17\")]\nlemma length_flatten' (L : List (List α)) : length (flatten L) = Nat.sum (map length L) := by\n  induction L <;> [rfl; simp only [*, flatten, map, Nat.sum_cons, length_append]]\n\n"}
{"name":"List.length_join'","module":"Mathlib.Data.List.Flatten","initialProofState":"α : Type u_1\nL : List (List α)\n⊢ Eq L.flatten.length (Nat.sum (List.map List.length L))","decl":"@[deprecated (since := \"2024-10-25\")] alias length_join' := length_flatten'\n\n"}
{"name":"List.countP_flatten'","module":"Mathlib.Data.List.Flatten","initialProofState":"α : Type u_1\np : α → Bool\nL : List (List α)\n⊢ Eq (List.countP p L.flatten) (Nat.sum (List.map (List.countP p) L))","decl":"set_option linter.deprecated false in\n/-- See `List.countP_flatten` for the corresponding statement using `List.sum`. -/\n@[deprecated countP_flatten (since := \"2024-10-17\")]\nlemma countP_flatten' (p : α → Bool) :\n    ∀ L : List (List α), countP p L.flatten = Nat.sum (L.map (countP p))\n  | [] => rfl\n  | a :: l => by rw [flatten, countP_append, map_cons, Nat.sum_cons, countP_flatten' _ l]\n\n"}
{"name":"List.countP_join'","module":"Mathlib.Data.List.Flatten","initialProofState":"α : Type u_1\np : α → Bool\nL : List (List α)\n⊢ Eq (List.countP p L.flatten) (Nat.sum (List.map (List.countP p) L))","decl":"@[deprecated (since := \"2024-10-25\")] alias countP_join' := countP_flatten'\n\n"}
{"name":"List.count_flatten'","module":"Mathlib.Data.List.Flatten","initialProofState":"α : Type u_1\ninst✝ : BEq α\nL : List (List α)\na : α\n⊢ Eq (List.count a L.flatten) (Nat.sum (List.map (List.count a) L))","decl":"set_option linter.deprecated false in\n/-- See `List.count_flatten` for the corresponding statement using `List.sum`. -/\n@[deprecated count_flatten (since := \"2024-10-17\")]\nlemma count_flatten' [BEq α] (L : List (List α)) (a : α) :\n    L.flatten.count a = Nat.sum (L.map (count a)) := countP_flatten' _ _\n\n"}
{"name":"List.count_join'","module":"Mathlib.Data.List.Flatten","initialProofState":"α : Type u_1\ninst✝ : BEq α\nL : List (List α)\na : α\n⊢ Eq (List.count a L.flatten) (Nat.sum (List.map (List.count a) L))","decl":"@[deprecated (since := \"2024-10-25\")] alias count_join' := count_flatten'\n\n"}
{"name":"List.length_flatMap'","module":"Mathlib.Data.List.Flatten","initialProofState":"α : Type u_1\nβ : Type u_2\nl : List α\nf : α → List β\n⊢ Eq (l.flatMap f).length (Nat.sum (List.map (Function.comp List.length f) l))","decl":"set_option linter.deprecated false in\n/-- See `List.length_flatMap` for the corresponding statement using `List.sum`. -/\n@[deprecated \"Use `List.length_flatMap`.\" (since := \"2024-10-17\")]\nlemma length_flatMap' (l : List α) (f : α → List β) :\n    length (l.flatMap f) = Nat.sum (map (length ∘ f) l) := by\n  rw [List.flatMap, length_flatten', map_map]\n\n"}
{"name":"List.length_bind'","module":"Mathlib.Data.List.Flatten","initialProofState":"α : Type u_1\nβ : Type u_2\nl : List α\nf : α → List β\n⊢ Eq (l.flatMap f).length (Nat.sum (List.map (Function.comp List.length f) l))","decl":"@[deprecated (since := \"2024-10-16\")] alias length_bind' := length_flatMap'\n\n"}
{"name":"List.countP_flatMap'","module":"Mathlib.Data.List.Flatten","initialProofState":"α : Type u_1\nβ : Type u_2\np : β → Bool\nl : List α\nf : α → List β\n⊢ Eq (List.countP p (l.flatMap f)) (Nat.sum (List.map (Function.comp (List.countP p) f) l))","decl":"set_option linter.deprecated false in\n/-- See `List.countP_flatMap` for the corresponding statement using `List.sum`. -/\n@[deprecated \"Use `List.countP_flatMap`.\" (since := \"2024-10-17\")]\nlemma countP_flatMap' (p : β → Bool) (l : List α) (f : α → List β) :\n    countP p (l.flatMap f) = Nat.sum (map (countP p ∘ f) l) := by\n  rw [List.flatMap, countP_flatten', map_map]\n\n"}
{"name":"List.countP_bind'","module":"Mathlib.Data.List.Flatten","initialProofState":"α : Type u_1\nβ : Type u_2\np : β → Bool\nl : List α\nf : α → List β\n⊢ Eq (List.countP p (l.flatMap f)) (Nat.sum (List.map (Function.comp (List.countP p) f) l))","decl":"@[deprecated (since := \"2024-10-16\")] alias countP_bind' := countP_flatMap'\n\n"}
{"name":"List.count_flatMap'","module":"Mathlib.Data.List.Flatten","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : BEq β\nl : List α\nf : α → List β\nx : β\n⊢ Eq (List.count x (l.flatMap f)) (Nat.sum (List.map (Function.comp (List.count x) f) l))","decl":"set_option linter.deprecated false in\n/-- See `List.count_flatMap` for the corresponding statement using `List.sum`. -/\n@[deprecated \"Use `List.count_flatMap`.\" (since := \"2024-10-17\")]\nlemma count_flatMap' [BEq β] (l : List α) (f : α → List β) (x : β) :\n    count x (l.flatMap f) = Nat.sum (map (count x ∘ f) l) := countP_flatMap' _ _ _\n\n"}
{"name":"List.count_bind'","module":"Mathlib.Data.List.Flatten","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : BEq β\nl : List α\nf : α → List β\nx : β\n⊢ Eq (List.count x (l.flatMap f)) (Nat.sum (List.map (Function.comp (List.count x) f) l))","decl":"@[deprecated (since := \"2024-10-16\")] alias count_bind' := count_flatMap'\n\n"}
{"name":"List.take_sum_flatten'","module":"Mathlib.Data.List.Flatten","initialProofState":"α : Type u_1\nL : List (List α)\ni : Nat\n⊢ Eq (List.take (Nat.sum (List.take i (List.map List.length L))) L.flatten) (List.take i L).flatten","decl":"set_option linter.deprecated false in\n/-- In a join, taking the first elements up to an index which is the sum of the lengths of the\nfirst `i` sublists, is the same as taking the join of the first `i` sublists.\n\nSee `List.take_sum_flatten` for the corresponding statement using `List.sum`. -/\n@[deprecated \"Use `List.take_sum_flatten`.\" (since := \"2024-10-17\")]\ntheorem take_sum_flatten' (L : List (List α)) (i : ℕ) :\n    L.flatten.take (Nat.sum ((L.map length).take i)) = (L.take i).flatten := by\n  induction L generalizing i\n  · simp\n  · cases i <;> simp [take_append, *]\n\n"}
{"name":"List.take_sum_join'","module":"Mathlib.Data.List.Flatten","initialProofState":"α : Type u_1\nL : List (List α)\ni : Nat\n⊢ Eq (List.take (Nat.sum (List.take i (List.map List.length L))) L.flatten) (List.take i L).flatten","decl":"@[deprecated (since := \"2024-10-25\")] alias take_sum_join' := take_sum_flatten'\n\n"}
{"name":"List.drop_sum_flatten'","module":"Mathlib.Data.List.Flatten","initialProofState":"α : Type u_1\nL : List (List α)\ni : Nat\n⊢ Eq (List.drop (Nat.sum (List.take i (List.map List.length L))) L.flatten) (List.drop i L).flatten","decl":"set_option linter.deprecated false in\n/-- In a join, dropping all the elements up to an index which is the sum of the lengths of the\nfirst `i` sublists, is the same as taking the join after dropping the first `i` sublists.\n\nSee `List.drop_sum_flatten` for the corresponding statement using `List.sum`. -/\n@[deprecated \"Use `List.drop_sum_flatten`.\" (since := \"2024-10-17\")]\ntheorem drop_sum_flatten' (L : List (List α)) (i : ℕ) :\n    L.flatten.drop (Nat.sum ((L.map length).take i)) = (L.drop i).flatten := by\n  induction L generalizing i\n  · simp\n  · cases i <;> simp [drop_append, *]\n\n"}
{"name":"List.drop_sum_join'","module":"Mathlib.Data.List.Flatten","initialProofState":"α : Type u_1\nL : List (List α)\ni : Nat\n⊢ Eq (List.drop (Nat.sum (List.take i (List.map List.length L))) L.flatten) (List.drop i L).flatten","decl":"@[deprecated (since := \"2024-10-25\")] alias drop_sum_join' := drop_sum_flatten'\n\n"}
{"name":"List.drop_take_succ_eq_cons_getElem","module":"Mathlib.Data.List.Flatten","initialProofState":"α : Type u_1\nL : List α\ni : Nat\nh : LT.lt i L.length\n⊢ Eq (List.drop i (List.take (HAdd.hAdd i 1) L)) (List.cons (GetElem.getElem L i ⋯) List.nil)","decl":"/-- Taking only the first `i+1` elements in a list, and then dropping the first `i` ones, one is\nleft with a list of length `1` made of the `i`-th element of the original list. -/\ntheorem drop_take_succ_eq_cons_getElem (L : List α) (i : Nat) (h : i < L.length) :\n    (L.take (i + 1)).drop i = [L[i]] := by\n  induction' L with head tail ih generalizing i\n  · exact (Nat.not_succ_le_zero i h).elim\n  rcases i with _ | i\n  · simp\n  · simpa using ih _ (by simpa using h)\n\n"}
{"name":"List.drop_take_succ_flatten_eq_getElem'","module":"Mathlib.Data.List.Flatten","initialProofState":"α : Type u_1\nL : List (List α)\ni : Nat\nh : LT.lt i L.length\n⊢ Eq (List.drop (Nat.sum (List.take i (List.map List.length L))) (List.take (Nat.sum (List.take (HAdd.hAdd i 1) (List.map List.length L))) L.flatten)) (GetElem.getElem L i ⋯)","decl":"set_option linter.deprecated false in\n/-- In a flatten of sublists, taking the slice between the indices `A` and `B - 1` gives back the\noriginal sublist of index `i` if `A` is the sum of the lengths of sublists of index `< i`, and\n`B` is the sum of the lengths of sublists of index `≤ i`.\n\nSee `List.drop_take_succ_flatten_eq_getElem` for the corresponding statement using `List.sum`. -/\n@[deprecated \"Use `List.drop_take_succ_flatten_eq_getElem`.\" (since := \"2024-10-17\")]\ntheorem drop_take_succ_flatten_eq_getElem' (L : List (List α)) (i : Nat) (h : i <  L.length) :\n    (L.flatten.take (Nat.sum ((L.map length).take (i + 1)))).drop\n      (Nat.sum ((L.map length).take i)) = L[i] := by\n  have : (L.map length).take i = ((L.take (i + 1)).map length).take i := by\n    simp [map_take, take_take, Nat.min_eq_left]\n  simp only [this, length_map, take_sum_flatten', drop_sum_flatten',\n    drop_take_succ_eq_cons_getElem, h, flatten, append_nil]\n\n"}
{"name":"List.drop_take_succ_join_eq_getElem'","module":"Mathlib.Data.List.Flatten","initialProofState":"α : Type u_1\nL : List (List α)\ni : Nat\nh : LT.lt i L.length\n⊢ Eq (List.drop (Nat.sum (List.take i (List.map List.length L))) (List.take (Nat.sum (List.take (HAdd.hAdd i 1) (List.map List.length L))) L.flatten)) (GetElem.getElem L i ⋯)","decl":"@[deprecated (since := \"2024-10-15\")]\nalias drop_take_succ_join_eq_getElem' := drop_take_succ_flatten_eq_getElem'\n\n"}
{"name":"List.flatten_drop_length_sub_one","module":"Mathlib.Data.List.Flatten","initialProofState":"α : Type u_1\nL : List (List α)\nh : Ne L List.nil\n⊢ Eq (List.drop (HSub.hSub L.length 1) L).flatten (L.getLast h)","decl":"theorem flatten_drop_length_sub_one {L : List (List α)} (h : L ≠ []) :\n    (L.drop (L.length - 1)).flatten = L.getLast h := by\n  induction L using List.reverseRecOn\n  · cases h rfl\n  · simp\n\n"}
{"name":"List.join_drop_length_sub_one","module":"Mathlib.Data.List.Flatten","initialProofState":"α : Type u_1\nL : List (List α)\nh : Ne L List.nil\n⊢ Eq (List.drop (HSub.hSub L.length 1) L).flatten (L.getLast h)","decl":"@[deprecated (since := \"2024-10-15\")] alias join_drop_length_sub_one := flatten_drop_length_sub_one\n\n"}
{"name":"List.append_flatten_map_append","module":"Mathlib.Data.List.Flatten","initialProofState":"α : Type u_1\nL : List (List α)\nx : List α\n⊢ Eq (HAppend.hAppend x (List.map (fun x_1 => HAppend.hAppend x_1 x) L).flatten) (HAppend.hAppend (List.map (fun x_1 => HAppend.hAppend x x_1) L).flatten x)","decl":"/-- We can rebracket `x ++ (l₁ ++ x) ++ (l₂ ++ x) ++ ... ++ (lₙ ++ x)` to\n`(x ++ l₁) ++ (x ++ l₂) ++ ... ++ (x ++ lₙ) ++ x` where `L = [l₁, l₂, ..., lₙ]`. -/\ntheorem append_flatten_map_append (L : List (List α)) (x : List α) :\n    x ++ (L.map (· ++ x)).flatten = (L.map (x ++ ·)).flatten ++ x := by\n  induction L with\n  | nil => rw [map_nil, flatten, append_nil, map_nil, flatten, nil_append]\n  | cons _ _ ih =>\n    rw [map_cons, flatten, map_cons, flatten, append_assoc, ih, append_assoc, append_assoc]\n\n"}
{"name":"List.append_join_map_append","module":"Mathlib.Data.List.Flatten","initialProofState":"α : Type u_1\nL : List (List α)\nx : List α\n⊢ Eq (HAppend.hAppend x (List.map (fun x_1 => HAppend.hAppend x_1 x) L).flatten) (HAppend.hAppend (List.map (fun x_1 => HAppend.hAppend x x_1) L).flatten x)","decl":"@[deprecated (since := \"2024-10-15\")] alias append_join_map_append := append_flatten_map_append\n\n"}
{"name":"List.sublist_join","module":"Mathlib.Data.List.Flatten","initialProofState":"α : Type u_1\nl : List α\nL : List (List α)\nh : Membership.mem L l\n⊢ l.Sublist L.flatten","decl":"@[deprecated \"No deprecation message was provided.\" (since := \"2024-08-15\")]\ntheorem sublist_join {l} {L : List (List α)} (h : l ∈ L) :\n    l <+ L.flatten :=\n  sublist_flatten_of_mem h\n\n"}
