{"name":"MvQPF.abs_repr","module":"Mathlib.Data.QPF.Multivariate.Basic","initialProofState":"n : Nat\nF : TypeVec.{u} n → Type u_1\nself : MvQPF F\nα : TypeVec.{u} n\nx : F α\n⊢ Eq (MvQPF.abs (MvQPF.repr x)) x","decl":"/-- Multivariate quotients of polynomial functors.\n-/\nclass MvQPF {n : ℕ} (F : TypeVec.{u} n → Type*) extends MvFunctor F where\n  P : MvPFunctor.{u} n\n  abs : ∀ {α}, P α → F α\n  repr : ∀ {α}, F α → P α\n  abs_repr : ∀ {α} (x : F α), abs (repr x) = x\n  abs_map : ∀ {α β} (f : α ⟹ β) (p : P α), abs (f <$$> p) = f <$$> abs p\n\n"}
{"name":"MvQPF.abs_map","module":"Mathlib.Data.QPF.Multivariate.Basic","initialProofState":"n : Nat\nF : TypeVec.{u} n → Type u_1\nself : MvQPF F\nα β : TypeVec.{u} n\nf : α.Arrow β\np : ↑(MvQPF.P F) α\n⊢ Eq (MvQPF.abs (MvFunctor.map f p)) (MvFunctor.map f (MvQPF.abs p))","decl":"/-- Multivariate quotients of polynomial functors.\n-/\nclass MvQPF {n : ℕ} (F : TypeVec.{u} n → Type*) extends MvFunctor F where\n  P : MvPFunctor.{u} n\n  abs : ∀ {α}, P α → F α\n  repr : ∀ {α}, F α → P α\n  abs_repr : ∀ {α} (x : F α), abs (repr x) = x\n  abs_map : ∀ {α β} (f : α ⟹ β) (p : P α), abs (f <$$> p) = f <$$> abs p\n\n"}
{"name":"MvQPF.id_map","module":"Mathlib.Data.QPF.Multivariate.Basic","initialProofState":"n : Nat\nF : TypeVec.{u} n → Type u_1\nq : MvQPF F\nα : TypeVec.{u} n\nx : F α\n⊢ Eq (MvFunctor.map TypeVec.id x) x","decl":"protected theorem id_map {α : TypeVec n} (x : F α) : TypeVec.id <$$> x = x := by\n  rw [← abs_repr x, ← abs_map]\n  rfl\n\n"}
{"name":"MvQPF.comp_map","module":"Mathlib.Data.QPF.Multivariate.Basic","initialProofState":"n : Nat\nF : TypeVec.{u} n → Type u_1\nq : MvQPF F\nα β γ : TypeVec.{u} n\nf : α.Arrow β\ng : β.Arrow γ\nx : F α\n⊢ Eq (MvFunctor.map (TypeVec.comp g f) x) (MvFunctor.map g (MvFunctor.map f x))","decl":"@[simp]\ntheorem comp_map {α β γ : TypeVec n} (f : α ⟹ β) (g : β ⟹ γ) (x : F α) :\n    (g ⊚ f) <$$> x = g <$$> f <$$> x := by\n  rw [← abs_repr x, ← abs_map, ← abs_map, ← abs_map]\n  rfl\n\n"}
{"name":"MvQPF.lawfulMvFunctor","module":"Mathlib.Data.QPF.Multivariate.Basic","initialProofState":"n : Nat\nF : TypeVec.{u} n → Type u_1\nq : MvQPF F\n⊢ LawfulMvFunctor F","decl":"instance (priority := 100) lawfulMvFunctor : LawfulMvFunctor F where\n  id_map := @MvQPF.id_map n F _\n  comp_map := @comp_map n F _\n\n-- Lifting predicates and relations\n"}
{"name":"MvQPF.liftP_iff","module":"Mathlib.Data.QPF.Multivariate.Basic","initialProofState":"n : Nat\nF : TypeVec.{u} n → Type u_1\nq : MvQPF F\nα : TypeVec.{u} n\np : ⦃i : Fin2 n⦄ → α i → Prop\nx : F α\n⊢ Iff (MvFunctor.LiftP p x) (Exists fun a => Exists fun f => And (Eq x (MvQPF.abs ⟨a, f⟩)) (∀ (i : Fin2 n) (j : (MvQPF.P F).B a i), p (f i j)))","decl":"theorem liftP_iff {α : TypeVec n} (p : ∀ ⦃i⦄, α i → Prop) (x : F α) :\n    LiftP p x ↔ ∃ a f, x = abs ⟨a, f⟩ ∧ ∀ i j, p (f i j) := by\n  constructor\n  · rintro ⟨y, hy⟩\n    cases' h : repr y with a f\n    use a, fun i j => (f i j).val\n    constructor\n    · rw [← hy, ← abs_repr y, h, ← abs_map]; rfl\n    intro i j\n    apply (f i j).property\n  rintro ⟨a, f, h₀, h₁⟩\n  use abs ⟨a, fun i j => ⟨f i j, h₁ i j⟩⟩\n  rw [← abs_map, h₀]; rfl\n\n"}
{"name":"MvQPF.liftR_iff","module":"Mathlib.Data.QPF.Multivariate.Basic","initialProofState":"n : Nat\nF : TypeVec.{u} n → Type u_1\nq : MvQPF F\nα : TypeVec.{u} n\nr : {i : Fin2 n} → α i → α i → Prop\nx y : F α\n⊢ Iff (MvFunctor.LiftR (fun {i} => r) x y) (Exists fun a => Exists fun f₀ => Exists fun f₁ => And (Eq x (MvQPF.abs ⟨a, f₀⟩)) (And (Eq y (MvQPF.abs ⟨a, f₁⟩)) (∀ (i : Fin2 n) (j : (MvQPF.P F).B a i), r (f₀ i j) (f₁ i j))))","decl":"theorem liftR_iff {α : TypeVec n} (r : ∀ /- ⦃i⦄ -/ {i}, α i → α i → Prop) (x y : F α) :\n    LiftR r x y ↔ ∃ a f₀ f₁, x = abs ⟨a, f₀⟩ ∧ y = abs ⟨a, f₁⟩ ∧ ∀ i j, r (f₀ i j) (f₁ i j) := by\n  constructor\n  · rintro ⟨u, xeq, yeq⟩\n    cases' h : repr u with a f\n    use a, fun i j => (f i j).val.fst, fun i j => (f i j).val.snd\n    constructor\n    · rw [← xeq, ← abs_repr u, h, ← abs_map]; rfl\n    constructor\n    · rw [← yeq, ← abs_repr u, h, ← abs_map]; rfl\n    intro i j\n    exact (f i j).property\n  rintro ⟨a, f₀, f₁, xeq, yeq, h⟩\n  use abs ⟨a, fun i j => ⟨(f₀ i j, f₁ i j), h i j⟩⟩\n  dsimp; constructor\n  · rw [xeq, ← abs_map]; rfl\n  rw [yeq, ← abs_map]; rfl\n\n"}
{"name":"MvQPF.mem_supp","module":"Mathlib.Data.QPF.Multivariate.Basic","initialProofState":"n : Nat\nF : TypeVec.{u} n → Type u_1\nq : MvQPF F\nα : TypeVec.{u} n\nx : F α\ni : Fin2 n\nu : α i\n⊢ Iff (Membership.mem (MvFunctor.supp x i) u) (∀ (a : (MvQPF.P F).A) (f : ((MvQPF.P F).B a).Arrow α), Eq (MvQPF.abs ⟨a, f⟩) x → Membership.mem (Set.image (f i) Set.univ) u)","decl":"theorem mem_supp {α : TypeVec n} (x : F α) (i) (u : α i) :\n    u ∈ supp x i ↔ ∀ a f, abs ⟨a, f⟩ = x → u ∈ f i '' univ := by\n  rw [supp]; dsimp; constructor\n  · intro h a f haf\n    have : LiftP (fun i u => u ∈ f i '' univ) x := by\n      rw [liftP_iff]\n      refine ⟨a, f, haf.symm, ?_⟩\n      intro i u\n      exact mem_image_of_mem _ (mem_univ _)\n    exact h this\n  intro h p; rw [liftP_iff]\n  rintro ⟨a, f, xeq, h'⟩\n  rcases h a f xeq.symm with ⟨i, _, hi⟩\n  rw [← hi]; apply h'\n\n"}
{"name":"MvQPF.supp_eq","module":"Mathlib.Data.QPF.Multivariate.Basic","initialProofState":"n : Nat\nF : TypeVec.{u} n → Type u_1\nq : MvQPF F\nα : TypeVec.{u} n\ni : Fin2 n\nx : F α\n⊢ Eq (MvFunctor.supp x i) (setOf fun u => ∀ (a : (MvQPF.P F).A) (f : ((MvQPF.P F).B a).Arrow α), Eq (MvQPF.abs ⟨a, f⟩) x → Membership.mem (Set.image (f i) Set.univ) u)","decl":"theorem supp_eq {α : TypeVec n} {i} (x : F α) :\n    supp x i = { u | ∀ a f, abs ⟨a, f⟩ = x → u ∈ f i '' univ } := by ext; apply mem_supp\n\n"}
{"name":"MvQPF.has_good_supp_iff","module":"Mathlib.Data.QPF.Multivariate.Basic","initialProofState":"n : Nat\nF : TypeVec.{u} n → Type u_1\nq : MvQPF F\nα : TypeVec.{u} n\nx : F α\n⊢ Iff (∀ (p : (i : Fin2 n) → α i → Prop), Iff (MvFunctor.LiftP p x) (∀ (i : Fin2 n) (u : α i), Membership.mem (MvFunctor.supp x i) u → p i u)) (Exists fun a => Exists fun f => And (Eq (MvQPF.abs ⟨a, f⟩) x) (∀ (i : Fin2 n) (a' : (MvQPF.P F).A) (f' : ((MvQPF.P F).B a').Arrow α), Eq (MvQPF.abs ⟨a', f'⟩) x → HasSubset.Subset (Set.image (f i) Set.univ) (Set.image (f' i) Set.univ)))","decl":"theorem has_good_supp_iff {α : TypeVec n} (x : F α) :\n    (∀ p, LiftP p x ↔ ∀ (i), ∀ u ∈ supp x i, p i u) ↔\n      ∃ a f, abs ⟨a, f⟩ = x ∧ ∀ i a' f', abs ⟨a', f'⟩ = x → f i '' univ ⊆ f' i '' univ := by\n  constructor\n  · intro h\n    have : LiftP (supp x) x := by rw [h]; introv; exact id\n    rw [liftP_iff] at this\n    rcases this with ⟨a, f, xeq, h'⟩\n    refine ⟨a, f, xeq.symm, ?_⟩\n    intro a' f' h''\n    rintro hu u ⟨j, _h₂, hfi⟩\n    have hh : u ∈ supp x a' := by rw [← hfi]; apply h'\n    exact (mem_supp x _ u).mp hh _ _ hu\n  rintro ⟨a, f, xeq, h⟩ p; rw [liftP_iff]; constructor\n  · rintro ⟨a', f', xeq', h'⟩ i u usuppx\n    rcases (mem_supp x _ u).mp (@usuppx) a' f' xeq'.symm with ⟨i, _, f'ieq⟩\n    rw [← f'ieq]\n    apply h'\n  intro h'\n  refine ⟨a, f, xeq.symm, ?_⟩; intro j y\n  apply h'; rw [mem_supp]\n  intro a' f' xeq'\n  apply h _ a' f' xeq'\n  apply mem_image_of_mem _ (mem_univ _)\n\n"}
{"name":"MvQPF.supp_eq_of_isUniform","module":"Mathlib.Data.QPF.Multivariate.Basic","initialProofState":"n : Nat\nF : TypeVec.{u} n → Type u_1\nq : MvQPF F\nh : MvQPF.IsUniform\nα : TypeVec.{u} n\na : (MvQPF.P F).A\nf : ((MvQPF.P F).B a).Arrow α\ni : Fin2 n\n⊢ Eq (MvFunctor.supp (MvQPF.abs ⟨a, f⟩) i) (Set.image (f i) Set.univ)","decl":"theorem supp_eq_of_isUniform (h : q.IsUniform) {α : TypeVec n} (a : q.P.A) (f : q.P.B a ⟹ α) :\n    ∀ i, supp (abs ⟨a, f⟩) i = f i '' univ := by\n  intro; ext u; rw [mem_supp]; constructor\n  · intro h'\n    apply h' _ _ rfl\n  intro h' a' f' e\n  rw [← h _ _ _ _ e.symm]; apply h'\n\n"}
{"name":"MvQPF.liftP_iff_of_isUniform","module":"Mathlib.Data.QPF.Multivariate.Basic","initialProofState":"n : Nat\nF : TypeVec.{u} n → Type u_1\nq : MvQPF F\nh : MvQPF.IsUniform\nα : TypeVec.{u} n\nx : F α\np : (i : Fin2 n) → α i → Prop\n⊢ Iff (MvFunctor.LiftP p x) (∀ (i : Fin2 n) (u : α i), Membership.mem (MvFunctor.supp x i) u → p i u)","decl":"theorem liftP_iff_of_isUniform (h : q.IsUniform) {α : TypeVec n} (x : F α) (p : ∀ i, α i → Prop) :\n    LiftP p x ↔ ∀ (i), ∀ u ∈ supp x i, p i u := by\n  rw [liftP_iff, ← abs_repr x]\n  cases' repr x with a f; constructor\n  · rintro ⟨a', f', abseq, hf⟩ u\n    rw [supp_eq_of_isUniform h, h _ _ _ _ abseq]\n    rintro b ⟨i, _, hi⟩\n    rw [← hi]\n    apply hf\n  intro h'\n  refine ⟨a, f, rfl, fun _ i => h' _ _ ?_⟩\n  rw [supp_eq_of_isUniform h]\n  exact ⟨i, mem_univ i, rfl⟩\n\n"}
{"name":"MvQPF.supp_map","module":"Mathlib.Data.QPF.Multivariate.Basic","initialProofState":"n : Nat\nF : TypeVec.{u} n → Type u_1\nq : MvQPF F\nh : MvQPF.IsUniform\nα β : TypeVec.{u} n\ng : α.Arrow β\nx : F α\ni : Fin2 n\n⊢ Eq (MvFunctor.supp (MvFunctor.map g x) i) (Set.image (g i) (MvFunctor.supp x i))","decl":"theorem supp_map (h : q.IsUniform) {α β : TypeVec n} (g : α ⟹ β) (x : F α) (i) :\n    supp (g <$$> x) i = g i '' supp x i := by\n  rw [← abs_repr x]; cases' repr x with a f; rw [← abs_map, MvPFunctor.map_eq]\n  rw [supp_eq_of_isUniform h, supp_eq_of_isUniform h, ← image_comp]\n  rfl\n\n"}
{"name":"MvQPF.suppPreservation_iff_isUniform","module":"Mathlib.Data.QPF.Multivariate.Basic","initialProofState":"n : Nat\nF : TypeVec.{u} n → Type u_1\nq : MvQPF F\n⊢ Iff MvQPF.SuppPreservation MvQPF.IsUniform","decl":"theorem suppPreservation_iff_isUniform : q.SuppPreservation ↔ q.IsUniform := by\n  constructor\n  · intro h α a a' f f' h' i\n    rw [← MvPFunctor.supp_eq, ← MvPFunctor.supp_eq, ← h, h', h]\n  · rintro h α ⟨a, f⟩\n    ext\n    rwa [supp_eq_of_isUniform, MvPFunctor.supp_eq]\n\n"}
{"name":"MvQPF.suppPreservation_iff_liftpPreservation","module":"Mathlib.Data.QPF.Multivariate.Basic","initialProofState":"n : Nat\nF : TypeVec.{u} n → Type u_1\nq : MvQPF F\n⊢ Iff MvQPF.SuppPreservation MvQPF.LiftPPreservation","decl":"theorem suppPreservation_iff_liftpPreservation : q.SuppPreservation ↔ q.LiftPPreservation := by\n  constructor <;> intro h\n  · rintro α p ⟨a, f⟩\n    have h' := h\n    rw [suppPreservation_iff_isUniform] at h'\n    dsimp only [SuppPreservation, supp] at h\n    simp only [liftP_iff_of_isUniform, supp_eq_of_isUniform, MvPFunctor.liftP_iff', h',\n      image_univ, mem_range, exists_imp]\n    constructor <;> intros <;> subst_vars <;> solve_by_elim\n  · rintro α ⟨a, f⟩\n    simp only [LiftPPreservation] at h\n    ext\n    simp only [supp, h, mem_setOf_eq]\n\n"}
{"name":"MvQPF.liftpPreservation_iff_uniform","module":"Mathlib.Data.QPF.Multivariate.Basic","initialProofState":"n : Nat\nF : TypeVec.{u} n → Type u_1\nq : MvQPF F\n⊢ Iff MvQPF.LiftPPreservation MvQPF.IsUniform","decl":"theorem liftpPreservation_iff_uniform : q.LiftPPreservation ↔ q.IsUniform := by\n  rw [← suppPreservation_iff_liftpPreservation, suppPreservation_iff_isUniform]\n\n"}
