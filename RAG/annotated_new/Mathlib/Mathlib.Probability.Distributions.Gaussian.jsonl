{"name":"ProbabilityTheory.gaussianPDFReal_def","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\n⊢ Eq (ProbabilityTheory.gaussianPDFReal μ v) fun x => HMul.hMul (Inv.inv (HMul.hMul (HMul.hMul 2 Real.pi) ↑v).sqrt) (Real.exp (HDiv.hDiv (Neg.neg (HPow.hPow (HSub.hSub x μ) 2)) (HMul.hMul 2 ↑v)))","decl":"lemma gaussianPDFReal_def (μ : ℝ) (v : ℝ≥0) :\n    gaussianPDFReal μ v =\n      fun x ↦ (Real.sqrt (2 * π * v))⁻¹ * rexp (- (x - μ)^2 / (2 * v)) := rfl\n\n"}
{"name":"ProbabilityTheory.gaussianPDFReal_zero_var","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"m : Real\n⊢ Eq (ProbabilityTheory.gaussianPDFReal m 0) 0","decl":"@[simp]\nlemma gaussianPDFReal_zero_var (m : ℝ) : gaussianPDFReal m 0 = 0 := by\n  ext1 x\n  simp [gaussianPDFReal]\n\n"}
{"name":"ProbabilityTheory.gaussianPDFReal_pos","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\nx : Real\nhv : Ne v 0\n⊢ LT.lt 0 (ProbabilityTheory.gaussianPDFReal μ v x)","decl":"/-- The gaussian pdf is positive when the variance is not zero. -/\nlemma gaussianPDFReal_pos (μ : ℝ) (v : ℝ≥0) (x : ℝ) (hv : v ≠ 0) : 0 < gaussianPDFReal μ v x := by\n  rw [gaussianPDFReal]\n  positivity\n\n"}
{"name":"ProbabilityTheory.gaussianPDFReal_nonneg","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\nx : Real\n⊢ LE.le 0 (ProbabilityTheory.gaussianPDFReal μ v x)","decl":"/-- The gaussian pdf is nonnegative. -/\nlemma gaussianPDFReal_nonneg (μ : ℝ) (v : ℝ≥0) (x : ℝ) : 0 ≤ gaussianPDFReal μ v x := by\n  rw [gaussianPDFReal]\n  positivity\n\n"}
{"name":"ProbabilityTheory.measurable_gaussianPDFReal","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\n⊢ Measurable (ProbabilityTheory.gaussianPDFReal μ v)","decl":"/-- The gaussian pdf is measurable. -/\nlemma measurable_gaussianPDFReal (μ : ℝ) (v : ℝ≥0) : Measurable (gaussianPDFReal μ v) :=\n  (((measurable_id.add_const _).pow_const _).neg.div_const _).exp.const_mul _\n\n"}
{"name":"ProbabilityTheory.stronglyMeasurable_gaussianPDFReal","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\n⊢ MeasureTheory.StronglyMeasurable (ProbabilityTheory.gaussianPDFReal μ v)","decl":"/-- The gaussian pdf is strongly measurable. -/\nlemma stronglyMeasurable_gaussianPDFReal (μ : ℝ) (v : ℝ≥0) :\n    StronglyMeasurable (gaussianPDFReal μ v) :=\n  (measurable_gaussianPDFReal μ v).stronglyMeasurable\n\n"}
{"name":"ProbabilityTheory.integrable_gaussianPDFReal","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\n⊢ MeasureTheory.Integrable (ProbabilityTheory.gaussianPDFReal μ v) MeasureTheory.MeasureSpace.volume","decl":"@[fun_prop]\nlemma integrable_gaussianPDFReal (μ : ℝ) (v : ℝ≥0) :\n    Integrable (gaussianPDFReal μ v) := by\n  rw [gaussianPDFReal_def]\n  by_cases hv : v = 0\n  · simp [hv]\n  let g : ℝ → ℝ := fun x ↦ (√(2 * π * v))⁻¹ * rexp (- x ^ 2 / (2 * v))\n  have hg : Integrable g := by\n    suffices g = fun x ↦ (√(2 * π * v))⁻¹ * rexp (- (2 * v)⁻¹ * x ^ 2) by\n      rw [this]\n      refine (integrable_exp_neg_mul_sq ?_).const_mul (√(2 * π * v))⁻¹\n      simp [lt_of_le_of_ne (zero_le _) (Ne.symm hv)]\n    ext x\n    simp only [g, zero_lt_two, mul_nonneg_iff_of_pos_left, NNReal.zero_le_coe, Real.sqrt_mul',\n      mul_inv_rev, NNReal.coe_mul, NNReal.coe_inv, NNReal.coe_ofNat, neg_mul, mul_eq_mul_left_iff,\n      Real.exp_eq_exp, mul_eq_zero, inv_eq_zero, Real.sqrt_eq_zero, NNReal.coe_eq_zero, hv,\n      false_or]\n    rw [mul_comm]\n    left\n    field_simp\n  exact Integrable.comp_sub_right hg μ\n\n"}
{"name":"ProbabilityTheory.lintegral_gaussianPDFReal_eq_one","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\nh : Ne v 0\n⊢ Eq (MeasureTheory.lintegral MeasureTheory.MeasureSpace.volume fun x => ENNReal.ofReal (ProbabilityTheory.gaussianPDFReal μ v x)) 1","decl":"/-- The gaussian distribution pdf integrates to 1 when the variance is not zero. -/\nlemma lintegral_gaussianPDFReal_eq_one (μ : ℝ) {v : ℝ≥0} (h : v ≠ 0) :\n    ∫⁻ x, ENNReal.ofReal (gaussianPDFReal μ v x) = 1 := by\n  rw [← ENNReal.toReal_eq_one_iff]\n  have hfm : AEStronglyMeasurable (gaussianPDFReal μ v) volume :=\n    (stronglyMeasurable_gaussianPDFReal μ v).aestronglyMeasurable\n  have hf : 0 ≤ₐₛ gaussianPDFReal μ v := ae_of_all _ (gaussianPDFReal_nonneg μ v)\n  rw [← integral_eq_lintegral_of_nonneg_ae hf hfm]\n  simp only [gaussianPDFReal, zero_lt_two, mul_nonneg_iff_of_pos_right, one_div,\n    Nat.cast_ofNat, integral_mul_left]\n  rw [integral_sub_right_eq_self (μ := volume) (fun a ↦ rexp (-a ^ 2 / ((2 : ℝ) * v))) μ]\n  simp only [zero_lt_two, mul_nonneg_iff_of_pos_right, div_eq_inv_mul, mul_inv_rev,\n    mul_neg]\n  simp_rw [← neg_mul]\n  rw [neg_mul, integral_gaussian, ← Real.sqrt_inv, ← Real.sqrt_mul]\n  · field_simp\n    ring\n  · positivity\n\n"}
{"name":"ProbabilityTheory.integral_gaussianPDFReal_eq_one","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\nhv : Ne v 0\n⊢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => ProbabilityTheory.gaussianPDFReal μ v x) 1","decl":"/-- The gaussian distribution pdf integrates to 1 when the variance is not zero. -/\nlemma integral_gaussianPDFReal_eq_one (μ : ℝ) {v : ℝ≥0} (hv : v ≠ 0) :\n    ∫ x, gaussianPDFReal μ v x = 1 := by\n  have h := lintegral_gaussianPDFReal_eq_one μ hv\n  rw [← ofReal_integral_eq_lintegral_ofReal (integrable_gaussianPDFReal _ _)\n    (ae_of_all _ (gaussianPDFReal_nonneg _ _)), ← ENNReal.ofReal_one] at h\n  rwa [← ENNReal.ofReal_eq_ofReal_iff (integral_nonneg (gaussianPDFReal_nonneg _ _)) zero_le_one]\n\n"}
{"name":"ProbabilityTheory.gaussianPDFReal_sub","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\nx y : Real\n⊢ Eq (ProbabilityTheory.gaussianPDFReal μ v (HSub.hSub x y)) (ProbabilityTheory.gaussianPDFReal (HAdd.hAdd μ y) v x)","decl":"lemma gaussianPDFReal_sub {μ : ℝ} {v : ℝ≥0} (x y : ℝ) :\n    gaussianPDFReal μ v (x - y) = gaussianPDFReal (μ + y) v x := by\n  simp only [gaussianPDFReal]\n  rw [sub_add_eq_sub_sub_swap]\n\n"}
{"name":"ProbabilityTheory.gaussianPDFReal_add","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\nx y : Real\n⊢ Eq (ProbabilityTheory.gaussianPDFReal μ v (HAdd.hAdd x y)) (ProbabilityTheory.gaussianPDFReal (HSub.hSub μ y) v x)","decl":"lemma gaussianPDFReal_add {μ : ℝ} {v : ℝ≥0} (x y : ℝ) :\n    gaussianPDFReal μ v (x + y) = gaussianPDFReal (μ - y) v x := by\n  rw [sub_eq_add_neg, ← gaussianPDFReal_sub, sub_eq_add_neg, neg_neg]\n\n"}
{"name":"ProbabilityTheory.gaussianPDFReal_inv_mul","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\nc : Real\nhc : Ne c 0\nx : Real\n⊢ Eq (ProbabilityTheory.gaussianPDFReal μ v (HMul.hMul (Inv.inv c) x)) (HMul.hMul (abs c) (ProbabilityTheory.gaussianPDFReal (HMul.hMul c μ) (HMul.hMul ⟨HPow.hPow c 2, ⋯⟩ v) x))","decl":"lemma gaussianPDFReal_inv_mul {μ : ℝ} {v : ℝ≥0} {c : ℝ} (hc : c ≠ 0) (x : ℝ) :\n    gaussianPDFReal μ v (c⁻¹ * x) = |c| * gaussianPDFReal (c * μ) (⟨c^2, sq_nonneg _⟩ * v) x := by\n  simp only [gaussianPDFReal.eq_1, zero_lt_two, mul_nonneg_iff_of_pos_left, NNReal.zero_le_coe,\n    Real.sqrt_mul', one_div, mul_inv_rev, NNReal.coe_mul, NNReal.coe_mk, NNReal.coe_pos]\n  rw [← mul_assoc]\n  refine congr_arg₂ _ ?_ ?_\n  · field_simp\n    rw [Real.sqrt_sq_eq_abs]\n    ring_nf\n    calc (Real.sqrt ↑v)⁻¹ * (Real.sqrt 2)⁻¹ * (Real.sqrt π)⁻¹\n      = (Real.sqrt ↑v)⁻¹ * (Real.sqrt 2)⁻¹ * (Real.sqrt π)⁻¹ * (|c| * |c|⁻¹) := by\n          rw [mul_inv_cancel₀, mul_one]\n          simp only [ne_eq, abs_eq_zero, hc, not_false_eq_true]\n    _ = (Real.sqrt ↑v)⁻¹ * (Real.sqrt 2)⁻¹ * (Real.sqrt π)⁻¹ * |c| * |c|⁻¹ := by ring\n  · congr 1\n    field_simp\n    congr 1\n    ring\n\n"}
{"name":"ProbabilityTheory.gaussianPDFReal_mul","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\nc : Real\nhc : Ne c 0\nx : Real\n⊢ Eq (ProbabilityTheory.gaussianPDFReal μ v (HMul.hMul c x)) (HMul.hMul (abs (Inv.inv c)) (ProbabilityTheory.gaussianPDFReal (HMul.hMul (Inv.inv c) μ) (HMul.hMul ⟨Inv.inv (HPow.hPow c 2), ⋯⟩ v) x))","decl":"lemma gaussianPDFReal_mul {μ : ℝ} {v : ℝ≥0} {c : ℝ} (hc : c ≠ 0) (x : ℝ) :\n    gaussianPDFReal μ v (c * x)\n      = |c⁻¹| * gaussianPDFReal (c⁻¹ * μ) (⟨(c^2)⁻¹, inv_nonneg.mpr (sq_nonneg _)⟩ * v) x := by\n  conv_lhs => rw [← inv_inv c, gaussianPDFReal_inv_mul (inv_ne_zero hc)]\n  simp\n\n"}
{"name":"ProbabilityTheory.gaussianPDF_def","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\n⊢ Eq (ProbabilityTheory.gaussianPDF μ v) fun x => ENNReal.ofReal (ProbabilityTheory.gaussianPDFReal μ v x)","decl":"lemma gaussianPDF_def (μ : ℝ) (v : ℝ≥0) :\n    gaussianPDF μ v = fun x ↦ ENNReal.ofReal (gaussianPDFReal μ v x) := rfl\n\n"}
{"name":"ProbabilityTheory.gaussianPDF_zero_var","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\n⊢ Eq (ProbabilityTheory.gaussianPDF μ 0) 0","decl":"@[simp]\nlemma gaussianPDF_zero_var (μ : ℝ) : gaussianPDF μ 0 = 0 := by\n  ext\n  simp [gaussianPDF]\n\n"}
{"name":"ProbabilityTheory.gaussianPDF_pos","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\nhv : Ne v 0\nx : Real\n⊢ LT.lt 0 (ProbabilityTheory.gaussianPDF μ v x)","decl":"lemma gaussianPDF_pos (μ : ℝ) {v : ℝ≥0} (hv : v ≠ 0) (x : ℝ) : 0 < gaussianPDF μ v x := by\n  rw [gaussianPDF, ENNReal.ofReal_pos]\n  exact gaussianPDFReal_pos _ _ _ hv\n\n"}
{"name":"ProbabilityTheory.measurable_gaussianPDF","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\n⊢ Measurable (ProbabilityTheory.gaussianPDF μ v)","decl":"@[measurability]\nlemma measurable_gaussianPDF (μ : ℝ) (v : ℝ≥0) : Measurable (gaussianPDF μ v) :=\n  (measurable_gaussianPDFReal _ _).ennreal_ofReal\n\n"}
{"name":"ProbabilityTheory.lintegral_gaussianPDF_eq_one","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\nh : Ne v 0\n⊢ Eq (MeasureTheory.lintegral MeasureTheory.MeasureSpace.volume fun x => ProbabilityTheory.gaussianPDF μ v x) 1","decl":"@[simp]\nlemma lintegral_gaussianPDF_eq_one (μ : ℝ) {v : ℝ≥0} (h : v ≠ 0) :\n    ∫⁻ x, gaussianPDF μ v x = 1 :=\n  lintegral_gaussianPDFReal_eq_one μ h\n\n"}
{"name":"ProbabilityTheory.gaussianReal_of_var_ne_zero","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\nhv : Ne v 0\n⊢ Eq (ProbabilityTheory.gaussianReal μ v) (MeasureTheory.MeasureSpace.volume.withDensity (ProbabilityTheory.gaussianPDF μ v))","decl":"lemma gaussianReal_of_var_ne_zero (μ : ℝ) {v : ℝ≥0} (hv : v ≠ 0) :\n    gaussianReal μ v = volume.withDensity (gaussianPDF μ v) := if_neg hv\n\n"}
{"name":"ProbabilityTheory.gaussianReal_zero_var","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\n⊢ Eq (ProbabilityTheory.gaussianReal μ 0) (MeasureTheory.Measure.dirac μ)","decl":"@[simp]\nlemma gaussianReal_zero_var (μ : ℝ) : gaussianReal μ 0 = Measure.dirac μ := if_pos rfl\n\n"}
{"name":"ProbabilityTheory.instIsProbabilityMeasureGaussianReal","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\n⊢ MeasureTheory.IsProbabilityMeasure (ProbabilityTheory.gaussianReal μ v)","decl":"instance instIsProbabilityMeasureGaussianReal (μ : ℝ) (v : ℝ≥0) :\n    IsProbabilityMeasure (gaussianReal μ v) where\n  measure_univ := by by_cases h : v = 0 <;> simp [gaussianReal_of_var_ne_zero, h]\n\n"}
{"name":"ProbabilityTheory.gaussianReal_apply","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\nhv : Ne v 0\ns : Set Real\n⊢ Eq ((ProbabilityTheory.gaussianReal μ v) s) (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict s) fun x => ProbabilityTheory.gaussianPDF μ v x)","decl":"lemma gaussianReal_apply (μ : ℝ) {v : ℝ≥0} (hv : v ≠ 0) (s : Set ℝ) :\n    gaussianReal μ v s = ∫⁻ x in s, gaussianPDF μ v x := by\n  rw [gaussianReal_of_var_ne_zero _ hv, withDensity_apply' _ s]\n\n"}
{"name":"ProbabilityTheory.gaussianReal_apply_eq_integral","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\nhv : Ne v 0\ns : Set Real\n⊢ Eq ((ProbabilityTheory.gaussianReal μ v) s) (ENNReal.ofReal (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict s) fun x => ProbabilityTheory.gaussianPDFReal μ v x))","decl":"lemma gaussianReal_apply_eq_integral (μ : ℝ) {v : ℝ≥0} (hv : v ≠ 0) (s : Set ℝ) :\n    gaussianReal μ v s = ENNReal.ofReal (∫ x in s, gaussianPDFReal μ v x) := by\n  rw [gaussianReal_apply _ hv s, ofReal_integral_eq_lintegral_ofReal]\n  · rfl\n  · exact (integrable_gaussianPDFReal _ _).restrict\n  · exact ae_of_all _ (gaussianPDFReal_nonneg _ _)\n\n"}
{"name":"ProbabilityTheory.gaussianReal_absolutelyContinuous","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\nhv : Ne v 0\n⊢ (ProbabilityTheory.gaussianReal μ v).AbsolutelyContinuous MeasureTheory.MeasureSpace.volume","decl":"lemma gaussianReal_absolutelyContinuous (μ : ℝ) {v : ℝ≥0} (hv : v ≠ 0) :\n    gaussianReal μ v ≪ volume := by\n  rw [gaussianReal_of_var_ne_zero _ hv]\n  exact withDensity_absolutelyContinuous _ _\n\n"}
{"name":"ProbabilityTheory.gaussianReal_absolutelyContinuous'","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\nhv : Ne v 0\n⊢ MeasureTheory.MeasureSpace.volume.AbsolutelyContinuous (ProbabilityTheory.gaussianReal μ v)","decl":"lemma gaussianReal_absolutelyContinuous' (μ : ℝ) {v : ℝ≥0} (hv : v ≠ 0) :\n    volume ≪ gaussianReal μ v := by\n  rw [gaussianReal_of_var_ne_zero _ hv]\n  refine withDensity_absolutelyContinuous' ?_ ?_\n  · exact (measurable_gaussianPDF _ _).aemeasurable\n  · exact ae_of_all _ (fun _ ↦ (gaussianPDF_pos _ hv _).ne')\n\n"}
{"name":"ProbabilityTheory.rnDeriv_gaussianReal","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\n⊢ (MeasureTheory.ae MeasureTheory.MeasureSpace.volume).EventuallyEq ((ProbabilityTheory.gaussianReal μ v).rnDeriv MeasureTheory.MeasureSpace.volume) (ProbabilityTheory.gaussianPDF μ v)","decl":"lemma rnDeriv_gaussianReal (μ : ℝ) (v : ℝ≥0) :\n    ∂(gaussianReal μ v)/∂volume =ₐₛ gaussianPDF μ v := by\n  by_cases hv : v = 0\n  · simp only [hv, gaussianReal_zero_var, gaussianPDF_zero_var]\n    refine (Measure.eq_rnDeriv measurable_zero (mutuallySingular_dirac μ volume) ?_).symm\n    rw [withDensity_zero, add_zero]\n  · rw [gaussianReal_of_var_ne_zero _ hv]\n    exact Measure.rnDeriv_withDensity _ (measurable_gaussianPDF μ v)\n\n"}
{"name":"MeasurableEmbedding.gaussianReal_comap_apply","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\nhv : Ne v 0\nf : Real → Real\nhf : MeasurableEmbedding f\nf' : Real → Real\nh_deriv : ∀ (x : Real), HasDerivAt f (f' x) x\ns : Set Real\nhs : MeasurableSet s\n⊢ Eq ((MeasureTheory.Measure.comap f (ProbabilityTheory.gaussianReal μ v)) s) (ENNReal.ofReal (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict s) fun x => HMul.hMul (abs (f' x)) (ProbabilityTheory.gaussianPDFReal μ v (f x))))","decl":"lemma _root_.MeasurableEmbedding.gaussianReal_comap_apply (hv : v ≠ 0)\n    {f : ℝ → ℝ} (hf : MeasurableEmbedding f)\n    {f' : ℝ → ℝ} (h_deriv : ∀ x, HasDerivAt f (f' x) x) {s : Set ℝ} (hs : MeasurableSet s) :\n    (gaussianReal μ v).comap f s\n      = ENNReal.ofReal (∫ x in s, |f' x| * gaussianPDFReal μ v (f x)) := by\n  rw [gaussianReal_of_var_ne_zero _ hv, gaussianPDF_def]\n  exact hf.withDensity_ofReal_comap_apply_eq_integral_abs_deriv_mul' hs h_deriv\n    (ae_of_all _ (gaussianPDFReal_nonneg _ _)) (integrable_gaussianPDFReal _ _)\n\n"}
{"name":"MeasurableEquiv.gaussianReal_map_symm_apply","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\nhv : Ne v 0\nf : MeasurableEquiv Real Real\nf' : Real → Real\nh_deriv : ∀ (x : Real), HasDerivAt (⇑f) (f' x) x\ns : Set Real\nhs : MeasurableSet s\n⊢ Eq ((MeasureTheory.Measure.map (⇑f.symm) (ProbabilityTheory.gaussianReal μ v)) s) (ENNReal.ofReal (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict s) fun x => HMul.hMul (abs (f' x)) (ProbabilityTheory.gaussianPDFReal μ v (f x))))","decl":"lemma _root_.MeasurableEquiv.gaussianReal_map_symm_apply (hv : v ≠ 0) (f : ℝ ≃ᵐ ℝ) {f' : ℝ → ℝ}\n    (h_deriv : ∀ x, HasDerivAt f (f' x) x) {s : Set ℝ} (hs : MeasurableSet s) :\n    (gaussianReal μ v).map f.symm s\n      = ENNReal.ofReal (∫ x in s, |f' x| * gaussianPDFReal μ v (f x)) := by\n  rw [gaussianReal_of_var_ne_zero _ hv, gaussianPDF_def]\n  exact f.withDensity_ofReal_map_symm_apply_eq_integral_abs_deriv_mul' hs h_deriv\n    (ae_of_all _ (gaussianPDFReal_nonneg _ _)) (integrable_gaussianPDFReal _ _)\n\n"}
{"name":"ProbabilityTheory.gaussianReal_map_add_const","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\ny : Real\n⊢ Eq (MeasureTheory.Measure.map (fun x => HAdd.hAdd x y) (ProbabilityTheory.gaussianReal μ v)) (ProbabilityTheory.gaussianReal (HAdd.hAdd μ y) v)","decl":"/-- The map of a Gaussian distribution by addition of a constant is a Gaussian. -/\nlemma gaussianReal_map_add_const (y : ℝ) :\n    (gaussianReal μ v).map (· + y) = gaussianReal (μ + y) v := by\n  by_cases hv : v = 0\n  · simp only [hv, ne_eq, not_true, gaussianReal_zero_var]\n    exact Measure.map_dirac (measurable_id'.add_const _) _\n  let e : ℝ ≃ᵐ ℝ := (Homeomorph.addRight y).symm.toMeasurableEquiv\n  have he' : ∀ x, HasDerivAt e ((fun _ ↦ 1) x) x := fun _ ↦ (hasDerivAt_id _).sub_const y\n  change (gaussianReal μ v).map e.symm = gaussianReal (μ + y) v\n  ext s' hs'\n  rw [MeasurableEquiv.gaussianReal_map_symm_apply hv e he' hs']\n  simp only [abs_neg, abs_one, MeasurableEquiv.coe_mk, Equiv.coe_fn_mk, one_mul, ne_eq]\n  rw [gaussianReal_apply_eq_integral _ hv s']\n  simp [e, gaussianPDFReal_sub _ y, Homeomorph.addRight, ← sub_eq_add_neg]\n\n"}
{"name":"ProbabilityTheory.gaussianReal_map_const_add","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\ny : Real\n⊢ Eq (MeasureTheory.Measure.map (fun x => HAdd.hAdd y x) (ProbabilityTheory.gaussianReal μ v)) (ProbabilityTheory.gaussianReal (HAdd.hAdd μ y) v)","decl":"/-- The map of a Gaussian distribution by addition of a constant is a Gaussian. -/\nlemma gaussianReal_map_const_add (y : ℝ) :\n    (gaussianReal μ v).map (y + ·) = gaussianReal (μ + y) v := by\n  simp_rw [add_comm y]\n  exact gaussianReal_map_add_const y\n\n"}
{"name":"ProbabilityTheory.gaussianReal_map_const_mul","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\nc : Real\n⊢ Eq (MeasureTheory.Measure.map (fun x => HMul.hMul c x) (ProbabilityTheory.gaussianReal μ v)) (ProbabilityTheory.gaussianReal (HMul.hMul c μ) (HMul.hMul ⟨HPow.hPow c 2, ⋯⟩ v))","decl":"/-- The map of a Gaussian distribution by multiplication by a constant is a Gaussian. -/\nlemma gaussianReal_map_const_mul (c : ℝ) :\n    (gaussianReal μ v).map (c * ·) = gaussianReal (c * μ) (⟨c^2, sq_nonneg _⟩ * v) := by\n  by_cases hv : v = 0\n  · simp only [hv, mul_zero, ne_eq, not_true, gaussianReal_zero_var]\n    exact Measure.map_dirac (measurable_id'.const_mul c) μ\n  by_cases hc : c = 0\n  · simp only [hc, zero_mul, ne_eq, abs_zero, mul_eq_zero]\n    rw [Measure.map_const]\n    simp only [ne_eq, measure_univ, one_smul, mul_eq_zero]\n    convert (gaussianReal_zero_var 0).symm\n    simp only [ne_eq, zero_pow, mul_eq_zero, hv, or_false, not_false_eq_true, reduceCtorEq,\n      NNReal.mk_zero]\n  let e : ℝ ≃ᵐ ℝ := (Homeomorph.mulLeft₀ c hc).symm.toMeasurableEquiv\n  have he' : ∀ x, HasDerivAt e ((fun _ ↦ c⁻¹) x) x := by\n    suffices ∀ x, HasDerivAt (fun x => c⁻¹ * x) (c⁻¹ * 1) x by rwa [mul_one] at this\n    exact fun _ ↦ HasDerivAt.const_mul _ (hasDerivAt_id _)\n  change (gaussianReal μ v).map e.symm = gaussianReal (c * μ) (⟨c^2, sq_nonneg _⟩ * v)\n  ext s' hs'\n  rw [MeasurableEquiv.gaussianReal_map_symm_apply hv e he' hs',\n    gaussianReal_apply_eq_integral _ _ s']\n  swap\n  · simp only [ne_eq, mul_eq_zero, hv, or_false]\n    rw [← NNReal.coe_inj]\n    simp [hc]\n  simp only [e, Homeomorph.mulLeft₀, Equiv.toFun_as_coe, Equiv.mulLeft₀_apply, Equiv.invFun_as_coe,\n    Equiv.mulLeft₀_symm_apply, Homeomorph.toMeasurableEquiv_coe, Homeomorph.homeomorph_mk_coe_symm,\n    Equiv.coe_fn_symm_mk, gaussianPDFReal_inv_mul hc]\n  congr with x\n  suffices |c⁻¹| * |c| = 1 by rw [← mul_assoc, this, one_mul]\n  rw [abs_inv, inv_mul_cancel₀]\n  rwa [ne_eq, abs_eq_zero]\n\n"}
{"name":"ProbabilityTheory.gaussianReal_map_mul_const","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\nc : Real\n⊢ Eq (MeasureTheory.Measure.map (fun x => HMul.hMul x c) (ProbabilityTheory.gaussianReal μ v)) (ProbabilityTheory.gaussianReal (HMul.hMul c μ) (HMul.hMul ⟨HPow.hPow c 2, ⋯⟩ v))","decl":"/-- The map of a Gaussian distribution by multiplication by a constant is a Gaussian. -/\nlemma gaussianReal_map_mul_const (c : ℝ) :\n    (gaussianReal μ v).map (· * c) = gaussianReal (c * μ) (⟨c^2, sq_nonneg _⟩ * v) := by\n  simp_rw [mul_comm _ c]\n  exact gaussianReal_map_const_mul c\n\n"}
{"name":"ProbabilityTheory.gaussianReal_add_const","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\nΩ : Type\ninst✝ : MeasureTheory.MeasureSpace Ω\nX : Ω → Real\nhX : Eq (MeasureTheory.Measure.map X MeasureTheory.MeasureSpace.volume) (ProbabilityTheory.gaussianReal μ v)\ny : Real\n⊢ Eq (MeasureTheory.Measure.map (fun ω => HAdd.hAdd (X ω) y) MeasureTheory.MeasureSpace.volume) (ProbabilityTheory.gaussianReal (HAdd.hAdd μ y) v)","decl":"/-- If `X` is a real random variable with Gaussian law with mean `μ` and variance `v`, then `X + y`\nhas Gaussian law with mean `μ + y` and variance `v`. -/\nlemma gaussianReal_add_const {X : Ω → ℝ} (hX : Measure.map X ℙ = gaussianReal μ v) (y : ℝ) :\n    Measure.map (fun ω ↦ X ω + y) ℙ = gaussianReal (μ + y) v := by\n  have hXm : AEMeasurable X := aemeasurable_of_map_neZero (by rw [hX]; infer_instance)\n  change Measure.map ((fun ω ↦ ω + y) ∘ X) ℙ = gaussianReal (μ + y) v\n  rw [← AEMeasurable.map_map_of_aemeasurable (measurable_id'.add_const _).aemeasurable hXm, hX,\n    gaussianReal_map_add_const y]\n\n"}
{"name":"ProbabilityTheory.gaussianReal_const_add","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\nΩ : Type\ninst✝ : MeasureTheory.MeasureSpace Ω\nX : Ω → Real\nhX : Eq (MeasureTheory.Measure.map X MeasureTheory.MeasureSpace.volume) (ProbabilityTheory.gaussianReal μ v)\ny : Real\n⊢ Eq (MeasureTheory.Measure.map (fun ω => HAdd.hAdd y (X ω)) MeasureTheory.MeasureSpace.volume) (ProbabilityTheory.gaussianReal (HAdd.hAdd μ y) v)","decl":"/-- If `X` is a real random variable with Gaussian law with mean `μ` and variance `v`, then `y + X`\nhas Gaussian law with mean `μ + y` and variance `v`. -/\nlemma gaussianReal_const_add {X : Ω → ℝ} (hX : Measure.map X ℙ = gaussianReal μ v) (y : ℝ) :\n    Measure.map (fun ω ↦ y + X ω) ℙ = gaussianReal (μ + y) v := by\n  simp_rw [add_comm y]\n  exact gaussianReal_add_const hX y\n\n"}
{"name":"ProbabilityTheory.gaussianReal_const_mul","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\nΩ : Type\ninst✝ : MeasureTheory.MeasureSpace Ω\nX : Ω → Real\nhX : Eq (MeasureTheory.Measure.map X MeasureTheory.MeasureSpace.volume) (ProbabilityTheory.gaussianReal μ v)\nc : Real\n⊢ Eq (MeasureTheory.Measure.map (fun ω => HMul.hMul c (X ω)) MeasureTheory.MeasureSpace.volume) (ProbabilityTheory.gaussianReal (HMul.hMul c μ) (HMul.hMul ⟨HPow.hPow c 2, ⋯⟩ v))","decl":"/-- If `X` is a real random variable with Gaussian law with mean `μ` and variance `v`, then `c * X`\nhas Gaussian law with mean `c * μ` and variance `c^2 * v`. -/\nlemma gaussianReal_const_mul {X : Ω → ℝ} (hX : Measure.map X ℙ = gaussianReal μ v) (c : ℝ) :\n    Measure.map (fun ω ↦ c * X ω) ℙ = gaussianReal (c * μ) (⟨c^2, sq_nonneg _⟩ * v) := by\n  have hXm : AEMeasurable X := aemeasurable_of_map_neZero (by rw [hX]; infer_instance)\n  change Measure.map ((fun ω ↦ c * ω) ∘ X) ℙ = gaussianReal (c * μ) (⟨c^2, sq_nonneg _⟩ * v)\n  rw [← AEMeasurable.map_map_of_aemeasurable (measurable_id'.const_mul c).aemeasurable hXm, hX]\n  exact gaussianReal_map_const_mul c\n\n"}
{"name":"ProbabilityTheory.gaussianReal_mul_const","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"μ : Real\nv : NNReal\nΩ : Type\ninst✝ : MeasureTheory.MeasureSpace Ω\nX : Ω → Real\nhX : Eq (MeasureTheory.Measure.map X MeasureTheory.MeasureSpace.volume) (ProbabilityTheory.gaussianReal μ v)\nc : Real\n⊢ Eq (MeasureTheory.Measure.map (fun ω => HMul.hMul (X ω) c) MeasureTheory.MeasureSpace.volume) (ProbabilityTheory.gaussianReal (HMul.hMul c μ) (HMul.hMul ⟨HPow.hPow c 2, ⋯⟩ v))","decl":"/-- If `X` is a real random variable with Gaussian law with mean `μ` and variance `v`, then `X * c`\nhas Gaussian law with mean `c * μ` and variance `c^2 * v`. -/\nlemma gaussianReal_mul_const {X : Ω → ℝ} (hX : Measure.map X ℙ = gaussianReal μ v) (c : ℝ) :\n    Measure.map (fun ω ↦ X ω * c) ℙ = gaussianReal (c * μ) (⟨c^2, sq_nonneg _⟩ * v) := by\n  simp_rw [mul_comm _ c]\n  exact gaussianReal_const_mul hX c\n\n"}
{"name":"ProbabilityTheory.mgf_gaussianReal","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\np : MeasureTheory.Measure Ω\nμ : Real\nv : NNReal\nX : Ω → Real\nhX : Eq (MeasureTheory.Measure.map X p) (ProbabilityTheory.gaussianReal μ v)\nt : Real\n⊢ Eq (ProbabilityTheory.mgf X p t) (Real.exp (HAdd.hAdd (HMul.hMul μ t) (HDiv.hDiv (HMul.hMul (↑v) (HPow.hPow t 2)) 2)))","decl":"theorem mgf_gaussianReal (hX : p.map X = gaussianReal μ v) (t : ℝ) :\n    mgf X p t = exp (μ * t + v * t ^ 2 / 2) := by\n  by_cases hv : v = 0\n  · simp only [gaussianReal, hv, ↓reduceIte] at hX\n    simp [mgf_dirac hX, hv]\n  calc\n  mgf X p t = (p.map X)[fun x => exp (t * x)] := by\n    rw [← mgf_id_map, mgf]\n    all_goals simp [AEMeasurable.of_map_ne_zero, hX, IsProbabilityMeasure.ne_zero]\n  _ = ∫ x, exp (t * x) * gaussianPDFReal μ v x := by\n    simp [hX, gaussianReal_of_var_ne_zero μ hv, gaussianPDF_def, ENNReal.ofReal,\n      integral_withDensity_eq_integral_smul (measurable_gaussianPDFReal μ v).real_toNNReal,\n      NNReal.smul_def, gaussianPDFReal_nonneg, mul_comm]\n  _ = ∫ x, exp (μ * t + v * t ^ 2 / 2) * gaussianPDFReal (μ + v * t) v x := by\n    simp only [gaussianPDFReal_def, mul_left_comm (exp _), mul_assoc, ← exp_add]\n    congr with x\n    field_simp only [mul_left_comm, ← exp_sub, ← exp_add]\n    ring_nf\n  _ = exp (μ * t + v * t ^ 2 / 2) := by\n    rw [integral_mul_left, integral_gaussianPDFReal_eq_one (μ + v * t) hv, mul_one]\n\n"}
{"name":"ProbabilityTheory.cgf_gaussianReal","module":"Mathlib.Probability.Distributions.Gaussian","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\np : MeasureTheory.Measure Ω\nμ : Real\nv : NNReal\nX : Ω → Real\nhX : Eq (MeasureTheory.Measure.map X p) (ProbabilityTheory.gaussianReal μ v)\nt : Real\n⊢ Eq (ProbabilityTheory.cgf X p t) (HAdd.hAdd (HMul.hMul μ t) (HDiv.hDiv (HMul.hMul (↑v) (HPow.hPow t 2)) 2))","decl":"theorem cgf_gaussianReal (hX : p.map X = gaussianReal μ v) (t : ℝ) :\n    cgf X p t = μ * t + v * t ^ 2 / 2 := by\n  rw [cgf, mgf_gaussianReal hX t, log_exp]\n\n"}
