{"name":"List.prod_nonneg","module":"Mathlib.Algebra.Order.BigOperators.GroupWithZero.List","initialProofState":"R : Type u_1\ninst✝³ : CommMonoidWithZero R\ninst✝² : PartialOrder R\ninst✝¹ : ZeroLEOneClass R\ninst✝ : PosMulMono R\ns : List R\nh : ∀ (a : R), Membership.mem s a → LE.le 0 a\n⊢ LE.le 0 s.prod","decl":"lemma prod_nonneg {s : List R} (h : ∀ a ∈ s, 0 ≤ a) : 0 ≤ s.prod := by\n  induction s with\n  | nil => simp\n  | cons head tail hind =>\n    simp only [prod_cons]\n    simp only [mem_cons, forall_eq_or_imp] at h\n    exact mul_nonneg h.1 (hind h.2)\n\n\n"}
{"name":"List.one_le_prod","module":"Mathlib.Algebra.Order.BigOperators.GroupWithZero.List","initialProofState":"R : Type u_1\ninst✝³ : CommMonoidWithZero R\ninst✝² : PartialOrder R\ninst✝¹ : ZeroLEOneClass R\ninst✝ : PosMulMono R\ns : List R\nh : ∀ (a : R), Membership.mem s a → LE.le 1 a\n⊢ LE.le 1 s.prod","decl":"lemma one_le_prod {s : List R} (h : ∀ a ∈ s, 1 ≤ a) : 1 ≤ s.prod := by\n  induction s with\n  | nil => simp\n  | cons head tail hind =>\n    simp only [prod_cons]\n    simp only [mem_cons, forall_eq_or_imp] at h\n    exact one_le_mul_of_one_le_of_one_le h.1 (hind h.2)\n\n"}
{"name":"List.prod_map_le_prod_map₀","module":"Mathlib.Algebra.Order.BigOperators.GroupWithZero.List","initialProofState":"R : Type u_1\ninst✝³ : CommMonoidWithZero R\ninst✝² : PartialOrder R\ninst✝¹ : ZeroLEOneClass R\ninst✝ : PosMulMono R\nι : Type u_2\ns : List ι\nf g : ι → R\nh0 : ∀ (i : ι), Membership.mem s i → LE.le 0 (f i)\nh : ∀ (i : ι), Membership.mem s i → LE.le (f i) (g i)\n⊢ LE.le (List.map f s).prod (List.map g s).prod","decl":"theorem prod_map_le_prod_map₀ {ι : Type*} {s : List ι} (f : ι → R) (g : ι → R)\n    (h0 : ∀ i ∈ s, 0 ≤ f i) (h : ∀ i ∈ s, f i ≤ g i) :\n    (map f s).prod ≤ (map g s).prod := by\n  induction s with\n  | nil => simp\n  | cons a s hind =>\n    simp only [map_cons, prod_cons]\n    have := posMulMono_iff_mulPosMono.1 ‹PosMulMono R›\n    apply mul_le_mul\n    · apply h\n      simp\n    · apply hind\n      · intro i hi\n        apply h0\n        simp [hi]\n      · intro i hi\n        apply h\n        simp [hi]\n    · apply prod_nonneg\n      simp only [mem_map, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂]\n      intro a ha\n      apply h0\n      simp [ha]\n    · apply (h0 _ _).trans (h _ _) <;> simp\n\n"}
{"name":"List.prod_pos","module":"Mathlib.Algebra.Order.BigOperators.GroupWithZero.List","initialProofState":"R : Type u_1\ninst✝⁴ : CommMonoidWithZero R\ninst✝³ : PartialOrder R\ninst✝² : ZeroLEOneClass R\ninst✝¹ : PosMulStrictMono R\ninst✝ : NeZero 1\ns : List R\nh : ∀ (a : R), Membership.mem s a → LT.lt 0 a\n⊢ LT.lt 0 s.prod","decl":"lemma prod_pos {s : List R} (h : ∀ a ∈ s, 0 < a) : 0 < s.prod := by\n  induction s with\n  | nil => simp\n  | cons a s hind =>\n    simp only [prod_cons]\n    simp only [mem_cons, forall_eq_or_imp] at h\n    exact mul_pos h.1 (hind h.2)\n\n"}
{"name":"List.prod_map_lt_prod_map","module":"Mathlib.Algebra.Order.BigOperators.GroupWithZero.List","initialProofState":"R : Type u_1\ninst✝⁴ : CommMonoidWithZero R\ninst✝³ : PartialOrder R\ninst✝² : ZeroLEOneClass R\ninst✝¹ : PosMulStrictMono R\ninst✝ : NeZero 1\nι : Type u_2\ns : List ι\nhs : Ne s List.nil\nf g : ι → R\nh0 : ∀ (i : ι), Membership.mem s i → LT.lt 0 (f i)\nh : ∀ (i : ι), Membership.mem s i → LT.lt (f i) (g i)\n⊢ LT.lt (List.map f s).prod (List.map g s).prod","decl":"theorem prod_map_lt_prod_map {ι : Type*} {s : List ι} (hs : s ≠ [])\n    (f : ι → R) (g : ι → R) (h0 : ∀ i ∈ s, 0 < f i) (h : ∀ i ∈ s, f i < g i) :\n    (map f s).prod < (map g s).prod := by\n  match s with\n  | [] => contradiction\n  | a :: s =>\n    simp only [map_cons, prod_cons]\n    have := posMulStrictMono_iff_mulPosStrictMono.1 ‹PosMulStrictMono R›\n    apply mul_lt_mul\n    · apply h\n      simp\n    · apply prod_map_le_prod_map₀\n      · intro i hi\n        apply le_of_lt\n        apply h0\n        simp [hi]\n      · intro i hi\n        apply le_of_lt\n        apply h\n        simp [hi]\n    · apply prod_pos\n      simp only [mem_map, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂]\n      intro a ha\n      apply h0\n      simp [ha]\n    · apply le_of_lt ((h0 _ _).trans (h _ _)) <;> simp\n\n"}
