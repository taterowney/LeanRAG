{"name":"PresheafOfModules.isSheaf_of_isLimit","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Limits","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nR : CategoryTheory.Functor (Opposite C) RingCat\nF : CategoryTheory.Functor D (PresheafOfModules R)\ninst✝¹ : ∀ (X : Opposite C), Small.{v, max u₂ v} ↑((F.comp (PresheafOfModules.evaluation R X)).comp (CategoryTheory.forget (ModuleCat ↑(R.obj X)))).sections\nc : CategoryTheory.Limits.Cone F\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape D AddCommGrp\nhc : CategoryTheory.Limits.IsLimit c\nhF : ∀ (j : D), CategoryTheory.Presheaf.IsSheaf J (F.obj j).presheaf\n⊢ CategoryTheory.Presheaf.IsSheaf J c.pt.presheaf","decl":"lemma isSheaf_of_isLimit (hc : IsLimit c) (hF : ∀ j, Presheaf.IsSheaf J (F.obj j).presheaf) :\n    Presheaf.IsSheaf J (c.pt.presheaf) := by\n  let G : D ⥤ Sheaf J AddCommGrp.{v} :=\n    { obj := fun j => ⟨(F.obj j).presheaf, hF j⟩\n      map := fun φ => ⟨(PresheafOfModules.toPresheaf R).map (F.map φ)⟩ }\n  exact Sheaf.isSheaf_of_isLimit G _ (isLimitOfPreserves (toPresheaf R) hc)\n\n"}
{"name":"SheafOfModules.instSmallElemForallObjCompModuleCatCarrierOppositeRingCatValPresheafOfModulesForgetEvaluationForgetSections","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nR : CategoryTheory.Sheaf J RingCat\nF : CategoryTheory.Functor D (SheafOfModules R)\nX : Opposite C\n⊢ Small.{v, max u₂ v} ↑(((F.comp (SheafOfModules.forget R)).comp (PresheafOfModules.evaluation R.val X)).comp (CategoryTheory.forget (ModuleCat ↑(R.val.obj X)))).sections","decl":"instance (X : Cᵒᵖ) : Small.{v} (((F ⋙ forget _) ⋙ PresheafOfModules.evaluation _ X) ⋙\n    CategoryTheory.forget _).sections := by\n  change Small.{v} ((F ⋙ evaluation R X) ⋙ CategoryTheory.forget _).sections\n  infer_instance\n\n"}
{"name":"SheafOfModules.hasLimit","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Limits","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nR : CategoryTheory.Sheaf J RingCat\nF : CategoryTheory.Functor D (SheafOfModules R)\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape D AddCommGrp\n⊢ CategoryTheory.Limits.HasLimit F","decl":"instance hasLimit : HasLimit F := hasLimit_of_created F (forget _)\n\n"}
{"name":"SheafOfModules.evaluationPreservesLimit","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nR : CategoryTheory.Sheaf J RingCat\nF : CategoryTheory.Functor D (SheafOfModules R)\nX : Opposite C\n⊢ CategoryTheory.Limits.PreservesLimit F (SheafOfModules.evaluation R X)","decl":"noncomputable instance evaluationPreservesLimit (X : Cᵒᵖ) :\n    PreservesLimit F (evaluation R X) := by\n  dsimp [evaluation]\n  infer_instance\n\n"}
{"name":"SheafOfModules.hasLimitsOfShape","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nR : CategoryTheory.Sheaf J RingCat\n⊢ CategoryTheory.Limits.HasLimitsOfShape D (SheafOfModules R)","decl":"instance hasLimitsOfShape : HasLimitsOfShape D (SheafOfModules.{v} R) where\n\n"}
{"name":"SheafOfModules.evaluationPreservesLimitsOfShape","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nR : CategoryTheory.Sheaf J RingCat\nX : Opposite C\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape D (SheafOfModules.evaluation R X)","decl":"noncomputable instance evaluationPreservesLimitsOfShape (X : Cᵒᵖ) :\n    PreservesLimitsOfShape D (evaluation R X : SheafOfModules.{v} R ⥤ _) where\n\n"}
{"name":"SheafOfModules.forgetPreservesLimitsOfShape","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nR : CategoryTheory.Sheaf J RingCat\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape D (SheafOfModules.forget R)","decl":"noncomputable instance forgetPreservesLimitsOfShape :\n    PreservesLimitsOfShape D (forget.{v} R) where\n\n"}
{"name":"SheafOfModules.Finite.hasFiniteLimits","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Limits","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\n⊢ CategoryTheory.Limits.HasFiniteLimits (SheafOfModules R)","decl":"instance hasFiniteLimits : HasFiniteLimits (SheafOfModules.{v} R) :=\n  ⟨fun _ => inferInstance⟩\n\n"}
{"name":"SheafOfModules.Finite.evaluationPreservesFiniteLimits","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Limits","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nX : Opposite C\n⊢ CategoryTheory.Limits.PreservesFiniteLimits (SheafOfModules.evaluation R X)","decl":"noncomputable instance evaluationPreservesFiniteLimits (X : Cᵒᵖ) :\n    PreservesFiniteLimits (evaluation.{v} R X) where\n\n"}
{"name":"SheafOfModules.Finite.forgetPreservesFiniteLimits","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Limits","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\n⊢ CategoryTheory.Limits.PreservesFiniteLimits (SheafOfModules.forget R)","decl":"noncomputable instance forgetPreservesFiniteLimits :\n    PreservesFiniteLimits (forget.{v} R) where\n\n"}
{"name":"SheafOfModules.hasLimitsOfSize","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Limits","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{v₂, v, max u₁ v, max (max (max (v + 1) u) u₁) v₁} (SheafOfModules R)","decl":"instance hasLimitsOfSize : HasLimitsOfSize.{v₂, v} (SheafOfModules.{v} R) where\n\n"}
{"name":"SheafOfModules.evaluationPreservesLimitsOfSize","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Limits","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nX : Opposite C\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{v₂, v, max u₁ v, v, max (max (max u u₁) (v + 1)) v₁, max u (v + 1)} (SheafOfModules.evaluation R X)","decl":"noncomputable instance evaluationPreservesLimitsOfSize (X : Cᵒᵖ) :\n    PreservesLimitsOfSize.{v₂, v} (evaluation R X : SheafOfModules.{v} R ⥤ _) where\n\n"}
{"name":"SheafOfModules.forgetPreservesLimitsOfSize","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Limits","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{v₂, v, max u₁ v, max u₁ v, max (max (max u u₁) (v + 1)) v₁, max (max (max u u₁) (v + 1)) v₁} (SheafOfModules.forget R)","decl":"noncomputable instance forgetPreservesLimitsOfSize :\n    PreservesLimitsOfSize.{v₂, v} (forget.{v} R) where\n\n"}
{"name":"SheafOfModules.instPreservesFiniteLimitsFunctorOppositeAddCommGrpCompSheafToSheafSheafToPresheaf","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Limits","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\n⊢ CategoryTheory.Limits.PreservesFiniteLimits ((SheafOfModules.toSheaf R).comp (CategoryTheory.sheafToPresheaf J AddCommGrp))","decl":"noncomputable instance :\n     PreservesFiniteLimits (SheafOfModules.toSheaf.{v} R ⋙ sheafToPresheaf _ _) :=\n  comp_preservesFiniteLimits (SheafOfModules.forget.{v} R) (PresheafOfModules.toPresheaf R.val)\n\n"}
{"name":"SheafOfModules.instPreservesFiniteLimitsSheafAddCommGrpToSheaf","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Limits","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\n⊢ CategoryTheory.Limits.PreservesFiniteLimits (SheafOfModules.toSheaf R)","decl":"noncomputable instance : PreservesFiniteLimits (SheafOfModules.toSheaf.{v} R) :=\n  preservesFiniteLimits_of_reflects_of_preserves _ (sheafToPresheaf _ _)\n\n"}
