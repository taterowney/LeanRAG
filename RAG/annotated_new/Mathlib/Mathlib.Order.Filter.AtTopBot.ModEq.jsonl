{"name":"Nat.frequently_modEq","module":"Mathlib.Order.Filter.AtTopBot.ModEq","initialProofState":"n : Nat\nh : Ne n 0\nd : Nat\n⊢ Filter.Frequently (fun m => n.ModEq m d) Filter.atTop","decl":"/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem frequently_modEq {n : ℕ} (h : n ≠ 0) (d : ℕ) : ∃ᶠ m in atTop, m ≡ d [MOD n] :=\n  ((tendsto_add_atTop_nat d).comp (tendsto_id.nsmul_atTop h.bot_lt)).frequently <|\n    Frequently.of_forall fun m => by simp [Nat.modEq_iff_dvd, ← sub_sub]\n\n"}
{"name":"Nat.frequently_mod_eq","module":"Mathlib.Order.Filter.AtTopBot.ModEq","initialProofState":"d n : Nat\nh : LT.lt d n\n⊢ Filter.Frequently (fun m => Eq (HMod.hMod m n) d) Filter.atTop","decl":"theorem frequently_mod_eq {d n : ℕ} (h : d < n) : ∃ᶠ m in atTop, m % n = d := by\n  simpa only [Nat.ModEq, mod_eq_of_lt h] using frequently_modEq h.ne_bot d\n\n"}
{"name":"Nat.frequently_even","module":"Mathlib.Order.Filter.AtTopBot.ModEq","initialProofState":"⊢ Filter.Frequently (fun m => Even m) Filter.atTop","decl":"theorem frequently_even : ∃ᶠ m : ℕ in atTop, Even m := by\n  simpa only [even_iff] using frequently_mod_eq zero_lt_two\n\n"}
{"name":"Nat.frequently_odd","module":"Mathlib.Order.Filter.AtTopBot.ModEq","initialProofState":"⊢ Filter.Frequently (fun m => Odd m) Filter.atTop","decl":"theorem frequently_odd : ∃ᶠ m : ℕ in atTop, Odd m := by\n  simpa only [odd_iff] using frequently_mod_eq one_lt_two\n\n"}
{"name":"Filter.nonneg_of_eventually_pow_nonneg","module":"Mathlib.Order.Filter.AtTopBot.ModEq","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na : α\nh : Filter.Eventually (fun n => LE.le 0 (HPow.hPow a n)) Filter.atTop\n⊢ LE.le 0 a","decl":"theorem Filter.nonneg_of_eventually_pow_nonneg {α : Type*} [LinearOrderedRing α] {a : α}\n    (h : ∀ᶠ n in atTop, 0 ≤ a ^ (n : ℕ)) : 0 ≤ a :=\n  let ⟨_n, ho, hn⟩ := (Nat.frequently_odd.and_eventually h).exists\n  ho.pow_nonneg_iff.1 hn\n"}
