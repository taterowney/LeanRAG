{"name":"ContinuousMap.Homotopy.map_one_left","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nself : f₀.Homotopy f₁\nx : X\n⊢ Eq (self.toFun { fst := 1, snd := x }) (f₁ x)","decl":"/-- `ContinuousMap.Homotopy f₀ f₁` is the type of homotopies from `f₀` to `f₁`.\n\nWhen possible, instead of parametrizing results over `(f : Homotopy f₀ f₁)`,\nyou should parametrize over `{F : Type*} [HomotopyLike F f₀ f₁] (f : F)`.\n\nWhen you extend this structure, make sure to extend `ContinuousMap.HomotopyLike`. -/\nstructure Homotopy (f₀ f₁ : C(X, Y)) extends C(I × X, Y) where\n  /-- value of the homotopy at 0 -/\n  map_zero_left : ∀ x, toFun (0, x) = f₀ x\n  /-- value of the homotopy at 1 -/\n  map_one_left : ∀ x, toFun (1, x) = f₁ x\n\n"}
{"name":"ContinuousMap.Homotopy.mk.sizeOf_spec","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\ninst✝¹ : SizeOf X\ninst✝ : SizeOf Y\ntoContinuousMap : ContinuousMap (Prod (↑unitInterval) X) Y\nmap_zero_left : ∀ (x : X), Eq (toContinuousMap.toFun { fst := 0, snd := x }) (f₀ x)\nmap_one_left : ∀ (x : X), Eq (toContinuousMap.toFun { fst := 1, snd := x }) (f₁ x)\n⊢ Eq (SizeOf.sizeOf { toContinuousMap := toContinuousMap, map_zero_left := map_zero_left, map_one_left := map_one_left }) (HAdd.hAdd 1 (SizeOf.sizeOf toContinuousMap))","decl":"/-- `ContinuousMap.Homotopy f₀ f₁` is the type of homotopies from `f₀` to `f₁`.\n\nWhen possible, instead of parametrizing results over `(f : Homotopy f₀ f₁)`,\nyou should parametrize over `{F : Type*} [HomotopyLike F f₀ f₁] (f : F)`.\n\nWhen you extend this structure, make sure to extend `ContinuousMap.HomotopyLike`. -/\nstructure Homotopy (f₀ f₁ : C(X, Y)) extends C(I × X, Y) where\n  /-- value of the homotopy at 0 -/\n  map_zero_left : ∀ x, toFun (0, x) = f₀ x\n  /-- value of the homotopy at 1 -/\n  map_one_left : ∀ x, toFun (1, x) = f₁ x\n\n"}
{"name":"ContinuousMap.Homotopy.map_zero_left","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nself : f₀.Homotopy f₁\nx : X\n⊢ Eq (self.toFun { fst := 0, snd := x }) (f₀ x)","decl":"/-- `ContinuousMap.Homotopy f₀ f₁` is the type of homotopies from `f₀` to `f₁`.\n\nWhen possible, instead of parametrizing results over `(f : Homotopy f₀ f₁)`,\nyou should parametrize over `{F : Type*} [HomotopyLike F f₀ f₁] (f : F)`.\n\nWhen you extend this structure, make sure to extend `ContinuousMap.HomotopyLike`. -/\nstructure Homotopy (f₀ f₁ : C(X, Y)) extends C(I × X, Y) where\n  /-- value of the homotopy at 0 -/\n  map_zero_left : ∀ x, toFun (0, x) = f₀ x\n  /-- value of the homotopy at 1 -/\n  map_one_left : ∀ x, toFun (1, x) = f₁ x\n\n"}
{"name":"ContinuousMap.Homotopy.mk.injEq","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\ntoContinuousMap✝ : ContinuousMap (Prod (↑unitInterval) X) Y\nmap_zero_left✝ : ∀ (x : X), Eq (toContinuousMap✝.toFun { fst := 0, snd := x }) (f₀ x)\nmap_one_left✝ : ∀ (x : X), Eq (toContinuousMap✝.toFun { fst := 1, snd := x }) (f₁ x)\ntoContinuousMap : ContinuousMap (Prod (↑unitInterval) X) Y\nmap_zero_left : ∀ (x : X), Eq (toContinuousMap.toFun { fst := 0, snd := x }) (f₀ x)\nmap_one_left : ∀ (x : X), Eq (toContinuousMap.toFun { fst := 1, snd := x }) (f₁ x)\n⊢ Eq (Eq { toContinuousMap := toContinuousMap✝, map_zero_left := map_zero_left✝, map_one_left := map_one_left✝ } { toContinuousMap := toContinuousMap, map_zero_left := map_zero_left, map_one_left := map_one_left }) (Eq toContinuousMap✝ toContinuousMap)","decl":"/-- `ContinuousMap.Homotopy f₀ f₁` is the type of homotopies from `f₀` to `f₁`.\n\nWhen possible, instead of parametrizing results over `(f : Homotopy f₀ f₁)`,\nyou should parametrize over `{F : Type*} [HomotopyLike F f₀ f₁] (f : F)`.\n\nWhen you extend this structure, make sure to extend `ContinuousMap.HomotopyLike`. -/\nstructure Homotopy (f₀ f₁ : C(X, Y)) extends C(I × X, Y) where\n  /-- value of the homotopy at 0 -/\n  map_zero_left : ∀ x, toFun (0, x) = f₀ x\n  /-- value of the homotopy at 1 -/\n  map_one_left : ∀ x, toFun (1, x) = f₁ x\n\n"}
{"name":"ContinuousMap.Homotopy.mk.inj","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\ntoContinuousMap✝ : ContinuousMap (Prod (↑unitInterval) X) Y\nmap_zero_left✝ : ∀ (x : X), Eq (toContinuousMap✝.toFun { fst := 0, snd := x }) (f₀ x)\nmap_one_left✝ : ∀ (x : X), Eq (toContinuousMap✝.toFun { fst := 1, snd := x }) (f₁ x)\ntoContinuousMap : ContinuousMap (Prod (↑unitInterval) X) Y\nmap_zero_left : ∀ (x : X), Eq (toContinuousMap.toFun { fst := 0, snd := x }) (f₀ x)\nmap_one_left : ∀ (x : X), Eq (toContinuousMap.toFun { fst := 1, snd := x }) (f₁ x)\nx✝ : Eq { toContinuousMap := toContinuousMap✝, map_zero_left := map_zero_left✝, map_one_left := map_one_left✝ } { toContinuousMap := toContinuousMap, map_zero_left := map_zero_left, map_one_left := map_one_left }\n⊢ Eq toContinuousMap✝ toContinuousMap","decl":"/-- `ContinuousMap.Homotopy f₀ f₁` is the type of homotopies from `f₀` to `f₁`.\n\nWhen possible, instead of parametrizing results over `(f : Homotopy f₀ f₁)`,\nyou should parametrize over `{F : Type*} [HomotopyLike F f₀ f₁] (f : F)`.\n\nWhen you extend this structure, make sure to extend `ContinuousMap.HomotopyLike`. -/\nstructure Homotopy (f₀ f₁ : C(X, Y)) extends C(I × X, Y) where\n  /-- value of the homotopy at 0 -/\n  map_zero_left : ∀ x, toFun (0, x) = f₀ x\n  /-- value of the homotopy at 1 -/\n  map_one_left : ∀ x, toFun (1, x) = f₁ x\n\n"}
{"name":"ContinuousMap.HomotopyLike.map_one_left","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : outParam (Type u_3)\nY : outParam (Type u_4)\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\nF : Type u_5\nf₀ f₁ : outParam (ContinuousMap X Y)\ninst✝ : FunLike F (Prod (↑unitInterval) X) Y\nself : ContinuousMap.HomotopyLike F f₀ f₁\nf : F\nx : X\n⊢ Eq (f { fst := 1, snd := x }) (f₁ x)","decl":"/-- `ContinuousMap.HomotopyLike F f₀ f₁` states that `F` is a type of homotopies between `f₀` and\n`f₁`.\n\nYou should extend this class when you extend `ContinuousMap.Homotopy`. -/\nclass HomotopyLike {X Y : outParam Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    (F : Type*) (f₀ f₁ : outParam <| C(X, Y)) [FunLike F (I × X) Y]\n    extends ContinuousMapClass F (I × X) Y : Prop where\n  /-- value of the homotopy at 0 -/\n  map_zero_left (f : F) : ∀ x, f (0, x) = f₀ x\n  /-- value of the homotopy at 1 -/\n  map_one_left (f : F) : ∀ x, f (1, x) = f₁ x\n\n"}
{"name":"ContinuousMap.HomotopyLike.map_zero_left","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : outParam (Type u_3)\nY : outParam (Type u_4)\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\nF : Type u_5\nf₀ f₁ : outParam (ContinuousMap X Y)\ninst✝ : FunLike F (Prod (↑unitInterval) X) Y\nself : ContinuousMap.HomotopyLike F f₀ f₁\nf : F\nx : X\n⊢ Eq (f { fst := 0, snd := x }) (f₀ x)","decl":"/-- `ContinuousMap.HomotopyLike F f₀ f₁` states that `F` is a type of homotopies between `f₀` and\n`f₁`.\n\nYou should extend this class when you extend `ContinuousMap.Homotopy`. -/\nclass HomotopyLike {X Y : outParam Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    (F : Type*) (f₀ f₁ : outParam <| C(X, Y)) [FunLike F (I × X) Y]\n    extends ContinuousMapClass F (I × X) Y : Prop where\n  /-- value of the homotopy at 0 -/\n  map_zero_left (f : F) : ∀ x, f (0, x) = f₀ x\n  /-- value of the homotopy at 1 -/\n  map_one_left (f : F) : ∀ x, f (1, x) = f₁ x\n\n"}
{"name":"ContinuousMap.HomotopyLike.toContinuousMapClass","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : outParam (Type u_3)\nY : outParam (Type u_4)\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\nF : Type u_5\nf₀ f₁ : outParam (ContinuousMap X Y)\ninst✝ : FunLike F (Prod (↑unitInterval) X) Y\nself : ContinuousMap.HomotopyLike F f₀ f₁\n⊢ ContinuousMapClass F (Prod (↑unitInterval) X) Y","decl":"/-- `ContinuousMap.HomotopyLike F f₀ f₁` states that `F` is a type of homotopies between `f₀` and\n`f₁`.\n\nYou should extend this class when you extend `ContinuousMap.Homotopy`. -/\nclass HomotopyLike {X Y : outParam Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    (F : Type*) (f₀ f₁ : outParam <| C(X, Y)) [FunLike F (I × X) Y]\n    extends ContinuousMapClass F (I × X) Y : Prop where\n  /-- value of the homotopy at 0 -/\n  map_zero_left (f : F) : ∀ x, f (0, x) = f₀ x\n  /-- value of the homotopy at 1 -/\n  map_one_left (f : F) : ∀ x, f (1, x) = f₁ x\n\n"}
{"name":"ContinuousMap.Homotopy.instHomotopyLike","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\n⊢ ContinuousMap.HomotopyLike (f₀.Homotopy f₁) f₀ f₁","decl":"instance : HomotopyLike (Homotopy f₀ f₁) f₀ f₁ where\n  map_continuous f := f.continuous_toFun\n  map_zero_left f := f.map_zero_left\n  map_one_left f := f.map_one_left\n\n"}
{"name":"ContinuousMap.Homotopy.ext_iff","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nF G : f₀.Homotopy f₁\n⊢ Iff (Eq F G) (∀ (x : Prod (↑unitInterval) X), Eq (F x) (G x))","decl":"@[ext]\ntheorem ext {F G : Homotopy f₀ f₁} (h : ∀ x, F x = G x) : F = G :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"ContinuousMap.Homotopy.ext","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nF G : f₀.Homotopy f₁\nh : ∀ (x : Prod (↑unitInterval) X), Eq (F x) (G x)\n⊢ Eq F G","decl":"@[ext]\ntheorem ext {F G : Homotopy f₀ f₁} (h : ∀ x, F x = G x) : F = G :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"ContinuousMap.Homotopy.continuous","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nF : f₀.Homotopy f₁\n⊢ Continuous ⇑F","decl":"/-- Deprecated. Use `map_continuous` instead. -/\nprotected theorem continuous (F : Homotopy f₀ f₁) : Continuous F :=\n  F.continuous_toFun\n\n"}
{"name":"ContinuousMap.Homotopy.apply_zero","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nF : f₀.Homotopy f₁\nx : X\n⊢ Eq (F { fst := 0, snd := x }) (f₀ x)","decl":"@[simp]\ntheorem apply_zero (F : Homotopy f₀ f₁) (x : X) : F (0, x) = f₀ x :=\n  F.map_zero_left x\n\n"}
{"name":"ContinuousMap.Homotopy.apply_one","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nF : f₀.Homotopy f₁\nx : X\n⊢ Eq (F { fst := 1, snd := x }) (f₁ x)","decl":"@[simp]\ntheorem apply_one (F : Homotopy f₀ f₁) (x : X) : F (1, x) = f₁ x :=\n  F.map_one_left x\n\n"}
{"name":"ContinuousMap.Homotopy.coe_toContinuousMap","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nF : f₀.Homotopy f₁\n⊢ Eq ⇑F.toContinuousMap ⇑F","decl":"@[simp]\ntheorem coe_toContinuousMap (F : Homotopy f₀ f₁) : ⇑F.toContinuousMap = F :=\n  rfl\n\n"}
{"name":"ContinuousMap.Homotopy.curry_apply","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nF : f₀.Homotopy f₁\nt : ↑unitInterval\nx : X\n⊢ Eq ((F.curry t) x) (F { fst := t, snd := x })","decl":"@[simp]\ntheorem curry_apply (F : Homotopy f₀ f₁) (t : I) (x : X) : F.curry t x = F (t, x) :=\n  rfl\n\n"}
{"name":"ContinuousMap.Homotopy.extend_apply_of_le_zero","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nF : f₀.Homotopy f₁\nt : Real\nht : LE.le t 0\nx : X\n⊢ Eq ((F.extend t) x) (f₀ x)","decl":"theorem extend_apply_of_le_zero (F : Homotopy f₀ f₁) {t : ℝ} (ht : t ≤ 0) (x : X) :\n    F.extend t x = f₀ x := by\n  rw [← F.apply_zero]\n  exact ContinuousMap.congr_fun (Set.IccExtend_of_le_left (zero_le_one' ℝ) F.curry ht) x\n\n"}
{"name":"ContinuousMap.Homotopy.extend_apply_of_one_le","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nF : f₀.Homotopy f₁\nt : Real\nht : LE.le 1 t\nx : X\n⊢ Eq ((F.extend t) x) (f₁ x)","decl":"theorem extend_apply_of_one_le (F : Homotopy f₀ f₁) {t : ℝ} (ht : 1 ≤ t) (x : X) :\n    F.extend t x = f₁ x := by\n  rw [← F.apply_one]\n  exact ContinuousMap.congr_fun (Set.IccExtend_of_right_le (zero_le_one' ℝ) F.curry ht) x\n\n"}
{"name":"ContinuousMap.Homotopy.extend_apply_coe","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nF : f₀.Homotopy f₁\nt : ↑unitInterval\nx : X\n⊢ Eq ((F.extend ↑t) x) (F { fst := t, snd := x })","decl":"theorem extend_apply_coe (F : Homotopy f₀ f₁) (t : I) (x : X) : F.extend t x = F (t, x) :=\n  ContinuousMap.congr_fun (Set.IccExtend_val (zero_le_one' ℝ) F.curry t) x\n\n"}
{"name":"ContinuousMap.Homotopy.extend_apply_of_mem_I","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nF : f₀.Homotopy f₁\nt : Real\nht : Membership.mem unitInterval t\nx : X\n⊢ Eq ((F.extend t) x) (F { fst := ⟨t, ht⟩, snd := x })","decl":"@[simp]\ntheorem extend_apply_of_mem_I (F : Homotopy f₀ f₁) {t : ℝ} (ht : t ∈ I) (x : X) :\n    F.extend t x = F (⟨t, ht⟩, x) :=\n  ContinuousMap.congr_fun (Set.IccExtend_of_mem (zero_le_one' ℝ) F.curry ht) x\n\n"}
{"name":"ContinuousMap.Homotopy.congr_fun","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nF G : f₀.Homotopy f₁\nh : Eq F G\nx : Prod (↑unitInterval) X\n⊢ Eq (F x) (G x)","decl":"protected theorem congr_fun {F G : Homotopy f₀ f₁} (h : F = G) (x : I × X) : F x = G x :=\n  ContinuousMap.congr_fun (congr_arg _ h) x\n\n"}
{"name":"ContinuousMap.Homotopy.congr_arg","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nF : f₀.Homotopy f₁\nx y : Prod (↑unitInterval) X\nh : Eq x y\n⊢ Eq (F x) (F y)","decl":"protected theorem congr_arg (F : Homotopy f₀ f₁) {x y : I × X} (h : x = y) : F x = F y :=\n  F.toContinuousMap.congr_arg h\n\n"}
{"name":"ContinuousMap.Homotopy.refl_apply","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : ContinuousMap X Y\nx : Prod (↑unitInterval) X\n⊢ Eq ((ContinuousMap.Homotopy.refl f) x) (f x.2)","decl":"/-- Given a continuous function `f`, we can define a `Homotopy f f` by `F (t, x) = f x`\n-/\n@[simps]\ndef refl (f : C(X, Y)) : Homotopy f f where\n  toFun x := f x.2\n  map_zero_left _ := rfl\n  map_one_left _ := rfl\n\n"}
{"name":"ContinuousMap.Homotopy.symm_apply","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nF : f₀.Homotopy f₁\nx : Prod (↑unitInterval) X\n⊢ Eq (F.symm x) (F { fst := unitInterval.symm x.1, snd := x.2 })","decl":"/-- Given a `Homotopy f₀ f₁`, we can define a `Homotopy f₁ f₀` by reversing the homotopy.\n-/\n@[simps]\ndef symm {f₀ f₁ : C(X, Y)} (F : Homotopy f₀ f₁) : Homotopy f₁ f₀ where\n  toFun x := F (σ x.1, x.2)\n  map_zero_left := by norm_num\n  map_one_left := by norm_num\n\n"}
{"name":"ContinuousMap.Homotopy.symm_symm","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nF : f₀.Homotopy f₁\n⊢ Eq F.symm.symm F","decl":"@[simp]\ntheorem symm_symm {f₀ f₁ : C(X, Y)} (F : Homotopy f₀ f₁) : F.symm.symm = F := by\n  ext\n  simp\n\n"}
{"name":"ContinuousMap.Homotopy.symm_bijective","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\n⊢ Function.Bijective ContinuousMap.Homotopy.symm","decl":"theorem symm_bijective {f₀ f₁ : C(X, Y)} :\n    Function.Bijective (Homotopy.symm : Homotopy f₀ f₁ → Homotopy f₁ f₀) :=\n  Function.bijective_iff_has_inverse.mpr ⟨_, symm_symm, symm_symm⟩\n\n"}
{"name":"ContinuousMap.Homotopy.trans_apply","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ f₂ : ContinuousMap X Y\nF : f₀.Homotopy f₁\nG : f₁.Homotopy f₂\nx : Prod (↑unitInterval) X\n⊢ Eq ((F.trans G) x) (dite (LE.le (↑x.1) (1 / 2)) (fun h => F { fst := ⟨HMul.hMul 2 ↑x.1, ⋯⟩, snd := x.2 }) fun h => G { fst := ⟨HSub.hSub (HMul.hMul 2 ↑x.1) 1, ⋯⟩, snd := x.2 })","decl":"theorem trans_apply {f₀ f₁ f₂ : C(X, Y)} (F : Homotopy f₀ f₁) (G : Homotopy f₁ f₂) (x : I × X) :\n    (F.trans G) x =\n      if h : (x.1 : ℝ) ≤ 1 / 2 then\n        F (⟨2 * x.1, (unitInterval.mul_pos_mem_iff zero_lt_two).2 ⟨x.1.2.1, h⟩⟩, x.2)\n      else\n        G (⟨2 * x.1 - 1, unitInterval.two_mul_sub_one_mem_iff.2 ⟨(not_le.1 h).le, x.1.2.2⟩⟩, x.2) :=\n  show ite _ _ _ = _ by\n    split_ifs <;>\n      · rw [extend, ContinuousMap.coe_IccExtend, Set.IccExtend_of_mem]\n        rfl\n\n"}
{"name":"ContinuousMap.Homotopy.symm_trans","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ f₂ : ContinuousMap X Y\nF : f₀.Homotopy f₁\nG : f₁.Homotopy f₂\n⊢ Eq (F.trans G).symm (G.symm.trans F.symm)","decl":"theorem symm_trans {f₀ f₁ f₂ : C(X, Y)} (F : Homotopy f₀ f₁) (G : Homotopy f₁ f₂) :\n    (F.trans G).symm = G.symm.trans F.symm := by\n  ext ⟨t, _⟩\n  rw [trans_apply, symm_apply, trans_apply]\n  simp only [coe_symm_eq, symm_apply]\n  split_ifs with h₁ h₂ h₂\n  · have ht : (t : ℝ) = 1 / 2 := by linarith\n    norm_num [ht]\n  · congr 2\n    apply Subtype.ext\n    simp only [coe_symm_eq]\n    linarith\n  · congr 2\n    apply Subtype.ext\n    simp only [coe_symm_eq]\n    linarith\n  · exfalso\n    linarith\n\n"}
{"name":"ContinuousMap.Homotopy.cast_apply","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ g₀ g₁ : ContinuousMap X Y\nF : f₀.Homotopy f₁\nh₀ : Eq f₀ g₀\nh₁ : Eq f₁ g₁\na : Prod (↑unitInterval) X\n⊢ Eq ((F.cast h₀ h₁) a) (F a)","decl":"/-- Casting a `Homotopy f₀ f₁` to a `Homotopy g₀ g₁` where `f₀ = g₀` and `f₁ = g₁`.\n-/\n@[simps]\ndef cast {f₀ f₁ g₀ g₁ : C(X, Y)} (F : Homotopy f₀ f₁) (h₀ : f₀ = g₀) (h₁ : f₁ = g₁) :\n    Homotopy g₀ g₁ where\n  toFun := F\n  map_zero_left := by simp [← h₀]\n  map_one_left := by simp [← h₁]\n\n"}
{"name":"ContinuousMap.Homotopy.compContinuousMap_apply","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\nZ : Type w\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\ng₀ g₁ : ContinuousMap Y Z\nG : g₀.Homotopy g₁\nf : ContinuousMap X Y\na✝ : Prod (↑unitInterval) X\n⊢ Eq ((G.compContinuousMap f) a✝) (G (Prod.map id (⇑f) a✝))","decl":"/-- Composition of a `Homotopy g₀ g₁` and `f : C(X, Y)` as a homotopy between `g₀.comp f` and\n`g₁.comp f`. -/\n@[simps!]\ndef compContinuousMap {g₀ g₁ : C(Y, Z)} (G : Homotopy g₀ g₁) (f : C(X, Y)) :\n    Homotopy (g₀.comp f) (g₁.comp f) where\n  toContinuousMap := G.comp (.prodMap (.id _) f)\n  map_zero_left _ := G.map_zero_left _\n  map_one_left _ := G.map_one_left _\n\n"}
{"name":"ContinuousMap.Homotopy.hcomp_apply","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\nZ : Type w\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf₀ f₁ : ContinuousMap X Y\ng₀ g₁ : ContinuousMap Y Z\nF : f₀.Homotopy f₁\nG : g₀.Homotopy g₁\nx : Prod (↑unitInterval) X\n⊢ Eq ((F.hcomp G) x) (G { fst := x.1, snd := F x })","decl":"/-- If we have a `Homotopy f₀ f₁` and a `Homotopy g₀ g₁`, then we can compose them and get a\n`Homotopy (g₀.comp f₀) (g₁.comp f₁)`.\n-/\n@[simps]\ndef hcomp {f₀ f₁ : C(X, Y)} {g₀ g₁ : C(Y, Z)} (F : Homotopy f₀ f₁) (G : Homotopy g₀ g₁) :\n    Homotopy (g₀.comp f₀) (g₁.comp f₁) where\n  toFun x := G (x.1, F x)\n  map_zero_left := by simp\n  map_one_left := by simp\n\n"}
{"name":"ContinuousMap.Homotopic.refl","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : ContinuousMap X Y\n⊢ f.Homotopic f","decl":"@[refl]\ntheorem refl (f : C(X, Y)) : Homotopic f f :=\n  ⟨Homotopy.refl f⟩\n\n"}
{"name":"ContinuousMap.Homotopic.symm","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf g : ContinuousMap X Y\nh : f.Homotopic g\n⊢ g.Homotopic f","decl":"@[symm]\ntheorem symm ⦃f g : C(X, Y)⦄ (h : Homotopic f g) : Homotopic g f :=\n  h.map Homotopy.symm\n\n"}
{"name":"ContinuousMap.Homotopic.trans","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf g h : ContinuousMap X Y\nh₀ : f.Homotopic g\nh₁ : g.Homotopic h\n⊢ f.Homotopic h","decl":"@[trans]\ntheorem trans ⦃f g h : C(X, Y)⦄ (h₀ : Homotopic f g) (h₁ : Homotopic g h) : Homotopic f h :=\n  h₀.map2 Homotopy.trans h₁\n\n"}
{"name":"ContinuousMap.Homotopic.hcomp","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\nZ : Type w\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf₀ f₁ : ContinuousMap X Y\ng₀ g₁ : ContinuousMap Y Z\nh₀ : f₀.Homotopic f₁\nh₁ : g₀.Homotopic g₁\n⊢ (g₀.comp f₀).Homotopic (g₁.comp f₁)","decl":"theorem hcomp {f₀ f₁ : C(X, Y)} {g₀ g₁ : C(Y, Z)} (h₀ : Homotopic f₀ f₁) (h₁ : Homotopic g₀ g₁) :\n    Homotopic (g₀.comp f₀) (g₁.comp f₁) :=\n  h₀.map2 Homotopy.hcomp h₁\n\n"}
{"name":"ContinuousMap.Homotopic.equivalence","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Equivalence ContinuousMap.Homotopic","decl":"theorem equivalence : Equivalence (@Homotopic X Y _ _) :=\n  ⟨refl, by apply symm, by apply trans⟩\n\n"}
{"name":"ContinuousMap.Homotopic.prodMk","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\nZ : Type w\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf₀ f₁ : ContinuousMap X Y\ng₀ g₁ : ContinuousMap X Z\na✝¹ : f₀.Homotopic f₁\na✝ : g₀.Homotopic g₁\n⊢ (f₀.prodMk g₀).Homotopic (f₁.prodMk g₁)","decl":"nonrec theorem prodMk {f₀ f₁ : C(X, Y)} {g₀ g₁ : C(X, Z)} :\n    Homotopic f₀ f₁ → Homotopic g₀ g₁ → Homotopic (f₀.prodMk g₀) (f₁.prodMk g₁)\n  | ⟨F⟩, ⟨G⟩ => ⟨F.prodMk G⟩\n\n"}
{"name":"ContinuousMap.Homotopic.prodMap","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\nZ : Type w\nZ' : Type x\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace Z'\nf₀ f₁ : ContinuousMap X Y\ng₀ g₁ : ContinuousMap Z Z'\na✝¹ : f₀.Homotopic f₁\na✝ : g₀.Homotopic g₁\n⊢ (f₀.prodMap g₀).Homotopic (f₁.prodMap g₁)","decl":"nonrec theorem prodMap {f₀ f₁ : C(X, Y)} {g₀ g₁ : C(Z, Z')} :\n    Homotopic f₀ f₁ → Homotopic g₀ g₁ → Homotopic (f₀.prodMap g₀) (f₁.prodMap g₁)\n  | ⟨F⟩, ⟨G⟩ => ⟨F.prodMap G⟩\n\n"}
{"name":"ContinuousMap.Homotopic.pi","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nι : Type u_2\ninst✝¹ : TopologicalSpace X\nY : ι → Type u_3\ninst✝ : (i : ι) → TopologicalSpace (Y i)\nf₀ f₁ : (i : ι) → ContinuousMap X (Y i)\nF : ∀ (i : ι), (f₀ i).Homotopic (f₁ i)\n⊢ (ContinuousMap.pi f₀).Homotopic (ContinuousMap.pi f₁)","decl":"/-- If each `f₀ i : C(X, Y i)` is homotopic to `f₁ i : C(X, Y i)`, then `ContinuousMap.pi f₀` is\nhomotopic to `ContinuousMap.pi f₁`. -/\nprotected theorem pi {Y : ι → Type*} [∀ i, TopologicalSpace (Y i)] {f₀ f₁ : ∀ i, C(X, Y i)}\n    (F : ∀ i, Homotopic (f₀ i) (f₁ i)) :\n    Homotopic (.pi f₀) (.pi f₁) :=\n  ⟨.pi fun i ↦ (F i).some⟩\n\n"}
{"name":"ContinuousMap.Homotopic.piMap","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"ι : Type u_2\nX : ι → Type u_3\nY : ι → Type u_4\ninst✝¹ : (i : ι) → TopologicalSpace (X i)\ninst✝ : (i : ι) → TopologicalSpace (Y i)\nf₀ f₁ : (i : ι) → ContinuousMap (X i) (Y i)\nF : ∀ (i : ι), (f₀ i).Homotopic (f₁ i)\n⊢ (ContinuousMap.piMap f₀).Homotopic (ContinuousMap.piMap f₁)","decl":"/-- If each `f₀ i : C(X, Y i)` is homotopic to `f₁ i : C(X, Y i)`, then `ContinuousMap.pi f₀` is\nhomotopic to `ContinuousMap.pi f₁`. -/\nprotected theorem piMap {X Y : ι → Type*} [∀ i, TopologicalSpace (X i)]\n    [∀ i, TopologicalSpace (Y i)] {f₀ f₁ : ∀ i, C(X i, Y i)} (F : ∀ i, Homotopic (f₀ i) (f₁ i)) :\n    Homotopic (.piMap f₀) (.piMap f₁) :=\n  .pi fun i ↦ .hcomp (.refl <| .eval i) (F i)\n\n"}
{"name":"ContinuousMap.HomotopyWith.mk.sizeOf_spec","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝⁴ : TopologicalSpace X\ninst✝³ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nP : ContinuousMap X Y → Prop\ninst✝² : SizeOf X\ninst✝¹ : SizeOf Y\ninst✝ : (a : ContinuousMap X Y) → SizeOf (P a)\ntoHomotopy : f₀.Homotopy f₁\nprop' : ∀ (t : ↑unitInterval), P { toFun := fun x => toHomotopy.toFun { fst := t, snd := x }, continuous_toFun := ⋯ }\n⊢ Eq (SizeOf.sizeOf { toHomotopy := toHomotopy, prop' := prop' }) (HAdd.hAdd 1 (SizeOf.sizeOf toHomotopy))","decl":"/--\nThe type of homotopies between `f₀ f₁ : C(X, Y)`, where the intermediate maps satisfy the predicate\n`P : C(X, Y) → Prop`\n-/\nstructure HomotopyWith (f₀ f₁ : C(X, Y)) (P : C(X, Y) → Prop) extends Homotopy f₀ f₁ where\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: use `toHomotopy.curry t`\n  /-- the intermediate maps of the homotopy satisfy the property -/\n  prop' : ∀ t, P ⟨fun x => toFun (t, x),\n    Continuous.comp continuous_toFun (continuous_const.prod_mk continuous_id')⟩\n\n"}
{"name":"ContinuousMap.HomotopyWith.mk.injEq","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nP : ContinuousMap X Y → Prop\ntoHomotopy✝ : f₀.Homotopy f₁\nprop'✝ : ∀ (t : ↑unitInterval), P { toFun := fun x => toHomotopy✝.toFun { fst := t, snd := x }, continuous_toFun := ⋯ }\ntoHomotopy : f₀.Homotopy f₁\nprop' : ∀ (t : ↑unitInterval), P { toFun := fun x => toHomotopy.toFun { fst := t, snd := x }, continuous_toFun := ⋯ }\n⊢ Eq (Eq { toHomotopy := toHomotopy✝, prop' := prop'✝ } { toHomotopy := toHomotopy, prop' := prop' }) (Eq toHomotopy✝ toHomotopy)","decl":"/--\nThe type of homotopies between `f₀ f₁ : C(X, Y)`, where the intermediate maps satisfy the predicate\n`P : C(X, Y) → Prop`\n-/\nstructure HomotopyWith (f₀ f₁ : C(X, Y)) (P : C(X, Y) → Prop) extends Homotopy f₀ f₁ where\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: use `toHomotopy.curry t`\n  /-- the intermediate maps of the homotopy satisfy the property -/\n  prop' : ∀ t, P ⟨fun x => toFun (t, x),\n    Continuous.comp continuous_toFun (continuous_const.prod_mk continuous_id')⟩\n\n"}
{"name":"ContinuousMap.HomotopyWith.prop'","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nP : ContinuousMap X Y → Prop\nself : f₀.HomotopyWith f₁ P\nt : ↑unitInterval\n⊢ P { toFun := fun x => self.toFun { fst := t, snd := x }, continuous_toFun := ⋯ }","decl":"/--\nThe type of homotopies between `f₀ f₁ : C(X, Y)`, where the intermediate maps satisfy the predicate\n`P : C(X, Y) → Prop`\n-/\nstructure HomotopyWith (f₀ f₁ : C(X, Y)) (P : C(X, Y) → Prop) extends Homotopy f₀ f₁ where\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: use `toHomotopy.curry t`\n  /-- the intermediate maps of the homotopy satisfy the property -/\n  prop' : ∀ t, P ⟨fun x => toFun (t, x),\n    Continuous.comp continuous_toFun (continuous_const.prod_mk continuous_id')⟩\n\n"}
{"name":"ContinuousMap.HomotopyWith.mk.inj","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nP : ContinuousMap X Y → Prop\ntoHomotopy✝ : f₀.Homotopy f₁\nprop'✝ : ∀ (t : ↑unitInterval), P { toFun := fun x => toHomotopy✝.toFun { fst := t, snd := x }, continuous_toFun := ⋯ }\ntoHomotopy : f₀.Homotopy f₁\nprop' : ∀ (t : ↑unitInterval), P { toFun := fun x => toHomotopy.toFun { fst := t, snd := x }, continuous_toFun := ⋯ }\nx✝ : Eq { toHomotopy := toHomotopy✝, prop' := prop'✝ } { toHomotopy := toHomotopy, prop' := prop' }\n⊢ Eq toHomotopy✝ toHomotopy","decl":"/--\nThe type of homotopies between `f₀ f₁ : C(X, Y)`, where the intermediate maps satisfy the predicate\n`P : C(X, Y) → Prop`\n-/\nstructure HomotopyWith (f₀ f₁ : C(X, Y)) (P : C(X, Y) → Prop) extends Homotopy f₀ f₁ where\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: use `toHomotopy.curry t`\n  /-- the intermediate maps of the homotopy satisfy the property -/\n  prop' : ∀ t, P ⟨fun x => toFun (t, x),\n    Continuous.comp continuous_toFun (continuous_const.prod_mk continuous_id')⟩\n\n"}
{"name":"ContinuousMap.HomotopyWith.instHomotopyLike","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nP : ContinuousMap X Y → Prop\n⊢ ContinuousMap.HomotopyLike (f₀.HomotopyWith f₁ P) f₀ f₁","decl":"instance : HomotopyLike (HomotopyWith f₀ f₁ P) f₀ f₁ where\n  map_continuous F := F.continuous_toFun\n  map_zero_left F := F.map_zero_left\n  map_one_left F := F.map_one_left\n\n"}
{"name":"ContinuousMap.HomotopyWith.coeFn_injective","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nP : ContinuousMap X Y → Prop\n⊢ Function.Injective DFunLike.coe","decl":"theorem coeFn_injective : @Function.Injective (HomotopyWith f₀ f₁ P) (I × X → Y) (⇑) :=\n  DFunLike.coe_injective'\n\n"}
{"name":"ContinuousMap.HomotopyWith.ext","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nP : ContinuousMap X Y → Prop\nF G : f₀.HomotopyWith f₁ P\nh : ∀ (x : Prod (↑unitInterval) X), Eq (F x) (G x)\n⊢ Eq F G","decl":"@[ext]\ntheorem ext {F G : HomotopyWith f₀ f₁ P} (h : ∀ x, F x = G x) : F = G := DFunLike.ext F G h\n\n"}
{"name":"ContinuousMap.HomotopyWith.ext_iff","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nP : ContinuousMap X Y → Prop\nF G : f₀.HomotopyWith f₁ P\n⊢ Iff (Eq F G) (∀ (x : Prod (↑unitInterval) X), Eq (F x) (G x))","decl":"@[ext]\ntheorem ext {F G : HomotopyWith f₀ f₁ P} (h : ∀ x, F x = G x) : F = G := DFunLike.ext F G h\n\n"}
{"name":"ContinuousMap.HomotopyWith.continuous","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nP : ContinuousMap X Y → Prop\nF : f₀.HomotopyWith f₁ P\n⊢ Continuous ⇑F","decl":"@[continuity]\nprotected theorem continuous (F : HomotopyWith f₀ f₁ P) : Continuous F :=\n  F.continuous_toFun\n\n"}
{"name":"ContinuousMap.HomotopyWith.apply_zero","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nP : ContinuousMap X Y → Prop\nF : f₀.HomotopyWith f₁ P\nx : X\n⊢ Eq (F { fst := 0, snd := x }) (f₀ x)","decl":"@[simp]\ntheorem apply_zero (F : HomotopyWith f₀ f₁ P) (x : X) : F (0, x) = f₀ x :=\n  F.map_zero_left x\n\n"}
{"name":"ContinuousMap.HomotopyWith.apply_one","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nP : ContinuousMap X Y → Prop\nF : f₀.HomotopyWith f₁ P\nx : X\n⊢ Eq (F { fst := 1, snd := x }) (f₁ x)","decl":"@[simp]\ntheorem apply_one (F : HomotopyWith f₀ f₁ P) (x : X) : F (1, x) = f₁ x :=\n  F.map_one_left x\n\n-- Porting note: removed `simp`\n"}
{"name":"ContinuousMap.HomotopyWith.coe_toContinuousMap","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nP : ContinuousMap X Y → Prop\nF : f₀.HomotopyWith f₁ P\n⊢ Eq ⇑F.toContinuousMap ⇑F","decl":"theorem coe_toContinuousMap (F : HomotopyWith f₀ f₁ P) : ⇑F.toContinuousMap = F :=\n  rfl\n\n"}
{"name":"ContinuousMap.HomotopyWith.coe_toHomotopy","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nP : ContinuousMap X Y → Prop\nF : f₀.HomotopyWith f₁ P\n⊢ Eq ⇑F.toHomotopy ⇑F","decl":"@[simp]\ntheorem coe_toHomotopy (F : HomotopyWith f₀ f₁ P) : ⇑F.toHomotopy = F :=\n  rfl\n\n"}
{"name":"ContinuousMap.HomotopyWith.prop","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nP : ContinuousMap X Y → Prop\nF : f₀.HomotopyWith f₁ P\nt : ↑unitInterval\n⊢ P (F.curry t)","decl":"theorem prop (F : HomotopyWith f₀ f₁ P) (t : I) : P (F.toHomotopy.curry t) := F.prop' t\n\n"}
{"name":"ContinuousMap.HomotopyWith.extendProp","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nP : ContinuousMap X Y → Prop\nF : f₀.HomotopyWith f₁ P\nt : Real\n⊢ P (F.extend t)","decl":"theorem extendProp (F : HomotopyWith f₀ f₁ P) (t : ℝ) : P (F.toHomotopy.extend t) := F.prop _\n\n"}
{"name":"ContinuousMap.HomotopyWith.refl_apply","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nP : ContinuousMap X Y → Prop\nf : ContinuousMap X Y\nhf : P f\nx : Prod (↑unitInterval) X\n⊢ Eq ((ContinuousMap.HomotopyWith.refl f hf) x) (f x.2)","decl":"/-- Given a continuous function `f`, and a proof `h : P f`, we can define a `HomotopyWith f f P` by\n`F (t, x) = f x`\n-/\n@[simps!]\ndef refl (f : C(X, Y)) (hf : P f) : HomotopyWith f f P where\n  toHomotopy := Homotopy.refl f\n  prop' := fun _ => hf\n\n"}
{"name":"ContinuousMap.HomotopyWith.symm_apply","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nP : ContinuousMap X Y → Prop\nf₀ f₁ : ContinuousMap X Y\nF : f₀.HomotopyWith f₁ P\nx : Prod (↑unitInterval) X\n⊢ Eq (F.symm x) (F { fst := unitInterval.symm x.1, snd := x.2 })","decl":"/--\nGiven a `HomotopyWith f₀ f₁ P`, we can define a `HomotopyWith f₁ f₀ P` by reversing the homotopy.\n-/\n@[simps!]\ndef symm {f₀ f₁ : C(X, Y)} (F : HomotopyWith f₀ f₁ P) : HomotopyWith f₁ f₀ P where\n  toHomotopy := F.toHomotopy.symm\n  prop' := fun t => F.prop (σ t)\n\n"}
{"name":"ContinuousMap.HomotopyWith.symm_symm","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nP : ContinuousMap X Y → Prop\nf₀ f₁ : ContinuousMap X Y\nF : f₀.HomotopyWith f₁ P\n⊢ Eq F.symm.symm F","decl":"@[simp]\ntheorem symm_symm {f₀ f₁ : C(X, Y)} (F : HomotopyWith f₀ f₁ P) : F.symm.symm = F :=\n  ext <| Homotopy.congr_fun <| Homotopy.symm_symm _\n\n"}
{"name":"ContinuousMap.HomotopyWith.symm_bijective","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nP : ContinuousMap X Y → Prop\nf₀ f₁ : ContinuousMap X Y\n⊢ Function.Bijective ContinuousMap.HomotopyWith.symm","decl":"theorem symm_bijective {f₀ f₁ : C(X, Y)} :\n    Function.Bijective (HomotopyWith.symm : HomotopyWith f₀ f₁ P → HomotopyWith f₁ f₀ P) :=\n  Function.bijective_iff_has_inverse.mpr ⟨_, symm_symm, symm_symm⟩\n\n"}
{"name":"ContinuousMap.HomotopyWith.trans_apply","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nP : ContinuousMap X Y → Prop\nf₀ f₁ f₂ : ContinuousMap X Y\nF : f₀.HomotopyWith f₁ P\nG : f₁.HomotopyWith f₂ P\nx : Prod (↑unitInterval) X\n⊢ Eq ((F.trans G) x) (dite (LE.le (↑x.1) (1 / 2)) (fun h => F { fst := ⟨HMul.hMul 2 ↑x.1, ⋯⟩, snd := x.2 }) fun h => G { fst := ⟨HSub.hSub (HMul.hMul 2 ↑x.1) 1, ⋯⟩, snd := x.2 })","decl":"theorem trans_apply {f₀ f₁ f₂ : C(X, Y)} (F : HomotopyWith f₀ f₁ P) (G : HomotopyWith f₁ f₂ P)\n    (x : I × X) :\n    (F.trans G) x =\n      if h : (x.1 : ℝ) ≤ 1 / 2 then\n        F (⟨2 * x.1, (unitInterval.mul_pos_mem_iff zero_lt_two).2 ⟨x.1.2.1, h⟩⟩, x.2)\n      else\n        G (⟨2 * x.1 - 1, unitInterval.two_mul_sub_one_mem_iff.2 ⟨(not_le.1 h).le, x.1.2.2⟩⟩, x.2) :=\n  Homotopy.trans_apply _ _ _\n\n"}
{"name":"ContinuousMap.HomotopyWith.symm_trans","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nP : ContinuousMap X Y → Prop\nf₀ f₁ f₂ : ContinuousMap X Y\nF : f₀.HomotopyWith f₁ P\nG : f₁.HomotopyWith f₂ P\n⊢ Eq (F.trans G).symm (G.symm.trans F.symm)","decl":"theorem symm_trans {f₀ f₁ f₂ : C(X, Y)} (F : HomotopyWith f₀ f₁ P) (G : HomotopyWith f₁ f₂ P) :\n    (F.trans G).symm = G.symm.trans F.symm :=\n  ext <| Homotopy.congr_fun <| Homotopy.symm_trans _ _\n\n"}
{"name":"ContinuousMap.HomotopyWith.cast_apply","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nP : ContinuousMap X Y → Prop\nf₀ f₁ g₀ g₁ : ContinuousMap X Y\nF : f₀.HomotopyWith f₁ P\nh₀ : Eq f₀ g₀\nh₁ : Eq f₁ g₁\na : Prod (↑unitInterval) X\n⊢ Eq ((F.cast h₀ h₁) a) (F a)","decl":"/-- Casting a `HomotopyWith f₀ f₁ P` to a `HomotopyWith g₀ g₁ P` where `f₀ = g₀` and `f₁ = g₁`.\n-/\n@[simps!]\ndef cast {f₀ f₁ g₀ g₁ : C(X, Y)} (F : HomotopyWith f₀ f₁ P) (h₀ : f₀ = g₀) (h₁ : f₁ = g₁) :\n    HomotopyWith g₀ g₁ P where\n  toHomotopy := F.toHomotopy.cast h₀ h₁\n  prop' := F.prop\n\n"}
{"name":"ContinuousMap.HomotopicWith.refl","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nP : ContinuousMap X Y → Prop\nf : ContinuousMap X Y\nhf : P f\n⊢ f.HomotopicWith f P","decl":"theorem refl (f : C(X, Y)) (hf : P f) : HomotopicWith f f P :=\n  ⟨HomotopyWith.refl f hf⟩\n\n"}
{"name":"ContinuousMap.HomotopicWith.symm","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nP : ContinuousMap X Y → Prop\nf g : ContinuousMap X Y\nh : f.HomotopicWith g P\n⊢ g.HomotopicWith f P","decl":"@[symm]\ntheorem symm ⦃f g : C(X, Y)⦄ (h : HomotopicWith f g P) : HomotopicWith g f P :=\n  ⟨h.some.symm⟩\n\n-- Note: this was formerly tagged with `@[trans]`, and although the `trans` attribute accepted it\n-- the `trans` tactic could not use it.\n-- An update to the trans tactic coming in https://github.com/leanprover-community/mathlib4/pull/7014 will reject this attribute.\n-- It could be restored by changing the argument order to `HomotopicWith P f g`.\n"}
{"name":"ContinuousMap.HomotopicWith.trans","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nP : ContinuousMap X Y → Prop\nf g h : ContinuousMap X Y\nh₀ : f.HomotopicWith g P\nh₁ : g.HomotopicWith h P\n⊢ f.HomotopicWith h P","decl":"@[trans]\ntheorem trans ⦃f g h : C(X, Y)⦄ (h₀ : HomotopicWith f g P) (h₁ : HomotopicWith g h P) :\n    HomotopicWith f h P :=\n  ⟨h₀.some.trans h₁.some⟩\n\n"}
{"name":"ContinuousMap.HomotopyRel.eq_fst","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nS : Set X\nF : f₀.HomotopyRel f₁ S\nt : ↑unitInterval\nx : X\nhx : Membership.mem S x\n⊢ Eq (F { fst := t, snd := x }) (f₀ x)","decl":"theorem eq_fst (F : HomotopyRel f₀ f₁ S) (t : I) {x : X} (hx : x ∈ S) : F (t, x) = f₀ x :=\n  F.prop t x hx\n\n"}
{"name":"ContinuousMap.HomotopyRel.eq_snd","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nS : Set X\nF : f₀.HomotopyRel f₁ S\nt : ↑unitInterval\nx : X\nhx : Membership.mem S x\n⊢ Eq (F { fst := t, snd := x }) (f₁ x)","decl":"theorem eq_snd (F : HomotopyRel f₀ f₁ S) (t : I) {x : X} (hx : x ∈ S) : F (t, x) = f₁ x := by\n  rw [F.eq_fst t hx, ← F.eq_fst 1 hx, F.apply_one]\n\n"}
{"name":"ContinuousMap.HomotopyRel.fst_eq_snd","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nS : Set X\nF : f₀.HomotopyRel f₁ S\nx : X\nhx : Membership.mem S x\n⊢ Eq (f₀ x) (f₁ x)","decl":"theorem fst_eq_snd (F : HomotopyRel f₀ f₁ S) {x : X} (hx : x ∈ S) : f₀ x = f₁ x :=\n  F.eq_fst 0 hx ▸ F.eq_snd 0 hx\n\n"}
{"name":"ContinuousMap.HomotopyRel.refl_apply","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : ContinuousMap X Y\nS : Set X\nx : Prod (↑unitInterval) X\n⊢ Eq ((ContinuousMap.HomotopyRel.refl f S) x) (f x.2)","decl":"/-- Given a map `f : C(X, Y)` and a set `S`, we can define a `HomotopyRel f f S` by setting\n`F (t, x) = f x` for all `t`. This is defined using `HomotopyWith.refl`, but with the proof\nfilled in.\n-/\n@[simps!]\ndef refl (f : C(X, Y)) (S : Set X) : HomotopyRel f f S :=\n  HomotopyWith.refl f fun _ _ ↦ rfl\n\n"}
{"name":"ContinuousMap.HomotopyRel.symm_apply","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nS : Set X\nF : f₀.HomotopyRel f₁ S\nx : Prod (↑unitInterval) X\n⊢ Eq (F.symm x) (F { fst := unitInterval.symm x.1, snd := x.2 })","decl":"/--\nGiven a `HomotopyRel f₀ f₁ S`, we can define a `HomotopyRel f₁ f₀ S` by reversing the homotopy.\n-/\n@[simps!]\ndef symm (F : HomotopyRel f₀ f₁ S) : HomotopyRel f₁ f₀ S where\n  toHomotopy := F.toHomotopy.symm\n  prop' := fun _ _ hx ↦ F.eq_snd _ hx\n\n"}
{"name":"ContinuousMap.HomotopyRel.symm_symm","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nS : Set X\nF : f₀.HomotopyRel f₁ S\n⊢ Eq F.symm.symm F","decl":"@[simp]\ntheorem symm_symm (F : HomotopyRel f₀ f₁ S) : F.symm.symm = F :=\n  HomotopyWith.symm_symm F\n\n"}
{"name":"ContinuousMap.HomotopyRel.symm_bijective","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\nS : Set X\n⊢ Function.Bijective ContinuousMap.HomotopyRel.symm","decl":"theorem symm_bijective :\n    Function.Bijective (HomotopyRel.symm : HomotopyRel f₀ f₁ S → HomotopyRel f₁ f₀ S) :=\n  Function.bijective_iff_has_inverse.mpr ⟨_, symm_symm, symm_symm⟩\n\n"}
{"name":"ContinuousMap.HomotopyRel.trans_apply","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ f₂ : ContinuousMap X Y\nS : Set X\nF : f₀.HomotopyRel f₁ S\nG : f₁.HomotopyRel f₂ S\nx : Prod (↑unitInterval) X\n⊢ Eq ((F.trans G) x) (dite (LE.le (↑x.1) (1 / 2)) (fun h => F { fst := ⟨HMul.hMul 2 ↑x.1, ⋯⟩, snd := x.2 }) fun h => G { fst := ⟨HSub.hSub (HMul.hMul 2 ↑x.1) 1, ⋯⟩, snd := x.2 })","decl":"theorem trans_apply (F : HomotopyRel f₀ f₁ S) (G : HomotopyRel f₁ f₂ S) (x : I × X) :\n    (F.trans G) x =\n      if h : (x.1 : ℝ) ≤ 1 / 2 then\n        F (⟨2 * x.1, (unitInterval.mul_pos_mem_iff zero_lt_two).2 ⟨x.1.2.1, h⟩⟩, x.2)\n      else\n        G (⟨2 * x.1 - 1, unitInterval.two_mul_sub_one_mem_iff.2 ⟨(not_le.1 h).le, x.1.2.2⟩⟩, x.2) :=\n  Homotopy.trans_apply _ _ _\n\n"}
{"name":"ContinuousMap.HomotopyRel.symm_trans","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ f₂ : ContinuousMap X Y\nS : Set X\nF : f₀.HomotopyRel f₁ S\nG : f₁.HomotopyRel f₂ S\n⊢ Eq (F.trans G).symm (G.symm.trans F.symm)","decl":"theorem symm_trans (F : HomotopyRel f₀ f₁ S) (G : HomotopyRel f₁ f₂ S) :\n    (F.trans G).symm = G.symm.trans F.symm :=\n  HomotopyWith.ext <| Homotopy.congr_fun <| Homotopy.symm_trans _ _\n\n"}
{"name":"ContinuousMap.HomotopyRel.cast_apply","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nS : Set X\nf₀ f₁ g₀ g₁ : ContinuousMap X Y\nF : f₀.HomotopyRel f₁ S\nh₀ : Eq f₀ g₀\nh₁ : Eq f₁ g₁\na : Prod (↑unitInterval) X\n⊢ Eq ((F.cast h₀ h₁) a) (F a)","decl":"/-- Casting a `HomotopyRel f₀ f₁ S` to a `HomotopyRel g₀ g₁ S` where `f₀ = g₀` and `f₁ = g₁`.\n-/\n@[simps!]\ndef cast {f₀ f₁ g₀ g₁ : C(X, Y)} (F : HomotopyRel f₀ f₁ S) (h₀ : f₀ = g₀) (h₁ : f₁ = g₁) :\n    HomotopyRel g₀ g₁ S where\n  toHomotopy := Homotopy.cast F.toHomotopy h₀ h₁\n  prop' t x hx := by simpa only [← h₀, ← h₁] using F.prop t x hx\n\n"}
{"name":"ContinuousMap.HomotopyRel.compContinuousMap_apply","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\nZ : Type w\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nS : Set X\nf₀ f₁ : ContinuousMap X Y\nF : f₀.HomotopyRel f₁ S\ng : ContinuousMap Y Z\nx : Prod (↑unitInterval) X\n⊢ Eq ((F.compContinuousMap g) x) (g (F x))","decl":"/-- Post-compose a homotopy relative to a set by a continuous function. -/\n@[simps!] def compContinuousMap {f₀ f₁ : C(X, Y)} (F : f₀.HomotopyRel f₁ S) (g : C(Y, Z)) :\n    (g.comp f₀).HomotopyRel (g.comp f₁) S where\n  toHomotopy := F.hcomp (ContinuousMap.Homotopy.refl g)\n  prop' t x hx := congr_arg g (F.prop t x hx)\n\n"}
{"name":"ContinuousMap.HomotopicRel.homotopic","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nS : Set X\nf₀ f₁ : ContinuousMap X Y\nh : f₀.HomotopicRel f₁ S\n⊢ f₀.Homotopic f₁","decl":"/-- If two maps are homotopic relative to a set, then they are homotopic. -/\nprotected theorem homotopic {f₀ f₁ : C(X, Y)} (h : HomotopicRel f₀ f₁ S) : Homotopic f₀ f₁ :=\n  h.map fun F ↦ F.1\n\n-- Porting note: removed @[refl]\n"}
{"name":"ContinuousMap.HomotopicRel.refl","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nS : Set X\nf : ContinuousMap X Y\n⊢ f.HomotopicRel f S","decl":"theorem refl (f : C(X, Y)) : HomotopicRel f f S :=\n  ⟨HomotopyRel.refl f S⟩\n\n"}
{"name":"ContinuousMap.HomotopicRel.symm","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nS : Set X\nf g : ContinuousMap X Y\nh : f.HomotopicRel g S\n⊢ g.HomotopicRel f S","decl":"@[symm]\ntheorem symm ⦃f g : C(X, Y)⦄ (h : HomotopicRel f g S) : HomotopicRel g f S :=\n  h.map HomotopyRel.symm\n\n"}
{"name":"ContinuousMap.HomotopicRel.trans","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nS : Set X\nf g h : ContinuousMap X Y\nh₀ : f.HomotopicRel g S\nh₁ : g.HomotopicRel h S\n⊢ f.HomotopicRel h S","decl":"@[trans]\ntheorem trans ⦃f g h : C(X, Y)⦄ (h₀ : HomotopicRel f g S) (h₁ : HomotopicRel g h S) :\n    HomotopicRel f h S :=\n  h₀.map2 HomotopyRel.trans h₁\n\n"}
{"name":"ContinuousMap.HomotopicRel.equivalence","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nS : Set X\n⊢ Equivalence fun f g => f.HomotopicRel g S","decl":"theorem equivalence : Equivalence fun f g : C(X, Y) => HomotopicRel f g S :=\n  ⟨refl, by apply symm, by apply trans⟩\n\n"}
{"name":"ContinuousMap.homotopicRel_empty","module":"Mathlib.Topology.Homotopy.Basic","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf₀ f₁ : ContinuousMap X Y\n⊢ Iff (f₀.HomotopicRel f₁ EmptyCollection.emptyCollection) (f₀.Homotopic f₁)","decl":"@[simp] theorem homotopicRel_empty {f₀ f₁ : C(X, Y)} : HomotopicRel f₀ f₁ ∅ ↔ Homotopic f₀ f₁ :=\n  ⟨fun h ↦ h.homotopic, fun ⟨F⟩ ↦ ⟨⟨F, fun _ _ ↦ False.elim⟩⟩⟩\n\n"}
