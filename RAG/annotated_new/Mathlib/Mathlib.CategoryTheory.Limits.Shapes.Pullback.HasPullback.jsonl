{"name":"CategoryTheory.Limits.PullbackCone.fst_limit_cone","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan f g)\n‚ä¢ Eq (CategoryTheory.Limits.PullbackCone.fst (CategoryTheory.Limits.limit.cone (CategoryTheory.Limits.cospan f g))) (CategoryTheory.Limits.pullback.fst f g)","decl":"@[simp]\ntheorem PullbackCone.fst_limit_cone {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [HasLimit (cospan f g)] :\n    PullbackCone.fst (limit.cone (cospan f g)) = pullback.fst f g := rfl\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.snd_limit_cone","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan f g)\n‚ä¢ Eq (CategoryTheory.Limits.PullbackCone.snd (CategoryTheory.Limits.limit.cone (CategoryTheory.Limits.cospan f g))) (CategoryTheory.Limits.pullback.snd f g)","decl":"@[simp]\ntheorem PullbackCone.snd_limit_cone {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [HasLimit (cospan f g)] :\n    PullbackCone.snd (limit.cone (cospan f g)) = pullback.snd f g := rfl\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.inl_colimit_cocone","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninst‚úù : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.span f g)\n‚ä¢ Eq (CategoryTheory.Limits.PushoutCocone.inl (CategoryTheory.Limits.colimit.cocone (CategoryTheory.Limits.span f g))) (CategoryTheory.Limits.pushout.inl f g)","decl":"theorem PushoutCocone.inl_colimit_cocone {X Y Z : C} (f : Z ‚ü∂ X) (g : Z ‚ü∂ Y)\n    [HasColimit (span f g)] : PushoutCocone.inl (colimit.cocone (span f g)) = pushout.inl _ _ := rfl\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.inr_colimit_cocone","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninst‚úù : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.span f g)\n‚ä¢ Eq (CategoryTheory.Limits.PushoutCocone.inr (CategoryTheory.Limits.colimit.cocone (CategoryTheory.Limits.span f g))) (CategoryTheory.Limits.pushout.inr f g)","decl":"theorem PushoutCocone.inr_colimit_cocone {X Y Z : C} (f : Z ‚ü∂ X) (g : Z ‚ü∂ Y)\n    [HasColimit (span f g)] : PushoutCocone.inr (colimit.cocone (span f g)) = pushout.inr _ _ := rfl\n\n"}
{"name":"CategoryTheory.Limits.pullback.lift_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW X Y Z‚úù : C\nf : Quiver.Hom X Z‚úù\ng : Quiver.Hom Y Z‚úù\ninst‚úù : CategoryTheory.Limits.HasPullback f g\nh‚úù : Quiver.Hom W X\nk : Quiver.Hom W Y\nw : Eq (CategoryTheory.CategoryStruct.comp h‚úù f) (CategoryTheory.CategoryStruct.comp k g)\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.lift h‚úù k w) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) h)) (CategoryTheory.CategoryStruct.comp h‚úù h)","decl":"@[reassoc]\ntheorem pullback.lift_fst {W X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [HasPullback f g] (h : W ‚ü∂ X)\n    (k : W ‚ü∂ Y) (w : h ‚â´ f = k ‚â´ g) : pullback.lift h k w ‚â´ pullback.fst f g = h :=\n  limit.lift_œÄ _ _\n\n"}
{"name":"CategoryTheory.Limits.pullback.lift_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Limits.HasPullback f g\nh : Quiver.Hom W X\nk : Quiver.Hom W Y\nw : Eq (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp k g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.lift h k w) (CategoryTheory.Limits.pullback.fst f g)) h","decl":"@[reassoc]\ntheorem pullback.lift_fst {W X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [HasPullback f g] (h : W ‚ü∂ X)\n    (k : W ‚ü∂ Y) (w : h ‚â´ f = k ‚â´ g) : pullback.lift h k w ‚â´ pullback.fst f g = h :=\n  limit.lift_œÄ _ _\n\n"}
{"name":"CategoryTheory.Limits.pullback.lift_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW X Y Z‚úù : C\nf : Quiver.Hom X Z‚úù\ng : Quiver.Hom Y Z‚úù\ninst‚úù : CategoryTheory.Limits.HasPullback f g\nh‚úù : Quiver.Hom W X\nk : Quiver.Hom W Y\nw : Eq (CategoryTheory.CategoryStruct.comp h‚úù f) (CategoryTheory.CategoryStruct.comp k g)\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.lift h‚úù k w) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc]\ntheorem pullback.lift_snd {W X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [HasPullback f g] (h : W ‚ü∂ X)\n    (k : W ‚ü∂ Y) (w : h ‚â´ f = k ‚â´ g) : pullback.lift h k w ‚â´ pullback.snd f g = k :=\n  limit.lift_œÄ _ _\n\n"}
{"name":"CategoryTheory.Limits.pullback.lift_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Limits.HasPullback f g\nh : Quiver.Hom W X\nk : Quiver.Hom W Y\nw : Eq (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp k g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.lift h k w) (CategoryTheory.Limits.pullback.snd f g)) k","decl":"@[reassoc]\ntheorem pullback.lift_snd {W X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [HasPullback f g] (h : W ‚ü∂ X)\n    (k : W ‚ü∂ Y) (w : h ‚â´ f = k ‚â´ g) : pullback.lift h k w ‚â´ pullback.snd f g = k :=\n  limit.lift_œÄ _ _\n\n"}
{"name":"CategoryTheory.Limits.pushout.inl_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst‚úù : CategoryTheory.Limits.HasPushout f g\nh : Quiver.Hom Y W\nk : Quiver.Hom Z W\nw : Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g k)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) (CategoryTheory.Limits.pushout.desc h k w)) h","decl":"@[reassoc]\ntheorem pushout.inl_desc {W X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [HasPushout f g] (h : Y ‚ü∂ W)\n    (k : Z ‚ü∂ W) (w : f ‚â´ h = g ‚â´ k) : pushout.inl _ _ ‚â´ pushout.desc h k w = h :=\n  colimit.Œπ_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.pushout.inl_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW X Y Z‚úù : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z‚úù\ninst‚úù : CategoryTheory.Limits.HasPushout f g\nh‚úù : Quiver.Hom Y W\nk : Quiver.Hom Z‚úù W\nw : Eq (CategoryTheory.CategoryStruct.comp f h‚úù) (CategoryTheory.CategoryStruct.comp g k)\nZ : C\nh : Quiver.Hom W Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.desc h‚úù k w) h)) (CategoryTheory.CategoryStruct.comp h‚úù h)","decl":"@[reassoc]\ntheorem pushout.inl_desc {W X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [HasPushout f g] (h : Y ‚ü∂ W)\n    (k : Z ‚ü∂ W) (w : f ‚â´ h = g ‚â´ k) : pushout.inl _ _ ‚â´ pushout.desc h k w = h :=\n  colimit.Œπ_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.pushout.inr_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW X Y Z‚úù : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z‚úù\ninst‚úù : CategoryTheory.Limits.HasPushout f g\nh‚úù : Quiver.Hom Y W\nk : Quiver.Hom Z‚úù W\nw : Eq (CategoryTheory.CategoryStruct.comp f h‚úù) (CategoryTheory.CategoryStruct.comp g k)\nZ : C\nh : Quiver.Hom W Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.desc h‚úù k w) h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc]\ntheorem pushout.inr_desc {W X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [HasPushout f g] (h : Y ‚ü∂ W)\n    (k : Z ‚ü∂ W) (w : f ‚â´ h = g ‚â´ k) : pushout.inr _ _ ‚â´ pushout.desc h k w = k :=\n  colimit.Œπ_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.pushout.inr_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst‚úù : CategoryTheory.Limits.HasPushout f g\nh : Quiver.Hom Y W\nk : Quiver.Hom Z W\nw : Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g k)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) (CategoryTheory.Limits.pushout.desc h k w)) k","decl":"@[reassoc]\ntheorem pushout.inr_desc {W X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [HasPushout f g] (h : Y ‚ü∂ W)\n    (k : Z ‚ü∂ W) (w : f ‚â´ h = g ‚â´ k) : pushout.inr _ _ ‚â´ pushout.desc h k w = k :=\n  colimit.Œπ_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.pullback.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Limits.HasPullback f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) g)","decl":"@[reassoc]\ntheorem pullback.condition {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [HasPullback f g] :\n    pullback.fst f g ‚â´ f = pullback.snd f g ‚â´ g :=\n  PullbackCone.condition _\n\n"}
{"name":"CategoryTheory.Limits.pullback.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z‚úù : C\nf : Quiver.Hom X Z‚úù\ng : Quiver.Hom Y Z‚úù\ninst‚úù : CategoryTheory.Limits.HasPullback f g\nZ : C\nh : Quiver.Hom Z‚úù Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc]\ntheorem pullback.condition {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [HasPullback f g] :\n    pullback.fst f g ‚â´ f = pullback.snd f g ‚â´ g :=\n  PullbackCone.condition _\n\n"}
{"name":"CategoryTheory.Limits.pushout.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z‚úù : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z‚úù\ninst‚úù : CategoryTheory.Limits.HasPushout f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout f g) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) h)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) h))","decl":"@[reassoc]\ntheorem pushout.condition {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [HasPushout f g] :\n    f ‚â´ (pushout.inl f g) = g ‚â´ pushout.inr _ _ :=\n  PushoutCocone.condition _\n\n"}
{"name":"CategoryTheory.Limits.pushout.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst‚úù : CategoryTheory.Limits.HasPushout f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.pushout.inl f g)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.pushout.inr f g))","decl":"@[reassoc]\ntheorem pushout.condition {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [HasPushout f g] :\n    f ‚â´ (pushout.inl f g) = g ‚â´ pushout.inr _ _ :=\n  PushoutCocone.condition _\n\n"}
{"name":"CategoryTheory.Limits.pullback.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Limits.HasPullback f g\nW : C\nk l : Quiver.Hom W (CategoryTheory.Limits.pullback f g)\nh‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp k (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.CategoryStruct.comp l (CategoryTheory.Limits.pullback.fst f g))\nh‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp k (CategoryTheory.Limits.pullback.snd f g)) (CategoryTheory.CategoryStruct.comp l (CategoryTheory.Limits.pullback.snd f g))\n‚ä¢ Eq k l","decl":"/-- Two morphisms into a pullback are equal if their compositions with the pullback morphisms are\n    equal -/\n@[ext 1100]\ntheorem pullback.hom_ext {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [HasPullback f g] {W : C}\n    {k l : W ‚ü∂ pullback f g} (h‚ÇÄ : k ‚â´ pullback.fst f g = l ‚â´ pullback.fst f g)\n    (h‚ÇÅ : k ‚â´ pullback.snd f g = l ‚â´ pullback.snd f g) : k = l :=\n  limit.hom_ext <| PullbackCone.equalizer_ext _ h‚ÇÄ h‚ÇÅ\n\n"}
{"name":"CategoryTheory.Limits.pullback.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Limits.HasPullback f g\nW : C\nk l : Quiver.Hom W (CategoryTheory.Limits.pullback f g)\n‚ä¢ Iff (Eq k l) (And (Eq (CategoryTheory.CategoryStruct.comp k (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.CategoryStruct.comp l (CategoryTheory.Limits.pullback.fst f g))) (Eq (CategoryTheory.CategoryStruct.comp k (CategoryTheory.Limits.pullback.snd f g)) (CategoryTheory.CategoryStruct.comp l (CategoryTheory.Limits.pullback.snd f g))))","decl":"/-- Two morphisms into a pullback are equal if their compositions with the pullback morphisms are\n    equal -/\n@[ext 1100]\ntheorem pullback.hom_ext {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [HasPullback f g] {W : C}\n    {k l : W ‚ü∂ pullback f g} (h‚ÇÄ : k ‚â´ pullback.fst f g = l ‚â´ pullback.fst f g)\n    (h‚ÇÅ : k ‚â´ pullback.snd f g = l ‚â´ pullback.snd f g) : k = l :=\n  limit.hom_ext <| PullbackCone.equalizer_ext _ h‚ÇÄ h‚ÇÅ\n\n"}
{"name":"CategoryTheory.Limits.pushout.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst‚úù : CategoryTheory.Limits.HasPushout f g\nW : C\nk l : Quiver.Hom (CategoryTheory.Limits.pushout f g) W\nh‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) l)\nh‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) l)\n‚ä¢ Eq k l","decl":"/-- Two morphisms out of a pushout are equal if their compositions with the pushout morphisms are\n    equal -/\n@[ext 1100]\ntheorem pushout.hom_ext {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [HasPushout f g] {W : C}\n    {k l : pushout f g ‚ü∂ W} (h‚ÇÄ : pushout.inl _ _ ‚â´ k = pushout.inl _ _ ‚â´ l)\n    (h‚ÇÅ : pushout.inr _ _ ‚â´ k = pushout.inr _ _ ‚â´ l) : k = l :=\n  colimit.hom_ext <| PushoutCocone.coequalizer_ext _ h‚ÇÄ h‚ÇÅ\n\n"}
{"name":"CategoryTheory.Limits.pushout.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst‚úù : CategoryTheory.Limits.HasPushout f g\nW : C\nk l : Quiver.Hom (CategoryTheory.Limits.pushout f g) W\n‚ä¢ Iff (Eq k l) (And (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) l)) (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) l)))","decl":"/-- Two morphisms out of a pushout are equal if their compositions with the pushout morphisms are\n    equal -/\n@[ext 1100]\ntheorem pushout.hom_ext {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [HasPushout f g] {W : C}\n    {k l : pushout f g ‚ü∂ W} (h‚ÇÄ : pushout.inl _ _ ‚â´ k = pushout.inl _ _ ‚â´ l)\n    (h‚ÇÅ : pushout.inr _ _ ‚â´ k = pushout.inr _ _ ‚â´ l) : k = l :=\n  colimit.hom_ext <| PushoutCocone.coequalizer_ext _ h‚ÇÄ h‚ÇÅ\n\n"}
{"name":"CategoryTheory.Limits.pullback.map_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y Z X' Y' Z' X'' Y'' Z'' : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nf' : Quiver.Hom X' Z'\ng' : Quiver.Hom Y' Z'\nf'' : Quiver.Hom X'' Z''\ng'' : Quiver.Hom Y'' Z''\ni‚ÇÅ : Quiver.Hom X X'\nj‚ÇÅ : Quiver.Hom X' X''\ni‚ÇÇ : Quiver.Hom Y Y'\nj‚ÇÇ : Quiver.Hom Y' Y''\ni‚ÇÉ : Quiver.Hom Z Z'\nj‚ÇÉ : Quiver.Hom Z' Z''\ninst‚úù¬≤ : CategoryTheory.Limits.HasPullback f g\ninst‚úù¬π : CategoryTheory.Limits.HasPullback f' g'\ninst‚úù : CategoryTheory.Limits.HasPullback f'' g''\ne‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp f i‚ÇÉ) (CategoryTheory.CategoryStruct.comp i‚ÇÅ f')\ne‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp g i‚ÇÉ) (CategoryTheory.CategoryStruct.comp i‚ÇÇ g')\ne‚ÇÉ : Eq (CategoryTheory.CategoryStruct.comp f' j‚ÇÉ) (CategoryTheory.CategoryStruct.comp j‚ÇÅ f'')\ne‚ÇÑ : Eq (CategoryTheory.CategoryStruct.comp g' j‚ÇÉ) (CategoryTheory.CategoryStruct.comp j‚ÇÇ g'')\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.map f g f' g' i‚ÇÅ i‚ÇÇ i‚ÇÉ e‚ÇÅ e‚ÇÇ) (CategoryTheory.Limits.pullback.map f' g' f'' g'' j‚ÇÅ j‚ÇÇ j‚ÇÉ e‚ÇÉ e‚ÇÑ)) (CategoryTheory.Limits.pullback.map f g f'' g'' (CategoryTheory.CategoryStruct.comp i‚ÇÅ j‚ÇÅ) (CategoryTheory.CategoryStruct.comp i‚ÇÇ j‚ÇÇ) (CategoryTheory.CategoryStruct.comp i‚ÇÉ j‚ÇÉ) ‚ãØ ‚ãØ)","decl":"@[reassoc]\nlemma pullback.map_comp {X Y Z X' Y' Z' X'' Y'' Z'' : C}\n    {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} {f' : X' ‚ü∂ Z'} {g' : Y' ‚ü∂ Z'} {f'' : X'' ‚ü∂ Z''} {g'' : Y'' ‚ü∂ Z''}\n    (i‚ÇÅ : X ‚ü∂ X') (j‚ÇÅ : X' ‚ü∂ X'') (i‚ÇÇ : Y ‚ü∂ Y') (j‚ÇÇ : Y' ‚ü∂ Y'') (i‚ÇÉ : Z ‚ü∂ Z') (j‚ÇÉ : Z' ‚ü∂ Z'')\n    [HasPullback f g] [HasPullback f' g'] [HasPullback f'' g'']\n    (e‚ÇÅ e‚ÇÇ e‚ÇÉ e‚ÇÑ) :\n    pullback.map f g f' g' i‚ÇÅ i‚ÇÇ i‚ÇÉ e‚ÇÅ e‚ÇÇ ‚â´ pullback.map f' g' f'' g'' j‚ÇÅ j‚ÇÇ j‚ÇÉ e‚ÇÉ e‚ÇÑ =\n      pullback.map f g f'' g'' (i‚ÇÅ ‚â´ j‚ÇÅ) (i‚ÇÇ ‚â´ j‚ÇÇ) (i‚ÇÉ ‚â´ j‚ÇÉ)\n        (by rw [reassoc_of% e‚ÇÅ, e‚ÇÉ, Category.assoc])\n        (by rw [reassoc_of% e‚ÇÇ, e‚ÇÑ, Category.assoc]) := by ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.pullback.map_comp_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y Z‚úù X' Y' Z' X'' Y'' Z'' : C\nf : Quiver.Hom X Z‚úù\ng : Quiver.Hom Y Z‚úù\nf' : Quiver.Hom X' Z'\ng' : Quiver.Hom Y' Z'\nf'' : Quiver.Hom X'' Z''\ng'' : Quiver.Hom Y'' Z''\ni‚ÇÅ : Quiver.Hom X X'\nj‚ÇÅ : Quiver.Hom X' X''\ni‚ÇÇ : Quiver.Hom Y Y'\nj‚ÇÇ : Quiver.Hom Y' Y''\ni‚ÇÉ : Quiver.Hom Z‚úù Z'\nj‚ÇÉ : Quiver.Hom Z' Z''\ninst‚úù¬≤ : CategoryTheory.Limits.HasPullback f g\ninst‚úù¬π : CategoryTheory.Limits.HasPullback f' g'\ninst‚úù : CategoryTheory.Limits.HasPullback f'' g''\ne‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp f i‚ÇÉ) (CategoryTheory.CategoryStruct.comp i‚ÇÅ f')\ne‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp g i‚ÇÉ) (CategoryTheory.CategoryStruct.comp i‚ÇÇ g')\ne‚ÇÉ : Eq (CategoryTheory.CategoryStruct.comp f' j‚ÇÉ) (CategoryTheory.CategoryStruct.comp j‚ÇÅ f'')\ne‚ÇÑ : Eq (CategoryTheory.CategoryStruct.comp g' j‚ÇÉ) (CategoryTheory.CategoryStruct.comp j‚ÇÇ g'')\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pullback f'' g'') Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.map f g f' g' i‚ÇÅ i‚ÇÇ i‚ÇÉ e‚ÇÅ e‚ÇÇ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.map f' g' f'' g'' j‚ÇÅ j‚ÇÇ j‚ÇÉ e‚ÇÉ e‚ÇÑ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.map f g f'' g'' (CategoryTheory.CategoryStruct.comp i‚ÇÅ j‚ÇÅ) (CategoryTheory.CategoryStruct.comp i‚ÇÇ j‚ÇÇ) (CategoryTheory.CategoryStruct.comp i‚ÇÉ j‚ÇÉ) ‚ãØ ‚ãØ) h)","decl":"@[reassoc]\nlemma pullback.map_comp {X Y Z X' Y' Z' X'' Y'' Z'' : C}\n    {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} {f' : X' ‚ü∂ Z'} {g' : Y' ‚ü∂ Z'} {f'' : X'' ‚ü∂ Z''} {g'' : Y'' ‚ü∂ Z''}\n    (i‚ÇÅ : X ‚ü∂ X') (j‚ÇÅ : X' ‚ü∂ X'') (i‚ÇÇ : Y ‚ü∂ Y') (j‚ÇÇ : Y' ‚ü∂ Y'') (i‚ÇÉ : Z ‚ü∂ Z') (j‚ÇÉ : Z' ‚ü∂ Z'')\n    [HasPullback f g] [HasPullback f' g'] [HasPullback f'' g'']\n    (e‚ÇÅ e‚ÇÇ e‚ÇÉ e‚ÇÑ) :\n    pullback.map f g f' g' i‚ÇÅ i‚ÇÇ i‚ÇÉ e‚ÇÅ e‚ÇÇ ‚â´ pullback.map f' g' f'' g'' j‚ÇÅ j‚ÇÇ j‚ÇÉ e‚ÇÉ e‚ÇÑ =\n      pullback.map f g f'' g'' (i‚ÇÅ ‚â´ j‚ÇÅ) (i‚ÇÇ ‚â´ j‚ÇÇ) (i‚ÇÉ ‚â´ j‚ÇÉ)\n        (by rw [reassoc_of% e‚ÇÅ, e‚ÇÉ, Category.assoc])\n        (by rw [reassoc_of% e‚ÇÇ, e‚ÇÑ, Category.assoc]) := by ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.pullback.map_id","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Limits.HasPullback f g\n‚ä¢ Eq (CategoryTheory.Limits.pullback.map f g f g (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Z) ‚ãØ ‚ãØ) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback f g))","decl":"@[simp]\nlemma pullback.map_id {X Y Z : C}\n    {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [HasPullback f g] :\n    pullback.map f g f g (ùüô _) (ùüô _) (ùüô _) (by simp) (by simp) = ùüô _ := by ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.pushout.map_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y Z X' Y' Z' X'' Y'' Z'' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nf' : Quiver.Hom X' Y'\ng' : Quiver.Hom X' Z'\nf'' : Quiver.Hom X'' Y''\ng'' : Quiver.Hom X'' Z''\ni‚ÇÅ : Quiver.Hom X X'\nj‚ÇÅ : Quiver.Hom X' X''\ni‚ÇÇ : Quiver.Hom Y Y'\nj‚ÇÇ : Quiver.Hom Y' Y''\ni‚ÇÉ : Quiver.Hom Z Z'\nj‚ÇÉ : Quiver.Hom Z' Z''\ninst‚úù¬≤ : CategoryTheory.Limits.HasPushout f g\ninst‚úù¬π : CategoryTheory.Limits.HasPushout f' g'\ninst‚úù : CategoryTheory.Limits.HasPushout f'' g''\ne‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp f i‚ÇÇ) (CategoryTheory.CategoryStruct.comp i‚ÇÅ f')\ne‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp g i‚ÇÉ) (CategoryTheory.CategoryStruct.comp i‚ÇÅ g')\ne‚ÇÉ : Eq (CategoryTheory.CategoryStruct.comp f' j‚ÇÇ) (CategoryTheory.CategoryStruct.comp j‚ÇÅ f'')\ne‚ÇÑ : Eq (CategoryTheory.CategoryStruct.comp g' j‚ÇÉ) (CategoryTheory.CategoryStruct.comp j‚ÇÅ g'')\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.map f g f' g' i‚ÇÇ i‚ÇÉ i‚ÇÅ e‚ÇÅ e‚ÇÇ) (CategoryTheory.Limits.pushout.map f' g' f'' g'' j‚ÇÇ j‚ÇÉ j‚ÇÅ e‚ÇÉ e‚ÇÑ)) (CategoryTheory.Limits.pushout.map f g f'' g'' (CategoryTheory.CategoryStruct.comp i‚ÇÇ j‚ÇÇ) (CategoryTheory.CategoryStruct.comp i‚ÇÉ j‚ÇÉ) (CategoryTheory.CategoryStruct.comp i‚ÇÅ j‚ÇÅ) ‚ãØ ‚ãØ)","decl":"@[reassoc]\nlemma pushout.map_comp {X Y Z X' Y' Z' X'' Y'' Z'' : C}\n    {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} {f' : X' ‚ü∂ Y'} {g' : X' ‚ü∂ Z'} {f'' : X'' ‚ü∂ Y''} {g'' : X'' ‚ü∂ Z''}\n    (i‚ÇÅ : X ‚ü∂ X') (j‚ÇÅ : X' ‚ü∂ X'') (i‚ÇÇ : Y ‚ü∂ Y') (j‚ÇÇ : Y' ‚ü∂ Y'') (i‚ÇÉ : Z ‚ü∂ Z') (j‚ÇÉ : Z' ‚ü∂ Z'')\n    [HasPushout f g] [HasPushout f' g'] [HasPushout f'' g'']\n    (e‚ÇÅ e‚ÇÇ e‚ÇÉ e‚ÇÑ) :\n    pushout.map f g f' g' i‚ÇÇ i‚ÇÉ i‚ÇÅ e‚ÇÅ e‚ÇÇ ‚â´ pushout.map f' g' f'' g'' j‚ÇÇ j‚ÇÉ j‚ÇÅ e‚ÇÉ e‚ÇÑ =\n      pushout.map f g f'' g'' (i‚ÇÇ ‚â´ j‚ÇÇ) (i‚ÇÉ ‚â´ j‚ÇÉ) (i‚ÇÅ ‚â´ j‚ÇÅ)\n        (by rw [reassoc_of% e‚ÇÅ, e‚ÇÉ, Category.assoc])\n        (by rw [reassoc_of% e‚ÇÇ, e‚ÇÑ, Category.assoc]) := by ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.pushout.map_comp_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y Z‚úù X' Y' Z' X'' Y'' Z'' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z‚úù\nf' : Quiver.Hom X' Y'\ng' : Quiver.Hom X' Z'\nf'' : Quiver.Hom X'' Y''\ng'' : Quiver.Hom X'' Z''\ni‚ÇÅ : Quiver.Hom X X'\nj‚ÇÅ : Quiver.Hom X' X''\ni‚ÇÇ : Quiver.Hom Y Y'\nj‚ÇÇ : Quiver.Hom Y' Y''\ni‚ÇÉ : Quiver.Hom Z‚úù Z'\nj‚ÇÉ : Quiver.Hom Z' Z''\ninst‚úù¬≤ : CategoryTheory.Limits.HasPushout f g\ninst‚úù¬π : CategoryTheory.Limits.HasPushout f' g'\ninst‚úù : CategoryTheory.Limits.HasPushout f'' g''\ne‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp f i‚ÇÇ) (CategoryTheory.CategoryStruct.comp i‚ÇÅ f')\ne‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp g i‚ÇÉ) (CategoryTheory.CategoryStruct.comp i‚ÇÅ g')\ne‚ÇÉ : Eq (CategoryTheory.CategoryStruct.comp f' j‚ÇÇ) (CategoryTheory.CategoryStruct.comp j‚ÇÅ f'')\ne‚ÇÑ : Eq (CategoryTheory.CategoryStruct.comp g' j‚ÇÉ) (CategoryTheory.CategoryStruct.comp j‚ÇÅ g'')\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout f'' g'') Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.map f g f' g' i‚ÇÇ i‚ÇÉ i‚ÇÅ e‚ÇÅ e‚ÇÇ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.map f' g' f'' g'' j‚ÇÇ j‚ÇÉ j‚ÇÅ e‚ÇÉ e‚ÇÑ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.map f g f'' g'' (CategoryTheory.CategoryStruct.comp i‚ÇÇ j‚ÇÇ) (CategoryTheory.CategoryStruct.comp i‚ÇÉ j‚ÇÉ) (CategoryTheory.CategoryStruct.comp i‚ÇÅ j‚ÇÅ) ‚ãØ ‚ãØ) h)","decl":"@[reassoc]\nlemma pushout.map_comp {X Y Z X' Y' Z' X'' Y'' Z'' : C}\n    {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} {f' : X' ‚ü∂ Y'} {g' : X' ‚ü∂ Z'} {f'' : X'' ‚ü∂ Y''} {g'' : X'' ‚ü∂ Z''}\n    (i‚ÇÅ : X ‚ü∂ X') (j‚ÇÅ : X' ‚ü∂ X'') (i‚ÇÇ : Y ‚ü∂ Y') (j‚ÇÇ : Y' ‚ü∂ Y'') (i‚ÇÉ : Z ‚ü∂ Z') (j‚ÇÉ : Z' ‚ü∂ Z'')\n    [HasPushout f g] [HasPushout f' g'] [HasPushout f'' g'']\n    (e‚ÇÅ e‚ÇÇ e‚ÇÉ e‚ÇÑ) :\n    pushout.map f g f' g' i‚ÇÇ i‚ÇÉ i‚ÇÅ e‚ÇÅ e‚ÇÇ ‚â´ pushout.map f' g' f'' g'' j‚ÇÇ j‚ÇÉ j‚ÇÅ e‚ÇÉ e‚ÇÑ =\n      pushout.map f g f'' g'' (i‚ÇÇ ‚â´ j‚ÇÇ) (i‚ÇÉ ‚â´ j‚ÇÉ) (i‚ÇÅ ‚â´ j‚ÇÅ)\n        (by rw [reassoc_of% e‚ÇÅ, e‚ÇÉ, Category.assoc])\n        (by rw [reassoc_of% e‚ÇÇ, e‚ÇÑ, Category.assoc]) := by ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.pushout.map_id","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst‚úù : CategoryTheory.Limits.HasPushout f g\n‚ä¢ Eq (CategoryTheory.Limits.pushout.map f g f g (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Z) (CategoryTheory.CategoryStruct.id X) ‚ãØ ‚ãØ) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pushout f g))","decl":"@[simp]\nlemma pushout.map_id {X Y Z : C}\n    {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [HasPushout f g] :\n    pushout.map f g f g (ùüô _) (ùüô _) (ùüô _) (by simp) (by simp) = ùüô _ := by ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.pullback.map_isIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nW X Y Z S T : C\nf‚ÇÅ : Quiver.Hom W S\nf‚ÇÇ : Quiver.Hom X S\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasPullback f‚ÇÅ f‚ÇÇ\ng‚ÇÅ : Quiver.Hom Y T\ng‚ÇÇ : Quiver.Hom Z T\ninst‚úù¬≥ : CategoryTheory.Limits.HasPullback g‚ÇÅ g‚ÇÇ\ni‚ÇÅ : Quiver.Hom W Y\ni‚ÇÇ : Quiver.Hom X Z\ni‚ÇÉ : Quiver.Hom S T\neq‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp f‚ÇÅ i‚ÇÉ) (CategoryTheory.CategoryStruct.comp i‚ÇÅ g‚ÇÅ)\neq‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp f‚ÇÇ i‚ÇÉ) (CategoryTheory.CategoryStruct.comp i‚ÇÇ g‚ÇÇ)\ninst‚úù¬≤ : CategoryTheory.IsIso i‚ÇÅ\ninst‚úù¬π : CategoryTheory.IsIso i‚ÇÇ\ninst‚úù : CategoryTheory.IsIso i‚ÇÉ\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ)","decl":"instance pullback.map_isIso {W X Y Z S T : C} (f‚ÇÅ : W ‚ü∂ S) (f‚ÇÇ : X ‚ü∂ S) [HasPullback f‚ÇÅ f‚ÇÇ]\n    (g‚ÇÅ : Y ‚ü∂ T) (g‚ÇÇ : Z ‚ü∂ T) [HasPullback g‚ÇÅ g‚ÇÇ] (i‚ÇÅ : W ‚ü∂ Y) (i‚ÇÇ : X ‚ü∂ Z) (i‚ÇÉ : S ‚ü∂ T)\n    (eq‚ÇÅ : f‚ÇÅ ‚â´ i‚ÇÉ = i‚ÇÅ ‚â´ g‚ÇÅ) (eq‚ÇÇ : f‚ÇÇ ‚â´ i‚ÇÉ = i‚ÇÇ ‚â´ g‚ÇÇ) [IsIso i‚ÇÅ] [IsIso i‚ÇÇ] [IsIso i‚ÇÉ] :\n    IsIso (pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ) := by\n  refine ‚ü®‚ü®pullback.map _ _ _ _ (inv i‚ÇÅ) (inv i‚ÇÇ) (inv i‚ÇÉ) ?_ ?_, ?_, ?_‚ü©‚ü©\n  ¬∑ rw [IsIso.comp_inv_eq, Category.assoc, eq‚ÇÅ, IsIso.inv_hom_id_assoc]\n  ¬∑ rw [IsIso.comp_inv_eq, Category.assoc, eq‚ÇÇ, IsIso.inv_hom_id_assoc]\n  ¬∑ aesop_cat\n  ¬∑ aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.pullback.congrHom_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf‚ÇÅ f‚ÇÇ : Quiver.Hom X Z\ng‚ÇÅ g‚ÇÇ : Quiver.Hom Y Z\nh‚ÇÅ : Eq f‚ÇÅ f‚ÇÇ\nh‚ÇÇ : Eq g‚ÇÅ g‚ÇÇ\ninst‚úù¬π : CategoryTheory.Limits.HasPullback f‚ÇÅ g‚ÇÅ\ninst‚úù : CategoryTheory.Limits.HasPullback f‚ÇÇ g‚ÇÇ\n‚ä¢ Eq (CategoryTheory.Limits.pullback.congrHom h‚ÇÅ h‚ÇÇ).hom (CategoryTheory.Limits.pullback.map f‚ÇÅ g‚ÇÅ f‚ÇÇ g‚ÇÇ (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Z) ‚ãØ ‚ãØ)","decl":"/-- If `f‚ÇÅ = f‚ÇÇ` and `g‚ÇÅ = g‚ÇÇ`, we may construct a canonical\nisomorphism `pullback f‚ÇÅ g‚ÇÅ ‚âÖ pullback f‚ÇÇ g‚ÇÇ` -/\n@[simps! hom]\ndef pullback.congrHom {X Y Z : C} {f‚ÇÅ f‚ÇÇ : X ‚ü∂ Z} {g‚ÇÅ g‚ÇÇ : Y ‚ü∂ Z} (h‚ÇÅ : f‚ÇÅ = f‚ÇÇ) (h‚ÇÇ : g‚ÇÅ = g‚ÇÇ)\n    [HasPullback f‚ÇÅ g‚ÇÅ] [HasPullback f‚ÇÇ g‚ÇÇ] : pullback f‚ÇÅ g‚ÇÅ ‚âÖ pullback f‚ÇÇ g‚ÇÇ :=\n  asIso <| pullback.map _ _ _ _ (ùüô _) (ùüô _) (ùüô _) (by simp [h‚ÇÅ]) (by simp [h‚ÇÇ])\n\n"}
{"name":"CategoryTheory.Limits.pullback.congrHom_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf‚ÇÅ f‚ÇÇ : Quiver.Hom X Z\ng‚ÇÅ g‚ÇÇ : Quiver.Hom Y Z\nh‚ÇÅ : Eq f‚ÇÅ f‚ÇÇ\nh‚ÇÇ : Eq g‚ÇÅ g‚ÇÇ\ninst‚úù¬π : CategoryTheory.Limits.HasPullback f‚ÇÅ g‚ÇÅ\ninst‚úù : CategoryTheory.Limits.HasPullback f‚ÇÇ g‚ÇÇ\n‚ä¢ Eq (CategoryTheory.Limits.pullback.congrHom h‚ÇÅ h‚ÇÇ).inv (CategoryTheory.Limits.pullback.map f‚ÇÇ g‚ÇÇ f‚ÇÅ g‚ÇÅ (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Z) ‚ãØ ‚ãØ)","decl":"@[simp]\ntheorem pullback.congrHom_inv {X Y Z : C} {f‚ÇÅ f‚ÇÇ : X ‚ü∂ Z} {g‚ÇÅ g‚ÇÇ : Y ‚ü∂ Z} (h‚ÇÅ : f‚ÇÅ = f‚ÇÇ)\n    (h‚ÇÇ : g‚ÇÅ = g‚ÇÇ) [HasPullback f‚ÇÅ g‚ÇÅ] [HasPullback f‚ÇÇ g‚ÇÇ] :\n    (pullback.congrHom h‚ÇÅ h‚ÇÇ).inv =\n      pullback.map _ _ _ _ (ùüô _) (ùüô _) (ùüô _) (by simp [h‚ÇÅ]) (by simp [h‚ÇÇ]) := by\n  ext <;> simp [Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.pushout.map_isIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nW X Y Z S T : C\nf‚ÇÅ : Quiver.Hom S W\nf‚ÇÇ : Quiver.Hom S X\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasPushout f‚ÇÅ f‚ÇÇ\ng‚ÇÅ : Quiver.Hom T Y\ng‚ÇÇ : Quiver.Hom T Z\ninst‚úù¬≥ : CategoryTheory.Limits.HasPushout g‚ÇÅ g‚ÇÇ\ni‚ÇÅ : Quiver.Hom W Y\ni‚ÇÇ : Quiver.Hom X Z\ni‚ÇÉ : Quiver.Hom S T\neq‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp f‚ÇÅ i‚ÇÅ) (CategoryTheory.CategoryStruct.comp i‚ÇÉ g‚ÇÅ)\neq‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp f‚ÇÇ i‚ÇÇ) (CategoryTheory.CategoryStruct.comp i‚ÇÉ g‚ÇÇ)\ninst‚úù¬≤ : CategoryTheory.IsIso i‚ÇÅ\ninst‚úù¬π : CategoryTheory.IsIso i‚ÇÇ\ninst‚úù : CategoryTheory.IsIso i‚ÇÉ\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.pushout.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ)","decl":"instance pushout.map_isIso {W X Y Z S T : C} (f‚ÇÅ : S ‚ü∂ W) (f‚ÇÇ : S ‚ü∂ X) [HasPushout f‚ÇÅ f‚ÇÇ]\n    (g‚ÇÅ : T ‚ü∂ Y) (g‚ÇÇ : T ‚ü∂ Z) [HasPushout g‚ÇÅ g‚ÇÇ] (i‚ÇÅ : W ‚ü∂ Y) (i‚ÇÇ : X ‚ü∂ Z) (i‚ÇÉ : S ‚ü∂ T)\n    (eq‚ÇÅ : f‚ÇÅ ‚â´ i‚ÇÅ = i‚ÇÉ ‚â´ g‚ÇÅ) (eq‚ÇÇ : f‚ÇÇ ‚â´ i‚ÇÇ = i‚ÇÉ ‚â´ g‚ÇÇ) [IsIso i‚ÇÅ] [IsIso i‚ÇÇ] [IsIso i‚ÇÉ] :\n    IsIso (pushout.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ) := by\n  refine ‚ü®‚ü®pushout.map _ _ _ _ (inv i‚ÇÅ) (inv i‚ÇÇ) (inv i‚ÇÉ) ?_ ?_, ?_, ?_‚ü©‚ü©\n  ¬∑ rw [IsIso.comp_inv_eq, Category.assoc, eq‚ÇÅ, IsIso.inv_hom_id_assoc]\n  ¬∑ rw [IsIso.comp_inv_eq, Category.assoc, eq‚ÇÇ, IsIso.inv_hom_id_assoc]\n  ¬∑ aesop_cat\n  ¬∑ aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.pullback.mapDesc_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nX Y S T S' : C\nf : Quiver.Hom X T\ng : Quiver.Hom Y T\ni : Quiver.Hom T S\ni' : Quiver.Hom S S'\ninst‚úù¬≥ : CategoryTheory.Limits.HasPullback f g\ninst‚úù¬≤ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i)\ninst‚úù¬π : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp i i')) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.comp i i'))\ninst‚úù : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f i) i') (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp g i) i')\n‚ä¢ Eq (CategoryTheory.Limits.pullback.mapDesc f g (CategoryTheory.CategoryStruct.comp i i')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.mapDesc f g i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.mapDesc (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) i') (CategoryTheory.Limits.pullback.congrHom ‚ãØ ‚ãØ).hom))","decl":"theorem pullback.mapDesc_comp {X Y S T S' : C} (f : X ‚ü∂ T) (g : Y ‚ü∂ T) (i : T ‚ü∂ S) (i' : S ‚ü∂ S')\n    [HasPullback f g] [HasPullback (f ‚â´ i) (g ‚â´ i)] [HasPullback (f ‚â´ i ‚â´ i') (g ‚â´ i ‚â´ i')]\n    [HasPullback ((f ‚â´ i) ‚â´ i') ((g ‚â´ i) ‚â´ i')] :\n    pullback.mapDesc f g (i ‚â´ i') = pullback.mapDesc f g i ‚â´ pullback.mapDesc _ _ i' ‚â´\n    (pullback.congrHom (Category.assoc _ _ _) (Category.assoc _ _ _)).hom := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.pushout.congrHom_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf‚ÇÅ f‚ÇÇ : Quiver.Hom X Y\ng‚ÇÅ g‚ÇÇ : Quiver.Hom X Z\nh‚ÇÅ : Eq f‚ÇÅ f‚ÇÇ\nh‚ÇÇ : Eq g‚ÇÅ g‚ÇÇ\ninst‚úù¬π : CategoryTheory.Limits.HasPushout f‚ÇÅ g‚ÇÅ\ninst‚úù : CategoryTheory.Limits.HasPushout f‚ÇÇ g‚ÇÇ\n‚ä¢ Eq (CategoryTheory.Limits.pushout.congrHom h‚ÇÅ h‚ÇÇ).hom (CategoryTheory.Limits.pushout.map f‚ÇÅ g‚ÇÅ f‚ÇÇ g‚ÇÇ (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Z) (CategoryTheory.CategoryStruct.id X) ‚ãØ ‚ãØ)","decl":"/-- If `f‚ÇÅ = f‚ÇÇ` and `g‚ÇÅ = g‚ÇÇ`, we may construct a canonical\nisomorphism `pushout f‚ÇÅ g‚ÇÅ ‚âÖ pullback f‚ÇÇ g‚ÇÇ` -/\n@[simps! hom]\ndef pushout.congrHom {X Y Z : C} {f‚ÇÅ f‚ÇÇ : X ‚ü∂ Y} {g‚ÇÅ g‚ÇÇ : X ‚ü∂ Z} (h‚ÇÅ : f‚ÇÅ = f‚ÇÇ) (h‚ÇÇ : g‚ÇÅ = g‚ÇÇ)\n    [HasPushout f‚ÇÅ g‚ÇÅ] [HasPushout f‚ÇÇ g‚ÇÇ] : pushout f‚ÇÅ g‚ÇÅ ‚âÖ pushout f‚ÇÇ g‚ÇÇ :=\n  asIso <| pushout.map _ _ _ _ (ùüô _) (ùüô _) (ùüô _) (by simp [h‚ÇÅ]) (by simp [h‚ÇÇ])\n\n"}
{"name":"CategoryTheory.Limits.pushout.congrHom_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf‚ÇÅ f‚ÇÇ : Quiver.Hom X Y\ng‚ÇÅ g‚ÇÇ : Quiver.Hom X Z\nh‚ÇÅ : Eq f‚ÇÅ f‚ÇÇ\nh‚ÇÇ : Eq g‚ÇÅ g‚ÇÇ\ninst‚úù¬π : CategoryTheory.Limits.HasPushout f‚ÇÅ g‚ÇÅ\ninst‚úù : CategoryTheory.Limits.HasPushout f‚ÇÇ g‚ÇÇ\n‚ä¢ Eq (CategoryTheory.Limits.pushout.congrHom h‚ÇÅ h‚ÇÇ).inv (CategoryTheory.Limits.pushout.map f‚ÇÇ g‚ÇÇ f‚ÇÅ g‚ÇÅ (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Z) (CategoryTheory.CategoryStruct.id X) ‚ãØ ‚ãØ)","decl":"@[simp]\ntheorem pushout.congrHom_inv {X Y Z : C} {f‚ÇÅ f‚ÇÇ : X ‚ü∂ Y} {g‚ÇÅ g‚ÇÇ : X ‚ü∂ Z} (h‚ÇÅ : f‚ÇÅ = f‚ÇÇ)\n    (h‚ÇÇ : g‚ÇÅ = g‚ÇÇ) [HasPushout f‚ÇÅ g‚ÇÅ] [HasPushout f‚ÇÇ g‚ÇÇ] :\n    (pushout.congrHom h‚ÇÅ h‚ÇÇ).inv =\n      pushout.map _ _ _ _ (ùüô _) (ùüô _) (ùüô _) (by simp [h‚ÇÅ]) (by simp [h‚ÇÇ]) := by\n  ext <;> simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.pushout.mapLift_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nX Y S T S' : C\nf : Quiver.Hom T X\ng : Quiver.Hom T Y\ni : Quiver.Hom S T\ni' : Quiver.Hom S' S\ninst‚úù¬≥ : CategoryTheory.Limits.HasPushout f g\ninst‚úù¬≤ : CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp i f) (CategoryTheory.CategoryStruct.comp i g)\ninst‚úù¬π : CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp i' (CategoryTheory.CategoryStruct.comp i f)) (CategoryTheory.CategoryStruct.comp i' (CategoryTheory.CategoryStruct.comp i g))\ninst‚úù : CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp i' i) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp i' i) g)\n‚ä¢ Eq (CategoryTheory.Limits.pushout.mapLift f g (CategoryTheory.CategoryStruct.comp i' i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.congrHom ‚ãØ ‚ãØ).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.mapLift (CategoryTheory.CategoryStruct.comp i f) (CategoryTheory.CategoryStruct.comp i g) i') (CategoryTheory.Limits.pushout.mapLift f g i)))","decl":"theorem pushout.mapLift_comp {X Y S T S' : C} (f : T ‚ü∂ X) (g : T ‚ü∂ Y) (i : S ‚ü∂ T) (i' : S' ‚ü∂ S)\n    [HasPushout f g] [HasPushout (i ‚â´ f) (i ‚â´ g)] [HasPushout (i' ‚â´ i ‚â´ f) (i' ‚â´ i ‚â´ g)]\n    [HasPushout ((i' ‚â´ i) ‚â´ f) ((i' ‚â´ i) ‚â´ g)] :\n    pushout.mapLift f g (i' ‚â´ i) =\n      (pushout.congrHom (Category.assoc _ _ _) (Category.assoc _ _ _)).hom ‚â´\n        pushout.mapLift _ _ i' ‚â´ pushout.mapLift f g i := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.pullbackComparison_comp_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Limits.HasPullback f g\ninst‚úù : CategoryTheory.Limits.HasPullback (G.map f) (G.map g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackComparison G f g) (CategoryTheory.Limits.pullback.fst (G.map f) (G.map g))) (G.map (CategoryTheory.Limits.pullback.fst f g))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackComparison_comp_fst (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [HasPullback f g]\n    [HasPullback (G.map f) (G.map g)] :\n    pullbackComparison G f g ‚â´ pullback.fst _ _ = G.map (pullback.fst f g) :=\n  pullback.lift_fst _ _ _\n\n"}
{"name":"CategoryTheory.Limits.pullbackComparison_comp_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y Z‚úù : C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\nf : Quiver.Hom X Z‚úù\ng : Quiver.Hom Y Z‚úù\ninst‚úù¬π : CategoryTheory.Limits.HasPullback f g\ninst‚úù : CategoryTheory.Limits.HasPullback (G.map f) (G.map g)\nZ : D\nh : Quiver.Hom (G.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackComparison G f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (G.map f) (G.map g)) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.pullback.fst f g)) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackComparison_comp_fst (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [HasPullback f g]\n    [HasPullback (G.map f) (G.map g)] :\n    pullbackComparison G f g ‚â´ pullback.fst _ _ = G.map (pullback.fst f g) :=\n  pullback.lift_fst _ _ _\n\n"}
{"name":"CategoryTheory.Limits.pullbackComparison_comp_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y Z‚úù : C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\nf : Quiver.Hom X Z‚úù\ng : Quiver.Hom Y Z‚úù\ninst‚úù¬π : CategoryTheory.Limits.HasPullback f g\ninst‚úù : CategoryTheory.Limits.HasPullback (G.map f) (G.map g)\nZ : D\nh : Quiver.Hom (G.obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackComparison G f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (G.map f) (G.map g)) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.pullback.snd f g)) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackComparison_comp_snd (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [HasPullback f g]\n    [HasPullback (G.map f) (G.map g)] :\n    pullbackComparison G f g ‚â´ pullback.snd _ _ = G.map (pullback.snd f g):=\n  pullback.lift_snd _ _ _\n\n"}
{"name":"CategoryTheory.Limits.pullbackComparison_comp_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Limits.HasPullback f g\ninst‚úù : CategoryTheory.Limits.HasPullback (G.map f) (G.map g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackComparison G f g) (CategoryTheory.Limits.pullback.snd (G.map f) (G.map g))) (G.map (CategoryTheory.Limits.pullback.snd f g))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackComparison_comp_snd (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [HasPullback f g]\n    [HasPullback (G.map f) (G.map g)] :\n    pullbackComparison G f g ‚â´ pullback.snd _ _ = G.map (pullback.snd f g):=\n  pullback.lift_snd _ _ _\n\n"}
{"name":"CategoryTheory.Limits.map_lift_pullbackComparison","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Limits.HasPullback f g\ninst‚úù : CategoryTheory.Limits.HasPullback (G.map f) (G.map g)\nW : C\nh : Quiver.Hom W X\nk : Quiver.Hom W Y\nw : Eq (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp k g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.pullback.lift h k w)) (CategoryTheory.Limits.pullbackComparison G f g)) (CategoryTheory.Limits.pullback.lift (G.map h) (G.map k) ‚ãØ)","decl":"@[reassoc (attr := simp)]\ntheorem map_lift_pullbackComparison (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [HasPullback f g]\n    [HasPullback (G.map f) (G.map g)] {W : C} {h : W ‚ü∂ X} {k : W ‚ü∂ Y} (w : h ‚â´ f = k ‚â´ g) :\n    G.map (pullback.lift _ _ w) ‚â´ pullbackComparison G f g =\n      pullback.lift (G.map h) (G.map k) (by simp only [‚Üê G.map_comp, w]) := by\n  ext <;> simp [‚Üê G.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.map_lift_pullbackComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y Z‚úù : C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\nf : Quiver.Hom X Z‚úù\ng : Quiver.Hom Y Z‚úù\ninst‚úù¬π : CategoryTheory.Limits.HasPullback f g\ninst‚úù : CategoryTheory.Limits.HasPullback (G.map f) (G.map g)\nW : C\nh‚úù : Quiver.Hom W X\nk : Quiver.Hom W Y\nw : Eq (CategoryTheory.CategoryStruct.comp h‚úù f) (CategoryTheory.CategoryStruct.comp k g)\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.pullback (G.map f) (G.map g)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.pullback.lift h‚úù k w)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackComparison G f g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.lift (G.map h‚úù) (G.map k) ‚ãØ) h)","decl":"@[reassoc (attr := simp)]\ntheorem map_lift_pullbackComparison (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [HasPullback f g]\n    [HasPullback (G.map f) (G.map g)] {W : C} {h : W ‚ü∂ X} {k : W ‚ü∂ Y} (w : h ‚â´ f = k ‚â´ g) :\n    G.map (pullback.lift _ _ w) ‚â´ pullbackComparison G f g =\n      pullback.lift (G.map h) (G.map k) (by simp only [‚Üê G.map_comp, w]) := by\n  ext <;> simp [‚Üê G.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.inl_comp_pushoutComparison","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst‚úù¬π : CategoryTheory.Limits.HasPushout f g\ninst‚úù : CategoryTheory.Limits.HasPushout (G.map f) (G.map g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (G.map f) (G.map g)) (CategoryTheory.Limits.pushoutComparison G f g)) (G.map (CategoryTheory.Limits.pushout.inl f g))","decl":"@[reassoc (attr := simp)]\ntheorem inl_comp_pushoutComparison (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [HasPushout f g]\n    [HasPushout (G.map f) (G.map g)] : pushout.inl _ _ ‚â´ pushoutComparison G f g =\n      G.map (pushout.inl _ _) :=\n  pushout.inl_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.inl_comp_pushoutComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y Z‚úù : C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z‚úù\ninst‚úù¬π : CategoryTheory.Limits.HasPushout f g\ninst‚úù : CategoryTheory.Limits.HasPushout (G.map f) (G.map g)\nZ : D\nh : Quiver.Hom (G.obj (CategoryTheory.Limits.pushout f g)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (G.map f) (G.map g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutComparison G f g) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.pushout.inl f g)) h)","decl":"@[reassoc (attr := simp)]\ntheorem inl_comp_pushoutComparison (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [HasPushout f g]\n    [HasPushout (G.map f) (G.map g)] : pushout.inl _ _ ‚â´ pushoutComparison G f g =\n      G.map (pushout.inl _ _) :=\n  pushout.inl_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.inr_comp_pushoutComparison","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst‚úù¬π : CategoryTheory.Limits.HasPushout f g\ninst‚úù : CategoryTheory.Limits.HasPushout (G.map f) (G.map g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr (G.map f) (G.map g)) (CategoryTheory.Limits.pushoutComparison G f g)) (G.map (CategoryTheory.Limits.pushout.inr f g))","decl":"@[reassoc (attr := simp)]\ntheorem inr_comp_pushoutComparison (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [HasPushout f g]\n    [HasPushout (G.map f) (G.map g)] : pushout.inr _ _ ‚â´ pushoutComparison G f g =\n      G.map (pushout.inr _ _) :=\n  pushout.inr_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.inr_comp_pushoutComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y Z‚úù : C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z‚úù\ninst‚úù¬π : CategoryTheory.Limits.HasPushout f g\ninst‚úù : CategoryTheory.Limits.HasPushout (G.map f) (G.map g)\nZ : D\nh : Quiver.Hom (G.obj (CategoryTheory.Limits.pushout f g)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr (G.map f) (G.map g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutComparison G f g) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.pushout.inr f g)) h)","decl":"@[reassoc (attr := simp)]\ntheorem inr_comp_pushoutComparison (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [HasPushout f g]\n    [HasPushout (G.map f) (G.map g)] : pushout.inr _ _ ‚â´ pushoutComparison G f g =\n      G.map (pushout.inr _ _) :=\n  pushout.inr_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.pushoutComparison_map_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y Z‚úù : C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z‚úù\ninst‚úù¬π : CategoryTheory.Limits.HasPushout f g\ninst‚úù : CategoryTheory.Limits.HasPushout (G.map f) (G.map g)\nW : C\nh‚úù : Quiver.Hom Y W\nk : Quiver.Hom Z‚úù W\nw : Eq (CategoryTheory.CategoryStruct.comp f h‚úù) (CategoryTheory.CategoryStruct.comp g k)\nZ : D\nh : Quiver.Hom (G.obj W) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutComparison G f g) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.pushout.desc h‚úù k w)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.desc (G.map h‚úù) (G.map k) ‚ãØ) h)","decl":"@[reassoc (attr := simp)]\ntheorem pushoutComparison_map_desc (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [HasPushout f g]\n    [HasPushout (G.map f) (G.map g)] {W : C} {h : Y ‚ü∂ W} {k : Z ‚ü∂ W} (w : f ‚â´ h = g ‚â´ k) :\n    pushoutComparison G f g ‚â´ G.map (pushout.desc _ _ w) =\n      pushout.desc (G.map h) (G.map k) (by simp only [‚Üê G.map_comp, w]) := by\n  ext <;> simp [‚Üê G.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.pushoutComparison_map_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst‚úù¬π : CategoryTheory.Limits.HasPushout f g\ninst‚úù : CategoryTheory.Limits.HasPushout (G.map f) (G.map g)\nW : C\nh : Quiver.Hom Y W\nk : Quiver.Hom Z W\nw : Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g k)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutComparison G f g) (G.map (CategoryTheory.Limits.pushout.desc h k w))) (CategoryTheory.Limits.pushout.desc (G.map h) (G.map k) ‚ãØ)","decl":"@[reassoc (attr := simp)]\ntheorem pushoutComparison_map_desc (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [HasPushout f g]\n    [HasPushout (G.map f) (G.map g)] {W : C} {h : Y ‚ü∂ W} {k : Z ‚ü∂ W} (w : f ‚â´ h = g ‚â´ k) :\n    pushoutComparison G f g ‚â´ G.map (pushout.desc _ _ w) =\n      pushout.desc (G.map h) (G.map k) (by simp only [‚Üê G.map_comp, w]) := by\n  ext <;> simp [‚Üê G.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.hasPullback_symmetry","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Limits.HasPullback f g\n‚ä¢ CategoryTheory.Limits.HasPullback g f","decl":"/-- Making this a global instance would make the typeclass search go in an infinite loop. -/\ntheorem hasPullback_symmetry [HasPullback f g] : HasPullback g f :=\n  ‚ü®‚ü®‚ü®_, PullbackCone.flipIsLimit (pullbackIsPullback f g)‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.pullbackSymmetry_hom_comp_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Limits.HasPullback f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry f g).hom (CategoryTheory.Limits.pullback.fst g f)) (CategoryTheory.Limits.pullback.snd f g)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackSymmetry_hom_comp_fst [HasPullback f g] :\n    (pullbackSymmetry f g).hom ‚â´ pullback.fst g f = pullback.snd f g := by simp [pullbackSymmetry]\n\n"}
{"name":"CategoryTheory.Limits.pullbackSymmetry_hom_comp_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z‚úù : C\nf : Quiver.Hom X Z‚úù\ng : Quiver.Hom Y Z‚úù\ninst‚úù : CategoryTheory.Limits.HasPullback f g\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry f g).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst g f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackSymmetry_hom_comp_fst [HasPullback f g] :\n    (pullbackSymmetry f g).hom ‚â´ pullback.fst g f = pullback.snd f g := by simp [pullbackSymmetry]\n\n"}
{"name":"CategoryTheory.Limits.pullbackSymmetry_hom_comp_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z‚úù : C\nf : Quiver.Hom X Z‚úù\ng : Quiver.Hom Y Z‚úù\ninst‚úù : CategoryTheory.Limits.HasPullback f g\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry f g).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd g f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackSymmetry_hom_comp_snd [HasPullback f g] :\n    (pullbackSymmetry f g).hom ‚â´ pullback.snd g f = pullback.fst f g := by simp [pullbackSymmetry]\n\n"}
{"name":"CategoryTheory.Limits.pullbackSymmetry_hom_comp_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Limits.HasPullback f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry f g).hom (CategoryTheory.Limits.pullback.snd g f)) (CategoryTheory.Limits.pullback.fst f g)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackSymmetry_hom_comp_snd [HasPullback f g] :\n    (pullbackSymmetry f g).hom ‚â´ pullback.snd g f = pullback.fst f g := by simp [pullbackSymmetry]\n\n"}
{"name":"CategoryTheory.Limits.pullbackSymmetry_inv_comp_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z‚úù : C\nf : Quiver.Hom X Z‚úù\ng : Quiver.Hom Y Z‚úù\ninst‚úù : CategoryTheory.Limits.HasPullback f g\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd g f) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackSymmetry_inv_comp_fst [HasPullback f g] :\n    (pullbackSymmetry f g).inv ‚â´ pullback.fst f g = pullback.snd g f := by simp [Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.pullbackSymmetry_inv_comp_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Limits.HasPullback f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry f g).inv (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.Limits.pullback.snd g f)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackSymmetry_inv_comp_fst [HasPullback f g] :\n    (pullbackSymmetry f g).inv ‚â´ pullback.fst f g = pullback.snd g f := by simp [Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.pullbackSymmetry_inv_comp_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Limits.HasPullback f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry f g).inv (CategoryTheory.Limits.pullback.snd f g)) (CategoryTheory.Limits.pullback.fst g f)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackSymmetry_inv_comp_snd [HasPullback f g] :\n    (pullbackSymmetry f g).inv ‚â´ pullback.snd f g = pullback.fst g f := by simp [Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.pullbackSymmetry_inv_comp_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z‚úù : C\nf : Quiver.Hom X Z‚úù\ng : Quiver.Hom Y Z‚úù\ninst‚úù : CategoryTheory.Limits.HasPullback f g\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst g f) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackSymmetry_inv_comp_snd [HasPullback f g] :\n    (pullbackSymmetry f g).inv ‚â´ pullback.snd f g = pullback.fst g f := by simp [Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.hasPushout_symmetry","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst‚úù : CategoryTheory.Limits.HasPushout f g\n‚ä¢ CategoryTheory.Limits.HasPushout g f","decl":"/-- Making this a global instance would make the typeclass search go in an infinite loop. -/\ntheorem hasPushout_symmetry [HasPushout f g] : HasPushout g f :=\n  ‚ü®‚ü®‚ü®_, PushoutCocone.flipIsColimit (pushoutIsPushout f g)‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.inl_comp_pushoutSymmetry_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z‚úù : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z‚úù\ninst‚úù : CategoryTheory.Limits.HasPushout f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout g f) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutSymmetry f g).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr g f) h)","decl":"@[reassoc (attr := simp)]\ntheorem inl_comp_pushoutSymmetry_hom [HasPushout f g] :\n    pushout.inl _ _ ‚â´ (pushoutSymmetry f g).hom = pushout.inr _ _ :=\n  (colimit.isColimit (span f g)).comp_coconePointUniqueUpToIso_hom\n    (PushoutCocone.flipIsColimit (pushoutIsPushout g f)) _\n\n"}
{"name":"CategoryTheory.Limits.inl_comp_pushoutSymmetry_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst‚úù : CategoryTheory.Limits.HasPushout f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) (CategoryTheory.Limits.pushoutSymmetry f g).hom) (CategoryTheory.Limits.pushout.inr g f)","decl":"@[reassoc (attr := simp)]\ntheorem inl_comp_pushoutSymmetry_hom [HasPushout f g] :\n    pushout.inl _ _ ‚â´ (pushoutSymmetry f g).hom = pushout.inr _ _ :=\n  (colimit.isColimit (span f g)).comp_coconePointUniqueUpToIso_hom\n    (PushoutCocone.flipIsColimit (pushoutIsPushout g f)) _\n\n"}
{"name":"CategoryTheory.Limits.inr_comp_pushoutSymmetry_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst‚úù : CategoryTheory.Limits.HasPushout f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) (CategoryTheory.Limits.pushoutSymmetry f g).hom) (CategoryTheory.Limits.pushout.inl g f)","decl":"@[reassoc (attr := simp)]\ntheorem inr_comp_pushoutSymmetry_hom [HasPushout f g] :\n    pushout.inr _ _ ‚â´ (pushoutSymmetry f g).hom = pushout.inl _ _ :=\n  (colimit.isColimit (span f g)).comp_coconePointUniqueUpToIso_hom\n    (PushoutCocone.flipIsColimit (pushoutIsPushout g f)) _\n\n"}
{"name":"CategoryTheory.Limits.inr_comp_pushoutSymmetry_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z‚úù : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z‚úù\ninst‚úù : CategoryTheory.Limits.HasPushout f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout g f) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutSymmetry f g).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl g f) h)","decl":"@[reassoc (attr := simp)]\ntheorem inr_comp_pushoutSymmetry_hom [HasPushout f g] :\n    pushout.inr _ _ ‚â´ (pushoutSymmetry f g).hom = pushout.inl _ _ :=\n  (colimit.isColimit (span f g)).comp_coconePointUniqueUpToIso_hom\n    (PushoutCocone.flipIsColimit (pushoutIsPushout g f)) _\n\n"}
{"name":"CategoryTheory.Limits.inl_comp_pushoutSymmetry_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z‚úù : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z‚úù\ninst‚úù : CategoryTheory.Limits.HasPushout f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout f g) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl g f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutSymmetry f g).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) h)","decl":"@[reassoc (attr := simp)]\ntheorem inl_comp_pushoutSymmetry_inv [HasPushout f g] :\n    pushout.inl _ _ ‚â´ (pushoutSymmetry f g).inv = pushout.inr _ _ := by simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.inl_comp_pushoutSymmetry_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst‚úù : CategoryTheory.Limits.HasPushout f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl g f) (CategoryTheory.Limits.pushoutSymmetry f g).inv) (CategoryTheory.Limits.pushout.inr f g)","decl":"@[reassoc (attr := simp)]\ntheorem inl_comp_pushoutSymmetry_inv [HasPushout f g] :\n    pushout.inl _ _ ‚â´ (pushoutSymmetry f g).inv = pushout.inr _ _ := by simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.inr_comp_pushoutSymmetry_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z‚úù : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z‚úù\ninst‚úù : CategoryTheory.Limits.HasPushout f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout f g) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr g f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutSymmetry f g).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) h)","decl":"@[reassoc (attr := simp)]\ntheorem inr_comp_pushoutSymmetry_inv [HasPushout f g] :\n    pushout.inr _ _ ‚â´ (pushoutSymmetry f g).inv = pushout.inl _ _ := by simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.inr_comp_pushoutSymmetry_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst‚úù : CategoryTheory.Limits.HasPushout f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr g f) (CategoryTheory.Limits.pushoutSymmetry f g).inv) (CategoryTheory.Limits.pushout.inl f g)","decl":"@[reassoc (attr := simp)]\ntheorem inr_comp_pushoutSymmetry_inv [HasPushout f g] :\n    pushout.inr _ _ ‚â´ (pushoutSymmetry f g).inv = pushout.inl _ _ := by simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.hasPullbacks_of_hasLimit_cospan","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : ‚àÄ {X Y Z : C} {f : Quiver.Hom X Z} {g : Quiver.Hom Y Z}, CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan f g)\n‚ä¢ CategoryTheory.Limits.HasPullbacks C","decl":"/-- If `C` has all limits of diagrams `cospan f g`, then it has all pullbacks -/\ntheorem hasPullbacks_of_hasLimit_cospan\n    [‚àÄ {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z}, HasLimit (cospan f g)] : HasPullbacks C :=\n  { has_limit := fun F => hasLimitOfIso (diagramIsoCospan F).symm }\n\n"}
{"name":"CategoryTheory.Limits.hasPushouts_of_hasColimit_span","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : ‚àÄ {X Y Z : C} {f : Quiver.Hom X Y} {g : Quiver.Hom X Z}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.span f g)\n‚ä¢ CategoryTheory.Limits.HasPushouts C","decl":"/-- If `C` has all colimits of diagrams `span f g`, then it has all pushouts -/\ntheorem hasPushouts_of_hasColimit_span\n    [‚àÄ {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z}, HasColimit (span f g)] : HasPushouts C :=\n  { has_colimit := fun F => hasColimitOfIso (diagramIsoSpan F) }\n\n"}
{"name":"CategoryTheory.Limits.walkingSpanOpEquiv_inverse_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X : CategoryTheory.Limits.WidePullbackShape CategoryTheory.Limits.WalkingPair\n‚ä¢ Eq (CategoryTheory.Limits.walkingSpanOpEquiv.inverse.obj X) { unop := X }","decl":"/-- The duality equivalence `WalkingSpan·µí·µñ ‚âå WalkingCospan` -/\n@[simps!]\ndef walkingSpanOpEquiv : WalkingSpan·µí·µñ ‚âå WalkingCospan :=\n  widePushoutShapeOpEquiv _\n\n"}
{"name":"CategoryTheory.Limits.walkingSpanOpEquiv_unitIso_inv_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X : Opposite (CategoryTheory.Limits.WidePushoutShape CategoryTheory.Limits.WalkingPair)\n‚ä¢ Eq (CategoryTheory.Limits.walkingSpanOpEquiv.unitIso.inv.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The duality equivalence `WalkingSpan·µí·µñ ‚âå WalkingCospan` -/\n@[simps!]\ndef walkingSpanOpEquiv : WalkingSpan·µí·µñ ‚âå WalkingCospan :=\n  widePushoutShapeOpEquiv _\n\n"}
{"name":"CategoryTheory.Limits.walkingSpanOpEquiv_counitIso_inv_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X : CategoryTheory.Limits.WidePullbackShape CategoryTheory.Limits.WalkingPair\n‚ä¢ Eq (CategoryTheory.Limits.walkingSpanOpEquiv.counitIso.inv.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The duality equivalence `WalkingSpan·µí·µñ ‚âå WalkingCospan` -/\n@[simps!]\ndef walkingSpanOpEquiv : WalkingSpan·µí·µñ ‚âå WalkingCospan :=\n  widePushoutShapeOpEquiv _\n\n"}
{"name":"CategoryTheory.Limits.walkingSpanOpEquiv_unitIso_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X : Opposite (CategoryTheory.Limits.WidePushoutShape CategoryTheory.Limits.WalkingPair)\n‚ä¢ Eq (CategoryTheory.Limits.walkingSpanOpEquiv.unitIso.hom.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The duality equivalence `WalkingSpan·µí·µñ ‚âå WalkingCospan` -/\n@[simps!]\ndef walkingSpanOpEquiv : WalkingSpan·µí·µñ ‚âå WalkingCospan :=\n  widePushoutShapeOpEquiv _\n\n"}
{"name":"CategoryTheory.Limits.walkingSpanOpEquiv_functor_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X : Opposite (CategoryTheory.Limits.WidePushoutShape CategoryTheory.Limits.WalkingPair)\n‚ä¢ Eq (CategoryTheory.Limits.walkingSpanOpEquiv.functor.obj X) (Opposite.unop X)","decl":"/-- The duality equivalence `WalkingSpan·µí·µñ ‚âå WalkingCospan` -/\n@[simps!]\ndef walkingSpanOpEquiv : WalkingSpan·µí·µñ ‚âå WalkingCospan :=\n  widePushoutShapeOpEquiv _\n\n"}
{"name":"CategoryTheory.Limits.walkingSpanOpEquiv_counitIso_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X : CategoryTheory.Limits.WidePullbackShape CategoryTheory.Limits.WalkingPair\n‚ä¢ Eq (CategoryTheory.Limits.walkingSpanOpEquiv.counitIso.hom.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The duality equivalence `WalkingSpan·µí·µñ ‚âå WalkingCospan` -/\n@[simps!]\ndef walkingSpanOpEquiv : WalkingSpan·µí·µñ ‚âå WalkingCospan :=\n  widePushoutShapeOpEquiv _\n\n"}
{"name":"CategoryTheory.Limits.walkingSpanOpEquiv_functor_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X‚úù Y‚úù : Opposite (CategoryTheory.Limits.WidePushoutShape CategoryTheory.Limits.WalkingPair)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Limits.walkingSpanOpEquiv.functor.map f) (CategoryTheory.Limits.widePushoutShapeOpMap CategoryTheory.Limits.WalkingPair (Opposite.unop Y‚úù) (Opposite.unop X‚úù) f.unop).unop","decl":"/-- The duality equivalence `WalkingSpan·µí·µñ ‚âå WalkingCospan` -/\n@[simps!]\ndef walkingSpanOpEquiv : WalkingSpan·µí·µñ ‚âå WalkingCospan :=\n  widePushoutShapeOpEquiv _\n\n"}
{"name":"CategoryTheory.Limits.walkingSpanOpEquiv_inverse_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X‚ÇÅ X‚ÇÇ : CategoryTheory.Limits.WidePullbackShape CategoryTheory.Limits.WalkingPair\na‚úù : Quiver.Hom X‚ÇÅ X‚ÇÇ\n‚ä¢ Eq (CategoryTheory.Limits.walkingSpanOpEquiv.inverse.map a‚úù) (CategoryTheory.Limits.widePullbackShapeOpMap CategoryTheory.Limits.WalkingPair X‚ÇÅ X‚ÇÇ a‚úù)","decl":"/-- The duality equivalence `WalkingSpan·µí·µñ ‚âå WalkingCospan` -/\n@[simps!]\ndef walkingSpanOpEquiv : WalkingSpan·µí·µñ ‚âå WalkingCospan :=\n  widePushoutShapeOpEquiv _\n\n"}
{"name":"CategoryTheory.Limits.walkingCospanOpEquiv_inverse_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X Y : CategoryTheory.Limits.WidePushoutShape CategoryTheory.Limits.WalkingPair\na‚úù : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.Limits.walkingCospanOpEquiv.inverse.map a‚úù) (CategoryTheory.Limits.widePushoutShapeOpMap CategoryTheory.Limits.WalkingPair X Y a‚úù)","decl":"/-- The duality equivalence `WalkingCospan·µí·µñ ‚âå WalkingSpan` -/\n@[simps!]\ndef walkingCospanOpEquiv : WalkingCospan·µí·µñ ‚âå WalkingSpan :=\n  widePullbackShapeOpEquiv _\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.walkingCospanOpEquiv_functor_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X‚úù Y‚úù : Opposite (CategoryTheory.Limits.WidePullbackShape CategoryTheory.Limits.WalkingPair)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Limits.walkingCospanOpEquiv.functor.map f) (CategoryTheory.Limits.widePullbackShapeOpMap CategoryTheory.Limits.WalkingPair (Opposite.unop Y‚úù) (Opposite.unop X‚úù) f.unop).unop","decl":"/-- The duality equivalence `WalkingCospan·µí·µñ ‚âå WalkingSpan` -/\n@[simps!]\ndef walkingCospanOpEquiv : WalkingCospan·µí·µñ ‚âå WalkingSpan :=\n  widePullbackShapeOpEquiv _\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.walkingCospanOpEquiv_functor_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X : Opposite (CategoryTheory.Limits.WidePullbackShape CategoryTheory.Limits.WalkingPair)\n‚ä¢ Eq (CategoryTheory.Limits.walkingCospanOpEquiv.functor.obj X) (Opposite.unop X)","decl":"/-- The duality equivalence `WalkingCospan·µí·µñ ‚âå WalkingSpan` -/\n@[simps!]\ndef walkingCospanOpEquiv : WalkingCospan·µí·µñ ‚âå WalkingSpan :=\n  widePullbackShapeOpEquiv _\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.walkingCospanOpEquiv_counitIso_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X : CategoryTheory.Limits.WidePushoutShape CategoryTheory.Limits.WalkingPair\n‚ä¢ Eq (CategoryTheory.Limits.walkingCospanOpEquiv.counitIso.hom.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The duality equivalence `WalkingCospan·µí·µñ ‚âå WalkingSpan` -/\n@[simps!]\ndef walkingCospanOpEquiv : WalkingCospan·µí·µñ ‚âå WalkingSpan :=\n  widePullbackShapeOpEquiv _\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.walkingCospanOpEquiv_unitIso_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X : Opposite (CategoryTheory.Limits.WidePullbackShape CategoryTheory.Limits.WalkingPair)\n‚ä¢ Eq (CategoryTheory.Limits.walkingCospanOpEquiv.unitIso.hom.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The duality equivalence `WalkingCospan·µí·µñ ‚âå WalkingSpan` -/\n@[simps!]\ndef walkingCospanOpEquiv : WalkingCospan·µí·µñ ‚âå WalkingSpan :=\n  widePullbackShapeOpEquiv _\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.walkingCospanOpEquiv_unitIso_inv_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X : Opposite (CategoryTheory.Limits.WidePullbackShape CategoryTheory.Limits.WalkingPair)\n‚ä¢ Eq (CategoryTheory.Limits.walkingCospanOpEquiv.unitIso.inv.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The duality equivalence `WalkingCospan·µí·µñ ‚âå WalkingSpan` -/\n@[simps!]\ndef walkingCospanOpEquiv : WalkingCospan·µí·µñ ‚âå WalkingSpan :=\n  widePullbackShapeOpEquiv _\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.walkingCospanOpEquiv_inverse_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X : CategoryTheory.Limits.WidePushoutShape CategoryTheory.Limits.WalkingPair\n‚ä¢ Eq (CategoryTheory.Limits.walkingCospanOpEquiv.inverse.obj X) { unop := X }","decl":"/-- The duality equivalence `WalkingCospan·µí·µñ ‚âå WalkingSpan` -/\n@[simps!]\ndef walkingCospanOpEquiv : WalkingCospan·µí·µñ ‚âå WalkingSpan :=\n  widePullbackShapeOpEquiv _\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.walkingCospanOpEquiv_counitIso_inv_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X : CategoryTheory.Limits.WidePushoutShape CategoryTheory.Limits.WalkingPair\n‚ä¢ Eq (CategoryTheory.Limits.walkingCospanOpEquiv.counitIso.inv.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The duality equivalence `WalkingCospan·µí·µñ ‚âå WalkingSpan` -/\n@[simps!]\ndef walkingCospanOpEquiv : WalkingCospan·µí·µñ ‚âå WalkingSpan :=\n  widePullbackShapeOpEquiv _\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"D : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} D\ninst‚úù : CategoryTheory.Limits.HasWidePullbacks D\n‚ä¢ CategoryTheory.Limits.HasPullbacks D","decl":"/-- Having wide pullback at any universe level implies having binary pullbacks. -/\ninstance (priority := 100) hasPullbacks_of_hasWidePullbacks (D : Type u) [Category.{v} D]\n    [HasWidePullbacks.{w} D] : HasPullbacks.{v,u} D :=\n  hasWidePullbacks_shrink WalkingPair\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.hasPushouts_of_hasWidePushouts","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"D : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} D\ninst‚úù : CategoryTheory.Limits.HasWidePushouts D\n‚ä¢ CategoryTheory.Limits.HasPushouts D","decl":"/-- Having wide pushout at any universe level implies having binary pushouts. -/\ninstance (priority := 100) hasPushouts_of_hasWidePushouts (D : Type u) [Category.{v} D]\n    [HasWidePushouts.{w} D] : HasPushouts.{v,u} D :=\n  hasWidePushouts_shrink WalkingPair\n\n"}
