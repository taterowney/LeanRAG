{"name":"CategoryTheory.Limits.PullbackCone.fst_limit_cone","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan f g)\n⊢ Eq (CategoryTheory.Limits.PullbackCone.fst (CategoryTheory.Limits.limit.cone (CategoryTheory.Limits.cospan f g))) (CategoryTheory.Limits.pullback.fst f g)","decl":"@[simp]\ntheorem PullbackCone.fst_limit_cone {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) [HasLimit (cospan f g)] :\n    PullbackCone.fst (limit.cone (cospan f g)) = pullback.fst f g := rfl\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.snd_limit_cone","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan f g)\n⊢ Eq (CategoryTheory.Limits.PullbackCone.snd (CategoryTheory.Limits.limit.cone (CategoryTheory.Limits.cospan f g))) (CategoryTheory.Limits.pullback.snd f g)","decl":"@[simp]\ntheorem PullbackCone.snd_limit_cone {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) [HasLimit (cospan f g)] :\n    PullbackCone.snd (limit.cone (cospan f g)) = pullback.snd f g := rfl\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.inl_colimit_cocone","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninst✝ : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.span f g)\n⊢ Eq (CategoryTheory.Limits.PushoutCocone.inl (CategoryTheory.Limits.colimit.cocone (CategoryTheory.Limits.span f g))) (CategoryTheory.Limits.pushout.inl f g)","decl":"theorem PushoutCocone.inl_colimit_cocone {X Y Z : C} (f : Z ⟶ X) (g : Z ⟶ Y)\n    [HasColimit (span f g)] : PushoutCocone.inl (colimit.cocone (span f g)) = pushout.inl _ _ := rfl\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.inr_colimit_cocone","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninst✝ : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.span f g)\n⊢ Eq (CategoryTheory.Limits.PushoutCocone.inr (CategoryTheory.Limits.colimit.cocone (CategoryTheory.Limits.span f g))) (CategoryTheory.Limits.pushout.inr f g)","decl":"theorem PushoutCocone.inr_colimit_cocone {X Y Z : C} (f : Z ⟶ X) (g : Z ⟶ Y)\n    [HasColimit (span f g)] : PushoutCocone.inr (colimit.cocone (span f g)) = pushout.inr _ _ := rfl\n\n"}
{"name":"CategoryTheory.Limits.pullback.lift_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : CategoryTheory.Limits.HasPullback f g\nh✝ : Quiver.Hom W X\nk : Quiver.Hom W Y\nw : Eq (CategoryTheory.CategoryStruct.comp h✝ f) (CategoryTheory.CategoryStruct.comp k g)\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.lift h✝ k w) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) h)) (CategoryTheory.CategoryStruct.comp h✝ h)","decl":"@[reassoc]\ntheorem pullback.lift_fst {W X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} [HasPullback f g] (h : W ⟶ X)\n    (k : W ⟶ Y) (w : h ≫ f = k ≫ g) : pullback.lift h k w ≫ pullback.fst f g = h :=\n  limit.lift_π _ _\n\n"}
{"name":"CategoryTheory.Limits.pullback.lift_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Limits.HasPullback f g\nh : Quiver.Hom W X\nk : Quiver.Hom W Y\nw : Eq (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp k g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.lift h k w) (CategoryTheory.Limits.pullback.fst f g)) h","decl":"@[reassoc]\ntheorem pullback.lift_fst {W X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} [HasPullback f g] (h : W ⟶ X)\n    (k : W ⟶ Y) (w : h ≫ f = k ≫ g) : pullback.lift h k w ≫ pullback.fst f g = h :=\n  limit.lift_π _ _\n\n"}
{"name":"CategoryTheory.Limits.pullback.lift_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : CategoryTheory.Limits.HasPullback f g\nh✝ : Quiver.Hom W X\nk : Quiver.Hom W Y\nw : Eq (CategoryTheory.CategoryStruct.comp h✝ f) (CategoryTheory.CategoryStruct.comp k g)\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.lift h✝ k w) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc]\ntheorem pullback.lift_snd {W X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} [HasPullback f g] (h : W ⟶ X)\n    (k : W ⟶ Y) (w : h ≫ f = k ≫ g) : pullback.lift h k w ≫ pullback.snd f g = k :=\n  limit.lift_π _ _\n\n"}
{"name":"CategoryTheory.Limits.pullback.lift_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Limits.HasPullback f g\nh : Quiver.Hom W X\nk : Quiver.Hom W Y\nw : Eq (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp k g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.lift h k w) (CategoryTheory.Limits.pullback.snd f g)) k","decl":"@[reassoc]\ntheorem pullback.lift_snd {W X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} [HasPullback f g] (h : W ⟶ X)\n    (k : W ⟶ Y) (w : h ≫ f = k ≫ g) : pullback.lift h k w ≫ pullback.snd f g = k :=\n  limit.lift_π _ _\n\n"}
{"name":"CategoryTheory.Limits.pushout.inl_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst✝ : CategoryTheory.Limits.HasPushout f g\nh : Quiver.Hom Y W\nk : Quiver.Hom Z W\nw : Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g k)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) (CategoryTheory.Limits.pushout.desc h k w)) h","decl":"@[reassoc]\ntheorem pushout.inl_desc {W X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z} [HasPushout f g] (h : Y ⟶ W)\n    (k : Z ⟶ W) (w : f ≫ h = g ≫ k) : pushout.inl _ _ ≫ pushout.desc h k w = h :=\n  colimit.ι_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.pushout.inl_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z✝\ninst✝ : CategoryTheory.Limits.HasPushout f g\nh✝ : Quiver.Hom Y W\nk : Quiver.Hom Z✝ W\nw : Eq (CategoryTheory.CategoryStruct.comp f h✝) (CategoryTheory.CategoryStruct.comp g k)\nZ : C\nh : Quiver.Hom W Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.desc h✝ k w) h)) (CategoryTheory.CategoryStruct.comp h✝ h)","decl":"@[reassoc]\ntheorem pushout.inl_desc {W X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z} [HasPushout f g] (h : Y ⟶ W)\n    (k : Z ⟶ W) (w : f ≫ h = g ≫ k) : pushout.inl _ _ ≫ pushout.desc h k w = h :=\n  colimit.ι_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.pushout.inr_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z✝\ninst✝ : CategoryTheory.Limits.HasPushout f g\nh✝ : Quiver.Hom Y W\nk : Quiver.Hom Z✝ W\nw : Eq (CategoryTheory.CategoryStruct.comp f h✝) (CategoryTheory.CategoryStruct.comp g k)\nZ : C\nh : Quiver.Hom W Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.desc h✝ k w) h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc]\ntheorem pushout.inr_desc {W X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z} [HasPushout f g] (h : Y ⟶ W)\n    (k : Z ⟶ W) (w : f ≫ h = g ≫ k) : pushout.inr _ _ ≫ pushout.desc h k w = k :=\n  colimit.ι_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.pushout.inr_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst✝ : CategoryTheory.Limits.HasPushout f g\nh : Quiver.Hom Y W\nk : Quiver.Hom Z W\nw : Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g k)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) (CategoryTheory.Limits.pushout.desc h k w)) k","decl":"@[reassoc]\ntheorem pushout.inr_desc {W X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z} [HasPushout f g] (h : Y ⟶ W)\n    (k : Z ⟶ W) (w : f ≫ h = g ≫ k) : pushout.inr _ _ ≫ pushout.desc h k w = k :=\n  colimit.ι_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.pullback.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Limits.HasPullback f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) g)","decl":"@[reassoc]\ntheorem pullback.condition {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} [HasPullback f g] :\n    pullback.fst f g ≫ f = pullback.snd f g ≫ g :=\n  PullbackCone.condition _\n\n"}
{"name":"CategoryTheory.Limits.pullback.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : CategoryTheory.Limits.HasPullback f g\nZ : C\nh : Quiver.Hom Z✝ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc]\ntheorem pullback.condition {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} [HasPullback f g] :\n    pullback.fst f g ≫ f = pullback.snd f g ≫ g :=\n  PullbackCone.condition _\n\n"}
{"name":"CategoryTheory.Limits.pushout.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z✝ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z✝\ninst✝ : CategoryTheory.Limits.HasPushout f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout f g) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) h)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) h))","decl":"@[reassoc]\ntheorem pushout.condition {X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z} [HasPushout f g] :\n    f ≫ (pushout.inl f g) = g ≫ pushout.inr _ _ :=\n  PushoutCocone.condition _\n\n"}
{"name":"CategoryTheory.Limits.pushout.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst✝ : CategoryTheory.Limits.HasPushout f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.pushout.inl f g)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.pushout.inr f g))","decl":"@[reassoc]\ntheorem pushout.condition {X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z} [HasPushout f g] :\n    f ≫ (pushout.inl f g) = g ≫ pushout.inr _ _ :=\n  PushoutCocone.condition _\n\n"}
{"name":"CategoryTheory.Limits.pullback.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Limits.HasPullback f g\nW : C\nk l : Quiver.Hom W (CategoryTheory.Limits.pullback f g)\nh₀ : Eq (CategoryTheory.CategoryStruct.comp k (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.CategoryStruct.comp l (CategoryTheory.Limits.pullback.fst f g))\nh₁ : Eq (CategoryTheory.CategoryStruct.comp k (CategoryTheory.Limits.pullback.snd f g)) (CategoryTheory.CategoryStruct.comp l (CategoryTheory.Limits.pullback.snd f g))\n⊢ Eq k l","decl":"/-- Two morphisms into a pullback are equal if their compositions with the pullback morphisms are\n    equal -/\n@[ext 1100]\ntheorem pullback.hom_ext {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} [HasPullback f g] {W : C}\n    {k l : W ⟶ pullback f g} (h₀ : k ≫ pullback.fst f g = l ≫ pullback.fst f g)\n    (h₁ : k ≫ pullback.snd f g = l ≫ pullback.snd f g) : k = l :=\n  limit.hom_ext <| PullbackCone.equalizer_ext _ h₀ h₁\n\n"}
{"name":"CategoryTheory.Limits.pullback.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Limits.HasPullback f g\nW : C\nk l : Quiver.Hom W (CategoryTheory.Limits.pullback f g)\n⊢ Iff (Eq k l) (And (Eq (CategoryTheory.CategoryStruct.comp k (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.CategoryStruct.comp l (CategoryTheory.Limits.pullback.fst f g))) (Eq (CategoryTheory.CategoryStruct.comp k (CategoryTheory.Limits.pullback.snd f g)) (CategoryTheory.CategoryStruct.comp l (CategoryTheory.Limits.pullback.snd f g))))","decl":"/-- Two morphisms into a pullback are equal if their compositions with the pullback morphisms are\n    equal -/\n@[ext 1100]\ntheorem pullback.hom_ext {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} [HasPullback f g] {W : C}\n    {k l : W ⟶ pullback f g} (h₀ : k ≫ pullback.fst f g = l ≫ pullback.fst f g)\n    (h₁ : k ≫ pullback.snd f g = l ≫ pullback.snd f g) : k = l :=\n  limit.hom_ext <| PullbackCone.equalizer_ext _ h₀ h₁\n\n"}
{"name":"CategoryTheory.Limits.pushout.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst✝ : CategoryTheory.Limits.HasPushout f g\nW : C\nk l : Quiver.Hom (CategoryTheory.Limits.pushout f g) W\nh₀ : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) l)\nh₁ : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) l)\n⊢ Eq k l","decl":"/-- Two morphisms out of a pushout are equal if their compositions with the pushout morphisms are\n    equal -/\n@[ext 1100]\ntheorem pushout.hom_ext {X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z} [HasPushout f g] {W : C}\n    {k l : pushout f g ⟶ W} (h₀ : pushout.inl _ _ ≫ k = pushout.inl _ _ ≫ l)\n    (h₁ : pushout.inr _ _ ≫ k = pushout.inr _ _ ≫ l) : k = l :=\n  colimit.hom_ext <| PushoutCocone.coequalizer_ext _ h₀ h₁\n\n"}
{"name":"CategoryTheory.Limits.pushout.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst✝ : CategoryTheory.Limits.HasPushout f g\nW : C\nk l : Quiver.Hom (CategoryTheory.Limits.pushout f g) W\n⊢ Iff (Eq k l) (And (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) l)) (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) l)))","decl":"/-- Two morphisms out of a pushout are equal if their compositions with the pushout morphisms are\n    equal -/\n@[ext 1100]\ntheorem pushout.hom_ext {X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z} [HasPushout f g] {W : C}\n    {k l : pushout f g ⟶ W} (h₀ : pushout.inl _ _ ≫ k = pushout.inl _ _ ≫ l)\n    (h₁ : pushout.inr _ _ ≫ k = pushout.inr _ _ ≫ l) : k = l :=\n  colimit.hom_ext <| PushoutCocone.coequalizer_ext _ h₀ h₁\n\n"}
{"name":"CategoryTheory.Limits.pullback.map_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y Z X' Y' Z' X'' Y'' Z'' : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nf' : Quiver.Hom X' Z'\ng' : Quiver.Hom Y' Z'\nf'' : Quiver.Hom X'' Z''\ng'' : Quiver.Hom Y'' Z''\ni₁ : Quiver.Hom X X'\nj₁ : Quiver.Hom X' X''\ni₂ : Quiver.Hom Y Y'\nj₂ : Quiver.Hom Y' Y''\ni₃ : Quiver.Hom Z Z'\nj₃ : Quiver.Hom Z' Z''\ninst✝² : CategoryTheory.Limits.HasPullback f g\ninst✝¹ : CategoryTheory.Limits.HasPullback f' g'\ninst✝ : CategoryTheory.Limits.HasPullback f'' g''\ne₁ : Eq (CategoryTheory.CategoryStruct.comp f i₃) (CategoryTheory.CategoryStruct.comp i₁ f')\ne₂ : Eq (CategoryTheory.CategoryStruct.comp g i₃) (CategoryTheory.CategoryStruct.comp i₂ g')\ne₃ : Eq (CategoryTheory.CategoryStruct.comp f' j₃) (CategoryTheory.CategoryStruct.comp j₁ f'')\ne₄ : Eq (CategoryTheory.CategoryStruct.comp g' j₃) (CategoryTheory.CategoryStruct.comp j₂ g'')\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.map f g f' g' i₁ i₂ i₃ e₁ e₂) (CategoryTheory.Limits.pullback.map f' g' f'' g'' j₁ j₂ j₃ e₃ e₄)) (CategoryTheory.Limits.pullback.map f g f'' g'' (CategoryTheory.CategoryStruct.comp i₁ j₁) (CategoryTheory.CategoryStruct.comp i₂ j₂) (CategoryTheory.CategoryStruct.comp i₃ j₃) ⋯ ⋯)","decl":"@[reassoc]\nlemma pullback.map_comp {X Y Z X' Y' Z' X'' Y'' Z'' : C}\n    {f : X ⟶ Z} {g : Y ⟶ Z} {f' : X' ⟶ Z'} {g' : Y' ⟶ Z'} {f'' : X'' ⟶ Z''} {g'' : Y'' ⟶ Z''}\n    (i₁ : X ⟶ X') (j₁ : X' ⟶ X'') (i₂ : Y ⟶ Y') (j₂ : Y' ⟶ Y'') (i₃ : Z ⟶ Z') (j₃ : Z' ⟶ Z'')\n    [HasPullback f g] [HasPullback f' g'] [HasPullback f'' g'']\n    (e₁ e₂ e₃ e₄) :\n    pullback.map f g f' g' i₁ i₂ i₃ e₁ e₂ ≫ pullback.map f' g' f'' g'' j₁ j₂ j₃ e₃ e₄ =\n      pullback.map f g f'' g'' (i₁ ≫ j₁) (i₂ ≫ j₂) (i₃ ≫ j₃)\n        (by rw [reassoc_of% e₁, e₃, Category.assoc])\n        (by rw [reassoc_of% e₂, e₄, Category.assoc]) := by ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.pullback.map_comp_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y Z✝ X' Y' Z' X'' Y'' Z'' : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nf' : Quiver.Hom X' Z'\ng' : Quiver.Hom Y' Z'\nf'' : Quiver.Hom X'' Z''\ng'' : Quiver.Hom Y'' Z''\ni₁ : Quiver.Hom X X'\nj₁ : Quiver.Hom X' X''\ni₂ : Quiver.Hom Y Y'\nj₂ : Quiver.Hom Y' Y''\ni₃ : Quiver.Hom Z✝ Z'\nj₃ : Quiver.Hom Z' Z''\ninst✝² : CategoryTheory.Limits.HasPullback f g\ninst✝¹ : CategoryTheory.Limits.HasPullback f' g'\ninst✝ : CategoryTheory.Limits.HasPullback f'' g''\ne₁ : Eq (CategoryTheory.CategoryStruct.comp f i₃) (CategoryTheory.CategoryStruct.comp i₁ f')\ne₂ : Eq (CategoryTheory.CategoryStruct.comp g i₃) (CategoryTheory.CategoryStruct.comp i₂ g')\ne₃ : Eq (CategoryTheory.CategoryStruct.comp f' j₃) (CategoryTheory.CategoryStruct.comp j₁ f'')\ne₄ : Eq (CategoryTheory.CategoryStruct.comp g' j₃) (CategoryTheory.CategoryStruct.comp j₂ g'')\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pullback f'' g'') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.map f g f' g' i₁ i₂ i₃ e₁ e₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.map f' g' f'' g'' j₁ j₂ j₃ e₃ e₄) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.map f g f'' g'' (CategoryTheory.CategoryStruct.comp i₁ j₁) (CategoryTheory.CategoryStruct.comp i₂ j₂) (CategoryTheory.CategoryStruct.comp i₃ j₃) ⋯ ⋯) h)","decl":"@[reassoc]\nlemma pullback.map_comp {X Y Z X' Y' Z' X'' Y'' Z'' : C}\n    {f : X ⟶ Z} {g : Y ⟶ Z} {f' : X' ⟶ Z'} {g' : Y' ⟶ Z'} {f'' : X'' ⟶ Z''} {g'' : Y'' ⟶ Z''}\n    (i₁ : X ⟶ X') (j₁ : X' ⟶ X'') (i₂ : Y ⟶ Y') (j₂ : Y' ⟶ Y'') (i₃ : Z ⟶ Z') (j₃ : Z' ⟶ Z'')\n    [HasPullback f g] [HasPullback f' g'] [HasPullback f'' g'']\n    (e₁ e₂ e₃ e₄) :\n    pullback.map f g f' g' i₁ i₂ i₃ e₁ e₂ ≫ pullback.map f' g' f'' g'' j₁ j₂ j₃ e₃ e₄ =\n      pullback.map f g f'' g'' (i₁ ≫ j₁) (i₂ ≫ j₂) (i₃ ≫ j₃)\n        (by rw [reassoc_of% e₁, e₃, Category.assoc])\n        (by rw [reassoc_of% e₂, e₄, Category.assoc]) := by ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.pullback.map_id","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Limits.HasPullback f g\n⊢ Eq (CategoryTheory.Limits.pullback.map f g f g (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Z) ⋯ ⋯) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback f g))","decl":"@[simp]\nlemma pullback.map_id {X Y Z : C}\n    {f : X ⟶ Z} {g : Y ⟶ Z} [HasPullback f g] :\n    pullback.map f g f g (𝟙 _) (𝟙 _) (𝟙 _) (by simp) (by simp) = 𝟙 _ := by ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.pushout.map_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y Z X' Y' Z' X'' Y'' Z'' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nf' : Quiver.Hom X' Y'\ng' : Quiver.Hom X' Z'\nf'' : Quiver.Hom X'' Y''\ng'' : Quiver.Hom X'' Z''\ni₁ : Quiver.Hom X X'\nj₁ : Quiver.Hom X' X''\ni₂ : Quiver.Hom Y Y'\nj₂ : Quiver.Hom Y' Y''\ni₃ : Quiver.Hom Z Z'\nj₃ : Quiver.Hom Z' Z''\ninst✝² : CategoryTheory.Limits.HasPushout f g\ninst✝¹ : CategoryTheory.Limits.HasPushout f' g'\ninst✝ : CategoryTheory.Limits.HasPushout f'' g''\ne₁ : Eq (CategoryTheory.CategoryStruct.comp f i₂) (CategoryTheory.CategoryStruct.comp i₁ f')\ne₂ : Eq (CategoryTheory.CategoryStruct.comp g i₃) (CategoryTheory.CategoryStruct.comp i₁ g')\ne₃ : Eq (CategoryTheory.CategoryStruct.comp f' j₂) (CategoryTheory.CategoryStruct.comp j₁ f'')\ne₄ : Eq (CategoryTheory.CategoryStruct.comp g' j₃) (CategoryTheory.CategoryStruct.comp j₁ g'')\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.map f g f' g' i₂ i₃ i₁ e₁ e₂) (CategoryTheory.Limits.pushout.map f' g' f'' g'' j₂ j₃ j₁ e₃ e₄)) (CategoryTheory.Limits.pushout.map f g f'' g'' (CategoryTheory.CategoryStruct.comp i₂ j₂) (CategoryTheory.CategoryStruct.comp i₃ j₃) (CategoryTheory.CategoryStruct.comp i₁ j₁) ⋯ ⋯)","decl":"@[reassoc]\nlemma pushout.map_comp {X Y Z X' Y' Z' X'' Y'' Z'' : C}\n    {f : X ⟶ Y} {g : X ⟶ Z} {f' : X' ⟶ Y'} {g' : X' ⟶ Z'} {f'' : X'' ⟶ Y''} {g'' : X'' ⟶ Z''}\n    (i₁ : X ⟶ X') (j₁ : X' ⟶ X'') (i₂ : Y ⟶ Y') (j₂ : Y' ⟶ Y'') (i₃ : Z ⟶ Z') (j₃ : Z' ⟶ Z'')\n    [HasPushout f g] [HasPushout f' g'] [HasPushout f'' g'']\n    (e₁ e₂ e₃ e₄) :\n    pushout.map f g f' g' i₂ i₃ i₁ e₁ e₂ ≫ pushout.map f' g' f'' g'' j₂ j₃ j₁ e₃ e₄ =\n      pushout.map f g f'' g'' (i₂ ≫ j₂) (i₃ ≫ j₃) (i₁ ≫ j₁)\n        (by rw [reassoc_of% e₁, e₃, Category.assoc])\n        (by rw [reassoc_of% e₂, e₄, Category.assoc]) := by ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.pushout.map_comp_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y Z✝ X' Y' Z' X'' Y'' Z'' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z✝\nf' : Quiver.Hom X' Y'\ng' : Quiver.Hom X' Z'\nf'' : Quiver.Hom X'' Y''\ng'' : Quiver.Hom X'' Z''\ni₁ : Quiver.Hom X X'\nj₁ : Quiver.Hom X' X''\ni₂ : Quiver.Hom Y Y'\nj₂ : Quiver.Hom Y' Y''\ni₃ : Quiver.Hom Z✝ Z'\nj₃ : Quiver.Hom Z' Z''\ninst✝² : CategoryTheory.Limits.HasPushout f g\ninst✝¹ : CategoryTheory.Limits.HasPushout f' g'\ninst✝ : CategoryTheory.Limits.HasPushout f'' g''\ne₁ : Eq (CategoryTheory.CategoryStruct.comp f i₂) (CategoryTheory.CategoryStruct.comp i₁ f')\ne₂ : Eq (CategoryTheory.CategoryStruct.comp g i₃) (CategoryTheory.CategoryStruct.comp i₁ g')\ne₃ : Eq (CategoryTheory.CategoryStruct.comp f' j₂) (CategoryTheory.CategoryStruct.comp j₁ f'')\ne₄ : Eq (CategoryTheory.CategoryStruct.comp g' j₃) (CategoryTheory.CategoryStruct.comp j₁ g'')\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout f'' g'') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.map f g f' g' i₂ i₃ i₁ e₁ e₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.map f' g' f'' g'' j₂ j₃ j₁ e₃ e₄) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.map f g f'' g'' (CategoryTheory.CategoryStruct.comp i₂ j₂) (CategoryTheory.CategoryStruct.comp i₃ j₃) (CategoryTheory.CategoryStruct.comp i₁ j₁) ⋯ ⋯) h)","decl":"@[reassoc]\nlemma pushout.map_comp {X Y Z X' Y' Z' X'' Y'' Z'' : C}\n    {f : X ⟶ Y} {g : X ⟶ Z} {f' : X' ⟶ Y'} {g' : X' ⟶ Z'} {f'' : X'' ⟶ Y''} {g'' : X'' ⟶ Z''}\n    (i₁ : X ⟶ X') (j₁ : X' ⟶ X'') (i₂ : Y ⟶ Y') (j₂ : Y' ⟶ Y'') (i₃ : Z ⟶ Z') (j₃ : Z' ⟶ Z'')\n    [HasPushout f g] [HasPushout f' g'] [HasPushout f'' g'']\n    (e₁ e₂ e₃ e₄) :\n    pushout.map f g f' g' i₂ i₃ i₁ e₁ e₂ ≫ pushout.map f' g' f'' g'' j₂ j₃ j₁ e₃ e₄ =\n      pushout.map f g f'' g'' (i₂ ≫ j₂) (i₃ ≫ j₃) (i₁ ≫ j₁)\n        (by rw [reassoc_of% e₁, e₃, Category.assoc])\n        (by rw [reassoc_of% e₂, e₄, Category.assoc]) := by ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.pushout.map_id","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst✝ : CategoryTheory.Limits.HasPushout f g\n⊢ Eq (CategoryTheory.Limits.pushout.map f g f g (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Z) (CategoryTheory.CategoryStruct.id X) ⋯ ⋯) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pushout f g))","decl":"@[simp]\nlemma pushout.map_id {X Y Z : C}\n    {f : X ⟶ Y} {g : X ⟶ Z} [HasPushout f g] :\n    pushout.map f g f g (𝟙 _) (𝟙 _) (𝟙 _) (by simp) (by simp) = 𝟙 _ := by ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.pullback.map_isIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nW X Y Z S T : C\nf₁ : Quiver.Hom W S\nf₂ : Quiver.Hom X S\ninst✝⁴ : CategoryTheory.Limits.HasPullback f₁ f₂\ng₁ : Quiver.Hom Y T\ng₂ : Quiver.Hom Z T\ninst✝³ : CategoryTheory.Limits.HasPullback g₁ g₂\ni₁ : Quiver.Hom W Y\ni₂ : Quiver.Hom X Z\ni₃ : Quiver.Hom S T\neq₁ : Eq (CategoryTheory.CategoryStruct.comp f₁ i₃) (CategoryTheory.CategoryStruct.comp i₁ g₁)\neq₂ : Eq (CategoryTheory.CategoryStruct.comp f₂ i₃) (CategoryTheory.CategoryStruct.comp i₂ g₂)\ninst✝² : CategoryTheory.IsIso i₁\ninst✝¹ : CategoryTheory.IsIso i₂\ninst✝ : CategoryTheory.IsIso i₃\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.pullback.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂)","decl":"instance pullback.map_isIso {W X Y Z S T : C} (f₁ : W ⟶ S) (f₂ : X ⟶ S) [HasPullback f₁ f₂]\n    (g₁ : Y ⟶ T) (g₂ : Z ⟶ T) [HasPullback g₁ g₂] (i₁ : W ⟶ Y) (i₂ : X ⟶ Z) (i₃ : S ⟶ T)\n    (eq₁ : f₁ ≫ i₃ = i₁ ≫ g₁) (eq₂ : f₂ ≫ i₃ = i₂ ≫ g₂) [IsIso i₁] [IsIso i₂] [IsIso i₃] :\n    IsIso (pullback.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂) := by\n  refine ⟨⟨pullback.map _ _ _ _ (inv i₁) (inv i₂) (inv i₃) ?_ ?_, ?_, ?_⟩⟩\n  · rw [IsIso.comp_inv_eq, Category.assoc, eq₁, IsIso.inv_hom_id_assoc]\n  · rw [IsIso.comp_inv_eq, Category.assoc, eq₂, IsIso.inv_hom_id_assoc]\n  · aesop_cat\n  · aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.pullback.congrHom_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf₁ f₂ : Quiver.Hom X Z\ng₁ g₂ : Quiver.Hom Y Z\nh₁ : Eq f₁ f₂\nh₂ : Eq g₁ g₂\ninst✝¹ : CategoryTheory.Limits.HasPullback f₁ g₁\ninst✝ : CategoryTheory.Limits.HasPullback f₂ g₂\n⊢ Eq (CategoryTheory.Limits.pullback.congrHom h₁ h₂).hom (CategoryTheory.Limits.pullback.map f₁ g₁ f₂ g₂ (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Z) ⋯ ⋯)","decl":"/-- If `f₁ = f₂` and `g₁ = g₂`, we may construct a canonical\nisomorphism `pullback f₁ g₁ ≅ pullback f₂ g₂` -/\n@[simps! hom]\ndef pullback.congrHom {X Y Z : C} {f₁ f₂ : X ⟶ Z} {g₁ g₂ : Y ⟶ Z} (h₁ : f₁ = f₂) (h₂ : g₁ = g₂)\n    [HasPullback f₁ g₁] [HasPullback f₂ g₂] : pullback f₁ g₁ ≅ pullback f₂ g₂ :=\n  asIso <| pullback.map _ _ _ _ (𝟙 _) (𝟙 _) (𝟙 _) (by simp [h₁]) (by simp [h₂])\n\n"}
{"name":"CategoryTheory.Limits.pullback.congrHom_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf₁ f₂ : Quiver.Hom X Z\ng₁ g₂ : Quiver.Hom Y Z\nh₁ : Eq f₁ f₂\nh₂ : Eq g₁ g₂\ninst✝¹ : CategoryTheory.Limits.HasPullback f₁ g₁\ninst✝ : CategoryTheory.Limits.HasPullback f₂ g₂\n⊢ Eq (CategoryTheory.Limits.pullback.congrHom h₁ h₂).inv (CategoryTheory.Limits.pullback.map f₂ g₂ f₁ g₁ (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Z) ⋯ ⋯)","decl":"@[simp]\ntheorem pullback.congrHom_inv {X Y Z : C} {f₁ f₂ : X ⟶ Z} {g₁ g₂ : Y ⟶ Z} (h₁ : f₁ = f₂)\n    (h₂ : g₁ = g₂) [HasPullback f₁ g₁] [HasPullback f₂ g₂] :\n    (pullback.congrHom h₁ h₂).inv =\n      pullback.map _ _ _ _ (𝟙 _) (𝟙 _) (𝟙 _) (by simp [h₁]) (by simp [h₂]) := by\n  ext <;> simp [Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.pushout.map_isIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nW X Y Z S T : C\nf₁ : Quiver.Hom S W\nf₂ : Quiver.Hom S X\ninst✝⁴ : CategoryTheory.Limits.HasPushout f₁ f₂\ng₁ : Quiver.Hom T Y\ng₂ : Quiver.Hom T Z\ninst✝³ : CategoryTheory.Limits.HasPushout g₁ g₂\ni₁ : Quiver.Hom W Y\ni₂ : Quiver.Hom X Z\ni₃ : Quiver.Hom S T\neq₁ : Eq (CategoryTheory.CategoryStruct.comp f₁ i₁) (CategoryTheory.CategoryStruct.comp i₃ g₁)\neq₂ : Eq (CategoryTheory.CategoryStruct.comp f₂ i₂) (CategoryTheory.CategoryStruct.comp i₃ g₂)\ninst✝² : CategoryTheory.IsIso i₁\ninst✝¹ : CategoryTheory.IsIso i₂\ninst✝ : CategoryTheory.IsIso i₃\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.pushout.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂)","decl":"instance pushout.map_isIso {W X Y Z S T : C} (f₁ : S ⟶ W) (f₂ : S ⟶ X) [HasPushout f₁ f₂]\n    (g₁ : T ⟶ Y) (g₂ : T ⟶ Z) [HasPushout g₁ g₂] (i₁ : W ⟶ Y) (i₂ : X ⟶ Z) (i₃ : S ⟶ T)\n    (eq₁ : f₁ ≫ i₁ = i₃ ≫ g₁) (eq₂ : f₂ ≫ i₂ = i₃ ≫ g₂) [IsIso i₁] [IsIso i₂] [IsIso i₃] :\n    IsIso (pushout.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂) := by\n  refine ⟨⟨pushout.map _ _ _ _ (inv i₁) (inv i₂) (inv i₃) ?_ ?_, ?_, ?_⟩⟩\n  · rw [IsIso.comp_inv_eq, Category.assoc, eq₁, IsIso.inv_hom_id_assoc]\n  · rw [IsIso.comp_inv_eq, Category.assoc, eq₂, IsIso.inv_hom_id_assoc]\n  · aesop_cat\n  · aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.pullback.mapDesc_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX Y S T S' : C\nf : Quiver.Hom X T\ng : Quiver.Hom Y T\ni : Quiver.Hom T S\ni' : Quiver.Hom S S'\ninst✝³ : CategoryTheory.Limits.HasPullback f g\ninst✝² : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i)\ninst✝¹ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp i i')) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.comp i i'))\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f i) i') (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp g i) i')\n⊢ Eq (CategoryTheory.Limits.pullback.mapDesc f g (CategoryTheory.CategoryStruct.comp i i')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.mapDesc f g i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.mapDesc (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) i') (CategoryTheory.Limits.pullback.congrHom ⋯ ⋯).hom))","decl":"theorem pullback.mapDesc_comp {X Y S T S' : C} (f : X ⟶ T) (g : Y ⟶ T) (i : T ⟶ S) (i' : S ⟶ S')\n    [HasPullback f g] [HasPullback (f ≫ i) (g ≫ i)] [HasPullback (f ≫ i ≫ i') (g ≫ i ≫ i')]\n    [HasPullback ((f ≫ i) ≫ i') ((g ≫ i) ≫ i')] :\n    pullback.mapDesc f g (i ≫ i') = pullback.mapDesc f g i ≫ pullback.mapDesc _ _ i' ≫\n    (pullback.congrHom (Category.assoc _ _ _) (Category.assoc _ _ _)).hom := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.pushout.congrHom_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf₁ f₂ : Quiver.Hom X Y\ng₁ g₂ : Quiver.Hom X Z\nh₁ : Eq f₁ f₂\nh₂ : Eq g₁ g₂\ninst✝¹ : CategoryTheory.Limits.HasPushout f₁ g₁\ninst✝ : CategoryTheory.Limits.HasPushout f₂ g₂\n⊢ Eq (CategoryTheory.Limits.pushout.congrHom h₁ h₂).hom (CategoryTheory.Limits.pushout.map f₁ g₁ f₂ g₂ (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Z) (CategoryTheory.CategoryStruct.id X) ⋯ ⋯)","decl":"/-- If `f₁ = f₂` and `g₁ = g₂`, we may construct a canonical\nisomorphism `pushout f₁ g₁ ≅ pullback f₂ g₂` -/\n@[simps! hom]\ndef pushout.congrHom {X Y Z : C} {f₁ f₂ : X ⟶ Y} {g₁ g₂ : X ⟶ Z} (h₁ : f₁ = f₂) (h₂ : g₁ = g₂)\n    [HasPushout f₁ g₁] [HasPushout f₂ g₂] : pushout f₁ g₁ ≅ pushout f₂ g₂ :=\n  asIso <| pushout.map _ _ _ _ (𝟙 _) (𝟙 _) (𝟙 _) (by simp [h₁]) (by simp [h₂])\n\n"}
{"name":"CategoryTheory.Limits.pushout.congrHom_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf₁ f₂ : Quiver.Hom X Y\ng₁ g₂ : Quiver.Hom X Z\nh₁ : Eq f₁ f₂\nh₂ : Eq g₁ g₂\ninst✝¹ : CategoryTheory.Limits.HasPushout f₁ g₁\ninst✝ : CategoryTheory.Limits.HasPushout f₂ g₂\n⊢ Eq (CategoryTheory.Limits.pushout.congrHom h₁ h₂).inv (CategoryTheory.Limits.pushout.map f₂ g₂ f₁ g₁ (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Z) (CategoryTheory.CategoryStruct.id X) ⋯ ⋯)","decl":"@[simp]\ntheorem pushout.congrHom_inv {X Y Z : C} {f₁ f₂ : X ⟶ Y} {g₁ g₂ : X ⟶ Z} (h₁ : f₁ = f₂)\n    (h₂ : g₁ = g₂) [HasPushout f₁ g₁] [HasPushout f₂ g₂] :\n    (pushout.congrHom h₁ h₂).inv =\n      pushout.map _ _ _ _ (𝟙 _) (𝟙 _) (𝟙 _) (by simp [h₁]) (by simp [h₂]) := by\n  ext <;> simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.pushout.mapLift_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX Y S T S' : C\nf : Quiver.Hom T X\ng : Quiver.Hom T Y\ni : Quiver.Hom S T\ni' : Quiver.Hom S' S\ninst✝³ : CategoryTheory.Limits.HasPushout f g\ninst✝² : CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp i f) (CategoryTheory.CategoryStruct.comp i g)\ninst✝¹ : CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp i' (CategoryTheory.CategoryStruct.comp i f)) (CategoryTheory.CategoryStruct.comp i' (CategoryTheory.CategoryStruct.comp i g))\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp i' i) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp i' i) g)\n⊢ Eq (CategoryTheory.Limits.pushout.mapLift f g (CategoryTheory.CategoryStruct.comp i' i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.congrHom ⋯ ⋯).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.mapLift (CategoryTheory.CategoryStruct.comp i f) (CategoryTheory.CategoryStruct.comp i g) i') (CategoryTheory.Limits.pushout.mapLift f g i)))","decl":"theorem pushout.mapLift_comp {X Y S T S' : C} (f : T ⟶ X) (g : T ⟶ Y) (i : S ⟶ T) (i' : S' ⟶ S)\n    [HasPushout f g] [HasPushout (i ≫ f) (i ≫ g)] [HasPushout (i' ≫ i ≫ f) (i' ≫ i ≫ g)]\n    [HasPushout ((i' ≫ i) ≫ f) ((i' ≫ i) ≫ g)] :\n    pushout.mapLift f g (i' ≫ i) =\n      (pushout.congrHom (Category.assoc _ _ _) (Category.assoc _ _ _)).hom ≫\n        pushout.mapLift _ _ i' ≫ pushout.mapLift f g i := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.pullbackComparison_comp_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (G.map f) (G.map g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackComparison G f g) (CategoryTheory.Limits.pullback.fst (G.map f) (G.map g))) (G.map (CategoryTheory.Limits.pullback.fst f g))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackComparison_comp_fst (f : X ⟶ Z) (g : Y ⟶ Z) [HasPullback f g]\n    [HasPullback (G.map f) (G.map g)] :\n    pullbackComparison G f g ≫ pullback.fst _ _ = G.map (pullback.fst f g) :=\n  pullback.lift_fst _ _ _\n\n"}
{"name":"CategoryTheory.Limits.pullbackComparison_comp_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y Z✝ : C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (G.map f) (G.map g)\nZ : D\nh : Quiver.Hom (G.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackComparison G f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (G.map f) (G.map g)) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.pullback.fst f g)) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackComparison_comp_fst (f : X ⟶ Z) (g : Y ⟶ Z) [HasPullback f g]\n    [HasPullback (G.map f) (G.map g)] :\n    pullbackComparison G f g ≫ pullback.fst _ _ = G.map (pullback.fst f g) :=\n  pullback.lift_fst _ _ _\n\n"}
{"name":"CategoryTheory.Limits.pullbackComparison_comp_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y Z✝ : C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (G.map f) (G.map g)\nZ : D\nh : Quiver.Hom (G.obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackComparison G f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (G.map f) (G.map g)) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.pullback.snd f g)) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackComparison_comp_snd (f : X ⟶ Z) (g : Y ⟶ Z) [HasPullback f g]\n    [HasPullback (G.map f) (G.map g)] :\n    pullbackComparison G f g ≫ pullback.snd _ _ = G.map (pullback.snd f g):=\n  pullback.lift_snd _ _ _\n\n"}
{"name":"CategoryTheory.Limits.pullbackComparison_comp_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (G.map f) (G.map g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackComparison G f g) (CategoryTheory.Limits.pullback.snd (G.map f) (G.map g))) (G.map (CategoryTheory.Limits.pullback.snd f g))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackComparison_comp_snd (f : X ⟶ Z) (g : Y ⟶ Z) [HasPullback f g]\n    [HasPullback (G.map f) (G.map g)] :\n    pullbackComparison G f g ≫ pullback.snd _ _ = G.map (pullback.snd f g):=\n  pullback.lift_snd _ _ _\n\n"}
{"name":"CategoryTheory.Limits.map_lift_pullbackComparison","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (G.map f) (G.map g)\nW : C\nh : Quiver.Hom W X\nk : Quiver.Hom W Y\nw : Eq (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp k g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.pullback.lift h k w)) (CategoryTheory.Limits.pullbackComparison G f g)) (CategoryTheory.Limits.pullback.lift (G.map h) (G.map k) ⋯)","decl":"@[reassoc (attr := simp)]\ntheorem map_lift_pullbackComparison (f : X ⟶ Z) (g : Y ⟶ Z) [HasPullback f g]\n    [HasPullback (G.map f) (G.map g)] {W : C} {h : W ⟶ X} {k : W ⟶ Y} (w : h ≫ f = k ≫ g) :\n    G.map (pullback.lift _ _ w) ≫ pullbackComparison G f g =\n      pullback.lift (G.map h) (G.map k) (by simp only [← G.map_comp, w]) := by\n  ext <;> simp [← G.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.map_lift_pullbackComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y Z✝ : C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (G.map f) (G.map g)\nW : C\nh✝ : Quiver.Hom W X\nk : Quiver.Hom W Y\nw : Eq (CategoryTheory.CategoryStruct.comp h✝ f) (CategoryTheory.CategoryStruct.comp k g)\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.pullback (G.map f) (G.map g)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.pullback.lift h✝ k w)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackComparison G f g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.lift (G.map h✝) (G.map k) ⋯) h)","decl":"@[reassoc (attr := simp)]\ntheorem map_lift_pullbackComparison (f : X ⟶ Z) (g : Y ⟶ Z) [HasPullback f g]\n    [HasPullback (G.map f) (G.map g)] {W : C} {h : W ⟶ X} {k : W ⟶ Y} (w : h ≫ f = k ≫ g) :\n    G.map (pullback.lift _ _ w) ≫ pullbackComparison G f g =\n      pullback.lift (G.map h) (G.map k) (by simp only [← G.map_comp, w]) := by\n  ext <;> simp [← G.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.inl_comp_pushoutComparison","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (G.map f) (G.map g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (G.map f) (G.map g)) (CategoryTheory.Limits.pushoutComparison G f g)) (G.map (CategoryTheory.Limits.pushout.inl f g))","decl":"@[reassoc (attr := simp)]\ntheorem inl_comp_pushoutComparison (f : X ⟶ Y) (g : X ⟶ Z) [HasPushout f g]\n    [HasPushout (G.map f) (G.map g)] : pushout.inl _ _ ≫ pushoutComparison G f g =\n      G.map (pushout.inl _ _) :=\n  pushout.inl_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.inl_comp_pushoutComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y Z✝ : C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z✝\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (G.map f) (G.map g)\nZ : D\nh : Quiver.Hom (G.obj (CategoryTheory.Limits.pushout f g)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (G.map f) (G.map g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutComparison G f g) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.pushout.inl f g)) h)","decl":"@[reassoc (attr := simp)]\ntheorem inl_comp_pushoutComparison (f : X ⟶ Y) (g : X ⟶ Z) [HasPushout f g]\n    [HasPushout (G.map f) (G.map g)] : pushout.inl _ _ ≫ pushoutComparison G f g =\n      G.map (pushout.inl _ _) :=\n  pushout.inl_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.inr_comp_pushoutComparison","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (G.map f) (G.map g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr (G.map f) (G.map g)) (CategoryTheory.Limits.pushoutComparison G f g)) (G.map (CategoryTheory.Limits.pushout.inr f g))","decl":"@[reassoc (attr := simp)]\ntheorem inr_comp_pushoutComparison (f : X ⟶ Y) (g : X ⟶ Z) [HasPushout f g]\n    [HasPushout (G.map f) (G.map g)] : pushout.inr _ _ ≫ pushoutComparison G f g =\n      G.map (pushout.inr _ _) :=\n  pushout.inr_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.inr_comp_pushoutComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y Z✝ : C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z✝\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (G.map f) (G.map g)\nZ : D\nh : Quiver.Hom (G.obj (CategoryTheory.Limits.pushout f g)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr (G.map f) (G.map g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutComparison G f g) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.pushout.inr f g)) h)","decl":"@[reassoc (attr := simp)]\ntheorem inr_comp_pushoutComparison (f : X ⟶ Y) (g : X ⟶ Z) [HasPushout f g]\n    [HasPushout (G.map f) (G.map g)] : pushout.inr _ _ ≫ pushoutComparison G f g =\n      G.map (pushout.inr _ _) :=\n  pushout.inr_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.pushoutComparison_map_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y Z✝ : C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z✝\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (G.map f) (G.map g)\nW : C\nh✝ : Quiver.Hom Y W\nk : Quiver.Hom Z✝ W\nw : Eq (CategoryTheory.CategoryStruct.comp f h✝) (CategoryTheory.CategoryStruct.comp g k)\nZ : D\nh : Quiver.Hom (G.obj W) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutComparison G f g) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.pushout.desc h✝ k w)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.desc (G.map h✝) (G.map k) ⋯) h)","decl":"@[reassoc (attr := simp)]\ntheorem pushoutComparison_map_desc (f : X ⟶ Y) (g : X ⟶ Z) [HasPushout f g]\n    [HasPushout (G.map f) (G.map g)] {W : C} {h : Y ⟶ W} {k : Z ⟶ W} (w : f ≫ h = g ≫ k) :\n    pushoutComparison G f g ≫ G.map (pushout.desc _ _ w) =\n      pushout.desc (G.map h) (G.map k) (by simp only [← G.map_comp, w]) := by\n  ext <;> simp [← G.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.pushoutComparison_map_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (G.map f) (G.map g)\nW : C\nh : Quiver.Hom Y W\nk : Quiver.Hom Z W\nw : Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g k)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutComparison G f g) (G.map (CategoryTheory.Limits.pushout.desc h k w))) (CategoryTheory.Limits.pushout.desc (G.map h) (G.map k) ⋯)","decl":"@[reassoc (attr := simp)]\ntheorem pushoutComparison_map_desc (f : X ⟶ Y) (g : X ⟶ Z) [HasPushout f g]\n    [HasPushout (G.map f) (G.map g)] {W : C} {h : Y ⟶ W} {k : Z ⟶ W} (w : f ≫ h = g ≫ k) :\n    pushoutComparison G f g ≫ G.map (pushout.desc _ _ w) =\n      pushout.desc (G.map h) (G.map k) (by simp only [← G.map_comp, w]) := by\n  ext <;> simp [← G.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.hasPullback_symmetry","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Limits.HasPullback f g\n⊢ CategoryTheory.Limits.HasPullback g f","decl":"/-- Making this a global instance would make the typeclass search go in an infinite loop. -/\ntheorem hasPullback_symmetry [HasPullback f g] : HasPullback g f :=\n  ⟨⟨⟨_, PullbackCone.flipIsLimit (pullbackIsPullback f g)⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.pullbackSymmetry_hom_comp_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Limits.HasPullback f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry f g).hom (CategoryTheory.Limits.pullback.fst g f)) (CategoryTheory.Limits.pullback.snd f g)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackSymmetry_hom_comp_fst [HasPullback f g] :\n    (pullbackSymmetry f g).hom ≫ pullback.fst g f = pullback.snd f g := by simp [pullbackSymmetry]\n\n"}
{"name":"CategoryTheory.Limits.pullbackSymmetry_hom_comp_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : CategoryTheory.Limits.HasPullback f g\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry f g).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst g f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackSymmetry_hom_comp_fst [HasPullback f g] :\n    (pullbackSymmetry f g).hom ≫ pullback.fst g f = pullback.snd f g := by simp [pullbackSymmetry]\n\n"}
{"name":"CategoryTheory.Limits.pullbackSymmetry_hom_comp_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : CategoryTheory.Limits.HasPullback f g\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry f g).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd g f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackSymmetry_hom_comp_snd [HasPullback f g] :\n    (pullbackSymmetry f g).hom ≫ pullback.snd g f = pullback.fst f g := by simp [pullbackSymmetry]\n\n"}
{"name":"CategoryTheory.Limits.pullbackSymmetry_hom_comp_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Limits.HasPullback f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry f g).hom (CategoryTheory.Limits.pullback.snd g f)) (CategoryTheory.Limits.pullback.fst f g)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackSymmetry_hom_comp_snd [HasPullback f g] :\n    (pullbackSymmetry f g).hom ≫ pullback.snd g f = pullback.fst f g := by simp [pullbackSymmetry]\n\n"}
{"name":"CategoryTheory.Limits.pullbackSymmetry_inv_comp_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : CategoryTheory.Limits.HasPullback f g\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd g f) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackSymmetry_inv_comp_fst [HasPullback f g] :\n    (pullbackSymmetry f g).inv ≫ pullback.fst f g = pullback.snd g f := by simp [Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.pullbackSymmetry_inv_comp_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Limits.HasPullback f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry f g).inv (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.Limits.pullback.snd g f)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackSymmetry_inv_comp_fst [HasPullback f g] :\n    (pullbackSymmetry f g).inv ≫ pullback.fst f g = pullback.snd g f := by simp [Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.pullbackSymmetry_inv_comp_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Limits.HasPullback f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry f g).inv (CategoryTheory.Limits.pullback.snd f g)) (CategoryTheory.Limits.pullback.fst g f)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackSymmetry_inv_comp_snd [HasPullback f g] :\n    (pullbackSymmetry f g).inv ≫ pullback.snd f g = pullback.fst g f := by simp [Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.pullbackSymmetry_inv_comp_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : CategoryTheory.Limits.HasPullback f g\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst g f) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackSymmetry_inv_comp_snd [HasPullback f g] :\n    (pullbackSymmetry f g).inv ≫ pullback.snd f g = pullback.fst g f := by simp [Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.hasPushout_symmetry","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst✝ : CategoryTheory.Limits.HasPushout f g\n⊢ CategoryTheory.Limits.HasPushout g f","decl":"/-- Making this a global instance would make the typeclass search go in an infinite loop. -/\ntheorem hasPushout_symmetry [HasPushout f g] : HasPushout g f :=\n  ⟨⟨⟨_, PushoutCocone.flipIsColimit (pushoutIsPushout f g)⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.inl_comp_pushoutSymmetry_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z✝ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z✝\ninst✝ : CategoryTheory.Limits.HasPushout f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout g f) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutSymmetry f g).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr g f) h)","decl":"@[reassoc (attr := simp)]\ntheorem inl_comp_pushoutSymmetry_hom [HasPushout f g] :\n    pushout.inl _ _ ≫ (pushoutSymmetry f g).hom = pushout.inr _ _ :=\n  (colimit.isColimit (span f g)).comp_coconePointUniqueUpToIso_hom\n    (PushoutCocone.flipIsColimit (pushoutIsPushout g f)) _\n\n"}
{"name":"CategoryTheory.Limits.inl_comp_pushoutSymmetry_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst✝ : CategoryTheory.Limits.HasPushout f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) (CategoryTheory.Limits.pushoutSymmetry f g).hom) (CategoryTheory.Limits.pushout.inr g f)","decl":"@[reassoc (attr := simp)]\ntheorem inl_comp_pushoutSymmetry_hom [HasPushout f g] :\n    pushout.inl _ _ ≫ (pushoutSymmetry f g).hom = pushout.inr _ _ :=\n  (colimit.isColimit (span f g)).comp_coconePointUniqueUpToIso_hom\n    (PushoutCocone.flipIsColimit (pushoutIsPushout g f)) _\n\n"}
{"name":"CategoryTheory.Limits.inr_comp_pushoutSymmetry_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst✝ : CategoryTheory.Limits.HasPushout f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) (CategoryTheory.Limits.pushoutSymmetry f g).hom) (CategoryTheory.Limits.pushout.inl g f)","decl":"@[reassoc (attr := simp)]\ntheorem inr_comp_pushoutSymmetry_hom [HasPushout f g] :\n    pushout.inr _ _ ≫ (pushoutSymmetry f g).hom = pushout.inl _ _ :=\n  (colimit.isColimit (span f g)).comp_coconePointUniqueUpToIso_hom\n    (PushoutCocone.flipIsColimit (pushoutIsPushout g f)) _\n\n"}
{"name":"CategoryTheory.Limits.inr_comp_pushoutSymmetry_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z✝ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z✝\ninst✝ : CategoryTheory.Limits.HasPushout f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout g f) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutSymmetry f g).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl g f) h)","decl":"@[reassoc (attr := simp)]\ntheorem inr_comp_pushoutSymmetry_hom [HasPushout f g] :\n    pushout.inr _ _ ≫ (pushoutSymmetry f g).hom = pushout.inl _ _ :=\n  (colimit.isColimit (span f g)).comp_coconePointUniqueUpToIso_hom\n    (PushoutCocone.flipIsColimit (pushoutIsPushout g f)) _\n\n"}
{"name":"CategoryTheory.Limits.inl_comp_pushoutSymmetry_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z✝ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z✝\ninst✝ : CategoryTheory.Limits.HasPushout f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout f g) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl g f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutSymmetry f g).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) h)","decl":"@[reassoc (attr := simp)]\ntheorem inl_comp_pushoutSymmetry_inv [HasPushout f g] :\n    pushout.inl _ _ ≫ (pushoutSymmetry f g).inv = pushout.inr _ _ := by simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.inl_comp_pushoutSymmetry_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst✝ : CategoryTheory.Limits.HasPushout f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl g f) (CategoryTheory.Limits.pushoutSymmetry f g).inv) (CategoryTheory.Limits.pushout.inr f g)","decl":"@[reassoc (attr := simp)]\ntheorem inl_comp_pushoutSymmetry_inv [HasPushout f g] :\n    pushout.inl _ _ ≫ (pushoutSymmetry f g).inv = pushout.inr _ _ := by simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.inr_comp_pushoutSymmetry_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z✝ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z✝\ninst✝ : CategoryTheory.Limits.HasPushout f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout f g) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr g f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutSymmetry f g).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) h)","decl":"@[reassoc (attr := simp)]\ntheorem inr_comp_pushoutSymmetry_inv [HasPushout f g] :\n    pushout.inr _ _ ≫ (pushoutSymmetry f g).inv = pushout.inl _ _ := by simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.inr_comp_pushoutSymmetry_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst✝ : CategoryTheory.Limits.HasPushout f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr g f) (CategoryTheory.Limits.pushoutSymmetry f g).inv) (CategoryTheory.Limits.pushout.inl f g)","decl":"@[reassoc (attr := simp)]\ntheorem inr_comp_pushoutSymmetry_inv [HasPushout f g] :\n    pushout.inr _ _ ≫ (pushoutSymmetry f g).inv = pushout.inl _ _ := by simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.hasPullbacks_of_hasLimit_cospan","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ {X Y Z : C} {f : Quiver.Hom X Z} {g : Quiver.Hom Y Z}, CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan f g)\n⊢ CategoryTheory.Limits.HasPullbacks C","decl":"/-- If `C` has all limits of diagrams `cospan f g`, then it has all pullbacks -/\ntheorem hasPullbacks_of_hasLimit_cospan\n    [∀ {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z}, HasLimit (cospan f g)] : HasPullbacks C :=\n  { has_limit := fun F => hasLimitOfIso (diagramIsoCospan F).symm }\n\n"}
{"name":"CategoryTheory.Limits.hasPushouts_of_hasColimit_span","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ {X Y Z : C} {f : Quiver.Hom X Y} {g : Quiver.Hom X Z}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.span f g)\n⊢ CategoryTheory.Limits.HasPushouts C","decl":"/-- If `C` has all colimits of diagrams `span f g`, then it has all pushouts -/\ntheorem hasPushouts_of_hasColimit_span\n    [∀ {X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z}, HasColimit (span f g)] : HasPushouts C :=\n  { has_colimit := fun F => hasColimitOfIso (diagramIsoSpan F) }\n\n"}
{"name":"CategoryTheory.Limits.walkingSpanOpEquiv_inverse_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X : CategoryTheory.Limits.WidePullbackShape CategoryTheory.Limits.WalkingPair\n⊢ Eq (CategoryTheory.Limits.walkingSpanOpEquiv.inverse.obj X) { unop := X }","decl":"/-- The duality equivalence `WalkingSpanᵒᵖ ≌ WalkingCospan` -/\n@[simps!]\ndef walkingSpanOpEquiv : WalkingSpanᵒᵖ ≌ WalkingCospan :=\n  widePushoutShapeOpEquiv _\n\n"}
{"name":"CategoryTheory.Limits.walkingSpanOpEquiv_unitIso_inv_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X : Opposite (CategoryTheory.Limits.WidePushoutShape CategoryTheory.Limits.WalkingPair)\n⊢ Eq (CategoryTheory.Limits.walkingSpanOpEquiv.unitIso.inv.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The duality equivalence `WalkingSpanᵒᵖ ≌ WalkingCospan` -/\n@[simps!]\ndef walkingSpanOpEquiv : WalkingSpanᵒᵖ ≌ WalkingCospan :=\n  widePushoutShapeOpEquiv _\n\n"}
{"name":"CategoryTheory.Limits.walkingSpanOpEquiv_counitIso_inv_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X : CategoryTheory.Limits.WidePullbackShape CategoryTheory.Limits.WalkingPair\n⊢ Eq (CategoryTheory.Limits.walkingSpanOpEquiv.counitIso.inv.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The duality equivalence `WalkingSpanᵒᵖ ≌ WalkingCospan` -/\n@[simps!]\ndef walkingSpanOpEquiv : WalkingSpanᵒᵖ ≌ WalkingCospan :=\n  widePushoutShapeOpEquiv _\n\n"}
{"name":"CategoryTheory.Limits.walkingSpanOpEquiv_unitIso_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X : Opposite (CategoryTheory.Limits.WidePushoutShape CategoryTheory.Limits.WalkingPair)\n⊢ Eq (CategoryTheory.Limits.walkingSpanOpEquiv.unitIso.hom.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The duality equivalence `WalkingSpanᵒᵖ ≌ WalkingCospan` -/\n@[simps!]\ndef walkingSpanOpEquiv : WalkingSpanᵒᵖ ≌ WalkingCospan :=\n  widePushoutShapeOpEquiv _\n\n"}
{"name":"CategoryTheory.Limits.walkingSpanOpEquiv_functor_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X : Opposite (CategoryTheory.Limits.WidePushoutShape CategoryTheory.Limits.WalkingPair)\n⊢ Eq (CategoryTheory.Limits.walkingSpanOpEquiv.functor.obj X) (Opposite.unop X)","decl":"/-- The duality equivalence `WalkingSpanᵒᵖ ≌ WalkingCospan` -/\n@[simps!]\ndef walkingSpanOpEquiv : WalkingSpanᵒᵖ ≌ WalkingCospan :=\n  widePushoutShapeOpEquiv _\n\n"}
{"name":"CategoryTheory.Limits.walkingSpanOpEquiv_counitIso_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X : CategoryTheory.Limits.WidePullbackShape CategoryTheory.Limits.WalkingPair\n⊢ Eq (CategoryTheory.Limits.walkingSpanOpEquiv.counitIso.hom.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The duality equivalence `WalkingSpanᵒᵖ ≌ WalkingCospan` -/\n@[simps!]\ndef walkingSpanOpEquiv : WalkingSpanᵒᵖ ≌ WalkingCospan :=\n  widePushoutShapeOpEquiv _\n\n"}
{"name":"CategoryTheory.Limits.walkingSpanOpEquiv_functor_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X✝ Y✝ : Opposite (CategoryTheory.Limits.WidePushoutShape CategoryTheory.Limits.WalkingPair)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Limits.walkingSpanOpEquiv.functor.map f) (CategoryTheory.Limits.widePushoutShapeOpMap CategoryTheory.Limits.WalkingPair (Opposite.unop Y✝) (Opposite.unop X✝) f.unop).unop","decl":"/-- The duality equivalence `WalkingSpanᵒᵖ ≌ WalkingCospan` -/\n@[simps!]\ndef walkingSpanOpEquiv : WalkingSpanᵒᵖ ≌ WalkingCospan :=\n  widePushoutShapeOpEquiv _\n\n"}
{"name":"CategoryTheory.Limits.walkingSpanOpEquiv_inverse_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X₁ X₂ : CategoryTheory.Limits.WidePullbackShape CategoryTheory.Limits.WalkingPair\na✝ : Quiver.Hom X₁ X₂\n⊢ Eq (CategoryTheory.Limits.walkingSpanOpEquiv.inverse.map a✝) (CategoryTheory.Limits.widePullbackShapeOpMap CategoryTheory.Limits.WalkingPair X₁ X₂ a✝)","decl":"/-- The duality equivalence `WalkingSpanᵒᵖ ≌ WalkingCospan` -/\n@[simps!]\ndef walkingSpanOpEquiv : WalkingSpanᵒᵖ ≌ WalkingCospan :=\n  widePushoutShapeOpEquiv _\n\n"}
{"name":"CategoryTheory.Limits.walkingCospanOpEquiv_inverse_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X Y : CategoryTheory.Limits.WidePushoutShape CategoryTheory.Limits.WalkingPair\na✝ : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.Limits.walkingCospanOpEquiv.inverse.map a✝) (CategoryTheory.Limits.widePushoutShapeOpMap CategoryTheory.Limits.WalkingPair X Y a✝)","decl":"/-- The duality equivalence `WalkingCospanᵒᵖ ≌ WalkingSpan` -/\n@[simps!]\ndef walkingCospanOpEquiv : WalkingCospanᵒᵖ ≌ WalkingSpan :=\n  widePullbackShapeOpEquiv _\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.walkingCospanOpEquiv_functor_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X✝ Y✝ : Opposite (CategoryTheory.Limits.WidePullbackShape CategoryTheory.Limits.WalkingPair)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Limits.walkingCospanOpEquiv.functor.map f) (CategoryTheory.Limits.widePullbackShapeOpMap CategoryTheory.Limits.WalkingPair (Opposite.unop Y✝) (Opposite.unop X✝) f.unop).unop","decl":"/-- The duality equivalence `WalkingCospanᵒᵖ ≌ WalkingSpan` -/\n@[simps!]\ndef walkingCospanOpEquiv : WalkingCospanᵒᵖ ≌ WalkingSpan :=\n  widePullbackShapeOpEquiv _\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.walkingCospanOpEquiv_functor_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X : Opposite (CategoryTheory.Limits.WidePullbackShape CategoryTheory.Limits.WalkingPair)\n⊢ Eq (CategoryTheory.Limits.walkingCospanOpEquiv.functor.obj X) (Opposite.unop X)","decl":"/-- The duality equivalence `WalkingCospanᵒᵖ ≌ WalkingSpan` -/\n@[simps!]\ndef walkingCospanOpEquiv : WalkingCospanᵒᵖ ≌ WalkingSpan :=\n  widePullbackShapeOpEquiv _\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.walkingCospanOpEquiv_counitIso_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X : CategoryTheory.Limits.WidePushoutShape CategoryTheory.Limits.WalkingPair\n⊢ Eq (CategoryTheory.Limits.walkingCospanOpEquiv.counitIso.hom.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The duality equivalence `WalkingCospanᵒᵖ ≌ WalkingSpan` -/\n@[simps!]\ndef walkingCospanOpEquiv : WalkingCospanᵒᵖ ≌ WalkingSpan :=\n  widePullbackShapeOpEquiv _\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.walkingCospanOpEquiv_unitIso_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X : Opposite (CategoryTheory.Limits.WidePullbackShape CategoryTheory.Limits.WalkingPair)\n⊢ Eq (CategoryTheory.Limits.walkingCospanOpEquiv.unitIso.hom.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The duality equivalence `WalkingCospanᵒᵖ ≌ WalkingSpan` -/\n@[simps!]\ndef walkingCospanOpEquiv : WalkingCospanᵒᵖ ≌ WalkingSpan :=\n  widePullbackShapeOpEquiv _\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.walkingCospanOpEquiv_unitIso_inv_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X : Opposite (CategoryTheory.Limits.WidePullbackShape CategoryTheory.Limits.WalkingPair)\n⊢ Eq (CategoryTheory.Limits.walkingCospanOpEquiv.unitIso.inv.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The duality equivalence `WalkingCospanᵒᵖ ≌ WalkingSpan` -/\n@[simps!]\ndef walkingCospanOpEquiv : WalkingCospanᵒᵖ ≌ WalkingSpan :=\n  widePullbackShapeOpEquiv _\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.walkingCospanOpEquiv_inverse_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X : CategoryTheory.Limits.WidePushoutShape CategoryTheory.Limits.WalkingPair\n⊢ Eq (CategoryTheory.Limits.walkingCospanOpEquiv.inverse.obj X) { unop := X }","decl":"/-- The duality equivalence `WalkingCospanᵒᵖ ≌ WalkingSpan` -/\n@[simps!]\ndef walkingCospanOpEquiv : WalkingCospanᵒᵖ ≌ WalkingSpan :=\n  widePullbackShapeOpEquiv _\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.walkingCospanOpEquiv_counitIso_inv_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"X : CategoryTheory.Limits.WidePushoutShape CategoryTheory.Limits.WalkingPair\n⊢ Eq (CategoryTheory.Limits.walkingCospanOpEquiv.counitIso.inv.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The duality equivalence `WalkingCospanᵒᵖ ≌ WalkingSpan` -/\n@[simps!]\ndef walkingCospanOpEquiv : WalkingCospanᵒᵖ ≌ WalkingSpan :=\n  widePullbackShapeOpEquiv _\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"D : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} D\ninst✝ : CategoryTheory.Limits.HasWidePullbacks D\n⊢ CategoryTheory.Limits.HasPullbacks D","decl":"/-- Having wide pullback at any universe level implies having binary pullbacks. -/\ninstance (priority := 100) hasPullbacks_of_hasWidePullbacks (D : Type u) [Category.{v} D]\n    [HasWidePullbacks.{w} D] : HasPullbacks.{v,u} D :=\n  hasWidePullbacks_shrink WalkingPair\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.hasPushouts_of_hasWidePushouts","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback","initialProofState":"D : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} D\ninst✝ : CategoryTheory.Limits.HasWidePushouts D\n⊢ CategoryTheory.Limits.HasPushouts D","decl":"/-- Having wide pushout at any universe level implies having binary pushouts. -/\ninstance (priority := 100) hasPushouts_of_hasWidePushouts (D : Type u) [Category.{v} D]\n    [HasWidePushouts.{w} D] : HasPushouts.{v,u} D :=\n  hasWidePushouts_shrink WalkingPair\n\n"}
