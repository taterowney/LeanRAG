{"name":"SimpleGraph.IsTuranMaximal.le_iff_eq","module":"Mathlib.Combinatorics.SimpleGraph.Turan","initialProofState":"V : Type u_1\ninst✝¹ : Fintype V\nG : SimpleGraph V\ninst✝ : DecidableRel G.Adj\nr : Nat\nH : SimpleGraph V\nhG : G.IsTuranMaximal r\nhH : H.CliqueFree (HAdd.hAdd r 1)\n⊢ Iff (LE.le G H) (Eq G H)","decl":"lemma IsTuranMaximal.le_iff_eq (hG : G.IsTuranMaximal r) (hH : H.CliqueFree (r + 1)) :\n    G ≤ H ↔ G = H := by\n  classical exact ⟨fun hGH ↦ edgeFinset_inj.1 <| eq_of_subset_of_card_le\n    (edgeFinset_subset_edgeFinset.2 hGH) (hG.2 _ hH), le_of_eq⟩\n\n"}
{"name":"SimpleGraph.turanGraph_zero","module":"Mathlib.Combinatorics.SimpleGraph.Turan","initialProofState":"n : Nat\n⊢ Eq (SimpleGraph.turanGraph n 0) Top.top","decl":"@[simp]\nlemma turanGraph_zero : turanGraph n 0 = ⊤ := by\n  ext a b; simp_rw [turanGraph, top_adj, Nat.mod_zero, not_iff_not, Fin.val_inj]\n\n"}
{"name":"SimpleGraph.turanGraph_eq_top","module":"Mathlib.Combinatorics.SimpleGraph.Turan","initialProofState":"n r : Nat\n⊢ Iff (Eq (SimpleGraph.turanGraph n r) Top.top) (Or (Eq r 0) (LE.le n r))","decl":"@[simp]\ntheorem turanGraph_eq_top : turanGraph n r = ⊤ ↔ r = 0 ∨ n ≤ r := by\n  simp_rw [SimpleGraph.ext_iff, funext_iff, turanGraph, top_adj, eq_iff_iff, not_iff_not]\n  refine ⟨fun h ↦ ?_, ?_⟩\n  · contrapose! h\n    use ⟨0, (Nat.pos_of_ne_zero h.1).trans h.2⟩, ⟨r, h.2⟩\n    simp [h.1.symm]\n  · rintro (rfl | h) a b\n    · simp [Fin.val_inj]\n    · rw [Nat.mod_eq_of_lt (a.2.trans_le h), Nat.mod_eq_of_lt (b.2.trans_le h), Fin.val_inj]\n\n"}
{"name":"SimpleGraph.turanGraph_cliqueFree","module":"Mathlib.Combinatorics.SimpleGraph.Turan","initialProofState":"n r : Nat\nhr : LT.lt 0 r\n⊢ (SimpleGraph.turanGraph n r).CliqueFree (HAdd.hAdd r 1)","decl":"theorem turanGraph_cliqueFree (hr : 0 < r) : (turanGraph n r).CliqueFree (r + 1) := by\n  rw [cliqueFree_iff]\n  by_contra h\n  rw [not_isEmpty_iff] at h\n  obtain ⟨f, ha⟩ := h\n  simp only [turanGraph, top_adj] at ha\n  obtain ⟨x, y, d, c⟩ := Fintype.exists_ne_map_eq_of_card_lt (fun x ↦\n    (⟨(f x).1 % r, Nat.mod_lt _ hr⟩ : Fin r)) (by simp)\n  simp only [Fin.mk.injEq] at c\n  exact absurd c ((@ha x y).mpr d)\n\n"}
{"name":"SimpleGraph.not_cliqueFree_of_isTuranMaximal","module":"Mathlib.Combinatorics.SimpleGraph.Turan","initialProofState":"V : Type u_1\ninst✝¹ : Fintype V\nG : SimpleGraph V\ninst✝ : DecidableRel G.Adj\nr : Nat\nhn : LE.le r (Fintype.card V)\nhG : G.IsTuranMaximal r\n⊢ Not (G.CliqueFree r)","decl":"/-- An `r + 1`-cliquefree Turán-maximal graph is _not_ `r`-cliquefree\nif it can accommodate such a clique. -/\ntheorem not_cliqueFree_of_isTuranMaximal (hn : r ≤ Fintype.card V) (hG : G.IsTuranMaximal r) :\n    ¬G.CliqueFree r := by\n  rintro h\n  obtain ⟨K, _, rfl⟩ := exists_subset_card_eq hn\n  obtain ⟨a, -, b, -, hab, hGab⟩ : ∃ a ∈ K, ∃ b ∈ K, a ≠ b ∧ ¬ G.Adj a b := by\n    simpa only [isNClique_iff, IsClique, Set.Pairwise, mem_coe, ne_eq, and_true, not_forall,\n      exists_prop, exists_and_right] using h K\n  exact hGab <| le_sup_right.trans_eq ((hG.le_iff_eq <| h.sup_edge _ _).1 le_sup_left).symm <|\n    (edge_adj ..).2 ⟨Or.inl ⟨rfl, rfl⟩, hab⟩\n\n"}
{"name":"SimpleGraph.exists_isTuranMaximal","module":"Mathlib.Combinatorics.SimpleGraph.Turan","initialProofState":"V : Type u_1\ninst✝ : Fintype V\nr : Nat\nhr : LT.lt 0 r\n⊢ Exists fun H => Exists fun x => H.IsTuranMaximal r","decl":"lemma exists_isTuranMaximal (hr : 0 < r):\n    ∃ H : SimpleGraph V, ∃ _ : DecidableRel H.Adj, H.IsTuranMaximal r := by\n  classical\n  let c := {H : SimpleGraph V | H.CliqueFree (r + 1)}\n  have cn : c.toFinset.Nonempty := ⟨⊥, by\n    simp only [Set.toFinset_setOf, mem_filter, mem_univ, true_and, c]\n    exact cliqueFree_bot (by omega)⟩\n  obtain ⟨S, Sm, Sl⟩ := exists_max_image c.toFinset (#·.edgeFinset) cn\n  use S, inferInstance\n  rw [Set.mem_toFinset] at Sm\n  refine ⟨Sm, fun I _ cf ↦ ?_⟩\n  by_cases Im : I ∈ c.toFinset\n  · convert Sl I Im\n  · rw [Set.mem_toFinset] at Im\n    contradiction\n\n"}
{"name":"SimpleGraph.IsTuranMaximal.degree_eq_of_not_adj","module":"Mathlib.Combinatorics.SimpleGraph.Turan","initialProofState":"V : Type u_1\ninst✝¹ : Fintype V\nG : SimpleGraph V\ninst✝ : DecidableRel G.Adj\nr : Nat\ns t : V\nh : G.IsTuranMaximal r\nhn : Not (G.Adj s t)\n⊢ Eq (G.degree s) (G.degree t)","decl":"/-- In a Turán-maximal graph, non-adjacent vertices have the same degree. -/\nlemma degree_eq_of_not_adj (h : G.IsTuranMaximal r) (hn : ¬G.Adj s t) :\n    G.degree s = G.degree t := by\n  rw [IsTuranMaximal] at h; contrapose! h; intro cf\n  wlog hd : G.degree t < G.degree s generalizing G t s\n  · replace hd : G.degree s < G.degree t := lt_of_le_of_ne (le_of_not_lt hd) h\n    exact this (by rwa [adj_comm] at hn) hd.ne' cf hd\n  classical\n  use G.replaceVertex s t, inferInstance, cf.replaceVertex s t\n  have := G.card_edgeFinset_replaceVertex_of_not_adj hn\n  omega\n\n"}
{"name":"SimpleGraph.IsTuranMaximal.not_adj_trans","module":"Mathlib.Combinatorics.SimpleGraph.Turan","initialProofState":"V : Type u_1\ninst✝¹ : Fintype V\nG : SimpleGraph V\ninst✝ : DecidableRel G.Adj\nr : Nat\ns t u : V\nh : G.IsTuranMaximal r\nhts : Not (G.Adj t s)\nhsu : Not (G.Adj s u)\n⊢ Not (G.Adj t u)","decl":"/-- In a Turán-maximal graph, non-adjacency is transitive. -/\nlemma not_adj_trans (h : G.IsTuranMaximal r) (hts : ¬G.Adj t s) (hsu : ¬G.Adj s u) :\n    ¬G.Adj t u := by\n  have hst : ¬G.Adj s t := fun a ↦ hts a.symm\n  have dst := h.degree_eq_of_not_adj hst\n  have dsu := h.degree_eq_of_not_adj hsu\n  rw [IsTuranMaximal] at h; contrapose! h; intro cf\n  classical\n  use (G.replaceVertex s t).replaceVertex s u, inferInstance,\n    (cf.replaceVertex s t).replaceVertex s u\n  have nst : s ≠ t := fun a ↦ hsu (a ▸ h)\n  have ntu : t ≠ u := G.ne_of_adj h\n  have := (G.adj_replaceVertex_iff_of_ne s nst ntu.symm).not.mpr hsu\n  rw [card_edgeFinset_replaceVertex_of_not_adj _ this,\n    card_edgeFinset_replaceVertex_of_not_adj _ hst, dst, Nat.add_sub_cancel]\n  have l1 : (G.replaceVertex s t).degree s = G.degree s := by\n    unfold degree; congr 1; ext v\n    simp only [mem_neighborFinset, SimpleGraph.irrefl, ite_self]\n    by_cases eq : v = t\n    · simpa only [eq, not_adj_replaceVertex_same, false_iff]\n    · rw [G.adj_replaceVertex_iff_of_ne s nst eq]\n  have l2 : (G.replaceVertex s t).degree u = G.degree u - 1 := by\n    rw [degree, degree, ← card_singleton t, ← card_sdiff (by simp [h.symm])]\n    congr 1; ext v\n    simp only [mem_neighborFinset, mem_sdiff, mem_singleton, replaceVertex]\n    split_ifs <;> simp_all [adj_comm]\n  have l3 : 0 < G.degree u := by rw [G.degree_pos_iff_exists_adj u]; use t, h.symm\n  omega\n\n"}
{"name":"SimpleGraph.IsTuranMaximal.equivalence_not_adj","module":"Mathlib.Combinatorics.SimpleGraph.Turan","initialProofState":"V : Type u_1\ninst✝¹ : Fintype V\nG : SimpleGraph V\ninst✝ : DecidableRel G.Adj\nr : Nat\nh : G.IsTuranMaximal r\n⊢ Equivalence fun x1 x2 => Not (G.Adj x1 x2)","decl":"/-- In a Turán-maximal graph, non-adjacency is an equivalence relation. -/\ntheorem equivalence_not_adj : Equivalence (¬G.Adj · ·) where\n  refl := by simp\n  symm := by simp [adj_comm]\n  trans := h.not_adj_trans\n\n"}
{"name":"SimpleGraph.IsTuranMaximal.not_adj_iff_part_eq","module":"Mathlib.Combinatorics.SimpleGraph.Turan","initialProofState":"V : Type u_1\ninst✝² : Fintype V\nG : SimpleGraph V\ninst✝¹ : DecidableRel G.Adj\nr : Nat\ns t : V\nh : G.IsTuranMaximal r\ninst✝ : DecidableEq V\n⊢ Iff (Not (G.Adj s t)) (Eq (h.finpartition.part s) (h.finpartition.part t))","decl":"lemma not_adj_iff_part_eq [DecidableEq V] :\n    ¬G.Adj s t ↔ h.finpartition.part s = h.finpartition.part t := by\n  change h.setoid.r s t ↔ _\n  rw [← Finpartition.mem_part_ofSetoid_iff_rel]\n  let fp := h.finpartition\n  change t ∈ fp.part s ↔ fp.part s = fp.part t\n  rw [fp.mem_part_iff_part_eq_part (mem_univ t) (mem_univ s), eq_comm]\n\n"}
{"name":"SimpleGraph.IsTuranMaximal.degree_eq_card_sub_part_card","module":"Mathlib.Combinatorics.SimpleGraph.Turan","initialProofState":"V : Type u_1\ninst✝² : Fintype V\nG : SimpleGraph V\ninst✝¹ : DecidableRel G.Adj\nr : Nat\ns : V\nh : G.IsTuranMaximal r\ninst✝ : DecidableEq V\n⊢ Eq (G.degree s) (HSub.hSub (Fintype.card V) (h.finpartition.part s).card)","decl":"lemma degree_eq_card_sub_part_card [DecidableEq V] :\n    G.degree s = Fintype.card V - #(h.finpartition.part s) :=\n  calc\n    _ = #{t | G.Adj s t} := by\n      simp [← card_neighborFinset_eq_degree, neighborFinset]\n    _ = Fintype.card V - #{t | ¬G.Adj s t} :=\n      eq_tsub_of_add_eq (filter_card_add_filter_neg_card_eq_card _)\n    _ = _ := by\n      congr; ext; rw [mem_filter]\n      convert Finpartition.mem_part_ofSetoid_iff_rel.symm\n      simp [setoid]\n\n"}
{"name":"SimpleGraph.IsTuranMaximal.isEquipartition","module":"Mathlib.Combinatorics.SimpleGraph.Turan","initialProofState":"V : Type u_1\ninst✝² : Fintype V\nG : SimpleGraph V\ninst✝¹ : DecidableRel G.Adj\nr : Nat\nh : G.IsTuranMaximal r\ninst✝ : DecidableEq V\n⊢ h.finpartition.IsEquipartition","decl":"/-- The parts of a Turán-maximal graph form an equipartition. -/\ntheorem isEquipartition [DecidableEq V] : h.finpartition.IsEquipartition := by\n  set fp := h.finpartition\n  by_contra hn\n  rw [Finpartition.not_isEquipartition] at hn\n  obtain ⟨large, hl, small, hs, ineq⟩ := hn\n  obtain ⟨w, hw⟩ := fp.nonempty_of_mem_parts hl\n  obtain ⟨v, hv⟩ := fp.nonempty_of_mem_parts hs\n  apply absurd h\n  rw [IsTuranMaximal]; push_neg; intro cf\n  use G.replaceVertex v w, inferInstance, cf.replaceVertex v w\n  have large_eq := fp.part_eq_of_mem hl hw\n  have small_eq := fp.part_eq_of_mem hs hv\n  have ha : G.Adj v w := by\n    by_contra hn; rw [h.not_adj_iff_part_eq, small_eq, large_eq] at hn\n    rw [hn] at ineq; omega\n  rw [G.card_edgeFinset_replaceVertex_of_adj ha,\n    degree_eq_card_sub_part_card h, small_eq, degree_eq_card_sub_part_card h, large_eq]\n  have : #large ≤ Fintype.card V := by simpa using card_le_card large.subset_univ\n  omega\n\n"}
{"name":"SimpleGraph.IsTuranMaximal.card_parts_le","module":"Mathlib.Combinatorics.SimpleGraph.Turan","initialProofState":"V : Type u_1\ninst✝² : Fintype V\nG : SimpleGraph V\ninst✝¹ : DecidableRel G.Adj\nr : Nat\nh : G.IsTuranMaximal r\ninst✝ : DecidableEq V\n⊢ LE.le h.finpartition.parts.card r","decl":"lemma card_parts_le [DecidableEq V] : #h.finpartition.parts ≤ r := by\n  by_contra! l\n  obtain ⟨z, -, hz⟩ := h.finpartition.exists_subset_part_bijOn\n  have ncf : ¬G.CliqueFree #z := by\n    refine IsNClique.not_cliqueFree ⟨fun v hv w hw hn ↦ ?_, rfl⟩\n    contrapose! hn\n    exact hz.injOn hv hw (by rwa [← h.not_adj_iff_part_eq])\n  rw [Finset.card_eq_of_equiv hz.equiv] at ncf\n  exact absurd (h.1.mono (Nat.succ_le_of_lt l)) ncf\n\n"}
{"name":"SimpleGraph.IsTuranMaximal.card_parts","module":"Mathlib.Combinatorics.SimpleGraph.Turan","initialProofState":"V : Type u_1\ninst✝² : Fintype V\nG : SimpleGraph V\ninst✝¹ : DecidableRel G.Adj\nr : Nat\nh : G.IsTuranMaximal r\ninst✝ : DecidableEq V\n⊢ Eq h.finpartition.parts.card (Min.min (Fintype.card V) r)","decl":"/-- There are `min n r` parts in a graph on `n` vertices satisfying `G.IsTuranMaximal r`.\n`min` handles the `n < r` case, when `G` is complete but still `r + 1`-cliquefree\nfor having insufficiently many vertices. -/\ntheorem card_parts [DecidableEq V] : #h.finpartition.parts = min (Fintype.card V) r := by\n  set fp := h.finpartition\n  apply le_antisymm (le_min fp.card_parts_le_card h.card_parts_le)\n  by_contra! l\n  rw [lt_min_iff] at l\n  obtain ⟨x, -, y, -, hn, he⟩ :=\n    exists_ne_map_eq_of_card_lt_of_maps_to l.1 fun a _ ↦ fp.part_mem (mem_univ a)\n  apply absurd h\n  rw [IsTuranMaximal]; push_neg; rintro -\n  have cf : G.CliqueFree r := by\n    simp_rw [← cliqueFinset_eq_empty_iff, cliqueFinset, filter_eq_empty_iff, mem_univ,\n      forall_true_left, isNClique_iff, and_comm, not_and, isClique_iff, Set.Pairwise]\n    intro z zc; push_neg; simp_rw [h.not_adj_iff_part_eq]\n    exact exists_ne_map_eq_of_card_lt_of_maps_to (zc.symm ▸ l.2) fun a _ ↦ fp.part_mem (mem_univ a)\n  use G ⊔ edge x y, inferInstance, cf.sup_edge x y\n  convert Nat.lt.base #G.edgeFinset\n  convert G.card_edgeFinset_sup_edge _ hn\n  rwa [h.not_adj_iff_part_eq]\n\n"}
{"name":"SimpleGraph.IsTuranMaximal.nonempty_iso_turanGraph","module":"Mathlib.Combinatorics.SimpleGraph.Turan","initialProofState":"V : Type u_1\ninst✝¹ : Fintype V\nG : SimpleGraph V\ninst✝ : DecidableRel G.Adj\nr : Nat\nh : G.IsTuranMaximal r\n⊢ Nonempty (G.Iso (SimpleGraph.turanGraph (Fintype.card V) r))","decl":"/-- **Turán's theorem**, forward direction.\n\nAny `r + 1`-cliquefree Turán-maximal graph on `n` vertices is isomorphic to `turanGraph n r`. -/\ntheorem nonempty_iso_turanGraph :\n    Nonempty (G ≃g turanGraph (Fintype.card V) r) := by\n  classical\n  obtain ⟨zm, zp⟩ := h.isEquipartition.exists_partPreservingEquiv\n  use (Equiv.subtypeUnivEquiv mem_univ).symm.trans zm\n  intro a b\n  simp_rw [turanGraph, Equiv.trans_apply, Equiv.subtypeUnivEquiv_symm_apply]\n  have := zp ⟨a, mem_univ a⟩ ⟨b, mem_univ b⟩\n  rw [← h.not_adj_iff_part_eq] at this\n  rw [← not_iff_not, not_ne_iff, this, card_parts]\n  rcases le_or_lt r (Fintype.card V) with c | c\n  · rw [min_eq_right c]; rfl\n  · have lc : ∀ x, zm ⟨x, _⟩ < Fintype.card V := fun x ↦ (zm ⟨x, mem_univ x⟩).2\n    rw [min_eq_left c.le, Nat.mod_eq_of_lt (lc a), Nat.mod_eq_of_lt (lc b),\n      ← Nat.mod_eq_of_lt ((lc a).trans c), ← Nat.mod_eq_of_lt ((lc b).trans c)]; rfl\n\n"}
{"name":"SimpleGraph.isTuranMaximal_of_iso","module":"Mathlib.Combinatorics.SimpleGraph.Turan","initialProofState":"V : Type u_1\ninst✝¹ : Fintype V\nG : SimpleGraph V\ninst✝ : DecidableRel G.Adj\nn r : Nat\nf : G.Iso (SimpleGraph.turanGraph n r)\nhr : LT.lt 0 r\n⊢ G.IsTuranMaximal r","decl":"/-- **Turán's theorem**, reverse direction.\n\nAny graph isomorphic to `turanGraph n r` is itself Turán-maximal if `0 < r`. -/\ntheorem isTuranMaximal_of_iso (f : G ≃g turanGraph n r) (hr : 0 < r) : G.IsTuranMaximal r := by\n  obtain ⟨J, _, j⟩ := exists_isTuranMaximal (V := V) hr\n  obtain ⟨g⟩ := j.nonempty_iso_turanGraph\n  rw [f.card_eq, Fintype.card_fin] at g\n  use (turanGraph_cliqueFree (n := n) hr).comap f,\n    fun H _ cf ↦ (f.symm.comp g).card_edgeFinset_eq ▸ j.2 H cf\n\n"}
{"name":"SimpleGraph.IsTuranMaximal.iso","module":"Mathlib.Combinatorics.SimpleGraph.Turan","initialProofState":"V : Type u_1\ninst✝³ : Fintype V\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\nr : Nat\nW : Type u_2\ninst✝¹ : Fintype W\nH : SimpleGraph W\ninst✝ : DecidableRel H.Adj\nh : G.IsTuranMaximal r\nf : G.Iso H\nhr : LT.lt 0 r\n⊢ H.IsTuranMaximal r","decl":"/-- Turán-maximality with `0 < r` transfers across graph isomorphisms. -/\ntheorem IsTuranMaximal.iso {W : Type*} [Fintype W] {H : SimpleGraph W}\n    [DecidableRel H.Adj] (h : G.IsTuranMaximal r) (f : G ≃g H) (hr : 0 < r) : H.IsTuranMaximal r :=\n  isTuranMaximal_of_iso (h.nonempty_iso_turanGraph.some.comp f.symm) hr\n\n"}
{"name":"SimpleGraph.isTuranMaximal_turanGraph","module":"Mathlib.Combinatorics.SimpleGraph.Turan","initialProofState":"n r : Nat\nhr : LT.lt 0 r\n⊢ (SimpleGraph.turanGraph n r).IsTuranMaximal r","decl":"/-- For `0 < r`, `turanGraph n r` is Turán-maximal. -/\ntheorem isTuranMaximal_turanGraph (hr : 0 < r) : (turanGraph n r).IsTuranMaximal r :=\n  isTuranMaximal_of_iso Iso.refl hr\n\n"}
{"name":"SimpleGraph.isTuranMaximal_iff_nonempty_iso_turanGraph","module":"Mathlib.Combinatorics.SimpleGraph.Turan","initialProofState":"V : Type u_1\ninst✝¹ : Fintype V\nG : SimpleGraph V\ninst✝ : DecidableRel G.Adj\nr : Nat\nhr : LT.lt 0 r\n⊢ Iff (G.IsTuranMaximal r) (Nonempty (G.Iso (SimpleGraph.turanGraph (Fintype.card V) r)))","decl":"/-- **Turán's theorem**. `turanGraph n r` is, up to isomorphism, the unique\n`r + 1`-cliquefree Turán-maximal graph on `n` vertices. -/\ntheorem isTuranMaximal_iff_nonempty_iso_turanGraph (hr : 0 < r) :\n    G.IsTuranMaximal r ↔ Nonempty (G ≃g turanGraph (Fintype.card V) r) :=\n  ⟨fun h ↦ h.nonempty_iso_turanGraph, fun h ↦ isTuranMaximal_of_iso h.some hr⟩\n\n"}
