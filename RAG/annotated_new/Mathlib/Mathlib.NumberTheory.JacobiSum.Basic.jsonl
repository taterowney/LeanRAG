{"name":"jacobiSum_comm","module":"Mathlib.NumberTheory.JacobiSum.Basic","initialProofState":"R : Type u_1\nR' : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Fintype R\ninst✝ : CommRing R'\nχ ψ : MulChar R R'\n⊢ Eq (jacobiSum χ ψ) (jacobiSum ψ χ)","decl":"lemma jacobiSum_comm (χ ψ : MulChar R R') : jacobiSum χ ψ = jacobiSum ψ χ := by\n  simp only [jacobiSum, mul_comm (χ _)]\n  rw [← (Equiv.subLeft 1).sum_comp]\n  simp only [Equiv.subLeft_apply, sub_sub_cancel]\n\n"}
{"name":"jacobiSum_ringHomComp","module":"Mathlib.NumberTheory.JacobiSum.Basic","initialProofState":"R : Type u_1\nR' : Type u_2\ninst✝³ : CommRing R\ninst✝² : Fintype R\ninst✝¹ : CommRing R'\nR'' : Type u_3\ninst✝ : CommRing R''\nχ ψ : MulChar R R'\nf : RingHom R' R''\n⊢ Eq (jacobiSum (χ.ringHomComp f) (ψ.ringHomComp f)) (f (jacobiSum χ ψ))","decl":"/-- The Jacobi sum is compatible with ring homomorphisms. -/\nlemma jacobiSum_ringHomComp {R'' : Type*} [CommRing R''] (χ ψ : MulChar R R') (f : R' →+* R'') :\n    jacobiSum (χ.ringHomComp f) (ψ.ringHomComp f) = f (jacobiSum χ ψ) := by\n  simp only [jacobiSum, MulChar.ringHomComp, MulChar.coe_mk, MonoidHom.coe_mk, OneHom.coe_mk,\n    map_sum, map_mul]\n\n"}
{"name":"jacobiSum_eq_sum_sdiff","module":"Mathlib.NumberTheory.JacobiSum.Basic","initialProofState":"F : Type u_1\nR : Type u_2\ninst✝⁴ : CommRing F\ninst✝³ : Nontrivial F\ninst✝² : Fintype F\ninst✝¹ : DecidableEq F\ninst✝ : CommRing R\nχ ψ : MulChar F R\n⊢ Eq (jacobiSum χ ψ) ((SDiff.sdiff Finset.univ (Insert.insert 0 (Singleton.singleton 1))).sum fun x => HMul.hMul (χ x) (ψ (HSub.hSub 1 x)))","decl":"/-- The Jacobi sum of two multiplicative characters on a nontrivial finite commutative ring `F`\ncan be written as a sum over `F \\ {0,1}`. -/\nlemma jacobiSum_eq_sum_sdiff (χ ψ : MulChar F R) :\n    jacobiSum χ ψ = ∑ x ∈ univ \\ {0,1}, χ x * ψ (1 - x) := by\n  simp only [jacobiSum, subset_univ, sum_sdiff_eq_sub, sub_eq_add_neg, self_eq_add_right,\n    neg_eq_zero]\n  apply sum_eq_zero\n  simp only [mem_insert, mem_singleton, forall_eq_or_imp, χ.map_zero, neg_zero, add_zero, map_one,\n    mul_one, forall_eq, add_neg_cancel, ψ.map_zero, mul_zero, and_self]\n\n"}
{"name":"jacobiSum_trivial_trivial","module":"Mathlib.NumberTheory.JacobiSum.Basic","initialProofState":"F : Type u_1\nR : Type u_2\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : CommRing R\n⊢ Eq (jacobiSum (MulChar.trivial F R) (MulChar.trivial F R)) (HSub.hSub (↑(Fintype.card F)) 2)","decl":"/-- The Jacobi sum of twice the trivial multiplicative character on a finite field `F`\nequals `#F-2`. -/\ntheorem jacobiSum_trivial_trivial :\n    jacobiSum (MulChar.trivial F R) (MulChar.trivial F R) = Fintype.card F - 2 := by\n  classical\n  rw [jacobiSum_eq_sum_sdiff]\n  have : ∀ x ∈ univ \\ {0, 1}, (MulChar.trivial F R) x * (MulChar.trivial F R) (1 - x) = 1 := by\n    intros x hx\n    rw [← map_mul, MulChar.trivial_apply, if_pos]\n    simp only [mem_sdiff, mem_univ, mem_insert, mem_singleton, not_or, ← ne_eq, true_and] at hx\n    simpa only [isUnit_iff_ne_zero, mul_ne_zero_iff, ne_eq, sub_eq_zero, @eq_comm _ _ x] using hx\n  calc ∑ x ∈ univ \\ {0, 1}, (MulChar.trivial F R) x * (MulChar.trivial F R) (1 - x)\n  _ = ∑ _ ∈ univ \\ {0, 1}, 1 := sum_congr rfl this\n  _ = #(univ \\ {0, 1}) := (cast_card _).symm\n  _ = Fintype.card F - 2 := by\n    rw [card_sdiff (subset_univ _), card_univ, card_pair zero_ne_one,\n      Nat.cast_sub <| Nat.add_one_le_of_lt Fintype.one_lt_card, Nat.cast_two]\n\n"}
{"name":"jacobiSum_one_one","module":"Mathlib.NumberTheory.JacobiSum.Basic","initialProofState":"F : Type u_1\nR : Type u_2\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : CommRing R\n⊢ Eq (jacobiSum 1 1) (HSub.hSub (↑(Fintype.card F)) 2)","decl":"/-- If `1` is the trivial multiplicative character on a finite field `F`, then `J(1,1) = #F-2`. -/\ntheorem jacobiSum_one_one : jacobiSum (1 : MulChar F R) 1 = Fintype.card F - 2 :=\n  jacobiSum_trivial_trivial\n\n"}
{"name":"jacobiSum_one_nontrivial","module":"Mathlib.NumberTheory.JacobiSum.Basic","initialProofState":"F : Type u_1\nR : Type u_2\ninst✝³ : Field F\ninst✝² : Fintype F\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nχ : MulChar F R\nhχ : Ne χ 1\n⊢ Eq (jacobiSum 1 χ) (-1)","decl":"/-- If `χ` is a nontrivial multiplicative character on a finite field `F`, then `J(1,χ) = -1`. -/\ntheorem jacobiSum_one_nontrivial {χ : MulChar F R} (hχ : χ ≠ 1) : jacobiSum 1 χ = -1 := by\n  classical\n  have : ∑ x ∈ univ \\ {0, 1}, ((1 : MulChar F R) x - 1) * (χ (1 - x) - 1) = 0 := by\n    apply Finset.sum_eq_zero\n    simp +contextual only [mem_sdiff, mem_univ, mem_insert, mem_singleton,\n      not_or, ← isUnit_iff_ne_zero, true_and, MulChar.one_apply, sub_self, zero_mul, and_imp,\n      implies_true]\n  simp only [jacobiSum_eq_aux, MulChar.sum_one_eq_card_units, MulChar.sum_eq_zero_of_ne_one hχ,\n    add_zero, Fintype.card_eq_card_units_add_one (α := F), Nat.cast_add, Nat.cast_one,\n    sub_add_cancel_left, this]\n\n"}
{"name":"jacobiSum_nontrivial_inv","module":"Mathlib.NumberTheory.JacobiSum.Basic","initialProofState":"F : Type u_1\nR : Type u_2\ninst✝³ : Field F\ninst✝² : Fintype F\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nχ : MulChar F R\nhχ : Ne χ 1\n⊢ Eq (jacobiSum χ (Inv.inv χ)) (Neg.neg (χ (-1)))","decl":"/-- If `χ` is a nontrivial multiplicative character on a finite field `F`,\nthen `J(χ,χ⁻¹) = -χ(-1)`. -/\ntheorem jacobiSum_nontrivial_inv {χ : MulChar F R} (hχ : χ ≠ 1) : jacobiSum χ χ⁻¹ = -χ (-1) := by\n  classical\n  rw [jacobiSum]\n  conv => enter [1, 2, x]; rw [MulChar.inv_apply', ← map_mul, ← div_eq_mul_inv]\n  rw [sum_eq_sum_diff_singleton_add (mem_univ (1 : F)), sub_self, div_zero, χ.map_zero, add_zero]\n  have : ∑ x ∈ univ \\ {1}, χ (x / (1 - x)) = ∑ x ∈ univ \\ {-1}, χ x := by\n    refine sum_bij' (fun a _ ↦ a / (1 - a)) (fun b _ ↦ b / (1 + b)) (fun x hx ↦ ?_)\n      (fun y hy ↦ ?_) (fun x hx ↦ ?_) (fun y hy ↦ ?_) (fun _ _ ↦ rfl)\n    · simp only [mem_sdiff, mem_univ, mem_singleton, true_and] at hx ⊢\n      rw [div_eq_iff <| sub_ne_zero.mpr ((ne_eq ..).symm ▸ hx).symm, mul_sub, mul_one,\n        neg_one_mul, sub_neg_eq_add, self_eq_add_left, neg_eq_zero]\n      exact one_ne_zero\n    · simp only [mem_sdiff, mem_univ, mem_singleton, true_and] at hy ⊢\n      rw [div_eq_iff fun h ↦ hy <| eq_neg_of_add_eq_zero_right h, one_mul, self_eq_add_left]\n      exact one_ne_zero\n    · simp only [mem_sdiff, mem_univ, mem_singleton, true_and] at hx\n      rw [eq_comm, ← sub_eq_zero] at hx\n      field_simp\n    · simp only [mem_sdiff, mem_univ, mem_singleton, true_and] at hy\n      rw [eq_comm, neg_eq_iff_eq_neg, ← sub_eq_zero, sub_neg_eq_add] at hy\n      field_simp\n  rw [this, ← add_eq_zero_iff_eq_neg, ← sum_eq_sum_diff_singleton_add (mem_univ (-1 : F))]\n  exact MulChar.sum_eq_zero_of_ne_one hχ\n\n"}
{"name":"jacobiSum_mul_nontrivial","module":"Mathlib.NumberTheory.JacobiSum.Basic","initialProofState":"F : Type u_1\nR : Type u_2\ninst✝³ : Field F\ninst✝² : Fintype F\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nχ φ : MulChar F R\nh : Ne (HMul.hMul χ φ) 1\nψ : AddChar F R\n⊢ Eq (HMul.hMul (gaussSum (HMul.hMul χ φ) ψ) (jacobiSum χ φ)) (HMul.hMul (gaussSum χ ψ) (gaussSum φ ψ))","decl":"/-- If `χ` and `φ` are multiplicative characters on a finite field `F` such that\n`χφ` is nontrivial, then `g(χφ) * J(χ,φ) = g(χ) * g(φ)`. -/\ntheorem jacobiSum_mul_nontrivial {χ φ : MulChar F R} (h : χ * φ ≠ 1) (ψ : AddChar F R) :\n    gaussSum (χ * φ) ψ * jacobiSum χ φ = gaussSum χ ψ * gaussSum φ ψ := by\n  classical\n  rw [gaussSum_mul _ _ ψ, sum_eq_sum_diff_singleton_add (mem_univ (0 : F))]\n  conv =>\n    enter [2, 2, 2, x]\n    rw [zero_sub, neg_eq_neg_one_mul x, map_mul, mul_left_comm (χ x) (φ (-1)),\n      ← MulChar.mul_apply, ψ.map_zero_eq_one, mul_one]\n  rw [← mul_sum _ _ (φ (-1)), MulChar.sum_eq_zero_of_ne_one h, mul_zero, add_zero]\n  have sum_eq : ∀ t ∈ univ \\ {0}, (∑ x : F, χ x * φ (t - x)) * ψ t =\n      (∑ y : F, χ (t * y) * φ (t - (t * y))) * ψ t := by\n    intro t ht\n    simp only [mem_sdiff, mem_univ, mem_singleton, true_and] at ht\n    exact congrArg (· * ψ t) (Equiv.sum_comp (Equiv.mulLeft₀ t ht) _).symm\n  simp_rw [← sum_mul, sum_congr rfl sum_eq, ← mul_one_sub, map_mul, mul_assoc]\n  conv => enter [2, 2, t, 1, 2, x, 2]; rw [← mul_assoc, mul_comm (χ x) (φ t)]\n  simp_rw [← mul_assoc, ← MulChar.mul_apply, mul_assoc, ← mul_sum, mul_right_comm]\n  rw [← jacobiSum, ← sum_mul, gaussSum, sum_eq_sum_diff_singleton_add (mem_univ (0 : F)),\n    (χ * φ).map_zero, zero_mul, add_zero]\n\n"}
{"name":"jacobiSum_eq_gaussSum_mul_gaussSum_div_gaussSum","module":"Mathlib.NumberTheory.JacobiSum.Basic","initialProofState":"F : Type u_1\nF' : Type u_2\ninst✝² : Fintype F\ninst✝¹ : Field F\ninst✝ : Field F'\nh : Ne (↑(Fintype.card F)) 0\nχ φ : MulChar F F'\nhχφ : Ne (HMul.hMul χ φ) 1\nψ : AddChar F F'\nhψ : ψ.IsPrimitive\n⊢ Eq (jacobiSum χ φ) (HDiv.hDiv (HMul.hMul (gaussSum χ ψ) (gaussSum φ ψ)) (gaussSum (HMul.hMul χ φ) ψ))","decl":"/-- If `χ` and `φ` are multiplicative characters on a finite field `F` with values\nin another field `F'` and such that `χφ` is nontrivial, then `J(χ,φ) = g(χ) * g(φ) / g(χφ)`. -/\ntheorem jacobiSum_eq_gaussSum_mul_gaussSum_div_gaussSum (h : (Fintype.card F : F') ≠ 0)\n    {χ φ : MulChar F F'} (hχφ : χ * φ ≠ 1) {ψ : AddChar F F'} (hψ : ψ.IsPrimitive) :\n    jacobiSum χ φ = gaussSum χ ψ * gaussSum φ ψ / gaussSum (χ * φ) ψ := by\n  rw [eq_div_iff <| gaussSum_ne_zero_of_nontrivial h hχφ hψ, mul_comm]\n  exact jacobiSum_mul_nontrivial hχφ ψ\n\n"}
{"name":"jacobiSum_mul_jacobiSum_inv","module":"Mathlib.NumberTheory.JacobiSum.Basic","initialProofState":"F : Type u_1\nF' : Type u_2\ninst✝² : Fintype F\ninst✝¹ : Field F\ninst✝ : Field F'\nh : Ne (ringChar F') (ringChar F)\nχ φ : MulChar F F'\nhχ : Ne χ 1\nhφ : Ne φ 1\nhχφ : Ne (HMul.hMul χ φ) 1\n⊢ Eq (HMul.hMul (jacobiSum χ φ) (jacobiSum (Inv.inv χ) (Inv.inv φ))) ↑(Fintype.card F)","decl":"open AddChar MulChar in\n/-- If `χ` and `φ` are multiplicative characters on a finite field `F` with values in another\nfield `F'` such that `χ`, `φ` and `χφ` are all nontrivial and `char F' ≠ char F`, then\n`J(χ,φ) * J(χ⁻¹,φ⁻¹) = #F` (in `F'`). -/\nlemma jacobiSum_mul_jacobiSum_inv (h : ringChar F' ≠ ringChar F) {χ φ : MulChar F F'} (hχ : χ ≠ 1)\n    (hφ : φ ≠ 1) (hχφ : χ * φ ≠ 1) :\n    jacobiSum χ φ * jacobiSum χ⁻¹ φ⁻¹ = Fintype.card F := by\n  obtain ⟨n, hp, hc⟩ := FiniteField.card F (ringChar F)\n  let ψ := FiniteField.primitiveChar F F' h   -- obtain primitive additive character `ψ : F → FF'`\n  let FF' := CyclotomicField ψ.n F'           -- the target field of `ψ`\n  let χ' := χ.ringHomComp (algebraMap F' FF') -- consider `χ` and `φ` as characters `F → FF'`\n  let φ' := φ.ringHomComp (algebraMap F' FF')\n  have hinj := (algebraMap F' FF').injective\n  apply hinj\n  rw [map_mul, ← jacobiSum_ringHomComp, ← jacobiSum_ringHomComp]\n  have Hχφ : χ' * φ' ≠ 1 := by\n    rw [← ringHomComp_mul]\n    exact (MulChar.ringHomComp_ne_one_iff hinj).mpr hχφ\n  have Hχφ' : χ'⁻¹ * φ'⁻¹ ≠ 1 := by\n    rwa [← mul_inv, inv_ne_one]\n  have Hχ : χ' ≠ 1 := (MulChar.ringHomComp_ne_one_iff hinj).mpr hχ\n  have Hφ : φ' ≠ 1 := (MulChar.ringHomComp_ne_one_iff hinj).mpr hφ\n  have Hcard : (Fintype.card F : FF') ≠ 0 := by\n    intro H\n    simp only [hc, Nat.cast_pow, ne_eq, PNat.ne_zero, not_false_eq_true, pow_eq_zero_iff] at H\n    exact h <| (Algebra.ringChar_eq F' FF').trans <| CharP.ringChar_of_prime_eq_zero hp H\n  have H := (gaussSum_mul_gaussSum_eq_card Hχφ ψ.prim).trans_ne Hcard\n  apply_fun (gaussSum (χ' * φ') ψ.char * gaussSum (χ' * φ')⁻¹ ψ.char⁻¹ * ·)\n    using mul_right_injective₀ H\n  simp only\n  rw [mul_mul_mul_comm, jacobiSum_mul_nontrivial Hχφ, mul_inv, ← ringHomComp_inv,\n    ← ringHomComp_inv, jacobiSum_mul_nontrivial Hχφ', map_natCast, ← mul_mul_mul_comm,\n    gaussSum_mul_gaussSum_eq_card Hχ ψ.prim, gaussSum_mul_gaussSum_eq_card Hφ ψ.prim,\n    ← mul_inv, gaussSum_mul_gaussSum_eq_card Hχφ ψ.prim]\n\n"}
{"name":"jacobiSum_mem_algebraAdjoin_of_pow_eq_one","module":"Mathlib.NumberTheory.JacobiSum.Basic","initialProofState":"F : Type u_1\nR : Type u_2\ninst✝⁴ : Fintype F\ninst✝³ : Field F\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\nn : Nat\ninst✝ : NeZero n\nχ φ : MulChar F R\nhχ : Eq (HPow.hPow χ n) 1\nhφ : Eq (HPow.hPow φ n) 1\nμ : R\nhμ : IsPrimitiveRoot μ n\n⊢ Membership.mem (Algebra.adjoin Int (Singleton.singleton μ)) (jacobiSum χ φ)","decl":"/-- If `χ` and `φ` are multiplicative characters on a finite field `F` satisfying `χ^n = φ^n = 1`\nand with values in an integral domain `R`, and `μ` is a primitive `n`th root of unity in `R`,\nthen the Jacobi sum `J(χ,φ)` is in `ℤ[μ] ⊆ R`. -/\nlemma jacobiSum_mem_algebraAdjoin_of_pow_eq_one {n : ℕ} [NeZero n] {χ φ : MulChar F R}\n    (hχ : χ ^ n = 1) (hφ : φ ^ n = 1) {μ : R} (hμ : IsPrimitiveRoot μ n) :\n    jacobiSum χ φ ∈ Algebra.adjoin ℤ {μ} :=\n  Subalgebra.sum_mem _ fun _ _ ↦ Subalgebra.mul_mem _\n    (MulChar.apply_mem_algebraAdjoin_of_pow_eq_one hχ hμ _)\n    (MulChar.apply_mem_algebraAdjoin_of_pow_eq_one hφ hμ _)\n\n"}
{"name":"exists_jacobiSum_eq_neg_one_add","module":"Mathlib.NumberTheory.JacobiSum.Basic","initialProofState":"F : Type u_1\nR : Type u_2\ninst✝³ : Fintype F\ninst✝² : Field F\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nn : Nat\nhn : LT.lt 2 n\nχ ψ : MulChar F R\nμ : R\nhχ : Eq (HPow.hPow χ n) 1\nhψ : Eq (HPow.hPow ψ n) 1\nhn' : Dvd.dvd n (HSub.hSub (Fintype.card F) 1)\nhμ : IsPrimitiveRoot μ n\n⊢ Exists fun z => And (Membership.mem (Algebra.adjoin Int (Singleton.singleton μ)) z) (Eq (jacobiSum χ ψ) (HAdd.hAdd (-1) (HMul.hMul z (HPow.hPow (HSub.hSub μ 1) 2))))","decl":"/-- If `χ` and `ψ` are multiplicative characters of order dividing `n` on a finite field `F`\nwith values in an integral domain `R` and `μ` is a primitive `n`th root of unity in `R`,\nthen `J(χ,ψ) = -1 + z*(μ - 1)^2` for some `z ∈ ℤ[μ] ⊆ R`. (We assume that `#F ≡ 1 mod n`.)\nNote that we do not state this as a divisibility in `R`, as this would give a weaker statement. -/\nlemma exists_jacobiSum_eq_neg_one_add {n : ℕ} (hn : 2 < n) {χ ψ : MulChar F R}\n    {μ : R} (hχ : χ ^ n = 1) (hψ : ψ ^ n = 1) (hn' : n ∣ Fintype.card F - 1)\n    (hμ : IsPrimitiveRoot μ n) :\n    ∃ z ∈ Algebra.adjoin ℤ {μ}, jacobiSum χ ψ = -1 + z * (μ - 1) ^ 2 := by\n  obtain ⟨q, hq⟩ := hn'\n  rw [Nat.sub_eq_iff_eq_add NeZero.one_le] at hq\n  obtain ⟨z₁, hz₁, Hz₁⟩ := hμ.self_sub_one_pow_dvd_order hn\n  by_cases hχ₀ : χ = 1 <;> by_cases hψ₀ : ψ = 1\n  · rw [hχ₀, hψ₀, jacobiSum_one_one]\n    refine ⟨q * z₁, Subalgebra.mul_mem _ (Subalgebra.natCast_mem _ q) hz₁, ?_⟩\n    rw [hq, Nat.cast_add, Nat.cast_mul, Hz₁]\n    ring\n  · refine ⟨0, Subalgebra.zero_mem _, ?_⟩\n    rw [hχ₀, jacobiSum_one_nontrivial hψ₀, zero_mul, add_zero]\n  · refine ⟨0, Subalgebra.zero_mem _, ?_⟩\n    rw [jacobiSum_comm, hψ₀, jacobiSum_one_nontrivial hχ₀, zero_mul, add_zero]\n  · classical\n    rw [jacobiSum_eq_aux, MulChar.sum_eq_zero_of_ne_one hχ₀, MulChar.sum_eq_zero_of_ne_one hψ₀, hq]\n    have : NeZero n := ⟨by omega⟩\n    have H := MulChar.exists_apply_sub_one_mul_apply_sub_one hχ hψ hμ\n    have Hcs x := (H x).choose_spec\n    refine ⟨-q * z₁ + ∑ x ∈ (univ \\ {0, 1} : Finset F), (H x).choose, ?_, ?_⟩\n    · refine Subalgebra.add_mem _ (Subalgebra.mul_mem _ (Subalgebra.neg_mem _ ?_) hz₁) ?_\n      · exact Subalgebra.natCast_mem ..\n      · exact Subalgebra.sum_mem _ fun x _ ↦ (Hcs x).1\n    · conv => enter [1, 2, 2, x]; rw [(Hcs x).2]\n      rw [← Finset.sum_mul, Nat.cast_add, Nat.cast_mul, Hz₁]\n      ring\n\n"}
{"name":"gaussSum_pow_eq_prod_jacobiSum_aux","module":"Mathlib.NumberTheory.JacobiSum.Basic","initialProofState":"F : Type u_1\nR : Type u_2\ninst✝³ : Fintype F\ninst✝² : Field F\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nχ : MulChar F R\nψ : AddChar F R\nn : Nat\nhn₁ : LT.lt 0 n\nhn₂ : LT.lt n (orderOf χ)\n⊢ Eq (HPow.hPow (gaussSum χ ψ) n) (HMul.hMul (gaussSum (HPow.hPow χ n) ψ) ((Finset.Ico 1 n).prod fun j => jacobiSum χ (HPow.hPow χ j)))","decl":"lemma gaussSum_pow_eq_prod_jacobiSum_aux (χ : MulChar F R) (ψ : AddChar F R) {n : ℕ}\n    (hn₁ : 0 < n) (hn₂ : n < orderOf χ) :\n    gaussSum χ ψ ^ n = gaussSum (χ ^ n) ψ * ∏ j ∈ Ico 1 n, jacobiSum χ (χ ^ j) := by\n  induction n, hn₁ using Nat.le_induction with\n  | base => simp only [pow_one, le_refl, Ico_eq_empty_of_le, prod_empty, mul_one]\n  | succ n hn ih =>\n      specialize ih <| lt_trans (Nat.lt_succ_self n) hn₂\n      have gauss_rw : gaussSum (χ ^ n) ψ * gaussSum χ ψ =\n            jacobiSum χ (χ ^ n) * gaussSum (χ ^ (n + 1)) ψ := by\n        have hχn : χ * (χ ^ n) ≠ 1 :=\n          pow_succ' χ n ▸ pow_ne_one_of_lt_orderOf n.add_one_ne_zero hn₂\n        rw [mul_comm, ← jacobiSum_mul_nontrivial hχn, mul_comm, ← pow_succ']\n      apply_fun (· * gaussSum χ ψ) at ih\n      rw [mul_right_comm, ← pow_succ, gauss_rw] at ih\n      rw [ih, Finset.prod_Ico_succ_top hn, mul_rotate, mul_assoc]\n\n"}
{"name":"gaussSum_pow_eq_prod_jacobiSum","module":"Mathlib.NumberTheory.JacobiSum.Basic","initialProofState":"F : Type u_1\nR : Type u_2\ninst✝³ : Fintype F\ninst✝² : Field F\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nχ : MulChar F R\nψ : AddChar F R\nhχ : LE.le 2 (orderOf χ)\nhψ : ψ.IsPrimitive\n⊢ Eq (HPow.hPow (gaussSum χ ψ) (orderOf χ)) (HMul.hMul (HMul.hMul (χ (-1)) ↑(Fintype.card F)) ((Finset.Ico 1 (HSub.hSub (orderOf χ) 1)).prod fun i => jacobiSum χ (HPow.hPow χ i)))","decl":"/-- If `χ` is a multiplicative character of order `n ≥ 2` on a finite field `F`,\nthen `g(χ)^n = χ(-1) * #F * J(χ,χ) * J(χ,χ²) * ... * J(χ,χⁿ⁻²)`. -/\ntheorem gaussSum_pow_eq_prod_jacobiSum {χ : MulChar F R} {ψ : AddChar F R} (hχ : 2 ≤ orderOf χ)\n    (hψ : ψ.IsPrimitive) :\n    gaussSum χ ψ ^ orderOf χ =\n      χ (-1) * Fintype.card F * ∏ i ∈ Ico 1 (orderOf χ - 1), jacobiSum χ (χ ^ i) := by\n  have := gaussSum_pow_eq_prod_jacobiSum_aux χ ψ (n := orderOf χ - 1) (by omega) (by omega)\n  apply_fun (gaussSum χ ψ * ·) at this\n  rw [← pow_succ', Nat.sub_one_add_one_eq_of_pos (by omega)] at this\n  have hχ₁ : χ ≠ 1 :=\n    fun h ↦ ((orderOf_one (G := MulChar F R) ▸ h ▸ hχ).trans_lt Nat.one_lt_two).false\n  rw [this, ← mul_assoc, gaussSum_mul_gaussSum_pow_orderOf_sub_one hχ₁ hψ]\n\n"}
