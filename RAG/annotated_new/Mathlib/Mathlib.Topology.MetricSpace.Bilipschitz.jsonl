{"name":"uniformity_eq_of_bilipschitz","module":"Mathlib.Topology.MetricSpace.Bilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK‚ÇÅ K‚ÇÇ : NNReal\nf : Œ± ‚Üí Œ≤\nhf‚ÇÅ : AntilipschitzWith K‚ÇÅ f\nhf‚ÇÇ : LipschitzWith K‚ÇÇ f\n‚ä¢ Eq (uniformity Œ±) (uniformity Œ±)","decl":"/-- If `f : Œ± ‚Üí Œ≤` is bilipschitz, then the pullback of the uniformity on `Œ≤` through `f` agrees\nwith the uniformity on `Œ±`.\n\nThis can be used to provide the replacement equality when applying\n`PseudoMetricSpace.replaceUniformity`, which can be useful when following the forgetful inheritance\npattern when creating type synonyms.\n\nImportant Note: if `Œ±` is some synonym of a type `Œ≤` (at default transparency), and `f : Œ± ‚âÉ Œ≤` is\nsome bilipschitz equivalence, then instead of writing:\n```\ninstance : UniformSpace Œ± := inferInstanceAs (UniformSpace Œ≤)\n```\nUsers should instead write something like:\n```\ninstance : UniformSpace Œ± := (inferInstance : UniformSpace Œ≤).comap f\n```\nin order to avoid abuse of the definitional equality `Œ± := Œ≤`. -/\nlemma uniformity_eq_of_bilipschitz (hf‚ÇÅ : AntilipschitzWith K‚ÇÅ f) (hf‚ÇÇ : LipschitzWith K‚ÇÇ f) :\n    ùì§[(inferInstance : UniformSpace Œ≤).comap f] = ùì§ Œ± :=\n  hf‚ÇÅ.isUniformInducing hf‚ÇÇ.uniformContinuous |>.comap_uniformity\n\n"}
{"name":"bornology_eq_of_bilipschitz","module":"Mathlib.Topology.MetricSpace.Bilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nK‚ÇÅ K‚ÇÇ : NNReal\nf : Œ± ‚Üí Œ≤\nhf‚ÇÅ : AntilipschitzWith K‚ÇÅ f\nhf‚ÇÇ : LipschitzWith K‚ÇÇ f\n‚ä¢ Eq (Bornology.cobounded Œ±) (Bornology.cobounded Œ±)","decl":"/-- If `f : Œ± ‚Üí Œ≤` is bilipschitz, then the pullback of the bornology on `Œ≤` through `f` agrees\nwith the bornology on `Œ±`. -/\nlemma bornology_eq_of_bilipschitz (hf‚ÇÅ : AntilipschitzWith K‚ÇÅ f) (hf‚ÇÇ : LipschitzWith K‚ÇÇ f) :\n    @cobounded _ (induced f) = cobounded Œ± :=\n  le_antisymm hf‚ÇÇ.comap_cobounded_le hf‚ÇÅ.tendsto_cobounded.le_comap\n\n\n"}
{"name":"isBounded_iff_of_bilipschitz","module":"Mathlib.Topology.MetricSpace.Bilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nK‚ÇÅ K‚ÇÇ : NNReal\nf : Œ± ‚Üí Œ≤\nhf‚ÇÅ : AntilipschitzWith K‚ÇÅ f\nhf‚ÇÇ : LipschitzWith K‚ÇÇ f\ns : Set Œ±\n‚ä¢ Iff (Bornology.IsBounded s) (Bornology.IsBounded s)","decl":"/-- If `f : Œ± ‚Üí Œ≤` is bilipschitz, then the pullback of the bornology on `Œ≤` through `f` agrees\nwith the bornology on `Œ±`.\n\nThis can be used to provide the replacement equality when applying\n`PseudoMetricSpace.replaceBornology`, which can be useful when following the forgetful inheritance\npattern when creating type synonyms.\n\nImportant Note: if `Œ±` is some synonym of a type `Œ≤` (at default transparency), and `f : Œ± ‚âÉ Œ≤` is\nsome bilipschitz equivalence, then instead of writing:\n```\ninstance : Bornology Œ± := inferInstanceAs (Bornology Œ≤)\n```\nUsers should instead write something like:\n```\ninstance : Bornology Œ± := Bornology.induced (f : Œ± ‚Üí Œ≤)\n```\nin order to avoid abuse of the definitional equality `Œ± := Œ≤`. -/\nlemma isBounded_iff_of_bilipschitz (hf‚ÇÅ : AntilipschitzWith K‚ÇÅ f) (hf‚ÇÇ : LipschitzWith K‚ÇÇ f)\n    (s : Set Œ±) : @IsBounded _ (induced f) s ‚Üî Bornology.IsBounded s :=\n  Filter.ext_iff.1 (bornology_eq_of_bilipschitz hf‚ÇÅ hf‚ÇÇ) (s·∂ú)\n\n"}
