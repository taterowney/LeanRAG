{"name":"CategoryTheory.SimplicialThickening.Path.mk.injEq","module":"Mathlib.AlgebraicTopology.SimplicialNerve","initialProofState":"J : Type u_1\ninst✝ : LinearOrder J\ni j : J\nI✝ : Set J\nleft✝ : autoParam (Membership.mem I✝ i) _auto✝\nright✝ : autoParam (Membership.mem I✝ j) _auto✝\nleft_le✝ : autoParam (∀ (k : J), Membership.mem I✝ k → LE.le i k) _auto✝\nle_right✝ : autoParam (∀ (k : J), Membership.mem I✝ k → LE.le k j) _auto✝\nI : Set J\nleft : autoParam (Membership.mem I i) _auto✝\nright : autoParam (Membership.mem I j) _auto✝\nleft_le : autoParam (∀ (k : J), Membership.mem I k → LE.le i k) _auto✝\nle_right : autoParam (∀ (k : J), Membership.mem I k → LE.le k j) _auto✝\n⊢ Eq (Eq { I := I✝, left := left✝, right := right✝, left_le := left_le✝, le_right := le_right✝ } { I := I, left := left, right := right, left_le := left_le, le_right := le_right }) (Eq I✝ I)","decl":"/--\nA path from `i` to `j` in a linear order `J` is a subset of the interval `[i, j]` in `J` containing\nthe endpoints.\n-/\n@[ext]\nstructure Path {J : Type*} [LinearOrder J] (i j : J) where\n  /-- The underlying subset -/\n  I : Set J\n  left : i ∈ I := by simp\n  right : j ∈ I := by simp\n  left_le (k : J) (_ : k ∈ I) : i ≤ k := by simp\n  le_right (k : J) (_ : k ∈ I) : k ≤ j := by simp\n\n"}
{"name":"CategoryTheory.SimplicialThickening.Path.mk.inj","module":"Mathlib.AlgebraicTopology.SimplicialNerve","initialProofState":"J : Type u_1\ninst✝ : LinearOrder J\ni j : J\nI✝ : Set J\nleft✝ : autoParam (Membership.mem I✝ i) _auto✝\nright✝ : autoParam (Membership.mem I✝ j) _auto✝\nleft_le✝ : autoParam (∀ (k : J), Membership.mem I✝ k → LE.le i k) _auto✝\nle_right✝ : autoParam (∀ (k : J), Membership.mem I✝ k → LE.le k j) _auto✝\nI : Set J\nleft : autoParam (Membership.mem I i) _auto✝\nright : autoParam (Membership.mem I j) _auto✝\nleft_le : autoParam (∀ (k : J), Membership.mem I k → LE.le i k) _auto✝\nle_right : autoParam (∀ (k : J), Membership.mem I k → LE.le k j) _auto✝\nx✝ : Eq { I := I✝, left := left✝, right := right✝, left_le := left_le✝, le_right := le_right✝ } { I := I, left := left, right := right, left_le := left_le, le_right := le_right }\n⊢ Eq I✝ I","decl":"/--\nA path from `i` to `j` in a linear order `J` is a subset of the interval `[i, j]` in `J` containing\nthe endpoints.\n-/\n@[ext]\nstructure Path {J : Type*} [LinearOrder J] (i j : J) where\n  /-- The underlying subset -/\n  I : Set J\n  left : i ∈ I := by simp\n  right : j ∈ I := by simp\n  left_le (k : J) (_ : k ∈ I) : i ≤ k := by simp\n  le_right (k : J) (_ : k ∈ I) : k ≤ j := by simp\n\n"}
{"name":"CategoryTheory.SimplicialThickening.Path.le_right","module":"Mathlib.AlgebraicTopology.SimplicialNerve","initialProofState":"J : Type u_1\ninst✝ : LinearOrder J\ni j : J\nself : CategoryTheory.SimplicialThickening.Path i j\nk : J\nx✝ : Membership.mem self.I k\n⊢ LE.le k j","decl":"/--\nA path from `i` to `j` in a linear order `J` is a subset of the interval `[i, j]` in `J` containing\nthe endpoints.\n-/\n@[ext]\nstructure Path {J : Type*} [LinearOrder J] (i j : J) where\n  /-- The underlying subset -/\n  I : Set J\n  left : i ∈ I := by simp\n  right : j ∈ I := by simp\n  left_le (k : J) (_ : k ∈ I) : i ≤ k := by simp\n  le_right (k : J) (_ : k ∈ I) : k ≤ j := by simp\n\n"}
{"name":"CategoryTheory.SimplicialThickening.Path.left","module":"Mathlib.AlgebraicTopology.SimplicialNerve","initialProofState":"J : Type u_1\ninst✝ : LinearOrder J\ni j : J\nself : CategoryTheory.SimplicialThickening.Path i j\n⊢ Membership.mem self.I i","decl":"/--\nA path from `i` to `j` in a linear order `J` is a subset of the interval `[i, j]` in `J` containing\nthe endpoints.\n-/\n@[ext]\nstructure Path {J : Type*} [LinearOrder J] (i j : J) where\n  /-- The underlying subset -/\n  I : Set J\n  left : i ∈ I := by simp\n  right : j ∈ I := by simp\n  left_le (k : J) (_ : k ∈ I) : i ≤ k := by simp\n  le_right (k : J) (_ : k ∈ I) : k ≤ j := by simp\n\n"}
{"name":"CategoryTheory.SimplicialThickening.Path.ext_iff","module":"Mathlib.AlgebraicTopology.SimplicialNerve","initialProofState":"J : Type u_1\ninst✝ : LinearOrder J\ni j : J\nx y : CategoryTheory.SimplicialThickening.Path i j\n⊢ Iff (Eq x y) (Eq x.I y.I)","decl":"/--\nA path from `i` to `j` in a linear order `J` is a subset of the interval `[i, j]` in `J` containing\nthe endpoints.\n-/\n@[ext]\nstructure Path {J : Type*} [LinearOrder J] (i j : J) where\n  /-- The underlying subset -/\n  I : Set J\n  left : i ∈ I := by simp\n  right : j ∈ I := by simp\n  left_le (k : J) (_ : k ∈ I) : i ≤ k := by simp\n  le_right (k : J) (_ : k ∈ I) : k ≤ j := by simp\n\n"}
{"name":"CategoryTheory.SimplicialThickening.Path.ext","module":"Mathlib.AlgebraicTopology.SimplicialNerve","initialProofState":"J : Type u_1\ninst✝ : LinearOrder J\ni j : J\nx y : CategoryTheory.SimplicialThickening.Path i j\nI : Eq x.I y.I\n⊢ Eq x y","decl":"/--\nA path from `i` to `j` in a linear order `J` is a subset of the interval `[i, j]` in `J` containing\nthe endpoints.\n-/\n@[ext]\nstructure Path {J : Type*} [LinearOrder J] (i j : J) where\n  /-- The underlying subset -/\n  I : Set J\n  left : i ∈ I := by simp\n  right : j ∈ I := by simp\n  left_le (k : J) (_ : k ∈ I) : i ≤ k := by simp\n  le_right (k : J) (_ : k ∈ I) : k ≤ j := by simp\n\n"}
{"name":"CategoryTheory.SimplicialThickening.Path.right","module":"Mathlib.AlgebraicTopology.SimplicialNerve","initialProofState":"J : Type u_1\ninst✝ : LinearOrder J\ni j : J\nself : CategoryTheory.SimplicialThickening.Path i j\n⊢ Membership.mem self.I j","decl":"/--\nA path from `i` to `j` in a linear order `J` is a subset of the interval `[i, j]` in `J` containing\nthe endpoints.\n-/\n@[ext]\nstructure Path {J : Type*} [LinearOrder J] (i j : J) where\n  /-- The underlying subset -/\n  I : Set J\n  left : i ∈ I := by simp\n  right : j ∈ I := by simp\n  left_le (k : J) (_ : k ∈ I) : i ≤ k := by simp\n  le_right (k : J) (_ : k ∈ I) : k ≤ j := by simp\n\n"}
{"name":"CategoryTheory.SimplicialThickening.Path.mk.sizeOf_spec","module":"Mathlib.AlgebraicTopology.SimplicialNerve","initialProofState":"J : Type u_1\ninst✝¹ : LinearOrder J\ni j : J\ninst✝ : SizeOf J\nI : Set J\nleft : autoParam (Membership.mem I i) _auto✝\nright : autoParam (Membership.mem I j) _auto✝\nleft_le : autoParam (∀ (k : J), Membership.mem I k → LE.le i k) _auto✝\nle_right : autoParam (∀ (k : J), Membership.mem I k → LE.le k j) _auto✝\n⊢ Eq (SizeOf.sizeOf { I := I, left := left, right := right, left_le := left_le, le_right := le_right }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf left)) (SizeOf.sizeOf right))","decl":"/--\nA path from `i` to `j` in a linear order `J` is a subset of the interval `[i, j]` in `J` containing\nthe endpoints.\n-/\n@[ext]\nstructure Path {J : Type*} [LinearOrder J] (i j : J) where\n  /-- The underlying subset -/\n  I : Set J\n  left : i ∈ I := by simp\n  right : j ∈ I := by simp\n  left_le (k : J) (_ : k ∈ I) : i ≤ k := by simp\n  le_right (k : J) (_ : k ∈ I) : k ≤ j := by simp\n\n"}
{"name":"CategoryTheory.SimplicialThickening.Path.left_le","module":"Mathlib.AlgebraicTopology.SimplicialNerve","initialProofState":"J : Type u_1\ninst✝ : LinearOrder J\ni j : J\nself : CategoryTheory.SimplicialThickening.Path i j\nk : J\nx✝ : Membership.mem self.I k\n⊢ LE.le i k","decl":"/--\nA path from `i` to `j` in a linear order `J` is a subset of the interval `[i, j]` in `J` containing\nthe endpoints.\n-/\n@[ext]\nstructure Path {J : Type*} [LinearOrder J] (i j : J) where\n  /-- The underlying subset -/\n  I : Set J\n  left : i ∈ I := by simp\n  right : j ∈ I := by simp\n  left_le (k : J) (_ : k ∈ I) : i ≤ k := by simp\n  le_right (k : J) (_ : k ∈ I) : k ≤ j := by simp\n\n"}
{"name":"CategoryTheory.SimplicialThickening.Path.le","module":"Mathlib.AlgebraicTopology.SimplicialNerve","initialProofState":"J : Type u_1\ninst✝ : LinearOrder J\ni j : J\nf : CategoryTheory.SimplicialThickening.Path i j\n⊢ LE.le i j","decl":"lemma Path.le {J : Type*} [LinearOrder J] {i j : J} (f : Path i j) : i ≤ j :=\n  f.left_le _ f.right\n\n"}
{"name":"CategoryTheory.SimplicialThickening.instCategoryStruct_id_I","module":"Mathlib.AlgebraicTopology.SimplicialNerve","initialProofState":"J : Type u_1\ninst✝ : LinearOrder J\ni : CategoryTheory.SimplicialThickening J\n⊢ Eq (CategoryTheory.CategoryStruct.id i).I (Singleton.singleton i)","decl":"@[simps]\ninstance (J : Type*) [LinearOrder J] : CategoryStruct (SimplicialThickening J) where\n  Hom i j := Path i j\n  id i := { I := {i} }\n  comp {i j k} f g := {\n    I := f.I ∪ g.I\n    left := Or.inl f.left\n    right := Or.inr g.right\n    left_le l := by\n      rintro (h | h)\n      exacts [(f.left_le l h), (Path.le f).trans (g.left_le l h)]\n    le_right l := by\n      rintro (h | h)\n      exacts [(f.le_right _ h).trans (Path.le g), (g.le_right l h)] }\n\n"}
{"name":"CategoryTheory.SimplicialThickening.instCategoryStruct_Hom","module":"Mathlib.AlgebraicTopology.SimplicialNerve","initialProofState":"J : Type u_1\ninst✝ : LinearOrder J\ni j : CategoryTheory.SimplicialThickening J\n⊢ Eq (Quiver.Hom i j) (CategoryTheory.SimplicialThickening.Path i j)","decl":"@[simps]\ninstance (J : Type*) [LinearOrder J] : CategoryStruct (SimplicialThickening J) where\n  Hom i j := Path i j\n  id i := { I := {i} }\n  comp {i j k} f g := {\n    I := f.I ∪ g.I\n    left := Or.inl f.left\n    right := Or.inr g.right\n    left_le l := by\n      rintro (h | h)\n      exacts [(f.left_le l h), (Path.le f).trans (g.left_le l h)]\n    le_right l := by\n      rintro (h | h)\n      exacts [(f.le_right _ h).trans (Path.le g), (g.le_right l h)] }\n\n"}
{"name":"CategoryTheory.SimplicialThickening.instCategoryStruct_comp_I","module":"Mathlib.AlgebraicTopology.SimplicialNerve","initialProofState":"J : Type u_1\ninst✝ : LinearOrder J\ni j k : CategoryTheory.SimplicialThickening J\nf : Quiver.Hom i j\ng : Quiver.Hom j k\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).I (Union.union f.I g.I)","decl":"@[simps]\ninstance (J : Type*) [LinearOrder J] : CategoryStruct (SimplicialThickening J) where\n  Hom i j := Path i j\n  id i := { I := {i} }\n  comp {i j k} f g := {\n    I := f.I ∪ g.I\n    left := Or.inl f.left\n    right := Or.inr g.right\n    left_le l := by\n      rintro (h | h)\n      exacts [(f.left_le l h), (Path.le f).trans (g.left_le l h)]\n    le_right l := by\n      rintro (h | h)\n      exacts [(f.le_right _ h).trans (Path.le g), (g.le_right l h)] }\n\n"}
{"name":"CategoryTheory.SimplicialThickening.hom_ext","module":"Mathlib.AlgebraicTopology.SimplicialNerve","initialProofState":"J : Type u_1\ninst✝ : LinearOrder J\ni j : CategoryTheory.SimplicialThickening J\nx y : Quiver.Hom i j\nh : ∀ (t : CategoryTheory.SimplicialThickening J), Iff (Membership.mem x.I t) (Membership.mem y.I t)\n⊢ Eq x y","decl":"@[ext]\nlemma hom_ext {J : Type*} [LinearOrder J]\n    (i j : SimplicialThickening J) (x y : i ⟶ j) (h : ∀ t, t ∈ x.I ↔ t ∈ y.I) : x = y := by\n  apply Path.ext\n  ext\n  apply h\n\n"}
{"name":"CategoryTheory.SimplicialThickening.hom_ext_iff","module":"Mathlib.AlgebraicTopology.SimplicialNerve","initialProofState":"J : Type u_1\ninst✝ : LinearOrder J\ni j : CategoryTheory.SimplicialThickening J\nx y : Quiver.Hom i j\n⊢ Iff (Eq x y) (∀ (t : CategoryTheory.SimplicialThickening J), Iff (Membership.mem x.I t) (Membership.mem y.I t))","decl":"@[ext]\nlemma hom_ext {J : Type*} [LinearOrder J]\n    (i j : SimplicialThickening J) (x y : i ⟶ j) (h : ∀ t, t ∈ x.I ↔ t ∈ y.I) : x = y := by\n  apply Path.ext\n  ext\n  apply h\n\n"}
{"name":"CategoryTheory.SimplicialThickening.compFunctor_map_down_down","module":"Mathlib.AlgebraicTopology.SimplicialNerve","initialProofState":"J : Type u_1\ninst✝ : LinearOrder J\ni j k : CategoryTheory.SimplicialThickening J\nX✝ Y✝ : Prod (Quiver.Hom i j) (Quiver.Hom j k)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ⋯ ⋯","decl":"/--\nComposition of morphisms in `SimplicialThickening J`, as a functor `(i ⟶ j) × (j ⟶ k) ⥤ (i ⟶ k)`\n-/\n@[simps]\ndef compFunctor {J : Type*} [LinearOrder J]\n    (i j k : SimplicialThickening J) : (i ⟶ j) × (j ⟶ k) ⥤ (i ⟶ k) where\n  obj x := x.1 ≫ x.2\n  map f := ⟨⟨Set.union_subset_union f.1.1.1 f.2.1.1⟩⟩\n\n"}
{"name":"CategoryTheory.SimplicialThickening.compFunctor_obj","module":"Mathlib.AlgebraicTopology.SimplicialNerve","initialProofState":"J : Type u_1\ninst✝ : LinearOrder J\ni j k : CategoryTheory.SimplicialThickening J\nx : Prod (Quiver.Hom i j) (Quiver.Hom j k)\n⊢ Eq ((i.compFunctor j k).obj x) (CategoryTheory.CategoryStruct.comp x.1 x.2)","decl":"/--\nComposition of morphisms in `SimplicialThickening J`, as a functor `(i ⟶ j) × (j ⟶ k) ⥤ (i ⟶ k)`\n-/\n@[simps]\ndef compFunctor {J : Type*} [LinearOrder J]\n    (i j k : SimplicialThickening J) : (i ⟶ j) × (j ⟶ k) ⥤ (i ⟶ k) where\n  obj x := x.1 ≫ x.2\n  map f := ⟨⟨Set.union_subset_union f.1.1.1 f.2.1.1⟩⟩\n\n"}
{"name":"CategoryTheory.SimplicialThickening.SimplicialCategory.id_comp","module":"Mathlib.AlgebraicTopology.SimplicialNerve","initialProofState":"J : Type u_1\ninst✝ : LinearOrder J\ni j : CategoryTheory.SimplicialThickening J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.SimplicialThickening.SimplicialCategory.Hom i j)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.SimplicialThickening.SimplicialCategory.id i) (CategoryTheory.SimplicialThickening.SimplicialCategory.Hom i j)) (CategoryTheory.SimplicialThickening.SimplicialCategory.comp i i j))) (CategoryTheory.CategoryStruct.id (CategoryTheory.SimplicialThickening.SimplicialCategory.Hom i j))","decl":"@[simp]\nlemma id_comp (i j : SimplicialThickening J) :\n    (λ_ (Hom i j)).inv ≫ id i ▷ Hom i j ≫ comp i i j = 𝟙 (Hom i j) := by\n  rw [Iso.inv_comp_eq]\n  ext\n  exact Functor.ext (fun _ ↦ by simp)\n\n"}
{"name":"CategoryTheory.SimplicialThickening.SimplicialCategory.comp_id","module":"Mathlib.AlgebraicTopology.SimplicialNerve","initialProofState":"J : Type u_1\ninst✝ : LinearOrder J\ni j : CategoryTheory.SimplicialThickening J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.SimplicialThickening.SimplicialCategory.Hom i j)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.SimplicialThickening.SimplicialCategory.Hom i j) (CategoryTheory.SimplicialThickening.SimplicialCategory.id j)) (CategoryTheory.SimplicialThickening.SimplicialCategory.comp i j j))) (CategoryTheory.CategoryStruct.id (CategoryTheory.SimplicialThickening.SimplicialCategory.Hom i j))","decl":"@[simp]\nlemma comp_id (i j : SimplicialThickening J) :\n    (ρ_ (Hom i j)).inv ≫ Hom i j ◁ id j ≫ comp i j j = 𝟙 (Hom i j) := by\n  rw [Iso.inv_comp_eq]\n  ext\n  exact Functor.ext (fun _ ↦ by simp)\n\n"}
{"name":"CategoryTheory.SimplicialThickening.SimplicialCategory.assoc","module":"Mathlib.AlgebraicTopology.SimplicialNerve","initialProofState":"J : Type u_1\ninst✝ : LinearOrder J\ni j k l : CategoryTheory.SimplicialThickening J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.SimplicialThickening.SimplicialCategory.Hom i j) (CategoryTheory.SimplicialThickening.SimplicialCategory.Hom j k) (CategoryTheory.SimplicialThickening.SimplicialCategory.Hom k l)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.SimplicialThickening.SimplicialCategory.comp i j k) (CategoryTheory.SimplicialThickening.SimplicialCategory.Hom k l)) (CategoryTheory.SimplicialThickening.SimplicialCategory.comp i k l))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.SimplicialThickening.SimplicialCategory.Hom i j) (CategoryTheory.SimplicialThickening.SimplicialCategory.comp j k l)) (CategoryTheory.SimplicialThickening.SimplicialCategory.comp i j l))","decl":"@[simp]\nlemma assoc (i j k l : SimplicialThickening J) :\n    (α_ (Hom i j) (Hom j k) (Hom k l)).inv ≫ comp i j k ▷ Hom k l ≫ comp i k l =\n      Hom i j ◁ comp j k l ≫ comp i j l := by\n  ext\n  exact Functor.ext (fun _ ↦ by simp)\n\n"}
{"name":"CategoryTheory.SimplicialThickening.functor_map","module":"Mathlib.AlgebraicTopology.SimplicialNerve","initialProofState":"J K : Type u\ninst✝¹ : LinearOrder J\ninst✝ : LinearOrder K\nf : OrderHom J K\ni j : CategoryTheory.SimplicialThickening J\n⊢ Eq ((CategoryTheory.SimplicialThickening.functor f).map i j) (CategoryTheory.nerveMap (CategoryTheory.SimplicialThickening.functorMap f i j))","decl":"/--\nThe simplicial thickening defines a functor from the category of linear orders to the category of\nsimplicial categories\n-/\n@[simps]\nnoncomputable def functor {J K : Type u} [LinearOrder J] [LinearOrder K]\n    (f : J →o K) : EnrichedFunctor SSet (SimplicialThickening J) (SimplicialThickening K) where\n  obj := f\n  map i j := nerveMap ((functorMap f i j))\n  map_id i := by\n    ext\n    simp only [eId, EnrichedCategory.id]\n    exact Functor.ext (by aesop_cat)\n  map_comp i j k := by\n    ext\n    simp only [eComp, EnrichedCategory.comp]\n    exact Functor.ext (by aesop_cat)\n\n"}
{"name":"CategoryTheory.SimplicialThickening.functor_obj","module":"Mathlib.AlgebraicTopology.SimplicialNerve","initialProofState":"J K : Type u\ninst✝¹ : LinearOrder J\ninst✝ : LinearOrder K\nf : OrderHom J K\na : J\n⊢ Eq ((CategoryTheory.SimplicialThickening.functor f).obj a) (f a)","decl":"/--\nThe simplicial thickening defines a functor from the category of linear orders to the category of\nsimplicial categories\n-/\n@[simps]\nnoncomputable def functor {J K : Type u} [LinearOrder J] [LinearOrder K]\n    (f : J →o K) : EnrichedFunctor SSet (SimplicialThickening J) (SimplicialThickening K) where\n  obj := f\n  map i j := nerveMap ((functorMap f i j))\n  map_id i := by\n    ext\n    simp only [eId, EnrichedCategory.id]\n    exact Functor.ext (by aesop_cat)\n  map_comp i j k := by\n    ext\n    simp only [eComp, EnrichedCategory.comp]\n    exact Functor.ext (by aesop_cat)\n\n"}
{"name":"CategoryTheory.SimplicialThickening.functor_id","module":"Mathlib.AlgebraicTopology.SimplicialNerve","initialProofState":"J : Type u\ninst✝ : LinearOrder J\n⊢ Eq (CategoryTheory.SimplicialThickening.functor OrderHom.id) (CategoryTheory.EnrichedFunctor.id SSet (CategoryTheory.SimplicialThickening J))","decl":"lemma functor_id (J : Type u) [LinearOrder J] :\n    (functor (OrderHom.id (α := J))) = EnrichedFunctor.id _ _ := by\n  refine EnrichedFunctor.ext _ (fun _ ↦ rfl) fun i j ↦ ?_\n  ext\n  exact Functor.ext (by aesop_cat)\n\n"}
{"name":"CategoryTheory.SimplicialThickening.functor_comp","module":"Mathlib.AlgebraicTopology.SimplicialNerve","initialProofState":"J K L : Type u\ninst✝² : LinearOrder J\ninst✝¹ : LinearOrder K\ninst✝ : LinearOrder L\nf : OrderHom J K\ng : OrderHom K L\n⊢ Eq (CategoryTheory.SimplicialThickening.functor (g.comp f)) (CategoryTheory.EnrichedFunctor.comp SSet (CategoryTheory.SimplicialThickening.functor f) (CategoryTheory.SimplicialThickening.functor g))","decl":"lemma functor_comp {J K L : Type u} [LinearOrder J] [LinearOrder K]\n    [LinearOrder L] (f : J →o K) (g : K →o L) :\n    functor (g.comp f) =\n      (functor f).comp _ (functor g) := by\n  refine EnrichedFunctor.ext _ (fun _ ↦ rfl) fun i j ↦ ?_\n  ext\n  exact Functor.ext (by aesop_cat)\n\n"}
