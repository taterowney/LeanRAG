{"name":"Nat.comap_cast_atTop","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"R : Type u_2\ninst✝¹ : StrictOrderedSemiring R\ninst✝ : Archimedean R\n⊢ Eq (Filter.comap Nat.cast Filter.atTop) Filter.atTop","decl":"@[simp]\ntheorem Nat.comap_cast_atTop [StrictOrderedSemiring R] [Archimedean R] :\n    comap ((↑) : ℕ → R) atTop = atTop :=\n  comap_embedding_atTop (fun _ _ => Nat.cast_le) exists_nat_ge\n\n"}
{"name":"tendsto_natCast_atTop_iff","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"α : Type u_1\nR : Type u_2\ninst✝¹ : StrictOrderedSemiring R\ninst✝ : Archimedean R\nf : α → Nat\nl : Filter α\n⊢ Iff (Filter.Tendsto (fun n => ↑(f n)) l Filter.atTop) (Filter.Tendsto f l Filter.atTop)","decl":"theorem tendsto_natCast_atTop_iff [StrictOrderedSemiring R] [Archimedean R] {f : α → ℕ}\n    {l : Filter α} : Tendsto (fun n => (f n : R)) l atTop ↔ Tendsto f l atTop :=\n  tendsto_atTop_embedding (fun _ _ => Nat.cast_le) exists_nat_ge\n\n"}
{"name":"tendsto_natCast_atTop_atTop","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"R : Type u_2\ninst✝¹ : OrderedSemiring R\ninst✝ : Archimedean R\n⊢ Filter.Tendsto Nat.cast Filter.atTop Filter.atTop","decl":"theorem tendsto_natCast_atTop_atTop [OrderedSemiring R] [Archimedean R] :\n    Tendsto ((↑) : ℕ → R) atTop atTop :=\n  Nat.mono_cast.tendsto_atTop_atTop exists_nat_ge\n\n"}
{"name":"Filter.Eventually.natCast_atTop","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"R : Type u_2\ninst✝¹ : OrderedSemiring R\ninst✝ : Archimedean R\np : R → Prop\nh : Filter.Eventually (fun x => p x) Filter.atTop\n⊢ Filter.Eventually (fun n => p ↑n) Filter.atTop","decl":"theorem Filter.Eventually.natCast_atTop [OrderedSemiring R] [Archimedean R] {p : R → Prop}\n    (h : ∀ᶠ (x : R) in atTop, p x) : ∀ᶠ (n : ℕ) in atTop, p n :=\n  tendsto_natCast_atTop_atTop.eventually h\n\n"}
{"name":"Int.comap_cast_atTop","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"R : Type u_2\ninst✝¹ : StrictOrderedRing R\ninst✝ : Archimedean R\n⊢ Eq (Filter.comap Int.cast Filter.atTop) Filter.atTop","decl":"@[simp] theorem Int.comap_cast_atTop [StrictOrderedRing R] [Archimedean R] :\n    comap ((↑) : ℤ → R) atTop = atTop :=\n  comap_embedding_atTop (fun _ _ => Int.cast_le) fun r =>\n    let ⟨n, hn⟩ := exists_nat_ge r; ⟨n, mod_cast hn⟩\n\n"}
{"name":"Int.comap_cast_atBot","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"R : Type u_2\ninst✝¹ : StrictOrderedRing R\ninst✝ : Archimedean R\n⊢ Eq (Filter.comap Int.cast Filter.atBot) Filter.atBot","decl":"@[simp]\ntheorem Int.comap_cast_atBot [StrictOrderedRing R] [Archimedean R] :\n    comap ((↑) : ℤ → R) atBot = atBot :=\n  comap_embedding_atBot (fun _ _ => Int.cast_le) fun r =>\n    let ⟨n, hn⟩ := exists_nat_ge (-r)\n    ⟨-n, by simpa [neg_le] using hn⟩\n\n"}
{"name":"tendsto_intCast_atTop_iff","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"α : Type u_1\nR : Type u_2\ninst✝¹ : StrictOrderedRing R\ninst✝ : Archimedean R\nf : α → Int\nl : Filter α\n⊢ Iff (Filter.Tendsto (fun n => ↑(f n)) l Filter.atTop) (Filter.Tendsto f l Filter.atTop)","decl":"theorem tendsto_intCast_atTop_iff [StrictOrderedRing R] [Archimedean R] {f : α → ℤ}\n    {l : Filter α} : Tendsto (fun n => (f n : R)) l atTop ↔ Tendsto f l atTop := by\n  rw [← @Int.comap_cast_atTop R, tendsto_comap_iff]; rfl\n\n"}
{"name":"tendsto_intCast_atBot_iff","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"α : Type u_1\nR : Type u_2\ninst✝¹ : StrictOrderedRing R\ninst✝ : Archimedean R\nf : α → Int\nl : Filter α\n⊢ Iff (Filter.Tendsto (fun n => ↑(f n)) l Filter.atBot) (Filter.Tendsto f l Filter.atBot)","decl":"theorem tendsto_intCast_atBot_iff [StrictOrderedRing R] [Archimedean R] {f : α → ℤ}\n    {l : Filter α} : Tendsto (fun n => (f n : R)) l atBot ↔ Tendsto f l atBot := by\n  rw [← @Int.comap_cast_atBot R, tendsto_comap_iff]; rfl\n\n"}
{"name":"tendsto_intCast_atTop_atTop","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"R : Type u_2\ninst✝¹ : StrictOrderedRing R\ninst✝ : Archimedean R\n⊢ Filter.Tendsto Int.cast Filter.atTop Filter.atTop","decl":"theorem tendsto_intCast_atTop_atTop [StrictOrderedRing R] [Archimedean R] :\n    Tendsto ((↑) : ℤ → R) atTop atTop :=\n  tendsto_intCast_atTop_iff.2 tendsto_id\n\n"}
{"name":"Filter.Eventually.intCast_atTop","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"R : Type u_2\ninst✝¹ : StrictOrderedRing R\ninst✝ : Archimedean R\np : R → Prop\nh : Filter.Eventually (fun x => p x) Filter.atTop\n⊢ Filter.Eventually (fun n => p ↑n) Filter.atTop","decl":"theorem Filter.Eventually.intCast_atTop [StrictOrderedRing R] [Archimedean R] {p : R → Prop}\n    (h : ∀ᶠ (x : R) in atTop, p x) : ∀ᶠ (n : ℤ) in atTop, p n := by\n  rw [← Int.comap_cast_atTop (R := R)]; exact h.comap _\n\n"}
{"name":"Filter.Eventually.intCast_atBot","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"R : Type u_2\ninst✝¹ : StrictOrderedRing R\ninst✝ : Archimedean R\np : R → Prop\nh : Filter.Eventually (fun x => p x) Filter.atBot\n⊢ Filter.Eventually (fun n => p ↑n) Filter.atBot","decl":"theorem Filter.Eventually.intCast_atBot [StrictOrderedRing R] [Archimedean R] {p : R → Prop}\n    (h : ∀ᶠ (x : R) in atBot, p x) : ∀ᶠ (n : ℤ) in atBot, p n := by\n  rw [← Int.comap_cast_atBot (R := R)]; exact h.comap _\n\n"}
{"name":"Rat.comap_cast_atTop","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"R : Type u_2\ninst✝¹ : LinearOrderedField R\ninst✝ : Archimedean R\n⊢ Eq (Filter.comap Rat.cast Filter.atTop) Filter.atTop","decl":"@[simp]\ntheorem Rat.comap_cast_atTop [LinearOrderedField R] [Archimedean R] :\n    comap ((↑) : ℚ → R) atTop = atTop :=\n  comap_embedding_atTop (fun _ _ => Rat.cast_le) fun r =>\n    let ⟨n, hn⟩ := exists_nat_ge r; ⟨n, by simpa⟩\n\n"}
{"name":"Rat.comap_cast_atBot","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"R : Type u_2\ninst✝¹ : LinearOrderedField R\ninst✝ : Archimedean R\n⊢ Eq (Filter.comap Rat.cast Filter.atBot) Filter.atBot","decl":"@[simp] theorem Rat.comap_cast_atBot [LinearOrderedField R] [Archimedean R] :\n    comap ((↑) : ℚ → R) atBot = atBot :=\n  comap_embedding_atBot (fun _ _ => Rat.cast_le) fun r =>\n    let ⟨n, hn⟩ := exists_nat_ge (-r)\n    ⟨-n, by simpa [neg_le]⟩\n\n"}
{"name":"tendsto_ratCast_atTop_iff","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"α : Type u_1\nR : Type u_2\ninst✝¹ : LinearOrderedField R\ninst✝ : Archimedean R\nf : α → Rat\nl : Filter α\n⊢ Iff (Filter.Tendsto (fun n => ↑(f n)) l Filter.atTop) (Filter.Tendsto f l Filter.atTop)","decl":"theorem tendsto_ratCast_atTop_iff [LinearOrderedField R] [Archimedean R] {f : α → ℚ}\n    {l : Filter α} : Tendsto (fun n => (f n : R)) l atTop ↔ Tendsto f l atTop := by\n  rw [← @Rat.comap_cast_atTop R, tendsto_comap_iff]; rfl\n\n"}
{"name":"tendsto_ratCast_atBot_iff","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"α : Type u_1\nR : Type u_2\ninst✝¹ : LinearOrderedField R\ninst✝ : Archimedean R\nf : α → Rat\nl : Filter α\n⊢ Iff (Filter.Tendsto (fun n => ↑(f n)) l Filter.atBot) (Filter.Tendsto f l Filter.atBot)","decl":"theorem tendsto_ratCast_atBot_iff [LinearOrderedField R] [Archimedean R] {f : α → ℚ}\n    {l : Filter α} : Tendsto (fun n => (f n : R)) l atBot ↔ Tendsto f l atBot := by\n  rw [← @Rat.comap_cast_atBot R, tendsto_comap_iff]; rfl\n\n"}
{"name":"Filter.Eventually.ratCast_atTop","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"R : Type u_2\ninst✝¹ : LinearOrderedField R\ninst✝ : Archimedean R\np : R → Prop\nh : Filter.Eventually (fun x => p x) Filter.atTop\n⊢ Filter.Eventually (fun n => p ↑n) Filter.atTop","decl":"theorem Filter.Eventually.ratCast_atTop [LinearOrderedField R] [Archimedean R] {p : R → Prop}\n    (h : ∀ᶠ (x : R) in atTop, p x) : ∀ᶠ (n : ℚ) in atTop, p n := by\n  rw [← Rat.comap_cast_atTop (R := R)]; exact h.comap _\n\n"}
{"name":"Filter.Eventually.ratCast_atBot","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"R : Type u_2\ninst✝¹ : LinearOrderedField R\ninst✝ : Archimedean R\np : R → Prop\nh : Filter.Eventually (fun x => p x) Filter.atBot\n⊢ Filter.Eventually (fun n => p ↑n) Filter.atBot","decl":"theorem Filter.Eventually.ratCast_atBot [LinearOrderedField R] [Archimedean R] {p : R → Prop}\n    (h : ∀ᶠ (x : R) in atBot, p x) : ∀ᶠ (n : ℚ) in atBot, p n := by\n  rw [← Rat.comap_cast_atBot (R := R)]; exact h.comap _\n\n"}
{"name":"atTop_hasAntitoneBasis_of_archimedean","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"R : Type u_2\ninst✝¹ : OrderedSemiring R\ninst✝ : Archimedean R\n⊢ Filter.atTop.HasAntitoneBasis fun n => Set.Ici ↑n","decl":"theorem atTop_hasAntitoneBasis_of_archimedean [OrderedSemiring R] [Archimedean R] :\n    (atTop : Filter R).HasAntitoneBasis fun n : ℕ => Ici n :=\n  hasAntitoneBasis_atTop.comp_mono Nat.mono_cast tendsto_natCast_atTop_atTop\n\n"}
{"name":"atTop_hasCountableBasis_of_archimedean","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"R : Type u_2\ninst✝¹ : OrderedSemiring R\ninst✝ : Archimedean R\n⊢ Filter.atTop.HasCountableBasis (fun x => True) fun n => Set.Ici ↑n","decl":"theorem atTop_hasCountableBasis_of_archimedean [OrderedSemiring R] [Archimedean R] :\n    (atTop : Filter R).HasCountableBasis (fun _ : ℕ => True) fun n => Ici n :=\n  ⟨atTop_hasAntitoneBasis_of_archimedean.1, to_countable _⟩\n\n"}
{"name":"atBot_hasCountableBasis_of_archimedean","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"R : Type u_2\ninst✝¹ : OrderedRing R\ninst✝ : Archimedean R\n⊢ Filter.atBot.HasCountableBasis (fun x => True) fun m => Set.Iic ↑m","decl":"theorem atBot_hasCountableBasis_of_archimedean [OrderedRing R] [Archimedean R] :\n    (atBot : Filter R).HasCountableBasis (fun _ : ℤ => True) fun m => Iic m where\n  countable := to_countable _\n  toHasBasis :=\n    atBot_basis.to_hasBasis\n      (fun x _ => let ⟨m, hm⟩ := exists_int_le x; ⟨m, trivial, Iic_subset_Iic.2 hm⟩)\n      fun m _ => ⟨m, trivial, Subset.rfl⟩\n\n"}
{"name":"atTop_isCountablyGenerated_of_archimedean","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"R : Type u_2\ninst✝¹ : OrderedSemiring R\ninst✝ : Archimedean R\n⊢ Filter.atTop.IsCountablyGenerated","decl":"instance (priority := 100) atTop_isCountablyGenerated_of_archimedean [OrderedSemiring R]\n    [Archimedean R] : (atTop : Filter R).IsCountablyGenerated :=\n  atTop_hasCountableBasis_of_archimedean.isCountablyGenerated\n\n"}
{"name":"atBot_isCountablyGenerated_of_archimedean","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"R : Type u_2\ninst✝¹ : OrderedRing R\ninst✝ : Archimedean R\n⊢ Filter.atBot.IsCountablyGenerated","decl":"instance (priority := 100) atBot_isCountablyGenerated_of_archimedean [OrderedRing R]\n    [Archimedean R] : (atBot : Filter R).IsCountablyGenerated :=\n  atBot_hasCountableBasis_of_archimedean.isCountablyGenerated\n\n"}
{"name":"Filter.Tendsto.const_mul_atTop'","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"α : Type u_1\nR : Type u_2\nl : Filter α\nf : α → R\nr : R\ninst✝¹ : LinearOrderedSemiring R\ninst✝ : Archimedean R\nhr : LT.lt 0 r\nhf : Filter.Tendsto f l Filter.atTop\n⊢ Filter.Tendsto (fun x => HMul.hMul r (f x)) l Filter.atTop","decl":"/-- If a function tends to infinity along a filter, then this function multiplied by a positive\nconstant (on the left) also tends to infinity. The archimedean assumption is convenient to get a\nstatement that works on `ℕ`, `ℤ` and `ℝ`, although not necessary (a version in ordered fields is\ngiven in `Filter.Tendsto.const_mul_atTop`). -/\ntheorem Tendsto.const_mul_atTop' (hr : 0 < r) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => r * f x) l atTop := by\n  refine tendsto_atTop.2 fun b => ?_\n  obtain ⟨n : ℕ, hn : 1 ≤ n • r⟩ := Archimedean.arch 1 hr\n  rw [nsmul_eq_mul'] at hn\n  filter_upwards [tendsto_atTop.1 hf (n * max b 0)] with x hx\n  calc\n    b ≤ 1 * max b 0 := by\n    { rw [one_mul]\n      exact le_max_left _ _ }\n    _ ≤ r * n * max b 0 := by gcongr\n    _ = r * (n * max b 0) := by rw [mul_assoc]\n    _ ≤ r * f x := by gcongr\n\n"}
{"name":"Filter.Tendsto.atTop_mul_const'","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"α : Type u_1\nR : Type u_2\nl : Filter α\nf : α → R\nr : R\ninst✝¹ : LinearOrderedSemiring R\ninst✝ : Archimedean R\nhr : LT.lt 0 r\nhf : Filter.Tendsto f l Filter.atTop\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) r) l Filter.atTop","decl":"/-- If a function tends to infinity along a filter, then this function multiplied by a positive\nconstant (on the right) also tends to infinity. The archimedean assumption is convenient to get a\nstatement that works on `ℕ`, `ℤ` and `ℝ`, although not necessary (a version in ordered fields is\ngiven in `Filter.Tendsto.atTop_mul_const`). -/\ntheorem Tendsto.atTop_mul_const' (hr : 0 < r) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => f x * r) l atTop := by\n  refine tendsto_atTop.2 fun b => ?_\n  obtain ⟨n : ℕ, hn : 1 ≤ n • r⟩ := Archimedean.arch 1 hr\n  have hn' : 1 ≤ (n : R) * r := by rwa [nsmul_eq_mul] at hn\n  filter_upwards [tendsto_atTop.1 hf (max b 0 * n)] with x hx\n  calc\n    b ≤ max b 0 * 1 := by\n    { rw [mul_one]\n      exact le_max_left _ _ }\n    _ ≤ max b 0 * (n * r) := by gcongr\n    _ = max b 0 * n * r := by rw [mul_assoc]\n    _ ≤ f x * r := by gcongr\n\n"}
{"name":"Filter.Tendsto.atTop_mul_const_of_neg'","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"α : Type u_1\nR : Type u_2\nl : Filter α\nf : α → R\nr : R\ninst✝¹ : LinearOrderedRing R\ninst✝ : Archimedean R\nhr : LT.lt r 0\nhf : Filter.Tendsto f l Filter.atTop\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) r) l Filter.atBot","decl":"/-- See also `Filter.Tendsto.atTop_mul_const_of_neg` for a version of this lemma for\n`LinearOrderedField`s which does not require the `Archimedean` assumption. -/\ntheorem Tendsto.atTop_mul_const_of_neg' (hr : r < 0) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => f x * r) l atBot := by\n  simpa only [tendsto_neg_atTop_iff, mul_neg] using hf.atTop_mul_const' (neg_pos.mpr hr)\n\n"}
{"name":"Filter.Tendsto.atBot_mul_const'","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"α : Type u_1\nR : Type u_2\nl : Filter α\nf : α → R\nr : R\ninst✝¹ : LinearOrderedRing R\ninst✝ : Archimedean R\nhr : LT.lt 0 r\nhf : Filter.Tendsto f l Filter.atBot\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) r) l Filter.atBot","decl":"/-- See also `Filter.Tendsto.atBot_mul_const` for a version of this lemma for\n`LinearOrderedField`s which does not require the `Archimedean` assumption. -/\ntheorem Tendsto.atBot_mul_const' (hr : 0 < r) (hf : Tendsto f l atBot) :\n    Tendsto (fun x => f x * r) l atBot := by\n  simp only [← tendsto_neg_atTop_iff, ← neg_mul] at hf ⊢\n  exact hf.atTop_mul_const' hr\n\n"}
{"name":"Filter.Tendsto.atBot_mul_const_of_neg'","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"α : Type u_1\nR : Type u_2\nl : Filter α\nf : α → R\nr : R\ninst✝¹ : LinearOrderedRing R\ninst✝ : Archimedean R\nhr : LT.lt r 0\nhf : Filter.Tendsto f l Filter.atBot\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) r) l Filter.atTop","decl":"/-- See also `Filter.Tendsto.atBot_mul_const_of_neg` for a version of this lemma for\n`LinearOrderedField`s which does not require the `Archimedean` assumption. -/\ntheorem Tendsto.atBot_mul_const_of_neg' (hr : r < 0) (hf : Tendsto f l atBot) :\n    Tendsto (fun x => f x * r) l atTop := by\n  simpa only [mul_neg, tendsto_neg_atBot_iff] using hf.atBot_mul_const' (neg_pos.2 hr)\n\n"}
{"name":"Filter.Tendsto.atTop_nsmul_const","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"α : Type u_1\nR : Type u_2\nl : Filter α\nr : R\ninst✝¹ : LinearOrderedCancelAddCommMonoid R\ninst✝ : Archimedean R\nf : α → Nat\nhr : LT.lt 0 r\nhf : Filter.Tendsto f l Filter.atTop\n⊢ Filter.Tendsto (fun x => HSMul.hSMul (f x) r) l Filter.atTop","decl":"theorem Tendsto.atTop_nsmul_const {f : α → ℕ} (hr : 0 < r) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => f x • r) l atTop := by\n  refine tendsto_atTop.mpr fun s => ?_\n  obtain ⟨n : ℕ, hn : s ≤ n • r⟩ := Archimedean.arch s hr\n  exact (tendsto_atTop.mp hf n).mono fun a ha => hn.trans (nsmul_le_nsmul_left hr.le ha)\n\n"}
{"name":"Filter.Tendsto.atTop_nsmul_neg_const","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"α : Type u_1\nR : Type u_2\nl : Filter α\nr : R\ninst✝¹ : LinearOrderedAddCommGroup R\ninst✝ : Archimedean R\nf : α → Nat\nhr : LT.lt r 0\nhf : Filter.Tendsto f l Filter.atTop\n⊢ Filter.Tendsto (fun x => HSMul.hSMul (f x) r) l Filter.atBot","decl":"theorem Tendsto.atTop_nsmul_neg_const {f : α → ℕ} (hr : r < 0) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => f x • r) l atBot := by simpa using hf.atTop_nsmul_const (neg_pos.2 hr)\n\n"}
{"name":"Filter.Tendsto.atTop_zsmul_const","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"α : Type u_1\nR : Type u_2\nl : Filter α\nr : R\ninst✝¹ : LinearOrderedAddCommGroup R\ninst✝ : Archimedean R\nf : α → Int\nhr : LT.lt 0 r\nhf : Filter.Tendsto f l Filter.atTop\n⊢ Filter.Tendsto (fun x => HSMul.hSMul (f x) r) l Filter.atTop","decl":"theorem Tendsto.atTop_zsmul_const {f : α → ℤ} (hr : 0 < r) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => f x • r) l atTop := by\n  refine tendsto_atTop.mpr fun s => ?_\n  obtain ⟨n : ℕ, hn : s ≤ n • r⟩ := Archimedean.arch s hr\n  replace hn : s ≤ (n : ℤ) • r := by simpa\n  exact (tendsto_atTop.mp hf n).mono fun a ha => hn.trans (zsmul_le_zsmul_left hr.le ha)\n\n"}
{"name":"Filter.Tendsto.atTop_zsmul_neg_const","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"α : Type u_1\nR : Type u_2\nl : Filter α\nr : R\ninst✝¹ : LinearOrderedAddCommGroup R\ninst✝ : Archimedean R\nf : α → Int\nhr : LT.lt r 0\nhf : Filter.Tendsto f l Filter.atTop\n⊢ Filter.Tendsto (fun x => HSMul.hSMul (f x) r) l Filter.atBot","decl":"theorem Tendsto.atTop_zsmul_neg_const {f : α → ℤ} (hr : r < 0) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => f x • r) l atBot := by simpa using hf.atTop_zsmul_const (neg_pos.2 hr)\n\n"}
{"name":"Filter.Tendsto.atBot_zsmul_const","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"α : Type u_1\nR : Type u_2\nl : Filter α\nr : R\ninst✝¹ : LinearOrderedAddCommGroup R\ninst✝ : Archimedean R\nf : α → Int\nhr : LT.lt 0 r\nhf : Filter.Tendsto f l Filter.atBot\n⊢ Filter.Tendsto (fun x => HSMul.hSMul (f x) r) l Filter.atBot","decl":"theorem Tendsto.atBot_zsmul_const {f : α → ℤ} (hr : 0 < r) (hf : Tendsto f l atBot) :\n    Tendsto (fun x => f x • r) l atBot := by\n  simp only [← tendsto_neg_atTop_iff, ← neg_zsmul] at hf ⊢\n  exact hf.atTop_zsmul_const hr\n\n"}
{"name":"Filter.Tendsto.atBot_zsmul_neg_const","module":"Mathlib.Order.Filter.AtTopBot.Archimedean","initialProofState":"α : Type u_1\nR : Type u_2\nl : Filter α\nr : R\ninst✝¹ : LinearOrderedAddCommGroup R\ninst✝ : Archimedean R\nf : α → Int\nhr : LT.lt r 0\nhf : Filter.Tendsto f l Filter.atBot\n⊢ Filter.Tendsto (fun x => HSMul.hSMul (f x) r) l Filter.atTop","decl":"theorem Tendsto.atBot_zsmul_neg_const {f : α → ℤ} (hr : r < 0) (hf : Tendsto f l atBot) :\n    Tendsto (fun x => f x • r) l atTop := by simpa using hf.atBot_zsmul_const (neg_pos.2 hr)\n\n"}
