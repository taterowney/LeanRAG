{"name":"CategoryTheory.Limits.PullbackCone.π_app_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nc : CategoryTheory.Limits.PullbackCone f g\n⊢ Eq (c.π.app CategoryTheory.Limits.WalkingCospan.left) c.fst","decl":"@[simp]\ntheorem π_app_left (c : PullbackCone f g) : c.π.app WalkingCospan.left = c.fst := rfl\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.π_app_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nc : CategoryTheory.Limits.PullbackCone f g\n⊢ Eq (c.π.app CategoryTheory.Limits.WalkingCospan.right) c.snd","decl":"@[simp]\ntheorem π_app_right (c : PullbackCone f g) : c.π.app WalkingCospan.right = c.snd := rfl\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.condition_one","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nt : CategoryTheory.Limits.PullbackCone f g\n⊢ Eq (t.π.app CategoryTheory.Limits.WalkingCospan.one) (CategoryTheory.CategoryStruct.comp t.fst f)","decl":"@[simp]\ntheorem condition_one (t : PullbackCone f g) : t.π.app WalkingCospan.one = t.fst ≫ f := by\n  have w := t.π.naturality WalkingCospan.Hom.inl\n  dsimp at w; simpa using w\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.mk_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nW : C\nfst : Quiver.Hom W X\nsnd : Quiver.Hom W Y\neq : Eq (CategoryTheory.CategoryStruct.comp fst f) (CategoryTheory.CategoryStruct.comp snd g)\n⊢ Eq (CategoryTheory.Limits.PullbackCone.mk fst snd eq).pt W","decl":"/-- A pullback cone on `f` and `g` is determined by morphisms `fst : W ⟶ X` and `snd : W ⟶ Y`\n    such that `fst ≫ f = snd ≫ g`. -/\n@[simps]\ndef mk {W : C} (fst : W ⟶ X) (snd : W ⟶ Y) (eq : fst ≫ f = snd ≫ g) : PullbackCone f g where\n  pt := W\n  π := { app := fun j => Option.casesOn j (fst ≫ f) fun j' => WalkingPair.casesOn j' fst snd\n         naturality := by rintro (⟨⟩ | ⟨⟨⟩⟩) (⟨⟩ | ⟨⟨⟩⟩) j <;> cases j <;> dsimp <;> simp [eq] }\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.mk_π_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nW : C\nfst : Quiver.Hom W X\nsnd : Quiver.Hom W Y\neq : Eq (CategoryTheory.CategoryStruct.comp fst f) (CategoryTheory.CategoryStruct.comp snd g)\nj : CategoryTheory.Limits.WalkingCospan\n⊢ Eq ((CategoryTheory.Limits.PullbackCone.mk fst snd eq).π.app j) (Option.casesOn j (CategoryTheory.CategoryStruct.comp fst f) fun j' => CategoryTheory.Limits.WalkingPair.casesOn j' fst snd)","decl":"/-- A pullback cone on `f` and `g` is determined by morphisms `fst : W ⟶ X` and `snd : W ⟶ Y`\n    such that `fst ≫ f = snd ≫ g`. -/\n@[simps]\ndef mk {W : C} (fst : W ⟶ X) (snd : W ⟶ Y) (eq : fst ≫ f = snd ≫ g) : PullbackCone f g where\n  pt := W\n  π := { app := fun j => Option.casesOn j (fst ≫ f) fun j' => WalkingPair.casesOn j' fst snd\n         naturality := by rintro (⟨⟩ | ⟨⟨⟩⟩) (⟨⟩ | ⟨⟨⟩⟩) j <;> cases j <;> dsimp <;> simp [eq] }\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.mk_π_app_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nW : C\nfst : Quiver.Hom W X\nsnd : Quiver.Hom W Y\neq : Eq (CategoryTheory.CategoryStruct.comp fst f) (CategoryTheory.CategoryStruct.comp snd g)\n⊢ Eq ((CategoryTheory.Limits.PullbackCone.mk fst snd eq).π.app CategoryTheory.Limits.WalkingCospan.left) fst","decl":"@[simp]\ntheorem mk_π_app_left {W : C} (fst : W ⟶ X) (snd : W ⟶ Y) (eq : fst ≫ f = snd ≫ g) :\n    (mk fst snd eq).π.app WalkingCospan.left = fst := rfl\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.mk_π_app_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nW : C\nfst : Quiver.Hom W X\nsnd : Quiver.Hom W Y\neq : Eq (CategoryTheory.CategoryStruct.comp fst f) (CategoryTheory.CategoryStruct.comp snd g)\n⊢ Eq ((CategoryTheory.Limits.PullbackCone.mk fst snd eq).π.app CategoryTheory.Limits.WalkingCospan.right) snd","decl":"@[simp]\ntheorem mk_π_app_right {W : C} (fst : W ⟶ X) (snd : W ⟶ Y) (eq : fst ≫ f = snd ≫ g) :\n    (mk fst snd eq).π.app WalkingCospan.right = snd := rfl\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.mk_π_app_one","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nW : C\nfst : Quiver.Hom W X\nsnd : Quiver.Hom W Y\neq : Eq (CategoryTheory.CategoryStruct.comp fst f) (CategoryTheory.CategoryStruct.comp snd g)\n⊢ Eq ((CategoryTheory.Limits.PullbackCone.mk fst snd eq).π.app CategoryTheory.Limits.WalkingCospan.one) (CategoryTheory.CategoryStruct.comp fst f)","decl":"@[simp]\ntheorem mk_π_app_one {W : C} (fst : W ⟶ X) (snd : W ⟶ Y) (eq : fst ≫ f = snd ≫ g) :\n    (mk fst snd eq).π.app WalkingCospan.one = fst ≫ f := rfl\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.mk_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nW : C\nfst : Quiver.Hom W X\nsnd : Quiver.Hom W Y\neq : Eq (CategoryTheory.CategoryStruct.comp fst f) (CategoryTheory.CategoryStruct.comp snd g)\n⊢ Eq (CategoryTheory.Limits.PullbackCone.mk fst snd eq).fst fst","decl":"@[simp]\ntheorem mk_fst {W : C} (fst : W ⟶ X) (snd : W ⟶ Y) (eq : fst ≫ f = snd ≫ g) :\n    (mk fst snd eq).fst = fst := rfl\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.mk_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nW : C\nfst : Quiver.Hom W X\nsnd : Quiver.Hom W Y\neq : Eq (CategoryTheory.CategoryStruct.comp fst f) (CategoryTheory.CategoryStruct.comp snd g)\n⊢ Eq (CategoryTheory.Limits.PullbackCone.mk fst snd eq).snd snd","decl":"@[simp]\ntheorem mk_snd {W : C} (fst : W ⟶ X) (snd : W ⟶ Y) (eq : fst ≫ f = snd ≫ g) :\n    (mk fst snd eq).snd = snd := rfl\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nt : CategoryTheory.Limits.PullbackCone f g\nZ : C\nh : Quiver.Hom Z✝ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp t.fst (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp t.snd (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc]\ntheorem condition (t : PullbackCone f g) : fst t ≫ f = snd t ≫ g :=\n  (t.w inl).trans (t.w inr).symm\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nt : CategoryTheory.Limits.PullbackCone f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp t.fst f) (CategoryTheory.CategoryStruct.comp t.snd g)","decl":"@[reassoc]\ntheorem condition (t : PullbackCone f g) : fst t ≫ f = snd t ≫ g :=\n  (t.w inl).trans (t.w inr).symm\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.equalizer_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nt : CategoryTheory.Limits.PullbackCone f g\nW : C\nk l : Quiver.Hom W t.pt\nh₀ : Eq (CategoryTheory.CategoryStruct.comp k t.fst) (CategoryTheory.CategoryStruct.comp l t.fst)\nh₁ : Eq (CategoryTheory.CategoryStruct.comp k t.snd) (CategoryTheory.CategoryStruct.comp l t.snd)\nj : CategoryTheory.Limits.WalkingCospan\n⊢ Eq (CategoryTheory.CategoryStruct.comp k (t.π.app j)) (CategoryTheory.CategoryStruct.comp l (t.π.app j))","decl":"/-- To check whether two morphisms are equalized by the maps of a pullback cone, it suffices to\ncheck it for `fst t` and `snd t` -/\ntheorem equalizer_ext (t : PullbackCone f g) {W : C} {k l : W ⟶ t.pt} (h₀ : k ≫ fst t = l ≫ fst t)\n    (h₁ : k ≫ snd t = l ≫ snd t) : ∀ j : WalkingCospan, k ≫ t.π.app j = l ≫ t.π.app j\n  | some WalkingPair.left => h₀\n  | some WalkingPair.right => h₁\n  | none => by rw [← t.w inl, reassoc_of% h₀]\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.eta_hom_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nt : CategoryTheory.Limits.PullbackCone f g\n⊢ Eq t.eta.hom.hom (CategoryTheory.CategoryStruct.id t.pt)","decl":"/-- The natural isomorphism between a pullback cone and the corresponding pullback cone\nreconstructed using `PullbackCone.mk`. -/\n@[simps!]\ndef eta (t : PullbackCone f g) : t ≅ mk t.fst t.snd t.condition :=\n  PullbackCone.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.eta_inv_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nt : CategoryTheory.Limits.PullbackCone f g\n⊢ Eq t.eta.inv.hom (CategoryTheory.CategoryStruct.id t.pt)","decl":"/-- The natural isomorphism between a pullback cone and the corresponding pullback cone\nreconstructed using `PullbackCone.mk`. -/\n@[simps!]\ndef eta (t : PullbackCone f g) : t ≅ mk t.fst t.snd t.condition :=\n  PullbackCone.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.IsLimit.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nt : CategoryTheory.Limits.PullbackCone f g\nht : CategoryTheory.Limits.IsLimit t\nW : C\nk l : Quiver.Hom W t.pt\nh₀ : Eq (CategoryTheory.CategoryStruct.comp k t.fst) (CategoryTheory.CategoryStruct.comp l t.fst)\nh₁ : Eq (CategoryTheory.CategoryStruct.comp k t.snd) (CategoryTheory.CategoryStruct.comp l t.snd)\n⊢ Eq k l","decl":"theorem IsLimit.hom_ext {t : PullbackCone f g} (ht : IsLimit t) {W : C} {k l : W ⟶ t.pt}\n    (h₀ : k ≫ fst t = l ≫ fst t) (h₁ : k ≫ snd t = l ≫ snd t) : k = l :=\n  ht.hom_ext <| equalizer_ext _ h₀ h₁\n\n-- Porting note: `IsLimit.lift` and the two following simp lemmas were introduced to ease the port\n"}
{"name":"CategoryTheory.Limits.PullbackCone.IsLimit.lift_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nt : CategoryTheory.Limits.PullbackCone f g\nht : CategoryTheory.Limits.IsLimit t\nW : C\nh✝ : Quiver.Hom W X\nk : Quiver.Hom W Y\nw : Eq (CategoryTheory.CategoryStruct.comp h✝ f) (CategoryTheory.CategoryStruct.comp k g)\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PullbackCone.IsLimit.lift ht h✝ k w) (CategoryTheory.CategoryStruct.comp t.fst h)) (CategoryTheory.CategoryStruct.comp h✝ h)","decl":"@[reassoc (attr := simp)]\nlemma IsLimit.lift_fst {t : PullbackCone f g} (ht : IsLimit t) {W : C} (h : W ⟶ X) (k : W ⟶ Y)\n    (w : h ≫ f = k ≫ g) : IsLimit.lift ht h k w ≫ fst t = h := ht.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.IsLimit.lift_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nt : CategoryTheory.Limits.PullbackCone f g\nht : CategoryTheory.Limits.IsLimit t\nW : C\nh : Quiver.Hom W X\nk : Quiver.Hom W Y\nw : Eq (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp k g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PullbackCone.IsLimit.lift ht h k w) t.fst) h","decl":"@[reassoc (attr := simp)]\nlemma IsLimit.lift_fst {t : PullbackCone f g} (ht : IsLimit t) {W : C} (h : W ⟶ X) (k : W ⟶ Y)\n    (w : h ≫ f = k ≫ g) : IsLimit.lift ht h k w ≫ fst t = h := ht.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.IsLimit.lift_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nt : CategoryTheory.Limits.PullbackCone f g\nht : CategoryTheory.Limits.IsLimit t\nW : C\nh : Quiver.Hom W X\nk : Quiver.Hom W Y\nw : Eq (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp k g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PullbackCone.IsLimit.lift ht h k w) t.snd) k","decl":"@[reassoc (attr := simp)]\nlemma IsLimit.lift_snd {t : PullbackCone f g} (ht : IsLimit t) {W : C} (h : W ⟶ X) (k : W ⟶ Y)\n    (w : h ≫ f = k ≫ g) : IsLimit.lift ht h k w ≫ snd t = k := ht.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.IsLimit.lift_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nt : CategoryTheory.Limits.PullbackCone f g\nht : CategoryTheory.Limits.IsLimit t\nW : C\nh✝ : Quiver.Hom W X\nk : Quiver.Hom W Y\nw : Eq (CategoryTheory.CategoryStruct.comp h✝ f) (CategoryTheory.CategoryStruct.comp k g)\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PullbackCone.IsLimit.lift ht h✝ k w) (CategoryTheory.CategoryStruct.comp t.snd h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc (attr := simp)]\nlemma IsLimit.lift_snd {t : PullbackCone f g} (ht : IsLimit t) {W : C} (h : W ⟶ X) (k : W ⟶ Y)\n    (w : h ≫ f = k ≫ g) : IsLimit.lift ht h k w ≫ snd t = k := ht.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.flip_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nt : CategoryTheory.Limits.PullbackCone f g\n⊢ Eq t.flip.pt t.pt","decl":"@[simp] lemma flip_pt : t.flip.pt = t.pt := rfl\n"}
{"name":"CategoryTheory.Limits.PullbackCone.flip_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nt : CategoryTheory.Limits.PullbackCone f g\n⊢ Eq t.flip.fst t.snd","decl":"@[simp] lemma flip_fst : t.flip.fst = t.snd := rfl\n"}
{"name":"CategoryTheory.Limits.PullbackCone.flip_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nt : CategoryTheory.Limits.PullbackCone f g\n⊢ Eq t.flip.snd t.fst","decl":"@[simp] lemma flip_snd : t.flip.snd = t.fst := rfl\n\n"}
{"name":"CategoryTheory.Limits.Cone.ofPullbackCone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingCospan C\nt : CategoryTheory.Limits.PullbackCone (F.map CategoryTheory.Limits.WalkingCospan.Hom.inl) (F.map CategoryTheory.Limits.WalkingCospan.Hom.inr)\n⊢ Eq (CategoryTheory.Limits.Cone.ofPullbackCone t).pt t.pt","decl":"/-- This is a helper construction that can be useful when verifying that a category has all\n    pullbacks. Given `F : WalkingCospan ⥤ C`, which is really the same as\n    `cospan (F.map inl) (F.map inr)`, and a pullback cone on `F.map inl` and `F.map inr`, we\n    get a cone on `F`.\n\n    If you're thinking about using this, have a look at `hasPullbacks_of_hasLimit_cospan`,\n    which you may find to be an easier way of achieving your goal. -/\n@[simps]\ndef Cone.ofPullbackCone {F : WalkingCospan ⥤ C} (t : PullbackCone (F.map inl) (F.map inr)) :\n    Cone F where\n  pt := t.pt\n  π := t.π ≫ (diagramIsoCospan F).inv\n\n"}
{"name":"CategoryTheory.Limits.Cone.ofPullbackCone_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingCospan C\nt : CategoryTheory.Limits.PullbackCone (F.map CategoryTheory.Limits.WalkingCospan.Hom.inl) (F.map CategoryTheory.Limits.WalkingCospan.Hom.inr)\n⊢ Eq (CategoryTheory.Limits.Cone.ofPullbackCone t).π (CategoryTheory.CategoryStruct.comp t.π (CategoryTheory.Limits.diagramIsoCospan F).inv)","decl":"/-- This is a helper construction that can be useful when verifying that a category has all\n    pullbacks. Given `F : WalkingCospan ⥤ C`, which is really the same as\n    `cospan (F.map inl) (F.map inr)`, and a pullback cone on `F.map inl` and `F.map inr`, we\n    get a cone on `F`.\n\n    If you're thinking about using this, have a look at `hasPullbacks_of_hasLimit_cospan`,\n    which you may find to be an easier way of achieving your goal. -/\n@[simps]\ndef Cone.ofPullbackCone {F : WalkingCospan ⥤ C} (t : PullbackCone (F.map inl) (F.map inr)) :\n    Cone F where\n  pt := t.pt\n  π := t.π ≫ (diagramIsoCospan F).inv\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.ofCone_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingCospan C\nt : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Limits.PullbackCone.ofCone t).π (CategoryTheory.CategoryStruct.comp t.π (CategoryTheory.Limits.diagramIsoCospan F).hom)","decl":"/-- Given `F : WalkingCospan ⥤ C`, which is really the same as `cospan (F.map inl) (F.map inr)`,\n    and a cone on `F`, we get a pullback cone on `F.map inl` and `F.map inr`. -/\n@[simps]\ndef PullbackCone.ofCone {F : WalkingCospan ⥤ C} (t : Cone F) :\n    PullbackCone (F.map inl) (F.map inr) where\n  pt := t.pt\n  π := t.π ≫ (diagramIsoCospan F).hom\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.ofCone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingCospan C\nt : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Limits.PullbackCone.ofCone t).pt t.pt","decl":"/-- Given `F : WalkingCospan ⥤ C`, which is really the same as `cospan (F.map inl) (F.map inr)`,\n    and a cone on `F`, we get a pullback cone on `F.map inl` and `F.map inr`. -/\n@[simps]\ndef PullbackCone.ofCone {F : WalkingCospan ⥤ C} (t : Cone F) :\n    PullbackCone (F.map inl) (F.map inr) where\n  pt := t.pt\n  π := t.π ≫ (diagramIsoCospan F).hom\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.isoMk_hom_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingCospan C\nt : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Limits.PullbackCone.isoMk t).hom.hom (CategoryTheory.CategoryStruct.id t.pt)","decl":"/-- A diagram `WalkingCospan ⥤ C` is isomorphic to some `PullbackCone.mk` after\ncomposing with `diagramIsoCospan`. -/\n@[simps!]\ndef PullbackCone.isoMk {F : WalkingCospan ⥤ C} (t : Cone F) :\n    (Cones.postcompose (diagramIsoCospan.{v} _).hom).obj t ≅\n      PullbackCone.mk (t.π.app WalkingCospan.left) (t.π.app WalkingCospan.right)\n        ((t.π.naturality inl).symm.trans (t.π.naturality inr :)) :=\n  Cones.ext (Iso.refl _) <| by\n    rintro (_ | (_ | _)) <;>\n      · dsimp\n        simp\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.isoMk_inv_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingCospan C\nt : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Limits.PullbackCone.isoMk t).inv.hom (CategoryTheory.CategoryStruct.id t.pt)","decl":"/-- A diagram `WalkingCospan ⥤ C` is isomorphic to some `PullbackCone.mk` after\ncomposing with `diagramIsoCospan`. -/\n@[simps!]\ndef PullbackCone.isoMk {F : WalkingCospan ⥤ C} (t : Cone F) :\n    (Cones.postcompose (diagramIsoCospan.{v} _).hom).obj t ≅\n      PullbackCone.mk (t.π.app WalkingCospan.left) (t.π.app WalkingCospan.right)\n        ((t.π.naturality inl).symm.trans (t.π.naturality inr :)) :=\n  Cones.ext (Iso.refl _) <| by\n    rintro (_ | (_ | _)) <;>\n      · dsimp\n        simp\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.ι_app_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nc : CategoryTheory.Limits.PushoutCocone f g\n⊢ Eq (c.ι.app CategoryTheory.Limits.WalkingSpan.left) c.inl","decl":"@[simp]\ntheorem ι_app_left (c : PushoutCocone f g) : c.ι.app WalkingSpan.left = c.inl := rfl\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.ι_app_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nc : CategoryTheory.Limits.PushoutCocone f g\n⊢ Eq (c.ι.app CategoryTheory.Limits.WalkingSpan.right) c.inr","decl":"@[simp]\ntheorem ι_app_right (c : PushoutCocone f g) : c.ι.app WalkingSpan.right = c.inr := rfl\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.condition_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nt : CategoryTheory.Limits.PushoutCocone f g\n⊢ Eq (t.ι.app CategoryTheory.Limits.WalkingSpan.zero) (CategoryTheory.CategoryStruct.comp f t.inl)","decl":"@[simp]\ntheorem condition_zero (t : PushoutCocone f g) : t.ι.app WalkingSpan.zero = f ≫ t.inl := by\n  have w := t.ι.naturality WalkingSpan.Hom.fst\n  dsimp at w; simpa using w.symm\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.mk_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nW : C\ninl : Quiver.Hom Y W\ninr : Quiver.Hom Z W\neq : Eq (CategoryTheory.CategoryStruct.comp f inl) (CategoryTheory.CategoryStruct.comp g inr)\n⊢ Eq (CategoryTheory.Limits.PushoutCocone.mk inl inr eq).pt W","decl":"/-- A pushout cocone on `f` and `g` is determined by morphisms `inl : Y ⟶ W` and `inr : Z ⟶ W` such\n    that `f ≫ inl = g ↠ inr`. -/\n@[simps]\ndef mk {W : C} (inl : Y ⟶ W) (inr : Z ⟶ W) (eq : f ≫ inl = g ≫ inr) : PushoutCocone f g where\n  pt := W\n  ι := { app := fun j => Option.casesOn j (f ≫ inl) fun j' => WalkingPair.casesOn j' inl inr\n         naturality := by\n          rintro (⟨⟩|⟨⟨⟩⟩) (⟨⟩|⟨⟨⟩⟩) <;> intro f <;> cases f <;> dsimp <;> aesop }\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.mk_ι_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nW : C\ninl : Quiver.Hom Y W\ninr : Quiver.Hom Z W\neq : Eq (CategoryTheory.CategoryStruct.comp f inl) (CategoryTheory.CategoryStruct.comp g inr)\nj : CategoryTheory.Limits.WalkingSpan\n⊢ Eq ((CategoryTheory.Limits.PushoutCocone.mk inl inr eq).ι.app j) (Option.casesOn j (CategoryTheory.CategoryStruct.comp f inl) fun j' => CategoryTheory.Limits.WalkingPair.casesOn j' inl inr)","decl":"/-- A pushout cocone on `f` and `g` is determined by morphisms `inl : Y ⟶ W` and `inr : Z ⟶ W` such\n    that `f ≫ inl = g ↠ inr`. -/\n@[simps]\ndef mk {W : C} (inl : Y ⟶ W) (inr : Z ⟶ W) (eq : f ≫ inl = g ≫ inr) : PushoutCocone f g where\n  pt := W\n  ι := { app := fun j => Option.casesOn j (f ≫ inl) fun j' => WalkingPair.casesOn j' inl inr\n         naturality := by\n          rintro (⟨⟩|⟨⟨⟩⟩) (⟨⟩|⟨⟨⟩⟩) <;> intro f <;> cases f <;> dsimp <;> aesop }\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.mk_ι_app_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nW : C\ninl : Quiver.Hom Y W\ninr : Quiver.Hom Z W\neq : Eq (CategoryTheory.CategoryStruct.comp f inl) (CategoryTheory.CategoryStruct.comp g inr)\n⊢ Eq ((CategoryTheory.Limits.PushoutCocone.mk inl inr eq).ι.app CategoryTheory.Limits.WalkingSpan.left) inl","decl":"@[simp]\ntheorem mk_ι_app_left {W : C} (inl : Y ⟶ W) (inr : Z ⟶ W) (eq : f ≫ inl = g ≫ inr) :\n    (mk inl inr eq).ι.app WalkingSpan.left = inl := rfl\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.mk_ι_app_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nW : C\ninl : Quiver.Hom Y W\ninr : Quiver.Hom Z W\neq : Eq (CategoryTheory.CategoryStruct.comp f inl) (CategoryTheory.CategoryStruct.comp g inr)\n⊢ Eq ((CategoryTheory.Limits.PushoutCocone.mk inl inr eq).ι.app CategoryTheory.Limits.WalkingSpan.right) inr","decl":"@[simp]\ntheorem mk_ι_app_right {W : C} (inl : Y ⟶ W) (inr : Z ⟶ W) (eq : f ≫ inl = g ≫ inr) :\n    (mk inl inr eq).ι.app WalkingSpan.right = inr := rfl\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.mk_ι_app_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nW : C\ninl : Quiver.Hom Y W\ninr : Quiver.Hom Z W\neq : Eq (CategoryTheory.CategoryStruct.comp f inl) (CategoryTheory.CategoryStruct.comp g inr)\n⊢ Eq ((CategoryTheory.Limits.PushoutCocone.mk inl inr eq).ι.app CategoryTheory.Limits.WalkingSpan.zero) (CategoryTheory.CategoryStruct.comp f inl)","decl":"@[simp]\ntheorem mk_ι_app_zero {W : C} (inl : Y ⟶ W) (inr : Z ⟶ W) (eq : f ≫ inl = g ≫ inr) :\n    (mk inl inr eq).ι.app WalkingSpan.zero = f ≫ inl := rfl\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.mk_inl","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nW : C\ninl : Quiver.Hom Y W\ninr : Quiver.Hom Z W\neq : Eq (CategoryTheory.CategoryStruct.comp f inl) (CategoryTheory.CategoryStruct.comp g inr)\n⊢ Eq (CategoryTheory.Limits.PushoutCocone.mk inl inr eq).inl inl","decl":"@[simp]\ntheorem mk_inl {W : C} (inl : Y ⟶ W) (inr : Z ⟶ W) (eq : f ≫ inl = g ≫ inr) :\n    (mk inl inr eq).inl = inl := rfl\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.mk_inr","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nW : C\ninl : Quiver.Hom Y W\ninr : Quiver.Hom Z W\neq : Eq (CategoryTheory.CategoryStruct.comp f inl) (CategoryTheory.CategoryStruct.comp g inr)\n⊢ Eq (CategoryTheory.Limits.PushoutCocone.mk inl inr eq).inr inr","decl":"@[simp]\ntheorem mk_inr {W : C} (inl : Y ⟶ W) (inr : Z ⟶ W) (eq : f ≫ inl = g ≫ inr) :\n    (mk inl inr eq).inr = inr := rfl\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nt : CategoryTheory.Limits.PushoutCocone f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp f t.inl) (CategoryTheory.CategoryStruct.comp g t.inr)","decl":"@[reassoc]\ntheorem condition (t : PushoutCocone f g) : f ≫ inl t = g ≫ inr t :=\n  (t.w fst).trans (t.w snd).symm\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z✝ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z✝\nt : CategoryTheory.Limits.PushoutCocone f g\nZ : C\nh : Quiver.Hom t.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp t.inl h)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.comp t.inr h))","decl":"@[reassoc]\ntheorem condition (t : PushoutCocone f g) : f ≫ inl t = g ≫ inr t :=\n  (t.w fst).trans (t.w snd).symm\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.coequalizer_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nt : CategoryTheory.Limits.PushoutCocone f g\nW : C\nk l : Quiver.Hom t.pt W\nh₀ : Eq (CategoryTheory.CategoryStruct.comp t.inl k) (CategoryTheory.CategoryStruct.comp t.inl l)\nh₁ : Eq (CategoryTheory.CategoryStruct.comp t.inr k) (CategoryTheory.CategoryStruct.comp t.inr l)\nj : CategoryTheory.Limits.WalkingSpan\n⊢ Eq (CategoryTheory.CategoryStruct.comp (t.ι.app j) k) (CategoryTheory.CategoryStruct.comp (t.ι.app j) l)","decl":"/-- To check whether a morphism is coequalized by the maps of a pushout cocone, it suffices to check\n  it for `inl t` and `inr t` -/\ntheorem coequalizer_ext (t : PushoutCocone f g) {W : C} {k l : t.pt ⟶ W}\n    (h₀ : inl t ≫ k = inl t ≫ l) (h₁ : inr t ≫ k = inr t ≫ l) :\n    ∀ j : WalkingSpan, t.ι.app j ≫ k = t.ι.app j ≫ l\n  | some WalkingPair.left => h₀\n  | some WalkingPair.right => h₁\n  | none => by rw [← t.w fst, Category.assoc, Category.assoc, h₀]\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.eta_hom_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nt : CategoryTheory.Limits.PushoutCocone f g\n⊢ Eq t.eta.hom.hom (CategoryTheory.CategoryStruct.id t.pt)","decl":"/-- The natural isomorphism between a pushout cocone and the corresponding pushout cocone\nreconstructed using `PushoutCocone.mk`. -/\n@[simps!]\ndef eta (t : PushoutCocone f g) : t ≅ mk t.inl t.inr t.condition :=\n  PushoutCocone.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.eta_inv_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nt : CategoryTheory.Limits.PushoutCocone f g\n⊢ Eq t.eta.inv.hom (CategoryTheory.CategoryStruct.id t.pt)","decl":"/-- The natural isomorphism between a pushout cocone and the corresponding pushout cocone\nreconstructed using `PushoutCocone.mk`. -/\n@[simps!]\ndef eta (t : PushoutCocone f g) : t ≅ mk t.inl t.inr t.condition :=\n  PushoutCocone.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.IsColimit.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nt : CategoryTheory.Limits.PushoutCocone f g\nht : CategoryTheory.Limits.IsColimit t\nW : C\nk l : Quiver.Hom t.pt W\nh₀ : Eq (CategoryTheory.CategoryStruct.comp t.inl k) (CategoryTheory.CategoryStruct.comp t.inl l)\nh₁ : Eq (CategoryTheory.CategoryStruct.comp t.inr k) (CategoryTheory.CategoryStruct.comp t.inr l)\n⊢ Eq k l","decl":"theorem IsColimit.hom_ext {t : PushoutCocone f g} (ht : IsColimit t) {W : C} {k l : t.pt ⟶ W}\n    (h₀ : inl t ≫ k = inl t ≫ l) (h₁ : inr t ≫ k = inr t ≫ l) : k = l :=\n  ht.hom_ext <| coequalizer_ext _ h₀ h₁\n\n-- Porting note: `IsColimit.desc` and the two following simp lemmas were introduced to ease the port\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.IsColimit.inl_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nt : CategoryTheory.Limits.PushoutCocone f g\nht : CategoryTheory.Limits.IsColimit t\nW : C\nh : Quiver.Hom Y W\nk : Quiver.Hom Z W\nw : Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g k)\n⊢ Eq (CategoryTheory.CategoryStruct.comp t.inl (CategoryTheory.Limits.PushoutCocone.IsColimit.desc ht h k w)) h","decl":"@[reassoc (attr := simp)]\nlemma IsColimit.inl_desc {t : PushoutCocone f g} (ht : IsColimit t) {W : C} (h : Y ⟶ W) (k : Z ⟶ W)\n    (w : f ≫ h = g ≫ k) : inl t ≫ IsColimit.desc ht h k w = h :=\n  ht.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.IsColimit.inl_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z✝ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z✝\nt : CategoryTheory.Limits.PushoutCocone f g\nht : CategoryTheory.Limits.IsColimit t\nW : C\nh✝ : Quiver.Hom Y W\nk : Quiver.Hom Z✝ W\nw : Eq (CategoryTheory.CategoryStruct.comp f h✝) (CategoryTheory.CategoryStruct.comp g k)\nZ : C\nh : Quiver.Hom W Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp t.inl (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PushoutCocone.IsColimit.desc ht h✝ k w) h)) (CategoryTheory.CategoryStruct.comp h✝ h)","decl":"@[reassoc (attr := simp)]\nlemma IsColimit.inl_desc {t : PushoutCocone f g} (ht : IsColimit t) {W : C} (h : Y ⟶ W) (k : Z ⟶ W)\n    (w : f ≫ h = g ≫ k) : inl t ≫ IsColimit.desc ht h k w = h :=\n  ht.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.IsColimit.inr_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nt : CategoryTheory.Limits.PushoutCocone f g\nht : CategoryTheory.Limits.IsColimit t\nW : C\nh : Quiver.Hom Y W\nk : Quiver.Hom Z W\nw : Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g k)\n⊢ Eq (CategoryTheory.CategoryStruct.comp t.inr (CategoryTheory.Limits.PushoutCocone.IsColimit.desc ht h k w)) k","decl":"@[reassoc (attr := simp)]\nlemma IsColimit.inr_desc {t : PushoutCocone f g} (ht : IsColimit t) {W : C} (h : Y ⟶ W) (k : Z ⟶ W)\n    (w : f ≫ h = g ≫ k) : inr t ≫ IsColimit.desc ht h k w = k :=\n  ht.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.IsColimit.inr_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z✝ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z✝\nt : CategoryTheory.Limits.PushoutCocone f g\nht : CategoryTheory.Limits.IsColimit t\nW : C\nh✝ : Quiver.Hom Y W\nk : Quiver.Hom Z✝ W\nw : Eq (CategoryTheory.CategoryStruct.comp f h✝) (CategoryTheory.CategoryStruct.comp g k)\nZ : C\nh : Quiver.Hom W Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp t.inr (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PushoutCocone.IsColimit.desc ht h✝ k w) h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc (attr := simp)]\nlemma IsColimit.inr_desc {t : PushoutCocone f g} (ht : IsColimit t) {W : C} (h : Y ⟶ W) (k : Z ⟶ W)\n    (w : f ≫ h = g ≫ k) : inr t ≫ IsColimit.desc ht h k w = k :=\n  ht.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.flip_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nt : CategoryTheory.Limits.PushoutCocone f g\n⊢ Eq t.flip.pt t.pt","decl":"@[simp] lemma flip_pt : t.flip.pt = t.pt := rfl\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.flip_inl","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nt : CategoryTheory.Limits.PushoutCocone f g\n⊢ Eq t.flip.inl t.inr","decl":"@[simp] lemma flip_inl : t.flip.inl = t.inr := rfl\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.flip_inr","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nt : CategoryTheory.Limits.PushoutCocone f g\n⊢ Eq t.flip.inr t.inl","decl":"@[simp] lemma flip_inr : t.flip.inr = t.inl := rfl\n\n"}
{"name":"CategoryTheory.Limits.Cocone.ofPushoutCocone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingSpan C\nt : CategoryTheory.Limits.PushoutCocone (F.map CategoryTheory.Limits.WalkingSpan.Hom.fst) (F.map CategoryTheory.Limits.WalkingSpan.Hom.snd)\n⊢ Eq (CategoryTheory.Limits.Cocone.ofPushoutCocone t).pt t.pt","decl":"/-- This is a helper construction that can be useful when verifying that a category has all\n    pushout. Given `F : WalkingSpan ⥤ C`, which is really the same as\n    `span (F.map fst) (F.map snd)`, and a pushout cocone on `F.map fst` and `F.map snd`,\n    we get a cocone on `F`.\n\n    If you're thinking about using this, have a look at `hasPushouts_of_hasColimit_span`, which\n    you may find to be an easier way of achieving your goal. -/\n@[simps]\ndef Cocone.ofPushoutCocone {F : WalkingSpan ⥤ C} (t : PushoutCocone (F.map fst) (F.map snd)) :\n    Cocone F where\n  pt := t.pt\n  ι := (diagramIsoSpan F).hom ≫ t.ι\n\n"}
{"name":"CategoryTheory.Limits.Cocone.ofPushoutCocone_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingSpan C\nt : CategoryTheory.Limits.PushoutCocone (F.map CategoryTheory.Limits.WalkingSpan.Hom.fst) (F.map CategoryTheory.Limits.WalkingSpan.Hom.snd)\n⊢ Eq (CategoryTheory.Limits.Cocone.ofPushoutCocone t).ι (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diagramIsoSpan F).hom t.ι)","decl":"/-- This is a helper construction that can be useful when verifying that a category has all\n    pushout. Given `F : WalkingSpan ⥤ C`, which is really the same as\n    `span (F.map fst) (F.map snd)`, and a pushout cocone on `F.map fst` and `F.map snd`,\n    we get a cocone on `F`.\n\n    If you're thinking about using this, have a look at `hasPushouts_of_hasColimit_span`, which\n    you may find to be an easier way of achieving your goal. -/\n@[simps]\ndef Cocone.ofPushoutCocone {F : WalkingSpan ⥤ C} (t : PushoutCocone (F.map fst) (F.map snd)) :\n    Cocone F where\n  pt := t.pt\n  ι := (diagramIsoSpan F).hom ≫ t.ι\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.ofCocone_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingSpan C\nt : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.Limits.PushoutCocone.ofCocone t).ι (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diagramIsoSpan F).inv t.ι)","decl":"/-- Given `F : WalkingSpan ⥤ C`, which is really the same as `span (F.map fst) (F.map snd)`,\n    and a cocone on `F`, we get a pushout cocone on `F.map fst` and `F.map snd`. -/\n@[simps]\ndef PushoutCocone.ofCocone {F : WalkingSpan ⥤ C} (t : Cocone F) :\n    PushoutCocone (F.map fst) (F.map snd) where\n  pt := t.pt\n  ι := (diagramIsoSpan F).inv ≫ t.ι\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.ofCocone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingSpan C\nt : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.Limits.PushoutCocone.ofCocone t).pt t.pt","decl":"/-- Given `F : WalkingSpan ⥤ C`, which is really the same as `span (F.map fst) (F.map snd)`,\n    and a cocone on `F`, we get a pushout cocone on `F.map fst` and `F.map snd`. -/\n@[simps]\ndef PushoutCocone.ofCocone {F : WalkingSpan ⥤ C} (t : Cocone F) :\n    PushoutCocone (F.map fst) (F.map snd) where\n  pt := t.pt\n  ι := (diagramIsoSpan F).inv ≫ t.ι\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.isoMk_inv_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingSpan C\nt : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.Limits.PushoutCocone.isoMk t).inv.hom (CategoryTheory.CategoryStruct.id t.pt)","decl":"/-- A diagram `WalkingSpan ⥤ C` is isomorphic to some `PushoutCocone.mk` after composing with\n`diagramIsoSpan`. -/\n@[simps!]\ndef PushoutCocone.isoMk {F : WalkingSpan ⥤ C} (t : Cocone F) :\n    (Cocones.precompose (diagramIsoSpan.{v} _).inv).obj t ≅\n      PushoutCocone.mk (t.ι.app WalkingSpan.left) (t.ι.app WalkingSpan.right)\n        ((t.ι.naturality fst).trans (t.ι.naturality snd).symm) :=\n  Cocones.ext (Iso.refl _) <| by\n    rintro (_ | (_ | _)) <;>\n      · dsimp\n        simp\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.isoMk_hom_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingSpan C\nt : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.Limits.PushoutCocone.isoMk t).hom.hom (CategoryTheory.CategoryStruct.id t.pt)","decl":"/-- A diagram `WalkingSpan ⥤ C` is isomorphic to some `PushoutCocone.mk` after composing with\n`diagramIsoSpan`. -/\n@[simps!]\ndef PushoutCocone.isoMk {F : WalkingSpan ⥤ C} (t : Cocone F) :\n    (Cocones.precompose (diagramIsoSpan.{v} _).inv).obj t ≅\n      PushoutCocone.mk (t.ι.app WalkingSpan.left) (t.ι.app WalkingSpan.right)\n        ((t.ι.naturality fst).trans (t.ι.naturality snd).symm) :=\n  Cocones.ext (Iso.refl _) <| by\n    rintro (_ | (_ | _)) <;>\n      · dsimp\n        simp\n\n"}
