{"name":"CategoryTheory.Functor.IsHomLift.cond","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\nself : p.IsHomLift f φ\n⊢ CategoryTheory.IsHomLiftAux p f φ","decl":"/-- Given a functor `p : 𝒳 ⥤ 𝒮`, an arrow `φ : a ⟶ b` in `𝒳` and an arrow `f : R ⟶ S` in `𝒮`,\n`p.IsHomLift f φ` expresses the fact that `φ` lifts `f` through `p`.\nThis is often drawn as:\n```\n  a --φ--> b\n  -        -\n  |        |\n  v        v\n  R --f--> S\n``` -/\nclass Functor.IsHomLift {R S : 𝒮} {a b : 𝒳} (f : R ⟶ S) (φ : a ⟶ b) : Prop where\n  cond : IsHomLiftAux p f φ\n\n"}
{"name":"CategoryTheory.instIsHomLiftMap","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\na b : 𝒳\nφ : Quiver.Hom a b\n⊢ p.IsHomLift (p.map φ) φ","decl":"/-- For any arrow `φ : a ⟶ b` in `𝒳`, `φ` lifts the arrow `p.map φ` in the base `𝒮`-/\n@[simp]\ninstance {a b : 𝒳} (φ : a ⟶ b) : p.IsHomLift (p.map φ) φ where\n  cond := by constructor\n\n"}
{"name":"CategoryTheory.instIsHomLiftIdObj","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\na : 𝒳\n⊢ p.IsHomLift (CategoryTheory.CategoryStruct.id (p.obj a)) (CategoryTheory.CategoryStruct.id a)","decl":"@[simp]\ninstance (a : 𝒳) : p.IsHomLift (𝟙 (p.obj a)) (𝟙 a) := by\n  rw [← p.map_id]; infer_instance\n\n"}
{"name":"CategoryTheory.IsHomLift.id","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR : 𝒮\na : 𝒳\nha : Eq (p.obj a) R\n⊢ p.IsHomLift (CategoryTheory.CategoryStruct.id R) (CategoryTheory.CategoryStruct.id a)","decl":"protected lemma id {p : 𝒳 ⥤ 𝒮} {R : 𝒮} {a : 𝒳} (ha : p.obj a = R) : p.IsHomLift (𝟙 R) (𝟙 a) := by\n  cases ha; infer_instance\n\n"}
{"name":"CategoryTheory.IsHomLift.domain_eq","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝¹ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝ : p.IsHomLift f φ\n⊢ Eq (p.obj a) R","decl":"lemma domain_eq (f : R ⟶ S) (φ : a ⟶ b) [p.IsHomLift f φ] : p.obj a = R := by\n  subst_hom_lift p f φ; rfl\n\n"}
{"name":"CategoryTheory.IsHomLift.codomain_eq","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝¹ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝ : p.IsHomLift f φ\n⊢ Eq (p.obj b) S","decl":"lemma codomain_eq (f : R ⟶ S) (φ : a ⟶ b) [p.IsHomLift f φ] : p.obj b = S := by\n  subst_hom_lift p f φ; rfl\n\n"}
{"name":"CategoryTheory.IsHomLift.fac","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝¹ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝ : p.IsHomLift f φ\n⊢ Eq f (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp (p.map φ) (CategoryTheory.eqToHom ⋯)))","decl":"lemma fac : f = eqToHom (domain_eq p f φ).symm ≫ p.map φ ≫ eqToHom (codomain_eq p f φ) := by\n  subst_hom_lift p f φ; simp\n\n"}
{"name":"CategoryTheory.IsHomLift.fac'","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝¹ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝ : p.IsHomLift f φ\n⊢ Eq (p.map φ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.eqToHom ⋯)))","decl":"lemma fac' : p.map φ = eqToHom (domain_eq p f φ) ≫ f ≫ eqToHom (codomain_eq p f φ).symm := by\n  subst_hom_lift p f φ; simp\n\n"}
{"name":"CategoryTheory.IsHomLift.commSq","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝¹ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝ : p.IsHomLift f φ\n⊢ CategoryTheory.CommSq (p.map φ) (CategoryTheory.eqToHom ⋯) (CategoryTheory.eqToHom ⋯) f","decl":"lemma commSq : CommSq (p.map φ) (eqToHom (domain_eq p f φ)) (eqToHom (codomain_eq p f φ)) f where\n  w := by simp only [fac p f φ, eqToHom_trans_assoc, eqToHom_refl, id_comp]\n\n"}
{"name":"CategoryTheory.IsHomLift.eq_of_isHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝¹ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\na b : 𝒳\nf : Quiver.Hom (p.obj a) (p.obj b)\nφ : Quiver.Hom a b\ninst✝ : p.IsHomLift f φ\n⊢ Eq f (p.map φ)","decl":"lemma eq_of_isHomLift {a b : 𝒳} (f : p.obj a ⟶ p.obj b) (φ : a ⟶ b) [p.IsHomLift f φ] :\n    f = p.map φ := by\n  simp only [fac p f φ, eqToHom_refl, comp_id, id_comp]\n\n"}
{"name":"CategoryTheory.IsHomLift.of_fac","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\nha : Eq (p.obj a) R\nhb : Eq (p.obj b) S\nh : Eq f (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp (p.map φ) (CategoryTheory.eqToHom hb)))\n⊢ p.IsHomLift f φ","decl":"lemma of_fac {R S : 𝒮} {a b : 𝒳} (f : R ⟶ S) (φ : a ⟶ b) (ha : p.obj a = R) (hb : p.obj b = S)\n    (h : f = eqToHom ha.symm ≫ p.map φ ≫ eqToHom hb) : p.IsHomLift f φ := by\n  subst ha hb h; simp\n\n"}
{"name":"CategoryTheory.IsHomLift.of_fac'","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\nha : Eq (p.obj a) R\nhb : Eq (p.obj b) S\nh : Eq (p.map φ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ha) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.eqToHom ⋯)))\n⊢ p.IsHomLift f φ","decl":"lemma of_fac' {R S : 𝒮} {a b : 𝒳} (f : R ⟶ S) (φ : a ⟶ b) (ha : p.obj a = R) (hb : p.obj b = S)\n    (h : p.map φ = eqToHom ha ≫ f ≫ eqToHom hb.symm) : p.IsHomLift f φ := by\n  subst ha hb\n  obtain rfl : f = p.map φ := by simpa using h.symm\n  infer_instance\n\n"}
{"name":"CategoryTheory.IsHomLift.of_commsq","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\nha : Eq (p.obj a) R\nhb : Eq (p.obj b) S\nh : Eq (CategoryTheory.CategoryStruct.comp (p.map φ) (CategoryTheory.eqToHom hb)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ha) f)\n⊢ p.IsHomLift f φ","decl":"lemma of_commsq {R S : 𝒮} {a b : 𝒳} (f : R ⟶ S) (φ : a ⟶ b) (ha : p.obj a = R) (hb : p.obj b = S)\n    (h : p.map φ ≫ eqToHom hb = (eqToHom ha) ≫ f) : p.IsHomLift f φ := by\n  subst ha hb\n  obtain rfl : f = p.map φ := by simpa using h.symm\n  infer_instance\n\n"}
{"name":"CategoryTheory.IsHomLift.of_commSq","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\nha : Eq (p.obj a) R\nhb : Eq (p.obj b) S\nh : CategoryTheory.CommSq (p.map φ) (CategoryTheory.eqToHom ha) (CategoryTheory.eqToHom hb) f\n⊢ p.IsHomLift f φ","decl":"lemma of_commSq {R S : 𝒮} {a b : 𝒳} (f : R ⟶ S) (φ : a ⟶ b) (ha : p.obj a = R) (hb : p.obj b = S)\n    (h : CommSq (p.map φ) (eqToHom ha) (eqToHom hb) f) : p.IsHomLift f φ :=\n  of_commsq p f φ ha hb h.1\n\n"}
{"name":"CategoryTheory.IsHomLift.comp","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝² : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S T : 𝒮\na b c : 𝒳\nf : Quiver.Hom R S\ng : Quiver.Hom S T\nφ : Quiver.Hom a b\nψ : Quiver.Hom b c\ninst✝¹ : p.IsHomLift f φ\ninst✝ : p.IsHomLift g ψ\n⊢ p.IsHomLift (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp φ ψ)","decl":"instance comp {R S T : 𝒮} {a b c : 𝒳} (f : R ⟶ S) (g : S ⟶ T) (φ : a ⟶ b)\n    (ψ : b ⟶ c) [p.IsHomLift f φ] [p.IsHomLift g ψ] : p.IsHomLift (f ≫ g) (φ ≫ ψ) := by\n  apply of_commSq\n  -- This line transforms the first goal in suitable form; the last line closes all three goals.\n  on_goal 1 => rw [p.map_comp]\n  apply CommSq.horiz_comp (commSq p f φ) (commSq p g ψ)\n\n"}
{"name":"CategoryTheory.IsHomLift.lift_id_comp","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝² : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR : 𝒮\na b c : 𝒳\nφ : Quiver.Hom a b\nψ : Quiver.Hom b c\ninst✝¹ : p.IsHomLift (CategoryTheory.CategoryStruct.id R) φ\ninst✝ : p.IsHomLift (CategoryTheory.CategoryStruct.id R) ψ\n⊢ p.IsHomLift (CategoryTheory.CategoryStruct.id R) (CategoryTheory.CategoryStruct.comp φ ψ)","decl":"/-- If `φ : a ⟶ b` and `ψ : b ⟶ c` lift `𝟙 R`, then so does `φ ≫ ψ` -/\ninstance lift_id_comp (R : 𝒮) {a b c : 𝒳} (φ : a ⟶ b) (ψ : b ⟶ c)\n    [p.IsHomLift (𝟙 R) φ] [p.IsHomLift (𝟙 R) ψ] : p.IsHomLift (𝟙 R) (φ ≫ ψ) :=\n  comp_id (𝟙 R) ▸ comp p (𝟙 R) (𝟙 R) φ ψ\n\n"}
{"name":"CategoryTheory.IsHomLift.comp_lift_id_right","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝² : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\na b c : 𝒳\nS T : 𝒮\nf : Quiver.Hom S T\nφ : Quiver.Hom a b\ninst✝¹ : p.IsHomLift f φ\nψ : Quiver.Hom b c\ninst✝ : p.IsHomLift (CategoryTheory.CategoryStruct.id T) ψ\n⊢ p.IsHomLift f (CategoryTheory.CategoryStruct.comp φ ψ)","decl":"instance comp_lift_id_right {a b c : 𝒳} {S T : 𝒮} (f : S ⟶ T) (φ : a ⟶ b) [p.IsHomLift f φ]\n    (ψ : b ⟶ c) [p.IsHomLift (𝟙 T) ψ] : p.IsHomLift f (φ ≫ ψ) := by\n  simpa using inferInstanceAs (p.IsHomLift (f ≫ 𝟙 T) (φ ≫ ψ))\n\n"}
{"name":"CategoryTheory.IsHomLift.comp_lift_id_right'","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝² : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b c : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsHomLift f φ\nT : 𝒮\nψ : Quiver.Hom b c\ninst✝ : p.IsHomLift (CategoryTheory.CategoryStruct.id T) ψ\n⊢ p.IsHomLift f (CategoryTheory.CategoryStruct.comp φ ψ)","decl":"/-- If `φ : a ⟶ b` lifts `f` and `ψ : b ⟶ c` lifts `𝟙 T`, then `φ ≫ ψ` lifts `f` -/\nlemma comp_lift_id_right' {R S : 𝒮} {a b c : 𝒳} (f : R ⟶ S) (φ : a ⟶ b) [p.IsHomLift f φ]\n    (T : 𝒮) (ψ : b ⟶ c) [p.IsHomLift (𝟙 T) ψ] : p.IsHomLift f (φ ≫ ψ) := by\n  obtain rfl : S = T := by rw [← codomain_eq p f φ, domain_eq p (𝟙 T) ψ]\n  infer_instance\n\n"}
{"name":"CategoryTheory.IsHomLift.comp_lift_id_left","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝² : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\na b c : 𝒳\nS T : 𝒮\nf : Quiver.Hom S T\nψ : Quiver.Hom b c\ninst✝¹ : p.IsHomLift f ψ\nφ : Quiver.Hom a b\ninst✝ : p.IsHomLift (CategoryTheory.CategoryStruct.id S) φ\n⊢ p.IsHomLift f (CategoryTheory.CategoryStruct.comp φ ψ)","decl":"instance comp_lift_id_left {a b c : 𝒳} {S T : 𝒮} (f : S ⟶ T) (ψ : b ⟶ c) [p.IsHomLift f ψ]\n    (φ : a ⟶ b) [p.IsHomLift (𝟙 S) φ] : p.IsHomLift f (φ ≫ ψ) := by\n  simpa using inferInstanceAs (p.IsHomLift (𝟙 S ≫ f) (φ ≫ ψ))\n\n"}
{"name":"CategoryTheory.IsHomLift.comp_lift_id_left'","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝² : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\na b c : 𝒳\nR : 𝒮\nφ : Quiver.Hom a b\ninst✝¹ : p.IsHomLift (CategoryTheory.CategoryStruct.id R) φ\nS T : 𝒮\nf : Quiver.Hom S T\nψ : Quiver.Hom b c\ninst✝ : p.IsHomLift f ψ\n⊢ p.IsHomLift f (CategoryTheory.CategoryStruct.comp φ ψ)","decl":"/-- If `φ : a ⟶ b` lifts `𝟙 T` and `ψ : b ⟶ c` lifts `f`, then `φ  ≫ ψ` lifts `f` -/\nlemma comp_lift_id_left' {a b c : 𝒳} (R : 𝒮) (φ : a ⟶ b) [p.IsHomLift (𝟙 R) φ]\n    {S T : 𝒮} (f : S ⟶ T) (ψ : b ⟶ c) [p.IsHomLift f ψ] : p.IsHomLift f (φ ≫ ψ) := by\n  obtain rfl : R = S := by rw [← codomain_eq p (𝟙 R) φ, domain_eq p f ψ]\n  infer_instance\n\n"}
{"name":"CategoryTheory.IsHomLift.eqToHom_domain_lift_id","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\na b : 𝒳\nhab : Eq a b\nR : 𝒮\nhR : Eq (p.obj a) R\n⊢ p.IsHomLift (CategoryTheory.CategoryStruct.id R) (CategoryTheory.eqToHom hab)","decl":"lemma eqToHom_domain_lift_id {p : 𝒳 ⥤ 𝒮} {a b : 𝒳} (hab : a = b) {R : 𝒮} (hR : p.obj a = R) :\n    p.IsHomLift (𝟙 R) (eqToHom hab) := by\n  subst hR hab; simp\n\n"}
{"name":"CategoryTheory.IsHomLift.eqToHom_codomain_lift_id","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\na b : 𝒳\nhab : Eq a b\nS : 𝒮\nhS : Eq (p.obj b) S\n⊢ p.IsHomLift (CategoryTheory.CategoryStruct.id S) (CategoryTheory.eqToHom hab)","decl":"lemma eqToHom_codomain_lift_id {p : 𝒳 ⥤ 𝒮} {a b : 𝒳} (hab : a = b) {S : 𝒮} (hS : p.obj b = S) :\n    p.IsHomLift (𝟙 S) (eqToHom hab) := by\n  subst hS hab; simp\n\n"}
{"name":"CategoryTheory.IsHomLift.id_lift_eqToHom_domain","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\nhRS : Eq R S\na : 𝒳\nha : Eq (p.obj a) R\n⊢ p.IsHomLift (CategoryTheory.eqToHom hRS) (CategoryTheory.CategoryStruct.id a)","decl":"lemma id_lift_eqToHom_domain {p : 𝒳 ⥤ 𝒮} {R S : 𝒮} (hRS : R = S) {a : 𝒳} (ha : p.obj a = R) :\n    p.IsHomLift (eqToHom hRS) (𝟙 a) := by\n  subst hRS ha; simp\n\n"}
{"name":"CategoryTheory.IsHomLift.id_lift_eqToHom_codomain","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\nhRS : Eq R S\nb : 𝒳\nhb : Eq (p.obj b) S\n⊢ p.IsHomLift (CategoryTheory.eqToHom hRS) (CategoryTheory.CategoryStruct.id b)","decl":"lemma id_lift_eqToHom_codomain {p : 𝒳 ⥤ 𝒮} {R S : 𝒮} (hRS : R = S) {b : 𝒳} (hb : p.obj b = S) :\n    p.IsHomLift (eqToHom hRS) (𝟙 b) := by\n  subst hRS hb; simp\n\n"}
{"name":"CategoryTheory.IsHomLift.comp_eqToHom_lift","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝¹ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na' a b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\nh : Eq a' a\ninst✝ : p.IsHomLift f φ\n⊢ p.IsHomLift f (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h) φ)","decl":"instance comp_eqToHom_lift {R S : 𝒮} {a' a b : 𝒳} (f : R ⟶ S) (φ : a ⟶ b) (h : a' = a)\n    [p.IsHomLift f φ] : p.IsHomLift f (eqToHom h ≫ φ) := by\n  subst h; simp_all\n\n"}
{"name":"CategoryTheory.IsHomLift.eqToHom_comp_lift","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝¹ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b b' : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\nh : Eq b b'\ninst✝ : p.IsHomLift f φ\n⊢ p.IsHomLift f (CategoryTheory.CategoryStruct.comp φ (CategoryTheory.eqToHom h))","decl":"instance eqToHom_comp_lift {R S : 𝒮} {a b b' : 𝒳} (f : R ⟶ S) (φ : a ⟶ b) (h : b = b')\n    [p.IsHomLift f φ] : p.IsHomLift f (φ ≫ eqToHom h) := by\n  subst h; simp_all\n\n"}
{"name":"CategoryTheory.IsHomLift.lift_eqToHom_comp","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝¹ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR' R S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\nh : Eq R' R\ninst✝ : p.IsHomLift f φ\n⊢ p.IsHomLift (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h) f) φ","decl":"instance lift_eqToHom_comp {R' R S : 𝒮} {a b : 𝒳} (f : R ⟶ S) (φ : a ⟶ b) (h : R' = R)\n    [p.IsHomLift f φ] : p.IsHomLift (eqToHom h ≫ f) φ := by\n  subst h; simp_all\n\n"}
{"name":"CategoryTheory.IsHomLift.lift_comp_eqToHom","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝¹ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S S' : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\nh : Eq S S'\ninst✝ : p.IsHomLift f φ\n⊢ p.IsHomLift (CategoryTheory.CategoryStruct.comp f (CategoryTheory.eqToHom h)) φ","decl":"instance lift_comp_eqToHom {R S S' : 𝒮} {a b : 𝒳} (f : R ⟶ S) (φ : a ⟶ b) (h : S = S')\n    [p.IsHomLift f φ] : p.IsHomLift (f ≫ eqToHom h) φ := by\n  subst h; simp_all\n\n"}
{"name":"CategoryTheory.IsHomLift.comp_eqToHom_lift_iff","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na' a b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\nh : Eq a' a\n⊢ Iff (p.IsHomLift f (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h) φ)) (p.IsHomLift f φ)","decl":"@[simp]\nlemma comp_eqToHom_lift_iff {R S : 𝒮} {a' a b : 𝒳} (f : R ⟶ S) (φ : a ⟶ b) (h : a' = a) :\n    p.IsHomLift f (eqToHom h ≫ φ) ↔ p.IsHomLift f φ where\n  mp hφ' := by subst h; simpa using hφ'\n  mpr _ := inferInstance\n\n"}
{"name":"CategoryTheory.IsHomLift.eqToHom_comp_lift_iff","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b b' : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\nh : Eq b b'\n⊢ Iff (p.IsHomLift f (CategoryTheory.CategoryStruct.comp φ (CategoryTheory.eqToHom h))) (p.IsHomLift f φ)","decl":"@[simp]\nlemma eqToHom_comp_lift_iff {R S : 𝒮} {a b b' : 𝒳} (f : R ⟶ S) (φ : a ⟶ b) (h : b = b') :\n    p.IsHomLift f (φ ≫ eqToHom h) ↔ p.IsHomLift f φ where\n  mp hφ' := by subst h; simpa using hφ'\n  mpr _ := inferInstance\n\n"}
{"name":"CategoryTheory.IsHomLift.lift_eqToHom_comp_iff","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR' R S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\nh : Eq R' R\n⊢ Iff (p.IsHomLift (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h) f) φ) (p.IsHomLift f φ)","decl":"@[simp]\nlemma lift_eqToHom_comp_iff {R' R S : 𝒮} {a b : 𝒳} (f : R ⟶ S) (φ : a ⟶ b) (h : R' = R) :\n    p.IsHomLift (eqToHom h ≫ f) φ ↔ p.IsHomLift f φ where\n  mp hφ' := by subst h; simpa using hφ'\n  mpr _ := inferInstance\n\n"}
{"name":"CategoryTheory.IsHomLift.lift_comp_eqToHom_iff","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S S' : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\nh : Eq S S'\n⊢ Iff (p.IsHomLift (CategoryTheory.CategoryStruct.comp f (CategoryTheory.eqToHom h)) φ) (p.IsHomLift f φ)","decl":"@[simp]\nlemma lift_comp_eqToHom_iff {R S S' : 𝒮} {a b : 𝒳} (f : R ⟶ S) (φ : a ⟶ b) (h : S = S') :\n    p.IsHomLift (f ≫ eqToHom h) φ ↔ p.IsHomLift f φ where\n  mp := fun hφ' => by subst h; simpa using hφ'\n  mpr := fun _ => inferInstance\n\n"}
{"name":"CategoryTheory.IsHomLift.isoOfIsoLift_hom","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝¹ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : CategoryTheory.Iso a b\ninst✝ : p.IsHomLift f φ.hom\n⊢ Eq (CategoryTheory.IsHomLift.isoOfIsoLift p f φ).hom f","decl":"/-- Given a morphism `f : R ⟶ S`, and an isomorphism `φ : a ≅ b` lifting `f`, `isoOfIsoLift f φ` is\nthe isomorphism `Φ : R ≅ S` with `Φ.hom = f` induced from `φ` -/\n@[simps hom]\ndef isoOfIsoLift (f : R ⟶ S) (φ : a ≅ b) [p.IsHomLift f φ.hom] :\n    R ≅ S where\n  hom := f\n  inv := eqToHom (codomain_eq p f φ.hom).symm ≫ (p.mapIso φ).inv ≫ eqToHom (domain_eq p f φ.hom)\n  hom_inv_id := by subst_hom_lift p f φ.hom; simp [← p.map_comp]\n  inv_hom_id := by subst_hom_lift p f φ.hom; simp [← p.map_comp]\n\n"}
{"name":"CategoryTheory.IsHomLift.isoOfIsoLift_inv_hom_id","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝¹ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : CategoryTheory.Iso a b\ninst✝ : p.IsHomLift f φ.hom\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsHomLift.isoOfIsoLift p f φ).inv f) (CategoryTheory.CategoryStruct.id S)","decl":"@[simp]\nlemma isoOfIsoLift_inv_hom_id (f : R ⟶ S) (φ : a ≅ b) [p.IsHomLift f φ.hom] :\n    (isoOfIsoLift p f φ).inv ≫ f = 𝟙 S :=\n  (isoOfIsoLift p f φ).inv_hom_id\n\n"}
{"name":"CategoryTheory.IsHomLift.isoOfIsoLift_hom_inv_id","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝¹ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : CategoryTheory.Iso a b\ninst✝ : p.IsHomLift f φ.hom\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.IsHomLift.isoOfIsoLift p f φ).inv) (CategoryTheory.CategoryStruct.id R)","decl":"@[simp]\nlemma isoOfIsoLift_hom_inv_id (f : R ⟶ S) (φ : a ≅ b) [p.IsHomLift f φ.hom] :\n    f ≫ (isoOfIsoLift p f φ).inv = 𝟙 R :=\n  (isoOfIsoLift p f φ).hom_inv_id\n\n"}
{"name":"CategoryTheory.IsHomLift.isIso_of_lift_isIso","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝² : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsHomLift f φ\ninst✝ : CategoryTheory.IsIso φ\n⊢ CategoryTheory.IsIso f","decl":"/-- If `φ : a ⟶ b` lifts `f : R ⟶ S` and `φ` is an isomorphism, then so is `f`. -/\nlemma isIso_of_lift_isIso (f : R ⟶ S) (φ : a ⟶ b) [p.IsHomLift f φ] [IsIso φ] : IsIso f :=\n  (fac p f φ) ▸ inferInstance\n\n"}
{"name":"CategoryTheory.IsHomLift.inv_lift_inv","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝¹ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : CategoryTheory.Iso R S\nφ : CategoryTheory.Iso a b\ninst✝ : p.IsHomLift f.hom φ.hom\n⊢ p.IsHomLift f.inv φ.inv","decl":"/-- Given `φ : a ≅ b` and `f : R ≅ S`, such that `φ.hom` lifts `f.hom`, then `φ.inv` lifts\n`f.inv`. -/\ninstance inv_lift_inv (f : R ≅ S) (φ : a ≅ b) [p.IsHomLift f.hom φ.hom] :\n    p.IsHomLift f.inv φ.inv := by\n  apply of_commSq\n  apply CommSq.horiz_inv (f := p.mapIso φ) (commSq p f.hom φ.hom)\n\n"}
{"name":"CategoryTheory.IsHomLift.inv_lift","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝¹ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : CategoryTheory.Iso a b\ninst✝ : p.IsHomLift f φ.hom\n⊢ p.IsHomLift (CategoryTheory.IsHomLift.isoOfIsoLift p f φ).inv φ.inv","decl":"/-- Given `φ : a ≅ b` and `f : R ⟶ S`, such that `φ.hom` lifts `f`, then `φ.inv` lifts the\ninverse of `f` given by `isoOfIsoLift`. -/\ninstance inv_lift (f : R ⟶ S) (φ : a ≅ b) [p.IsHomLift f φ.hom] :\n    p.IsHomLift (isoOfIsoLift p f φ).inv φ.inv := by\n  apply of_commSq\n  apply CommSq.horiz_inv (f := p.mapIso φ) (by apply commSq p f φ.hom)\n\n"}
{"name":"CategoryTheory.IsHomLift.inv","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝³ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝² : CategoryTheory.IsIso f\ninst✝¹ : CategoryTheory.IsIso φ\ninst✝ : p.IsHomLift f φ\n⊢ p.IsHomLift (CategoryTheory.inv f) (CategoryTheory.inv φ)","decl":"/-- If `φ : a ⟶ b` lifts `f : R ⟶ S` and both are isomorphisms, then `φ⁻¹` lifts `f⁻¹`. -/\nprotected instance inv (f : R ⟶ S) (φ : a ⟶ b) [IsIso f] [IsIso φ] [p.IsHomLift f φ] :\n    p.IsHomLift (inv f) (inv φ) :=\n  have : p.IsHomLift (asIso f).hom (asIso φ).hom := by simp_all\n  IsHomLift.inv_lift_inv p (asIso f) (asIso φ)\n\n"}
{"name":"CategoryTheory.IsHomLift.lift_id_inv","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝¹ : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nS : 𝒮\na b : 𝒳\nφ : CategoryTheory.Iso a b\ninst✝ : p.IsHomLift (CategoryTheory.CategoryStruct.id S) φ.hom\n⊢ p.IsHomLift (CategoryTheory.CategoryStruct.id S) φ.inv","decl":"/-- If `φ : a ≅ b` is an isomorphism lifting `𝟙 S` for some `S : 𝒮`, then `φ⁻¹` also\nlifts `𝟙 S`. -/\ninstance lift_id_inv (S : 𝒮) {a b : 𝒳} (φ : a ≅ b) [p.IsHomLift (𝟙 S) φ.hom] :\n    p.IsHomLift (𝟙 S) φ.inv :=\n  have : p.IsHomLift (asIso (𝟙 S)).hom φ.hom := by simp_all\n  (IsIso.inv_id (X := S)) ▸ (IsHomLift.inv_lift_inv p (asIso (𝟙 S)) φ)\n\n"}
{"name":"CategoryTheory.IsHomLift.lift_id_inv_isIso","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₂} 𝒳\ninst✝² : CategoryTheory.Category.{v₂, u₁} 𝒮\np : CategoryTheory.Functor 𝒳 𝒮\nS : 𝒮\na b : 𝒳\nφ : Quiver.Hom a b\ninst✝¹ : CategoryTheory.IsIso φ\ninst✝ : p.IsHomLift (CategoryTheory.CategoryStruct.id S) φ\n⊢ p.IsHomLift (CategoryTheory.CategoryStruct.id S) (CategoryTheory.inv φ)","decl":"instance lift_id_inv_isIso (S : 𝒮) {a b : 𝒳} (φ : a ⟶ b) [IsIso φ] [p.IsHomLift (𝟙 S) φ] :\n    p.IsHomLift (𝟙 S) (inv φ) :=\n  (IsIso.inv_id (X := S)) ▸ (IsHomLift.inv p _ φ)\n\n"}
