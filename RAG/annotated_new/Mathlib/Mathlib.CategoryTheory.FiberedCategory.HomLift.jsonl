{"name":"CategoryTheory.Functor.IsHomLift.cond","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\nself : p.IsHomLift f Ï†\nâŠ¢ CategoryTheory.IsHomLiftAux p f Ï†","decl":"/-- Given a functor `p : ğ’³ â¥¤ ğ’®`, an arrow `Ï† : a âŸ¶ b` in `ğ’³` and an arrow `f : R âŸ¶ S` in `ğ’®`,\n`p.IsHomLift f Ï†` expresses the fact that `Ï†` lifts `f` through `p`.\nThis is often drawn as:\n```\n  a --Ï†--> b\n  -        -\n  |        |\n  v        v\n  R --f--> S\n``` -/\nclass Functor.IsHomLift {R S : ğ’®} {a b : ğ’³} (f : R âŸ¶ S) (Ï† : a âŸ¶ b) : Prop where\n  cond : IsHomLiftAux p f Ï†\n\n"}
{"name":"CategoryTheory.instIsHomLiftMap","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\na b : ğ’³\nÏ† : Quiver.Hom a b\nâŠ¢ p.IsHomLift (p.map Ï†) Ï†","decl":"/-- For any arrow `Ï† : a âŸ¶ b` in `ğ’³`, `Ï†` lifts the arrow `p.map Ï†` in the base `ğ’®`-/\n@[simp]\ninstance {a b : ğ’³} (Ï† : a âŸ¶ b) : p.IsHomLift (p.map Ï†) Ï† where\n  cond := by constructor\n\n"}
{"name":"CategoryTheory.instIsHomLiftIdObj","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\na : ğ’³\nâŠ¢ p.IsHomLift (CategoryTheory.CategoryStruct.id (p.obj a)) (CategoryTheory.CategoryStruct.id a)","decl":"@[simp]\ninstance (a : ğ’³) : p.IsHomLift (ğŸ™ (p.obj a)) (ğŸ™ a) := by\n  rw [â† p.map_id]; infer_instance\n\n"}
{"name":"CategoryTheory.IsHomLift.id","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR : ğ’®\na : ğ’³\nha : Eq (p.obj a) R\nâŠ¢ p.IsHomLift (CategoryTheory.CategoryStruct.id R) (CategoryTheory.CategoryStruct.id a)","decl":"protected lemma id {p : ğ’³ â¥¤ ğ’®} {R : ğ’®} {a : ğ’³} (ha : p.obj a = R) : p.IsHomLift (ğŸ™ R) (ğŸ™ a) := by\n  cases ha; infer_instance\n\n"}
{"name":"CategoryTheory.IsHomLift.domain_eq","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœ : p.IsHomLift f Ï†\nâŠ¢ Eq (p.obj a) R","decl":"lemma domain_eq (f : R âŸ¶ S) (Ï† : a âŸ¶ b) [p.IsHomLift f Ï†] : p.obj a = R := by\n  subst_hom_lift p f Ï†; rfl\n\n"}
{"name":"CategoryTheory.IsHomLift.codomain_eq","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœ : p.IsHomLift f Ï†\nâŠ¢ Eq (p.obj b) S","decl":"lemma codomain_eq (f : R âŸ¶ S) (Ï† : a âŸ¶ b) [p.IsHomLift f Ï†] : p.obj b = S := by\n  subst_hom_lift p f Ï†; rfl\n\n"}
{"name":"CategoryTheory.IsHomLift.fac","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœ : p.IsHomLift f Ï†\nâŠ¢ Eq f (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom â‹¯) (CategoryTheory.CategoryStruct.comp (p.map Ï†) (CategoryTheory.eqToHom â‹¯)))","decl":"lemma fac : f = eqToHom (domain_eq p f Ï†).symm â‰« p.map Ï† â‰« eqToHom (codomain_eq p f Ï†) := by\n  subst_hom_lift p f Ï†; simp\n\n"}
{"name":"CategoryTheory.IsHomLift.fac'","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœ : p.IsHomLift f Ï†\nâŠ¢ Eq (p.map Ï†) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom â‹¯) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.eqToHom â‹¯)))","decl":"lemma fac' : p.map Ï† = eqToHom (domain_eq p f Ï†) â‰« f â‰« eqToHom (codomain_eq p f Ï†).symm := by\n  subst_hom_lift p f Ï†; simp\n\n"}
{"name":"CategoryTheory.IsHomLift.commSq","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœ : p.IsHomLift f Ï†\nâŠ¢ CategoryTheory.CommSq (p.map Ï†) (CategoryTheory.eqToHom â‹¯) (CategoryTheory.eqToHom â‹¯) f","decl":"lemma commSq : CommSq (p.map Ï†) (eqToHom (domain_eq p f Ï†)) (eqToHom (codomain_eq p f Ï†)) f where\n  w := by simp only [fac p f Ï†, eqToHom_trans_assoc, eqToHom_refl, id_comp]\n\n"}
{"name":"CategoryTheory.IsHomLift.eq_of_isHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\na b : ğ’³\nf : Quiver.Hom (p.obj a) (p.obj b)\nÏ† : Quiver.Hom a b\ninstâœ : p.IsHomLift f Ï†\nâŠ¢ Eq f (p.map Ï†)","decl":"lemma eq_of_isHomLift {a b : ğ’³} (f : p.obj a âŸ¶ p.obj b) (Ï† : a âŸ¶ b) [p.IsHomLift f Ï†] :\n    f = p.map Ï† := by\n  simp only [fac p f Ï†, eqToHom_refl, comp_id, id_comp]\n\n"}
{"name":"CategoryTheory.IsHomLift.of_fac","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\nha : Eq (p.obj a) R\nhb : Eq (p.obj b) S\nh : Eq f (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom â‹¯) (CategoryTheory.CategoryStruct.comp (p.map Ï†) (CategoryTheory.eqToHom hb)))\nâŠ¢ p.IsHomLift f Ï†","decl":"lemma of_fac {R S : ğ’®} {a b : ğ’³} (f : R âŸ¶ S) (Ï† : a âŸ¶ b) (ha : p.obj a = R) (hb : p.obj b = S)\n    (h : f = eqToHom ha.symm â‰« p.map Ï† â‰« eqToHom hb) : p.IsHomLift f Ï† := by\n  subst ha hb h; simp\n\n"}
{"name":"CategoryTheory.IsHomLift.of_fac'","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\nha : Eq (p.obj a) R\nhb : Eq (p.obj b) S\nh : Eq (p.map Ï†) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ha) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.eqToHom â‹¯)))\nâŠ¢ p.IsHomLift f Ï†","decl":"lemma of_fac' {R S : ğ’®} {a b : ğ’³} (f : R âŸ¶ S) (Ï† : a âŸ¶ b) (ha : p.obj a = R) (hb : p.obj b = S)\n    (h : p.map Ï† = eqToHom ha â‰« f â‰« eqToHom hb.symm) : p.IsHomLift f Ï† := by\n  subst ha hb\n  obtain rfl : f = p.map Ï† := by simpa using h.symm\n  infer_instance\n\n"}
{"name":"CategoryTheory.IsHomLift.of_commsq","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\nha : Eq (p.obj a) R\nhb : Eq (p.obj b) S\nh : Eq (CategoryTheory.CategoryStruct.comp (p.map Ï†) (CategoryTheory.eqToHom hb)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ha) f)\nâŠ¢ p.IsHomLift f Ï†","decl":"lemma of_commsq {R S : ğ’®} {a b : ğ’³} (f : R âŸ¶ S) (Ï† : a âŸ¶ b) (ha : p.obj a = R) (hb : p.obj b = S)\n    (h : p.map Ï† â‰« eqToHom hb = (eqToHom ha) â‰« f) : p.IsHomLift f Ï† := by\n  subst ha hb\n  obtain rfl : f = p.map Ï† := by simpa using h.symm\n  infer_instance\n\n"}
{"name":"CategoryTheory.IsHomLift.of_commSq","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\nha : Eq (p.obj a) R\nhb : Eq (p.obj b) S\nh : CategoryTheory.CommSq (p.map Ï†) (CategoryTheory.eqToHom ha) (CategoryTheory.eqToHom hb) f\nâŠ¢ p.IsHomLift f Ï†","decl":"lemma of_commSq {R S : ğ’®} {a b : ğ’³} (f : R âŸ¶ S) (Ï† : a âŸ¶ b) (ha : p.obj a = R) (hb : p.obj b = S)\n    (h : CommSq (p.map Ï†) (eqToHom ha) (eqToHom hb) f) : p.IsHomLift f Ï† :=\n  of_commsq p f Ï† ha hb h.1\n\n"}
{"name":"CategoryTheory.IsHomLift.comp","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S T : ğ’®\na b c : ğ’³\nf : Quiver.Hom R S\ng : Quiver.Hom S T\nÏ† : Quiver.Hom a b\nÏˆ : Quiver.Hom b c\ninstâœÂ¹ : p.IsHomLift f Ï†\ninstâœ : p.IsHomLift g Ïˆ\nâŠ¢ p.IsHomLift (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp Ï† Ïˆ)","decl":"instance comp {R S T : ğ’®} {a b c : ğ’³} (f : R âŸ¶ S) (g : S âŸ¶ T) (Ï† : a âŸ¶ b)\n    (Ïˆ : b âŸ¶ c) [p.IsHomLift f Ï†] [p.IsHomLift g Ïˆ] : p.IsHomLift (f â‰« g) (Ï† â‰« Ïˆ) := by\n  apply of_commSq\n  -- This line transforms the first goal in suitable form; the last line closes all three goals.\n  on_goal 1 => rw [p.map_comp]\n  apply CommSq.horiz_comp (commSq p f Ï†) (commSq p g Ïˆ)\n\n"}
{"name":"CategoryTheory.IsHomLift.lift_id_comp","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR : ğ’®\na b c : ğ’³\nÏ† : Quiver.Hom a b\nÏˆ : Quiver.Hom b c\ninstâœÂ¹ : p.IsHomLift (CategoryTheory.CategoryStruct.id R) Ï†\ninstâœ : p.IsHomLift (CategoryTheory.CategoryStruct.id R) Ïˆ\nâŠ¢ p.IsHomLift (CategoryTheory.CategoryStruct.id R) (CategoryTheory.CategoryStruct.comp Ï† Ïˆ)","decl":"/-- If `Ï† : a âŸ¶ b` and `Ïˆ : b âŸ¶ c` lift `ğŸ™ R`, then so does `Ï† â‰« Ïˆ` -/\ninstance lift_id_comp (R : ğ’®) {a b c : ğ’³} (Ï† : a âŸ¶ b) (Ïˆ : b âŸ¶ c)\n    [p.IsHomLift (ğŸ™ R) Ï†] [p.IsHomLift (ğŸ™ R) Ïˆ] : p.IsHomLift (ğŸ™ R) (Ï† â‰« Ïˆ) :=\n  comp_id (ğŸ™ R) â–¸ comp p (ğŸ™ R) (ğŸ™ R) Ï† Ïˆ\n\n"}
{"name":"CategoryTheory.IsHomLift.comp_lift_id_right","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\na b c : ğ’³\nS T : ğ’®\nf : Quiver.Hom S T\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsHomLift f Ï†\nÏˆ : Quiver.Hom b c\ninstâœ : p.IsHomLift (CategoryTheory.CategoryStruct.id T) Ïˆ\nâŠ¢ p.IsHomLift f (CategoryTheory.CategoryStruct.comp Ï† Ïˆ)","decl":"instance comp_lift_id_right {a b c : ğ’³} {S T : ğ’®} (f : S âŸ¶ T) (Ï† : a âŸ¶ b) [p.IsHomLift f Ï†]\n    (Ïˆ : b âŸ¶ c) [p.IsHomLift (ğŸ™ T) Ïˆ] : p.IsHomLift f (Ï† â‰« Ïˆ) := by\n  simpa using inferInstanceAs (p.IsHomLift (f â‰« ğŸ™ T) (Ï† â‰« Ïˆ))\n\n"}
{"name":"CategoryTheory.IsHomLift.comp_lift_id_right'","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b c : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsHomLift f Ï†\nT : ğ’®\nÏˆ : Quiver.Hom b c\ninstâœ : p.IsHomLift (CategoryTheory.CategoryStruct.id T) Ïˆ\nâŠ¢ p.IsHomLift f (CategoryTheory.CategoryStruct.comp Ï† Ïˆ)","decl":"/-- If `Ï† : a âŸ¶ b` lifts `f` and `Ïˆ : b âŸ¶ c` lifts `ğŸ™ T`, then `Ï† â‰« Ïˆ` lifts `f` -/\nlemma comp_lift_id_right' {R S : ğ’®} {a b c : ğ’³} (f : R âŸ¶ S) (Ï† : a âŸ¶ b) [p.IsHomLift f Ï†]\n    (T : ğ’®) (Ïˆ : b âŸ¶ c) [p.IsHomLift (ğŸ™ T) Ïˆ] : p.IsHomLift f (Ï† â‰« Ïˆ) := by\n  obtain rfl : S = T := by rw [â† codomain_eq p f Ï†, domain_eq p (ğŸ™ T) Ïˆ]\n  infer_instance\n\n"}
{"name":"CategoryTheory.IsHomLift.comp_lift_id_left","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\na b c : ğ’³\nS T : ğ’®\nf : Quiver.Hom S T\nÏˆ : Quiver.Hom b c\ninstâœÂ¹ : p.IsHomLift f Ïˆ\nÏ† : Quiver.Hom a b\ninstâœ : p.IsHomLift (CategoryTheory.CategoryStruct.id S) Ï†\nâŠ¢ p.IsHomLift f (CategoryTheory.CategoryStruct.comp Ï† Ïˆ)","decl":"instance comp_lift_id_left {a b c : ğ’³} {S T : ğ’®} (f : S âŸ¶ T) (Ïˆ : b âŸ¶ c) [p.IsHomLift f Ïˆ]\n    (Ï† : a âŸ¶ b) [p.IsHomLift (ğŸ™ S) Ï†] : p.IsHomLift f (Ï† â‰« Ïˆ) := by\n  simpa using inferInstanceAs (p.IsHomLift (ğŸ™ S â‰« f) (Ï† â‰« Ïˆ))\n\n"}
{"name":"CategoryTheory.IsHomLift.comp_lift_id_left'","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\na b c : ğ’³\nR : ğ’®\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsHomLift (CategoryTheory.CategoryStruct.id R) Ï†\nS T : ğ’®\nf : Quiver.Hom S T\nÏˆ : Quiver.Hom b c\ninstâœ : p.IsHomLift f Ïˆ\nâŠ¢ p.IsHomLift f (CategoryTheory.CategoryStruct.comp Ï† Ïˆ)","decl":"/-- If `Ï† : a âŸ¶ b` lifts `ğŸ™ T` and `Ïˆ : b âŸ¶ c` lifts `f`, then `Ï†  â‰« Ïˆ` lifts `f` -/\nlemma comp_lift_id_left' {a b c : ğ’³} (R : ğ’®) (Ï† : a âŸ¶ b) [p.IsHomLift (ğŸ™ R) Ï†]\n    {S T : ğ’®} (f : S âŸ¶ T) (Ïˆ : b âŸ¶ c) [p.IsHomLift f Ïˆ] : p.IsHomLift f (Ï† â‰« Ïˆ) := by\n  obtain rfl : R = S := by rw [â† codomain_eq p (ğŸ™ R) Ï†, domain_eq p f Ïˆ]\n  infer_instance\n\n"}
{"name":"CategoryTheory.IsHomLift.eqToHom_domain_lift_id","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\na b : ğ’³\nhab : Eq a b\nR : ğ’®\nhR : Eq (p.obj a) R\nâŠ¢ p.IsHomLift (CategoryTheory.CategoryStruct.id R) (CategoryTheory.eqToHom hab)","decl":"lemma eqToHom_domain_lift_id {p : ğ’³ â¥¤ ğ’®} {a b : ğ’³} (hab : a = b) {R : ğ’®} (hR : p.obj a = R) :\n    p.IsHomLift (ğŸ™ R) (eqToHom hab) := by\n  subst hR hab; simp\n\n"}
{"name":"CategoryTheory.IsHomLift.eqToHom_codomain_lift_id","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\na b : ğ’³\nhab : Eq a b\nS : ğ’®\nhS : Eq (p.obj b) S\nâŠ¢ p.IsHomLift (CategoryTheory.CategoryStruct.id S) (CategoryTheory.eqToHom hab)","decl":"lemma eqToHom_codomain_lift_id {p : ğ’³ â¥¤ ğ’®} {a b : ğ’³} (hab : a = b) {S : ğ’®} (hS : p.obj b = S) :\n    p.IsHomLift (ğŸ™ S) (eqToHom hab) := by\n  subst hS hab; simp\n\n"}
{"name":"CategoryTheory.IsHomLift.id_lift_eqToHom_domain","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\nhRS : Eq R S\na : ğ’³\nha : Eq (p.obj a) R\nâŠ¢ p.IsHomLift (CategoryTheory.eqToHom hRS) (CategoryTheory.CategoryStruct.id a)","decl":"lemma id_lift_eqToHom_domain {p : ğ’³ â¥¤ ğ’®} {R S : ğ’®} (hRS : R = S) {a : ğ’³} (ha : p.obj a = R) :\n    p.IsHomLift (eqToHom hRS) (ğŸ™ a) := by\n  subst hRS ha; simp\n\n"}
{"name":"CategoryTheory.IsHomLift.id_lift_eqToHom_codomain","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\nhRS : Eq R S\nb : ğ’³\nhb : Eq (p.obj b) S\nâŠ¢ p.IsHomLift (CategoryTheory.eqToHom hRS) (CategoryTheory.CategoryStruct.id b)","decl":"lemma id_lift_eqToHom_codomain {p : ğ’³ â¥¤ ğ’®} {R S : ğ’®} (hRS : R = S) {b : ğ’³} (hb : p.obj b = S) :\n    p.IsHomLift (eqToHom hRS) (ğŸ™ b) := by\n  subst hRS hb; simp\n\n"}
{"name":"CategoryTheory.IsHomLift.comp_eqToHom_lift","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na' a b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\nh : Eq a' a\ninstâœ : p.IsHomLift f Ï†\nâŠ¢ p.IsHomLift f (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h) Ï†)","decl":"instance comp_eqToHom_lift {R S : ğ’®} {a' a b : ğ’³} (f : R âŸ¶ S) (Ï† : a âŸ¶ b) (h : a' = a)\n    [p.IsHomLift f Ï†] : p.IsHomLift f (eqToHom h â‰« Ï†) := by\n  subst h; simp_all\n\n"}
{"name":"CategoryTheory.IsHomLift.eqToHom_comp_lift","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b b' : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\nh : Eq b b'\ninstâœ : p.IsHomLift f Ï†\nâŠ¢ p.IsHomLift f (CategoryTheory.CategoryStruct.comp Ï† (CategoryTheory.eqToHom h))","decl":"instance eqToHom_comp_lift {R S : ğ’®} {a b b' : ğ’³} (f : R âŸ¶ S) (Ï† : a âŸ¶ b) (h : b = b')\n    [p.IsHomLift f Ï†] : p.IsHomLift f (Ï† â‰« eqToHom h) := by\n  subst h; simp_all\n\n"}
{"name":"CategoryTheory.IsHomLift.lift_eqToHom_comp","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR' R S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\nh : Eq R' R\ninstâœ : p.IsHomLift f Ï†\nâŠ¢ p.IsHomLift (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h) f) Ï†","decl":"instance lift_eqToHom_comp {R' R S : ğ’®} {a b : ğ’³} (f : R âŸ¶ S) (Ï† : a âŸ¶ b) (h : R' = R)\n    [p.IsHomLift f Ï†] : p.IsHomLift (eqToHom h â‰« f) Ï† := by\n  subst h; simp_all\n\n"}
{"name":"CategoryTheory.IsHomLift.lift_comp_eqToHom","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S S' : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\nh : Eq S S'\ninstâœ : p.IsHomLift f Ï†\nâŠ¢ p.IsHomLift (CategoryTheory.CategoryStruct.comp f (CategoryTheory.eqToHom h)) Ï†","decl":"instance lift_comp_eqToHom {R S S' : ğ’®} {a b : ğ’³} (f : R âŸ¶ S) (Ï† : a âŸ¶ b) (h : S = S')\n    [p.IsHomLift f Ï†] : p.IsHomLift (f â‰« eqToHom h) Ï† := by\n  subst h; simp_all\n\n"}
{"name":"CategoryTheory.IsHomLift.comp_eqToHom_lift_iff","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na' a b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\nh : Eq a' a\nâŠ¢ Iff (p.IsHomLift f (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h) Ï†)) (p.IsHomLift f Ï†)","decl":"@[simp]\nlemma comp_eqToHom_lift_iff {R S : ğ’®} {a' a b : ğ’³} (f : R âŸ¶ S) (Ï† : a âŸ¶ b) (h : a' = a) :\n    p.IsHomLift f (eqToHom h â‰« Ï†) â†” p.IsHomLift f Ï† where\n  mp hÏ†' := by subst h; simpa using hÏ†'\n  mpr _ := inferInstance\n\n"}
{"name":"CategoryTheory.IsHomLift.eqToHom_comp_lift_iff","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b b' : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\nh : Eq b b'\nâŠ¢ Iff (p.IsHomLift f (CategoryTheory.CategoryStruct.comp Ï† (CategoryTheory.eqToHom h))) (p.IsHomLift f Ï†)","decl":"@[simp]\nlemma eqToHom_comp_lift_iff {R S : ğ’®} {a b b' : ğ’³} (f : R âŸ¶ S) (Ï† : a âŸ¶ b) (h : b = b') :\n    p.IsHomLift f (Ï† â‰« eqToHom h) â†” p.IsHomLift f Ï† where\n  mp hÏ†' := by subst h; simpa using hÏ†'\n  mpr _ := inferInstance\n\n"}
{"name":"CategoryTheory.IsHomLift.lift_eqToHom_comp_iff","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR' R S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\nh : Eq R' R\nâŠ¢ Iff (p.IsHomLift (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h) f) Ï†) (p.IsHomLift f Ï†)","decl":"@[simp]\nlemma lift_eqToHom_comp_iff {R' R S : ğ’®} {a b : ğ’³} (f : R âŸ¶ S) (Ï† : a âŸ¶ b) (h : R' = R) :\n    p.IsHomLift (eqToHom h â‰« f) Ï† â†” p.IsHomLift f Ï† where\n  mp hÏ†' := by subst h; simpa using hÏ†'\n  mpr _ := inferInstance\n\n"}
{"name":"CategoryTheory.IsHomLift.lift_comp_eqToHom_iff","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S S' : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\nh : Eq S S'\nâŠ¢ Iff (p.IsHomLift (CategoryTheory.CategoryStruct.comp f (CategoryTheory.eqToHom h)) Ï†) (p.IsHomLift f Ï†)","decl":"@[simp]\nlemma lift_comp_eqToHom_iff {R S S' : ğ’®} {a b : ğ’³} (f : R âŸ¶ S) (Ï† : a âŸ¶ b) (h : S = S') :\n    p.IsHomLift (f â‰« eqToHom h) Ï† â†” p.IsHomLift f Ï† where\n  mp := fun hÏ†' => by subst h; simpa using hÏ†'\n  mpr := fun _ => inferInstance\n\n"}
{"name":"CategoryTheory.IsHomLift.isoOfIsoLift_hom","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : CategoryTheory.Iso a b\ninstâœ : p.IsHomLift f Ï†.hom\nâŠ¢ Eq (CategoryTheory.IsHomLift.isoOfIsoLift p f Ï†).hom f","decl":"/-- Given a morphism `f : R âŸ¶ S`, and an isomorphism `Ï† : a â‰… b` lifting `f`, `isoOfIsoLift f Ï†` is\nthe isomorphism `Î¦ : R â‰… S` with `Î¦.hom = f` induced from `Ï†` -/\n@[simps hom]\ndef isoOfIsoLift (f : R âŸ¶ S) (Ï† : a â‰… b) [p.IsHomLift f Ï†.hom] :\n    R â‰… S where\n  hom := f\n  inv := eqToHom (codomain_eq p f Ï†.hom).symm â‰« (p.mapIso Ï†).inv â‰« eqToHom (domain_eq p f Ï†.hom)\n  hom_inv_id := by subst_hom_lift p f Ï†.hom; simp [â† p.map_comp]\n  inv_hom_id := by subst_hom_lift p f Ï†.hom; simp [â† p.map_comp]\n\n"}
{"name":"CategoryTheory.IsHomLift.isoOfIsoLift_inv_hom_id","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : CategoryTheory.Iso a b\ninstâœ : p.IsHomLift f Ï†.hom\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsHomLift.isoOfIsoLift p f Ï†).inv f) (CategoryTheory.CategoryStruct.id S)","decl":"@[simp]\nlemma isoOfIsoLift_inv_hom_id (f : R âŸ¶ S) (Ï† : a â‰… b) [p.IsHomLift f Ï†.hom] :\n    (isoOfIsoLift p f Ï†).inv â‰« f = ğŸ™ S :=\n  (isoOfIsoLift p f Ï†).inv_hom_id\n\n"}
{"name":"CategoryTheory.IsHomLift.isoOfIsoLift_hom_inv_id","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : CategoryTheory.Iso a b\ninstâœ : p.IsHomLift f Ï†.hom\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.IsHomLift.isoOfIsoLift p f Ï†).inv) (CategoryTheory.CategoryStruct.id R)","decl":"@[simp]\nlemma isoOfIsoLift_hom_inv_id (f : R âŸ¶ S) (Ï† : a â‰… b) [p.IsHomLift f Ï†.hom] :\n    f â‰« (isoOfIsoLift p f Ï†).inv = ğŸ™ R :=\n  (isoOfIsoLift p f Ï†).hom_inv_id\n\n"}
{"name":"CategoryTheory.IsHomLift.isIso_of_lift_isIso","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsHomLift f Ï†\ninstâœ : CategoryTheory.IsIso Ï†\nâŠ¢ CategoryTheory.IsIso f","decl":"/-- If `Ï† : a âŸ¶ b` lifts `f : R âŸ¶ S` and `Ï†` is an isomorphism, then so is `f`. -/\nlemma isIso_of_lift_isIso (f : R âŸ¶ S) (Ï† : a âŸ¶ b) [p.IsHomLift f Ï†] [IsIso Ï†] : IsIso f :=\n  (fac p f Ï†) â–¸ inferInstance\n\n"}
{"name":"CategoryTheory.IsHomLift.inv_lift_inv","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : CategoryTheory.Iso R S\nÏ† : CategoryTheory.Iso a b\ninstâœ : p.IsHomLift f.hom Ï†.hom\nâŠ¢ p.IsHomLift f.inv Ï†.inv","decl":"/-- Given `Ï† : a â‰… b` and `f : R â‰… S`, such that `Ï†.hom` lifts `f.hom`, then `Ï†.inv` lifts\n`f.inv`. -/\ninstance inv_lift_inv (f : R â‰… S) (Ï† : a â‰… b) [p.IsHomLift f.hom Ï†.hom] :\n    p.IsHomLift f.inv Ï†.inv := by\n  apply of_commSq\n  apply CommSq.horiz_inv (f := p.mapIso Ï†) (commSq p f.hom Ï†.hom)\n\n"}
{"name":"CategoryTheory.IsHomLift.inv_lift","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : CategoryTheory.Iso a b\ninstâœ : p.IsHomLift f Ï†.hom\nâŠ¢ p.IsHomLift (CategoryTheory.IsHomLift.isoOfIsoLift p f Ï†).inv Ï†.inv","decl":"/-- Given `Ï† : a â‰… b` and `f : R âŸ¶ S`, such that `Ï†.hom` lifts `f`, then `Ï†.inv` lifts the\ninverse of `f` given by `isoOfIsoLift`. -/\ninstance inv_lift (f : R âŸ¶ S) (Ï† : a â‰… b) [p.IsHomLift f Ï†.hom] :\n    p.IsHomLift (isoOfIsoLift p f Ï†).inv Ï†.inv := by\n  apply of_commSq\n  apply CommSq.horiz_inv (f := p.mapIso Ï†) (by apply commSq p f Ï†.hom)\n\n"}
{"name":"CategoryTheory.IsHomLift.inv","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ² : CategoryTheory.IsIso f\ninstâœÂ¹ : CategoryTheory.IsIso Ï†\ninstâœ : p.IsHomLift f Ï†\nâŠ¢ p.IsHomLift (CategoryTheory.inv f) (CategoryTheory.inv Ï†)","decl":"/-- If `Ï† : a âŸ¶ b` lifts `f : R âŸ¶ S` and both are isomorphisms, then `Ï†â»Â¹` lifts `fâ»Â¹`. -/\nprotected instance inv (f : R âŸ¶ S) (Ï† : a âŸ¶ b) [IsIso f] [IsIso Ï†] [p.IsHomLift f Ï†] :\n    p.IsHomLift (inv f) (inv Ï†) :=\n  have : p.IsHomLift (asIso f).hom (asIso Ï†).hom := by simp_all\n  IsHomLift.inv_lift_inv p (asIso f) (asIso Ï†)\n\n"}
{"name":"CategoryTheory.IsHomLift.lift_id_inv","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nS : ğ’®\na b : ğ’³\nÏ† : CategoryTheory.Iso a b\ninstâœ : p.IsHomLift (CategoryTheory.CategoryStruct.id S) Ï†.hom\nâŠ¢ p.IsHomLift (CategoryTheory.CategoryStruct.id S) Ï†.inv","decl":"/-- If `Ï† : a â‰… b` is an isomorphism lifting `ğŸ™ S` for some `S : ğ’®`, then `Ï†â»Â¹` also\nlifts `ğŸ™ S`. -/\ninstance lift_id_inv (S : ğ’®) {a b : ğ’³} (Ï† : a â‰… b) [p.IsHomLift (ğŸ™ S) Ï†.hom] :\n    p.IsHomLift (ğŸ™ S) Ï†.inv :=\n  have : p.IsHomLift (asIso (ğŸ™ S)).hom Ï†.hom := by simp_all\n  (IsIso.inv_id (X := S)) â–¸ (IsHomLift.inv_lift_inv p (asIso (ğŸ™ S)) Ï†)\n\n"}
{"name":"CategoryTheory.IsHomLift.lift_id_inv_isIso","module":"Mathlib.CategoryTheory.FiberedCategory.HomLift","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚‚} ğ’³\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚} ğ’®\np : CategoryTheory.Functor ğ’³ ğ’®\nS : ğ’®\na b : ğ’³\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : CategoryTheory.IsIso Ï†\ninstâœ : p.IsHomLift (CategoryTheory.CategoryStruct.id S) Ï†\nâŠ¢ p.IsHomLift (CategoryTheory.CategoryStruct.id S) (CategoryTheory.inv Ï†)","decl":"instance lift_id_inv_isIso (S : ğ’®) {a b : ğ’³} (Ï† : a âŸ¶ b) [IsIso Ï†] [p.IsHomLift (ğŸ™ S) Ï†] :\n    p.IsHomLift (ğŸ™ S) (inv Ï†) :=\n  (IsIso.inv_id (X := S)) â–¸ (IsHomLift.inv p _ Ï†)\n\n"}
