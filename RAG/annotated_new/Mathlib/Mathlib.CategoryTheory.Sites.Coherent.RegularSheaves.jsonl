{"name":"CategoryTheory.Presieve.regular.single_epi","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_4, u_1} C\nX : C\nR : CategoryTheory.Presieve X\nself : R.regular\nâŠ¢ Exists fun Y => Exists fun f => And (Eq R (CategoryTheory.Presieve.ofArrows (fun x => Y) fun x => f)) (CategoryTheory.EffectiveEpi f)","decl":"/-- A presieve is *regular* if it consists of a single effective epimorphism. -/\nclass Presieve.regular {X : C} (R : Presieve X) : Prop where\n  /-- `R` consists of a single epimorphism. -/\n  single_epi : âˆƒ (Y : C) (f : Y âŸ¶ X), R = Presieve.ofArrows (fun (_ : Unit) â†¦ Y)\n    (fun (_ : Unit) â†¦ f) âˆ§ EffectiveEpi f\n\n"}
{"name":"CategoryTheory.regularTopology.equalizerCondition_w","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ¹ : CategoryTheory.Category.{u_4, u_1} C\ninstâœ : CategoryTheory.Category.{u_5, u_2} D\nP : CategoryTheory.Functor (Opposite C) D\nX B : C\nÏ€ : Quiver.Hom X B\nc : CategoryTheory.Limits.PullbackCone Ï€ Ï€\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (P.map Ï€.op) (P.map c.fst.op)) (CategoryTheory.CategoryStruct.comp (P.map Ï€.op) (P.map c.snd.op))","decl":"lemma equalizerCondition_w (P : Cáµ’áµ– â¥¤ D) {X B : C} {Ï€ : X âŸ¶ B} (c : PullbackCone Ï€ Ï€) :\n    P.map Ï€.op â‰« P.map c.fst.op = P.map Ï€.op â‰« P.map c.snd.op := by\n  simp only [â† Functor.map_comp, â† op_comp, c.condition]\n\n"}
{"name":"CategoryTheory.regularTopology.equalizerCondition_of_natIso","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ¹ : CategoryTheory.Category.{u_4, u_1} C\ninstâœ : CategoryTheory.Category.{u_5, u_2} D\nP P' : CategoryTheory.Functor (Opposite C) D\ni : CategoryTheory.Iso P P'\nhP : CategoryTheory.regularTopology.EqualizerCondition P\nâŠ¢ CategoryTheory.regularTopology.EqualizerCondition P'","decl":"/-- The equalizer condition is preserved by natural isomorphism. -/\ntheorem equalizerCondition_of_natIso {P P' : Cáµ’áµ– â¥¤ D} (i : P â‰… P')\n    (hP : EqualizerCondition P) : EqualizerCondition P' := fun X B Ï€ _ c hc â†¦\n  âŸ¨Fork.isLimitOfIsos _ (hP Ï€ c hc).some _ (i.app _) (i.app _) (i.app _)âŸ©\n\n"}
{"name":"CategoryTheory.regularTopology.equalizerCondition_precomp_of_preservesPullback","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_5, u_2} D\ninstâœÂ² : CategoryTheory.Category.{u_6, u_3} E\nP : CategoryTheory.Functor (Opposite C) D\nF : CategoryTheory.Functor E C\ninstâœÂ¹ : âˆ€ {X B : E} (Ï€ : Quiver.Hom X B) [inst : CategoryTheory.EffectiveEpi Ï€], CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan Ï€ Ï€) F\ninstâœ : F.PreservesEffectiveEpis\nhP : CategoryTheory.regularTopology.EqualizerCondition P\nâŠ¢ CategoryTheory.regularTopology.EqualizerCondition (F.op.comp P)","decl":"/-- Precomposing with a pullback-preserving functor preserves the equalizer condition. -/\ntheorem equalizerCondition_precomp_of_preservesPullback (P : Cáµ’áµ– â¥¤ D) (F : E â¥¤ C)\n    [âˆ€ {X B} (Ï€ : X âŸ¶ B) [EffectiveEpi Ï€], PreservesLimit (cospan Ï€ Ï€) F]\n    [F.PreservesEffectiveEpis] (hP : EqualizerCondition P) : EqualizerCondition (F.op â‹™ P) := by\n  intro X B Ï€ _ c hc\n  have h : P.map (F.map Ï€).op = (F.op â‹™ P).map Ï€.op := by simp\n  refine âŸ¨(IsLimit.equivIsoLimit (ForkOfÎ¹.ext ?_ _ h)) ?_âŸ©\n  Â· simp only [Functor.comp_map, op_map, Quiver.Hom.unop_op, â† map_comp, â† op_comp, c.condition]\n  Â· refine (hP (F.map Ï€) (PullbackCone.mk (F.map c.fst) (F.map c.snd) ?_) ?_).some\n    Â· simp only [â† map_comp, c.condition]\n    Â· exact (isLimitMapConePullbackConeEquiv F c.condition)\n        (isLimitOfPreserves F (hc.ofIsoLimit (PullbackCone.ext (Iso.refl _) (by simp) (by simp))))\n\n"}
{"name":"CategoryTheory.regularTopology.EqualizerCondition.bijective_mapToEqualizer_pullback","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_5, u_1} C\nP : CategoryTheory.Functor (Opposite C) (Type u_4)\nhP : CategoryTheory.regularTopology.EqualizerCondition P\nX B : C\nÏ€ : Quiver.Hom X B\ninstâœÂ¹ : CategoryTheory.EffectiveEpi Ï€\ninstâœ : CategoryTheory.Limits.HasPullback Ï€ Ï€\nâŠ¢ Function.Bijective (CategoryTheory.regularTopology.MapToEqualizer P Ï€ (CategoryTheory.Limits.pullback.fst Ï€ Ï€) (CategoryTheory.Limits.pullback.snd Ï€ Ï€) â‹¯)","decl":"theorem EqualizerCondition.bijective_mapToEqualizer_pullback (P : Cáµ’áµ– â¥¤ Type*)\n    (hP : EqualizerCondition P) : âˆ€ (X B : C) (Ï€ : X âŸ¶ B) [EffectiveEpi Ï€] [HasPullback Ï€ Ï€],\n    Function.Bijective\n      (MapToEqualizer P Ï€ (pullback.fst Ï€ Ï€) (pullback.snd Ï€ Ï€) pullback.condition) := by\n  intro X B Ï€ _ _\n  specialize hP Ï€ _ (pullbackIsPullback Ï€ Ï€)\n  rw [Types.type_equalizer_iff_unique] at hP\n  rw [Function.bijective_iff_existsUnique]\n  intro âŸ¨b, hbâŸ©\n  obtain âŸ¨a, haâ‚, haâ‚‚âŸ© := hP b hb\n  refine âŸ¨a, ?_, ?_âŸ©\n  Â· simpa [MapToEqualizer] using haâ‚\n  Â· simpa [MapToEqualizer] using haâ‚‚\n\n"}
{"name":"CategoryTheory.regularTopology.EqualizerCondition.mk","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_5, u_1} C\nP : CategoryTheory.Functor (Opposite C) (Type u_4)\nhP : âˆ€ (X B : C) (Ï€ : Quiver.Hom X B) [inst : CategoryTheory.EffectiveEpi Ï€] [inst : CategoryTheory.Limits.HasPullback Ï€ Ï€], Function.Bijective (CategoryTheory.regularTopology.MapToEqualizer P Ï€ (CategoryTheory.Limits.pullback.fst Ï€ Ï€) (CategoryTheory.Limits.pullback.snd Ï€ Ï€) â‹¯)\nâŠ¢ CategoryTheory.regularTopology.EqualizerCondition P","decl":"theorem EqualizerCondition.mk (P : Cáµ’áµ– â¥¤ Type*)\n    (hP : âˆ€ (X B : C) (Ï€ : X âŸ¶ B) [EffectiveEpi Ï€] [HasPullback Ï€ Ï€], Function.Bijective\n    (MapToEqualizer P Ï€ (pullback.fst Ï€ Ï€) (pullback.snd Ï€ Ï€)\n    pullback.condition)) : EqualizerCondition P := by\n  intro X B Ï€ _ c hc\n  have : HasPullback Ï€ Ï€ := âŸ¨c, hcâŸ©\n  specialize hP X B Ï€\n  rw [Types.type_equalizer_iff_unique]\n  rw [Function.bijective_iff_existsUnique] at hP\n  intro b hb\n  have hâ‚ : ((pullbackIsPullback Ï€ Ï€).conePointUniqueUpToIso hc).hom â‰« c.fst =\n    pullback.fst Ï€ Ï€ := by simp\n  have hb' : P.map (pullback.fst Ï€ Ï€).op b = P.map (pullback.snd _ _).op b := by\n    rw [â† hâ‚, op_comp, FunctorToTypes.map_comp_apply, hb]\n    simp [â† FunctorToTypes.map_comp_apply, â† op_comp]\n  obtain âŸ¨a, haâ‚, haâ‚‚âŸ© := hP âŸ¨b, hb'âŸ©\n  refine âŸ¨a, ?_, ?_âŸ©\n  Â· simpa [MapToEqualizer] using haâ‚\n  Â· simpa [MapToEqualizer] using haâ‚‚\n\n"}
{"name":"CategoryTheory.regularTopology.equalizerCondition_w'","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_1} C\nP : CategoryTheory.Functor (Opposite C) (Type u_4)\nX B : C\nÏ€ : Quiver.Hom X B\ninstâœ : CategoryTheory.Limits.HasPullback Ï€ Ï€\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (P.map Ï€.op) (P.map (CategoryTheory.Limits.pullback.fst Ï€ Ï€).op)) (CategoryTheory.CategoryStruct.comp (P.map Ï€.op) (P.map (CategoryTheory.Limits.pullback.snd Ï€ Ï€).op))","decl":"lemma equalizerCondition_w' (P : Cáµ’áµ– â¥¤ Type*) {X B : C} (Ï€ : X âŸ¶ B)\n    [HasPullback Ï€ Ï€] : P.map Ï€.op â‰« P.map (pullback.fst Ï€ Ï€).op =\n    P.map Ï€.op â‰« P.map (pullback.snd Ï€ Ï€).op := by\n  simp only [â† Functor.map_comp, â† op_comp, pullback.condition]\n\n"}
{"name":"CategoryTheory.regularTopology.mapToEqualizer_eq_comp","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_1} C\nP : CategoryTheory.Functor (Opposite C) (Type u_4)\nX B : C\nÏ€ : Quiver.Hom X B\ninstâœ : CategoryTheory.Limits.HasPullback Ï€ Ï€\nâŠ¢ Eq (CategoryTheory.regularTopology.MapToEqualizer P Ï€ (CategoryTheory.Limits.pullback.fst Ï€ Ï€) (CategoryTheory.Limits.pullback.snd Ï€ Ï€) â‹¯) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizer.lift (P.map Ï€.op) â‹¯) (CategoryTheory.Limits.Types.equalizerIso (P.map (CategoryTheory.Limits.pullback.fst Ï€ Ï€).op) (P.map (CategoryTheory.Limits.pullback.snd Ï€ Ï€).op)).hom)","decl":"lemma mapToEqualizer_eq_comp (P : Cáµ’áµ– â¥¤ Type*) {X B : C} (Ï€ : X âŸ¶ B) [HasPullback Ï€ Ï€] :\n    MapToEqualizer P Ï€ (pullback.fst Ï€ Ï€) (pullback.snd Ï€ Ï€) pullback.condition =\n    equalizer.lift (P.map Ï€.op) (equalizerCondition_w' P Ï€) â‰«\n    (Types.equalizerIso _ _).hom := by\n  rw [â† Iso.comp_inv_eq (Î± := Types.equalizerIso _ _)]\n  apply equalizer.hom_ext\n  aesop\n\n"}
{"name":"CategoryTheory.regularTopology.equalizerCondition_iff_isIso_lift","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_5, u_1} C\nP : CategoryTheory.Functor (Opposite C) (Type u_4)\nâŠ¢ Iff (CategoryTheory.regularTopology.EqualizerCondition P) (âˆ€ (X B : C) (Ï€ : Quiver.Hom X B) [inst : CategoryTheory.EffectiveEpi Ï€] [inst : CategoryTheory.Limits.HasPullback Ï€ Ï€], CategoryTheory.IsIso (CategoryTheory.Limits.equalizer.lift (P.map Ï€.op) â‹¯))","decl":"/-- An alternative phrasing of the explicit equalizer condition, using more categorical language. -/\ntheorem equalizerCondition_iff_isIso_lift (P : Cáµ’áµ– â¥¤ Type*) : EqualizerCondition P â†”\n    âˆ€ (X B : C) (Ï€ : X âŸ¶ B) [EffectiveEpi Ï€] [HasPullback Ï€ Ï€],\n      IsIso (equalizer.lift (P.map Ï€.op) (equalizerCondition_w' P Ï€)) := by\n  constructor\n  Â· intro hP X B Ï€ _ _\n    have h := hP.bijective_mapToEqualizer_pullback _ X B Ï€\n    rw [â† isIso_iff_bijective, mapToEqualizer_eq_comp] at h\n    exact IsIso.of_isIso_comp_right (equalizer.lift (P.map Ï€.op)\n      (equalizerCondition_w' P Ï€))\n      (Types.equalizerIso _ _).hom\n  Â· intro hP\n    apply EqualizerCondition.mk\n    intro X B Ï€ _ _\n    rw [mapToEqualizer_eq_comp, â† isIso_iff_bijective]\n    infer_instance\n\n"}
{"name":"CategoryTheory.regularTopology.equalizerCondition_iff_of_equivalence","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninstâœÂ² : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_2} D\ninstâœ : CategoryTheory.Category.{u_6, u_3} E\nP : CategoryTheory.Functor (Opposite C) D\ne : CategoryTheory.Equivalence C E\nâŠ¢ Iff (CategoryTheory.regularTopology.EqualizerCondition P) (CategoryTheory.regularTopology.EqualizerCondition (e.op.inverse.comp P))","decl":"/-- `P` satisfies the equalizer condition iff its precomposition by an equivalence does. -/\ntheorem equalizerCondition_iff_of_equivalence (P : Cáµ’áµ– â¥¤ D)\n    (e : C â‰Œ E) : EqualizerCondition P â†” EqualizerCondition (e.op.inverse â‹™ P) :=\n  âŸ¨fun h â†¦ equalizerCondition_precomp_of_preservesPullback P e.inverse h, fun h â†¦\n    equalizerCondition_of_natIso (e.op.funInvIdAssoc P)\n      (equalizerCondition_precomp_of_preservesPullback (e.op.inverse â‹™ P) e.functor h)âŸ©\n\n"}
{"name":"CategoryTheory.regularTopology.parallelPair_pullback_initial","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_4, u_1} C\nX B : C\nÏ€ : Quiver.Hom X B\nc : CategoryTheory.Limits.PullbackCone Ï€ Ï€\nhc : CategoryTheory.Limits.IsLimit c\nâŠ¢ (CategoryTheory.Limits.parallelPair (CategoryTheory.Over.homMk c.fst â‹¯).op (CategoryTheory.Over.homMk c.snd â‹¯).op).Initial","decl":"open WalkingParallelPair WalkingParallelPairHom in\ntheorem parallelPair_pullback_initial {X B : C} (Ï€ : X âŸ¶ B)\n    (c : PullbackCone Ï€ Ï€) (hc : IsLimit c) :\n    (parallelPair (C := (Sieve.ofArrows (fun (_ : Unit) => X) (fun _ => Ï€)).arrows.categoryáµ’áµ–)\n    (Y := op ((Presieve.categoryMk _ (c.fst â‰« Ï€) âŸ¨_, c.fst, Ï€, ofArrows.mk (), rflâŸ©)))\n    (X := op ((Presieve.categoryMk _ Ï€ (Sieve.ofArrows_mk _ _ Unit.unit))))\n    (Quiver.Hom.op (Over.homMk c.fst))\n    (Quiver.Hom.op (Over.homMk c.snd c.condition.symm))).Initial := by\n  apply Limits.parallelPair_initial_mk\n  Â· intro âŸ¨ZâŸ©\n    obtain âŸ¨_, f, g, âŸ¨âŸ©, hhâŸ© := Z.property\n    let X' : (Presieve.ofArrows (fun () â†¦ X) (fun () â†¦ Ï€)).category :=\n      Presieve.categoryMk _ Ï€ (ofArrows.mk ())\n    let f' : Z.obj.left âŸ¶ X'.obj.left := f\n    exact âŸ¨(Over.homMk f').opâŸ©\n  Â· intro âŸ¨ZâŸ© âŸ¨iâŸ© âŸ¨jâŸ©\n    let ij := PullbackCone.IsLimit.lift hc i.left j.left (by erw [i.w, j.w]; rfl)\n    refine âŸ¨Quiver.Hom.op (Over.homMk ij (by simpa [ij] using i.w)), ?_, ?_âŸ©\n    all_goals congr\n    all_goals exact Comma.hom_ext _ _ (by erw [Over.comp_left]; simp [ij]) rfl\n\n"}
{"name":"CategoryTheory.regularTopology.equalizerConditionMap_iff_nonempty_isLimit","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ² : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_2} D\nP : CategoryTheory.Functor (Opposite C) D\nX B : C\nÏ€ : Quiver.Hom X B\ninstâœ : CategoryTheory.Limits.HasPullback Ï€ Ï€\nâŠ¢ Iff (CategoryTheory.regularTopology.SingleEqualizerCondition P Ï€) (Nonempty (CategoryTheory.Limits.IsLimit (P.mapCone (CategoryTheory.Sieve.ofArrows (fun x => X) fun x => Ï€).arrows.cocone.op)))","decl":"lemma equalizerConditionMap_iff_nonempty_isLimit (P : Cáµ’áµ– â¥¤ D) â¦ƒX B : Câ¦„ (Ï€ : X âŸ¶ B)\n    [HasPullback Ï€ Ï€] : SingleEqualizerCondition P Ï€ â†”\n      Nonempty (IsLimit (P.mapCone\n        (Sieve.ofArrows (fun (_ : Unit) => X) (fun _ => Ï€)).arrows.cocone.op)) := by\n  constructor\n  Â· intro h\n    exact âŸ¨isLimit_forkOfÎ¹_equiv _ _ _ (pullbackIsPullback Ï€ Ï€) (h _ (pullbackIsPullback Ï€ Ï€)).someâŸ©\n  Â· intro âŸ¨hâŸ©\n    exact fun c hc â†¦ âŸ¨(isLimit_forkOfÎ¹_equiv _ _ _ hc).symm hâŸ©\n\n"}
{"name":"CategoryTheory.regularTopology.equalizerCondition_iff_isSheaf","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor (Opposite C) D\ninstâœÂ¹ : CategoryTheory.Preregular C\ninstâœ : âˆ€ {Y X : C} (f : Quiver.Hom Y X) [inst : CategoryTheory.EffectiveEpi f], CategoryTheory.Limits.HasPullback f f\nâŠ¢ Iff (CategoryTheory.regularTopology.EqualizerCondition F) (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.regularTopology C) F)","decl":"lemma equalizerCondition_iff_isSheaf (F : Cáµ’áµ– â¥¤ D) [Preregular C]\n    [âˆ€ {Y X : C} (f : Y âŸ¶ X) [EffectiveEpi f], HasPullback f f] :\n    EqualizerCondition F â†” Presheaf.IsSheaf (regularTopology C) F := by\n  dsimp [regularTopology]\n  rw [Presheaf.isSheaf_iff_isLimit_coverage]\n  constructor\n  Â· rintro hF X _ âŸ¨Y, f, rfl, _âŸ©\n    exact (equalizerConditionMap_iff_nonempty_isLimit F f).1 (hF f)\n  Â· intro hF Y X f _\n    exact (equalizerConditionMap_iff_nonempty_isLimit F f).2 (hF _ âŸ¨_, f, rfl, inferInstanceâŸ©)\n\n"}
{"name":"CategoryTheory.regularTopology.isSheafFor_regular_of_projective","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_5, u_1} C\nX : C\nS : CategoryTheory.Presieve X\ninstâœÂ¹ : S.regular\ninstâœ : CategoryTheory.Projective X\nF : CategoryTheory.Functor (Opposite C) (Type u_4)\nâŠ¢ CategoryTheory.Presieve.IsSheafFor F S","decl":"lemma isSheafFor_regular_of_projective {X : C} (S : Presieve X) [S.regular] [Projective X]\n    (F : Cáµ’áµ– â¥¤ Type*) : S.IsSheafFor F := by\n  obtain âŸ¨Y, f, rfl, hfâŸ© := Presieve.regular.single_epi (R := S)\n  rw [isSheafFor_arrows_iff]\n  refine fun x hx â†¦ âŸ¨F.map (Projective.factorThru (ğŸ™ _) f).op <| x (), fun _ â†¦ ?_, fun y h â†¦ ?_âŸ©\n  Â· simpa using (hx () () Y (ğŸ™ Y) (f â‰« (Projective.factorThru (ğŸ™ _) f)) (by simp)).symm\n  Â· simp only [â† h (), â† FunctorToTypes.map_comp_apply, â† op_comp, Projective.factorThru_comp,\n      op_id, FunctorToTypes.map_id_apply]\n\n"}
{"name":"CategoryTheory.regularTopology.isSheaf_of_projective","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor (Opposite C) D\ninstâœÂ¹ : CategoryTheory.Preregular C\ninstâœ : âˆ€ (X : C), CategoryTheory.Projective X\nâŠ¢ CategoryTheory.Presheaf.IsSheaf (CategoryTheory.regularTopology C) F","decl":"/-- Every presheaf is a sheaf for the regular topology if every object of `C` is projective. -/\ntheorem isSheaf_of_projective (F : Cáµ’áµ– â¥¤ D) [Preregular C] [âˆ€ (X : C), Projective X] :\n    Presheaf.IsSheaf (regularTopology C) F :=\n  fun _ â†¦ (isSheaf_coverage _ _).mpr fun S âŸ¨_, hâŸ© â†¦ have : S.regular := âŸ¨_, hâŸ©\n    isSheafFor_regular_of_projective _ _\n\n"}
{"name":"CategoryTheory.regularTopology.isSheaf_yoneda_obj","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_4, u_1} C\ninstâœ : CategoryTheory.Preregular C\nW : C\nâŠ¢ CategoryTheory.Presieve.IsSheaf (CategoryTheory.regularTopology C) (CategoryTheory.yoneda.obj W)","decl":"/-- Every Yoneda-presheaf is a sheaf for the regular topology. -/\nlemma isSheaf_yoneda_obj [Preregular C] (W : C)  :\n    Presieve.IsSheaf (regularTopology C) (yoneda.obj W) := by\n  rw [regularTopology, isSheaf_coverage]\n  intro X S âŸ¨_, hSâŸ©\n  have : S.regular := âŸ¨_, hSâŸ©\n  obtain âŸ¨Y, f, rfl, hfâŸ© := Presieve.regular.single_epi (R := S)\n  have h_colim := isColimitOfEffectiveEpiStruct f hf.effectiveEpi.some\n  rw [â† Sieve.generateSingleton_eq, â† Presieve.ofArrows_pUnit] at h_colim\n  intro x hx\n  let x_ext := Presieve.FamilyOfElements.sieveExtend x\n  have hx_ext := Presieve.FamilyOfElements.Compatible.sieveExtend hx\n  let S := Sieve.generate (Presieve.ofArrows (fun () â†¦ Y) (fun () â†¦ f))\n  obtain âŸ¨t, t_amalg, t_uniqâŸ© :=\n    (Sieve.forallYonedaIsSheaf_iff_colimit S).mpr âŸ¨h_colimâŸ© W x_ext hx_ext\n  refine âŸ¨t, ?_, ?_âŸ©\n  Â· convert Presieve.isAmalgamation_restrict (Sieve.le_generate\n      (Presieve.ofArrows (fun () â†¦ Y) (fun () â†¦ f))) _ _ t_amalg\n    exact (Presieve.restrict_extend hx).symm\n  Â· exact fun y hy â†¦ t_uniq y <| Presieve.isAmalgamation_sieveExtend x y hy\n\n"}
{"name":"CategoryTheory.regularTopology.subcanonical","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_4, u_1} C\ninstâœ : CategoryTheory.Preregular C\nâŠ¢ (CategoryTheory.regularTopology C).Subcanonical","decl":"/-- The regular topology on any preregular category is subcanonical. -/\ninstance subcanonical [Preregular C] : (regularTopology C).Subcanonical :=\n  GrothendieckTopology.Subcanonical.of_isSheaf_yoneda_obj _ isSheaf_yoneda_obj\n\n"}
