{"name":"CategoryTheory.Presieve.regular.single_epi","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_4, u_1} C\nX : C\nR : CategoryTheory.Presieve X\nself : R.regular\n⊢ Exists fun Y => Exists fun f => And (Eq R (CategoryTheory.Presieve.ofArrows (fun x => Y) fun x => f)) (CategoryTheory.EffectiveEpi f)","decl":"/-- A presieve is *regular* if it consists of a single effective epimorphism. -/\nclass Presieve.regular {X : C} (R : Presieve X) : Prop where\n  /-- `R` consists of a single epimorphism. -/\n  single_epi : ∃ (Y : C) (f : Y ⟶ X), R = Presieve.ofArrows (fun (_ : Unit) ↦ Y)\n    (fun (_ : Unit) ↦ f) ∧ EffectiveEpi f\n\n"}
{"name":"CategoryTheory.regularTopology.equalizerCondition_w","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Category.{u_5, u_2} D\nP : CategoryTheory.Functor (Opposite C) D\nX B : C\nπ : Quiver.Hom X B\nc : CategoryTheory.Limits.PullbackCone π π\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.map π.op) (P.map c.fst.op)) (CategoryTheory.CategoryStruct.comp (P.map π.op) (P.map c.snd.op))","decl":"lemma equalizerCondition_w (P : Cᵒᵖ ⥤ D) {X B : C} {π : X ⟶ B} (c : PullbackCone π π) :\n    P.map π.op ≫ P.map c.fst.op = P.map π.op ≫ P.map c.snd.op := by\n  simp only [← Functor.map_comp, ← op_comp, c.condition]\n\n"}
{"name":"CategoryTheory.regularTopology.equalizerCondition_of_natIso","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Category.{u_5, u_2} D\nP P' : CategoryTheory.Functor (Opposite C) D\ni : CategoryTheory.Iso P P'\nhP : CategoryTheory.regularTopology.EqualizerCondition P\n⊢ CategoryTheory.regularTopology.EqualizerCondition P'","decl":"/-- The equalizer condition is preserved by natural isomorphism. -/\ntheorem equalizerCondition_of_natIso {P P' : Cᵒᵖ ⥤ D} (i : P ≅ P')\n    (hP : EqualizerCondition P) : EqualizerCondition P' := fun X B π _ c hc ↦\n  ⟨Fork.isLimitOfIsos _ (hP π c hc).some _ (i.app _) (i.app _) (i.app _)⟩\n\n"}
{"name":"CategoryTheory.regularTopology.equalizerCondition_precomp_of_preservesPullback","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\ninst✝² : CategoryTheory.Category.{u_6, u_3} E\nP : CategoryTheory.Functor (Opposite C) D\nF : CategoryTheory.Functor E C\ninst✝¹ : ∀ {X B : E} (π : Quiver.Hom X B) [inst : CategoryTheory.EffectiveEpi π], CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan π π) F\ninst✝ : F.PreservesEffectiveEpis\nhP : CategoryTheory.regularTopology.EqualizerCondition P\n⊢ CategoryTheory.regularTopology.EqualizerCondition (F.op.comp P)","decl":"/-- Precomposing with a pullback-preserving functor preserves the equalizer condition. -/\ntheorem equalizerCondition_precomp_of_preservesPullback (P : Cᵒᵖ ⥤ D) (F : E ⥤ C)\n    [∀ {X B} (π : X ⟶ B) [EffectiveEpi π], PreservesLimit (cospan π π) F]\n    [F.PreservesEffectiveEpis] (hP : EqualizerCondition P) : EqualizerCondition (F.op ⋙ P) := by\n  intro X B π _ c hc\n  have h : P.map (F.map π).op = (F.op ⋙ P).map π.op := by simp\n  refine ⟨(IsLimit.equivIsoLimit (ForkOfι.ext ?_ _ h)) ?_⟩\n  · simp only [Functor.comp_map, op_map, Quiver.Hom.unop_op, ← map_comp, ← op_comp, c.condition]\n  · refine (hP (F.map π) (PullbackCone.mk (F.map c.fst) (F.map c.snd) ?_) ?_).some\n    · simp only [← map_comp, c.condition]\n    · exact (isLimitMapConePullbackConeEquiv F c.condition)\n        (isLimitOfPreserves F (hc.ofIsoLimit (PullbackCone.ext (Iso.refl _) (by simp) (by simp))))\n\n"}
{"name":"CategoryTheory.regularTopology.EqualizerCondition.bijective_mapToEqualizer_pullback","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_5, u_1} C\nP : CategoryTheory.Functor (Opposite C) (Type u_4)\nhP : CategoryTheory.regularTopology.EqualizerCondition P\nX B : C\nπ : Quiver.Hom X B\ninst✝¹ : CategoryTheory.EffectiveEpi π\ninst✝ : CategoryTheory.Limits.HasPullback π π\n⊢ Function.Bijective (CategoryTheory.regularTopology.MapToEqualizer P π (CategoryTheory.Limits.pullback.fst π π) (CategoryTheory.Limits.pullback.snd π π) ⋯)","decl":"theorem EqualizerCondition.bijective_mapToEqualizer_pullback (P : Cᵒᵖ ⥤ Type*)\n    (hP : EqualizerCondition P) : ∀ (X B : C) (π : X ⟶ B) [EffectiveEpi π] [HasPullback π π],\n    Function.Bijective\n      (MapToEqualizer P π (pullback.fst π π) (pullback.snd π π) pullback.condition) := by\n  intro X B π _ _\n  specialize hP π _ (pullbackIsPullback π π)\n  rw [Types.type_equalizer_iff_unique] at hP\n  rw [Function.bijective_iff_existsUnique]\n  intro ⟨b, hb⟩\n  obtain ⟨a, ha₁, ha₂⟩ := hP b hb\n  refine ⟨a, ?_, ?_⟩\n  · simpa [MapToEqualizer] using ha₁\n  · simpa [MapToEqualizer] using ha₂\n\n"}
{"name":"CategoryTheory.regularTopology.EqualizerCondition.mk","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_5, u_1} C\nP : CategoryTheory.Functor (Opposite C) (Type u_4)\nhP : ∀ (X B : C) (π : Quiver.Hom X B) [inst : CategoryTheory.EffectiveEpi π] [inst : CategoryTheory.Limits.HasPullback π π], Function.Bijective (CategoryTheory.regularTopology.MapToEqualizer P π (CategoryTheory.Limits.pullback.fst π π) (CategoryTheory.Limits.pullback.snd π π) ⋯)\n⊢ CategoryTheory.regularTopology.EqualizerCondition P","decl":"theorem EqualizerCondition.mk (P : Cᵒᵖ ⥤ Type*)\n    (hP : ∀ (X B : C) (π : X ⟶ B) [EffectiveEpi π] [HasPullback π π], Function.Bijective\n    (MapToEqualizer P π (pullback.fst π π) (pullback.snd π π)\n    pullback.condition)) : EqualizerCondition P := by\n  intro X B π _ c hc\n  have : HasPullback π π := ⟨c, hc⟩\n  specialize hP X B π\n  rw [Types.type_equalizer_iff_unique]\n  rw [Function.bijective_iff_existsUnique] at hP\n  intro b hb\n  have h₁ : ((pullbackIsPullback π π).conePointUniqueUpToIso hc).hom ≫ c.fst =\n    pullback.fst π π := by simp\n  have hb' : P.map (pullback.fst π π).op b = P.map (pullback.snd _ _).op b := by\n    rw [← h₁, op_comp, FunctorToTypes.map_comp_apply, hb]\n    simp [← FunctorToTypes.map_comp_apply, ← op_comp]\n  obtain ⟨a, ha₁, ha₂⟩ := hP ⟨b, hb'⟩\n  refine ⟨a, ?_, ?_⟩\n  · simpa [MapToEqualizer] using ha₁\n  · simpa [MapToEqualizer] using ha₂\n\n"}
{"name":"CategoryTheory.regularTopology.equalizerCondition_w'","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C\nP : CategoryTheory.Functor (Opposite C) (Type u_4)\nX B : C\nπ : Quiver.Hom X B\ninst✝ : CategoryTheory.Limits.HasPullback π π\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.map π.op) (P.map (CategoryTheory.Limits.pullback.fst π π).op)) (CategoryTheory.CategoryStruct.comp (P.map π.op) (P.map (CategoryTheory.Limits.pullback.snd π π).op))","decl":"lemma equalizerCondition_w' (P : Cᵒᵖ ⥤ Type*) {X B : C} (π : X ⟶ B)\n    [HasPullback π π] : P.map π.op ≫ P.map (pullback.fst π π).op =\n    P.map π.op ≫ P.map (pullback.snd π π).op := by\n  simp only [← Functor.map_comp, ← op_comp, pullback.condition]\n\n"}
{"name":"CategoryTheory.regularTopology.mapToEqualizer_eq_comp","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C\nP : CategoryTheory.Functor (Opposite C) (Type u_4)\nX B : C\nπ : Quiver.Hom X B\ninst✝ : CategoryTheory.Limits.HasPullback π π\n⊢ Eq (CategoryTheory.regularTopology.MapToEqualizer P π (CategoryTheory.Limits.pullback.fst π π) (CategoryTheory.Limits.pullback.snd π π) ⋯) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizer.lift (P.map π.op) ⋯) (CategoryTheory.Limits.Types.equalizerIso (P.map (CategoryTheory.Limits.pullback.fst π π).op) (P.map (CategoryTheory.Limits.pullback.snd π π).op)).hom)","decl":"lemma mapToEqualizer_eq_comp (P : Cᵒᵖ ⥤ Type*) {X B : C} (π : X ⟶ B) [HasPullback π π] :\n    MapToEqualizer P π (pullback.fst π π) (pullback.snd π π) pullback.condition =\n    equalizer.lift (P.map π.op) (equalizerCondition_w' P π) ≫\n    (Types.equalizerIso _ _).hom := by\n  rw [← Iso.comp_inv_eq (α := Types.equalizerIso _ _)]\n  apply equalizer.hom_ext\n  aesop\n\n"}
{"name":"CategoryTheory.regularTopology.equalizerCondition_iff_isIso_lift","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_5, u_1} C\nP : CategoryTheory.Functor (Opposite C) (Type u_4)\n⊢ Iff (CategoryTheory.regularTopology.EqualizerCondition P) (∀ (X B : C) (π : Quiver.Hom X B) [inst : CategoryTheory.EffectiveEpi π] [inst : CategoryTheory.Limits.HasPullback π π], CategoryTheory.IsIso (CategoryTheory.Limits.equalizer.lift (P.map π.op) ⋯))","decl":"/-- An alternative phrasing of the explicit equalizer condition, using more categorical language. -/\ntheorem equalizerCondition_iff_isIso_lift (P : Cᵒᵖ ⥤ Type*) : EqualizerCondition P ↔\n    ∀ (X B : C) (π : X ⟶ B) [EffectiveEpi π] [HasPullback π π],\n      IsIso (equalizer.lift (P.map π.op) (equalizerCondition_w' P π)) := by\n  constructor\n  · intro hP X B π _ _\n    have h := hP.bijective_mapToEqualizer_pullback _ X B π\n    rw [← isIso_iff_bijective, mapToEqualizer_eq_comp] at h\n    exact IsIso.of_isIso_comp_right (equalizer.lift (P.map π.op)\n      (equalizerCondition_w' P π))\n      (Types.equalizerIso _ _).hom\n  · intro hP\n    apply EqualizerCondition.mk\n    intro X B π _ _\n    rw [mapToEqualizer_eq_comp, ← isIso_iff_bijective]\n    infer_instance\n\n"}
{"name":"CategoryTheory.regularTopology.equalizerCondition_iff_of_equivalence","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} D\ninst✝ : CategoryTheory.Category.{u_6, u_3} E\nP : CategoryTheory.Functor (Opposite C) D\ne : CategoryTheory.Equivalence C E\n⊢ Iff (CategoryTheory.regularTopology.EqualizerCondition P) (CategoryTheory.regularTopology.EqualizerCondition (e.op.inverse.comp P))","decl":"/-- `P` satisfies the equalizer condition iff its precomposition by an equivalence does. -/\ntheorem equalizerCondition_iff_of_equivalence (P : Cᵒᵖ ⥤ D)\n    (e : C ≌ E) : EqualizerCondition P ↔ EqualizerCondition (e.op.inverse ⋙ P) :=\n  ⟨fun h ↦ equalizerCondition_precomp_of_preservesPullback P e.inverse h, fun h ↦\n    equalizerCondition_of_natIso (e.op.funInvIdAssoc P)\n      (equalizerCondition_precomp_of_preservesPullback (e.op.inverse ⋙ P) e.functor h)⟩\n\n"}
{"name":"CategoryTheory.regularTopology.parallelPair_pullback_initial","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_4, u_1} C\nX B : C\nπ : Quiver.Hom X B\nc : CategoryTheory.Limits.PullbackCone π π\nhc : CategoryTheory.Limits.IsLimit c\n⊢ (CategoryTheory.Limits.parallelPair (CategoryTheory.Over.homMk c.fst ⋯).op (CategoryTheory.Over.homMk c.snd ⋯).op).Initial","decl":"open WalkingParallelPair WalkingParallelPairHom in\ntheorem parallelPair_pullback_initial {X B : C} (π : X ⟶ B)\n    (c : PullbackCone π π) (hc : IsLimit c) :\n    (parallelPair (C := (Sieve.ofArrows (fun (_ : Unit) => X) (fun _ => π)).arrows.categoryᵒᵖ)\n    (Y := op ((Presieve.categoryMk _ (c.fst ≫ π) ⟨_, c.fst, π, ofArrows.mk (), rfl⟩)))\n    (X := op ((Presieve.categoryMk _ π (Sieve.ofArrows_mk _ _ Unit.unit))))\n    (Quiver.Hom.op (Over.homMk c.fst))\n    (Quiver.Hom.op (Over.homMk c.snd c.condition.symm))).Initial := by\n  apply Limits.parallelPair_initial_mk\n  · intro ⟨Z⟩\n    obtain ⟨_, f, g, ⟨⟩, hh⟩ := Z.property\n    let X' : (Presieve.ofArrows (fun () ↦ X) (fun () ↦ π)).category :=\n      Presieve.categoryMk _ π (ofArrows.mk ())\n    let f' : Z.obj.left ⟶ X'.obj.left := f\n    exact ⟨(Over.homMk f').op⟩\n  · intro ⟨Z⟩ ⟨i⟩ ⟨j⟩\n    let ij := PullbackCone.IsLimit.lift hc i.left j.left (by erw [i.w, j.w]; rfl)\n    refine ⟨Quiver.Hom.op (Over.homMk ij (by simpa [ij] using i.w)), ?_, ?_⟩\n    all_goals congr\n    all_goals exact Comma.hom_ext _ _ (by erw [Over.comp_left]; simp [ij]) rfl\n\n"}
{"name":"CategoryTheory.regularTopology.equalizerConditionMap_iff_nonempty_isLimit","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} D\nP : CategoryTheory.Functor (Opposite C) D\nX B : C\nπ : Quiver.Hom X B\ninst✝ : CategoryTheory.Limits.HasPullback π π\n⊢ Iff (CategoryTheory.regularTopology.SingleEqualizerCondition P π) (Nonempty (CategoryTheory.Limits.IsLimit (P.mapCone (CategoryTheory.Sieve.ofArrows (fun x => X) fun x => π).arrows.cocone.op)))","decl":"lemma equalizerConditionMap_iff_nonempty_isLimit (P : Cᵒᵖ ⥤ D) ⦃X B : C⦄ (π : X ⟶ B)\n    [HasPullback π π] : SingleEqualizerCondition P π ↔\n      Nonempty (IsLimit (P.mapCone\n        (Sieve.ofArrows (fun (_ : Unit) => X) (fun _ => π)).arrows.cocone.op)) := by\n  constructor\n  · intro h\n    exact ⟨isLimit_forkOfι_equiv _ _ _ (pullbackIsPullback π π) (h _ (pullbackIsPullback π π)).some⟩\n  · intro ⟨h⟩\n    exact fun c hc ↦ ⟨(isLimit_forkOfι_equiv _ _ _ hc).symm h⟩\n\n"}
{"name":"CategoryTheory.regularTopology.equalizerCondition_iff_isSheaf","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor (Opposite C) D\ninst✝¹ : CategoryTheory.Preregular C\ninst✝ : ∀ {Y X : C} (f : Quiver.Hom Y X) [inst : CategoryTheory.EffectiveEpi f], CategoryTheory.Limits.HasPullback f f\n⊢ Iff (CategoryTheory.regularTopology.EqualizerCondition F) (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.regularTopology C) F)","decl":"lemma equalizerCondition_iff_isSheaf (F : Cᵒᵖ ⥤ D) [Preregular C]\n    [∀ {Y X : C} (f : Y ⟶ X) [EffectiveEpi f], HasPullback f f] :\n    EqualizerCondition F ↔ Presheaf.IsSheaf (regularTopology C) F := by\n  dsimp [regularTopology]\n  rw [Presheaf.isSheaf_iff_isLimit_coverage]\n  constructor\n  · rintro hF X _ ⟨Y, f, rfl, _⟩\n    exact (equalizerConditionMap_iff_nonempty_isLimit F f).1 (hF f)\n  · intro hF Y X f _\n    exact (equalizerConditionMap_iff_nonempty_isLimit F f).2 (hF _ ⟨_, f, rfl, inferInstance⟩)\n\n"}
{"name":"CategoryTheory.regularTopology.isSheafFor_regular_of_projective","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_5, u_1} C\nX : C\nS : CategoryTheory.Presieve X\ninst✝¹ : S.regular\ninst✝ : CategoryTheory.Projective X\nF : CategoryTheory.Functor (Opposite C) (Type u_4)\n⊢ CategoryTheory.Presieve.IsSheafFor F S","decl":"lemma isSheafFor_regular_of_projective {X : C} (S : Presieve X) [S.regular] [Projective X]\n    (F : Cᵒᵖ ⥤ Type*) : S.IsSheafFor F := by\n  obtain ⟨Y, f, rfl, hf⟩ := Presieve.regular.single_epi (R := S)\n  rw [isSheafFor_arrows_iff]\n  refine fun x hx ↦ ⟨F.map (Projective.factorThru (𝟙 _) f).op <| x (), fun _ ↦ ?_, fun y h ↦ ?_⟩\n  · simpa using (hx () () Y (𝟙 Y) (f ≫ (Projective.factorThru (𝟙 _) f)) (by simp)).symm\n  · simp only [← h (), ← FunctorToTypes.map_comp_apply, ← op_comp, Projective.factorThru_comp,\n      op_id, FunctorToTypes.map_id_apply]\n\n"}
{"name":"CategoryTheory.regularTopology.isSheaf_of_projective","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor (Opposite C) D\ninst✝¹ : CategoryTheory.Preregular C\ninst✝ : ∀ (X : C), CategoryTheory.Projective X\n⊢ CategoryTheory.Presheaf.IsSheaf (CategoryTheory.regularTopology C) F","decl":"/-- Every presheaf is a sheaf for the regular topology if every object of `C` is projective. -/\ntheorem isSheaf_of_projective (F : Cᵒᵖ ⥤ D) [Preregular C] [∀ (X : C), Projective X] :\n    Presheaf.IsSheaf (regularTopology C) F :=\n  fun _ ↦ (isSheaf_coverage _ _).mpr fun S ⟨_, h⟩ ↦ have : S.regular := ⟨_, h⟩\n    isSheafFor_regular_of_projective _ _\n\n"}
{"name":"CategoryTheory.regularTopology.isSheaf_yoneda_obj","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Preregular C\nW : C\n⊢ CategoryTheory.Presieve.IsSheaf (CategoryTheory.regularTopology C) (CategoryTheory.yoneda.obj W)","decl":"/-- Every Yoneda-presheaf is a sheaf for the regular topology. -/\nlemma isSheaf_yoneda_obj [Preregular C] (W : C)  :\n    Presieve.IsSheaf (regularTopology C) (yoneda.obj W) := by\n  rw [regularTopology, isSheaf_coverage]\n  intro X S ⟨_, hS⟩\n  have : S.regular := ⟨_, hS⟩\n  obtain ⟨Y, f, rfl, hf⟩ := Presieve.regular.single_epi (R := S)\n  have h_colim := isColimitOfEffectiveEpiStruct f hf.effectiveEpi.some\n  rw [← Sieve.generateSingleton_eq, ← Presieve.ofArrows_pUnit] at h_colim\n  intro x hx\n  let x_ext := Presieve.FamilyOfElements.sieveExtend x\n  have hx_ext := Presieve.FamilyOfElements.Compatible.sieveExtend hx\n  let S := Sieve.generate (Presieve.ofArrows (fun () ↦ Y) (fun () ↦ f))\n  obtain ⟨t, t_amalg, t_uniq⟩ :=\n    (Sieve.forallYonedaIsSheaf_iff_colimit S).mpr ⟨h_colim⟩ W x_ext hx_ext\n  refine ⟨t, ?_, ?_⟩\n  · convert Presieve.isAmalgamation_restrict (Sieve.le_generate\n      (Presieve.ofArrows (fun () ↦ Y) (fun () ↦ f))) _ _ t_amalg\n    exact (Presieve.restrict_extend hx).symm\n  · exact fun y hy ↦ t_uniq y <| Presieve.isAmalgamation_sieveExtend x y hy\n\n"}
{"name":"CategoryTheory.regularTopology.subcanonical","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Preregular C\n⊢ (CategoryTheory.regularTopology C).Subcanonical","decl":"/-- The regular topology on any preregular category is subcanonical. -/\ninstance subcanonical [Preregular C] : (regularTopology C).Subcanonical :=\n  GrothendieckTopology.Subcanonical.of_isSheaf_yoneda_obj _ isSheaf_yoneda_obj\n\n"}
