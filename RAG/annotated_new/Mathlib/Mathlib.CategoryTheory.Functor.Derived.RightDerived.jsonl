{"name":"CategoryTheory.Functor.IsRightDerivedFunctor.isLeftKanExtension'","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Category.{u_6, u_3} H\nRF : CategoryTheory.Functor D H\nF : CategoryTheory.Functor C H\nL : CategoryTheory.Functor C D\nα : Quiver.Hom F (L.comp RF)\nW : CategoryTheory.MorphismProperty C\ninst✝ : L.IsLocalization W\nself : RF.IsRightDerivedFunctor α W\n⊢ RF.IsLeftKanExtension α","decl":"/-- A functor `RF : D ⥤ H` is a right derived functor of `F : C ⥤ H`\nif it is equipped with a natural transformation `α : F ⟶ L ⋙ RF`\nwhich makes it a left Kan extension of `F` along `L`,\nwhere `L : C ⥤ D` is a localization functor for `W : MorphismProperty C`. -/\nclass IsRightDerivedFunctor [L.IsLocalization W] : Prop where\n  isLeftKanExtension' : RF.IsLeftKanExtension α\n\n"}
{"name":"CategoryTheory.Functor.IsRightDerivedFunctor.isLeftKanExtension","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_5\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.Category.{u_6, u_5} H\nRF : CategoryTheory.Functor D H\nF : CategoryTheory.Functor C H\nL : CategoryTheory.Functor C D\nα : Quiver.Hom F (L.comp RF)\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : RF.IsRightDerivedFunctor α W\n⊢ RF.IsLeftKanExtension α","decl":"lemma IsRightDerivedFunctor.isLeftKanExtension\n    [L.IsLocalization W] [RF.IsRightDerivedFunctor α W] :\n    RF.IsLeftKanExtension α :=\n  IsRightDerivedFunctor.isLeftKanExtension' W\n\n"}
{"name":"CategoryTheory.Functor.isRightDerivedFunctor_iff_isLeftKanExtension","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_5\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹ : CategoryTheory.Category.{u_6, u_5} H\nRF : CategoryTheory.Functor D H\nF : CategoryTheory.Functor C H\nL : CategoryTheory.Functor C D\nα : Quiver.Hom F (L.comp RF)\nW : CategoryTheory.MorphismProperty C\ninst✝ : L.IsLocalization W\n⊢ Iff (RF.IsRightDerivedFunctor α W) (RF.IsLeftKanExtension α)","decl":"lemma isRightDerivedFunctor_iff_isLeftKanExtension [L.IsLocalization W] :\n    RF.IsRightDerivedFunctor α W ↔ RF.IsLeftKanExtension α := by\n  constructor\n  · exact fun _ => IsRightDerivedFunctor.isLeftKanExtension RF α W\n  · exact fun h => ⟨h⟩\n\n"}
{"name":"CategoryTheory.Functor.isRightDerivedFunctor_iff_of_iso","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_1\nD : Type u_6\nH : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_5, u_6} D\ninst✝¹ : CategoryTheory.Category.{u_2, u_3} H\nRF RF' : CategoryTheory.Functor D H\nF : CategoryTheory.Functor C H\nL : CategoryTheory.Functor C D\nα : Quiver.Hom F (L.comp RF)\nα' : Quiver.Hom F (L.comp RF')\nW : CategoryTheory.MorphismProperty C\ninst✝ : L.IsLocalization W\ne : CategoryTheory.Iso RF RF'\ncomm : Eq (CategoryTheory.CategoryStruct.comp α (CategoryTheory.whiskerLeft L e.hom)) α'\n⊢ Iff (RF.IsRightDerivedFunctor α W) (RF'.IsRightDerivedFunctor α' W)","decl":"variable {RF RF'} in\nlemma isRightDerivedFunctor_iff_of_iso (α' : F ⟶ L ⋙ RF') (W : MorphismProperty C)\n    [L.IsLocalization W] (e : RF ≅ RF') (comm : α ≫ whiskerLeft L e.hom = α') :\n    RF.IsRightDerivedFunctor α W ↔ RF'.IsRightDerivedFunctor α' W := by\n  simp only [isRightDerivedFunctor_iff_isLeftKanExtension]\n  exact isLeftKanExtension_iff_of_iso e _ _ comm\n\n"}
{"name":"CategoryTheory.Functor.rightDerived_fac","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_5\nD : Type u_3\nH : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_6, u_5} C\ninst✝³ : CategoryTheory.Category.{u_1, u_3} D\ninst✝² : CategoryTheory.Category.{u_2, u_4} H\nRF : CategoryTheory.Functor D H\nF : CategoryTheory.Functor C H\nL : CategoryTheory.Functor C D\nα : Quiver.Hom F (L.comp RF)\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : RF.IsRightDerivedFunctor α W\nG : CategoryTheory.Functor D H\nβ : Quiver.Hom F (L.comp G)\n⊢ Eq (CategoryTheory.CategoryStruct.comp α (CategoryTheory.whiskerLeft L (RF.rightDerivedDesc α W G β))) β","decl":"@[reassoc (attr := simp)]\nlemma rightDerived_fac (G : D ⥤ H) (β : F ⟶ L ⋙ G) :\n    α ≫ whiskerLeft L (RF.rightDerivedDesc α W G β) = β :=\n  have := IsRightDerivedFunctor.isLeftKanExtension RF α W\n  RF.descOfIsLeftKanExtension_fac α G β\n\n"}
{"name":"CategoryTheory.Functor.rightDerived_fac_assoc","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_5\nD : Type u_3\nH : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_6, u_5} C\ninst✝³ : CategoryTheory.Category.{u_1, u_3} D\ninst✝² : CategoryTheory.Category.{u_2, u_4} H\nRF : CategoryTheory.Functor D H\nF : CategoryTheory.Functor C H\nL : CategoryTheory.Functor C D\nα : Quiver.Hom F (L.comp RF)\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : RF.IsRightDerivedFunctor α W\nG : CategoryTheory.Functor D H\nβ : Quiver.Hom F (L.comp G)\nZ : CategoryTheory.Functor C H\nh : Quiver.Hom (L.comp G) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp α (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L (RF.rightDerivedDesc α W G β)) h)) (CategoryTheory.CategoryStruct.comp β h)","decl":"@[reassoc (attr := simp)]\nlemma rightDerived_fac (G : D ⥤ H) (β : F ⟶ L ⋙ G) :\n    α ≫ whiskerLeft L (RF.rightDerivedDesc α W G β) = β :=\n  have := IsRightDerivedFunctor.isLeftKanExtension RF α W\n  RF.descOfIsLeftKanExtension_fac α G β\n\n"}
{"name":"CategoryTheory.Functor.rightDerived_fac_app_assoc","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_5\nD : Type u_3\nH : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_6, u_5} C\ninst✝³ : CategoryTheory.Category.{u_1, u_3} D\ninst✝² : CategoryTheory.Category.{u_2, u_4} H\nRF : CategoryTheory.Functor D H\nF : CategoryTheory.Functor C H\nL : CategoryTheory.Functor C D\nα : Quiver.Hom F (L.comp RF)\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : RF.IsRightDerivedFunctor α W\nG : CategoryTheory.Functor D H\nβ : Quiver.Hom F (L.comp G)\nX : C\nZ : H\nh : Quiver.Hom (G.obj (L.obj X)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (α.app X) (CategoryTheory.CategoryStruct.comp ((RF.rightDerivedDesc α W G β).app (L.obj X)) h)) (CategoryTheory.CategoryStruct.comp (β.app X) h)","decl":"@[reassoc (attr := simp)]\nlemma rightDerived_fac_app (G : D ⥤ H) (β : F ⟶ L ⋙ G) (X : C) :\n    α.app X ≫ (RF.rightDerivedDesc α W G β).app (L.obj X) = β.app X :=\n  have := IsRightDerivedFunctor.isLeftKanExtension RF α W\n  RF.descOfIsLeftKanExtension_fac_app α G β X\n\n"}
{"name":"CategoryTheory.Functor.rightDerived_fac_app","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_5\nD : Type u_3\nH : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_6, u_5} C\ninst✝³ : CategoryTheory.Category.{u_1, u_3} D\ninst✝² : CategoryTheory.Category.{u_2, u_4} H\nRF : CategoryTheory.Functor D H\nF : CategoryTheory.Functor C H\nL : CategoryTheory.Functor C D\nα : Quiver.Hom F (L.comp RF)\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : RF.IsRightDerivedFunctor α W\nG : CategoryTheory.Functor D H\nβ : Quiver.Hom F (L.comp G)\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (α.app X) ((RF.rightDerivedDesc α W G β).app (L.obj X))) (β.app X)","decl":"@[reassoc (attr := simp)]\nlemma rightDerived_fac_app (G : D ⥤ H) (β : F ⟶ L ⋙ G) (X : C) :\n    α.app X ≫ (RF.rightDerivedDesc α W G β).app (L.obj X) = β.app X :=\n  have := IsRightDerivedFunctor.isLeftKanExtension RF α W\n  RF.descOfIsLeftKanExtension_fac_app α G β X\n\n"}
{"name":"CategoryTheory.Functor.rightDerived_ext","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_5\nD : Type u_3\nH : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_6, u_5} C\ninst✝³ : CategoryTheory.Category.{u_1, u_3} D\ninst✝² : CategoryTheory.Category.{u_2, u_4} H\nRF : CategoryTheory.Functor D H\nF : CategoryTheory.Functor C H\nL : CategoryTheory.Functor C D\nα : Quiver.Hom F (L.comp RF)\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : RF.IsRightDerivedFunctor α W\nG : CategoryTheory.Functor D H\nγ₁ γ₂ : Quiver.Hom RF G\nhγ : Eq (CategoryTheory.CategoryStruct.comp α (CategoryTheory.whiskerLeft L γ₁)) (CategoryTheory.CategoryStruct.comp α (CategoryTheory.whiskerLeft L γ₂))\n⊢ Eq γ₁ γ₂","decl":"include W in\nlemma rightDerived_ext (G : D ⥤ H) (γ₁ γ₂ : RF ⟶ G)\n    (hγ : α ≫ whiskerLeft L γ₁ = α ≫ whiskerLeft L γ₂) : γ₁ = γ₂ :=\n  have := IsRightDerivedFunctor.isLeftKanExtension RF α W\n  RF.hom_ext_of_isLeftKanExtension α γ₁ γ₂ hγ\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedNatTrans_fac_assoc","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_1\nD : Type u_6\nH : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_6} D\ninst✝² : CategoryTheory.Category.{u_2, u_3} H\nRF RF' : CategoryTheory.Functor D H\nF F' : CategoryTheory.Functor C H\nL : CategoryTheory.Functor C D\nα : Quiver.Hom F (L.comp RF)\nα' : Quiver.Hom F' (L.comp RF')\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : RF.IsRightDerivedFunctor α W\nτ : Quiver.Hom F F'\nZ : CategoryTheory.Functor C H\nh : Quiver.Hom (L.comp RF') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp α (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L (RF.rightDerivedNatTrans RF' α α' W τ)) h)) (CategoryTheory.CategoryStruct.comp τ (CategoryTheory.CategoryStruct.comp α' h))","decl":"@[reassoc (attr := simp)]\nlemma rightDerivedNatTrans_fac (τ : F ⟶ F') :\n    α ≫ whiskerLeft L (rightDerivedNatTrans RF RF' α α' W τ) = τ ≫ α' := by\n  dsimp only [rightDerivedNatTrans]\n  simp\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedNatTrans_fac","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_1\nD : Type u_6\nH : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_6} D\ninst✝² : CategoryTheory.Category.{u_2, u_3} H\nRF RF' : CategoryTheory.Functor D H\nF F' : CategoryTheory.Functor C H\nL : CategoryTheory.Functor C D\nα : Quiver.Hom F (L.comp RF)\nα' : Quiver.Hom F' (L.comp RF')\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : RF.IsRightDerivedFunctor α W\nτ : Quiver.Hom F F'\n⊢ Eq (CategoryTheory.CategoryStruct.comp α (CategoryTheory.whiskerLeft L (RF.rightDerivedNatTrans RF' α α' W τ))) (CategoryTheory.CategoryStruct.comp τ α')","decl":"@[reassoc (attr := simp)]\nlemma rightDerivedNatTrans_fac (τ : F ⟶ F') :\n    α ≫ whiskerLeft L (rightDerivedNatTrans RF RF' α α' W τ) = τ ≫ α' := by\n  dsimp only [rightDerivedNatTrans]\n  simp\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedNatTrans_app","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_1\nD : Type u_6\nH : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_6} D\ninst✝² : CategoryTheory.Category.{u_2, u_3} H\nRF RF' : CategoryTheory.Functor D H\nF F' : CategoryTheory.Functor C H\nL : CategoryTheory.Functor C D\nα : Quiver.Hom F (L.comp RF)\nα' : Quiver.Hom F' (L.comp RF')\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : RF.IsRightDerivedFunctor α W\nτ : Quiver.Hom F F'\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (α.app X) ((RF.rightDerivedNatTrans RF' α α' W τ).app (L.obj X))) (CategoryTheory.CategoryStruct.comp (τ.app X) (α'.app X))","decl":"@[reassoc (attr := simp)]\nlemma rightDerivedNatTrans_app (τ : F ⟶ F') (X : C) :\n    α.app X ≫ (rightDerivedNatTrans RF RF' α α' W τ).app (L.obj X) =\n    τ.app X ≫ α'.app X := by\n  dsimp only [rightDerivedNatTrans]\n  simp\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedNatTrans_app_assoc","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_1\nD : Type u_6\nH : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_6} D\ninst✝² : CategoryTheory.Category.{u_2, u_3} H\nRF RF' : CategoryTheory.Functor D H\nF F' : CategoryTheory.Functor C H\nL : CategoryTheory.Functor C D\nα : Quiver.Hom F (L.comp RF)\nα' : Quiver.Hom F' (L.comp RF')\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : RF.IsRightDerivedFunctor α W\nτ : Quiver.Hom F F'\nX : C\nZ : H\nh : Quiver.Hom (RF'.obj (L.obj X)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (α.app X) (CategoryTheory.CategoryStruct.comp ((RF.rightDerivedNatTrans RF' α α' W τ).app (L.obj X)) h)) (CategoryTheory.CategoryStruct.comp (τ.app X) (CategoryTheory.CategoryStruct.comp (α'.app X) h))","decl":"@[reassoc (attr := simp)]\nlemma rightDerivedNatTrans_app (τ : F ⟶ F') (X : C) :\n    α.app X ≫ (rightDerivedNatTrans RF RF' α α' W τ).app (L.obj X) =\n    τ.app X ≫ α'.app X := by\n  dsimp only [rightDerivedNatTrans]\n  simp\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedNatTrans_id","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_5\nD : Type u_1\nH : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_6, u_5} C\ninst✝³ : CategoryTheory.Category.{u_4, u_1} D\ninst✝² : CategoryTheory.Category.{u_2, u_3} H\nRF : CategoryTheory.Functor D H\nF : CategoryTheory.Functor C H\nL : CategoryTheory.Functor C D\nα : Quiver.Hom F (L.comp RF)\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : RF.IsRightDerivedFunctor α W\n⊢ Eq (RF.rightDerivedNatTrans RF α α W (CategoryTheory.CategoryStruct.id F)) (CategoryTheory.CategoryStruct.id RF)","decl":"@[simp]\nlemma rightDerivedNatTrans_id :\n    rightDerivedNatTrans RF RF α α W (𝟙 F) = 𝟙 RF :=\n  rightDerived_ext RF α W _ _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedNatTrans_comp","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_1\nD : Type u_5\nH : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_6, u_5} D\ninst✝³ : CategoryTheory.Category.{u_2, u_3} H\nRF RF' RF'' : CategoryTheory.Functor D H\nF F' F'' : CategoryTheory.Functor C H\nL : CategoryTheory.Functor C D\nα : Quiver.Hom F (L.comp RF)\nα' : Quiver.Hom F' (L.comp RF')\nα'' : Quiver.Hom F'' (L.comp RF'')\nW : CategoryTheory.MorphismProperty C\ninst✝² : L.IsLocalization W\ninst✝¹ : RF.IsRightDerivedFunctor α W\ninst✝ : RF'.IsRightDerivedFunctor α' W\nτ : Quiver.Hom F F'\nτ' : Quiver.Hom F' F''\n⊢ Eq (CategoryTheory.CategoryStruct.comp (RF.rightDerivedNatTrans RF' α α' W τ) (RF'.rightDerivedNatTrans RF'' α' α'' W τ')) (RF.rightDerivedNatTrans RF'' α α'' W (CategoryTheory.CategoryStruct.comp τ τ'))","decl":"@[reassoc (attr := simp)]\nlemma rightDerivedNatTrans_comp (τ : F ⟶ F') (τ' : F' ⟶ F'') :\n    rightDerivedNatTrans RF RF' α α' W τ ≫ rightDerivedNatTrans RF' RF'' α' α'' W τ' =\n    rightDerivedNatTrans RF RF'' α α'' W (τ ≫ τ') :=\n  rightDerived_ext RF α W _ _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedNatTrans_comp_assoc","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_1\nD : Type u_5\nH : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_6, u_5} D\ninst✝³ : CategoryTheory.Category.{u_2, u_3} H\nRF RF' RF'' : CategoryTheory.Functor D H\nF F' F'' : CategoryTheory.Functor C H\nL : CategoryTheory.Functor C D\nα : Quiver.Hom F (L.comp RF)\nα' : Quiver.Hom F' (L.comp RF')\nα'' : Quiver.Hom F'' (L.comp RF'')\nW : CategoryTheory.MorphismProperty C\ninst✝² : L.IsLocalization W\ninst✝¹ : RF.IsRightDerivedFunctor α W\ninst✝ : RF'.IsRightDerivedFunctor α' W\nτ : Quiver.Hom F F'\nτ' : Quiver.Hom F' F''\nZ : CategoryTheory.Functor D H\nh : Quiver.Hom RF'' Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (RF.rightDerivedNatTrans RF' α α' W τ) (CategoryTheory.CategoryStruct.comp (RF'.rightDerivedNatTrans RF'' α' α'' W τ') h)) (CategoryTheory.CategoryStruct.comp (RF.rightDerivedNatTrans RF'' α α'' W (CategoryTheory.CategoryStruct.comp τ τ')) h)","decl":"@[reassoc (attr := simp)]\nlemma rightDerivedNatTrans_comp (τ : F ⟶ F') (τ' : F' ⟶ F'') :\n    rightDerivedNatTrans RF RF' α α' W τ ≫ rightDerivedNatTrans RF' RF'' α' α'' W τ' =\n    rightDerivedNatTrans RF RF'' α α'' W (τ ≫ τ') :=\n  rightDerived_ext RF α W _ _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedNatIso_hom","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} D\ninst✝³ : CategoryTheory.Category.{u_6, u_3} H\nRF RF' : CategoryTheory.Functor D H\nF F' : CategoryTheory.Functor C H\nL : CategoryTheory.Functor C D\nα : Quiver.Hom F (L.comp RF)\nα' : Quiver.Hom F' (L.comp RF')\nW : CategoryTheory.MorphismProperty C\ninst✝² : L.IsLocalization W\ninst✝¹ : RF.IsRightDerivedFunctor α W\ninst✝ : RF'.IsRightDerivedFunctor α' W\nτ : CategoryTheory.Iso F F'\n⊢ Eq (RF.rightDerivedNatIso RF' α α' W τ).hom (RF.rightDerivedNatTrans RF' α α' W τ.hom)","decl":"/-- The natural isomorphism `RF ≅ RF'` on right derived functors that is\ninduced by a natural isomorphism `F ≅ F'`. -/\n@[simps]\nnoncomputable def rightDerivedNatIso (τ : F ≅ F') :\n    RF ≅ RF' where\n  hom := rightDerivedNatTrans RF RF' α α' W τ.hom\n  inv := rightDerivedNatTrans RF' RF α' α W τ.inv\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedNatIso_inv","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} D\ninst✝³ : CategoryTheory.Category.{u_6, u_3} H\nRF RF' : CategoryTheory.Functor D H\nF F' : CategoryTheory.Functor C H\nL : CategoryTheory.Functor C D\nα : Quiver.Hom F (L.comp RF)\nα' : Quiver.Hom F' (L.comp RF')\nW : CategoryTheory.MorphismProperty C\ninst✝² : L.IsLocalization W\ninst✝¹ : RF.IsRightDerivedFunctor α W\ninst✝ : RF'.IsRightDerivedFunctor α' W\nτ : CategoryTheory.Iso F F'\n⊢ Eq (RF.rightDerivedNatIso RF' α α' W τ).inv (RF'.rightDerivedNatTrans RF α' α W τ.inv)","decl":"/-- The natural isomorphism `RF ≅ RF'` on right derived functors that is\ninduced by a natural isomorphism `F ≅ F'`. -/\n@[simps]\nnoncomputable def rightDerivedNatIso (τ : F ≅ F') :\n    RF ≅ RF' where\n  hom := rightDerivedNatTrans RF RF' α α' W τ.hom\n  inv := rightDerivedNatTrans RF' RF α' α W τ.inv\n\n"}
{"name":"CategoryTheory.Functor.isRightDerivedFunctor_iff_isIso_rightDerivedDesc","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_5\nD : Type u_3\nH : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_6, u_5} C\ninst✝³ : CategoryTheory.Category.{u_1, u_3} D\ninst✝² : CategoryTheory.Category.{u_2, u_4} H\nRF : CategoryTheory.Functor D H\nF : CategoryTheory.Functor C H\nL : CategoryTheory.Functor C D\nα : Quiver.Hom F (L.comp RF)\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : RF.IsRightDerivedFunctor α W\nG : CategoryTheory.Functor D H\nβ : Quiver.Hom F (L.comp G)\n⊢ Iff (G.IsRightDerivedFunctor β W) (CategoryTheory.IsIso (RF.rightDerivedDesc α W G β))","decl":"lemma isRightDerivedFunctor_iff_isIso_rightDerivedDesc (G : D ⥤ H) (β : F ⟶ L ⋙ G) :\n    G.IsRightDerivedFunctor β W ↔ IsIso (RF.rightDerivedDesc α W G β) := by\n  rw [isRightDerivedFunctor_iff_isLeftKanExtension]\n  have := IsRightDerivedFunctor.isLeftKanExtension _ α W\n  exact isLeftKanExtension_iff_isIso _ α _ (by simp)\n\n"}
{"name":"CategoryTheory.Functor.HasRightDerivedFunctor.hasLeftKanExtension'","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_1\nH : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Category.{u_4, u_2} H\nF : CategoryTheory.Functor C H\nW : CategoryTheory.MorphismProperty C\nself : F.HasRightDerivedFunctor W\n⊢ W.Q.HasLeftKanExtension F","decl":"/-- A functor `F : C ⥤ H` has a right derived functor with respect to\n`W : MorphismProperty C` if it has a left Kan extension along\n`W.Q : C ⥤ W.Localization` (or any localization functor `L : C ⥤ D`\nfor `W`, see `hasRightDerivedFunctor_iff`). -/\nclass HasRightDerivedFunctor : Prop where\n  hasLeftKanExtension' : HasLeftKanExtension W.Q F\n\n"}
{"name":"CategoryTheory.Functor.hasRightDerivedFunctor_iff","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_1\nD : Type u_5\nH : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_5} D\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} H\nF : CategoryTheory.Functor C H\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝ : L.IsLocalization W\n⊢ Iff (F.HasRightDerivedFunctor W) (L.HasLeftKanExtension F)","decl":"lemma hasRightDerivedFunctor_iff :\n    F.HasRightDerivedFunctor W ↔ HasLeftKanExtension L F := by\n  have : HasRightDerivedFunctor F W ↔ HasLeftKanExtension W.Q F :=\n    ⟨fun h => h.hasLeftKanExtension', fun h => ⟨h⟩⟩\n  rw [this, hasLeftExtension_iff_postcomp₁ (Localization.compUniqFunctor W.Q L W) F]\n\n"}
{"name":"CategoryTheory.Functor.hasRightDerivedFunctor_iff_of_iso","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_1\nH : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Category.{u_4, u_2} H\nF F' : CategoryTheory.Functor C H\ne : CategoryTheory.Iso F F'\nW : CategoryTheory.MorphismProperty C\n⊢ Iff (F.HasRightDerivedFunctor W) (F'.HasRightDerivedFunctor W)","decl":"include e in\nlemma hasRightDerivedFunctor_iff_of_iso :\n    HasRightDerivedFunctor F W ↔ HasRightDerivedFunctor F' W := by\n  rw [hasRightDerivedFunctor_iff F W.Q W, hasRightDerivedFunctor_iff F' W.Q W,\n    hasLeftExtension_iff_of_iso₂ W.Q e]\n\n"}
{"name":"CategoryTheory.Functor.HasRightDerivedFunctor.hasLeftKanExtension","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_1\nD : Type u_5\nH : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_6, u_5} D\ninst✝² : CategoryTheory.Category.{u_4, u_2} H\nF : CategoryTheory.Functor C H\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : F.HasRightDerivedFunctor W\n⊢ L.HasLeftKanExtension F","decl":"lemma HasRightDerivedFunctor.hasLeftKanExtension [HasRightDerivedFunctor F W] :\n    HasLeftKanExtension L F := by\n  simpa only [← hasRightDerivedFunctor_iff F L W]\n\n"}
{"name":"CategoryTheory.Functor.HasRightDerivedFunctor.mk'","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\ninst✝² : CategoryTheory.Category.{u_6, u_3} H\nRF : CategoryTheory.Functor D H\nF : CategoryTheory.Functor C H\nL : CategoryTheory.Functor C D\nα : Quiver.Hom F (L.comp RF)\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : RF.IsRightDerivedFunctor α W\n⊢ F.HasRightDerivedFunctor W","decl":"lemma HasRightDerivedFunctor.mk' [RF.IsRightDerivedFunctor α W] :\n    HasRightDerivedFunctor F W := by\n  have := IsRightDerivedFunctor.isLeftKanExtension RF α W\n  simpa only [hasRightDerivedFunctor_iff F L W] using HasLeftKanExtension.mk RF α\n\n"}
{"name":"CategoryTheory.Functor.instIsRightDerivedFunctorTotalRightDerivedTotalRightDerivedUnit","module":"Mathlib.CategoryTheory.Functor.Derived.RightDerived","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\ninst✝² : CategoryTheory.Category.{u_6, u_3} H\nF : CategoryTheory.Functor C H\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : F.HasRightDerivedFunctor W\n⊢ (CategoryTheory.Functor.totalRightDerived L W).IsRightDerivedFunctor (CategoryTheory.Functor.totalRightDerivedUnit L W) W","decl":"instance : (F.totalRightDerived L W).IsRightDerivedFunctor\n    (F.totalRightDerivedUnit L W) W where\n  isLeftKanExtension' := by\n    dsimp [totalRightDerived, totalRightDerivedUnit]\n    infer_instance\n\n"}
