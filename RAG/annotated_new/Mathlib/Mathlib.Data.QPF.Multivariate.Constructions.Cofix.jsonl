{"name":"MvQPF.corecF_eq","module":"Mathlib.Data.QPF.Multivariate.Constructions.Cofix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nβ : Type u\ng : β → F (α.append1 β)\nx : β\n⊢ Eq (MvPFunctor.M.dest (MvQPF.P F) (MvQPF.corecF g x)) (MvFunctor.map (TypeVec.appendFun TypeVec.id (MvQPF.corecF g)) (MvQPF.repr (g x)))","decl":"theorem corecF_eq {α : TypeVec n} {β : Type u} (g : β → F (α.append1 β)) (x : β) :\n    M.dest q.P (corecF g x) = appendFun id (corecF g) <$$> repr (g x) := by\n  rw [corecF, M.dest_corec]\n\n"}
{"name":"MvQPF.Cofix.dest_corec","module":"Mathlib.Data.QPF.Multivariate.Constructions.Cofix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nβ : Type u\ng : β → F (α.append1 β)\nx : β\n⊢ Eq (MvQPF.Cofix.corec g x).dest (MvFunctor.map (TypeVec.appendFun TypeVec.id (MvQPF.Cofix.corec g)) (g x))","decl":"theorem Cofix.dest_corec {α : TypeVec n} {β : Type u} (g : β → F (α.append1 β)) (x : β) :\n    Cofix.dest (Cofix.corec g x) = appendFun id (Cofix.corec g) <$$> g x := by\n  conv =>\n    lhs\n    rw [Cofix.dest, Cofix.corec]\n  dsimp\n  rw [corecF_eq, abs_map, abs_repr, ← comp_map, ← appendFun_comp]; rfl\n\n"}
{"name":"MvQPF.Cofix.bisim_rel","module":"Mathlib.Data.QPF.Multivariate.Constructions.Cofix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nr : MvQPF.Cofix F α → MvQPF.Cofix F α → Prop\nh : ∀ (x y : MvQPF.Cofix F α), r x y → Eq (MvFunctor.map (TypeVec.appendFun TypeVec.id (Quot.mk r)) x.dest) (MvFunctor.map (TypeVec.appendFun TypeVec.id (Quot.mk r)) y.dest)\nx y : MvQPF.Cofix F α\na✝ : r x y\n⊢ Eq x y","decl":"/-- Bisimulation principle using `map` and `Quot.mk` to match and relate children of two trees. -/\ntheorem Cofix.bisim_rel {α : TypeVec n} (r : Cofix F α → Cofix F α → Prop)\n    (h : ∀ x y, r x y →\n      appendFun id (Quot.mk r) <$$> Cofix.dest x = appendFun id (Quot.mk r) <$$> Cofix.dest y) :\n    ∀ x y, r x y → x = y := by\n  let r' (x y) := x = y ∨ r x y\n  intro x y rxy\n  apply Cofix.bisim_aux r'\n  · intro x\n    left\n    rfl\n  · intro x y r'xy\n    cases r'xy with\n    | inl h =>\n      rw [h]\n    | inr r'xy =>\n      have : ∀ x y, r x y → r' x y := fun x y h => Or.inr h\n      rw [← Quot.factor_mk_eq _ _ this]\n      dsimp [r']\n      rw [appendFun_comp_id]\n      rw [@comp_map _ _ q _ _ _ (appendFun id (Quot.mk r)),\n        @comp_map _ _ q _ _ _ (appendFun id (Quot.mk r))]\n      rw [h _ _ r'xy]\n  right; exact rxy\n\n"}
{"name":"MvQPF.Cofix.bisim","module":"Mathlib.Data.QPF.Multivariate.Constructions.Cofix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nr : MvQPF.Cofix F α → MvQPF.Cofix F α → Prop\nh : ∀ (x y : MvQPF.Cofix F α), r x y → MvFunctor.LiftR (fun {i} => α.RelLast r) x.dest y.dest\nx y : MvQPF.Cofix F α\na✝ : r x y\n⊢ Eq x y","decl":"/-- Bisimulation principle using `LiftR` to match and relate children of two trees. -/\ntheorem Cofix.bisim {α : TypeVec n} (r : Cofix F α → Cofix F α → Prop)\n    (h : ∀ x y, r x y → LiftR (RelLast α r (i := _)) (Cofix.dest x) (Cofix.dest y)) :\n    ∀ x y, r x y → x = y := by\n  apply Cofix.bisim_rel\n  intro x y rxy\n  rcases (liftR_iff (fun a b => RelLast α r a b) (dest x) (dest y)).mp (h x y rxy)\n    with ⟨a, f₀, f₁, dxeq, dyeq, h'⟩\n  rw [dxeq, dyeq, ← abs_map, ← abs_map, MvPFunctor.map_eq, MvPFunctor.map_eq]\n  rw [← split_dropFun_lastFun f₀, ← split_dropFun_lastFun f₁]\n  rw [appendFun_comp_splitFun, appendFun_comp_splitFun]\n  rw [id_comp, id_comp]\n  congr 2 with (i j); cases' i with _ i\n  · apply Quot.sound\n    apply h' _ j\n  · change f₀ _ j = f₁ _ j\n    apply h' _ j\n\n"}
{"name":"MvQPF.Cofix.bisim₂","module":"Mathlib.Data.QPF.Multivariate.Constructions.Cofix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nr : MvQPF.Cofix F α → MvQPF.Cofix F α → Prop\nh : ∀ (x y : MvQPF.Cofix F α), r x y → MvFunctor.LiftR' (α.RelLast' r) x.dest y.dest\nx y : MvQPF.Cofix F α\na✝ : r x y\n⊢ Eq x y","decl":"/-- Bisimulation principle using `LiftR'` to match and relate children of two trees. -/\ntheorem Cofix.bisim₂ {α : TypeVec n} (r : Cofix F α → Cofix F α → Prop)\n    (h : ∀ x y, r x y → LiftR' (RelLast' α r) (Cofix.dest x) (Cofix.dest y)) :\n    ∀ x y, r x y → x = y :=\n  Cofix.bisim r <| by intros; rw [← LiftR_RelLast_iff]; apply h; assumption\n\n"}
{"name":"MvQPF.Cofix.bisim'","module":"Mathlib.Data.QPF.Multivariate.Constructions.Cofix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nβ : Type u_1\nQ : β → Prop\nu v : β → MvQPF.Cofix F α\nh : ∀ (x : β), Q x → Exists fun a => Exists fun f' => Exists fun f₀ => Exists fun f₁ => And (Eq (u x).dest (MvQPF.abs ⟨a, (MvQPF.P F).appendContents f' f₀⟩)) (And (Eq (v x).dest (MvQPF.abs ⟨a, (MvQPF.P F).appendContents f' f₁⟩)) (∀ (i : (MvQPF.P F).last.B a), Exists fun x' => And (Q x') (And (Eq (f₀ i) (u x')) (Eq (f₁ i) (v x')))))\nx : β\na✝ : Q x\n⊢ Eq (u x) (v x)","decl":"/-- Bisimulation principle the values `⟨a,f⟩` of the polynomial functor representing\n`Cofix F α` as well as an invariant `Q : β → Prop` and a state `β` generating the\nleft-hand side and right-hand side of the equality through functions `u v : β → Cofix F α` -/\ntheorem Cofix.bisim' {α : TypeVec n} {β : Type*} (Q : β → Prop) (u v : β → Cofix F α)\n    (h : ∀ x, Q x → ∃ a f' f₀ f₁,\n      Cofix.dest (u x) = q.abs ⟨a, q.P.appendContents f' f₀⟩ ∧\n        Cofix.dest (v x) = q.abs ⟨a, q.P.appendContents f' f₁⟩ ∧\n          ∀ i, ∃ x', Q x' ∧ f₀ i = u x' ∧ f₁ i = v x') :\n    ∀ x, Q x → u x = v x := fun x Qx =>\n  let R := fun w z : Cofix F α => ∃ x', Q x' ∧ w = u x' ∧ z = v x'\n  Cofix.bisim R\n    (fun x y ⟨x', Qx', xeq, yeq⟩ => by\n      rcases h x' Qx' with ⟨a, f', f₀, f₁, ux'eq, vx'eq, h'⟩\n      rw [liftR_iff]\n      refine\n        ⟨a, q.P.appendContents f' f₀, q.P.appendContents f' f₁, xeq.symm ▸ ux'eq,\n          yeq.symm ▸ vx'eq, ?_⟩\n      intro i; cases i\n      · apply h'\n      · intro j\n        apply Eq.refl)\n    _ _ ⟨x, Qx, rfl, rfl⟩\n\n"}
{"name":"MvQPF.Cofix.mk_dest","module":"Mathlib.Data.QPF.Multivariate.Constructions.Cofix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nx : MvQPF.Cofix F α\n⊢ Eq (MvQPF.Cofix.mk x.dest) x","decl":"theorem Cofix.mk_dest {α : TypeVec n} (x : Cofix F α) : Cofix.mk (Cofix.dest x) = x := by\n  apply Cofix.bisim_rel (fun x y : Cofix F α => x = Cofix.mk (Cofix.dest y)) _ _ _ rfl\n  dsimp\n  intro x y h\n  rw [h]\n  conv =>\n    lhs\n    congr\n    rfl\n    rw [Cofix.mk]\n    rw [Cofix.dest_corec]\n  rw [← comp_map, ← appendFun_comp, id_comp]\n  rw [← comp_map, ← appendFun_comp, id_comp, ← Cofix.mk]\n  congr\n  apply congrArg\n  funext x\n  apply Quot.sound\n  rfl\n\n"}
{"name":"MvQPF.Cofix.dest_mk","module":"Mathlib.Data.QPF.Multivariate.Constructions.Cofix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nx : F (α.append1 (MvQPF.Cofix F α))\n⊢ Eq (MvQPF.Cofix.mk x).dest x","decl":"theorem Cofix.dest_mk {α : TypeVec n} (x : F (α.append1 <| Cofix F α)) :\n    Cofix.dest (Cofix.mk x) = x := by\n  have : Cofix.mk ∘ Cofix.dest = @_root_.id (Cofix F α) := funext Cofix.mk_dest\n  rw [Cofix.mk, Cofix.dest_corec, ← comp_map, ← Cofix.mk, ← appendFun_comp, this, id_comp,\n    appendFun_id_id, MvFunctor.id_map]\n\n"}
{"name":"MvQPF.Cofix.ext","module":"Mathlib.Data.QPF.Multivariate.Constructions.Cofix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nx y : MvQPF.Cofix F α\nh : Eq x.dest y.dest\n⊢ Eq x y","decl":"theorem Cofix.ext {α : TypeVec n} (x y : Cofix F α) (h : x.dest = y.dest) : x = y := by\n  rw [← Cofix.mk_dest x, h, Cofix.mk_dest]\n\n"}
{"name":"MvQPF.Cofix.ext_mk","module":"Mathlib.Data.QPF.Multivariate.Constructions.Cofix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nx y : F (α.append1 (MvQPF.Cofix F α))\nh : Eq (MvQPF.Cofix.mk x) (MvQPF.Cofix.mk y)\n⊢ Eq x y","decl":"theorem Cofix.ext_mk {α : TypeVec n} (x y : F (α ::: Cofix F α)) (h : Cofix.mk x = Cofix.mk y) :\n    x = y := by rw [← Cofix.dest_mk x, h, Cofix.dest_mk]\n\n"}
{"name":"MvQPF.liftR_map","module":"Mathlib.Data.QPF.Multivariate.Constructions.Cofix","initialProofState":"n : Nat\nα β : TypeVec.{u_1} n\nF' : TypeVec.{u_1} n → Type u\ninst✝¹ : MvFunctor F'\ninst✝ : LawfulMvFunctor F'\nR : (β.prod β).Arrow (TypeVec.repeat n Prop)\nx : F' α\nf g : α.Arrow β\nh : α.Arrow (TypeVec.Subtype_ R)\nhh : Eq (TypeVec.comp (TypeVec.subtypeVal R) h) (TypeVec.comp (TypeVec.prod.map f g) TypeVec.prod.diag)\n⊢ MvFunctor.LiftR' R (MvFunctor.map f x) (MvFunctor.map g x)","decl":"theorem liftR_map {α β : TypeVec n} {F' : TypeVec n → Type u} [MvFunctor F'] [LawfulMvFunctor F']\n    (R : β ⊗ β ⟹ «repeat» n Prop) (x : F' α) (f g : α ⟹ β) (h : α ⟹ Subtype_ R)\n    (hh : subtypeVal _ ⊚ h = (f ⊗' g) ⊚ prod.diag) : LiftR' R (f <$$> x) (g <$$> x) := by\n  rw [LiftR_def]\n  exists h <$$> x\n  rw [MvFunctor.map_map, comp_assoc, hh, ← comp_assoc, fst_prod_mk, comp_assoc, fst_diag]\n  rw [MvFunctor.map_map, comp_assoc, hh, ← comp_assoc, snd_prod_mk, comp_assoc, snd_diag]\n  dsimp [LiftR']; constructor <;> rfl\n\n"}
{"name":"MvQPF.liftR_map_last","module":"Mathlib.Data.QPF.Multivariate.Constructions.Cofix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nlawful : LawfulMvFunctor F\nα : TypeVec.{u} n\nι ι' : Type u\nR : ι' → ι' → Prop\nx : F (α.append1 ι)\nf g : ι → ι'\nhh : ∀ (x : ι), R (f x) (g x)\n⊢ MvFunctor.LiftR' (α.RelLast' R) (MvFunctor.map (TypeVec.appendFun TypeVec.id f) x) (MvFunctor.map (TypeVec.appendFun TypeVec.id g) x)","decl":"theorem liftR_map_last [lawful : LawfulMvFunctor F]\n    {α : TypeVec n} {ι ι'} (R : ι' → ι' → Prop)\n    (x : F (α ::: ι)) (f g : ι → ι') (hh : ∀ x : ι, R (f x) (g x)) :\n    LiftR' (RelLast' _ R) ((id ::: f) <$$> x) ((id ::: g) <$$> x) :=\n  let h : ι → { x : ι' × ι' // uncurry R x } := fun x => ⟨(f x, g x), hh x⟩\n  let b : (α ::: ι) ⟹ _ := @diagSub n α ::: h\n  let c :\n    (Subtype_ α.repeatEq ::: { x // uncurry R x }) ⟹\n      ((fun i : Fin2 n => { x // ofRepeat (α.RelLast' R i.fs x) }) ::: Subtype (uncurry R)) :=\n    ofSubtype _ ::: id\n  have hh :\n    subtypeVal _ ⊚ toSubtype _ ⊚ fromAppend1DropLast ⊚ c ⊚ b =\n      ((id ::: f) ⊗' (id ::: g)) ⊚ prod.diag := by\n    dsimp [b]\n    apply eq_of_drop_last_eq\n    · dsimp\n      simp only [prod_map_id, dropFun_prod, dropFun_appendFun, dropFun_diag, TypeVec.id_comp,\n        dropFun_toSubtype]\n      erw [toSubtype_of_subtype_assoc, TypeVec.id_comp]\n      clear liftR_map_last q lawful F x R f g hh h b c\n      ext (i x) : 2\n      induction i with\n      | fz => rfl\n      | fs _ ih =>\n        apply ih\n    simp only [lastFun_from_append1_drop_last, lastFun_toSubtype, lastFun_appendFun,\n      lastFun_subtypeVal, Function.id_comp, lastFun_comp, lastFun_prod]\n    ext1\n    rfl\n  liftR_map _ _ _ _ (toSubtype _ ⊚ fromAppend1DropLast ⊚ c ⊚ b) hh\n\n"}
{"name":"MvQPF.liftR_map_last'","module":"Mathlib.Data.QPF.Multivariate.Constructions.Cofix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\ninst✝ : LawfulMvFunctor F\nα : TypeVec.{u} n\nι : Type u\nR : ι → ι → Prop\nx : F (α.append1 ι)\nf : ι → ι\nhh : ∀ (x : ι), R (f x) x\n⊢ MvFunctor.LiftR' (α.RelLast' R) (MvFunctor.map (TypeVec.appendFun TypeVec.id f) x) x","decl":"theorem liftR_map_last' [LawfulMvFunctor F] {α : TypeVec n} {ι} (R : ι → ι → Prop) (x : F (α ::: ι))\n    (f : ι → ι) (hh : ∀ x : ι, R (f x) x) : LiftR' (RelLast' _ R) ((id ::: f) <$$> x) x := by\n  have := liftR_map_last R x f id hh\n  rwa [appendFun_id_id, MvFunctor.id_map] at this\n\n"}
{"name":"MvQPF.Cofix.abs_repr","module":"Mathlib.Data.QPF.Multivariate.Constructions.Cofix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nx : MvQPF.Cofix F α\n⊢ Eq (Quot.mk MvQPF.Mcongr x.repr) x","decl":"theorem Cofix.abs_repr {α} (x : Cofix F α) : Quot.mk _ (Cofix.repr x) = x := by\n  let R := fun x y : Cofix F α => abs (repr y) = x\n  refine Cofix.bisim₂ R ?_ _ _ rfl\n  clear x\n  rintro x y h\n  subst h\n  dsimp [Cofix.dest, Cofix.abs]\n  induction y using Quot.ind\n  simp only [Cofix.repr, M.dest_corec, abs_map, MvQPF.abs_repr, Function.comp]\n  conv => congr; rfl; rw [Cofix.dest]\n  rw [MvFunctor.map_map, MvFunctor.map_map, ← appendFun_comp_id, ← appendFun_comp_id]\n  apply liftR_map_last\n  intros\n  rfl\n\n"}
{"name":"MvQPF.corec_roll","module":"Mathlib.Data.QPF.Multivariate.Constructions.Cofix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nX Y : Type u\nx₀ : X\nf : X → Y\ng : Y → F (α.append1 X)\n⊢ Eq (MvQPF.Cofix.corec (Function.comp g f) x₀) (MvQPF.Cofix.corec (Function.comp (MvFunctor.map (TypeVec.appendFun TypeVec.id f)) g) (f x₀))","decl":"theorem corec_roll {α : TypeVec n} {X Y} {x₀ : X} (f : X → Y) (g : Y → F (α ::: X)) :\n    Cofix.corec (g ∘ f) x₀ = Cofix.corec (MvFunctor.map (id ::: f) ∘ g) (f x₀) := by\n  mv_bisim x₀ with R a b x Ha Hb\n  rw [Ha, Hb, Cofix.dest_corec, Cofix.dest_corec, Function.comp_apply, Function.comp_apply]\n  rw [MvFunctor.map_map, ← appendFun_comp_id]\n  refine liftR_map_last _ _ _ _ ?_\n  intro a; refine ⟨a, rfl, rfl⟩\n\n"}
{"name":"MvQPF.Cofix.dest_corec'","module":"Mathlib.Data.QPF.Multivariate.Constructions.Cofix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nβ : Type u\ng : β → F (α.append1 (Sum (MvQPF.Cofix F α) β))\nx : β\n⊢ Eq (MvQPF.Cofix.corec' g x).dest (MvFunctor.map (TypeVec.appendFun TypeVec.id (Sum.elim id (MvQPF.Cofix.corec' g))) (g x))","decl":"theorem Cofix.dest_corec' {α : TypeVec.{u} n} {β : Type u}\n    (g : β → F (α.append1 (Cofix F α ⊕ β))) (x : β) :\n    Cofix.dest (Cofix.corec' g x) =\n      appendFun id (Sum.elim _root_.id (Cofix.corec' g)) <$$> g x := by\n  rw [Cofix.corec', Cofix.dest_corec]; dsimp\n  congr!; ext (i | i) <;> erw [corec_roll] <;> dsimp [Cofix.corec']\n  · mv_bisim i with R a b x Ha Hb\n    rw [Ha, Hb, Cofix.dest_corec]\n    dsimp [Function.comp_def]\n    repeat rw [MvFunctor.map_map, ← appendFun_comp_id]\n    apply liftR_map_last'\n    dsimp [Function.comp_def]\n    intros\n    exact ⟨_, rfl, rfl⟩\n  · congr with y\n    erw [appendFun_id_id]\n    simp [MvFunctor.id_map, Sum.elim]\n\n"}
{"name":"MvQPF.Cofix.dest_corec₁","module":"Mathlib.Data.QPF.Multivariate.Constructions.Cofix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nβ : Type u\ng : {X : Type u} → (MvQPF.Cofix F α → X) → (β → X) → β → F (α.append1 X)\nx : β\nh : ∀ (X Y : Type u) (f : MvQPF.Cofix F α → X) (f' : β → X) (k : X → Y), Eq (g (Function.comp k f) (Function.comp k f') x) (MvFunctor.map (TypeVec.appendFun TypeVec.id k) (g f f' x))\n⊢ Eq (MvQPF.Cofix.corec₁ g x).dest (g id (MvQPF.Cofix.corec₁ g) x)","decl":"theorem Cofix.dest_corec₁ {α : TypeVec n} {β : Type u}\n    (g : ∀ {X}, (Cofix F α → X) → (β → X) → β → F (α.append1 X)) (x : β)\n    (h : ∀ (X Y) (f : Cofix F α → X) (f' : β → X) (k : X → Y),\n      g (k ∘ f) (k ∘ f') x = (id ::: k) <$$> g f f' x) :\n    Cofix.dest (Cofix.corec₁ (@g) x) = g id (Cofix.corec₁ @g) x := by\n  rw [Cofix.corec₁, Cofix.dest_corec', ← h]; rfl\n\n"}
