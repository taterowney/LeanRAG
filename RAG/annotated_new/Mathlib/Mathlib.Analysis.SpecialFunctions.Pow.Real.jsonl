{"name":"Real.rpow_eq_pow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\n⊢ Eq (x.rpow y) (HPow.hPow x y)","decl":"@[simp]\ntheorem rpow_eq_pow (x y : ℝ) : rpow x y = x ^ y := rfl\n\n"}
{"name":"Real.rpow_def","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\n⊢ Eq (HPow.hPow x y) (HPow.hPow ↑x ↑y).re","decl":"theorem rpow_def (x y : ℝ) : x ^ y = ((x : ℂ) ^ (y : ℂ)).re := rfl\n\n"}
{"name":"Real.rpow_def_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LE.le 0 x\ny : Real\n⊢ Eq (HPow.hPow x y) (ite (Eq x 0) (ite (Eq y 0) 1 0) (Real.exp (HMul.hMul (Real.log x) y)))","decl":"theorem rpow_def_of_nonneg {x : ℝ} (hx : 0 ≤ x) (y : ℝ) :\n    x ^ y = if x = 0 then if y = 0 then 1 else 0 else exp (log x * y) := by\n  simp only [rpow_def, Complex.cpow_def]; split_ifs <;>\n  simp_all [(Complex.ofReal_log hx).symm, -Complex.ofReal_mul,\n      (Complex.ofReal_mul _ _).symm, Complex.exp_ofReal_re, Complex.ofReal_eq_zero]\n\n"}
{"name":"Real.rpow_def_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LT.lt 0 x\ny : Real\n⊢ Eq (HPow.hPow x y) (Real.exp (HMul.hMul (Real.log x) y))","decl":"theorem rpow_def_of_pos {x : ℝ} (hx : 0 < x) (y : ℝ) : x ^ y = exp (log x * y) := by\n  rw [rpow_def_of_nonneg (le_of_lt hx), if_neg (ne_of_gt hx)]\n\n"}
{"name":"Real.exp_mul","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\n⊢ Eq (Real.exp (HMul.hMul x y)) (HPow.hPow (Real.exp x) y)","decl":"theorem exp_mul (x y : ℝ) : exp (x * y) = exp x ^ y := by rw [rpow_def_of_pos (exp_pos _), log_exp]\n\n"}
{"name":"Real.rpow_intCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nn : Int\n⊢ Eq (HPow.hPow x ↑n) (HPow.hPow x n)","decl":"@[simp, norm_cast]\ntheorem rpow_intCast (x : ℝ) (n : ℤ) : x ^ (n : ℝ) = x ^ n := by\n  simp only [rpow_def, ← Complex.ofReal_zpow, Complex.cpow_intCast, Complex.ofReal_intCast,\n    Complex.ofReal_re]\n\n"}
{"name":"Real.rpow_natCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nn : Nat\n⊢ Eq (HPow.hPow x ↑n) (HPow.hPow x n)","decl":"@[simp, norm_cast]\ntheorem rpow_natCast (x : ℝ) (n : ℕ) : x ^ (n : ℝ) = x ^ n := by simpa using rpow_intCast x n\n\n"}
{"name":"Real.exp_one_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\n⊢ Eq (HPow.hPow (Real.exp 1) x) (Real.exp x)","decl":"@[simp]\ntheorem exp_one_rpow (x : ℝ) : exp 1 ^ x = exp x := by rw [← exp_mul, one_mul]\n\n"}
{"name":"Real.exp_one_pow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"n : Nat\n⊢ Eq (HPow.hPow (Real.exp 1) n) (Real.exp ↑n)","decl":"@[simp] lemma exp_one_pow (n : ℕ) : exp 1 ^ n = exp n := by rw [← rpow_natCast, exp_one_rpow]\n\n"}
{"name":"Real.rpow_eq_zero_iff_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nhx : LE.le 0 x\n⊢ Iff (Eq (HPow.hPow x y) 0) (And (Eq x 0) (Ne y 0))","decl":"theorem rpow_eq_zero_iff_of_nonneg (hx : 0 ≤ x) : x ^ y = 0 ↔ x = 0 ∧ y ≠ 0 := by\n  simp only [rpow_def_of_nonneg hx]\n  split_ifs <;> simp [*, exp_ne_zero]\n\n"}
{"name":"Real.rpow_eq_zero","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nhx : LE.le 0 x\nhy : Ne y 0\n⊢ Iff (Eq (HPow.hPow x y) 0) (Eq x 0)","decl":"@[simp]\nlemma rpow_eq_zero (hx : 0 ≤ x) (hy : y ≠ 0) : x ^ y = 0 ↔ x = 0 := by\n  simp [rpow_eq_zero_iff_of_nonneg, *]\n\n"}
{"name":"Real.rpow_ne_zero","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nhx : LE.le 0 x\nhy : Ne y 0\n⊢ Iff (Ne (HPow.hPow x y) 0) (Ne x 0)","decl":"@[simp]\nlemma rpow_ne_zero (hx : 0 ≤ x) (hy : y ≠ 0) : x ^ y ≠ 0 ↔ x ≠ 0 :=\n  Real.rpow_eq_zero hx hy |>.not\n\n"}
{"name":"Real.rpow_def_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LT.lt x 0\ny : Real\n⊢ Eq (HPow.hPow x y) (HMul.hMul (Real.exp (HMul.hMul (Real.log x) y)) (Real.cos (HMul.hMul y Real.pi)))","decl":"theorem rpow_def_of_neg {x : ℝ} (hx : x < 0) (y : ℝ) : x ^ y = exp (log x * y) * cos (y * π) := by\n  rw [rpow_def, Complex.cpow_def, if_neg]\n  · have : Complex.log x * y = ↑(log (-x) * y) + ↑(y * π) * Complex.I := by\n      simp only [Complex.log, abs_of_neg hx, Complex.arg_ofReal_of_neg hx, Complex.abs_ofReal,\n        Complex.ofReal_mul]\n      ring\n    rw [this, Complex.exp_add_mul_I, ← Complex.ofReal_exp, ← Complex.ofReal_cos, ←\n      Complex.ofReal_sin, mul_add, ← Complex.ofReal_mul, ← mul_assoc, ← Complex.ofReal_mul,\n      Complex.add_re, Complex.ofReal_re, Complex.mul_re, Complex.I_re, Complex.ofReal_im,\n      Real.log_neg_eq_log]\n    ring\n  · rw [Complex.ofReal_eq_zero]\n    exact ne_of_lt hx\n\n"}
{"name":"Real.rpow_def_of_nonpos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LE.le x 0\ny : Real\n⊢ Eq (HPow.hPow x y) (ite (Eq x 0) (ite (Eq y 0) 1 0) (HMul.hMul (Real.exp (HMul.hMul (Real.log x) y)) (Real.cos (HMul.hMul y Real.pi))))","decl":"theorem rpow_def_of_nonpos {x : ℝ} (hx : x ≤ 0) (y : ℝ) :\n    x ^ y = if x = 0 then if y = 0 then 1 else 0 else exp (log x * y) * cos (y * π) := by\n  split_ifs with h <;> simp [rpow_def, *]; exact rpow_def_of_neg (lt_of_le_of_ne hx h) _\n\n"}
{"name":"Real.rpow_pos_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LT.lt 0 x\ny : Real\n⊢ LT.lt 0 (HPow.hPow x y)","decl":"@[bound]\ntheorem rpow_pos_of_pos {x : ℝ} (hx : 0 < x) (y : ℝ) : 0 < x ^ y := by\n  rw [rpow_def_of_pos hx]; apply exp_pos\n\n"}
{"name":"Real.rpow_zero","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\n⊢ Eq (HPow.hPow x 0) 1","decl":"@[simp]\ntheorem rpow_zero (x : ℝ) : x ^ (0 : ℝ) = 1 := by simp [rpow_def]\n\n"}
{"name":"Real.rpow_zero_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\n⊢ LT.lt 0 (HPow.hPow x 0)","decl":"theorem rpow_zero_pos (x : ℝ) : 0 < x ^ (0 : ℝ) := by simp\n\n"}
{"name":"Real.zero_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nh : Ne x 0\n⊢ Eq (HPow.hPow 0 x) 0","decl":"@[simp]\ntheorem zero_rpow {x : ℝ} (h : x ≠ 0) : (0 : ℝ) ^ x = 0 := by simp [rpow_def, *]\n\n"}
{"name":"Real.zero_rpow_eq_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x a : Real\n⊢ Iff (Eq (HPow.hPow 0 x) a) (Or (And (Ne x 0) (Eq a 0)) (And (Eq x 0) (Eq a 1)))","decl":"theorem zero_rpow_eq_iff {x : ℝ} {a : ℝ} : 0 ^ x = a ↔ x ≠ 0 ∧ a = 0 ∨ x = 0 ∧ a = 1 := by\n  constructor\n  · intro hyp\n    simp only [rpow_def, Complex.ofReal_zero] at hyp\n    by_cases h : x = 0\n    · subst h\n      simp only [Complex.one_re, Complex.ofReal_zero, Complex.cpow_zero] at hyp\n      exact Or.inr ⟨rfl, hyp.symm⟩\n    · rw [Complex.zero_cpow (Complex.ofReal_ne_zero.mpr h)] at hyp\n      exact Or.inl ⟨h, hyp.symm⟩\n  · rintro (⟨h, rfl⟩ | ⟨rfl, rfl⟩)\n    · exact zero_rpow h\n    · exact rpow_zero _\n\n"}
{"name":"Real.eq_zero_rpow_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x a : Real\n⊢ Iff (Eq a (HPow.hPow 0 x)) (Or (And (Ne x 0) (Eq a 0)) (And (Eq x 0) (Eq a 1)))","decl":"theorem eq_zero_rpow_iff {x : ℝ} {a : ℝ} : a = 0 ^ x ↔ x ≠ 0 ∧ a = 0 ∨ x = 0 ∧ a = 1 := by\n  rw [← zero_rpow_eq_iff, eq_comm]\n\n"}
{"name":"Real.rpow_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\n⊢ Eq (HPow.hPow x 1) x","decl":"@[simp]\ntheorem rpow_one (x : ℝ) : x ^ (1 : ℝ) = x := by simp [rpow_def]\n\n"}
{"name":"Real.one_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\n⊢ Eq (HPow.hPow 1 x) 1","decl":"@[simp]\ntheorem one_rpow (x : ℝ) : (1 : ℝ) ^ x = 1 := by simp [rpow_def]\n\n"}
{"name":"Real.zero_rpow_le_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\n⊢ LE.le (HPow.hPow 0 x) 1","decl":"theorem zero_rpow_le_one (x : ℝ) : (0 : ℝ) ^ x ≤ 1 := by\n  by_cases h : x = 0 <;> simp [h, zero_le_one]\n\n"}
{"name":"Real.zero_rpow_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\n⊢ LE.le 0 (HPow.hPow 0 x)","decl":"theorem zero_rpow_nonneg (x : ℝ) : 0 ≤ (0 : ℝ) ^ x := by\n  by_cases h : x = 0 <;> simp [h, zero_le_one]\n\n"}
{"name":"Real.rpow_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LE.le 0 x\ny : Real\n⊢ LE.le 0 (HPow.hPow x y)","decl":"@[bound]\ntheorem rpow_nonneg {x : ℝ} (hx : 0 ≤ x) (y : ℝ) : 0 ≤ x ^ y := by\n  rw [rpow_def_of_nonneg hx]; split_ifs <;>\n    simp only [zero_le_one, le_refl, le_of_lt (exp_pos _)]\n\n"}
{"name":"Real.abs_rpow_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nhx_nonneg : LE.le 0 x\n⊢ Eq (abs (HPow.hPow x y)) (HPow.hPow (abs x) y)","decl":"theorem abs_rpow_of_nonneg {x y : ℝ} (hx_nonneg : 0 ≤ x) : |x ^ y| = |x| ^ y := by\n  have h_rpow_nonneg : 0 ≤ x ^ y := Real.rpow_nonneg hx_nonneg _\n  rw [abs_eq_self.mpr hx_nonneg, abs_eq_self.mpr h_rpow_nonneg]\n\n"}
{"name":"Real.abs_rpow_le_abs_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\n⊢ LE.le (abs (HPow.hPow x y)) (HPow.hPow (abs x) y)","decl":"@[bound]\ntheorem abs_rpow_le_abs_rpow (x y : ℝ) : |x ^ y| ≤ |x| ^ y := by\n  rcases le_or_lt 0 x with hx | hx\n  · rw [abs_rpow_of_nonneg hx]\n  · rw [abs_of_neg hx, rpow_def_of_neg hx, rpow_def_of_pos (neg_pos.2 hx), log_neg_eq_log, abs_mul,\n      abs_of_pos (exp_pos _)]\n    exact mul_le_of_le_one_right (exp_pos _).le (abs_cos_le_one _)\n\n"}
{"name":"Real.abs_rpow_le_exp_log_mul","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\n⊢ LE.le (abs (HPow.hPow x y)) (Real.exp (HMul.hMul (Real.log x) y))","decl":"theorem abs_rpow_le_exp_log_mul (x y : ℝ) : |x ^ y| ≤ exp (log x * y) := by\n  refine (abs_rpow_le_abs_rpow x y).trans ?_\n  by_cases hx : x = 0\n  · by_cases hy : y = 0 <;> simp [hx, hy, zero_le_one]\n  · rw [rpow_def_of_pos (abs_pos.2 hx), log_abs]\n\n"}
{"name":"Real.rpow_inv_log","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx₀ : LT.lt 0 x\nhx₁ : Ne x 1\n⊢ Eq (HPow.hPow x (Inv.inv (Real.log x))) (Real.exp 1)","decl":"lemma rpow_inv_log (hx₀ : 0 < x) (hx₁ : x ≠ 1) : x ^ (log x)⁻¹ = exp 1 := by\n  rw [rpow_def_of_pos hx₀, mul_inv_cancel₀]\n  exact log_ne_zero.2 ⟨hx₀.ne', hx₁, (hx₀.trans' <| by norm_num).ne'⟩\n\n"}
{"name":"Real.rpow_inv_log_le_exp_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\n⊢ LE.le (HPow.hPow x (Inv.inv (Real.log x))) (Real.exp 1)","decl":"/-- See `Real.rpow_inv_log` for the equality when `x ≠ 1` is strictly positive. -/\nlemma rpow_inv_log_le_exp_one : x ^ (log x)⁻¹ ≤ exp 1 := by\n  calc\n    _ ≤ |x ^ (log x)⁻¹| := le_abs_self _\n    _ ≤ |x| ^ (log x)⁻¹ := abs_rpow_le_abs_rpow ..\n  rw [← log_abs]\n  obtain hx | hx := (abs_nonneg x).eq_or_gt\n  · simp [hx]\n  · rw [rpow_def_of_pos hx]\n    gcongr\n    exact mul_inv_le_one\n\n"}
{"name":"Real.norm_rpow_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nhx_nonneg : LE.le 0 x\n⊢ Eq (Norm.norm (HPow.hPow x y)) (HPow.hPow (Norm.norm x) y)","decl":"theorem norm_rpow_of_nonneg {x y : ℝ} (hx_nonneg : 0 ≤ x) : ‖x ^ y‖ = ‖x‖ ^ y := by\n  simp_rw [Real.norm_eq_abs]\n  exact abs_rpow_of_nonneg hx_nonneg\n\n"}
{"name":"Real.rpow_add","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LT.lt 0 x\ny z : Real\n⊢ Eq (HPow.hPow x (HAdd.hAdd y z)) (HMul.hMul (HPow.hPow x y) (HPow.hPow x z))","decl":"theorem rpow_add (hx : 0 < x) (y z : ℝ) : x ^ (y + z) = x ^ y * x ^ z := by\n  simp only [rpow_def_of_pos hx, mul_add, exp_add]\n\n"}
{"name":"Real.rpow_add'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LE.le 0 x\nh : Ne (HAdd.hAdd y z) 0\n⊢ Eq (HPow.hPow x (HAdd.hAdd y z)) (HMul.hMul (HPow.hPow x y) (HPow.hPow x z))","decl":"theorem rpow_add' (hx : 0 ≤ x) (h : y + z ≠ 0) : x ^ (y + z) = x ^ y * x ^ z := by\n  rcases hx.eq_or_lt with (rfl | pos)\n  · rw [zero_rpow h, zero_eq_mul]\n    have : y ≠ 0 ∨ z ≠ 0 := not_and_or.1 fun ⟨hy, hz⟩ => h <| hy.symm ▸ hz.symm ▸ zero_add 0\n    exact this.imp zero_rpow zero_rpow\n  · exact rpow_add pos _ _\n\n"}
{"name":"Real.rpow_of_add_eq","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"w x y z : Real\nhx : LE.le 0 x\nhw : Ne w 0\nh : Eq (HAdd.hAdd y z) w\n⊢ Eq (HPow.hPow x w) (HMul.hMul (HPow.hPow x y) (HPow.hPow x z))","decl":"/-- Variant of `Real.rpow_add'` that avoids having to prove `y + z = w` twice. -/\nlemma rpow_of_add_eq (hx : 0 ≤ x) (hw : w ≠ 0) (h : y + z = w) : x ^ w = x ^ y * x ^ z := by\n  rw [← h, rpow_add' hx]; rwa [h]\n\n"}
{"name":"Real.rpow_add_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LE.le 0 x\nhy : LE.le 0 y\nhz : LE.le 0 z\n⊢ Eq (HPow.hPow x (HAdd.hAdd y z)) (HMul.hMul (HPow.hPow x y) (HPow.hPow x z))","decl":"theorem rpow_add_of_nonneg (hx : 0 ≤ x) (hy : 0 ≤ y) (hz : 0 ≤ z) :\n    x ^ (y + z) = x ^ y * x ^ z := by\n  rcases hy.eq_or_lt with (rfl | hy)\n  · rw [zero_add, rpow_zero, one_mul]\n  exact rpow_add' hx (ne_of_gt <| add_pos_of_pos_of_nonneg hy hz)\n\n"}
{"name":"Real.le_rpow_add","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LE.le 0 x\ny z : Real\n⊢ LE.le (HMul.hMul (HPow.hPow x y) (HPow.hPow x z)) (HPow.hPow x (HAdd.hAdd y z))","decl":"/-- For `0 ≤ x`, the only problematic case in the equality `x ^ y * x ^ z = x ^ (y + z)` is for\n`x = 0` and `y + z = 0`, where the right hand side is `1` while the left hand side can vanish.\nThe inequality is always true, though, and given in this lemma. -/\ntheorem le_rpow_add {x : ℝ} (hx : 0 ≤ x) (y z : ℝ) : x ^ y * x ^ z ≤ x ^ (y + z) := by\n  rcases le_iff_eq_or_lt.1 hx with (H | pos)\n  · by_cases h : y + z = 0\n    · simp only [H.symm, h, rpow_zero]\n      calc\n        (0 : ℝ) ^ y * 0 ^ z ≤ 1 * 1 :=\n          mul_le_mul (zero_rpow_le_one y) (zero_rpow_le_one z) (zero_rpow_nonneg z) zero_le_one\n        _ = 1 := by simp\n\n    · simp [rpow_add', ← H, h]\n  · simp [rpow_add pos]\n\n"}
{"name":"Real.rpow_sum_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"ι : Type u_1\na : Real\nha : LT.lt 0 a\nf : ι → Real\ns : Finset ι\n⊢ Eq (HPow.hPow a (s.sum fun x => f x)) (s.prod fun x => HPow.hPow a (f x))","decl":"theorem rpow_sum_of_pos {ι : Type*} {a : ℝ} (ha : 0 < a) (f : ι → ℝ) (s : Finset ι) :\n    (a ^ ∑ x ∈ s, f x) = ∏ x ∈ s, a ^ f x :=\n  map_sum (⟨⟨fun (x : ℝ) => (a ^ x : ℝ), rpow_zero a⟩, rpow_add ha⟩ : ℝ →+ (Additive ℝ)) f s\n\n"}
{"name":"Real.rpow_sum_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"ι : Type u_1\na : Real\nha : LE.le 0 a\ns : Finset ι\nf : ι → Real\nh : ∀ (x : ι), Membership.mem s x → LE.le 0 (f x)\n⊢ Eq (HPow.hPow a (s.sum fun x => f x)) (s.prod fun x => HPow.hPow a (f x))","decl":"theorem rpow_sum_of_nonneg {ι : Type*} {a : ℝ} (ha : 0 ≤ a) {s : Finset ι} {f : ι → ℝ}\n    (h : ∀ x ∈ s, 0 ≤ f x) : (a ^ ∑ x ∈ s, f x) = ∏ x ∈ s, a ^ f x := by\n  induction' s using Finset.cons_induction with i s hi ihs\n  · rw [sum_empty, Finset.prod_empty, rpow_zero]\n  · rw [forall_mem_cons] at h\n    rw [sum_cons, prod_cons, ← ihs h.2, rpow_add_of_nonneg ha h.1 (sum_nonneg h.2)]\n\n"}
{"name":"Real.rpow_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LE.le 0 x\ny : Real\n⊢ Eq (HPow.hPow x (Neg.neg y)) (Inv.inv (HPow.hPow x y))","decl":"theorem rpow_neg {x : ℝ} (hx : 0 ≤ x) (y : ℝ) : x ^ (-y) = (x ^ y)⁻¹ := by\n  simp only [rpow_def_of_nonneg hx]; split_ifs <;> simp_all [exp_neg]\n\n"}
{"name":"Real.rpow_sub","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LT.lt 0 x\ny z : Real\n⊢ Eq (HPow.hPow x (HSub.hSub y z)) (HDiv.hDiv (HPow.hPow x y) (HPow.hPow x z))","decl":"theorem rpow_sub {x : ℝ} (hx : 0 < x) (y z : ℝ) : x ^ (y - z) = x ^ y / x ^ z := by\n  simp only [sub_eq_add_neg, rpow_add hx, rpow_neg (le_of_lt hx), div_eq_mul_inv]\n\n"}
{"name":"Real.rpow_sub'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LE.le 0 x\ny z : Real\nh : Ne (HSub.hSub y z) 0\n⊢ Eq (HPow.hPow x (HSub.hSub y z)) (HDiv.hDiv (HPow.hPow x y) (HPow.hPow x z))","decl":"theorem rpow_sub' {x : ℝ} (hx : 0 ≤ x) {y z : ℝ} (h : y - z ≠ 0) : x ^ (y - z) = x ^ y / x ^ z := by\n  simp only [sub_eq_add_neg] at h ⊢\n  simp only [rpow_add' hx h, rpow_neg hx, div_eq_mul_inv]\n\n"}
{"name":"HasCompactSupport.rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nf : α → Real\nhf : HasCompactSupport f\nr : Real\nhr : Ne r 0\n⊢ HasCompactSupport fun x => HPow.hPow (f x) r","decl":"protected theorem _root_.HasCompactSupport.rpow_const {α : Type*} [TopologicalSpace α] {f : α → ℝ}\n    (hf : HasCompactSupport f) {r : ℝ} (hr : r ≠ 0) : HasCompactSupport (fun x ↦ f x ^ r) :=\n  hf.comp_left (g := (· ^ r)) (Real.zero_rpow hr)\n\n"}
{"name":"Complex.ofReal_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LE.le 0 x\ny : Real\n⊢ Eq (↑(HPow.hPow x y)) (HPow.hPow ↑x ↑y)","decl":"theorem ofReal_cpow {x : ℝ} (hx : 0 ≤ x) (y : ℝ) : ((x ^ y : ℝ) : ℂ) = (x : ℂ) ^ (y : ℂ) := by\n  simp only [Real.rpow_def_of_nonneg hx, Complex.cpow_def, ofReal_eq_zero]; split_ifs <;>\n    simp [Complex.ofReal_log hx]\n\n"}
{"name":"Complex.ofReal_cpow_of_nonpos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LE.le x 0\ny : Complex\n⊢ Eq (HPow.hPow (↑x) y) (HMul.hMul (HPow.hPow (Neg.neg ↑x) y) (Complex.exp (HMul.hMul (HMul.hMul (↑Real.pi) Complex.I) y)))","decl":"theorem ofReal_cpow_of_nonpos {x : ℝ} (hx : x ≤ 0) (y : ℂ) :\n    (x : ℂ) ^ y = (-x : ℂ) ^ y * exp (π * I * y) := by\n  rcases hx.eq_or_lt with (rfl | hlt)\n  · rcases eq_or_ne y 0 with (rfl | hy) <;> simp [*]\n  have hne : (x : ℂ) ≠ 0 := ofReal_ne_zero.mpr hlt.ne\n  rw [cpow_def_of_ne_zero hne, cpow_def_of_ne_zero (neg_ne_zero.2 hne), ← exp_add, ← add_mul, log,\n    log, abs.map_neg, arg_ofReal_of_neg hlt, ← ofReal_neg,\n    arg_ofReal_of_nonneg (neg_nonneg.2 hx), ofReal_zero, zero_mul, add_zero]\n\n"}
{"name":"Complex.cpow_ofReal","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Complex\ny : Real\n⊢ Eq (HPow.hPow x ↑y) (HMul.hMul (↑(HPow.hPow (Complex.abs x) y)) (HAdd.hAdd (↑(Real.cos (HMul.hMul x.arg y))) (HMul.hMul (↑(Real.sin (HMul.hMul x.arg y))) Complex.I)))","decl":"lemma cpow_ofReal (x : ℂ) (y : ℝ) :\n    x ^ (y : ℂ) = ↑(abs x ^ y) * (Real.cos (arg x * y) + Real.sin (arg x * y) * I) := by\n  rcases eq_or_ne x 0 with rfl | hx\n  · simp [ofReal_cpow le_rfl]\n  · rw [cpow_def_of_ne_zero hx, exp_eq_exp_re_mul_sin_add_cos, mul_comm (log x)]\n    norm_cast\n    rw [re_ofReal_mul, im_ofReal_mul, log_re, log_im, mul_comm y, mul_comm y, Real.exp_mul,\n      Real.exp_log]\n    rwa [abs.pos_iff]\n\n"}
{"name":"Complex.cpow_ofReal_re","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Complex\ny : Real\n⊢ Eq (HPow.hPow x ↑y).re (HMul.hMul (HPow.hPow (Complex.abs x) y) (Real.cos (HMul.hMul x.arg y)))","decl":"lemma cpow_ofReal_re (x : ℂ) (y : ℝ) : (x ^ (y : ℂ)).re = (abs x) ^ y * Real.cos (arg x * y) := by\n  rw [cpow_ofReal]; generalize arg x * y = z; simp [Real.cos]\n\n"}
{"name":"Complex.cpow_ofReal_im","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Complex\ny : Real\n⊢ Eq (HPow.hPow x ↑y).im (HMul.hMul (HPow.hPow (Complex.abs x) y) (Real.sin (HMul.hMul x.arg y)))","decl":"lemma cpow_ofReal_im (x : ℂ) (y : ℝ) : (x ^ (y : ℂ)).im = (abs x) ^ y * Real.sin (arg x * y) := by\n  rw [cpow_ofReal]; generalize arg x * y = z; simp [Real.sin]\n\n"}
{"name":"Complex.abs_cpow_of_ne_zero","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"z : Complex\nhz : Ne z 0\nw : Complex\n⊢ Eq (Complex.abs (HPow.hPow z w)) (HDiv.hDiv (HPow.hPow (Complex.abs z) w.re) (Real.exp (HMul.hMul z.arg w.im)))","decl":"theorem abs_cpow_of_ne_zero {z : ℂ} (hz : z ≠ 0) (w : ℂ) :\n    abs (z ^ w) = abs z ^ w.re / Real.exp (arg z * im w) := by\n  rw [cpow_def_of_ne_zero hz, abs_exp, mul_re, log_re, log_im, Real.exp_sub,\n    Real.rpow_def_of_pos (abs.pos hz)]\n\n"}
{"name":"Complex.abs_cpow_of_imp","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"z w : Complex\nh : Eq z 0 → Eq w.re 0 → Eq w 0\n⊢ Eq (Complex.abs (HPow.hPow z w)) (HDiv.hDiv (HPow.hPow (Complex.abs z) w.re) (Real.exp (HMul.hMul z.arg w.im)))","decl":"theorem abs_cpow_of_imp {z w : ℂ} (h : z = 0 → w.re = 0 → w = 0) :\n    abs (z ^ w) = abs z ^ w.re / Real.exp (arg z * im w) := by\n  rcases ne_or_eq z 0 with (hz | rfl) <;> [exact abs_cpow_of_ne_zero hz w; rw [map_zero]]\n  rcases eq_or_ne w.re 0 with hw | hw\n  · simp [hw, h rfl hw]\n  · rw [Real.zero_rpow hw, zero_div, zero_cpow, map_zero]\n    exact ne_of_apply_ne re hw\n\n"}
{"name":"Complex.abs_cpow_le","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"z w : Complex\n⊢ LE.le (Complex.abs (HPow.hPow z w)) (HDiv.hDiv (HPow.hPow (Complex.abs z) w.re) (Real.exp (HMul.hMul z.arg w.im)))","decl":"theorem abs_cpow_le (z w : ℂ) : abs (z ^ w) ≤ abs z ^ w.re / Real.exp (arg z * im w) := by\n  by_cases h : z = 0 → w.re = 0 → w = 0\n  · exact (abs_cpow_of_imp h).le\n  · push_neg at h\n    simp [h]\n\n"}
{"name":"Complex.abs_cpow_real","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Complex\ny : Real\n⊢ Eq (Complex.abs (HPow.hPow x ↑y)) (HPow.hPow (Complex.abs x) y)","decl":"@[simp]\ntheorem abs_cpow_real (x : ℂ) (y : ℝ) : abs (x ^ (y : ℂ)) = Complex.abs x ^ y := by\n  rw [abs_cpow_of_imp] <;> simp\n\n"}
{"name":"Complex.abs_cpow_inv_nat","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Complex\nn : Nat\n⊢ Eq (Complex.abs (HPow.hPow x (Inv.inv ↑n))) (HPow.hPow (Complex.abs x) (Inv.inv ↑n))","decl":"@[simp]\ntheorem abs_cpow_inv_nat (x : ℂ) (n : ℕ) : abs (x ^ (n⁻¹ : ℂ)) = Complex.abs x ^ (n⁻¹ : ℝ) := by\n  rw [← abs_cpow_real]; simp [-abs_cpow_real]\n\n"}
{"name":"Complex.abs_cpow_eq_rpow_re_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LT.lt 0 x\ny : Complex\n⊢ Eq (Complex.abs (HPow.hPow (↑x) y)) (HPow.hPow x y.re)","decl":"theorem abs_cpow_eq_rpow_re_of_pos {x : ℝ} (hx : 0 < x) (y : ℂ) : abs (x ^ y) = x ^ y.re := by\n  rw [abs_cpow_of_ne_zero (ofReal_ne_zero.mpr hx.ne'), arg_ofReal_of_nonneg hx.le,\n    zero_mul, Real.exp_zero, div_one, abs_of_nonneg hx.le]\n\n"}
{"name":"Complex.abs_cpow_eq_rpow_re_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LE.le 0 x\ny : Complex\nhy : Ne y.re 0\n⊢ Eq (Complex.abs (HPow.hPow (↑x) y)) (HPow.hPow x y.re)","decl":"theorem abs_cpow_eq_rpow_re_of_nonneg {x : ℝ} (hx : 0 ≤ x) {y : ℂ} (hy : re y ≠ 0) :\n    abs (x ^ y) = x ^ re y := by\n  rw [abs_cpow_of_imp] <;> simp [*, arg_ofReal_of_nonneg, _root_.abs_of_nonneg]\n\n"}
{"name":"Complex.norm_ofReal_cpow_eventually_eq_atTop","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"c : Complex\n⊢ Filter.atTop.EventuallyEq (fun t => Norm.norm (HPow.hPow (↑t) c)) fun t => HPow.hPow t c.re","decl":"open Filter in\nlemma norm_ofReal_cpow_eventually_eq_atTop (c : ℂ) :\n    (fun t : ℝ ↦ ‖(t : ℂ) ^ c‖) =ᶠ[atTop] fun t ↦ t ^ c.re := by\n  filter_upwards [eventually_gt_atTop 0] with t ht\n  rw [Complex.norm_eq_abs, abs_cpow_eq_rpow_re_of_pos ht]\n\n"}
{"name":"Complex.norm_natCast_cpow_of_re_ne_zero","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"n : Nat\ns : Complex\nhs : Ne s.re 0\n⊢ Eq (Norm.norm (HPow.hPow (↑n) s)) (HPow.hPow (↑n) s.re)","decl":"lemma norm_natCast_cpow_of_re_ne_zero (n : ℕ) {s : ℂ} (hs : s.re ≠ 0) :\n    ‖(n : ℂ) ^ s‖ = (n : ℝ) ^ (s.re) := by\n  rw [norm_eq_abs, ← ofReal_natCast, abs_cpow_eq_rpow_re_of_nonneg n.cast_nonneg hs]\n\n"}
{"name":"Complex.norm_natCast_cpow_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"n : Nat\nhn : LT.lt 0 n\ns : Complex\n⊢ Eq (Norm.norm (HPow.hPow (↑n) s)) (HPow.hPow (↑n) s.re)","decl":"lemma norm_natCast_cpow_of_pos {n : ℕ} (hn : 0 < n) (s : ℂ) :\n    ‖(n : ℂ) ^ s‖ = (n : ℝ) ^ (s.re) := by\n  rw [norm_eq_abs, ← ofReal_natCast, abs_cpow_eq_rpow_re_of_pos (Nat.cast_pos.mpr hn) _]\n\n"}
{"name":"Complex.norm_natCast_cpow_pos_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"n : Nat\nhn : LT.lt 0 n\ns : Complex\n⊢ LT.lt 0 (Norm.norm (HPow.hPow (↑n) s))","decl":"lemma norm_natCast_cpow_pos_of_pos {n : ℕ} (hn : 0 < n) (s : ℂ) : 0 < ‖(n : ℂ) ^ s‖ :=\n  (norm_natCast_cpow_of_pos hn _).symm ▸ Real.rpow_pos_of_pos (Nat.cast_pos.mpr hn) _\n\n"}
{"name":"Complex.cpow_mul_ofReal_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LE.le 0 x\ny : Real\nz : Complex\n⊢ Eq (HPow.hPow (↑x) (HMul.hMul (↑y) z)) (HPow.hPow (↑(HPow.hPow x y)) z)","decl":"theorem cpow_mul_ofReal_nonneg {x : ℝ} (hx : 0 ≤ x) (y : ℝ) (z : ℂ) :\n    (x : ℂ) ^ (↑y * z) = (↑(x ^ y) : ℂ) ^ z := by\n  rw [cpow_mul, ofReal_cpow hx]\n  · rw [← ofReal_log hx, ← ofReal_mul, ofReal_im, neg_lt_zero]; exact Real.pi_pos\n  · rw [← ofReal_log hx, ← ofReal_mul, ofReal_im]; exact Real.pi_pos.le\n\n"}
{"name":"Real.rpow_mul","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LE.le 0 x\ny z : Real\n⊢ Eq (HPow.hPow x (HMul.hMul y z)) (HPow.hPow (HPow.hPow x y) z)","decl":"theorem rpow_mul {x : ℝ} (hx : 0 ≤ x) (y z : ℝ) : x ^ (y * z) = (x ^ y) ^ z := by\n  rw [← Complex.ofReal_inj, Complex.ofReal_cpow (rpow_nonneg hx _),\n      Complex.ofReal_cpow hx, Complex.ofReal_mul, Complex.cpow_mul, Complex.ofReal_cpow hx] <;>\n    simp only [(Complex.ofReal_mul _ _).symm, (Complex.ofReal_log hx).symm, Complex.ofReal_im,\n      neg_lt_zero, pi_pos, le_of_lt pi_pos]\n\n"}
{"name":"Real.rpow_pow_comm","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LE.le 0 x\ny : Real\nn : Nat\n⊢ Eq (HPow.hPow (HPow.hPow x y) n) (HPow.hPow (HPow.hPow x n) y)","decl":"lemma rpow_pow_comm {x : ℝ} (hx : 0 ≤ x) (y : ℝ) (n : ℕ) : (x ^ y) ^ n = (x ^ n) ^ y := by\n  simp_rw [← rpow_natCast, ← rpow_mul hx, mul_comm y]\n\n"}
{"name":"Real.rpow_zpow_comm","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LE.le 0 x\ny : Real\nn : Int\n⊢ Eq (HPow.hPow (HPow.hPow x y) n) (HPow.hPow (HPow.hPow x n) y)","decl":"lemma rpow_zpow_comm {x : ℝ} (hx : 0 ≤ x) (y : ℝ) (n : ℤ) : (x ^ y) ^ n = (x ^ n) ^ y := by\n  simp_rw [← rpow_intCast, ← rpow_mul hx, mul_comm y]\n\n"}
{"name":"Real.rpow_add_intCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : Ne x 0\ny : Real\nn : Int\n⊢ Eq (HPow.hPow x (HAdd.hAdd y ↑n)) (HMul.hMul (HPow.hPow x y) (HPow.hPow x n))","decl":"lemma rpow_add_intCast {x : ℝ} (hx : x ≠ 0) (y : ℝ) (n : ℤ) : x ^ (y + n) = x ^ y * x ^ n := by\n  rw [rpow_def, rpow_def, Complex.ofReal_add,\n    Complex.cpow_add _ _ (Complex.ofReal_ne_zero.mpr hx), Complex.ofReal_intCast,\n    Complex.cpow_intCast, ← Complex.ofReal_zpow, mul_comm, Complex.re_ofReal_mul, mul_comm]\n\n"}
{"name":"Real.rpow_add_natCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : Ne x 0\ny : Real\nn : Nat\n⊢ Eq (HPow.hPow x (HAdd.hAdd y ↑n)) (HMul.hMul (HPow.hPow x y) (HPow.hPow x n))","decl":"lemma rpow_add_natCast {x : ℝ} (hx : x ≠ 0) (y : ℝ) (n : ℕ) : x ^ (y + n) = x ^ y * x ^ n := by\n  simpa using rpow_add_intCast hx y n\n\n"}
{"name":"Real.rpow_sub_intCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : Ne x 0\ny : Real\nn : Nat\n⊢ Eq (HPow.hPow x (HSub.hSub y ↑n)) (HDiv.hDiv (HPow.hPow x y) (HPow.hPow x n))","decl":"lemma rpow_sub_intCast {x : ℝ} (hx : x ≠ 0) (y : ℝ) (n : ℕ) : x ^ (y - n) = x ^ y / x ^ n := by\n  simpa using rpow_add_intCast hx y (-n)\n\n"}
{"name":"Real.rpow_sub_natCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : Ne x 0\ny : Real\nn : Nat\n⊢ Eq (HPow.hPow x (HSub.hSub y ↑n)) (HDiv.hDiv (HPow.hPow x y) (HPow.hPow x n))","decl":"lemma rpow_sub_natCast {x : ℝ} (hx : x ≠ 0) (y : ℝ) (n : ℕ) : x ^ (y - n) = x ^ y / x ^ n := by\n  simpa using rpow_sub_intCast hx y n\n\n"}
{"name":"Real.rpow_add_intCast'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nhx : LE.le 0 x\nn : Int\nh : Ne (HAdd.hAdd y ↑n) 0\n⊢ Eq (HPow.hPow x (HAdd.hAdd y ↑n)) (HMul.hMul (HPow.hPow x y) (HPow.hPow x n))","decl":"lemma rpow_add_intCast' (hx : 0 ≤ x) {n : ℤ} (h : y + n ≠ 0) : x ^ (y + n) = x ^ y * x ^ n := by\n  rw [rpow_add' hx h, rpow_intCast]\n\n"}
{"name":"Real.rpow_add_natCast'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nn : Nat\nhx : LE.le 0 x\nh : Ne (HAdd.hAdd y ↑n) 0\n⊢ Eq (HPow.hPow x (HAdd.hAdd y ↑n)) (HMul.hMul (HPow.hPow x y) (HPow.hPow x n))","decl":"lemma rpow_add_natCast' (hx : 0 ≤ x) (h : y + n ≠ 0) : x ^ (y + n) = x ^ y * x ^ n := by\n  rw [rpow_add' hx h, rpow_natCast]\n\n"}
{"name":"Real.rpow_sub_intCast'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nhx : LE.le 0 x\nn : Int\nh : Ne (HSub.hSub y ↑n) 0\n⊢ Eq (HPow.hPow x (HSub.hSub y ↑n)) (HDiv.hDiv (HPow.hPow x y) (HPow.hPow x n))","decl":"lemma rpow_sub_intCast' (hx : 0 ≤ x) {n : ℤ} (h : y - n ≠ 0) : x ^ (y - n) = x ^ y / x ^ n := by\n  rw [rpow_sub' hx h, rpow_intCast]\n\n"}
{"name":"Real.rpow_sub_natCast'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nn : Nat\nhx : LE.le 0 x\nh : Ne (HSub.hSub y ↑n) 0\n⊢ Eq (HPow.hPow x (HSub.hSub y ↑n)) (HDiv.hDiv (HPow.hPow x y) (HPow.hPow x n))","decl":"lemma rpow_sub_natCast' (hx : 0 ≤ x) (h : y - n ≠ 0) : x ^ (y - n) = x ^ y / x ^ n := by\n  rw [rpow_sub' hx h, rpow_natCast]\n\n"}
{"name":"Real.rpow_add_int","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : Ne x 0\ny : Real\nn : Int\n⊢ Eq (HPow.hPow x (HAdd.hAdd y ↑n)) (HMul.hMul (HPow.hPow x y) (HPow.hPow x n))","decl":"@[deprecated (since := \"2024-08-28\")] alias rpow_add_int := rpow_add_intCast\n"}
{"name":"Real.rpow_add_nat","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : Ne x 0\ny : Real\nn : Nat\n⊢ Eq (HPow.hPow x (HAdd.hAdd y ↑n)) (HMul.hMul (HPow.hPow x y) (HPow.hPow x n))","decl":"@[deprecated (since := \"2024-08-28\")] alias rpow_add_nat := rpow_add_natCast\n"}
{"name":"Real.rpow_sub_int","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : Ne x 0\ny : Real\nn : Nat\n⊢ Eq (HPow.hPow x (HSub.hSub y ↑n)) (HDiv.hDiv (HPow.hPow x y) (HPow.hPow x n))","decl":"@[deprecated (since := \"2024-08-28\")] alias rpow_sub_int := rpow_sub_intCast\n"}
{"name":"Real.rpow_sub_nat","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : Ne x 0\ny : Real\nn : Nat\n⊢ Eq (HPow.hPow x (HSub.hSub y ↑n)) (HDiv.hDiv (HPow.hPow x y) (HPow.hPow x n))","decl":"@[deprecated (since := \"2024-08-28\")] alias rpow_sub_nat := rpow_sub_natCast\n"}
{"name":"Real.rpow_add_int'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nhx : LE.le 0 x\nn : Int\nh : Ne (HAdd.hAdd y ↑n) 0\n⊢ Eq (HPow.hPow x (HAdd.hAdd y ↑n)) (HMul.hMul (HPow.hPow x y) (HPow.hPow x n))","decl":"@[deprecated (since := \"2024-08-28\")] alias rpow_add_int' := rpow_add_intCast'\n"}
{"name":"Real.rpow_add_nat'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nn : Nat\nhx : LE.le 0 x\nh : Ne (HAdd.hAdd y ↑n) 0\n⊢ Eq (HPow.hPow x (HAdd.hAdd y ↑n)) (HMul.hMul (HPow.hPow x y) (HPow.hPow x n))","decl":"@[deprecated (since := \"2024-08-28\")] alias rpow_add_nat' := rpow_add_natCast'\n"}
{"name":"Real.rpow_sub_int'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nhx : LE.le 0 x\nn : Int\nh : Ne (HSub.hSub y ↑n) 0\n⊢ Eq (HPow.hPow x (HSub.hSub y ↑n)) (HDiv.hDiv (HPow.hPow x y) (HPow.hPow x n))","decl":"@[deprecated (since := \"2024-08-28\")] alias rpow_sub_int' := rpow_sub_intCast'\n"}
{"name":"Real.rpow_sub_nat'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nn : Nat\nhx : LE.le 0 x\nh : Ne (HSub.hSub y ↑n) 0\n⊢ Eq (HPow.hPow x (HSub.hSub y ↑n)) (HDiv.hDiv (HPow.hPow x y) (HPow.hPow x n))","decl":"@[deprecated (since := \"2024-08-28\")] alias rpow_sub_nat' := rpow_sub_natCast'\n\n"}
{"name":"Real.rpow_add_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : Ne x 0\ny : Real\n⊢ Eq (HPow.hPow x (HAdd.hAdd y 1)) (HMul.hMul (HPow.hPow x y) x)","decl":"theorem rpow_add_one {x : ℝ} (hx : x ≠ 0) (y : ℝ) : x ^ (y + 1) = x ^ y * x := by\n  simpa using rpow_add_natCast hx y 1\n\n"}
{"name":"Real.rpow_sub_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : Ne x 0\ny : Real\n⊢ Eq (HPow.hPow x (HSub.hSub y 1)) (HDiv.hDiv (HPow.hPow x y) x)","decl":"theorem rpow_sub_one {x : ℝ} (hx : x ≠ 0) (y : ℝ) : x ^ (y - 1) = x ^ y / x := by\n  simpa using rpow_sub_natCast hx y 1\n\n"}
{"name":"Real.rpow_add_one'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nhx : LE.le 0 x\nh : Ne (HAdd.hAdd y 1) 0\n⊢ Eq (HPow.hPow x (HAdd.hAdd y 1)) (HMul.hMul (HPow.hPow x y) x)","decl":"lemma rpow_add_one' (hx : 0 ≤ x) (h : y + 1 ≠ 0) : x ^ (y + 1) = x ^ y * x := by\n  rw [rpow_add' hx h, rpow_one]\n\n"}
{"name":"Real.rpow_one_add'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nhx : LE.le 0 x\nh : Ne (HAdd.hAdd 1 y) 0\n⊢ Eq (HPow.hPow x (HAdd.hAdd 1 y)) (HMul.hMul x (HPow.hPow x y))","decl":"lemma rpow_one_add' (hx : 0 ≤ x) (h : 1 + y ≠ 0) : x ^ (1 + y) = x * x ^ y := by\n  rw [rpow_add' hx h, rpow_one]\n\n"}
{"name":"Real.rpow_sub_one'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nhx : LE.le 0 x\nh : Ne (HSub.hSub y 1) 0\n⊢ Eq (HPow.hPow x (HSub.hSub y 1)) (HDiv.hDiv (HPow.hPow x y) x)","decl":"lemma rpow_sub_one' (hx : 0 ≤ x) (h : y - 1 ≠ 0) : x ^ (y - 1) = x ^ y / x := by\n  rw [rpow_sub' hx h, rpow_one]\n\n"}
{"name":"Real.rpow_one_sub'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nhx : LE.le 0 x\nh : Ne (HSub.hSub 1 y) 0\n⊢ Eq (HPow.hPow x (HSub.hSub 1 y)) (HDiv.hDiv x (HPow.hPow x y))","decl":"lemma rpow_one_sub' (hx : 0 ≤ x) (h : 1 - y ≠ 0) : x ^ (1 - y) = x / x ^ y := by\n  rw [rpow_sub' hx h, rpow_one]\n\n"}
{"name":"Real.rpow_two","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\n⊢ Eq (HPow.hPow x 2) (HPow.hPow x 2)","decl":"@[simp]\ntheorem rpow_two (x : ℝ) : x ^ (2 : ℝ) = x ^ 2 := by\n  rw [← rpow_natCast]\n  simp only [Nat.cast_ofNat]\n\n"}
{"name":"Real.rpow_neg_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\n⊢ Eq (HPow.hPow x (-1)) (Inv.inv x)","decl":"theorem rpow_neg_one (x : ℝ) : x ^ (-1 : ℝ) = x⁻¹ := by\n  suffices H : x ^ ((-1 : ℤ) : ℝ) = x⁻¹ by rwa [Int.cast_neg, Int.cast_one] at H\n  simp only [rpow_intCast, zpow_one, zpow_neg]\n\n"}
{"name":"Real.mul_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LE.le 0 x\nhy : LE.le 0 y\n⊢ Eq (HPow.hPow (HMul.hMul x y) z) (HMul.hMul (HPow.hPow x z) (HPow.hPow y z))","decl":"theorem mul_rpow (hx : 0 ≤ x) (hy : 0 ≤ y) : (x * y) ^ z = x ^ z * y ^ z := by\n  iterate 2 rw [Real.rpow_def_of_nonneg]; split_ifs with h_ifs <;> simp_all\n  · rw [log_mul ‹_› ‹_›, add_mul, exp_add, rpow_def_of_pos (hy.lt_of_ne' ‹_›)]\n  all_goals positivity\n\n"}
{"name":"Real.inv_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LE.le 0 x\ny : Real\n⊢ Eq (HPow.hPow (Inv.inv x) y) (Inv.inv (HPow.hPow x y))","decl":"theorem inv_rpow (hx : 0 ≤ x) (y : ℝ) : x⁻¹ ^ y = (x ^ y)⁻¹ := by\n  simp only [← rpow_neg_one, ← rpow_mul hx, mul_comm]\n\n"}
{"name":"Real.div_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nhx : LE.le 0 x\nhy : LE.le 0 y\nz : Real\n⊢ Eq (HPow.hPow (HDiv.hDiv x y) z) (HDiv.hDiv (HPow.hPow x z) (HPow.hPow y z))","decl":"theorem div_rpow (hx : 0 ≤ x) (hy : 0 ≤ y) (z : ℝ) : (x / y) ^ z = x ^ z / y ^ z := by\n  simp only [div_eq_mul_inv, mul_rpow hx (inv_nonneg.2 hy), inv_rpow hy]\n\n"}
{"name":"Real.log_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LT.lt 0 x\ny : Real\n⊢ Eq (Real.log (HPow.hPow x y)) (HMul.hMul y (Real.log x))","decl":"theorem log_rpow {x : ℝ} (hx : 0 < x) (y : ℝ) : log (x ^ y) = y * log x := by\n  apply exp_injective\n  rw [exp_log (rpow_pos_of_pos hx y), ← exp_log hx, mul_comm, rpow_def_of_pos (exp_pos (log x)) y]\n\n"}
{"name":"Real.mul_log_eq_log_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LT.lt 0 x\nhz : LT.lt 0 z\n⊢ Iff (Eq (HMul.hMul y (Real.log x)) (Real.log z)) (Eq (HPow.hPow x y) z)","decl":"theorem mul_log_eq_log_iff {x y z : ℝ} (hx : 0 < x) (hz : 0 < z) :\n    y * log x = log z ↔ x ^ y = z :=\n  ⟨fun h ↦ log_injOn_pos (rpow_pos_of_pos hx _) hz <| log_rpow hx _ |>.trans h,\n  by rintro rfl; rw [log_rpow hx]⟩\n\n"}
{"name":"Real.rpow_rpow_inv","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nhx : LE.le 0 x\nhy : Ne y 0\n⊢ Eq (HPow.hPow (HPow.hPow x y) (Inv.inv y)) x","decl":"@[simp] lemma rpow_rpow_inv (hx : 0 ≤ x) (hy : y ≠ 0) : (x ^ y) ^ y⁻¹ = x := by\n  rw [← rpow_mul hx, mul_inv_cancel₀ hy, rpow_one]\n\n"}
{"name":"Real.rpow_inv_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nhx : LE.le 0 x\nhy : Ne y 0\n⊢ Eq (HPow.hPow (HPow.hPow x (Inv.inv y)) y) x","decl":"@[simp] lemma rpow_inv_rpow (hx : 0 ≤ x) (hy : y ≠ 0) : (x ^ y⁻¹) ^ y = x := by\n  rw [← rpow_mul hx, inv_mul_cancel₀ hy, rpow_one]\n\n"}
{"name":"Real.pow_rpow_inv_natCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nn : Nat\nhx : LE.le 0 x\nhn : Ne n 0\n⊢ Eq (HPow.hPow (HPow.hPow x n) (Inv.inv ↑n)) x","decl":"theorem pow_rpow_inv_natCast (hx : 0 ≤ x) (hn : n ≠ 0) : (x ^ n) ^ (n⁻¹ : ℝ) = x := by\n  have hn0 : (n : ℝ) ≠ 0 := Nat.cast_ne_zero.2 hn\n  rw [← rpow_natCast, ← rpow_mul hx, mul_inv_cancel₀ hn0, rpow_one]\n\n"}
{"name":"Real.rpow_inv_natCast_pow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nn : Nat\nhx : LE.le 0 x\nhn : Ne n 0\n⊢ Eq (HPow.hPow (HPow.hPow x (Inv.inv ↑n)) n) x","decl":"theorem rpow_inv_natCast_pow (hx : 0 ≤ x) (hn : n ≠ 0) : (x ^ (n⁻¹ : ℝ)) ^ n = x := by\n  have hn0 : (n : ℝ) ≠ 0 := Nat.cast_ne_zero.2 hn\n  rw [← rpow_natCast, ← rpow_mul hx, inv_mul_cancel₀ hn0, rpow_one]\n\n"}
{"name":"Real.rpow_natCast_mul","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LE.le 0 x\nn : Nat\nz : Real\n⊢ Eq (HPow.hPow x (HMul.hMul (↑n) z)) (HPow.hPow (HPow.hPow x n) z)","decl":"lemma rpow_natCast_mul (hx : 0 ≤ x) (n : ℕ) (z : ℝ) : x ^ (n * z) = (x ^ n) ^ z := by\n  rw [rpow_mul hx, rpow_natCast]\n\n"}
{"name":"Real.rpow_mul_natCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LE.le 0 x\ny : Real\nn : Nat\n⊢ Eq (HPow.hPow x (HMul.hMul y ↑n)) (HPow.hPow (HPow.hPow x y) n)","decl":"lemma rpow_mul_natCast (hx : 0 ≤ x) (y : ℝ) (n : ℕ) : x ^ (y * n) = (x ^ y) ^ n := by\n  rw [rpow_mul hx, rpow_natCast]\n\n"}
{"name":"Real.rpow_intCast_mul","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LE.le 0 x\nn : Int\nz : Real\n⊢ Eq (HPow.hPow x (HMul.hMul (↑n) z)) (HPow.hPow (HPow.hPow x n) z)","decl":"lemma rpow_intCast_mul (hx : 0 ≤ x) (n : ℤ) (z : ℝ) : x ^ (n * z) = (x ^ n) ^ z := by\n  rw [rpow_mul hx, rpow_intCast]\n\n"}
{"name":"Real.rpow_mul_intCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : LE.le 0 x\ny : Real\nn : Int\n⊢ Eq (HPow.hPow x (HMul.hMul y ↑n)) (HPow.hPow (HPow.hPow x y) n)","decl":"lemma rpow_mul_intCast (hx : 0 ≤ x) (y : ℝ) (n : ℤ) : x ^ (y * n) = (x ^ y) ^ n := by\n  rw [rpow_mul hx, rpow_intCast]\n\n"}
{"name":"Real.rpow_lt_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LE.le 0 x\nhxy : LT.lt x y\nhz : LT.lt 0 z\n⊢ LT.lt (HPow.hPow x z) (HPow.hPow y z)","decl":"@[gcongr, bound]\ntheorem rpow_lt_rpow (hx : 0 ≤ x) (hxy : x < y) (hz : 0 < z) : x ^ z < y ^ z := by\n  rw [le_iff_eq_or_lt] at hx; cases' hx with hx hx\n  · rw [← hx, zero_rpow (ne_of_gt hz)]\n    exact rpow_pos_of_pos (by rwa [← hx] at hxy) _\n  · rw [rpow_def_of_pos hx, rpow_def_of_pos (lt_trans hx hxy), exp_lt_exp]\n    exact mul_lt_mul_of_pos_right (log_lt_log hx hxy) hz\n\n"}
{"name":"Real.strictMonoOn_rpow_Ici_of_exponent_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"r : Real\nhr : LT.lt 0 r\n⊢ StrictMonoOn (fun x => HPow.hPow x r) (Set.Ici 0)","decl":"theorem strictMonoOn_rpow_Ici_of_exponent_pos {r : ℝ} (hr : 0 < r) :\n    StrictMonoOn (fun (x : ℝ) => x ^ r) (Set.Ici 0) :=\n  fun _ ha _ _ hab => rpow_lt_rpow ha hab hr\n\n"}
{"name":"Real.rpow_le_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nh : LE.le 0 x\nh₁ : LE.le x y\nh₂ : LE.le 0 z\n⊢ LE.le (HPow.hPow x z) (HPow.hPow y z)","decl":"@[gcongr, bound]\ntheorem rpow_le_rpow {x y z : ℝ} (h : 0 ≤ x) (h₁ : x ≤ y) (h₂ : 0 ≤ z) : x ^ z ≤ y ^ z := by\n  rcases eq_or_lt_of_le h₁ with (rfl | h₁'); · rfl\n  rcases eq_or_lt_of_le h₂ with (rfl | h₂'); · simp\n  exact le_of_lt (rpow_lt_rpow h h₁' h₂')\n\n"}
{"name":"Real.monotoneOn_rpow_Ici_of_exponent_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"r : Real\nhr : LE.le 0 r\n⊢ MonotoneOn (fun x => HPow.hPow x r) (Set.Ici 0)","decl":"theorem monotoneOn_rpow_Ici_of_exponent_nonneg {r : ℝ} (hr : 0 ≤ r) :\n    MonotoneOn (fun (x : ℝ) => x ^ r) (Set.Ici 0) :=\n  fun _ ha _ _ hab => rpow_le_rpow ha hab hr\n\n"}
{"name":"Real.rpow_lt_rpow_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LT.lt 0 x\nhxy : LT.lt x y\nhz : LT.lt z 0\n⊢ LT.lt (HPow.hPow y z) (HPow.hPow x z)","decl":"lemma rpow_lt_rpow_of_neg (hx : 0 < x) (hxy : x < y) (hz : z < 0) : y ^ z < x ^ z := by\n  have := hx.trans hxy\n  rw [← inv_lt_inv₀, ← rpow_neg, ← rpow_neg]\n  on_goal 1 => refine rpow_lt_rpow ?_ hxy (neg_pos.2 hz)\n  all_goals positivity\n\n"}
{"name":"Real.rpow_le_rpow_of_nonpos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LT.lt 0 x\nhxy : LE.le x y\nhz : LE.le z 0\n⊢ LE.le (HPow.hPow y z) (HPow.hPow x z)","decl":"lemma rpow_le_rpow_of_nonpos (hx : 0 < x) (hxy : x ≤ y) (hz : z ≤ 0) : y ^ z ≤ x ^ z := by\n  have := hx.trans_le hxy\n  rw [← inv_le_inv₀, ← rpow_neg, ← rpow_neg]\n  on_goal 1 => refine rpow_le_rpow ?_ hxy (neg_nonneg.2 hz)\n  all_goals positivity\n\n"}
{"name":"Real.rpow_lt_rpow_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LE.le 0 x\nhy : LE.le 0 y\nhz : LT.lt 0 z\n⊢ Iff (LT.lt (HPow.hPow x z) (HPow.hPow y z)) (LT.lt x y)","decl":"theorem rpow_lt_rpow_iff (hx : 0 ≤ x) (hy : 0 ≤ y) (hz : 0 < z) : x ^ z < y ^ z ↔ x < y :=\n  ⟨lt_imp_lt_of_le_imp_le fun h => rpow_le_rpow hy h (le_of_lt hz), fun h => rpow_lt_rpow hx h hz⟩\n\n"}
{"name":"Real.rpow_le_rpow_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LE.le 0 x\nhy : LE.le 0 y\nhz : LT.lt 0 z\n⊢ Iff (LE.le (HPow.hPow x z) (HPow.hPow y z)) (LE.le x y)","decl":"theorem rpow_le_rpow_iff (hx : 0 ≤ x) (hy : 0 ≤ y) (hz : 0 < z) : x ^ z ≤ y ^ z ↔ x ≤ y :=\n  le_iff_le_iff_lt_iff_lt.2 <| rpow_lt_rpow_iff hy hx hz\n\n"}
{"name":"Real.rpow_lt_rpow_iff_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LT.lt 0 x\nhy : LT.lt 0 y\nhz : LT.lt z 0\n⊢ Iff (LT.lt (HPow.hPow x z) (HPow.hPow y z)) (LT.lt y x)","decl":"lemma rpow_lt_rpow_iff_of_neg (hx : 0 < x) (hy : 0 < y) (hz : z < 0) : x ^ z < y ^ z ↔ y < x :=\n  ⟨lt_imp_lt_of_le_imp_le fun h ↦ rpow_le_rpow_of_nonpos hx h hz.le,\n    fun h ↦ rpow_lt_rpow_of_neg hy h hz⟩\n\n"}
{"name":"Real.rpow_le_rpow_iff_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LT.lt 0 x\nhy : LT.lt 0 y\nhz : LT.lt z 0\n⊢ Iff (LE.le (HPow.hPow x z) (HPow.hPow y z)) (LE.le y x)","decl":"lemma rpow_le_rpow_iff_of_neg (hx : 0 < x) (hy : 0 < y) (hz : z < 0) : x ^ z ≤ y ^ z ↔ y ≤ x :=\n  le_iff_le_iff_lt_iff_lt.2 <| rpow_lt_rpow_iff_of_neg hy hx hz\n\n"}
{"name":"Real.le_rpow_inv_iff_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LE.le 0 x\nhy : LE.le 0 y\nhz : LT.lt 0 z\n⊢ Iff (LE.le x (HPow.hPow y (Inv.inv z))) (LE.le (HPow.hPow x z) y)","decl":"lemma le_rpow_inv_iff_of_pos (hx : 0 ≤ x) (hy : 0 ≤ y) (hz : 0 < z) : x ≤ y ^ z⁻¹ ↔ x ^ z ≤ y := by\n  rw [← rpow_le_rpow_iff hx _ hz, rpow_inv_rpow] <;> positivity\n\n"}
{"name":"Real.rpow_inv_le_iff_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LE.le 0 x\nhy : LE.le 0 y\nhz : LT.lt 0 z\n⊢ Iff (LE.le (HPow.hPow x (Inv.inv z)) y) (LE.le x (HPow.hPow y z))","decl":"lemma rpow_inv_le_iff_of_pos (hx : 0 ≤ x) (hy : 0 ≤ y) (hz : 0 < z) : x ^ z⁻¹ ≤ y ↔ x ≤ y ^ z := by\n  rw [← rpow_le_rpow_iff _ hy hz, rpow_inv_rpow] <;> positivity\n\n"}
{"name":"Real.lt_rpow_inv_iff_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LE.le 0 x\nhy : LE.le 0 y\nhz : LT.lt 0 z\n⊢ Iff (LT.lt x (HPow.hPow y (Inv.inv z))) (LT.lt (HPow.hPow x z) y)","decl":"lemma lt_rpow_inv_iff_of_pos (hx : 0 ≤ x) (hy : 0 ≤ y) (hz : 0 < z) : x < y ^ z⁻¹ ↔ x ^ z < y :=\n  lt_iff_lt_of_le_iff_le <| rpow_inv_le_iff_of_pos hy hx hz\n\n"}
{"name":"Real.rpow_inv_lt_iff_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LE.le 0 x\nhy : LE.le 0 y\nhz : LT.lt 0 z\n⊢ Iff (LT.lt (HPow.hPow x (Inv.inv z)) y) (LT.lt x (HPow.hPow y z))","decl":"lemma rpow_inv_lt_iff_of_pos (hx : 0 ≤ x) (hy : 0 ≤ y) (hz : 0 < z) : x ^ z⁻¹ < y ↔ x < y ^ z :=\n  lt_iff_lt_of_le_iff_le <| le_rpow_inv_iff_of_pos hy hx hz\n\n"}
{"name":"Real.le_rpow_inv_iff_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LT.lt 0 x\nhy : LT.lt 0 y\nhz : LT.lt z 0\n⊢ Iff (LE.le x (HPow.hPow y (Inv.inv z))) (LE.le y (HPow.hPow x z))","decl":"theorem le_rpow_inv_iff_of_neg (hx : 0 < x) (hy : 0 < y) (hz : z < 0) :\n    x ≤ y ^ z⁻¹ ↔ y ≤ x ^ z := by\n  rw [← rpow_le_rpow_iff_of_neg _ hx hz, rpow_inv_rpow _ hz.ne] <;> positivity\n\n"}
{"name":"Real.lt_rpow_inv_iff_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LT.lt 0 x\nhy : LT.lt 0 y\nhz : LT.lt z 0\n⊢ Iff (LT.lt x (HPow.hPow y (Inv.inv z))) (LT.lt y (HPow.hPow x z))","decl":"theorem lt_rpow_inv_iff_of_neg (hx : 0 < x) (hy : 0 < y) (hz : z < 0) :\n    x < y ^ z⁻¹ ↔ y < x ^ z := by\n  rw [← rpow_lt_rpow_iff_of_neg _ hx hz, rpow_inv_rpow _ hz.ne] <;> positivity\n\n"}
{"name":"Real.rpow_inv_lt_iff_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LT.lt 0 x\nhy : LT.lt 0 y\nhz : LT.lt z 0\n⊢ Iff (LT.lt (HPow.hPow x (Inv.inv z)) y) (LT.lt (HPow.hPow y z) x)","decl":"theorem rpow_inv_lt_iff_of_neg (hx : 0 < x) (hy : 0 < y) (hz : z < 0) :\n    x ^ z⁻¹ < y ↔ y ^ z < x := by\n  rw [← rpow_lt_rpow_iff_of_neg hy _ hz, rpow_inv_rpow _ hz.ne] <;> positivity\n\n"}
{"name":"Real.rpow_inv_le_iff_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LT.lt 0 x\nhy : LT.lt 0 y\nhz : LT.lt z 0\n⊢ Iff (LE.le (HPow.hPow x (Inv.inv z)) y) (LE.le (HPow.hPow y z) x)","decl":"theorem rpow_inv_le_iff_of_neg (hx : 0 < x) (hy : 0 < y) (hz : z < 0) :\n    x ^ z⁻¹ ≤ y ↔ y ^ z ≤ x := by\n  rw [← rpow_le_rpow_iff_of_neg hy _ hz, rpow_inv_rpow _ hz.ne] <;> positivity\n\n"}
{"name":"Real.rpow_lt_rpow_of_exponent_lt","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LT.lt 1 x\nhyz : LT.lt y z\n⊢ LT.lt (HPow.hPow x y) (HPow.hPow x z)","decl":"theorem rpow_lt_rpow_of_exponent_lt (hx : 1 < x) (hyz : y < z) : x ^ y < x ^ z := by\n  repeat' rw [rpow_def_of_pos (lt_trans zero_lt_one hx)]\n  rw [exp_lt_exp]; exact mul_lt_mul_of_pos_left hyz (log_pos hx)\n\n"}
{"name":"Real.rpow_le_rpow_of_exponent_le","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LE.le 1 x\nhyz : LE.le y z\n⊢ LE.le (HPow.hPow x y) (HPow.hPow x z)","decl":"@[gcongr]\ntheorem rpow_le_rpow_of_exponent_le (hx : 1 ≤ x) (hyz : y ≤ z) : x ^ y ≤ x ^ z := by\n  repeat' rw [rpow_def_of_pos (lt_of_lt_of_le zero_lt_one hx)]\n  rw [exp_le_exp]; exact mul_le_mul_of_nonneg_left hyz (log_nonneg hx)\n\n"}
{"name":"Real.rpow_lt_rpow_of_exponent_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhy : LT.lt 0 y\nhxy : LT.lt y x\nhz : LT.lt z 0\n⊢ LT.lt (HPow.hPow x z) (HPow.hPow y z)","decl":"theorem rpow_lt_rpow_of_exponent_neg {x y z : ℝ} (hy : 0 < y) (hxy : y < x) (hz : z < 0) :\n    x ^ z < y ^ z := by\n  have hx : 0 < x := hy.trans hxy\n  rw [← neg_neg z, Real.rpow_neg (le_of_lt hx) (-z), Real.rpow_neg (le_of_lt hy) (-z),\n      inv_lt_inv₀ (rpow_pos_of_pos hx _) (rpow_pos_of_pos hy _)]\n  exact Real.rpow_lt_rpow (by positivity) hxy <| neg_pos_of_neg hz\n\n"}
{"name":"Real.strictAntiOn_rpow_Ioi_of_exponent_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"r : Real\nhr : LT.lt r 0\n⊢ StrictAntiOn (fun x => HPow.hPow x r) (Set.Ioi 0)","decl":"theorem strictAntiOn_rpow_Ioi_of_exponent_neg {r : ℝ} (hr : r < 0) :\n    StrictAntiOn (fun (x : ℝ) => x ^ r) (Set.Ioi 0) :=\n  fun _ ha _ _ hab => rpow_lt_rpow_of_exponent_neg ha hab hr\n\n"}
{"name":"Real.rpow_le_rpow_of_exponent_nonpos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"z x y : Real\nhy : LT.lt 0 y\nhxy : LE.le y x\nhz : LE.le z 0\n⊢ LE.le (HPow.hPow x z) (HPow.hPow y z)","decl":"theorem rpow_le_rpow_of_exponent_nonpos {x y : ℝ} (hy : 0 < y) (hxy : y ≤ x) (hz : z ≤ 0) :\n    x ^ z ≤ y ^ z := by\n  rcases ne_or_eq z 0 with hz_zero | rfl\n  case inl =>\n    rcases ne_or_eq x y with hxy' | rfl\n    case inl =>\n      exact le_of_lt <| rpow_lt_rpow_of_exponent_neg hy (Ne.lt_of_le (id (Ne.symm hxy')) hxy)\n        (Ne.lt_of_le hz_zero hz)\n    case inr => simp\n  case inr => simp\n\n"}
{"name":"Real.antitoneOn_rpow_Ioi_of_exponent_nonpos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"r : Real\nhr : LE.le r 0\n⊢ AntitoneOn (fun x => HPow.hPow x r) (Set.Ioi 0)","decl":"theorem antitoneOn_rpow_Ioi_of_exponent_nonpos {r : ℝ} (hr : r ≤ 0) :\n    AntitoneOn (fun (x : ℝ) => x ^ r) (Set.Ioi 0) :=\n  fun _ ha _ _ hab => rpow_le_rpow_of_exponent_nonpos ha hab hr\n\n"}
{"name":"Real.rpow_le_rpow_left_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LT.lt 1 x\n⊢ Iff (LE.le (HPow.hPow x y) (HPow.hPow x z)) (LE.le y z)","decl":"@[simp]\ntheorem rpow_le_rpow_left_iff (hx : 1 < x) : x ^ y ≤ x ^ z ↔ y ≤ z := by\n  have x_pos : 0 < x := lt_trans zero_lt_one hx\n  rw [← log_le_log_iff (rpow_pos_of_pos x_pos y) (rpow_pos_of_pos x_pos z), log_rpow x_pos,\n    log_rpow x_pos, mul_le_mul_right (log_pos hx)]\n\n"}
{"name":"Real.rpow_lt_rpow_left_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LT.lt 1 x\n⊢ Iff (LT.lt (HPow.hPow x y) (HPow.hPow x z)) (LT.lt y z)","decl":"@[simp]\ntheorem rpow_lt_rpow_left_iff (hx : 1 < x) : x ^ y < x ^ z ↔ y < z := by\n  rw [lt_iff_not_le, rpow_le_rpow_left_iff hx, lt_iff_not_le]\n\n"}
{"name":"Real.rpow_lt_rpow_of_exponent_gt","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx0 : LT.lt 0 x\nhx1 : LT.lt x 1\nhyz : LT.lt z y\n⊢ LT.lt (HPow.hPow x y) (HPow.hPow x z)","decl":"theorem rpow_lt_rpow_of_exponent_gt (hx0 : 0 < x) (hx1 : x < 1) (hyz : z < y) : x ^ y < x ^ z := by\n  repeat' rw [rpow_def_of_pos hx0]\n  rw [exp_lt_exp]; exact mul_lt_mul_of_neg_left hyz (log_neg hx0 hx1)\n\n"}
{"name":"Real.rpow_le_rpow_of_exponent_ge","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx0 : LT.lt 0 x\nhx1 : LE.le x 1\nhyz : LE.le z y\n⊢ LE.le (HPow.hPow x y) (HPow.hPow x z)","decl":"theorem rpow_le_rpow_of_exponent_ge (hx0 : 0 < x) (hx1 : x ≤ 1) (hyz : z ≤ y) : x ^ y ≤ x ^ z := by\n  repeat' rw [rpow_def_of_pos hx0]\n  rw [exp_le_exp]; exact mul_le_mul_of_nonpos_left hyz (log_nonpos (le_of_lt hx0) hx1)\n\n"}
{"name":"Real.rpow_le_rpow_left_iff_of_base_lt_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx0 : LT.lt 0 x\nhx1 : LT.lt x 1\n⊢ Iff (LE.le (HPow.hPow x y) (HPow.hPow x z)) (LE.le z y)","decl":"@[simp]\ntheorem rpow_le_rpow_left_iff_of_base_lt_one (hx0 : 0 < x) (hx1 : x < 1) :\n    x ^ y ≤ x ^ z ↔ z ≤ y := by\n  rw [← log_le_log_iff (rpow_pos_of_pos hx0 y) (rpow_pos_of_pos hx0 z), log_rpow hx0, log_rpow hx0,\n    mul_le_mul_right_of_neg (log_neg hx0 hx1)]\n\n"}
{"name":"Real.rpow_lt_rpow_left_iff_of_base_lt_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx0 : LT.lt 0 x\nhx1 : LT.lt x 1\n⊢ Iff (LT.lt (HPow.hPow x y) (HPow.hPow x z)) (LT.lt z y)","decl":"@[simp]\ntheorem rpow_lt_rpow_left_iff_of_base_lt_one (hx0 : 0 < x) (hx1 : x < 1) :\n    x ^ y < x ^ z ↔ z < y := by\n  rw [lt_iff_not_le, rpow_le_rpow_left_iff_of_base_lt_one hx0 hx1, lt_iff_not_le]\n\n"}
{"name":"Real.rpow_lt_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x z : Real\nhx1 : LE.le 0 x\nhx2 : LT.lt x 1\nhz : LT.lt 0 z\n⊢ LT.lt (HPow.hPow x z) 1","decl":"theorem rpow_lt_one {x z : ℝ} (hx1 : 0 ≤ x) (hx2 : x < 1) (hz : 0 < z) : x ^ z < 1 := by\n  rw [← one_rpow z]\n  exact rpow_lt_rpow hx1 hx2 hz\n\n"}
{"name":"Real.rpow_le_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x z : Real\nhx1 : LE.le 0 x\nhx2 : LE.le x 1\nhz : LE.le 0 z\n⊢ LE.le (HPow.hPow x z) 1","decl":"theorem rpow_le_one {x z : ℝ} (hx1 : 0 ≤ x) (hx2 : x ≤ 1) (hz : 0 ≤ z) : x ^ z ≤ 1 := by\n  rw [← one_rpow z]\n  exact rpow_le_rpow hx1 hx2 hz\n\n"}
{"name":"Real.rpow_lt_one_of_one_lt_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x z : Real\nhx : LT.lt 1 x\nhz : LT.lt z 0\n⊢ LT.lt (HPow.hPow x z) 1","decl":"theorem rpow_lt_one_of_one_lt_of_neg {x z : ℝ} (hx : 1 < x) (hz : z < 0) : x ^ z < 1 := by\n  convert rpow_lt_rpow_of_exponent_lt hx hz\n  exact (rpow_zero x).symm\n\n"}
{"name":"Real.rpow_le_one_of_one_le_of_nonpos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x z : Real\nhx : LE.le 1 x\nhz : LE.le z 0\n⊢ LE.le (HPow.hPow x z) 1","decl":"theorem rpow_le_one_of_one_le_of_nonpos {x z : ℝ} (hx : 1 ≤ x) (hz : z ≤ 0) : x ^ z ≤ 1 := by\n  convert rpow_le_rpow_of_exponent_le hx hz\n  exact (rpow_zero x).symm\n\n"}
{"name":"Real.one_lt_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x z : Real\nhx : LT.lt 1 x\nhz : LT.lt 0 z\n⊢ LT.lt 1 (HPow.hPow x z)","decl":"theorem one_lt_rpow {x z : ℝ} (hx : 1 < x) (hz : 0 < z) : 1 < x ^ z := by\n  rw [← one_rpow z]\n  exact rpow_lt_rpow zero_le_one hx hz\n\n"}
{"name":"Real.one_le_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x z : Real\nhx : LE.le 1 x\nhz : LE.le 0 z\n⊢ LE.le 1 (HPow.hPow x z)","decl":"theorem one_le_rpow {x z : ℝ} (hx : 1 ≤ x) (hz : 0 ≤ z) : 1 ≤ x ^ z := by\n  rw [← one_rpow z]\n  exact rpow_le_rpow zero_le_one hx hz\n\n"}
{"name":"Real.one_lt_rpow_of_pos_of_lt_one_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x z : Real\nhx1 : LT.lt 0 x\nhx2 : LT.lt x 1\nhz : LT.lt z 0\n⊢ LT.lt 1 (HPow.hPow x z)","decl":"theorem one_lt_rpow_of_pos_of_lt_one_of_neg (hx1 : 0 < x) (hx2 : x < 1) (hz : z < 0) :\n    1 < x ^ z := by\n  convert rpow_lt_rpow_of_exponent_gt hx1 hx2 hz\n  exact (rpow_zero x).symm\n\n"}
{"name":"Real.one_le_rpow_of_pos_of_le_one_of_nonpos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x z : Real\nhx1 : LT.lt 0 x\nhx2 : LE.le x 1\nhz : LE.le z 0\n⊢ LE.le 1 (HPow.hPow x z)","decl":"theorem one_le_rpow_of_pos_of_le_one_of_nonpos (hx1 : 0 < x) (hx2 : x ≤ 1) (hz : z ≤ 0) :\n    1 ≤ x ^ z := by\n  convert rpow_le_rpow_of_exponent_ge hx1 hx2 hz\n  exact (rpow_zero x).symm\n\n"}
{"name":"Real.rpow_lt_one_iff_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nhx : LT.lt 0 x\n⊢ Iff (LT.lt (HPow.hPow x y) 1) (Or (And (LT.lt 1 x) (LT.lt y 0)) (And (LT.lt x 1) (LT.lt 0 y)))","decl":"theorem rpow_lt_one_iff_of_pos (hx : 0 < x) : x ^ y < 1 ↔ 1 < x ∧ y < 0 ∨ x < 1 ∧ 0 < y := by\n  rw [rpow_def_of_pos hx, exp_lt_one_iff, mul_neg_iff, log_pos_iff hx.le, log_neg_iff hx]\n\n"}
{"name":"Real.rpow_lt_one_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nhx : LE.le 0 x\n⊢ Iff (LT.lt (HPow.hPow x y) 1) (Or (And (Eq x 0) (Ne y 0)) (Or (And (LT.lt 1 x) (LT.lt y 0)) (And (LT.lt x 1) (LT.lt 0 y))))","decl":"theorem rpow_lt_one_iff (hx : 0 ≤ x) :\n    x ^ y < 1 ↔ x = 0 ∧ y ≠ 0 ∨ 1 < x ∧ y < 0 ∨ x < 1 ∧ 0 < y := by\n  rcases hx.eq_or_lt with (rfl | hx)\n  · rcases _root_.em (y = 0) with (rfl | hy) <;> simp [*, lt_irrefl, zero_lt_one]\n  · simp [rpow_lt_one_iff_of_pos hx, hx.ne.symm]\n\n"}
{"name":"Real.rpow_lt_one_iff'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nhx : LE.le 0 x\nhy : LT.lt 0 y\n⊢ Iff (LT.lt (HPow.hPow x y) 1) (LT.lt x 1)","decl":"theorem rpow_lt_one_iff' {x y : ℝ} (hx : 0 ≤ x) (hy : 0 < y) :\n    x ^ y < 1 ↔ x < 1 := by\n  rw [← Real.rpow_lt_rpow_iff hx zero_le_one hy, Real.one_rpow]\n\n"}
{"name":"Real.one_lt_rpow_iff_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nhx : LT.lt 0 x\n⊢ Iff (LT.lt 1 (HPow.hPow x y)) (Or (And (LT.lt 1 x) (LT.lt 0 y)) (And (LT.lt x 1) (LT.lt y 0)))","decl":"theorem one_lt_rpow_iff_of_pos (hx : 0 < x) : 1 < x ^ y ↔ 1 < x ∧ 0 < y ∨ x < 1 ∧ y < 0 := by\n  rw [rpow_def_of_pos hx, one_lt_exp_iff, mul_pos_iff, log_pos_iff hx.le, log_neg_iff hx]\n\n"}
{"name":"Real.one_lt_rpow_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nhx : LE.le 0 x\n⊢ Iff (LT.lt 1 (HPow.hPow x y)) (Or (And (LT.lt 1 x) (LT.lt 0 y)) (And (LT.lt 0 x) (And (LT.lt x 1) (LT.lt y 0))))","decl":"theorem one_lt_rpow_iff (hx : 0 ≤ x) : 1 < x ^ y ↔ 1 < x ∧ 0 < y ∨ 0 < x ∧ x < 1 ∧ y < 0 := by\n  rcases hx.eq_or_lt with (rfl | hx)\n  · rcases _root_.em (y = 0) with (rfl | hy) <;> simp [*, lt_irrefl, (zero_lt_one' ℝ).not_lt]\n  · simp [one_lt_rpow_iff_of_pos hx, hx]\n\n"}
{"name":"Real.rpow_le_rpow_of_exponent_ge_of_imp","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx0 : LE.le 0 x\nhx1 : LE.le x 1\nhyz : LE.le z y\nh : Eq x 0 → Eq y 0 → Eq z 0\n⊢ LE.le (HPow.hPow x y) (HPow.hPow x z)","decl":"/-- This is a more general but less convenient version of `rpow_le_rpow_of_exponent_ge`.\nThis version allows `x = 0`, so it explicitly forbids `x = y = 0`, `z ≠ 0`. -/\ntheorem rpow_le_rpow_of_exponent_ge_of_imp (hx0 : 0 ≤ x) (hx1 : x ≤ 1) (hyz : z ≤ y)\n    (h : x = 0 → y = 0 → z = 0) :\n    x ^ y ≤ x ^ z := by\n  rcases eq_or_lt_of_le hx0 with (rfl | hx0')\n  · rcases eq_or_ne y 0 with rfl | hy0\n    · rw [h rfl rfl]\n    · rw [zero_rpow hy0]\n      apply zero_rpow_nonneg\n  · exact rpow_le_rpow_of_exponent_ge hx0' hx1 hyz\n\n"}
{"name":"Real.rpow_le_rpow_of_exponent_ge'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx0 : LE.le 0 x\nhx1 : LE.le x 1\nhz : LE.le 0 z\nhyz : LE.le z y\n⊢ LE.le (HPow.hPow x y) (HPow.hPow x z)","decl":"/-- This version of `rpow_le_rpow_of_exponent_ge` allows `x = 0` but requires `0 ≤ z`.\nSee also `rpow_le_rpow_of_exponent_ge_of_imp` for the most general version. -/\ntheorem rpow_le_rpow_of_exponent_ge' (hx0 : 0 ≤ x) (hx1 : x ≤ 1) (hz : 0 ≤ z) (hyz : z ≤ y) :\n    x ^ y ≤ x ^ z :=\n  rpow_le_rpow_of_exponent_ge_of_imp hx0 hx1 hyz fun _ hy ↦ le_antisymm (hyz.trans_eq hy) hz\n\n"}
{"name":"Real.rpow_max","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y p : Real\nhx : LE.le 0 x\nhy : LE.le 0 y\nhp : LE.le 0 p\n⊢ Eq (HPow.hPow (Max.max x y) p) (Max.max (HPow.hPow x p) (HPow.hPow y p))","decl":"lemma rpow_max {x y p : ℝ} (hx : 0 ≤ x) (hy : 0 ≤ y) (hp : 0 ≤ p) :\n    (max x y) ^ p = max (x ^ p) (y ^ p) := by\n  rcases le_total x y with hxy | hxy\n  · rw [max_eq_right hxy, max_eq_right (rpow_le_rpow hx hxy hp)]\n  · rw [max_eq_left hxy, max_eq_left (rpow_le_rpow hy hxy hp)]\n\n"}
{"name":"Real.self_le_rpow_of_le_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nh₁ : LE.le 0 x\nh₂ : LE.le x 1\nh₃ : LE.le y 1\n⊢ LE.le x (HPow.hPow x y)","decl":"theorem self_le_rpow_of_le_one (h₁ : 0 ≤ x) (h₂ : x ≤ 1) (h₃ : y ≤ 1) : x ≤ x ^ y := by\n  simpa only [rpow_one]\n    using rpow_le_rpow_of_exponent_ge_of_imp h₁ h₂ h₃ fun _ ↦ (absurd · one_ne_zero)\n\n"}
{"name":"Real.self_le_rpow_of_one_le","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nh₁ : LE.le 1 x\nh₂ : LE.le 1 y\n⊢ LE.le x (HPow.hPow x y)","decl":"theorem self_le_rpow_of_one_le (h₁ : 1 ≤ x) (h₂ : 1 ≤ y) : x ≤ x ^ y := by\n  simpa only [rpow_one] using rpow_le_rpow_of_exponent_le h₁ h₂\n\n"}
{"name":"Real.rpow_le_self_of_le_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nh₁ : LE.le 0 x\nh₂ : LE.le x 1\nh₃ : LE.le 1 y\n⊢ LE.le (HPow.hPow x y) x","decl":"theorem rpow_le_self_of_le_one (h₁ : 0 ≤ x) (h₂ : x ≤ 1) (h₃ : 1 ≤ y) : x ^ y ≤ x := by\n  simpa only [rpow_one]\n    using rpow_le_rpow_of_exponent_ge_of_imp h₁ h₂ h₃ fun _ ↦ (absurd · (one_pos.trans_le h₃).ne')\n\n"}
{"name":"Real.rpow_le_self_of_one_le","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nh₁ : LE.le 1 x\nh₂ : LE.le y 1\n⊢ LE.le (HPow.hPow x y) x","decl":"theorem rpow_le_self_of_one_le (h₁ : 1 ≤ x) (h₂ : y ≤ 1) : x ^ y ≤ x := by\n  simpa only [rpow_one] using rpow_le_rpow_of_exponent_le h₁ h₂\n\n"}
{"name":"Real.self_lt_rpow_of_lt_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nh₁ : LT.lt 0 x\nh₂ : LT.lt x 1\nh₃ : LT.lt y 1\n⊢ LT.lt x (HPow.hPow x y)","decl":"theorem self_lt_rpow_of_lt_one (h₁ : 0 < x) (h₂ : x < 1) (h₃ : y < 1) : x < x ^ y := by\n  simpa only [rpow_one] using rpow_lt_rpow_of_exponent_gt h₁ h₂ h₃\n\n"}
{"name":"Real.self_lt_rpow_of_one_lt","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nh₁ : LT.lt 1 x\nh₂ : LT.lt 1 y\n⊢ LT.lt x (HPow.hPow x y)","decl":"theorem self_lt_rpow_of_one_lt (h₁ : 1 < x) (h₂ : 1 < y) : x < x ^ y := by\n  simpa only [rpow_one] using rpow_lt_rpow_of_exponent_lt h₁ h₂\n\n"}
{"name":"Real.rpow_lt_self_of_lt_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nh₁ : LT.lt 0 x\nh₂ : LT.lt x 1\nh₃ : LT.lt 1 y\n⊢ LT.lt (HPow.hPow x y) x","decl":"theorem rpow_lt_self_of_lt_one (h₁ : 0 < x) (h₂ : x < 1) (h₃ : 1 < y) : x ^ y < x := by\n  simpa only [rpow_one] using rpow_lt_rpow_of_exponent_gt h₁ h₂ h₃\n\n"}
{"name":"Real.rpow_lt_self_of_one_lt","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nh₁ : LT.lt 1 x\nh₂ : LT.lt y 1\n⊢ LT.lt (HPow.hPow x y) x","decl":"theorem rpow_lt_self_of_one_lt (h₁ : 1 < x) (h₂ : y < 1) : x ^ y < x := by\n  simpa only [rpow_one] using rpow_lt_rpow_of_exponent_lt h₁ h₂\n\n"}
{"name":"Real.rpow_left_injOn","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\nhx : Ne x 0\n⊢ Set.InjOn (fun y => HPow.hPow y x) (setOf fun y => LE.le 0 y)","decl":"theorem rpow_left_injOn {x : ℝ} (hx : x ≠ 0) : InjOn (fun y : ℝ => y ^ x) { y : ℝ | 0 ≤ y } := by\n  rintro y hy z hz (hyz : y ^ x = z ^ x)\n  rw [← rpow_one y, ← rpow_one z, ← mul_inv_cancel₀ hx, rpow_mul hy, rpow_mul hz, hyz]\n\n"}
{"name":"Real.rpow_left_inj","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LE.le 0 x\nhy : LE.le 0 y\nhz : Ne z 0\n⊢ Iff (Eq (HPow.hPow x z) (HPow.hPow y z)) (Eq x y)","decl":"lemma rpow_left_inj (hx : 0 ≤ x) (hy : 0 ≤ y) (hz : z ≠ 0) : x ^ z = y ^ z ↔ x = y :=\n  (rpow_left_injOn hz).eq_iff hx hy\n\n"}
{"name":"Real.rpow_inv_eq","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LE.le 0 x\nhy : LE.le 0 y\nhz : Ne z 0\n⊢ Iff (Eq (HPow.hPow x (Inv.inv z)) y) (Eq x (HPow.hPow y z))","decl":"lemma rpow_inv_eq (hx : 0 ≤ x) (hy : 0 ≤ y) (hz : z ≠ 0) : x ^ z⁻¹ = y ↔ x = y ^ z := by\n  rw [← rpow_left_inj _ hy hz, rpow_inv_rpow hx hz]; positivity\n\n"}
{"name":"Real.eq_rpow_inv","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LE.le 0 x\nhy : LE.le 0 y\nhz : Ne z 0\n⊢ Iff (Eq x (HPow.hPow y (Inv.inv z))) (Eq (HPow.hPow x z) y)","decl":"lemma eq_rpow_inv (hx : 0 ≤ x) (hy : 0 ≤ y) (hz : z ≠ 0) : x = y ^ z⁻¹ ↔ x ^ z = y := by\n  rw [← rpow_left_inj hx _ hz, rpow_inv_rpow hy hz]; positivity\n\n"}
{"name":"Real.le_rpow_iff_log_le","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LT.lt 0 x\nhy : LT.lt 0 y\n⊢ Iff (LE.le x (HPow.hPow y z)) (LE.le (Real.log x) (HMul.hMul z (Real.log y)))","decl":"theorem le_rpow_iff_log_le (hx : 0 < x) (hy : 0 < y) : x ≤ y ^ z ↔ log x ≤ z * log y := by\n  rw [← log_le_log_iff hx (rpow_pos_of_pos hy z), log_rpow hy]\n\n"}
{"name":"Real.le_pow_iff_log_le","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nn : Nat\nhx : LT.lt 0 x\nhy : LT.lt 0 y\n⊢ Iff (LE.le x (HPow.hPow y n)) (LE.le (Real.log x) (HMul.hMul (↑n) (Real.log y)))","decl":"lemma le_pow_iff_log_le (hx : 0 < x) (hy : 0 < y) : x ≤ y ^ n ↔ log x ≤ n * log y :=\n  rpow_natCast _ _ ▸ le_rpow_iff_log_le hx hy\n\n"}
{"name":"Real.le_zpow_iff_log_le","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nn : Int\nhx : LT.lt 0 x\nhy : LT.lt 0 y\n⊢ Iff (LE.le x (HPow.hPow y n)) (LE.le (Real.log x) (HMul.hMul (↑n) (Real.log y)))","decl":"lemma le_zpow_iff_log_le {n : ℤ} (hx : 0 < x) (hy : 0 < y) : x ≤ y ^ n ↔ log x ≤ n * log y :=\n  rpow_intCast _ _ ▸ le_rpow_iff_log_le hx hy\n\n"}
{"name":"Real.le_rpow_of_log_le","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhy : LT.lt 0 y\nh : LE.le (Real.log x) (HMul.hMul z (Real.log y))\n⊢ LE.le x (HPow.hPow y z)","decl":"lemma le_rpow_of_log_le (hy : 0 < y) (h : log x ≤ z * log y) : x ≤ y ^ z := by\n  obtain hx | hx := le_or_lt x 0\n  · exact hx.trans (rpow_pos_of_pos hy _).le\n  · exact (le_rpow_iff_log_le hx hy).2 h\n\n"}
{"name":"Real.le_pow_of_log_le","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nn : Nat\nhy : LT.lt 0 y\nh : LE.le (Real.log x) (HMul.hMul (↑n) (Real.log y))\n⊢ LE.le x (HPow.hPow y n)","decl":"lemma le_pow_of_log_le (hy : 0 < y) (h : log x ≤ n * log y) : x ≤ y ^ n :=\n  rpow_natCast _ _ ▸ le_rpow_of_log_le hy h\n\n"}
{"name":"Real.le_zpow_of_log_le","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nn : Int\nhy : LT.lt 0 y\nh : LE.le (Real.log x) (HMul.hMul (↑n) (Real.log y))\n⊢ LE.le x (HPow.hPow y n)","decl":"lemma le_zpow_of_log_le {n : ℤ} (hy : 0 < y) (h : log x ≤ n * log y) : x ≤ y ^ n :=\n  rpow_intCast _ _ ▸ le_rpow_of_log_le hy h\n\n"}
{"name":"Real.lt_rpow_iff_log_lt","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LT.lt 0 x\nhy : LT.lt 0 y\n⊢ Iff (LT.lt x (HPow.hPow y z)) (LT.lt (Real.log x) (HMul.hMul z (Real.log y)))","decl":"theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ log x < z * log y := by\n  rw [← log_lt_log_iff hx (rpow_pos_of_pos hy z), log_rpow hy]\n\n"}
{"name":"Real.lt_pow_iff_log_lt","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nn : Nat\nhx : LT.lt 0 x\nhy : LT.lt 0 y\n⊢ Iff (LT.lt x (HPow.hPow y n)) (LT.lt (Real.log x) (HMul.hMul (↑n) (Real.log y)))","decl":"lemma lt_pow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ n ↔ log x < n * log y :=\n  rpow_natCast _ _ ▸ lt_rpow_iff_log_lt hx hy\n\n"}
{"name":"Real.lt_zpow_iff_log_lt","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nn : Int\nhx : LT.lt 0 x\nhy : LT.lt 0 y\n⊢ Iff (LT.lt x (HPow.hPow y n)) (LT.lt (Real.log x) (HMul.hMul (↑n) (Real.log y)))","decl":"lemma lt_zpow_iff_log_lt {n : ℤ} (hx : 0 < x) (hy : 0 < y) : x < y ^ n ↔ log x < n * log y :=\n  rpow_intCast _ _ ▸ lt_rpow_iff_log_lt hx hy\n\n"}
{"name":"Real.lt_rpow_of_log_lt","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhy : LT.lt 0 y\nh : LT.lt (Real.log x) (HMul.hMul z (Real.log y))\n⊢ LT.lt x (HPow.hPow y z)","decl":"lemma lt_rpow_of_log_lt (hy : 0 < y) (h : log x < z * log y) : x < y ^ z := by\n  obtain hx | hx := le_or_lt x 0\n  · exact hx.trans_lt (rpow_pos_of_pos hy _)\n  · exact (lt_rpow_iff_log_lt hx hy).2 h\n\n"}
{"name":"Real.lt_pow_of_log_lt","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nn : Nat\nhy : LT.lt 0 y\nh : LT.lt (Real.log x) (HMul.hMul (↑n) (Real.log y))\n⊢ LT.lt x (HPow.hPow y n)","decl":"lemma lt_pow_of_log_lt (hy : 0 < y) (h : log x < n * log y) : x < y ^ n :=\n  rpow_natCast _ _ ▸ lt_rpow_of_log_lt hy h\n\n"}
{"name":"Real.lt_zpow_of_log_lt","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nn : Int\nhy : LT.lt 0 y\nh : LT.lt (Real.log x) (HMul.hMul (↑n) (Real.log y))\n⊢ LT.lt x (HPow.hPow y n)","decl":"lemma lt_zpow_of_log_lt {n : ℤ} (hy : 0 < y) (h : log x < n * log y) : x < y ^ n :=\n  rpow_intCast _ _ ▸ lt_rpow_of_log_lt hy h\n\n"}
{"name":"Real.rpow_le_iff_le_log","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LT.lt 0 x\nhy : LT.lt 0 y\n⊢ Iff (LE.le (HPow.hPow x z) y) (LE.le (HMul.hMul z (Real.log x)) (Real.log y))","decl":"lemma rpow_le_iff_le_log (hx : 0 < x) (hy : 0 < y) : x ^ z ≤ y ↔ z * log x ≤ log y := by\n  rw [← log_le_log_iff (rpow_pos_of_pos hx _) hy, log_rpow hx]\n\n"}
{"name":"Real.pow_le_iff_le_log","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nn : Nat\nhx : LT.lt 0 x\nhy : LT.lt 0 y\n⊢ Iff (LE.le (HPow.hPow x n) y) (LE.le (HMul.hMul (↑n) (Real.log x)) (Real.log y))","decl":"lemma pow_le_iff_le_log (hx : 0 < x) (hy : 0 < y) : x ^ n ≤ y ↔ n * log x ≤ log y := by\n  rw [← rpow_le_iff_le_log hx hy, rpow_natCast]\n\n"}
{"name":"Real.zpow_le_iff_le_log","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nn : Int\nhx : LT.lt 0 x\nhy : LT.lt 0 y\n⊢ Iff (LE.le (HPow.hPow x n) y) (LE.le (HMul.hMul (↑n) (Real.log x)) (Real.log y))","decl":"lemma zpow_le_iff_le_log {n : ℤ} (hx : 0 < x) (hy : 0 < y) : x ^ n ≤ y ↔ n * log x ≤ log y := by\n  rw [← rpow_le_iff_le_log hx hy, rpow_intCast]\n\n"}
{"name":"Real.le_log_of_rpow_le","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LT.lt 0 x\nh : LE.le (HPow.hPow x z) y\n⊢ LE.le (HMul.hMul z (Real.log x)) (Real.log y)","decl":"lemma le_log_of_rpow_le (hx : 0 < x) (h : x ^ z ≤ y) : z * log x ≤ log y :=\n  log_rpow hx _ ▸ log_le_log (by positivity) h\n\n"}
{"name":"Real.le_log_of_pow_le","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nn : Nat\nhx : LT.lt 0 x\nh : LE.le (HPow.hPow x n) y\n⊢ LE.le (HMul.hMul (↑n) (Real.log x)) (Real.log y)","decl":"lemma le_log_of_pow_le (hx : 0 < x) (h : x ^ n ≤ y) : n * log x ≤ log y :=\n  le_log_of_rpow_le hx (rpow_natCast _ _ ▸ h)\n\n"}
{"name":"Real.le_log_of_zpow_le","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nn : Int\nhx : LT.lt 0 x\nh : LE.le (HPow.hPow x n) y\n⊢ LE.le (HMul.hMul (↑n) (Real.log x)) (Real.log y)","decl":"lemma le_log_of_zpow_le {n : ℤ} (hx : 0 < x) (h : x ^ n ≤ y) : n * log x ≤ log y :=\n  le_log_of_rpow_le hx (rpow_intCast _ _ ▸ h)\n\n"}
{"name":"Real.rpow_le_of_le_log","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhy : LT.lt 0 y\nh : LE.le (Real.log x) (HMul.hMul z (Real.log y))\n⊢ LE.le x (HPow.hPow y z)","decl":"lemma rpow_le_of_le_log (hy : 0 < y) (h : log x ≤ z * log y) : x ≤ y ^ z := by\n  obtain hx | hx := le_or_lt x 0\n  · exact hx.trans (rpow_pos_of_pos hy _).le\n  · exact (le_rpow_iff_log_le hx hy).2 h\n\n"}
{"name":"Real.pow_le_of_le_log","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nn : Nat\nhy : LT.lt 0 y\nh : LE.le (Real.log x) (HMul.hMul (↑n) (Real.log y))\n⊢ LE.le x (HPow.hPow y n)","decl":"lemma pow_le_of_le_log (hy : 0 < y) (h : log x ≤ n * log y) : x ≤ y ^ n :=\n  rpow_natCast _ _ ▸ rpow_le_of_le_log hy h\n\n"}
{"name":"Real.zpow_le_of_le_log","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nn : Int\nhy : LT.lt 0 y\nh : LE.le (Real.log x) (HMul.hMul (↑n) (Real.log y))\n⊢ LE.le x (HPow.hPow y n)","decl":"lemma zpow_le_of_le_log {n : ℤ} (hy : 0 < y) (h : log x ≤ n * log y) : x ≤ y ^ n :=\n  rpow_intCast _ _ ▸ rpow_le_of_le_log hy h\n\n"}
{"name":"Real.rpow_lt_iff_lt_log","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LT.lt 0 x\nhy : LT.lt 0 y\n⊢ Iff (LT.lt (HPow.hPow x z) y) (LT.lt (HMul.hMul z (Real.log x)) (Real.log y))","decl":"lemma rpow_lt_iff_lt_log (hx : 0 < x) (hy : 0 < y) : x ^ z < y ↔ z * log x < log y := by\n  rw [← log_lt_log_iff (rpow_pos_of_pos hx _) hy, log_rpow hx]\n\n"}
{"name":"Real.pow_lt_iff_lt_log","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nn : Nat\nhx : LT.lt 0 x\nhy : LT.lt 0 y\n⊢ Iff (LT.lt (HPow.hPow x n) y) (LT.lt (HMul.hMul (↑n) (Real.log x)) (Real.log y))","decl":"lemma pow_lt_iff_lt_log (hx : 0 < x) (hy : 0 < y) : x ^ n < y ↔ n * log x < log y := by\n  rw [← rpow_lt_iff_lt_log hx hy, rpow_natCast]\n\n"}
{"name":"Real.zpow_lt_iff_lt_log","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nn : Int\nhx : LT.lt 0 x\nhy : LT.lt 0 y\n⊢ Iff (LT.lt (HPow.hPow x n) y) (LT.lt (HMul.hMul (↑n) (Real.log x)) (Real.log y))","decl":"lemma zpow_lt_iff_lt_log {n : ℤ} (hx : 0 < x) (hy : 0 < y) : x ^ n < y ↔ n * log x < log y := by\n  rw [← rpow_lt_iff_lt_log hx hy, rpow_intCast]\n\n"}
{"name":"Real.lt_log_of_rpow_lt","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx : LT.lt 0 x\nh : LT.lt (HPow.hPow x z) y\n⊢ LT.lt (HMul.hMul z (Real.log x)) (Real.log y)","decl":"lemma lt_log_of_rpow_lt (hx : 0 < x) (h : x ^ z < y) : z * log x < log y :=\n  log_rpow hx _ ▸ log_lt_log (by positivity) h\n\n"}
{"name":"Real.lt_log_of_pow_lt","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nn : Nat\nhx : LT.lt 0 x\nh : LT.lt (HPow.hPow x n) y\n⊢ LT.lt (HMul.hMul (↑n) (Real.log x)) (Real.log y)","decl":"lemma lt_log_of_pow_lt (hx : 0 < x) (h : x ^ n < y) : n * log x < log y :=\n  lt_log_of_rpow_lt hx (rpow_natCast _ _ ▸ h)\n\n"}
{"name":"Real.lt_log_of_zpow_lt","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nn : Int\nhx : LT.lt 0 x\nh : LT.lt (HPow.hPow x n) y\n⊢ LT.lt (HMul.hMul (↑n) (Real.log x)) (Real.log y)","decl":"lemma lt_log_of_zpow_lt {n : ℤ} (hx : 0 < x) (h : x ^ n < y) : n * log x < log y :=\n  lt_log_of_rpow_lt hx (rpow_intCast _ _ ▸ h)\n\n"}
{"name":"Real.rpow_lt_of_lt_log","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhy : LT.lt 0 y\nh : LT.lt (Real.log x) (HMul.hMul z (Real.log y))\n⊢ LT.lt x (HPow.hPow y z)","decl":"lemma rpow_lt_of_lt_log (hy : 0 < y) (h : log x < z * log y) : x < y ^ z := by\n  obtain hx | hx := le_or_lt x 0\n  · exact hx.trans_lt (rpow_pos_of_pos hy _)\n  · exact (lt_rpow_iff_log_lt hx hy).2 h\n\n"}
{"name":"Real.pow_lt_of_lt_log","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nn : Nat\nhy : LT.lt 0 y\nh : LT.lt (Real.log x) (HMul.hMul (↑n) (Real.log y))\n⊢ LT.lt x (HPow.hPow y n)","decl":"lemma pow_lt_of_lt_log (hy : 0 < y) (h : log x < n * log y) : x < y ^ n :=\n  rpow_natCast _ _ ▸ rpow_lt_of_lt_log hy h\n\n"}
{"name":"Real.zpow_lt_of_lt_log","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nn : Int\nhy : LT.lt 0 y\nh : LT.lt (Real.log x) (HMul.hMul (↑n) (Real.log y))\n⊢ LT.lt x (HPow.hPow y n)","decl":"lemma zpow_lt_of_lt_log {n : ℤ} (hy : 0 < y) (h : log x < n * log y) : x < y ^ n :=\n  rpow_intCast _ _ ▸ rpow_lt_of_lt_log hy h\n\n"}
{"name":"Real.rpow_le_one_iff_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y : Real\nhx : LT.lt 0 x\n⊢ Iff (LE.le (HPow.hPow x y) 1) (Or (And (LE.le 1 x) (LE.le y 0)) (And (LE.le x 1) (LE.le 0 y)))","decl":"theorem rpow_le_one_iff_of_pos (hx : 0 < x) : x ^ y ≤ 1 ↔ 1 ≤ x ∧ y ≤ 0 ∨ x ≤ 1 ∧ 0 ≤ y := by\n  rw [rpow_def_of_pos hx, exp_le_one_iff, mul_nonpos_iff, log_nonneg_iff hx, log_nonpos_iff hx.le]\n\n"}
{"name":"Real.abs_log_mul_self_rpow_lt","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x t : Real\nh1 : LT.lt 0 x\nh2 : LE.le x 1\nht : LT.lt 0 t\n⊢ LT.lt (abs (HMul.hMul (Real.log x) (HPow.hPow x t))) (HDiv.hDiv 1 t)","decl":"/-- Bound for `|log x * x ^ t|` in the interval `(0, 1]`, for positive real `t`. -/\ntheorem abs_log_mul_self_rpow_lt (x t : ℝ) (h1 : 0 < x) (h2 : x ≤ 1) (ht : 0 < t) :\n    |log x * x ^ t| < 1 / t := by\n  rw [lt_div_iff₀ ht]\n  have := abs_log_mul_self_lt (x ^ t) (rpow_pos_of_pos h1 t) (rpow_le_one h1.le h2 ht.le)\n  rwa [log_rpow h1, mul_assoc, abs_mul, abs_of_pos ht, mul_comm] at this\n\n"}
{"name":"Real.log_le_rpow_div","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x ε : Real\nhx : LE.le 0 x\nhε : LT.lt 0 ε\n⊢ LE.le (Real.log x) (HDiv.hDiv (HPow.hPow x ε) ε)","decl":"/-- `log x` is bounded above by a multiple of every power of `x` with positive exponent. -/\nlemma log_le_rpow_div {x ε : ℝ} (hx : 0 ≤ x) (hε : 0 < ε) : log x ≤ x ^ ε / ε := by\n  rcases hx.eq_or_lt with rfl | h\n  · rw [log_zero, zero_rpow hε.ne', zero_div]\n  rw [le_div_iff₀' hε]\n  exact (log_rpow h ε).symm.trans_le <| (log_le_sub_one_of_pos <| rpow_pos_of_pos h ε).trans\n    (sub_one_lt _).le\n\n"}
{"name":"Real.log_natCast_le_rpow_div","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"n : Nat\nε : Real\nhε : LT.lt 0 ε\n⊢ LE.le (Real.log ↑n) (HDiv.hDiv (HPow.hPow (↑n) ε) ε)","decl":"/-- The (real) logarithm of a natural number `n` is bounded by a multiple of every power of `n`\nwith positive exponent. -/\nlemma log_natCast_le_rpow_div (n : ℕ) {ε : ℝ} (hε : 0 < ε) : log n ≤ n ^ ε / ε :=\n  log_le_rpow_div n.cast_nonneg hε\n\n"}
{"name":"Real.strictMono_rpow_of_base_gt_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"b : Real\nhb : LT.lt 1 b\n⊢ StrictMono fun x => HPow.hPow b x","decl":"lemma strictMono_rpow_of_base_gt_one {b : ℝ} (hb : 1 < b) :\n    StrictMono (b ^ · : ℝ → ℝ) := by\n  simp_rw [Real.rpow_def_of_pos (zero_lt_one.trans hb)]\n  exact exp_strictMono.comp <| StrictMono.const_mul strictMono_id <| Real.log_pos hb\n\n"}
{"name":"Real.monotone_rpow_of_base_ge_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"b : Real\nhb : LE.le 1 b\n⊢ Monotone fun x => HPow.hPow b x","decl":"lemma monotone_rpow_of_base_ge_one {b : ℝ} (hb : 1 ≤ b) :\n    Monotone (b ^ · : ℝ → ℝ) := by\n  rcases lt_or_eq_of_le hb with hb | rfl\n  case inl => exact (strictMono_rpow_of_base_gt_one hb).monotone\n  case inr => intro _ _ _; simp\n\n"}
{"name":"Real.strictAnti_rpow_of_base_lt_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"b : Real\nhb₀ : LT.lt 0 b\nhb₁ : LT.lt b 1\n⊢ StrictAnti fun x => HPow.hPow b x","decl":"lemma strictAnti_rpow_of_base_lt_one {b : ℝ} (hb₀ : 0 < b) (hb₁ : b < 1) :\n    StrictAnti (b ^ · : ℝ → ℝ) := by\n  simp_rw [Real.rpow_def_of_pos hb₀]\n  exact exp_strictMono.comp_strictAnti <| StrictMono.const_mul_of_neg strictMono_id\n      <| Real.log_neg hb₀ hb₁\n\n"}
{"name":"Real.antitone_rpow_of_base_le_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"b : Real\nhb₀ : LT.lt 0 b\nhb₁ : LE.le b 1\n⊢ Antitone fun x => HPow.hPow b x","decl":"lemma antitone_rpow_of_base_le_one {b : ℝ} (hb₀ : 0 < b) (hb₁ : b ≤ 1) :\n    Antitone (b ^ · : ℝ → ℝ) := by\n  rcases lt_or_eq_of_le hb₁ with hb₁ | rfl\n  case inl => exact (strictAnti_rpow_of_base_lt_one hb₀ hb₁).antitone\n  case inr => intro _ _ _; simp\n\n"}
{"name":"Real.rpow_right_inj","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nhx₀ : LT.lt 0 x\nhx₁ : Ne x 1\n⊢ Iff (Eq (HPow.hPow x y) (HPow.hPow x z)) (Eq y z)","decl":"lemma rpow_right_inj (hx₀ : 0 < x) (hx₁ : x ≠ 1) : x ^ y = x ^ z ↔ y = z := by\n  refine ⟨fun H ↦ ?_, fun H ↦ by rw [H]⟩\n  rcases hx₁.lt_or_lt with h | h\n  · exact (strictAnti_rpow_of_base_lt_one hx₀ h).injective H\n  · exact (strictMono_rpow_of_base_gt_one h).injective H\n\n"}
{"name":"Real.rpow_le_rpow_of_exponent_le_or_ge","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x y z : Real\nh : Or (And (LE.le 1 x) (LE.le y z)) (And (LT.lt 0 x) (And (LE.le x 1) (LE.le z y)))\n⊢ LE.le (HPow.hPow x y) (HPow.hPow x z)","decl":"/-- Guessing rule for the `bound` tactic: when trying to prove `x ^ y ≤ x ^ z`, we can either assume\n`1 ≤ x` or `0 < x ≤ 1`. -/\n@[bound] lemma rpow_le_rpow_of_exponent_le_or_ge {x y z : ℝ}\n    (h : 1 ≤ x ∧ y ≤ z ∨ 0 < x ∧ x ≤ 1 ∧ z ≤ y) : x ^ y ≤ x ^ z := by\n  rcases h with ⟨x1, yz⟩ | ⟨x0, x1, zy⟩\n  · exact Real.rpow_le_rpow_of_exponent_le x1 yz\n  · exact Real.rpow_le_rpow_of_exponent_ge x0 x1 zy\n\n"}
{"name":"Complex.norm_prime_cpow_le_one_half","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"p : Nat.Primes\ns : Complex\nhs : LT.lt 1 s.re\n⊢ LE.le (Norm.norm (HPow.hPow (↑↑p) (Neg.neg s))) (1 / 2)","decl":"lemma norm_prime_cpow_le_one_half (p : Nat.Primes) {s : ℂ} (hs : 1 < s.re) :\n    ‖(p : ℂ) ^ (-s)‖ ≤ 1 / 2 := by\n  rw [norm_natCast_cpow_of_re_ne_zero p <| by rw [neg_re]; linarith only [hs]]\n  refine (Real.rpow_le_rpow_of_nonpos zero_lt_two (Nat.cast_le.mpr p.prop.two_le) <|\n    by rw [neg_re]; linarith only [hs]).trans ?_\n  rw [one_div, ← Real.rpow_neg_one]\n  exact Real.rpow_le_rpow_of_exponent_le one_le_two <| (neg_lt_neg hs).le\n\n"}
{"name":"Complex.one_sub_prime_cpow_ne_zero","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"p : Nat\nhp : Nat.Prime p\ns : Complex\nhs : LT.lt 1 s.re\n⊢ Ne (HSub.hSub 1 (HPow.hPow (↑p) (Neg.neg s))) 0","decl":"lemma one_sub_prime_cpow_ne_zero {p : ℕ} (hp : p.Prime) {s : ℂ} (hs : 1 < s.re) :\n    1 - (p : ℂ) ^ (-s) ≠ 0 := by\n  refine sub_ne_zero_of_ne fun H ↦ ?_\n  have := norm_prime_cpow_le_one_half ⟨p, hp⟩ hs\n  simp only at this\n  rw [← H, norm_one] at this\n  norm_num at this\n\n"}
{"name":"Complex.norm_natCast_cpow_le_norm_natCast_cpow_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"n : Nat\nhn : LT.lt 0 n\nw z : Complex\nh : LE.le w.re z.re\n⊢ LE.le (Norm.norm (HPow.hPow (↑n) w)) (Norm.norm (HPow.hPow (↑n) z))","decl":"lemma norm_natCast_cpow_le_norm_natCast_cpow_of_pos {n : ℕ} (hn : 0 < n) {w z : ℂ}\n    (h : w.re ≤ z.re) :\n    ‖(n : ℂ) ^ w‖ ≤ ‖(n : ℂ) ^ z‖ := by\n  simp_rw [norm_natCast_cpow_of_pos hn]\n  exact Real.rpow_le_rpow_of_exponent_le (by exact_mod_cast hn) h\n\n"}
{"name":"Complex.norm_natCast_cpow_le_norm_natCast_cpow_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"n : Nat\nhn : LT.lt 1 n\nw z : Complex\n⊢ Iff (LE.le (Norm.norm (HPow.hPow (↑n) w)) (Norm.norm (HPow.hPow (↑n) z))) (LE.le w.re z.re)","decl":"lemma norm_natCast_cpow_le_norm_natCast_cpow_iff {n : ℕ} (hn : 1 < n) {w z : ℂ} :\n    ‖(n : ℂ) ^ w‖ ≤ ‖(n : ℂ) ^ z‖ ↔ w.re ≤ z.re := by\n  simp_rw [norm_natCast_cpow_of_pos (Nat.zero_lt_of_lt hn),\n    Real.rpow_le_rpow_left_iff (Nat.one_lt_cast.mpr hn)]\n\n"}
{"name":"Complex.norm_log_natCast_le_rpow_div","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"n : Nat\nε : Real\nhε : LT.lt 0 ε\n⊢ LE.le (Norm.norm (Complex.log ↑n)) (HDiv.hDiv (HPow.hPow (↑n) ε) ε)","decl":"lemma norm_log_natCast_le_rpow_div (n : ℕ) {ε : ℝ} (hε : 0 < ε) : ‖log n‖ ≤ n ^ ε / ε := by\n  rcases n.eq_zero_or_pos with rfl | h\n  · rw [Nat.cast_zero, Nat.cast_zero, log_zero, norm_zero, Real.zero_rpow hε.ne', zero_div]\n  rw [norm_eq_abs, ← natCast_log, abs_ofReal,\n    _root_.abs_of_nonneg <| Real.log_nonneg <| by exact_mod_cast Nat.one_le_of_lt h.lt]\n  exact Real.log_natCast_le_rpow_div n hε\n\n"}
{"name":"Asymptotics.IsBigO.mul_atTop_rpow_of_isBigO_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"E : Type u_1\ninst✝ : SeminormedRing E\na b c : Real\nf g : Real → E\nhf : Asymptotics.IsBigO Filter.atTop f fun t => HPow.hPow t a\nhg : Asymptotics.IsBigO Filter.atTop g fun t => HPow.hPow t b\nh : LE.le (HAdd.hAdd a b) c\n⊢ Asymptotics.IsBigO Filter.atTop (HMul.hMul f g) fun t => HPow.hPow t c","decl":"theorem IsBigO.mul_atTop_rpow_of_isBigO_rpow {f g : ℝ → E}\n    (hf : f =O[atTop] fun t ↦ (t : ℝ) ^ a) (hg : g =O[atTop] fun t ↦ (t : ℝ) ^ b)\n    (h : a + b ≤ c) :\n    (f * g) =O[atTop] fun t ↦ (t : ℝ) ^ c := by\n  refine (hf.mul hg).trans (Eventually.isBigO ?_)\n  filter_upwards [eventually_ge_atTop 1] with t ht\n  rw [← Real.rpow_add (zero_lt_one.trans_le ht), Real.norm_of_nonneg (Real.rpow_nonneg\n    (zero_le_one.trans ht) (a + b))]\n  exact Real.rpow_le_rpow_of_exponent_le ht h\n\n"}
{"name":"Asymptotics.IsBigO.mul_atTop_rpow_natCast_of_isBigO_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"E : Type u_1\ninst✝ : SeminormedRing E\na b c : Real\nf g : Nat → E\nhf : Asymptotics.IsBigO Filter.atTop f fun n => HPow.hPow (↑n) a\nhg : Asymptotics.IsBigO Filter.atTop g fun n => HPow.hPow (↑n) b\nh : LE.le (HAdd.hAdd a b) c\n⊢ Asymptotics.IsBigO Filter.atTop (HMul.hMul f g) fun n => HPow.hPow (↑n) c","decl":"theorem IsBigO.mul_atTop_rpow_natCast_of_isBigO_rpow {f g : ℕ → E}\n    (hf : f =O[atTop] fun n ↦ (n : ℝ) ^ a) (hg : g =O[atTop] fun n ↦ (n : ℝ) ^ b)\n    (h : a + b ≤ c) :\n    (f * g) =O[atTop] fun n ↦ (n : ℝ) ^ c := by\n  refine (hf.mul hg).trans (Eventually.isBigO ?_)\n  filter_upwards [eventually_ge_atTop 1] with t ht\n  replace ht : 1 ≤ (t : ℝ) := Nat.one_le_cast.mpr ht\n  rw [← Real.rpow_add (zero_lt_one.trans_le ht), Real.norm_of_nonneg (Real.rpow_nonneg\n    (zero_le_one.trans ht) (a + b))]\n  exact Real.rpow_le_rpow_of_exponent_le ht h\n\n"}
{"name":"Real.sqrt_eq_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Real\n⊢ Eq x.sqrt (HPow.hPow x (1 / 2))","decl":"theorem sqrt_eq_rpow (x : ℝ) : √x = x ^ (1 / (2 : ℝ)) := by\n  obtain h | h := le_or_lt 0 x\n  · rw [← mul_self_inj_of_nonneg (sqrt_nonneg _) (rpow_nonneg h _), mul_self_sqrt h, ← sq,\n      ← rpow_natCast, ← rpow_mul h]\n    norm_num\n  · have : 1 / (2 : ℝ) * π = π / (2 : ℝ) := by ring\n    rw [sqrt_eq_zero_of_nonpos h.le, rpow_def_of_neg h, this, cos_pi_div_two, mul_zero]\n\n"}
{"name":"Real.rpow_div_two_eq_sqrt","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x r : Real\nhx : LE.le 0 x\n⊢ Eq (HPow.hPow x (HDiv.hDiv r 2)) (HPow.hPow x.sqrt r)","decl":"theorem rpow_div_two_eq_sqrt {x : ℝ} (r : ℝ) (hx : 0 ≤ x) : x ^ (r / 2) = √x ^ r := by\n  rw [sqrt_eq_rpow, ← rpow_mul hx]\n  congr\n  ring\n\n"}
{"name":"Complex.cpow_inv_two_re","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Complex\n⊢ Eq (HPow.hPow x (Inv.inv 2)).re (HDiv.hDiv (HAdd.hAdd (Complex.abs x) x.re) 2).sqrt","decl":"lemma cpow_inv_two_re (x : ℂ) : (x ^ (2⁻¹ : ℂ)).re = sqrt ((abs x + x.re) / 2) := by\n  rw [← ofReal_ofNat, ← ofReal_inv, cpow_ofReal_re, ← div_eq_mul_inv, ← one_div,\n    ← Real.sqrt_eq_rpow, cos_half, ← sqrt_mul, ← mul_div_assoc, mul_add, mul_one, abs_mul_cos_arg]\n  exacts [abs.nonneg _, (neg_pi_lt_arg _).le, arg_le_pi _]\n\n"}
{"name":"Complex.cpow_inv_two_im_eq_sqrt","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Complex\nhx : LE.le 0 x.im\n⊢ Eq (HPow.hPow x (Inv.inv 2)).im (HDiv.hDiv (HSub.hSub (Complex.abs x) x.re) 2).sqrt","decl":"lemma cpow_inv_two_im_eq_sqrt {x : ℂ} (hx : 0 ≤ x.im) :\n    (x ^ (2⁻¹ : ℂ)).im = sqrt ((abs x - x.re) / 2) := by\n  rw [← ofReal_ofNat, ← ofReal_inv, cpow_ofReal_im, ← div_eq_mul_inv, ← one_div,\n    ← Real.sqrt_eq_rpow, sin_half_eq_sqrt, ← sqrt_mul (abs.nonneg _), ← mul_div_assoc, mul_sub,\n    mul_one, abs_mul_cos_arg]\n  · rwa [arg_nonneg_iff]\n  · linarith [pi_pos, arg_le_pi x]\n\n"}
{"name":"Complex.cpow_inv_two_im_eq_neg_sqrt","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Complex\nhx : LT.lt x.im 0\n⊢ Eq (HPow.hPow x (Inv.inv 2)).im (Neg.neg (HDiv.hDiv (HSub.hSub (Complex.abs x) x.re) 2).sqrt)","decl":"lemma cpow_inv_two_im_eq_neg_sqrt {x : ℂ} (hx : x.im < 0) :\n    (x ^ (2⁻¹ : ℂ)).im = -sqrt ((abs x - x.re) / 2) := by\n  rw [← ofReal_ofNat, ← ofReal_inv, cpow_ofReal_im, ← div_eq_mul_inv, ← one_div,\n    ← Real.sqrt_eq_rpow, sin_half_eq_neg_sqrt, mul_neg, ← sqrt_mul (abs.nonneg _),\n    ← mul_div_assoc, mul_sub, mul_one, abs_mul_cos_arg]\n  · linarith [pi_pos, neg_pi_lt_arg x]\n  · exact (arg_neg_iff.2 hx).le\n\n"}
{"name":"Complex.abs_cpow_inv_two_im","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"x : Complex\n⊢ Eq (abs (HPow.hPow x (Inv.inv 2)).im) (HDiv.hDiv (HSub.hSub (Complex.abs x) x.re) 2).sqrt","decl":"lemma abs_cpow_inv_two_im (x : ℂ) : |(x ^ (2⁻¹ : ℂ)).im| = sqrt ((abs x - x.re) / 2) := by\n  rw [← ofReal_ofNat, ← ofReal_inv, cpow_ofReal_im, ← div_eq_mul_inv, ← one_div,\n    ← Real.sqrt_eq_rpow, _root_.abs_mul, _root_.abs_of_nonneg (sqrt_nonneg _), abs_sin_half,\n    ← sqrt_mul (abs.nonneg _), ← mul_div_assoc, mul_sub, mul_one, abs_mul_cos_arg]\n\n"}
{"name":"Complex.inv_natCast_cpow_ofReal_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"n : Nat\nhn : Ne n 0\nx : Real\n⊢ LT.lt 0 (Inv.inv (HPow.hPow ↑n ↑x))","decl":"open scoped ComplexOrder in\nlemma inv_natCast_cpow_ofReal_pos {n : ℕ} (hn : n ≠ 0) (x : ℝ) :\n    0 < ((n : ℂ) ^ (x : ℂ))⁻¹ := by\n  refine RCLike.inv_pos_of_pos ?_\n  rw [show (n : ℂ) ^ (x : ℂ) = (n : ℝ) ^ (x : ℂ) from rfl, ← ofReal_cpow n.cast_nonneg']\n  positivity\n\n"}
{"name":"Mathlib.Meta.NormNum.isNat_rpow_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"a b : Real\nnb ne : Nat\npb : Mathlib.Meta.NormNum.IsNat b nb\npe' : Mathlib.Meta.NormNum.IsNat (HPow.hPow a nb) ne\n⊢ Mathlib.Meta.NormNum.IsNat (HPow.hPow a b) ne","decl":"theorem isNat_rpow_pos {a b : ℝ} {nb ne : ℕ}\n    (pb : IsNat b nb) (pe' : IsNat (a ^ nb) ne) :\n    IsNat (a ^ b) ne := by\n  rwa [pb.out, rpow_natCast]\n\n"}
{"name":"Mathlib.Meta.NormNum.isNat_rpow_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"a b : Real\nnb ne : Nat\npb : Mathlib.Meta.NormNum.IsInt b (Int.negOfNat nb)\npe' : Mathlib.Meta.NormNum.IsNat (HPow.hPow a (Int.negOfNat nb)) ne\n⊢ Mathlib.Meta.NormNum.IsNat (HPow.hPow a b) ne","decl":"theorem isNat_rpow_neg {a b : ℝ} {nb ne : ℕ}\n    (pb : IsInt b (Int.negOfNat nb)) (pe' : IsNat (a ^ (Int.negOfNat nb)) ne) :\n    IsNat (a ^ b) ne := by\n  rwa [pb.out, Real.rpow_intCast]\n\n"}
{"name":"Mathlib.Meta.NormNum.isInt_rpow_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"a b : Real\nnb ne : Nat\npb : Mathlib.Meta.NormNum.IsNat b nb\npe' : Mathlib.Meta.NormNum.IsInt (HPow.hPow a nb) (Int.negOfNat ne)\n⊢ Mathlib.Meta.NormNum.IsInt (HPow.hPow a b) (Int.negOfNat ne)","decl":"theorem isInt_rpow_pos {a b : ℝ} {nb ne : ℕ}\n    (pb : IsNat b nb) (pe' : IsInt (a ^ nb) (Int.negOfNat ne)) :\n    IsInt (a ^ b) (Int.negOfNat ne) := by\n  rwa [pb.out, rpow_natCast]\n\n"}
{"name":"Mathlib.Meta.NormNum.isInt_rpow_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"a b : Real\nnb ne : Nat\npb : Mathlib.Meta.NormNum.IsInt b (Int.negOfNat nb)\npe' : Mathlib.Meta.NormNum.IsInt (HPow.hPow a (Int.negOfNat nb)) (Int.negOfNat ne)\n⊢ Mathlib.Meta.NormNum.IsInt (HPow.hPow a b) (Int.negOfNat ne)","decl":"theorem isInt_rpow_neg {a b : ℝ} {nb ne : ℕ}\n    (pb : IsInt b (Int.negOfNat nb)) (pe' : IsInt (a ^ (Int.negOfNat nb)) (Int.negOfNat ne)) :\n    IsInt (a ^ b) (Int.negOfNat ne) := by\n  rwa [pb.out, Real.rpow_intCast]\n\n"}
{"name":"Mathlib.Meta.NormNum.isRat_rpow_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"a b : Real\nnb : Nat\nnum : Int\nden : Nat\npb : Mathlib.Meta.NormNum.IsNat b nb\npe' : Mathlib.Meta.NormNum.IsRat (HPow.hPow a nb) num den\n⊢ Mathlib.Meta.NormNum.IsRat (HPow.hPow a b) num den","decl":"theorem isRat_rpow_pos {a b : ℝ} {nb : ℕ}\n    {num : ℤ} {den : ℕ}\n    (pb : IsNat b nb) (pe' : IsRat (a ^ nb) num den) :\n    IsRat (a ^ b) num den := by\n  rwa [pb.out, rpow_natCast]\n\n"}
{"name":"Mathlib.Meta.NormNum.isRat_rpow_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Real","initialProofState":"a b : Real\nnb : Nat\nnum : Int\nden : Nat\npb : Mathlib.Meta.NormNum.IsInt b (Int.negOfNat nb)\npe' : Mathlib.Meta.NormNum.IsRat (HPow.hPow a (Int.negOfNat nb)) num den\n⊢ Mathlib.Meta.NormNum.IsRat (HPow.hPow a b) num den","decl":"theorem isRat_rpow_neg {a b : ℝ} {nb : ℕ}\n    {num : ℤ} {den : ℕ}\n    (pb : IsInt b (Int.negOfNat nb)) (pe' : IsRat (a ^ (Int.negOfNat nb)) num den) :\n    IsRat (a ^ b) num den := by\n  rwa [pb.out, Real.rpow_intCast]\n\n"}
