{"name":"small_subset","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\ns t : Set Œ±\nhts : HasSubset.Subset t s\ninst‚úù : Small.{u, u1} ‚Üës\n‚ä¢ Small.{u, u1} ‚Üët","decl":"theorem small_subset {s t : Set Œ±} (hts : t ‚äÜ s) [Small.{u} s] : Small.{u} t :=\n  small_of_injective (Set.inclusion_injective hts)\n\n"}
{"name":"small_powerset","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\ns : Set Œ±\ninst‚úù : Small.{u, u1} ‚Üës\n‚ä¢ Small.{u, u1} ‚Üës.powerset","decl":"instance small_powerset (s : Set Œ±) [Small.{u} s] : Small.{u} (ùí´ s) :=\n  small_map (Equiv.Set.powerset s)\n\n"}
{"name":"small_setProd","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\nŒ≤ : Type u2\ns : Set Œ±\nt : Set Œ≤\ninst‚úù¬π : Small.{u, u1} ‚Üës\ninst‚úù : Small.{u, u2} ‚Üët\n‚ä¢ Small.{u, max u1 u2} ‚Üë(SProd.sprod s t)","decl":"instance small_setProd (s : Set Œ±) (t : Set Œ≤) [Small.{u} s] [Small.{u} t] :\n    Small.{u} (s √óÀ¢ t : Set (Œ± √ó Œ≤)) :=\n  small_of_injective (Equiv.Set.prod s t).injective\n\n"}
{"name":"small_setPi","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\nŒ≤ : Œ± ‚Üí Type u2\ns : (a : Œ±) ‚Üí Set (Œ≤ a)\ninst‚úù¬π : Small.{u, u1} Œ±\ninst‚úù : ‚àÄ (a : Œ±), Small.{u, u2} ‚Üë(s a)\n‚ä¢ Small.{u, max u1 u2} ‚Üë(Set.univ.pi s)","decl":"instance small_setPi {Œ≤ : Œ± ‚Üí Type u2} (s : (a : Œ±) ‚Üí Set (Œ≤ a))\n    [Small.{u} Œ±] [‚àÄ a, Small.{u} (s a)] : Small.{u} (Set.pi Set.univ s) :=\n  small_of_injective (Equiv.Set.univPi s).injective\n\n"}
{"name":"small_range","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\nŒ≤ : Type u2\nf : Œ± ‚Üí Œ≤\ninst‚úù : Small.{u, u1} Œ±\n‚ä¢ Small.{u, u2} ‚Üë(Set.range f)","decl":"instance small_range (f : Œ± ‚Üí Œ≤) [Small.{u} Œ±] :\n    Small.{u} (Set.range f) :=\n  small_of_surjective Set.surjective_onto_range\n\n"}
{"name":"small_image","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\nŒ≤ : Type u2\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\ninst‚úù : Small.{u, u1} ‚Üës\n‚ä¢ Small.{u, u2} ‚Üë(Set.image f s)","decl":"instance small_image (f : Œ± ‚Üí Œ≤) (s : Set Œ±) [Small.{u} s] :\n    Small.{u} (f '' s) :=\n  small_of_surjective Set.surjective_onto_image\n\n"}
{"name":"small_image2","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\nŒ≤ : Type u2\nŒ≥ : Type u3\nf : Œ± ‚Üí Œ≤ ‚Üí Œ≥\ns : Set Œ±\nt : Set Œ≤\ninst‚úù¬π : Small.{u, u1} ‚Üës\ninst‚úù : Small.{u, u2} ‚Üët\n‚ä¢ Small.{u, u3} ‚Üë(Set.image2 f s t)","decl":"instance small_image2 (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (s : Set Œ±) (t : Set Œ≤) [Small.{u} s] [Small.{u} t] :\n    Small.{u} (Set.image2 f s t) := by\n  rw [‚Üê Set.image_uncurry_prod]\n  infer_instance\n\n"}
{"name":"small_univ_iff","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\n‚ä¢ Iff (Small.{u, u1} ‚ÜëSet.univ) (Small.{u, u1} Œ±)","decl":"theorem small_univ_iff : Small.{u} (@Set.univ Œ±) ‚Üî Small.{u} Œ± :=\n  small_congr <| Equiv.Set.univ Œ±\n\n"}
{"name":"small_univ","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\nh : Small.{u, u1} Œ±\n‚ä¢ Small.{u, u1} ‚ÜëSet.univ","decl":"instance small_univ [h : Small.{u} Œ±] : Small.{u} (@Set.univ Œ±) :=\n  small_univ_iff.2 h\n\n"}
{"name":"small_union","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\ns t : Set Œ±\ninst‚úù¬π : Small.{u, u1} ‚Üës\ninst‚úù : Small.{u, u1} ‚Üët\n‚ä¢ Small.{u, u1} ‚Üë(Union.union s t)","decl":"instance small_union (s t : Set Œ±) [Small.{u} s] [Small.{u} t] :\n    Small.{u} (s ‚à™ t : Set Œ±) := by\n  rw [‚Üê Subtype.range_val (s := s), ‚Üê Subtype.range_val (s := t), ‚Üê Set.Sum.elim_range]\n  infer_instance\n\n"}
{"name":"small_iUnion","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\nŒπ : Type u4\ninst‚úù¬π : Small.{u, u4} Œπ\ns : Œπ ‚Üí Set Œ±\ninst‚úù : ‚àÄ (i : Œπ), Small.{u, u1} ‚Üë(s i)\n‚ä¢ Small.{u, u1} ‚Üë(Set.iUnion fun i => s i)","decl":"instance small_iUnion [Small.{u} Œπ] (s : Œπ ‚Üí Set Œ±)\n    [‚àÄ i, Small.{u} (s i)] : Small.{u} (‚ãÉ i, s i) :=\n  small_of_surjective <| Set.sigmaToiUnion_surjective _\n\n"}
{"name":"small_sUnion","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\ns : Set (Set Œ±)\ninst‚úù¬π : Small.{u, u1} ‚Üës\ninst‚úù : ‚àÄ (t : ‚Üës), Small.{u, u1} ‚Üë‚Üët\n‚ä¢ Small.{u, u1} ‚Üës.sUnion","decl":"instance small_sUnion (s : Set (Set Œ±)) [Small.{u} s] [‚àÄ t : s, Small.{u} t] :\n    Small.{u} (‚ãÉ‚ÇÄ s) :=\n  Set.sUnion_eq_iUnion ‚ñ∏ small_iUnion _\n\n"}
{"name":"small_biUnion","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\nŒπ : Type u4\ns : Set Œπ\ninst‚úù¬π : Small.{u, u4} ‚Üës\nf : (i : Œπ) ‚Üí Membership.mem s i ‚Üí Set Œ±\ninst‚úù : ‚àÄ (i : Œπ) (hi : Membership.mem s i), Small.{u, u1} ‚Üë(f i hi)\n‚ä¢ Small.{u, u1} ‚Üë(Set.iUnion fun i => Set.iUnion fun hi => f i hi)","decl":"instance small_biUnion (s : Set Œπ) [Small.{u} s]\n    (f : (i : Œπ) ‚Üí i ‚àà s ‚Üí Set Œ±) [‚àÄ i hi, Small.{u} (f i hi)] : Small.{u} (‚ãÉ i, ‚ãÉ hi, f i hi) :=\n  Set.biUnion_eq_iUnion s f ‚ñ∏ small_iUnion _\n\n"}
{"name":"small_insert","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\nx : Œ±\ns : Set Œ±\ninst‚úù : Small.{u, u1} ‚Üës\n‚ä¢ Small.{u, u1} ‚Üë(Insert.insert x s)","decl":"instance small_insert (x : Œ±) (s : Set Œ±) [Small.{u} s] :\n    Small.{u} (insert x s : Set Œ±) :=\n  Set.insert_eq x s ‚ñ∏ small_union.{u} {x} s\n\n"}
{"name":"small_diff","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\ns t : Set Œ±\ninst‚úù : Small.{u, u1} ‚Üës\n‚ä¢ Small.{u, u1} ‚Üë(SDiff.sdiff s t)","decl":"instance small_diff (s t : Set Œ±) [Small.{u} s] : Small.{u} (s \\ t : Set Œ±) :=\n  small_subset (Set.diff_subset)\n\n"}
{"name":"small_sep","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\ns : Set Œ±\nP : Œ± ‚Üí Prop\ninst‚úù : Small.{u, u1} ‚Üës\n‚ä¢ Small.{u, u1} ‚Üë(setOf fun x => And (Membership.mem s x) (P x))","decl":"instance small_sep (s : Set Œ±) (P : Œ± ‚Üí Prop) [Small.{u} s] :\n    Small.{u} { x | x ‚àà s ‚àß P x} :=\n  small_subset (Set.sep_subset s P)\n\n"}
{"name":"small_inter_of_left","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\ns t : Set Œ±\ninst‚úù : Small.{u, u1} ‚Üës\n‚ä¢ Small.{u, u1} ‚Üë(Inter.inter s t)","decl":"instance small_inter_of_left (s t : Set Œ±) [Small.{u} s] :\n    Small.{u} (s ‚à© t : Set Œ±) :=\n  small_subset Set.inter_subset_left\n\n"}
{"name":"small_inter_of_right","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\ns t : Set Œ±\ninst‚úù : Small.{u, u1} ‚Üët\n‚ä¢ Small.{u, u1} ‚Üë(Inter.inter s t)","decl":"instance small_inter_of_right (s t : Set Œ±) [Small.{u} t] :\n    Small.{u} (s ‚à© t : Set Œ±) :=\n  small_subset Set.inter_subset_right\n\n"}
{"name":"small_iInter","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\nŒπ : Type u4\ns : Œπ ‚Üí Set Œ±\ni : Œπ\ninst‚úù : Small.{u, u1} ‚Üë(s i)\n‚ä¢ Small.{u, u1} ‚Üë(Set.iInter fun i => s i)","decl":"theorem small_iInter (s : Œπ ‚Üí Set Œ±) (i : Œπ)\n    [Small.{u} (s i)] : Small.{u} (‚ãÇ i, s i) :=\n  small_subset (Set.iInter_subset s i)\n\n"}
{"name":"small_iInter'","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\nŒπ : Type u4\ninst‚úù¬π : Nonempty Œπ\ns : Œπ ‚Üí Set Œ±\ninst‚úù : ‚àÄ (i : Œπ), Small.{u, u1} ‚Üë(s i)\n‚ä¢ Small.{u, u1} ‚Üë(Set.iInter fun i => s i)","decl":"instance small_iInter' [Nonempty Œπ] (s : Œπ ‚Üí Set Œ±)\n    [‚àÄ i, Small.{u} (s i)] : Small.{u} (‚ãÇ i, s i) :=\n  let ‚ü®i‚ü© : Nonempty Œπ := inferInstance\n  small_iInter s i\n\n"}
{"name":"small_sInter","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\ns : Set (Set Œ±)\nt : Set Œ±\nht : Membership.mem s t\ninst‚úù : Small.{u, u1} ‚Üët\n‚ä¢ Small.{u, u1} ‚Üës.sInter","decl":"theorem small_sInter {s : Set (Set Œ±)} {t : Set Œ±} (ht : t ‚àà s)\n    [Small.{u} t] : Small.{u} (‚ãÇ‚ÇÄ s) :=\n  Set.sInter_eq_iInter ‚ñ∏ small_iInter _ ‚ü®t, ht‚ü©\n\n"}
{"name":"small_sInter'","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\ns : Set (Set Œ±)\ninst‚úù¬π : Nonempty ‚Üës\ninst‚úù : ‚àÄ (t : ‚Üës), Small.{u, u1} ‚Üë‚Üët\n‚ä¢ Small.{u, u1} ‚Üës.sInter","decl":"instance small_sInter' {s : Set (Set Œ±)} [Nonempty s]\n    [‚àÄ t : s, Small.{u} t] : Small.{u} (‚ãÇ‚ÇÄ s) :=\n  let ‚ü®t‚ü© : Nonempty s := inferInstance\n  small_sInter t.prop\n\n"}
{"name":"small_biInter","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\nŒπ : Type u4\ns : Set Œπ\ni : Œπ\nhi : Membership.mem s i\nf : (i : Œπ) ‚Üí Membership.mem s i ‚Üí Set Œ±\ninst‚úù : Small.{u, u1} ‚Üë(f i hi)\n‚ä¢ Small.{u, u1} ‚Üë(Set.iInter fun i => Set.iInter fun hi => f i hi)","decl":"theorem small_biInter {s : Set Œπ} {i : Œπ} (hi : i ‚àà s)\n    (f : (i : Œπ) ‚Üí i ‚àà s ‚Üí Set Œ±) [Small.{u} (f i hi)] : Small.{u} (‚ãÇ i, ‚ãÇ hi, f i hi) :=\n  Set.biInter_eq_iInter s f ‚ñ∏ small_iInter _ ‚ü®i, hi‚ü©\n\n"}
{"name":"small_biInter'","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\nŒπ : Type u4\ns : Set Œπ\ninst‚úù¬π : Nonempty ‚Üës\nf : (i : Œπ) ‚Üí Membership.mem s i ‚Üí Set Œ±\ninst‚úù : ‚àÄ (i : Œπ) (hi : Membership.mem s i), Small.{u, u1} ‚Üë(f i hi)\n‚ä¢ Small.{u, u1} ‚Üë(Set.iInter fun i => Set.iInter fun hi => f i hi)","decl":"instance small_biInter' (s : Set Œπ) [Nonempty s]\n    (f : (i : Œπ) ‚Üí i ‚àà s ‚Üí Set Œ±) [‚àÄ i hi, Small.{u} (f i hi)] : Small.{u} (‚ãÇ i, ‚ãÇ hi, f i hi) :=\n  let ‚ü®t‚ü© : Nonempty s := inferInstance\n  small_biInter t.prop f\n\n"}
{"name":"small_empty","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\n‚ä¢ Small.{u, u1} ‚ÜëEmptyCollection.emptyCollection","decl":"theorem small_empty : Small.{u} (‚àÖ : Set Œ±) :=\n  inferInstance\n\n"}
{"name":"small_single","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\nx : Œ±\n‚ä¢ Small.{u, u1} ‚Üë(Singleton.singleton x)","decl":"theorem small_single (x : Œ±) : Small.{u} ({x} : Set Œ±) :=\n  inferInstance\n\n"}
{"name":"small_pair","module":"Mathlib.Logic.Small.Set","initialProofState":"Œ± : Type u1\nx y : Œ±\n‚ä¢ Small.{u, u1} ‚Üë(Insert.insert x (Singleton.singleton y))","decl":"theorem small_pair (x y : Œ±) : Small.{u} ({x, y} : Set Œ±) :=\n  inferInstance\n"}
