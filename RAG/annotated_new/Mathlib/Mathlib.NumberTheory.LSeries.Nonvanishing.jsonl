{"name":"DirichletCharacter.isMultiplicative_zetaMul","module":"Mathlib.NumberTheory.LSeries.Nonvanishing","initialProofState":"N : Nat\nÏ‡ : DirichletCharacter Complex N\nâŠ¢ Ï‡.zetaMul.IsMultiplicative","decl":"/-- The arithmetic function `zetaMul Ï‡` is multiplicative. -/\nlemma isMultiplicative_zetaMul (Ï‡ : DirichletCharacter â„‚ N) : Ï‡.zetaMul.IsMultiplicative :=\n  isMultiplicative_zeta.natCast.mul <| isMultiplicative_toArithmeticFunction Ï‡\n\n"}
{"name":"DirichletCharacter.LSeriesSummable_zetaMul","module":"Mathlib.NumberTheory.LSeries.Nonvanishing","initialProofState":"N : Nat\nÏ‡ : DirichletCharacter Complex N\ns : Complex\nhs : LT.lt 1 s.re\nâŠ¢ LSeriesSummable (â‡‘Ï‡.zetaMul) s","decl":"lemma LSeriesSummable_zetaMul (Ï‡ : DirichletCharacter â„‚ N) {s : â„‚} (hs : 1 < s.re) :\n    LSeriesSummable Ï‡.zetaMul s := by\n  refine ArithmeticFunction.LSeriesSummable_mul (LSeriesSummable_zeta_iff.mpr hs) <|\n    LSeriesSummable_of_bounded_of_one_lt_re (m := 1) (fun n hn â†¦ ?_) hs\n  simpa only [toArithmeticFunction, coe_mk, hn, â†“reduceIte, â† Complex.norm_eq_abs]\n  using norm_le_one Ï‡ _\n\n"}
{"name":"DirichletCharacter.zetaMul_prime_pow_nonneg","module":"Mathlib.NumberTheory.LSeries.Nonvanishing","initialProofState":"N : Nat\nÏ‡ : DirichletCharacter Complex N\nhÏ‡ : Eq (HPow.hPow Ï‡ 2) 1\np : Nat\nhp : Nat.Prime p\nk : Nat\nâŠ¢ LE.le 0 (Ï‡.zetaMul (HPow.hPow p k))","decl":"lemma zetaMul_prime_pow_nonneg {Ï‡ : DirichletCharacter â„‚ N} (hÏ‡ : Ï‡ ^ 2 = 1) {p : â„•}\n    (hp : p.Prime) (k : â„•) :\n    0 â‰¤ zetaMul Ï‡ (p ^ k) := by\n  simp only [zetaMul, toArithmeticFunction, coe_zeta_mul_apply, coe_mk,\n    Nat.sum_divisors_prime_pow hp, pow_eq_zero_iff', hp.ne_zero, ne_eq, false_and, â†“reduceIte,\n    Nat.cast_pow, map_pow]\n  rcases MulChar.isQuadratic_iff_sq_eq_one.mpr hÏ‡ p with h | h | h\n  Â· refine Finset.sum_nonneg fun i _ â†¦ ?_\n    simp only [h, le_refl, pow_nonneg]\n  Â· refine Finset.sum_nonneg fun i _ â†¦ ?_\n    simp only [h, one_pow, zero_le_one]\n  Â· simp only [h, neg_one_geom_sum]\n    split_ifs\n    exacts [le_rfl, zero_le_one]\n\n"}
{"name":"DirichletCharacter.zetaMul_nonneg","module":"Mathlib.NumberTheory.LSeries.Nonvanishing","initialProofState":"N : Nat\nÏ‡ : DirichletCharacter Complex N\nhÏ‡ : Eq (HPow.hPow Ï‡ 2) 1\nn : Nat\nâŠ¢ LE.le 0 (Ï‡.zetaMul n)","decl":"/-- `zetaMul Ï‡` takes nonnegative real values when `Ï‡` is a quadratic character. -/\nlemma zetaMul_nonneg {Ï‡ : DirichletCharacter â„‚ N} (hÏ‡ : Ï‡ ^ 2 = 1) (n : â„•) :\n    0 â‰¤ zetaMul Ï‡ n := by\n  rcases eq_or_ne n 0 with rfl | hn\n  Â· simp only [ArithmeticFunction.map_zero, le_refl]\n  Â· simpa only [Ï‡.isMultiplicative_zetaMul.multiplicative_factorization _ hn] using\n      Finset.prod_nonneg\n        fun p hp â†¦ zetaMul_prime_pow_nonneg hÏ‡ (Nat.prime_of_mem_primeFactors hp) _\n\n/-\n### \"Bad\" Dirichlet characters\n\nOur goal is to show that `L(Ï‡, 1) â‰  0` when `Ï‡` is a (nontrivial) quadratic Dirichlet character.\nTo do that, we package the contradictory properties in a (private) structure\n`DirichletCharacter.BadChar` and derive further statements eventually leading to a contradiction.\n\nThis entire section is private.\n-/\n\n"}
{"name":"DirichletCharacter.summable_neg_log_one_sub_mul_prime_cpow","module":"Mathlib.NumberTheory.LSeries.Nonvanishing","initialProofState":"N : Nat\nÏ‡ : DirichletCharacter Complex N\ns : Complex\nhs : LT.lt 1 s.re\nâŠ¢ Summable fun p => Neg.neg (Complex.log (HSub.hSub 1 (HMul.hMul (Ï‡ â†‘â†‘p) (HPow.hPow (â†‘â†‘p) (Neg.neg s)))))","decl":"/-- The logarithms of the Euler factors of a Dirichlet L-series form a summable sequence. -/\nlemma summable_neg_log_one_sub_mul_prime_cpow {s : â„‚} (hs : 1 < s.re) :\n    Summable fun p : Nat.Primes â†¦ -log (1 - Ï‡ p * (p : â„‚) ^ (-s)) := by\n  have (p : Nat.Primes) : â€–Ï‡ p * (p : â„‚) ^ (-s)â€– â‰¤ (p : â„) ^ (-s).re := by\n    simpa only [norm_mul, norm_natCast_cpow_of_re_ne_zero _ <| re_neg_ne_zero_of_one_lt_re hs]\n      using mul_le_of_le_one_left (by positivity) (Ï‡.norm_le_one _)\n  refine (Nat.Primes.summable_rpow.mpr ?_).of_nonneg_of_le (fun _ â†¦ norm_nonneg _) this\n    |>.of_norm.clog_one_sub.neg\n  simp only [neg_re, neg_lt_neg_iff, hs]\n\n"}
{"name":"DirichletCharacter.norm_LSeries_product_ge_one","module":"Mathlib.NumberTheory.LSeries.Nonvanishing","initialProofState":"N : Nat\nÏ‡ : DirichletCharacter Complex N\nx : Real\nhx : LT.lt 0 x\ny : Real\nâŠ¢ GE.ge (Norm.norm (HMul.hMul (HMul.hMul (HPow.hPow (LSeries (fun n => 1 â†‘n) (HAdd.hAdd 1 â†‘x)) 3) (HPow.hPow (LSeries (fun n => Ï‡ â†‘n) (HAdd.hAdd (HAdd.hAdd 1 â†‘x) (HMul.hMul Complex.I â†‘y))) 4)) (LSeries (fun n => (HPow.hPow Ï‡ 2) â†‘n) (HAdd.hAdd (HAdd.hAdd 1 â†‘x) (HMul.hMul (HMul.hMul 2 Complex.I) â†‘y))))) 1","decl":"open scoped LSeries.notation in\n/-- For positive `x` and nonzero `y` and a Dirichlet character `Ï‡` we have that\n`|L(Ï‡^0, 1 + x)^3 L(Ï‡, 1 + x + I * y)^4 L(Ï‡^2, 1 + x + 2 * I * y)| â‰¥ 1. -/\nlemma norm_LSeries_product_ge_one {x : â„} (hx : 0 < x) (y : â„) :\n    â€–L â†—(1 : DirichletCharacter â„‚ N) (1 + x) ^ 3 * L â†—Ï‡ (1 + x + I * y) ^ 4 *\n      L â†—(Ï‡ ^ 2 :) (1 + x + 2 * I * y)â€– â‰¥ 1 := by\n  have âŸ¨hâ‚€, hâ‚, hâ‚‚âŸ© := one_lt_re_one_add hx y\n  have Hâ‚€ := summable_neg_log_one_sub_mul_prime_cpow (N := N) 1 hâ‚€\n  have Hâ‚ := summable_neg_log_one_sub_mul_prime_cpow Ï‡ hâ‚\n  have Hâ‚‚ := summable_neg_log_one_sub_mul_prime_cpow (Ï‡ ^ 2) hâ‚‚\n  have hsumâ‚€ := (hasSum_re Hâ‚€.hasSum).summable.mul_left 3\n  have hsumâ‚ := (hasSum_re Hâ‚.hasSum).summable.mul_left 4\n  have hsumâ‚‚ := (hasSum_re Hâ‚‚.hasSum).summable\n  rw [â† LSeries_eulerProduct_exp_log _ hâ‚€, â† LSeries_eulerProduct_exp_log Ï‡ hâ‚,\n    â† LSeries_eulerProduct_exp_log _ hâ‚‚]\n  simp only [â† exp_nat_mul, Nat.cast_ofNat, â† exp_add, norm_eq_abs, abs_exp, add_re, mul_re,\n    re_ofNat, im_ofNat, zero_mul, sub_zero, Real.one_le_exp_iff]\n  rw [re_tsum Hâ‚€, re_tsum Hâ‚, re_tsum Hâ‚‚, â† tsum_mul_left, â† tsum_mul_left,\n    â† tsum_add hsumâ‚€ hsumâ‚, â† tsum_add (hsumâ‚€.add hsumâ‚) hsumâ‚‚]\n  simpa only [neg_add_rev, neg_re, mul_neg, Ï‡.pow_apply' two_ne_zero, ge_iff_le, add_re, one_re,\n    ofReal_re, ofReal_add, ofReal_one] using\n      tsum_nonneg fun (p : Nat.Primes) â†¦ Ï‡.re_log_comb_nonneg p.prop.two_le hâ‚€ y\n\n"}
{"name":"DirichletCharacter.norm_LFunction_product_ge_one","module":"Mathlib.NumberTheory.LSeries.Nonvanishing","initialProofState":"N : Nat\nÏ‡ : DirichletCharacter Complex N\ninstâœ : NeZero N\nx : Real\nhx : LT.lt 0 x\ny : Real\nâŠ¢ GE.ge (Norm.norm (HMul.hMul (HMul.hMul (HPow.hPow (DirichletCharacter.LFunctionTrivChar N (HAdd.hAdd 1 â†‘x)) 3) (HPow.hPow (DirichletCharacter.LFunction Ï‡ (HAdd.hAdd (HAdd.hAdd 1 â†‘x) (HMul.hMul Complex.I â†‘y))) 4)) (DirichletCharacter.LFunction (HPow.hPow Ï‡ 2) (HAdd.hAdd (HAdd.hAdd 1 â†‘x) (HMul.hMul (HMul.hMul 2 Complex.I) â†‘y))))) 1","decl":"/-- A variant of `DirichletCharacter.norm_LSeries_product_ge_one` in terms of the L-functions. -/\nlemma norm_LFunction_product_ge_one {x : â„} (hx : 0 < x) (y : â„) :\n    â€–LFunctionTrivChar N (1 + x) ^ 3 * LFunction Ï‡ (1 + x + I * y) ^ 4 *\n      LFunction (Ï‡ ^ 2) (1 + x + 2 * I * y)â€– â‰¥ 1 := by\n  have âŸ¨hâ‚€, hâ‚, hâ‚‚âŸ© := one_lt_re_one_add hx y\n  rw [LFunctionTrivChar, DirichletCharacter.LFunction_eq_LSeries 1 hâ‚€,\n    Ï‡.LFunction_eq_LSeries hâ‚, (Ï‡ ^ 2).LFunction_eq_LSeries hâ‚‚]\n  exact norm_LSeries_product_ge_one Ï‡ hx y\n\n"}
{"name":"DirichletCharacter.LFunctionTrivChar_isBigO_near_one_horizontal","module":"Mathlib.NumberTheory.LSeries.Nonvanishing","initialProofState":"N : Nat\ninstâœ : NeZero N\nâŠ¢ Asymptotics.IsBigO (nhdsWithin 0 (Set.Ioi 0)) (fun x => DirichletCharacter.LFunctionTrivChar N (HAdd.hAdd 1 â†‘x)) fun x => HDiv.hDiv 1 â†‘x","decl":"lemma LFunctionTrivChar_isBigO_near_one_horizontal :\n    (fun x : â„ â†¦ LFunctionTrivChar N (1 + x)) =O[ğ“[>] 0] fun x â†¦ (1 : â„‚) / x := by\n  have : (fun w : â„‚ â†¦ LFunctionTrivChar N (1 + w)) =O[ğ“[â‰ ] 0] (1 / Â·) := by\n    have H : Tendsto (fun w â†¦ w * LFunctionTrivChar N (1 + w)) (ğ“[â‰ ] 0)\n        (ğ“ <| âˆ p âˆˆ N.primeFactors, (1 - (p : â„‚)â»Â¹)) := by\n      convert (LFunctionTrivChar_residue_one (N := N)).comp (f := fun w â†¦ 1 + w) ?_ using 1\n      Â· simp only [Function.comp_def, add_sub_cancel_left]\n      Â· simpa only [tendsto_iff_comap, Homeomorph.coe_addLeft, add_zero, map_le_iff_le_comap] using\n          ((Homeomorph.addLeft (1 : â„‚)).map_punctured_nhds_eq 0).le\n    exact (isBigO_mul_iff_isBigO_div eventually_mem_nhdsWithin).mp <| H.isBigO_one â„‚\n  exact (isBigO_comp_ofReal_nhds_ne this).mono <| nhdsGT_le_nhdsNE 0\n\n"}
{"name":"DirichletCharacter.LFunction_isBigO_horizontal","module":"Mathlib.NumberTheory.LSeries.Nonvanishing","initialProofState":"N : Nat\nÏ‡ : DirichletCharacter Complex N\ninstâœ : NeZero N\ny : Real\nhy : Or (Ne y 0) (Ne Ï‡ 1)\nâŠ¢ Asymptotics.IsBigO (nhdsWithin 0 (Set.Ioi 0)) (fun x => DirichletCharacter.LFunction Ï‡ (HAdd.hAdd (HAdd.hAdd 1 â†‘x) (HMul.hMul Complex.I â†‘y))) fun x => 1","decl":"lemma LFunction_isBigO_horizontal {y : â„} (hy : y â‰  0 âˆ¨ Ï‡ â‰  1) :\n    (fun x : â„ â†¦ LFunction Ï‡ (1 + x + I * y)) =O[ğ“[>] 0] fun _ â†¦ (1 : â„‚) := by\n  refine IsBigO.mono ?_ nhdsWithin_le_nhds\n  simp_rw [add_comm (1 : â„‚), add_assoc]\n  have := (Ï‡.differentiableAt_LFunction _ <| one_add_I_mul_ne_one_or Ï‡ hy).continuousAt\n  rw [â† zero_add (1 + _)] at this\n  exact this.comp (f := fun x : â„ â†¦ x + (1 + I * y)) (x := 0) (by fun_prop) |>.tendsto.isBigO_one â„‚\n\n"}
{"name":"DirichletCharacter.LFunction_ne_zero_of_re_eq_one","module":"Mathlib.NumberTheory.LSeries.Nonvanishing","initialProofState":"N : Nat\nÏ‡ : DirichletCharacter Complex N\ninstâœ : NeZero N\ns : Complex\nhs : Eq s.re 1\nhÏ‡s : Or (Ne Ï‡ 1) (Ne s 1)\nâŠ¢ Ne (DirichletCharacter.LFunction Ï‡ s) 0","decl":"/-- If `Ï‡` is a Dirichlet character, then `L(Ï‡, s)` does not vanish when `s.re = 1`\nexcept when `Ï‡` is trivial and `s = 1` (then `L(Ï‡, s)` has a simple pole at `s = 1`). -/\ntheorem LFunction_ne_zero_of_re_eq_one {s : â„‚} (hs : s.re = 1) (hÏ‡s : Ï‡ â‰  1 âˆ¨ s â‰  1) :\n    LFunction Ï‡ s â‰  0 := by\n  by_cases h : Ï‡ ^ 2 = 1 âˆ§ s = 1\n  Â· exact h.2 â–¸ LFunction_apply_one_ne_zero_of_quadratic h.1 <| hÏ‡s.neg_resolve_right h.2\n  Â· have hs' : s = 1 + I * s.im := by\n      conv_lhs => rw [â† re_add_im s, hs, ofReal_one, mul_comm]\n    rw [not_and_or, â† ne_eq, â† ne_eq, hs', add_right_ne_self] at h\n    replace h : Ï‡ ^ 2 â‰  1 âˆ¨ s.im â‰  0 :=\n      h.imp_right (fun H â†¦ by exact_mod_cast right_ne_zero_of_mul H)\n    exact hs'.symm â–¸ Ï‡.LFunction_ne_zero_of_not_quadratic_or_ne_one h\n\n"}
{"name":"DirichletCharacter.LFunction_ne_zero_of_one_le_re","module":"Mathlib.NumberTheory.LSeries.Nonvanishing","initialProofState":"N : Nat\nÏ‡ : DirichletCharacter Complex N\ninstâœ : NeZero N\ns : Complex\nhÏ‡s : Or (Ne Ï‡ 1) (Ne s 1)\nhs : LE.le 1 s.re\nâŠ¢ Ne (DirichletCharacter.LFunction Ï‡ s) 0","decl":"/-- If `Ï‡` is a Dirichlet character, then `L(Ï‡, s)` does not vanish for `s.re â‰¥ 1`\nexcept when `Ï‡` is trivial and `s = 1` (then `L(Ï‡, s)` has a simple pole at `s = 1`). -/\ntheorem LFunction_ne_zero_of_one_le_re â¦ƒs : â„‚â¦„ (hÏ‡s : Ï‡ â‰  1 âˆ¨ s â‰  1) (hs : 1 â‰¤ s.re) :\n    LFunction Ï‡ s â‰  0 :=\n  hs.eq_or_lt.casesOn (fun hs â†¦ LFunction_ne_zero_of_re_eq_one Ï‡ hs.symm hÏ‡s)\n    fun hs â†¦ LFunction_eq_LSeries Ï‡ hs â–¸ LSeries_ne_zero_of_one_lt_re Ï‡ hs\n\n-- Interesting special case:\n"}
{"name":"DirichletCharacter.LFunction_apply_one_ne_zero","module":"Mathlib.NumberTheory.LSeries.Nonvanishing","initialProofState":"N : Nat\nÏ‡ : DirichletCharacter Complex N\ninstâœ : NeZero N\nhÏ‡ : Ne Ï‡ 1\nâŠ¢ Ne (DirichletCharacter.LFunction Ï‡ 1) 0","decl":"variable {Ï‡} in\n/-- The L-function of a nontrivial Dirichlet character does not vanish at `s = 1`. -/\ntheorem LFunction_apply_one_ne_zero (hÏ‡ : Ï‡ â‰  1) : LFunction Ï‡ 1 â‰  0 :=\n  LFunction_ne_zero_of_one_le_re Ï‡ (.inl hÏ‡) <| one_re â–¸ le_rfl\n\n"}
{"name":"riemannZeta_ne_zero_of_one_le_re","module":"Mathlib.NumberTheory.LSeries.Nonvanishing","initialProofState":"s : Complex\nhs : LE.le 1 s.re\nâŠ¢ Ne (riemannZeta s) 0","decl":"/-- The Riemann Zeta Function does not vanish on the closed half-plane `re s â‰¥ 1`.\n(Note that the value at `s = 1` is a junk value, which happens to be nonzero.) -/\nlemma _root_.riemannZeta_ne_zero_of_one_le_re â¦ƒs : â„‚â¦„ (hs : 1 â‰¤ s.re) :\n    riemannZeta s â‰  0 := by\n  rcases eq_or_ne s 1 with rfl | hsâ‚€\n  Â· exact riemannZeta_one_ne_zero\n  Â· exact LFunction_modOne_eq (Ï‡ := 1) â–¸ LFunction_ne_zero_of_one_le_re _ (.inr hsâ‚€) hs\n\n"}
