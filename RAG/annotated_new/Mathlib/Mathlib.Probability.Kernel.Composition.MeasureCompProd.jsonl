{"name":"MeasureTheory.Measure.compProd_of_not_sfinite","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nκ : ProbabilityTheory.Kernel α β\nh : Not (MeasureTheory.SFinite μ)\n⊢ Eq (μ.compProd κ) 0","decl":"lemma compProd_of_not_sfinite (μ : Measure α) (κ : Kernel α β) (h : ¬ SFinite μ) :\n    μ ⊗ₘ κ = 0 := by\n  rw [compProd, Kernel.compProd_of_not_isSFiniteKernel_left, Kernel.zero_apply]\n  rwa [Kernel.isSFiniteKernel_const]\n\n"}
{"name":"MeasureTheory.Measure.compProd_of_not_isSFiniteKernel","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nκ : ProbabilityTheory.Kernel α β\nh : Not (ProbabilityTheory.IsSFiniteKernel κ)\n⊢ Eq (μ.compProd κ) 0","decl":"lemma compProd_of_not_isSFiniteKernel (μ : Measure α) (κ : Kernel α β) (h : ¬ IsSFiniteKernel κ) :\n    μ ⊗ₘ κ = 0 := by\n  rw [compProd, Kernel.compProd_of_not_isSFiniteKernel_right, Kernel.zero_apply]\n  rwa [Kernel.isSFiniteKernel_prodMkLeft_unit]\n\n"}
{"name":"MeasureTheory.Measure.compProd_zero_left","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\n⊢ Eq (MeasureTheory.Measure.compProd 0 κ) 0","decl":"@[simp] lemma compProd_zero_left (κ : Kernel α β) : (0 : Measure α) ⊗ₘ κ = 0 := by simp [compProd]\n"}
{"name":"MeasureTheory.Measure.compProd_zero_right","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\n⊢ Eq (μ.compProd 0) 0","decl":"@[simp] lemma compProd_zero_right (μ : Measure α) : μ ⊗ₘ (0 : Kernel α β) = 0 := by simp [compProd]\n\n"}
{"name":"MeasureTheory.Measure.compProd_apply","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\ns : Set (Prod α β)\nhs : MeasurableSet s\n⊢ Eq ((μ.compProd κ) s) (MeasureTheory.lintegral μ fun a => (κ a) (Set.preimage (Prod.mk a) s))","decl":"lemma compProd_apply [SFinite μ] [IsSFiniteKernel κ] {s : Set (α × β)} (hs : MeasurableSet s) :\n    (μ ⊗ₘ κ) s = ∫⁻ a, κ a (Prod.mk a ⁻¹' s) ∂μ := by\n  simp_rw [compProd, Kernel.compProd_apply hs, Kernel.const_apply, Kernel.prodMkLeft_apply']\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.compProd_apply_univ","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : ProbabilityTheory.IsMarkovKernel κ\n⊢ Eq ((μ.compProd κ) Set.univ) (μ Set.univ)","decl":"@[simp]\nlemma compProd_apply_univ [SFinite μ] [IsMarkovKernel κ] : (μ ⊗ₘ κ) univ = μ univ := by\n  rw [compProd_apply MeasurableSet.univ]\n  simp\n\n"}
{"name":"MeasureTheory.Measure.compProd_apply_prod","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\ns : Set α\nt : Set β\nhs : MeasurableSet s\nht : MeasurableSet t\n⊢ Eq ((μ.compProd κ) (SProd.sprod s t)) (MeasureTheory.lintegral (μ.restrict s) fun a => (κ a) t)","decl":"lemma compProd_apply_prod [SFinite μ] [IsSFiniteKernel κ]\n    {s : Set α} {t : Set β} (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    (μ ⊗ₘ κ) (s ×ˢ t) = ∫⁻ a in s, κ a t ∂μ := by\n  rw [compProd_apply (hs.prod ht), ← lintegral_indicator hs]\n  congr with a\n  classical\n  rw [indicator_apply]\n  split_ifs with ha <;> simp [ha]\n\n"}
{"name":"ProbabilityTheory.Kernel.compProd_apply_eq_compProd_sectR","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\na : α\n⊢ Eq ((κ.compProd η) a) ((κ a).compProd (η.sectR a))","decl":"lemma _root_.ProbabilityTheory.Kernel.compProd_apply_eq_compProd_sectR {γ : Type*}\n    {mγ : MeasurableSpace γ} (κ : Kernel α β) (η : Kernel (α × β) γ)\n    [IsSFiniteKernel κ] [IsSFiniteKernel η] (a : α) :\n    (κ ⊗ₖ η) a = (κ a) ⊗ₘ (Kernel.sectR η a) := by\n  ext s hs\n  simp_rw [Kernel.compProd_apply hs, compProd_apply hs, Kernel.sectR_apply]\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.compProd_id","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\n⊢ Eq (μ.compProd ProbabilityTheory.Kernel.id) (MeasureTheory.Measure.map (fun x => { fst := x, snd := x }) μ)","decl":"lemma compProd_id [SFinite μ] : μ ⊗ₘ Kernel.id = μ.map (fun x ↦ (x, x)) := by\n  ext s hs\n  rw [compProd_apply hs, map_apply (measurable_id.prod measurable_id) hs]\n  have h_meas a : MeasurableSet (Prod.mk a ⁻¹' s) := measurable_prod_mk_left hs\n  simp_rw [Kernel.id_apply, dirac_apply' _ (h_meas _)]\n  calc ∫⁻ a, (Prod.mk a ⁻¹' s).indicator 1 a ∂μ\n  _ = ∫⁻ a, ((fun x ↦ (x, x)) ⁻¹' s).indicator 1 a ∂μ := rfl\n  _ = μ ((fun x ↦ (x, x)) ⁻¹' s) := by\n    rw [lintegral_indicator_one]\n    exact (measurable_id.prod measurable_id) hs\n\n"}
{"name":"MeasureTheory.Measure.compProd_congr","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nκ η : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\nh : (MeasureTheory.ae μ).EventuallyEq ⇑κ ⇑η\n⊢ Eq (μ.compProd κ) (μ.compProd η)","decl":"lemma compProd_congr [IsSFiniteKernel κ] [IsSFiniteKernel η]\n    (h : κ =ᵐ[μ] η) : μ ⊗ₘ κ = μ ⊗ₘ η := by\n  by_cases hμ : SFinite μ\n  · ext s hs\n    have : (fun a ↦ κ a (Prod.mk a ⁻¹' s)) =ᵐ[μ] fun a ↦ η a (Prod.mk a ⁻¹' s) := by\n      filter_upwards [h] with a ha using by rw [ha]\n    rw [compProd_apply hs, lintegral_congr_ae this, compProd_apply hs]\n  · simp [compProd_of_not_sfinite _ _ hμ]\n\n"}
{"name":"MeasureTheory.Measure.ae_compProd_of_ae_ae","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nκ : ProbabilityTheory.Kernel α β\np : Prod α β → Prop\nhp : MeasurableSet (setOf fun x => p x)\nh : Filter.Eventually (fun a => Filter.Eventually (fun b => p { fst := a, snd := b }) (MeasureTheory.ae (κ a))) (MeasureTheory.ae μ)\n⊢ Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.compProd κ))","decl":"lemma ae_compProd_of_ae_ae {p : α × β → Prop}\n    (hp : MeasurableSet {x | p x}) (h : ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b)) :\n    ∀ᵐ x ∂(μ ⊗ₘ κ), p x :=\n  Kernel.ae_compProd_of_ae_ae hp h\n\n"}
{"name":"MeasureTheory.Measure.ae_ae_of_ae_compProd","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\np : Prod α β → Prop\nh : Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.compProd κ))\n⊢ Filter.Eventually (fun a => Filter.Eventually (fun b => p { fst := a, snd := b }) (MeasureTheory.ae (κ a))) (MeasureTheory.ae μ)","decl":"lemma ae_ae_of_ae_compProd [SFinite μ] [IsSFiniteKernel κ] {p : α × β → Prop}\n    (h : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂κ a, p (a, b) := by\n  convert Kernel.ae_ae_of_ae_compProd h -- Much faster with `convert`\n\n"}
{"name":"MeasureTheory.Measure.ae_compProd_iff","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\np : Prod α β → Prop\nhp : MeasurableSet (setOf fun x => p x)\n⊢ Iff (Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.compProd κ))) (Filter.Eventually (fun a => Filter.Eventually (fun b => p { fst := a, snd := b }) (MeasureTheory.ae (κ a))) (MeasureTheory.ae μ))","decl":"lemma ae_compProd_iff [SFinite μ] [IsSFiniteKernel κ] {p : α × β → Prop}\n    (hp : MeasurableSet {x | p x}) :\n    (∀ᵐ x ∂(μ ⊗ₘ κ), p x) ↔ ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) :=\n  Kernel.ae_compProd_iff hp\n\n"}
{"name":"MeasureTheory.Measure.compProd_const","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : MeasureTheory.SFinite ν\n⊢ Eq (μ.compProd (ProbabilityTheory.Kernel.const α ν)) (μ.prod ν)","decl":"/-- The composition product of a measure and a constant kernel is the product between the two\nmeasures. -/\n@[simp]\nlemma compProd_const {ν : Measure β} [SFinite μ] [SFinite ν] :\n    μ ⊗ₘ (Kernel.const α ν) = μ.prod ν := by\n  ext s hs\n  simp_rw [compProd_apply hs, prod_apply hs, Kernel.const_apply]\n\n"}
{"name":"MeasureTheory.Measure.compProd_add_left","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : MeasureTheory.SFinite ν\nκ : ProbabilityTheory.Kernel α β\n⊢ Eq ((HAdd.hAdd μ ν).compProd κ) (HAdd.hAdd (μ.compProd κ) (ν.compProd κ))","decl":"lemma compProd_add_left (μ ν : Measure α) [SFinite μ] [SFinite ν] (κ : Kernel α β) :\n    (μ + ν) ⊗ₘ κ = μ ⊗ₘ κ + ν ⊗ₘ κ := by\n  by_cases hκ : IsSFiniteKernel κ\n  · simp_rw [Measure.compProd, Kernel.const_add, Kernel.compProd_add_left, Kernel.add_apply]\n  · simp [compProd_of_not_isSFiniteKernel _ _ hκ]\n\n"}
{"name":"MeasureTheory.Measure.compProd_add_right","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nκ η : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\n⊢ Eq (μ.compProd (HAdd.hAdd κ η)) (HAdd.hAdd (μ.compProd κ) (μ.compProd η))","decl":"lemma compProd_add_right (μ : Measure α) (κ η : Kernel α β)\n    [IsSFiniteKernel κ] [IsSFiniteKernel η] :\n    μ ⊗ₘ (κ + η) = μ ⊗ₘ κ + μ ⊗ₘ η := by\n  by_cases hμ : SFinite μ\n  · simp_rw [Measure.compProd, Kernel.prodMkLeft_add, Kernel.compProd_add_right, Kernel.add_apply]\n  · simp [compProd_of_not_sfinite _ _ hμ]\n\n"}
{"name":"MeasureTheory.Measure.fst_compProd","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SFinite μ\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsMarkovKernel κ\n⊢ Eq (μ.compProd κ).fst μ","decl":"@[simp]\nlemma fst_compProd (μ : Measure α) [SFinite μ] (κ : Kernel α β) [IsMarkovKernel κ] :\n    (μ ⊗ₘ κ).fst = μ := by\n  ext s\n  rw [compProd, Measure.fst, ← Kernel.fst_apply, Kernel.fst_compProd, Kernel.const_apply]\n\n"}
{"name":"MeasureTheory.Measure.compProd_smul_left","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nκ : ProbabilityTheory.Kernel α β\na : ENNReal\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\n⊢ Eq ((HSMul.hSMul a μ).compProd κ) (HSMul.hSMul a (μ.compProd κ))","decl":"lemma compProd_smul_left (a : ℝ≥0∞) [SFinite μ] [IsSFiniteKernel κ] :\n    (a • μ) ⊗ₘ κ = a • (μ ⊗ₘ κ) := by\n  ext s hs\n  simp only [compProd_apply hs, lintegral_smul_measure, smul_apply, smul_eq_mul]\n\n"}
{"name":"MeasureTheory.Measure.lintegral_compProd","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nf : Prod α β → ENNReal\nhf : Measurable f\n⊢ Eq (MeasureTheory.lintegral (μ.compProd κ) fun x => f x) (MeasureTheory.lintegral μ fun a => MeasureTheory.lintegral (κ a) fun b => f { fst := a, snd := b })","decl":"lemma lintegral_compProd [SFinite μ] [IsSFiniteKernel κ]\n    {f : α × β → ℝ≥0∞} (hf : Measurable f) :\n    ∫⁻ x, f x ∂(μ ⊗ₘ κ) = ∫⁻ a, ∫⁻ b, f (a, b) ∂(κ a) ∂μ := by\n  rw [compProd, Kernel.lintegral_compProd _ _ _ hf]\n  simp\n\n"}
{"name":"MeasureTheory.Measure.setLIntegral_compProd","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nf : Prod α β → ENNReal\nhf : Measurable f\ns : Set α\nhs : MeasurableSet s\nt : Set β\nht : MeasurableSet t\n⊢ Eq (MeasureTheory.lintegral ((μ.compProd κ).restrict (SProd.sprod s t)) fun x => f x) (MeasureTheory.lintegral (μ.restrict s) fun a => MeasureTheory.lintegral ((κ a).restrict t) fun b => f { fst := a, snd := b })","decl":"lemma setLIntegral_compProd [SFinite μ] [IsSFiniteKernel κ]\n    {f : α × β → ℝ≥0∞} (hf : Measurable f)\n    {s : Set α} (hs : MeasurableSet s) {t : Set β} (ht : MeasurableSet t) :\n    ∫⁻ x in s ×ˢ t, f x ∂(μ ⊗ₘ κ) = ∫⁻ a in s, ∫⁻ b in t, f (a, b) ∂(κ a) ∂μ := by\n  rw [compProd, Kernel.setLIntegral_compProd _ _ _ hf hs ht]\n  simp\n\n"}
{"name":"MeasureTheory.Measure.integrable_compProd_iff","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nκ : ProbabilityTheory.Kernel α β\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nE : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Prod α β → E\nhf : MeasureTheory.AEStronglyMeasurable f (μ.compProd κ)\n⊢ Iff (MeasureTheory.Integrable f (μ.compProd κ)) (And (Filter.Eventually (fun x => MeasureTheory.Integrable (fun y => f { fst := x, snd := y }) (κ x)) (MeasureTheory.ae μ)) (MeasureTheory.Integrable (fun x => MeasureTheory.integral (κ x) fun y => Norm.norm (f { fst := x, snd := y })) μ))","decl":"lemma integrable_compProd_iff [SFinite μ] [IsSFiniteKernel κ] {E : Type*} [NormedAddCommGroup E]\n    {f : α × β → E} (hf : AEStronglyMeasurable f (μ ⊗ₘ κ)) :\n    Integrable f (μ ⊗ₘ κ) ↔\n      (∀ᵐ x ∂μ, Integrable (fun y => f (x, y)) (κ x)) ∧\n        Integrable (fun x => ∫ y, ‖f (x, y)‖ ∂(κ x)) μ := by\n  simp_rw [Measure.compProd, ProbabilityTheory.integrable_compProd_iff hf, Kernel.prodMkLeft_apply,\n    Kernel.const_apply]\n\n"}
{"name":"MeasureTheory.Measure.integral_compProd","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nκ : ProbabilityTheory.Kernel α β\ninst✝³ : MeasureTheory.SFinite μ\ninst✝² : ProbabilityTheory.IsSFiniteKernel κ\nE : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : Prod α β → E\nhf : MeasureTheory.Integrable f (μ.compProd κ)\n⊢ Eq (MeasureTheory.integral (μ.compProd κ) fun x => f x) (MeasureTheory.integral μ fun a => MeasureTheory.integral (κ a) fun b => f { fst := a, snd := b })","decl":"lemma integral_compProd [SFinite μ] [IsSFiniteKernel κ] {E : Type*}\n    [NormedAddCommGroup E] [NormedSpace ℝ E]\n    {f : α × β → E} (hf : Integrable f (μ ⊗ₘ κ)) :\n    ∫ x, f x ∂(μ ⊗ₘ κ) = ∫ a, ∫ b, f (a, b) ∂(κ a) ∂μ := by\n  rw [compProd, ProbabilityTheory.integral_compProd hf]\n  simp\n\n"}
{"name":"MeasureTheory.Measure.setIntegral_compProd","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nκ : ProbabilityTheory.Kernel α β\ninst✝³ : MeasureTheory.SFinite μ\ninst✝² : ProbabilityTheory.IsSFiniteKernel κ\nE : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\ns : Set α\nhs : MeasurableSet s\nt : Set β\nht : MeasurableSet t\nf : Prod α β → E\nhf : MeasureTheory.IntegrableOn f (SProd.sprod s t) (μ.compProd κ)\n⊢ Eq (MeasureTheory.integral ((μ.compProd κ).restrict (SProd.sprod s t)) fun x => f x) (MeasureTheory.integral (μ.restrict s) fun a => MeasureTheory.integral ((κ a).restrict t) fun b => f { fst := a, snd := b })","decl":"lemma setIntegral_compProd [SFinite μ] [IsSFiniteKernel κ] {E : Type*}\n    [NormedAddCommGroup E] [NormedSpace ℝ E]\n    {s : Set α} (hs : MeasurableSet s) {t : Set β} (ht : MeasurableSet t)\n    {f : α × β → E} (hf : IntegrableOn f (s ×ˢ t) (μ ⊗ₘ κ))  :\n    ∫ x in s ×ˢ t, f x ∂(μ ⊗ₘ κ) = ∫ a in s, ∫ b in t, f (a, b) ∂(κ a) ∂μ := by\n  rw [compProd, ProbabilityTheory.setIntegral_compProd hs ht hf]\n  simp\n\n"}
{"name":"MeasureTheory.Measure.dirac_compProd_apply","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : MeasurableSingletonClass α\na : α\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\ns : Set (Prod α β)\nhs : MeasurableSet s\n⊢ Eq (((MeasureTheory.Measure.dirac a).compProd κ) s) ((κ a) (Set.preimage (Prod.mk a) s))","decl":"lemma dirac_compProd_apply [MeasurableSingletonClass α] {a : α} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : MeasurableSet s) :\n    (Measure.dirac a ⊗ₘ κ) s = κ a (Prod.mk a ⁻¹' s) := by\n  rw [compProd_apply hs, lintegral_dirac]\n\n"}
{"name":"MeasureTheory.Measure.dirac_unit_compProd","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"β : Type u_2\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel Unit β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\n⊢ Eq ((MeasureTheory.Measure.dirac Unit.unit).compProd κ) (MeasureTheory.Measure.map (Prod.mk Unit.unit) (κ Unit.unit))","decl":"lemma dirac_unit_compProd (κ : Kernel Unit β) [IsSFiniteKernel κ] :\n    Measure.dirac () ⊗ₘ κ = (κ ()).map (Prod.mk ()) := by\n  ext s hs; rw [dirac_compProd_apply hs, Measure.map_apply measurable_prod_mk_left hs]\n\n"}
{"name":"MeasureTheory.Measure.dirac_unit_compProd_const","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"β : Type u_2\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure β\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Eq ((MeasureTheory.Measure.dirac Unit.unit).compProd (ProbabilityTheory.Kernel.const Unit μ)) (MeasureTheory.Measure.map (Prod.mk Unit.unit) μ)","decl":"lemma dirac_unit_compProd_const (μ : Measure β) [IsFiniteMeasure μ] :\n    Measure.dirac () ⊗ₘ Kernel.const Unit μ = μ.map (Prod.mk ()) := by\n  rw [dirac_unit_compProd, Kernel.const_apply]\n\n"}
{"name":"MeasureTheory.Measure.snd_dirac_unit_compProd_const","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"β : Type u_2\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure β\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Eq ((MeasureTheory.Measure.dirac Unit.unit).compProd (ProbabilityTheory.Kernel.const Unit μ)).snd μ","decl":"lemma snd_dirac_unit_compProd_const (μ : Measure β) [IsFiniteMeasure μ] :\n    snd (Measure.dirac () ⊗ₘ Kernel.const Unit μ) = μ := by simp\n\n"}
{"name":"MeasureTheory.Measure.instSFiniteProdCompProd","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nκ : ProbabilityTheory.Kernel α β\n⊢ MeasureTheory.SFinite (μ.compProd κ)","decl":"instance : SFinite (μ ⊗ₘ κ) := by rw [compProd]; infer_instance\n\n"}
{"name":"MeasureTheory.Measure.instIsFiniteMeasureProdCompProdOfIsFiniteKernel","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ MeasureTheory.IsFiniteMeasure (μ.compProd κ)","decl":"instance [IsFiniteMeasure μ] [IsFiniteKernel κ] : IsFiniteMeasure (μ ⊗ₘ κ) := by\n  rw [compProd]; infer_instance\n\n"}
{"name":"MeasureTheory.Measure.instIsProbabilityMeasureProdCompProdOfIsMarkovKernel","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : MeasureTheory.IsProbabilityMeasure μ\ninst✝ : ProbabilityTheory.IsMarkovKernel κ\n⊢ MeasureTheory.IsProbabilityMeasure (μ.compProd κ)","decl":"instance [IsProbabilityMeasure μ] [IsMarkovKernel κ] : IsProbabilityMeasure (μ ⊗ₘ κ) := by\n  rw [compProd]; infer_instance\n\n"}
{"name":"MeasureTheory.Measure.instIsZeroOrProbabilityMeasureProdCompProdOfIsZeroOrMarkovKernel","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : MeasureTheory.IsZeroOrProbabilityMeasure μ\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\n⊢ MeasureTheory.IsZeroOrProbabilityMeasure (μ.compProd κ)","decl":"instance [IsZeroOrProbabilityMeasure μ] [IsZeroOrMarkovKernel κ] :\n    IsZeroOrProbabilityMeasure (μ ⊗ₘ κ) := by\n  rw [compProd]\n  rcases eq_zero_or_isProbabilityMeasure μ with rfl | h\n  · simp only [Kernel.const_zero, Kernel.compProd_zero_left, Kernel.zero_apply]\n    infer_instance\n  rcases eq_zero_or_isMarkovKernel κ with rfl | hκ\n  · simp only [Kernel.prodMkLeft_zero, Kernel.compProd_zero_right, Kernel.zero_apply]\n    infer_instance\n  · infer_instance\n\n"}
{"name":"MeasureTheory.Measure.AbsolutelyContinuous.compProd_left","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite ν\nhμν : μ.AbsolutelyContinuous ν\nκ : ProbabilityTheory.Kernel α β\n⊢ (μ.compProd κ).AbsolutelyContinuous (ν.compProd κ)","decl":"lemma AbsolutelyContinuous.compProd_left [SFinite ν] (hμν : μ ≪ ν) (κ : Kernel α β) :\n    μ ⊗ₘ κ ≪ ν ⊗ₘ κ := by\n  by_cases hκ : IsSFiniteKernel κ\n  · have : SFinite μ := sFinite_of_absolutelyContinuous hμν\n    refine Measure.AbsolutelyContinuous.mk fun s hs hs_zero ↦ ?_\n    rw [Measure.compProd_apply hs, lintegral_eq_zero_iff (Kernel.measurable_kernel_prod_mk_left hs)]\n      at hs_zero ⊢\n    exact hμν.ae_eq hs_zero\n  · simp [compProd_of_not_isSFiniteKernel _ _ hκ]\n\n"}
{"name":"MeasureTheory.Measure.absolutelyContinuous_compProd_left","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite ν\nhμν : μ.AbsolutelyContinuous ν\nκ : ProbabilityTheory.Kernel α β\n⊢ (μ.compProd κ).AbsolutelyContinuous (ν.compProd κ)","decl":"@[deprecated (since := \"2024-12-11\")]\nalias absolutelyContinuous_compProd_left := AbsolutelyContinuous.compProd_left\n\n"}
{"name":"MeasureTheory.Measure.AbsolutelyContinuous.compProd_right","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nκ η : ProbabilityTheory.Kernel α β\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\nhκη : Filter.Eventually (fun a => (κ a).AbsolutelyContinuous (η a)) (MeasureTheory.ae μ)\n⊢ (μ.compProd κ).AbsolutelyContinuous (μ.compProd η)","decl":"lemma AbsolutelyContinuous.compProd_right [SFinite μ] [IsSFiniteKernel η]\n    (hκη : ∀ᵐ a ∂μ, κ a ≪ η a) :\n    μ ⊗ₘ κ ≪ μ ⊗ₘ η := by\n  by_cases hκ : IsSFiniteKernel κ\n  · refine Measure.AbsolutelyContinuous.mk fun s hs hs_zero ↦ ?_\n    rw [Measure.compProd_apply hs, lintegral_eq_zero_iff (Kernel.measurable_kernel_prod_mk_left hs)]\n      at hs_zero ⊢\n    filter_upwards [hs_zero, hκη] with a ha_zero ha_ac using ha_ac ha_zero\n  · simp [compProd_of_not_isSFiniteKernel _ _ hκ]\n\n"}
{"name":"MeasureTheory.Measure.absolutelyContinuous_compProd_right","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nκ η : ProbabilityTheory.Kernel α β\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\nhκη : Filter.Eventually (fun a => (κ a).AbsolutelyContinuous (η a)) (MeasureTheory.ae μ)\n⊢ (μ.compProd κ).AbsolutelyContinuous (μ.compProd η)","decl":"@[deprecated (since := \"2024-12-11\")]\nalias absolutelyContinuous_compProd_right := AbsolutelyContinuous.compProd_right\n\n"}
{"name":"MeasureTheory.Measure.AbsolutelyContinuous.compProd","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ ν : MeasureTheory.Measure α\nκ η : ProbabilityTheory.Kernel α β\ninst✝¹ : MeasureTheory.SFinite ν\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\nhμν : μ.AbsolutelyContinuous ν\nhκη : Filter.Eventually (fun a => (κ a).AbsolutelyContinuous (η a)) (MeasureTheory.ae μ)\n⊢ (μ.compProd κ).AbsolutelyContinuous (ν.compProd η)","decl":"lemma AbsolutelyContinuous.compProd [SFinite ν] [IsSFiniteKernel η]\n    (hμν : μ ≪ ν) (hκη : ∀ᵐ a ∂μ, κ a ≪ η a) :\n    μ ⊗ₘ κ ≪ ν ⊗ₘ η :=\n  have : SFinite μ := sFinite_of_absolutelyContinuous hμν\n  (Measure.AbsolutelyContinuous.compProd_right hκη).trans (hμν.compProd_left _)\n\n"}
{"name":"MeasureTheory.Measure.absolutelyContinuous_compProd","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ ν : MeasureTheory.Measure α\nκ η : ProbabilityTheory.Kernel α β\ninst✝¹ : MeasureTheory.SFinite ν\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\nhμν : μ.AbsolutelyContinuous ν\nhκη : Filter.Eventually (fun a => (κ a).AbsolutelyContinuous (η a)) (MeasureTheory.ae μ)\n⊢ (μ.compProd κ).AbsolutelyContinuous (ν.compProd η)","decl":"@[deprecated (since := \"2024-12-11\")]\nalias absolutelyContinuous_compProd := AbsolutelyContinuous.compProd\n\n"}
{"name":"MeasureTheory.Measure.absolutelyContinuous_of_compProd","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ ν : MeasureTheory.Measure α\nκ η : ProbabilityTheory.Kernel α β\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nh_zero : ∀ (a : α), NeZero (κ a)\nh : (μ.compProd κ).AbsolutelyContinuous (ν.compProd η)\n⊢ μ.AbsolutelyContinuous ν","decl":"lemma absolutelyContinuous_of_compProd [SFinite μ] [IsSFiniteKernel κ] [h_zero : ∀ a, NeZero (κ a)]\n    (h : μ ⊗ₘ κ ≪ ν ⊗ₘ η) :\n    μ ≪ ν := by\n  refine Measure.AbsolutelyContinuous.mk (fun s hs hs0 ↦ ?_)\n  have h1 : (ν ⊗ₘ η) (s ×ˢ univ) = 0 := by\n    by_cases hν : SFinite ν\n    swap; · simp [compProd_of_not_sfinite _ _ hν]\n    by_cases hη : IsSFiniteKernel η\n    swap; · simp [compProd_of_not_isSFiniteKernel _ _ hη]\n    rw [Measure.compProd_apply_prod hs MeasurableSet.univ]\n    exact setLIntegral_measure_zero _ _ hs0\n  have h2 : (μ ⊗ₘ κ) (s ×ˢ univ) = 0 := h h1\n  rw [Measure.compProd_apply_prod hs MeasurableSet.univ, lintegral_eq_zero_iff] at h2\n  swap; · exact Kernel.measurable_coe _ MeasurableSet.univ\n  by_contra hμs\n  have : Filter.NeBot (ae (μ.restrict s)) := by simp [hμs]\n  obtain ⟨a, ha⟩ : ∃ a, κ a univ = 0 := h2.exists\n  refine absurd ha ?_\n  simp only [Measure.measure_univ_eq_zero]\n  exact (h_zero a).out\n\n"}
{"name":"MeasureTheory.Measure.absolutelyContinuous_compProd_left_iff","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ ν : MeasureTheory.Measure α\nκ : ProbabilityTheory.Kernel α β\ninst✝³ : MeasureTheory.SFinite μ\ninst✝² : MeasureTheory.SFinite ν\ninst✝¹ : ProbabilityTheory.IsFiniteKernel κ\ninst✝ : ∀ (a : α), NeZero (κ a)\n⊢ Iff ((μ.compProd κ).AbsolutelyContinuous (ν.compProd κ)) (μ.AbsolutelyContinuous ν)","decl":"lemma absolutelyContinuous_compProd_left_iff [SFinite μ] [SFinite ν]\n    [IsFiniteKernel κ] [∀ a, NeZero (κ a)] :\n    μ ⊗ₘ κ ≪ ν ⊗ₘ κ ↔ μ ≪ ν :=\n  ⟨absolutelyContinuous_of_compProd, fun h ↦ h.compProd_left κ⟩\n\n"}
{"name":"MeasureTheory.Measure.AbsolutelyContinuous.compProd_of_compProd","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ ν : MeasureTheory.Measure α\nκ η : ProbabilityTheory.Kernel α β\ninst✝¹ : MeasureTheory.SFinite ν\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\nhμν : μ.AbsolutelyContinuous ν\nhκη : (μ.compProd κ).AbsolutelyContinuous (μ.compProd η)\n⊢ (μ.compProd κ).AbsolutelyContinuous (ν.compProd η)","decl":"lemma AbsolutelyContinuous.compProd_of_compProd [SFinite ν] [IsSFiniteKernel η]\n    (hμν : μ ≪ ν) (hκη : μ ⊗ₘ κ ≪ μ ⊗ₘ η) :\n    μ ⊗ₘ κ ≪ ν ⊗ₘ η := by\n  by_cases hμ : SFinite μ\n  swap; · rw [compProd_of_not_sfinite _ _ hμ]; simp\n  refine AbsolutelyContinuous.mk fun s hs hs_zero ↦ ?_\n  suffices (μ ⊗ₘ η) s = 0 from hκη this\n  rw [measure_zero_iff_ae_nmem, ae_compProd_iff hs.compl] at hs_zero ⊢\n  exact hμν.ae_le hs_zero\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.compProd_of_left","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ ν : MeasureTheory.Measure α\nhμν : μ.MutuallySingular ν\nκ η : ProbabilityTheory.Kernel α β\n⊢ (μ.compProd κ).MutuallySingular (ν.compProd η)","decl":"lemma MutuallySingular.compProd_of_left (hμν : μ ⟂ₘ ν) (κ η : Kernel α β) :\n    μ ⊗ₘ κ ⟂ₘ ν ⊗ₘ η := by\n  by_cases hμ : SFinite μ\n  swap; · rw [compProd_of_not_sfinite _ _ hμ]; simp\n  by_cases hν : SFinite ν\n  swap; · rw [compProd_of_not_sfinite _ _ hν]; simp\n  by_cases hκ : IsSFiniteKernel κ\n  swap; · rw [compProd_of_not_isSFiniteKernel _ _ hκ]; simp\n  by_cases hη : IsSFiniteKernel η\n  swap; · rw [compProd_of_not_isSFiniteKernel _ _ hη]; simp\n  refine ⟨hμν.nullSet ×ˢ univ, hμν.measurableSet_nullSet.prod .univ, ?_⟩\n  rw [compProd_apply_prod hμν.measurableSet_nullSet .univ, compl_prod_eq_union]\n  simp only [MutuallySingular.restrict_nullSet, lintegral_zero_measure, compl_univ,\n    prod_empty, union_empty, true_and]\n  rw [compProd_apply_prod hμν.measurableSet_nullSet.compl .univ]\n  simp\n\n"}
{"name":"MeasureTheory.Measure.mutuallySingular_of_mutuallySingular_compProd","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ ν : MeasureTheory.Measure α\nκ η : ProbabilityTheory.Kernel α β\nξ : MeasureTheory.Measure α\ninst✝³ : MeasureTheory.SFinite μ\ninst✝² : MeasureTheory.SFinite ν\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\nh : (μ.compProd κ).MutuallySingular (ν.compProd η)\nhμ : ξ.AbsolutelyContinuous μ\nhν : ξ.AbsolutelyContinuous ν\n⊢ Filter.Eventually (fun x => (κ x).MutuallySingular (η x)) (MeasureTheory.ae ξ)","decl":"lemma mutuallySingular_of_mutuallySingular_compProd {ξ : Measure α}\n    [SFinite μ] [SFinite ν] [IsSFiniteKernel κ] [IsSFiniteKernel η]\n    (h : μ ⊗ₘ κ ⟂ₘ ν ⊗ₘ η) (hμ : ξ ≪ μ) (hν : ξ ≪ ν) :\n    ∀ᵐ x ∂ξ, κ x ⟂ₘ η x := by\n  have hs : MeasurableSet h.nullSet := h.measurableSet_nullSet\n  have hμ_zero : (μ ⊗ₘ κ) h.nullSet = 0 := h.measure_nullSet\n  have hν_zero : (ν ⊗ₘ η) h.nullSetᶜ = 0 := h.measure_compl_nullSet\n  rw [compProd_apply, lintegral_eq_zero_iff'] at hμ_zero hν_zero\n  · filter_upwards [hμ hμ_zero, hν hν_zero] with x hxμ hxν\n    exact ⟨Prod.mk x ⁻¹' h.nullSet, measurable_prod_mk_left hs, ⟨hxμ, hxν⟩⟩\n  · exact (Kernel.measurable_kernel_prod_mk_left hs.compl).aemeasurable\n  · exact (Kernel.measurable_kernel_prod_mk_left hs).aemeasurable\n  · exact hs.compl\n  · exact hs\n\n"}
{"name":"MeasureTheory.Measure.mutuallySingular_compProd_left_iff","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ ν : MeasureTheory.Measure α\nκ : ProbabilityTheory.Kernel α β\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasureTheory.SigmaFinite ν\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nhκ : ∀ (x : α), NeZero (κ x)\n⊢ Iff ((μ.compProd κ).MutuallySingular (ν.compProd κ)) (μ.MutuallySingular ν)","decl":"lemma mutuallySingular_compProd_left_iff [SFinite μ] [SigmaFinite ν]\n    [IsSFiniteKernel κ] [hκ : ∀ x, NeZero (κ x)] :\n    μ ⊗ₘ κ ⟂ₘ ν ⊗ₘ κ ↔ μ ⟂ₘ ν := by\n  refine ⟨fun h ↦ ?_, fun h ↦ h.compProd_of_left _ _⟩\n  rw [← withDensity_rnDeriv_eq_zero]\n  have hh := mutuallySingular_of_mutuallySingular_compProd h ?_ ?_\n    (ξ := ν.withDensity (μ.rnDeriv ν))\n  rotate_left\n  · exact absolutelyContinuous_of_le (μ.withDensity_rnDeriv_le ν)\n  · exact withDensity_absolutelyContinuous _ _\n  simp_rw [MutuallySingular.self_iff, (hκ _).ne] at hh\n  exact ae_eq_bot.mp (Filter.eventually_false_iff_eq_bot.mp hh)\n\n"}
{"name":"MeasureTheory.Measure.AbsolutelyContinuous.mutuallySingular_compProd_iff","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ ν : MeasureTheory.Measure α\nκ η : ProbabilityTheory.Kernel α β\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhμν : μ.AbsolutelyContinuous ν\n⊢ Iff ((μ.compProd κ).MutuallySingular (ν.compProd η)) ((μ.compProd κ).MutuallySingular (μ.compProd η))","decl":"lemma AbsolutelyContinuous.mutuallySingular_compProd_iff [SigmaFinite μ] [SigmaFinite ν]\n    (hμν : μ ≪ ν) :\n    μ ⊗ₘ κ ⟂ₘ ν ⊗ₘ η ↔ μ ⊗ₘ κ ⟂ₘ μ ⊗ₘ η := by\n  conv_lhs => rw [ν.haveLebesgueDecomposition_add μ]\n  rw [compProd_add_left, MutuallySingular.add_right_iff]\n  simp only [(mutuallySingular_singularPart ν μ).symm.compProd_of_left κ η, true_and]\n  refine ⟨fun h ↦ h.mono_ac .rfl ?_, fun h ↦ h.mono_ac .rfl ?_⟩\n  · exact (absolutelyContinuous_withDensity_rnDeriv hμν).compProd_left _\n  · exact (withDensity_absolutelyContinuous μ (ν.rnDeriv μ)).compProd_left _\n\n"}
{"name":"MeasureTheory.Measure.mutuallySingular_compProd_iff","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ ν : MeasureTheory.Measure α\nκ η : ProbabilityTheory.Kernel α β\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\n⊢ Iff ((μ.compProd κ).MutuallySingular (ν.compProd η)) (∀ (ξ : MeasureTheory.Measure α), MeasureTheory.SFinite ξ → ξ.AbsolutelyContinuous μ → ξ.AbsolutelyContinuous ν → (ξ.compProd κ).MutuallySingular (ξ.compProd η))","decl":"lemma mutuallySingular_compProd_iff [SigmaFinite μ] [SigmaFinite ν] :\n    μ ⊗ₘ κ ⟂ₘ ν ⊗ₘ η ↔ ∀ ξ, SFinite ξ → ξ ≪ μ → ξ ≪ ν → ξ ⊗ₘ κ ⟂ₘ ξ ⊗ₘ η := by\n  conv_lhs => rw [μ.haveLebesgueDecomposition_add ν]\n  rw [compProd_add_left, MutuallySingular.add_left_iff]\n  simp only [(mutuallySingular_singularPart μ ν).compProd_of_left κ η, true_and]\n  rw [(withDensity_absolutelyContinuous ν (μ.rnDeriv ν)).mutuallySingular_compProd_iff]\n  refine ⟨fun h ξ hξ hξμ hξν ↦ ?_, fun h ↦ ?_⟩\n  · exact h.mono_ac ((hξμ.withDensity_rnDeriv hξν).compProd_left _)\n      ((hξμ.withDensity_rnDeriv hξν).compProd_left _)\n  · refine h _ ?_ ?_ ?_\n    · infer_instance\n    · exact absolutelyContinuous_of_le (withDensity_rnDeriv_le _ _)\n    · exact withDensity_absolutelyContinuous ν (μ.rnDeriv ν)\n\n"}
{"name":"MeasureTheory.Measure.absolutelyContinuous_compProd_of_compProd","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ ν : MeasureTheory.Measure α\nκ η : ProbabilityTheory.Kernel α β\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhκη : (μ.compProd κ).AbsolutelyContinuous (ν.compProd η)\n⊢ (μ.compProd κ).AbsolutelyContinuous (μ.compProd η)","decl":"lemma absolutelyContinuous_compProd_of_compProd [SigmaFinite μ] [SigmaFinite ν]\n    (hκη : μ ⊗ₘ κ ≪ ν ⊗ₘ η) :\n    μ ⊗ₘ κ ≪ μ ⊗ₘ η := by\n  rw [ν.haveLebesgueDecomposition_add μ, compProd_add_left, add_comm] at hκη\n  have h := absolutelyContinuous_of_add_of_mutuallySingular hκη\n    ((mutuallySingular_singularPart _ _).symm.compProd_of_left _ _)\n  refine h.trans (AbsolutelyContinuous.compProd_left ?_ _)\n  exact withDensity_absolutelyContinuous _ _\n\n"}
{"name":"MeasureTheory.Measure.absolutelyContinuous_compProd_iff","module":"Mathlib.Probability.Kernel.Composition.MeasureCompProd","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ ν : MeasureTheory.Measure α\nκ η : ProbabilityTheory.Kernel α β\ninst✝⁴ : MeasureTheory.SigmaFinite μ\ninst✝³ : MeasureTheory.SigmaFinite ν\ninst✝² : ProbabilityTheory.IsSFiniteKernel κ\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel η\ninst✝ : ∀ (x : α), NeZero (κ x)\n⊢ Iff ((μ.compProd κ).AbsolutelyContinuous (ν.compProd η)) (And (μ.AbsolutelyContinuous ν) ((μ.compProd κ).AbsolutelyContinuous (μ.compProd η)))","decl":"lemma absolutelyContinuous_compProd_iff\n    [SigmaFinite μ] [SigmaFinite ν] [IsSFiniteKernel κ] [IsSFiniteKernel η] [∀ x, NeZero (κ x)] :\n    μ ⊗ₘ κ ≪ ν ⊗ₘ η ↔ μ ≪ ν ∧ μ ⊗ₘ κ ≪ μ ⊗ₘ η :=\n  ⟨fun h ↦ ⟨absolutelyContinuous_of_compProd h, absolutelyContinuous_compProd_of_compProd h⟩,\n    fun h ↦ h.1.compProd_of_compProd h.2⟩\n\n"}
