{"name":"Module.isTrivialRelation_iff_vanishesTrivially","module":"Mathlib.RingTheory.Flat.EquationalCriterion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nι : Type u_3\ninst✝ : Fintype ι\nf : ι → R\nx : ι → M\n⊢ Iff (Module.IsTrivialRelation f x) (TensorProduct.VanishesTrivially R f x)","decl":"/-- `Module.IsTrivialRelation` is equivalent to the predicate `TensorProduct.VanishesTrivially`\ndefined in `Mathlib/LinearAlgebra/TensorProduct/Vanishing.lean`. -/\ntheorem isTrivialRelation_iff_vanishesTrivially :\n    IsTrivialRelation f x ↔ VanishesTrivially R f x := by\n  simp only [IsTrivialRelation, VanishesTrivially, smul_eq_mul, mul_comm]\n\n"}
{"name":"Equiv.isTrivialRelation_comp","module":"Mathlib.RingTheory.Flat.EquationalCriterion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_3\ninst✝¹ : Fintype ι\nf : ι → R\nx : ι → M\nκ : Type u_4\ninst✝ : Fintype κ\ne : Equiv κ ι\n⊢ Iff (Module.IsTrivialRelation (Function.comp f ⇑e) (Function.comp x ⇑e)) (Module.IsTrivialRelation f x)","decl":"theorem _root_.Equiv.isTrivialRelation_comp {κ} [Fintype κ] (e : κ ≃ ι) :\n    IsTrivialRelation (f ∘ e) (x ∘ e) ↔ IsTrivialRelation f x := by\n  simp_rw [isTrivialRelation_iff_vanishesTrivially, e.vanishesTrivially_comp]\n\n"}
{"name":"Module.sum_smul_eq_zero_of_isTrivialRelation","module":"Mathlib.RingTheory.Flat.EquationalCriterion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nι : Type u_3\ninst✝ : Fintype ι\nf : ι → R\nx : ι → M\nh : Module.IsTrivialRelation f x\n⊢ Eq (Finset.univ.sum fun i => HSMul.hSMul (f i) (x i)) 0","decl":"/-- If the relation given by $(f_i)_{i \\in \\iota}$ and $(x_i)_{i \\in \\iota}$ is trivial, then\n$\\sum_i f_i x_i$ is actually equal to $0$. -/\ntheorem sum_smul_eq_zero_of_isTrivialRelation (h : IsTrivialRelation f x) :\n    ∑ i, f i • x i = 0 := by\n  simpa using\n    congr_arg (TensorProduct.lid R M) <|\n      sum_tmul_eq_zero_of_vanishesTrivially R (isTrivialRelation_iff_vanishesTrivially.mp h)\n\n"}
{"name":"Module.Flat.tfae_equational_criterion","module":"Mathlib.RingTheory.Flat.EquationalCriterion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ (List.cons (Module.Flat R M) (List.cons (∀ (I : Ideal R), Function.Injective ⇑(LinearMap.rTensor M (Submodule.subtype I))) (List.cons (∀ {l : Nat} {f : Fin l → R} {x : Fin l → M}, Eq (Finset.univ.sum fun i => TensorProduct.tmul R (f i) (x i)) 0 → TensorProduct.VanishesTrivially R f x) (List.cons (∀ {l : Nat} {f : Fin l → R} {x : Fin l → M}, Eq (Finset.univ.sum fun i => HSMul.hSMul (f i) (x i)) 0 → Module.IsTrivialRelation f x) (List.cons (∀ {l : Nat} {f : Finsupp (Fin l) R} {x : LinearMap (RingHom.id R) (Finsupp (Fin l) R) M}, Eq (x f) 0 → Exists fun k => Exists fun a => Exists fun y => And (Eq x (y.comp a)) (Eq (a f) 0)) List.nil))))).TFAE","decl":"variable (R M) in\n/-- **Equational criterion for flatness**, combined form.\n\nLet $M$ be a module over a commutative ring $R$. The following are equivalent:\n* $M$ is flat.\n* For all ideals $I \\subseteq R$, the map $I \\otimes M \\to M$ is injective.\n* Every $\\sum_i f_i \\otimes x_i$ that vanishes in $R \\otimes M$ vanishes trivially.\n* Every relation $\\sum_i f_i x_i = 0$ in $M$ is trivial.\n* For all finite free modules $R^l$, all elements $f \\in R^l$, and all linear maps\n$x \\colon R^l \\to M$ such that $x(f) = 0$, there exist a finite free module $R^k$ and\nlinear maps $a \\colon R^l \\to R^k$ and $y \\colon R^k \\to M$ such\nthat $x = y \\circ a$ and $a(f) = 0$.\n-/\n@[stacks 00HK, stacks 058D \"except (3)\"]\ntheorem tfae_equational_criterion : List.TFAE [\n    Flat R M,\n    ∀ I : Ideal R, Function.Injective (rTensor M I.subtype),\n    ∀ {l : ℕ} {f : Fin l → R} {x : Fin l → M}, ∑ i, f i ⊗ₜ x i = (0 : R ⊗[R] M) →\n      VanishesTrivially R f x,\n    ∀ {l : ℕ} {f : Fin l → R} {x : Fin l → M}, ∑ i, f i • x i = 0 → IsTrivialRelation f x,\n    ∀ {l : ℕ} {f : Fin l →₀ R} {x : (Fin l →₀ R) →ₗ[R] M}, x f = 0 →\n      ∃ (k : ℕ) (a : (Fin l →₀ R) →ₗ[R] (Fin k →₀ R)) (y : (Fin k →₀ R) →ₗ[R] M),\n        x = y ∘ₗ a ∧ a f = 0] := by\n  classical\n  tfae_have 1 ↔ 2 := iff_rTensor_injective'\n  tfae_have 3 ↔ 2 := forall_vanishesTrivially_iff_forall_rTensor_injective R\n  tfae_have 3 ↔ 4 := by\n    simp [(TensorProduct.lid R M).injective.eq_iff.symm, isTrivialRelation_iff_vanishesTrivially]\n  tfae_have 4 → 5\n  | h₄, l, f, x, hfx => by\n    let f' : Fin l → R := f\n    let x' : Fin l → M := fun i ↦ x (single i 1)\n    have := calc\n      ∑ i, f' i • x' i\n      _ = ∑ i, f i • x (single i 1)         := rfl\n      _ = x (∑ i, f i • Finsupp.single i 1) := by simp_rw [map_sum, map_smul]\n      _ = x f                               := by\n        simp_rw [smul_single, smul_eq_mul, mul_one, univ_sum_single]\n      _ = 0                                 := hfx\n    obtain ⟨k, a', y', ⟨ha'y', ha'⟩⟩ := h₄ this\n    use k\n    use Finsupp.linearCombination R (fun i ↦ equivFunOnFinite.symm (a' i))\n    use Finsupp.linearCombination R y'\n    constructor\n    · apply Finsupp.basisSingleOne.ext\n      intro i\n      simpa [linearCombination_apply, sum_fintype, Finsupp.single_apply] using ha'y' i\n    · ext j\n      simp only [linearCombination_apply, zero_smul, implies_true, sum_fintype, finset_sum_apply]\n      exact ha' j\n  tfae_have 5 → 4\n  | h₅, l, f, x, hfx => by\n    let f' : Fin l →₀ R := equivFunOnFinite.symm f\n    let x' : (Fin l →₀ R) →ₗ[R] M := Finsupp.linearCombination R x\n    have : x' f' = 0 := by simpa [x', f', linearCombination_apply, sum_fintype] using hfx\n    obtain ⟨k, a', y', ha'y', ha'⟩ := h₅ this\n    refine ⟨k, fun i ↦ a' (single i 1), fun j ↦ y' (single j 1), fun i ↦ ?_, fun j ↦ ?_⟩\n    · simpa [x', ← map_smul, ← map_sum, smul_single] using\n        LinearMap.congr_fun ha'y' (Finsupp.single i 1)\n    · simp_rw [← smul_eq_mul, ← Finsupp.smul_apply, ← map_smul, ← finset_sum_apply, ← map_sum,\n        smul_single, smul_eq_mul, mul_one,\n        ← (fun _ ↦ equivFunOnFinite_symm_apply_toFun _ _ : ∀ x, f' x = f x), univ_sum_single]\n      simpa using DFunLike.congr_fun ha' j\n  tfae_finish\n\n"}
{"name":"Module.Flat.iff_forall_isTrivialRelation","module":"Mathlib.RingTheory.Flat.EquationalCriterion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Module.Flat R M) (∀ {l : Nat} {f : Fin l → R} {x : Fin l → M}, Eq (Finset.univ.sum fun i => HSMul.hSMul (f i) (x i)) 0 → Module.IsTrivialRelation f x)","decl":"/-- **Equational criterion for flatness**:\na module $M$ is flat if and only if every relation $\\sum_i f_i x_i = 0$ in $M$ is trivial. -/\n@[stacks 00HK]\ntheorem iff_forall_isTrivialRelation : Flat R M ↔ ∀ {l : ℕ} {f : Fin l → R} {x : Fin l → M},\n    ∑ i, f i • x i = 0 → IsTrivialRelation f x :=\n  (tfae_equational_criterion R M).out 0 3\n\n"}
{"name":"Module.Flat.isTrivialRelation_of_sum_smul_eq_zero","module":"Mathlib.RingTheory.Flat.EquationalCriterion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Flat R M\nι : Type u_3\ninst✝ : Fintype ι\nf : ι → R\nx : ι → M\nh : Eq (Finset.univ.sum fun i => HSMul.hSMul (f i) (x i)) 0\n⊢ Module.IsTrivialRelation f x","decl":"/-- **Equational criterion for flatness**, forward direction.\n\nIf $M$ is flat, then every relation $\\sum_i f_i x_i = 0$ in $M$ is trivial. -/\n@[stacks 00HK]\ntheorem isTrivialRelation_of_sum_smul_eq_zero [Flat R M] {ι : Type*} [Fintype ι] {f : ι → R}\n    {x : ι → M} (h : ∑ i, f i • x i = 0) : IsTrivialRelation f x :=\n  (Fintype.equivFin ι).symm.isTrivialRelation_comp.mp <| iff_forall_isTrivialRelation.mp ‹_› <| by\n    simpa only [← (Fintype.equivFin ι).symm.sum_comp] using h\n\n"}
{"name":"Module.Flat.of_forall_isTrivialRelation","module":"Mathlib.RingTheory.Flat.EquationalCriterion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nhfx : ∀ {l : Nat} {f : Fin l → R} {x : Fin l → M}, Eq (Finset.univ.sum fun i => HSMul.hSMul (f i) (x i)) 0 → Module.IsTrivialRelation f x\n⊢ Module.Flat R M","decl":"/-- **Equational criterion for flatness**, backward direction.\n\nIf every relation $\\sum_i f_i x_i = 0$ in $M$ is trivial, then $M$ is flat. -/\n@[stacks 00HK]\ntheorem of_forall_isTrivialRelation (hfx : ∀ {l : ℕ} {f : Fin l → R} {x : Fin l → M},\n    ∑ i, f i • x i = 0 → IsTrivialRelation f x) : Flat R M :=\n  iff_forall_isTrivialRelation.mpr hfx\n\n"}
{"name":"Module.Flat.iff_forall_exists_factorization","module":"Mathlib.RingTheory.Flat.EquationalCriterion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Module.Flat R M) (∀ {l : Nat} {f : Finsupp (Fin l) R} {x : LinearMap (RingHom.id R) (Finsupp (Fin l) R) M}, Eq (x f) 0 → Exists fun k => Exists fun a => Exists fun y => And (Eq x (y.comp a)) (Eq (a f) 0))","decl":"/-- **Equational criterion for flatness**, alternate form.\n\nA module $M$ is flat if and only if for all finite free modules $R^l$,\nall $f \\in R^l$, and all linear maps $x \\colon R^l \\to M$ such that $x(f) = 0$, there\nexist a finite free module $R^k$ and linear maps $a \\colon R^l \\to R^k$ and\n$y \\colon R^k \\to M$ such that $x = y \\circ a$ and $a(f) = 0$. -/\n@[stacks 058D \"(1) ↔ (2)\"]\ntheorem iff_forall_exists_factorization : Flat R M ↔\n    ∀ {l : ℕ} {f : Fin l →₀ R} {x : (Fin l →₀ R) →ₗ[R] M}, x f = 0 →\n      ∃ (k : ℕ) (a : (Fin l →₀ R) →ₗ[R] (Fin k →₀ R)) (y : (Fin k →₀ R) →ₗ[R] M),\n        x = y ∘ₗ a ∧ a f = 0 := (tfae_equational_criterion R M).out 0 4\n\n"}
{"name":"Module.Flat.of_forall_exists_factorization","module":"Mathlib.RingTheory.Flat.EquationalCriterion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nh : ∀ {l : Nat} {f : Finsupp (Fin l) R} {x : LinearMap (RingHom.id R) (Finsupp (Fin l) R) M}, Eq (x f) 0 → Exists fun k => Exists fun a => Exists fun y => And (Eq x (y.comp a)) (Eq (a f) 0)\n⊢ Module.Flat R M","decl":"/-- **Equational criterion for flatness**, backward direction, alternate form.\n\nLet $M$ be a module over a commutative ring $R$. Suppose that for all finite free modules $R^l$,\nall $f \\in R^l$, and all linear maps $x \\colon R^l \\to M$ such that $x(f) = 0$, there\nexist a finite free module $R^k$ and linear maps $a \\colon R^l \\to R^k$ and\n$y \\colon R^k \\to M$ such that $x = y \\circ a$ and $a(f) = 0$. Then $M$ is flat. -/\n@[stacks 058D \"(2) → (1)\"]\ntheorem of_forall_exists_factorization\n    (h : ∀ {l : ℕ} {f : Fin l →₀ R} {x : (Fin l →₀ R) →ₗ[R] M}, x f = 0 →\n      ∃ (k : ℕ) (a : (Fin l →₀ R) →ₗ[R] (Fin k →₀ R)) (y : (Fin k →₀ R) →ₗ[R] M),\n      x = y ∘ₗ a ∧ a f = 0) : Flat R M := iff_forall_exists_factorization.mpr h\n\n"}
{"name":"Module.Flat.exists_factorization_of_apply_eq_zero_of_free","module":"Mathlib.RingTheory.Flat.EquationalCriterion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁷ : CommRing R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : Module.Flat R M\nN : Type u_3\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : Module.Free R N\ninst✝ : Module.Finite R N\nf : N\nx : LinearMap (RingHom.id R) N M\nh : Eq (x f) 0\n⊢ Exists fun k => Exists fun a => Exists fun y => And (Eq x (y.comp a)) (Eq (a f) 0)","decl":"/-- **Equational criterion for flatness**, forward direction, second alternate form.\n\nLet $M$ be a flat module over a commutative ring $R$. Let $N$ be a finite free module over $R$,\nlet $f \\in N$, and let $x \\colon N \\to M$ be a linear map such that $x(f) = 0$. Then there exist a\nfinite free module $R^k$ and linear maps $a \\colon N \\to R^k$ and\n$y \\colon R^k \\to M$ such that $x = y \\circ a$ and $a(f) = 0$. -/\n@[stacks 058D \"(1) → (2)\"]\ntheorem exists_factorization_of_apply_eq_zero_of_free [Flat R M] {N : Type*} [AddCommGroup N]\n    [Module R N] [Free R N] [Module.Finite R N] {f : N} {x : N →ₗ[R] M} (h : x f = 0) :\n    ∃ (k : ℕ) (a : N →ₗ[R] (Fin k →₀ R)) (y : (Fin k →₀ R) →ₗ[R] M), x = y ∘ₗ a ∧ a f = 0 :=\n  have e := ((Module.Free.chooseBasis R N).reindex (Fintype.equivFin _)).repr.symm\n  have ⟨k, a, y, hya, haf⟩ := iff_forall_exists_factorization.mp ‹Flat R M›\n    (f := e.symm f) (x := x ∘ₗ e) (by simpa using h)\n  ⟨k, a ∘ₗ e.symm, y, by rwa [← comp_assoc, LinearEquiv.eq_comp_toLinearMap_symm], haf⟩\n\n"}
{"name":"Module.Flat.exists_factorization_of_apply_eq_zero","module":"Mathlib.RingTheory.Flat.EquationalCriterion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁷ : CommRing R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : Module.Flat R M\nN : Type u_3\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : Module.Free R N\ninst✝ : Module.Finite R N\nf : N\nx : LinearMap (RingHom.id R) N M\nh : Eq (x f) 0\n⊢ Exists fun k => Exists fun a => Exists fun y => And (Eq x (y.comp a)) (Eq (a f) 0)","decl":"@[deprecated (since := \"2025-01-03\")] alias exists_factorization_of_apply_eq_zero :=\n  exists_factorization_of_apply_eq_zero_of_free\n\n"}
{"name":"Module.Flat.exists_factorization_of_comp_eq_zero_of_free","module":"Mathlib.RingTheory.Flat.EquationalCriterion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : AddCommGroup M\ninst✝⁸ : Module R M\ninst✝⁷ : Module.Flat R M\nK : Type u_3\nN : Type u_4\ninst✝⁶ : AddCommGroup K\ninst✝⁵ : Module R K\ninst✝⁴ : Module.Finite R K\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : Module.Free R N\ninst✝ : Module.Finite R N\nf : LinearMap (RingHom.id R) K N\nx : LinearMap (RingHom.id R) N M\nh : Eq (x.comp f) 0\n⊢ Exists fun k => Exists fun a => Exists fun y => And (Eq x (y.comp a)) (Eq (a.comp f) 0)","decl":"/-- Let $M$ be a flat module. Let $K$ and $N$ be finite $R$-modules with $N$\nfree, and let $f \\colon K \\to N$ and $x \\colon N \\to M$ be linear maps such that\n$x \\circ f = 0$. Then there exist a finite free module $R^k$ and linear maps\n$a \\colon N \\to R^k$ and $y \\colon R^k \\to M$ such that $x = y \\circ a$ and\n$a \\circ f = 0$. -/\n@[stacks 058D \"(1) → (4)\"]\ntheorem exists_factorization_of_comp_eq_zero_of_free [Flat R M] {K N : Type*} [AddCommGroup K]\n    [Module R K] [Module.Finite R K] [AddCommGroup N] [Module R N] [Free R N] [Module.Finite R N]\n    {f : K →ₗ[R] N} {x : N →ₗ[R] M} (h : x ∘ₗ f = 0) :\n    ∃ (k : ℕ) (a : N →ₗ[R] (Fin k →₀ R)) (y : (Fin k →₀ R) →ₗ[R] M),\n      x = y ∘ₗ a ∧ a ∘ₗ f = 0 :=\n  have e := ((Module.Free.chooseBasis R N).reindex (Fintype.equivFin _)).repr.symm\n  have ⟨k, a, y, hya, haf⟩ := exists_factorization_of_comp_eq_zero_of_free_aux\n    (f := e.symm ∘ₗ f) (x := x ∘ₗ e.toLinearMap) (by ext; simpa [comp_assoc] using congr($h _))\n  ⟨k, a ∘ₗ e.symm, y, by rwa [← comp_assoc, LinearEquiv.eq_comp_toLinearMap_symm], by\n    rwa [comp_assoc]⟩\n\n"}
{"name":"Module.Flat.exists_factorization_of_isFinitelyPresented","module":"Mathlib.RingTheory.Flat.EquationalCriterion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : Module.Flat R M\nP : Type u_3\ninst✝² : AddCommGroup P\ninst✝¹ : Module R P\ninst✝ : Module.FinitePresentation R P\nh₁ : LinearMap (RingHom.id R) P M\n⊢ Exists fun k => Exists fun h₂ => Exists fun h₃ => Eq h₁ (h₃.comp h₂)","decl":"/-- Every homomorphism from a finitely presented module to a flat module factors through a finite\nfree module. -/\n@[stacks 058E \"only if\"]\ntheorem exists_factorization_of_isFinitelyPresented [Flat R M] {P : Type*} [AddCommGroup P]\n    [Module R P] [FinitePresentation R P] (h₁ : P →ₗ[R] M) :\n      ∃ (k : ℕ) (h₂ : P →ₗ[R] (Fin k →₀ R)) (h₃ : (Fin k →₀ R) →ₗ[R] M), h₁ = h₃ ∘ₗ h₂ := by\n  have ⟨_, K, ϕ, hK⟩ := FinitePresentation.exists_fin R P\n  haveI : Module.Finite R K := Module.Finite.iff_fg.mpr hK\n  have : (h₁ ∘ₗ ϕ.symm ∘ₗ K.mkQ) ∘ₗ K.subtype = 0 := by\n    simp_rw [comp_assoc, (LinearMap.exact_subtype_mkQ K).linearMap_comp_eq_zero, comp_zero]\n  obtain ⟨k, a, y, hay, ha⟩ := exists_factorization_of_comp_eq_zero_of_free this\n  use k, (K.liftQ a (by rwa [← range_le_ker_iff, Submodule.range_subtype] at ha)) ∘ₗ ϕ, y\n  apply (cancel_right ϕ.symm.surjective).mp\n  apply (cancel_right K.mkQ_surjective).mp\n  simpa [comp_assoc]\n\n"}
{"name":"Module.Flat.projective_of_finitePresentation","module":"Mathlib.RingTheory.Flat.EquationalCriterion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Flat R M\ninst✝ : Module.FinitePresentation R M\n⊢ Module.Projective R M","decl":"@[stacks 00NX \"(1) → (2)\"]\ntheorem projective_of_finitePresentation [Flat R M] [FinitePresentation R M] : Projective R M :=\n  have ⟨_, f, g, eq⟩ := exists_factorization_of_isFinitelyPresented (.id (R := R) (M := M))\n  .of_split f g eq.symm\n\n"}
