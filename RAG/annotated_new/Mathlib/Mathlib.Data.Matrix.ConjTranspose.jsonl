{"name":"Matrix.conjTranspose_stdBasisMatrix","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝³ : DecidableEq n\ninst✝² : DecidableEq m\ninst✝¹ : AddMonoid α\ninst✝ : StarAddMonoid α\ni : m\nj : n\na : α\n⊢ Eq (Matrix.stdBasisMatrix i j a).conjTranspose (Matrix.stdBasisMatrix j i (Star.star a))","decl":"@[simp]\nlemma conjTranspose_stdBasisMatrix [DecidableEq n] [DecidableEq m] [AddMonoid α]\n    [StarAddMonoid α] (i : m) (j : n) (a : α) :\n    (stdBasisMatrix i j a)ᴴ = stdBasisMatrix j i (star a) := by\n  show (stdBasisMatrix i j a).transpose.map starAddEquiv = stdBasisMatrix j i (star a)\n  simp\n\n"}
{"name":"Matrix.diagonal_conjTranspose","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : DecidableEq n\ninst✝¹ : AddMonoid α\ninst✝ : StarAddMonoid α\nv : n → α\n⊢ Eq (Matrix.diagonal v).conjTranspose (Matrix.diagonal (Star.star v))","decl":"@[simp]\ntheorem diagonal_conjTranspose [AddMonoid α] [StarAddMonoid α] (v : n → α) :\n    (diagonal v)ᴴ = diagonal (star v) := by\n  rw [conjTranspose, diagonal_transpose, diagonal_map (star_zero _)]\n  rfl\n\n"}
{"name":"Matrix.diag_conjTranspose","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : AddMonoid α\ninst✝ : StarAddMonoid α\nA : Matrix n n α\n⊢ Eq A.conjTranspose.diag (Star.star A.diag)","decl":"@[simp]\ntheorem diag_conjTranspose [AddMonoid α] [StarAddMonoid α] (A : Matrix n n α) :\n    diag Aᴴ = star (diag A) :=\n  rfl\n\n"}
{"name":"Matrix.star_dotProduct_star","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : NonUnitalSemiring α\ninst✝ : StarRing α\nv w : m → α\n⊢ Eq (dotProduct (Star.star v) (Star.star w)) (Star.star (dotProduct w v))","decl":"theorem star_dotProduct_star : star v ⬝ᵥ star w = star (w ⬝ᵥ v) := by simp [dotProduct]\n\n"}
{"name":"Matrix.star_dotProduct","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : NonUnitalSemiring α\ninst✝ : StarRing α\nv w : m → α\n⊢ Eq (dotProduct (Star.star v) w) (Star.star (dotProduct (Star.star w) v))","decl":"theorem star_dotProduct : star v ⬝ᵥ w = star (star w ⬝ᵥ v) := by simp [dotProduct]\n\n"}
{"name":"Matrix.dotProduct_star","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : NonUnitalSemiring α\ninst✝ : StarRing α\nv w : m → α\n⊢ Eq (dotProduct v (Star.star w)) (Star.star (dotProduct w (Star.star v)))","decl":"theorem dotProduct_star : v ⬝ᵥ star w = star (w ⬝ᵥ star v) := by simp [dotProduct]\n\n"}
{"name":"Matrix.star_mulVec","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : NonUnitalSemiring α\ninst✝¹ : Fintype n\ninst✝ : StarRing α\nM : Matrix m n α\nv : n → α\n⊢ Eq (Star.star (M.mulVec v)) (Matrix.vecMul (Star.star v) M.conjTranspose)","decl":"theorem star_mulVec [Fintype n] [StarRing α] (M : Matrix m n α) (v : n → α) :\n    star (M *ᵥ v) = star v ᵥ* Mᴴ :=\n  funext fun _ => (star_dotProduct_star _ _).symm\n\n"}
{"name":"Matrix.star_vecMul","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : NonUnitalSemiring α\ninst✝¹ : Fintype m\ninst✝ : StarRing α\nM : Matrix m n α\nv : m → α\n⊢ Eq (Star.star (Matrix.vecMul v M)) (M.conjTranspose.mulVec (Star.star v))","decl":"theorem star_vecMul [Fintype m] [StarRing α] (M : Matrix m n α) (v : m → α) :\n    star (v ᵥ* M) = Mᴴ *ᵥ star v :=\n  funext fun _ => (star_dotProduct_star _ _).symm\n\n"}
{"name":"Matrix.mulVec_conjTranspose","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : NonUnitalSemiring α\ninst✝¹ : Fintype m\ninst✝ : StarRing α\nA : Matrix m n α\nx : m → α\n⊢ Eq (A.conjTranspose.mulVec x) (Star.star (Matrix.vecMul (Star.star x) A))","decl":"theorem mulVec_conjTranspose [Fintype m] [StarRing α] (A : Matrix m n α) (x : m → α) :\n    Aᴴ *ᵥ x = star (star x ᵥ* A) :=\n  funext fun _ => star_dotProduct _ _\n\n"}
{"name":"Matrix.vecMul_conjTranspose","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : NonUnitalSemiring α\ninst✝¹ : Fintype n\ninst✝ : StarRing α\nA : Matrix m n α\nx : n → α\n⊢ Eq (Matrix.vecMul x A.conjTranspose) (Star.star (A.mulVec (Star.star x)))","decl":"theorem vecMul_conjTranspose [Fintype n] [StarRing α] (A : Matrix m n α) (x : n → α) :\n    x ᵥ* Aᴴ = star (A *ᵥ star x) :=\n  funext fun _ => dotProduct_star _ _\n\n"}
{"name":"Matrix.conjTranspose_apply","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : Star α\nM : Matrix m n α\ni : m\nj : n\n⊢ Eq (M.conjTranspose j i) (Star.star (M i j))","decl":"/-- Tell `simp` what the entries are in a conjugate transposed matrix.\n\n  Compare with `mul_apply`, `diagonal_apply_eq`, etc.\n-/\n@[simp]\ntheorem conjTranspose_apply [Star α] (M : Matrix m n α) (i j) :\n    M.conjTranspose j i = star (M i j) :=\n  rfl\n\n"}
{"name":"Matrix.conjTranspose_conjTranspose","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : InvolutiveStar α\nM : Matrix m n α\n⊢ Eq M.conjTranspose.conjTranspose M","decl":"@[simp]\ntheorem conjTranspose_conjTranspose [InvolutiveStar α] (M : Matrix m n α) : Mᴴᴴ = M :=\n  Matrix.ext <| by simp\n\n"}
{"name":"Matrix.conjTranspose_injective","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : InvolutiveStar α\n⊢ Function.Injective Matrix.conjTranspose","decl":"theorem conjTranspose_injective [InvolutiveStar α] :\n    Function.Injective (conjTranspose : Matrix m n α → Matrix n m α) :=\n  (map_injective star_injective).comp transpose_injective\n\n"}
{"name":"Matrix.conjTranspose_inj","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : InvolutiveStar α\nA B : Matrix m n α\n⊢ Iff (Eq A.conjTranspose B.conjTranspose) (Eq A B)","decl":"@[simp] theorem conjTranspose_inj [InvolutiveStar α] {A B : Matrix m n α} : Aᴴ = Bᴴ ↔ A = B :=\n  conjTranspose_injective.eq_iff\n\n"}
{"name":"Matrix.conjTranspose_eq_diagonal","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : DecidableEq n\ninst✝¹ : AddMonoid α\ninst✝ : StarAddMonoid α\nM : Matrix n n α\nv : n → α\n⊢ Iff (Eq M.conjTranspose (Matrix.diagonal v)) (Eq M (Matrix.diagonal (Star.star v)))","decl":"@[simp]\ntheorem conjTranspose_eq_diagonal [DecidableEq n] [AddMonoid α] [StarAddMonoid α]\n    {M : Matrix n n α} {v : n → α} :\n    Mᴴ = diagonal v ↔ M = diagonal (star v) :=\n  (Function.Involutive.eq_iff conjTranspose_conjTranspose).trans <|\n    by rw [diagonal_conjTranspose]\n\n"}
{"name":"Matrix.conjTranspose_zero","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : AddMonoid α\ninst✝ : StarAddMonoid α\n⊢ Eq (Matrix.conjTranspose 0) 0","decl":"@[simp]\ntheorem conjTranspose_zero [AddMonoid α] [StarAddMonoid α] : (0 : Matrix m n α)ᴴ = 0 :=\n  Matrix.ext <| by simp\n\n"}
{"name":"Matrix.conjTranspose_eq_zero","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : AddMonoid α\ninst✝ : StarAddMonoid α\nM : Matrix m n α\n⊢ Iff (Eq M.conjTranspose 0) (Eq M 0)","decl":"@[simp]\ntheorem conjTranspose_eq_zero [AddMonoid α] [StarAddMonoid α] {M : Matrix m n α} :\n    Mᴴ = 0 ↔ M = 0 := by\n  rw [← conjTranspose_inj (A := M), conjTranspose_zero]\n\n"}
{"name":"Matrix.conjTranspose_one","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Semiring α\ninst✝ : StarRing α\n⊢ Eq (Matrix.conjTranspose 1) 1","decl":"@[simp]\ntheorem conjTranspose_one [DecidableEq n] [Semiring α] [StarRing α] : (1 : Matrix n n α)ᴴ = 1 := by\n  simp [conjTranspose]\n\n"}
{"name":"Matrix.conjTranspose_eq_one","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Semiring α\ninst✝ : StarRing α\nM : Matrix n n α\n⊢ Iff (Eq M.conjTranspose 1) (Eq M 1)","decl":"@[simp]\ntheorem conjTranspose_eq_one [DecidableEq n] [Semiring α] [StarRing α] {M : Matrix n n α} :\n    Mᴴ = 1 ↔ M = 1 :=\n  (Function.Involutive.eq_iff conjTranspose_conjTranspose).trans <|\n    by rw [conjTranspose_one]\n\n"}
{"name":"Matrix.conjTranspose_natCast","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Semiring α\ninst✝ : StarRing α\nd : Nat\n⊢ Eq (↑d).conjTranspose ↑d","decl":"@[simp]\ntheorem conjTranspose_natCast [DecidableEq n] [Semiring α] [StarRing α] (d : ℕ) :\n    (d : Matrix n n α)ᴴ = d := by\n  simp [conjTranspose, Matrix.map_natCast, diagonal_natCast]\n\n"}
{"name":"Matrix.conjTranspose_eq_natCast","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Semiring α\ninst✝ : StarRing α\nM : Matrix n n α\nd : Nat\n⊢ Iff (Eq M.conjTranspose ↑d) (Eq M ↑d)","decl":"@[simp]\ntheorem conjTranspose_eq_natCast [DecidableEq n] [Semiring α] [StarRing α]\n    {M : Matrix n n α} {d : ℕ} :\n    Mᴴ = d ↔ M = d :=\n  (Function.Involutive.eq_iff conjTranspose_conjTranspose).trans <|\n    by rw [conjTranspose_natCast]\n\n"}
{"name":"Matrix.conjTranspose_ofNat","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"n : Type u_3\nα : Type v\ninst✝³ : DecidableEq n\ninst✝² : Semiring α\ninst✝¹ : StarRing α\nd : Nat\ninst✝ : d.AtLeastTwo\n⊢ Eq (OfNat.ofNat d).conjTranspose (OfNat.ofNat d)","decl":"@[simp]\ntheorem conjTranspose_ofNat [DecidableEq n] [Semiring α] [StarRing α] (d : ℕ) [d.AtLeastTwo] :\n    (ofNat(d) : Matrix n n α)ᴴ = OfNat.ofNat d :=\n  conjTranspose_natCast _\n\n"}
{"name":"Matrix.conjTranspose_eq_ofNat","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"n : Type u_3\nα : Type v\ninst✝³ : DecidableEq n\ninst✝² : Semiring α\ninst✝¹ : StarRing α\nM : Matrix n n α\nd : Nat\ninst✝ : d.AtLeastTwo\n⊢ Iff (Eq M.conjTranspose (OfNat.ofNat d)) (Eq M (OfNat.ofNat d))","decl":"@[simp]\ntheorem conjTranspose_eq_ofNat [DecidableEq n] [Semiring α] [StarRing α]\n    {M : Matrix n n α} {d : ℕ} [d.AtLeastTwo] :\n    Mᴴ = ofNat(d) ↔ M = OfNat.ofNat d :=\n  conjTranspose_eq_natCast\n\n"}
{"name":"Matrix.conjTranspose_intCast","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Ring α\ninst✝ : StarRing α\nd : Int\n⊢ Eq (↑d).conjTranspose ↑d","decl":"@[simp]\ntheorem conjTranspose_intCast [DecidableEq n] [Ring α] [StarRing α] (d : ℤ) :\n    (d : Matrix n n α)ᴴ = d := by\n  simp [conjTranspose, Matrix.map_intCast, diagonal_intCast]\n\n"}
{"name":"Matrix.conjTranspose_eq_intCast","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Ring α\ninst✝ : StarRing α\nM : Matrix n n α\nd : Int\n⊢ Iff (Eq M.conjTranspose ↑d) (Eq M ↑d)","decl":"@[simp]\ntheorem conjTranspose_eq_intCast [DecidableEq n] [Ring α] [StarRing α]\n    {M : Matrix n n α} {d : ℤ} :\n    Mᴴ = d ↔ M = d :=\n  (Function.Involutive.eq_iff conjTranspose_conjTranspose).trans <|\n    by rw [conjTranspose_intCast]\n\n"}
{"name":"Matrix.conjTranspose_add","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : AddMonoid α\ninst✝ : StarAddMonoid α\nM N : Matrix m n α\n⊢ Eq (HAdd.hAdd M N).conjTranspose (HAdd.hAdd M.conjTranspose N.conjTranspose)","decl":"@[simp]\ntheorem conjTranspose_add [AddMonoid α] [StarAddMonoid α] (M N : Matrix m n α) :\n    (M + N)ᴴ = Mᴴ + Nᴴ :=\n  Matrix.ext <| by simp\n\n"}
{"name":"Matrix.conjTranspose_sub","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : AddGroup α\ninst✝ : StarAddMonoid α\nM N : Matrix m n α\n⊢ Eq (HSub.hSub M N).conjTranspose (HSub.hSub M.conjTranspose N.conjTranspose)","decl":"@[simp]\ntheorem conjTranspose_sub [AddGroup α] [StarAddMonoid α] (M N : Matrix m n α) :\n    (M - N)ᴴ = Mᴴ - Nᴴ :=\n  Matrix.ext <| by simp\n\n"}
{"name":"Matrix.conjTranspose_smul","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝³ : Star R\ninst✝² : Star α\ninst✝¹ : SMul R α\ninst✝ : StarModule R α\nc : R\nM : Matrix m n α\n⊢ Eq (HSMul.hSMul c M).conjTranspose (HSMul.hSMul (Star.star c) M.conjTranspose)","decl":"/-- Note that `StarModule` is quite a strong requirement; as such we also provide the following\nvariants which this lemma would not apply to:\n* `Matrix.conjTranspose_smul_non_comm`\n* `Matrix.conjTranspose_nsmul`\n* `Matrix.conjTranspose_zsmul`\n* `Matrix.conjTranspose_natCast_smul`\n* `Matrix.conjTranspose_intCast_smul`\n* `Matrix.conjTranspose_inv_natCast_smul`\n* `Matrix.conjTranspose_inv_intCast_smul`\n* `Matrix.conjTranspose_ratCast_smul`\n-/\n@[simp]\ntheorem conjTranspose_smul [Star R] [Star α] [SMul R α] [StarModule R α] (c : R)\n    (M : Matrix m n α) : (c • M)ᴴ = star c • Mᴴ :=\n  Matrix.ext fun _ _ => star_smul _ _\n\n"}
{"name":"Matrix.conjTranspose_smul_non_comm","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝³ : Star R\ninst✝² : Star α\ninst✝¹ : SMul R α\ninst✝ : SMul (MulOpposite R) α\nc : R\nM : Matrix m n α\nh : ∀ (r : R) (a : α), Eq (Star.star (HSMul.hSMul r a)) (HSMul.hSMul (MulOpposite.op (Star.star r)) (Star.star a))\n⊢ Eq (HSMul.hSMul c M).conjTranspose (HSMul.hSMul (MulOpposite.op (Star.star c)) M.conjTranspose)","decl":"@[simp]\ntheorem conjTranspose_smul_non_comm [Star R] [Star α] [SMul R α] [SMul Rᵐᵒᵖ α] (c : R)\n    (M : Matrix m n α) (h : ∀ (r : R) (a : α), star (r • a) = MulOpposite.op (star r) • star a) :\n    (c • M)ᴴ = MulOpposite.op (star c) • Mᴴ :=\n  Matrix.ext <| by simp [h]\n\n"}
{"name":"Matrix.conjTranspose_smul_self","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : Mul α\ninst✝ : StarMul α\nc : α\nM : Matrix m n α\n⊢ Eq (HSMul.hSMul c M).conjTranspose (HSMul.hSMul (MulOpposite.op (Star.star c)) M.conjTranspose)","decl":"theorem conjTranspose_smul_self [Mul α] [StarMul α] (c : α) (M : Matrix m n α) :\n    (c • M)ᴴ = MulOpposite.op (star c) • Mᴴ :=\n  conjTranspose_smul_non_comm c M star_mul\n\n"}
{"name":"Matrix.conjTranspose_nsmul","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : AddMonoid α\ninst✝ : StarAddMonoid α\nc : Nat\nM : Matrix m n α\n⊢ Eq (HSMul.hSMul c M).conjTranspose (HSMul.hSMul c M.conjTranspose)","decl":"@[simp]\ntheorem conjTranspose_nsmul [AddMonoid α] [StarAddMonoid α] (c : ℕ) (M : Matrix m n α) :\n    (c • M)ᴴ = c • Mᴴ :=\n  Matrix.ext <| by simp\n\n"}
{"name":"Matrix.conjTranspose_zsmul","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : AddGroup α\ninst✝ : StarAddMonoid α\nc : Int\nM : Matrix m n α\n⊢ Eq (HSMul.hSMul c M).conjTranspose (HSMul.hSMul c M.conjTranspose)","decl":"@[simp]\ntheorem conjTranspose_zsmul [AddGroup α] [StarAddMonoid α] (c : ℤ) (M : Matrix m n α) :\n    (c • M)ᴴ = c • Mᴴ :=\n  Matrix.ext <| by simp\n\n"}
{"name":"Matrix.conjTranspose_natCast_smul","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid α\ninst✝¹ : StarAddMonoid α\ninst✝ : Module R α\nc : Nat\nM : Matrix m n α\n⊢ Eq (HSMul.hSMul (↑c) M).conjTranspose (HSMul.hSMul (↑c) M.conjTranspose)","decl":"@[simp]\ntheorem conjTranspose_natCast_smul [Semiring R] [AddCommMonoid α] [StarAddMonoid α] [Module R α]\n    (c : ℕ) (M : Matrix m n α) : ((c : R) • M)ᴴ = (c : R) • Mᴴ :=\n  Matrix.ext <| by simp\n\n"}
{"name":"Matrix.conjTranspose_ofNat_smul","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid α\ninst✝² : StarAddMonoid α\ninst✝¹ : Module R α\nc : Nat\ninst✝ : c.AtLeastTwo\nM : Matrix m n α\n⊢ Eq (HSMul.hSMul (OfNat.ofNat c) M).conjTranspose (HSMul.hSMul (OfNat.ofNat c) M.conjTranspose)","decl":"@[simp]\ntheorem conjTranspose_ofNat_smul [Semiring R] [AddCommMonoid α] [StarAddMonoid α] [Module R α]\n    (c : ℕ) [c.AtLeastTwo] (M : Matrix m n α) :\n    ((ofNat(c) : R) • M)ᴴ = (OfNat.ofNat c : R) • Mᴴ :=\n  conjTranspose_natCast_smul c M\n\n"}
{"name":"Matrix.conjTranspose_intCast_smul","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝³ : Ring R\ninst✝² : AddCommGroup α\ninst✝¹ : StarAddMonoid α\ninst✝ : Module R α\nc : Int\nM : Matrix m n α\n⊢ Eq (HSMul.hSMul (↑c) M).conjTranspose (HSMul.hSMul (↑c) M.conjTranspose)","decl":"@[simp]\ntheorem conjTranspose_intCast_smul [Ring R] [AddCommGroup α] [StarAddMonoid α] [Module R α] (c : ℤ)\n    (M : Matrix m n α) : ((c : R) • M)ᴴ = (c : R) • Mᴴ :=\n  Matrix.ext <| by simp\n\n"}
{"name":"Matrix.conjTranspose_inv_natCast_smul","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝³ : DivisionSemiring R\ninst✝² : AddCommMonoid α\ninst✝¹ : StarAddMonoid α\ninst✝ : Module R α\nc : Nat\nM : Matrix m n α\n⊢ Eq (HSMul.hSMul (Inv.inv ↑c) M).conjTranspose (HSMul.hSMul (Inv.inv ↑c) M.conjTranspose)","decl":"@[simp]\ntheorem conjTranspose_inv_natCast_smul [DivisionSemiring R] [AddCommMonoid α] [StarAddMonoid α]\n    [Module R α] (c : ℕ) (M : Matrix m n α) : ((c : R)⁻¹ • M)ᴴ = (c : R)⁻¹ • Mᴴ :=\n  Matrix.ext <| by simp\n\n"}
{"name":"Matrix.conjTranspose_inv_ofNat_smul","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝⁴ : DivisionSemiring R\ninst✝³ : AddCommMonoid α\ninst✝² : StarAddMonoid α\ninst✝¹ : Module R α\nc : Nat\ninst✝ : c.AtLeastTwo\nM : Matrix m n α\n⊢ Eq (HSMul.hSMul (Inv.inv (OfNat.ofNat c)) M).conjTranspose (HSMul.hSMul (Inv.inv (OfNat.ofNat c)) M.conjTranspose)","decl":"@[simp]\ntheorem conjTranspose_inv_ofNat_smul [DivisionSemiring R] [AddCommMonoid α] [StarAddMonoid α]\n    [Module R α] (c : ℕ) [c.AtLeastTwo] (M : Matrix m n α) :\n    ((ofNat(c) : R)⁻¹ • M)ᴴ = (OfNat.ofNat c : R)⁻¹ • Mᴴ :=\n  conjTranspose_inv_natCast_smul c M\n\n"}
{"name":"Matrix.conjTranspose_inv_intCast_smul","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝³ : DivisionRing R\ninst✝² : AddCommGroup α\ninst✝¹ : StarAddMonoid α\ninst✝ : Module R α\nc : Int\nM : Matrix m n α\n⊢ Eq (HSMul.hSMul (Inv.inv ↑c) M).conjTranspose (HSMul.hSMul (Inv.inv ↑c) M.conjTranspose)","decl":"@[simp]\ntheorem conjTranspose_inv_intCast_smul [DivisionRing R] [AddCommGroup α] [StarAddMonoid α]\n    [Module R α] (c : ℤ) (M : Matrix m n α) : ((c : R)⁻¹ • M)ᴴ = (c : R)⁻¹ • Mᴴ :=\n  Matrix.ext <| by simp\n\n"}
{"name":"Matrix.conjTranspose_ratCast_smul","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝³ : DivisionRing R\ninst✝² : AddCommGroup α\ninst✝¹ : StarAddMonoid α\ninst✝ : Module R α\nc : Rat\nM : Matrix m n α\n⊢ Eq (HSMul.hSMul (↑c) M).conjTranspose (HSMul.hSMul (↑c) M.conjTranspose)","decl":"@[simp]\ntheorem conjTranspose_ratCast_smul [DivisionRing R] [AddCommGroup α] [StarAddMonoid α] [Module R α]\n    (c : ℚ) (M : Matrix m n α) : ((c : R) • M)ᴴ = (c : R) • Mᴴ :=\n  Matrix.ext <| by simp\n\n"}
{"name":"Matrix.conjTranspose_rat_smul","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : AddCommGroup α\ninst✝¹ : StarAddMonoid α\ninst✝ : Module Rat α\nc : Rat\nM : Matrix m n α\n⊢ Eq (HSMul.hSMul c M).conjTranspose (HSMul.hSMul c M.conjTranspose)","decl":"theorem conjTranspose_rat_smul [AddCommGroup α] [StarAddMonoid α] [Module ℚ α] (c : ℚ)\n    (M : Matrix m n α) : (c • M)ᴴ = c • Mᴴ :=\n  Matrix.ext <| by simp\n\n"}
{"name":"Matrix.conjTranspose_mul","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : NonUnitalSemiring α\ninst✝ : StarRing α\nM : Matrix m n α\nN : Matrix n l α\n⊢ Eq (HMul.hMul M N).conjTranspose (HMul.hMul N.conjTranspose M.conjTranspose)","decl":"@[simp]\ntheorem conjTranspose_mul [Fintype n] [NonUnitalSemiring α] [StarRing α] (M : Matrix m n α)\n    (N : Matrix n l α) : (M * N)ᴴ = Nᴴ * Mᴴ :=\n  Matrix.ext <| by simp [mul_apply]\n\n"}
{"name":"Matrix.conjTranspose_neg","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : AddGroup α\ninst✝ : StarAddMonoid α\nM : Matrix m n α\n⊢ Eq (Neg.neg M).conjTranspose (Neg.neg M.conjTranspose)","decl":"@[simp]\ntheorem conjTranspose_neg [AddGroup α] [StarAddMonoid α] (M : Matrix m n α) : (-M)ᴴ = -Mᴴ :=\n  Matrix.ext <| by simp\n\n"}
{"name":"Matrix.conjTranspose_map","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nβ : Type w\ninst✝¹ : Star α\ninst✝ : Star β\nA : Matrix m n α\nf : α → β\nhf : Function.Semiconj f Star.star Star.star\n⊢ Eq (A.conjTranspose.map f) (A.map f).conjTranspose","decl":"theorem conjTranspose_map [Star α] [Star β] {A : Matrix m n α} (f : α → β)\n    (hf : Function.Semiconj f star star) : Aᴴ.map f = (A.map f)ᴴ :=\n  Matrix.ext fun _ _ => hf _\n\n"}
{"name":"Matrix.conjTranspose_eq_transpose_of_trivial","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : Star α\ninst✝ : TrivialStar α\nA : Matrix m n α\n⊢ Eq A.conjTranspose A.transpose","decl":"/-- When `star x = x` on the coefficients (such as the real numbers) `conjTranspose` and `transpose`\nare the same operation. -/\n@[simp]\ntheorem conjTranspose_eq_transpose_of_trivial [Star α] [TrivialStar α] (A : Matrix m n α) :\n    Aᴴ = Aᵀ := Matrix.ext fun _ _ => star_trivial _\n\n"}
{"name":"Matrix.conjTransposeAddEquiv_apply","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : AddMonoid α\ninst✝ : StarAddMonoid α\nM : Matrix m n α\n⊢ Eq ((Matrix.conjTransposeAddEquiv m n α) M) M.conjTranspose","decl":"/-- `Matrix.conjTranspose` as an `AddEquiv` -/\n@[simps apply]\ndef conjTransposeAddEquiv [AddMonoid α] [StarAddMonoid α] : Matrix m n α ≃+ Matrix n m α where\n  toFun := conjTranspose\n  invFun := conjTranspose\n  left_inv := conjTranspose_conjTranspose\n  right_inv := conjTranspose_conjTranspose\n  map_add' := conjTranspose_add\n\n"}
{"name":"Matrix.conjTransposeAddEquiv_symm","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : AddMonoid α\ninst✝ : StarAddMonoid α\n⊢ Eq (Matrix.conjTransposeAddEquiv m n α).symm (Matrix.conjTransposeAddEquiv n m α)","decl":"@[simp]\ntheorem conjTransposeAddEquiv_symm [AddMonoid α] [StarAddMonoid α] :\n    (conjTransposeAddEquiv m n α).symm = conjTransposeAddEquiv n m α :=\n  rfl\n\n"}
{"name":"Matrix.conjTranspose_list_sum","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : AddMonoid α\ninst✝ : StarAddMonoid α\nl : List (Matrix m n α)\n⊢ Eq l.sum.conjTranspose (List.map Matrix.conjTranspose l).sum","decl":"theorem conjTranspose_list_sum [AddMonoid α] [StarAddMonoid α] (l : List (Matrix m n α)) :\n    l.sumᴴ = (l.map conjTranspose).sum :=\n  map_list_sum (conjTransposeAddEquiv m n α) l\n\n"}
{"name":"Matrix.conjTranspose_multiset_sum","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : AddCommMonoid α\ninst✝ : StarAddMonoid α\ns : Multiset (Matrix m n α)\n⊢ Eq s.sum.conjTranspose (Multiset.map Matrix.conjTranspose s).sum","decl":"theorem conjTranspose_multiset_sum [AddCommMonoid α] [StarAddMonoid α]\n    (s : Multiset (Matrix m n α)) : s.sumᴴ = (s.map conjTranspose).sum :=\n  (conjTransposeAddEquiv m n α).toAddMonoidHom.map_multiset_sum s\n\n"}
{"name":"Matrix.conjTranspose_sum","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : AddCommMonoid α\ninst✝ : StarAddMonoid α\nι : Type u_10\ns : Finset ι\nM : ι → Matrix m n α\n⊢ Eq (s.sum fun i => M i).conjTranspose (s.sum fun i => (M i).conjTranspose)","decl":"theorem conjTranspose_sum [AddCommMonoid α] [StarAddMonoid α] {ι : Type*} (s : Finset ι)\n    (M : ι → Matrix m n α) : (∑ i ∈ s, M i)ᴴ = ∑ i ∈ s, (M i)ᴴ :=\n  map_sum (conjTransposeAddEquiv m n α) _ s\n\n"}
{"name":"Matrix.conjTransposeLinearEquiv_apply","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝⁵ : CommSemiring R\ninst✝⁴ : StarRing R\ninst✝³ : AddCommMonoid α\ninst✝² : StarAddMonoid α\ninst✝¹ : Module R α\ninst✝ : StarModule R α\na✝ : Matrix m n α\n⊢ Eq ((Matrix.conjTransposeLinearEquiv m n R α) a✝) ((Matrix.conjTransposeAddEquiv m n α).toFun a✝)","decl":"/-- `Matrix.conjTranspose` as a `LinearMap` -/\n@[simps apply]\ndef conjTransposeLinearEquiv [CommSemiring R] [StarRing R] [AddCommMonoid α] [StarAddMonoid α]\n    [Module R α] [StarModule R α] : Matrix m n α ≃ₗ⋆[R] Matrix n m α :=\n  { conjTransposeAddEquiv m n α with map_smul' := conjTranspose_smul }\n\n"}
{"name":"Matrix.conjTransposeLinearEquiv_symm","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝⁵ : CommSemiring R\ninst✝⁴ : StarRing R\ninst✝³ : AddCommMonoid α\ninst✝² : StarAddMonoid α\ninst✝¹ : Module R α\ninst✝ : StarModule R α\n⊢ Eq (Matrix.conjTransposeLinearEquiv m n R α).symm (Matrix.conjTransposeLinearEquiv n m R α)","decl":"@[simp]\ntheorem conjTransposeLinearEquiv_symm [CommSemiring R] [StarRing R] [AddCommMonoid α]\n    [StarAddMonoid α] [Module R α] [StarModule R α] :\n    (conjTransposeLinearEquiv m n R α).symm = conjTransposeLinearEquiv n m R α :=\n  rfl\n\n"}
{"name":"Matrix.conjTransposeRingEquiv_symm_apply","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : Semiring α\ninst✝¹ : StarRing α\ninst✝ : Fintype m\nM : MulOpposite (Matrix m m α)\n⊢ Eq ((Matrix.conjTransposeRingEquiv m α).symm M) (MulOpposite.unop M).conjTranspose","decl":"/-- `Matrix.conjTranspose` as a `RingEquiv` to the opposite ring -/\n@[simps]\ndef conjTransposeRingEquiv [Semiring α] [StarRing α] [Fintype m] :\n    Matrix m m α ≃+* (Matrix m m α)ᵐᵒᵖ :=\n  { (conjTransposeAddEquiv m m α).trans MulOpposite.opAddEquiv with\n    toFun := fun M => MulOpposite.op Mᴴ\n    invFun := fun M => M.unopᴴ\n    map_mul' := fun M N =>\n      (congr_arg MulOpposite.op (conjTranspose_mul M N)).trans (MulOpposite.op_mul _ _) }\n\n"}
{"name":"Matrix.conjTransposeRingEquiv_apply","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : Semiring α\ninst✝¹ : StarRing α\ninst✝ : Fintype m\nM : Matrix m m α\n⊢ Eq ((Matrix.conjTransposeRingEquiv m α) M) (MulOpposite.op M.conjTranspose)","decl":"/-- `Matrix.conjTranspose` as a `RingEquiv` to the opposite ring -/\n@[simps]\ndef conjTransposeRingEquiv [Semiring α] [StarRing α] [Fintype m] :\n    Matrix m m α ≃+* (Matrix m m α)ᵐᵒᵖ :=\n  { (conjTransposeAddEquiv m m α).trans MulOpposite.opAddEquiv with\n    toFun := fun M => MulOpposite.op Mᴴ\n    invFun := fun M => M.unopᴴ\n    map_mul' := fun M N =>\n      (congr_arg MulOpposite.op (conjTranspose_mul M N)).trans (MulOpposite.op_mul _ _) }\n\n"}
{"name":"Matrix.conjTranspose_pow","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nα : Type v\ninst✝³ : Semiring α\ninst✝² : StarRing α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nM : Matrix m m α\nk : Nat\n⊢ Eq (HPow.hPow M k).conjTranspose (HPow.hPow M.conjTranspose k)","decl":"@[simp]\ntheorem conjTranspose_pow [Semiring α] [StarRing α] [Fintype m] [DecidableEq m] (M : Matrix m m α)\n    (k : ℕ) : (M ^ k)ᴴ = Mᴴ ^ k :=\n  MulOpposite.op_injective <| map_pow (conjTransposeRingEquiv m α) M k\n\n"}
{"name":"Matrix.conjTranspose_list_prod","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nα : Type v\ninst✝³ : Semiring α\ninst✝² : StarRing α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nl : List (Matrix m m α)\n⊢ Eq l.prod.conjTranspose (List.map Matrix.conjTranspose l).reverse.prod","decl":"theorem conjTranspose_list_prod [Semiring α] [StarRing α] [Fintype m] [DecidableEq m]\n    (l : List (Matrix m m α)) : l.prodᴴ = (l.map conjTranspose).reverse.prod :=\n  (conjTransposeRingEquiv m α).unop_map_list_prod l\n\n"}
{"name":"Matrix.star_eq_conjTranspose","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"m : Type u_2\nα : Type v\ninst✝ : Star α\nM : Matrix m m α\n⊢ Eq (Star.star M) M.conjTranspose","decl":"theorem star_eq_conjTranspose [Star α] (M : Matrix m m α) : star M = Mᴴ :=\n  rfl\n\n"}
{"name":"Matrix.star_apply","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"n : Type u_3\nα : Type v\ninst✝ : Star α\nM : Matrix n n α\ni j : n\n⊢ Eq (Star.star M i j) (Star.star (M j i))","decl":"@[simp]\ntheorem star_apply [Star α] (M : Matrix n n α) (i j) : (star M) i j = star (M j i) :=\n  rfl\n\n"}
{"name":"Matrix.instStarModule","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"n : Type u_3\nα : Type v\nβ : Type w\ninst✝³ : Star α\ninst✝² : Star β\ninst✝¹ : SMul α β\ninst✝ : StarModule α β\n⊢ StarModule α (Matrix n n β)","decl":"instance [Star α] [Star β] [SMul α β] [StarModule α β] : StarModule α (Matrix n n β) where\n  star_smul := conjTranspose_smul\n\n"}
{"name":"Matrix.star_mul","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : NonUnitalSemiring α\ninst✝ : StarRing α\nM N : Matrix n n α\n⊢ Eq (Star.star (HMul.hMul M N)) (HMul.hMul (Star.star N) (Star.star M))","decl":"/-- A version of `star_mul` for `*` instead of `*`. -/\ntheorem star_mul [Fintype n] [NonUnitalSemiring α] [StarRing α] (M N : Matrix n n α) :\n    star (M * N) = star N * star M :=\n  conjTranspose_mul _ _\n\n"}
{"name":"Matrix.conjTranspose_submatrix","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝ : Star α\nA : Matrix m n α\nr_reindex : l → m\nc_reindex : o → n\n⊢ Eq (A.submatrix r_reindex c_reindex).conjTranspose (A.conjTranspose.submatrix c_reindex r_reindex)","decl":"@[simp]\ntheorem conjTranspose_submatrix [Star α] (A : Matrix m n α) (r_reindex : l → m)\n    (c_reindex : o → n) : (A.submatrix r_reindex c_reindex)ᴴ = Aᴴ.submatrix c_reindex r_reindex :=\n  ext fun _ _ => rfl\n\n"}
{"name":"Matrix.conjTranspose_reindex","module":"Mathlib.Data.Matrix.ConjTranspose","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝ : Star α\neₘ : Equiv m l\neₙ : Equiv n o\nM : Matrix m n α\n⊢ Eq ((Matrix.reindex eₘ eₙ) M).conjTranspose ((Matrix.reindex eₙ eₘ) M.conjTranspose)","decl":"theorem conjTranspose_reindex [Star α] (eₘ : m ≃ l) (eₙ : n ≃ o) (M : Matrix m n α) :\n    (reindex eₘ eₙ M)ᴴ = reindex eₙ eₘ Mᴴ :=\n  rfl\n\n"}
