{"name":"Condensed.isColimitLocallyConstantPresheaf_desc_apply","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"I : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{u, u} I\ninst‚úù¬π : CategoryTheory.IsCofiltered I\nF : CategoryTheory.Functor I FintypeCat\nc : CategoryTheory.Limits.Cone (F.comp FintypeCat.toProfinite)\nX : Type (u + 1)\nhc : CategoryTheory.Limits.IsLimit c\ninst‚úù : ‚àÄ (i : I), CategoryTheory.Epi (c.œÄ.app i)\ns : CategoryTheory.Limits.Cocone ((F.comp FintypeCat.toProfinite).op.comp (Condensed.locallyConstantPresheaf X))\ni : I\nf : LocallyConstant (‚Üë(FintypeCat.toProfinite.obj (F.obj i)).toTop) X\n‚ä¢ Eq ((Condensed.isColimitLocallyConstantPresheaf c X hc).desc s (LocallyConstant.comap (c.œÄ.app i) f)) (s.Œπ.app { unop := i } f)","decl":"@[simp]\nlemma isColimitLocallyConstantPresheaf_desc_apply (hc : IsLimit c) [‚àÄ i, Epi (c.œÄ.app i)]\n    (s : Cocone ((F ‚ãô toProfinite).op ‚ãô locallyConstantPresheaf X))\n    (i : I) (f : LocallyConstant (toProfinite.obj (F.obj i)) X) :\n    (isColimitLocallyConstantPresheaf c X hc).desc s (f.comap (c.œÄ.app i)) = s.Œπ.app ‚ü®i‚ü© f := by\n  change ((((locallyConstantPresheaf X).mapCocone c.op).Œπ.app ‚ü®i‚ü©) ‚â´\n    (isColimitLocallyConstantPresheaf c X hc).desc s) _ = _\n  rw [(isColimitLocallyConstantPresheaf c X hc).fac]\n\n"}
{"name":"Condensed.isColimitLocallyConstantPresheafDiagram_desc_apply","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"X : Type (u + 1)\nS : Profinite\ns : CategoryTheory.Limits.Cocone (S.diagram.op.comp (Condensed.locallyConstantPresheaf X))\ni : DiscreteQuotient ‚ÜëS.toTop\nf : LocallyConstant (‚Üë(S.diagram.obj i).toTop) X\n‚ä¢ Eq ((Condensed.isColimitLocallyConstantPresheafDiagram X S).desc s (LocallyConstant.comap (S.asLimitCone.œÄ.app i) f)) (s.Œπ.app { unop := i } f)","decl":"@[simp]\nlemma isColimitLocallyConstantPresheafDiagram_desc_apply (S : Profinite)\n    (s : Cocone (S.diagram.op ‚ãô locallyConstantPresheaf X))\n    (i : DiscreteQuotient S) (f : LocallyConstant (S.diagram.obj i) X) :\n    (isColimitLocallyConstantPresheafDiagram X S).desc s (f.comap (S.asLimitCone.œÄ.app i)) =\n      s.Œπ.app ‚ü®i‚ü© f :=\n  isColimitLocallyConstantPresheaf_desc_apply S.asLimitCone X S.asLimit s i f\n\n"}
{"name":"Condensed.lanPresheafExt_hom","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F G : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\nS : Opposite Profinite\ni : CategoryTheory.Iso (FintypeCat.toProfinite.op.comp F) (FintypeCat.toProfinite.op.comp G)\n‚ä¢ Eq ((Condensed.lanPresheafExt i).hom.app S) (CategoryTheory.Limits.colimMap (CategoryTheory.whiskerLeft (CategoryTheory.CostructuredArrow.proj FintypeCat.toProfinite.op S) i.hom))","decl":"@[simp]\nlemma lanPresheafExt_hom {F G : Profinite.{u}·µí·µñ ‚•§ Type (u+1)} (S : Profinite.{u}·µí·µñ)\n    (i : toProfinite.op ‚ãô F ‚âÖ toProfinite.op ‚ãô G) : (lanPresheafExt i).hom.app S =\n      colimMap (whiskerLeft (CostructuredArrow.proj toProfinite.op S) i.hom) := by\n  simp only [lanPresheaf, pointwiseLeftKanExtension_obj, lanPresheafExt,\n    leftKanExtensionUniqueOfIso_hom, pointwiseLeftKanExtension_desc_app]\n  apply colimit.hom_ext\n  aesop\n\n"}
{"name":"Condensed.lanPresheafExt_inv","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F G : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\nS : Opposite Profinite\ni : CategoryTheory.Iso (FintypeCat.toProfinite.op.comp F) (FintypeCat.toProfinite.op.comp G)\n‚ä¢ Eq ((Condensed.lanPresheafExt i).inv.app S) (CategoryTheory.Limits.colimMap (CategoryTheory.whiskerLeft (CategoryTheory.CostructuredArrow.proj FintypeCat.toProfinite.op S) i.inv))","decl":"@[simp]\nlemma lanPresheafExt_inv {F G : Profinite.{u}·µí·µñ ‚•§ Type (u+1)} (S : Profinite.{u}·µí·µñ)\n    (i : toProfinite.op ‚ãô F ‚âÖ toProfinite.op ‚ãô G) : (lanPresheafExt i).inv.app S =\n      colimMap (whiskerLeft (CostructuredArrow.proj toProfinite.op S) i.inv) := by\n  simp only [lanPresheaf, pointwiseLeftKanExtension_obj, lanPresheafExt,\n    leftKanExtensionUniqueOfIso_inv, pointwiseLeftKanExtension_desc_app]\n  apply colimit.hom_ext\n  aesop\n\n"}
{"name":"Condensed.instFinalOppositeDiscreteQuotientŒ±TopologicalSpaceToTopTotallyDisconnectedSpaceCostructuredArrowFintypeCatProfiniteOpToProfiniteOpPtAsLimitConeFunctorOp","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"S : Profinite\n‚ä¢ (Profinite.Extend.functorOp S.asLimitCone).Final","decl":"instance : Final <| Profinite.Extend.functorOp S.asLimitCone :=\n  Profinite.Extend.functorOp_final S.asLimitCone S.asLimit\n\n"}
{"name":"Condensed.lanPresheafIso_hom","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"S : Profinite\nF : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\nhF : CategoryTheory.Limits.IsColimit (F.mapCocone S.asLimitCone.op)\n‚ä¢ Eq (Condensed.lanPresheafIso hF).hom (CategoryTheory.Limits.colimit.desc ((CategoryTheory.CostructuredArrow.proj FintypeCat.toProfinite.op { unop := S }).comp (FintypeCat.toProfinite.op.comp F)) (Profinite.Extend.cocone F S))","decl":"@[simp]\nlemma lanPresheafIso_hom (hF : IsColimit <| F.mapCocone S.asLimitCone.op) :\n    (lanPresheafIso hF).hom = colimit.desc _ (Profinite.Extend.cocone _ _) := by\n  simp [lanPresheafIso, Final.colimitIso]\n  rfl\n\n"}
{"name":"Condensed.lanPresheafNatIso_hom_app","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\nhF : (S : Profinite) ‚Üí CategoryTheory.Limits.IsColimit (F.mapCocone S.asLimitCone.op)\nS : Opposite Profinite\n‚ä¢ Eq ((Condensed.lanPresheafNatIso hF).hom.app S) (CategoryTheory.Limits.colimit.desc ((CategoryTheory.CostructuredArrow.proj FintypeCat.toProfinite.op { unop := Opposite.unop S }).comp (FintypeCat.toProfinite.op.comp F)) (Profinite.Extend.cocone F (Opposite.unop S)))","decl":"@[simp]\nlemma lanPresheafNatIso_hom_app (hF : ‚àÄ S : Profinite, IsColimit <| F.mapCocone S.asLimitCone.op)\n    (S : Profinite·µí·µñ) : (lanPresheafNatIso hF).hom.app S =\n      colimit.desc _ (Profinite.Extend.cocone _ _) := by\n  simp [lanPresheafNatIso]\n\n"}
{"name":"Condensed.finYoneda_obj","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\nX : Opposite FintypeCat\n‚ä¢ Eq ((Condensed.finYoneda F).obj X) (‚Üë(Opposite.unop X) ‚Üí F.obj (FintypeCat.toProfinite.op.obj { unop := FintypeCat.of PUnit.{u + 1} }))","decl":"/--\nThe functor which takes a finite set to the set of maps into `F(*)` for a presheaf `F` on\n`Profinite`.\n-/\n@[simps]\ndef finYoneda : FintypeCat.{u}·µí·µñ ‚•§ Type (u+1) where\n  obj X := X.unop ‚Üí F.obj (toProfinite.op.obj ‚ü®of PUnit.{u+1}‚ü©)\n  map f g := g ‚àò f.unop\n\n"}
{"name":"Condensed.finYoneda_map","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\nX‚úù Y‚úù : Opposite FintypeCat\nf : Quiver.Hom X‚úù Y‚úù\ng : ‚Üë(Opposite.unop X‚úù) ‚Üí F.obj (FintypeCat.toProfinite.op.obj { unop := FintypeCat.of PUnit.{u + 1} })\na‚úù : ‚Üë(Opposite.unop Y‚úù)\n‚ä¢ Eq ((Condensed.finYoneda F).map f g a‚úù) (Function.comp g f.unop a‚úù)","decl":"/--\nThe functor which takes a finite set to the set of maps into `F(*)` for a presheaf `F` on\n`Profinite`.\n-/\n@[simps]\ndef finYoneda : FintypeCat.{u}·µí·µñ ‚•§ Type (u+1) where\n  obj X := X.unop ‚Üí F.obj (toProfinite.op.obj ‚ü®of PUnit.{u+1}‚ü©)\n  map f g := g ‚àò f.unop\n\n"}
{"name":"Condensed.locallyConstantIsoFinYoneda_hom_app","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\nX : Opposite FintypeCat\na‚úù : (FintypeCat.toProfinite.op.comp (Condensed.locallyConstantPresheaf (F.obj (FintypeCat.toProfinite.op.obj { unop := FintypeCat.of PUnit.{u + 1} })))).obj X\n‚ä¢ Eq ((Condensed.locallyConstantIsoFinYoneda F).hom.app X a‚úù) ‚áëa‚úù","decl":"/-- `locallyConstantPresheaf` restricted to finite sets is isomorphic to `finYoneda F`. -/\n@[simps! hom_app]\ndef locallyConstantIsoFinYoneda :\n    toProfinite.op ‚ãô (locallyConstantPresheaf (F.obj (toProfinite.op.obj ‚ü®of PUnit.{u+1}‚ü©))) ‚âÖ\n    finYoneda F :=\n  NatIso.ofComponents fun Y ‚Ü¶ {\n    hom := fun f ‚Ü¶ f.1\n    inv := fun f ‚Ü¶ ‚ü®f, @IsLocallyConstant.of_discrete _ _ _ ‚ü®rfl‚ü© _‚ü© }\n\n"}
{"name":"Condensed.instPreservesLimitsOfShapeOppositeProfiniteDiscreteŒ±TopologicalSpaceToTopTotallyDisconnectedSpaceOfFinite","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\ninst‚úù¬π : CategoryTheory.Limits.PreservesFiniteProducts F\nX : Profinite\ninst‚úù : Finite ‚ÜëX.toTop\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete ‚ÜëX.toTop) F","decl":"noncomputable instance (X : Profinite) [Finite X] :\n    PreservesLimitsOfShape (Discrete X) F :=\n  let X' := (Countable.toSmall.{0} X).equiv_small.choose\n  let e : X ‚âÉ X' := (Countable.toSmall X).equiv_small.choose_spec.some\n  have : Finite X' := .of_equiv X e\n  preservesLimitsOfShape_of_equiv (Discrete.equivalence e.symm) F\n\n"}
{"name":"Condensed.isoFinYonedaComponents_hom_apply","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\ninst‚úù¬π : CategoryTheory.Limits.PreservesFiniteProducts F\nX : Profinite\ninst‚úù : Finite ‚ÜëX.toTop\ny : F.obj { unop := X }\nx : ‚ÜëX.toTop\n‚ä¢ Eq ((Condensed.isoFinYonedaComponents F X).hom y x) (F.map (CompHausLike.const (Profinite.of PUnit.{u + 1}) x).op y)","decl":"lemma isoFinYonedaComponents_hom_apply (X : Profinite.{u}) [Finite X] (y : F.obj ‚ü®X‚ü©) (x : X) :\n    (isoFinYonedaComponents F X).hom y x = F.map ((Profinite.of PUnit.{u+1}).const x).op y := rfl\n\n"}
{"name":"Condensed.isoFinYonedaComponents_inv_comp","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\ninst‚úù¬≤ : CategoryTheory.Limits.PreservesFiniteProducts F\nX Y : Profinite\ninst‚úù¬π : Finite ‚ÜëX.toTop\ninst‚úù : Finite ‚ÜëY.toTop\nf : ‚ÜëY.toTop ‚Üí F.obj { unop := Profinite.of PUnit.{u + 1} }\ng : Quiver.Hom X Y\n‚ä¢ Eq ((Condensed.isoFinYonedaComponents F X).inv (Function.comp f ‚áëg)) (F.map g.op ((Condensed.isoFinYonedaComponents F Y).inv f))","decl":"lemma isoFinYonedaComponents_inv_comp {X Y : Profinite.{u}} [Finite X] [Finite Y]\n    (f : Y ‚Üí F.obj ‚ü®Profinite.of PUnit‚ü©) (g : X ‚ü∂ Y) :\n    (isoFinYonedaComponents F X).inv (f ‚àò g) = F.map g.op ((isoFinYonedaComponents F Y).inv f) := by\n  apply injective_of_mono (isoFinYonedaComponents F X).hom\n  simp only [CategoryTheory.inv_hom_id_apply]\n  ext x\n  rw [isoFinYonedaComponents_hom_apply]\n  simp only [‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp, CompHausLike.const_comp,\n    ‚Üê isoFinYonedaComponents_hom_apply, CategoryTheory.inv_hom_id_apply, Function.comp_apply]\n\n"}
{"name":"Condensed.isoFinYoneda_hom_app","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\ninst‚úù : CategoryTheory.Limits.PreservesFiniteProducts F\nX : Opposite FintypeCat\na‚úù : (FintypeCat.toProfinite.op.comp F).obj X\n‚ä¢ Eq ((Condensed.isoFinYoneda F).hom.app X a‚úù) ((Condensed.isoFinYonedaComponents F (FintypeCat.toProfinite.obj (Opposite.unop X))).hom a‚úù)","decl":"/--\nThe restriction of a finite product preserving presheaf `F` on `Profinite` to the category of\nfinite sets is isomorphic to `finYoneda F`.\n-/\n@[simps!]\ndef isoFinYoneda : toProfinite.op ‚ãô F ‚âÖ finYoneda F :=\n  NatIso.ofComponents (fun X ‚Ü¶ isoFinYonedaComponents F (toProfinite.obj X.unop)) fun _ ‚Ü¶ by\n    simp only [comp_obj, op_obj, finYoneda_obj, Functor.comp_map, op_map]\n    ext\n    simp only [types_comp_apply, isoFinYonedaComponents_hom_apply, finYoneda_map,\n      op_obj, Function.comp_apply, ‚Üê FunctorToTypes.map_comp_apply]\n    rfl\n\n"}
{"name":"Condensed.isoFinYoneda_inv_app","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\ninst‚úù : CategoryTheory.Limits.PreservesFiniteProducts F\nX : Opposite FintypeCat\na‚úù : (Condensed.finYoneda F).obj X\n‚ä¢ Eq ((Condensed.isoFinYoneda F).inv.app X a‚úù) ((Condensed.isoFinYonedaComponents F (FintypeCat.toProfinite.obj (Opposite.unop X))).inv a‚úù)","decl":"/--\nThe restriction of a finite product preserving presheaf `F` on `Profinite` to the category of\nfinite sets is isomorphic to `finYoneda F`.\n-/\n@[simps!]\ndef isoFinYoneda : toProfinite.op ‚ãô F ‚âÖ finYoneda F :=\n  NatIso.ofComponents (fun X ‚Ü¶ isoFinYonedaComponents F (toProfinite.obj X.unop)) fun _ ‚Ü¶ by\n    simp only [comp_obj, op_obj, finYoneda_obj, Functor.comp_map, op_map]\n    ext\n    simp only [types_comp_apply, isoFinYonedaComponents_hom_apply, finYoneda_map,\n      op_obj, Function.comp_apply, ‚Üê FunctorToTypes.map_comp_apply]\n    rfl\n\n"}
{"name":"Condensed.isoLocallyConstantOfIsColimit_inv","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"X : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\ninst‚úù : CategoryTheory.Limits.PreservesFiniteProducts X\nhX : (S : Profinite) ‚Üí CategoryTheory.Limits.IsColimit (X.mapCocone S.asLimitCone.op)\n‚ä¢ Eq (Condensed.isoLocallyConstantOfIsColimit X hX).inv (CompHausLike.LocallyConstant.counitApp X)","decl":"lemma isoLocallyConstantOfIsColimit_inv (X : Profinite.{u}·µí·µñ ‚•§ Type (u+1))\n    [PreservesFiniteProducts X]\n    (hX : ‚àÄ S : Profinite.{u}, (IsColimit <| X.mapCocone S.asLimitCone.op)) :\n    (isoLocallyConstantOfIsColimit X hX).inv =\n      (CompHausLike.LocallyConstant.counitApp.{u, u+1} X) := by\n  dsimp [isoLocallyConstantOfIsColimit]\n  simp only [Category.assoc]\n  rw [Iso.inv_comp_eq]\n  ext S : 2\n  apply colimit.hom_ext\n  intro ‚ü®Y, _, g‚ü©\n  simp? [locallyConstantIsoFinYoneda, isoFinYoneda, counitApp] says\n    simp only [comp_obj, CostructuredArrow.proj_obj, op_obj, functorToPresheaves_obj_obj,\n      isoFinYoneda, locallyConstantIsoFinYoneda, finYoneda_obj, LocallyConstant.toFun_eq_coe,\n      NatTrans.comp_app, pointwiseLeftKanExtension_obj, lanPresheafExt_inv, Iso.trans_inv,\n      Iso.symm_inv, whiskerLeft_comp, lanPresheafNatIso_hom_app, Opposite.op_unop, colimit.map_desc,\n      id_eq, Functor.comp_map, op_map, colimit.Œπ_desc, Cocones.precompose_obj_pt,\n      Profinite.Extend.cocone_pt, Cocones.precompose_obj_Œπ, Category.assoc, const_obj_obj,\n      whiskerLeft_app, NatIso.ofComponents_hom_app, NatIso.ofComponents_inv_app,\n      Profinite.Extend.cocone_Œπ_app, counitApp, colimit.Œπ_desc_assoc]\n  erw [(counitApp.{u, u+1} X).naturality]\n  simp only [‚Üê Category.assoc]\n  congr\n  ext f\n  simp only [types_comp_apply, isoFinYoneda_inv_app, counitApp_app]\n  apply presheaf_ext.{u, u+1} (X := X) (Y := X) (f := f)\n  intro x\n  rw [incl_of_counitAppApp]\n  simp only [counitAppAppImage, CompHausLike.coe_of]\n  letI : Fintype (fiber.{u, u+1} f x) :=\n    Fintype.ofInjective (sigmaIncl.{u, u+1} f x).1 Subtype.val_injective\n  apply injective_of_mono (isoFinYonedaComponents X (fiber.{u, u+1} f x)).hom\n  ext y\n  simp only [isoFinYonedaComponents_hom_apply, ‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp]\n  rw [show (Profinite.of PUnit.{u+1}).const y ‚â´ IsTerminal.from _ (fiber f x) = ùüô _ from rfl]\n  simp only [op_comp, FunctorToTypes.map_comp_apply, op_id, FunctorToTypes.map_id_apply]\n  rw [‚Üê isoFinYonedaComponents_inv_comp X _ (sigmaIncl.{u, u+1} f x)]\n  simpa [‚Üê isoFinYonedaComponents_hom_apply] using x.map_eq_image f y\n\n"}
{"name":"LightCondensed.isColimitLocallyConstantPresheaf_desc_apply","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite Nat) FintypeCat\nc : CategoryTheory.Limits.Cone (F.comp FintypeCat.toLightProfinite)\nX : Type u\nhc : CategoryTheory.Limits.IsLimit c\ninst‚úù : ‚àÄ (i : Opposite Nat), CategoryTheory.Epi (c.œÄ.app i)\ns : CategoryTheory.Limits.Cocone ((F.comp FintypeCat.toLightProfinite).op.comp (LightCondensed.locallyConstantPresheaf X))\nn : Opposite Nat\nf : LocallyConstant (‚Üë(FintypeCat.toLightProfinite.obj (F.obj n)).toTop) X\n‚ä¢ Eq ((LightCondensed.isColimitLocallyConstantPresheaf c X hc).desc s (LocallyConstant.comap (c.œÄ.app n) f)) (s.Œπ.app { unop := n } f)","decl":"@[simp]\nlemma isColimitLocallyConstantPresheaf_desc_apply (hc : IsLimit c) [‚àÄ i, Epi (c.œÄ.app i)]\n    (s : Cocone ((F ‚ãô toLightProfinite).op ‚ãô locallyConstantPresheaf X))\n    (n : ‚Ñï·µí·µñ) (f : LocallyConstant (toLightProfinite.obj (F.obj n)) X) :\n    (isColimitLocallyConstantPresheaf c X hc).desc s (f.comap (c.œÄ.app n)) = s.Œπ.app ‚ü®n‚ü© f := by\n  change ((((locallyConstantPresheaf X).mapCocone c.op).Œπ.app ‚ü®n‚ü©) ‚â´\n    (isColimitLocallyConstantPresheaf c X hc).desc s) _ = _\n  rw [(isColimitLocallyConstantPresheaf c X hc).fac]\n\n"}
{"name":"LightCondensed.isColimitLocallyConstantPresheafDiagram_desc_apply","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"X : Type u\nS : LightProfinite\ns : CategoryTheory.Limits.Cocone (S.diagram.rightOp.comp (LightCondensed.locallyConstantPresheaf X))\nn : Nat\nf : LocallyConstant (‚Üë(S.diagram.obj { unop := n }).toTop) X\n‚ä¢ Eq ((LightCondensed.isColimitLocallyConstantPresheafDiagram X S).desc s (LocallyConstant.comap (S.asLimitCone.œÄ.app { unop := n }) f)) (s.Œπ.app n f)","decl":"@[simp]\nlemma isColimitLocallyConstantPresheafDiagram_desc_apply (S : LightProfinite)\n    (s : Cocone (S.diagram.rightOp ‚ãô locallyConstantPresheaf X))\n    (n : ‚Ñï) (f : LocallyConstant (S.diagram.obj ‚ü®n‚ü©) X) :\n    (isColimitLocallyConstantPresheafDiagram X S).desc s (f.comap (S.asLimitCone.œÄ.app ‚ü®n‚ü©)) =\n      s.Œπ.app n f := by\n  change ((((locallyConstantPresheaf X).mapCocone (coconeRightOpOfCone S.asLimitCone)).Œπ.app n) ‚â´\n    (isColimitLocallyConstantPresheafDiagram X S).desc s) _ = _\n  rw [(isColimitLocallyConstantPresheafDiagram X S).fac]\n\n"}
{"name":"LightCondensed.instHasColimitsOfShapeCostructuredArrowOppositeFintypeCatLightProfiniteOpToLightProfiniteType","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"S : Opposite LightProfinite\n‚ä¢ CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.CostructuredArrow FintypeCat.toLightProfinite.op S) (Type u)","decl":"instance (S : LightProfinite.{u}·µí·µñ) :\n    HasColimitsOfShape (CostructuredArrow toLightProfinite.op S) (Type u) :=\n  hasColimitsOfShape_of_equivalence (asEquivalence (CostructuredArrow.pre Skeleton.incl.op _ S))\n\n"}
{"name":"LightCondensed.lanPresheafExt_hom","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F G : CategoryTheory.Functor (Opposite LightProfinite) (Type u)\nS : Opposite LightProfinite\ni : CategoryTheory.Iso (FintypeCat.toLightProfinite.op.comp F) (FintypeCat.toLightProfinite.op.comp G)\n‚ä¢ Eq ((LightCondensed.lanPresheafExt i).hom.app S) (CategoryTheory.Limits.colimMap (CategoryTheory.whiskerLeft (CategoryTheory.CostructuredArrow.proj FintypeCat.toLightProfinite.op S) i.hom))","decl":"@[simp]\nlemma lanPresheafExt_hom {F G : LightProfinite.{u}·µí·µñ ‚•§ Type u} (S : LightProfinite.{u}·µí·µñ)\n    (i : toLightProfinite.op ‚ãô F ‚âÖ toLightProfinite.op ‚ãô G) : (lanPresheafExt i).hom.app S =\n      colimMap (whiskerLeft (CostructuredArrow.proj toLightProfinite.op S) i.hom) := by\n  simp only [lanPresheaf, pointwiseLeftKanExtension_obj, lanPresheafExt,\n    leftKanExtensionUniqueOfIso_hom, pointwiseLeftKanExtension_desc_app]\n  apply colimit.hom_ext\n  aesop\n\n"}
{"name":"LightCondensed.lanPresheafExt_inv","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F G : CategoryTheory.Functor (Opposite LightProfinite) (Type u)\nS : Opposite LightProfinite\ni : CategoryTheory.Iso (FintypeCat.toLightProfinite.op.comp F) (FintypeCat.toLightProfinite.op.comp G)\n‚ä¢ Eq ((LightCondensed.lanPresheafExt i).inv.app S) (CategoryTheory.Limits.colimMap (CategoryTheory.whiskerLeft (CategoryTheory.CostructuredArrow.proj FintypeCat.toLightProfinite.op S) i.inv))","decl":"@[simp]\nlemma lanPresheafExt_inv  {F G : LightProfinite.{u}·µí·µñ ‚•§ Type u} (S : LightProfinite.{u}·µí·µñ)\n    (i : toLightProfinite.op ‚ãô F ‚âÖ toLightProfinite.op ‚ãô G) : (lanPresheafExt i).inv.app S =\n      colimMap (whiskerLeft (CostructuredArrow.proj toLightProfinite.op S) i.inv) := by\n  simp only [lanPresheaf, pointwiseLeftKanExtension_obj, lanPresheafExt,\n    leftKanExtensionUniqueOfIso_inv, pointwiseLeftKanExtension_desc_app]\n  apply colimit.hom_ext\n  aesop\n\n"}
{"name":"LightCondensed.instFinalNatCostructuredArrowOppositeFintypeCatLightProfiniteOpToLightProfiniteOpPtAsLimitConeFunctorOp","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"S : LightProfinite\n‚ä¢ (LightProfinite.Extend.functorOp S.asLimitCone).Final","decl":"instance : Final <| LightProfinite.Extend.functorOp S.asLimitCone :=\n  LightProfinite.Extend.functorOp_final S.asLimitCone S.asLimit\n\n"}
{"name":"LightCondensed.lanPresheafIso_hom","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"S : LightProfinite\nF : CategoryTheory.Functor (Opposite LightProfinite) (Type u)\nhF : CategoryTheory.Limits.IsColimit (F.mapCocone (CategoryTheory.Limits.coconeRightOpOfCone S.asLimitCone))\n‚ä¢ Eq (LightCondensed.lanPresheafIso hF).hom (CategoryTheory.Limits.colimit.desc ((CategoryTheory.CostructuredArrow.proj FintypeCat.toLightProfinite.op { unop := S }).comp (FintypeCat.toLightProfinite.op.comp F)) (LightProfinite.Extend.cocone F S))","decl":"@[simp]\nlemma lanPresheafIso_hom (hF : IsColimit <| F.mapCocone (coconeRightOpOfCone S.asLimitCone)) :\n    (lanPresheafIso hF).hom = colimit.desc _ (LightProfinite.Extend.cocone _ _) := by\n  simp [lanPresheafIso, Final.colimitIso]\n  rfl\n\n"}
{"name":"LightCondensed.lanPresheafNatIso_hom_app","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite LightProfinite) (Type u)\nhF : (S : LightProfinite) ‚Üí CategoryTheory.Limits.IsColimit (F.mapCocone (CategoryTheory.Limits.coconeRightOpOfCone S.asLimitCone))\nS : Opposite LightProfinite\n‚ä¢ Eq ((LightCondensed.lanPresheafNatIso hF).hom.app S) (CategoryTheory.Limits.colimit.desc ((CategoryTheory.CostructuredArrow.proj FintypeCat.toLightProfinite.op { unop := Opposite.unop S }).comp (FintypeCat.toLightProfinite.op.comp F)) (LightProfinite.Extend.cocone F (Opposite.unop S)))","decl":"@[simp]\nlemma lanPresheafNatIso_hom_app\n    (hF : ‚àÄ S : LightProfinite, IsColimit <| F.mapCocone (coconeRightOpOfCone S.asLimitCone))\n    (S : LightProfinite·µí·µñ) : (lanPresheafNatIso hF).hom.app S =\n      colimit.desc _ (LightProfinite.Extend.cocone _ _) := by\n  simp [lanPresheafNatIso]\n\n"}
{"name":"LightCondensed.finYoneda_obj","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite LightProfinite) (Type u)\nX : Opposite FintypeCat\n‚ä¢ Eq ((LightCondensed.finYoneda F).obj X) (‚Üë(Opposite.unop X) ‚Üí F.obj (FintypeCat.toLightProfinite.op.obj { unop := FintypeCat.of PUnit.{u + 1} }))","decl":"/--\nThe functor which takes a finite set to the set of maps into `F(*)` for a presheaf `F` on\n`LightProfinite`.\n-/\n@[simps]\ndef finYoneda : FintypeCat.{u}·µí·µñ ‚•§ Type u where\n  obj X := X.unop ‚Üí F.obj (toLightProfinite.op.obj ‚ü®of PUnit.{u+1}‚ü©)\n  map f g := g ‚àò f.unop\n\n"}
{"name":"LightCondensed.finYoneda_map","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite LightProfinite) (Type u)\nX‚úù Y‚úù : Opposite FintypeCat\nf : Quiver.Hom X‚úù Y‚úù\ng : ‚Üë(Opposite.unop X‚úù) ‚Üí F.obj (FintypeCat.toLightProfinite.op.obj { unop := FintypeCat.of PUnit.{u + 1} })\na‚úù : ‚Üë(Opposite.unop Y‚úù)\n‚ä¢ Eq ((LightCondensed.finYoneda F).map f g a‚úù) (Function.comp g f.unop a‚úù)","decl":"/--\nThe functor which takes a finite set to the set of maps into `F(*)` for a presheaf `F` on\n`LightProfinite`.\n-/\n@[simps]\ndef finYoneda : FintypeCat.{u}·µí·µñ ‚•§ Type u where\n  obj X := X.unop ‚Üí F.obj (toLightProfinite.op.obj ‚ü®of PUnit.{u+1}‚ü©)\n  map f g := g ‚àò f.unop\n\n"}
{"name":"LightCondensed.instPreservesLimitsOfShapeOppositeLightProfiniteDiscreteŒ±Fintype","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite LightProfinite) (Type u)\ninst‚úù : CategoryTheory.Limits.PreservesFiniteProducts F\nX : FintypeCat\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete ‚ÜëX) F","decl":"noncomputable instance (X : FintypeCat.{u}) : PreservesLimitsOfShape (Discrete X) F :=\n  let X' := (Countable.toSmall.{0} X).equiv_small.choose\n  let e : X ‚âÉ X' := (Countable.toSmall X).equiv_small.choose_spec.some\n  have : Fintype X' := Fintype.ofEquiv X e\n  preservesLimitsOfShape_of_equiv (Discrete.equivalence e.symm) F\n\n"}
{"name":"LightCondensed.isoFinYonedaComponents_hom_apply","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite LightProfinite) (Type u)\ninst‚úù¬π : CategoryTheory.Limits.PreservesFiniteProducts F\nX : LightProfinite\ninst‚úù : Finite ‚ÜëX.toTop\ny : F.obj { unop := X }\nx : ‚ÜëX.toTop\n‚ä¢ Eq ((LightCondensed.isoFinYonedaComponents F X).hom y x) (F.map (CompHausLike.const (LightProfinite.of PUnit.{u + 1}) x).op y)","decl":"lemma isoFinYonedaComponents_hom_apply (X : LightProfinite.{u}) [Finite X] (y : F.obj ‚ü®X‚ü©)\n    (x : X) : (isoFinYonedaComponents F X).hom y x =\n      F.map ((LightProfinite.of PUnit.{u+1}).const x).op y := rfl\n\n"}
{"name":"LightCondensed.isoFinYonedaComponents_inv_comp","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite LightProfinite) (Type u)\ninst‚úù¬≤ : CategoryTheory.Limits.PreservesFiniteProducts F\nX Y : LightProfinite\ninst‚úù¬π : Finite ‚ÜëX.toTop\ninst‚úù : Finite ‚ÜëY.toTop\nf : ‚ÜëY.toTop ‚Üí F.obj { unop := LightProfinite.of PUnit.{u + 1} }\ng : Quiver.Hom X Y\n‚ä¢ Eq ((LightCondensed.isoFinYonedaComponents F X).inv (Function.comp f ‚áëg)) (F.map g.op ((LightCondensed.isoFinYonedaComponents F Y).inv f))","decl":"lemma isoFinYonedaComponents_inv_comp {X Y : LightProfinite.{u}} [Finite X] [Finite Y]\n    (f : Y ‚Üí F.obj ‚ü®LightProfinite.of PUnit‚ü©) (g : X ‚ü∂ Y) :\n    (isoFinYonedaComponents F X).inv (f ‚àò g) = F.map g.op ((isoFinYonedaComponents F Y).inv f) := by\n  apply injective_of_mono (isoFinYonedaComponents F X).hom\n  simp only [CategoryTheory.inv_hom_id_apply]\n  ext x\n  rw [isoFinYonedaComponents_hom_apply]\n  simp only [‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp, CompHausLike.const_comp,\n    ‚Üê isoFinYonedaComponents_hom_apply, CategoryTheory.inv_hom_id_apply, Function.comp_apply]\n\n"}
{"name":"LightCondensed.isoFinYoneda_hom_app","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite LightProfinite) (Type u)\ninst‚úù : CategoryTheory.Limits.PreservesFiniteProducts F\nX : Opposite FintypeCat\na‚úù : (FintypeCat.toLightProfinite.op.comp F).obj X\n‚ä¢ Eq ((LightCondensed.isoFinYoneda F).hom.app X a‚úù) ((LightCondensed.isoFinYonedaComponents F (FintypeCat.toLightProfinite.obj (Opposite.unop X))).hom a‚úù)","decl":"/--\nThe restriction of a finite product preserving presheaf `F` on `Profinite` to the category of\nfinite sets is isomorphic to `finYoneda F`.\n-/\n@[simps!]\ndef isoFinYoneda : toLightProfinite.op ‚ãô F ‚âÖ finYoneda F :=\n  NatIso.ofComponents (fun X ‚Ü¶ isoFinYonedaComponents F (toLightProfinite.obj X.unop)) fun _ ‚Ü¶ by\n    simp only [comp_obj, op_obj, finYoneda_obj, Functor.comp_map, op_map]\n    ext\n    simp only [types_comp_apply, isoFinYonedaComponents_hom_apply, finYoneda_map, op_obj,\n      Function.comp_apply, Types.productLimitCone, const_obj_obj, fintypeCatAsCofan, Cofan.mk_pt,\n      cofan_mk_inj, Fan.mk_pt, Fan.mk_œÄ_app, ‚Üê FunctorToTypes.map_comp_apply]\n    rfl\n\n"}
{"name":"LightCondensed.isoFinYoneda_inv_app","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite LightProfinite) (Type u)\ninst‚úù : CategoryTheory.Limits.PreservesFiniteProducts F\nX : Opposite FintypeCat\na‚úù : (LightCondensed.finYoneda F).obj X\n‚ä¢ Eq ((LightCondensed.isoFinYoneda F).inv.app X a‚úù) ((LightCondensed.isoFinYonedaComponents F (FintypeCat.toLightProfinite.obj (Opposite.unop X))).inv a‚úù)","decl":"/--\nThe restriction of a finite product preserving presheaf `F` on `Profinite` to the category of\nfinite sets is isomorphic to `finYoneda F`.\n-/\n@[simps!]\ndef isoFinYoneda : toLightProfinite.op ‚ãô F ‚âÖ finYoneda F :=\n  NatIso.ofComponents (fun X ‚Ü¶ isoFinYonedaComponents F (toLightProfinite.obj X.unop)) fun _ ‚Ü¶ by\n    simp only [comp_obj, op_obj, finYoneda_obj, Functor.comp_map, op_map]\n    ext\n    simp only [types_comp_apply, isoFinYonedaComponents_hom_apply, finYoneda_map, op_obj,\n      Function.comp_apply, Types.productLimitCone, const_obj_obj, fintypeCatAsCofan, Cofan.mk_pt,\n      cofan_mk_inj, Fan.mk_pt, Fan.mk_œÄ_app, ‚Üê FunctorToTypes.map_comp_apply]\n    rfl\n\n"}
{"name":"LightCondensed.isoLocallyConstantOfIsColimit_inv","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"X : CategoryTheory.Functor (Opposite LightProfinite) (Type u)\ninst‚úù : CategoryTheory.Limits.PreservesFiniteProducts X\nhX : (S : LightProfinite) ‚Üí CategoryTheory.Limits.IsColimit (X.mapCocone (CategoryTheory.Limits.coconeRightOpOfCone S.asLimitCone))\n‚ä¢ Eq (LightCondensed.isoLocallyConstantOfIsColimit X hX).inv (CompHausLike.LocallyConstant.counitApp X)","decl":"lemma isoLocallyConstantOfIsColimit_inv (X : LightProfinite.{u}·µí·µñ ‚•§ Type u)\n    [PreservesFiniteProducts X] (hX : ‚àÄ S : LightProfinite.{u}, (IsColimit <|\n      X.mapCocone (coconeRightOpOfCone S.asLimitCone))) :\n    (isoLocallyConstantOfIsColimit X hX).inv =\n      (CompHausLike.LocallyConstant.counitApp.{u, u} X) := by\n  dsimp [isoLocallyConstantOfIsColimit]\n  simp only [Category.assoc]\n  rw [Iso.inv_comp_eq]\n  ext S : 2\n  apply colimit.hom_ext\n  intro ‚ü®Y, _, g‚ü©\n  simp? [locallyConstantIsoFinYoneda, isoFinYoneda, counitApp] says\n    simp only [comp_obj, CostructuredArrow.proj_obj, op_obj, functorToPresheaves_obj_obj,\n      isoFinYoneda, locallyConstantIsoFinYoneda, finYoneda_obj, LocallyConstant.toFun_eq_coe,\n      NatTrans.comp_app, pointwiseLeftKanExtension_obj, lanPresheafExt_inv, Iso.trans_inv,\n      Iso.symm_inv, whiskerLeft_comp, lanPresheafNatIso_hom_app, Opposite.op_unop, colimit.map_desc,\n      id_eq, Functor.comp_map, op_map, colimit.Œπ_desc, Cocones.precompose_obj_pt,\n      LightProfinite.Extend.cocone_pt, Cocones.precompose_obj_Œπ, Category.assoc, const_obj_obj,\n      whiskerLeft_app, NatIso.ofComponents_hom_app, NatIso.ofComponents_inv_app,\n      LightProfinite.Extend.cocone_Œπ_app, counitApp, colimit.Œπ_desc_assoc]\n  erw [(counitApp.{u, u} X).naturality]\n  simp only [‚Üê Category.assoc]\n  congr\n  ext f\n  simp only [types_comp_apply, isoFinYoneda_inv_app, counitApp_app]\n  apply presheaf_ext.{u, u} (X := X) (Y := X) (f := f)\n  intro x\n  rw [incl_of_counitAppApp]\n  simp only [counitAppAppImage, CompHausLike.coe_of]\n  letI : Fintype (fiber.{u, u} f x) :=\n    Fintype.ofInjective (sigmaIncl.{u, u} f x).1 Subtype.val_injective\n  apply injective_of_mono (isoFinYonedaComponents X (fiber.{u, u} f x)).hom\n  ext y\n  simp only [isoFinYonedaComponents_hom_apply, ‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp]\n  rw [show (LightProfinite.of PUnit.{u+1}).const y ‚â´ IsTerminal.from _ (fiber f x) = ùüô _ from rfl]\n  simp only [op_comp, FunctorToTypes.map_comp_apply, op_id, FunctorToTypes.map_id_apply]\n  rw [‚Üê isoFinYonedaComponents_inv_comp X _ (sigmaIncl.{u, u} f x)]\n  simpa [‚Üê isoFinYonedaComponents_hom_apply] using x.map_eq_image f y\n\n"}
