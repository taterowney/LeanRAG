{"name":"Condensed.isColimitLocallyConstantPresheaf_desc_apply","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"I : Type u\ninst✝² : CategoryTheory.Category.{u, u} I\ninst✝¹ : CategoryTheory.IsCofiltered I\nF : CategoryTheory.Functor I FintypeCat\nc : CategoryTheory.Limits.Cone (F.comp FintypeCat.toProfinite)\nX : Type (u + 1)\nhc : CategoryTheory.Limits.IsLimit c\ninst✝ : ∀ (i : I), CategoryTheory.Epi (c.π.app i)\ns : CategoryTheory.Limits.Cocone ((F.comp FintypeCat.toProfinite).op.comp (Condensed.locallyConstantPresheaf X))\ni : I\nf : LocallyConstant (↑(FintypeCat.toProfinite.obj (F.obj i)).toTop) X\n⊢ Eq ((Condensed.isColimitLocallyConstantPresheaf c X hc).desc s (LocallyConstant.comap (c.π.app i) f)) (s.ι.app { unop := i } f)","decl":"@[simp]\nlemma isColimitLocallyConstantPresheaf_desc_apply (hc : IsLimit c) [∀ i, Epi (c.π.app i)]\n    (s : Cocone ((F ⋙ toProfinite).op ⋙ locallyConstantPresheaf X))\n    (i : I) (f : LocallyConstant (toProfinite.obj (F.obj i)) X) :\n    (isColimitLocallyConstantPresheaf c X hc).desc s (f.comap (c.π.app i)) = s.ι.app ⟨i⟩ f := by\n  change ((((locallyConstantPresheaf X).mapCocone c.op).ι.app ⟨i⟩) ≫\n    (isColimitLocallyConstantPresheaf c X hc).desc s) _ = _\n  rw [(isColimitLocallyConstantPresheaf c X hc).fac]\n\n"}
{"name":"Condensed.isColimitLocallyConstantPresheafDiagram_desc_apply","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"X : Type (u + 1)\nS : Profinite\ns : CategoryTheory.Limits.Cocone (S.diagram.op.comp (Condensed.locallyConstantPresheaf X))\ni : DiscreteQuotient ↑S.toTop\nf : LocallyConstant (↑(S.diagram.obj i).toTop) X\n⊢ Eq ((Condensed.isColimitLocallyConstantPresheafDiagram X S).desc s (LocallyConstant.comap (S.asLimitCone.π.app i) f)) (s.ι.app { unop := i } f)","decl":"@[simp]\nlemma isColimitLocallyConstantPresheafDiagram_desc_apply (S : Profinite)\n    (s : Cocone (S.diagram.op ⋙ locallyConstantPresheaf X))\n    (i : DiscreteQuotient S) (f : LocallyConstant (S.diagram.obj i) X) :\n    (isColimitLocallyConstantPresheafDiagram X S).desc s (f.comap (S.asLimitCone.π.app i)) =\n      s.ι.app ⟨i⟩ f :=\n  isColimitLocallyConstantPresheaf_desc_apply S.asLimitCone X S.asLimit s i f\n\n"}
{"name":"Condensed.lanPresheafExt_hom","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F G : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\nS : Opposite Profinite\ni : CategoryTheory.Iso (FintypeCat.toProfinite.op.comp F) (FintypeCat.toProfinite.op.comp G)\n⊢ Eq ((Condensed.lanPresheafExt i).hom.app S) (CategoryTheory.Limits.colimMap (CategoryTheory.whiskerLeft (CategoryTheory.CostructuredArrow.proj FintypeCat.toProfinite.op S) i.hom))","decl":"@[simp]\nlemma lanPresheafExt_hom {F G : Profinite.{u}ᵒᵖ ⥤ Type (u+1)} (S : Profinite.{u}ᵒᵖ)\n    (i : toProfinite.op ⋙ F ≅ toProfinite.op ⋙ G) : (lanPresheafExt i).hom.app S =\n      colimMap (whiskerLeft (CostructuredArrow.proj toProfinite.op S) i.hom) := by\n  simp only [lanPresheaf, pointwiseLeftKanExtension_obj, lanPresheafExt,\n    leftKanExtensionUniqueOfIso_hom, pointwiseLeftKanExtension_desc_app]\n  apply colimit.hom_ext\n  aesop\n\n"}
{"name":"Condensed.lanPresheafExt_inv","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F G : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\nS : Opposite Profinite\ni : CategoryTheory.Iso (FintypeCat.toProfinite.op.comp F) (FintypeCat.toProfinite.op.comp G)\n⊢ Eq ((Condensed.lanPresheafExt i).inv.app S) (CategoryTheory.Limits.colimMap (CategoryTheory.whiskerLeft (CategoryTheory.CostructuredArrow.proj FintypeCat.toProfinite.op S) i.inv))","decl":"@[simp]\nlemma lanPresheafExt_inv {F G : Profinite.{u}ᵒᵖ ⥤ Type (u+1)} (S : Profinite.{u}ᵒᵖ)\n    (i : toProfinite.op ⋙ F ≅ toProfinite.op ⋙ G) : (lanPresheafExt i).inv.app S =\n      colimMap (whiskerLeft (CostructuredArrow.proj toProfinite.op S) i.inv) := by\n  simp only [lanPresheaf, pointwiseLeftKanExtension_obj, lanPresheafExt,\n    leftKanExtensionUniqueOfIso_inv, pointwiseLeftKanExtension_desc_app]\n  apply colimit.hom_ext\n  aesop\n\n"}
{"name":"Condensed.instFinalOppositeDiscreteQuotientαTopologicalSpaceToTopTotallyDisconnectedSpaceCostructuredArrowFintypeCatProfiniteOpToProfiniteOpPtAsLimitConeFunctorOp","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"S : Profinite\n⊢ (Profinite.Extend.functorOp S.asLimitCone).Final","decl":"instance : Final <| Profinite.Extend.functorOp S.asLimitCone :=\n  Profinite.Extend.functorOp_final S.asLimitCone S.asLimit\n\n"}
{"name":"Condensed.lanPresheafIso_hom","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"S : Profinite\nF : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\nhF : CategoryTheory.Limits.IsColimit (F.mapCocone S.asLimitCone.op)\n⊢ Eq (Condensed.lanPresheafIso hF).hom (CategoryTheory.Limits.colimit.desc ((CategoryTheory.CostructuredArrow.proj FintypeCat.toProfinite.op { unop := S }).comp (FintypeCat.toProfinite.op.comp F)) (Profinite.Extend.cocone F S))","decl":"@[simp]\nlemma lanPresheafIso_hom (hF : IsColimit <| F.mapCocone S.asLimitCone.op) :\n    (lanPresheafIso hF).hom = colimit.desc _ (Profinite.Extend.cocone _ _) := by\n  simp [lanPresheafIso, Final.colimitIso]\n  rfl\n\n"}
{"name":"Condensed.lanPresheafNatIso_hom_app","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\nhF : (S : Profinite) → CategoryTheory.Limits.IsColimit (F.mapCocone S.asLimitCone.op)\nS : Opposite Profinite\n⊢ Eq ((Condensed.lanPresheafNatIso hF).hom.app S) (CategoryTheory.Limits.colimit.desc ((CategoryTheory.CostructuredArrow.proj FintypeCat.toProfinite.op { unop := Opposite.unop S }).comp (FintypeCat.toProfinite.op.comp F)) (Profinite.Extend.cocone F (Opposite.unop S)))","decl":"@[simp]\nlemma lanPresheafNatIso_hom_app (hF : ∀ S : Profinite, IsColimit <| F.mapCocone S.asLimitCone.op)\n    (S : Profiniteᵒᵖ) : (lanPresheafNatIso hF).hom.app S =\n      colimit.desc _ (Profinite.Extend.cocone _ _) := by\n  simp [lanPresheafNatIso]\n\n"}
{"name":"Condensed.finYoneda_obj","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\nX : Opposite FintypeCat\n⊢ Eq ((Condensed.finYoneda F).obj X) (↑(Opposite.unop X) → F.obj (FintypeCat.toProfinite.op.obj { unop := FintypeCat.of PUnit.{u + 1} }))","decl":"/--\nThe functor which takes a finite set to the set of maps into `F(*)` for a presheaf `F` on\n`Profinite`.\n-/\n@[simps]\ndef finYoneda : FintypeCat.{u}ᵒᵖ ⥤ Type (u+1) where\n  obj X := X.unop → F.obj (toProfinite.op.obj ⟨of PUnit.{u+1}⟩)\n  map f g := g ∘ f.unop\n\n"}
{"name":"Condensed.finYoneda_map","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\nX✝ Y✝ : Opposite FintypeCat\nf : Quiver.Hom X✝ Y✝\ng : ↑(Opposite.unop X✝) → F.obj (FintypeCat.toProfinite.op.obj { unop := FintypeCat.of PUnit.{u + 1} })\na✝ : ↑(Opposite.unop Y✝)\n⊢ Eq ((Condensed.finYoneda F).map f g a✝) (Function.comp g f.unop a✝)","decl":"/--\nThe functor which takes a finite set to the set of maps into `F(*)` for a presheaf `F` on\n`Profinite`.\n-/\n@[simps]\ndef finYoneda : FintypeCat.{u}ᵒᵖ ⥤ Type (u+1) where\n  obj X := X.unop → F.obj (toProfinite.op.obj ⟨of PUnit.{u+1}⟩)\n  map f g := g ∘ f.unop\n\n"}
{"name":"Condensed.locallyConstantIsoFinYoneda_hom_app","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\nX : Opposite FintypeCat\na✝ : (FintypeCat.toProfinite.op.comp (Condensed.locallyConstantPresheaf (F.obj (FintypeCat.toProfinite.op.obj { unop := FintypeCat.of PUnit.{u + 1} })))).obj X\n⊢ Eq ((Condensed.locallyConstantIsoFinYoneda F).hom.app X a✝) ⇑a✝","decl":"/-- `locallyConstantPresheaf` restricted to finite sets is isomorphic to `finYoneda F`. -/\n@[simps! hom_app]\ndef locallyConstantIsoFinYoneda :\n    toProfinite.op ⋙ (locallyConstantPresheaf (F.obj (toProfinite.op.obj ⟨of PUnit.{u+1}⟩))) ≅\n    finYoneda F :=\n  NatIso.ofComponents fun Y ↦ {\n    hom := fun f ↦ f.1\n    inv := fun f ↦ ⟨f, @IsLocallyConstant.of_discrete _ _ _ ⟨rfl⟩ _⟩ }\n\n"}
{"name":"Condensed.instPreservesLimitsOfShapeOppositeProfiniteDiscreteαTopologicalSpaceToTopTotallyDisconnectedSpaceOfFinite","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteProducts F\nX : Profinite\ninst✝ : Finite ↑X.toTop\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete ↑X.toTop) F","decl":"noncomputable instance (X : Profinite) [Finite X] :\n    PreservesLimitsOfShape (Discrete X) F :=\n  let X' := (Countable.toSmall.{0} X).equiv_small.choose\n  let e : X ≃ X' := (Countable.toSmall X).equiv_small.choose_spec.some\n  have : Finite X' := .of_equiv X e\n  preservesLimitsOfShape_of_equiv (Discrete.equivalence e.symm) F\n\n"}
{"name":"Condensed.isoFinYonedaComponents_hom_apply","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteProducts F\nX : Profinite\ninst✝ : Finite ↑X.toTop\ny : F.obj { unop := X }\nx : ↑X.toTop\n⊢ Eq ((Condensed.isoFinYonedaComponents F X).hom y x) (F.map (CompHausLike.const (Profinite.of PUnit.{u + 1}) x).op y)","decl":"lemma isoFinYonedaComponents_hom_apply (X : Profinite.{u}) [Finite X] (y : F.obj ⟨X⟩) (x : X) :\n    (isoFinYonedaComponents F X).hom y x = F.map ((Profinite.of PUnit.{u+1}).const x).op y := rfl\n\n"}
{"name":"Condensed.isoFinYonedaComponents_inv_comp","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\ninst✝² : CategoryTheory.Limits.PreservesFiniteProducts F\nX Y : Profinite\ninst✝¹ : Finite ↑X.toTop\ninst✝ : Finite ↑Y.toTop\nf : ↑Y.toTop → F.obj { unop := Profinite.of PUnit.{u + 1} }\ng : Quiver.Hom X Y\n⊢ Eq ((Condensed.isoFinYonedaComponents F X).inv (Function.comp f ⇑g)) (F.map g.op ((Condensed.isoFinYonedaComponents F Y).inv f))","decl":"lemma isoFinYonedaComponents_inv_comp {X Y : Profinite.{u}} [Finite X] [Finite Y]\n    (f : Y → F.obj ⟨Profinite.of PUnit⟩) (g : X ⟶ Y) :\n    (isoFinYonedaComponents F X).inv (f ∘ g) = F.map g.op ((isoFinYonedaComponents F Y).inv f) := by\n  apply injective_of_mono (isoFinYonedaComponents F X).hom\n  simp only [CategoryTheory.inv_hom_id_apply]\n  ext x\n  rw [isoFinYonedaComponents_hom_apply]\n  simp only [← FunctorToTypes.map_comp_apply, ← op_comp, CompHausLike.const_comp,\n    ← isoFinYonedaComponents_hom_apply, CategoryTheory.inv_hom_id_apply, Function.comp_apply]\n\n"}
{"name":"Condensed.isoFinYoneda_hom_app","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts F\nX : Opposite FintypeCat\na✝ : (FintypeCat.toProfinite.op.comp F).obj X\n⊢ Eq ((Condensed.isoFinYoneda F).hom.app X a✝) ((Condensed.isoFinYonedaComponents F (FintypeCat.toProfinite.obj (Opposite.unop X))).hom a✝)","decl":"/--\nThe restriction of a finite product preserving presheaf `F` on `Profinite` to the category of\nfinite sets is isomorphic to `finYoneda F`.\n-/\n@[simps!]\ndef isoFinYoneda : toProfinite.op ⋙ F ≅ finYoneda F :=\n  NatIso.ofComponents (fun X ↦ isoFinYonedaComponents F (toProfinite.obj X.unop)) fun _ ↦ by\n    simp only [comp_obj, op_obj, finYoneda_obj, Functor.comp_map, op_map]\n    ext\n    simp only [types_comp_apply, isoFinYonedaComponents_hom_apply, finYoneda_map,\n      op_obj, Function.comp_apply, ← FunctorToTypes.map_comp_apply]\n    rfl\n\n"}
{"name":"Condensed.isoFinYoneda_inv_app","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts F\nX : Opposite FintypeCat\na✝ : (Condensed.finYoneda F).obj X\n⊢ Eq ((Condensed.isoFinYoneda F).inv.app X a✝) ((Condensed.isoFinYonedaComponents F (FintypeCat.toProfinite.obj (Opposite.unop X))).inv a✝)","decl":"/--\nThe restriction of a finite product preserving presheaf `F` on `Profinite` to the category of\nfinite sets is isomorphic to `finYoneda F`.\n-/\n@[simps!]\ndef isoFinYoneda : toProfinite.op ⋙ F ≅ finYoneda F :=\n  NatIso.ofComponents (fun X ↦ isoFinYonedaComponents F (toProfinite.obj X.unop)) fun _ ↦ by\n    simp only [comp_obj, op_obj, finYoneda_obj, Functor.comp_map, op_map]\n    ext\n    simp only [types_comp_apply, isoFinYonedaComponents_hom_apply, finYoneda_map,\n      op_obj, Function.comp_apply, ← FunctorToTypes.map_comp_apply]\n    rfl\n\n"}
{"name":"Condensed.isoLocallyConstantOfIsColimit_inv","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"X : CategoryTheory.Functor (Opposite Profinite) (Type (u + 1))\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts X\nhX : (S : Profinite) → CategoryTheory.Limits.IsColimit (X.mapCocone S.asLimitCone.op)\n⊢ Eq (Condensed.isoLocallyConstantOfIsColimit X hX).inv (CompHausLike.LocallyConstant.counitApp X)","decl":"lemma isoLocallyConstantOfIsColimit_inv (X : Profinite.{u}ᵒᵖ ⥤ Type (u+1))\n    [PreservesFiniteProducts X]\n    (hX : ∀ S : Profinite.{u}, (IsColimit <| X.mapCocone S.asLimitCone.op)) :\n    (isoLocallyConstantOfIsColimit X hX).inv =\n      (CompHausLike.LocallyConstant.counitApp.{u, u+1} X) := by\n  dsimp [isoLocallyConstantOfIsColimit]\n  simp only [Category.assoc]\n  rw [Iso.inv_comp_eq]\n  ext S : 2\n  apply colimit.hom_ext\n  intro ⟨Y, _, g⟩\n  simp? [locallyConstantIsoFinYoneda, isoFinYoneda, counitApp] says\n    simp only [comp_obj, CostructuredArrow.proj_obj, op_obj, functorToPresheaves_obj_obj,\n      isoFinYoneda, locallyConstantIsoFinYoneda, finYoneda_obj, LocallyConstant.toFun_eq_coe,\n      NatTrans.comp_app, pointwiseLeftKanExtension_obj, lanPresheafExt_inv, Iso.trans_inv,\n      Iso.symm_inv, whiskerLeft_comp, lanPresheafNatIso_hom_app, Opposite.op_unop, colimit.map_desc,\n      id_eq, Functor.comp_map, op_map, colimit.ι_desc, Cocones.precompose_obj_pt,\n      Profinite.Extend.cocone_pt, Cocones.precompose_obj_ι, Category.assoc, const_obj_obj,\n      whiskerLeft_app, NatIso.ofComponents_hom_app, NatIso.ofComponents_inv_app,\n      Profinite.Extend.cocone_ι_app, counitApp, colimit.ι_desc_assoc]\n  erw [(counitApp.{u, u+1} X).naturality]\n  simp only [← Category.assoc]\n  congr\n  ext f\n  simp only [types_comp_apply, isoFinYoneda_inv_app, counitApp_app]\n  apply presheaf_ext.{u, u+1} (X := X) (Y := X) (f := f)\n  intro x\n  rw [incl_of_counitAppApp]\n  simp only [counitAppAppImage, CompHausLike.coe_of]\n  letI : Fintype (fiber.{u, u+1} f x) :=\n    Fintype.ofInjective (sigmaIncl.{u, u+1} f x).1 Subtype.val_injective\n  apply injective_of_mono (isoFinYonedaComponents X (fiber.{u, u+1} f x)).hom\n  ext y\n  simp only [isoFinYonedaComponents_hom_apply, ← FunctorToTypes.map_comp_apply, ← op_comp]\n  rw [show (Profinite.of PUnit.{u+1}).const y ≫ IsTerminal.from _ (fiber f x) = 𝟙 _ from rfl]\n  simp only [op_comp, FunctorToTypes.map_comp_apply, op_id, FunctorToTypes.map_id_apply]\n  rw [← isoFinYonedaComponents_inv_comp X _ (sigmaIncl.{u, u+1} f x)]\n  simpa [← isoFinYonedaComponents_hom_apply] using x.map_eq_image f y\n\n"}
{"name":"LightCondensed.isColimitLocallyConstantPresheaf_desc_apply","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite Nat) FintypeCat\nc : CategoryTheory.Limits.Cone (F.comp FintypeCat.toLightProfinite)\nX : Type u\nhc : CategoryTheory.Limits.IsLimit c\ninst✝ : ∀ (i : Opposite Nat), CategoryTheory.Epi (c.π.app i)\ns : CategoryTheory.Limits.Cocone ((F.comp FintypeCat.toLightProfinite).op.comp (LightCondensed.locallyConstantPresheaf X))\nn : Opposite Nat\nf : LocallyConstant (↑(FintypeCat.toLightProfinite.obj (F.obj n)).toTop) X\n⊢ Eq ((LightCondensed.isColimitLocallyConstantPresheaf c X hc).desc s (LocallyConstant.comap (c.π.app n) f)) (s.ι.app { unop := n } f)","decl":"@[simp]\nlemma isColimitLocallyConstantPresheaf_desc_apply (hc : IsLimit c) [∀ i, Epi (c.π.app i)]\n    (s : Cocone ((F ⋙ toLightProfinite).op ⋙ locallyConstantPresheaf X))\n    (n : ℕᵒᵖ) (f : LocallyConstant (toLightProfinite.obj (F.obj n)) X) :\n    (isColimitLocallyConstantPresheaf c X hc).desc s (f.comap (c.π.app n)) = s.ι.app ⟨n⟩ f := by\n  change ((((locallyConstantPresheaf X).mapCocone c.op).ι.app ⟨n⟩) ≫\n    (isColimitLocallyConstantPresheaf c X hc).desc s) _ = _\n  rw [(isColimitLocallyConstantPresheaf c X hc).fac]\n\n"}
{"name":"LightCondensed.isColimitLocallyConstantPresheafDiagram_desc_apply","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"X : Type u\nS : LightProfinite\ns : CategoryTheory.Limits.Cocone (S.diagram.rightOp.comp (LightCondensed.locallyConstantPresheaf X))\nn : Nat\nf : LocallyConstant (↑(S.diagram.obj { unop := n }).toTop) X\n⊢ Eq ((LightCondensed.isColimitLocallyConstantPresheafDiagram X S).desc s (LocallyConstant.comap (S.asLimitCone.π.app { unop := n }) f)) (s.ι.app n f)","decl":"@[simp]\nlemma isColimitLocallyConstantPresheafDiagram_desc_apply (S : LightProfinite)\n    (s : Cocone (S.diagram.rightOp ⋙ locallyConstantPresheaf X))\n    (n : ℕ) (f : LocallyConstant (S.diagram.obj ⟨n⟩) X) :\n    (isColimitLocallyConstantPresheafDiagram X S).desc s (f.comap (S.asLimitCone.π.app ⟨n⟩)) =\n      s.ι.app n f := by\n  change ((((locallyConstantPresheaf X).mapCocone (coconeRightOpOfCone S.asLimitCone)).ι.app n) ≫\n    (isColimitLocallyConstantPresheafDiagram X S).desc s) _ = _\n  rw [(isColimitLocallyConstantPresheafDiagram X S).fac]\n\n"}
{"name":"LightCondensed.instHasColimitsOfShapeCostructuredArrowOppositeFintypeCatLightProfiniteOpToLightProfiniteType","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"S : Opposite LightProfinite\n⊢ CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.CostructuredArrow FintypeCat.toLightProfinite.op S) (Type u)","decl":"instance (S : LightProfinite.{u}ᵒᵖ) :\n    HasColimitsOfShape (CostructuredArrow toLightProfinite.op S) (Type u) :=\n  hasColimitsOfShape_of_equivalence (asEquivalence (CostructuredArrow.pre Skeleton.incl.op _ S))\n\n"}
{"name":"LightCondensed.lanPresheafExt_hom","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F G : CategoryTheory.Functor (Opposite LightProfinite) (Type u)\nS : Opposite LightProfinite\ni : CategoryTheory.Iso (FintypeCat.toLightProfinite.op.comp F) (FintypeCat.toLightProfinite.op.comp G)\n⊢ Eq ((LightCondensed.lanPresheafExt i).hom.app S) (CategoryTheory.Limits.colimMap (CategoryTheory.whiskerLeft (CategoryTheory.CostructuredArrow.proj FintypeCat.toLightProfinite.op S) i.hom))","decl":"@[simp]\nlemma lanPresheafExt_hom {F G : LightProfinite.{u}ᵒᵖ ⥤ Type u} (S : LightProfinite.{u}ᵒᵖ)\n    (i : toLightProfinite.op ⋙ F ≅ toLightProfinite.op ⋙ G) : (lanPresheafExt i).hom.app S =\n      colimMap (whiskerLeft (CostructuredArrow.proj toLightProfinite.op S) i.hom) := by\n  simp only [lanPresheaf, pointwiseLeftKanExtension_obj, lanPresheafExt,\n    leftKanExtensionUniqueOfIso_hom, pointwiseLeftKanExtension_desc_app]\n  apply colimit.hom_ext\n  aesop\n\n"}
{"name":"LightCondensed.lanPresheafExt_inv","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F G : CategoryTheory.Functor (Opposite LightProfinite) (Type u)\nS : Opposite LightProfinite\ni : CategoryTheory.Iso (FintypeCat.toLightProfinite.op.comp F) (FintypeCat.toLightProfinite.op.comp G)\n⊢ Eq ((LightCondensed.lanPresheafExt i).inv.app S) (CategoryTheory.Limits.colimMap (CategoryTheory.whiskerLeft (CategoryTheory.CostructuredArrow.proj FintypeCat.toLightProfinite.op S) i.inv))","decl":"@[simp]\nlemma lanPresheafExt_inv  {F G : LightProfinite.{u}ᵒᵖ ⥤ Type u} (S : LightProfinite.{u}ᵒᵖ)\n    (i : toLightProfinite.op ⋙ F ≅ toLightProfinite.op ⋙ G) : (lanPresheafExt i).inv.app S =\n      colimMap (whiskerLeft (CostructuredArrow.proj toLightProfinite.op S) i.inv) := by\n  simp only [lanPresheaf, pointwiseLeftKanExtension_obj, lanPresheafExt,\n    leftKanExtensionUniqueOfIso_inv, pointwiseLeftKanExtension_desc_app]\n  apply colimit.hom_ext\n  aesop\n\n"}
{"name":"LightCondensed.instFinalNatCostructuredArrowOppositeFintypeCatLightProfiniteOpToLightProfiniteOpPtAsLimitConeFunctorOp","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"S : LightProfinite\n⊢ (LightProfinite.Extend.functorOp S.asLimitCone).Final","decl":"instance : Final <| LightProfinite.Extend.functorOp S.asLimitCone :=\n  LightProfinite.Extend.functorOp_final S.asLimitCone S.asLimit\n\n"}
{"name":"LightCondensed.lanPresheafIso_hom","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"S : LightProfinite\nF : CategoryTheory.Functor (Opposite LightProfinite) (Type u)\nhF : CategoryTheory.Limits.IsColimit (F.mapCocone (CategoryTheory.Limits.coconeRightOpOfCone S.asLimitCone))\n⊢ Eq (LightCondensed.lanPresheafIso hF).hom (CategoryTheory.Limits.colimit.desc ((CategoryTheory.CostructuredArrow.proj FintypeCat.toLightProfinite.op { unop := S }).comp (FintypeCat.toLightProfinite.op.comp F)) (LightProfinite.Extend.cocone F S))","decl":"@[simp]\nlemma lanPresheafIso_hom (hF : IsColimit <| F.mapCocone (coconeRightOpOfCone S.asLimitCone)) :\n    (lanPresheafIso hF).hom = colimit.desc _ (LightProfinite.Extend.cocone _ _) := by\n  simp [lanPresheafIso, Final.colimitIso]\n  rfl\n\n"}
{"name":"LightCondensed.lanPresheafNatIso_hom_app","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite LightProfinite) (Type u)\nhF : (S : LightProfinite) → CategoryTheory.Limits.IsColimit (F.mapCocone (CategoryTheory.Limits.coconeRightOpOfCone S.asLimitCone))\nS : Opposite LightProfinite\n⊢ Eq ((LightCondensed.lanPresheafNatIso hF).hom.app S) (CategoryTheory.Limits.colimit.desc ((CategoryTheory.CostructuredArrow.proj FintypeCat.toLightProfinite.op { unop := Opposite.unop S }).comp (FintypeCat.toLightProfinite.op.comp F)) (LightProfinite.Extend.cocone F (Opposite.unop S)))","decl":"@[simp]\nlemma lanPresheafNatIso_hom_app\n    (hF : ∀ S : LightProfinite, IsColimit <| F.mapCocone (coconeRightOpOfCone S.asLimitCone))\n    (S : LightProfiniteᵒᵖ) : (lanPresheafNatIso hF).hom.app S =\n      colimit.desc _ (LightProfinite.Extend.cocone _ _) := by\n  simp [lanPresheafNatIso]\n\n"}
{"name":"LightCondensed.finYoneda_obj","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite LightProfinite) (Type u)\nX : Opposite FintypeCat\n⊢ Eq ((LightCondensed.finYoneda F).obj X) (↑(Opposite.unop X) → F.obj (FintypeCat.toLightProfinite.op.obj { unop := FintypeCat.of PUnit.{u + 1} }))","decl":"/--\nThe functor which takes a finite set to the set of maps into `F(*)` for a presheaf `F` on\n`LightProfinite`.\n-/\n@[simps]\ndef finYoneda : FintypeCat.{u}ᵒᵖ ⥤ Type u where\n  obj X := X.unop → F.obj (toLightProfinite.op.obj ⟨of PUnit.{u+1}⟩)\n  map f g := g ∘ f.unop\n\n"}
{"name":"LightCondensed.finYoneda_map","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite LightProfinite) (Type u)\nX✝ Y✝ : Opposite FintypeCat\nf : Quiver.Hom X✝ Y✝\ng : ↑(Opposite.unop X✝) → F.obj (FintypeCat.toLightProfinite.op.obj { unop := FintypeCat.of PUnit.{u + 1} })\na✝ : ↑(Opposite.unop Y✝)\n⊢ Eq ((LightCondensed.finYoneda F).map f g a✝) (Function.comp g f.unop a✝)","decl":"/--\nThe functor which takes a finite set to the set of maps into `F(*)` for a presheaf `F` on\n`LightProfinite`.\n-/\n@[simps]\ndef finYoneda : FintypeCat.{u}ᵒᵖ ⥤ Type u where\n  obj X := X.unop → F.obj (toLightProfinite.op.obj ⟨of PUnit.{u+1}⟩)\n  map f g := g ∘ f.unop\n\n"}
{"name":"LightCondensed.instPreservesLimitsOfShapeOppositeLightProfiniteDiscreteαFintype","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite LightProfinite) (Type u)\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts F\nX : FintypeCat\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete ↑X) F","decl":"noncomputable instance (X : FintypeCat.{u}) : PreservesLimitsOfShape (Discrete X) F :=\n  let X' := (Countable.toSmall.{0} X).equiv_small.choose\n  let e : X ≃ X' := (Countable.toSmall X).equiv_small.choose_spec.some\n  have : Fintype X' := Fintype.ofEquiv X e\n  preservesLimitsOfShape_of_equiv (Discrete.equivalence e.symm) F\n\n"}
{"name":"LightCondensed.isoFinYonedaComponents_hom_apply","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite LightProfinite) (Type u)\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteProducts F\nX : LightProfinite\ninst✝ : Finite ↑X.toTop\ny : F.obj { unop := X }\nx : ↑X.toTop\n⊢ Eq ((LightCondensed.isoFinYonedaComponents F X).hom y x) (F.map (CompHausLike.const (LightProfinite.of PUnit.{u + 1}) x).op y)","decl":"lemma isoFinYonedaComponents_hom_apply (X : LightProfinite.{u}) [Finite X] (y : F.obj ⟨X⟩)\n    (x : X) : (isoFinYonedaComponents F X).hom y x =\n      F.map ((LightProfinite.of PUnit.{u+1}).const x).op y := rfl\n\n"}
{"name":"LightCondensed.isoFinYonedaComponents_inv_comp","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite LightProfinite) (Type u)\ninst✝² : CategoryTheory.Limits.PreservesFiniteProducts F\nX Y : LightProfinite\ninst✝¹ : Finite ↑X.toTop\ninst✝ : Finite ↑Y.toTop\nf : ↑Y.toTop → F.obj { unop := LightProfinite.of PUnit.{u + 1} }\ng : Quiver.Hom X Y\n⊢ Eq ((LightCondensed.isoFinYonedaComponents F X).inv (Function.comp f ⇑g)) (F.map g.op ((LightCondensed.isoFinYonedaComponents F Y).inv f))","decl":"lemma isoFinYonedaComponents_inv_comp {X Y : LightProfinite.{u}} [Finite X] [Finite Y]\n    (f : Y → F.obj ⟨LightProfinite.of PUnit⟩) (g : X ⟶ Y) :\n    (isoFinYonedaComponents F X).inv (f ∘ g) = F.map g.op ((isoFinYonedaComponents F Y).inv f) := by\n  apply injective_of_mono (isoFinYonedaComponents F X).hom\n  simp only [CategoryTheory.inv_hom_id_apply]\n  ext x\n  rw [isoFinYonedaComponents_hom_apply]\n  simp only [← FunctorToTypes.map_comp_apply, ← op_comp, CompHausLike.const_comp,\n    ← isoFinYonedaComponents_hom_apply, CategoryTheory.inv_hom_id_apply, Function.comp_apply]\n\n"}
{"name":"LightCondensed.isoFinYoneda_hom_app","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite LightProfinite) (Type u)\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts F\nX : Opposite FintypeCat\na✝ : (FintypeCat.toLightProfinite.op.comp F).obj X\n⊢ Eq ((LightCondensed.isoFinYoneda F).hom.app X a✝) ((LightCondensed.isoFinYonedaComponents F (FintypeCat.toLightProfinite.obj (Opposite.unop X))).hom a✝)","decl":"/--\nThe restriction of a finite product preserving presheaf `F` on `Profinite` to the category of\nfinite sets is isomorphic to `finYoneda F`.\n-/\n@[simps!]\ndef isoFinYoneda : toLightProfinite.op ⋙ F ≅ finYoneda F :=\n  NatIso.ofComponents (fun X ↦ isoFinYonedaComponents F (toLightProfinite.obj X.unop)) fun _ ↦ by\n    simp only [comp_obj, op_obj, finYoneda_obj, Functor.comp_map, op_map]\n    ext\n    simp only [types_comp_apply, isoFinYonedaComponents_hom_apply, finYoneda_map, op_obj,\n      Function.comp_apply, Types.productLimitCone, const_obj_obj, fintypeCatAsCofan, Cofan.mk_pt,\n      cofan_mk_inj, Fan.mk_pt, Fan.mk_π_app, ← FunctorToTypes.map_comp_apply]\n    rfl\n\n"}
{"name":"LightCondensed.isoFinYoneda_inv_app","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"F : CategoryTheory.Functor (Opposite LightProfinite) (Type u)\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts F\nX : Opposite FintypeCat\na✝ : (LightCondensed.finYoneda F).obj X\n⊢ Eq ((LightCondensed.isoFinYoneda F).inv.app X a✝) ((LightCondensed.isoFinYonedaComponents F (FintypeCat.toLightProfinite.obj (Opposite.unop X))).inv a✝)","decl":"/--\nThe restriction of a finite product preserving presheaf `F` on `Profinite` to the category of\nfinite sets is isomorphic to `finYoneda F`.\n-/\n@[simps!]\ndef isoFinYoneda : toLightProfinite.op ⋙ F ≅ finYoneda F :=\n  NatIso.ofComponents (fun X ↦ isoFinYonedaComponents F (toLightProfinite.obj X.unop)) fun _ ↦ by\n    simp only [comp_obj, op_obj, finYoneda_obj, Functor.comp_map, op_map]\n    ext\n    simp only [types_comp_apply, isoFinYonedaComponents_hom_apply, finYoneda_map, op_obj,\n      Function.comp_apply, Types.productLimitCone, const_obj_obj, fintypeCatAsCofan, Cofan.mk_pt,\n      cofan_mk_inj, Fan.mk_pt, Fan.mk_π_app, ← FunctorToTypes.map_comp_apply]\n    rfl\n\n"}
{"name":"LightCondensed.isoLocallyConstantOfIsColimit_inv","module":"Mathlib.Condensed.Discrete.Colimit","initialProofState":"X : CategoryTheory.Functor (Opposite LightProfinite) (Type u)\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts X\nhX : (S : LightProfinite) → CategoryTheory.Limits.IsColimit (X.mapCocone (CategoryTheory.Limits.coconeRightOpOfCone S.asLimitCone))\n⊢ Eq (LightCondensed.isoLocallyConstantOfIsColimit X hX).inv (CompHausLike.LocallyConstant.counitApp X)","decl":"lemma isoLocallyConstantOfIsColimit_inv (X : LightProfinite.{u}ᵒᵖ ⥤ Type u)\n    [PreservesFiniteProducts X] (hX : ∀ S : LightProfinite.{u}, (IsColimit <|\n      X.mapCocone (coconeRightOpOfCone S.asLimitCone))) :\n    (isoLocallyConstantOfIsColimit X hX).inv =\n      (CompHausLike.LocallyConstant.counitApp.{u, u} X) := by\n  dsimp [isoLocallyConstantOfIsColimit]\n  simp only [Category.assoc]\n  rw [Iso.inv_comp_eq]\n  ext S : 2\n  apply colimit.hom_ext\n  intro ⟨Y, _, g⟩\n  simp? [locallyConstantIsoFinYoneda, isoFinYoneda, counitApp] says\n    simp only [comp_obj, CostructuredArrow.proj_obj, op_obj, functorToPresheaves_obj_obj,\n      isoFinYoneda, locallyConstantIsoFinYoneda, finYoneda_obj, LocallyConstant.toFun_eq_coe,\n      NatTrans.comp_app, pointwiseLeftKanExtension_obj, lanPresheafExt_inv, Iso.trans_inv,\n      Iso.symm_inv, whiskerLeft_comp, lanPresheafNatIso_hom_app, Opposite.op_unop, colimit.map_desc,\n      id_eq, Functor.comp_map, op_map, colimit.ι_desc, Cocones.precompose_obj_pt,\n      LightProfinite.Extend.cocone_pt, Cocones.precompose_obj_ι, Category.assoc, const_obj_obj,\n      whiskerLeft_app, NatIso.ofComponents_hom_app, NatIso.ofComponents_inv_app,\n      LightProfinite.Extend.cocone_ι_app, counitApp, colimit.ι_desc_assoc]\n  erw [(counitApp.{u, u} X).naturality]\n  simp only [← Category.assoc]\n  congr\n  ext f\n  simp only [types_comp_apply, isoFinYoneda_inv_app, counitApp_app]\n  apply presheaf_ext.{u, u} (X := X) (Y := X) (f := f)\n  intro x\n  rw [incl_of_counitAppApp]\n  simp only [counitAppAppImage, CompHausLike.coe_of]\n  letI : Fintype (fiber.{u, u} f x) :=\n    Fintype.ofInjective (sigmaIncl.{u, u} f x).1 Subtype.val_injective\n  apply injective_of_mono (isoFinYonedaComponents X (fiber.{u, u} f x)).hom\n  ext y\n  simp only [isoFinYonedaComponents_hom_apply, ← FunctorToTypes.map_comp_apply, ← op_comp]\n  rw [show (LightProfinite.of PUnit.{u+1}).const y ≫ IsTerminal.from _ (fiber f x) = 𝟙 _ from rfl]\n  simp only [op_comp, FunctorToTypes.map_comp_apply, op_id, FunctorToTypes.map_id_apply]\n  rw [← isoFinYonedaComponents_inv_comp X _ (sigmaIncl.{u, u} f x)]\n  simpa [← isoFinYonedaComponents_hom_apply] using x.map_eq_image f y\n\n"}
