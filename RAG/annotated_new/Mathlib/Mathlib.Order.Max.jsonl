{"name":"NoBotOrder.exists_not_ge","module":"Mathlib.Order.Max","initialProofState":"α : Type u_3\ninst✝ : LE α\nself : NoBotOrder α\na : α\n⊢ Exists fun b => Not (LE.le a b)","decl":"/-- Order without bottom elements. -/\nclass NoBotOrder (α : Type*) [LE α] : Prop where\n  /-- For each term `a`, there is some `b` which is either incomparable or strictly smaller. -/\n  exists_not_ge (a : α) : ∃ b, ¬a ≤ b\n\n"}
{"name":"NoTopOrder.exists_not_le","module":"Mathlib.Order.Max","initialProofState":"α : Type u_3\ninst✝ : LE α\nself : NoTopOrder α\na : α\n⊢ Exists fun b => Not (LE.le b a)","decl":"/-- Order without top elements. -/\nclass NoTopOrder (α : Type*) [LE α] : Prop where\n  /-- For each term `a`, there is some `b` which is either incomparable or strictly larger. -/\n  exists_not_le (a : α) : ∃ b, ¬b ≤ a\n\n"}
{"name":"NoMinOrder.exists_lt","module":"Mathlib.Order.Max","initialProofState":"α : Type u_3\ninst✝ : LT α\nself : NoMinOrder α\na : α\n⊢ Exists fun b => LT.lt b a","decl":"/-- Order without minimal elements. Sometimes called coinitial or dense. -/\nclass NoMinOrder (α : Type*) [LT α] : Prop where\n  /-- For each term `a`, there is some strictly smaller `b`. -/\n  exists_lt (a : α) : ∃ b, b < a\n\n"}
{"name":"NoMaxOrder.exists_gt","module":"Mathlib.Order.Max","initialProofState":"α : Type u_3\ninst✝ : LT α\nself : NoMaxOrder α\na : α\n⊢ Exists fun b => LT.lt a b","decl":"/-- Order without maximal elements. Sometimes called cofinal. -/\nclass NoMaxOrder (α : Type*) [LT α] : Prop where\n  /-- For each term `a`, there is some strictly greater `b`. -/\n  exists_gt (a : α) : ∃ b, a < b\n\n"}
{"name":"nonempty_lt","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝¹ : LT α\ninst✝ : NoMinOrder α\na : α\n⊢ Nonempty (Subtype fun x => LT.lt x a)","decl":"instance nonempty_lt [LT α] [NoMinOrder α] (a : α) : Nonempty { x // x < a } :=\n  nonempty_subtype.2 (exists_lt a)\n\n"}
{"name":"nonempty_gt","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝¹ : LT α\ninst✝ : NoMaxOrder α\na : α\n⊢ Nonempty (Subtype fun x => LT.lt a x)","decl":"instance nonempty_gt [LT α] [NoMaxOrder α] (a : α) : Nonempty { x // a < x } :=\n  nonempty_subtype.2 (exists_gt a)\n\n"}
{"name":"IsEmpty.toNoMaxOrder","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝¹ : LT α\ninst✝ : IsEmpty α\n⊢ NoMaxOrder α","decl":"instance IsEmpty.toNoMaxOrder [LT α] [IsEmpty α] : NoMaxOrder α := ⟨isEmptyElim⟩\n"}
{"name":"IsEmpty.toNoMinOrder","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝¹ : LT α\ninst✝ : IsEmpty α\n⊢ NoMinOrder α","decl":"instance IsEmpty.toNoMinOrder [LT α] [IsEmpty α] : NoMinOrder α := ⟨isEmptyElim⟩\n\n"}
{"name":"OrderDual.noBotOrder","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝¹ : LE α\ninst✝ : NoTopOrder α\n⊢ NoBotOrder (OrderDual α)","decl":"instance OrderDual.noBotOrder [LE α] [NoTopOrder α] : NoBotOrder αᵒᵈ :=\n  ⟨fun a => exists_not_le (α := α) a⟩\n\n"}
{"name":"OrderDual.noTopOrder","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝¹ : LE α\ninst✝ : NoBotOrder α\n⊢ NoTopOrder (OrderDual α)","decl":"instance OrderDual.noTopOrder [LE α] [NoBotOrder α] : NoTopOrder αᵒᵈ :=\n  ⟨fun a => exists_not_ge (α := α) a⟩\n\n"}
{"name":"OrderDual.noMinOrder","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝¹ : LT α\ninst✝ : NoMaxOrder α\n⊢ NoMinOrder (OrderDual α)","decl":"instance OrderDual.noMinOrder [LT α] [NoMaxOrder α] : NoMinOrder αᵒᵈ :=\n  ⟨fun a => exists_gt (α := α) a⟩\n\n"}
{"name":"OrderDual.noMaxOrder","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝¹ : LT α\ninst✝ : NoMinOrder α\n⊢ NoMaxOrder (OrderDual α)","decl":"instance OrderDual.noMaxOrder [LT α] [NoMinOrder α] : NoMaxOrder αᵒᵈ :=\n  ⟨fun a => exists_lt (α := α) a⟩\n\n-- See note [lower instance priority]\n"}
{"name":"instNoBotOrderOfNoMinOrder","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : NoMinOrder α\n⊢ NoBotOrder α","decl":"instance (priority := 100) [Preorder α] [NoMinOrder α] : NoBotOrder α :=\n  ⟨fun a => (exists_lt a).imp fun _ => not_le_of_lt⟩\n\n-- See note [lower instance priority]\n"}
{"name":"instNoTopOrderOfNoMaxOrder","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : NoMaxOrder α\n⊢ NoTopOrder α","decl":"instance (priority := 100) [Preorder α] [NoMaxOrder α] : NoTopOrder α :=\n  ⟨fun a => (exists_gt a).imp fun _ => not_le_of_lt⟩\n\n"}
{"name":"noMaxOrder_of_left","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : NoMaxOrder α\n⊢ NoMaxOrder (Prod α β)","decl":"instance noMaxOrder_of_left [Preorder α] [Preorder β] [NoMaxOrder α] : NoMaxOrder (α × β) :=\n  ⟨fun ⟨a, b⟩ => by\n    obtain ⟨c, h⟩ := exists_gt a\n    exact ⟨(c, b), Prod.mk_lt_mk_iff_left.2 h⟩⟩\n\n"}
{"name":"noMaxOrder_of_right","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : NoMaxOrder β\n⊢ NoMaxOrder (Prod α β)","decl":"instance noMaxOrder_of_right [Preorder α] [Preorder β] [NoMaxOrder β] : NoMaxOrder (α × β) :=\n  ⟨fun ⟨a, b⟩ => by\n    obtain ⟨c, h⟩ := exists_gt b\n    exact ⟨(a, c), Prod.mk_lt_mk_iff_right.2 h⟩⟩\n\n"}
{"name":"noMinOrder_of_left","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : NoMinOrder α\n⊢ NoMinOrder (Prod α β)","decl":"instance noMinOrder_of_left [Preorder α] [Preorder β] [NoMinOrder α] : NoMinOrder (α × β) :=\n  ⟨fun ⟨a, b⟩ => by\n    obtain ⟨c, h⟩ := exists_lt a\n    exact ⟨(c, b), Prod.mk_lt_mk_iff_left.2 h⟩⟩\n\n"}
{"name":"noMinOrder_of_right","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : NoMinOrder β\n⊢ NoMinOrder (Prod α β)","decl":"instance noMinOrder_of_right [Preorder α] [Preorder β] [NoMinOrder β] : NoMinOrder (α × β) :=\n  ⟨fun ⟨a, b⟩ => by\n    obtain ⟨c, h⟩ := exists_lt b\n    exact ⟨(a, c), Prod.mk_lt_mk_iff_right.2 h⟩⟩\n\n"}
{"name":"instNoMaxOrderForallOfNonempty","module":"Mathlib.Order.Max","initialProofState":"ι : Type u\nπ : ι → Type u_3\ninst✝² : Nonempty ι\ninst✝¹ : (i : ι) → Preorder (π i)\ninst✝ : ∀ (i : ι), NoMaxOrder (π i)\n⊢ NoMaxOrder ((i : ι) → π i)","decl":"instance {ι : Type u} {π : ι → Type*} [Nonempty ι] [∀ i, Preorder (π i)] [∀ i, NoMaxOrder (π i)] :\n    NoMaxOrder (∀ i, π i) :=\n  ⟨fun a => by\n    classical\n    obtain ⟨b, hb⟩ := exists_gt (a <| Classical.arbitrary _)\n    exact ⟨_, lt_update_self_iff.2 hb⟩⟩\n\n"}
{"name":"instNoMinOrderForallOfNonempty","module":"Mathlib.Order.Max","initialProofState":"ι : Type u\nπ : ι → Type u_3\ninst✝² : Nonempty ι\ninst✝¹ : (i : ι) → Preorder (π i)\ninst✝ : ∀ (i : ι), NoMinOrder (π i)\n⊢ NoMinOrder ((i : ι) → π i)","decl":"instance {ι : Type u} {π : ι → Type*} [Nonempty ι] [∀ i, Preorder (π i)] [∀ i, NoMinOrder (π i)] :\n    NoMinOrder (∀ i, π i) :=\n  ⟨fun a => by\n     classical\n      obtain ⟨b, hb⟩ := exists_lt (a <| Classical.arbitrary _)\n      exact ⟨_, update_lt_self_iff.2 hb⟩⟩\n\n-- Porting note: mathlib3 proof uses `convert`\n"}
{"name":"NoBotOrder.to_noMinOrder","module":"Mathlib.Order.Max","initialProofState":"α : Type u_3\ninst✝¹ : LinearOrder α\ninst✝ : NoBotOrder α\n⊢ NoMinOrder α","decl":"theorem NoBotOrder.to_noMinOrder (α : Type*) [LinearOrder α] [NoBotOrder α] : NoMinOrder α :=\n  { exists_lt := fun a => by simpa [not_le] using exists_not_ge a }\n\n-- Porting note: mathlib3 proof uses `convert`\n"}
{"name":"NoTopOrder.to_noMaxOrder","module":"Mathlib.Order.Max","initialProofState":"α : Type u_3\ninst✝¹ : LinearOrder α\ninst✝ : NoTopOrder α\n⊢ NoMaxOrder α","decl":"theorem NoTopOrder.to_noMaxOrder (α : Type*) [LinearOrder α] [NoTopOrder α] : NoMaxOrder α :=\n  { exists_gt := fun a => by simpa [not_le] using exists_not_le a }\n\n"}
{"name":"noBotOrder_iff_noMinOrder","module":"Mathlib.Order.Max","initialProofState":"α : Type u_3\ninst✝ : LinearOrder α\n⊢ Iff (NoBotOrder α) (NoMinOrder α)","decl":"theorem noBotOrder_iff_noMinOrder (α : Type*) [LinearOrder α] : NoBotOrder α ↔ NoMinOrder α :=\n  ⟨fun h =>\n    haveI := h\n    NoBotOrder.to_noMinOrder α,\n    fun h =>\n    haveI := h\n    inferInstance⟩\n\n"}
{"name":"noTopOrder_iff_noMaxOrder","module":"Mathlib.Order.Max","initialProofState":"α : Type u_3\ninst✝ : LinearOrder α\n⊢ Iff (NoTopOrder α) (NoMaxOrder α)","decl":"theorem noTopOrder_iff_noMaxOrder (α : Type*) [LinearOrder α] : NoTopOrder α ↔ NoMaxOrder α :=\n  ⟨fun h =>\n    haveI := h\n    NoTopOrder.to_noMaxOrder α,\n    fun h =>\n    haveI := h\n    inferInstance⟩\n\n"}
{"name":"NoMinOrder.not_acc","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝¹ : LT α\ninst✝ : NoMinOrder α\na : α\n⊢ Not (Acc (fun x1 x2 => LT.lt x1 x2) a)","decl":"theorem NoMinOrder.not_acc [LT α] [NoMinOrder α] (a : α) : ¬Acc (· < ·) a := fun h =>\n  Acc.recOn h fun x _ => (exists_lt x).recOn\n\n"}
{"name":"NoMaxOrder.not_acc","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝¹ : LT α\ninst✝ : NoMaxOrder α\na : α\n⊢ Not (Acc (fun x1 x2 => GT.gt x1 x2) a)","decl":"theorem NoMaxOrder.not_acc [LT α] [NoMaxOrder α] (a : α) : ¬Acc (· > ·) a := fun h =>\n  Acc.recOn h fun x _ => (exists_gt x).recOn\n\n"}
{"name":"not_isBot","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝¹ : LE α\ninst✝ : NoBotOrder α\na : α\n⊢ Not (IsBot a)","decl":"@[simp]\ntheorem not_isBot [NoBotOrder α] (a : α) : ¬IsBot a := fun h =>\n  let ⟨_, hb⟩ := exists_not_ge a\n  hb <| h _\n\n"}
{"name":"not_isTop","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝¹ : LE α\ninst✝ : NoTopOrder α\na : α\n⊢ Not (IsTop a)","decl":"@[simp]\ntheorem not_isTop [NoTopOrder α] (a : α) : ¬IsTop a := fun h =>\n  let ⟨_, hb⟩ := exists_not_le a\n  hb <| h _\n\n"}
{"name":"IsBot.isMin","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : LE α\na : α\nh : IsBot a\n⊢ IsMin a","decl":"protected theorem IsBot.isMin (h : IsBot a) : IsMin a := fun b _ => h b\n\n"}
{"name":"IsTop.isMax","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : LE α\na : α\nh : IsTop a\n⊢ IsMax a","decl":"protected theorem IsTop.isMax (h : IsTop a) : IsMax a := fun b _ => h b\n\n"}
{"name":"IsTop.isMax_iff","module":"Mathlib.Order.Max","initialProofState":"α : Type u_3\ninst✝ : PartialOrder α\ni j : α\nh : IsTop i\n⊢ Iff (IsMax j) (Eq j i)","decl":"theorem IsTop.isMax_iff {α} [PartialOrder α] {i j : α} (h : IsTop i) : IsMax j ↔ j = i := by\n  simp_rw [le_antisymm_iff, h j, true_and]\n  exact ⟨(· (h j)), Function.swap (fun _ ↦ h · |>.trans ·)⟩\n\n"}
{"name":"IsBot.isMin_iff","module":"Mathlib.Order.Max","initialProofState":"α : Type u_3\ninst✝ : PartialOrder α\ni j : α\nh : IsBot i\n⊢ Iff (IsMin j) (Eq j i)","decl":"theorem IsBot.isMin_iff {α} [PartialOrder α] {i j : α} (h : IsBot i) : IsMin j ↔ j = i := by\n  simp_rw [le_antisymm_iff, h j, and_true]\n  exact ⟨fun a ↦ a (h j), fun a h' ↦ fun _ ↦ Preorder.le_trans j i h' a (h h')⟩\n\n"}
{"name":"isBot_toDual_iff","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : LE α\na : α\n⊢ Iff (IsBot (OrderDual.toDual a)) (IsTop a)","decl":"@[simp]\ntheorem isBot_toDual_iff : IsBot (toDual a) ↔ IsTop a :=\n  Iff.rfl\n\n"}
{"name":"isTop_toDual_iff","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : LE α\na : α\n⊢ Iff (IsTop (OrderDual.toDual a)) (IsBot a)","decl":"@[simp]\ntheorem isTop_toDual_iff : IsTop (toDual a) ↔ IsBot a :=\n  Iff.rfl\n\n"}
{"name":"isMin_toDual_iff","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : LE α\na : α\n⊢ Iff (IsMin (OrderDual.toDual a)) (IsMax a)","decl":"@[simp]\ntheorem isMin_toDual_iff : IsMin (toDual a) ↔ IsMax a :=\n  Iff.rfl\n\n"}
{"name":"isMax_toDual_iff","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : LE α\na : α\n⊢ Iff (IsMax (OrderDual.toDual a)) (IsMin a)","decl":"@[simp]\ntheorem isMax_toDual_iff : IsMax (toDual a) ↔ IsMin a :=\n  Iff.rfl\n\n"}
{"name":"isBot_ofDual_iff","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : LE α\na : OrderDual α\n⊢ Iff (IsBot (OrderDual.ofDual a)) (IsTop a)","decl":"@[simp]\ntheorem isBot_ofDual_iff {a : αᵒᵈ} : IsBot (ofDual a) ↔ IsTop a :=\n  Iff.rfl\n\n"}
{"name":"isTop_ofDual_iff","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : LE α\na : OrderDual α\n⊢ Iff (IsTop (OrderDual.ofDual a)) (IsBot a)","decl":"@[simp]\ntheorem isTop_ofDual_iff {a : αᵒᵈ} : IsTop (ofDual a) ↔ IsBot a :=\n  Iff.rfl\n\n"}
{"name":"isMin_ofDual_iff","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : LE α\na : OrderDual α\n⊢ Iff (IsMin (OrderDual.ofDual a)) (IsMax a)","decl":"@[simp]\ntheorem isMin_ofDual_iff {a : αᵒᵈ} : IsMin (ofDual a) ↔ IsMax a :=\n  Iff.rfl\n\n"}
{"name":"isMax_ofDual_iff","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : LE α\na : OrderDual α\n⊢ Iff (IsMax (OrderDual.ofDual a)) (IsMin a)","decl":"@[simp]\ntheorem isMax_ofDual_iff {a : αᵒᵈ} : IsMax (ofDual a) ↔ IsMin a :=\n  Iff.rfl\n\n"}
{"name":"IsTop.toDual","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : LE α\na : α\na✝ : IsTop a\n⊢ IsBot (OrderDual.toDual a)","decl":"alias ⟨_, IsTop.toDual⟩ := isBot_toDual_iff\n\n"}
{"name":"IsBot.toDual","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : LE α\na : α\na✝ : IsBot a\n⊢ IsTop (OrderDual.toDual a)","decl":"alias ⟨_, IsBot.toDual⟩ := isTop_toDual_iff\n\n"}
{"name":"IsMax.toDual","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : LE α\na : α\na✝ : IsMax a\n⊢ IsMin (OrderDual.toDual a)","decl":"alias ⟨_, IsMax.toDual⟩ := isMin_toDual_iff\n\n"}
{"name":"IsMin.toDual","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : LE α\na : α\na✝ : IsMin a\n⊢ IsMax (OrderDual.toDual a)","decl":"alias ⟨_, IsMin.toDual⟩ := isMax_toDual_iff\n\n"}
{"name":"IsTop.ofDual","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : LE α\na : OrderDual α\na✝ : IsTop a\n⊢ IsBot (OrderDual.ofDual a)","decl":"alias ⟨_, IsTop.ofDual⟩ := isBot_ofDual_iff\n\n"}
{"name":"IsBot.ofDual","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : LE α\na : OrderDual α\na✝ : IsBot a\n⊢ IsTop (OrderDual.ofDual a)","decl":"alias ⟨_, IsBot.ofDual⟩ := isTop_ofDual_iff\n\n"}
{"name":"IsMax.ofDual","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : LE α\na : OrderDual α\na✝ : IsMax a\n⊢ IsMin (OrderDual.ofDual a)","decl":"alias ⟨_, IsMax.ofDual⟩ := isMin_ofDual_iff\n\n"}
{"name":"IsMin.ofDual","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : LE α\na : OrderDual α\na✝ : IsMin a\n⊢ IsMax (OrderDual.ofDual a)","decl":"alias ⟨_, IsMin.ofDual⟩ := isMax_ofDual_iff\n\n"}
{"name":"IsBot.mono","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nha : IsBot a\nh : LE.le b a\n⊢ IsBot b","decl":"theorem IsBot.mono (ha : IsBot a) (h : b ≤ a) : IsBot b := fun _ => h.trans <| ha _\n\n"}
{"name":"IsTop.mono","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nha : IsTop a\nh : LE.le a b\n⊢ IsTop b","decl":"theorem IsTop.mono (ha : IsTop a) (h : a ≤ b) : IsTop b := fun _ => (ha _).trans h\n\n"}
{"name":"IsMin.mono","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nha : IsMin a\nh : LE.le b a\n⊢ IsMin b","decl":"theorem IsMin.mono (ha : IsMin a) (h : b ≤ a) : IsMin b := fun _ hc => h.trans <| ha <| hc.trans h\n\n"}
{"name":"IsMax.mono","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nha : IsMax a\nh : LE.le a b\n⊢ IsMax b","decl":"theorem IsMax.mono (ha : IsMax a) (h : a ≤ b) : IsMax b := fun _ hc => (ha <| h.trans hc).trans h\n\n"}
{"name":"IsMin.not_lt","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : IsMin a\n⊢ Not (LT.lt b a)","decl":"theorem IsMin.not_lt (h : IsMin a) : ¬b < a := fun hb => hb.not_le <| h hb.le\n\n"}
{"name":"IsMax.not_lt","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : IsMax a\n⊢ Not (LT.lt a b)","decl":"theorem IsMax.not_lt (h : IsMax a) : ¬a < b := fun hb => hb.not_le <| h hb.le\n\n"}
{"name":"not_isMin_of_lt","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : LT.lt b a\n⊢ Not (IsMin a)","decl":"@[simp]\ntheorem not_isMin_of_lt (h : b < a) : ¬IsMin a := fun ha => ha.not_lt h\n\n"}
{"name":"not_isMax_of_lt","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : LT.lt a b\n⊢ Not (IsMax a)","decl":"@[simp]\ntheorem not_isMax_of_lt (h : a < b) : ¬IsMax a := fun ha => ha.not_lt h\n\n"}
{"name":"LT.lt.not_isMin","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : LT.lt b a\n⊢ Not (IsMin a)","decl":"alias LT.lt.not_isMin := not_isMin_of_lt\n\n"}
{"name":"LT.lt.not_isMax","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : LT.lt a b\n⊢ Not (IsMax a)","decl":"alias LT.lt.not_isMax := not_isMax_of_lt\n\n"}
{"name":"isMin_iff_forall_not_lt","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Iff (IsMin a) (∀ (b : α), Not (LT.lt b a))","decl":"theorem isMin_iff_forall_not_lt : IsMin a ↔ ∀ b, ¬b < a :=\n  ⟨fun h _ => h.not_lt, fun h _ hba => of_not_not fun hab => h _ <| hba.lt_of_not_le hab⟩\n\n"}
{"name":"isMax_iff_forall_not_lt","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Iff (IsMax a) (∀ (b : α), Not (LT.lt a b))","decl":"theorem isMax_iff_forall_not_lt : IsMax a ↔ ∀ b, ¬a < b :=\n  ⟨fun h _ => h.not_lt, fun h _ hba => of_not_not fun hab => h _ <| hba.lt_of_not_le hab⟩\n\n"}
{"name":"not_isMin_iff","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Iff (Not (IsMin a)) (Exists fun b => LT.lt b a)","decl":"@[simp]\ntheorem not_isMin_iff : ¬IsMin a ↔ ∃ b, b < a := by\n  simp [lt_iff_le_not_le, IsMin, not_forall, exists_prop]\n\n"}
{"name":"not_isMax_iff","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Iff (Not (IsMax a)) (Exists fun b => LT.lt a b)","decl":"@[simp]\ntheorem not_isMax_iff : ¬IsMax a ↔ ∃ b, a < b := by\n  simp [lt_iff_le_not_le, IsMax, not_forall, exists_prop]\n\n"}
{"name":"not_isMin","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : NoMinOrder α\na : α\n⊢ Not (IsMin a)","decl":"@[simp]\ntheorem not_isMin [NoMinOrder α] (a : α) : ¬IsMin a :=\n  not_isMin_iff.2 <| exists_lt a\n\n"}
{"name":"not_isMax","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : NoMaxOrder α\na : α\n⊢ Not (IsMax a)","decl":"@[simp]\ntheorem not_isMax [NoMaxOrder α] (a : α) : ¬IsMax a :=\n  not_isMax_iff.2 <| exists_gt a\n\n"}
{"name":"Subsingleton.isBot","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Subsingleton α\na : α\n⊢ IsBot a","decl":"protected theorem isBot (a : α) : IsBot a := fun _ => (Subsingleton.elim _ _).le\n\n"}
{"name":"Subsingleton.isTop","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Subsingleton α\na : α\n⊢ IsTop a","decl":"protected theorem isTop (a : α) : IsTop a := fun _ => (Subsingleton.elim _ _).le\n\n"}
{"name":"Subsingleton.isMin","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Subsingleton α\na : α\n⊢ IsMin a","decl":"protected theorem isMin (a : α) : IsMin a :=\n  (Subsingleton.isBot _).isMin\n\n"}
{"name":"Subsingleton.isMax","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Subsingleton α\na : α\n⊢ IsMax a","decl":"protected theorem isMax (a : α) : IsMax a :=\n  (Subsingleton.isTop _).isMax\n\n"}
{"name":"IsMin.eq_of_le","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nha : IsMin a\nh : LE.le b a\n⊢ Eq b a","decl":"protected theorem IsMin.eq_of_le (ha : IsMin a) (h : b ≤ a) : b = a :=\n  h.antisymm <| ha h\n\n"}
{"name":"IsMin.eq_of_ge","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nha : IsMin a\nh : LE.le b a\n⊢ Eq a b","decl":"protected theorem IsMin.eq_of_ge (ha : IsMin a) (h : b ≤ a) : a = b :=\n  h.antisymm' <| ha h\n\n"}
{"name":"IsMax.eq_of_le","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nha : IsMax a\nh : LE.le a b\n⊢ Eq a b","decl":"protected theorem IsMax.eq_of_le (ha : IsMax a) (h : a ≤ b) : a = b :=\n  h.antisymm <| ha h\n\n"}
{"name":"IsMax.eq_of_ge","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nha : IsMax a\nh : LE.le a b\n⊢ Eq b a","decl":"protected theorem IsMax.eq_of_ge (ha : IsMax a) (h : a ≤ b) : b = a :=\n  h.antisymm' <| ha h\n\n"}
{"name":"IsBot.lt_of_ne","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nha : IsBot a\nh : Ne a b\n⊢ LT.lt a b","decl":"protected theorem IsBot.lt_of_ne (ha : IsBot a) (h : a ≠ b) : a < b :=\n  (ha b).lt_of_ne h\n\n"}
{"name":"IsTop.lt_of_ne","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nha : IsTop a\nh : Ne b a\n⊢ LT.lt b a","decl":"protected theorem IsTop.lt_of_ne (ha : IsTop a) (h : b ≠ a) : b < a :=\n  (ha b).lt_of_ne h\n\n"}
{"name":"IsBot.not_isMax","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\na : α\ninst✝ : Nontrivial α\nha : IsBot a\n⊢ Not (IsMax a)","decl":"protected theorem IsBot.not_isMax [Nontrivial α] (ha : IsBot a) : ¬ IsMax a := by\n  intro ha'\n  obtain ⟨b, hb⟩ := exists_ne a\n  exact hb <| ha'.eq_of_ge (ha.lt_of_ne hb.symm).le\n\n"}
{"name":"IsTop.not_isMin","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\na : α\ninst✝ : Nontrivial α\nha : IsTop a\n⊢ Not (IsMin a)","decl":"protected theorem IsTop.not_isMin [Nontrivial α] (ha : IsTop a) : ¬ IsMin a :=\n  ha.toDual.not_isMax\n\n"}
{"name":"IsBot.not_isTop","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\na : α\ninst✝ : Nontrivial α\nha : IsBot a\n⊢ Not (IsTop a)","decl":"protected theorem IsBot.not_isTop [Nontrivial α] (ha : IsBot a) : ¬ IsTop a :=\n  mt IsTop.isMax ha.not_isMax\n\n"}
{"name":"IsTop.not_isBot","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\na : α\ninst✝ : Nontrivial α\nha : IsTop a\n⊢ Not (IsBot a)","decl":"protected theorem IsTop.not_isBot [Nontrivial α] (ha : IsTop a) : ¬ IsBot a :=\n  ha.toDual.not_isTop\n\n"}
{"name":"IsBot.prod_mk","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na : α\nb : β\nha : IsBot a\nhb : IsBot b\n⊢ IsBot { fst := a, snd := b }","decl":"theorem IsBot.prod_mk (ha : IsBot a) (hb : IsBot b) : IsBot (a, b) := fun _ => ⟨ha _, hb _⟩\n\n"}
{"name":"IsTop.prod_mk","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na : α\nb : β\nha : IsTop a\nhb : IsTop b\n⊢ IsTop { fst := a, snd := b }","decl":"theorem IsTop.prod_mk (ha : IsTop a) (hb : IsTop b) : IsTop (a, b) := fun _ => ⟨ha _, hb _⟩\n\n"}
{"name":"IsMin.prod_mk","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na : α\nb : β\nha : IsMin a\nhb : IsMin b\n⊢ IsMin { fst := a, snd := b }","decl":"theorem IsMin.prod_mk (ha : IsMin a) (hb : IsMin b) : IsMin (a, b) := fun _ hc => ⟨ha hc.1, hb hc.2⟩\n\n"}
{"name":"IsMax.prod_mk","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na : α\nb : β\nha : IsMax a\nhb : IsMax b\n⊢ IsMax { fst := a, snd := b }","decl":"theorem IsMax.prod_mk (ha : IsMax a) (hb : IsMax b) : IsMax (a, b) := fun _ hc => ⟨ha hc.1, hb hc.2⟩\n\n"}
{"name":"IsBot.fst","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nx : Prod α β\nhx : IsBot x\n⊢ IsBot x.fst","decl":"theorem IsBot.fst (hx : IsBot x) : IsBot x.1 := fun c => (hx (c, x.2)).1\n\n"}
{"name":"IsBot.snd","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nx : Prod α β\nhx : IsBot x\n⊢ IsBot x.snd","decl":"theorem IsBot.snd (hx : IsBot x) : IsBot x.2 := fun c => (hx (x.1, c)).2\n\n"}
{"name":"IsTop.fst","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nx : Prod α β\nhx : IsTop x\n⊢ IsTop x.fst","decl":"theorem IsTop.fst (hx : IsTop x) : IsTop x.1 := fun c => (hx (c, x.2)).1\n\n"}
{"name":"IsTop.snd","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nx : Prod α β\nhx : IsTop x\n⊢ IsTop x.snd","decl":"theorem IsTop.snd (hx : IsTop x) : IsTop x.2 := fun c => (hx (x.1, c)).2\n\n"}
{"name":"IsMin.fst","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nx : Prod α β\nhx : IsMin x\n⊢ IsMin x.fst","decl":"theorem IsMin.fst (hx : IsMin x) : IsMin x.1 :=\n  fun c hc => (hx <| show (c, x.2) ≤ x from (and_iff_left le_rfl).2 hc).1\n\n"}
{"name":"IsMin.snd","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nx : Prod α β\nhx : IsMin x\n⊢ IsMin x.snd","decl":"theorem IsMin.snd (hx : IsMin x) : IsMin x.2 :=\n  fun c hc => (hx <| show (x.1, c) ≤ x from (and_iff_right le_rfl).2 hc).2\n\n"}
{"name":"IsMax.fst","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nx : Prod α β\nhx : IsMax x\n⊢ IsMax x.fst","decl":"theorem IsMax.fst (hx : IsMax x) : IsMax x.1 :=\n  fun c hc => (hx <| show x ≤ (c, x.2) from (and_iff_left le_rfl).2 hc).1\n\n"}
{"name":"IsMax.snd","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nx : Prod α β\nhx : IsMax x\n⊢ IsMax x.snd","decl":"theorem IsMax.snd (hx : IsMax x) : IsMax x.2 :=\n  fun c hc => (hx <| show x ≤ (x.1, c) from (and_iff_right le_rfl).2 hc).2\n\n"}
{"name":"Prod.isBot_iff","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nx : Prod α β\n⊢ Iff (IsBot x) (And (IsBot x.fst) (IsBot x.snd))","decl":"theorem Prod.isBot_iff : IsBot x ↔ IsBot x.1 ∧ IsBot x.2 :=\n  ⟨fun hx => ⟨hx.fst, hx.snd⟩, fun h => h.1.prod_mk h.2⟩\n\n"}
{"name":"Prod.isTop_iff","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nx : Prod α β\n⊢ Iff (IsTop x) (And (IsTop x.fst) (IsTop x.snd))","decl":"theorem Prod.isTop_iff : IsTop x ↔ IsTop x.1 ∧ IsTop x.2 :=\n  ⟨fun hx => ⟨hx.fst, hx.snd⟩, fun h => h.1.prod_mk h.2⟩\n\n"}
{"name":"Prod.isMin_iff","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nx : Prod α β\n⊢ Iff (IsMin x) (And (IsMin x.fst) (IsMin x.snd))","decl":"theorem Prod.isMin_iff : IsMin x ↔ IsMin x.1 ∧ IsMin x.2 :=\n  ⟨fun hx => ⟨hx.fst, hx.snd⟩, fun h => h.1.prod_mk h.2⟩\n\n"}
{"name":"Prod.isMax_iff","module":"Mathlib.Order.Max","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nx : Prod α β\n⊢ Iff (IsMax x) (And (IsMax x.fst) (IsMax x.snd))","decl":"theorem Prod.isMax_iff : IsMax x ↔ IsMax x.1 ∧ IsMax x.2 :=\n  ⟨fun hx => ⟨hx.fst, hx.snd⟩, fun h => h.1.prod_mk h.2⟩\n\n"}
