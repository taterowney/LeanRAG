{"name":"IsLocalizedModule.linearIndependent_lift","module":"Mathlib.LinearAlgebra.Dimension.Localization","initialProofState":"R : Type u\nS : Type u'\nM : Type v\nN : Type v'\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : AddCommGroup N\ninst✝⁶ : Module R M\ninst✝⁵ : Module R N\ninst✝⁴ : Algebra R S\ninst✝³ : Module S N\ninst✝² : IsScalarTower R S N\np : Submonoid R\ninst✝¹ : IsLocalization p S\nf : LinearMap (RingHom.id R) M N\ninst✝ : IsLocalizedModule p f\nhp : LE.le p (nonZeroDivisors R)\nι : Type u_1\nv : ι → N\nhf : LinearIndependent S v\n⊢ Exists fun w => LinearIndependent R w","decl":"variable {S} in\nlemma IsLocalizedModule.linearIndependent_lift {ι} {v : ι → N} (hf : LinearIndependent S v) :\n    ∃ w : ι → M, LinearIndependent R w := by\n  choose sec hsec using IsLocalizedModule.surj p f\n  use fun i ↦ (sec (v i)).1\n  rw [linearIndependent_iff'] at hf ⊢\n  intro t g hg i hit\n  apply hp (sec (v i)).2.prop\n  apply IsLocalization.injective S hp\n  rw [map_zero]\n  refine hf t (fun i ↦ algebraMap R S (g i * (sec (v i)).2)) ?_ _ hit\n  simp only [map_mul, mul_smul, algebraMap_smul, ← Submonoid.smul_def,\n    hsec, ← map_smul, ← map_sum, hg, map_zero]\n\n"}
{"name":"IsLocalizedModule.lift_rank_eq","module":"Mathlib.LinearAlgebra.Dimension.Localization","initialProofState":"R : Type u\nS : Type u'\nM : Type v\nN : Type v'\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : AddCommGroup N\ninst✝⁶ : Module R M\ninst✝⁵ : Module R N\ninst✝⁴ : Algebra R S\ninst✝³ : Module S N\ninst✝² : IsScalarTower R S N\np : Submonoid R\ninst✝¹ : IsLocalization p S\nf : LinearMap (RingHom.id R) M N\ninst✝ : IsLocalizedModule p f\nhp : LE.le p (nonZeroDivisors R)\n⊢ Eq (Cardinal.lift.{v, v'} (Module.rank S N)) (Cardinal.lift.{v', v} (Module.rank R M))","decl":"lemma IsLocalizedModule.lift_rank_eq :\n    Cardinal.lift.{v} (Module.rank S N) = Cardinal.lift.{v'} (Module.rank R M) := by\n  cases' subsingleton_or_nontrivial R\n  · have := (algebraMap R S).codomain_trivial; simp only [rank_subsingleton, lift_one]\n  have := (IsLocalization.injective S hp).nontrivial\n  apply le_antisymm <;>\n    rw [Module.rank_def, lift_iSup (bddAbove_range _)] <;>\n    apply ciSup_le' <;>\n    intro ⟨s, hs⟩\n  · exact (IsLocalizedModule.linearIndependent_lift p f hp hs).choose_spec.cardinal_lift_le_rank\n  · choose sec hsec using IsLocalization.surj p (S := S)\n    refine LinearIndependent.cardinal_lift_le_rank (ι := s) (v := fun i ↦ f i) ?_\n    rw [linearIndependent_iff'] at hs ⊢\n    intro t g hg i hit\n    apply (IsLocalization.map_units S (sec (g i)).2).mul_left_injective\n    classical\n    let u := fun (i : s) ↦ (t.erase i).prod (fun j ↦ (sec (g j)).2)\n    have : f (t.sum fun i ↦ u i • (sec (g i)).1 • i) = f 0 := by\n      convert congr_arg (t.prod (fun j ↦ (sec (g j)).2) • ·) hg\n      · simp only [map_sum, map_smul, Submonoid.smul_def, Finset.smul_sum]\n        apply Finset.sum_congr rfl\n        intro j hj\n        simp only [u, ← @IsScalarTower.algebraMap_smul R S N, Submonoid.coe_finset_prod, map_prod]\n        rw [← hsec, mul_comm (g j), mul_smul, ← mul_smul, Finset.prod_erase_mul (h := hj)]\n      rw [map_zero, smul_zero]\n    obtain ⟨c, hc⟩ := IsLocalizedModule.exists_of_eq (S := p) this\n    simp_rw [smul_zero, Finset.smul_sum, ← mul_smul, Submonoid.smul_def, ← mul_smul, mul_comm] at hc\n    simp only [hsec, zero_mul, map_eq_zero_iff (algebraMap R S) (IsLocalization.injective S hp)]\n    apply hp (c * u i).prop\n    exact hs t _ hc _ hit\n\n"}
{"name":"IsLocalizedModule.rank_eq","module":"Mathlib.LinearAlgebra.Dimension.Localization","initialProofState":"R : Type u\nS : Type u'\nM : Type v\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : Algebra R S\np : Submonoid R\ninst✝⁵ : IsLocalization p S\nhp : LE.le p (nonZeroDivisors R)\nN : Type v\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R N\ninst✝² : Module S N\ninst✝¹ : IsScalarTower R S N\nf : LinearMap (RingHom.id R) M N\ninst✝ : IsLocalizedModule p f\n⊢ Eq (Module.rank S N) (Module.rank R M)","decl":"lemma IsLocalizedModule.rank_eq {N : Type v} [AddCommGroup N]\n    [Module R N] [Module S N] [IsScalarTower R S N] (f : M →ₗ[R] N) [IsLocalizedModule p f] :\n    Module.rank S N = Module.rank R M := by simpa using IsLocalizedModule.lift_rank_eq S p f hp\n\n"}
{"name":"exists_set_linearIndependent_of_isDomain","module":"Mathlib.LinearAlgebra.Dimension.Localization","initialProofState":"R : Type u\nM : Type v\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsDomain R\n⊢ Exists fun s => And (Eq (Cardinal.mk ↑s) (Module.rank R M)) (LinearIndependent R Subtype.val)","decl":"variable (R M) in\ntheorem exists_set_linearIndependent_of_isDomain [IsDomain R] :\n    ∃ s : Set M, #s = Module.rank R M ∧ LinearIndependent (ι := s) R Subtype.val := by\n  obtain ⟨w, hw⟩ :=\n    IsLocalizedModule.linearIndependent_lift R⁰ (LocalizedModule.mkLinearMap R⁰ M) le_rfl\n      (Module.Free.chooseBasis (FractionRing R) (LocalizedModule R⁰ M)).linearIndependent\n  refine ⟨Set.range w, ?_, (linearIndependent_subtype_range hw.injective).mpr hw⟩\n  apply Cardinal.lift_injective.{max u v}\n  rw [Cardinal.mk_range_eq_of_injective hw.injective, ← Module.Free.rank_eq_card_chooseBasisIndex,\n  IsLocalizedModule.lift_rank_eq (FractionRing R) R⁰ (LocalizedModule.mkLinearMap R⁰ M) le_rfl]\n\n"}
{"name":"rank_quotient_add_rank_of_isDomain","module":"Mathlib.LinearAlgebra.Dimension.Localization","initialProofState":"R : Type u\nM : Type v\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsDomain R\nM' : Submodule R M\n⊢ Eq (HAdd.hAdd (Module.rank R (HasQuotient.Quotient M M')) (Module.rank R (Subtype fun x => Membership.mem M' x))) (Module.rank R M)","decl":"/-- The **rank-nullity theorem** for commutative domains. Also see `rank_quotient_add_rank`. -/\ntheorem rank_quotient_add_rank_of_isDomain [IsDomain R] (M' : Submodule R M) :\n    Module.rank R (M ⧸ M') + Module.rank R M' = Module.rank R M := by\n  apply lift_injective.{max u v}\n  rw [lift_add, ← IsLocalizedModule.lift_rank_eq (FractionRing R) R⁰ (M'.toLocalized R⁰) le_rfl,\n    ← IsLocalizedModule.lift_rank_eq (FractionRing R) R⁰ (LocalizedModule.mkLinearMap R⁰ M) le_rfl,\n    ← IsLocalizedModule.lift_rank_eq (FractionRing R) R⁰ (M'.toLocalizedQuotient R⁰) le_rfl,\n    ← lift_add, rank_quotient_add_rank_of_divisionRing]\n\n"}
{"name":"IsDomain.hasRankNullity","module":"Mathlib.LinearAlgebra.Dimension.Localization","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ HasRankNullity.{w, u} R","decl":"universe w in\ninstance IsDomain.hasRankNullity [IsDomain R] : HasRankNullity.{w} R where\n  rank_quotient_add_rank := rank_quotient_add_rank_of_isDomain\n  exists_set_linearIndependent M := exists_set_linearIndependent_of_isDomain R M\n\n"}
{"name":"aleph0_le_rank_of_isEmpty_oreSet","module":"Mathlib.LinearAlgebra.Dimension.Localization","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : IsDomain R\nhS : IsEmpty (OreLocalization.OreSet (nonZeroDivisors R))\n⊢ LE.le Cardinal.aleph0 (Module.rank R R)","decl":"/-- A domain that is not (left) Ore is of infinite rank.\nSee [cohn_1995] Proposition 1.3.6 -/\nlemma aleph0_le_rank_of_isEmpty_oreSet (hS : IsEmpty (OreLocalization.OreSet R⁰)) :\n    ℵ₀ ≤ Module.rank R R := by\n  classical\n  rw [← not_nonempty_iff, OreLocalization.nonempty_oreSet_iff_of_noZeroDivisors] at hS\n  push_neg at hS\n  obtain ⟨r, s, h⟩ := hS\n  refine Cardinal.aleph0_le.mpr fun n ↦ ?_\n  suffices LinearIndependent R (fun (i : Fin n) ↦ r * s ^ (i : ℕ)) by\n    simpa using this.cardinal_lift_le_rank\n  suffices ∀ (g : ℕ → R) (x), (∑ i ∈ Finset.range n, g i • (r * s ^ (i + x))) = 0 →\n      ∀ i < n, g i = 0 by\n    refine Fintype.linearIndependent_iff.mpr fun g hg i ↦ ?_\n    simpa only [dif_pos i.prop] using this (fun i ↦ if h : i < n then g ⟨i, h⟩ else 0) 0\n      (by simp [← Fin.sum_univ_eq_sum_range, ← hg]) i i.prop\n  intro g x hg i hin\n  induction' n with n IH generalizing g x i\n  · exact (hin.not_le (zero_le i)).elim\n  · rw [Finset.sum_range_succ'] at hg\n    by_cases hg0 : g 0 = 0\n    · simp only [hg0, zero_smul, add_zero, add_assoc] at hg\n      cases i; exacts [hg0, IH _ _ hg _ (Nat.succ_lt_succ_iff.mp hin)]\n    simp only [MulOpposite.smul_eq_mul_unop, zero_add, ← add_comm _ x, pow_add _ _ x,\n      ← mul_assoc, pow_succ, ← Finset.sum_mul, pow_zero, one_mul, smul_eq_mul] at hg\n    rw [← neg_eq_iff_add_eq_zero, ← neg_mul, ← neg_mul] at hg\n    have := mul_right_cancel₀ (mem_nonZeroDivisors_iff_ne_zero.mp (s ^ x).prop) hg\n    exact (h _ ⟨(g 0), mem_nonZeroDivisors_iff_ne_zero.mpr (by simpa)⟩ this.symm).elim\n\n-- TODO: Upgrade this to an iff. See [lam_1999] Exercise 10.21\n"}
{"name":"nonempty_oreSet_of_strongRankCondition","module":"Mathlib.LinearAlgebra.Dimension.Localization","initialProofState":"R : Type u_1\ninst✝² : Ring R\ninst✝¹ : IsDomain R\ninst✝ : StrongRankCondition R\n⊢ Nonempty (OreLocalization.OreSet (nonZeroDivisors R))","decl":"lemma nonempty_oreSet_of_strongRankCondition [StrongRankCondition R] :\n    Nonempty (OreLocalization.OreSet R⁰) := by\n  by_contra h\n  have := aleph0_le_rank_of_isEmpty_oreSet (not_nonempty_iff.mp h)\n  rw [rank_self] at this\n  exact this.not_lt one_lt_aleph0\n\n"}
