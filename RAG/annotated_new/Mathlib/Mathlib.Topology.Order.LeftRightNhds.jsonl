{"name":"TFAE_mem_nhdsGT","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na b : Œ±\nhab : LT.lt a b\ns : Set Œ±\n‚ä¢ (List.cons (Membership.mem (nhdsWithin a (Set.Ioi a)) s) (List.cons (Membership.mem (nhdsWithin a (Set.Ioc a b)) s) (List.cons (Membership.mem (nhdsWithin a (Set.Ioo a b)) s) (List.cons (Exists fun u => And (Membership.mem (Set.Ioc a b) u) (HasSubset.Subset (Set.Ioo a u) s)) (List.cons (Exists fun u => And (Membership.mem (Set.Ioi a) u) (HasSubset.Subset (Set.Ioo a u) s)) List.nil))))).TFAE","decl":"open List in\n/-- The following statements are equivalent:\n\n0. `s` is a neighborhood of `a` within `(a, +‚àû)`;\n1. `s` is a neighborhood of `a` within `(a, b]`;\n2. `s` is a neighborhood of `a` within `(a, b)`;\n3. `s` includes `(a, u)` for some `u ‚àà (a, b]`;\n4. `s` includes `(a, u)` for some `u > a`.\n-/\ntheorem TFAE_mem_nhdsGT {a b : Œ±} (hab : a < b) (s : Set Œ±) :\n    TFAE [s ‚àà ùìù[>] a,\n      s ‚àà ùìù[Ioc a b] a,\n      s ‚àà ùìù[Ioo a b] a,\n      ‚àÉ u ‚àà Ioc a b, Ioo a u ‚äÜ s,\n      ‚àÉ u ‚àà Ioi a, Ioo a u ‚äÜ s] := by\n  tfae_have 1 ‚Üî 2 := by\n    rw [nhdsWithin_Ioc_eq_nhdsGT hab]\n  tfae_have 1 ‚Üî 3 := by\n    rw [nhdsWithin_Ioo_eq_nhdsGT hab]\n  tfae_have 4 ‚Üí 5 := fun ‚ü®u, umem, hu‚ü© => ‚ü®u, umem.1, hu‚ü©\n  tfae_have 5 ‚Üí 1\n  | ‚ü®u, hau, hu‚ü© => mem_of_superset (Ioo_mem_nhdsGT hau) hu\n  tfae_have 1 ‚Üí 4\n  | h => by\n    rcases mem_nhdsWithin_iff_exists_mem_nhds_inter.1 h with ‚ü®v, va, hv‚ü©\n    rcases exists_Ico_subset_of_mem_nhds' va hab with ‚ü®u, au, hu‚ü©\n    exact ‚ü®u, au, fun x hx => hv ‚ü®hu ‚ü®le_of_lt hx.1, hx.2‚ü©, hx.1‚ü©‚ü©\n  tfae_finish\n\n"}
{"name":"TFAE_mem_nhdsWithin_Ioi","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na b : Œ±\nhab : LT.lt a b\ns : Set Œ±\n‚ä¢ (List.cons (Membership.mem (nhdsWithin a (Set.Ioi a)) s) (List.cons (Membership.mem (nhdsWithin a (Set.Ioc a b)) s) (List.cons (Membership.mem (nhdsWithin a (Set.Ioo a b)) s) (List.cons (Exists fun u => And (Membership.mem (Set.Ioc a b) u) (HasSubset.Subset (Set.Ioo a u) s)) (List.cons (Exists fun u => And (Membership.mem (Set.Ioi a) u) (HasSubset.Subset (Set.Ioo a u) s)) List.nil))))).TFAE","decl":"@[deprecated (since := \"2024-12-22\")]\nalias TFAE_mem_nhdsWithin_Ioi := TFAE_mem_nhdsGT\n\n"}
{"name":"mem_nhdsGT_iff_exists_mem_Ioc_Ioo_subset","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na u' : Œ±\ns : Set Œ±\nhu' : LT.lt a u'\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Ioi a)) s) (Exists fun u => And (Membership.mem (Set.Ioc a u') u) (HasSubset.Subset (Set.Ioo a u) s))","decl":"theorem mem_nhdsGT_iff_exists_mem_Ioc_Ioo_subset {a u' : Œ±} {s : Set Œ±} (hu' : a < u') :\n    s ‚àà ùìù[>] a ‚Üî ‚àÉ u ‚àà Ioc a u', Ioo a u ‚äÜ s :=\n  (TFAE_mem_nhdsGT hu' s).out 0 3\n\n"}
{"name":"mem_nhdsWithin_Ioi_iff_exists_mem_Ioc_Ioo_subset","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na u' : Œ±\ns : Set Œ±\nhu' : LT.lt a u'\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Ioi a)) s) (Exists fun u => And (Membership.mem (Set.Ioc a u') u) (HasSubset.Subset (Set.Ioo a u) s))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias mem_nhdsWithin_Ioi_iff_exists_mem_Ioc_Ioo_subset := mem_nhdsGT_iff_exists_mem_Ioc_Ioo_subset\n\n"}
{"name":"mem_nhdsGT_iff_exists_Ioo_subset'","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na u' : Œ±\ns : Set Œ±\nhu' : LT.lt a u'\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Ioi a)) s) (Exists fun u => And (Membership.mem (Set.Ioi a) u) (HasSubset.Subset (Set.Ioo a u) s))","decl":"/-- A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u)`\nwith `a < u < u'`, provided `a` is not a top element. -/\ntheorem mem_nhdsGT_iff_exists_Ioo_subset' {a u' : Œ±} {s : Set Œ±} (hu' : a < u') :\n    s ‚àà ùìù[>] a ‚Üî ‚àÉ u ‚àà Ioi a, Ioo a u ‚äÜ s :=\n  (TFAE_mem_nhdsGT hu' s).out 0 4\n\n"}
{"name":"mem_nhdsWithin_Ioi_iff_exists_Ioo_subset'","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na u' : Œ±\ns : Set Œ±\nhu' : LT.lt a u'\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Ioi a)) s) (Exists fun u => And (Membership.mem (Set.Ioi a) u) (HasSubset.Subset (Set.Ioo a u) s))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' := mem_nhdsGT_iff_exists_Ioo_subset'\n\n"}
{"name":"nhdsGT_basis_of_exists_gt","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\nh : Exists fun b => LT.lt a b\n‚ä¢ (nhdsWithin a (Set.Ioi a)).HasBasis (fun x => LT.lt a x) (Set.Ioo a)","decl":"theorem nhdsGT_basis_of_exists_gt {a : Œ±} (h : ‚àÉ b, a < b) : (ùìù[>] a).HasBasis (a < ¬∑) (Ioo a) :=\n  let ‚ü®_, h‚ü© := h\n  ‚ü®fun _ => mem_nhdsGT_iff_exists_Ioo_subset' h‚ü©\n\n"}
{"name":"nhdsWithin_Ioi_basis'","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\nh : Exists fun b => LT.lt a b\n‚ä¢ (nhdsWithin a (Set.Ioi a)).HasBasis (fun x => LT.lt a x) (Set.Ioo a)","decl":"@[deprecated (since := \"2024-12-22\")]\nalias nhdsWithin_Ioi_basis' := nhdsGT_basis_of_exists_gt\n\n"}
{"name":"nhdsGT_basis","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : NoMaxOrder Œ±\na : Œ±\n‚ä¢ (nhdsWithin a (Set.Ioi a)).HasBasis (fun x => LT.lt a x) (Set.Ioo a)","decl":"lemma nhdsGT_basis [NoMaxOrder Œ±] (a : Œ±) : (ùìù[>] a).HasBasis (a < ¬∑) (Ioo a) :=\n  nhdsGT_basis_of_exists_gt <| exists_gt a\n\n"}
{"name":"nhdsWithin_Ioi_basis","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : NoMaxOrder Œ±\na : Œ±\n‚ä¢ (nhdsWithin a (Set.Ioi a)).HasBasis (fun x => LT.lt a x) (Set.Ioo a)","decl":"@[deprecated (since := \"2024-12-22\")]\nalias nhdsWithin_Ioi_basis := nhdsGT_basis\n\n"}
{"name":"nhdsGT_eq_bot_iff","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\n‚ä¢ Iff (Eq (nhdsWithin a (Set.Ioi a)) Bot.bot) (Or (IsTop a) (Exists fun b => CovBy a b))","decl":"theorem nhdsGT_eq_bot_iff {a : Œ±} : ùìù[>] a = ‚ä• ‚Üî IsTop a ‚à® ‚àÉ b, a ‚ãñ b := by\n  by_cases ha : IsTop a\n  ¬∑ simp [ha, ha.isMax.Ioi_eq]\n  ¬∑ simp only [ha, false_or]\n    rw [isTop_iff_isMax, not_isMax_iff] at ha\n    simp only [(nhdsGT_basis_of_exists_gt ha).eq_bot_iff, covBy_iff_Ioo_eq]\n\n"}
{"name":"nhdsWithin_Ioi_eq_bot_iff","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\n‚ä¢ Iff (Eq (nhdsWithin a (Set.Ioi a)) Bot.bot) (Or (IsTop a) (Exists fun b => CovBy a b))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias nhdsWithin_Ioi_eq_bot_iff := nhdsGT_eq_bot_iff\n\n"}
{"name":"mem_nhdsGT_iff_exists_Ioo_subset","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : NoMaxOrder Œ±\na : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Ioi a)) s) (Exists fun u => And (Membership.mem (Set.Ioi a) u) (HasSubset.Subset (Set.Ioo a u) s))","decl":"/-- A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u)`\nwith `a < u`. -/\ntheorem mem_nhdsGT_iff_exists_Ioo_subset [NoMaxOrder Œ±] {a : Œ±} {s : Set Œ±} :\n    s ‚àà ùìù[>] a ‚Üî ‚àÉ u ‚àà Ioi a, Ioo a u ‚äÜ s :=\n  let ‚ü®_u', hu'‚ü© := exists_gt a\n  mem_nhdsGT_iff_exists_Ioo_subset' hu'\n\n"}
{"name":"mem_nhdsWithin_Ioi_iff_exists_Ioo_subset","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : NoMaxOrder Œ±\na : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Ioi a)) s) (Exists fun u => And (Membership.mem (Set.Ioi a) u) (HasSubset.Subset (Set.Ioo a u) s))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias mem_nhdsWithin_Ioi_iff_exists_Ioo_subset := mem_nhdsGT_iff_exists_Ioo_subset\n\n"}
{"name":"countable_setOf_isolated_right","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : SecondCountableTopology Œ±\n‚ä¢ (setOf fun x => Eq (nhdsWithin x (Set.Ioi x)) Bot.bot).Countable","decl":"/-- The set of points which are isolated on the right is countable when the space is\nsecond-countable. -/\ntheorem countable_setOf_isolated_right [SecondCountableTopology Œ±] :\n    { x : Œ± | ùìù[>] x = ‚ä• }.Countable := by\n  simp only [nhdsGT_eq_bot_iff, setOf_or]\n  exact (subsingleton_isTop Œ±).countable.union countable_setOf_covBy_right\n\n"}
{"name":"countable_setOf_isolated_left","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : SecondCountableTopology Œ±\n‚ä¢ (setOf fun x => Eq (nhdsWithin x (Set.Iio x)) Bot.bot).Countable","decl":"/-- The set of points which are isolated on the left is countable when the space is\nsecond-countable. -/\ntheorem countable_setOf_isolated_left [SecondCountableTopology Œ±] :\n    { x : Œ± | ùìù[<] x = ‚ä• }.Countable :=\n  countable_setOf_isolated_right (Œ± := Œ±·µí·µà)\n\n"}
{"name":"mem_nhdsGT_iff_exists_Ioc_subset","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : NoMaxOrder Œ±\ninst‚úù : DenselyOrdered Œ±\na : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Ioi a)) s) (Exists fun u => And (Membership.mem (Set.Ioi a) u) (HasSubset.Subset (Set.Ioc a u) s))","decl":"/-- A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u]`\nwith `a < u`. -/\ntheorem mem_nhdsGT_iff_exists_Ioc_subset [NoMaxOrder Œ±] [DenselyOrdered Œ±] {a : Œ±} {s : Set Œ±} :\n    s ‚àà ùìù[>] a ‚Üî ‚àÉ u ‚àà Ioi a, Ioc a u ‚äÜ s := by\n  rw [mem_nhdsGT_iff_exists_Ioo_subset]\n  constructor\n  ¬∑ rintro ‚ü®u, au, as‚ü©\n    rcases exists_between au with ‚ü®v, hv‚ü©\n    exact ‚ü®v, hv.1, fun x hx => as ‚ü®hx.1, lt_of_le_of_lt hx.2 hv.2‚ü©‚ü©\n  ¬∑ rintro ‚ü®u, au, as‚ü©\n    exact ‚ü®u, au, Subset.trans Ioo_subset_Ioc_self as‚ü©\n\n"}
{"name":"mem_nhdsWithin_Ioi_iff_exists_Ioc_subset","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : NoMaxOrder Œ±\ninst‚úù : DenselyOrdered Œ±\na : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Ioi a)) s) (Exists fun u => And (Membership.mem (Set.Ioi a) u) (HasSubset.Subset (Set.Ioc a u) s))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias mem_nhdsWithin_Ioi_iff_exists_Ioc_subset := mem_nhdsGT_iff_exists_Ioc_subset\n\n"}
{"name":"TFAE_mem_nhdsLT","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na b : Œ±\nh : LT.lt a b\ns : Set Œ±\n‚ä¢ (List.cons (Membership.mem (nhdsWithin b (Set.Iio b)) s) (List.cons (Membership.mem (nhdsWithin b (Set.Ico a b)) s) (List.cons (Membership.mem (nhdsWithin b (Set.Ioo a b)) s) (List.cons (Exists fun l => And (Membership.mem (Set.Ico a b) l) (HasSubset.Subset (Set.Ioo l b) s)) (List.cons (Exists fun l => And (Membership.mem (Set.Iio b) l) (HasSubset.Subset (Set.Ioo l b) s)) List.nil))))).TFAE","decl":"open List in\n/-- The following statements are equivalent:\n\n0. `s` is a neighborhood of `b` within `(-‚àû, b)`\n1. `s` is a neighborhood of `b` within `[a, b)`\n2. `s` is a neighborhood of `b` within `(a, b)`\n3. `s` includes `(l, b)` for some `l ‚àà [a, b)`\n4. `s` includes `(l, b)` for some `l < b` -/\ntheorem TFAE_mem_nhdsLT {a b : Œ±} (h : a < b) (s : Set Œ±) :\n    TFAE [s ‚àà ùìù[<] b,-- 0 : `s` is a neighborhood of `b` within `(-‚àû, b)`\n        s ‚àà ùìù[Ico a b] b,-- 1 : `s` is a neighborhood of `b` within `[a, b)`\n        s ‚àà ùìù[Ioo a b] b,-- 2 : `s` is a neighborhood of `b` within `(a, b)`\n        ‚àÉ l ‚àà Ico a b, Ioo l b ‚äÜ s,-- 3 : `s` includes `(l, b)` for some `l ‚àà [a, b)`\n        ‚àÉ l ‚àà Iio b, Ioo l b ‚äÜ s] := by-- 4 : `s` includes `(l, b)` for some `l < b`\n  simpa only [exists_prop, OrderDual.exists, dual_Ioi, dual_Ioc, dual_Ioo] using\n    TFAE_mem_nhdsGT h.dual (ofDual ‚Åª¬π' s)\n\n"}
{"name":"TFAE_mem_nhdsWithin_Iio","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na b : Œ±\nh : LT.lt a b\ns : Set Œ±\n‚ä¢ (List.cons (Membership.mem (nhdsWithin b (Set.Iio b)) s) (List.cons (Membership.mem (nhdsWithin b (Set.Ico a b)) s) (List.cons (Membership.mem (nhdsWithin b (Set.Ioo a b)) s) (List.cons (Exists fun l => And (Membership.mem (Set.Ico a b) l) (HasSubset.Subset (Set.Ioo l b) s)) (List.cons (Exists fun l => And (Membership.mem (Set.Iio b) l) (HasSubset.Subset (Set.Ioo l b) s)) List.nil))))).TFAE","decl":"@[deprecated (since := \"2024-12-22\")]\nalias TFAE_mem_nhdsWithin_Iio := TFAE_mem_nhdsLT\n\n"}
{"name":"mem_nhdsLT_iff_exists_mem_Ico_Ioo_subset","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na l' : Œ±\ns : Set Œ±\nhl' : LT.lt l' a\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Iio a)) s) (Exists fun l => And (Membership.mem (Set.Ico l' a) l) (HasSubset.Subset (Set.Ioo l a) s))","decl":"theorem mem_nhdsLT_iff_exists_mem_Ico_Ioo_subset {a l' : Œ±} {s : Set Œ±} (hl' : l' < a) :\n    s ‚àà ùìù[<] a ‚Üî ‚àÉ l ‚àà Ico l' a, Ioo l a ‚äÜ s :=\n  (TFAE_mem_nhdsLT hl' s).out 0 3\n\n"}
{"name":"mem_nhdsWithin_Iio_iff_exists_mem_Ico_Ioo_subset","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na l' : Œ±\ns : Set Œ±\nhl' : LT.lt l' a\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Iio a)) s) (Exists fun l => And (Membership.mem (Set.Ico l' a) l) (HasSubset.Subset (Set.Ioo l a) s))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias mem_nhdsWithin_Iio_iff_exists_mem_Ico_Ioo_subset := mem_nhdsLT_iff_exists_mem_Ico_Ioo_subset\n\n"}
{"name":"mem_nhdsLT_iff_exists_Ioo_subset'","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na l' : Œ±\ns : Set Œ±\nhl' : LT.lt l' a\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Iio a)) s) (Exists fun l => And (Membership.mem (Set.Iio a) l) (HasSubset.Subset (Set.Ioo l a) s))","decl":"/-- A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `(l, a)`\nwith `l < a`, provided `a` is not a bottom element. -/\ntheorem mem_nhdsLT_iff_exists_Ioo_subset' {a l' : Œ±} {s : Set Œ±} (hl' : l' < a) :\n    s ‚àà ùìù[<] a ‚Üî ‚àÉ l ‚àà Iio a, Ioo l a ‚äÜ s :=\n  (TFAE_mem_nhdsLT hl' s).out 0 4\n\n"}
{"name":"mem_nhdsWithin_Iio_iff_exists_Ioo_subset'","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na l' : Œ±\ns : Set Œ±\nhl' : LT.lt l' a\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Iio a)) s) (Exists fun l => And (Membership.mem (Set.Iio a) l) (HasSubset.Subset (Set.Ioo l a) s))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias mem_nhdsWithin_Iio_iff_exists_Ioo_subset' := mem_nhdsLT_iff_exists_Ioo_subset'\n\n"}
{"name":"mem_nhdsLT_iff_exists_Ioo_subset","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : NoMinOrder Œ±\na : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Iio a)) s) (Exists fun l => And (Membership.mem (Set.Iio a) l) (HasSubset.Subset (Set.Ioo l a) s))","decl":"/-- A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `(l, a)`\nwith `l < a`. -/\ntheorem mem_nhdsLT_iff_exists_Ioo_subset [NoMinOrder Œ±] {a : Œ±} {s : Set Œ±} :\n    s ‚àà ùìù[<] a ‚Üî ‚àÉ l ‚àà Iio a, Ioo l a ‚äÜ s :=\n  let ‚ü®_, h‚ü© := exists_lt a\n  mem_nhdsLT_iff_exists_Ioo_subset' h\n\n"}
{"name":"mem_nhdsWithin_Iio_iff_exists_Ioo_subset","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : NoMinOrder Œ±\na : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Iio a)) s) (Exists fun l => And (Membership.mem (Set.Iio a) l) (HasSubset.Subset (Set.Ioo l a) s))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias mem_nhdsWithin_Iio_iff_exists_Ioo_subset := mem_nhdsLT_iff_exists_Ioo_subset\n\n"}
{"name":"mem_nhdsLT_iff_exists_Ico_subset","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : NoMinOrder Œ±\ninst‚úù : DenselyOrdered Œ±\na : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Iio a)) s) (Exists fun l => And (Membership.mem (Set.Iio a) l) (HasSubset.Subset (Set.Ico l a) s))","decl":"/-- A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `[l, a)`\nwith `l < a`. -/\ntheorem mem_nhdsLT_iff_exists_Ico_subset [NoMinOrder Œ±] [DenselyOrdered Œ±] {a : Œ±} {s : Set Œ±} :\n    s ‚àà ùìù[<] a ‚Üî ‚àÉ l ‚àà Iio a, Ico l a ‚äÜ s := by\n  have : ofDual ‚Åª¬π' s ‚àà ùìù[>] toDual a ‚Üî _ := mem_nhdsGT_iff_exists_Ioc_subset\n  simpa only [OrderDual.exists, exists_prop, dual_Ioc] using this\n\n"}
{"name":"mem_nhdsWithin_Iio_iff_exists_Ico_subset","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : NoMinOrder Œ±\ninst‚úù : DenselyOrdered Œ±\na : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Iio a)) s) (Exists fun l => And (Membership.mem (Set.Iio a) l) (HasSubset.Subset (Set.Ico l a) s))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias mem_nhdsWithin_Iio_iff_exists_Ico_subset := mem_nhdsLT_iff_exists_Ico_subset\n\n"}
{"name":"nhdsLT_basis_of_exists_lt","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\nh : Exists fun b => LT.lt b a\n‚ä¢ (nhdsWithin a (Set.Iio a)).HasBasis (fun x => LT.lt x a) fun x => Set.Ioo x a","decl":"theorem nhdsLT_basis_of_exists_lt {a : Œ±} (h : ‚àÉ b, b < a) : (ùìù[<] a).HasBasis (¬∑ < a) (Ioo ¬∑ a) :=\n  let ‚ü®_, h‚ü© := h\n  ‚ü®fun _ => mem_nhdsLT_iff_exists_Ioo_subset' h‚ü©\n\n"}
{"name":"nhdsWithin_Iio_basis'","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\nh : Exists fun b => LT.lt b a\n‚ä¢ (nhdsWithin a (Set.Iio a)).HasBasis (fun x => LT.lt x a) fun x => Set.Ioo x a","decl":"@[deprecated (since := \"2024-12-22\")]\nalias nhdsWithin_Iio_basis' := nhdsLT_basis_of_exists_lt\n\n"}
{"name":"nhdsLT_basis","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : NoMinOrder Œ±\na : Œ±\n‚ä¢ (nhdsWithin a (Set.Iio a)).HasBasis (fun x => LT.lt x a) fun x => Set.Ioo x a","decl":"theorem nhdsLT_basis [NoMinOrder Œ±] (a : Œ±) : (ùìù[<] a).HasBasis (¬∑ < a) (Ioo ¬∑ a) :=\n  nhdsLT_basis_of_exists_lt <| exists_lt a\n\n"}
{"name":"nhdsWithin_Iio_basis","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : NoMinOrder Œ±\na : Œ±\n‚ä¢ (nhdsWithin a (Set.Iio a)).HasBasis (fun x => LT.lt x a) fun x => Set.Ioo x a","decl":"@[deprecated (since := \"2024-12-22\")]\nalias nhdsWithin_Iio_basis := nhdsLT_basis\n\n"}
{"name":"nhdsLT_eq_bot_iff","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\n‚ä¢ Iff (Eq (nhdsWithin a (Set.Iio a)) Bot.bot) (Or (IsBot a) (Exists fun b => CovBy b a))","decl":"theorem nhdsLT_eq_bot_iff {a : Œ±} : ùìù[<] a = ‚ä• ‚Üî IsBot a ‚à® ‚àÉ b, b ‚ãñ a := by\n  convert (config := { preTransparency := .default }) nhdsGT_eq_bot_iff (a := OrderDual.toDual a)\n    using 4\n  exact ofDual_covBy_ofDual_iff\n\n"}
{"name":"nhdsWithin_Iio_eq_bot_iff","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\n‚ä¢ Iff (Eq (nhdsWithin a (Set.Iio a)) Bot.bot) (Or (IsBot a) (Exists fun b => CovBy b a))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias nhdsWithin_Iio_eq_bot_iff := nhdsLT_eq_bot_iff\n\n"}
{"name":"TFAE_mem_nhdsGE","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na b : Œ±\nhab : LT.lt a b\ns : Set Œ±\n‚ä¢ (List.cons (Membership.mem (nhdsWithin a (Set.Ici a)) s) (List.cons (Membership.mem (nhdsWithin a (Set.Icc a b)) s) (List.cons (Membership.mem (nhdsWithin a (Set.Ico a b)) s) (List.cons (Exists fun u => And (Membership.mem (Set.Ioc a b) u) (HasSubset.Subset (Set.Ico a u) s)) (List.cons (Exists fun u => And (Membership.mem (Set.Ioi a) u) (HasSubset.Subset (Set.Ico a u) s)) List.nil))))).TFAE","decl":"open List in\n/-- The following statements are equivalent:\n\n0. `s` is a neighborhood of `a` within `[a, +‚àû)`;\n1. `s` is a neighborhood of `a` within `[a, b]`;\n2. `s` is a neighborhood of `a` within `[a, b)`;\n3. `s` includes `[a, u)` for some `u ‚àà (a, b]`;\n4. `s` includes `[a, u)` for some `u > a`.\n-/\ntheorem TFAE_mem_nhdsGE {a b : Œ±} (hab : a < b) (s : Set Œ±) :\n    TFAE [s ‚àà ùìù[‚â•] a,\n      s ‚àà ùìù[Icc a b] a,\n      s ‚àà ùìù[Ico a b] a,\n      ‚àÉ u ‚àà Ioc a b, Ico a u ‚äÜ s,\n      ‚àÉ u ‚àà Ioi a , Ico a u ‚äÜ s] := by\n  tfae_have 1 ‚Üî 2 := by\n    rw [nhdsWithin_Icc_eq_nhdsGE hab]\n  tfae_have 1 ‚Üî 3 := by\n    rw [nhdsWithin_Ico_eq_nhdsGE hab]\n  tfae_have 1 ‚Üî 5 := (nhdsGE_basis_of_exists_gt ‚ü®b, hab‚ü©).mem_iff\n  tfae_have 4 ‚Üí 5 := fun ‚ü®u, umem, hu‚ü© => ‚ü®u, umem.1, hu‚ü©\n  tfae_have 5 ‚Üí 4\n  | ‚ü®u, hua, hus‚ü© => ‚ü®min u b, ‚ü®lt_min hua hab, min_le_right _ _‚ü©,\n      (Ico_subset_Ico_right <| min_le_left _ _).trans hus‚ü©\n  tfae_finish\n\n"}
{"name":"TFAE_mem_nhdsWithin_Ici","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na b : Œ±\nhab : LT.lt a b\ns : Set Œ±\n‚ä¢ (List.cons (Membership.mem (nhdsWithin a (Set.Ici a)) s) (List.cons (Membership.mem (nhdsWithin a (Set.Icc a b)) s) (List.cons (Membership.mem (nhdsWithin a (Set.Ico a b)) s) (List.cons (Exists fun u => And (Membership.mem (Set.Ioc a b) u) (HasSubset.Subset (Set.Ico a u) s)) (List.cons (Exists fun u => And (Membership.mem (Set.Ioi a) u) (HasSubset.Subset (Set.Ico a u) s)) List.nil))))).TFAE","decl":"@[deprecated (since := \"2024-12-22\")]\nalias TFAE_mem_nhdsWithin_Ici := TFAE_mem_nhdsGE\n\n"}
{"name":"mem_nhdsGE_iff_exists_mem_Ioc_Ico_subset","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na u' : Œ±\ns : Set Œ±\nhu' : LT.lt a u'\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Ici a)) s) (Exists fun u => And (Membership.mem (Set.Ioc a u') u) (HasSubset.Subset (Set.Ico a u) s))","decl":"theorem mem_nhdsGE_iff_exists_mem_Ioc_Ico_subset {a u' : Œ±} {s : Set Œ±} (hu' : a < u') :\n    s ‚àà ùìù[‚â•] a ‚Üî ‚àÉ u ‚àà Ioc a u', Ico a u ‚äÜ s :=\n  (TFAE_mem_nhdsGE hu' s).out 0 3 (by norm_num) (by norm_num)\n\n"}
{"name":"mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na u' : Œ±\ns : Set Œ±\nhu' : LT.lt a u'\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Ici a)) s) (Exists fun u => And (Membership.mem (Set.Ioc a u') u) (HasSubset.Subset (Set.Ico a u) s))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset := mem_nhdsGE_iff_exists_mem_Ioc_Ico_subset\n\n"}
{"name":"mem_nhdsGE_iff_exists_Ico_subset'","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na u' : Œ±\ns : Set Œ±\nhu' : LT.lt a u'\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Ici a)) s) (Exists fun u => And (Membership.mem (Set.Ioi a) u) (HasSubset.Subset (Set.Ico a u) s))","decl":"/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u)`\nwith `a < u < u'`, provided `a` is not a top element. -/\ntheorem mem_nhdsGE_iff_exists_Ico_subset' {a u' : Œ±} {s : Set Œ±} (hu' : a < u') :\n    s ‚àà ùìù[‚â•] a ‚Üî ‚àÉ u ‚àà Ioi a, Ico a u ‚äÜ s :=\n  (TFAE_mem_nhdsGE hu' s).out 0 4 (by norm_num) (by norm_num)\n\n"}
{"name":"mem_nhdsWithin_Ici_iff_exists_Ico_subset'","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na u' : Œ±\ns : Set Œ±\nhu' : LT.lt a u'\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Ici a)) s) (Exists fun u => And (Membership.mem (Set.Ioi a) u) (HasSubset.Subset (Set.Ico a u) s))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias mem_nhdsWithin_Ici_iff_exists_Ico_subset' := mem_nhdsGE_iff_exists_Ico_subset'\n\n"}
{"name":"mem_nhdsGE_iff_exists_Ico_subset","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : NoMaxOrder Œ±\na : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Ici a)) s) (Exists fun u => And (Membership.mem (Set.Ioi a) u) (HasSubset.Subset (Set.Ico a u) s))","decl":"/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u)`\nwith `a < u`. -/\ntheorem mem_nhdsGE_iff_exists_Ico_subset [NoMaxOrder Œ±] {a : Œ±} {s : Set Œ±} :\n    s ‚àà ùìù[‚â•] a ‚Üî ‚àÉ u ‚àà Ioi a, Ico a u ‚äÜ s :=\n  let ‚ü®_, hu'‚ü© := exists_gt a\n  mem_nhdsGE_iff_exists_Ico_subset' hu'\n\n"}
{"name":"mem_nhdsWithin_Ici_iff_exists_Ico_subset","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : NoMaxOrder Œ±\na : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Ici a)) s) (Exists fun u => And (Membership.mem (Set.Ioi a) u) (HasSubset.Subset (Set.Ico a u) s))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias mem_nhdsWithin_Ici_iff_exists_Ico_subset := mem_nhdsGE_iff_exists_Ico_subset\n\n"}
{"name":"nhdsGE_basis_Ico","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : NoMaxOrder Œ±\na : Œ±\n‚ä¢ (nhdsWithin a (Set.Ici a)).HasBasis (fun u => LT.lt a u) (Set.Ico a)","decl":"theorem nhdsGE_basis_Ico [NoMaxOrder Œ±] (a : Œ±) : (ùìù[‚â•] a).HasBasis (fun u => a < u) (Ico a) :=\n  ‚ü®fun _ => mem_nhdsGE_iff_exists_Ico_subset‚ü©\n\n"}
{"name":"nhdsWithin_Ici_basis_Ico","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : NoMaxOrder Œ±\na : Œ±\n‚ä¢ (nhdsWithin a (Set.Ici a)).HasBasis (fun u => LT.lt a u) (Set.Ico a)","decl":"@[deprecated (since := \"2024-12-22\")]\nalias nhdsWithin_Ici_basis_Ico := nhdsGE_basis_Ico\n\n"}
{"name":"nhdsGE_basis_Icc","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : NoMaxOrder Œ±\ninst‚úù : DenselyOrdered Œ±\na : Œ±\n‚ä¢ (nhdsWithin a (Set.Ici a)).HasBasis (fun x => LT.lt a x) (Set.Icc a)","decl":"/-- The filter of right neighborhoods has a basis of closed intervals. -/\ntheorem nhdsGE_basis_Icc [NoMaxOrder Œ±] [DenselyOrdered Œ±] {a : Œ±} :\n    (ùìù[‚â•] a).HasBasis (a < ¬∑) (Icc a) :=\n  (nhdsGE_basis _).to_hasBasis\n    (fun _u hu ‚Ü¶ (exists_between hu).imp fun _v hv ‚Ü¶ hv.imp_right Icc_subset_Ico_right) fun u hu ‚Ü¶\n    ‚ü®u, hu, Ico_subset_Icc_self‚ü©\n\n"}
{"name":"nhdsWithin_Ici_basis_Icc","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : NoMaxOrder Œ±\ninst‚úù : DenselyOrdered Œ±\na : Œ±\n‚ä¢ (nhdsWithin a (Set.Ici a)).HasBasis (fun x => LT.lt a x) (Set.Icc a)","decl":"@[deprecated (since := \"2024-12-22\")]\nalias nhdsWithin_Ici_basis_Icc := nhdsGE_basis_Icc\n\n"}
{"name":"mem_nhdsGE_iff_exists_Icc_subset","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : NoMaxOrder Œ±\ninst‚úù : DenselyOrdered Œ±\na : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Ici a)) s) (Exists fun u => And (LT.lt a u) (HasSubset.Subset (Set.Icc a u) s))","decl":"/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u]`\nwith `a < u`. -/\ntheorem mem_nhdsGE_iff_exists_Icc_subset [NoMaxOrder Œ±] [DenselyOrdered Œ±] {a : Œ±} {s : Set Œ±} :\n    s ‚àà ùìù[‚â•] a ‚Üî ‚àÉ u, a < u ‚àß Icc a u ‚äÜ s :=\n  nhdsGE_basis_Icc.mem_iff\n\n"}
{"name":"mem_nhdsWithin_Ici_iff_exists_Icc_subset","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : NoMaxOrder Œ±\ninst‚úù : DenselyOrdered Œ±\na : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Ici a)) s) (Exists fun u => And (LT.lt a u) (HasSubset.Subset (Set.Icc a u) s))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias mem_nhdsWithin_Ici_iff_exists_Icc_subset := mem_nhdsGE_iff_exists_Icc_subset\n\n"}
{"name":"TFAE_mem_nhdsLE","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na b : Œ±\nh : LT.lt a b\ns : Set Œ±\n‚ä¢ (List.cons (Membership.mem (nhdsWithin b (Set.Iic b)) s) (List.cons (Membership.mem (nhdsWithin b (Set.Icc a b)) s) (List.cons (Membership.mem (nhdsWithin b (Set.Ioc a b)) s) (List.cons (Exists fun l => And (Membership.mem (Set.Ico a b) l) (HasSubset.Subset (Set.Ioc l b) s)) (List.cons (Exists fun l => And (Membership.mem (Set.Iio b) l) (HasSubset.Subset (Set.Ioc l b) s)) List.nil))))).TFAE","decl":"open List in\n/-- The following statements are equivalent:\n\n0. `s` is a neighborhood of `b` within `(-‚àû, b]`\n1. `s` is a neighborhood of `b` within `[a, b]`\n2. `s` is a neighborhood of `b` within `(a, b]`\n3. `s` includes `(l, b]` for some `l ‚àà [a, b)`\n4. `s` includes `(l, b]` for some `l < b` -/\ntheorem TFAE_mem_nhdsLE {a b : Œ±} (h : a < b) (s : Set Œ±) :\n    TFAE [s ‚àà ùìù[‚â§] b,-- 0 : `s` is a neighborhood of `b` within `(-‚àû, b]`\n      s ‚àà ùìù[Icc a b] b,-- 1 : `s` is a neighborhood of `b` within `[a, b]`\n      s ‚àà ùìù[Ioc a b] b,-- 2 : `s` is a neighborhood of `b` within `(a, b]`\n      ‚àÉ l ‚àà Ico a b, Ioc l b ‚äÜ s,-- 3 : `s` includes `(l, b]` for some `l ‚àà [a, b)`\n      ‚àÉ l ‚àà Iio b, Ioc l b ‚äÜ s] := by-- 4 : `s` includes `(l, b]` for some `l < b`\n  simpa only [exists_prop, OrderDual.exists, dual_Ici, dual_Ioc, dual_Icc, dual_Ico] using\n    TFAE_mem_nhdsGE h.dual (ofDual ‚Åª¬π' s)\n\n"}
{"name":"TFAE_mem_nhdsWithin_Iic","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na b : Œ±\nh : LT.lt a b\ns : Set Œ±\n‚ä¢ (List.cons (Membership.mem (nhdsWithin b (Set.Iic b)) s) (List.cons (Membership.mem (nhdsWithin b (Set.Icc a b)) s) (List.cons (Membership.mem (nhdsWithin b (Set.Ioc a b)) s) (List.cons (Exists fun l => And (Membership.mem (Set.Ico a b) l) (HasSubset.Subset (Set.Ioc l b) s)) (List.cons (Exists fun l => And (Membership.mem (Set.Iio b) l) (HasSubset.Subset (Set.Ioc l b) s)) List.nil))))).TFAE","decl":"@[deprecated (since := \"2024-12-22\")]\nalias TFAE_mem_nhdsWithin_Iic := TFAE_mem_nhdsLE\n\n"}
{"name":"mem_nhdsLE_iff_exists_mem_Ico_Ioc_subset","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na l' : Œ±\ns : Set Œ±\nhl' : LT.lt l' a\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Iic a)) s) (Exists fun l => And (Membership.mem (Set.Ico l' a) l) (HasSubset.Subset (Set.Ioc l a) s))","decl":"theorem mem_nhdsLE_iff_exists_mem_Ico_Ioc_subset {a l' : Œ±} {s : Set Œ±} (hl' : l' < a) :\n    s ‚àà ùìù[‚â§] a ‚Üî ‚àÉ l ‚àà Ico l' a, Ioc l a ‚äÜ s :=\n  (TFAE_mem_nhdsLE hl' s).out 0 3 (by norm_num) (by norm_num)\n\n"}
{"name":"mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na l' : Œ±\ns : Set Œ±\nhl' : LT.lt l' a\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Iic a)) s) (Exists fun l => And (Membership.mem (Set.Ico l' a) l) (HasSubset.Subset (Set.Ioc l a) s))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset := mem_nhdsLE_iff_exists_mem_Ico_Ioc_subset\n\n"}
{"name":"mem_nhdsLE_iff_exists_Ioc_subset'","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na l' : Œ±\ns : Set Œ±\nhl' : LT.lt l' a\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Iic a)) s) (Exists fun l => And (Membership.mem (Set.Iio a) l) (HasSubset.Subset (Set.Ioc l a) s))","decl":"/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `(l, a]`\nwith `l < a`, provided `a` is not a bottom element. -/\ntheorem mem_nhdsLE_iff_exists_Ioc_subset' {a l' : Œ±} {s : Set Œ±} (hl' : l' < a) :\n    s ‚àà ùìù[‚â§] a ‚Üî ‚àÉ l ‚àà Iio a, Ioc l a ‚äÜ s :=\n  (TFAE_mem_nhdsLE hl' s).out 0 4 (by norm_num) (by norm_num)\n\n"}
{"name":"mem_nhdsWithin_Iic_iff_exists_Ioc_subset'","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na l' : Œ±\ns : Set Œ±\nhl' : LT.lt l' a\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Iic a)) s) (Exists fun l => And (Membership.mem (Set.Iio a) l) (HasSubset.Subset (Set.Ioc l a) s))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias mem_nhdsWithin_Iic_iff_exists_Ioc_subset' := mem_nhdsLE_iff_exists_Ioc_subset'\n\n"}
{"name":"mem_nhdsLE_iff_exists_Ioc_subset","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : NoMinOrder Œ±\na : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Iic a)) s) (Exists fun l => And (Membership.mem (Set.Iio a) l) (HasSubset.Subset (Set.Ioc l a) s))","decl":"/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `(l, a]`\nwith `l < a`. -/\ntheorem mem_nhdsLE_iff_exists_Ioc_subset [NoMinOrder Œ±] {a : Œ±} {s : Set Œ±} :\n    s ‚àà ùìù[‚â§] a ‚Üî ‚àÉ l ‚àà Iio a, Ioc l a ‚äÜ s :=\n  let ‚ü®_, hl'‚ü© := exists_lt a\n  mem_nhdsLE_iff_exists_Ioc_subset' hl'\n\n"}
{"name":"mem_nhdsWithin_Iic_iff_exists_Ioc_subset","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : NoMinOrder Œ±\na : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Iic a)) s) (Exists fun l => And (Membership.mem (Set.Iio a) l) (HasSubset.Subset (Set.Ioc l a) s))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias mem_nhdsWithin_Iic_iff_exists_Ioc_subset := mem_nhdsLE_iff_exists_Ioc_subset\n\n"}
{"name":"mem_nhdsLE_iff_exists_Icc_subset","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : NoMinOrder Œ±\ninst‚úù : DenselyOrdered Œ±\na : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Iic a)) s) (Exists fun l => And (LT.lt l a) (HasSubset.Subset (Set.Icc l a) s))","decl":"/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `[l, a]`\nwith `l < a`. -/\ntheorem mem_nhdsLE_iff_exists_Icc_subset [NoMinOrder Œ±] [DenselyOrdered Œ±] {a : Œ±}\n    {s : Set Œ±} : s ‚àà ùìù[‚â§] a ‚Üî ‚àÉ l, l < a ‚àß Icc l a ‚äÜ s :=\n  calc s ‚àà ùìù[‚â§] a ‚Üî ofDual ‚Åª¬π' s ‚àà ùìù[‚â•] (toDual a) := Iff.rfl\n  _ ‚Üî ‚àÉ u : Œ±, toDual a < toDual u ‚àß Icc (toDual a) (toDual u) ‚äÜ ofDual ‚Åª¬π' s :=\n    mem_nhdsGE_iff_exists_Icc_subset\n  _ ‚Üî ‚àÉ l, l < a ‚àß Icc l a ‚äÜ s := by simp only [dual_Icc]; rfl\n\n"}
{"name":"mem_nhdsWithin_Iic_iff_exists_Icc_subset","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : NoMinOrder Œ±\ninst‚úù : DenselyOrdered Œ±\na : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (nhdsWithin a (Set.Iic a)) s) (Exists fun l => And (LT.lt l a) (HasSubset.Subset (Set.Icc l a) s))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias mem_nhdsWithin_Iic_iff_exists_Icc_subset := mem_nhdsLE_iff_exists_Icc_subset\n\n"}
{"name":"nhdsLE_basis_Icc","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : NoMinOrder Œ±\ninst‚úù : DenselyOrdered Œ±\na : Œ±\n‚ä¢ (nhdsWithin a (Set.Iic a)).HasBasis (fun x => LT.lt x a) fun x => Set.Icc x a","decl":"/-- The filter of left neighborhoods has a basis of closed intervals. -/\ntheorem nhdsLE_basis_Icc [NoMinOrder Œ±] [DenselyOrdered Œ±] {a : Œ±} :\n    (ùìù[‚â§] a).HasBasis (¬∑ < a) (Icc ¬∑ a) :=\n  ‚ü®fun _ ‚Ü¶ mem_nhdsLE_iff_exists_Icc_subset‚ü©\n\n"}
{"name":"nhdsWithin_Iic_basis_Icc","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : NoMinOrder Œ±\ninst‚úù : DenselyOrdered Œ±\na : Œ±\n‚ä¢ (nhdsWithin a (Set.Iic a)).HasBasis (fun x => LT.lt x a) fun x => Set.Icc x a","decl":"@[deprecated (since := \"2024-12-22\")]\nalias nhdsWithin_Iic_basis_Icc := nhdsLE_basis_Icc\n\n"}
{"name":"nhds_eq_iInf_abs_sub","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrderedAddCommGroup Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\n‚ä¢ Eq (nhds a) (iInf fun r => iInf fun h => Filter.principal (setOf fun b => LT.lt (abs (HSub.hSub a b)) r))","decl":"theorem nhds_eq_iInf_abs_sub (a : Œ±) : ùìù a = ‚®Ö r > 0, ùìü { b | |a - b| < r } := by\n  simp only [nhds_eq_order, abs_lt, setOf_and, ‚Üê inf_principal, iInf_inf_eq]\n  refine (congr_arg‚ÇÇ _ ?_ ?_).trans (inf_comm ..)\n  ¬∑ refine (Equiv.subLeft a).iInf_congr fun x => ?_; simp [Ioi]\n  ¬∑ refine (Equiv.subRight a).iInf_congr fun x => ?_; simp [Iio]\n\n"}
{"name":"orderTopology_of_nhds_abs","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_4\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : LinearOrderedAddCommGroup Œ±\nh_nhds : ‚àÄ (a : Œ±), Eq (nhds a) (iInf fun r => iInf fun h => Filter.principal (setOf fun b => LT.lt (abs (HSub.hSub a b)) r))\n‚ä¢ OrderTopology Œ±","decl":"theorem orderTopology_of_nhds_abs {Œ± : Type*} [TopologicalSpace Œ±] [LinearOrderedAddCommGroup Œ±]\n    (h_nhds : ‚àÄ a : Œ±, ùìù a = ‚®Ö r > 0, ùìü { b | |a - b| < r }) : OrderTopology Œ± := by\n  refine ‚ü®TopologicalSpace.ext_nhds fun a => ?_‚ü©\n  rw [h_nhds]\n  letI := Preorder.topology Œ±; letI : OrderTopology Œ± := ‚ü®rfl‚ü©\n  exact (nhds_eq_iInf_abs_sub a).symm\n\n"}
{"name":"LinearOrderedAddCommGroup.tendsto_nhds","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrderedAddCommGroup Œ±\ninst‚úù : OrderTopology Œ±\nf : Œ≤ ‚Üí Œ±\nx : Filter Œ≤\na : Œ±\n‚ä¢ Iff (Filter.Tendsto f x (nhds a)) (‚àÄ (Œµ : Œ±), GT.gt Œµ 0 ‚Üí Filter.Eventually (fun b => LT.lt (abs (HSub.hSub (f b) a)) Œµ) x)","decl":"theorem LinearOrderedAddCommGroup.tendsto_nhds {x : Filter Œ≤} {a : Œ±} :\n    Tendsto f x (ùìù a) ‚Üî ‚àÄ Œµ > (0 : Œ±), ‚àÄ·∂† b in x, |f b - a| < Œµ := by\n  simp [nhds_eq_iInf_abs_sub, abs_sub_comm a]\n\n"}
{"name":"eventually_abs_sub_lt","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrderedAddCommGroup Œ±\ninst‚úù : OrderTopology Œ±\na Œµ : Œ±\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Filter.Eventually (fun x => LT.lt (abs (HSub.hSub x a)) Œµ) (nhds a)","decl":"theorem eventually_abs_sub_lt (a : Œ±) {Œµ : Œ±} (hŒµ : 0 < Œµ) : ‚àÄ·∂† x in ùìù a, |x - a| < Œµ :=\n  (nhds_eq_iInf_abs_sub a).symm ‚ñ∏\n    mem_iInf_of_mem Œµ (mem_iInf_of_mem hŒµ <| by simp only [abs_sub_comm, mem_principal_self])\n\n"}
{"name":"Filter.Tendsto.add_atTop","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrderedAddCommGroup Œ±\ninst‚úù : OrderTopology Œ±\nl : Filter Œ≤\nf g : Œ≤ ‚Üí Œ±\nC : Œ±\nhf : Filter.Tendsto f l (nhds C)\nhg : Filter.Tendsto g l Filter.atTop\n‚ä¢ Filter.Tendsto (fun x => HAdd.hAdd (f x) (g x)) l Filter.atTop","decl":"/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to `C`\nand `g` tends to `atTop` then `f + g` tends to `atTop`. -/\ntheorem Filter.Tendsto.add_atTop {C : Œ±} (hf : Tendsto f l (ùìù C)) (hg : Tendsto g l atTop) :\n    Tendsto (fun x => f x + g x) l atTop := by\n  nontriviality Œ±\n  obtain ‚ü®C', hC'‚ü© : ‚àÉ C', C' < C := exists_lt C\n  refine tendsto_atTop_add_left_of_le' _ C' ?_ hg\n  exact (hf.eventually (lt_mem_nhds hC')).mono fun x => le_of_lt\n\n"}
{"name":"Filter.Tendsto.add_atBot","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrderedAddCommGroup Œ±\ninst‚úù : OrderTopology Œ±\nl : Filter Œ≤\nf g : Œ≤ ‚Üí Œ±\nC : Œ±\nhf : Filter.Tendsto f l (nhds C)\nhg : Filter.Tendsto g l Filter.atBot\n‚ä¢ Filter.Tendsto (fun x => HAdd.hAdd (f x) (g x)) l Filter.atBot","decl":"/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to `C`\nand `g` tends to `atBot` then `f + g` tends to `atBot`. -/\ntheorem Filter.Tendsto.add_atBot {C : Œ±} (hf : Tendsto f l (ùìù C)) (hg : Tendsto g l atBot) :\n    Tendsto (fun x => f x + g x) l atBot :=\n  Filter.Tendsto.add_atTop (Œ± := Œ±·µí·µà) hf hg\n\n"}
{"name":"Filter.Tendsto.atTop_add","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrderedAddCommGroup Œ±\ninst‚úù : OrderTopology Œ±\nl : Filter Œ≤\nf g : Œ≤ ‚Üí Œ±\nC : Œ±\nhf : Filter.Tendsto f l Filter.atTop\nhg : Filter.Tendsto g l (nhds C)\n‚ä¢ Filter.Tendsto (fun x => HAdd.hAdd (f x) (g x)) l Filter.atTop","decl":"/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to\n`atTop` and `g` tends to `C` then `f + g` tends to `atTop`. -/\ntheorem Filter.Tendsto.atTop_add {C : Œ±} (hf : Tendsto f l atTop) (hg : Tendsto g l (ùìù C)) :\n    Tendsto (fun x => f x + g x) l atTop := by\n  conv in _ + _ => rw [add_comm]\n  exact hg.add_atTop hf\n\n"}
{"name":"Filter.Tendsto.atBot_add","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrderedAddCommGroup Œ±\ninst‚úù : OrderTopology Œ±\nl : Filter Œ≤\nf g : Œ≤ ‚Üí Œ±\nC : Œ±\nhf : Filter.Tendsto f l Filter.atBot\nhg : Filter.Tendsto g l (nhds C)\n‚ä¢ Filter.Tendsto (fun x => HAdd.hAdd (f x) (g x)) l Filter.atBot","decl":"/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to\n`atBot` and `g` tends to `C` then `f + g` tends to `atBot`. -/\ntheorem Filter.Tendsto.atBot_add {C : Œ±} (hf : Tendsto f l atBot) (hg : Tendsto g l (ùìù C)) :\n    Tendsto (fun x => f x + g x) l atBot := by\n  conv in _ + _ => rw [add_comm]\n  exact hg.add_atBot hf\n\n"}
{"name":"nhds_basis_abs_sub_lt","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrderedAddCommGroup Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : NoMaxOrder Œ±\na : Œ±\n‚ä¢ (nhds a).HasBasis (fun Œµ => LT.lt 0 Œµ) fun Œµ => setOf fun b => LT.lt (abs (HSub.hSub b a)) Œµ","decl":"theorem nhds_basis_abs_sub_lt [NoMaxOrder Œ±] (a : Œ±) :\n    (ùìù a).HasBasis (fun Œµ : Œ± => (0 : Œ±) < Œµ) fun Œµ => { b | |b - a| < Œµ } := by\n  simp only [nhds_eq_iInf_abs_sub, abs_sub_comm (a := a)]\n  refine hasBasis_biInf_principal' (fun x hx y hy => ?_) (exists_gt _)\n  exact ‚ü®min x y, lt_min hx hy, fun _ hz => hz.trans_le (min_le_left _ _),\n    fun _ hz => hz.trans_le (min_le_right _ _)‚ü©\n\n"}
{"name":"nhds_basis_Ioo_pos","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrderedAddCommGroup Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : NoMaxOrder Œ±\na : Œ±\n‚ä¢ (nhds a).HasBasis (fun Œµ => LT.lt 0 Œµ) fun Œµ => Set.Ioo (HSub.hSub a Œµ) (HAdd.hAdd a Œµ)","decl":"theorem nhds_basis_Ioo_pos [NoMaxOrder Œ±] (a : Œ±) :\n    (ùìù a).HasBasis (fun Œµ : Œ± => (0 : Œ±) < Œµ) fun Œµ => Ioo (a - Œµ) (a + Œµ) := by\n  convert nhds_basis_abs_sub_lt a\n  simp only [Ioo, abs_lt, ‚Üê sub_lt_iff_lt_add, neg_lt_sub_iff_lt_add, sub_lt_comm]\n\n"}
{"name":"nhds_basis_Icc_pos","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrderedAddCommGroup Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : NoMaxOrder Œ±\ninst‚úù : DenselyOrdered Œ±\na : Œ±\n‚ä¢ (nhds a).HasBasis (fun x => LT.lt 0 x) fun Œµ => Set.Icc (HSub.hSub a Œµ) (HAdd.hAdd a Œµ)","decl":"theorem nhds_basis_Icc_pos [NoMaxOrder Œ±] [DenselyOrdered Œ±] (a : Œ±) :\n    (ùìù a).HasBasis ((0 : Œ±) < ¬∑) fun Œµ ‚Ü¶ Icc (a - Œµ) (a + Œµ) :=\n  (nhds_basis_Ioo_pos a).to_hasBasis\n    (fun _Œµ Œµ‚ÇÄ ‚Ü¶ let ‚ü®Œ¥, Œ¥‚ÇÄ, Œ¥Œµ‚ü© := exists_between Œµ‚ÇÄ\n      ‚ü®Œ¥, Œ¥‚ÇÄ, Icc_subset_Ioo (sub_lt_sub_left Œ¥Œµ _) (add_lt_add_left Œ¥Œµ _)‚ü©)\n    (fun Œµ Œµ‚ÇÄ ‚Ü¶ ‚ü®Œµ, Œµ‚ÇÄ, Ioo_subset_Icc_self‚ü©)\n\n"}
{"name":"nhds_basis_zero_abs_sub_lt","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrderedAddCommGroup Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : NoMaxOrder Œ±\n‚ä¢ (nhds 0).HasBasis (fun Œµ => LT.lt 0 Œµ) fun Œµ => setOf fun b => LT.lt (abs b) Œµ","decl":"theorem nhds_basis_zero_abs_sub_lt [NoMaxOrder Œ±] :\n    (ùìù (0 : Œ±)).HasBasis (fun Œµ : Œ± => (0 : Œ±) < Œµ) fun Œµ => { b | |b| < Œµ } := by\n  simpa using nhds_basis_abs_sub_lt (0 : Œ±)\n\n"}
{"name":"nhds_basis_Ioo_pos_of_pos","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrderedAddCommGroup Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : NoMaxOrder Œ±\na : Œ±\nha : LT.lt 0 a\n‚ä¢ (nhds a).HasBasis (fun Œµ => And (LT.lt 0 Œµ) (LE.le Œµ a)) fun Œµ => Set.Ioo (HSub.hSub a Œµ) (HAdd.hAdd a Œµ)","decl":"/-- If `a` is positive we can form a basis from only nonnegative `Set.Ioo` intervals -/\ntheorem nhds_basis_Ioo_pos_of_pos [NoMaxOrder Œ±] {a : Œ±} (ha : 0 < a) :\n    (ùìù a).HasBasis (fun Œµ : Œ± => (0 : Œ±) < Œµ ‚àß Œµ ‚â§ a) fun Œµ => Ioo (a - Œµ) (a + Œµ) :=\n  (nhds_basis_Ioo_pos a).restrict fun Œµ hŒµ => ‚ü®min a Œµ, lt_min ha hŒµ, min_le_left _ _,\n    Ioo_subset_Ioo (sub_le_sub_left (min_le_right _ _) _) (add_le_add_left (min_le_right _ _) _)‚ü©\n\n"}
{"name":"Set.OrdConnected.mem_nhdsGE","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : ClosedIciTopology Œ±\nS : Set Œ±\nx y : Œ±\nhS : S.OrdConnected\nhx : Membership.mem S x\nhy : Membership.mem S y\nhxy : LT.lt x y\n‚ä¢ Membership.mem (nhdsWithin x (Set.Ici x)) S","decl":"/-- If `S` is order-connected and contains two points `x < y`,\nthen `S` is a right neighbourhood of `x`. -/\nlemma mem_nhdsGE (hS : OrdConnected S) (hx : x ‚àà S) (hy : y ‚àà S) (hxy : x < y) : S ‚àà ùìù[‚â•] x :=\n  mem_of_superset (Icc_mem_nhdsGE hxy) <| hS.out hx hy\n\n"}
{"name":"Set.OrdConnected.mem_nhdsWithin_Ici","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : ClosedIciTopology Œ±\nS : Set Œ±\nx y : Œ±\nhS : S.OrdConnected\nhx : Membership.mem S x\nhy : Membership.mem S y\nhxy : LT.lt x y\n‚ä¢ Membership.mem (nhdsWithin x (Set.Ici x)) S","decl":"@[deprecated (since := \"2024-12-22\")] alias mem_nhdsWithin_Ici := mem_nhdsGE\n\n"}
{"name":"Set.OrdConnected.mem_nhdsGT","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : ClosedIciTopology Œ±\nS : Set Œ±\nx y : Œ±\nhS : S.OrdConnected\nhx : Membership.mem S x\nhy : Membership.mem S y\nhxy : LT.lt x y\n‚ä¢ Membership.mem (nhdsWithin x (Set.Ioi x)) S","decl":"/-- If `S` is order-connected and contains two points `x < y`,\nthen `S` is a punctured right neighbourhood of `x`. -/\nlemma mem_nhdsGT (hS : OrdConnected S) (hx : x ‚àà S) (hy : y ‚àà S) (hxy : x < y) : S ‚àà ùìù[>] x :=\n  nhdsWithin_mono _ Ioi_subset_Ici_self <| hS.mem_nhdsGE hx hy hxy\n\n"}
{"name":"Set.OrdConnected.mem_nhdsWithin_Ioi","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : ClosedIciTopology Œ±\nS : Set Œ±\nx y : Œ±\nhS : S.OrdConnected\nhx : Membership.mem S x\nhy : Membership.mem S y\nhxy : LT.lt x y\n‚ä¢ Membership.mem (nhdsWithin x (Set.Ioi x)) S","decl":"@[deprecated (since := \"2024-12-22\")] alias mem_nhdsWithin_Ioi := mem_nhdsGT\n\n"}
{"name":"Set.OrdConnected.mem_nhdsLE","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : ClosedIicTopology Œ±\nS : Set Œ±\nx y : Œ±\nhS : S.OrdConnected\nhx : Membership.mem S x\nhy : Membership.mem S y\nhxy : LT.lt x y\n‚ä¢ Membership.mem (nhdsWithin y (Set.Iic y)) S","decl":"/-- If `S` is order-connected and contains two points `x < y`, then `S` is a left neighbourhood\nof `y`. -/\nlemma mem_nhdsLE (hS : OrdConnected S) (hx : x ‚àà S) (hy : y ‚àà S) (hxy : x < y) : S ‚àà ùìù[‚â§] y :=\n  hS.dual.mem_nhdsGE hy hx hxy\n\n"}
{"name":"Set.OrdConnected.mem_nhdsWithin_Iic","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : ClosedIicTopology Œ±\nS : Set Œ±\nx y : Œ±\nhS : S.OrdConnected\nhx : Membership.mem S x\nhy : Membership.mem S y\nhxy : LT.lt x y\n‚ä¢ Membership.mem (nhdsWithin y (Set.Iic y)) S","decl":"@[deprecated (since := \"2024-12-22\")] alias mem_nhdsWithin_Iic := mem_nhdsLE\n\n"}
{"name":"Set.OrdConnected.mem_nhdsLT","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : ClosedIicTopology Œ±\nS : Set Œ±\nx y : Œ±\nhS : S.OrdConnected\nhx : Membership.mem S x\nhy : Membership.mem S y\nhxy : LT.lt x y\n‚ä¢ Membership.mem (nhdsWithin y (Set.Iio y)) S","decl":"/-- If `S` is order-connected and contains two points `x < y`, then `S` is a punctured left\nneighbourhood of `y`. -/\nlemma mem_nhdsLT (hS : OrdConnected S) (hx : x ‚àà S) (hy : y ‚àà S) (hxy : x < y) : S ‚àà ùìù[<] y :=\n  hS.dual.mem_nhdsGT hy hx hxy\n\n"}
{"name":"Set.OrdConnected.mem_nhdsWithin_Iio","module":"Mathlib.Topology.Order.LeftRightNhds","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : ClosedIicTopology Œ±\nS : Set Œ±\nx y : Œ±\nhS : S.OrdConnected\nhx : Membership.mem S x\nhy : Membership.mem S y\nhxy : LT.lt x y\n‚ä¢ Membership.mem (nhdsWithin y (Set.Iio y)) S","decl":"@[deprecated (since := \"2024-12-22\")] alias mem_nhdsWithin_Iio := mem_nhdsLT\n\n"}
