{"name":"minpolyDiv_spec","module":"Mathlib.FieldTheory.Minpoly.MinpolyDiv","initialProofState":"R : Type u_2\nS : Type u_1\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\n⊢ Eq (HMul.hMul (minpolyDiv R x) (HSub.hSub Polynomial.X (Polynomial.C x))) (Polynomial.map (algebraMap R S) (minpoly R x))","decl":"lemma minpolyDiv_spec :\n    minpolyDiv R x * (X - C x) = (minpoly R x).map (algebraMap R S) := by\n  delta minpolyDiv\n  rw [mul_comm, mul_divByMonic_eq_iff_isRoot, IsRoot, eval_map, ← aeval_def, minpoly.aeval]\n\n"}
{"name":"coeff_minpolyDiv","module":"Mathlib.FieldTheory.Minpoly.MinpolyDiv","initialProofState":"R : Type u_2\nS : Type u_1\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\ni : Nat\n⊢ Eq ((minpolyDiv R x).coeff i) (HAdd.hAdd ((algebraMap R S) ((minpoly R x).coeff (HAdd.hAdd i 1))) (HMul.hMul ((minpolyDiv R x).coeff (HAdd.hAdd i 1)) x))","decl":"lemma coeff_minpolyDiv (i) : coeff (minpolyDiv R x) i =\n    algebraMap R S (coeff (minpoly R x) (i + 1)) + coeff (minpolyDiv R x) (i + 1) * x := by\n  rw [← coeff_map, ← minpolyDiv_spec R x]; simp [mul_sub]\n\n"}
{"name":"minpolyDiv_eq_zero","module":"Mathlib.FieldTheory.Minpoly.MinpolyDiv","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\nhx : Not (IsIntegral R x)\n⊢ Eq (minpolyDiv R x) 0","decl":"lemma minpolyDiv_eq_zero (hx : ¬IsIntegral R x) : minpolyDiv R x = 0 := by\n  delta minpolyDiv minpoly\n  rw [dif_neg hx, Polynomial.map_zero, zero_divByMonic]\n\n"}
{"name":"eval_minpolyDiv_self","module":"Mathlib.FieldTheory.Minpoly.MinpolyDiv","initialProofState":"R : Type u_2\nS : Type u_1\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\n⊢ Eq (Polynomial.eval x (minpolyDiv R x)) ((Polynomial.aeval x) (Polynomial.derivative (minpoly R x)))","decl":"lemma eval_minpolyDiv_self : (minpolyDiv R x).eval x = aeval x (derivative <| minpoly R x) := by\n  rw [aeval_def, ← eval_map, ← derivative_map, ← minpolyDiv_spec R x]; simp\n\n"}
{"name":"minpolyDiv_eval_eq_zero_of_ne_of_aeval_eq_zero","module":"Mathlib.FieldTheory.Minpoly.MinpolyDiv","initialProofState":"R : Type u_2\nS : Type u_1\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nx : S\ninst✝ : IsDomain S\ny : S\nhxy : Ne y x\nhy : Eq ((Polynomial.aeval y) (minpoly R x)) 0\n⊢ Eq (Polynomial.eval y (minpolyDiv R x)) 0","decl":"lemma minpolyDiv_eval_eq_zero_of_ne_of_aeval_eq_zero [IsDomain S]\n    {y} (hxy : y ≠ x) (hy : aeval y (minpoly R x) = 0) : (minpolyDiv R x).eval y = 0 := by\n  rw [aeval_def, ← eval_map, ← minpolyDiv_spec R x] at hy\n  simp only [eval_mul, eval_sub, eval_X, eval_C, mul_eq_zero] at hy\n  exact hy.resolve_right (by rwa [sub_eq_zero])\n\n"}
{"name":"eval₂_minpolyDiv_of_eval₂_eq_zero","module":"Mathlib.FieldTheory.Minpoly.MinpolyDiv","initialProofState":"R : Type u_3\nS : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R S\nT : Type u_1\ninst✝² : CommRing T\ninst✝¹ : IsDomain T\ninst✝ : DecidableEq T\nx : S\ny : T\nσ : RingHom S T\nhy : Eq (Polynomial.eval₂ (σ.comp (algebraMap R S)) y (minpoly R x)) 0\n⊢ Eq (Polynomial.eval₂ σ y (minpolyDiv R x)) (ite (Eq (σ x) y) (σ ((Polynomial.aeval x) (Polynomial.derivative (minpoly R x)))) 0)","decl":"lemma eval₂_minpolyDiv_of_eval₂_eq_zero {T} [CommRing T]\n    [IsDomain T] [DecidableEq T] {x y}\n    (σ : S →+* T) (hy : eval₂ (σ.comp (algebraMap R S)) y (minpoly R x) = 0) :\n    eval₂ σ y (minpolyDiv R x) =\n      if σ x = y then σ (aeval x (derivative <| minpoly R x)) else 0 := by\n  split_ifs with h\n  · rw [← h, eval₂_hom, eval_minpolyDiv_self]\n  · rw [← eval₂_map, ← minpolyDiv_spec] at hy\n    simpa [sub_eq_zero, Ne.symm h] using hy\n\n"}
{"name":"eval₂_minpolyDiv_self","module":"Mathlib.FieldTheory.Minpoly.MinpolyDiv","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type u_1\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : IsDomain T\ninst✝ : DecidableEq T\nx : S\nσ₁ σ₂ : AlgHom R S T\n⊢ Eq (Polynomial.eval₂ (↑σ₁) (σ₂ x) (minpolyDiv R x)) (ite (Eq (σ₁ x) (σ₂ x)) (σ₁ ((Polynomial.aeval x) (Polynomial.derivative (minpoly R x)))) 0)","decl":"lemma eval₂_minpolyDiv_self {T} [CommRing T] [Algebra R T] [IsDomain T] [DecidableEq T] (x : S)\n    (σ₁ σ₂ : S →ₐ[R] T) :\n    eval₂ σ₁ (σ₂ x) (minpolyDiv R x) =\n      if σ₁ x = σ₂ x then σ₁ (aeval x (derivative <| minpoly R x)) else 0 := by\n  apply eval₂_minpolyDiv_of_eval₂_eq_zero\n  rw [AlgHom.comp_algebraMap, ← σ₂.comp_algebraMap, ← eval₂_map, ← RingHom.coe_coe, eval₂_hom,\n    eval_map, ← aeval_def, minpoly.aeval, map_zero]\n\n"}
{"name":"eval_minpolyDiv_of_aeval_eq_zero","module":"Mathlib.FieldTheory.Minpoly.MinpolyDiv","initialProofState":"R : Type u_2\nS : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nx : S\ninst✝¹ : IsDomain S\ninst✝ : DecidableEq S\ny : S\nhy : Eq ((Polynomial.aeval y) (minpoly R x)) 0\n⊢ Eq (Polynomial.eval y (minpolyDiv R x)) (ite (Eq x y) ((Polynomial.aeval x) (Polynomial.derivative (minpoly R x))) 0)","decl":"lemma eval_minpolyDiv_of_aeval_eq_zero [IsDomain S] [DecidableEq S]\n    {y} (hy : aeval y (minpoly R x) = 0) :\n    (minpolyDiv R x).eval y = if x = y then aeval x (derivative <| minpoly R x) else 0 := by\n  rw [eval, eval₂_minpolyDiv_of_eval₂_eq_zero, RingHom.id_apply, RingHom.id_apply]\n  simpa [aeval_def] using hy\n\n\n"}
{"name":"coeff_minpolyDiv_mem_adjoin","module":"Mathlib.FieldTheory.Minpoly.MinpolyDiv","initialProofState":"R : Type u_2\nS : Type u_1\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\ni : Nat\n⊢ Membership.mem (Algebra.adjoin R (Singleton.singleton x)) ((minpolyDiv R x).coeff i)","decl":"lemma coeff_minpolyDiv_mem_adjoin (x : S) (i) :\n    coeff (minpolyDiv R x) i ∈ Algebra.adjoin R {x} := by\n  by_contra H\n  have : ∀ j, coeff (minpolyDiv R x) (i + j) ∉ Algebra.adjoin R {x} := by\n    intro j; induction j with\n    | zero => exact H\n    | succ j IH =>\n      intro H; apply IH\n      rw [coeff_minpolyDiv]\n      refine add_mem ?_ (mul_mem H (Algebra.self_mem_adjoin_singleton R x))\n      exact Subalgebra.algebraMap_mem _ _\n  apply this (natDegree (minpolyDiv R x) + 1)\n  rw [coeff_eq_zero_of_natDegree_lt]\n  · exact zero_mem _\n  · refine (Nat.le_add_left _ i).trans_lt ?_\n    rw [← add_assoc]\n    exact Nat.lt_succ_self _\n\n"}
{"name":"minpolyDiv_ne_zero","module":"Mathlib.FieldTheory.Minpoly.MinpolyDiv","initialProofState":"R : Type u_2\nS : Type u_1\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nx : S\nhx : IsIntegral R x\ninst✝ : Nontrivial S\n⊢ Ne (minpolyDiv R x) 0","decl":"lemma minpolyDiv_ne_zero [Nontrivial S] : minpolyDiv R x ≠ 0 := by\n  intro e\n  have := minpolyDiv_spec R x\n  rw [e, zero_mul] at this\n  exact ((minpoly.monic hx).map (algebraMap R S)).ne_zero this.symm\n\n"}
{"name":"minpolyDiv_monic","module":"Mathlib.FieldTheory.Minpoly.MinpolyDiv","initialProofState":"R : Type u_2\nS : Type u_1\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\nhx : IsIntegral R x\n⊢ (minpolyDiv R x).Monic","decl":"lemma minpolyDiv_monic : Monic (minpolyDiv R x) := by\n  nontriviality S\n  have := congr_arg leadingCoeff (minpolyDiv_spec R x)\n  rw [leadingCoeff_mul', ((minpoly.monic hx).map (algebraMap R S)).leadingCoeff] at this\n  · simpa using this\n  · simpa using minpolyDiv_ne_zero hx\n\n"}
{"name":"natDegree_minpolyDiv_succ","module":"Mathlib.FieldTheory.Minpoly.MinpolyDiv","initialProofState":"R : Type u_2\nS : Type u_1\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nx : S\nhx : IsIntegral R x\ninst✝ : Nontrivial S\n⊢ Eq (HAdd.hAdd (minpolyDiv R x).natDegree 1) (minpoly R x).natDegree","decl":"lemma natDegree_minpolyDiv_succ [Nontrivial S] :\n    natDegree (minpolyDiv R x) + 1 = natDegree (minpoly R x) := by\n  rw [← (minpoly.monic hx).natDegree_map (algebraMap R S), ← minpolyDiv_spec, natDegree_mul']\n  · simp\n  · simpa using minpolyDiv_ne_zero hx\n\n"}
{"name":"natDegree_minpolyDiv_lt","module":"Mathlib.FieldTheory.Minpoly.MinpolyDiv","initialProofState":"R : Type u_2\nS : Type u_1\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nx : S\nhx : IsIntegral R x\ninst✝ : Nontrivial S\n⊢ LT.lt (minpolyDiv R x).natDegree (minpoly R x).natDegree","decl":"lemma natDegree_minpolyDiv_lt [Nontrivial S] :\n    natDegree (minpolyDiv R x) < natDegree (minpoly R x) := by\n  rw [← natDegree_minpolyDiv_succ hx]\n  exact Nat.lt_succ_self _\n\n"}
{"name":"minpolyDiv_eq_of_isIntegrallyClosed","module":"Mathlib.FieldTheory.Minpoly.MinpolyDiv","initialProofState":"R : Type u_1\nK : Type u_3\nS : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : Field K\ninst✝⁸ : CommRing S\ninst✝⁷ : Algebra R S\nx : S\nhx : IsIntegral R x\ninst✝⁶ : IsDomain R\ninst✝⁵ : IsIntegrallyClosed R\ninst✝⁴ : IsDomain S\ninst✝³ : Algebra R K\ninst✝² : Algebra K S\ninst✝¹ : IsScalarTower R K S\ninst✝ : IsFractionRing R K\n⊢ Eq (minpolyDiv R x) (minpolyDiv K x)","decl":"lemma minpolyDiv_eq_of_isIntegrallyClosed [IsDomain R] [IsIntegrallyClosed R] [IsDomain S]\n    [Algebra R K] [Algebra K S] [IsScalarTower R K S] [IsFractionRing R K] :\n    minpolyDiv R x = minpolyDiv K x := by\n  delta minpolyDiv\n  rw [IsScalarTower.algebraMap_eq R K S, ← map_map,\n    ← minpoly.isIntegrallyClosed_eq_field_fractions' _ hx]\n\n"}
{"name":"coeff_minpolyDiv_sub_pow_mem_span","module":"Mathlib.FieldTheory.Minpoly.MinpolyDiv","initialProofState":"R : Type u_2\nS : Type u_1\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\nhx : IsIntegral R x\ni : Nat\nhi : LE.le i (minpolyDiv R x).natDegree\n⊢ Membership.mem (Submodule.span R (Set.image (fun x_1 => HPow.hPow x x_1) (Set.Iio i))) (HSub.hSub ((minpolyDiv R x).coeff (HSub.hSub (minpolyDiv R x).natDegree i)) (HPow.hPow x i))","decl":"lemma coeff_minpolyDiv_sub_pow_mem_span {i} (hi : i ≤ natDegree (minpolyDiv R x)) :\n    coeff (minpolyDiv R x) (natDegree (minpolyDiv R x) - i) - x ^ i ∈\n      Submodule.span R ((x ^ ·) '' Set.Iio i) := by\n  induction i with\n  | zero => simp [(minpolyDiv_monic hx).leadingCoeff]\n  | succ i IH =>\n    rw [coeff_minpolyDiv, add_sub_assoc, pow_succ, ← sub_mul, Algebra.algebraMap_eq_smul_one]\n    refine add_mem ?_ ?_\n    · apply Submodule.smul_mem\n      apply Submodule.subset_span\n      exact ⟨0, Nat.zero_lt_succ _, pow_zero _⟩\n    · rw [← tsub_tsub, tsub_add_cancel_of_le (le_tsub_of_add_le_left (b := 1) hi)]\n      apply SetLike.le_def.mp ?_\n        (Submodule.mul_mem_mul (IH ((Nat.le_succ _).trans hi))\n          (Submodule.mem_span_singleton_self x))\n      rw [Submodule.span_mul_span, Set.mul_singleton, Set.image_image]\n      apply Submodule.span_mono\n      rintro _ ⟨j, hj, rfl⟩\n      rw [Set.mem_Iio] at hj\n      exact ⟨j + 1, Nat.add_lt_of_lt_sub hj, pow_succ x j⟩\n\n"}
{"name":"span_coeff_minpolyDiv","module":"Mathlib.FieldTheory.Minpoly.MinpolyDiv","initialProofState":"R : Type u_2\nS : Type u_1\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\nhx : IsIntegral R x\n⊢ Eq (Submodule.span R (Set.range (minpolyDiv R x).coeff)) (Subalgebra.toSubmodule (Algebra.adjoin R (Singleton.singleton x)))","decl":"lemma span_coeff_minpolyDiv :\n    Submodule.span R (Set.range (coeff (minpolyDiv R x))) =\n      Subalgebra.toSubmodule (Algebra.adjoin R {x}) := by\n  nontriviality S\n  classical\n  apply le_antisymm\n  · rw [Submodule.span_le]\n    rintro _ ⟨i, rfl⟩\n    apply coeff_minpolyDiv_mem_adjoin\n  · rw [← Submodule.span_range_natDegree_eq_adjoin (minpoly.monic hx) (minpoly.aeval _ _),\n      Submodule.span_le]\n    simp only [Finset.coe_image, Finset.coe_range, Set.image_subset_iff]\n    intro i\n    induction i using Nat.strongRecOn with | ind i hi => ?_\n    intro hi'\n    have : coeff (minpolyDiv R x) (natDegree (minpolyDiv R x) - i) ∈\n        Submodule.span R (Set.range (coeff (minpolyDiv R x))) :=\n      Submodule.subset_span (Set.mem_range_self _)\n    rw [Set.mem_preimage, SetLike.mem_coe, ← Submodule.sub_mem_iff_right _ this]\n    refine SetLike.le_def.mp ?_ (coeff_minpolyDiv_sub_pow_mem_span hx ?_)\n    · rw [Submodule.span_le, Set.image_subset_iff]\n      intro j (hj : j < i)\n      exact hi j hj (lt_trans hj hi')\n    · rwa [← natDegree_minpolyDiv_succ hx, Set.mem_Iio, Nat.lt_succ_iff] at hi'\n\n"}
{"name":"natDegree_minpolyDiv","module":"Mathlib.FieldTheory.Minpoly.MinpolyDiv","initialProofState":"R : Type u_2\nS : Type u_1\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\n⊢ Eq (minpolyDiv R x).natDegree (HSub.hSub (minpoly R x).natDegree 1)","decl":"lemma natDegree_minpolyDiv :\n    natDegree (minpolyDiv R x) = natDegree (minpoly R x) - 1 := by\n  nontriviality S\n  by_cases hx : IsIntegral R x\n  · rw [← natDegree_minpolyDiv_succ hx]; rfl\n  · rw [minpolyDiv_eq_zero hx, minpoly.eq_zero hx]; rfl\n\n\n"}
{"name":"sum_smul_minpolyDiv_eq_X_pow","module":"Mathlib.FieldTheory.Minpoly.MinpolyDiv","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁷ : Field K\ninst✝⁶ : Field L\ninst✝⁵ : Algebra K L\nE : Type u_1\ninst✝⁴ : Field E\ninst✝³ : Algebra K E\ninst✝² : IsAlgClosed E\ninst✝¹ : FiniteDimensional K L\ninst✝ : Algebra.IsSeparable K L\nx : L\nhxL : Eq (Algebra.adjoin K (Singleton.singleton x)) Top.top\nr : Nat\nhr : LT.lt r (Module.finrank K L)\n⊢ Eq (Finset.univ.sum fun σ => Polynomial.map (↑σ) (HSMul.hSMul (HDiv.hDiv (HPow.hPow x r) ((Polynomial.aeval x) (Polynomial.derivative (minpoly K x)))) (minpolyDiv K x))) (HPow.hPow Polynomial.X r)","decl":"lemma sum_smul_minpolyDiv_eq_X_pow (E) [Field E] [Algebra K E] [IsAlgClosed E]\n    [FiniteDimensional K L] [Algebra.IsSeparable K L]\n    {x : L} (hxL : Algebra.adjoin K {x} = ⊤) {r : ℕ} (hr : r < finrank K L) :\n    ∑ σ : L →ₐ[K] E, ((x ^ r / aeval x (derivative <| minpoly K x)) •\n      minpolyDiv K x).map σ = (X ^ r : E[X]) := by\n  classical\n  rw [← sub_eq_zero]\n  have : Function.Injective (fun σ : L →ₐ[K] E ↦ σ x) := fun _ _ h =>\n    AlgHom.ext_of_adjoin_eq_top hxL (fun _ hx ↦ hx ▸ h)\n  apply Polynomial.eq_zero_of_natDegree_lt_card_of_eval_eq_zero _ this\n  · intro σ\n    simp only [Polynomial.map_smul, map_div₀, map_pow, RingHom.coe_coe, eval_sub, eval_finset_sum,\n      eval_smul, eval_map, eval₂_minpolyDiv_self, this.eq_iff, smul_eq_mul, mul_ite, mul_zero,\n      Finset.sum_ite_eq', Finset.mem_univ, ite_true, eval_pow, eval_X]\n    rw [sub_eq_zero, div_mul_cancel₀]\n    rw [ne_eq, map_eq_zero_iff σ σ.toRingHom.injective]\n    exact (Algebra.IsSeparable.isSeparable _ _).aeval_derivative_ne_zero (minpoly.aeval _ _)\n  · refine (Polynomial.natDegree_sub_le _ _).trans_lt\n      (max_lt ((Polynomial.natDegree_sum_le _ _).trans_lt ?_) ?_)\n    · simp only [AlgEquiv.toAlgHom_eq_coe, Polynomial.map_smul,\n        map_div₀, map_pow, RingHom.coe_coe, AlgHom.coe_coe, Function.comp_apply,\n        Finset.mem_univ, forall_true_left, true_and, Finset.fold_max_lt, AlgHom.card]\n      refine ⟨finrank_pos, ?_⟩\n      intro σ\n      exact ((Polynomial.natDegree_smul_le _ _).trans natDegree_map_le).trans_lt\n        ((natDegree_minpolyDiv_lt (Algebra.IsIntegral.isIntegral x)).trans_le\n          (minpoly.natDegree_le _))\n    · rwa [natDegree_pow, natDegree_X, mul_one, AlgHom.card]\n\n"}
