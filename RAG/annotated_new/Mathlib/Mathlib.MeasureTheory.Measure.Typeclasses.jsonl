{"name":"MeasureTheory.IsFiniteMeasure.measure_univ_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nself : MeasureTheory.IsFiniteMeasure Œº\n‚ä¢ LT.lt (Œº Set.univ) Top.top","decl":"/-- A measure `Œº` is called finite if `Œº univ < ‚àû`. -/\n@[mk_iff]\nclass IsFiniteMeasure (Œº : Measure Œ±) : Prop where\n  measure_univ_lt_top : Œº univ < ‚àû\n\n"}
{"name":"MeasureTheory.isFiniteMeasure_iff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\n‚ä¢ Iff (MeasureTheory.IsFiniteMeasure Œº) (LT.lt (Œº Set.univ) Top.top)","decl":"/-- A measure `Œº` is called finite if `Œº univ < ‚àû`. -/\n@[mk_iff]\nclass IsFiniteMeasure (Œº : Measure Œ±) : Prop where\n  measure_univ_lt_top : Œº univ < ‚àû\n\n"}
{"name":"MeasureTheory.not_isFiniteMeasure_iff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\n‚ä¢ Iff (Not (MeasureTheory.IsFiniteMeasure Œº)) (Eq (Œº Set.univ) Top.top)","decl":"lemma not_isFiniteMeasure_iff : ¬¨IsFiniteMeasure Œº ‚Üî Œº univ = ‚àû := by simp [isFiniteMeasure_iff]\n\n"}
{"name":"MeasureTheory.isFiniteMeasure_restrict","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\n‚ä¢ Iff (MeasureTheory.IsFiniteMeasure (Œº.restrict s)) (Ne (Œº s) Top.top)","decl":"lemma isFiniteMeasure_restrict : IsFiniteMeasure (Œº.restrict s) ‚Üî Œº s ‚â† ‚àû := by\n  simp [isFiniteMeasure_iff, lt_top_iff_ne_top]\n\n"}
{"name":"MeasureTheory.Restrict.isFiniteMeasure","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\ns : Set Œ±\nŒº : MeasureTheory.Measure Œ±\nhs : Fact (LT.lt (Œº s) Top.top)\n‚ä¢ MeasureTheory.IsFiniteMeasure (Œº.restrict s)","decl":"instance Restrict.isFiniteMeasure (Œº : Measure Œ±) [hs : Fact (Œº s < ‚àû)] :\n    IsFiniteMeasure (Œº.restrict s) :=\n  ‚ü®by simpa using hs.elim‚ü©\n\n"}
{"name":"MeasureTheory.measure_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\ns : Set Œ±\n‚ä¢ LT.lt (Œº s) Top.top","decl":"@[simp]\ntheorem measure_lt_top (Œº : Measure Œ±) [IsFiniteMeasure Œº] (s : Set Œ±) : Œº s < ‚àû :=\n  (measure_mono (subset_univ s)).trans_lt IsFiniteMeasure.measure_univ_lt_top\n\n"}
{"name":"MeasureTheory.isFiniteMeasureRestrict","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\nh : MeasureTheory.IsFiniteMeasure Œº\n‚ä¢ MeasureTheory.IsFiniteMeasure (Œº.restrict s)","decl":"instance isFiniteMeasureRestrict (Œº : Measure Œ±) (s : Set Œ±) [h : IsFiniteMeasure Œº] :\n    IsFiniteMeasure (Œº.restrict s) := ‚ü®by simp‚ü©\n\n"}
{"name":"MeasureTheory.measure_ne_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\ns : Set Œ±\n‚ä¢ Ne (Œº s) Top.top","decl":"@[simp, aesop (rule_sets := [finiteness]) safe apply]\ntheorem measure_ne_top (Œº : Measure Œ±) [IsFiniteMeasure Œº] (s : Set Œ±) : Œº s ‚â† ‚àû :=\n  ne_of_lt (measure_lt_top Œº s)\n\n"}
{"name":"MeasureTheory.measure_compl_le_add_of_le_add","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns t : Set Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhs : MeasurableSet s\nht : MeasurableSet t\nŒµ : ENNReal\nh : LE.le (Œº s) (HAdd.hAdd (Œº t) Œµ)\n‚ä¢ LE.le (Œº (HasCompl.compl t)) (HAdd.hAdd (Œº (HasCompl.compl s)) Œµ)","decl":"theorem measure_compl_le_add_of_le_add [IsFiniteMeasure Œº] (hs : MeasurableSet s)\n    (ht : MeasurableSet t) {Œµ : ‚Ñù‚â•0‚àû} (h : Œº s ‚â§ Œº t + Œµ) : Œº t·∂ú ‚â§ Œº s·∂ú + Œµ := by\n  rw [measure_compl ht (measure_ne_top Œº _), measure_compl hs (measure_ne_top Œº _),\n    tsub_le_iff_right]\n  calc\n    Œº univ = Œº univ - Œº s + Œº s := (tsub_add_cancel_of_le <| measure_mono s.subset_univ).symm\n    _ ‚â§ Œº univ - Œº s + (Œº t + Œµ) := add_le_add_left h _\n    _ = _ := by rw [add_right_comm, add_assoc]\n\n"}
{"name":"MeasureTheory.measure_compl_le_add_iff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns t : Set Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhs : MeasurableSet s\nht : MeasurableSet t\nŒµ : ENNReal\n‚ä¢ Iff (LE.le (Œº (HasCompl.compl s)) (HAdd.hAdd (Œº (HasCompl.compl t)) Œµ)) (LE.le (Œº t) (HAdd.hAdd (Œº s) Œµ))","decl":"theorem measure_compl_le_add_iff [IsFiniteMeasure Œº] (hs : MeasurableSet s) (ht : MeasurableSet t)\n    {Œµ : ‚Ñù‚â•0‚àû} : Œº s·∂ú ‚â§ Œº t·∂ú + Œµ ‚Üî Œº t ‚â§ Œº s + Œµ :=\n  ‚ü®fun h => compl_compl s ‚ñ∏ compl_compl t ‚ñ∏ measure_compl_le_add_of_le_add hs.compl ht.compl h,\n    measure_compl_le_add_of_le_add ht hs‚ü©\n\n"}
{"name":"MeasureTheory.coe_measureUnivNNReal","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\n‚ä¢ Eq (‚Üë(MeasureTheory.measureUnivNNReal Œº)) (Œº Set.univ)","decl":"@[simp]\ntheorem coe_measureUnivNNReal (Œº : Measure Œ±) [IsFiniteMeasure Œº] :\n    ‚Üë(measureUnivNNReal Œº) = Œº univ :=\n  ENNReal.coe_toNNReal (measure_ne_top Œº univ)\n\n"}
{"name":"MeasureTheory.isFiniteMeasureZero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\n‚ä¢ MeasureTheory.IsFiniteMeasure 0","decl":"instance isFiniteMeasureZero : IsFiniteMeasure (0 : Measure Œ±) :=\n  ‚ü®by simp‚ü©\n\n"}
{"name":"MeasureTheory.isFiniteMeasureOfIsEmpty","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : IsEmpty Œ±\n‚ä¢ MeasureTheory.IsFiniteMeasure Œº","decl":"instance (priority := 50) isFiniteMeasureOfIsEmpty [IsEmpty Œ±] : IsFiniteMeasure Œº := by\n  rw [eq_zero_of_isEmpty Œº]\n  infer_instance\n\n"}
{"name":"MeasureTheory.measureUnivNNReal_zero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\n‚ä¢ Eq (MeasureTheory.measureUnivNNReal 0) 0","decl":"@[simp]\ntheorem measureUnivNNReal_zero : measureUnivNNReal (0 : Measure Œ±) = 0 :=\n  rfl\n\n"}
{"name":"MeasureTheory.isFiniteMeasureAdd","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº ŒΩ : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.IsFiniteMeasure Œº\ninst‚úù : MeasureTheory.IsFiniteMeasure ŒΩ\n‚ä¢ MeasureTheory.IsFiniteMeasure (HAdd.hAdd Œº ŒΩ)","decl":"instance isFiniteMeasureAdd [IsFiniteMeasure Œº] [IsFiniteMeasure ŒΩ] : IsFiniteMeasure (Œº + ŒΩ) where\n  measure_univ_lt_top := by\n    rw [Measure.coe_add, Pi.add_apply, ENNReal.add_lt_top]\n    exact ‚ü®measure_lt_top _ _, measure_lt_top _ _‚ü©\n\n"}
{"name":"MeasureTheory.isFiniteMeasureSMulNNReal","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nr : NNReal\n‚ä¢ MeasureTheory.IsFiniteMeasure (HSMul.hSMul r Œº)","decl":"instance isFiniteMeasureSMulNNReal [IsFiniteMeasure Œº] {r : ‚Ñù‚â•0} : IsFiniteMeasure (r ‚Ä¢ Œº) where\n  measure_univ_lt_top := ENNReal.mul_lt_top ENNReal.coe_lt_top (measure_lt_top _ _)\n\n"}
{"name":"MeasureTheory.IsFiniteMeasure.average","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\n‚ä¢ MeasureTheory.IsFiniteMeasure (HSMul.hSMul (Inv.inv (Œº Set.univ)) Œº)","decl":"instance IsFiniteMeasure.average : IsFiniteMeasure ((Œº univ)‚Åª¬π ‚Ä¢ Œº) where\n  measure_univ_lt_top := by\n    rw [smul_apply, smul_eq_mul, ‚Üê ENNReal.div_eq_inv_mul]\n    exact ENNReal.div_self_le_one.trans_lt ENNReal.one_lt_top\n\n"}
{"name":"MeasureTheory.isFiniteMeasureSMulOfNNRealTower","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nR : Type u_5\ninst‚úù‚Å¥ : SMul R NNReal\ninst‚úù¬≥ : SMul R ENNReal\ninst‚úù¬≤ : IsScalarTower R NNReal ENNReal\ninst‚úù¬π : IsScalarTower R ENNReal ENNReal\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nr : R\n‚ä¢ MeasureTheory.IsFiniteMeasure (HSMul.hSMul r Œº)","decl":"instance isFiniteMeasureSMulOfNNRealTower {R} [SMul R ‚Ñù‚â•0] [SMul R ‚Ñù‚â•0‚àû] [IsScalarTower R ‚Ñù‚â•0 ‚Ñù‚â•0‚àû]\n    [IsScalarTower R ‚Ñù‚â•0‚àû ‚Ñù‚â•0‚àû] [IsFiniteMeasure Œº] {r : R} : IsFiniteMeasure (r ‚Ä¢ Œº) := by\n  rw [‚Üê smul_one_smul ‚Ñù‚â•0 r Œº]\n  infer_instance\n\n"}
{"name":"MeasureTheory.isFiniteMeasure_of_le","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒΩ Œº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nh : LE.le ŒΩ Œº\n‚ä¢ MeasureTheory.IsFiniteMeasure ŒΩ","decl":"theorem isFiniteMeasure_of_le (Œº : Measure Œ±) [IsFiniteMeasure Œº] (h : ŒΩ ‚â§ Œº) : IsFiniteMeasure ŒΩ :=\n  { measure_univ_lt_top := (h Set.univ).trans_lt (measure_lt_top _ _) }\n\n"}
{"name":"MeasureTheory.Measure.isFiniteMeasure_map","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : MeasurableSpace Œ≤\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nf : Œ± ‚Üí Œ≤\n‚ä¢ MeasureTheory.IsFiniteMeasure (MeasureTheory.Measure.map f Œº)","decl":"@[instance]\ntheorem Measure.isFiniteMeasure_map {m : MeasurableSpace Œ±} (Œº : Measure Œ±) [IsFiniteMeasure Œº]\n    (f : Œ± ‚Üí Œ≤) : IsFiniteMeasure (Œº.map f) := by\n  by_cases hf : AEMeasurable f Œº\n  ¬∑ constructor\n    rw [map_apply_of_aemeasurable hf MeasurableSet.univ]\n    exact measure_lt_top Œº _\n  ¬∑ rw [map_of_not_aemeasurable hf]\n    exact MeasureTheory.isFiniteMeasureZero\n\n"}
{"name":"MeasureTheory.IsFiniteMeasure_comap","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù¬π : MeasurableSpace Œ≤\nŒº : MeasureTheory.Measure Œ±\nf : Œ≤ ‚Üí Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\n‚ä¢ MeasureTheory.IsFiniteMeasure (MeasureTheory.Measure.comap f Œº)","decl":"instance IsFiniteMeasure_comap (f : Œ≤ ‚Üí Œ±) [IsFiniteMeasure Œº] : IsFiniteMeasure (Œº.comap f) where\n  measure_univ_lt_top := by\n    by_cases hf : Injective f ‚àß ‚àÄ s, MeasurableSet s ‚Üí NullMeasurableSet (f '' s) Œº\n    ¬∑ rw [Measure.comap_apply‚ÇÄ _ _ hf.1 hf.2 MeasurableSet.univ.nullMeasurableSet]\n      exact measure_lt_top Œº _\n    ¬∑ rw [Measure.comap, dif_neg hf]\n      exact zero_lt_top\n\n"}
{"name":"MeasureTheory.measureUnivNNReal_eq_zero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\n‚ä¢ Iff (Eq (MeasureTheory.measureUnivNNReal Œº) 0) (Eq Œº 0)","decl":"@[simp]\ntheorem measureUnivNNReal_eq_zero [IsFiniteMeasure Œº] : measureUnivNNReal Œº = 0 ‚Üî Œº = 0 := by\n  rw [‚Üê MeasureTheory.Measure.measure_univ_eq_zero, ‚Üê coe_measureUnivNNReal]\n  norm_cast\n\n"}
{"name":"MeasureTheory.measureUnivNNReal_pos","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhŒº : Ne Œº 0\n‚ä¢ LT.lt 0 (MeasureTheory.measureUnivNNReal Œº)","decl":"theorem measureUnivNNReal_pos [IsFiniteMeasure Œº] (hŒº : Œº ‚â† 0) : 0 < measureUnivNNReal Œº := by\n  contrapose! hŒº\n  simpa [measureUnivNNReal_eq_zero, Nat.le_zero] using hŒº\n\n"}
{"name":"MeasureTheory.Measure.le_of_add_le_add_left","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº ŒΩ‚ÇÅ ŒΩ‚ÇÇ : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nA2 : LE.le (HAdd.hAdd Œº ŒΩ‚ÇÅ) (HAdd.hAdd Œº ŒΩ‚ÇÇ)\n‚ä¢ LE.le ŒΩ‚ÇÅ ŒΩ‚ÇÇ","decl":"/-- `le_of_add_le_add_left` is normally applicable to `OrderedCancelAddCommMonoid`,\nbut it holds for measures with the additional assumption that Œº is finite. -/\ntheorem Measure.le_of_add_le_add_left [IsFiniteMeasure Œº] (A2 : Œº + ŒΩ‚ÇÅ ‚â§ Œº + ŒΩ‚ÇÇ) : ŒΩ‚ÇÅ ‚â§ ŒΩ‚ÇÇ :=\n  fun S => ENNReal.le_of_add_le_add_left (MeasureTheory.measure_ne_top Œº S) (A2 S)\n\n"}
{"name":"MeasureTheory.summable_measure_toReal","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nhŒº : MeasureTheory.IsFiniteMeasure Œº\nf : Nat ‚Üí Set Œ±\nhf‚ÇÅ : ‚àÄ (i : Nat), MeasurableSet (f i)\nhf‚ÇÇ : Pairwise (Function.onFun Disjoint f)\n‚ä¢ Summable fun x => (Œº (f x)).toReal","decl":"theorem summable_measure_toReal [hŒº : IsFiniteMeasure Œº] {f : ‚Ñï ‚Üí Set Œ±}\n    (hf‚ÇÅ : ‚àÄ i : ‚Ñï, MeasurableSet (f i)) (hf‚ÇÇ : Pairwise (Disjoint on f)) :\n    Summable fun x => (Œº (f x)).toReal := by\n  apply ENNReal.summable_toReal\n  rw [‚Üê MeasureTheory.measure_iUnion hf‚ÇÇ hf‚ÇÅ]\n  exact ne_of_lt (measure_lt_top _ _)\n\n"}
{"name":"MeasureTheory.ae_eq_univ_iff_measure_eq","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhs : MeasureTheory.NullMeasurableSet s Œº\n‚ä¢ Iff ((MeasureTheory.ae Œº).EventuallyEq s Set.univ) (Eq (Œº s) (Œº Set.univ))","decl":"theorem ae_eq_univ_iff_measure_eq [IsFiniteMeasure Œº] (hs : NullMeasurableSet s Œº) :\n    s =·µê[Œº] univ ‚Üî Œº s = Œº univ :=\n  ‚ü®measure_congr, fun h ‚Ü¶\n    ae_eq_of_subset_of_measure_ge (subset_univ _) h.ge hs (measure_ne_top _ _)‚ü©\n\n"}
{"name":"MeasureTheory.ae_iff_measure_eq","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\np : Œ± ‚Üí Prop\nhp : MeasureTheory.NullMeasurableSet (setOf fun a => p a) Œº\n‚ä¢ Iff (Filter.Eventually (fun a => p a) (MeasureTheory.ae Œº)) (Eq (Œº (setOf fun a => p a)) (Œº Set.univ))","decl":"theorem ae_iff_measure_eq [IsFiniteMeasure Œº] {p : Œ± ‚Üí Prop}\n    (hp : NullMeasurableSet { a | p a } Œº) : (‚àÄ·µê a ‚àÇŒº, p a) ‚Üî Œº { a | p a } = Œº univ := by\n  rw [‚Üê ae_eq_univ_iff_measure_eq hp, eventuallyEq_univ, eventually_iff]\n\n"}
{"name":"MeasureTheory.ae_mem_iff_measure_eq","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\ns : Set Œ±\nhs : MeasureTheory.NullMeasurableSet s Œº\n‚ä¢ Iff (Filter.Eventually (fun a => Membership.mem s a) (MeasureTheory.ae Œº)) (Eq (Œº s) (Œº Set.univ))","decl":"theorem ae_mem_iff_measure_eq [IsFiniteMeasure Œº] {s : Set Œ±} (hs : NullMeasurableSet s Œº) :\n    (‚àÄ·µê a ‚àÇŒº, a ‚àà s) ‚Üî Œº s = Œº univ :=\n  ae_iff_measure_eq hs\n\n"}
{"name":"MeasureTheory.tendsto_measure_biUnion_Ici_zero_of_pairwise_disjoint","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"X : Type u_5\ninst‚úù¬π : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nEs : Nat ‚Üí Set X\nEs_mble : ‚àÄ (i : Nat), MeasureTheory.NullMeasurableSet (Es i) Œº\nEs_disj : Pairwise fun n m => Disjoint (Es n) (Es m)\n‚ä¢ Filter.Tendsto (Function.comp ‚áëŒº fun n => Set.iUnion fun i => Set.iUnion fun h => Es i) Filter.atTop (nhds 0)","decl":"lemma tendsto_measure_biUnion_Ici_zero_of_pairwise_disjoint\n    {X : Type*} [MeasurableSpace X] {Œº : Measure X} [IsFiniteMeasure Œº]\n    {Es : ‚Ñï ‚Üí Set X} (Es_mble : ‚àÄ i, NullMeasurableSet (Es i) Œº)\n    (Es_disj : Pairwise fun n m ‚Ü¶ Disjoint (Es n) (Es m)) :\n    Tendsto (Œº ‚àò fun n ‚Ü¶ ‚ãÉ i ‚â• n, Es i) atTop (ùìù 0) := by\n  have decr : Antitone fun n ‚Ü¶ ‚ãÉ i ‚â• n, Es i :=\n    fun n m hnm ‚Ü¶ biUnion_mono (fun _ hi ‚Ü¶ le_trans hnm hi) (fun _ _ ‚Ü¶ subset_rfl)\n  have nothing : ‚ãÇ n, ‚ãÉ i ‚â• n, Es i = ‚àÖ := by\n    apply subset_antisymm _ (empty_subset _)\n    intro x hx\n    simp only [mem_iInter, mem_iUnion, exists_prop] at hx\n    obtain ‚ü®j, _, x_in_Es_j‚ü© := hx 0\n    obtain ‚ü®k, k_gt_j, x_in_Es_k‚ü© := hx (j+1)\n    have oops := (Es_disj (Nat.ne_of_lt k_gt_j)).ne_of_mem x_in_Es_j x_in_Es_k\n    contradiction\n  have key := tendsto_measure_iInter_atTop (Œº := Œº) (fun n ‚Ü¶ by measurability)\n    decr ‚ü®0, measure_ne_top _ _‚ü©\n  simp only [nothing, measure_empty] at key\n  convert key\n\n"}
{"name":"MeasureTheory.abs_toReal_measure_sub_le_measure_symmDiff'","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns t : Set Œ±\nhs : MeasureTheory.NullMeasurableSet s Œº\nht : MeasureTheory.NullMeasurableSet t Œº\nhs' : Ne (Œº s) Top.top\nht' : Ne (Œº t) Top.top\n‚ä¢ LE.le (abs (HSub.hSub (Œº s).toReal (Œº t).toReal)) (Œº (symmDiff s t)).toReal","decl":"theorem abs_toReal_measure_sub_le_measure_symmDiff'\n    (hs : NullMeasurableSet s Œº) (ht : NullMeasurableSet t Œº) (hs' : Œº s ‚â† ‚àû) (ht' : Œº t ‚â† ‚àû) :\n    |(Œº s).toReal - (Œº t).toReal| ‚â§ (Œº (s ‚àÜ t)).toReal := by\n  have hst : Œº (s \\ t) ‚â† ‚àû := (measure_lt_top_of_subset diff_subset hs').ne\n  have hts : Œº (t \\ s) ‚â† ‚àû := (measure_lt_top_of_subset diff_subset ht').ne\n  suffices (Œº s).toReal - (Œº t).toReal = (Œº (s \\ t)).toReal - (Œº (t \\ s)).toReal by\n    rw [this, measure_symmDiff_eq hs ht, ENNReal.toReal_add hst hts]\n    convert abs_sub (Œº (s \\ t)).toReal (Œº (t \\ s)).toReal <;> simp\n  rw [measure_diff' s ht ht', measure_diff' t hs hs',\n    ENNReal.toReal_sub_of_le measure_le_measure_union_right (measure_union_ne_top hs' ht'),\n    ENNReal.toReal_sub_of_le measure_le_measure_union_right (measure_union_ne_top ht' hs'),\n    union_comm t s]\n  abel\n\n"}
{"name":"MeasureTheory.abs_toReal_measure_sub_le_measure_symmDiff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns t : Set Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhs : MeasureTheory.NullMeasurableSet s Œº\nht : MeasureTheory.NullMeasurableSet t Œº\n‚ä¢ LE.le (abs (HSub.hSub (Œº s).toReal (Œº t).toReal)) (Œº (symmDiff s t)).toReal","decl":"theorem abs_toReal_measure_sub_le_measure_symmDiff [IsFiniteMeasure Œº]\n    (hs : NullMeasurableSet s Œº) (ht : NullMeasurableSet t Œº) :\n    |(Œº s).toReal - (Œº t).toReal| ‚â§ (Œº (s ‚àÜ t)).toReal :=\n  abs_toReal_measure_sub_le_measure_symmDiff' hs ht (measure_ne_top Œº s) (measure_ne_top Œº t)\n\n"}
{"name":"MeasureTheory.instIsFiniteMeasureSumMeasure","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\nm0 : MeasurableSpace Œ±\ns : Finset Œπ\nŒº : Œπ ‚Üí MeasureTheory.Measure Œ±\ninst‚úù : ‚àÄ (i : Œπ), MeasureTheory.IsFiniteMeasure (Œº i)\n‚ä¢ MeasureTheory.IsFiniteMeasure (s.sum fun i => Œº i)","decl":"instance {s : Finset Œπ} {Œº : Œπ ‚Üí Measure Œ±} [‚àÄ i, IsFiniteMeasure (Œº i)] :\n    IsFiniteMeasure (‚àë i ‚àà s, Œº i) where measure_univ_lt_top := by simp [measure_lt_top]\n\n"}
{"name":"MeasureTheory.instIsFiniteMeasureSumOfFinite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\nm0 : MeasurableSpace Œ±\ninst‚úù¬π : Finite Œπ\nŒº : Œπ ‚Üí MeasureTheory.Measure Œ±\ninst‚úù : ‚àÄ (i : Œπ), MeasureTheory.IsFiniteMeasure (Œº i)\n‚ä¢ MeasureTheory.IsFiniteMeasure (MeasureTheory.Measure.sum Œº)","decl":"instance [Finite Œπ] {Œº : Œπ ‚Üí Measure Œ±} [‚àÄ i, IsFiniteMeasure (Œº i)] :\n    IsFiniteMeasure (.sum Œº) where\n  measure_univ_lt_top := by\n    cases nonempty_fintype Œπ\n    simp [measure_lt_top]\n\n"}
{"name":"MeasureTheory.IsZeroOrProbabilityMeasure.measure_univ","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nself : MeasureTheory.IsZeroOrProbabilityMeasure Œº\n‚ä¢ Or (Eq (Œº Set.univ) 0) (Eq (Œº Set.univ) 1)","decl":"/-- A measure `Œº` is zero or a probability measure if `Œº univ = 0` or `Œº univ = 1`. This class\nof measures appears naturally when conditioning on events, and many results which are true for\nprobability measures hold more generally over this class. -/\nclass IsZeroOrProbabilityMeasure (Œº : Measure Œ±) : Prop where\n  measure_univ : Œº univ = 0 ‚à® Œº univ = 1\n\n"}
{"name":"MeasureTheory.isZeroOrProbabilityMeasure_iff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\n‚ä¢ Iff (MeasureTheory.IsZeroOrProbabilityMeasure Œº) (Or (Eq (Œº Set.univ) 0) (Eq (Œº Set.univ) 1))","decl":"lemma isZeroOrProbabilityMeasure_iff : IsZeroOrProbabilityMeasure Œº ‚Üî Œº univ = 0 ‚à® Œº univ = 1 :=\n  ‚ü®fun _ ‚Ü¶ IsZeroOrProbabilityMeasure.measure_univ, IsZeroOrProbabilityMeasure.mk‚ü©\n\n"}
{"name":"MeasureTheory.prob_le_one","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsZeroOrProbabilityMeasure Œº\ns : Set Œ±\n‚ä¢ LE.le (Œº s) 1","decl":"lemma prob_le_one {Œº : Measure Œ±} [IsZeroOrProbabilityMeasure Œº] {s : Set Œ±} : Œº s ‚â§ 1 := by\n  apply (measure_mono (subset_univ _)).trans\n  rcases IsZeroOrProbabilityMeasure.measure_univ (Œº := Œº) with h | h <;> simp [h]\n\n"}
{"name":"MeasureTheory.one_le_prob_iff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\ns : Set Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsZeroOrProbabilityMeasure Œº\n‚ä¢ Iff (LE.le 1 (Œº s)) (Eq (Œº s) 1)","decl":"@[simp]\ntheorem one_le_prob_iff {Œº : Measure Œ±} [IsZeroOrProbabilityMeasure Œº] : 1 ‚â§ Œº s ‚Üî Œº s = 1 :=\n  ‚ü®fun h => le_antisymm prob_le_one h, fun h => h ‚ñ∏ le_refl _‚ü©\n\n"}
{"name":"MeasureTheory.IsZeroOrProbabilityMeasure.toIsFiniteMeasure","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsZeroOrProbabilityMeasure Œº\n‚ä¢ MeasureTheory.IsFiniteMeasure Œº","decl":"instance (priority := 100) IsZeroOrProbabilityMeasure.toIsFiniteMeasure (Œº : Measure Œ±)\n    [IsZeroOrProbabilityMeasure Œº] : IsFiniteMeasure Œº :=\n  ‚ü®prob_le_one.trans_lt one_lt_top‚ü©\n\n"}
{"name":"MeasureTheory.instIsZeroOrProbabilityMeasureOfNatMeasure","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\n‚ä¢ MeasureTheory.IsZeroOrProbabilityMeasure 0","decl":"instance : IsZeroOrProbabilityMeasure (0 : Measure Œ±) :=\n  ‚ü®Or.inl rfl‚ü©\n\n"}
{"name":"MeasureTheory.IsProbabilityMeasure.measure_univ","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nself : MeasureTheory.IsProbabilityMeasure Œº\n‚ä¢ Eq (Œº Set.univ) 1","decl":"/-- A measure `Œº` is called a probability measure if `Œº univ = 1`. -/\nclass IsProbabilityMeasure (Œº : Measure Œ±) : Prop where\n  measure_univ : Œº univ = 1\n\n"}
{"name":"MeasureTheory.isProbabilityMeasure_iff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\n‚ä¢ Iff (MeasureTheory.IsProbabilityMeasure Œº) (Eq (Œº Set.univ) 1)","decl":"lemma isProbabilityMeasure_iff : IsProbabilityMeasure Œº ‚Üî Œº univ = 1 :=\n  ‚ü®fun _ ‚Ü¶ measure_univ, IsProbabilityMeasure.mk‚ü©\n\n"}
{"name":"MeasureTheory.instIsZeroOrProbabilityMeasureOfIsProbabilityMeasure","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\n‚ä¢ MeasureTheory.IsZeroOrProbabilityMeasure Œº","decl":"instance (priority := 100) (Œº : Measure Œ±) [IsProbabilityMeasure Œº] :\n    IsZeroOrProbabilityMeasure Œº :=\n  ‚ü®Or.inr measure_univ‚ü©\n\n"}
{"name":"MeasureTheory.IsProbabilityMeasure.ne_zero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\n‚ä¢ Ne Œº 0","decl":"theorem IsProbabilityMeasure.ne_zero (Œº : Measure Œ±) [IsProbabilityMeasure Œº] : Œº ‚â† 0 :=\n  mt measure_univ_eq_zero.2 <| by simp [measure_univ]\n\n"}
{"name":"MeasureTheory.IsProbabilityMeasure.neZero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\n‚ä¢ NeZero Œº","decl":"instance (priority := 100) IsProbabilityMeasure.neZero (Œº : Measure Œ±) [IsProbabilityMeasure Œº] :\n    NeZero Œº := ‚ü®IsProbabilityMeasure.ne_zero Œº‚ü©\n\n-- Porting note: no longer an `instance` because `inferInstance` can find it now\n"}
{"name":"MeasureTheory.IsProbabilityMeasure.ae_neBot","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\n‚ä¢ (MeasureTheory.ae Œº).NeBot","decl":"theorem IsProbabilityMeasure.ae_neBot [IsProbabilityMeasure Œº] : NeBot (ae Œº) := inferInstance\n\n"}
{"name":"MeasureTheory.prob_add_prob_compl","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\nh : MeasurableSet s\n‚ä¢ Eq (HAdd.hAdd (Œº s) (Œº (HasCompl.compl s))) 1","decl":"theorem prob_add_prob_compl [IsProbabilityMeasure Œº] (h : MeasurableSet s) : Œº s + Œº s·∂ú = 1 :=\n  (measure_add_measure_compl h).trans measure_univ\n\n-- Porting note: made an `instance`, using `NeZero`\n"}
{"name":"MeasureTheory.isProbabilityMeasureSMul","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.IsFiniteMeasure Œº\ninst‚úù : NeZero Œº\n‚ä¢ MeasureTheory.IsProbabilityMeasure (HSMul.hSMul (Inv.inv (Œº Set.univ)) Œº)","decl":"instance isProbabilityMeasureSMul [IsFiniteMeasure Œº] [NeZero Œº] :\n    IsProbabilityMeasure ((Œº univ)‚Åª¬π ‚Ä¢ Œº) :=\n  ‚ü®ENNReal.inv_mul_cancel (NeZero.ne (Œº univ)) (measure_ne_top _ _)‚ü©\n\n"}
{"name":"MeasureTheory.isProbabilityMeasure_map","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù¬π : MeasurableSpace Œ≤\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\nf : Œ± ‚Üí Œ≤\nhf : AEMeasurable f Œº\n‚ä¢ MeasureTheory.IsProbabilityMeasure (MeasureTheory.Measure.map f Œº)","decl":"theorem isProbabilityMeasure_map {f : Œ± ‚Üí Œ≤} (hf : AEMeasurable f Œº) :\n    IsProbabilityMeasure (map f Œº) :=\n  ‚ü®by simp [map_apply_of_aemeasurable, hf]‚ü©\n\n"}
{"name":"MeasureTheory.IsProbabilityMeasure_comap_equiv","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù : MeasurableSpace Œ≤\nŒº : MeasureTheory.Measure Œ±\nf : MeasurableEquiv Œ≤ Œ±\n‚ä¢ MeasureTheory.IsProbabilityMeasure (MeasureTheory.Measure.comap (‚áëf) Œº)","decl":"instance IsProbabilityMeasure_comap_equiv (f : Œ≤ ‚âÉ·µê Œ±) : IsProbabilityMeasure (Œº.comap f) := by\n  rw [‚Üê MeasurableEquiv.map_symm]; exact isProbabilityMeasure_map f.symm.measurable.aemeasurable\n\n"}
{"name":"MeasureTheory.prob_compl_eq_one_sub‚ÇÄ","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\nh : MeasureTheory.NullMeasurableSet s Œº\n‚ä¢ Eq (Œº (HasCompl.compl s)) (HSub.hSub 1 (Œº s))","decl":"/-- Note that this is not quite as useful as it looks because the measure takes values in `‚Ñù‚â•0‚àû`.\nThus the subtraction appearing is the truncated subtraction of `‚Ñù‚â•0‚àû`, rather than the\nbetter-behaved subtraction of `‚Ñù`. -/\nlemma prob_compl_eq_one_sub‚ÇÄ (h : NullMeasurableSet s Œº) : Œº s·∂ú = 1 - Œº s := by\n  rw [measure_compl‚ÇÄ h (measure_ne_top _ _), measure_univ]\n\n"}
{"name":"MeasureTheory.prob_compl_eq_one_sub","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\nhs : MeasurableSet s\n‚ä¢ Eq (Œº (HasCompl.compl s)) (HSub.hSub 1 (Œº s))","decl":"/-- Note that this is not quite as useful as it looks because the measure takes values in `‚Ñù‚â•0‚àû`.\nThus the subtraction appearing is the truncated subtraction of `‚Ñù‚â•0‚àû`, rather than the\nbetter-behaved subtraction of `‚Ñù`. -/\ntheorem prob_compl_eq_one_sub (hs : MeasurableSet s) : Œº s·∂ú = 1 - Œº s :=\n  prob_compl_eq_one_sub‚ÇÄ hs.nullMeasurableSet\n\n"}
{"name":"MeasureTheory.prob_compl_eq_zero_iff‚ÇÄ","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\nhs : MeasureTheory.NullMeasurableSet s Œº\n‚ä¢ Iff (Eq (Œº (HasCompl.compl s)) 0) (Eq (Œº s) 1)","decl":"@[simp] lemma prob_compl_eq_zero_iff‚ÇÄ (hs : NullMeasurableSet s Œº) : Œº s·∂ú = 0 ‚Üî Œº s = 1 := by\n  rw [prob_compl_eq_one_sub‚ÇÄ hs, tsub_eq_zero_iff_le, one_le_prob_iff]\n\n"}
{"name":"MeasureTheory.prob_compl_eq_zero_iff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\nhs : MeasurableSet s\n‚ä¢ Iff (Eq (Œº (HasCompl.compl s)) 0) (Eq (Œº s) 1)","decl":"@[simp] lemma prob_compl_eq_zero_iff (hs : MeasurableSet s) : Œº s·∂ú = 0 ‚Üî Œº s = 1 :=\n  prob_compl_eq_zero_iff‚ÇÄ hs.nullMeasurableSet\n\n"}
{"name":"MeasureTheory.prob_compl_eq_one_iff‚ÇÄ","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\nhs : MeasureTheory.NullMeasurableSet s Œº\n‚ä¢ Iff (Eq (Œº (HasCompl.compl s)) 1) (Eq (Œº s) 0)","decl":"@[simp] lemma prob_compl_eq_one_iff‚ÇÄ (hs : NullMeasurableSet s Œº) : Œº s·∂ú = 1 ‚Üî Œº s = 0 := by\n  rw [‚Üê prob_compl_eq_zero_iff‚ÇÄ hs.compl, compl_compl]\n\n"}
{"name":"MeasureTheory.prob_compl_eq_one_iff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\nhs : MeasurableSet s\n‚ä¢ Iff (Eq (Œº (HasCompl.compl s)) 1) (Eq (Œº s) 0)","decl":"@[simp] lemma prob_compl_eq_one_iff (hs : MeasurableSet s) : Œº s·∂ú = 1 ‚Üî Œº s = 0 :=\n  prob_compl_eq_one_iff‚ÇÄ hs.nullMeasurableSet\n\n"}
{"name":"MeasureTheory.mem_ae_iff_prob_eq_one‚ÇÄ","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\nhs : MeasureTheory.NullMeasurableSet s Œº\n‚ä¢ Iff (Membership.mem (MeasureTheory.ae Œº) s) (Eq (Œº s) 1)","decl":"lemma mem_ae_iff_prob_eq_one‚ÇÄ (hs : NullMeasurableSet s Œº) : s ‚àà ae Œº ‚Üî Œº s = 1 :=\n  mem_ae_iff.trans <| prob_compl_eq_zero_iff‚ÇÄ hs\n\n"}
{"name":"MeasureTheory.mem_ae_iff_prob_eq_one","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\nhs : MeasurableSet s\n‚ä¢ Iff (Membership.mem (MeasureTheory.ae Œº) s) (Eq (Œº s) 1)","decl":"lemma mem_ae_iff_prob_eq_one (hs : MeasurableSet s) : s ‚àà ae Œº ‚Üî Œº s = 1 :=\n  mem_ae_iff.trans <| prob_compl_eq_zero_iff hs\n\n"}
{"name":"MeasureTheory.ae_iff_prob_eq_one","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\np : Œ± ‚Üí Prop\nhp : Measurable p\n‚ä¢ Iff (Filter.Eventually (fun a => p a) (MeasureTheory.ae Œº)) (Eq (Œº (setOf fun a => p a)) 1)","decl":"lemma ae_iff_prob_eq_one (hp : Measurable p) : (‚àÄ·µê a ‚àÇŒº, p a) ‚Üî Œº {a | p a} = 1 :=\n  mem_ae_iff_prob_eq_one hp.setOf\n\n"}
{"name":"MeasureTheory.isProbabilityMeasure_comap","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù¬π : MeasurableSpace Œ≤\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\nf : Œ≤ ‚Üí Œ±\nhf : Function.Injective f\nhf' : Filter.Eventually (fun a => Membership.mem (Set.range f) a) (MeasureTheory.ae Œº)\nhf'' : ‚àÄ (s : Set Œ≤), MeasurableSet s ‚Üí MeasurableSet (Set.image f s)\n‚ä¢ MeasureTheory.IsProbabilityMeasure (MeasureTheory.Measure.comap f Œº)","decl":"lemma isProbabilityMeasure_comap (hf : Injective f) (hf' : ‚àÄ·µê a ‚àÇŒº, a ‚àà range f)\n    (hf'' : ‚àÄ s, MeasurableSet s ‚Üí MeasurableSet (f '' s)) :\n    IsProbabilityMeasure (Œº.comap f) where\n  measure_univ := by\n    rw [comap_apply _ hf hf'' _ MeasurableSet.univ,\n      ‚Üê mem_ae_iff_prob_eq_one (hf'' _ MeasurableSet.univ)]\n    simpa\n\n"}
{"name":"MeasurableEmbedding.isProbabilityMeasure_comap","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù¬π : MeasurableSpace Œ≤\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\nf : Œ≤ ‚Üí Œ±\nhf : MeasurableEmbedding f\nhf' : Filter.Eventually (fun a => Membership.mem (Set.range f) a) (MeasureTheory.ae Œº)\n‚ä¢ MeasureTheory.IsProbabilityMeasure (MeasureTheory.Measure.comap f Œº)","decl":"protected lemma _root_.MeasurableEmbedding.isProbabilityMeasure_comap (hf : MeasurableEmbedding f)\n    (hf' : ‚àÄ·µê a ‚àÇŒº, a ‚àà range f) : IsProbabilityMeasure (Œº.comap f) :=\n  isProbabilityMeasure_comap hf.injective hf' hf.measurableSet_image'\n\n"}
{"name":"MeasureTheory.isProbabilityMeasure_map_up","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\n‚ä¢ MeasureTheory.IsProbabilityMeasure (MeasureTheory.Measure.map ULift.up Œº)","decl":"instance isProbabilityMeasure_map_up :\n    IsProbabilityMeasure (Œº.map ULift.up) := isProbabilityMeasure_map measurable_up.aemeasurable\n\n"}
{"name":"MeasureTheory.isProbabilityMeasure_comap_down","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\n‚ä¢ MeasureTheory.IsProbabilityMeasure (MeasureTheory.Measure.comap ULift.down Œº)","decl":"instance isProbabilityMeasure_comap_down : IsProbabilityMeasure (Œº.comap ULift.down) :=\n  MeasurableEquiv.ulift.measurableEmbedding.isProbabilityMeasure_comap <| ae_of_all _ <| by\n    simp [Function.Surjective.range_eq <| EquivLike.surjective _]\n\n"}
{"name":"MeasureTheory.isZeroOrProbabilityMeasureSMul","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\n‚ä¢ MeasureTheory.IsZeroOrProbabilityMeasure (HSMul.hSMul (Inv.inv (Œº Set.univ)) Œº)","decl":"instance isZeroOrProbabilityMeasureSMul :\n    IsZeroOrProbabilityMeasure ((Œº univ)‚Åª¬π ‚Ä¢ Œº) := by\n  rcases eq_zero_or_neZero Œº with rfl | h\n  ¬∑ simp; infer_instance\n  rcases eq_top_or_lt_top (Œº univ) with h | h\n  ¬∑ simp [h]; infer_instance\n  have : IsFiniteMeasure Œº := ‚ü®h‚ü©\n  infer_instance\n\n"}
{"name":"MeasureTheory.eq_zero_or_isProbabilityMeasure","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsZeroOrProbabilityMeasure Œº\n‚ä¢ Or (Eq Œº 0) (MeasureTheory.IsProbabilityMeasure Œº)","decl":"variable (Œº) in\nlemma eq_zero_or_isProbabilityMeasure : Œº = 0 ‚à® IsProbabilityMeasure Œº := by\n  rcases IsZeroOrProbabilityMeasure.measure_univ (Œº := Œº) with h | h\n  ¬∑ apply Or.inl (measure_univ_eq_zero.mp h)\n  ¬∑ exact Or.inr ‚ü®h‚ü©\n\n"}
{"name":"MeasureTheory.instIsZeroOrProbabilityMeasureMap","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù : MeasurableSpace Œ≤\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Œ≤\n‚ä¢ MeasureTheory.IsZeroOrProbabilityMeasure (MeasureTheory.Measure.map f Œº)","decl":"instance {f : Œ± ‚Üí Œ≤} : IsZeroOrProbabilityMeasure (map f Œº) := by\n  by_cases hf : AEMeasurable f Œº\n  ¬∑ simpa [isZeroOrProbabilityMeasure_iff, hf] using IsZeroOrProbabilityMeasure.measure_univ\n  ¬∑ simp [isZeroOrProbabilityMeasure_iff, hf]\n\n"}
{"name":"MeasureTheory.prob_compl_lt_one_sub_of_lt_prob","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\ninst‚úù : MeasureTheory.IsZeroOrProbabilityMeasure Œº\np : ENNReal\nhŒºs : LT.lt p (Œº s)\ns_mble : MeasurableSet s\n‚ä¢ LT.lt (Œº (HasCompl.compl s)) (HSub.hSub 1 p)","decl":"lemma prob_compl_lt_one_sub_of_lt_prob {p : ‚Ñù‚â•0‚àû} (hŒºs : p < Œº s) (s_mble : MeasurableSet s) :\n    Œº s·∂ú < 1 - p := by\n  rcases eq_zero_or_isProbabilityMeasure Œº with rfl | h\n  ¬∑ simp at hŒºs\n  ¬∑ rw [prob_compl_eq_one_sub s_mble]\n    apply ENNReal.sub_lt_of_sub_lt prob_le_one (Or.inl one_ne_top)\n    convert hŒºs\n    exact ENNReal.sub_sub_cancel one_ne_top (lt_of_lt_of_le hŒºs prob_le_one).le\n\n"}
{"name":"MeasureTheory.prob_compl_le_one_sub_of_le_prob","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\ninst‚úù : MeasureTheory.IsZeroOrProbabilityMeasure Œº\np : ENNReal\nhŒºs : LE.le p (Œº s)\ns_mble : MeasurableSet s\n‚ä¢ LE.le (Œº (HasCompl.compl s)) (HSub.hSub 1 p)","decl":"lemma prob_compl_le_one_sub_of_le_prob {p : ‚Ñù‚â•0‚àû} (hŒºs : p ‚â§ Œº s) (s_mble : MeasurableSet s) :\n    Œº s·∂ú ‚â§ 1 - p := by\n  rcases eq_zero_or_isProbabilityMeasure Œº with rfl | h\n  ¬∑ simp\n  ¬∑ simpa [prob_compl_eq_one_sub s_mble] using tsub_le_tsub_left hŒºs 1\n\n"}
{"name":"MeasureTheory.NoAtoms.measure_singleton","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nself : MeasureTheory.NoAtoms Œº\nx : Œ±\n‚ä¢ Eq (Œº (Singleton.singleton x)) 0","decl":"/-- Measure `Œº` *has no atoms* if the measure of each singleton is zero.\n\nNB: Wikipedia assumes that for any measurable set `s` with positive `Œº`-measure,\nthere exists a measurable `t ‚äÜ s` such that `0 < Œº t < Œº s`. While this implies `Œº {x} = 0`,\nthe converse is not true. -/\nclass NoAtoms {m0 : MeasurableSpace Œ±} (Œº : Measure Œ±) : Prop where\n  measure_singleton : ‚àÄ x, Œº {x} = 0\n\n"}
{"name":"Set.Subsingleton.measure_zero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\ns : Set Œ±\nhs : s.Subsingleton\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.NoAtoms Œº\n‚ä¢ Eq (Œº s) 0","decl":"theorem _root_.Set.Subsingleton.measure_zero (hs : s.Subsingleton) (Œº : Measure Œ±) [NoAtoms Œº] :\n    Œº s = 0 :=\n  hs.induction_on (p := fun s => Œº s = 0) measure_empty measure_singleton\n\n"}
{"name":"MeasureTheory.Measure.restrict_singleton'","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.NoAtoms Œº\na : Œ±\n‚ä¢ Eq (Œº.restrict (Singleton.singleton a)) 0","decl":"theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 0 := by\n  simp only [measure_singleton, Measure.restrict_eq_zero]\n\n"}
{"name":"MeasureTheory.Measure.restrict.instNoAtoms","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\n‚ä¢ MeasureTheory.NoAtoms (Œº.restrict s)","decl":"instance Measure.restrict.instNoAtoms (s : Set Œ±) : NoAtoms (Œº.restrict s) := by\n  refine ‚ü®fun x => ?_‚ü©\n  obtain ‚ü®t, hxt, ht1, ht2‚ü© := exists_measurable_superset_of_null (measure_singleton x : Œº {x} = 0)\n  apply measure_mono_null hxt\n  rw [Measure.restrict_apply ht1]\n  apply measure_mono_null inter_subset_left ht2\n\n"}
{"name":"Set.Countable.measure_zero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\ns : Set Œ±\nh : s.Countable\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.NoAtoms Œº\n‚ä¢ Eq (Œº s) 0","decl":"theorem _root_.Set.Countable.measure_zero (h : s.Countable) (Œº : Measure Œ±) [NoAtoms Œº] :\n    Œº s = 0 := by\n  rw [‚Üê biUnion_of_singleton s, measure_biUnion_null_iff h]\n  simp\n\n"}
{"name":"Set.Countable.ae_not_mem","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\ns : Set Œ±\nh : s.Countable\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.NoAtoms Œº\n‚ä¢ Filter.Eventually (fun x => Not (Membership.mem s x)) (MeasureTheory.ae Œº)","decl":"theorem _root_.Set.Countable.ae_not_mem (h : s.Countable) (Œº : Measure Œ±) [NoAtoms Œº] :\n    ‚àÄ·µê x ‚àÇŒº, x ‚àâ s := by\n  simpa only [ae_iff, Classical.not_not] using h.measure_zero Œº\n\n"}
{"name":"Set.Countable.measure_restrict_compl","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\ns : Set Œ±\nh : s.Countable\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.NoAtoms Œº\n‚ä¢ Eq (Œº.restrict (HasCompl.compl s)) Œº","decl":"lemma _root_.Set.Countable.measure_restrict_compl (h : s.Countable) (Œº : Measure Œ±) [NoAtoms Œº] :\n    Œº.restrict s·∂ú = Œº :=\n  restrict_eq_self_of_ae_mem <| h.ae_not_mem Œº\n\n"}
{"name":"MeasureTheory.restrict_compl_singleton","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.NoAtoms Œº\na : Œ±\n‚ä¢ Eq (Œº.restrict (HasCompl.compl (Singleton.singleton a))) Œº","decl":"@[simp]\nlemma restrict_compl_singleton (a : Œ±) : Œº.restrict ({a}·∂ú) = Œº :=\n  (countable_singleton _).measure_restrict_compl Œº\n\n"}
{"name":"Set.Finite.measure_zero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\ns : Set Œ±\nh : s.Finite\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.NoAtoms Œº\n‚ä¢ Eq (Œº s) 0","decl":"theorem _root_.Set.Finite.measure_zero (h : s.Finite) (Œº : Measure Œ±) [NoAtoms Œº] : Œº s = 0 :=\n  h.countable.measure_zero Œº\n\n"}
{"name":"Finset.measure_zero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\ns : Finset Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.NoAtoms Œº\n‚ä¢ Eq (Œº ‚Üës) 0","decl":"theorem _root_.Finset.measure_zero (s : Finset Œ±) (Œº : Measure Œ±) [NoAtoms Œº] : Œº s = 0 :=\n  s.finite_toSet.measure_zero Œº\n\n"}
{"name":"MeasureTheory.insert_ae_eq_self","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.NoAtoms Œº\na : Œ±\ns : Set Œ±\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (Insert.insert a s) s","decl":"theorem insert_ae_eq_self (a : Œ±) (s : Set Œ±) : (insert a s : Set Œ±) =·µê[Œº] s :=\n  union_ae_eq_right.2 <| measure_mono_null diff_subset (measure_singleton _)\n\n"}
{"name":"MeasureTheory.Iio_ae_eq_Iic","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.NoAtoms Œº\ninst‚úù : PartialOrder Œ±\na : Œ±\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (Set.Iio a) (Set.Iic a)","decl":"theorem Iio_ae_eq_Iic : Iio a =·µê[Œº] Iic a :=\n  Iio_ae_eq_Iic' (measure_singleton a)\n\n"}
{"name":"MeasureTheory.Ioi_ae_eq_Ici","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.NoAtoms Œº\ninst‚úù : PartialOrder Œ±\na : Œ±\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (Set.Ioi a) (Set.Ici a)","decl":"theorem Ioi_ae_eq_Ici : Ioi a =·µê[Œº] Ici a :=\n  Ioi_ae_eq_Ici' (measure_singleton a)\n\n"}
{"name":"MeasureTheory.Ioo_ae_eq_Ioc","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.NoAtoms Œº\ninst‚úù : PartialOrder Œ±\na b : Œ±\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (Set.Ioo a b) (Set.Ioc a b)","decl":"theorem Ioo_ae_eq_Ioc : Ioo a b =·µê[Œº] Ioc a b :=\n  Ioo_ae_eq_Ioc' (measure_singleton b)\n\n"}
{"name":"MeasureTheory.Ioc_ae_eq_Icc","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.NoAtoms Œº\ninst‚úù : PartialOrder Œ±\na b : Œ±\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (Set.Ioc a b) (Set.Icc a b)","decl":"theorem Ioc_ae_eq_Icc : Ioc a b =·µê[Œº] Icc a b :=\n  Ioc_ae_eq_Icc' (measure_singleton a)\n\n"}
{"name":"MeasureTheory.Ioo_ae_eq_Ico","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.NoAtoms Œº\ninst‚úù : PartialOrder Œ±\na b : Œ±\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (Set.Ioo a b) (Set.Ico a b)","decl":"theorem Ioo_ae_eq_Ico : Ioo a b =·µê[Œº] Ico a b :=\n  Ioo_ae_eq_Ico' (measure_singleton a)\n\n"}
{"name":"MeasureTheory.Ioo_ae_eq_Icc","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.NoAtoms Œº\ninst‚úù : PartialOrder Œ±\na b : Œ±\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (Set.Ioo a b) (Set.Icc a b)","decl":"theorem Ioo_ae_eq_Icc : Ioo a b =·µê[Œº] Icc a b :=\n  Ioo_ae_eq_Icc' (measure_singleton a) (measure_singleton b)\n\n"}
{"name":"MeasureTheory.Ico_ae_eq_Icc","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.NoAtoms Œº\ninst‚úù : PartialOrder Œ±\na b : Œ±\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (Set.Ico a b) (Set.Icc a b)","decl":"theorem Ico_ae_eq_Icc : Ico a b =·µê[Œº] Icc a b :=\n  Ico_ae_eq_Icc' (measure_singleton b)\n\n"}
{"name":"MeasureTheory.Ico_ae_eq_Ioc","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.NoAtoms Œº\ninst‚úù : PartialOrder Œ±\na b : Œ±\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (Set.Ico a b) (Set.Ioc a b)","decl":"theorem Ico_ae_eq_Ioc : Ico a b =·µê[Œº] Ioc a b :=\n  Ico_ae_eq_Ioc' (measure_singleton a) (measure_singleton b)\n\n"}
{"name":"MeasureTheory.restrict_Iio_eq_restrict_Iic","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.NoAtoms Œº\ninst‚úù : PartialOrder Œ±\na : Œ±\n‚ä¢ Eq (Œº.restrict (Set.Iio a)) (Œº.restrict (Set.Iic a))","decl":"theorem restrict_Iio_eq_restrict_Iic : Œº.restrict (Iio a) = Œº.restrict (Iic a) :=\n  restrict_congr_set Iio_ae_eq_Iic\n\n"}
{"name":"MeasureTheory.restrict_Ioi_eq_restrict_Ici","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.NoAtoms Œº\ninst‚úù : PartialOrder Œ±\na : Œ±\n‚ä¢ Eq (Œº.restrict (Set.Ioi a)) (Œº.restrict (Set.Ici a))","decl":"theorem restrict_Ioi_eq_restrict_Ici : Œº.restrict (Ioi a) = Œº.restrict (Ici a) :=\n  restrict_congr_set Ioi_ae_eq_Ici\n\n"}
{"name":"MeasureTheory.restrict_Ioo_eq_restrict_Ioc","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.NoAtoms Œº\ninst‚úù : PartialOrder Œ±\na b : Œ±\n‚ä¢ Eq (Œº.restrict (Set.Ioo a b)) (Œº.restrict (Set.Ioc a b))","decl":"theorem restrict_Ioo_eq_restrict_Ioc : Œº.restrict (Ioo a b) = Œº.restrict (Ioc a b) :=\n  restrict_congr_set Ioo_ae_eq_Ioc\n\n"}
{"name":"MeasureTheory.restrict_Ioc_eq_restrict_Icc","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.NoAtoms Œº\ninst‚úù : PartialOrder Œ±\na b : Œ±\n‚ä¢ Eq (Œº.restrict (Set.Ioc a b)) (Œº.restrict (Set.Icc a b))","decl":"theorem restrict_Ioc_eq_restrict_Icc : Œº.restrict (Ioc a b) = Œº.restrict (Icc a b) :=\n  restrict_congr_set Ioc_ae_eq_Icc\n\n"}
{"name":"MeasureTheory.restrict_Ioo_eq_restrict_Ico","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.NoAtoms Œº\ninst‚úù : PartialOrder Œ±\na b : Œ±\n‚ä¢ Eq (Œº.restrict (Set.Ioo a b)) (Œº.restrict (Set.Ico a b))","decl":"theorem restrict_Ioo_eq_restrict_Ico : Œº.restrict (Ioo a b) = Œº.restrict (Ico a b) :=\n  restrict_congr_set Ioo_ae_eq_Ico\n\n"}
{"name":"MeasureTheory.restrict_Ioo_eq_restrict_Icc","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.NoAtoms Œº\ninst‚úù : PartialOrder Œ±\na b : Œ±\n‚ä¢ Eq (Œº.restrict (Set.Ioo a b)) (Œº.restrict (Set.Icc a b))","decl":"theorem restrict_Ioo_eq_restrict_Icc : Œº.restrict (Ioo a b) = Œº.restrict (Icc a b) :=\n  restrict_congr_set Ioo_ae_eq_Icc\n\n"}
{"name":"MeasureTheory.restrict_Ico_eq_restrict_Icc","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.NoAtoms Œº\ninst‚úù : PartialOrder Œ±\na b : Œ±\n‚ä¢ Eq (Œº.restrict (Set.Ico a b)) (Œº.restrict (Set.Icc a b))","decl":"theorem restrict_Ico_eq_restrict_Icc : Œº.restrict (Ico a b) = Œº.restrict (Icc a b) :=\n  restrict_congr_set Ico_ae_eq_Icc\n\n"}
{"name":"MeasureTheory.restrict_Ico_eq_restrict_Ioc","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.NoAtoms Œº\ninst‚úù : PartialOrder Œ±\na b : Œ±\n‚ä¢ Eq (Œº.restrict (Set.Ico a b)) (Œº.restrict (Set.Ioc a b))","decl":"theorem restrict_Ico_eq_restrict_Ioc : Œº.restrict (Ico a b) = Œº.restrict (Ioc a b) :=\n  restrict_congr_set Ico_ae_eq_Ioc\n\n"}
{"name":"MeasureTheory.uIoc_ae_eq_interval","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.NoAtoms Œº\ninst‚úù : LinearOrder Œ±\na b : Œ±\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (Set.uIoc a b) (Set.uIcc a b)","decl":"theorem uIoc_ae_eq_interval [LinearOrder Œ±] {a b : Œ±} : Œô a b =·µê[Œº] [[a, b]] :=\n  Ioc_ae_eq_Icc\n\n"}
{"name":"MeasureTheory.ite_ae_eq_of_measure_zero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≥ : Type u_5\nf g : Œ± ‚Üí Œ≥\ns : Set Œ±\ninst‚úù : DecidablePred fun x => Membership.mem s x\nhs_zero : Eq (Œº s) 0\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (fun x => ite (Membership.mem s x) (f x) (g x)) g","decl":"theorem ite_ae_eq_of_measure_zero {Œ≥} (f : Œ± ‚Üí Œ≥) (g : Œ± ‚Üí Œ≥) (s : Set Œ±) [DecidablePred (¬∑ ‚àà s)]\n    (hs_zero : Œº s = 0) :\n    (fun x => ite (x ‚àà s) (f x) (g x)) =·µê[Œº] g := by\n  have h_ss : s·∂ú ‚äÜ { a : Œ± | ite (a ‚àà s) (f a) (g a) = g a } := fun x hx => by\n    simp [(Set.mem_compl_iff _ _).mp hx]\n  refine measure_mono_null ?_ hs_zero\n  conv_rhs => rw [‚Üê compl_compl s]\n  rwa [Set.compl_subset_compl]\n\n"}
{"name":"MeasureTheory.ite_ae_eq_of_measure_compl_zero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≥ : Type u_5\nf g : Œ± ‚Üí Œ≥\ns : Set Œ±\ninst‚úù : DecidablePred fun x => Membership.mem s x\nhs_zero : Eq (Œº (HasCompl.compl s)) 0\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (fun x => ite (Membership.mem s x) (f x) (g x)) f","decl":"theorem ite_ae_eq_of_measure_compl_zero {Œ≥} (f : Œ± ‚Üí Œ≥) (g : Œ± ‚Üí Œ≥)\n    (s : Set Œ±) [DecidablePred (¬∑ ‚àà s)] (hs_zero : Œº s·∂ú = 0) :\n    (fun x => ite (x ‚àà s) (f x) (g x)) =·µê[Œº] f := by\n  rw [‚Üê mem_ae_iff] at hs_zero\n  filter_upwards [hs_zero]\n  intros\n  split_ifs\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.finiteAtFilter_of_finite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\n_m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nf : Filter Œ±\n‚ä¢ Œº.FiniteAtFilter f","decl":"theorem finiteAtFilter_of_finite {_m0 : MeasurableSpace Œ±} (Œº : Measure Œ±) [IsFiniteMeasure Œº]\n    (f : Filter Œ±) : Œº.FiniteAtFilter f :=\n  ‚ü®univ, univ_mem, measure_lt_top Œº univ‚ü©\n\n"}
{"name":"MeasureTheory.Measure.FiniteAtFilter.exists_mem_basis","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Filter Œ±\nhŒº : Œº.FiniteAtFilter f\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set Œ±\nhf : f.HasBasis p s\n‚ä¢ Exists fun i => And (p i) (LT.lt (Œº (s i)) Top.top)","decl":"theorem FiniteAtFilter.exists_mem_basis {f : Filter Œ±} (hŒº : FiniteAtFilter Œº f) {p : Œπ ‚Üí Prop}\n    {s : Œπ ‚Üí Set Œ±} (hf : f.HasBasis p s) : ‚àÉ i, p i ‚àß Œº (s i) < ‚àû :=\n  (hf.exists_iff fun {_s _t} hst ht => (measure_mono hst).trans_lt ht).1 hŒº\n\n"}
{"name":"MeasureTheory.Measure.finiteAtBot","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\n‚ä¢ Œº.FiniteAtFilter Bot.bot","decl":"theorem finiteAtBot {m0 : MeasurableSpace Œ±} (Œº : Measure Œ±) : Œº.FiniteAtFilter ‚ä• :=\n  ‚ü®‚àÖ, mem_bot, by simp only [measure_empty, zero_lt_top]‚ü©\n\n"}
{"name":"MeasureTheory.Measure.FiniteSpanningSetsIn.mk.injEq","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nC : Set (Set Œ±)\nset‚úù : Nat ‚Üí Set Œ±\nset_mem‚úù : ‚àÄ (i : Nat), Membership.mem C (set‚úù i)\nfinite‚úù : ‚àÄ (i : Nat), LT.lt (Œº (set‚úù i)) Top.top\nspanning‚úù : Eq (Set.iUnion fun i => set‚úù i) Set.univ\nset : Nat ‚Üí Set Œ±\nset_mem : ‚àÄ (i : Nat), Membership.mem C (set i)\nfinite : ‚àÄ (i : Nat), LT.lt (Œº (set i)) Top.top\nspanning : Eq (Set.iUnion fun i => set i) Set.univ\n‚ä¢ Eq (Eq { set := set‚úù, set_mem := set_mem‚úù, finite := finite‚úù, spanning := spanning‚úù } { set := set, set_mem := set_mem, finite := finite, spanning := spanning }) (Eq set‚úù set)","decl":"/-- `Œº` has finite spanning sets in `C` if there is a countable sequence of sets in `C` that have\n  finite measures. This structure is a type, which is useful if we want to record extra properties\n  about the sets, such as that they are monotone.\n  `SigmaFinite` is defined in terms of this: `Œº` is œÉ-finite if there exists a sequence of\n  finite spanning sets in the collection of all measurable sets. -/\nstructure FiniteSpanningSetsIn {m0 : MeasurableSpace Œ±} (Œº : Measure Œ±) (C : Set (Set Œ±)) where\n  protected set : ‚Ñï ‚Üí Set Œ±\n  protected set_mem : ‚àÄ i, set i ‚àà C\n  protected finite : ‚àÄ i, Œº (set i) < ‚àû\n  protected spanning : ‚ãÉ i, set i = univ\n\n"}
{"name":"MeasureTheory.Measure.FiniteSpanningSetsIn.mk.sizeOf_spec","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nC : Set (Set Œ±)\ninst‚úù¬π : SizeOf Œ±\ninst‚úù : (a : Set Œ±) ‚Üí SizeOf (C a)\nset : Nat ‚Üí Set Œ±\nset_mem : ‚àÄ (i : Nat), Membership.mem C (set i)\nfinite : ‚àÄ (i : Nat), LT.lt (Œº (set i)) Top.top\nspanning : Eq (Set.iUnion fun i => set i) Set.univ\n‚ä¢ Eq (SizeOf.sizeOf { set := set, set_mem := set_mem, finite := finite, spanning := spanning }) (HAdd.hAdd 1 (SizeOf.sizeOf spanning))","decl":"/-- `Œº` has finite spanning sets in `C` if there is a countable sequence of sets in `C` that have\n  finite measures. This structure is a type, which is useful if we want to record extra properties\n  about the sets, such as that they are monotone.\n  `SigmaFinite` is defined in terms of this: `Œº` is œÉ-finite if there exists a sequence of\n  finite spanning sets in the collection of all measurable sets. -/\nstructure FiniteSpanningSetsIn {m0 : MeasurableSpace Œ±} (Œº : Measure Œ±) (C : Set (Set Œ±)) where\n  protected set : ‚Ñï ‚Üí Set Œ±\n  protected set_mem : ‚àÄ i, set i ‚àà C\n  protected finite : ‚àÄ i, Œº (set i) < ‚àû\n  protected spanning : ‚ãÉ i, set i = univ\n\n"}
{"name":"MeasureTheory.Measure.FiniteSpanningSetsIn.mk.inj","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nC : Set (Set Œ±)\nset‚úù : Nat ‚Üí Set Œ±\nset_mem‚úù : ‚àÄ (i : Nat), Membership.mem C (set‚úù i)\nfinite‚úù : ‚àÄ (i : Nat), LT.lt (Œº (set‚úù i)) Top.top\nspanning‚úù : Eq (Set.iUnion fun i => set‚úù i) Set.univ\nset : Nat ‚Üí Set Œ±\nset_mem : ‚àÄ (i : Nat), Membership.mem C (set i)\nfinite : ‚àÄ (i : Nat), LT.lt (Œº (set i)) Top.top\nspanning : Eq (Set.iUnion fun i => set i) Set.univ\nx‚úù : Eq { set := set‚úù, set_mem := set_mem‚úù, finite := finite‚úù, spanning := spanning‚úù } { set := set, set_mem := set_mem, finite := finite, spanning := spanning }\n‚ä¢ Eq set‚úù set","decl":"/-- `Œº` has finite spanning sets in `C` if there is a countable sequence of sets in `C` that have\n  finite measures. This structure is a type, which is useful if we want to record extra properties\n  about the sets, such as that they are monotone.\n  `SigmaFinite` is defined in terms of this: `Œº` is œÉ-finite if there exists a sequence of\n  finite spanning sets in the collection of all measurable sets. -/\nstructure FiniteSpanningSetsIn {m0 : MeasurableSpace Œ±} (Œº : Measure Œ±) (C : Set (Set Œ±)) where\n  protected set : ‚Ñï ‚Üí Set Œ±\n  protected set_mem : ‚àÄ i, set i ‚àà C\n  protected finite : ‚àÄ i, Œº (set i) < ‚àû\n  protected spanning : ‚ãÉ i, set i = univ\n\n"}
{"name":"MeasureTheory.Measure.FiniteSpanningSetsIn.set_mem","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nC : Set (Set Œ±)\nself : Œº.FiniteSpanningSetsIn C\ni : Nat\n‚ä¢ Membership.mem C (self.set i)","decl":"/-- `Œº` has finite spanning sets in `C` if there is a countable sequence of sets in `C` that have\n  finite measures. This structure is a type, which is useful if we want to record extra properties\n  about the sets, such as that they are monotone.\n  `SigmaFinite` is defined in terms of this: `Œº` is œÉ-finite if there exists a sequence of\n  finite spanning sets in the collection of all measurable sets. -/\nstructure FiniteSpanningSetsIn {m0 : MeasurableSpace Œ±} (Œº : Measure Œ±) (C : Set (Set Œ±)) where\n  protected set : ‚Ñï ‚Üí Set Œ±\n  protected set_mem : ‚àÄ i, set i ‚àà C\n  protected finite : ‚àÄ i, Œº (set i) < ‚àû\n  protected spanning : ‚ãÉ i, set i = univ\n\n"}
{"name":"MeasureTheory.Measure.FiniteSpanningSetsIn.spanning","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nC : Set (Set Œ±)\nself : Œº.FiniteSpanningSetsIn C\n‚ä¢ Eq (Set.iUnion fun i => self.set i) Set.univ","decl":"/-- `Œº` has finite spanning sets in `C` if there is a countable sequence of sets in `C` that have\n  finite measures. This structure is a type, which is useful if we want to record extra properties\n  about the sets, such as that they are monotone.\n  `SigmaFinite` is defined in terms of this: `Œº` is œÉ-finite if there exists a sequence of\n  finite spanning sets in the collection of all measurable sets. -/\nstructure FiniteSpanningSetsIn {m0 : MeasurableSpace Œ±} (Œº : Measure Œ±) (C : Set (Set Œ±)) where\n  protected set : ‚Ñï ‚Üí Set Œ±\n  protected set_mem : ‚àÄ i, set i ‚àà C\n  protected finite : ‚àÄ i, Œº (set i) < ‚àû\n  protected spanning : ‚ãÉ i, set i = univ\n\n"}
{"name":"MeasureTheory.Measure.FiniteSpanningSetsIn.finite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nC : Set (Set Œ±)\nself : Œº.FiniteSpanningSetsIn C\ni : Nat\n‚ä¢ LT.lt (Œº (self.set i)) Top.top","decl":"/-- `Œº` has finite spanning sets in `C` if there is a countable sequence of sets in `C` that have\n  finite measures. This structure is a type, which is useful if we want to record extra properties\n  about the sets, such as that they are monotone.\n  `SigmaFinite` is defined in terms of this: `Œº` is œÉ-finite if there exists a sequence of\n  finite spanning sets in the collection of all measurable sets. -/\nstructure FiniteSpanningSetsIn {m0 : MeasurableSpace Œ±} (Œº : Measure Œ±) (C : Set (Set Œ±)) where\n  protected set : ‚Ñï ‚Üí Set Œ±\n  protected set_mem : ‚àÄ i, set i ‚àà C\n  protected finite : ‚àÄ i, Œº (set i) < ‚àû\n  protected spanning : ‚ãÉ i, set i = univ\n\n"}
{"name":"MeasureTheory.SFinite.out'","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nself : MeasureTheory.SFinite Œº\n‚ä¢ Exists fun m => And (‚àÄ (n : Nat), MeasureTheory.IsFiniteMeasure (m n)) (Eq Œº (MeasureTheory.Measure.sum m))","decl":"/-- A measure is called s-finite if it is a countable sum of finite measures. -/\nclass SFinite (Œº : Measure Œ±) : Prop where\n  out' : ‚àÉ m : ‚Ñï ‚Üí Measure Œ±, (‚àÄ n, IsFiniteMeasure (m n)) ‚àß Œº = Measure.sum m\n\n"}
{"name":"MeasureTheory.isFiniteMeasure_sfiniteSeq","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nh : MeasureTheory.SFinite Œº\nn : Nat\n‚ä¢ MeasureTheory.IsFiniteMeasure (MeasureTheory.sfiniteSeq Œº n)","decl":"instance isFiniteMeasure_sfiniteSeq [h : SFinite Œº] (n : ‚Ñï) : IsFiniteMeasure (sfiniteSeq Œº n) :=\n  h.1.choose_spec.1 n\n\n"}
{"name":"MeasureTheory.isFiniteMeasure_sFiniteSeq","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SFinite Œº\nn : Nat\n‚ä¢ MeasureTheory.IsFiniteMeasure (MeasureTheory.sFiniteSeq Œº n)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\" (since := \"2024-10-11\")]\ninstance isFiniteMeasure_sFiniteSeq [SFinite Œº] (n : ‚Ñï) : IsFiniteMeasure (sFiniteSeq Œº n) :=\n  isFiniteMeasure_sfiniteSeq n\n\n"}
{"name":"MeasureTheory.sum_sfiniteSeq","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nh : MeasureTheory.SFinite Œº\n‚ä¢ Eq (MeasureTheory.Measure.sum (MeasureTheory.sfiniteSeq Œº)) Œº","decl":"lemma sum_sfiniteSeq (Œº : Measure Œ±) [h : SFinite Œº] : sum (sfiniteSeq Œº) = Œº :=\n  h.1.choose_spec.2.symm\n\n"}
{"name":"MeasureTheory.sum_sFiniteSeq","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nh : MeasureTheory.SFinite Œº\n‚ä¢ Eq (MeasureTheory.Measure.sum (MeasureTheory.sfiniteSeq Œº)) Œº","decl":"@[deprecated (since := \"2024-10-11\")] alias sum_sFiniteSeq := sum_sfiniteSeq\n\n"}
{"name":"MeasureTheory.sfiniteSeq_le","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SFinite Œº\nn : Nat\n‚ä¢ LE.le (MeasureTheory.sfiniteSeq Œº n) Œº","decl":"lemma sfiniteSeq_le (Œº : Measure Œ±) [SFinite Œº] (n : ‚Ñï) : sfiniteSeq Œº n ‚â§ Œº :=\n  (le_sum _ n).trans (sum_sfiniteSeq Œº).le\n\n"}
{"name":"MeasureTheory.sFiniteSeq_le","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SFinite Œº\nn : Nat\n‚ä¢ LE.le (MeasureTheory.sfiniteSeq Œº n) Œº","decl":"@[deprecated (since := \"2024-10-11\")] alias sFiniteSeq_le := sfiniteSeq_le\n\n"}
{"name":"MeasureTheory.instSFiniteOfNatMeasure","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\n‚ä¢ MeasureTheory.SFinite 0","decl":"instance : SFinite (0 : Measure Œ±) := ‚ü®fun _ ‚Ü¶ 0, inferInstance, by rw [Measure.sum_zero]‚ü©\n\n"}
{"name":"MeasureTheory.sfiniteSeq_zero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nn : Nat\n‚ä¢ Eq (MeasureTheory.sfiniteSeq 0 n) 0","decl":"@[simp]\nlemma sfiniteSeq_zero (n : ‚Ñï) : sfiniteSeq (0 : Measure Œ±) n = 0 :=\n  bot_unique <| sfiniteSeq_le _ _\n\n"}
{"name":"MeasureTheory.sFiniteSeq_zero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nn : Nat\n‚ä¢ Eq (MeasureTheory.sfiniteSeq 0 n) 0","decl":"@[deprecated (since := \"2024-10-11\")] alias sFiniteSeq_zero := sfiniteSeq_zero\n\n"}
{"name":"MeasureTheory.sfinite_sum_of_countable","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\nm0 : MeasurableSpace Œ±\ninst‚úù¬π : Countable Œπ\nm : Œπ ‚Üí MeasureTheory.Measure Œ±\ninst‚úù : ‚àÄ (n : Œπ), MeasureTheory.IsFiniteMeasure (m n)\n‚ä¢ MeasureTheory.SFinite (MeasureTheory.Measure.sum m)","decl":"/-- A countable sum of finite measures is s-finite.\nThis lemma is superseded by the instance below. -/\nlemma sfinite_sum_of_countable [Countable Œπ]\n    (m : Œπ ‚Üí Measure Œ±) [‚àÄ n, IsFiniteMeasure (m n)] : SFinite (Measure.sum m) := by\n  classical\n  obtain ‚ü®f, hf‚ü© : ‚àÉ f : Œπ ‚Üí ‚Ñï, Function.Injective f := Countable.exists_injective_nat Œπ\n  refine ‚ü®_, fun n ‚Ü¶ ?_, (sum_extend_zero hf m).symm‚ü©\n  rcases em (n ‚àà range f) with ‚ü®i, rfl‚ü© | hn\n  ¬∑ rw [hf.extend_apply]\n    infer_instance\n  ¬∑ rw [Function.extend_apply' _ _ _ hn, Pi.zero_apply]\n    infer_instance\n\n"}
{"name":"MeasureTheory.instSFiniteSumOfCountable","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\nm0 : MeasurableSpace Œ±\ninst‚úù¬π : Countable Œπ\nm : Œπ ‚Üí MeasureTheory.Measure Œ±\ninst‚úù : ‚àÄ (n : Œπ), MeasureTheory.SFinite (m n)\n‚ä¢ MeasureTheory.SFinite (MeasureTheory.Measure.sum m)","decl":"instance [Countable Œπ] (m : Œπ ‚Üí Measure Œ±) [‚àÄ n, SFinite (m n)] : SFinite (Measure.sum m) := by\n  change SFinite (Measure.sum (fun i ‚Ü¶ m i))\n  simp_rw [‚Üê sum_sfiniteSeq (m _), Measure.sum_sum]\n  apply sfinite_sum_of_countable\n\n"}
{"name":"MeasureTheory.instSFiniteHAddMeasure","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº ŒΩ : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.SFinite Œº\ninst‚úù : MeasureTheory.SFinite ŒΩ\n‚ä¢ MeasureTheory.SFinite (HAdd.hAdd Œº ŒΩ)","decl":"instance [SFinite Œº] [SFinite ŒΩ] : SFinite (Œº + ŒΩ) := by\n  have : ‚àÄ b : Bool, SFinite (cond b Œº ŒΩ) := by simp [*]\n  simpa using inferInstanceAs (SFinite (.sum (cond ¬∑ Œº ŒΩ)))\n\n"}
{"name":"MeasureTheory.instSFiniteRestrict","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SFinite Œº\ns : Set Œ±\n‚ä¢ MeasureTheory.SFinite (Œº.restrict s)","decl":"instance [SFinite Œº] (s : Set Œ±) : SFinite (Œº.restrict s) :=\n  ‚ü®fun n ‚Ü¶ (sfiniteSeq Œº n).restrict s, fun n ‚Ü¶ inferInstance,\n    by rw [‚Üê restrict_sum_of_countable, sum_sfiniteSeq]‚ü©\n\n"}
{"name":"MeasureTheory.exists_isFiniteMeasure_absolutelyContinuous","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SFinite Œº\n‚ä¢ Exists fun ŒΩ => And (MeasureTheory.IsFiniteMeasure ŒΩ) (And (Œº.AbsolutelyContinuous ŒΩ) (ŒΩ.AbsolutelyContinuous Œº))","decl":"variable (Œº) in\n/-- For an s-finite measure `Œº`, there exists a finite measure `ŒΩ`\nsuch that each of `Œº` and `ŒΩ` is absolutely continuous with respect to the other.\n-/\ntheorem exists_isFiniteMeasure_absolutelyContinuous [SFinite Œº] :\n    ‚àÉ ŒΩ : Measure Œ±, IsFiniteMeasure ŒΩ ‚àß Œº ‚â™ ŒΩ ‚àß ŒΩ ‚â™ Œº := by\n  rcases ENNReal.exists_pos_tsum_mul_lt_of_countable top_ne_zero (sfiniteSeq Œº ¬∑ univ)\n    fun _ ‚Ü¶ measure_ne_top _ _ with ‚ü®c, hc‚ÇÄ, hc‚ü©\n  have {s : Set Œ±} : sum (fun n ‚Ü¶ c n ‚Ä¢ sfiniteSeq Œº n) s = 0 ‚Üî Œº s = 0 := by\n    conv_rhs => rw [‚Üê sum_sfiniteSeq Œº, sum_apply_of_countable]\n    simp [(hc‚ÇÄ _).ne']\n  refine ‚ü®.sum fun n ‚Ü¶ c n ‚Ä¢ sfiniteSeq Œº n, ‚ü®?_‚ü©, fun _ ‚Ü¶ this.1, fun _ ‚Ü¶ this.2‚ü©\n  simpa [mul_comm] using hc\n\n"}
{"name":"MeasureTheory.exists_absolutelyContinuous_isFiniteMeasure","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SFinite Œº\n‚ä¢ Exists fun ŒΩ => And (MeasureTheory.IsFiniteMeasure ŒΩ) (Œº.AbsolutelyContinuous ŒΩ)","decl":"variable (Œº) in\n@[deprecated exists_isFiniteMeasure_absolutelyContinuous (since := \"2024-08-25\")]\ntheorem exists_absolutelyContinuous_isFiniteMeasure [SFinite Œº] :\n    ‚àÉ ŒΩ : Measure Œ±, IsFiniteMeasure ŒΩ ‚àß Œº ‚â™ ŒΩ :=\n  let ‚ü®ŒΩ, hfin, h, _‚ü© := exists_isFiniteMeasure_absolutelyContinuous Œº; ‚ü®ŒΩ, hfin, h‚ü©\n\n"}
{"name":"MeasureTheory.SigmaFinite.out'","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nself : MeasureTheory.SigmaFinite Œº\n‚ä¢ Nonempty (Œº.FiniteSpanningSetsIn Set.univ)","decl":"/-- A measure `Œº` is called œÉ-finite if there is a countable collection of sets\n `{ A i | i ‚àà ‚Ñï }` such that `Œº (A i) < ‚àû` and `‚ãÉ i, A i = s`. -/\nclass SigmaFinite {m0 : MeasurableSpace Œ±} (Œº : Measure Œ±) : Prop where\n  out' : Nonempty (Œº.FiniteSpanningSetsIn univ)\n\n"}
{"name":"MeasureTheory.sigmaFinite_iff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\n‚ä¢ Iff (MeasureTheory.SigmaFinite Œº) (Nonempty (Œº.FiniteSpanningSetsIn Set.univ))","decl":"theorem sigmaFinite_iff : SigmaFinite Œº ‚Üî Nonempty (Œº.FiniteSpanningSetsIn univ) :=\n  ‚ü®fun h => h.1, fun h => ‚ü®h‚ü©‚ü©\n\n"}
{"name":"MeasureTheory.SigmaFinite.out","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nh : MeasureTheory.SigmaFinite Œº\n‚ä¢ Nonempty (Œº.FiniteSpanningSetsIn Set.univ)","decl":"theorem SigmaFinite.out (h : SigmaFinite Œº) : Nonempty (Œº.FiniteSpanningSetsIn univ) :=\n  h.1\n\n"}
{"name":"MeasureTheory.monotone_spanningSets","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\n‚ä¢ Monotone (MeasureTheory.spanningSets Œº)","decl":"theorem monotone_spanningSets (Œº : Measure Œ±) [SigmaFinite Œº] : Monotone (spanningSets Œº) :=\n  monotone_accumulate\n\n"}
{"name":"MeasureTheory.spanningSets_mono","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\nm n : Nat\nhmn : LE.le m n\n‚ä¢ HasSubset.Subset (MeasureTheory.spanningSets Œº m) (MeasureTheory.spanningSets Œº n)","decl":"@[gcongr]\nlemma spanningSets_mono [SigmaFinite Œº] {m n : ‚Ñï} (hmn : m ‚â§ n) :\n    spanningSets Œº m ‚äÜ spanningSets Œº n := monotone_spanningSets _ hmn\n\n"}
{"name":"MeasureTheory.measurableSet_spanningSets","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\ni : Nat\n‚ä¢ MeasurableSet (MeasureTheory.spanningSets Œº i)","decl":"theorem measurableSet_spanningSets (Œº : Measure Œ±) [SigmaFinite Œº] (i : ‚Ñï) :\n    MeasurableSet (spanningSets Œº i) :=\n  MeasurableSet.iUnion fun j => MeasurableSet.iUnion fun _ => Œº.toFiniteSpanningSetsIn.set_mem j\n\n"}
{"name":"MeasureTheory.measurable_spanningSets","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\ni : Nat\n‚ä¢ MeasurableSet (MeasureTheory.spanningSets Œº i)","decl":"@[deprecated (since := \"2024-10-16\")] alias measurable_spanningSets := measurableSet_spanningSets\n\n"}
{"name":"MeasureTheory.measure_spanningSets_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\ni : Nat\n‚ä¢ LT.lt (Œº (MeasureTheory.spanningSets Œº i)) Top.top","decl":"theorem measure_spanningSets_lt_top (Œº : Measure Œ±) [SigmaFinite Œº] (i : ‚Ñï) :\n    Œº (spanningSets Œº i) < ‚àû :=\n  measure_biUnion_lt_top (finite_le_nat i) fun j _ => Œº.toFiniteSpanningSetsIn.finite j\n\n"}
{"name":"MeasureTheory.iUnion_spanningSets","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\n‚ä¢ Eq (Set.iUnion fun i => MeasureTheory.spanningSets Œº i) Set.univ","decl":"@[simp]\ntheorem iUnion_spanningSets (Œº : Measure Œ±) [SigmaFinite Œº] : ‚ãÉ i : ‚Ñï, spanningSets Œº i = univ := by\n  simp_rw [spanningSets, iUnion_accumulate, Œº.toFiniteSpanningSetsIn.spanning]\n\n"}
{"name":"MeasureTheory.isCountablySpanning_spanningSets","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\n‚ä¢ IsCountablySpanning (Set.range (MeasureTheory.spanningSets Œº))","decl":"theorem isCountablySpanning_spanningSets (Œº : Measure Œ±) [SigmaFinite Œº] :\n    IsCountablySpanning (range (spanningSets Œº)) :=\n  ‚ü®spanningSets Œº, mem_range_self, iUnion_spanningSets Œº‚ü©\n\n"}
{"name":"MeasureTheory.measurableSet_spanningSetsIndex","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\n‚ä¢ Measurable (MeasureTheory.spanningSetsIndex Œº)","decl":"open scoped Classical in\ntheorem measurableSet_spanningSetsIndex (Œº : Measure Œ±) [SigmaFinite Œº] :\n    Measurable (spanningSetsIndex Œº) :=\n  measurable_find _ <| measurableSet_spanningSets Œº\n\n"}
{"name":"MeasureTheory.preimage_spanningSetsIndex_singleton","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\nn : Nat\n‚ä¢ Eq (Set.preimage (MeasureTheory.spanningSetsIndex Œº) (Singleton.singleton n)) (disjointed (MeasureTheory.spanningSets Œº) n)","decl":"open scoped Classical in\ntheorem preimage_spanningSetsIndex_singleton (Œº : Measure Œ±) [SigmaFinite Œº] (n : ‚Ñï) :\n    spanningSetsIndex Œº ‚Åª¬π' {n} = disjointed (spanningSets Œº) n :=\n  preimage_find_eq_disjointed _ _ _\n\n"}
{"name":"MeasureTheory.spanningSetsIndex_eq_iff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\nx : Œ±\nn : Nat\n‚ä¢ Iff (Eq (MeasureTheory.spanningSetsIndex Œº x) n) (Membership.mem (disjointed (MeasureTheory.spanningSets Œº) n) x)","decl":"theorem spanningSetsIndex_eq_iff (Œº : Measure Œ±) [SigmaFinite Œº] {x : Œ±} {n : ‚Ñï} :\n    spanningSetsIndex Œº x = n ‚Üî x ‚àà disjointed (spanningSets Œº) n := by\n  convert Set.ext_iff.1 (preimage_spanningSetsIndex_singleton Œº n) x\n\n"}
{"name":"MeasureTheory.mem_disjointed_spanningSetsIndex","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\nx : Œ±\n‚ä¢ Membership.mem (disjointed (MeasureTheory.spanningSets Œº) (MeasureTheory.spanningSetsIndex Œº x)) x","decl":"theorem mem_disjointed_spanningSetsIndex (Œº : Measure Œ±) [SigmaFinite Œº] (x : Œ±) :\n    x ‚àà disjointed (spanningSets Œº) (spanningSetsIndex Œº x) :=\n  (spanningSetsIndex_eq_iff Œº).1 rfl\n\n"}
{"name":"MeasureTheory.mem_spanningSetsIndex","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\nx : Œ±\n‚ä¢ Membership.mem (MeasureTheory.spanningSets Œº (MeasureTheory.spanningSetsIndex Œº x)) x","decl":"theorem mem_spanningSetsIndex (Œº : Measure Œ±) [SigmaFinite Œº] (x : Œ±) :\n    x ‚àà spanningSets Œº (spanningSetsIndex Œº x) :=\n  disjointed_subset _ _ (mem_disjointed_spanningSetsIndex Œº x)\n\n"}
{"name":"MeasureTheory.mem_spanningSets_of_index_le","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\nx : Œ±\nn : Nat\nhn : LE.le (MeasureTheory.spanningSetsIndex Œº x) n\n‚ä¢ Membership.mem (MeasureTheory.spanningSets Œº n) x","decl":"theorem mem_spanningSets_of_index_le (Œº : Measure Œ±) [SigmaFinite Œº] (x : Œ±) {n : ‚Ñï}\n    (hn : spanningSetsIndex Œº x ‚â§ n) : x ‚àà spanningSets Œº n :=\n  monotone_spanningSets Œº hn (mem_spanningSetsIndex Œº x)\n\n"}
{"name":"MeasureTheory.eventually_mem_spanningSets","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\nx : Œ±\n‚ä¢ Filter.Eventually (fun n => Membership.mem (MeasureTheory.spanningSets Œº n) x) Filter.atTop","decl":"theorem eventually_mem_spanningSets (Œº : Measure Œ±) [SigmaFinite Œº] (x : Œ±) :\n    ‚àÄ·∂† n in atTop, x ‚àà spanningSets Œº n :=\n  eventually_atTop.2 ‚ü®spanningSetsIndex Œº x, fun _ => mem_spanningSets_of_index_le Œº x‚ü©\n\n"}
{"name":"MeasureTheory.sum_restrict_disjointed_spanningSets","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº ŒΩ : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SigmaFinite ŒΩ\n‚ä¢ Eq (MeasureTheory.Measure.sum fun n => Œº.restrict (disjointed (MeasureTheory.spanningSets ŒΩ) n)) Œº","decl":"theorem sum_restrict_disjointed_spanningSets (Œº ŒΩ : Measure Œ±) [SigmaFinite ŒΩ] :\n    sum (fun n ‚Ü¶ Œº.restrict (disjointed (spanningSets ŒΩ) n)) = Œº := by\n  rw [‚Üê restrict_iUnion (disjoint_disjointed _)\n      (MeasurableSet.disjointed (measurableSet_spanningSets _)),\n    iUnion_disjointed, iUnion_spanningSets, restrict_univ]\n\n"}
{"name":"MeasureTheory.instSFiniteOfSigmaFinite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\n‚ä¢ MeasureTheory.SFinite Œº","decl":"instance (priority := 100) [SigmaFinite Œº] : SFinite Œº := by\n  have : ‚àÄ n, Fact (Œº (disjointed (spanningSets Œº) n) < ‚àû) :=\n    fun n ‚Ü¶ ‚ü®(measure_mono (disjointed_subset _ _)).trans_lt (measure_spanningSets_lt_top Œº n)‚ü©\n  exact ‚ü®‚ü®fun n ‚Ü¶ Œº.restrict (disjointed (spanningSets Œº) n), fun n ‚Ü¶ by infer_instance,\n    (sum_restrict_disjointed_spanningSets Œº Œº).symm‚ü©‚ü©\n\n"}
{"name":"MeasureTheory.Measure.forall_measure_inter_spanningSets_eq_zero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\ns : Set Œ±\n‚ä¢ Iff (‚àÄ (n : Nat), Eq (Œº (Inter.inter s (MeasureTheory.spanningSets Œº n))) 0) (Eq (Œº s) 0)","decl":"/-- A set in a œÉ-finite space has zero measure if and only if its intersection with\nall members of the countable family of finite measure spanning sets has zero measure. -/\ntheorem forall_measure_inter_spanningSets_eq_zero [MeasurableSpace Œ±] {Œº : Measure Œ±}\n    [SigmaFinite Œº] (s : Set Œ±) : (‚àÄ n, Œº (s ‚à© spanningSets Œº n) = 0) ‚Üî Œº s = 0 := by\n  nth_rw 2 [show s = ‚ãÉ n, s ‚à© spanningSets Œº n by\n      rw [‚Üê inter_iUnion, iUnion_spanningSets, inter_univ] ]\n  rw [measure_iUnion_null_iff]\n\n"}
{"name":"MeasureTheory.Measure.exists_measure_inter_spanningSets_pos","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\ns : Set Œ±\n‚ä¢ Iff (Exists fun n => LT.lt 0 (Œº (Inter.inter s (MeasureTheory.spanningSets Œº n)))) (LT.lt 0 (Œº s))","decl":"/-- A set in a œÉ-finite space has positive measure if and only if its intersection with\nsome member of the countable family of finite measure spanning sets has positive measure. -/\ntheorem exists_measure_inter_spanningSets_pos [MeasurableSpace Œ±] {Œº : Measure Œ±} [SigmaFinite Œº]\n    (s : Set Œ±) : (‚àÉ n, 0 < Œº (s ‚à© spanningSets Œº n)) ‚Üî 0 < Œº s := by\n  rw [‚Üê not_iff_not]\n  simp only [not_exists, not_lt, nonpos_iff_eq_zero]\n  exact forall_measure_inter_spanningSets_eq_zero s\n\n"}
{"name":"MeasureTheory.Measure.finite_const_le_meas_of_disjoint_iUnion‚ÇÄ","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nŒπ : Type u_5\ninst‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒµ : ENNReal\nŒµ_pos : LT.lt 0 Œµ\nAs : Œπ ‚Üí Set Œ±\nAs_mble : ‚àÄ (i : Œπ), MeasureTheory.NullMeasurableSet (As i) Œº\nAs_disj : Pairwise (Function.onFun (MeasureTheory.AEDisjoint Œº) As)\nUnion_As_finite : Ne (Œº (Set.iUnion fun i => As i)) Top.top\n‚ä¢ (setOf fun i => LE.le Œµ (Œº (As i))).Finite","decl":"/-- If the union of a.e.-disjoint null-measurable sets has finite measure, then there are only\nfinitely many members of the union whose measure exceeds any given positive number. -/\ntheorem finite_const_le_meas_of_disjoint_iUnion‚ÇÄ {Œπ : Type*} [MeasurableSpace Œ±] (Œº : Measure Œ±)\n    {Œµ : ‚Ñù‚â•0‚àû} (Œµ_pos : 0 < Œµ) {As : Œπ ‚Üí Set Œ±} (As_mble : ‚àÄ i : Œπ, NullMeasurableSet (As i) Œº)\n    (As_disj : Pairwise (AEDisjoint Œº on As)) (Union_As_finite : Œº (‚ãÉ i, As i) ‚â† ‚àû) :\n    Set.Finite { i : Œπ | Œµ ‚â§ Œº (As i) } :=\n  ENNReal.finite_const_le_of_tsum_ne_top\n    (ne_top_of_le_ne_top Union_As_finite (tsum_meas_le_meas_iUnion_of_disjoint‚ÇÄ Œº As_mble As_disj))\n    Œµ_pos.ne'\n\n"}
{"name":"MeasureTheory.Measure.finite_const_le_meas_of_disjoint_iUnion","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nŒπ : Type u_5\ninst‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒµ : ENNReal\nŒµ_pos : LT.lt 0 Œµ\nAs : Œπ ‚Üí Set Œ±\nAs_mble : ‚àÄ (i : Œπ), MeasurableSet (As i)\nAs_disj : Pairwise (Function.onFun Disjoint As)\nUnion_As_finite : Ne (Œº (Set.iUnion fun i => As i)) Top.top\n‚ä¢ (setOf fun i => LE.le Œµ (Œº (As i))).Finite","decl":"/-- If the union of disjoint measurable sets has finite measure, then there are only\nfinitely many members of the union whose measure exceeds any given positive number. -/\ntheorem finite_const_le_meas_of_disjoint_iUnion {Œπ : Type*} [MeasurableSpace Œ±] (Œº : Measure Œ±)\n    {Œµ : ‚Ñù‚â•0‚àû} (Œµ_pos : 0 < Œµ) {As : Œπ ‚Üí Set Œ±} (As_mble : ‚àÄ i : Œπ, MeasurableSet (As i))\n    (As_disj : Pairwise (Disjoint on As)) (Union_As_finite : Œº (‚ãÉ i, As i) ‚â† ‚àû) :\n    Set.Finite { i : Œπ | Œµ ‚â§ Œº (As i) } :=\n  finite_const_le_meas_of_disjoint_iUnion‚ÇÄ Œº Œµ_pos (fun i ‚Ü¶ (As_mble i).nullMeasurableSet)\n    (fun _ _ h ‚Ü¶ Disjoint.aedisjoint (As_disj h)) Union_As_finite\n\n"}
{"name":"Set.Infinite.meas_eq_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasurableSingletonClass Œ±\ns : Set Œ±\nhs : s.Infinite\nh' : Exists fun Œµ => And (Ne Œµ 0) (‚àÄ (x : Œ±), Membership.mem s x ‚Üí LE.le Œµ (Œº (Singleton.singleton x)))\n‚ä¢ Eq (Œº s) Top.top","decl":"/-- If all elements of an infinite set have measure uniformly separated from zero,\nthen the set has infinite measure. -/\ntheorem _root_.Set.Infinite.meas_eq_top [MeasurableSingletonClass Œ±]\n    {s : Set Œ±} (hs : s.Infinite) (h' : ‚àÉ Œµ, Œµ ‚â† 0 ‚àß ‚àÄ x ‚àà s, Œµ ‚â§ Œº {x}) : Œº s = ‚àû := top_unique <|\n  let ‚ü®Œµ, hne, hŒµ‚ü© := h'; have := hs.to_subtype\n  calc\n    ‚àû = ‚àë' _ : s, Œµ := (ENNReal.tsum_const_eq_top_of_ne_zero hne).symm\n    _ ‚â§ ‚àë' x : s, Œº {x.1} := ENNReal.tsum_le_tsum fun x ‚Ü¶ hŒµ x x.2\n    _ ‚â§ Œº (‚ãÉ x : s, {x.1}) := tsum_meas_le_meas_iUnion_of_disjoint _\n      (fun _ ‚Ü¶ MeasurableSet.singleton _) fun x y hne ‚Ü¶ by simpa [Subtype.val_inj]\n    _ = Œº s := by simp\n\n"}
{"name":"MeasureTheory.Measure.countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top‚ÇÄ","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nŒπ : Type u_5\nx‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nAs : Œπ ‚Üí Set Œ±\nAs_mble : ‚àÄ (i : Œπ), MeasureTheory.NullMeasurableSet (As i) Œº\nAs_disj : Pairwise (Function.onFun (MeasureTheory.AEDisjoint Œº) As)\nUnion_As_finite : Ne (Œº (Set.iUnion fun i => As i)) Top.top\n‚ä¢ (setOf fun i => LT.lt 0 (Œº (As i))).Countable","decl":"/-- If the union of a.e.-disjoint null-measurable sets has finite measure, then there are only\ncountably many members of the union whose measure is positive. -/\ntheorem countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top‚ÇÄ {Œπ : Type*} {_ : MeasurableSpace Œ±}\n    (Œº : Measure Œ±) {As : Œπ ‚Üí Set Œ±} (As_mble : ‚àÄ i : Œπ, NullMeasurableSet (As i) Œº)\n    (As_disj : Pairwise (AEDisjoint Œº on As)) (Union_As_finite : Œº (‚ãÉ i, As i) ‚â† ‚àû) :\n    Set.Countable { i : Œπ | 0 < Œº (As i) } := by\n  set posmeas := { i : Œπ | 0 < Œº (As i) } with posmeas_def\n  rcases exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : ‚Ñù‚â•0‚àû) < 1) with\n    ‚ü®as, _, as_mem, as_lim‚ü©\n  set fairmeas := fun n : ‚Ñï => { i : Œπ | as n ‚â§ Œº (As i) }\n  have countable_union : posmeas = ‚ãÉ n, fairmeas n := by\n    have fairmeas_eq : ‚àÄ n, fairmeas n = (fun i => Œº (As i)) ‚Åª¬π' Ici (as n) := fun n => by\n      simp only [fairmeas]\n      rfl\n    simpa only [fairmeas_eq, posmeas_def, ‚Üê preimage_iUnion,\n      iUnion_Ici_eq_Ioi_of_lt_of_tendsto (fun n => (as_mem n).1) as_lim]\n  rw [countable_union]\n  refine countable_iUnion fun n => Finite.countable ?_\n  exact finite_const_le_meas_of_disjoint_iUnion‚ÇÄ Œº (as_mem n).1 As_mble As_disj Union_As_finite\n\n"}
{"name":"MeasureTheory.Measure.countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nŒπ : Type u_5\nx‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nAs : Œπ ‚Üí Set Œ±\nAs_mble : ‚àÄ (i : Œπ), MeasurableSet (As i)\nAs_disj : Pairwise (Function.onFun Disjoint As)\nUnion_As_finite : Ne (Œº (Set.iUnion fun i => As i)) Top.top\n‚ä¢ (setOf fun i => LT.lt 0 (Œº (As i))).Countable","decl":"/-- If the union of disjoint measurable sets has finite measure, then there are only\ncountably many members of the union whose measure is positive. -/\ntheorem countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top {Œπ : Type*} {_ : MeasurableSpace Œ±}\n    (Œº : Measure Œ±) {As : Œπ ‚Üí Set Œ±} (As_mble : ‚àÄ i : Œπ, MeasurableSet (As i))\n    (As_disj : Pairwise (Disjoint on As)) (Union_As_finite : Œº (‚ãÉ i, As i) ‚â† ‚àû) :\n    Set.Countable { i : Œπ | 0 < Œº (As i) } :=\n  countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top‚ÇÄ Œº (fun i ‚Ü¶ (As_mble i).nullMeasurableSet)\n    ((fun _ _ h ‚Ü¶ Disjoint.aedisjoint (As_disj h))) Union_As_finite\n\n"}
{"name":"MeasureTheory.Measure.countable_meas_pos_of_disjoint_iUnion‚ÇÄ","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nŒπ : Type u_5\nx‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SFinite Œº\nAs : Œπ ‚Üí Set Œ±\nAs_mble : ‚àÄ (i : Œπ), MeasureTheory.NullMeasurableSet (As i) Œº\nAs_disj : Pairwise (Function.onFun (MeasureTheory.AEDisjoint Œº) As)\n‚ä¢ (setOf fun i => LT.lt 0 (Œº (As i))).Countable","decl":"/-- In an s-finite space, among disjoint null-measurable sets, only countably many can have positive\nmeasure. -/\ntheorem countable_meas_pos_of_disjoint_iUnion‚ÇÄ {Œπ : Type*} {_ : MeasurableSpace Œ±} {Œº : Measure Œ±}\n    [SFinite Œº] {As : Œπ ‚Üí Set Œ±} (As_mble : ‚àÄ i : Œπ, NullMeasurableSet (As i) Œº)\n    (As_disj : Pairwise (AEDisjoint Œº on As)) :\n    Set.Countable { i : Œπ | 0 < Œº (As i) } := by\n  rw [‚Üê sum_sfiniteSeq Œº] at As_disj As_mble ‚ä¢\n  have obs : { i : Œπ | 0 < sum (sfiniteSeq Œº) (As i) }\n      ‚äÜ ‚ãÉ n, { i : Œπ | 0 < sfiniteSeq Œº n (As i) } := by\n    intro i hi\n    by_contra con\n    simp only [mem_iUnion, mem_setOf_eq, not_exists, not_lt, nonpos_iff_eq_zero] at *\n    rw [sum_apply‚ÇÄ] at hi\n    ¬∑ simp_rw [con] at hi\n      simp at hi\n    ¬∑ exact As_mble i\n  apply Countable.mono obs\n  refine countable_iUnion fun n ‚Ü¶ ?_\n  apply countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top‚ÇÄ\n  ¬∑ exact fun i ‚Ü¶ (As_mble i).mono (le_sum _ _)\n  ¬∑ exact fun i j hij ‚Ü¶ AEDisjoint.of_le (As_disj hij) (le_sum _ _)\n  ¬∑ exact measure_ne_top _ (‚ãÉ i, As i)\n\n"}
{"name":"MeasureTheory.Measure.countable_meas_pos_of_disjoint_iUnion","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nŒπ : Type u_5\nx‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SFinite Œº\nAs : Œπ ‚Üí Set Œ±\nAs_mble : ‚àÄ (i : Œπ), MeasurableSet (As i)\nAs_disj : Pairwise (Function.onFun Disjoint As)\n‚ä¢ (setOf fun i => LT.lt 0 (Œº (As i))).Countable","decl":"/-- In an s-finite space, among disjoint measurable sets, only countably many can have positive\nmeasure. -/\ntheorem countable_meas_pos_of_disjoint_iUnion {Œπ : Type*} {_ : MeasurableSpace Œ±} {Œº : Measure Œ±}\n    [SFinite Œº] {As : Œπ ‚Üí Set Œ±} (As_mble : ‚àÄ i : Œπ, MeasurableSet (As i))\n    (As_disj : Pairwise (Disjoint on As)) : Set.Countable { i : Œπ | 0 < Œº (As i) } :=\n  countable_meas_pos_of_disjoint_iUnion‚ÇÄ (fun i ‚Ü¶ (As_mble i).nullMeasurableSet)\n    ((fun _ _ h ‚Ü¶ Disjoint.aedisjoint (As_disj h)))\n\n"}
{"name":"MeasureTheory.Measure.countable_meas_level_set_pos‚ÇÄ","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_5\nŒ≤ : Type u_6\nx‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : MeasureTheory.SFinite Œº\ninst‚úù¬π : MeasurableSpace Œ≤\ninst‚úù : MeasurableSingletonClass Œ≤\ng : Œ± ‚Üí Œ≤\ng_mble : MeasureTheory.NullMeasurable g Œº\n‚ä¢ (setOf fun t => LT.lt 0 (Œº (setOf fun a => Eq (g a) t))).Countable","decl":"theorem countable_meas_level_set_pos‚ÇÄ {Œ± Œ≤ : Type*} {_ : MeasurableSpace Œ±} {Œº : Measure Œ±}\n    [SFinite Œº] [MeasurableSpace Œ≤] [MeasurableSingletonClass Œ≤] {g : Œ± ‚Üí Œ≤}\n    (g_mble : NullMeasurable g Œº) : Set.Countable { t : Œ≤ | 0 < Œº { a : Œ± | g a = t } } := by\n  have level_sets_disjoint : Pairwise (Disjoint on fun t : Œ≤ => { a : Œ± | g a = t }) :=\n    fun s t hst => Disjoint.preimage g (disjoint_singleton.mpr hst)\n  exact Measure.countable_meas_pos_of_disjoint_iUnion‚ÇÄ\n    (fun b => g_mble (‚ÄπMeasurableSingletonClass Œ≤‚Ä∫.measurableSet_singleton b))\n    ((fun _ _ h ‚Ü¶ Disjoint.aedisjoint (level_sets_disjoint h)))\n\n"}
{"name":"MeasureTheory.Measure.countable_meas_level_set_pos","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_5\nŒ≤ : Type u_6\nx‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : MeasureTheory.SFinite Œº\ninst‚úù¬π : MeasurableSpace Œ≤\ninst‚úù : MeasurableSingletonClass Œ≤\ng : Œ± ‚Üí Œ≤\ng_mble : Measurable g\n‚ä¢ (setOf fun t => LT.lt 0 (Œº (setOf fun a => Eq (g a) t))).Countable","decl":"theorem countable_meas_level_set_pos {Œ± Œ≤ : Type*} {_ : MeasurableSpace Œ±} {Œº : Measure Œ±}\n    [SFinite Œº] [MeasurableSpace Œ≤] [MeasurableSingletonClass Œ≤] {g : Œ± ‚Üí Œ≤}\n    (g_mble : Measurable g) : Set.Countable { t : Œ≤ | 0 < Œº { a : Œ± | g a = t } } :=\n  countable_meas_level_set_pos‚ÇÄ g_mble.nullMeasurable\n\n"}
{"name":"MeasureTheory.Measure.measure_toMeasurable_inter_of_sum","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\nhs : MeasurableSet s\nt : Set Œ±\nm : Nat ‚Üí MeasureTheory.Measure Œ±\nhv : ‚àÄ (n : Nat), Ne ((m n) t) Top.top\nhŒº : Eq Œº (MeasureTheory.Measure.sum m)\n‚ä¢ Eq (Œº (Inter.inter (MeasureTheory.toMeasurable Œº t) s)) (Œº (Inter.inter t s))","decl":"/-- If a measure `Œº` is the sum of a countable family `m‚Çô`, and a set `t` has finite measure for\neach `m‚Çô`, then its measurable superset `toMeasurable Œº t` (which has the same measure as `t`)\nsatisfies, for any measurable set `s`, the equality `Œº (toMeasurable Œº t ‚à© s) = Œº (t ‚à© s)`. -/\ntheorem measure_toMeasurable_inter_of_sum {s : Set Œ±} (hs : MeasurableSet s) {t : Set Œ±}\n    {m : ‚Ñï ‚Üí Measure Œ±} (hv : ‚àÄ n, m n t ‚â† ‚àû) (hŒº : Œº = sum m) :\n    Œº (toMeasurable Œº t ‚à© s) = Œº (t ‚à© s) := by\n  -- we show that there is a measurable superset of `t` satisfying the conclusion for any\n  -- measurable set `s`. It is built for each measure `m‚Çô` using `toMeasurable`\n  -- (which is well behaved for finite measure sets thanks to `measure_toMeasurable_inter`), and\n  -- then taking the intersection over `n`.\n  have A : ‚àÉ t', t' ‚äá t ‚àß MeasurableSet t' ‚àß ‚àÄ u, MeasurableSet u ‚Üí Œº (t' ‚à© u) = Œº (t ‚à© u) := by\n    let w n := toMeasurable (m n) t\n    have T : t ‚äÜ ‚ãÇ n, w n := subset_iInter (fun i ‚Ü¶ subset_toMeasurable (m i) t)\n    have M : MeasurableSet (‚ãÇ n, w n) :=\n      MeasurableSet.iInter (fun i ‚Ü¶ measurableSet_toMeasurable (m i) t)\n    refine ‚ü®‚ãÇ n, w n, T, M, fun u hu ‚Ü¶ ?_‚ü©\n    refine le_antisymm ?_ (by gcongr)\n    rw [hŒº, sum_apply _ (M.inter hu)]\n    apply le_trans _ (le_sum_apply _ _)\n    apply ENNReal.tsum_le_tsum (fun i ‚Ü¶ ?_)\n    calc\n    m i ((‚ãÇ n, w n) ‚à© u) ‚â§ m i (w i ‚à© u) := by gcongr; apply iInter_subset\n    _ = m i (t ‚à© u) := measure_toMeasurable_inter hu (hv i)\n  -- thanks to the definition of `toMeasurable`, the previous property will also be shared\n  -- by `toMeasurable Œº t`, which is enough to conclude the proof.\n  rw [toMeasurable]\n  split_ifs with ht\n  ¬∑ apply measure_congr\n    exact ae_eq_set_inter ht.choose_spec.2.2 (ae_eq_refl _)\n  ¬∑ exact A.choose_spec.2.2 s hs\n\n"}
{"name":"MeasureTheory.Measure.measure_toMeasurable_inter_of_cover","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\nhs : MeasurableSet s\nt : Set Œ±\nv : Nat ‚Üí Set Œ±\nhv : HasSubset.Subset t (Set.iUnion fun n => v n)\nh'v : ‚àÄ (n : Nat), Ne (Œº (Inter.inter t (v n))) Top.top\n‚ä¢ Eq (Œº (Inter.inter (MeasureTheory.toMeasurable Œº t) s)) (Œº (Inter.inter t s))","decl":"/-- If a set `t` is covered by a countable family of finite measure sets, then its measurable\nsuperset `toMeasurable Œº t` (which has the same measure as `t`) satisfies,\nfor any measurable set `s`, the equality `Œº (toMeasurable Œº t ‚à© s) = Œº (t ‚à© s)`. -/\ntheorem measure_toMeasurable_inter_of_cover {s : Set Œ±} (hs : MeasurableSet s) {t : Set Œ±}\n    {v : ‚Ñï ‚Üí Set Œ±} (hv : t ‚äÜ ‚ãÉ n, v n) (h'v : ‚àÄ n, Œº (t ‚à© v n) ‚â† ‚àû) :\n    Œº (toMeasurable Œº t ‚à© s) = Œº (t ‚à© s) := by\n  -- we show that there is a measurable superset of `t` satisfying the conclusion for any\n  -- measurable set `s`. It is built on each member of a spanning family using `toMeasurable`\n  -- (which is well behaved for finite measure sets thanks to `measure_toMeasurable_inter`), and\n  -- the desired property passes to the union.\n  have A : ‚àÉ t', t' ‚äá t ‚àß MeasurableSet t' ‚àß ‚àÄ u, MeasurableSet u ‚Üí Œº (t' ‚à© u) = Œº (t ‚à© u) := by\n    let w n := toMeasurable Œº (t ‚à© v n)\n    have hw : ‚àÄ n, Œº (w n) < ‚àû := by\n      intro n\n      simp_rw [w, measure_toMeasurable]\n      exact (h'v n).lt_top\n    set t' := ‚ãÉ n, toMeasurable Œº (t ‚à© disjointed w n) with ht'\n    have tt' : t ‚äÜ t' :=\n      calc\n        t ‚äÜ ‚ãÉ n, t ‚à© disjointed w n := by\n          rw [‚Üê inter_iUnion, iUnion_disjointed, inter_iUnion]\n          intro x hx\n          rcases mem_iUnion.1 (hv hx) with ‚ü®n, hn‚ü©\n          refine mem_iUnion.2 ‚ü®n, ?_‚ü©\n          have : x ‚àà t ‚à© v n := ‚ü®hx, hn‚ü©\n          exact ‚ü®hx, subset_toMeasurable Œº _ this‚ü©\n        _ ‚äÜ ‚ãÉ n, toMeasurable Œº (t ‚à© disjointed w n) :=\n          iUnion_mono fun n => subset_toMeasurable _ _\n    refine ‚ü®t', tt', MeasurableSet.iUnion fun n => measurableSet_toMeasurable Œº _, fun u hu => ?_‚ü©\n    apply le_antisymm _ (by gcongr)\n    calc\n      Œº (t' ‚à© u) ‚â§ ‚àë' n, Œº (toMeasurable Œº (t ‚à© disjointed w n) ‚à© u) := by\n        rw [ht', iUnion_inter]\n        exact measure_iUnion_le _\n      _ = ‚àë' n, Œº (t ‚à© disjointed w n ‚à© u) := by\n        congr 1\n        ext1 n\n        apply measure_toMeasurable_inter hu\n        apply ne_of_lt\n        calc\n          Œº (t ‚à© disjointed w n) ‚â§ Œº (t ‚à© w n) := by\n            gcongr\n            exact disjointed_le w n\n          _ ‚â§ Œº (w n) := measure_mono inter_subset_right\n          _ < ‚àû := hw n\n      _ = ‚àë' n, Œº.restrict (t ‚à© u) (disjointed w n) := by\n        congr 1\n        ext1 n\n        rw [restrict_apply, inter_comm t _, inter_assoc]\n        refine MeasurableSet.disjointed (fun n => ?_) n\n        exact measurableSet_toMeasurable _ _\n      _ = Œº.restrict (t ‚à© u) (‚ãÉ n, disjointed w n) := by\n        rw [measure_iUnion]\n        ¬∑ exact disjoint_disjointed _\n        ¬∑ intro i\n          refine MeasurableSet.disjointed (fun n => ?_) i\n          exact measurableSet_toMeasurable _ _\n      _ ‚â§ Œº.restrict (t ‚à© u) univ := measure_mono (subset_univ _)\n      _ = Œº (t ‚à© u) := by rw [restrict_apply MeasurableSet.univ, univ_inter]\n  -- thanks to the definition of `toMeasurable`, the previous property will also be shared\n  -- by `toMeasurable Œº t`, which is enough to conclude the proof.\n  rw [toMeasurable]\n  split_ifs with ht\n  ¬∑ apply measure_congr\n    exact ae_eq_set_inter ht.choose_spec.2.2 (ae_eq_refl _)\n  ¬∑ exact A.choose_spec.2.2 s hs\n\n"}
{"name":"MeasureTheory.Measure.restrict_toMeasurable_of_cover","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\nv : Nat ‚Üí Set Œ±\nhv : HasSubset.Subset s (Set.iUnion fun n => v n)\nh'v : ‚àÄ (n : Nat), Ne (Œº (Inter.inter s (v n))) Top.top\n‚ä¢ Eq (Œº.restrict (MeasureTheory.toMeasurable Œº s)) (Œº.restrict s)","decl":"theorem restrict_toMeasurable_of_cover {s : Set Œ±} {v : ‚Ñï ‚Üí Set Œ±} (hv : s ‚äÜ ‚ãÉ n, v n)\n    (h'v : ‚àÄ n, Œº (s ‚à© v n) ‚â† ‚àû) : Œº.restrict (toMeasurable Œº s) = Œº.restrict s :=\n  ext fun t ht => by\n    simp only [restrict_apply ht, inter_comm t, measure_toMeasurable_inter_of_cover ht hv h'v]\n\n"}
{"name":"MeasureTheory.Measure.measure_toMeasurable_inter_of_sFinite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SFinite Œº\ns : Set Œ±\nhs : MeasurableSet s\nt : Set Œ±\n‚ä¢ Eq (Œº (Inter.inter (MeasureTheory.toMeasurable Œº t) s)) (Œº (Inter.inter t s))","decl":"/-- The measurable superset `toMeasurable Œº t` of `t` (which has the same measure as `t`)\nsatisfies, for any measurable set `s`, the equality `Œº (toMeasurable Œº t ‚à© s) = Œº (t ‚à© s)`.\nThis only holds when `Œº` is s-finite -- for example for œÉ-finite measures. For a version without\nthis assumption (but requiring that `t` has finite measure), see `measure_toMeasurable_inter`. -/\ntheorem measure_toMeasurable_inter_of_sFinite [SFinite Œº] {s : Set Œ±} (hs : MeasurableSet s)\n    (t : Set Œ±) : Œº (toMeasurable Œº t ‚à© s) = Œº (t ‚à© s) :=\n  measure_toMeasurable_inter_of_sum hs (fun _ ‚Ü¶ measure_ne_top _ t) (sum_sfiniteSeq Œº).symm\n\n"}
{"name":"MeasureTheory.Measure.restrict_toMeasurable_of_sFinite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SFinite Œº\ns : Set Œ±\n‚ä¢ Eq (Œº.restrict (MeasureTheory.toMeasurable Œº s)) (Œº.restrict s)","decl":"@[simp]\ntheorem restrict_toMeasurable_of_sFinite [SFinite Œº] (s : Set Œ±) :\n    Œº.restrict (toMeasurable Œº s) = Œº.restrict s :=\n  ext fun t ht => by\n    rw [restrict_apply ht, inter_comm t, measure_toMeasurable_inter_of_sFinite ht,\n      restrict_apply ht, inter_comm t]\n\n"}
{"name":"MeasureTheory.Measure.iSup_restrict_spanningSets_of_measurableSet","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\nhs : MeasurableSet s\n‚ä¢ Eq (iSup fun i => (Œº.restrict (MeasureTheory.spanningSets Œº i)) s) (Œº s)","decl":"/-- Auxiliary lemma for `iSup_restrict_spanningSets`. -/\ntheorem iSup_restrict_spanningSets_of_measurableSet [SigmaFinite Œº] (hs : MeasurableSet s) :\n    ‚®Ü i, Œº.restrict (spanningSets Œº i) s = Œº s :=\n  calc\n    ‚®Ü i, Œº.restrict (spanningSets Œº i) s = Œº.restrict (‚ãÉ i, spanningSets Œº i) s :=\n      (restrict_iUnion_apply_eq_iSup (monotone_spanningSets Œº).directed_le hs).symm\n    _ = Œº s := by rw [iUnion_spanningSets, restrict_univ]\n\n"}
{"name":"MeasureTheory.Measure.iSup_restrict_spanningSets","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\ns : Set Œ±\n‚ä¢ Eq (iSup fun i => (Œº.restrict (MeasureTheory.spanningSets Œº i)) s) (Œº s)","decl":"theorem iSup_restrict_spanningSets [SigmaFinite Œº] (s : Set Œ±) :\n    ‚®Ü i, Œº.restrict (spanningSets Œº i) s = Œº s := by\n  rw [‚Üê measure_toMeasurable s,\n    ‚Üê iSup_restrict_spanningSets_of_measurableSet (measurableSet_toMeasurable _ _)]\n  simp_rw [restrict_apply' (measurableSet_spanningSets Œº _), Set.inter_comm s,\n    ‚Üê restrict_apply (measurableSet_spanningSets Œº _), ‚Üê restrict_toMeasurable_of_sFinite s,\n    restrict_apply (measurableSet_spanningSets Œº _), Set.inter_comm _ (toMeasurable Œº s)]\n\n"}
{"name":"MeasureTheory.Measure.exists_subset_measure_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\nr : ENNReal\nhs : MeasurableSet s\nh's : LT.lt r (Œº s)\n‚ä¢ Exists fun t => And (MeasurableSet t) (And (HasSubset.Subset t s) (And (LT.lt r (Œº t)) (LT.lt (Œº t) Top.top)))","decl":"/-- In a œÉ-finite space, any measurable set of measure `> r` contains a measurable subset of\nfinite measure `> r`. -/\ntheorem exists_subset_measure_lt_top [SigmaFinite Œº] {r : ‚Ñù‚â•0‚àû} (hs : MeasurableSet s)\n    (h's : r < Œº s) : ‚àÉ t, MeasurableSet t ‚àß t ‚äÜ s ‚àß r < Œº t ‚àß Œº t < ‚àû := by\n  rw [‚Üê iSup_restrict_spanningSets,\n    @lt_iSup_iff _ _ _ r fun i : ‚Ñï => Œº.restrict (spanningSets Œº i) s] at h's\n  rcases h's with ‚ü®n, hn‚ü©\n  simp only [restrict_apply hs] at hn\n  refine\n    ‚ü®s ‚à© spanningSets Œº n, hs.inter (measurableSet_spanningSets _ _), inter_subset_left, hn, ?_‚ü©\n  exact (measure_mono inter_subset_right).trans_lt (measure_spanningSets_lt_top _ _)\n\n"}
{"name":"MeasureTheory.Measure.FiniteSpanningSetsIn.sigmaFinite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nC : Set (Set Œ±)\nh : Œº.FiniteSpanningSetsIn C\n‚ä¢ MeasureTheory.SigmaFinite Œº","decl":"/-- If `Œº` has finite spanning sets in the collection of measurable sets `C`, then `Œº` is œÉ-finite.\n-/\nprotected theorem sigmaFinite (h : Œº.FiniteSpanningSetsIn C) : SigmaFinite Œº :=\n  ‚ü®‚ü®h.mono <| subset_univ C‚ü©‚ü©\n\n"}
{"name":"MeasureTheory.Measure.FiniteSpanningSetsIn.ext","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº ŒΩ : MeasureTheory.Measure Œ±\nC : Set (Set Œ±)\nhA : Eq m0 (MeasurableSpace.generateFrom C)\nhC : IsPiSystem C\nh : Œº.FiniteSpanningSetsIn C\nh_eq : ‚àÄ (s : Set Œ±), Membership.mem C s ‚Üí Eq (Œº s) (ŒΩ s)\n‚ä¢ Eq Œº ŒΩ","decl":"/-- An extensionality for measures. It is `ext_of_generateFrom_of_iUnion` formulated in terms of\n`FiniteSpanningSetsIn`. -/\nprotected theorem ext {ŒΩ : Measure Œ±} {C : Set (Set Œ±)} (hA : ‚Äπ_‚Ä∫ = generateFrom C)\n    (hC : IsPiSystem C) (h : Œº.FiniteSpanningSetsIn C) (h_eq : ‚àÄ s ‚àà C, Œº s = ŒΩ s) : Œº = ŒΩ :=\n  ext_of_generateFrom_of_iUnion C _ hA hC h.spanning h.set_mem (fun i => (h.finite i).ne) h_eq\n\n"}
{"name":"MeasureTheory.Measure.FiniteSpanningSetsIn.isCountablySpanning","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nC : Set (Set Œ±)\nh : Œº.FiniteSpanningSetsIn C\n‚ä¢ IsCountablySpanning C","decl":"protected theorem isCountablySpanning (h : Œº.FiniteSpanningSetsIn C) : IsCountablySpanning C :=\n  ‚ü®h.set, h.set_mem, h.spanning‚ü©\n\n"}
{"name":"MeasureTheory.Measure.sigmaFinite_of_countable","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nS : Set (Set Œ±)\nhc : S.Countable\nhŒº : ‚àÄ (s : Set Œ±), Membership.mem S s ‚Üí LT.lt (Œº s) Top.top\nhU : Eq S.sUnion Set.univ\n‚ä¢ MeasureTheory.SigmaFinite Œº","decl":"theorem sigmaFinite_of_countable {S : Set (Set Œ±)} (hc : S.Countable) (hŒº : ‚àÄ s ‚àà S, Œº s < ‚àû)\n    (hU : ‚ãÉ‚ÇÄ S = univ) : SigmaFinite Œº := by\n  obtain ‚ü®s, hŒº, hs‚ü© : ‚àÉ s : ‚Ñï ‚Üí Set Œ±, (‚àÄ n, Œº (s n) < ‚àû) ‚àß ‚ãÉ n, s n = univ :=\n    (@exists_seq_cover_iff_countable _ (fun x => Œº x < ‚àû) ‚ü®‚àÖ, by simp‚ü©).2 ‚ü®S, hc, hŒº, hU‚ü©\n  exact ‚ü®‚ü®‚ü®fun n => s n, fun _ => trivial, hŒº, hs‚ü©‚ü©‚ü©\n\n"}
{"name":"MeasureTheory.Measure.sigmaFinite_of_le","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒΩ Œº : MeasureTheory.Measure Œ±\nhs : MeasureTheory.SigmaFinite Œº\nh : LE.le ŒΩ Œº\n‚ä¢ MeasureTheory.SigmaFinite ŒΩ","decl":"theorem sigmaFinite_of_le (Œº : Measure Œ±) [hs : SigmaFinite Œº] (h : ŒΩ ‚â§ Œº) : SigmaFinite ŒΩ :=\n  ‚ü®hs.out.map <| FiniteSpanningSetsIn.ofLE h‚ü©\n\n"}
{"name":"MeasureTheory.Measure.add_right_inj","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº ŒΩ‚ÇÅ ŒΩ‚ÇÇ : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\n‚ä¢ Iff (Eq (HAdd.hAdd Œº ŒΩ‚ÇÅ) (HAdd.hAdd Œº ŒΩ‚ÇÇ)) (Eq ŒΩ‚ÇÅ ŒΩ‚ÇÇ)","decl":"@[simp] lemma add_right_inj (Œº ŒΩ‚ÇÅ ŒΩ‚ÇÇ : Measure Œ±) [SigmaFinite Œº] :\n    Œº + ŒΩ‚ÇÅ = Œº + ŒΩ‚ÇÇ ‚Üî ŒΩ‚ÇÅ = ŒΩ‚ÇÇ := by\n  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ by rw [h]‚ü©\n  rw [ext_iff_of_iUnion_eq_univ (iUnion_spanningSets Œº)]\n  intro i\n  ext s hs\n  rw [‚Üê ENNReal.add_right_inj (measure_mono s.inter_subset_right |>.trans_lt <|\n    measure_spanningSets_lt_top Œº i).ne]\n  simp only [ext_iff', coe_add, Pi.add_apply] at h\n  simp [hs, h]\n\n"}
{"name":"MeasureTheory.Measure.add_left_inj","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº ŒΩ‚ÇÅ ŒΩ‚ÇÇ : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\n‚ä¢ Iff (Eq (HAdd.hAdd ŒΩ‚ÇÅ Œº) (HAdd.hAdd ŒΩ‚ÇÇ Œº)) (Eq ŒΩ‚ÇÅ ŒΩ‚ÇÇ)","decl":"@[simp] lemma add_left_inj (Œº ŒΩ‚ÇÅ ŒΩ‚ÇÇ : Measure Œ±) [SigmaFinite Œº] :\n    ŒΩ‚ÇÅ + Œº = ŒΩ‚ÇÇ + Œº ‚Üî ŒΩ‚ÇÅ = ŒΩ‚ÇÇ := by rw [add_comm _ Œº, add_comm _ Œº, Œº.add_right_inj]\n\n"}
{"name":"MeasureTheory.IsFiniteMeasure.toSigmaFinite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\n_m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\n‚ä¢ MeasureTheory.SigmaFinite Œº","decl":"/-- Every finite measure is œÉ-finite. -/\ninstance (priority := 100) IsFiniteMeasure.toSigmaFinite {_m0 : MeasurableSpace Œ±} (Œº : Measure Œ±)\n    [IsFiniteMeasure Œº] : SigmaFinite Œº :=\n  ‚ü®‚ü®‚ü®fun _ => univ, fun _ => trivial, fun _ => measure_lt_top Œº _, iUnion_const _‚ü©‚ü©‚ü©\n\n"}
{"name":"MeasureTheory.sigmaFinite_bot_iff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nŒº : MeasureTheory.Measure Œ±\n‚ä¢ Iff (MeasureTheory.SigmaFinite Œº) (MeasureTheory.IsFiniteMeasure Œº)","decl":"theorem sigmaFinite_bot_iff (Œº : @Measure Œ± ‚ä•) : SigmaFinite Œº ‚Üî IsFiniteMeasure Œº := by\n  refine\n    ‚ü®fun h => ‚ü®?_‚ü©, fun h => by\n      haveI := h\n      infer_instance‚ü©\n  haveI : SigmaFinite Œº := h\n  let s := spanningSets Œº\n  have hs_univ : ‚ãÉ i, s i = Set.univ := iUnion_spanningSets Œº\n  have hs_meas : ‚àÄ i, MeasurableSet[‚ä•] (s i) := measurableSet_spanningSets Œº\n  simp_rw [MeasurableSpace.measurableSet_bot_iff] at hs_meas\n  by_cases h_univ_empty : (Set.univ : Set Œ±) = ‚àÖ\n  ¬∑ rw [h_univ_empty, measure_empty]\n    exact ENNReal.zero_ne_top.lt_top\n  obtain ‚ü®i, hsi‚ü© : ‚àÉ i, s i = Set.univ := by\n    by_contra! h_not_univ\n    have h_empty : ‚àÄ i, s i = ‚àÖ := by simpa [h_not_univ] using hs_meas\n    simp only [h_empty, iUnion_empty] at hs_univ\n    exact h_univ_empty hs_univ.symm\n  rw [‚Üê hsi]\n  exact measure_spanningSets_lt_top Œº i\n\n"}
{"name":"MeasureTheory.Restrict.sigmaFinite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\ns : Set Œ±\n‚ä¢ MeasureTheory.SigmaFinite (Œº.restrict s)","decl":"instance Restrict.sigmaFinite (Œº : Measure Œ±) [SigmaFinite Œº] (s : Set Œ±) :\n    SigmaFinite (Œº.restrict s) := by\n  refine ‚ü®‚ü®‚ü®spanningSets Œº, fun _ => trivial, fun i => ?_, iUnion_spanningSets Œº‚ü©‚ü©‚ü©\n  rw [Measure.restrict_apply (measurableSet_spanningSets Œº i)]\n  exact (measure_mono inter_subset_left).trans_lt (measure_spanningSets_lt_top Œº i)\n\n"}
{"name":"MeasureTheory.sum.sigmaFinite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒπ : Type u_5\ninst‚úù¬π : Finite Œπ\nŒº : Œπ ‚Üí MeasureTheory.Measure Œ±\ninst‚úù : ‚àÄ (i : Œπ), MeasureTheory.SigmaFinite (Œº i)\n‚ä¢ MeasureTheory.SigmaFinite (MeasureTheory.Measure.sum Œº)","decl":"instance sum.sigmaFinite {Œπ} [Finite Œπ] (Œº : Œπ ‚Üí Measure Œ±) [‚àÄ i, SigmaFinite (Œº i)] :\n    SigmaFinite (sum Œº) := by\n  cases nonempty_fintype Œπ\n  have : ‚àÄ n, MeasurableSet (‚ãÇ i : Œπ, spanningSets (Œº i) n) := fun n =>\n    MeasurableSet.iInter fun i => measurableSet_spanningSets (Œº i) n\n  refine ‚ü®‚ü®‚ü®fun n => ‚ãÇ i, spanningSets (Œº i) n, fun _ => trivial, fun n => ?_, ?_‚ü©‚ü©‚ü©\n  ¬∑ rw [sum_apply _ (this n), tsum_fintype, ENNReal.sum_lt_top]\n    rintro i -\n    exact (measure_mono <| iInter_subset _ i).trans_lt (measure_spanningSets_lt_top (Œº i) n)\n  ¬∑ rw [iUnion_iInter_of_monotone]\n    ¬∑ simp_rw [iUnion_spanningSets, iInter_univ]\n    exact fun i => monotone_spanningSets (Œº i)\n\n"}
{"name":"MeasureTheory.Add.sigmaFinite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº ŒΩ : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.SigmaFinite Œº\ninst‚úù : MeasureTheory.SigmaFinite ŒΩ\n‚ä¢ MeasureTheory.SigmaFinite (HAdd.hAdd Œº ŒΩ)","decl":"instance Add.sigmaFinite (Œº ŒΩ : Measure Œ±) [SigmaFinite Œº] [SigmaFinite ŒΩ] :\n    SigmaFinite (Œº + ŒΩ) := by\n  rw [‚Üê sum_cond]\n  refine @sum.sigmaFinite _ _ _ _ _ (Bool.rec ?_ ?_) <;> simpa\n\n"}
{"name":"MeasureTheory.SMul.sigmaFinite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\nc : NNReal\n‚ä¢ MeasureTheory.SigmaFinite (HSMul.hSMul c Œº)","decl":"instance SMul.sigmaFinite {Œº : Measure Œ±} [SigmaFinite Œº] (c : ‚Ñù‚â•0) :\n    MeasureTheory.SigmaFinite (c ‚Ä¢ Œº) where\n  out' :=\n  ‚ü®{  set := spanningSets Œº\n      set_mem := fun _ ‚Ü¶ trivial\n      finite := by\n        intro i\n        simp only [Measure.coe_smul, Pi.smul_apply, nnreal_smul_coe_apply]\n        exact ENNReal.mul_lt_top ENNReal.coe_lt_top (measure_spanningSets_lt_top Œº i)\n      spanning := iUnion_spanningSets Œº }‚ü©\n\n"}
{"name":"MeasureTheory.instSigmaFiniteRestrictUnionSet","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns t : Set Œ±\ninst‚úù¬π : MeasureTheory.SigmaFinite (Œº.restrict s)\ninst‚úù : MeasureTheory.SigmaFinite (Œº.restrict t)\n‚ä¢ MeasureTheory.SigmaFinite (Œº.restrict (Union.union s t))","decl":"instance [SigmaFinite (Œº.restrict s)] [SigmaFinite (Œº.restrict t)] :\n    SigmaFinite (Œº.restrict (s ‚à™ t)) := sigmaFinite_of_le _ (restrict_union_le _ _)\n\n"}
{"name":"MeasureTheory.instSigmaFiniteRestrictInterSet","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns t : Set Œ±\ninst‚úù : MeasureTheory.SigmaFinite (Œº.restrict s)\n‚ä¢ MeasureTheory.SigmaFinite (Œº.restrict (Inter.inter s t))","decl":"instance [SigmaFinite (Œº.restrict s)] : SigmaFinite (Œº.restrict (s ‚à© t)) :=\n  sigmaFinite_of_le (Œº.restrict s) (restrict_mono_ae (ae_of_all _ Set.inter_subset_left))\n\n"}
{"name":"MeasureTheory.instSigmaFiniteRestrictInterSet_1","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns t : Set Œ±\ninst‚úù : MeasureTheory.SigmaFinite (Œº.restrict t)\n‚ä¢ MeasureTheory.SigmaFinite (Œº.restrict (Inter.inter s t))","decl":"instance [SigmaFinite (Œº.restrict t)] : SigmaFinite (Œº.restrict (s ‚à© t)) :=\n  sigmaFinite_of_le (Œº.restrict t) (restrict_mono_ae (ae_of_all _ Set.inter_subset_right))\n\n"}
{"name":"MeasureTheory.SigmaFinite.of_map","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù : MeasurableSpace Œ≤\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Œ≤\nhf : AEMeasurable f Œº\nh : MeasureTheory.SigmaFinite (MeasureTheory.Measure.map f Œº)\n‚ä¢ MeasureTheory.SigmaFinite Œº","decl":"theorem SigmaFinite.of_map (Œº : Measure Œ±) {f : Œ± ‚Üí Œ≤} (hf : AEMeasurable f Œº)\n    (h : SigmaFinite (Œº.map f)) : SigmaFinite Œº :=\n  ‚ü®‚ü®‚ü®fun n => f ‚Åª¬π' spanningSets (Œº.map f) n, fun _ => trivial, fun n => by\n        simp only [‚Üê map_apply_of_aemeasurable hf, measurableSet_spanningSets,\n          measure_spanningSets_lt_top],\n        by rw [‚Üê preimage_iUnion, iUnion_spanningSets, preimage_univ]‚ü©‚ü©‚ü©\n\n"}
{"name":"MeasurableEmbedding.sigmaFinite_map","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù¬π : MeasurableSpace Œ≤\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Œ≤\nhf : MeasurableEmbedding f\ninst‚úù : MeasureTheory.SigmaFinite Œº\n‚ä¢ MeasureTheory.SigmaFinite (MeasureTheory.Measure.map f Œº)","decl":"lemma _root_.MeasurableEmbedding.sigmaFinite_map {f : Œ± ‚Üí Œ≤} (hf : MeasurableEmbedding f)\n    [SigmaFinite Œº] :\n    SigmaFinite (Œº.map f) := by\n  refine ‚ü®fun n ‚Ü¶ f '' (spanningSets Œº n) ‚à™ (Set.range f)·∂ú, by simp, fun n ‚Ü¶ ?_, ?_‚ü©\n  ¬∑ rw [hf.map_apply, Set.preimage_union]\n    simp only [Set.preimage_compl, Set.preimage_range, Set.compl_univ, Set.union_empty,\n      Set.preimage_image_eq _ hf.injective]\n    exact measure_spanningSets_lt_top Œº n\n  ¬∑ rw [‚Üê Set.iUnion_union, ‚Üê Set.image_iUnion, iUnion_spanningSets,\n      Set.image_univ, Set.union_compl_self]\n\n"}
{"name":"MeasurableEquiv.sigmaFinite_map","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù¬π : MeasurableSpace Œ≤\nŒº : MeasureTheory.Measure Œ±\nf : MeasurableEquiv Œ± Œ≤\ninst‚úù : MeasureTheory.SigmaFinite Œº\n‚ä¢ MeasureTheory.SigmaFinite (MeasureTheory.Measure.map (‚áëf) Œº)","decl":"theorem _root_.MeasurableEquiv.sigmaFinite_map (f : Œ± ‚âÉ·µê Œ≤) [SigmaFinite Œº] :\n    SigmaFinite (Œº.map f) := f.measurableEmbedding.sigmaFinite_map\n\n"}
{"name":"MeasureTheory.ae_of_forall_measure_lt_top_ae_restrict'","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº ŒΩ : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.SigmaFinite Œº\ninst‚úù : MeasureTheory.SigmaFinite ŒΩ\nP : Œ± ‚Üí Prop\nh : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí LT.lt (ŒΩ s) Top.top ‚Üí Filter.Eventually (fun x => P x) (MeasureTheory.ae (Œº.restrict s))\n‚ä¢ Filter.Eventually (fun x => P x) (MeasureTheory.ae Œº)","decl":"/-- Similar to `ae_of_forall_measure_lt_top_ae_restrict`, but where you additionally get the\n  hypothesis that another œÉ-finite measure has finite values on `s`. -/\ntheorem ae_of_forall_measure_lt_top_ae_restrict' {Œº : Measure Œ±} (ŒΩ : Measure Œ±) [SigmaFinite Œº]\n    [SigmaFinite ŒΩ] (P : Œ± ‚Üí Prop)\n    (h : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí ŒΩ s < ‚àû ‚Üí ‚àÄ·µê x ‚àÇŒº.restrict s, P x) : ‚àÄ·µê x ‚àÇŒº, P x := by\n  have : ‚àÄ n, ‚àÄ·µê x ‚àÇŒº, x ‚àà spanningSets (Œº + ŒΩ) n ‚Üí P x := by\n    intro n\n    have := h\n      (spanningSets (Œº + ŒΩ) n) (measurableSet_spanningSets _ _)\n      ((self_le_add_right _ _).trans_lt (measure_spanningSets_lt_top (Œº + ŒΩ) _))\n      ((self_le_add_left _ _).trans_lt (measure_spanningSets_lt_top (Œº + ŒΩ) _))\n    exact (ae_restrict_iff' (measurableSet_spanningSets _ _)).mp this\n  filter_upwards [ae_all_iff.2 this] with _ hx using hx _ (mem_spanningSetsIndex _ _)\n\n"}
{"name":"MeasureTheory.ae_of_forall_measure_lt_top_ae_restrict","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.SigmaFinite Œº\nP : Œ± ‚Üí Prop\nh : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí Filter.Eventually (fun x => P x) (MeasureTheory.ae (Œº.restrict s))\n‚ä¢ Filter.Eventually (fun x => P x) (MeasureTheory.ae Œº)","decl":"/-- To prove something for almost all `x` w.r.t. a œÉ-finite measure, it is sufficient to show that\n  this holds almost everywhere in sets where the measure has finite value. -/\ntheorem ae_of_forall_measure_lt_top_ae_restrict {Œº : Measure Œ±} [SigmaFinite Œº] (P : Œ± ‚Üí Prop)\n    (h : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí ‚àÄ·µê x ‚àÇŒº.restrict s, P x) : ‚àÄ·µê x ‚àÇŒº, P x :=\n  ae_of_forall_measure_lt_top_ae_restrict' Œº P fun s hs h2s _ => h s hs h2s\n\n"}
{"name":"MeasureTheory.IsLocallyFiniteMeasure.finiteAtNhds","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\ninst‚úù : TopologicalSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nself : MeasureTheory.IsLocallyFiniteMeasure Œº\nx : Œ±\n‚ä¢ Œº.FiniteAtFilter (nhds x)","decl":"/-- A measure is called locally finite if it is finite in some neighborhood of each point. -/\nclass IsLocallyFiniteMeasure [TopologicalSpace Œ±] (Œº : Measure Œ±) : Prop where\n  finiteAtNhds : ‚àÄ x, Œº.FiniteAtFilter (ùìù x)\n\n-- see Note [lower instance priority]\n"}
{"name":"MeasureTheory.IsFiniteMeasure.toIsLocallyFiniteMeasure","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\n‚ä¢ MeasureTheory.IsLocallyFiniteMeasure Œº","decl":"instance (priority := 100) IsFiniteMeasure.toIsLocallyFiniteMeasure [TopologicalSpace Œ±]\n    (Œº : Measure Œ±) [IsFiniteMeasure Œº] : IsLocallyFiniteMeasure Œº :=\n  ‚ü®fun _ => finiteAtFilter_of_finite _ _‚ü©\n\n"}
{"name":"MeasureTheory.Measure.finiteAt_nhds","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\nx : Œ±\n‚ä¢ Œº.FiniteAtFilter (nhds x)","decl":"theorem Measure.finiteAt_nhds [TopologicalSpace Œ±] (Œº : Measure Œ±) [IsLocallyFiniteMeasure Œº]\n    (x : Œ±) : Œº.FiniteAtFilter (ùìù x) :=\n  IsLocallyFiniteMeasure.finiteAtNhds x\n\n"}
{"name":"MeasureTheory.Measure.smul_finite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nc : ENNReal\nhc : Ne c Top.top\n‚ä¢ MeasureTheory.IsFiniteMeasure (HSMul.hSMul c Œº)","decl":"theorem Measure.smul_finite (Œº : Measure Œ±) [IsFiniteMeasure Œº] {c : ‚Ñù‚â•0‚àû} (hc : c ‚â† ‚àû) :\n    IsFiniteMeasure (c ‚Ä¢ Œº) := by\n  lift c to ‚Ñù‚â•0 using hc\n  exact MeasureTheory.isFiniteMeasureSMulNNReal\n\n"}
{"name":"MeasureTheory.Measure.exists_isOpen_measure_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\nx : Œ±\n‚ä¢ Exists fun s => And (Membership.mem s x) (And (IsOpen s) (LT.lt (Œº s) Top.top))","decl":"theorem Measure.exists_isOpen_measure_lt_top [TopologicalSpace Œ±] (Œº : Measure Œ±)\n    [IsLocallyFiniteMeasure Œº] (x : Œ±) : ‚àÉ s : Set Œ±, x ‚àà s ‚àß IsOpen s ‚àß Œº s < ‚àû := by\n  simpa only [and_assoc] using (Œº.finiteAt_nhds x).exists_mem_basis (nhds_basis_opens x)\n\n"}
{"name":"MeasureTheory.isLocallyFiniteMeasureSMulNNReal","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\nc : NNReal\n‚ä¢ MeasureTheory.IsLocallyFiniteMeasure (HSMul.hSMul c Œº)","decl":"instance isLocallyFiniteMeasureSMulNNReal [TopologicalSpace Œ±] (Œº : Measure Œ±)\n    [IsLocallyFiniteMeasure Œº] (c : ‚Ñù‚â•0) : IsLocallyFiniteMeasure (c ‚Ä¢ Œº) := by\n  refine ‚ü®fun x => ?_‚ü©\n  rcases Œº.exists_isOpen_measure_lt_top x with ‚ü®o, xo, o_open, Œºo‚ü©\n  refine ‚ü®o, o_open.mem_nhds xo, ?_‚ü©\n  apply ENNReal.mul_lt_top _ Œºo\n  simp\n\n"}
{"name":"MeasureTheory.Measure.isTopologicalBasis_isOpen_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\n‚ä¢ TopologicalSpace.IsTopologicalBasis (setOf fun s => And (IsOpen s) (LT.lt (Œº s) Top.top))","decl":"protected theorem Measure.isTopologicalBasis_isOpen_lt_top [TopologicalSpace Œ±]\n    (Œº : Measure Œ±) [IsLocallyFiniteMeasure Œº] :\n    TopologicalSpace.IsTopologicalBasis { s | IsOpen s ‚àß Œº s < ‚àû } := by\n  refine TopologicalSpace.isTopologicalBasis_of_isOpen_of_nhds (fun s hs => hs.1) ?_\n  intro x s xs hs\n  rcases Œº.exists_isOpen_measure_lt_top x with ‚ü®v, xv, hv, Œºv‚ü©\n  refine ‚ü®v ‚à© s, ‚ü®hv.inter hs, lt_of_le_of_lt ?_ Œºv‚ü©, ‚ü®xv, xs‚ü©, inter_subset_right‚ü©\n  exact measure_mono inter_subset_left\n\n"}
{"name":"MeasureTheory.IsFiniteMeasureOnCompacts.lt_top_of_isCompact","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\ninst‚úù : TopologicalSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nself : MeasureTheory.IsFiniteMeasureOnCompacts Œº\nK : Set Œ±\na‚úù : IsCompact K\n‚ä¢ LT.lt (Œº K) Top.top","decl":"/-- A measure `Œº` is finite on compacts if any compact set `K` satisfies `Œº K < ‚àû`. -/\nclass IsFiniteMeasureOnCompacts [TopologicalSpace Œ±] (Œº : Measure Œ±) : Prop where\n  protected lt_top_of_isCompact : ‚àÄ ‚¶ÉK : Set Œ±‚¶Ñ, IsCompact K ‚Üí Œº K < ‚àû\n\n"}
{"name":"IsCompact.measure_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasureOnCompacts Œº\nK : Set Œ±\nhK : IsCompact K\n‚ä¢ LT.lt (Œº K) Top.top","decl":"/-- A compact subset has finite measure for a measure which is finite on compacts. -/\ntheorem _root_.IsCompact.measure_lt_top [TopologicalSpace Œ±] {Œº : Measure Œ±}\n    [IsFiniteMeasureOnCompacts Œº] ‚¶ÉK : Set Œ±‚¶Ñ (hK : IsCompact K) : Œº K < ‚àû :=\n  IsFiniteMeasureOnCompacts.lt_top_of_isCompact hK\n\n"}
{"name":"IsCompact.measure_ne_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasureOnCompacts Œº\nK : Set Œ±\nhK : IsCompact K\n‚ä¢ Ne (Œº K) Top.top","decl":"/-- A compact subset has finite measure for a measure which is finite on compacts. -/\ntheorem _root_.IsCompact.measure_ne_top [TopologicalSpace Œ±] {Œº : Measure Œ±}\n    [IsFiniteMeasureOnCompacts Œº] ‚¶ÉK : Set Œ±‚¶Ñ (hK : IsCompact K) : Œº K ‚â† ‚àû :=\n  hK.measure_lt_top.ne\n\n"}
{"name":"Bornology.IsBounded.measure_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\ninst‚úù¬≤ : PseudoMetricSpace Œ±\ninst‚úù¬π : ProperSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasureOnCompacts Œº\ns : Set Œ±\nhs : Bornology.IsBounded s\n‚ä¢ LT.lt (Œº s) Top.top","decl":"/-- A bounded subset has finite measure for a measure which is finite on compact sets, in a\nproper space. -/\ntheorem _root_.Bornology.IsBounded.measure_lt_top [PseudoMetricSpace Œ±] [ProperSpace Œ±]\n    {Œº : Measure Œ±} [IsFiniteMeasureOnCompacts Œº] ‚¶És : Set Œ±‚¶Ñ (hs : Bornology.IsBounded s) :\n    Œº s < ‚àû :=\n  calc\n    Œº s ‚â§ Œº (closure s) := measure_mono subset_closure\n    _ < ‚àû := (Metric.isCompact_of_isClosed_isBounded isClosed_closure hs.closure).measure_lt_top\n\n"}
{"name":"MeasureTheory.measure_closedBall_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\ninst‚úù¬≤ : PseudoMetricSpace Œ±\ninst‚úù¬π : ProperSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasureOnCompacts Œº\nx : Œ±\nr : Real\n‚ä¢ LT.lt (Œº (Metric.closedBall x r)) Top.top","decl":"theorem measure_closedBall_lt_top [PseudoMetricSpace Œ±] [ProperSpace Œ±] {Œº : Measure Œ±}\n    [IsFiniteMeasureOnCompacts Œº] {x : Œ±} {r : ‚Ñù} : Œº (Metric.closedBall x r) < ‚àû :=\n  Metric.isBounded_closedBall.measure_lt_top\n\n"}
{"name":"MeasureTheory.measure_ball_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\ninst‚úù¬≤ : PseudoMetricSpace Œ±\ninst‚úù¬π : ProperSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasureOnCompacts Œº\nx : Œ±\nr : Real\n‚ä¢ LT.lt (Œº (Metric.ball x r)) Top.top","decl":"theorem measure_ball_lt_top [PseudoMetricSpace Œ±] [ProperSpace Œ±] {Œº : Measure Œ±}\n    [IsFiniteMeasureOnCompacts Œº] {x : Œ±} {r : ‚Ñù} : Œº (Metric.ball x r) < ‚àû :=\n  Metric.isBounded_ball.measure_lt_top\n\n"}
{"name":"MeasureTheory.IsFiniteMeasureOnCompacts.smul","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasureOnCompacts Œº\nc : ENNReal\nhc : Ne c Top.top\n‚ä¢ MeasureTheory.IsFiniteMeasureOnCompacts (HSMul.hSMul c Œº)","decl":"protected theorem IsFiniteMeasureOnCompacts.smul [TopologicalSpace Œ±] (Œº : Measure Œ±)\n    [IsFiniteMeasureOnCompacts Œº] {c : ‚Ñù‚â•0‚àû} (hc : c ‚â† ‚àû) : IsFiniteMeasureOnCompacts (c ‚Ä¢ Œº) :=\n  ‚ü®fun _K hK => ENNReal.mul_lt_top hc.lt_top hK.measure_lt_top‚ü©\n\n"}
{"name":"MeasureTheory.IsFiniteMeasureOnCompacts.smul_nnreal","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasureOnCompacts Œº\nc : NNReal\n‚ä¢ MeasureTheory.IsFiniteMeasureOnCompacts (HSMul.hSMul c Œº)","decl":"instance IsFiniteMeasureOnCompacts.smul_nnreal [TopologicalSpace Œ±] (Œº : Measure Œ±)\n    [IsFiniteMeasureOnCompacts Œº] (c : ‚Ñù‚â•0) : IsFiniteMeasureOnCompacts (c ‚Ä¢ Œº) :=\n  IsFiniteMeasureOnCompacts.smul Œº coe_ne_top\n\n"}
{"name":"MeasureTheory.instIsFiniteMeasureOnCompactsRestrict","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasureOnCompacts Œº\ns : Set Œ±\n‚ä¢ MeasureTheory.IsFiniteMeasureOnCompacts (Œº.restrict s)","decl":"instance instIsFiniteMeasureOnCompactsRestrict [TopologicalSpace Œ±] {Œº : Measure Œ±}\n    [IsFiniteMeasureOnCompacts Œº] {s : Set Œ±} : IsFiniteMeasureOnCompacts (Œº.restrict s) :=\n  ‚ü®fun _k hk ‚Ü¶ (restrict_apply_le _ _).trans_lt hk.measure_lt_top‚ü©\n\n"}
{"name":"MeasureTheory.CompactSpace.isFiniteMeasure","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : CompactSpace Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasureOnCompacts Œº\n‚ä¢ MeasureTheory.IsFiniteMeasure Œº","decl":"instance (priority := 100) CompactSpace.isFiniteMeasure [TopologicalSpace Œ±] [CompactSpace Œ±]\n    [IsFiniteMeasureOnCompacts Œº] : IsFiniteMeasure Œº :=\n  ‚ü®IsFiniteMeasureOnCompacts.lt_top_of_isCompact isCompact_univ‚ü©\n\n"}
{"name":"MeasureTheory.SigmaFinite.of_isFiniteMeasureOnCompacts","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : SigmaCompactSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasureOnCompacts Œº\n‚ä¢ MeasureTheory.SigmaFinite Œº","decl":"instance (priority := 100) SigmaFinite.of_isFiniteMeasureOnCompacts [TopologicalSpace Œ±]\n    [SigmaCompactSpace Œ±] (Œº : Measure Œ±) [IsFiniteMeasureOnCompacts Œº] : SigmaFinite Œº :=\n  ‚ü®‚ü®{   set := compactCovering Œ±\n        set_mem := fun _ => trivial\n        finite := fun n => (isCompact_compactCovering Œ± n).measure_lt_top\n        spanning := iUnion_compactCovering Œ± }‚ü©‚ü©\n\n-- see Note [lower instance priority]\n"}
{"name":"MeasureTheory.sigmaFinite_of_locallyFinite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : SecondCountableTopology Œ±\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\n‚ä¢ MeasureTheory.SigmaFinite Œº","decl":"instance (priority := 100) sigmaFinite_of_locallyFinite [TopologicalSpace Œ±]\n    [SecondCountableTopology Œ±] [IsLocallyFiniteMeasure Œº] : SigmaFinite Œº := by\n  choose s hsx hsŒº using Œº.finiteAt_nhds\n  rcases TopologicalSpace.countable_cover_nhds hsx with ‚ü®t, htc, htU‚ü©\n  refine Measure.sigmaFinite_of_countable (htc.image s) (forall_mem_image.2 fun x _ => hsŒº x) ?_\n  rwa [sUnion_image]\n\n"}
{"name":"MeasureTheory.isLocallyFiniteMeasure_of_isFiniteMeasureOnCompacts","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : WeaklyLocallyCompactSpace Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasureOnCompacts Œº\n‚ä¢ MeasureTheory.IsLocallyFiniteMeasure Œº","decl":"/-- A measure which is finite on compact sets in a locally compact space is locally finite. -/\ninstance (priority := 100) isLocallyFiniteMeasure_of_isFiniteMeasureOnCompacts [TopologicalSpace Œ±]\n    [WeaklyLocallyCompactSpace Œ±] [IsFiniteMeasureOnCompacts Œº] : IsLocallyFiniteMeasure Œº :=\n  ‚ü®fun x ‚Ü¶\n    let ‚ü®K, K_compact, K_mem‚ü© := exists_compact_mem_nhds x\n    ‚ü®K, K_mem, K_compact.measure_lt_top‚ü©‚ü©\n\n"}
{"name":"MeasureTheory.exists_pos_measure_of_cover","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : Countable Œπ\nU : Œπ ‚Üí Set Œ±\nhU : Eq (Set.iUnion fun i => U i) Set.univ\nhŒº : Ne Œº 0\n‚ä¢ Exists fun i => LT.lt 0 (Œº (U i))","decl":"theorem exists_pos_measure_of_cover [Countable Œπ] {U : Œπ ‚Üí Set Œ±} (hU : ‚ãÉ i, U i = univ)\n    (hŒº : Œº ‚â† 0) : ‚àÉ i, 0 < Œº (U i) := by\n  contrapose! hŒº with H\n  rw [‚Üê measure_univ_eq_zero, ‚Üê hU]\n  exact measure_iUnion_null fun i => nonpos_iff_eq_zero.1 (H i)\n\n"}
{"name":"MeasureTheory.exists_pos_preimage_ball","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nŒ¥ : Type u_3\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : PseudoMetricSpace Œ¥\nf : Œ± ‚Üí Œ¥\nx : Œ¥\nhŒº : Ne Œº 0\n‚ä¢ Exists fun n => LT.lt 0 (Œº (Set.preimage f (Metric.ball x ‚Üën)))","decl":"theorem exists_pos_preimage_ball [PseudoMetricSpace Œ¥] (f : Œ± ‚Üí Œ¥) (x : Œ¥) (hŒº : Œº ‚â† 0) :\n    ‚àÉ n : ‚Ñï, 0 < Œº (f ‚Åª¬π' Metric.ball x n) :=\n  exists_pos_measure_of_cover (by rw [‚Üê preimage_iUnion, Metric.iUnion_ball_nat, preimage_univ]) hŒº\n\n"}
{"name":"MeasureTheory.exists_pos_ball","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nhŒº : Ne Œº 0\n‚ä¢ Exists fun n => LT.lt 0 (Œº (Metric.ball x ‚Üën))","decl":"theorem exists_pos_ball [PseudoMetricSpace Œ±] (x : Œ±) (hŒº : Œº ‚â† 0) :\n    ‚àÉ n : ‚Ñï, 0 < Œº (Metric.ball x n) :=\n  exists_pos_preimage_ball id x hŒº\n\n"}
{"name":"MeasureTheory.exists_ne_forall_mem_nhds_pos_measure_preimage","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_5\ninst‚úù¬≥ : TopologicalSpace Œ≤\ninst‚úù¬≤ : T1Space Œ≤\ninst‚úù¬π : SecondCountableTopology Œ≤\ninst‚úù : Nonempty Œ≤\nf : Œ± ‚Üí Œ≤\nh : ‚àÄ (b : Œ≤), Filter.Frequently (fun x => Ne (f x) b) (MeasureTheory.ae Œº)\n‚ä¢ Exists fun a => Exists fun b => And (Ne a b) (And (‚àÄ (s : Set Œ≤), Membership.mem (nhds a) s ‚Üí LT.lt 0 (Œº (Set.preimage f s))) (‚àÄ (t : Set Œ≤), Membership.mem (nhds b) t ‚Üí LT.lt 0 (Œº (Set.preimage f t))))","decl":"/-- If a set has zero measure in a neighborhood of each of its points, then it has zero measure\nin a second-countable space. -/\ntheorem exists_ne_forall_mem_nhds_pos_measure_preimage {Œ≤} [TopologicalSpace Œ≤] [T1Space Œ≤]\n    [SecondCountableTopology Œ≤] [Nonempty Œ≤] {f : Œ± ‚Üí Œ≤} (h : ‚àÄ b, ‚àÉ·µê x ‚àÇŒº, f x ‚â† b) :\n    ‚àÉ a b : Œ≤, a ‚â† b ‚àß (‚àÄ s ‚àà ùìù a, 0 < Œº (f ‚Åª¬π' s)) ‚àß ‚àÄ t ‚àà ùìù b, 0 < Œº (f ‚Åª¬π' t) := by\n  -- We use an `OuterMeasure` so that the proof works without `Measurable f`\n  set m : OuterMeasure Œ≤ := OuterMeasure.map f Œº.toOuterMeasure\n  replace h : ‚àÄ b : Œ≤, m {b}·∂ú ‚â† 0 := fun b => not_eventually.mpr (h b)\n  inhabit Œ≤\n  have : m univ ‚â† 0 := ne_bot_of_le_ne_bot (h default) (measure_mono <| subset_univ _)\n  rcases exists_mem_forall_mem_nhdsWithin_pos_measure this with ‚ü®b, -, hb‚ü©\n  simp only [nhdsWithin_univ] at hb\n  rcases exists_mem_forall_mem_nhdsWithin_pos_measure (h b) with ‚ü®a, hab : a ‚â† b, ha‚ü©\n  simp only [isOpen_compl_singleton.nhdsWithin_eq hab] at ha\n  exact ‚ü®a, b, hab, ha, hb‚ü©\n\n"}
{"name":"MeasureTheory.ext_on_measurableSpace_of_generate_finite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_5\nm‚ÇÄ : MeasurableSpace Œ±\nŒº ŒΩ : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nC : Set (Set Œ±)\nhŒºŒΩ : ‚àÄ (s : Set Œ±), Membership.mem C s ‚Üí Eq (Œº s) (ŒΩ s)\nm : MeasurableSpace Œ±\nh : LE.le m m‚ÇÄ\nhA : Eq m (MeasurableSpace.generateFrom C)\nhC : IsPiSystem C\nh_univ : Eq (Œº Set.univ) (ŒΩ Set.univ)\ns : Set Œ±\nhs : MeasurableSet s\n‚ä¢ Eq (Œº s) (ŒΩ s)","decl":"/-- If two finite measures give the same mass to the whole space and coincide on a œÄ-system made\nof measurable sets, then they coincide on all sets in the œÉ-algebra generated by the œÄ-system. -/\ntheorem ext_on_measurableSpace_of_generate_finite {Œ±} (m‚ÇÄ : MeasurableSpace Œ±) {Œº ŒΩ : Measure Œ±}\n    [IsFiniteMeasure Œº] (C : Set (Set Œ±)) (hŒºŒΩ : ‚àÄ s ‚àà C, Œº s = ŒΩ s) {m : MeasurableSpace Œ±}\n    (h : m ‚â§ m‚ÇÄ) (hA : m = MeasurableSpace.generateFrom C) (hC : IsPiSystem C)\n    (h_univ : Œº Set.univ = ŒΩ Set.univ) {s : Set Œ±} (hs : MeasurableSet[m] s) : Œº s = ŒΩ s := by\n  haveI : IsFiniteMeasure ŒΩ := by\n    constructor\n    rw [‚Üê h_univ]\n    apply IsFiniteMeasure.measure_univ_lt_top\n  induction s, hs using induction_on_inter hA hC with\n  | empty => simp\n  | basic t ht => exact hŒºŒΩ t ht\n  | compl t htm iht =>\n    rw [measure_compl (h t htm) (measure_ne_top _ _), measure_compl (h t htm) (measure_ne_top _ _),\n      iht, h_univ]\n  | iUnion f hfd hfm ihf =>\n    simp [measure_iUnion, hfd, h _ (hfm _), ihf]\n\n"}
{"name":"MeasureTheory.ext_of_generate_finite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº ŒΩ : MeasureTheory.Measure Œ±\nC : Set (Set Œ±)\nhA : Eq m0 (MeasurableSpace.generateFrom C)\nhC : IsPiSystem C\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhŒºŒΩ : ‚àÄ (s : Set Œ±), Membership.mem C s ‚Üí Eq (Œº s) (ŒΩ s)\nh_univ : Eq (Œº Set.univ) (ŒΩ Set.univ)\n‚ä¢ Eq Œº ŒΩ","decl":"/-- Two finite measures are equal if they are equal on the œÄ-system generating the œÉ-algebra\n  (and `univ`). -/\ntheorem ext_of_generate_finite (C : Set (Set Œ±)) (hA : m0 = generateFrom C) (hC : IsPiSystem C)\n    [IsFiniteMeasure Œº] (hŒºŒΩ : ‚àÄ s ‚àà C, Œº s = ŒΩ s) (h_univ : Œº univ = ŒΩ univ) : Œº = ŒΩ :=\n  Measure.ext fun _s hs =>\n    ext_on_measurableSpace_of_generate_finite m0 C hŒºŒΩ le_rfl hA hC h_univ hs\n\n"}
{"name":"MeasureTheory.Measure.FiniteSpanningSetsIn.disjointed_set_eq","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nS : Œº.FiniteSpanningSetsIn (setOf fun s => MeasurableSet s)\n‚ä¢ Eq S.disjointed.set (disjointed S.set)","decl":"theorem FiniteSpanningSetsIn.disjointed_set_eq {Œº : Measure Œ±}\n    (S : Œº.FiniteSpanningSetsIn { s | MeasurableSet s }) : S.disjointed.set = disjointed S.set :=\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.exists_eq_disjoint_finiteSpanningSetsIn","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº ŒΩ : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.SigmaFinite Œº\ninst‚úù : MeasureTheory.SigmaFinite ŒΩ\n‚ä¢ Exists fun S => Exists fun T => And (Eq S.set T.set) (Pairwise (Function.onFun Disjoint S.set))","decl":"theorem exists_eq_disjoint_finiteSpanningSetsIn (Œº ŒΩ : Measure Œ±) [SigmaFinite Œº] [SigmaFinite ŒΩ] :\n    ‚àÉ (S : Œº.FiniteSpanningSetsIn { s | MeasurableSet s })\n      (T : ŒΩ.FiniteSpanningSetsIn { s | MeasurableSet s }),\n      S.set = T.set ‚àß Pairwise (Disjoint on S.set) :=\n  let S := (Œº + ŒΩ).toFiniteSpanningSetsIn.disjointed\n  ‚ü®S.ofLE (Measure.le_add_right le_rfl), S.ofLE (Measure.le_add_left le_rfl), rfl,\n    disjoint_disjointed _‚ü©\n\n"}
{"name":"MeasureTheory.Measure.FiniteAtFilter.filter_mono","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf g : Filter Œ±\nh : LE.le f g\na‚úù : Œº.FiniteAtFilter g\n‚ä¢ Œº.FiniteAtFilter f","decl":"theorem filter_mono (h : f ‚â§ g) : Œº.FiniteAtFilter g ‚Üí Œº.FiniteAtFilter f := fun ‚ü®s, hs, hŒº‚ü© =>\n  ‚ü®s, h hs, hŒº‚ü©\n\n"}
{"name":"MeasureTheory.Measure.FiniteAtFilter.inf_of_left","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf g : Filter Œ±\nh : Œº.FiniteAtFilter f\n‚ä¢ Œº.FiniteAtFilter (Min.min f g)","decl":"theorem inf_of_left (h : Œº.FiniteAtFilter f) : Œº.FiniteAtFilter (f ‚äì g) :=\n  h.filter_mono inf_le_left\n\n"}
{"name":"MeasureTheory.Measure.FiniteAtFilter.inf_of_right","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf g : Filter Œ±\nh : Œº.FiniteAtFilter g\n‚ä¢ Œº.FiniteAtFilter (Min.min f g)","decl":"theorem inf_of_right (h : Œº.FiniteAtFilter g) : Œº.FiniteAtFilter (f ‚äì g) :=\n  h.filter_mono inf_le_right\n\n"}
{"name":"MeasureTheory.Measure.FiniteAtFilter.inf_ae_iff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Filter Œ±\n‚ä¢ Iff (Œº.FiniteAtFilter (Min.min f (MeasureTheory.ae Œº))) (Œº.FiniteAtFilter f)","decl":"@[simp]\ntheorem inf_ae_iff : Œº.FiniteAtFilter (f ‚äì ae Œº) ‚Üî Œº.FiniteAtFilter f := by\n  refine ‚ü®?_, fun h => h.filter_mono inf_le_left‚ü©\n  rintro ‚ü®s, ‚ü®t, ht, u, hu, rfl‚ü©, hŒº‚ü©\n  suffices Œº t ‚â§ Œº (t ‚à© u) from ‚ü®t, ht, this.trans_lt hŒº‚ü©\n  exact measure_mono_ae (mem_of_superset hu fun x hu ht => ‚ü®ht, hu‚ü©)\n\n"}
{"name":"MeasureTheory.Measure.FiniteAtFilter.of_inf_ae","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Filter Œ±\na‚úù : Œº.FiniteAtFilter (Min.min f (MeasureTheory.ae Œº))\n‚ä¢ Œº.FiniteAtFilter f","decl":"alias ‚ü®of_inf_ae, _‚ü© := inf_ae_iff\n\n"}
{"name":"MeasureTheory.Measure.FiniteAtFilter.filter_mono_ae","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf g : Filter Œ±\nh : LE.le (Min.min f (MeasureTheory.ae Œº)) g\nhg : Œº.FiniteAtFilter g\n‚ä¢ Œº.FiniteAtFilter f","decl":"theorem filter_mono_ae (h : f ‚äì (ae Œº) ‚â§ g) (hg : Œº.FiniteAtFilter g) : Œº.FiniteAtFilter f :=\n  inf_ae_iff.1 (hg.filter_mono h)\n\n"}
{"name":"MeasureTheory.Measure.FiniteAtFilter.measure_mono","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº ŒΩ : MeasureTheory.Measure Œ±\nf : Filter Œ±\nh : LE.le Œº ŒΩ\na‚úù : ŒΩ.FiniteAtFilter f\n‚ä¢ Œº.FiniteAtFilter f","decl":"protected theorem measure_mono (h : Œº ‚â§ ŒΩ) : ŒΩ.FiniteAtFilter f ‚Üí Œº.FiniteAtFilter f :=\n  fun ‚ü®s, hs, hŒΩ‚ü© => ‚ü®s, hs, (Measure.le_iff'.1 h s).trans_lt hŒΩ‚ü©\n\n"}
{"name":"MeasureTheory.Measure.FiniteAtFilter.mono","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº ŒΩ : MeasureTheory.Measure Œ±\nf g : Filter Œ±\nhf : LE.le f g\nhŒº : LE.le Œº ŒΩ\na‚úù : ŒΩ.FiniteAtFilter g\n‚ä¢ Œº.FiniteAtFilter f","decl":"@[mono]\nprotected theorem mono (hf : f ‚â§ g) (hŒº : Œº ‚â§ ŒΩ) : ŒΩ.FiniteAtFilter g ‚Üí Œº.FiniteAtFilter f :=\n  fun h => (h.filter_mono hf).measure_mono hŒº\n\n"}
{"name":"MeasureTheory.Measure.FiniteAtFilter.eventually","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Filter Œ±\nh : Œº.FiniteAtFilter f\n‚ä¢ Filter.Eventually (fun s => LT.lt (Œº s) Top.top) f.smallSets","decl":"protected theorem eventually (h : Œº.FiniteAtFilter f) : ‚àÄ·∂† s in f.smallSets, Œº s < ‚àû :=\n  (eventually_smallSets' fun _s _t hst ht => (measure_mono hst).trans_lt ht).2 h\n\n"}
{"name":"MeasureTheory.Measure.FiniteAtFilter.filterSup","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf g : Filter Œ±\na‚úù¬π : Œº.FiniteAtFilter f\na‚úù : Œº.FiniteAtFilter g\n‚ä¢ Œº.FiniteAtFilter (Max.max f g)","decl":"theorem filterSup : Œº.FiniteAtFilter f ‚Üí Œº.FiniteAtFilter g ‚Üí Œº.FiniteAtFilter (f ‚äî g) :=\n  fun ‚ü®s, hsf, hsŒº‚ü© ‚ü®t, htg, htŒº‚ü© =>\n  ‚ü®s ‚à™ t, union_mem_sup hsf htg, (measure_union_le s t).trans_lt (ENNReal.add_lt_top.2 ‚ü®hsŒº, htŒº‚ü©)‚ü©\n\n"}
{"name":"MeasureTheory.Measure.finiteAt_nhdsWithin","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\n_m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\nx : Œ±\ns : Set Œ±\n‚ä¢ Œº.FiniteAtFilter (nhdsWithin x s)","decl":"theorem finiteAt_nhdsWithin [TopologicalSpace Œ±] {_m0 : MeasurableSpace Œ±} (Œº : Measure Œ±)\n    [IsLocallyFiniteMeasure Œº] (x : Œ±) (s : Set Œ±) : Œº.FiniteAtFilter (ùìù[s] x) :=\n  (finiteAt_nhds Œº x).inf_of_left\n\n"}
{"name":"MeasureTheory.Measure.finiteAt_principal","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\n‚ä¢ Iff (Œº.FiniteAtFilter (Filter.principal s)) (LT.lt (Œº s) Top.top)","decl":"@[simp]\ntheorem finiteAt_principal : Œº.FiniteAtFilter (ùìü s) ‚Üî Œº s < ‚àû :=\n  ‚ü®fun ‚ü®_t, ht, hŒº‚ü© => (measure_mono ht).trans_lt hŒº, fun h => ‚ü®s, mem_principal_self s, h‚ü©‚ü©\n\n"}
{"name":"MeasureTheory.Measure.isLocallyFiniteMeasure_of_le","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\n_m : MeasurableSpace Œ±\nŒº ŒΩ : MeasureTheory.Measure Œ±\nH : MeasureTheory.IsLocallyFiniteMeasure Œº\nh : LE.le ŒΩ Œº\n‚ä¢ MeasureTheory.IsLocallyFiniteMeasure ŒΩ","decl":"theorem isLocallyFiniteMeasure_of_le [TopologicalSpace Œ±] {_m : MeasurableSpace Œ±} {Œº ŒΩ : Measure Œ±}\n    [H : IsLocallyFiniteMeasure Œº] (h : ŒΩ ‚â§ Œº) : IsLocallyFiniteMeasure ŒΩ :=\n  let F := H.finiteAtNhds\n  ‚ü®fun x => (F x).measure_mono h‚ü©\n\n"}
{"name":"IsCompact.exists_open_superset_measure_lt_top'","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\nh : IsCompact s\nhŒº : ‚àÄ (x : Œ±), Membership.mem s x ‚Üí Œº.FiniteAtFilter (nhds x)\n‚ä¢ Exists fun U => And (Superset U s) (And (IsOpen U) (LT.lt (Œº U) Top.top))","decl":"/-- If `s` is a compact set and `Œº` is finite at `ùìù x` for every `x ‚àà s`, then `s` admits an open\nsuperset of finite measure. -/\ntheorem exists_open_superset_measure_lt_top' (h : IsCompact s)\n    (hŒº : ‚àÄ x ‚àà s, Œº.FiniteAtFilter (ùìù x)) : ‚àÉ U ‚äá s, IsOpen U ‚àß Œº U < ‚àû := by\n  refine IsCompact.induction_on h ?_ ?_ ?_ ?_\n  ¬∑ use ‚àÖ\n    simp [Superset]\n  ¬∑ rintro s t hst ‚ü®U, htU, hUo, hU‚ü©\n    exact ‚ü®U, hst.trans htU, hUo, hU‚ü©\n  ¬∑ rintro s t ‚ü®U, hsU, hUo, hU‚ü© ‚ü®V, htV, hVo, hV‚ü©\n    refine\n      ‚ü®U ‚à™ V, union_subset_union hsU htV, hUo.union hVo,\n        (measure_union_le _ _).trans_lt <| ENNReal.add_lt_top.2 ‚ü®hU, hV‚ü©‚ü©\n  ¬∑ intro x hx\n    rcases (hŒº x hx).exists_mem_basis (nhds_basis_opens _) with ‚ü®U, ‚ü®hx, hUo‚ü©, hU‚ü©\n    exact ‚ü®U, nhdsWithin_le_nhds (hUo.mem_nhds hx), U, Subset.rfl, hUo, hU‚ü©\n\n"}
{"name":"IsCompact.exists_open_superset_measure_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : MeasurableSpace Œ±\ns : Set Œ±\nh : IsCompact s\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\n‚ä¢ Exists fun U => And (Superset U s) (And (IsOpen U) (LT.lt (Œº U) Top.top))","decl":"/-- If `s` is a compact set and `Œº` is a locally finite measure, then `s` admits an open superset of\nfinite measure. -/\ntheorem exists_open_superset_measure_lt_top (h : IsCompact s) (Œº : Measure Œ±)\n    [IsLocallyFiniteMeasure Œº] : ‚àÉ U ‚äá s, IsOpen U ‚àß Œº U < ‚àû :=\n  h.exists_open_superset_measure_lt_top' fun x _ => Œº.finiteAt_nhds x\n\n"}
{"name":"IsCompact.measure_lt_top_of_nhdsWithin","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\nh : IsCompact s\nhŒº : ‚àÄ (x : Œ±), Membership.mem s x ‚Üí Œº.FiniteAtFilter (nhdsWithin x s)\n‚ä¢ LT.lt (Œº s) Top.top","decl":"theorem measure_lt_top_of_nhdsWithin (h : IsCompact s) (hŒº : ‚àÄ x ‚àà s, Œº.FiniteAtFilter (ùìù[s] x)) :\n    Œº s < ‚àû :=\n  IsCompact.induction_on h (by simp) (fun _ _ hst ht => (measure_mono hst).trans_lt ht)\n    (fun s t hs ht => (measure_union_le s t).trans_lt (ENNReal.add_lt_top.2 ‚ü®hs, ht‚ü©)) hŒº\n\n"}
{"name":"IsCompact.measure_zero_of_nhdsWithin","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\nhs : IsCompact s\na‚úù : ‚àÄ (a : Œ±), Membership.mem s a ‚Üí Exists fun t => And (Membership.mem (nhdsWithin a s) t) (Eq (Œº t) 0)\n‚ä¢ Eq (Œº s) 0","decl":"theorem measure_zero_of_nhdsWithin (hs : IsCompact s) :\n    (‚àÄ a ‚àà s, ‚àÉ t ‚àà ùìù[s] a, Œº t = 0) ‚Üí Œº s = 0 := by\n  simpa only [‚Üê compl_mem_ae_iff] using hs.compl_mem_sets_of_nhdsWithin\n\n"}
{"name":"isFiniteMeasureOnCompacts_of_isLocallyFiniteMeasure","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\nx‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\n‚ä¢ MeasureTheory.IsFiniteMeasureOnCompacts Œº","decl":"instance (priority := 100) isFiniteMeasureOnCompacts_of_isLocallyFiniteMeasure [TopologicalSpace Œ±]\n    {_ : MeasurableSpace Œ±} {Œº : Measure Œ±} [IsLocallyFiniteMeasure Œº] :\n    IsFiniteMeasureOnCompacts Œº :=\n  ‚ü®fun _s hs => hs.measure_lt_top_of_nhdsWithin fun _ _ => Œº.finiteAt_nhdsWithin _ _‚ü©\n\n"}
{"name":"isFiniteMeasure_iff_isFiniteMeasureOnCompacts_of_compactSpace","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompactSpace Œ±\n‚ä¢ Iff (MeasureTheory.IsFiniteMeasure Œº) (MeasureTheory.IsFiniteMeasureOnCompacts Œº)","decl":"theorem isFiniteMeasure_iff_isFiniteMeasureOnCompacts_of_compactSpace [TopologicalSpace Œ±]\n    [MeasurableSpace Œ±] {Œº : Measure Œ±} [CompactSpace Œ±] :\n    IsFiniteMeasure Œº ‚Üî IsFiniteMeasureOnCompacts Œº := by\n  constructor <;> intros\n  ¬∑ infer_instance\n  ¬∑ exact CompactSpace.isFiniteMeasure\n\n"}
{"name":"MeasureTheory.Measure.finiteSpanningSetsInOpen'_def","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_5\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : SecondCountableTopology Œ±\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\n‚ä¢ Eq Œº.finiteSpanningSetsInOpen' (letFun ‚ãØ fun H => H.some)","decl":"/-- A locally finite measure on a second countable topological space admits a finite spanning\nsequence of open sets. -/\nnoncomputable irreducible_def MeasureTheory.Measure.finiteSpanningSetsInOpen' [TopologicalSpace Œ±]\n  [SecondCountableTopology Œ±] {m : MeasurableSpace Œ±} (Œº : Measure Œ±) [IsLocallyFiniteMeasure Œº] :\n  Œº.FiniteSpanningSetsIn { K | IsOpen K } := by\n  suffices H : Nonempty (Œº.FiniteSpanningSetsIn { K | IsOpen K }) from H.some\n  cases isEmpty_or_nonempty Œ±\n  ¬∑ exact\n      ‚ü®{  set := fun _ => ‚àÖ\n          set_mem := fun _ => by simp\n          finite := fun _ => by simp\n          spanning := by simp [eq_iff_true_of_subsingleton] }‚ü©\n  inhabit Œ±\n  let S : Set (Set Œ±) := { s | IsOpen s ‚àß Œº s < ‚àû }\n  obtain ‚ü®T, T_count, TS, hT‚ü© : ‚àÉ T : Set (Set Œ±), T.Countable ‚àß T ‚äÜ S ‚àß ‚ãÉ‚ÇÄ T = ‚ãÉ‚ÇÄ S :=\n    isOpen_sUnion_countable S fun s hs => hs.1\n  rw [Œº.isTopologicalBasis_isOpen_lt_top.sUnion_eq] at hT\n  have T_ne : T.Nonempty := by\n    by_contra h'T\n    rw [not_nonempty_iff_eq_empty.1 h'T, sUnion_empty] at hT\n    simpa only [‚Üê hT] using mem_univ (default : Œ±)\n  obtain ‚ü®f, hf‚ü© : ‚àÉ f : ‚Ñï ‚Üí Set Œ±, T = range f := T_count.exists_eq_range T_ne\n  have fS : ‚àÄ n, f n ‚àà S := by\n    intro n\n    apply TS\n    rw [hf]\n    exact mem_range_self n\n  refine\n    ‚ü®{  set := f\n        set_mem := fun n => (fS n).1\n        finite := fun n => (fS n).2\n        spanning := ?_ }‚ü©\n  refine eq_univ_of_forall fun x => ?_\n  obtain ‚ü®t, tT, xt‚ü© : ‚àÉ t : Set Œ±, t ‚àà range f ‚àß x ‚àà t := by\n    have : x ‚àà ‚ãÉ‚ÇÄ T := by simp only [hT, mem_univ]\n    simpa only [mem_sUnion, exists_prop, ‚Üê hf]\n  obtain ‚ü®n, rfl‚ü© : ‚àÉ n : ‚Ñï, f n = t := by simpa only using tT\n  exact mem_iUnion_of_mem _ xt\n\n"}
{"name":"measure_Icc_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : CompactIccSpace Œ±\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\na b : Œ±\n‚ä¢ LT.lt (Œº (Set.Icc a b)) Top.top","decl":"theorem measure_Icc_lt_top : Œº (Icc a b) < ‚àû :=\n  isCompact_Icc.measure_lt_top\n\n"}
{"name":"measure_Ico_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : CompactIccSpace Œ±\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\na b : Œ±\n‚ä¢ LT.lt (Œº (Set.Ico a b)) Top.top","decl":"theorem measure_Ico_lt_top : Œº (Ico a b) < ‚àû :=\n  (measure_mono Ico_subset_Icc_self).trans_lt measure_Icc_lt_top\n\n"}
{"name":"measure_Ioc_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : CompactIccSpace Œ±\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\na b : Œ±\n‚ä¢ LT.lt (Œº (Set.Ioc a b)) Top.top","decl":"theorem measure_Ioc_lt_top : Œº (Ioc a b) < ‚àû :=\n  (measure_mono Ioc_subset_Icc_self).trans_lt measure_Icc_lt_top\n\n"}
{"name":"measure_Ioo_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : CompactIccSpace Œ±\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\na b : Œ±\n‚ä¢ LT.lt (Œº (Set.Ioo a b)) Top.top","decl":"theorem measure_Ioo_lt_top : Œº (Ioo a b) < ‚àû :=\n  (measure_mono Ioo_subset_Icc_self).trans_lt measure_Icc_lt_top\n\n"}
