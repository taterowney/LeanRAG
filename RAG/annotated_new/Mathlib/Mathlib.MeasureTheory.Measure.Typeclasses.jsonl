{"name":"MeasureTheory.IsFiniteMeasure.measure_univ_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nself : MeasureTheory.IsFiniteMeasure μ\n⊢ LT.lt (μ Set.univ) Top.top","decl":"/-- A measure `μ` is called finite if `μ univ < ∞`. -/\n@[mk_iff]\nclass IsFiniteMeasure (μ : Measure α) : Prop where\n  measure_univ_lt_top : μ univ < ∞\n\n"}
{"name":"MeasureTheory.isFiniteMeasure_iff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Iff (MeasureTheory.IsFiniteMeasure μ) (LT.lt (μ Set.univ) Top.top)","decl":"/-- A measure `μ` is called finite if `μ univ < ∞`. -/\n@[mk_iff]\nclass IsFiniteMeasure (μ : Measure α) : Prop where\n  measure_univ_lt_top : μ univ < ∞\n\n"}
{"name":"MeasureTheory.not_isFiniteMeasure_iff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Iff (Not (MeasureTheory.IsFiniteMeasure μ)) (Eq (μ Set.univ) Top.top)","decl":"lemma not_isFiniteMeasure_iff : ¬IsFiniteMeasure μ ↔ μ univ = ∞ := by simp [isFiniteMeasure_iff]\n\n"}
{"name":"MeasureTheory.isFiniteMeasure_restrict","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ Iff (MeasureTheory.IsFiniteMeasure (μ.restrict s)) (Ne (μ s) Top.top)","decl":"lemma isFiniteMeasure_restrict : IsFiniteMeasure (μ.restrict s) ↔ μ s ≠ ∞ := by\n  simp [isFiniteMeasure_iff, lt_top_iff_ne_top]\n\n"}
{"name":"MeasureTheory.Restrict.isFiniteMeasure","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\nhs : Fact (LT.lt (μ s) Top.top)\n⊢ MeasureTheory.IsFiniteMeasure (μ.restrict s)","decl":"instance Restrict.isFiniteMeasure (μ : Measure α) [hs : Fact (μ s < ∞)] :\n    IsFiniteMeasure (μ.restrict s) :=\n  ⟨by simpa using hs.elim⟩\n\n"}
{"name":"MeasureTheory.measure_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : Set α\n⊢ LT.lt (μ s) Top.top","decl":"@[simp]\ntheorem measure_lt_top (μ : Measure α) [IsFiniteMeasure μ] (s : Set α) : μ s < ∞ :=\n  (measure_mono (subset_univ s)).trans_lt IsFiniteMeasure.measure_univ_lt_top\n\n"}
{"name":"MeasureTheory.isFiniteMeasureRestrict","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nh : MeasureTheory.IsFiniteMeasure μ\n⊢ MeasureTheory.IsFiniteMeasure (μ.restrict s)","decl":"instance isFiniteMeasureRestrict (μ : Measure α) (s : Set α) [h : IsFiniteMeasure μ] :\n    IsFiniteMeasure (μ.restrict s) := ⟨by simp⟩\n\n"}
{"name":"MeasureTheory.measure_ne_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : Set α\n⊢ Ne (μ s) Top.top","decl":"@[simp, aesop (rule_sets := [finiteness]) safe apply]\ntheorem measure_ne_top (μ : Measure α) [IsFiniteMeasure μ] (s : Set α) : μ s ≠ ∞ :=\n  ne_of_lt (measure_lt_top μ s)\n\n"}
{"name":"MeasureTheory.measure_compl_le_add_of_le_add","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhs : MeasurableSet s\nht : MeasurableSet t\nε : ENNReal\nh : LE.le (μ s) (HAdd.hAdd (μ t) ε)\n⊢ LE.le (μ (HasCompl.compl t)) (HAdd.hAdd (μ (HasCompl.compl s)) ε)","decl":"theorem measure_compl_le_add_of_le_add [IsFiniteMeasure μ] (hs : MeasurableSet s)\n    (ht : MeasurableSet t) {ε : ℝ≥0∞} (h : μ s ≤ μ t + ε) : μ tᶜ ≤ μ sᶜ + ε := by\n  rw [measure_compl ht (measure_ne_top μ _), measure_compl hs (measure_ne_top μ _),\n    tsub_le_iff_right]\n  calc\n    μ univ = μ univ - μ s + μ s := (tsub_add_cancel_of_le <| measure_mono s.subset_univ).symm\n    _ ≤ μ univ - μ s + (μ t + ε) := add_le_add_left h _\n    _ = _ := by rw [add_right_comm, add_assoc]\n\n"}
{"name":"MeasureTheory.measure_compl_le_add_iff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhs : MeasurableSet s\nht : MeasurableSet t\nε : ENNReal\n⊢ Iff (LE.le (μ (HasCompl.compl s)) (HAdd.hAdd (μ (HasCompl.compl t)) ε)) (LE.le (μ t) (HAdd.hAdd (μ s) ε))","decl":"theorem measure_compl_le_add_iff [IsFiniteMeasure μ] (hs : MeasurableSet s) (ht : MeasurableSet t)\n    {ε : ℝ≥0∞} : μ sᶜ ≤ μ tᶜ + ε ↔ μ t ≤ μ s + ε :=\n  ⟨fun h => compl_compl s ▸ compl_compl t ▸ measure_compl_le_add_of_le_add hs.compl ht.compl h,\n    measure_compl_le_add_of_le_add ht hs⟩\n\n"}
{"name":"MeasureTheory.coe_measureUnivNNReal","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Eq (↑(MeasureTheory.measureUnivNNReal μ)) (μ Set.univ)","decl":"@[simp]\ntheorem coe_measureUnivNNReal (μ : Measure α) [IsFiniteMeasure μ] :\n    ↑(measureUnivNNReal μ) = μ univ :=\n  ENNReal.coe_toNNReal (measure_ne_top μ univ)\n\n"}
{"name":"MeasureTheory.isFiniteMeasureZero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\n⊢ MeasureTheory.IsFiniteMeasure 0","decl":"instance isFiniteMeasureZero : IsFiniteMeasure (0 : Measure α) :=\n  ⟨by simp⟩\n\n"}
{"name":"MeasureTheory.isFiniteMeasureOfIsEmpty","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : IsEmpty α\n⊢ MeasureTheory.IsFiniteMeasure μ","decl":"instance (priority := 50) isFiniteMeasureOfIsEmpty [IsEmpty α] : IsFiniteMeasure μ := by\n  rw [eq_zero_of_isEmpty μ]\n  infer_instance\n\n"}
{"name":"MeasureTheory.measureUnivNNReal_zero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\n⊢ Eq (MeasureTheory.measureUnivNNReal 0) 0","decl":"@[simp]\ntheorem measureUnivNNReal_zero : measureUnivNNReal (0 : Measure α) = 0 :=\n  rfl\n\n"}
{"name":"MeasureTheory.isFiniteMeasureAdd","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : MeasureTheory.IsFiniteMeasure ν\n⊢ MeasureTheory.IsFiniteMeasure (HAdd.hAdd μ ν)","decl":"instance isFiniteMeasureAdd [IsFiniteMeasure μ] [IsFiniteMeasure ν] : IsFiniteMeasure (μ + ν) where\n  measure_univ_lt_top := by\n    rw [Measure.coe_add, Pi.add_apply, ENNReal.add_lt_top]\n    exact ⟨measure_lt_top _ _, measure_lt_top _ _⟩\n\n"}
{"name":"MeasureTheory.isFiniteMeasureSMulNNReal","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nr : NNReal\n⊢ MeasureTheory.IsFiniteMeasure (HSMul.hSMul r μ)","decl":"instance isFiniteMeasureSMulNNReal [IsFiniteMeasure μ] {r : ℝ≥0} : IsFiniteMeasure (r • μ) where\n  measure_univ_lt_top := ENNReal.mul_lt_top ENNReal.coe_lt_top (measure_lt_top _ _)\n\n"}
{"name":"MeasureTheory.IsFiniteMeasure.average","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ MeasureTheory.IsFiniteMeasure (HSMul.hSMul (Inv.inv (μ Set.univ)) μ)","decl":"instance IsFiniteMeasure.average : IsFiniteMeasure ((μ univ)⁻¹ • μ) where\n  measure_univ_lt_top := by\n    rw [smul_apply, smul_eq_mul, ← ENNReal.div_eq_inv_mul]\n    exact ENNReal.div_self_le_one.trans_lt ENNReal.one_lt_top\n\n"}
{"name":"MeasureTheory.isFiniteMeasureSMulOfNNRealTower","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nR : Type u_5\ninst✝⁴ : SMul R NNReal\ninst✝³ : SMul R ENNReal\ninst✝² : IsScalarTower R NNReal ENNReal\ninst✝¹ : IsScalarTower R ENNReal ENNReal\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nr : R\n⊢ MeasureTheory.IsFiniteMeasure (HSMul.hSMul r μ)","decl":"instance isFiniteMeasureSMulOfNNRealTower {R} [SMul R ℝ≥0] [SMul R ℝ≥0∞] [IsScalarTower R ℝ≥0 ℝ≥0∞]\n    [IsScalarTower R ℝ≥0∞ ℝ≥0∞] [IsFiniteMeasure μ] {r : R} : IsFiniteMeasure (r • μ) := by\n  rw [← smul_one_smul ℝ≥0 r μ]\n  infer_instance\n\n"}
{"name":"MeasureTheory.isFiniteMeasure_of_le","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nν μ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nh : LE.le ν μ\n⊢ MeasureTheory.IsFiniteMeasure ν","decl":"theorem isFiniteMeasure_of_le (μ : Measure α) [IsFiniteMeasure μ] (h : ν ≤ μ) : IsFiniteMeasure ν :=\n  { measure_univ_lt_top := (h Set.univ).trans_lt (measure_lt_top _ _) }\n\n"}
{"name":"MeasureTheory.Measure.isFiniteMeasure_map","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace β\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : α → β\n⊢ MeasureTheory.IsFiniteMeasure (MeasureTheory.Measure.map f μ)","decl":"@[instance]\ntheorem Measure.isFiniteMeasure_map {m : MeasurableSpace α} (μ : Measure α) [IsFiniteMeasure μ]\n    (f : α → β) : IsFiniteMeasure (μ.map f) := by\n  by_cases hf : AEMeasurable f μ\n  · constructor\n    rw [map_apply_of_aemeasurable hf MeasurableSet.univ]\n    exact measure_lt_top μ _\n  · rw [map_of_not_aemeasurable hf]\n    exact MeasureTheory.isFiniteMeasureZero\n\n"}
{"name":"MeasureTheory.IsFiniteMeasure_comap","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nβ : Type u_2\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : β → α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ MeasureTheory.IsFiniteMeasure (MeasureTheory.Measure.comap f μ)","decl":"instance IsFiniteMeasure_comap (f : β → α) [IsFiniteMeasure μ] : IsFiniteMeasure (μ.comap f) where\n  measure_univ_lt_top := by\n    by_cases hf : Injective f ∧ ∀ s, MeasurableSet s → NullMeasurableSet (f '' s) μ\n    · rw [Measure.comap_apply₀ _ _ hf.1 hf.2 MeasurableSet.univ.nullMeasurableSet]\n      exact measure_lt_top μ _\n    · rw [Measure.comap, dif_neg hf]\n      exact zero_lt_top\n\n"}
{"name":"MeasureTheory.measureUnivNNReal_eq_zero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Iff (Eq (MeasureTheory.measureUnivNNReal μ) 0) (Eq μ 0)","decl":"@[simp]\ntheorem measureUnivNNReal_eq_zero [IsFiniteMeasure μ] : measureUnivNNReal μ = 0 ↔ μ = 0 := by\n  rw [← MeasureTheory.Measure.measure_univ_eq_zero, ← coe_measureUnivNNReal]\n  norm_cast\n\n"}
{"name":"MeasureTheory.measureUnivNNReal_pos","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhμ : Ne μ 0\n⊢ LT.lt 0 (MeasureTheory.measureUnivNNReal μ)","decl":"theorem measureUnivNNReal_pos [IsFiniteMeasure μ] (hμ : μ ≠ 0) : 0 < measureUnivNNReal μ := by\n  contrapose! hμ\n  simpa [measureUnivNNReal_eq_zero, Nat.le_zero] using hμ\n\n"}
{"name":"MeasureTheory.Measure.le_of_add_le_add_left","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν₁ ν₂ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nA2 : LE.le (HAdd.hAdd μ ν₁) (HAdd.hAdd μ ν₂)\n⊢ LE.le ν₁ ν₂","decl":"/-- `le_of_add_le_add_left` is normally applicable to `OrderedCancelAddCommMonoid`,\nbut it holds for measures with the additional assumption that μ is finite. -/\ntheorem Measure.le_of_add_le_add_left [IsFiniteMeasure μ] (A2 : μ + ν₁ ≤ μ + ν₂) : ν₁ ≤ ν₂ :=\n  fun S => ENNReal.le_of_add_le_add_left (MeasureTheory.measure_ne_top μ S) (A2 S)\n\n"}
{"name":"MeasureTheory.summable_measure_toReal","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhμ : MeasureTheory.IsFiniteMeasure μ\nf : Nat → Set α\nhf₁ : ∀ (i : Nat), MeasurableSet (f i)\nhf₂ : Pairwise (Function.onFun Disjoint f)\n⊢ Summable fun x => (μ (f x)).toReal","decl":"theorem summable_measure_toReal [hμ : IsFiniteMeasure μ] {f : ℕ → Set α}\n    (hf₁ : ∀ i : ℕ, MeasurableSet (f i)) (hf₂ : Pairwise (Disjoint on f)) :\n    Summable fun x => (μ (f x)).toReal := by\n  apply ENNReal.summable_toReal\n  rw [← MeasureTheory.measure_iUnion hf₂ hf₁]\n  exact ne_of_lt (measure_lt_top _ _)\n\n"}
{"name":"MeasureTheory.ae_eq_univ_iff_measure_eq","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhs : MeasureTheory.NullMeasurableSet s μ\n⊢ Iff ((MeasureTheory.ae μ).EventuallyEq s Set.univ) (Eq (μ s) (μ Set.univ))","decl":"theorem ae_eq_univ_iff_measure_eq [IsFiniteMeasure μ] (hs : NullMeasurableSet s μ) :\n    s =ᵐ[μ] univ ↔ μ s = μ univ :=\n  ⟨measure_congr, fun h ↦\n    ae_eq_of_subset_of_measure_ge (subset_univ _) h.ge hs (measure_ne_top _ _)⟩\n\n"}
{"name":"MeasureTheory.ae_iff_measure_eq","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\np : α → Prop\nhp : MeasureTheory.NullMeasurableSet (setOf fun a => p a) μ\n⊢ Iff (Filter.Eventually (fun a => p a) (MeasureTheory.ae μ)) (Eq (μ (setOf fun a => p a)) (μ Set.univ))","decl":"theorem ae_iff_measure_eq [IsFiniteMeasure μ] {p : α → Prop}\n    (hp : NullMeasurableSet { a | p a } μ) : (∀ᵐ a ∂μ, p a) ↔ μ { a | p a } = μ univ := by\n  rw [← ae_eq_univ_iff_measure_eq hp, eventuallyEq_univ, eventually_iff]\n\n"}
{"name":"MeasureTheory.ae_mem_iff_measure_eq","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : Set α\nhs : MeasureTheory.NullMeasurableSet s μ\n⊢ Iff (Filter.Eventually (fun a => Membership.mem s a) (MeasureTheory.ae μ)) (Eq (μ s) (μ Set.univ))","decl":"theorem ae_mem_iff_measure_eq [IsFiniteMeasure μ] {s : Set α} (hs : NullMeasurableSet s μ) :\n    (∀ᵐ a ∂μ, a ∈ s) ↔ μ s = μ univ :=\n  ae_iff_measure_eq hs\n\n"}
{"name":"MeasureTheory.tendsto_measure_biUnion_Ici_zero_of_pairwise_disjoint","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"X : Type u_5\ninst✝¹ : MeasurableSpace X\nμ : MeasureTheory.Measure X\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nEs : Nat → Set X\nEs_mble : ∀ (i : Nat), MeasureTheory.NullMeasurableSet (Es i) μ\nEs_disj : Pairwise fun n m => Disjoint (Es n) (Es m)\n⊢ Filter.Tendsto (Function.comp ⇑μ fun n => Set.iUnion fun i => Set.iUnion fun h => Es i) Filter.atTop (nhds 0)","decl":"lemma tendsto_measure_biUnion_Ici_zero_of_pairwise_disjoint\n    {X : Type*} [MeasurableSpace X] {μ : Measure X} [IsFiniteMeasure μ]\n    {Es : ℕ → Set X} (Es_mble : ∀ i, NullMeasurableSet (Es i) μ)\n    (Es_disj : Pairwise fun n m ↦ Disjoint (Es n) (Es m)) :\n    Tendsto (μ ∘ fun n ↦ ⋃ i ≥ n, Es i) atTop (𝓝 0) := by\n  have decr : Antitone fun n ↦ ⋃ i ≥ n, Es i :=\n    fun n m hnm ↦ biUnion_mono (fun _ hi ↦ le_trans hnm hi) (fun _ _ ↦ subset_rfl)\n  have nothing : ⋂ n, ⋃ i ≥ n, Es i = ∅ := by\n    apply subset_antisymm _ (empty_subset _)\n    intro x hx\n    simp only [mem_iInter, mem_iUnion, exists_prop] at hx\n    obtain ⟨j, _, x_in_Es_j⟩ := hx 0\n    obtain ⟨k, k_gt_j, x_in_Es_k⟩ := hx (j+1)\n    have oops := (Es_disj (Nat.ne_of_lt k_gt_j)).ne_of_mem x_in_Es_j x_in_Es_k\n    contradiction\n  have key := tendsto_measure_iInter_atTop (μ := μ) (fun n ↦ by measurability)\n    decr ⟨0, measure_ne_top _ _⟩\n  simp only [nothing, measure_empty] at key\n  convert key\n\n"}
{"name":"MeasureTheory.abs_toReal_measure_sub_le_measure_symmDiff'","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nhs : MeasureTheory.NullMeasurableSet s μ\nht : MeasureTheory.NullMeasurableSet t μ\nhs' : Ne (μ s) Top.top\nht' : Ne (μ t) Top.top\n⊢ LE.le (abs (HSub.hSub (μ s).toReal (μ t).toReal)) (μ (symmDiff s t)).toReal","decl":"theorem abs_toReal_measure_sub_le_measure_symmDiff'\n    (hs : NullMeasurableSet s μ) (ht : NullMeasurableSet t μ) (hs' : μ s ≠ ∞) (ht' : μ t ≠ ∞) :\n    |(μ s).toReal - (μ t).toReal| ≤ (μ (s ∆ t)).toReal := by\n  have hst : μ (s \\ t) ≠ ∞ := (measure_lt_top_of_subset diff_subset hs').ne\n  have hts : μ (t \\ s) ≠ ∞ := (measure_lt_top_of_subset diff_subset ht').ne\n  suffices (μ s).toReal - (μ t).toReal = (μ (s \\ t)).toReal - (μ (t \\ s)).toReal by\n    rw [this, measure_symmDiff_eq hs ht, ENNReal.toReal_add hst hts]\n    convert abs_sub (μ (s \\ t)).toReal (μ (t \\ s)).toReal <;> simp\n  rw [measure_diff' s ht ht', measure_diff' t hs hs',\n    ENNReal.toReal_sub_of_le measure_le_measure_union_right (measure_union_ne_top hs' ht'),\n    ENNReal.toReal_sub_of_le measure_le_measure_union_right (measure_union_ne_top ht' hs'),\n    union_comm t s]\n  abel\n\n"}
{"name":"MeasureTheory.abs_toReal_measure_sub_le_measure_symmDiff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhs : MeasureTheory.NullMeasurableSet s μ\nht : MeasureTheory.NullMeasurableSet t μ\n⊢ LE.le (abs (HSub.hSub (μ s).toReal (μ t).toReal)) (μ (symmDiff s t)).toReal","decl":"theorem abs_toReal_measure_sub_le_measure_symmDiff [IsFiniteMeasure μ]\n    (hs : NullMeasurableSet s μ) (ht : NullMeasurableSet t μ) :\n    |(μ s).toReal - (μ t).toReal| ≤ (μ (s ∆ t)).toReal :=\n  abs_toReal_measure_sub_le_measure_symmDiff' hs ht (measure_ne_top μ s) (measure_ne_top μ t)\n\n"}
{"name":"MeasureTheory.instIsFiniteMeasureSumMeasure","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nι : Type u_4\nm0 : MeasurableSpace α\ns : Finset ι\nμ : ι → MeasureTheory.Measure α\ninst✝ : ∀ (i : ι), MeasureTheory.IsFiniteMeasure (μ i)\n⊢ MeasureTheory.IsFiniteMeasure (s.sum fun i => μ i)","decl":"instance {s : Finset ι} {μ : ι → Measure α} [∀ i, IsFiniteMeasure (μ i)] :\n    IsFiniteMeasure (∑ i ∈ s, μ i) where measure_univ_lt_top := by simp [measure_lt_top]\n\n"}
{"name":"MeasureTheory.instIsFiniteMeasureSumOfFinite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nι : Type u_4\nm0 : MeasurableSpace α\ninst✝¹ : Finite ι\nμ : ι → MeasureTheory.Measure α\ninst✝ : ∀ (i : ι), MeasureTheory.IsFiniteMeasure (μ i)\n⊢ MeasureTheory.IsFiniteMeasure (MeasureTheory.Measure.sum μ)","decl":"instance [Finite ι] {μ : ι → Measure α} [∀ i, IsFiniteMeasure (μ i)] :\n    IsFiniteMeasure (.sum μ) where\n  measure_univ_lt_top := by\n    cases nonempty_fintype ι\n    simp [measure_lt_top]\n\n"}
{"name":"MeasureTheory.IsZeroOrProbabilityMeasure.measure_univ","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nself : MeasureTheory.IsZeroOrProbabilityMeasure μ\n⊢ Or (Eq (μ Set.univ) 0) (Eq (μ Set.univ) 1)","decl":"/-- A measure `μ` is zero or a probability measure if `μ univ = 0` or `μ univ = 1`. This class\nof measures appears naturally when conditioning on events, and many results which are true for\nprobability measures hold more generally over this class. -/\nclass IsZeroOrProbabilityMeasure (μ : Measure α) : Prop where\n  measure_univ : μ univ = 0 ∨ μ univ = 1\n\n"}
{"name":"MeasureTheory.isZeroOrProbabilityMeasure_iff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Iff (MeasureTheory.IsZeroOrProbabilityMeasure μ) (Or (Eq (μ Set.univ) 0) (Eq (μ Set.univ) 1))","decl":"lemma isZeroOrProbabilityMeasure_iff : IsZeroOrProbabilityMeasure μ ↔ μ univ = 0 ∨ μ univ = 1 :=\n  ⟨fun _ ↦ IsZeroOrProbabilityMeasure.measure_univ, IsZeroOrProbabilityMeasure.mk⟩\n\n"}
{"name":"MeasureTheory.prob_le_one","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsZeroOrProbabilityMeasure μ\ns : Set α\n⊢ LE.le (μ s) 1","decl":"lemma prob_le_one {μ : Measure α} [IsZeroOrProbabilityMeasure μ] {s : Set α} : μ s ≤ 1 := by\n  apply (measure_mono (subset_univ _)).trans\n  rcases IsZeroOrProbabilityMeasure.measure_univ (μ := μ) with h | h <;> simp [h]\n\n"}
{"name":"MeasureTheory.one_le_prob_iff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsZeroOrProbabilityMeasure μ\n⊢ Iff (LE.le 1 (μ s)) (Eq (μ s) 1)","decl":"@[simp]\ntheorem one_le_prob_iff {μ : Measure α} [IsZeroOrProbabilityMeasure μ] : 1 ≤ μ s ↔ μ s = 1 :=\n  ⟨fun h => le_antisymm prob_le_one h, fun h => h ▸ le_refl _⟩\n\n"}
{"name":"MeasureTheory.IsZeroOrProbabilityMeasure.toIsFiniteMeasure","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsZeroOrProbabilityMeasure μ\n⊢ MeasureTheory.IsFiniteMeasure μ","decl":"instance (priority := 100) IsZeroOrProbabilityMeasure.toIsFiniteMeasure (μ : Measure α)\n    [IsZeroOrProbabilityMeasure μ] : IsFiniteMeasure μ :=\n  ⟨prob_le_one.trans_lt one_lt_top⟩\n\n"}
{"name":"MeasureTheory.instIsZeroOrProbabilityMeasureOfNatMeasure","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\n⊢ MeasureTheory.IsZeroOrProbabilityMeasure 0","decl":"instance : IsZeroOrProbabilityMeasure (0 : Measure α) :=\n  ⟨Or.inl rfl⟩\n\n"}
{"name":"MeasureTheory.IsProbabilityMeasure.measure_univ","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nself : MeasureTheory.IsProbabilityMeasure μ\n⊢ Eq (μ Set.univ) 1","decl":"/-- A measure `μ` is called a probability measure if `μ univ = 1`. -/\nclass IsProbabilityMeasure (μ : Measure α) : Prop where\n  measure_univ : μ univ = 1\n\n"}
{"name":"MeasureTheory.isProbabilityMeasure_iff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Iff (MeasureTheory.IsProbabilityMeasure μ) (Eq (μ Set.univ) 1)","decl":"lemma isProbabilityMeasure_iff : IsProbabilityMeasure μ ↔ μ univ = 1 :=\n  ⟨fun _ ↦ measure_univ, IsProbabilityMeasure.mk⟩\n\n"}
{"name":"MeasureTheory.instIsZeroOrProbabilityMeasureOfIsProbabilityMeasure","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\n⊢ MeasureTheory.IsZeroOrProbabilityMeasure μ","decl":"instance (priority := 100) (μ : Measure α) [IsProbabilityMeasure μ] :\n    IsZeroOrProbabilityMeasure μ :=\n  ⟨Or.inr measure_univ⟩\n\n"}
{"name":"MeasureTheory.IsProbabilityMeasure.ne_zero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\n⊢ Ne μ 0","decl":"theorem IsProbabilityMeasure.ne_zero (μ : Measure α) [IsProbabilityMeasure μ] : μ ≠ 0 :=\n  mt measure_univ_eq_zero.2 <| by simp [measure_univ]\n\n"}
{"name":"MeasureTheory.IsProbabilityMeasure.neZero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\n⊢ NeZero μ","decl":"instance (priority := 100) IsProbabilityMeasure.neZero (μ : Measure α) [IsProbabilityMeasure μ] :\n    NeZero μ := ⟨IsProbabilityMeasure.ne_zero μ⟩\n\n-- Porting note: no longer an `instance` because `inferInstance` can find it now\n"}
{"name":"MeasureTheory.IsProbabilityMeasure.ae_neBot","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\n⊢ (MeasureTheory.ae μ).NeBot","decl":"theorem IsProbabilityMeasure.ae_neBot [IsProbabilityMeasure μ] : NeBot (ae μ) := inferInstance\n\n"}
{"name":"MeasureTheory.prob_add_prob_compl","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nh : MeasurableSet s\n⊢ Eq (HAdd.hAdd (μ s) (μ (HasCompl.compl s))) 1","decl":"theorem prob_add_prob_compl [IsProbabilityMeasure μ] (h : MeasurableSet s) : μ s + μ sᶜ = 1 :=\n  (measure_add_measure_compl h).trans measure_univ\n\n-- Porting note: made an `instance`, using `NeZero`\n"}
{"name":"MeasureTheory.isProbabilityMeasureSMul","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : NeZero μ\n⊢ MeasureTheory.IsProbabilityMeasure (HSMul.hSMul (Inv.inv (μ Set.univ)) μ)","decl":"instance isProbabilityMeasureSMul [IsFiniteMeasure μ] [NeZero μ] :\n    IsProbabilityMeasure ((μ univ)⁻¹ • μ) :=\n  ⟨ENNReal.inv_mul_cancel (NeZero.ne (μ univ)) (measure_ne_top _ _)⟩\n\n"}
{"name":"MeasureTheory.isProbabilityMeasure_map","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nβ : Type u_2\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nf : α → β\nhf : AEMeasurable f μ\n⊢ MeasureTheory.IsProbabilityMeasure (MeasureTheory.Measure.map f μ)","decl":"theorem isProbabilityMeasure_map {f : α → β} (hf : AEMeasurable f μ) :\n    IsProbabilityMeasure (map f μ) :=\n  ⟨by simp [map_apply_of_aemeasurable, hf]⟩\n\n"}
{"name":"MeasureTheory.IsProbabilityMeasure_comap_equiv","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nβ : Type u_2\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : MeasurableEquiv β α\n⊢ MeasureTheory.IsProbabilityMeasure (MeasureTheory.Measure.comap (⇑f) μ)","decl":"instance IsProbabilityMeasure_comap_equiv (f : β ≃ᵐ α) : IsProbabilityMeasure (μ.comap f) := by\n  rw [← MeasurableEquiv.map_symm]; exact isProbabilityMeasure_map f.symm.measurable.aemeasurable\n\n"}
{"name":"MeasureTheory.prob_compl_eq_one_sub₀","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nh : MeasureTheory.NullMeasurableSet s μ\n⊢ Eq (μ (HasCompl.compl s)) (HSub.hSub 1 (μ s))","decl":"/-- Note that this is not quite as useful as it looks because the measure takes values in `ℝ≥0∞`.\nThus the subtraction appearing is the truncated subtraction of `ℝ≥0∞`, rather than the\nbetter-behaved subtraction of `ℝ`. -/\nlemma prob_compl_eq_one_sub₀ (h : NullMeasurableSet s μ) : μ sᶜ = 1 - μ s := by\n  rw [measure_compl₀ h (measure_ne_top _ _), measure_univ]\n\n"}
{"name":"MeasureTheory.prob_compl_eq_one_sub","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhs : MeasurableSet s\n⊢ Eq (μ (HasCompl.compl s)) (HSub.hSub 1 (μ s))","decl":"/-- Note that this is not quite as useful as it looks because the measure takes values in `ℝ≥0∞`.\nThus the subtraction appearing is the truncated subtraction of `ℝ≥0∞`, rather than the\nbetter-behaved subtraction of `ℝ`. -/\ntheorem prob_compl_eq_one_sub (hs : MeasurableSet s) : μ sᶜ = 1 - μ s :=\n  prob_compl_eq_one_sub₀ hs.nullMeasurableSet\n\n"}
{"name":"MeasureTheory.prob_compl_eq_zero_iff₀","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhs : MeasureTheory.NullMeasurableSet s μ\n⊢ Iff (Eq (μ (HasCompl.compl s)) 0) (Eq (μ s) 1)","decl":"@[simp] lemma prob_compl_eq_zero_iff₀ (hs : NullMeasurableSet s μ) : μ sᶜ = 0 ↔ μ s = 1 := by\n  rw [prob_compl_eq_one_sub₀ hs, tsub_eq_zero_iff_le, one_le_prob_iff]\n\n"}
{"name":"MeasureTheory.prob_compl_eq_zero_iff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhs : MeasurableSet s\n⊢ Iff (Eq (μ (HasCompl.compl s)) 0) (Eq (μ s) 1)","decl":"@[simp] lemma prob_compl_eq_zero_iff (hs : MeasurableSet s) : μ sᶜ = 0 ↔ μ s = 1 :=\n  prob_compl_eq_zero_iff₀ hs.nullMeasurableSet\n\n"}
{"name":"MeasureTheory.prob_compl_eq_one_iff₀","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhs : MeasureTheory.NullMeasurableSet s μ\n⊢ Iff (Eq (μ (HasCompl.compl s)) 1) (Eq (μ s) 0)","decl":"@[simp] lemma prob_compl_eq_one_iff₀ (hs : NullMeasurableSet s μ) : μ sᶜ = 1 ↔ μ s = 0 := by\n  rw [← prob_compl_eq_zero_iff₀ hs.compl, compl_compl]\n\n"}
{"name":"MeasureTheory.prob_compl_eq_one_iff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhs : MeasurableSet s\n⊢ Iff (Eq (μ (HasCompl.compl s)) 1) (Eq (μ s) 0)","decl":"@[simp] lemma prob_compl_eq_one_iff (hs : MeasurableSet s) : μ sᶜ = 1 ↔ μ s = 0 :=\n  prob_compl_eq_one_iff₀ hs.nullMeasurableSet\n\n"}
{"name":"MeasureTheory.mem_ae_iff_prob_eq_one₀","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhs : MeasureTheory.NullMeasurableSet s μ\n⊢ Iff (Membership.mem (MeasureTheory.ae μ) s) (Eq (μ s) 1)","decl":"lemma mem_ae_iff_prob_eq_one₀ (hs : NullMeasurableSet s μ) : s ∈ ae μ ↔ μ s = 1 :=\n  mem_ae_iff.trans <| prob_compl_eq_zero_iff₀ hs\n\n"}
{"name":"MeasureTheory.mem_ae_iff_prob_eq_one","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhs : MeasurableSet s\n⊢ Iff (Membership.mem (MeasureTheory.ae μ) s) (Eq (μ s) 1)","decl":"lemma mem_ae_iff_prob_eq_one (hs : MeasurableSet s) : s ∈ ae μ ↔ μ s = 1 :=\n  mem_ae_iff.trans <| prob_compl_eq_zero_iff hs\n\n"}
{"name":"MeasureTheory.ae_iff_prob_eq_one","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\np : α → Prop\nhp : Measurable p\n⊢ Iff (Filter.Eventually (fun a => p a) (MeasureTheory.ae μ)) (Eq (μ (setOf fun a => p a)) 1)","decl":"lemma ae_iff_prob_eq_one (hp : Measurable p) : (∀ᵐ a ∂μ, p a) ↔ μ {a | p a} = 1 :=\n  mem_ae_iff_prob_eq_one hp.setOf\n\n"}
{"name":"MeasureTheory.isProbabilityMeasure_comap","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nβ : Type u_2\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nf : β → α\nhf : Function.Injective f\nhf' : Filter.Eventually (fun a => Membership.mem (Set.range f) a) (MeasureTheory.ae μ)\nhf'' : ∀ (s : Set β), MeasurableSet s → MeasurableSet (Set.image f s)\n⊢ MeasureTheory.IsProbabilityMeasure (MeasureTheory.Measure.comap f μ)","decl":"lemma isProbabilityMeasure_comap (hf : Injective f) (hf' : ∀ᵐ a ∂μ, a ∈ range f)\n    (hf'' : ∀ s, MeasurableSet s → MeasurableSet (f '' s)) :\n    IsProbabilityMeasure (μ.comap f) where\n  measure_univ := by\n    rw [comap_apply _ hf hf'' _ MeasurableSet.univ,\n      ← mem_ae_iff_prob_eq_one (hf'' _ MeasurableSet.univ)]\n    simpa\n\n"}
{"name":"MeasurableEmbedding.isProbabilityMeasure_comap","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nβ : Type u_2\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nf : β → α\nhf : MeasurableEmbedding f\nhf' : Filter.Eventually (fun a => Membership.mem (Set.range f) a) (MeasureTheory.ae μ)\n⊢ MeasureTheory.IsProbabilityMeasure (MeasureTheory.Measure.comap f μ)","decl":"protected lemma _root_.MeasurableEmbedding.isProbabilityMeasure_comap (hf : MeasurableEmbedding f)\n    (hf' : ∀ᵐ a ∂μ, a ∈ range f) : IsProbabilityMeasure (μ.comap f) :=\n  isProbabilityMeasure_comap hf.injective hf' hf.measurableSet_image'\n\n"}
{"name":"MeasureTheory.isProbabilityMeasure_map_up","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\n⊢ MeasureTheory.IsProbabilityMeasure (MeasureTheory.Measure.map ULift.up μ)","decl":"instance isProbabilityMeasure_map_up :\n    IsProbabilityMeasure (μ.map ULift.up) := isProbabilityMeasure_map measurable_up.aemeasurable\n\n"}
{"name":"MeasureTheory.isProbabilityMeasure_comap_down","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\n⊢ MeasureTheory.IsProbabilityMeasure (MeasureTheory.Measure.comap ULift.down μ)","decl":"instance isProbabilityMeasure_comap_down : IsProbabilityMeasure (μ.comap ULift.down) :=\n  MeasurableEquiv.ulift.measurableEmbedding.isProbabilityMeasure_comap <| ae_of_all _ <| by\n    simp [Function.Surjective.range_eq <| EquivLike.surjective _]\n\n"}
{"name":"MeasureTheory.isZeroOrProbabilityMeasureSMul","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ MeasureTheory.IsZeroOrProbabilityMeasure (HSMul.hSMul (Inv.inv (μ Set.univ)) μ)","decl":"instance isZeroOrProbabilityMeasureSMul :\n    IsZeroOrProbabilityMeasure ((μ univ)⁻¹ • μ) := by\n  rcases eq_zero_or_neZero μ with rfl | h\n  · simp; infer_instance\n  rcases eq_top_or_lt_top (μ univ) with h | h\n  · simp [h]; infer_instance\n  have : IsFiniteMeasure μ := ⟨h⟩\n  infer_instance\n\n"}
{"name":"MeasureTheory.eq_zero_or_isProbabilityMeasure","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsZeroOrProbabilityMeasure μ\n⊢ Or (Eq μ 0) (MeasureTheory.IsProbabilityMeasure μ)","decl":"variable (μ) in\nlemma eq_zero_or_isProbabilityMeasure : μ = 0 ∨ IsProbabilityMeasure μ := by\n  rcases IsZeroOrProbabilityMeasure.measure_univ (μ := μ) with h | h\n  · apply Or.inl (measure_univ_eq_zero.mp h)\n  · exact Or.inr ⟨h⟩\n\n"}
{"name":"MeasureTheory.instIsZeroOrProbabilityMeasureMap","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nβ : Type u_2\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\n⊢ MeasureTheory.IsZeroOrProbabilityMeasure (MeasureTheory.Measure.map f μ)","decl":"instance {f : α → β} : IsZeroOrProbabilityMeasure (map f μ) := by\n  by_cases hf : AEMeasurable f μ\n  · simpa [isZeroOrProbabilityMeasure_iff, hf] using IsZeroOrProbabilityMeasure.measure_univ\n  · simp [isZeroOrProbabilityMeasure_iff, hf]\n\n"}
{"name":"MeasureTheory.prob_compl_lt_one_sub_of_lt_prob","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\ninst✝ : MeasureTheory.IsZeroOrProbabilityMeasure μ\np : ENNReal\nhμs : LT.lt p (μ s)\ns_mble : MeasurableSet s\n⊢ LT.lt (μ (HasCompl.compl s)) (HSub.hSub 1 p)","decl":"lemma prob_compl_lt_one_sub_of_lt_prob {p : ℝ≥0∞} (hμs : p < μ s) (s_mble : MeasurableSet s) :\n    μ sᶜ < 1 - p := by\n  rcases eq_zero_or_isProbabilityMeasure μ with rfl | h\n  · simp at hμs\n  · rw [prob_compl_eq_one_sub s_mble]\n    apply ENNReal.sub_lt_of_sub_lt prob_le_one (Or.inl one_ne_top)\n    convert hμs\n    exact ENNReal.sub_sub_cancel one_ne_top (lt_of_lt_of_le hμs prob_le_one).le\n\n"}
{"name":"MeasureTheory.prob_compl_le_one_sub_of_le_prob","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\ninst✝ : MeasureTheory.IsZeroOrProbabilityMeasure μ\np : ENNReal\nhμs : LE.le p (μ s)\ns_mble : MeasurableSet s\n⊢ LE.le (μ (HasCompl.compl s)) (HSub.hSub 1 p)","decl":"lemma prob_compl_le_one_sub_of_le_prob {p : ℝ≥0∞} (hμs : p ≤ μ s) (s_mble : MeasurableSet s) :\n    μ sᶜ ≤ 1 - p := by\n  rcases eq_zero_or_isProbabilityMeasure μ with rfl | h\n  · simp\n  · simpa [prob_compl_eq_one_sub s_mble] using tsub_le_tsub_left hμs 1\n\n"}
{"name":"MeasureTheory.NoAtoms.measure_singleton","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nself : MeasureTheory.NoAtoms μ\nx : α\n⊢ Eq (μ (Singleton.singleton x)) 0","decl":"/-- Measure `μ` *has no atoms* if the measure of each singleton is zero.\n\nNB: Wikipedia assumes that for any measurable set `s` with positive `μ`-measure,\nthere exists a measurable `t ⊆ s` such that `0 < μ t < μ s`. While this implies `μ {x} = 0`,\nthe converse is not true. -/\nclass NoAtoms {m0 : MeasurableSpace α} (μ : Measure α) : Prop where\n  measure_singleton : ∀ x, μ {x} = 0\n\n"}
{"name":"Set.Subsingleton.measure_zero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ns : Set α\nhs : s.Subsingleton\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.NoAtoms μ\n⊢ Eq (μ s) 0","decl":"theorem _root_.Set.Subsingleton.measure_zero (hs : s.Subsingleton) (μ : Measure α) [NoAtoms μ] :\n    μ s = 0 :=\n  hs.induction_on (p := fun s => μ s = 0) measure_empty measure_singleton\n\n"}
{"name":"MeasureTheory.Measure.restrict_singleton'","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.NoAtoms μ\na : α\n⊢ Eq (μ.restrict (Singleton.singleton a)) 0","decl":"theorem Measure.restrict_singleton' {a : α} : μ.restrict {a} = 0 := by\n  simp only [measure_singleton, Measure.restrict_eq_zero]\n\n"}
{"name":"MeasureTheory.Measure.restrict.instNoAtoms","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ MeasureTheory.NoAtoms (μ.restrict s)","decl":"instance Measure.restrict.instNoAtoms (s : Set α) : NoAtoms (μ.restrict s) := by\n  refine ⟨fun x => ?_⟩\n  obtain ⟨t, hxt, ht1, ht2⟩ := exists_measurable_superset_of_null (measure_singleton x : μ {x} = 0)\n  apply measure_mono_null hxt\n  rw [Measure.restrict_apply ht1]\n  apply measure_mono_null inter_subset_left ht2\n\n"}
{"name":"Set.Countable.measure_zero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ns : Set α\nh : s.Countable\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.NoAtoms μ\n⊢ Eq (μ s) 0","decl":"theorem _root_.Set.Countable.measure_zero (h : s.Countable) (μ : Measure α) [NoAtoms μ] :\n    μ s = 0 := by\n  rw [← biUnion_of_singleton s, measure_biUnion_null_iff h]\n  simp\n\n"}
{"name":"Set.Countable.ae_not_mem","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ns : Set α\nh : s.Countable\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.NoAtoms μ\n⊢ Filter.Eventually (fun x => Not (Membership.mem s x)) (MeasureTheory.ae μ)","decl":"theorem _root_.Set.Countable.ae_not_mem (h : s.Countable) (μ : Measure α) [NoAtoms μ] :\n    ∀ᵐ x ∂μ, x ∉ s := by\n  simpa only [ae_iff, Classical.not_not] using h.measure_zero μ\n\n"}
{"name":"Set.Countable.measure_restrict_compl","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ns : Set α\nh : s.Countable\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.NoAtoms μ\n⊢ Eq (μ.restrict (HasCompl.compl s)) μ","decl":"lemma _root_.Set.Countable.measure_restrict_compl (h : s.Countable) (μ : Measure α) [NoAtoms μ] :\n    μ.restrict sᶜ = μ :=\n  restrict_eq_self_of_ae_mem <| h.ae_not_mem μ\n\n"}
{"name":"MeasureTheory.restrict_compl_singleton","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.NoAtoms μ\na : α\n⊢ Eq (μ.restrict (HasCompl.compl (Singleton.singleton a))) μ","decl":"@[simp]\nlemma restrict_compl_singleton (a : α) : μ.restrict ({a}ᶜ) = μ :=\n  (countable_singleton _).measure_restrict_compl μ\n\n"}
{"name":"Set.Finite.measure_zero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ns : Set α\nh : s.Finite\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.NoAtoms μ\n⊢ Eq (μ s) 0","decl":"theorem _root_.Set.Finite.measure_zero (h : s.Finite) (μ : Measure α) [NoAtoms μ] : μ s = 0 :=\n  h.countable.measure_zero μ\n\n"}
{"name":"Finset.measure_zero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ns : Finset α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.NoAtoms μ\n⊢ Eq (μ ↑s) 0","decl":"theorem _root_.Finset.measure_zero (s : Finset α) (μ : Measure α) [NoAtoms μ] : μ s = 0 :=\n  s.finite_toSet.measure_zero μ\n\n"}
{"name":"MeasureTheory.insert_ae_eq_self","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.NoAtoms μ\na : α\ns : Set α\n⊢ (MeasureTheory.ae μ).EventuallyEq (Insert.insert a s) s","decl":"theorem insert_ae_eq_self (a : α) (s : Set α) : (insert a s : Set α) =ᵐ[μ] s :=\n  union_ae_eq_right.2 <| measure_mono_null diff_subset (measure_singleton _)\n\n"}
{"name":"MeasureTheory.Iio_ae_eq_Iic","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.NoAtoms μ\ninst✝ : PartialOrder α\na : α\n⊢ (MeasureTheory.ae μ).EventuallyEq (Set.Iio a) (Set.Iic a)","decl":"theorem Iio_ae_eq_Iic : Iio a =ᵐ[μ] Iic a :=\n  Iio_ae_eq_Iic' (measure_singleton a)\n\n"}
{"name":"MeasureTheory.Ioi_ae_eq_Ici","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.NoAtoms μ\ninst✝ : PartialOrder α\na : α\n⊢ (MeasureTheory.ae μ).EventuallyEq (Set.Ioi a) (Set.Ici a)","decl":"theorem Ioi_ae_eq_Ici : Ioi a =ᵐ[μ] Ici a :=\n  Ioi_ae_eq_Ici' (measure_singleton a)\n\n"}
{"name":"MeasureTheory.Ioo_ae_eq_Ioc","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.NoAtoms μ\ninst✝ : PartialOrder α\na b : α\n⊢ (MeasureTheory.ae μ).EventuallyEq (Set.Ioo a b) (Set.Ioc a b)","decl":"theorem Ioo_ae_eq_Ioc : Ioo a b =ᵐ[μ] Ioc a b :=\n  Ioo_ae_eq_Ioc' (measure_singleton b)\n\n"}
{"name":"MeasureTheory.Ioc_ae_eq_Icc","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.NoAtoms μ\ninst✝ : PartialOrder α\na b : α\n⊢ (MeasureTheory.ae μ).EventuallyEq (Set.Ioc a b) (Set.Icc a b)","decl":"theorem Ioc_ae_eq_Icc : Ioc a b =ᵐ[μ] Icc a b :=\n  Ioc_ae_eq_Icc' (measure_singleton a)\n\n"}
{"name":"MeasureTheory.Ioo_ae_eq_Ico","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.NoAtoms μ\ninst✝ : PartialOrder α\na b : α\n⊢ (MeasureTheory.ae μ).EventuallyEq (Set.Ioo a b) (Set.Ico a b)","decl":"theorem Ioo_ae_eq_Ico : Ioo a b =ᵐ[μ] Ico a b :=\n  Ioo_ae_eq_Ico' (measure_singleton a)\n\n"}
{"name":"MeasureTheory.Ioo_ae_eq_Icc","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.NoAtoms μ\ninst✝ : PartialOrder α\na b : α\n⊢ (MeasureTheory.ae μ).EventuallyEq (Set.Ioo a b) (Set.Icc a b)","decl":"theorem Ioo_ae_eq_Icc : Ioo a b =ᵐ[μ] Icc a b :=\n  Ioo_ae_eq_Icc' (measure_singleton a) (measure_singleton b)\n\n"}
{"name":"MeasureTheory.Ico_ae_eq_Icc","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.NoAtoms μ\ninst✝ : PartialOrder α\na b : α\n⊢ (MeasureTheory.ae μ).EventuallyEq (Set.Ico a b) (Set.Icc a b)","decl":"theorem Ico_ae_eq_Icc : Ico a b =ᵐ[μ] Icc a b :=\n  Ico_ae_eq_Icc' (measure_singleton b)\n\n"}
{"name":"MeasureTheory.Ico_ae_eq_Ioc","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.NoAtoms μ\ninst✝ : PartialOrder α\na b : α\n⊢ (MeasureTheory.ae μ).EventuallyEq (Set.Ico a b) (Set.Ioc a b)","decl":"theorem Ico_ae_eq_Ioc : Ico a b =ᵐ[μ] Ioc a b :=\n  Ico_ae_eq_Ioc' (measure_singleton a) (measure_singleton b)\n\n"}
{"name":"MeasureTheory.restrict_Iio_eq_restrict_Iic","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.NoAtoms μ\ninst✝ : PartialOrder α\na : α\n⊢ Eq (μ.restrict (Set.Iio a)) (μ.restrict (Set.Iic a))","decl":"theorem restrict_Iio_eq_restrict_Iic : μ.restrict (Iio a) = μ.restrict (Iic a) :=\n  restrict_congr_set Iio_ae_eq_Iic\n\n"}
{"name":"MeasureTheory.restrict_Ioi_eq_restrict_Ici","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.NoAtoms μ\ninst✝ : PartialOrder α\na : α\n⊢ Eq (μ.restrict (Set.Ioi a)) (μ.restrict (Set.Ici a))","decl":"theorem restrict_Ioi_eq_restrict_Ici : μ.restrict (Ioi a) = μ.restrict (Ici a) :=\n  restrict_congr_set Ioi_ae_eq_Ici\n\n"}
{"name":"MeasureTheory.restrict_Ioo_eq_restrict_Ioc","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.NoAtoms μ\ninst✝ : PartialOrder α\na b : α\n⊢ Eq (μ.restrict (Set.Ioo a b)) (μ.restrict (Set.Ioc a b))","decl":"theorem restrict_Ioo_eq_restrict_Ioc : μ.restrict (Ioo a b) = μ.restrict (Ioc a b) :=\n  restrict_congr_set Ioo_ae_eq_Ioc\n\n"}
{"name":"MeasureTheory.restrict_Ioc_eq_restrict_Icc","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.NoAtoms μ\ninst✝ : PartialOrder α\na b : α\n⊢ Eq (μ.restrict (Set.Ioc a b)) (μ.restrict (Set.Icc a b))","decl":"theorem restrict_Ioc_eq_restrict_Icc : μ.restrict (Ioc a b) = μ.restrict (Icc a b) :=\n  restrict_congr_set Ioc_ae_eq_Icc\n\n"}
{"name":"MeasureTheory.restrict_Ioo_eq_restrict_Ico","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.NoAtoms μ\ninst✝ : PartialOrder α\na b : α\n⊢ Eq (μ.restrict (Set.Ioo a b)) (μ.restrict (Set.Ico a b))","decl":"theorem restrict_Ioo_eq_restrict_Ico : μ.restrict (Ioo a b) = μ.restrict (Ico a b) :=\n  restrict_congr_set Ioo_ae_eq_Ico\n\n"}
{"name":"MeasureTheory.restrict_Ioo_eq_restrict_Icc","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.NoAtoms μ\ninst✝ : PartialOrder α\na b : α\n⊢ Eq (μ.restrict (Set.Ioo a b)) (μ.restrict (Set.Icc a b))","decl":"theorem restrict_Ioo_eq_restrict_Icc : μ.restrict (Ioo a b) = μ.restrict (Icc a b) :=\n  restrict_congr_set Ioo_ae_eq_Icc\n\n"}
{"name":"MeasureTheory.restrict_Ico_eq_restrict_Icc","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.NoAtoms μ\ninst✝ : PartialOrder α\na b : α\n⊢ Eq (μ.restrict (Set.Ico a b)) (μ.restrict (Set.Icc a b))","decl":"theorem restrict_Ico_eq_restrict_Icc : μ.restrict (Ico a b) = μ.restrict (Icc a b) :=\n  restrict_congr_set Ico_ae_eq_Icc\n\n"}
{"name":"MeasureTheory.restrict_Ico_eq_restrict_Ioc","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.NoAtoms μ\ninst✝ : PartialOrder α\na b : α\n⊢ Eq (μ.restrict (Set.Ico a b)) (μ.restrict (Set.Ioc a b))","decl":"theorem restrict_Ico_eq_restrict_Ioc : μ.restrict (Ico a b) = μ.restrict (Ioc a b) :=\n  restrict_congr_set Ico_ae_eq_Ioc\n\n"}
{"name":"MeasureTheory.uIoc_ae_eq_interval","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.NoAtoms μ\ninst✝ : LinearOrder α\na b : α\n⊢ (MeasureTheory.ae μ).EventuallyEq (Set.uIoc a b) (Set.uIcc a b)","decl":"theorem uIoc_ae_eq_interval [LinearOrder α] {a b : α} : Ι a b =ᵐ[μ] [[a, b]] :=\n  Ioc_ae_eq_Icc\n\n"}
{"name":"MeasureTheory.ite_ae_eq_of_measure_zero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nγ : Type u_5\nf g : α → γ\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\nhs_zero : Eq (μ s) 0\n⊢ (MeasureTheory.ae μ).EventuallyEq (fun x => ite (Membership.mem s x) (f x) (g x)) g","decl":"theorem ite_ae_eq_of_measure_zero {γ} (f : α → γ) (g : α → γ) (s : Set α) [DecidablePred (· ∈ s)]\n    (hs_zero : μ s = 0) :\n    (fun x => ite (x ∈ s) (f x) (g x)) =ᵐ[μ] g := by\n  have h_ss : sᶜ ⊆ { a : α | ite (a ∈ s) (f a) (g a) = g a } := fun x hx => by\n    simp [(Set.mem_compl_iff _ _).mp hx]\n  refine measure_mono_null ?_ hs_zero\n  conv_rhs => rw [← compl_compl s]\n  rwa [Set.compl_subset_compl]\n\n"}
{"name":"MeasureTheory.ite_ae_eq_of_measure_compl_zero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nγ : Type u_5\nf g : α → γ\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\nhs_zero : Eq (μ (HasCompl.compl s)) 0\n⊢ (MeasureTheory.ae μ).EventuallyEq (fun x => ite (Membership.mem s x) (f x) (g x)) f","decl":"theorem ite_ae_eq_of_measure_compl_zero {γ} (f : α → γ) (g : α → γ)\n    (s : Set α) [DecidablePred (· ∈ s)] (hs_zero : μ sᶜ = 0) :\n    (fun x => ite (x ∈ s) (f x) (g x)) =ᵐ[μ] f := by\n  rw [← mem_ae_iff] at hs_zero\n  filter_upwards [hs_zero]\n  intros\n  split_ifs\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.finiteAtFilter_of_finite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\n_m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : Filter α\n⊢ μ.FiniteAtFilter f","decl":"theorem finiteAtFilter_of_finite {_m0 : MeasurableSpace α} (μ : Measure α) [IsFiniteMeasure μ]\n    (f : Filter α) : μ.FiniteAtFilter f :=\n  ⟨univ, univ_mem, measure_lt_top μ univ⟩\n\n"}
{"name":"MeasureTheory.Measure.FiniteAtFilter.exists_mem_basis","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nι : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : Filter α\nhμ : μ.FiniteAtFilter f\np : ι → Prop\ns : ι → Set α\nhf : f.HasBasis p s\n⊢ Exists fun i => And (p i) (LT.lt (μ (s i)) Top.top)","decl":"theorem FiniteAtFilter.exists_mem_basis {f : Filter α} (hμ : FiniteAtFilter μ f) {p : ι → Prop}\n    {s : ι → Set α} (hf : f.HasBasis p s) : ∃ i, p i ∧ μ (s i) < ∞ :=\n  (hf.exists_iff fun {_s _t} hst ht => (measure_mono hst).trans_lt ht).1 hμ\n\n"}
{"name":"MeasureTheory.Measure.finiteAtBot","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ μ.FiniteAtFilter Bot.bot","decl":"theorem finiteAtBot {m0 : MeasurableSpace α} (μ : Measure α) : μ.FiniteAtFilter ⊥ :=\n  ⟨∅, mem_bot, by simp only [measure_empty, zero_lt_top]⟩\n\n"}
{"name":"MeasureTheory.Measure.FiniteSpanningSetsIn.mk.injEq","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nC : Set (Set α)\nset✝ : Nat → Set α\nset_mem✝ : ∀ (i : Nat), Membership.mem C (set✝ i)\nfinite✝ : ∀ (i : Nat), LT.lt (μ (set✝ i)) Top.top\nspanning✝ : Eq (Set.iUnion fun i => set✝ i) Set.univ\nset : Nat → Set α\nset_mem : ∀ (i : Nat), Membership.mem C (set i)\nfinite : ∀ (i : Nat), LT.lt (μ (set i)) Top.top\nspanning : Eq (Set.iUnion fun i => set i) Set.univ\n⊢ Eq (Eq { set := set✝, set_mem := set_mem✝, finite := finite✝, spanning := spanning✝ } { set := set, set_mem := set_mem, finite := finite, spanning := spanning }) (Eq set✝ set)","decl":"/-- `μ` has finite spanning sets in `C` if there is a countable sequence of sets in `C` that have\n  finite measures. This structure is a type, which is useful if we want to record extra properties\n  about the sets, such as that they are monotone.\n  `SigmaFinite` is defined in terms of this: `μ` is σ-finite if there exists a sequence of\n  finite spanning sets in the collection of all measurable sets. -/\nstructure FiniteSpanningSetsIn {m0 : MeasurableSpace α} (μ : Measure α) (C : Set (Set α)) where\n  protected set : ℕ → Set α\n  protected set_mem : ∀ i, set i ∈ C\n  protected finite : ∀ i, μ (set i) < ∞\n  protected spanning : ⋃ i, set i = univ\n\n"}
{"name":"MeasureTheory.Measure.FiniteSpanningSetsIn.mk.sizeOf_spec","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nC : Set (Set α)\ninst✝¹ : SizeOf α\ninst✝ : (a : Set α) → SizeOf (C a)\nset : Nat → Set α\nset_mem : ∀ (i : Nat), Membership.mem C (set i)\nfinite : ∀ (i : Nat), LT.lt (μ (set i)) Top.top\nspanning : Eq (Set.iUnion fun i => set i) Set.univ\n⊢ Eq (SizeOf.sizeOf { set := set, set_mem := set_mem, finite := finite, spanning := spanning }) (HAdd.hAdd 1 (SizeOf.sizeOf spanning))","decl":"/-- `μ` has finite spanning sets in `C` if there is a countable sequence of sets in `C` that have\n  finite measures. This structure is a type, which is useful if we want to record extra properties\n  about the sets, such as that they are monotone.\n  `SigmaFinite` is defined in terms of this: `μ` is σ-finite if there exists a sequence of\n  finite spanning sets in the collection of all measurable sets. -/\nstructure FiniteSpanningSetsIn {m0 : MeasurableSpace α} (μ : Measure α) (C : Set (Set α)) where\n  protected set : ℕ → Set α\n  protected set_mem : ∀ i, set i ∈ C\n  protected finite : ∀ i, μ (set i) < ∞\n  protected spanning : ⋃ i, set i = univ\n\n"}
{"name":"MeasureTheory.Measure.FiniteSpanningSetsIn.mk.inj","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nC : Set (Set α)\nset✝ : Nat → Set α\nset_mem✝ : ∀ (i : Nat), Membership.mem C (set✝ i)\nfinite✝ : ∀ (i : Nat), LT.lt (μ (set✝ i)) Top.top\nspanning✝ : Eq (Set.iUnion fun i => set✝ i) Set.univ\nset : Nat → Set α\nset_mem : ∀ (i : Nat), Membership.mem C (set i)\nfinite : ∀ (i : Nat), LT.lt (μ (set i)) Top.top\nspanning : Eq (Set.iUnion fun i => set i) Set.univ\nx✝ : Eq { set := set✝, set_mem := set_mem✝, finite := finite✝, spanning := spanning✝ } { set := set, set_mem := set_mem, finite := finite, spanning := spanning }\n⊢ Eq set✝ set","decl":"/-- `μ` has finite spanning sets in `C` if there is a countable sequence of sets in `C` that have\n  finite measures. This structure is a type, which is useful if we want to record extra properties\n  about the sets, such as that they are monotone.\n  `SigmaFinite` is defined in terms of this: `μ` is σ-finite if there exists a sequence of\n  finite spanning sets in the collection of all measurable sets. -/\nstructure FiniteSpanningSetsIn {m0 : MeasurableSpace α} (μ : Measure α) (C : Set (Set α)) where\n  protected set : ℕ → Set α\n  protected set_mem : ∀ i, set i ∈ C\n  protected finite : ∀ i, μ (set i) < ∞\n  protected spanning : ⋃ i, set i = univ\n\n"}
{"name":"MeasureTheory.Measure.FiniteSpanningSetsIn.set_mem","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nC : Set (Set α)\nself : μ.FiniteSpanningSetsIn C\ni : Nat\n⊢ Membership.mem C (self.set i)","decl":"/-- `μ` has finite spanning sets in `C` if there is a countable sequence of sets in `C` that have\n  finite measures. This structure is a type, which is useful if we want to record extra properties\n  about the sets, such as that they are monotone.\n  `SigmaFinite` is defined in terms of this: `μ` is σ-finite if there exists a sequence of\n  finite spanning sets in the collection of all measurable sets. -/\nstructure FiniteSpanningSetsIn {m0 : MeasurableSpace α} (μ : Measure α) (C : Set (Set α)) where\n  protected set : ℕ → Set α\n  protected set_mem : ∀ i, set i ∈ C\n  protected finite : ∀ i, μ (set i) < ∞\n  protected spanning : ⋃ i, set i = univ\n\n"}
{"name":"MeasureTheory.Measure.FiniteSpanningSetsIn.spanning","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nC : Set (Set α)\nself : μ.FiniteSpanningSetsIn C\n⊢ Eq (Set.iUnion fun i => self.set i) Set.univ","decl":"/-- `μ` has finite spanning sets in `C` if there is a countable sequence of sets in `C` that have\n  finite measures. This structure is a type, which is useful if we want to record extra properties\n  about the sets, such as that they are monotone.\n  `SigmaFinite` is defined in terms of this: `μ` is σ-finite if there exists a sequence of\n  finite spanning sets in the collection of all measurable sets. -/\nstructure FiniteSpanningSetsIn {m0 : MeasurableSpace α} (μ : Measure α) (C : Set (Set α)) where\n  protected set : ℕ → Set α\n  protected set_mem : ∀ i, set i ∈ C\n  protected finite : ∀ i, μ (set i) < ∞\n  protected spanning : ⋃ i, set i = univ\n\n"}
{"name":"MeasureTheory.Measure.FiniteSpanningSetsIn.finite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nC : Set (Set α)\nself : μ.FiniteSpanningSetsIn C\ni : Nat\n⊢ LT.lt (μ (self.set i)) Top.top","decl":"/-- `μ` has finite spanning sets in `C` if there is a countable sequence of sets in `C` that have\n  finite measures. This structure is a type, which is useful if we want to record extra properties\n  about the sets, such as that they are monotone.\n  `SigmaFinite` is defined in terms of this: `μ` is σ-finite if there exists a sequence of\n  finite spanning sets in the collection of all measurable sets. -/\nstructure FiniteSpanningSetsIn {m0 : MeasurableSpace α} (μ : Measure α) (C : Set (Set α)) where\n  protected set : ℕ → Set α\n  protected set_mem : ∀ i, set i ∈ C\n  protected finite : ∀ i, μ (set i) < ∞\n  protected spanning : ⋃ i, set i = univ\n\n"}
{"name":"MeasureTheory.SFinite.out'","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nself : MeasureTheory.SFinite μ\n⊢ Exists fun m => And (∀ (n : Nat), MeasureTheory.IsFiniteMeasure (m n)) (Eq μ (MeasureTheory.Measure.sum m))","decl":"/-- A measure is called s-finite if it is a countable sum of finite measures. -/\nclass SFinite (μ : Measure α) : Prop where\n  out' : ∃ m : ℕ → Measure α, (∀ n, IsFiniteMeasure (m n)) ∧ μ = Measure.sum m\n\n"}
{"name":"MeasureTheory.isFiniteMeasure_sfiniteSeq","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nh : MeasureTheory.SFinite μ\nn : Nat\n⊢ MeasureTheory.IsFiniteMeasure (MeasureTheory.sfiniteSeq μ n)","decl":"instance isFiniteMeasure_sfiniteSeq [h : SFinite μ] (n : ℕ) : IsFiniteMeasure (sfiniteSeq μ n) :=\n  h.1.choose_spec.1 n\n\n"}
{"name":"MeasureTheory.isFiniteMeasure_sFiniteSeq","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\nn : Nat\n⊢ MeasureTheory.IsFiniteMeasure (MeasureTheory.sFiniteSeq μ n)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\" (since := \"2024-10-11\")]\ninstance isFiniteMeasure_sFiniteSeq [SFinite μ] (n : ℕ) : IsFiniteMeasure (sFiniteSeq μ n) :=\n  isFiniteMeasure_sfiniteSeq n\n\n"}
{"name":"MeasureTheory.sum_sfiniteSeq","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nh : MeasureTheory.SFinite μ\n⊢ Eq (MeasureTheory.Measure.sum (MeasureTheory.sfiniteSeq μ)) μ","decl":"lemma sum_sfiniteSeq (μ : Measure α) [h : SFinite μ] : sum (sfiniteSeq μ) = μ :=\n  h.1.choose_spec.2.symm\n\n"}
{"name":"MeasureTheory.sum_sFiniteSeq","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nh : MeasureTheory.SFinite μ\n⊢ Eq (MeasureTheory.Measure.sum (MeasureTheory.sfiniteSeq μ)) μ","decl":"@[deprecated (since := \"2024-10-11\")] alias sum_sFiniteSeq := sum_sfiniteSeq\n\n"}
{"name":"MeasureTheory.sfiniteSeq_le","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\nn : Nat\n⊢ LE.le (MeasureTheory.sfiniteSeq μ n) μ","decl":"lemma sfiniteSeq_le (μ : Measure α) [SFinite μ] (n : ℕ) : sfiniteSeq μ n ≤ μ :=\n  (le_sum _ n).trans (sum_sfiniteSeq μ).le\n\n"}
{"name":"MeasureTheory.sFiniteSeq_le","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\nn : Nat\n⊢ LE.le (MeasureTheory.sfiniteSeq μ n) μ","decl":"@[deprecated (since := \"2024-10-11\")] alias sFiniteSeq_le := sfiniteSeq_le\n\n"}
{"name":"MeasureTheory.instSFiniteOfNatMeasure","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\n⊢ MeasureTheory.SFinite 0","decl":"instance : SFinite (0 : Measure α) := ⟨fun _ ↦ 0, inferInstance, by rw [Measure.sum_zero]⟩\n\n"}
{"name":"MeasureTheory.sfiniteSeq_zero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nn : Nat\n⊢ Eq (MeasureTheory.sfiniteSeq 0 n) 0","decl":"@[simp]\nlemma sfiniteSeq_zero (n : ℕ) : sfiniteSeq (0 : Measure α) n = 0 :=\n  bot_unique <| sfiniteSeq_le _ _\n\n"}
{"name":"MeasureTheory.sFiniteSeq_zero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nn : Nat\n⊢ Eq (MeasureTheory.sfiniteSeq 0 n) 0","decl":"@[deprecated (since := \"2024-10-11\")] alias sFiniteSeq_zero := sfiniteSeq_zero\n\n"}
{"name":"MeasureTheory.sfinite_sum_of_countable","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nι : Type u_4\nm0 : MeasurableSpace α\ninst✝¹ : Countable ι\nm : ι → MeasureTheory.Measure α\ninst✝ : ∀ (n : ι), MeasureTheory.IsFiniteMeasure (m n)\n⊢ MeasureTheory.SFinite (MeasureTheory.Measure.sum m)","decl":"/-- A countable sum of finite measures is s-finite.\nThis lemma is superseded by the instance below. -/\nlemma sfinite_sum_of_countable [Countable ι]\n    (m : ι → Measure α) [∀ n, IsFiniteMeasure (m n)] : SFinite (Measure.sum m) := by\n  classical\n  obtain ⟨f, hf⟩ : ∃ f : ι → ℕ, Function.Injective f := Countable.exists_injective_nat ι\n  refine ⟨_, fun n ↦ ?_, (sum_extend_zero hf m).symm⟩\n  rcases em (n ∈ range f) with ⟨i, rfl⟩ | hn\n  · rw [hf.extend_apply]\n    infer_instance\n  · rw [Function.extend_apply' _ _ _ hn, Pi.zero_apply]\n    infer_instance\n\n"}
{"name":"MeasureTheory.instSFiniteSumOfCountable","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nι : Type u_4\nm0 : MeasurableSpace α\ninst✝¹ : Countable ι\nm : ι → MeasureTheory.Measure α\ninst✝ : ∀ (n : ι), MeasureTheory.SFinite (m n)\n⊢ MeasureTheory.SFinite (MeasureTheory.Measure.sum m)","decl":"instance [Countable ι] (m : ι → Measure α) [∀ n, SFinite (m n)] : SFinite (Measure.sum m) := by\n  change SFinite (Measure.sum (fun i ↦ m i))\n  simp_rw [← sum_sfiniteSeq (m _), Measure.sum_sum]\n  apply sfinite_sum_of_countable\n\n"}
{"name":"MeasureTheory.instSFiniteHAddMeasure","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : MeasureTheory.SFinite ν\n⊢ MeasureTheory.SFinite (HAdd.hAdd μ ν)","decl":"instance [SFinite μ] [SFinite ν] : SFinite (μ + ν) := by\n  have : ∀ b : Bool, SFinite (cond b μ ν) := by simp [*]\n  simpa using inferInstanceAs (SFinite (.sum (cond · μ ν)))\n\n"}
{"name":"MeasureTheory.instSFiniteRestrict","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\ns : Set α\n⊢ MeasureTheory.SFinite (μ.restrict s)","decl":"instance [SFinite μ] (s : Set α) : SFinite (μ.restrict s) :=\n  ⟨fun n ↦ (sfiniteSeq μ n).restrict s, fun n ↦ inferInstance,\n    by rw [← restrict_sum_of_countable, sum_sfiniteSeq]⟩\n\n"}
{"name":"MeasureTheory.exists_isFiniteMeasure_absolutelyContinuous","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\n⊢ Exists fun ν => And (MeasureTheory.IsFiniteMeasure ν) (And (μ.AbsolutelyContinuous ν) (ν.AbsolutelyContinuous μ))","decl":"variable (μ) in\n/-- For an s-finite measure `μ`, there exists a finite measure `ν`\nsuch that each of `μ` and `ν` is absolutely continuous with respect to the other.\n-/\ntheorem exists_isFiniteMeasure_absolutelyContinuous [SFinite μ] :\n    ∃ ν : Measure α, IsFiniteMeasure ν ∧ μ ≪ ν ∧ ν ≪ μ := by\n  rcases ENNReal.exists_pos_tsum_mul_lt_of_countable top_ne_zero (sfiniteSeq μ · univ)\n    fun _ ↦ measure_ne_top _ _ with ⟨c, hc₀, hc⟩\n  have {s : Set α} : sum (fun n ↦ c n • sfiniteSeq μ n) s = 0 ↔ μ s = 0 := by\n    conv_rhs => rw [← sum_sfiniteSeq μ, sum_apply_of_countable]\n    simp [(hc₀ _).ne']\n  refine ⟨.sum fun n ↦ c n • sfiniteSeq μ n, ⟨?_⟩, fun _ ↦ this.1, fun _ ↦ this.2⟩\n  simpa [mul_comm] using hc\n\n"}
{"name":"MeasureTheory.exists_absolutelyContinuous_isFiniteMeasure","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\n⊢ Exists fun ν => And (MeasureTheory.IsFiniteMeasure ν) (μ.AbsolutelyContinuous ν)","decl":"variable (μ) in\n@[deprecated exists_isFiniteMeasure_absolutelyContinuous (since := \"2024-08-25\")]\ntheorem exists_absolutelyContinuous_isFiniteMeasure [SFinite μ] :\n    ∃ ν : Measure α, IsFiniteMeasure ν ∧ μ ≪ ν :=\n  let ⟨ν, hfin, h, _⟩ := exists_isFiniteMeasure_absolutelyContinuous μ; ⟨ν, hfin, h⟩\n\n"}
{"name":"MeasureTheory.SigmaFinite.out'","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nself : MeasureTheory.SigmaFinite μ\n⊢ Nonempty (μ.FiniteSpanningSetsIn Set.univ)","decl":"/-- A measure `μ` is called σ-finite if there is a countable collection of sets\n `{ A i | i ∈ ℕ }` such that `μ (A i) < ∞` and `⋃ i, A i = s`. -/\nclass SigmaFinite {m0 : MeasurableSpace α} (μ : Measure α) : Prop where\n  out' : Nonempty (μ.FiniteSpanningSetsIn univ)\n\n"}
{"name":"MeasureTheory.sigmaFinite_iff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Iff (MeasureTheory.SigmaFinite μ) (Nonempty (μ.FiniteSpanningSetsIn Set.univ))","decl":"theorem sigmaFinite_iff : SigmaFinite μ ↔ Nonempty (μ.FiniteSpanningSetsIn univ) :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n\n"}
{"name":"MeasureTheory.SigmaFinite.out","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nh : MeasureTheory.SigmaFinite μ\n⊢ Nonempty (μ.FiniteSpanningSetsIn Set.univ)","decl":"theorem SigmaFinite.out (h : SigmaFinite μ) : Nonempty (μ.FiniteSpanningSetsIn univ) :=\n  h.1\n\n"}
{"name":"MeasureTheory.monotone_spanningSets","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\n⊢ Monotone (MeasureTheory.spanningSets μ)","decl":"theorem monotone_spanningSets (μ : Measure α) [SigmaFinite μ] : Monotone (spanningSets μ) :=\n  monotone_accumulate\n\n"}
{"name":"MeasureTheory.spanningSets_mono","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nm n : Nat\nhmn : LE.le m n\n⊢ HasSubset.Subset (MeasureTheory.spanningSets μ m) (MeasureTheory.spanningSets μ n)","decl":"@[gcongr]\nlemma spanningSets_mono [SigmaFinite μ] {m n : ℕ} (hmn : m ≤ n) :\n    spanningSets μ m ⊆ spanningSets μ n := monotone_spanningSets _ hmn\n\n"}
{"name":"MeasureTheory.measurableSet_spanningSets","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\ni : Nat\n⊢ MeasurableSet (MeasureTheory.spanningSets μ i)","decl":"theorem measurableSet_spanningSets (μ : Measure α) [SigmaFinite μ] (i : ℕ) :\n    MeasurableSet (spanningSets μ i) :=\n  MeasurableSet.iUnion fun j => MeasurableSet.iUnion fun _ => μ.toFiniteSpanningSetsIn.set_mem j\n\n"}
{"name":"MeasureTheory.measurable_spanningSets","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\ni : Nat\n⊢ MeasurableSet (MeasureTheory.spanningSets μ i)","decl":"@[deprecated (since := \"2024-10-16\")] alias measurable_spanningSets := measurableSet_spanningSets\n\n"}
{"name":"MeasureTheory.measure_spanningSets_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\ni : Nat\n⊢ LT.lt (μ (MeasureTheory.spanningSets μ i)) Top.top","decl":"theorem measure_spanningSets_lt_top (μ : Measure α) [SigmaFinite μ] (i : ℕ) :\n    μ (spanningSets μ i) < ∞ :=\n  measure_biUnion_lt_top (finite_le_nat i) fun j _ => μ.toFiniteSpanningSetsIn.finite j\n\n"}
{"name":"MeasureTheory.iUnion_spanningSets","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\n⊢ Eq (Set.iUnion fun i => MeasureTheory.spanningSets μ i) Set.univ","decl":"@[simp]\ntheorem iUnion_spanningSets (μ : Measure α) [SigmaFinite μ] : ⋃ i : ℕ, spanningSets μ i = univ := by\n  simp_rw [spanningSets, iUnion_accumulate, μ.toFiniteSpanningSetsIn.spanning]\n\n"}
{"name":"MeasureTheory.isCountablySpanning_spanningSets","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\n⊢ IsCountablySpanning (Set.range (MeasureTheory.spanningSets μ))","decl":"theorem isCountablySpanning_spanningSets (μ : Measure α) [SigmaFinite μ] :\n    IsCountablySpanning (range (spanningSets μ)) :=\n  ⟨spanningSets μ, mem_range_self, iUnion_spanningSets μ⟩\n\n"}
{"name":"MeasureTheory.measurableSet_spanningSetsIndex","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\n⊢ Measurable (MeasureTheory.spanningSetsIndex μ)","decl":"open scoped Classical in\ntheorem measurableSet_spanningSetsIndex (μ : Measure α) [SigmaFinite μ] :\n    Measurable (spanningSetsIndex μ) :=\n  measurable_find _ <| measurableSet_spanningSets μ\n\n"}
{"name":"MeasureTheory.preimage_spanningSetsIndex_singleton","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nn : Nat\n⊢ Eq (Set.preimage (MeasureTheory.spanningSetsIndex μ) (Singleton.singleton n)) (disjointed (MeasureTheory.spanningSets μ) n)","decl":"open scoped Classical in\ntheorem preimage_spanningSetsIndex_singleton (μ : Measure α) [SigmaFinite μ] (n : ℕ) :\n    spanningSetsIndex μ ⁻¹' {n} = disjointed (spanningSets μ) n :=\n  preimage_find_eq_disjointed _ _ _\n\n"}
{"name":"MeasureTheory.spanningSetsIndex_eq_iff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nx : α\nn : Nat\n⊢ Iff (Eq (MeasureTheory.spanningSetsIndex μ x) n) (Membership.mem (disjointed (MeasureTheory.spanningSets μ) n) x)","decl":"theorem spanningSetsIndex_eq_iff (μ : Measure α) [SigmaFinite μ] {x : α} {n : ℕ} :\n    spanningSetsIndex μ x = n ↔ x ∈ disjointed (spanningSets μ) n := by\n  convert Set.ext_iff.1 (preimage_spanningSetsIndex_singleton μ n) x\n\n"}
{"name":"MeasureTheory.mem_disjointed_spanningSetsIndex","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nx : α\n⊢ Membership.mem (disjointed (MeasureTheory.spanningSets μ) (MeasureTheory.spanningSetsIndex μ x)) x","decl":"theorem mem_disjointed_spanningSetsIndex (μ : Measure α) [SigmaFinite μ] (x : α) :\n    x ∈ disjointed (spanningSets μ) (spanningSetsIndex μ x) :=\n  (spanningSetsIndex_eq_iff μ).1 rfl\n\n"}
{"name":"MeasureTheory.mem_spanningSetsIndex","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nx : α\n⊢ Membership.mem (MeasureTheory.spanningSets μ (MeasureTheory.spanningSetsIndex μ x)) x","decl":"theorem mem_spanningSetsIndex (μ : Measure α) [SigmaFinite μ] (x : α) :\n    x ∈ spanningSets μ (spanningSetsIndex μ x) :=\n  disjointed_subset _ _ (mem_disjointed_spanningSetsIndex μ x)\n\n"}
{"name":"MeasureTheory.mem_spanningSets_of_index_le","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nx : α\nn : Nat\nhn : LE.le (MeasureTheory.spanningSetsIndex μ x) n\n⊢ Membership.mem (MeasureTheory.spanningSets μ n) x","decl":"theorem mem_spanningSets_of_index_le (μ : Measure α) [SigmaFinite μ] (x : α) {n : ℕ}\n    (hn : spanningSetsIndex μ x ≤ n) : x ∈ spanningSets μ n :=\n  monotone_spanningSets μ hn (mem_spanningSetsIndex μ x)\n\n"}
{"name":"MeasureTheory.eventually_mem_spanningSets","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nx : α\n⊢ Filter.Eventually (fun n => Membership.mem (MeasureTheory.spanningSets μ n) x) Filter.atTop","decl":"theorem eventually_mem_spanningSets (μ : Measure α) [SigmaFinite μ] (x : α) :\n    ∀ᶠ n in atTop, x ∈ spanningSets μ n :=\n  eventually_atTop.2 ⟨spanningSetsIndex μ x, fun _ => mem_spanningSets_of_index_le μ x⟩\n\n"}
{"name":"MeasureTheory.sum_restrict_disjointed_spanningSets","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite ν\n⊢ Eq (MeasureTheory.Measure.sum fun n => μ.restrict (disjointed (MeasureTheory.spanningSets ν) n)) μ","decl":"theorem sum_restrict_disjointed_spanningSets (μ ν : Measure α) [SigmaFinite ν] :\n    sum (fun n ↦ μ.restrict (disjointed (spanningSets ν) n)) = μ := by\n  rw [← restrict_iUnion (disjoint_disjointed _)\n      (MeasurableSet.disjointed (measurableSet_spanningSets _)),\n    iUnion_disjointed, iUnion_spanningSets, restrict_univ]\n\n"}
{"name":"MeasureTheory.instSFiniteOfSigmaFinite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\n⊢ MeasureTheory.SFinite μ","decl":"instance (priority := 100) [SigmaFinite μ] : SFinite μ := by\n  have : ∀ n, Fact (μ (disjointed (spanningSets μ) n) < ∞) :=\n    fun n ↦ ⟨(measure_mono (disjointed_subset _ _)).trans_lt (measure_spanningSets_lt_top μ n)⟩\n  exact ⟨⟨fun n ↦ μ.restrict (disjointed (spanningSets μ) n), fun n ↦ by infer_instance,\n    (sum_restrict_disjointed_spanningSets μ μ).symm⟩⟩\n\n"}
{"name":"MeasureTheory.Measure.forall_measure_inter_spanningSets_eq_zero","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\ns : Set α\n⊢ Iff (∀ (n : Nat), Eq (μ (Inter.inter s (MeasureTheory.spanningSets μ n))) 0) (Eq (μ s) 0)","decl":"/-- A set in a σ-finite space has zero measure if and only if its intersection with\nall members of the countable family of finite measure spanning sets has zero measure. -/\ntheorem forall_measure_inter_spanningSets_eq_zero [MeasurableSpace α] {μ : Measure α}\n    [SigmaFinite μ] (s : Set α) : (∀ n, μ (s ∩ spanningSets μ n) = 0) ↔ μ s = 0 := by\n  nth_rw 2 [show s = ⋃ n, s ∩ spanningSets μ n by\n      rw [← inter_iUnion, iUnion_spanningSets, inter_univ] ]\n  rw [measure_iUnion_null_iff]\n\n"}
{"name":"MeasureTheory.Measure.exists_measure_inter_spanningSets_pos","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\ns : Set α\n⊢ Iff (Exists fun n => LT.lt 0 (μ (Inter.inter s (MeasureTheory.spanningSets μ n)))) (LT.lt 0 (μ s))","decl":"/-- A set in a σ-finite space has positive measure if and only if its intersection with\nsome member of the countable family of finite measure spanning sets has positive measure. -/\ntheorem exists_measure_inter_spanningSets_pos [MeasurableSpace α] {μ : Measure α} [SigmaFinite μ]\n    (s : Set α) : (∃ n, 0 < μ (s ∩ spanningSets μ n)) ↔ 0 < μ s := by\n  rw [← not_iff_not]\n  simp only [not_exists, not_lt, nonpos_iff_eq_zero]\n  exact forall_measure_inter_spanningSets_eq_zero s\n\n"}
{"name":"MeasureTheory.Measure.finite_const_le_meas_of_disjoint_iUnion₀","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nι : Type u_5\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nε : ENNReal\nε_pos : LT.lt 0 ε\nAs : ι → Set α\nAs_mble : ∀ (i : ι), MeasureTheory.NullMeasurableSet (As i) μ\nAs_disj : Pairwise (Function.onFun (MeasureTheory.AEDisjoint μ) As)\nUnion_As_finite : Ne (μ (Set.iUnion fun i => As i)) Top.top\n⊢ (setOf fun i => LE.le ε (μ (As i))).Finite","decl":"/-- If the union of a.e.-disjoint null-measurable sets has finite measure, then there are only\nfinitely many members of the union whose measure exceeds any given positive number. -/\ntheorem finite_const_le_meas_of_disjoint_iUnion₀ {ι : Type*} [MeasurableSpace α] (μ : Measure α)\n    {ε : ℝ≥0∞} (ε_pos : 0 < ε) {As : ι → Set α} (As_mble : ∀ i : ι, NullMeasurableSet (As i) μ)\n    (As_disj : Pairwise (AEDisjoint μ on As)) (Union_As_finite : μ (⋃ i, As i) ≠ ∞) :\n    Set.Finite { i : ι | ε ≤ μ (As i) } :=\n  ENNReal.finite_const_le_of_tsum_ne_top\n    (ne_top_of_le_ne_top Union_As_finite (tsum_meas_le_meas_iUnion_of_disjoint₀ μ As_mble As_disj))\n    ε_pos.ne'\n\n"}
{"name":"MeasureTheory.Measure.finite_const_le_meas_of_disjoint_iUnion","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nι : Type u_5\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nε : ENNReal\nε_pos : LT.lt 0 ε\nAs : ι → Set α\nAs_mble : ∀ (i : ι), MeasurableSet (As i)\nAs_disj : Pairwise (Function.onFun Disjoint As)\nUnion_As_finite : Ne (μ (Set.iUnion fun i => As i)) Top.top\n⊢ (setOf fun i => LE.le ε (μ (As i))).Finite","decl":"/-- If the union of disjoint measurable sets has finite measure, then there are only\nfinitely many members of the union whose measure exceeds any given positive number. -/\ntheorem finite_const_le_meas_of_disjoint_iUnion {ι : Type*} [MeasurableSpace α] (μ : Measure α)\n    {ε : ℝ≥0∞} (ε_pos : 0 < ε) {As : ι → Set α} (As_mble : ∀ i : ι, MeasurableSet (As i))\n    (As_disj : Pairwise (Disjoint on As)) (Union_As_finite : μ (⋃ i, As i) ≠ ∞) :\n    Set.Finite { i : ι | ε ≤ μ (As i) } :=\n  finite_const_le_meas_of_disjoint_iUnion₀ μ ε_pos (fun i ↦ (As_mble i).nullMeasurableSet)\n    (fun _ _ h ↦ Disjoint.aedisjoint (As_disj h)) Union_As_finite\n\n"}
{"name":"Set.Infinite.meas_eq_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableSingletonClass α\ns : Set α\nhs : s.Infinite\nh' : Exists fun ε => And (Ne ε 0) (∀ (x : α), Membership.mem s x → LE.le ε (μ (Singleton.singleton x)))\n⊢ Eq (μ s) Top.top","decl":"/-- If all elements of an infinite set have measure uniformly separated from zero,\nthen the set has infinite measure. -/\ntheorem _root_.Set.Infinite.meas_eq_top [MeasurableSingletonClass α]\n    {s : Set α} (hs : s.Infinite) (h' : ∃ ε, ε ≠ 0 ∧ ∀ x ∈ s, ε ≤ μ {x}) : μ s = ∞ := top_unique <|\n  let ⟨ε, hne, hε⟩ := h'; have := hs.to_subtype\n  calc\n    ∞ = ∑' _ : s, ε := (ENNReal.tsum_const_eq_top_of_ne_zero hne).symm\n    _ ≤ ∑' x : s, μ {x.1} := ENNReal.tsum_le_tsum fun x ↦ hε x x.2\n    _ ≤ μ (⋃ x : s, {x.1}) := tsum_meas_le_meas_iUnion_of_disjoint _\n      (fun _ ↦ MeasurableSet.singleton _) fun x y hne ↦ by simpa [Subtype.val_inj]\n    _ = μ s := by simp\n\n"}
{"name":"MeasureTheory.Measure.countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top₀","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nι : Type u_5\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nAs : ι → Set α\nAs_mble : ∀ (i : ι), MeasureTheory.NullMeasurableSet (As i) μ\nAs_disj : Pairwise (Function.onFun (MeasureTheory.AEDisjoint μ) As)\nUnion_As_finite : Ne (μ (Set.iUnion fun i => As i)) Top.top\n⊢ (setOf fun i => LT.lt 0 (μ (As i))).Countable","decl":"/-- If the union of a.e.-disjoint null-measurable sets has finite measure, then there are only\ncountably many members of the union whose measure is positive. -/\ntheorem countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top₀ {ι : Type*} {_ : MeasurableSpace α}\n    (μ : Measure α) {As : ι → Set α} (As_mble : ∀ i : ι, NullMeasurableSet (As i) μ)\n    (As_disj : Pairwise (AEDisjoint μ on As)) (Union_As_finite : μ (⋃ i, As i) ≠ ∞) :\n    Set.Countable { i : ι | 0 < μ (As i) } := by\n  set posmeas := { i : ι | 0 < μ (As i) } with posmeas_def\n  rcases exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : ℝ≥0∞) < 1) with\n    ⟨as, _, as_mem, as_lim⟩\n  set fairmeas := fun n : ℕ => { i : ι | as n ≤ μ (As i) }\n  have countable_union : posmeas = ⋃ n, fairmeas n := by\n    have fairmeas_eq : ∀ n, fairmeas n = (fun i => μ (As i)) ⁻¹' Ici (as n) := fun n => by\n      simp only [fairmeas]\n      rfl\n    simpa only [fairmeas_eq, posmeas_def, ← preimage_iUnion,\n      iUnion_Ici_eq_Ioi_of_lt_of_tendsto (fun n => (as_mem n).1) as_lim]\n  rw [countable_union]\n  refine countable_iUnion fun n => Finite.countable ?_\n  exact finite_const_le_meas_of_disjoint_iUnion₀ μ (as_mem n).1 As_mble As_disj Union_As_finite\n\n"}
{"name":"MeasureTheory.Measure.countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nι : Type u_5\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nAs : ι → Set α\nAs_mble : ∀ (i : ι), MeasurableSet (As i)\nAs_disj : Pairwise (Function.onFun Disjoint As)\nUnion_As_finite : Ne (μ (Set.iUnion fun i => As i)) Top.top\n⊢ (setOf fun i => LT.lt 0 (μ (As i))).Countable","decl":"/-- If the union of disjoint measurable sets has finite measure, then there are only\ncountably many members of the union whose measure is positive. -/\ntheorem countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top {ι : Type*} {_ : MeasurableSpace α}\n    (μ : Measure α) {As : ι → Set α} (As_mble : ∀ i : ι, MeasurableSet (As i))\n    (As_disj : Pairwise (Disjoint on As)) (Union_As_finite : μ (⋃ i, As i) ≠ ∞) :\n    Set.Countable { i : ι | 0 < μ (As i) } :=\n  countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top₀ μ (fun i ↦ (As_mble i).nullMeasurableSet)\n    ((fun _ _ h ↦ Disjoint.aedisjoint (As_disj h))) Union_As_finite\n\n"}
{"name":"MeasureTheory.Measure.countable_meas_pos_of_disjoint_iUnion₀","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nι : Type u_5\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\nAs : ι → Set α\nAs_mble : ∀ (i : ι), MeasureTheory.NullMeasurableSet (As i) μ\nAs_disj : Pairwise (Function.onFun (MeasureTheory.AEDisjoint μ) As)\n⊢ (setOf fun i => LT.lt 0 (μ (As i))).Countable","decl":"/-- In an s-finite space, among disjoint null-measurable sets, only countably many can have positive\nmeasure. -/\ntheorem countable_meas_pos_of_disjoint_iUnion₀ {ι : Type*} {_ : MeasurableSpace α} {μ : Measure α}\n    [SFinite μ] {As : ι → Set α} (As_mble : ∀ i : ι, NullMeasurableSet (As i) μ)\n    (As_disj : Pairwise (AEDisjoint μ on As)) :\n    Set.Countable { i : ι | 0 < μ (As i) } := by\n  rw [← sum_sfiniteSeq μ] at As_disj As_mble ⊢\n  have obs : { i : ι | 0 < sum (sfiniteSeq μ) (As i) }\n      ⊆ ⋃ n, { i : ι | 0 < sfiniteSeq μ n (As i) } := by\n    intro i hi\n    by_contra con\n    simp only [mem_iUnion, mem_setOf_eq, not_exists, not_lt, nonpos_iff_eq_zero] at *\n    rw [sum_apply₀] at hi\n    · simp_rw [con] at hi\n      simp at hi\n    · exact As_mble i\n  apply Countable.mono obs\n  refine countable_iUnion fun n ↦ ?_\n  apply countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top₀\n  · exact fun i ↦ (As_mble i).mono (le_sum _ _)\n  · exact fun i j hij ↦ AEDisjoint.of_le (As_disj hij) (le_sum _ _)\n  · exact measure_ne_top _ (⋃ i, As i)\n\n"}
{"name":"MeasureTheory.Measure.countable_meas_pos_of_disjoint_iUnion","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nι : Type u_5\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\nAs : ι → Set α\nAs_mble : ∀ (i : ι), MeasurableSet (As i)\nAs_disj : Pairwise (Function.onFun Disjoint As)\n⊢ (setOf fun i => LT.lt 0 (μ (As i))).Countable","decl":"/-- In an s-finite space, among disjoint measurable sets, only countably many can have positive\nmeasure. -/\ntheorem countable_meas_pos_of_disjoint_iUnion {ι : Type*} {_ : MeasurableSpace α} {μ : Measure α}\n    [SFinite μ] {As : ι → Set α} (As_mble : ∀ i : ι, MeasurableSet (As i))\n    (As_disj : Pairwise (Disjoint on As)) : Set.Countable { i : ι | 0 < μ (As i) } :=\n  countable_meas_pos_of_disjoint_iUnion₀ (fun i ↦ (As_mble i).nullMeasurableSet)\n    ((fun _ _ h ↦ Disjoint.aedisjoint (As_disj h)))\n\n"}
{"name":"MeasureTheory.Measure.countable_meas_level_set_pos₀","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_5\nβ : Type u_6\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSingletonClass β\ng : α → β\ng_mble : MeasureTheory.NullMeasurable g μ\n⊢ (setOf fun t => LT.lt 0 (μ (setOf fun a => Eq (g a) t))).Countable","decl":"theorem countable_meas_level_set_pos₀ {α β : Type*} {_ : MeasurableSpace α} {μ : Measure α}\n    [SFinite μ] [MeasurableSpace β] [MeasurableSingletonClass β] {g : α → β}\n    (g_mble : NullMeasurable g μ) : Set.Countable { t : β | 0 < μ { a : α | g a = t } } := by\n  have level_sets_disjoint : Pairwise (Disjoint on fun t : β => { a : α | g a = t }) :=\n    fun s t hst => Disjoint.preimage g (disjoint_singleton.mpr hst)\n  exact Measure.countable_meas_pos_of_disjoint_iUnion₀\n    (fun b => g_mble (‹MeasurableSingletonClass β›.measurableSet_singleton b))\n    ((fun _ _ h ↦ Disjoint.aedisjoint (level_sets_disjoint h)))\n\n"}
{"name":"MeasureTheory.Measure.countable_meas_level_set_pos","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_5\nβ : Type u_6\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSingletonClass β\ng : α → β\ng_mble : Measurable g\n⊢ (setOf fun t => LT.lt 0 (μ (setOf fun a => Eq (g a) t))).Countable","decl":"theorem countable_meas_level_set_pos {α β : Type*} {_ : MeasurableSpace α} {μ : Measure α}\n    [SFinite μ] [MeasurableSpace β] [MeasurableSingletonClass β] {g : α → β}\n    (g_mble : Measurable g) : Set.Countable { t : β | 0 < μ { a : α | g a = t } } :=\n  countable_meas_level_set_pos₀ g_mble.nullMeasurable\n\n"}
{"name":"MeasureTheory.Measure.measure_toMeasurable_inter_of_sum","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\nt : Set α\nm : Nat → MeasureTheory.Measure α\nhv : ∀ (n : Nat), Ne ((m n) t) Top.top\nhμ : Eq μ (MeasureTheory.Measure.sum m)\n⊢ Eq (μ (Inter.inter (MeasureTheory.toMeasurable μ t) s)) (μ (Inter.inter t s))","decl":"/-- If a measure `μ` is the sum of a countable family `mₙ`, and a set `t` has finite measure for\neach `mₙ`, then its measurable superset `toMeasurable μ t` (which has the same measure as `t`)\nsatisfies, for any measurable set `s`, the equality `μ (toMeasurable μ t ∩ s) = μ (t ∩ s)`. -/\ntheorem measure_toMeasurable_inter_of_sum {s : Set α} (hs : MeasurableSet s) {t : Set α}\n    {m : ℕ → Measure α} (hv : ∀ n, m n t ≠ ∞) (hμ : μ = sum m) :\n    μ (toMeasurable μ t ∩ s) = μ (t ∩ s) := by\n  -- we show that there is a measurable superset of `t` satisfying the conclusion for any\n  -- measurable set `s`. It is built for each measure `mₙ` using `toMeasurable`\n  -- (which is well behaved for finite measure sets thanks to `measure_toMeasurable_inter`), and\n  -- then taking the intersection over `n`.\n  have A : ∃ t', t' ⊇ t ∧ MeasurableSet t' ∧ ∀ u, MeasurableSet u → μ (t' ∩ u) = μ (t ∩ u) := by\n    let w n := toMeasurable (m n) t\n    have T : t ⊆ ⋂ n, w n := subset_iInter (fun i ↦ subset_toMeasurable (m i) t)\n    have M : MeasurableSet (⋂ n, w n) :=\n      MeasurableSet.iInter (fun i ↦ measurableSet_toMeasurable (m i) t)\n    refine ⟨⋂ n, w n, T, M, fun u hu ↦ ?_⟩\n    refine le_antisymm ?_ (by gcongr)\n    rw [hμ, sum_apply _ (M.inter hu)]\n    apply le_trans _ (le_sum_apply _ _)\n    apply ENNReal.tsum_le_tsum (fun i ↦ ?_)\n    calc\n    m i ((⋂ n, w n) ∩ u) ≤ m i (w i ∩ u) := by gcongr; apply iInter_subset\n    _ = m i (t ∩ u) := measure_toMeasurable_inter hu (hv i)\n  -- thanks to the definition of `toMeasurable`, the previous property will also be shared\n  -- by `toMeasurable μ t`, which is enough to conclude the proof.\n  rw [toMeasurable]\n  split_ifs with ht\n  · apply measure_congr\n    exact ae_eq_set_inter ht.choose_spec.2.2 (ae_eq_refl _)\n  · exact A.choose_spec.2.2 s hs\n\n"}
{"name":"MeasureTheory.Measure.measure_toMeasurable_inter_of_cover","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\nt : Set α\nv : Nat → Set α\nhv : HasSubset.Subset t (Set.iUnion fun n => v n)\nh'v : ∀ (n : Nat), Ne (μ (Inter.inter t (v n))) Top.top\n⊢ Eq (μ (Inter.inter (MeasureTheory.toMeasurable μ t) s)) (μ (Inter.inter t s))","decl":"/-- If a set `t` is covered by a countable family of finite measure sets, then its measurable\nsuperset `toMeasurable μ t` (which has the same measure as `t`) satisfies,\nfor any measurable set `s`, the equality `μ (toMeasurable μ t ∩ s) = μ (t ∩ s)`. -/\ntheorem measure_toMeasurable_inter_of_cover {s : Set α} (hs : MeasurableSet s) {t : Set α}\n    {v : ℕ → Set α} (hv : t ⊆ ⋃ n, v n) (h'v : ∀ n, μ (t ∩ v n) ≠ ∞) :\n    μ (toMeasurable μ t ∩ s) = μ (t ∩ s) := by\n  -- we show that there is a measurable superset of `t` satisfying the conclusion for any\n  -- measurable set `s`. It is built on each member of a spanning family using `toMeasurable`\n  -- (which is well behaved for finite measure sets thanks to `measure_toMeasurable_inter`), and\n  -- the desired property passes to the union.\n  have A : ∃ t', t' ⊇ t ∧ MeasurableSet t' ∧ ∀ u, MeasurableSet u → μ (t' ∩ u) = μ (t ∩ u) := by\n    let w n := toMeasurable μ (t ∩ v n)\n    have hw : ∀ n, μ (w n) < ∞ := by\n      intro n\n      simp_rw [w, measure_toMeasurable]\n      exact (h'v n).lt_top\n    set t' := ⋃ n, toMeasurable μ (t ∩ disjointed w n) with ht'\n    have tt' : t ⊆ t' :=\n      calc\n        t ⊆ ⋃ n, t ∩ disjointed w n := by\n          rw [← inter_iUnion, iUnion_disjointed, inter_iUnion]\n          intro x hx\n          rcases mem_iUnion.1 (hv hx) with ⟨n, hn⟩\n          refine mem_iUnion.2 ⟨n, ?_⟩\n          have : x ∈ t ∩ v n := ⟨hx, hn⟩\n          exact ⟨hx, subset_toMeasurable μ _ this⟩\n        _ ⊆ ⋃ n, toMeasurable μ (t ∩ disjointed w n) :=\n          iUnion_mono fun n => subset_toMeasurable _ _\n    refine ⟨t', tt', MeasurableSet.iUnion fun n => measurableSet_toMeasurable μ _, fun u hu => ?_⟩\n    apply le_antisymm _ (by gcongr)\n    calc\n      μ (t' ∩ u) ≤ ∑' n, μ (toMeasurable μ (t ∩ disjointed w n) ∩ u) := by\n        rw [ht', iUnion_inter]\n        exact measure_iUnion_le _\n      _ = ∑' n, μ (t ∩ disjointed w n ∩ u) := by\n        congr 1\n        ext1 n\n        apply measure_toMeasurable_inter hu\n        apply ne_of_lt\n        calc\n          μ (t ∩ disjointed w n) ≤ μ (t ∩ w n) := by\n            gcongr\n            exact disjointed_le w n\n          _ ≤ μ (w n) := measure_mono inter_subset_right\n          _ < ∞ := hw n\n      _ = ∑' n, μ.restrict (t ∩ u) (disjointed w n) := by\n        congr 1\n        ext1 n\n        rw [restrict_apply, inter_comm t _, inter_assoc]\n        refine MeasurableSet.disjointed (fun n => ?_) n\n        exact measurableSet_toMeasurable _ _\n      _ = μ.restrict (t ∩ u) (⋃ n, disjointed w n) := by\n        rw [measure_iUnion]\n        · exact disjoint_disjointed _\n        · intro i\n          refine MeasurableSet.disjointed (fun n => ?_) i\n          exact measurableSet_toMeasurable _ _\n      _ ≤ μ.restrict (t ∩ u) univ := measure_mono (subset_univ _)\n      _ = μ (t ∩ u) := by rw [restrict_apply MeasurableSet.univ, univ_inter]\n  -- thanks to the definition of `toMeasurable`, the previous property will also be shared\n  -- by `toMeasurable μ t`, which is enough to conclude the proof.\n  rw [toMeasurable]\n  split_ifs with ht\n  · apply measure_congr\n    exact ae_eq_set_inter ht.choose_spec.2.2 (ae_eq_refl _)\n  · exact A.choose_spec.2.2 s hs\n\n"}
{"name":"MeasureTheory.Measure.restrict_toMeasurable_of_cover","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nv : Nat → Set α\nhv : HasSubset.Subset s (Set.iUnion fun n => v n)\nh'v : ∀ (n : Nat), Ne (μ (Inter.inter s (v n))) Top.top\n⊢ Eq (μ.restrict (MeasureTheory.toMeasurable μ s)) (μ.restrict s)","decl":"theorem restrict_toMeasurable_of_cover {s : Set α} {v : ℕ → Set α} (hv : s ⊆ ⋃ n, v n)\n    (h'v : ∀ n, μ (s ∩ v n) ≠ ∞) : μ.restrict (toMeasurable μ s) = μ.restrict s :=\n  ext fun t ht => by\n    simp only [restrict_apply ht, inter_comm t, measure_toMeasurable_inter_of_cover ht hv h'v]\n\n"}
{"name":"MeasureTheory.Measure.measure_toMeasurable_inter_of_sFinite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\ns : Set α\nhs : MeasurableSet s\nt : Set α\n⊢ Eq (μ (Inter.inter (MeasureTheory.toMeasurable μ t) s)) (μ (Inter.inter t s))","decl":"/-- The measurable superset `toMeasurable μ t` of `t` (which has the same measure as `t`)\nsatisfies, for any measurable set `s`, the equality `μ (toMeasurable μ t ∩ s) = μ (t ∩ s)`.\nThis only holds when `μ` is s-finite -- for example for σ-finite measures. For a version without\nthis assumption (but requiring that `t` has finite measure), see `measure_toMeasurable_inter`. -/\ntheorem measure_toMeasurable_inter_of_sFinite [SFinite μ] {s : Set α} (hs : MeasurableSet s)\n    (t : Set α) : μ (toMeasurable μ t ∩ s) = μ (t ∩ s) :=\n  measure_toMeasurable_inter_of_sum hs (fun _ ↦ measure_ne_top _ t) (sum_sfiniteSeq μ).symm\n\n"}
{"name":"MeasureTheory.Measure.restrict_toMeasurable_of_sFinite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\ns : Set α\n⊢ Eq (μ.restrict (MeasureTheory.toMeasurable μ s)) (μ.restrict s)","decl":"@[simp]\ntheorem restrict_toMeasurable_of_sFinite [SFinite μ] (s : Set α) :\n    μ.restrict (toMeasurable μ s) = μ.restrict s :=\n  ext fun t ht => by\n    rw [restrict_apply ht, inter_comm t, measure_toMeasurable_inter_of_sFinite ht,\n      restrict_apply ht, inter_comm t]\n\n"}
{"name":"MeasureTheory.Measure.iSup_restrict_spanningSets_of_measurableSet","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\ninst✝ : MeasureTheory.SigmaFinite μ\nhs : MeasurableSet s\n⊢ Eq (iSup fun i => (μ.restrict (MeasureTheory.spanningSets μ i)) s) (μ s)","decl":"/-- Auxiliary lemma for `iSup_restrict_spanningSets`. -/\ntheorem iSup_restrict_spanningSets_of_measurableSet [SigmaFinite μ] (hs : MeasurableSet s) :\n    ⨆ i, μ.restrict (spanningSets μ i) s = μ s :=\n  calc\n    ⨆ i, μ.restrict (spanningSets μ i) s = μ.restrict (⋃ i, spanningSets μ i) s :=\n      (restrict_iUnion_apply_eq_iSup (monotone_spanningSets μ).directed_le hs).symm\n    _ = μ s := by rw [iUnion_spanningSets, restrict_univ]\n\n"}
{"name":"MeasureTheory.Measure.iSup_restrict_spanningSets","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\ns : Set α\n⊢ Eq (iSup fun i => (μ.restrict (MeasureTheory.spanningSets μ i)) s) (μ s)","decl":"theorem iSup_restrict_spanningSets [SigmaFinite μ] (s : Set α) :\n    ⨆ i, μ.restrict (spanningSets μ i) s = μ s := by\n  rw [← measure_toMeasurable s,\n    ← iSup_restrict_spanningSets_of_measurableSet (measurableSet_toMeasurable _ _)]\n  simp_rw [restrict_apply' (measurableSet_spanningSets μ _), Set.inter_comm s,\n    ← restrict_apply (measurableSet_spanningSets μ _), ← restrict_toMeasurable_of_sFinite s,\n    restrict_apply (measurableSet_spanningSets μ _), Set.inter_comm _ (toMeasurable μ s)]\n\n"}
{"name":"MeasureTheory.Measure.exists_subset_measure_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\ninst✝ : MeasureTheory.SigmaFinite μ\nr : ENNReal\nhs : MeasurableSet s\nh's : LT.lt r (μ s)\n⊢ Exists fun t => And (MeasurableSet t) (And (HasSubset.Subset t s) (And (LT.lt r (μ t)) (LT.lt (μ t) Top.top)))","decl":"/-- In a σ-finite space, any measurable set of measure `> r` contains a measurable subset of\nfinite measure `> r`. -/\ntheorem exists_subset_measure_lt_top [SigmaFinite μ] {r : ℝ≥0∞} (hs : MeasurableSet s)\n    (h's : r < μ s) : ∃ t, MeasurableSet t ∧ t ⊆ s ∧ r < μ t ∧ μ t < ∞ := by\n  rw [← iSup_restrict_spanningSets,\n    @lt_iSup_iff _ _ _ r fun i : ℕ => μ.restrict (spanningSets μ i) s] at h's\n  rcases h's with ⟨n, hn⟩\n  simp only [restrict_apply hs] at hn\n  refine\n    ⟨s ∩ spanningSets μ n, hs.inter (measurableSet_spanningSets _ _), inter_subset_left, hn, ?_⟩\n  exact (measure_mono inter_subset_right).trans_lt (measure_spanningSets_lt_top _ _)\n\n"}
{"name":"MeasureTheory.Measure.FiniteSpanningSetsIn.sigmaFinite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nC : Set (Set α)\nh : μ.FiniteSpanningSetsIn C\n⊢ MeasureTheory.SigmaFinite μ","decl":"/-- If `μ` has finite spanning sets in the collection of measurable sets `C`, then `μ` is σ-finite.\n-/\nprotected theorem sigmaFinite (h : μ.FiniteSpanningSetsIn C) : SigmaFinite μ :=\n  ⟨⟨h.mono <| subset_univ C⟩⟩\n\n"}
{"name":"MeasureTheory.Measure.FiniteSpanningSetsIn.ext","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nC : Set (Set α)\nhA : Eq m0 (MeasurableSpace.generateFrom C)\nhC : IsPiSystem C\nh : μ.FiniteSpanningSetsIn C\nh_eq : ∀ (s : Set α), Membership.mem C s → Eq (μ s) (ν s)\n⊢ Eq μ ν","decl":"/-- An extensionality for measures. It is `ext_of_generateFrom_of_iUnion` formulated in terms of\n`FiniteSpanningSetsIn`. -/\nprotected theorem ext {ν : Measure α} {C : Set (Set α)} (hA : ‹_› = generateFrom C)\n    (hC : IsPiSystem C) (h : μ.FiniteSpanningSetsIn C) (h_eq : ∀ s ∈ C, μ s = ν s) : μ = ν :=\n  ext_of_generateFrom_of_iUnion C _ hA hC h.spanning h.set_mem (fun i => (h.finite i).ne) h_eq\n\n"}
{"name":"MeasureTheory.Measure.FiniteSpanningSetsIn.isCountablySpanning","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nC : Set (Set α)\nh : μ.FiniteSpanningSetsIn C\n⊢ IsCountablySpanning C","decl":"protected theorem isCountablySpanning (h : μ.FiniteSpanningSetsIn C) : IsCountablySpanning C :=\n  ⟨h.set, h.set_mem, h.spanning⟩\n\n"}
{"name":"MeasureTheory.Measure.sigmaFinite_of_countable","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nS : Set (Set α)\nhc : S.Countable\nhμ : ∀ (s : Set α), Membership.mem S s → LT.lt (μ s) Top.top\nhU : Eq S.sUnion Set.univ\n⊢ MeasureTheory.SigmaFinite μ","decl":"theorem sigmaFinite_of_countable {S : Set (Set α)} (hc : S.Countable) (hμ : ∀ s ∈ S, μ s < ∞)\n    (hU : ⋃₀ S = univ) : SigmaFinite μ := by\n  obtain ⟨s, hμ, hs⟩ : ∃ s : ℕ → Set α, (∀ n, μ (s n) < ∞) ∧ ⋃ n, s n = univ :=\n    (@exists_seq_cover_iff_countable _ (fun x => μ x < ∞) ⟨∅, by simp⟩).2 ⟨S, hc, hμ, hU⟩\n  exact ⟨⟨⟨fun n => s n, fun _ => trivial, hμ, hs⟩⟩⟩\n\n"}
{"name":"MeasureTheory.Measure.sigmaFinite_of_le","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nν μ : MeasureTheory.Measure α\nhs : MeasureTheory.SigmaFinite μ\nh : LE.le ν μ\n⊢ MeasureTheory.SigmaFinite ν","decl":"theorem sigmaFinite_of_le (μ : Measure α) [hs : SigmaFinite μ] (h : ν ≤ μ) : SigmaFinite ν :=\n  ⟨hs.out.map <| FiniteSpanningSetsIn.ofLE h⟩\n\n"}
{"name":"MeasureTheory.Measure.add_right_inj","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν₁ ν₂ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\n⊢ Iff (Eq (HAdd.hAdd μ ν₁) (HAdd.hAdd μ ν₂)) (Eq ν₁ ν₂)","decl":"@[simp] lemma add_right_inj (μ ν₁ ν₂ : Measure α) [SigmaFinite μ] :\n    μ + ν₁ = μ + ν₂ ↔ ν₁ = ν₂ := by\n  refine ⟨fun h ↦ ?_, fun h ↦ by rw [h]⟩\n  rw [ext_iff_of_iUnion_eq_univ (iUnion_spanningSets μ)]\n  intro i\n  ext s hs\n  rw [← ENNReal.add_right_inj (measure_mono s.inter_subset_right |>.trans_lt <|\n    measure_spanningSets_lt_top μ i).ne]\n  simp only [ext_iff', coe_add, Pi.add_apply] at h\n  simp [hs, h]\n\n"}
{"name":"MeasureTheory.Measure.add_left_inj","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν₁ ν₂ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\n⊢ Iff (Eq (HAdd.hAdd ν₁ μ) (HAdd.hAdd ν₂ μ)) (Eq ν₁ ν₂)","decl":"@[simp] lemma add_left_inj (μ ν₁ ν₂ : Measure α) [SigmaFinite μ] :\n    ν₁ + μ = ν₂ + μ ↔ ν₁ = ν₂ := by rw [add_comm _ μ, add_comm _ μ, μ.add_right_inj]\n\n"}
{"name":"MeasureTheory.IsFiniteMeasure.toSigmaFinite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\n_m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ MeasureTheory.SigmaFinite μ","decl":"/-- Every finite measure is σ-finite. -/\ninstance (priority := 100) IsFiniteMeasure.toSigmaFinite {_m0 : MeasurableSpace α} (μ : Measure α)\n    [IsFiniteMeasure μ] : SigmaFinite μ :=\n  ⟨⟨⟨fun _ => univ, fun _ => trivial, fun _ => measure_lt_top μ _, iUnion_const _⟩⟩⟩\n\n"}
{"name":"MeasureTheory.sigmaFinite_bot_iff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nμ : MeasureTheory.Measure α\n⊢ Iff (MeasureTheory.SigmaFinite μ) (MeasureTheory.IsFiniteMeasure μ)","decl":"theorem sigmaFinite_bot_iff (μ : @Measure α ⊥) : SigmaFinite μ ↔ IsFiniteMeasure μ := by\n  refine\n    ⟨fun h => ⟨?_⟩, fun h => by\n      haveI := h\n      infer_instance⟩\n  haveI : SigmaFinite μ := h\n  let s := spanningSets μ\n  have hs_univ : ⋃ i, s i = Set.univ := iUnion_spanningSets μ\n  have hs_meas : ∀ i, MeasurableSet[⊥] (s i) := measurableSet_spanningSets μ\n  simp_rw [MeasurableSpace.measurableSet_bot_iff] at hs_meas\n  by_cases h_univ_empty : (Set.univ : Set α) = ∅\n  · rw [h_univ_empty, measure_empty]\n    exact ENNReal.zero_ne_top.lt_top\n  obtain ⟨i, hsi⟩ : ∃ i, s i = Set.univ := by\n    by_contra! h_not_univ\n    have h_empty : ∀ i, s i = ∅ := by simpa [h_not_univ] using hs_meas\n    simp only [h_empty, iUnion_empty] at hs_univ\n    exact h_univ_empty hs_univ.symm\n  rw [← hsi]\n  exact measure_spanningSets_lt_top μ i\n\n"}
{"name":"MeasureTheory.Restrict.sigmaFinite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\ns : Set α\n⊢ MeasureTheory.SigmaFinite (μ.restrict s)","decl":"instance Restrict.sigmaFinite (μ : Measure α) [SigmaFinite μ] (s : Set α) :\n    SigmaFinite (μ.restrict s) := by\n  refine ⟨⟨⟨spanningSets μ, fun _ => trivial, fun i => ?_, iUnion_spanningSets μ⟩⟩⟩\n  rw [Measure.restrict_apply (measurableSet_spanningSets μ i)]\n  exact (measure_mono inter_subset_left).trans_lt (measure_spanningSets_lt_top μ i)\n\n"}
{"name":"MeasureTheory.sum.sigmaFinite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nι : Type u_5\ninst✝¹ : Finite ι\nμ : ι → MeasureTheory.Measure α\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\n⊢ MeasureTheory.SigmaFinite (MeasureTheory.Measure.sum μ)","decl":"instance sum.sigmaFinite {ι} [Finite ι] (μ : ι → Measure α) [∀ i, SigmaFinite (μ i)] :\n    SigmaFinite (sum μ) := by\n  cases nonempty_fintype ι\n  have : ∀ n, MeasurableSet (⋂ i : ι, spanningSets (μ i) n) := fun n =>\n    MeasurableSet.iInter fun i => measurableSet_spanningSets (μ i) n\n  refine ⟨⟨⟨fun n => ⋂ i, spanningSets (μ i) n, fun _ => trivial, fun n => ?_, ?_⟩⟩⟩\n  · rw [sum_apply _ (this n), tsum_fintype, ENNReal.sum_lt_top]\n    rintro i -\n    exact (measure_mono <| iInter_subset _ i).trans_lt (measure_spanningSets_lt_top (μ i) n)\n  · rw [iUnion_iInter_of_monotone]\n    · simp_rw [iUnion_spanningSets, iInter_univ]\n    exact fun i => monotone_spanningSets (μ i)\n\n"}
{"name":"MeasureTheory.Add.sigmaFinite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\n⊢ MeasureTheory.SigmaFinite (HAdd.hAdd μ ν)","decl":"instance Add.sigmaFinite (μ ν : Measure α) [SigmaFinite μ] [SigmaFinite ν] :\n    SigmaFinite (μ + ν) := by\n  rw [← sum_cond]\n  refine @sum.sigmaFinite _ _ _ _ _ (Bool.rec ?_ ?_) <;> simpa\n\n"}
{"name":"MeasureTheory.SMul.sigmaFinite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nc : NNReal\n⊢ MeasureTheory.SigmaFinite (HSMul.hSMul c μ)","decl":"instance SMul.sigmaFinite {μ : Measure α} [SigmaFinite μ] (c : ℝ≥0) :\n    MeasureTheory.SigmaFinite (c • μ) where\n  out' :=\n  ⟨{  set := spanningSets μ\n      set_mem := fun _ ↦ trivial\n      finite := by\n        intro i\n        simp only [Measure.coe_smul, Pi.smul_apply, nnreal_smul_coe_apply]\n        exact ENNReal.mul_lt_top ENNReal.coe_lt_top (measure_spanningSets_lt_top μ i)\n      spanning := iUnion_spanningSets μ }⟩\n\n"}
{"name":"MeasureTheory.instSigmaFiniteRestrictUnionSet","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\ninst✝¹ : MeasureTheory.SigmaFinite (μ.restrict s)\ninst✝ : MeasureTheory.SigmaFinite (μ.restrict t)\n⊢ MeasureTheory.SigmaFinite (μ.restrict (Union.union s t))","decl":"instance [SigmaFinite (μ.restrict s)] [SigmaFinite (μ.restrict t)] :\n    SigmaFinite (μ.restrict (s ∪ t)) := sigmaFinite_of_le _ (restrict_union_le _ _)\n\n"}
{"name":"MeasureTheory.instSigmaFiniteRestrictInterSet","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\ninst✝ : MeasureTheory.SigmaFinite (μ.restrict s)\n⊢ MeasureTheory.SigmaFinite (μ.restrict (Inter.inter s t))","decl":"instance [SigmaFinite (μ.restrict s)] : SigmaFinite (μ.restrict (s ∩ t)) :=\n  sigmaFinite_of_le (μ.restrict s) (restrict_mono_ae (ae_of_all _ Set.inter_subset_left))\n\n"}
{"name":"MeasureTheory.instSigmaFiniteRestrictInterSet_1","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\ninst✝ : MeasureTheory.SigmaFinite (μ.restrict t)\n⊢ MeasureTheory.SigmaFinite (μ.restrict (Inter.inter s t))","decl":"instance [SigmaFinite (μ.restrict t)] : SigmaFinite (μ.restrict (s ∩ t)) :=\n  sigmaFinite_of_le (μ.restrict t) (restrict_mono_ae (ae_of_all _ Set.inter_subset_right))\n\n"}
{"name":"MeasureTheory.SigmaFinite.of_map","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nβ : Type u_2\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\nhf : AEMeasurable f μ\nh : MeasureTheory.SigmaFinite (MeasureTheory.Measure.map f μ)\n⊢ MeasureTheory.SigmaFinite μ","decl":"theorem SigmaFinite.of_map (μ : Measure α) {f : α → β} (hf : AEMeasurable f μ)\n    (h : SigmaFinite (μ.map f)) : SigmaFinite μ :=\n  ⟨⟨⟨fun n => f ⁻¹' spanningSets (μ.map f) n, fun _ => trivial, fun n => by\n        simp only [← map_apply_of_aemeasurable hf, measurableSet_spanningSets,\n          measure_spanningSets_lt_top],\n        by rw [← preimage_iUnion, iUnion_spanningSets, preimage_univ]⟩⟩⟩\n\n"}
{"name":"MeasurableEmbedding.sigmaFinite_map","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nβ : Type u_2\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\nhf : MeasurableEmbedding f\ninst✝ : MeasureTheory.SigmaFinite μ\n⊢ MeasureTheory.SigmaFinite (MeasureTheory.Measure.map f μ)","decl":"lemma _root_.MeasurableEmbedding.sigmaFinite_map {f : α → β} (hf : MeasurableEmbedding f)\n    [SigmaFinite μ] :\n    SigmaFinite (μ.map f) := by\n  refine ⟨fun n ↦ f '' (spanningSets μ n) ∪ (Set.range f)ᶜ, by simp, fun n ↦ ?_, ?_⟩\n  · rw [hf.map_apply, Set.preimage_union]\n    simp only [Set.preimage_compl, Set.preimage_range, Set.compl_univ, Set.union_empty,\n      Set.preimage_image_eq _ hf.injective]\n    exact measure_spanningSets_lt_top μ n\n  · rw [← Set.iUnion_union, ← Set.image_iUnion, iUnion_spanningSets,\n      Set.image_univ, Set.union_compl_self]\n\n"}
{"name":"MeasurableEquiv.sigmaFinite_map","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nβ : Type u_2\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : MeasurableEquiv α β\ninst✝ : MeasureTheory.SigmaFinite μ\n⊢ MeasureTheory.SigmaFinite (MeasureTheory.Measure.map (⇑f) μ)","decl":"theorem _root_.MeasurableEquiv.sigmaFinite_map (f : α ≃ᵐ β) [SigmaFinite μ] :\n    SigmaFinite (μ.map f) := f.measurableEmbedding.sigmaFinite_map\n\n"}
{"name":"MeasureTheory.ae_of_forall_measure_lt_top_ae_restrict'","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\nP : α → Prop\nh : ∀ (s : Set α), MeasurableSet s → LT.lt (μ s) Top.top → LT.lt (ν s) Top.top → Filter.Eventually (fun x => P x) (MeasureTheory.ae (μ.restrict s))\n⊢ Filter.Eventually (fun x => P x) (MeasureTheory.ae μ)","decl":"/-- Similar to `ae_of_forall_measure_lt_top_ae_restrict`, but where you additionally get the\n  hypothesis that another σ-finite measure has finite values on `s`. -/\ntheorem ae_of_forall_measure_lt_top_ae_restrict' {μ : Measure α} (ν : Measure α) [SigmaFinite μ]\n    [SigmaFinite ν] (P : α → Prop)\n    (h : ∀ s, MeasurableSet s → μ s < ∞ → ν s < ∞ → ∀ᵐ x ∂μ.restrict s, P x) : ∀ᵐ x ∂μ, P x := by\n  have : ∀ n, ∀ᵐ x ∂μ, x ∈ spanningSets (μ + ν) n → P x := by\n    intro n\n    have := h\n      (spanningSets (μ + ν) n) (measurableSet_spanningSets _ _)\n      ((self_le_add_right _ _).trans_lt (measure_spanningSets_lt_top (μ + ν) _))\n      ((self_le_add_left _ _).trans_lt (measure_spanningSets_lt_top (μ + ν) _))\n    exact (ae_restrict_iff' (measurableSet_spanningSets _ _)).mp this\n  filter_upwards [ae_all_iff.2 this] with _ hx using hx _ (mem_spanningSetsIndex _ _)\n\n"}
{"name":"MeasureTheory.ae_of_forall_measure_lt_top_ae_restrict","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nP : α → Prop\nh : ∀ (s : Set α), MeasurableSet s → LT.lt (μ s) Top.top → Filter.Eventually (fun x => P x) (MeasureTheory.ae (μ.restrict s))\n⊢ Filter.Eventually (fun x => P x) (MeasureTheory.ae μ)","decl":"/-- To prove something for almost all `x` w.r.t. a σ-finite measure, it is sufficient to show that\n  this holds almost everywhere in sets where the measure has finite value. -/\ntheorem ae_of_forall_measure_lt_top_ae_restrict {μ : Measure α} [SigmaFinite μ] (P : α → Prop)\n    (h : ∀ s, MeasurableSet s → μ s < ∞ → ∀ᵐ x ∂μ.restrict s, P x) : ∀ᵐ x ∂μ, P x :=\n  ae_of_forall_measure_lt_top_ae_restrict' μ P fun s hs h2s _ => h s hs h2s\n\n"}
{"name":"MeasureTheory.IsLocallyFiniteMeasure.finiteAtNhds","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ninst✝ : TopologicalSpace α\nμ : MeasureTheory.Measure α\nself : MeasureTheory.IsLocallyFiniteMeasure μ\nx : α\n⊢ μ.FiniteAtFilter (nhds x)","decl":"/-- A measure is called locally finite if it is finite in some neighborhood of each point. -/\nclass IsLocallyFiniteMeasure [TopologicalSpace α] (μ : Measure α) : Prop where\n  finiteAtNhds : ∀ x, μ.FiniteAtFilter (𝓝 x)\n\n-- see Note [lower instance priority]\n"}
{"name":"MeasureTheory.IsFiniteMeasure.toIsLocallyFiniteMeasure","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ninst✝¹ : TopologicalSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ MeasureTheory.IsLocallyFiniteMeasure μ","decl":"instance (priority := 100) IsFiniteMeasure.toIsLocallyFiniteMeasure [TopologicalSpace α]\n    (μ : Measure α) [IsFiniteMeasure μ] : IsLocallyFiniteMeasure μ :=\n  ⟨fun _ => finiteAtFilter_of_finite _ _⟩\n\n"}
{"name":"MeasureTheory.Measure.finiteAt_nhds","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ninst✝¹ : TopologicalSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nx : α\n⊢ μ.FiniteAtFilter (nhds x)","decl":"theorem Measure.finiteAt_nhds [TopologicalSpace α] (μ : Measure α) [IsLocallyFiniteMeasure μ]\n    (x : α) : μ.FiniteAtFilter (𝓝 x) :=\n  IsLocallyFiniteMeasure.finiteAtNhds x\n\n"}
{"name":"MeasureTheory.Measure.smul_finite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nc : ENNReal\nhc : Ne c Top.top\n⊢ MeasureTheory.IsFiniteMeasure (HSMul.hSMul c μ)","decl":"theorem Measure.smul_finite (μ : Measure α) [IsFiniteMeasure μ] {c : ℝ≥0∞} (hc : c ≠ ∞) :\n    IsFiniteMeasure (c • μ) := by\n  lift c to ℝ≥0 using hc\n  exact MeasureTheory.isFiniteMeasureSMulNNReal\n\n"}
{"name":"MeasureTheory.Measure.exists_isOpen_measure_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ninst✝¹ : TopologicalSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nx : α\n⊢ Exists fun s => And (Membership.mem s x) (And (IsOpen s) (LT.lt (μ s) Top.top))","decl":"theorem Measure.exists_isOpen_measure_lt_top [TopologicalSpace α] (μ : Measure α)\n    [IsLocallyFiniteMeasure μ] (x : α) : ∃ s : Set α, x ∈ s ∧ IsOpen s ∧ μ s < ∞ := by\n  simpa only [and_assoc] using (μ.finiteAt_nhds x).exists_mem_basis (nhds_basis_opens x)\n\n"}
{"name":"MeasureTheory.isLocallyFiniteMeasureSMulNNReal","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ninst✝¹ : TopologicalSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nc : NNReal\n⊢ MeasureTheory.IsLocallyFiniteMeasure (HSMul.hSMul c μ)","decl":"instance isLocallyFiniteMeasureSMulNNReal [TopologicalSpace α] (μ : Measure α)\n    [IsLocallyFiniteMeasure μ] (c : ℝ≥0) : IsLocallyFiniteMeasure (c • μ) := by\n  refine ⟨fun x => ?_⟩\n  rcases μ.exists_isOpen_measure_lt_top x with ⟨o, xo, o_open, μo⟩\n  refine ⟨o, o_open.mem_nhds xo, ?_⟩\n  apply ENNReal.mul_lt_top _ μo\n  simp\n\n"}
{"name":"MeasureTheory.Measure.isTopologicalBasis_isOpen_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ninst✝¹ : TopologicalSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\n⊢ TopologicalSpace.IsTopologicalBasis (setOf fun s => And (IsOpen s) (LT.lt (μ s) Top.top))","decl":"protected theorem Measure.isTopologicalBasis_isOpen_lt_top [TopologicalSpace α]\n    (μ : Measure α) [IsLocallyFiniteMeasure μ] :\n    TopologicalSpace.IsTopologicalBasis { s | IsOpen s ∧ μ s < ∞ } := by\n  refine TopologicalSpace.isTopologicalBasis_of_isOpen_of_nhds (fun s hs => hs.1) ?_\n  intro x s xs hs\n  rcases μ.exists_isOpen_measure_lt_top x with ⟨v, xv, hv, μv⟩\n  refine ⟨v ∩ s, ⟨hv.inter hs, lt_of_le_of_lt ?_ μv⟩, ⟨xv, xs⟩, inter_subset_right⟩\n  exact measure_mono inter_subset_left\n\n"}
{"name":"MeasureTheory.IsFiniteMeasureOnCompacts.lt_top_of_isCompact","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ninst✝ : TopologicalSpace α\nμ : MeasureTheory.Measure α\nself : MeasureTheory.IsFiniteMeasureOnCompacts μ\nK : Set α\na✝ : IsCompact K\n⊢ LT.lt (μ K) Top.top","decl":"/-- A measure `μ` is finite on compacts if any compact set `K` satisfies `μ K < ∞`. -/\nclass IsFiniteMeasureOnCompacts [TopologicalSpace α] (μ : Measure α) : Prop where\n  protected lt_top_of_isCompact : ∀ ⦃K : Set α⦄, IsCompact K → μ K < ∞\n\n"}
{"name":"IsCompact.measure_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ninst✝¹ : TopologicalSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasureOnCompacts μ\nK : Set α\nhK : IsCompact K\n⊢ LT.lt (μ K) Top.top","decl":"/-- A compact subset has finite measure for a measure which is finite on compacts. -/\ntheorem _root_.IsCompact.measure_lt_top [TopologicalSpace α] {μ : Measure α}\n    [IsFiniteMeasureOnCompacts μ] ⦃K : Set α⦄ (hK : IsCompact K) : μ K < ∞ :=\n  IsFiniteMeasureOnCompacts.lt_top_of_isCompact hK\n\n"}
{"name":"IsCompact.measure_ne_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ninst✝¹ : TopologicalSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasureOnCompacts μ\nK : Set α\nhK : IsCompact K\n⊢ Ne (μ K) Top.top","decl":"/-- A compact subset has finite measure for a measure which is finite on compacts. -/\ntheorem _root_.IsCompact.measure_ne_top [TopologicalSpace α] {μ : Measure α}\n    [IsFiniteMeasureOnCompacts μ] ⦃K : Set α⦄ (hK : IsCompact K) : μ K ≠ ∞ :=\n  hK.measure_lt_top.ne\n\n"}
{"name":"Bornology.IsBounded.measure_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ninst✝² : PseudoMetricSpace α\ninst✝¹ : ProperSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasureOnCompacts μ\ns : Set α\nhs : Bornology.IsBounded s\n⊢ LT.lt (μ s) Top.top","decl":"/-- A bounded subset has finite measure for a measure which is finite on compact sets, in a\nproper space. -/\ntheorem _root_.Bornology.IsBounded.measure_lt_top [PseudoMetricSpace α] [ProperSpace α]\n    {μ : Measure α} [IsFiniteMeasureOnCompacts μ] ⦃s : Set α⦄ (hs : Bornology.IsBounded s) :\n    μ s < ∞ :=\n  calc\n    μ s ≤ μ (closure s) := measure_mono subset_closure\n    _ < ∞ := (Metric.isCompact_of_isClosed_isBounded isClosed_closure hs.closure).measure_lt_top\n\n"}
{"name":"MeasureTheory.measure_closedBall_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ninst✝² : PseudoMetricSpace α\ninst✝¹ : ProperSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasureOnCompacts μ\nx : α\nr : Real\n⊢ LT.lt (μ (Metric.closedBall x r)) Top.top","decl":"theorem measure_closedBall_lt_top [PseudoMetricSpace α] [ProperSpace α] {μ : Measure α}\n    [IsFiniteMeasureOnCompacts μ] {x : α} {r : ℝ} : μ (Metric.closedBall x r) < ∞ :=\n  Metric.isBounded_closedBall.measure_lt_top\n\n"}
{"name":"MeasureTheory.measure_ball_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ninst✝² : PseudoMetricSpace α\ninst✝¹ : ProperSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasureOnCompacts μ\nx : α\nr : Real\n⊢ LT.lt (μ (Metric.ball x r)) Top.top","decl":"theorem measure_ball_lt_top [PseudoMetricSpace α] [ProperSpace α] {μ : Measure α}\n    [IsFiniteMeasureOnCompacts μ] {x : α} {r : ℝ} : μ (Metric.ball x r) < ∞ :=\n  Metric.isBounded_ball.measure_lt_top\n\n"}
{"name":"MeasureTheory.IsFiniteMeasureOnCompacts.smul","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ninst✝¹ : TopologicalSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasureOnCompacts μ\nc : ENNReal\nhc : Ne c Top.top\n⊢ MeasureTheory.IsFiniteMeasureOnCompacts (HSMul.hSMul c μ)","decl":"protected theorem IsFiniteMeasureOnCompacts.smul [TopologicalSpace α] (μ : Measure α)\n    [IsFiniteMeasureOnCompacts μ] {c : ℝ≥0∞} (hc : c ≠ ∞) : IsFiniteMeasureOnCompacts (c • μ) :=\n  ⟨fun _K hK => ENNReal.mul_lt_top hc.lt_top hK.measure_lt_top⟩\n\n"}
{"name":"MeasureTheory.IsFiniteMeasureOnCompacts.smul_nnreal","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ninst✝¹ : TopologicalSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasureOnCompacts μ\nc : NNReal\n⊢ MeasureTheory.IsFiniteMeasureOnCompacts (HSMul.hSMul c μ)","decl":"instance IsFiniteMeasureOnCompacts.smul_nnreal [TopologicalSpace α] (μ : Measure α)\n    [IsFiniteMeasureOnCompacts μ] (c : ℝ≥0) : IsFiniteMeasureOnCompacts (c • μ) :=\n  IsFiniteMeasureOnCompacts.smul μ coe_ne_top\n\n"}
{"name":"MeasureTheory.instIsFiniteMeasureOnCompactsRestrict","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ninst✝¹ : TopologicalSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasureOnCompacts μ\ns : Set α\n⊢ MeasureTheory.IsFiniteMeasureOnCompacts (μ.restrict s)","decl":"instance instIsFiniteMeasureOnCompactsRestrict [TopologicalSpace α] {μ : Measure α}\n    [IsFiniteMeasureOnCompacts μ] {s : Set α} : IsFiniteMeasureOnCompacts (μ.restrict s) :=\n  ⟨fun _k hk ↦ (restrict_apply_le _ _).trans_lt hk.measure_lt_top⟩\n\n"}
{"name":"MeasureTheory.CompactSpace.isFiniteMeasure","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : MeasureTheory.IsFiniteMeasureOnCompacts μ\n⊢ MeasureTheory.IsFiniteMeasure μ","decl":"instance (priority := 100) CompactSpace.isFiniteMeasure [TopologicalSpace α] [CompactSpace α]\n    [IsFiniteMeasureOnCompacts μ] : IsFiniteMeasure μ :=\n  ⟨IsFiniteMeasureOnCompacts.lt_top_of_isCompact isCompact_univ⟩\n\n"}
{"name":"MeasureTheory.SigmaFinite.of_isFiniteMeasureOnCompacts","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ninst✝² : TopologicalSpace α\ninst✝¹ : SigmaCompactSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasureOnCompacts μ\n⊢ MeasureTheory.SigmaFinite μ","decl":"instance (priority := 100) SigmaFinite.of_isFiniteMeasureOnCompacts [TopologicalSpace α]\n    [SigmaCompactSpace α] (μ : Measure α) [IsFiniteMeasureOnCompacts μ] : SigmaFinite μ :=\n  ⟨⟨{   set := compactCovering α\n        set_mem := fun _ => trivial\n        finite := fun n => (isCompact_compactCovering α n).measure_lt_top\n        spanning := iUnion_compactCovering α }⟩⟩\n\n-- see Note [lower instance priority]\n"}
{"name":"MeasureTheory.sigmaFinite_of_locallyFinite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : TopologicalSpace α\ninst✝¹ : SecondCountableTopology α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\n⊢ MeasureTheory.SigmaFinite μ","decl":"instance (priority := 100) sigmaFinite_of_locallyFinite [TopologicalSpace α]\n    [SecondCountableTopology α] [IsLocallyFiniteMeasure μ] : SigmaFinite μ := by\n  choose s hsx hsμ using μ.finiteAt_nhds\n  rcases TopologicalSpace.countable_cover_nhds hsx with ⟨t, htc, htU⟩\n  refine Measure.sigmaFinite_of_countable (htc.image s) (forall_mem_image.2 fun x _ => hsμ x) ?_\n  rwa [sUnion_image]\n\n"}
{"name":"MeasureTheory.isLocallyFiniteMeasure_of_isFiniteMeasureOnCompacts","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : TopologicalSpace α\ninst✝¹ : WeaklyLocallyCompactSpace α\ninst✝ : MeasureTheory.IsFiniteMeasureOnCompacts μ\n⊢ MeasureTheory.IsLocallyFiniteMeasure μ","decl":"/-- A measure which is finite on compact sets in a locally compact space is locally finite. -/\ninstance (priority := 100) isLocallyFiniteMeasure_of_isFiniteMeasureOnCompacts [TopologicalSpace α]\n    [WeaklyLocallyCompactSpace α] [IsFiniteMeasureOnCompacts μ] : IsLocallyFiniteMeasure μ :=\n  ⟨fun x ↦\n    let ⟨K, K_compact, K_mem⟩ := exists_compact_mem_nhds x\n    ⟨K, K_mem, K_compact.measure_lt_top⟩⟩\n\n"}
{"name":"MeasureTheory.exists_pos_measure_of_cover","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nι : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Countable ι\nU : ι → Set α\nhU : Eq (Set.iUnion fun i => U i) Set.univ\nhμ : Ne μ 0\n⊢ Exists fun i => LT.lt 0 (μ (U i))","decl":"theorem exists_pos_measure_of_cover [Countable ι] {U : ι → Set α} (hU : ⋃ i, U i = univ)\n    (hμ : μ ≠ 0) : ∃ i, 0 < μ (U i) := by\n  contrapose! hμ with H\n  rw [← measure_univ_eq_zero, ← hU]\n  exact measure_iUnion_null fun i => nonpos_iff_eq_zero.1 (H i)\n\n"}
{"name":"MeasureTheory.exists_pos_preimage_ball","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nδ : Type u_3\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : PseudoMetricSpace δ\nf : α → δ\nx : δ\nhμ : Ne μ 0\n⊢ Exists fun n => LT.lt 0 (μ (Set.preimage f (Metric.ball x ↑n)))","decl":"theorem exists_pos_preimage_ball [PseudoMetricSpace δ] (f : α → δ) (x : δ) (hμ : μ ≠ 0) :\n    ∃ n : ℕ, 0 < μ (f ⁻¹' Metric.ball x n) :=\n  exists_pos_measure_of_cover (by rw [← preimage_iUnion, Metric.iUnion_ball_nat, preimage_univ]) hμ\n\n"}
{"name":"MeasureTheory.exists_pos_ball","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : PseudoMetricSpace α\nx : α\nhμ : Ne μ 0\n⊢ Exists fun n => LT.lt 0 (μ (Metric.ball x ↑n))","decl":"theorem exists_pos_ball [PseudoMetricSpace α] (x : α) (hμ : μ ≠ 0) :\n    ∃ n : ℕ, 0 < μ (Metric.ball x n) :=\n  exists_pos_preimage_ball id x hμ\n\n"}
{"name":"MeasureTheory.exists_ne_forall_mem_nhds_pos_measure_preimage","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nβ : Type u_5\ninst✝³ : TopologicalSpace β\ninst✝² : T1Space β\ninst✝¹ : SecondCountableTopology β\ninst✝ : Nonempty β\nf : α → β\nh : ∀ (b : β), Filter.Frequently (fun x => Ne (f x) b) (MeasureTheory.ae μ)\n⊢ Exists fun a => Exists fun b => And (Ne a b) (And (∀ (s : Set β), Membership.mem (nhds a) s → LT.lt 0 (μ (Set.preimage f s))) (∀ (t : Set β), Membership.mem (nhds b) t → LT.lt 0 (μ (Set.preimage f t))))","decl":"/-- If a set has zero measure in a neighborhood of each of its points, then it has zero measure\nin a second-countable space. -/\ntheorem exists_ne_forall_mem_nhds_pos_measure_preimage {β} [TopologicalSpace β] [T1Space β]\n    [SecondCountableTopology β] [Nonempty β] {f : α → β} (h : ∀ b, ∃ᵐ x ∂μ, f x ≠ b) :\n    ∃ a b : β, a ≠ b ∧ (∀ s ∈ 𝓝 a, 0 < μ (f ⁻¹' s)) ∧ ∀ t ∈ 𝓝 b, 0 < μ (f ⁻¹' t) := by\n  -- We use an `OuterMeasure` so that the proof works without `Measurable f`\n  set m : OuterMeasure β := OuterMeasure.map f μ.toOuterMeasure\n  replace h : ∀ b : β, m {b}ᶜ ≠ 0 := fun b => not_eventually.mpr (h b)\n  inhabit β\n  have : m univ ≠ 0 := ne_bot_of_le_ne_bot (h default) (measure_mono <| subset_univ _)\n  rcases exists_mem_forall_mem_nhdsWithin_pos_measure this with ⟨b, -, hb⟩\n  simp only [nhdsWithin_univ] at hb\n  rcases exists_mem_forall_mem_nhdsWithin_pos_measure (h b) with ⟨a, hab : a ≠ b, ha⟩\n  simp only [isOpen_compl_singleton.nhdsWithin_eq hab] at ha\n  exact ⟨a, b, hab, ha, hb⟩\n\n"}
{"name":"MeasureTheory.ext_on_measurableSpace_of_generate_finite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_5\nm₀ : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nC : Set (Set α)\nhμν : ∀ (s : Set α), Membership.mem C s → Eq (μ s) (ν s)\nm : MeasurableSpace α\nh : LE.le m m₀\nhA : Eq m (MeasurableSpace.generateFrom C)\nhC : IsPiSystem C\nh_univ : Eq (μ Set.univ) (ν Set.univ)\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (μ s) (ν s)","decl":"/-- If two finite measures give the same mass to the whole space and coincide on a π-system made\nof measurable sets, then they coincide on all sets in the σ-algebra generated by the π-system. -/\ntheorem ext_on_measurableSpace_of_generate_finite {α} (m₀ : MeasurableSpace α) {μ ν : Measure α}\n    [IsFiniteMeasure μ] (C : Set (Set α)) (hμν : ∀ s ∈ C, μ s = ν s) {m : MeasurableSpace α}\n    (h : m ≤ m₀) (hA : m = MeasurableSpace.generateFrom C) (hC : IsPiSystem C)\n    (h_univ : μ Set.univ = ν Set.univ) {s : Set α} (hs : MeasurableSet[m] s) : μ s = ν s := by\n  haveI : IsFiniteMeasure ν := by\n    constructor\n    rw [← h_univ]\n    apply IsFiniteMeasure.measure_univ_lt_top\n  induction s, hs using induction_on_inter hA hC with\n  | empty => simp\n  | basic t ht => exact hμν t ht\n  | compl t htm iht =>\n    rw [measure_compl (h t htm) (measure_ne_top _ _), measure_compl (h t htm) (measure_ne_top _ _),\n      iht, h_univ]\n  | iUnion f hfd hfm ihf =>\n    simp [measure_iUnion, hfd, h _ (hfm _), ihf]\n\n"}
{"name":"MeasureTheory.ext_of_generate_finite","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nC : Set (Set α)\nhA : Eq m0 (MeasurableSpace.generateFrom C)\nhC : IsPiSystem C\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhμν : ∀ (s : Set α), Membership.mem C s → Eq (μ s) (ν s)\nh_univ : Eq (μ Set.univ) (ν Set.univ)\n⊢ Eq μ ν","decl":"/-- Two finite measures are equal if they are equal on the π-system generating the σ-algebra\n  (and `univ`). -/\ntheorem ext_of_generate_finite (C : Set (Set α)) (hA : m0 = generateFrom C) (hC : IsPiSystem C)\n    [IsFiniteMeasure μ] (hμν : ∀ s ∈ C, μ s = ν s) (h_univ : μ univ = ν univ) : μ = ν :=\n  Measure.ext fun _s hs =>\n    ext_on_measurableSpace_of_generate_finite m0 C hμν le_rfl hA hC h_univ hs\n\n"}
{"name":"MeasureTheory.Measure.FiniteSpanningSetsIn.disjointed_set_eq","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nS : μ.FiniteSpanningSetsIn (setOf fun s => MeasurableSet s)\n⊢ Eq S.disjointed.set (disjointed S.set)","decl":"theorem FiniteSpanningSetsIn.disjointed_set_eq {μ : Measure α}\n    (S : μ.FiniteSpanningSetsIn { s | MeasurableSet s }) : S.disjointed.set = disjointed S.set :=\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.exists_eq_disjoint_finiteSpanningSetsIn","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\n⊢ Exists fun S => Exists fun T => And (Eq S.set T.set) (Pairwise (Function.onFun Disjoint S.set))","decl":"theorem exists_eq_disjoint_finiteSpanningSetsIn (μ ν : Measure α) [SigmaFinite μ] [SigmaFinite ν] :\n    ∃ (S : μ.FiniteSpanningSetsIn { s | MeasurableSet s })\n      (T : ν.FiniteSpanningSetsIn { s | MeasurableSet s }),\n      S.set = T.set ∧ Pairwise (Disjoint on S.set) :=\n  let S := (μ + ν).toFiniteSpanningSetsIn.disjointed\n  ⟨S.ofLE (Measure.le_add_right le_rfl), S.ofLE (Measure.le_add_left le_rfl), rfl,\n    disjoint_disjointed _⟩\n\n"}
{"name":"MeasureTheory.Measure.FiniteAtFilter.filter_mono","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : Filter α\nh : LE.le f g\na✝ : μ.FiniteAtFilter g\n⊢ μ.FiniteAtFilter f","decl":"theorem filter_mono (h : f ≤ g) : μ.FiniteAtFilter g → μ.FiniteAtFilter f := fun ⟨s, hs, hμ⟩ =>\n  ⟨s, h hs, hμ⟩\n\n"}
{"name":"MeasureTheory.Measure.FiniteAtFilter.inf_of_left","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : Filter α\nh : μ.FiniteAtFilter f\n⊢ μ.FiniteAtFilter (Min.min f g)","decl":"theorem inf_of_left (h : μ.FiniteAtFilter f) : μ.FiniteAtFilter (f ⊓ g) :=\n  h.filter_mono inf_le_left\n\n"}
{"name":"MeasureTheory.Measure.FiniteAtFilter.inf_of_right","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : Filter α\nh : μ.FiniteAtFilter g\n⊢ μ.FiniteAtFilter (Min.min f g)","decl":"theorem inf_of_right (h : μ.FiniteAtFilter g) : μ.FiniteAtFilter (f ⊓ g) :=\n  h.filter_mono inf_le_right\n\n"}
{"name":"MeasureTheory.Measure.FiniteAtFilter.inf_ae_iff","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : Filter α\n⊢ Iff (μ.FiniteAtFilter (Min.min f (MeasureTheory.ae μ))) (μ.FiniteAtFilter f)","decl":"@[simp]\ntheorem inf_ae_iff : μ.FiniteAtFilter (f ⊓ ae μ) ↔ μ.FiniteAtFilter f := by\n  refine ⟨?_, fun h => h.filter_mono inf_le_left⟩\n  rintro ⟨s, ⟨t, ht, u, hu, rfl⟩, hμ⟩\n  suffices μ t ≤ μ (t ∩ u) from ⟨t, ht, this.trans_lt hμ⟩\n  exact measure_mono_ae (mem_of_superset hu fun x hu ht => ⟨ht, hu⟩)\n\n"}
{"name":"MeasureTheory.Measure.FiniteAtFilter.of_inf_ae","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : Filter α\na✝ : μ.FiniteAtFilter (Min.min f (MeasureTheory.ae μ))\n⊢ μ.FiniteAtFilter f","decl":"alias ⟨of_inf_ae, _⟩ := inf_ae_iff\n\n"}
{"name":"MeasureTheory.Measure.FiniteAtFilter.filter_mono_ae","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : Filter α\nh : LE.le (Min.min f (MeasureTheory.ae μ)) g\nhg : μ.FiniteAtFilter g\n⊢ μ.FiniteAtFilter f","decl":"theorem filter_mono_ae (h : f ⊓ (ae μ) ≤ g) (hg : μ.FiniteAtFilter g) : μ.FiniteAtFilter f :=\n  inf_ae_iff.1 (hg.filter_mono h)\n\n"}
{"name":"MeasureTheory.Measure.FiniteAtFilter.measure_mono","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nf : Filter α\nh : LE.le μ ν\na✝ : ν.FiniteAtFilter f\n⊢ μ.FiniteAtFilter f","decl":"protected theorem measure_mono (h : μ ≤ ν) : ν.FiniteAtFilter f → μ.FiniteAtFilter f :=\n  fun ⟨s, hs, hν⟩ => ⟨s, hs, (Measure.le_iff'.1 h s).trans_lt hν⟩\n\n"}
{"name":"MeasureTheory.Measure.FiniteAtFilter.mono","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nf g : Filter α\nhf : LE.le f g\nhμ : LE.le μ ν\na✝ : ν.FiniteAtFilter g\n⊢ μ.FiniteAtFilter f","decl":"@[mono]\nprotected theorem mono (hf : f ≤ g) (hμ : μ ≤ ν) : ν.FiniteAtFilter g → μ.FiniteAtFilter f :=\n  fun h => (h.filter_mono hf).measure_mono hμ\n\n"}
{"name":"MeasureTheory.Measure.FiniteAtFilter.eventually","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : Filter α\nh : μ.FiniteAtFilter f\n⊢ Filter.Eventually (fun s => LT.lt (μ s) Top.top) f.smallSets","decl":"protected theorem eventually (h : μ.FiniteAtFilter f) : ∀ᶠ s in f.smallSets, μ s < ∞ :=\n  (eventually_smallSets' fun _s _t hst ht => (measure_mono hst).trans_lt ht).2 h\n\n"}
{"name":"MeasureTheory.Measure.FiniteAtFilter.filterSup","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : Filter α\na✝¹ : μ.FiniteAtFilter f\na✝ : μ.FiniteAtFilter g\n⊢ μ.FiniteAtFilter (Max.max f g)","decl":"theorem filterSup : μ.FiniteAtFilter f → μ.FiniteAtFilter g → μ.FiniteAtFilter (f ⊔ g) :=\n  fun ⟨s, hsf, hsμ⟩ ⟨t, htg, htμ⟩ =>\n  ⟨s ∪ t, union_mem_sup hsf htg, (measure_union_le s t).trans_lt (ENNReal.add_lt_top.2 ⟨hsμ, htμ⟩)⟩\n\n"}
{"name":"MeasureTheory.Measure.finiteAt_nhdsWithin","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\n_m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nx : α\ns : Set α\n⊢ μ.FiniteAtFilter (nhdsWithin x s)","decl":"theorem finiteAt_nhdsWithin [TopologicalSpace α] {_m0 : MeasurableSpace α} (μ : Measure α)\n    [IsLocallyFiniteMeasure μ] (x : α) (s : Set α) : μ.FiniteAtFilter (𝓝[s] x) :=\n  (finiteAt_nhds μ x).inf_of_left\n\n"}
{"name":"MeasureTheory.Measure.finiteAt_principal","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ Iff (μ.FiniteAtFilter (Filter.principal s)) (LT.lt (μ s) Top.top)","decl":"@[simp]\ntheorem finiteAt_principal : μ.FiniteAtFilter (𝓟 s) ↔ μ s < ∞ :=\n  ⟨fun ⟨_t, ht, hμ⟩ => (measure_mono ht).trans_lt hμ, fun h => ⟨s, mem_principal_self s, h⟩⟩\n\n"}
{"name":"MeasureTheory.Measure.isLocallyFiniteMeasure_of_le","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\n_m : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nH : MeasureTheory.IsLocallyFiniteMeasure μ\nh : LE.le ν μ\n⊢ MeasureTheory.IsLocallyFiniteMeasure ν","decl":"theorem isLocallyFiniteMeasure_of_le [TopologicalSpace α] {_m : MeasurableSpace α} {μ ν : Measure α}\n    [H : IsLocallyFiniteMeasure μ] (h : ν ≤ μ) : IsLocallyFiniteMeasure ν :=\n  let F := H.finiteAtNhds\n  ⟨fun x => (F x).measure_mono h⟩\n\n"}
{"name":"IsCompact.exists_open_superset_measure_lt_top'","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nh : IsCompact s\nhμ : ∀ (x : α), Membership.mem s x → μ.FiniteAtFilter (nhds x)\n⊢ Exists fun U => And (Superset U s) (And (IsOpen U) (LT.lt (μ U) Top.top))","decl":"/-- If `s` is a compact set and `μ` is finite at `𝓝 x` for every `x ∈ s`, then `s` admits an open\nsuperset of finite measure. -/\ntheorem exists_open_superset_measure_lt_top' (h : IsCompact s)\n    (hμ : ∀ x ∈ s, μ.FiniteAtFilter (𝓝 x)) : ∃ U ⊇ s, IsOpen U ∧ μ U < ∞ := by\n  refine IsCompact.induction_on h ?_ ?_ ?_ ?_\n  · use ∅\n    simp [Superset]\n  · rintro s t hst ⟨U, htU, hUo, hU⟩\n    exact ⟨U, hst.trans htU, hUo, hU⟩\n  · rintro s t ⟨U, hsU, hUo, hU⟩ ⟨V, htV, hVo, hV⟩\n    refine\n      ⟨U ∪ V, union_subset_union hsU htV, hUo.union hVo,\n        (measure_union_le _ _).trans_lt <| ENNReal.add_lt_top.2 ⟨hU, hV⟩⟩\n  · intro x hx\n    rcases (hμ x hx).exists_mem_basis (nhds_basis_opens _) with ⟨U, ⟨hx, hUo⟩, hU⟩\n    exact ⟨U, nhdsWithin_le_nhds (hUo.mem_nhds hx), U, Subset.rfl, hUo, hU⟩\n\n"}
{"name":"IsCompact.exists_open_superset_measure_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : MeasurableSpace α\ns : Set α\nh : IsCompact s\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\n⊢ Exists fun U => And (Superset U s) (And (IsOpen U) (LT.lt (μ U) Top.top))","decl":"/-- If `s` is a compact set and `μ` is a locally finite measure, then `s` admits an open superset of\nfinite measure. -/\ntheorem exists_open_superset_measure_lt_top (h : IsCompact s) (μ : Measure α)\n    [IsLocallyFiniteMeasure μ] : ∃ U ⊇ s, IsOpen U ∧ μ U < ∞ :=\n  h.exists_open_superset_measure_lt_top' fun x _ => μ.finiteAt_nhds x\n\n"}
{"name":"IsCompact.measure_lt_top_of_nhdsWithin","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nh : IsCompact s\nhμ : ∀ (x : α), Membership.mem s x → μ.FiniteAtFilter (nhdsWithin x s)\n⊢ LT.lt (μ s) Top.top","decl":"theorem measure_lt_top_of_nhdsWithin (h : IsCompact s) (hμ : ∀ x ∈ s, μ.FiniteAtFilter (𝓝[s] x)) :\n    μ s < ∞ :=\n  IsCompact.induction_on h (by simp) (fun _ _ hst ht => (measure_mono hst).trans_lt ht)\n    (fun s t hs ht => (measure_union_le s t).trans_lt (ENNReal.add_lt_top.2 ⟨hs, ht⟩)) hμ\n\n"}
{"name":"IsCompact.measure_zero_of_nhdsWithin","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : IsCompact s\na✝ : ∀ (a : α), Membership.mem s a → Exists fun t => And (Membership.mem (nhdsWithin a s) t) (Eq (μ t) 0)\n⊢ Eq (μ s) 0","decl":"theorem measure_zero_of_nhdsWithin (hs : IsCompact s) :\n    (∀ a ∈ s, ∃ t ∈ 𝓝[s] a, μ t = 0) → μ s = 0 := by\n  simpa only [← compl_mem_ae_iff] using hs.compl_mem_sets_of_nhdsWithin\n\n"}
{"name":"isFiniteMeasureOnCompacts_of_isLocallyFiniteMeasure","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\n⊢ MeasureTheory.IsFiniteMeasureOnCompacts μ","decl":"instance (priority := 100) isFiniteMeasureOnCompacts_of_isLocallyFiniteMeasure [TopologicalSpace α]\n    {_ : MeasurableSpace α} {μ : Measure α} [IsLocallyFiniteMeasure μ] :\n    IsFiniteMeasureOnCompacts μ :=\n  ⟨fun _s hs => hs.measure_lt_top_of_nhdsWithin fun _ _ => μ.finiteAt_nhdsWithin _ _⟩\n\n"}
{"name":"isFiniteMeasure_iff_isFiniteMeasureOnCompacts_of_compactSpace","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : CompactSpace α\n⊢ Iff (MeasureTheory.IsFiniteMeasure μ) (MeasureTheory.IsFiniteMeasureOnCompacts μ)","decl":"theorem isFiniteMeasure_iff_isFiniteMeasureOnCompacts_of_compactSpace [TopologicalSpace α]\n    [MeasurableSpace α] {μ : Measure α} [CompactSpace α] :\n    IsFiniteMeasure μ ↔ IsFiniteMeasureOnCompacts μ := by\n  constructor <;> intros\n  · infer_instance\n  · exact CompactSpace.isFiniteMeasure\n\n"}
{"name":"MeasureTheory.Measure.finiteSpanningSetsInOpen'_def","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_5\ninst✝² : TopologicalSpace α\ninst✝¹ : SecondCountableTopology α\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\n⊢ Eq μ.finiteSpanningSetsInOpen' (letFun ⋯ fun H => H.some)","decl":"/-- A locally finite measure on a second countable topological space admits a finite spanning\nsequence of open sets. -/\nnoncomputable irreducible_def MeasureTheory.Measure.finiteSpanningSetsInOpen' [TopologicalSpace α]\n  [SecondCountableTopology α] {m : MeasurableSpace α} (μ : Measure α) [IsLocallyFiniteMeasure μ] :\n  μ.FiniteSpanningSetsIn { K | IsOpen K } := by\n  suffices H : Nonempty (μ.FiniteSpanningSetsIn { K | IsOpen K }) from H.some\n  cases isEmpty_or_nonempty α\n  · exact\n      ⟨{  set := fun _ => ∅\n          set_mem := fun _ => by simp\n          finite := fun _ => by simp\n          spanning := by simp [eq_iff_true_of_subsingleton] }⟩\n  inhabit α\n  let S : Set (Set α) := { s | IsOpen s ∧ μ s < ∞ }\n  obtain ⟨T, T_count, TS, hT⟩ : ∃ T : Set (Set α), T.Countable ∧ T ⊆ S ∧ ⋃₀ T = ⋃₀ S :=\n    isOpen_sUnion_countable S fun s hs => hs.1\n  rw [μ.isTopologicalBasis_isOpen_lt_top.sUnion_eq] at hT\n  have T_ne : T.Nonempty := by\n    by_contra h'T\n    rw [not_nonempty_iff_eq_empty.1 h'T, sUnion_empty] at hT\n    simpa only [← hT] using mem_univ (default : α)\n  obtain ⟨f, hf⟩ : ∃ f : ℕ → Set α, T = range f := T_count.exists_eq_range T_ne\n  have fS : ∀ n, f n ∈ S := by\n    intro n\n    apply TS\n    rw [hf]\n    exact mem_range_self n\n  refine\n    ⟨{  set := f\n        set_mem := fun n => (fS n).1\n        finite := fun n => (fS n).2\n        spanning := ?_ }⟩\n  refine eq_univ_of_forall fun x => ?_\n  obtain ⟨t, tT, xt⟩ : ∃ t : Set α, t ∈ range f ∧ x ∈ t := by\n    have : x ∈ ⋃₀ T := by simp only [hT, mem_univ]\n    simpa only [mem_sUnion, exists_prop, ← hf]\n  obtain ⟨n, rfl⟩ : ∃ n : ℕ, f n = t := by simpa only using tT\n  exact mem_iUnion_of_mem _ xt\n\n"}
{"name":"measure_Icc_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\ninst✝³ : Preorder α\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactIccSpace α\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\na b : α\n⊢ LT.lt (μ (Set.Icc a b)) Top.top","decl":"theorem measure_Icc_lt_top : μ (Icc a b) < ∞ :=\n  isCompact_Icc.measure_lt_top\n\n"}
{"name":"measure_Ico_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\ninst✝³ : Preorder α\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactIccSpace α\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\na b : α\n⊢ LT.lt (μ (Set.Ico a b)) Top.top","decl":"theorem measure_Ico_lt_top : μ (Ico a b) < ∞ :=\n  (measure_mono Ico_subset_Icc_self).trans_lt measure_Icc_lt_top\n\n"}
{"name":"measure_Ioc_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\ninst✝³ : Preorder α\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactIccSpace α\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\na b : α\n⊢ LT.lt (μ (Set.Ioc a b)) Top.top","decl":"theorem measure_Ioc_lt_top : μ (Ioc a b) < ∞ :=\n  (measure_mono Ioc_subset_Icc_self).trans_lt measure_Icc_lt_top\n\n"}
{"name":"measure_Ioo_lt_top","module":"Mathlib.MeasureTheory.Measure.Typeclasses","initialProofState":"α : Type u_1\ninst✝³ : Preorder α\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactIccSpace α\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\na b : α\n⊢ LT.lt (μ (Set.Ioo a b)) Top.top","decl":"theorem measure_Ioo_lt_top : μ (Ioo a b) < ∞ :=\n  (measure_mono Ioo_subset_Icc_self).trans_lt measure_Icc_lt_top\n\n"}
