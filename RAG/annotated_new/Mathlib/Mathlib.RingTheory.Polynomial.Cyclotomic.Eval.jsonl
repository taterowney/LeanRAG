{"name":"Polynomial.eval_one_cyclotomic_prime","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Eval","initialProofState":"R : Type u_1\ninst✝ : CommRing R\np : Nat\nhn : Fact (Nat.Prime p)\n⊢ Eq (Polynomial.eval 1 (Polynomial.cyclotomic p R)) ↑p","decl":"@[simp]\ntheorem eval_one_cyclotomic_prime {R : Type*} [CommRing R] {p : ℕ} [hn : Fact p.Prime] :\n    eval 1 (cyclotomic p R) = p := by\n  simp only [cyclotomic_prime, eval_X, one_pow, Finset.sum_const, eval_pow, eval_finset_sum,\n    Finset.card_range, smul_one_eq_cast]\n\n"}
{"name":"Polynomial.eval₂_one_cyclotomic_prime","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Eval","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Semiring S\nf : RingHom R S\np : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ Eq (Polynomial.eval₂ f 1 (Polynomial.cyclotomic p R)) ↑p","decl":"theorem eval₂_one_cyclotomic_prime {R S : Type*} [CommRing R] [Semiring S] (f : R →+* S) {p : ℕ}\n    [Fact p.Prime] : eval₂ f 1 (cyclotomic p R) = p := by simp\n\n"}
{"name":"Polynomial.eval_one_cyclotomic_prime_pow","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Eval","initialProofState":"R : Type u_1\ninst✝ : CommRing R\np k : Nat\nhn : Fact (Nat.Prime p)\n⊢ Eq (Polynomial.eval 1 (Polynomial.cyclotomic (HPow.hPow p (HAdd.hAdd k 1)) R)) ↑p","decl":"@[simp]\ntheorem eval_one_cyclotomic_prime_pow {R : Type*} [CommRing R] {p : ℕ} (k : ℕ)\n    [hn : Fact p.Prime] : eval 1 (cyclotomic (p ^ (k + 1)) R) = p := by\n  simp only [cyclotomic_prime_pow_eq_geom_sum hn.out, eval_X, one_pow, Finset.sum_const, eval_pow,\n    eval_finset_sum, Finset.card_range, smul_one_eq_cast]\n\n"}
{"name":"Polynomial.eval₂_one_cyclotomic_prime_pow","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Eval","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Semiring S\nf : RingHom R S\np k : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ Eq (Polynomial.eval₂ f 1 (Polynomial.cyclotomic (HPow.hPow p (HAdd.hAdd k 1)) R)) ↑p","decl":"theorem eval₂_one_cyclotomic_prime_pow {R S : Type*} [CommRing R] [Semiring S] (f : R →+* S)\n    {p : ℕ} (k : ℕ) [Fact p.Prime] : eval₂ f 1 (cyclotomic (p ^ (k + 1)) R) = p := by simp\n\n"}
{"name":"Polynomial.cyclotomic_pos","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Eval","initialProofState":"n : Nat\nhn : LT.lt 2 n\nR : Type u_1\ninst✝ : LinearOrderedCommRing R\nx : R\n⊢ LT.lt 0 (Polynomial.eval x (Polynomial.cyclotomic n R))","decl":"theorem cyclotomic_pos {n : ℕ} (hn : 2 < n) {R} [LinearOrderedCommRing R] (x : R) :\n    0 < eval x (cyclotomic n R) := by\n  induction' n using Nat.strong_induction_on with n ih\n  have hn' : 0 < n := pos_of_gt hn\n  have hn'' : 1 < n := one_lt_two.trans hn\n  have := prod_cyclotomic_eq_geom_sum hn' R\n  apply_fun eval x at this\n  rw [← cons_self_properDivisors hn'.ne', Finset.erase_cons_of_ne _ hn''.ne', Finset.prod_cons,\n    eval_mul, eval_geom_sum] at this\n  rcases lt_trichotomy 0 (∑ i ∈ Finset.range n, x ^ i) with (h | h | h)\n  · apply pos_of_mul_pos_left\n    · rwa [this]\n    rw [eval_prod]\n    refine Finset.prod_nonneg fun i hi => ?_\n    simp only [Finset.mem_erase, mem_properDivisors] at hi\n    rw [geom_sum_pos_iff hn'.ne'] at h\n    cases' h with hk hx\n    · refine (ih _ hi.2.2 (Nat.two_lt_of_ne ?_ hi.1 ?_)).le <;> rintro rfl\n      · exact hn'.ne' (zero_dvd_iff.mp hi.2.1)\n      · exact not_odd_iff_even.2 (even_iff_two_dvd.mpr hi.2.1) hk\n    · rcases eq_or_ne i 2 with (rfl | hk)\n      · simpa only [eval_X, eval_one, cyclotomic_two, eval_add] using hx.le\n      refine (ih _ hi.2.2 (Nat.two_lt_of_ne ?_ hi.1 hk)).le\n      rintro rfl\n      exact hn'.ne' <| zero_dvd_iff.mp hi.2.1\n  · rw [eq_comm, geom_sum_eq_zero_iff_neg_one hn'.ne'] at h\n    exact h.1.symm ▸ cyclotomic_neg_one_pos hn\n  · apply pos_of_mul_neg_left\n    · rwa [this]\n    rw [geom_sum_neg_iff hn'.ne'] at h\n    have h2 : 2 ∈ n.properDivisors.erase 1 := by\n      rw [Finset.mem_erase, mem_properDivisors]\n      exact ⟨by decide, even_iff_two_dvd.mp h.1, hn⟩\n    rw [eval_prod, ← Finset.prod_erase_mul _ _ h2]\n    apply mul_nonpos_of_nonneg_of_nonpos\n    · refine Finset.prod_nonneg fun i hi => le_of_lt ?_\n      simp only [Finset.mem_erase, mem_properDivisors] at hi\n      refine ih _ hi.2.2.2 (Nat.two_lt_of_ne ?_ hi.2.1 hi.1)\n      rintro rfl\n      rw [zero_dvd_iff] at hi\n      exact hn'.ne' hi.2.2.1\n    · simpa only [eval_X, eval_one, cyclotomic_two, eval_add] using h.right.le\n\n"}
{"name":"Polynomial.cyclotomic_pos_and_nonneg","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Eval","initialProofState":"n : Nat\nR : Type u_1\ninst✝ : LinearOrderedCommRing R\nx : R\n⊢ And (LT.lt 1 x → LT.lt 0 (Polynomial.eval x (Polynomial.cyclotomic n R))) (LE.le 1 x → LE.le 0 (Polynomial.eval x (Polynomial.cyclotomic n R)))","decl":"theorem cyclotomic_pos_and_nonneg (n : ℕ) {R} [LinearOrderedCommRing R] (x : R) :\n    (1 < x → 0 < eval x (cyclotomic n R)) ∧ (1 ≤ x → 0 ≤ eval x (cyclotomic n R)) := by\n  rcases n with (_ | _ | _ | n)\n  · simp only [cyclotomic_zero, eval_one, zero_lt_one, implies_true, zero_le_one, and_self]\n  · simp only [zero_add, cyclotomic_one, eval_sub, eval_X, eval_one, sub_pos, imp_self, sub_nonneg,\n      and_self]\n  · simp only [zero_add, reduceAdd, cyclotomic_two, eval_add, eval_X, eval_one]\n    constructor <;> intro <;> linarith\n  · constructor <;> intro <;> [skip; apply le_of_lt] <;> apply cyclotomic_pos (by omega)\n\n"}
{"name":"Polynomial.cyclotomic_pos'","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Eval","initialProofState":"n : Nat\nR : Type u_1\ninst✝ : LinearOrderedCommRing R\nx : R\nhx : LT.lt 1 x\n⊢ LT.lt 0 (Polynomial.eval x (Polynomial.cyclotomic n R))","decl":"/-- Cyclotomic polynomials are always positive on inputs larger than one.\nSimilar to `cyclotomic_pos` but with the condition on the input rather than index of the\ncyclotomic polynomial. -/\ntheorem cyclotomic_pos' (n : ℕ) {R} [LinearOrderedCommRing R] {x : R} (hx : 1 < x) :\n    0 < eval x (cyclotomic n R) :=\n  (cyclotomic_pos_and_nonneg n x).1 hx\n\n"}
{"name":"Polynomial.cyclotomic_nonneg","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Eval","initialProofState":"n : Nat\nR : Type u_1\ninst✝ : LinearOrderedCommRing R\nx : R\nhx : LE.le 1 x\n⊢ LE.le 0 (Polynomial.eval x (Polynomial.cyclotomic n R))","decl":"/-- Cyclotomic polynomials are always nonnegative on inputs one or more. -/\ntheorem cyclotomic_nonneg (n : ℕ) {R} [LinearOrderedCommRing R] {x : R} (hx : 1 ≤ x) :\n    0 ≤ eval x (cyclotomic n R) :=\n  (cyclotomic_pos_and_nonneg n x).2 hx\n\n"}
{"name":"Polynomial.eval_one_cyclotomic_not_prime_pow","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Eval","initialProofState":"R : Type u_1\ninst✝ : Ring R\nn : Nat\nh : ∀ {p : Nat}, Nat.Prime p → ∀ (k : Nat), Ne (HPow.hPow p k) n\n⊢ Eq (Polynomial.eval 1 (Polynomial.cyclotomic n R)) 1","decl":"theorem eval_one_cyclotomic_not_prime_pow {R : Type*} [Ring R] {n : ℕ}\n    (h : ∀ {p : ℕ}, p.Prime → ∀ k : ℕ, p ^ k ≠ n) : eval 1 (cyclotomic n R) = 1 := by\n  rcases n.eq_zero_or_pos with (rfl | hn')\n  · simp\n  have hn : 1 < n := one_lt_iff_ne_zero_and_ne_one.mpr ⟨hn'.ne', (h Nat.prime_two 0).symm⟩\n  rsuffices h | h : eval 1 (cyclotomic n ℤ) = 1 ∨ eval 1 (cyclotomic n ℤ) = -1\n  · have := eval_intCast_map (Int.castRingHom R) (cyclotomic n ℤ) 1\n    simpa only [map_cyclotomic, Int.cast_one, h, eq_intCast] using this\n  · exfalso\n    linarith [cyclotomic_nonneg n (le_refl (1 : ℤ))]\n  rw [← Int.natAbs_eq_natAbs_iff, Int.natAbs_one, Nat.eq_one_iff_not_exists_prime_dvd]\n  intro p hp hpe\n  haveI := Fact.mk hp\n  have := prod_cyclotomic_eq_geom_sum hn' ℤ\n  apply_fun eval 1 at this\n  rw [eval_geom_sum, one_geom_sum, eval_prod, eq_comm, ←\n    Finset.prod_sdiff <| @range_pow_padicValNat_subset_divisors' p _ _, Finset.prod_image] at this\n  · simp_rw [eval_one_cyclotomic_prime_pow, Finset.prod_const, Finset.card_range, mul_comm] at this\n    rw [← Finset.prod_sdiff <| show {n} ⊆ _ from _] at this\n    swap\n    · simp only [singleton_subset_iff, mem_sdiff, mem_erase, Ne, mem_divisors, dvd_refl,\n        true_and, mem_image, mem_range, exists_prop, not_exists, not_and]\n      exact ⟨⟨hn.ne', hn'.ne'⟩, fun t _ => h hp _⟩\n    rw [← Int.natAbs_ofNat p, Int.natAbs_dvd_natAbs] at hpe\n    obtain ⟨t, ht⟩ := hpe\n    rw [Finset.prod_singleton, ht, mul_left_comm, mul_comm, ← mul_assoc, mul_assoc] at this\n    have : (p : ℤ) ^ padicValNat p n * p ∣ n := ⟨_, this⟩\n    simp only [← _root_.pow_succ, ← Int.natAbs_dvd_natAbs, Int.natAbs_ofNat, Int.natAbs_pow] at this\n    exact pow_succ_padicValNat_not_dvd hn'.ne' this\n  · rintro x - y - hxy\n    apply Nat.succ_injective\n    exact Nat.pow_right_injective hp.two_le hxy\n\n"}
{"name":"Polynomial.sub_one_pow_totient_lt_cyclotomic_eval","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Eval","initialProofState":"n : Nat\nq : Real\nhn' : LE.le 2 n\nhq' : LT.lt 1 q\n⊢ LT.lt (HPow.hPow (HSub.hSub q 1) n.totient) (Polynomial.eval q (Polynomial.cyclotomic n Real))","decl":"theorem sub_one_pow_totient_lt_cyclotomic_eval {n : ℕ} {q : ℝ} (hn' : 2 ≤ n) (hq' : 1 < q) :\n    (q - 1) ^ totient n < (cyclotomic n ℝ).eval q := by\n  have hn : 0 < n := pos_of_gt hn'\n  have hq := zero_lt_one.trans hq'\n  have hfor : ∀ ζ' ∈ primitiveRoots n ℂ, q - 1 ≤ ‖↑q - ζ'‖ := by\n    intro ζ' hζ'\n    rw [mem_primitiveRoots hn] at hζ'\n    convert norm_sub_norm_le (↑q) ζ'\n    · rw [Complex.norm_real, Real.norm_of_nonneg hq.le]\n    · rw [hζ'.norm'_eq_one hn.ne']\n  let ζ := Complex.exp (2 * ↑Real.pi * Complex.I / ↑n)\n  have hζ : IsPrimitiveRoot ζ n := Complex.isPrimitiveRoot_exp n hn.ne'\n  have hex : ∃ ζ' ∈ primitiveRoots n ℂ, q - 1 < ‖↑q - ζ'‖ := by\n    refine ⟨ζ, (mem_primitiveRoots hn).mpr hζ, ?_⟩\n    suffices ¬SameRay ℝ (q : ℂ) ζ by\n      convert lt_norm_sub_of_not_sameRay this <;>\n        simp only [hζ.norm'_eq_one hn.ne', Real.norm_of_nonneg hq.le, Complex.norm_real]\n    rw [Complex.sameRay_iff]\n    push_neg\n    refine ⟨mod_cast hq.ne', hζ.ne_zero hn.ne', ?_⟩\n    rw [Complex.arg_ofReal_of_nonneg hq.le, Ne, eq_comm, hζ.arg_eq_zero_iff hn.ne']\n    clear_value ζ\n    rintro rfl\n    linarith [hζ.unique IsPrimitiveRoot.one]\n  have : ¬eval (↑q) (cyclotomic n ℂ) = 0 := by simpa using (cyclotomic_pos' n hq').ne'\n  suffices Units.mk0 (Real.toNNReal (q - 1)) (by simp [hq']) ^ totient n <\n      Units.mk0 ‖(cyclotomic n ℂ).eval ↑q‖₊ (by simp_all) by\n    simp [← Units.val_lt_val, Units.val_pow_eq_pow_val, Units.val_mk0, ← NNReal.coe_lt_coe,\n      hq'.le, Real.toNNReal_lt_toNNReal_iff_of_nonneg, coe_nnnorm, Complex.norm_eq_abs,\n      NNReal.coe_pow, Real.coe_toNNReal', max_eq_left, sub_nonneg] at this\n    convert this\n    rw [eq_comm]\n    simp [cyclotomic_nonneg n hq'.le]\n  simp only [cyclotomic_eq_prod_X_sub_primitiveRoots hζ, eval_prod, eval_C, eval_X, eval_sub,\n    nnnorm_prod, Units.mk0_prod]\n  convert Finset.prod_lt_prod' (M := NNRealˣ) _ _\n  swap; · exact fun _ => Units.mk0 (Real.toNNReal (q - 1)) (by simp [hq'])\n  · simp only [Complex.card_primitiveRoots, prod_const, card_attach]\n  · simp only [Subtype.coe_mk, Finset.mem_attach, forall_true_left, Subtype.forall, ←\n      Units.val_le_val, ← NNReal.coe_le_coe, Complex.abs.nonneg, hq'.le, Units.val_mk0,\n      Real.coe_toNNReal', coe_nnnorm, Complex.norm_eq_abs, max_le_iff, tsub_le_iff_right]\n    intro x hx\n    simpa only [and_true, tsub_le_iff_right] using hfor x hx\n  · simp only [Subtype.coe_mk, Finset.mem_attach, exists_true_left, Subtype.exists, ←\n      NNReal.coe_lt_coe, ← Units.val_lt_val, Units.val_mk0 _, coe_nnnorm]\n    simpa [hq'.le, Real.coe_toNNReal', max_eq_left, sub_nonneg] using hex\n\n"}
{"name":"Polynomial.sub_one_pow_totient_le_cyclotomic_eval","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Eval","initialProofState":"q : Real\nhq' : LT.lt 1 q\nn : Nat\n⊢ LE.le (HPow.hPow (HSub.hSub q 1) n.totient) (Polynomial.eval q (Polynomial.cyclotomic n Real))","decl":"theorem sub_one_pow_totient_le_cyclotomic_eval {q : ℝ} (hq' : 1 < q) :\n    ∀ n, (q - 1) ^ totient n ≤ (cyclotomic n ℝ).eval q\n  | 0 => by simp only [totient_zero, _root_.pow_zero, cyclotomic_zero, eval_one, le_refl]\n  | 1 => by simp only [totient_one, pow_one, cyclotomic_one, eval_sub, eval_X, eval_one, le_refl]\n  | _ + 2 => (sub_one_pow_totient_lt_cyclotomic_eval le_add_self hq').le\n\n"}
{"name":"Polynomial.cyclotomic_eval_lt_add_one_pow_totient","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Eval","initialProofState":"n : Nat\nq : Real\nhn' : LE.le 3 n\nhq' : LT.lt 1 q\n⊢ LT.lt (Polynomial.eval q (Polynomial.cyclotomic n Real)) (HPow.hPow (HAdd.hAdd q 1) n.totient)","decl":"theorem cyclotomic_eval_lt_add_one_pow_totient {n : ℕ} {q : ℝ} (hn' : 3 ≤ n) (hq' : 1 < q) :\n    (cyclotomic n ℝ).eval q < (q + 1) ^ totient n := by\n  have hn : 0 < n := pos_of_gt hn'\n  have hq := zero_lt_one.trans hq'\n  have hfor : ∀ ζ' ∈ primitiveRoots n ℂ, ‖↑q - ζ'‖ ≤ q + 1 := by\n    intro ζ' hζ'\n    rw [mem_primitiveRoots hn] at hζ'\n    convert norm_sub_le (↑q) ζ'\n    · rw [Complex.norm_real, Real.norm_of_nonneg (zero_le_one.trans_lt hq').le]\n    · rw [hζ'.norm'_eq_one hn.ne']\n  let ζ := Complex.exp (2 * ↑Real.pi * Complex.I / ↑n)\n  have hζ : IsPrimitiveRoot ζ n := Complex.isPrimitiveRoot_exp n hn.ne'\n  have hex : ∃ ζ' ∈ primitiveRoots n ℂ, ‖↑q - ζ'‖ < q + 1 := by\n    refine ⟨ζ, (mem_primitiveRoots hn).mpr hζ, ?_⟩\n    suffices ¬SameRay ℝ (q : ℂ) (-ζ) by\n      convert norm_add_lt_of_not_sameRay this using 2\n      · rw [Complex.norm_eq_abs, Complex.abs_ofReal]\n        symm\n        exact abs_eq_self.mpr hq.le\n      · simp [abs_of_pos hq, hζ.norm'_eq_one hn.ne', -Complex.norm_eq_abs]\n    rw [Complex.sameRay_iff]\n    push_neg\n    refine ⟨mod_cast hq.ne', neg_ne_zero.mpr <| hζ.ne_zero hn.ne', ?_⟩\n    rw [Complex.arg_ofReal_of_nonneg hq.le, Ne, eq_comm]\n    intro h\n    rw [Complex.arg_eq_zero_iff, Complex.neg_re, neg_nonneg, Complex.neg_im, neg_eq_zero] at h\n    have hζ₀ : ζ ≠ 0 := by\n      clear_value ζ\n      rintro rfl\n      exact hn.ne' (hζ.unique IsPrimitiveRoot.zero)\n    have : ζ.re < 0 ∧ ζ.im = 0 := ⟨h.1.lt_of_ne ?_, h.2⟩\n    · rw [← Complex.arg_eq_pi_iff, hζ.arg_eq_pi_iff hn.ne'] at this\n      rw [this] at hζ\n      linarith [hζ.unique <| IsPrimitiveRoot.neg_one 0 two_ne_zero.symm]\n    · contrapose! hζ₀\n      apply Complex.ext <;> simp [hζ₀, h.2]\n  have : ¬eval (↑q) (cyclotomic n ℂ) = 0 := by simpa using (cyclotomic_pos' n hq').ne.symm\n  suffices Units.mk0 ‖(cyclotomic n ℂ).eval ↑q‖₊ (by simp_all) <\n      Units.mk0 (Real.toNNReal (q + 1)) (by simp; linarith) ^ totient n by\n    simp only [← Units.val_lt_val, Units.val_pow_eq_pow_val, Units.val_mk0, ← NNReal.coe_lt_coe,\n      hq'.le, Real.toNNReal_lt_toNNReal_iff_of_nonneg, coe_nnnorm, Complex.norm_eq_abs,\n      NNReal.coe_pow, Real.coe_toNNReal', max_eq_left, sub_nonneg] at this\n    convert this using 2\n    · rw [eq_comm]\n      simp [cyclotomic_nonneg n hq'.le]\n    rw [eq_comm, max_eq_left_iff]\n    linarith\n  simp only [cyclotomic_eq_prod_X_sub_primitiveRoots hζ, eval_prod, eval_C, eval_X, eval_sub,\n    nnnorm_prod, Units.mk0_prod]\n  convert Finset.prod_lt_prod' (M := NNRealˣ) _ _\n  swap; · exact fun _ => Units.mk0 (Real.toNNReal (q + 1)) (by simp; linarith only [hq'])\n  · simp [Complex.card_primitiveRoots]\n  · simp only [Subtype.coe_mk, Finset.mem_attach, forall_true_left, Subtype.forall, ←\n      Units.val_le_val, ← NNReal.coe_le_coe, Complex.abs.nonneg, hq'.le, Units.val_mk0,\n      Real.coe_toNNReal, coe_nnnorm, Complex.norm_eq_abs, max_le_iff]\n    intro x hx\n    have : Complex.abs _ ≤ _ := hfor x hx\n    simp [this]\n  · simp only [Subtype.coe_mk, Finset.mem_attach, exists_true_left, Subtype.exists, ←\n      NNReal.coe_lt_coe, ← Units.val_lt_val, Units.val_mk0 _, coe_nnnorm]\n    obtain ⟨ζ, hζ, hhζ : Complex.abs _ < _⟩ := hex\n    exact ⟨ζ, hζ, by simp [hhζ]⟩\n\n"}
{"name":"Polynomial.cyclotomic_eval_le_add_one_pow_totient","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Eval","initialProofState":"q : Real\nhq' : LT.lt 1 q\nn : Nat\n⊢ LE.le (Polynomial.eval q (Polynomial.cyclotomic n Real)) (HPow.hPow (HAdd.hAdd q 1) n.totient)","decl":"theorem cyclotomic_eval_le_add_one_pow_totient {q : ℝ} (hq' : 1 < q) :\n    ∀ n, (cyclotomic n ℝ).eval q ≤ (q + 1) ^ totient n\n  | 0 => by simp\n  | 1 => by simp [add_assoc, add_nonneg, zero_le_one]\n  | 2 => by simp\n  | _ + 3 => (cyclotomic_eval_lt_add_one_pow_totient le_add_self hq').le\n\n"}
{"name":"Polynomial.sub_one_pow_totient_lt_natAbs_cyclotomic_eval","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Eval","initialProofState":"n q : Nat\nhn' : LT.lt 1 n\nhq : Ne q 1\n⊢ LT.lt (HPow.hPow (HSub.hSub q 1) n.totient) (Polynomial.eval (↑q) (Polynomial.cyclotomic n Int)).natAbs","decl":"theorem sub_one_pow_totient_lt_natAbs_cyclotomic_eval {n : ℕ} {q : ℕ} (hn' : 1 < n) (hq : q ≠ 1) :\n    (q - 1) ^ totient n < ((cyclotomic n ℤ).eval ↑q).natAbs := by\n  rcases hq.lt_or_lt.imp_left Nat.lt_one_iff.mp with (rfl | hq')\n  · rw [zero_tsub, zero_pow (Nat.totient_pos.2 (pos_of_gt hn')).ne', pos_iff_ne_zero,\n      Int.natAbs_ne_zero, Nat.cast_zero, ← coeff_zero_eq_eval_zero, cyclotomic_coeff_zero _ hn']\n    exact one_ne_zero\n  rw [← @Nat.cast_lt ℝ, Nat.cast_pow, Nat.cast_sub hq'.le, Nat.cast_one, Int.cast_natAbs]\n  refine (sub_one_pow_totient_lt_cyclotomic_eval hn' (Nat.one_lt_cast.2 hq')).trans_le ?_\n  convert (cyclotomic.eval_apply (q : ℤ) n (algebraMap ℤ ℝ)).trans_le (le_abs_self _)\n  simp\n\n"}
{"name":"Polynomial.sub_one_lt_natAbs_cyclotomic_eval","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Eval","initialProofState":"n q : Nat\nhn' : LT.lt 1 n\nhq : Ne q 1\n⊢ LT.lt (HSub.hSub q 1) (Polynomial.eval (↑q) (Polynomial.cyclotomic n Int)).natAbs","decl":"theorem sub_one_lt_natAbs_cyclotomic_eval {n : ℕ} {q : ℕ} (hn' : 1 < n) (hq : q ≠ 1) :\n    q - 1 < ((cyclotomic n ℤ).eval ↑q).natAbs :=\n  calc\n    q - 1 ≤ (q - 1) ^ totient n := Nat.le_self_pow (Nat.totient_pos.2 <| pos_of_gt hn').ne' _\n    _ < ((cyclotomic n ℤ).eval ↑q).natAbs := sub_one_pow_totient_lt_natAbs_cyclotomic_eval hn' hq\n\n"}
