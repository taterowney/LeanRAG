{"name":"Finset.add_sum_Ico_eq_sum_Icc","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : AddCommMonoid M\nf : α → M\na b : α\ninst✝ : LocallyFiniteOrder α\nh : LE.le a b\n⊢ Eq (HAdd.hAdd (f b) ((Finset.Ico a b).sum fun x => f x)) ((Finset.Icc a b).sum fun x => f x)","decl":"@[to_additive]\nlemma mul_prod_Ico_eq_prod_Icc (h : a ≤ b) : f b * ∏ x ∈ Ico a b, f x = ∏ x ∈ Icc a b, f x := by\n  rw [Icc_eq_cons_Ico h, prod_cons]\n\n"}
{"name":"Finset.mul_prod_Ico_eq_prod_Icc","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : CommMonoid M\nf : α → M\na b : α\ninst✝ : LocallyFiniteOrder α\nh : LE.le a b\n⊢ Eq (HMul.hMul (f b) ((Finset.Ico a b).prod fun x => f x)) ((Finset.Icc a b).prod fun x => f x)","decl":"@[to_additive]\nlemma mul_prod_Ico_eq_prod_Icc (h : a ≤ b) : f b * ∏ x ∈ Ico a b, f x = ∏ x ∈ Icc a b, f x := by\n  rw [Icc_eq_cons_Ico h, prod_cons]\n\n"}
{"name":"Finset.prod_Ico_mul_eq_prod_Icc","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : CommMonoid M\nf : α → M\na b : α\ninst✝ : LocallyFiniteOrder α\nh : LE.le a b\n⊢ Eq (HMul.hMul ((Finset.Ico a b).prod fun x => f x) (f b)) ((Finset.Icc a b).prod fun x => f x)","decl":"@[to_additive]\nlemma prod_Ico_mul_eq_prod_Icc (h : a ≤ b) : (∏ x ∈ Ico a b, f x) * f b = ∏ x ∈ Icc a b, f x := by\n  rw [mul_comm, mul_prod_Ico_eq_prod_Icc h]\n\n"}
{"name":"Finset.sum_Ico_add_eq_sum_Icc","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : AddCommMonoid M\nf : α → M\na b : α\ninst✝ : LocallyFiniteOrder α\nh : LE.le a b\n⊢ Eq (HAdd.hAdd ((Finset.Ico a b).sum fun x => f x) (f b)) ((Finset.Icc a b).sum fun x => f x)","decl":"@[to_additive]\nlemma prod_Ico_mul_eq_prod_Icc (h : a ≤ b) : (∏ x ∈ Ico a b, f x) * f b = ∏ x ∈ Icc a b, f x := by\n  rw [mul_comm, mul_prod_Ico_eq_prod_Icc h]\n\n"}
{"name":"Finset.mul_prod_Ioc_eq_prod_Icc","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : CommMonoid M\nf : α → M\na b : α\ninst✝ : LocallyFiniteOrder α\nh : LE.le a b\n⊢ Eq (HMul.hMul (f a) ((Finset.Ioc a b).prod fun x => f x)) ((Finset.Icc a b).prod fun x => f x)","decl":"@[to_additive]\nlemma mul_prod_Ioc_eq_prod_Icc (h : a ≤ b) : f a * ∏ x ∈ Ioc a b, f x = ∏ x ∈ Icc a b, f x := by\n  rw [Icc_eq_cons_Ioc h, prod_cons]\n\n"}
{"name":"Finset.add_sum_Ioc_eq_sum_Icc","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : AddCommMonoid M\nf : α → M\na b : α\ninst✝ : LocallyFiniteOrder α\nh : LE.le a b\n⊢ Eq (HAdd.hAdd (f a) ((Finset.Ioc a b).sum fun x => f x)) ((Finset.Icc a b).sum fun x => f x)","decl":"@[to_additive]\nlemma mul_prod_Ioc_eq_prod_Icc (h : a ≤ b) : f a * ∏ x ∈ Ioc a b, f x = ∏ x ∈ Icc a b, f x := by\n  rw [Icc_eq_cons_Ioc h, prod_cons]\n\n"}
{"name":"Finset.sum_Ioc_add_eq_sum_Icc","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : AddCommMonoid M\nf : α → M\na b : α\ninst✝ : LocallyFiniteOrder α\nh : LE.le a b\n⊢ Eq (HAdd.hAdd ((Finset.Ioc a b).sum fun x => f x) (f a)) ((Finset.Icc a b).sum fun x => f x)","decl":"@[to_additive]\nlemma prod_Ioc_mul_eq_prod_Icc (h : a ≤ b) : (∏ x ∈ Ioc a b, f x) * f a = ∏ x ∈ Icc a b, f x := by\n  rw [mul_comm, mul_prod_Ioc_eq_prod_Icc h]\n\n"}
{"name":"Finset.prod_Ioc_mul_eq_prod_Icc","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : CommMonoid M\nf : α → M\na b : α\ninst✝ : LocallyFiniteOrder α\nh : LE.le a b\n⊢ Eq (HMul.hMul ((Finset.Ioc a b).prod fun x => f x) (f a)) ((Finset.Icc a b).prod fun x => f x)","decl":"@[to_additive]\nlemma prod_Ioc_mul_eq_prod_Icc (h : a ≤ b) : (∏ x ∈ Ioc a b, f x) * f a = ∏ x ∈ Icc a b, f x := by\n  rw [mul_comm, mul_prod_Ioc_eq_prod_Icc h]\n\n"}
{"name":"Finset.add_sum_Ioi_eq_sum_Ici","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : AddCommMonoid M\nf : α → M\ninst✝ : LocallyFiniteOrderTop α\na : α\n⊢ Eq (HAdd.hAdd (f a) ((Finset.Ioi a).sum fun x => f x)) ((Finset.Ici a).sum fun x => f x)","decl":"@[to_additive]\nlemma mul_prod_Ioi_eq_prod_Ici (a : α) : f a * ∏ x ∈ Ioi a, f x = ∏ x ∈ Ici a, f x := by\n  rw [Ici_eq_cons_Ioi, prod_cons]\n\n"}
{"name":"Finset.mul_prod_Ioi_eq_prod_Ici","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : CommMonoid M\nf : α → M\ninst✝ : LocallyFiniteOrderTop α\na : α\n⊢ Eq (HMul.hMul (f a) ((Finset.Ioi a).prod fun x => f x)) ((Finset.Ici a).prod fun x => f x)","decl":"@[to_additive]\nlemma mul_prod_Ioi_eq_prod_Ici (a : α) : f a * ∏ x ∈ Ioi a, f x = ∏ x ∈ Ici a, f x := by\n  rw [Ici_eq_cons_Ioi, prod_cons]\n\n"}
{"name":"Finset.sum_Ioi_add_eq_sum_Ici","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : AddCommMonoid M\nf : α → M\ninst✝ : LocallyFiniteOrderTop α\na : α\n⊢ Eq (HAdd.hAdd ((Finset.Ioi a).sum fun x => f x) (f a)) ((Finset.Ici a).sum fun x => f x)","decl":"@[to_additive]\nlemma prod_Ioi_mul_eq_prod_Ici (a : α) : (∏ x ∈ Ioi a, f x) * f a = ∏ x ∈ Ici a, f x := by\n  rw [mul_comm, mul_prod_Ioi_eq_prod_Ici]\n\n"}
{"name":"Finset.prod_Ioi_mul_eq_prod_Ici","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : CommMonoid M\nf : α → M\ninst✝ : LocallyFiniteOrderTop α\na : α\n⊢ Eq (HMul.hMul ((Finset.Ioi a).prod fun x => f x) (f a)) ((Finset.Ici a).prod fun x => f x)","decl":"@[to_additive]\nlemma prod_Ioi_mul_eq_prod_Ici (a : α) : (∏ x ∈ Ioi a, f x) * f a = ∏ x ∈ Ici a, f x := by\n  rw [mul_comm, mul_prod_Ioi_eq_prod_Ici]\n\n"}
{"name":"Finset.mul_prod_Iio_eq_prod_Iic","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : CommMonoid M\nf : α → M\ninst✝ : LocallyFiniteOrderBot α\na : α\n⊢ Eq (HMul.hMul (f a) ((Finset.Iio a).prod fun x => f x)) ((Finset.Iic a).prod fun x => f x)","decl":"@[to_additive]\nlemma mul_prod_Iio_eq_prod_Iic (a : α) : f a * ∏ x ∈ Iio a, f x = ∏ x ∈ Iic a, f x := by\n  rw [Iic_eq_cons_Iio, prod_cons]\n\n"}
{"name":"Finset.add_sum_Iio_eq_sum_Iic","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : AddCommMonoid M\nf : α → M\ninst✝ : LocallyFiniteOrderBot α\na : α\n⊢ Eq (HAdd.hAdd (f a) ((Finset.Iio a).sum fun x => f x)) ((Finset.Iic a).sum fun x => f x)","decl":"@[to_additive]\nlemma mul_prod_Iio_eq_prod_Iic (a : α) : f a * ∏ x ∈ Iio a, f x = ∏ x ∈ Iic a, f x := by\n  rw [Iic_eq_cons_Iio, prod_cons]\n\n"}
{"name":"Finset.sum_Iio_add_eq_sum_Iic","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : AddCommMonoid M\nf : α → M\ninst✝ : LocallyFiniteOrderBot α\na : α\n⊢ Eq (HAdd.hAdd ((Finset.Iio a).sum fun x => f x) (f a)) ((Finset.Iic a).sum fun x => f x)","decl":"@[to_additive]\nlemma prod_Iio_mul_eq_prod_Iic (a : α) : (∏ x ∈ Iio a, f x) * f a = ∏ x ∈ Iic a, f x := by\n  rw [mul_comm, mul_prod_Iio_eq_prod_Iic]\n\n"}
{"name":"Finset.prod_Iio_mul_eq_prod_Iic","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : CommMonoid M\nf : α → M\ninst✝ : LocallyFiniteOrderBot α\na : α\n⊢ Eq (HMul.hMul ((Finset.Iio a).prod fun x => f x) (f a)) ((Finset.Iic a).prod fun x => f x)","decl":"@[to_additive]\nlemma prod_Iio_mul_eq_prod_Iic (a : α) : (∏ x ∈ Iio a, f x) * f a = ∏ x ∈ Iic a, f x := by\n  rw [mul_comm, mul_prod_Iio_eq_prod_Iic]\n\n"}
{"name":"Finset.prod_prod_Ioi_mul_eq_prod_prod_off_diag","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝⁴ : Fintype α\ninst✝³ : LinearOrder α\ninst✝² : LocallyFiniteOrderTop α\ninst✝¹ : LocallyFiniteOrderBot α\ninst✝ : CommMonoid M\nf : α → α → M\n⊢ Eq (Finset.univ.prod fun i => (Finset.Ioi i).prod fun j => HMul.hMul (f j i) (f i j)) (Finset.univ.prod fun i => (HasCompl.compl (Singleton.singleton i)).prod fun j => f j i)","decl":"@[to_additive]\nlemma prod_prod_Ioi_mul_eq_prod_prod_off_diag (f : α → α → M) :\n    ∏ i, ∏ j ∈ Ioi i, f j i * f i j = ∏ i, ∏ j ∈ {i}ᶜ, f j i := by\n  simp_rw [← Ioi_disjUnion_Iio, prod_disjUnion, prod_mul_distrib]\n  congr 1\n  rw [prod_sigma', prod_sigma']\n  refine prod_nbij' (fun i ↦ ⟨i.2, i.1⟩) (fun i ↦ ⟨i.2, i.1⟩) ?_ ?_ ?_ ?_ ?_ <;> simp\n\n"}
{"name":"Finset.sum_sum_Ioi_add_eq_sum_sum_off_diag","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝⁴ : Fintype α\ninst✝³ : LinearOrder α\ninst✝² : LocallyFiniteOrderTop α\ninst✝¹ : LocallyFiniteOrderBot α\ninst✝ : AddCommMonoid M\nf : α → α → M\n⊢ Eq (Finset.univ.sum fun i => (Finset.Ioi i).sum fun j => HAdd.hAdd (f j i) (f i j)) (Finset.univ.sum fun i => (HasCompl.compl (Singleton.singleton i)).sum fun j => f j i)","decl":"@[to_additive]\nlemma prod_prod_Ioi_mul_eq_prod_prod_off_diag (f : α → α → M) :\n    ∏ i, ∏ j ∈ Ioi i, f j i * f i j = ∏ i, ∏ j ∈ {i}ᶜ, f j i := by\n  simp_rw [← Ioi_disjUnion_Iio, prod_disjUnion, prod_mul_distrib]\n  congr 1\n  rw [prod_sigma', prod_sigma']\n  refine prod_nbij' (fun i ↦ ⟨i.2, i.1⟩) (fun i ↦ ⟨i.2, i.1⟩) ?_ ?_ ?_ ?_ ?_ <;> simp\n\n"}
{"name":"Finset.sum_Ico_add'","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : OrderedCancelAddCommMonoid α\ninst✝¹ : ExistsAddOfLE α\ninst✝ : LocallyFiniteOrder α\nf : α → M\na b c : α\n⊢ Eq ((Finset.Ico a b).sum fun x => f (HAdd.hAdd x c)) ((Finset.Ico (HAdd.hAdd a c) (HAdd.hAdd b c)).sum fun x => f x)","decl":"@[to_additive]\ntheorem prod_Ico_add' [OrderedCancelAddCommMonoid α] [ExistsAddOfLE α] [LocallyFiniteOrder α]\n    (f : α → M) (a b c : α) : (∏ x ∈ Ico a b, f (x + c)) = ∏ x ∈ Ico (a + c) (b + c), f x := by\n  rw [← map_add_right_Ico, prod_map]\n  rfl\n\n"}
{"name":"Finset.prod_Ico_add'","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝³ : CommMonoid M\ninst✝² : OrderedCancelAddCommMonoid α\ninst✝¹ : ExistsAddOfLE α\ninst✝ : LocallyFiniteOrder α\nf : α → M\na b c : α\n⊢ Eq ((Finset.Ico a b).prod fun x => f (HAdd.hAdd x c)) ((Finset.Ico (HAdd.hAdd a c) (HAdd.hAdd b c)).prod fun x => f x)","decl":"@[to_additive]\ntheorem prod_Ico_add' [OrderedCancelAddCommMonoid α] [ExistsAddOfLE α] [LocallyFiniteOrder α]\n    (f : α → M) (a b c : α) : (∏ x ∈ Ico a b, f (x + c)) = ∏ x ∈ Ico (a + c) (b + c), f x := by\n  rw [← map_add_right_Ico, prod_map]\n  rfl\n\n"}
{"name":"Finset.prod_Ico_add","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝³ : CommMonoid M\ninst✝² : OrderedCancelAddCommMonoid α\ninst✝¹ : ExistsAddOfLE α\ninst✝ : LocallyFiniteOrder α\nf : α → M\na b c : α\n⊢ Eq ((Finset.Ico a b).prod fun x => f (HAdd.hAdd c x)) ((Finset.Ico (HAdd.hAdd a c) (HAdd.hAdd b c)).prod fun x => f x)","decl":"@[to_additive]\ntheorem prod_Ico_add [OrderedCancelAddCommMonoid α] [ExistsAddOfLE α] [LocallyFiniteOrder α]\n    (f : α → M) (a b c : α) : (∏ x ∈ Ico a b, f (c + x)) = ∏ x ∈ Ico (a + c) (b + c), f x := by\n  convert prod_Ico_add' f a b c using 2\n  rw [add_comm]\n\n"}
{"name":"Finset.sum_Ico_add","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : OrderedCancelAddCommMonoid α\ninst✝¹ : ExistsAddOfLE α\ninst✝ : LocallyFiniteOrder α\nf : α → M\na b c : α\n⊢ Eq ((Finset.Ico a b).sum fun x => f (HAdd.hAdd c x)) ((Finset.Ico (HAdd.hAdd a c) (HAdd.hAdd b c)).sum fun x => f x)","decl":"@[to_additive]\ntheorem prod_Ico_add [OrderedCancelAddCommMonoid α] [ExistsAddOfLE α] [LocallyFiniteOrder α]\n    (f : α → M) (a b c : α) : (∏ x ∈ Ico a b, f (c + x)) = ∏ x ∈ Ico (a + c) (b + c), f x := by\n  convert prod_Ico_add' f a b c using 2\n  rw [add_comm]\n\n"}
{"name":"Finset.sum_Ico_add_right_sub_eq","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\nf : α → M\ninst✝⁴ : OrderedCancelAddCommMonoid α\ninst✝³ : ExistsAddOfLE α\ninst✝² : LocallyFiniteOrder α\ninst✝¹ : Sub α\ninst✝ : OrderedSub α\na b c : α\n⊢ Eq ((Finset.Ico (HAdd.hAdd a c) (HAdd.hAdd b c)).sum fun x => f (HSub.hSub x c)) ((Finset.Ico a b).sum fun x => f x)","decl":"@[to_additive (attr := simp)]\ntheorem prod_Ico_add_right_sub_eq [OrderedCancelAddCommMonoid α] [ExistsAddOfLE α]\n    [LocallyFiniteOrder α] [Sub α] [OrderedSub α] (a b c : α) :\n    ∏ x ∈ Ico (a + c) (b + c), f (x - c) = ∏ x ∈ Ico a b, f x := by\n  simp only [← map_add_right_Ico, prod_map, addRightEmbedding_apply, add_tsub_cancel_right]\n\n"}
{"name":"Finset.prod_Ico_add_right_sub_eq","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝⁵ : CommMonoid M\nf : α → M\ninst✝⁴ : OrderedCancelAddCommMonoid α\ninst✝³ : ExistsAddOfLE α\ninst✝² : LocallyFiniteOrder α\ninst✝¹ : Sub α\ninst✝ : OrderedSub α\na b c : α\n⊢ Eq ((Finset.Ico (HAdd.hAdd a c) (HAdd.hAdd b c)).prod fun x => f (HSub.hSub x c)) ((Finset.Ico a b).prod fun x => f x)","decl":"@[to_additive (attr := simp)]\ntheorem prod_Ico_add_right_sub_eq [OrderedCancelAddCommMonoid α] [ExistsAddOfLE α]\n    [LocallyFiniteOrder α] [Sub α] [OrderedSub α] (a b c : α) :\n    ∏ x ∈ Ico (a + c) (b + c), f (x - c) = ∏ x ∈ Ico a b, f x := by\n  simp only [← map_add_right_Ico, prod_map, addRightEmbedding_apply, add_tsub_cancel_right]\n\n"}
{"name":"Finset.prod_Ico_succ_top","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_2\ninst✝ : CommMonoid M\na b : Nat\nhab : LE.le a b\nf : Nat → M\n⊢ Eq ((Finset.Ico a (HAdd.hAdd b 1)).prod fun k => f k) (HMul.hMul ((Finset.Ico a b).prod fun k => f k) (f b))","decl":"@[to_additive]\ntheorem prod_Ico_succ_top {a b : ℕ} (hab : a ≤ b) (f : ℕ → M) :\n    (∏ k ∈ Ico a (b + 1), f k) = (∏ k ∈ Ico a b, f k) * f b := by\n  rw [Nat.Ico_succ_right_eq_insert_Ico hab, prod_insert right_not_mem_Ico, mul_comm]\n\n"}
{"name":"Finset.sum_Ico_succ_top","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_2\ninst✝ : AddCommMonoid M\na b : Nat\nhab : LE.le a b\nf : Nat → M\n⊢ Eq ((Finset.Ico a (HAdd.hAdd b 1)).sum fun k => f k) (HAdd.hAdd ((Finset.Ico a b).sum fun k => f k) (f b))","decl":"@[to_additive]\ntheorem prod_Ico_succ_top {a b : ℕ} (hab : a ≤ b) (f : ℕ → M) :\n    (∏ k ∈ Ico a (b + 1), f k) = (∏ k ∈ Ico a b, f k) * f b := by\n  rw [Nat.Ico_succ_right_eq_insert_Ico hab, prod_insert right_not_mem_Ico, mul_comm]\n\n"}
{"name":"Finset.sum_eq_sum_Ico_succ_bot","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_2\ninst✝ : AddCommMonoid M\na b : Nat\nhab : LT.lt a b\nf : Nat → M\n⊢ Eq ((Finset.Ico a b).sum fun k => f k) (HAdd.hAdd (f a) ((Finset.Ico (HAdd.hAdd a 1) b).sum fun k => f k))","decl":"@[to_additive]\ntheorem prod_eq_prod_Ico_succ_bot {a b : ℕ} (hab : a < b) (f : ℕ → M) :\n    ∏ k ∈ Ico a b, f k = f a * ∏ k ∈ Ico (a + 1) b, f k := by\n  have ha : a ∉ Ico (a + 1) b := by simp\n  rw [← prod_insert ha, Nat.Ico_insert_succ_left hab]\n\n"}
{"name":"Finset.prod_eq_prod_Ico_succ_bot","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_2\ninst✝ : CommMonoid M\na b : Nat\nhab : LT.lt a b\nf : Nat → M\n⊢ Eq ((Finset.Ico a b).prod fun k => f k) (HMul.hMul (f a) ((Finset.Ico (HAdd.hAdd a 1) b).prod fun k => f k))","decl":"@[to_additive]\ntheorem prod_eq_prod_Ico_succ_bot {a b : ℕ} (hab : a < b) (f : ℕ → M) :\n    ∏ k ∈ Ico a b, f k = f a * ∏ k ∈ Ico (a + 1) b, f k := by\n  have ha : a ∉ Ico (a + 1) b := by simp\n  rw [← prod_insert ha, Nat.Ico_insert_succ_left hab]\n\n"}
{"name":"Finset.sum_Ico_consecutive","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_2\ninst✝ : AddCommMonoid M\nf : Nat → M\nm n k : Nat\nhmn : LE.le m n\nhnk : LE.le n k\n⊢ Eq (HAdd.hAdd ((Finset.Ico m n).sum fun i => f i) ((Finset.Ico n k).sum fun i => f i)) ((Finset.Ico m k).sum fun i => f i)","decl":"@[to_additive]\ntheorem prod_Ico_consecutive (f : ℕ → M) {m n k : ℕ} (hmn : m ≤ n) (hnk : n ≤ k) :\n    ((∏ i ∈ Ico m n, f i) * ∏ i ∈ Ico n k, f i) = ∏ i ∈ Ico m k, f i :=\n  Ico_union_Ico_eq_Ico hmn hnk ▸ Eq.symm (prod_union (Ico_disjoint_Ico_consecutive m n k))\n\n"}
{"name":"Finset.prod_Ico_consecutive","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_2\ninst✝ : CommMonoid M\nf : Nat → M\nm n k : Nat\nhmn : LE.le m n\nhnk : LE.le n k\n⊢ Eq (HMul.hMul ((Finset.Ico m n).prod fun i => f i) ((Finset.Ico n k).prod fun i => f i)) ((Finset.Ico m k).prod fun i => f i)","decl":"@[to_additive]\ntheorem prod_Ico_consecutive (f : ℕ → M) {m n k : ℕ} (hmn : m ≤ n) (hnk : n ≤ k) :\n    ((∏ i ∈ Ico m n, f i) * ∏ i ∈ Ico n k, f i) = ∏ i ∈ Ico m k, f i :=\n  Ico_union_Ico_eq_Ico hmn hnk ▸ Eq.symm (prod_union (Ico_disjoint_Ico_consecutive m n k))\n\n"}
{"name":"Finset.prod_Ioc_consecutive","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_2\ninst✝ : CommMonoid M\nf : Nat → M\nm n k : Nat\nhmn : LE.le m n\nhnk : LE.le n k\n⊢ Eq (HMul.hMul ((Finset.Ioc m n).prod fun i => f i) ((Finset.Ioc n k).prod fun i => f i)) ((Finset.Ioc m k).prod fun i => f i)","decl":"@[to_additive]\ntheorem prod_Ioc_consecutive (f : ℕ → M) {m n k : ℕ} (hmn : m ≤ n) (hnk : n ≤ k) :\n    ((∏ i ∈ Ioc m n, f i) * ∏ i ∈ Ioc n k, f i) = ∏ i ∈ Ioc m k, f i := by\n  rw [← Ioc_union_Ioc_eq_Ioc hmn hnk, prod_union]\n  apply disjoint_left.2 fun x hx h'x => _\n  intros x hx h'x\n  exact lt_irrefl _ ((mem_Ioc.1 h'x).1.trans_le (mem_Ioc.1 hx).2)\n\n"}
{"name":"Finset.sum_Ioc_consecutive","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_2\ninst✝ : AddCommMonoid M\nf : Nat → M\nm n k : Nat\nhmn : LE.le m n\nhnk : LE.le n k\n⊢ Eq (HAdd.hAdd ((Finset.Ioc m n).sum fun i => f i) ((Finset.Ioc n k).sum fun i => f i)) ((Finset.Ioc m k).sum fun i => f i)","decl":"@[to_additive]\ntheorem prod_Ioc_consecutive (f : ℕ → M) {m n k : ℕ} (hmn : m ≤ n) (hnk : n ≤ k) :\n    ((∏ i ∈ Ioc m n, f i) * ∏ i ∈ Ioc n k, f i) = ∏ i ∈ Ioc m k, f i := by\n  rw [← Ioc_union_Ioc_eq_Ioc hmn hnk, prod_union]\n  apply disjoint_left.2 fun x hx h'x => _\n  intros x hx h'x\n  exact lt_irrefl _ ((mem_Ioc.1 h'x).1.trans_le (mem_Ioc.1 hx).2)\n\n"}
{"name":"Finset.prod_Ioc_succ_top","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_2\ninst✝ : CommMonoid M\na b : Nat\nhab : LE.le a b\nf : Nat → M\n⊢ Eq ((Finset.Ioc a (HAdd.hAdd b 1)).prod fun k => f k) (HMul.hMul ((Finset.Ioc a b).prod fun k => f k) (f (HAdd.hAdd b 1)))","decl":"@[to_additive]\ntheorem prod_Ioc_succ_top {a b : ℕ} (hab : a ≤ b) (f : ℕ → M) :\n    (∏ k ∈ Ioc a (b + 1), f k) = (∏ k ∈ Ioc a b, f k) * f (b + 1) := by\n  rw [← prod_Ioc_consecutive _ hab (Nat.le_succ b), Nat.Ioc_succ_singleton, prod_singleton]\n\n"}
{"name":"Finset.sum_Ioc_succ_top","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_2\ninst✝ : AddCommMonoid M\na b : Nat\nhab : LE.le a b\nf : Nat → M\n⊢ Eq ((Finset.Ioc a (HAdd.hAdd b 1)).sum fun k => f k) (HAdd.hAdd ((Finset.Ioc a b).sum fun k => f k) (f (HAdd.hAdd b 1)))","decl":"@[to_additive]\ntheorem prod_Ioc_succ_top {a b : ℕ} (hab : a ≤ b) (f : ℕ → M) :\n    (∏ k ∈ Ioc a (b + 1), f k) = (∏ k ∈ Ioc a b, f k) * f (b + 1) := by\n  rw [← prod_Ioc_consecutive _ hab (Nat.le_succ b), Nat.Ioc_succ_singleton, prod_singleton]\n\n"}
{"name":"Finset.sum_Icc_succ_top","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_2\ninst✝ : AddCommMonoid M\na b : Nat\nhab : LE.le a (HAdd.hAdd b 1)\nf : Nat → M\n⊢ Eq ((Finset.Icc a (HAdd.hAdd b 1)).sum fun k => f k) (HAdd.hAdd ((Finset.Icc a b).sum fun k => f k) (f (HAdd.hAdd b 1)))","decl":"@[to_additive]\ntheorem prod_Icc_succ_top {a b : ℕ} (hab : a ≤ b + 1) (f : ℕ → M) :\n    (∏ k ∈ Icc a (b + 1), f k) = (∏ k ∈ Icc a b, f k) * f (b + 1) := by\n  rw [← Nat.Ico_succ_right, prod_Ico_succ_top hab, Nat.Ico_succ_right]\n\n"}
{"name":"Finset.prod_Icc_succ_top","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_2\ninst✝ : CommMonoid M\na b : Nat\nhab : LE.le a (HAdd.hAdd b 1)\nf : Nat → M\n⊢ Eq ((Finset.Icc a (HAdd.hAdd b 1)).prod fun k => f k) (HMul.hMul ((Finset.Icc a b).prod fun k => f k) (f (HAdd.hAdd b 1)))","decl":"@[to_additive]\ntheorem prod_Icc_succ_top {a b : ℕ} (hab : a ≤ b + 1) (f : ℕ → M) :\n    (∏ k ∈ Icc a (b + 1), f k) = (∏ k ∈ Icc a b, f k) * f (b + 1) := by\n  rw [← Nat.Ico_succ_right, prod_Ico_succ_top hab, Nat.Ico_succ_right]\n\n"}
{"name":"Finset.sum_range_add_sum_Ico","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_2\ninst✝ : AddCommMonoid M\nf : Nat → M\nm n : Nat\nh : LE.le m n\n⊢ Eq (HAdd.hAdd ((Finset.range m).sum fun k => f k) ((Finset.Ico m n).sum fun k => f k)) ((Finset.range n).sum fun k => f k)","decl":"@[to_additive]\ntheorem prod_range_mul_prod_Ico (f : ℕ → M) {m n : ℕ} (h : m ≤ n) :\n    ((∏ k ∈ range m, f k) * ∏ k ∈ Ico m n, f k) = ∏ k ∈ range n, f k :=\n  Nat.Ico_zero_eq_range ▸ Nat.Ico_zero_eq_range ▸ prod_Ico_consecutive f m.zero_le h\n\n"}
{"name":"Finset.prod_range_mul_prod_Ico","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_2\ninst✝ : CommMonoid M\nf : Nat → M\nm n : Nat\nh : LE.le m n\n⊢ Eq (HMul.hMul ((Finset.range m).prod fun k => f k) ((Finset.Ico m n).prod fun k => f k)) ((Finset.range n).prod fun k => f k)","decl":"@[to_additive]\ntheorem prod_range_mul_prod_Ico (f : ℕ → M) {m n : ℕ} (h : m ≤ n) :\n    ((∏ k ∈ range m, f k) * ∏ k ∈ Ico m n, f k) = ∏ k ∈ range n, f k :=\n  Nat.Ico_zero_eq_range ▸ Nat.Ico_zero_eq_range ▸ prod_Ico_consecutive f m.zero_le h\n\n"}
{"name":"Finset.sum_range_eq_add_Ico","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_2\ninst✝ : AddCommMonoid M\nf : Nat → M\nn : Nat\nhn : LT.lt 0 n\n⊢ Eq ((Finset.range n).sum fun x => f x) (HAdd.hAdd (f 0) ((Finset.Ico 1 n).sum fun x => f x))","decl":"@[to_additive]\ntheorem prod_range_eq_mul_Ico (f : ℕ → M) {n : ℕ} (hn : 0 < n) :\n    ∏ x ∈ Finset.range n, f x = f 0 * ∏ x ∈ Ico 1 n, f x :=\n  Finset.range_eq_Ico ▸ Finset.prod_eq_prod_Ico_succ_bot hn f\n\n"}
{"name":"Finset.prod_range_eq_mul_Ico","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_2\ninst✝ : CommMonoid M\nf : Nat → M\nn : Nat\nhn : LT.lt 0 n\n⊢ Eq ((Finset.range n).prod fun x => f x) (HMul.hMul (f 0) ((Finset.Ico 1 n).prod fun x => f x))","decl":"@[to_additive]\ntheorem prod_range_eq_mul_Ico (f : ℕ → M) {n : ℕ} (hn : 0 < n) :\n    ∏ x ∈ Finset.range n, f x = f 0 * ∏ x ∈ Ico 1 n, f x :=\n  Finset.range_eq_Ico ▸ Finset.prod_eq_prod_Ico_succ_bot hn f\n\n"}
{"name":"Finset.sum_Ico_eq_add_neg","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"δ : Type u_3\ninst✝ : AddCommGroup δ\nf : Nat → δ\nm n : Nat\nh : LE.le m n\n⊢ Eq ((Finset.Ico m n).sum fun k => f k) (HAdd.hAdd ((Finset.range n).sum fun k => f k) (Neg.neg ((Finset.range m).sum fun k => f k)))","decl":"@[to_additive]\ntheorem prod_Ico_eq_mul_inv {δ : Type*} [CommGroup δ] (f : ℕ → δ) {m n : ℕ} (h : m ≤ n) :\n    ∏ k ∈ Ico m n, f k = (∏ k ∈ range n, f k) * (∏ k ∈ range m, f k)⁻¹ :=\n  eq_mul_inv_iff_mul_eq.2 <| by (rw [mul_comm]; exact prod_range_mul_prod_Ico f h)\n\n"}
{"name":"Finset.prod_Ico_eq_mul_inv","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"δ : Type u_3\ninst✝ : CommGroup δ\nf : Nat → δ\nm n : Nat\nh : LE.le m n\n⊢ Eq ((Finset.Ico m n).prod fun k => f k) (HMul.hMul ((Finset.range n).prod fun k => f k) (Inv.inv ((Finset.range m).prod fun k => f k)))","decl":"@[to_additive]\ntheorem prod_Ico_eq_mul_inv {δ : Type*} [CommGroup δ] (f : ℕ → δ) {m n : ℕ} (h : m ≤ n) :\n    ∏ k ∈ Ico m n, f k = (∏ k ∈ range n, f k) * (∏ k ∈ range m, f k)⁻¹ :=\n  eq_mul_inv_iff_mul_eq.2 <| by (rw [mul_comm]; exact prod_range_mul_prod_Ico f h)\n\n"}
{"name":"Finset.prod_Ico_eq_div","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"δ : Type u_3\ninst✝ : CommGroup δ\nf : Nat → δ\nm n : Nat\nh : LE.le m n\n⊢ Eq ((Finset.Ico m n).prod fun k => f k) (HDiv.hDiv ((Finset.range n).prod fun k => f k) ((Finset.range m).prod fun k => f k))","decl":"@[to_additive]\ntheorem prod_Ico_eq_div {δ : Type*} [CommGroup δ] (f : ℕ → δ) {m n : ℕ} (h : m ≤ n) :\n    ∏ k ∈ Ico m n, f k = (∏ k ∈ range n, f k) / ∏ k ∈ range m, f k := by\n  simpa only [div_eq_mul_inv] using prod_Ico_eq_mul_inv f h\n\n"}
{"name":"Finset.sum_Ico_eq_sub","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"δ : Type u_3\ninst✝ : AddCommGroup δ\nf : Nat → δ\nm n : Nat\nh : LE.le m n\n⊢ Eq ((Finset.Ico m n).sum fun k => f k) (HSub.hSub ((Finset.range n).sum fun k => f k) ((Finset.range m).sum fun k => f k))","decl":"@[to_additive]\ntheorem prod_Ico_eq_div {δ : Type*} [CommGroup δ] (f : ℕ → δ) {m n : ℕ} (h : m ≤ n) :\n    ∏ k ∈ Ico m n, f k = (∏ k ∈ range n, f k) / ∏ k ∈ range m, f k := by\n  simpa only [div_eq_mul_inv] using prod_Ico_eq_mul_inv f h\n\n"}
{"name":"Finset.sum_range_sub_sum_range","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_3\ninst✝ : AddCommGroup α\nf : Nat → α\nn m : Nat\nhnm : LE.le n m\n⊢ Eq (HSub.hSub ((Finset.range m).sum fun k => f k) ((Finset.range n).sum fun k => f k)) ((Finset.filter (fun k => LE.le n k) (Finset.range m)).sum fun k => f k)","decl":"@[to_additive]\ntheorem prod_range_div_prod_range {α : Type*} [CommGroup α] {f : ℕ → α} {n m : ℕ} (hnm : n ≤ m) :\n    ((∏ k ∈ range m, f k) / ∏ k ∈ range n, f k) =\n    ∏ k ∈ (range m).filter fun k => n ≤ k, f k := by\n  rw [← prod_Ico_eq_div f hnm]\n  congr\n  apply Finset.ext\n  simp only [mem_Ico, mem_filter, mem_range, *]\n  tauto\n\n"}
{"name":"Finset.prod_range_div_prod_range","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"α : Type u_3\ninst✝ : CommGroup α\nf : Nat → α\nn m : Nat\nhnm : LE.le n m\n⊢ Eq (HDiv.hDiv ((Finset.range m).prod fun k => f k) ((Finset.range n).prod fun k => f k)) ((Finset.filter (fun k => LE.le n k) (Finset.range m)).prod fun k => f k)","decl":"@[to_additive]\ntheorem prod_range_div_prod_range {α : Type*} [CommGroup α] {f : ℕ → α} {n m : ℕ} (hnm : n ≤ m) :\n    ((∏ k ∈ range m, f k) / ∏ k ∈ range n, f k) =\n    ∏ k ∈ (range m).filter fun k => n ≤ k, f k := by\n  rw [← prod_Ico_eq_div f hnm]\n  congr\n  apply Finset.ext\n  simp only [mem_Ico, mem_filter, mem_range, *]\n  tauto\n\n"}
{"name":"Finset.sum_Ico_Ico_comm","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_3\ninst✝ : AddCommMonoid M\na b : Nat\nf : Nat → Nat → M\n⊢ Eq ((Finset.Ico a b).sum fun i => (Finset.Ico i b).sum fun j => f i j) ((Finset.Ico a b).sum fun j => (Finset.Ico a (HAdd.hAdd j 1)).sum fun i => f i j)","decl":"/-- The two ways of summing over `(i, j)` in the range `a ≤ i ≤ j < b` are equal. -/\ntheorem sum_Ico_Ico_comm {M : Type*} [AddCommMonoid M] (a b : ℕ) (f : ℕ → ℕ → M) :\n    (∑ i ∈ Finset.Ico a b, ∑ j ∈ Finset.Ico i b, f i j) =\n      ∑ j ∈ Finset.Ico a b, ∑ i ∈ Finset.Ico a (j + 1), f i j := by\n  rw [Finset.sum_sigma', Finset.sum_sigma']\n  refine sum_nbij' (fun x ↦ ⟨x.2, x.1⟩) (fun x ↦ ⟨x.2, x.1⟩) ?_ ?_ (fun _ _ ↦ rfl) (fun _ _ ↦ rfl)\n    (fun _ _ ↦ rfl) <;>\n  simp only [Finset.mem_Ico, Sigma.forall, Finset.mem_sigma] <;>\n  rintro a b ⟨⟨h₁, h₂⟩, ⟨h₃, h₄⟩⟩ <;>\n  omega\n\n"}
{"name":"Finset.sum_Ico_Ico_comm'","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_3\ninst✝ : AddCommMonoid M\na b : Nat\nf : Nat → Nat → M\n⊢ Eq ((Finset.Ico a b).sum fun i => (Finset.Ico (HAdd.hAdd i 1) b).sum fun j => f i j) ((Finset.Ico a b).sum fun j => (Finset.Ico a j).sum fun i => f i j)","decl":"/-- The two ways of summing over `(i, j)` in the range `a ≤ i < j < b` are equal. -/\ntheorem sum_Ico_Ico_comm' {M : Type*} [AddCommMonoid M] (a b : ℕ) (f : ℕ → ℕ → M) :\n    (∑ i ∈ Finset.Ico a b, ∑ j ∈ Finset.Ico (i + 1) b, f i j) =\n      ∑ j ∈ Finset.Ico a b, ∑ i ∈ Finset.Ico a j, f i j := by\n  rw [Finset.sum_sigma', Finset.sum_sigma']\n  refine sum_nbij' (fun x ↦ ⟨x.2, x.1⟩) (fun x ↦ ⟨x.2, x.1⟩) ?_ ?_ (fun _ _ ↦ rfl) (fun _ _ ↦ rfl)\n    (fun _ _ ↦ rfl) <;>\n  simp only [Finset.mem_Ico, Sigma.forall, Finset.mem_sigma] <;>\n  rintro a b ⟨⟨h₁, h₂⟩, ⟨h₃, h₄⟩⟩ <;>\n  omega\n\n"}
{"name":"Finset.prod_Ico_eq_prod_range","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_2\ninst✝ : CommMonoid M\nf : Nat → M\nm n : Nat\n⊢ Eq ((Finset.Ico m n).prod fun k => f k) ((Finset.range (HSub.hSub n m)).prod fun k => f (HAdd.hAdd m k))","decl":"@[to_additive]\ntheorem prod_Ico_eq_prod_range (f : ℕ → M) (m n : ℕ) :\n    ∏ k ∈ Ico m n, f k = ∏ k ∈ range (n - m), f (m + k) := by\n  by_cases h : m ≤ n\n  · rw [← Nat.Ico_zero_eq_range, prod_Ico_add, zero_add, tsub_add_cancel_of_le h]\n  · replace h : n ≤ m := le_of_not_ge h\n    rw [Ico_eq_empty_of_le h, tsub_eq_zero_iff_le.mpr h, range_zero, prod_empty, prod_empty]\n\n"}
{"name":"Finset.sum_Ico_eq_sum_range","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_2\ninst✝ : AddCommMonoid M\nf : Nat → M\nm n : Nat\n⊢ Eq ((Finset.Ico m n).sum fun k => f k) ((Finset.range (HSub.hSub n m)).sum fun k => f (HAdd.hAdd m k))","decl":"@[to_additive]\ntheorem prod_Ico_eq_prod_range (f : ℕ → M) (m n : ℕ) :\n    ∏ k ∈ Ico m n, f k = ∏ k ∈ range (n - m), f (m + k) := by\n  by_cases h : m ≤ n\n  · rw [← Nat.Ico_zero_eq_range, prod_Ico_add, zero_add, tsub_add_cancel_of_le h]\n  · replace h : n ≤ m := le_of_not_ge h\n    rw [Ico_eq_empty_of_le h, tsub_eq_zero_iff_le.mpr h, range_zero, prod_empty, prod_empty]\n\n"}
{"name":"Finset.prod_Ico_reflect","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_2\ninst✝ : CommMonoid M\nf : Nat → M\nk m n : Nat\nh : LE.le m (HAdd.hAdd n 1)\n⊢ Eq ((Finset.Ico k m).prod fun j => f (HSub.hSub n j)) ((Finset.Ico (HSub.hSub (HAdd.hAdd n 1) m) (HSub.hSub (HAdd.hAdd n 1) k)).prod fun j => f j)","decl":"theorem prod_Ico_reflect (f : ℕ → M) (k : ℕ) {m n : ℕ} (h : m ≤ n + 1) :\n    (∏ j ∈ Ico k m, f (n - j)) = ∏ j ∈ Ico (n + 1 - m) (n + 1 - k), f j := by\n  have : ∀ i < m, i ≤ n := by\n    intro i hi\n    exact (add_le_add_iff_right 1).1 (le_trans (Nat.lt_iff_add_one_le.1 hi) h)\n  rcases lt_or_le k m with hkm | hkm\n  · rw [← Nat.Ico_image_const_sub_eq_Ico (this _ hkm)]\n    refine (prod_image ?_).symm\n    simp only [mem_Ico]\n    rintro i ⟨_, im⟩ j ⟨_, jm⟩ Hij\n    rw [← tsub_tsub_cancel_of_le (this _ im), Hij, tsub_tsub_cancel_of_le (this _ jm)]\n  · have : n + 1 - k ≤ n + 1 - m := by\n      rw [tsub_le_tsub_iff_left h]\n      exact hkm\n    simp only [hkm, Ico_eq_empty_of_le, prod_empty, tsub_le_iff_right, Ico_eq_empty_of_le\n      this]\n\n"}
{"name":"Finset.sum_Ico_reflect","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"δ : Type u_3\ninst✝ : AddCommMonoid δ\nf : Nat → δ\nk m n : Nat\nh : LE.le m (HAdd.hAdd n 1)\n⊢ Eq ((Finset.Ico k m).sum fun j => f (HSub.hSub n j)) ((Finset.Ico (HSub.hSub (HAdd.hAdd n 1) m) (HSub.hSub (HAdd.hAdd n 1) k)).sum fun j => f j)","decl":"theorem sum_Ico_reflect {δ : Type*} [AddCommMonoid δ] (f : ℕ → δ) (k : ℕ) {m n : ℕ}\n    (h : m ≤ n + 1) : (∑ j ∈ Ico k m, f (n - j)) = ∑ j ∈ Ico (n + 1 - m) (n + 1 - k), f j :=\n  @prod_Ico_reflect (Multiplicative δ) _ f k m n h\n\n"}
{"name":"Finset.prod_range_reflect","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_2\ninst✝ : CommMonoid M\nf : Nat → M\nn : Nat\n⊢ Eq ((Finset.range n).prod fun j => f (HSub.hSub (HSub.hSub n 1) j)) ((Finset.range n).prod fun j => f j)","decl":"theorem prod_range_reflect (f : ℕ → M) (n : ℕ) :\n    (∏ j ∈ range n, f (n - 1 - j)) = ∏ j ∈ range n, f j := by\n  cases n\n  · simp\n  · simp only [← Nat.Ico_zero_eq_range, Nat.succ_sub_succ_eq_sub, tsub_zero]\n    rw [prod_Ico_reflect _ _ le_rfl]\n    simp\n\n"}
{"name":"Finset.sum_range_reflect","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"δ : Type u_3\ninst✝ : AddCommMonoid δ\nf : Nat → δ\nn : Nat\n⊢ Eq ((Finset.range n).sum fun j => f (HSub.hSub (HSub.hSub n 1) j)) ((Finset.range n).sum fun j => f j)","decl":"theorem sum_range_reflect {δ : Type*} [AddCommMonoid δ] (f : ℕ → δ) (n : ℕ) :\n    (∑ j ∈ range n, f (n - 1 - j)) = ∑ j ∈ range n, f j :=\n  @prod_range_reflect (Multiplicative δ) _ f n\n\n"}
{"name":"Finset.prod_Ico_id_eq_factorial","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"n : Nat\n⊢ Eq ((Finset.Ico 1 (HAdd.hAdd n 1)).prod fun x => x) n.factorial","decl":"@[simp]\ntheorem prod_Ico_id_eq_factorial : ∀ n : ℕ, (∏ x ∈ Ico 1 (n + 1), x) = n !\n  | 0 => rfl\n  | n + 1 => by\n    rw [prod_Ico_succ_top <| Nat.succ_le_succ <| Nat.zero_le n, Nat.factorial_succ,\n      prod_Ico_id_eq_factorial n, Nat.succ_eq_add_one, mul_comm]\n\n"}
{"name":"Finset.prod_range_add_one_eq_factorial","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"n : Nat\n⊢ Eq ((Finset.range n).prod fun x => HAdd.hAdd x 1) n.factorial","decl":"@[simp]\ntheorem prod_range_add_one_eq_factorial : ∀ n : ℕ, (∏ x ∈ range n, (x + 1)) = n !\n  | 0 => rfl\n  | n + 1 => by simp [factorial, Finset.range_succ, prod_range_add_one_eq_factorial n]\n\n"}
{"name":"Finset.sum_range_id_mul_two","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"n : Nat\n⊢ Eq (HMul.hMul ((Finset.range n).sum fun i => i) 2) (HMul.hMul n (HSub.hSub n 1))","decl":"/-- Gauss' summation formula -/\ntheorem sum_range_id_mul_two (n : ℕ) : (∑ i ∈ range n, i) * 2 = n * (n - 1) :=\n  calc\n    (∑ i ∈ range n, i) * 2 = (∑ i ∈ range n, i) + ∑ i ∈ range n, (n - 1 - i) := by\n      rw [sum_range_reflect (fun i => i) n, mul_two]\n    _ = ∑ i ∈ range n, (i + (n - 1 - i)) := sum_add_distrib.symm\n    _ = ∑ _ ∈ range n, (n - 1) :=\n      sum_congr rfl fun _ hi => add_tsub_cancel_of_le <| Nat.le_sub_one_of_lt <| mem_range.1 hi\n    _ = n * (n - 1) := by rw [sum_const, card_range, Nat.nsmul_eq_mul]\n\n"}
{"name":"Finset.sum_range_id","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"n : Nat\n⊢ Eq ((Finset.range n).sum fun i => i) (HDiv.hDiv (HMul.hMul n (HSub.hSub n 1)) 2)","decl":"/-- Gauss' summation formula -/\ntheorem sum_range_id (n : ℕ) : ∑ i ∈ range n, i = n * (n - 1) / 2 := by\n  rw [← sum_range_id_mul_two n, Nat.mul_div_cancel _ zero_lt_two]\n\n"}
{"name":"Finset.prod_range_diag_flip","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_2\ninst✝ : CommMonoid M\nn : Nat\nf : Nat → Nat → M\n⊢ Eq ((Finset.range n).prod fun m => (Finset.range (HAdd.hAdd m 1)).prod fun k => f k (HSub.hSub m k)) ((Finset.range n).prod fun m => (Finset.range (HSub.hSub n m)).prod fun k => f m k)","decl":"@[to_additive]\nlemma prod_range_diag_flip (n : ℕ) (f : ℕ → ℕ → M) :\n    (∏ m ∈ range n, ∏ k ∈ range (m + 1), f k (m - k)) =\n      ∏ m ∈ range n, ∏ k ∈ range (n - m), f m k := by\n  rw [prod_sigma', prod_sigma']\n  refine prod_nbij' (fun a ↦ ⟨a.2, a.1 - a.2⟩) (fun a ↦ ⟨a.1 + a.2, a.1⟩) ?_ ?_ ?_ ?_ ?_ <;>\n    simp +contextual only [mem_sigma, mem_range, lt_tsub_iff_left,\n      Nat.lt_succ_iff, le_add_iff_nonneg_right, Nat.zero_le, and_true, and_imp, imp_self,\n      implies_true, Sigma.forall, forall_const, add_tsub_cancel_of_le, Sigma.mk.inj_iff,\n      add_tsub_cancel_left, heq_eq_eq]\n  exact fun a b han hba ↦ lt_of_le_of_lt hba han\n\n"}
{"name":"Finset.sum_range_diag_flip","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_2\ninst✝ : AddCommMonoid M\nn : Nat\nf : Nat → Nat → M\n⊢ Eq ((Finset.range n).sum fun m => (Finset.range (HAdd.hAdd m 1)).sum fun k => f k (HSub.hSub m k)) ((Finset.range n).sum fun m => (Finset.range (HSub.hSub n m)).sum fun k => f m k)","decl":"@[to_additive]\nlemma prod_range_diag_flip (n : ℕ) (f : ℕ → ℕ → M) :\n    (∏ m ∈ range n, ∏ k ∈ range (m + 1), f k (m - k)) =\n      ∏ m ∈ range n, ∏ k ∈ range (n - m), f m k := by\n  rw [prod_sigma', prod_sigma']\n  refine prod_nbij' (fun a ↦ ⟨a.2, a.1 - a.2⟩) (fun a ↦ ⟨a.1 + a.2, a.1⟩) ?_ ?_ ?_ ?_ ?_ <;>\n    simp +contextual only [mem_sigma, mem_range, lt_tsub_iff_left,\n      Nat.lt_succ_iff, le_add_iff_nonneg_right, Nat.zero_le, and_true, and_imp, imp_self,\n      implies_true, Sigma.forall, forall_const, add_tsub_cancel_of_le, Sigma.mk.inj_iff,\n      add_tsub_cancel_left, heq_eq_eq]\n  exact fun a b han hba ↦ lt_of_le_of_lt hba han\n\n"}
{"name":"Finset.prod_range_succ_div_prod","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_3\nf : Nat → M\nn : Nat\ninst✝ : CommGroup M\n⊢ Eq (HDiv.hDiv ((Finset.range (HAdd.hAdd n 1)).prod fun i => f i) ((Finset.range n).prod fun i => f i)) (f n)","decl":"@[to_additive]\ntheorem prod_range_succ_div_prod : ((∏ i ∈ range (n + 1), f i) / ∏ i ∈ range n, f i) = f n :=\n  div_eq_iff_eq_mul'.mpr <| prod_range_succ f n\n\n"}
{"name":"Finset.sum_range_succ_sub_sum","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_3\nf : Nat → M\nn : Nat\ninst✝ : AddCommGroup M\n⊢ Eq (HSub.hSub ((Finset.range (HAdd.hAdd n 1)).sum fun i => f i) ((Finset.range n).sum fun i => f i)) (f n)","decl":"@[to_additive]\ntheorem prod_range_succ_div_prod : ((∏ i ∈ range (n + 1), f i) / ∏ i ∈ range n, f i) = f n :=\n  div_eq_iff_eq_mul'.mpr <| prod_range_succ f n\n\n"}
{"name":"Finset.prod_range_succ_div_top","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_3\nf : Nat → M\nn : Nat\ninst✝ : CommGroup M\n⊢ Eq (HDiv.hDiv ((Finset.range (HAdd.hAdd n 1)).prod fun i => f i) (f n)) ((Finset.range n).prod fun i => f i)","decl":"@[to_additive]\ntheorem prod_range_succ_div_top : (∏ i ∈ range (n + 1), f i) / f n = ∏ i ∈ range n, f i :=\n  div_eq_iff_eq_mul.mpr <| prod_range_succ f n\n\n"}
{"name":"Finset.sum_range_succ_sub_top","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_3\nf : Nat → M\nn : Nat\ninst✝ : AddCommGroup M\n⊢ Eq (HSub.hSub ((Finset.range (HAdd.hAdd n 1)).sum fun i => f i) (f n)) ((Finset.range n).sum fun i => f i)","decl":"@[to_additive]\ntheorem prod_range_succ_div_top : (∏ i ∈ range (n + 1), f i) / f n = ∏ i ∈ range n, f i :=\n  div_eq_iff_eq_mul.mpr <| prod_range_succ f n\n\n"}
{"name":"Finset.prod_Ico_div_bot","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_3\nf : Nat → M\nm n : Nat\ninst✝ : CommGroup M\nhmn : LT.lt m n\n⊢ Eq (HDiv.hDiv ((Finset.Ico m n).prod fun i => f i) (f m)) ((Finset.Ico (HAdd.hAdd m 1) n).prod fun i => f i)","decl":"@[to_additive]\ntheorem prod_Ico_div_bot (hmn : m < n) : (∏ i ∈ Ico m n, f i) / f m = ∏ i ∈ Ico (m + 1) n, f i :=\n  div_eq_iff_eq_mul'.mpr <| prod_eq_prod_Ico_succ_bot hmn _\n\n"}
{"name":"Finset.sum_Ico_sub_bot","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_3\nf : Nat → M\nm n : Nat\ninst✝ : AddCommGroup M\nhmn : LT.lt m n\n⊢ Eq (HSub.hSub ((Finset.Ico m n).sum fun i => f i) (f m)) ((Finset.Ico (HAdd.hAdd m 1) n).sum fun i => f i)","decl":"@[to_additive]\ntheorem prod_Ico_div_bot (hmn : m < n) : (∏ i ∈ Ico m n, f i) / f m = ∏ i ∈ Ico (m + 1) n, f i :=\n  div_eq_iff_eq_mul'.mpr <| prod_eq_prod_Ico_succ_bot hmn _\n\n"}
{"name":"Finset.sum_Ico_succ_sub_top","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_3\nf : Nat → M\nm n : Nat\ninst✝ : AddCommGroup M\nhmn : LE.le m n\n⊢ Eq (HSub.hSub ((Finset.Ico m (HAdd.hAdd n 1)).sum fun i => f i) (f n)) ((Finset.Ico m n).sum fun i => f i)","decl":"@[to_additive]\ntheorem prod_Ico_succ_div_top (hmn : m ≤ n) :\n    (∏ i ∈ Ico m (n + 1), f i) / f n = ∏ i ∈ Ico m n, f i :=\n  div_eq_iff_eq_mul.mpr <| prod_Ico_succ_top hmn _\n\n"}
{"name":"Finset.prod_Ico_succ_div_top","module":"Mathlib.Algebra.BigOperators.Intervals","initialProofState":"M : Type u_3\nf : Nat → M\nm n : Nat\ninst✝ : CommGroup M\nhmn : LE.le m n\n⊢ Eq (HDiv.hDiv ((Finset.Ico m (HAdd.hAdd n 1)).prod fun i => f i) (f n)) ((Finset.Ico m n).prod fun i => f i)","decl":"@[to_additive]\ntheorem prod_Ico_succ_div_top (hmn : m ≤ n) :\n    (∏ i ∈ Ico m (n + 1), f i) / f n = ∏ i ∈ Ico m n, f i :=\n  div_eq_iff_eq_mul.mpr <| prod_Ico_succ_top hmn _\n\n"}
