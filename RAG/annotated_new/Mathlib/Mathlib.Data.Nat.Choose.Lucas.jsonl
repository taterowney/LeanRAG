{"name":"Choose.choose_modEq_choose_mod_mul_choose_div","module":"Mathlib.Data.Nat.Choose.Lucas","initialProofState":"n k p : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ (↑p).ModEq (↑(n.choose k)) (HMul.hMul ↑((HMod.hMod n p).choose (HMod.hMod k p)) ↑((HDiv.hDiv n p).choose (HDiv.hDiv k p)))","decl":"/-- For primes `p`, `choose n k` is congruent to `choose (n % p) (k % p) * choose (n / p) (k / p)`\nmodulo `p`. Also see `choose_modEq_choose_mod_mul_choose_div_nat` for the version with `MOD`. -/\ntheorem choose_modEq_choose_mod_mul_choose_div :\n    choose n k ≡ choose (n % p) (k % p) * choose (n / p) (k / p) [ZMOD p] := by\n  have decompose : ((X : (ZMod p)[X]) + 1) ^ n = (X + 1) ^ (n % p) * (X ^ p + 1) ^ (n / p) := by\n    simpa using add_pow_eq_mul_pow_add_pow_div_char (X : (ZMod p)[X]) 1 p _\n  simp only [← ZMod.intCast_eq_intCast_iff, Int.cast_mul, Int.cast_ofNat,\n    ← coeff_X_add_one_pow _ n k, ← eq_intCast (Int.castRingHom (ZMod p)), ← coeff_map,\n    Polynomial.map_pow, Polynomial.map_add, Polynomial.map_one, map_X, decompose]\n  simp only [add_pow, one_pow, mul_one, ← pow_mul, sum_mul_sum]\n  conv_lhs =>\n    enter [1, 2, k, 2, k']\n    rw [← mul_assoc, mul_right_comm _ _ (X ^ (p * k')), ← pow_add, mul_assoc, ← cast_mul]\n  have h_iff : ∀ x ∈ range (n % p + 1) ×ˢ range (n / p + 1),\n      k = x.1 + p * x.2 ↔ (k % p, k / p) = x := by\n    intro ⟨x₁, x₂⟩ hx\n    rw [Prod.mk.injEq]\n    constructor <;> intro h\n    · simp only [mem_product, mem_range] at hx\n      have h' : x₁ < p := lt_of_lt_of_le hx.left <| mod_lt _ Fin.pos'\n      rw [h, add_mul_mod_self_left, add_mul_div_left _ _ Fin.pos', eq_comm (b := x₂)]\n      exact ⟨mod_eq_of_lt h', self_eq_add_left.mpr (div_eq_of_lt h')⟩\n    · rw [← h.left, ← h.right, mod_add_div]\n  simp only [finset_sum_coeff, coeff_mul_natCast, coeff_X_pow, ite_mul, zero_mul, ← cast_mul]\n  rw [← sum_product', sum_congr rfl (fun a ha ↦ if_congr (h_iff a ha) rfl rfl), sum_ite_eq]\n  split_ifs with h\n  · simp\n  · rw [mem_product, mem_range, mem_range, not_and_or, lt_succ, not_le, not_lt] at h\n    cases h <;> simp [choose_eq_zero_of_lt (by tauto)]\n\n"}
{"name":"Choose.choose_modEq_choose_mod_mul_choose_div_nat","module":"Mathlib.Data.Nat.Choose.Lucas","initialProofState":"n k p : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ p.ModEq (n.choose k) (HMul.hMul ((HMod.hMod n p).choose (HMod.hMod k p)) ((HDiv.hDiv n p).choose (HDiv.hDiv k p)))","decl":"/-- For primes `p`, `choose n k` is congruent to `choose (n % p) (k % p) * choose (n / p) (k / p)`\nmodulo `p`. Also see `choose_modEq_choose_mod_mul_choose_div` for the version with `ZMOD`. -/\ntheorem choose_modEq_choose_mod_mul_choose_div_nat :\n    choose n k ≡ choose (n % p) (k % p) * choose (n / p) (k / p) [MOD p] := by\n  rw [← Int.natCast_modEq_iff]\n  exact_mod_cast choose_modEq_choose_mod_mul_choose_div\n\n"}
{"name":"Choose.choose_modEq_choose_mul_prod_range_choose","module":"Mathlib.Data.Nat.Choose.Lucas","initialProofState":"n k p : Nat\ninst✝ : Fact (Nat.Prime p)\na : Nat\n⊢ (↑p).ModEq (↑(n.choose k)) (HMul.hMul ↑((HDiv.hDiv n (HPow.hPow p a)).choose (HDiv.hDiv k (HPow.hPow p a))) ↑((Finset.range a).prod fun i => (HMod.hMod (HDiv.hDiv n (HPow.hPow p i)) p).choose (HMod.hMod (HDiv.hDiv k (HPow.hPow p i)) p)))","decl":"/-- For primes `p`, `choose n k` is congruent to the product of `choose (⌊n / p ^ i⌋ % p)\n(⌊k / p ^ i⌋ % p)` over i < a, multiplied by `choose (⌊n / p ^ a⌋) (⌊k / p ^ a⌋)`, modulo `p`. -/\ntheorem choose_modEq_choose_mul_prod_range_choose (a : ℕ) :\n    choose n k ≡ choose (n / p ^ a) (k / p ^ a) *\n      ∏ i ∈ range a, choose (n / p ^ i % p) (k / p ^ i % p) [ZMOD p] :=\n  match a with\n  | Nat.zero => by simp\n  | Nat.succ a => (choose_modEq_choose_mul_prod_range_choose a).trans <| by\n    rw [prod_range_succ, cast_mul, ← mul_assoc, mul_right_comm]\n    gcongr\n    apply choose_modEq_choose_mod_mul_choose_div.trans\n    simp_rw [pow_succ, Nat.div_div_eq_div_mul, mul_comm, Int.ModEq.refl]\n\n"}
{"name":"Choose.choose_modEq_prod_range_choose","module":"Mathlib.Data.Nat.Choose.Lucas","initialProofState":"n k p : Nat\ninst✝ : Fact (Nat.Prime p)\na : Nat\nha₁ : LT.lt n (HPow.hPow p a)\nha₂ : LT.lt k (HPow.hPow p a)\n⊢ (↑p).ModEq (↑(n.choose k)) ((Finset.range a).prod fun i => ↑((HMod.hMod (HDiv.hDiv n (HPow.hPow p i)) p).choose (HMod.hMod (HDiv.hDiv k (HPow.hPow p i)) p)))","decl":"/-- **Lucas's Theorem**: For primes `p`, `choose n k` is congruent to the product of\n`choose (⌊n / p ^ i⌋ % p) (⌊k / p ^ i⌋ % p)` over `i` modulo `p`. -/\ntheorem choose_modEq_prod_range_choose {a : ℕ} (ha₁ : n < p ^ a) (ha₂ : k < p ^ a) :\n    choose n k ≡ ∏ i ∈ range a, choose (n / p ^ i % p) (k / p ^ i % p) [ZMOD p] := by\n  apply (choose_modEq_choose_mul_prod_range_choose a).trans\n  simp_rw [Nat.div_eq_of_lt ha₁, Nat.div_eq_of_lt ha₂, choose, cast_one, one_mul, cast_prod,\n    Int.ModEq.refl]\n\n"}
{"name":"Choose.choose_modEq_prod_range_choose_nat","module":"Mathlib.Data.Nat.Choose.Lucas","initialProofState":"n k p : Nat\ninst✝ : Fact (Nat.Prime p)\na : Nat\nha₁ : LT.lt n (HPow.hPow p a)\nha₂ : LT.lt k (HPow.hPow p a)\n⊢ p.ModEq (n.choose k) ((Finset.range a).prod fun i => (HMod.hMod (HDiv.hDiv n (HPow.hPow p i)) p).choose (HMod.hMod (HDiv.hDiv k (HPow.hPow p i)) p))","decl":"/-- **Lucas's Theorem**: For primes `p`, `choose n k` is congruent to the product of\n`choose (⌊n / p ^ i⌋ % p) (⌊k / p ^ i⌋ % p)` over `i` modulo `p`. -/\ntheorem choose_modEq_prod_range_choose_nat {a : ℕ} (ha₁ : n < p ^ a) (ha₂ : k < p ^ a) :\n    choose n k ≡ ∏ i ∈ range a, choose (n / p ^ i % p) (k / p ^ i % p) [MOD p] := by\n  rw [← Int.natCast_modEq_iff]\n  exact_mod_cast choose_modEq_prod_range_choose ha₁ ha₂\n\n"}
{"name":"Choose.lucas_theorem","module":"Mathlib.Data.Nat.Choose.Lucas","initialProofState":"n k p : Nat\ninst✝ : Fact (Nat.Prime p)\na : Nat\nha₁ : LT.lt n (HPow.hPow p a)\nha₂ : LT.lt k (HPow.hPow p a)\n⊢ (↑p).ModEq (↑(n.choose k)) ((Finset.range a).prod fun i => ↑((HMod.hMod (HDiv.hDiv n (HPow.hPow p i)) p).choose (HMod.hMod (HDiv.hDiv k (HPow.hPow p i)) p)))","decl":"alias lucas_theorem := choose_modEq_prod_range_choose\n"}
{"name":"Choose.lucas_theorem_nat","module":"Mathlib.Data.Nat.Choose.Lucas","initialProofState":"n k p : Nat\ninst✝ : Fact (Nat.Prime p)\na : Nat\nha₁ : LT.lt n (HPow.hPow p a)\nha₂ : LT.lt k (HPow.hPow p a)\n⊢ p.ModEq (n.choose k) ((Finset.range a).prod fun i => (HMod.hMod (HDiv.hDiv n (HPow.hPow p i)) p).choose (HMod.hMod (HDiv.hDiv k (HPow.hPow p i)) p))","decl":"alias lucas_theorem_nat := choose_modEq_prod_range_choose_nat\n\n"}
