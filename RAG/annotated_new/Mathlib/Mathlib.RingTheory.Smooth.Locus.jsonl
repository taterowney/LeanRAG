{"name":"Algebra.smoothLocus_eq_compl_support_inter","module":"Mathlib.RingTheory.Smooth.Locus","initialProofState":"R A : Type u\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : Algebra.EssFiniteType R A\n⊢ Eq (Algebra.smoothLocus R A) (Inter.inter (HasCompl.compl (Module.support A (Algebra.H1Cotangent R A))) (Module.freeLocus A (KaehlerDifferential R A)))","decl":"attribute [local instance] Module.finitePresentation_of_projective in\nlemma smoothLocus_eq_compl_support_inter [EssFiniteType R A] :\n    smoothLocus R A = (Module.support A (H1Cotangent R A))ᶜ ∩ Module.freeLocus A (Ω[A⁄R]) := by\n  ext p\n  simp only [Set.mem_inter_iff, Set.mem_compl_iff, Module.not_mem_support_iff,\n    Module.mem_freeLocus]\n  refine Algebra.FormallySmooth.iff_subsingleton_and_projective.trans ?_\n  congr! 1\n  · have := IsLocalizedModule.iso p.asIdeal.primeCompl\n      (H1Cotangent.map R R A (Localization.AtPrime p.asIdeal))\n    exact this.subsingleton_congr.symm\n  · trans Module.Free (Localization.AtPrime p.asIdeal) (Ω[Localization.AtPrime p.asIdeal⁄R])\n    · have : EssFiniteType A (Localization.AtPrime p.asIdeal) :=\n        .of_isLocalization _ p.asIdeal.primeCompl\n      have : EssFiniteType R (Localization.AtPrime p.asIdeal) := .comp _ A _\n      exact ⟨fun _ ↦ Module.free_of_flat_of_isLocalRing, fun _ ↦ inferInstance⟩\n    · have := IsLocalizedModule.iso p.asIdeal.primeCompl\n        (KaehlerDifferential.map R R A (Localization.AtPrime p.asIdeal))\n      have := LinearEquiv.ofBijective (this.extendScalarsOfIsLocalization\n        p.asIdeal.primeCompl (Localization.AtPrime p.asIdeal)) this.bijective\n      exact ⟨fun H ↦ H.of_equiv' this.symm, fun H ↦ H.of_equiv' this⟩\n\n"}
{"name":"Algebra.basicOpen_subset_smoothLocus_iff","module":"Mathlib.RingTheory.Smooth.Locus","initialProofState":"R A : Type u\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : Algebra.FinitePresentation R A\nf : A\n⊢ Iff (HasSubset.Subset (↑(PrimeSpectrum.basicOpen f)) (Algebra.smoothLocus R A)) (Algebra.FormallySmooth R (Localization.Away f))","decl":"lemma basicOpen_subset_smoothLocus_iff [FinitePresentation R A] {f : A} :\n    ↑(PrimeSpectrum.basicOpen f) ⊆ smoothLocus R A ↔\n      Algebra.FormallySmooth R (Localization.Away f) := by\n  rw [smoothLocus_eq_compl_support_inter, Set.subset_inter_iff, Set.subset_compl_comm,\n    PrimeSpectrum.basicOpen_eq_zeroLocus_compl, compl_compl,\n    ← LocalizedModule.subsingleton_iff_support_subset,\n    Algebra.FormallySmooth.iff_subsingleton_and_projective]\n  congr! 1\n  · have := IsLocalizedModule.iso (.powers f) (H1Cotangent.map R R A (Localization.Away f))\n    rw [this.subsingleton_congr]\n  · rw [← PrimeSpectrum.basicOpen_eq_zeroLocus_compl, Module.basicOpen_subset_freeLocus_iff]\n    have := IsLocalizedModule.iso (.powers f)\n        (KaehlerDifferential.map R R A (Localization.Away f))\n    have := LinearEquiv.ofBijective (this.extendScalarsOfIsLocalization\n      (.powers f) (Localization.Away f)) this.bijective\n    exact ⟨fun _ ↦ .of_equiv this, fun _ ↦ .of_equiv this.symm⟩\n\n"}
{"name":"Algebra.basicOpen_subset_smoothLocus_iff_smooth","module":"Mathlib.RingTheory.Smooth.Locus","initialProofState":"R A : Type u\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : Algebra.FinitePresentation R A\nf : A\n⊢ Iff (HasSubset.Subset (↑(PrimeSpectrum.basicOpen f)) (Algebra.smoothLocus R A)) (Algebra.Smooth R (Localization.Away f))","decl":"lemma basicOpen_subset_smoothLocus_iff_smooth [FinitePresentation R A] {f : A} :\n    ↑(PrimeSpectrum.basicOpen f) ⊆ smoothLocus R A ↔\n      Algebra.Smooth R (Localization.Away f) := by\n  have : FinitePresentation A (Localization.Away f) := IsLocalization.Away.finitePresentation f\n  rw [basicOpen_subset_smoothLocus_iff]\n  exact ⟨fun H ↦ ⟨H, .trans _ A _⟩, fun H ↦ H.1⟩\n\n"}
{"name":"Algebra.smoothLocus_eq_univ_iff","module":"Mathlib.RingTheory.Smooth.Locus","initialProofState":"R A : Type u\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : Algebra.FinitePresentation R A\n⊢ Iff (Eq (Algebra.smoothLocus R A) Set.univ) (Algebra.FormallySmooth R A)","decl":"lemma smoothLocus_eq_univ_iff [FinitePresentation R A] :\n    smoothLocus R A = Set.univ ↔ Algebra.FormallySmooth R A := by\n  have := IsLocalization.atUnits A (.powers 1) (S := Localization.Away (1 : A)) (by simp)\n  rw [Algebra.FormallySmooth.iff_of_equiv (this.restrictScalars R),\n    ← basicOpen_subset_smoothLocus_iff]\n  simp\n\n"}
{"name":"Algebra.smoothLocus_comap_of_isLocalization","module":"Mathlib.RingTheory.Smooth.Locus","initialProofState":"R A : Type u\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing A\ninst✝⁵ : Algebra R A\nAf : Type u\ninst✝⁴ : CommRing Af\ninst✝³ : Algebra A Af\ninst✝² : Algebra R Af\ninst✝¹ : IsScalarTower R A Af\nf : A\ninst✝ : IsLocalization.Away f Af\n⊢ Eq (Set.preimage (⇑(PrimeSpectrum.comap (algebraMap A Af))) (Algebra.smoothLocus R A)) (Algebra.smoothLocus R Af)","decl":"lemma smoothLocus_comap_of_isLocalization {Af : Type u} [CommRing Af] [Algebra A Af] [Algebra R Af]\n    [IsScalarTower R A Af] (f : A) [IsLocalization.Away f Af] :\n    PrimeSpectrum.comap (algebraMap A Af) ⁻¹' smoothLocus R A = smoothLocus R Af := by\n  ext p\n  let q := PrimeSpectrum.comap (algebraMap A Af) p\n  have : IsLocalization.AtPrime (Localization.AtPrime p.asIdeal) q.asIdeal :=\n    IsLocalization.isLocalization_isLocalization_atPrime_isLocalization (.powers f) _ p.asIdeal\n  refine Algebra.FormallySmooth.iff_of_equiv ?_\n  exact (IsLocalization.algEquiv q.asIdeal.primeCompl _ _).restrictScalars R\n\n-- Note that this does not follow directly from `smoothLocus_eq_compl_support_inter` because\n-- `H¹(L_{S/R})` is not necessarily finitely generated.\n"}
{"name":"Algebra.isOpen_smoothLocus","module":"Mathlib.RingTheory.Smooth.Locus","initialProofState":"R A : Type u\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : Algebra.FinitePresentation R A\n⊢ IsOpen (Algebra.smoothLocus R A)","decl":"open PrimeSpectrum in\nlemma isOpen_smoothLocus [FinitePresentation R A] : IsOpen (smoothLocus R A) := by\n  rw [isOpen_iff_forall_mem_open]\n  intro x hx\n  obtain ⟨_, ⟨_, ⟨f, rfl⟩, rfl⟩, hxf, hf⟩ :=\n    isBasis_basic_opens.exists_subset_of_mem_open\n    (smoothLocus_eq_compl_support_inter.le hx).2 Module.isOpen_freeLocus\n  rw [Module.basicOpen_subset_freeLocus_iff] at hf\n  let Af := Localization.Away f\n  have : Algebra.FinitePresentation A (Localization.Away f) :=\n    IsLocalization.Away.finitePresentation f\n  have : Algebra.FinitePresentation R (Localization.Away f) :=\n    .trans _ A _\n  have : IsOpen (smoothLocus R Af) := by\n    have := IsLocalizedModule.iso (.powers f)\n      (KaehlerDifferential.map R R A (Localization.Away f))\n    have := LinearEquiv.ofBijective (this.extendScalarsOfIsLocalization\n      (.powers f) (Localization.Away f)) this.bijective\n    have := Module.Projective.of_equiv this\n    rw [smoothLocus_eq_compl_support_inter, Module.support_eq_zeroLocus]\n    exact (isClosed_zeroLocus _).isOpen_compl.inter Module.isOpen_freeLocus\n  rw [← smoothLocus_comap_of_isLocalization f] at this\n  replace this := (PrimeSpectrum.localization_away_isOpenEmbedding Af f).isOpenMap _ this\n  rw [Set.image_preimage_eq_inter_range, localization_away_comap_range Af f] at this\n  exact ⟨_, Set.inter_subset_left, this, hx, hxf⟩\n\n"}
