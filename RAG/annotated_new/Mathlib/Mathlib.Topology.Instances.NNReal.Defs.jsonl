{"name":"NNReal.instTopologicalSemiring","module":"Mathlib.Topology.Instances.NNReal.Defs","initialProofState":"⊢ TopologicalSemiring NNReal","decl":"instance : TopologicalSemiring ℝ≥0 where\n  toContinuousAdd := continuousAdd_induced toRealHom\n  toContinuousMul := continuousMul_induced toRealHom\n\n"}
{"name":"NNReal.instSecondCountableTopology","module":"Mathlib.Topology.Instances.NNReal.Defs","initialProofState":"⊢ SecondCountableTopology NNReal","decl":"instance : SecondCountableTopology ℝ≥0 :=\n  inferInstanceAs (SecondCountableTopology { x : ℝ | 0 ≤ x })\n\n"}
{"name":"NNReal.instOrderTopology","module":"Mathlib.Topology.Instances.NNReal.Defs","initialProofState":"⊢ OrderTopology NNReal","decl":"instance : OrderTopology ℝ≥0 :=\n  orderTopology_of_ordConnected (t := Ici 0)\n\n"}
{"name":"NNReal.instCompleteSpace","module":"Mathlib.Topology.Instances.NNReal.Defs","initialProofState":"⊢ CompleteSpace NNReal","decl":"instance : CompleteSpace ℝ≥0 :=\n  isClosed_Ici.completeSpace_coe\n\n"}
{"name":"NNReal.instContinuousStar","module":"Mathlib.Topology.Instances.NNReal.Defs","initialProofState":"⊢ ContinuousStar NNReal","decl":"instance : ContinuousStar ℝ≥0 where\n  continuous_star := continuous_id\n\n-- TODO: generalize this to a broader class of subtypes\n"}
{"name":"NNReal.instIsOrderBornology","module":"Mathlib.Topology.Instances.NNReal.Defs","initialProofState":"⊢ IsOrderBornology NNReal","decl":"instance : IsOrderBornology ℝ≥0 where\n  isBounded_iff_bddBelow_bddAbove s := by\n    refine ⟨fun bdd ↦ ?_, fun h ↦ isBounded_of_bddAbove_of_bddBelow h.2 h.1⟩\n    obtain ⟨r, hr⟩ : ∃ r : ℝ≥0, s ⊆ Icc 0 r := by\n      obtain ⟨rreal, hrreal⟩ := bdd.subset_closedBall 0\n      use rreal.toNNReal\n      simp only [← NNReal.closedBall_zero_eq_Icc', Real.coe_toNNReal']\n      exact subset_trans hrreal (Metric.closedBall_subset_closedBall (le_max_left rreal 0))\n    exact ⟨bddBelow_Icc.mono hr, bddAbove_Icc.mono hr⟩\n\n"}
{"name":"NNReal.continuous_coe","module":"Mathlib.Topology.Instances.NNReal.Defs","initialProofState":"⊢ Continuous NNReal.toReal","decl":"theorem continuous_coe : Continuous ((↑) : ℝ≥0 → ℝ) :=\n  continuous_subtype_val\n\n"}
{"name":"NNReal.instContinuousSub","module":"Mathlib.Topology.Instances.NNReal.Defs","initialProofState":"⊢ ContinuousSub NNReal","decl":"instance : ContinuousSub ℝ≥0 :=\n  ⟨((continuous_coe.fst'.sub continuous_coe.snd').max continuous_const).subtype_mk _⟩\n\n"}
{"name":"NNReal.instHasContinuousInv₀","module":"Mathlib.Topology.Instances.NNReal.Defs","initialProofState":"⊢ HasContinuousInv₀ NNReal","decl":"instance : HasContinuousInv₀ ℝ≥0 := inferInstance\n\n"}
{"name":"NNReal.instContinuousSMulOfReal","module":"Mathlib.Topology.Instances.NNReal.Defs","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : MulAction Real α\ninst✝ : ContinuousSMul Real α\n⊢ ContinuousSMul NNReal α","decl":"instance [TopologicalSpace α] [MulAction ℝ α] [ContinuousSMul ℝ α] :\n    ContinuousSMul ℝ≥0 α where\n  continuous_smul := continuous_induced_dom.fst'.smul continuous_snd\n\n"}
{"name":"ContinuousMap.coeNNRealReal_apply","module":"Mathlib.Topology.Instances.NNReal.Defs","initialProofState":"⊢ Eq (⇑ContinuousMap.coeNNRealReal) NNReal.toReal","decl":"/-- Embedding of `ℝ≥0` to `ℝ` as a bundled continuous map. -/\n@[simps (config := .asFn)]\ndef _root_.ContinuousMap.coeNNRealReal : C(ℝ≥0, ℝ) :=\n  ⟨(↑), continuous_coe⟩\n\n"}
{"name":"NNReal.ContinuousMap.canLift","module":"Mathlib.Topology.Instances.NNReal.Defs","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\n⊢ CanLift (ContinuousMap X Real) (ContinuousMap X NNReal) ContinuousMap.coeNNRealReal.comp fun f => ∀ (x : X), LE.le 0 (f x)","decl":"instance ContinuousMap.canLift {X : Type*} [TopologicalSpace X] :\n    CanLift C(X, ℝ) C(X, ℝ≥0) ContinuousMap.coeNNRealReal.comp fun f => ∀ x, 0 ≤ f x where\n  prf f hf := ⟨⟨fun x => ⟨f x, hf x⟩, f.2.subtype_mk _⟩, DFunLike.ext' rfl⟩\n\n"}
{"name":"NNReal.instProperSpace","module":"Mathlib.Topology.Instances.NNReal.Defs","initialProofState":"⊢ ProperSpace NNReal","decl":"instance instProperSpace : ProperSpace ℝ≥0 where\n  isCompact_closedBall x r := by\n    have emb : IsClosedEmbedding ((↑) : ℝ≥0 → ℝ) := Isometry.isClosedEmbedding fun _ ↦ congrFun rfl\n    exact emb.isCompact_preimage (K := Metric.closedBall x r) (isCompact_closedBall _ _)\n\n"}
