{"name":"AlgebraicGeometry.IsClosedImmersion.toSurjectiveOnStalks","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nself : AlgebraicGeometry.IsClosedImmersion f\n‚ä¢ AlgebraicGeometry.SurjectiveOnStalks f","decl":"/-- A morphism of schemes `X ‚ü∂ Y` is a closed immersion if the underlying\ntopological map is a closed embedding and the induced stalk maps are surjective. -/\n@[mk_iff]\nclass IsClosedImmersion {X Y : Scheme} (f : X ‚ü∂ Y) extends SurjectiveOnStalks f : Prop where\n  base_closed : IsClosedEmbedding f.base\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.base_closed","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nself : AlgebraicGeometry.IsClosedImmersion f\n‚ä¢ Topology.IsClosedEmbedding ‚áëf.base","decl":"/-- A morphism of schemes `X ‚ü∂ Y` is a closed immersion if the underlying\ntopological map is a closed embedding and the induced stalk maps are surjective. -/\n@[mk_iff]\nclass IsClosedImmersion {X Y : Scheme} (f : X ‚ü∂ Y) extends SurjectiveOnStalks f : Prop where\n  base_closed : IsClosedEmbedding f.base\n\n"}
{"name":"AlgebraicGeometry.isClosedImmersion_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n‚ä¢ Iff (AlgebraicGeometry.IsClosedImmersion f) (And (AlgebraicGeometry.SurjectiveOnStalks f) (Topology.IsClosedEmbedding ‚áëf.base))","decl":"/-- A morphism of schemes `X ‚ü∂ Y` is a closed immersion if the underlying\ntopological map is a closed embedding and the induced stalk maps are surjective. -/\n@[mk_iff]\nclass IsClosedImmersion {X Y : Scheme} (f : X ‚ü∂ Y) extends SurjectiveOnStalks f : Prop where\n  base_closed : IsClosedEmbedding f.base\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.isClosedEmbedding","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\ninst‚úù : AlgebraicGeometry.IsClosedImmersion f\n‚ä¢ Topology.IsClosedEmbedding ‚áëf.base","decl":"lemma Scheme.Hom.isClosedEmbedding {X Y : Scheme} (f : X.Hom Y)\n    [IsClosedImmersion f] : IsClosedEmbedding f.base :=\n  IsClosedImmersion.base_closed\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.isClosedEmbedding","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\ninst‚úù : AlgebraicGeometry.IsClosedImmersion f\n‚ä¢ Topology.IsClosedEmbedding ‚áëf.base","decl":"@[deprecated (since := \"2024-10-24\")]\nalias isClosedEmbedding := Scheme.Hom.isClosedEmbedding\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.closedEmbedding","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\ninst‚úù : AlgebraicGeometry.IsClosedImmersion f\n‚ä¢ Topology.IsClosedEmbedding ‚áëf.base","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding := isClosedEmbedding\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.eq_inf","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"‚ä¢ Eq (@AlgebraicGeometry.IsClosedImmersion) (Min.min (AlgebraicGeometry.topologically fun {Œ± Œ≤} [TopologicalSpace Œ±] [TopologicalSpace Œ≤] => Topology.IsClosedEmbedding) @AlgebraicGeometry.SurjectiveOnStalks)","decl":"lemma eq_inf : @IsClosedImmersion = (topologically IsClosedEmbedding) ‚äì\n    @SurjectiveOnStalks := by\n  ext X Y f\n  rw [isClosedImmersion_iff, and_comm]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.iff_isPreimmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n‚ä¢ Iff (AlgebraicGeometry.IsClosedImmersion f) (And (AlgebraicGeometry.IsPreimmersion f) (IsClosed (Set.range ‚áëf.base)))","decl":"lemma iff_isPreimmersion {X Y : Scheme} {f : X ‚ü∂ Y} :\n    IsClosedImmersion f ‚Üî IsPreimmersion f ‚àß IsClosed (Set.range f.base) := by\n  rw [isClosedImmersion_iff, isPreimmersion_iff, and_assoc, isClosedEmbedding_iff]\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.of_isPreimmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù : AlgebraicGeometry.IsPreimmersion f\nhf : IsClosed (Set.range ‚áëf.base)\n‚ä¢ AlgebraicGeometry.IsClosedImmersion f","decl":"lemma of_isPreimmersion {X Y : Scheme} (f : X ‚ü∂ Y) [IsPreimmersion f]\n    (hf : IsClosed (Set.range f.base)) : IsClosedImmersion f :=\n  iff_isPreimmersion.mpr ‚ü®‚Äπ_‚Ä∫, hf‚ü©\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.instIsPreimmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù : AlgebraicGeometry.IsClosedImmersion f\n‚ä¢ AlgebraicGeometry.IsPreimmersion f","decl":"instance (priority := 900) {X Y : Scheme} (f : X ‚ü∂ Y) [IsClosedImmersion f] : IsPreimmersion f :=\n  (iff_isPreimmersion.mp ‚Äπ_‚Ä∫).1\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.instOfIsIsoScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ AlgebraicGeometry.IsClosedImmersion f","decl":"/-- Isomorphisms are closed immersions. -/\ninstance {X Y : Scheme} (f : X ‚ü∂ Y) [IsIso f] : IsClosedImmersion f where\n  base_closed := Homeomorph.isClosedEmbedding <| TopCat.homeoOfIso (asIso f.base)\n  surj_on_stalks := fun _ ‚Ü¶ (ConcreteCategory.bijective_of_isIso _).2\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.instIsMultiplicativeScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"‚ä¢ CategoryTheory.MorphismProperty.IsMultiplicative @AlgebraicGeometry.IsClosedImmersion","decl":"instance : MorphismProperty.IsMultiplicative @IsClosedImmersion where\n  id_mem _ := inferInstance\n  comp_mem _ _ hf hg := ‚ü®hg.base_closed.comp hf.base_closed‚ü©\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.comp","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : AlgebraicGeometry.IsClosedImmersion f\ninst‚úù : AlgebraicGeometry.IsClosedImmersion g\n‚ä¢ AlgebraicGeometry.IsClosedImmersion (CategoryTheory.CategoryStruct.comp f g)","decl":"/-- Composition of closed immersions is a closed immersion. -/\ninstance comp {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsClosedImmersion f]\n    [IsClosedImmersion g] : IsClosedImmersion (f ‚â´ g) :=\n  MorphismProperty.IsStableUnderComposition.comp_mem f g inferInstance inferInstance\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"‚ä¢ CategoryTheory.MorphismProperty.RespectsIso @AlgebraicGeometry.IsClosedImmersion","decl":"/-- Composition with an isomorphism preserves closed immersions. -/\ninstance respectsIso : MorphismProperty.RespectsIso @IsClosedImmersion := by\n  apply MorphismProperty.RespectsIso.mk <;> intro X Y Z e f hf <;> infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.spec_of_surjective","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\nh : Function.Surjective ‚áë(CategoryTheory.ConcreteCategory.hom f)\n‚ä¢ AlgebraicGeometry.IsClosedImmersion (AlgebraicGeometry.Spec.map f)","decl":"/-- Given two commutative rings `R S : CommRingCat` and a surjective morphism\n`f : R ‚ü∂ S`, the induced scheme morphism `specObj S ‚ü∂ specObj R` is a\nclosed immersion. -/\ntheorem spec_of_surjective {R S : CommRingCat} (f : R ‚ü∂ S) (h : Function.Surjective f) :\n    IsClosedImmersion (Spec.map f) where\n  base_closed := PrimeSpectrum.isClosedEmbedding_comap_of_surjective _ _ h\n  surj_on_stalks x := by\n    haveI : (RingHom.toMorphismProperty (fun f ‚Ü¶ Function.Surjective f)).RespectsIso := by\n      rw [‚Üê RingHom.toMorphismProperty_respectsIso_iff]\n      exact RingHom.surjective_respectsIso\n    apply (MorphismProperty.arrow_mk_iso_iff\n      (RingHom.toMorphismProperty (fun f ‚Ü¶ Function.Surjective f))\n      (Scheme.arrowStalkMapSpecIso f x)).mpr\n    exact RingHom.surjective_localRingHom_of_surjective f.hom h x.asIdeal\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.spec_of_quotient_mk","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"R : CommRingCat\nI : Ideal ‚ÜëR\n‚ä¢ AlgebraicGeometry.IsClosedImmersion (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (Ideal.Quotient.mk I)))","decl":"/-- For any ideal `I` in a commutative ring `R`, the quotient map `specObj R ‚ü∂ specObj (R ‚ß∏ I)`\nis a closed immersion. -/\ninstance spec_of_quotient_mk {R : CommRingCat.{u}} (I : Ideal R) :\n    IsClosedImmersion (Spec.map (CommRingCat.ofHom (Ideal.Quotient.mk I))) :=\n  spec_of_surjective _ Ideal.Quotient.mk_surjective\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.of_surjective_of_isAffine","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst‚úù¬π : AlgebraicGeometry.IsAffine X\ninst‚úù : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\nh : Function.Surjective ‚áë(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.appTop f))\n‚ä¢ AlgebraicGeometry.IsClosedImmersion f","decl":"/-- Any morphism between affine schemes that is surjective on global sections is a\nclosed immersion. -/\nlemma of_surjective_of_isAffine {X Y : Scheme} [IsAffine X] [IsAffine Y] (f : X ‚ü∂ Y)\n    (h : Function.Surjective (f.appTop)) : IsClosedImmersion f := by\n  rw [MorphismProperty.arrow_mk_iso_iff @IsClosedImmersion (arrowIsoSpecŒìOfIsAffine f)]\n  apply spec_of_surjective\n  exact h\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.of_comp_isClosedImmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : AlgebraicGeometry.IsClosedImmersion g\ninst‚úù : AlgebraicGeometry.IsClosedImmersion (CategoryTheory.CategoryStruct.comp f g)\n‚ä¢ AlgebraicGeometry.IsClosedImmersion f","decl":"/--\nIf `f ‚â´ g` and `g` are closed immersions, then `f` is a closed immersion.\nAlso see `IsClosedImmersion.of_comp` for the general version\nwhere `g` is only required to be separated.\n-/\ntheorem of_comp_isClosedImmersion {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsClosedImmersion g]\n    [IsClosedImmersion (f ‚â´ g)] : IsClosedImmersion f where\n  base_closed := by\n    have h := (f ‚â´ g).isClosedEmbedding\n    simp only [Scheme.comp_coeBase, TopCat.coe_comp] at h\n    refine .of_continuous_injective_isClosedMap (Scheme.Hom.continuous f) h.injective.of_comp ?_\n    intro Z hZ\n    rw [IsClosedEmbedding.isClosed_iff_image_isClosed g.isClosedEmbedding,\n      ‚Üê Set.image_comp]\n    exact h.isClosedMap _ hZ\n  surj_on_stalks x := by\n    have h := (f ‚â´ g).stalkMap_surjective x\n    simp_rw [Scheme.stalkMap_comp] at h\n    exact Function.Surjective.of_comp h\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.Spec_map_residue","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ AlgebraicGeometry.IsClosedImmersion (AlgebraicGeometry.Spec.map (X.residue x))","decl":"instance Spec_map_residue {X : Scheme.{u}} (x) : IsClosedImmersion (Spec.map (X.residue x)) :=\n  IsClosedImmersion.spec_of_surjective (X.residue x)\n    Ideal.Quotient.mk_surjective\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.instQuasiCompact","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù : AlgebraicGeometry.IsClosedImmersion f\n‚ä¢ AlgebraicGeometry.QuasiCompact f","decl":"instance {X Y : Scheme} (f : X ‚ü∂ Y) [IsClosedImmersion f] : QuasiCompact f where\n  isCompact_preimage _ _ hU' := base_closed.isCompact_preimage hU'\n\n"}
{"name":"AlgebraicGeometry.surjective_of_isClosed_range_of_injective","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst‚úù¬π : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\ninst‚úù : CompactSpace ‚Üë‚ÜëX.toPresheafedSpace\nhfcl : IsClosed (Set.range ‚áëf.base)\nhfinj : Function.Injective ‚áë(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.appTop f))\n‚ä¢ Function.Surjective ‚áëf.base","decl":"/-- If `f : X ‚ü∂ Y` is a morphism of schemes with quasi-compact source and affine target, `f`\nhas a closed image and `f` induces an injection on global sections, then\n`f` is surjective. -/\nlemma surjective_of_isClosed_range_of_injective [CompactSpace X]\n    (hfcl : IsClosed (Set.range f.base)) (hfinj : Function.Injective (f.appTop)) :\n    Function.Surjective f.base := by\n  obtain ‚ü®I, hI‚ü© := (Scheme.eq_zeroLocus_of_isClosed_of_isAffine Y (Set.range f.base)).mp hfcl\n  let ùí∞ : X.OpenCover := X.affineCover.finiteSubcover\n  haveI (i : ùí∞.J) : IsAffine (ùí∞.obj i) := Scheme.isAffine_affineCover X _\n  apply Set.range_eq_univ.mp\n  apply hI ‚ñ∏ (Scheme.zeroLocus_eq_top_iff_subset_nilradical _).mpr\n  intro s hs\n  simp only [AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup,\n    Submodule.mem_toAddSubmonoid, SetLike.mem_coe, mem_nilradical, ‚Üê IsNilpotent.map_iff hfinj]\n  refine Scheme.isNilpotent_of_isNilpotent_cover _ ùí∞ (fun i ‚Ü¶ ?_)\n  rw [Scheme.isNilpotent_iff_basicOpen_eq_bot]\n  rw [Scheme.basicOpen_eq_bot_iff_forall_evaluation_eq_zero]\n  intro x\n  suffices h : f.base ((ùí∞.map i).base x.val) ‚àâ Y.basicOpen s by\n    erw [‚Üê Scheme.Œìevaluation_naturality_apply (ùí∞.map i ‚â´ f)]\n    simpa only [Scheme.comp_base, TopCat.coe_comp, Function.comp_apply,\n      Scheme.residueFieldMap_comp, CommRingCat.comp_apply, map_eq_zero,\n      Scheme.evaluation_eq_zero_iff_not_mem_basicOpen]\n  exact (Y.mem_zeroLocus_iff I _).mp (hI ‚ñ∏ Set.mem_range_self ((ùí∞.map i).base x.val)) s hs\n\n"}
{"name":"AlgebraicGeometry.stalkMap_injective_of_isOpenMap_of_injective","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst‚úù¬π : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\ninst‚úù : CompactSpace ‚Üë‚ÜëX.toPresheafedSpace\nhfopen : IsOpenMap ‚áëf.base\nhfinj‚ÇÅ : Function.Injective ‚áëf.base\nhfinj‚ÇÇ : Function.Injective ‚áë(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.appTop f))\nx : ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ Function.Injective ‚áë(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.stalkMap f x))","decl":"/-- If `f : X ‚ü∂ Y` is open, injective, `X` is quasi-compact and `Y` is affine, then `f` is stalkwise\ninjective if it is injective on global sections. -/\nlemma stalkMap_injective_of_isOpenMap_of_injective [CompactSpace X]\n    (hfopen : IsOpenMap f.base) (hfinj‚ÇÅ : Function.Injective f.base)\n    (hfinj‚ÇÇ : Function.Injective (f.appTop)) (x : X) :\n    Function.Injective (f.stalkMap x) := by\n  let œÜ : Œì(Y, ‚ä§) ‚ü∂ Œì(X, ‚ä§) := f.appTop\n  let ùí∞ : X.OpenCover := X.affineCover.finiteSubcover\n  have (i : ùí∞.J) : IsAffine (ùí∞.obj i) := Scheme.isAffine_affineCover X _\n  let res (i : ùí∞.J) : Œì(X, ‚ä§) ‚ü∂ Œì(ùí∞.obj i, ‚ä§) := (ùí∞.map i).appTop\n  refine stalkMap_injective_of_isAffine _ _ (fun (g : Œì(Y, ‚ä§)) h ‚Ü¶ ?_)\n  rw [TopCat.Presheaf.Œìgerm, Scheme.stalkMap_germ_apply] at h\n  obtain ‚ü®U, w, (hx : x ‚àà U), hg‚ü© :=\n    X.toRingedSpace.exists_res_eq_zero_of_germ_eq_zero ‚ä§ (œÜ g) ‚ü®x, trivial‚ü© h\n  obtain ‚ü®_, ‚ü®s, rfl‚ü©, hyv, bsle‚ü© := Opens.isBasis_iff_nbhd.mp (isBasis_basicOpen Y)\n    (show f.base x ‚àà ‚ü®f.base '' U.carrier, hfopen U.carrier U.is_open'‚ü© from ‚ü®x, by simpa‚ü©)\n  let W (i : ùí∞.J) : TopologicalSpace.Opens (ùí∞.obj i) := (ùí∞.obj i).basicOpen ((res i) (œÜ s))\n  have hwle (i : ùí∞.J) : W i ‚â§ (ùí∞.map i)‚Åª¬π·µÅ U := by\n    show (ùí∞.obj i).basicOpen ((ùí∞.map i ‚â´ f).appTop s) ‚â§ _\n    rw [‚Üê Scheme.preimage_basicOpen_top, Scheme.comp_coeBase, Opens.map_comp_obj]\n    refine Scheme.Hom.preimage_le_preimage_of_le _\n      (le_trans (f.preimage_le_preimage_of_le bsle) (le_of_eq ?_))\n    simp [Set.preimage_image_eq _ hfinj‚ÇÅ]\n  have h0 (i : ùí∞.J) : (ùí∞.map i).appLE _ (W i) (by simp) (œÜ g) = 0 := by\n    rw [‚Üê Scheme.Hom.appLE_map _ _ (homOfLE <| hwle i).op, ‚Üê Scheme.Hom.map_appLE _ le_rfl w.op]\n    simp only [CommRingCat.comp_apply]\n    erw [hg]\n    simp only [map_zero]\n  have h1 (i : ùí∞.J) : ‚àÉ n, (res i) (œÜ (s ^ n * g)) = 0 := by\n    obtain ‚ü®n, hn‚ü© := exists_of_res_zero_of_qcqs_of_top (s := ((res i) (œÜ s))) (h0 i)\n    exact ‚ü®n, by rwa [map_mul, map_mul, map_pow, map_pow]‚ü©\n  have h2 : ‚àÉ n, ‚àÄ i, (res i) (œÜ (s ^ n * g)) = 0 := by\n    choose fn hfn using h1\n    refine ‚ü®Finset.sup Finset.univ fn, fun i ‚Ü¶ ?_‚ü©\n    rw [map_mul, map_pow, map_mul, map_pow]\n    simp only [map_mul, map_pow, map_mul, map_pow] at hfn\n    apply pow_mul_eq_zero_of_le (Finset.le_sup (Finset.mem_univ i)) (hfn i)\n  obtain ‚ü®n, hn‚ü© := h2\n  apply germ_eq_zero_of_pow_mul_eq_zero (U := ‚ä§) ‚ü®f.base x, trivial‚ü© hyv\n  rw [RingHom.injective_iff_ker_eq_bot, RingHom.ker_eq_bot_iff_eq_zero] at hfinj‚ÇÇ\n  exact hfinj‚ÇÇ _ (Scheme.zero_of_zero_cover _ _ hn)\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.isIso_of_injective_of_isAffine","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst‚úù¬π : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\ninst‚úù : AlgebraicGeometry.IsClosedImmersion f\nhf : Function.Injective ‚áë(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.appTop f))\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- If `f` is a closed immersion with affine target such that the induced map on global\nsections is injective, `f` is an isomorphism. -/\ntheorem isIso_of_injective_of_isAffine [IsClosedImmersion f]\n    (hf : Function.Injective (f.appTop)) : IsIso f := (isIso_iff_stalk_iso f).mpr <|\n  have : CompactSpace X := f.isClosedEmbedding.compactSpace\n  have hiso : IsIso f.base := TopCat.isIso_of_bijective_of_isClosedMap _\n    ‚ü®f.isClosedEmbedding.injective,\n     surjective_of_isClosed_range_of_injective f.isClosedEmbedding.isClosed_range hf‚ü©\n    (f.isClosedEmbedding.isClosedMap)\n  ‚ü®hiso, fun x ‚Ü¶ (ConcreteCategory.isIso_iff_bijective _).mpr\n    ‚ü®stalkMap_injective_of_isOpenMap_of_injective ((TopCat.homeoOfIso (asIso f.base)).isOpenMap)\n    f.isClosedEmbedding.injective hf _, f.stalkMap_surjective x‚ü©‚ü©\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.isAffine_surjective_of_isAffine","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst‚úù¬π : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\ninst‚úù : AlgebraicGeometry.IsClosedImmersion f\n‚ä¢ And (AlgebraicGeometry.IsAffine X) (Function.Surjective ‚áë(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.appTop f)))","decl":"/-- If `f` is a closed immersion with affine target, the source is affine and\nthe induced map on global sections is surjective. -/\ntheorem isAffine_surjective_of_isAffine [IsClosedImmersion f] :\n    IsAffine X ‚àß Function.Surjective (f.appTop) := by\n  haveI i : IsClosedImmersion f := inferInstance\n  rw [‚Üê affineTargetImageFactorization_comp f] at i ‚ä¢\n  haveI := of_surjective_of_isAffine (affineTargetImageInclusion f)\n    (affineTargetImageInclusion_app_surjective f)\n  haveI := IsClosedImmersion.of_comp_isClosedImmersion (affineTargetImageFactorization f)\n    (affineTargetImageInclusion f)\n  haveI := isIso_of_injective_of_isAffine (affineTargetImageFactorization_app_injective f)\n  exact ‚ü®isAffine_of_isIso (affineTargetImageFactorization f),\n    (ConcreteCategory.bijective_of_isIso\n      ((affineTargetImageFactorization f).appTop)).surjective.comp <|\n      affineTargetImageInclusion_app_surjective f‚ü©\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.Spec_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\nf : Quiver.Hom X (AlgebraicGeometry.Spec R)\n‚ä¢ Iff (AlgebraicGeometry.IsClosedImmersion f) (Exists fun I => Exists fun e => Eq f (CategoryTheory.CategoryStruct.comp e.hom (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (Ideal.Quotient.mk I)))))","decl":"lemma Spec_iff {R : CommRingCat} {f : X ‚ü∂ Spec R} :\n    IsClosedImmersion f ‚Üî ‚àÉ I : Ideal R, ‚àÉ e : X ‚âÖ Spec (.of <| R ‚ß∏ I),\n      f = e.hom ‚â´ Spec.map (CommRingCat.ofHom (Ideal.Quotient.mk I)) := by\n  constructor\n  ¬∑ intro H\n    obtain ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := IsClosedImmersion.isAffine_surjective_of_isAffine f\n    let œÜ := (Scheme.ŒìSpecIso R).inv ‚â´ f.appTop\n    refine ‚ü®RingHom.ker œÜ.1, Scheme.isoSpec _ ‚â™‚â´ Scheme.Spec.mapIso\n        (.op (RingEquiv.ofBijective œÜ.1.kerLift ?_).toCommRingCatIso), ?_‚ü©\n    ¬∑ exact ‚ü®œÜ.1.kerLift_injective, Ideal.Quotient.lift_surjective_of_surjective _ _\n        (h‚ÇÇ.comp (Scheme.ŒìSpecIso R).commRingCatIsoToRingEquiv.symm.surjective)‚ü©\n    ¬∑ simp only [Iso.trans_hom, Functor.mapIso_hom, Iso.op_hom, Scheme.Spec_map,\n        Quiver.Hom.unop_op, Category.assoc, ‚Üê Spec.map_comp]\n      show f = X.isoSpec.hom ‚â´ Spec.map œÜ\n      simp only [Scheme.isoSpec, asIso_hom, Spec.map_comp, ‚Üê Scheme.toSpecŒì_naturality_assoc,\n        ‚Üê SpecMap_ŒìSpecIso_hom, œÜ]\n      simp only [‚Üê Spec.map_comp, Iso.inv_hom_id, Spec.map_id, Category.comp_id]\n  ¬∑ rintro ‚ü®I, e, rfl‚ü©\n    infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.isLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"‚ä¢ AlgebraicGeometry.IsLocalAtTarget @AlgebraicGeometry.IsClosedImmersion","decl":"/-- Being a closed immersion is local at the target. -/\ninstance IsClosedImmersion.isLocalAtTarget : IsLocalAtTarget @IsClosedImmersion :=\n  eq_inf ‚ñ∏ inferInstance\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.hasAffineProperty","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"‚ä¢ AlgebraicGeometry.HasAffineProperty @AlgebraicGeometry.IsClosedImmersion fun X x f [AlgebraicGeometry.IsAffine x] => And (AlgebraicGeometry.IsAffine X) (Function.Surjective ‚áë(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.appTop f)))","decl":"/-- On morphisms with affine target, being a closed immersion is precisely having affine source\nand being surjective on global sections. -/\ninstance IsClosedImmersion.hasAffineProperty : HasAffineProperty @IsClosedImmersion\n    (fun X _ f ‚Ü¶ IsAffine X ‚àß Function.Surjective (f.appTop)) := by\n  convert HasAffineProperty.of_isLocalAtTarget @IsClosedImmersion\n  refine ‚ü®fun ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© ‚Ü¶ of_surjective_of_isAffine _ h‚ÇÇ, by apply isAffine_surjective_of_isAffine‚ü©\n\n"}
{"name":"AlgebraicGeometry.instIsAffineHomOfIsClosedImmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nh : AlgebraicGeometry.IsClosedImmersion f\n‚ä¢ AlgebraicGeometry.IsAffineHom f","decl":"instance (priority := 900) {X Y : Scheme.{u}} (f : X ‚ü∂ Y) [h : IsClosedImmersion f] :\n    IsAffineHom f := by\n  wlog hY : IsAffine Y\n  ¬∑ rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := @IsAffineHom) _\n      (iSup_affineOpens_eq_top Y)]\n    intro U\n    have H : IsClosedImmersion (f ‚à£_ U) := IsLocalAtTarget.restrict h U\n    exact this _ U.2\n  rw [HasAffineProperty.iff_of_isAffine (P := @IsAffineHom)]\n  exact (IsClosedImmersion.isAffine_surjective_of_isAffine f).1\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.isStableUnderBaseChange","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"‚ä¢ CategoryTheory.MorphismProperty.IsStableUnderBaseChange @AlgebraicGeometry.IsClosedImmersion","decl":"/-- Being a closed immersion is stable under base change. -/\ninstance IsClosedImmersion.isStableUnderBaseChange :\n    MorphismProperty.IsStableUnderBaseChange @IsClosedImmersion := by\n  apply HasAffineProperty.isStableUnderBaseChange\n  haveI := HasAffineProperty.isLocal_affineProperty @IsClosedImmersion\n  apply AffineTargetMorphismProperty.IsStableUnderBaseChange.mk\n  intro X Y S _ _ f g ‚ü®ha, hsurj‚ü©\n  exact ‚ü®inferInstance, RingHom.surjective_isStableUnderBaseChange.pullback_fst_appTop _\n    RingHom.surjective_respectsIso f _ hsurj‚ü©\n\n"}
{"name":"AlgebraicGeometry.instLocallyOfFiniteTypeOfIsClosedImmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nh : AlgebraicGeometry.IsClosedImmersion f\n‚ä¢ AlgebraicGeometry.LocallyOfFiniteType f","decl":"/-- Closed immersions are locally of finite type. -/\ninstance (priority := 900) {X Y : Scheme.{u}} (f : X ‚ü∂ Y) [h : IsClosedImmersion f] :\n    LocallyOfFiniteType f := by\n  wlog hY : IsAffine Y\n  ¬∑ rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := @LocallyOfFiniteType) _\n      (iSup_affineOpens_eq_top Y)]\n    intro U\n    have H : IsClosedImmersion (f ‚à£_ U) := IsLocalAtTarget.restrict h U\n    exact this _ U.2\n  obtain ‚ü®_, hf‚ü© := h.isAffine_surjective_of_isAffine\n  rw [HasRingHomProperty.iff_of_isAffine (P := @LocallyOfFiniteType)]\n  exact RingHom.FiniteType.of_surjective (Scheme.Hom.app f ‚ä§).hom hf\n\n"}
{"name":"AlgebraicGeometry.isIso_of_isClosedImmersion_of_surjective","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù¬≤ : AlgebraicGeometry.IsClosedImmersion f\ninst‚úù¬π : AlgebraicGeometry.Surjective f\ninst‚úù : AlgebraicGeometry.IsReduced Y\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- A surjective closed immersion is an isomorphism when the target is reduced. -/\nlemma isIso_of_isClosedImmersion_of_surjective {X Y : Scheme.{u}} (f : X ‚ü∂ Y)\n    [IsClosedImmersion f] [Surjective f] [IsReduced Y] :\n    IsIso f := by\n  wlog hY : IsAffine Y\n  ¬∑ refine (IsLocalAtTarget.iff_of_openCover (P := .isomorphisms Scheme) Y.affineCover).mpr ?_\n    intro i\n    apply (config := { allowSynthFailures := true }) this\n    ¬∑ exact MorphismProperty.pullback_snd _ _ inferInstance\n    ¬∑ exact IsLocalAtTarget.of_isPullback (.of_hasPullback f (Y.affineCover.map i)) ‚Äπ_‚Ä∫\n    ¬∑ exact isReduced_of_isOpenImmersion (Y.affineCover.map i)\n    ¬∑ infer_instance\n  apply IsClosedImmersion.isIso_of_injective_of_isAffine\n  obtain ‚ü®hX, hf‚ü© := HasAffineProperty.iff_of_isAffine.mp ‚ÄπIsClosedImmersion f‚Ä∫\n  let œÜ := f.appTop\n  suffices RingHom.ker œÜ.hom ‚â§ nilradical _ by\n    rwa [nilradical_eq_zero, Submodule.zero_eq_bot, le_bot_iff,\n      ‚Üê RingHom.injective_iff_ker_eq_bot] at this\n  refine (PrimeSpectrum.zeroLocus_eq_top_iff _).mp ?_\n  rw [‚Üê range_specComap_of_surjective _ _ hf, Set.top_eq_univ, Set.range_eq_univ]\n  have : Surjective (Spec.map (f.appTop)) :=\n    (MorphismProperty.arrow_mk_iso_iff @Surjective (arrowIsoSpecŒìOfIsAffine f)).mp\n    (inferInstanceAs (Surjective f))\n  exact this.1\n\n"}
