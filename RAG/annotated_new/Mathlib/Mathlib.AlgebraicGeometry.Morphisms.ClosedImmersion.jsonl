{"name":"AlgebraicGeometry.IsClosedImmersion.toSurjectiveOnStalks","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nself : AlgebraicGeometry.IsClosedImmersion f\n⊢ AlgebraicGeometry.SurjectiveOnStalks f","decl":"/-- A morphism of schemes `X ⟶ Y` is a closed immersion if the underlying\ntopological map is a closed embedding and the induced stalk maps are surjective. -/\n@[mk_iff]\nclass IsClosedImmersion {X Y : Scheme} (f : X ⟶ Y) extends SurjectiveOnStalks f : Prop where\n  base_closed : IsClosedEmbedding f.base\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.base_closed","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nself : AlgebraicGeometry.IsClosedImmersion f\n⊢ Topology.IsClosedEmbedding ⇑f.base","decl":"/-- A morphism of schemes `X ⟶ Y` is a closed immersion if the underlying\ntopological map is a closed embedding and the induced stalk maps are surjective. -/\n@[mk_iff]\nclass IsClosedImmersion {X Y : Scheme} (f : X ⟶ Y) extends SurjectiveOnStalks f : Prop where\n  base_closed : IsClosedEmbedding f.base\n\n"}
{"name":"AlgebraicGeometry.isClosedImmersion_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n⊢ Iff (AlgebraicGeometry.IsClosedImmersion f) (And (AlgebraicGeometry.SurjectiveOnStalks f) (Topology.IsClosedEmbedding ⇑f.base))","decl":"/-- A morphism of schemes `X ⟶ Y` is a closed immersion if the underlying\ntopological map is a closed embedding and the induced stalk maps are surjective. -/\n@[mk_iff]\nclass IsClosedImmersion {X Y : Scheme} (f : X ⟶ Y) extends SurjectiveOnStalks f : Prop where\n  base_closed : IsClosedEmbedding f.base\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.isClosedEmbedding","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\ninst✝ : AlgebraicGeometry.IsClosedImmersion f\n⊢ Topology.IsClosedEmbedding ⇑f.base","decl":"lemma Scheme.Hom.isClosedEmbedding {X Y : Scheme} (f : X.Hom Y)\n    [IsClosedImmersion f] : IsClosedEmbedding f.base :=\n  IsClosedImmersion.base_closed\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.isClosedEmbedding","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\ninst✝ : AlgebraicGeometry.IsClosedImmersion f\n⊢ Topology.IsClosedEmbedding ⇑f.base","decl":"@[deprecated (since := \"2024-10-24\")]\nalias isClosedEmbedding := Scheme.Hom.isClosedEmbedding\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.closedEmbedding","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\ninst✝ : AlgebraicGeometry.IsClosedImmersion f\n⊢ Topology.IsClosedEmbedding ⇑f.base","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding := isClosedEmbedding\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.eq_inf","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"⊢ Eq (@AlgebraicGeometry.IsClosedImmersion) (Min.min (AlgebraicGeometry.topologically fun {α β} [TopologicalSpace α] [TopologicalSpace β] => Topology.IsClosedEmbedding) @AlgebraicGeometry.SurjectiveOnStalks)","decl":"lemma eq_inf : @IsClosedImmersion = (topologically IsClosedEmbedding) ⊓\n    @SurjectiveOnStalks := by\n  ext X Y f\n  rw [isClosedImmersion_iff, and_comm]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.iff_isPreimmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n⊢ Iff (AlgebraicGeometry.IsClosedImmersion f) (And (AlgebraicGeometry.IsPreimmersion f) (IsClosed (Set.range ⇑f.base)))","decl":"lemma iff_isPreimmersion {X Y : Scheme} {f : X ⟶ Y} :\n    IsClosedImmersion f ↔ IsPreimmersion f ∧ IsClosed (Set.range f.base) := by\n  rw [isClosedImmersion_iff, isPreimmersion_iff, and_assoc, isClosedEmbedding_iff]\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.of_isPreimmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsPreimmersion f\nhf : IsClosed (Set.range ⇑f.base)\n⊢ AlgebraicGeometry.IsClosedImmersion f","decl":"lemma of_isPreimmersion {X Y : Scheme} (f : X ⟶ Y) [IsPreimmersion f]\n    (hf : IsClosed (Set.range f.base)) : IsClosedImmersion f :=\n  iff_isPreimmersion.mpr ⟨‹_›, hf⟩\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.instIsPreimmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsClosedImmersion f\n⊢ AlgebraicGeometry.IsPreimmersion f","decl":"instance (priority := 900) {X Y : Scheme} (f : X ⟶ Y) [IsClosedImmersion f] : IsPreimmersion f :=\n  (iff_isPreimmersion.mp ‹_›).1\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.instOfIsIsoScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\n⊢ AlgebraicGeometry.IsClosedImmersion f","decl":"/-- Isomorphisms are closed immersions. -/\ninstance {X Y : Scheme} (f : X ⟶ Y) [IsIso f] : IsClosedImmersion f where\n  base_closed := Homeomorph.isClosedEmbedding <| TopCat.homeoOfIso (asIso f.base)\n  surj_on_stalks := fun _ ↦ (ConcreteCategory.bijective_of_isIso _).2\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.instIsMultiplicativeScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"⊢ CategoryTheory.MorphismProperty.IsMultiplicative @AlgebraicGeometry.IsClosedImmersion","decl":"instance : MorphismProperty.IsMultiplicative @IsClosedImmersion where\n  id_mem _ := inferInstance\n  comp_mem _ _ hf hg := ⟨hg.base_closed.comp hf.base_closed⟩\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.comp","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst✝¹ : AlgebraicGeometry.IsClosedImmersion f\ninst✝ : AlgebraicGeometry.IsClosedImmersion g\n⊢ AlgebraicGeometry.IsClosedImmersion (CategoryTheory.CategoryStruct.comp f g)","decl":"/-- Composition of closed immersions is a closed immersion. -/\ninstance comp {X Y Z : Scheme} (f : X ⟶ Y) (g : Y ⟶ Z) [IsClosedImmersion f]\n    [IsClosedImmersion g] : IsClosedImmersion (f ≫ g) :=\n  MorphismProperty.IsStableUnderComposition.comp_mem f g inferInstance inferInstance\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"⊢ CategoryTheory.MorphismProperty.RespectsIso @AlgebraicGeometry.IsClosedImmersion","decl":"/-- Composition with an isomorphism preserves closed immersions. -/\ninstance respectsIso : MorphismProperty.RespectsIso @IsClosedImmersion := by\n  apply MorphismProperty.RespectsIso.mk <;> intro X Y Z e f hf <;> infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.spec_of_surjective","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\nh : Function.Surjective ⇑(CategoryTheory.ConcreteCategory.hom f)\n⊢ AlgebraicGeometry.IsClosedImmersion (AlgebraicGeometry.Spec.map f)","decl":"/-- Given two commutative rings `R S : CommRingCat` and a surjective morphism\n`f : R ⟶ S`, the induced scheme morphism `specObj S ⟶ specObj R` is a\nclosed immersion. -/\ntheorem spec_of_surjective {R S : CommRingCat} (f : R ⟶ S) (h : Function.Surjective f) :\n    IsClosedImmersion (Spec.map f) where\n  base_closed := PrimeSpectrum.isClosedEmbedding_comap_of_surjective _ _ h\n  surj_on_stalks x := by\n    haveI : (RingHom.toMorphismProperty (fun f ↦ Function.Surjective f)).RespectsIso := by\n      rw [← RingHom.toMorphismProperty_respectsIso_iff]\n      exact RingHom.surjective_respectsIso\n    apply (MorphismProperty.arrow_mk_iso_iff\n      (RingHom.toMorphismProperty (fun f ↦ Function.Surjective f))\n      (Scheme.arrowStalkMapSpecIso f x)).mpr\n    exact RingHom.surjective_localRingHom_of_surjective f.hom h x.asIdeal\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.spec_of_quotient_mk","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"R : CommRingCat\nI : Ideal ↑R\n⊢ AlgebraicGeometry.IsClosedImmersion (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (Ideal.Quotient.mk I)))","decl":"/-- For any ideal `I` in a commutative ring `R`, the quotient map `specObj R ⟶ specObj (R ⧸ I)`\nis a closed immersion. -/\ninstance spec_of_quotient_mk {R : CommRingCat.{u}} (I : Ideal R) :\n    IsClosedImmersion (Spec.map (CommRingCat.ofHom (Ideal.Quotient.mk I))) :=\n  spec_of_surjective _ Ideal.Quotient.mk_surjective\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.of_surjective_of_isAffine","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst✝¹ : AlgebraicGeometry.IsAffine X\ninst✝ : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\nh : Function.Surjective ⇑(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.appTop f))\n⊢ AlgebraicGeometry.IsClosedImmersion f","decl":"/-- Any morphism between affine schemes that is surjective on global sections is a\nclosed immersion. -/\nlemma of_surjective_of_isAffine {X Y : Scheme} [IsAffine X] [IsAffine Y] (f : X ⟶ Y)\n    (h : Function.Surjective (f.appTop)) : IsClosedImmersion f := by\n  rw [MorphismProperty.arrow_mk_iso_iff @IsClosedImmersion (arrowIsoSpecΓOfIsAffine f)]\n  apply spec_of_surjective\n  exact h\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.of_comp_isClosedImmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst✝¹ : AlgebraicGeometry.IsClosedImmersion g\ninst✝ : AlgebraicGeometry.IsClosedImmersion (CategoryTheory.CategoryStruct.comp f g)\n⊢ AlgebraicGeometry.IsClosedImmersion f","decl":"/--\nIf `f ≫ g` and `g` are closed immersions, then `f` is a closed immersion.\nAlso see `IsClosedImmersion.of_comp` for the general version\nwhere `g` is only required to be separated.\n-/\ntheorem of_comp_isClosedImmersion {X Y Z : Scheme} (f : X ⟶ Y) (g : Y ⟶ Z) [IsClosedImmersion g]\n    [IsClosedImmersion (f ≫ g)] : IsClosedImmersion f where\n  base_closed := by\n    have h := (f ≫ g).isClosedEmbedding\n    simp only [Scheme.comp_coeBase, TopCat.coe_comp] at h\n    refine .of_continuous_injective_isClosedMap (Scheme.Hom.continuous f) h.injective.of_comp ?_\n    intro Z hZ\n    rw [IsClosedEmbedding.isClosed_iff_image_isClosed g.isClosedEmbedding,\n      ← Set.image_comp]\n    exact h.isClosedMap _ hZ\n  surj_on_stalks x := by\n    have h := (f ≫ g).stalkMap_surjective x\n    simp_rw [Scheme.stalkMap_comp] at h\n    exact Function.Surjective.of_comp h\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.Spec_map_residue","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ↑↑X.toPresheafedSpace\n⊢ AlgebraicGeometry.IsClosedImmersion (AlgebraicGeometry.Spec.map (X.residue x))","decl":"instance Spec_map_residue {X : Scheme.{u}} (x) : IsClosedImmersion (Spec.map (X.residue x)) :=\n  IsClosedImmersion.spec_of_surjective (X.residue x)\n    Ideal.Quotient.mk_surjective\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.instQuasiCompact","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsClosedImmersion f\n⊢ AlgebraicGeometry.QuasiCompact f","decl":"instance {X Y : Scheme} (f : X ⟶ Y) [IsClosedImmersion f] : QuasiCompact f where\n  isCompact_preimage _ _ hU' := base_closed.isCompact_preimage hU'\n\n"}
{"name":"AlgebraicGeometry.surjective_of_isClosed_range_of_injective","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst✝¹ : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\ninst✝ : CompactSpace ↑↑X.toPresheafedSpace\nhfcl : IsClosed (Set.range ⇑f.base)\nhfinj : Function.Injective ⇑(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.appTop f))\n⊢ Function.Surjective ⇑f.base","decl":"/-- If `f : X ⟶ Y` is a morphism of schemes with quasi-compact source and affine target, `f`\nhas a closed image and `f` induces an injection on global sections, then\n`f` is surjective. -/\nlemma surjective_of_isClosed_range_of_injective [CompactSpace X]\n    (hfcl : IsClosed (Set.range f.base)) (hfinj : Function.Injective (f.appTop)) :\n    Function.Surjective f.base := by\n  obtain ⟨I, hI⟩ := (Scheme.eq_zeroLocus_of_isClosed_of_isAffine Y (Set.range f.base)).mp hfcl\n  let 𝒰 : X.OpenCover := X.affineCover.finiteSubcover\n  haveI (i : 𝒰.J) : IsAffine (𝒰.obj i) := Scheme.isAffine_affineCover X _\n  apply Set.range_eq_univ.mp\n  apply hI ▸ (Scheme.zeroLocus_eq_top_iff_subset_nilradical _).mpr\n  intro s hs\n  simp only [AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup,\n    Submodule.mem_toAddSubmonoid, SetLike.mem_coe, mem_nilradical, ← IsNilpotent.map_iff hfinj]\n  refine Scheme.isNilpotent_of_isNilpotent_cover _ 𝒰 (fun i ↦ ?_)\n  rw [Scheme.isNilpotent_iff_basicOpen_eq_bot]\n  rw [Scheme.basicOpen_eq_bot_iff_forall_evaluation_eq_zero]\n  intro x\n  suffices h : f.base ((𝒰.map i).base x.val) ∉ Y.basicOpen s by\n    erw [← Scheme.Γevaluation_naturality_apply (𝒰.map i ≫ f)]\n    simpa only [Scheme.comp_base, TopCat.coe_comp, Function.comp_apply,\n      Scheme.residueFieldMap_comp, CommRingCat.comp_apply, map_eq_zero,\n      Scheme.evaluation_eq_zero_iff_not_mem_basicOpen]\n  exact (Y.mem_zeroLocus_iff I _).mp (hI ▸ Set.mem_range_self ((𝒰.map i).base x.val)) s hs\n\n"}
{"name":"AlgebraicGeometry.stalkMap_injective_of_isOpenMap_of_injective","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst✝¹ : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\ninst✝ : CompactSpace ↑↑X.toPresheafedSpace\nhfopen : IsOpenMap ⇑f.base\nhfinj₁ : Function.Injective ⇑f.base\nhfinj₂ : Function.Injective ⇑(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.appTop f))\nx : ↑↑X.toPresheafedSpace\n⊢ Function.Injective ⇑(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.stalkMap f x))","decl":"/-- If `f : X ⟶ Y` is open, injective, `X` is quasi-compact and `Y` is affine, then `f` is stalkwise\ninjective if it is injective on global sections. -/\nlemma stalkMap_injective_of_isOpenMap_of_injective [CompactSpace X]\n    (hfopen : IsOpenMap f.base) (hfinj₁ : Function.Injective f.base)\n    (hfinj₂ : Function.Injective (f.appTop)) (x : X) :\n    Function.Injective (f.stalkMap x) := by\n  let φ : Γ(Y, ⊤) ⟶ Γ(X, ⊤) := f.appTop\n  let 𝒰 : X.OpenCover := X.affineCover.finiteSubcover\n  have (i : 𝒰.J) : IsAffine (𝒰.obj i) := Scheme.isAffine_affineCover X _\n  let res (i : 𝒰.J) : Γ(X, ⊤) ⟶ Γ(𝒰.obj i, ⊤) := (𝒰.map i).appTop\n  refine stalkMap_injective_of_isAffine _ _ (fun (g : Γ(Y, ⊤)) h ↦ ?_)\n  rw [TopCat.Presheaf.Γgerm, Scheme.stalkMap_germ_apply] at h\n  obtain ⟨U, w, (hx : x ∈ U), hg⟩ :=\n    X.toRingedSpace.exists_res_eq_zero_of_germ_eq_zero ⊤ (φ g) ⟨x, trivial⟩ h\n  obtain ⟨_, ⟨s, rfl⟩, hyv, bsle⟩ := Opens.isBasis_iff_nbhd.mp (isBasis_basicOpen Y)\n    (show f.base x ∈ ⟨f.base '' U.carrier, hfopen U.carrier U.is_open'⟩ from ⟨x, by simpa⟩)\n  let W (i : 𝒰.J) : TopologicalSpace.Opens (𝒰.obj i) := (𝒰.obj i).basicOpen ((res i) (φ s))\n  have hwle (i : 𝒰.J) : W i ≤ (𝒰.map i)⁻¹ᵁ U := by\n    show (𝒰.obj i).basicOpen ((𝒰.map i ≫ f).appTop s) ≤ _\n    rw [← Scheme.preimage_basicOpen_top, Scheme.comp_coeBase, Opens.map_comp_obj]\n    refine Scheme.Hom.preimage_le_preimage_of_le _\n      (le_trans (f.preimage_le_preimage_of_le bsle) (le_of_eq ?_))\n    simp [Set.preimage_image_eq _ hfinj₁]\n  have h0 (i : 𝒰.J) : (𝒰.map i).appLE _ (W i) (by simp) (φ g) = 0 := by\n    rw [← Scheme.Hom.appLE_map _ _ (homOfLE <| hwle i).op, ← Scheme.Hom.map_appLE _ le_rfl w.op]\n    simp only [CommRingCat.comp_apply]\n    erw [hg]\n    simp only [map_zero]\n  have h1 (i : 𝒰.J) : ∃ n, (res i) (φ (s ^ n * g)) = 0 := by\n    obtain ⟨n, hn⟩ := exists_of_res_zero_of_qcqs_of_top (s := ((res i) (φ s))) (h0 i)\n    exact ⟨n, by rwa [map_mul, map_mul, map_pow, map_pow]⟩\n  have h2 : ∃ n, ∀ i, (res i) (φ (s ^ n * g)) = 0 := by\n    choose fn hfn using h1\n    refine ⟨Finset.sup Finset.univ fn, fun i ↦ ?_⟩\n    rw [map_mul, map_pow, map_mul, map_pow]\n    simp only [map_mul, map_pow, map_mul, map_pow] at hfn\n    apply pow_mul_eq_zero_of_le (Finset.le_sup (Finset.mem_univ i)) (hfn i)\n  obtain ⟨n, hn⟩ := h2\n  apply germ_eq_zero_of_pow_mul_eq_zero (U := ⊤) ⟨f.base x, trivial⟩ hyv\n  rw [RingHom.injective_iff_ker_eq_bot, RingHom.ker_eq_bot_iff_eq_zero] at hfinj₂\n  exact hfinj₂ _ (Scheme.zero_of_zero_cover _ _ hn)\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.isIso_of_injective_of_isAffine","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst✝¹ : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsClosedImmersion f\nhf : Function.Injective ⇑(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.appTop f))\n⊢ CategoryTheory.IsIso f","decl":"/-- If `f` is a closed immersion with affine target such that the induced map on global\nsections is injective, `f` is an isomorphism. -/\ntheorem isIso_of_injective_of_isAffine [IsClosedImmersion f]\n    (hf : Function.Injective (f.appTop)) : IsIso f := (isIso_iff_stalk_iso f).mpr <|\n  have : CompactSpace X := f.isClosedEmbedding.compactSpace\n  have hiso : IsIso f.base := TopCat.isIso_of_bijective_of_isClosedMap _\n    ⟨f.isClosedEmbedding.injective,\n     surjective_of_isClosed_range_of_injective f.isClosedEmbedding.isClosed_range hf⟩\n    (f.isClosedEmbedding.isClosedMap)\n  ⟨hiso, fun x ↦ (ConcreteCategory.isIso_iff_bijective _).mpr\n    ⟨stalkMap_injective_of_isOpenMap_of_injective ((TopCat.homeoOfIso (asIso f.base)).isOpenMap)\n    f.isClosedEmbedding.injective hf _, f.stalkMap_surjective x⟩⟩\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.isAffine_surjective_of_isAffine","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst✝¹ : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsClosedImmersion f\n⊢ And (AlgebraicGeometry.IsAffine X) (Function.Surjective ⇑(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.appTop f)))","decl":"/-- If `f` is a closed immersion with affine target, the source is affine and\nthe induced map on global sections is surjective. -/\ntheorem isAffine_surjective_of_isAffine [IsClosedImmersion f] :\n    IsAffine X ∧ Function.Surjective (f.appTop) := by\n  haveI i : IsClosedImmersion f := inferInstance\n  rw [← affineTargetImageFactorization_comp f] at i ⊢\n  haveI := of_surjective_of_isAffine (affineTargetImageInclusion f)\n    (affineTargetImageInclusion_app_surjective f)\n  haveI := IsClosedImmersion.of_comp_isClosedImmersion (affineTargetImageFactorization f)\n    (affineTargetImageInclusion f)\n  haveI := isIso_of_injective_of_isAffine (affineTargetImageFactorization_app_injective f)\n  exact ⟨isAffine_of_isIso (affineTargetImageFactorization f),\n    (ConcreteCategory.bijective_of_isIso\n      ((affineTargetImageFactorization f).appTop)).surjective.comp <|\n      affineTargetImageInclusion_app_surjective f⟩\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.Spec_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\nf : Quiver.Hom X (AlgebraicGeometry.Spec R)\n⊢ Iff (AlgebraicGeometry.IsClosedImmersion f) (Exists fun I => Exists fun e => Eq f (CategoryTheory.CategoryStruct.comp e.hom (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (Ideal.Quotient.mk I)))))","decl":"lemma Spec_iff {R : CommRingCat} {f : X ⟶ Spec R} :\n    IsClosedImmersion f ↔ ∃ I : Ideal R, ∃ e : X ≅ Spec (.of <| R ⧸ I),\n      f = e.hom ≫ Spec.map (CommRingCat.ofHom (Ideal.Quotient.mk I)) := by\n  constructor\n  · intro H\n    obtain ⟨h₁, h₂⟩ := IsClosedImmersion.isAffine_surjective_of_isAffine f\n    let φ := (Scheme.ΓSpecIso R).inv ≫ f.appTop\n    refine ⟨RingHom.ker φ.1, Scheme.isoSpec _ ≪≫ Scheme.Spec.mapIso\n        (.op (RingEquiv.ofBijective φ.1.kerLift ?_).toCommRingCatIso), ?_⟩\n    · exact ⟨φ.1.kerLift_injective, Ideal.Quotient.lift_surjective_of_surjective _ _\n        (h₂.comp (Scheme.ΓSpecIso R).commRingCatIsoToRingEquiv.symm.surjective)⟩\n    · simp only [Iso.trans_hom, Functor.mapIso_hom, Iso.op_hom, Scheme.Spec_map,\n        Quiver.Hom.unop_op, Category.assoc, ← Spec.map_comp]\n      show f = X.isoSpec.hom ≫ Spec.map φ\n      simp only [Scheme.isoSpec, asIso_hom, Spec.map_comp, ← Scheme.toSpecΓ_naturality_assoc,\n        ← SpecMap_ΓSpecIso_hom, φ]\n      simp only [← Spec.map_comp, Iso.inv_hom_id, Spec.map_id, Category.comp_id]\n  · rintro ⟨I, e, rfl⟩\n    infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.isLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"⊢ AlgebraicGeometry.IsLocalAtTarget @AlgebraicGeometry.IsClosedImmersion","decl":"/-- Being a closed immersion is local at the target. -/\ninstance IsClosedImmersion.isLocalAtTarget : IsLocalAtTarget @IsClosedImmersion :=\n  eq_inf ▸ inferInstance\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.hasAffineProperty","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"⊢ AlgebraicGeometry.HasAffineProperty @AlgebraicGeometry.IsClosedImmersion fun X x f [AlgebraicGeometry.IsAffine x] => And (AlgebraicGeometry.IsAffine X) (Function.Surjective ⇑(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.appTop f)))","decl":"/-- On morphisms with affine target, being a closed immersion is precisely having affine source\nand being surjective on global sections. -/\ninstance IsClosedImmersion.hasAffineProperty : HasAffineProperty @IsClosedImmersion\n    (fun X _ f ↦ IsAffine X ∧ Function.Surjective (f.appTop)) := by\n  convert HasAffineProperty.of_isLocalAtTarget @IsClosedImmersion\n  refine ⟨fun ⟨h₁, h₂⟩ ↦ of_surjective_of_isAffine _ h₂, by apply isAffine_surjective_of_isAffine⟩\n\n"}
{"name":"AlgebraicGeometry.instIsAffineHomOfIsClosedImmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nh : AlgebraicGeometry.IsClosedImmersion f\n⊢ AlgebraicGeometry.IsAffineHom f","decl":"instance (priority := 900) {X Y : Scheme.{u}} (f : X ⟶ Y) [h : IsClosedImmersion f] :\n    IsAffineHom f := by\n  wlog hY : IsAffine Y\n  · rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := @IsAffineHom) _\n      (iSup_affineOpens_eq_top Y)]\n    intro U\n    have H : IsClosedImmersion (f ∣_ U) := IsLocalAtTarget.restrict h U\n    exact this _ U.2\n  rw [HasAffineProperty.iff_of_isAffine (P := @IsAffineHom)]\n  exact (IsClosedImmersion.isAffine_surjective_of_isAffine f).1\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.isStableUnderBaseChange","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"⊢ CategoryTheory.MorphismProperty.IsStableUnderBaseChange @AlgebraicGeometry.IsClosedImmersion","decl":"/-- Being a closed immersion is stable under base change. -/\ninstance IsClosedImmersion.isStableUnderBaseChange :\n    MorphismProperty.IsStableUnderBaseChange @IsClosedImmersion := by\n  apply HasAffineProperty.isStableUnderBaseChange\n  haveI := HasAffineProperty.isLocal_affineProperty @IsClosedImmersion\n  apply AffineTargetMorphismProperty.IsStableUnderBaseChange.mk\n  intro X Y S _ _ f g ⟨ha, hsurj⟩\n  exact ⟨inferInstance, RingHom.surjective_isStableUnderBaseChange.pullback_fst_appTop _\n    RingHom.surjective_respectsIso f _ hsurj⟩\n\n"}
{"name":"AlgebraicGeometry.instLocallyOfFiniteTypeOfIsClosedImmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nh : AlgebraicGeometry.IsClosedImmersion f\n⊢ AlgebraicGeometry.LocallyOfFiniteType f","decl":"/-- Closed immersions are locally of finite type. -/\ninstance (priority := 900) {X Y : Scheme.{u}} (f : X ⟶ Y) [h : IsClosedImmersion f] :\n    LocallyOfFiniteType f := by\n  wlog hY : IsAffine Y\n  · rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := @LocallyOfFiniteType) _\n      (iSup_affineOpens_eq_top Y)]\n    intro U\n    have H : IsClosedImmersion (f ∣_ U) := IsLocalAtTarget.restrict h U\n    exact this _ U.2\n  obtain ⟨_, hf⟩ := h.isAffine_surjective_of_isAffine\n  rw [HasRingHomProperty.iff_of_isAffine (P := @LocallyOfFiniteType)]\n  exact RingHom.FiniteType.of_surjective (Scheme.Hom.app f ⊤).hom hf\n\n"}
{"name":"AlgebraicGeometry.isIso_of_isClosedImmersion_of_surjective","module":"Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝² : AlgebraicGeometry.IsClosedImmersion f\ninst✝¹ : AlgebraicGeometry.Surjective f\ninst✝ : AlgebraicGeometry.IsReduced Y\n⊢ CategoryTheory.IsIso f","decl":"/-- A surjective closed immersion is an isomorphism when the target is reduced. -/\nlemma isIso_of_isClosedImmersion_of_surjective {X Y : Scheme.{u}} (f : X ⟶ Y)\n    [IsClosedImmersion f] [Surjective f] [IsReduced Y] :\n    IsIso f := by\n  wlog hY : IsAffine Y\n  · refine (IsLocalAtTarget.iff_of_openCover (P := .isomorphisms Scheme) Y.affineCover).mpr ?_\n    intro i\n    apply (config := { allowSynthFailures := true }) this\n    · exact MorphismProperty.pullback_snd _ _ inferInstance\n    · exact IsLocalAtTarget.of_isPullback (.of_hasPullback f (Y.affineCover.map i)) ‹_›\n    · exact isReduced_of_isOpenImmersion (Y.affineCover.map i)\n    · infer_instance\n  apply IsClosedImmersion.isIso_of_injective_of_isAffine\n  obtain ⟨hX, hf⟩ := HasAffineProperty.iff_of_isAffine.mp ‹IsClosedImmersion f›\n  let φ := f.appTop\n  suffices RingHom.ker φ.hom ≤ nilradical _ by\n    rwa [nilradical_eq_zero, Submodule.zero_eq_bot, le_bot_iff,\n      ← RingHom.injective_iff_ker_eq_bot] at this\n  refine (PrimeSpectrum.zeroLocus_eq_top_iff _).mp ?_\n  rw [← range_specComap_of_surjective _ _ hf, Set.top_eq_univ, Set.range_eq_univ]\n  have : Surjective (Spec.map (f.appTop)) :=\n    (MorphismProperty.arrow_mk_iso_iff @Surjective (arrowIsoSpecΓOfIsAffine f)).mp\n    (inferInstanceAs (Surjective f))\n  exact this.1\n\n"}
