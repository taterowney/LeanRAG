{"name":"Nat.choose_le_pow_div","module":"Mathlib.Data.Nat.Choose.Bounds","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedSemifield α\nr n : Nat\n⊢ LE.le (↑(n.choose r)) (HDiv.hDiv (HPow.hPow (↑n) r) ↑r.factorial)","decl":"theorem choose_le_pow_div (r n : ℕ) : (n.choose r : α) ≤ (n ^ r : α) / r ! := by\n  rw [le_div_iff₀']\n  · norm_cast\n    rw [← Nat.descFactorial_eq_factorial_mul_choose]\n    exact n.descFactorial_le_pow r\n  exact mod_cast r.factorial_pos\n\n"}
{"name":"Nat.choose_le_descFactorial","module":"Mathlib.Data.Nat.Choose.Bounds","initialProofState":"n k : Nat\n⊢ LE.le (n.choose k) (n.descFactorial k)","decl":"lemma choose_le_descFactorial (n k : ℕ) : n.choose k ≤ n.descFactorial k := by\n  rw [choose_eq_descFactorial_div_factorial]\n  exact Nat.div_le_self _ _\n\n"}
{"name":"Nat.choose_le_pow","module":"Mathlib.Data.Nat.Choose.Bounds","initialProofState":"n k : Nat\n⊢ LE.le (n.choose k) (HPow.hPow n k)","decl":"/-- This lemma was changed on 2024/08/29, the old statement is available\nin `Nat.choose_le_pow_div`. -/\nlemma choose_le_pow (n k : ℕ) : n.choose k ≤ n ^ k :=\n  (choose_le_descFactorial n k).trans (descFactorial_le_pow n k)\n\n-- horrific casting is due to ℕ-subtraction\n"}
{"name":"Nat.pow_le_choose","module":"Mathlib.Data.Nat.Choose.Bounds","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedSemifield α\nr n : Nat\n⊢ LE.le (HDiv.hDiv (HPow.hPow (↑(HSub.hSub (HAdd.hAdd n 1) r)) r) ↑r.factorial) ↑(n.choose r)","decl":"theorem pow_le_choose (r n : ℕ) : ((n + 1 - r : ℕ) ^ r : α) / r ! ≤ n.choose r := by\n  rw [div_le_iff₀']\n  · norm_cast\n    rw [← Nat.descFactorial_eq_factorial_mul_choose]\n    exact n.pow_sub_le_descFactorial r\n  exact mod_cast r.factorial_pos\n\n"}
{"name":"Nat.choose_succ_le_two_pow","module":"Mathlib.Data.Nat.Choose.Bounds","initialProofState":"n k : Nat\n⊢ LE.le ((HAdd.hAdd n 1).choose k) (HPow.hPow 2 n)","decl":"theorem choose_succ_le_two_pow (n k : ℕ) : (n + 1).choose k ≤ 2 ^ n := by\n  by_cases lt : n + 1 < k\n  · simp [choose_eq_zero_of_lt lt]\n  · cases' n with n\n    · cases k <;> simp_all\n    · cases' k with k\n      · rw [choose_zero_right]\n        exact Nat.one_le_two_pow\n      · rw [choose_succ_succ', two_pow_succ]\n        exact Nat.add_le_add (choose_succ_le_two_pow n k) (choose_succ_le_two_pow n (k + 1))\n\n"}
{"name":"Nat.choose_le_two_pow","module":"Mathlib.Data.Nat.Choose.Bounds","initialProofState":"n k : Nat\np : LT.lt 0 n\n⊢ LT.lt (n.choose k) (HPow.hPow 2 n)","decl":"theorem choose_le_two_pow (n k : ℕ) (p : 0 < n) : n.choose k < 2 ^ n := by\n  refine lt_of_le_of_lt ?_ (Nat.two_pow_pred_lt_two_pow p)\n  rw [← Nat.sub_add_cancel p]\n  exact choose_succ_le_two_pow (n - 1) k\n\n"}
