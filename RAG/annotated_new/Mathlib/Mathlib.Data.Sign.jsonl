{"name":"SignType.ofNat_toCtorIdx","module":"Mathlib.Data.Sign","initialProofState":"x : SignType\n⊢ Eq (SignType.ofNat x.toCtorIdx) x","decl":"set_option genSizeOfSpec false in\n/-- The type of signs. -/\ninductive SignType\n  | zero\n  | neg\n  | pos\n  deriving DecidableEq, Inhabited, Fintype\n\n"}
{"name":"SignType.enumList_nodup","module":"Mathlib.Data.Sign","initialProofState":"⊢ SignType.enumList.Nodup","decl":"set_option genSizeOfSpec false in\n/-- The type of signs. -/\ninductive SignType\n  | zero\n  | neg\n  | pos\n  deriving DecidableEq, Inhabited, Fintype\n\n"}
{"name":"SignType.enumList_get?_to_CtorIdx_eq","module":"Mathlib.Data.Sign","initialProofState":"x✝ : SignType\n⊢ Eq (SignType.enumList.get? x✝.toCtorIdx) (Option.some x✝)","decl":"set_option genSizeOfSpec false in\n/-- The type of signs. -/\ninductive SignType\n  | zero\n  | neg\n  | pos\n  deriving DecidableEq, Inhabited, Fintype\n\n"}
{"name":"SignType.zero_eq_zero","module":"Mathlib.Data.Sign","initialProofState":"⊢ Eq SignType.zero 0","decl":"@[simp]\ntheorem zero_eq_zero : zero = 0 :=\n  rfl\n\n"}
{"name":"SignType.neg_eq_neg_one","module":"Mathlib.Data.Sign","initialProofState":"⊢ Eq SignType.neg (-1)","decl":"@[simp]\ntheorem neg_eq_neg_one : neg = -1 :=\n  rfl\n\n"}
{"name":"SignType.pos_eq_one","module":"Mathlib.Data.Sign","initialProofState":"⊢ Eq SignType.pos 1","decl":"@[simp]\ntheorem pos_eq_one : pos = 1 :=\n  rfl\n\n"}
{"name":"SignType.nonneg_iff","module":"Mathlib.Data.Sign","initialProofState":"a : SignType\n⊢ Iff (LE.le 0 a) (Or (Eq a 0) (Eq a 1))","decl":"theorem nonneg_iff {a : SignType} : 0 ≤ a ↔ a = 0 ∨ a = 1 := by cases a <;> decide\n\n"}
{"name":"SignType.nonneg_iff_ne_neg_one","module":"Mathlib.Data.Sign","initialProofState":"a : SignType\n⊢ Iff (LE.le 0 a) (Ne a (-1))","decl":"theorem nonneg_iff_ne_neg_one {a : SignType} : 0 ≤ a ↔ a ≠ -1 := by cases a <;> decide\n\n"}
{"name":"SignType.neg_one_lt_iff","module":"Mathlib.Data.Sign","initialProofState":"a : SignType\n⊢ Iff (LT.lt (-1) a) (LE.le 0 a)","decl":"theorem neg_one_lt_iff {a : SignType} : -1 < a ↔ 0 ≤ a := by cases a <;> decide\n\n"}
{"name":"SignType.nonpos_iff","module":"Mathlib.Data.Sign","initialProofState":"a : SignType\n⊢ Iff (LE.le a 0) (Or (Eq a (-1)) (Eq a 0))","decl":"theorem nonpos_iff {a : SignType} : a ≤ 0 ↔ a = -1 ∨ a = 0 := by cases a <;> decide\n\n"}
{"name":"SignType.nonpos_iff_ne_one","module":"Mathlib.Data.Sign","initialProofState":"a : SignType\n⊢ Iff (LE.le a 0) (Ne a 1)","decl":"theorem nonpos_iff_ne_one {a : SignType} : a ≤ 0 ↔ a ≠ 1 := by cases a <;> decide\n\n"}
{"name":"SignType.lt_one_iff","module":"Mathlib.Data.Sign","initialProofState":"a : SignType\n⊢ Iff (LT.lt a 1) (LE.le a 0)","decl":"theorem lt_one_iff {a : SignType} : a < 1 ↔ a ≤ 0 := by cases a <;> decide\n\n"}
{"name":"SignType.neg_iff","module":"Mathlib.Data.Sign","initialProofState":"a : SignType\n⊢ Iff (LT.lt a 0) (Eq a (-1))","decl":"@[simp]\ntheorem neg_iff {a : SignType} : a < 0 ↔ a = -1 := by cases a <;> decide\n\n"}
{"name":"SignType.le_neg_one_iff","module":"Mathlib.Data.Sign","initialProofState":"a : SignType\n⊢ Iff (LE.le a (-1)) (Eq a (-1))","decl":"@[simp]\ntheorem le_neg_one_iff {a : SignType} : a ≤ -1 ↔ a = -1 :=\n  le_bot_iff\n\n"}
{"name":"SignType.pos_iff","module":"Mathlib.Data.Sign","initialProofState":"a : SignType\n⊢ Iff (LT.lt 0 a) (Eq a 1)","decl":"@[simp]\ntheorem pos_iff {a : SignType} : 0 < a ↔ a = 1 := by cases a <;> decide\n\n"}
{"name":"SignType.one_le_iff","module":"Mathlib.Data.Sign","initialProofState":"a : SignType\n⊢ Iff (LE.le 1 a) (Eq a 1)","decl":"@[simp]\ntheorem one_le_iff {a : SignType} : 1 ≤ a ↔ a = 1 :=\n  top_le_iff\n\n"}
{"name":"SignType.neg_one_le","module":"Mathlib.Data.Sign","initialProofState":"a : SignType\n⊢ LE.le (-1) a","decl":"@[simp]\ntheorem neg_one_le (a : SignType) : -1 ≤ a :=\n  bot_le\n\n"}
{"name":"SignType.le_one","module":"Mathlib.Data.Sign","initialProofState":"a : SignType\n⊢ LE.le a 1","decl":"@[simp]\ntheorem le_one (a : SignType) : a ≤ 1 :=\n  le_top\n\n"}
{"name":"SignType.not_lt_neg_one","module":"Mathlib.Data.Sign","initialProofState":"a : SignType\n⊢ Not (LT.lt a (-1))","decl":"@[simp]\ntheorem not_lt_neg_one (a : SignType) : ¬a < -1 :=\n  not_lt_bot\n\n"}
{"name":"SignType.not_one_lt","module":"Mathlib.Data.Sign","initialProofState":"a : SignType\n⊢ Not (LT.lt 1 a)","decl":"@[simp]\ntheorem not_one_lt (a : SignType) : ¬1 < a :=\n  not_top_lt\n\n"}
{"name":"SignType.self_eq_neg_iff","module":"Mathlib.Data.Sign","initialProofState":"a : SignType\n⊢ Iff (Eq a (Neg.neg a)) (Eq a 0)","decl":"@[simp]\ntheorem self_eq_neg_iff (a : SignType) : a = -a ↔ a = 0 := by cases a <;> decide\n\n"}
{"name":"SignType.neg_eq_self_iff","module":"Mathlib.Data.Sign","initialProofState":"a : SignType\n⊢ Iff (Eq (Neg.neg a) a) (Eq a 0)","decl":"@[simp]\ntheorem neg_eq_self_iff (a : SignType) : -a = a ↔ a = 0 := by cases a <;> decide\n\n"}
{"name":"SignType.neg_one_lt_one","module":"Mathlib.Data.Sign","initialProofState":"⊢ LT.lt (-1) 1","decl":"@[simp]\ntheorem neg_one_lt_one : (-1 : SignType) < 1 :=\n  bot_lt_top\n\n"}
{"name":"SignType.map_cast'","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝⁵ : Zero α\ninst✝⁴ : One α\ninst✝³ : Neg α\nβ : Type u_2\ninst✝² : One β\ninst✝¹ : Neg β\ninst✝ : Zero β\nf : α → β\nh₁ : Eq (f 1) 1\nh₂ : Eq (f 0) 0\nh₃ : Eq (f (-1)) (-1)\ns : SignType\n⊢ Eq (f ↑s) ↑s","decl":"/-- Casting out of `SignType` respects composition with functions preserving `0, 1, -1`. -/\nlemma map_cast' {β : Type*} [One β] [Neg β] [Zero β]\n    (f : α → β) (h₁ : f 1 = 1) (h₂ : f 0 = 0) (h₃ : f (-1) = -1) (s : SignType) :\n    f s = s := by\n  cases s <;> simp only [SignType.cast, h₁, h₂, h₃]\n\n"}
{"name":"SignType.map_cast","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_2\nβ : Type u_3\nF : Type u_4\ninst✝⁵ : AddGroupWithOne α\ninst✝⁴ : One β\ninst✝³ : SubtractionMonoid β\ninst✝² : FunLike F α β\ninst✝¹ : AddMonoidHomClass F α β\ninst✝ : OneHomClass F α β\nf : F\ns : SignType\n⊢ Eq (f ↑s) ↑s","decl":"/-- Casting out of `SignType` respects composition with suitable bundled homomorphism types. -/\nlemma map_cast {α β F : Type*} [AddGroupWithOne α] [One β] [SubtractionMonoid β]\n    [FunLike F α β] [AddMonoidHomClass F α β] [OneHomClass F α β] (f : F) (s : SignType) :\n    f s = s := by\n  apply map_cast' <;> simp\n\n"}
{"name":"SignType.coe_zero","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝² : Zero α\ninst✝¹ : One α\ninst✝ : Neg α\n⊢ Eq (↑0) 0","decl":"@[simp]\ntheorem coe_zero : ↑(0 : SignType) = (0 : α) :=\n  rfl\n\n"}
{"name":"SignType.coe_one","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝² : Zero α\ninst✝¹ : One α\ninst✝ : Neg α\n⊢ Eq (↑1) 1","decl":"@[simp]\ntheorem coe_one : ↑(1 : SignType) = (1 : α) :=\n  rfl\n\n"}
{"name":"SignType.coe_neg_one","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝² : Zero α\ninst✝¹ : One α\ninst✝ : Neg α\n⊢ Eq (↑(-1)) (-1)","decl":"@[simp]\ntheorem coe_neg_one : ↑(-1 : SignType) = (-1 : α) :=\n  rfl\n\n"}
{"name":"SignType.coe_neg","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_2\ninst✝¹ : One α\ninst✝ : SubtractionMonoid α\ns : SignType\n⊢ Eq (↑(Neg.neg s)) (Neg.neg ↑s)","decl":"@[simp, norm_cast]\nlemma coe_neg {α : Type*} [One α] [SubtractionMonoid α] (s : SignType) :\n    (↑(-s) : α) = -↑s := by\n  cases s <;> simp\n\n"}
{"name":"SignType.intCast_cast","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_2\ninst✝ : AddGroupWithOne α\ns : SignType\n⊢ Eq ↑↑s ↑s","decl":"/-- Casting `SignType → ℤ → α` is the same as casting directly `SignType → α`. -/\n@[simp, norm_cast]\nlemma intCast_cast {α : Type*} [AddGroupWithOne α] (s : SignType) : ((s : ℤ) : α) = s :=\n  map_cast' _ Int.cast_one Int.cast_zero (@Int.cast_one α _ ▸ Int.cast_neg 1) _\n\n"}
{"name":"SignType.castHom_apply","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝¹ : MulZeroOneClass α\ninst✝ : HasDistribNeg α\na✝ : SignType\n⊢ Eq (SignType.castHom a✝) ↑a✝","decl":"/-- `SignType.cast` as a `MulWithZeroHom`. -/\n@[simps]\ndef castHom {α} [MulZeroOneClass α] [HasDistribNeg α] : SignType →*₀ α where\n  toFun := cast\n  map_zero' := rfl\n  map_one' := rfl\n  map_mul' x y := by cases x <;> cases y <;> simp [zero_eq_zero, pos_eq_one, neg_eq_neg_one]\n\n"}
{"name":"SignType.univ_eq","module":"Mathlib.Data.Sign","initialProofState":"⊢ Eq Finset.univ (Insert.insert 0 (Insert.insert (-1) (Singleton.singleton 1)))","decl":"theorem univ_eq : (Finset.univ : Finset SignType) = {0, -1, 1} := by\n  decide\n\n"}
{"name":"SignType.range_eq","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\nf : SignType → α\n⊢ Eq (Set.range f) (Insert.insert (f SignType.zero) (Insert.insert (f SignType.neg) (Singleton.singleton (f SignType.pos))))","decl":"theorem range_eq {α} (f : SignType → α) : Set.range f = {f zero, f neg, f pos} := by\n  classical rw [← Fintype.coe_image_univ, univ_eq]\n  classical simp [Finset.coe_insert]\n\n"}
{"name":"SignType.coe_mul","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝¹ : MulZeroOneClass α\ninst✝ : HasDistribNeg α\na b : SignType\n⊢ Eq (↑(HMul.hMul a b)) (HMul.hMul ↑a ↑b)","decl":"@[simp, norm_cast] lemma coe_mul {α} [MulZeroOneClass α] [HasDistribNeg α] (a b : SignType) :\n    ↑(a * b) = (a : α) * b :=\n  map_mul SignType.castHom _ _\n\n"}
{"name":"SignType.coe_pow","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝¹ : MonoidWithZero α\ninst✝ : HasDistribNeg α\na : SignType\nk : Nat\n⊢ Eq (↑(HPow.hPow a k)) (HPow.hPow (↑a) k)","decl":"@[simp, norm_cast] lemma coe_pow {α} [MonoidWithZero α] [HasDistribNeg α] (a : SignType) (k : ℕ) :\n    ↑(a ^ k) = (a : α) ^ k :=\n  map_pow SignType.castHom _ _\n\n"}
{"name":"SignType.coe_zpow","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝¹ : GroupWithZero α\ninst✝ : HasDistribNeg α\na : SignType\nk : Int\n⊢ Eq (↑(HPow.hPow a k)) (HPow.hPow (↑a) k)","decl":"@[simp, norm_cast] lemma coe_zpow {α} [GroupWithZero α] [HasDistribNeg α] (a : SignType) (k : ℤ) :\n    ↑(a ^ k) = (a : α) ^ k :=\n  map_zpow₀ SignType.castHom _ _\n\n"}
{"name":"sign_apply","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝² : Zero α\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\na : α\n⊢ Eq (SignType.sign a) (ite (LT.lt 0 a) 1 (ite (LT.lt a 0) (-1) 0))","decl":"theorem sign_apply : sign a = ite (0 < a) 1 (ite (a < 0) (-1) 0) :=\n  rfl\n\n"}
{"name":"sign_zero","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝² : Zero α\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\n⊢ Eq (SignType.sign 0) 0","decl":"@[simp]\ntheorem sign_zero : sign (0 : α) = 0 := by simp [sign_apply]\n\n"}
{"name":"sign_pos","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝² : Zero α\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\na : α\nha : LT.lt 0 a\n⊢ Eq (SignType.sign a) 1","decl":"@[simp]\ntheorem sign_pos (ha : 0 < a) : sign a = 1 := by rwa [sign_apply, if_pos]\n\n"}
{"name":"sign_neg","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝² : Zero α\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\na : α\nha : LT.lt a 0\n⊢ Eq (SignType.sign a) (-1)","decl":"@[simp]\ntheorem sign_neg (ha : a < 0) : sign a = -1 := by rwa [sign_apply, if_neg <| asymm ha, if_pos]\n\n"}
{"name":"sign_eq_one_iff","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝² : Zero α\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\na : α\n⊢ Iff (Eq (SignType.sign a) 1) (LT.lt 0 a)","decl":"theorem sign_eq_one_iff : sign a = 1 ↔ 0 < a := by\n  refine ⟨fun h => ?_, fun h => sign_pos h⟩\n  by_contra hn\n  rw [sign_apply, if_neg hn] at h\n  split_ifs at h\n\n"}
{"name":"sign_eq_neg_one_iff","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝² : Zero α\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\na : α\n⊢ Iff (Eq (SignType.sign a) (-1)) (LT.lt a 0)","decl":"theorem sign_eq_neg_one_iff : sign a = -1 ↔ a < 0 := by\n  refine ⟨fun h => ?_, fun h => sign_neg h⟩\n  rw [sign_apply] at h\n  split_ifs at h\n  assumption\n\n"}
{"name":"StrictMono.sign_comp","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝⁶ : Zero α\ninst✝⁵ : LinearOrder α\nβ : Type u_2\nF : Type u_3\ninst✝⁴ : Zero β\ninst✝³ : Preorder β\ninst✝² : DecidableRel fun x1 x2 => LT.lt x1 x2\ninst✝¹ : FunLike F α β\ninst✝ : ZeroHomClass F α β\nf : F\nhf : StrictMono ⇑f\na : α\n⊢ Eq (SignType.sign (f a)) (SignType.sign a)","decl":"/-- `SignType.sign` respects strictly monotone zero-preserving maps. -/\nlemma StrictMono.sign_comp {β F : Type*} [Zero β] [Preorder β] [DecidableRel ((· < ·) : β → β → _)]\n    [FunLike F α β] [ZeroHomClass F α β] {f : F} (hf : StrictMono f) (a : α) :\n    sign (f a) = sign a := by\n  simp only [sign_apply, ← map_zero f, hf.lt_iff_lt]\n\n"}
{"name":"sign_eq_zero_iff","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝¹ : Zero α\ninst✝ : LinearOrder α\na : α\n⊢ Iff (Eq (SignType.sign a) 0) (Eq a 0)","decl":"@[simp]\ntheorem sign_eq_zero_iff : sign a = 0 ↔ a = 0 := by\n  refine ⟨fun h => ?_, fun h => h.symm ▸ sign_zero⟩\n  rw [sign_apply] at h\n  split_ifs at h with h_1 h_2\n  cases' h\n  exact (le_of_not_lt h_1).eq_of_not_lt h_2\n\n"}
{"name":"sign_ne_zero","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝¹ : Zero α\ninst✝ : LinearOrder α\na : α\n⊢ Iff (Ne (SignType.sign a) 0) (Ne a 0)","decl":"theorem sign_ne_zero : sign a ≠ 0 ↔ a ≠ 0 :=\n  sign_eq_zero_iff.not\n\n"}
{"name":"sign_nonneg_iff","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝¹ : Zero α\ninst✝ : LinearOrder α\na : α\n⊢ Iff (LE.le 0 (SignType.sign a)) (LE.le 0 a)","decl":"@[simp]\ntheorem sign_nonneg_iff : 0 ≤ sign a ↔ 0 ≤ a := by\n  rcases lt_trichotomy 0 a with (h | h | h)\n  · simp [h, h.le]\n  · simp [← h]\n  · simp [h, h.not_le]\n\n"}
{"name":"sign_nonpos_iff","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝¹ : Zero α\ninst✝ : LinearOrder α\na : α\n⊢ Iff (LE.le (SignType.sign a) 0) (LE.le a 0)","decl":"@[simp]\ntheorem sign_nonpos_iff : sign a ≤ 0 ↔ a ≤ 0 := by\n  rcases lt_trichotomy 0 a with (h | h | h)\n  · simp [h, h.not_le]\n  · simp [← h]\n  · simp [h, h.le]\n\n"}
{"name":"sign_one","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝² : OrderedSemiring α\ninst✝¹ : DecidableRel fun x1 x2 => LT.lt x1 x2\ninst✝ : Nontrivial α\n⊢ Eq (SignType.sign 1) 1","decl":"theorem sign_one : sign (1 : α) = 1 :=\n  sign_pos zero_lt_one\n\n"}
{"name":"sign_intCast","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_2\ninst✝² : OrderedRing α\ninst✝¹ : Nontrivial α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nn : Int\n⊢ Eq (SignType.sign ↑n) (SignType.sign n)","decl":"@[simp]\nlemma sign_intCast {α : Type*} [OrderedRing α] [Nontrivial α]\n    [DecidableRel ((· < ·) : α → α → Prop)] (n : ℤ) :\n    sign (n : α) = sign n := by\n  simp only [sign_apply, Int.cast_pos, Int.cast_lt_zero]\n\n"}
{"name":"sign_mul","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\nx y : α\n⊢ Eq (SignType.sign (HMul.hMul x y)) (HMul.hMul (SignType.sign x) (SignType.sign y))","decl":"theorem sign_mul (x y : α) : sign (x * y) = sign x * sign y := by\n  rcases lt_trichotomy x 0 with (hx | hx | hx) <;> rcases lt_trichotomy y 0 with (hy | hy | hy) <;>\n    simp [hx, hy, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]\n\n"}
{"name":"sign_mul_abs","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\nx : α\n⊢ Eq (HMul.hMul (↑(SignType.sign x)) (abs x)) x","decl":"@[simp] theorem sign_mul_abs (x : α) : (sign x * |x| : α) = x := by\n  rcases lt_trichotomy x 0 with hx | rfl | hx <;> simp [*, abs_of_pos, abs_of_neg]\n\n"}
{"name":"abs_mul_sign","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\nx : α\n⊢ Eq (HMul.hMul (abs x) ↑(SignType.sign x)) x","decl":"@[simp] theorem abs_mul_sign (x : α) : (|x| * sign x : α) = x := by\n  rcases lt_trichotomy x 0 with hx | rfl | hx <;> simp [*, abs_of_pos, abs_of_neg]\n\n"}
{"name":"sign_mul_self","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\nx : α\n⊢ Eq (HMul.hMul (↑(SignType.sign x)) x) (abs x)","decl":"@[simp]\ntheorem sign_mul_self (x : α) : sign x * x = |x| := by\n  rcases lt_trichotomy x 0 with hx | rfl | hx <;> simp [*, abs_of_pos, abs_of_neg]\n\n"}
{"name":"self_mul_sign","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\nx : α\n⊢ Eq (HMul.hMul x ↑(SignType.sign x)) (abs x)","decl":"@[simp]\ntheorem self_mul_sign (x : α) : x * sign x = |x| := by\n  rcases lt_trichotomy x 0 with hx | rfl | hx <;> simp [*, abs_of_pos, abs_of_neg]\n\n"}
{"name":"sign_pow","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\nx : α\nn : Nat\n⊢ Eq (SignType.sign (HPow.hPow x n)) (HPow.hPow (SignType.sign x) n)","decl":"theorem sign_pow (x : α) (n : ℕ) : sign (x ^ n) = sign x ^ n := map_pow signHom x n\n\n"}
{"name":"Left.sign_neg","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝³ : AddGroup α\ninst✝² : Preorder α\ninst✝¹ : DecidableRel fun x1 x2 => LT.lt x1 x2\ninst✝ : AddLeftStrictMono α\na : α\n⊢ Eq (SignType.sign (Neg.neg a)) (Neg.neg (SignType.sign a))","decl":"theorem Left.sign_neg [AddLeftStrictMono α] (a : α) : sign (-a) = -sign a := by\n  simp_rw [sign_apply, Left.neg_pos_iff, Left.neg_neg_iff]\n  split_ifs with h h'\n  · exact False.elim (lt_asymm h h')\n  · simp\n  · simp\n  · simp\n\n"}
{"name":"Right.sign_neg","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝³ : AddGroup α\ninst✝² : Preorder α\ninst✝¹ : DecidableRel fun x1 x2 => LT.lt x1 x2\ninst✝ : AddRightStrictMono α\na : α\n⊢ Eq (SignType.sign (Neg.neg a)) (Neg.neg (SignType.sign a))","decl":"theorem Right.sign_neg [AddRightStrictMono α] (a : α) :\n    sign (-a) = -sign a := by\n  simp_rw [sign_apply, Right.neg_pos_iff, Right.neg_neg_iff]\n  split_ifs with h h'\n  · exact False.elim (lt_asymm h h')\n  · simp\n  · simp\n  · simp\n\n"}
{"name":"sign_sum","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommGroup α\nι : Type u_2\ns : Finset ι\nf : ι → α\nhs : s.Nonempty\nt : SignType\nh : ∀ (i : ι), Membership.mem s i → Eq (SignType.sign (f i)) t\n⊢ Eq (SignType.sign (s.sum fun i => f i)) t","decl":"theorem sign_sum {ι : Type*} {s : Finset ι} {f : ι → α} (hs : s.Nonempty) (t : SignType)\n    (h : ∀ i ∈ s, sign (f i) = t) : sign (∑ i ∈ s, f i) = t := by\n  cases t\n  · simp_rw [zero_eq_zero, sign_eq_zero_iff] at h ⊢\n    exact Finset.sum_eq_zero h\n  · simp_rw [neg_eq_neg_one, sign_eq_neg_one_iff] at h ⊢\n    exact Finset.sum_neg h hs\n  · simp_rw [pos_eq_one, sign_eq_one_iff] at h ⊢\n    exact Finset.sum_pos h hs\n\n"}
{"name":"Int.sign_eq_sign","module":"Mathlib.Data.Sign","initialProofState":"n : Int\n⊢ Eq n.sign ↑(SignType.sign n)","decl":"theorem sign_eq_sign (n : ℤ) : Int.sign n = SignType.sign n := by\n  obtain (n | _) | _ := n <;> simp [sign, Int.sign_neg, negSucc_lt_zero]\n\n"}
{"name":"exists_signed_sum","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nf : α → Int\n⊢ Exists fun β => Exists fun x => Exists fun sgn => Exists fun g => And (∀ (b : β), Membership.mem s (g b)) (And (Eq (Fintype.card β) (s.sum fun a => (f a).natAbs)) (∀ (a : α), Membership.mem s a → Eq (Finset.univ.sum fun b => ite (Eq (g b) a) (↑(sgn b)) 0) (f a)))","decl":"/-- We can decompose a sum of absolute value `n` into a sum of `n` signs. -/\ntheorem exists_signed_sum {α : Type u_1} [DecidableEq α] (s : Finset α) (f : α → ℤ) :\n    ∃ (β : Type u_1) (_ : Fintype β) (sgn : β → SignType) (g : β → α),\n      (∀ b, g b ∈ s) ∧\n        (Fintype.card β = ∑ a ∈ s, (f a).natAbs) ∧\n          ∀ a ∈ s, (∑ b, if g b = a then (sgn b : ℤ) else 0) = f a :=\n  let ⟨β, t, sgn, g, hg, ht, hf⟩ := exists_signed_sum_aux s f\n  ⟨t, inferInstance, fun b => sgn b, fun b => g b, fun b => hg b, by simp [ht], fun a ha =>\n    (sum_attach t fun b ↦ ite (g b = a) (sgn b : ℤ) 0).trans <| hf _ ha⟩\n\n"}
{"name":"exists_signed_sum'","module":"Mathlib.Data.Sign","initialProofState":"α : Type u_1\ninst✝¹ : Nonempty α\ninst✝ : DecidableEq α\ns : Finset α\nf : α → Int\nn : Nat\nh : LE.le (s.sum fun i => (f i).natAbs) n\n⊢ Exists fun β => Exists fun x => Exists fun sgn => Exists fun g => And (∀ (b : β), Not (Membership.mem s (g b)) → Eq (sgn b) 0) (And (Eq (Fintype.card β) n) (∀ (a : α), Membership.mem s a → Eq (Finset.univ.sum fun i => ite (Eq (g i) a) (↑(sgn i)) 0) (f a)))","decl":"/-- We can decompose a sum of absolute value less than `n` into a sum of at most `n` signs. -/\ntheorem exists_signed_sum' {α : Type u_1} [Nonempty α] [DecidableEq α] (s : Finset α) (f : α → ℤ)\n    (n : ℕ) (h : (∑ i ∈ s, (f i).natAbs) ≤ n) :\n    ∃ (β : Type u_1) (_ : Fintype β) (sgn : β → SignType) (g : β → α),\n      (∀ b, g b ∉ s → sgn b = 0) ∧\n        Fintype.card β = n ∧ ∀ a ∈ s, (∑ i, if g i = a then (sgn i : ℤ) else 0) = f a := by\n  obtain ⟨β, _, sgn, g, hg, hβ, hf⟩ := exists_signed_sum s f\n  refine\n    ⟨β ⊕ (Fin (n - ∑ i ∈ s, (f i).natAbs)), inferInstance, Sum.elim sgn 0,\n      Sum.elim g (Classical.arbitrary (Fin (n - Finset.sum s fun i => Int.natAbs (f i)) → α)),\n        ?_, by simp [hβ, h], fun a ha => by simp [hf _ ha]⟩\n  rintro (b | b) hb\n  · cases hb (hg _)\n  · rfl\n"}
