{"name":"Polynomial.Gal.instAlgEquivClassSplittingField","module":"Mathlib.FieldTheory.PolynomialGaloisGroup","initialProofState":"F : Type u_1\ninst✝ : Field F\np : Polynomial F\n⊢ AlgEquivClass p.Gal F p.SplittingField p.SplittingField","decl":"instance : AlgEquivClass p.Gal F p.SplittingField p.SplittingField :=\n  inferInstanceAs (AlgEquivClass (p.SplittingField ≃ₐ[F] p.SplittingField) F _ _)\n\n"}
{"name":"Polynomial.Gal.ext_iff","module":"Mathlib.FieldTheory.PolynomialGaloisGroup","initialProofState":"F : Type u_1\ninst✝ : Field F\np : Polynomial F\nσ τ : p.Gal\n⊢ Iff (Eq σ τ) (∀ (x : p.SplittingField), Membership.mem (p.rootSet p.SplittingField) x → Eq (σ x) (τ x))","decl":"@[ext]\ntheorem ext {σ τ : p.Gal} (h : ∀ x ∈ p.rootSet p.SplittingField, σ x = τ x) : σ = τ := by\n  refine\n    AlgEquiv.ext fun x =>\n      (AlgHom.mem_equalizer σ.toAlgHom τ.toAlgHom x).mp\n        ((SetLike.ext_iff.mp ?_ x).mpr Algebra.mem_top)\n  rwa [eq_top_iff, ← SplittingField.adjoin_rootSet, Algebra.adjoin_le_iff]\n\n"}
{"name":"Polynomial.Gal.ext","module":"Mathlib.FieldTheory.PolynomialGaloisGroup","initialProofState":"F : Type u_1\ninst✝ : Field F\np : Polynomial F\nσ τ : p.Gal\nh : ∀ (x : p.SplittingField), Membership.mem (p.rootSet p.SplittingField) x → Eq (σ x) (τ x)\n⊢ Eq σ τ","decl":"@[ext]\ntheorem ext {σ τ : p.Gal} (h : ∀ x ∈ p.rootSet p.SplittingField, σ x = τ x) : σ = τ := by\n  refine\n    AlgEquiv.ext fun x =>\n      (AlgHom.mem_equalizer σ.toAlgHom τ.toAlgHom x).mp\n        ((SetLike.ext_iff.mp ?_ x).mpr Algebra.mem_top)\n  rwa [eq_top_iff, ← SplittingField.adjoin_rootSet, Algebra.adjoin_le_iff]\n\n"}
{"name":"Polynomial.Gal.instIsScalarTowerSplittingField","module":"Mathlib.FieldTheory.PolynomialGaloisGroup","initialProofState":"F : Type u_1\ninst✝² : Field F\np : Polynomial F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nh : Fact (Polynomial.Splits (algebraMap F E) p)\n⊢ IsScalarTower F p.SplittingField E","decl":"instance [h : Fact (p.Splits (algebraMap F E))] : IsScalarTower F p.SplittingField E :=\n  IsScalarTower.of_algebraMap_eq fun x =>\n    ((IsSplittingField.lift p.SplittingField p h.1).commutes x).symm\n\n-- The `Algebra p.SplittingField E` instance above behaves badly when\n-- `E := p.SplittingField`, since it may result in a unification problem\n-- `IsSplittingField.lift.toRingHom.toAlgebra =?= Algebra.id`,\n-- which takes an extremely long time to resolve, causing timeouts.\n-- Since we don't really care about this definition, marking it as irreducible\n-- causes that unification to error out early.\n"}
{"name":"Polynomial.Gal.restrict_surjective","module":"Mathlib.FieldTheory.PolynomialGaloisGroup","initialProofState":"F : Type u_1\ninst✝⁴ : Field F\np : Polynomial F\nE : Type u_2\ninst✝³ : Field E\ninst✝² : Algebra F E\ninst✝¹ : Fact (Polynomial.Splits (algebraMap F E) p)\ninst✝ : Normal F E\n⊢ Function.Surjective ⇑(Polynomial.Gal.restrict p E)","decl":"theorem restrict_surjective [Fact (p.Splits (algebraMap F E))] [Normal F E] :\n    Function.Surjective (restrict p E) :=\n  AlgEquiv.restrictNormalHom_surjective E\n\n"}
{"name":"Polynomial.Gal.mapRoots_bijective","module":"Mathlib.FieldTheory.PolynomialGaloisGroup","initialProofState":"F : Type u_1\ninst✝² : Field F\np : Polynomial F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nh : Fact (Polynomial.Splits (algebraMap F E) p)\n⊢ Function.Bijective (Polynomial.Gal.mapRoots p E)","decl":"theorem mapRoots_bijective [h : Fact (p.Splits (algebraMap F E))] :\n    Function.Bijective (mapRoots p E) := by\n  constructor\n  · exact fun _ _ h => Subtype.ext (RingHom.injective _ (Subtype.ext_iff.mp h))\n  · intro y\n    -- this is just an equality of two different ways to write the roots of `p` as an `E`-polynomial\n    have key :=\n      roots_map (IsScalarTower.toAlgHom F p.SplittingField E : p.SplittingField →+* E)\n        ((splits_id_iff_splits _).mpr (IsSplittingField.splits p.SplittingField p))\n    rw [map_map, AlgHom.comp_algebraMap] at key\n    have hy := Subtype.mem y\n    simp only [rootSet, Finset.mem_coe, Multiset.mem_toFinset, key, Multiset.mem_map] at hy\n    rcases hy with ⟨x, hx1, hx2⟩\n    exact ⟨⟨x, (@Multiset.mem_toFinset _ (Classical.decEq _) _ _).mpr hx1⟩, Subtype.ext hx2⟩\n\n"}
{"name":"Polynomial.Gal.smul_def","module":"Mathlib.FieldTheory.PolynomialGaloisGroup","initialProofState":"F : Type u_1\ninst✝³ : Field F\np : Polynomial F\nE : Type u_2\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Fact (Polynomial.Splits (algebraMap F E) p)\nϕ : p.Gal\nx : ↑(p.rootSet E)\n⊢ Eq (HSMul.hSMul ϕ x) ((Polynomial.Gal.rootsEquivRoots p E) (HSMul.hSMul ϕ ((Polynomial.Gal.rootsEquivRoots p E).symm x)))","decl":"theorem smul_def [Fact (p.Splits (algebraMap F E))] (ϕ : p.Gal) (x : rootSet p E) :\n    ϕ • x = rootsEquivRoots p E (ϕ • (rootsEquivRoots p E).symm x) :=\n  rfl\n\n"}
{"name":"Polynomial.Gal.galAction_isPretransitive","module":"Mathlib.FieldTheory.PolynomialGaloisGroup","initialProofState":"F : Type u_1\ninst✝³ : Field F\np : Polynomial F\nE : Type u_2\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Fact (Polynomial.Splits (algebraMap F E) p)\nhp : Irreducible p\n⊢ MulAction.IsPretransitive p.Gal ↑(p.rootSet E)","decl":"lemma galAction_isPretransitive [Fact (p.Splits (algebraMap F E))] (hp : Irreducible p) :\n    MulAction.IsPretransitive p.Gal (p.rootSet E) := by\n  refine ⟨fun x y ↦ ?_⟩\n  have hx := minpoly.eq_of_irreducible hp (mem_rootSet.mp ((rootsEquivRoots p E).symm x).2).2\n  have hy := minpoly.eq_of_irreducible hp (mem_rootSet.mp ((rootsEquivRoots p E).symm y).2).2\n  obtain ⟨g, hg⟩ := (Normal.minpoly_eq_iff_mem_orbit p.SplittingField).mp (hy.symm.trans hx)\n  exact ⟨g, (rootsEquivRoots p E).apply_eq_iff_eq_symm_apply.mpr (Subtype.ext hg)⟩\n\n"}
{"name":"Polynomial.Gal.restrict_smul","module":"Mathlib.FieldTheory.PolynomialGaloisGroup","initialProofState":"F : Type u_1\ninst✝³ : Field F\np : Polynomial F\nE : Type u_2\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Fact (Polynomial.Splits (algebraMap F E) p)\nϕ : AlgEquiv F E E\nx : ↑(p.rootSet E)\n⊢ Eq (↑(HSMul.hSMul ((Polynomial.Gal.restrict p E) ϕ) x)) (ϕ ↑x)","decl":"/-- `Polynomial.Gal.restrict p E` is compatible with `Polynomial.Gal.galAction p E`. -/\n@[simp]\ntheorem restrict_smul [Fact (p.Splits (algebraMap F E))] (ϕ : E ≃ₐ[F] E) (x : rootSet p E) :\n    ↑(restrict p E ϕ • x) = ϕ x := by\n  let ψ := AlgEquiv.ofInjectiveField (IsScalarTower.toAlgHom F p.SplittingField E)\n  change ↑(ψ (ψ.symm _)) = ϕ x\n  rw [AlgEquiv.apply_symm_apply ψ]\n  change ϕ (rootsEquivRoots p E ((rootsEquivRoots p E).symm x)) = ϕ x\n  rw [Equiv.apply_symm_apply (rootsEquivRoots p E)]\n\n"}
{"name":"Polynomial.Gal.galActionHom_restrict","module":"Mathlib.FieldTheory.PolynomialGaloisGroup","initialProofState":"F : Type u_1\ninst✝³ : Field F\np : Polynomial F\nE : Type u_2\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Fact (Polynomial.Splits (algebraMap F E) p)\nϕ : AlgEquiv F E E\nx : ↑(p.rootSet E)\n⊢ Eq (↑(((Polynomial.Gal.galActionHom p E) ((Polynomial.Gal.restrict p E) ϕ)) x)) (ϕ ↑x)","decl":"theorem galActionHom_restrict [Fact (p.Splits (algebraMap F E))] (ϕ : E ≃ₐ[F] E) (x : rootSet p E) :\n    ↑(galActionHom p E (restrict p E ϕ) x) = ϕ x :=\n  restrict_smul ϕ x\n\n"}
{"name":"Polynomial.Gal.galActionHom_injective","module":"Mathlib.FieldTheory.PolynomialGaloisGroup","initialProofState":"F : Type u_1\ninst✝³ : Field F\np : Polynomial F\nE : Type u_2\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Fact (Polynomial.Splits (algebraMap F E) p)\n⊢ Function.Injective ⇑(Polynomial.Gal.galActionHom p E)","decl":"/-- `gal p` embeds as a subgroup of permutations of the roots of `p` in `E`. -/\ntheorem galActionHom_injective [Fact (p.Splits (algebraMap F E))] :\n    Function.Injective (galActionHom p E) := by\n  rw [injective_iff_map_eq_one]\n  intro ϕ hϕ\n  ext (x hx)\n  have key := Equiv.Perm.ext_iff.mp hϕ (rootsEquivRoots p E ⟨x, hx⟩)\n  change\n    rootsEquivRoots p E (ϕ • (rootsEquivRoots p E).symm (rootsEquivRoots p E ⟨x, hx⟩)) =\n      rootsEquivRoots p E ⟨x, hx⟩\n    at key\n  rw [Equiv.symm_apply_apply] at key\n  exact Subtype.ext_iff.mp (Equiv.injective (rootsEquivRoots p E) key)\n\n"}
{"name":"Polynomial.Gal.restrictDvd_def","module":"Mathlib.FieldTheory.PolynomialGaloisGroup","initialProofState":"F : Type u_1\ninst✝¹ : Field F\np q : Polynomial F\ninst✝ : Decidable (Eq q 0)\nhpq : Dvd.dvd p q\n⊢ Eq (Polynomial.Gal.restrictDvd hpq) (dite (Eq q 0) (fun hq => 1) fun hq => Polynomial.Gal.restrict p q.SplittingField)","decl":"theorem restrictDvd_def [Decidable (q = 0)] (hpq : p ∣ q) :\n    restrictDvd hpq =\n      if hq : q = 0 then 1\n      else\n        @restrict F _ p _ _ _\n          ⟨splits_of_splits_of_dvd (algebraMap F q.SplittingField) hq (SplittingField.splits q)\n              hpq⟩ := by\n  -- Porting note: added `unfold`\n  unfold restrictDvd\n  convert rfl\n\n"}
{"name":"Polynomial.Gal.restrictDvd_surjective","module":"Mathlib.FieldTheory.PolynomialGaloisGroup","initialProofState":"F : Type u_1\ninst✝ : Field F\np q : Polynomial F\nhpq : Dvd.dvd p q\nhq : Ne q 0\n⊢ Function.Surjective ⇑(Polynomial.Gal.restrictDvd hpq)","decl":"theorem restrictDvd_surjective (hpq : p ∣ q) (hq : q ≠ 0) :\n    Function.Surjective (restrictDvd hpq) := by\n  classical\n    -- Porting note: was `simp only [restrictDvd_def, dif_neg hq, restrict_surjective]`\n    haveI := Fact.mk <|\n      splits_of_splits_of_dvd (algebraMap F q.SplittingField) hq (SplittingField.splits q) hpq\n    simp only [restrictDvd_def, dif_neg hq]\n    exact restrict_surjective _ _\n\n"}
{"name":"Polynomial.Gal.restrictProd_injective","module":"Mathlib.FieldTheory.PolynomialGaloisGroup","initialProofState":"F : Type u_1\ninst✝ : Field F\np q : Polynomial F\n⊢ Function.Injective ⇑(Polynomial.Gal.restrictProd p q)","decl":"/-- `Polynomial.Gal.restrictProd` is actually a subgroup embedding. -/\ntheorem restrictProd_injective : Function.Injective (restrictProd p q) := by\n  by_cases hpq : p * q = 0\n  · have : Unique (p * q).Gal := by rw [hpq]; infer_instance\n    exact fun f g _ => Eq.trans (Unique.eq_default f) (Unique.eq_default g).symm\n  intro f g hfg\n  classical\n  simp only [restrictProd, restrictDvd_def] at hfg\n  simp only [dif_neg hpq, MonoidHom.prod_apply, Prod.mk.inj_iff] at hfg\n  ext (x hx)\n  rw [rootSet_def, aroots_mul hpq] at hx\n  cases' Multiset.mem_add.mp (Multiset.mem_toFinset.mp hx) with h h\n  · haveI : Fact (p.Splits (algebraMap F (p * q).SplittingField)) :=\n      ⟨splits_of_splits_of_dvd _ hpq (SplittingField.splits (p * q)) (dvd_mul_right p q)⟩\n    have key :\n      x =\n        algebraMap p.SplittingField (p * q).SplittingField\n          ((rootsEquivRoots p _).invFun\n            ⟨x, (@Multiset.mem_toFinset _ (Classical.decEq _) _ _).mpr h⟩) :=\n      Subtype.ext_iff.mp (Equiv.apply_symm_apply (rootsEquivRoots p _) ⟨x, _⟩).symm\n    rw [key, ← AlgEquiv.restrictNormal_commutes, ← AlgEquiv.restrictNormal_commutes]\n    exact congr_arg _ (AlgEquiv.ext_iff.mp hfg.1 _)\n  · haveI : Fact (q.Splits (algebraMap F (p * q).SplittingField)) :=\n      ⟨splits_of_splits_of_dvd _ hpq (SplittingField.splits (p * q)) (dvd_mul_left q p)⟩\n    have key :\n      x =\n        algebraMap q.SplittingField (p * q).SplittingField\n          ((rootsEquivRoots q _).invFun\n            ⟨x, (@Multiset.mem_toFinset _ (Classical.decEq _) _ _).mpr h⟩) :=\n      Subtype.ext_iff.mp (Equiv.apply_symm_apply (rootsEquivRoots q _) ⟨x, _⟩).symm\n    rw [key, ← AlgEquiv.restrictNormal_commutes, ← AlgEquiv.restrictNormal_commutes]\n    exact congr_arg _ (AlgEquiv.ext_iff.mp hfg.2 _)\n\n"}
{"name":"Polynomial.Gal.mul_splits_in_splittingField_of_mul","module":"Mathlib.FieldTheory.PolynomialGaloisGroup","initialProofState":"F : Type u_1\ninst✝ : Field F\np₁ q₁ p₂ q₂ : Polynomial F\nhq₁ : Ne q₁ 0\nhq₂ : Ne q₂ 0\nh₁ : Polynomial.Splits (algebraMap F q₁.SplittingField) p₁\nh₂ : Polynomial.Splits (algebraMap F q₂.SplittingField) p₂\n⊢ Polynomial.Splits (algebraMap F (HMul.hMul q₁ q₂).SplittingField) (HMul.hMul p₁ p₂)","decl":"theorem mul_splits_in_splittingField_of_mul {p₁ q₁ p₂ q₂ : F[X]} (hq₁ : q₁ ≠ 0) (hq₂ : q₂ ≠ 0)\n    (h₁ : p₁.Splits (algebraMap F q₁.SplittingField))\n    (h₂ : p₂.Splits (algebraMap F q₂.SplittingField)) :\n    (p₁ * p₂).Splits (algebraMap F (q₁ * q₂).SplittingField) := by\n  apply splits_mul\n  · rw [←\n      (SplittingField.lift q₁\n          (splits_of_splits_of_dvd (algebraMap F (q₁ * q₂).SplittingField) (mul_ne_zero hq₁ hq₂)\n            (SplittingField.splits _) (dvd_mul_right q₁ q₂))).comp_algebraMap]\n    exact splits_comp_of_splits _ _ h₁\n  · rw [←\n      (SplittingField.lift q₂\n          (splits_of_splits_of_dvd (algebraMap F (q₁ * q₂).SplittingField) (mul_ne_zero hq₁ hq₂)\n            (SplittingField.splits _) (dvd_mul_left q₂ q₁))).comp_algebraMap]\n    exact splits_comp_of_splits _ _ h₂\n\n"}
{"name":"Polynomial.Gal.splits_in_splittingField_of_comp","module":"Mathlib.FieldTheory.PolynomialGaloisGroup","initialProofState":"F : Type u_1\ninst✝ : Field F\np q : Polynomial F\nhq : Ne q.natDegree 0\n⊢ Polynomial.Splits (algebraMap F (p.comp q).SplittingField) p","decl":"/-- `p` splits in the splitting field of `p ∘ q`, for `q` non-constant. -/\ntheorem splits_in_splittingField_of_comp (hq : q.natDegree ≠ 0) :\n    p.Splits (algebraMap F (p.comp q).SplittingField) := by\n  let P : F[X] → Prop := fun r => r.Splits (algebraMap F (r.comp q).SplittingField)\n  have key1 : ∀ {r : F[X]}, Irreducible r → P r := by\n    intro r hr\n    by_cases hr' : natDegree r = 0\n    · exact splits_of_natDegree_le_one _ (le_trans (le_of_eq hr') zero_le_one)\n    obtain ⟨x, hx⟩ :=\n      exists_root_of_splits _ (SplittingField.splits (r.comp q)) fun h =>\n        hr'\n          ((mul_eq_zero.mp\n                (natDegree_comp.symm.trans (natDegree_eq_of_degree_eq_some h))).resolve_right\n            hq)\n    rw [← aeval_def, aeval_comp] at hx\n    have h_normal : Normal F (r.comp q).SplittingField := SplittingField.instNormal (r.comp q)\n    have qx_int := Normal.isIntegral h_normal (aeval x q)\n    exact\n      splits_of_splits_of_dvd _ (minpoly.ne_zero qx_int) (Normal.splits h_normal _)\n        ((minpoly.irreducible qx_int).dvd_symm hr (minpoly.dvd F _ hx))\n  have key2 : ∀ {p₁ p₂ : F[X]}, P p₁ → P p₂ → P (p₁ * p₂) := by\n    intro p₁ p₂ hp₁ hp₂\n    by_cases h₁ : p₁.comp q = 0\n    · cases' comp_eq_zero_iff.mp h₁ with h h\n      · rw [h, zero_mul]\n        exact splits_zero _\n      · exact False.elim (hq (by rw [h.2, natDegree_C]))\n    by_cases h₂ : p₂.comp q = 0\n    · cases' comp_eq_zero_iff.mp h₂ with h h\n      · rw [h, mul_zero]\n        exact splits_zero _\n      · exact False.elim (hq (by rw [h.2, natDegree_C]))\n    have key := mul_splits_in_splittingField_of_mul h₁ h₂ hp₁ hp₂\n    rwa [← mul_comp] at key\n  -- Porting note: the last part of the proof needs to be unfolded to avoid timeout\n  -- original proof\n  -- exact\n  --  WfDvdMonoid.induction_on_irreducible p (splits_zero _) (fun _ => splits_of_isUnit _)\n  --    fun _ _ _ h => key2 (key1 h)\n  induction p using WfDvdMonoid.induction_on_irreducible with\n  | h0 => exact splits_zero _\n  | hu u hu => exact splits_of_isUnit (algebraMap F (SplittingField (comp u q))) hu\n  -- Porting note: using `exact` instead of `apply` times out\n  | hi p₁ p₂ _ hp₂ hp₁ => apply key2 (key1 hp₂) hp₁\n\n"}
{"name":"Polynomial.Gal.restrictComp_surjective","module":"Mathlib.FieldTheory.PolynomialGaloisGroup","initialProofState":"F : Type u_1\ninst✝ : Field F\np q : Polynomial F\nhq : Ne q.natDegree 0\n⊢ Function.Surjective ⇑(Polynomial.Gal.restrictComp p q hq)","decl":"theorem restrictComp_surjective (hq : q.natDegree ≠ 0) :\n    Function.Surjective (restrictComp p q hq) := by\n  -- Porting note: was\n  -- simp only [restrictComp, restrict_surjective]\n  haveI : Fact (Splits (algebraMap F (SplittingField (comp p q))) p) :=\n    ⟨splits_in_splittingField_of_comp p q hq⟩\n  rw [restrictComp]\n  exact restrict_surjective _ _\n\n"}
{"name":"Polynomial.Gal.card_of_separable","module":"Mathlib.FieldTheory.PolynomialGaloisGroup","initialProofState":"F : Type u_1\ninst✝ : Field F\np : Polynomial F\nhp : p.Separable\n⊢ Eq (Fintype.card p.Gal) (Module.finrank F p.SplittingField)","decl":"/-- For a separable polynomial, its Galois group has cardinality\nequal to the dimension of its splitting field over `F`. -/\ntheorem card_of_separable (hp : p.Separable) : Fintype.card p.Gal = finrank F p.SplittingField :=\n  haveI : IsGalois F p.SplittingField := IsGalois.of_separable_splitting_field hp\n  IsGalois.card_aut_eq_finrank F p.SplittingField\n\n"}
{"name":"Polynomial.Gal.prime_degree_dvd_card","module":"Mathlib.FieldTheory.PolynomialGaloisGroup","initialProofState":"F : Type u_1\ninst✝¹ : Field F\np : Polynomial F\ninst✝ : CharZero F\np_irr : Irreducible p\np_deg : Nat.Prime p.natDegree\n⊢ Dvd.dvd p.natDegree (Fintype.card p.Gal)","decl":"theorem prime_degree_dvd_card [CharZero F] (p_irr : Irreducible p) (p_deg : p.natDegree.Prime) :\n    p.natDegree ∣ Fintype.card p.Gal := by\n  rw [Gal.card_of_separable p_irr.separable]\n  have hp : p.degree ≠ 0 := fun h =>\n    Nat.Prime.ne_zero p_deg (natDegree_eq_zero_iff_degree_le_zero.mpr (le_of_eq h))\n  let α : p.SplittingField :=\n    rootOfSplits (algebraMap F p.SplittingField) (SplittingField.splits p) hp\n  have hα : IsIntegral F α := .of_finite F α\n  use Module.finrank F⟮α⟯ p.SplittingField\n  suffices (minpoly F α).natDegree = p.natDegree by\n    letI _ : AddCommGroup F⟮α⟯ := Ring.toAddCommGroup\n    rw [← Module.finrank_mul_finrank F F⟮α⟯ p.SplittingField,\n      IntermediateField.adjoin.finrank hα, this]\n  suffices minpoly F α ∣ p by\n    have key := (minpoly.irreducible hα).dvd_symm p_irr this\n    apply le_antisymm\n    · exact natDegree_le_of_dvd this p_irr.ne_zero\n    · exact natDegree_le_of_dvd key (minpoly.ne_zero hα)\n  apply minpoly.dvd F α\n  rw [aeval_def, map_rootOfSplits _ (SplittingField.splits p) hp]\n\n"}
