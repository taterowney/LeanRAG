{"name":"uniformity_dist_of_mem_uniformity","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù : LinearOrder Œ≤\nU : Filter (Prod Œ± Œ±)\nz : Œ≤\nD : Œ± ‚Üí Œ± ‚Üí Œ≤\nH : ‚àÄ (s : Set (Prod Œ± Œ±)), Iff (Membership.mem U s) (Exists fun Œµ => And (GT.gt Œµ z) (‚àÄ {a b : Œ±}, LT.lt (D a b) Œµ ‚Üí Membership.mem s { fst := a, snd := b }))\n‚ä¢ Eq U (iInf fun Œµ => iInf fun h => Filter.principal (setOf fun p => LT.lt (D p.1 p.2) Œµ))","decl":"/-- Characterizing uniformities associated to a (generalized) distance function `D`\nin terms of the elements of the uniformity. -/\ntheorem uniformity_dist_of_mem_uniformity [LinearOrder Œ≤] {U : Filter (Œ± √ó Œ±)} (z : Œ≤)\n    (D : Œ± ‚Üí Œ± ‚Üí Œ≤) (H : ‚àÄ s, s ‚àà U ‚Üî ‚àÉ Œµ > z, ‚àÄ {a b : Œ±}, D a b < Œµ ‚Üí (a, b) ‚àà s) :\n    U = ‚®Ö Œµ > z, ùìü { p : Œ± √ó Œ± | D p.1 p.2 < Œµ } :=\n  HasBasis.eq_biInf ‚ü®fun s => by simp only [H, subset_def, Prod.forall, mem_setOf]‚ü©\n\n"}
{"name":"EDist.ext_iff","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u_2\nx y : EDist Œ±\n‚ä¢ Iff (Eq x y) (Eq EDist.edist EDist.edist)","decl":"/-- `EDist Œ±` means that `Œ±` is equipped with an extended distance. -/\n@[ext]\nclass EDist (Œ± : Type*) where\n  edist : Œ± ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû\n\n"}
{"name":"EDist.ext","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u_2\nx y : EDist Œ±\nedist : Eq EDist.edist EDist.edist\n‚ä¢ Eq x y","decl":"/-- `EDist Œ±` means that `Œ±` is equipped with an extended distance. -/\n@[ext]\nclass EDist (Œ± : Type*) where\n  edist : Œ± ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû\n\n"}
{"name":"PseudoEMetricSpace.edist_comm","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\nself : PseudoEMetricSpace Œ±\nx y : Œ±\n‚ä¢ Eq (EDist.edist x y) (EDist.edist y x)","decl":"/-- Extended (pseudo) metric spaces, with an extended distance `edist` possibly taking the\nvalue ‚àû\n\nEach pseudo_emetric space induces a canonical `UniformSpace` and hence a canonical\n`TopologicalSpace`.\nThis is enforced in the type class definition, by extending the `UniformSpace` structure. When\ninstantiating a `PseudoEMetricSpace` structure, the uniformity fields are not necessary, they\nwill be filled in by default. There is a default value for the uniformity, that can be substituted\nin cases of interest, for instance when instantiating a `PseudoEMetricSpace` structure\non a product.\n\nContinuity of `edist` is proved in `Topology.Instances.ENNReal`\n-/\nclass PseudoEMetricSpace (Œ± : Type u) extends EDist Œ± : Type u where\n  edist_self : ‚àÄ x : Œ±, edist x x = 0\n  edist_comm : ‚àÄ x y : Œ±, edist x y = edist y x\n  edist_triangle : ‚àÄ x y z : Œ±, edist x z ‚â§ edist x y + edist y z\n  toUniformSpace : UniformSpace Œ± := uniformSpaceOfEDist edist edist_self edist_comm edist_triangle\n  uniformity_edist : ùì§ Œ± = ‚®Ö Œµ > 0, ùìü { p : Œ± √ó Œ± | edist p.1 p.2 < Œµ } := by rfl\n\n"}
{"name":"PseudoEMetricSpace.uniformity_edist","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\nself : PseudoEMetricSpace Œ±\n‚ä¢ Eq (uniformity Œ±) (iInf fun Œµ => iInf fun h => Filter.principal (setOf fun p => LT.lt (EDist.edist p.1 p.2) Œµ))","decl":"/-- Extended (pseudo) metric spaces, with an extended distance `edist` possibly taking the\nvalue ‚àû\n\nEach pseudo_emetric space induces a canonical `UniformSpace` and hence a canonical\n`TopologicalSpace`.\nThis is enforced in the type class definition, by extending the `UniformSpace` structure. When\ninstantiating a `PseudoEMetricSpace` structure, the uniformity fields are not necessary, they\nwill be filled in by default. There is a default value for the uniformity, that can be substituted\nin cases of interest, for instance when instantiating a `PseudoEMetricSpace` structure\non a product.\n\nContinuity of `edist` is proved in `Topology.Instances.ENNReal`\n-/\nclass PseudoEMetricSpace (Œ± : Type u) extends EDist Œ± : Type u where\n  edist_self : ‚àÄ x : Œ±, edist x x = 0\n  edist_comm : ‚àÄ x y : Œ±, edist x y = edist y x\n  edist_triangle : ‚àÄ x y z : Œ±, edist x z ‚â§ edist x y + edist y z\n  toUniformSpace : UniformSpace Œ± := uniformSpaceOfEDist edist edist_self edist_comm edist_triangle\n  uniformity_edist : ùì§ Œ± = ‚®Ö Œµ > 0, ùìü { p : Œ± √ó Œ± | edist p.1 p.2 < Œµ } := by rfl\n\n"}
{"name":"PseudoEMetricSpace.edist_triangle","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\nself : PseudoEMetricSpace Œ±\nx y z : Œ±\n‚ä¢ LE.le (EDist.edist x z) (HAdd.hAdd (EDist.edist x y) (EDist.edist y z))","decl":"/-- Extended (pseudo) metric spaces, with an extended distance `edist` possibly taking the\nvalue ‚àû\n\nEach pseudo_emetric space induces a canonical `UniformSpace` and hence a canonical\n`TopologicalSpace`.\nThis is enforced in the type class definition, by extending the `UniformSpace` structure. When\ninstantiating a `PseudoEMetricSpace` structure, the uniformity fields are not necessary, they\nwill be filled in by default. There is a default value for the uniformity, that can be substituted\nin cases of interest, for instance when instantiating a `PseudoEMetricSpace` structure\non a product.\n\nContinuity of `edist` is proved in `Topology.Instances.ENNReal`\n-/\nclass PseudoEMetricSpace (Œ± : Type u) extends EDist Œ± : Type u where\n  edist_self : ‚àÄ x : Œ±, edist x x = 0\n  edist_comm : ‚àÄ x y : Œ±, edist x y = edist y x\n  edist_triangle : ‚àÄ x y z : Œ±, edist x z ‚â§ edist x y + edist y z\n  toUniformSpace : UniformSpace Œ± := uniformSpaceOfEDist edist edist_self edist_comm edist_triangle\n  uniformity_edist : ùì§ Œ± = ‚®Ö Œµ > 0, ùìü { p : Œ± √ó Œ± | edist p.1 p.2 < Œµ } := by rfl\n\n"}
{"name":"PseudoEMetricSpace.edist_self","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\nself : PseudoEMetricSpace Œ±\nx : Œ±\n‚ä¢ Eq (EDist.edist x x) 0","decl":"/-- Extended (pseudo) metric spaces, with an extended distance `edist` possibly taking the\nvalue ‚àû\n\nEach pseudo_emetric space induces a canonical `UniformSpace` and hence a canonical\n`TopologicalSpace`.\nThis is enforced in the type class definition, by extending the `UniformSpace` structure. When\ninstantiating a `PseudoEMetricSpace` structure, the uniformity fields are not necessary, they\nwill be filled in by default. There is a default value for the uniformity, that can be substituted\nin cases of interest, for instance when instantiating a `PseudoEMetricSpace` structure\non a product.\n\nContinuity of `edist` is proved in `Topology.Instances.ENNReal`\n-/\nclass PseudoEMetricSpace (Œ± : Type u) extends EDist Œ± : Type u where\n  edist_self : ‚àÄ x : Œ±, edist x x = 0\n  edist_comm : ‚àÄ x y : Œ±, edist x y = edist y x\n  edist_triangle : ‚àÄ x y z : Œ±, edist x z ‚â§ edist x y + edist y z\n  toUniformSpace : UniformSpace Œ± := uniformSpaceOfEDist edist edist_self edist_comm edist_triangle\n  uniformity_edist : ùì§ Œ± = ‚®Ö Œµ > 0, ùìü { p : Œ± √ó Œ± | edist p.1 p.2 < Œµ } := by rfl\n\n"}
{"name":"PseudoEMetricSpace.ext_iff","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u_2\nm m' : PseudoEMetricSpace Œ±\n‚ä¢ Iff (Eq m m') (Eq PseudoEMetricSpace.toEDist PseudoEMetricSpace.toEDist)","decl":"/-- Two pseudo emetric space structures with the same edistance function coincide. -/\n@[ext]\nprotected theorem PseudoEMetricSpace.ext {Œ± : Type*} {m m' : PseudoEMetricSpace Œ±}\n    (h : m.toEDist = m'.toEDist) : m = m' := by\n  cases' m with ed  _ _ _ U hU\n  cases' m' with ed' _ _ _ U' hU'\n  congr 1\n  exact UniformSpace.ext (((show ed = ed' from h) ‚ñ∏ hU).trans hU'.symm)\n\n"}
{"name":"PseudoEMetricSpace.ext","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u_2\nm m' : PseudoEMetricSpace Œ±\nh : Eq PseudoEMetricSpace.toEDist PseudoEMetricSpace.toEDist\n‚ä¢ Eq m m'","decl":"/-- Two pseudo emetric space structures with the same edistance function coincide. -/\n@[ext]\nprotected theorem PseudoEMetricSpace.ext {Œ± : Type*} {m m' : PseudoEMetricSpace Œ±}\n    (h : m.toEDist = m'.toEDist) : m = m' := by\n  cases' m with ed  _ _ _ U hU\n  cases' m' with ed' _ _ _ U' hU'\n  congr 1\n  exact UniformSpace.ext (((show ed = ed' from h) ‚ñ∏ hU).trans hU'.symm)\n\n"}
{"name":"edist_triangle_left","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y z : Œ±\n‚ä¢ LE.le (EDist.edist x y) (HAdd.hAdd (EDist.edist z x) (EDist.edist z y))","decl":"/-- Triangle inequality for the extended distance -/\ntheorem edist_triangle_left (x y z : Œ±) : edist x y ‚â§ edist z x + edist z y := by\n  rw [edist_comm z]; apply edist_triangle\n\n"}
{"name":"edist_triangle_right","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y z : Œ±\n‚ä¢ LE.le (EDist.edist x y) (HAdd.hAdd (EDist.edist x z) (EDist.edist y z))","decl":"theorem edist_triangle_right (x y z : Œ±) : edist x y ‚â§ edist x z + edist y z := by\n  rw [edist_comm y]; apply edist_triangle\n\n"}
{"name":"edist_congr_right","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y z : Œ±\nh : Eq (EDist.edist x y) 0\n‚ä¢ Eq (EDist.edist x z) (EDist.edist y z)","decl":"theorem edist_congr_right {x y z : Œ±} (h : edist x y = 0) : edist x z = edist y z := by\n  apply le_antisymm\n  ¬∑ rw [‚Üê zero_add (edist y z), ‚Üê h]\n    apply edist_triangle\n  ¬∑ rw [edist_comm] at h\n    rw [‚Üê zero_add (edist x z), ‚Üê h]\n    apply edist_triangle\n\n"}
{"name":"edist_congr_left","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y z : Œ±\nh : Eq (EDist.edist x y) 0\n‚ä¢ Eq (EDist.edist z x) (EDist.edist z y)","decl":"theorem edist_congr_left {x y z : Œ±} (h : edist x y = 0) : edist z x = edist z y := by\n  rw [edist_comm z x, edist_comm z y]\n  apply edist_congr_right h\n\n-- new theorem\n"}
{"name":"edist_congr","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nw x y z : Œ±\nhl : Eq (EDist.edist w x) 0\nhr : Eq (EDist.edist y z) 0\n‚ä¢ Eq (EDist.edist w y) (EDist.edist x z)","decl":"theorem edist_congr {w x y z : Œ±} (hl : edist w x = 0) (hr : edist y z = 0) :\n    edist w y = edist x z :=\n  (edist_congr_right hl).trans (edist_congr_left hr)\n\n"}
{"name":"edist_triangle4","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y z t : Œ±\n‚ä¢ LE.le (EDist.edist x t) (HAdd.hAdd (HAdd.hAdd (EDist.edist x y) (EDist.edist y z)) (EDist.edist z t))","decl":"theorem edist_triangle4 (x y z t : Œ±) : edist x t ‚â§ edist x y + edist y z + edist z t :=\n  calc\n    edist x t ‚â§ edist x z + edist z t := edist_triangle x z t\n    _ ‚â§ edist x y + edist y z + edist z t := add_le_add_right (edist_triangle x y z) _\n\n"}
{"name":"uniformity_pseudoedist","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\n‚ä¢ Eq (uniformity Œ±) (iInf fun Œµ => iInf fun h => Filter.principal (setOf fun p => LT.lt (EDist.edist p.1 p.2) Œµ))","decl":"/-- Reformulation of the uniform structure in terms of the extended distance -/\ntheorem uniformity_pseudoedist : ùì§ Œ± = ‚®Ö Œµ > 0, ùìü { p : Œ± √ó Œ± | edist p.1 p.2 < Œµ } :=\n  PseudoEMetricSpace.uniformity_edist\n\n"}
{"name":"uniformSpace_edist","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\n‚ä¢ Eq PseudoEMetricSpace.toUniformSpace (uniformSpaceOfEDist EDist.edist ‚ãØ ‚ãØ ‚ãØ)","decl":"theorem uniformSpace_edist :\n    ‚ÄπPseudoEMetricSpace Œ±‚Ä∫.toUniformSpace =\n      uniformSpaceOfEDist edist edist_self edist_comm edist_triangle :=\n  UniformSpace.ext uniformity_pseudoedist\n\n"}
{"name":"uniformity_basis_edist","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\n‚ä¢ (uniformity Œ±).HasBasis (fun Œµ => LT.lt 0 Œµ) fun Œµ => setOf fun p => LT.lt (EDist.edist p.1 p.2) Œµ","decl":"theorem uniformity_basis_edist :\n    (ùì§ Œ±).HasBasis (fun Œµ : ‚Ñù‚â•0‚àû => 0 < Œµ) fun Œµ => { p : Œ± √ó Œ± | edist p.1 p.2 < Œµ } :=\n  (@uniformSpace_edist Œ± _).symm ‚ñ∏ UniformSpace.hasBasis_ofFun ‚ü®1, one_pos‚ü© _ _ _ _ _\n\n"}
{"name":"mem_uniformity_edist","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\ns : Set (Prod Œ± Œ±)\n‚ä¢ Iff (Membership.mem (uniformity Œ±) s) (Exists fun Œµ => And (GT.gt Œµ 0) (‚àÄ {a b : Œ±}, LT.lt (EDist.edist a b) Œµ ‚Üí Membership.mem s { fst := a, snd := b }))","decl":"/-- Characterization of the elements of the uniformity in terms of the extended distance -/\ntheorem mem_uniformity_edist {s : Set (Œ± √ó Œ±)} :\n    s ‚àà ùì§ Œ± ‚Üî ‚àÉ Œµ > 0, ‚àÄ {a b : Œ±}, edist a b < Œµ ‚Üí (a, b) ‚àà s :=\n  uniformity_basis_edist.mem_uniformity_iff\n\n"}
{"name":"EMetric.mk_uniformity_basis","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nŒ≤ : Type u_2\np : Œ≤ ‚Üí Prop\nf : Œ≤ ‚Üí ENNReal\nhf‚ÇÄ : ‚àÄ (x : Œ≤), p x ‚Üí LT.lt 0 (f x)\nhf : ‚àÄ (Œµ : ENNReal), LT.lt 0 Œµ ‚Üí Exists fun x => And (p x) (LE.le (f x) Œµ)\n‚ä¢ (uniformity Œ±).HasBasis p fun x => setOf fun p => LT.lt (EDist.edist p.1 p.2) (f x)","decl":"/-- Given `f : Œ≤ ‚Üí ‚Ñù‚â•0‚àû`, if `f` sends `{i | p i}` to a set of positive numbers\naccumulating to zero, then `f i`-neighborhoods of the diagonal form a basis of `ùì§ Œ±`.\n\nFor specific bases see `uniformity_basis_edist`, `uniformity_basis_edist'`,\n`uniformity_basis_edist_nnreal`, and `uniformity_basis_edist_inv_nat`. -/\nprotected theorem EMetric.mk_uniformity_basis {Œ≤ : Type*} {p : Œ≤ ‚Üí Prop} {f : Œ≤ ‚Üí ‚Ñù‚â•0‚àû}\n    (hf‚ÇÄ : ‚àÄ x, p x ‚Üí 0 < f x) (hf : ‚àÄ Œµ, 0 < Œµ ‚Üí ‚àÉ x, p x ‚àß f x ‚â§ Œµ) :\n    (ùì§ Œ±).HasBasis p fun x => { p : Œ± √ó Œ± | edist p.1 p.2 < f x } := by\n  refine ‚ü®fun s => uniformity_basis_edist.mem_iff.trans ?_‚ü©\n  constructor\n  ¬∑ rintro ‚ü®Œµ, Œµ‚ÇÄ, hŒµ‚ü©\n    rcases hf Œµ Œµ‚ÇÄ with ‚ü®i, hi, H‚ü©\n    exact ‚ü®i, hi, fun x hx => hŒµ <| lt_of_lt_of_le hx.out H‚ü©\n  ¬∑ exact fun ‚ü®i, hi, H‚ü© => ‚ü®f i, hf‚ÇÄ i hi, H‚ü©\n\n"}
{"name":"EMetric.mk_uniformity_basis_le","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nŒ≤ : Type u_2\np : Œ≤ ‚Üí Prop\nf : Œ≤ ‚Üí ENNReal\nhf‚ÇÄ : ‚àÄ (x : Œ≤), p x ‚Üí LT.lt 0 (f x)\nhf : ‚àÄ (Œµ : ENNReal), LT.lt 0 Œµ ‚Üí Exists fun x => And (p x) (LE.le (f x) Œµ)\n‚ä¢ (uniformity Œ±).HasBasis p fun x => setOf fun p => LE.le (EDist.edist p.1 p.2) (f x)","decl":"/-- Given `f : Œ≤ ‚Üí ‚Ñù‚â•0‚àû`, if `f` sends `{i | p i}` to a set of positive numbers\naccumulating to zero, then closed `f i`-neighborhoods of the diagonal form a basis of `ùì§ Œ±`.\n\nFor specific bases see `uniformity_basis_edist_le` and `uniformity_basis_edist_le'`. -/\nprotected theorem EMetric.mk_uniformity_basis_le {Œ≤ : Type*} {p : Œ≤ ‚Üí Prop} {f : Œ≤ ‚Üí ‚Ñù‚â•0‚àû}\n    (hf‚ÇÄ : ‚àÄ x, p x ‚Üí 0 < f x) (hf : ‚àÄ Œµ, 0 < Œµ ‚Üí ‚àÉ x, p x ‚àß f x ‚â§ Œµ) :\n    (ùì§ Œ±).HasBasis p fun x => { p : Œ± √ó Œ± | edist p.1 p.2 ‚â§ f x } := by\n  refine ‚ü®fun s => uniformity_basis_edist.mem_iff.trans ?_‚ü©\n  constructor\n  ¬∑ rintro ‚ü®Œµ, Œµ‚ÇÄ, hŒµ‚ü©\n    rcases exists_between Œµ‚ÇÄ with ‚ü®Œµ', hŒµ'‚ü©\n    rcases hf Œµ' hŒµ'.1 with ‚ü®i, hi, H‚ü©\n    exact ‚ü®i, hi, fun x hx => hŒµ <| lt_of_le_of_lt (le_trans hx.out H) hŒµ'.2‚ü©\n  ¬∑ exact fun ‚ü®i, hi, H‚ü© => ‚ü®f i, hf‚ÇÄ i hi, fun x hx => H (le_of_lt hx.out)‚ü©\n\n"}
{"name":"uniformity_basis_edist_le","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\n‚ä¢ (uniformity Œ±).HasBasis (fun Œµ => LT.lt 0 Œµ) fun Œµ => setOf fun p => LE.le (EDist.edist p.1 p.2) Œµ","decl":"theorem uniformity_basis_edist_le :\n    (ùì§ Œ±).HasBasis (fun Œµ : ‚Ñù‚â•0‚àû => 0 < Œµ) fun Œµ => { p : Œ± √ó Œ± | edist p.1 p.2 ‚â§ Œµ } :=\n  EMetric.mk_uniformity_basis_le (fun _ => id) fun Œµ Œµ‚ÇÄ => ‚ü®Œµ, Œµ‚ÇÄ, le_refl Œµ‚ü©\n\n"}
{"name":"uniformity_basis_edist'","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nŒµ' : ENNReal\nhŒµ' : LT.lt 0 Œµ'\n‚ä¢ (uniformity Œ±).HasBasis (fun Œµ => Membership.mem (Set.Ioo 0 Œµ') Œµ) fun Œµ => setOf fun p => LT.lt (EDist.edist p.1 p.2) Œµ","decl":"theorem uniformity_basis_edist' (Œµ' : ‚Ñù‚â•0‚àû) (hŒµ' : 0 < Œµ') :\n    (ùì§ Œ±).HasBasis (fun Œµ : ‚Ñù‚â•0‚àû => Œµ ‚àà Ioo 0 Œµ') fun Œµ => { p : Œ± √ó Œ± | edist p.1 p.2 < Œµ } :=\n  EMetric.mk_uniformity_basis (fun _ => And.left) fun Œµ Œµ‚ÇÄ =>\n    let ‚ü®Œ¥, hŒ¥‚ü© := exists_between hŒµ'\n    ‚ü®min Œµ Œ¥, ‚ü®lt_min Œµ‚ÇÄ hŒ¥.1, lt_of_le_of_lt (min_le_right _ _) hŒ¥.2‚ü©, min_le_left _ _‚ü©\n\n"}
{"name":"uniformity_basis_edist_le'","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nŒµ' : ENNReal\nhŒµ' : LT.lt 0 Œµ'\n‚ä¢ (uniformity Œ±).HasBasis (fun Œµ => Membership.mem (Set.Ioo 0 Œµ') Œµ) fun Œµ => setOf fun p => LE.le (EDist.edist p.1 p.2) Œµ","decl":"theorem uniformity_basis_edist_le' (Œµ' : ‚Ñù‚â•0‚àû) (hŒµ' : 0 < Œµ') :\n    (ùì§ Œ±).HasBasis (fun Œµ : ‚Ñù‚â•0‚àû => Œµ ‚àà Ioo 0 Œµ') fun Œµ => { p : Œ± √ó Œ± | edist p.1 p.2 ‚â§ Œµ } :=\n  EMetric.mk_uniformity_basis_le (fun _ => And.left) fun Œµ Œµ‚ÇÄ =>\n    let ‚ü®Œ¥, hŒ¥‚ü© := exists_between hŒµ'\n    ‚ü®min Œµ Œ¥, ‚ü®lt_min Œµ‚ÇÄ hŒ¥.1, lt_of_le_of_lt (min_le_right _ _) hŒ¥.2‚ü©, min_le_left _ _‚ü©\n\n"}
{"name":"uniformity_basis_edist_nnreal","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\n‚ä¢ (uniformity Œ±).HasBasis (fun Œµ => LT.lt 0 Œµ) fun Œµ => setOf fun p => LT.lt (EDist.edist p.1 p.2) ‚ÜëŒµ","decl":"theorem uniformity_basis_edist_nnreal :\n    (ùì§ Œ±).HasBasis (fun Œµ : ‚Ñù‚â•0 => 0 < Œµ) fun Œµ => { p : Œ± √ó Œ± | edist p.1 p.2 < Œµ } :=\n  EMetric.mk_uniformity_basis (fun _ => ENNReal.coe_pos.2) fun _Œµ Œµ‚ÇÄ =>\n    let ‚ü®Œ¥, hŒ¥‚ü© := ENNReal.lt_iff_exists_nnreal_btwn.1 Œµ‚ÇÄ\n    ‚ü®Œ¥, ENNReal.coe_pos.1 hŒ¥.1, le_of_lt hŒ¥.2‚ü©\n\n"}
{"name":"uniformity_basis_edist_nnreal_le","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\n‚ä¢ (uniformity Œ±).HasBasis (fun Œµ => LT.lt 0 Œµ) fun Œµ => setOf fun p => LE.le (EDist.edist p.1 p.2) ‚ÜëŒµ","decl":"theorem uniformity_basis_edist_nnreal_le :\n    (ùì§ Œ±).HasBasis (fun Œµ : ‚Ñù‚â•0 => 0 < Œµ) fun Œµ => { p : Œ± √ó Œ± | edist p.1 p.2 ‚â§ Œµ } :=\n  EMetric.mk_uniformity_basis_le (fun _ => ENNReal.coe_pos.2) fun _Œµ Œµ‚ÇÄ =>\n    let ‚ü®Œ¥, hŒ¥‚ü© := ENNReal.lt_iff_exists_nnreal_btwn.1 Œµ‚ÇÄ\n    ‚ü®Œ¥, ENNReal.coe_pos.1 hŒ¥.1, le_of_lt hŒ¥.2‚ü©\n\n"}
{"name":"uniformity_basis_edist_inv_nat","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\n‚ä¢ (uniformity Œ±).HasBasis (fun x => True) fun n => setOf fun p => LT.lt (EDist.edist p.1 p.2) (Inv.inv ‚Üën)","decl":"theorem uniformity_basis_edist_inv_nat :\n    (ùì§ Œ±).HasBasis (fun _ => True) fun n : ‚Ñï => { p : Œ± √ó Œ± | edist p.1 p.2 < (‚Üën)‚Åª¬π } :=\n  EMetric.mk_uniformity_basis (fun n _ ‚Ü¶ ENNReal.inv_pos.2 <| ENNReal.natCast_ne_top n) fun _Œµ Œµ‚ÇÄ ‚Ü¶\n    let ‚ü®n, hn‚ü© := ENNReal.exists_inv_nat_lt (ne_of_gt Œµ‚ÇÄ)\n    ‚ü®n, trivial, le_of_lt hn‚ü©\n\n"}
{"name":"uniformity_basis_edist_inv_two_pow","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\n‚ä¢ (uniformity Œ±).HasBasis (fun x => True) fun n => setOf fun p => LT.lt (EDist.edist p.1 p.2) (HPow.hPow (Inv.inv 2) n)","decl":"theorem uniformity_basis_edist_inv_two_pow :\n    (ùì§ Œ±).HasBasis (fun _ => True) fun n : ‚Ñï => { p : Œ± √ó Œ± | edist p.1 p.2 < 2‚Åª¬π ^ n } :=\n  EMetric.mk_uniformity_basis (fun _ _ ‚Ü¶ ENNReal.pow_pos (ENNReal.inv_pos.2 ENNReal.ofNat_ne_top) _)\n    fun _Œµ Œµ‚ÇÄ ‚Ü¶\n    let ‚ü®n, hn‚ü© := ENNReal.exists_inv_two_pow_lt (ne_of_gt Œµ‚ÇÄ)\n    ‚ü®n, trivial, le_of_lt hn‚ü©\n\n"}
{"name":"edist_mem_uniformity","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nŒµ : ENNReal\nŒµ0 : LT.lt 0 Œµ\n‚ä¢ Membership.mem (uniformity Œ±) (setOf fun p => LT.lt (EDist.edist p.1 p.2) Œµ)","decl":"/-- Fixed size neighborhoods of the diagonal belong to the uniform structure -/\ntheorem edist_mem_uniformity {Œµ : ‚Ñù‚â•0‚àû} (Œµ0 : 0 < Œµ) : { p : Œ± √ó Œ± | edist p.1 p.2 < Œµ } ‚àà ùì§ Œ± :=\n  mem_uniformity_edist.2 ‚ü®Œµ, Œµ0, id‚ü©\n\n"}
{"name":"EMetric.instIsCountablyGeneratedUniformity","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\n‚ä¢ (uniformity Œ±).IsCountablyGenerated","decl":"instance (priority := 900) instIsCountablyGeneratedUniformity : IsCountablyGenerated (ùì§ Œ±) :=\n  isCountablyGenerated_of_seq ‚ü®_, uniformity_basis_edist_inv_nat.eq_iInf‚ü©\n\n-- Porting note: changed explicit/implicit\n"}
{"name":"EMetric.uniformContinuousOn_iff","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\n‚ä¢ Iff (UniformContinuousOn f s) (‚àÄ (Œµ : ENNReal), GT.gt Œµ 0 ‚Üí Exists fun Œ¥ => And (GT.gt Œ¥ 0) (‚àÄ {a : Œ±}, Membership.mem s a ‚Üí ‚àÄ {b : Œ±}, Membership.mem s b ‚Üí LT.lt (EDist.edist a b) Œ¥ ‚Üí LT.lt (EDist.edist (f a) (f b)) Œµ))","decl":"/-- Œµ-Œ¥ characterization of uniform continuity on a set for pseudoemetric spaces -/\ntheorem uniformContinuousOn_iff [PseudoEMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±} :\n    UniformContinuousOn f s ‚Üî\n      ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ {a}, a ‚àà s ‚Üí ‚àÄ {b}, b ‚àà s ‚Üí edist a b < Œ¥ ‚Üí edist (f a) (f b) < Œµ :=\n  uniformity_basis_edist.uniformContinuousOn_iff uniformity_basis_edist\n\n"}
{"name":"EMetric.uniformContinuous_iff","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (UniformContinuous f) (‚àÄ (Œµ : ENNReal), GT.gt Œµ 0 ‚Üí Exists fun Œ¥ => And (GT.gt Œ¥ 0) (‚àÄ {a b : Œ±}, LT.lt (EDist.edist a b) Œ¥ ‚Üí LT.lt (EDist.edist (f a) (f b)) Œµ))","decl":"/-- Œµ-Œ¥ characterization of uniform continuity on pseudoemetric spaces -/\ntheorem uniformContinuous_iff [PseudoEMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} :\n    UniformContinuous f ‚Üî ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ {a b : Œ±}, edist a b < Œ¥ ‚Üí edist (f a) (f b) < Œµ :=\n  uniformity_basis_edist.uniformContinuous_iff uniformity_basis_edist\n\n"}
{"name":"Subtype.edist_eq","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\np : Œ± ‚Üí Prop\nx y : Subtype p\n‚ä¢ Eq (EDist.edist x y) (EDist.edist ‚Üëx ‚Üëy)","decl":"/-- The extended pseudodistance on a subset of a pseudoemetric space is the restriction of\nthe original pseudodistance, by definition. -/\ntheorem Subtype.edist_eq {p : Œ± ‚Üí Prop} (x y : Subtype p) : edist x y = edist (x : Œ±) y := rfl\n\n"}
{"name":"Subtype.edist_mk_mk","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\np : Œ± ‚Üí Prop\nx y : Œ±\nhx : p x\nhy : p y\n‚ä¢ Eq (EDist.edist ‚ü®x, hx‚ü© ‚ü®y, hy‚ü©) (EDist.edist x y)","decl":"/-- The extended pseudodistance on a subtype of a pseudoemetric space is the restriction of\nthe original pseudodistance, by definition. -/\n@[simp]\ntheorem Subtype.edist_mk_mk {p : Œ± ‚Üí Prop} {x y : Œ±} (hx : p x) (hy : p y) :\n    edist (‚ü®x, hx‚ü© : Subtype p) ‚ü®y, hy‚ü© = edist x y :=\n  rfl\n\n"}
{"name":"AddOpposite.edist_unop","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y : AddOpposite Œ±\n‚ä¢ Eq (EDist.edist (AddOpposite.unop x) (AddOpposite.unop y)) (EDist.edist x y)","decl":"@[to_additive]\ntheorem edist_unop (x y : Œ±·µê·µí·µñ) : edist (unop x) (unop y) = edist x y := rfl\n\n"}
{"name":"MulOpposite.edist_unop","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y : MulOpposite Œ±\n‚ä¢ Eq (EDist.edist (MulOpposite.unop x) (MulOpposite.unop y)) (EDist.edist x y)","decl":"@[to_additive]\ntheorem edist_unop (x y : Œ±·µê·µí·µñ) : edist (unop x) (unop y) = edist x y := rfl\n\n"}
{"name":"MulOpposite.edist_op","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y : Œ±\n‚ä¢ Eq (EDist.edist (MulOpposite.op x) (MulOpposite.op y)) (EDist.edist x y)","decl":"@[to_additive]\ntheorem edist_op (x y : Œ±) : edist (op x) (op y) = edist x y := rfl\n\n"}
{"name":"AddOpposite.edist_op","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y : Œ±\n‚ä¢ Eq (EDist.edist (AddOpposite.op x) (AddOpposite.op y)) (EDist.edist x y)","decl":"@[to_additive]\ntheorem edist_op (x y : Œ±) : edist (op x) (op y) = edist x y := rfl\n\n"}
{"name":"ULift.edist_eq","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y : ULift.{u_2, u} Œ±\n‚ä¢ Eq (EDist.edist x y) (EDist.edist x.down y.down)","decl":"theorem ULift.edist_eq (x y : ULift Œ±) : edist x y = edist x.down y.down := rfl\n\n"}
{"name":"ULift.edist_up_up","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y : Œ±\n‚ä¢ Eq (EDist.edist { down := x } { down := y }) (EDist.edist x y)","decl":"@[simp]\ntheorem ULift.edist_up_up (x y : Œ±) : edist (ULift.up x) (ULift.up y) = edist x y := rfl\n\n"}
{"name":"Prod.edist_eq","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nx y : Prod Œ± Œ≤\n‚ä¢ Eq (EDist.edist x y) (Max.max (EDist.edist x.1 y.1) (EDist.edist x.2 y.2))","decl":"theorem Prod.edist_eq [PseudoEMetricSpace Œ≤] (x y : Œ± √ó Œ≤) :\n    edist x y = max (edist x.1 y.1) (edist x.2 y.2) :=\n  rfl\n\n"}
{"name":"EMetric.mem_ball","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y : Œ±\nŒµ : ENNReal\n‚ä¢ Iff (Membership.mem (EMetric.ball x Œµ) y) (LT.lt (EDist.edist y x) Œµ)","decl":"@[simp] theorem mem_ball : y ‚àà ball x Œµ ‚Üî edist y x < Œµ := Iff.rfl\n\n"}
{"name":"EMetric.mem_ball'","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y : Œ±\nŒµ : ENNReal\n‚ä¢ Iff (Membership.mem (EMetric.ball x Œµ) y) (LT.lt (EDist.edist x y) Œµ)","decl":"theorem mem_ball' : y ‚àà ball x Œµ ‚Üî edist x y < Œµ := by rw [edist_comm, mem_ball]\n\n"}
{"name":"EMetric.mem_closedBall","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y : Œ±\nŒµ : ENNReal\n‚ä¢ Iff (Membership.mem (EMetric.closedBall x Œµ) y) (LE.le (EDist.edist y x) Œµ)","decl":"@[simp] theorem mem_closedBall : y ‚àà closedBall x Œµ ‚Üî edist y x ‚â§ Œµ := Iff.rfl\n\n"}
{"name":"EMetric.mem_closedBall'","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y : Œ±\nŒµ : ENNReal\n‚ä¢ Iff (Membership.mem (EMetric.closedBall x Œµ) y) (LE.le (EDist.edist x y) Œµ)","decl":"theorem mem_closedBall' : y ‚àà closedBall x Œµ ‚Üî edist x y ‚â§ Œµ := by rw [edist_comm, mem_closedBall]\n\n"}
{"name":"EMetric.closedBall_top","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\n‚ä¢ Eq (EMetric.closedBall x Top.top) Set.univ","decl":"@[simp]\ntheorem closedBall_top (x : Œ±) : closedBall x ‚àû = univ :=\n  eq_univ_of_forall fun _ => mem_setOf.2 le_top\n\n"}
{"name":"EMetric.ball_subset_closedBall","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\nŒµ : ENNReal\n‚ä¢ HasSubset.Subset (EMetric.ball x Œµ) (EMetric.closedBall x Œµ)","decl":"theorem ball_subset_closedBall : ball x Œµ ‚äÜ closedBall x Œµ := fun _ h => le_of_lt h.out\n\n"}
{"name":"EMetric.pos_of_mem_ball","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y : Œ±\nŒµ : ENNReal\nhy : Membership.mem (EMetric.ball x Œµ) y\n‚ä¢ LT.lt 0 Œµ","decl":"theorem pos_of_mem_ball (hy : y ‚àà ball x Œµ) : 0 < Œµ :=\n  lt_of_le_of_lt (zero_le _) hy\n\n"}
{"name":"EMetric.mem_ball_self","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\nŒµ : ENNReal\nh : LT.lt 0 Œµ\n‚ä¢ Membership.mem (EMetric.ball x Œµ) x","decl":"theorem mem_ball_self (h : 0 < Œµ) : x ‚àà ball x Œµ := by\n  rwa [mem_ball, edist_self]\n\n"}
{"name":"EMetric.mem_closedBall_self","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\nŒµ : ENNReal\n‚ä¢ Membership.mem (EMetric.closedBall x Œµ) x","decl":"theorem mem_closedBall_self : x ‚àà closedBall x Œµ := by\n  rw [mem_closedBall, edist_self]; apply zero_le\n\n"}
{"name":"EMetric.mem_ball_comm","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y : Œ±\nŒµ : ENNReal\n‚ä¢ Iff (Membership.mem (EMetric.ball y Œµ) x) (Membership.mem (EMetric.ball x Œµ) y)","decl":"theorem mem_ball_comm : x ‚àà ball y Œµ ‚Üî y ‚àà ball x Œµ := by rw [mem_ball', mem_ball]\n\n"}
{"name":"EMetric.mem_closedBall_comm","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y : Œ±\nŒµ : ENNReal\n‚ä¢ Iff (Membership.mem (EMetric.closedBall y Œµ) x) (Membership.mem (EMetric.closedBall x Œµ) y)","decl":"theorem mem_closedBall_comm : x ‚àà closedBall y Œµ ‚Üî y ‚àà closedBall x Œµ := by\n  rw [mem_closedBall', mem_closedBall]\n\n"}
{"name":"EMetric.ball_subset_ball","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\nŒµ‚ÇÅ Œµ‚ÇÇ : ENNReal\nh : LE.le Œµ‚ÇÅ Œµ‚ÇÇ\n‚ä¢ HasSubset.Subset (EMetric.ball x Œµ‚ÇÅ) (EMetric.ball x Œµ‚ÇÇ)","decl":"@[gcongr]\ntheorem ball_subset_ball (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) : ball x Œµ‚ÇÅ ‚äÜ ball x Œµ‚ÇÇ := fun _y (yx : _ < Œµ‚ÇÅ) =>\n  lt_of_lt_of_le yx h\n\n"}
{"name":"EMetric.closedBall_subset_closedBall","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\nŒµ‚ÇÅ Œµ‚ÇÇ : ENNReal\nh : LE.le Œµ‚ÇÅ Œµ‚ÇÇ\n‚ä¢ HasSubset.Subset (EMetric.closedBall x Œµ‚ÇÅ) (EMetric.closedBall x Œµ‚ÇÇ)","decl":"@[gcongr]\ntheorem closedBall_subset_closedBall (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) : closedBall x Œµ‚ÇÅ ‚äÜ closedBall x Œµ‚ÇÇ :=\n  fun _y (yx : _ ‚â§ Œµ‚ÇÅ) => le_trans yx h\n\n"}
{"name":"EMetric.ball_disjoint","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y : Œ±\nŒµ‚ÇÅ Œµ‚ÇÇ : ENNReal\nh : LE.le (HAdd.hAdd Œµ‚ÇÅ Œµ‚ÇÇ) (EDist.edist x y)\n‚ä¢ Disjoint (EMetric.ball x Œµ‚ÇÅ) (EMetric.ball y Œµ‚ÇÇ)","decl":"theorem ball_disjoint (h : Œµ‚ÇÅ + Œµ‚ÇÇ ‚â§ edist x y) : Disjoint (ball x Œµ‚ÇÅ) (ball y Œµ‚ÇÇ) :=\n  Set.disjoint_left.mpr fun z h‚ÇÅ h‚ÇÇ =>\n    (edist_triangle_left x y z).not_lt <| (ENNReal.add_lt_add h‚ÇÅ h‚ÇÇ).trans_le h\n\n"}
{"name":"EMetric.ball_subset","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y : Œ±\nŒµ‚ÇÅ Œµ‚ÇÇ : ENNReal\nh : LE.le (HAdd.hAdd (EDist.edist x y) Œµ‚ÇÅ) Œµ‚ÇÇ\nh' : Ne (EDist.edist x y) Top.top\n‚ä¢ HasSubset.Subset (EMetric.ball x Œµ‚ÇÅ) (EMetric.ball y Œµ‚ÇÇ)","decl":"theorem ball_subset (h : edist x y + Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) (h' : edist x y ‚â† ‚àû) : ball x Œµ‚ÇÅ ‚äÜ ball y Œµ‚ÇÇ :=\n  fun z zx =>\n  calc\n    edist z y ‚â§ edist z x + edist x y := edist_triangle _ _ _\n    _ = edist x y + edist z x := add_comm _ _\n    _ < edist x y + Œµ‚ÇÅ := ENNReal.add_lt_add_left h' zx\n    _ ‚â§ Œµ‚ÇÇ := h\n\n"}
{"name":"EMetric.exists_ball_subset_ball","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y : Œ±\nŒµ : ENNReal\nh : Membership.mem (EMetric.ball x Œµ) y\n‚ä¢ Exists fun Œµ' => And (GT.gt Œµ' 0) (HasSubset.Subset (EMetric.ball y Œµ') (EMetric.ball x Œµ))","decl":"theorem exists_ball_subset_ball (h : y ‚àà ball x Œµ) : ‚àÉ Œµ' > 0, ball y Œµ' ‚äÜ ball x Œµ := by\n  have : 0 < Œµ - edist y x := by simpa using h\n  refine ‚ü®Œµ - edist y x, this, ball_subset ?_ (ne_top_of_lt h)‚ü©\n  exact (add_tsub_cancel_of_le (mem_ball.mp h).le).le\n\n"}
{"name":"EMetric.ball_eq_empty_iff","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\nŒµ : ENNReal\n‚ä¢ Iff (Eq (EMetric.ball x Œµ) EmptyCollection.emptyCollection) (Eq Œµ 0)","decl":"theorem ball_eq_empty_iff : ball x Œµ = ‚àÖ ‚Üî Œµ = 0 :=\n  eq_empty_iff_forall_not_mem.trans\n    ‚ü®fun h => le_bot_iff.1 (le_of_not_gt fun Œµ0 => h _ (mem_ball_self Œµ0)), fun Œµ0 _ h =>\n      not_lt_of_le (le_of_eq Œµ0) (pos_of_mem_ball h)‚ü©\n\n"}
{"name":"EMetric.ordConnected_setOf_closedBall_subset","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\ns : Set Œ±\n‚ä¢ (setOf fun r => HasSubset.Subset (EMetric.closedBall x r) s).OrdConnected","decl":"theorem ordConnected_setOf_closedBall_subset (x : Œ±) (s : Set Œ±) :\n    OrdConnected { r | closedBall x r ‚äÜ s } :=\n  ‚ü®fun _ _ _ h‚ÇÅ _ h‚ÇÇ => (closedBall_subset_closedBall h‚ÇÇ.2).trans h‚ÇÅ‚ü©\n\n"}
{"name":"EMetric.ordConnected_setOf_ball_subset","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\ns : Set Œ±\n‚ä¢ (setOf fun r => HasSubset.Subset (EMetric.ball x r) s).OrdConnected","decl":"theorem ordConnected_setOf_ball_subset (x : Œ±) (s : Set Œ±) : OrdConnected { r | ball x r ‚äÜ s } :=\n  ‚ü®fun _ _ _ h‚ÇÅ _ h‚ÇÇ => (ball_subset_ball h‚ÇÇ.2).trans h‚ÇÅ‚ü©\n\n"}
{"name":"EMetric.ball_zero","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\n‚ä¢ Eq (EMetric.ball x 0) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem ball_zero : ball x 0 = ‚àÖ := by rw [EMetric.ball_eq_empty_iff]\n\n"}
{"name":"EMetric.nhds_basis_eball","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\n‚ä¢ (nhds x).HasBasis (fun Œµ => LT.lt 0 Œµ) (EMetric.ball x)","decl":"theorem nhds_basis_eball : (ùìù x).HasBasis (fun Œµ : ‚Ñù‚â•0‚àû => 0 < Œµ) (ball x) :=\n  nhds_basis_uniformity uniformity_basis_edist\n\n"}
{"name":"EMetric.nhdsWithin_basis_eball","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\ns : Set Œ±\n‚ä¢ (nhdsWithin x s).HasBasis (fun Œµ => LT.lt 0 Œµ) fun Œµ => Inter.inter (EMetric.ball x Œµ) s","decl":"theorem nhdsWithin_basis_eball : (ùìù[s] x).HasBasis (fun Œµ : ‚Ñù‚â•0‚àû => 0 < Œµ) fun Œµ => ball x Œµ ‚à© s :=\n  nhdsWithin_hasBasis nhds_basis_eball s\n\n"}
{"name":"EMetric.nhds_basis_closed_eball","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\n‚ä¢ (nhds x).HasBasis (fun Œµ => LT.lt 0 Œµ) (EMetric.closedBall x)","decl":"theorem nhds_basis_closed_eball : (ùìù x).HasBasis (fun Œµ : ‚Ñù‚â•0‚àû => 0 < Œµ) (closedBall x) :=\n  nhds_basis_uniformity uniformity_basis_edist_le\n\n"}
{"name":"EMetric.nhdsWithin_basis_closed_eball","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\ns : Set Œ±\n‚ä¢ (nhdsWithin x s).HasBasis (fun Œµ => LT.lt 0 Œµ) fun Œµ => Inter.inter (EMetric.closedBall x Œµ) s","decl":"theorem nhdsWithin_basis_closed_eball :\n    (ùìù[s] x).HasBasis (fun Œµ : ‚Ñù‚â•0‚àû => 0 < Œµ) fun Œµ => closedBall x Œµ ‚à© s :=\n  nhdsWithin_hasBasis nhds_basis_closed_eball s\n\n"}
{"name":"EMetric.nhds_eq","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\n‚ä¢ Eq (nhds x) (iInf fun Œµ => iInf fun h => Filter.principal (EMetric.ball x Œµ))","decl":"theorem nhds_eq : ùìù x = ‚®Ö Œµ > 0, ùìü (ball x Œµ) :=\n  nhds_basis_eball.eq_biInf\n\n"}
{"name":"EMetric.mem_nhds_iff","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (nhds x) s) (Exists fun Œµ => And (GT.gt Œµ 0) (HasSubset.Subset (EMetric.ball x Œµ) s))","decl":"theorem mem_nhds_iff : s ‚àà ùìù x ‚Üî ‚àÉ Œµ > 0, ball x Œµ ‚äÜ s :=\n  nhds_basis_eball.mem_iff\n\n"}
{"name":"EMetric.mem_nhdsWithin_iff","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\ns t : Set Œ±\n‚ä¢ Iff (Membership.mem (nhdsWithin x t) s) (Exists fun Œµ => And (GT.gt Œµ 0) (HasSubset.Subset (Inter.inter (EMetric.ball x Œµ) t) s))","decl":"theorem mem_nhdsWithin_iff : s ‚àà ùìù[t] x ‚Üî ‚àÉ Œµ > 0, ball x Œµ ‚à© t ‚äÜ s :=\n  nhdsWithin_basis_eball.mem_iff\n\n"}
{"name":"EMetric.tendsto_nhdsWithin_nhdsWithin","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ns : Set Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nf : Œ± ‚Üí Œ≤\nt : Set Œ≤\na : Œ±\nb : Œ≤\n‚ä¢ Iff (Filter.Tendsto f (nhdsWithin a s) (nhdsWithin b t)) (‚àÄ (Œµ : ENNReal), GT.gt Œµ 0 ‚Üí Exists fun Œ¥ => And (GT.gt Œ¥ 0) (‚àÄ ‚¶Éx : Œ±‚¶Ñ, Membership.mem s x ‚Üí LT.lt (EDist.edist x a) Œ¥ ‚Üí And (Membership.mem t (f x)) (LT.lt (EDist.edist (f x) b) Œµ)))","decl":"theorem tendsto_nhdsWithin_nhdsWithin {t : Set Œ≤} {a b} :\n    Tendsto f (ùìù[s] a) (ùìù[t] b) ‚Üî\n      ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ ‚¶Éx‚¶Ñ, x ‚àà s ‚Üí edist x a < Œ¥ ‚Üí f x ‚àà t ‚àß edist (f x) b < Œµ :=\n  (nhdsWithin_basis_eball.tendsto_iff nhdsWithin_basis_eball).trans <|\n    forall‚ÇÇ_congr fun Œµ _ => exists_congr fun Œ¥ => and_congr_right fun _ =>\n      forall_congr' fun x => by simp; tauto\n\n"}
{"name":"EMetric.tendsto_nhdsWithin_nhds","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ns : Set Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nf : Œ± ‚Üí Œ≤\na : Œ±\nb : Œ≤\n‚ä¢ Iff (Filter.Tendsto f (nhdsWithin a s) (nhds b)) (‚àÄ (Œµ : ENNReal), GT.gt Œµ 0 ‚Üí Exists fun Œ¥ => And (GT.gt Œ¥ 0) (‚àÄ {x : Œ±}, Membership.mem s x ‚Üí LT.lt (EDist.edist x a) Œ¥ ‚Üí LT.lt (EDist.edist (f x) b) Œµ))","decl":"theorem tendsto_nhdsWithin_nhds {a b} :\n    Tendsto f (ùìù[s] a) (ùìù b) ‚Üî\n      ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ {x : Œ±}, x ‚àà s ‚Üí edist x a < Œ¥ ‚Üí edist (f x) b < Œµ := by\n  rw [‚Üê nhdsWithin_univ b, tendsto_nhdsWithin_nhdsWithin]\n  simp only [mem_univ, true_and]\n\n"}
{"name":"EMetric.tendsto_nhds_nhds","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nf : Œ± ‚Üí Œ≤\na : Œ±\nb : Œ≤\n‚ä¢ Iff (Filter.Tendsto f (nhds a) (nhds b)) (‚àÄ (Œµ : ENNReal), GT.gt Œµ 0 ‚Üí Exists fun Œ¥ => And (GT.gt Œ¥ 0) (‚àÄ ‚¶Éx : Œ±‚¶Ñ, LT.lt (EDist.edist x a) Œ¥ ‚Üí LT.lt (EDist.edist (f x) b) Œµ))","decl":"theorem tendsto_nhds_nhds {a b} :\n    Tendsto f (ùìù a) (ùìù b) ‚Üî ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ ‚¶Éx‚¶Ñ, edist x a < Œ¥ ‚Üí edist (f x) b < Œµ :=\n  nhds_basis_eball.tendsto_iff nhds_basis_eball\n\n"}
{"name":"EMetric.isOpen_iff","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\ns : Set Œ±\n‚ä¢ Iff (IsOpen s) (‚àÄ (x : Œ±), Membership.mem s x ‚Üí Exists fun Œµ => And (GT.gt Œµ 0) (HasSubset.Subset (EMetric.ball x Œµ) s))","decl":"theorem isOpen_iff : IsOpen s ‚Üî ‚àÄ x ‚àà s, ‚àÉ Œµ > 0, ball x Œµ ‚äÜ s := by\n  simp [isOpen_iff_nhds, mem_nhds_iff]\n\n"}
{"name":"EMetric.isOpen_ball","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\nŒµ : ENNReal\n‚ä¢ IsOpen (EMetric.ball x Œµ)","decl":"theorem isOpen_ball : IsOpen (ball x Œµ) :=\n  isOpen_iff.2 fun _ => exists_ball_subset_ball\n\n"}
{"name":"EMetric.isClosed_ball_top","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\n‚ä¢ IsClosed (EMetric.ball x Top.top)","decl":"theorem isClosed_ball_top : IsClosed (ball x ‚ä§) :=\n  isOpen_compl_iff.1 <| isOpen_iff.2 fun _y hy =>\n    ‚ü®‚ä§, ENNReal.coe_lt_top, fun _z hzy hzx =>\n      hy (edistLtTopSetoid.trans (edistLtTopSetoid.symm hzy) hzx)‚ü©\n\n"}
{"name":"EMetric.ball_mem_nhds","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\nŒµ : ENNReal\nŒµ0 : LT.lt 0 Œµ\n‚ä¢ Membership.mem (nhds x) (EMetric.ball x Œµ)","decl":"theorem ball_mem_nhds (x : Œ±) {Œµ : ‚Ñù‚â•0‚àû} (Œµ0 : 0 < Œµ) : ball x Œµ ‚àà ùìù x :=\n  isOpen_ball.mem_nhds (mem_ball_self Œµ0)\n\n"}
{"name":"EMetric.closedBall_mem_nhds","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\nŒµ : ENNReal\nŒµ0 : LT.lt 0 Œµ\n‚ä¢ Membership.mem (nhds x) (EMetric.closedBall x Œµ)","decl":"theorem closedBall_mem_nhds (x : Œ±) {Œµ : ‚Ñù‚â•0‚àû} (Œµ0 : 0 < Œµ) : closedBall x Œµ ‚àà ùìù x :=\n  mem_of_superset (ball_mem_nhds x Œµ0) ball_subset_closedBall\n\n"}
{"name":"EMetric.ball_prod_same","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nx : Œ±\ny : Œ≤\nr : ENNReal\n‚ä¢ Eq (SProd.sprod (EMetric.ball x r) (EMetric.ball y r)) (EMetric.ball { fst := x, snd := y } r)","decl":"theorem ball_prod_same [PseudoEMetricSpace Œ≤] (x : Œ±) (y : Œ≤) (r : ‚Ñù‚â•0‚àû) :\n    ball x r √óÀ¢ ball y r = ball (x, y) r :=\n  ext fun z => by simp [Prod.edist_eq]\n\n"}
{"name":"EMetric.closedBall_prod_same","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nx : Œ±\ny : Œ≤\nr : ENNReal\n‚ä¢ Eq (SProd.sprod (EMetric.closedBall x r) (EMetric.closedBall y r)) (EMetric.closedBall { fst := x, snd := y } r)","decl":"theorem closedBall_prod_same [PseudoEMetricSpace Œ≤] (x : Œ±) (y : Œ≤) (r : ‚Ñù‚â•0‚àû) :\n    closedBall x r √óÀ¢ closedBall y r = closedBall (x, y) r :=\n  ext fun z => by simp [Prod.edist_eq]\n\n"}
{"name":"EMetric.mem_closure_iff","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (closure s) x) (‚àÄ (Œµ : ENNReal), GT.gt Œµ 0 ‚Üí Exists fun y => And (Membership.mem s y) (LT.lt (EDist.edist x y) Œµ))","decl":"/-- Œµ-characterization of the closure in pseudoemetric spaces -/\ntheorem mem_closure_iff : x ‚àà closure s ‚Üî ‚àÄ Œµ > 0, ‚àÉ y ‚àà s, edist x y < Œµ :=\n  (mem_closure_iff_nhds_basis nhds_basis_eball).trans <| by simp only [mem_ball, edist_comm x]\n\n"}
{"name":"EMetric.tendsto_nhds","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù : PseudoEMetricSpace Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\na : Œ±\n‚ä¢ Iff (Filter.Tendsto u f (nhds a)) (‚àÄ (Œµ : ENNReal), GT.gt Œµ 0 ‚Üí Filter.Eventually (fun x => LT.lt (EDist.edist (u x) a) Œµ) f)","decl":"theorem tendsto_nhds {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±} :\n    Tendsto u f (ùìù a) ‚Üî ‚àÄ Œµ > 0, ‚àÄ·∂† x in f, edist (u x) a < Œµ :=\n  nhds_basis_eball.tendsto_right_iff\n\n"}
{"name":"EMetric.tendsto_atTop","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : PseudoEMetricSpace Œ±\ninst‚úù¬π : Nonempty Œ≤\ninst‚úù : SemilatticeSup Œ≤\nu : Œ≤ ‚Üí Œ±\na : Œ±\n‚ä¢ Iff (Filter.Tendsto u Filter.atTop (nhds a)) (‚àÄ (Œµ : ENNReal), GT.gt Œµ 0 ‚Üí Exists fun N => ‚àÄ (n : Œ≤), GE.ge n N ‚Üí LT.lt (EDist.edist (u n) a) Œµ)","decl":"theorem tendsto_atTop [Nonempty Œ≤] [SemilatticeSup Œ≤] {u : Œ≤ ‚Üí Œ±} {a : Œ±} :\n    Tendsto u atTop (ùìù a) ‚Üî ‚àÄ Œµ > 0, ‚àÉ N, ‚àÄ n ‚â• N, edist (u n) a < Œµ :=\n  (atTop_basis.tendsto_iff nhds_basis_eball).trans <| by\n    simp only [exists_prop, true_and, mem_Ici, mem_ball]\n\n"}
{"name":"EMetric.subset_countable_closure_of_almost_dense_set","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\ns : Set Œ±\nhs : ‚àÄ (Œµ : ENNReal), GT.gt Œµ 0 ‚Üí Exists fun t => And t.Countable (HasSubset.Subset s (Set.iUnion fun x => Set.iUnion fun h => EMetric.closedBall x Œµ))\n‚ä¢ Exists fun t => And (HasSubset.Subset t s) (And t.Countable (HasSubset.Subset s (closure t)))","decl":"/-- For a set `s` in a pseudo emetric space, if for every `Œµ > 0` there exists a countable\nset that is `Œµ`-dense in `s`, then there exists a countable subset `t ‚äÜ s` that is dense in `s`. -/\ntheorem subset_countable_closure_of_almost_dense_set (s : Set Œ±)\n    (hs : ‚àÄ Œµ > 0, ‚àÉ t : Set Œ±, t.Countable ‚àß s ‚äÜ ‚ãÉ x ‚àà t, closedBall x Œµ) :\n    ‚àÉ t, t ‚äÜ s ‚àß t.Countable ‚àß s ‚äÜ closure t := by\n  rcases s.eq_empty_or_nonempty with (rfl | ‚ü®x‚ÇÄ, hx‚ÇÄ‚ü©)\n  ¬∑ exact ‚ü®‚àÖ, empty_subset _, countable_empty, empty_subset _‚ü©\n  choose! T hTc hsT using fun n : ‚Ñï => hs n‚Åª¬π (by simp)\n  have : ‚àÄ r x, ‚àÉ y ‚àà s, closedBall x r ‚à© s ‚äÜ closedBall y (r * 2) := fun r x => by\n    rcases (closedBall x r ‚à© s).eq_empty_or_nonempty with (he | ‚ü®y, hxy, hys‚ü©)\n    ¬∑ refine ‚ü®x‚ÇÄ, hx‚ÇÄ, ?_‚ü©\n      rw [he]\n      exact empty_subset _\n    ¬∑ refine ‚ü®y, hys, fun z hz => ?_‚ü©\n      calc\n        edist z y ‚â§ edist z x + edist y x := edist_triangle_right _ _ _\n        _ ‚â§ r + r := add_le_add hz.1 hxy\n        _ = r * 2 := (mul_two r).symm\n  choose f hfs hf using this\n  refine\n    ‚ü®‚ãÉ n : ‚Ñï, f n‚Åª¬π '' T n, iUnion_subset fun n => image_subset_iff.2 fun z _ => hfs _ _,\n      countable_iUnion fun n => (hTc n).image _, ?_‚ü©\n  refine fun x hx => mem_closure_iff.2 fun Œµ Œµ0 => ?_\n  rcases ENNReal.exists_inv_nat_lt (ENNReal.half_pos Œµ0.lt.ne').ne' with ‚ü®n, hn‚ü©\n  rcases mem_iUnion‚ÇÇ.1 (hsT n hx) with ‚ü®y, hyn, hyx‚ü©\n  refine ‚ü®f n‚Åª¬π y, mem_iUnion.2 ‚ü®n, mem_image_of_mem _ hyn‚ü©, ?_‚ü©\n  calc\n    edist x (f n‚Åª¬π y) ‚â§ (n : ‚Ñù‚â•0‚àû)‚Åª¬π * 2 := hf _ _ ‚ü®hyx, hx‚ü©\n    _ < Œµ := ENNReal.mul_lt_of_lt_div hn\n\n"}
{"name":"TopologicalSpace.IsSeparable.exists_countable_dense_subset","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\ns : Set Œ±\nhs : TopologicalSpace.IsSeparable s\n‚ä¢ Exists fun t => And (HasSubset.Subset t s) (And t.Countable (HasSubset.Subset s (closure t)))","decl":"open TopologicalSpace in\n/-- If a set `s` is separable in a (pseudo extended) metric space, then it admits a countable dense\nsubset. This is not obvious, as the countable set whose closure covers `s` given by the definition\nof separability does not need in general to be contained in `s`. -/\ntheorem _root_.TopologicalSpace.IsSeparable.exists_countable_dense_subset\n    {s : Set Œ±} (hs : IsSeparable s) : ‚àÉ t, t ‚äÜ s ‚àß t.Countable ‚àß s ‚äÜ closure t := by\n  have : ‚àÄ Œµ > 0, ‚àÉ t : Set Œ±, t.Countable ‚àß s ‚äÜ ‚ãÉ x ‚àà t, closedBall x Œµ := fun Œµ Œµ0 => by\n    rcases hs with ‚ü®t, htc, hst‚ü©\n    refine ‚ü®t, htc, hst.trans fun x hx => ?_‚ü©\n    rcases mem_closure_iff.1 hx Œµ Œµ0 with ‚ü®y, hyt, hxy‚ü©\n    exact mem_iUnion‚ÇÇ.2 ‚ü®y, hyt, mem_closedBall.2 hxy.le‚ü©\n  exact subset_countable_closure_of_almost_dense_set _ this\n\n"}
{"name":"TopologicalSpace.IsSeparable.separableSpace","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\ns : Set Œ±\nhs : TopologicalSpace.IsSeparable s\n‚ä¢ TopologicalSpace.SeparableSpace ‚Üës","decl":"open TopologicalSpace in\n/-- If a set `s` is separable, then the corresponding subtype is separable in a (pseudo extended)\nmetric space.  This is not obvious, as the countable set whose closure covers `s` does not need in\ngeneral to be contained in `s`. -/\ntheorem _root_.TopologicalSpace.IsSeparable.separableSpace {s : Set Œ±} (hs : IsSeparable s) :\n    SeparableSpace s := by\n  rcases hs.exists_countable_dense_subset with ‚ü®t, hts, htc, hst‚ü©\n  lift t to Set s using hts\n  refine ‚ü®‚ü®t, countable_of_injective_of_countable_image Subtype.coe_injective.injOn htc, ?_‚ü©‚ü©\n  rwa [IsInducing.subtypeVal.dense_iff, Subtype.forall]\n\n"}
{"name":"EMetricSpace.eq_of_edist_eq_zero","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u\nself : EMetricSpace Œ±\nx y : Œ±\na‚úù : Eq (EDist.edist x y) 0\n‚ä¢ Eq x y","decl":"/-- We now define `EMetricSpace`, extending `PseudoEMetricSpace`. -/\nclass EMetricSpace (Œ± : Type u) extends PseudoEMetricSpace Œ± : Type u where\n  eq_of_edist_eq_zero : ‚àÄ {x y : Œ±}, edist x y = 0 ‚Üí x = y\n\n"}
{"name":"EMetricSpace.ext","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u_2\nm m' : EMetricSpace Œ±\nh : Eq PseudoEMetricSpace.toEDist PseudoEMetricSpace.toEDist\n‚ä¢ Eq m m'","decl":"@[ext]\nprotected theorem EMetricSpace.ext\n    {Œ± : Type*} {m m' : EMetricSpace Œ±} (h : m.toEDist = m'.toEDist) : m = m' := by\n  cases m\n  cases m'\n  congr\n  ext1\n  assumption\n\n"}
{"name":"EMetricSpace.ext_iff","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ± : Type u_2\nm m' : EMetricSpace Œ±\n‚ä¢ Iff (Eq m m') (Eq PseudoEMetricSpace.toEDist PseudoEMetricSpace.toEDist)","decl":"@[ext]\nprotected theorem EMetricSpace.ext\n    {Œ± : Type*} {m m' : EMetricSpace Œ±} (h : m.toEDist = m'.toEDist) : m = m' := by\n  cases m\n  cases m'\n  congr\n  ext1\n  assumption\n\n"}
{"name":"edist_eq_zero","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ≥ : Type w\ninst‚úù : EMetricSpace Œ≥\nx y : Œ≥\n‚ä¢ Iff (Eq (EDist.edist x y) 0) (Eq x y)","decl":"/-- Characterize the equality of points by the vanishing of their extended distance -/\n@[simp]\ntheorem edist_eq_zero {x y : Œ≥} : edist x y = 0 ‚Üî x = y :=\n  ‚ü®eq_of_edist_eq_zero, fun h => h ‚ñ∏ edist_self _‚ü©\n\n"}
{"name":"zero_eq_edist","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ≥ : Type w\ninst‚úù : EMetricSpace Œ≥\nx y : Œ≥\n‚ä¢ Iff (Eq 0 (EDist.edist x y)) (Eq x y)","decl":"@[simp]\ntheorem zero_eq_edist {x y : Œ≥} : 0 = edist x y ‚Üî x = y := eq_comm.trans edist_eq_zero\n\n"}
{"name":"edist_le_zero","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ≥ : Type w\ninst‚úù : EMetricSpace Œ≥\nx y : Œ≥\n‚ä¢ Iff (LE.le (EDist.edist x y) 0) (Eq x y)","decl":"theorem edist_le_zero {x y : Œ≥} : edist x y ‚â§ 0 ‚Üî x = y :=\n  nonpos_iff_eq_zero.trans edist_eq_zero\n\n"}
{"name":"edist_pos","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ≥ : Type w\ninst‚úù : EMetricSpace Œ≥\nx y : Œ≥\n‚ä¢ Iff (LT.lt 0 (EDist.edist x y)) (Ne x y)","decl":"@[simp]\ntheorem edist_pos {x y : Œ≥} : 0 < edist x y ‚Üî x ‚â† y := by simp [‚Üê not_le]\n\n"}
{"name":"eq_of_forall_edist_le","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ≥ : Type w\ninst‚úù : EMetricSpace Œ≥\nx y : Œ≥\nh : ‚àÄ (Œµ : ENNReal), GT.gt Œµ 0 ‚Üí LE.le (EDist.edist x y) Œµ\n‚ä¢ Eq x y","decl":"/-- Two points coincide if their distance is `< Œµ` for all positive Œµ -/\ntheorem eq_of_forall_edist_le {x y : Œ≥} (h : ‚àÄ Œµ > 0, edist x y ‚â§ Œµ) : x = y :=\n  eq_of_edist_eq_zero (eq_of_le_of_forall_lt_imp_le_of_dense bot_le h)\n\n"}
{"name":"uniformity_edist","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"Œ≥ : Type w\ninst‚úù : EMetricSpace Œ≥\n‚ä¢ Eq (uniformity Œ≥) (iInf fun Œµ => iInf fun h => Filter.principal (setOf fun p => LT.lt (EDist.edist p.1 p.2) Œµ))","decl":"/-- Reformulation of the uniform structure in terms of the extended distance -/\ntheorem uniformity_edist : ùì§ Œ≥ = ‚®Ö Œµ > 0, ùìü { p : Œ≥ √ó Œ≥ | edist p.1 p.2 < Œµ } :=\n  PseudoEMetricSpace.uniformity_edist\n\n"}
{"name":"edist_ofMul","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"X : Type u_1\ninst‚úù : EDist X\na b : X\n‚ä¢ Eq (EDist.edist (Additive.ofMul a) (Additive.ofMul b)) (EDist.edist a b)","decl":"@[simp]\ntheorem edist_ofMul (a b : X) : edist (ofMul a) (ofMul b) = edist a b :=\n  rfl\n\n"}
{"name":"edist_ofAdd","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"X : Type u_1\ninst‚úù : EDist X\na b : X\n‚ä¢ Eq (EDist.edist (Multiplicative.ofAdd a) (Multiplicative.ofAdd b)) (EDist.edist a b)","decl":"@[simp]\ntheorem edist_ofAdd (a b : X) : edist (ofAdd a) (ofAdd b) = edist a b :=\n  rfl\n\n"}
{"name":"edist_toMul","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"X : Type u_1\ninst‚úù : EDist X\na b : Additive X\n‚ä¢ Eq (EDist.edist (Additive.toMul a) (Additive.toMul b)) (EDist.edist a b)","decl":"@[simp]\ntheorem edist_toMul (a b : Additive X) : edist a.toMul b.toMul = edist a b :=\n  rfl\n\n"}
{"name":"edist_toAdd","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"X : Type u_1\ninst‚úù : EDist X\na b : Multiplicative X\n‚ä¢ Eq (EDist.edist (Multiplicative.toAdd a) (Multiplicative.toAdd b)) (EDist.edist a b)","decl":"@[simp]\ntheorem edist_toAdd (a b : Multiplicative X) : edist a.toAdd b.toAdd = edist a b :=\n  rfl\n\n"}
{"name":"edist_toDual","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"X : Type u_1\ninst‚úù : EDist X\na b : X\n‚ä¢ Eq (EDist.edist (OrderDual.toDual a) (OrderDual.toDual b)) (EDist.edist a b)","decl":"@[simp]\ntheorem edist_toDual (a b : X) : edist (toDual a) (toDual b) = edist a b :=\n  rfl\n\n"}
{"name":"edist_ofDual","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"X : Type u_1\ninst‚úù : EDist X\na b : OrderDual X\n‚ä¢ Eq (EDist.edist (OrderDual.ofDual a) (OrderDual.ofDual b)) (EDist.edist a b)","decl":"@[simp]\ntheorem edist_ofDual (a b : X·µí·µà) : edist (ofDual a) (ofDual b) = edist a b :=\n  rfl\n\n"}
