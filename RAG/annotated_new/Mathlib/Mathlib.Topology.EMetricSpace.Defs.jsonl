{"name":"uniformity_dist_of_mem_uniformity","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝ : LinearOrder β\nU : Filter (Prod α α)\nz : β\nD : α → α → β\nH : ∀ (s : Set (Prod α α)), Iff (Membership.mem U s) (Exists fun ε => And (GT.gt ε z) (∀ {a b : α}, LT.lt (D a b) ε → Membership.mem s { fst := a, snd := b }))\n⊢ Eq U (iInf fun ε => iInf fun h => Filter.principal (setOf fun p => LT.lt (D p.1 p.2) ε))","decl":"/-- Characterizing uniformities associated to a (generalized) distance function `D`\nin terms of the elements of the uniformity. -/\ntheorem uniformity_dist_of_mem_uniformity [LinearOrder β] {U : Filter (α × α)} (z : β)\n    (D : α → α → β) (H : ∀ s, s ∈ U ↔ ∃ ε > z, ∀ {a b : α}, D a b < ε → (a, b) ∈ s) :\n    U = ⨅ ε > z, 𝓟 { p : α × α | D p.1 p.2 < ε } :=\n  HasBasis.eq_biInf ⟨fun s => by simp only [H, subset_def, Prod.forall, mem_setOf]⟩\n\n"}
{"name":"EDist.ext_iff","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u_2\nx y : EDist α\n⊢ Iff (Eq x y) (Eq EDist.edist EDist.edist)","decl":"/-- `EDist α` means that `α` is equipped with an extended distance. -/\n@[ext]\nclass EDist (α : Type*) where\n  edist : α → α → ℝ≥0∞\n\n"}
{"name":"EDist.ext","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u_2\nx y : EDist α\nedist : Eq EDist.edist EDist.edist\n⊢ Eq x y","decl":"/-- `EDist α` means that `α` is equipped with an extended distance. -/\n@[ext]\nclass EDist (α : Type*) where\n  edist : α → α → ℝ≥0∞\n\n"}
{"name":"PseudoEMetricSpace.edist_comm","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\nself : PseudoEMetricSpace α\nx y : α\n⊢ Eq (EDist.edist x y) (EDist.edist y x)","decl":"/-- Extended (pseudo) metric spaces, with an extended distance `edist` possibly taking the\nvalue ∞\n\nEach pseudo_emetric space induces a canonical `UniformSpace` and hence a canonical\n`TopologicalSpace`.\nThis is enforced in the type class definition, by extending the `UniformSpace` structure. When\ninstantiating a `PseudoEMetricSpace` structure, the uniformity fields are not necessary, they\nwill be filled in by default. There is a default value for the uniformity, that can be substituted\nin cases of interest, for instance when instantiating a `PseudoEMetricSpace` structure\non a product.\n\nContinuity of `edist` is proved in `Topology.Instances.ENNReal`\n-/\nclass PseudoEMetricSpace (α : Type u) extends EDist α : Type u where\n  edist_self : ∀ x : α, edist x x = 0\n  edist_comm : ∀ x y : α, edist x y = edist y x\n  edist_triangle : ∀ x y z : α, edist x z ≤ edist x y + edist y z\n  toUniformSpace : UniformSpace α := uniformSpaceOfEDist edist edist_self edist_comm edist_triangle\n  uniformity_edist : 𝓤 α = ⨅ ε > 0, 𝓟 { p : α × α | edist p.1 p.2 < ε } := by rfl\n\n"}
{"name":"PseudoEMetricSpace.uniformity_edist","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\nself : PseudoEMetricSpace α\n⊢ Eq (uniformity α) (iInf fun ε => iInf fun h => Filter.principal (setOf fun p => LT.lt (EDist.edist p.1 p.2) ε))","decl":"/-- Extended (pseudo) metric spaces, with an extended distance `edist` possibly taking the\nvalue ∞\n\nEach pseudo_emetric space induces a canonical `UniformSpace` and hence a canonical\n`TopologicalSpace`.\nThis is enforced in the type class definition, by extending the `UniformSpace` structure. When\ninstantiating a `PseudoEMetricSpace` structure, the uniformity fields are not necessary, they\nwill be filled in by default. There is a default value for the uniformity, that can be substituted\nin cases of interest, for instance when instantiating a `PseudoEMetricSpace` structure\non a product.\n\nContinuity of `edist` is proved in `Topology.Instances.ENNReal`\n-/\nclass PseudoEMetricSpace (α : Type u) extends EDist α : Type u where\n  edist_self : ∀ x : α, edist x x = 0\n  edist_comm : ∀ x y : α, edist x y = edist y x\n  edist_triangle : ∀ x y z : α, edist x z ≤ edist x y + edist y z\n  toUniformSpace : UniformSpace α := uniformSpaceOfEDist edist edist_self edist_comm edist_triangle\n  uniformity_edist : 𝓤 α = ⨅ ε > 0, 𝓟 { p : α × α | edist p.1 p.2 < ε } := by rfl\n\n"}
{"name":"PseudoEMetricSpace.edist_triangle","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\nself : PseudoEMetricSpace α\nx y z : α\n⊢ LE.le (EDist.edist x z) (HAdd.hAdd (EDist.edist x y) (EDist.edist y z))","decl":"/-- Extended (pseudo) metric spaces, with an extended distance `edist` possibly taking the\nvalue ∞\n\nEach pseudo_emetric space induces a canonical `UniformSpace` and hence a canonical\n`TopologicalSpace`.\nThis is enforced in the type class definition, by extending the `UniformSpace` structure. When\ninstantiating a `PseudoEMetricSpace` structure, the uniformity fields are not necessary, they\nwill be filled in by default. There is a default value for the uniformity, that can be substituted\nin cases of interest, for instance when instantiating a `PseudoEMetricSpace` structure\non a product.\n\nContinuity of `edist` is proved in `Topology.Instances.ENNReal`\n-/\nclass PseudoEMetricSpace (α : Type u) extends EDist α : Type u where\n  edist_self : ∀ x : α, edist x x = 0\n  edist_comm : ∀ x y : α, edist x y = edist y x\n  edist_triangle : ∀ x y z : α, edist x z ≤ edist x y + edist y z\n  toUniformSpace : UniformSpace α := uniformSpaceOfEDist edist edist_self edist_comm edist_triangle\n  uniformity_edist : 𝓤 α = ⨅ ε > 0, 𝓟 { p : α × α | edist p.1 p.2 < ε } := by rfl\n\n"}
{"name":"PseudoEMetricSpace.edist_self","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\nself : PseudoEMetricSpace α\nx : α\n⊢ Eq (EDist.edist x x) 0","decl":"/-- Extended (pseudo) metric spaces, with an extended distance `edist` possibly taking the\nvalue ∞\n\nEach pseudo_emetric space induces a canonical `UniformSpace` and hence a canonical\n`TopologicalSpace`.\nThis is enforced in the type class definition, by extending the `UniformSpace` structure. When\ninstantiating a `PseudoEMetricSpace` structure, the uniformity fields are not necessary, they\nwill be filled in by default. There is a default value for the uniformity, that can be substituted\nin cases of interest, for instance when instantiating a `PseudoEMetricSpace` structure\non a product.\n\nContinuity of `edist` is proved in `Topology.Instances.ENNReal`\n-/\nclass PseudoEMetricSpace (α : Type u) extends EDist α : Type u where\n  edist_self : ∀ x : α, edist x x = 0\n  edist_comm : ∀ x y : α, edist x y = edist y x\n  edist_triangle : ∀ x y z : α, edist x z ≤ edist x y + edist y z\n  toUniformSpace : UniformSpace α := uniformSpaceOfEDist edist edist_self edist_comm edist_triangle\n  uniformity_edist : 𝓤 α = ⨅ ε > 0, 𝓟 { p : α × α | edist p.1 p.2 < ε } := by rfl\n\n"}
{"name":"PseudoEMetricSpace.ext_iff","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u_2\nm m' : PseudoEMetricSpace α\n⊢ Iff (Eq m m') (Eq PseudoEMetricSpace.toEDist PseudoEMetricSpace.toEDist)","decl":"/-- Two pseudo emetric space structures with the same edistance function coincide. -/\n@[ext]\nprotected theorem PseudoEMetricSpace.ext {α : Type*} {m m' : PseudoEMetricSpace α}\n    (h : m.toEDist = m'.toEDist) : m = m' := by\n  cases' m with ed  _ _ _ U hU\n  cases' m' with ed' _ _ _ U' hU'\n  congr 1\n  exact UniformSpace.ext (((show ed = ed' from h) ▸ hU).trans hU'.symm)\n\n"}
{"name":"PseudoEMetricSpace.ext","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u_2\nm m' : PseudoEMetricSpace α\nh : Eq PseudoEMetricSpace.toEDist PseudoEMetricSpace.toEDist\n⊢ Eq m m'","decl":"/-- Two pseudo emetric space structures with the same edistance function coincide. -/\n@[ext]\nprotected theorem PseudoEMetricSpace.ext {α : Type*} {m m' : PseudoEMetricSpace α}\n    (h : m.toEDist = m'.toEDist) : m = m' := by\n  cases' m with ed  _ _ _ U hU\n  cases' m' with ed' _ _ _ U' hU'\n  congr 1\n  exact UniformSpace.ext (((show ed = ed' from h) ▸ hU).trans hU'.symm)\n\n"}
{"name":"edist_triangle_left","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y z : α\n⊢ LE.le (EDist.edist x y) (HAdd.hAdd (EDist.edist z x) (EDist.edist z y))","decl":"/-- Triangle inequality for the extended distance -/\ntheorem edist_triangle_left (x y z : α) : edist x y ≤ edist z x + edist z y := by\n  rw [edist_comm z]; apply edist_triangle\n\n"}
{"name":"edist_triangle_right","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y z : α\n⊢ LE.le (EDist.edist x y) (HAdd.hAdd (EDist.edist x z) (EDist.edist y z))","decl":"theorem edist_triangle_right (x y z : α) : edist x y ≤ edist x z + edist y z := by\n  rw [edist_comm y]; apply edist_triangle\n\n"}
{"name":"edist_congr_right","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y z : α\nh : Eq (EDist.edist x y) 0\n⊢ Eq (EDist.edist x z) (EDist.edist y z)","decl":"theorem edist_congr_right {x y z : α} (h : edist x y = 0) : edist x z = edist y z := by\n  apply le_antisymm\n  · rw [← zero_add (edist y z), ← h]\n    apply edist_triangle\n  · rw [edist_comm] at h\n    rw [← zero_add (edist x z), ← h]\n    apply edist_triangle\n\n"}
{"name":"edist_congr_left","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y z : α\nh : Eq (EDist.edist x y) 0\n⊢ Eq (EDist.edist z x) (EDist.edist z y)","decl":"theorem edist_congr_left {x y z : α} (h : edist x y = 0) : edist z x = edist z y := by\n  rw [edist_comm z x, edist_comm z y]\n  apply edist_congr_right h\n\n-- new theorem\n"}
{"name":"edist_congr","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nw x y z : α\nhl : Eq (EDist.edist w x) 0\nhr : Eq (EDist.edist y z) 0\n⊢ Eq (EDist.edist w y) (EDist.edist x z)","decl":"theorem edist_congr {w x y z : α} (hl : edist w x = 0) (hr : edist y z = 0) :\n    edist w y = edist x z :=\n  (edist_congr_right hl).trans (edist_congr_left hr)\n\n"}
{"name":"edist_triangle4","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y z t : α\n⊢ LE.le (EDist.edist x t) (HAdd.hAdd (HAdd.hAdd (EDist.edist x y) (EDist.edist y z)) (EDist.edist z t))","decl":"theorem edist_triangle4 (x y z t : α) : edist x t ≤ edist x y + edist y z + edist z t :=\n  calc\n    edist x t ≤ edist x z + edist z t := edist_triangle x z t\n    _ ≤ edist x y + edist y z + edist z t := add_le_add_right (edist_triangle x y z) _\n\n"}
{"name":"uniformity_pseudoedist","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\n⊢ Eq (uniformity α) (iInf fun ε => iInf fun h => Filter.principal (setOf fun p => LT.lt (EDist.edist p.1 p.2) ε))","decl":"/-- Reformulation of the uniform structure in terms of the extended distance -/\ntheorem uniformity_pseudoedist : 𝓤 α = ⨅ ε > 0, 𝓟 { p : α × α | edist p.1 p.2 < ε } :=\n  PseudoEMetricSpace.uniformity_edist\n\n"}
{"name":"uniformSpace_edist","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\n⊢ Eq PseudoEMetricSpace.toUniformSpace (uniformSpaceOfEDist EDist.edist ⋯ ⋯ ⋯)","decl":"theorem uniformSpace_edist :\n    ‹PseudoEMetricSpace α›.toUniformSpace =\n      uniformSpaceOfEDist edist edist_self edist_comm edist_triangle :=\n  UniformSpace.ext uniformity_pseudoedist\n\n"}
{"name":"uniformity_basis_edist","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\n⊢ (uniformity α).HasBasis (fun ε => LT.lt 0 ε) fun ε => setOf fun p => LT.lt (EDist.edist p.1 p.2) ε","decl":"theorem uniformity_basis_edist :\n    (𝓤 α).HasBasis (fun ε : ℝ≥0∞ => 0 < ε) fun ε => { p : α × α | edist p.1 p.2 < ε } :=\n  (@uniformSpace_edist α _).symm ▸ UniformSpace.hasBasis_ofFun ⟨1, one_pos⟩ _ _ _ _ _\n\n"}
{"name":"mem_uniformity_edist","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns : Set (Prod α α)\n⊢ Iff (Membership.mem (uniformity α) s) (Exists fun ε => And (GT.gt ε 0) (∀ {a b : α}, LT.lt (EDist.edist a b) ε → Membership.mem s { fst := a, snd := b }))","decl":"/-- Characterization of the elements of the uniformity in terms of the extended distance -/\ntheorem mem_uniformity_edist {s : Set (α × α)} :\n    s ∈ 𝓤 α ↔ ∃ ε > 0, ∀ {a b : α}, edist a b < ε → (a, b) ∈ s :=\n  uniformity_basis_edist.mem_uniformity_iff\n\n"}
{"name":"EMetric.mk_uniformity_basis","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nβ : Type u_2\np : β → Prop\nf : β → ENNReal\nhf₀ : ∀ (x : β), p x → LT.lt 0 (f x)\nhf : ∀ (ε : ENNReal), LT.lt 0 ε → Exists fun x => And (p x) (LE.le (f x) ε)\n⊢ (uniformity α).HasBasis p fun x => setOf fun p => LT.lt (EDist.edist p.1 p.2) (f x)","decl":"/-- Given `f : β → ℝ≥0∞`, if `f` sends `{i | p i}` to a set of positive numbers\naccumulating to zero, then `f i`-neighborhoods of the diagonal form a basis of `𝓤 α`.\n\nFor specific bases see `uniformity_basis_edist`, `uniformity_basis_edist'`,\n`uniformity_basis_edist_nnreal`, and `uniformity_basis_edist_inv_nat`. -/\nprotected theorem EMetric.mk_uniformity_basis {β : Type*} {p : β → Prop} {f : β → ℝ≥0∞}\n    (hf₀ : ∀ x, p x → 0 < f x) (hf : ∀ ε, 0 < ε → ∃ x, p x ∧ f x ≤ ε) :\n    (𝓤 α).HasBasis p fun x => { p : α × α | edist p.1 p.2 < f x } := by\n  refine ⟨fun s => uniformity_basis_edist.mem_iff.trans ?_⟩\n  constructor\n  · rintro ⟨ε, ε₀, hε⟩\n    rcases hf ε ε₀ with ⟨i, hi, H⟩\n    exact ⟨i, hi, fun x hx => hε <| lt_of_lt_of_le hx.out H⟩\n  · exact fun ⟨i, hi, H⟩ => ⟨f i, hf₀ i hi, H⟩\n\n"}
{"name":"EMetric.mk_uniformity_basis_le","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nβ : Type u_2\np : β → Prop\nf : β → ENNReal\nhf₀ : ∀ (x : β), p x → LT.lt 0 (f x)\nhf : ∀ (ε : ENNReal), LT.lt 0 ε → Exists fun x => And (p x) (LE.le (f x) ε)\n⊢ (uniformity α).HasBasis p fun x => setOf fun p => LE.le (EDist.edist p.1 p.2) (f x)","decl":"/-- Given `f : β → ℝ≥0∞`, if `f` sends `{i | p i}` to a set of positive numbers\naccumulating to zero, then closed `f i`-neighborhoods of the diagonal form a basis of `𝓤 α`.\n\nFor specific bases see `uniformity_basis_edist_le` and `uniformity_basis_edist_le'`. -/\nprotected theorem EMetric.mk_uniformity_basis_le {β : Type*} {p : β → Prop} {f : β → ℝ≥0∞}\n    (hf₀ : ∀ x, p x → 0 < f x) (hf : ∀ ε, 0 < ε → ∃ x, p x ∧ f x ≤ ε) :\n    (𝓤 α).HasBasis p fun x => { p : α × α | edist p.1 p.2 ≤ f x } := by\n  refine ⟨fun s => uniformity_basis_edist.mem_iff.trans ?_⟩\n  constructor\n  · rintro ⟨ε, ε₀, hε⟩\n    rcases exists_between ε₀ with ⟨ε', hε'⟩\n    rcases hf ε' hε'.1 with ⟨i, hi, H⟩\n    exact ⟨i, hi, fun x hx => hε <| lt_of_le_of_lt (le_trans hx.out H) hε'.2⟩\n  · exact fun ⟨i, hi, H⟩ => ⟨f i, hf₀ i hi, fun x hx => H (le_of_lt hx.out)⟩\n\n"}
{"name":"uniformity_basis_edist_le","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\n⊢ (uniformity α).HasBasis (fun ε => LT.lt 0 ε) fun ε => setOf fun p => LE.le (EDist.edist p.1 p.2) ε","decl":"theorem uniformity_basis_edist_le :\n    (𝓤 α).HasBasis (fun ε : ℝ≥0∞ => 0 < ε) fun ε => { p : α × α | edist p.1 p.2 ≤ ε } :=\n  EMetric.mk_uniformity_basis_le (fun _ => id) fun ε ε₀ => ⟨ε, ε₀, le_refl ε⟩\n\n"}
{"name":"uniformity_basis_edist'","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nε' : ENNReal\nhε' : LT.lt 0 ε'\n⊢ (uniformity α).HasBasis (fun ε => Membership.mem (Set.Ioo 0 ε') ε) fun ε => setOf fun p => LT.lt (EDist.edist p.1 p.2) ε","decl":"theorem uniformity_basis_edist' (ε' : ℝ≥0∞) (hε' : 0 < ε') :\n    (𝓤 α).HasBasis (fun ε : ℝ≥0∞ => ε ∈ Ioo 0 ε') fun ε => { p : α × α | edist p.1 p.2 < ε } :=\n  EMetric.mk_uniformity_basis (fun _ => And.left) fun ε ε₀ =>\n    let ⟨δ, hδ⟩ := exists_between hε'\n    ⟨min ε δ, ⟨lt_min ε₀ hδ.1, lt_of_le_of_lt (min_le_right _ _) hδ.2⟩, min_le_left _ _⟩\n\n"}
{"name":"uniformity_basis_edist_le'","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nε' : ENNReal\nhε' : LT.lt 0 ε'\n⊢ (uniformity α).HasBasis (fun ε => Membership.mem (Set.Ioo 0 ε') ε) fun ε => setOf fun p => LE.le (EDist.edist p.1 p.2) ε","decl":"theorem uniformity_basis_edist_le' (ε' : ℝ≥0∞) (hε' : 0 < ε') :\n    (𝓤 α).HasBasis (fun ε : ℝ≥0∞ => ε ∈ Ioo 0 ε') fun ε => { p : α × α | edist p.1 p.2 ≤ ε } :=\n  EMetric.mk_uniformity_basis_le (fun _ => And.left) fun ε ε₀ =>\n    let ⟨δ, hδ⟩ := exists_between hε'\n    ⟨min ε δ, ⟨lt_min ε₀ hδ.1, lt_of_le_of_lt (min_le_right _ _) hδ.2⟩, min_le_left _ _⟩\n\n"}
{"name":"uniformity_basis_edist_nnreal","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\n⊢ (uniformity α).HasBasis (fun ε => LT.lt 0 ε) fun ε => setOf fun p => LT.lt (EDist.edist p.1 p.2) ↑ε","decl":"theorem uniformity_basis_edist_nnreal :\n    (𝓤 α).HasBasis (fun ε : ℝ≥0 => 0 < ε) fun ε => { p : α × α | edist p.1 p.2 < ε } :=\n  EMetric.mk_uniformity_basis (fun _ => ENNReal.coe_pos.2) fun _ε ε₀ =>\n    let ⟨δ, hδ⟩ := ENNReal.lt_iff_exists_nnreal_btwn.1 ε₀\n    ⟨δ, ENNReal.coe_pos.1 hδ.1, le_of_lt hδ.2⟩\n\n"}
{"name":"uniformity_basis_edist_nnreal_le","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\n⊢ (uniformity α).HasBasis (fun ε => LT.lt 0 ε) fun ε => setOf fun p => LE.le (EDist.edist p.1 p.2) ↑ε","decl":"theorem uniformity_basis_edist_nnreal_le :\n    (𝓤 α).HasBasis (fun ε : ℝ≥0 => 0 < ε) fun ε => { p : α × α | edist p.1 p.2 ≤ ε } :=\n  EMetric.mk_uniformity_basis_le (fun _ => ENNReal.coe_pos.2) fun _ε ε₀ =>\n    let ⟨δ, hδ⟩ := ENNReal.lt_iff_exists_nnreal_btwn.1 ε₀\n    ⟨δ, ENNReal.coe_pos.1 hδ.1, le_of_lt hδ.2⟩\n\n"}
{"name":"uniformity_basis_edist_inv_nat","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\n⊢ (uniformity α).HasBasis (fun x => True) fun n => setOf fun p => LT.lt (EDist.edist p.1 p.2) (Inv.inv ↑n)","decl":"theorem uniformity_basis_edist_inv_nat :\n    (𝓤 α).HasBasis (fun _ => True) fun n : ℕ => { p : α × α | edist p.1 p.2 < (↑n)⁻¹ } :=\n  EMetric.mk_uniformity_basis (fun n _ ↦ ENNReal.inv_pos.2 <| ENNReal.natCast_ne_top n) fun _ε ε₀ ↦\n    let ⟨n, hn⟩ := ENNReal.exists_inv_nat_lt (ne_of_gt ε₀)\n    ⟨n, trivial, le_of_lt hn⟩\n\n"}
{"name":"uniformity_basis_edist_inv_two_pow","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\n⊢ (uniformity α).HasBasis (fun x => True) fun n => setOf fun p => LT.lt (EDist.edist p.1 p.2) (HPow.hPow (Inv.inv 2) n)","decl":"theorem uniformity_basis_edist_inv_two_pow :\n    (𝓤 α).HasBasis (fun _ => True) fun n : ℕ => { p : α × α | edist p.1 p.2 < 2⁻¹ ^ n } :=\n  EMetric.mk_uniformity_basis (fun _ _ ↦ ENNReal.pow_pos (ENNReal.inv_pos.2 ENNReal.ofNat_ne_top) _)\n    fun _ε ε₀ ↦\n    let ⟨n, hn⟩ := ENNReal.exists_inv_two_pow_lt (ne_of_gt ε₀)\n    ⟨n, trivial, le_of_lt hn⟩\n\n"}
{"name":"edist_mem_uniformity","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nε : ENNReal\nε0 : LT.lt 0 ε\n⊢ Membership.mem (uniformity α) (setOf fun p => LT.lt (EDist.edist p.1 p.2) ε)","decl":"/-- Fixed size neighborhoods of the diagonal belong to the uniform structure -/\ntheorem edist_mem_uniformity {ε : ℝ≥0∞} (ε0 : 0 < ε) : { p : α × α | edist p.1 p.2 < ε } ∈ 𝓤 α :=\n  mem_uniformity_edist.2 ⟨ε, ε0, id⟩\n\n"}
{"name":"EMetric.instIsCountablyGeneratedUniformity","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\n⊢ (uniformity α).IsCountablyGenerated","decl":"instance (priority := 900) instIsCountablyGeneratedUniformity : IsCountablyGenerated (𝓤 α) :=\n  isCountablyGenerated_of_seq ⟨_, uniformity_basis_edist_inv_nat.eq_iInf⟩\n\n-- Porting note: changed explicit/implicit\n"}
{"name":"EMetric.uniformContinuousOn_iff","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nf : α → β\ns : Set α\n⊢ Iff (UniformContinuousOn f s) (∀ (ε : ENNReal), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ {a : α}, Membership.mem s a → ∀ {b : α}, Membership.mem s b → LT.lt (EDist.edist a b) δ → LT.lt (EDist.edist (f a) (f b)) ε))","decl":"/-- ε-δ characterization of uniform continuity on a set for pseudoemetric spaces -/\ntheorem uniformContinuousOn_iff [PseudoEMetricSpace β] {f : α → β} {s : Set α} :\n    UniformContinuousOn f s ↔\n      ∀ ε > 0, ∃ δ > 0, ∀ {a}, a ∈ s → ∀ {b}, b ∈ s → edist a b < δ → edist (f a) (f b) < ε :=\n  uniformity_basis_edist.uniformContinuousOn_iff uniformity_basis_edist\n\n"}
{"name":"EMetric.uniformContinuous_iff","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nf : α → β\n⊢ Iff (UniformContinuous f) (∀ (ε : ENNReal), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ {a b : α}, LT.lt (EDist.edist a b) δ → LT.lt (EDist.edist (f a) (f b)) ε))","decl":"/-- ε-δ characterization of uniform continuity on pseudoemetric spaces -/\ntheorem uniformContinuous_iff [PseudoEMetricSpace β] {f : α → β} :\n    UniformContinuous f ↔ ∀ ε > 0, ∃ δ > 0, ∀ {a b : α}, edist a b < δ → edist (f a) (f b) < ε :=\n  uniformity_basis_edist.uniformContinuous_iff uniformity_basis_edist\n\n"}
{"name":"Subtype.edist_eq","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\np : α → Prop\nx y : Subtype p\n⊢ Eq (EDist.edist x y) (EDist.edist ↑x ↑y)","decl":"/-- The extended pseudodistance on a subset of a pseudoemetric space is the restriction of\nthe original pseudodistance, by definition. -/\ntheorem Subtype.edist_eq {p : α → Prop} (x y : Subtype p) : edist x y = edist (x : α) y := rfl\n\n"}
{"name":"Subtype.edist_mk_mk","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\np : α → Prop\nx y : α\nhx : p x\nhy : p y\n⊢ Eq (EDist.edist ⟨x, hx⟩ ⟨y, hy⟩) (EDist.edist x y)","decl":"/-- The extended pseudodistance on a subtype of a pseudoemetric space is the restriction of\nthe original pseudodistance, by definition. -/\n@[simp]\ntheorem Subtype.edist_mk_mk {p : α → Prop} {x y : α} (hx : p x) (hy : p y) :\n    edist (⟨x, hx⟩ : Subtype p) ⟨y, hy⟩ = edist x y :=\n  rfl\n\n"}
{"name":"AddOpposite.edist_unop","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y : AddOpposite α\n⊢ Eq (EDist.edist (AddOpposite.unop x) (AddOpposite.unop y)) (EDist.edist x y)","decl":"@[to_additive]\ntheorem edist_unop (x y : αᵐᵒᵖ) : edist (unop x) (unop y) = edist x y := rfl\n\n"}
{"name":"MulOpposite.edist_unop","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y : MulOpposite α\n⊢ Eq (EDist.edist (MulOpposite.unop x) (MulOpposite.unop y)) (EDist.edist x y)","decl":"@[to_additive]\ntheorem edist_unop (x y : αᵐᵒᵖ) : edist (unop x) (unop y) = edist x y := rfl\n\n"}
{"name":"MulOpposite.edist_op","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y : α\n⊢ Eq (EDist.edist (MulOpposite.op x) (MulOpposite.op y)) (EDist.edist x y)","decl":"@[to_additive]\ntheorem edist_op (x y : α) : edist (op x) (op y) = edist x y := rfl\n\n"}
{"name":"AddOpposite.edist_op","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y : α\n⊢ Eq (EDist.edist (AddOpposite.op x) (AddOpposite.op y)) (EDist.edist x y)","decl":"@[to_additive]\ntheorem edist_op (x y : α) : edist (op x) (op y) = edist x y := rfl\n\n"}
{"name":"ULift.edist_eq","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y : ULift.{u_2, u} α\n⊢ Eq (EDist.edist x y) (EDist.edist x.down y.down)","decl":"theorem ULift.edist_eq (x y : ULift α) : edist x y = edist x.down y.down := rfl\n\n"}
{"name":"ULift.edist_up_up","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y : α\n⊢ Eq (EDist.edist { down := x } { down := y }) (EDist.edist x y)","decl":"@[simp]\ntheorem ULift.edist_up_up (x y : α) : edist (ULift.up x) (ULift.up y) = edist x y := rfl\n\n"}
{"name":"Prod.edist_eq","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nx y : Prod α β\n⊢ Eq (EDist.edist x y) (Max.max (EDist.edist x.1 y.1) (EDist.edist x.2 y.2))","decl":"theorem Prod.edist_eq [PseudoEMetricSpace β] (x y : α × β) :\n    edist x y = max (edist x.1 y.1) (edist x.2 y.2) :=\n  rfl\n\n"}
{"name":"EMetric.mem_ball","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y : α\nε : ENNReal\n⊢ Iff (Membership.mem (EMetric.ball x ε) y) (LT.lt (EDist.edist y x) ε)","decl":"@[simp] theorem mem_ball : y ∈ ball x ε ↔ edist y x < ε := Iff.rfl\n\n"}
{"name":"EMetric.mem_ball'","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y : α\nε : ENNReal\n⊢ Iff (Membership.mem (EMetric.ball x ε) y) (LT.lt (EDist.edist x y) ε)","decl":"theorem mem_ball' : y ∈ ball x ε ↔ edist x y < ε := by rw [edist_comm, mem_ball]\n\n"}
{"name":"EMetric.mem_closedBall","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y : α\nε : ENNReal\n⊢ Iff (Membership.mem (EMetric.closedBall x ε) y) (LE.le (EDist.edist y x) ε)","decl":"@[simp] theorem mem_closedBall : y ∈ closedBall x ε ↔ edist y x ≤ ε := Iff.rfl\n\n"}
{"name":"EMetric.mem_closedBall'","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y : α\nε : ENNReal\n⊢ Iff (Membership.mem (EMetric.closedBall x ε) y) (LE.le (EDist.edist x y) ε)","decl":"theorem mem_closedBall' : y ∈ closedBall x ε ↔ edist x y ≤ ε := by rw [edist_comm, mem_closedBall]\n\n"}
{"name":"EMetric.closedBall_top","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\n⊢ Eq (EMetric.closedBall x Top.top) Set.univ","decl":"@[simp]\ntheorem closedBall_top (x : α) : closedBall x ∞ = univ :=\n  eq_univ_of_forall fun _ => mem_setOf.2 le_top\n\n"}
{"name":"EMetric.ball_subset_closedBall","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\nε : ENNReal\n⊢ HasSubset.Subset (EMetric.ball x ε) (EMetric.closedBall x ε)","decl":"theorem ball_subset_closedBall : ball x ε ⊆ closedBall x ε := fun _ h => le_of_lt h.out\n\n"}
{"name":"EMetric.pos_of_mem_ball","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y : α\nε : ENNReal\nhy : Membership.mem (EMetric.ball x ε) y\n⊢ LT.lt 0 ε","decl":"theorem pos_of_mem_ball (hy : y ∈ ball x ε) : 0 < ε :=\n  lt_of_le_of_lt (zero_le _) hy\n\n"}
{"name":"EMetric.mem_ball_self","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\nε : ENNReal\nh : LT.lt 0 ε\n⊢ Membership.mem (EMetric.ball x ε) x","decl":"theorem mem_ball_self (h : 0 < ε) : x ∈ ball x ε := by\n  rwa [mem_ball, edist_self]\n\n"}
{"name":"EMetric.mem_closedBall_self","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\nε : ENNReal\n⊢ Membership.mem (EMetric.closedBall x ε) x","decl":"theorem mem_closedBall_self : x ∈ closedBall x ε := by\n  rw [mem_closedBall, edist_self]; apply zero_le\n\n"}
{"name":"EMetric.mem_ball_comm","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y : α\nε : ENNReal\n⊢ Iff (Membership.mem (EMetric.ball y ε) x) (Membership.mem (EMetric.ball x ε) y)","decl":"theorem mem_ball_comm : x ∈ ball y ε ↔ y ∈ ball x ε := by rw [mem_ball', mem_ball]\n\n"}
{"name":"EMetric.mem_closedBall_comm","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y : α\nε : ENNReal\n⊢ Iff (Membership.mem (EMetric.closedBall y ε) x) (Membership.mem (EMetric.closedBall x ε) y)","decl":"theorem mem_closedBall_comm : x ∈ closedBall y ε ↔ y ∈ closedBall x ε := by\n  rw [mem_closedBall', mem_closedBall]\n\n"}
{"name":"EMetric.ball_subset_ball","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\nε₁ ε₂ : ENNReal\nh : LE.le ε₁ ε₂\n⊢ HasSubset.Subset (EMetric.ball x ε₁) (EMetric.ball x ε₂)","decl":"@[gcongr]\ntheorem ball_subset_ball (h : ε₁ ≤ ε₂) : ball x ε₁ ⊆ ball x ε₂ := fun _y (yx : _ < ε₁) =>\n  lt_of_lt_of_le yx h\n\n"}
{"name":"EMetric.closedBall_subset_closedBall","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\nε₁ ε₂ : ENNReal\nh : LE.le ε₁ ε₂\n⊢ HasSubset.Subset (EMetric.closedBall x ε₁) (EMetric.closedBall x ε₂)","decl":"@[gcongr]\ntheorem closedBall_subset_closedBall (h : ε₁ ≤ ε₂) : closedBall x ε₁ ⊆ closedBall x ε₂ :=\n  fun _y (yx : _ ≤ ε₁) => le_trans yx h\n\n"}
{"name":"EMetric.ball_disjoint","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y : α\nε₁ ε₂ : ENNReal\nh : LE.le (HAdd.hAdd ε₁ ε₂) (EDist.edist x y)\n⊢ Disjoint (EMetric.ball x ε₁) (EMetric.ball y ε₂)","decl":"theorem ball_disjoint (h : ε₁ + ε₂ ≤ edist x y) : Disjoint (ball x ε₁) (ball y ε₂) :=\n  Set.disjoint_left.mpr fun z h₁ h₂ =>\n    (edist_triangle_left x y z).not_lt <| (ENNReal.add_lt_add h₁ h₂).trans_le h\n\n"}
{"name":"EMetric.ball_subset","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y : α\nε₁ ε₂ : ENNReal\nh : LE.le (HAdd.hAdd (EDist.edist x y) ε₁) ε₂\nh' : Ne (EDist.edist x y) Top.top\n⊢ HasSubset.Subset (EMetric.ball x ε₁) (EMetric.ball y ε₂)","decl":"theorem ball_subset (h : edist x y + ε₁ ≤ ε₂) (h' : edist x y ≠ ∞) : ball x ε₁ ⊆ ball y ε₂ :=\n  fun z zx =>\n  calc\n    edist z y ≤ edist z x + edist x y := edist_triangle _ _ _\n    _ = edist x y + edist z x := add_comm _ _\n    _ < edist x y + ε₁ := ENNReal.add_lt_add_left h' zx\n    _ ≤ ε₂ := h\n\n"}
{"name":"EMetric.exists_ball_subset_ball","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y : α\nε : ENNReal\nh : Membership.mem (EMetric.ball x ε) y\n⊢ Exists fun ε' => And (GT.gt ε' 0) (HasSubset.Subset (EMetric.ball y ε') (EMetric.ball x ε))","decl":"theorem exists_ball_subset_ball (h : y ∈ ball x ε) : ∃ ε' > 0, ball y ε' ⊆ ball x ε := by\n  have : 0 < ε - edist y x := by simpa using h\n  refine ⟨ε - edist y x, this, ball_subset ?_ (ne_top_of_lt h)⟩\n  exact (add_tsub_cancel_of_le (mem_ball.mp h).le).le\n\n"}
{"name":"EMetric.ball_eq_empty_iff","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\nε : ENNReal\n⊢ Iff (Eq (EMetric.ball x ε) EmptyCollection.emptyCollection) (Eq ε 0)","decl":"theorem ball_eq_empty_iff : ball x ε = ∅ ↔ ε = 0 :=\n  eq_empty_iff_forall_not_mem.trans\n    ⟨fun h => le_bot_iff.1 (le_of_not_gt fun ε0 => h _ (mem_ball_self ε0)), fun ε0 _ h =>\n      not_lt_of_le (le_of_eq ε0) (pos_of_mem_ball h)⟩\n\n"}
{"name":"EMetric.ordConnected_setOf_closedBall_subset","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\ns : Set α\n⊢ (setOf fun r => HasSubset.Subset (EMetric.closedBall x r) s).OrdConnected","decl":"theorem ordConnected_setOf_closedBall_subset (x : α) (s : Set α) :\n    OrdConnected { r | closedBall x r ⊆ s } :=\n  ⟨fun _ _ _ h₁ _ h₂ => (closedBall_subset_closedBall h₂.2).trans h₁⟩\n\n"}
{"name":"EMetric.ordConnected_setOf_ball_subset","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\ns : Set α\n⊢ (setOf fun r => HasSubset.Subset (EMetric.ball x r) s).OrdConnected","decl":"theorem ordConnected_setOf_ball_subset (x : α) (s : Set α) : OrdConnected { r | ball x r ⊆ s } :=\n  ⟨fun _ _ _ h₁ _ h₂ => (ball_subset_ball h₂.2).trans h₁⟩\n\n"}
{"name":"EMetric.ball_zero","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\n⊢ Eq (EMetric.ball x 0) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem ball_zero : ball x 0 = ∅ := by rw [EMetric.ball_eq_empty_iff]\n\n"}
{"name":"EMetric.nhds_basis_eball","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\n⊢ (nhds x).HasBasis (fun ε => LT.lt 0 ε) (EMetric.ball x)","decl":"theorem nhds_basis_eball : (𝓝 x).HasBasis (fun ε : ℝ≥0∞ => 0 < ε) (ball x) :=\n  nhds_basis_uniformity uniformity_basis_edist\n\n"}
{"name":"EMetric.nhdsWithin_basis_eball","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\ns : Set α\n⊢ (nhdsWithin x s).HasBasis (fun ε => LT.lt 0 ε) fun ε => Inter.inter (EMetric.ball x ε) s","decl":"theorem nhdsWithin_basis_eball : (𝓝[s] x).HasBasis (fun ε : ℝ≥0∞ => 0 < ε) fun ε => ball x ε ∩ s :=\n  nhdsWithin_hasBasis nhds_basis_eball s\n\n"}
{"name":"EMetric.nhds_basis_closed_eball","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\n⊢ (nhds x).HasBasis (fun ε => LT.lt 0 ε) (EMetric.closedBall x)","decl":"theorem nhds_basis_closed_eball : (𝓝 x).HasBasis (fun ε : ℝ≥0∞ => 0 < ε) (closedBall x) :=\n  nhds_basis_uniformity uniformity_basis_edist_le\n\n"}
{"name":"EMetric.nhdsWithin_basis_closed_eball","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\ns : Set α\n⊢ (nhdsWithin x s).HasBasis (fun ε => LT.lt 0 ε) fun ε => Inter.inter (EMetric.closedBall x ε) s","decl":"theorem nhdsWithin_basis_closed_eball :\n    (𝓝[s] x).HasBasis (fun ε : ℝ≥0∞ => 0 < ε) fun ε => closedBall x ε ∩ s :=\n  nhdsWithin_hasBasis nhds_basis_closed_eball s\n\n"}
{"name":"EMetric.nhds_eq","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\n⊢ Eq (nhds x) (iInf fun ε => iInf fun h => Filter.principal (EMetric.ball x ε))","decl":"theorem nhds_eq : 𝓝 x = ⨅ ε > 0, 𝓟 (ball x ε) :=\n  nhds_basis_eball.eq_biInf\n\n"}
{"name":"EMetric.mem_nhds_iff","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\ns : Set α\n⊢ Iff (Membership.mem (nhds x) s) (Exists fun ε => And (GT.gt ε 0) (HasSubset.Subset (EMetric.ball x ε) s))","decl":"theorem mem_nhds_iff : s ∈ 𝓝 x ↔ ∃ ε > 0, ball x ε ⊆ s :=\n  nhds_basis_eball.mem_iff\n\n"}
{"name":"EMetric.mem_nhdsWithin_iff","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\ns t : Set α\n⊢ Iff (Membership.mem (nhdsWithin x t) s) (Exists fun ε => And (GT.gt ε 0) (HasSubset.Subset (Inter.inter (EMetric.ball x ε) t) s))","decl":"theorem mem_nhdsWithin_iff : s ∈ 𝓝[t] x ↔ ∃ ε > 0, ball x ε ∩ t ⊆ s :=\n  nhdsWithin_basis_eball.mem_iff\n\n"}
{"name":"EMetric.tendsto_nhdsWithin_nhdsWithin","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoEMetricSpace α\ns : Set α\ninst✝ : PseudoEMetricSpace β\nf : α → β\nt : Set β\na : α\nb : β\n⊢ Iff (Filter.Tendsto f (nhdsWithin a s) (nhdsWithin b t)) (∀ (ε : ENNReal), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ ⦃x : α⦄, Membership.mem s x → LT.lt (EDist.edist x a) δ → And (Membership.mem t (f x)) (LT.lt (EDist.edist (f x) b) ε)))","decl":"theorem tendsto_nhdsWithin_nhdsWithin {t : Set β} {a b} :\n    Tendsto f (𝓝[s] a) (𝓝[t] b) ↔\n      ∀ ε > 0, ∃ δ > 0, ∀ ⦃x⦄, x ∈ s → edist x a < δ → f x ∈ t ∧ edist (f x) b < ε :=\n  (nhdsWithin_basis_eball.tendsto_iff nhdsWithin_basis_eball).trans <|\n    forall₂_congr fun ε _ => exists_congr fun δ => and_congr_right fun _ =>\n      forall_congr' fun x => by simp; tauto\n\n"}
{"name":"EMetric.tendsto_nhdsWithin_nhds","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoEMetricSpace α\ns : Set α\ninst✝ : PseudoEMetricSpace β\nf : α → β\na : α\nb : β\n⊢ Iff (Filter.Tendsto f (nhdsWithin a s) (nhds b)) (∀ (ε : ENNReal), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ {x : α}, Membership.mem s x → LT.lt (EDist.edist x a) δ → LT.lt (EDist.edist (f x) b) ε))","decl":"theorem tendsto_nhdsWithin_nhds {a b} :\n    Tendsto f (𝓝[s] a) (𝓝 b) ↔\n      ∀ ε > 0, ∃ δ > 0, ∀ {x : α}, x ∈ s → edist x a < δ → edist (f x) b < ε := by\n  rw [← nhdsWithin_univ b, tendsto_nhdsWithin_nhdsWithin]\n  simp only [mem_univ, true_and]\n\n"}
{"name":"EMetric.tendsto_nhds_nhds","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nf : α → β\na : α\nb : β\n⊢ Iff (Filter.Tendsto f (nhds a) (nhds b)) (∀ (ε : ENNReal), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ ⦃x : α⦄, LT.lt (EDist.edist x a) δ → LT.lt (EDist.edist (f x) b) ε))","decl":"theorem tendsto_nhds_nhds {a b} :\n    Tendsto f (𝓝 a) (𝓝 b) ↔ ∀ ε > 0, ∃ δ > 0, ∀ ⦃x⦄, edist x a < δ → edist (f x) b < ε :=\n  nhds_basis_eball.tendsto_iff nhds_basis_eball\n\n"}
{"name":"EMetric.isOpen_iff","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns : Set α\n⊢ Iff (IsOpen s) (∀ (x : α), Membership.mem s x → Exists fun ε => And (GT.gt ε 0) (HasSubset.Subset (EMetric.ball x ε) s))","decl":"theorem isOpen_iff : IsOpen s ↔ ∀ x ∈ s, ∃ ε > 0, ball x ε ⊆ s := by\n  simp [isOpen_iff_nhds, mem_nhds_iff]\n\n"}
{"name":"EMetric.isOpen_ball","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\nε : ENNReal\n⊢ IsOpen (EMetric.ball x ε)","decl":"theorem isOpen_ball : IsOpen (ball x ε) :=\n  isOpen_iff.2 fun _ => exists_ball_subset_ball\n\n"}
{"name":"EMetric.isClosed_ball_top","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\n⊢ IsClosed (EMetric.ball x Top.top)","decl":"theorem isClosed_ball_top : IsClosed (ball x ⊤) :=\n  isOpen_compl_iff.1 <| isOpen_iff.2 fun _y hy =>\n    ⟨⊤, ENNReal.coe_lt_top, fun _z hzy hzx =>\n      hy (edistLtTopSetoid.trans (edistLtTopSetoid.symm hzy) hzx)⟩\n\n"}
{"name":"EMetric.ball_mem_nhds","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\nε : ENNReal\nε0 : LT.lt 0 ε\n⊢ Membership.mem (nhds x) (EMetric.ball x ε)","decl":"theorem ball_mem_nhds (x : α) {ε : ℝ≥0∞} (ε0 : 0 < ε) : ball x ε ∈ 𝓝 x :=\n  isOpen_ball.mem_nhds (mem_ball_self ε0)\n\n"}
{"name":"EMetric.closedBall_mem_nhds","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\nε : ENNReal\nε0 : LT.lt 0 ε\n⊢ Membership.mem (nhds x) (EMetric.closedBall x ε)","decl":"theorem closedBall_mem_nhds (x : α) {ε : ℝ≥0∞} (ε0 : 0 < ε) : closedBall x ε ∈ 𝓝 x :=\n  mem_of_superset (ball_mem_nhds x ε0) ball_subset_closedBall\n\n"}
{"name":"EMetric.ball_prod_same","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nx : α\ny : β\nr : ENNReal\n⊢ Eq (SProd.sprod (EMetric.ball x r) (EMetric.ball y r)) (EMetric.ball { fst := x, snd := y } r)","decl":"theorem ball_prod_same [PseudoEMetricSpace β] (x : α) (y : β) (r : ℝ≥0∞) :\n    ball x r ×ˢ ball y r = ball (x, y) r :=\n  ext fun z => by simp [Prod.edist_eq]\n\n"}
{"name":"EMetric.closedBall_prod_same","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nx : α\ny : β\nr : ENNReal\n⊢ Eq (SProd.sprod (EMetric.closedBall x r) (EMetric.closedBall y r)) (EMetric.closedBall { fst := x, snd := y } r)","decl":"theorem closedBall_prod_same [PseudoEMetricSpace β] (x : α) (y : β) (r : ℝ≥0∞) :\n    closedBall x r ×ˢ closedBall y r = closedBall (x, y) r :=\n  ext fun z => by simp [Prod.edist_eq]\n\n"}
{"name":"EMetric.mem_closure_iff","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\ns : Set α\n⊢ Iff (Membership.mem (closure s) x) (∀ (ε : ENNReal), GT.gt ε 0 → Exists fun y => And (Membership.mem s y) (LT.lt (EDist.edist x y) ε))","decl":"/-- ε-characterization of the closure in pseudoemetric spaces -/\ntheorem mem_closure_iff : x ∈ closure s ↔ ∀ ε > 0, ∃ y ∈ s, edist x y < ε :=\n  (mem_closure_iff_nhds_basis nhds_basis_eball).trans <| by simp only [mem_ball, edist_comm x]\n\n"}
{"name":"EMetric.tendsto_nhds","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝ : PseudoEMetricSpace α\nf : Filter β\nu : β → α\na : α\n⊢ Iff (Filter.Tendsto u f (nhds a)) (∀ (ε : ENNReal), GT.gt ε 0 → Filter.Eventually (fun x => LT.lt (EDist.edist (u x) a) ε) f)","decl":"theorem tendsto_nhds {f : Filter β} {u : β → α} {a : α} :\n    Tendsto u f (𝓝 a) ↔ ∀ ε > 0, ∀ᶠ x in f, edist (u x) a < ε :=\n  nhds_basis_eball.tendsto_right_iff\n\n"}
{"name":"EMetric.tendsto_atTop","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝² : PseudoEMetricSpace α\ninst✝¹ : Nonempty β\ninst✝ : SemilatticeSup β\nu : β → α\na : α\n⊢ Iff (Filter.Tendsto u Filter.atTop (nhds a)) (∀ (ε : ENNReal), GT.gt ε 0 → Exists fun N => ∀ (n : β), GE.ge n N → LT.lt (EDist.edist (u n) a) ε)","decl":"theorem tendsto_atTop [Nonempty β] [SemilatticeSup β] {u : β → α} {a : α} :\n    Tendsto u atTop (𝓝 a) ↔ ∀ ε > 0, ∃ N, ∀ n ≥ N, edist (u n) a < ε :=\n  (atTop_basis.tendsto_iff nhds_basis_eball).trans <| by\n    simp only [exists_prop, true_and, mem_Ici, mem_ball]\n\n"}
{"name":"EMetric.subset_countable_closure_of_almost_dense_set","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns : Set α\nhs : ∀ (ε : ENNReal), GT.gt ε 0 → Exists fun t => And t.Countable (HasSubset.Subset s (Set.iUnion fun x => Set.iUnion fun h => EMetric.closedBall x ε))\n⊢ Exists fun t => And (HasSubset.Subset t s) (And t.Countable (HasSubset.Subset s (closure t)))","decl":"/-- For a set `s` in a pseudo emetric space, if for every `ε > 0` there exists a countable\nset that is `ε`-dense in `s`, then there exists a countable subset `t ⊆ s` that is dense in `s`. -/\ntheorem subset_countable_closure_of_almost_dense_set (s : Set α)\n    (hs : ∀ ε > 0, ∃ t : Set α, t.Countable ∧ s ⊆ ⋃ x ∈ t, closedBall x ε) :\n    ∃ t, t ⊆ s ∧ t.Countable ∧ s ⊆ closure t := by\n  rcases s.eq_empty_or_nonempty with (rfl | ⟨x₀, hx₀⟩)\n  · exact ⟨∅, empty_subset _, countable_empty, empty_subset _⟩\n  choose! T hTc hsT using fun n : ℕ => hs n⁻¹ (by simp)\n  have : ∀ r x, ∃ y ∈ s, closedBall x r ∩ s ⊆ closedBall y (r * 2) := fun r x => by\n    rcases (closedBall x r ∩ s).eq_empty_or_nonempty with (he | ⟨y, hxy, hys⟩)\n    · refine ⟨x₀, hx₀, ?_⟩\n      rw [he]\n      exact empty_subset _\n    · refine ⟨y, hys, fun z hz => ?_⟩\n      calc\n        edist z y ≤ edist z x + edist y x := edist_triangle_right _ _ _\n        _ ≤ r + r := add_le_add hz.1 hxy\n        _ = r * 2 := (mul_two r).symm\n  choose f hfs hf using this\n  refine\n    ⟨⋃ n : ℕ, f n⁻¹ '' T n, iUnion_subset fun n => image_subset_iff.2 fun z _ => hfs _ _,\n      countable_iUnion fun n => (hTc n).image _, ?_⟩\n  refine fun x hx => mem_closure_iff.2 fun ε ε0 => ?_\n  rcases ENNReal.exists_inv_nat_lt (ENNReal.half_pos ε0.lt.ne').ne' with ⟨n, hn⟩\n  rcases mem_iUnion₂.1 (hsT n hx) with ⟨y, hyn, hyx⟩\n  refine ⟨f n⁻¹ y, mem_iUnion.2 ⟨n, mem_image_of_mem _ hyn⟩, ?_⟩\n  calc\n    edist x (f n⁻¹ y) ≤ (n : ℝ≥0∞)⁻¹ * 2 := hf _ _ ⟨hyx, hx⟩\n    _ < ε := ENNReal.mul_lt_of_lt_div hn\n\n"}
{"name":"TopologicalSpace.IsSeparable.exists_countable_dense_subset","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns : Set α\nhs : TopologicalSpace.IsSeparable s\n⊢ Exists fun t => And (HasSubset.Subset t s) (And t.Countable (HasSubset.Subset s (closure t)))","decl":"open TopologicalSpace in\n/-- If a set `s` is separable in a (pseudo extended) metric space, then it admits a countable dense\nsubset. This is not obvious, as the countable set whose closure covers `s` given by the definition\nof separability does not need in general to be contained in `s`. -/\ntheorem _root_.TopologicalSpace.IsSeparable.exists_countable_dense_subset\n    {s : Set α} (hs : IsSeparable s) : ∃ t, t ⊆ s ∧ t.Countable ∧ s ⊆ closure t := by\n  have : ∀ ε > 0, ∃ t : Set α, t.Countable ∧ s ⊆ ⋃ x ∈ t, closedBall x ε := fun ε ε0 => by\n    rcases hs with ⟨t, htc, hst⟩\n    refine ⟨t, htc, hst.trans fun x hx => ?_⟩\n    rcases mem_closure_iff.1 hx ε ε0 with ⟨y, hyt, hxy⟩\n    exact mem_iUnion₂.2 ⟨y, hyt, mem_closedBall.2 hxy.le⟩\n  exact subset_countable_closure_of_almost_dense_set _ this\n\n"}
{"name":"TopologicalSpace.IsSeparable.separableSpace","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns : Set α\nhs : TopologicalSpace.IsSeparable s\n⊢ TopologicalSpace.SeparableSpace ↑s","decl":"open TopologicalSpace in\n/-- If a set `s` is separable, then the corresponding subtype is separable in a (pseudo extended)\nmetric space.  This is not obvious, as the countable set whose closure covers `s` does not need in\ngeneral to be contained in `s`. -/\ntheorem _root_.TopologicalSpace.IsSeparable.separableSpace {s : Set α} (hs : IsSeparable s) :\n    SeparableSpace s := by\n  rcases hs.exists_countable_dense_subset with ⟨t, hts, htc, hst⟩\n  lift t to Set s using hts\n  refine ⟨⟨t, countable_of_injective_of_countable_image Subtype.coe_injective.injOn htc, ?_⟩⟩\n  rwa [IsInducing.subtypeVal.dense_iff, Subtype.forall]\n\n"}
{"name":"EMetricSpace.eq_of_edist_eq_zero","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u\nself : EMetricSpace α\nx y : α\na✝ : Eq (EDist.edist x y) 0\n⊢ Eq x y","decl":"/-- We now define `EMetricSpace`, extending `PseudoEMetricSpace`. -/\nclass EMetricSpace (α : Type u) extends PseudoEMetricSpace α : Type u where\n  eq_of_edist_eq_zero : ∀ {x y : α}, edist x y = 0 → x = y\n\n"}
{"name":"EMetricSpace.ext","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u_2\nm m' : EMetricSpace α\nh : Eq PseudoEMetricSpace.toEDist PseudoEMetricSpace.toEDist\n⊢ Eq m m'","decl":"@[ext]\nprotected theorem EMetricSpace.ext\n    {α : Type*} {m m' : EMetricSpace α} (h : m.toEDist = m'.toEDist) : m = m' := by\n  cases m\n  cases m'\n  congr\n  ext1\n  assumption\n\n"}
{"name":"EMetricSpace.ext_iff","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"α : Type u_2\nm m' : EMetricSpace α\n⊢ Iff (Eq m m') (Eq PseudoEMetricSpace.toEDist PseudoEMetricSpace.toEDist)","decl":"@[ext]\nprotected theorem EMetricSpace.ext\n    {α : Type*} {m m' : EMetricSpace α} (h : m.toEDist = m'.toEDist) : m = m' := by\n  cases m\n  cases m'\n  congr\n  ext1\n  assumption\n\n"}
{"name":"edist_eq_zero","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"γ : Type w\ninst✝ : EMetricSpace γ\nx y : γ\n⊢ Iff (Eq (EDist.edist x y) 0) (Eq x y)","decl":"/-- Characterize the equality of points by the vanishing of their extended distance -/\n@[simp]\ntheorem edist_eq_zero {x y : γ} : edist x y = 0 ↔ x = y :=\n  ⟨eq_of_edist_eq_zero, fun h => h ▸ edist_self _⟩\n\n"}
{"name":"zero_eq_edist","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"γ : Type w\ninst✝ : EMetricSpace γ\nx y : γ\n⊢ Iff (Eq 0 (EDist.edist x y)) (Eq x y)","decl":"@[simp]\ntheorem zero_eq_edist {x y : γ} : 0 = edist x y ↔ x = y := eq_comm.trans edist_eq_zero\n\n"}
{"name":"edist_le_zero","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"γ : Type w\ninst✝ : EMetricSpace γ\nx y : γ\n⊢ Iff (LE.le (EDist.edist x y) 0) (Eq x y)","decl":"theorem edist_le_zero {x y : γ} : edist x y ≤ 0 ↔ x = y :=\n  nonpos_iff_eq_zero.trans edist_eq_zero\n\n"}
{"name":"edist_pos","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"γ : Type w\ninst✝ : EMetricSpace γ\nx y : γ\n⊢ Iff (LT.lt 0 (EDist.edist x y)) (Ne x y)","decl":"@[simp]\ntheorem edist_pos {x y : γ} : 0 < edist x y ↔ x ≠ y := by simp [← not_le]\n\n"}
{"name":"eq_of_forall_edist_le","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"γ : Type w\ninst✝ : EMetricSpace γ\nx y : γ\nh : ∀ (ε : ENNReal), GT.gt ε 0 → LE.le (EDist.edist x y) ε\n⊢ Eq x y","decl":"/-- Two points coincide if their distance is `< ε` for all positive ε -/\ntheorem eq_of_forall_edist_le {x y : γ} (h : ∀ ε > 0, edist x y ≤ ε) : x = y :=\n  eq_of_edist_eq_zero (eq_of_le_of_forall_lt_imp_le_of_dense bot_le h)\n\n"}
{"name":"uniformity_edist","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"γ : Type w\ninst✝ : EMetricSpace γ\n⊢ Eq (uniformity γ) (iInf fun ε => iInf fun h => Filter.principal (setOf fun p => LT.lt (EDist.edist p.1 p.2) ε))","decl":"/-- Reformulation of the uniform structure in terms of the extended distance -/\ntheorem uniformity_edist : 𝓤 γ = ⨅ ε > 0, 𝓟 { p : γ × γ | edist p.1 p.2 < ε } :=\n  PseudoEMetricSpace.uniformity_edist\n\n"}
{"name":"edist_ofMul","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"X : Type u_1\ninst✝ : EDist X\na b : X\n⊢ Eq (EDist.edist (Additive.ofMul a) (Additive.ofMul b)) (EDist.edist a b)","decl":"@[simp]\ntheorem edist_ofMul (a b : X) : edist (ofMul a) (ofMul b) = edist a b :=\n  rfl\n\n"}
{"name":"edist_ofAdd","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"X : Type u_1\ninst✝ : EDist X\na b : X\n⊢ Eq (EDist.edist (Multiplicative.ofAdd a) (Multiplicative.ofAdd b)) (EDist.edist a b)","decl":"@[simp]\ntheorem edist_ofAdd (a b : X) : edist (ofAdd a) (ofAdd b) = edist a b :=\n  rfl\n\n"}
{"name":"edist_toMul","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"X : Type u_1\ninst✝ : EDist X\na b : Additive X\n⊢ Eq (EDist.edist (Additive.toMul a) (Additive.toMul b)) (EDist.edist a b)","decl":"@[simp]\ntheorem edist_toMul (a b : Additive X) : edist a.toMul b.toMul = edist a b :=\n  rfl\n\n"}
{"name":"edist_toAdd","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"X : Type u_1\ninst✝ : EDist X\na b : Multiplicative X\n⊢ Eq (EDist.edist (Multiplicative.toAdd a) (Multiplicative.toAdd b)) (EDist.edist a b)","decl":"@[simp]\ntheorem edist_toAdd (a b : Multiplicative X) : edist a.toAdd b.toAdd = edist a b :=\n  rfl\n\n"}
{"name":"edist_toDual","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"X : Type u_1\ninst✝ : EDist X\na b : X\n⊢ Eq (EDist.edist (OrderDual.toDual a) (OrderDual.toDual b)) (EDist.edist a b)","decl":"@[simp]\ntheorem edist_toDual (a b : X) : edist (toDual a) (toDual b) = edist a b :=\n  rfl\n\n"}
{"name":"edist_ofDual","module":"Mathlib.Topology.EMetricSpace.Defs","initialProofState":"X : Type u_1\ninst✝ : EDist X\na b : OrderDual X\n⊢ Eq (EDist.edist (OrderDual.ofDual a) (OrderDual.ofDual b)) (EDist.edist a b)","decl":"@[simp]\ntheorem edist_ofDual (a b : Xᵒᵈ) : edist (ofDual a) (ofDual b) = edist a b :=\n  rfl\n\n"}
