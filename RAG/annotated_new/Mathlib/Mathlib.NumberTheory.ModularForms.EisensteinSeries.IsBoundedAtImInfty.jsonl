{"name":"EisensteinSeries.summable_norm_eisSummand","module":"Mathlib.NumberTheory.ModularForms.EisensteinSeries.IsBoundedAtImInfty","initialProofState":"k : Int\nhk : LE.le 3 k\nz : UpperHalfPlane\n⊢ Summable fun x => Norm.norm (EisensteinSeries.eisSummand k x z)","decl":"lemma summable_norm_eisSummand {k : ℤ} (hk : 3 ≤ k) (z : ℍ) :\n    Summable fun (x : Fin 2 → ℤ) ↦ ‖(eisSummand k x z)‖ := by\n  have hk' : (2 : ℝ) < k := by norm_cast\n  apply ((summable_one_div_norm_rpow hk').mul_left <| r z ^ (-k : ℝ)).of_nonneg_of_le\n    (fun _ => Complex.abs.nonneg _)\n  intro b\n  simp only [eisSummand, map_zpow₀]\n  exact_mod_cast summand_bound z (show 0 ≤ (k : ℝ) by positivity) b\n\n"}
{"name":"EisensteinSeries.abs_le_tsum_abs","module":"Mathlib.NumberTheory.ModularForms.EisensteinSeries.IsBoundedAtImInfty","initialProofState":"N : Nat\na : Fin 2 → ZMod N\nk : Int\nhk : LE.le 3 k\nz : UpperHalfPlane\n⊢ LE.le (Complex.abs (eisensteinSeries a k z)) (tsum fun x => Complex.abs (EisensteinSeries.eisSummand k x z))","decl":"/-- The absolute value of the restricted sum is less than the full sum of the absolute values. -/\nlemma abs_le_tsum_abs (N : ℕ) (a : Fin 2 → ZMod N) (k : ℤ) (hk : 3 ≤ k) (z : ℍ) :\n    Complex.abs (eisensteinSeries a k z) ≤ ∑' (x : Fin 2 → ℤ), Complex.abs (eisSummand k x z) := by\n  simp_rw [← Complex.norm_eq_abs, eisensteinSeries]\n  apply le_trans (norm_tsum_le_tsum_norm ((summable_norm_eisSummand hk z).subtype _))\n    (tsum_subtype_le (fun (x : Fin 2 → ℤ) ↦ ‖(eisSummand k x z)‖) _ (fun _ ↦ norm_nonneg _)\n      (summable_norm_eisSummand hk z))\n\n"}
{"name":"EisensteinSeries.isBoundedAtImInfty_eisensteinSeries_SIF","module":"Mathlib.NumberTheory.ModularForms.EisensteinSeries.IsBoundedAtImInfty","initialProofState":"N : PNat\na : Fin 2 → ZMod ↑N\nk : Int\nhk : LE.le 3 k\nA : Matrix.SpecialLinearGroup (Fin 2) Int\n⊢ UpperHalfPlane.IsBoundedAtImInfty (SlashAction.map Complex k A (EisensteinSeries.eisensteinSeries_SIF a k).toFun)","decl":"/-- Eisenstein series are bounded at infinity. -/\ntheorem isBoundedAtImInfty_eisensteinSeries_SIF {N : ℕ+} (a : Fin 2 → ZMod N) {k : ℤ} (hk : 3 ≤ k)\n    (A : SL(2, ℤ)) : IsBoundedAtImInfty ((eisensteinSeries_SIF a k).toFun ∣[k] A) := by\n  simp_rw [UpperHalfPlane.isBoundedAtImInfty_iff, eisensteinSeries_SIF] at *\n  refine ⟨∑'(x : Fin 2 → ℤ), r ⟨⟨N, 2⟩, Nat.ofNat_pos⟩ ^ (-k) * ‖x‖ ^ (-k), 2, ?_⟩\n  intro z hz\n  obtain ⟨n, hn⟩ := (ModularGroup_T_zpow_mem_verticalStrip z N.2)\n  rw [eisensteinSeries_slash_apply, ← eisensteinSeries_SIF_apply,\n    ← T_zpow_width_invariant N k n (eisensteinSeries_SIF (a ᵥ* A) k) z]\n  apply le_trans (abs_le_tsum_abs N (a ᵥ* A) k hk _)\n  have hk' : (2 : ℝ) < k := by norm_cast\n  apply tsum_le_tsum _ (summable_norm_eisSummand hk _)\n  · exact_mod_cast (summable_one_div_norm_rpow hk').mul_left <| r ⟨⟨N, 2⟩, Nat.ofNat_pos⟩ ^ (-k)\n  · intro x\n    simp_rw [eisSummand, norm_zpow]\n    exact_mod_cast\n      summand_bound_of_mem_verticalStrip (lt_trans two_pos hk').le x two_pos\n      (verticalStrip_anti_right N hz hn)\n\n"}
