{"name":"SimpleGraph.set_walk_self_length_zero_eq","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.WalkCounting","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\n⊢ Eq (setOf fun p => Eq p.length 0) (Singleton.singleton SimpleGraph.Walk.nil)","decl":"theorem set_walk_self_length_zero_eq (u : V) : {p : G.Walk u u | p.length = 0} = {Walk.nil} := by\n  ext p\n  simp\n\n"}
{"name":"SimpleGraph.set_walk_length_zero_eq_of_ne","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.WalkCounting","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nh : Ne u v\n⊢ Eq (setOf fun p => Eq p.length 0) EmptyCollection.emptyCollection","decl":"theorem set_walk_length_zero_eq_of_ne {u v : V} (h : u ≠ v) :\n    {p : G.Walk u v | p.length = 0} = ∅ := by\n  ext p\n  simp only [Set.mem_setOf_eq, Set.mem_empty_iff_false, iff_false]\n  exact fun h' => absurd (Walk.eq_of_length_eq_zero h') h\n\n"}
{"name":"SimpleGraph.set_walk_length_succ_eq","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.WalkCounting","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nn : Nat\n⊢ Eq (setOf fun p => Eq p.length n.succ) (Set.iUnion fun w => Set.iUnion fun h => Set.image (SimpleGraph.Walk.cons h) (setOf fun p' => Eq p'.length n))","decl":"theorem set_walk_length_succ_eq (u v : V) (n : ℕ) :\n    {p : G.Walk u v | p.length = n.succ} =\n      ⋃ (w : V) (h : G.Adj u w), Walk.cons h '' {p' : G.Walk w v | p'.length = n} := by\n  ext p\n  cases' p with _ _ w _ huw pwv\n  · simp [eq_comm]\n  · simp only [Nat.succ_eq_add_one, Set.mem_setOf_eq, Walk.length_cons, add_left_inj,\n      Set.mem_iUnion, Set.mem_image, exists_prop]\n    constructor\n    · rintro rfl\n      exact ⟨w, huw, pwv, rfl, rfl⟩\n    · rintro ⟨w, huw, pwv, rfl, rfl, rfl⟩\n      rfl\n\n"}
{"name":"SimpleGraph.walkLengthTwoEquivCommonNeighbors_symm_apply_coe","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.WalkCounting","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nw : ↑(G.commonNeighbors u v)\n⊢ Eq (↑((G.walkLengthTwoEquivCommonNeighbors u v).symm w)) ((SimpleGraph.Adj.toWalk ⋯).concat ⋯)","decl":"/-- Walks of length two from `u` to `v` correspond bijectively to common neighbours of `u` and `v`.\nNote that `u` and `v` may be the same. -/\n@[simps]\ndef walkLengthTwoEquivCommonNeighbors (u v : V) :\n    {p : G.Walk u v // p.length = 2} ≃ G.commonNeighbors u v where\n  toFun p := ⟨p.val.snd, match p with\n    | ⟨.cons _ (.cons _ .nil), _⟩ => ⟨‹G.Adj u _›, ‹G.Adj _ v›.symm⟩⟩\n  invFun w := ⟨w.prop.1.toWalk.concat w.prop.2.symm, rfl⟩\n  left_inv | ⟨.cons _ (.cons _ .nil), hp⟩ => by rfl\n  right_inv _ := rfl\n\n"}
{"name":"SimpleGraph.walkLengthTwoEquivCommonNeighbors_apply_coe","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.WalkCounting","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : Subtype fun p => Eq p.length 2\n⊢ Eq (↑((G.walkLengthTwoEquivCommonNeighbors u v) p)) (↑p).snd","decl":"/-- Walks of length two from `u` to `v` correspond bijectively to common neighbours of `u` and `v`.\nNote that `u` and `v` may be the same. -/\n@[simps]\ndef walkLengthTwoEquivCommonNeighbors (u v : V) :\n    {p : G.Walk u v // p.length = 2} ≃ G.commonNeighbors u v where\n  toFun p := ⟨p.val.snd, match p with\n    | ⟨.cons _ (.cons _ .nil), _⟩ => ⟨‹G.Adj u _›, ‹G.Adj _ v›.symm⟩⟩\n  invFun w := ⟨w.prop.1.toWalk.concat w.prop.2.symm, rfl⟩\n  left_inv | ⟨.cons _ (.cons _ .nil), hp⟩ => by rfl\n  right_inv _ := rfl\n\n"}
{"name":"SimpleGraph.coe_finsetWalkLength_eq","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.WalkCounting","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝¹ : DecidableEq V\ninst✝ : G.LocallyFinite\nn : Nat\nu v : V\n⊢ Eq (↑(G.finsetWalkLength n u v)) (setOf fun p => Eq p.length n)","decl":"theorem coe_finsetWalkLength_eq (n : ℕ) (u v : V) :\n    (G.finsetWalkLength n u v : Set (G.Walk u v)) = {p : G.Walk u v | p.length = n} := by\n  induction' n with n ih generalizing u v\n  · obtain rfl | huv := eq_or_ne u v <;> simp [finsetWalkLength, set_walk_length_zero_eq_of_ne, *]\n  · simp only [finsetWalkLength, set_walk_length_succ_eq, Finset.coe_biUnion, Finset.mem_coe,\n      Finset.mem_univ, Set.iUnion_true]\n    ext p\n    simp only [mem_neighborSet, Finset.coe_map, Embedding.coeFn_mk, Set.iUnion_coe_set,\n      Set.mem_iUnion, Set.mem_image, Finset.mem_coe, Set.mem_setOf_eq]\n    congr!\n    rename_i w _ q\n    have := Set.ext_iff.mp (ih w v) q\n    simp only [Finset.mem_coe, Set.mem_setOf_eq] at this\n    rw [← this]\n\n"}
{"name":"SimpleGraph.mem_finsetWalkLength_iff","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.WalkCounting","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝¹ : DecidableEq V\ninst✝ : G.LocallyFinite\nn : Nat\nu v : V\np : G.Walk u v\n⊢ Iff (Membership.mem (G.finsetWalkLength n u v) p) (Eq p.length n)","decl":"theorem mem_finsetWalkLength_iff {n : ℕ} {u v : V} {p : G.Walk u v} :\n    p ∈ G.finsetWalkLength n u v ↔ p.length = n :=\n  Set.ext_iff.mp (G.coe_finsetWalkLength_eq n u v) p\n\n"}
{"name":"SimpleGraph.coe_finsetWalkLengthLT_eq","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.WalkCounting","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝¹ : DecidableEq V\ninst✝ : G.LocallyFinite\nn : Nat\nu v : V\n⊢ Eq (↑(G.finsetWalkLengthLT n u v)) (setOf fun p => LT.lt p.length n)","decl":"open Finset in\ntheorem coe_finsetWalkLengthLT_eq (n : ℕ) (u v : V) :\n    (G.finsetWalkLengthLT n u v : Set (G.Walk u v)) = {p : G.Walk u v | p.length < n} := by\n  ext p\n  simp [finsetWalkLengthLT, mem_coe, mem_disjiUnion, mem_finsetWalkLength_iff]\n\n"}
{"name":"SimpleGraph.mem_finsetWalkLengthLT_iff","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.WalkCounting","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝¹ : DecidableEq V\ninst✝ : G.LocallyFinite\nn : Nat\nu v : V\np : G.Walk u v\n⊢ Iff (Membership.mem (G.finsetWalkLengthLT n u v) p) (LT.lt p.length n)","decl":"theorem mem_finsetWalkLengthLT_iff {n : ℕ} {u v : V} {p : G.Walk u v} :\n    p ∈ G.finsetWalkLengthLT n u v ↔ p.length < n :=\n  Set.ext_iff.mp (G.coe_finsetWalkLengthLT_eq n u v) p\n\n"}
{"name":"SimpleGraph.set_walk_length_toFinset_eq","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.WalkCounting","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝¹ : DecidableEq V\ninst✝ : G.LocallyFinite\nn : Nat\nu v : V\n⊢ Eq (setOf fun p => Eq p.length n).toFinset (G.finsetWalkLength n u v)","decl":"theorem set_walk_length_toFinset_eq (n : ℕ) (u v : V) :\n    {p : G.Walk u v | p.length = n}.toFinset = G.finsetWalkLength n u v := by\n  ext p\n  simp [← coe_finsetWalkLength_eq]\n\n/- See `SimpleGraph.adjMatrix_pow_apply_eq_card_walk` for the cardinality in terms of the `n`th\npower of the adjacency matrix. -/\n"}
{"name":"SimpleGraph.card_set_walk_length_eq","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.WalkCounting","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝¹ : DecidableEq V\ninst✝ : G.LocallyFinite\nu v : V\nn : Nat\n⊢ Eq (Fintype.card ↑(setOf fun p => Eq p.length n)) (G.finsetWalkLength n u v).card","decl":"theorem card_set_walk_length_eq (u v : V) (n : ℕ) :\n    Fintype.card {p : G.Walk u v | p.length = n} = #(G.finsetWalkLength n u v) :=\n  Fintype.card_ofFinset (G.finsetWalkLength n u v) fun p => by\n    rw [← Finset.mem_coe, coe_finsetWalkLength_eq]\n\n"}
{"name":"SimpleGraph.reachable_iff_exists_finsetWalkLength_nonempty","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.WalkCounting","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝² : DecidableEq V\ninst✝¹ : Fintype V\ninst✝ : DecidableRel G.Adj\nu v : V\n⊢ Iff (G.Reachable u v) (Exists fun n => (G.finsetWalkLength (↑n) u v).Nonempty)","decl":"theorem reachable_iff_exists_finsetWalkLength_nonempty (u v : V) :\n    G.Reachable u v ↔ ∃ n : Fin (Fintype.card V), (G.finsetWalkLength n u v).Nonempty := by\n  constructor\n  · intro r\n    refine r.elim_path fun p => ?_\n    refine ⟨⟨_, p.isPath.length_lt⟩, p, ?_⟩\n    simp [mem_finsetWalkLength_iff]\n  · rintro ⟨_, p, _⟩\n    exact ⟨p⟩\n\n"}
{"name":"SimpleGraph.disjiUnion_supp_toFinset_eq_supp_toFinset","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.WalkCounting","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝⁴ : DecidableEq V\ninst✝³ : Fintype V\ninst✝² : DecidableRel G.Adj\nG' : SimpleGraph V\nh : LE.le G G'\nc' : G'.ConnectedComponent\ninst✝¹ : Fintype ↑c'.supp\ninst✝ : DecidablePred fun c => HasSubset.Subset c.supp c'.supp\n⊢ Eq ((Finset.filter (fun c => HasSubset.Subset c.supp c'.supp) Finset.univ).disjiUnion (fun c => c.supp.toFinset) ⋯) c'.supp.toFinset","decl":"variable {G} in\nlemma disjiUnion_supp_toFinset_eq_supp_toFinset {G' : SimpleGraph V} (h : G ≤ G')\n    (c' : ConnectedComponent G') [Fintype c'.supp]\n    [DecidablePred fun c : G.ConnectedComponent ↦ c.supp ⊆ c'.supp] :\n    .disjiUnion {c : ConnectedComponent G | c.supp ⊆ c'.supp} (fun c ↦ c.supp.toFinset)\n      (fun x _ y _ hxy ↦ by simpa using pairwise_disjoint_supp_connectedComponent _ hxy) =\n      c'.supp.toFinset :=\n  Finset.coe_injective <| by simpa using ConnectedComponent.biUnion_supp_eq_supp h _\n\n"}
{"name":"SimpleGraph.ConnectedComponent.odd_card_supp_iff_odd_subcomponents","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.WalkCounting","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : Finite V\nG' : SimpleGraph V\nh : LE.le G G'\nc' : G'.ConnectedComponent\n⊢ Iff (Odd (Nat.card ↑c'.supp)) (Odd (Nat.card ↑(setOf fun c => And (HasSubset.Subset c.supp c'.supp) (Odd (Nat.card ↑c.supp)))))","decl":"lemma ConnectedComponent.odd_card_supp_iff_odd_subcomponents [Finite V] {G'}\n    (h : G ≤ G') (c' : ConnectedComponent G') :\n    Odd (Nat.card c'.supp) ↔ Odd (Nat.card\n    ({c : ConnectedComponent G | c.supp ⊆ c'.supp ∧ Odd (Nat.card c.supp) })) := by\n  classical\n  cases nonempty_fintype V\n  rw [Nat.card_eq_card_toFinset, ← disjiUnion_supp_toFinset_eq_supp_toFinset h]\n  simp only [Finset.card_disjiUnion, Set.toFinset_card]\n  rw [Finset.odd_sum_iff_odd_card_odd, Nat.card_eq_fintype_card, Fintype.card_ofFinset]\n  simp only [Nat.card_eq_fintype_card, Finset.filter_filter]\n  rfl\n\n"}
{"name":"SimpleGraph.odd_card_iff_odd_components","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.WalkCounting","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : Finite V\n⊢ Iff (Odd (Nat.card V)) (Odd (Nat.card ↑(setOf fun x => SimpleGraph.odd_card_iff_odd_components.match_1 G (fun x => Prop) x fun c => Odd (Nat.card ↑c.supp))))","decl":"lemma odd_card_iff_odd_components [Finite V] : Odd (Nat.card V) ↔\n    Odd (Nat.card ({(c : ConnectedComponent G) | Odd (Nat.card c.supp)})) := by\n  classical\n  cases nonempty_fintype V\n  rw [Nat.card_eq_fintype_card]\n  simp only [← (set_fintype_card_eq_univ_iff _).mpr G.iUnion_connectedComponentSupp,\n    ConnectedComponent.mem_supp_iff, Fintype.card_subtype_compl,\n    ← Set.toFinset_card, Set.toFinset_iUnion ConnectedComponent.supp]\n  rw [Finset.card_biUnion\n    (fun x _ y _ hxy ↦ Set.disjoint_toFinset.mpr (pairwise_disjoint_supp_connectedComponent _ hxy))]\n  simp_rw [Set.toFinset_card, ← Nat.card_eq_fintype_card]\n  rw [Nat.card_eq_fintype_card, Fintype.card_ofFinset]\n  exact (Finset.odd_sum_iff_odd_card_odd (fun x : G.ConnectedComponent ↦ Nat.card x.supp))\n\n"}
