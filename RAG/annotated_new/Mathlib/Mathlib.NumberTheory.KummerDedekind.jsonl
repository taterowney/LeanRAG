{"name":"conductor_eq_of_eq","module":"Mathlib.NumberTheory.KummerDedekind","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx y : S\nh : Eq ↑(Algebra.adjoin R (Singleton.singleton x)) ↑(Algebra.adjoin R (Singleton.singleton y))\n⊢ Eq (conductor R x) (conductor R y)","decl":"theorem conductor_eq_of_eq {y : S} (h : (R<x> : Set S) = R<y>) : conductor R x = conductor R y :=\n  Ideal.ext fun _ => forall_congr' fun _ => Set.ext_iff.mp h _\n\n"}
{"name":"conductor_subset_adjoin","module":"Mathlib.NumberTheory.KummerDedekind","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\n⊢ HasSubset.Subset ↑(conductor R x) ↑(Algebra.adjoin R (Singleton.singleton x))","decl":"theorem conductor_subset_adjoin : (conductor R x : Set S) ⊆ R<x> := fun y hy => by\n  simpa only [mul_one] using hy 1\n\n"}
{"name":"mem_conductor_iff","module":"Mathlib.NumberTheory.KummerDedekind","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx y : S\n⊢ Iff (Membership.mem (conductor R x) y) (∀ (b : S), Membership.mem (Algebra.adjoin R (Singleton.singleton x)) (HMul.hMul y b))","decl":"theorem mem_conductor_iff {y : S} : y ∈ conductor R x ↔ ∀ b : S, y * b ∈ R<x> :=\n  ⟨fun h => h, fun h => h⟩\n\n"}
{"name":"conductor_eq_top_of_adjoin_eq_top","module":"Mathlib.NumberTheory.KummerDedekind","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\nh : Eq (Algebra.adjoin R (Singleton.singleton x)) Top.top\n⊢ Eq (conductor R x) Top.top","decl":"theorem conductor_eq_top_of_adjoin_eq_top (h : R<x> = ⊤) : conductor R x = ⊤ := by\n  simp only [Ideal.eq_top_iff_one, mem_conductor_iff, h, mem_top, forall_const]\n\n"}
{"name":"conductor_eq_top_of_powerBasis","module":"Mathlib.NumberTheory.KummerDedekind","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\npb : PowerBasis R S\n⊢ Eq (conductor R pb.gen) Top.top","decl":"theorem conductor_eq_top_of_powerBasis (pb : PowerBasis R S) : conductor R pb.gen = ⊤ :=\n  conductor_eq_top_of_adjoin_eq_top pb.adjoin_gen_eq_top\n\n"}
{"name":"mem_coeSubmodule_conductor","module":"Mathlib.NumberTheory.KummerDedekind","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : Algebra R S\nL : Type u_3\ninst✝⁴ : CommRing L\ninst✝³ : Algebra S L\ninst✝² : Algebra R L\ninst✝¹ : IsScalarTower R S L\ninst✝ : NoZeroSMulDivisors S L\nx : S\ny : L\n⊢ Iff (Membership.mem (IsLocalization.coeSubmodule L (conductor R x)) y) (∀ (z : S), Membership.mem (Algebra.adjoin R (Singleton.singleton ((algebraMap S L) x))) (HMul.hMul y ((algebraMap S L) z)))","decl":"open IsLocalization in\nlemma mem_coeSubmodule_conductor {L} [CommRing L] [Algebra S L] [Algebra R L]\n    [IsScalarTower R S L] [NoZeroSMulDivisors S L] {x : S} {y : L} :\n    y ∈ coeSubmodule L (conductor R x) ↔ ∀ z : S,\n      y * (algebraMap S L) z ∈ Algebra.adjoin R {algebraMap S L x} := by\n  cases subsingleton_or_nontrivial L\n  · rw [Subsingleton.elim (coeSubmodule L _) ⊤, Subsingleton.elim (Algebra.adjoin R _) ⊤]; simp\n  trans ∀ z, y * (algebraMap S L) z ∈ (Algebra.adjoin R {x}).map (IsScalarTower.toAlgHom R S L)\n  · simp only [coeSubmodule, Submodule.mem_map, Algebra.linearMap_apply, Subalgebra.mem_map,\n      IsScalarTower.coe_toAlgHom']\n    constructor\n    · rintro ⟨y, hy, rfl⟩ z\n      exact ⟨_, hy z, map_mul _ _ _⟩\n    · intro H\n      obtain ⟨y, _, e⟩ := H 1\n      rw [map_one, mul_one] at e\n      subst e\n      simp only [← _root_.map_mul, (NoZeroSMulDivisors.algebraMap_injective S L).eq_iff,\n        exists_eq_right] at H\n      exact ⟨_, H, rfl⟩\n  · rw [AlgHom.map_adjoin, Set.image_singleton]; rfl\n\n"}
{"name":"prod_mem_ideal_map_of_mem_conductor","module":"Mathlib.NumberTheory.KummerDedekind","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\nI : Ideal R\np : R\nz : S\nhp : Membership.mem (Ideal.comap (algebraMap R S) (conductor R x)) p\nhz' : Membership.mem (Ideal.map (algebraMap R S) I) z\n⊢ Membership.mem (Set.image ⇑(algebraMap (Subtype fun x_1 => Membership.mem (Algebra.adjoin R (Singleton.singleton x)) x_1) S) ↑(Ideal.map (algebraMap R (Subtype fun x_1 => Membership.mem (Algebra.adjoin R (Singleton.singleton x)) x_1)) I)) (HMul.hMul ((algebraMap R S) p) z)","decl":"/-- This technical lemma tell us that if `C` is the conductor of `R<x>` and `I` is an ideal of `R`\n  then `p * (I * S) ⊆ I * R<x>` for any `p` in `C ∩ R` -/\ntheorem prod_mem_ideal_map_of_mem_conductor {p : R} {z : S}\n    (hp : p ∈ Ideal.comap (algebraMap R S) (conductor R x)) (hz' : z ∈ I.map (algebraMap R S)) :\n    algebraMap R S p * z ∈ algebraMap R<x> S '' ↑(I.map (algebraMap R R<x>)) := by\n  rw [Ideal.map, Ideal.span, Finsupp.mem_span_image_iff_linearCombination] at hz'\n  obtain ⟨l, H, H'⟩ := hz'\n  rw [Finsupp.linearCombination_apply] at H'\n  rw [← H', mul_comm, Finsupp.sum_mul]\n  have lem : ∀ {a : R}, a ∈ I → l a • algebraMap R S a * algebraMap R S p ∈\n      algebraMap R<x> S '' I.map (algebraMap R R<x>) := by\n    intro a ha\n    rw [Algebra.id.smul_eq_mul, mul_assoc, mul_comm, mul_assoc, Set.mem_image]\n    refine Exists.intro\n        (algebraMap R R<x> a * ⟨l a * algebraMap R S p,\n          show l a * algebraMap R S p ∈ R<x> from ?h⟩) ?_\n    case h =>\n      rw [mul_comm]\n      exact mem_conductor_iff.mp (Ideal.mem_comap.mp hp) _\n    · refine ⟨?_, ?_⟩\n      · rw [mul_comm]\n        apply Ideal.mul_mem_left (I.map (algebraMap R R<x>)) _ (Ideal.mem_map_of_mem _ ha)\n      · simp only [RingHom.map_mul, mul_comm (algebraMap R S p) (l a)]\n        rfl\n  refine Finset.sum_induction _ (fun u => u ∈ algebraMap R<x> S '' I.map (algebraMap R R<x>))\n      (fun a b => ?_) ?_ ?_\n  · rintro ⟨z, hz, rfl⟩ ⟨y, hy, rfl⟩\n    rw [← RingHom.map_add]\n    exact ⟨z + y, Ideal.add_mem _ (SetLike.mem_coe.mp hz) hy, rfl⟩\n  · exact ⟨0, SetLike.mem_coe.mpr <| Ideal.zero_mem _, RingHom.map_zero _⟩\n  · intro y hy\n    exact lem ((Finsupp.mem_supported _ l).mp H hy)\n\n"}
{"name":"comap_map_eq_map_adjoin_of_coprime_conductor","module":"Mathlib.NumberTheory.KummerDedekind","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\nI : Ideal R\nhx : Eq (Max.max (Ideal.comap (algebraMap R S) (conductor R x)) I) Top.top\nh_alg : Function.Injective ⇑(algebraMap (Subtype fun x_1 => Membership.mem (Algebra.adjoin R (Singleton.singleton x)) x_1) S)\n⊢ Eq (Ideal.comap (algebraMap (Subtype fun x_1 => Membership.mem (Algebra.adjoin R (Singleton.singleton x)) x_1) S) (Ideal.map (algebraMap R S) I)) (Ideal.map (algebraMap R (Subtype fun x_1 => Membership.mem (Algebra.adjoin R (Singleton.singleton x)) x_1)) I)","decl":"/-- A technical result telling us that `(I * S) ∩ R<x> = I * R<x>` for any ideal `I` of `R`. -/\ntheorem comap_map_eq_map_adjoin_of_coprime_conductor\n    (hx : (conductor R x).comap (algebraMap R S) ⊔ I = ⊤)\n    (h_alg : Function.Injective (algebraMap R<x> S)) :\n    (I.map (algebraMap R S)).comap (algebraMap R<x> S) = I.map (algebraMap R R<x>) := by\n  apply le_antisymm\n  · -- This is adapted from [Neukirch1992]. Let `C = (conductor R x)`. The idea of the proof\n    -- is that since `I` and `C ∩ R` are coprime, we have\n    -- `(I * S) ∩ R<x> ⊆ (I + C) * ((I * S) ∩ R<x>) ⊆ I * R<x> + I * C * S ⊆ I * R<x>`.\n    intro y hy\n    obtain ⟨z, hz⟩ := y\n    obtain ⟨p, hp, q, hq, hpq⟩ := Submodule.mem_sup.mp ((Ideal.eq_top_iff_one _).mp hx)\n    have temp : algebraMap R S p * z + algebraMap R S q * z = z := by\n      simp only [← add_mul, ← RingHom.map_add (algebraMap R S), hpq, map_one, one_mul]\n    suffices z ∈ algebraMap R<x> S '' I.map (algebraMap R R<x>) ↔\n        (⟨z, hz⟩ : R<x>) ∈ I.map (algebraMap R R<x>) by\n      rw [← this, ← temp]\n      obtain ⟨a, ha⟩ := (Set.mem_image _ _ _).mp (prod_mem_ideal_map_of_mem_conductor hp\n          (show z ∈ I.map (algebraMap R S) by rwa [Ideal.mem_comap] at hy))\n      use a + algebraMap R R<x> q * ⟨z, hz⟩\n      refine ⟨Ideal.add_mem (I.map (algebraMap R R<x>)) ha.left ?_, by\n          simp only [ha.right, map_add, _root_.map_mul, add_right_inj]; rfl⟩\n      rw [mul_comm]\n      exact Ideal.mul_mem_left (I.map (algebraMap R R<x>)) _ (Ideal.mem_map_of_mem _ hq)\n    refine ⟨fun h => ?_,\n      fun h => (Set.mem_image _ _ _).mpr (Exists.intro ⟨z, hz⟩ ⟨by simp [h], rfl⟩)⟩\n    obtain ⟨x₁, hx₁, hx₂⟩ := (Set.mem_image _ _ _).mp h\n    have : x₁ = ⟨z, hz⟩ := by\n      apply h_alg\n      simp only [hx₂, algebraMap_eq_smul_one]\n      rw [Submonoid.mk_smul, smul_eq_mul, mul_one]\n    rwa [← this]\n  · -- The converse inclusion is trivial\n    have : algebraMap R S = (algebraMap _ S).comp (algebraMap R R<x>) := by ext; rfl\n    rw [this, ← Ideal.map_map]\n    apply Ideal.le_comap_map\n\n"}
{"name":"quotAdjoinEquivQuotMap_apply_mk","module":"Mathlib.NumberTheory.KummerDedekind","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\nI : Ideal R\nhx : Eq (Max.max (Ideal.comap (algebraMap R S) (conductor R x)) I) Top.top\nh_alg : Function.Injective ⇑(algebraMap (Subtype fun x_1 => Membership.mem (Algebra.adjoin R (Singleton.singleton x)) x_1) S)\na : Subtype fun x_1 => Membership.mem (Algebra.adjoin R (Singleton.singleton x)) x_1\n⊢ Eq ((quotAdjoinEquivQuotMap hx h_alg) ((Ideal.Quotient.mk (Ideal.map (algebraMap R (Subtype fun x_1 => Membership.mem (Algebra.adjoin R (Singleton.singleton x)) x_1)) I)) a)) ((Ideal.Quotient.mk (Ideal.map (algebraMap R S) I)) ↑a)","decl":"@[simp]\ntheorem quotAdjoinEquivQuotMap_apply_mk (hx : (conductor R x).comap (algebraMap R S) ⊔ I = ⊤)\n    (h_alg : Function.Injective (algebraMap R<x> S)) (a : R<x>) :\n    quotAdjoinEquivQuotMap hx h_alg (Ideal.Quotient.mk (I.map (algebraMap R R<x>)) a) =\n      Ideal.Quotient.mk (I.map (algebraMap R S)) ↑a := rfl\n\n"}
{"name":"KummerDedekind.emultiplicity_factors_map_eq_emultiplicity","module":"Mathlib.NumberTheory.KummerDedekind","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nx : S\nI : Ideal R\ninst✝³ : IsDomain R\ninst✝² : IsIntegrallyClosed R\ninst✝¹ : IsDedekindDomain S\ninst✝ : NoZeroSMulDivisors R S\nhI : I.IsMaximal\nhI' : Ne I Bot.bot\nhx : Eq (Max.max (Ideal.comap (algebraMap R S) (conductor R x)) I) Top.top\nhx' : IsIntegral R x\nJ : Ideal S\nhJ : Membership.mem (UniqueFactorizationMonoid.normalizedFactors (Ideal.map (algebraMap R S) I)) J\n⊢ Eq (emultiplicity J (Ideal.map (algebraMap R S) I)) (emultiplicity (↑((KummerDedekind.normalizedFactorsMapEquivNormalizedFactorsMinPolyMk hI hI' hx hx') ⟨J, hJ⟩)) (Polynomial.map (Ideal.Quotient.mk I) (minpoly R x)))","decl":"open Classical in\n/-- The second half of the **Kummer-Dedekind Theorem** in the monogenic case, stating that the\n    bijection `FactorsEquiv'` defined in the first half preserves multiplicities. -/\ntheorem emultiplicity_factors_map_eq_emultiplicity\n    (hI : IsMaximal I) (hI' : I ≠ ⊥)\n    (hx : (conductor R x).comap (algebraMap R S) ⊔ I = ⊤) (hx' : IsIntegral R x) {J : Ideal S}\n    (hJ : J ∈ normalizedFactors (I.map (algebraMap R S))) :\n    emultiplicity J (I.map (algebraMap R S)) =\n      emultiplicity (↑(normalizedFactorsMapEquivNormalizedFactorsMinPolyMk hI hI' hx hx' ⟨J, hJ⟩))\n        (Polynomial.map (Ideal.Quotient.mk I) (minpoly R x)) := by\n  rw [normalizedFactorsMapEquivNormalizedFactorsMinPolyMk, Equiv.coe_trans, Function.comp_apply,\n    emultiplicity_normalizedFactorsEquivSpanNormalizedFactors_symm_eq_emultiplicity,\n    normalizedFactorsEquivOfQuotEquiv_emultiplicity_eq_emultiplicity]\n\n"}
{"name":"KummerDedekind.normalizedFactors_ideal_map_eq_normalizedFactors_min_poly_mk_map","module":"Mathlib.NumberTheory.KummerDedekind","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nx : S\nI : Ideal R\ninst✝³ : IsDomain R\ninst✝² : IsIntegrallyClosed R\ninst✝¹ : IsDedekindDomain S\ninst✝ : NoZeroSMulDivisors R S\nhI : I.IsMaximal\nhI' : Ne I Bot.bot\nhx : Eq (Max.max (Ideal.comap (algebraMap R S) (conductor R x)) I) Top.top\nhx' : IsIntegral R x\n⊢ Eq (UniqueFactorizationMonoid.normalizedFactors (Ideal.map (algebraMap R S) I)) (Multiset.map (fun f => ↑((KummerDedekind.normalizedFactorsMapEquivNormalizedFactorsMinPolyMk hI hI' hx hx').symm f)) (UniqueFactorizationMonoid.normalizedFactors (Polynomial.map (Ideal.Quotient.mk I) (minpoly R x))).attach)","decl":"open Classical in\n/-- The **Kummer-Dedekind Theorem**. -/\ntheorem normalizedFactors_ideal_map_eq_normalizedFactors_min_poly_mk_map (hI : IsMaximal I)\n    (hI' : I ≠ ⊥) (hx : (conductor R x).comap (algebraMap R S) ⊔ I = ⊤) (hx' : IsIntegral R x) :\n    normalizedFactors (I.map (algebraMap R S)) =\n      Multiset.map\n        (fun f =>\n          ((normalizedFactorsMapEquivNormalizedFactorsMinPolyMk hI hI' hx hx').symm f : Ideal S))\n        (normalizedFactors (Polynomial.map (Ideal.Quotient.mk I) (minpoly R x))).attach := by\n  ext J\n  -- WLOG, assume J is a normalized factor\n  by_cases hJ : J ∈ normalizedFactors (I.map (algebraMap R S))\n  swap\n  · rw [Multiset.count_eq_zero.mpr hJ, eq_comm, Multiset.count_eq_zero, Multiset.mem_map]\n    simp only [not_exists]\n    rintro J' ⟨_, rfl⟩\n    exact\n      hJ ((normalizedFactorsMapEquivNormalizedFactorsMinPolyMk hI hI' hx hx').symm J').prop\n  -- Then we just have to compare the multiplicities, which we already proved are equal.\n  have := emultiplicity_factors_map_eq_emultiplicity hI hI' hx hx' hJ\n  rw [emultiplicity_eq_count_normalizedFactors, emultiplicity_eq_count_normalizedFactors,\n    UniqueFactorizationMonoid.normalize_normalized_factor _ hJ,\n    UniqueFactorizationMonoid.normalize_normalized_factor, Nat.cast_inj] at this\n  · refine this.trans ?_\n    -- Get rid of the `map` by applying the equiv to both sides.\n    generalize hJ' :\n      (normalizedFactorsMapEquivNormalizedFactorsMinPolyMk hI hI' hx hx') ⟨J, hJ⟩ = J'\n    have : ((normalizedFactorsMapEquivNormalizedFactorsMinPolyMk hI hI' hx hx').symm J' : Ideal S) =\n        J := by\n      rw [← hJ', Equiv.symm_apply_apply _ _, Subtype.coe_mk]\n    subst this\n    -- Get rid of the `attach` by applying the subtype `coe` to both sides.\n    rw [Multiset.count_map_eq_count' fun f =>\n        ((normalizedFactorsMapEquivNormalizedFactorsMinPolyMk hI hI' hx hx').symm f :\n          Ideal S),\n      Multiset.count_attach]\n    · exact Subtype.coe_injective.comp (Equiv.injective _)\n  · exact (normalizedFactorsMapEquivNormalizedFactorsMinPolyMk hI hI' hx hx' _).prop\n  · exact irreducible_of_normalized_factor _\n        (normalizedFactorsMapEquivNormalizedFactorsMinPolyMk hI hI' hx hx' _).prop\n  · exact Polynomial.map_monic_ne_zero (minpoly.monic hx')\n  · exact irreducible_of_normalized_factor _ hJ\n  · rwa [← bot_eq_zero, Ne,\n      map_eq_bot_iff_of_injective (NoZeroSMulDivisors.algebraMap_injective R S)]\n\n"}
{"name":"KummerDedekind.Ideal.irreducible_map_of_irreducible_minpoly","module":"Mathlib.NumberTheory.KummerDedekind","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nx : S\nI : Ideal R\ninst✝³ : IsDomain R\ninst✝² : IsIntegrallyClosed R\ninst✝¹ : IsDedekindDomain S\ninst✝ : NoZeroSMulDivisors R S\nhI : I.IsMaximal\nhI' : Ne I Bot.bot\nhx : Eq (Max.max (Ideal.comap (algebraMap R S) (conductor R x)) I) Top.top\nhx' : IsIntegral R x\nhf : Irreducible (Polynomial.map (Ideal.Quotient.mk I) (minpoly R x))\n⊢ Irreducible (Ideal.map (algebraMap R S) I)","decl":"theorem Ideal.irreducible_map_of_irreducible_minpoly (hI : IsMaximal I) (hI' : I ≠ ⊥)\n    (hx : (conductor R x).comap (algebraMap R S) ⊔ I = ⊤) (hx' : IsIntegral R x)\n    (hf : Irreducible (Polynomial.map (Ideal.Quotient.mk I) (minpoly R x))) :\n    Irreducible (I.map (algebraMap R S)) := by\n  classical\n  have mem_norm_factors : normalize (Polynomial.map (Ideal.Quotient.mk I) (minpoly R x)) ∈\n      normalizedFactors (Polynomial.map (Ideal.Quotient.mk I) (minpoly R x)) := by\n    simp [normalizedFactors_irreducible hf]\n  suffices ∃ y, normalizedFactors (I.map (algebraMap R S)) = {y} by\n    obtain ⟨y, hy⟩ := this\n    have h := prod_normalizedFactors (show I.map (algebraMap R S) ≠ 0 by\n          rwa [← bot_eq_zero, Ne,\n            map_eq_bot_iff_of_injective (NoZeroSMulDivisors.algebraMap_injective R S)])\n    rw [associated_iff_eq, hy, Multiset.prod_singleton] at h\n    rw [← h]\n    exact\n      irreducible_of_normalized_factor y\n        (show y ∈ normalizedFactors (I.map (algebraMap R S)) by simp [hy])\n  rw [normalizedFactors_ideal_map_eq_normalizedFactors_min_poly_mk_map hI hI' hx hx']\n  use ((normalizedFactorsMapEquivNormalizedFactorsMinPolyMk hI hI' hx hx').symm\n        ⟨normalize (Polynomial.map (Ideal.Quotient.mk I) (minpoly R x)), mem_norm_factors⟩ :\n      Ideal S)\n  rw [Multiset.map_eq_singleton]\n  use ⟨normalize (Polynomial.map (Ideal.Quotient.mk I) (minpoly R x)), mem_norm_factors⟩\n  refine ⟨?_, rfl⟩\n  apply Multiset.map_injective Subtype.coe_injective\n  rw [Multiset.attach_map_val, Multiset.map_singleton, Subtype.coe_mk]\n  exact normalizedFactors_irreducible hf\n\n"}
{"name":"KummerDedekind.normalizedFactorsMapEquivNormalizedFactorsMinPolyMk_symm_apply_eq_span","module":"Mathlib.NumberTheory.KummerDedekind","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nx : S\nI : Ideal R\ninst✝³ : IsDomain R\ninst✝² : IsIntegrallyClosed R\ninst✝¹ : IsDedekindDomain S\ninst✝ : NoZeroSMulDivisors R S\nhI : I.IsMaximal\nQ : Polynomial R\nhQ : Membership.mem (UniqueFactorizationMonoid.normalizedFactors (Polynomial.map (Ideal.Quotient.mk I) (minpoly R x))) (Polynomial.map (Ideal.Quotient.mk I) Q)\nhI' : Ne I Bot.bot\nhx : Eq (Max.max (Ideal.comap (algebraMap R S) (conductor R x)) I) Top.top\nhx' : IsIntegral R x\n⊢ Eq (↑((KummerDedekind.normalizedFactorsMapEquivNormalizedFactorsMinPolyMk hI hI' hx hx').symm ⟨Polynomial.map (Ideal.Quotient.mk I) Q, hQ⟩)) (Ideal.span (Union.union (↑(Ideal.map (algebraMap R S) I)) (Singleton.singleton ((Polynomial.aeval x) Q))))","decl":"open Set Classical in\n/-- Let `Q` be a lift of factor of the minimal polynomial of `x`, a generator of `S` over `R`, taken\n`mod I`. Then (the reduction of) `Q` corresponds via\n`normalizedFactorsMapEquivNormalizedFactorsMinPolyMk` to\n`span (I.map (algebraMap R S) ∪ {Q.aeval x})`.  -/\ntheorem normalizedFactorsMapEquivNormalizedFactorsMinPolyMk_symm_apply_eq_span\n    (hI : I.IsMaximal) {Q : R[X]}\n    (hQ : Q.map (Ideal.Quotient.mk I) ∈ normalizedFactors ((minpoly R x).map (Ideal.Quotient.mk I)))\n    (hI' : I ≠ ⊥) (hx : (conductor R x).comap (algebraMap R S) ⊔ I = ⊤) (hx' : IsIntegral R x) :\n    ((normalizedFactorsMapEquivNormalizedFactorsMinPolyMk hI hI' hx hx').symm ⟨_, hQ⟩).val =\n    span (I.map (algebraMap R S) ∪ {Q.aeval x}) := by\n  dsimp [normalizedFactorsMapEquivNormalizedFactorsMinPolyMk,\n    normalizedFactorsEquivSpanNormalizedFactors]\n  rw [normalizedFactorsEquivOfQuotEquiv_symm]\n  dsimp [normalizedFactorsEquivOfQuotEquiv, idealFactorsEquivOfQuotEquiv, OrderIso.ofHomInv]\n  simp only [map_span, image_singleton, coe_coe,f_symm_aux hx hx' Q]\n  refine le_antisymm (fun a ha ↦ ?_) (span_le.mpr <| union_subset_iff.mpr <|\n    ⟨le_comap_of_map_le (by simp), by simp [mem_span_singleton]⟩)\n  rw [mem_comap, Ideal.mem_span_singleton] at ha\n  obtain ⟨a', ha'⟩ := ha\n  obtain ⟨b, hb⟩ := Ideal.Quotient.mk_surjective a'\n  rw [← hb, ← _root_.map_mul, Quotient.mk_eq_mk_iff_sub_mem] at ha'\n  rw [union_comm, span_union, span_eq, mem_span_singleton_sup]\n  exact ⟨b, a - Q.aeval x * b, ha', by ring⟩\n\n"}
