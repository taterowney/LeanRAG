{"name":"CategoryTheory.mono_of_nonzero_from_simple","module":"Mathlib.CategoryTheory.Preadditive.Schur","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\nX Y : C\ninst✝ : CategoryTheory.Simple X\nf : Quiver.Hom X Y\nw : Ne f 0\n⊢ CategoryTheory.Mono f","decl":"theorem mono_of_nonzero_from_simple [HasKernels C] {X Y : C} [Simple X] {f : X ⟶ Y} (w : f ≠ 0) :\n    Mono f :=\n  Preadditive.mono_of_kernel_zero (kernel_zero_of_nonzero_from_simple w)\n\n"}
{"name":"CategoryTheory.isIso_of_hom_simple","module":"Mathlib.CategoryTheory.Preadditive.Schur","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : CategoryTheory.Limits.HasKernels C\nX Y : C\ninst✝¹ : CategoryTheory.Simple X\ninst✝ : CategoryTheory.Simple Y\nf : Quiver.Hom X Y\nw : Ne f 0\n⊢ CategoryTheory.IsIso f","decl":"/-- The part of **Schur's lemma** that holds in any preadditive category with kernels:\nthat a nonzero morphism between simple objects is an isomorphism.\n-/\ntheorem isIso_of_hom_simple\n    [HasKernels C] {X Y : C} [Simple X] [Simple Y] {f : X ⟶ Y} (w : f ≠ 0) : IsIso f :=\n  haveI := mono_of_nonzero_from_simple w\n  isIso_of_mono_of_nonzero w\n\n"}
{"name":"CategoryTheory.isIso_iff_nonzero","module":"Mathlib.CategoryTheory.Preadditive.Schur","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : CategoryTheory.Limits.HasKernels C\nX Y : C\ninst✝¹ : CategoryTheory.Simple X\ninst✝ : CategoryTheory.Simple Y\nf : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.IsIso f) (Ne f 0)","decl":"/-- As a corollary of Schur's lemma for preadditive categories,\nany morphism between simple objects is (exclusively) either an isomorphism or zero.\n-/\ntheorem isIso_iff_nonzero [HasKernels C] {X Y : C} [Simple X] [Simple Y] (f : X ⟶ Y) :\n    IsIso f ↔ f ≠ 0 :=\n  ⟨fun I => by\n    intro h\n    apply id_nonzero X\n    simp only [← IsIso.hom_inv_id f, h, zero_comp],\n   fun w => isIso_of_hom_simple w⟩\n\n"}
{"name":"CategoryTheory.finrank_hom_simple_simple_eq_zero_of_not_iso","module":"Mathlib.CategoryTheory.Preadditive.Schur","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Preadditive C\n𝕜 : Type u_2\ninst✝⁴ : DivisionRing 𝕜\ninst✝³ : CategoryTheory.Limits.HasKernels C\ninst✝² : CategoryTheory.Linear 𝕜 C\nX Y : C\ninst✝¹ : CategoryTheory.Simple X\ninst✝ : CategoryTheory.Simple Y\nh : CategoryTheory.Iso X Y → False\n⊢ Eq (Module.finrank 𝕜 (Quiver.Hom X Y)) 0","decl":"/-- Part of **Schur's lemma** for `𝕜`-linear categories:\nthe hom space between two non-isomorphic simple objects is 0-dimensional.\n-/\ntheorem finrank_hom_simple_simple_eq_zero_of_not_iso [HasKernels C] [Linear 𝕜 C] {X Y : C}\n    [Simple X] [Simple Y] (h : (X ≅ Y) → False) : finrank 𝕜 (X ⟶ Y) = 0 :=\n  haveI :=\n    subsingleton_of_forall_eq (0 : X ⟶ Y) fun f => by\n      have p := not_congr (isIso_iff_nonzero f)\n      simp only [Classical.not_not, Ne] at p\n      exact p.mp fun _ => h (asIso f)\n  finrank_zero_of_subsingleton\n\n"}
{"name":"CategoryTheory.finrank_endomorphism_eq_one","module":"Mathlib.CategoryTheory.Preadditive.Schur","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\n𝕜 : Type u_2\ninst✝² : Field 𝕜\ninst✝¹ : IsAlgClosed 𝕜\ninst✝ : CategoryTheory.Linear 𝕜 C\nX : C\nisIso_iff_nonzero : ∀ (f : Quiver.Hom X X), Iff (CategoryTheory.IsIso f) (Ne f 0)\nI : FiniteDimensional 𝕜 (Quiver.Hom X X)\n⊢ Eq (Module.finrank 𝕜 (Quiver.Hom X X)) 1","decl":"/-- An auxiliary lemma for Schur's lemma.\n\nIf `X ⟶ X` is finite dimensional, and every nonzero endomorphism is invertible,\nthen `X ⟶ X` is 1-dimensional.\n-/\ntheorem finrank_endomorphism_eq_one {X : C} (isIso_iff_nonzero : ∀ f : X ⟶ X, IsIso f ↔ f ≠ 0)\n    [I : FiniteDimensional 𝕜 (X ⟶ X)] : finrank 𝕜 (X ⟶ X) = 1 := by\n  have id_nonzero := (isIso_iff_nonzero (𝟙 X)).mp (by infer_instance)\n  refine finrank_eq_one (𝟙 X) id_nonzero ?_\n  intro f\n  have : Nontrivial (End X) := nontrivial_of_ne _ _ id_nonzero\n  have : FiniteDimensional 𝕜 (End X) := I\n  obtain ⟨c, nu⟩ := spectrum.nonempty_of_isAlgClosed_of_finiteDimensional 𝕜 (End.of f)\n  use c\n  rw [spectrum.mem_iff, IsUnit.sub_iff, isUnit_iff_isIso, isIso_iff_nonzero, Ne,\n    Classical.not_not, sub_eq_zero, Algebra.algebraMap_eq_smul_one] at nu\n  exact nu.symm\n\n"}
{"name":"CategoryTheory.finrank_endomorphism_simple_eq_one","module":"Mathlib.CategoryTheory.Preadditive.Schur","initialProofState":"C : Type u_1\ninst✝⁷ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁶ : CategoryTheory.Preadditive C\n𝕜 : Type u_2\ninst✝⁵ : Field 𝕜\ninst✝⁴ : IsAlgClosed 𝕜\ninst✝³ : CategoryTheory.Linear 𝕜 C\ninst✝² : CategoryTheory.Limits.HasKernels C\nX : C\ninst✝¹ : CategoryTheory.Simple X\ninst✝ : FiniteDimensional 𝕜 (Quiver.Hom X X)\n⊢ Eq (Module.finrank 𝕜 (Quiver.Hom X X)) 1","decl":"/-- **Schur's lemma** for endomorphisms in `𝕜`-linear categories.\n-/\ntheorem finrank_endomorphism_simple_eq_one (X : C) [Simple X] [FiniteDimensional 𝕜 (X ⟶ X)] :\n    finrank 𝕜 (X ⟶ X) = 1 :=\n  finrank_endomorphism_eq_one 𝕜 isIso_iff_nonzero\n\n"}
{"name":"CategoryTheory.endomorphism_simple_eq_smul_id","module":"Mathlib.CategoryTheory.Preadditive.Schur","initialProofState":"C : Type u_1\ninst✝⁷ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁶ : CategoryTheory.Preadditive C\n𝕜 : Type u_2\ninst✝⁵ : Field 𝕜\ninst✝⁴ : IsAlgClosed 𝕜\ninst✝³ : CategoryTheory.Linear 𝕜 C\ninst✝² : CategoryTheory.Limits.HasKernels C\nX : C\ninst✝¹ : CategoryTheory.Simple X\ninst✝ : FiniteDimensional 𝕜 (Quiver.Hom X X)\nf : Quiver.Hom X X\n⊢ Exists fun c => Eq (HSMul.hSMul c (CategoryTheory.CategoryStruct.id X)) f","decl":"theorem endomorphism_simple_eq_smul_id {X : C} [Simple X] [FiniteDimensional 𝕜 (X ⟶ X)]\n    (f : X ⟶ X) : ∃ c : 𝕜, c • 𝟙 X = f :=\n  (finrank_eq_one_iff_of_nonzero' (𝟙 X) (id_nonzero X)).mp (finrank_endomorphism_simple_eq_one 𝕜 X)\n    f\n\n"}
{"name":"CategoryTheory.finrank_hom_simple_simple_le_one","module":"Mathlib.CategoryTheory.Preadditive.Schur","initialProofState":"C : Type u_1\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Preadditive C\n𝕜 : Type u_2\ninst✝⁶ : Field 𝕜\ninst✝⁵ : IsAlgClosed 𝕜\ninst✝⁴ : CategoryTheory.Linear 𝕜 C\ninst✝³ : CategoryTheory.Limits.HasKernels C\nX Y : C\ninst✝² : FiniteDimensional 𝕜 (Quiver.Hom X X)\ninst✝¹ : CategoryTheory.Simple X\ninst✝ : CategoryTheory.Simple Y\n⊢ LE.le (Module.finrank 𝕜 (Quiver.Hom X Y)) 1","decl":"/-- **Schur's lemma** for `𝕜`-linear categories:\nif hom spaces are finite dimensional, then the hom space between simples is at most 1-dimensional.\n\nSee `finrank_hom_simple_simple_eq_one_iff` and `finrank_hom_simple_simple_eq_zero_iff` below\nfor the refinements when we know whether or not the simples are isomorphic.\n-/\ntheorem finrank_hom_simple_simple_le_one (X Y : C) [FiniteDimensional 𝕜 (X ⟶ X)] [Simple X]\n    [Simple Y] : finrank 𝕜 (X ⟶ Y) ≤ 1 := by\n  obtain (h|h) := subsingleton_or_nontrivial (X ⟶ Y)\n  · rw [finrank_zero_of_subsingleton]\n    exact zero_le_one\n  · obtain ⟨f, nz⟩ := (nontrivial_iff_exists_ne 0).mp h\n    haveI fi := (isIso_iff_nonzero f).mpr nz\n    refine finrank_le_one f ?_\n    intro g\n    obtain ⟨c, w⟩ := endomorphism_simple_eq_smul_id 𝕜 (g ≫ inv f)\n    exact ⟨c, by simpa using w =≫ f⟩\n\n"}
{"name":"CategoryTheory.finrank_hom_simple_simple_eq_one_iff","module":"Mathlib.CategoryTheory.Preadditive.Schur","initialProofState":"C : Type u_1\ninst✝⁹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁸ : CategoryTheory.Preadditive C\n𝕜 : Type u_2\ninst✝⁷ : Field 𝕜\ninst✝⁶ : IsAlgClosed 𝕜\ninst✝⁵ : CategoryTheory.Linear 𝕜 C\ninst✝⁴ : CategoryTheory.Limits.HasKernels C\nX Y : C\ninst✝³ : FiniteDimensional 𝕜 (Quiver.Hom X X)\ninst✝² : FiniteDimensional 𝕜 (Quiver.Hom X Y)\ninst✝¹ : CategoryTheory.Simple X\ninst✝ : CategoryTheory.Simple Y\n⊢ Iff (Eq (Module.finrank 𝕜 (Quiver.Hom X Y)) 1) (Nonempty (CategoryTheory.Iso X Y))","decl":"theorem finrank_hom_simple_simple_eq_one_iff (X Y : C) [FiniteDimensional 𝕜 (X ⟶ X)]\n    [FiniteDimensional 𝕜 (X ⟶ Y)] [Simple X] [Simple Y] :\n    finrank 𝕜 (X ⟶ Y) = 1 ↔ Nonempty (X ≅ Y) := by\n  fconstructor\n  · intro h\n    rw [finrank_eq_one_iff'] at h\n    obtain ⟨f, nz, -⟩ := h\n    rw [← isIso_iff_nonzero] at nz\n    exact ⟨asIso f⟩\n  · rintro ⟨f⟩\n    have le_one := finrank_hom_simple_simple_le_one 𝕜 X Y\n    have zero_lt : 0 < finrank 𝕜 (X ⟶ Y) :=\n      finrank_pos_iff_exists_ne_zero.mpr ⟨f.hom, (isIso_iff_nonzero f.hom).mp inferInstance⟩\n    omega\n\n"}
{"name":"CategoryTheory.finrank_hom_simple_simple_eq_zero_iff","module":"Mathlib.CategoryTheory.Preadditive.Schur","initialProofState":"C : Type u_1\ninst✝⁹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁸ : CategoryTheory.Preadditive C\n𝕜 : Type u_2\ninst✝⁷ : Field 𝕜\ninst✝⁶ : IsAlgClosed 𝕜\ninst✝⁵ : CategoryTheory.Linear 𝕜 C\ninst✝⁴ : CategoryTheory.Limits.HasKernels C\nX Y : C\ninst✝³ : FiniteDimensional 𝕜 (Quiver.Hom X X)\ninst✝² : FiniteDimensional 𝕜 (Quiver.Hom X Y)\ninst✝¹ : CategoryTheory.Simple X\ninst✝ : CategoryTheory.Simple Y\n⊢ Iff (Eq (Module.finrank 𝕜 (Quiver.Hom X Y)) 0) (IsEmpty (CategoryTheory.Iso X Y))","decl":"theorem finrank_hom_simple_simple_eq_zero_iff (X Y : C) [FiniteDimensional 𝕜 (X ⟶ X)]\n    [FiniteDimensional 𝕜 (X ⟶ Y)] [Simple X] [Simple Y] :\n    finrank 𝕜 (X ⟶ Y) = 0 ↔ IsEmpty (X ≅ Y) := by\n  rw [← not_nonempty_iff, ← not_congr (finrank_hom_simple_simple_eq_one_iff 𝕜 X Y)]\n  have := finrank_hom_simple_simple_le_one 𝕜 X Y\n  omega\n\n"}
{"name":"CategoryTheory.finrank_hom_simple_simple","module":"Mathlib.CategoryTheory.Preadditive.Schur","initialProofState":"C : Type u_1\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Preadditive C\n𝕜 : Type u_2\ninst✝⁶ : Field 𝕜\ninst✝⁵ : IsAlgClosed 𝕜\ninst✝⁴ : CategoryTheory.Linear 𝕜 C\ninst✝³ : CategoryTheory.Limits.HasKernels C\nX Y : C\ninst✝² : ∀ (X Y : C), FiniteDimensional 𝕜 (Quiver.Hom X Y)\ninst✝¹ : CategoryTheory.Simple X\ninst✝ : CategoryTheory.Simple Y\n⊢ Eq (Module.finrank 𝕜 (Quiver.Hom X Y)) (ite (Nonempty (CategoryTheory.Iso X Y)) 1 0)","decl":"open scoped Classical in\ntheorem finrank_hom_simple_simple (X Y : C) [∀ X Y : C, FiniteDimensional 𝕜 (X ⟶ Y)] [Simple X]\n    [Simple Y] : finrank 𝕜 (X ⟶ Y) = if Nonempty (X ≅ Y) then 1 else 0 := by\n  split_ifs with h\n  · exact (finrank_hom_simple_simple_eq_one_iff 𝕜 X Y).2 h\n  · exact (finrank_hom_simple_simple_eq_zero_iff 𝕜 X Y).2 (not_nonempty_iff.mp h)\n\n"}
