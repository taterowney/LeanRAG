{"name":"CategoryTheory.mono_of_nonzero_from_simple","module":"Mathlib.CategoryTheory.Preadditive.Schur","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasKernels C\nX Y : C\ninstâœ : CategoryTheory.Simple X\nf : Quiver.Hom X Y\nw : Ne f 0\nâŠ¢ CategoryTheory.Mono f","decl":"theorem mono_of_nonzero_from_simple [HasKernels C] {X Y : C} [Simple X] {f : X âŸ¶ Y} (w : f â‰  0) :\n    Mono f :=\n  Preadditive.mono_of_kernel_zero (kernel_zero_of_nonzero_from_simple w)\n\n"}
{"name":"CategoryTheory.isIso_of_hom_simple","module":"Mathlib.CategoryTheory.Preadditive.Schur","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ³ : CategoryTheory.Preadditive C\ninstâœÂ² : CategoryTheory.Limits.HasKernels C\nX Y : C\ninstâœÂ¹ : CategoryTheory.Simple X\ninstâœ : CategoryTheory.Simple Y\nf : Quiver.Hom X Y\nw : Ne f 0\nâŠ¢ CategoryTheory.IsIso f","decl":"/-- The part of **Schur's lemma** that holds in any preadditive category with kernels:\nthat a nonzero morphism between simple objects is an isomorphism.\n-/\ntheorem isIso_of_hom_simple\n    [HasKernels C] {X Y : C} [Simple X] [Simple Y] {f : X âŸ¶ Y} (w : f â‰  0) : IsIso f :=\n  haveI := mono_of_nonzero_from_simple w\n  isIso_of_mono_of_nonzero w\n\n"}
{"name":"CategoryTheory.isIso_iff_nonzero","module":"Mathlib.CategoryTheory.Preadditive.Schur","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ³ : CategoryTheory.Preadditive C\ninstâœÂ² : CategoryTheory.Limits.HasKernels C\nX Y : C\ninstâœÂ¹ : CategoryTheory.Simple X\ninstâœ : CategoryTheory.Simple Y\nf : Quiver.Hom X Y\nâŠ¢ Iff (CategoryTheory.IsIso f) (Ne f 0)","decl":"/-- As a corollary of Schur's lemma for preadditive categories,\nany morphism between simple objects is (exclusively) either an isomorphism or zero.\n-/\ntheorem isIso_iff_nonzero [HasKernels C] {X Y : C} [Simple X] [Simple Y] (f : X âŸ¶ Y) :\n    IsIso f â†” f â‰  0 :=\n  âŸ¨fun I => by\n    intro h\n    apply id_nonzero X\n    simp only [â† IsIso.hom_inv_id f, h, zero_comp],\n   fun w => isIso_of_hom_simple wâŸ©\n\n"}
{"name":"CategoryTheory.finrank_hom_simple_simple_eq_zero_of_not_iso","module":"Mathlib.CategoryTheory.Preadditive.Schur","initialProofState":"C : Type u_1\ninstâœâ¶ : CategoryTheory.Category.{u_3, u_1} C\ninstâœâµ : CategoryTheory.Preadditive C\nğ•œ : Type u_2\ninstâœâ´ : DivisionRing ğ•œ\ninstâœÂ³ : CategoryTheory.Limits.HasKernels C\ninstâœÂ² : CategoryTheory.Linear ğ•œ C\nX Y : C\ninstâœÂ¹ : CategoryTheory.Simple X\ninstâœ : CategoryTheory.Simple Y\nh : CategoryTheory.Iso X Y â†’ False\nâŠ¢ Eq (Module.finrank ğ•œ (Quiver.Hom X Y)) 0","decl":"/-- Part of **Schur's lemma** for `ğ•œ`-linear categories:\nthe hom space between two non-isomorphic simple objects is 0-dimensional.\n-/\ntheorem finrank_hom_simple_simple_eq_zero_of_not_iso [HasKernels C] [Linear ğ•œ C] {X Y : C}\n    [Simple X] [Simple Y] (h : (X â‰… Y) â†’ False) : finrank ğ•œ (X âŸ¶ Y) = 0 :=\n  haveI :=\n    subsingleton_of_forall_eq (0 : X âŸ¶ Y) fun f => by\n      have p := not_congr (isIso_iff_nonzero f)\n      simp only [Classical.not_not, Ne] at p\n      exact p.mp fun _ => h (asIso f)\n  finrank_zero_of_subsingleton\n\n"}
{"name":"CategoryTheory.finrank_endomorphism_eq_one","module":"Mathlib.CategoryTheory.Preadditive.Schur","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nğ•œ : Type u_2\ninstâœÂ² : Field ğ•œ\ninstâœÂ¹ : IsAlgClosed ğ•œ\ninstâœ : CategoryTheory.Linear ğ•œ C\nX : C\nisIso_iff_nonzero : âˆ€ (f : Quiver.Hom X X), Iff (CategoryTheory.IsIso f) (Ne f 0)\nI : FiniteDimensional ğ•œ (Quiver.Hom X X)\nâŠ¢ Eq (Module.finrank ğ•œ (Quiver.Hom X X)) 1","decl":"/-- An auxiliary lemma for Schur's lemma.\n\nIf `X âŸ¶ X` is finite dimensional, and every nonzero endomorphism is invertible,\nthen `X âŸ¶ X` is 1-dimensional.\n-/\ntheorem finrank_endomorphism_eq_one {X : C} (isIso_iff_nonzero : âˆ€ f : X âŸ¶ X, IsIso f â†” f â‰  0)\n    [I : FiniteDimensional ğ•œ (X âŸ¶ X)] : finrank ğ•œ (X âŸ¶ X) = 1 := by\n  have id_nonzero := (isIso_iff_nonzero (ğŸ™ X)).mp (by infer_instance)\n  refine finrank_eq_one (ğŸ™ X) id_nonzero ?_\n  intro f\n  have : Nontrivial (End X) := nontrivial_of_ne _ _ id_nonzero\n  have : FiniteDimensional ğ•œ (End X) := I\n  obtain âŸ¨c, nuâŸ© := spectrum.nonempty_of_isAlgClosed_of_finiteDimensional ğ•œ (End.of f)\n  use c\n  rw [spectrum.mem_iff, IsUnit.sub_iff, isUnit_iff_isIso, isIso_iff_nonzero, Ne,\n    Classical.not_not, sub_eq_zero, Algebra.algebraMap_eq_smul_one] at nu\n  exact nu.symm\n\n"}
{"name":"CategoryTheory.finrank_endomorphism_simple_eq_one","module":"Mathlib.CategoryTheory.Preadditive.Schur","initialProofState":"C : Type u_1\ninstâœâ· : CategoryTheory.Category.{u_3, u_1} C\ninstâœâ¶ : CategoryTheory.Preadditive C\nğ•œ : Type u_2\ninstâœâµ : Field ğ•œ\ninstâœâ´ : IsAlgClosed ğ•œ\ninstâœÂ³ : CategoryTheory.Linear ğ•œ C\ninstâœÂ² : CategoryTheory.Limits.HasKernels C\nX : C\ninstâœÂ¹ : CategoryTheory.Simple X\ninstâœ : FiniteDimensional ğ•œ (Quiver.Hom X X)\nâŠ¢ Eq (Module.finrank ğ•œ (Quiver.Hom X X)) 1","decl":"/-- **Schur's lemma** for endomorphisms in `ğ•œ`-linear categories.\n-/\ntheorem finrank_endomorphism_simple_eq_one (X : C) [Simple X] [FiniteDimensional ğ•œ (X âŸ¶ X)] :\n    finrank ğ•œ (X âŸ¶ X) = 1 :=\n  finrank_endomorphism_eq_one ğ•œ isIso_iff_nonzero\n\n"}
{"name":"CategoryTheory.endomorphism_simple_eq_smul_id","module":"Mathlib.CategoryTheory.Preadditive.Schur","initialProofState":"C : Type u_1\ninstâœâ· : CategoryTheory.Category.{u_3, u_1} C\ninstâœâ¶ : CategoryTheory.Preadditive C\nğ•œ : Type u_2\ninstâœâµ : Field ğ•œ\ninstâœâ´ : IsAlgClosed ğ•œ\ninstâœÂ³ : CategoryTheory.Linear ğ•œ C\ninstâœÂ² : CategoryTheory.Limits.HasKernels C\nX : C\ninstâœÂ¹ : CategoryTheory.Simple X\ninstâœ : FiniteDimensional ğ•œ (Quiver.Hom X X)\nf : Quiver.Hom X X\nâŠ¢ Exists fun c => Eq (HSMul.hSMul c (CategoryTheory.CategoryStruct.id X)) f","decl":"theorem endomorphism_simple_eq_smul_id {X : C} [Simple X] [FiniteDimensional ğ•œ (X âŸ¶ X)]\n    (f : X âŸ¶ X) : âˆƒ c : ğ•œ, c â€¢ ğŸ™ X = f :=\n  (finrank_eq_one_iff_of_nonzero' (ğŸ™ X) (id_nonzero X)).mp (finrank_endomorphism_simple_eq_one ğ•œ X)\n    f\n\n"}
{"name":"CategoryTheory.finrank_hom_simple_simple_le_one","module":"Mathlib.CategoryTheory.Preadditive.Schur","initialProofState":"C : Type u_1\ninstâœâ¸ : CategoryTheory.Category.{u_3, u_1} C\ninstâœâ· : CategoryTheory.Preadditive C\nğ•œ : Type u_2\ninstâœâ¶ : Field ğ•œ\ninstâœâµ : IsAlgClosed ğ•œ\ninstâœâ´ : CategoryTheory.Linear ğ•œ C\ninstâœÂ³ : CategoryTheory.Limits.HasKernels C\nX Y : C\ninstâœÂ² : FiniteDimensional ğ•œ (Quiver.Hom X X)\ninstâœÂ¹ : CategoryTheory.Simple X\ninstâœ : CategoryTheory.Simple Y\nâŠ¢ LE.le (Module.finrank ğ•œ (Quiver.Hom X Y)) 1","decl":"/-- **Schur's lemma** for `ğ•œ`-linear categories:\nif hom spaces are finite dimensional, then the hom space between simples is at most 1-dimensional.\n\nSee `finrank_hom_simple_simple_eq_one_iff` and `finrank_hom_simple_simple_eq_zero_iff` below\nfor the refinements when we know whether or not the simples are isomorphic.\n-/\ntheorem finrank_hom_simple_simple_le_one (X Y : C) [FiniteDimensional ğ•œ (X âŸ¶ X)] [Simple X]\n    [Simple Y] : finrank ğ•œ (X âŸ¶ Y) â‰¤ 1 := by\n  obtain (h|h) := subsingleton_or_nontrivial (X âŸ¶ Y)\n  Â· rw [finrank_zero_of_subsingleton]\n    exact zero_le_one\n  Â· obtain âŸ¨f, nzâŸ© := (nontrivial_iff_exists_ne 0).mp h\n    haveI fi := (isIso_iff_nonzero f).mpr nz\n    refine finrank_le_one f ?_\n    intro g\n    obtain âŸ¨c, wâŸ© := endomorphism_simple_eq_smul_id ğ•œ (g â‰« inv f)\n    exact âŸ¨c, by simpa using w =â‰« fâŸ©\n\n"}
{"name":"CategoryTheory.finrank_hom_simple_simple_eq_one_iff","module":"Mathlib.CategoryTheory.Preadditive.Schur","initialProofState":"C : Type u_1\ninstâœâ¹ : CategoryTheory.Category.{u_3, u_1} C\ninstâœâ¸ : CategoryTheory.Preadditive C\nğ•œ : Type u_2\ninstâœâ· : Field ğ•œ\ninstâœâ¶ : IsAlgClosed ğ•œ\ninstâœâµ : CategoryTheory.Linear ğ•œ C\ninstâœâ´ : CategoryTheory.Limits.HasKernels C\nX Y : C\ninstâœÂ³ : FiniteDimensional ğ•œ (Quiver.Hom X X)\ninstâœÂ² : FiniteDimensional ğ•œ (Quiver.Hom X Y)\ninstâœÂ¹ : CategoryTheory.Simple X\ninstâœ : CategoryTheory.Simple Y\nâŠ¢ Iff (Eq (Module.finrank ğ•œ (Quiver.Hom X Y)) 1) (Nonempty (CategoryTheory.Iso X Y))","decl":"theorem finrank_hom_simple_simple_eq_one_iff (X Y : C) [FiniteDimensional ğ•œ (X âŸ¶ X)]\n    [FiniteDimensional ğ•œ (X âŸ¶ Y)] [Simple X] [Simple Y] :\n    finrank ğ•œ (X âŸ¶ Y) = 1 â†” Nonempty (X â‰… Y) := by\n  fconstructor\n  Â· intro h\n    rw [finrank_eq_one_iff'] at h\n    obtain âŸ¨f, nz, -âŸ© := h\n    rw [â† isIso_iff_nonzero] at nz\n    exact âŸ¨asIso fâŸ©\n  Â· rintro âŸ¨fâŸ©\n    have le_one := finrank_hom_simple_simple_le_one ğ•œ X Y\n    have zero_lt : 0 < finrank ğ•œ (X âŸ¶ Y) :=\n      finrank_pos_iff_exists_ne_zero.mpr âŸ¨f.hom, (isIso_iff_nonzero f.hom).mp inferInstanceâŸ©\n    omega\n\n"}
{"name":"CategoryTheory.finrank_hom_simple_simple_eq_zero_iff","module":"Mathlib.CategoryTheory.Preadditive.Schur","initialProofState":"C : Type u_1\ninstâœâ¹ : CategoryTheory.Category.{u_3, u_1} C\ninstâœâ¸ : CategoryTheory.Preadditive C\nğ•œ : Type u_2\ninstâœâ· : Field ğ•œ\ninstâœâ¶ : IsAlgClosed ğ•œ\ninstâœâµ : CategoryTheory.Linear ğ•œ C\ninstâœâ´ : CategoryTheory.Limits.HasKernels C\nX Y : C\ninstâœÂ³ : FiniteDimensional ğ•œ (Quiver.Hom X X)\ninstâœÂ² : FiniteDimensional ğ•œ (Quiver.Hom X Y)\ninstâœÂ¹ : CategoryTheory.Simple X\ninstâœ : CategoryTheory.Simple Y\nâŠ¢ Iff (Eq (Module.finrank ğ•œ (Quiver.Hom X Y)) 0) (IsEmpty (CategoryTheory.Iso X Y))","decl":"theorem finrank_hom_simple_simple_eq_zero_iff (X Y : C) [FiniteDimensional ğ•œ (X âŸ¶ X)]\n    [FiniteDimensional ğ•œ (X âŸ¶ Y)] [Simple X] [Simple Y] :\n    finrank ğ•œ (X âŸ¶ Y) = 0 â†” IsEmpty (X â‰… Y) := by\n  rw [â† not_nonempty_iff, â† not_congr (finrank_hom_simple_simple_eq_one_iff ğ•œ X Y)]\n  have := finrank_hom_simple_simple_le_one ğ•œ X Y\n  omega\n\n"}
{"name":"CategoryTheory.finrank_hom_simple_simple","module":"Mathlib.CategoryTheory.Preadditive.Schur","initialProofState":"C : Type u_1\ninstâœâ¸ : CategoryTheory.Category.{u_3, u_1} C\ninstâœâ· : CategoryTheory.Preadditive C\nğ•œ : Type u_2\ninstâœâ¶ : Field ğ•œ\ninstâœâµ : IsAlgClosed ğ•œ\ninstâœâ´ : CategoryTheory.Linear ğ•œ C\ninstâœÂ³ : CategoryTheory.Limits.HasKernels C\nX Y : C\ninstâœÂ² : âˆ€ (X Y : C), FiniteDimensional ğ•œ (Quiver.Hom X Y)\ninstâœÂ¹ : CategoryTheory.Simple X\ninstâœ : CategoryTheory.Simple Y\nâŠ¢ Eq (Module.finrank ğ•œ (Quiver.Hom X Y)) (ite (Nonempty (CategoryTheory.Iso X Y)) 1 0)","decl":"open scoped Classical in\ntheorem finrank_hom_simple_simple (X Y : C) [âˆ€ X Y : C, FiniteDimensional ğ•œ (X âŸ¶ Y)] [Simple X]\n    [Simple Y] : finrank ğ•œ (X âŸ¶ Y) = if Nonempty (X â‰… Y) then 1 else 0 := by\n  split_ifs with h\n  Â· exact (finrank_hom_simple_simple_eq_one_iff ğ•œ X Y).2 h\n  Â· exact (finrank_hom_simple_simple_eq_zero_iff ğ•œ X Y).2 (not_nonempty_iff.mp h)\n\n"}
