{"name":"CategoryTheory.Limits.hasTerminalChangeDiagram","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nF₁ : CategoryTheory.Functor (CategoryTheory.Discrete PEmpty.{w + 1}) C\nF₂ : CategoryTheory.Functor (CategoryTheory.Discrete PEmpty.{w' + 1}) C\nh : CategoryTheory.Limits.HasLimit F₁\n⊢ CategoryTheory.Limits.HasLimit F₂","decl":"theorem hasTerminalChangeDiagram (h : HasLimit F₁) : HasLimit F₂ :=\n  ⟨⟨⟨⟨limit F₁, by aesop_cat, by simp⟩,\n    isLimitChangeEmptyCone C (limit.isLimit F₁) _ (eqToIso rfl)⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.hasTerminalChangeUniverse","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nh : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete PEmpty.{w + 1}) C\n⊢ CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete PEmpty.{w' + 1}) C","decl":"theorem hasTerminalChangeUniverse [h : HasLimitsOfShape (Discrete.{w} PEmpty) C] :\n    HasLimitsOfShape (Discrete.{w'} PEmpty) C where\n  has_limit _ := hasTerminalChangeDiagram C (h.1 (Functor.empty C))\n\n"}
{"name":"CategoryTheory.Limits.hasInitialChangeDiagram","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nF₁ : CategoryTheory.Functor (CategoryTheory.Discrete PEmpty.{w + 1}) C\nF₂ : CategoryTheory.Functor (CategoryTheory.Discrete PEmpty.{w' + 1}) C\nh : CategoryTheory.Limits.HasColimit F₁\n⊢ CategoryTheory.Limits.HasColimit F₂","decl":"theorem hasInitialChangeDiagram (h : HasColimit F₁) : HasColimit F₂ :=\n  ⟨⟨⟨⟨colimit F₁, by aesop_cat, by simp⟩,\n    isColimitChangeEmptyCocone C (colimit.isColimit F₁) _ (eqToIso rfl)⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.hasInitialChangeUniverse","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nh : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete PEmpty.{w + 1}) C\n⊢ CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete PEmpty.{w' + 1}) C","decl":"theorem hasInitialChangeUniverse [h : HasColimitsOfShape (Discrete.{w} PEmpty) C] :\n    HasColimitsOfShape (Discrete.{w'} PEmpty) C where\n  has_colimit _ := hasInitialChangeDiagram C (h.1 (Functor.empty C))\n\n"}
{"name":"CategoryTheory.Limits.hasTerminal_of_unique","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX : C\ninst✝¹ : ∀ (Y : C), Nonempty (Quiver.Hom Y X)\ninst✝ : ∀ (Y : C), Subsingleton (Quiver.Hom Y X)\n⊢ CategoryTheory.Limits.HasTerminal C","decl":"/-- We can more explicitly show that a category has a terminal object by specifying the object,\nand showing there is a unique morphism to it from any other object. -/\ntheorem hasTerminal_of_unique (X : C) [∀ Y, Nonempty (Y ⟶ X)] [∀ Y, Subsingleton (Y ⟶ X)] :\n    HasTerminal C where\n  has_limit F := .mk ⟨_, (isTerminalEquivUnique F X).invFun fun _ ↦\n    ⟨Classical.inhabited_of_nonempty', (Subsingleton.elim · _)⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.IsTerminal.hasTerminal","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nh : CategoryTheory.Limits.IsTerminal X\n⊢ CategoryTheory.Limits.HasTerminal C","decl":"theorem IsTerminal.hasTerminal {X : C} (h : IsTerminal X) : HasTerminal C :=\n  { has_limit := fun F => HasLimit.mk ⟨⟨X, by aesop_cat, by simp⟩,\n    isLimitChangeEmptyCone _ h _ (Iso.refl _)⟩ }\n\n"}
{"name":"CategoryTheory.Limits.hasInitial_of_unique","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX : C\ninst✝¹ : ∀ (Y : C), Nonempty (Quiver.Hom X Y)\ninst✝ : ∀ (Y : C), Subsingleton (Quiver.Hom X Y)\n⊢ CategoryTheory.Limits.HasInitial C","decl":"/-- We can more explicitly show that a category has an initial object by specifying the object,\nand showing there is a unique morphism from it to any other object. -/\ntheorem hasInitial_of_unique (X : C) [∀ Y, Nonempty (X ⟶ Y)] [∀ Y, Subsingleton (X ⟶ Y)] :\n    HasInitial C where\n  has_colimit F := .mk ⟨_, (isInitialEquivUnique F X).invFun fun _ ↦\n    ⟨Classical.inhabited_of_nonempty', (Subsingleton.elim · _)⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.IsInitial.hasInitial","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nh : CategoryTheory.Limits.IsInitial X\n⊢ CategoryTheory.Limits.HasInitial C","decl":"theorem IsInitial.hasInitial {X : C} (h : IsInitial X) : HasInitial C where\n  has_colimit F :=\n    HasColimit.mk ⟨⟨X, by aesop_cat, by simp⟩, isColimitChangeEmptyCocone _ h _ (Iso.refl _)⟩\n\n"}
{"name":"CategoryTheory.Limits.terminal.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\nP : C\nf g : Quiver.Hom P (CategoryTheory.Limits.terminal C)\n⊢ Iff (Eq f g) True","decl":"@[ext] theorem terminal.hom_ext [HasTerminal C] {P : C} (f g : P ⟶ ⊤_ C) : f = g := by ext ⟨⟨⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.terminal.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\nP : C\nf g : Quiver.Hom P (CategoryTheory.Limits.terminal C)\n⊢ Eq f g","decl":"@[ext] theorem terminal.hom_ext [HasTerminal C] {P : C} (f g : P ⟶ ⊤_ C) : f = g := by ext ⟨⟨⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.initial.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasInitial C\nP : C\nf g : Quiver.Hom (CategoryTheory.Limits.initial C) P\n⊢ Iff (Eq f g) True","decl":"@[ext] theorem initial.hom_ext [HasInitial C] {P : C} (f g : ⊥_ C ⟶ P) : f = g := by ext ⟨⟨⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.initial.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasInitial C\nP : C\nf g : Quiver.Hom (CategoryTheory.Limits.initial C) P\n⊢ Eq f g","decl":"@[ext] theorem initial.hom_ext [HasInitial C] {P : C} (f g : ⊥_ C ⟶ P) : f = g := by ext ⟨⟨⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.terminal.comp_from","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\nP Q : C\nf : Quiver.Hom P Q\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.terminal.from Q)) (CategoryTheory.Limits.terminal.from P)","decl":"@[simp]\ntheorem terminal.comp_from [HasTerminal C] {P Q : C} (f : P ⟶ Q) :\n    f ≫ terminal.from Q = terminal.from P := by\n  simp [eq_iff_true_of_subsingleton]\n\n"}
{"name":"CategoryTheory.Limits.initial.to_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasInitial C\nP Q : C\nf : Quiver.Hom P Q\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.initial.to P) f) (CategoryTheory.Limits.initial.to Q)","decl":"@[simp]\ntheorem initial.to_comp [HasInitial C] {P Q : C} (f : P ⟶ Q) : initial.to P ≫ f = initial.to Q := by\n  simp [eq_iff_true_of_subsingleton]\n\n"}
{"name":"CategoryTheory.Limits.terminal.isSplitMono_from","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nY : C\ninst✝ : CategoryTheory.Limits.HasTerminal C\nf : Quiver.Hom (CategoryTheory.Limits.terminal C) Y\n⊢ CategoryTheory.IsSplitMono f","decl":"/-- Any morphism from a terminal object is split mono. -/\ninstance terminal.isSplitMono_from {Y : C} [HasTerminal C] (f : ⊤_ C ⟶ Y) : IsSplitMono f :=\n  IsTerminal.isSplitMono_from terminalIsTerminal _\n\n"}
{"name":"CategoryTheory.Limits.initial.isSplitEpi_to","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nY : C\ninst✝ : CategoryTheory.Limits.HasInitial C\nf : Quiver.Hom Y (CategoryTheory.Limits.initial C)\n⊢ CategoryTheory.IsSplitEpi f","decl":"/-- Any morphism to an initial object is split epi. -/\ninstance initial.isSplitEpi_to {Y : C} [HasInitial C] (f : Y ⟶ ⊥_ C) : IsSplitEpi f :=\n  IsInitial.isSplitEpi_to initialIsInitial _\n\n"}
{"name":"CategoryTheory.Limits.hasInitial_op_of_hasTerminal","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\n⊢ CategoryTheory.Limits.HasInitial (Opposite C)","decl":"instance hasInitial_op_of_hasTerminal [HasTerminal C] : HasInitial Cᵒᵖ :=\n  (initialOpOfTerminal terminalIsTerminal).hasInitial\n\n"}
{"name":"CategoryTheory.Limits.hasTerminal_op_of_hasInitial","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasInitial C\n⊢ CategoryTheory.Limits.HasTerminal (Opposite C)","decl":"instance hasTerminal_op_of_hasInitial [HasInitial C] : HasTerminal Cᵒᵖ :=\n  (terminalOpOfInitial initialIsInitial).hasTerminal\n\n"}
{"name":"CategoryTheory.Limits.hasTerminal_of_hasInitial_op","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasInitial (Opposite C)\n⊢ CategoryTheory.Limits.HasTerminal C","decl":"theorem hasTerminal_of_hasInitial_op [HasInitial Cᵒᵖ] : HasTerminal C :=\n  (terminalUnopOfInitial initialIsInitial).hasTerminal\n\n"}
{"name":"CategoryTheory.Limits.hasInitial_of_hasTerminal_op","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasTerminal (Opposite C)\n⊢ CategoryTheory.Limits.HasInitial C","decl":"theorem hasInitial_of_hasTerminal_op [HasTerminal Cᵒᵖ] : HasInitial C :=\n  (initialUnopOfTerminal terminalIsTerminal).hasInitial\n\n"}
{"name":"CategoryTheory.Limits.instHasLimitObjFunctorConstTerminal","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"J : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\n⊢ CategoryTheory.Limits.HasLimit ((CategoryTheory.Functor.const J).obj (CategoryTheory.Limits.terminal C))","decl":"instance {J : Type*} [Category J] {C : Type*} [Category C] [HasTerminal C] :\n    HasLimit ((CategoryTheory.Functor.const J).obj (⊤_ C)) :=\n  HasLimit.mk\n    { cone :=\n        { pt := ⊤_ C\n          π := { app := fun _ => terminal.from _ } }\n      isLimit := { lift := fun _ => terminal.from _ } }\n\n"}
{"name":"CategoryTheory.Limits.limitConstTerminal_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"J : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\n⊢ Eq CategoryTheory.Limits.limitConstTerminal.hom (CategoryTheory.Limits.terminal.from (CategoryTheory.Limits.limit ((CategoryTheory.Functor.const J).obj (CategoryTheory.Limits.terminal C))))","decl":"/-- The limit of the constant `⊤_ C` functor is `⊤_ C`. -/\n@[simps hom]\ndef limitConstTerminal {J : Type*} [Category J] {C : Type*} [Category C] [HasTerminal C] :\n    limit ((CategoryTheory.Functor.const J).obj (⊤_ C)) ≅ ⊤_ C where\n  hom := terminal.from _\n  inv :=\n    limit.lift ((CategoryTheory.Functor.const J).obj (⊤_ C))\n      { pt := ⊤_ C\n        π := { app := fun _ => terminal.from _ } }\n\n"}
{"name":"CategoryTheory.Limits.limitConstTerminal_inv_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"J : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.limitConstTerminal.inv (CategoryTheory.Limits.limit.π ((CategoryTheory.Functor.const J).obj (CategoryTheory.Limits.terminal C)) j)) (CategoryTheory.Limits.terminal.from (CategoryTheory.Limits.terminal C))","decl":"@[reassoc (attr := simp)]\ntheorem limitConstTerminal_inv_π {J : Type*} [Category J] {C : Type*} [Category C] [HasTerminal C]\n    {j : J} :\n    limitConstTerminal.inv ≫ limit.π ((CategoryTheory.Functor.const J).obj (⊤_ C)) j =\n      terminal.from _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.limitConstTerminal_inv_π_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"J : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\nj : J\nZ : C\nh : Quiver.Hom (((CategoryTheory.Functor.const J).obj (CategoryTheory.Limits.terminal C)).obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.limitConstTerminal.inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π ((CategoryTheory.Functor.const J).obj (CategoryTheory.Limits.terminal C)) j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.terminal.from (CategoryTheory.Limits.terminal C)) h)","decl":"@[reassoc (attr := simp)]\ntheorem limitConstTerminal_inv_π {J : Type*} [Category J] {C : Type*} [Category C] [HasTerminal C]\n    {j : J} :\n    limitConstTerminal.inv ≫ limit.π ((CategoryTheory.Functor.const J).obj (⊤_ C)) j =\n      terminal.from _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.instHasColimitObjFunctorConstInitial","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"J : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.Limits.HasInitial C\n⊢ CategoryTheory.Limits.HasColimit ((CategoryTheory.Functor.const J).obj (CategoryTheory.Limits.initial C))","decl":"instance {J : Type*} [Category J] {C : Type*} [Category C] [HasInitial C] :\n    HasColimit ((CategoryTheory.Functor.const J).obj (⊥_ C)) :=\n  HasColimit.mk\n    { cocone :=\n        { pt := ⊥_ C\n          ι := { app := fun _ => initial.to _ } }\n      isColimit := { desc := fun _ => initial.to _ } }\n\n"}
{"name":"CategoryTheory.Limits.colimitConstInitial_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"J : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.Limits.HasInitial C\n⊢ Eq CategoryTheory.Limits.colimitConstInitial.inv (CategoryTheory.Limits.initial.to (CategoryTheory.Limits.colimit ((CategoryTheory.Functor.const J).obj (CategoryTheory.Limits.initial C))))","decl":"/-- The colimit of the constant `⊥_ C` functor is `⊥_ C`. -/\n@[simps inv]\ndef colimitConstInitial {J : Type*} [Category J] {C : Type*} [Category C] [HasInitial C] :\n    colimit ((CategoryTheory.Functor.const J).obj (⊥_ C)) ≅ ⊥_ C where\n  hom :=\n    colimit.desc ((CategoryTheory.Functor.const J).obj (⊥_ C))\n      { pt := ⊥_ C\n        ι := { app := fun _ => initial.to _ } }\n  inv := initial.to _\n\n"}
{"name":"CategoryTheory.Limits.ι_colimitConstInitial_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"J : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.Limits.HasInitial C\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.initial C) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι ((CategoryTheory.Functor.const J).obj (CategoryTheory.Limits.initial C)) j) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.colimitConstInitial.hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.initial.to (CategoryTheory.Limits.initial C)) h)","decl":"@[reassoc (attr := simp)]\ntheorem ι_colimitConstInitial_hom {J : Type*} [Category J] {C : Type*} [Category C] [HasInitial C]\n    {j : J} :\n    colimit.ι ((CategoryTheory.Functor.const J).obj (⊥_ C)) j ≫ colimitConstInitial.hom =\n      initial.to _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.ι_colimitConstInitial_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"J : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.Limits.HasInitial C\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι ((CategoryTheory.Functor.const J).obj (CategoryTheory.Limits.initial C)) j) CategoryTheory.Limits.colimitConstInitial.hom) (CategoryTheory.Limits.initial.to (CategoryTheory.Limits.initial C))","decl":"@[reassoc (attr := simp)]\ntheorem ι_colimitConstInitial_hom {J : Type*} [Category J] {C : Type*} [Category C] [HasInitial C]\n    {j : J} :\n    colimit.ι ((CategoryTheory.Functor.const J).obj (⊥_ C)) j ≫ colimitConstInitial.hom =\n      initial.to _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.initial.mono_from","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasInitial C\ninst✝ : CategoryTheory.Limits.InitialMonoClass C\nX : C\nf : Quiver.Hom (CategoryTheory.Limits.initial C) X\n⊢ CategoryTheory.Mono f","decl":"instance (priority := 100) initial.mono_from [HasInitial C] [InitialMonoClass C] (X : C)\n    (f : ⊥_ C ⟶ X) : Mono f :=\n  initialIsInitial.mono_from f\n\n"}
{"name":"CategoryTheory.Limits.InitialMonoClass.of_initial","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasInitial C\nh : ∀ (X : C), CategoryTheory.Mono (CategoryTheory.Limits.initial.to X)\n⊢ CategoryTheory.Limits.InitialMonoClass C","decl":"/-- To show a category is an `InitialMonoClass` it suffices to show every morphism out of the\ninitial object is a monomorphism. -/\ntheorem InitialMonoClass.of_initial [HasInitial C] (h : ∀ X : C, Mono (initial.to X)) :\n    InitialMonoClass C :=\n  InitialMonoClass.of_isInitial initialIsInitial h\n\n"}
{"name":"CategoryTheory.Limits.InitialMonoClass.of_terminal","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasInitial C\ninst✝ : CategoryTheory.Limits.HasTerminal C\nh : CategoryTheory.Mono (CategoryTheory.Limits.initial.to (CategoryTheory.Limits.terminal C))\n⊢ CategoryTheory.Limits.InitialMonoClass C","decl":"/-- To show a category is an `InitialMonoClass` it suffices to show the unique morphism from the\ninitial object to a terminal object is a monomorphism. -/\ntheorem InitialMonoClass.of_terminal [HasInitial C] [HasTerminal C] (h : Mono (initial.to (⊤_ C))) :\n    InitialMonoClass C :=\n  InitialMonoClass.of_isTerminal initialIsInitial terminalIsTerminal h\n\n"}
{"name":"CategoryTheory.Limits.hasLimit_of_domain_hasInitial","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\ninst✝ : CategoryTheory.Limits.HasInitial J\nF : CategoryTheory.Functor J C\n⊢ CategoryTheory.Limits.HasLimit F","decl":"instance hasLimit_of_domain_hasInitial [HasInitial J] {F : J ⥤ C} : HasLimit F :=\n  HasLimit.mk { cone := _, isLimit := limitOfDiagramInitial (initialIsInitial) F }\n\n-- See note [dsimp, simp]\n-- This is reducible to allow usage of lemmas about `cone_point_unique_up_to_iso`.\n"}
{"name":"CategoryTheory.Limits.hasLimit_of_domain_hasTerminal","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\ninst✝¹ : CategoryTheory.Limits.HasTerminal J\nF : CategoryTheory.Functor J C\ninst✝ : ∀ (i j : J) (f : Quiver.Hom i j), CategoryTheory.IsIso (F.map f)\n⊢ CategoryTheory.Limits.HasLimit F","decl":"instance hasLimit_of_domain_hasTerminal [HasTerminal J] {F : J ⥤ C}\n    [∀ (i j : J) (f : i ⟶ j), IsIso (F.map f)] : HasLimit F :=\n  HasLimit.mk { cone := _, isLimit := limitOfDiagramTerminal (terminalIsTerminal) F }\n\n-- This is reducible to allow usage of lemmas about `cone_point_unique_up_to_iso`.\n"}
{"name":"CategoryTheory.Limits.hasColimit_of_domain_hasTerminal","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\ninst✝ : CategoryTheory.Limits.HasTerminal J\nF : CategoryTheory.Functor J C\n⊢ CategoryTheory.Limits.HasColimit F","decl":"instance hasColimit_of_domain_hasTerminal [HasTerminal J] {F : J ⥤ C} : HasColimit F :=\n  HasColimit.mk { cocone := _, isColimit := colimitOfDiagramTerminal (terminalIsTerminal) F }\n\n-- This is reducible to allow usage of lemmas about `cocone_point_unique_up_to_iso`.\n"}
{"name":"CategoryTheory.Limits.hasColimit_of_domain_hasInitial","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\ninst✝¹ : CategoryTheory.Limits.HasInitial J\nF : CategoryTheory.Functor J C\ninst✝ : ∀ (i j : J) (f : Quiver.Hom i j), CategoryTheory.IsIso (F.map f)\n⊢ CategoryTheory.Limits.HasColimit F","decl":"instance hasColimit_of_domain_hasInitial [HasInitial J] {F : J ⥤ C}\n    [∀ (i j : J) (f : i ⟶ j), IsIso (F.map f)] : HasColimit F :=\n  HasColimit.mk { cocone := _, isColimit := colimitOfDiagramInitial (initialIsInitial) F }\n\n-- This is reducible to allow usage of lemmas about `cocone_point_unique_up_to_iso`.\n"}
{"name":"CategoryTheory.Limits.isIso_π_of_isInitial","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nj : J\nI : CategoryTheory.Limits.IsInitial j\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.limit.π F j)","decl":"/-- If `j` is initial in the index category, then the map `limit.π F j` is an isomorphism.\n-/\ntheorem isIso_π_of_isInitial {j : J} (I : IsInitial j) (F : J ⥤ C) [HasLimit F] :\n    IsIso (limit.π F j) :=\n  ⟨⟨limit.lift _ (coneOfDiagramInitial I F), ⟨by ext; simp, by simp⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.isIso_π_initial","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\ninst✝ : CategoryTheory.Limits.HasInitial J\nF : CategoryTheory.Functor J C\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.limit.π F (CategoryTheory.Limits.initial J))","decl":"instance isIso_π_initial [HasInitial J] (F : J ⥤ C) : IsIso (limit.π F (⊥_ J)) :=\n  isIso_π_of_isInitial initialIsInitial F\n\n"}
{"name":"CategoryTheory.Limits.isIso_π_of_isTerminal","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nj : J\nI : CategoryTheory.Limits.IsTerminal j\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasLimit F\ninst✝ : ∀ (i j : J) (f : Quiver.Hom i j), CategoryTheory.IsIso (F.map f)\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.limit.π F j)","decl":"theorem isIso_π_of_isTerminal {j : J} (I : IsTerminal j) (F : J ⥤ C) [HasLimit F]\n    [∀ (i j : J) (f : i ⟶ j), IsIso (F.map f)] : IsIso (limit.π F j) :=\n  ⟨⟨limit.lift _ (coneOfDiagramTerminal I F), by ext; simp, by simp⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.isIso_π_terminal","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\ninst✝¹ : CategoryTheory.Limits.HasTerminal J\nF : CategoryTheory.Functor J C\ninst✝ : ∀ (i j : J) (f : Quiver.Hom i j), CategoryTheory.IsIso (F.map f)\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.limit.π F (CategoryTheory.Limits.terminal J))","decl":"instance isIso_π_terminal [HasTerminal J] (F : J ⥤ C) [∀ (i j : J) (f : i ⟶ j), IsIso (F.map f)] :\n    IsIso (limit.π F (⊤_ J)) :=\n  isIso_π_of_isTerminal terminalIsTerminal F\n\n"}
{"name":"CategoryTheory.Limits.isIso_ι_of_isTerminal","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nj : J\nI : CategoryTheory.Limits.IsTerminal j\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.colimit.ι F j)","decl":"/-- If `j` is terminal in the index category, then the map `colimit.ι F j` is an isomorphism.\n-/\ntheorem isIso_ι_of_isTerminal {j : J} (I : IsTerminal j) (F : J ⥤ C) [HasColimit F] :\n    IsIso (colimit.ι F j) :=\n  ⟨⟨colimit.desc _ (coconeOfDiagramTerminal I F), ⟨by simp, by ext; simp⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.isIso_ι_terminal","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\ninst✝ : CategoryTheory.Limits.HasTerminal J\nF : CategoryTheory.Functor J C\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.colimit.ι F (CategoryTheory.Limits.terminal J))","decl":"instance isIso_ι_terminal [HasTerminal J] (F : J ⥤ C) : IsIso (colimit.ι F (⊤_ J)) :=\n  isIso_ι_of_isTerminal terminalIsTerminal F\n\n"}
{"name":"CategoryTheory.Limits.isIso_ι_of_isInitial","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nj : J\nI : CategoryTheory.Limits.IsInitial j\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\ninst✝ : ∀ (i j : J) (f : Quiver.Hom i j), CategoryTheory.IsIso (F.map f)\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.colimit.ι F j)","decl":"theorem isIso_ι_of_isInitial {j : J} (I : IsInitial j) (F : J ⥤ C) [HasColimit F]\n    [∀ (i j : J) (f : i ⟶ j), IsIso (F.map f)] : IsIso (colimit.ι F j) :=\n  ⟨⟨colimit.desc _ (coconeOfDiagramInitial I F), by\n    refine ⟨?_, by ext; simp⟩\n    dsimp; simp only [colimit.ι_desc, coconeOfDiagramInitial_pt, coconeOfDiagramInitial_ι_app,\n      Functor.const_obj_obj, IsInitial.to_self, Functor.map_id]\n    dsimp [inv]; simp only [Category.id_comp, Category.comp_id, and_self]\n    apply @Classical.choose_spec _ (fun x => x = 𝟙 F.obj j) _\n  ⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.isIso_ι_initial","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\ninst✝¹ : CategoryTheory.Limits.HasInitial J\nF : CategoryTheory.Functor J C\ninst✝ : ∀ (i j : J) (f : Quiver.Hom i j), CategoryTheory.IsIso (F.map f)\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.colimit.ι F (CategoryTheory.Limits.initial J))","decl":"instance isIso_ι_initial [HasInitial J] (F : J ⥤ C) [∀ (i j : J) (f : i ⟶ j), IsIso (F.map f)] :\n    IsIso (colimit.ι F (⊥_ J)) :=\n  isIso_ι_of_isInitial initialIsInitial F\n\n"}
