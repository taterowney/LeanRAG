{"name":"CategoryTheory.Limits.hasTerminalChangeDiagram","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nFâ‚ : CategoryTheory.Functor (CategoryTheory.Discrete PEmpty.{w + 1}) C\nFâ‚‚ : CategoryTheory.Functor (CategoryTheory.Discrete PEmpty.{w' + 1}) C\nh : CategoryTheory.Limits.HasLimit Fâ‚\nâŠ¢ CategoryTheory.Limits.HasLimit Fâ‚‚","decl":"theorem hasTerminalChangeDiagram (h : HasLimit Fâ‚) : HasLimit Fâ‚‚ :=\n  âŸ¨âŸ¨âŸ¨âŸ¨limit Fâ‚, by aesop_cat, by simpâŸ©,\n    isLimitChangeEmptyCone C (limit.isLimit Fâ‚) _ (eqToIso rfl)âŸ©âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Limits.hasTerminalChangeUniverse","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nh : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete PEmpty.{w + 1}) C\nâŠ¢ CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete PEmpty.{w' + 1}) C","decl":"theorem hasTerminalChangeUniverse [h : HasLimitsOfShape (Discrete.{w} PEmpty) C] :\n    HasLimitsOfShape (Discrete.{w'} PEmpty) C where\n  has_limit _ := hasTerminalChangeDiagram C (h.1 (Functor.empty C))\n\n"}
{"name":"CategoryTheory.Limits.hasInitialChangeDiagram","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nFâ‚ : CategoryTheory.Functor (CategoryTheory.Discrete PEmpty.{w + 1}) C\nFâ‚‚ : CategoryTheory.Functor (CategoryTheory.Discrete PEmpty.{w' + 1}) C\nh : CategoryTheory.Limits.HasColimit Fâ‚\nâŠ¢ CategoryTheory.Limits.HasColimit Fâ‚‚","decl":"theorem hasInitialChangeDiagram (h : HasColimit Fâ‚) : HasColimit Fâ‚‚ :=\n  âŸ¨âŸ¨âŸ¨âŸ¨colimit Fâ‚, by aesop_cat, by simpâŸ©,\n    isColimitChangeEmptyCocone C (colimit.isColimit Fâ‚) _ (eqToIso rfl)âŸ©âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Limits.hasInitialChangeUniverse","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nh : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete PEmpty.{w + 1}) C\nâŠ¢ CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete PEmpty.{w' + 1}) C","decl":"theorem hasInitialChangeUniverse [h : HasColimitsOfShape (Discrete.{w} PEmpty) C] :\n    HasColimitsOfShape (Discrete.{w'} PEmpty) C where\n  has_colimit _ := hasInitialChangeDiagram C (h.1 (Functor.empty C))\n\n"}
{"name":"CategoryTheory.Limits.hasTerminal_of_unique","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nX : C\ninstâœÂ¹ : âˆ€ (Y : C), Nonempty (Quiver.Hom Y X)\ninstâœ : âˆ€ (Y : C), Subsingleton (Quiver.Hom Y X)\nâŠ¢ CategoryTheory.Limits.HasTerminal C","decl":"/-- We can more explicitly show that a category has a terminal object by specifying the object,\nand showing there is a unique morphism to it from any other object. -/\ntheorem hasTerminal_of_unique (X : C) [âˆ€ Y, Nonempty (Y âŸ¶ X)] [âˆ€ Y, Subsingleton (Y âŸ¶ X)] :\n    HasTerminal C where\n  has_limit F := .mk âŸ¨_, (isTerminalEquivUnique F X).invFun fun _ â†¦\n    âŸ¨Classical.inhabited_of_nonempty', (Subsingleton.elim Â· _)âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Limits.IsTerminal.hasTerminal","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nX : C\nh : CategoryTheory.Limits.IsTerminal X\nâŠ¢ CategoryTheory.Limits.HasTerminal C","decl":"theorem IsTerminal.hasTerminal {X : C} (h : IsTerminal X) : HasTerminal C :=\n  { has_limit := fun F => HasLimit.mk âŸ¨âŸ¨X, by aesop_cat, by simpâŸ©,\n    isLimitChangeEmptyCone _ h _ (Iso.refl _)âŸ© }\n\n"}
{"name":"CategoryTheory.Limits.hasInitial_of_unique","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nX : C\ninstâœÂ¹ : âˆ€ (Y : C), Nonempty (Quiver.Hom X Y)\ninstâœ : âˆ€ (Y : C), Subsingleton (Quiver.Hom X Y)\nâŠ¢ CategoryTheory.Limits.HasInitial C","decl":"/-- We can more explicitly show that a category has an initial object by specifying the object,\nand showing there is a unique morphism from it to any other object. -/\ntheorem hasInitial_of_unique (X : C) [âˆ€ Y, Nonempty (X âŸ¶ Y)] [âˆ€ Y, Subsingleton (X âŸ¶ Y)] :\n    HasInitial C where\n  has_colimit F := .mk âŸ¨_, (isInitialEquivUnique F X).invFun fun _ â†¦\n    âŸ¨Classical.inhabited_of_nonempty', (Subsingleton.elim Â· _)âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Limits.IsInitial.hasInitial","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nX : C\nh : CategoryTheory.Limits.IsInitial X\nâŠ¢ CategoryTheory.Limits.HasInitial C","decl":"theorem IsInitial.hasInitial {X : C} (h : IsInitial X) : HasInitial C where\n  has_colimit F :=\n    HasColimit.mk âŸ¨âŸ¨X, by aesop_cat, by simpâŸ©, isColimitChangeEmptyCocone _ h _ (Iso.refl _)âŸ©\n\n"}
{"name":"CategoryTheory.Limits.terminal.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.Limits.HasTerminal C\nP : C\nf g : Quiver.Hom P (CategoryTheory.Limits.terminal C)\nâŠ¢ Iff (Eq f g) True","decl":"@[ext] theorem terminal.hom_ext [HasTerminal C] {P : C} (f g : P âŸ¶ âŠ¤_ C) : f = g := by ext âŸ¨âŸ¨âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Limits.terminal.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.Limits.HasTerminal C\nP : C\nf g : Quiver.Hom P (CategoryTheory.Limits.terminal C)\nâŠ¢ Eq f g","decl":"@[ext] theorem terminal.hom_ext [HasTerminal C] {P : C} (f g : P âŸ¶ âŠ¤_ C) : f = g := by ext âŸ¨âŸ¨âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Limits.initial.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.Limits.HasInitial C\nP : C\nf g : Quiver.Hom (CategoryTheory.Limits.initial C) P\nâŠ¢ Iff (Eq f g) True","decl":"@[ext] theorem initial.hom_ext [HasInitial C] {P : C} (f g : âŠ¥_ C âŸ¶ P) : f = g := by ext âŸ¨âŸ¨âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Limits.initial.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.Limits.HasInitial C\nP : C\nf g : Quiver.Hom (CategoryTheory.Limits.initial C) P\nâŠ¢ Eq f g","decl":"@[ext] theorem initial.hom_ext [HasInitial C] {P : C} (f g : âŠ¥_ C âŸ¶ P) : f = g := by ext âŸ¨âŸ¨âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Limits.terminal.comp_from","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.Limits.HasTerminal C\nP Q : C\nf : Quiver.Hom P Q\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.terminal.from Q)) (CategoryTheory.Limits.terminal.from P)","decl":"@[simp]\ntheorem terminal.comp_from [HasTerminal C] {P Q : C} (f : P âŸ¶ Q) :\n    f â‰« terminal.from Q = terminal.from P := by\n  simp [eq_iff_true_of_subsingleton]\n\n"}
{"name":"CategoryTheory.Limits.initial.to_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.Limits.HasInitial C\nP Q : C\nf : Quiver.Hom P Q\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.initial.to P) f) (CategoryTheory.Limits.initial.to Q)","decl":"@[simp]\ntheorem initial.to_comp [HasInitial C] {P Q : C} (f : P âŸ¶ Q) : initial.to P â‰« f = initial.to Q := by\n  simp [eq_iff_true_of_subsingleton]\n\n"}
{"name":"CategoryTheory.Limits.terminal.isSplitMono_from","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nY : C\ninstâœ : CategoryTheory.Limits.HasTerminal C\nf : Quiver.Hom (CategoryTheory.Limits.terminal C) Y\nâŠ¢ CategoryTheory.IsSplitMono f","decl":"/-- Any morphism from a terminal object is split mono. -/\ninstance terminal.isSplitMono_from {Y : C} [HasTerminal C] (f : âŠ¤_ C âŸ¶ Y) : IsSplitMono f :=\n  IsTerminal.isSplitMono_from terminalIsTerminal _\n\n"}
{"name":"CategoryTheory.Limits.initial.isSplitEpi_to","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nY : C\ninstâœ : CategoryTheory.Limits.HasInitial C\nf : Quiver.Hom Y (CategoryTheory.Limits.initial C)\nâŠ¢ CategoryTheory.IsSplitEpi f","decl":"/-- Any morphism to an initial object is split epi. -/\ninstance initial.isSplitEpi_to {Y : C} [HasInitial C] (f : Y âŸ¶ âŠ¥_ C) : IsSplitEpi f :=\n  IsInitial.isSplitEpi_to initialIsInitial _\n\n"}
{"name":"CategoryTheory.Limits.hasInitial_op_of_hasTerminal","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.Limits.HasTerminal C\nâŠ¢ CategoryTheory.Limits.HasInitial (Opposite C)","decl":"instance hasInitial_op_of_hasTerminal [HasTerminal C] : HasInitial Cáµ’áµ– :=\n  (initialOpOfTerminal terminalIsTerminal).hasInitial\n\n"}
{"name":"CategoryTheory.Limits.hasTerminal_op_of_hasInitial","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.Limits.HasInitial C\nâŠ¢ CategoryTheory.Limits.HasTerminal (Opposite C)","decl":"instance hasTerminal_op_of_hasInitial [HasInitial C] : HasTerminal Cáµ’áµ– :=\n  (terminalOpOfInitial initialIsInitial).hasTerminal\n\n"}
{"name":"CategoryTheory.Limits.hasTerminal_of_hasInitial_op","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.Limits.HasInitial (Opposite C)\nâŠ¢ CategoryTheory.Limits.HasTerminal C","decl":"theorem hasTerminal_of_hasInitial_op [HasInitial Cáµ’áµ–] : HasTerminal C :=\n  (terminalUnopOfInitial initialIsInitial).hasTerminal\n\n"}
{"name":"CategoryTheory.Limits.hasInitial_of_hasTerminal_op","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.Limits.HasTerminal (Opposite C)\nâŠ¢ CategoryTheory.Limits.HasInitial C","decl":"theorem hasInitial_of_hasTerminal_op [HasTerminal Cáµ’áµ–] : HasInitial C :=\n  (initialUnopOfTerminal terminalIsTerminal).hasInitial\n\n"}
{"name":"CategoryTheory.Limits.instHasLimitObjFunctorConstTerminal","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"J : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} J\nC : Type u_2\ninstâœÂ¹ : CategoryTheory.Category.{u_4, u_2} C\ninstâœ : CategoryTheory.Limits.HasTerminal C\nâŠ¢ CategoryTheory.Limits.HasLimit ((CategoryTheory.Functor.const J).obj (CategoryTheory.Limits.terminal C))","decl":"instance {J : Type*} [Category J] {C : Type*} [Category C] [HasTerminal C] :\n    HasLimit ((CategoryTheory.Functor.const J).obj (âŠ¤_ C)) :=\n  HasLimit.mk\n    { cone :=\n        { pt := âŠ¤_ C\n          Ï€ := { app := fun _ => terminal.from _ } }\n      isLimit := { lift := fun _ => terminal.from _ } }\n\n"}
{"name":"CategoryTheory.Limits.limitConstTerminal_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"J : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} J\nC : Type u_2\ninstâœÂ¹ : CategoryTheory.Category.{u_4, u_2} C\ninstâœ : CategoryTheory.Limits.HasTerminal C\nâŠ¢ Eq CategoryTheory.Limits.limitConstTerminal.hom (CategoryTheory.Limits.terminal.from (CategoryTheory.Limits.limit ((CategoryTheory.Functor.const J).obj (CategoryTheory.Limits.terminal C))))","decl":"/-- The limit of the constant `âŠ¤_ C` functor is `âŠ¤_ C`. -/\n@[simps hom]\ndef limitConstTerminal {J : Type*} [Category J] {C : Type*} [Category C] [HasTerminal C] :\n    limit ((CategoryTheory.Functor.const J).obj (âŠ¤_ C)) â‰… âŠ¤_ C where\n  hom := terminal.from _\n  inv :=\n    limit.lift ((CategoryTheory.Functor.const J).obj (âŠ¤_ C))\n      { pt := âŠ¤_ C\n        Ï€ := { app := fun _ => terminal.from _ } }\n\n"}
{"name":"CategoryTheory.Limits.limitConstTerminal_inv_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"J : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} J\nC : Type u_2\ninstâœÂ¹ : CategoryTheory.Category.{u_4, u_2} C\ninstâœ : CategoryTheory.Limits.HasTerminal C\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.limitConstTerminal.inv (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.Functor.const J).obj (CategoryTheory.Limits.terminal C)) j)) (CategoryTheory.Limits.terminal.from (CategoryTheory.Limits.terminal C))","decl":"@[reassoc (attr := simp)]\ntheorem limitConstTerminal_inv_Ï€ {J : Type*} [Category J] {C : Type*} [Category C] [HasTerminal C]\n    {j : J} :\n    limitConstTerminal.inv â‰« limit.Ï€ ((CategoryTheory.Functor.const J).obj (âŠ¤_ C)) j =\n      terminal.from _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.limitConstTerminal_inv_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"J : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} J\nC : Type u_2\ninstâœÂ¹ : CategoryTheory.Category.{u_4, u_2} C\ninstâœ : CategoryTheory.Limits.HasTerminal C\nj : J\nZ : C\nh : Quiver.Hom (((CategoryTheory.Functor.const J).obj (CategoryTheory.Limits.terminal C)).obj j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.limitConstTerminal.inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.Functor.const J).obj (CategoryTheory.Limits.terminal C)) j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.terminal.from (CategoryTheory.Limits.terminal C)) h)","decl":"@[reassoc (attr := simp)]\ntheorem limitConstTerminal_inv_Ï€ {J : Type*} [Category J] {C : Type*} [Category C] [HasTerminal C]\n    {j : J} :\n    limitConstTerminal.inv â‰« limit.Ï€ ((CategoryTheory.Functor.const J).obj (âŠ¤_ C)) j =\n      terminal.from _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.instHasColimitObjFunctorConstInitial","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"J : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} J\nC : Type u_2\ninstâœÂ¹ : CategoryTheory.Category.{u_4, u_2} C\ninstâœ : CategoryTheory.Limits.HasInitial C\nâŠ¢ CategoryTheory.Limits.HasColimit ((CategoryTheory.Functor.const J).obj (CategoryTheory.Limits.initial C))","decl":"instance {J : Type*} [Category J] {C : Type*} [Category C] [HasInitial C] :\n    HasColimit ((CategoryTheory.Functor.const J).obj (âŠ¥_ C)) :=\n  HasColimit.mk\n    { cocone :=\n        { pt := âŠ¥_ C\n          Î¹ := { app := fun _ => initial.to _ } }\n      isColimit := { desc := fun _ => initial.to _ } }\n\n"}
{"name":"CategoryTheory.Limits.colimitConstInitial_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"J : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} J\nC : Type u_2\ninstâœÂ¹ : CategoryTheory.Category.{u_4, u_2} C\ninstâœ : CategoryTheory.Limits.HasInitial C\nâŠ¢ Eq CategoryTheory.Limits.colimitConstInitial.inv (CategoryTheory.Limits.initial.to (CategoryTheory.Limits.colimit ((CategoryTheory.Functor.const J).obj (CategoryTheory.Limits.initial C))))","decl":"/-- The colimit of the constant `âŠ¥_ C` functor is `âŠ¥_ C`. -/\n@[simps inv]\ndef colimitConstInitial {J : Type*} [Category J] {C : Type*} [Category C] [HasInitial C] :\n    colimit ((CategoryTheory.Functor.const J).obj (âŠ¥_ C)) â‰… âŠ¥_ C where\n  hom :=\n    colimit.desc ((CategoryTheory.Functor.const J).obj (âŠ¥_ C))\n      { pt := âŠ¥_ C\n        Î¹ := { app := fun _ => initial.to _ } }\n  inv := initial.to _\n\n"}
{"name":"CategoryTheory.Limits.Î¹_colimitConstInitial_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"J : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} J\nC : Type u_2\ninstâœÂ¹ : CategoryTheory.Category.{u_4, u_2} C\ninstâœ : CategoryTheory.Limits.HasInitial C\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.initial C) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.Functor.const J).obj (CategoryTheory.Limits.initial C)) j) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.colimitConstInitial.hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.initial.to (CategoryTheory.Limits.initial C)) h)","decl":"@[reassoc (attr := simp)]\ntheorem Î¹_colimitConstInitial_hom {J : Type*} [Category J] {C : Type*} [Category C] [HasInitial C]\n    {j : J} :\n    colimit.Î¹ ((CategoryTheory.Functor.const J).obj (âŠ¥_ C)) j â‰« colimitConstInitial.hom =\n      initial.to _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.Î¹_colimitConstInitial_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"J : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} J\nC : Type u_2\ninstâœÂ¹ : CategoryTheory.Category.{u_4, u_2} C\ninstâœ : CategoryTheory.Limits.HasInitial C\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.Functor.const J).obj (CategoryTheory.Limits.initial C)) j) CategoryTheory.Limits.colimitConstInitial.hom) (CategoryTheory.Limits.initial.to (CategoryTheory.Limits.initial C))","decl":"@[reassoc (attr := simp)]\ntheorem Î¹_colimitConstInitial_hom {J : Type*} [Category J] {C : Type*} [Category C] [HasInitial C]\n    {j : J} :\n    colimit.Î¹ ((CategoryTheory.Functor.const J).obj (âŠ¥_ C)) j â‰« colimitConstInitial.hom =\n      initial.to _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.initial.mono_from","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Limits.HasInitial C\ninstâœ : CategoryTheory.Limits.InitialMonoClass C\nX : C\nf : Quiver.Hom (CategoryTheory.Limits.initial C) X\nâŠ¢ CategoryTheory.Mono f","decl":"instance (priority := 100) initial.mono_from [HasInitial C] [InitialMonoClass C] (X : C)\n    (f : âŠ¥_ C âŸ¶ X) : Mono f :=\n  initialIsInitial.mono_from f\n\n"}
{"name":"CategoryTheory.Limits.InitialMonoClass.of_initial","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.Limits.HasInitial C\nh : âˆ€ (X : C), CategoryTheory.Mono (CategoryTheory.Limits.initial.to X)\nâŠ¢ CategoryTheory.Limits.InitialMonoClass C","decl":"/-- To show a category is an `InitialMonoClass` it suffices to show every morphism out of the\ninitial object is a monomorphism. -/\ntheorem InitialMonoClass.of_initial [HasInitial C] (h : âˆ€ X : C, Mono (initial.to X)) :\n    InitialMonoClass C :=\n  InitialMonoClass.of_isInitial initialIsInitial h\n\n"}
{"name":"CategoryTheory.Limits.InitialMonoClass.of_terminal","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Limits.HasInitial C\ninstâœ : CategoryTheory.Limits.HasTerminal C\nh : CategoryTheory.Mono (CategoryTheory.Limits.initial.to (CategoryTheory.Limits.terminal C))\nâŠ¢ CategoryTheory.Limits.InitialMonoClass C","decl":"/-- To show a category is an `InitialMonoClass` it suffices to show the unique morphism from the\ninitial object to a terminal object is a monomorphism. -/\ntheorem InitialMonoClass.of_terminal [HasInitial C] [HasTerminal C] (h : Mono (initial.to (âŠ¤_ C))) :\n    InitialMonoClass C :=\n  InitialMonoClass.of_isTerminal initialIsInitial terminalIsTerminal h\n\n"}
{"name":"CategoryTheory.Limits.hasLimit_of_domain_hasInitial","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nJ : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} J\ninstâœ : CategoryTheory.Limits.HasInitial J\nF : CategoryTheory.Functor J C\nâŠ¢ CategoryTheory.Limits.HasLimit F","decl":"instance hasLimit_of_domain_hasInitial [HasInitial J] {F : J â¥¤ C} : HasLimit F :=\n  HasLimit.mk { cone := _, isLimit := limitOfDiagramInitial (initialIsInitial) F }\n\n-- See note [dsimp, simp]\n-- This is reducible to allow usage of lemmas about `cone_point_unique_up_to_iso`.\n"}
{"name":"CategoryTheory.Limits.hasLimit_of_domain_hasTerminal","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nJ : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} J\ninstâœÂ¹ : CategoryTheory.Limits.HasTerminal J\nF : CategoryTheory.Functor J C\ninstâœ : âˆ€ (i j : J) (f : Quiver.Hom i j), CategoryTheory.IsIso (F.map f)\nâŠ¢ CategoryTheory.Limits.HasLimit F","decl":"instance hasLimit_of_domain_hasTerminal [HasTerminal J] {F : J â¥¤ C}\n    [âˆ€ (i j : J) (f : i âŸ¶ j), IsIso (F.map f)] : HasLimit F :=\n  HasLimit.mk { cone := _, isLimit := limitOfDiagramTerminal (terminalIsTerminal) F }\n\n-- This is reducible to allow usage of lemmas about `cone_point_unique_up_to_iso`.\n"}
{"name":"CategoryTheory.Limits.hasColimit_of_domain_hasTerminal","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nJ : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} J\ninstâœ : CategoryTheory.Limits.HasTerminal J\nF : CategoryTheory.Functor J C\nâŠ¢ CategoryTheory.Limits.HasColimit F","decl":"instance hasColimit_of_domain_hasTerminal [HasTerminal J] {F : J â¥¤ C} : HasColimit F :=\n  HasColimit.mk { cocone := _, isColimit := colimitOfDiagramTerminal (terminalIsTerminal) F }\n\n-- This is reducible to allow usage of lemmas about `cocone_point_unique_up_to_iso`.\n"}
{"name":"CategoryTheory.Limits.hasColimit_of_domain_hasInitial","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nJ : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} J\ninstâœÂ¹ : CategoryTheory.Limits.HasInitial J\nF : CategoryTheory.Functor J C\ninstâœ : âˆ€ (i j : J) (f : Quiver.Hom i j), CategoryTheory.IsIso (F.map f)\nâŠ¢ CategoryTheory.Limits.HasColimit F","decl":"instance hasColimit_of_domain_hasInitial [HasInitial J] {F : J â¥¤ C}\n    [âˆ€ (i j : J) (f : i âŸ¶ j), IsIso (F.map f)] : HasColimit F :=\n  HasColimit.mk { cocone := _, isColimit := colimitOfDiagramInitial (initialIsInitial) F }\n\n-- This is reducible to allow usage of lemmas about `cocone_point_unique_up_to_iso`.\n"}
{"name":"CategoryTheory.Limits.isIso_Ï€_of_isInitial","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nJ : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} J\nj : J\nI : CategoryTheory.Limits.IsInitial j\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Limits.limit.Ï€ F j)","decl":"/-- If `j` is initial in the index category, then the map `limit.Ï€ F j` is an isomorphism.\n-/\ntheorem isIso_Ï€_of_isInitial {j : J} (I : IsInitial j) (F : J â¥¤ C) [HasLimit F] :\n    IsIso (limit.Ï€ F j) :=\n  âŸ¨âŸ¨limit.lift _ (coneOfDiagramInitial I F), âŸ¨by ext; simp, by simpâŸ©âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Limits.isIso_Ï€_initial","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nJ : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} J\ninstâœ : CategoryTheory.Limits.HasInitial J\nF : CategoryTheory.Functor J C\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Limits.limit.Ï€ F (CategoryTheory.Limits.initial J))","decl":"instance isIso_Ï€_initial [HasInitial J] (F : J â¥¤ C) : IsIso (limit.Ï€ F (âŠ¥_ J)) :=\n  isIso_Ï€_of_isInitial initialIsInitial F\n\n"}
{"name":"CategoryTheory.Limits.isIso_Ï€_of_isTerminal","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nJ : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} J\nj : J\nI : CategoryTheory.Limits.IsTerminal j\nF : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit F\ninstâœ : âˆ€ (i j : J) (f : Quiver.Hom i j), CategoryTheory.IsIso (F.map f)\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Limits.limit.Ï€ F j)","decl":"theorem isIso_Ï€_of_isTerminal {j : J} (I : IsTerminal j) (F : J â¥¤ C) [HasLimit F]\n    [âˆ€ (i j : J) (f : i âŸ¶ j), IsIso (F.map f)] : IsIso (limit.Ï€ F j) :=\n  âŸ¨âŸ¨limit.lift _ (coneOfDiagramTerminal I F), by ext; simp, by simpâŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Limits.isIso_Ï€_terminal","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nJ : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} J\ninstâœÂ¹ : CategoryTheory.Limits.HasTerminal J\nF : CategoryTheory.Functor J C\ninstâœ : âˆ€ (i j : J) (f : Quiver.Hom i j), CategoryTheory.IsIso (F.map f)\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Limits.limit.Ï€ F (CategoryTheory.Limits.terminal J))","decl":"instance isIso_Ï€_terminal [HasTerminal J] (F : J â¥¤ C) [âˆ€ (i j : J) (f : i âŸ¶ j), IsIso (F.map f)] :\n    IsIso (limit.Ï€ F (âŠ¤_ J)) :=\n  isIso_Ï€_of_isTerminal terminalIsTerminal F\n\n"}
{"name":"CategoryTheory.Limits.isIso_Î¹_of_isTerminal","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nJ : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} J\nj : J\nI : CategoryTheory.Limits.IsTerminal j\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Limits.colimit.Î¹ F j)","decl":"/-- If `j` is terminal in the index category, then the map `colimit.Î¹ F j` is an isomorphism.\n-/\ntheorem isIso_Î¹_of_isTerminal {j : J} (I : IsTerminal j) (F : J â¥¤ C) [HasColimit F] :\n    IsIso (colimit.Î¹ F j) :=\n  âŸ¨âŸ¨colimit.desc _ (coconeOfDiagramTerminal I F), âŸ¨by simp, by ext; simpâŸ©âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Limits.isIso_Î¹_terminal","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nJ : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} J\ninstâœ : CategoryTheory.Limits.HasTerminal J\nF : CategoryTheory.Functor J C\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Limits.colimit.Î¹ F (CategoryTheory.Limits.terminal J))","decl":"instance isIso_Î¹_terminal [HasTerminal J] (F : J â¥¤ C) : IsIso (colimit.Î¹ F (âŠ¤_ J)) :=\n  isIso_Î¹_of_isTerminal terminalIsTerminal F\n\n"}
{"name":"CategoryTheory.Limits.isIso_Î¹_of_isInitial","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nJ : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} J\nj : J\nI : CategoryTheory.Limits.IsInitial j\nF : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit F\ninstâœ : âˆ€ (i j : J) (f : Quiver.Hom i j), CategoryTheory.IsIso (F.map f)\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Limits.colimit.Î¹ F j)","decl":"theorem isIso_Î¹_of_isInitial {j : J} (I : IsInitial j) (F : J â¥¤ C) [HasColimit F]\n    [âˆ€ (i j : J) (f : i âŸ¶ j), IsIso (F.map f)] : IsIso (colimit.Î¹ F j) :=\n  âŸ¨âŸ¨colimit.desc _ (coconeOfDiagramInitial I F), by\n    refine âŸ¨?_, by ext; simpâŸ©\n    dsimp; simp only [colimit.Î¹_desc, coconeOfDiagramInitial_pt, coconeOfDiagramInitial_Î¹_app,\n      Functor.const_obj_obj, IsInitial.to_self, Functor.map_id]\n    dsimp [inv]; simp only [Category.id_comp, Category.comp_id, and_self]\n    apply @Classical.choose_spec _ (fun x => x = ğŸ™ F.obj j) _\n  âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Limits.isIso_Î¹_initial","module":"Mathlib.CategoryTheory.Limits.Shapes.Terminal","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nJ : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} J\ninstâœÂ¹ : CategoryTheory.Limits.HasInitial J\nF : CategoryTheory.Functor J C\ninstâœ : âˆ€ (i j : J) (f : Quiver.Hom i j), CategoryTheory.IsIso (F.map f)\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Limits.colimit.Î¹ F (CategoryTheory.Limits.initial J))","decl":"instance isIso_Î¹_initial [HasInitial J] (F : J â¥¤ C) [âˆ€ (i j : J) (f : i âŸ¶ j), IsIso (F.map f)] :\n    IsIso (colimit.Î¹ F (âŠ¥_ J)) :=\n  isIso_Î¹_of_isInitial initialIsInitial F\n\n"}
