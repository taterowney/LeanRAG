{"name":"Finset.mem_powerset","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\ns t : Finset α\n⊢ Iff (Membership.mem t.powerset s) (HasSubset.Subset s t)","decl":"@[simp]\ntheorem mem_powerset {s t : Finset α} : s ∈ powerset t ↔ s ⊆ t := by\n  cases s\n  simp [powerset, mem_mk, mem_pmap, mk.injEq, mem_powerset, exists_prop, exists_eq_right,\n    ← val_le_iff]\n\n"}
{"name":"Finset.coe_powerset","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq (↑s.powerset) (Set.preimage Finset.toSet (↑s).powerset)","decl":"@[simp, norm_cast]\ntheorem coe_powerset (s : Finset α) :\n    (s.powerset : Set (Finset α)) = ((↑) : Finset α → Set α) ⁻¹' (s : Set α).powerset := by\n  ext\n  simp\n\n"}
{"name":"Finset.empty_mem_powerset","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Membership.mem s.powerset EmptyCollection.emptyCollection","decl":"theorem empty_mem_powerset (s : Finset α) : ∅ ∈ powerset s := by simp\n\n"}
{"name":"Finset.mem_powerset_self","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Membership.mem s.powerset s","decl":"theorem mem_powerset_self (s : Finset α) : s ∈ powerset s := by simp\n\n"}
{"name":"Finset.powerset_nonempty","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\ns : Finset α\n⊢ s.powerset.Nonempty","decl":"@[aesop safe apply (rule_sets := [finsetNonempty])]\ntheorem powerset_nonempty (s : Finset α) : s.powerset.Nonempty :=\n  ⟨∅, empty_mem_powerset _⟩\n\n"}
{"name":"Finset.powerset_mono","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\ns t : Finset α\n⊢ Iff (HasSubset.Subset s.powerset t.powerset) (HasSubset.Subset s t)","decl":"@[simp]\ntheorem powerset_mono {s t : Finset α} : powerset s ⊆ powerset t ↔ s ⊆ t :=\n  ⟨fun h => mem_powerset.1 <| h <| mem_powerset_self _, fun st _u h =>\n    mem_powerset.2 <| Subset.trans (mem_powerset.1 h) st⟩\n\n"}
{"name":"Finset.powerset_injective","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\n⊢ Function.Injective Finset.powerset","decl":"theorem powerset_injective : Injective (powerset : Finset α → Finset (Finset α)) :=\n  (injective_of_le_imp_le _) powerset_mono.1\n\n"}
{"name":"Finset.powerset_inj","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\ns t : Finset α\n⊢ Iff (Eq s.powerset t.powerset) (Eq s t)","decl":"@[simp]\ntheorem powerset_inj : powerset s = powerset t ↔ s = t :=\n  powerset_injective.eq_iff\n\n"}
{"name":"Finset.powerset_empty","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\n⊢ Eq EmptyCollection.emptyCollection.powerset (Singleton.singleton EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem powerset_empty : (∅ : Finset α).powerset = {∅} :=\n  rfl\n\n"}
{"name":"Finset.powerset_eq_singleton_empty","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (Eq s.powerset (Singleton.singleton EmptyCollection.emptyCollection)) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem powerset_eq_singleton_empty : s.powerset = {∅} ↔ s = ∅ := by\n  rw [← powerset_empty, powerset_inj]\n\n"}
{"name":"Finset.card_powerset","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq s.powerset.card (HPow.hPow 2 s.card)","decl":"/-- **Number of Subsets of a Set** -/\n@[simp]\ntheorem card_powerset (s : Finset α) : card (powerset s) = 2 ^ card s :=\n  (card_pmap _ _ _).trans (Multiset.card_powerset s.1)\n\n"}
{"name":"Finset.not_mem_of_mem_powerset_of_not_mem","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\ns t : Finset α\na : α\nht : Membership.mem s.powerset t\nh : Not (Membership.mem s a)\n⊢ Not (Membership.mem t a)","decl":"theorem not_mem_of_mem_powerset_of_not_mem {s t : Finset α} {a : α} (ht : t ∈ s.powerset)\n    (h : a ∉ s) : a ∉ t := by\n  apply mt _ h\n  apply mem_powerset.1 ht\n\n"}
{"name":"Finset.powerset_insert","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\n⊢ Eq (Insert.insert a s).powerset (Union.union s.powerset (Finset.image (Insert.insert a) s.powerset))","decl":"theorem powerset_insert [DecidableEq α] (s : Finset α) (a : α) :\n    powerset (insert a s) = s.powerset ∪ s.powerset.image (insert a) := by\n  ext t\n  simp only [exists_prop, mem_powerset, mem_image, mem_union, subset_insert_iff]\n  by_cases h : a ∈ t\n  · constructor\n    · exact fun H => Or.inr ⟨_, H, insert_erase h⟩\n    · intro H\n      cases' H with H H\n      · exact Subset.trans (erase_subset a t) H\n      · rcases H with ⟨u, hu⟩\n        rw [← hu.2]\n        exact Subset.trans (erase_insert_subset a u) hu.1\n  · have : ¬∃ u : Finset α, u ⊆ s ∧ insert a u = t := by simp [Ne.symm (ne_insert_of_not_mem _ _ h)]\n    simp [Finset.erase_eq_of_not_mem h, this]\n\n"}
{"name":"Finset.pairwiseDisjoint_pair_insert","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\ns : Finset α\ninst✝ : DecidableEq α\na : α\nha : Not (Membership.mem s a)\n⊢ (↑s.powerset).PairwiseDisjoint fun t => Insert.insert t (Singleton.singleton (Insert.insert a t))","decl":"lemma pairwiseDisjoint_pair_insert [DecidableEq α] {a : α} (ha : a ∉ s) :\n    (s.powerset : Set (Finset α)).PairwiseDisjoint fun t ↦ ({t, insert a t} : Set (Finset α)) := by\n  simp_rw [Set.pairwiseDisjoint_iff, mem_coe, mem_powerset]\n  rintro i hi j hj\n  simp only [Set.Nonempty, Set.mem_inter_iff, Set.mem_insert_iff, Set.mem_singleton_iff,\n    exists_eq_or_imp, exists_eq_left, or_imp, imp_self, true_and]\n  refine ⟨?_, ?_, insert_erase_invOn.2.injOn (not_mem_mono hi ha) (not_mem_mono hj ha)⟩ <;>\n    rintro rfl <;>\n    cases Finset.not_mem_mono ‹_› ha (Finset.mem_insert_self _ _)\n\n"}
{"name":"Finset.mem_ssubsets","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Iff (Membership.mem s.ssubsets t) (HasSSubset.SSubset t s)","decl":"@[simp]\ntheorem mem_ssubsets {s t : Finset α} : t ∈ s.ssubsets ↔ t ⊂ s := by\n  rw [ssubsets, mem_erase, mem_powerset, ssubset_iff_subset_ne, and_comm]\n\n"}
{"name":"Finset.empty_mem_ssubsets","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nh : s.Nonempty\n⊢ Membership.mem s.ssubsets EmptyCollection.emptyCollection","decl":"theorem empty_mem_ssubsets {s : Finset α} (h : s.Nonempty) : ∅ ∈ s.ssubsets := by\n  rw [mem_ssubsets, ssubset_iff_subset_ne]\n  exact ⟨empty_subset s, h.ne_empty.symm⟩\n\n"}
{"name":"Finset.mem_powersetCard","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\nn : Nat\ns t : Finset α\n⊢ Iff (Membership.mem (Finset.powersetCard n t) s) (And (HasSubset.Subset s t) (Eq s.card n))","decl":"@[simp] lemma mem_powersetCard : s ∈ powersetCard n t ↔ s ⊆ t ∧ card s = n := by\n  cases s; simp [powersetCard, val_le_iff.symm]\n\n"}
{"name":"Finset.powersetCard_mono","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\nn : Nat\ns t : Finset α\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset (Finset.powersetCard n s) (Finset.powersetCard n t)","decl":"@[simp]\ntheorem powersetCard_mono {n} {s t : Finset α} (h : s ⊆ t) : powersetCard n s ⊆ powersetCard n t :=\n  fun _u h' => mem_powersetCard.2 <|\n    And.imp (fun h₂ => Subset.trans h₂ h) id (mem_powersetCard.1 h')\n\n"}
{"name":"Finset.card_powersetCard","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\nn : Nat\ns : Finset α\n⊢ Eq (Finset.powersetCard n s).card (s.card.choose n)","decl":"/-- **Formula for the Number of Combinations** -/\n@[simp]\ntheorem card_powersetCard (n : ℕ) (s : Finset α) :\n    card (powersetCard n s) = Nat.choose (card s) n :=\n  (card_pmap _ _ _).trans (Multiset.card_powersetCard n s.1)\n\n"}
{"name":"Finset.powersetCard_zero","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq (Finset.powersetCard 0 s) (Singleton.singleton EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem powersetCard_zero (s : Finset α) : s.powersetCard 0 = {∅} := by\n  ext; rw [mem_powersetCard, mem_singleton, card_eq_zero]\n  refine\n    ⟨fun h => h.2, fun h => by\n      rw [h]\n      exact ⟨empty_subset s, rfl⟩⟩\n\n"}
{"name":"Finset.powersetCard_empty_subsingleton","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\nn : Nat\n⊢ (↑(Finset.powersetCard n EmptyCollection.emptyCollection)).Subsingleton","decl":"lemma powersetCard_empty_subsingleton (n : ℕ) :\n    (powersetCard n (∅ : Finset α) : Set <| Finset α).Subsingleton := by\n  simp [Set.Subsingleton, subset_empty]\n\n"}
{"name":"Finset.map_val_val_powersetCard","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\ns : Finset α\ni : Nat\n⊢ Eq (Multiset.map Finset.val (Finset.powersetCard i s).val) (Multiset.powersetCard i s.val)","decl":"@[simp]\ntheorem map_val_val_powersetCard (s : Finset α) (i : ℕ) :\n    (s.powersetCard i).val.map Finset.val = s.1.powersetCard i := by\n  simp [Finset.powersetCard, map_pmap, pmap_eq_map, map_id']\n\n"}
{"name":"Finset.powersetCard_one","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq (Finset.powersetCard 1 s) (Finset.map { toFun := Singleton.singleton, inj' := ⋯ } s)","decl":"theorem powersetCard_one (s : Finset α) :\n    s.powersetCard 1 = s.map ⟨_, Finset.singleton_injective⟩ :=\n  eq_of_veq <| Multiset.map_injective val_injective <| by simp [Multiset.powersetCard_one]\n\n"}
{"name":"Finset.powersetCard_eq_empty","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\nn : Nat\ns : Finset α\n⊢ Iff (Eq (Finset.powersetCard n s) EmptyCollection.emptyCollection) (LT.lt s.card n)","decl":"@[simp]\nlemma powersetCard_eq_empty : powersetCard n s = ∅ ↔ s.card < n := by\n  refine ⟨?_, fun h ↦ card_eq_zero.1 <| by rw [card_powersetCard, Nat.choose_eq_zero_of_lt h]⟩\n  contrapose!\n  exact fun h ↦ nonempty_iff_ne_empty.1 <| (exists_subset_card_eq h).imp <| by simp\n\n"}
{"name":"Finset.powersetCard_card_add","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\nn : Nat\ns : Finset α\nhn : LT.lt 0 n\n⊢ Eq (Finset.powersetCard (HAdd.hAdd s.card n) s) EmptyCollection.emptyCollection","decl":"@[simp] lemma powersetCard_card_add (s : Finset α) (hn : 0 < n) :\n    s.powersetCard (s.card + n) = ∅ := by simpa\n\n"}
{"name":"Finset.powersetCard_eq_filter","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\nn : Nat\ns : Finset α\n⊢ Eq (Finset.powersetCard n s) (Finset.filter (fun x => Eq x.card n) s.powerset)","decl":"theorem powersetCard_eq_filter {n} {s : Finset α} :\n    powersetCard n s = (powerset s).filter fun x => x.card = n := by\n  ext\n  simp [mem_powersetCard]\n\n"}
{"name":"Finset.powersetCard_succ_insert","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx : α\ns : Finset α\nh : Not (Membership.mem s x)\nn : Nat\n⊢ Eq (Finset.powersetCard n.succ (Insert.insert x s)) (Union.union (Finset.powersetCard n.succ s) (Finset.image (Insert.insert x) (Finset.powersetCard n s)))","decl":"theorem powersetCard_succ_insert [DecidableEq α] {x : α} {s : Finset α} (h : x ∉ s) (n : ℕ) :\n    powersetCard n.succ (insert x s) =\n    powersetCard n.succ s ∪ (powersetCard n s).image (insert x) := by\n  rw [powersetCard_eq_filter, powerset_insert, filter_union, ← powersetCard_eq_filter]\n  congr\n  rw [powersetCard_eq_filter, filter_image]\n  congr 1\n  ext t\n  simp only [mem_powerset, mem_filter, Function.comp_apply, and_congr_right_iff]\n  intro ht\n  have : x ∉ t := fun H => h (ht H)\n  simp [card_insert_of_not_mem this, Nat.succ_inj']\n\n"}
{"name":"Finset.powersetCard_nonempty","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\nn : Nat\ns : Finset α\n⊢ Iff (Finset.powersetCard n s).Nonempty (LE.le n s.card)","decl":"@[simp]\nlemma powersetCard_nonempty : (powersetCard n s).Nonempty ↔ n ≤ s.card := by\n  aesop (add simp [Finset.Nonempty, exists_subset_card_eq, card_le_card])\n\n"}
{"name":"Finset.powersetCard_nonempty_of_le","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\nn : Nat\ns : Finset α\na✝ : LE.le n s.card\n⊢ (Finset.powersetCard n s).Nonempty","decl":"@[aesop safe apply (rule_sets := [finsetNonempty])]\nalias ⟨_, powersetCard_nonempty_of_le⟩ := powersetCard_nonempty\n\n"}
{"name":"Finset.powersetCard_self","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq (Finset.powersetCard s.card s) (Singleton.singleton s)","decl":"@[simp]\ntheorem powersetCard_self (s : Finset α) : powersetCard s.card s = {s} := by\n  ext\n  rw [mem_powersetCard, mem_singleton]\n  constructor\n  · exact fun ⟨hs, hc⟩ => eq_of_subset_of_card_le hs hc.ge\n  · rintro rfl\n    simp\n\n"}
{"name":"Finset.pairwise_disjoint_powersetCard","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Pairwise fun i j => Disjoint (Finset.powersetCard i s) (Finset.powersetCard j s)","decl":"theorem pairwise_disjoint_powersetCard (s : Finset α) :\n    Pairwise fun i j => Disjoint (s.powersetCard i) (s.powersetCard j) := fun _i _j hij =>\n  Finset.disjoint_left.mpr fun _x hi hj =>\n    hij <| (mem_powersetCard.mp hi).2.symm.trans (mem_powersetCard.mp hj).2\n\n"}
{"name":"Finset.powerset_card_disjiUnion","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq s.powerset ((Finset.range (HAdd.hAdd s.card 1)).disjiUnion (fun i => Finset.powersetCard i s) ⋯)","decl":"theorem powerset_card_disjiUnion (s : Finset α) :\n    Finset.powerset s =\n      (range (s.card + 1)).disjiUnion (fun i => powersetCard i s)\n        (s.pairwise_disjoint_powersetCard.set_pairwise _) := by\n  refine ext fun a => ⟨fun ha => ?_, fun ha => ?_⟩\n  · rw [mem_disjiUnion]\n    exact\n      ⟨a.card, mem_range.mpr (Nat.lt_succ_of_le (card_le_card (mem_powerset.mp ha))),\n        mem_powersetCard.mpr ⟨mem_powerset.mp ha, rfl⟩⟩\n  · rcases mem_disjiUnion.mp ha with ⟨i, _hi, ha⟩\n    exact mem_powerset.mpr (mem_powersetCard.mp ha).1\n\n"}
{"name":"Finset.powerset_card_biUnion","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq (Finset α)\ns : Finset α\n⊢ Eq s.powerset ((Finset.range (HAdd.hAdd s.card 1)).biUnion fun i => Finset.powersetCard i s)","decl":"theorem powerset_card_biUnion [DecidableEq (Finset α)] (s : Finset α) :\n    Finset.powerset s = (range (s.card + 1)).biUnion fun i => powersetCard i s := by\n  simpa only [disjiUnion_eq_biUnion] using powerset_card_disjiUnion s\n\n"}
{"name":"Finset.powersetCard_sup","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nu : Finset α\nn : Nat\nhn : LT.lt n u.card\n⊢ Eq ((Finset.powersetCard n.succ u).sup id) u","decl":"theorem powersetCard_sup [DecidableEq α] (u : Finset α) (n : ℕ) (hn : n < u.card) :\n    (powersetCard n.succ u).sup id = u := by\n  apply le_antisymm\n  · simp_rw [Finset.sup_le_iff, mem_powersetCard]\n    rintro x ⟨h, -⟩\n    exact h\n  · rw [sup_eq_biUnion, le_iff_subset, subset_iff]\n    intro x hx\n    simp only [mem_biUnion, exists_prop, id]\n    obtain ⟨t, ht⟩ : ∃ t, t ∈ powersetCard n (u.erase x) := powersetCard_nonempty.2\n      (le_trans (Nat.le_sub_one_of_lt hn) pred_card_le_card_erase)\n    refine ⟨insert x t, ?_, mem_insert_self _ _⟩\n    rw [← insert_erase hx, powersetCard_succ_insert (not_mem_erase _ _)]\n    exact mem_union_right _ (mem_image_of_mem _ ht)\n\n"}
{"name":"Finset.powersetCard_map","module":"Mathlib.Data.Finset.Powerset","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\nn : Nat\ns : Finset α\n⊢ Eq (Finset.powersetCard n (Finset.map f s)) (Finset.map (Finset.mapEmbedding f).toEmbedding (Finset.powersetCard n s))","decl":"theorem powersetCard_map {β : Type*} (f : α ↪ β) (n : ℕ) (s : Finset α) :\n    powersetCard n (s.map f) = (powersetCard n s).map (mapEmbedding f).toEmbedding :=\n  ext fun t => by\n    simp only [card_map, mem_powersetCard, le_eq_subset, gt_iff_lt, mem_map, mapEmbedding_apply]\n    constructor\n    · classical\n      intro h\n      have : map f (filter (fun x => (f x ∈ t)) s) = t := by\n        ext x\n        simp only [mem_map, mem_filter, decide_eq_true_eq]\n        exact ⟨fun ⟨_y, ⟨_hy₁, hy₂⟩, hy₃⟩ => hy₃ ▸ hy₂,\n          fun hx => let ⟨y, hy⟩ := mem_map.1 (h.1 hx); ⟨y, ⟨hy.1, hy.2 ▸ hx⟩, hy.2⟩⟩\n      refine ⟨_, ?_, this⟩\n      rw [← card_map f, this, h.2]; simp\n    · rintro ⟨a, ⟨has, rfl⟩, rfl⟩\n      dsimp [RelEmbedding.coe_toEmbedding]\n      -- Porting note: Why is `rw` required here and not `simp`?\n      rw [mapEmbedding_apply]\n      simp [has]\n\n"}
