{"name":"Finsupp.toDFinsupp_coe","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝ : Zero M\nf : Finsupp ι M\n⊢ Eq ⇑f.toDFinsupp ⇑f","decl":"@[simp]\ntheorem Finsupp.toDFinsupp_coe [Zero M] (f : ι →₀ M) : ⇑f.toDFinsupp = f :=\n  rfl\n\n"}
{"name":"Finsupp.toDFinsupp_single","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝¹ : DecidableEq ι\ninst✝ : Zero M\ni : ι\nm : M\n⊢ Eq (Finsupp.single i m).toDFinsupp (DFinsupp.single i m)","decl":"@[simp]\ntheorem Finsupp.toDFinsupp_single (i : ι) (m : M) :\n    (Finsupp.single i m).toDFinsupp = DFinsupp.single i m := by\n  ext\n  simp [Finsupp.single_apply, DFinsupp.single_apply]\n\n"}
{"name":"toDFinsupp_support","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : DecidableEq ι\ninst✝¹ : Zero M\ninst✝ : (m : M) → Decidable (Ne m 0)\nf : Finsupp ι M\n⊢ Eq f.toDFinsupp.support f.support","decl":"@[simp]\ntheorem toDFinsupp_support (f : ι →₀ M) : f.toDFinsupp.support = f.support := by\n  ext\n  simp\n\n"}
{"name":"DFinsupp.toFinsupp_coe","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : DecidableEq ι\ninst✝¹ : Zero M\ninst✝ : (m : M) → Decidable (Ne m 0)\nf : DFinsupp fun x => M\n⊢ Eq ⇑f.toFinsupp ⇑f","decl":"@[simp]\ntheorem DFinsupp.toFinsupp_coe (f : Π₀ _ : ι, M) : ⇑f.toFinsupp = f :=\n  rfl\n\n"}
{"name":"DFinsupp.toFinsupp_support","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : DecidableEq ι\ninst✝¹ : Zero M\ninst✝ : (m : M) → Decidable (Ne m 0)\nf : DFinsupp fun x => M\n⊢ Eq f.toFinsupp.support f.support","decl":"@[simp]\ntheorem DFinsupp.toFinsupp_support (f : Π₀ _ : ι, M) : f.toFinsupp.support = f.support := by\n  ext\n  simp\n\n"}
{"name":"DFinsupp.toFinsupp_single","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : DecidableEq ι\ninst✝¹ : Zero M\ninst✝ : (m : M) → Decidable (Ne m 0)\ni : ι\nm : M\n⊢ Eq (DFinsupp.single i m).toFinsupp (Finsupp.single i m)","decl":"@[simp]\ntheorem DFinsupp.toFinsupp_single (i : ι) (m : M) :\n    (DFinsupp.single i m : Π₀ _ : ι, M).toFinsupp = Finsupp.single i m := by\n  ext\n  simp [Finsupp.single_apply, DFinsupp.single_apply]\n\n"}
{"name":"Finsupp.toDFinsupp_toFinsupp","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : DecidableEq ι\ninst✝¹ : Zero M\ninst✝ : (m : M) → Decidable (Ne m 0)\nf : Finsupp ι M\n⊢ Eq f.toDFinsupp.toFinsupp f","decl":"@[simp]\ntheorem Finsupp.toDFinsupp_toFinsupp (f : ι →₀ M) : f.toDFinsupp.toFinsupp = f :=\n  DFunLike.coe_injective rfl\n\n"}
{"name":"DFinsupp.toFinsupp_toDFinsupp","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : DecidableEq ι\ninst✝¹ : Zero M\ninst✝ : (m : M) → Decidable (Ne m 0)\nf : DFinsupp fun x => M\n⊢ Eq f.toFinsupp.toDFinsupp f","decl":"@[simp]\ntheorem DFinsupp.toFinsupp_toDFinsupp (f : Π₀ _ : ι, M) : f.toFinsupp.toDFinsupp = f :=\n  DFunLike.coe_injective rfl\n\n"}
{"name":"Finsupp.toDFinsupp_zero","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝ : Zero M\n⊢ Eq (Finsupp.toDFinsupp 0) 0","decl":"@[simp]\ntheorem toDFinsupp_zero [Zero M] : (0 : ι →₀ M).toDFinsupp = 0 :=\n  DFunLike.coe_injective rfl\n\n"}
{"name":"Finsupp.toDFinsupp_add","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝ : AddZeroClass M\nf g : Finsupp ι M\n⊢ Eq (HAdd.hAdd f g).toDFinsupp (HAdd.hAdd f.toDFinsupp g.toDFinsupp)","decl":"@[simp]\ntheorem toDFinsupp_add [AddZeroClass M] (f g : ι →₀ M) :\n    (f + g).toDFinsupp = f.toDFinsupp + g.toDFinsupp :=\n  DFunLike.coe_injective rfl\n\n"}
{"name":"Finsupp.toDFinsupp_neg","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝ : AddGroup M\nf : Finsupp ι M\n⊢ Eq (Neg.neg f).toDFinsupp (Neg.neg f.toDFinsupp)","decl":"@[simp]\ntheorem toDFinsupp_neg [AddGroup M] (f : ι →₀ M) : (-f).toDFinsupp = -f.toDFinsupp :=\n  DFunLike.coe_injective rfl\n\n"}
{"name":"Finsupp.toDFinsupp_sub","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝ : AddGroup M\nf g : Finsupp ι M\n⊢ Eq (HSub.hSub f g).toDFinsupp (HSub.hSub f.toDFinsupp g.toDFinsupp)","decl":"@[simp]\ntheorem toDFinsupp_sub [AddGroup M] (f g : ι →₀ M) :\n    (f - g).toDFinsupp = f.toDFinsupp - g.toDFinsupp :=\n  DFunLike.coe_injective rfl\n\n"}
{"name":"Finsupp.toDFinsupp_smul","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝² : Monoid R\ninst✝¹ : AddMonoid M\ninst✝ : DistribMulAction R M\nr : R\nf : Finsupp ι M\n⊢ Eq (HSMul.hSMul r f).toDFinsupp (HSMul.hSMul r f.toDFinsupp)","decl":"@[simp]\ntheorem toDFinsupp_smul [Monoid R] [AddMonoid M] [DistribMulAction R M] (r : R) (f : ι →₀ M) :\n    (r • f).toDFinsupp = r • f.toDFinsupp :=\n  DFunLike.coe_injective rfl\n\n"}
{"name":"DFinsupp.toFinsupp_zero","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : DecidableEq ι\ninst✝¹ : Zero M\ninst✝ : (m : M) → Decidable (Ne m 0)\n⊢ Eq (DFinsupp.toFinsupp 0) 0","decl":"@[simp]\ntheorem toFinsupp_zero [Zero M] [∀ m : M, Decidable (m ≠ 0)] : toFinsupp 0 = (0 : ι →₀ M) :=\n  DFunLike.coe_injective rfl\n\n"}
{"name":"DFinsupp.toFinsupp_add","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : DecidableEq ι\ninst✝¹ : AddZeroClass M\ninst✝ : (m : M) → Decidable (Ne m 0)\nf g : DFinsupp fun x => M\n⊢ Eq (HAdd.hAdd f g).toFinsupp (HAdd.hAdd f.toFinsupp g.toFinsupp)","decl":"@[simp]\ntheorem toFinsupp_add [AddZeroClass M] [∀ m : M, Decidable (m ≠ 0)] (f g : Π₀ _ : ι, M) :\n    (toFinsupp (f + g) : ι →₀ M) = toFinsupp f + toFinsupp g :=\n  DFunLike.coe_injective <| DFinsupp.coe_add _ _\n\n"}
{"name":"DFinsupp.toFinsupp_neg","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : DecidableEq ι\ninst✝¹ : AddGroup M\ninst✝ : (m : M) → Decidable (Ne m 0)\nf : DFinsupp fun x => M\n⊢ Eq (Neg.neg f).toFinsupp (Neg.neg f.toFinsupp)","decl":"@[simp]\ntheorem toFinsupp_neg [AddGroup M] [∀ m : M, Decidable (m ≠ 0)] (f : Π₀ _ : ι, M) :\n    (toFinsupp (-f) : ι →₀ M) = -toFinsupp f :=\n  DFunLike.coe_injective <| DFinsupp.coe_neg _\n\n"}
{"name":"DFinsupp.toFinsupp_sub","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : DecidableEq ι\ninst✝¹ : AddGroup M\ninst✝ : (m : M) → Decidable (Ne m 0)\nf g : DFinsupp fun x => M\n⊢ Eq (HSub.hSub f g).toFinsupp (HSub.hSub f.toFinsupp g.toFinsupp)","decl":"@[simp]\ntheorem toFinsupp_sub [AddGroup M] [∀ m : M, Decidable (m ≠ 0)] (f g : Π₀ _ : ι, M) :\n    (toFinsupp (f - g) : ι →₀ M) = toFinsupp f - toFinsupp g :=\n  DFunLike.coe_injective <| DFinsupp.coe_sub _ _\n\n"}
{"name":"DFinsupp.toFinsupp_smul","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁴ : DecidableEq ι\ninst✝³ : Monoid R\ninst✝² : AddMonoid M\ninst✝¹ : DistribMulAction R M\ninst✝ : (m : M) → Decidable (Ne m 0)\nr : R\nf : DFinsupp fun x => M\n⊢ Eq (HSMul.hSMul r f).toFinsupp (HSMul.hSMul r f.toFinsupp)","decl":"@[simp]\ntheorem toFinsupp_smul [Monoid R] [AddMonoid M] [DistribMulAction R M] [∀ m : M, Decidable (m ≠ 0)]\n    (r : R) (f : Π₀ _ : ι, M) : (toFinsupp (r • f) : ι →₀ M) = r • toFinsupp f :=\n  DFunLike.coe_injective <| DFinsupp.coe_smul _ _\n\n"}
{"name":"finsuppEquivDFinsupp_symm_apply","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : DecidableEq ι\ninst✝¹ : Zero M\ninst✝ : (m : M) → Decidable (Ne m 0)\n⊢ Eq (⇑finsuppEquivDFinsupp.symm) DFinsupp.toFinsupp","decl":"/-- `Finsupp.toDFinsupp` and `DFinsupp.toFinsupp` together form an equiv. -/\n@[simps (config := .asFn)]\ndef finsuppEquivDFinsupp [DecidableEq ι] [Zero M] [∀ m : M, Decidable (m ≠ 0)] :\n    (ι →₀ M) ≃ Π₀ _ : ι, M where\n  toFun := Finsupp.toDFinsupp\n  invFun := DFinsupp.toFinsupp\n  left_inv := Finsupp.toDFinsupp_toFinsupp\n  right_inv := DFinsupp.toFinsupp_toDFinsupp\n\n"}
{"name":"finsuppEquivDFinsupp_apply","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : DecidableEq ι\ninst✝¹ : Zero M\ninst✝ : (m : M) → Decidable (Ne m 0)\n⊢ Eq (⇑finsuppEquivDFinsupp) Finsupp.toDFinsupp","decl":"/-- `Finsupp.toDFinsupp` and `DFinsupp.toFinsupp` together form an equiv. -/\n@[simps (config := .asFn)]\ndef finsuppEquivDFinsupp [DecidableEq ι] [Zero M] [∀ m : M, Decidable (m ≠ 0)] :\n    (ι →₀ M) ≃ Π₀ _ : ι, M where\n  toFun := Finsupp.toDFinsupp\n  invFun := DFinsupp.toFinsupp\n  left_inv := Finsupp.toDFinsupp_toFinsupp\n  right_inv := DFinsupp.toFinsupp_toDFinsupp\n\n"}
{"name":"finsuppAddEquivDFinsupp_apply","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : DecidableEq ι\ninst✝¹ : AddZeroClass M\ninst✝ : (m : M) → Decidable (Ne m 0)\n⊢ Eq (⇑finsuppAddEquivDFinsupp) Finsupp.toDFinsupp","decl":"/-- The additive version of `finsupp.toFinsupp`. Note that this is `noncomputable` because\n`Finsupp.add` is noncomputable. -/\n@[simps (config := .asFn)]\ndef finsuppAddEquivDFinsupp [DecidableEq ι] [AddZeroClass M] [∀ m : M, Decidable (m ≠ 0)] :\n    (ι →₀ M) ≃+ Π₀ _ : ι, M :=\n  { finsuppEquivDFinsupp with\n    toFun := Finsupp.toDFinsupp\n    invFun := DFinsupp.toFinsupp\n    map_add' := Finsupp.toDFinsupp_add }\n\n"}
{"name":"finsuppAddEquivDFinsupp_symm_apply","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : DecidableEq ι\ninst✝¹ : AddZeroClass M\ninst✝ : (m : M) → Decidable (Ne m 0)\n⊢ Eq (⇑finsuppAddEquivDFinsupp.symm) DFinsupp.toFinsupp","decl":"/-- The additive version of `finsupp.toFinsupp`. Note that this is `noncomputable` because\n`Finsupp.add` is noncomputable. -/\n@[simps (config := .asFn)]\ndef finsuppAddEquivDFinsupp [DecidableEq ι] [AddZeroClass M] [∀ m : M, Decidable (m ≠ 0)] :\n    (ι →₀ M) ≃+ Π₀ _ : ι, M :=\n  { finsuppEquivDFinsupp with\n    toFun := Finsupp.toDFinsupp\n    invFun := DFinsupp.toFinsupp\n    map_add' := Finsupp.toDFinsupp_add }\n\n"}
{"name":"finsuppLequivDFinsupp_apply_apply","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁴ : DecidableEq ι\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : (m : M) → Decidable (Ne m 0)\ninst✝ : Module R M\n⊢ Eq (⇑(finsuppLequivDFinsupp R)) Finsupp.toDFinsupp","decl":"@[simp]\ntheorem finsuppLequivDFinsupp_apply_apply [DecidableEq ι] [Semiring R] [AddCommMonoid M]\n    [∀ m : M, Decidable (m ≠ 0)] [Module R M] :\n    (↑(finsuppLequivDFinsupp (M := M) R) : (ι →₀ M) → _) = Finsupp.toDFinsupp := rfl\n\n"}
{"name":"finsuppLequivDFinsupp_symm_apply","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁴ : DecidableEq ι\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : (m : M) → Decidable (Ne m 0)\ninst✝ : Module R M\n⊢ Eq (⇑(finsuppLequivDFinsupp R).symm) DFinsupp.toFinsupp","decl":"@[simp]\ntheorem finsuppLequivDFinsupp_symm_apply [DecidableEq ι] [Semiring R] [AddCommMonoid M]\n    [∀ m : M, Decidable (m ≠ 0)] [Module R M] :\n    ↑(LinearEquiv.symm (finsuppLequivDFinsupp (ι := ι) (M := M) R)) = DFinsupp.toFinsupp :=\n  rfl\n\n-- Porting note: moved noncomputable declaration into section begin\n"}
{"name":"sigmaFinsuppEquivDFinsupp_apply","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nη : ι → Type u_4\nN : Type u_5\ninst✝ : Zero N\nf : Finsupp (Sigma fun i => η i) N\n⊢ Eq (⇑(sigmaFinsuppEquivDFinsupp f)) f.split","decl":"@[simp]\ntheorem sigmaFinsuppEquivDFinsupp_apply [Zero N] (f : (Σi, η i) →₀ N) :\n    (sigmaFinsuppEquivDFinsupp f : ∀ i, η i →₀ N) = Finsupp.split f :=\n  rfl\n\n"}
{"name":"sigmaFinsuppEquivDFinsupp_symm_apply","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nη : ι → Type u_4\nN : Type u_5\ninst✝ : Zero N\nf : DFinsupp fun i => Finsupp (η i) N\ns : Sigma fun i => η i\n⊢ Eq ((sigmaFinsuppEquivDFinsupp.symm f) s) ((f s.fst) s.snd)","decl":"@[simp]\ntheorem sigmaFinsuppEquivDFinsupp_symm_apply [Zero N] (f : Π₀ i, η i →₀ N) (s : Σi, η i) :\n    (sigmaFinsuppEquivDFinsupp.symm f : (Σi, η i) →₀ N) s = f s.1 s.2 :=\n  rfl\n\n"}
{"name":"sigmaFinsuppEquivDFinsupp_support","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nη : ι → Type u_4\nN : Type u_5\ninst✝² : DecidableEq ι\ninst✝¹ : Zero N\ninst✝ : (i : ι) → (x : Finsupp (η i) N) → Decidable (Ne x 0)\nf : Finsupp (Sigma fun i => η i) N\n⊢ Eq (sigmaFinsuppEquivDFinsupp f).support f.splitSupport","decl":"@[simp]\ntheorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]\n    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :\n    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by\n  ext\n  rw [DFinsupp.mem_support_toFun]\n  exact (Finsupp.mem_splitSupport_iff_nonzero _ _).symm\n\n"}
{"name":"sigmaFinsuppEquivDFinsupp_single","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nη : ι → Type u_4\nN : Type u_5\ninst✝¹ : DecidableEq ι\ninst✝ : Zero N\na : Sigma fun i => η i\nn : N\n⊢ Eq (sigmaFinsuppEquivDFinsupp (Finsupp.single a n)) (DFinsupp.single a.fst (Finsupp.single a.snd n))","decl":"@[simp]\ntheorem sigmaFinsuppEquivDFinsupp_single [DecidableEq ι] [Zero N] (a : Σi, η i) (n : N) :\n    sigmaFinsuppEquivDFinsupp (Finsupp.single a n) =\n      @DFinsupp.single _ (fun i => η i →₀ N) _ _ a.1 (Finsupp.single a.2 n) := by\n  obtain ⟨i, a⟩ := a\n  ext j b\n  by_cases h : i = j\n  · subst h\n    classical simp [split_apply, Finsupp.single_apply]\n  suffices Finsupp.single (⟨i, a⟩ : Σi, η i) n ⟨j, b⟩ = 0 by simp [split_apply, dif_neg h, this]\n  have H : (⟨i, a⟩ : Σi, η i) ≠ ⟨j, b⟩ := by simp [h]\n  classical rw [Finsupp.single_apply, if_neg H]\n\n-- Without this Lean fails to find the `AddZeroClass` instance on `Π₀ i, (η i →₀ N)`.\n"}
{"name":"sigmaFinsuppEquivDFinsupp_add","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nη : ι → Type u_4\nN : Type u_5\ninst✝ : AddZeroClass N\nf g : Finsupp (Sigma fun i => η i) N\n⊢ Eq (sigmaFinsuppEquivDFinsupp (HAdd.hAdd f g)) (HAdd.hAdd (sigmaFinsuppEquivDFinsupp f) (sigmaFinsuppEquivDFinsupp g))","decl":"@[simp]\ntheorem sigmaFinsuppEquivDFinsupp_add [AddZeroClass N] (f g : (Σi, η i) →₀ N) :\n    sigmaFinsuppEquivDFinsupp (f + g) =\n      (sigmaFinsuppEquivDFinsupp f + sigmaFinsuppEquivDFinsupp g : Π₀ i : ι, η i →₀ N) := by\n  ext\n  rfl\n\n"}
{"name":"sigmaFinsuppAddEquivDFinsupp_apply","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nη : ι → Type u_4\nN : Type u_5\ninst✝ : AddZeroClass N\na : Finsupp (Sigma fun i => η i) N\n⊢ Eq (sigmaFinsuppAddEquivDFinsupp a) (sigmaFinsuppEquivDFinsupp a)","decl":"/-- `Finsupp.split` is an additive equivalence between `(Σ i, η i) →₀ N` and `Π₀ i, (η i →₀ N)`. -/\n@[simps]\ndef sigmaFinsuppAddEquivDFinsupp [AddZeroClass N] : ((Σi, η i) →₀ N) ≃+ Π₀ i, η i →₀ N :=\n  { sigmaFinsuppEquivDFinsupp with\n    toFun := sigmaFinsuppEquivDFinsupp\n    invFun := sigmaFinsuppEquivDFinsupp.symm\n    map_add' := sigmaFinsuppEquivDFinsupp_add }\n\n"}
{"name":"sigmaFinsuppAddEquivDFinsupp_symm_apply","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nη : ι → Type u_4\nN : Type u_5\ninst✝ : AddZeroClass N\na : DFinsupp fun i => Finsupp (η i) N\n⊢ Eq (sigmaFinsuppAddEquivDFinsupp.symm a) (sigmaFinsuppEquivDFinsupp.symm a)","decl":"/-- `Finsupp.split` is an additive equivalence between `(Σ i, η i) →₀ N` and `Π₀ i, (η i →₀ N)`. -/\n@[simps]\ndef sigmaFinsuppAddEquivDFinsupp [AddZeroClass N] : ((Σi, η i) →₀ N) ≃+ Π₀ i, η i →₀ N :=\n  { sigmaFinsuppEquivDFinsupp with\n    toFun := sigmaFinsuppEquivDFinsupp\n    invFun := sigmaFinsuppEquivDFinsupp.symm\n    map_add' := sigmaFinsuppEquivDFinsupp_add }\n\n"}
{"name":"sigmaFinsuppEquivDFinsupp_smul","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nη : ι → Type u_4\nN : Type u_5\nR : Type u_6\ninst✝² : Monoid R\ninst✝¹ : AddMonoid N\ninst✝ : DistribMulAction R N\nr : R\nf : Finsupp (Sigma fun i => η i) N\n⊢ Eq (sigmaFinsuppEquivDFinsupp (HSMul.hSMul r f)) (HSMul.hSMul r (sigmaFinsuppEquivDFinsupp f))","decl":"@[simp]\ntheorem sigmaFinsuppEquivDFinsupp_smul {R} [Monoid R] [AddMonoid N] [DistribMulAction R N] (r : R)\n    (f : (Σ i, η i) →₀ N) :\n    sigmaFinsuppEquivDFinsupp (r • f) = r • sigmaFinsuppEquivDFinsupp f := by\n  ext\n  rfl\n\n"}
{"name":"sigmaFinsuppLequivDFinsupp_apply","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nη : ι → Type u_4\nN : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\na : Finsupp (Sigma fun i => η i) N\n⊢ Eq ((sigmaFinsuppLequivDFinsupp R) a) (sigmaFinsuppEquivDFinsupp a)","decl":"/-- `Finsupp.split` is a linear equivalence between `(Σ i, η i) →₀ N` and `Π₀ i, (η i →₀ N)`. -/\n@[simps]\ndef sigmaFinsuppLequivDFinsupp [AddCommMonoid N] [Module R N] :\n    ((Σi, η i) →₀ N) ≃ₗ[R] Π₀ i, η i →₀ N :=\n    -- Porting note: was\n    -- sigmaFinsuppAddEquivDFinsupp with map_smul' := sigmaFinsuppEquivDFinsupp_smul\n    -- but times out\n  { sigmaFinsuppEquivDFinsupp with\n    toFun := sigmaFinsuppEquivDFinsupp\n    invFun := sigmaFinsuppEquivDFinsupp.symm\n    map_add' := sigmaFinsuppEquivDFinsupp_add\n    map_smul' := sigmaFinsuppEquivDFinsupp_smul }\n\n"}
{"name":"sigmaFinsuppLequivDFinsupp_symm_apply","module":"Mathlib.Data.Finsupp.ToDFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nη : ι → Type u_4\nN : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\na : DFinsupp fun i => Finsupp (η i) N\n⊢ Eq ((sigmaFinsuppLequivDFinsupp R).symm a) (sigmaFinsuppEquivDFinsupp.symm a)","decl":"/-- `Finsupp.split` is a linear equivalence between `(Σ i, η i) →₀ N` and `Π₀ i, (η i →₀ N)`. -/\n@[simps]\ndef sigmaFinsuppLequivDFinsupp [AddCommMonoid N] [Module R N] :\n    ((Σi, η i) →₀ N) ≃ₗ[R] Π₀ i, η i →₀ N :=\n    -- Porting note: was\n    -- sigmaFinsuppAddEquivDFinsupp with map_smul' := sigmaFinsuppEquivDFinsupp_smul\n    -- but times out\n  { sigmaFinsuppEquivDFinsupp with\n    toFun := sigmaFinsuppEquivDFinsupp\n    invFun := sigmaFinsuppEquivDFinsupp.symm\n    map_add' := sigmaFinsuppEquivDFinsupp_add\n    map_smul' := sigmaFinsuppEquivDFinsupp_smul }\n\n"}
