{"name":"IsSuccArchimedean.exists_succ_iterate_of_le","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_3\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\nself : IsSuccArchimedean α\na b : α\nh : LE.le a b\n⊢ Exists fun n => Eq (Nat.iterate Order.succ n a) b","decl":"/-- A `SuccOrder` is succ-archimedean if one can go from any two comparable elements by iterating\n`succ` -/\nclass IsSuccArchimedean (α : Type*) [Preorder α] [SuccOrder α] : Prop where\n  /-- If `a ≤ b` then one can get to `a` from `b` by iterating `succ` -/\n  exists_succ_iterate_of_le {a b : α} (h : a ≤ b) : ∃ n, succ^[n] a = b\n\n"}
{"name":"IsPredArchimedean.exists_pred_iterate_of_le","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_3\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\nself : IsPredArchimedean α\na b : α\nh : LE.le a b\n⊢ Exists fun n => Eq (Nat.iterate Order.pred n b) a","decl":"/-- A `PredOrder` is pred-archimedean if one can go from any two comparable elements by iterating\n`pred` -/\nclass IsPredArchimedean (α : Type*) [Preorder α] [PredOrder α] : Prop where\n  /-- If `a ≤ b` then one can get to `b` from `a` by iterating `pred` -/\n  exists_pred_iterate_of_le {a b : α} (h : a ≤ b) : ∃ n, pred^[n] b = a\n\n"}
{"name":"instIsPredArchimedeanOrderDual","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\n⊢ IsPredArchimedean (OrderDual α)","decl":"instance : IsPredArchimedean αᵒᵈ :=\n  ⟨fun {a b} h => by convert exists_succ_iterate_of_le h.ofDual⟩\n\n"}
{"name":"LE.le.exists_succ_iterate","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\na b : α\nh : LE.le a b\n⊢ Exists fun n => Eq (Nat.iterate Order.succ n a) b","decl":"theorem LE.le.exists_succ_iterate (h : a ≤ b) : ∃ n, succ^[n] a = b :=\n  exists_succ_iterate_of_le h\n\n"}
{"name":"exists_succ_iterate_iff_le","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\na b : α\n⊢ Iff (Exists fun n => Eq (Nat.iterate Order.succ n a) b) (LE.le a b)","decl":"theorem exists_succ_iterate_iff_le : (∃ n, succ^[n] a = b) ↔ a ≤ b := by\n  refine ⟨?_, exists_succ_iterate_of_le⟩\n  rintro ⟨n, rfl⟩\n  exact id_le_iterate_of_id_le le_succ n a\n\n"}
{"name":"Succ.rec","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\nP : α → Prop\nm : α\nh0 : P m\nh1 : ∀ (n : α), LE.le m n → P n → P (Order.succ n)\nn : α\nhmn : LE.le m n\n⊢ P n","decl":"/-- Induction principle on a type with a `SuccOrder` for all elements above a given element `m`. -/\n@[elab_as_elim]\ntheorem Succ.rec {P : α → Prop} {m : α} (h0 : P m) (h1 : ∀ n, m ≤ n → P n → P (succ n)) ⦃n : α⦄\n    (hmn : m ≤ n) : P n := by\n  obtain ⟨n, rfl⟩ := hmn.exists_succ_iterate; clear hmn\n  induction' n with n ih\n  · exact h0\n  · rw [Function.iterate_succ_apply']\n    exact h1 _ (id_le_iterate_of_id_le le_succ n m) ih\n\n"}
{"name":"Succ.rec_iff","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\np : α → Prop\nhsucc : ∀ (a : α), Iff (p a) (p (Order.succ a))\na b : α\nh : LE.le a b\n⊢ Iff (p a) (p b)","decl":"theorem Succ.rec_iff {p : α → Prop} (hsucc : ∀ a, p a ↔ p (succ a)) {a b : α} (h : a ≤ b) :\n    p a ↔ p b := by\n  obtain ⟨n, rfl⟩ := h.exists_succ_iterate\n  exact Iterate.rec (fun b => p a ↔ p b) (fun c hc => hc.trans (hsucc _)) Iff.rfl n\n\n"}
{"name":"le_total_of_codirected","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\nr v₁ v₂ : α\nh₁ : LE.le r v₁\nh₂ : LE.le r v₂\n⊢ Or (LE.le v₁ v₂) (LE.le v₂ v₁)","decl":"lemma le_total_of_codirected {r v₁ v₂ : α} (h₁ : r ≤ v₁) (h₂ : r ≤ v₂) : v₁ ≤ v₂ ∨ v₂ ≤ v₁ := by\n  obtain ⟨n, rfl⟩ := h₁.exists_succ_iterate\n  obtain ⟨m, rfl⟩ := h₂.exists_succ_iterate\n  clear h₁ h₂\n  wlog h : n ≤ m\n  · rw [Or.comm]\n    apply this\n    exact Nat.le_of_not_ge h\n  left\n  obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_le h\n  rw [Nat.add_comm, Function.iterate_add, Function.comp_apply]\n  apply Order.le_succ_iterate\n\n"}
{"name":"instIsSuccArchimedeanOrderDual","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\n⊢ IsSuccArchimedean (OrderDual α)","decl":"instance : IsSuccArchimedean αᵒᵈ :=\n  ⟨fun {a b} h => by convert exists_pred_iterate_of_le h.ofDual⟩\n\n"}
{"name":"LE.le.exists_pred_iterate","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\na b : α\nh : LE.le a b\n⊢ Exists fun n => Eq (Nat.iterate Order.pred n b) a","decl":"theorem LE.le.exists_pred_iterate (h : a ≤ b) : ∃ n, pred^[n] b = a :=\n  exists_pred_iterate_of_le h\n\n"}
{"name":"exists_pred_iterate_iff_le","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\na b : α\n⊢ Iff (Exists fun n => Eq (Nat.iterate Order.pred n b) a) (LE.le a b)","decl":"theorem exists_pred_iterate_iff_le : (∃ n, pred^[n] b = a) ↔ a ≤ b :=\n  exists_succ_iterate_iff_le (α := αᵒᵈ)\n\n"}
{"name":"Pred.rec","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\nP : α → Prop\nm : α\nh0 : P m\nh1 : ∀ (n : α), LE.le n m → P n → P (Order.pred n)\nn : α\nhmn : LE.le n m\n⊢ P n","decl":"/-- Induction principle on a type with a `PredOrder` for all elements below a given element `m`. -/\n@[elab_as_elim]\ntheorem Pred.rec {P : α → Prop} {m : α} (h0 : P m) (h1 : ∀ n, n ≤ m → P n → P (pred n)) ⦃n : α⦄\n    (hmn : n ≤ m) : P n :=\n  Succ.rec (α := αᵒᵈ) (P := P) h0 h1 hmn\n\n"}
{"name":"Pred.rec_iff","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\np : α → Prop\nhsucc : ∀ (a : α), Iff (p a) (p (Order.pred a))\na b : α\nh : LE.le a b\n⊢ Iff (p a) (p b)","decl":"theorem Pred.rec_iff {p : α → Prop} (hsucc : ∀ a, p a ↔ p (pred a)) {a b : α} (h : a ≤ b) :\n    p a ↔ p b :=\n  (Succ.rec_iff (α := αᵒᵈ) hsucc h).symm\n\n"}
{"name":"le_total_of_directed","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\nr v₁ v₂ : α\nh₁ : LE.le v₁ r\nh₂ : LE.le v₂ r\n⊢ Or (LE.le v₁ v₂) (LE.le v₂ v₁)","decl":"lemma le_total_of_directed {r v₁ v₂ : α} (h₁ : v₁ ≤ r) (h₂ : v₂ ≤ r) : v₁ ≤ v₂ ∨ v₂ ≤ v₁ :=\n  Or.symm (le_total_of_codirected (α := αᵒᵈ) h₁ h₂)\n\n"}
{"name":"lt_or_le_of_codirected","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\nr v₁ v₂ : α\nh₁ : LE.le r v₁\nh₂ : LE.le r v₂\n⊢ Or (LT.lt v₁ v₂) (LE.le v₂ v₁)","decl":"lemma lt_or_le_of_codirected [SuccOrder α] [IsSuccArchimedean α] {r v₁ v₂ : α} (h₁ : r ≤ v₁)\n    (h₂ : r ≤ v₂) : v₁ < v₂ ∨ v₂ ≤ v₁ := by\n  rw [Classical.or_iff_not_imp_right]\n  intro nh\n  rcases le_total_of_codirected h₁ h₂ with h | h\n  · apply lt_of_le_of_ne h (ne_of_not_le nh).symm\n  · contradiction\n\n"}
{"name":"lt_or_le_of_directed","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\nr v₁ v₂ : α\nh₁ : LE.le v₁ r\nh₂ : LE.le v₂ r\n⊢ Or (LT.lt v₁ v₂) (LE.le v₂ v₁)","decl":"lemma lt_or_le_of_directed [PredOrder α] [IsPredArchimedean α] {r v₁ v₂ : α} (h₁ : v₁ ≤ r)\n    (h₂ : v₂ ≤ r) : v₁ < v₂ ∨ v₂ ≤ v₁ := by\n  rw [Classical.or_iff_not_imp_right]\n  intro nh\n  rcases le_total_of_directed h₁ h₂ with h | h\n  · apply lt_of_le_of_ne h (ne_of_not_le nh).symm\n  · contradiction\n\n"}
{"name":"succ_max","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\na b : α\n⊢ Eq (Order.succ (Max.max a b)) (Max.max (Order.succ a) (Order.succ b))","decl":"lemma succ_max (a b : α) : succ (max a b) = max (succ a) (succ b) := succ_mono.map_max\n"}
{"name":"succ_min","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\na b : α\n⊢ Eq (Order.succ (Min.min a b)) (Min.min (Order.succ a) (Order.succ b))","decl":"lemma succ_min (a b : α) : succ (min a b) = min (succ a) (succ b) := succ_mono.map_min\n\n"}
{"name":"exists_succ_iterate_or","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\na b : α\n⊢ Or (Exists fun n => Eq (Nat.iterate Order.succ n a) b) (Exists fun n => Eq (Nat.iterate Order.succ n b) a)","decl":"theorem exists_succ_iterate_or : (∃ n, succ^[n] a = b) ∨ ∃ n, succ^[n] b = a :=\n  (le_total a b).imp exists_succ_iterate_of_le exists_succ_iterate_of_le\n\n"}
{"name":"Succ.rec_linear","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\np : α → Prop\nhsucc : ∀ (a : α), Iff (p a) (p (Order.succ a))\na b : α\n⊢ Iff (p a) (p b)","decl":"theorem Succ.rec_linear {p : α → Prop} (hsucc : ∀ a, p a ↔ p (succ a)) (a b : α) : p a ↔ p b :=\n  (le_total a b).elim (Succ.rec_iff hsucc) fun h => (Succ.rec_iff hsucc h).symm\n\n"}
{"name":"pred_max","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : PredOrder α\na b : α\n⊢ Eq (Order.pred (Max.max a b)) (Max.max (Order.pred a) (Order.pred b))","decl":"lemma pred_max (a b : α) : pred (max a b) = max (pred a) (pred b) := pred_mono.map_max\n"}
{"name":"pred_min","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : PredOrder α\na b : α\n⊢ Eq (Order.pred (Min.min a b)) (Min.min (Order.pred a) (Order.pred b))","decl":"lemma pred_min (a b : α) : pred (min a b) = min (pred a) (pred b) := pred_mono.map_min\n\n"}
{"name":"exists_pred_iterate_or","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\na b : α\n⊢ Or (Exists fun n => Eq (Nat.iterate Order.pred n b) a) (Exists fun n => Eq (Nat.iterate Order.pred n a) b)","decl":"theorem exists_pred_iterate_or : (∃ n, pred^[n] b = a) ∨ ∃ n, pred^[n] a = b :=\n  (le_total a b).imp exists_pred_iterate_of_le exists_pred_iterate_of_le\n\n"}
{"name":"Pred.rec_linear","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\np : α → Prop\nhsucc : ∀ (a : α), Iff (p a) (p (Order.pred a))\na b : α\n⊢ Iff (p a) (p b)","decl":"theorem Pred.rec_linear {p : α → Prop} (hsucc : ∀ a, p a ↔ p (pred a)) (a b : α) : p a ↔ p b :=\n  (le_total a b).elim (Pred.rec_iff hsucc) fun h => (Pred.rec_iff hsucc h).symm\n\n"}
{"name":"StrictMono.not_bddAbove_range_of_isSuccArchimedean","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : Nonempty α\ninst✝³ : Preorder β\nf : α → β\ninst✝² : NoMaxOrder α\ninst✝¹ : SuccOrder β\ninst✝ : IsSuccArchimedean β\nhf : StrictMono f\n⊢ Not (BddAbove (Set.range f))","decl":"lemma StrictMono.not_bddAbove_range_of_isSuccArchimedean [NoMaxOrder α] [SuccOrder β]\n    [IsSuccArchimedean β] (hf : StrictMono f) : ¬ BddAbove (Set.range f) := by\n  rintro ⟨m, hm⟩\n  have hm' : ∀ a, f a ≤ m := fun a ↦ hm <| Set.mem_range_self _\n  obtain ⟨a₀⟩ := ‹Nonempty α›\n  suffices ∀ b, f a₀ ≤ b → ∃ a, b < f a by\n    obtain ⟨a, ha⟩ : ∃ a, m < f a := this m (hm' a₀)\n    exact ha.not_le (hm' a)\n  have h : ∀ a, ∃ a', f a < f a' := fun a ↦ (exists_gt a).imp (fun a' h ↦ hf h)\n  apply Succ.rec\n  · exact h a₀\n  rintro b _ ⟨a, hba⟩\n  exact (h a).imp (fun a' ↦ (succ_le_of_lt hba).trans_lt)\n\n"}
{"name":"StrictMono.not_bddAbove_range","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : Nonempty α\ninst✝³ : Preorder β\nf : α → β\ninst✝² : NoMaxOrder α\ninst✝¹ : SuccOrder β\ninst✝ : IsSuccArchimedean β\nhf : StrictMono f\n⊢ Not (BddAbove (Set.range f))","decl":"@[deprecated StrictMono.not_bddAbove_range_of_isSuccArchimedean (since := \"2024-09-21\")]\nalias StrictMono.not_bddAbove_range := StrictMono.not_bddAbove_range_of_isSuccArchimedean\n\n"}
{"name":"StrictMono.not_bddBelow_range_of_isPredArchimedean","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : Nonempty α\ninst✝³ : Preorder β\nf : α → β\ninst✝² : NoMinOrder α\ninst✝¹ : PredOrder β\ninst✝ : IsPredArchimedean β\nhf : StrictMono f\n⊢ Not (BddBelow (Set.range f))","decl":"lemma StrictMono.not_bddBelow_range_of_isPredArchimedean [NoMinOrder α] [PredOrder β]\n    [IsPredArchimedean β] (hf : StrictMono f) : ¬ BddBelow (Set.range f) :=\n  hf.dual.not_bddAbove_range_of_isSuccArchimedean\n\n"}
{"name":"StrictMono.not_bddBelow_range","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : Nonempty α\ninst✝³ : Preorder β\nf : α → β\ninst✝² : NoMinOrder α\ninst✝¹ : PredOrder β\ninst✝ : IsPredArchimedean β\nhf : StrictMono f\n⊢ Not (BddBelow (Set.range f))","decl":"@[deprecated StrictMono.not_bddBelow_range_of_isPredArchimedean (since := \"2024-09-21\")]\nalias StrictMono.not_bddBelow_range := StrictMono.not_bddBelow_range_of_isPredArchimedean\n\n"}
{"name":"StrictAnti.not_bddBelow_range_of_isSuccArchimedean","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : Nonempty α\ninst✝³ : Preorder β\nf : α → β\ninst✝² : NoMinOrder α\ninst✝¹ : SuccOrder β\ninst✝ : IsSuccArchimedean β\nhf : StrictAnti f\n⊢ Not (BddAbove (Set.range f))","decl":"lemma StrictAnti.not_bddBelow_range_of_isSuccArchimedean [NoMinOrder α] [SuccOrder β]\n    [IsSuccArchimedean β] (hf : StrictAnti f) : ¬ BddAbove (Set.range f) :=\n  hf.dual_right.not_bddBelow_range_of_isPredArchimedean\n\n"}
{"name":"StrictAnti.not_bddAbove_range","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : Nonempty α\ninst✝³ : Preorder β\nf : α → β\ninst✝² : NoMinOrder α\ninst✝¹ : SuccOrder β\ninst✝ : IsSuccArchimedean β\nhf : StrictAnti f\n⊢ Not (BddAbove (Set.range f))","decl":"@[deprecated StrictAnti.not_bddBelow_range_of_isSuccArchimedean (since := \"2024-09-21\")]\nalias StrictAnti.not_bddAbove_range := StrictAnti.not_bddBelow_range_of_isSuccArchimedean\n\n"}
{"name":"StrictAnti.not_bddBelow_range_of_isPredArchimedean","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : Nonempty α\ninst✝³ : Preorder β\nf : α → β\ninst✝² : NoMaxOrder α\ninst✝¹ : PredOrder β\ninst✝ : IsPredArchimedean β\nhf : StrictAnti f\n⊢ Not (BddBelow (Set.range f))","decl":"lemma StrictAnti.not_bddBelow_range_of_isPredArchimedean [NoMaxOrder α] [PredOrder β]\n    [IsPredArchimedean β] (hf : StrictAnti f) : ¬ BddBelow (Set.range f) :=\n  hf.dual_right.not_bddAbove_range_of_isSuccArchimedean\n\n"}
{"name":"StrictAnti.not_bddBelow_range","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : Nonempty α\ninst✝³ : Preorder β\nf : α → β\ninst✝² : NoMaxOrder α\ninst✝¹ : PredOrder β\ninst✝ : IsPredArchimedean β\nhf : StrictAnti f\n⊢ Not (BddBelow (Set.range f))","decl":"@[deprecated StrictAnti.not_bddBelow_range_of_isPredArchimedean (since := \"2024-09-21\")]\nalias StrictAnti.not_bddBelow_range := StrictAnti.not_bddBelow_range_of_isPredArchimedean\n\n"}
{"name":"WellFoundedLT.toIsPredArchimedean","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\nh : WellFoundedLT α\ninst✝ : PredOrder α\n⊢ IsPredArchimedean α","decl":"instance (priority := 100) WellFoundedLT.toIsPredArchimedean [h : WellFoundedLT α]\n    [PredOrder α] : IsPredArchimedean α :=\n  ⟨fun {a b} => by\n    refine WellFounded.fix (C := fun b => a ≤ b → ∃ n, Nat.iterate pred n b = a)\n      h.wf ?_ b\n    intros b ih hab\n    replace hab := eq_or_lt_of_le hab\n    rcases hab with (rfl | hab)\n    · exact ⟨0, rfl⟩\n    rcases eq_or_lt_of_le (pred_le b) with hb | hb\n    · cases (min_of_le_pred hb.ge).not_lt hab\n    dsimp at ih\n    obtain ⟨k, hk⟩ := ih (pred b) hb (le_pred_of_lt hab)\n    refine ⟨k + 1, ?_⟩\n    rw [iterate_add_apply, iterate_one, hk]⟩\n\n"}
{"name":"WellFoundedGT.toIsSuccArchimedean","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\nh : WellFoundedGT α\ninst✝ : SuccOrder α\n⊢ IsSuccArchimedean α","decl":"instance (priority := 100) WellFoundedGT.toIsSuccArchimedean [h : WellFoundedGT α]\n    [SuccOrder α] : IsSuccArchimedean α :=\n  let h : IsPredArchimedean αᵒᵈ := by infer_instance\n  ⟨h.1⟩\n\n"}
{"name":"Succ.rec_bot","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝³ : Preorder α\ninst✝² : OrderBot α\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\np : α → Prop\nhbot : p Bot.bot\nhsucc : ∀ (a : α), p a → p (Order.succ a)\na : α\n⊢ p a","decl":"theorem Succ.rec_bot (p : α → Prop) (hbot : p ⊥) (hsucc : ∀ a, p a → p (succ a)) (a : α) : p a :=\n  Succ.rec hbot (fun x _ h => hsucc x h) (bot_le : ⊥ ≤ a)\n\n"}
{"name":"Pred.rec_top","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝³ : Preorder α\ninst✝² : OrderTop α\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\np : α → Prop\nhtop : p Top.top\nhpred : ∀ (a : α), p a → p (Order.pred a)\na : α\n⊢ p a","decl":"theorem Pred.rec_top (p : α → Prop) (htop : p ⊤) (hpred : ∀ a, p a → p (pred a)) (a : α) : p a :=\n  Pred.rec htop (fun x _ h => hpred x h) (le_top : a ≤ ⊤)\n\n"}
{"name":"SuccOrder.forall_ne_bot_iff","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝⁴ : Nontrivial α\ninst✝³ : PartialOrder α\ninst✝² : OrderBot α\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\nP : α → Prop\n⊢ Iff (∀ (i : α), Ne i Bot.bot → P i) (∀ (i : α), P (SuccOrder.succ i))","decl":"lemma SuccOrder.forall_ne_bot_iff\n    [Nontrivial α] [PartialOrder α] [OrderBot α] [SuccOrder α] [IsSuccArchimedean α]\n    (P : α → Prop) :\n    (∀ i, i ≠ ⊥ → P i) ↔ (∀ i, P (SuccOrder.succ i)) := by\n  refine ⟨fun h i ↦ h _ (Order.succ_ne_bot i), fun h i hi ↦ ?_⟩\n  obtain ⟨j, rfl⟩ := exists_succ_iterate_of_le (bot_le : ⊥ ≤ i)\n  have hj : 0 < j := by apply Nat.pos_of_ne_zero; contrapose! hi; simp [hi]\n  rw [← Nat.succ_pred_eq_of_pos hj]\n  simp only [Function.iterate_succ', Function.comp_apply]\n  apply h\n\n"}
{"name":"BddAbove.exists_isGreatest_of_nonempty","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"X : Type u_3\ninst✝² : LinearOrder X\ninst✝¹ : SuccOrder X\ninst✝ : IsSuccArchimedean X\nS : Set X\nhS : BddAbove S\nhS' : S.Nonempty\n⊢ Exists fun x => IsGreatest S x","decl":"lemma BddAbove.exists_isGreatest_of_nonempty {X : Type*} [LinearOrder X] [SuccOrder X]\n    [IsSuccArchimedean X] {S : Set X} (hS : BddAbove S) (hS' : S.Nonempty) :\n    ∃ x, IsGreatest S x := by\n  obtain ⟨m, hm⟩ := hS\n  obtain ⟨n, hn⟩ := hS'\n  by_cases hm' : m ∈ S\n  · exact ⟨_, hm', hm⟩\n  have hn' := hm hn\n  revert hn hm hm'\n  refine Succ.rec ?_ ?_ hn'\n  · simp (config := {contextual := true})\n  intro m _ IH hm hn hm'\n  rw [mem_upperBounds] at IH hm\n  simp_rw [Order.le_succ_iff_eq_or_le] at hm\n  replace hm : ∀ x ∈ S, x ≤ m := by\n    intro x hx\n    refine (hm x hx).resolve_left ?_\n    rintro rfl\n    exact hm' hx\n  by_cases hmS : m ∈ S\n  · exact ⟨m, hmS, hm⟩\n  · exact IH hm hn hmS\n\n"}
{"name":"BddBelow.exists_isLeast_of_nonempty","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"X : Type u_3\ninst✝² : LinearOrder X\ninst✝¹ : PredOrder X\ninst✝ : IsPredArchimedean X\nS : Set X\nhS : BddBelow S\nhS' : S.Nonempty\n⊢ Exists fun x => IsLeast S x","decl":"lemma BddBelow.exists_isLeast_of_nonempty {X : Type*} [LinearOrder X] [PredOrder X]\n    [IsPredArchimedean X] {S : Set X} (hS : BddBelow S) (hS' : S.Nonempty) :\n    ∃ x, IsLeast S x :=\n  hS.dual.exists_isGreatest_of_nonempty hS'\n\n"}
{"name":"IsSuccArchimedean.of_orderIso","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"X : Type u_3\nY : Type u_4\ninst✝⁴ : PartialOrder X\ninst✝³ : PartialOrder Y\ninst✝² : SuccOrder X\ninst✝¹ : IsSuccArchimedean X\ninst✝ : SuccOrder Y\nf : OrderIso X Y\n⊢ IsSuccArchimedean Y","decl":"/-- `IsSuccArchimedean` transfers across equivalences between `SuccOrder`s. -/\nprotected lemma IsSuccArchimedean.of_orderIso [SuccOrder X] [IsSuccArchimedean X] [SuccOrder Y]\n    (f : X ≃o Y) : IsSuccArchimedean Y where\n  exists_succ_iterate_of_le {a b} h := by\n    refine (exists_succ_iterate_of_le ((map_inv_le_map_inv_iff f).mpr h)).imp ?_\n    intro n\n    rw [← f.apply_eq_iff_eq, EquivLike.apply_inv_apply]\n    rintro rfl\n    clear h\n    induction n generalizing a with\n    | zero => simp\n    | succ n IH => simp only [Function.iterate_succ', Function.comp_apply, IH, f.map_succ]\n\n"}
{"name":"IsPredArchimedean.of_orderIso","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"X : Type u_3\nY : Type u_4\ninst✝⁴ : PartialOrder X\ninst✝³ : PartialOrder Y\ninst✝² : PredOrder X\ninst✝¹ : IsPredArchimedean X\ninst✝ : PredOrder Y\nf : OrderIso X Y\n⊢ IsPredArchimedean Y","decl":"/-- `IsPredArchimedean` transfers across equivalences between `PredOrder`s. -/\nprotected lemma IsPredArchimedean.of_orderIso [PredOrder X] [IsPredArchimedean X] [PredOrder Y]\n    (f : X ≃o Y) : IsPredArchimedean Y where\n  exists_pred_iterate_of_le {a b} h := by\n    refine (exists_pred_iterate_of_le ((map_inv_le_map_inv_iff f).mpr h)).imp ?_\n    intro n\n    rw [← f.apply_eq_iff_eq, EquivLike.apply_inv_apply]\n    rintro rfl\n    clear h\n    induction n generalizing b with\n    | zero => simp\n    | succ n IH => simp only [Function.iterate_succ', Function.comp_apply, IH, f.map_pred]\n\n"}
{"name":"Set.OrdConnected.isPredArchimedean","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝³ : PartialOrder α\ninst✝² : PredOrder α\ninst✝¹ : IsPredArchimedean α\ns : Set α\ninst✝ : s.OrdConnected\n⊢ IsPredArchimedean ↑s","decl":"instance Set.OrdConnected.isPredArchimedean [PredOrder α] [IsPredArchimedean α]\n    (s : Set α) [s.OrdConnected] : IsPredArchimedean s where\n  exists_pred_iterate_of_le := @fun ⟨b, hb⟩ ⟨c, hc⟩ hbc ↦ by classical\n    simp only [Subtype.mk_le_mk] at hbc\n    obtain ⟨n, hn⟩ := hbc.exists_pred_iterate\n    use n\n    induction n generalizing c with\n    | zero => simp_all\n    | succ n hi =>\n      simp_all only [Function.iterate_succ, Function.comp_apply]\n      change Order.pred^[n] (dite ..) = _\n      split_ifs with h\n      · dsimp only at h ⊢\n        apply hi _ _ _ hn\n        · rw [← hn]\n          apply Order.pred_iterate_le\n      · have : Order.pred (⟨c, hc⟩ : s) = ⟨c, hc⟩ := by\n          change dite .. = _\n          simp [h]\n        rw [Function.iterate_fixed]\n        · simp only [Order.pred_eq_iff_isMin] at this\n          apply (this.eq_of_le _).symm\n          exact hbc\n        · exact this\n\n"}
{"name":"Set.OrdConnected.isSuccArchimedean","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_1\ninst✝³ : PartialOrder α\ninst✝² : SuccOrder α\ninst✝¹ : IsSuccArchimedean α\ns : Set α\ninst✝ : s.OrdConnected\n⊢ IsSuccArchimedean ↑s","decl":"instance Set.OrdConnected.isSuccArchimedean [SuccOrder α] [IsSuccArchimedean α]\n    (s : Set α) [s.OrdConnected] : IsSuccArchimedean s :=\n  letI : IsPredArchimedean sᵒᵈ := inferInstanceAs (IsPredArchimedean (OrderDual.ofDual ⁻¹' s))\n  inferInstanceAs (IsSuccArchimedean sᵒᵈᵒᵈ)\n\n"}
{"name":"monotoneOn_of_le_succ","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝³ : PartialOrder α\ninst✝² : Preorder β\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\ns : Set α\nf : α → β\nhs : s.OrdConnected\nhf : ∀ (a : α), Not (IsMax a) → Membership.mem s a → Membership.mem s (Order.succ a) → LE.le (f a) (f (Order.succ a))\n⊢ MonotoneOn f s","decl":"lemma monotoneOn_of_le_succ (hs : s.OrdConnected)\n    (hf : ∀ a, ¬ IsMax a → a ∈ s → succ a ∈ s → f a ≤ f (succ a)) : MonotoneOn f s := by\n  rintro a ha b hb hab\n  obtain ⟨n, rfl⟩ := exists_succ_iterate_of_le hab\n  clear hab\n  induction' n with n hn\n  · simp\n  rw [Function.iterate_succ_apply'] at hb ⊢\n  have : succ^[n] a ∈ s := hs.1 ha hb ⟨le_succ_iterate .., le_succ _⟩\n  by_cases hb' : IsMax (succ^[n] a)\n  · rw [succ_eq_iff_isMax.2 hb']\n    exact hn this\n  · exact (hn this).trans (hf _ hb' this hb)\n\n"}
{"name":"antitoneOn_of_succ_le","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝³ : PartialOrder α\ninst✝² : Preorder β\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\ns : Set α\nf : α → β\nhs : s.OrdConnected\nhf : ∀ (a : α), Not (IsMax a) → Membership.mem s a → Membership.mem s (Order.succ a) → LE.le (f (Order.succ a)) (f a)\n⊢ AntitoneOn f s","decl":"lemma antitoneOn_of_succ_le (hs : s.OrdConnected)\n    (hf : ∀ a, ¬ IsMax a → a ∈ s → succ a ∈ s → f (succ a) ≤ f a) : AntitoneOn f s :=\n  monotoneOn_of_le_succ (β := βᵒᵈ) hs hf\n\n"}
{"name":"strictMonoOn_of_lt_succ","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝³ : PartialOrder α\ninst✝² : Preorder β\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\ns : Set α\nf : α → β\nhs : s.OrdConnected\nhf : ∀ (a : α), Not (IsMax a) → Membership.mem s a → Membership.mem s (Order.succ a) → LT.lt (f a) (f (Order.succ a))\n⊢ StrictMonoOn f s","decl":"lemma strictMonoOn_of_lt_succ (hs : s.OrdConnected)\n    (hf : ∀ a, ¬ IsMax a → a ∈ s → succ a ∈ s → f a < f (succ a)) : StrictMonoOn f s := by\n  rintro a ha b hb hab\n  obtain ⟨n, rfl⟩ := exists_succ_iterate_of_le hab.le\n  obtain _ | n := n\n  · simp at hab\n  apply not_isMax_of_lt at hab\n  induction' n with n hn\n  · simpa using hf _ hab ha hb\n  rw [Function.iterate_succ_apply'] at hb ⊢\n  have : succ^[n + 1] a ∈ s := hs.1 ha hb ⟨le_succ_iterate .., le_succ _⟩\n  by_cases hb' : IsMax (succ^[n + 1] a)\n  · rw [succ_eq_iff_isMax.2 hb']\n    exact hn this\n  · exact (hn this).trans (hf _ hb' this hb)\n\n"}
{"name":"strictAntiOn_of_succ_lt","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝³ : PartialOrder α\ninst✝² : Preorder β\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\ns : Set α\nf : α → β\nhs : s.OrdConnected\nhf : ∀ (a : α), Not (IsMax a) → Membership.mem s a → Membership.mem s (Order.succ a) → LT.lt (f (Order.succ a)) (f a)\n⊢ StrictAntiOn f s","decl":"lemma strictAntiOn_of_succ_lt (hs : s.OrdConnected)\n    (hf : ∀ a, ¬ IsMax a → a ∈ s → succ a ∈ s → f (succ a) < f a) : StrictAntiOn f s :=\n  strictMonoOn_of_lt_succ (β := βᵒᵈ) hs hf\n\n"}
{"name":"monotone_of_le_succ","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝³ : PartialOrder α\ninst✝² : Preorder β\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\nf : α → β\nhf : ∀ (a : α), Not (IsMax a) → LE.le (f a) (f (Order.succ a))\n⊢ Monotone f","decl":"lemma monotone_of_le_succ (hf : ∀ a, ¬ IsMax a → f a ≤ f (succ a)) : Monotone f := by\n  simpa using monotoneOn_of_le_succ Set.ordConnected_univ (by simpa using hf)\n\n"}
{"name":"antitone_of_succ_le","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝³ : PartialOrder α\ninst✝² : Preorder β\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\nf : α → β\nhf : ∀ (a : α), Not (IsMax a) → LE.le (f (Order.succ a)) (f a)\n⊢ Antitone f","decl":"lemma antitone_of_succ_le (hf : ∀ a, ¬ IsMax a → f (succ a) ≤ f a) : Antitone f := by\n  simpa using antitoneOn_of_succ_le Set.ordConnected_univ (by simpa using hf)\n\n"}
{"name":"strictMono_of_lt_succ","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝³ : PartialOrder α\ninst✝² : Preorder β\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\nf : α → β\nhf : ∀ (a : α), Not (IsMax a) → LT.lt (f a) (f (Order.succ a))\n⊢ StrictMono f","decl":"lemma strictMono_of_lt_succ (hf : ∀ a, ¬ IsMax a → f a < f (succ a)) : StrictMono f := by\n  simpa using strictMonoOn_of_lt_succ Set.ordConnected_univ (by simpa using hf)\n\n"}
{"name":"strictAnti_of_succ_lt","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝³ : PartialOrder α\ninst✝² : Preorder β\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\nf : α → β\nhf : ∀ (a : α), Not (IsMax a) → LT.lt (f (Order.succ a)) (f a)\n⊢ StrictAnti f","decl":"lemma strictAnti_of_succ_lt (hf : ∀ a, ¬ IsMax a → f (succ a) < f a) : StrictAnti f := by\n  simpa using strictAntiOn_of_succ_lt Set.ordConnected_univ (by simpa using hf)\n\n"}
{"name":"monotoneOn_of_pred_le","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝³ : PartialOrder α\ninst✝² : Preorder β\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\ns : Set α\nf : α → β\nhs : s.OrdConnected\nhf : ∀ (a : α), Not (IsMin a) → Membership.mem s a → Membership.mem s (Order.pred a) → LE.le (f (Order.pred a)) (f a)\n⊢ MonotoneOn f s","decl":"lemma monotoneOn_of_pred_le (hs : s.OrdConnected)\n    (hf : ∀ a, ¬ IsMin a → a ∈ s → pred a ∈ s → f (pred a) ≤ f a) : MonotoneOn f s := by\n  rintro a ha b hb hab\n  obtain ⟨n, rfl⟩ := exists_pred_iterate_of_le hab\n  clear hab\n  induction' n with n hn\n  · simp\n  rw [Function.iterate_succ_apply'] at ha ⊢\n  have : pred^[n] b ∈ s := hs.1 ha hb ⟨pred_le _, pred_iterate_le ..⟩\n  by_cases ha' : IsMin (pred^[n] b)\n  · rw [pred_eq_iff_isMin.2 ha']\n    exact hn this\n  · exact (hn this).trans' (hf _ ha' this ha)\n\n"}
{"name":"antitoneOn_of_le_pred","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝³ : PartialOrder α\ninst✝² : Preorder β\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\ns : Set α\nf : α → β\nhs : s.OrdConnected\nhf : ∀ (a : α), Not (IsMin a) → Membership.mem s a → Membership.mem s (Order.pred a) → LE.le (f a) (f (Order.pred a))\n⊢ AntitoneOn f s","decl":"lemma antitoneOn_of_le_pred (hs : s.OrdConnected)\n    (hf : ∀ a, ¬ IsMin a → a ∈ s → pred a ∈ s → f a ≤ f (pred a)) : AntitoneOn f s :=\n  monotoneOn_of_pred_le (β := βᵒᵈ) hs hf\n\n"}
{"name":"strictMonoOn_of_pred_lt","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝³ : PartialOrder α\ninst✝² : Preorder β\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\ns : Set α\nf : α → β\nhs : s.OrdConnected\nhf : ∀ (a : α), Not (IsMin a) → Membership.mem s a → Membership.mem s (Order.pred a) → LT.lt (f (Order.pred a)) (f a)\n⊢ StrictMonoOn f s","decl":"lemma strictMonoOn_of_pred_lt (hs : s.OrdConnected)\n    (hf : ∀ a, ¬ IsMin a → a ∈ s → pred a ∈ s → f (pred a) < f a) : StrictMonoOn f s := by\n  rintro a ha b hb hab\n  obtain ⟨n, rfl⟩ := exists_pred_iterate_of_le hab.le\n  obtain _ | n := n\n  · simp at hab\n  apply not_isMin_of_lt at hab\n  induction' n with n hn\n  · simpa using hf _ hab hb ha\n  rw [Function.iterate_succ_apply'] at ha ⊢\n  have : pred^[n + 1] b ∈ s := hs.1 ha hb ⟨pred_le _, pred_iterate_le ..⟩\n  by_cases ha' : IsMin (pred^[n + 1] b)\n  · rw [pred_eq_iff_isMin.2 ha']\n    exact hn this\n  · exact (hn this).trans' (hf _ ha' this ha)\n\n"}
{"name":"strictAntiOn_of_lt_pred","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝³ : PartialOrder α\ninst✝² : Preorder β\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\ns : Set α\nf : α → β\nhs : s.OrdConnected\nhf : ∀ (a : α), Not (IsMin a) → Membership.mem s a → Membership.mem s (Order.pred a) → LT.lt (f a) (f (Order.pred a))\n⊢ StrictAntiOn f s","decl":"lemma strictAntiOn_of_lt_pred (hs : s.OrdConnected)\n    (hf : ∀ a, ¬ IsMin a → a ∈ s → pred a ∈ s → f a < f (pred a)) : StrictAntiOn f s :=\n  strictMonoOn_of_pred_lt (β := βᵒᵈ) hs hf\n\n"}
{"name":"monotone_of_pred_le","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝³ : PartialOrder α\ninst✝² : Preorder β\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\nf : α → β\nhf : ∀ (a : α), Not (IsMin a) → LE.le (f (Order.pred a)) (f a)\n⊢ Monotone f","decl":"lemma monotone_of_pred_le (hf : ∀ a, ¬ IsMin a → f (pred a) ≤ f a) : Monotone f := by\n  simpa using monotoneOn_of_pred_le Set.ordConnected_univ (by simpa using hf)\n\n"}
{"name":"antitone_of_le_pred","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝³ : PartialOrder α\ninst✝² : Preorder β\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\nf : α → β\nhf : ∀ (a : α), Not (IsMin a) → LE.le (f a) (f (Order.pred a))\n⊢ Antitone f","decl":"lemma antitone_of_le_pred (hf : ∀ a, ¬ IsMin a → f a ≤ f (pred a)) : Antitone f := by\n  simpa using antitoneOn_of_le_pred Set.ordConnected_univ (by simpa using hf)\n\n"}
{"name":"strictMono_of_pred_lt","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝³ : PartialOrder α\ninst✝² : Preorder β\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\nf : α → β\nhf : ∀ (a : α), Not (IsMin a) → LT.lt (f (Order.pred a)) (f a)\n⊢ StrictMono f","decl":"lemma strictMono_of_pred_lt (hf : ∀ a, ¬ IsMin a → f (pred a) < f a) : StrictMono f := by\n  simpa using strictMonoOn_of_pred_lt Set.ordConnected_univ (by simpa using hf)\n\n"}
{"name":"strictAnti_of_lt_pred","module":"Mathlib.Order.SuccPred.Archimedean","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝³ : PartialOrder α\ninst✝² : Preorder β\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\nf : α → β\nhf : ∀ (a : α), Not (IsMin a) → LT.lt (f a) (f (Order.pred a))\n⊢ StrictAnti f","decl":"lemma strictAnti_of_lt_pred (hf : ∀ a, ¬ IsMin a → f a < f (pred a)) : StrictAnti f := by\n  simpa using strictAntiOn_of_lt_pred Set.ordConnected_univ (by simpa using hf)\n\n"}
