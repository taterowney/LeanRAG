{"name":"Complex.sin_arg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\n‚ä¢ Eq (Real.sin x.arg) (HDiv.hDiv x.im (Complex.abs x))","decl":"theorem sin_arg (x : ‚ÑÇ) : Real.sin (arg x) = x.im / abs x := by\n  unfold arg; split_ifs <;>\n    simp [sub_eq_add_neg, arg,\n      Real.sin_arcsin (abs_le.1 (abs_im_div_abs_le_one x)).1 (abs_le.1 (abs_im_div_abs_le_one x)).2,\n      Real.sin_add, neg_div, Real.arcsin_neg, Real.sin_neg]\n\n"}
{"name":"Complex.cos_arg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\nhx : Ne x 0\n‚ä¢ Eq (Real.cos x.arg) (HDiv.hDiv x.re (Complex.abs x))","decl":"theorem cos_arg {x : ‚ÑÇ} (hx : x ‚â† 0) : Real.cos (arg x) = x.re / abs x := by\n  rw [arg]\n  split_ifs with h‚ÇÅ h‚ÇÇ\n  ¬∑ rw [Real.cos_arcsin]\n    field_simp [Real.sqrt_sq, (abs.pos hx).le, *]\n  ¬∑ rw [Real.cos_add_pi, Real.cos_arcsin]\n    field_simp [Real.sqrt_div (sq_nonneg _), Real.sqrt_sq_eq_abs,\n      _root_.abs_of_neg (not_le.1 h‚ÇÅ), *]\n  ¬∑ rw [Real.cos_sub_pi, Real.cos_arcsin]\n    field_simp [Real.sqrt_div (sq_nonneg _), Real.sqrt_sq_eq_abs,\n      _root_.abs_of_neg (not_le.1 h‚ÇÅ), *]\n\n"}
{"name":"Complex.abs_mul_exp_arg_mul_I","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\n‚ä¢ Eq (HMul.hMul (‚Üë(Complex.abs x)) (Complex.exp (HMul.hMul (‚Üëx.arg) Complex.I))) x","decl":"@[simp]\ntheorem abs_mul_exp_arg_mul_I (x : ‚ÑÇ) : ‚Üë(abs x) * exp (arg x * I) = x := by\n  rcases eq_or_ne x 0 with (rfl | hx)\n  ¬∑ simp\n  ¬∑ have : abs x ‚â† 0 := abs.ne_zero hx\n    apply Complex.ext <;> field_simp [sin_arg, cos_arg hx, this, mul_comm (abs x)]\n\n"}
{"name":"Complex.abs_mul_cos_add_sin_mul_I","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\n‚ä¢ Eq (HMul.hMul (‚Üë(Complex.abs x)) (HAdd.hAdd (Complex.cos ‚Üëx.arg) (HMul.hMul (Complex.sin ‚Üëx.arg) Complex.I))) x","decl":"@[simp]\ntheorem abs_mul_cos_add_sin_mul_I (x : ‚ÑÇ) : (abs x * (cos (arg x) + sin (arg x) * I) : ‚ÑÇ) = x := by\n  rw [‚Üê exp_mul_I, abs_mul_exp_arg_mul_I]\n\n"}
{"name":"Complex.abs_mul_cos_arg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\n‚ä¢ Eq (HMul.hMul (Complex.abs x) (Real.cos x.arg)) x.re","decl":"@[simp]\nlemma abs_mul_cos_arg (x : ‚ÑÇ) : abs x * Real.cos (arg x) = x.re := by\n  simpa [-abs_mul_cos_add_sin_mul_I] using congr_arg re (abs_mul_cos_add_sin_mul_I x)\n\n"}
{"name":"Complex.abs_mul_sin_arg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\n‚ä¢ Eq (HMul.hMul (Complex.abs x) (Real.sin x.arg)) x.im","decl":"@[simp]\nlemma abs_mul_sin_arg (x : ‚ÑÇ) : abs x * Real.sin (arg x) = x.im := by\n  simpa [-abs_mul_cos_add_sin_mul_I] using congr_arg im (abs_mul_cos_add_sin_mul_I x)\n\n"}
{"name":"Complex.abs_eq_one_iff","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\n‚ä¢ Iff (Eq (Complex.abs z) 1) (Exists fun Œ∏ => Eq (Complex.exp (HMul.hMul (‚ÜëŒ∏) Complex.I)) z)","decl":"theorem abs_eq_one_iff (z : ‚ÑÇ) : abs z = 1 ‚Üî ‚àÉ Œ∏ : ‚Ñù, exp (Œ∏ * I) = z := by\n  refine ‚ü®fun hz => ‚ü®arg z, ?_‚ü©, ?_‚ü©\n  ¬∑ calc\n      exp (arg z * I) = abs z * exp (arg z * I) := by rw [hz, ofReal_one, one_mul]\n      _ = z := abs_mul_exp_arg_mul_I z\n\n  ¬∑ rintro ‚ü®Œ∏, rfl‚ü©\n    exact Complex.abs_exp_ofReal_mul_I Œ∏\n\n"}
{"name":"Complex.range_exp_mul_I","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"‚ä¢ Eq (Set.range fun x => Complex.exp (HMul.hMul (‚Üëx) Complex.I)) (Metric.sphere 0 1)","decl":"@[simp]\ntheorem range_exp_mul_I : (Set.range fun x : ‚Ñù => exp (x * I)) = Metric.sphere 0 1 := by\n  ext x\n  simp only [mem_sphere_zero_iff_norm, norm_eq_abs, abs_eq_one_iff, Set.mem_range]\n\n"}
{"name":"Complex.arg_mul_cos_add_sin_mul_I","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"r : Real\nhr : LT.lt 0 r\nŒ∏ : Real\nhŒ∏ : Membership.mem (Set.Ioc (Neg.neg Real.pi) Real.pi) Œ∏\n‚ä¢ Eq (HMul.hMul (‚Üër) (HAdd.hAdd (Complex.cos ‚ÜëŒ∏) (HMul.hMul (Complex.sin ‚ÜëŒ∏) Complex.I))).arg Œ∏","decl":"theorem arg_mul_cos_add_sin_mul_I {r : ‚Ñù} (hr : 0 < r) {Œ∏ : ‚Ñù} (hŒ∏ : Œ∏ ‚àà Set.Ioc (-œÄ) œÄ) :\n    arg (r * (cos Œ∏ + sin Œ∏ * I)) = Œ∏ := by\n  simp only [arg, map_mul, abs_cos_add_sin_mul_I, abs_of_nonneg hr.le, mul_one]\n  simp only [re_ofReal_mul, im_ofReal_mul, neg_im, ‚Üê ofReal_cos, ‚Üê ofReal_sin, ‚Üê\n    mk_eq_add_mul_I, neg_div, mul_div_cancel_left‚ÇÄ _ hr.ne', mul_nonneg_iff_right_nonneg_of_pos hr]\n  by_cases h‚ÇÅ : Œ∏ ‚àà Set.Icc (-(œÄ / 2)) (œÄ / 2)\n  ¬∑ rw [if_pos]\n    exacts [Real.arcsin_sin' h‚ÇÅ, Real.cos_nonneg_of_mem_Icc h‚ÇÅ]\n  ¬∑ rw [Set.mem_Icc, not_and_or, not_le, not_le] at h‚ÇÅ\n    cases' h‚ÇÅ with h‚ÇÅ h‚ÇÅ\n    ¬∑ replace hŒ∏ := hŒ∏.1\n      have hcos : Real.cos Œ∏ < 0 := by\n        rw [‚Üê neg_pos, ‚Üê Real.cos_add_pi]\n        refine Real.cos_pos_of_mem_Ioo ‚ü®?_, ?_‚ü© <;> linarith\n      have hsin : Real.sin Œ∏ < 0 := Real.sin_neg_of_neg_of_neg_pi_lt (by linarith) hŒ∏\n      rw [if_neg, if_neg, ‚Üê Real.sin_add_pi, Real.arcsin_sin, add_sub_cancel_right] <;> [linarith;\n        linarith; exact hsin.not_le; exact hcos.not_le]\n    ¬∑ replace hŒ∏ := hŒ∏.2\n      have hcos : Real.cos Œ∏ < 0 := Real.cos_neg_of_pi_div_two_lt_of_lt h‚ÇÅ (by linarith)\n      have hsin : 0 ‚â§ Real.sin Œ∏ := Real.sin_nonneg_of_mem_Icc ‚ü®by linarith, hŒ∏‚ü©\n      rw [if_neg, if_pos, ‚Üê Real.sin_sub_pi, Real.arcsin_sin, sub_add_cancel] <;> [linarith;\n        linarith; exact hsin; exact hcos.not_le]\n\n"}
{"name":"Complex.arg_cos_add_sin_mul_I","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"Œ∏ : Real\nhŒ∏ : Membership.mem (Set.Ioc (Neg.neg Real.pi) Real.pi) Œ∏\n‚ä¢ Eq (HAdd.hAdd (Complex.cos ‚ÜëŒ∏) (HMul.hMul (Complex.sin ‚ÜëŒ∏) Complex.I)).arg Œ∏","decl":"theorem arg_cos_add_sin_mul_I {Œ∏ : ‚Ñù} (hŒ∏ : Œ∏ ‚àà Set.Ioc (-œÄ) œÄ) : arg (cos Œ∏ + sin Œ∏ * I) = Œ∏ := by\n  rw [‚Üê one_mul (_ + _), ‚Üê ofReal_one, arg_mul_cos_add_sin_mul_I zero_lt_one hŒ∏]\n\n"}
{"name":"Complex.arg_exp_mul_I","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"Œ∏ : Real\n‚ä¢ Eq (Complex.exp (HMul.hMul (‚ÜëŒ∏) Complex.I)).arg (toIocMod ‚ãØ (Neg.neg Real.pi) Œ∏)","decl":"lemma arg_exp_mul_I (Œ∏ : ‚Ñù) :\n    arg (exp (Œ∏ * I)) = toIocMod (mul_pos two_pos Real.pi_pos) (-œÄ) Œ∏ := by\n  convert arg_cos_add_sin_mul_I (Œ∏ := toIocMod (mul_pos two_pos Real.pi_pos) (-œÄ) Œ∏) _ using 2\n  ¬∑ rw [‚Üê exp_mul_I, eq_sub_of_add_eq <| toIocMod_add_toIocDiv_zsmul _ _ Œ∏, ofReal_sub,\n      ofReal_zsmul, ofReal_mul, ofReal_ofNat, exp_mul_I_periodic.sub_zsmul_eq]\n  ¬∑ convert toIocMod_mem_Ioc _ _ _\n    ring\n\n"}
{"name":"Complex.arg_zero","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"‚ä¢ Eq (Complex.arg 0) 0","decl":"@[simp]\ntheorem arg_zero : arg 0 = 0 := by simp [arg, le_refl]\n\n"}
{"name":"Complex.ext_abs_arg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x y : Complex\nh‚ÇÅ : Eq (Complex.abs x) (Complex.abs y)\nh‚ÇÇ : Eq x.arg y.arg\n‚ä¢ Eq x y","decl":"theorem ext_abs_arg {x y : ‚ÑÇ} (h‚ÇÅ : abs x = abs y) (h‚ÇÇ : x.arg = y.arg) : x = y := by\n  rw [‚Üê abs_mul_exp_arg_mul_I x, ‚Üê abs_mul_exp_arg_mul_I y, h‚ÇÅ, h‚ÇÇ]\n\n"}
{"name":"Complex.ext_abs_arg_iff","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x y : Complex\n‚ä¢ Iff (Eq x y) (And (Eq (Complex.abs x) (Complex.abs y)) (Eq x.arg y.arg))","decl":"theorem ext_abs_arg_iff {x y : ‚ÑÇ} : x = y ‚Üî abs x = abs y ‚àß arg x = arg y :=\n  ‚ü®fun h => h ‚ñ∏ ‚ü®rfl, rfl‚ü©, and_imp.2 ext_abs_arg‚ü©\n\n"}
{"name":"Complex.arg_mem_Ioc","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\n‚ä¢ Membership.mem (Set.Ioc (Neg.neg Real.pi) Real.pi) z.arg","decl":"theorem arg_mem_Ioc (z : ‚ÑÇ) : arg z ‚àà Set.Ioc (-œÄ) œÄ := by\n  have hœÄ : 0 < œÄ := Real.pi_pos\n  rcases eq_or_ne z 0 with (rfl | hz)\n  ¬∑ simp [hœÄ, hœÄ.le]\n  rcases existsUnique_add_zsmul_mem_Ioc Real.two_pi_pos (arg z) (-œÄ) with ‚ü®N, hN, -‚ü©\n  rw [two_mul, neg_add_cancel_left, ‚Üê two_mul, zsmul_eq_mul] at hN\n  rw [‚Üê abs_mul_cos_add_sin_mul_I z, ‚Üê cos_add_int_mul_two_pi _ N, ‚Üê sin_add_int_mul_two_pi _ N]\n  have := arg_mul_cos_add_sin_mul_I (abs.pos hz) hN\n  push_cast at this\n  rwa [this]\n\n"}
{"name":"Complex.range_arg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"‚ä¢ Eq (Set.range Complex.arg) (Set.Ioc (Neg.neg Real.pi) Real.pi)","decl":"@[simp]\ntheorem range_arg : Set.range arg = Set.Ioc (-œÄ) œÄ :=\n  (Set.range_subset_iff.2 arg_mem_Ioc).antisymm fun _ hx => ‚ü®_, arg_cos_add_sin_mul_I hx‚ü©\n\n"}
{"name":"Complex.arg_le_pi","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\n‚ä¢ LE.le x.arg Real.pi","decl":"theorem arg_le_pi (x : ‚ÑÇ) : arg x ‚â§ œÄ :=\n  (arg_mem_Ioc x).2\n\n"}
{"name":"Complex.neg_pi_lt_arg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\n‚ä¢ LT.lt (Neg.neg Real.pi) x.arg","decl":"theorem neg_pi_lt_arg (x : ‚ÑÇ) : -œÄ < arg x :=\n  (arg_mem_Ioc x).1\n\n"}
{"name":"Complex.abs_arg_le_pi","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\n‚ä¢ LE.le (abs z.arg) Real.pi","decl":"theorem abs_arg_le_pi (z : ‚ÑÇ) : |arg z| ‚â§ œÄ :=\n  abs_le.2 ‚ü®(neg_pi_lt_arg z).le, arg_le_pi z‚ü©\n\n"}
{"name":"Complex.arg_nonneg_iff","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\n‚ä¢ Iff (LE.le 0 z.arg) (LE.le 0 z.im)","decl":"@[simp]\ntheorem arg_nonneg_iff {z : ‚ÑÇ} : 0 ‚â§ arg z ‚Üî 0 ‚â§ z.im := by\n  rcases eq_or_ne z 0 with (rfl | h‚ÇÄ); ¬∑ simp\n  calc\n    0 ‚â§ arg z ‚Üî 0 ‚â§ Real.sin (arg z) :=\n      ‚ü®fun h => Real.sin_nonneg_of_mem_Icc ‚ü®h, arg_le_pi z‚ü©, by\n        contrapose!\n        intro h\n        exact Real.sin_neg_of_neg_of_neg_pi_lt h (neg_pi_lt_arg _)‚ü©\n    _ ‚Üî _ := by rw [sin_arg, le_div_iff‚ÇÄ (abs.pos h‚ÇÄ), zero_mul]\n\n"}
{"name":"Complex.arg_neg_iff","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\n‚ä¢ Iff (LT.lt z.arg 0) (LT.lt z.im 0)","decl":"@[simp]\ntheorem arg_neg_iff {z : ‚ÑÇ} : arg z < 0 ‚Üî z.im < 0 :=\n  lt_iff_lt_of_le_iff_le arg_nonneg_iff\n\n"}
{"name":"Complex.arg_real_mul","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\nr : Real\nhr : LT.lt 0 r\n‚ä¢ Eq (HMul.hMul (‚Üër) x).arg x.arg","decl":"theorem arg_real_mul (x : ‚ÑÇ) {r : ‚Ñù} (hr : 0 < r) : arg (r * x) = arg x := by\n  rcases eq_or_ne x 0 with (rfl | hx); ¬∑ rw [mul_zero]\n  conv_lhs =>\n    rw [‚Üê abs_mul_cos_add_sin_mul_I x, ‚Üê mul_assoc, ‚Üê ofReal_mul,\n      arg_mul_cos_add_sin_mul_I (mul_pos hr (abs.pos hx)) x.arg_mem_Ioc]\n\n"}
{"name":"Complex.arg_mul_real","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"r : Real\nhr : LT.lt 0 r\nx : Complex\n‚ä¢ Eq (HMul.hMul x ‚Üër).arg x.arg","decl":"theorem arg_mul_real {r : ‚Ñù} (hr : 0 < r) (x : ‚ÑÇ) : arg (x * r) = arg x :=\n  mul_comm x r ‚ñ∏ arg_real_mul x hr\n\n"}
{"name":"Complex.arg_eq_arg_iff","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x y : Complex\nhx : Ne x 0\nhy : Ne y 0\n‚ä¢ Iff (Eq x.arg y.arg) (Eq (HMul.hMul (HDiv.hDiv ‚Üë(Complex.abs y) ‚Üë(Complex.abs x)) x) y)","decl":"theorem arg_eq_arg_iff {x y : ‚ÑÇ} (hx : x ‚â† 0) (hy : y ‚â† 0) :\n    arg x = arg y ‚Üî (abs y / abs x : ‚ÑÇ) * x = y := by\n  simp only [ext_abs_arg_iff, map_mul, map_div‚ÇÄ, abs_ofReal, abs_abs,\n    div_mul_cancel‚ÇÄ _ (abs.ne_zero hx), eq_self_iff_true, true_and]\n  rw [‚Üê ofReal_div, arg_real_mul]\n  exact div_pos (abs.pos hy) (abs.pos hx)\n\n"}
{"name":"Complex.arg_one","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"‚ä¢ Eq (Complex.arg 1) 0","decl":"@[simp] lemma arg_one : arg 1 = 0 := by simp [arg, zero_le_one]\n\n"}
{"name":"Complex.arg_div_self","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\n‚ä¢ Eq (HDiv.hDiv x x).arg 0","decl":"/-- This holds true for all `x : ‚ÑÇ` because of the junk values `0 / 0 = 0` and `arg 0 = 0`. -/\n@[simp] lemma arg_div_self (x : ‚ÑÇ) : arg (x / x) = 0 := by\n  obtain rfl | hx := eq_or_ne x 0 <;> simp [*]\n\n"}
{"name":"Complex.arg_neg_one","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"‚ä¢ Eq (-1).arg Real.pi","decl":"@[simp]\ntheorem arg_neg_one : arg (-1) = œÄ := by simp [arg, le_refl, not_le.2 (zero_lt_one' ‚Ñù)]\n\n"}
{"name":"Complex.arg_I","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"‚ä¢ Eq Complex.I.arg (HDiv.hDiv Real.pi 2)","decl":"@[simp]\ntheorem arg_I : arg I = œÄ / 2 := by simp [arg, le_refl]\n\n"}
{"name":"Complex.arg_neg_I","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"‚ä¢ Eq (Neg.neg Complex.I).arg (Neg.neg (HDiv.hDiv Real.pi 2))","decl":"@[simp]\ntheorem arg_neg_I : arg (-I) = -(œÄ / 2) := by simp [arg, le_refl]\n\n"}
{"name":"Complex.tan_arg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\n‚ä¢ Eq (Real.tan x.arg) (HDiv.hDiv x.im x.re)","decl":"@[simp]\ntheorem tan_arg (x : ‚ÑÇ) : Real.tan (arg x) = x.im / x.re := by\n  by_cases h : x = 0\n  ¬∑ simp only [h, zero_div, Complex.zero_im, Complex.arg_zero, Real.tan_zero, Complex.zero_re]\n  rw [Real.tan_eq_sin_div_cos, sin_arg, cos_arg h, div_div_div_cancel_right‚ÇÄ (abs.ne_zero h)]\n\n"}
{"name":"Complex.arg_ofReal_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Real\nhx : LE.le 0 x\n‚ä¢ Eq (‚Üëx).arg 0","decl":"theorem arg_ofReal_of_nonneg {x : ‚Ñù} (hx : 0 ‚â§ x) : arg x = 0 := by simp [arg, hx]\n\n"}
{"name":"Complex.natCast_arg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"n : Nat\n‚ä¢ Eq (‚Üën).arg 0","decl":"@[simp, norm_cast]\nlemma natCast_arg {n : ‚Ñï} : arg n = 0 :=\n  ofReal_natCast n ‚ñ∏ arg_ofReal_of_nonneg n.cast_nonneg\n\n"}
{"name":"Complex.ofNat_arg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"n : Nat\ninst‚úù : n.AtLeastTwo\n‚ä¢ Eq (OfNat.ofNat n).arg 0","decl":"@[simp]\nlemma ofNat_arg {n : ‚Ñï} [n.AtLeastTwo] : arg ofNat(n) = 0 :=\n  natCast_arg\n\n"}
{"name":"Complex.arg_eq_zero_iff","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\n‚ä¢ Iff (Eq z.arg 0) (And (LE.le 0 z.re) (Eq z.im 0))","decl":"theorem arg_eq_zero_iff {z : ‚ÑÇ} : arg z = 0 ‚Üî 0 ‚â§ z.re ‚àß z.im = 0 := by\n  refine ‚ü®fun h => ?_, ?_‚ü©\n  ¬∑ rw [‚Üê abs_mul_cos_add_sin_mul_I z, h]\n    simp [abs.nonneg]\n  ¬∑ cases' z with x y\n    rintro ‚ü®h, rfl : y = 0‚ü©\n    exact arg_ofReal_of_nonneg h\n\n"}
{"name":"Complex.arg_eq_zero_iff_zero_le","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\n‚ä¢ Iff (Eq z.arg 0) (LE.le 0 z)","decl":"open ComplexOrder in\nlemma arg_eq_zero_iff_zero_le {z : ‚ÑÇ} : arg z = 0 ‚Üî 0 ‚â§ z := by\n  rw [arg_eq_zero_iff, eq_comm, nonneg_iff]\n\n"}
{"name":"Complex.arg_eq_pi_iff","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\n‚ä¢ Iff (Eq z.arg Real.pi) (And (LT.lt z.re 0) (Eq z.im 0))","decl":"theorem arg_eq_pi_iff {z : ‚ÑÇ} : arg z = œÄ ‚Üî z.re < 0 ‚àß z.im = 0 := by\n  by_cases h‚ÇÄ : z = 0\n  ¬∑ simp [h‚ÇÄ, lt_irrefl, Real.pi_ne_zero.symm]\n  constructor\n  ¬∑ intro h\n    rw [‚Üê abs_mul_cos_add_sin_mul_I z, h]\n    simp [h‚ÇÄ]\n  ¬∑ cases' z with x y\n    rintro ‚ü®h : x < 0, rfl : y = 0‚ü©\n    rw [‚Üê arg_neg_one, ‚Üê arg_real_mul (-1) (neg_pos.2 h)]\n    simp [‚Üê ofReal_def]\n\n"}
{"name":"Complex.arg_eq_pi_iff_lt_zero","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\n‚ä¢ Iff (Eq z.arg Real.pi) (LT.lt z 0)","decl":"open ComplexOrder in\nlemma arg_eq_pi_iff_lt_zero {z : ‚ÑÇ} : arg z = œÄ ‚Üî z < 0 := arg_eq_pi_iff\n\n"}
{"name":"Complex.arg_lt_pi_iff","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\n‚ä¢ Iff (LT.lt z.arg Real.pi) (Or (LE.le 0 z.re) (Ne z.im 0))","decl":"theorem arg_lt_pi_iff {z : ‚ÑÇ} : arg z < œÄ ‚Üî 0 ‚â§ z.re ‚à® z.im ‚â† 0 := by\n  rw [(arg_le_pi z).lt_iff_ne, not_iff_comm, not_or, not_le, Classical.not_not, arg_eq_pi_iff]\n\n"}
{"name":"Complex.arg_ofReal_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Real\nhx : LT.lt x 0\n‚ä¢ Eq (‚Üëx).arg Real.pi","decl":"theorem arg_ofReal_of_neg {x : ‚Ñù} (hx : x < 0) : arg x = œÄ :=\n  arg_eq_pi_iff.2 ‚ü®hx, rfl‚ü©\n\n"}
{"name":"Complex.arg_eq_pi_div_two_iff","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\n‚ä¢ Iff (Eq z.arg (HDiv.hDiv Real.pi 2)) (And (Eq z.re 0) (LT.lt 0 z.im))","decl":"theorem arg_eq_pi_div_two_iff {z : ‚ÑÇ} : arg z = œÄ / 2 ‚Üî z.re = 0 ‚àß 0 < z.im := by\n  by_cases h‚ÇÄ : z = 0; ¬∑ simp [h‚ÇÄ, lt_irrefl, Real.pi_div_two_pos.ne]\n  constructor\n  ¬∑ intro h\n    rw [‚Üê abs_mul_cos_add_sin_mul_I z, h]\n    simp [h‚ÇÄ]\n  ¬∑ cases' z with x y\n    rintro ‚ü®rfl : x = 0, hy : 0 < y‚ü©\n    rw [‚Üê arg_I, ‚Üê arg_real_mul I hy, ofReal_mul', I_re, I_im, mul_zero, mul_one]\n\n"}
{"name":"Complex.arg_eq_neg_pi_div_two_iff","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\n‚ä¢ Iff (Eq z.arg (Neg.neg (HDiv.hDiv Real.pi 2))) (And (Eq z.re 0) (LT.lt z.im 0))","decl":"theorem arg_eq_neg_pi_div_two_iff {z : ‚ÑÇ} : arg z = -(œÄ / 2) ‚Üî z.re = 0 ‚àß z.im < 0 := by\n  by_cases h‚ÇÄ : z = 0; ¬∑ simp [h‚ÇÄ, lt_irrefl, Real.pi_ne_zero]\n  constructor\n  ¬∑ intro h\n    rw [‚Üê abs_mul_cos_add_sin_mul_I z, h]\n    simp [h‚ÇÄ]\n  ¬∑ cases' z with x y\n    rintro ‚ü®rfl : x = 0, hy : y < 0‚ü©\n    rw [‚Üê arg_neg_I, ‚Üê arg_real_mul (-I) (neg_pos.2 hy), mk_eq_add_mul_I]\n    simp\n\n"}
{"name":"Complex.arg_of_re_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\nhx : LE.le 0 x.re\n‚ä¢ Eq x.arg (Real.arcsin (HDiv.hDiv x.im (Complex.abs x)))","decl":"theorem arg_of_re_nonneg {x : ‚ÑÇ} (hx : 0 ‚â§ x.re) : arg x = Real.arcsin (x.im / abs x) :=\n  if_pos hx\n\n"}
{"name":"Complex.arg_of_re_neg_of_im_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\nhx_re : LT.lt x.re 0\nhx_im : LE.le 0 x.im\n‚ä¢ Eq x.arg (HAdd.hAdd (Real.arcsin (HDiv.hDiv (Neg.neg x).im (Complex.abs x))) Real.pi)","decl":"theorem arg_of_re_neg_of_im_nonneg {x : ‚ÑÇ} (hx_re : x.re < 0) (hx_im : 0 ‚â§ x.im) :\n    arg x = Real.arcsin ((-x).im / abs x) + œÄ := by\n  simp only [arg, hx_re.not_le, hx_im, if_true, if_false]\n\n"}
{"name":"Complex.arg_of_re_neg_of_im_neg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\nhx_re : LT.lt x.re 0\nhx_im : LT.lt x.im 0\n‚ä¢ Eq x.arg (HSub.hSub (Real.arcsin (HDiv.hDiv (Neg.neg x).im (Complex.abs x))) Real.pi)","decl":"theorem arg_of_re_neg_of_im_neg {x : ‚ÑÇ} (hx_re : x.re < 0) (hx_im : x.im < 0) :\n    arg x = Real.arcsin ((-x).im / abs x) - œÄ := by\n  simp only [arg, hx_re.not_le, hx_im.not_le, if_false]\n\n"}
{"name":"Complex.arg_of_im_nonneg_of_ne_zero","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\nh‚ÇÅ : LE.le 0 z.im\nh‚ÇÇ : Ne z 0\n‚ä¢ Eq z.arg (Real.arccos (HDiv.hDiv z.re (Complex.abs z)))","decl":"theorem arg_of_im_nonneg_of_ne_zero {z : ‚ÑÇ} (h‚ÇÅ : 0 ‚â§ z.im) (h‚ÇÇ : z ‚â† 0) :\n    arg z = Real.arccos (z.re / abs z) := by\n  rw [‚Üê cos_arg h‚ÇÇ, Real.arccos_cos (arg_nonneg_iff.2 h‚ÇÅ) (arg_le_pi _)]\n\n"}
{"name":"Complex.arg_of_im_pos","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\nhz : LT.lt 0 z.im\n‚ä¢ Eq z.arg (Real.arccos (HDiv.hDiv z.re (Complex.abs z)))","decl":"theorem arg_of_im_pos {z : ‚ÑÇ} (hz : 0 < z.im) : arg z = Real.arccos (z.re / abs z) :=\n  arg_of_im_nonneg_of_ne_zero hz.le fun h => hz.ne' <| h.symm ‚ñ∏ rfl\n\n"}
{"name":"Complex.arg_of_im_neg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\nhz : LT.lt z.im 0\n‚ä¢ Eq z.arg (Neg.neg (Real.arccos (HDiv.hDiv z.re (Complex.abs z))))","decl":"theorem arg_of_im_neg {z : ‚ÑÇ} (hz : z.im < 0) : arg z = -Real.arccos (z.re / abs z) := by\n  have h‚ÇÄ : z ‚â† 0 := mt (congr_arg im) hz.ne\n  rw [‚Üê cos_arg h‚ÇÄ, ‚Üê Real.cos_neg, Real.arccos_cos, neg_neg]\n  exacts [neg_nonneg.2 (arg_neg_iff.2 hz).le, neg_le.2 (neg_pi_lt_arg z).le]\n\n"}
{"name":"Complex.arg_conj","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\n‚ä¢ Eq ((starRingEnd Complex) x).arg (ite (Eq x.arg Real.pi) Real.pi (Neg.neg x.arg))","decl":"theorem arg_conj (x : ‚ÑÇ) : arg (conj x) = if arg x = œÄ then œÄ else -arg x := by\n  simp_rw [arg_eq_pi_iff, arg, neg_im, conj_im, conj_re, abs_conj, neg_div, neg_neg,\n    Real.arcsin_neg]\n  rcases lt_trichotomy x.re 0 with (hr | hr | hr) <;>\n    rcases lt_trichotomy x.im 0 with (hi | hi | hi)\n  ¬∑ simp [hr, hr.not_le, hi.le, hi.ne, not_le.2 hi, add_comm]\n  ¬∑ simp [hr, hr.not_le, hi]\n  ¬∑ simp [hr, hr.not_le, hi.ne.symm, hi.le, not_le.2 hi, sub_eq_neg_add]\n  ¬∑ simp [hr]\n  ¬∑ simp [hr]\n  ¬∑ simp [hr]\n  ¬∑ simp [hr, hr.le, hi.ne]\n  ¬∑ simp [hr, hr.le, hr.le.not_lt]\n  ¬∑ simp [hr, hr.le, hr.le.not_lt]\n\n"}
{"name":"Complex.arg_inv","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\n‚ä¢ Eq (Inv.inv x).arg (ite (Eq x.arg Real.pi) Real.pi (Neg.neg x.arg))","decl":"theorem arg_inv (x : ‚ÑÇ) : arg x‚Åª¬π = if arg x = œÄ then œÄ else -arg x := by\n  rw [‚Üê arg_conj, inv_def, mul_comm]\n  by_cases hx : x = 0\n  ¬∑ simp [hx]\n  ¬∑ exact arg_real_mul (conj x) (by simp [hx])\n\n"}
{"name":"Complex.abs_arg_inv","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\n‚ä¢ Eq (abs (Inv.inv x).arg) (abs x.arg)","decl":"@[simp] lemma abs_arg_inv (x : ‚ÑÇ) : |x‚Åª¬π.arg| = |x.arg| := by rw [arg_inv]; split_ifs <;> simp [*]\n\n-- TODO: Replace the next two lemmas by general facts about periodic functions\n"}
{"name":"Complex.abs_eq_one_iff'","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\n‚ä¢ Iff (Eq (Complex.abs x) 1) (Exists fun Œ∏ => And (Membership.mem (Set.Ioc (Neg.neg Real.pi) Real.pi) Œ∏) (Eq (Complex.exp (HMul.hMul (‚ÜëŒ∏) Complex.I)) x))","decl":"lemma abs_eq_one_iff' : abs x = 1 ‚Üî ‚àÉ Œ∏ ‚àà Set.Ioc (-œÄ) œÄ, exp (Œ∏ * I) = x := by\n  rw [abs_eq_one_iff]\n  constructor\n  ¬∑ rintro ‚ü®Œ∏, rfl‚ü©\n    refine ‚ü®toIocMod (mul_pos two_pos Real.pi_pos) (-œÄ) Œ∏, ?_, ?_‚ü©\n    ¬∑ convert toIocMod_mem_Ioc _ _ _\n      ring\n    ¬∑ rw [eq_sub_of_add_eq <| toIocMod_add_toIocDiv_zsmul _ _ Œ∏, ofReal_sub,\n      ofReal_zsmul, ofReal_mul, ofReal_ofNat, exp_mul_I_periodic.sub_zsmul_eq]\n  ¬∑ rintro ‚ü®Œ∏, _, rfl‚ü©\n    exact ‚ü®Œ∏, rfl‚ü©\n\n"}
{"name":"Complex.image_exp_Ioc_eq_sphere","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"‚ä¢ Eq (Set.image (fun Œ∏ => Complex.exp (HMul.hMul (‚ÜëŒ∏) Complex.I)) (Set.Ioc (Neg.neg Real.pi) Real.pi)) (Metric.sphere 0 1)","decl":"lemma image_exp_Ioc_eq_sphere : (fun Œ∏ : ‚Ñù ‚Ü¶ exp (Œ∏ * I)) '' Set.Ioc (-œÄ) œÄ = sphere 0 1 := by\n  ext; simpa using abs_eq_one_iff'.symm\n\n"}
{"name":"Complex.arg_le_pi_div_two_iff","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\n‚ä¢ Iff (LE.le z.arg (HDiv.hDiv Real.pi 2)) (Or (LE.le 0 z.re) (LT.lt z.im 0))","decl":"theorem arg_le_pi_div_two_iff {z : ‚ÑÇ} : arg z ‚â§ œÄ / 2 ‚Üî 0 ‚â§ re z ‚à® im z < 0 := by\n  rcases le_or_lt 0 (re z) with hre | hre\n  ¬∑ simp only [hre, arg_of_re_nonneg hre, Real.arcsin_le_pi_div_two, true_or]\n  simp only [hre.not_le, false_or]\n  rcases le_or_lt 0 (im z) with him | him\n  ¬∑ simp only [him.not_lt]\n    rw [iff_false, not_le, arg_of_re_neg_of_im_nonneg hre him, ‚Üê sub_lt_iff_lt_add, half_sub,\n      Real.neg_pi_div_two_lt_arcsin, neg_im, neg_div, neg_lt_neg_iff, div_lt_one, ‚Üê\n      _root_.abs_of_nonneg him, abs_im_lt_abs]\n    exacts [hre.ne, abs.pos <| ne_of_apply_ne re hre.ne]\n  ¬∑ simp only [him]\n    rw [iff_true, arg_of_re_neg_of_im_neg hre him]\n    exact (sub_le_self _ Real.pi_pos.le).trans (Real.arcsin_le_pi_div_two _)\n\n"}
{"name":"Complex.neg_pi_div_two_le_arg_iff","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\n‚ä¢ Iff (LE.le (Neg.neg (HDiv.hDiv Real.pi 2)) z.arg) (Or (LE.le 0 z.re) (LE.le 0 z.im))","decl":"theorem neg_pi_div_two_le_arg_iff {z : ‚ÑÇ} : -(œÄ / 2) ‚â§ arg z ‚Üî 0 ‚â§ re z ‚à® 0 ‚â§ im z := by\n  rcases le_or_lt 0 (re z) with hre | hre\n  ¬∑ simp only [hre, arg_of_re_nonneg hre, Real.neg_pi_div_two_le_arcsin, true_or]\n  simp only [hre.not_le, false_or]\n  rcases le_or_lt 0 (im z) with him | him\n  ¬∑ simp only [him]\n    rw [iff_true, arg_of_re_neg_of_im_nonneg hre him]\n    exact (Real.neg_pi_div_two_le_arcsin _).trans (le_add_of_nonneg_right Real.pi_pos.le)\n  ¬∑ simp only [him.not_le]\n    rw [iff_false, not_le, arg_of_re_neg_of_im_neg hre him, sub_lt_iff_lt_add', ‚Üê\n      sub_eq_add_neg, sub_half, Real.arcsin_lt_pi_div_two, div_lt_one, neg_im, ‚Üê abs_of_neg him,\n      abs_im_lt_abs]\n    exacts [hre.ne, abs.pos <| ne_of_apply_ne re hre.ne]\n\n"}
{"name":"Complex.neg_pi_div_two_lt_arg_iff","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\n‚ä¢ Iff (LT.lt (Neg.neg (HDiv.hDiv Real.pi 2)) z.arg) (Or (LT.lt 0 z.re) (LE.le 0 z.im))","decl":"lemma neg_pi_div_two_lt_arg_iff {z : ‚ÑÇ} : -(œÄ / 2) < arg z ‚Üî 0 < re z ‚à® 0 ‚â§ im z := by\n  rw [lt_iff_le_and_ne, neg_pi_div_two_le_arg_iff, ne_comm, Ne, arg_eq_neg_pi_div_two_iff]\n  rcases lt_trichotomy z.re 0 with hre | hre | hre\n  ¬∑ simp [hre.ne, hre.not_le, hre.not_lt]\n  ¬∑ simp [hre]\n  ¬∑ simp [hre, hre.le, hre.ne']\n\n"}
{"name":"Complex.arg_lt_pi_div_two_iff","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\n‚ä¢ Iff (LT.lt z.arg (HDiv.hDiv Real.pi 2)) (Or (LT.lt 0 z.re) (Or (LT.lt z.im 0) (Eq z 0)))","decl":"lemma arg_lt_pi_div_two_iff {z : ‚ÑÇ} : arg z < œÄ / 2 ‚Üî 0 < re z ‚à® im z < 0 ‚à® z = 0 := by\n  rw [lt_iff_le_and_ne, arg_le_pi_div_two_iff, Ne, arg_eq_pi_div_two_iff]\n  rcases lt_trichotomy z.re 0 with hre | hre | hre\n  ¬∑ have : z ‚â† 0 := by simp [Complex.ext_iff, hre.ne]\n    simp [hre.ne, hre.not_le, hre.not_lt, this]\n  ¬∑ have : z = 0 ‚Üî z.im = 0 := by simp [Complex.ext_iff, hre]\n    simp [hre, this, or_comm, le_iff_eq_or_lt]\n  ¬∑ simp [hre, hre.le, hre.ne']\n\n"}
{"name":"Complex.abs_arg_le_pi_div_two_iff","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\n‚ä¢ Iff (LE.le (abs z.arg) (HDiv.hDiv Real.pi 2)) (LE.le 0 z.re)","decl":"@[simp]\ntheorem abs_arg_le_pi_div_two_iff {z : ‚ÑÇ} : |arg z| ‚â§ œÄ / 2 ‚Üî 0 ‚â§ re z := by\n  rw [abs_le, arg_le_pi_div_two_iff, neg_pi_div_two_le_arg_iff, ‚Üê or_and_left, ‚Üê not_le,\n    and_not_self_iff, or_false]\n\n"}
{"name":"Complex.abs_arg_lt_pi_div_two_iff","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\n‚ä¢ Iff (LT.lt (abs z.arg) (HDiv.hDiv Real.pi 2)) (Or (LT.lt 0 z.re) (Eq z 0))","decl":"@[simp]\ntheorem abs_arg_lt_pi_div_two_iff {z : ‚ÑÇ} : |arg z| < œÄ / 2 ‚Üî 0 < re z ‚à® z = 0 := by\n  rw [abs_lt, arg_lt_pi_div_two_iff, neg_pi_div_two_lt_arg_iff, ‚Üê or_and_left]\n  rcases eq_or_ne z 0 with hz | hz\n  ¬∑ simp [hz]\n  ¬∑ simp_rw [hz, or_false, ‚Üê not_lt, not_and_self_iff, or_false]\n\n"}
{"name":"Complex.arg_conj_coe_angle","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\n‚ä¢ Eq (‚Üë((starRingEnd Complex) x).arg) (Neg.neg ‚Üëx.arg)","decl":"@[simp]\ntheorem arg_conj_coe_angle (x : ‚ÑÇ) : (arg (conj x) : Real.Angle) = -arg x := by\n  by_cases h : arg x = œÄ <;> simp [arg_conj, h]\n\n"}
{"name":"Complex.arg_inv_coe_angle","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\n‚ä¢ Eq (‚Üë(Inv.inv x).arg) (Neg.neg ‚Üëx.arg)","decl":"@[simp]\ntheorem arg_inv_coe_angle (x : ‚ÑÇ) : (arg x‚Åª¬π : Real.Angle) = -arg x := by\n  by_cases h : arg x = œÄ <;> simp [arg_inv, h]\n\n"}
{"name":"Complex.arg_neg_eq_arg_sub_pi_of_im_pos","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\nhi : LT.lt 0 x.im\n‚ä¢ Eq (Neg.neg x).arg (HSub.hSub x.arg Real.pi)","decl":"theorem arg_neg_eq_arg_sub_pi_of_im_pos {x : ‚ÑÇ} (hi : 0 < x.im) : arg (-x) = arg x - œÄ := by\n  rw [arg_of_im_pos hi, arg_of_im_neg (show (-x).im < 0 from Left.neg_neg_iff.2 hi)]\n  simp [neg_div, Real.arccos_neg]\n\n"}
{"name":"Complex.arg_neg_eq_arg_add_pi_of_im_neg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\nhi : LT.lt x.im 0\n‚ä¢ Eq (Neg.neg x).arg (HAdd.hAdd x.arg Real.pi)","decl":"theorem arg_neg_eq_arg_add_pi_of_im_neg {x : ‚ÑÇ} (hi : x.im < 0) : arg (-x) = arg x + œÄ := by\n  rw [arg_of_im_neg hi, arg_of_im_pos (show 0 < (-x).im from Left.neg_pos_iff.2 hi)]\n  simp [neg_div, Real.arccos_neg, add_comm, ‚Üê sub_eq_add_neg]\n\n"}
{"name":"Complex.arg_neg_eq_arg_sub_pi_iff","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\n‚ä¢ Iff (Eq (Neg.neg x).arg (HSub.hSub x.arg Real.pi)) (Or (LT.lt 0 x.im) (And (Eq x.im 0) (LT.lt x.re 0)))","decl":"theorem arg_neg_eq_arg_sub_pi_iff {x : ‚ÑÇ} :\n    arg (-x) = arg x - œÄ ‚Üî 0 < x.im ‚à® x.im = 0 ‚àß x.re < 0 := by\n  rcases lt_trichotomy x.im 0 with (hi | hi | hi)\n  ¬∑ simp [hi, hi.ne, hi.not_lt, arg_neg_eq_arg_add_pi_of_im_neg, sub_eq_add_neg, ‚Üê\n      add_eq_zero_iff_eq_neg, Real.pi_ne_zero]\n  ¬∑ rw [(ext rfl hi : x = x.re)]\n    rcases lt_trichotomy x.re 0 with (hr | hr | hr)\n    ¬∑ rw [arg_ofReal_of_neg hr, ‚Üê ofReal_neg, arg_ofReal_of_nonneg (Left.neg_pos_iff.2 hr).le]\n      simp [hr]\n    ¬∑ simp [hr, hi, Real.pi_ne_zero]\n    ¬∑ rw [arg_ofReal_of_nonneg hr.le, ‚Üê ofReal_neg, arg_ofReal_of_neg (Left.neg_neg_iff.2 hr)]\n      simp [hr.not_lt, ‚Üê add_eq_zero_iff_eq_neg, Real.pi_ne_zero]\n  ¬∑ simp [hi, arg_neg_eq_arg_sub_pi_of_im_pos]\n\n"}
{"name":"Complex.arg_neg_eq_arg_add_pi_iff","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\n‚ä¢ Iff (Eq (Neg.neg x).arg (HAdd.hAdd x.arg Real.pi)) (Or (LT.lt x.im 0) (And (Eq x.im 0) (LT.lt 0 x.re)))","decl":"theorem arg_neg_eq_arg_add_pi_iff {x : ‚ÑÇ} :\n    arg (-x) = arg x + œÄ ‚Üî x.im < 0 ‚à® x.im = 0 ‚àß 0 < x.re := by\n  rcases lt_trichotomy x.im 0 with (hi | hi | hi)\n  ¬∑ simp [hi, arg_neg_eq_arg_add_pi_of_im_neg]\n  ¬∑ rw [(ext rfl hi : x = x.re)]\n    rcases lt_trichotomy x.re 0 with (hr | hr | hr)\n    ¬∑ rw [arg_ofReal_of_neg hr, ‚Üê ofReal_neg, arg_ofReal_of_nonneg (Left.neg_pos_iff.2 hr).le]\n      simp [hr.not_lt, ‚Üê two_mul, Real.pi_ne_zero]\n    ¬∑ simp [hr, hi, Real.pi_ne_zero.symm]\n    ¬∑ rw [arg_ofReal_of_nonneg hr.le, ‚Üê ofReal_neg, arg_ofReal_of_neg (Left.neg_neg_iff.2 hr)]\n      simp [hr]\n  ¬∑ simp [hi, hi.ne.symm, hi.not_lt, arg_neg_eq_arg_sub_pi_of_im_pos, sub_eq_add_neg, ‚Üê\n      add_eq_zero_iff_neg_eq, Real.pi_ne_zero]\n\n"}
{"name":"Complex.arg_neg_coe_angle","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\nhx : Ne x 0\n‚ä¢ Eq (‚Üë(Neg.neg x).arg) (HAdd.hAdd ‚Üëx.arg ‚ÜëReal.pi)","decl":"theorem arg_neg_coe_angle {x : ‚ÑÇ} (hx : x ‚â† 0) : (arg (-x) : Real.Angle) = arg x + œÄ := by\n  rcases lt_trichotomy x.im 0 with (hi | hi | hi)\n  ¬∑ rw [arg_neg_eq_arg_add_pi_of_im_neg hi, Real.Angle.coe_add]\n  ¬∑ rw [(ext rfl hi : x = x.re)]\n    rcases lt_trichotomy x.re 0 with (hr | hr | hr)\n    ¬∑ rw [arg_ofReal_of_neg hr, ‚Üê ofReal_neg, arg_ofReal_of_nonneg (Left.neg_pos_iff.2 hr).le, ‚Üê\n        Real.Angle.coe_add, ‚Üê two_mul, Real.Angle.coe_two_pi, Real.Angle.coe_zero]\n    ¬∑ exact False.elim (hx (ext hr hi))\n    ¬∑ rw [arg_ofReal_of_nonneg hr.le, ‚Üê ofReal_neg, arg_ofReal_of_neg (Left.neg_neg_iff.2 hr),\n        Real.Angle.coe_zero, zero_add]\n  ¬∑ rw [arg_neg_eq_arg_sub_pi_of_im_pos hi, Real.Angle.coe_sub, Real.Angle.sub_coe_pi_eq_add_coe_pi]\n\n"}
{"name":"Complex.arg_mul_cos_add_sin_mul_I_eq_toIocMod","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"r : Real\nhr : LT.lt 0 r\nŒ∏ : Real\n‚ä¢ Eq (HMul.hMul (‚Üër) (HAdd.hAdd (Complex.cos ‚ÜëŒ∏) (HMul.hMul (Complex.sin ‚ÜëŒ∏) Complex.I))).arg (toIocMod Real.two_pi_pos (Neg.neg Real.pi) Œ∏)","decl":"theorem arg_mul_cos_add_sin_mul_I_eq_toIocMod {r : ‚Ñù} (hr : 0 < r) (Œ∏ : ‚Ñù) :\n    arg (r * (cos Œ∏ + sin Œ∏ * I)) = toIocMod Real.two_pi_pos (-œÄ) Œ∏ := by\n  have hi : toIocMod Real.two_pi_pos (-œÄ) Œ∏ ‚àà Set.Ioc (-œÄ) œÄ := by\n    convert toIocMod_mem_Ioc _ _ Œ∏\n    ring\n  convert arg_mul_cos_add_sin_mul_I hr hi using 3\n  simp [toIocMod, cos_sub_int_mul_two_pi, sin_sub_int_mul_two_pi]\n\n"}
{"name":"Complex.arg_cos_add_sin_mul_I_eq_toIocMod","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"Œ∏ : Real\n‚ä¢ Eq (HAdd.hAdd (Complex.cos ‚ÜëŒ∏) (HMul.hMul (Complex.sin ‚ÜëŒ∏) Complex.I)).arg (toIocMod Real.two_pi_pos (Neg.neg Real.pi) Œ∏)","decl":"theorem arg_cos_add_sin_mul_I_eq_toIocMod (Œ∏ : ‚Ñù) :\n    arg (cos Œ∏ + sin Œ∏ * I) = toIocMod Real.two_pi_pos (-œÄ) Œ∏ := by\n  rw [‚Üê one_mul (_ + _), ‚Üê ofReal_one, arg_mul_cos_add_sin_mul_I_eq_toIocMod zero_lt_one]\n\n"}
{"name":"Complex.arg_mul_cos_add_sin_mul_I_sub","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"r : Real\nhr : LT.lt 0 r\nŒ∏ : Real\n‚ä¢ Eq (HSub.hSub (HMul.hMul (‚Üër) (HAdd.hAdd (Complex.cos ‚ÜëŒ∏) (HMul.hMul (Complex.sin ‚ÜëŒ∏) Complex.I))).arg Œ∏) (HMul.hMul (HMul.hMul 2 Real.pi) ‚Üë(Int.floor (HDiv.hDiv (HSub.hSub Real.pi Œ∏) (HMul.hMul 2 Real.pi))))","decl":"theorem arg_mul_cos_add_sin_mul_I_sub {r : ‚Ñù} (hr : 0 < r) (Œ∏ : ‚Ñù) :\n    arg (r * (cos Œ∏ + sin Œ∏ * I)) - Œ∏ = 2 * œÄ * ‚åä(œÄ - Œ∏) / (2 * œÄ)‚åã := by\n  rw [arg_mul_cos_add_sin_mul_I_eq_toIocMod hr, toIocMod_sub_self, toIocDiv_eq_neg_floor,\n    zsmul_eq_mul]\n  ring_nf\n\n"}
{"name":"Complex.arg_cos_add_sin_mul_I_sub","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"Œ∏ : Real\n‚ä¢ Eq (HSub.hSub (HAdd.hAdd (Complex.cos ‚ÜëŒ∏) (HMul.hMul (Complex.sin ‚ÜëŒ∏) Complex.I)).arg Œ∏) (HMul.hMul (HMul.hMul 2 Real.pi) ‚Üë(Int.floor (HDiv.hDiv (HSub.hSub Real.pi Œ∏) (HMul.hMul 2 Real.pi))))","decl":"theorem arg_cos_add_sin_mul_I_sub (Œ∏ : ‚Ñù) :\n    arg (cos Œ∏ + sin Œ∏ * I) - Œ∏ = 2 * œÄ * ‚åä(œÄ - Œ∏) / (2 * œÄ)‚åã := by\n  rw [‚Üê one_mul (_ + _), ‚Üê ofReal_one, arg_mul_cos_add_sin_mul_I_sub zero_lt_one]\n\n"}
{"name":"Complex.arg_mul_cos_add_sin_mul_I_coe_angle","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"r : Real\nhr : LT.lt 0 r\nŒ∏ : Real.Angle\n‚ä¢ Eq (‚Üë(HMul.hMul (‚Üër) (HAdd.hAdd (‚ÜëŒ∏.cos) (HMul.hMul (‚ÜëŒ∏.sin) Complex.I))).arg) Œ∏","decl":"theorem arg_mul_cos_add_sin_mul_I_coe_angle {r : ‚Ñù} (hr : 0 < r) (Œ∏ : Real.Angle) :\n    (arg (r * (Real.Angle.cos Œ∏ + Real.Angle.sin Œ∏ * I)) : Real.Angle) = Œ∏ := by\n  induction' Œ∏ using Real.Angle.induction_on with Œ∏\n  rw [Real.Angle.cos_coe, Real.Angle.sin_coe, Real.Angle.angle_eq_iff_two_pi_dvd_sub]\n  use ‚åä(œÄ - Œ∏) / (2 * œÄ)‚åã\n  exact mod_cast arg_mul_cos_add_sin_mul_I_sub hr Œ∏\n\n"}
{"name":"Complex.arg_cos_add_sin_mul_I_coe_angle","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"Œ∏ : Real.Angle\n‚ä¢ Eq (‚Üë(HAdd.hAdd (‚ÜëŒ∏.cos) (HMul.hMul (‚ÜëŒ∏.sin) Complex.I)).arg) Œ∏","decl":"theorem arg_cos_add_sin_mul_I_coe_angle (Œ∏ : Real.Angle) :\n    (arg (Real.Angle.cos Œ∏ + Real.Angle.sin Œ∏ * I) : Real.Angle) = Œ∏ := by\n  rw [‚Üê one_mul (_ + _), ‚Üê ofReal_one, arg_mul_cos_add_sin_mul_I_coe_angle zero_lt_one]\n\n"}
{"name":"Complex.arg_mul_coe_angle","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x y : Complex\nhx : Ne x 0\nhy : Ne y 0\n‚ä¢ Eq (‚Üë(HMul.hMul x y).arg) (HAdd.hAdd ‚Üëx.arg ‚Üëy.arg)","decl":"theorem arg_mul_coe_angle {x y : ‚ÑÇ} (hx : x ‚â† 0) (hy : y ‚â† 0) :\n    (arg (x * y) : Real.Angle) = arg x + arg y := by\n  convert arg_mul_cos_add_sin_mul_I_coe_angle (mul_pos (abs.pos hx) (abs.pos hy))\n      (arg x + arg y : Real.Angle) using\n    3\n  simp_rw [‚Üê Real.Angle.coe_add, Real.Angle.sin_coe, Real.Angle.cos_coe, ofReal_cos, ofReal_sin,\n    cos_add_sin_I, ofReal_add, add_mul, exp_add, ofReal_mul]\n  rw [mul_assoc, mul_comm (exp _), ‚Üê mul_assoc (abs y : ‚ÑÇ), abs_mul_exp_arg_mul_I, mul_comm y, ‚Üê\n    mul_assoc, abs_mul_exp_arg_mul_I]\n\n"}
{"name":"Complex.arg_div_coe_angle","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x y : Complex\nhx : Ne x 0\nhy : Ne y 0\n‚ä¢ Eq (‚Üë(HDiv.hDiv x y).arg) (HSub.hSub ‚Üëx.arg ‚Üëy.arg)","decl":"theorem arg_div_coe_angle {x y : ‚ÑÇ} (hx : x ‚â† 0) (hy : y ‚â† 0) :\n    (arg (x / y) : Real.Angle) = arg x - arg y := by\n  rw [div_eq_mul_inv, arg_mul_coe_angle hx (inv_ne_zero hy), arg_inv_coe_angle, sub_eq_add_neg]\n\n"}
{"name":"Complex.arg_coe_angle_toReal_eq_arg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\n‚ä¢ Eq (‚Üëz.arg).toReal z.arg","decl":"@[simp]\ntheorem arg_coe_angle_toReal_eq_arg (z : ‚ÑÇ) : (arg z : Real.Angle).toReal = arg z := by\n  rw [Real.Angle.toReal_coe_eq_self_iff_mem_Ioc]\n  exact arg_mem_Ioc _\n\n"}
{"name":"Complex.arg_coe_angle_eq_iff_eq_toReal","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\nŒ∏ : Real.Angle\n‚ä¢ Iff (Eq (‚Üëz.arg) Œ∏) (Eq z.arg Œ∏.toReal)","decl":"theorem arg_coe_angle_eq_iff_eq_toReal {z : ‚ÑÇ} {Œ∏ : Real.Angle} :\n    (arg z : Real.Angle) = Œ∏ ‚Üî arg z = Œ∏.toReal := by\n  rw [‚Üê Real.Angle.toReal_inj, arg_coe_angle_toReal_eq_arg]\n\n"}
{"name":"Complex.arg_coe_angle_eq_iff","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x y : Complex\n‚ä¢ Iff (Eq ‚Üëx.arg ‚Üëy.arg) (Eq x.arg y.arg)","decl":"@[simp]\ntheorem arg_coe_angle_eq_iff {x y : ‚ÑÇ} : (arg x : Real.Angle) = arg y ‚Üî arg x = arg y := by\n  simp_rw [‚Üê Real.Angle.toReal_inj, arg_coe_angle_toReal_eq_arg]\n\n"}
{"name":"Complex.arg_mul_eq_add_arg_iff","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x y : Complex\nhx‚ÇÄ : Ne x 0\nhy‚ÇÄ : Ne y 0\n‚ä¢ Iff (Eq (HMul.hMul x y).arg (HAdd.hAdd x.arg y.arg)) (Membership.mem (Set.Ioc (Neg.neg Real.pi) Real.pi) (HAdd.hAdd x.arg y.arg))","decl":"lemma arg_mul_eq_add_arg_iff {x y : ‚ÑÇ} (hx‚ÇÄ : x ‚â† 0) (hy‚ÇÄ : y ‚â† 0) :\n    (x * y).arg = x.arg + y.arg ‚Üî arg x + arg y ‚àà Set.Ioc (-œÄ) œÄ := by\n  rw [‚Üê arg_coe_angle_toReal_eq_arg, arg_mul_coe_angle hx‚ÇÄ hy‚ÇÄ, ‚Üê Real.Angle.coe_add,\n      Real.Angle.toReal_coe_eq_self_iff_mem_Ioc]\n\n"}
{"name":"Complex.arg_mul","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x y : Complex\nhx‚ÇÄ : Ne x 0\nhy‚ÇÄ : Ne y 0\na‚úù : Membership.mem (Set.Ioc (Neg.neg Real.pi) Real.pi) (HAdd.hAdd x.arg y.arg)\n‚ä¢ Eq (HMul.hMul x y).arg (HAdd.hAdd x.arg y.arg)","decl":"alias ‚ü®_, arg_mul‚ü© := arg_mul_eq_add_arg_iff\n\n"}
{"name":"Complex.mem_slitPlane_iff_arg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\n‚ä¢ Iff (Membership.mem Complex.slitPlane z) (And (Ne z.arg Real.pi) (Ne z 0))","decl":"open ComplexOrder in\n/-- An alternative description of the slit plane as consisting of nonzero complex numbers\nwhose argument is not œÄ. -/\nlemma mem_slitPlane_iff_arg {z : ‚ÑÇ} : z ‚àà slitPlane ‚Üî z.arg ‚â† œÄ ‚àß z ‚â† 0 := by\n  simp only [mem_slitPlane_iff_not_le_zero, le_iff_lt_or_eq, ne_eq, arg_eq_pi_iff_lt_zero, not_or]\n\n"}
{"name":"Complex.slitPlane_arg_ne_pi","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\nhz : Membership.mem Complex.slitPlane z\n‚ä¢ Ne z.arg Real.pi","decl":"lemma slitPlane_arg_ne_pi {z : ‚ÑÇ} (hz : z ‚àà slitPlane) : z.arg ‚â† Real.pi :=\n  (mem_slitPlane_iff_arg.mp hz).1\n\n"}
{"name":"Complex.arg_eq_nhds_of_re_pos","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\nhx : LT.lt 0 x.re\n‚ä¢ (nhds x).EventuallyEq Complex.arg fun x => Real.arcsin (HDiv.hDiv x.im (Complex.abs x))","decl":"theorem arg_eq_nhds_of_re_pos (hx : 0 < x.re) : arg =·∂†[ùìù x] fun x => Real.arcsin (x.im / abs x) :=\n  ((continuous_re.tendsto _).eventually (lt_mem_nhds hx)).mono fun _ hy => arg_of_re_nonneg hy.le\n\n"}
{"name":"Complex.arg_eq_nhds_of_re_neg_of_im_pos","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\nhx_re : LT.lt x.re 0\nhx_im : LT.lt 0 x.im\n‚ä¢ (nhds x).EventuallyEq Complex.arg fun x => HAdd.hAdd (Real.arcsin (HDiv.hDiv (Neg.neg x).im (Complex.abs x))) Real.pi","decl":"theorem arg_eq_nhds_of_re_neg_of_im_pos (hx_re : x.re < 0) (hx_im : 0 < x.im) :\n    arg =·∂†[ùìù x] fun x => Real.arcsin ((-x).im / abs x) + œÄ := by\n  suffices h_forall_nhds : ‚àÄ·∂† y : ‚ÑÇ in ùìù x, y.re < 0 ‚àß 0 < y.im from\n    h_forall_nhds.mono fun y hy => arg_of_re_neg_of_im_nonneg hy.1 hy.2.le\n  refine IsOpen.eventually_mem ?_ (‚ü®hx_re, hx_im‚ü© : x.re < 0 ‚àß 0 < x.im)\n  exact\n    IsOpen.and (isOpen_lt continuous_re continuous_zero) (isOpen_lt continuous_zero continuous_im)\n\n"}
{"name":"Complex.arg_eq_nhds_of_re_neg_of_im_neg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\nhx_re : LT.lt x.re 0\nhx_im : LT.lt x.im 0\n‚ä¢ (nhds x).EventuallyEq Complex.arg fun x => HSub.hSub (Real.arcsin (HDiv.hDiv (Neg.neg x).im (Complex.abs x))) Real.pi","decl":"theorem arg_eq_nhds_of_re_neg_of_im_neg (hx_re : x.re < 0) (hx_im : x.im < 0) :\n    arg =·∂†[ùìù x] fun x => Real.arcsin ((-x).im / abs x) - œÄ := by\n  suffices h_forall_nhds : ‚àÄ·∂† y : ‚ÑÇ in ùìù x, y.re < 0 ‚àß y.im < 0 from\n    h_forall_nhds.mono fun y hy => arg_of_re_neg_of_im_neg hy.1 hy.2\n  refine IsOpen.eventually_mem ?_ (‚ü®hx_re, hx_im‚ü© : x.re < 0 ‚àß x.im < 0)\n  exact\n    IsOpen.and (isOpen_lt continuous_re continuous_zero) (isOpen_lt continuous_im continuous_zero)\n\n"}
{"name":"Complex.arg_eq_nhds_of_im_pos","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\nhz : LT.lt 0 z.im\n‚ä¢ (nhds z).EventuallyEq Complex.arg fun x => Real.arccos (HDiv.hDiv x.re (Complex.abs x))","decl":"theorem arg_eq_nhds_of_im_pos (hz : 0 < im z) : arg =·∂†[ùìù z] fun x => Real.arccos (x.re / abs x) :=\n  ((continuous_im.tendsto _).eventually (lt_mem_nhds hz)).mono fun _ => arg_of_im_pos\n\n"}
{"name":"Complex.arg_eq_nhds_of_im_neg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\nhz : LT.lt z.im 0\n‚ä¢ (nhds z).EventuallyEq Complex.arg fun x => Neg.neg (Real.arccos (HDiv.hDiv x.re (Complex.abs x)))","decl":"theorem arg_eq_nhds_of_im_neg (hz : im z < 0) : arg =·∂†[ùìù z] fun x => -Real.arccos (x.re / abs x) :=\n  ((continuous_im.tendsto _).eventually (gt_mem_nhds hz)).mono fun _ => arg_of_im_neg\n\n"}
{"name":"Complex.continuousAt_arg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\nh : Membership.mem Complex.slitPlane x\n‚ä¢ ContinuousAt Complex.arg x","decl":"theorem continuousAt_arg (h : x ‚àà slitPlane) : ContinuousAt arg x := by\n  have h‚ÇÄ : abs x ‚â† 0 := by\n    rw [abs.ne_zero_iff]\n    exact slitPlane_ne_zero h\n  rw [mem_slitPlane_iff, ‚Üê lt_or_lt_iff_ne] at h\n  rcases h with (hx_re | hx_im | hx_im)\n  exacts [(Real.continuousAt_arcsin.comp\n          (continuous_im.continuousAt.div continuous_abs.continuousAt h‚ÇÄ)).congr\n      (arg_eq_nhds_of_re_pos hx_re).symm,\n    (Real.continuous_arccos.continuousAt.comp\n            (continuous_re.continuousAt.div continuous_abs.continuousAt h‚ÇÄ)).neg.congr\n      (arg_eq_nhds_of_im_neg hx_im).symm,\n    (Real.continuous_arccos.continuousAt.comp\n          (continuous_re.continuousAt.div continuous_abs.continuousAt h‚ÇÄ)).congr\n      (arg_eq_nhds_of_im_pos hx_im).symm]\n\n"}
{"name":"Complex.tendsto_arg_nhdsWithin_im_neg_of_re_neg_of_im_zero","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\nhre : LT.lt z.re 0\nhim : Eq z.im 0\n‚ä¢ Filter.Tendsto Complex.arg (nhdsWithin z (setOf fun z => LT.lt z.im 0)) (nhds (Neg.neg Real.pi))","decl":"theorem tendsto_arg_nhdsWithin_im_neg_of_re_neg_of_im_zero {z : ‚ÑÇ} (hre : z.re < 0)\n    (him : z.im = 0) : Tendsto arg (ùìù[{ z : ‚ÑÇ | z.im < 0 }] z) (ùìù (-œÄ)) := by\n  suffices H : Tendsto (fun x : ‚ÑÇ => Real.arcsin ((-x).im / abs x) - œÄ)\n      (ùìù[{ z : ‚ÑÇ | z.im < 0 }] z) (ùìù (-œÄ)) by\n    refine H.congr' ?_\n    have : ‚àÄ·∂† x : ‚ÑÇ in ùìù z, x.re < 0 := continuous_re.tendsto z (gt_mem_nhds hre)\n    filter_upwards [self_mem_nhdsWithin, mem_nhdsWithin_of_mem_nhds this] with _ him hre\n    rw [arg, if_neg hre.not_le, if_neg him.not_le]\n  convert (Real.continuousAt_arcsin.comp_continuousWithinAt\n    ((continuous_im.continuousAt.comp_continuousWithinAt continuousWithinAt_neg).div\n      continuous_abs.continuousWithinAt _)\n    ).sub_const œÄ using 1\n  ¬∑ simp [him]\n  ¬∑ lift z to ‚Ñù using him\n    simpa using hre.ne\n\n"}
{"name":"Complex.continuousWithinAt_arg_of_re_neg_of_im_zero","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\nhre : LT.lt z.re 0\nhim : Eq z.im 0\n‚ä¢ ContinuousWithinAt Complex.arg (setOf fun z => LE.le 0 z.im) z","decl":"theorem continuousWithinAt_arg_of_re_neg_of_im_zero {z : ‚ÑÇ} (hre : z.re < 0) (him : z.im = 0) :\n    ContinuousWithinAt arg { z : ‚ÑÇ | 0 ‚â§ z.im } z := by\n  have : arg =·∂†[ùìù[{ z : ‚ÑÇ | 0 ‚â§ z.im }] z] fun x => Real.arcsin ((-x).im / abs x) + œÄ := by\n    have : ‚àÄ·∂† x : ‚ÑÇ in ùìù z, x.re < 0 := continuous_re.tendsto z (gt_mem_nhds hre)\n    filter_upwards [self_mem_nhdsWithin (s := { z : ‚ÑÇ | 0 ‚â§ z.im }),\n      mem_nhdsWithin_of_mem_nhds this] with _ him hre\n    rw [arg, if_neg hre.not_le, if_pos him]\n  refine ContinuousWithinAt.congr_of_eventuallyEq ?_ this ?_\n  ¬∑ refine\n      (Real.continuousAt_arcsin.comp_continuousWithinAt\n            ((continuous_im.continuousAt.comp_continuousWithinAt continuousWithinAt_neg).div\n              continuous_abs.continuousWithinAt ?_)).add\n        tendsto_const_nhds\n    lift z to ‚Ñù using him\n    simpa using hre.ne\n  ¬∑ rw [arg, if_neg hre.not_le, if_pos him.ge]\n\n"}
{"name":"Complex.tendsto_arg_nhdsWithin_im_nonneg_of_re_neg_of_im_zero","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"z : Complex\nhre : LT.lt z.re 0\nhim : Eq z.im 0\n‚ä¢ Filter.Tendsto Complex.arg (nhdsWithin z (setOf fun z => LE.le 0 z.im)) (nhds Real.pi)","decl":"theorem tendsto_arg_nhdsWithin_im_nonneg_of_re_neg_of_im_zero {z : ‚ÑÇ} (hre : z.re < 0)\n    (him : z.im = 0) : Tendsto arg (ùìù[{ z : ‚ÑÇ | 0 ‚â§ z.im }] z) (ùìù œÄ) := by\n  simpa only [arg_eq_pi_iff.2 ‚ü®hre, him‚ü©] using\n    (continuousWithinAt_arg_of_re_neg_of_im_zero hre him).tendsto\n\n"}
{"name":"Complex.continuousAt_arg_coe_angle","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arg","initialProofState":"x : Complex\nh : Ne x 0\n‚ä¢ ContinuousAt (Function.comp Real.Angle.coe Complex.arg) x","decl":"theorem continuousAt_arg_coe_angle (h : x ‚â† 0) : ContinuousAt ((‚Üë) ‚àò arg : ‚ÑÇ ‚Üí Real.Angle) x := by\n  by_cases hs : x ‚àà slitPlane\n  ¬∑ exact Real.Angle.continuous_coe.continuousAt.comp (continuousAt_arg hs)\n  ¬∑ rw [‚Üê Function.comp_id (((‚Üë) : ‚Ñù ‚Üí Real.Angle) ‚àò arg),\n      (funext_iff.2 fun _ => (neg_neg _).symm : (id : ‚ÑÇ ‚Üí ‚ÑÇ) = Neg.neg ‚àò Neg.neg), ‚Üê\n      Function.comp_assoc]\n    refine ContinuousAt.comp ?_ continuous_neg.continuousAt\n    suffices ContinuousAt (Function.update (((‚Üë) ‚àò arg) ‚àò Neg.neg : ‚ÑÇ ‚Üí Real.Angle) 0 œÄ) (-x) by\n      rwa [continuousAt_update_of_ne (neg_ne_zero.2 h)] at this\n    have ha :\n      Function.update (((‚Üë) ‚àò arg) ‚àò Neg.neg : ‚ÑÇ ‚Üí Real.Angle) 0 œÄ = fun z =>\n        (arg z : Real.Angle) + œÄ := by\n      rw [Function.update_eq_iff]\n      exact ‚ü®by simp, fun z hz => arg_neg_coe_angle hz‚ü©\n    rw [ha]\n    replace hs := mem_slitPlane_iff.mpr.mt hs\n    push_neg at hs\n    refine\n      (Real.Angle.continuous_coe.continuousAt.comp (continuousAt_arg (Or.inl ?_))).add\n        continuousAt_const\n    rw [neg_re, neg_pos]\n    exact hs.1.lt_of_ne fun h0 => h (Complex.ext_iff.2 ‚ü®h0, hs.2‚ü©)\n\n"}
