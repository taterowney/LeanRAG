{"name":"ContinuousMap.coe_mul","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Mul β\ninst✝ : ContinuousMul β\nf g : ContinuousMap α β\n⊢ Eq (⇑(HMul.hMul f g)) (HMul.hMul ⇑f ⇑g)","decl":"@[to_additive (attr := norm_cast, simp)]\ntheorem coe_mul [Mul β] [ContinuousMul β] (f g : C(α, β)) : ⇑(f * g) = f * g :=\n  rfl\n\n"}
{"name":"ContinuousMap.coe_add","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Add β\ninst✝ : ContinuousAdd β\nf g : ContinuousMap α β\n⊢ Eq (⇑(HAdd.hAdd f g)) (HAdd.hAdd ⇑f ⇑g)","decl":"@[to_additive (attr := norm_cast, simp)]\ntheorem coe_mul [Mul β] [ContinuousMul β] (f g : C(α, β)) : ⇑(f * g) = f * g :=\n  rfl\n\n"}
{"name":"ContinuousMap.add_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Add β\ninst✝ : ContinuousAdd β\nf g : ContinuousMap α β\nx : α\n⊢ Eq ((HAdd.hAdd f g) x) (HAdd.hAdd (f x) (g x))","decl":"@[to_additive (attr := simp)]\ntheorem mul_apply [Mul β] [ContinuousMul β] (f g : C(α, β)) (x : α) : (f * g) x = f x * g x :=\n  rfl\n\n"}
{"name":"ContinuousMap.mul_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Mul β\ninst✝ : ContinuousMul β\nf g : ContinuousMap α β\nx : α\n⊢ Eq ((HMul.hMul f g) x) (HMul.hMul (f x) (g x))","decl":"@[to_additive (attr := simp)]\ntheorem mul_apply [Mul β] [ContinuousMul β] (f g : C(α, β)) (x : α) : (f * g) x = f x * g x :=\n  rfl\n\n"}
{"name":"ContinuousMap.add_comp","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁴ : TopologicalSpace α\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace γ\ninst✝¹ : Add γ\ninst✝ : ContinuousAdd γ\nf₁ f₂ : ContinuousMap β γ\ng : ContinuousMap α β\n⊢ Eq ((HAdd.hAdd f₁ f₂).comp g) (HAdd.hAdd (f₁.comp g) (f₂.comp g))","decl":"@[to_additive (attr := simp)]\ntheorem mul_comp [Mul γ] [ContinuousMul γ] (f₁ f₂ : C(β, γ)) (g : C(α, β)) :\n    (f₁ * f₂).comp g = f₁.comp g * f₂.comp g :=\n  rfl\n\n"}
{"name":"ContinuousMap.mul_comp","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁴ : TopologicalSpace α\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace γ\ninst✝¹ : Mul γ\ninst✝ : ContinuousMul γ\nf₁ f₂ : ContinuousMap β γ\ng : ContinuousMap α β\n⊢ Eq ((HMul.hMul f₁ f₂).comp g) (HMul.hMul (f₁.comp g) (f₂.comp g))","decl":"@[to_additive (attr := simp)]\ntheorem mul_comp [Mul γ] [ContinuousMul γ] (f₁ f₂ : C(β, γ)) (g : C(α, β)) :\n    (f₁ * f₂).comp g = f₁.comp g * f₂.comp g :=\n  rfl\n\n"}
{"name":"ContinuousMap.coe_one","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : One β\n⊢ Eq (⇑1) 1","decl":"@[to_additive (attr := norm_cast, simp)]\ntheorem coe_one [One β] : ⇑(1 : C(α, β)) = 1 :=\n  rfl\n\n"}
{"name":"ContinuousMap.coe_zero","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : Zero β\n⊢ Eq (⇑0) 0","decl":"@[to_additive (attr := norm_cast, simp)]\ntheorem coe_one [One β] : ⇑(1 : C(α, β)) = 1 :=\n  rfl\n\n"}
{"name":"ContinuousMap.zero_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : Zero β\nx : α\n⊢ Eq (0 x) 0","decl":"@[to_additive (attr := simp)]\ntheorem one_apply [One β] (x : α) : (1 : C(α, β)) x = 1 :=\n  rfl\n\n"}
{"name":"ContinuousMap.one_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : One β\nx : α\n⊢ Eq (1 x) 1","decl":"@[to_additive (attr := simp)]\ntheorem one_apply [One β] (x : α) : (1 : C(α, β)) x = 1 :=\n  rfl\n\n"}
{"name":"ContinuousMap.one_comp","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : TopologicalSpace γ\ninst✝ : One γ\ng : ContinuousMap α β\n⊢ Eq (ContinuousMap.comp 1 g) 1","decl":"@[to_additive (attr := simp)]\ntheorem one_comp [One γ] (g : C(α, β)) : (1 : C(β, γ)).comp g = 1 :=\n  rfl\n\n"}
{"name":"ContinuousMap.zero_comp","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : TopologicalSpace γ\ninst✝ : Zero γ\ng : ContinuousMap α β\n⊢ Eq (ContinuousMap.comp 0 g) 0","decl":"@[to_additive (attr := simp)]\ntheorem one_comp [One γ] (g : C(α, β)) : (1 : C(β, γ)).comp g = 1 :=\n  rfl\n\n"}
{"name":"ContinuousMap.coe_natCast","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : NatCast β\nn : Nat\n⊢ Eq ⇑↑n ↑n","decl":"@[simp, norm_cast]\ntheorem coe_natCast [NatCast β] (n : ℕ) : ((n : C(α, β)) : α → β) = n :=\n  rfl\n\n"}
{"name":"ContinuousMap.natCast_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : NatCast β\nn : Nat\nx : α\n⊢ Eq (↑n x) ↑n","decl":"@[simp]\ntheorem natCast_apply [NatCast β] (n : ℕ) (x : α) : (n : C(α, β)) x = n :=\n  rfl\n\n"}
{"name":"ContinuousMap.coe_intCast","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : IntCast β\nn : Int\n⊢ Eq ⇑↑n ↑n","decl":"@[simp, norm_cast]\ntheorem coe_intCast [IntCast β] (n : ℤ) : ((n : C(α, β)) : α → β) = n :=\n  rfl\n\n"}
{"name":"ContinuousMap.intCast_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : IntCast β\nn : Int\nx : α\n⊢ Eq (↑n x) ↑n","decl":"@[simp]\ntheorem intCast_apply [IntCast β] (n : ℤ) (x : α) : (n : C(α, β)) x = n :=\n  rfl\n\n"}
{"name":"ContinuousMap.coe_nsmul","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : AddMonoid β\ninst✝ : ContinuousAdd β\nn : Nat\nf : ContinuousMap α β\n⊢ Eq (⇑(HSMul.hSMul n f)) (HSMul.hSMul n ⇑f)","decl":"@[to_additive (attr := norm_cast) (reorder := 7 8)]\ntheorem coe_pow [Monoid β] [ContinuousMul β] (f : C(α, β)) (n : ℕ) : ⇑(f ^ n) = (⇑f) ^ n :=\n  rfl\n\n"}
{"name":"ContinuousMap.coe_pow","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Monoid β\ninst✝ : ContinuousMul β\nf : ContinuousMap α β\nn : Nat\n⊢ Eq (⇑(HPow.hPow f n)) (HPow.hPow (⇑f) n)","decl":"@[to_additive (attr := norm_cast) (reorder := 7 8)]\ntheorem coe_pow [Monoid β] [ContinuousMul β] (f : C(α, β)) (n : ℕ) : ⇑(f ^ n) = (⇑f) ^ n :=\n  rfl\n\n"}
{"name":"ContinuousMap.pow_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Monoid β\ninst✝ : ContinuousMul β\nf : ContinuousMap α β\nn : Nat\nx : α\n⊢ Eq ((HPow.hPow f n) x) (HPow.hPow (f x) n)","decl":"@[to_additive (attr := norm_cast)]\ntheorem pow_apply [Monoid β] [ContinuousMul β] (f : C(α, β)) (n : ℕ) (x : α) :\n    (f ^ n) x = f x ^ n :=\n  rfl\n\n-- don't make auto-generated `coe_nsmul` and `nsmul_apply` simp, as the linter complains they're\n-- redundant WRT `coe_smul`\n"}
{"name":"ContinuousMap.nsmul_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : AddMonoid β\ninst✝ : ContinuousAdd β\nf : ContinuousMap α β\nn : Nat\nx : α\n⊢ Eq ((HSMul.hSMul n f) x) (HSMul.hSMul n (f x))","decl":"@[to_additive (attr := norm_cast)]\ntheorem pow_apply [Monoid β] [ContinuousMul β] (f : C(α, β)) (n : ℕ) (x : α) :\n    (f ^ n) x = f x ^ n :=\n  rfl\n\n-- don't make auto-generated `coe_nsmul` and `nsmul_apply` simp, as the linter complains they're\n-- redundant WRT `coe_smul`\n"}
{"name":"ContinuousMap.pow_comp","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁴ : TopologicalSpace α\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace γ\ninst✝¹ : Monoid γ\ninst✝ : ContinuousMul γ\nf : ContinuousMap β γ\nn : Nat\ng : ContinuousMap α β\n⊢ Eq ((HPow.hPow f n).comp g) (HPow.hPow (f.comp g) n)","decl":"@[to_additive]\ntheorem pow_comp [Monoid γ] [ContinuousMul γ] (f : C(β, γ)) (n : ℕ) (g : C(α, β)) :\n    (f ^ n).comp g = f.comp g ^ n :=\n  rfl\n\n-- don't make `nsmul_comp` simp as the linter complains it's redundant WRT `smul_comp`\n"}
{"name":"ContinuousMap.nsmul_comp","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁴ : TopologicalSpace α\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace γ\ninst✝¹ : AddMonoid γ\ninst✝ : ContinuousAdd γ\nf : ContinuousMap β γ\nn : Nat\ng : ContinuousMap α β\n⊢ Eq ((HSMul.hSMul n f).comp g) (HSMul.hSMul n (f.comp g))","decl":"@[to_additive]\ntheorem pow_comp [Monoid γ] [ContinuousMul γ] (f : C(β, γ)) (n : ℕ) (g : C(α, β)) :\n    (f ^ n).comp g = f.comp g ^ n :=\n  rfl\n\n-- don't make `nsmul_comp` simp as the linter complains it's redundant WRT `smul_comp`\n"}
{"name":"ContinuousMap.coe_inv","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Inv β\ninst✝ : ContinuousInv β\nf : ContinuousMap α β\n⊢ Eq (⇑(Inv.inv f)) (Inv.inv ⇑f)","decl":"@[to_additive (attr := simp)]\ntheorem coe_inv [Inv β] [ContinuousInv β] (f : C(α, β)) : ⇑f⁻¹ = (⇑f)⁻¹ :=\n  rfl\n\n"}
{"name":"ContinuousMap.coe_neg","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Neg β\ninst✝ : ContinuousNeg β\nf : ContinuousMap α β\n⊢ Eq (⇑(Neg.neg f)) (Neg.neg ⇑f)","decl":"@[to_additive (attr := simp)]\ntheorem coe_inv [Inv β] [ContinuousInv β] (f : C(α, β)) : ⇑f⁻¹ = (⇑f)⁻¹ :=\n  rfl\n\n"}
{"name":"ContinuousMap.inv_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Inv β\ninst✝ : ContinuousInv β\nf : ContinuousMap α β\nx : α\n⊢ Eq ((Inv.inv f) x) (Inv.inv (f x))","decl":"@[to_additive (attr := simp)]\ntheorem inv_apply [Inv β] [ContinuousInv β] (f : C(α, β)) (x : α) : f⁻¹ x = (f x)⁻¹ :=\n  rfl\n\n"}
{"name":"ContinuousMap.neg_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Neg β\ninst✝ : ContinuousNeg β\nf : ContinuousMap α β\nx : α\n⊢ Eq ((Neg.neg f) x) (Neg.neg (f x))","decl":"@[to_additive (attr := simp)]\ntheorem inv_apply [Inv β] [ContinuousInv β] (f : C(α, β)) (x : α) : f⁻¹ x = (f x)⁻¹ :=\n  rfl\n\n"}
{"name":"ContinuousMap.inv_comp","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁴ : TopologicalSpace α\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace γ\ninst✝¹ : Inv γ\ninst✝ : ContinuousInv γ\nf : ContinuousMap β γ\ng : ContinuousMap α β\n⊢ Eq ((Inv.inv f).comp g) (Inv.inv (f.comp g))","decl":"@[to_additive (attr := simp)]\ntheorem inv_comp [Inv γ] [ContinuousInv γ] (f : C(β, γ)) (g : C(α, β)) :\n    f⁻¹.comp g = (f.comp g)⁻¹ :=\n  rfl\n\n"}
{"name":"ContinuousMap.neg_comp","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁴ : TopologicalSpace α\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace γ\ninst✝¹ : Neg γ\ninst✝ : ContinuousNeg γ\nf : ContinuousMap β γ\ng : ContinuousMap α β\n⊢ Eq ((Neg.neg f).comp g) (Neg.neg (f.comp g))","decl":"@[to_additive (attr := simp)]\ntheorem inv_comp [Inv γ] [ContinuousInv γ] (f : C(β, γ)) (g : C(α, β)) :\n    f⁻¹.comp g = (f.comp g)⁻¹ :=\n  rfl\n\n"}
{"name":"ContinuousMap.coe_div","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Div β\ninst✝ : ContinuousDiv β\nf g : ContinuousMap α β\n⊢ Eq (⇑(HDiv.hDiv f g)) (HDiv.hDiv ⇑f ⇑g)","decl":"@[to_additive (attr := norm_cast, simp)]\ntheorem coe_div [Div β] [ContinuousDiv β] (f g : C(α, β)) : ⇑(f / g) = f / g :=\n  rfl\n\n"}
{"name":"ContinuousMap.coe_sub","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Sub β\ninst✝ : ContinuousSub β\nf g : ContinuousMap α β\n⊢ Eq (⇑(HSub.hSub f g)) (HSub.hSub ⇑f ⇑g)","decl":"@[to_additive (attr := norm_cast, simp)]\ntheorem coe_div [Div β] [ContinuousDiv β] (f g : C(α, β)) : ⇑(f / g) = f / g :=\n  rfl\n\n"}
{"name":"ContinuousMap.div_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Div β\ninst✝ : ContinuousDiv β\nf g : ContinuousMap α β\nx : α\n⊢ Eq ((HDiv.hDiv f g) x) (HDiv.hDiv (f x) (g x))","decl":"@[to_additive (attr := simp)]\ntheorem div_apply [Div β] [ContinuousDiv β] (f g : C(α, β)) (x : α) : (f / g) x = f x / g x :=\n  rfl\n\n"}
{"name":"ContinuousMap.sub_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Sub β\ninst✝ : ContinuousSub β\nf g : ContinuousMap α β\nx : α\n⊢ Eq ((HSub.hSub f g) x) (HSub.hSub (f x) (g x))","decl":"@[to_additive (attr := simp)]\ntheorem div_apply [Div β] [ContinuousDiv β] (f g : C(α, β)) (x : α) : (f / g) x = f x / g x :=\n  rfl\n\n"}
{"name":"ContinuousMap.div_comp","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁴ : TopologicalSpace α\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace γ\ninst✝¹ : Div γ\ninst✝ : ContinuousDiv γ\nf g : ContinuousMap β γ\nh : ContinuousMap α β\n⊢ Eq ((HDiv.hDiv f g).comp h) (HDiv.hDiv (f.comp h) (g.comp h))","decl":"@[to_additive (attr := simp)]\ntheorem div_comp [Div γ] [ContinuousDiv γ] (f g : C(β, γ)) (h : C(α, β)) :\n    (f / g).comp h = f.comp h / g.comp h :=\n  rfl\n\n"}
{"name":"ContinuousMap.sub_comp","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁴ : TopologicalSpace α\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace γ\ninst✝¹ : Sub γ\ninst✝ : ContinuousSub γ\nf g : ContinuousMap β γ\nh : ContinuousMap α β\n⊢ Eq ((HSub.hSub f g).comp h) (HSub.hSub (f.comp h) (g.comp h))","decl":"@[to_additive (attr := simp)]\ntheorem div_comp [Div γ] [ContinuousDiv γ] (f g : C(β, γ)) (h : C(α, β)) :\n    (f / g).comp h = f.comp h / g.comp h :=\n  rfl\n\n"}
{"name":"ContinuousMap.coe_zsmul","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : AddGroup β\ninst✝ : TopologicalAddGroup β\nz : Int\nf : ContinuousMap α β\n⊢ Eq (⇑(HSMul.hSMul z f)) (HSMul.hSMul z ⇑f)","decl":"@[to_additive (attr := norm_cast) (reorder := 7 8)]\ntheorem coe_zpow [Group β] [TopologicalGroup β] (f : C(α, β)) (z : ℤ) : ⇑(f ^ z) = (⇑f) ^ z :=\n  rfl\n\n"}
{"name":"ContinuousMap.coe_zpow","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Group β\ninst✝ : TopologicalGroup β\nf : ContinuousMap α β\nz : Int\n⊢ Eq (⇑(HPow.hPow f z)) (HPow.hPow (⇑f) z)","decl":"@[to_additive (attr := norm_cast) (reorder := 7 8)]\ntheorem coe_zpow [Group β] [TopologicalGroup β] (f : C(α, β)) (z : ℤ) : ⇑(f ^ z) = (⇑f) ^ z :=\n  rfl\n\n"}
{"name":"ContinuousMap.zpow_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Group β\ninst✝ : TopologicalGroup β\nf : ContinuousMap α β\nz : Int\nx : α\n⊢ Eq ((HPow.hPow f z) x) (HPow.hPow (f x) z)","decl":"@[to_additive]\ntheorem zpow_apply [Group β] [TopologicalGroup β] (f : C(α, β)) (z : ℤ) (x : α) :\n    (f ^ z) x = f x ^ z :=\n  rfl\n\n-- don't make auto-generated `coe_zsmul` and `zsmul_apply` simp as the linter complains they're\n-- redundant WRT `coe_smul`\n"}
{"name":"ContinuousMap.zsmul_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : AddGroup β\ninst✝ : TopologicalAddGroup β\nf : ContinuousMap α β\nz : Int\nx : α\n⊢ Eq ((HSMul.hSMul z f) x) (HSMul.hSMul z (f x))","decl":"@[to_additive]\ntheorem zpow_apply [Group β] [TopologicalGroup β] (f : C(α, β)) (z : ℤ) (x : α) :\n    (f ^ z) x = f x ^ z :=\n  rfl\n\n-- don't make auto-generated `coe_zsmul` and `zsmul_apply` simp as the linter complains they're\n-- redundant WRT `coe_smul`\n"}
{"name":"ContinuousMap.zpow_comp","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁴ : TopologicalSpace α\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace γ\ninst✝¹ : Group γ\ninst✝ : TopologicalGroup γ\nf : ContinuousMap β γ\nz : Int\ng : ContinuousMap α β\n⊢ Eq ((HPow.hPow f z).comp g) (HPow.hPow (f.comp g) z)","decl":"@[to_additive]\ntheorem zpow_comp [Group γ] [TopologicalGroup γ] (f : C(β, γ)) (z : ℤ) (g : C(α, β)) :\n    (f ^ z).comp g = f.comp g ^ z :=\n  rfl\n\n-- don't make `zsmul_comp` simp as the linter complains it's redundant WRT `smul_comp`\n"}
{"name":"ContinuousMap.zsmul_comp","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁴ : TopologicalSpace α\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace γ\ninst✝¹ : AddGroup γ\ninst✝ : TopologicalAddGroup γ\nf : ContinuousMap β γ\nz : Int\ng : ContinuousMap α β\n⊢ Eq ((HSMul.hSMul z f).comp g) (HSMul.hSMul z (f.comp g))","decl":"@[to_additive]\ntheorem zpow_comp [Group γ] [TopologicalGroup γ] (f : C(β, γ)) (z : ℤ) (g : C(α, β)) :\n    (f ^ z).comp g = f.comp g ^ z :=\n  rfl\n\n-- don't make `zsmul_comp` simp as the linter complains it's redundant WRT `smul_comp`\n"}
{"name":"ContinuousMap.instContinuousAddOfLocallyCompactSpace","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : TopologicalSpace α\ninst✝³ : TopologicalSpace β\ninst✝² : LocallyCompactSpace α\ninst✝¹ : Add β\ninst✝ : ContinuousAdd β\n⊢ ContinuousAdd (ContinuousMap α β)","decl":"@[to_additive]\ninstance [LocallyCompactSpace α] [Mul β] [ContinuousMul β] : ContinuousMul C(α, β) :=\n  ⟨by\n    refine continuous_of_continuous_uncurry _ ?_\n    have h1 : Continuous fun x : (C(α, β) × C(α, β)) × α => x.fst.fst x.snd :=\n      continuous_eval.comp (continuous_fst.prodMap continuous_id)\n    have h2 : Continuous fun x : (C(α, β) × C(α, β)) × α => x.fst.snd x.snd :=\n      continuous_eval.comp (continuous_snd.prodMap continuous_id)\n    exact h1.mul h2⟩\n\n"}
{"name":"ContinuousMap.instContinuousMulOfLocallyCompactSpace","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : TopologicalSpace α\ninst✝³ : TopologicalSpace β\ninst✝² : LocallyCompactSpace α\ninst✝¹ : Mul β\ninst✝ : ContinuousMul β\n⊢ ContinuousMul (ContinuousMap α β)","decl":"@[to_additive]\ninstance [LocallyCompactSpace α] [Mul β] [ContinuousMul β] : ContinuousMul C(α, β) :=\n  ⟨by\n    refine continuous_of_continuous_uncurry _ ?_\n    have h1 : Continuous fun x : (C(α, β) × C(α, β)) × α => x.fst.fst x.snd :=\n      continuous_eval.comp (continuous_fst.prodMap continuous_id)\n    have h2 : Continuous fun x : (C(α, β) × C(α, β)) × α => x.fst.snd x.snd :=\n      continuous_eval.comp (continuous_snd.prodMap continuous_id)\n    exact h1.mul h2⟩\n\n"}
{"name":"ContinuousMap.coeFnMonoidHom_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Monoid β\ninst✝ : ContinuousMul β\nf : ContinuousMap α β\na : α\n⊢ Eq (ContinuousMap.coeFnMonoidHom f a) (f a)","decl":"/-- Coercion to a function as a `MonoidHom`. Similar to `MonoidHom.coeFn`. -/\n@[to_additive (attr := simps)\n  \"Coercion to a function as an `AddMonoidHom`. Similar to `AddMonoidHom.coeFn`.\" ]\ndef coeFnMonoidHom [Monoid β] [ContinuousMul β] : C(α, β) →* α → β where\n  toFun f := f\n  map_one' := coe_one\n  map_mul' := coe_mul\n\n"}
{"name":"ContinuousMap.coeFnAddMonoidHom_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : AddMonoid β\ninst✝ : ContinuousAdd β\nf : ContinuousMap α β\na : α\n⊢ Eq (ContinuousMap.coeFnAddMonoidHom f a) (f a)","decl":"/-- Coercion to a function as a `MonoidHom`. Similar to `MonoidHom.coeFn`. -/\n@[to_additive (attr := simps)\n  \"Coercion to a function as an `AddMonoidHom`. Similar to `AddMonoidHom.coeFn`.\" ]\ndef coeFnMonoidHom [Monoid β] [ContinuousMul β] : C(α, β) →* α → β where\n  toFun f := f\n  map_one' := coe_one\n  map_mul' := coe_mul\n\n"}
{"name":"AddMonoidHom.compLeftContinuous_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : TopologicalSpace β\nγ : Type u_3\ninst✝⁴ : AddMonoid β\ninst✝³ : ContinuousAdd β\ninst✝² : TopologicalSpace γ\ninst✝¹ : AddMonoid γ\ninst✝ : ContinuousAdd γ\ng : AddMonoidHom β γ\nhg : Continuous ⇑g\nf : ContinuousMap α β\n⊢ Eq ((AddMonoidHom.compLeftContinuous α g hg) f) ({ toFun := ⇑g, continuous_toFun := hg }.comp f)","decl":"/-- Composition on the left by a (continuous) homomorphism of topological monoids, as a\n`MonoidHom`. Similar to `MonoidHom.compLeft`. -/\n@[to_additive (attr := simps)\n\"Composition on the left by a (continuous) homomorphism of topological `AddMonoid`s, as an\n`AddMonoidHom`. Similar to `AddMonoidHom.comp_left`.\"]\nprotected def _root_.MonoidHom.compLeftContinuous {γ : Type*} [Monoid β] [ContinuousMul β]\n    [TopologicalSpace γ] [Monoid γ] [ContinuousMul γ] (g : β →* γ) (hg : Continuous g) :\n    C(α, β) →* C(α, γ) where\n  toFun f := (⟨g, hg⟩ : C(β, γ)).comp f\n  map_one' := ext fun _ => g.map_one\n  map_mul' _ _ := ext fun _ => g.map_mul _ _\n\n"}
{"name":"MonoidHom.compLeftContinuous_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : TopologicalSpace β\nγ : Type u_3\ninst✝⁴ : Monoid β\ninst✝³ : ContinuousMul β\ninst✝² : TopologicalSpace γ\ninst✝¹ : Monoid γ\ninst✝ : ContinuousMul γ\ng : MonoidHom β γ\nhg : Continuous ⇑g\nf : ContinuousMap α β\n⊢ Eq ((MonoidHom.compLeftContinuous α g hg) f) ({ toFun := ⇑g, continuous_toFun := hg }.comp f)","decl":"/-- Composition on the left by a (continuous) homomorphism of topological monoids, as a\n`MonoidHom`. Similar to `MonoidHom.compLeft`. -/\n@[to_additive (attr := simps)\n\"Composition on the left by a (continuous) homomorphism of topological `AddMonoid`s, as an\n`AddMonoidHom`. Similar to `AddMonoidHom.comp_left`.\"]\nprotected def _root_.MonoidHom.compLeftContinuous {γ : Type*} [Monoid β] [ContinuousMul β]\n    [TopologicalSpace γ] [Monoid γ] [ContinuousMul γ] (g : β →* γ) (hg : Continuous g) :\n    C(α, β) →* C(α, γ) where\n  toFun f := (⟨g, hg⟩ : C(β, γ)).comp f\n  map_one' := ext fun _ => g.map_one\n  map_mul' _ _ := ext fun _ => g.map_mul _ _\n\n"}
{"name":"ContinuousMap.compAddMonoidHom'_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : TopologicalSpace α\ninst✝³ : TopologicalSpace β\nγ : Type u_3\ninst✝² : TopologicalSpace γ\ninst✝¹ : AddZeroClass γ\ninst✝ : ContinuousAdd γ\ng : ContinuousMap α β\nf : ContinuousMap β γ\n⊢ Eq (g.compAddMonoidHom' f) (f.comp g)","decl":"/-- Composition on the right as a `MonoidHom`. Similar to `MonoidHom.compHom'`. -/\n@[to_additive (attr := simps)\n      \"Composition on the right as an `AddMonoidHom`. Similar to `AddMonoidHom.compHom'`.\"]\ndef compMonoidHom' {γ : Type*} [TopologicalSpace γ] [MulOneClass γ] [ContinuousMul γ]\n    (g : C(α, β)) : C(β, γ) →* C(α, γ) where\n  toFun f := f.comp g\n  map_one' := one_comp g\n  map_mul' f₁ f₂ := mul_comp f₁ f₂ g\n\n"}
{"name":"ContinuousMap.compMonoidHom'_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : TopologicalSpace α\ninst✝³ : TopologicalSpace β\nγ : Type u_3\ninst✝² : TopologicalSpace γ\ninst✝¹ : MulOneClass γ\ninst✝ : ContinuousMul γ\ng : ContinuousMap α β\nf : ContinuousMap β γ\n⊢ Eq (g.compMonoidHom' f) (f.comp g)","decl":"/-- Composition on the right as a `MonoidHom`. Similar to `MonoidHom.compHom'`. -/\n@[to_additive (attr := simps)\n      \"Composition on the right as an `AddMonoidHom`. Similar to `AddMonoidHom.compHom'`.\"]\ndef compMonoidHom' {γ : Type*} [TopologicalSpace γ] [MulOneClass γ] [ContinuousMul γ]\n    (g : C(α, β)) : C(β, γ) →* C(α, γ) where\n  toFun f := f.comp g\n  map_one' := one_comp g\n  map_mul' f₁ f₂ := mul_comp f₁ f₂ g\n\n"}
{"name":"ContinuousMap.coe_prod","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : CommMonoid β\ninst✝ : ContinuousMul β\nι : Type u_3\ns : Finset ι\nf : ι → ContinuousMap α β\n⊢ Eq (⇑(s.prod fun i => f i)) (s.prod fun i => ⇑(f i))","decl":"@[to_additive (attr := simp)]\ntheorem coe_prod [CommMonoid β] [ContinuousMul β] {ι : Type*} (s : Finset ι) (f : ι → C(α, β)) :\n    ⇑(∏ i ∈ s, f i) = ∏ i ∈ s, (f i : α → β) :=\n  map_prod coeFnMonoidHom f s\n\n"}
{"name":"ContinuousMap.coe_sum","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : AddCommMonoid β\ninst✝ : ContinuousAdd β\nι : Type u_3\ns : Finset ι\nf : ι → ContinuousMap α β\n⊢ Eq (⇑(s.sum fun i => f i)) (s.sum fun i => ⇑(f i))","decl":"@[to_additive (attr := simp)]\ntheorem coe_prod [CommMonoid β] [ContinuousMul β] {ι : Type*} (s : Finset ι) (f : ι → C(α, β)) :\n    ⇑(∏ i ∈ s, f i) = ∏ i ∈ s, (f i : α → β) :=\n  map_prod coeFnMonoidHom f s\n\n"}
{"name":"ContinuousMap.sum_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : AddCommMonoid β\ninst✝ : ContinuousAdd β\nι : Type u_3\ns : Finset ι\nf : ι → ContinuousMap α β\na : α\n⊢ Eq ((s.sum fun i => f i) a) (s.sum fun i => (f i) a)","decl":"@[to_additive]\ntheorem prod_apply [CommMonoid β] [ContinuousMul β] {ι : Type*} (s : Finset ι) (f : ι → C(α, β))\n    (a : α) : (∏ i ∈ s, f i) a = ∏ i ∈ s, f i a := by simp\n\n"}
{"name":"ContinuousMap.prod_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : CommMonoid β\ninst✝ : ContinuousMul β\nι : Type u_3\ns : Finset ι\nf : ι → ContinuousMap α β\na : α\n⊢ Eq ((s.prod fun i => f i) a) (s.prod fun i => (f i) a)","decl":"@[to_additive]\ntheorem prod_apply [CommMonoid β] [ContinuousMul β] {ι : Type*} (s : Finset ι) (f : ι → C(α, β))\n    (a : α) : (∏ i ∈ s, f i) a = ∏ i ∈ s, f i a := by simp\n\n"}
{"name":"ContinuousMap.instTopologicalGroup","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : CommGroup β\ninst✝ : TopologicalGroup β\n⊢ TopologicalGroup (ContinuousMap α β)","decl":"@[to_additive]\ninstance [CommGroup β] [TopologicalGroup β] : TopologicalGroup C(α, β) where\n  continuous_mul := by\n    letI : UniformSpace β := TopologicalGroup.toUniformSpace β\n    have : UniformGroup β := comm_topologicalGroup_is_uniform\n    rw [continuous_iff_continuousAt]\n    rintro ⟨f, g⟩\n    rw [ContinuousAt, tendsto_iff_forall_isCompact_tendstoUniformlyOn, nhds_prod_eq]\n    exact fun K hK =>\n      uniformContinuous_mul.comp_tendstoUniformlyOn\n        ((tendsto_iff_forall_isCompact_tendstoUniformlyOn.mp Filter.tendsto_id K hK).prod\n          (tendsto_iff_forall_isCompact_tendstoUniformlyOn.mp Filter.tendsto_id K hK))\n  continuous_inv := by\n    letI : UniformSpace β := TopologicalGroup.toUniformSpace β\n    have : UniformGroup β := comm_topologicalGroup_is_uniform\n    rw [continuous_iff_continuousAt]\n    intro f\n    rw [ContinuousAt, tendsto_iff_forall_isCompact_tendstoUniformlyOn]\n    exact fun K hK =>\n      uniformContinuous_inv.comp_tendstoUniformlyOn\n        (tendsto_iff_forall_isCompact_tendstoUniformlyOn.mp Filter.tendsto_id K hK)\n\n"}
{"name":"ContinuousMap.instTopologicalAddGroup","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : AddCommGroup β\ninst✝ : TopologicalAddGroup β\n⊢ TopologicalAddGroup (ContinuousMap α β)","decl":"@[to_additive]\ninstance [CommGroup β] [TopologicalGroup β] : TopologicalGroup C(α, β) where\n  continuous_mul := by\n    letI : UniformSpace β := TopologicalGroup.toUniformSpace β\n    have : UniformGroup β := comm_topologicalGroup_is_uniform\n    rw [continuous_iff_continuousAt]\n    rintro ⟨f, g⟩\n    rw [ContinuousAt, tendsto_iff_forall_isCompact_tendstoUniformlyOn, nhds_prod_eq]\n    exact fun K hK =>\n      uniformContinuous_mul.comp_tendstoUniformlyOn\n        ((tendsto_iff_forall_isCompact_tendstoUniformlyOn.mp Filter.tendsto_id K hK).prod\n          (tendsto_iff_forall_isCompact_tendstoUniformlyOn.mp Filter.tendsto_id K hK))\n  continuous_inv := by\n    letI : UniformSpace β := TopologicalGroup.toUniformSpace β\n    have : UniformGroup β := comm_topologicalGroup_is_uniform\n    rw [continuous_iff_continuousAt]\n    intro f\n    rw [ContinuousAt, tendsto_iff_forall_isCompact_tendstoUniformlyOn]\n    exact fun K hK =>\n      uniformContinuous_inv.comp_tendstoUniformlyOn\n        (tendsto_iff_forall_isCompact_tendstoUniformlyOn.mp Filter.tendsto_id K hK)\n\n"}
{"name":"ContinuousMap.hasSum_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\nγ : Type u_3\ninst✝¹ : AddCommMonoid β\ninst✝ : ContinuousAdd β\nf : γ → ContinuousMap α β\ng : ContinuousMap α β\nhf : HasSum f g\nx : α\n⊢ HasSum (fun i => (f i) x) (g x)","decl":"/-- If an infinite product of functions in `C(α, β)` converges to `g`\n(for the compact-open topology), then the pointwise product converges to `g x` for all `x ∈ α`. -/\n@[to_additive\n  \"If an infinite sum of functions in `C(α, β)` converges to `g` (for the compact-open topology),\nthen the pointwise sum converges to `g x` for all `x ∈ α`.\"]\ntheorem hasProd_apply {γ : Type*} [CommMonoid β] [ContinuousMul β]\n    {f : γ → C(α, β)} {g : C(α, β)} (hf : HasProd f g) (x : α) :\n    HasProd (fun i : γ => f i x) (g x) := by\n  let ev : C(α, β) →* β := (Pi.evalMonoidHom _ x).comp coeFnMonoidHom\n  exact hf.map ev (continuous_eval_const x)\n\n"}
{"name":"ContinuousMap.hasProd_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\nγ : Type u_3\ninst✝¹ : CommMonoid β\ninst✝ : ContinuousMul β\nf : γ → ContinuousMap α β\ng : ContinuousMap α β\nhf : HasProd f g\nx : α\n⊢ HasProd (fun i => (f i) x) (g x)","decl":"/-- If an infinite product of functions in `C(α, β)` converges to `g`\n(for the compact-open topology), then the pointwise product converges to `g x` for all `x ∈ α`. -/\n@[to_additive\n  \"If an infinite sum of functions in `C(α, β)` converges to `g` (for the compact-open topology),\nthen the pointwise sum converges to `g x` for all `x ∈ α`.\"]\ntheorem hasProd_apply {γ : Type*} [CommMonoid β] [ContinuousMul β]\n    {f : γ → C(α, β)} {g : C(α, β)} (hf : HasProd f g) (x : α) :\n    HasProd (fun i : γ => f i x) (g x) := by\n  let ev : C(α, β) →* β := (Pi.evalMonoidHom _ x).comp coeFnMonoidHom\n  exact hf.map ev (continuous_eval_const x)\n\n"}
{"name":"ContinuousMap.summable_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : AddCommMonoid β\ninst✝ : ContinuousAdd β\nγ : Type u_3\nf : γ → ContinuousMap α β\nhf : Summable f\nx : α\n⊢ Summable fun i => (f i) x","decl":"@[to_additive]\ntheorem multipliable_apply [CommMonoid β] [ContinuousMul β] {γ : Type*} {f : γ → C(α, β)}\n    (hf : Multipliable f) (x : α) : Multipliable fun i : γ => f i x :=\n  (hasProd_apply hf.hasProd x).multipliable\n\n"}
{"name":"ContinuousMap.multipliable_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : CommMonoid β\ninst✝ : ContinuousMul β\nγ : Type u_3\nf : γ → ContinuousMap α β\nhf : Multipliable f\nx : α\n⊢ Multipliable fun i => (f i) x","decl":"@[to_additive]\ntheorem multipliable_apply [CommMonoid β] [ContinuousMul β] {γ : Type*} {f : γ → C(α, β)}\n    (hf : Multipliable f) (x : α) : Multipliable fun i : γ => f i x :=\n  (hasProd_apply hf.hasProd x).multipliable\n\n"}
{"name":"ContinuousMap.tsum_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : TopologicalSpace α\ninst✝³ : TopologicalSpace β\ninst✝² : T2Space β\ninst✝¹ : AddCommMonoid β\ninst✝ : ContinuousAdd β\nγ : Type u_3\nf : γ → ContinuousMap α β\nhf : Summable f\nx : α\n⊢ Eq (tsum fun i => (f i) x) ((tsum fun i => f i) x)","decl":"@[to_additive]\ntheorem tprod_apply [T2Space β] [CommMonoid β] [ContinuousMul β] {γ : Type*} {f : γ → C(α, β)}\n    (hf : Multipliable f) (x : α) :\n    ∏' i : γ, f i x = (∏' i : γ, f i) x :=\n  (hasProd_apply hf.hasProd x).tprod_eq\n\n"}
{"name":"ContinuousMap.tprod_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : TopologicalSpace α\ninst✝³ : TopologicalSpace β\ninst✝² : T2Space β\ninst✝¹ : CommMonoid β\ninst✝ : ContinuousMul β\nγ : Type u_3\nf : γ → ContinuousMap α β\nhf : Multipliable f\nx : α\n⊢ Eq (tprod fun i => (f i) x) ((tprod fun i => f i) x)","decl":"@[to_additive]\ntheorem tprod_apply [T2Space β] [CommMonoid β] [ContinuousMul β] {γ : Type*} {f : γ → C(α, β)}\n    (hf : Multipliable f) (x : α) :\n    ∏' i : γ, f i x = (∏' i : γ, f i) x :=\n  (hasProd_apply hf.hasProd x).tprod_eq\n\n"}
{"name":"ContinuousMap.instTopologicalSemiringOfLocallyCompactSpace","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : TopologicalSpace α\ninst✝³ : TopologicalSpace β\ninst✝² : LocallyCompactSpace α\ninst✝¹ : NonUnitalSemiring β\ninst✝ : TopologicalSemiring β\n⊢ TopologicalSemiring (ContinuousMap α β)","decl":"instance {α : Type*} {β : Type*} [TopologicalSpace α] [TopologicalSpace β] [LocallyCompactSpace α]\n    [NonUnitalSemiring β] [TopologicalSemiring β] : TopologicalSemiring C(α, β) where\n\n"}
{"name":"ContinuousMap.instTopologicalRingOfLocallyCompactSpace","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : TopologicalSpace α\ninst✝³ : TopologicalSpace β\ninst✝² : LocallyCompactSpace α\ninst✝¹ : NonUnitalRing β\ninst✝ : TopologicalRing β\n⊢ TopologicalRing (ContinuousMap α β)","decl":"instance {α : Type*} {β : Type*} [TopologicalSpace α] [TopologicalSpace β] [LocallyCompactSpace α]\n    [NonUnitalRing β] [TopologicalRing β] : TopologicalRing C(α, β) where\n\n"}
{"name":"RingHom.compLeftContinuous_apply_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : TopologicalSpace β\ninst✝⁴ : Semiring β\ninst✝³ : TopologicalSemiring β\ninst✝² : TopologicalSpace γ\ninst✝¹ : Semiring γ\ninst✝ : TopologicalSemiring γ\ng : RingHom β γ\nhg : Continuous ⇑g\nf : ContinuousMap α β\na✝ : α\n⊢ Eq (((RingHom.compLeftContinuous α g hg) f) a✝) (g (f a✝))","decl":"/-- Composition on the left by a (continuous) homomorphism of topological semirings, as a\n`RingHom`.  Similar to `RingHom.compLeft`. -/\n@[simps!]\nprotected def _root_.RingHom.compLeftContinuous (α : Type*) {β : Type*} {γ : Type*}\n    [TopologicalSpace α]\n    [TopologicalSpace β] [Semiring β] [TopologicalSemiring β] [TopologicalSpace γ] [Semiring γ]\n    [TopologicalSemiring γ] (g : β →+* γ) (hg : Continuous g) : C(α, β) →+* C(α, γ) :=\n  { g.toMonoidHom.compLeftContinuous α hg, g.toAddMonoidHom.compLeftContinuous α hg with }\n\n"}
{"name":"ContinuousMap.coeFnRingHom_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Semiring β\ninst✝ : TopologicalSemiring β\nf : ContinuousMap α β\na : α\n⊢ Eq (ContinuousMap.coeFnRingHom f a) (f a)","decl":"/-- Coercion to a function as a `RingHom`. -/\n@[simps!]\ndef coeFnRingHom {α : Type*} {β : Type*} [TopologicalSpace α] [TopologicalSpace β] [Semiring β]\n    [TopologicalSemiring β] : C(α, β) →+* α → β :=\n  { (coeFnMonoidHom : C(α, β) →* _),\n    (coeFnAddMonoidHom : C(α, β) →+ _) with }\n\n"}
{"name":"ContinuousMap.instContinuousConstVAddOfLocallyCompactSpace","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝⁴ : TopologicalSpace α\nR : Type u_3\nM : Type u_5\ninst✝³ : TopologicalSpace M\ninst✝² : LocallyCompactSpace α\ninst✝¹ : VAdd R M\ninst✝ : ContinuousConstVAdd R M\n⊢ ContinuousConstVAdd R (ContinuousMap α M)","decl":"@[to_additive]\ninstance [LocallyCompactSpace α] [SMul R M] [ContinuousConstSMul R M] :\n    ContinuousConstSMul R C(α, M) :=\n  ⟨fun γ => continuous_of_continuous_uncurry _ (continuous_eval.const_smul γ)⟩\n\n"}
{"name":"ContinuousMap.instContinuousConstSMulOfLocallyCompactSpace","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝⁴ : TopologicalSpace α\nR : Type u_3\nM : Type u_5\ninst✝³ : TopologicalSpace M\ninst✝² : LocallyCompactSpace α\ninst✝¹ : SMul R M\ninst✝ : ContinuousConstSMul R M\n⊢ ContinuousConstSMul R (ContinuousMap α M)","decl":"@[to_additive]\ninstance [LocallyCompactSpace α] [SMul R M] [ContinuousConstSMul R M] :\n    ContinuousConstSMul R C(α, M) :=\n  ⟨fun γ => continuous_of_continuous_uncurry _ (continuous_eval.const_smul γ)⟩\n\n"}
{"name":"ContinuousMap.instContinuousSMulOfLocallyCompactSpace","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝⁵ : TopologicalSpace α\nR : Type u_3\nM : Type u_5\ninst✝⁴ : TopologicalSpace M\ninst✝³ : LocallyCompactSpace α\ninst✝² : TopologicalSpace R\ninst✝¹ : SMul R M\ninst✝ : ContinuousSMul R M\n⊢ ContinuousSMul R (ContinuousMap α M)","decl":"@[to_additive]\ninstance [LocallyCompactSpace α] [TopologicalSpace R] [SMul R M] [ContinuousSMul R M] :\n    ContinuousSMul R C(α, M) :=\n  ⟨by\n    refine continuous_of_continuous_uncurry _ ?_\n    have h : Continuous fun x : (R × C(α, M)) × α => x.fst.snd x.snd :=\n      continuous_eval.comp (continuous_snd.prodMap continuous_id)\n    exact (continuous_fst.comp continuous_fst).smul h⟩\n\n"}
{"name":"ContinuousMap.instContinuousVAddOfLocallyCompactSpace","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝⁵ : TopologicalSpace α\nR : Type u_3\nM : Type u_5\ninst✝⁴ : TopologicalSpace M\ninst✝³ : LocallyCompactSpace α\ninst✝² : TopologicalSpace R\ninst✝¹ : VAdd R M\ninst✝ : ContinuousVAdd R M\n⊢ ContinuousVAdd R (ContinuousMap α M)","decl":"@[to_additive]\ninstance [LocallyCompactSpace α] [TopologicalSpace R] [SMul R M] [ContinuousSMul R M] :\n    ContinuousSMul R C(α, M) :=\n  ⟨by\n    refine continuous_of_continuous_uncurry _ ?_\n    have h : Continuous fun x : (R × C(α, M)) × α => x.fst.snd x.snd :=\n      continuous_eval.comp (continuous_snd.prodMap continuous_id)\n    exact (continuous_fst.comp continuous_fst).smul h⟩\n\n"}
{"name":"ContinuousMap.coe_vadd","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nR : Type u_3\nM : Type u_5\ninst✝² : TopologicalSpace M\ninst✝¹ : VAdd R M\ninst✝ : ContinuousConstVAdd R M\nc : R\nf : ContinuousMap α M\n⊢ Eq (⇑(HVAdd.hVAdd c f)) (HVAdd.hVAdd c ⇑f)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_smul [SMul R M] [ContinuousConstSMul R M] (c : R) (f : C(α, M)) : ⇑(c • f) = c • ⇑f :=\n  rfl\n\n"}
{"name":"ContinuousMap.coe_smul","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nR : Type u_3\nM : Type u_5\ninst✝² : TopologicalSpace M\ninst✝¹ : SMul R M\ninst✝ : ContinuousConstSMul R M\nc : R\nf : ContinuousMap α M\n⊢ Eq (⇑(HSMul.hSMul c f)) (HSMul.hSMul c ⇑f)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_smul [SMul R M] [ContinuousConstSMul R M] (c : R) (f : C(α, M)) : ⇑(c • f) = c • ⇑f :=\n  rfl\n\n"}
{"name":"ContinuousMap.vadd_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nR : Type u_3\nM : Type u_5\ninst✝² : TopologicalSpace M\ninst✝¹ : VAdd R M\ninst✝ : ContinuousConstVAdd R M\nc : R\nf : ContinuousMap α M\na : α\n⊢ Eq ((HVAdd.hVAdd c f) a) (HVAdd.hVAdd c (f a))","decl":"@[to_additive]\ntheorem smul_apply [SMul R M] [ContinuousConstSMul R M] (c : R) (f : C(α, M)) (a : α) :\n    (c • f) a = c • f a :=\n  rfl\n\n"}
{"name":"ContinuousMap.smul_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nR : Type u_3\nM : Type u_5\ninst✝² : TopologicalSpace M\ninst✝¹ : SMul R M\ninst✝ : ContinuousConstSMul R M\nc : R\nf : ContinuousMap α M\na : α\n⊢ Eq ((HSMul.hSMul c f) a) (HSMul.hSMul c (f a))","decl":"@[to_additive]\ntheorem smul_apply [SMul R M] [ContinuousConstSMul R M] (c : R) (f : C(α, M)) (a : α) :\n    (c • f) a = c • f a :=\n  rfl\n\n"}
{"name":"ContinuousMap.vadd_comp","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : TopologicalSpace α\ninst✝³ : TopologicalSpace β\nR : Type u_3\nM : Type u_5\ninst✝² : TopologicalSpace M\ninst✝¹ : VAdd R M\ninst✝ : ContinuousConstVAdd R M\nr : R\nf : ContinuousMap β M\ng : ContinuousMap α β\n⊢ Eq ((HVAdd.hVAdd r f).comp g) (HVAdd.hVAdd r (f.comp g))","decl":"@[to_additive (attr := simp)]\ntheorem smul_comp [SMul R M] [ContinuousConstSMul R M] (r : R) (f : C(β, M)) (g : C(α, β)) :\n    (r • f).comp g = r • f.comp g :=\n  rfl\n\n"}
{"name":"ContinuousMap.smul_comp","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : TopologicalSpace α\ninst✝³ : TopologicalSpace β\nR : Type u_3\nM : Type u_5\ninst✝² : TopologicalSpace M\ninst✝¹ : SMul R M\ninst✝ : ContinuousConstSMul R M\nr : R\nf : ContinuousMap β M\ng : ContinuousMap α β\n⊢ Eq ((HSMul.hSMul r f).comp g) (HSMul.hSMul r (f.comp g))","decl":"@[to_additive (attr := simp)]\ntheorem smul_comp [SMul R M] [ContinuousConstSMul R M] (r : R) (f : C(β, M)) (g : C(α, β)) :\n    (r • f).comp g = r • f.comp g :=\n  rfl\n\n"}
{"name":"ContinuousMap.instSMulCommClass","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝⁶ : TopologicalSpace α\nR : Type u_3\nR₁ : Type u_4\nM : Type u_5\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : SMul R M\ninst✝³ : ContinuousConstSMul R M\ninst✝² : SMul R₁ M\ninst✝¹ : ContinuousConstSMul R₁ M\ninst✝ : SMulCommClass R R₁ M\n⊢ SMulCommClass R R₁ (ContinuousMap α M)","decl":"@[to_additive]\ninstance [SMul R M] [ContinuousConstSMul R M] [SMul R₁ M] [ContinuousConstSMul R₁ M]\n    [SMulCommClass R R₁ M] : SMulCommClass R R₁ C(α, M) where\n  smul_comm _ _ _ := ext fun _ => smul_comm _ _ _\n\n"}
{"name":"ContinuousMap.instVAddCommClass","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝⁶ : TopologicalSpace α\nR : Type u_3\nR₁ : Type u_4\nM : Type u_5\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : VAdd R M\ninst✝³ : ContinuousConstVAdd R M\ninst✝² : VAdd R₁ M\ninst✝¹ : ContinuousConstVAdd R₁ M\ninst✝ : VAddCommClass R R₁ M\n⊢ VAddCommClass R R₁ (ContinuousMap α M)","decl":"@[to_additive]\ninstance [SMul R M] [ContinuousConstSMul R M] [SMul R₁ M] [ContinuousConstSMul R₁ M]\n    [SMulCommClass R R₁ M] : SMulCommClass R R₁ C(α, M) where\n  smul_comm _ _ _ := ext fun _ => smul_comm _ _ _\n\n"}
{"name":"ContinuousMap.instIsScalarTower","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝⁷ : TopologicalSpace α\nR : Type u_3\nR₁ : Type u_4\nM : Type u_5\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : SMul R M\ninst✝⁴ : ContinuousConstSMul R M\ninst✝³ : SMul R₁ M\ninst✝² : ContinuousConstSMul R₁ M\ninst✝¹ : SMul R R₁\ninst✝ : IsScalarTower R R₁ M\n⊢ IsScalarTower R R₁ (ContinuousMap α M)","decl":"instance [SMul R M] [ContinuousConstSMul R M] [SMul R₁ M] [ContinuousConstSMul R₁ M] [SMul R R₁]\n    [IsScalarTower R R₁ M] : IsScalarTower R R₁ C(α, M) where\n  smul_assoc _ _ _ := ext fun _ => smul_assoc _ _ _\n\n"}
{"name":"ContinuousMap.instIsCentralScalar","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝⁵ : TopologicalSpace α\nR : Type u_3\nM : Type u_5\ninst✝⁴ : TopologicalSpace M\ninst✝³ : SMul R M\ninst✝² : SMul (MulOpposite R) M\ninst✝¹ : ContinuousConstSMul R M\ninst✝ : IsCentralScalar R M\n⊢ IsCentralScalar R (ContinuousMap α M)","decl":"instance [SMul R M] [SMul Rᵐᵒᵖ M] [ContinuousConstSMul R M] [IsCentralScalar R M] :\n    IsCentralScalar R C(α, M) where op_smul_eq_smul _ _ := ext fun _ => op_smul_eq_smul _ _\n\n"}
{"name":"ContinuousMap.instIsScalarTower_1","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝⁶ : TopologicalSpace α\nR : Type u_3\nM : Type u_5\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : SMul R M\ninst✝³ : ContinuousConstSMul R M\ninst✝² : Mul M\ninst✝¹ : ContinuousMul M\ninst✝ : IsScalarTower R M M\n⊢ IsScalarTower R (ContinuousMap α M) (ContinuousMap α M)","decl":"instance [SMul R M] [ContinuousConstSMul R M] [Mul M] [ContinuousMul M] [IsScalarTower R M M] :\n    IsScalarTower R C(α, M) C(α, M) where\n  smul_assoc _ _ _ := ext fun _ => smul_mul_assoc ..\n\n"}
{"name":"ContinuousMap.instSMulCommClass_1","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝⁶ : TopologicalSpace α\nR : Type u_3\nM : Type u_5\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : SMul R M\ninst✝³ : ContinuousConstSMul R M\ninst✝² : Mul M\ninst✝¹ : ContinuousMul M\ninst✝ : SMulCommClass R M M\n⊢ SMulCommClass R (ContinuousMap α M) (ContinuousMap α M)","decl":"instance [SMul R M] [ContinuousConstSMul R M] [Mul M] [ContinuousMul M] [SMulCommClass R M M] :\n    SMulCommClass R C(α, M) C(α, M) where\n  smul_comm _ _ _ := ext fun _ => (mul_smul_comm ..).symm\n\n"}
{"name":"ContinuousMap.instSMulCommClass_2","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝⁶ : TopologicalSpace α\nR : Type u_3\nM : Type u_5\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : SMul R M\ninst✝³ : ContinuousConstSMul R M\ninst✝² : Mul M\ninst✝¹ : ContinuousMul M\ninst✝ : SMulCommClass M R M\n⊢ SMulCommClass (ContinuousMap α M) R (ContinuousMap α M)","decl":"instance [SMul R M] [ContinuousConstSMul R M] [Mul M] [ContinuousMul M] [SMulCommClass M R M] :\n    SMulCommClass C(α, M) R C(α, M) where\n  smul_comm _ _ _ := ext fun _ => smul_comm (_ : M) ..\n\n"}
{"name":"ContinuousLinearMap.compLeftContinuous_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"R : Type u_3\nM : Type u_5\ninst✝¹¹ : TopologicalSpace M\nM₂ : Type u_6\ninst✝¹⁰ : TopologicalSpace M₂\ninst✝⁹ : Semiring R\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : ContinuousAdd M\ninst✝⁵ : Module R M\ninst✝⁴ : ContinuousConstSMul R M\ninst✝³ : ContinuousAdd M₂\ninst✝² : Module R M₂\ninst✝¹ : ContinuousConstSMul R M₂\nα : Type u_7\ninst✝ : TopologicalSpace α\ng : ContinuousLinearMap (RingHom.id R) M M₂\na✝ : ContinuousMap α M\n⊢ Eq ((ContinuousLinearMap.compLeftContinuous R α g) a✝) ((↑(AddMonoidHom.compLeftContinuous α (↑g).toAddMonoidHom ⋯)).toFun a✝)","decl":"/-- Composition on the left by a continuous linear map, as a `LinearMap`.\nSimilar to `LinearMap.compLeft`. -/\n@[simps]\nprotected def _root_.ContinuousLinearMap.compLeftContinuous (α : Type*) [TopologicalSpace α]\n    (g : M →L[R] M₂) : C(α, M) →ₗ[R] C(α, M₂) :=\n  { g.toLinearMap.toAddMonoidHom.compLeftContinuous α g.continuous with\n    map_smul' := fun c _ => ext fun _ => g.map_smul' c _ }\n\n"}
{"name":"ContinuousMap.coeFnLinearMap_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝⁶ : TopologicalSpace α\nR : Type u_3\nM : Type u_5\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : ContinuousAdd M\ninst✝¹ : Module R M\ninst✝ : ContinuousConstSMul R M\na✝¹ : ContinuousMap α M\na✝ : α\n⊢ Eq ((ContinuousMap.coeFnLinearMap R) a✝¹ a✝) ((↑ContinuousMap.coeFnAddMonoidHom).toFun a✝¹ a✝)","decl":"/-- Coercion to a function as a `LinearMap`. -/\n@[simps]\ndef coeFnLinearMap : C(α, M) →ₗ[R] α → M :=\n  { (coeFnAddMonoidHom : C(α, M) →+ _) with\n    map_smul' := coe_smul }\n\n"}
{"name":"ContinuousMap.evalCLM_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝⁶ : TopologicalSpace α\nR : Type u_3\nM : Type u_5\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : ContinuousAdd M\ninst✝¹ : Module R M\ninst✝ : ContinuousConstSMul R M\nx : α\nf : ContinuousMap α M\n⊢ Eq ((ContinuousMap.evalCLM R x) f) (f x)","decl":"/-- Evaluation at a point, as a continuous linear map. -/\n@[simps apply]\ndef evalCLM (x : α) : C(α, M) →L[R] M where\n  toFun f := f x\n  map_add' _ _ := add_apply _ _ x\n  map_smul' _ _ := smul_apply _ _ x\n\n"}
{"name":"ContinuousMap.C_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝⁵ : TopologicalSpace α\nR : Type u_2\ninst✝⁴ : CommSemiring R\nA : Type u_3\ninst✝³ : TopologicalSpace A\ninst✝² : Semiring A\ninst✝¹ : Algebra R A\ninst✝ : TopologicalSemiring A\nr : R\na : α\n⊢ Eq ((ContinuousMap.C r) a) ((algebraMap R A) r)","decl":"@[simp]\ntheorem ContinuousMap.C_apply (r : R) (a : α) : ContinuousMap.C r a = algebraMap R A r :=\n  rfl\n\n"}
{"name":"AlgHom.compLeftContinuous_apply_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"R : Type u_2\ninst✝⁹ : CommSemiring R\nA : Type u_3\ninst✝⁸ : TopologicalSpace A\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : TopologicalSemiring A\nA₂ : Type u_4\ninst✝⁴ : TopologicalSpace A₂\ninst✝³ : Semiring A₂\ninst✝² : Algebra R A₂\ninst✝¹ : TopologicalSemiring A₂\nα : Type u_5\ninst✝ : TopologicalSpace α\ng : AlgHom R A A₂\nhg : Continuous ⇑g\nf : ContinuousMap α A\na✝ : α\n⊢ Eq (((AlgHom.compLeftContinuous R g hg) f) a✝) (g (f a✝))","decl":"/-- Composition on the left by a (continuous) homomorphism of topological `R`-algebras, as an\n`AlgHom`. Similar to `AlgHom.compLeft`. -/\n@[simps!]\nprotected def AlgHom.compLeftContinuous {α : Type*} [TopologicalSpace α] (g : A →ₐ[R] A₂)\n    (hg : Continuous g) : C(α, A) →ₐ[R] C(α, A₂) :=\n  { g.toRingHom.compLeftContinuous α hg with\n    commutes' := fun _ => ContinuousMap.ext fun _ => g.commutes' _ }\n\n"}
{"name":"ContinuousMap.compRightAlgHom_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"R : Type u_2\ninst✝⁶ : CommSemiring R\nA : Type u_3\ninst✝⁵ : TopologicalSpace A\ninst✝⁴ : Semiring A\ninst✝³ : Algebra R A\ninst✝² : TopologicalSemiring A\nα : Type u_5\nβ : Type u_6\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : ContinuousMap α β\ng : ContinuousMap β A\n⊢ Eq ((ContinuousMap.compRightAlgHom R A f) g) (g.comp f)","decl":"/-- Precomposition of functions into a topological semiring by a continuous map is an algebra\nhomomorphism. -/\n@[simps]\ndef ContinuousMap.compRightAlgHom {α β : Type*} [TopologicalSpace α] [TopologicalSpace β]\n    (f : C(α, β)) : C(β, A) →ₐ[R] C(α, A) where\n  toFun g := g.comp f\n  map_zero' := ext fun _ ↦ rfl\n  map_add'  _ _ := ext fun _ ↦ rfl\n  map_one' := ext fun _ ↦ rfl\n  map_mul' _ _ := ext fun _ ↦ rfl\n  commutes' _ := ext fun _ ↦ rfl\n\n"}
{"name":"ContinuousMap.compRightAlgHom_continuous","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"R : Type u_2\ninst✝⁶ : CommSemiring R\nA : Type u_3\ninst✝⁵ : TopologicalSpace A\ninst✝⁴ : Semiring A\ninst✝³ : Algebra R A\ninst✝² : TopologicalSemiring A\nα : Type u_5\nβ : Type u_6\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : ContinuousMap α β\n⊢ Continuous ⇑(ContinuousMap.compRightAlgHom R A f)","decl":"theorem ContinuousMap.compRightAlgHom_continuous {α β : Type*} [TopologicalSpace α]\n    [TopologicalSpace β] (f : C(α, β)) : Continuous (compRightAlgHom R A f) :=\n  continuous_precomp f\n\n"}
{"name":"ContinuousMap.coeFnAlgHom_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝⁵ : TopologicalSpace α\nR : Type u_2\ninst✝⁴ : CommSemiring R\nA : Type u_3\ninst✝³ : TopologicalSpace A\ninst✝² : Semiring A\ninst✝¹ : Algebra R A\ninst✝ : TopologicalSemiring A\nf : ContinuousMap α A\na : α\n⊢ Eq ((ContinuousMap.coeFnAlgHom R) f a) (f a)","decl":"/-- Coercion to a function as an `AlgHom`. -/\n@[simps!]\ndef ContinuousMap.coeFnAlgHom : C(α, A) →ₐ[R] α → A :=\n  { (ContinuousMap.coeFnRingHom : C(α, A) →+* _) with\n    commutes' := fun _ => rfl }\n\n"}
{"name":"Subalgebra.separatesPoints_monotone","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝⁵ : TopologicalSpace α\nR : Type u_2\ninst✝⁴ : CommSemiring R\nA : Type u_3\ninst✝³ : TopologicalSpace A\ninst✝² : Semiring A\ninst✝¹ : Algebra R A\ninst✝ : TopologicalSemiring A\n⊢ Monotone fun s => s.SeparatesPoints","decl":"theorem Subalgebra.separatesPoints_monotone :\n    Monotone fun s : Subalgebra R C(α, A) => s.SeparatesPoints := fun s s' r h x y n => by\n  obtain ⟨f, m, w⟩ := h n\n  rcases m with ⟨f, ⟨m, rfl⟩⟩\n  exact ⟨_, ⟨f, ⟨r m, rfl⟩⟩, w⟩\n\n"}
{"name":"algebraMap_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝⁵ : TopologicalSpace α\nR : Type u_2\ninst✝⁴ : CommSemiring R\nA : Type u_3\ninst✝³ : TopologicalSpace A\ninst✝² : Semiring A\ninst✝¹ : Algebra R A\ninst✝ : TopologicalSemiring A\nk : R\na : α\n⊢ Eq (((algebraMap R (ContinuousMap α A)) k) a) (HSMul.hSMul k 1)","decl":"@[simp]\ntheorem algebraMap_apply (k : R) (a : α) : algebraMap R C(α, A) k a = k • (1 : A) := by\n  rw [Algebra.algebraMap_eq_smul_one]\n  rfl\n\n"}
{"name":"Subalgebra.SeparatesPoints.strongly","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\n𝕜 : Type u_5\ninst✝² : TopologicalSpace 𝕜\ninst✝¹ : Field 𝕜\ninst✝ : TopologicalRing 𝕜\ns : Subalgebra 𝕜 (ContinuousMap α 𝕜)\nh : s.SeparatesPoints\n⊢ (↑s).SeparatesPointsStrongly","decl":"/-- Working in continuous functions into a topological field,\na subalgebra of functions that separates points also separates points strongly.\n\nBy the hypothesis, we can find a function `f` so `f x ≠ f y`.\nBy an affine transformation in the field we can arrange so that `f x = a` and `f x = b`.\n-/\ntheorem Subalgebra.SeparatesPoints.strongly {s : Subalgebra 𝕜 C(α, 𝕜)} (h : s.SeparatesPoints) :\n    (s : Set C(α, 𝕜)).SeparatesPointsStrongly := fun v x y => by\n  by_cases n : x = y\n  · subst n\n    exact ⟨_, (v x • (1 : s) : s).prop, mul_one _, mul_one _⟩\n  obtain ⟨_, ⟨f, hf, rfl⟩, hxy⟩ := h n\n  replace hxy : f x - f y ≠ 0 := sub_ne_zero_of_ne hxy\n  let a := v x\n  let b := v y\n  let f' : s :=\n    ((b - a) * (f x - f y)⁻¹) • (algebraMap _ s (f x) - (⟨f, hf⟩ : s)) + algebraMap _ s a\n  refine ⟨f', f'.prop, ?_, ?_⟩\n  · simp [a, b, f']\n  · simp [a, b, f', inv_mul_cancel_right₀ hxy]\n\n"}
{"name":"ContinuousMap.subsingleton_subalgebra","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝⁴ : TopologicalSpace α\nR : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : TopologicalSpace R\ninst✝¹ : TopologicalSemiring R\ninst✝ : Subsingleton α\n⊢ Subsingleton (Subalgebra R (ContinuousMap α R))","decl":"instance ContinuousMap.subsingleton_subalgebra (α : Type*) [TopologicalSpace α] (R : Type*)\n    [CommSemiring R] [TopologicalSpace R] [TopologicalSemiring R] [Subsingleton α] :\n    Subsingleton (Subalgebra R C(α, R)) :=\n  ⟨fun s₁ s₂ => by\n    cases isEmpty_or_nonempty α\n    · have : Subsingleton C(α, R) := DFunLike.coe_injective.subsingleton\n      subsingleton\n    · inhabit α\n      ext f\n      have h : f = algebraMap R C(α, R) (f default) := by\n        ext x'\n        simp only [mul_one, Algebra.id.smul_eq_mul, algebraMap_apply]\n        congr\n        simp [eq_iff_true_of_subsingleton]\n      rw [h]\n      simp only [Subalgebra.algebraMap_mem]⟩\n\n"}
{"name":"ContinuousMap.coe_smul'","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝⁶ : TopologicalSpace α\nR : Type u_2\ninst✝⁵ : Semiring R\ninst✝⁴ : TopologicalSpace R\nM : Type u_3\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : ContinuousSMul R M\nf : ContinuousMap α R\ng : ContinuousMap α M\n⊢ Eq (⇑(HSMul.hSMul f g)) (HSMul.hSMul ⇑f ⇑g)","decl":"/-- Coercion to a function for a scalar-valued continuous map multiplying a vector-valued one\n(as opposed to `ContinuousMap.coe_smul` which is multiplication by a constant scalar). -/\n@[simp] lemma coe_smul' (f : C(α, R)) (g : C(α, M)) :\n    ⇑(f • g) = ⇑f • ⇑g :=\n  rfl\n\n"}
{"name":"ContinuousMap.smul_apply'","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"α : Type u_1\ninst✝⁶ : TopologicalSpace α\nR : Type u_2\ninst✝⁵ : Semiring R\ninst✝⁴ : TopologicalSpace R\nM : Type u_3\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : ContinuousSMul R M\nf : ContinuousMap α R\ng : ContinuousMap α M\nx : α\n⊢ Eq ((HSMul.hSMul f g) x) (HSMul.hSMul (f x) (g x))","decl":"/-- Evaluation of a scalar-valued continuous map multiplying a vector-valued one\n(as opposed to `ContinuousMap.smul_apply` which is multiplication by a constant scalar). -/\n-- (this doesn't need to be @[simp] since it can be derived from `coe_smul'` and `Pi.smul_apply'`)\nlemma smul_apply' (f : C(α, R)) (g : C(α, M)) (x : α) :\n    (f • g) x = f x • g x :=\n  rfl\n\n"}
{"name":"ContinuousMap.evalAlgHom_apply","module":"Mathlib.Topology.ContinuousMap.Algebra","initialProofState":"X : Type u_1\nS : Type u_2\nR : Type u_3\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : CommSemiring S\ninst✝³ : CommSemiring R\ninst✝² : Algebra S R\ninst✝¹ : TopologicalSpace R\ninst✝ : TopologicalSemiring R\nx : X\nf : ContinuousMap X R\n⊢ Eq ((ContinuousMap.evalAlgHom S R x) f) (f x)","decl":"/-- Evaluation of continuous maps at a point, bundled as an algebra homomorphism. -/\n@[simps]\ndef ContinuousMap.evalAlgHom (x : X) : C(X, R) →ₐ[S] R where\n  toFun f := f x\n  map_zero' := rfl\n  map_one' := rfl\n  map_add' _ _ := rfl\n  map_mul' _ _ := rfl\n  commutes' _ := rfl\n"}
