{"name":"Subalgebra.isIntegral_iff","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nS : Subalgebra R A\n⊢ Iff (Algebra.IsIntegral R (Subtype fun x => Membership.mem S x)) (∀ (x : A), Membership.mem S x → IsIntegral R x)","decl":"theorem Subalgebra.isIntegral_iff (S : Subalgebra R A) :\n    Algebra.IsIntegral R S ↔ ∀ x ∈ S, IsIntegral R x :=\n  Algebra.isIntegral_def.trans <| .trans\n    (forall_congr' fun _ ↦ (isIntegral_algHom_iff S.val Subtype.val_injective).symm) Subtype.forall\n\n"}
{"name":"Algebra.IsIntegral.of_injective","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nA : Type u_5\nB : Type u_6\ninst✝⁴ : Ring A\ninst✝³ : Ring B\ninst✝² : Algebra R A\ninst✝¹ : Algebra R B\nf : AlgHom R A B\nhf : Function.Injective ⇑f\ninst✝ : Algebra.IsIntegral R B\n⊢ Algebra.IsIntegral R A","decl":"theorem Algebra.IsIntegral.of_injective (f : A →ₐ[R] B) (hf : Function.Injective f)\n    [Algebra.IsIntegral R B] : Algebra.IsIntegral R A :=\n  ⟨fun _ ↦ (isIntegral_algHom_iff f hf).mp (isIntegral _)⟩\n\n"}
{"name":"Algebra.IsIntegral.of_surjective","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nA : Type u_5\nB : Type u_6\ninst✝⁴ : Ring A\ninst✝³ : Ring B\ninst✝² : Algebra R A\ninst✝¹ : Algebra R B\ninst✝ : Algebra.IsIntegral R A\nf : AlgHom R A B\nhf : Function.Surjective ⇑f\n⊢ Algebra.IsIntegral R B","decl":"/-- Homomorphic image of an integral algebra is an integral algebra. -/\ntheorem Algebra.IsIntegral.of_surjective [Algebra.IsIntegral R A]\n    (f : A →ₐ[R] B) (hf : Function.Surjective f) : Algebra.IsIntegral R B :=\n  isIntegral_def.mpr fun b ↦ let ⟨a, ha⟩ := hf b; ha ▸ (isIntegral_def.mp ‹_› a).map f\n\n"}
{"name":"AlgEquiv.isIntegral_iff","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nA : Type u_5\nB : Type u_6\ninst✝³ : Ring A\ninst✝² : Ring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\ne : AlgEquiv R A B\n⊢ Iff (Algebra.IsIntegral R A) (Algebra.IsIntegral R B)","decl":"theorem AlgEquiv.isIntegral_iff (e : A ≃ₐ[R] B) : Algebra.IsIntegral R A ↔ Algebra.IsIntegral R B :=\n  ⟨fun h ↦ h.of_injective e.symm e.symm.injective, fun h ↦ h.of_injective e e.injective⟩\n\n"}
{"name":"Module.End.isIntegral","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Type u_5\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.Finite R M\n⊢ Algebra.IsIntegral R (Module.End R M)","decl":"instance Module.End.isIntegral {M : Type*} [AddCommGroup M] [Module R M] [Module.Finite R M] :\n    Algebra.IsIntegral R (Module.End R M) :=\n  ⟨LinearMap.exists_monic_and_aeval_eq_zero R⟩\n\n"}
{"name":"IsIntegral.of_finite","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\nB : Type u_3\ninst✝³ : CommRing R\ninst✝² : Ring B\ninst✝¹ : Algebra R B\ninst✝ : Module.Finite R B\nx : B\n⊢ IsIntegral R x","decl":"variable (R) in\ntheorem IsIntegral.of_finite [Module.Finite R B] (x : B) : IsIntegral R x :=\n  (isIntegral_algHom_iff (Algebra.lmul R B) Algebra.lmul_injective).mp\n    (Algebra.IsIntegral.isIntegral _)\n\n"}
{"name":"isIntegral_of_noetherian","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\nB : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Ring B\ninst✝ : Algebra R B\nx✝ : IsNoetherian R B\nx : B\n⊢ IsIntegral R x","decl":"theorem isIntegral_of_noetherian (_ : IsNoetherian R B) (x : B) : IsIntegral R x :=\n  .of_finite R x\n\n"}
{"name":"Algebra.IsIntegral.of_finite","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\nB : Type u_3\ninst✝³ : CommRing R\ninst✝² : Ring B\ninst✝¹ : Algebra R B\ninst✝ : Module.Finite R B\n⊢ Algebra.IsIntegral R B","decl":"variable (R B) in\ninstance Algebra.IsIntegral.of_finite [Module.Finite R B] : Algebra.IsIntegral R B :=\n  ⟨.of_finite R⟩\n\n"}
{"name":"IsIntegral.of_mem_of_fg","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\nB : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Ring B\ninst✝ : Algebra R B\nS : Subalgebra R B\nHS : (Subalgebra.toSubmodule S).FG\nx : B\nhx : Membership.mem S x\n⊢ IsIntegral R x","decl":"/-- If `S` is a sub-`R`-algebra of `A` and `S` is finitely-generated as an `R`-module,\n  then all elements of `S` are integral over `R`. -/\ntheorem IsIntegral.of_mem_of_fg (S : Subalgebra R B)\n    (HS : S.toSubmodule.FG) (x : B) (hx : x ∈ S) : IsIntegral R x :=\n  have : Module.Finite R S := ⟨(fg_top _).mpr HS⟩\n  (isIntegral_algHom_iff S.val Subtype.val_injective).mpr (.of_finite R (⟨x, hx⟩ : S))\n\n"}
{"name":"isIntegral_of_submodule_noetherian","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\nB : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Ring B\ninst✝ : Algebra R B\nS : Subalgebra R B\nH : IsNoetherian R (Subtype fun x => Membership.mem (Subalgebra.toSubmodule S) x)\nx : B\nhx : Membership.mem S x\n⊢ IsIntegral R x","decl":"theorem isIntegral_of_submodule_noetherian (S : Subalgebra R B)\n    (H : IsNoetherian R (Subalgebra.toSubmodule S)) (x : B) (hx : x ∈ S) : IsIntegral R x :=\n  .of_mem_of_fg _ ((fg_top _).mp <| H.noetherian _) _ hx\n\n"}
{"name":"isIntegral_of_smul_mem_submodule","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing A\ninst✝⁵ : Algebra R A\nM : Type u_5\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : Module A M\ninst✝¹ : IsScalarTower R A M\ninst✝ : NoZeroSMulDivisors A M\nN : Submodule R M\nhN : Ne N Bot.bot\nhN' : N.FG\nx : A\nhx : ∀ (n : M), Membership.mem N n → Membership.mem N (HSMul.hSMul x n)\n⊢ IsIntegral R x","decl":"/-- Suppose `A` is an `R`-algebra, `M` is an `A`-module such that `a • m ≠ 0` for all non-zero `a`\nand `m`. If `x : A` fixes a nontrivial f.g. `R`-submodule `N` of `M`, then `x` is `R`-integral. -/\ntheorem isIntegral_of_smul_mem_submodule {M : Type*} [AddCommGroup M] [Module R M] [Module A M]\n    [IsScalarTower R A M] [NoZeroSMulDivisors A M] (N : Submodule R M) (hN : N ≠ ⊥) (hN' : N.FG)\n    (x : A) (hx : ∀ n ∈ N, x • n ∈ N) : IsIntegral R x := by\n  let A' : Subalgebra R A :=\n    { carrier := { x | ∀ n ∈ N, x • n ∈ N }\n      mul_mem' := fun {a b} ha hb n hn => smul_smul a b n ▸ ha _ (hb _ hn)\n      one_mem' := fun n hn => (one_smul A n).symm ▸ hn\n      add_mem' := fun {a b} ha hb n hn => (add_smul a b n).symm ▸ N.add_mem (ha _ hn) (hb _ hn)\n      zero_mem' := fun n _hn => (zero_smul A n).symm ▸ N.zero_mem\n      algebraMap_mem' := fun r n hn => (algebraMap_smul A r n).symm ▸ N.smul_mem r hn }\n  let f : A' →ₐ[R] Module.End R N :=\n    AlgHom.ofLinearMap\n      { toFun := fun x => (DistribMulAction.toLinearMap R M x).restrict x.prop\n        -- Porting note: was\n                -- `fun x y => LinearMap.ext fun n => Subtype.ext <| add_smul x y n`\n        map_add' := by intros x y; ext; exact add_smul _ _ _\n        -- Porting note: was\n                --  `fun r s => LinearMap.ext fun n => Subtype.ext <| smul_assoc r s n`\n        map_smul' := by intros r s; ext; apply smul_assoc }\n      -- Porting note: the next two lines were\n      --`(LinearMap.ext fun n => Subtype.ext <| one_smul _ _) fun x y =>`\n      --`LinearMap.ext fun n => Subtype.ext <| mul_smul x y n`\n      (by ext; apply one_smul)\n      (by intros x y; ext; apply mul_smul)\n  obtain ⟨a, ha₁, ha₂⟩ : ∃ a ∈ N, a ≠ (0 : M) := by\n    by_contra! h'\n    apply hN\n    rwa [eq_bot_iff]\n  have : Function.Injective f := by\n    show Function.Injective f.toLinearMap\n    rw [← LinearMap.ker_eq_bot, eq_bot_iff]\n    intro s hs\n    have : s.1 • a = 0 := congr_arg Subtype.val (LinearMap.congr_fun hs ⟨a, ha₁⟩)\n    exact Subtype.ext ((eq_zero_or_eq_zero_of_smul_eq_zero this).resolve_right ha₂)\n  show IsIntegral R (A'.val ⟨x, hx⟩)\n  rw [isIntegral_algHom_iff A'.val Subtype.val_injective, ← isIntegral_algHom_iff f this]\n  haveI : Module.Finite R N := by rwa [Module.finite_def, Submodule.fg_top]\n  apply Algebra.IsIntegral.isIntegral\n\n"}
{"name":"RingHom.Finite.to_isIntegral","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nh : f.Finite\n⊢ f.IsIntegral","decl":"theorem RingHom.Finite.to_isIntegral (h : f.Finite) : f.IsIntegral :=\n  letI := f.toAlgebra\n  fun _ ↦ IsIntegral.of_mem_of_fg ⊤ h.1 _ trivial\n\n"}
{"name":"RingHom.IsIntegral.of_finite","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nh : f.Finite\n⊢ f.IsIntegral","decl":"alias RingHom.IsIntegral.of_finite := RingHom.Finite.to_isIntegral\n\n"}
{"name":"RingHom.IsIntegralElem.of_mem_closure","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nx y z : S\nhx : f.IsIntegralElem x\nhy : f.IsIntegralElem y\nhz : Membership.mem (Subring.closure (Insert.insert x (Singleton.singleton y))) z\n⊢ f.IsIntegralElem z","decl":"theorem RingHom.IsIntegralElem.of_mem_closure {x y z : S} (hx : f.IsIntegralElem x)\n    (hy : f.IsIntegralElem y) (hz : z ∈ Subring.closure ({x, y} : Set S)) : f.IsIntegralElem z := by\n  letI : Algebra R S := f.toAlgebra\n  have := (IsIntegral.fg_adjoin_singleton hx).mul (IsIntegral.fg_adjoin_singleton hy)\n  rw [← Algebra.adjoin_union_coe_submodule, Set.singleton_union] at this\n  exact\n    IsIntegral.of_mem_of_fg (Algebra.adjoin R {x, y}) this z\n      (Algebra.mem_adjoin_iff.2 <| Subring.closure_mono Set.subset_union_right hz)\n\n"}
{"name":"IsIntegral.of_mem_closure","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nx y z : A\nhx : IsIntegral R x\nhy : IsIntegral R y\nhz : Membership.mem (Subring.closure (Insert.insert x (Singleton.singleton y))) z\n⊢ IsIntegral R z","decl":"nonrec theorem IsIntegral.of_mem_closure {x y z : A} (hx : IsIntegral R x) (hy : IsIntegral R y)\n    (hz : z ∈ Subring.closure ({x, y} : Set A)) : IsIntegral R z :=\n  hx.of_mem_closure (algebraMap R A) hy hz\n\n"}
{"name":"RingHom.IsIntegralElem.add","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nx y : S\nhx : f.IsIntegralElem x\nhy : f.IsIntegralElem y\n⊢ f.IsIntegralElem (HAdd.hAdd x y)","decl":"theorem RingHom.IsIntegralElem.add (f : R →+* S) {x y : S}\n    (hx : f.IsIntegralElem x) (hy : f.IsIntegralElem y) :\n    f.IsIntegralElem (x + y) :=\n  hx.of_mem_closure f hy <|\n    Subring.add_mem _ (Subring.subset_closure (Or.inl rfl)) (Subring.subset_closure (Or.inr rfl))\n\n"}
{"name":"IsIntegral.add","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nx y : A\nhx : IsIntegral R x\nhy : IsIntegral R y\n⊢ IsIntegral R (HAdd.hAdd x y)","decl":"nonrec theorem IsIntegral.add {x y : A} (hx : IsIntegral R x) (hy : IsIntegral R y) :\n    IsIntegral R (x + y) :=\n  hx.add (algebraMap R A) hy\n\n"}
{"name":"RingHom.IsIntegralElem.neg","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nx : S\nhx : f.IsIntegralElem x\n⊢ f.IsIntegralElem (Neg.neg x)","decl":"theorem RingHom.IsIntegralElem.neg {x : S} (hx : f.IsIntegralElem x) : f.IsIntegralElem (-x) :=\n  hx.of_mem_closure f hx (Subring.neg_mem _ (Subring.subset_closure (Or.inl rfl)))\n\n"}
{"name":"RingHom.IsIntegralElem.of_neg","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nx : S\nh : f.IsIntegralElem (Neg.neg x)\n⊢ f.IsIntegralElem x","decl":"theorem RingHom.IsIntegralElem.of_neg {x : S} (h : f.IsIntegralElem (-x)) : f.IsIntegralElem x :=\n  neg_neg x ▸ h.neg\n\n"}
{"name":"RingHom.IsIntegralElem.neg_iff","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nx : S\n⊢ Iff (f.IsIntegralElem (Neg.neg x)) (f.IsIntegralElem x)","decl":"@[simp]\ntheorem RingHom.IsIntegralElem.neg_iff {x : S} : f.IsIntegralElem (-x) ↔ f.IsIntegralElem x :=\n  ⟨fun h => h.of_neg, fun h => h.neg⟩\n\n"}
{"name":"IsIntegral.neg","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\nB : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Ring B\ninst✝ : Algebra R B\nx : B\nhx : IsIntegral R x\n⊢ IsIntegral R (Neg.neg x)","decl":"theorem IsIntegral.neg {x : B} (hx : IsIntegral R x) : IsIntegral R (-x) :=\n  .of_mem_of_fg _ hx.fg_adjoin_singleton _ (Subalgebra.neg_mem _ <| Algebra.subset_adjoin rfl)\n\n"}
{"name":"IsIntegral.of_neg","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\nB : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Ring B\ninst✝ : Algebra R B\nx : B\nhx : IsIntegral R (Neg.neg x)\n⊢ IsIntegral R x","decl":"theorem IsIntegral.of_neg {x : B} (hx : IsIntegral R (-x)) : IsIntegral R x :=\n  neg_neg x ▸ hx.neg\n\n"}
{"name":"IsIntegral.neg_iff","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\nB : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Ring B\ninst✝ : Algebra R B\nx : B\n⊢ Iff (IsIntegral R (Neg.neg x)) (IsIntegral R x)","decl":"@[simp]\ntheorem IsIntegral.neg_iff {x : B} : IsIntegral R (-x) ↔ IsIntegral R x :=\n  ⟨IsIntegral.of_neg, IsIntegral.neg⟩\n\n"}
{"name":"RingHom.IsIntegralElem.sub","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nx y : S\nhx : f.IsIntegralElem x\nhy : f.IsIntegralElem y\n⊢ f.IsIntegralElem (HSub.hSub x y)","decl":"theorem RingHom.IsIntegralElem.sub {x y : S} (hx : f.IsIntegralElem x) (hy : f.IsIntegralElem y) :\n    f.IsIntegralElem (x - y) := by\n  simpa only [sub_eq_add_neg] using hx.add f (hy.neg f)\n\n"}
{"name":"IsIntegral.sub","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nx y : A\nhx : IsIntegral R x\nhy : IsIntegral R y\n⊢ IsIntegral R (HSub.hSub x y)","decl":"nonrec theorem IsIntegral.sub {x y : A} (hx : IsIntegral R x) (hy : IsIntegral R y) :\n    IsIntegral R (x - y) :=\n  hx.sub (algebraMap R A) hy\n\n"}
{"name":"RingHom.IsIntegralElem.mul","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nx y : S\nhx : f.IsIntegralElem x\nhy : f.IsIntegralElem y\n⊢ f.IsIntegralElem (HMul.hMul x y)","decl":"theorem RingHom.IsIntegralElem.mul {x y : S} (hx : f.IsIntegralElem x) (hy : f.IsIntegralElem y) :\n    f.IsIntegralElem (x * y) :=\n  hx.of_mem_closure f hy\n    (Subring.mul_mem _ (Subring.subset_closure (Or.inl rfl)) (Subring.subset_closure (Or.inr rfl)))\n\n"}
{"name":"IsIntegral.mul","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nx y : A\nhx : IsIntegral R x\nhy : IsIntegral R y\n⊢ IsIntegral R (HMul.hMul x y)","decl":"nonrec theorem IsIntegral.mul {x y : A} (hx : IsIntegral R x) (hy : IsIntegral R y) :\n    IsIntegral R (x * y) :=\n  hx.mul (algebraMap R A) hy\n\n"}
{"name":"IsIntegral.smul","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"B : Type u_3\nS : Type u_4\ninst✝⁶ : Ring B\ninst✝⁵ : CommRing S\nR : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : Algebra R B\ninst✝² : Algebra S B\ninst✝¹ : Algebra R S\ninst✝ : IsScalarTower R S B\nx : B\nr : R\nhx : IsIntegral S x\n⊢ IsIntegral S (HSMul.hSMul r x)","decl":"theorem IsIntegral.smul {R} [CommSemiring R] [Algebra R B] [Algebra S B] [Algebra R S]\n    [IsScalarTower R S B] {x : B} (r : R)(hx : IsIntegral S x) : IsIntegral S (r • x) :=\n  .of_mem_of_fg _ hx.fg_adjoin_singleton _ <| by\n    rw [← algebraMap_smul S]; apply Subalgebra.smul_mem; exact Algebra.subset_adjoin rfl\n\n"}
{"name":"mem_integralClosure_iff","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\na : A\n⊢ Iff (Membership.mem (integralClosure R A) a) (IsIntegral R a)","decl":"theorem mem_integralClosure_iff {a : A} : a ∈ integralClosure R A ↔ IsIntegral R a :=\n  Iff.rfl\n\n"}
{"name":"Algebra.IsIntegral.prod","module":"Mathlib.RingTheory.IntegralClosure.Algebra.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nA : Type u_5\nB : Type u_6\ninst✝⁵ : Ring A\ninst✝⁴ : Algebra R A\ninst✝³ : Ring B\ninst✝² : Algebra R B\ninst✝¹ : Algebra.IsIntegral R A\ninst✝ : Algebra.IsIntegral R B\n⊢ Algebra.IsIntegral R (Prod A B)","decl":"/-- Product of two integral algebras is an integral algebra. -/\ninstance Algebra.IsIntegral.prod [Algebra.IsIntegral R A] [Algebra.IsIntegral R B] :\n    Algebra.IsIntegral R (A × B) :=\n  Algebra.isIntegral_def.mpr fun x ↦\n    (Algebra.isIntegral_def.mp ‹_› x.1).pair (Algebra.isIntegral_def.mp ‹_› x.2)\n\n"}
