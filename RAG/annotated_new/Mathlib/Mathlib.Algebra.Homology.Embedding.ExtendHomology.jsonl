{"name":"HomologicalComplex.extend.comp_d_eq_zero_iff","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\nj k : ι\nj' k' : ι'\nhj' : Eq (e.f j) j'\nhk : Eq (c.next j) k\nhk' : Eq (c'.next j') k'\nW : C\nφ : Quiver.Hom W (K.X j)\n⊢ Iff (Eq (CategoryTheory.CategoryStruct.comp φ (K.d j k)) 0) (Eq (CategoryTheory.CategoryStruct.comp φ (CategoryTheory.CategoryStruct.comp (K.extendXIso e hj').inv ((K.extend e).d j' k'))) 0)","decl":"include hk hk' in\nlemma comp_d_eq_zero_iff ⦃W : C⦄ (φ : W ⟶ K.X j) :\n    φ ≫ K.d j k = 0 ↔ φ ≫ (K.extendXIso e hj').inv ≫ (K.extend e).d j' k' = 0 := by\n  by_cases hjk : c.Rel j k\n  · have hk' : e.f k = k' := by rw [← hk', ← hj', c'.next_eq' (e.rel hjk)]\n    rw [K.extend_d_eq e hj' hk', Iso.inv_hom_id_assoc,\n      ← cancel_mono (K.extendXIso e hk').inv, zero_comp, assoc]\n  · simp only [K.shape _ _ hjk, comp_zero, true_iff]\n    rw [K.extend_d_from_eq_zero e j' k' j hj', comp_zero, comp_zero]\n    rw [hk]\n    exact hjk\n\n"}
{"name":"HomologicalComplex.extend.d_comp_eq_zero_iff","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\ni j : ι\ni' j' : ι'\nhj' : Eq (e.f j) j'\nhi : Eq (c.prev j) i\nhi' : Eq (c'.prev j') i'\nW : C\nφ : Quiver.Hom (K.X j) W\n⊢ Iff (Eq (CategoryTheory.CategoryStruct.comp (K.d i j) φ) 0) (Eq (CategoryTheory.CategoryStruct.comp ((K.extend e).d i' j') (CategoryTheory.CategoryStruct.comp (K.extendXIso e hj').hom φ)) 0)","decl":"include hi hi' in\nlemma d_comp_eq_zero_iff ⦃W : C⦄ (φ : K.X j ⟶ W) :\n    K.d i j ≫ φ = 0 ↔ (K.extend e).d i' j' ≫ (K.extendXIso e hj').hom ≫ φ = 0 := by\n  by_cases hij : c.Rel i j\n  · have hi' : e.f i = i' := by rw [← hi', ← hj', c'.prev_eq' (e.rel hij)]\n    rw [K.extend_d_eq e hi' hj', assoc, assoc, Iso.inv_hom_id_assoc,\n      ← cancel_epi (K.extendXIso e hi').hom, comp_zero]\n  · simp only [K.shape _ _ hij, zero_comp, true_iff]\n    rw [K.extend_d_to_eq_zero e i' j' j hj', zero_comp]\n    rw [hi]\n    exact hij\n\n"}
{"name":"HomologicalComplex.extend.leftHomologyData.lift_d_comp_eq_zero_iff'","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\ni j k : ι\ni' j' : ι'\nhj' : Eq (e.f j) j'\nhi : Eq (c.prev j) i\nhi' : Eq (c'.prev j') i'\ncone : CategoryTheory.Limits.KernelFork (K.d j k)\nhcone : CategoryTheory.Limits.IsLimit cone\nW : C\nf' : Quiver.Hom (K.X i) cone.pt\nhf' : Eq (CategoryTheory.CategoryStruct.comp f' (CategoryTheory.Limits.Fork.ι cone)) (K.d i j)\nf'' : Quiver.Hom ((K.extend e).X i') cone.pt\nhf'' : Eq (CategoryTheory.CategoryStruct.comp f'' (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.ι cone) (K.extendXIso e hj').inv)) ((K.extend e).d i' j')\nφ : Quiver.Hom cone.pt W\n⊢ Iff (Eq (CategoryTheory.CategoryStruct.comp f' φ) 0) (Eq (CategoryTheory.CategoryStruct.comp f'' φ) 0)","decl":"include hi hi' hcone in\n/-- Auxiliary lemma for `lift_d_comp_eq_zero_iff`. -/\nlemma lift_d_comp_eq_zero_iff' ⦃W : C⦄ (f' : K.X i ⟶ cone.pt)\n    (hf' : f' ≫ cone.ι = K.d i j)\n    (f'' : (K.extend e).X i' ⟶ cone.pt)\n    (hf'' : f'' ≫ cone.ι ≫ (extendXIso K e hj').inv = (K.extend e).d i' j')\n    (φ : cone.pt ⟶ W) :\n    f' ≫ φ = 0 ↔ f'' ≫ φ = 0 := by\n  by_cases hij : c.Rel i j\n  · have hi'' : e.f i = i' := by rw [← hi', ← hj', c'.prev_eq' (e.rel hij)]\n    have : (K.extendXIso e hi'').hom ≫ f' = f'' := by\n      apply Fork.IsLimit.hom_ext hcone\n      rw [assoc, hf', ← cancel_mono (extendXIso K e hj').inv, assoc, assoc, hf'',\n        K.extend_d_eq e hi'' hj']\n    rw [← cancel_epi (K.extendXIso e hi'').hom, comp_zero, ← this, assoc]\n  · have h₁ : f' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      simp only [zero_comp, hf', K.shape _ _ hij]\n    have h₂ : f'' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      dsimp\n      rw [← cancel_mono (extendXIso K e hj').inv, assoc, hf'', zero_comp, zero_comp,\n        K.extend_d_to_eq_zero e i' j' j hj']\n      rw [hi]\n      exact hij\n    simp [h₁, h₂]\n\n"}
{"name":"HomologicalComplex.extend.leftHomologyData_H","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\ni j k : ι\ni' j' k' : ι'\nhj' : Eq (e.f j) j'\nh : (K.sc' i j k).LeftHomologyData\n⊢ Eq (HomologicalComplex.extend.leftHomologyData K e hj' h).H h.H","decl":"open leftHomologyData in\n/-- The left homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a left homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def leftHomologyData (h : (K.sc' i j k).LeftHomologyData) :\n    ((K.extend e).sc' i' j' k').LeftHomologyData where\n  K := h.K\n  H := h.H\n  i := h.i ≫ (extendXIso K e hj').inv\n  π := h.π\n  wi := by\n    dsimp\n    rw [assoc, ← comp_d_eq_zero_iff K e hj' hk hk']\n    exact h.wi\n  hi := isLimitKernelFork K e hj' hk hk' _ h.hi\n  wπ := by\n    dsimp\n    rw [← lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' _ h.hi]\n    exact h.wπ\n  hπ := isColimitCokernelCofork K e hj' hi hi' hk hk' _ h.hi _ h.hπ\n\n"}
{"name":"HomologicalComplex.extend.leftHomologyData_i","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\ni j k : ι\ni' j' k' : ι'\nhj' : Eq (e.f j) j'\nh : (K.sc' i j k).LeftHomologyData\n⊢ Eq (HomologicalComplex.extend.leftHomologyData K e hj' h).i (CategoryTheory.CategoryStruct.comp h.i (K.extendXIso e hj').inv)","decl":"open leftHomologyData in\n/-- The left homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a left homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def leftHomologyData (h : (K.sc' i j k).LeftHomologyData) :\n    ((K.extend e).sc' i' j' k').LeftHomologyData where\n  K := h.K\n  H := h.H\n  i := h.i ≫ (extendXIso K e hj').inv\n  π := h.π\n  wi := by\n    dsimp\n    rw [assoc, ← comp_d_eq_zero_iff K e hj' hk hk']\n    exact h.wi\n  hi := isLimitKernelFork K e hj' hk hk' _ h.hi\n  wπ := by\n    dsimp\n    rw [← lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' _ h.hi]\n    exact h.wπ\n  hπ := isColimitCokernelCofork K e hj' hi hi' hk hk' _ h.hi _ h.hπ\n\n"}
{"name":"HomologicalComplex.extend.leftHomologyData_π","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\ni j k : ι\ni' j' k' : ι'\nhj' : Eq (e.f j) j'\nh : (K.sc' i j k).LeftHomologyData\n⊢ Eq (HomologicalComplex.extend.leftHomologyData K e hj' h).π h.π","decl":"open leftHomologyData in\n/-- The left homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a left homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def leftHomologyData (h : (K.sc' i j k).LeftHomologyData) :\n    ((K.extend e).sc' i' j' k').LeftHomologyData where\n  K := h.K\n  H := h.H\n  i := h.i ≫ (extendXIso K e hj').inv\n  π := h.π\n  wi := by\n    dsimp\n    rw [assoc, ← comp_d_eq_zero_iff K e hj' hk hk']\n    exact h.wi\n  hi := isLimitKernelFork K e hj' hk hk' _ h.hi\n  wπ := by\n    dsimp\n    rw [← lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' _ h.hi]\n    exact h.wπ\n  hπ := isColimitCokernelCofork K e hj' hi hi' hk hk' _ h.hi _ h.hπ\n\n"}
{"name":"HomologicalComplex.extend.leftHomologyData_K","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\ni j k : ι\ni' j' k' : ι'\nhj' : Eq (e.f j) j'\nh : (K.sc' i j k).LeftHomologyData\n⊢ Eq (HomologicalComplex.extend.leftHomologyData K e hj' h).K h.K","decl":"open leftHomologyData in\n/-- The left homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a left homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def leftHomologyData (h : (K.sc' i j k).LeftHomologyData) :\n    ((K.extend e).sc' i' j' k').LeftHomologyData where\n  K := h.K\n  H := h.H\n  i := h.i ≫ (extendXIso K e hj').inv\n  π := h.π\n  wi := by\n    dsimp\n    rw [assoc, ← comp_d_eq_zero_iff K e hj' hk hk']\n    exact h.wi\n  hi := isLimitKernelFork K e hj' hk hk' _ h.hi\n  wπ := by\n    dsimp\n    rw [← lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' _ h.hi]\n    exact h.wπ\n  hπ := isColimitCokernelCofork K e hj' hi hi' hk hk' _ h.hi _ h.hπ\n\n"}
{"name":"HomologicalComplex.extend.rightHomologyData.d_comp_desc_eq_zero_iff'","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\ni j k : ι\nj' k' : ι'\nhj' : Eq (e.f j) j'\nhk : Eq (c.next j) k\nhk' : Eq (c'.next j') k'\ncocone : CategoryTheory.Limits.CokernelCofork (K.d i j)\nhcocone : CategoryTheory.Limits.IsColimit cocone\nW : C\nf' : Quiver.Hom cocone.pt (K.X k)\nhf' : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofork.π cocone) f') (K.d j k)\nf'' : Quiver.Hom cocone.pt ((K.extend e).X k')\nhf'' : Eq (CategoryTheory.CategoryStruct.comp (K.extendXIso e hj').hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofork.π cocone) f'')) ((K.extend e).d j' k')\nφ : Quiver.Hom W cocone.pt\n⊢ Iff (Eq (CategoryTheory.CategoryStruct.comp φ f') 0) (Eq (CategoryTheory.CategoryStruct.comp φ f'') 0)","decl":"include hk hk' hcocone in\nlemma d_comp_desc_eq_zero_iff' ⦃W : C⦄ (f' : cocone.pt ⟶ K.X k)\n    (hf' : cocone.π ≫ f' = K.d j k)\n    (f'' : cocone.pt ⟶ (K.extend e).X k')\n    (hf'' : (extendXIso K e hj').hom ≫ cocone.π ≫ f'' = (K.extend e).d j' k')\n    (φ : W ⟶ cocone.pt) :\n    φ ≫ f' = 0 ↔ φ ≫ f'' = 0 := by\n  by_cases hjk : c.Rel j k\n  · have hk'' : e.f k = k' := by rw [← hk', ← hj', c'.next_eq' (e.rel hjk)]\n    have : f' ≫ (K.extendXIso e hk'').inv = f'' := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [reassoc_of% hf', ← cancel_epi (extendXIso K e hj').hom, hf'',\n        K.extend_d_eq e hj' hk'']\n    rw [← cancel_mono (K.extendXIso e hk'').inv, zero_comp, assoc, this]\n  · have h₁ : f' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      simp only [hf', comp_zero, K.shape _ _ hjk]\n    have h₂ : f'' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [← cancel_epi (extendXIso K e hj').hom, hf'', comp_zero, comp_zero,\n        K.extend_d_from_eq_zero e j' k' j hj']\n      rw [hk]\n      exact hjk\n    simp [h₁, h₂]\n\n"}
{"name":"HomologicalComplex.extend.rightHomologyData_ι","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\ni j k : ι\ni' j' k' : ι'\nhj' : Eq (e.f j) j'\nh : (K.sc' i j k).RightHomologyData\n⊢ Eq (HomologicalComplex.extend.rightHomologyData K e hj' h).ι h.ι","decl":"open rightHomologyData in\n/-- The right homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a right homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def rightHomologyData (h : (K.sc' i j k).RightHomologyData) :\n    ((K.extend e).sc' i' j' k').RightHomologyData where\n  Q := h.Q\n  H := h.H\n  p := (extendXIso K e hj').hom ≫ h.p\n  ι := h.ι\n  wp := by\n    dsimp\n    rw [← d_comp_eq_zero_iff K e hj' hi hi']\n    exact h.wp\n  hp := isColimitCokernelCofork K e hj' hi hi' _ h.hp\n  wι := by\n    dsimp\n    rw [← d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' _ h.hp]\n    exact h.wι\n  hι := isLimitKernelFork K e hj' hi hi' hk hk' _ h.hp _ h.hι\n\n"}
{"name":"HomologicalComplex.extend.rightHomologyData_H","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\ni j k : ι\ni' j' k' : ι'\nhj' : Eq (e.f j) j'\nh : (K.sc' i j k).RightHomologyData\n⊢ Eq (HomologicalComplex.extend.rightHomologyData K e hj' h).H h.H","decl":"open rightHomologyData in\n/-- The right homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a right homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def rightHomologyData (h : (K.sc' i j k).RightHomologyData) :\n    ((K.extend e).sc' i' j' k').RightHomologyData where\n  Q := h.Q\n  H := h.H\n  p := (extendXIso K e hj').hom ≫ h.p\n  ι := h.ι\n  wp := by\n    dsimp\n    rw [← d_comp_eq_zero_iff K e hj' hi hi']\n    exact h.wp\n  hp := isColimitCokernelCofork K e hj' hi hi' _ h.hp\n  wι := by\n    dsimp\n    rw [← d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' _ h.hp]\n    exact h.wι\n  hι := isLimitKernelFork K e hj' hi hi' hk hk' _ h.hp _ h.hι\n\n"}
{"name":"HomologicalComplex.extend.rightHomologyData_Q","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\ni j k : ι\ni' j' k' : ι'\nhj' : Eq (e.f j) j'\nh : (K.sc' i j k).RightHomologyData\n⊢ Eq (HomologicalComplex.extend.rightHomologyData K e hj' h).Q h.Q","decl":"open rightHomologyData in\n/-- The right homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a right homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def rightHomologyData (h : (K.sc' i j k).RightHomologyData) :\n    ((K.extend e).sc' i' j' k').RightHomologyData where\n  Q := h.Q\n  H := h.H\n  p := (extendXIso K e hj').hom ≫ h.p\n  ι := h.ι\n  wp := by\n    dsimp\n    rw [← d_comp_eq_zero_iff K e hj' hi hi']\n    exact h.wp\n  hp := isColimitCokernelCofork K e hj' hi hi' _ h.hp\n  wι := by\n    dsimp\n    rw [← d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' _ h.hp]\n    exact h.wι\n  hι := isLimitKernelFork K e hj' hi hi' hk hk' _ h.hp _ h.hι\n\n"}
{"name":"HomologicalComplex.extend.rightHomologyData_p","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\ni j k : ι\ni' j' k' : ι'\nhj' : Eq (e.f j) j'\nh : (K.sc' i j k).RightHomologyData\n⊢ Eq (HomologicalComplex.extend.rightHomologyData K e hj' h).p (CategoryTheory.CategoryStruct.comp (K.extendXIso e hj').hom h.p)","decl":"open rightHomologyData in\n/-- The right homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a right homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def rightHomologyData (h : (K.sc' i j k).RightHomologyData) :\n    ((K.extend e).sc' i' j' k').RightHomologyData where\n  Q := h.Q\n  H := h.H\n  p := (extendXIso K e hj').hom ≫ h.p\n  ι := h.ι\n  wp := by\n    dsimp\n    rw [← d_comp_eq_zero_iff K e hj' hi hi']\n    exact h.wp\n  hp := isColimitCokernelCofork K e hj' hi hi' _ h.hp\n  wι := by\n    dsimp\n    rw [← d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' _ h.hp]\n    exact h.wι\n  hι := isLimitKernelFork K e hj' hi hi' hk hk' _ h.hp _ h.hι\n\n"}
{"name":"HomologicalComplex.extend.rightHomologyData_g'","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\ni j k : ι\nk' : ι'\nh : (K.sc' i j k).RightHomologyData\nhk'' : Eq (e.f k) k'\n⊢ Eq (sorryAx (Unit → Quiver.Hom h.Q ((K.extend e).X k')) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 246).num 4).num 246).num 50).num 4).num 50).str \"_sorry\").str \"_@\").str \"_hyg\").num 3113))) (CategoryTheory.CategoryStruct.comp h.g' (K.extendXIso e hk'').inv)","decl":"/-- Computation of the `g'` field of `extend.rightHomologyData`. -/\nlemma rightHomologyData_g' (h : (K.sc' i j k).RightHomologyData) (hk'' : e.f k = k') :\n    (rightHomologyData K e hj' hi hi' hk hk' h).g' = h.g' ≫ (K.extendXIso e hk'').inv := by\n  rw [← cancel_epi h.p, ← cancel_epi (extendXIso K e hj').hom]\n  have := (rightHomologyData K e hj' hi hi' hk hk' h).p_g'\n  dsimp at this\n  rw [assoc] at this\n  rw [this, K.extend_d_eq e hj' hk'', h.p_g'_assoc, shortComplexFunctor'_obj_g]\n\n"}
{"name":"HomologicalComplex.extend.homologyData_iso","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\ni j k : ι\ni' j' k' : ι'\nh : (K.sc' i j k).HomologyData\n⊢ Eq (HomologicalComplex.extend.homologyData K e h).iso (sorryAx (Unit → CategoryTheory.Iso (sorryAx (Unit → ((K.extend e).sc' i' j' k').LeftHomologyData) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 258).num 10).num 258).num 55).num 10).num 55).str \"_sorry\").str \"_@\").str \"_hyg\").num 3220))).H (sorryAx (Unit → ((K.extend e).sc' i' j' k').RightHomologyData) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 259).num 11).num 259).num 58).num 11).num 58).str \"_sorry\").str \"_@\").str \"_hyg\").num 3228))).H) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 260).num 9).num 260).num 14).num 9).num 14).str \"_sorry\").str \"_@\").str \"_hyg\").num 3230)))","decl":"/-- The homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def homologyData (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc' i' j' k').HomologyData where\n  left := leftHomologyData K e hj' hi hi' hk hk' h.left\n  right := rightHomologyData K e hj' hi hi' hk hk' h.right\n  iso := h.iso\n\n"}
{"name":"HomologicalComplex.extend.homologyData_left","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\ni j k : ι\ni' j' k' : ι'\nh : (K.sc' i j k).HomologyData\n⊢ Eq (HomologicalComplex.extend.homologyData K e h).left (sorryAx (Unit → ((K.extend e).sc' i' j' k').LeftHomologyData) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 258).num 10).num 258).num 55).num 10).num 55).str \"_sorry\").str \"_@\").str \"_hyg\").num 3220)))","decl":"/-- The homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def homologyData (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc' i' j' k').HomologyData where\n  left := leftHomologyData K e hj' hi hi' hk hk' h.left\n  right := rightHomologyData K e hj' hi hi' hk hk' h.right\n  iso := h.iso\n\n"}
{"name":"HomologicalComplex.extend.homologyData_right","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\ni j k : ι\ni' j' k' : ι'\nh : (K.sc' i j k).HomologyData\n⊢ Eq (HomologicalComplex.extend.homologyData K e h).right (sorryAx (Unit → ((K.extend e).sc' i' j' k').RightHomologyData) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 259).num 11).num 259).num 58).num 11).num 58).str \"_sorry\").str \"_@\").str \"_hyg\").num 3228)))","decl":"/-- The homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def homologyData (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc' i' j' k').HomologyData where\n  left := leftHomologyData K e hj' hi hi' hk hk' h.left\n  right := rightHomologyData K e hj' hi hi' hk hk' h.right\n  iso := h.iso\n\n"}
{"name":"HomologicalComplex.extend.hasHomology","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\nj : ι\nj' : ι'\nhj' : Eq (e.f j) j'\ninst✝ : K.HasHomology j\n⊢ (K.extend e).HasHomology j'","decl":"lemma hasHomology {j : ι} {j' : ι'} (hj' : e.f j = j') [K.HasHomology j] :\n    (K.extend e).HasHomology j' :=\n  ShortComplex.HasHomology.mk'\n    (homologyData' K e hj' rfl rfl ((K.sc j).homologyData))\n\n"}
{"name":"HomologicalComplex.extend.instHasHomologyF","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\nj : ι\ninst✝ : K.HasHomology j\n⊢ (K.extend e).HasHomology (e.f j)","decl":"instance (j : ι) [K.HasHomology j] : (K.extend e).HasHomology (e.f j) :=\n  hasHomology K e rfl\n\n"}
{"name":"HomologicalComplex.extend.instHasHomology","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\ninst✝ : ∀ (j : ι), K.HasHomology j\nj' : ι'\n⊢ (K.extend e).HasHomology j'","decl":"instance [∀ j, K.HasHomology j] (j' : ι') : (K.extend e).HasHomology j' := by\n  by_cases h : ∃ j, e.f j = j'\n  · obtain ⟨j, rfl⟩ := h\n    infer_instance\n  · have hj := isZero_extend_X K e j' (by tauto)\n    exact ShortComplex.HasHomology.mk'\n      (ShortComplex.HomologyData.ofZeros _ (hj.eq_of_tgt _ _) (hj.eq_of_src _ _))\n\n"}
{"name":"HomologicalComplex.extend_exactAt","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\nj' : ι'\nhj' : ∀ (j : ι), Ne (e.f j) j'\n⊢ (K.extend e).ExactAt j'","decl":"lemma extend_exactAt (j' : ι') (hj' : ∀ j, e.f j ≠ j') :\n    (K.extend e).ExactAt j' :=\n  exactAt_of_isSupported _ e j' hj'\n\n"}
{"name":"HomologicalComplex.extend_exactAt_iff","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\nj : ι\nj' : ι'\nhj' : Eq (e.f j) j'\ninst✝¹ : K.HasHomology j\ninst✝ : (K.extend e).HasHomology j'\n⊢ Iff ((K.extend e).ExactAt j') (K.ExactAt j)","decl":"include hj' in\nlemma extend_exactAt_iff :\n    (K.extend e).ExactAt j' ↔ K.ExactAt j := by\n  simp only [HomologicalComplex.exactAt_iff_isZero_homology]\n  exact (K.extendHomologyIso e hj').isZero_iff\n\n"}
{"name":"HomologicalComplex.extendCyclesIso_hom_iCycles_assoc","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\nj : ι\nj' : ι'\nhj' : Eq (e.f j) j'\ninst✝¹ : K.HasHomology j\ninst✝ : (K.extend e).HasHomology j'\nZ : C\nh : Quiver.Hom (K.X j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom ((K.extend e).cycles j') (K.cycles j)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 324).num 4).num 324).num 33).num 4).num 33).str \"_sorry\").str \"_@\").str \"_hyg\").num 4245))) (CategoryTheory.CategoryStruct.comp (K.iCycles j) h)) (CategoryTheory.CategoryStruct.comp ((K.extend e).iCycles j') (CategoryTheory.CategoryStruct.comp (K.extendXIso e hj').hom h))","decl":"@[reassoc (attr := simp)]\nlemma extendCyclesIso_hom_iCycles :\n    (K.extendCyclesIso e hj').hom ≫ K.iCycles j =\n      (K.extend e).iCycles j' ≫ (K.extendXIso e hj').hom := by\n  rw [← cancel_epi (K.extendCyclesIso e hj').inv, Iso.inv_hom_id_assoc]\n  dsimp [extendCyclesIso, iCycles]\n  rw [assoc, ShortComplex.LeftHomologyData.cyclesIso_inv_comp_iCycles_assoc]\n  dsimp\n  rw [assoc, Iso.inv_hom_id, comp_id,\n    ShortComplex.LeftHomologyData.cyclesIso_hom_comp_i]\n\n"}
{"name":"HomologicalComplex.extendCyclesIso_hom_iCycles","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\nj : ι\nj' : ι'\nhj' : Eq (e.f j) j'\ninst✝¹ : K.HasHomology j\ninst✝ : (K.extend e).HasHomology j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom ((K.extend e).cycles j') (K.cycles j)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 324).num 4).num 324).num 33).num 4).num 33).str \"_sorry\").str \"_@\").str \"_hyg\").num 4245))) (K.iCycles j)) (CategoryTheory.CategoryStruct.comp ((K.extend e).iCycles j') (K.extendXIso e hj').hom)","decl":"@[reassoc (attr := simp)]\nlemma extendCyclesIso_hom_iCycles :\n    (K.extendCyclesIso e hj').hom ≫ K.iCycles j =\n      (K.extend e).iCycles j' ≫ (K.extendXIso e hj').hom := by\n  rw [← cancel_epi (K.extendCyclesIso e hj').inv, Iso.inv_hom_id_assoc]\n  dsimp [extendCyclesIso, iCycles]\n  rw [assoc, ShortComplex.LeftHomologyData.cyclesIso_inv_comp_iCycles_assoc]\n  dsimp\n  rw [assoc, Iso.inv_hom_id, comp_id,\n    ShortComplex.LeftHomologyData.cyclesIso_hom_comp_i]\n\n"}
{"name":"HomologicalComplex.extendCyclesIso_inv_iCycles_assoc","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\nj : ι\nj' : ι'\nhj' : Eq (e.f j) j'\ninst✝¹ : K.HasHomology j\ninst✝ : (K.extend e).HasHomology j'\nZ : C\nh : Quiver.Hom ((K.extend e).X j') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom (K.cycles j) ((K.extend e).cycles j')) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 335).num 4).num 335).num 33).num 4).num 33).str \"_sorry\").str \"_@\").str \"_hyg\").num 4386))) (CategoryTheory.CategoryStruct.comp ((K.extend e).iCycles j') h)) (CategoryTheory.CategoryStruct.comp (K.iCycles j) (CategoryTheory.CategoryStruct.comp (K.extendXIso e hj').inv h))","decl":"@[reassoc (attr := simp)]\nlemma extendCyclesIso_inv_iCycles :\n    (K.extendCyclesIso e hj').inv ≫ (K.extend e).iCycles j' =\n      K.iCycles j ≫ (K.extendXIso e hj').inv := by\n  simp only [← cancel_epi (K.extendCyclesIso e hj').hom, Iso.hom_inv_id_assoc,\n    extendCyclesIso_hom_iCycles_assoc, Iso.hom_inv_id, comp_id]\n\n"}
{"name":"HomologicalComplex.extendCyclesIso_inv_iCycles","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\nj : ι\nj' : ι'\nhj' : Eq (e.f j) j'\ninst✝¹ : K.HasHomology j\ninst✝ : (K.extend e).HasHomology j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom (K.cycles j) ((K.extend e).cycles j')) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 335).num 4).num 335).num 33).num 4).num 33).str \"_sorry\").str \"_@\").str \"_hyg\").num 4386))) ((K.extend e).iCycles j')) (CategoryTheory.CategoryStruct.comp (K.iCycles j) (K.extendXIso e hj').inv)","decl":"@[reassoc (attr := simp)]\nlemma extendCyclesIso_inv_iCycles :\n    (K.extendCyclesIso e hj').inv ≫ (K.extend e).iCycles j' =\n      K.iCycles j ≫ (K.extendXIso e hj').inv := by\n  simp only [← cancel_epi (K.extendCyclesIso e hj').hom, Iso.hom_inv_id_assoc,\n    extendCyclesIso_hom_iCycles_assoc, Iso.hom_inv_id, comp_id]\n\n"}
{"name":"HomologicalComplex.homologyπ_extendHomologyIso_hom","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\nj : ι\nj' : ι'\ninst✝¹ : K.HasHomology j\ninst✝ : (K.extend e).HasHomology j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((K.extend e).homologyπ j') (sorryAx (Unit → Quiver.Hom ((K.extend e).homology j') (K.homology j)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 342).num 32).num 342).num 63).num 32).num 63).str \"_sorry\").str \"_@\").str \"_hyg\").num 4562)))) (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom ((K.extend e).cycles j') (K.cycles j)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 343).num 6).num 343).num 35).num 6).num 35).str \"_sorry\").str \"_@\").str \"_hyg\").num 4570))) (K.homologyπ j))","decl":"@[reassoc (attr := simp)]\nlemma homologyπ_extendHomologyIso_hom :\n    (K.extend e).homologyπ j' ≫ (K.extendHomologyIso e hj').hom =\n      (K.extendCyclesIso e hj').hom ≫ K.homologyπ j := by\n  dsimp [extendHomologyIso, homologyπ]\n  rw [ShortComplex.LeftHomologyData.homologyπ_comp_homologyIso_hom_assoc,\n    ← cancel_mono (K.sc j).homologyData.left.homologyIso.hom,\n    assoc, assoc, assoc, Iso.inv_hom_id, comp_id,\n    ShortComplex.LeftHomologyData.homologyπ_comp_homologyIso_hom]\n  dsimp [extendCyclesIso]\n  simp only [assoc, Iso.inv_hom_id_assoc]\n\n"}
{"name":"HomologicalComplex.homologyπ_extendHomologyIso_hom_assoc","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\nj : ι\nj' : ι'\ninst✝¹ : K.HasHomology j\ninst✝ : (K.extend e).HasHomology j'\nZ : C\nh : Quiver.Hom (K.homology j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((K.extend e).homologyπ j') (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom ((K.extend e).homology j') (K.homology j)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 342).num 32).num 342).num 63).num 32).num 63).str \"_sorry\").str \"_@\").str \"_hyg\").num 4562))) h)) (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom ((K.extend e).cycles j') (K.cycles j)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 343).num 6).num 343).num 35).num 6).num 35).str \"_sorry\").str \"_@\").str \"_hyg\").num 4570))) (CategoryTheory.CategoryStruct.comp (K.homologyπ j) h))","decl":"@[reassoc (attr := simp)]\nlemma homologyπ_extendHomologyIso_hom :\n    (K.extend e).homologyπ j' ≫ (K.extendHomologyIso e hj').hom =\n      (K.extendCyclesIso e hj').hom ≫ K.homologyπ j := by\n  dsimp [extendHomologyIso, homologyπ]\n  rw [ShortComplex.LeftHomologyData.homologyπ_comp_homologyIso_hom_assoc,\n    ← cancel_mono (K.sc j).homologyData.left.homologyIso.hom,\n    assoc, assoc, assoc, Iso.inv_hom_id, comp_id,\n    ShortComplex.LeftHomologyData.homologyπ_comp_homologyIso_hom]\n  dsimp [extendCyclesIso]\n  simp only [assoc, Iso.inv_hom_id_assoc]\n\n"}
{"name":"HomologicalComplex.homologyπ_extendHomologyIso_inv_assoc","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\nj : ι\nj' : ι'\ninst✝¹ : K.HasHomology j\ninst✝ : (K.extend e).HasHomology j'\nZ : C\nh : Quiver.Hom ((K.extend e).homology j') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.homologyπ j) (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom (K.homology j) ((K.extend e).homology j')) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 354).num 20).num 354).num 51).num 20).num 51).str \"_sorry\").str \"_@\").str \"_hyg\").num 4746))) h)) (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom (K.cycles j) ((K.extend e).cycles j')) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 355).num 6).num 355).num 35).num 6).num 35).str \"_sorry\").str \"_@\").str \"_hyg\").num 4754))) (CategoryTheory.CategoryStruct.comp ((K.extend e).homologyπ j') h))","decl":"@[reassoc (attr := simp)]\nlemma homologyπ_extendHomologyIso_inv :\n    K.homologyπ j ≫ (K.extendHomologyIso e hj').inv =\n      (K.extendCyclesIso e hj').inv ≫ (K.extend e).homologyπ j' := by\n  simp only [← cancel_mono (K.extendHomologyIso e hj').hom,\n    assoc, Iso.inv_hom_id, comp_id, homologyπ_extendHomologyIso_hom, Iso.inv_hom_id_assoc]\n\n"}
{"name":"HomologicalComplex.homologyπ_extendHomologyIso_inv","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\nj : ι\nj' : ι'\ninst✝¹ : K.HasHomology j\ninst✝ : (K.extend e).HasHomology j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.homologyπ j) (sorryAx (Unit → Quiver.Hom (K.homology j) ((K.extend e).homology j')) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 354).num 20).num 354).num 51).num 20).num 51).str \"_sorry\").str \"_@\").str \"_hyg\").num 4746)))) (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom (K.cycles j) ((K.extend e).cycles j')) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 355).num 6).num 355).num 35).num 6).num 35).str \"_sorry\").str \"_@\").str \"_hyg\").num 4754))) ((K.extend e).homologyπ j'))","decl":"@[reassoc (attr := simp)]\nlemma homologyπ_extendHomologyIso_inv :\n    K.homologyπ j ≫ (K.extendHomologyIso e hj').inv =\n      (K.extendCyclesIso e hj').inv ≫ (K.extend e).homologyπ j' := by\n  simp only [← cancel_mono (K.extendHomologyIso e hj').hom,\n    assoc, Iso.inv_hom_id, comp_id, homologyπ_extendHomologyIso_hom, Iso.inv_hom_id_assoc]\n\n"}
{"name":"HomologicalComplex.pOpcycles_extendOpcyclesIso_inv","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\nj : ι\nj' : ι'\nhj' : Eq (e.f j) j'\ninst✝¹ : K.HasHomology j\ninst✝ : (K.extend e).HasHomology j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.pOpcycles j) (sorryAx (Unit → Quiver.Hom (K.opcycles j) ((K.extend e).opcycles j')) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 361).num 20).num 361).num 51).num 20).num 51).str \"_sorry\").str \"_@\").str \"_hyg\").num 4895)))) (CategoryTheory.CategoryStruct.comp (K.extendXIso e hj').inv ((K.extend e).pOpcycles j'))","decl":"@[reassoc (attr := simp)]\nlemma pOpcycles_extendOpcyclesIso_inv :\n    K.pOpcycles j ≫ (K.extendOpcyclesIso e hj').inv =\n      (K.extendXIso e hj').inv ≫ (K.extend e).pOpcycles j' := by\n  rw [← cancel_mono (K.extendOpcyclesIso e hj').hom, assoc, assoc, Iso.inv_hom_id, comp_id]\n  dsimp [extendOpcyclesIso, pOpcycles]\n  rw [ShortComplex.RightHomologyData.pOpcycles_comp_opcyclesIso_hom_assoc]\n  dsimp\n  rw [assoc, Iso.inv_hom_id_assoc, ShortComplex.RightHomologyData.p_comp_opcyclesIso_inv]\n  rfl\n\n"}
{"name":"HomologicalComplex.pOpcycles_extendOpcyclesIso_inv_assoc","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\nj : ι\nj' : ι'\nhj' : Eq (e.f j) j'\ninst✝¹ : K.HasHomology j\ninst✝ : (K.extend e).HasHomology j'\nZ : C\nh : Quiver.Hom ((K.extend e).opcycles j') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.pOpcycles j) (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom (K.opcycles j) ((K.extend e).opcycles j')) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 361).num 20).num 361).num 51).num 20).num 51).str \"_sorry\").str \"_@\").str \"_hyg\").num 4895))) h)) (CategoryTheory.CategoryStruct.comp (K.extendXIso e hj').inv (CategoryTheory.CategoryStruct.comp ((K.extend e).pOpcycles j') h))","decl":"@[reassoc (attr := simp)]\nlemma pOpcycles_extendOpcyclesIso_inv :\n    K.pOpcycles j ≫ (K.extendOpcyclesIso e hj').inv =\n      (K.extendXIso e hj').inv ≫ (K.extend e).pOpcycles j' := by\n  rw [← cancel_mono (K.extendOpcyclesIso e hj').hom, assoc, assoc, Iso.inv_hom_id, comp_id]\n  dsimp [extendOpcyclesIso, pOpcycles]\n  rw [ShortComplex.RightHomologyData.pOpcycles_comp_opcyclesIso_hom_assoc]\n  dsimp\n  rw [assoc, Iso.inv_hom_id_assoc, ShortComplex.RightHomologyData.p_comp_opcyclesIso_inv]\n  rfl\n\n"}
{"name":"HomologicalComplex.pOpcycles_extendOpcyclesIso_hom","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\nj : ι\nj' : ι'\nhj' : Eq (e.f j) j'\ninst✝¹ : K.HasHomology j\ninst✝ : (K.extend e).HasHomology j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((K.extend e).pOpcycles j') (sorryAx (Unit → Quiver.Hom ((K.extend e).opcycles j') (K.opcycles j)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 372).num 32).num 372).num 63).num 32).num 63).str \"_sorry\").str \"_@\").str \"_hyg\").num 5036)))) (CategoryTheory.CategoryStruct.comp (K.extendXIso e hj').hom (K.pOpcycles j))","decl":"@[reassoc (attr := simp)]\nlemma pOpcycles_extendOpcyclesIso_hom :\n    (K.extend e).pOpcycles j' ≫ (K.extendOpcyclesIso e hj').hom =\n      (K.extendXIso e hj').hom ≫ K.pOpcycles j := by\n  simp only [← cancel_mono (K.extendOpcyclesIso e hj').inv,\n    assoc, Iso.hom_inv_id, comp_id, pOpcycles_extendOpcyclesIso_inv, Iso.hom_inv_id_assoc]\n\n"}
{"name":"HomologicalComplex.pOpcycles_extendOpcyclesIso_hom_assoc","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\nj : ι\nj' : ι'\nhj' : Eq (e.f j) j'\ninst✝¹ : K.HasHomology j\ninst✝ : (K.extend e).HasHomology j'\nZ : C\nh : Quiver.Hom (K.opcycles j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((K.extend e).pOpcycles j') (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom ((K.extend e).opcycles j') (K.opcycles j)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 372).num 32).num 372).num 63).num 32).num 63).str \"_sorry\").str \"_@\").str \"_hyg\").num 5036))) h)) (CategoryTheory.CategoryStruct.comp (K.extendXIso e hj').hom (CategoryTheory.CategoryStruct.comp (K.pOpcycles j) h))","decl":"@[reassoc (attr := simp)]\nlemma pOpcycles_extendOpcyclesIso_hom :\n    (K.extend e).pOpcycles j' ≫ (K.extendOpcyclesIso e hj').hom =\n      (K.extendXIso e hj').hom ≫ K.pOpcycles j := by\n  simp only [← cancel_mono (K.extendOpcyclesIso e hj').inv,\n    assoc, Iso.hom_inv_id, comp_id, pOpcycles_extendOpcyclesIso_inv, Iso.hom_inv_id_assoc]\n\n"}
{"name":"HomologicalComplex.extendHomologyIso_hom_homologyι","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\nj : ι\nj' : ι'\ninst✝¹ : K.HasHomology j\ninst✝ : (K.extend e).HasHomology j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom ((K.extend e).homology j') (K.homology j)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 379).num 4).num 379).num 35).num 4).num 35).str \"_sorry\").str \"_@\").str \"_hyg\").num 5212))) (K.homologyι j)) (CategoryTheory.CategoryStruct.comp ((K.extend e).homologyι j') (sorryAx (Unit → Quiver.Hom ((K.extend e).opcycles j') (K.opcycles j)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 380).num 34).num 380).num 65).num 34).num 65).str \"_sorry\").str \"_@\").str \"_hyg\").num 5220))))","decl":"@[reassoc (attr := simp)]\nlemma extendHomologyIso_hom_homologyι :\n    (K.extendHomologyIso e hj').hom ≫ K.homologyι j =\n      (K.extend e).homologyι j' ≫ (K.extendOpcyclesIso e hj').hom := by\n  simp only [← cancel_epi ((K.extend e).homologyπ j'),\n    homologyπ_extendHomologyIso_hom_assoc, homology_π_ι, extendCyclesIso_hom_iCycles_assoc,\n    homology_π_ι_assoc, pOpcycles_extendOpcyclesIso_hom]\n\n"}
{"name":"HomologicalComplex.extendHomologyIso_hom_homologyι_assoc","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\nj : ι\nj' : ι'\ninst✝¹ : K.HasHomology j\ninst✝ : (K.extend e).HasHomology j'\nZ : C\nh : Quiver.Hom (K.opcycles j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom ((K.extend e).homology j') (K.homology j)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 379).num 4).num 379).num 35).num 4).num 35).str \"_sorry\").str \"_@\").str \"_hyg\").num 5212))) (CategoryTheory.CategoryStruct.comp (K.homologyι j) h)) (CategoryTheory.CategoryStruct.comp ((K.extend e).homologyι j') (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom ((K.extend e).opcycles j') (K.opcycles j)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 380).num 34).num 380).num 65).num 34).num 65).str \"_sorry\").str \"_@\").str \"_hyg\").num 5220))) h))","decl":"@[reassoc (attr := simp)]\nlemma extendHomologyIso_hom_homologyι :\n    (K.extendHomologyIso e hj').hom ≫ K.homologyι j =\n      (K.extend e).homologyι j' ≫ (K.extendOpcyclesIso e hj').hom := by\n  simp only [← cancel_epi ((K.extend e).homologyπ j'),\n    homologyπ_extendHomologyIso_hom_assoc, homology_π_ι, extendCyclesIso_hom_iCycles_assoc,\n    homology_π_ι_assoc, pOpcycles_extendOpcyclesIso_hom]\n\n"}
{"name":"HomologicalComplex.extendHomologyIso_inv_homologyι","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\nj : ι\nj' : ι'\ninst✝¹ : K.HasHomology j\ninst✝ : (K.extend e).HasHomology j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom (K.homology j) ((K.extend e).homology j')) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 387).num 4).num 387).num 35).num 4).num 35).str \"_sorry\").str \"_@\").str \"_hyg\").num 5396))) ((K.extend e).homologyι j')) (CategoryTheory.CategoryStruct.comp (K.homologyι j) (sorryAx (Unit → Quiver.Hom (K.opcycles j) ((K.extend e).opcycles j')) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 388).num 22).num 388).num 53).num 22).num 53).str \"_sorry\").str \"_@\").str \"_hyg\").num 5404))))","decl":"@[reassoc (attr := simp)]\nlemma extendHomologyIso_inv_homologyι :\n    (K.extendHomologyIso e hj').inv ≫ (K.extend e).homologyι j' =\n      K.homologyι j ≫ (K.extendOpcyclesIso e hj').inv := by\n  simp only [← cancel_epi (K.extendHomologyIso e hj').hom,\n    Iso.hom_inv_id_assoc, extendHomologyIso_hom_homologyι_assoc, Iso.hom_inv_id, comp_id]\n\n"}
{"name":"HomologicalComplex.extendHomologyIso_inv_homologyι_assoc","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\nK : HomologicalComplex C c\ne : c.Embedding c'\nj : ι\nj' : ι'\ninst✝¹ : K.HasHomology j\ninst✝ : (K.extend e).HasHomology j'\nZ : C\nh : Quiver.Hom ((K.extend e).opcycles j') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom (K.homology j) ((K.extend e).homology j')) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 387).num 4).num 387).num 35).num 4).num 35).str \"_sorry\").str \"_@\").str \"_hyg\").num 5396))) (CategoryTheory.CategoryStruct.comp ((K.extend e).homologyι j') h)) (CategoryTheory.CategoryStruct.comp (K.homologyι j) (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom (K.opcycles j) ((K.extend e).opcycles j')) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 388).num 22).num 388).num 53).num 22).num 53).str \"_sorry\").str \"_@\").str \"_hyg\").num 5404))) h))","decl":"@[reassoc (attr := simp)]\nlemma extendHomologyIso_inv_homologyι :\n    (K.extendHomologyIso e hj').inv ≫ (K.extend e).homologyι j' =\n      K.homologyι j ≫ (K.extendOpcyclesIso e hj').inv := by\n  simp only [← cancel_epi (K.extendHomologyIso e hj').hom,\n    Iso.hom_inv_id_assoc, extendHomologyIso_hom_homologyι_assoc, Iso.hom_inv_id, comp_id]\n\n"}
{"name":"HomologicalComplex.extendCyclesIso_hom_naturality","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁶ : CategoryTheory.Category.{u_4, u_3} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\nK L : HomologicalComplex C c\nφ : Quiver.Hom K L\ne : c.Embedding c'\nj : ι\nj' : ι'\ninst✝³ : K.HasHomology j\ninst✝² : L.HasHomology j\ninst✝¹ : (K.extend e).HasHomology j'\ninst✝ : (L.extend e).HasHomology j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cyclesMap (HomologicalComplex.extendMap φ e) j') (sorryAx (Unit → Quiver.Hom ((L.extend e).cycles j') (L.cycles j)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 396).num 35).num 396).num 64).num 35).num 64).str \"_sorry\").str \"_@\").str \"_hyg\").num 5648)))) (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom ((K.extend e).cycles j') (K.cycles j)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 397).num 6).num 397).num 35).num 6).num 35).str \"_sorry\").str \"_@\").str \"_hyg\").num 5656))) (HomologicalComplex.cyclesMap φ j))","decl":"@[reassoc (attr := simp)]\nlemma extendCyclesIso_hom_naturality :\n    cyclesMap (extendMap φ e) j' ≫ (L.extendCyclesIso e hj').hom =\n      (K.extendCyclesIso e hj').hom ≫ cyclesMap φ j := by\n  simp [← cancel_mono (L.iCycles j), extendMap_f φ e hj']\n\n"}
{"name":"HomologicalComplex.extendCyclesIso_hom_naturality_assoc","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁶ : CategoryTheory.Category.{u_4, u_3} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\nK L : HomologicalComplex C c\nφ : Quiver.Hom K L\ne : c.Embedding c'\nj : ι\nj' : ι'\ninst✝³ : K.HasHomology j\ninst✝² : L.HasHomology j\ninst✝¹ : (K.extend e).HasHomology j'\ninst✝ : (L.extend e).HasHomology j'\nZ : C\nh : Quiver.Hom (L.cycles j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cyclesMap (HomologicalComplex.extendMap φ e) j') (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom ((L.extend e).cycles j') (L.cycles j)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 396).num 35).num 396).num 64).num 35).num 64).str \"_sorry\").str \"_@\").str \"_hyg\").num 5648))) h)) (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom ((K.extend e).cycles j') (K.cycles j)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 397).num 6).num 397).num 35).num 6).num 35).str \"_sorry\").str \"_@\").str \"_hyg\").num 5656))) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cyclesMap φ j) h))","decl":"@[reassoc (attr := simp)]\nlemma extendCyclesIso_hom_naturality :\n    cyclesMap (extendMap φ e) j' ≫ (L.extendCyclesIso e hj').hom =\n      (K.extendCyclesIso e hj').hom ≫ cyclesMap φ j := by\n  simp [← cancel_mono (L.iCycles j), extendMap_f φ e hj']\n\n"}
{"name":"HomologicalComplex.extendHomologyIso_hom_naturality","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁶ : CategoryTheory.Category.{u_4, u_3} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\nK L : HomologicalComplex C c\nφ : Quiver.Hom K L\ne : c.Embedding c'\nj : ι\nj' : ι'\ninst✝³ : K.HasHomology j\ninst✝² : L.HasHomology j\ninst✝¹ : (K.extend e).HasHomology j'\ninst✝ : (L.extend e).HasHomology j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homologyMap (HomologicalComplex.extendMap φ e) j') (sorryAx (Unit → Quiver.Hom ((L.extend e).homology j') (L.homology j)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 402).num 37).num 402).num 68).num 37).num 68).str \"_sorry\").str \"_@\").str \"_hyg\").num 5834)))) (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom ((K.extend e).homology j') (K.homology j)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 403).num 6).num 403).num 37).num 6).num 37).str \"_sorry\").str \"_@\").str \"_hyg\").num 5842))) (HomologicalComplex.homologyMap φ j))","decl":"@[reassoc (attr := simp)]\nlemma extendHomologyIso_hom_naturality :\n    homologyMap (extendMap φ e) j' ≫ (L.extendHomologyIso e hj').hom =\n      (K.extendHomologyIso e hj').hom ≫ homologyMap φ j := by\n  simp [← cancel_epi ((K.extend e).homologyπ _)]\n\n"}
{"name":"HomologicalComplex.extendHomologyIso_hom_naturality_assoc","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁶ : CategoryTheory.Category.{u_4, u_3} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\nK L : HomologicalComplex C c\nφ : Quiver.Hom K L\ne : c.Embedding c'\nj : ι\nj' : ι'\ninst✝³ : K.HasHomology j\ninst✝² : L.HasHomology j\ninst✝¹ : (K.extend e).HasHomology j'\ninst✝ : (L.extend e).HasHomology j'\nZ : C\nh : Quiver.Hom (L.homology j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homologyMap (HomologicalComplex.extendMap φ e) j') (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom ((L.extend e).homology j') (L.homology j)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 402).num 37).num 402).num 68).num 37).num 68).str \"_sorry\").str \"_@\").str \"_hyg\").num 5834))) h)) (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom ((K.extend e).homology j') (K.homology j)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 403).num 6).num 403).num 37).num 6).num 37).str \"_sorry\").str \"_@\").str \"_hyg\").num 5842))) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homologyMap φ j) h))","decl":"@[reassoc (attr := simp)]\nlemma extendHomologyIso_hom_naturality :\n    homologyMap (extendMap φ e) j' ≫ (L.extendHomologyIso e hj').hom =\n      (K.extendHomologyIso e hj').hom ≫ homologyMap φ j := by\n  simp [← cancel_epi ((K.extend e).homologyπ _)]\n\n"}
{"name":"HomologicalComplex.quasiIsoAt_extendMap_iff","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁶ : CategoryTheory.Category.{u_4, u_3} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\nK L : HomologicalComplex C c\nφ : Quiver.Hom K L\ne : c.Embedding c'\nj : ι\nj' : ι'\nhj' : Eq (e.f j) j'\ninst✝³ : K.HasHomology j\ninst✝² : L.HasHomology j\ninst✝¹ : (K.extend e).HasHomology j'\ninst✝ : (L.extend e).HasHomology j'\n⊢ Iff (QuasiIsoAt (HomologicalComplex.extendMap φ e) j') (QuasiIsoAt φ j)","decl":"include hj' in\nlemma quasiIsoAt_extendMap_iff :\n    QuasiIsoAt (extendMap φ e) j' ↔ QuasiIsoAt φ j := by\n  simp only [quasiIsoAt_iff_isIso_homologyMap]\n  exact (MorphismProperty.isomorphisms C).arrow_mk_iso_iff\n    (Arrow.isoMk (K.extendHomologyIso e hj') (L.extendHomologyIso e hj'))\n\n"}
{"name":"HomologicalComplex.quasiIso_extendMap_iff","module":"Mathlib.Algebra.Homology.Embedding.ExtendHomology","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\nK L : HomologicalComplex C c\nφ : Quiver.Hom K L\ne : c.Embedding c'\ninst✝¹ : ∀ (j : ι), K.HasHomology j\ninst✝ : ∀ (j : ι), L.HasHomology j\n⊢ Iff (QuasiIso (HomologicalComplex.extendMap φ e)) (QuasiIso φ)","decl":"lemma quasiIso_extendMap_iff [∀ j, K.HasHomology j] [∀ j, L.HasHomology j] :\n    QuasiIso (extendMap φ e) ↔ QuasiIso φ := by\n  simp only [quasiIso_iff, ← fun j ↦ quasiIsoAt_extendMap_iff φ e (j := j) (hj' := rfl)]\n  constructor\n  · tauto\n  · intro h j'\n    by_cases hj' : ∃ j, e.f j = j'\n    · obtain ⟨j, rfl⟩ := hj'\n      exact h j\n    · rw [quasiIsoAt_iff_exactAt]\n      all_goals\n        exact extend_exactAt _ _ _ (by simpa using hj')\n\n"}
