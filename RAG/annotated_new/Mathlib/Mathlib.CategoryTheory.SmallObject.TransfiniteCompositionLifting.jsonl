{"name":"CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct.w₁","module":"Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝¹ : LinearOrder J\ninst✝ : OrderBot J\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nX Y : C\np : Quiver.Hom X Y\nf : Quiver.Hom (F.obj Bot.bot) X\ng : Quiver.Hom c.pt Y\nj : J\nself : CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct c p f g j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.homOfLE ⋯)) self.f') f","decl":"/-- Given a cocone `c` for a functor `F : J ⥤ C` from a well-ordered type,\nand maps `p : X ⟶ Y`, `f : F.obj ⊥ ⟶ X`, `g : c.pt ⟶ Y`, this structure\ncontains the data of a map `F.obj j ⟶ X` such that `F.map (homOfLE bot_le) ≫ f' = f`\nand `f' ≫ p = c.ι.app j ≫ g`. (This implies that the outer square below\ncommutes, see `SqStruct.w`.)\n\n```\n         f\nF.obj ⊥ --> X\n   |      Λ |\n   |   f'╱  |\n   v    ╱   |\nF.obj j     | p\n   |        |\n   |        |\n   v    g   v\n  c.pt ---> Y\n```\n-/\n@[ext]\nstructure SqStruct (j : J) where\n  /-- a morphism `F.obj j ⟶ X` -/\n  f' : F.obj j ⟶ X\n  w₁ : F.map (homOfLE bot_le) ≫ f' = f := by aesop_cat\n  w₂ : f' ≫ p = c.ι.app j ≫ g := by aesop_cat\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct.mk.injEq","module":"Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝¹ : LinearOrder J\ninst✝ : OrderBot J\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nX Y : C\np : Quiver.Hom X Y\nf : Quiver.Hom (F.obj Bot.bot) X\ng : Quiver.Hom c.pt Y\nj : J\nf'✝ : Quiver.Hom (F.obj j) X\nw₁✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.homOfLE ⋯)) f'✝) f) _auto✝\nw₂✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp f'✝ p) (CategoryTheory.CategoryStruct.comp (c.ι.app j) g)) _auto✝\nf' : Quiver.Hom (F.obj j) X\nw₁ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.homOfLE ⋯)) f') f) _auto✝\nw₂ : autoParam (Eq (CategoryTheory.CategoryStruct.comp f' p) (CategoryTheory.CategoryStruct.comp (c.ι.app j) g)) _auto✝\n⊢ Eq (Eq { f' := f'✝, w₁ := w₁✝, w₂ := w₂✝ } { f' := f', w₁ := w₁, w₂ := w₂ }) (Eq f'✝ f')","decl":"/-- Given a cocone `c` for a functor `F : J ⥤ C` from a well-ordered type,\nand maps `p : X ⟶ Y`, `f : F.obj ⊥ ⟶ X`, `g : c.pt ⟶ Y`, this structure\ncontains the data of a map `F.obj j ⟶ X` such that `F.map (homOfLE bot_le) ≫ f' = f`\nand `f' ≫ p = c.ι.app j ≫ g`. (This implies that the outer square below\ncommutes, see `SqStruct.w`.)\n\n```\n         f\nF.obj ⊥ --> X\n   |      Λ |\n   |   f'╱  |\n   v    ╱   |\nF.obj j     | p\n   |        |\n   |        |\n   v    g   v\n  c.pt ---> Y\n```\n-/\n@[ext]\nstructure SqStruct (j : J) where\n  /-- a morphism `F.obj j ⟶ X` -/\n  f' : F.obj j ⟶ X\n  w₁ : F.map (homOfLE bot_le) ≫ f' = f := by aesop_cat\n  w₂ : f' ≫ p = c.ι.app j ≫ g := by aesop_cat\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝³ : LinearOrder J\ninst✝² : OrderBot J\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nX Y : C\np : Quiver.Hom X Y\nf : Quiver.Hom (F.obj Bot.bot) X\ng : Quiver.Hom c.pt Y\nj : J\ninst✝¹ : SizeOf C\ninst✝ : SizeOf J\nf' : Quiver.Hom (F.obj j) X\nw₁ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.homOfLE ⋯)) f') f) _auto✝\nw₂ : autoParam (Eq (CategoryTheory.CategoryStruct.comp f' p) (CategoryTheory.CategoryStruct.comp (c.ι.app j) g)) _auto✝\n⊢ Eq (SizeOf.sizeOf { f' := f', w₁ := w₁, w₂ := w₂ }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf f')) (SizeOf.sizeOf w₁)) (SizeOf.sizeOf w₂))","decl":"/-- Given a cocone `c` for a functor `F : J ⥤ C` from a well-ordered type,\nand maps `p : X ⟶ Y`, `f : F.obj ⊥ ⟶ X`, `g : c.pt ⟶ Y`, this structure\ncontains the data of a map `F.obj j ⟶ X` such that `F.map (homOfLE bot_le) ≫ f' = f`\nand `f' ≫ p = c.ι.app j ≫ g`. (This implies that the outer square below\ncommutes, see `SqStruct.w`.)\n\n```\n         f\nF.obj ⊥ --> X\n   |      Λ |\n   |   f'╱  |\n   v    ╱   |\nF.obj j     | p\n   |        |\n   |        |\n   v    g   v\n  c.pt ---> Y\n```\n-/\n@[ext]\nstructure SqStruct (j : J) where\n  /-- a morphism `F.obj j ⟶ X` -/\n  f' : F.obj j ⟶ X\n  w₁ : F.map (homOfLE bot_le) ≫ f' = f := by aesop_cat\n  w₂ : f' ≫ p = c.ι.app j ≫ g := by aesop_cat\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct.w₂","module":"Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝¹ : LinearOrder J\ninst✝ : OrderBot J\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nX Y : C\np : Quiver.Hom X Y\nf : Quiver.Hom (F.obj Bot.bot) X\ng : Quiver.Hom c.pt Y\nj : J\nself : CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct c p f g j\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.f' p) (CategoryTheory.CategoryStruct.comp (c.ι.app j) g)","decl":"/-- Given a cocone `c` for a functor `F : J ⥤ C` from a well-ordered type,\nand maps `p : X ⟶ Y`, `f : F.obj ⊥ ⟶ X`, `g : c.pt ⟶ Y`, this structure\ncontains the data of a map `F.obj j ⟶ X` such that `F.map (homOfLE bot_le) ≫ f' = f`\nand `f' ≫ p = c.ι.app j ≫ g`. (This implies that the outer square below\ncommutes, see `SqStruct.w`.)\n\n```\n         f\nF.obj ⊥ --> X\n   |      Λ |\n   |   f'╱  |\n   v    ╱   |\nF.obj j     | p\n   |        |\n   |        |\n   v    g   v\n  c.pt ---> Y\n```\n-/\n@[ext]\nstructure SqStruct (j : J) where\n  /-- a morphism `F.obj j ⟶ X` -/\n  f' : F.obj j ⟶ X\n  w₁ : F.map (homOfLE bot_le) ≫ f' = f := by aesop_cat\n  w₂ : f' ≫ p = c.ι.app j ≫ g := by aesop_cat\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct.mk.inj","module":"Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝¹ : LinearOrder J\ninst✝ : OrderBot J\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nX Y : C\np : Quiver.Hom X Y\nf : Quiver.Hom (F.obj Bot.bot) X\ng : Quiver.Hom c.pt Y\nj : J\nf'✝ : Quiver.Hom (F.obj j) X\nw₁✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.homOfLE ⋯)) f'✝) f) _auto✝\nw₂✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp f'✝ p) (CategoryTheory.CategoryStruct.comp (c.ι.app j) g)) _auto✝\nf' : Quiver.Hom (F.obj j) X\nw₁ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.homOfLE ⋯)) f') f) _auto✝\nw₂ : autoParam (Eq (CategoryTheory.CategoryStruct.comp f' p) (CategoryTheory.CategoryStruct.comp (c.ι.app j) g)) _auto✝\nx✝ : Eq { f' := f'✝, w₁ := w₁✝, w₂ := w₂✝ } { f' := f', w₁ := w₁, w₂ := w₂ }\n⊢ Eq f'✝ f'","decl":"/-- Given a cocone `c` for a functor `F : J ⥤ C` from a well-ordered type,\nand maps `p : X ⟶ Y`, `f : F.obj ⊥ ⟶ X`, `g : c.pt ⟶ Y`, this structure\ncontains the data of a map `F.obj j ⟶ X` such that `F.map (homOfLE bot_le) ≫ f' = f`\nand `f' ≫ p = c.ι.app j ≫ g`. (This implies that the outer square below\ncommutes, see `SqStruct.w`.)\n\n```\n         f\nF.obj ⊥ --> X\n   |      Λ |\n   |   f'╱  |\n   v    ╱   |\nF.obj j     | p\n   |        |\n   |        |\n   v    g   v\n  c.pt ---> Y\n```\n-/\n@[ext]\nstructure SqStruct (j : J) where\n  /-- a morphism `F.obj j ⟶ X` -/\n  f' : F.obj j ⟶ X\n  w₁ : F.map (homOfLE bot_le) ≫ f' = f := by aesop_cat\n  w₂ : f' ≫ p = c.ι.app j ≫ g := by aesop_cat\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct.ext","module":"Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝¹ : LinearOrder J\ninst✝ : OrderBot J\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nX Y : C\np : Quiver.Hom X Y\nf : Quiver.Hom (F.obj Bot.bot) X\ng : Quiver.Hom c.pt Y\nj : J\nx y : CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct c p f g j\nf' : Eq x.f' y.f'\n⊢ Eq x y","decl":"/-- Given a cocone `c` for a functor `F : J ⥤ C` from a well-ordered type,\nand maps `p : X ⟶ Y`, `f : F.obj ⊥ ⟶ X`, `g : c.pt ⟶ Y`, this structure\ncontains the data of a map `F.obj j ⟶ X` such that `F.map (homOfLE bot_le) ≫ f' = f`\nand `f' ≫ p = c.ι.app j ≫ g`. (This implies that the outer square below\ncommutes, see `SqStruct.w`.)\n\n```\n         f\nF.obj ⊥ --> X\n   |      Λ |\n   |   f'╱  |\n   v    ╱   |\nF.obj j     | p\n   |        |\n   |        |\n   v    g   v\n  c.pt ---> Y\n```\n-/\n@[ext]\nstructure SqStruct (j : J) where\n  /-- a morphism `F.obj j ⟶ X` -/\n  f' : F.obj j ⟶ X\n  w₁ : F.map (homOfLE bot_le) ≫ f' = f := by aesop_cat\n  w₂ : f' ≫ p = c.ι.app j ≫ g := by aesop_cat\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct.ext_iff","module":"Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝¹ : LinearOrder J\ninst✝ : OrderBot J\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nX Y : C\np : Quiver.Hom X Y\nf : Quiver.Hom (F.obj Bot.bot) X\ng : Quiver.Hom c.pt Y\nj : J\nx y : CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct c p f g j\n⊢ Iff (Eq x y) (Eq x.f' y.f')","decl":"/-- Given a cocone `c` for a functor `F : J ⥤ C` from a well-ordered type,\nand maps `p : X ⟶ Y`, `f : F.obj ⊥ ⟶ X`, `g : c.pt ⟶ Y`, this structure\ncontains the data of a map `F.obj j ⟶ X` such that `F.map (homOfLE bot_le) ≫ f' = f`\nand `f' ≫ p = c.ι.app j ≫ g`. (This implies that the outer square below\ncommutes, see `SqStruct.w`.)\n\n```\n         f\nF.obj ⊥ --> X\n   |      Λ |\n   |   f'╱  |\n   v    ╱   |\nF.obj j     | p\n   |        |\n   |        |\n   v    g   v\n  c.pt ---> Y\n```\n-/\n@[ext]\nstructure SqStruct (j : J) where\n  /-- a morphism `F.obj j ⟶ X` -/\n  f' : F.obj j ⟶ X\n  w₁ : F.map (homOfLE bot_le) ≫ f' = f := by aesop_cat\n  w₂ : f' ≫ p = c.ι.app j ≫ g := by aesop_cat\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct.w₁_assoc","module":"Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝¹ : LinearOrder J\ninst✝ : OrderBot J\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nX Y : C\np : Quiver.Hom X Y\nf : Quiver.Hom (F.obj Bot.bot) X\ng : Quiver.Hom c.pt Y\nj : J\nself : CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct c p f g j\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.homOfLE ⋯)) (CategoryTheory.CategoryStruct.comp self.f' h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"attribute [reassoc (attr := simp)] w₁ w₂\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct.w₂_assoc","module":"Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝¹ : LinearOrder J\ninst✝ : OrderBot J\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nX Y : C\np : Quiver.Hom X Y\nf : Quiver.Hom (F.obj Bot.bot) X\ng : Quiver.Hom c.pt Y\nj : J\nself : CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct c p f g j\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.f' (CategoryTheory.CategoryStruct.comp p h)) (CategoryTheory.CategoryStruct.comp (c.ι.app j) (CategoryTheory.CategoryStruct.comp g h))","decl":"attribute [reassoc (attr := simp)] w₁ w₂\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct.w_assoc","module":"Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝¹ : LinearOrder J\ninst✝ : OrderBot J\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nX Y : C\np : Quiver.Hom X Y\nf : Quiver.Hom (F.obj Bot.bot) X\ng : Quiver.Hom c.pt Y\nj : J\nsq' : CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct c p f g j\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp p h)) (CategoryTheory.CategoryStruct.comp (c.ι.app Bot.bot) (CategoryTheory.CategoryStruct.comp g h))","decl":"include sq' in\n@[reassoc]\nlemma w : f ≫ p = c.ι.app ⊥ ≫ g := by\n  rw [← sq'.w₁, assoc, sq'.w₂, Cocone.w_assoc]\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct.w","module":"Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝¹ : LinearOrder J\ninst✝ : OrderBot J\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nX Y : C\np : Quiver.Hom X Y\nf : Quiver.Hom (F.obj Bot.bot) X\ng : Quiver.Hom c.pt Y\nj : J\nsq' : CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct c p f g j\n⊢ Eq (CategoryTheory.CategoryStruct.comp f p) (CategoryTheory.CategoryStruct.comp (c.ι.app Bot.bot) g)","decl":"include sq' in\n@[reassoc]\nlemma w : f ≫ p = c.ι.app ⊥ ≫ g := by\n  rw [← sq'.w₁, assoc, sq'.w₂, Cocone.w_assoc]\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct.sq","module":"Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝² : LinearOrder J\ninst✝¹ : OrderBot J\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nX Y : C\np : Quiver.Hom X Y\nf : Quiver.Hom (F.obj Bot.bot) X\ng : Quiver.Hom c.pt Y\nj : J\nsq' : CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct c p f g j\ninst✝ : SuccOrder J\n⊢ CategoryTheory.CommSq sq'.f' (F.map (CategoryTheory.homOfLE ⋯)) p (CategoryTheory.CategoryStruct.comp (c.ι.app (Order.succ j)) g)","decl":"/--\nGiven `sq' : SqStruct c p f g j`, this is the commutative square\n```\n               sq'.f'\nF.obj j --------------------> X\n   |                          |\n   |                          |p\n   v                      g   v\nF.obj (succ j) ---> c.pt ---> Y\n```\n\n(Using the lifting property for this square is the key ingredient\nin the proof that the left lifting property with respect to `p`\nis stable under transfinite composition.) -/\nlemma sq [SuccOrder J] :\n    CommSq sq'.f' (F.map (homOfLE (Order.le_succ j))) p (c.ι.app _ ≫ g) where\n  w := by simp\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct.map_f'","module":"Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝¹ : LinearOrder J\ninst✝ : OrderBot J\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nX Y : C\np : Quiver.Hom X Y\nf : Quiver.Hom (F.obj Bot.bot) X\ng : Quiver.Hom c.pt Y\nj : J\nsq' : CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct c p f g j\nj' : J\nα : Quiver.Hom j' j\n⊢ Eq (sq'.map α).f' (CategoryTheory.CategoryStruct.comp (F.map α) sq'.f')","decl":"/-- Auxiliary definition for `sqFunctor`. -/\n@[simps]\ndef map {j' : J} (α : j' ⟶ j) : SqStruct c p f g j' where\n  f' := F.map α ≫ sq'.f'\n  w₁ := by\n    rw [← F.map_comp_assoc]\n    exact sq'.w₁\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.transfiniteComposition.sqFunctor_obj","module":"Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝¹ : LinearOrder J\ninst✝ : OrderBot J\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nX Y : C\np : Quiver.Hom X Y\nf : Quiver.Hom (F.obj Bot.bot) X\ng : Quiver.Hom c.pt Y\nj : Opposite J\n⊢ Eq ((CategoryTheory.HasLiftingProperty.transfiniteComposition.sqFunctor c p f g).obj j) (CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct c p f g (Opposite.unop j))","decl":"/-- The projective system `j ↦ SqStruct c p f g j.unop`. -/\n@[simps]\ndef sqFunctor : Jᵒᵖ ⥤ Type _ where\n  obj j := SqStruct c p f g j.unop\n  map α sq' := sq'.map α.unop\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.transfiniteComposition.sqFunctor_map","module":"Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝¹ : LinearOrder J\ninst✝ : OrderBot J\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nX Y : C\np : Quiver.Hom X Y\nf : Quiver.Hom (F.obj Bot.bot) X\ng : Quiver.Hom c.pt Y\nX✝ Y✝ : Opposite J\nα : Quiver.Hom X✝ Y✝\nsq' : CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct c p f g (Opposite.unop X✝)\n⊢ Eq ((CategoryTheory.HasLiftingProperty.transfiniteComposition.sqFunctor c p f g).map α sq') (sq'.map α.unop)","decl":"/-- The projective system `j ↦ SqStruct c p f g j.unop`. -/\n@[simps]\ndef sqFunctor : Jᵒᵖ ⥤ Type _ where\n  obj j := SqStruct c p f g j.unop\n  map α sq' := sq'.map α.unop\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.transfiniteComposition.wellOrderInductionData.liftHom_fac_assoc","module":"Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝² : LinearOrder J\ninst✝¹ : OrderBot J\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nX Y : C\np : Quiver.Hom X Y\nf : Quiver.Hom (F.obj Bot.bot) X\ng : Quiver.Hom c.pt Y\ninst✝ : F.IsWellOrderContinuous\nj : J\nhj : Order.IsSuccLimit j\ns : ↑(⋯.functor.op.comp (CategoryTheory.HasLiftingProperty.transfiniteComposition.sqFunctor c p f g)).sections\ni : J\nhi : LT.lt i j\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.homOfLE ⋯)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.HasLiftingProperty.transfiniteComposition.wellOrderInductionData.liftHom hj s) h)) (CategoryTheory.CategoryStruct.comp (↑s { unop := ⟨i, hi⟩ }).f' h)","decl":"@[reassoc]\nlemma liftHom_fac (i : J) (hi : i < j) :\n    F.map (homOfLE hi.le) ≫ liftHom hj s = (s.1 ⟨⟨i, hi⟩⟩).f' :=\n  (F.isColimitOfIsWellOrderContinuous j hj).fac _ ⟨i, hi⟩\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.transfiniteComposition.wellOrderInductionData.liftHom_fac","module":"Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝² : LinearOrder J\ninst✝¹ : OrderBot J\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nX Y : C\np : Quiver.Hom X Y\nf : Quiver.Hom (F.obj Bot.bot) X\ng : Quiver.Hom c.pt Y\ninst✝ : F.IsWellOrderContinuous\nj : J\nhj : Order.IsSuccLimit j\ns : ↑(⋯.functor.op.comp (CategoryTheory.HasLiftingProperty.transfiniteComposition.sqFunctor c p f g)).sections\ni : J\nhi : LT.lt i j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.homOfLE ⋯)) (CategoryTheory.HasLiftingProperty.transfiniteComposition.wellOrderInductionData.liftHom hj s)) (↑s { unop := ⟨i, hi⟩ }).f'","decl":"@[reassoc]\nlemma liftHom_fac (i : J) (hi : i < j) :\n    F.map (homOfLE hi.le) ≫ liftHom hj s = (s.1 ⟨⟨i, hi⟩⟩).f' :=\n  (F.isColimitOfIsWellOrderContinuous j hj).fac _ ⟨i, hi⟩\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.transfiniteComposition.wellOrderInductionData.lift_f'","module":"Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝² : LinearOrder J\ninst✝¹ : OrderBot J\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nX Y : C\np : Quiver.Hom X Y\nf : Quiver.Hom (F.obj Bot.bot) X\ng : Quiver.Hom c.pt Y\ninst✝ : F.IsWellOrderContinuous\nj : J\nhj : Order.IsSuccLimit j\ns : ↑(⋯.functor.op.comp (CategoryTheory.HasLiftingProperty.transfiniteComposition.sqFunctor c p f g)).sections\n⊢ Eq (CategoryTheory.HasLiftingProperty.transfiniteComposition.wellOrderInductionData.lift hj s).f' (CategoryTheory.HasLiftingProperty.transfiniteComposition.wellOrderInductionData.liftHom hj s)","decl":"/-- Auxiliary definition for `transfiniteComposition.wellOrderInductionData`. -/\n@[simps]\nnoncomputable def lift : (sqFunctor c p f g).obj (Opposite.op j) where\n  f' := liftHom hj s\n  w₁ := by\n    have h : ⊥ < j := Ne.bot_lt' (by\n      rintro rfl\n      exact Order.not_isSuccLimit_bot hj)\n    rw [liftHom_fac hj s ⊥ h]\n    simpa using (s.1 ⟨⊥, h⟩).w₁\n  w₂ := (F.isColimitOfIsWellOrderContinuous j hj).hom_ext (fun ⟨i, hij⟩ ↦ by\n    have := (s.1 ⟨i, hij⟩).w₂\n    dsimp at this ⊢\n    rw [liftHom_fac_assoc _ _ _ hij, this, Cocone.w_assoc])\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.transfiniteComposition.wellOrderInductionData.map_lift","module":"Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝² : LinearOrder J\ninst✝¹ : OrderBot J\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nX Y : C\np : Quiver.Hom X Y\nf : Quiver.Hom (F.obj Bot.bot) X\ng : Quiver.Hom c.pt Y\ninst✝ : F.IsWellOrderContinuous\nj : J\nhj : Order.IsSuccLimit j\ns : ↑(⋯.functor.op.comp (CategoryTheory.HasLiftingProperty.transfiniteComposition.sqFunctor c p f g)).sections\ni : J\nhij : LT.lt i j\n⊢ Eq (CategoryTheory.HasLiftingProperty.transfiniteComposition.SqStruct.map (CategoryTheory.HasLiftingProperty.transfiniteComposition.wellOrderInductionData.lift hj s) (CategoryTheory.homOfLE ⋯)) (↑s { unop := ⟨i, hij⟩ })","decl":"lemma map_lift {i : J} (hij : i < j) :\n    (lift hj s).map (homOfLE hij.le) = s.1 ⟨⟨i, hij⟩⟩ := by\n  ext\n  apply liftHom_fac\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.transfiniteComposition.hasLift","module":"Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝⁴ : LinearOrder J\ninst✝³ : OrderBot J\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\nX Y : C\np : Quiver.Hom X Y\nf : Quiver.Hom (F.obj Bot.bot) X\ng : Quiver.Hom c.pt Y\ninst✝² : F.IsWellOrderContinuous\ninst✝¹ : SuccOrder J\ninst✝ : WellFoundedLT J\nhF : ∀ (j : J), Not (IsMax j) → CategoryTheory.HasLiftingProperty (F.map (CategoryTheory.homOfLE ⋯)) p\nsq : CategoryTheory.CommSq f (c.ι.app Bot.bot) p g\n⊢ sq.HasLift","decl":"lemma hasLift : sq.HasLift := by\n  obtain ⟨s, hs⟩ := (wellOrderInductionData c f g hF).surjective { w₂ := sq.w }\n  replace hs := congr_arg SqStruct.f' hs\n  dsimp at hs\n  let t : Cocone F := Cocone.mk X\n    { app j := (s.1 ⟨j⟩).f'\n      naturality j j' g := by simpa using congr_arg SqStruct.f' (s.2 g.op) }\n  let l := hc.desc t\n  have hl (j : J) : c.ι.app j ≫ l = (s.1 ⟨j⟩).f' := hc.fac t j\n  exact ⟨⟨{\n    l := l\n    fac_left := by rw [hl, hs]\n    fac_right := hc.hom_ext (fun j ↦ by rw [reassoc_of% (hl j), SqStruct.w₂])}⟩⟩\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.transfiniteComposition.hasLiftingProperty_ι_app_bot","module":"Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝⁴ : LinearOrder J\ninst✝³ : OrderBot J\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\nX Y : C\np : Quiver.Hom X Y\ninst✝² : F.IsWellOrderContinuous\ninst✝¹ : SuccOrder J\ninst✝ : WellFoundedLT J\nhF : ∀ (j : J), Not (IsMax j) → CategoryTheory.HasLiftingProperty (F.map (CategoryTheory.homOfLE ⋯)) p\n⊢ CategoryTheory.HasLiftingProperty (c.ι.app Bot.bot) p","decl":"lemma hasLiftingProperty_ι_app_bot : HasLiftingProperty (c.ι.app ⊥) p where\n  sq_hasLift sq := hasLift hc hF sq\n\n"}
