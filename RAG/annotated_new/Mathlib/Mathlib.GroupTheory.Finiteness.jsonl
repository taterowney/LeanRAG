{"name":"Submonoid.fg_iff","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nP : Submonoid M\n⊢ Iff P.FG (Exists fun S => And (Eq (Submonoid.closure S) P) S.Finite)","decl":"/-- An equivalent expression of `Submonoid.FG` in terms of `Set.Finite` instead of `Finset`. -/\n@[to_additive \"An equivalent expression of `AddSubmonoid.FG` in terms of `Set.Finite` instead of\n`Finset`.\"]\ntheorem Submonoid.fg_iff (P : Submonoid M) :\n    Submonoid.FG P ↔ ∃ S : Set M, Submonoid.closure S = P ∧ S.Finite :=\n  ⟨fun ⟨S, hS⟩ => ⟨S, hS, Finset.finite_toSet S⟩, fun ⟨S, hS, hf⟩ =>\n    ⟨Set.Finite.toFinset hf, by simp [hS]⟩⟩\n\n"}
{"name":"AddSubmonoid.fg_iff","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nP : AddSubmonoid M\n⊢ Iff P.FG (Exists fun S => And (Eq (AddSubmonoid.closure S) P) S.Finite)","decl":"/-- An equivalent expression of `Submonoid.FG` in terms of `Set.Finite` instead of `Finset`. -/\n@[to_additive \"An equivalent expression of `AddSubmonoid.FG` in terms of `Set.Finite` instead of\n`Finset`.\"]\ntheorem Submonoid.fg_iff (P : Submonoid M) :\n    Submonoid.FG P ↔ ∃ S : Set M, Submonoid.closure S = P ∧ S.Finite :=\n  ⟨fun ⟨S, hS⟩ => ⟨S, hS, Finset.finite_toSet S⟩, fun ⟨S, hS, hf⟩ =>\n    ⟨Set.Finite.toFinset hf, by simp [hS]⟩⟩\n\n"}
{"name":"Submonoid.fg_iff_add_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nP : Submonoid M\n⊢ Iff P.FG (Submonoid.toAddSubmonoid P).FG","decl":"theorem Submonoid.fg_iff_add_fg (P : Submonoid M) : P.FG ↔ P.toAddSubmonoid.FG :=\n  ⟨fun h =>\n    let ⟨S, hS, hf⟩ := (Submonoid.fg_iff _).1 h\n    (AddSubmonoid.fg_iff _).mpr\n      ⟨Additive.toMul ⁻¹' S, by simp [← Submonoid.toAddSubmonoid_closure, hS], hf⟩,\n    fun h =>\n    let ⟨T, hT, hf⟩ := (AddSubmonoid.fg_iff _).1 h\n    (Submonoid.fg_iff _).mpr\n      ⟨Multiplicative.ofAdd ⁻¹' T, by simp [← AddSubmonoid.toSubmonoid'_closure, hT], hf⟩⟩\n\n"}
{"name":"AddSubmonoid.fg_iff_mul_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"N : Type u_2\ninst✝ : AddMonoid N\nP : AddSubmonoid N\n⊢ Iff P.FG (AddSubmonoid.toSubmonoid P).FG","decl":"theorem AddSubmonoid.fg_iff_mul_fg (P : AddSubmonoid N) : P.FG ↔ P.toSubmonoid.FG := by\n  convert (Submonoid.fg_iff_add_fg (toSubmonoid P)).symm\n\n"}
{"name":"Monoid.FG.out","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nself : Monoid.FG M\n⊢ Top.top.FG","decl":"/-- A monoid is finitely generated if it is finitely generated as a submonoid of itself. -/\nclass Monoid.FG : Prop where\n  out : (⊤ : Submonoid M).FG\n\n"}
{"name":"AddMonoid.FG.out","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"N : Type u_2\ninst✝ : AddMonoid N\nself : AddMonoid.FG N\n⊢ Top.top.FG","decl":"/-- An additive monoid is finitely generated if it is finitely generated as an additive submonoid of\nitself. -/\nclass AddMonoid.FG : Prop where\n  out : (⊤ : AddSubmonoid N).FG\n\n"}
{"name":"Monoid.fg_def","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ Iff (Monoid.FG M) Top.top.FG","decl":"theorem Monoid.fg_def : Monoid.FG M ↔ (⊤ : Submonoid M).FG :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n\n"}
{"name":"AddMonoid.fg_def","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"N : Type u_2\ninst✝ : AddMonoid N\n⊢ Iff (AddMonoid.FG N) Top.top.FG","decl":"theorem AddMonoid.fg_def : AddMonoid.FG N ↔ (⊤ : AddSubmonoid N).FG :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n\n"}
{"name":"Monoid.fg_iff","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ Iff (Monoid.FG M) (Exists fun S => And (Eq (Submonoid.closure S) Top.top) S.Finite)","decl":"/-- An equivalent expression of `Monoid.FG` in terms of `Set.Finite` instead of `Finset`. -/\n@[to_additive\n      \"An equivalent expression of `AddMonoid.FG` in terms of `Set.Finite` instead of `Finset`.\"]\ntheorem Monoid.fg_iff :\n    Monoid.FG M ↔ ∃ S : Set M, Submonoid.closure S = (⊤ : Submonoid M) ∧ S.Finite :=\n  ⟨fun h => (Submonoid.fg_iff ⊤).1 h.out, fun h => ⟨(Submonoid.fg_iff ⊤).2 h⟩⟩\n\n"}
{"name":"AddMonoid.fg_iff","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\n⊢ Iff (AddMonoid.FG M) (Exists fun S => And (Eq (AddSubmonoid.closure S) Top.top) S.Finite)","decl":"/-- An equivalent expression of `Monoid.FG` in terms of `Set.Finite` instead of `Finset`. -/\n@[to_additive\n      \"An equivalent expression of `AddMonoid.FG` in terms of `Set.Finite` instead of `Finset`.\"]\ntheorem Monoid.fg_iff :\n    Monoid.FG M ↔ ∃ S : Set M, Submonoid.closure S = (⊤ : Submonoid M) ∧ S.Finite :=\n  ⟨fun h => (Submonoid.fg_iff ⊤).1 h.out, fun h => ⟨(Submonoid.fg_iff ⊤).2 h⟩⟩\n\n"}
{"name":"Monoid.fg_iff_add_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ Iff (Monoid.FG M) (AddMonoid.FG (Additive M))","decl":"theorem Monoid.fg_iff_add_fg : Monoid.FG M ↔ AddMonoid.FG (Additive M) :=\n  ⟨fun h => ⟨(Submonoid.fg_iff_add_fg ⊤).1 h.out⟩, fun h => ⟨(Submonoid.fg_iff_add_fg ⊤).2 h.out⟩⟩\n\n"}
{"name":"AddMonoid.fg_iff_mul_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"N : Type u_2\ninst✝ : AddMonoid N\n⊢ Iff (AddMonoid.FG N) (Monoid.FG (Multiplicative N))","decl":"theorem AddMonoid.fg_iff_mul_fg : AddMonoid.FG N ↔ Monoid.FG (Multiplicative N) :=\n  ⟨fun h => ⟨(AddSubmonoid.fg_iff_mul_fg ⊤).1 h.out⟩, fun h =>\n    ⟨(AddSubmonoid.fg_iff_mul_fg ⊤).2 h.out⟩⟩\n\n"}
{"name":"AddMonoid.fg_of_monoid_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝¹ : Monoid M\ninst✝ : Monoid.FG M\n⊢ AddMonoid.FG (Additive M)","decl":"instance AddMonoid.fg_of_monoid_fg [Monoid.FG M] : AddMonoid.FG (Additive M) :=\n  Monoid.fg_iff_add_fg.1 ‹_›\n\n"}
{"name":"Monoid.fg_of_addMonoid_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"N : Type u_2\ninst✝¹ : AddMonoid N\ninst✝ : AddMonoid.FG N\n⊢ Monoid.FG (Multiplicative N)","decl":"instance Monoid.fg_of_addMonoid_fg [AddMonoid.FG N] : Monoid.FG (Multiplicative N) :=\n  AddMonoid.fg_iff_mul_fg.1 ‹_›\n\n"}
{"name":"Monoid.fg_of_finite","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝¹ : Monoid M\ninst✝ : Finite M\n⊢ Monoid.FG M","decl":"@[to_additive]\ninstance (priority := 100) Monoid.fg_of_finite [Finite M] : Monoid.FG M := by\n  cases nonempty_fintype M\n  exact ⟨⟨Finset.univ, by rw [Finset.coe_univ]; exact Submonoid.closure_univ⟩⟩\n\n"}
{"name":"AddMonoid.fg_of_finite","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝¹ : AddMonoid M\ninst✝ : Finite M\n⊢ AddMonoid.FG M","decl":"@[to_additive]\ninstance (priority := 100) Monoid.fg_of_finite [Finite M] : Monoid.FG M := by\n  cases nonempty_fintype M\n  exact ⟨⟨Finset.univ, by rw [Finset.coe_univ]; exact Submonoid.closure_univ⟩⟩\n\n"}
{"name":"Submonoid.FG.map","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝¹ : Monoid M\nM' : Type u_3\ninst✝ : Monoid M'\nP : Submonoid M\nh : P.FG\ne : MonoidHom M M'\n⊢ (Submonoid.map e P).FG","decl":"@[to_additive]\ntheorem Submonoid.FG.map {M' : Type*} [Monoid M'] {P : Submonoid M} (h : P.FG) (e : M →* M') :\n    (P.map e).FG := by\n  classical\n    obtain ⟨s, rfl⟩ := h\n    exact ⟨s.image e, by rw [Finset.coe_image, MonoidHom.map_mclosure]⟩\n\n"}
{"name":"AddSubmonoid.FG.map","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝¹ : AddMonoid M\nM' : Type u_3\ninst✝ : AddMonoid M'\nP : AddSubmonoid M\nh : P.FG\ne : AddMonoidHom M M'\n⊢ (AddSubmonoid.map e P).FG","decl":"@[to_additive]\ntheorem Submonoid.FG.map {M' : Type*} [Monoid M'] {P : Submonoid M} (h : P.FG) (e : M →* M') :\n    (P.map e).FG := by\n  classical\n    obtain ⟨s, rfl⟩ := h\n    exact ⟨s.image e, by rw [Finset.coe_image, MonoidHom.map_mclosure]⟩\n\n"}
{"name":"Submonoid.FG.map_injective","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝¹ : Monoid M\nM' : Type u_3\ninst✝ : Monoid M'\nP : Submonoid M\ne : MonoidHom M M'\nhe : Function.Injective ⇑e\nh : (Submonoid.map e P).FG\n⊢ P.FG","decl":"@[to_additive]\ntheorem Submonoid.FG.map_injective {M' : Type*} [Monoid M'] {P : Submonoid M} (e : M →* M')\n    (he : Function.Injective e) (h : (P.map e).FG) : P.FG := by\n  obtain ⟨s, hs⟩ := h\n  use s.preimage e he.injOn\n  apply Submonoid.map_injective_of_injective he\n  rw [← hs, MonoidHom.map_mclosure e, Finset.coe_preimage]\n  congr\n  rw [Set.image_preimage_eq_iff, ← MonoidHom.coe_mrange e, ← Submonoid.closure_le, hs,\n      MonoidHom.mrange_eq_map e]\n  exact Submonoid.monotone_map le_top\n\n"}
{"name":"AddSubmonoid.FG.map_injective","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝¹ : AddMonoid M\nM' : Type u_3\ninst✝ : AddMonoid M'\nP : AddSubmonoid M\ne : AddMonoidHom M M'\nhe : Function.Injective ⇑e\nh : (AddSubmonoid.map e P).FG\n⊢ P.FG","decl":"@[to_additive]\ntheorem Submonoid.FG.map_injective {M' : Type*} [Monoid M'] {P : Submonoid M} (e : M →* M')\n    (he : Function.Injective e) (h : (P.map e).FG) : P.FG := by\n  obtain ⟨s, hs⟩ := h\n  use s.preimage e he.injOn\n  apply Submonoid.map_injective_of_injective he\n  rw [← hs, MonoidHom.map_mclosure e, Finset.coe_preimage]\n  congr\n  rw [Set.image_preimage_eq_iff, ← MonoidHom.coe_mrange e, ← Submonoid.closure_le, hs,\n      MonoidHom.mrange_eq_map e]\n  exact Submonoid.monotone_map le_top\n\n"}
{"name":"AddMonoid.fg_iff_addSubmonoid_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nN : AddSubmonoid M\n⊢ Iff (AddMonoid.FG (Subtype fun x => Membership.mem N x)) N.FG","decl":"@[to_additive (attr := simp)]\ntheorem Monoid.fg_iff_submonoid_fg (N : Submonoid M) : Monoid.FG N ↔ N.FG := by\n  conv_rhs => rw [← N.mrange_subtype, MonoidHom.mrange_eq_map]\n  exact ⟨fun h => h.out.map N.subtype, fun h => ⟨h.map_injective N.subtype Subtype.coe_injective⟩⟩\n\n"}
{"name":"Monoid.fg_iff_submonoid_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nN : Submonoid M\n⊢ Iff (Monoid.FG (Subtype fun x => Membership.mem N x)) N.FG","decl":"@[to_additive (attr := simp)]\ntheorem Monoid.fg_iff_submonoid_fg (N : Submonoid M) : Monoid.FG N ↔ N.FG := by\n  conv_rhs => rw [← N.mrange_subtype, MonoidHom.mrange_eq_map]\n  exact ⟨fun h => h.out.map N.subtype, fun h => ⟨h.map_injective N.subtype Subtype.coe_injective⟩⟩\n\n"}
{"name":"AddMonoid.fg_of_surjective","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝² : AddMonoid M\nM' : Type u_3\ninst✝¹ : AddMonoid M'\ninst✝ : AddMonoid.FG M\nf : AddMonoidHom M M'\nhf : Function.Surjective ⇑f\n⊢ AddMonoid.FG M'","decl":"@[to_additive]\ntheorem Monoid.fg_of_surjective {M' : Type*} [Monoid M'] [Monoid.FG M] (f : M →* M')\n    (hf : Function.Surjective f) : Monoid.FG M' := by\n  classical\n    obtain ⟨s, hs⟩ := Monoid.fg_def.mp ‹_›\n    use s.image f\n    rwa [Finset.coe_image, ← MonoidHom.map_mclosure, hs, ← MonoidHom.mrange_eq_map,\n      MonoidHom.mrange_eq_top]\n\n"}
{"name":"Monoid.fg_of_surjective","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝² : Monoid M\nM' : Type u_3\ninst✝¹ : Monoid M'\ninst✝ : Monoid.FG M\nf : MonoidHom M M'\nhf : Function.Surjective ⇑f\n⊢ Monoid.FG M'","decl":"@[to_additive]\ntheorem Monoid.fg_of_surjective {M' : Type*} [Monoid M'] [Monoid.FG M] (f : M →* M')\n    (hf : Function.Surjective f) : Monoid.FG M' := by\n  classical\n    obtain ⟨s, hs⟩ := Monoid.fg_def.mp ‹_›\n    use s.image f\n    rwa [Finset.coe_image, ← MonoidHom.map_mclosure, hs, ← MonoidHom.mrange_eq_map,\n      MonoidHom.mrange_eq_top]\n\n"}
{"name":"Monoid.fg_range","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝² : Monoid M\nM' : Type u_3\ninst✝¹ : Monoid M'\ninst✝ : Monoid.FG M\nf : MonoidHom M M'\n⊢ Monoid.FG (Subtype fun x => Membership.mem (MonoidHom.mrange f) x)","decl":"@[to_additive]\ninstance Monoid.fg_range {M' : Type*} [Monoid M'] [Monoid.FG M] (f : M →* M') :\n    Monoid.FG (MonoidHom.mrange f) :=\n  Monoid.fg_of_surjective f.mrangeRestrict f.mrangeRestrict_surjective\n\n"}
{"name":"AddMonoid.fg_range","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝² : AddMonoid M\nM' : Type u_3\ninst✝¹ : AddMonoid M'\ninst✝ : AddMonoid.FG M\nf : AddMonoidHom M M'\n⊢ AddMonoid.FG (Subtype fun x => Membership.mem (AddMonoidHom.mrange f) x)","decl":"@[to_additive]\ninstance Monoid.fg_range {M' : Type*} [Monoid M'] [Monoid.FG M] (f : M →* M') :\n    Monoid.FG (MonoidHom.mrange f) :=\n  Monoid.fg_of_surjective f.mrangeRestrict f.mrangeRestrict_surjective\n\n"}
{"name":"AddSubmonoid.multiples_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nr : M\n⊢ (AddSubmonoid.multiples r).FG","decl":"@[to_additive]\ntheorem Submonoid.powers_fg (r : M) : (Submonoid.powers r).FG :=\n  ⟨{r}, (Finset.coe_singleton r).symm ▸ (Submonoid.powers_eq_closure r).symm⟩\n\n"}
{"name":"Submonoid.powers_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nr : M\n⊢ (Submonoid.powers r).FG","decl":"@[to_additive]\ntheorem Submonoid.powers_fg (r : M) : (Submonoid.powers r).FG :=\n  ⟨{r}, (Finset.coe_singleton r).symm ▸ (Submonoid.powers_eq_closure r).symm⟩\n\n"}
{"name":"AddMonoid.multiples_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nr : M\n⊢ AddMonoid.FG (Subtype fun x => Membership.mem (AddSubmonoid.multiples r) x)","decl":"@[to_additive]\ninstance Monoid.powers_fg (r : M) : Monoid.FG (Submonoid.powers r) :=\n  (Monoid.fg_iff_submonoid_fg _).mpr (Submonoid.powers_fg r)\n\n"}
{"name":"Monoid.powers_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nr : M\n⊢ Monoid.FG (Subtype fun x => Membership.mem (Submonoid.powers r) x)","decl":"@[to_additive]\ninstance Monoid.powers_fg (r : M) : Monoid.FG (Submonoid.powers r) :=\n  (Monoid.fg_iff_submonoid_fg _).mpr (Submonoid.powers_fg r)\n\n"}
{"name":"Monoid.closure_finset_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝ : Monoid M\ns : Finset M\n⊢ Monoid.FG (Subtype fun x => Membership.mem (Submonoid.closure ↑s) x)","decl":"@[to_additive]\ninstance Monoid.closure_finset_fg (s : Finset M) : Monoid.FG (Submonoid.closure (s : Set M)) := by\n  refine ⟨⟨s.preimage Subtype.val Subtype.coe_injective.injOn, ?_⟩⟩\n  rw [Finset.coe_preimage, Submonoid.closure_closure_coe_preimage]\n\n"}
{"name":"AddMonoid.closure_finset_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\ns : Finset M\n⊢ AddMonoid.FG (Subtype fun x => Membership.mem (AddSubmonoid.closure ↑s) x)","decl":"@[to_additive]\ninstance Monoid.closure_finset_fg (s : Finset M) : Monoid.FG (Submonoid.closure (s : Set M)) := by\n  refine ⟨⟨s.preimage Subtype.val Subtype.coe_injective.injOn, ?_⟩⟩\n  rw [Finset.coe_preimage, Submonoid.closure_closure_coe_preimage]\n\n"}
{"name":"Monoid.closure_finite_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝¹ : Monoid M\ns : Set M\ninst✝ : Finite ↑s\n⊢ Monoid.FG (Subtype fun x => Membership.mem (Submonoid.closure s) x)","decl":"@[to_additive]\ninstance Monoid.closure_finite_fg (s : Set M) [Finite s] : Monoid.FG (Submonoid.closure s) :=\n  haveI := Fintype.ofFinite s\n  s.coe_toFinset ▸ Monoid.closure_finset_fg s.toFinset\n\n"}
{"name":"AddMonoid.closure_finite_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"M : Type u_1\ninst✝¹ : AddMonoid M\ns : Set M\ninst✝ : Finite ↑s\n⊢ AddMonoid.FG (Subtype fun x => Membership.mem (AddSubmonoid.closure s) x)","decl":"@[to_additive]\ninstance Monoid.closure_finite_fg (s : Set M) [Finite s] : Monoid.FG (Submonoid.closure s) :=\n  haveI := Fintype.ofFinite s\n  s.coe_toFinset ▸ Monoid.closure_finset_fg s.toFinset\n\n"}
{"name":"AddSubgroup.fg_iff","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\nP : AddSubgroup G\n⊢ Iff P.FG (Exists fun S => And (Eq (AddSubgroup.closure S) P) S.Finite)","decl":"/-- An equivalent expression of `Subgroup.FG` in terms of `Set.Finite` instead of `Finset`. -/\n@[to_additive \"An equivalent expression of `AddSubgroup.fg` in terms of `Set.Finite` instead of\n`Finset`.\"]\ntheorem Subgroup.fg_iff (P : Subgroup G) :\n    Subgroup.FG P ↔ ∃ S : Set G, Subgroup.closure S = P ∧ S.Finite :=\n  ⟨fun ⟨S, hS⟩ => ⟨S, hS, Finset.finite_toSet S⟩, fun ⟨S, hS, hf⟩ =>\n    ⟨Set.Finite.toFinset hf, by simp [hS]⟩⟩\n\n"}
{"name":"Subgroup.fg_iff","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : Group G\nP : Subgroup G\n⊢ Iff P.FG (Exists fun S => And (Eq (Subgroup.closure S) P) S.Finite)","decl":"/-- An equivalent expression of `Subgroup.FG` in terms of `Set.Finite` instead of `Finset`. -/\n@[to_additive \"An equivalent expression of `AddSubgroup.fg` in terms of `Set.Finite` instead of\n`Finset`.\"]\ntheorem Subgroup.fg_iff (P : Subgroup G) :\n    Subgroup.FG P ↔ ∃ S : Set G, Subgroup.closure S = P ∧ S.Finite :=\n  ⟨fun ⟨S, hS⟩ => ⟨S, hS, Finset.finite_toSet S⟩, fun ⟨S, hS, hf⟩ =>\n    ⟨Set.Finite.toFinset hf, by simp [hS]⟩⟩\n\n"}
{"name":"Subgroup.fg_iff_submonoid_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : Group G\nP : Subgroup G\n⊢ Iff P.FG P.FG","decl":"/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\n@[to_additive \"An additive subgroup is finitely generated if\nand only if it is finitely generated as an additive submonoid.\"]\ntheorem Subgroup.fg_iff_submonoid_fg (P : Subgroup G) : P.FG ↔ P.toSubmonoid.FG := by\n  constructor\n  · rintro ⟨S, rfl⟩\n    rw [Submonoid.fg_iff]\n    refine ⟨S ∪ S⁻¹, ?_, S.finite_toSet.union S.finite_toSet.inv⟩\n    exact (Subgroup.closure_toSubmonoid _).symm\n  · rintro ⟨S, hS⟩\n    refine ⟨S, le_antisymm ?_ ?_⟩\n    · rw [Subgroup.closure_le, ← Subgroup.coe_toSubmonoid, ← hS]\n      exact Submonoid.subset_closure\n    · rw [← Subgroup.toSubmonoid_le, ← hS, Submonoid.closure_le]\n      exact Subgroup.subset_closure\n\n"}
{"name":"AddSubgroup.fg_iff_addSubmonoid_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\nP : AddSubgroup G\n⊢ Iff P.FG P.FG","decl":"/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\n@[to_additive \"An additive subgroup is finitely generated if\nand only if it is finitely generated as an additive submonoid.\"]\ntheorem Subgroup.fg_iff_submonoid_fg (P : Subgroup G) : P.FG ↔ P.toSubmonoid.FG := by\n  constructor\n  · rintro ⟨S, rfl⟩\n    rw [Submonoid.fg_iff]\n    refine ⟨S ∪ S⁻¹, ?_, S.finite_toSet.union S.finite_toSet.inv⟩\n    exact (Subgroup.closure_toSubmonoid _).symm\n  · rintro ⟨S, hS⟩\n    refine ⟨S, le_antisymm ?_ ?_⟩\n    · rw [Subgroup.closure_le, ← Subgroup.coe_toSubmonoid, ← hS]\n      exact Submonoid.subset_closure\n    · rw [← Subgroup.toSubmonoid_le, ← hS, Submonoid.closure_le]\n      exact Subgroup.subset_closure\n\n"}
{"name":"Subgroup.fg_iff_add_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : Group G\nP : Subgroup G\n⊢ Iff P.FG (Subgroup.toAddSubgroup P).FG","decl":"theorem Subgroup.fg_iff_add_fg (P : Subgroup G) : P.FG ↔ P.toAddSubgroup.FG := by\n  rw [Subgroup.fg_iff_submonoid_fg, AddSubgroup.fg_iff_addSubmonoid_fg]\n  exact (Subgroup.toSubmonoid P).fg_iff_add_fg\n\n"}
{"name":"AddSubgroup.fg_iff_mul_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"H : Type u_4\ninst✝ : AddGroup H\nP : AddSubgroup H\n⊢ Iff P.FG (AddSubgroup.toSubgroup P).FG","decl":"theorem AddSubgroup.fg_iff_mul_fg (P : AddSubgroup H) : P.FG ↔ P.toSubgroup.FG := by\n  rw [AddSubgroup.fg_iff_addSubmonoid_fg, Subgroup.fg_iff_submonoid_fg]\n  exact AddSubmonoid.fg_iff_mul_fg (AddSubgroup.toAddSubmonoid P)\n\n"}
{"name":"Group.FG.out","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : Group G\nself : Group.FG G\n⊢ Top.top.FG","decl":"/-- A group is finitely generated if it is finitely generated as a submonoid of itself. -/\nclass Group.FG : Prop where\n  out : (⊤ : Subgroup G).FG\n\n"}
{"name":"AddGroup.FG.out","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"H : Type u_4\ninst✝ : AddGroup H\nself : AddGroup.FG H\n⊢ Top.top.FG","decl":"/-- An additive group is finitely generated if it is finitely generated as an additive submonoid of\nitself. -/\nclass AddGroup.FG : Prop where\n  out : (⊤ : AddSubgroup H).FG\n\n"}
{"name":"Group.fg_def","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : Group G\n⊢ Iff (Group.FG G) Top.top.FG","decl":"theorem Group.fg_def : Group.FG G ↔ (⊤ : Subgroup G).FG :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n\n"}
{"name":"AddGroup.fg_def","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"H : Type u_4\ninst✝ : AddGroup H\n⊢ Iff (AddGroup.FG H) Top.top.FG","decl":"theorem AddGroup.fg_def : AddGroup.FG H ↔ (⊤ : AddSubgroup H).FG :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n\n"}
{"name":"AddGroup.fg_iff","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\n⊢ Iff (AddGroup.FG G) (Exists fun S => And (Eq (AddSubgroup.closure S) Top.top) S.Finite)","decl":"/-- An equivalent expression of `Group.FG` in terms of `Set.Finite` instead of `Finset`. -/\n@[to_additive\n      \"An equivalent expression of `AddGroup.fg` in terms of `Set.Finite` instead of `Finset`.\"]\ntheorem Group.fg_iff : Group.FG G ↔ ∃ S : Set G, Subgroup.closure S = (⊤ : Subgroup G) ∧ S.Finite :=\n  ⟨fun h => (Subgroup.fg_iff ⊤).1 h.out, fun h => ⟨(Subgroup.fg_iff ⊤).2 h⟩⟩\n\n"}
{"name":"Group.fg_iff","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : Group G\n⊢ Iff (Group.FG G) (Exists fun S => And (Eq (Subgroup.closure S) Top.top) S.Finite)","decl":"/-- An equivalent expression of `Group.FG` in terms of `Set.Finite` instead of `Finset`. -/\n@[to_additive\n      \"An equivalent expression of `AddGroup.fg` in terms of `Set.Finite` instead of `Finset`.\"]\ntheorem Group.fg_iff : Group.FG G ↔ ∃ S : Set G, Subgroup.closure S = (⊤ : Subgroup G) ∧ S.Finite :=\n  ⟨fun h => (Subgroup.fg_iff ⊤).1 h.out, fun h => ⟨(Subgroup.fg_iff ⊤).2 h⟩⟩\n\n"}
{"name":"Group.fg_iff'","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : Group G\n⊢ Iff (Group.FG G) (Exists fun n => Exists fun S => And (Eq S.card n) (Eq (Subgroup.closure ↑S) Top.top))","decl":"@[to_additive]\ntheorem Group.fg_iff' :\n    Group.FG G ↔ ∃ (n : _) (S : Finset G), S.card = n ∧ Subgroup.closure (S : Set G) = ⊤ :=\n  Group.fg_def.trans ⟨fun ⟨S, hS⟩ => ⟨S.card, S, rfl, hS⟩, fun ⟨_n, S, _hn, hS⟩ => ⟨S, hS⟩⟩\n\n"}
{"name":"AddGroup.fg_iff'","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\n⊢ Iff (AddGroup.FG G) (Exists fun n => Exists fun S => And (Eq S.card n) (Eq (AddSubgroup.closure ↑S) Top.top))","decl":"@[to_additive]\ntheorem Group.fg_iff' :\n    Group.FG G ↔ ∃ (n : _) (S : Finset G), S.card = n ∧ Subgroup.closure (S : Set G) = ⊤ :=\n  Group.fg_def.trans ⟨fun ⟨S, hS⟩ => ⟨S.card, S, rfl, hS⟩, fun ⟨_n, S, _hn, hS⟩ => ⟨S, hS⟩⟩\n\n"}
{"name":"Group.fg_iff_monoid_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : Group G\n⊢ Iff (Group.FG G) (Monoid.FG G)","decl":"/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\n@[to_additive \"An additive group is finitely generated if and only\nif it is finitely generated as an additive monoid.\"]\ntheorem Group.fg_iff_monoid_fg : Group.FG G ↔ Monoid.FG G :=\n  ⟨fun h => Monoid.fg_def.2 <| (Subgroup.fg_iff_submonoid_fg ⊤).1 (Group.fg_def.1 h), fun h =>\n    Group.fg_def.2 <| (Subgroup.fg_iff_submonoid_fg ⊤).2 (Monoid.fg_def.1 h)⟩\n\n"}
{"name":"AddGroup.fg_iff_addMonoid_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\n⊢ Iff (AddGroup.FG G) (AddMonoid.FG G)","decl":"/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\n@[to_additive \"An additive group is finitely generated if and only\nif it is finitely generated as an additive monoid.\"]\ntheorem Group.fg_iff_monoid_fg : Group.FG G ↔ Monoid.FG G :=\n  ⟨fun h => Monoid.fg_def.2 <| (Subgroup.fg_iff_submonoid_fg ⊤).1 (Group.fg_def.1 h), fun h =>\n    Group.fg_def.2 <| (Subgroup.fg_iff_submonoid_fg ⊤).2 (Monoid.fg_def.1 h)⟩\n\n"}
{"name":"AddGroup.fg_iff_addSubgroup_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Iff (AddGroup.FG (Subtype fun x => Membership.mem H x)) H.FG","decl":"@[to_additive (attr := simp)]\ntheorem Group.fg_iff_subgroup_fg (H : Subgroup G) : Group.FG H ↔ H.FG :=\n  (fg_iff_monoid_fg.trans (Monoid.fg_iff_submonoid_fg _)).trans\n    (Subgroup.fg_iff_submonoid_fg _).symm\n\n"}
{"name":"Group.fg_iff_subgroup_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : Group G\nH : Subgroup G\n⊢ Iff (Group.FG (Subtype fun x => Membership.mem H x)) H.FG","decl":"@[to_additive (attr := simp)]\ntheorem Group.fg_iff_subgroup_fg (H : Subgroup G) : Group.FG H ↔ H.FG :=\n  (fg_iff_monoid_fg.trans (Monoid.fg_iff_submonoid_fg _)).trans\n    (Subgroup.fg_iff_submonoid_fg _).symm\n\n"}
{"name":"GroupFG.iff_add_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : Group G\n⊢ Iff (Group.FG G) (AddGroup.FG (Additive G))","decl":"theorem GroupFG.iff_add_fg : Group.FG G ↔ AddGroup.FG (Additive G) :=\n  ⟨fun h => ⟨(Subgroup.fg_iff_add_fg ⊤).1 h.out⟩, fun h => ⟨(Subgroup.fg_iff_add_fg ⊤).2 h.out⟩⟩\n\n"}
{"name":"AddGroup.fg_iff_mul_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"H : Type u_4\ninst✝ : AddGroup H\n⊢ Iff (AddGroup.FG H) (Group.FG (Multiplicative H))","decl":"theorem AddGroup.fg_iff_mul_fg : AddGroup.FG H ↔ Group.FG (Multiplicative H) :=\n  ⟨fun h => ⟨(AddSubgroup.fg_iff_mul_fg ⊤).1 h.out⟩, fun h =>\n    ⟨(AddSubgroup.fg_iff_mul_fg ⊤).2 h.out⟩⟩\n\n"}
{"name":"AddGroup.fg_of_group_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝¹ : Group G\ninst✝ : Group.FG G\n⊢ AddGroup.FG (Additive G)","decl":"instance AddGroup.fg_of_group_fg [Group.FG G] : AddGroup.FG (Additive G) :=\n  GroupFG.iff_add_fg.1 ‹_›\n\n"}
{"name":"Group.fg_of_mul_group_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"H : Type u_4\ninst✝¹ : AddGroup H\ninst✝ : AddGroup.FG H\n⊢ Group.FG (Multiplicative H)","decl":"instance Group.fg_of_mul_group_fg [AddGroup.FG H] : Group.FG (Multiplicative H) :=\n  AddGroup.fg_iff_mul_fg.1 ‹_›\n\n"}
{"name":"AddGroup.fg_of_finite","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝¹ : AddGroup G\ninst✝ : Finite G\n⊢ AddGroup.FG G","decl":"@[to_additive]\ninstance (priority := 100) Group.fg_of_finite [Finite G] : Group.FG G := by\n  cases nonempty_fintype G\n  exact ⟨⟨Finset.univ, by rw [Finset.coe_univ]; exact Subgroup.closure_univ⟩⟩\n\n"}
{"name":"Group.fg_of_finite","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝¹ : Group G\ninst✝ : Finite G\n⊢ Group.FG G","decl":"@[to_additive]\ninstance (priority := 100) Group.fg_of_finite [Finite G] : Group.FG G := by\n  cases nonempty_fintype G\n  exact ⟨⟨Finset.univ, by rw [Finset.coe_univ]; exact Subgroup.closure_univ⟩⟩\n\n"}
{"name":"Group.fg_of_surjective","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝¹ : Group G\nG' : Type u_5\ninst✝ : Group G'\nhG : Group.FG G\nf : MonoidHom G G'\nhf : Function.Surjective ⇑f\n⊢ Group.FG G'","decl":"@[to_additive]\ntheorem Group.fg_of_surjective {G' : Type*} [Group G'] [hG : Group.FG G] {f : G →* G'}\n    (hf : Function.Surjective f) : Group.FG G' :=\n  Group.fg_iff_monoid_fg.mpr <|\n    @Monoid.fg_of_surjective G _ G' _ (Group.fg_iff_monoid_fg.mp hG) f hf\n\n"}
{"name":"AddGroup.fg_of_surjective","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝¹ : AddGroup G\nG' : Type u_5\ninst✝ : AddGroup G'\nhG : AddGroup.FG G\nf : AddMonoidHom G G'\nhf : Function.Surjective ⇑f\n⊢ AddGroup.FG G'","decl":"@[to_additive]\ntheorem Group.fg_of_surjective {G' : Type*} [Group G'] [hG : Group.FG G] {f : G →* G'}\n    (hf : Function.Surjective f) : Group.FG G' :=\n  Group.fg_iff_monoid_fg.mpr <|\n    @Monoid.fg_of_surjective G _ G' _ (Group.fg_iff_monoid_fg.mp hG) f hf\n\n"}
{"name":"Group.fg_range","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝² : Group G\nG' : Type u_5\ninst✝¹ : Group G'\ninst✝ : Group.FG G\nf : MonoidHom G G'\n⊢ Group.FG (Subtype fun x => Membership.mem f.range x)","decl":"@[to_additive]\ninstance Group.fg_range {G' : Type*} [Group G'] [Group.FG G] (f : G →* G') : Group.FG f.range :=\n  Group.fg_of_surjective f.rangeRestrict_surjective\n\n"}
{"name":"AddGroup.fg_range","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝² : AddGroup G\nG' : Type u_5\ninst✝¹ : AddGroup G'\ninst✝ : AddGroup.FG G\nf : AddMonoidHom G G'\n⊢ AddGroup.FG (Subtype fun x => Membership.mem f.range x)","decl":"@[to_additive]\ninstance Group.fg_range {G' : Type*} [Group G'] [Group.FG G] (f : G →* G') : Group.FG f.range :=\n  Group.fg_of_surjective f.rangeRestrict_surjective\n\n"}
{"name":"AddGroup.closure_finset_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\ns : Finset G\n⊢ AddGroup.FG (Subtype fun x => Membership.mem (AddSubgroup.closure ↑s) x)","decl":"@[to_additive]\ninstance Group.closure_finset_fg (s : Finset G) : Group.FG (Subgroup.closure (s : Set G)) := by\n  refine ⟨⟨s.preimage Subtype.val Subtype.coe_injective.injOn, ?_⟩⟩\n  rw [Finset.coe_preimage, ← Subgroup.coeSubtype, Subgroup.closure_preimage_eq_top]\n\n"}
{"name":"Group.closure_finset_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : Group G\ns : Finset G\n⊢ Group.FG (Subtype fun x => Membership.mem (Subgroup.closure ↑s) x)","decl":"@[to_additive]\ninstance Group.closure_finset_fg (s : Finset G) : Group.FG (Subgroup.closure (s : Set G)) := by\n  refine ⟨⟨s.preimage Subtype.val Subtype.coe_injective.injOn, ?_⟩⟩\n  rw [Finset.coe_preimage, ← Subgroup.coeSubtype, Subgroup.closure_preimage_eq_top]\n\n"}
{"name":"Group.closure_finite_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝¹ : Group G\ns : Set G\ninst✝ : Finite ↑s\n⊢ Group.FG (Subtype fun x => Membership.mem (Subgroup.closure s) x)","decl":"@[to_additive]\ninstance Group.closure_finite_fg (s : Set G) [Finite s] : Group.FG (Subgroup.closure s) :=\n  haveI := Fintype.ofFinite s\n  s.coe_toFinset ▸ Group.closure_finset_fg s.toFinset\n\n"}
{"name":"AddGroup.closure_finite_fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝¹ : AddGroup G\ns : Set G\ninst✝ : Finite ↑s\n⊢ AddGroup.FG (Subtype fun x => Membership.mem (AddSubgroup.closure s) x)","decl":"@[to_additive]\ninstance Group.closure_finite_fg (s : Set G) [Finite s] : Group.FG (Subgroup.closure s) :=\n  haveI := Fintype.ofFinite s\n  s.coe_toFinset ▸ Group.closure_finset_fg s.toFinset\n\n"}
{"name":"Group.rank_spec","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : Group G\nh : Group.FG G\n⊢ Exists fun S => And (Eq S.card (Group.rank G)) (Eq (Subgroup.closure ↑S) Top.top)","decl":"@[to_additive]\ntheorem Group.rank_spec [h : Group.FG G] :\n    ∃ S : Finset G, S.card = Group.rank G ∧ Subgroup.closure (S : Set G) = ⊤ :=\n  @Nat.find_spec _ (Classical.decPred _) (Group.fg_iff'.mp h)\n\n"}
{"name":"AddGroup.rank_spec","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\nh : AddGroup.FG G\n⊢ Exists fun S => And (Eq S.card (AddGroup.rank G)) (Eq (AddSubgroup.closure ↑S) Top.top)","decl":"@[to_additive]\ntheorem Group.rank_spec [h : Group.FG G] :\n    ∃ S : Finset G, S.card = Group.rank G ∧ Subgroup.closure (S : Set G) = ⊤ :=\n  @Nat.find_spec _ (Classical.decPred _) (Group.fg_iff'.mp h)\n\n"}
{"name":"AddGroup.rank_le","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\nh : AddGroup.FG G\nS : Finset G\nhS : Eq (AddSubgroup.closure ↑S) Top.top\n⊢ LE.le (AddGroup.rank G) S.card","decl":"@[to_additive]\ntheorem Group.rank_le [h : Group.FG G] {S : Finset G} (hS : Subgroup.closure (S : Set G) = ⊤) :\n    Group.rank G ≤ S.card :=\n  @Nat.find_le _ _ (Classical.decPred _) (Group.fg_iff'.mp h) ⟨S, rfl, hS⟩\n\n"}
{"name":"Group.rank_le","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : Group G\nh : Group.FG G\nS : Finset G\nhS : Eq (Subgroup.closure ↑S) Top.top\n⊢ LE.le (Group.rank G) S.card","decl":"@[to_additive]\ntheorem Group.rank_le [h : Group.FG G] {S : Finset G} (hS : Subgroup.closure (S : Set G) = ⊤) :\n    Group.rank G ≤ S.card :=\n  @Nat.find_le _ _ (Classical.decPred _) (Group.fg_iff'.mp h) ⟨S, rfl, hS⟩\n\n"}
{"name":"Group.rank_le_of_surjective","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝³ : Group G\nG' : Type u_5\ninst✝² : Group G'\ninst✝¹ : Group.FG G\ninst✝ : Group.FG G'\nf : MonoidHom G G'\nhf : Function.Surjective ⇑f\n⊢ LE.le (Group.rank G') (Group.rank G)","decl":"@[to_additive]\ntheorem Group.rank_le_of_surjective [Group.FG G] [Group.FG G'] (f : G →* G')\n    (hf : Function.Surjective f) : Group.rank G' ≤ Group.rank G := by\n  classical\n    obtain ⟨S, hS1, hS2⟩ := Group.rank_spec G\n    trans (S.image f).card\n    · apply Group.rank_le\n      rw [Finset.coe_image, ← MonoidHom.map_closure, hS2, Subgroup.map_top_of_surjective f hf]\n    · exact Finset.card_image_le.trans_eq hS1\n\n"}
{"name":"AddGroup.rank_le_of_surjective","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝³ : AddGroup G\nG' : Type u_5\ninst✝² : AddGroup G'\ninst✝¹ : AddGroup.FG G\ninst✝ : AddGroup.FG G'\nf : AddMonoidHom G G'\nhf : Function.Surjective ⇑f\n⊢ LE.le (AddGroup.rank G') (AddGroup.rank G)","decl":"@[to_additive]\ntheorem Group.rank_le_of_surjective [Group.FG G] [Group.FG G'] (f : G →* G')\n    (hf : Function.Surjective f) : Group.rank G' ≤ Group.rank G := by\n  classical\n    obtain ⟨S, hS1, hS2⟩ := Group.rank_spec G\n    trans (S.image f).card\n    · apply Group.rank_le\n      rw [Finset.coe_image, ← MonoidHom.map_closure, hS2, Subgroup.map_top_of_surjective f hf]\n    · exact Finset.card_image_le.trans_eq hS1\n\n"}
{"name":"Group.rank_range_le","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝² : Group G\nG' : Type u_5\ninst✝¹ : Group G'\ninst✝ : Group.FG G\nf : MonoidHom G G'\n⊢ LE.le (Group.rank (Subtype fun x => Membership.mem f.range x)) (Group.rank G)","decl":"@[to_additive]\ntheorem Group.rank_range_le [Group.FG G] {f : G →* G'} : Group.rank f.range ≤ Group.rank G :=\n  Group.rank_le_of_surjective f.rangeRestrict f.rangeRestrict_surjective\n\n"}
{"name":"AddGroup.rank_range_le","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝² : AddGroup G\nG' : Type u_5\ninst✝¹ : AddGroup G'\ninst✝ : AddGroup.FG G\nf : AddMonoidHom G G'\n⊢ LE.le (AddGroup.rank (Subtype fun x => Membership.mem f.range x)) (AddGroup.rank G)","decl":"@[to_additive]\ntheorem Group.rank_range_le [Group.FG G] {f : G →* G'} : Group.rank f.range ≤ Group.rank G :=\n  Group.rank_le_of_surjective f.rangeRestrict f.rangeRestrict_surjective\n\n"}
{"name":"Group.rank_congr","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝³ : Group G\nG' : Type u_5\ninst✝² : Group G'\ninst✝¹ : Group.FG G\ninst✝ : Group.FG G'\nf : MulEquiv G G'\n⊢ Eq (Group.rank G) (Group.rank G')","decl":"@[to_additive]\ntheorem Group.rank_congr [Group.FG G] [Group.FG G'] (f : G ≃* G') : Group.rank G = Group.rank G' :=\n  le_antisymm (Group.rank_le_of_surjective f.symm f.symm.surjective)\n    (Group.rank_le_of_surjective f f.surjective)\n\n"}
{"name":"AddGroup.rank_congr","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝³ : AddGroup G\nG' : Type u_5\ninst✝² : AddGroup G'\ninst✝¹ : AddGroup.FG G\ninst✝ : AddGroup.FG G'\nf : AddEquiv G G'\n⊢ Eq (AddGroup.rank G) (AddGroup.rank G')","decl":"@[to_additive]\ntheorem Group.rank_congr [Group.FG G] [Group.FG G'] (f : G ≃* G') : Group.rank G = Group.rank G' :=\n  le_antisymm (Group.rank_le_of_surjective f.symm f.symm.surjective)\n    (Group.rank_le_of_surjective f f.surjective)\n\n"}
{"name":"AddSubgroup.rank_congr","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝² : AddGroup G\nH K : AddSubgroup G\ninst✝¹ : AddGroup.FG (Subtype fun x => Membership.mem H x)\ninst✝ : AddGroup.FG (Subtype fun x => Membership.mem K x)\nh : Eq H K\n⊢ Eq (AddGroup.rank (Subtype fun x => Membership.mem H x)) (AddGroup.rank (Subtype fun x => Membership.mem K x))","decl":"@[to_additive]\ntheorem rank_congr {H K : Subgroup G} [Group.FG H] [Group.FG K] (h : H = K) :\n    Group.rank H = Group.rank K := by subst h; rfl\n\n"}
{"name":"Subgroup.rank_congr","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝² : Group G\nH K : Subgroup G\ninst✝¹ : Group.FG (Subtype fun x => Membership.mem H x)\ninst✝ : Group.FG (Subtype fun x => Membership.mem K x)\nh : Eq H K\n⊢ Eq (Group.rank (Subtype fun x => Membership.mem H x)) (Group.rank (Subtype fun x => Membership.mem K x))","decl":"@[to_additive]\ntheorem rank_congr {H K : Subgroup G} [Group.FG H] [Group.FG K] (h : H = K) :\n    Group.rank H = Group.rank K := by subst h; rfl\n\n"}
{"name":"AddSubgroup.rank_closure_finset_le_card","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\ns : Finset G\n⊢ LE.le (AddGroup.rank (Subtype fun x => Membership.mem (AddSubgroup.closure ↑s) x)) s.card","decl":"@[to_additive]\ntheorem rank_closure_finset_le_card (s : Finset G) : Group.rank (closure (s : Set G)) ≤ s.card := by\n  classical\n  let t : Finset (closure (s : Set G)) := s.preimage Subtype.val Subtype.coe_injective.injOn\n  have ht : closure (t : Set (closure (s : Set G))) = ⊤ := by\n    rw [Finset.coe_preimage]\n    exact closure_preimage_eq_top (s : Set G)\n  apply (Group.rank_le (closure (s : Set G)) ht).trans\n  suffices H : Set.InjOn Subtype.val (t : Set (closure (s : Set G))) by\n    rw [← Finset.card_image_of_injOn H, Finset.image_preimage]\n    apply Finset.card_filter_le\n  apply Subtype.coe_injective.injOn\n\n"}
{"name":"Subgroup.rank_closure_finset_le_card","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : Group G\ns : Finset G\n⊢ LE.le (Group.rank (Subtype fun x => Membership.mem (Subgroup.closure ↑s) x)) s.card","decl":"@[to_additive]\ntheorem rank_closure_finset_le_card (s : Finset G) : Group.rank (closure (s : Set G)) ≤ s.card := by\n  classical\n  let t : Finset (closure (s : Set G)) := s.preimage Subtype.val Subtype.coe_injective.injOn\n  have ht : closure (t : Set (closure (s : Set G))) = ⊤ := by\n    rw [Finset.coe_preimage]\n    exact closure_preimage_eq_top (s : Set G)\n  apply (Group.rank_le (closure (s : Set G)) ht).trans\n  suffices H : Set.InjOn Subtype.val (t : Set (closure (s : Set G))) by\n    rw [← Finset.card_image_of_injOn H, Finset.image_preimage]\n    apply Finset.card_filter_le\n  apply Subtype.coe_injective.injOn\n\n"}
{"name":"AddSubgroup.rank_closure_finite_le_nat_card","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝¹ : AddGroup G\ns : Set G\ninst✝ : Finite ↑s\n⊢ LE.le (AddGroup.rank (Subtype fun x => Membership.mem (AddSubgroup.closure s) x)) (Nat.card ↑s)","decl":"@[to_additive]\ntheorem rank_closure_finite_le_nat_card (s : Set G) [Finite s] :\n    Group.rank (closure s) ≤ Nat.card s := by\n  haveI := Fintype.ofFinite s\n  rw [Nat.card_eq_fintype_card, ← s.toFinset_card, ← rank_congr (congr_arg _ s.coe_toFinset)]\n  exact rank_closure_finset_le_card s.toFinset\n\n"}
{"name":"Subgroup.rank_closure_finite_le_nat_card","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝¹ : Group G\ns : Set G\ninst✝ : Finite ↑s\n⊢ LE.le (Group.rank (Subtype fun x => Membership.mem (Subgroup.closure s) x)) (Nat.card ↑s)","decl":"@[to_additive]\ntheorem rank_closure_finite_le_nat_card (s : Set G) [Finite s] :\n    Group.rank (closure s) ≤ Nat.card s := by\n  haveI := Fintype.ofFinite s\n  rw [Nat.card_eq_fintype_card, ← s.toFinset_card, ← rank_congr (congr_arg _ s.coe_toFinset)]\n  exact rank_closure_finset_le_card s.toFinset\n\n"}
{"name":"Subgroup.nat_card_centralizer_nat_card_stabilizer","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝ : Group G\ng : G\n⊢ Eq (Nat.card (Subtype fun x => Membership.mem (Subgroup.centralizer (Singleton.singleton g)) x)) (Nat.card (Subtype fun x => Membership.mem (MulAction.stabilizer (ConjAct G) g) x))","decl":"theorem nat_card_centralizer_nat_card_stabilizer (g : G) :\n    Nat.card (Subgroup.centralizer {g}) =\n      Nat.card (MulAction.stabilizer (ConjAct G) g) := by\n  rw [Subgroup.centralizer_eq_comap_stabilizer]\n  rfl\n\n"}
{"name":"QuotientAddGroup.fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝² : AddGroup G\ninst✝¹ : AddGroup.FG G\nN : AddSubgroup G\ninst✝ : N.Normal\n⊢ AddGroup.FG (HasQuotient.Quotient G N)","decl":"@[to_additive]\ninstance QuotientGroup.fg [Group.FG G] (N : Subgroup G) [Subgroup.Normal N] : Group.FG <| G ⧸ N :=\n  Group.fg_of_surjective <| QuotientGroup.mk'_surjective N\n\n"}
{"name":"QuotientGroup.fg","module":"Mathlib.GroupTheory.Finiteness","initialProofState":"G : Type u_3\ninst✝² : Group G\ninst✝¹ : Group.FG G\nN : Subgroup G\ninst✝ : N.Normal\n⊢ Group.FG (HasQuotient.Quotient G N)","decl":"@[to_additive]\ninstance QuotientGroup.fg [Group.FG G] (N : Subgroup G) [Subgroup.Normal N] : Group.FG <| G ⧸ N :=\n  Group.fg_of_surjective <| QuotientGroup.mk'_surjective N\n\n"}
