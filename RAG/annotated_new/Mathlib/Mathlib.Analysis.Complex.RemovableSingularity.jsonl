{"name":"Complex.analyticAt_of_differentiable_on_punctured_nhds_of_continuousAt","module":"Mathlib.Analysis.Complex.RemovableSingularity","initialProofState":"E : Type u\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Complex E\ninstâœ : CompleteSpace E\nf : Complex â†’ E\nc : Complex\nhd : Filter.Eventually (fun z => DifferentiableAt Complex f z) (nhdsWithin c (HasCompl.compl (Singleton.singleton c)))\nhc : ContinuousAt f c\nâŠ¢ AnalyticAt Complex f c","decl":"/-- **Removable singularity** theorem, weak version. If `f : â„‚ â†’ E` is differentiable in a punctured\nneighborhood of a point and is continuous at this point, then it is analytic at this point. -/\ntheorem analyticAt_of_differentiable_on_punctured_nhds_of_continuousAt {f : â„‚ â†’ E} {c : â„‚}\n    (hd : âˆ€á¶  z in ğ“[â‰ ] c, DifferentiableAt â„‚ f z) (hc : ContinuousAt f c) : AnalyticAt â„‚ f c := by\n  rcases (nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1 hd with âŸ¨R, hR0, hRsâŸ©\n  lift R to â„â‰¥0 using hR0.le\n  replace hc : ContinuousOn f (closedBall c R) := by\n    refine fun z hz => ContinuousAt.continuousWithinAt ?_\n    rcases eq_or_ne z c with (rfl | hne)\n    exacts [hc, (hRs âŸ¨hz, hneâŸ©).continuousAt]\n  exact (hasFPowerSeriesOnBall_of_differentiable_off_countable (countable_singleton c) hc\n    (fun z hz => hRs (diff_subset_diff_left ball_subset_closedBall hz)) hR0).analyticAt\n\n"}
{"name":"Complex.differentiableOn_compl_singleton_and_continuousAt_iff","module":"Mathlib.Analysis.Complex.RemovableSingularity","initialProofState":"E : Type u\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Complex E\ninstâœ : CompleteSpace E\nf : Complex â†’ E\ns : Set Complex\nc : Complex\nhs : Membership.mem (nhds c) s\nâŠ¢ Iff (And (DifferentiableOn Complex f (SDiff.sdiff s (Singleton.singleton c))) (ContinuousAt f c)) (DifferentiableOn Complex f s)","decl":"theorem differentiableOn_compl_singleton_and_continuousAt_iff {f : â„‚ â†’ E} {s : Set â„‚} {c : â„‚}\n    (hs : s âˆˆ ğ“ c) :\n    DifferentiableOn â„‚ f (s \\ {c}) âˆ§ ContinuousAt f c â†” DifferentiableOn â„‚ f s := by\n  refine âŸ¨?_, fun hd => âŸ¨hd.mono diff_subset, (hd.differentiableAt hs).continuousAtâŸ©âŸ©\n  rintro âŸ¨hd, hcâŸ© x hx\n  rcases eq_or_ne x c with (rfl | hne)\n  Â· refine (analyticAt_of_differentiable_on_punctured_nhds_of_continuousAt\n      ?_ hc).differentiableAt.differentiableWithinAt\n    refine eventually_nhdsWithin_iff.2 ((eventually_mem_nhds_iff.2 hs).mono fun z hz hzx => ?_)\n    exact hd.differentiableAt (inter_mem hz (isOpen_ne.mem_nhds hzx))\n  Â· simpa only [DifferentiableWithinAt, HasFDerivWithinAt, hne.nhdsWithin_diff_singleton] using\n      hd x âŸ¨hx, hneâŸ©\n\n"}
{"name":"Complex.differentiableOn_dslope","module":"Mathlib.Analysis.Complex.RemovableSingularity","initialProofState":"E : Type u\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Complex E\ninstâœ : CompleteSpace E\nf : Complex â†’ E\ns : Set Complex\nc : Complex\nhc : Membership.mem (nhds c) s\nâŠ¢ Iff (DifferentiableOn Complex (dslope f c) s) (DifferentiableOn Complex f s)","decl":"theorem differentiableOn_dslope {f : â„‚ â†’ E} {s : Set â„‚} {c : â„‚} (hc : s âˆˆ ğ“ c) :\n    DifferentiableOn â„‚ (dslope f c) s â†” DifferentiableOn â„‚ f s :=\n  âŸ¨fun h => h.of_dslope, fun h =>\n    (differentiableOn_compl_singleton_and_continuousAt_iff hc).mp <|\n      âŸ¨Iff.mpr (differentiableOn_dslope_of_nmem fun h => h.2 rfl) (h.mono diff_subset),\n        continuousAt_dslope_same.2 <| h.differentiableAt hcâŸ©âŸ©\n\n"}
{"name":"Complex.differentiableOn_update_limUnder_of_isLittleO","module":"Mathlib.Analysis.Complex.RemovableSingularity","initialProofState":"E : Type u\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Complex E\ninstâœ : CompleteSpace E\nf : Complex â†’ E\ns : Set Complex\nc : Complex\nhc : Membership.mem (nhds c) s\nhd : DifferentiableOn Complex f (SDiff.sdiff s (Singleton.singleton c))\nho : Asymptotics.IsLittleO (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) (fun z => HSub.hSub (f z) (f c)) fun z => Inv.inv (HSub.hSub z c)\nâŠ¢ DifferentiableOn Complex (Function.update f c (limUnder (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) f)) s","decl":"/-- **Removable singularity** theorem: if `s` is a neighborhood of `c : â„‚`, a function `f : â„‚ â†’ E`\nis complex differentiable on `s \\ {c}`, and $f(z) - f(c)=o((z-c)^{-1})$, then `f` redefined to be\nequal to `limUnder (ğ“[â‰ ] c) f` at `c` is complex differentiable on `s`. -/\ntheorem differentiableOn_update_limUnder_of_isLittleO {f : â„‚ â†’ E} {s : Set â„‚} {c : â„‚} (hc : s âˆˆ ğ“ c)\n    (hd : DifferentiableOn â„‚ f (s \\ {c}))\n    (ho : (fun z => f z - f c) =o[ğ“[â‰ ] c] fun z => (z - c)â»Â¹) :\n    DifferentiableOn â„‚ (update f c (limUnder (ğ“[â‰ ] c) f)) s := by\n  set F : â„‚ â†’ E := fun z => (z - c) â€¢ f z\n  suffices DifferentiableOn â„‚ F (s \\ {c}) âˆ§ ContinuousAt F c by\n    rw [differentiableOn_compl_singleton_and_continuousAt_iff hc, â† differentiableOn_dslope hc,\n      dslope_sub_smul] at this\n    have hc : Tendsto f (ğ“[â‰ ] c) (ğ“ (deriv F c)) :=\n      continuousAt_update_same.mp (this.continuousOn.continuousAt hc)\n    rwa [hc.limUnder_eq]\n  refine âŸ¨(differentiableOn_id.sub_const _).smul hd, ?_âŸ©\n  rw [â† continuousWithinAt_compl_self]\n  have H := ho.tendsto_inv_smul_nhds_zero\n  have H' : Tendsto (fun z => (z - c) â€¢ f c) (ğ“[â‰ ] c) (ğ“ (F c)) :=\n    (continuousWithinAt_id.tendsto.sub tendsto_const_nhds).smul tendsto_const_nhds\n  simpa [â† smul_add, ContinuousWithinAt] using H.add H'\n\n"}
{"name":"Complex.differentiableOn_update_limUnder_insert_of_isLittleO","module":"Mathlib.Analysis.Complex.RemovableSingularity","initialProofState":"E : Type u\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Complex E\ninstâœ : CompleteSpace E\nf : Complex â†’ E\ns : Set Complex\nc : Complex\nhc : Membership.mem (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) s\nhd : DifferentiableOn Complex f s\nho : Asymptotics.IsLittleO (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) (fun z => HSub.hSub (f z) (f c)) fun z => Inv.inv (HSub.hSub z c)\nâŠ¢ DifferentiableOn Complex (Function.update f c (limUnder (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) f)) (Insert.insert c s)","decl":"/-- **Removable singularity** theorem: if `s` is a punctured neighborhood of `c : â„‚`, a function\n`f : â„‚ â†’ E` is complex differentiable on `s`, and $f(z) - f(c)=o((z-c)^{-1})$, then `f` redefined to\nbe equal to `limUnder (ğ“[â‰ ] c) f` at `c` is complex differentiable on `{c} âˆª s`. -/\ntheorem differentiableOn_update_limUnder_insert_of_isLittleO {f : â„‚ â†’ E} {s : Set â„‚} {c : â„‚}\n    (hc : s âˆˆ ğ“[â‰ ] c) (hd : DifferentiableOn â„‚ f s)\n    (ho : (fun z => f z - f c) =o[ğ“[â‰ ] c] fun z => (z - c)â»Â¹) :\n    DifferentiableOn â„‚ (update f c (limUnder (ğ“[â‰ ] c) f)) (insert c s) :=\n  differentiableOn_update_limUnder_of_isLittleO (insert_mem_nhds_iff.2 hc)\n    (hd.mono fun _ hz => hz.1.resolve_left hz.2) ho\n\n"}
{"name":"Complex.differentiableOn_update_limUnder_of_bddAbove","module":"Mathlib.Analysis.Complex.RemovableSingularity","initialProofState":"E : Type u\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Complex E\ninstâœ : CompleteSpace E\nf : Complex â†’ E\ns : Set Complex\nc : Complex\nhc : Membership.mem (nhds c) s\nhd : DifferentiableOn Complex f (SDiff.sdiff s (Singleton.singleton c))\nhb : BddAbove (Set.image (Function.comp Norm.norm f) (SDiff.sdiff s (Singleton.singleton c)))\nâŠ¢ DifferentiableOn Complex (Function.update f c (limUnder (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) f)) s","decl":"/-- **Removable singularity** theorem: if `s` is a neighborhood of `c : â„‚`, a function `f : â„‚ â†’ E`\nis complex differentiable and is bounded on `s \\ {c}`, then `f` redefined to be equal to\n`limUnder (ğ“[â‰ ] c) f` at `c` is complex differentiable on `s`. -/\ntheorem differentiableOn_update_limUnder_of_bddAbove {f : â„‚ â†’ E} {s : Set â„‚} {c : â„‚} (hc : s âˆˆ ğ“ c)\n    (hd : DifferentiableOn â„‚ f (s \\ {c})) (hb : BddAbove (norm âˆ˜ f '' (s \\ {c}))) :\n    DifferentiableOn â„‚ (update f c (limUnder (ğ“[â‰ ] c) f)) s :=\n  differentiableOn_update_limUnder_of_isLittleO hc hd <| IsBoundedUnder.isLittleO_sub_self_inv <|\n    let âŸ¨C, hCâŸ© := hb\n    âŸ¨C + â€–f câ€–, eventually_map.2 <| mem_nhdsWithin_iff_exists_mem_nhds_inter.2\n      âŸ¨s, hc, fun _ hz => norm_sub_le_of_le (hC <| mem_image_of_mem _ hz) le_rflâŸ©âŸ©\n\n"}
{"name":"Complex.tendsto_limUnder_of_differentiable_on_punctured_nhds_of_isLittleO","module":"Mathlib.Analysis.Complex.RemovableSingularity","initialProofState":"E : Type u\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Complex E\ninstâœ : CompleteSpace E\nf : Complex â†’ E\nc : Complex\nhd : Filter.Eventually (fun z => DifferentiableAt Complex f z) (nhdsWithin c (HasCompl.compl (Singleton.singleton c)))\nho : Asymptotics.IsLittleO (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) (fun z => HSub.hSub (f z) (f c)) fun z => Inv.inv (HSub.hSub z c)\nâŠ¢ Filter.Tendsto f (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) (nhds (limUnder (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) f))","decl":"/-- **Removable singularity** theorem: if a function `f : â„‚ â†’ E` is complex differentiable on a\npunctured neighborhood of `c` and $f(z) - f(c)=o((z-c)^{-1})$, then `f` has a limit at `c`. -/\ntheorem tendsto_limUnder_of_differentiable_on_punctured_nhds_of_isLittleO {f : â„‚ â†’ E} {c : â„‚}\n    (hd : âˆ€á¶  z in ğ“[â‰ ] c, DifferentiableAt â„‚ f z)\n    (ho : (fun z => f z - f c) =o[ğ“[â‰ ] c] fun z => (z - c)â»Â¹) :\n    Tendsto f (ğ“[â‰ ] c) (ğ“ <| limUnder (ğ“[â‰ ] c) f) := by\n  rw [eventually_nhdsWithin_iff] at hd\n  have : DifferentiableOn â„‚ f ({z | z â‰  c â†’ DifferentiableAt â„‚ f z} \\ {c}) := fun z hz =>\n    (hz.1 hz.2).differentiableWithinAt\n  have H := differentiableOn_update_limUnder_of_isLittleO hd this ho\n  exact continuousAt_update_same.1 (H.differentiableAt hd).continuousAt\n\n"}
{"name":"Complex.tendsto_limUnder_of_differentiable_on_punctured_nhds_of_bounded_under","module":"Mathlib.Analysis.Complex.RemovableSingularity","initialProofState":"E : Type u\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Complex E\ninstâœ : CompleteSpace E\nf : Complex â†’ E\nc : Complex\nhd : Filter.Eventually (fun z => DifferentiableAt Complex f z) (nhdsWithin c (HasCompl.compl (Singleton.singleton c)))\nhb : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) fun z => Norm.norm (HSub.hSub (f z) (f c))\nâŠ¢ Filter.Tendsto f (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) (nhds (limUnder (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) f))","decl":"/-- **Removable singularity** theorem: if a function `f : â„‚ â†’ E` is complex differentiable and\nbounded on a punctured neighborhood of `c`, then `f` has a limit at `c`. -/\ntheorem tendsto_limUnder_of_differentiable_on_punctured_nhds_of_bounded_under {f : â„‚ â†’ E} {c : â„‚}\n    (hd : âˆ€á¶  z in ğ“[â‰ ] c, DifferentiableAt â„‚ f z)\n    (hb : IsBoundedUnder (Â· â‰¤ Â·) (ğ“[â‰ ] c) fun z => â€–f z - f câ€–) :\n    Tendsto f (ğ“[â‰ ] c) (ğ“ <| limUnder (ğ“[â‰ ] c) f) :=\n  tendsto_limUnder_of_differentiable_on_punctured_nhds_of_isLittleO hd hb.isLittleO_sub_self_inv\n\n"}
{"name":"Complex.two_pi_I_inv_smul_circleIntegral_sub_sq_inv_smul_of_differentiable","module":"Mathlib.Analysis.Complex.RemovableSingularity","initialProofState":"E : Type u\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Complex E\ninstâœ : CompleteSpace E\nU : Set Complex\nhU : IsOpen U\nc wâ‚€ : Complex\nR : Real\nf : Complex â†’ E\nhc : HasSubset.Subset (Metric.closedBall c R) U\nhf : DifferentiableOn Complex f U\nhwâ‚€ : Membership.mem (Metric.ball c R) wâ‚€\nâŠ¢ Eq (HSMul.hSMul (Inv.inv (HMul.hMul (HMul.hMul 2 â†‘Real.pi) Complex.I)) (circleIntegral (fun z => HSMul.hSMul (Inv.inv (HPow.hPow (HSub.hSub z wâ‚€) 2)) (f z)) c R)) (deriv f wâ‚€)","decl":"/-- The Cauchy formula for the derivative of a holomorphic function. -/\ntheorem two_pi_I_inv_smul_circleIntegral_sub_sq_inv_smul_of_differentiable {U : Set â„‚}\n    (hU : IsOpen U) {c wâ‚€ : â„‚} {R : â„} {f : â„‚ â†’ E} (hc : closedBall c R âŠ† U)\n    (hf : DifferentiableOn â„‚ f U) (hwâ‚€ : wâ‚€ âˆˆ ball c R) :\n    ((2 * Ï€ * I : â„‚)â»Â¹ â€¢ âˆ® z in C(c, R), ((z - wâ‚€) ^ 2)â»Â¹ â€¢ f z) = deriv f wâ‚€ := by\n  -- We apply the removable singularity theorem and the Cauchy formula to `dslope f wâ‚€`\n  have hf' : DifferentiableOn â„‚ (dslope f wâ‚€) U :=\n    (differentiableOn_dslope (hU.mem_nhds ((ball_subset_closedBall.trans hc) hwâ‚€))).mpr hf\n  have h0 := (hf'.diffContOnCl_ball hc).two_pi_i_inv_smul_circleIntegral_sub_inv_smul hwâ‚€\n  rw [â† dslope_same, â† h0]\n  congr 1\n  trans âˆ® z in C(c, R), ((z - wâ‚€) ^ 2)â»Â¹ â€¢ (f z - f wâ‚€)\n  Â· have h1 : ContinuousOn (fun z : â„‚ => ((z - wâ‚€) ^ 2)â»Â¹) (sphere c R) := by\n      refine ((continuous_id'.sub continuous_const).pow 2).continuousOn.invâ‚€ fun w hw h => ?_\n      exact sphere_disjoint_ball.ne_of_mem hw hwâ‚€ (sub_eq_zero.mp (sq_eq_zero_iff.mp h))\n    have h2 : CircleIntegrable (fun z : â„‚ => ((z - wâ‚€) ^ 2)â»Â¹ â€¢ f z) c R := by\n      refine ContinuousOn.circleIntegrable (pos_of_mem_ball hwâ‚€).le ?_\n      exact h1.smul (hf.continuousOn.mono (sphere_subset_closedBall.trans hc))\n    have h3 : CircleIntegrable (fun z : â„‚ => ((z - wâ‚€) ^ 2)â»Â¹ â€¢ f wâ‚€) c R :=\n      ContinuousOn.circleIntegrable (pos_of_mem_ball hwâ‚€).le (h1.smul continuousOn_const)\n    have h4 : (âˆ® z : â„‚ in C(c, R), ((z - wâ‚€) ^ 2)â»Â¹) = 0 := by\n      simpa using circleIntegral.integral_sub_zpow_of_ne (by decide : (-2 : â„¤) â‰  -1) c wâ‚€ R\n    simp only [smul_sub, circleIntegral.integral_sub h2 h3, h4, circleIntegral.integral_smul_const,\n      zero_smul, sub_zero]\n  Â· refine circleIntegral.integral_congr (pos_of_mem_ball hwâ‚€).le fun z hz => ?_\n    simp only [dslope_of_ne, Metric.sphere_disjoint_ball.ne_of_mem hz hwâ‚€, slope, â† smul_assoc, sq,\n      mul_inv, Ne, not_false_iff, vsub_eq_sub, Algebra.id.smul_eq_mul]\n\n"}
