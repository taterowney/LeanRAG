{"name":"Complex.analyticAt_of_differentiable_on_punctured_nhds_of_continuousAt","module":"Mathlib.Analysis.Complex.RemovableSingularity","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf : Complex → E\nc : Complex\nhd : Filter.Eventually (fun z => DifferentiableAt Complex f z) (nhdsWithin c (HasCompl.compl (Singleton.singleton c)))\nhc : ContinuousAt f c\n⊢ AnalyticAt Complex f c","decl":"/-- **Removable singularity** theorem, weak version. If `f : ℂ → E` is differentiable in a punctured\nneighborhood of a point and is continuous at this point, then it is analytic at this point. -/\ntheorem analyticAt_of_differentiable_on_punctured_nhds_of_continuousAt {f : ℂ → E} {c : ℂ}\n    (hd : ∀ᶠ z in 𝓝[≠] c, DifferentiableAt ℂ f z) (hc : ContinuousAt f c) : AnalyticAt ℂ f c := by\n  rcases (nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1 hd with ⟨R, hR0, hRs⟩\n  lift R to ℝ≥0 using hR0.le\n  replace hc : ContinuousOn f (closedBall c R) := by\n    refine fun z hz => ContinuousAt.continuousWithinAt ?_\n    rcases eq_or_ne z c with (rfl | hne)\n    exacts [hc, (hRs ⟨hz, hne⟩).continuousAt]\n  exact (hasFPowerSeriesOnBall_of_differentiable_off_countable (countable_singleton c) hc\n    (fun z hz => hRs (diff_subset_diff_left ball_subset_closedBall hz)) hR0).analyticAt\n\n"}
{"name":"Complex.differentiableOn_compl_singleton_and_continuousAt_iff","module":"Mathlib.Analysis.Complex.RemovableSingularity","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf : Complex → E\ns : Set Complex\nc : Complex\nhs : Membership.mem (nhds c) s\n⊢ Iff (And (DifferentiableOn Complex f (SDiff.sdiff s (Singleton.singleton c))) (ContinuousAt f c)) (DifferentiableOn Complex f s)","decl":"theorem differentiableOn_compl_singleton_and_continuousAt_iff {f : ℂ → E} {s : Set ℂ} {c : ℂ}\n    (hs : s ∈ 𝓝 c) :\n    DifferentiableOn ℂ f (s \\ {c}) ∧ ContinuousAt f c ↔ DifferentiableOn ℂ f s := by\n  refine ⟨?_, fun hd => ⟨hd.mono diff_subset, (hd.differentiableAt hs).continuousAt⟩⟩\n  rintro ⟨hd, hc⟩ x hx\n  rcases eq_or_ne x c with (rfl | hne)\n  · refine (analyticAt_of_differentiable_on_punctured_nhds_of_continuousAt\n      ?_ hc).differentiableAt.differentiableWithinAt\n    refine eventually_nhdsWithin_iff.2 ((eventually_mem_nhds_iff.2 hs).mono fun z hz hzx => ?_)\n    exact hd.differentiableAt (inter_mem hz (isOpen_ne.mem_nhds hzx))\n  · simpa only [DifferentiableWithinAt, HasFDerivWithinAt, hne.nhdsWithin_diff_singleton] using\n      hd x ⟨hx, hne⟩\n\n"}
{"name":"Complex.differentiableOn_dslope","module":"Mathlib.Analysis.Complex.RemovableSingularity","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf : Complex → E\ns : Set Complex\nc : Complex\nhc : Membership.mem (nhds c) s\n⊢ Iff (DifferentiableOn Complex (dslope f c) s) (DifferentiableOn Complex f s)","decl":"theorem differentiableOn_dslope {f : ℂ → E} {s : Set ℂ} {c : ℂ} (hc : s ∈ 𝓝 c) :\n    DifferentiableOn ℂ (dslope f c) s ↔ DifferentiableOn ℂ f s :=\n  ⟨fun h => h.of_dslope, fun h =>\n    (differentiableOn_compl_singleton_and_continuousAt_iff hc).mp <|\n      ⟨Iff.mpr (differentiableOn_dslope_of_nmem fun h => h.2 rfl) (h.mono diff_subset),\n        continuousAt_dslope_same.2 <| h.differentiableAt hc⟩⟩\n\n"}
{"name":"Complex.differentiableOn_update_limUnder_of_isLittleO","module":"Mathlib.Analysis.Complex.RemovableSingularity","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf : Complex → E\ns : Set Complex\nc : Complex\nhc : Membership.mem (nhds c) s\nhd : DifferentiableOn Complex f (SDiff.sdiff s (Singleton.singleton c))\nho : Asymptotics.IsLittleO (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) (fun z => HSub.hSub (f z) (f c)) fun z => Inv.inv (HSub.hSub z c)\n⊢ DifferentiableOn Complex (Function.update f c (limUnder (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) f)) s","decl":"/-- **Removable singularity** theorem: if `s` is a neighborhood of `c : ℂ`, a function `f : ℂ → E`\nis complex differentiable on `s \\ {c}`, and $f(z) - f(c)=o((z-c)^{-1})$, then `f` redefined to be\nequal to `limUnder (𝓝[≠] c) f` at `c` is complex differentiable on `s`. -/\ntheorem differentiableOn_update_limUnder_of_isLittleO {f : ℂ → E} {s : Set ℂ} {c : ℂ} (hc : s ∈ 𝓝 c)\n    (hd : DifferentiableOn ℂ f (s \\ {c}))\n    (ho : (fun z => f z - f c) =o[𝓝[≠] c] fun z => (z - c)⁻¹) :\n    DifferentiableOn ℂ (update f c (limUnder (𝓝[≠] c) f)) s := by\n  set F : ℂ → E := fun z => (z - c) • f z\n  suffices DifferentiableOn ℂ F (s \\ {c}) ∧ ContinuousAt F c by\n    rw [differentiableOn_compl_singleton_and_continuousAt_iff hc, ← differentiableOn_dslope hc,\n      dslope_sub_smul] at this\n    have hc : Tendsto f (𝓝[≠] c) (𝓝 (deriv F c)) :=\n      continuousAt_update_same.mp (this.continuousOn.continuousAt hc)\n    rwa [hc.limUnder_eq]\n  refine ⟨(differentiableOn_id.sub_const _).smul hd, ?_⟩\n  rw [← continuousWithinAt_compl_self]\n  have H := ho.tendsto_inv_smul_nhds_zero\n  have H' : Tendsto (fun z => (z - c) • f c) (𝓝[≠] c) (𝓝 (F c)) :=\n    (continuousWithinAt_id.tendsto.sub tendsto_const_nhds).smul tendsto_const_nhds\n  simpa [← smul_add, ContinuousWithinAt] using H.add H'\n\n"}
{"name":"Complex.differentiableOn_update_limUnder_insert_of_isLittleO","module":"Mathlib.Analysis.Complex.RemovableSingularity","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf : Complex → E\ns : Set Complex\nc : Complex\nhc : Membership.mem (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) s\nhd : DifferentiableOn Complex f s\nho : Asymptotics.IsLittleO (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) (fun z => HSub.hSub (f z) (f c)) fun z => Inv.inv (HSub.hSub z c)\n⊢ DifferentiableOn Complex (Function.update f c (limUnder (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) f)) (Insert.insert c s)","decl":"/-- **Removable singularity** theorem: if `s` is a punctured neighborhood of `c : ℂ`, a function\n`f : ℂ → E` is complex differentiable on `s`, and $f(z) - f(c)=o((z-c)^{-1})$, then `f` redefined to\nbe equal to `limUnder (𝓝[≠] c) f` at `c` is complex differentiable on `{c} ∪ s`. -/\ntheorem differentiableOn_update_limUnder_insert_of_isLittleO {f : ℂ → E} {s : Set ℂ} {c : ℂ}\n    (hc : s ∈ 𝓝[≠] c) (hd : DifferentiableOn ℂ f s)\n    (ho : (fun z => f z - f c) =o[𝓝[≠] c] fun z => (z - c)⁻¹) :\n    DifferentiableOn ℂ (update f c (limUnder (𝓝[≠] c) f)) (insert c s) :=\n  differentiableOn_update_limUnder_of_isLittleO (insert_mem_nhds_iff.2 hc)\n    (hd.mono fun _ hz => hz.1.resolve_left hz.2) ho\n\n"}
{"name":"Complex.differentiableOn_update_limUnder_of_bddAbove","module":"Mathlib.Analysis.Complex.RemovableSingularity","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf : Complex → E\ns : Set Complex\nc : Complex\nhc : Membership.mem (nhds c) s\nhd : DifferentiableOn Complex f (SDiff.sdiff s (Singleton.singleton c))\nhb : BddAbove (Set.image (Function.comp Norm.norm f) (SDiff.sdiff s (Singleton.singleton c)))\n⊢ DifferentiableOn Complex (Function.update f c (limUnder (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) f)) s","decl":"/-- **Removable singularity** theorem: if `s` is a neighborhood of `c : ℂ`, a function `f : ℂ → E`\nis complex differentiable and is bounded on `s \\ {c}`, then `f` redefined to be equal to\n`limUnder (𝓝[≠] c) f` at `c` is complex differentiable on `s`. -/\ntheorem differentiableOn_update_limUnder_of_bddAbove {f : ℂ → E} {s : Set ℂ} {c : ℂ} (hc : s ∈ 𝓝 c)\n    (hd : DifferentiableOn ℂ f (s \\ {c})) (hb : BddAbove (norm ∘ f '' (s \\ {c}))) :\n    DifferentiableOn ℂ (update f c (limUnder (𝓝[≠] c) f)) s :=\n  differentiableOn_update_limUnder_of_isLittleO hc hd <| IsBoundedUnder.isLittleO_sub_self_inv <|\n    let ⟨C, hC⟩ := hb\n    ⟨C + ‖f c‖, eventually_map.2 <| mem_nhdsWithin_iff_exists_mem_nhds_inter.2\n      ⟨s, hc, fun _ hz => norm_sub_le_of_le (hC <| mem_image_of_mem _ hz) le_rfl⟩⟩\n\n"}
{"name":"Complex.tendsto_limUnder_of_differentiable_on_punctured_nhds_of_isLittleO","module":"Mathlib.Analysis.Complex.RemovableSingularity","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf : Complex → E\nc : Complex\nhd : Filter.Eventually (fun z => DifferentiableAt Complex f z) (nhdsWithin c (HasCompl.compl (Singleton.singleton c)))\nho : Asymptotics.IsLittleO (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) (fun z => HSub.hSub (f z) (f c)) fun z => Inv.inv (HSub.hSub z c)\n⊢ Filter.Tendsto f (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) (nhds (limUnder (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) f))","decl":"/-- **Removable singularity** theorem: if a function `f : ℂ → E` is complex differentiable on a\npunctured neighborhood of `c` and $f(z) - f(c)=o((z-c)^{-1})$, then `f` has a limit at `c`. -/\ntheorem tendsto_limUnder_of_differentiable_on_punctured_nhds_of_isLittleO {f : ℂ → E} {c : ℂ}\n    (hd : ∀ᶠ z in 𝓝[≠] c, DifferentiableAt ℂ f z)\n    (ho : (fun z => f z - f c) =o[𝓝[≠] c] fun z => (z - c)⁻¹) :\n    Tendsto f (𝓝[≠] c) (𝓝 <| limUnder (𝓝[≠] c) f) := by\n  rw [eventually_nhdsWithin_iff] at hd\n  have : DifferentiableOn ℂ f ({z | z ≠ c → DifferentiableAt ℂ f z} \\ {c}) := fun z hz =>\n    (hz.1 hz.2).differentiableWithinAt\n  have H := differentiableOn_update_limUnder_of_isLittleO hd this ho\n  exact continuousAt_update_same.1 (H.differentiableAt hd).continuousAt\n\n"}
{"name":"Complex.tendsto_limUnder_of_differentiable_on_punctured_nhds_of_bounded_under","module":"Mathlib.Analysis.Complex.RemovableSingularity","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf : Complex → E\nc : Complex\nhd : Filter.Eventually (fun z => DifferentiableAt Complex f z) (nhdsWithin c (HasCompl.compl (Singleton.singleton c)))\nhb : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) fun z => Norm.norm (HSub.hSub (f z) (f c))\n⊢ Filter.Tendsto f (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) (nhds (limUnder (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) f))","decl":"/-- **Removable singularity** theorem: if a function `f : ℂ → E` is complex differentiable and\nbounded on a punctured neighborhood of `c`, then `f` has a limit at `c`. -/\ntheorem tendsto_limUnder_of_differentiable_on_punctured_nhds_of_bounded_under {f : ℂ → E} {c : ℂ}\n    (hd : ∀ᶠ z in 𝓝[≠] c, DifferentiableAt ℂ f z)\n    (hb : IsBoundedUnder (· ≤ ·) (𝓝[≠] c) fun z => ‖f z - f c‖) :\n    Tendsto f (𝓝[≠] c) (𝓝 <| limUnder (𝓝[≠] c) f) :=\n  tendsto_limUnder_of_differentiable_on_punctured_nhds_of_isLittleO hd hb.isLittleO_sub_self_inv\n\n"}
{"name":"Complex.two_pi_I_inv_smul_circleIntegral_sub_sq_inv_smul_of_differentiable","module":"Mathlib.Analysis.Complex.RemovableSingularity","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nU : Set Complex\nhU : IsOpen U\nc w₀ : Complex\nR : Real\nf : Complex → E\nhc : HasSubset.Subset (Metric.closedBall c R) U\nhf : DifferentiableOn Complex f U\nhw₀ : Membership.mem (Metric.ball c R) w₀\n⊢ Eq (HSMul.hSMul (Inv.inv (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I)) (circleIntegral (fun z => HSMul.hSMul (Inv.inv (HPow.hPow (HSub.hSub z w₀) 2)) (f z)) c R)) (deriv f w₀)","decl":"/-- The Cauchy formula for the derivative of a holomorphic function. -/\ntheorem two_pi_I_inv_smul_circleIntegral_sub_sq_inv_smul_of_differentiable {U : Set ℂ}\n    (hU : IsOpen U) {c w₀ : ℂ} {R : ℝ} {f : ℂ → E} (hc : closedBall c R ⊆ U)\n    (hf : DifferentiableOn ℂ f U) (hw₀ : w₀ ∈ ball c R) :\n    ((2 * π * I : ℂ)⁻¹ • ∮ z in C(c, R), ((z - w₀) ^ 2)⁻¹ • f z) = deriv f w₀ := by\n  -- We apply the removable singularity theorem and the Cauchy formula to `dslope f w₀`\n  have hf' : DifferentiableOn ℂ (dslope f w₀) U :=\n    (differentiableOn_dslope (hU.mem_nhds ((ball_subset_closedBall.trans hc) hw₀))).mpr hf\n  have h0 := (hf'.diffContOnCl_ball hc).two_pi_i_inv_smul_circleIntegral_sub_inv_smul hw₀\n  rw [← dslope_same, ← h0]\n  congr 1\n  trans ∮ z in C(c, R), ((z - w₀) ^ 2)⁻¹ • (f z - f w₀)\n  · have h1 : ContinuousOn (fun z : ℂ => ((z - w₀) ^ 2)⁻¹) (sphere c R) := by\n      refine ((continuous_id'.sub continuous_const).pow 2).continuousOn.inv₀ fun w hw h => ?_\n      exact sphere_disjoint_ball.ne_of_mem hw hw₀ (sub_eq_zero.mp (sq_eq_zero_iff.mp h))\n    have h2 : CircleIntegrable (fun z : ℂ => ((z - w₀) ^ 2)⁻¹ • f z) c R := by\n      refine ContinuousOn.circleIntegrable (pos_of_mem_ball hw₀).le ?_\n      exact h1.smul (hf.continuousOn.mono (sphere_subset_closedBall.trans hc))\n    have h3 : CircleIntegrable (fun z : ℂ => ((z - w₀) ^ 2)⁻¹ • f w₀) c R :=\n      ContinuousOn.circleIntegrable (pos_of_mem_ball hw₀).le (h1.smul continuousOn_const)\n    have h4 : (∮ z : ℂ in C(c, R), ((z - w₀) ^ 2)⁻¹) = 0 := by\n      simpa using circleIntegral.integral_sub_zpow_of_ne (by decide : (-2 : ℤ) ≠ -1) c w₀ R\n    simp only [smul_sub, circleIntegral.integral_sub h2 h3, h4, circleIntegral.integral_smul_const,\n      zero_smul, sub_zero]\n  · refine circleIntegral.integral_congr (pos_of_mem_ball hw₀).le fun z hz => ?_\n    simp only [dslope_of_ne, Metric.sphere_disjoint_ball.ne_of_mem hz hw₀, slope, ← smul_assoc, sq,\n      mul_inv, Ne, not_false_iff, vsub_eq_sub, Algebra.id.smul_eq_mul]\n\n"}
