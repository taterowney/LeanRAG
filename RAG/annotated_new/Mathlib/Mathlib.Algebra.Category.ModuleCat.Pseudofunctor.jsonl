{"name":"CommRingCat.moduleCatRestrictScalarsPseudofunctor_obj","module":"Mathlib.Algebra.Category.ModuleCat.Pseudofunctor","initialProofState":"b : CategoryTheory.LocallyDiscrete (Opposite CommRingCat)\n⊢ Eq (CommRingCat.moduleCatRestrictScalarsPseudofunctor.obj b) (CategoryTheory.Cat.of (ModuleCat ↑(Opposite.unop b.as)))","decl":"/-- The pseudofunctor from `LocallyDiscrete CommRingCatᵒᵖ` to `Cat` which sends\na commutative ring `R` to its category of modules. The functoriality is given by\nthe restriction of scalars. -/\n@[simps! obj map mapId mapComp]\nnoncomputable def CommRingCat.moduleCatRestrictScalarsPseudofunctor :\n    Pseudofunctor (LocallyDiscrete CommRingCat.{u}ᵒᵖ) Cat :=\n  LocallyDiscrete.mkPseudofunctor\n    (fun R ↦ Cat.of (ModuleCat.{v} R.unop))\n    (fun f ↦ restrictScalars f.unop.hom)\n    (fun R ↦ restrictScalarsId R.unop)\n    (fun f g ↦ restrictScalarsComp g.unop.hom f.unop.hom)\n\n"}
{"name":"CommRingCat.moduleCatRestrictScalarsPseudofunctor_mapId","module":"Mathlib.Algebra.Category.ModuleCat.Pseudofunctor","initialProofState":"x✝ : CategoryTheory.LocallyDiscrete (Opposite CommRingCat)\n⊢ Eq (CommRingCat.moduleCatRestrictScalarsPseudofunctor.mapId x✝) (ModuleCat.restrictScalarsId ↑(Opposite.unop x✝.as))","decl":"/-- The pseudofunctor from `LocallyDiscrete CommRingCatᵒᵖ` to `Cat` which sends\na commutative ring `R` to its category of modules. The functoriality is given by\nthe restriction of scalars. -/\n@[simps! obj map mapId mapComp]\nnoncomputable def CommRingCat.moduleCatRestrictScalarsPseudofunctor :\n    Pseudofunctor (LocallyDiscrete CommRingCat.{u}ᵒᵖ) Cat :=\n  LocallyDiscrete.mkPseudofunctor\n    (fun R ↦ Cat.of (ModuleCat.{v} R.unop))\n    (fun f ↦ restrictScalars f.unop.hom)\n    (fun R ↦ restrictScalarsId R.unop)\n    (fun f g ↦ restrictScalarsComp g.unop.hom f.unop.hom)\n\n"}
{"name":"CommRingCat.moduleCatRestrictScalarsPseudofunctor_mapComp","module":"Mathlib.Algebra.Category.ModuleCat.Pseudofunctor","initialProofState":"a✝ b✝ c✝ : CategoryTheory.LocallyDiscrete (Opposite CommRingCat)\nx✝¹ : Quiver.Hom a✝ b✝\nx✝ : Quiver.Hom b✝ c✝\n⊢ Eq (CommRingCat.moduleCatRestrictScalarsPseudofunctor.mapComp x✝¹ x✝) (ModuleCat.restrictScalarsComp (CommRingCat.Hom.hom x✝.as.unop) (CommRingCat.Hom.hom x✝¹.as.unop))","decl":"/-- The pseudofunctor from `LocallyDiscrete CommRingCatᵒᵖ` to `Cat` which sends\na commutative ring `R` to its category of modules. The functoriality is given by\nthe restriction of scalars. -/\n@[simps! obj map mapId mapComp]\nnoncomputable def CommRingCat.moduleCatRestrictScalarsPseudofunctor :\n    Pseudofunctor (LocallyDiscrete CommRingCat.{u}ᵒᵖ) Cat :=\n  LocallyDiscrete.mkPseudofunctor\n    (fun R ↦ Cat.of (ModuleCat.{v} R.unop))\n    (fun f ↦ restrictScalars f.unop.hom)\n    (fun R ↦ restrictScalarsId R.unop)\n    (fun f g ↦ restrictScalarsComp g.unop.hom f.unop.hom)\n\n"}
{"name":"CommRingCat.moduleCatRestrictScalarsPseudofunctor_map","module":"Mathlib.Algebra.Category.ModuleCat.Pseudofunctor","initialProofState":"X✝ Y✝ : CategoryTheory.LocallyDiscrete (Opposite CommRingCat)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CommRingCat.moduleCatRestrictScalarsPseudofunctor.map f) (ModuleCat.restrictScalars (CommRingCat.Hom.hom f.as.unop))","decl":"/-- The pseudofunctor from `LocallyDiscrete CommRingCatᵒᵖ` to `Cat` which sends\na commutative ring `R` to its category of modules. The functoriality is given by\nthe restriction of scalars. -/\n@[simps! obj map mapId mapComp]\nnoncomputable def CommRingCat.moduleCatRestrictScalarsPseudofunctor :\n    Pseudofunctor (LocallyDiscrete CommRingCat.{u}ᵒᵖ) Cat :=\n  LocallyDiscrete.mkPseudofunctor\n    (fun R ↦ Cat.of (ModuleCat.{v} R.unop))\n    (fun f ↦ restrictScalars f.unop.hom)\n    (fun R ↦ restrictScalarsId R.unop)\n    (fun f g ↦ restrictScalarsComp g.unop.hom f.unop.hom)\n\n"}
{"name":"RingCat.moduleCatRestrictScalarsPseudofunctor_obj","module":"Mathlib.Algebra.Category.ModuleCat.Pseudofunctor","initialProofState":"b : CategoryTheory.LocallyDiscrete (Opposite RingCat)\n⊢ Eq (RingCat.moduleCatRestrictScalarsPseudofunctor.obj b) (CategoryTheory.Cat.of (ModuleCat ↑(Opposite.unop b.as)))","decl":"/-- The pseudofunctor from `LocallyDiscrete RingCatᵒᵖ` to `Cat` which sends a ring `R`\nto its category of modules. The functoriality is given by the restriction of scalars. -/\n@[simps! obj map mapId mapComp]\nnoncomputable def RingCat.moduleCatRestrictScalarsPseudofunctor :\n    Pseudofunctor (LocallyDiscrete RingCat.{u}ᵒᵖ) Cat :=\n  LocallyDiscrete.mkPseudofunctor\n    (fun R ↦ Cat.of (ModuleCat.{v} R.unop))\n    (fun f ↦ restrictScalars f.unop.hom)\n    (fun R ↦ restrictScalarsId R.unop)\n    (fun f g ↦ restrictScalarsComp g.unop.hom f.unop.hom)\n\n"}
{"name":"RingCat.moduleCatRestrictScalarsPseudofunctor_map","module":"Mathlib.Algebra.Category.ModuleCat.Pseudofunctor","initialProofState":"X✝ Y✝ : CategoryTheory.LocallyDiscrete (Opposite RingCat)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (RingCat.moduleCatRestrictScalarsPseudofunctor.map f) (ModuleCat.restrictScalars (RingCat.Hom.hom f.as.unop))","decl":"/-- The pseudofunctor from `LocallyDiscrete RingCatᵒᵖ` to `Cat` which sends a ring `R`\nto its category of modules. The functoriality is given by the restriction of scalars. -/\n@[simps! obj map mapId mapComp]\nnoncomputable def RingCat.moduleCatRestrictScalarsPseudofunctor :\n    Pseudofunctor (LocallyDiscrete RingCat.{u}ᵒᵖ) Cat :=\n  LocallyDiscrete.mkPseudofunctor\n    (fun R ↦ Cat.of (ModuleCat.{v} R.unop))\n    (fun f ↦ restrictScalars f.unop.hom)\n    (fun R ↦ restrictScalarsId R.unop)\n    (fun f g ↦ restrictScalarsComp g.unop.hom f.unop.hom)\n\n"}
{"name":"RingCat.moduleCatRestrictScalarsPseudofunctor_mapComp","module":"Mathlib.Algebra.Category.ModuleCat.Pseudofunctor","initialProofState":"a✝ b✝ c✝ : CategoryTheory.LocallyDiscrete (Opposite RingCat)\nx✝¹ : Quiver.Hom a✝ b✝\nx✝ : Quiver.Hom b✝ c✝\n⊢ Eq (RingCat.moduleCatRestrictScalarsPseudofunctor.mapComp x✝¹ x✝) (ModuleCat.restrictScalarsComp (RingCat.Hom.hom x✝.as.unop) (RingCat.Hom.hom x✝¹.as.unop))","decl":"/-- The pseudofunctor from `LocallyDiscrete RingCatᵒᵖ` to `Cat` which sends a ring `R`\nto its category of modules. The functoriality is given by the restriction of scalars. -/\n@[simps! obj map mapId mapComp]\nnoncomputable def RingCat.moduleCatRestrictScalarsPseudofunctor :\n    Pseudofunctor (LocallyDiscrete RingCat.{u}ᵒᵖ) Cat :=\n  LocallyDiscrete.mkPseudofunctor\n    (fun R ↦ Cat.of (ModuleCat.{v} R.unop))\n    (fun f ↦ restrictScalars f.unop.hom)\n    (fun R ↦ restrictScalarsId R.unop)\n    (fun f g ↦ restrictScalarsComp g.unop.hom f.unop.hom)\n\n"}
{"name":"RingCat.moduleCatRestrictScalarsPseudofunctor_mapId","module":"Mathlib.Algebra.Category.ModuleCat.Pseudofunctor","initialProofState":"x✝ : CategoryTheory.LocallyDiscrete (Opposite RingCat)\n⊢ Eq (RingCat.moduleCatRestrictScalarsPseudofunctor.mapId x✝) (ModuleCat.restrictScalarsId ↑(Opposite.unop x✝.as))","decl":"/-- The pseudofunctor from `LocallyDiscrete RingCatᵒᵖ` to `Cat` which sends a ring `R`\nto its category of modules. The functoriality is given by the restriction of scalars. -/\n@[simps! obj map mapId mapComp]\nnoncomputable def RingCat.moduleCatRestrictScalarsPseudofunctor :\n    Pseudofunctor (LocallyDiscrete RingCat.{u}ᵒᵖ) Cat :=\n  LocallyDiscrete.mkPseudofunctor\n    (fun R ↦ Cat.of (ModuleCat.{v} R.unop))\n    (fun f ↦ restrictScalars f.unop.hom)\n    (fun R ↦ restrictScalarsId R.unop)\n    (fun f g ↦ restrictScalarsComp g.unop.hom f.unop.hom)\n\n"}
{"name":"CommRingCat.moduleCatExtendScalarsPseudofunctor_obj","module":"Mathlib.Algebra.Category.ModuleCat.Pseudofunctor","initialProofState":"b : CategoryTheory.LocallyDiscrete CommRingCat\n⊢ Eq (CommRingCat.moduleCatExtendScalarsPseudofunctor.obj b) (CategoryTheory.Cat.of (ModuleCat ↑b.as))","decl":"/-- The pseudofunctor from `LocallyDiscrete CommRingCat` to `Cat` which sends\na commutative ring `R` to its category of modules. The functoriality is given by\nthe extension of scalars. -/\n@[simps! obj map mapId mapComp]\nnoncomputable def CommRingCat.moduleCatExtendScalarsPseudofunctor :\n    Pseudofunctor (LocallyDiscrete CommRingCat.{u}) Cat :=\n  LocallyDiscrete.mkPseudofunctor\n    (fun R ↦ Cat.of (ModuleCat.{u} R))\n    (fun f ↦ extendScalars f.hom)\n    (fun R ↦ extendScalarsId R)\n    (fun f g ↦ extendScalarsComp f.hom g.hom)\n    (fun _ _ _ ↦ extendScalars_assoc' _ _ _)\n    (fun _ ↦ extendScalars_id_comp _)\n    (fun _ ↦ extendScalars_comp_id _)\n"}
{"name":"CommRingCat.moduleCatExtendScalarsPseudofunctor_mapId","module":"Mathlib.Algebra.Category.ModuleCat.Pseudofunctor","initialProofState":"x✝ : CategoryTheory.LocallyDiscrete CommRingCat\n⊢ Eq (CommRingCat.moduleCatExtendScalarsPseudofunctor.mapId x✝) (ModuleCat.extendScalarsId ↑x✝.as)","decl":"/-- The pseudofunctor from `LocallyDiscrete CommRingCat` to `Cat` which sends\na commutative ring `R` to its category of modules. The functoriality is given by\nthe extension of scalars. -/\n@[simps! obj map mapId mapComp]\nnoncomputable def CommRingCat.moduleCatExtendScalarsPseudofunctor :\n    Pseudofunctor (LocallyDiscrete CommRingCat.{u}) Cat :=\n  LocallyDiscrete.mkPseudofunctor\n    (fun R ↦ Cat.of (ModuleCat.{u} R))\n    (fun f ↦ extendScalars f.hom)\n    (fun R ↦ extendScalarsId R)\n    (fun f g ↦ extendScalarsComp f.hom g.hom)\n    (fun _ _ _ ↦ extendScalars_assoc' _ _ _)\n    (fun _ ↦ extendScalars_id_comp _)\n    (fun _ ↦ extendScalars_comp_id _)\n"}
{"name":"CommRingCat.moduleCatExtendScalarsPseudofunctor_map","module":"Mathlib.Algebra.Category.ModuleCat.Pseudofunctor","initialProofState":"X✝ Y✝ : CategoryTheory.LocallyDiscrete CommRingCat\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CommRingCat.moduleCatExtendScalarsPseudofunctor.map f) (ModuleCat.extendScalars (CommRingCat.Hom.hom f.as))","decl":"/-- The pseudofunctor from `LocallyDiscrete CommRingCat` to `Cat` which sends\na commutative ring `R` to its category of modules. The functoriality is given by\nthe extension of scalars. -/\n@[simps! obj map mapId mapComp]\nnoncomputable def CommRingCat.moduleCatExtendScalarsPseudofunctor :\n    Pseudofunctor (LocallyDiscrete CommRingCat.{u}) Cat :=\n  LocallyDiscrete.mkPseudofunctor\n    (fun R ↦ Cat.of (ModuleCat.{u} R))\n    (fun f ↦ extendScalars f.hom)\n    (fun R ↦ extendScalarsId R)\n    (fun f g ↦ extendScalarsComp f.hom g.hom)\n    (fun _ _ _ ↦ extendScalars_assoc' _ _ _)\n    (fun _ ↦ extendScalars_id_comp _)\n    (fun _ ↦ extendScalars_comp_id _)\n"}
{"name":"CommRingCat.moduleCatExtendScalarsPseudofunctor_mapComp","module":"Mathlib.Algebra.Category.ModuleCat.Pseudofunctor","initialProofState":"a✝ b✝ c✝ : CategoryTheory.LocallyDiscrete CommRingCat\nx✝¹ : Quiver.Hom a✝ b✝\nx✝ : Quiver.Hom b✝ c✝\n⊢ Eq (CommRingCat.moduleCatExtendScalarsPseudofunctor.mapComp x✝¹ x✝) (ModuleCat.extendScalarsComp (CommRingCat.Hom.hom x✝¹.as) (CommRingCat.Hom.hom x✝.as))","decl":"/-- The pseudofunctor from `LocallyDiscrete CommRingCat` to `Cat` which sends\na commutative ring `R` to its category of modules. The functoriality is given by\nthe extension of scalars. -/\n@[simps! obj map mapId mapComp]\nnoncomputable def CommRingCat.moduleCatExtendScalarsPseudofunctor :\n    Pseudofunctor (LocallyDiscrete CommRingCat.{u}) Cat :=\n  LocallyDiscrete.mkPseudofunctor\n    (fun R ↦ Cat.of (ModuleCat.{u} R))\n    (fun f ↦ extendScalars f.hom)\n    (fun R ↦ extendScalarsId R)\n    (fun f g ↦ extendScalarsComp f.hom g.hom)\n    (fun _ _ _ ↦ extendScalars_assoc' _ _ _)\n    (fun _ ↦ extendScalars_id_comp _)\n    (fun _ ↦ extendScalars_comp_id _)\n"}
