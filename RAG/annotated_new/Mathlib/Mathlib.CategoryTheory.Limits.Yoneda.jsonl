{"name":"CategoryTheory.Coyoneda.colimitCocone_Œπ_app","module":"Mathlib.CategoryTheory.Limits.Yoneda","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : Opposite C\nX_1 : C\na : (CategoryTheory.coyoneda.obj X).obj X_1\n‚ä¢ Eq ((CategoryTheory.Coyoneda.colimitCocone X).Œπ.app X_1 a) (id PUnit.unit)","decl":"/-- The colimit cocone over `coyoneda.obj X`, with cocone point `PUnit`.\n-/\n@[simps]\ndef colimitCocone (X : C·µí·µñ) : Cocone (coyoneda.obj X) where\n  pt := PUnit\n  Œπ := { app := by aesop_cat }\n\n"}
{"name":"CategoryTheory.Coyoneda.colimitCocone_pt","module":"Mathlib.CategoryTheory.Limits.Yoneda","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : Opposite C\n‚ä¢ Eq (CategoryTheory.Coyoneda.colimitCocone X).pt PUnit.{v + 1}","decl":"/-- The colimit cocone over `coyoneda.obj X`, with cocone point `PUnit`.\n-/\n@[simps]\ndef colimitCocone (X : C·µí·µñ) : Cocone (coyoneda.obj X) where\n  pt := PUnit\n  Œπ := { app := by aesop_cat }\n\n"}
{"name":"CategoryTheory.Coyoneda.colimitCoconeIsColimit_desc","module":"Mathlib.CategoryTheory.Limits.Yoneda","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : Opposite C\ns : CategoryTheory.Limits.Cocone (CategoryTheory.coyoneda.obj X)\nx‚úù : (CategoryTheory.Coyoneda.colimitCocone X).pt\n‚ä¢ Eq ((CategoryTheory.Coyoneda.colimitCoconeIsColimit X).desc s x‚úù) (s.Œπ.app (Opposite.unop X) (CategoryTheory.CategoryStruct.id (Opposite.unop X)))","decl":"/-- The proposed colimit cocone over `coyoneda.obj X` is a colimit cocone.\n-/\n@[simps]\ndef colimitCoconeIsColimit (X : C·µí·µñ) : IsColimit (colimitCocone X) where\n  desc s _ := s.Œπ.app (unop X) (ùüô _)\n  fac s Y := by\n    funext f\n    convert congr_fun (s.w f).symm (ùüô (unop X))\n    simp only [coyoneda_obj_obj, Functor.const_obj_obj, types_comp_apply,\n      coyoneda_obj_map, Category.id_comp]\n  uniq s m w := by\n    apply funext; rintro ‚ü®‚ü©\n    dsimp\n    rw [‚Üê w]\n    simp\n\n"}
{"name":"CategoryTheory.Coyoneda.instHasColimitObjOppositeFunctorTypeCoyoneda","module":"Mathlib.CategoryTheory.Limits.Yoneda","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : Opposite C\n‚ä¢ CategoryTheory.Limits.HasColimit (CategoryTheory.coyoneda.obj X)","decl":"instance (X : C·µí·µñ) : HasColimit (coyoneda.obj X) :=\n  HasColimit.mk\n    { cocone := _\n      isColimit := colimitCoconeIsColimit X }\n\n"}
{"name":"CategoryTheory.Limits.coneOfSectionCompYoneda_œÄ","module":"Mathlib.CategoryTheory.Limits.Yoneda","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst‚úù : CategoryTheory.Category.{t, w} J\nF : CategoryTheory.Functor J (Opposite C)\nX : C\ns : ‚Üë(F.comp (CategoryTheory.yoneda.obj X)).sections\n‚ä¢ Eq (CategoryTheory.Limits.coneOfSectionCompYoneda F X s).œÄ ((CategoryTheory.Limits.compYonedaSectionsEquiv F X) s)","decl":"/-- The cone of `F` corresponding to an element in `(F ‚ãô yoneda.obj X).sections`. -/\n@[simps]\ndef Limits.coneOfSectionCompYoneda (F : J ‚•§ C·µí·µñ) (X : C)\n    (s : (F ‚ãô yoneda.obj X).sections) : Cone F where\n  pt := Opposite.op X\n  œÄ := compYonedaSectionsEquiv F X s\n\n"}
{"name":"CategoryTheory.Limits.coneOfSectionCompYoneda_pt","module":"Mathlib.CategoryTheory.Limits.Yoneda","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst‚úù : CategoryTheory.Category.{t, w} J\nF : CategoryTheory.Functor J (Opposite C)\nX : C\ns : ‚Üë(F.comp (CategoryTheory.yoneda.obj X)).sections\n‚ä¢ Eq (CategoryTheory.Limits.coneOfSectionCompYoneda F X s).pt { unop := X }","decl":"/-- The cone of `F` corresponding to an element in `(F ‚ãô yoneda.obj X).sections`. -/\n@[simps]\ndef Limits.coneOfSectionCompYoneda (F : J ‚•§ C·µí·µñ) (X : C)\n    (s : (F ‚ãô yoneda.obj X).sections) : Cone F where\n  pt := Opposite.op X\n  œÄ := compYonedaSectionsEquiv F X s\n\n"}
{"name":"CategoryTheory.yoneda_preservesLimit","module":"Mathlib.CategoryTheory.Limits.Yoneda","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst‚úù : CategoryTheory.Category.{t, w} J\nF : CategoryTheory.Functor J (Opposite C)\nX : C\n‚ä¢ CategoryTheory.Limits.PreservesLimit F (CategoryTheory.yoneda.obj X)","decl":"instance yoneda_preservesLimit (F : J ‚•§ C·µí·µñ) (X : C) :\n    PreservesLimit F (yoneda.obj X) where\n  preserves {c} hc := by\n    rw [Types.isLimit_iff]\n    intro s hs\n    exact ‚ü®(hc.lift (Limits.coneOfSectionCompYoneda F X ‚ü®s, hs‚ü©)).unop,\n      fun j => Quiver.Hom.op_inj (hc.fac (Limits.coneOfSectionCompYoneda F X ‚ü®s, hs‚ü©) j),\n      fun m hm => Quiver.Hom.op_inj\n        (hc.uniq (Limits.coneOfSectionCompYoneda F X ‚ü®s, hs‚ü©) _\n          (fun j => Quiver.Hom.unop_inj (hm j)))‚ü©\n\n"}
{"name":"CategoryTheory.yoneda_preservesLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Yoneda","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst‚úù : CategoryTheory.Category.{t, w} J\nX : C\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape J (CategoryTheory.yoneda.obj X)","decl":"variable (J) in\nnoncomputable instance yoneda_preservesLimitsOfShape (X : C) :\n    PreservesLimitsOfShape J (yoneda.obj X) where\n\n"}
{"name":"CategoryTheory.Limits.coneOfSectionCompCoyoneda_œÄ","module":"Mathlib.CategoryTheory.Limits.Yoneda","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst‚úù : CategoryTheory.Category.{t, w} J\nF : CategoryTheory.Functor J C\nX : Opposite C\ns : ‚Üë(F.comp (CategoryTheory.coyoneda.obj X)).sections\n‚ä¢ Eq (CategoryTheory.Limits.coneOfSectionCompCoyoneda F X s).œÄ ((CategoryTheory.Limits.compCoyonedaSectionsEquiv F (Opposite.unop X)) s)","decl":"/-- The cone of `F` corresponding to an element in `(F ‚ãô coyoneda.obj X).sections`. -/\n@[simps]\ndef Limits.coneOfSectionCompCoyoneda (F : J ‚•§ C) (X : C·µí·µñ)\n    (s : (F ‚ãô coyoneda.obj X).sections) : Cone F where\n  pt := X.unop\n  œÄ := compCoyonedaSectionsEquiv F X.unop s\n\n"}
{"name":"CategoryTheory.Limits.coneOfSectionCompCoyoneda_pt","module":"Mathlib.CategoryTheory.Limits.Yoneda","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst‚úù : CategoryTheory.Category.{t, w} J\nF : CategoryTheory.Functor J C\nX : Opposite C\ns : ‚Üë(F.comp (CategoryTheory.coyoneda.obj X)).sections\n‚ä¢ Eq (CategoryTheory.Limits.coneOfSectionCompCoyoneda F X s).pt (Opposite.unop X)","decl":"/-- The cone of `F` corresponding to an element in `(F ‚ãô coyoneda.obj X).sections`. -/\n@[simps]\ndef Limits.coneOfSectionCompCoyoneda (F : J ‚•§ C) (X : C·µí·µñ)\n    (s : (F ‚ãô coyoneda.obj X).sections) : Cone F where\n  pt := X.unop\n  œÄ := compCoyonedaSectionsEquiv F X.unop s\n\n"}
{"name":"CategoryTheory.coyoneda_preservesLimit","module":"Mathlib.CategoryTheory.Limits.Yoneda","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst‚úù : CategoryTheory.Category.{t, w} J\nF : CategoryTheory.Functor J C\nX : Opposite C\n‚ä¢ CategoryTheory.Limits.PreservesLimit F (CategoryTheory.coyoneda.obj X)","decl":"instance coyoneda_preservesLimit (F : J ‚•§ C) (X : C·µí·µñ) :\n    PreservesLimit F (coyoneda.obj X) where\n  preserves {c} hc := by\n    rw [Types.isLimit_iff]\n    intro s hs\n    exact ‚ü®hc.lift (Limits.coneOfSectionCompCoyoneda F X ‚ü®s, hs‚ü©), hc.fac _,\n      hc.uniq (Limits.coneOfSectionCompCoyoneda F X ‚ü®s, hs‚ü©)‚ü©\n\n"}
{"name":"CategoryTheory.coyonedaPreservesLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Yoneda","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst‚úù : CategoryTheory.Category.{t, w} J\nX : Opposite C\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape J (CategoryTheory.coyoneda.obj X)","decl":"variable (J) in\nnoncomputable instance coyonedaPreservesLimitsOfShape (X : C·µí·µñ) :\n    PreservesLimitsOfShape J (coyoneda.obj X) where\n\n"}
{"name":"CategoryTheory.yoneda_preservesLimits","module":"Mathlib.CategoryTheory.Limits.Yoneda","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{t, w, v, v, u, v + 1} (CategoryTheory.yoneda.obj X)","decl":"/-- The yoneda embedding `yoneda.obj X : C·µí·µñ ‚•§ Type v` for `X : C` preserves limits. -/\ninstance yoneda_preservesLimits (X : C) :\n    PreservesLimitsOfSize.{t, w} (yoneda.obj X) where\n\n"}
{"name":"CategoryTheory.coyoneda_preservesLimits","module":"Mathlib.CategoryTheory.Limits.Yoneda","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : Opposite C\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{t, w, v, v, u, v + 1} (CategoryTheory.coyoneda.obj X)","decl":"/-- The coyoneda embedding `coyoneda.obj X : C ‚•§ Type v` for `X : C·µí·µñ` preserves limits. -/\ninstance coyoneda_preservesLimits (X : C·µí·µñ) :\n    PreservesLimitsOfSize.{t, w} (coyoneda.obj X) where\n\n"}
{"name":"CategoryTheory.yonedaFunctor_preservesLimits","module":"Mathlib.CategoryTheory.Limits.Yoneda","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{t, w, v, max u v, u, max u (v + 1)} CategoryTheory.yoneda","decl":"instance yonedaFunctor_preservesLimits :\n    PreservesLimitsOfSize.{t, w} (@yoneda C _) := by\n  apply preservesLimits_of_evaluation\n  intro K\n  change PreservesLimitsOfSize (coyoneda.obj K)\n  infer_instance\n\n"}
{"name":"CategoryTheory.coyonedaFunctor_preservesLimits","module":"Mathlib.CategoryTheory.Limits.Yoneda","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{t, w, v, max u v, u, max u (v + 1)} CategoryTheory.coyoneda","decl":"noncomputable instance coyonedaFunctor_preservesLimits :\n    PreservesLimitsOfSize.{t, w} (@coyoneda C _) := by\n  apply preservesLimits_of_evaluation\n  intro K\n  change PreservesLimitsOfSize (yoneda.obj K)\n  infer_instance\n\n"}
{"name":"CategoryTheory.yonedaFunctor_reflectsLimits","module":"Mathlib.CategoryTheory.Limits.Yoneda","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfSize.{t, w, v, max u v, u, max u (v + 1)} CategoryTheory.yoneda","decl":"noncomputable instance yonedaFunctor_reflectsLimits :\n    ReflectsLimitsOfSize.{t, w} (@yoneda C _) := inferInstance\n\n"}
{"name":"CategoryTheory.coyonedaFunctor_reflectsLimits","module":"Mathlib.CategoryTheory.Limits.Yoneda","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfSize.{t, w, v, max u v, u, max u (v + 1)} CategoryTheory.coyoneda","decl":"noncomputable instance coyonedaFunctor_reflectsLimits :\n    ReflectsLimitsOfSize.{t, w} (@coyoneda C _) := inferInstance\n\n"}
{"name":"CategoryTheory.Functor.representable_preservesLimit","module":"Mathlib.CategoryTheory.Limits.Yoneda","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\ninst‚úù¬π : F.IsRepresentable\nJ : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} J\nG : CategoryTheory.Functor J (Opposite C)\n‚ä¢ CategoryTheory.Limits.PreservesLimit G F","decl":"instance representable_preservesLimit (G : J ‚•§ C·µí·µñ) :\n    PreservesLimit G F :=\n  preservesLimit_of_natIso _ F.reprW\n\n"}
{"name":"CategoryTheory.Functor.representable_preservesLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Yoneda","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\nJ : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} J\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape J F","decl":"variable (J) in\ninstance representable_preservesLimitsOfShape :\n    PreservesLimitsOfShape J F where\n\n"}
{"name":"CategoryTheory.Functor.representable_preservesLimits","module":"Mathlib.CategoryTheory.Limits.Yoneda","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{t, w, v, v, u, v + 1} F","decl":"instance representable_preservesLimits :\n    PreservesLimitsOfSize.{t, w} F where\n\n"}
{"name":"CategoryTheory.Functor.corepresentable_preservesLimit","module":"Mathlib.CategoryTheory.Limits.Yoneda","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type v)\ninst‚úù¬π : F.IsCorepresentable\nJ : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} J\nG : CategoryTheory.Functor J C\n‚ä¢ CategoryTheory.Limits.PreservesLimit G F","decl":"instance corepresentable_preservesLimit (G : J ‚•§ C) :\n    PreservesLimit G F :=\n  preservesLimit_of_natIso _ F.coreprW\n\n"}
{"name":"CategoryTheory.Functor.corepresentable_preservesLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Yoneda","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type v)\nJ : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} J\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape J F","decl":"variable (J) in\ninstance corepresentable_preservesLimitsOfShape :\n    PreservesLimitsOfShape J F where\n\n"}
{"name":"CategoryTheory.Functor.corepresentable_preservesLimits","module":"Mathlib.CategoryTheory.Limits.Yoneda","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type v)\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{t, w, v, v, u, v + 1} F","decl":"instance corepresentable_preservesLimits :\n    PreservesLimitsOfSize.{t, w} F where\n\n"}
