{"name":"Action.instHasFiniteProducts","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝ : CategoryTheory.Limits.HasFiniteProducts V\n⊢ CategoryTheory.Limits.HasFiniteProducts (Action V G)","decl":"instance [HasFiniteProducts V] : HasFiniteProducts (Action V G) where\n  out _ :=\n    Adjunction.hasLimitsOfShape_of_equivalence (Action.functorCategoryEquivalence _ _).functor\n\n"}
{"name":"Action.instHasFiniteLimits","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝ : CategoryTheory.Limits.HasFiniteLimits V\n⊢ CategoryTheory.Limits.HasFiniteLimits (Action V G)","decl":"instance [HasFiniteLimits V] : HasFiniteLimits (Action V G) where\n  out _ _ _ :=\n    Adjunction.hasLimitsOfShape_of_equivalence (Action.functorCategoryEquivalence _ _).functor\n\n"}
{"name":"Action.instHasLimits","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝ : CategoryTheory.Limits.HasLimits V\n⊢ CategoryTheory.Limits.HasLimits (Action V G)","decl":"instance [HasLimits V] : HasLimits (Action V G) :=\n  Adjunction.has_limits_of_equivalence (Action.functorCategoryEquivalence _ _).functor\n\n"}
{"name":"Action.hasLimitsOfShape","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝² : CategoryTheory.LargeCategory V\nG : MonCat\nJ : Type w₁\ninst✝¹ : CategoryTheory.Category.{w₂, w₁} J\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J V\n⊢ CategoryTheory.Limits.HasLimitsOfShape J (Action V G)","decl":"/-- If `V` has limits of shape `J`, so does `Action V G`. -/\ninstance hasLimitsOfShape {J : Type w₁} [Category.{w₂} J] [HasLimitsOfShape J V] :\n    HasLimitsOfShape J (Action V G) :=\n  Adjunction.hasLimitsOfShape_of_equivalence (Action.functorCategoryEquivalence _ _).functor\n\n"}
{"name":"Action.instHasFiniteCoproducts","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts V\n⊢ CategoryTheory.Limits.HasFiniteCoproducts (Action V G)","decl":"instance [HasFiniteCoproducts V] : HasFiniteCoproducts (Action V G) where\n  out _ :=\n    Adjunction.hasColimitsOfShape_of_equivalence (Action.functorCategoryEquivalence _ _).functor\n\n"}
{"name":"Action.instHasFiniteColimits","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝ : CategoryTheory.Limits.HasFiniteColimits V\n⊢ CategoryTheory.Limits.HasFiniteColimits (Action V G)","decl":"instance [HasFiniteColimits V] : HasFiniteColimits (Action V G) where\n  out _ _ _ :=\n    Adjunction.hasColimitsOfShape_of_equivalence (Action.functorCategoryEquivalence _ _).functor\n\n"}
{"name":"Action.instHasColimits","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝ : CategoryTheory.Limits.HasColimits V\n⊢ CategoryTheory.Limits.HasColimits (Action V G)","decl":"instance [HasColimits V] : HasColimits (Action V G) :=\n  Adjunction.has_colimits_of_equivalence (Action.functorCategoryEquivalence _ _).functor\n\n"}
{"name":"Action.hasColimitsOfShape","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝² : CategoryTheory.LargeCategory V\nG : MonCat\nJ : Type w₁\ninst✝¹ : CategoryTheory.Category.{w₂, w₁} J\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J V\n⊢ CategoryTheory.Limits.HasColimitsOfShape J (Action V G)","decl":"/-- If `V` has colimits of shape `J`, so does `Action V G`. -/\ninstance hasColimitsOfShape {J : Type w₁} [Category.{w₂} J]\n    [HasColimitsOfShape J V] : HasColimitsOfShape J (Action V G) :=\n  Adjunction.hasColimitsOfShape_of_equivalence (Action.functorCategoryEquivalence _ _).functor\n\n"}
{"name":"Action.preservesLimit_of_preserves","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝² : CategoryTheory.LargeCategory V\nG : MonCat\nC : Type t₁\ninst✝¹ : CategoryTheory.Category.{t₂, t₁} C\nF : CategoryTheory.Functor C (Action V G)\nJ : Type w₁\ninst✝ : CategoryTheory.Category.{w₂, w₁} J\nK : CategoryTheory.Functor J C\nh : CategoryTheory.Limits.PreservesLimit K (F.comp (Action.forget V G))\n⊢ CategoryTheory.Limits.PreservesLimit K F","decl":"/-- `F : C ⥤ Action V G` preserves the limit of some `K : J ⥤ C` if\nif it does after postcomposing with the forgetful functor `Action V G ⥤ V`. -/\nlemma preservesLimit_of_preserves (F : C ⥤ Action V G) {J : Type w₁}\n    [Category.{w₂} J] (K : J ⥤ C)\n    (h : PreservesLimit K (F ⋙ Action.forget V G)) : PreservesLimit K F := by\n  let F' : C ⥤ SingleObj G ⥤ V := F ⋙ (Action.functorCategoryEquivalence V G).functor\n  have : PreservesLimit K F' := SingleObj.preservesLimit _ _ h\n  apply preservesLimit_of_reflects_of_preserves F (Action.functorCategoryEquivalence V G).functor\n\n"}
{"name":"Action.preservesLimitsOfShape_of_preserves","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝² : CategoryTheory.LargeCategory V\nG : MonCat\nC : Type t₁\ninst✝¹ : CategoryTheory.Category.{t₂, t₁} C\nF : CategoryTheory.Functor C (Action V G)\nJ : Type w₁\ninst✝ : CategoryTheory.Category.{w₂, w₁} J\nh : CategoryTheory.Limits.PreservesLimitsOfShape J (F.comp (Action.forget V G))\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J F","decl":"/-- `F : C ⥤ Action V G` preserves limits of some shape `J`\nif it does after postcomposing with the forgetful functor `Action V G ⥤ V`. -/\nlemma preservesLimitsOfShape_of_preserves (F : C ⥤ Action V G) {J : Type w₁}\n    [Category.{w₂} J] (h : PreservesLimitsOfShape J (F ⋙ Action.forget V G)) :\n    PreservesLimitsOfShape J F := by\n  constructor\n  intro K\n  apply Action.preservesLimit_of_preserves\n  exact PreservesLimitsOfShape.preservesLimit\n\n"}
{"name":"Action.preservesLimitsOfSize_of_preserves","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\nC : Type t₁\ninst✝ : CategoryTheory.Category.{t₂, t₁} C\nF : CategoryTheory.Functor C (Action V G)\nh : CategoryTheory.Limits.PreservesLimitsOfSize.{w₂, w₁, t₂, u, t₁, u + 1} (F.comp (Action.forget V G))\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w₂, w₁, t₂, u, t₁, u + 1} F","decl":"/-- `F : C ⥤ Action V G` preserves limits of some size\nif it does after postcomposing with the forgetful functor `Action V G ⥤ V`. -/\nlemma preservesLimitsOfSize_of_preserves (F : C ⥤ Action V G)\n    (h : PreservesLimitsOfSize.{w₂, w₁} (F ⋙ Action.forget V G)) :\n    PreservesLimitsOfSize.{w₂, w₁} F := by\n  constructor\n  intro J _\n  apply Action.preservesLimitsOfShape_of_preserves\n  exact PreservesLimitsOfSize.preservesLimitsOfShape\n\n"}
{"name":"Action.preservesColimit_of_preserves","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝² : CategoryTheory.LargeCategory V\nG : MonCat\nC : Type t₁\ninst✝¹ : CategoryTheory.Category.{t₂, t₁} C\nF : CategoryTheory.Functor C (Action V G)\nJ : Type w₁\ninst✝ : CategoryTheory.Category.{w₂, w₁} J\nK : CategoryTheory.Functor J C\nh : CategoryTheory.Limits.PreservesColimit K (F.comp (Action.forget V G))\n⊢ CategoryTheory.Limits.PreservesColimit K F","decl":"/-- `F : C ⥤ Action V G` preserves the colimit of some `K : J ⥤ C` if\nif it does after postcomposing with the forgetful functor `Action V G ⥤ V`. -/\nlemma preservesColimit_of_preserves (F : C ⥤ Action V G) {J : Type w₁}\n    [Category.{w₂} J] (K : J ⥤ C)\n    (h : PreservesColimit K (F ⋙ Action.forget V G)) : PreservesColimit K F := by\n  let F' : C ⥤ SingleObj G ⥤ V := F ⋙ (Action.functorCategoryEquivalence V G).functor\n  have : PreservesColimit K F' := SingleObj.preservesColimit _ _ h\n  apply preservesColimit_of_reflects_of_preserves F (Action.functorCategoryEquivalence V G).functor\n\n"}
{"name":"Action.preservesColimitsOfShape_of_preserves","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝² : CategoryTheory.LargeCategory V\nG : MonCat\nC : Type t₁\ninst✝¹ : CategoryTheory.Category.{t₂, t₁} C\nF : CategoryTheory.Functor C (Action V G)\nJ : Type w₁\ninst✝ : CategoryTheory.Category.{w₂, w₁} J\nh : CategoryTheory.Limits.PreservesColimitsOfShape J (F.comp (Action.forget V G))\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape J F","decl":"/-- `F : C ⥤ Action V G` preserves colimits of some shape `J`\nif it does after postcomposing with the forgetful functor `Action V G ⥤ V`. -/\nlemma preservesColimitsOfShape_of_preserves (F : C ⥤ Action V G) {J : Type w₁}\n    [Category.{w₂} J] (h : PreservesColimitsOfShape J (F ⋙ Action.forget V G)) :\n    PreservesColimitsOfShape J F := by\n  constructor\n  intro K\n  apply Action.preservesColimit_of_preserves\n  exact PreservesColimitsOfShape.preservesColimit\n\n"}
{"name":"Action.preservesColimitsOfSize_of_preserves","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\nC : Type t₁\ninst✝ : CategoryTheory.Category.{t₂, t₁} C\nF : CategoryTheory.Functor C (Action V G)\nh : CategoryTheory.Limits.PreservesColimitsOfSize.{w₂, w₁, t₂, u, t₁, u + 1} (F.comp (Action.forget V G))\n⊢ CategoryTheory.Limits.PreservesColimitsOfSize.{w₂, w₁, t₂, u, t₁, u + 1} F","decl":"/-- `F : C ⥤ Action V G` preserves colimits of some size\nif it does after postcomposing with the forgetful functor `Action V G ⥤ V`. -/\nlemma preservesColimitsOfSize_of_preserves (F : C ⥤ Action V G)\n    (h : PreservesColimitsOfSize.{w₂, w₁} (F ⋙ Action.forget V G)) :\n    PreservesColimitsOfSize.{w₂, w₁} F := by\n  constructor\n  intro J _\n  apply Action.preservesColimitsOfShape_of_preserves\n  exact PreservesColimitsOfSize.preservesColimitsOfShape\n\n"}
{"name":"Action.instPreservesLimitsOfShapeForgetOfHasLimitsOfShape","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝² : CategoryTheory.LargeCategory V\nG : MonCat\nJ : Type w₁\ninst✝¹ : CategoryTheory.Category.{w₂, w₁} J\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J V\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J (Action.forget V G)","decl":"noncomputable instance {J : Type w₁} [Category.{w₂} J] [HasLimitsOfShape J V] :\n    PreservesLimitsOfShape J (Action.forget V G) := by\n  show PreservesLimitsOfShape J ((Action.functorCategoryEquivalence V G).functor ⋙\n    (evaluation (SingleObj G) V).obj (SingleObj.star G))\n  infer_instance\n\n"}
{"name":"Action.instPreservesColimitsOfShapeForgetOfHasColimitsOfShape","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝² : CategoryTheory.LargeCategory V\nG : MonCat\nJ : Type w₁\ninst✝¹ : CategoryTheory.Category.{w₂, w₁} J\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J V\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape J (Action.forget V G)","decl":"noncomputable instance {J : Type w₁} [Category.{w₂} J] [HasColimitsOfShape J V] :\n    PreservesColimitsOfShape J (Action.forget V G) := by\n  show PreservesColimitsOfShape J ((Action.functorCategoryEquivalence V G).functor ⋙\n    (evaluation (SingleObj G) V).obj (SingleObj.star G))\n  infer_instance\n\n"}
{"name":"Action.instPreservesFiniteLimitsForgetOfHasFiniteLimits","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝ : CategoryTheory.Limits.HasFiniteLimits V\n⊢ CategoryTheory.Limits.PreservesFiniteLimits (Action.forget V G)","decl":"noncomputable instance [HasFiniteLimits V] : PreservesFiniteLimits (Action.forget V G) := by\n  show PreservesFiniteLimits ((Action.functorCategoryEquivalence V G).functor ⋙\n    (evaluation (SingleObj G) V).obj (SingleObj.star G))\n  have : PreservesFiniteLimits ((evaluation (SingleObj G) V).obj (SingleObj.star G)) := by\n    constructor\n    intro _ _ _\n    infer_instance\n  apply comp_preservesFiniteLimits\n\n"}
{"name":"Action.instPreservesFiniteColimitsForgetOfHasFiniteColimits","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝ : CategoryTheory.Limits.HasFiniteColimits V\n⊢ CategoryTheory.Limits.PreservesFiniteColimits (Action.forget V G)","decl":"noncomputable instance [HasFiniteColimits V] : PreservesFiniteColimits (Action.forget V G) := by\n  show PreservesFiniteColimits ((Action.functorCategoryEquivalence V G).functor ⋙\n    (evaluation (SingleObj G) V).obj (SingleObj.star G))\n  have : PreservesFiniteColimits ((evaluation (SingleObj G) V).obj (SingleObj.star G)) := by\n    constructor\n    intro _ _ _\n    infer_instance\n  apply comp_preservesFiniteColimits\n\n"}
{"name":"Action.instReflectsLimitForget","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\nJ : Type w₁\ninst✝ : CategoryTheory.Category.{w₂, w₁} J\nF : CategoryTheory.Functor J (Action V G)\n⊢ CategoryTheory.Limits.ReflectsLimit F (Action.forget V G)","decl":"instance {J : Type w₁} [Category.{w₂} J] (F : J ⥤ Action V G) :\n    ReflectsLimit F (Action.forget V G) where\n  reflects h := ⟨by\n    apply isLimitOfReflects ((Action.functorCategoryEquivalence V G).functor)\n    exact evaluationJointlyReflectsLimits _ (fun _ => h)⟩\n\n"}
{"name":"Action.instReflectsLimitsOfShapeForget","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\nJ : Type w₁\ninst✝ : CategoryTheory.Category.{w₂, w₁} J\n⊢ CategoryTheory.Limits.ReflectsLimitsOfShape J (Action.forget V G)","decl":"instance {J : Type w₁} [Category.{w₂} J] :\n    ReflectsLimitsOfShape J (Action.forget V G) where\n\n"}
{"name":"Action.instReflectsLimitsForget","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\n⊢ CategoryTheory.Limits.ReflectsLimits (Action.forget V G)","decl":"instance : ReflectsLimits (Action.forget V G) where\n\n"}
{"name":"Action.instReflectsColimitForget","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\nJ : Type w₁\ninst✝ : CategoryTheory.Category.{w₂, w₁} J\nF : CategoryTheory.Functor J (Action V G)\n⊢ CategoryTheory.Limits.ReflectsColimit F (Action.forget V G)","decl":"instance {J : Type w₁} [Category.{w₂} J] (F : J ⥤ Action V G) :\n    ReflectsColimit F (Action.forget V G) where\n  reflects h := ⟨by\n    apply isColimitOfReflects ((Action.functorCategoryEquivalence V G).functor)\n    exact evaluationJointlyReflectsColimits _ (fun _ => h)⟩\n\n"}
{"name":"Action.instReflectsColimitsOfShapeForget","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\nJ : Type w₁\ninst✝ : CategoryTheory.Category.{w₂, w₁} J\n⊢ CategoryTheory.Limits.ReflectsColimitsOfShape J (Action.forget V G)","decl":"noncomputable instance {J : Type w₁} [Category.{w₂} J] :\n    ReflectsColimitsOfShape J (Action.forget V G) where\n\n"}
{"name":"Action.instReflectsColimitsForget","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\n⊢ CategoryTheory.Limits.ReflectsColimits (Action.forget V G)","decl":"noncomputable instance : ReflectsColimits (Action.forget V G) where\n\n"}
{"name":"Action.zero_hom","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX Y : Action V G\n⊢ Eq (Action.Hom.hom 0) 0","decl":"@[simp]\ntheorem zero_hom {X Y : Action V G} : (0 : X ⟶ Y).hom = 0 :=\n  rfl\n\n"}
{"name":"Action.forget_preservesZeroMorphisms","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\n⊢ (Action.forget V G).PreservesZeroMorphisms","decl":"instance forget_preservesZeroMorphisms : Functor.PreservesZeroMorphisms (forget V G) where\n\n"}
{"name":"Action.forget₂_preservesZeroMorphisms","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝² : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝ : CategoryTheory.HasForget V\n⊢ (CategoryTheory.forget₂ (Action V G) V).PreservesZeroMorphisms","decl":"instance forget₂_preservesZeroMorphisms [HasForget V] :\n    Functor.PreservesZeroMorphisms (forget₂ (Action V G) V) where\n\n"}
{"name":"Action.functorCategoryEquivalence_preservesZeroMorphisms","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\n⊢ (Action.functorCategoryEquivalence V G).functor.PreservesZeroMorphisms","decl":"instance functorCategoryEquivalence_preservesZeroMorphisms :\n    Functor.PreservesZeroMorphisms (functorCategoryEquivalence V G).functor where\n\n"}
{"name":"Action.forget_additive","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝ : CategoryTheory.Preadditive V\n⊢ (Action.forget V G).Additive","decl":"instance forget_additive : Functor.Additive (forget V G) where\n\n"}
{"name":"Action.forget₂_additive","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝² : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝¹ : CategoryTheory.Preadditive V\ninst✝ : CategoryTheory.HasForget V\n⊢ (CategoryTheory.forget₂ (Action V G) V).Additive","decl":"instance forget₂_additive [HasForget V] : Functor.Additive (forget₂ (Action V G) V) where\n\n"}
{"name":"Action.functorCategoryEquivalence_additive","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝ : CategoryTheory.Preadditive V\n⊢ (Action.functorCategoryEquivalence V G).functor.Additive","decl":"instance functorCategoryEquivalence_additive :\n    Functor.Additive (functorCategoryEquivalence V G).functor where\n\n"}
{"name":"Action.neg_hom","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝ : CategoryTheory.Preadditive V\nX Y : Action V G\nf : Quiver.Hom X Y\n⊢ Eq (Neg.neg f).hom (Neg.neg f.hom)","decl":"@[simp]\ntheorem neg_hom {X Y : Action V G} (f : X ⟶ Y) : (-f).hom = -f.hom :=\n  rfl\n\n"}
{"name":"Action.add_hom","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝ : CategoryTheory.Preadditive V\nX Y : Action V G\nf g : Quiver.Hom X Y\n⊢ Eq (HAdd.hAdd f g).hom (HAdd.hAdd f.hom g.hom)","decl":"@[simp]\ntheorem add_hom {X Y : Action V G} (f g : X ⟶ Y) : (f + g).hom = f.hom + g.hom :=\n  rfl\n\n"}
{"name":"Action.sum_hom","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝ : CategoryTheory.Preadditive V\nX Y : Action V G\nι : Type u_1\nf : ι → Quiver.Hom X Y\ns : Finset ι\n⊢ Eq (s.sum f).hom (s.sum fun i => (f i).hom)","decl":"@[simp]\ntheorem sum_hom {X Y : Action V G} {ι : Type*} (f : ι → (X ⟶ Y)) (s : Finset ι) :\n    (s.sum f).hom = s.sum fun i => (f i).hom :=\n  (forget V G).map_sum f s\n\n"}
{"name":"Action.forget_linear","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝³ : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝² : CategoryTheory.Preadditive V\nR : Type u_1\ninst✝¹ : Semiring R\ninst✝ : CategoryTheory.Linear R V\n⊢ CategoryTheory.Functor.Linear R (Action.forget V G)","decl":"instance forget_linear : Functor.Linear R (forget V G) where\n\n"}
{"name":"Action.forget₂_linear","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝⁴ : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝³ : CategoryTheory.Preadditive V\nR : Type u_1\ninst✝² : Semiring R\ninst✝¹ : CategoryTheory.Linear R V\ninst✝ : CategoryTheory.HasForget V\n⊢ CategoryTheory.Functor.Linear R (CategoryTheory.forget₂ (Action V G) V)","decl":"instance forget₂_linear [HasForget V] : Functor.Linear R (forget₂ (Action V G) V) where\n\n"}
{"name":"Action.functorCategoryEquivalence_linear","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝³ : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝² : CategoryTheory.Preadditive V\nR : Type u_1\ninst✝¹ : Semiring R\ninst✝ : CategoryTheory.Linear R V\n⊢ CategoryTheory.Functor.Linear R (Action.functorCategoryEquivalence V G).functor","decl":"instance functorCategoryEquivalence_linear :\n    Functor.Linear R (functorCategoryEquivalence V G).functor where\n\n"}
{"name":"Action.smul_hom","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝³ : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝² : CategoryTheory.Preadditive V\nR : Type u_1\ninst✝¹ : Semiring R\ninst✝ : CategoryTheory.Linear R V\nX Y : Action V G\nr : R\nf : Quiver.Hom X Y\n⊢ Eq (HSMul.hSMul r f).hom (HSMul.hSMul r f.hom)","decl":"@[simp]\ntheorem smul_hom {X Y : Action V G} (r : R) (f : X ⟶ Y) : (r • f).hom = r • f.hom :=\n  rfl\n\n"}
{"name":"Action.res_additive","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝ : CategoryTheory.Preadditive V\nH : MonCat\nf : Quiver.Hom G H\n⊢ (Action.res V f).Additive","decl":"instance res_additive : (res V f).Additive where\n\n"}
{"name":"Action.res_linear","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝³ : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝² : CategoryTheory.Preadditive V\nR : Type u_1\ninst✝¹ : Semiring R\ninst✝ : CategoryTheory.Linear R V\nH : MonCat\nf : Quiver.Hom G H\n⊢ CategoryTheory.Functor.Linear R (Action.res V f)","decl":"instance res_linear : (res V f).Linear R where\n\n"}
{"name":"CategoryTheory.Functor.mapAction_preadditive","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝⁴ : CategoryTheory.LargeCategory V\nW : Type (u + 1)\ninst✝³ : CategoryTheory.LargeCategory W\nF : CategoryTheory.Functor V W\nG : MonCat\ninst✝² : CategoryTheory.Preadditive V\ninst✝¹ : CategoryTheory.Preadditive W\ninst✝ : F.Additive\n⊢ (F.mapAction G).Additive","decl":"instance mapAction_preadditive [F.Additive] : (F.mapAction G).Additive where\n\n"}
{"name":"CategoryTheory.Functor.mapAction_linear","module":"Mathlib.CategoryTheory.Action.Limits","initialProofState":"V : Type (u + 1)\ninst✝⁸ : CategoryTheory.LargeCategory V\nW : Type (u + 1)\ninst✝⁷ : CategoryTheory.LargeCategory W\nF : CategoryTheory.Functor V W\nG : MonCat\ninst✝⁶ : CategoryTheory.Preadditive V\ninst✝⁵ : CategoryTheory.Preadditive W\nR : Type u_1\ninst✝⁴ : Semiring R\ninst✝³ : CategoryTheory.Linear R V\ninst✝² : CategoryTheory.Linear R W\ninst✝¹ : F.Additive\ninst✝ : CategoryTheory.Functor.Linear R F\n⊢ CategoryTheory.Functor.Linear R (F.mapAction G)","decl":"instance mapAction_linear [F.Additive] [F.Linear R] : (F.mapAction G).Linear R where\n\n"}
