{"name":"Filter.tendsto_eval_pi","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\ni : Î¹\nâŠ¢ Filter.Tendsto (Function.eval i) (Filter.pi f) (f i)","decl":"theorem tendsto_eval_pi (f : âˆ€ i, Filter (Î± i)) (i : Î¹) : Tendsto (eval i) (pi f) (f i) :=\n  tendsto_iInf' i tendsto_comap\n\n"}
{"name":"Filter.tendsto_pi","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\nÎ² : Type u_3\nm : Î² â†’ (i : Î¹) â†’ Î± i\nl : Filter Î²\nâŠ¢ Iff (Filter.Tendsto m l (Filter.pi f)) (âˆ€ (i : Î¹), Filter.Tendsto (fun x => m x i) l (f i))","decl":"theorem tendsto_pi {Î² : Type*} {m : Î² â†’ âˆ€ i, Î± i} {l : Filter Î²} :\n    Tendsto m l (pi f) â†” âˆ€ i, Tendsto (fun x => m x i) l (f i) := by\n  simp only [pi, tendsto_iInf, tendsto_comap_iff]; rfl\n\n"}
{"name":"Filter.Tendsto.apply","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\nÎ² : Type u_3\nm : Î² â†’ (i : Î¹) â†’ Î± i\nl : Filter Î²\naâœ : Filter.Tendsto m l (Filter.pi f)\ni : Î¹\nâŠ¢ Filter.Tendsto (fun x => m x i) l (f i)","decl":"/-- If a function tends to a product `Filter.pi f` of filters, then its `i`-th component tends to\n`f i`. See also `Filter.Tendsto.apply_nhds` for the special case of converging to a point in a\nproduct of topological spaces. -/\nalias âŸ¨Tendsto.apply, _âŸ© := tendsto_pi\n\n"}
{"name":"Filter.le_pi","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\ng : Filter ((i : Î¹) â†’ Î± i)\nâŠ¢ Iff (LE.le g (Filter.pi f)) (âˆ€ (i : Î¹), Filter.Tendsto (Function.eval i) g (f i))","decl":"theorem le_pi {g : Filter (âˆ€ i, Î± i)} : g â‰¤ pi f â†” âˆ€ i, Tendsto (eval i) g (f i) :=\n  tendsto_pi\n\n"}
{"name":"Filter.pi_mono","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nfâ‚ fâ‚‚ : (i : Î¹) â†’ Filter (Î± i)\nh : âˆ€ (i : Î¹), LE.le (fâ‚ i) (fâ‚‚ i)\nâŠ¢ LE.le (Filter.pi fâ‚) (Filter.pi fâ‚‚)","decl":"@[mono]\ntheorem pi_mono (h : âˆ€ i, fâ‚ i â‰¤ fâ‚‚ i) : pi fâ‚ â‰¤ pi fâ‚‚ :=\n  iInf_mono fun i => comap_mono <| h i\n\n"}
{"name":"Filter.mem_pi_of_mem","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\ni : Î¹\ns : Set (Î± i)\nhs : Membership.mem (f i) s\nâŠ¢ Membership.mem (Filter.pi f) (Set.preimage (Function.eval i) s)","decl":"theorem mem_pi_of_mem (i : Î¹) {s : Set (Î± i)} (hs : s âˆˆ f i) : eval i â»Â¹' s âˆˆ pi f :=\n  mem_iInf_of_mem i <| preimage_mem_comap hs\n\n"}
{"name":"Filter.pi_mem_pi","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\ns : (i : Î¹) â†’ Set (Î± i)\nI : Set Î¹\nhI : I.Finite\nh : âˆ€ (i : Î¹), Membership.mem I i â†’ Membership.mem (f i) (s i)\nâŠ¢ Membership.mem (Filter.pi f) (I.pi s)","decl":"theorem pi_mem_pi {I : Set Î¹} (hI : I.Finite) (h : âˆ€ i âˆˆ I, s i âˆˆ f i) : I.pi s âˆˆ pi f := by\n  rw [pi_def, biInter_eq_iInter]\n  refine mem_iInf_of_iInter hI (fun i => ?_) Subset.rfl\n  exact preimage_mem_comap (h i i.2)\n\n"}
{"name":"Filter.mem_pi","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\ns : Set ((i : Î¹) â†’ Î± i)\nâŠ¢ Iff (Membership.mem (Filter.pi f) s) (Exists fun I => And I.Finite (Exists fun t => And (âˆ€ (i : Î¹), Membership.mem (f i) (t i)) (HasSubset.Subset (I.pi t) s)))","decl":"theorem mem_pi {s : Set (âˆ€ i, Î± i)} :\n    s âˆˆ pi f â†” âˆƒ I : Set Î¹, I.Finite âˆ§ âˆƒ t : âˆ€ i, Set (Î± i), (âˆ€ i, t i âˆˆ f i) âˆ§ I.pi t âŠ† s := by\n  constructor\n  Â· simp only [pi, mem_iInf', mem_comap, pi_def]\n    rintro âŸ¨I, If, V, hVf, -, rfl, -âŸ©\n    choose t htf htV using hVf\n    exact âŸ¨I, If, t, htf, iInterâ‚‚_mono fun i _ => htV iâŸ©\n  Â· rintro âŸ¨I, If, t, htf, htsâŸ©\n    exact mem_of_superset (pi_mem_pi If fun i _ => htf i) hts\n\n"}
{"name":"Filter.mem_pi'","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\ns : Set ((i : Î¹) â†’ Î± i)\nâŠ¢ Iff (Membership.mem (Filter.pi f) s) (Exists fun I => Exists fun t => And (âˆ€ (i : Î¹), Membership.mem (f i) (t i)) (HasSubset.Subset ((â†‘I).pi t) s))","decl":"theorem mem_pi' {s : Set (âˆ€ i, Î± i)} :\n    s âˆˆ pi f â†” âˆƒ I : Finset Î¹, âˆƒ t : âˆ€ i, Set (Î± i), (âˆ€ i, t i âˆˆ f i) âˆ§ Set.pi (â†‘I) t âŠ† s :=\n  mem_pi.trans exists_finite_iff_finset\n\n"}
{"name":"Filter.mem_of_pi_mem_pi","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\ns : (i : Î¹) â†’ Set (Î± i)\ninstâœ : âˆ€ (i : Î¹), (f i).NeBot\nI : Set Î¹\nh : Membership.mem (Filter.pi f) (I.pi s)\ni : Î¹\nhi : Membership.mem I i\nâŠ¢ Membership.mem (f i) (s i)","decl":"theorem mem_of_pi_mem_pi [âˆ€ i, NeBot (f i)] {I : Set Î¹} (h : I.pi s âˆˆ pi f) {i : Î¹} (hi : i âˆˆ I) :\n    s i âˆˆ f i := by\n  classical\n  rcases mem_pi.1 h with âŸ¨I', -, t, htf, htsâŸ©\n  refine mem_of_superset (htf i) fun x hx => ?_\n  have : âˆ€ i, (t i).Nonempty := fun i => nonempty_of_mem (htf i)\n  choose g hg using this\n  have : update g i x âˆˆ I'.pi t := fun j _ => by\n    rcases eq_or_ne j i with (rfl | hne) <;> simp [*]\n  simpa using hts this i hi\n\n"}
{"name":"Filter.pi_mem_pi_iff","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\ns : (i : Î¹) â†’ Set (Î± i)\ninstâœ : âˆ€ (i : Î¹), (f i).NeBot\nI : Set Î¹\nhI : I.Finite\nâŠ¢ Iff (Membership.mem (Filter.pi f) (I.pi s)) (âˆ€ (i : Î¹), Membership.mem I i â†’ Membership.mem (f i) (s i))","decl":"@[simp]\ntheorem pi_mem_pi_iff [âˆ€ i, NeBot (f i)] {I : Set Î¹} (hI : I.Finite) :\n    I.pi s âˆˆ pi f â†” âˆ€ i âˆˆ I, s i âˆˆ f i :=\n  âŸ¨fun h _i hi => mem_of_pi_mem_pi h hi, pi_mem_pi hIâŸ©\n\n"}
{"name":"Filter.Eventually.eval_pi","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\np : (i : Î¹) â†’ Î± i â†’ Prop\ni : Î¹\nhf : Filter.Eventually (fun x => p i x) (f i)\nâŠ¢ Filter.Eventually (fun x => p i (x i)) (Filter.pi f)","decl":"theorem Eventually.eval_pi {i : Î¹} (hf : âˆ€á¶  x : Î± i in f i, p i x) :\n    âˆ€á¶  x : âˆ€ i : Î¹, Î± i in pi f, p i (x i) := (tendsto_eval_pi _ _).eventually hf\n\n"}
{"name":"Filter.eventually_pi","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\np : (i : Î¹) â†’ Î± i â†’ Prop\ninstâœ : Finite Î¹\nhf : âˆ€ (i : Î¹), Filter.Eventually (fun x => p i x) (f i)\nâŠ¢ Filter.Eventually (fun x => âˆ€ (i : Î¹), p i (x i)) (Filter.pi f)","decl":"theorem eventually_pi [Finite Î¹] (hf : âˆ€ i, âˆ€á¶  x in f i, p i x) :\n    âˆ€á¶  x : âˆ€ i, Î± i in pi f, âˆ€ i, p i (x i) := eventually_all.2 fun _i => (hf _).eval_pi\n\n"}
{"name":"Filter.hasBasis_pi","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\nÎ¹' : Î¹ â†’ Type u_3\ns : (i : Î¹) â†’ Î¹' i â†’ Set (Î± i)\np : (i : Î¹) â†’ Î¹' i â†’ Prop\nh : âˆ€ (i : Î¹), (f i).HasBasis (p i) (s i)\nâŠ¢ (Filter.pi f).HasBasis (fun If => And If.1.Finite (âˆ€ (i : Î¹), Membership.mem If.1 i â†’ p i (If.2 i))) fun If => If.1.pi fun i => s i (If.2 i)","decl":"theorem hasBasis_pi {Î¹' : Î¹ â†’ Type*} {s : âˆ€ i, Î¹' i â†’ Set (Î± i)} {p : âˆ€ i, Î¹' i â†’ Prop}\n    (h : âˆ€ i, (f i).HasBasis (p i) (s i)) :\n    (pi f).HasBasis (fun If : Set Î¹ Ã— âˆ€ i, Î¹' i => If.1.Finite âˆ§ âˆ€ i âˆˆ If.1, p i (If.2 i))\n      fun If : Set Î¹ Ã— âˆ€ i, Î¹' i => If.1.pi fun i => s i <| If.2 i := by\n  simpa [Set.pi_def] using hasBasis_iInf' fun i => (h i).comap (eval i : (âˆ€ j, Î± j) â†’ Î± i)\n\n"}
{"name":"Filter.le_pi_principal","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\ns : (i : Î¹) â†’ Set (Î± i)\nâŠ¢ LE.le (Filter.principal (Set.univ.pi s)) (Filter.pi fun i => Filter.principal (s i))","decl":"theorem le_pi_principal (s : (i : Î¹) â†’ Set (Î± i)) :\n    ğ“Ÿ (univ.pi s) â‰¤ pi fun i â†¦ ğ“Ÿ (s i) :=\n  le_pi.2 fun i â†¦ tendsto_principal_principal.2 fun _f hf â†¦ hf i trivial\n\n"}
{"name":"Filter.pi_principal","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\ninstâœ : Finite Î¹\ns : (i : Î¹) â†’ Set (Î± i)\nâŠ¢ Eq (Filter.pi fun i => Filter.principal (s i)) (Filter.principal (Set.univ.pi s))","decl":"@[simp]\ntheorem pi_principal [Finite Î¹] (s : (i : Î¹) â†’ Set (Î± i)) :\n    pi (fun i â†¦ ğ“Ÿ (s i)) = ğ“Ÿ (univ.pi s) := by\n  simp [Filter.pi, Set.pi_def]\n\n"}
{"name":"Filter.pi_pure","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\ninstâœ : Finite Î¹\nf : (i : Î¹) â†’ Î± i\nâŠ¢ Eq (Filter.pi fun x => Pure.pure (f x)) (Pure.pure f)","decl":"@[simp]\ntheorem pi_pure [Finite Î¹] (f : (i : Î¹) â†’ Î± i) : pi (pure <| f Â·) = pure f := by\n  simp only [â† principal_singleton, pi_principal, univ_pi_singleton]\n\n"}
{"name":"Filter.pi_inf_principal_univ_pi_eq_bot","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\ns : (i : Î¹) â†’ Set (Î± i)\nâŠ¢ Iff (Eq (Min.min (Filter.pi f) (Filter.principal (Set.univ.pi s))) Bot.bot) (Exists fun i => Eq (Min.min (f i) (Filter.principal (s i))) Bot.bot)","decl":"@[simp]\ntheorem pi_inf_principal_univ_pi_eq_bot :\n    pi f âŠ“ ğ“Ÿ (Set.pi univ s) = âŠ¥ â†” âˆƒ i, f i âŠ“ ğ“Ÿ (s i) = âŠ¥ := by\n  constructor\n  Â· simp only [inf_principal_eq_bot, mem_pi]\n    contrapose!\n    rintro (hsf : âˆ€ i, âˆƒá¶  x in f i, x âˆˆ s i) I - t htf hts\n    have : âˆ€ i, (s i âˆ© t i).Nonempty := fun i => ((hsf i).and_eventually (htf i)).exists\n    choose x hxs hxt using this\n    exact hts (fun i _ => hxt i) (mem_univ_pi.2 hxs)\n  Â· simp only [inf_principal_eq_bot]\n    rintro âŸ¨i, hiâŸ©\n    filter_upwards [mem_pi_of_mem i hi] with x using mt fun h => h i trivial\n\n"}
{"name":"Filter.pi_inf_principal_pi_eq_bot","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\ns : (i : Î¹) â†’ Set (Î± i)\ninstâœ : âˆ€ (i : Î¹), (f i).NeBot\nI : Set Î¹\nâŠ¢ Iff (Eq (Min.min (Filter.pi f) (Filter.principal (I.pi s))) Bot.bot) (Exists fun i => And (Membership.mem I i) (Eq (Min.min (f i) (Filter.principal (s i))) Bot.bot))","decl":"@[simp]\ntheorem pi_inf_principal_pi_eq_bot [âˆ€ i, NeBot (f i)] {I : Set Î¹} :\n    pi f âŠ“ ğ“Ÿ (Set.pi I s) = âŠ¥ â†” âˆƒ i âˆˆ I, f i âŠ“ ğ“Ÿ (s i) = âŠ¥ := by\n  classical\n  rw [â† univ_pi_piecewise_univ I, pi_inf_principal_univ_pi_eq_bot]\n  refine exists_congr fun i => ?_\n  by_cases hi : i âˆˆ I <;> simp [hi, NeBot.ne']\n\n"}
{"name":"Filter.pi_inf_principal_univ_pi_neBot","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\ns : (i : Î¹) â†’ Set (Î± i)\nâŠ¢ Iff (Min.min (Filter.pi f) (Filter.principal (Set.univ.pi s))).NeBot (âˆ€ (i : Î¹), (Min.min (f i) (Filter.principal (s i))).NeBot)","decl":"@[simp]\ntheorem pi_inf_principal_univ_pi_neBot :\n    NeBot (pi f âŠ“ ğ“Ÿ (Set.pi univ s)) â†” âˆ€ i, NeBot (f i âŠ“ ğ“Ÿ (s i)) := by simp [neBot_iff]\n\n"}
{"name":"Filter.pi_inf_principal_pi_neBot","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\ns : (i : Î¹) â†’ Set (Î± i)\ninstâœ : âˆ€ (i : Î¹), (f i).NeBot\nI : Set Î¹\nâŠ¢ Iff (Min.min (Filter.pi f) (Filter.principal (I.pi s))).NeBot (âˆ€ (i : Î¹), Membership.mem I i â†’ (Min.min (f i) (Filter.principal (s i))).NeBot)","decl":"@[simp]\ntheorem pi_inf_principal_pi_neBot [âˆ€ i, NeBot (f i)] {I : Set Î¹} :\n    NeBot (pi f âŠ“ ğ“Ÿ (I.pi s)) â†” âˆ€ i âˆˆ I, NeBot (f i âŠ“ ğ“Ÿ (s i)) := by simp [neBot_iff]\n\n"}
{"name":"Filter.PiInfPrincipalPi.neBot","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\ns : (i : Î¹) â†’ Set (Î± i)\nh : âˆ€ (i : Î¹), (Min.min (f i) (Filter.principal (s i))).NeBot\nI : Set Î¹\nâŠ¢ (Min.min (Filter.pi f) (Filter.principal (I.pi s))).NeBot","decl":"instance PiInfPrincipalPi.neBot [h : âˆ€ i, NeBot (f i âŠ“ ğ“Ÿ (s i))] {I : Set Î¹} :\n    NeBot (pi f âŠ“ ğ“Ÿ (I.pi s)) :=\n  (pi_inf_principal_univ_pi_neBot.2 â€¹_â€º).mono <|\n    inf_le_inf_left _ <| principal_mono.2 fun _ hx i _ => hx i trivial\n\n"}
{"name":"Filter.pi_eq_bot","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\nâŠ¢ Iff (Eq (Filter.pi f) Bot.bot) (Exists fun i => Eq (f i) Bot.bot)","decl":"@[simp]\ntheorem pi_eq_bot : pi f = âŠ¥ â†” âˆƒ i, f i = âŠ¥ := by\n  simpa using @pi_inf_principal_univ_pi_eq_bot Î¹ Î± f fun _ => univ\n\n"}
{"name":"Filter.pi_neBot","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\nâŠ¢ Iff (Filter.pi f).NeBot (âˆ€ (i : Î¹), (f i).NeBot)","decl":"@[simp]\ntheorem pi_neBot : NeBot (pi f) â†” âˆ€ i, NeBot (f i) := by simp [neBot_iff]\n\n"}
{"name":"Filter.instNeBotForallPi","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\ninstâœ : âˆ€ (i : Î¹), (f i).NeBot\nâŠ¢ (Filter.pi f).NeBot","decl":"instance [âˆ€ i, NeBot (f i)] : NeBot (pi f) :=\n  pi_neBot.2 â€¹_â€º\n\n"}
{"name":"Filter.map_eval_pi","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\ninstâœ : âˆ€ (i : Î¹), (f i).NeBot\ni : Î¹\nâŠ¢ Eq (Filter.map (Function.eval i) (Filter.pi f)) (f i)","decl":"@[simp]\ntheorem map_eval_pi (f : âˆ€ i, Filter (Î± i)) [âˆ€ i, NeBot (f i)] (i : Î¹) :\n    map (eval i) (pi f) = f i := by\n  refine le_antisymm (tendsto_eval_pi f i) fun s hs => ?_\n  rcases mem_pi.1 (mem_map.1 hs) with âŸ¨I, hIf, t, htf, hIâŸ©\n  rw [â† image_subset_iff] at hI\n  refine mem_of_superset (htf i) ((subset_eval_image_pi ?_ _).trans hI)\n  exact nonempty_of_mem (pi_mem_pi hIf fun i _ => htf i)\n\n"}
{"name":"Filter.pi_le_pi","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nfâ‚ fâ‚‚ : (i : Î¹) â†’ Filter (Î± i)\ninstâœ : âˆ€ (i : Î¹), (fâ‚ i).NeBot\nâŠ¢ Iff (LE.le (Filter.pi fâ‚) (Filter.pi fâ‚‚)) (âˆ€ (i : Î¹), LE.le (fâ‚ i) (fâ‚‚ i))","decl":"@[simp]\ntheorem pi_le_pi [âˆ€ i, NeBot (fâ‚ i)] : pi fâ‚ â‰¤ pi fâ‚‚ â†” âˆ€ i, fâ‚ i â‰¤ fâ‚‚ i :=\n  âŸ¨fun h i => map_eval_pi fâ‚ i â–¸ (tendsto_eval_pi _ _).mono_left h, pi_monoâŸ©\n\n"}
{"name":"Filter.pi_inj","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nfâ‚ fâ‚‚ : (i : Î¹) â†’ Filter (Î± i)\ninstâœ : âˆ€ (i : Î¹), (fâ‚ i).NeBot\nâŠ¢ Iff (Eq (Filter.pi fâ‚) (Filter.pi fâ‚‚)) (Eq fâ‚ fâ‚‚)","decl":"@[simp]\ntheorem pi_inj [âˆ€ i, NeBot (fâ‚ i)] : pi fâ‚ = pi fâ‚‚ â†” fâ‚ = fâ‚‚ := by\n  refine âŸ¨fun h => ?_, congr_arg piâŸ©\n  have hle : fâ‚ â‰¤ fâ‚‚ := pi_le_pi.1 h.le\n  haveI : âˆ€ i, NeBot (fâ‚‚ i) := fun i => neBot_of_le (hle i)\n  exact hle.antisymm (pi_le_pi.1 h.ge)\n\n"}
{"name":"Filter.tendsto_piMap_pi","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nÎ² : Î¹ â†’ Type u_3\nf : (i : Î¹) â†’ Î± i â†’ Î² i\nl : (i : Î¹) â†’ Filter (Î± i)\nl' : (i : Î¹) â†’ Filter (Î² i)\nh : âˆ€ (i : Î¹), Filter.Tendsto (f i) (l i) (l' i)\nâŠ¢ Filter.Tendsto (Pi.map f) (Filter.pi l) (Filter.pi l')","decl":"theorem tendsto_piMap_pi {Î² : Î¹ â†’ Type*} {f : âˆ€ i, Î± i â†’ Î² i} {l : âˆ€ i, Filter (Î± i)}\n    {l' : âˆ€ i, Filter (Î² i)} (h : âˆ€ i, Tendsto (f i) (l i) (l' i)) :\n    Tendsto (Pi.map f) (pi l) (pi l') :=\n  tendsto_pi.2 fun i â†¦ (h i).comp (tendsto_eval_pi _ _)\n\n"}
{"name":"Filter.mem_coprodáµ¢_iff","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\ns : Set ((i : Î¹) â†’ Î± i)\nâŠ¢ Iff (Membership.mem (Filter.coprodáµ¢ f) s) (âˆ€ (i : Î¹), Exists fun tâ‚ => And (Membership.mem (f i) tâ‚) (HasSubset.Subset (Set.preimage (Function.eval i) tâ‚) s))","decl":"theorem mem_coprodáµ¢_iff {s : Set (âˆ€ i, Î± i)} :\n    s âˆˆ Filter.coprodáµ¢ f â†” âˆ€ i : Î¹, âˆƒ tâ‚ âˆˆ f i, eval i â»Â¹' tâ‚ âŠ† s := by simp [Filter.coprodáµ¢]\n\n"}
{"name":"Filter.compl_mem_coprodáµ¢","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\ns : Set ((i : Î¹) â†’ Î± i)\nâŠ¢ Iff (Membership.mem (Filter.coprodáµ¢ f) (HasCompl.compl s)) (âˆ€ (i : Î¹), Membership.mem (f i) (HasCompl.compl (Set.image (Function.eval i) s)))","decl":"theorem compl_mem_coprodáµ¢ {s : Set (âˆ€ i, Î± i)} :\n    sá¶œ âˆˆ Filter.coprodáµ¢ f â†” âˆ€ i, (eval i '' s)á¶œ âˆˆ f i := by\n  simp only [Filter.coprodáµ¢, mem_iSup, compl_mem_comap]\n\n"}
{"name":"Filter.coprodáµ¢_neBot_iff'","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\nâŠ¢ Iff (Filter.coprodáµ¢ f).NeBot (And (âˆ€ (i : Î¹), Nonempty (Î± i)) (Exists fun d => (f d).NeBot))","decl":"theorem coprodáµ¢_neBot_iff' :\n    NeBot (Filter.coprodáµ¢ f) â†” (âˆ€ i, Nonempty (Î± i)) âˆ§ âˆƒ d, NeBot (f d) := by\n  simp only [Filter.coprodáµ¢, iSup_neBot, â† exists_and_left, â† comap_eval_neBot_iff']\n\n"}
{"name":"Filter.coprodáµ¢_neBot_iff","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\ninstâœ : âˆ€ (i : Î¹), Nonempty (Î± i)\nâŠ¢ Iff (Filter.coprodáµ¢ f).NeBot (Exists fun d => (f d).NeBot)","decl":"@[simp]\ntheorem coprodáµ¢_neBot_iff [âˆ€ i, Nonempty (Î± i)] : NeBot (Filter.coprodáµ¢ f) â†” âˆƒ d, NeBot (f d) := by\n  simp [coprodáµ¢_neBot_iff', *]\n\n"}
{"name":"Filter.coprodáµ¢_eq_bot_iff'","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\nâŠ¢ Iff (Eq (Filter.coprodáµ¢ f) Bot.bot) (Or (Exists fun i => IsEmpty (Î± i)) (Eq f Bot.bot))","decl":"theorem coprodáµ¢_eq_bot_iff' : Filter.coprodáµ¢ f = âŠ¥ â†” (âˆƒ i, IsEmpty (Î± i)) âˆ¨ f = âŠ¥ := by\n  simpa only [not_neBot, not_and_or, funext_iff, not_forall, not_exists, not_nonempty_iff]\n    using coprodáµ¢_neBot_iff'.not\n\n"}
{"name":"Filter.coprodáµ¢_eq_bot_iff","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\ninstâœ : âˆ€ (i : Î¹), Nonempty (Î± i)\nâŠ¢ Iff (Eq (Filter.coprodáµ¢ f) Bot.bot) (Eq f Bot.bot)","decl":"@[simp]\ntheorem coprodáµ¢_eq_bot_iff [âˆ€ i, Nonempty (Î± i)] : Filter.coprodáµ¢ f = âŠ¥ â†” f = âŠ¥ := by\n  simpa [funext_iff] using coprodáµ¢_neBot_iff.not\n\n"}
{"name":"Filter.coprodáµ¢_bot'","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nâŠ¢ Eq (Filter.coprodáµ¢ Bot.bot) Bot.bot","decl":"@[simp] theorem coprodáµ¢_bot' : Filter.coprodáµ¢ (âŠ¥ : âˆ€ i, Filter (Î± i)) = âŠ¥ :=\n  coprodáµ¢_eq_bot_iff'.2 (Or.inr rfl)\n\n"}
{"name":"Filter.coprodáµ¢_bot","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nâŠ¢ Eq (Filter.coprodáµ¢ fun x => Bot.bot) Bot.bot","decl":"@[simp]\ntheorem coprodáµ¢_bot : Filter.coprodáµ¢ (fun _ => âŠ¥ : âˆ€ i, Filter (Î± i)) = âŠ¥ :=\n  coprodáµ¢_bot'\n\n"}
{"name":"Filter.NeBot.coprodáµ¢","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\ninstâœ : âˆ€ (i : Î¹), Nonempty (Î± i)\ni : Î¹\nh : (f i).NeBot\nâŠ¢ (Filter.coprodáµ¢ f).NeBot","decl":"theorem NeBot.coprodáµ¢ [âˆ€ i, Nonempty (Î± i)] {i : Î¹} (h : NeBot (f i)) : NeBot (Filter.coprodáµ¢ f) :=\n  coprodáµ¢_neBot_iff.2 âŸ¨i, hâŸ©\n\n"}
{"name":"Filter.coprodáµ¢_neBot","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\ninstâœÂ¹ : âˆ€ (i : Î¹), Nonempty (Î± i)\ninstâœ : Nonempty Î¹\nf : (i : Î¹) â†’ Filter (Î± i)\nH : âˆ€ (i : Î¹), (f i).NeBot\nâŠ¢ (Filter.coprodáµ¢ f).NeBot","decl":"@[instance]\ntheorem coprodáµ¢_neBot [âˆ€ i, Nonempty (Î± i)] [Nonempty Î¹] (f : âˆ€ i, Filter (Î± i))\n    [H : âˆ€ i, NeBot (f i)] : NeBot (Filter.coprodáµ¢ f) :=\n  (H (Classical.arbitrary Î¹)).coprodáµ¢\n\n"}
{"name":"Filter.coprodáµ¢_mono","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nfâ‚ fâ‚‚ : (i : Î¹) â†’ Filter (Î± i)\nhf : âˆ€ (i : Î¹), LE.le (fâ‚ i) (fâ‚‚ i)\nâŠ¢ LE.le (Filter.coprodáµ¢ fâ‚) (Filter.coprodáµ¢ fâ‚‚)","decl":"@[mono]\ntheorem coprodáµ¢_mono (hf : âˆ€ i, fâ‚ i â‰¤ fâ‚‚ i) : Filter.coprodáµ¢ fâ‚ â‰¤ Filter.coprodáµ¢ fâ‚‚ :=\n  iSup_mono fun i => comap_mono (hf i)\n\n"}
{"name":"Filter.map_pi_map_coprodáµ¢_le","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\nÎ² : Î¹ â†’ Type u_3\nm : (i : Î¹) â†’ Î± i â†’ Î² i\nâŠ¢ LE.le (Filter.map (fun k i => m i (k i)) (Filter.coprodáµ¢ f)) (Filter.coprodáµ¢ fun i => Filter.map (m i) (f i))","decl":"theorem map_pi_map_coprodáµ¢_le :\n    map (fun k : âˆ€ i, Î± i => fun i => m i (k i)) (Filter.coprodáµ¢ f) â‰¤\n      Filter.coprodáµ¢ fun i => map (m i) (f i) := by\n  simp only [le_def, mem_map, mem_coprodáµ¢_iff]\n  intro s h i\n  obtain âŸ¨t, H, hHâŸ© := h i\n  exact âŸ¨{ x : Î± i | m i x âˆˆ t }, H, fun x hx => hH hxâŸ©\n\n"}
{"name":"Filter.Tendsto.pi_map_coprodáµ¢","module":"Mathlib.Order.Filter.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf : (i : Î¹) â†’ Filter (Î± i)\nÎ² : Î¹ â†’ Type u_3\nm : (i : Î¹) â†’ Î± i â†’ Î² i\ng : (i : Î¹) â†’ Filter (Î² i)\nh : âˆ€ (i : Î¹), Filter.Tendsto (m i) (f i) (g i)\nâŠ¢ Filter.Tendsto (fun k i => m i (k i)) (Filter.coprodáµ¢ f) (Filter.coprodáµ¢ g)","decl":"theorem Tendsto.pi_map_coprodáµ¢ {g : âˆ€ i, Filter (Î² i)} (h : âˆ€ i, Tendsto (m i) (f i) (g i)) :\n    Tendsto (fun k : âˆ€ i, Î± i => fun i => m i (k i)) (Filter.coprodáµ¢ f) (Filter.coprodáµ¢ g) :=\n  map_pi_map_coprodáµ¢_le.trans (coprodáµ¢_mono h)\n\n"}
