{"name":"Filter.tendsto_eval_pi","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\ni : ι\n⊢ Filter.Tendsto (Function.eval i) (Filter.pi f) (f i)","decl":"theorem tendsto_eval_pi (f : ∀ i, Filter (α i)) (i : ι) : Tendsto (eval i) (pi f) (f i) :=\n  tendsto_iInf' i tendsto_comap\n\n"}
{"name":"Filter.tendsto_pi","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\nβ : Type u_3\nm : β → (i : ι) → α i\nl : Filter β\n⊢ Iff (Filter.Tendsto m l (Filter.pi f)) (∀ (i : ι), Filter.Tendsto (fun x => m x i) l (f i))","decl":"theorem tendsto_pi {β : Type*} {m : β → ∀ i, α i} {l : Filter β} :\n    Tendsto m l (pi f) ↔ ∀ i, Tendsto (fun x => m x i) l (f i) := by\n  simp only [pi, tendsto_iInf, tendsto_comap_iff]; rfl\n\n"}
{"name":"Filter.Tendsto.apply","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\nβ : Type u_3\nm : β → (i : ι) → α i\nl : Filter β\na✝ : Filter.Tendsto m l (Filter.pi f)\ni : ι\n⊢ Filter.Tendsto (fun x => m x i) l (f i)","decl":"/-- If a function tends to a product `Filter.pi f` of filters, then its `i`-th component tends to\n`f i`. See also `Filter.Tendsto.apply_nhds` for the special case of converging to a point in a\nproduct of topological spaces. -/\nalias ⟨Tendsto.apply, _⟩ := tendsto_pi\n\n"}
{"name":"Filter.le_pi","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\ng : Filter ((i : ι) → α i)\n⊢ Iff (LE.le g (Filter.pi f)) (∀ (i : ι), Filter.Tendsto (Function.eval i) g (f i))","decl":"theorem le_pi {g : Filter (∀ i, α i)} : g ≤ pi f ↔ ∀ i, Tendsto (eval i) g (f i) :=\n  tendsto_pi\n\n"}
{"name":"Filter.pi_mono","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf₁ f₂ : (i : ι) → Filter (α i)\nh : ∀ (i : ι), LE.le (f₁ i) (f₂ i)\n⊢ LE.le (Filter.pi f₁) (Filter.pi f₂)","decl":"@[mono]\ntheorem pi_mono (h : ∀ i, f₁ i ≤ f₂ i) : pi f₁ ≤ pi f₂ :=\n  iInf_mono fun i => comap_mono <| h i\n\n"}
{"name":"Filter.mem_pi_of_mem","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\ni : ι\ns : Set (α i)\nhs : Membership.mem (f i) s\n⊢ Membership.mem (Filter.pi f) (Set.preimage (Function.eval i) s)","decl":"theorem mem_pi_of_mem (i : ι) {s : Set (α i)} (hs : s ∈ f i) : eval i ⁻¹' s ∈ pi f :=\n  mem_iInf_of_mem i <| preimage_mem_comap hs\n\n"}
{"name":"Filter.pi_mem_pi","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\ns : (i : ι) → Set (α i)\nI : Set ι\nhI : I.Finite\nh : ∀ (i : ι), Membership.mem I i → Membership.mem (f i) (s i)\n⊢ Membership.mem (Filter.pi f) (I.pi s)","decl":"theorem pi_mem_pi {I : Set ι} (hI : I.Finite) (h : ∀ i ∈ I, s i ∈ f i) : I.pi s ∈ pi f := by\n  rw [pi_def, biInter_eq_iInter]\n  refine mem_iInf_of_iInter hI (fun i => ?_) Subset.rfl\n  exact preimage_mem_comap (h i i.2)\n\n"}
{"name":"Filter.mem_pi","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\ns : Set ((i : ι) → α i)\n⊢ Iff (Membership.mem (Filter.pi f) s) (Exists fun I => And I.Finite (Exists fun t => And (∀ (i : ι), Membership.mem (f i) (t i)) (HasSubset.Subset (I.pi t) s)))","decl":"theorem mem_pi {s : Set (∀ i, α i)} :\n    s ∈ pi f ↔ ∃ I : Set ι, I.Finite ∧ ∃ t : ∀ i, Set (α i), (∀ i, t i ∈ f i) ∧ I.pi t ⊆ s := by\n  constructor\n  · simp only [pi, mem_iInf', mem_comap, pi_def]\n    rintro ⟨I, If, V, hVf, -, rfl, -⟩\n    choose t htf htV using hVf\n    exact ⟨I, If, t, htf, iInter₂_mono fun i _ => htV i⟩\n  · rintro ⟨I, If, t, htf, hts⟩\n    exact mem_of_superset (pi_mem_pi If fun i _ => htf i) hts\n\n"}
{"name":"Filter.mem_pi'","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\ns : Set ((i : ι) → α i)\n⊢ Iff (Membership.mem (Filter.pi f) s) (Exists fun I => Exists fun t => And (∀ (i : ι), Membership.mem (f i) (t i)) (HasSubset.Subset ((↑I).pi t) s))","decl":"theorem mem_pi' {s : Set (∀ i, α i)} :\n    s ∈ pi f ↔ ∃ I : Finset ι, ∃ t : ∀ i, Set (α i), (∀ i, t i ∈ f i) ∧ Set.pi (↑I) t ⊆ s :=\n  mem_pi.trans exists_finite_iff_finset\n\n"}
{"name":"Filter.mem_of_pi_mem_pi","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\ns : (i : ι) → Set (α i)\ninst✝ : ∀ (i : ι), (f i).NeBot\nI : Set ι\nh : Membership.mem (Filter.pi f) (I.pi s)\ni : ι\nhi : Membership.mem I i\n⊢ Membership.mem (f i) (s i)","decl":"theorem mem_of_pi_mem_pi [∀ i, NeBot (f i)] {I : Set ι} (h : I.pi s ∈ pi f) {i : ι} (hi : i ∈ I) :\n    s i ∈ f i := by\n  classical\n  rcases mem_pi.1 h with ⟨I', -, t, htf, hts⟩\n  refine mem_of_superset (htf i) fun x hx => ?_\n  have : ∀ i, (t i).Nonempty := fun i => nonempty_of_mem (htf i)\n  choose g hg using this\n  have : update g i x ∈ I'.pi t := fun j _ => by\n    rcases eq_or_ne j i with (rfl | hne) <;> simp [*]\n  simpa using hts this i hi\n\n"}
{"name":"Filter.pi_mem_pi_iff","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\ns : (i : ι) → Set (α i)\ninst✝ : ∀ (i : ι), (f i).NeBot\nI : Set ι\nhI : I.Finite\n⊢ Iff (Membership.mem (Filter.pi f) (I.pi s)) (∀ (i : ι), Membership.mem I i → Membership.mem (f i) (s i))","decl":"@[simp]\ntheorem pi_mem_pi_iff [∀ i, NeBot (f i)] {I : Set ι} (hI : I.Finite) :\n    I.pi s ∈ pi f ↔ ∀ i ∈ I, s i ∈ f i :=\n  ⟨fun h _i hi => mem_of_pi_mem_pi h hi, pi_mem_pi hI⟩\n\n"}
{"name":"Filter.Eventually.eval_pi","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\np : (i : ι) → α i → Prop\ni : ι\nhf : Filter.Eventually (fun x => p i x) (f i)\n⊢ Filter.Eventually (fun x => p i (x i)) (Filter.pi f)","decl":"theorem Eventually.eval_pi {i : ι} (hf : ∀ᶠ x : α i in f i, p i x) :\n    ∀ᶠ x : ∀ i : ι, α i in pi f, p i (x i) := (tendsto_eval_pi _ _).eventually hf\n\n"}
{"name":"Filter.eventually_pi","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\np : (i : ι) → α i → Prop\ninst✝ : Finite ι\nhf : ∀ (i : ι), Filter.Eventually (fun x => p i x) (f i)\n⊢ Filter.Eventually (fun x => ∀ (i : ι), p i (x i)) (Filter.pi f)","decl":"theorem eventually_pi [Finite ι] (hf : ∀ i, ∀ᶠ x in f i, p i x) :\n    ∀ᶠ x : ∀ i, α i in pi f, ∀ i, p i (x i) := eventually_all.2 fun _i => (hf _).eval_pi\n\n"}
{"name":"Filter.hasBasis_pi","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\nι' : ι → Type u_3\ns : (i : ι) → ι' i → Set (α i)\np : (i : ι) → ι' i → Prop\nh : ∀ (i : ι), (f i).HasBasis (p i) (s i)\n⊢ (Filter.pi f).HasBasis (fun If => And If.1.Finite (∀ (i : ι), Membership.mem If.1 i → p i (If.2 i))) fun If => If.1.pi fun i => s i (If.2 i)","decl":"theorem hasBasis_pi {ι' : ι → Type*} {s : ∀ i, ι' i → Set (α i)} {p : ∀ i, ι' i → Prop}\n    (h : ∀ i, (f i).HasBasis (p i) (s i)) :\n    (pi f).HasBasis (fun If : Set ι × ∀ i, ι' i => If.1.Finite ∧ ∀ i ∈ If.1, p i (If.2 i))\n      fun If : Set ι × ∀ i, ι' i => If.1.pi fun i => s i <| If.2 i := by\n  simpa [Set.pi_def] using hasBasis_iInf' fun i => (h i).comap (eval i : (∀ j, α j) → α i)\n\n"}
{"name":"Filter.le_pi_principal","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : (i : ι) → Set (α i)\n⊢ LE.le (Filter.principal (Set.univ.pi s)) (Filter.pi fun i => Filter.principal (s i))","decl":"theorem le_pi_principal (s : (i : ι) → Set (α i)) :\n    𝓟 (univ.pi s) ≤ pi fun i ↦ 𝓟 (s i) :=\n  le_pi.2 fun i ↦ tendsto_principal_principal.2 fun _f hf ↦ hf i trivial\n\n"}
{"name":"Filter.pi_principal","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : Finite ι\ns : (i : ι) → Set (α i)\n⊢ Eq (Filter.pi fun i => Filter.principal (s i)) (Filter.principal (Set.univ.pi s))","decl":"@[simp]\ntheorem pi_principal [Finite ι] (s : (i : ι) → Set (α i)) :\n    pi (fun i ↦ 𝓟 (s i)) = 𝓟 (univ.pi s) := by\n  simp [Filter.pi, Set.pi_def]\n\n"}
{"name":"Filter.pi_pure","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : Finite ι\nf : (i : ι) → α i\n⊢ Eq (Filter.pi fun x => Pure.pure (f x)) (Pure.pure f)","decl":"@[simp]\ntheorem pi_pure [Finite ι] (f : (i : ι) → α i) : pi (pure <| f ·) = pure f := by\n  simp only [← principal_singleton, pi_principal, univ_pi_singleton]\n\n"}
{"name":"Filter.pi_inf_principal_univ_pi_eq_bot","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\ns : (i : ι) → Set (α i)\n⊢ Iff (Eq (Min.min (Filter.pi f) (Filter.principal (Set.univ.pi s))) Bot.bot) (Exists fun i => Eq (Min.min (f i) (Filter.principal (s i))) Bot.bot)","decl":"@[simp]\ntheorem pi_inf_principal_univ_pi_eq_bot :\n    pi f ⊓ 𝓟 (Set.pi univ s) = ⊥ ↔ ∃ i, f i ⊓ 𝓟 (s i) = ⊥ := by\n  constructor\n  · simp only [inf_principal_eq_bot, mem_pi]\n    contrapose!\n    rintro (hsf : ∀ i, ∃ᶠ x in f i, x ∈ s i) I - t htf hts\n    have : ∀ i, (s i ∩ t i).Nonempty := fun i => ((hsf i).and_eventually (htf i)).exists\n    choose x hxs hxt using this\n    exact hts (fun i _ => hxt i) (mem_univ_pi.2 hxs)\n  · simp only [inf_principal_eq_bot]\n    rintro ⟨i, hi⟩\n    filter_upwards [mem_pi_of_mem i hi] with x using mt fun h => h i trivial\n\n"}
{"name":"Filter.pi_inf_principal_pi_eq_bot","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\ns : (i : ι) → Set (α i)\ninst✝ : ∀ (i : ι), (f i).NeBot\nI : Set ι\n⊢ Iff (Eq (Min.min (Filter.pi f) (Filter.principal (I.pi s))) Bot.bot) (Exists fun i => And (Membership.mem I i) (Eq (Min.min (f i) (Filter.principal (s i))) Bot.bot))","decl":"@[simp]\ntheorem pi_inf_principal_pi_eq_bot [∀ i, NeBot (f i)] {I : Set ι} :\n    pi f ⊓ 𝓟 (Set.pi I s) = ⊥ ↔ ∃ i ∈ I, f i ⊓ 𝓟 (s i) = ⊥ := by\n  classical\n  rw [← univ_pi_piecewise_univ I, pi_inf_principal_univ_pi_eq_bot]\n  refine exists_congr fun i => ?_\n  by_cases hi : i ∈ I <;> simp [hi, NeBot.ne']\n\n"}
{"name":"Filter.pi_inf_principal_univ_pi_neBot","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\ns : (i : ι) → Set (α i)\n⊢ Iff (Min.min (Filter.pi f) (Filter.principal (Set.univ.pi s))).NeBot (∀ (i : ι), (Min.min (f i) (Filter.principal (s i))).NeBot)","decl":"@[simp]\ntheorem pi_inf_principal_univ_pi_neBot :\n    NeBot (pi f ⊓ 𝓟 (Set.pi univ s)) ↔ ∀ i, NeBot (f i ⊓ 𝓟 (s i)) := by simp [neBot_iff]\n\n"}
{"name":"Filter.pi_inf_principal_pi_neBot","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\ns : (i : ι) → Set (α i)\ninst✝ : ∀ (i : ι), (f i).NeBot\nI : Set ι\n⊢ Iff (Min.min (Filter.pi f) (Filter.principal (I.pi s))).NeBot (∀ (i : ι), Membership.mem I i → (Min.min (f i) (Filter.principal (s i))).NeBot)","decl":"@[simp]\ntheorem pi_inf_principal_pi_neBot [∀ i, NeBot (f i)] {I : Set ι} :\n    NeBot (pi f ⊓ 𝓟 (I.pi s)) ↔ ∀ i ∈ I, NeBot (f i ⊓ 𝓟 (s i)) := by simp [neBot_iff]\n\n"}
{"name":"Filter.PiInfPrincipalPi.neBot","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\ns : (i : ι) → Set (α i)\nh : ∀ (i : ι), (Min.min (f i) (Filter.principal (s i))).NeBot\nI : Set ι\n⊢ (Min.min (Filter.pi f) (Filter.principal (I.pi s))).NeBot","decl":"instance PiInfPrincipalPi.neBot [h : ∀ i, NeBot (f i ⊓ 𝓟 (s i))] {I : Set ι} :\n    NeBot (pi f ⊓ 𝓟 (I.pi s)) :=\n  (pi_inf_principal_univ_pi_neBot.2 ‹_›).mono <|\n    inf_le_inf_left _ <| principal_mono.2 fun _ hx i _ => hx i trivial\n\n"}
{"name":"Filter.pi_eq_bot","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\n⊢ Iff (Eq (Filter.pi f) Bot.bot) (Exists fun i => Eq (f i) Bot.bot)","decl":"@[simp]\ntheorem pi_eq_bot : pi f = ⊥ ↔ ∃ i, f i = ⊥ := by\n  simpa using @pi_inf_principal_univ_pi_eq_bot ι α f fun _ => univ\n\n"}
{"name":"Filter.pi_neBot","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\n⊢ Iff (Filter.pi f).NeBot (∀ (i : ι), (f i).NeBot)","decl":"@[simp]\ntheorem pi_neBot : NeBot (pi f) ↔ ∀ i, NeBot (f i) := by simp [neBot_iff]\n\n"}
{"name":"Filter.instNeBotForallPi","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\ninst✝ : ∀ (i : ι), (f i).NeBot\n⊢ (Filter.pi f).NeBot","decl":"instance [∀ i, NeBot (f i)] : NeBot (pi f) :=\n  pi_neBot.2 ‹_›\n\n"}
{"name":"Filter.map_eval_pi","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\ninst✝ : ∀ (i : ι), (f i).NeBot\ni : ι\n⊢ Eq (Filter.map (Function.eval i) (Filter.pi f)) (f i)","decl":"@[simp]\ntheorem map_eval_pi (f : ∀ i, Filter (α i)) [∀ i, NeBot (f i)] (i : ι) :\n    map (eval i) (pi f) = f i := by\n  refine le_antisymm (tendsto_eval_pi f i) fun s hs => ?_\n  rcases mem_pi.1 (mem_map.1 hs) with ⟨I, hIf, t, htf, hI⟩\n  rw [← image_subset_iff] at hI\n  refine mem_of_superset (htf i) ((subset_eval_image_pi ?_ _).trans hI)\n  exact nonempty_of_mem (pi_mem_pi hIf fun i _ => htf i)\n\n"}
{"name":"Filter.pi_le_pi","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf₁ f₂ : (i : ι) → Filter (α i)\ninst✝ : ∀ (i : ι), (f₁ i).NeBot\n⊢ Iff (LE.le (Filter.pi f₁) (Filter.pi f₂)) (∀ (i : ι), LE.le (f₁ i) (f₂ i))","decl":"@[simp]\ntheorem pi_le_pi [∀ i, NeBot (f₁ i)] : pi f₁ ≤ pi f₂ ↔ ∀ i, f₁ i ≤ f₂ i :=\n  ⟨fun h i => map_eval_pi f₁ i ▸ (tendsto_eval_pi _ _).mono_left h, pi_mono⟩\n\n"}
{"name":"Filter.pi_inj","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf₁ f₂ : (i : ι) → Filter (α i)\ninst✝ : ∀ (i : ι), (f₁ i).NeBot\n⊢ Iff (Eq (Filter.pi f₁) (Filter.pi f₂)) (Eq f₁ f₂)","decl":"@[simp]\ntheorem pi_inj [∀ i, NeBot (f₁ i)] : pi f₁ = pi f₂ ↔ f₁ = f₂ := by\n  refine ⟨fun h => ?_, congr_arg pi⟩\n  have hle : f₁ ≤ f₂ := pi_le_pi.1 h.le\n  haveI : ∀ i, NeBot (f₂ i) := fun i => neBot_of_le (hle i)\n  exact hle.antisymm (pi_le_pi.1 h.ge)\n\n"}
{"name":"Filter.tendsto_piMap_pi","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : ι → Type u_3\nf : (i : ι) → α i → β i\nl : (i : ι) → Filter (α i)\nl' : (i : ι) → Filter (β i)\nh : ∀ (i : ι), Filter.Tendsto (f i) (l i) (l' i)\n⊢ Filter.Tendsto (Pi.map f) (Filter.pi l) (Filter.pi l')","decl":"theorem tendsto_piMap_pi {β : ι → Type*} {f : ∀ i, α i → β i} {l : ∀ i, Filter (α i)}\n    {l' : ∀ i, Filter (β i)} (h : ∀ i, Tendsto (f i) (l i) (l' i)) :\n    Tendsto (Pi.map f) (pi l) (pi l') :=\n  tendsto_pi.2 fun i ↦ (h i).comp (tendsto_eval_pi _ _)\n\n"}
{"name":"Filter.mem_coprodᵢ_iff","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\ns : Set ((i : ι) → α i)\n⊢ Iff (Membership.mem (Filter.coprodᵢ f) s) (∀ (i : ι), Exists fun t₁ => And (Membership.mem (f i) t₁) (HasSubset.Subset (Set.preimage (Function.eval i) t₁) s))","decl":"theorem mem_coprodᵢ_iff {s : Set (∀ i, α i)} :\n    s ∈ Filter.coprodᵢ f ↔ ∀ i : ι, ∃ t₁ ∈ f i, eval i ⁻¹' t₁ ⊆ s := by simp [Filter.coprodᵢ]\n\n"}
{"name":"Filter.compl_mem_coprodᵢ","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\ns : Set ((i : ι) → α i)\n⊢ Iff (Membership.mem (Filter.coprodᵢ f) (HasCompl.compl s)) (∀ (i : ι), Membership.mem (f i) (HasCompl.compl (Set.image (Function.eval i) s)))","decl":"theorem compl_mem_coprodᵢ {s : Set (∀ i, α i)} :\n    sᶜ ∈ Filter.coprodᵢ f ↔ ∀ i, (eval i '' s)ᶜ ∈ f i := by\n  simp only [Filter.coprodᵢ, mem_iSup, compl_mem_comap]\n\n"}
{"name":"Filter.coprodᵢ_neBot_iff'","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\n⊢ Iff (Filter.coprodᵢ f).NeBot (And (∀ (i : ι), Nonempty (α i)) (Exists fun d => (f d).NeBot))","decl":"theorem coprodᵢ_neBot_iff' :\n    NeBot (Filter.coprodᵢ f) ↔ (∀ i, Nonempty (α i)) ∧ ∃ d, NeBot (f d) := by\n  simp only [Filter.coprodᵢ, iSup_neBot, ← exists_and_left, ← comap_eval_neBot_iff']\n\n"}
{"name":"Filter.coprodᵢ_neBot_iff","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\ninst✝ : ∀ (i : ι), Nonempty (α i)\n⊢ Iff (Filter.coprodᵢ f).NeBot (Exists fun d => (f d).NeBot)","decl":"@[simp]\ntheorem coprodᵢ_neBot_iff [∀ i, Nonempty (α i)] : NeBot (Filter.coprodᵢ f) ↔ ∃ d, NeBot (f d) := by\n  simp [coprodᵢ_neBot_iff', *]\n\n"}
{"name":"Filter.coprodᵢ_eq_bot_iff'","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\n⊢ Iff (Eq (Filter.coprodᵢ f) Bot.bot) (Or (Exists fun i => IsEmpty (α i)) (Eq f Bot.bot))","decl":"theorem coprodᵢ_eq_bot_iff' : Filter.coprodᵢ f = ⊥ ↔ (∃ i, IsEmpty (α i)) ∨ f = ⊥ := by\n  simpa only [not_neBot, not_and_or, funext_iff, not_forall, not_exists, not_nonempty_iff]\n    using coprodᵢ_neBot_iff'.not\n\n"}
{"name":"Filter.coprodᵢ_eq_bot_iff","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\ninst✝ : ∀ (i : ι), Nonempty (α i)\n⊢ Iff (Eq (Filter.coprodᵢ f) Bot.bot) (Eq f Bot.bot)","decl":"@[simp]\ntheorem coprodᵢ_eq_bot_iff [∀ i, Nonempty (α i)] : Filter.coprodᵢ f = ⊥ ↔ f = ⊥ := by\n  simpa [funext_iff] using coprodᵢ_neBot_iff.not\n\n"}
{"name":"Filter.coprodᵢ_bot'","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\n⊢ Eq (Filter.coprodᵢ Bot.bot) Bot.bot","decl":"@[simp] theorem coprodᵢ_bot' : Filter.coprodᵢ (⊥ : ∀ i, Filter (α i)) = ⊥ :=\n  coprodᵢ_eq_bot_iff'.2 (Or.inr rfl)\n\n"}
{"name":"Filter.coprodᵢ_bot","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\n⊢ Eq (Filter.coprodᵢ fun x => Bot.bot) Bot.bot","decl":"@[simp]\ntheorem coprodᵢ_bot : Filter.coprodᵢ (fun _ => ⊥ : ∀ i, Filter (α i)) = ⊥ :=\n  coprodᵢ_bot'\n\n"}
{"name":"Filter.NeBot.coprodᵢ","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\ninst✝ : ∀ (i : ι), Nonempty (α i)\ni : ι\nh : (f i).NeBot\n⊢ (Filter.coprodᵢ f).NeBot","decl":"theorem NeBot.coprodᵢ [∀ i, Nonempty (α i)] {i : ι} (h : NeBot (f i)) : NeBot (Filter.coprodᵢ f) :=\n  coprodᵢ_neBot_iff.2 ⟨i, h⟩\n\n"}
{"name":"Filter.coprodᵢ_neBot","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : ∀ (i : ι), Nonempty (α i)\ninst✝ : Nonempty ι\nf : (i : ι) → Filter (α i)\nH : ∀ (i : ι), (f i).NeBot\n⊢ (Filter.coprodᵢ f).NeBot","decl":"@[instance]\ntheorem coprodᵢ_neBot [∀ i, Nonempty (α i)] [Nonempty ι] (f : ∀ i, Filter (α i))\n    [H : ∀ i, NeBot (f i)] : NeBot (Filter.coprodᵢ f) :=\n  (H (Classical.arbitrary ι)).coprodᵢ\n\n"}
{"name":"Filter.coprodᵢ_mono","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf₁ f₂ : (i : ι) → Filter (α i)\nhf : ∀ (i : ι), LE.le (f₁ i) (f₂ i)\n⊢ LE.le (Filter.coprodᵢ f₁) (Filter.coprodᵢ f₂)","decl":"@[mono]\ntheorem coprodᵢ_mono (hf : ∀ i, f₁ i ≤ f₂ i) : Filter.coprodᵢ f₁ ≤ Filter.coprodᵢ f₂ :=\n  iSup_mono fun i => comap_mono (hf i)\n\n"}
{"name":"Filter.map_pi_map_coprodᵢ_le","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\nβ : ι → Type u_3\nm : (i : ι) → α i → β i\n⊢ LE.le (Filter.map (fun k i => m i (k i)) (Filter.coprodᵢ f)) (Filter.coprodᵢ fun i => Filter.map (m i) (f i))","decl":"theorem map_pi_map_coprodᵢ_le :\n    map (fun k : ∀ i, α i => fun i => m i (k i)) (Filter.coprodᵢ f) ≤\n      Filter.coprodᵢ fun i => map (m i) (f i) := by\n  simp only [le_def, mem_map, mem_coprodᵢ_iff]\n  intro s h i\n  obtain ⟨t, H, hH⟩ := h i\n  exact ⟨{ x : α i | m i x ∈ t }, H, fun x hx => hH hx⟩\n\n"}
{"name":"Filter.Tendsto.pi_map_coprodᵢ","module":"Mathlib.Order.Filter.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → Filter (α i)\nβ : ι → Type u_3\nm : (i : ι) → α i → β i\ng : (i : ι) → Filter (β i)\nh : ∀ (i : ι), Filter.Tendsto (m i) (f i) (g i)\n⊢ Filter.Tendsto (fun k i => m i (k i)) (Filter.coprodᵢ f) (Filter.coprodᵢ g)","decl":"theorem Tendsto.pi_map_coprodᵢ {g : ∀ i, Filter (β i)} (h : ∀ i, Tendsto (m i) (f i) (g i)) :\n    Tendsto (fun k : ∀ i, α i => fun i => m i (k i)) (Filter.coprodᵢ f) (Filter.coprodᵢ g) :=\n  map_pi_map_coprodᵢ_le.trans (coprodᵢ_mono h)\n\n"}
