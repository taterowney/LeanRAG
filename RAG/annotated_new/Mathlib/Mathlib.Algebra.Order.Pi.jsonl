{"name":"Pi.existsMulOfLe","module":"Mathlib.Algebra.Order.Pi","initialProofState":"ι : Type u_6\nα : ι → Type u_7\ninst✝² : (i : ι) → LE (α i)\ninst✝¹ : (i : ι) → Mul (α i)\ninst✝ : ∀ (i : ι), ExistsMulOfLE (α i)\n⊢ ExistsMulOfLE ((i : ι) → α i)","decl":"@[to_additive]\ninstance existsMulOfLe {ι : Type*} {α : ι → Type*} [∀ i, LE (α i)] [∀ i, Mul (α i)]\n    [∀ i, ExistsMulOfLE (α i)] : ExistsMulOfLE (∀ i, α i) :=\n  ⟨fun h =>\n    ⟨fun i => (exists_mul_of_le <| h i).choose,\n      funext fun i => (exists_mul_of_le <| h i).choose_spec⟩⟩\n\n"}
{"name":"Pi.existsAddOfLe","module":"Mathlib.Algebra.Order.Pi","initialProofState":"ι : Type u_6\nα : ι → Type u_7\ninst✝² : (i : ι) → LE (α i)\ninst✝¹ : (i : ι) → Add (α i)\ninst✝ : ∀ (i : ι), ExistsAddOfLE (α i)\n⊢ ExistsAddOfLE ((i : ι) → α i)","decl":"@[to_additive]\ninstance existsMulOfLe {ι : Type*} {α : ι → Type*} [∀ i, LE (α i)] [∀ i, Mul (α i)]\n    [∀ i, ExistsMulOfLE (α i)] : ExistsMulOfLE (∀ i, α i) :=\n  ⟨fun h =>\n    ⟨fun i => (exists_mul_of_le <| h i).choose,\n      funext fun i => (exists_mul_of_le <| h i).choose_spec⟩⟩\n\n"}
{"name":"Pi.instCanonicallyOrderedMulForall","module":"Mathlib.Algebra.Order.Pi","initialProofState":"ι : Type u_6\nZ : ι → Type u_7\ninst✝² : (i : ι) → Monoid (Z i)\ninst✝¹ : (i : ι) → PartialOrder (Z i)\ninst✝ : ∀ (i : ι), CanonicallyOrderedMul (Z i)\n⊢ CanonicallyOrderedMul ((i : ι) → Z i)","decl":"/-- The product of a family of canonically ordered monoids is a canonically ordered monoid. -/\n@[to_additive\n      \"The product of a family of canonically ordered additive monoids is\na canonically ordered additive monoid.\"]\ninstance {ι : Type*} {Z : ι → Type*} [∀ i, Monoid (Z i)] [∀ i, PartialOrder (Z i)]\n    [∀ i, CanonicallyOrderedMul (Z i)] :\n    CanonicallyOrderedMul (∀ i, Z i) where\n  __ := Pi.existsMulOfLe\n  le_self_mul _ _ := fun _ => le_self_mul\n\n"}
{"name":"Pi.instCanonicallyOrderedAddForall","module":"Mathlib.Algebra.Order.Pi","initialProofState":"ι : Type u_6\nZ : ι → Type u_7\ninst✝² : (i : ι) → AddMonoid (Z i)\ninst✝¹ : (i : ι) → PartialOrder (Z i)\ninst✝ : ∀ (i : ι), CanonicallyOrderedAdd (Z i)\n⊢ CanonicallyOrderedAdd ((i : ι) → Z i)","decl":"/-- The product of a family of canonically ordered monoids is a canonically ordered monoid. -/\n@[to_additive\n      \"The product of a family of canonically ordered additive monoids is\na canonically ordered additive monoid.\"]\ninstance {ι : Type*} {Z : ι → Type*} [∀ i, Monoid (Z i)] [∀ i, PartialOrder (Z i)]\n    [∀ i, CanonicallyOrderedMul (Z i)] :\n    CanonicallyOrderedMul (∀ i, Z i) where\n  __ := Pi.existsMulOfLe\n  le_self_mul _ _ := fun _ => le_self_mul\n\n"}
{"name":"Function.one_le_const_of_one_le","module":"Mathlib.Algebra.Order.Pi","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : One α\ninst✝ : Preorder α\na : α\nha : LE.le 1 a\n⊢ LE.le 1 (Function.const β a)","decl":"@[to_additive const_nonneg_of_nonneg]\ntheorem one_le_const_of_one_le (ha : 1 ≤ a) : 1 ≤ const β a := fun _ => ha\n\n"}
{"name":"Function.const_nonneg_of_nonneg","module":"Mathlib.Algebra.Order.Pi","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Zero α\ninst✝ : Preorder α\na : α\nha : LE.le 0 a\n⊢ LE.le 0 (Function.const β a)","decl":"@[to_additive const_nonneg_of_nonneg]\ntheorem one_le_const_of_one_le (ha : 1 ≤ a) : 1 ≤ const β a := fun _ => ha\n\n"}
{"name":"Function.const_le_one_of_le_one","module":"Mathlib.Algebra.Order.Pi","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : One α\ninst✝ : Preorder α\na : α\nha : LE.le a 1\n⊢ LE.le (Function.const β a) 1","decl":"@[to_additive]\ntheorem const_le_one_of_le_one (ha : a ≤ 1) : const β a ≤ 1 := fun _ => ha\n\n"}
{"name":"Function.const_nonpos_of_nonpos","module":"Mathlib.Algebra.Order.Pi","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Zero α\ninst✝ : Preorder α\na : α\nha : LE.le a 0\n⊢ LE.le (Function.const β a) 0","decl":"@[to_additive]\ntheorem const_le_one_of_le_one (ha : a ≤ 1) : const β a ≤ 1 := fun _ => ha\n\n"}
{"name":"Function.const_nonneg","module":"Mathlib.Algebra.Order.Pi","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Zero α\ninst✝¹ : Preorder α\na : α\ninst✝ : Nonempty β\n⊢ Iff (LE.le 0 (Function.const β a)) (LE.le 0 a)","decl":"@[to_additive (attr := simp) const_nonneg]\ntheorem one_le_const : 1 ≤ const β a ↔ 1 ≤ a :=\n  const_le_const\n\n"}
{"name":"Function.one_le_const","module":"Mathlib.Algebra.Order.Pi","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : One α\ninst✝¹ : Preorder α\na : α\ninst✝ : Nonempty β\n⊢ Iff (LE.le 1 (Function.const β a)) (LE.le 1 a)","decl":"@[to_additive (attr := simp) const_nonneg]\ntheorem one_le_const : 1 ≤ const β a ↔ 1 ≤ a :=\n  const_le_const\n\n"}
{"name":"Function.const_pos","module":"Mathlib.Algebra.Order.Pi","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Zero α\ninst✝¹ : Preorder α\na : α\ninst✝ : Nonempty β\n⊢ Iff (LT.lt 0 (Function.const β a)) (LT.lt 0 a)","decl":"@[to_additive (attr := simp) const_pos]\ntheorem one_lt_const : 1 < const β a ↔ 1 < a :=\n  const_lt_const\n\n"}
{"name":"Function.one_lt_const","module":"Mathlib.Algebra.Order.Pi","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : One α\ninst✝¹ : Preorder α\na : α\ninst✝ : Nonempty β\n⊢ Iff (LT.lt 1 (Function.const β a)) (LT.lt 1 a)","decl":"@[to_additive (attr := simp) const_pos]\ntheorem one_lt_const : 1 < const β a ↔ 1 < a :=\n  const_lt_const\n\n"}
{"name":"Function.const_nonpos","module":"Mathlib.Algebra.Order.Pi","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Zero α\ninst✝¹ : Preorder α\na : α\ninst✝ : Nonempty β\n⊢ Iff (LE.le (Function.const β a) 0) (LE.le a 0)","decl":"@[to_additive (attr := simp)]\ntheorem const_le_one : const β a ≤ 1 ↔ a ≤ 1 :=\n  const_le_const\n\n"}
{"name":"Function.const_le_one","module":"Mathlib.Algebra.Order.Pi","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : One α\ninst✝¹ : Preorder α\na : α\ninst✝ : Nonempty β\n⊢ Iff (LE.le (Function.const β a) 1) (LE.le a 1)","decl":"@[to_additive (attr := simp)]\ntheorem const_le_one : const β a ≤ 1 ↔ a ≤ 1 :=\n  const_le_const\n\n"}
{"name":"Function.const_lt_one","module":"Mathlib.Algebra.Order.Pi","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : One α\ninst✝¹ : Preorder α\na : α\ninst✝ : Nonempty β\n⊢ Iff (LT.lt (Function.const β a) 1) (LT.lt a 1)","decl":"@[to_additive (attr := simp) const_neg']\ntheorem const_lt_one : const β a < 1 ↔ a < 1 :=\n  const_lt_const\n\n"}
{"name":"Function.const_neg'","module":"Mathlib.Algebra.Order.Pi","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Zero α\ninst✝¹ : Preorder α\na : α\ninst✝ : Nonempty β\n⊢ Iff (LT.lt (Function.const β a) 0) (LT.lt a 0)","decl":"@[to_additive (attr := simp) const_neg']\ntheorem const_lt_one : const β a < 1 ↔ a < 1 :=\n  const_lt_const\n\n"}
{"name":"Function.one_le_extend","module":"Mathlib.Algebra.Order.Pi","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : One γ\ninst✝ : LE γ\nf : α → β\ng : α → γ\ne : β → γ\nhg : LE.le 1 g\nhe : LE.le 1 e\n⊢ LE.le 1 (Function.extend f g e)","decl":"@[to_additive extend_nonneg] lemma one_le_extend (hg : 1 ≤ g) (he : 1 ≤ e) : 1 ≤ extend f g e :=\n  fun _b ↦ by classical exact one_le_dite (fun _ ↦ hg _) (fun _ ↦ he _)\n\n"}
{"name":"Function.extend_nonneg","module":"Mathlib.Algebra.Order.Pi","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : Zero γ\ninst✝ : LE γ\nf : α → β\ng : α → γ\ne : β → γ\nhg : LE.le 0 g\nhe : LE.le 0 e\n⊢ LE.le 0 (Function.extend f g e)","decl":"@[to_additive extend_nonneg] lemma one_le_extend (hg : 1 ≤ g) (he : 1 ≤ e) : 1 ≤ extend f g e :=\n  fun _b ↦ by classical exact one_le_dite (fun _ ↦ hg _) (fun _ ↦ he _)\n\n"}
{"name":"Function.extend_nonpos","module":"Mathlib.Algebra.Order.Pi","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : Zero γ\ninst✝ : LE γ\nf : α → β\ng : α → γ\ne : β → γ\nhg : LE.le g 0\nhe : LE.le e 0\n⊢ LE.le (Function.extend f g e) 0","decl":"@[to_additive] lemma extend_le_one (hg : g ≤ 1) (he : e ≤ 1) : extend f g e ≤ 1 :=\n  fun _b ↦ by classical exact dite_le_one (fun _ ↦ hg _) (fun _ ↦ he _)\n\n"}
{"name":"Function.extend_le_one","module":"Mathlib.Algebra.Order.Pi","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : One γ\ninst✝ : LE γ\nf : α → β\ng : α → γ\ne : β → γ\nhg : LE.le g 1\nhe : LE.le e 1\n⊢ LE.le (Function.extend f g e) 1","decl":"@[to_additive] lemma extend_le_one (hg : g ≤ 1) (he : e ≤ 1) : extend f g e ≤ 1 :=\n  fun _b ↦ by classical exact dite_le_one (fun _ ↦ hg _) (fun _ ↦ he _)\n\n"}
{"name":"Pi.mulSingle_le_mulSingle","module":"Mathlib.Algebra.Order.Pi","initialProofState":"ι : Type u_6\nα : ι → Type u_7\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → One (α i)\ninst✝ : (i : ι) → Preorder (α i)\ni : ι\na b : α i\n⊢ Iff (LE.le (Pi.mulSingle i a) (Pi.mulSingle i b)) (LE.le a b)","decl":"@[to_additive (attr := simp)]\nlemma mulSingle_le_mulSingle : mulSingle i a ≤ mulSingle i b ↔ a ≤ b := by\n  simp [mulSingle, update_le_update_iff]\n\n"}
{"name":"Pi.single_le_single","module":"Mathlib.Algebra.Order.Pi","initialProofState":"ι : Type u_6\nα : ι → Type u_7\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (α i)\ninst✝ : (i : ι) → Preorder (α i)\ni : ι\na b : α i\n⊢ Iff (LE.le (Pi.single i a) (Pi.single i b)) (LE.le a b)","decl":"@[to_additive (attr := simp)]\nlemma mulSingle_le_mulSingle : mulSingle i a ≤ mulSingle i b ↔ a ≤ b := by\n  simp [mulSingle, update_le_update_iff]\n\n"}
{"name":"Pi.GCongr.mulSingle_mono","module":"Mathlib.Algebra.Order.Pi","initialProofState":"ι : Type u_6\nα : ι → Type u_7\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → One (α i)\ninst✝ : (i : ι) → Preorder (α i)\ni : ι\na b : α i\na✝ : LE.le a b\n⊢ LE.le (Pi.mulSingle i a) (Pi.mulSingle i b)","decl":"@[to_additive (attr := gcongr)] alias ⟨_, GCongr.mulSingle_mono⟩ := mulSingle_le_mulSingle\n\n"}
{"name":"Pi.GCongr.single_mono","module":"Mathlib.Algebra.Order.Pi","initialProofState":"ι : Type u_6\nα : ι → Type u_7\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (α i)\ninst✝ : (i : ι) → Preorder (α i)\ni : ι\na b : α i\na✝ : LE.le a b\n⊢ LE.le (Pi.single i a) (Pi.single i b)","decl":"@[to_additive (attr := gcongr)] alias ⟨_, GCongr.mulSingle_mono⟩ := mulSingle_le_mulSingle\n\n"}
{"name":"Pi.single_nonneg","module":"Mathlib.Algebra.Order.Pi","initialProofState":"ι : Type u_6\nα : ι → Type u_7\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (α i)\ninst✝ : (i : ι) → Preorder (α i)\ni : ι\na : α i\n⊢ Iff (LE.le 0 (Pi.single i a)) (LE.le 0 a)","decl":"@[to_additive (attr := simp) single_nonneg]\nlemma one_le_mulSingle : 1 ≤ mulSingle i a ↔ 1 ≤ a := by simp [mulSingle]\n\n"}
{"name":"Pi.one_le_mulSingle","module":"Mathlib.Algebra.Order.Pi","initialProofState":"ι : Type u_6\nα : ι → Type u_7\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → One (α i)\ninst✝ : (i : ι) → Preorder (α i)\ni : ι\na : α i\n⊢ Iff (LE.le 1 (Pi.mulSingle i a)) (LE.le 1 a)","decl":"@[to_additive (attr := simp) single_nonneg]\nlemma one_le_mulSingle : 1 ≤ mulSingle i a ↔ 1 ≤ a := by simp [mulSingle]\n\n"}
{"name":"Pi.mulSingle_le_one","module":"Mathlib.Algebra.Order.Pi","initialProofState":"ι : Type u_6\nα : ι → Type u_7\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → One (α i)\ninst✝ : (i : ι) → Preorder (α i)\ni : ι\na : α i\n⊢ Iff (LE.le (Pi.mulSingle i a) 1) (LE.le a 1)","decl":"@[to_additive (attr := simp)]\nlemma mulSingle_le_one : mulSingle i a ≤ 1 ↔ a ≤ 1 := by simp [mulSingle]\n\n"}
{"name":"Pi.single_nonpos","module":"Mathlib.Algebra.Order.Pi","initialProofState":"ι : Type u_6\nα : ι → Type u_7\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (α i)\ninst✝ : (i : ι) → Preorder (α i)\ni : ι\na : α i\n⊢ Iff (LE.le (Pi.single i a) 0) (LE.le a 0)","decl":"@[to_additive (attr := simp)]\nlemma mulSingle_le_one : mulSingle i a ≤ 1 ↔ a ≤ 1 := by simp [mulSingle]\n\n"}
