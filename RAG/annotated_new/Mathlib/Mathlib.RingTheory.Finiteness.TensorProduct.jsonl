{"name":"Submodule.exists_fg_le_eq_rTensor_subtype","module":"Mathlib.RingTheory.Finiteness.TensorProduct","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nx : TensorProduct R N M\n⊢ Exists fun J => Exists fun x_1 => Exists fun y => Eq x ((LinearMap.rTensor M J.subtype) y)","decl":"/-- Every `x : N ⊗ M` is the image of some `y : J ⊗ M`, where `J` is a finitely generated\nsubmodule of `N`, under the tensor product of the inclusion `J → N` and the identity `M → M`. -/\ntheorem exists_fg_le_eq_rTensor_subtype (x : N ⊗ M) :\n    ∃ (J : Submodule R N) (_ : J.FG) (y : J ⊗ M), x = rTensor M J.subtype y := by\n  induction x with\n  | zero => exact ⟨⊥, fg_bot, 0, rfl⟩\n  | tmul i m => exact ⟨R ∙ i, fg_span_singleton i, ⟨i, mem_span_singleton_self _⟩ ⊗ₜ[R] m, rfl⟩\n  | add x₁ x₂ ihx₁ ihx₂ =>\n    obtain ⟨J₁, fg₁, y₁, rfl⟩ := ihx₁\n    obtain ⟨J₂, fg₂, y₂, rfl⟩ := ihx₂\n    refine ⟨J₁ ⊔ J₂, fg₁.sup fg₂,\n      rTensor M (J₁.inclusion le_sup_left) y₁ + rTensor M (J₂.inclusion le_sup_right) y₂, ?_⟩\n    rw [map_add, ← rTensor_comp_apply, ← rTensor_comp_apply]\n    rfl\n\n"}
{"name":"Submodule.exists_fg_le_subset_range_rTensor_subtype","module":"Mathlib.RingTheory.Finiteness.TensorProduct","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\ns : Set (TensorProduct R N M)\nhs : s.Finite\n⊢ Exists fun J => Exists fun x => HasSubset.Subset s ↑(LinearMap.range (LinearMap.rTensor M J.subtype))","decl":"theorem exists_fg_le_subset_range_rTensor_subtype (s : Set (N ⊗[R] M)) (hs : s.Finite) :\n    ∃ (J : Submodule R N) (_ : J.FG), s ⊆ LinearMap.range (rTensor M J.subtype) := by\n  choose J fg y eq using exists_fg_le_eq_rTensor_subtype (R := R) (M := M) (N := N)\n  rw [← Set.finite_coe_iff] at hs\n  refine ⟨⨆ x : s, J x, fg_iSup _ fun _ ↦ fg _, fun x hx ↦\n    ⟨rTensor M (inclusion <| le_iSup _ ⟨x, hx⟩) (y x), .trans ?_ (eq x).symm⟩⟩\n  rw [← comp_apply, ← rTensor_comp]; rfl\n\n"}
{"name":"Submodule.exists_fg_le_eq_rTensor_inclusion","module":"Mathlib.RingTheory.Finiteness.TensorProduct","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nI : Submodule R N\nx : TensorProduct R (Subtype fun x => Membership.mem I x) M\n⊢ Exists fun J => Exists fun x_1 => Exists fun hle => Exists fun y => Eq x ((LinearMap.rTensor M (Submodule.inclusion hle)) y)","decl":"/-- Every `x : I ⊗ M` is the image of some `y : J ⊗ M`, where `J ≤ I` is finitely generated,\nunder the tensor product of `J.inclusion ‹J ≤ I› : J → I` and the identity `M → M`. -/\ntheorem exists_fg_le_eq_rTensor_inclusion (x : I ⊗ M) :\n    ∃ (J : Submodule R N) (_ : J.FG) (hle : J ≤ I) (y : J ⊗ M),\n      x = rTensor M (J.inclusion hle) y := by\n  obtain ⟨J, fg, y, rfl⟩ := exists_fg_le_eq_rTensor_subtype x\n  refine ⟨J.map I.subtype, fg.map _, I.map_subtype_le J, rTensor M (I.subtype.submoduleMap J) y, ?_⟩\n  rw [← LinearMap.rTensor_comp_apply]; rfl\n\n"}
{"name":"Submodule.exists_fg_le_subset_range_rTensor_inclusion","module":"Mathlib.RingTheory.Finiteness.TensorProduct","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nI : Submodule R N\ns : Set (TensorProduct R (Subtype fun x => Membership.mem I x) M)\nhs : s.Finite\n⊢ Exists fun J => Exists fun x => Exists fun hle => HasSubset.Subset s ↑(LinearMap.range (LinearMap.rTensor M (Submodule.inclusion hle)))","decl":"theorem exists_fg_le_subset_range_rTensor_inclusion (s : Set (I ⊗[R] M)) (hs : s.Finite) :\n    ∃ (J : Submodule R N) (_ : J.FG) (hle : J ≤ I),\n      s ⊆ LinearMap.range (rTensor M (J.inclusion hle)) := by\n  choose J fg hle y eq using exists_fg_le_eq_rTensor_inclusion (M := M) (I := I)\n  rw [← Set.finite_coe_iff] at hs\n  refine ⟨⨆ x : s, J x, fg_iSup _ fun _ ↦ fg _, iSup_le fun _ ↦ hle _, fun x hx ↦\n    ⟨rTensor M (inclusion <| le_iSup _ ⟨x, hx⟩) (y x), .trans ?_ (eq x).symm⟩⟩\n  rw [← comp_apply, ← rTensor_comp]; rfl\n\n"}
{"name":"Module.Finite.base_change","module":"Mathlib.RingTheory.Finiteness.TensorProduct","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nh : Module.Finite R M\n⊢ Module.Finite A (TensorProduct R A M)","decl":"instance Module.Finite.base_change [CommSemiring R] [Semiring A] [Algebra R A] [AddCommMonoid M]\n    [Module R M] [h : Module.Finite R M] : Module.Finite A (TensorProduct R A M) := by\n  classical\n    obtain ⟨s, hs⟩ := h.fg_top\n    refine ⟨⟨s.image (TensorProduct.mk R A M 1), eq_top_iff.mpr ?_⟩⟩\n    rintro x -\n    induction x with\n    | zero => exact zero_mem _\n    | tmul x y =>\n      -- Porting note: new TC reminder\n      haveI : IsScalarTower R A (TensorProduct R A M) := TensorProduct.isScalarTower_left\n      rw [Finset.coe_image, ← Submodule.span_span_of_tower R, Submodule.span_image, hs,\n        Submodule.map_top, LinearMap.range_coe]\n      change _ ∈ Submodule.span A (Set.range <| TensorProduct.mk R A M 1)\n      rw [← mul_one x, ← smul_eq_mul, ← TensorProduct.smul_tmul']\n      exact Submodule.smul_mem _ x (Submodule.subset_span <| Set.mem_range_self y)\n    | add x y hx hy => exact Submodule.add_mem _ hx hy\n\n"}
{"name":"Module.Finite.tensorProduct","module":"Mathlib.RingTheory.Finiteness.TensorProduct","initialProofState":"R : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nhM : Module.Finite R M\nhN : Module.Finite R N\n⊢ Module.Finite R (TensorProduct R M N)","decl":"instance Module.Finite.tensorProduct [CommSemiring R] [AddCommMonoid M] [Module R M]\n    [AddCommMonoid N] [Module R N] [hM : Module.Finite R M] [hN : Module.Finite R N] :\n    Module.Finite R (TensorProduct R M N) where\n  fg_top := (TensorProduct.map₂_mk_top_top_eq_top R M N).subst (hM.fg_top.map₂ _ hN.fg_top)\n\n"}
{"name":"Module.exists_isPrincipal_quotient_of_finite","module":"Mathlib.RingTheory.Finiteness.TensorProduct","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Finite R M\ninst✝ : Nontrivial M\n⊢ Exists fun N => And (Ne N Top.top) Top.top.IsPrincipal","decl":"lemma Module.exists_isPrincipal_quotient_of_finite  :\n    ∃ N : Submodule R M, N ≠ ⊤ ∧ Submodule.IsPrincipal (⊤ : Submodule R (M ⧸ N)) := by\n  obtain ⟨n, f, hf⟩ := @Module.Finite.exists_fin R M _ _ _ _\n  let s := { m : ℕ | Submodule.span R (f '' (Fin.val ⁻¹' (Set.Iio m))) ≠ ⊤ }\n  have hns : ∀ x ∈ s, x < n := by\n    refine fun x hx ↦ lt_iff_not_le.mpr fun e ↦ ?_\n    have : (Fin.val ⁻¹' Set.Iio x : Set (Fin n)) = Set.univ := by ext y; simpa using y.2.trans_le e\n    simp [s, this, hf] at hx\n  have hs₁ : s.Nonempty := ⟨0, by simp [s, show Set.Iio 0 = ∅ by ext; simp]⟩\n  have hs₂ : BddAbove s := ⟨n, fun x hx ↦ (hns x hx).le⟩\n  have hs := Nat.sSup_mem hs₁ hs₂\n  refine ⟨_, hs, ⟨⟨Submodule.mkQ _ (f ⟨_, hns _ hs⟩), ?_⟩⟩⟩\n  have := not_not.mp (not_mem_of_csSup_lt (Order.lt_succ _) hs₂)\n  rw [← Set.image_singleton, ← Submodule.map_span,\n    ← (Submodule.comap_injective_of_surjective (Submodule.mkQ_surjective _)).eq_iff,\n    Submodule.comap_map_eq, Submodule.ker_mkQ, Submodule.comap_top, ← this, ← Submodule.span_union,\n    Order.Iio_succ_eq_insert (sSup s), ← Set.union_singleton, Set.preimage_union, Set.image_union,\n    ← @Set.image_singleton _ _ f, Set.union_comm]\n  congr!\n  ext\n  simp [Fin.ext_iff]\n\n"}
{"name":"Module.exists_surjective_quotient_of_finite","module":"Mathlib.RingTheory.Finiteness.TensorProduct","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Finite R M\ninst✝ : Nontrivial M\n⊢ Exists fun I => Exists fun f => And (Ne I Top.top) (Function.Surjective ⇑f)","decl":"lemma Module.exists_surjective_quotient_of_finite :\n    ∃ (I : Ideal R) (f : M →ₗ[R] R ⧸ I), I ≠ ⊤ ∧ Function.Surjective f := by\n  obtain ⟨N, hN, ⟨x, hx⟩⟩ := Module.exists_isPrincipal_quotient_of_finite R M\n  let f := (LinearMap.toSpanSingleton R _ x).quotKerEquivOfSurjective\n    (by rw [← LinearMap.range_eq_top, ← LinearMap.span_singleton_eq_range, hx])\n  refine ⟨_, f.symm.toLinearMap.comp N.mkQ, fun e ↦ ?_, f.symm.surjective.comp N.mkQ_surjective⟩\n  obtain rfl : x = 0 := by simpa using LinearMap.congr_fun (LinearMap.ker_eq_top.mp e) 1\n  rw [ne_eq, ← Submodule.subsingleton_quotient_iff_eq_top, ← not_nontrivial_iff_subsingleton,\n    not_not] at hN\n  simp at hx\n\n"}
{"name":"instNontrivialTensorProduct","module":"Mathlib.RingTheory.Finiteness.TensorProduct","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Nontrivial (TensorProduct R M M)","decl":"instance : Nontrivial (M ⊗[R] M) := by\n  obtain ⟨I, ϕ, hI, hϕ⟩ := Module.exists_surjective_quotient_of_finite R M\n  let ψ : M ⊗[R] M →ₗ[R] R ⧸ I :=\n    (LinearMap.mul' R (R ⧸ I)).comp (TensorProduct.map ϕ ϕ)\n  have : Nontrivial (R ⧸ I) := by\n    rwa [← not_subsingleton_iff_nontrivial, Submodule.subsingleton_quotient_iff_eq_top]\n  have : Function.Surjective ψ := by\n    intro x; obtain ⟨x, rfl⟩ := hϕ x; obtain ⟨y, hy⟩ := hϕ 1; exact ⟨x ⊗ₜ y, by simp [ψ, hy]⟩\n  exact this.nontrivial\n\n"}
