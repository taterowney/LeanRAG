{"name":"AssociatePrimes.mem_iff","module":"Mathlib.RingTheory.Ideal.AssociatedPrime","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Membership.mem (associatedPrimes R M) I) (IsAssociatedPrime I M)","decl":"theorem AssociatePrimes.mem_iff : I ∈ associatedPrimes R M ↔ IsAssociatedPrime I M := Iff.rfl\n\n"}
{"name":"IsAssociatedPrime.isPrime","module":"Mathlib.RingTheory.Ideal.AssociatedPrime","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nh : IsAssociatedPrime I M\n⊢ I.IsPrime","decl":"theorem IsAssociatedPrime.isPrime (h : IsAssociatedPrime I M) : I.IsPrime := h.1\n"}
{"name":"IsAssociatedPrime.map_of_injective","module":"Mathlib.RingTheory.Ideal.AssociatedPrime","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nM' : Type u_3\ninst✝¹ : AddCommGroup M'\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\nh : IsAssociatedPrime I M\nhf : Function.Injective ⇑f\n⊢ IsAssociatedPrime I M'","decl":"theorem IsAssociatedPrime.map_of_injective (h : IsAssociatedPrime I M) (hf : Function.Injective f) :\n    IsAssociatedPrime I M' := by\n  obtain ⟨x, rfl⟩ := h.2\n  refine ⟨h.1, ⟨f x, ?_⟩⟩\n  ext r\n  simp_rw [mem_ker, toSpanSingleton_apply, ← map_smul, ← f.map_zero, hf.eq_iff]\n\n"}
{"name":"LinearEquiv.isAssociatedPrime_iff","module":"Mathlib.RingTheory.Ideal.AssociatedPrime","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nM' : Type u_3\ninst✝¹ : AddCommGroup M'\ninst✝ : Module R M'\nl : LinearEquiv (RingHom.id R) M M'\n⊢ Iff (IsAssociatedPrime I M) (IsAssociatedPrime I M')","decl":"theorem LinearEquiv.isAssociatedPrime_iff (l : M ≃ₗ[R] M') :\n    IsAssociatedPrime I M ↔ IsAssociatedPrime I M' :=\n  ⟨fun h => h.map_of_injective l l.injective,\n    fun h => h.map_of_injective l.symm l.symm.injective⟩\n\n"}
{"name":"not_isAssociatedPrime_of_subsingleton","module":"Mathlib.RingTheory.Ideal.AssociatedPrime","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Subsingleton M\n⊢ Not (IsAssociatedPrime I M)","decl":"theorem not_isAssociatedPrime_of_subsingleton [Subsingleton M] : ¬IsAssociatedPrime I M := by\n  rintro ⟨hI, x, hx⟩\n  apply hI.ne_top\n  simpa [Subsingleton.elim x 0] using hx\n\n"}
{"name":"exists_le_isAssociatedPrime_of_isNoetherianRing","module":"Mathlib.RingTheory.Ideal.AssociatedPrime","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nH : IsNoetherianRing R\nx : M\nhx : Ne x 0\n⊢ Exists fun P => And (IsAssociatedPrime P M) (LE.le (LinearMap.ker (LinearMap.toSpanSingleton R M x)) P)","decl":"theorem exists_le_isAssociatedPrime_of_isNoetherianRing [H : IsNoetherianRing R] (x : M)\n    (hx : x ≠ 0) : ∃ P : Ideal R, IsAssociatedPrime P M ∧ ker (toSpanSingleton R M x) ≤ P := by\n  have : ker (toSpanSingleton R M x) ≠ ⊤ := by\n    rwa [Ne, Ideal.eq_top_iff_one, mem_ker, toSpanSingleton_apply, one_smul]\n  obtain ⟨P, ⟨l, h₁, y, rfl⟩, h₃⟩ :=\n    set_has_maximal_iff_noetherian.mpr H\n      { P | ker (toSpanSingleton R M x) ≤ P ∧ P ≠ ⊤ ∧ ∃ y : M, P = ker (toSpanSingleton R M y) }\n      ⟨_, rfl.le, this, x, rfl⟩\n  refine ⟨_, ⟨⟨h₁, ?_⟩, y, rfl⟩, l⟩\n  intro a b hab\n  rw [or_iff_not_imp_left]\n  intro ha\n  rw [mem_ker, toSpanSingleton_apply] at ha hab\n  have H₁ : ker (toSpanSingleton R M y) ≤ ker (toSpanSingleton R M (a • y)) := by\n    intro c hc\n    rw [mem_ker, toSpanSingleton_apply] at hc ⊢\n    rw [smul_comm, hc, smul_zero]\n  have H₂ : ker (toSpanSingleton R M (a • y)) ≠ ⊤ := by\n    rwa [Ne, ker_eq_top, toSpanSingleton_eq_zero_iff]\n  rwa [H₁.eq_of_not_lt (h₃ _ ⟨l.trans H₁, H₂, _, rfl⟩),\n    mem_ker, toSpanSingleton_apply, smul_comm, smul_smul]\n\n"}
{"name":"associatedPrimes.subset_of_injective","module":"Mathlib.RingTheory.Ideal.AssociatedPrime","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nM' : Type u_3\ninst✝¹ : AddCommGroup M'\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\nhf : Function.Injective ⇑f\n⊢ HasSubset.Subset (associatedPrimes R M) (associatedPrimes R M')","decl":"theorem associatedPrimes.subset_of_injective (hf : Function.Injective f) :\n    associatedPrimes R M ⊆ associatedPrimes R M' := fun _I h => h.map_of_injective f hf\n\n"}
{"name":"LinearEquiv.AssociatedPrimes.eq","module":"Mathlib.RingTheory.Ideal.AssociatedPrime","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nM' : Type u_3\ninst✝¹ : AddCommGroup M'\ninst✝ : Module R M'\nl : LinearEquiv (RingHom.id R) M M'\n⊢ Eq (associatedPrimes R M) (associatedPrimes R M')","decl":"theorem LinearEquiv.AssociatedPrimes.eq (l : M ≃ₗ[R] M') :\n    associatedPrimes R M = associatedPrimes R M' :=\n  le_antisymm (associatedPrimes.subset_of_injective l l.injective)\n    (associatedPrimes.subset_of_injective l.symm l.symm.injective)\n\n"}
{"name":"associatedPrimes.eq_empty_of_subsingleton","module":"Mathlib.RingTheory.Ideal.AssociatedPrime","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Subsingleton M\n⊢ Eq (associatedPrimes R M) EmptyCollection.emptyCollection","decl":"theorem associatedPrimes.eq_empty_of_subsingleton [Subsingleton M] : associatedPrimes R M = ∅ := by\n  ext; simp only [Set.mem_empty_iff_false, iff_false]\n  apply not_isAssociatedPrime_of_subsingleton\n\n"}
{"name":"associatedPrimes.nonempty","module":"Mathlib.RingTheory.Ideal.AssociatedPrime","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : IsNoetherianRing R\ninst✝ : Nontrivial M\n⊢ (associatedPrimes R M).Nonempty","decl":"theorem associatedPrimes.nonempty [IsNoetherianRing R] [Nontrivial M] :\n    (associatedPrimes R M).Nonempty := by\n  obtain ⟨x, hx⟩ := exists_ne (0 : M)\n  obtain ⟨P, hP, _⟩ := exists_le_isAssociatedPrime_of_isNoetherianRing R x hx\n  exact ⟨P, hP⟩\n\n"}
{"name":"biUnion_associatedPrimes_eq_zero_divisors","module":"Mathlib.RingTheory.Ideal.AssociatedPrime","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsNoetherianRing R\n⊢ Eq (Set.iUnion fun p => Set.iUnion fun h => ↑p) (setOf fun r => Exists fun x => And (Ne x 0) (Eq (HSMul.hSMul r x) 0))","decl":"theorem biUnion_associatedPrimes_eq_zero_divisors [IsNoetherianRing R] :\n    ⋃ p ∈ associatedPrimes R M, p = { r : R | ∃ x : M, x ≠ 0 ∧ r • x = 0 } := by\n  refine subset_antisymm (Set.iUnion₂_subset ?_) ?_\n  · rintro _ ⟨h, x, ⟨⟩⟩ r h'\n    refine ⟨x, ne_of_eq_of_ne (one_smul R x).symm ?_, h'⟩\n    exact (Ideal.ne_top_iff_one _).mp h.ne_top\n  · intro r ⟨x, h, h'⟩\n    obtain ⟨P, hP, hx⟩ := exists_le_isAssociatedPrime_of_isNoetherianRing R x h\n    exact Set.mem_biUnion hP (hx h')\n\n"}
{"name":"IsAssociatedPrime.annihilator_le","module":"Mathlib.RingTheory.Ideal.AssociatedPrime","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nh : IsAssociatedPrime I M\n⊢ LE.le Top.top.annihilator I","decl":"theorem IsAssociatedPrime.annihilator_le (h : IsAssociatedPrime I M) :\n    (⊤ : Submodule R M).annihilator ≤ I := by\n  obtain ⟨hI, x, rfl⟩ := h\n  rw [← Submodule.annihilator_span_singleton]\n  exact Submodule.annihilator_mono le_top\n\n"}
{"name":"IsAssociatedPrime.eq_radical","module":"Mathlib.RingTheory.Ideal.AssociatedPrime","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI J : Ideal R\nhI : I.IsPrimary\nh : IsAssociatedPrime J (HasQuotient.Quotient R I)\n⊢ Eq J I.radical","decl":"theorem IsAssociatedPrime.eq_radical (hI : I.IsPrimary) (h : IsAssociatedPrime J (R ⧸ I)) :\n    J = I.radical := by\n  obtain ⟨hJ, x, e⟩ := h\n  have : x ≠ 0 := by\n    rintro rfl\n    apply hJ.1\n    rwa [toSpanSingleton_zero, ker_zero] at e\n  obtain ⟨x, rfl⟩ := Ideal.Quotient.mkₐ_surjective R _ x\n  replace e : ∀ {y}, y ∈ J ↔ x * y ∈ I := by\n    intro y\n    rw [e, mem_ker, toSpanSingleton_apply, ← map_smul, smul_eq_mul, mul_comm,\n      Ideal.Quotient.mkₐ_eq_mk, ← Ideal.Quotient.mk_eq_mk, Submodule.Quotient.mk_eq_zero]\n  apply le_antisymm\n  · intro y hy\n    exact ((Ideal.isPrimary_iff.1 hI).2 <| e.mp hy).resolve_left\n      ((Submodule.Quotient.mk_eq_zero I).not.mp this)\n  · rw [hJ.radical_le_iff]\n    intro y hy\n    exact e.mpr (I.mul_mem_left x hy)\n\n"}
{"name":"associatedPrimes.eq_singleton_of_isPrimary","module":"Mathlib.RingTheory.Ideal.AssociatedPrime","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nI : Ideal R\ninst✝ : IsNoetherianRing R\nhI : I.IsPrimary\n⊢ Eq (associatedPrimes R (HasQuotient.Quotient R I)) (Singleton.singleton I.radical)","decl":"theorem associatedPrimes.eq_singleton_of_isPrimary [IsNoetherianRing R] (hI : I.IsPrimary) :\n    associatedPrimes R (R ⧸ I) = {I.radical} := by\n  ext J\n  rw [Set.mem_singleton_iff]\n  refine ⟨IsAssociatedPrime.eq_radical hI, ?_⟩\n  rintro rfl\n  haveI : Nontrivial (R ⧸ I) := by\n    refine ⟨(Ideal.Quotient.mk I :) 1, (Ideal.Quotient.mk I :) 0, ?_⟩\n    rw [Ne, Ideal.Quotient.eq, sub_zero, ← Ideal.eq_top_iff_one]\n    exact hI.1\n  obtain ⟨a, ha⟩ := associatedPrimes.nonempty R (R ⧸ I)\n  exact ha.eq_radical hI ▸ ha\n"}
