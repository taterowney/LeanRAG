{"name":"CategoryTheory.IsFilteredOrEmpty.cocone_maps","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.IsFilteredOrEmpty C\nX Y : C\nf g : Quiver.Hom X Y\n‚ä¢ Exists fun Z => Exists fun h => Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g h)","decl":"/-- A category `IsFilteredOrEmpty` if\n1. for every pair of objects there exists another object \"to the right\", and\n2. for every pair of parallel morphisms there exists a morphism to the right so the compositions\n   are equal.\n-/\nclass IsFilteredOrEmpty : Prop where\n  /-- for every pair of objects there exists another object \"to the right\" -/\n  cocone_objs : ‚àÄ X Y : C, ‚àÉ (Z : _) (_ : X ‚ü∂ Z) (_ : Y ‚ü∂ Z), True\n  /-- for every pair of parallel morphisms there exists a morphism to the right\n    so the compositions are equal -/\n  cocone_maps : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f g : X ‚ü∂ Y), ‚àÉ (Z : _) (h : Y ‚ü∂ Z), f ‚â´ h = g ‚â´ h\n\n"}
{"name":"CategoryTheory.IsFilteredOrEmpty.cocone_objs","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.IsFilteredOrEmpty C\nX Y : C\n‚ä¢ Exists fun Z => Exists fun x => Exists fun x => True","decl":"/-- A category `IsFilteredOrEmpty` if\n1. for every pair of objects there exists another object \"to the right\", and\n2. for every pair of parallel morphisms there exists a morphism to the right so the compositions\n   are equal.\n-/\nclass IsFilteredOrEmpty : Prop where\n  /-- for every pair of objects there exists another object \"to the right\" -/\n  cocone_objs : ‚àÄ X Y : C, ‚àÉ (Z : _) (_ : X ‚ü∂ Z) (_ : Y ‚ü∂ Z), True\n  /-- for every pair of parallel morphisms there exists a morphism to the right\n    so the compositions are equal -/\n  cocone_maps : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f g : X ‚ü∂ Y), ‚àÉ (Z : _) (h : Y ‚ü∂ Z), f ‚â´ h = g ‚â´ h\n\n"}
{"name":"CategoryTheory.IsFiltered.nonempty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.IsFiltered C\n‚ä¢ Nonempty C","decl":"/-- A category `IsFiltered` if\n1. for every pair of objects there exists another object \"to the right\",\n2. for every pair of parallel morphisms there exists a morphism to the right so the compositions\n   are equal, and\n3. there exists some object. -/\n@[stacks 002V \"They also define a diagram being filtered.\"]\nclass IsFiltered extends IsFilteredOrEmpty C : Prop where\n  /-- a filtered category must be non empty -/\n  [nonempty : Nonempty C]\n\n"}
{"name":"CategoryTheory.IsFiltered.toIsFilteredOrEmpty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.IsFiltered C\n‚ä¢ CategoryTheory.IsFilteredOrEmpty C","decl":"/-- A category `IsFiltered` if\n1. for every pair of objects there exists another object \"to the right\",\n2. for every pair of parallel morphisms there exists a morphism to the right so the compositions\n   are equal, and\n3. there exists some object. -/\n@[stacks 002V \"They also define a diagram being filtered.\"]\nclass IsFiltered extends IsFilteredOrEmpty C : Prop where\n  /-- a filtered category must be non empty -/\n  [nonempty : Nonempty C]\n\n"}
{"name":"CategoryTheory.isFilteredOrEmpty_of_semilatticeSup","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"Œ± : Type u\ninst‚úù : SemilatticeSup Œ±\n‚ä¢ CategoryTheory.IsFilteredOrEmpty Œ±","decl":"instance (priority := 100) isFilteredOrEmpty_of_semilatticeSup (Œ± : Type u) [SemilatticeSup Œ±] :\n    IsFilteredOrEmpty Œ± where\n  cocone_objs X Y := ‚ü®X ‚äî Y, homOfLE le_sup_left, homOfLE le_sup_right, trivial‚ü©\n  cocone_maps X Y f g := ‚ü®Y, ùüô _, by subsingleton‚ü©\n\n"}
{"name":"CategoryTheory.isFiltered_of_semilatticeSup_nonempty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬π : SemilatticeSup Œ±\ninst‚úù : Nonempty Œ±\n‚ä¢ CategoryTheory.IsFiltered Œ±","decl":"instance (priority := 100) isFiltered_of_semilatticeSup_nonempty (Œ± : Type u) [SemilatticeSup Œ±]\n    [Nonempty Œ±] : IsFiltered Œ± where\n\n"}
{"name":"CategoryTheory.isFilteredOrEmpty_of_directed_le","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => LE.le x1 x2\n‚ä¢ CategoryTheory.IsFilteredOrEmpty Œ±","decl":"instance (priority := 100) isFilteredOrEmpty_of_directed_le (Œ± : Type u) [Preorder Œ±]\n    [IsDirected Œ± (¬∑ ‚â§ ¬∑)] : IsFilteredOrEmpty Œ± where\n  cocone_objs X Y :=\n    let ‚ü®Z, h1, h2‚ü© := exists_ge_ge X Y\n    ‚ü®Z, homOfLE h1, homOfLE h2, trivial‚ü©\n  cocone_maps X Y f g := ‚ü®Y, ùüô _, by subsingleton‚ü©\n\n"}
{"name":"CategoryTheory.isFiltered_of_directed_le_nonempty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => LE.le x1 x2\ninst‚úù : Nonempty Œ±\n‚ä¢ CategoryTheory.IsFiltered Œ±","decl":"instance (priority := 100) isFiltered_of_directed_le_nonempty (Œ± : Type u) [Preorder Œ±]\n    [IsDirected Œ± (¬∑ ‚â§ ¬∑)] [Nonempty Œ±] : IsFiltered Œ± where\n\n-- Sanity checks\n"}
{"name":"CategoryTheory.instIsFilteredDiscretePUnit","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"‚ä¢ CategoryTheory.IsFiltered (CategoryTheory.Discrete PUnit.{u_1 + 1})","decl":"instance : IsFiltered (Discrete PUnit) where\n  cocone_objs X Y := ‚ü®‚ü®PUnit.unit‚ü©, ‚ü®‚ü®by trivial‚ü©‚ü©, ‚ü®‚ü®by subsingleton‚ü©‚ü©, trivial‚ü©\n  cocone_maps X Y f g := ‚ü®‚ü®PUnit.unit‚ü©, ‚ü®‚ü®by trivial‚ü©‚ü©, by subsingleton‚ü©\n\n"}
{"name":"CategoryTheory.IsFiltered.coeq_condition_assoc","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsFilteredOrEmpty C\nj j' : C\nf f' : Quiver.Hom j j'\nZ : C\nh : Quiver.Hom (CategoryTheory.IsFiltered.coeq f f') Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsFiltered.coeqHom f f') h)) (CategoryTheory.CategoryStruct.comp f' (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsFiltered.coeqHom f f') h))","decl":"/-- `coeq_condition f f'`, for morphisms `f f' : j ‚ü∂ j'`, is the proof that\n`f ‚â´ coeqHom f f' = f' ‚â´ coeqHom f f'`.\n-/\n@[reassoc]\ntheorem coeq_condition {j j' : C} (f f' : j ‚ü∂ j') : f ‚â´ coeqHom f f' = f' ‚â´ coeqHom f f' :=\n  (IsFilteredOrEmpty.cocone_maps f f').choose_spec.choose_spec\n\n"}
{"name":"CategoryTheory.IsFiltered.coeq_condition","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsFilteredOrEmpty C\nj j' : C\nf f' : Quiver.Hom j j'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.IsFiltered.coeqHom f f')) (CategoryTheory.CategoryStruct.comp f' (CategoryTheory.IsFiltered.coeqHom f f'))","decl":"/-- `coeq_condition f f'`, for morphisms `f f' : j ‚ü∂ j'`, is the proof that\n`f ‚â´ coeqHom f f' = f' ‚â´ coeqHom f f'`.\n-/\n@[reassoc]\ntheorem coeq_condition {j j' : C} (f f' : j ‚ü∂ j') : f ‚â´ coeqHom f f' = f' ‚â´ coeqHom f f' :=\n  (IsFilteredOrEmpty.cocone_maps f f').choose_spec.choose_spec\n\n"}
{"name":"CategoryTheory.IsFilteredOrEmpty.of_right_adjoint","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.IsFilteredOrEmpty C\nD : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nL : CategoryTheory.Functor D C\nR : CategoryTheory.Functor C D\nh : CategoryTheory.Adjunction L R\n‚ä¢ CategoryTheory.IsFilteredOrEmpty D","decl":"/-- If `C` is filtered or empty, and we have a functor `R : C ‚•§ D` with a left adjoint, then `D` is\nfiltered or empty.\n-/\ntheorem of_right_adjoint {L : D ‚•§ C} {R : C ‚•§ D} (h : L ‚ä£ R) : IsFilteredOrEmpty D :=\n  { cocone_objs := fun X Y =>\n      ‚ü®R.obj (max (L.obj X) (L.obj Y)),\n        h.homEquiv _ _ (leftToMax _ _), h.homEquiv _ _ (rightToMax _ _), ‚ü®‚ü©‚ü©\n    cocone_maps := fun X Y f g =>\n      ‚ü®R.obj (coeq (L.map f) (L.map g)), h.homEquiv _ _ (coeqHom _ _), by\n        rw [‚Üê h.homEquiv_naturality_left, ‚Üê h.homEquiv_naturality_left, coeq_condition]‚ü© }\n\n"}
{"name":"CategoryTheory.IsFilteredOrEmpty.of_isRightAdjoint","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.IsFilteredOrEmpty C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nR : CategoryTheory.Functor C D\ninst‚úù : R.IsRightAdjoint\n‚ä¢ CategoryTheory.IsFilteredOrEmpty D","decl":"/-- If `C` is filtered or empty, and we have a right adjoint functor `R : C ‚•§ D`, then `D` is\nfiltered or empty. -/\ntheorem of_isRightAdjoint (R : C ‚•§ D) [R.IsRightAdjoint] : IsFilteredOrEmpty D :=\n  of_right_adjoint (Adjunction.ofIsRightAdjoint R)\n\n"}
{"name":"CategoryTheory.IsFilteredOrEmpty.of_equivalence","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.IsFilteredOrEmpty C\nD : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nh : CategoryTheory.Equivalence C D\n‚ä¢ CategoryTheory.IsFilteredOrEmpty D","decl":"/-- Being filtered or empty is preserved by equivalence of categories. -/\ntheorem of_equivalence (h : C ‚âå D) : IsFilteredOrEmpty D :=\n  of_right_adjoint h.symm.toAdjunction\n\n"}
{"name":"CategoryTheory.IsFiltered.sup_objs_exists","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsFiltered C\nO : Finset C\n‚ä¢ Exists fun S => ‚àÄ {X : C}, Membership.mem O X ‚Üí Nonempty (Quiver.Hom X S)","decl":"/-- Any finite collection of objects in a filtered category has an object \"to the right\".\n-/\ntheorem sup_objs_exists (O : Finset C) : ‚àÉ S : C, ‚àÄ {X}, X ‚àà O ‚Üí Nonempty (X ‚ü∂ S) := by\n  classical\n  induction' O using Finset.induction with X O' nm h\n  ¬∑ exact ‚ü®Classical.choice IsFiltered.nonempty, by intro; simp‚ü©\n  ¬∑ obtain ‚ü®S', w'‚ü© := h\n    use max X S'\n    rintro Y mY\n    obtain rfl | h := eq_or_ne Y X\n    ¬∑ exact ‚ü®leftToMax _ _‚ü©\n    ¬∑ exact ‚ü®(w' (Finset.mem_of_mem_insert_of_ne mY h)).some ‚â´ rightToMax _ _‚ü©\n\n"}
{"name":"CategoryTheory.IsFiltered.sup_exists","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsFiltered C\nO : Finset C\nH : Finset (PSigma fun X => PSigma fun Y => PSigma fun x => PSigma fun x => Quiver.Hom X Y)\n‚ä¢ Exists fun S => Exists fun T => ‚àÄ {X Y : C} (mX : Membership.mem O X) (mY : Membership.mem O Y) {f : Quiver.Hom X Y}, Membership.mem H ‚ü®X, ‚ü®Y, ‚ü®mX, ‚ü®mY, f‚ü©‚ü©‚ü©‚ü© ‚Üí Eq (CategoryTheory.CategoryStruct.comp f (T mY)) (T mX)","decl":"/-- Given any `Finset` of objects `{X, ...}` and\nindexed collection of `Finset`s of morphisms `{f, ...}` in `C`,\nthere exists an object `S`, with a morphism `T X : X ‚ü∂ S` from each `X`,\nsuch that the triangles commute: `f ‚â´ T Y = T X`, for `f : X ‚ü∂ Y` in the `Finset`.\n-/\ntheorem sup_exists :\n    ‚àÉ (S : C) (T : ‚àÄ {X : C}, X ‚àà O ‚Üí (X ‚ü∂ S)),\n      ‚àÄ {X Y : C} (mX : X ‚àà O) (mY : Y ‚àà O) {f : X ‚ü∂ Y},\n        (‚ü®X, Y, mX, mY, f‚ü© : Œ£' (X Y : C) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) ‚àà H ‚Üí\n          f ‚â´ T mY = T mX := by\n  classical\n  induction' H using Finset.induction with h' H' nmf h''\n  ¬∑ obtain ‚ü®S, f‚ü© := sup_objs_exists O\n    exact ‚ü®S, fun mX => (f mX).some, by rintro - - - - - ‚ü®‚ü©‚ü©\n  ¬∑ obtain ‚ü®X, Y, mX, mY, f‚ü© := h'\n    obtain ‚ü®S', T', w'‚ü© := h''\n    refine ‚ü®coeq (f ‚â´ T' mY) (T' mX), fun mZ => T' mZ ‚â´ coeqHom (f ‚â´ T' mY) (T' mX), ?_‚ü©\n    intro X' Y' mX' mY' f' mf'\n    rw [‚Üê Category.assoc]\n    by_cases h : X = X' ‚àß Y = Y'\n    ¬∑ rcases h with ‚ü®rfl, rfl‚ü©\n      by_cases hf : f = f'\n      ¬∑ subst hf\n        apply coeq_condition\n      ¬∑ rw [@w' _ _ mX mY f']\n        simp only [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, true_and] at mf'\n        rcases mf' with mf' | mf'\n        ¬∑ exfalso\n          exact hf mf'.symm\n        ¬∑ exact mf'\n    ¬∑ rw [@w' _ _ mX' mY' f' _]\n      apply Finset.mem_of_mem_insert_of_ne mf'\n      contrapose! h\n      obtain ‚ü®rfl, h‚ü© := h\n      trivial\n\n"}
{"name":"CategoryTheory.IsFiltered.toSup_commutes","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsFiltered C\nO : Finset C\nH : Finset (PSigma fun X => PSigma fun Y => PSigma fun x => PSigma fun x => Quiver.Hom X Y)\nX Y : C\nmX : Membership.mem O X\nmY : Membership.mem O Y\nf : Quiver.Hom X Y\nmf : Membership.mem H ‚ü®X, ‚ü®Y, ‚ü®mX, ‚ü®mY, f‚ü©‚ü©‚ü©‚ü©\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.IsFiltered.toSup O H mY)) (CategoryTheory.IsFiltered.toSup O H mX)","decl":"/-- The triangles of consisting of a morphism in `H` and the maps to `sup O H` commute.\n-/\ntheorem toSup_commutes {X Y : C} (mX : X ‚àà O) (mY : Y ‚àà O) {f : X ‚ü∂ Y}\n    (mf : (‚ü®X, Y, mX, mY, f‚ü© : Œ£' (X Y : C) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) ‚àà H) :\n    f ‚â´ toSup O H mY = toSup O H mX :=\n  (sup_exists O H).choose_spec.choose_spec mX mY mf\n\n"}
{"name":"CategoryTheory.IsFiltered.cocone_nonempty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.IsFiltered C\nJ : Type w\ninst‚úù¬π : CategoryTheory.SmallCategory J\ninst‚úù : CategoryTheory.FinCategory J\nF : CategoryTheory.Functor J C\n‚ä¢ Nonempty (CategoryTheory.Limits.Cocone F)","decl":"/-- If we have `IsFiltered C`, then for any functor `F : J ‚•§ C` with `FinCategory J`,\nthere exists a cocone over `F`.\n-/\ntheorem cocone_nonempty (F : J ‚•§ C) : Nonempty (Cocone F) := by\n  classical\n  let O := Finset.univ.image F.obj\n  let H : Finset (Œ£' (X Y : C) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) :=\n    Finset.univ.biUnion   fun X : J =>\n      Finset.univ.biUnion fun Y : J =>\n        Finset.univ.image fun f : X ‚ü∂ Y => ‚ü®F.obj X, F.obj Y, by simp [O], by simp [O], F.map f‚ü©\n  obtain ‚ü®Z, f, w‚ü© := sup_exists O H\n  refine ‚ü®‚ü®Z, ‚ü®fun X => f (by simp [O]), ?_‚ü©‚ü©‚ü©\n  intro j j' g\n  dsimp\n  simp only [Category.comp_id]\n  apply w\n  simp only [O, H, Finset.mem_biUnion, Finset.mem_univ, Finset.mem_image, PSigma.mk.injEq,\n    true_and, exists_and_left]\n  exact ‚ü®j, rfl, j', g, by simp‚ü©\n\n"}
{"name":"CategoryTheory.IsFiltered.of_right_adjoint","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.IsFiltered C\nD : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nL : CategoryTheory.Functor D C\nR : CategoryTheory.Functor C D\nh : CategoryTheory.Adjunction L R\n‚ä¢ CategoryTheory.IsFiltered D","decl":"/-- If `C` is filtered, and we have a functor `R : C ‚•§ D` with a left adjoint, then `D` is filtered.\n-/\ntheorem of_right_adjoint {L : D ‚•§ C} {R : C ‚•§ D} (h : L ‚ä£ R) : IsFiltered D :=\n  { IsFilteredOrEmpty.of_right_adjoint h with\n    nonempty := IsFiltered.nonempty.map R.obj }\n\n"}
{"name":"CategoryTheory.IsFiltered.of_isRightAdjoint","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.IsFiltered C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nR : CategoryTheory.Functor C D\ninst‚úù : R.IsRightAdjoint\n‚ä¢ CategoryTheory.IsFiltered D","decl":"/-- If `C` is filtered, and we have a right adjoint functor `R : C ‚•§ D`, then `D` is filtered. -/\ntheorem of_isRightAdjoint (R : C ‚•§ D) [R.IsRightAdjoint] : IsFiltered D :=\n  of_right_adjoint (Adjunction.ofIsRightAdjoint R)\n\n"}
{"name":"CategoryTheory.IsFiltered.of_equivalence","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.IsFiltered C\nD : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nh : CategoryTheory.Equivalence C D\n‚ä¢ CategoryTheory.IsFiltered D","decl":"/-- Being filtered is preserved by equivalence of categories. -/\ntheorem of_equivalence (h : C ‚âå D) : IsFiltered D :=\n  of_right_adjoint h.symm.toAdjunction\n\n"}
{"name":"CategoryTheory.IsFiltered.of_cocone_nonempty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nh : ‚àÄ {J : Type w} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] (F : CategoryTheory.Functor J C), Nonempty (CategoryTheory.Limits.Cocone F)\n‚ä¢ CategoryTheory.IsFiltered C","decl":"/-- If every finite diagram in `C` admits a cocone, then `C` is filtered. It is sufficient to verify\n    this for diagrams whose shape lives in any one fixed universe. -/\ntheorem of_cocone_nonempty (h : ‚àÄ {J : Type w} [SmallCategory J] [FinCategory J] (F : J ‚•§ C),\n    Nonempty (Cocone F)) : IsFiltered C := by\n  have : Nonempty C := by\n    obtain ‚ü®c‚ü© := h (Functor.empty _)\n    exact ‚ü®c.pt‚ü©\n  have : IsFilteredOrEmpty C := by\n    refine ‚ü®?_, ?_‚ü©\n    ¬∑ intros X Y\n      obtain ‚ü®c‚ü© := h (ULiftHom.down ‚ãô ULift.downFunctor ‚ãô pair X Y)\n      exact ‚ü®c.pt, c.Œπ.app ‚ü®‚ü®WalkingPair.left‚ü©‚ü©, c.Œπ.app ‚ü®‚ü®WalkingPair.right‚ü©‚ü©, trivial‚ü©\n    ¬∑ intros X Y f g\n      obtain ‚ü®c‚ü© := h (ULiftHom.down ‚ãô ULift.downFunctor ‚ãô parallelPair f g)\n      refine ‚ü®c.pt, c.Œπ.app ‚ü®WalkingParallelPair.one‚ü©, ?_‚ü©\n      have h‚ÇÅ := c.Œπ.naturality ‚ü®WalkingParallelPairHom.left‚ü©\n      have h‚ÇÇ := c.Œπ.naturality ‚ü®WalkingParallelPairHom.right‚ü©\n      simp_all\n  apply IsFiltered.mk\n\n"}
{"name":"CategoryTheory.IsFiltered.of_hasFiniteColimits","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasFiniteColimits C\n‚ä¢ CategoryTheory.IsFiltered C","decl":"theorem of_hasFiniteColimits [HasFiniteColimits C] : IsFiltered C :=\n  of_cocone_nonempty.{v} C fun F => ‚ü®colimit.cocone F‚ü©\n\n"}
{"name":"CategoryTheory.IsFiltered.of_isTerminal","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nh : CategoryTheory.Limits.IsTerminal X\n‚ä¢ CategoryTheory.IsFiltered C","decl":"theorem of_isTerminal {X : C} (h : IsTerminal X) : IsFiltered C :=\n  of_cocone_nonempty.{v} _ fun {_} _ _ _ => ‚ü®‚ü®X, ‚ü®fun _ => h.from _, fun _ _ _ => h.hom_ext _ _‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.IsFiltered.of_hasTerminal","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasTerminal C\n‚ä¢ CategoryTheory.IsFiltered C","decl":"instance (priority := 100) of_hasTerminal [HasTerminal C] : IsFiltered C :=\n  of_isTerminal _ terminalIsTerminal\n\n"}
{"name":"CategoryTheory.IsFiltered.iff_cocone_nonempty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Iff (CategoryTheory.IsFiltered C) (‚àÄ {J : Type w} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] (F : CategoryTheory.Functor J C), Nonempty (CategoryTheory.Limits.Cocone F))","decl":"/-- For every universe `w`, `C` is filtered if and only if every finite diagram in `C` with shape\n    in `w` admits a cocone. -/\ntheorem iff_cocone_nonempty : IsFiltered C ‚Üî\n    ‚àÄ {J : Type w} [SmallCategory J] [FinCategory J] (F : J ‚•§ C), Nonempty (Cocone F) :=\n  ‚ü®fun _ _ _ _ F => cocone_nonempty F, of_cocone_nonempty C‚ü©\n\n"}
{"name":"CategoryTheory.IsFiltered.coeq‚ÇÉ_condition‚ÇÅ","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsFilteredOrEmpty C\nj‚ÇÅ j‚ÇÇ : C\nf g h : Quiver.Hom j‚ÇÅ j‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.IsFiltered.coeq‚ÇÉHom f g h)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.IsFiltered.coeq‚ÇÉHom f g h))","decl":"theorem coeq‚ÇÉ_condition‚ÇÅ {j‚ÇÅ j‚ÇÇ : C} (f g h : j‚ÇÅ ‚ü∂ j‚ÇÇ) :\n    f ‚â´ coeq‚ÇÉHom f g h = g ‚â´ coeq‚ÇÉHom f g h := by\n  simp only [coeq‚ÇÉHom, ‚Üê Category.assoc, coeq_condition f g]\n\n"}
{"name":"CategoryTheory.IsFiltered.coeq‚ÇÉ_condition‚ÇÇ","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsFilteredOrEmpty C\nj‚ÇÅ j‚ÇÇ : C\nf g h : Quiver.Hom j‚ÇÅ j‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.IsFiltered.coeq‚ÇÉHom f g h)) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.IsFiltered.coeq‚ÇÉHom f g h))","decl":"theorem coeq‚ÇÉ_condition‚ÇÇ {j‚ÇÅ j‚ÇÇ : C} (f g h : j‚ÇÅ ‚ü∂ j‚ÇÇ) :\n    g ‚â´ coeq‚ÇÉHom f g h = h ‚â´ coeq‚ÇÉHom f g h := by\n  dsimp [coeq‚ÇÉHom]\n  slice_lhs 2 4 => rw [‚Üê Category.assoc, coeq_condition _ _]\n  slice_rhs 2 4 => rw [‚Üê Category.assoc, coeq_condition _ _]\n  slice_lhs 1 3 => rw [‚Üê Category.assoc, coeq_condition _ _]\n  simp only [Category.assoc]\n\n"}
{"name":"CategoryTheory.IsFiltered.coeq‚ÇÉ_condition‚ÇÉ","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsFilteredOrEmpty C\nj‚ÇÅ j‚ÇÇ : C\nf g h : Quiver.Hom j‚ÇÅ j‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.IsFiltered.coeq‚ÇÉHom f g h)) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.IsFiltered.coeq‚ÇÉHom f g h))","decl":"theorem coeq‚ÇÉ_condition‚ÇÉ {j‚ÇÅ j‚ÇÇ : C} (f g h : j‚ÇÅ ‚ü∂ j‚ÇÇ) : f ‚â´ coeq‚ÇÉHom f g h = h ‚â´ coeq‚ÇÉHom f g h :=\n  Eq.trans (coeq‚ÇÉ_condition‚ÇÅ f g h) (coeq‚ÇÉ_condition‚ÇÇ f g h)\n\n"}
{"name":"CategoryTheory.IsFiltered.span","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsFilteredOrEmpty C\ni j j' : C\nf : Quiver.Hom i j\nf' : Quiver.Hom i j'\n‚ä¢ Exists fun k => Exists fun g => Exists fun g' => Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f' g')","decl":"/-- For every span `j ‚üµ i ‚ü∂ j'`, there\n   exists a cocone `j ‚ü∂ k ‚üµ j'` such that the square commutes. -/\ntheorem span {i j j' : C} (f : i ‚ü∂ j) (f' : i ‚ü∂ j') :\n    ‚àÉ (k : C) (g : j ‚ü∂ k) (g' : j' ‚ü∂ k), f ‚â´ g = f' ‚â´ g' :=\n  let ‚ü®K, G, G', _‚ü© := IsFilteredOrEmpty.cocone_objs j j'\n  let ‚ü®k, e, he‚ü© := IsFilteredOrEmpty.cocone_maps (f ‚â´ G) (f' ‚â´ G')\n  ‚ü®k, G ‚â´ e, G' ‚â´ e, by simpa only [‚Üê Category.assoc] ‚ü©\n\n"}
{"name":"CategoryTheory.IsFiltered.bowtie","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsFilteredOrEmpty C\nj‚ÇÅ j‚ÇÇ k‚ÇÅ k‚ÇÇ : C\nf‚ÇÅ : Quiver.Hom j‚ÇÅ k‚ÇÅ\ng‚ÇÅ : Quiver.Hom j‚ÇÅ k‚ÇÇ\nf‚ÇÇ : Quiver.Hom j‚ÇÇ k‚ÇÅ\ng‚ÇÇ : Quiver.Hom j‚ÇÇ k‚ÇÇ\n‚ä¢ Exists fun s => Exists fun Œ± => Exists fun Œ≤ => And (Eq (CategoryTheory.CategoryStruct.comp f‚ÇÅ Œ±) (CategoryTheory.CategoryStruct.comp g‚ÇÅ Œ≤)) (Eq (CategoryTheory.CategoryStruct.comp f‚ÇÇ Œ±) (CategoryTheory.CategoryStruct.comp g‚ÇÇ Œ≤))","decl":"/-- Given a \"bowtie\" of morphisms\n```\n j‚ÇÅ   j‚ÇÇ\n |\\  /|\n | \\/ |\n | /\\ |\n |/  \\‚à£\n vv  vv\n k‚ÇÅ  k‚ÇÇ\n```\nin a filtered category, we can construct an object `s` and two morphisms from `k‚ÇÅ` and `k‚ÇÇ` to `s`,\nmaking the resulting squares commute.\n-/\ntheorem bowtie {j‚ÇÅ j‚ÇÇ k‚ÇÅ k‚ÇÇ : C} (f‚ÇÅ : j‚ÇÅ ‚ü∂ k‚ÇÅ) (g‚ÇÅ : j‚ÇÅ ‚ü∂ k‚ÇÇ) (f‚ÇÇ : j‚ÇÇ ‚ü∂ k‚ÇÅ) (g‚ÇÇ : j‚ÇÇ ‚ü∂ k‚ÇÇ) :\n    ‚àÉ (s : C) (Œ± : k‚ÇÅ ‚ü∂ s) (Œ≤ : k‚ÇÇ ‚ü∂ s), f‚ÇÅ ‚â´ Œ± = g‚ÇÅ ‚â´ Œ≤ ‚àß f‚ÇÇ ‚â´ Œ± = g‚ÇÇ ‚â´ Œ≤ := by\n  obtain ‚ü®t, k‚ÇÅt, k‚ÇÇt, ht‚ü© := span f‚ÇÅ g‚ÇÅ\n  obtain ‚ü®s, ts, hs‚ü© := IsFilteredOrEmpty.cocone_maps (f‚ÇÇ ‚â´ k‚ÇÅt) (g‚ÇÇ ‚â´ k‚ÇÇt)\n  simp_rw [Category.assoc] at hs\n  exact ‚ü®s, k‚ÇÅt ‚â´ ts, k‚ÇÇt ‚â´ ts, by simp only [‚Üê Category.assoc, ht], hs‚ü©\n\n"}
{"name":"CategoryTheory.IsFiltered.tulip","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsFilteredOrEmpty C\nj‚ÇÅ j‚ÇÇ j‚ÇÉ k‚ÇÅ k‚ÇÇ l : C\nf‚ÇÅ : Quiver.Hom j‚ÇÅ k‚ÇÅ\nf‚ÇÇ : Quiver.Hom j‚ÇÇ k‚ÇÅ\nf‚ÇÉ : Quiver.Hom j‚ÇÇ k‚ÇÇ\nf‚ÇÑ : Quiver.Hom j‚ÇÉ k‚ÇÇ\ng‚ÇÅ : Quiver.Hom j‚ÇÅ l\ng‚ÇÇ : Quiver.Hom j‚ÇÉ l\n‚ä¢ Exists fun s => Exists fun Œ± => Exists fun Œ≤ => Exists fun Œ≥ => And (Eq (CategoryTheory.CategoryStruct.comp f‚ÇÅ Œ±) (CategoryTheory.CategoryStruct.comp g‚ÇÅ Œ≤)) (And (Eq (CategoryTheory.CategoryStruct.comp f‚ÇÇ Œ±) (CategoryTheory.CategoryStruct.comp f‚ÇÉ Œ≥)) (Eq (CategoryTheory.CategoryStruct.comp f‚ÇÑ Œ≥) (CategoryTheory.CategoryStruct.comp g‚ÇÇ Œ≤)))","decl":"/-- Given a \"tulip\" of morphisms\n```\n j‚ÇÅ    j‚ÇÇ    j‚ÇÉ\n |\\   / \\   / |\n | \\ /   \\ /  |\n |  vv    vv  |\n \\  k‚ÇÅ    k‚ÇÇ /\n  \\         /\n   \\       /\n    \\     /\n     \\   /\n      v v\n       l\n```\nin a filtered category, we can construct an object `s` and three morphisms from `k‚ÇÅ`, `k‚ÇÇ` and `l`\nto `s`, making the resulting squares commute.\n-/\ntheorem tulip {j‚ÇÅ j‚ÇÇ j‚ÇÉ k‚ÇÅ k‚ÇÇ l : C} (f‚ÇÅ : j‚ÇÅ ‚ü∂ k‚ÇÅ) (f‚ÇÇ : j‚ÇÇ ‚ü∂ k‚ÇÅ) (f‚ÇÉ : j‚ÇÇ ‚ü∂ k‚ÇÇ) (f‚ÇÑ : j‚ÇÉ ‚ü∂ k‚ÇÇ)\n    (g‚ÇÅ : j‚ÇÅ ‚ü∂ l) (g‚ÇÇ : j‚ÇÉ ‚ü∂ l) :\n    ‚àÉ (s : C) (Œ± : k‚ÇÅ ‚ü∂ s) (Œ≤ : l ‚ü∂ s) (Œ≥ : k‚ÇÇ ‚ü∂ s),\n      f‚ÇÅ ‚â´ Œ± = g‚ÇÅ ‚â´ Œ≤ ‚àß f‚ÇÇ ‚â´ Œ± = f‚ÇÉ ‚â´ Œ≥ ‚àß f‚ÇÑ ‚â´ Œ≥ = g‚ÇÇ ‚â´ Œ≤ := by\n  obtain ‚ü®l', k‚ÇÅl, k‚ÇÇl, hl‚ü© := span f‚ÇÇ f‚ÇÉ\n  obtain ‚ü®s, ls, l's, hs‚ÇÅ, hs‚ÇÇ‚ü© := bowtie g‚ÇÅ (f‚ÇÅ ‚â´ k‚ÇÅl) g‚ÇÇ (f‚ÇÑ ‚â´ k‚ÇÇl)\n  refine ‚ü®s, k‚ÇÅl ‚â´ l's, ls, k‚ÇÇl ‚â´ l's, ?_, by simp only [‚Üê Category.assoc, hl], ?_‚ü© <;>\n    simp only [hs‚ÇÅ, hs‚ÇÇ, Category.assoc]\n\n"}
{"name":"CategoryTheory.IsCofilteredOrEmpty.cone_maps","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.IsCofilteredOrEmpty C\nX Y : C\nf g : Quiver.Hom X Y\n‚ä¢ Exists fun W => Exists fun h => Eq (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp h g)","decl":"/-- A category `IsCofilteredOrEmpty` if\n1. for every pair of objects there exists another object \"to the left\", and\n2. for every pair of parallel morphisms there exists a morphism to the left so the compositions\n   are equal.\n-/\nclass IsCofilteredOrEmpty : Prop where\n  /-- for every pair of objects there exists another object \"to the left\" -/\n  cone_objs : ‚àÄ X Y : C, ‚àÉ (W : _) (_ : W ‚ü∂ X) (_ : W ‚ü∂ Y), True\n  /-- for every pair of parallel morphisms there exists a morphism to the left\n    so the compositions are equal -/\n  cone_maps : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f g : X ‚ü∂ Y), ‚àÉ (W : _) (h : W ‚ü∂ X), h ‚â´ f = h ‚â´ g\n\n"}
{"name":"CategoryTheory.IsCofilteredOrEmpty.cone_objs","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.IsCofilteredOrEmpty C\nX Y : C\n‚ä¢ Exists fun W => Exists fun x => Exists fun x => True","decl":"/-- A category `IsCofilteredOrEmpty` if\n1. for every pair of objects there exists another object \"to the left\", and\n2. for every pair of parallel morphisms there exists a morphism to the left so the compositions\n   are equal.\n-/\nclass IsCofilteredOrEmpty : Prop where\n  /-- for every pair of objects there exists another object \"to the left\" -/\n  cone_objs : ‚àÄ X Y : C, ‚àÉ (W : _) (_ : W ‚ü∂ X) (_ : W ‚ü∂ Y), True\n  /-- for every pair of parallel morphisms there exists a morphism to the left\n    so the compositions are equal -/\n  cone_maps : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f g : X ‚ü∂ Y), ‚àÉ (W : _) (h : W ‚ü∂ X), h ‚â´ f = h ‚â´ g\n\n"}
{"name":"CategoryTheory.IsCofiltered.nonempty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.IsCofiltered C\n‚ä¢ Nonempty C","decl":"/-- A category `IsCofiltered` if\n1. for every pair of objects there exists another object \"to the left\",\n2. for every pair of parallel morphisms there exists a morphism to the left so the compositions\n   are equal, and\n3. there exists some object. -/\n@[stacks 04AZ]\nclass IsCofiltered extends IsCofilteredOrEmpty C : Prop where\n  /-- a cofiltered category must be non empty -/\n  [nonempty : Nonempty C]\n\n"}
{"name":"CategoryTheory.IsCofiltered.toIsCofilteredOrEmpty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.IsCofiltered C\n‚ä¢ CategoryTheory.IsCofilteredOrEmpty C","decl":"/-- A category `IsCofiltered` if\n1. for every pair of objects there exists another object \"to the left\",\n2. for every pair of parallel morphisms there exists a morphism to the left so the compositions\n   are equal, and\n3. there exists some object. -/\n@[stacks 04AZ]\nclass IsCofiltered extends IsCofilteredOrEmpty C : Prop where\n  /-- a cofiltered category must be non empty -/\n  [nonempty : Nonempty C]\n\n"}
{"name":"CategoryTheory.isCofilteredOrEmpty_of_semilatticeInf","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"Œ± : Type u\ninst‚úù : SemilatticeInf Œ±\n‚ä¢ CategoryTheory.IsCofilteredOrEmpty Œ±","decl":"instance (priority := 100) isCofilteredOrEmpty_of_semilatticeInf (Œ± : Type u) [SemilatticeInf Œ±] :\n    IsCofilteredOrEmpty Œ± where\n  cone_objs X Y := ‚ü®X ‚äì Y, homOfLE inf_le_left, homOfLE inf_le_right, trivial‚ü©\n  cone_maps X Y f g := ‚ü®X, ùüô _, by\n    apply ULift.ext\n    subsingleton‚ü©\n\n"}
{"name":"CategoryTheory.isCofiltered_of_semilatticeInf_nonempty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬π : SemilatticeInf Œ±\ninst‚úù : Nonempty Œ±\n‚ä¢ CategoryTheory.IsCofiltered Œ±","decl":"instance (priority := 100) isCofiltered_of_semilatticeInf_nonempty (Œ± : Type u) [SemilatticeInf Œ±]\n    [Nonempty Œ±] : IsCofiltered Œ± where\n\n"}
{"name":"CategoryTheory.isCofilteredOrEmpty_of_directed_ge","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\n‚ä¢ CategoryTheory.IsCofilteredOrEmpty Œ±","decl":"instance (priority := 100) isCofilteredOrEmpty_of_directed_ge (Œ± : Type u) [Preorder Œ±]\n    [IsDirected Œ± (¬∑ ‚â• ¬∑)] : IsCofilteredOrEmpty Œ± where\n  cone_objs X Y :=\n    let ‚ü®Z, hX, hY‚ü© := exists_le_le X Y\n    ‚ü®Z, homOfLE hX, homOfLE hY, trivial‚ü©\n  cone_maps X Y f g := ‚ü®X, ùüô _, by\n    apply ULift.ext\n    subsingleton‚ü©\n\n"}
{"name":"CategoryTheory.isCofiltered_of_directed_ge_nonempty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\ninst‚úù : Nonempty Œ±\n‚ä¢ CategoryTheory.IsCofiltered Œ±","decl":"instance (priority := 100) isCofiltered_of_directed_ge_nonempty (Œ± : Type u) [Preorder Œ±]\n    [IsDirected Œ± (¬∑ ‚â• ¬∑)] [Nonempty Œ±] : IsCofiltered Œ± where\n\n-- Sanity checks\n"}
{"name":"CategoryTheory.instIsCofilteredDiscretePUnit","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"‚ä¢ CategoryTheory.IsCofiltered (CategoryTheory.Discrete PUnit.{u_1 + 1})","decl":"instance : IsCofiltered (Discrete PUnit) where\n  cone_objs _ Y := ‚ü®‚ü®PUnit.unit‚ü©, ‚ü®‚ü®by trivial‚ü©‚ü©, ‚ü®‚ü®by subsingleton‚ü©‚ü©, trivial‚ü©\n  cone_maps X Y f g := ‚ü®‚ü®PUnit.unit‚ü©, ‚ü®‚ü®by trivial‚ü©‚ü©, by\n    apply ULift.ext\n    subsingleton‚ü©\n\n"}
{"name":"CategoryTheory.IsCofiltered.eq_condition_assoc","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsCofilteredOrEmpty C\nj j' : C\nf f' : Quiver.Hom j j'\nZ : C\nh : Quiver.Hom j' Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsCofiltered.eqHom f f') (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsCofiltered.eqHom f f') (CategoryTheory.CategoryStruct.comp f' h))","decl":"/-- `eq_condition f f'`, for morphisms `f f' : j ‚ü∂ j'`, is the proof that\n`eqHom f f' ‚â´ f = eqHom f f' ‚â´ f'`.\n-/\n@[reassoc]\ntheorem eq_condition {j j' : C} (f f' : j ‚ü∂ j') : eqHom f f' ‚â´ f = eqHom f f' ‚â´ f' :=\n  (IsCofilteredOrEmpty.cone_maps f f').choose_spec.choose_spec\n\n"}
{"name":"CategoryTheory.IsCofiltered.eq_condition","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsCofilteredOrEmpty C\nj j' : C\nf f' : Quiver.Hom j j'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsCofiltered.eqHom f f') f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsCofiltered.eqHom f f') f')","decl":"/-- `eq_condition f f'`, for morphisms `f f' : j ‚ü∂ j'`, is the proof that\n`eqHom f f' ‚â´ f = eqHom f f' ‚â´ f'`.\n-/\n@[reassoc]\ntheorem eq_condition {j j' : C} (f f' : j ‚ü∂ j') : eqHom f f' ‚â´ f = eqHom f f' ‚â´ f' :=\n  (IsCofilteredOrEmpty.cone_maps f f').choose_spec.choose_spec\n\n"}
{"name":"CategoryTheory.IsCofiltered.cospan","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsCofilteredOrEmpty C\ni j j' : C\nf : Quiver.Hom j i\nf' : Quiver.Hom j' i\n‚ä¢ Exists fun k => Exists fun g => Exists fun g' => Eq (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.comp g' f')","decl":"/-- For every cospan `j ‚ü∂ i ‚üµ j'`,\n there exists a cone `j ‚üµ k ‚ü∂ j'` such that the square commutes. -/\ntheorem cospan {i j j' : C} (f : j ‚ü∂ i) (f' : j' ‚ü∂ i) :\n    ‚àÉ (k : C) (g : k ‚ü∂ j) (g' : k ‚ü∂ j'), g ‚â´ f = g' ‚â´ f' :=\n  let ‚ü®K, G, G', _‚ü© := IsCofilteredOrEmpty.cone_objs j j'\n  let ‚ü®k, e, he‚ü© := IsCofilteredOrEmpty.cone_maps (G ‚â´ f) (G' ‚â´ f')\n  ‚ü®k, e ‚â´ G, e ‚â´ G', by simpa only [Category.assoc] using he‚ü©\n\n"}
{"name":"CategoryTheory.Functor.ranges_directed","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsCofilteredOrEmpty C\nF : CategoryTheory.Functor C (Type u_1)\nj : C\n‚ä¢ Directed (fun x1 x2 => Superset x1 x2) fun f => Set.range (F.map f.snd)","decl":"theorem _root_.CategoryTheory.Functor.ranges_directed (F : C ‚•§ Type*) (j : C) :\n    Directed (¬∑ ‚äá ¬∑) fun f : Œ£'i, i ‚ü∂ j => Set.range (F.map f.2) := fun ‚ü®i, ij‚ü© ‚ü®k, kj‚ü© => by\n  let ‚ü®l, li, lk, e‚ü© := cospan ij kj\n  refine ‚ü®‚ü®l, lk ‚â´ kj‚ü©, e ‚ñ∏ ?_, ?_‚ü© <;> simp_rw [F.map_comp] <;> apply Set.range_comp_subset_range\n\n"}
{"name":"CategoryTheory.IsCofiltered.bowtie","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsCofilteredOrEmpty C\nj‚ÇÅ j‚ÇÇ k‚ÇÅ k‚ÇÇ : C\nf‚ÇÅ : Quiver.Hom k‚ÇÅ j‚ÇÅ\ng‚ÇÅ : Quiver.Hom k‚ÇÇ j‚ÇÅ\nf‚ÇÇ : Quiver.Hom k‚ÇÅ j‚ÇÇ\ng‚ÇÇ : Quiver.Hom k‚ÇÇ j‚ÇÇ\n‚ä¢ Exists fun s => Exists fun Œ± => Exists fun Œ≤ => And (Eq (CategoryTheory.CategoryStruct.comp Œ± f‚ÇÅ) (CategoryTheory.CategoryStruct.comp Œ≤ g‚ÇÅ)) (Eq (CategoryTheory.CategoryStruct.comp Œ± f‚ÇÇ) (CategoryTheory.CategoryStruct.comp Œ≤ g‚ÇÇ))","decl":"/-- Given a \"bowtie\" of morphisms\n```\n k‚ÇÅ   k‚ÇÇ\n |\\  /|\n | \\/ |\n | /\\ |\n |/  \\‚à£\n vv  vv\n j‚ÇÅ  j‚ÇÇ\n```\nin a cofiltered category, we can construct an object `s` and two morphisms\nfrom `s` to `k‚ÇÅ` and `k‚ÇÇ`, making the resulting squares commute.\n-/\ntheorem bowtie {j‚ÇÅ j‚ÇÇ k‚ÇÅ k‚ÇÇ : C} (f‚ÇÅ : k‚ÇÅ ‚ü∂ j‚ÇÅ) (g‚ÇÅ : k‚ÇÇ ‚ü∂ j‚ÇÅ) (f‚ÇÇ : k‚ÇÅ ‚ü∂ j‚ÇÇ) (g‚ÇÇ : k‚ÇÇ ‚ü∂ j‚ÇÇ) :\n    ‚àÉ (s : C) (Œ± : s ‚ü∂ k‚ÇÅ) (Œ≤ : s ‚ü∂ k‚ÇÇ), Œ± ‚â´ f‚ÇÅ = Œ≤ ‚â´ g‚ÇÅ ‚àß Œ± ‚â´ f‚ÇÇ = Œ≤ ‚â´ g‚ÇÇ := by\n  obtain ‚ü®t, k‚ÇÅt, k‚ÇÇt, ht‚ü© := cospan f‚ÇÅ g‚ÇÅ\n  obtain ‚ü®s, ts, hs‚ü© := IsCofilteredOrEmpty.cone_maps (k‚ÇÅt ‚â´ f‚ÇÇ) (k‚ÇÇt ‚â´ g‚ÇÇ)\n  exact ‚ü®s, ts ‚â´ k‚ÇÅt, ts ‚â´ k‚ÇÇt, by simp only [Category.assoc, ht],\n    by simp only [Category.assoc, hs]‚ü©\n\n"}
{"name":"CategoryTheory.IsCofilteredOrEmpty.of_left_adjoint","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.IsCofilteredOrEmpty C\nD : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\n‚ä¢ CategoryTheory.IsCofilteredOrEmpty D","decl":"/-- If `C` is cofiltered or empty, and we have a functor `L : C ‚•§ D` with a right adjoint,\nthen `D` is cofiltered or empty.\n-/\ntheorem of_left_adjoint {L : C ‚•§ D} {R : D ‚•§ C} (h : L ‚ä£ R) : IsCofilteredOrEmpty D :=\n  { cone_objs := fun X Y =>\n      ‚ü®L.obj (min (R.obj X) (R.obj Y)), (h.homEquiv _ X).symm (minToLeft _ _),\n        (h.homEquiv _ Y).symm (minToRight _ _), ‚ü®‚ü©‚ü©\n    cone_maps := fun X Y f g =>\n      ‚ü®L.obj (eq (R.map f) (R.map g)), (h.homEquiv _ _).symm (eqHom _ _), by\n        rw [‚Üê h.homEquiv_naturality_right_symm, ‚Üê h.homEquiv_naturality_right_symm, eq_condition]‚ü© }\n\n"}
{"name":"CategoryTheory.IsCofilteredOrEmpty.of_isLeftAdjoint","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.IsCofilteredOrEmpty C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nL : CategoryTheory.Functor C D\ninst‚úù : L.IsLeftAdjoint\n‚ä¢ CategoryTheory.IsCofilteredOrEmpty D","decl":"/-- If `C` is cofiltered or empty, and we have a left adjoint functor `L : C ‚•§ D`, then `D` is\ncofiltered or empty. -/\ntheorem of_isLeftAdjoint (L : C ‚•§ D) [L.IsLeftAdjoint] : IsCofilteredOrEmpty D :=\n  of_left_adjoint (Adjunction.ofIsLeftAdjoint L)\n\n"}
{"name":"CategoryTheory.IsCofilteredOrEmpty.of_equivalence","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.IsCofilteredOrEmpty C\nD : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nh : CategoryTheory.Equivalence C D\n‚ä¢ CategoryTheory.IsCofilteredOrEmpty D","decl":"/-- Being cofiltered or empty is preserved by equivalence of categories. -/\ntheorem of_equivalence (h : C ‚âå D) : IsCofilteredOrEmpty D :=\n  of_left_adjoint h.toAdjunction\n\n"}
{"name":"CategoryTheory.IsCofiltered.inf_objs_exists","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsCofiltered C\nO : Finset C\n‚ä¢ Exists fun S => ‚àÄ {X : C}, Membership.mem O X ‚Üí Nonempty (Quiver.Hom S X)","decl":"/-- Any finite collection of objects in a cofiltered category has an object \"to the left\".\n-/\ntheorem inf_objs_exists (O : Finset C) : ‚àÉ S : C, ‚àÄ {X}, X ‚àà O ‚Üí Nonempty (S ‚ü∂ X) := by\n  classical\n  induction' O using Finset.induction with X O' nm h\n  ¬∑ exact ‚ü®Classical.choice IsCofiltered.nonempty, by intro; simp‚ü©\n  ¬∑ obtain ‚ü®S', w'‚ü© := h\n    use min X S'\n    rintro Y mY\n    obtain rfl | h := eq_or_ne Y X\n    ¬∑ exact ‚ü®minToLeft _ _‚ü©\n    ¬∑ exact ‚ü®minToRight _ _ ‚â´ (w' (Finset.mem_of_mem_insert_of_ne mY h)).some‚ü©\n\n"}
{"name":"CategoryTheory.IsCofiltered.inf_exists","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsCofiltered C\nO : Finset C\nH : Finset (PSigma fun X => PSigma fun Y => PSigma fun x => PSigma fun x => Quiver.Hom X Y)\n‚ä¢ Exists fun S => Exists fun T => ‚àÄ {X Y : C} (mX : Membership.mem O X) (mY : Membership.mem O Y) {f : Quiver.Hom X Y}, Membership.mem H ‚ü®X, ‚ü®Y, ‚ü®mX, ‚ü®mY, f‚ü©‚ü©‚ü©‚ü© ‚Üí Eq (CategoryTheory.CategoryStruct.comp (T mX) f) (T mY)","decl":"/-- Given any `Finset` of objects `{X, ...}` and\nindexed collection of `Finset`s of morphisms `{f, ...}` in `C`,\nthere exists an object `S`, with a morphism `T X : S ‚ü∂ X` from each `X`,\nsuch that the triangles commute: `T X ‚â´ f = T Y`, for `f : X ‚ü∂ Y` in the `Finset`.\n-/\ntheorem inf_exists :\n    ‚àÉ (S : C) (T : ‚àÄ {X : C}, X ‚àà O ‚Üí (S ‚ü∂ X)),\n      ‚àÄ {X Y : C} (mX : X ‚àà O) (mY : Y ‚àà O) {f : X ‚ü∂ Y},\n        (‚ü®X, Y, mX, mY, f‚ü© : Œ£' (X Y : C) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) ‚àà H ‚Üí\n          T mX ‚â´ f = T mY := by\n  classical\n  induction' H using Finset.induction with h' H' nmf h''\n  ¬∑ obtain ‚ü®S, f‚ü© := inf_objs_exists O\n    exact ‚ü®S, fun mX => (f mX).some, by rintro - - - - - ‚ü®‚ü©‚ü©\n  ¬∑ obtain ‚ü®X, Y, mX, mY, f‚ü© := h'\n    obtain ‚ü®S', T', w'‚ü© := h''\n    refine ‚ü®eq (T' mX ‚â´ f) (T' mY), fun mZ => eqHom (T' mX ‚â´ f) (T' mY) ‚â´ T' mZ, ?_‚ü©\n    intro X' Y' mX' mY' f' mf'\n    rw [Category.assoc]\n    by_cases h : X = X' ‚àß Y = Y'\n    ¬∑ rcases h with ‚ü®rfl, rfl‚ü©\n      by_cases hf : f = f'\n      ¬∑ subst hf\n        apply eq_condition\n      ¬∑ rw [@w' _ _ mX mY f']\n        simp only [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, true_and] at mf'\n        rcases mf' with mf' | mf'\n        ¬∑ exfalso\n          exact hf mf'.symm\n        ¬∑ exact mf'\n    ¬∑ rw [@w' _ _ mX' mY' f' _]\n      apply Finset.mem_of_mem_insert_of_ne mf'\n      contrapose! h\n      obtain ‚ü®rfl, h‚ü© := h\n      trivial\n\n"}
{"name":"CategoryTheory.IsCofiltered.infTo_commutes","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsCofiltered C\nO : Finset C\nH : Finset (PSigma fun X => PSigma fun Y => PSigma fun x => PSigma fun x => Quiver.Hom X Y)\nX Y : C\nmX : Membership.mem O X\nmY : Membership.mem O Y\nf : Quiver.Hom X Y\nmf : Membership.mem H ‚ü®X, ‚ü®Y, ‚ü®mX, ‚ü®mY, f‚ü©‚ü©‚ü©‚ü©\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsCofiltered.infTo O H mX) f) (CategoryTheory.IsCofiltered.infTo O H mY)","decl":"/-- The triangles consisting of a morphism in `H` and the maps from `inf O H` commute.\n-/\ntheorem infTo_commutes {X Y : C} (mX : X ‚àà O) (mY : Y ‚àà O) {f : X ‚ü∂ Y}\n    (mf : (‚ü®X, Y, mX, mY, f‚ü© : Œ£' (X Y : C) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) ‚àà H) :\n    infTo O H mX ‚â´ f = infTo O H mY :=\n  (inf_exists O H).choose_spec.choose_spec mX mY mf\n\n"}
{"name":"CategoryTheory.IsCofiltered.cone_nonempty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.IsCofiltered C\nJ : Type w\ninst‚úù¬π : CategoryTheory.SmallCategory J\ninst‚úù : CategoryTheory.FinCategory J\nF : CategoryTheory.Functor J C\n‚ä¢ Nonempty (CategoryTheory.Limits.Cone F)","decl":"/-- If we have `IsCofiltered C`, then for any functor `F : J ‚•§ C` with `FinCategory J`,\nthere exists a cone over `F`.\n-/\ntheorem cone_nonempty (F : J ‚•§ C) : Nonempty (Cone F) := by\n  classical\n  let O := Finset.univ.image F.obj\n  let H : Finset (Œ£' (X Y : C) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) :=\n    Finset.univ.biUnion fun X : J =>\n      Finset.univ.biUnion fun Y : J =>\n        Finset.univ.image fun f : X ‚ü∂ Y => ‚ü®F.obj X, F.obj Y, by simp [O], by simp [O], F.map f‚ü©\n  obtain ‚ü®Z, f, w‚ü© := inf_exists O H\n  refine ‚ü®‚ü®Z, ‚ü®fun X => f (by simp [O]), ?_‚ü©‚ü©‚ü©\n  intro j j' g\n  dsimp\n  simp only [Category.id_comp]\n  symm\n  apply w\n  simp only [O, H, Finset.mem_biUnion, Finset.mem_univ, Finset.mem_image,\n    PSigma.mk.injEq, true_and, exists_and_left]\n  exact ‚ü®j, rfl, j', g, by simp‚ü©\n\n"}
{"name":"CategoryTheory.IsCofiltered.of_left_adjoint","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.IsCofiltered C\nD : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\n‚ä¢ CategoryTheory.IsCofiltered D","decl":"/-- If `C` is cofiltered, and we have a functor `L : C ‚•§ D` with a right adjoint,\nthen `D` is cofiltered.\n-/\ntheorem of_left_adjoint {L : C ‚•§ D} {R : D ‚•§ C} (h : L ‚ä£ R) : IsCofiltered D :=\n  { IsCofilteredOrEmpty.of_left_adjoint h with\n    nonempty := IsCofiltered.nonempty.map L.obj }\n\n"}
{"name":"CategoryTheory.IsCofiltered.of_isLeftAdjoint","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.IsCofiltered C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nL : CategoryTheory.Functor C D\ninst‚úù : L.IsLeftAdjoint\n‚ä¢ CategoryTheory.IsCofiltered D","decl":"/-- If `C` is cofiltered, and we have a left adjoint functor `L : C ‚•§ D`, then `D` is cofiltered. -/\ntheorem of_isLeftAdjoint (L : C ‚•§ D) [L.IsLeftAdjoint] : IsCofiltered D :=\n  of_left_adjoint (Adjunction.ofIsLeftAdjoint L)\n\n"}
{"name":"CategoryTheory.IsCofiltered.of_equivalence","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.IsCofiltered C\nD : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nh : CategoryTheory.Equivalence C D\n‚ä¢ CategoryTheory.IsCofiltered D","decl":"/-- Being cofiltered is preserved by equivalence of categories. -/\ntheorem of_equivalence (h : C ‚âå D) : IsCofiltered D :=\n  of_left_adjoint h.toAdjunction\n\n"}
{"name":"CategoryTheory.IsCofiltered.of_cone_nonempty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nh : ‚àÄ {J : Type w} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] (F : CategoryTheory.Functor J C), Nonempty (CategoryTheory.Limits.Cone F)\n‚ä¢ CategoryTheory.IsCofiltered C","decl":"/-- If every finite diagram in `C` admits a cone, then `C` is cofiltered. It is sufficient to\n    verify this for diagrams whose shape lives in any one fixed universe. -/\ntheorem of_cone_nonempty (h : ‚àÄ {J : Type w} [SmallCategory J] [FinCategory J] (F : J ‚•§ C),\n    Nonempty (Cone F)) : IsCofiltered C := by\n  have : Nonempty C := by\n    obtain ‚ü®c‚ü© := h (Functor.empty _)\n    exact ‚ü®c.pt‚ü©\n  have : IsCofilteredOrEmpty C := by\n    refine ‚ü®?_, ?_‚ü©\n    ¬∑ intros X Y\n      obtain ‚ü®c‚ü© := h (ULiftHom.down ‚ãô ULift.downFunctor ‚ãô pair X Y)\n      exact ‚ü®c.pt, c.œÄ.app ‚ü®‚ü®WalkingPair.left‚ü©‚ü©, c.œÄ.app ‚ü®‚ü®WalkingPair.right‚ü©‚ü©, trivial‚ü©\n    ¬∑ intros X Y f g\n      obtain ‚ü®c‚ü© := h (ULiftHom.down ‚ãô ULift.downFunctor ‚ãô parallelPair f g)\n      refine ‚ü®c.pt, c.œÄ.app ‚ü®WalkingParallelPair.zero‚ü©, ?_‚ü©\n      have h‚ÇÅ := c.œÄ.naturality ‚ü®WalkingParallelPairHom.left‚ü©\n      have h‚ÇÇ := c.œÄ.naturality ‚ü®WalkingParallelPairHom.right‚ü©\n      simp_all\n  apply IsCofiltered.mk\n\n"}
{"name":"CategoryTheory.IsCofiltered.of_hasFiniteLimits","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasFiniteLimits C\n‚ä¢ CategoryTheory.IsCofiltered C","decl":"theorem of_hasFiniteLimits [HasFiniteLimits C] : IsCofiltered C :=\n  of_cone_nonempty.{v} C fun F => ‚ü®limit.cone F‚ü©\n\n"}
{"name":"CategoryTheory.IsCofiltered.of_isInitial","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nh : CategoryTheory.Limits.IsInitial X\n‚ä¢ CategoryTheory.IsCofiltered C","decl":"theorem of_isInitial {X : C} (h : IsInitial X) : IsCofiltered C :=\n  of_cone_nonempty.{v} _ fun {_} _ _ _ => ‚ü®‚ü®X, ‚ü®fun _ => h.to _, fun _ _ _ => h.hom_ext _ _‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.IsCofiltered.of_hasInitial","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasInitial C\n‚ä¢ CategoryTheory.IsCofiltered C","decl":"instance (priority := 100) of_hasInitial [HasInitial C] : IsCofiltered C :=\n  of_isInitial _ initialIsInitial\n\n"}
{"name":"CategoryTheory.IsCofiltered.iff_cone_nonempty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Iff (CategoryTheory.IsCofiltered C) (‚àÄ {J : Type w} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] (F : CategoryTheory.Functor J C), Nonempty (CategoryTheory.Limits.Cone F))","decl":"/-- For every universe `w`, `C` is filtered if and only if every finite diagram in `C` with shape\n    in `w` admits a cocone. -/\ntheorem iff_cone_nonempty : IsCofiltered C ‚Üî\n    ‚àÄ {J : Type w} [SmallCategory J] [FinCategory J] (F : J ‚•§ C), Nonempty (Cone F) :=\n  ‚ü®fun _ _ _ _ F => cone_nonempty F, of_cone_nonempty C‚ü©\n\n"}
{"name":"CategoryTheory.isCofilteredOrEmpty_op_of_isFilteredOrEmpty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsFilteredOrEmpty C\n‚ä¢ CategoryTheory.IsCofilteredOrEmpty (Opposite C)","decl":"instance isCofilteredOrEmpty_op_of_isFilteredOrEmpty [IsFilteredOrEmpty C] :\n    IsCofilteredOrEmpty C·µí·µñ where\n  cone_objs X Y :=\n    ‚ü®op (IsFiltered.max X.unop Y.unop), (IsFiltered.leftToMax _ _).op,\n      (IsFiltered.rightToMax _ _).op, trivial‚ü©\n  cone_maps X Y f g :=\n    ‚ü®op (IsFiltered.coeq f.unop g.unop), (IsFiltered.coeqHom _ _).op, by\n      rw [show f = f.unop.op by simp, show g = g.unop.op by simp, ‚Üê op_comp, ‚Üê op_comp]\n      congr 1\n      exact IsFiltered.coeq_condition f.unop g.unop‚ü©\n\n"}
{"name":"CategoryTheory.isCofiltered_op_of_isFiltered","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsFiltered C\n‚ä¢ CategoryTheory.IsCofiltered (Opposite C)","decl":"instance isCofiltered_op_of_isFiltered [IsFiltered C] : IsCofiltered C·µí·µñ where\n  nonempty := letI : Nonempty C := IsFiltered.nonempty; inferInstance\n\n"}
{"name":"CategoryTheory.isFilteredOrEmpty_op_of_isCofilteredOrEmpty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsCofilteredOrEmpty C\n‚ä¢ CategoryTheory.IsFilteredOrEmpty (Opposite C)","decl":"instance isFilteredOrEmpty_op_of_isCofilteredOrEmpty [IsCofilteredOrEmpty C] :\n    IsFilteredOrEmpty C·µí·µñ where\n  cocone_objs X Y :=\n    ‚ü®op (IsCofiltered.min X.unop Y.unop), (IsCofiltered.minToLeft X.unop Y.unop).op,\n      (IsCofiltered.minToRight X.unop Y.unop).op, trivial‚ü©\n  cocone_maps X Y f g :=\n    ‚ü®op (IsCofiltered.eq f.unop g.unop), (IsCofiltered.eqHom f.unop g.unop).op, by\n      rw [show f = f.unop.op by simp, show g = g.unop.op by simp, ‚Üê op_comp, ‚Üê op_comp]\n      congr 1\n      exact IsCofiltered.eq_condition f.unop g.unop‚ü©\n\n"}
{"name":"CategoryTheory.isFiltered_op_of_isCofiltered","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsCofiltered C\n‚ä¢ CategoryTheory.IsFiltered (Opposite C)","decl":"instance isFiltered_op_of_isCofiltered [IsCofiltered C] : IsFiltered C·µí·µñ where\n  nonempty := letI : Nonempty C := IsCofiltered.nonempty; inferInstance\n\n"}
{"name":"CategoryTheory.isCofilteredOrEmpty_of_isFilteredOrEmpty_op","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsFilteredOrEmpty (Opposite C)\n‚ä¢ CategoryTheory.IsCofilteredOrEmpty C","decl":"/-- If C·µí·µñ is filtered or empty, then C is cofiltered or empty. -/\nlemma isCofilteredOrEmpty_of_isFilteredOrEmpty_op [IsFilteredOrEmpty C·µí·µñ] : IsCofilteredOrEmpty C :=\n  IsCofilteredOrEmpty.of_equivalence (opOpEquivalence _)\n\n"}
{"name":"CategoryTheory.isFilteredOrEmpty_of_isCofilteredOrEmpty_op","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsCofilteredOrEmpty (Opposite C)\n‚ä¢ CategoryTheory.IsFilteredOrEmpty C","decl":"/-- If C·µí·µñ is cofiltered or empty, then C is filtered or empty. -/\nlemma isFilteredOrEmpty_of_isCofilteredOrEmpty_op [IsCofilteredOrEmpty C·µí·µñ] : IsFilteredOrEmpty C :=\n  IsFilteredOrEmpty.of_equivalence (opOpEquivalence _)\n\n"}
{"name":"CategoryTheory.isCofiltered_of_isFiltered_op","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsFiltered (Opposite C)\n‚ä¢ CategoryTheory.IsCofiltered C","decl":"/-- If C·µí·µñ is filtered, then C is cofiltered. -/\nlemma isCofiltered_of_isFiltered_op [IsFiltered C·µí·µñ] : IsCofiltered C :=\n  IsCofiltered.of_equivalence (opOpEquivalence _)\n\n"}
{"name":"CategoryTheory.isFiltered_of_isCofiltered_op","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsCofiltered (Opposite C)\n‚ä¢ CategoryTheory.IsFiltered C","decl":"/-- If C·µí·µñ is cofiltered, then C is filtered. -/\nlemma isFiltered_of_isCofiltered_op [IsCofiltered C·µí·µñ] : IsFiltered C :=\n  IsFiltered.of_equivalence (opOpEquivalence _)\n\n"}
{"name":"CategoryTheory.instIsFilteredULift","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsFiltered C\n‚ä¢ CategoryTheory.IsFiltered (ULift.{u‚ÇÇ, u} C)","decl":"instance [IsFiltered C] : IsFiltered (ULift.{u‚ÇÇ} C) :=\n  IsFiltered.of_equivalence ULift.equivalence\n\n"}
{"name":"CategoryTheory.instIsCofilteredULift","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsCofiltered C\n‚ä¢ CategoryTheory.IsCofiltered (ULift.{u‚ÇÇ, u} C)","decl":"instance [IsCofiltered C] : IsCofiltered (ULift.{u‚ÇÇ} C) :=\n  IsCofiltered.of_equivalence ULift.equivalence\n\n"}
{"name":"CategoryTheory.instIsFilteredULiftHom","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsFiltered C\n‚ä¢ CategoryTheory.IsFiltered (CategoryTheory.ULiftHom C)","decl":"instance [IsFiltered C] : IsFiltered (ULiftHom C) :=\n  IsFiltered.of_equivalence ULiftHom.equiv\n\n"}
{"name":"CategoryTheory.instIsCofilteredULiftHom","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsCofiltered C\n‚ä¢ CategoryTheory.IsCofiltered (CategoryTheory.ULiftHom C)","decl":"instance [IsCofiltered C] : IsCofiltered (ULiftHom C) :=\n  IsCofiltered.of_equivalence ULiftHom.equiv\n\n"}
{"name":"CategoryTheory.instIsFilteredAsSmall","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsFiltered C\n‚ä¢ CategoryTheory.IsFiltered (CategoryTheory.AsSmall C)","decl":"instance [IsFiltered C] : IsFiltered (AsSmall C) :=\n  IsFiltered.of_equivalence AsSmall.equiv\n\n"}
{"name":"CategoryTheory.instIsCofilteredAsSmall","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.IsCofiltered C\n‚ä¢ CategoryTheory.IsCofiltered (CategoryTheory.AsSmall C)","decl":"instance [IsCofiltered C] : IsCofiltered (AsSmall C) :=\n  IsCofiltered.of_equivalence AsSmall.equiv\n\n"}
{"name":"CategoryTheory.instIsFilteredOrEmptyForall","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"Œ± : Type w\nI : Œ± ‚Üí Type u‚ÇÅ\ninst‚úù¬π : (i : Œ±) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (I i)\ninst‚úù : ‚àÄ (i : Œ±), CategoryTheory.IsFilteredOrEmpty (I i)\n‚ä¢ CategoryTheory.IsFilteredOrEmpty ((i : Œ±) ‚Üí I i)","decl":"open IsFiltered in\ninstance [‚àÄ i, IsFilteredOrEmpty (I i)] : IsFilteredOrEmpty (‚àÄ i, I i) where\n  cocone_objs k l := ‚ü®fun s => max (k s) (l s), fun s => leftToMax (k s) (l s),\n    fun s => rightToMax (k s) (l s), trivial‚ü©\n  cocone_maps k l f g := ‚ü®fun s => coeq (f s) (g s), fun s => coeqHom (f s) (g s),\n    funext fun s => by simp [coeq_condition (f s) (g s)]‚ü©\n\n"}
{"name":"CategoryTheory.instIsFilteredForall","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"Œ± : Type w\nI : Œ± ‚Üí Type u‚ÇÅ\ninst‚úù¬π : (i : Œ±) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (I i)\ninst‚úù : ‚àÄ (i : Œ±), CategoryTheory.IsFiltered (I i)\n‚ä¢ CategoryTheory.IsFiltered ((i : Œ±) ‚Üí I i)","decl":"attribute [local instance] IsFiltered.nonempty in\ninstance [‚àÄ i, IsFiltered (I i)] : IsFiltered (‚àÄ i, I i) where\n\n"}
{"name":"CategoryTheory.instIsCofilteredOrEmptyForall","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"Œ± : Type w\nI : Œ± ‚Üí Type u‚ÇÅ\ninst‚úù¬π : (i : Œ±) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (I i)\ninst‚úù : ‚àÄ (i : Œ±), CategoryTheory.IsCofilteredOrEmpty (I i)\n‚ä¢ CategoryTheory.IsCofilteredOrEmpty ((i : Œ±) ‚Üí I i)","decl":"open IsCofiltered in\ninstance [‚àÄ i, IsCofilteredOrEmpty (I i)] : IsCofilteredOrEmpty (‚àÄ i, I i) where\n  cone_objs k l := ‚ü®fun s => min (k s) (l s), fun s => minToLeft (k s) (l s),\n    fun s => minToRight (k s) (l s), trivial‚ü©\n  cone_maps k l f g := ‚ü®fun s => eq (f s) (g s), fun s => eqHom (f s) (g s),\n    funext fun s => by simp [eq_condition (f s) (g s)]‚ü©\n\n"}
{"name":"CategoryTheory.instIsCofilteredForall","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"Œ± : Type w\nI : Œ± ‚Üí Type u‚ÇÅ\ninst‚úù¬π : (i : Œ±) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (I i)\ninst‚úù : ‚àÄ (i : Œ±), CategoryTheory.IsCofiltered (I i)\n‚ä¢ CategoryTheory.IsCofiltered ((i : Œ±) ‚Üí I i)","decl":"attribute [local instance] IsCofiltered.nonempty in\ninstance [‚àÄ i, IsCofiltered (I i)] : IsCofiltered (‚àÄ i, I i) where\n\n"}
{"name":"CategoryTheory.instIsFilteredOrEmptyProd","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.IsFilteredOrEmpty C\ninst‚úù : CategoryTheory.IsFilteredOrEmpty D\n‚ä¢ CategoryTheory.IsFilteredOrEmpty (Prod C D)","decl":"open IsFiltered in\ninstance [IsFilteredOrEmpty C] [IsFilteredOrEmpty D] : IsFilteredOrEmpty (C √ó D) where\n  cocone_objs k l := ‚ü®(max k.1 l.1, max k.2 l.2), (leftToMax k.1 l.1, leftToMax k.2 l.2),\n    (rightToMax k.1 l.1, rightToMax k.2 l.2), trivial‚ü©\n  cocone_maps k l f g := ‚ü®(coeq f.1 g.1, coeq f.2 g.2), (coeqHom f.1 g.1, coeqHom f.2 g.2),\n    by simp [coeq_condition]‚ü©\n\n"}
{"name":"CategoryTheory.instIsFilteredProd","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.IsFiltered C\ninst‚úù : CategoryTheory.IsFiltered D\n‚ä¢ CategoryTheory.IsFiltered (Prod C D)","decl":"attribute [local instance] IsFiltered.nonempty in\ninstance [IsFiltered C] [IsFiltered D] : IsFiltered (C √ó D) where\n\n"}
{"name":"CategoryTheory.instIsCofilteredOrEmptyProd","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.IsCofilteredOrEmpty C\ninst‚úù : CategoryTheory.IsCofilteredOrEmpty D\n‚ä¢ CategoryTheory.IsCofilteredOrEmpty (Prod C D)","decl":"open IsCofiltered in\ninstance [IsCofilteredOrEmpty C] [IsCofilteredOrEmpty D] : IsCofilteredOrEmpty (C √ó D) where\n  cone_objs k l := ‚ü®(min k.1 l.1, min k.2 l.2), (minToLeft k.1 l.1, minToLeft k.2 l.2),\n    (minToRight k.1 l.1, minToRight k.2 l.2), trivial‚ü©\n  cone_maps k l f g := ‚ü®(eq f.1 g.1, eq f.2 g.2), (eqHom f.1 g.1, eqHom f.2 g.2),\n    by simp [eq_condition]‚ü©\n\n"}
{"name":"CategoryTheory.instIsCofilteredProd","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.IsCofiltered C\ninst‚úù : CategoryTheory.IsCofiltered D\n‚ä¢ CategoryTheory.IsCofiltered (Prod C D)","decl":"attribute [local instance] IsCofiltered.nonempty in\ninstance [IsCofiltered C] [IsCofiltered D] : IsCofiltered (C √ó D) where\n\n"}
