{"name":"CategoryTheory.IsFilteredOrEmpty.cocone_maps","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.IsFilteredOrEmpty C\nX Y : C\nf g : Quiver.Hom X Y\n⊢ Exists fun Z => Exists fun h => Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g h)","decl":"/-- A category `IsFilteredOrEmpty` if\n1. for every pair of objects there exists another object \"to the right\", and\n2. for every pair of parallel morphisms there exists a morphism to the right so the compositions\n   are equal.\n-/\nclass IsFilteredOrEmpty : Prop where\n  /-- for every pair of objects there exists another object \"to the right\" -/\n  cocone_objs : ∀ X Y : C, ∃ (Z : _) (_ : X ⟶ Z) (_ : Y ⟶ Z), True\n  /-- for every pair of parallel morphisms there exists a morphism to the right\n    so the compositions are equal -/\n  cocone_maps : ∀ ⦃X Y : C⦄ (f g : X ⟶ Y), ∃ (Z : _) (h : Y ⟶ Z), f ≫ h = g ≫ h\n\n"}
{"name":"CategoryTheory.IsFilteredOrEmpty.cocone_objs","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.IsFilteredOrEmpty C\nX Y : C\n⊢ Exists fun Z => Exists fun x => Exists fun x => True","decl":"/-- A category `IsFilteredOrEmpty` if\n1. for every pair of objects there exists another object \"to the right\", and\n2. for every pair of parallel morphisms there exists a morphism to the right so the compositions\n   are equal.\n-/\nclass IsFilteredOrEmpty : Prop where\n  /-- for every pair of objects there exists another object \"to the right\" -/\n  cocone_objs : ∀ X Y : C, ∃ (Z : _) (_ : X ⟶ Z) (_ : Y ⟶ Z), True\n  /-- for every pair of parallel morphisms there exists a morphism to the right\n    so the compositions are equal -/\n  cocone_maps : ∀ ⦃X Y : C⦄ (f g : X ⟶ Y), ∃ (Z : _) (h : Y ⟶ Z), f ≫ h = g ≫ h\n\n"}
{"name":"CategoryTheory.IsFiltered.nonempty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.IsFiltered C\n⊢ Nonempty C","decl":"/-- A category `IsFiltered` if\n1. for every pair of objects there exists another object \"to the right\",\n2. for every pair of parallel morphisms there exists a morphism to the right so the compositions\n   are equal, and\n3. there exists some object. -/\n@[stacks 002V \"They also define a diagram being filtered.\"]\nclass IsFiltered extends IsFilteredOrEmpty C : Prop where\n  /-- a filtered category must be non empty -/\n  [nonempty : Nonempty C]\n\n"}
{"name":"CategoryTheory.IsFiltered.toIsFilteredOrEmpty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.IsFiltered C\n⊢ CategoryTheory.IsFilteredOrEmpty C","decl":"/-- A category `IsFiltered` if\n1. for every pair of objects there exists another object \"to the right\",\n2. for every pair of parallel morphisms there exists a morphism to the right so the compositions\n   are equal, and\n3. there exists some object. -/\n@[stacks 002V \"They also define a diagram being filtered.\"]\nclass IsFiltered extends IsFilteredOrEmpty C : Prop where\n  /-- a filtered category must be non empty -/\n  [nonempty : Nonempty C]\n\n"}
{"name":"CategoryTheory.isFilteredOrEmpty_of_semilatticeSup","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\n⊢ CategoryTheory.IsFilteredOrEmpty α","decl":"instance (priority := 100) isFilteredOrEmpty_of_semilatticeSup (α : Type u) [SemilatticeSup α] :\n    IsFilteredOrEmpty α where\n  cocone_objs X Y := ⟨X ⊔ Y, homOfLE le_sup_left, homOfLE le_sup_right, trivial⟩\n  cocone_maps X Y f g := ⟨Y, 𝟙 _, by subsingleton⟩\n\n"}
{"name":"CategoryTheory.isFiltered_of_semilatticeSup_nonempty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"α : Type u\ninst✝¹ : SemilatticeSup α\ninst✝ : Nonempty α\n⊢ CategoryTheory.IsFiltered α","decl":"instance (priority := 100) isFiltered_of_semilatticeSup_nonempty (α : Type u) [SemilatticeSup α]\n    [Nonempty α] : IsFiltered α where\n\n"}
{"name":"CategoryTheory.isFilteredOrEmpty_of_directed_le","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : IsDirected α fun x1 x2 => LE.le x1 x2\n⊢ CategoryTheory.IsFilteredOrEmpty α","decl":"instance (priority := 100) isFilteredOrEmpty_of_directed_le (α : Type u) [Preorder α]\n    [IsDirected α (· ≤ ·)] : IsFilteredOrEmpty α where\n  cocone_objs X Y :=\n    let ⟨Z, h1, h2⟩ := exists_ge_ge X Y\n    ⟨Z, homOfLE h1, homOfLE h2, trivial⟩\n  cocone_maps X Y f g := ⟨Y, 𝟙 _, by subsingleton⟩\n\n"}
{"name":"CategoryTheory.isFiltered_of_directed_le_nonempty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"α : Type u\ninst✝² : Preorder α\ninst✝¹ : IsDirected α fun x1 x2 => LE.le x1 x2\ninst✝ : Nonempty α\n⊢ CategoryTheory.IsFiltered α","decl":"instance (priority := 100) isFiltered_of_directed_le_nonempty (α : Type u) [Preorder α]\n    [IsDirected α (· ≤ ·)] [Nonempty α] : IsFiltered α where\n\n-- Sanity checks\n"}
{"name":"CategoryTheory.instIsFilteredDiscretePUnit","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"⊢ CategoryTheory.IsFiltered (CategoryTheory.Discrete PUnit.{u_1 + 1})","decl":"instance : IsFiltered (Discrete PUnit) where\n  cocone_objs X Y := ⟨⟨PUnit.unit⟩, ⟨⟨by trivial⟩⟩, ⟨⟨by subsingleton⟩⟩, trivial⟩\n  cocone_maps X Y f g := ⟨⟨PUnit.unit⟩, ⟨⟨by trivial⟩⟩, by subsingleton⟩\n\n"}
{"name":"CategoryTheory.IsFiltered.coeq_condition_assoc","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsFilteredOrEmpty C\nj j' : C\nf f' : Quiver.Hom j j'\nZ : C\nh : Quiver.Hom (CategoryTheory.IsFiltered.coeq f f') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsFiltered.coeqHom f f') h)) (CategoryTheory.CategoryStruct.comp f' (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsFiltered.coeqHom f f') h))","decl":"/-- `coeq_condition f f'`, for morphisms `f f' : j ⟶ j'`, is the proof that\n`f ≫ coeqHom f f' = f' ≫ coeqHom f f'`.\n-/\n@[reassoc]\ntheorem coeq_condition {j j' : C} (f f' : j ⟶ j') : f ≫ coeqHom f f' = f' ≫ coeqHom f f' :=\n  (IsFilteredOrEmpty.cocone_maps f f').choose_spec.choose_spec\n\n"}
{"name":"CategoryTheory.IsFiltered.coeq_condition","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsFilteredOrEmpty C\nj j' : C\nf f' : Quiver.Hom j j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.IsFiltered.coeqHom f f')) (CategoryTheory.CategoryStruct.comp f' (CategoryTheory.IsFiltered.coeqHom f f'))","decl":"/-- `coeq_condition f f'`, for morphisms `f f' : j ⟶ j'`, is the proof that\n`f ≫ coeqHom f f' = f' ≫ coeqHom f f'`.\n-/\n@[reassoc]\ntheorem coeq_condition {j j' : C} (f f' : j ⟶ j') : f ≫ coeqHom f f' = f' ≫ coeqHom f f' :=\n  (IsFilteredOrEmpty.cocone_maps f f').choose_spec.choose_spec\n\n"}
{"name":"CategoryTheory.IsFilteredOrEmpty.of_right_adjoint","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.IsFilteredOrEmpty C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nL : CategoryTheory.Functor D C\nR : CategoryTheory.Functor C D\nh : CategoryTheory.Adjunction L R\n⊢ CategoryTheory.IsFilteredOrEmpty D","decl":"/-- If `C` is filtered or empty, and we have a functor `R : C ⥤ D` with a left adjoint, then `D` is\nfiltered or empty.\n-/\ntheorem of_right_adjoint {L : D ⥤ C} {R : C ⥤ D} (h : L ⊣ R) : IsFilteredOrEmpty D :=\n  { cocone_objs := fun X Y =>\n      ⟨R.obj (max (L.obj X) (L.obj Y)),\n        h.homEquiv _ _ (leftToMax _ _), h.homEquiv _ _ (rightToMax _ _), ⟨⟩⟩\n    cocone_maps := fun X Y f g =>\n      ⟨R.obj (coeq (L.map f) (L.map g)), h.homEquiv _ _ (coeqHom _ _), by\n        rw [← h.homEquiv_naturality_left, ← h.homEquiv_naturality_left, coeq_condition]⟩ }\n\n"}
{"name":"CategoryTheory.IsFilteredOrEmpty.of_isRightAdjoint","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.IsFilteredOrEmpty C\nD : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} D\nR : CategoryTheory.Functor C D\ninst✝ : R.IsRightAdjoint\n⊢ CategoryTheory.IsFilteredOrEmpty D","decl":"/-- If `C` is filtered or empty, and we have a right adjoint functor `R : C ⥤ D`, then `D` is\nfiltered or empty. -/\ntheorem of_isRightAdjoint (R : C ⥤ D) [R.IsRightAdjoint] : IsFilteredOrEmpty D :=\n  of_right_adjoint (Adjunction.ofIsRightAdjoint R)\n\n"}
{"name":"CategoryTheory.IsFilteredOrEmpty.of_equivalence","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.IsFilteredOrEmpty C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nh : CategoryTheory.Equivalence C D\n⊢ CategoryTheory.IsFilteredOrEmpty D","decl":"/-- Being filtered or empty is preserved by equivalence of categories. -/\ntheorem of_equivalence (h : C ≌ D) : IsFilteredOrEmpty D :=\n  of_right_adjoint h.symm.toAdjunction\n\n"}
{"name":"CategoryTheory.IsFiltered.sup_objs_exists","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsFiltered C\nO : Finset C\n⊢ Exists fun S => ∀ {X : C}, Membership.mem O X → Nonempty (Quiver.Hom X S)","decl":"/-- Any finite collection of objects in a filtered category has an object \"to the right\".\n-/\ntheorem sup_objs_exists (O : Finset C) : ∃ S : C, ∀ {X}, X ∈ O → Nonempty (X ⟶ S) := by\n  classical\n  induction' O using Finset.induction with X O' nm h\n  · exact ⟨Classical.choice IsFiltered.nonempty, by intro; simp⟩\n  · obtain ⟨S', w'⟩ := h\n    use max X S'\n    rintro Y mY\n    obtain rfl | h := eq_or_ne Y X\n    · exact ⟨leftToMax _ _⟩\n    · exact ⟨(w' (Finset.mem_of_mem_insert_of_ne mY h)).some ≫ rightToMax _ _⟩\n\n"}
{"name":"CategoryTheory.IsFiltered.sup_exists","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsFiltered C\nO : Finset C\nH : Finset (PSigma fun X => PSigma fun Y => PSigma fun x => PSigma fun x => Quiver.Hom X Y)\n⊢ Exists fun S => Exists fun T => ∀ {X Y : C} (mX : Membership.mem O X) (mY : Membership.mem O Y) {f : Quiver.Hom X Y}, Membership.mem H ⟨X, ⟨Y, ⟨mX, ⟨mY, f⟩⟩⟩⟩ → Eq (CategoryTheory.CategoryStruct.comp f (T mY)) (T mX)","decl":"/-- Given any `Finset` of objects `{X, ...}` and\nindexed collection of `Finset`s of morphisms `{f, ...}` in `C`,\nthere exists an object `S`, with a morphism `T X : X ⟶ S` from each `X`,\nsuch that the triangles commute: `f ≫ T Y = T X`, for `f : X ⟶ Y` in the `Finset`.\n-/\ntheorem sup_exists :\n    ∃ (S : C) (T : ∀ {X : C}, X ∈ O → (X ⟶ S)),\n      ∀ {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f : X ⟶ Y},\n        (⟨X, Y, mX, mY, f⟩ : Σ' (X Y : C) (_ : X ∈ O) (_ : Y ∈ O), X ⟶ Y) ∈ H →\n          f ≫ T mY = T mX := by\n  classical\n  induction' H using Finset.induction with h' H' nmf h''\n  · obtain ⟨S, f⟩ := sup_objs_exists O\n    exact ⟨S, fun mX => (f mX).some, by rintro - - - - - ⟨⟩⟩\n  · obtain ⟨X, Y, mX, mY, f⟩ := h'\n    obtain ⟨S', T', w'⟩ := h''\n    refine ⟨coeq (f ≫ T' mY) (T' mX), fun mZ => T' mZ ≫ coeqHom (f ≫ T' mY) (T' mX), ?_⟩\n    intro X' Y' mX' mY' f' mf'\n    rw [← Category.assoc]\n    by_cases h : X = X' ∧ Y = Y'\n    · rcases h with ⟨rfl, rfl⟩\n      by_cases hf : f = f'\n      · subst hf\n        apply coeq_condition\n      · rw [@w' _ _ mX mY f']\n        simp only [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, true_and] at mf'\n        rcases mf' with mf' | mf'\n        · exfalso\n          exact hf mf'.symm\n        · exact mf'\n    · rw [@w' _ _ mX' mY' f' _]\n      apply Finset.mem_of_mem_insert_of_ne mf'\n      contrapose! h\n      obtain ⟨rfl, h⟩ := h\n      trivial\n\n"}
{"name":"CategoryTheory.IsFiltered.toSup_commutes","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsFiltered C\nO : Finset C\nH : Finset (PSigma fun X => PSigma fun Y => PSigma fun x => PSigma fun x => Quiver.Hom X Y)\nX Y : C\nmX : Membership.mem O X\nmY : Membership.mem O Y\nf : Quiver.Hom X Y\nmf : Membership.mem H ⟨X, ⟨Y, ⟨mX, ⟨mY, f⟩⟩⟩⟩\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.IsFiltered.toSup O H mY)) (CategoryTheory.IsFiltered.toSup O H mX)","decl":"/-- The triangles of consisting of a morphism in `H` and the maps to `sup O H` commute.\n-/\ntheorem toSup_commutes {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f : X ⟶ Y}\n    (mf : (⟨X, Y, mX, mY, f⟩ : Σ' (X Y : C) (_ : X ∈ O) (_ : Y ∈ O), X ⟶ Y) ∈ H) :\n    f ≫ toSup O H mY = toSup O H mX :=\n  (sup_exists O H).choose_spec.choose_spec mX mY mf\n\n"}
{"name":"CategoryTheory.IsFiltered.cocone_nonempty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.IsFiltered C\nJ : Type w\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.FinCategory J\nF : CategoryTheory.Functor J C\n⊢ Nonempty (CategoryTheory.Limits.Cocone F)","decl":"/-- If we have `IsFiltered C`, then for any functor `F : J ⥤ C` with `FinCategory J`,\nthere exists a cocone over `F`.\n-/\ntheorem cocone_nonempty (F : J ⥤ C) : Nonempty (Cocone F) := by\n  classical\n  let O := Finset.univ.image F.obj\n  let H : Finset (Σ' (X Y : C) (_ : X ∈ O) (_ : Y ∈ O), X ⟶ Y) :=\n    Finset.univ.biUnion   fun X : J =>\n      Finset.univ.biUnion fun Y : J =>\n        Finset.univ.image fun f : X ⟶ Y => ⟨F.obj X, F.obj Y, by simp [O], by simp [O], F.map f⟩\n  obtain ⟨Z, f, w⟩ := sup_exists O H\n  refine ⟨⟨Z, ⟨fun X => f (by simp [O]), ?_⟩⟩⟩\n  intro j j' g\n  dsimp\n  simp only [Category.comp_id]\n  apply w\n  simp only [O, H, Finset.mem_biUnion, Finset.mem_univ, Finset.mem_image, PSigma.mk.injEq,\n    true_and, exists_and_left]\n  exact ⟨j, rfl, j', g, by simp⟩\n\n"}
{"name":"CategoryTheory.IsFiltered.of_right_adjoint","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.IsFiltered C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nL : CategoryTheory.Functor D C\nR : CategoryTheory.Functor C D\nh : CategoryTheory.Adjunction L R\n⊢ CategoryTheory.IsFiltered D","decl":"/-- If `C` is filtered, and we have a functor `R : C ⥤ D` with a left adjoint, then `D` is filtered.\n-/\ntheorem of_right_adjoint {L : D ⥤ C} {R : C ⥤ D} (h : L ⊣ R) : IsFiltered D :=\n  { IsFilteredOrEmpty.of_right_adjoint h with\n    nonempty := IsFiltered.nonempty.map R.obj }\n\n"}
{"name":"CategoryTheory.IsFiltered.of_isRightAdjoint","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.IsFiltered C\nD : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} D\nR : CategoryTheory.Functor C D\ninst✝ : R.IsRightAdjoint\n⊢ CategoryTheory.IsFiltered D","decl":"/-- If `C` is filtered, and we have a right adjoint functor `R : C ⥤ D`, then `D` is filtered. -/\ntheorem of_isRightAdjoint (R : C ⥤ D) [R.IsRightAdjoint] : IsFiltered D :=\n  of_right_adjoint (Adjunction.ofIsRightAdjoint R)\n\n"}
{"name":"CategoryTheory.IsFiltered.of_equivalence","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.IsFiltered C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nh : CategoryTheory.Equivalence C D\n⊢ CategoryTheory.IsFiltered D","decl":"/-- Being filtered is preserved by equivalence of categories. -/\ntheorem of_equivalence (h : C ≌ D) : IsFiltered D :=\n  of_right_adjoint h.symm.toAdjunction\n\n"}
{"name":"CategoryTheory.IsFiltered.of_cocone_nonempty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nh : ∀ {J : Type w} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] (F : CategoryTheory.Functor J C), Nonempty (CategoryTheory.Limits.Cocone F)\n⊢ CategoryTheory.IsFiltered C","decl":"/-- If every finite diagram in `C` admits a cocone, then `C` is filtered. It is sufficient to verify\n    this for diagrams whose shape lives in any one fixed universe. -/\ntheorem of_cocone_nonempty (h : ∀ {J : Type w} [SmallCategory J] [FinCategory J] (F : J ⥤ C),\n    Nonempty (Cocone F)) : IsFiltered C := by\n  have : Nonempty C := by\n    obtain ⟨c⟩ := h (Functor.empty _)\n    exact ⟨c.pt⟩\n  have : IsFilteredOrEmpty C := by\n    refine ⟨?_, ?_⟩\n    · intros X Y\n      obtain ⟨c⟩ := h (ULiftHom.down ⋙ ULift.downFunctor ⋙ pair X Y)\n      exact ⟨c.pt, c.ι.app ⟨⟨WalkingPair.left⟩⟩, c.ι.app ⟨⟨WalkingPair.right⟩⟩, trivial⟩\n    · intros X Y f g\n      obtain ⟨c⟩ := h (ULiftHom.down ⋙ ULift.downFunctor ⋙ parallelPair f g)\n      refine ⟨c.pt, c.ι.app ⟨WalkingParallelPair.one⟩, ?_⟩\n      have h₁ := c.ι.naturality ⟨WalkingParallelPairHom.left⟩\n      have h₂ := c.ι.naturality ⟨WalkingParallelPairHom.right⟩\n      simp_all\n  apply IsFiltered.mk\n\n"}
{"name":"CategoryTheory.IsFiltered.of_hasFiniteColimits","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasFiniteColimits C\n⊢ CategoryTheory.IsFiltered C","decl":"theorem of_hasFiniteColimits [HasFiniteColimits C] : IsFiltered C :=\n  of_cocone_nonempty.{v} C fun F => ⟨colimit.cocone F⟩\n\n"}
{"name":"CategoryTheory.IsFiltered.of_isTerminal","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nh : CategoryTheory.Limits.IsTerminal X\n⊢ CategoryTheory.IsFiltered C","decl":"theorem of_isTerminal {X : C} (h : IsTerminal X) : IsFiltered C :=\n  of_cocone_nonempty.{v} _ fun {_} _ _ _ => ⟨⟨X, ⟨fun _ => h.from _, fun _ _ _ => h.hom_ext _ _⟩⟩⟩\n\n"}
{"name":"CategoryTheory.IsFiltered.of_hasTerminal","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\n⊢ CategoryTheory.IsFiltered C","decl":"instance (priority := 100) of_hasTerminal [HasTerminal C] : IsFiltered C :=\n  of_isTerminal _ terminalIsTerminal\n\n"}
{"name":"CategoryTheory.IsFiltered.iff_cocone_nonempty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Iff (CategoryTheory.IsFiltered C) (∀ {J : Type w} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] (F : CategoryTheory.Functor J C), Nonempty (CategoryTheory.Limits.Cocone F))","decl":"/-- For every universe `w`, `C` is filtered if and only if every finite diagram in `C` with shape\n    in `w` admits a cocone. -/\ntheorem iff_cocone_nonempty : IsFiltered C ↔\n    ∀ {J : Type w} [SmallCategory J] [FinCategory J] (F : J ⥤ C), Nonempty (Cocone F) :=\n  ⟨fun _ _ _ _ F => cocone_nonempty F, of_cocone_nonempty C⟩\n\n"}
{"name":"CategoryTheory.IsFiltered.coeq₃_condition₁","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsFilteredOrEmpty C\nj₁ j₂ : C\nf g h : Quiver.Hom j₁ j₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.IsFiltered.coeq₃Hom f g h)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.IsFiltered.coeq₃Hom f g h))","decl":"theorem coeq₃_condition₁ {j₁ j₂ : C} (f g h : j₁ ⟶ j₂) :\n    f ≫ coeq₃Hom f g h = g ≫ coeq₃Hom f g h := by\n  simp only [coeq₃Hom, ← Category.assoc, coeq_condition f g]\n\n"}
{"name":"CategoryTheory.IsFiltered.coeq₃_condition₂","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsFilteredOrEmpty C\nj₁ j₂ : C\nf g h : Quiver.Hom j₁ j₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.IsFiltered.coeq₃Hom f g h)) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.IsFiltered.coeq₃Hom f g h))","decl":"theorem coeq₃_condition₂ {j₁ j₂ : C} (f g h : j₁ ⟶ j₂) :\n    g ≫ coeq₃Hom f g h = h ≫ coeq₃Hom f g h := by\n  dsimp [coeq₃Hom]\n  slice_lhs 2 4 => rw [← Category.assoc, coeq_condition _ _]\n  slice_rhs 2 4 => rw [← Category.assoc, coeq_condition _ _]\n  slice_lhs 1 3 => rw [← Category.assoc, coeq_condition _ _]\n  simp only [Category.assoc]\n\n"}
{"name":"CategoryTheory.IsFiltered.coeq₃_condition₃","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsFilteredOrEmpty C\nj₁ j₂ : C\nf g h : Quiver.Hom j₁ j₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.IsFiltered.coeq₃Hom f g h)) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.IsFiltered.coeq₃Hom f g h))","decl":"theorem coeq₃_condition₃ {j₁ j₂ : C} (f g h : j₁ ⟶ j₂) : f ≫ coeq₃Hom f g h = h ≫ coeq₃Hom f g h :=\n  Eq.trans (coeq₃_condition₁ f g h) (coeq₃_condition₂ f g h)\n\n"}
{"name":"CategoryTheory.IsFiltered.span","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsFilteredOrEmpty C\ni j j' : C\nf : Quiver.Hom i j\nf' : Quiver.Hom i j'\n⊢ Exists fun k => Exists fun g => Exists fun g' => Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f' g')","decl":"/-- For every span `j ⟵ i ⟶ j'`, there\n   exists a cocone `j ⟶ k ⟵ j'` such that the square commutes. -/\ntheorem span {i j j' : C} (f : i ⟶ j) (f' : i ⟶ j') :\n    ∃ (k : C) (g : j ⟶ k) (g' : j' ⟶ k), f ≫ g = f' ≫ g' :=\n  let ⟨K, G, G', _⟩ := IsFilteredOrEmpty.cocone_objs j j'\n  let ⟨k, e, he⟩ := IsFilteredOrEmpty.cocone_maps (f ≫ G) (f' ≫ G')\n  ⟨k, G ≫ e, G' ≫ e, by simpa only [← Category.assoc] ⟩\n\n"}
{"name":"CategoryTheory.IsFiltered.bowtie","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsFilteredOrEmpty C\nj₁ j₂ k₁ k₂ : C\nf₁ : Quiver.Hom j₁ k₁\ng₁ : Quiver.Hom j₁ k₂\nf₂ : Quiver.Hom j₂ k₁\ng₂ : Quiver.Hom j₂ k₂\n⊢ Exists fun s => Exists fun α => Exists fun β => And (Eq (CategoryTheory.CategoryStruct.comp f₁ α) (CategoryTheory.CategoryStruct.comp g₁ β)) (Eq (CategoryTheory.CategoryStruct.comp f₂ α) (CategoryTheory.CategoryStruct.comp g₂ β))","decl":"/-- Given a \"bowtie\" of morphisms\n```\n j₁   j₂\n |\\  /|\n | \\/ |\n | /\\ |\n |/  \\∣\n vv  vv\n k₁  k₂\n```\nin a filtered category, we can construct an object `s` and two morphisms from `k₁` and `k₂` to `s`,\nmaking the resulting squares commute.\n-/\ntheorem bowtie {j₁ j₂ k₁ k₂ : C} (f₁ : j₁ ⟶ k₁) (g₁ : j₁ ⟶ k₂) (f₂ : j₂ ⟶ k₁) (g₂ : j₂ ⟶ k₂) :\n    ∃ (s : C) (α : k₁ ⟶ s) (β : k₂ ⟶ s), f₁ ≫ α = g₁ ≫ β ∧ f₂ ≫ α = g₂ ≫ β := by\n  obtain ⟨t, k₁t, k₂t, ht⟩ := span f₁ g₁\n  obtain ⟨s, ts, hs⟩ := IsFilteredOrEmpty.cocone_maps (f₂ ≫ k₁t) (g₂ ≫ k₂t)\n  simp_rw [Category.assoc] at hs\n  exact ⟨s, k₁t ≫ ts, k₂t ≫ ts, by simp only [← Category.assoc, ht], hs⟩\n\n"}
{"name":"CategoryTheory.IsFiltered.tulip","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsFilteredOrEmpty C\nj₁ j₂ j₃ k₁ k₂ l : C\nf₁ : Quiver.Hom j₁ k₁\nf₂ : Quiver.Hom j₂ k₁\nf₃ : Quiver.Hom j₂ k₂\nf₄ : Quiver.Hom j₃ k₂\ng₁ : Quiver.Hom j₁ l\ng₂ : Quiver.Hom j₃ l\n⊢ Exists fun s => Exists fun α => Exists fun β => Exists fun γ => And (Eq (CategoryTheory.CategoryStruct.comp f₁ α) (CategoryTheory.CategoryStruct.comp g₁ β)) (And (Eq (CategoryTheory.CategoryStruct.comp f₂ α) (CategoryTheory.CategoryStruct.comp f₃ γ)) (Eq (CategoryTheory.CategoryStruct.comp f₄ γ) (CategoryTheory.CategoryStruct.comp g₂ β)))","decl":"/-- Given a \"tulip\" of morphisms\n```\n j₁    j₂    j₃\n |\\   / \\   / |\n | \\ /   \\ /  |\n |  vv    vv  |\n \\  k₁    k₂ /\n  \\         /\n   \\       /\n    \\     /\n     \\   /\n      v v\n       l\n```\nin a filtered category, we can construct an object `s` and three morphisms from `k₁`, `k₂` and `l`\nto `s`, making the resulting squares commute.\n-/\ntheorem tulip {j₁ j₂ j₃ k₁ k₂ l : C} (f₁ : j₁ ⟶ k₁) (f₂ : j₂ ⟶ k₁) (f₃ : j₂ ⟶ k₂) (f₄ : j₃ ⟶ k₂)\n    (g₁ : j₁ ⟶ l) (g₂ : j₃ ⟶ l) :\n    ∃ (s : C) (α : k₁ ⟶ s) (β : l ⟶ s) (γ : k₂ ⟶ s),\n      f₁ ≫ α = g₁ ≫ β ∧ f₂ ≫ α = f₃ ≫ γ ∧ f₄ ≫ γ = g₂ ≫ β := by\n  obtain ⟨l', k₁l, k₂l, hl⟩ := span f₂ f₃\n  obtain ⟨s, ls, l's, hs₁, hs₂⟩ := bowtie g₁ (f₁ ≫ k₁l) g₂ (f₄ ≫ k₂l)\n  refine ⟨s, k₁l ≫ l's, ls, k₂l ≫ l's, ?_, by simp only [← Category.assoc, hl], ?_⟩ <;>\n    simp only [hs₁, hs₂, Category.assoc]\n\n"}
{"name":"CategoryTheory.IsCofilteredOrEmpty.cone_maps","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.IsCofilteredOrEmpty C\nX Y : C\nf g : Quiver.Hom X Y\n⊢ Exists fun W => Exists fun h => Eq (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp h g)","decl":"/-- A category `IsCofilteredOrEmpty` if\n1. for every pair of objects there exists another object \"to the left\", and\n2. for every pair of parallel morphisms there exists a morphism to the left so the compositions\n   are equal.\n-/\nclass IsCofilteredOrEmpty : Prop where\n  /-- for every pair of objects there exists another object \"to the left\" -/\n  cone_objs : ∀ X Y : C, ∃ (W : _) (_ : W ⟶ X) (_ : W ⟶ Y), True\n  /-- for every pair of parallel morphisms there exists a morphism to the left\n    so the compositions are equal -/\n  cone_maps : ∀ ⦃X Y : C⦄ (f g : X ⟶ Y), ∃ (W : _) (h : W ⟶ X), h ≫ f = h ≫ g\n\n"}
{"name":"CategoryTheory.IsCofilteredOrEmpty.cone_objs","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.IsCofilteredOrEmpty C\nX Y : C\n⊢ Exists fun W => Exists fun x => Exists fun x => True","decl":"/-- A category `IsCofilteredOrEmpty` if\n1. for every pair of objects there exists another object \"to the left\", and\n2. for every pair of parallel morphisms there exists a morphism to the left so the compositions\n   are equal.\n-/\nclass IsCofilteredOrEmpty : Prop where\n  /-- for every pair of objects there exists another object \"to the left\" -/\n  cone_objs : ∀ X Y : C, ∃ (W : _) (_ : W ⟶ X) (_ : W ⟶ Y), True\n  /-- for every pair of parallel morphisms there exists a morphism to the left\n    so the compositions are equal -/\n  cone_maps : ∀ ⦃X Y : C⦄ (f g : X ⟶ Y), ∃ (W : _) (h : W ⟶ X), h ≫ f = h ≫ g\n\n"}
{"name":"CategoryTheory.IsCofiltered.nonempty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.IsCofiltered C\n⊢ Nonempty C","decl":"/-- A category `IsCofiltered` if\n1. for every pair of objects there exists another object \"to the left\",\n2. for every pair of parallel morphisms there exists a morphism to the left so the compositions\n   are equal, and\n3. there exists some object. -/\n@[stacks 04AZ]\nclass IsCofiltered extends IsCofilteredOrEmpty C : Prop where\n  /-- a cofiltered category must be non empty -/\n  [nonempty : Nonempty C]\n\n"}
{"name":"CategoryTheory.IsCofiltered.toIsCofilteredOrEmpty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.IsCofiltered C\n⊢ CategoryTheory.IsCofilteredOrEmpty C","decl":"/-- A category `IsCofiltered` if\n1. for every pair of objects there exists another object \"to the left\",\n2. for every pair of parallel morphisms there exists a morphism to the left so the compositions\n   are equal, and\n3. there exists some object. -/\n@[stacks 04AZ]\nclass IsCofiltered extends IsCofilteredOrEmpty C : Prop where\n  /-- a cofiltered category must be non empty -/\n  [nonempty : Nonempty C]\n\n"}
{"name":"CategoryTheory.isCofilteredOrEmpty_of_semilatticeInf","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\n⊢ CategoryTheory.IsCofilteredOrEmpty α","decl":"instance (priority := 100) isCofilteredOrEmpty_of_semilatticeInf (α : Type u) [SemilatticeInf α] :\n    IsCofilteredOrEmpty α where\n  cone_objs X Y := ⟨X ⊓ Y, homOfLE inf_le_left, homOfLE inf_le_right, trivial⟩\n  cone_maps X Y f g := ⟨X, 𝟙 _, by\n    apply ULift.ext\n    subsingleton⟩\n\n"}
{"name":"CategoryTheory.isCofiltered_of_semilatticeInf_nonempty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"α : Type u\ninst✝¹ : SemilatticeInf α\ninst✝ : Nonempty α\n⊢ CategoryTheory.IsCofiltered α","decl":"instance (priority := 100) isCofiltered_of_semilatticeInf_nonempty (α : Type u) [SemilatticeInf α]\n    [Nonempty α] : IsCofiltered α where\n\n"}
{"name":"CategoryTheory.isCofilteredOrEmpty_of_directed_ge","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : IsDirected α fun x1 x2 => GE.ge x1 x2\n⊢ CategoryTheory.IsCofilteredOrEmpty α","decl":"instance (priority := 100) isCofilteredOrEmpty_of_directed_ge (α : Type u) [Preorder α]\n    [IsDirected α (· ≥ ·)] : IsCofilteredOrEmpty α where\n  cone_objs X Y :=\n    let ⟨Z, hX, hY⟩ := exists_le_le X Y\n    ⟨Z, homOfLE hX, homOfLE hY, trivial⟩\n  cone_maps X Y f g := ⟨X, 𝟙 _, by\n    apply ULift.ext\n    subsingleton⟩\n\n"}
{"name":"CategoryTheory.isCofiltered_of_directed_ge_nonempty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"α : Type u\ninst✝² : Preorder α\ninst✝¹ : IsDirected α fun x1 x2 => GE.ge x1 x2\ninst✝ : Nonempty α\n⊢ CategoryTheory.IsCofiltered α","decl":"instance (priority := 100) isCofiltered_of_directed_ge_nonempty (α : Type u) [Preorder α]\n    [IsDirected α (· ≥ ·)] [Nonempty α] : IsCofiltered α where\n\n-- Sanity checks\n"}
{"name":"CategoryTheory.instIsCofilteredDiscretePUnit","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"⊢ CategoryTheory.IsCofiltered (CategoryTheory.Discrete PUnit.{u_1 + 1})","decl":"instance : IsCofiltered (Discrete PUnit) where\n  cone_objs _ Y := ⟨⟨PUnit.unit⟩, ⟨⟨by trivial⟩⟩, ⟨⟨by subsingleton⟩⟩, trivial⟩\n  cone_maps X Y f g := ⟨⟨PUnit.unit⟩, ⟨⟨by trivial⟩⟩, by\n    apply ULift.ext\n    subsingleton⟩\n\n"}
{"name":"CategoryTheory.IsCofiltered.eq_condition_assoc","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsCofilteredOrEmpty C\nj j' : C\nf f' : Quiver.Hom j j'\nZ : C\nh : Quiver.Hom j' Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsCofiltered.eqHom f f') (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsCofiltered.eqHom f f') (CategoryTheory.CategoryStruct.comp f' h))","decl":"/-- `eq_condition f f'`, for morphisms `f f' : j ⟶ j'`, is the proof that\n`eqHom f f' ≫ f = eqHom f f' ≫ f'`.\n-/\n@[reassoc]\ntheorem eq_condition {j j' : C} (f f' : j ⟶ j') : eqHom f f' ≫ f = eqHom f f' ≫ f' :=\n  (IsCofilteredOrEmpty.cone_maps f f').choose_spec.choose_spec\n\n"}
{"name":"CategoryTheory.IsCofiltered.eq_condition","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsCofilteredOrEmpty C\nj j' : C\nf f' : Quiver.Hom j j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsCofiltered.eqHom f f') f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsCofiltered.eqHom f f') f')","decl":"/-- `eq_condition f f'`, for morphisms `f f' : j ⟶ j'`, is the proof that\n`eqHom f f' ≫ f = eqHom f f' ≫ f'`.\n-/\n@[reassoc]\ntheorem eq_condition {j j' : C} (f f' : j ⟶ j') : eqHom f f' ≫ f = eqHom f f' ≫ f' :=\n  (IsCofilteredOrEmpty.cone_maps f f').choose_spec.choose_spec\n\n"}
{"name":"CategoryTheory.IsCofiltered.cospan","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsCofilteredOrEmpty C\ni j j' : C\nf : Quiver.Hom j i\nf' : Quiver.Hom j' i\n⊢ Exists fun k => Exists fun g => Exists fun g' => Eq (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.comp g' f')","decl":"/-- For every cospan `j ⟶ i ⟵ j'`,\n there exists a cone `j ⟵ k ⟶ j'` such that the square commutes. -/\ntheorem cospan {i j j' : C} (f : j ⟶ i) (f' : j' ⟶ i) :\n    ∃ (k : C) (g : k ⟶ j) (g' : k ⟶ j'), g ≫ f = g' ≫ f' :=\n  let ⟨K, G, G', _⟩ := IsCofilteredOrEmpty.cone_objs j j'\n  let ⟨k, e, he⟩ := IsCofilteredOrEmpty.cone_maps (G ≫ f) (G' ≫ f')\n  ⟨k, e ≫ G, e ≫ G', by simpa only [Category.assoc] using he⟩\n\n"}
{"name":"CategoryTheory.Functor.ranges_directed","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsCofilteredOrEmpty C\nF : CategoryTheory.Functor C (Type u_1)\nj : C\n⊢ Directed (fun x1 x2 => Superset x1 x2) fun f => Set.range (F.map f.snd)","decl":"theorem _root_.CategoryTheory.Functor.ranges_directed (F : C ⥤ Type*) (j : C) :\n    Directed (· ⊇ ·) fun f : Σ'i, i ⟶ j => Set.range (F.map f.2) := fun ⟨i, ij⟩ ⟨k, kj⟩ => by\n  let ⟨l, li, lk, e⟩ := cospan ij kj\n  refine ⟨⟨l, lk ≫ kj⟩, e ▸ ?_, ?_⟩ <;> simp_rw [F.map_comp] <;> apply Set.range_comp_subset_range\n\n"}
{"name":"CategoryTheory.IsCofiltered.bowtie","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsCofilteredOrEmpty C\nj₁ j₂ k₁ k₂ : C\nf₁ : Quiver.Hom k₁ j₁\ng₁ : Quiver.Hom k₂ j₁\nf₂ : Quiver.Hom k₁ j₂\ng₂ : Quiver.Hom k₂ j₂\n⊢ Exists fun s => Exists fun α => Exists fun β => And (Eq (CategoryTheory.CategoryStruct.comp α f₁) (CategoryTheory.CategoryStruct.comp β g₁)) (Eq (CategoryTheory.CategoryStruct.comp α f₂) (CategoryTheory.CategoryStruct.comp β g₂))","decl":"/-- Given a \"bowtie\" of morphisms\n```\n k₁   k₂\n |\\  /|\n | \\/ |\n | /\\ |\n |/  \\∣\n vv  vv\n j₁  j₂\n```\nin a cofiltered category, we can construct an object `s` and two morphisms\nfrom `s` to `k₁` and `k₂`, making the resulting squares commute.\n-/\ntheorem bowtie {j₁ j₂ k₁ k₂ : C} (f₁ : k₁ ⟶ j₁) (g₁ : k₂ ⟶ j₁) (f₂ : k₁ ⟶ j₂) (g₂ : k₂ ⟶ j₂) :\n    ∃ (s : C) (α : s ⟶ k₁) (β : s ⟶ k₂), α ≫ f₁ = β ≫ g₁ ∧ α ≫ f₂ = β ≫ g₂ := by\n  obtain ⟨t, k₁t, k₂t, ht⟩ := cospan f₁ g₁\n  obtain ⟨s, ts, hs⟩ := IsCofilteredOrEmpty.cone_maps (k₁t ≫ f₂) (k₂t ≫ g₂)\n  exact ⟨s, ts ≫ k₁t, ts ≫ k₂t, by simp only [Category.assoc, ht],\n    by simp only [Category.assoc, hs]⟩\n\n"}
{"name":"CategoryTheory.IsCofilteredOrEmpty.of_left_adjoint","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.IsCofilteredOrEmpty C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\n⊢ CategoryTheory.IsCofilteredOrEmpty D","decl":"/-- If `C` is cofiltered or empty, and we have a functor `L : C ⥤ D` with a right adjoint,\nthen `D` is cofiltered or empty.\n-/\ntheorem of_left_adjoint {L : C ⥤ D} {R : D ⥤ C} (h : L ⊣ R) : IsCofilteredOrEmpty D :=\n  { cone_objs := fun X Y =>\n      ⟨L.obj (min (R.obj X) (R.obj Y)), (h.homEquiv _ X).symm (minToLeft _ _),\n        (h.homEquiv _ Y).symm (minToRight _ _), ⟨⟩⟩\n    cone_maps := fun X Y f g =>\n      ⟨L.obj (eq (R.map f) (R.map g)), (h.homEquiv _ _).symm (eqHom _ _), by\n        rw [← h.homEquiv_naturality_right_symm, ← h.homEquiv_naturality_right_symm, eq_condition]⟩ }\n\n"}
{"name":"CategoryTheory.IsCofilteredOrEmpty.of_isLeftAdjoint","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.IsCofilteredOrEmpty C\nD : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} D\nL : CategoryTheory.Functor C D\ninst✝ : L.IsLeftAdjoint\n⊢ CategoryTheory.IsCofilteredOrEmpty D","decl":"/-- If `C` is cofiltered or empty, and we have a left adjoint functor `L : C ⥤ D`, then `D` is\ncofiltered or empty. -/\ntheorem of_isLeftAdjoint (L : C ⥤ D) [L.IsLeftAdjoint] : IsCofilteredOrEmpty D :=\n  of_left_adjoint (Adjunction.ofIsLeftAdjoint L)\n\n"}
{"name":"CategoryTheory.IsCofilteredOrEmpty.of_equivalence","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.IsCofilteredOrEmpty C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nh : CategoryTheory.Equivalence C D\n⊢ CategoryTheory.IsCofilteredOrEmpty D","decl":"/-- Being cofiltered or empty is preserved by equivalence of categories. -/\ntheorem of_equivalence (h : C ≌ D) : IsCofilteredOrEmpty D :=\n  of_left_adjoint h.toAdjunction\n\n"}
{"name":"CategoryTheory.IsCofiltered.inf_objs_exists","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsCofiltered C\nO : Finset C\n⊢ Exists fun S => ∀ {X : C}, Membership.mem O X → Nonempty (Quiver.Hom S X)","decl":"/-- Any finite collection of objects in a cofiltered category has an object \"to the left\".\n-/\ntheorem inf_objs_exists (O : Finset C) : ∃ S : C, ∀ {X}, X ∈ O → Nonempty (S ⟶ X) := by\n  classical\n  induction' O using Finset.induction with X O' nm h\n  · exact ⟨Classical.choice IsCofiltered.nonempty, by intro; simp⟩\n  · obtain ⟨S', w'⟩ := h\n    use min X S'\n    rintro Y mY\n    obtain rfl | h := eq_or_ne Y X\n    · exact ⟨minToLeft _ _⟩\n    · exact ⟨minToRight _ _ ≫ (w' (Finset.mem_of_mem_insert_of_ne mY h)).some⟩\n\n"}
{"name":"CategoryTheory.IsCofiltered.inf_exists","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsCofiltered C\nO : Finset C\nH : Finset (PSigma fun X => PSigma fun Y => PSigma fun x => PSigma fun x => Quiver.Hom X Y)\n⊢ Exists fun S => Exists fun T => ∀ {X Y : C} (mX : Membership.mem O X) (mY : Membership.mem O Y) {f : Quiver.Hom X Y}, Membership.mem H ⟨X, ⟨Y, ⟨mX, ⟨mY, f⟩⟩⟩⟩ → Eq (CategoryTheory.CategoryStruct.comp (T mX) f) (T mY)","decl":"/-- Given any `Finset` of objects `{X, ...}` and\nindexed collection of `Finset`s of morphisms `{f, ...}` in `C`,\nthere exists an object `S`, with a morphism `T X : S ⟶ X` from each `X`,\nsuch that the triangles commute: `T X ≫ f = T Y`, for `f : X ⟶ Y` in the `Finset`.\n-/\ntheorem inf_exists :\n    ∃ (S : C) (T : ∀ {X : C}, X ∈ O → (S ⟶ X)),\n      ∀ {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f : X ⟶ Y},\n        (⟨X, Y, mX, mY, f⟩ : Σ' (X Y : C) (_ : X ∈ O) (_ : Y ∈ O), X ⟶ Y) ∈ H →\n          T mX ≫ f = T mY := by\n  classical\n  induction' H using Finset.induction with h' H' nmf h''\n  · obtain ⟨S, f⟩ := inf_objs_exists O\n    exact ⟨S, fun mX => (f mX).some, by rintro - - - - - ⟨⟩⟩\n  · obtain ⟨X, Y, mX, mY, f⟩ := h'\n    obtain ⟨S', T', w'⟩ := h''\n    refine ⟨eq (T' mX ≫ f) (T' mY), fun mZ => eqHom (T' mX ≫ f) (T' mY) ≫ T' mZ, ?_⟩\n    intro X' Y' mX' mY' f' mf'\n    rw [Category.assoc]\n    by_cases h : X = X' ∧ Y = Y'\n    · rcases h with ⟨rfl, rfl⟩\n      by_cases hf : f = f'\n      · subst hf\n        apply eq_condition\n      · rw [@w' _ _ mX mY f']\n        simp only [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, true_and] at mf'\n        rcases mf' with mf' | mf'\n        · exfalso\n          exact hf mf'.symm\n        · exact mf'\n    · rw [@w' _ _ mX' mY' f' _]\n      apply Finset.mem_of_mem_insert_of_ne mf'\n      contrapose! h\n      obtain ⟨rfl, h⟩ := h\n      trivial\n\n"}
{"name":"CategoryTheory.IsCofiltered.infTo_commutes","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsCofiltered C\nO : Finset C\nH : Finset (PSigma fun X => PSigma fun Y => PSigma fun x => PSigma fun x => Quiver.Hom X Y)\nX Y : C\nmX : Membership.mem O X\nmY : Membership.mem O Y\nf : Quiver.Hom X Y\nmf : Membership.mem H ⟨X, ⟨Y, ⟨mX, ⟨mY, f⟩⟩⟩⟩\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsCofiltered.infTo O H mX) f) (CategoryTheory.IsCofiltered.infTo O H mY)","decl":"/-- The triangles consisting of a morphism in `H` and the maps from `inf O H` commute.\n-/\ntheorem infTo_commutes {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f : X ⟶ Y}\n    (mf : (⟨X, Y, mX, mY, f⟩ : Σ' (X Y : C) (_ : X ∈ O) (_ : Y ∈ O), X ⟶ Y) ∈ H) :\n    infTo O H mX ≫ f = infTo O H mY :=\n  (inf_exists O H).choose_spec.choose_spec mX mY mf\n\n"}
{"name":"CategoryTheory.IsCofiltered.cone_nonempty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.IsCofiltered C\nJ : Type w\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.FinCategory J\nF : CategoryTheory.Functor J C\n⊢ Nonempty (CategoryTheory.Limits.Cone F)","decl":"/-- If we have `IsCofiltered C`, then for any functor `F : J ⥤ C` with `FinCategory J`,\nthere exists a cone over `F`.\n-/\ntheorem cone_nonempty (F : J ⥤ C) : Nonempty (Cone F) := by\n  classical\n  let O := Finset.univ.image F.obj\n  let H : Finset (Σ' (X Y : C) (_ : X ∈ O) (_ : Y ∈ O), X ⟶ Y) :=\n    Finset.univ.biUnion fun X : J =>\n      Finset.univ.biUnion fun Y : J =>\n        Finset.univ.image fun f : X ⟶ Y => ⟨F.obj X, F.obj Y, by simp [O], by simp [O], F.map f⟩\n  obtain ⟨Z, f, w⟩ := inf_exists O H\n  refine ⟨⟨Z, ⟨fun X => f (by simp [O]), ?_⟩⟩⟩\n  intro j j' g\n  dsimp\n  simp only [Category.id_comp]\n  symm\n  apply w\n  simp only [O, H, Finset.mem_biUnion, Finset.mem_univ, Finset.mem_image,\n    PSigma.mk.injEq, true_and, exists_and_left]\n  exact ⟨j, rfl, j', g, by simp⟩\n\n"}
{"name":"CategoryTheory.IsCofiltered.of_left_adjoint","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.IsCofiltered C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\n⊢ CategoryTheory.IsCofiltered D","decl":"/-- If `C` is cofiltered, and we have a functor `L : C ⥤ D` with a right adjoint,\nthen `D` is cofiltered.\n-/\ntheorem of_left_adjoint {L : C ⥤ D} {R : D ⥤ C} (h : L ⊣ R) : IsCofiltered D :=\n  { IsCofilteredOrEmpty.of_left_adjoint h with\n    nonempty := IsCofiltered.nonempty.map L.obj }\n\n"}
{"name":"CategoryTheory.IsCofiltered.of_isLeftAdjoint","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.IsCofiltered C\nD : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} D\nL : CategoryTheory.Functor C D\ninst✝ : L.IsLeftAdjoint\n⊢ CategoryTheory.IsCofiltered D","decl":"/-- If `C` is cofiltered, and we have a left adjoint functor `L : C ⥤ D`, then `D` is cofiltered. -/\ntheorem of_isLeftAdjoint (L : C ⥤ D) [L.IsLeftAdjoint] : IsCofiltered D :=\n  of_left_adjoint (Adjunction.ofIsLeftAdjoint L)\n\n"}
{"name":"CategoryTheory.IsCofiltered.of_equivalence","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.IsCofiltered C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nh : CategoryTheory.Equivalence C D\n⊢ CategoryTheory.IsCofiltered D","decl":"/-- Being cofiltered is preserved by equivalence of categories. -/\ntheorem of_equivalence (h : C ≌ D) : IsCofiltered D :=\n  of_left_adjoint h.toAdjunction\n\n"}
{"name":"CategoryTheory.IsCofiltered.of_cone_nonempty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nh : ∀ {J : Type w} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] (F : CategoryTheory.Functor J C), Nonempty (CategoryTheory.Limits.Cone F)\n⊢ CategoryTheory.IsCofiltered C","decl":"/-- If every finite diagram in `C` admits a cone, then `C` is cofiltered. It is sufficient to\n    verify this for diagrams whose shape lives in any one fixed universe. -/\ntheorem of_cone_nonempty (h : ∀ {J : Type w} [SmallCategory J] [FinCategory J] (F : J ⥤ C),\n    Nonempty (Cone F)) : IsCofiltered C := by\n  have : Nonempty C := by\n    obtain ⟨c⟩ := h (Functor.empty _)\n    exact ⟨c.pt⟩\n  have : IsCofilteredOrEmpty C := by\n    refine ⟨?_, ?_⟩\n    · intros X Y\n      obtain ⟨c⟩ := h (ULiftHom.down ⋙ ULift.downFunctor ⋙ pair X Y)\n      exact ⟨c.pt, c.π.app ⟨⟨WalkingPair.left⟩⟩, c.π.app ⟨⟨WalkingPair.right⟩⟩, trivial⟩\n    · intros X Y f g\n      obtain ⟨c⟩ := h (ULiftHom.down ⋙ ULift.downFunctor ⋙ parallelPair f g)\n      refine ⟨c.pt, c.π.app ⟨WalkingParallelPair.zero⟩, ?_⟩\n      have h₁ := c.π.naturality ⟨WalkingParallelPairHom.left⟩\n      have h₂ := c.π.naturality ⟨WalkingParallelPairHom.right⟩\n      simp_all\n  apply IsCofiltered.mk\n\n"}
{"name":"CategoryTheory.IsCofiltered.of_hasFiniteLimits","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasFiniteLimits C\n⊢ CategoryTheory.IsCofiltered C","decl":"theorem of_hasFiniteLimits [HasFiniteLimits C] : IsCofiltered C :=\n  of_cone_nonempty.{v} C fun F => ⟨limit.cone F⟩\n\n"}
{"name":"CategoryTheory.IsCofiltered.of_isInitial","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nh : CategoryTheory.Limits.IsInitial X\n⊢ CategoryTheory.IsCofiltered C","decl":"theorem of_isInitial {X : C} (h : IsInitial X) : IsCofiltered C :=\n  of_cone_nonempty.{v} _ fun {_} _ _ _ => ⟨⟨X, ⟨fun _ => h.to _, fun _ _ _ => h.hom_ext _ _⟩⟩⟩\n\n"}
{"name":"CategoryTheory.IsCofiltered.of_hasInitial","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasInitial C\n⊢ CategoryTheory.IsCofiltered C","decl":"instance (priority := 100) of_hasInitial [HasInitial C] : IsCofiltered C :=\n  of_isInitial _ initialIsInitial\n\n"}
{"name":"CategoryTheory.IsCofiltered.iff_cone_nonempty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Iff (CategoryTheory.IsCofiltered C) (∀ {J : Type w} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] (F : CategoryTheory.Functor J C), Nonempty (CategoryTheory.Limits.Cone F))","decl":"/-- For every universe `w`, `C` is filtered if and only if every finite diagram in `C` with shape\n    in `w` admits a cocone. -/\ntheorem iff_cone_nonempty : IsCofiltered C ↔\n    ∀ {J : Type w} [SmallCategory J] [FinCategory J] (F : J ⥤ C), Nonempty (Cone F) :=\n  ⟨fun _ _ _ _ F => cone_nonempty F, of_cone_nonempty C⟩\n\n"}
{"name":"CategoryTheory.isCofilteredOrEmpty_op_of_isFilteredOrEmpty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsFilteredOrEmpty C\n⊢ CategoryTheory.IsCofilteredOrEmpty (Opposite C)","decl":"instance isCofilteredOrEmpty_op_of_isFilteredOrEmpty [IsFilteredOrEmpty C] :\n    IsCofilteredOrEmpty Cᵒᵖ where\n  cone_objs X Y :=\n    ⟨op (IsFiltered.max X.unop Y.unop), (IsFiltered.leftToMax _ _).op,\n      (IsFiltered.rightToMax _ _).op, trivial⟩\n  cone_maps X Y f g :=\n    ⟨op (IsFiltered.coeq f.unop g.unop), (IsFiltered.coeqHom _ _).op, by\n      rw [show f = f.unop.op by simp, show g = g.unop.op by simp, ← op_comp, ← op_comp]\n      congr 1\n      exact IsFiltered.coeq_condition f.unop g.unop⟩\n\n"}
{"name":"CategoryTheory.isCofiltered_op_of_isFiltered","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsFiltered C\n⊢ CategoryTheory.IsCofiltered (Opposite C)","decl":"instance isCofiltered_op_of_isFiltered [IsFiltered C] : IsCofiltered Cᵒᵖ where\n  nonempty := letI : Nonempty C := IsFiltered.nonempty; inferInstance\n\n"}
{"name":"CategoryTheory.isFilteredOrEmpty_op_of_isCofilteredOrEmpty","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsCofilteredOrEmpty C\n⊢ CategoryTheory.IsFilteredOrEmpty (Opposite C)","decl":"instance isFilteredOrEmpty_op_of_isCofilteredOrEmpty [IsCofilteredOrEmpty C] :\n    IsFilteredOrEmpty Cᵒᵖ where\n  cocone_objs X Y :=\n    ⟨op (IsCofiltered.min X.unop Y.unop), (IsCofiltered.minToLeft X.unop Y.unop).op,\n      (IsCofiltered.minToRight X.unop Y.unop).op, trivial⟩\n  cocone_maps X Y f g :=\n    ⟨op (IsCofiltered.eq f.unop g.unop), (IsCofiltered.eqHom f.unop g.unop).op, by\n      rw [show f = f.unop.op by simp, show g = g.unop.op by simp, ← op_comp, ← op_comp]\n      congr 1\n      exact IsCofiltered.eq_condition f.unop g.unop⟩\n\n"}
{"name":"CategoryTheory.isFiltered_op_of_isCofiltered","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsCofiltered C\n⊢ CategoryTheory.IsFiltered (Opposite C)","decl":"instance isFiltered_op_of_isCofiltered [IsCofiltered C] : IsFiltered Cᵒᵖ where\n  nonempty := letI : Nonempty C := IsCofiltered.nonempty; inferInstance\n\n"}
{"name":"CategoryTheory.isCofilteredOrEmpty_of_isFilteredOrEmpty_op","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsFilteredOrEmpty (Opposite C)\n⊢ CategoryTheory.IsCofilteredOrEmpty C","decl":"/-- If Cᵒᵖ is filtered or empty, then C is cofiltered or empty. -/\nlemma isCofilteredOrEmpty_of_isFilteredOrEmpty_op [IsFilteredOrEmpty Cᵒᵖ] : IsCofilteredOrEmpty C :=\n  IsCofilteredOrEmpty.of_equivalence (opOpEquivalence _)\n\n"}
{"name":"CategoryTheory.isFilteredOrEmpty_of_isCofilteredOrEmpty_op","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsCofilteredOrEmpty (Opposite C)\n⊢ CategoryTheory.IsFilteredOrEmpty C","decl":"/-- If Cᵒᵖ is cofiltered or empty, then C is filtered or empty. -/\nlemma isFilteredOrEmpty_of_isCofilteredOrEmpty_op [IsCofilteredOrEmpty Cᵒᵖ] : IsFilteredOrEmpty C :=\n  IsFilteredOrEmpty.of_equivalence (opOpEquivalence _)\n\n"}
{"name":"CategoryTheory.isCofiltered_of_isFiltered_op","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsFiltered (Opposite C)\n⊢ CategoryTheory.IsCofiltered C","decl":"/-- If Cᵒᵖ is filtered, then C is cofiltered. -/\nlemma isCofiltered_of_isFiltered_op [IsFiltered Cᵒᵖ] : IsCofiltered C :=\n  IsCofiltered.of_equivalence (opOpEquivalence _)\n\n"}
{"name":"CategoryTheory.isFiltered_of_isCofiltered_op","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsCofiltered (Opposite C)\n⊢ CategoryTheory.IsFiltered C","decl":"/-- If Cᵒᵖ is cofiltered, then C is filtered. -/\nlemma isFiltered_of_isCofiltered_op [IsCofiltered Cᵒᵖ] : IsFiltered C :=\n  IsFiltered.of_equivalence (opOpEquivalence _)\n\n"}
{"name":"CategoryTheory.instIsFilteredULift","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsFiltered C\n⊢ CategoryTheory.IsFiltered (ULift.{u₂, u} C)","decl":"instance [IsFiltered C] : IsFiltered (ULift.{u₂} C) :=\n  IsFiltered.of_equivalence ULift.equivalence\n\n"}
{"name":"CategoryTheory.instIsCofilteredULift","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsCofiltered C\n⊢ CategoryTheory.IsCofiltered (ULift.{u₂, u} C)","decl":"instance [IsCofiltered C] : IsCofiltered (ULift.{u₂} C) :=\n  IsCofiltered.of_equivalence ULift.equivalence\n\n"}
{"name":"CategoryTheory.instIsFilteredULiftHom","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsFiltered C\n⊢ CategoryTheory.IsFiltered (CategoryTheory.ULiftHom C)","decl":"instance [IsFiltered C] : IsFiltered (ULiftHom C) :=\n  IsFiltered.of_equivalence ULiftHom.equiv\n\n"}
{"name":"CategoryTheory.instIsCofilteredULiftHom","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsCofiltered C\n⊢ CategoryTheory.IsCofiltered (CategoryTheory.ULiftHom C)","decl":"instance [IsCofiltered C] : IsCofiltered (ULiftHom C) :=\n  IsCofiltered.of_equivalence ULiftHom.equiv\n\n"}
{"name":"CategoryTheory.instIsFilteredAsSmall","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsFiltered C\n⊢ CategoryTheory.IsFiltered (CategoryTheory.AsSmall C)","decl":"instance [IsFiltered C] : IsFiltered (AsSmall C) :=\n  IsFiltered.of_equivalence AsSmall.equiv\n\n"}
{"name":"CategoryTheory.instIsCofilteredAsSmall","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsCofiltered C\n⊢ CategoryTheory.IsCofiltered (CategoryTheory.AsSmall C)","decl":"instance [IsCofiltered C] : IsCofiltered (AsSmall C) :=\n  IsCofiltered.of_equivalence AsSmall.equiv\n\n"}
{"name":"CategoryTheory.instIsFilteredOrEmptyForall","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"α : Type w\nI : α → Type u₁\ninst✝¹ : (i : α) → CategoryTheory.Category.{v₁, u₁} (I i)\ninst✝ : ∀ (i : α), CategoryTheory.IsFilteredOrEmpty (I i)\n⊢ CategoryTheory.IsFilteredOrEmpty ((i : α) → I i)","decl":"open IsFiltered in\ninstance [∀ i, IsFilteredOrEmpty (I i)] : IsFilteredOrEmpty (∀ i, I i) where\n  cocone_objs k l := ⟨fun s => max (k s) (l s), fun s => leftToMax (k s) (l s),\n    fun s => rightToMax (k s) (l s), trivial⟩\n  cocone_maps k l f g := ⟨fun s => coeq (f s) (g s), fun s => coeqHom (f s) (g s),\n    funext fun s => by simp [coeq_condition (f s) (g s)]⟩\n\n"}
{"name":"CategoryTheory.instIsFilteredForall","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"α : Type w\nI : α → Type u₁\ninst✝¹ : (i : α) → CategoryTheory.Category.{v₁, u₁} (I i)\ninst✝ : ∀ (i : α), CategoryTheory.IsFiltered (I i)\n⊢ CategoryTheory.IsFiltered ((i : α) → I i)","decl":"attribute [local instance] IsFiltered.nonempty in\ninstance [∀ i, IsFiltered (I i)] : IsFiltered (∀ i, I i) where\n\n"}
{"name":"CategoryTheory.instIsCofilteredOrEmptyForall","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"α : Type w\nI : α → Type u₁\ninst✝¹ : (i : α) → CategoryTheory.Category.{v₁, u₁} (I i)\ninst✝ : ∀ (i : α), CategoryTheory.IsCofilteredOrEmpty (I i)\n⊢ CategoryTheory.IsCofilteredOrEmpty ((i : α) → I i)","decl":"open IsCofiltered in\ninstance [∀ i, IsCofilteredOrEmpty (I i)] : IsCofilteredOrEmpty (∀ i, I i) where\n  cone_objs k l := ⟨fun s => min (k s) (l s), fun s => minToLeft (k s) (l s),\n    fun s => minToRight (k s) (l s), trivial⟩\n  cone_maps k l f g := ⟨fun s => eq (f s) (g s), fun s => eqHom (f s) (g s),\n    funext fun s => by simp [eq_condition (f s) (g s)]⟩\n\n"}
{"name":"CategoryTheory.instIsCofilteredForall","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"α : Type w\nI : α → Type u₁\ninst✝¹ : (i : α) → CategoryTheory.Category.{v₁, u₁} (I i)\ninst✝ : ∀ (i : α), CategoryTheory.IsCofiltered (I i)\n⊢ CategoryTheory.IsCofiltered ((i : α) → I i)","decl":"attribute [local instance] IsCofiltered.nonempty in\ninstance [∀ i, IsCofiltered (I i)] : IsCofiltered (∀ i, I i) where\n\n"}
{"name":"CategoryTheory.instIsFilteredOrEmptyProd","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.IsFilteredOrEmpty C\ninst✝ : CategoryTheory.IsFilteredOrEmpty D\n⊢ CategoryTheory.IsFilteredOrEmpty (Prod C D)","decl":"open IsFiltered in\ninstance [IsFilteredOrEmpty C] [IsFilteredOrEmpty D] : IsFilteredOrEmpty (C × D) where\n  cocone_objs k l := ⟨(max k.1 l.1, max k.2 l.2), (leftToMax k.1 l.1, leftToMax k.2 l.2),\n    (rightToMax k.1 l.1, rightToMax k.2 l.2), trivial⟩\n  cocone_maps k l f g := ⟨(coeq f.1 g.1, coeq f.2 g.2), (coeqHom f.1 g.1, coeqHom f.2 g.2),\n    by simp [coeq_condition]⟩\n\n"}
{"name":"CategoryTheory.instIsFilteredProd","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.IsFiltered C\ninst✝ : CategoryTheory.IsFiltered D\n⊢ CategoryTheory.IsFiltered (Prod C D)","decl":"attribute [local instance] IsFiltered.nonempty in\ninstance [IsFiltered C] [IsFiltered D] : IsFiltered (C × D) where\n\n"}
{"name":"CategoryTheory.instIsCofilteredOrEmptyProd","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.IsCofilteredOrEmpty C\ninst✝ : CategoryTheory.IsCofilteredOrEmpty D\n⊢ CategoryTheory.IsCofilteredOrEmpty (Prod C D)","decl":"open IsCofiltered in\ninstance [IsCofilteredOrEmpty C] [IsCofilteredOrEmpty D] : IsCofilteredOrEmpty (C × D) where\n  cone_objs k l := ⟨(min k.1 l.1, min k.2 l.2), (minToLeft k.1 l.1, minToLeft k.2 l.2),\n    (minToRight k.1 l.1, minToRight k.2 l.2), trivial⟩\n  cone_maps k l f g := ⟨(eq f.1 g.1, eq f.2 g.2), (eqHom f.1 g.1, eqHom f.2 g.2),\n    by simp [eq_condition]⟩\n\n"}
{"name":"CategoryTheory.instIsCofilteredProd","module":"Mathlib.CategoryTheory.Filtered.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.IsCofiltered C\ninst✝ : CategoryTheory.IsCofiltered D\n⊢ CategoryTheory.IsCofiltered (Prod C D)","decl":"attribute [local instance] IsCofiltered.nonempty in\ninstance [IsCofiltered C] [IsCofiltered D] : IsCofiltered (C × D) where\n\n"}
