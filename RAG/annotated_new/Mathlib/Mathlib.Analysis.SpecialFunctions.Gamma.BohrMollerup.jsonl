{"name":"Real.Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"s t a b : Real\nhs : LT.lt 0 s\nht : LT.lt 0 t\nha : LT.lt 0 a\nhb : LT.lt 0 b\nhab : Eq (HAdd.hAdd a b) 1\n‚ä¢ LE.le (Real.Gamma (HAdd.hAdd (HMul.hMul a s) (HMul.hMul b t))) (HMul.hMul (HPow.hPow (Real.Gamma s) a) (HPow.hPow (Real.Gamma t) b))","decl":"/-- Log-convexity of the Gamma function on the positive reals (stated in multiplicative form),\nproved using the H√∂lder inequality applied to Euler's integral. -/\ntheorem Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma {s t a b : ‚Ñù} (hs : 0 < s) (ht : 0 < t)\n    (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) :\n    Gamma (a * s + b * t) ‚â§ Gamma s ^ a * Gamma t ^ b := by\n  -- We will apply H√∂lder's inequality, for the conjugate exponents `p = 1 / a`\n  -- and `q = 1 / b`, to the functions `f a s` and `f b t`, where `f` is as follows:\n  let f : ‚Ñù ‚Üí ‚Ñù ‚Üí ‚Ñù ‚Üí ‚Ñù := fun c u x => exp (-c * x) * x ^ (c * (u - 1))\n  have e : IsConjExponent (1 / a) (1 / b) := Real.isConjExponent_one_div ha hb hab\n  have hab' : b = 1 - a := by linarith\n  have hst : 0 < a * s + b * t := by positivity\n  -- some properties of f:\n  have posf : ‚àÄ c u x : ‚Ñù, x ‚àà Ioi (0 : ‚Ñù) ‚Üí 0 ‚â§ f c u x := fun c u x hx =>\n    mul_nonneg (exp_pos _).le (rpow_pos_of_pos hx _).le\n  have posf' : ‚àÄ c u : ‚Ñù, ‚àÄ·µê x : ‚Ñù ‚àÇvolume.restrict (Ioi 0), 0 ‚â§ f c u x := fun c u =>\n    (ae_restrict_iff' measurableSet_Ioi).mpr (ae_of_all _ (posf c u))\n  have fpow :\n    ‚àÄ {c x : ‚Ñù} (_ : 0 < c) (u : ‚Ñù) (_ : 0 < x), exp (-x) * x ^ (u - 1) = f c u x ^ (1 / c) := by\n    intro c x hc u hx\n    dsimp only [f]\n    rw [mul_rpow (exp_pos _).le ((rpow_nonneg hx.le) _), ‚Üê exp_mul, ‚Üê rpow_mul hx.le]\n    congr 2 <;> field_simp [hc.ne']; ring\n  -- show `f c u` is in `‚Ñíp` for `p = 1/c`:\n  have f_mem_Lp :\n    ‚àÄ {c u : ‚Ñù} (hc : 0 < c) (hu : 0 < u),\n      Mem‚Ñíp (f c u) (ENNReal.ofReal (1 / c)) (volume.restrict (Ioi 0)) := by\n    intro c u hc hu\n    have A : ENNReal.ofReal (1 / c) ‚â† 0 := by\n      rwa [Ne, ENNReal.ofReal_eq_zero, not_le, one_div_pos]\n    have B : ENNReal.ofReal (1 / c) ‚â† ‚àû := ENNReal.ofReal_ne_top\n    rw [‚Üê mem‚Ñíp_norm_rpow_iff _ A B, ENNReal.toReal_ofReal (one_div_nonneg.mpr hc.le),\n      ENNReal.div_self A B, mem‚Ñíp_one_iff_integrable]\n    ¬∑ apply Integrable.congr (GammaIntegral_convergent hu)\n      refine eventuallyEq_of_mem (self_mem_ae_restrict measurableSet_Ioi) fun x hx => ?_\n      dsimp only\n      rw [fpow hc u hx]\n      congr 1\n      exact (norm_of_nonneg (posf _ _ x hx)).symm\n    ¬∑ refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi\n      refine (Continuous.continuousOn ?_).mul (continuousOn_of_forall_continuousAt fun x hx => ?_)\n      ¬∑ exact continuous_exp.comp (continuous_const.mul continuous_id')\n      ¬∑ exact continuousAt_rpow_const _ _ (Or.inl (mem_Ioi.mp hx).ne')\n  -- now apply H√∂lder:\n  rw [Gamma_eq_integral hs, Gamma_eq_integral ht, Gamma_eq_integral hst]\n  convert\n    MeasureTheory.integral_mul_le_Lp_mul_Lq_of_nonneg e (posf' a s) (posf' b t) (f_mem_Lp ha hs)\n      (f_mem_Lp hb ht) using\n    1\n  ¬∑ refine setIntegral_congr_fun measurableSet_Ioi fun x hx => ?_\n    dsimp only\n    have A : exp (-x) = exp (-a * x) * exp (-b * x) := by\n      rw [‚Üê exp_add, ‚Üê add_mul, ‚Üê neg_add, hab, neg_one_mul]\n    have B : x ^ (a * s + b * t - 1) = x ^ (a * (s - 1)) * x ^ (b * (t - 1)) := by\n      rw [‚Üê rpow_add hx, hab']; congr 1; ring\n    rw [A, B]\n    ring\n  ¬∑ rw [one_div_one_div, one_div_one_div]\n    congr 2 <;> exact setIntegral_congr_fun measurableSet_Ioi fun x hx => fpow (by assumption) _ hx\n\n"}
{"name":"Real.convexOn_log_Gamma","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"‚ä¢ ConvexOn Real (Set.Ioi 0) (Function.comp Real.log Real.Gamma)","decl":"theorem convexOn_log_Gamma : ConvexOn ‚Ñù (Ioi 0) (log ‚àò Gamma) := by\n  refine convexOn_iff_forall_pos.mpr ‚ü®convex_Ioi _, fun x hx y hy a b ha hb hab => ?_‚ü©\n  have : b = 1 - a := by linarith\n  subst this\n  simp_rw [Function.comp_apply, smul_eq_mul]\n  simp only [mem_Ioi] at hx hy\n  rw [‚Üê log_rpow, ‚Üê log_rpow, ‚Üê log_mul]\n  ¬∑ gcongr\n    exact Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma hx hy ha hb hab\n  all_goals positivity\n\n"}
{"name":"Real.convexOn_Gamma","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"‚ä¢ ConvexOn Real (Set.Ioi 0) Real.Gamma","decl":"theorem convexOn_Gamma : ConvexOn ‚Ñù (Ioi 0) Gamma := by\n  refine\n    ((convexOn_exp.subset (subset_univ _) ?_).comp convexOn_log_Gamma\n          (exp_monotone.monotoneOn _)).congr\n      fun x hx => exp_log (Gamma_pos_of_pos hx)\n  rw [convex_iff_isPreconnected]\n  refine isPreconnected_Ioi.image _ fun x hx => ContinuousAt.continuousWithinAt ?_\n  refine (differentiableAt_Gamma fun m => ?_).continuousAt.log (Gamma_pos_of_pos hx).ne'\n  exact (neg_lt_iff_pos_add.mpr (add_pos_of_pos_of_nonneg (mem_Ioi.mp hx) (Nat.cast_nonneg m))).ne'\n\n"}
{"name":"Real.BohrMollerup.f_nat_eq","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"f : Real ‚Üí Real\nn : Nat\nhf_feq : ‚àÄ {y : Real}, LT.lt 0 y ‚Üí Eq (f (HAdd.hAdd y 1)) (HAdd.hAdd (f y) (Real.log y))\nhn : Ne n 0\n‚ä¢ Eq (f ‚Üën) (HAdd.hAdd (f 1) (Real.log ‚Üë(HSub.hSub n 1).factorial))","decl":"theorem f_nat_eq (hf_feq : ‚àÄ {y : ‚Ñù}, 0 < y ‚Üí f (y + 1) = f y + log y) (hn : n ‚â† 0) :\n    f n = f 1 + log (n - 1)! := by\n  refine Nat.le_induction (by simp) (fun m hm IH => ?_) n (Nat.one_le_iff_ne_zero.2 hn)\n  have A : 0 < (m : ‚Ñù) := Nat.cast_pos.2 hm\n  simp only [hf_feq A, Nat.cast_add, Nat.cast_one, Nat.add_succ_sub_one, add_zero]\n  rw [IH, add_assoc, ‚Üê log_mul (Nat.cast_ne_zero.mpr (Nat.factorial_ne_zero _)) A.ne', ‚Üê\n    Nat.cast_mul]\n  conv_rhs => rw [‚Üê Nat.succ_pred_eq_of_pos hm, Nat.factorial_succ, mul_comm]\n  congr\n  exact (Nat.succ_pred_eq_of_pos hm).symm\n\n"}
{"name":"Real.BohrMollerup.f_add_nat_eq","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"f : Real ‚Üí Real\nx : Real\nhf_feq : ‚àÄ {y : Real}, LT.lt 0 y ‚Üí Eq (f (HAdd.hAdd y 1)) (HAdd.hAdd (f y) (Real.log y))\nhx : LT.lt 0 x\nn : Nat\n‚ä¢ Eq (f (HAdd.hAdd x ‚Üën)) (HAdd.hAdd (f x) ((Finset.range n).sum fun m => Real.log (HAdd.hAdd x ‚Üëm)))","decl":"theorem f_add_nat_eq (hf_feq : ‚àÄ {y : ‚Ñù}, 0 < y ‚Üí f (y + 1) = f y + log y) (hx : 0 < x) (n : ‚Ñï) :\n    f (x + n) = f x + ‚àë m ‚àà Finset.range n, log (x + m) := by\n  induction n with\n  | zero => simp\n  | succ n hn =>\n    have : x + n.succ = x + n + 1 := by push_cast; ring\n    rw [this, hf_feq, hn]\n    ¬∑ rw [Finset.range_succ, Finset.sum_insert Finset.not_mem_range_self]\n      abel\n    ¬∑ linarith [(Nat.cast_nonneg n : 0 ‚â§ (n : ‚Ñù))]\n\n"}
{"name":"Real.BohrMollerup.f_add_nat_le","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"f : Real ‚Üí Real\nx : Real\nn : Nat\nhf_conv : ConvexOn Real (Set.Ioi 0) f\nhf_feq : ‚àÄ {y : Real}, LT.lt 0 y ‚Üí Eq (f (HAdd.hAdd y 1)) (HAdd.hAdd (f y) (Real.log y))\nhn : Ne n 0\nhx : LT.lt 0 x\nhx' : LE.le x 1\n‚ä¢ LE.le (f (HAdd.hAdd (‚Üën) x)) (HAdd.hAdd (f ‚Üën) (HMul.hMul x (Real.log ‚Üën)))","decl":"/-- Linear upper bound for `f (x + n)` on unit interval -/\ntheorem f_add_nat_le (hf_conv : ConvexOn ‚Ñù (Ioi 0) f)\n    (hf_feq : ‚àÄ {y : ‚Ñù}, 0 < y ‚Üí f (y + 1) = f y + log y) (hn : n ‚â† 0) (hx : 0 < x) (hx' : x ‚â§ 1) :\n    f (n + x) ‚â§ f n + x * log n := by\n  have hn' : 0 < (n : ‚Ñù) := Nat.cast_pos.mpr (Nat.pos_of_ne_zero hn)\n  have : f n + x * log n = (1 - x) * f n + x * f (n + 1) := by rw [hf_feq hn']; ring\n  rw [this, (by ring : (n : ‚Ñù) + x = (1 - x) * n + x * (n + 1))]\n  simpa only [smul_eq_mul] using\n    hf_conv.2 hn' (by linarith : 0 < (n + 1 : ‚Ñù)) (by linarith : 0 ‚â§ 1 - x) hx.le (by linarith)\n\n"}
{"name":"Real.BohrMollerup.f_add_nat_ge","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"f : Real ‚Üí Real\nx : Real\nn : Nat\nhf_conv : ConvexOn Real (Set.Ioi 0) f\nhf_feq : ‚àÄ {y : Real}, LT.lt 0 y ‚Üí Eq (f (HAdd.hAdd y 1)) (HAdd.hAdd (f y) (Real.log y))\nhn : LE.le 2 n\nhx : LT.lt 0 x\n‚ä¢ LE.le (HAdd.hAdd (f ‚Üën) (HMul.hMul x (Real.log (HSub.hSub (‚Üën) 1)))) (f (HAdd.hAdd (‚Üën) x))","decl":"/-- Linear lower bound for `f (x + n)` on unit interval -/\ntheorem f_add_nat_ge (hf_conv : ConvexOn ‚Ñù (Ioi 0) f)\n    (hf_feq : ‚àÄ {y : ‚Ñù}, 0 < y ‚Üí f (y + 1) = f y + log y) (hn : 2 ‚â§ n) (hx : 0 < x) :\n    f n + x * log (n - 1) ‚â§ f (n + x) := by\n  have npos : 0 < (n : ‚Ñù) - 1 := by rw [‚Üê Nat.cast_one, sub_pos, Nat.cast_lt]; omega\n  have c :=\n    (convexOn_iff_slope_mono_adjacent.mp <| hf_conv).2 npos (by linarith : 0 < (n : ‚Ñù) + x)\n      (by linarith : (n : ‚Ñù) - 1 < (n : ‚Ñù)) (by linarith)\n  rw [add_sub_cancel_left, sub_sub_cancel, div_one] at c\n  have : f (‚Üën - 1) = f n - log (‚Üën - 1) := by\n    -- Porting note: was\n    -- nth_rw_rhs 1 [(by ring : (n : ‚Ñù) = ‚Üën - 1 + 1)]\n    -- rw [hf_feq npos, add_sub_cancel]\n    rw [eq_sub_iff_add_eq, ‚Üê hf_feq npos, sub_add_cancel]\n  rwa [this, le_div_iff‚ÇÄ hx, sub_sub_cancel, le_sub_iff_add_le, mul_comm _ x, add_comm] at c\n\n"}
{"name":"Real.BohrMollerup.logGammaSeq_add_one","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"x : Real\nn : Nat\n‚ä¢ Eq (Real.BohrMollerup.logGammaSeq (HAdd.hAdd x 1) n) (HSub.hSub (HAdd.hAdd (Real.BohrMollerup.logGammaSeq x (HAdd.hAdd n 1)) (Real.log x)) (HMul.hMul (HAdd.hAdd x 1) (HSub.hSub (Real.log (HAdd.hAdd (‚Üën) 1)) (Real.log ‚Üën))))","decl":"theorem logGammaSeq_add_one (x : ‚Ñù) (n : ‚Ñï) :\n    logGammaSeq (x + 1) n = logGammaSeq x (n + 1) + log x - (x + 1) * (log (n + 1) - log n) := by\n  dsimp only [Nat.factorial_succ, logGammaSeq]\n  conv_rhs => rw [Finset.sum_range_succ', Nat.cast_zero, add_zero]\n  rw [Nat.cast_mul, log_mul]; rotate_left\n  ¬∑ rw [Nat.cast_ne_zero]; exact Nat.succ_ne_zero n\n  ¬∑ rw [Nat.cast_ne_zero]; exact Nat.factorial_ne_zero n\n  have :\n    ‚àë m ‚àà Finset.range (n + 1), log (x + 1 + ‚Üëm) =\n      ‚àë k ‚àà Finset.range (n + 1), log (x + ‚Üë(k + 1)) := by\n    congr! 2 with m\n    push_cast\n    abel\n  rw [‚Üê this, Nat.cast_add_one n]\n  ring\n\n"}
{"name":"Real.BohrMollerup.le_logGammaSeq","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"f : Real ‚Üí Real\nx : Real\nhf_conv : ConvexOn Real (Set.Ioi 0) f\nhf_feq : ‚àÄ {y : Real}, LT.lt 0 y ‚Üí Eq (f (HAdd.hAdd y 1)) (HAdd.hAdd (f y) (Real.log y))\nhx : LT.lt 0 x\nhx' : LE.le x 1\nn : Nat\n‚ä¢ LE.le (f x) (HAdd.hAdd (HSub.hSub (HAdd.hAdd (f 1) (HMul.hMul x (Real.log (HAdd.hAdd (‚Üën) 1)))) (HMul.hMul x (Real.log ‚Üën))) (Real.BohrMollerup.logGammaSeq x n))","decl":"theorem le_logGammaSeq (hf_conv : ConvexOn ‚Ñù (Ioi 0) f)\n    (hf_feq : ‚àÄ {y : ‚Ñù}, 0 < y ‚Üí f (y + 1) = f y + log y) (hx : 0 < x) (hx' : x ‚â§ 1) (n : ‚Ñï) :\n    f x ‚â§ f 1 + x * log (n + 1) - x * log n + logGammaSeq x n := by\n  rw [logGammaSeq, ‚Üê add_sub_assoc, le_sub_iff_add_le, ‚Üê f_add_nat_eq (@hf_feq) hx, add_comm x]\n  refine (f_add_nat_le hf_conv (@hf_feq) (Nat.add_one_ne_zero n) hx hx').trans (le_of_eq ?_)\n  rw [f_nat_eq @hf_feq (by omega : n + 1 ‚â† 0), Nat.add_sub_cancel, Nat.cast_add_one]\n  ring\n\n"}
{"name":"Real.BohrMollerup.ge_logGammaSeq","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"f : Real ‚Üí Real\nx : Real\nn : Nat\nhf_conv : ConvexOn Real (Set.Ioi 0) f\nhf_feq : ‚àÄ {y : Real}, LT.lt 0 y ‚Üí Eq (f (HAdd.hAdd y 1)) (HAdd.hAdd (f y) (Real.log y))\nhx : LT.lt 0 x\nhn : Ne n 0\n‚ä¢ LE.le (HAdd.hAdd (f 1) (Real.BohrMollerup.logGammaSeq x n)) (f x)","decl":"theorem ge_logGammaSeq (hf_conv : ConvexOn ‚Ñù (Ioi 0) f)\n    (hf_feq : ‚àÄ {y : ‚Ñù}, 0 < y ‚Üí f (y + 1) = f y + log y) (hx : 0 < x) (hn : n ‚â† 0) :\n    f 1 + logGammaSeq x n ‚â§ f x := by\n  dsimp [logGammaSeq]\n  rw [‚Üê add_sub_assoc, sub_le_iff_le_add, ‚Üê f_add_nat_eq (@hf_feq) hx, add_comm x _]\n  refine le_trans (le_of_eq ?_) (f_add_nat_ge hf_conv @hf_feq ?_ hx)\n  ¬∑ rw [f_nat_eq @hf_feq, Nat.add_sub_cancel, Nat.cast_add_one, add_sub_cancel_right]\n    ¬∑ ring\n    ¬∑ exact Nat.succ_ne_zero _\n  ¬∑ omega\n\n"}
{"name":"Real.BohrMollerup.tendsto_logGammaSeq_of_le_one","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"f : Real ‚Üí Real\nx : Real\nhf_conv : ConvexOn Real (Set.Ioi 0) f\nhf_feq : ‚àÄ {y : Real}, LT.lt 0 y ‚Üí Eq (f (HAdd.hAdd y 1)) (HAdd.hAdd (f y) (Real.log y))\nhx : LT.lt 0 x\nhx' : LE.le x 1\n‚ä¢ Filter.Tendsto (Real.BohrMollerup.logGammaSeq x) Filter.atTop (nhds (HSub.hSub (f x) (f 1)))","decl":"theorem tendsto_logGammaSeq_of_le_one (hf_conv : ConvexOn ‚Ñù (Ioi 0) f)\n    (hf_feq : ‚àÄ {y : ‚Ñù}, 0 < y ‚Üí f (y + 1) = f y + log y) (hx : 0 < x) (hx' : x ‚â§ 1) :\n    Tendsto (logGammaSeq x) atTop (ùìù <| f x - f 1) := by\n  refine tendsto_of_tendsto_of_tendsto_of_le_of_le' (f := logGammaSeq x)\n    (g := fun n ‚Ü¶ f x - f 1 - x * (log (n + 1) - log n)) ?_ tendsto_const_nhds ?_ ?_\n  ¬∑ have : f x - f 1 = f x - f 1 - x * 0 := by ring\n    nth_rw 2 [this]\n    exact Tendsto.sub tendsto_const_nhds (tendsto_log_nat_add_one_sub_log.const_mul _)\n  ¬∑ filter_upwards with n\n    rw [sub_le_iff_le_add', sub_le_iff_le_add']\n    convert le_logGammaSeq hf_conv (@hf_feq) hx hx' n using 1\n    ring\n  ¬∑ show ‚àÄ·∂† n : ‚Ñï in atTop, logGammaSeq x n ‚â§ f x - f 1\n    filter_upwards [eventually_ne_atTop 0] with n hn using\n      le_sub_iff_add_le'.mpr (ge_logGammaSeq hf_conv hf_feq hx hn)\n\n"}
{"name":"Real.BohrMollerup.tendsto_logGammaSeq","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"f : Real ‚Üí Real\nx : Real\nhf_conv : ConvexOn Real (Set.Ioi 0) f\nhf_feq : ‚àÄ {y : Real}, LT.lt 0 y ‚Üí Eq (f (HAdd.hAdd y 1)) (HAdd.hAdd (f y) (Real.log y))\nhx : LT.lt 0 x\n‚ä¢ Filter.Tendsto (Real.BohrMollerup.logGammaSeq x) Filter.atTop (nhds (HSub.hSub (f x) (f 1)))","decl":"theorem tendsto_logGammaSeq (hf_conv : ConvexOn ‚Ñù (Ioi 0) f)\n    (hf_feq : ‚àÄ {y : ‚Ñù}, 0 < y ‚Üí f (y + 1) = f y + log y) (hx : 0 < x) :\n    Tendsto (logGammaSeq x) atTop (ùìù <| f x - f 1) := by\n  suffices ‚àÄ m : ‚Ñï, ‚Üëm < x ‚Üí x ‚â§ m + 1 ‚Üí Tendsto (logGammaSeq x) atTop (ùìù <| f x - f 1) by\n    refine this ‚åàx - 1‚åâ‚Çä ?_ ?_\n    ¬∑ rcases lt_or_le x 1 with ‚ü®‚ü©\n      ¬∑ rwa [Nat.ceil_eq_zero.mpr (by linarith : x - 1 ‚â§ 0), Nat.cast_zero]\n      ¬∑ convert Nat.ceil_lt_add_one (by linarith : 0 ‚â§ x - 1)\n        abel\n    ¬∑ rw [‚Üê sub_le_iff_le_add]; exact Nat.le_ceil _\n  intro m\n  induction' m with m hm generalizing x\n  ¬∑ rw [Nat.cast_zero, zero_add]\n    exact fun _ hx' => tendsto_logGammaSeq_of_le_one hf_conv (@hf_feq) hx hx'\n  ¬∑ intro hy hy'\n    rw [Nat.cast_succ, ‚Üê sub_le_iff_le_add] at hy'\n    rw [Nat.cast_succ, ‚Üê lt_sub_iff_add_lt] at hy\n    specialize hm ((Nat.cast_nonneg _).trans_lt hy) hy hy'\n    -- now massage gauss_product n (x - 1) into gauss_product (n - 1) x\n    have :\n      ‚àÄ·∂† n : ‚Ñï in atTop,\n        logGammaSeq (x - 1) n =\n          logGammaSeq x (n - 1) + x * (log (‚Üë(n - 1) + 1) - log ‚Üë(n - 1)) - log (x - 1) := by\n      refine Eventually.mp (eventually_ge_atTop 1) (Eventually.of_forall fun n hn => ?_)\n      have := logGammaSeq_add_one (x - 1) (n - 1)\n      rw [sub_add_cancel, Nat.sub_add_cancel hn] at this\n      rw [this]\n      ring\n    replace hm :=\n      ((Tendsto.congr' this hm).add (tendsto_const_nhds : Tendsto (fun _ => log (x - 1)) _ _)).comp\n        (tendsto_add_atTop_nat 1)\n    have :\n      ((fun x_1 : ‚Ñï =>\n            (fun n : ‚Ñï =>\n                  logGammaSeq x (n - 1) + x * (log (‚Üë(n - 1) + 1) - log ‚Üë(n - 1)) - log (x - 1))\n                x_1 +\n              (fun b : ‚Ñï => log (x - 1)) x_1) ‚àò\n          fun a : ‚Ñï => a + 1) =\n        fun n => logGammaSeq x n + x * (log (‚Üën + 1) - log ‚Üën) := by\n      ext1 n\n      dsimp only [Function.comp_apply]\n      rw [sub_add_cancel, Nat.add_sub_cancel]\n    rw [this] at hm\n    convert hm.sub (tendsto_log_nat_add_one_sub_log.const_mul x) using 2\n    ¬∑ ring\n    ¬∑ have := hf_feq ((Nat.cast_nonneg m).trans_lt hy)\n      rw [sub_add_cancel] at this\n      rw [this]\n      ring\n\n"}
{"name":"Real.BohrMollerup.tendsto_log_gamma","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"x : Real\nhx : LT.lt 0 x\n‚ä¢ Filter.Tendsto (Real.BohrMollerup.logGammaSeq x) Filter.atTop (nhds (Real.log (Real.Gamma x)))","decl":"theorem tendsto_log_gamma {x : ‚Ñù} (hx : 0 < x) :\n    Tendsto (logGammaSeq x) atTop (ùìù <| log (Gamma x)) := by\n  have : log (Gamma x) = (log ‚àò Gamma) x - (log ‚àò Gamma) 1 := by\n    simp_rw [Function.comp_apply, Gamma_one, log_one, sub_zero]\n  rw [this]\n  refine BohrMollerup.tendsto_logGammaSeq convexOn_log_Gamma (fun {y} hy => ?_) hx\n  rw [Function.comp_apply, Gamma_add_one hy.ne', log_mul hy.ne' (Gamma_pos_of_pos hy).ne', add_comm,\n    Function.comp_apply]\n\n"}
{"name":"Real.eq_Gamma_of_log_convex","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"f : Real ‚Üí Real\nhf_conv : ConvexOn Real (Set.Ioi 0) (Function.comp Real.log f)\nhf_feq : ‚àÄ {y : Real}, LT.lt 0 y ‚Üí Eq (f (HAdd.hAdd y 1)) (HMul.hMul y (f y))\nhf_pos : ‚àÄ {y : Real}, LT.lt 0 y ‚Üí LT.lt 0 (f y)\nhf_one : Eq (f 1) 1\n‚ä¢ Set.EqOn f Real.Gamma (Set.Ioi 0)","decl":"/-- The **Bohr-Mollerup theorem**: the Gamma function is the *unique* log-convex, positive-valued\nfunction on the positive reals which satisfies `f 1 = 1` and `f (x + 1) = x * f x` for all `x`. -/\ntheorem eq_Gamma_of_log_convex {f : ‚Ñù ‚Üí ‚Ñù} (hf_conv : ConvexOn ‚Ñù (Ioi 0) (log ‚àò f))\n    (hf_feq : ‚àÄ {y : ‚Ñù}, 0 < y ‚Üí f (y + 1) = y * f y) (hf_pos : ‚àÄ {y : ‚Ñù}, 0 < y ‚Üí 0 < f y)\n    (hf_one : f 1 = 1) : EqOn f Gamma (Ioi (0 : ‚Ñù)) := by\n  suffices EqOn (log ‚àò f) (log ‚àò Gamma) (Ioi (0 : ‚Ñù)) from\n    fun x hx ‚Ü¶ log_injOn_pos (hf_pos hx) (Gamma_pos_of_pos hx) (this hx)\n  intro x hx\n  have e1 := BohrMollerup.tendsto_logGammaSeq hf_conv ?_ hx\n  ¬∑ rw [Function.comp_apply (f := log) (g := f) (x := 1), hf_one, log_one, sub_zero] at e1\n    exact tendsto_nhds_unique e1 (BohrMollerup.tendsto_log_gamma hx)\n  ¬∑ intro y hy\n    rw [Function.comp_apply, Function.comp_apply, hf_feq hy, log_mul hy.ne' (hf_pos hy).ne']\n    ring\n\n"}
{"name":"Real.Gamma_two","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"‚ä¢ Eq (Real.Gamma 2) 1","decl":"theorem Gamma_two : Gamma 2 = 1 := by simp [Nat.factorial_one]\n\n"}
{"name":"Real.Gamma_three_div_two_lt_one","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"‚ä¢ LT.lt (Real.Gamma (3 / 2)) 1","decl":"theorem Gamma_three_div_two_lt_one : Gamma (3 / 2) < 1 := by\n  -- This can also be proved using the closed-form evaluation of `Gamma (1 / 2)` in\n  -- `Mathlib/Analysis/SpecialFunctions/Gaussian.lean`, but we give a self-contained proof using\n  -- log-convexity to avoid unnecessary imports.\n  have A : (0 : ‚Ñù) < 3 / 2 := by norm_num\n  have :=\n    BohrMollerup.f_add_nat_le convexOn_log_Gamma (fun {y} hy => ?_) two_ne_zero one_half_pos\n      (by norm_num : 1 / 2 ‚â§ (1 : ‚Ñù))\n  swap\n  ¬∑ rw [Function.comp_apply, Gamma_add_one hy.ne', log_mul hy.ne' (Gamma_pos_of_pos hy).ne',\n      add_comm, Function.comp_apply]\n  rw [Function.comp_apply, Function.comp_apply, Nat.cast_two, Gamma_two, log_one, zero_add,\n    (by norm_num : (2 : ‚Ñù) + 1 / 2 = 3 / 2 + 1), Gamma_add_one A.ne',\n    log_mul A.ne' (Gamma_pos_of_pos A).ne', ‚Üê le_sub_iff_add_le',\n    log_le_iff_le_exp (Gamma_pos_of_pos A)] at this\n  refine this.trans_lt (exp_lt_one_iff.mpr ?_)\n  rw [mul_comm, ‚Üê mul_div_assoc, div_sub' _ _ (2 : ‚Ñù) two_ne_zero]\n  refine div_neg_of_neg_of_pos ?_ two_pos\n  rw [sub_neg, mul_one, ‚Üê Nat.cast_two, ‚Üê log_pow, ‚Üê exp_lt_exp, Nat.cast_two, exp_log two_pos,\n      exp_log] <;>\n    norm_num\n\n"}
{"name":"Real.Gamma_strictMonoOn_Ici","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"‚ä¢ StrictMonoOn Real.Gamma (Set.Ici 2)","decl":"theorem Gamma_strictMonoOn_Ici : StrictMonoOn Gamma (Ici 2) := by\n  convert\n    convexOn_Gamma.strict_mono_of_lt (by norm_num : (0 : ‚Ñù) < 3 / 2)\n      (by norm_num : (3 / 2 : ‚Ñù) < 2) (Gamma_two.symm ‚ñ∏ Gamma_three_div_two_lt_one)\n  symm\n  rw [inter_eq_right]\n  exact fun x hx => two_pos.trans_le <| mem_Ici.mp hx\n\n"}
{"name":"Real.doublingGamma_add_one","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"s : Real\nhs : Ne s 0\n‚ä¢ Eq (HAdd.hAdd s 1).doublingGamma (HMul.hMul s s.doublingGamma)","decl":"theorem doublingGamma_add_one (s : ‚Ñù) (hs : s ‚â† 0) :\n    doublingGamma (s + 1) = s * doublingGamma s := by\n  rw [doublingGamma, doublingGamma, (by abel : s + 1 - 1 = s - 1 + 1), add_div, add_assoc,\n    add_halves (1 : ‚Ñù), Gamma_add_one (div_ne_zero hs two_ne_zero), rpow_add two_pos, rpow_one]\n  ring\n\n"}
{"name":"Real.doublingGamma_one","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"‚ä¢ Eq (Real.doublingGamma 1) 1","decl":"theorem doublingGamma_one : doublingGamma 1 = 1 := by\n  simp_rw [doublingGamma, Gamma_one_half_eq, add_halves (1 : ‚Ñù), sub_self, Gamma_one, mul_one,\n    rpow_zero, mul_one, div_self (sqrt_ne_zero'.mpr pi_pos)]\n\n"}
{"name":"Real.log_doublingGamma_eq","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"‚ä¢ Set.EqOn (Function.comp Real.log Real.doublingGamma) (fun s => HSub.hSub (HAdd.hAdd (HAdd.hAdd (Real.log (Real.Gamma (HDiv.hDiv s 2))) (Real.log (Real.Gamma (HAdd.hAdd (HDiv.hDiv s 2) (1 / 2))))) (HMul.hMul s (Real.log 2))) (Real.log (HMul.hMul 2 Real.pi.sqrt))) (Set.Ioi 0)","decl":"theorem log_doublingGamma_eq :\n    EqOn (log ‚àò doublingGamma)\n      (fun s => log (Gamma (s / 2)) + log (Gamma (s / 2 + 1 / 2)) + s * log 2 - log (2 * ‚àöœÄ))\n      (Ioi 0) := by\n  intro s hs\n  have h1 : ‚àöœÄ ‚â† 0 := sqrt_ne_zero'.mpr pi_pos\n  have h2 : Gamma (s / 2) ‚â† 0 := (Gamma_pos_of_pos <| div_pos hs two_pos).ne'\n  have h3 : Gamma (s / 2 + 1 / 2) ‚â† 0 :=\n    (Gamma_pos_of_pos <| add_pos (div_pos hs two_pos) one_half_pos).ne'\n  have h4 : (2 : ‚Ñù) ^ (s - 1) ‚â† 0 := (rpow_pos_of_pos two_pos _).ne'\n  rw [Function.comp_apply, doublingGamma, log_div (mul_ne_zero (mul_ne_zero h2 h3) h4) h1,\n    log_mul (mul_ne_zero h2 h3) h4, log_mul h2 h3, log_rpow two_pos, log_mul two_ne_zero h1]\n  ring_nf\n\n"}
{"name":"Real.doublingGamma_log_convex_Ioi","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"‚ä¢ ConvexOn Real (Set.Ioi 0) (Function.comp Real.log Real.doublingGamma)","decl":"theorem doublingGamma_log_convex_Ioi : ConvexOn ‚Ñù (Ioi (0 : ‚Ñù)) (log ‚àò doublingGamma) := by\n  refine (((ConvexOn.add ?_ ?_).add ?_).add_const _).congr log_doublingGamma_eq.symm\n  ¬∑ convert\n      convexOn_log_Gamma.comp_affineMap (DistribMulAction.toLinearMap ‚Ñù ‚Ñù (1 / 2 : ‚Ñù)).toAffineMap\n      using 1\n    ¬∑ simpa only [zero_div] using (preimage_const_mul_Ioi (0 : ‚Ñù) one_half_pos).symm\n    ¬∑ ext1 x\n      -- Porting note: was\n      -- change log (Gamma (x / 2)) = log (Gamma ((1 / 2 : ‚Ñù) ‚Ä¢ x))\n      simp only [LinearMap.coe_toAffineMap, Function.comp_apply, DistribMulAction.toLinearMap_apply]\n      rw [smul_eq_mul, mul_comm, mul_one_div]\n  ¬∑ refine ConvexOn.subset ?_ (Ioi_subset_Ioi <| neg_one_lt_zero.le) (convex_Ioi _)\n    convert\n      convexOn_log_Gamma.comp_affineMap\n        ((DistribMulAction.toLinearMap ‚Ñù ‚Ñù (1 / 2 : ‚Ñù)).toAffineMap +\n          AffineMap.const ‚Ñù ‚Ñù (1 / 2 : ‚Ñù)) using 1\n    ¬∑ change Ioi (-1 : ‚Ñù) = ((fun x : ‚Ñù => x + 1 / 2) ‚àò fun x : ‚Ñù => (1 / 2 : ‚Ñù) * x) ‚Åª¬π' Ioi 0\n      rw [preimage_comp, preimage_add_const_Ioi, zero_sub,\n        preimage_const_mul_Ioi (_ : ‚Ñù) one_half_pos, neg_div, div_self (@one_half_pos ‚Ñù _).ne']\n    ¬∑ ext1 x\n      change log (Gamma (x / 2 + 1 / 2)) = log (Gamma ((1 / 2 : ‚Ñù) ‚Ä¢ x + 1 / 2))\n      rw [smul_eq_mul, mul_comm, mul_one_div]\n  ¬∑ simpa only [mul_comm _ (log _)] using\n      (convexOn_id (convex_Ioi (0 : ‚Ñù))).smul (log_pos one_lt_two).le\n\n"}
{"name":"Real.doublingGamma_eq_Gamma","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"s : Real\nhs : LT.lt 0 s\n‚ä¢ Eq s.doublingGamma (Real.Gamma s)","decl":"theorem doublingGamma_eq_Gamma {s : ‚Ñù} (hs : 0 < s) : doublingGamma s = Gamma s := by\n  refine\n    eq_Gamma_of_log_convex doublingGamma_log_convex_Ioi\n      (fun {y} hy => doublingGamma_add_one y hy.ne') (fun {y} hy => ?_) doublingGamma_one hs\n  apply_rules [mul_pos, Gamma_pos_of_pos, add_pos, inv_pos_of_pos, rpow_pos_of_pos, two_pos,\n    one_pos, sqrt_pos_of_pos pi_pos]\n\n"}
{"name":"Real.Gamma_mul_Gamma_add_half_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"s : Real\nhs : LT.lt 0 s\n‚ä¢ Eq (HMul.hMul (Real.Gamma s) (Real.Gamma (HAdd.hAdd s (1 / 2)))) (HMul.hMul (HMul.hMul (Real.Gamma (HMul.hMul 2 s)) (HPow.hPow 2 (HSub.hSub 1 (HMul.hMul 2 s)))) Real.pi.sqrt)","decl":"/-- Legendre's doubling formula for the Gamma function, for positive real arguments. Note that\nwe shall later prove this for all `s` as `Real.Gamma_mul_Gamma_add_half` (superseding this result)\nbut this result is needed as an intermediate step. -/\ntheorem Gamma_mul_Gamma_add_half_of_pos {s : ‚Ñù} (hs : 0 < s) :\n    Gamma s * Gamma (s + 1 / 2) = Gamma (2 * s) * 2 ^ (1 - 2 * s) * ‚àöœÄ := by\n  rw [‚Üê doublingGamma_eq_Gamma (mul_pos two_pos hs), doublingGamma,\n    mul_div_cancel_left‚ÇÄ _ (two_ne_zero' ‚Ñù), (by abel : 1 - 2 * s = -(2 * s - 1)),\n    rpow_neg zero_le_two]\n  field_simp [(sqrt_pos_of_pos pi_pos).ne', (rpow_pos_of_pos two_pos (2 * s - 1)).ne']\n  ring\n\n"}
