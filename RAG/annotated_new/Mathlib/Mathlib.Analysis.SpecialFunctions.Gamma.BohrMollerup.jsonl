{"name":"Real.Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"s t a b : Real\nhs : LT.lt 0 s\nht : LT.lt 0 t\nha : LT.lt 0 a\nhb : LT.lt 0 b\nhab : Eq (HAdd.hAdd a b) 1\n⊢ LE.le (Real.Gamma (HAdd.hAdd (HMul.hMul a s) (HMul.hMul b t))) (HMul.hMul (HPow.hPow (Real.Gamma s) a) (HPow.hPow (Real.Gamma t) b))","decl":"/-- Log-convexity of the Gamma function on the positive reals (stated in multiplicative form),\nproved using the Hölder inequality applied to Euler's integral. -/\ntheorem Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma {s t a b : ℝ} (hs : 0 < s) (ht : 0 < t)\n    (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) :\n    Gamma (a * s + b * t) ≤ Gamma s ^ a * Gamma t ^ b := by\n  -- We will apply Hölder's inequality, for the conjugate exponents `p = 1 / a`\n  -- and `q = 1 / b`, to the functions `f a s` and `f b t`, where `f` is as follows:\n  let f : ℝ → ℝ → ℝ → ℝ := fun c u x => exp (-c * x) * x ^ (c * (u - 1))\n  have e : IsConjExponent (1 / a) (1 / b) := Real.isConjExponent_one_div ha hb hab\n  have hab' : b = 1 - a := by linarith\n  have hst : 0 < a * s + b * t := by positivity\n  -- some properties of f:\n  have posf : ∀ c u x : ℝ, x ∈ Ioi (0 : ℝ) → 0 ≤ f c u x := fun c u x hx =>\n    mul_nonneg (exp_pos _).le (rpow_pos_of_pos hx _).le\n  have posf' : ∀ c u : ℝ, ∀ᵐ x : ℝ ∂volume.restrict (Ioi 0), 0 ≤ f c u x := fun c u =>\n    (ae_restrict_iff' measurableSet_Ioi).mpr (ae_of_all _ (posf c u))\n  have fpow :\n    ∀ {c x : ℝ} (_ : 0 < c) (u : ℝ) (_ : 0 < x), exp (-x) * x ^ (u - 1) = f c u x ^ (1 / c) := by\n    intro c x hc u hx\n    dsimp only [f]\n    rw [mul_rpow (exp_pos _).le ((rpow_nonneg hx.le) _), ← exp_mul, ← rpow_mul hx.le]\n    congr 2 <;> field_simp [hc.ne']; ring\n  -- show `f c u` is in `ℒp` for `p = 1/c`:\n  have f_mem_Lp :\n    ∀ {c u : ℝ} (hc : 0 < c) (hu : 0 < u),\n      Memℒp (f c u) (ENNReal.ofReal (1 / c)) (volume.restrict (Ioi 0)) := by\n    intro c u hc hu\n    have A : ENNReal.ofReal (1 / c) ≠ 0 := by\n      rwa [Ne, ENNReal.ofReal_eq_zero, not_le, one_div_pos]\n    have B : ENNReal.ofReal (1 / c) ≠ ∞ := ENNReal.ofReal_ne_top\n    rw [← memℒp_norm_rpow_iff _ A B, ENNReal.toReal_ofReal (one_div_nonneg.mpr hc.le),\n      ENNReal.div_self A B, memℒp_one_iff_integrable]\n    · apply Integrable.congr (GammaIntegral_convergent hu)\n      refine eventuallyEq_of_mem (self_mem_ae_restrict measurableSet_Ioi) fun x hx => ?_\n      dsimp only\n      rw [fpow hc u hx]\n      congr 1\n      exact (norm_of_nonneg (posf _ _ x hx)).symm\n    · refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi\n      refine (Continuous.continuousOn ?_).mul (continuousOn_of_forall_continuousAt fun x hx => ?_)\n      · exact continuous_exp.comp (continuous_const.mul continuous_id')\n      · exact continuousAt_rpow_const _ _ (Or.inl (mem_Ioi.mp hx).ne')\n  -- now apply Hölder:\n  rw [Gamma_eq_integral hs, Gamma_eq_integral ht, Gamma_eq_integral hst]\n  convert\n    MeasureTheory.integral_mul_le_Lp_mul_Lq_of_nonneg e (posf' a s) (posf' b t) (f_mem_Lp ha hs)\n      (f_mem_Lp hb ht) using\n    1\n  · refine setIntegral_congr_fun measurableSet_Ioi fun x hx => ?_\n    dsimp only\n    have A : exp (-x) = exp (-a * x) * exp (-b * x) := by\n      rw [← exp_add, ← add_mul, ← neg_add, hab, neg_one_mul]\n    have B : x ^ (a * s + b * t - 1) = x ^ (a * (s - 1)) * x ^ (b * (t - 1)) := by\n      rw [← rpow_add hx, hab']; congr 1; ring\n    rw [A, B]\n    ring\n  · rw [one_div_one_div, one_div_one_div]\n    congr 2 <;> exact setIntegral_congr_fun measurableSet_Ioi fun x hx => fpow (by assumption) _ hx\n\n"}
{"name":"Real.convexOn_log_Gamma","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"⊢ ConvexOn Real (Set.Ioi 0) (Function.comp Real.log Real.Gamma)","decl":"theorem convexOn_log_Gamma : ConvexOn ℝ (Ioi 0) (log ∘ Gamma) := by\n  refine convexOn_iff_forall_pos.mpr ⟨convex_Ioi _, fun x hx y hy a b ha hb hab => ?_⟩\n  have : b = 1 - a := by linarith\n  subst this\n  simp_rw [Function.comp_apply, smul_eq_mul]\n  simp only [mem_Ioi] at hx hy\n  rw [← log_rpow, ← log_rpow, ← log_mul]\n  · gcongr\n    exact Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma hx hy ha hb hab\n  all_goals positivity\n\n"}
{"name":"Real.convexOn_Gamma","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"⊢ ConvexOn Real (Set.Ioi 0) Real.Gamma","decl":"theorem convexOn_Gamma : ConvexOn ℝ (Ioi 0) Gamma := by\n  refine\n    ((convexOn_exp.subset (subset_univ _) ?_).comp convexOn_log_Gamma\n          (exp_monotone.monotoneOn _)).congr\n      fun x hx => exp_log (Gamma_pos_of_pos hx)\n  rw [convex_iff_isPreconnected]\n  refine isPreconnected_Ioi.image _ fun x hx => ContinuousAt.continuousWithinAt ?_\n  refine (differentiableAt_Gamma fun m => ?_).continuousAt.log (Gamma_pos_of_pos hx).ne'\n  exact (neg_lt_iff_pos_add.mpr (add_pos_of_pos_of_nonneg (mem_Ioi.mp hx) (Nat.cast_nonneg m))).ne'\n\n"}
{"name":"Real.BohrMollerup.f_nat_eq","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"f : Real → Real\nn : Nat\nhf_feq : ∀ {y : Real}, LT.lt 0 y → Eq (f (HAdd.hAdd y 1)) (HAdd.hAdd (f y) (Real.log y))\nhn : Ne n 0\n⊢ Eq (f ↑n) (HAdd.hAdd (f 1) (Real.log ↑(HSub.hSub n 1).factorial))","decl":"theorem f_nat_eq (hf_feq : ∀ {y : ℝ}, 0 < y → f (y + 1) = f y + log y) (hn : n ≠ 0) :\n    f n = f 1 + log (n - 1)! := by\n  refine Nat.le_induction (by simp) (fun m hm IH => ?_) n (Nat.one_le_iff_ne_zero.2 hn)\n  have A : 0 < (m : ℝ) := Nat.cast_pos.2 hm\n  simp only [hf_feq A, Nat.cast_add, Nat.cast_one, Nat.add_succ_sub_one, add_zero]\n  rw [IH, add_assoc, ← log_mul (Nat.cast_ne_zero.mpr (Nat.factorial_ne_zero _)) A.ne', ←\n    Nat.cast_mul]\n  conv_rhs => rw [← Nat.succ_pred_eq_of_pos hm, Nat.factorial_succ, mul_comm]\n  congr\n  exact (Nat.succ_pred_eq_of_pos hm).symm\n\n"}
{"name":"Real.BohrMollerup.f_add_nat_eq","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"f : Real → Real\nx : Real\nhf_feq : ∀ {y : Real}, LT.lt 0 y → Eq (f (HAdd.hAdd y 1)) (HAdd.hAdd (f y) (Real.log y))\nhx : LT.lt 0 x\nn : Nat\n⊢ Eq (f (HAdd.hAdd x ↑n)) (HAdd.hAdd (f x) ((Finset.range n).sum fun m => Real.log (HAdd.hAdd x ↑m)))","decl":"theorem f_add_nat_eq (hf_feq : ∀ {y : ℝ}, 0 < y → f (y + 1) = f y + log y) (hx : 0 < x) (n : ℕ) :\n    f (x + n) = f x + ∑ m ∈ Finset.range n, log (x + m) := by\n  induction n with\n  | zero => simp\n  | succ n hn =>\n    have : x + n.succ = x + n + 1 := by push_cast; ring\n    rw [this, hf_feq, hn]\n    · rw [Finset.range_succ, Finset.sum_insert Finset.not_mem_range_self]\n      abel\n    · linarith [(Nat.cast_nonneg n : 0 ≤ (n : ℝ))]\n\n"}
{"name":"Real.BohrMollerup.f_add_nat_le","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"f : Real → Real\nx : Real\nn : Nat\nhf_conv : ConvexOn Real (Set.Ioi 0) f\nhf_feq : ∀ {y : Real}, LT.lt 0 y → Eq (f (HAdd.hAdd y 1)) (HAdd.hAdd (f y) (Real.log y))\nhn : Ne n 0\nhx : LT.lt 0 x\nhx' : LE.le x 1\n⊢ LE.le (f (HAdd.hAdd (↑n) x)) (HAdd.hAdd (f ↑n) (HMul.hMul x (Real.log ↑n)))","decl":"/-- Linear upper bound for `f (x + n)` on unit interval -/\ntheorem f_add_nat_le (hf_conv : ConvexOn ℝ (Ioi 0) f)\n    (hf_feq : ∀ {y : ℝ}, 0 < y → f (y + 1) = f y + log y) (hn : n ≠ 0) (hx : 0 < x) (hx' : x ≤ 1) :\n    f (n + x) ≤ f n + x * log n := by\n  have hn' : 0 < (n : ℝ) := Nat.cast_pos.mpr (Nat.pos_of_ne_zero hn)\n  have : f n + x * log n = (1 - x) * f n + x * f (n + 1) := by rw [hf_feq hn']; ring\n  rw [this, (by ring : (n : ℝ) + x = (1 - x) * n + x * (n + 1))]\n  simpa only [smul_eq_mul] using\n    hf_conv.2 hn' (by linarith : 0 < (n + 1 : ℝ)) (by linarith : 0 ≤ 1 - x) hx.le (by linarith)\n\n"}
{"name":"Real.BohrMollerup.f_add_nat_ge","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"f : Real → Real\nx : Real\nn : Nat\nhf_conv : ConvexOn Real (Set.Ioi 0) f\nhf_feq : ∀ {y : Real}, LT.lt 0 y → Eq (f (HAdd.hAdd y 1)) (HAdd.hAdd (f y) (Real.log y))\nhn : LE.le 2 n\nhx : LT.lt 0 x\n⊢ LE.le (HAdd.hAdd (f ↑n) (HMul.hMul x (Real.log (HSub.hSub (↑n) 1)))) (f (HAdd.hAdd (↑n) x))","decl":"/-- Linear lower bound for `f (x + n)` on unit interval -/\ntheorem f_add_nat_ge (hf_conv : ConvexOn ℝ (Ioi 0) f)\n    (hf_feq : ∀ {y : ℝ}, 0 < y → f (y + 1) = f y + log y) (hn : 2 ≤ n) (hx : 0 < x) :\n    f n + x * log (n - 1) ≤ f (n + x) := by\n  have npos : 0 < (n : ℝ) - 1 := by rw [← Nat.cast_one, sub_pos, Nat.cast_lt]; omega\n  have c :=\n    (convexOn_iff_slope_mono_adjacent.mp <| hf_conv).2 npos (by linarith : 0 < (n : ℝ) + x)\n      (by linarith : (n : ℝ) - 1 < (n : ℝ)) (by linarith)\n  rw [add_sub_cancel_left, sub_sub_cancel, div_one] at c\n  have : f (↑n - 1) = f n - log (↑n - 1) := by\n    -- Porting note: was\n    -- nth_rw_rhs 1 [(by ring : (n : ℝ) = ↑n - 1 + 1)]\n    -- rw [hf_feq npos, add_sub_cancel]\n    rw [eq_sub_iff_add_eq, ← hf_feq npos, sub_add_cancel]\n  rwa [this, le_div_iff₀ hx, sub_sub_cancel, le_sub_iff_add_le, mul_comm _ x, add_comm] at c\n\n"}
{"name":"Real.BohrMollerup.logGammaSeq_add_one","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"x : Real\nn : Nat\n⊢ Eq (Real.BohrMollerup.logGammaSeq (HAdd.hAdd x 1) n) (HSub.hSub (HAdd.hAdd (Real.BohrMollerup.logGammaSeq x (HAdd.hAdd n 1)) (Real.log x)) (HMul.hMul (HAdd.hAdd x 1) (HSub.hSub (Real.log (HAdd.hAdd (↑n) 1)) (Real.log ↑n))))","decl":"theorem logGammaSeq_add_one (x : ℝ) (n : ℕ) :\n    logGammaSeq (x + 1) n = logGammaSeq x (n + 1) + log x - (x + 1) * (log (n + 1) - log n) := by\n  dsimp only [Nat.factorial_succ, logGammaSeq]\n  conv_rhs => rw [Finset.sum_range_succ', Nat.cast_zero, add_zero]\n  rw [Nat.cast_mul, log_mul]; rotate_left\n  · rw [Nat.cast_ne_zero]; exact Nat.succ_ne_zero n\n  · rw [Nat.cast_ne_zero]; exact Nat.factorial_ne_zero n\n  have :\n    ∑ m ∈ Finset.range (n + 1), log (x + 1 + ↑m) =\n      ∑ k ∈ Finset.range (n + 1), log (x + ↑(k + 1)) := by\n    congr! 2 with m\n    push_cast\n    abel\n  rw [← this, Nat.cast_add_one n]\n  ring\n\n"}
{"name":"Real.BohrMollerup.le_logGammaSeq","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"f : Real → Real\nx : Real\nhf_conv : ConvexOn Real (Set.Ioi 0) f\nhf_feq : ∀ {y : Real}, LT.lt 0 y → Eq (f (HAdd.hAdd y 1)) (HAdd.hAdd (f y) (Real.log y))\nhx : LT.lt 0 x\nhx' : LE.le x 1\nn : Nat\n⊢ LE.le (f x) (HAdd.hAdd (HSub.hSub (HAdd.hAdd (f 1) (HMul.hMul x (Real.log (HAdd.hAdd (↑n) 1)))) (HMul.hMul x (Real.log ↑n))) (Real.BohrMollerup.logGammaSeq x n))","decl":"theorem le_logGammaSeq (hf_conv : ConvexOn ℝ (Ioi 0) f)\n    (hf_feq : ∀ {y : ℝ}, 0 < y → f (y + 1) = f y + log y) (hx : 0 < x) (hx' : x ≤ 1) (n : ℕ) :\n    f x ≤ f 1 + x * log (n + 1) - x * log n + logGammaSeq x n := by\n  rw [logGammaSeq, ← add_sub_assoc, le_sub_iff_add_le, ← f_add_nat_eq (@hf_feq) hx, add_comm x]\n  refine (f_add_nat_le hf_conv (@hf_feq) (Nat.add_one_ne_zero n) hx hx').trans (le_of_eq ?_)\n  rw [f_nat_eq @hf_feq (by omega : n + 1 ≠ 0), Nat.add_sub_cancel, Nat.cast_add_one]\n  ring\n\n"}
{"name":"Real.BohrMollerup.ge_logGammaSeq","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"f : Real → Real\nx : Real\nn : Nat\nhf_conv : ConvexOn Real (Set.Ioi 0) f\nhf_feq : ∀ {y : Real}, LT.lt 0 y → Eq (f (HAdd.hAdd y 1)) (HAdd.hAdd (f y) (Real.log y))\nhx : LT.lt 0 x\nhn : Ne n 0\n⊢ LE.le (HAdd.hAdd (f 1) (Real.BohrMollerup.logGammaSeq x n)) (f x)","decl":"theorem ge_logGammaSeq (hf_conv : ConvexOn ℝ (Ioi 0) f)\n    (hf_feq : ∀ {y : ℝ}, 0 < y → f (y + 1) = f y + log y) (hx : 0 < x) (hn : n ≠ 0) :\n    f 1 + logGammaSeq x n ≤ f x := by\n  dsimp [logGammaSeq]\n  rw [← add_sub_assoc, sub_le_iff_le_add, ← f_add_nat_eq (@hf_feq) hx, add_comm x _]\n  refine le_trans (le_of_eq ?_) (f_add_nat_ge hf_conv @hf_feq ?_ hx)\n  · rw [f_nat_eq @hf_feq, Nat.add_sub_cancel, Nat.cast_add_one, add_sub_cancel_right]\n    · ring\n    · exact Nat.succ_ne_zero _\n  · omega\n\n"}
{"name":"Real.BohrMollerup.tendsto_logGammaSeq_of_le_one","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"f : Real → Real\nx : Real\nhf_conv : ConvexOn Real (Set.Ioi 0) f\nhf_feq : ∀ {y : Real}, LT.lt 0 y → Eq (f (HAdd.hAdd y 1)) (HAdd.hAdd (f y) (Real.log y))\nhx : LT.lt 0 x\nhx' : LE.le x 1\n⊢ Filter.Tendsto (Real.BohrMollerup.logGammaSeq x) Filter.atTop (nhds (HSub.hSub (f x) (f 1)))","decl":"theorem tendsto_logGammaSeq_of_le_one (hf_conv : ConvexOn ℝ (Ioi 0) f)\n    (hf_feq : ∀ {y : ℝ}, 0 < y → f (y + 1) = f y + log y) (hx : 0 < x) (hx' : x ≤ 1) :\n    Tendsto (logGammaSeq x) atTop (𝓝 <| f x - f 1) := by\n  refine tendsto_of_tendsto_of_tendsto_of_le_of_le' (f := logGammaSeq x)\n    (g := fun n ↦ f x - f 1 - x * (log (n + 1) - log n)) ?_ tendsto_const_nhds ?_ ?_\n  · have : f x - f 1 = f x - f 1 - x * 0 := by ring\n    nth_rw 2 [this]\n    exact Tendsto.sub tendsto_const_nhds (tendsto_log_nat_add_one_sub_log.const_mul _)\n  · filter_upwards with n\n    rw [sub_le_iff_le_add', sub_le_iff_le_add']\n    convert le_logGammaSeq hf_conv (@hf_feq) hx hx' n using 1\n    ring\n  · show ∀ᶠ n : ℕ in atTop, logGammaSeq x n ≤ f x - f 1\n    filter_upwards [eventually_ne_atTop 0] with n hn using\n      le_sub_iff_add_le'.mpr (ge_logGammaSeq hf_conv hf_feq hx hn)\n\n"}
{"name":"Real.BohrMollerup.tendsto_logGammaSeq","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"f : Real → Real\nx : Real\nhf_conv : ConvexOn Real (Set.Ioi 0) f\nhf_feq : ∀ {y : Real}, LT.lt 0 y → Eq (f (HAdd.hAdd y 1)) (HAdd.hAdd (f y) (Real.log y))\nhx : LT.lt 0 x\n⊢ Filter.Tendsto (Real.BohrMollerup.logGammaSeq x) Filter.atTop (nhds (HSub.hSub (f x) (f 1)))","decl":"theorem tendsto_logGammaSeq (hf_conv : ConvexOn ℝ (Ioi 0) f)\n    (hf_feq : ∀ {y : ℝ}, 0 < y → f (y + 1) = f y + log y) (hx : 0 < x) :\n    Tendsto (logGammaSeq x) atTop (𝓝 <| f x - f 1) := by\n  suffices ∀ m : ℕ, ↑m < x → x ≤ m + 1 → Tendsto (logGammaSeq x) atTop (𝓝 <| f x - f 1) by\n    refine this ⌈x - 1⌉₊ ?_ ?_\n    · rcases lt_or_le x 1 with ⟨⟩\n      · rwa [Nat.ceil_eq_zero.mpr (by linarith : x - 1 ≤ 0), Nat.cast_zero]\n      · convert Nat.ceil_lt_add_one (by linarith : 0 ≤ x - 1)\n        abel\n    · rw [← sub_le_iff_le_add]; exact Nat.le_ceil _\n  intro m\n  induction' m with m hm generalizing x\n  · rw [Nat.cast_zero, zero_add]\n    exact fun _ hx' => tendsto_logGammaSeq_of_le_one hf_conv (@hf_feq) hx hx'\n  · intro hy hy'\n    rw [Nat.cast_succ, ← sub_le_iff_le_add] at hy'\n    rw [Nat.cast_succ, ← lt_sub_iff_add_lt] at hy\n    specialize hm ((Nat.cast_nonneg _).trans_lt hy) hy hy'\n    -- now massage gauss_product n (x - 1) into gauss_product (n - 1) x\n    have :\n      ∀ᶠ n : ℕ in atTop,\n        logGammaSeq (x - 1) n =\n          logGammaSeq x (n - 1) + x * (log (↑(n - 1) + 1) - log ↑(n - 1)) - log (x - 1) := by\n      refine Eventually.mp (eventually_ge_atTop 1) (Eventually.of_forall fun n hn => ?_)\n      have := logGammaSeq_add_one (x - 1) (n - 1)\n      rw [sub_add_cancel, Nat.sub_add_cancel hn] at this\n      rw [this]\n      ring\n    replace hm :=\n      ((Tendsto.congr' this hm).add (tendsto_const_nhds : Tendsto (fun _ => log (x - 1)) _ _)).comp\n        (tendsto_add_atTop_nat 1)\n    have :\n      ((fun x_1 : ℕ =>\n            (fun n : ℕ =>\n                  logGammaSeq x (n - 1) + x * (log (↑(n - 1) + 1) - log ↑(n - 1)) - log (x - 1))\n                x_1 +\n              (fun b : ℕ => log (x - 1)) x_1) ∘\n          fun a : ℕ => a + 1) =\n        fun n => logGammaSeq x n + x * (log (↑n + 1) - log ↑n) := by\n      ext1 n\n      dsimp only [Function.comp_apply]\n      rw [sub_add_cancel, Nat.add_sub_cancel]\n    rw [this] at hm\n    convert hm.sub (tendsto_log_nat_add_one_sub_log.const_mul x) using 2\n    · ring\n    · have := hf_feq ((Nat.cast_nonneg m).trans_lt hy)\n      rw [sub_add_cancel] at this\n      rw [this]\n      ring\n\n"}
{"name":"Real.BohrMollerup.tendsto_log_gamma","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"x : Real\nhx : LT.lt 0 x\n⊢ Filter.Tendsto (Real.BohrMollerup.logGammaSeq x) Filter.atTop (nhds (Real.log (Real.Gamma x)))","decl":"theorem tendsto_log_gamma {x : ℝ} (hx : 0 < x) :\n    Tendsto (logGammaSeq x) atTop (𝓝 <| log (Gamma x)) := by\n  have : log (Gamma x) = (log ∘ Gamma) x - (log ∘ Gamma) 1 := by\n    simp_rw [Function.comp_apply, Gamma_one, log_one, sub_zero]\n  rw [this]\n  refine BohrMollerup.tendsto_logGammaSeq convexOn_log_Gamma (fun {y} hy => ?_) hx\n  rw [Function.comp_apply, Gamma_add_one hy.ne', log_mul hy.ne' (Gamma_pos_of_pos hy).ne', add_comm,\n    Function.comp_apply]\n\n"}
{"name":"Real.eq_Gamma_of_log_convex","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"f : Real → Real\nhf_conv : ConvexOn Real (Set.Ioi 0) (Function.comp Real.log f)\nhf_feq : ∀ {y : Real}, LT.lt 0 y → Eq (f (HAdd.hAdd y 1)) (HMul.hMul y (f y))\nhf_pos : ∀ {y : Real}, LT.lt 0 y → LT.lt 0 (f y)\nhf_one : Eq (f 1) 1\n⊢ Set.EqOn f Real.Gamma (Set.Ioi 0)","decl":"/-- The **Bohr-Mollerup theorem**: the Gamma function is the *unique* log-convex, positive-valued\nfunction on the positive reals which satisfies `f 1 = 1` and `f (x + 1) = x * f x` for all `x`. -/\ntheorem eq_Gamma_of_log_convex {f : ℝ → ℝ} (hf_conv : ConvexOn ℝ (Ioi 0) (log ∘ f))\n    (hf_feq : ∀ {y : ℝ}, 0 < y → f (y + 1) = y * f y) (hf_pos : ∀ {y : ℝ}, 0 < y → 0 < f y)\n    (hf_one : f 1 = 1) : EqOn f Gamma (Ioi (0 : ℝ)) := by\n  suffices EqOn (log ∘ f) (log ∘ Gamma) (Ioi (0 : ℝ)) from\n    fun x hx ↦ log_injOn_pos (hf_pos hx) (Gamma_pos_of_pos hx) (this hx)\n  intro x hx\n  have e1 := BohrMollerup.tendsto_logGammaSeq hf_conv ?_ hx\n  · rw [Function.comp_apply (f := log) (g := f) (x := 1), hf_one, log_one, sub_zero] at e1\n    exact tendsto_nhds_unique e1 (BohrMollerup.tendsto_log_gamma hx)\n  · intro y hy\n    rw [Function.comp_apply, Function.comp_apply, hf_feq hy, log_mul hy.ne' (hf_pos hy).ne']\n    ring\n\n"}
{"name":"Real.Gamma_two","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"⊢ Eq (Real.Gamma 2) 1","decl":"theorem Gamma_two : Gamma 2 = 1 := by simp [Nat.factorial_one]\n\n"}
{"name":"Real.Gamma_three_div_two_lt_one","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"⊢ LT.lt (Real.Gamma (3 / 2)) 1","decl":"theorem Gamma_three_div_two_lt_one : Gamma (3 / 2) < 1 := by\n  -- This can also be proved using the closed-form evaluation of `Gamma (1 / 2)` in\n  -- `Mathlib/Analysis/SpecialFunctions/Gaussian.lean`, but we give a self-contained proof using\n  -- log-convexity to avoid unnecessary imports.\n  have A : (0 : ℝ) < 3 / 2 := by norm_num\n  have :=\n    BohrMollerup.f_add_nat_le convexOn_log_Gamma (fun {y} hy => ?_) two_ne_zero one_half_pos\n      (by norm_num : 1 / 2 ≤ (1 : ℝ))\n  swap\n  · rw [Function.comp_apply, Gamma_add_one hy.ne', log_mul hy.ne' (Gamma_pos_of_pos hy).ne',\n      add_comm, Function.comp_apply]\n  rw [Function.comp_apply, Function.comp_apply, Nat.cast_two, Gamma_two, log_one, zero_add,\n    (by norm_num : (2 : ℝ) + 1 / 2 = 3 / 2 + 1), Gamma_add_one A.ne',\n    log_mul A.ne' (Gamma_pos_of_pos A).ne', ← le_sub_iff_add_le',\n    log_le_iff_le_exp (Gamma_pos_of_pos A)] at this\n  refine this.trans_lt (exp_lt_one_iff.mpr ?_)\n  rw [mul_comm, ← mul_div_assoc, div_sub' _ _ (2 : ℝ) two_ne_zero]\n  refine div_neg_of_neg_of_pos ?_ two_pos\n  rw [sub_neg, mul_one, ← Nat.cast_two, ← log_pow, ← exp_lt_exp, Nat.cast_two, exp_log two_pos,\n      exp_log] <;>\n    norm_num\n\n"}
{"name":"Real.Gamma_strictMonoOn_Ici","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"⊢ StrictMonoOn Real.Gamma (Set.Ici 2)","decl":"theorem Gamma_strictMonoOn_Ici : StrictMonoOn Gamma (Ici 2) := by\n  convert\n    convexOn_Gamma.strict_mono_of_lt (by norm_num : (0 : ℝ) < 3 / 2)\n      (by norm_num : (3 / 2 : ℝ) < 2) (Gamma_two.symm ▸ Gamma_three_div_two_lt_one)\n  symm\n  rw [inter_eq_right]\n  exact fun x hx => two_pos.trans_le <| mem_Ici.mp hx\n\n"}
{"name":"Real.doublingGamma_add_one","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"s : Real\nhs : Ne s 0\n⊢ Eq (HAdd.hAdd s 1).doublingGamma (HMul.hMul s s.doublingGamma)","decl":"theorem doublingGamma_add_one (s : ℝ) (hs : s ≠ 0) :\n    doublingGamma (s + 1) = s * doublingGamma s := by\n  rw [doublingGamma, doublingGamma, (by abel : s + 1 - 1 = s - 1 + 1), add_div, add_assoc,\n    add_halves (1 : ℝ), Gamma_add_one (div_ne_zero hs two_ne_zero), rpow_add two_pos, rpow_one]\n  ring\n\n"}
{"name":"Real.doublingGamma_one","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"⊢ Eq (Real.doublingGamma 1) 1","decl":"theorem doublingGamma_one : doublingGamma 1 = 1 := by\n  simp_rw [doublingGamma, Gamma_one_half_eq, add_halves (1 : ℝ), sub_self, Gamma_one, mul_one,\n    rpow_zero, mul_one, div_self (sqrt_ne_zero'.mpr pi_pos)]\n\n"}
{"name":"Real.log_doublingGamma_eq","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"⊢ Set.EqOn (Function.comp Real.log Real.doublingGamma) (fun s => HSub.hSub (HAdd.hAdd (HAdd.hAdd (Real.log (Real.Gamma (HDiv.hDiv s 2))) (Real.log (Real.Gamma (HAdd.hAdd (HDiv.hDiv s 2) (1 / 2))))) (HMul.hMul s (Real.log 2))) (Real.log (HMul.hMul 2 Real.pi.sqrt))) (Set.Ioi 0)","decl":"theorem log_doublingGamma_eq :\n    EqOn (log ∘ doublingGamma)\n      (fun s => log (Gamma (s / 2)) + log (Gamma (s / 2 + 1 / 2)) + s * log 2 - log (2 * √π))\n      (Ioi 0) := by\n  intro s hs\n  have h1 : √π ≠ 0 := sqrt_ne_zero'.mpr pi_pos\n  have h2 : Gamma (s / 2) ≠ 0 := (Gamma_pos_of_pos <| div_pos hs two_pos).ne'\n  have h3 : Gamma (s / 2 + 1 / 2) ≠ 0 :=\n    (Gamma_pos_of_pos <| add_pos (div_pos hs two_pos) one_half_pos).ne'\n  have h4 : (2 : ℝ) ^ (s - 1) ≠ 0 := (rpow_pos_of_pos two_pos _).ne'\n  rw [Function.comp_apply, doublingGamma, log_div (mul_ne_zero (mul_ne_zero h2 h3) h4) h1,\n    log_mul (mul_ne_zero h2 h3) h4, log_mul h2 h3, log_rpow two_pos, log_mul two_ne_zero h1]\n  ring_nf\n\n"}
{"name":"Real.doublingGamma_log_convex_Ioi","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"⊢ ConvexOn Real (Set.Ioi 0) (Function.comp Real.log Real.doublingGamma)","decl":"theorem doublingGamma_log_convex_Ioi : ConvexOn ℝ (Ioi (0 : ℝ)) (log ∘ doublingGamma) := by\n  refine (((ConvexOn.add ?_ ?_).add ?_).add_const _).congr log_doublingGamma_eq.symm\n  · convert\n      convexOn_log_Gamma.comp_affineMap (DistribMulAction.toLinearMap ℝ ℝ (1 / 2 : ℝ)).toAffineMap\n      using 1\n    · simpa only [zero_div] using (preimage_const_mul_Ioi (0 : ℝ) one_half_pos).symm\n    · ext1 x\n      -- Porting note: was\n      -- change log (Gamma (x / 2)) = log (Gamma ((1 / 2 : ℝ) • x))\n      simp only [LinearMap.coe_toAffineMap, Function.comp_apply, DistribMulAction.toLinearMap_apply]\n      rw [smul_eq_mul, mul_comm, mul_one_div]\n  · refine ConvexOn.subset ?_ (Ioi_subset_Ioi <| neg_one_lt_zero.le) (convex_Ioi _)\n    convert\n      convexOn_log_Gamma.comp_affineMap\n        ((DistribMulAction.toLinearMap ℝ ℝ (1 / 2 : ℝ)).toAffineMap +\n          AffineMap.const ℝ ℝ (1 / 2 : ℝ)) using 1\n    · change Ioi (-1 : ℝ) = ((fun x : ℝ => x + 1 / 2) ∘ fun x : ℝ => (1 / 2 : ℝ) * x) ⁻¹' Ioi 0\n      rw [preimage_comp, preimage_add_const_Ioi, zero_sub,\n        preimage_const_mul_Ioi (_ : ℝ) one_half_pos, neg_div, div_self (@one_half_pos ℝ _).ne']\n    · ext1 x\n      change log (Gamma (x / 2 + 1 / 2)) = log (Gamma ((1 / 2 : ℝ) • x + 1 / 2))\n      rw [smul_eq_mul, mul_comm, mul_one_div]\n  · simpa only [mul_comm _ (log _)] using\n      (convexOn_id (convex_Ioi (0 : ℝ))).smul (log_pos one_lt_two).le\n\n"}
{"name":"Real.doublingGamma_eq_Gamma","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"s : Real\nhs : LT.lt 0 s\n⊢ Eq s.doublingGamma (Real.Gamma s)","decl":"theorem doublingGamma_eq_Gamma {s : ℝ} (hs : 0 < s) : doublingGamma s = Gamma s := by\n  refine\n    eq_Gamma_of_log_convex doublingGamma_log_convex_Ioi\n      (fun {y} hy => doublingGamma_add_one y hy.ne') (fun {y} hy => ?_) doublingGamma_one hs\n  apply_rules [mul_pos, Gamma_pos_of_pos, add_pos, inv_pos_of_pos, rpow_pos_of_pos, two_pos,\n    one_pos, sqrt_pos_of_pos pi_pos]\n\n"}
{"name":"Real.Gamma_mul_Gamma_add_half_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup","initialProofState":"s : Real\nhs : LT.lt 0 s\n⊢ Eq (HMul.hMul (Real.Gamma s) (Real.Gamma (HAdd.hAdd s (1 / 2)))) (HMul.hMul (HMul.hMul (Real.Gamma (HMul.hMul 2 s)) (HPow.hPow 2 (HSub.hSub 1 (HMul.hMul 2 s)))) Real.pi.sqrt)","decl":"/-- Legendre's doubling formula for the Gamma function, for positive real arguments. Note that\nwe shall later prove this for all `s` as `Real.Gamma_mul_Gamma_add_half` (superseding this result)\nbut this result is needed as an intermediate step. -/\ntheorem Gamma_mul_Gamma_add_half_of_pos {s : ℝ} (hs : 0 < s) :\n    Gamma s * Gamma (s + 1 / 2) = Gamma (2 * s) * 2 ^ (1 - 2 * s) * √π := by\n  rw [← doublingGamma_eq_Gamma (mul_pos two_pos hs), doublingGamma,\n    mul_div_cancel_left₀ _ (two_ne_zero' ℝ), (by abel : 1 - 2 * s = -(2 * s - 1)),\n    rpow_neg zero_le_two]\n  field_simp [(sqrt_pos_of_pos pi_pos).ne', (rpow_pos_of_pos two_pos (2 * s - 1)).ne']\n  ring\n\n"}
