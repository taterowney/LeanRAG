{"name":"SemiconjBy.units_inv_right","module":"Mathlib.Algebra.Group.Semiconj.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\nx y : Units M\nh : SemiconjBy a ↑x ↑y\n⊢ SemiconjBy a ↑(Inv.inv x) ↑(Inv.inv y)","decl":"/-- If `a` semiconjugates a unit `x` to a unit `y`, then it semiconjugates `x⁻¹` to `y⁻¹`. -/\n@[to_additive \"If `a` semiconjugates an additive unit `x` to an additive unit `y`, then it\nsemiconjugates `-x` to `-y`.\"]\ntheorem units_inv_right {a : M} {x y : Mˣ} (h : SemiconjBy a x y) : SemiconjBy a ↑x⁻¹ ↑y⁻¹ :=\n  calc\n    a * ↑x⁻¹ = ↑y⁻¹ * (y * a) * ↑x⁻¹ := by rw [Units.inv_mul_cancel_left]\n    _        = ↑y⁻¹ * a              := by rw [← h.eq, mul_assoc, Units.mul_inv_cancel_right]\n\n"}
{"name":"AddSemiconjBy.addUnits_neg_right","module":"Mathlib.Algebra.Group.Semiconj.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : M\nx y : AddUnits M\nh : AddSemiconjBy a ↑x ↑y\n⊢ AddSemiconjBy a ↑(Neg.neg x) ↑(Neg.neg y)","decl":"/-- If `a` semiconjugates a unit `x` to a unit `y`, then it semiconjugates `x⁻¹` to `y⁻¹`. -/\n@[to_additive \"If `a` semiconjugates an additive unit `x` to an additive unit `y`, then it\nsemiconjugates `-x` to `-y`.\"]\ntheorem units_inv_right {a : M} {x y : Mˣ} (h : SemiconjBy a x y) : SemiconjBy a ↑x⁻¹ ↑y⁻¹ :=\n  calc\n    a * ↑x⁻¹ = ↑y⁻¹ * (y * a) * ↑x⁻¹ := by rw [Units.inv_mul_cancel_left]\n    _        = ↑y⁻¹ * a              := by rw [← h.eq, mul_assoc, Units.mul_inv_cancel_right]\n\n"}
{"name":"SemiconjBy.units_inv_right_iff","module":"Mathlib.Algebra.Group.Semiconj.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\nx y : Units M\n⊢ Iff (SemiconjBy a ↑(Inv.inv x) ↑(Inv.inv y)) (SemiconjBy a ↑x ↑y)","decl":"@[to_additive (attr := simp)]\ntheorem units_inv_right_iff {a : M} {x y : Mˣ} : SemiconjBy a ↑x⁻¹ ↑y⁻¹ ↔ SemiconjBy a x y :=\n  ⟨units_inv_right, units_inv_right⟩\n\n"}
{"name":"AddSemiconjBy.addUnits_neg_right_iff","module":"Mathlib.Algebra.Group.Semiconj.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : M\nx y : AddUnits M\n⊢ Iff (AddSemiconjBy a ↑(Neg.neg x) ↑(Neg.neg y)) (AddSemiconjBy a ↑x ↑y)","decl":"@[to_additive (attr := simp)]\ntheorem units_inv_right_iff {a : M} {x y : Mˣ} : SemiconjBy a ↑x⁻¹ ↑y⁻¹ ↔ SemiconjBy a x y :=\n  ⟨units_inv_right, units_inv_right⟩\n\n"}
{"name":"AddSemiconjBy.addUnits_neg_symm_left","module":"Mathlib.Algebra.Group.Semiconj.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : AddUnits M\nx y : M\nh : AddSemiconjBy (↑a) x y\n⊢ AddSemiconjBy (↑(Neg.neg a)) y x","decl":"/-- If a unit `a` semiconjugates `x` to `y`, then `a⁻¹` semiconjugates `y` to `x`. -/\n@[to_additive \"If an additive unit `a` semiconjugates `x` to `y`, then `-a` semiconjugates `y` to\n`x`.\"]\ntheorem units_inv_symm_left {a : Mˣ} {x y : M} (h : SemiconjBy (↑a) x y) : SemiconjBy (↑a⁻¹) y x :=\n  calc\n    ↑a⁻¹ * y = ↑a⁻¹ * (y * a * ↑a⁻¹) := by rw [Units.mul_inv_cancel_right]\n    _ = x * ↑a⁻¹ := by rw [← h.eq, ← mul_assoc, Units.inv_mul_cancel_left]\n\n"}
{"name":"SemiconjBy.units_inv_symm_left","module":"Mathlib.Algebra.Group.Semiconj.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : Units M\nx y : M\nh : SemiconjBy (↑a) x y\n⊢ SemiconjBy (↑(Inv.inv a)) y x","decl":"/-- If a unit `a` semiconjugates `x` to `y`, then `a⁻¹` semiconjugates `y` to `x`. -/\n@[to_additive \"If an additive unit `a` semiconjugates `x` to `y`, then `-a` semiconjugates `y` to\n`x`.\"]\ntheorem units_inv_symm_left {a : Mˣ} {x y : M} (h : SemiconjBy (↑a) x y) : SemiconjBy (↑a⁻¹) y x :=\n  calc\n    ↑a⁻¹ * y = ↑a⁻¹ * (y * a * ↑a⁻¹) := by rw [Units.mul_inv_cancel_right]\n    _ = x * ↑a⁻¹ := by rw [← h.eq, ← mul_assoc, Units.inv_mul_cancel_left]\n\n"}
{"name":"SemiconjBy.units_inv_symm_left_iff","module":"Mathlib.Algebra.Group.Semiconj.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : Units M\nx y : M\n⊢ Iff (SemiconjBy (↑(Inv.inv a)) y x) (SemiconjBy (↑a) x y)","decl":"@[to_additive (attr := simp)]\ntheorem units_inv_symm_left_iff {a : Mˣ} {x y : M} : SemiconjBy (↑a⁻¹) y x ↔ SemiconjBy (↑a) x y :=\n  ⟨units_inv_symm_left, units_inv_symm_left⟩\n\n"}
{"name":"AddSemiconjBy.addUnits_neg_symm_left_iff","module":"Mathlib.Algebra.Group.Semiconj.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : AddUnits M\nx y : M\n⊢ Iff (AddSemiconjBy (↑(Neg.neg a)) y x) (AddSemiconjBy (↑a) x y)","decl":"@[to_additive (attr := simp)]\ntheorem units_inv_symm_left_iff {a : Mˣ} {x y : M} : SemiconjBy (↑a⁻¹) y x ↔ SemiconjBy (↑a) x y :=\n  ⟨units_inv_symm_left, units_inv_symm_left⟩\n\n"}
{"name":"AddSemiconjBy.addUnits_val","module":"Mathlib.Algebra.Group.Semiconj.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na x y : AddUnits M\nh : AddSemiconjBy a x y\n⊢ AddSemiconjBy ↑a ↑x ↑y","decl":"@[to_additive]\ntheorem units_val {a x y : Mˣ} (h : SemiconjBy a x y) : SemiconjBy (a : M) x y :=\n  congr_arg Units.val h\n\n"}
{"name":"SemiconjBy.units_val","module":"Mathlib.Algebra.Group.Semiconj.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na x y : Units M\nh : SemiconjBy a x y\n⊢ SemiconjBy ↑a ↑x ↑y","decl":"@[to_additive]\ntheorem units_val {a x y : Mˣ} (h : SemiconjBy a x y) : SemiconjBy (a : M) x y :=\n  congr_arg Units.val h\n\n"}
{"name":"SemiconjBy.units_of_val","module":"Mathlib.Algebra.Group.Semiconj.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na x y : Units M\nh : SemiconjBy ↑a ↑x ↑y\n⊢ SemiconjBy a x y","decl":"@[to_additive]\ntheorem units_of_val {a x y : Mˣ} (h : SemiconjBy (a : M) x y) : SemiconjBy a x y :=\n  Units.ext h\n\n"}
{"name":"AddSemiconjBy.addUnits_of_val","module":"Mathlib.Algebra.Group.Semiconj.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na x y : AddUnits M\nh : AddSemiconjBy ↑a ↑x ↑y\n⊢ AddSemiconjBy a x y","decl":"@[to_additive]\ntheorem units_of_val {a x y : Mˣ} (h : SemiconjBy (a : M) x y) : SemiconjBy a x y :=\n  Units.ext h\n\n"}
{"name":"SemiconjBy.units_val_iff","module":"Mathlib.Algebra.Group.Semiconj.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na x y : Units M\n⊢ Iff (SemiconjBy ↑a ↑x ↑y) (SemiconjBy a x y)","decl":"@[to_additive (attr := simp)]\ntheorem units_val_iff {a x y : Mˣ} : SemiconjBy (a : M) x y ↔ SemiconjBy a x y :=\n  ⟨units_of_val, units_val⟩\n\n"}
{"name":"AddSemiconjBy.addUnits_val_iff","module":"Mathlib.Algebra.Group.Semiconj.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na x y : AddUnits M\n⊢ Iff (AddSemiconjBy ↑a ↑x ↑y) (AddSemiconjBy a x y)","decl":"@[to_additive (attr := simp)]\ntheorem units_val_iff {a x y : Mˣ} : SemiconjBy (a : M) x y ↔ SemiconjBy a x y :=\n  ⟨units_of_val, units_val⟩\n\n"}
{"name":"SemiconjBy.units_zpow_right","module":"Mathlib.Algebra.Group.Semiconj.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\nx y : Units M\nh : SemiconjBy a ↑x ↑y\nm : Int\n⊢ SemiconjBy a ↑(HPow.hPow x m) ↑(HPow.hPow y m)","decl":"@[to_additive (attr := simp)]\nlemma units_zpow_right {a : M} {x y : Mˣ} (h : SemiconjBy a x y) :\n    ∀ m : ℤ, SemiconjBy a ↑(x ^ m) ↑(y ^ m)\n  | (n : ℕ) => by simp only [zpow_natCast, Units.val_pow_eq_pow_val, h, pow_right]\n  | -[n+1] => by simp only [zpow_negSucc, Units.val_pow_eq_pow_val, units_inv_right, h, pow_right]\n\n"}
{"name":"AddSemiconjBy.addUnits_zsmul_right","module":"Mathlib.Algebra.Group.Semiconj.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : M\nx y : AddUnits M\nh : AddSemiconjBy a ↑x ↑y\nm : Int\n⊢ AddSemiconjBy a ↑(HSMul.hSMul m x) ↑(HSMul.hSMul m y)","decl":"@[to_additive (attr := simp)]\nlemma units_zpow_right {a : M} {x y : Mˣ} (h : SemiconjBy a x y) :\n    ∀ m : ℤ, SemiconjBy a ↑(x ^ m) ↑(y ^ m)\n  | (n : ℕ) => by simp only [zpow_natCast, Units.val_pow_eq_pow_val, h, pow_right]\n  | -[n+1] => by simp only [zpow_negSucc, Units.val_pow_eq_pow_val, units_inv_right, h, pow_right]\n\n"}
{"name":"AddUnits.mk_addSemiconjBy","module":"Mathlib.Algebra.Group.Semiconj.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nu : AddUnits M\nx : M\n⊢ AddSemiconjBy (↑u) x (HAdd.hAdd (HAdd.hAdd (↑u) x) ↑(Neg.neg u))","decl":"/-- `a` semiconjugates `x` to `a * x * a⁻¹`. -/\n@[to_additive \"`a` semiconjugates `x` to `a + x + -a`.\"]\nlemma mk_semiconjBy (u : Mˣ) (x : M) : SemiconjBy (↑u) x (u * x * ↑u⁻¹) := by\n  unfold SemiconjBy; rw [Units.inv_mul_cancel_right]\n\n"}
{"name":"Units.mk_semiconjBy","module":"Mathlib.Algebra.Group.Semiconj.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nu : Units M\nx : M\n⊢ SemiconjBy (↑u) x (HMul.hMul (HMul.hMul (↑u) x) ↑(Inv.inv u))","decl":"/-- `a` semiconjugates `x` to `a * x * a⁻¹`. -/\n@[to_additive \"`a` semiconjugates `x` to `a + x + -a`.\"]\nlemma mk_semiconjBy (u : Mˣ) (x : M) : SemiconjBy (↑u) x (u * x * ↑u⁻¹) := by\n  unfold SemiconjBy; rw [Units.inv_mul_cancel_right]\n\n"}
{"name":"Units.conj_pow","module":"Mathlib.Algebra.Group.Semiconj.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nu : Units M\nx : M\nn : Nat\n⊢ Eq (HPow.hPow (HMul.hMul (HMul.hMul (↑u) x) ↑(Inv.inv u)) n) (HMul.hMul (HMul.hMul (↑u) (HPow.hPow x n)) ↑(Inv.inv u))","decl":"lemma conj_pow (u : Mˣ) (x : M) (n : ℕ) :\n    ((↑u : M) * x * (↑u⁻¹ : M)) ^ n = (u : M) * x ^ n * (↑u⁻¹ : M) :=\n  eq_divp_iff_mul_eq.2 ((u.mk_semiconjBy x).pow_right n).eq.symm\n\n"}
{"name":"Units.conj_pow'","module":"Mathlib.Algebra.Group.Semiconj.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nu : Units M\nx : M\nn : Nat\n⊢ Eq (HPow.hPow (HMul.hMul (HMul.hMul (↑(Inv.inv u)) x) ↑u) n) (HMul.hMul (HMul.hMul (↑(Inv.inv u)) (HPow.hPow x n)) ↑u)","decl":"lemma conj_pow' (u : Mˣ) (x : M) (n : ℕ) :\n    ((↑u⁻¹ : M) * x * (u : M)) ^ n = (↑u⁻¹ : M) * x ^ n * (u : M) := u⁻¹.conj_pow x n\n\n"}
