{"name":"Bornology.isVonNBounded_empty","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝³ : SeminormedRing 𝕜\ninst✝² : SMul 𝕜 E\ninst✝¹ : Zero E\ninst✝ : TopologicalSpace E\n⊢ Bornology.IsVonNBounded 𝕜 EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem isVonNBounded_empty : IsVonNBounded 𝕜 (∅ : Set E) := fun _ _ => Absorbs.empty\n\n"}
{"name":"Bornology.isVonNBounded_iff","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝³ : SeminormedRing 𝕜\ninst✝² : SMul 𝕜 E\ninst✝¹ : Zero E\ninst✝ : TopologicalSpace E\ns : Set E\n⊢ Iff (Bornology.IsVonNBounded 𝕜 s) (∀ (V : Set E), Membership.mem (nhds 0) V → Absorbs 𝕜 V s)","decl":"theorem isVonNBounded_iff (s : Set E) : IsVonNBounded 𝕜 s ↔ ∀ V ∈ 𝓝 (0 : E), Absorbs 𝕜 V s :=\n  Iff.rfl\n\n"}
{"name":"Filter.HasBasis.isVonNBounded_iff","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\nι : Type u_5\ninst✝³ : SeminormedRing 𝕜\ninst✝² : SMul 𝕜 E\ninst✝¹ : Zero E\ninst✝ : TopologicalSpace E\nq : ι → Prop\ns : ι → Set E\nA : Set E\nh : (nhds 0).HasBasis q s\n⊢ Iff (Bornology.IsVonNBounded 𝕜 A) (∀ (i : ι), q i → Absorbs 𝕜 (s i) A)","decl":"theorem _root_.Filter.HasBasis.isVonNBounded_iff {q : ι → Prop} {s : ι → Set E} {A : Set E}\n    (h : (𝓝 (0 : E)).HasBasis q s) : IsVonNBounded 𝕜 A ↔ ∀ i, q i → Absorbs 𝕜 (s i) A := by\n  refine ⟨fun hA i hi => hA (h.mem_of_mem hi), fun hA V hV => ?_⟩\n  rcases h.mem_iff.mp hV with ⟨i, hi, hV⟩\n  exact (hA i hi).mono_left hV\n\n"}
{"name":"Bornology.IsVonNBounded.subset","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝³ : SeminormedRing 𝕜\ninst✝² : SMul 𝕜 E\ninst✝¹ : Zero E\ninst✝ : TopologicalSpace E\ns₁ s₂ : Set E\nh : HasSubset.Subset s₁ s₂\nhs₂ : Bornology.IsVonNBounded 𝕜 s₂\n⊢ Bornology.IsVonNBounded 𝕜 s₁","decl":"/-- Subsets of bounded sets are bounded. -/\ntheorem IsVonNBounded.subset {s₁ s₂ : Set E} (h : s₁ ⊆ s₂) (hs₂ : IsVonNBounded 𝕜 s₂) :\n    IsVonNBounded 𝕜 s₁ := fun _ hV => (hs₂ hV).mono_right h\n\n"}
{"name":"Bornology.isVonNBounded_union","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝³ : SeminormedRing 𝕜\ninst✝² : SMul 𝕜 E\ninst✝¹ : Zero E\ninst✝ : TopologicalSpace E\ns t : Set E\n⊢ Iff (Bornology.IsVonNBounded 𝕜 (Union.union s t)) (And (Bornology.IsVonNBounded 𝕜 s) (Bornology.IsVonNBounded 𝕜 t))","decl":"@[simp]\ntheorem isVonNBounded_union {s t : Set E} :\n    IsVonNBounded 𝕜 (s ∪ t) ↔ IsVonNBounded 𝕜 s ∧ IsVonNBounded 𝕜 t := by\n  simp only [IsVonNBounded, absorbs_union, forall_and]\n\n"}
{"name":"Bornology.IsVonNBounded.union","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝³ : SeminormedRing 𝕜\ninst✝² : SMul 𝕜 E\ninst✝¹ : Zero E\ninst✝ : TopologicalSpace E\ns₁ s₂ : Set E\nhs₁ : Bornology.IsVonNBounded 𝕜 s₁\nhs₂ : Bornology.IsVonNBounded 𝕜 s₂\n⊢ Bornology.IsVonNBounded 𝕜 (Union.union s₁ s₂)","decl":"/-- The union of two bounded sets is bounded. -/\ntheorem IsVonNBounded.union {s₁ s₂ : Set E} (hs₁ : IsVonNBounded 𝕜 s₁) (hs₂ : IsVonNBounded 𝕜 s₂) :\n    IsVonNBounded 𝕜 (s₁ ∪ s₂) := isVonNBounded_union.2 ⟨hs₁, hs₂⟩\n\n"}
{"name":"Bornology.IsVonNBounded.of_boundedSpace","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁴ : SeminormedRing 𝕜\ninst✝³ : SMul 𝕜 E\ninst✝² : Zero E\ninst✝¹ : TopologicalSpace E\ninst✝ : BoundedSpace 𝕜\ns : Set E\n⊢ Bornology.IsVonNBounded 𝕜 s","decl":"@[nontriviality]\ntheorem IsVonNBounded.of_boundedSpace [BoundedSpace 𝕜] {s : Set E} : IsVonNBounded 𝕜 s := fun _ _ ↦\n  .of_boundedSpace\n\n"}
{"name":"Bornology.IsVonNBounded.of_subsingleton","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁴ : SeminormedRing 𝕜\ninst✝³ : SMul 𝕜 E\ninst✝² : Zero E\ninst✝¹ : TopologicalSpace E\ninst✝ : Subsingleton E\ns : Set E\n⊢ Bornology.IsVonNBounded 𝕜 s","decl":"@[nontriviality]\ntheorem IsVonNBounded.of_subsingleton [Subsingleton E] {s : Set E} : IsVonNBounded 𝕜 s :=\n  fun U hU ↦ .of_forall fun c ↦ calc\n    s ⊆ univ := subset_univ s\n    _ = c • U := .symm <| Subsingleton.eq_univ_of_nonempty <| (Filter.nonempty_of_mem hU).image _\n\n"}
{"name":"Bornology.isVonNBounded_iUnion","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁴ : SeminormedRing 𝕜\ninst✝³ : SMul 𝕜 E\ninst✝² : Zero E\ninst✝¹ : TopologicalSpace E\nι : Sort u_6\ninst✝ : Finite ι\ns : ι → Set E\n⊢ Iff (Bornology.IsVonNBounded 𝕜 (Set.iUnion fun i => s i)) (∀ (i : ι), Bornology.IsVonNBounded 𝕜 (s i))","decl":"@[simp]\ntheorem isVonNBounded_iUnion {ι : Sort*} [Finite ι] {s : ι → Set E} :\n    IsVonNBounded 𝕜 (⋃ i, s i) ↔ ∀ i, IsVonNBounded 𝕜 (s i) := by\n  simp only [IsVonNBounded, absorbs_iUnion, @forall_swap ι]\n\n"}
{"name":"Bornology.isVonNBounded_biUnion","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝³ : SeminormedRing 𝕜\ninst✝² : SMul 𝕜 E\ninst✝¹ : Zero E\ninst✝ : TopologicalSpace E\nι : Type u_6\nI : Set ι\nhI : I.Finite\ns : ι → Set E\n⊢ Iff (Bornology.IsVonNBounded 𝕜 (Set.iUnion fun i => Set.iUnion fun h => s i)) (∀ (i : ι), Membership.mem I i → Bornology.IsVonNBounded 𝕜 (s i))","decl":"theorem isVonNBounded_biUnion {ι : Type*} {I : Set ι} (hI : I.Finite) {s : ι → Set E} :\n    IsVonNBounded 𝕜 (⋃ i ∈ I, s i) ↔ ∀ i ∈ I, IsVonNBounded 𝕜 (s i) := by\n  have _ := hI.to_subtype\n  rw [biUnion_eq_iUnion, isVonNBounded_iUnion, Subtype.forall]\n\n"}
{"name":"Bornology.isVonNBounded_sUnion","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝³ : SeminormedRing 𝕜\ninst✝² : SMul 𝕜 E\ninst✝¹ : Zero E\ninst✝ : TopologicalSpace E\nS : Set (Set E)\nhS : S.Finite\n⊢ Iff (Bornology.IsVonNBounded 𝕜 S.sUnion) (∀ (s : Set E), Membership.mem S s → Bornology.IsVonNBounded 𝕜 s)","decl":"theorem isVonNBounded_sUnion {S : Set (Set E)} (hS : S.Finite) :\n    IsVonNBounded 𝕜 (⋃₀ S) ↔ ∀ s ∈ S, IsVonNBounded 𝕜 s := by\n  rw [sUnion_eq_biUnion, isVonNBounded_biUnion hS]\n\n"}
{"name":"Bornology.IsVonNBounded.add","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁴ : SeminormedRing 𝕜\ninst✝³ : AddZeroClass E\ninst✝² : TopologicalSpace E\ninst✝¹ : ContinuousAdd E\ninst✝ : DistribSMul 𝕜 E\ns t : Set E\nhs : Bornology.IsVonNBounded 𝕜 s\nht : Bornology.IsVonNBounded 𝕜 t\n⊢ Bornology.IsVonNBounded 𝕜 (HAdd.hAdd s t)","decl":"protected theorem IsVonNBounded.add (hs : IsVonNBounded 𝕜 s) (ht : IsVonNBounded 𝕜 t) :\n    IsVonNBounded 𝕜 (s + t) := fun U hU ↦ by\n  rcases exists_open_nhds_zero_add_subset hU with ⟨V, hVo, hV, hVU⟩\n  exact ((hs <| hVo.mem_nhds hV).add (ht <| hVo.mem_nhds hV)).mono_left hVU\n\n"}
{"name":"Bornology.IsVonNBounded.neg","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁴ : SeminormedRing 𝕜\ninst✝³ : AddGroup E\ninst✝² : TopologicalSpace E\ninst✝¹ : TopologicalAddGroup E\ninst✝ : DistribMulAction 𝕜 E\ns : Set E\nhs : Bornology.IsVonNBounded 𝕜 s\n⊢ Bornology.IsVonNBounded 𝕜 (Neg.neg s)","decl":"protected theorem IsVonNBounded.neg (hs : IsVonNBounded 𝕜 s) : IsVonNBounded 𝕜 (-s) := fun U hU ↦ by\n  rw [← neg_neg U]\n  exact (hs <| neg_mem_nhds_zero _ hU).neg_neg\n\n"}
{"name":"Bornology.isVonNBounded_neg","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁴ : SeminormedRing 𝕜\ninst✝³ : AddGroup E\ninst✝² : TopologicalSpace E\ninst✝¹ : TopologicalAddGroup E\ninst✝ : DistribMulAction 𝕜 E\ns : Set E\n⊢ Iff (Bornology.IsVonNBounded 𝕜 (Neg.neg s)) (Bornology.IsVonNBounded 𝕜 s)","decl":"@[simp]\ntheorem isVonNBounded_neg : IsVonNBounded 𝕜 (-s) ↔ IsVonNBounded 𝕜 s :=\n  ⟨fun h ↦ neg_neg s ▸ h.neg, fun h ↦ h.neg⟩\n\n"}
{"name":"Bornology.IsVonNBounded.of_neg","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁴ : SeminormedRing 𝕜\ninst✝³ : AddGroup E\ninst✝² : TopologicalSpace E\ninst✝¹ : TopologicalAddGroup E\ninst✝ : DistribMulAction 𝕜 E\ns : Set E\na✝ : Bornology.IsVonNBounded 𝕜 (Neg.neg s)\n⊢ Bornology.IsVonNBounded 𝕜 s","decl":"alias ⟨IsVonNBounded.of_neg, _⟩ := isVonNBounded_neg\n\n"}
{"name":"Bornology.IsVonNBounded.sub","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁴ : SeminormedRing 𝕜\ninst✝³ : AddGroup E\ninst✝² : TopologicalSpace E\ninst✝¹ : TopologicalAddGroup E\ninst✝ : DistribMulAction 𝕜 E\ns t : Set E\nhs : Bornology.IsVonNBounded 𝕜 s\nht : Bornology.IsVonNBounded 𝕜 t\n⊢ Bornology.IsVonNBounded 𝕜 (HSub.hSub s t)","decl":"protected theorem IsVonNBounded.sub (hs : IsVonNBounded 𝕜 s) (ht : IsVonNBounded 𝕜 t) :\n    IsVonNBounded 𝕜 (s - t) := by\n  rw [sub_eq_add_neg]\n  exact hs.add ht.neg\n\n"}
{"name":"Bornology.IsVonNBounded.of_topologicalSpace_le","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nt t' : TopologicalSpace E\nh : LE.le t t'\ns : Set E\nhs : Bornology.IsVonNBounded 𝕜 s\n⊢ Bornology.IsVonNBounded 𝕜 s","decl":"/-- If a topology `t'` is coarser than `t`, then any set `s` that is bounded with respect to\n`t` is bounded with respect to `t'`. -/\ntheorem IsVonNBounded.of_topologicalSpace_le {t t' : TopologicalSpace E} (h : t ≤ t') {s : Set E}\n    (hs : @IsVonNBounded 𝕜 E _ _ _ t s) : @IsVonNBounded 𝕜 E _ _ _ t' s := fun _ hV =>\n  hs <| (le_iff_nhds t t').mp h 0 hV\n\n"}
{"name":"Bornology.isVonNBounded_iff_tendsto_smallSets_nhds","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_6\nE : Type u_7\ninst✝³ : NormedDivisionRing 𝕜\ninst✝² : AddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : TopologicalSpace E\nS : Set E\n⊢ Iff (Bornology.IsVonNBounded 𝕜 S) (Filter.Tendsto (fun x => HSMul.hSMul x S) (nhds 0) (nhds 0).smallSets)","decl":"lemma isVonNBounded_iff_tendsto_smallSets_nhds {𝕜 E : Type*} [NormedDivisionRing 𝕜]\n    [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] {S : Set E} :\n    IsVonNBounded 𝕜 S ↔ Tendsto (· • S : 𝕜 → Set E) (𝓝 0) (𝓝 0).smallSets := by\n  rw [tendsto_smallSets_iff]\n  refine forall₂_congr fun V hV ↦ ?_\n  simp only [absorbs_iff_eventually_nhds_zero (mem_of_mem_nhds hV), mapsTo', image_smul]\n\n"}
{"name":"Bornology.IsVonNBounded.tendsto_smallSets_nhds","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_6\nE : Type u_7\ninst✝³ : NormedDivisionRing 𝕜\ninst✝² : AddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : TopologicalSpace E\nS : Set E\na✝ : Bornology.IsVonNBounded 𝕜 S\n⊢ Filter.Tendsto (fun x => HSMul.hSMul x S) (nhds 0) (nhds 0).smallSets","decl":"alias ⟨IsVonNBounded.tendsto_smallSets_nhds, _⟩ := isVonNBounded_iff_tendsto_smallSets_nhds\n\n"}
{"name":"Bornology.isVonNBounded_iff_absorbing_le","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_6\nE : Type u_7\ninst✝³ : NormedDivisionRing 𝕜\ninst✝² : AddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : TopologicalSpace E\nS : Set E\n⊢ Iff (Bornology.IsVonNBounded 𝕜 S) (LE.le (Filter.absorbing 𝕜 S) (nhds 0))","decl":"lemma isVonNBounded_iff_absorbing_le {𝕜 E : Type*} [NormedDivisionRing 𝕜]\n    [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] {S : Set E} :\n    IsVonNBounded 𝕜 S ↔ Filter.absorbing 𝕜 S ≤ 𝓝 0 :=\n  .rfl\n\n"}
{"name":"Bornology.isVonNBounded_pi_iff","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_6\nι : Type u_7\nE : ι → Type u_8\ninst✝³ : NormedDivisionRing 𝕜\ninst✝² : (i : ι) → AddCommGroup (E i)\ninst✝¹ : (i : ι) → Module 𝕜 (E i)\ninst✝ : (i : ι) → TopologicalSpace (E i)\nS : Set ((i : ι) → E i)\n⊢ Iff (Bornology.IsVonNBounded 𝕜 S) (∀ (i : ι), Bornology.IsVonNBounded 𝕜 (Set.image (Function.eval i) S))","decl":"lemma isVonNBounded_pi_iff {𝕜 ι : Type*} {E : ι → Type*} [NormedDivisionRing 𝕜]\n    [∀ i, AddCommGroup (E i)] [∀ i, Module 𝕜 (E i)] [∀ i, TopologicalSpace (E i)]\n    {S : Set (∀ i, E i)} : IsVonNBounded 𝕜 S ↔ ∀ i, IsVonNBounded 𝕜 (eval i '' S) := by\n  simp_rw [isVonNBounded_iff_tendsto_smallSets_nhds, nhds_pi, Filter.pi, smallSets_iInf,\n    smallSets_comap_eq_comap_image, tendsto_iInf, tendsto_comap_iff, Function.comp_def,\n    ← image_smul, image_image, eval, Pi.smul_apply, Pi.zero_apply]\n\n"}
{"name":"Bornology.IsVonNBounded.image","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"E : Type u_3\nF : Type u_4\n𝕜₁ : Type u_6\n𝕜₂ : Type u_7\ninst✝⁹ : NormedDivisionRing 𝕜₁\ninst✝⁸ : NormedDivisionRing 𝕜₂\ninst✝⁷ : AddCommGroup E\ninst✝⁶ : Module 𝕜₁ E\ninst✝⁵ : AddCommGroup F\ninst✝⁴ : Module 𝕜₂ F\ninst✝³ : TopologicalSpace E\ninst✝² : TopologicalSpace F\nσ : RingHom 𝕜₁ 𝕜₂\ninst✝¹ : RingHomSurjective σ\ninst✝ : RingHomIsometric σ\ns : Set E\nhs : Bornology.IsVonNBounded 𝕜₁ s\nf : ContinuousLinearMap σ E F\n⊢ Bornology.IsVonNBounded 𝕜₂ (Set.image (⇑f) s)","decl":"/-- A continuous linear image of a bounded set is bounded. -/\ntheorem IsVonNBounded.image {σ : 𝕜₁ →+* 𝕜₂} [RingHomSurjective σ] [RingHomIsometric σ] {s : Set E}\n    (hs : IsVonNBounded 𝕜₁ s) (f : E →SL[σ] F) : IsVonNBounded 𝕜₂ (f '' s) := by\n  have σ_iso : Isometry σ := AddMonoidHomClass.isometry_of_norm σ fun x => RingHomIsometric.is_iso\n  have : map σ (𝓝 0) = 𝓝 0 := by\n    rw [σ_iso.isEmbedding.map_nhds_eq, σ.surjective.range_eq, nhdsWithin_univ, map_zero]\n  have hf₀ : Tendsto f (𝓝 0) (𝓝 0) := f.continuous.tendsto' 0 0 (map_zero f)\n  simp only [isVonNBounded_iff_tendsto_smallSets_nhds, ← this, tendsto_map'_iff] at hs ⊢\n  simpa only [comp_def, image_smul_setₛₗ _ _ σ f] using hf₀.image_smallSets.comp hs\n\n"}
{"name":"Bornology.IsVonNBounded.smul_tendsto_zero","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\nι : Type u_5\ninst✝³ : NormedField 𝕜\ninst✝² : AddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : TopologicalSpace E\nS : Set E\nε : ι → 𝕜\nx : ι → E\nl : Filter ι\nhS : Bornology.IsVonNBounded 𝕜 S\nhxS : Filter.Eventually (fun n => Membership.mem S (x n)) l\nhε : Filter.Tendsto ε l (nhds 0)\n⊢ Filter.Tendsto (HSMul.hSMul ε x) l (nhds 0)","decl":"theorem IsVonNBounded.smul_tendsto_zero [NormedField 𝕜]\n    [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E]\n    {S : Set E} {ε : ι → 𝕜} {x : ι → E} {l : Filter ι}\n    (hS : IsVonNBounded 𝕜 S) (hxS : ∀ᶠ n in l, x n ∈ S) (hε : Tendsto ε l (𝓝 0)) :\n    Tendsto (ε • x) l (𝓝 0) :=\n  (hS.tendsto_smallSets_nhds.comp hε).of_smallSets <| hxS.mono fun _ ↦ smul_mem_smul_set\n\n"}
{"name":"Bornology.isVonNBounded_of_smul_tendsto_zero","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\nι : Type u_5\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : TopologicalSpace E\ninst✝¹ : ContinuousSMul 𝕜 E\nε : ι → 𝕜\nl : Filter ι\ninst✝ : l.NeBot\nhε : Filter.Eventually (fun n => Ne (ε n) 0) l\nS : Set E\nH : ∀ (x : ι → E), (∀ (n : ι), Membership.mem S (x n)) → Filter.Tendsto (HSMul.hSMul ε x) l (nhds 0)\n⊢ Bornology.IsVonNBounded 𝕜 S","decl":"theorem isVonNBounded_of_smul_tendsto_zero {ε : ι → 𝕜} {l : Filter ι} [l.NeBot]\n    (hε : ∀ᶠ n in l, ε n ≠ 0) {S : Set E}\n    (H : ∀ x : ι → E, (∀ n, x n ∈ S) → Tendsto (ε • x) l (𝓝 0)) : IsVonNBounded 𝕜 S := by\n  rw [(nhds_basis_balanced 𝕜 E).isVonNBounded_iff]\n  by_contra! H'\n  rcases H' with ⟨V, ⟨hV, hVb⟩, hVS⟩\n  have : ∀ᶠ n in l, ∃ x : S, ε n • (x : E) ∉ V := by\n    filter_upwards [hε] with n hn\n    rw [absorbs_iff_norm] at hVS\n    push_neg at hVS\n    rcases hVS ‖(ε n)⁻¹‖ with ⟨a, haε, haS⟩\n    rcases Set.not_subset.mp haS with ⟨x, hxS, hx⟩\n    refine ⟨⟨x, hxS⟩, fun hnx => ?_⟩\n    rw [← Set.mem_inv_smul_set_iff₀ hn] at hnx\n    exact hx (hVb.smul_mono haε hnx)\n  rcases this.choice with ⟨x, hx⟩\n  refine Filter.frequently_false l (Filter.Eventually.frequently ?_)\n  filter_upwards [hx,\n    (H (_ ∘ x) fun n => (x n).2).eventually (eventually_mem_set.mpr hV)] using fun n => id\n\n"}
{"name":"Bornology.isVonNBounded_iff_smul_tendsto_zero","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\nι : Type u_5\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : TopologicalSpace E\ninst✝¹ : ContinuousSMul 𝕜 E\nε : ι → 𝕜\nl : Filter ι\ninst✝ : l.NeBot\nhε : Filter.Tendsto ε l (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0)))\nS : Set E\n⊢ Iff (Bornology.IsVonNBounded 𝕜 S) (∀ (x : ι → E), (∀ (n : ι), Membership.mem S (x n)) → Filter.Tendsto (HSMul.hSMul ε x) l (nhds 0))","decl":"/-- Given any sequence `ε` of scalars which tends to `𝓝[≠] 0`, we have that a set `S` is bounded\n  if and only if for any sequence `x : ℕ → S`, `ε • x` tends to 0. This actually works for any\n  indexing type `ι`, but in the special case `ι = ℕ` we get the important fact that convergent\n  sequences fully characterize bounded sets. -/\ntheorem isVonNBounded_iff_smul_tendsto_zero {ε : ι → 𝕜} {l : Filter ι} [l.NeBot]\n    (hε : Tendsto ε l (𝓝[≠] 0)) {S : Set E} :\n    IsVonNBounded 𝕜 S ↔ ∀ x : ι → E, (∀ n, x n ∈ S) → Tendsto (ε • x) l (𝓝 0) :=\n  ⟨fun hS _ hxS => hS.smul_tendsto_zero (Eventually.of_forall hxS) (le_trans hε nhdsWithin_le_nhds),\n    isVonNBounded_of_smul_tendsto_zero (by exact hε self_mem_nhdsWithin)⟩\n\n"}
{"name":"Bornology.IsVonNBounded.extend_scalars","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_6\ninst✝⁷ : AddCommGroup E\ninst✝⁶ : Module 𝕜 E\n𝕝 : Type u_7\ninst✝⁵ : NontriviallyNormedField 𝕝\ninst✝⁴ : NormedAlgebra 𝕜 𝕝\ninst✝³ : Module 𝕝 E\ninst✝² : TopologicalSpace E\ninst✝¹ : ContinuousSMul 𝕝 E\ninst✝ : IsScalarTower 𝕜 𝕝 E\ns : Set E\nh : Bornology.IsVonNBounded 𝕜 s\n⊢ Bornology.IsVonNBounded 𝕝 s","decl":"/-- If a set is von Neumann bounded with respect to a smaller field,\nthen it is also von Neumann bounded with respect to a larger field.\nSee also `Bornology.IsVonNBounded.restrict_scalars` below. -/\ntheorem IsVonNBounded.extend_scalars [NontriviallyNormedField 𝕜]\n    {E : Type*} [AddCommGroup E] [Module 𝕜 E]\n    (𝕝 : Type*) [NontriviallyNormedField 𝕝] [NormedAlgebra 𝕜 𝕝]\n    [Module 𝕝 E] [TopologicalSpace E] [ContinuousSMul 𝕝 E] [IsScalarTower 𝕜 𝕝 E]\n    {s : Set E} (h : IsVonNBounded 𝕜 s) : IsVonNBounded 𝕝 s := by\n  obtain ⟨ε, hε, hε₀⟩ : ∃ ε : ℕ → 𝕜, Tendsto ε atTop (𝓝 0) ∧ ∀ᶠ n in atTop, ε n ≠ 0 := by\n    simpa only [tendsto_nhdsWithin_iff] using exists_seq_tendsto (𝓝[≠] (0 : 𝕜))\n  refine isVonNBounded_of_smul_tendsto_zero (ε := (ε · • 1)) (by simpa) fun x hx ↦ ?_\n  have := h.smul_tendsto_zero (.of_forall hx) hε\n  simpa only [Pi.smul_def', smul_one_smul]\n\n"}
{"name":"Bornology.isVonNBounded_singleton","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁴ : NormedField 𝕜\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕜 E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousSMul 𝕜 E\nx : E\n⊢ Bornology.IsVonNBounded 𝕜 (Singleton.singleton x)","decl":"/-- Singletons are bounded. -/\ntheorem isVonNBounded_singleton (x : E) : IsVonNBounded 𝕜 ({x} : Set E) := fun _ hV =>\n  (absorbent_nhds_zero hV).absorbs\n\n"}
{"name":"Bornology.isVonNBounded_insert","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁴ : NormedField 𝕜\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕜 E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousSMul 𝕜 E\nx : E\ns : Set E\n⊢ Iff (Bornology.IsVonNBounded 𝕜 (Insert.insert x s)) (Bornology.IsVonNBounded 𝕜 s)","decl":"@[simp]\ntheorem isVonNBounded_insert (x : E) {s : Set E} :\n    IsVonNBounded 𝕜 (insert x s) ↔ IsVonNBounded 𝕜 s := by\n  simp only [← singleton_union, isVonNBounded_union, isVonNBounded_singleton, true_and]\n\n"}
{"name":"Bornology.IsVonNBounded.insert","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁴ : NormedField 𝕜\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕜 E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousSMul 𝕜 E\nx : E\ns : Set E\na✝ : Bornology.IsVonNBounded 𝕜 s\n⊢ Bornology.IsVonNBounded 𝕜 (Insert.insert x s)","decl":"protected alias ⟨_, IsVonNBounded.insert⟩ := isVonNBounded_insert\n\n"}
{"name":"Bornology.IsVonNBounded.vadd","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁵ : NormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : TopologicalSpace E\ninst✝¹ : ContinuousSMul 𝕜 E\ninst✝ : ContinuousAdd E\ns : Set E\nhs : Bornology.IsVonNBounded 𝕜 s\nx : E\n⊢ Bornology.IsVonNBounded 𝕜 (HVAdd.hVAdd x s)","decl":"protected theorem IsVonNBounded.vadd (hs : IsVonNBounded 𝕜 s) (x : E) :\n    IsVonNBounded 𝕜 (x +ᵥ s) := by\n  rw [← singleton_vadd]\n  -- TODO: dot notation timeouts in the next line\n  exact IsVonNBounded.add (isVonNBounded_singleton x) hs\n\n"}
{"name":"Bornology.isVonNBounded_vadd","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁵ : NormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : TopologicalSpace E\ninst✝¹ : ContinuousSMul 𝕜 E\ninst✝ : ContinuousAdd E\ns : Set E\nx : E\n⊢ Iff (Bornology.IsVonNBounded 𝕜 (HVAdd.hVAdd x s)) (Bornology.IsVonNBounded 𝕜 s)","decl":"@[simp]\ntheorem isVonNBounded_vadd (x : E) : IsVonNBounded 𝕜 (x +ᵥ s) ↔ IsVonNBounded 𝕜 s :=\n  ⟨fun h ↦ by simpa using h.vadd (-x), fun h ↦ h.vadd x⟩\n\n"}
{"name":"Bornology.IsVonNBounded.of_add_right","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁵ : NormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : TopologicalSpace E\ninst✝¹ : ContinuousSMul 𝕜 E\ninst✝ : ContinuousAdd E\ns t : Set E\nhst : Bornology.IsVonNBounded 𝕜 (HAdd.hAdd s t)\nhs : s.Nonempty\n⊢ Bornology.IsVonNBounded 𝕜 t","decl":"theorem IsVonNBounded.of_add_right (hst : IsVonNBounded 𝕜 (s + t)) (hs : s.Nonempty) :\n    IsVonNBounded 𝕜 t :=\n  let ⟨x, hx⟩ := hs\n  (isVonNBounded_vadd x).mp <| hst.subset <| image_subset_image2_right hx\n\n"}
{"name":"Bornology.IsVonNBounded.of_add_left","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁵ : NormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : TopologicalSpace E\ninst✝¹ : ContinuousSMul 𝕜 E\ninst✝ : ContinuousAdd E\ns t : Set E\nhst : Bornology.IsVonNBounded 𝕜 (HAdd.hAdd s t)\nht : t.Nonempty\n⊢ Bornology.IsVonNBounded 𝕜 s","decl":"theorem IsVonNBounded.of_add_left (hst : IsVonNBounded 𝕜 (s + t)) (ht : t.Nonempty) :\n    IsVonNBounded 𝕜 s :=\n  ((add_comm s t).subst hst).of_add_right ht\n\n"}
{"name":"Bornology.isVonNBounded_add_of_nonempty","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁵ : NormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : TopologicalSpace E\ninst✝¹ : ContinuousSMul 𝕜 E\ninst✝ : ContinuousAdd E\ns t : Set E\nhs : s.Nonempty\nht : t.Nonempty\n⊢ Iff (Bornology.IsVonNBounded 𝕜 (HAdd.hAdd s t)) (And (Bornology.IsVonNBounded 𝕜 s) (Bornology.IsVonNBounded 𝕜 t))","decl":"theorem isVonNBounded_add_of_nonempty (hs : s.Nonempty) (ht : t.Nonempty) :\n    IsVonNBounded 𝕜 (s + t) ↔ IsVonNBounded 𝕜 s ∧ IsVonNBounded 𝕜 t :=\n  ⟨fun h ↦ ⟨h.of_add_left ht, h.of_add_right hs⟩, and_imp.2 IsVonNBounded.add⟩\n\n"}
{"name":"Bornology.isVonNBounded_add","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁵ : NormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : TopologicalSpace E\ninst✝¹ : ContinuousSMul 𝕜 E\ninst✝ : ContinuousAdd E\ns t : Set E\n⊢ Iff (Bornology.IsVonNBounded 𝕜 (HAdd.hAdd s t)) (Or (Eq s EmptyCollection.emptyCollection) (Or (Eq t EmptyCollection.emptyCollection) (And (Bornology.IsVonNBounded 𝕜 s) (Bornology.IsVonNBounded 𝕜 t))))","decl":"theorem isVonNBounded_add :\n    IsVonNBounded 𝕜 (s + t) ↔ s = ∅ ∨ t = ∅ ∨ IsVonNBounded 𝕜 s ∧ IsVonNBounded 𝕜 t := by\n  rcases s.eq_empty_or_nonempty with rfl | hs; · simp\n  rcases t.eq_empty_or_nonempty with rfl | ht; · simp\n  simp [hs.ne_empty, ht.ne_empty, isVonNBounded_add_of_nonempty hs ht]\n\n"}
{"name":"Bornology.isVonNBounded_add_self","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁵ : NormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : TopologicalSpace E\ninst✝¹ : ContinuousSMul 𝕜 E\ninst✝ : ContinuousAdd E\ns : Set E\n⊢ Iff (Bornology.IsVonNBounded 𝕜 (HAdd.hAdd s s)) (Bornology.IsVonNBounded 𝕜 s)","decl":"@[simp]\ntheorem isVonNBounded_add_self : IsVonNBounded 𝕜 (s + s) ↔ IsVonNBounded 𝕜 s := by\n  rcases s.eq_empty_or_nonempty with rfl | hs <;> simp [isVonNBounded_add_of_nonempty, *]\n\n"}
{"name":"Bornology.IsVonNBounded.of_sub_left","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁵ : NormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : TopologicalSpace E\ninst✝¹ : ContinuousSMul 𝕜 E\ninst✝ : ContinuousAdd E\ns t : Set E\nhst : Bornology.IsVonNBounded 𝕜 (HSub.hSub s t)\nht : t.Nonempty\n⊢ Bornology.IsVonNBounded 𝕜 s","decl":"theorem IsVonNBounded.of_sub_left (hst : IsVonNBounded 𝕜 (s - t)) (ht : t.Nonempty) :\n    IsVonNBounded 𝕜 s :=\n  ((sub_eq_add_neg s t).subst hst).of_add_left ht.neg\n\n"}
{"name":"Bornology.IsVonNBounded.of_sub_right","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁵ : NormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : TopologicalSpace E\ninst✝¹ : ContinuousSMul 𝕜 E\ninst✝ : TopologicalAddGroup E\ns t : Set E\nhst : Bornology.IsVonNBounded 𝕜 (HSub.hSub s t)\nhs : s.Nonempty\n⊢ Bornology.IsVonNBounded 𝕜 t","decl":"theorem IsVonNBounded.of_sub_right (hst : IsVonNBounded 𝕜 (s - t)) (hs : s.Nonempty) :\n    IsVonNBounded 𝕜 t :=\n  (((sub_eq_add_neg s t).subst hst).of_add_right hs).of_neg\n\n"}
{"name":"Bornology.isVonNBounded_sub_of_nonempty","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁵ : NormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : TopologicalSpace E\ninst✝¹ : ContinuousSMul 𝕜 E\ninst✝ : TopologicalAddGroup E\ns t : Set E\nhs : s.Nonempty\nht : t.Nonempty\n⊢ Iff (Bornology.IsVonNBounded 𝕜 (HSub.hSub s t)) (And (Bornology.IsVonNBounded 𝕜 s) (Bornology.IsVonNBounded 𝕜 t))","decl":"theorem isVonNBounded_sub_of_nonempty (hs : s.Nonempty) (ht : t.Nonempty) :\n    IsVonNBounded 𝕜 (s - t) ↔ IsVonNBounded 𝕜 s ∧ IsVonNBounded 𝕜 t := by\n  simp [sub_eq_add_neg, isVonNBounded_add_of_nonempty, hs, ht]\n\n"}
{"name":"Bornology.isVonNBounded_sub","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁵ : NormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : TopologicalSpace E\ninst✝¹ : ContinuousSMul 𝕜 E\ninst✝ : TopologicalAddGroup E\ns t : Set E\n⊢ Iff (Bornology.IsVonNBounded 𝕜 (HSub.hSub s t)) (Or (Eq s EmptyCollection.emptyCollection) (Or (Eq t EmptyCollection.emptyCollection) (And (Bornology.IsVonNBounded 𝕜 s) (Bornology.IsVonNBounded 𝕜 t))))","decl":"theorem isVonNBounded_sub :\n    IsVonNBounded 𝕜 (s - t) ↔ s = ∅ ∨ t = ∅ ∨ IsVonNBounded 𝕜 s ∧ IsVonNBounded 𝕜 t := by\n  simp [sub_eq_add_neg, isVonNBounded_add]\n\n"}
{"name":"Bornology.isVonNBounded_covers","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁴ : NormedField 𝕜\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕜 E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousSMul 𝕜 E\n⊢ Eq (setOf (Bornology.IsVonNBounded 𝕜)).sUnion Set.univ","decl":"/-- The union of all bounded set is the whole space. -/\ntheorem isVonNBounded_covers : ⋃₀ setOf (IsVonNBounded 𝕜) = (Set.univ : Set E) :=\n  Set.eq_univ_iff_forall.mpr fun x =>\n    Set.mem_sUnion.mpr ⟨{x}, isVonNBounded_singleton _, Set.mem_singleton _⟩\n\n"}
{"name":"Bornology.isBounded_iff_isVonNBounded","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁴ : NormedField 𝕜\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕜 E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousSMul 𝕜 E\ns : Set E\n⊢ Iff (Bornology.IsBounded s) (Bornology.IsVonNBounded 𝕜 s)","decl":"@[simp]\ntheorem isBounded_iff_isVonNBounded {s : Set E} :\n    @IsBounded _ (vonNBornology 𝕜 E) s ↔ IsVonNBounded 𝕜 s :=\n  isBounded_ofBounded_iff _\n\n"}
{"name":"TotallyBounded.isVonNBounded","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁵ : NormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : UniformSpace E\ninst✝¹ : UniformAddGroup E\ninst✝ : ContinuousSMul 𝕜 E\ns : Set E\nhs : TotallyBounded s\n⊢ Bornology.IsVonNBounded 𝕜 s","decl":"theorem TotallyBounded.isVonNBounded {s : Set E} (hs : TotallyBounded s) :\n    Bornology.IsVonNBounded 𝕜 s := by\n  if h : ∃ x : 𝕜, 1 < ‖x‖ then\n    letI : NontriviallyNormedField 𝕜 := ⟨h⟩\n    rw [totallyBounded_iff_subset_finite_iUnion_nhds_zero] at hs\n    intro U hU\n    have h : Filter.Tendsto (fun x : E × E => x.fst + x.snd) (𝓝 0) (𝓝 0) :=\n      continuous_add.tendsto' _ _ (zero_add _)\n    have h' := (nhds_basis_balanced 𝕜 E).prod (nhds_basis_balanced 𝕜 E)\n    simp_rw [← nhds_prod_eq, id] at h'\n    rcases h.basis_left h' U hU with ⟨x, hx, h''⟩\n    rcases hs x.snd hx.2.1 with ⟨t, ht, hs⟩\n    refine Absorbs.mono_right ?_ hs\n    rw [ht.absorbs_biUnion]\n    have hx_fstsnd : x.fst + x.snd ⊆ U := add_subset_iff.mpr fun z1 hz1 z2 hz2 ↦\n      h'' <| mk_mem_prod hz1 hz2\n    refine fun y _ => Absorbs.mono_left ?_ hx_fstsnd\n    -- TODO: with dot notation, Lean timeouts on the next line. Why?\n    exact Absorbent.vadd_absorbs (absorbent_nhds_zero hx.1.1) hx.2.2.absorbs_self\n  else\n    haveI : BoundedSpace 𝕜 := ⟨Metric.isBounded_iff.2 ⟨1, by simp_all [dist_eq_norm]⟩⟩\n    exact Bornology.IsVonNBounded.of_boundedSpace\n\n"}
{"name":"Filter.Tendsto.isVonNBounded_range","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁵ : NormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : TopologicalSpace E\ninst✝¹ : TopologicalAddGroup E\ninst✝ : ContinuousSMul 𝕜 E\nf : Nat → E\nx : E\nhf : Filter.Tendsto f Filter.atTop (nhds x)\n⊢ Bornology.IsVonNBounded 𝕜 (Set.range f)","decl":"variable (𝕜) in\ntheorem Filter.Tendsto.isVonNBounded_range [NormedField 𝕜] [AddCommGroup E] [Module 𝕜 E]\n    [TopologicalSpace E] [TopologicalAddGroup E] [ContinuousSMul 𝕜 E]\n    {f : ℕ → E} {x : E} (hf : Tendsto f atTop (𝓝 x)) : Bornology.IsVonNBounded 𝕜 (range f) :=\n  letI := TopologicalAddGroup.toUniformSpace E\n  haveI := comm_topologicalAddGroup_is_uniform (G := E)\n  hf.cauchySeq.totallyBounded_range.isVonNBounded 𝕜\n\n"}
{"name":"Bornology.IsVonNBounded.restrict_scalars_of_nontrivial","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\n𝕜' : Type u_2\nE : Type u_3\ninst✝⁸ : NormedField 𝕜\ninst✝⁷ : NormedRing 𝕜'\ninst✝⁶ : NormedAlgebra 𝕜 𝕜'\ninst✝⁵ : Nontrivial 𝕜'\ninst✝⁴ : Zero E\ninst✝³ : TopologicalSpace E\ninst✝² : SMul 𝕜 E\ninst✝¹ : MulAction 𝕜' E\ninst✝ : IsScalarTower 𝕜 𝕜' E\ns : Set E\nh : Bornology.IsVonNBounded 𝕜' s\n⊢ Bornology.IsVonNBounded 𝕜 s","decl":"variable (𝕜) in\nprotected theorem Bornology.IsVonNBounded.restrict_scalars_of_nontrivial\n    [NormedField 𝕜] [NormedRing 𝕜'] [NormedAlgebra 𝕜 𝕜'] [Nontrivial 𝕜']\n    [Zero E] [TopologicalSpace E]\n    [SMul 𝕜 E] [MulAction 𝕜' E] [IsScalarTower 𝕜 𝕜' E] {s : Set E}\n    (h : IsVonNBounded 𝕜' s) : IsVonNBounded 𝕜 s := by\n  intro V hV\n  refine (h hV).restrict_scalars <| AntilipschitzWith.tendsto_cobounded (K := ‖(1 : 𝕜')‖₊⁻¹) ?_\n  refine AntilipschitzWith.of_le_mul_nndist fun x y ↦ ?_\n  rw [nndist_eq_nnnorm, nndist_eq_nnnorm, ← sub_smul, nnnorm_smul, ← div_eq_inv_mul,\n    mul_div_cancel_right₀ _ (nnnorm_ne_zero_iff.2 one_ne_zero)]\n\n"}
{"name":"Bornology.IsVonNBounded.restrict_scalars","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\n𝕜' : Type u_2\nE : Type u_3\ninst✝⁷ : NormedField 𝕜\ninst✝⁶ : NormedRing 𝕜'\ninst✝⁵ : NormedAlgebra 𝕜 𝕜'\ninst✝⁴ : Zero E\ninst✝³ : TopologicalSpace E\ninst✝² : SMul 𝕜 E\ninst✝¹ : MulActionWithZero 𝕜' E\ninst✝ : IsScalarTower 𝕜 𝕜' E\ns : Set E\nh : Bornology.IsVonNBounded 𝕜' s\n⊢ Bornology.IsVonNBounded 𝕜 s","decl":"variable (𝕜) in\nprotected theorem Bornology.IsVonNBounded.restrict_scalars\n    [NormedField 𝕜] [NormedRing 𝕜'] [NormedAlgebra 𝕜 𝕜']\n    [Zero E] [TopologicalSpace E]\n    [SMul 𝕜 E] [MulActionWithZero 𝕜' E] [IsScalarTower 𝕜 𝕜' E] {s : Set E}\n    (h : IsVonNBounded 𝕜' s) : IsVonNBounded 𝕜 s :=\n  match subsingleton_or_nontrivial 𝕜' with\n  | .inl _ =>\n    have : Subsingleton E := MulActionWithZero.subsingleton 𝕜' E\n    IsVonNBounded.of_subsingleton\n  | .inr _ =>\n    h.restrict_scalars_of_nontrivial _\n\n"}
{"name":"NormedSpace.isVonNBounded_of_isBounded","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : NormedField 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\ns : Set E\nh : Bornology.IsBounded s\n⊢ Bornology.IsVonNBounded 𝕜 s","decl":"theorem isVonNBounded_of_isBounded {s : Set E} (h : Bornology.IsBounded s) :\n    Bornology.IsVonNBounded 𝕜 s := by\n  rcases h.subset_ball 0 with ⟨r, hr⟩\n  rw [Metric.nhds_basis_ball.isVonNBounded_iff]\n  rw [← ball_normSeminorm 𝕜 E] at hr ⊢\n  exact fun ε hε ↦ ((normSeminorm 𝕜 E).ball_zero_absorbs_ball_zero hε).mono_right hr\n\n"}
{"name":"NormedSpace.isVonNBounded_ball","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : NormedField 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nr : Real\n⊢ Bornology.IsVonNBounded 𝕜 (Metric.ball 0 r)","decl":"theorem isVonNBounded_ball (r : ℝ) : Bornology.IsVonNBounded 𝕜 (Metric.ball (0 : E) r) :=\n  isVonNBounded_of_isBounded _ Metric.isBounded_ball\n\n"}
{"name":"NormedSpace.isVonNBounded_closedBall","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : NormedField 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nr : Real\n⊢ Bornology.IsVonNBounded 𝕜 (Metric.closedBall 0 r)","decl":"theorem isVonNBounded_closedBall (r : ℝ) :\n    Bornology.IsVonNBounded 𝕜 (Metric.closedBall (0 : E) r) :=\n  isVonNBounded_of_isBounded _ Metric.isBounded_closedBall\n\n"}
{"name":"NormedSpace.isVonNBounded_iff","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\ns : Set E\n⊢ Iff (Bornology.IsVonNBounded 𝕜 s) (Bornology.IsBounded s)","decl":"theorem isVonNBounded_iff {s : Set E} : Bornology.IsVonNBounded 𝕜 s ↔ Bornology.IsBounded s := by\n  refine ⟨fun h ↦ ?_, isVonNBounded_of_isBounded _⟩\n  rcases (h (Metric.ball_mem_nhds 0 zero_lt_one)).exists_pos with ⟨ρ, hρ, hρball⟩\n  rcases NormedField.exists_lt_norm 𝕜 ρ with ⟨a, ha⟩\n  specialize hρball a ha.le\n  rw [← ball_normSeminorm 𝕜 E, Seminorm.smul_ball_zero (norm_pos_iff.1 <| hρ.trans ha),\n    ball_normSeminorm] at hρball\n  exact Metric.isBounded_ball.subset hρball\n\n"}
{"name":"NormedSpace.isVonNBounded_iff'","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\ns : Set E\n⊢ Iff (Bornology.IsVonNBounded 𝕜 s) (Exists fun r => ∀ (x : E), Membership.mem s x → LE.le (Norm.norm x) r)","decl":"theorem isVonNBounded_iff' {s : Set E} :\n    Bornology.IsVonNBounded 𝕜 s ↔ ∃ r : ℝ, ∀ x ∈ s, ‖x‖ ≤ r := by\n  rw [NormedSpace.isVonNBounded_iff, isBounded_iff_forall_norm_le]\n\n"}
{"name":"NormedSpace.image_isVonNBounded_iff","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nα : Type u_6\nf : α → E\ns : Set α\n⊢ Iff (Bornology.IsVonNBounded 𝕜 (Set.image f s)) (Exists fun r => ∀ (x : α), Membership.mem s x → LE.le (Norm.norm (f x)) r)","decl":"theorem image_isVonNBounded_iff {α : Type*} {f : α → E} {s : Set α} :\n    Bornology.IsVonNBounded 𝕜 (f '' s) ↔ ∃ r : ℝ, ∀ x ∈ s, ‖f x‖ ≤ r := by\n  simp_rw [isVonNBounded_iff', Set.forall_mem_image]\n\n"}
{"name":"NormedSpace.vonNBornology_eq","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\n⊢ Eq (Bornology.vonNBornology 𝕜 E) PseudoMetricSpace.toBornology","decl":"/-- In a normed space, the von Neumann bornology (`Bornology.vonNBornology`) is equal to the\nmetric bornology. -/\ntheorem vonNBornology_eq : Bornology.vonNBornology 𝕜 E = PseudoMetricSpace.toBornology := by\n  rw [Bornology.ext_iff_isBounded]\n  intro s\n  rw [Bornology.isBounded_iff_isVonNBounded]\n  exact isVonNBounded_iff _\n\n"}
{"name":"NormedSpace.isBounded_iff_subset_smul_ball","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\ns : Set E\n⊢ Iff (Bornology.IsBounded s) (Exists fun a => HasSubset.Subset s (HSMul.hSMul a (Metric.ball 0 1)))","decl":"theorem isBounded_iff_subset_smul_ball {s : Set E} :\n    Bornology.IsBounded s ↔ ∃ a : 𝕜, s ⊆ a • Metric.ball (0 : E) 1 := by\n  rw [← isVonNBounded_iff 𝕜]\n  constructor\n  · intro h\n    rcases (h (Metric.ball_mem_nhds 0 zero_lt_one)).exists_pos with ⟨ρ, _, hρball⟩\n    rcases NormedField.exists_lt_norm 𝕜 ρ with ⟨a, ha⟩\n    exact ⟨a, hρball a ha.le⟩\n  · rintro ⟨a, ha⟩\n    exact ((isVonNBounded_ball 𝕜 E 1).image (a • (1 : E →L[𝕜] E))).subset ha\n\n"}
{"name":"NormedSpace.isBounded_iff_subset_smul_closedBall","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\ns : Set E\n⊢ Iff (Bornology.IsBounded s) (Exists fun a => HasSubset.Subset s (HSMul.hSMul a (Metric.closedBall 0 1)))","decl":"theorem isBounded_iff_subset_smul_closedBall {s : Set E} :\n    Bornology.IsBounded s ↔ ∃ a : 𝕜, s ⊆ a • Metric.closedBall (0 : E) 1 := by\n  constructor\n  · rw [isBounded_iff_subset_smul_ball 𝕜]\n    exact Exists.imp fun a ha => ha.trans <| Set.smul_set_mono <| Metric.ball_subset_closedBall\n  · rw [← isVonNBounded_iff 𝕜]\n    rintro ⟨a, ha⟩\n    exact ((isVonNBounded_closedBall 𝕜 E 1).image (a • (1 : E →L[𝕜] E))).subset ha\n\n"}
