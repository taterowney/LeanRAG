{"name":"Bornology.isVonNBounded_empty","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ³ : SeminormedRing ğ•œ\ninstâœÂ² : SMul ğ•œ E\ninstâœÂ¹ : Zero E\ninstâœ : TopologicalSpace E\nâŠ¢ Bornology.IsVonNBounded ğ•œ EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem isVonNBounded_empty : IsVonNBounded ğ•œ (âˆ… : Set E) := fun _ _ => Absorbs.empty\n\n"}
{"name":"Bornology.isVonNBounded_iff","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ³ : SeminormedRing ğ•œ\ninstâœÂ² : SMul ğ•œ E\ninstâœÂ¹ : Zero E\ninstâœ : TopologicalSpace E\ns : Set E\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ s) (âˆ€ (V : Set E), Membership.mem (nhds 0) V â†’ Absorbs ğ•œ V s)","decl":"theorem isVonNBounded_iff (s : Set E) : IsVonNBounded ğ•œ s â†” âˆ€ V âˆˆ ğ“ (0 : E), Absorbs ğ•œ V s :=\n  Iff.rfl\n\n"}
{"name":"Filter.HasBasis.isVonNBounded_iff","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\ninstâœÂ³ : SeminormedRing ğ•œ\ninstâœÂ² : SMul ğ•œ E\ninstâœÂ¹ : Zero E\ninstâœ : TopologicalSpace E\nq : Î¹ â†’ Prop\ns : Î¹ â†’ Set E\nA : Set E\nh : (nhds 0).HasBasis q s\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ A) (âˆ€ (i : Î¹), q i â†’ Absorbs ğ•œ (s i) A)","decl":"theorem _root_.Filter.HasBasis.isVonNBounded_iff {q : Î¹ â†’ Prop} {s : Î¹ â†’ Set E} {A : Set E}\n    (h : (ğ“ (0 : E)).HasBasis q s) : IsVonNBounded ğ•œ A â†” âˆ€ i, q i â†’ Absorbs ğ•œ (s i) A := by\n  refine âŸ¨fun hA i hi => hA (h.mem_of_mem hi), fun hA V hV => ?_âŸ©\n  rcases h.mem_iff.mp hV with âŸ¨i, hi, hVâŸ©\n  exact (hA i hi).mono_left hV\n\n"}
{"name":"Bornology.IsVonNBounded.subset","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ³ : SeminormedRing ğ•œ\ninstâœÂ² : SMul ğ•œ E\ninstâœÂ¹ : Zero E\ninstâœ : TopologicalSpace E\nsâ‚ sâ‚‚ : Set E\nh : HasSubset.Subset sâ‚ sâ‚‚\nhsâ‚‚ : Bornology.IsVonNBounded ğ•œ sâ‚‚\nâŠ¢ Bornology.IsVonNBounded ğ•œ sâ‚","decl":"/-- Subsets of bounded sets are bounded. -/\ntheorem IsVonNBounded.subset {sâ‚ sâ‚‚ : Set E} (h : sâ‚ âŠ† sâ‚‚) (hsâ‚‚ : IsVonNBounded ğ•œ sâ‚‚) :\n    IsVonNBounded ğ•œ sâ‚ := fun _ hV => (hsâ‚‚ hV).mono_right h\n\n"}
{"name":"Bornology.isVonNBounded_union","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ³ : SeminormedRing ğ•œ\ninstâœÂ² : SMul ğ•œ E\ninstâœÂ¹ : Zero E\ninstâœ : TopologicalSpace E\ns t : Set E\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ (Union.union s t)) (And (Bornology.IsVonNBounded ğ•œ s) (Bornology.IsVonNBounded ğ•œ t))","decl":"@[simp]\ntheorem isVonNBounded_union {s t : Set E} :\n    IsVonNBounded ğ•œ (s âˆª t) â†” IsVonNBounded ğ•œ s âˆ§ IsVonNBounded ğ•œ t := by\n  simp only [IsVonNBounded, absorbs_union, forall_and]\n\n"}
{"name":"Bornology.IsVonNBounded.union","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ³ : SeminormedRing ğ•œ\ninstâœÂ² : SMul ğ•œ E\ninstâœÂ¹ : Zero E\ninstâœ : TopologicalSpace E\nsâ‚ sâ‚‚ : Set E\nhsâ‚ : Bornology.IsVonNBounded ğ•œ sâ‚\nhsâ‚‚ : Bornology.IsVonNBounded ğ•œ sâ‚‚\nâŠ¢ Bornology.IsVonNBounded ğ•œ (Union.union sâ‚ sâ‚‚)","decl":"/-- The union of two bounded sets is bounded. -/\ntheorem IsVonNBounded.union {sâ‚ sâ‚‚ : Set E} (hsâ‚ : IsVonNBounded ğ•œ sâ‚) (hsâ‚‚ : IsVonNBounded ğ•œ sâ‚‚) :\n    IsVonNBounded ğ•œ (sâ‚ âˆª sâ‚‚) := isVonNBounded_union.2 âŸ¨hsâ‚, hsâ‚‚âŸ©\n\n"}
{"name":"Bornology.IsVonNBounded.of_boundedSpace","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâ´ : SeminormedRing ğ•œ\ninstâœÂ³ : SMul ğ•œ E\ninstâœÂ² : Zero E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : BoundedSpace ğ•œ\ns : Set E\nâŠ¢ Bornology.IsVonNBounded ğ•œ s","decl":"@[nontriviality]\ntheorem IsVonNBounded.of_boundedSpace [BoundedSpace ğ•œ] {s : Set E} : IsVonNBounded ğ•œ s := fun _ _ â†¦\n  .of_boundedSpace\n\n"}
{"name":"Bornology.IsVonNBounded.of_subsingleton","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâ´ : SeminormedRing ğ•œ\ninstâœÂ³ : SMul ğ•œ E\ninstâœÂ² : Zero E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : Subsingleton E\ns : Set E\nâŠ¢ Bornology.IsVonNBounded ğ•œ s","decl":"@[nontriviality]\ntheorem IsVonNBounded.of_subsingleton [Subsingleton E] {s : Set E} : IsVonNBounded ğ•œ s :=\n  fun U hU â†¦ .of_forall fun c â†¦ calc\n    s âŠ† univ := subset_univ s\n    _ = c â€¢ U := .symm <| Subsingleton.eq_univ_of_nonempty <| (Filter.nonempty_of_mem hU).image _\n\n"}
{"name":"Bornology.isVonNBounded_iUnion","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâ´ : SeminormedRing ğ•œ\ninstâœÂ³ : SMul ğ•œ E\ninstâœÂ² : Zero E\ninstâœÂ¹ : TopologicalSpace E\nÎ¹ : Sort u_6\ninstâœ : Finite Î¹\ns : Î¹ â†’ Set E\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ (Set.iUnion fun i => s i)) (âˆ€ (i : Î¹), Bornology.IsVonNBounded ğ•œ (s i))","decl":"@[simp]\ntheorem isVonNBounded_iUnion {Î¹ : Sort*} [Finite Î¹] {s : Î¹ â†’ Set E} :\n    IsVonNBounded ğ•œ (â‹ƒ i, s i) â†” âˆ€ i, IsVonNBounded ğ•œ (s i) := by\n  simp only [IsVonNBounded, absorbs_iUnion, @forall_swap Î¹]\n\n"}
{"name":"Bornology.isVonNBounded_biUnion","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ³ : SeminormedRing ğ•œ\ninstâœÂ² : SMul ğ•œ E\ninstâœÂ¹ : Zero E\ninstâœ : TopologicalSpace E\nÎ¹ : Type u_6\nI : Set Î¹\nhI : I.Finite\ns : Î¹ â†’ Set E\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ (Set.iUnion fun i => Set.iUnion fun h => s i)) (âˆ€ (i : Î¹), Membership.mem I i â†’ Bornology.IsVonNBounded ğ•œ (s i))","decl":"theorem isVonNBounded_biUnion {Î¹ : Type*} {I : Set Î¹} (hI : I.Finite) {s : Î¹ â†’ Set E} :\n    IsVonNBounded ğ•œ (â‹ƒ i âˆˆ I, s i) â†” âˆ€ i âˆˆ I, IsVonNBounded ğ•œ (s i) := by\n  have _ := hI.to_subtype\n  rw [biUnion_eq_iUnion, isVonNBounded_iUnion, Subtype.forall]\n\n"}
{"name":"Bornology.isVonNBounded_sUnion","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ³ : SeminormedRing ğ•œ\ninstâœÂ² : SMul ğ•œ E\ninstâœÂ¹ : Zero E\ninstâœ : TopologicalSpace E\nS : Set (Set E)\nhS : S.Finite\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ S.sUnion) (âˆ€ (s : Set E), Membership.mem S s â†’ Bornology.IsVonNBounded ğ•œ s)","decl":"theorem isVonNBounded_sUnion {S : Set (Set E)} (hS : S.Finite) :\n    IsVonNBounded ğ•œ (â‹ƒâ‚€ S) â†” âˆ€ s âˆˆ S, IsVonNBounded ğ•œ s := by\n  rw [sUnion_eq_biUnion, isVonNBounded_biUnion hS]\n\n"}
{"name":"Bornology.IsVonNBounded.add","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâ´ : SeminormedRing ğ•œ\ninstâœÂ³ : AddZeroClass E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : ContinuousAdd E\ninstâœ : DistribSMul ğ•œ E\ns t : Set E\nhs : Bornology.IsVonNBounded ğ•œ s\nht : Bornology.IsVonNBounded ğ•œ t\nâŠ¢ Bornology.IsVonNBounded ğ•œ (HAdd.hAdd s t)","decl":"protected theorem IsVonNBounded.add (hs : IsVonNBounded ğ•œ s) (ht : IsVonNBounded ğ•œ t) :\n    IsVonNBounded ğ•œ (s + t) := fun U hU â†¦ by\n  rcases exists_open_nhds_zero_add_subset hU with âŸ¨V, hVo, hV, hVUâŸ©\n  exact ((hs <| hVo.mem_nhds hV).add (ht <| hVo.mem_nhds hV)).mono_left hVU\n\n"}
{"name":"Bornology.IsVonNBounded.neg","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâ´ : SeminormedRing ğ•œ\ninstâœÂ³ : AddGroup E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : DistribMulAction ğ•œ E\ns : Set E\nhs : Bornology.IsVonNBounded ğ•œ s\nâŠ¢ Bornology.IsVonNBounded ğ•œ (Neg.neg s)","decl":"protected theorem IsVonNBounded.neg (hs : IsVonNBounded ğ•œ s) : IsVonNBounded ğ•œ (-s) := fun U hU â†¦ by\n  rw [â† neg_neg U]\n  exact (hs <| neg_mem_nhds_zero _ hU).neg_neg\n\n"}
{"name":"Bornology.isVonNBounded_neg","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâ´ : SeminormedRing ğ•œ\ninstâœÂ³ : AddGroup E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : DistribMulAction ğ•œ E\ns : Set E\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ (Neg.neg s)) (Bornology.IsVonNBounded ğ•œ s)","decl":"@[simp]\ntheorem isVonNBounded_neg : IsVonNBounded ğ•œ (-s) â†” IsVonNBounded ğ•œ s :=\n  âŸ¨fun h â†¦ neg_neg s â–¸ h.neg, fun h â†¦ h.negâŸ©\n\n"}
{"name":"Bornology.IsVonNBounded.of_neg","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâ´ : SeminormedRing ğ•œ\ninstâœÂ³ : AddGroup E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : DistribMulAction ğ•œ E\ns : Set E\naâœ : Bornology.IsVonNBounded ğ•œ (Neg.neg s)\nâŠ¢ Bornology.IsVonNBounded ğ•œ s","decl":"alias âŸ¨IsVonNBounded.of_neg, _âŸ© := isVonNBounded_neg\n\n"}
{"name":"Bornology.IsVonNBounded.sub","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâ´ : SeminormedRing ğ•œ\ninstâœÂ³ : AddGroup E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : DistribMulAction ğ•œ E\ns t : Set E\nhs : Bornology.IsVonNBounded ğ•œ s\nht : Bornology.IsVonNBounded ğ•œ t\nâŠ¢ Bornology.IsVonNBounded ğ•œ (HSub.hSub s t)","decl":"protected theorem IsVonNBounded.sub (hs : IsVonNBounded ğ•œ s) (ht : IsVonNBounded ğ•œ t) :\n    IsVonNBounded ğ•œ (s - t) := by\n  rw [sub_eq_add_neg]\n  exact hs.add ht.neg\n\n"}
{"name":"Bornology.IsVonNBounded.of_topologicalSpace_le","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nt t' : TopologicalSpace E\nh : LE.le t t'\ns : Set E\nhs : Bornology.IsVonNBounded ğ•œ s\nâŠ¢ Bornology.IsVonNBounded ğ•œ s","decl":"/-- If a topology `t'` is coarser than `t`, then any set `s` that is bounded with respect to\n`t` is bounded with respect to `t'`. -/\ntheorem IsVonNBounded.of_topologicalSpace_le {t t' : TopologicalSpace E} (h : t â‰¤ t') {s : Set E}\n    (hs : @IsVonNBounded ğ•œ E _ _ _ t s) : @IsVonNBounded ğ•œ E _ _ _ t' s := fun _ hV =>\n  hs <| (le_iff_nhds t t').mp h 0 hV\n\n"}
{"name":"Bornology.isVonNBounded_iff_tendsto_smallSets_nhds","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_6\nE : Type u_7\ninstâœÂ³ : NormedDivisionRing ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : TopologicalSpace E\nS : Set E\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ S) (Filter.Tendsto (fun x => HSMul.hSMul x S) (nhds 0) (nhds 0).smallSets)","decl":"lemma isVonNBounded_iff_tendsto_smallSets_nhds {ğ•œ E : Type*} [NormedDivisionRing ğ•œ]\n    [AddCommGroup E] [Module ğ•œ E] [TopologicalSpace E] {S : Set E} :\n    IsVonNBounded ğ•œ S â†” Tendsto (Â· â€¢ S : ğ•œ â†’ Set E) (ğ“ 0) (ğ“ 0).smallSets := by\n  rw [tendsto_smallSets_iff]\n  refine forallâ‚‚_congr fun V hV â†¦ ?_\n  simp only [absorbs_iff_eventually_nhds_zero (mem_of_mem_nhds hV), mapsTo', image_smul]\n\n"}
{"name":"Bornology.IsVonNBounded.tendsto_smallSets_nhds","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_6\nE : Type u_7\ninstâœÂ³ : NormedDivisionRing ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : TopologicalSpace E\nS : Set E\naâœ : Bornology.IsVonNBounded ğ•œ S\nâŠ¢ Filter.Tendsto (fun x => HSMul.hSMul x S) (nhds 0) (nhds 0).smallSets","decl":"alias âŸ¨IsVonNBounded.tendsto_smallSets_nhds, _âŸ© := isVonNBounded_iff_tendsto_smallSets_nhds\n\n"}
{"name":"Bornology.isVonNBounded_iff_absorbing_le","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_6\nE : Type u_7\ninstâœÂ³ : NormedDivisionRing ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : TopologicalSpace E\nS : Set E\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ S) (LE.le (Filter.absorbing ğ•œ S) (nhds 0))","decl":"lemma isVonNBounded_iff_absorbing_le {ğ•œ E : Type*} [NormedDivisionRing ğ•œ]\n    [AddCommGroup E] [Module ğ•œ E] [TopologicalSpace E] {S : Set E} :\n    IsVonNBounded ğ•œ S â†” Filter.absorbing ğ•œ S â‰¤ ğ“ 0 :=\n  .rfl\n\n"}
{"name":"Bornology.isVonNBounded_pi_iff","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_6\nÎ¹ : Type u_7\nE : Î¹ â†’ Type u_8\ninstâœÂ³ : NormedDivisionRing ğ•œ\ninstâœÂ² : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœÂ¹ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœ : (i : Î¹) â†’ TopologicalSpace (E i)\nS : Set ((i : Î¹) â†’ E i)\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ S) (âˆ€ (i : Î¹), Bornology.IsVonNBounded ğ•œ (Set.image (Function.eval i) S))","decl":"lemma isVonNBounded_pi_iff {ğ•œ Î¹ : Type*} {E : Î¹ â†’ Type*} [NormedDivisionRing ğ•œ]\n    [âˆ€ i, AddCommGroup (E i)] [âˆ€ i, Module ğ•œ (E i)] [âˆ€ i, TopologicalSpace (E i)]\n    {S : Set (âˆ€ i, E i)} : IsVonNBounded ğ•œ S â†” âˆ€ i, IsVonNBounded ğ•œ (eval i '' S) := by\n  simp_rw [isVonNBounded_iff_tendsto_smallSets_nhds, nhds_pi, Filter.pi, smallSets_iInf,\n    smallSets_comap_eq_comap_image, tendsto_iInf, tendsto_comap_iff, Function.comp_def,\n    â† image_smul, image_image, eval, Pi.smul_apply, Pi.zero_apply]\n\n"}
{"name":"Bornology.IsVonNBounded.image","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"E : Type u_3\nF : Type u_4\nğ•œâ‚ : Type u_6\nğ•œâ‚‚ : Type u_7\ninstâœâ¹ : NormedDivisionRing ğ•œâ‚\ninstâœâ¸ : NormedDivisionRing ğ•œâ‚‚\ninstâœâ· : AddCommGroup E\ninstâœâ¶ : Module ğ•œâ‚ E\ninstâœâµ : AddCommGroup F\ninstâœâ´ : Module ğ•œâ‚‚ F\ninstâœÂ³ : TopologicalSpace E\ninstâœÂ² : TopologicalSpace F\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\ninstâœÂ¹ : RingHomSurjective Ïƒ\ninstâœ : RingHomIsometric Ïƒ\ns : Set E\nhs : Bornology.IsVonNBounded ğ•œâ‚ s\nf : ContinuousLinearMap Ïƒ E F\nâŠ¢ Bornology.IsVonNBounded ğ•œâ‚‚ (Set.image (â‡‘f) s)","decl":"/-- A continuous linear image of a bounded set is bounded. -/\ntheorem IsVonNBounded.image {Ïƒ : ğ•œâ‚ â†’+* ğ•œâ‚‚} [RingHomSurjective Ïƒ] [RingHomIsometric Ïƒ] {s : Set E}\n    (hs : IsVonNBounded ğ•œâ‚ s) (f : E â†’SL[Ïƒ] F) : IsVonNBounded ğ•œâ‚‚ (f '' s) := by\n  have Ïƒ_iso : Isometry Ïƒ := AddMonoidHomClass.isometry_of_norm Ïƒ fun x => RingHomIsometric.is_iso\n  have : map Ïƒ (ğ“ 0) = ğ“ 0 := by\n    rw [Ïƒ_iso.isEmbedding.map_nhds_eq, Ïƒ.surjective.range_eq, nhdsWithin_univ, map_zero]\n  have hfâ‚€ : Tendsto f (ğ“ 0) (ğ“ 0) := f.continuous.tendsto' 0 0 (map_zero f)\n  simp only [isVonNBounded_iff_tendsto_smallSets_nhds, â† this, tendsto_map'_iff] at hs âŠ¢\n  simpa only [comp_def, image_smul_setâ‚›â‚— _ _ Ïƒ f] using hfâ‚€.image_smallSets.comp hs\n\n"}
{"name":"Bornology.IsVonNBounded.smul_tendsto_zero","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : TopologicalSpace E\nS : Set E\nÎµ : Î¹ â†’ ğ•œ\nx : Î¹ â†’ E\nl : Filter Î¹\nhS : Bornology.IsVonNBounded ğ•œ S\nhxS : Filter.Eventually (fun n => Membership.mem S (x n)) l\nhÎµ : Filter.Tendsto Îµ l (nhds 0)\nâŠ¢ Filter.Tendsto (HSMul.hSMul Îµ x) l (nhds 0)","decl":"theorem IsVonNBounded.smul_tendsto_zero [NormedField ğ•œ]\n    [AddCommGroup E] [Module ğ•œ E] [TopologicalSpace E]\n    {S : Set E} {Îµ : Î¹ â†’ ğ•œ} {x : Î¹ â†’ E} {l : Filter Î¹}\n    (hS : IsVonNBounded ğ•œ S) (hxS : âˆ€á¶  n in l, x n âˆˆ S) (hÎµ : Tendsto Îµ l (ğ“ 0)) :\n    Tendsto (Îµ â€¢ x) l (ğ“ 0) :=\n  (hS.tendsto_smallSets_nhds.comp hÎµ).of_smallSets <| hxS.mono fun _ â†¦ smul_mem_smul_set\n\n"}
{"name":"Bornology.isVonNBounded_of_smul_tendsto_zero","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\nÎµ : Î¹ â†’ ğ•œ\nl : Filter Î¹\ninstâœ : l.NeBot\nhÎµ : Filter.Eventually (fun n => Ne (Îµ n) 0) l\nS : Set E\nH : âˆ€ (x : Î¹ â†’ E), (âˆ€ (n : Î¹), Membership.mem S (x n)) â†’ Filter.Tendsto (HSMul.hSMul Îµ x) l (nhds 0)\nâŠ¢ Bornology.IsVonNBounded ğ•œ S","decl":"theorem isVonNBounded_of_smul_tendsto_zero {Îµ : Î¹ â†’ ğ•œ} {l : Filter Î¹} [l.NeBot]\n    (hÎµ : âˆ€á¶  n in l, Îµ n â‰  0) {S : Set E}\n    (H : âˆ€ x : Î¹ â†’ E, (âˆ€ n, x n âˆˆ S) â†’ Tendsto (Îµ â€¢ x) l (ğ“ 0)) : IsVonNBounded ğ•œ S := by\n  rw [(nhds_basis_balanced ğ•œ E).isVonNBounded_iff]\n  by_contra! H'\n  rcases H' with âŸ¨V, âŸ¨hV, hVbâŸ©, hVSâŸ©\n  have : âˆ€á¶  n in l, âˆƒ x : S, Îµ n â€¢ (x : E) âˆ‰ V := by\n    filter_upwards [hÎµ] with n hn\n    rw [absorbs_iff_norm] at hVS\n    push_neg at hVS\n    rcases hVS â€–(Îµ n)â»Â¹â€– with âŸ¨a, haÎµ, haSâŸ©\n    rcases Set.not_subset.mp haS with âŸ¨x, hxS, hxâŸ©\n    refine âŸ¨âŸ¨x, hxSâŸ©, fun hnx => ?_âŸ©\n    rw [â† Set.mem_inv_smul_set_iffâ‚€ hn] at hnx\n    exact hx (hVb.smul_mono haÎµ hnx)\n  rcases this.choice with âŸ¨x, hxâŸ©\n  refine Filter.frequently_false l (Filter.Eventually.frequently ?_)\n  filter_upwards [hx,\n    (H (_ âˆ˜ x) fun n => (x n).2).eventually (eventually_mem_set.mpr hV)] using fun n => id\n\n"}
{"name":"Bornology.isVonNBounded_iff_smul_tendsto_zero","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\nÎµ : Î¹ â†’ ğ•œ\nl : Filter Î¹\ninstâœ : l.NeBot\nhÎµ : Filter.Tendsto Îµ l (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0)))\nS : Set E\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ S) (âˆ€ (x : Î¹ â†’ E), (âˆ€ (n : Î¹), Membership.mem S (x n)) â†’ Filter.Tendsto (HSMul.hSMul Îµ x) l (nhds 0))","decl":"/-- Given any sequence `Îµ` of scalars which tends to `ğ“[â‰ ] 0`, we have that a set `S` is bounded\n  if and only if for any sequence `x : â„• â†’ S`, `Îµ â€¢ x` tends to 0. This actually works for any\n  indexing type `Î¹`, but in the special case `Î¹ = â„•` we get the important fact that convergent\n  sequences fully characterize bounded sets. -/\ntheorem isVonNBounded_iff_smul_tendsto_zero {Îµ : Î¹ â†’ ğ•œ} {l : Filter Î¹} [l.NeBot]\n    (hÎµ : Tendsto Îµ l (ğ“[â‰ ] 0)) {S : Set E} :\n    IsVonNBounded ğ•œ S â†” âˆ€ x : Î¹ â†’ E, (âˆ€ n, x n âˆˆ S) â†’ Tendsto (Îµ â€¢ x) l (ğ“ 0) :=\n  âŸ¨fun hS _ hxS => hS.smul_tendsto_zero (Eventually.of_forall hxS) (le_trans hÎµ nhdsWithin_le_nhds),\n    isVonNBounded_of_smul_tendsto_zero (by exact hÎµ self_mem_nhdsWithin)âŸ©\n\n"}
{"name":"Bornology.IsVonNBounded.extend_scalars","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_6\ninstâœâ· : AddCommGroup E\ninstâœâ¶ : Module ğ•œ E\nğ• : Type u_7\ninstâœâµ : NontriviallyNormedField ğ•\ninstâœâ´ : NormedAlgebra ğ•œ ğ•\ninstâœÂ³ : Module ğ• E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : ContinuousSMul ğ• E\ninstâœ : IsScalarTower ğ•œ ğ• E\ns : Set E\nh : Bornology.IsVonNBounded ğ•œ s\nâŠ¢ Bornology.IsVonNBounded ğ• s","decl":"/-- If a set is von Neumann bounded with respect to a smaller field,\nthen it is also von Neumann bounded with respect to a larger field.\nSee also `Bornology.IsVonNBounded.restrict_scalars` below. -/\ntheorem IsVonNBounded.extend_scalars [NontriviallyNormedField ğ•œ]\n    {E : Type*} [AddCommGroup E] [Module ğ•œ E]\n    (ğ• : Type*) [NontriviallyNormedField ğ•] [NormedAlgebra ğ•œ ğ•]\n    [Module ğ• E] [TopologicalSpace E] [ContinuousSMul ğ• E] [IsScalarTower ğ•œ ğ• E]\n    {s : Set E} (h : IsVonNBounded ğ•œ s) : IsVonNBounded ğ• s := by\n  obtain âŸ¨Îµ, hÎµ, hÎµâ‚€âŸ© : âˆƒ Îµ : â„• â†’ ğ•œ, Tendsto Îµ atTop (ğ“ 0) âˆ§ âˆ€á¶  n in atTop, Îµ n â‰  0 := by\n    simpa only [tendsto_nhdsWithin_iff] using exists_seq_tendsto (ğ“[â‰ ] (0 : ğ•œ))\n  refine isVonNBounded_of_smul_tendsto_zero (Îµ := (Îµ Â· â€¢ 1)) (by simpa) fun x hx â†¦ ?_\n  have := h.smul_tendsto_zero (.of_forall hx) hÎµ\n  simpa only [Pi.smul_def', smul_one_smul]\n\n"}
{"name":"Bornology.isVonNBounded_singleton","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousSMul ğ•œ E\nx : E\nâŠ¢ Bornology.IsVonNBounded ğ•œ (Singleton.singleton x)","decl":"/-- Singletons are bounded. -/\ntheorem isVonNBounded_singleton (x : E) : IsVonNBounded ğ•œ ({x} : Set E) := fun _ hV =>\n  (absorbent_nhds_zero hV).absorbs\n\n"}
{"name":"Bornology.isVonNBounded_insert","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousSMul ğ•œ E\nx : E\ns : Set E\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ (Insert.insert x s)) (Bornology.IsVonNBounded ğ•œ s)","decl":"@[simp]\ntheorem isVonNBounded_insert (x : E) {s : Set E} :\n    IsVonNBounded ğ•œ (insert x s) â†” IsVonNBounded ğ•œ s := by\n  simp only [â† singleton_union, isVonNBounded_union, isVonNBounded_singleton, true_and]\n\n"}
{"name":"Bornology.IsVonNBounded.insert","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousSMul ğ•œ E\nx : E\ns : Set E\naâœ : Bornology.IsVonNBounded ğ•œ s\nâŠ¢ Bornology.IsVonNBounded ğ•œ (Insert.insert x s)","decl":"protected alias âŸ¨_, IsVonNBounded.insertâŸ© := isVonNBounded_insert\n\n"}
{"name":"Bornology.IsVonNBounded.vadd","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâµ : NormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\ninstâœ : ContinuousAdd E\ns : Set E\nhs : Bornology.IsVonNBounded ğ•œ s\nx : E\nâŠ¢ Bornology.IsVonNBounded ğ•œ (HVAdd.hVAdd x s)","decl":"protected theorem IsVonNBounded.vadd (hs : IsVonNBounded ğ•œ s) (x : E) :\n    IsVonNBounded ğ•œ (x +áµ¥ s) := by\n  rw [â† singleton_vadd]\n  -- TODO: dot notation timeouts in the next line\n  exact IsVonNBounded.add (isVonNBounded_singleton x) hs\n\n"}
{"name":"Bornology.isVonNBounded_vadd","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâµ : NormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\ninstâœ : ContinuousAdd E\ns : Set E\nx : E\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ (HVAdd.hVAdd x s)) (Bornology.IsVonNBounded ğ•œ s)","decl":"@[simp]\ntheorem isVonNBounded_vadd (x : E) : IsVonNBounded ğ•œ (x +áµ¥ s) â†” IsVonNBounded ğ•œ s :=\n  âŸ¨fun h â†¦ by simpa using h.vadd (-x), fun h â†¦ h.vadd xâŸ©\n\n"}
{"name":"Bornology.IsVonNBounded.of_add_right","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâµ : NormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\ninstâœ : ContinuousAdd E\ns t : Set E\nhst : Bornology.IsVonNBounded ğ•œ (HAdd.hAdd s t)\nhs : s.Nonempty\nâŠ¢ Bornology.IsVonNBounded ğ•œ t","decl":"theorem IsVonNBounded.of_add_right (hst : IsVonNBounded ğ•œ (s + t)) (hs : s.Nonempty) :\n    IsVonNBounded ğ•œ t :=\n  let âŸ¨x, hxâŸ© := hs\n  (isVonNBounded_vadd x).mp <| hst.subset <| image_subset_image2_right hx\n\n"}
{"name":"Bornology.IsVonNBounded.of_add_left","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâµ : NormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\ninstâœ : ContinuousAdd E\ns t : Set E\nhst : Bornology.IsVonNBounded ğ•œ (HAdd.hAdd s t)\nht : t.Nonempty\nâŠ¢ Bornology.IsVonNBounded ğ•œ s","decl":"theorem IsVonNBounded.of_add_left (hst : IsVonNBounded ğ•œ (s + t)) (ht : t.Nonempty) :\n    IsVonNBounded ğ•œ s :=\n  ((add_comm s t).subst hst).of_add_right ht\n\n"}
{"name":"Bornology.isVonNBounded_add_of_nonempty","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâµ : NormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\ninstâœ : ContinuousAdd E\ns t : Set E\nhs : s.Nonempty\nht : t.Nonempty\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ (HAdd.hAdd s t)) (And (Bornology.IsVonNBounded ğ•œ s) (Bornology.IsVonNBounded ğ•œ t))","decl":"theorem isVonNBounded_add_of_nonempty (hs : s.Nonempty) (ht : t.Nonempty) :\n    IsVonNBounded ğ•œ (s + t) â†” IsVonNBounded ğ•œ s âˆ§ IsVonNBounded ğ•œ t :=\n  âŸ¨fun h â†¦ âŸ¨h.of_add_left ht, h.of_add_right hsâŸ©, and_imp.2 IsVonNBounded.addâŸ©\n\n"}
{"name":"Bornology.isVonNBounded_add","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâµ : NormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\ninstâœ : ContinuousAdd E\ns t : Set E\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ (HAdd.hAdd s t)) (Or (Eq s EmptyCollection.emptyCollection) (Or (Eq t EmptyCollection.emptyCollection) (And (Bornology.IsVonNBounded ğ•œ s) (Bornology.IsVonNBounded ğ•œ t))))","decl":"theorem isVonNBounded_add :\n    IsVonNBounded ğ•œ (s + t) â†” s = âˆ… âˆ¨ t = âˆ… âˆ¨ IsVonNBounded ğ•œ s âˆ§ IsVonNBounded ğ•œ t := by\n  rcases s.eq_empty_or_nonempty with rfl | hs; Â· simp\n  rcases t.eq_empty_or_nonempty with rfl | ht; Â· simp\n  simp [hs.ne_empty, ht.ne_empty, isVonNBounded_add_of_nonempty hs ht]\n\n"}
{"name":"Bornology.isVonNBounded_add_self","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâµ : NormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\ninstâœ : ContinuousAdd E\ns : Set E\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ (HAdd.hAdd s s)) (Bornology.IsVonNBounded ğ•œ s)","decl":"@[simp]\ntheorem isVonNBounded_add_self : IsVonNBounded ğ•œ (s + s) â†” IsVonNBounded ğ•œ s := by\n  rcases s.eq_empty_or_nonempty with rfl | hs <;> simp [isVonNBounded_add_of_nonempty, *]\n\n"}
{"name":"Bornology.IsVonNBounded.of_sub_left","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâµ : NormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\ninstâœ : ContinuousAdd E\ns t : Set E\nhst : Bornology.IsVonNBounded ğ•œ (HSub.hSub s t)\nht : t.Nonempty\nâŠ¢ Bornology.IsVonNBounded ğ•œ s","decl":"theorem IsVonNBounded.of_sub_left (hst : IsVonNBounded ğ•œ (s - t)) (ht : t.Nonempty) :\n    IsVonNBounded ğ•œ s :=\n  ((sub_eq_add_neg s t).subst hst).of_add_left ht.neg\n\n"}
{"name":"Bornology.IsVonNBounded.of_sub_right","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâµ : NormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\ninstâœ : TopologicalAddGroup E\ns t : Set E\nhst : Bornology.IsVonNBounded ğ•œ (HSub.hSub s t)\nhs : s.Nonempty\nâŠ¢ Bornology.IsVonNBounded ğ•œ t","decl":"theorem IsVonNBounded.of_sub_right (hst : IsVonNBounded ğ•œ (s - t)) (hs : s.Nonempty) :\n    IsVonNBounded ğ•œ t :=\n  (((sub_eq_add_neg s t).subst hst).of_add_right hs).of_neg\n\n"}
{"name":"Bornology.isVonNBounded_sub_of_nonempty","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâµ : NormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\ninstâœ : TopologicalAddGroup E\ns t : Set E\nhs : s.Nonempty\nht : t.Nonempty\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ (HSub.hSub s t)) (And (Bornology.IsVonNBounded ğ•œ s) (Bornology.IsVonNBounded ğ•œ t))","decl":"theorem isVonNBounded_sub_of_nonempty (hs : s.Nonempty) (ht : t.Nonempty) :\n    IsVonNBounded ğ•œ (s - t) â†” IsVonNBounded ğ•œ s âˆ§ IsVonNBounded ğ•œ t := by\n  simp [sub_eq_add_neg, isVonNBounded_add_of_nonempty, hs, ht]\n\n"}
{"name":"Bornology.isVonNBounded_sub","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâµ : NormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\ninstâœ : TopologicalAddGroup E\ns t : Set E\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ (HSub.hSub s t)) (Or (Eq s EmptyCollection.emptyCollection) (Or (Eq t EmptyCollection.emptyCollection) (And (Bornology.IsVonNBounded ğ•œ s) (Bornology.IsVonNBounded ğ•œ t))))","decl":"theorem isVonNBounded_sub :\n    IsVonNBounded ğ•œ (s - t) â†” s = âˆ… âˆ¨ t = âˆ… âˆ¨ IsVonNBounded ğ•œ s âˆ§ IsVonNBounded ğ•œ t := by\n  simp [sub_eq_add_neg, isVonNBounded_add]\n\n"}
{"name":"Bornology.isVonNBounded_covers","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousSMul ğ•œ E\nâŠ¢ Eq (setOf (Bornology.IsVonNBounded ğ•œ)).sUnion Set.univ","decl":"/-- The union of all bounded set is the whole space. -/\ntheorem isVonNBounded_covers : â‹ƒâ‚€ setOf (IsVonNBounded ğ•œ) = (Set.univ : Set E) :=\n  Set.eq_univ_iff_forall.mpr fun x =>\n    Set.mem_sUnion.mpr âŸ¨{x}, isVonNBounded_singleton _, Set.mem_singleton _âŸ©\n\n"}
{"name":"Bornology.isBounded_iff_isVonNBounded","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousSMul ğ•œ E\ns : Set E\nâŠ¢ Iff (Bornology.IsBounded s) (Bornology.IsVonNBounded ğ•œ s)","decl":"@[simp]\ntheorem isBounded_iff_isVonNBounded {s : Set E} :\n    @IsBounded _ (vonNBornology ğ•œ E) s â†” IsVonNBounded ğ•œ s :=\n  isBounded_ofBounded_iff _\n\n"}
{"name":"TotallyBounded.isVonNBounded","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâµ : NormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : UniformSpace E\ninstâœÂ¹ : UniformAddGroup E\ninstâœ : ContinuousSMul ğ•œ E\ns : Set E\nhs : TotallyBounded s\nâŠ¢ Bornology.IsVonNBounded ğ•œ s","decl":"theorem TotallyBounded.isVonNBounded {s : Set E} (hs : TotallyBounded s) :\n    Bornology.IsVonNBounded ğ•œ s := by\n  if h : âˆƒ x : ğ•œ, 1 < â€–xâ€– then\n    letI : NontriviallyNormedField ğ•œ := âŸ¨hâŸ©\n    rw [totallyBounded_iff_subset_finite_iUnion_nhds_zero] at hs\n    intro U hU\n    have h : Filter.Tendsto (fun x : E Ã— E => x.fst + x.snd) (ğ“ 0) (ğ“ 0) :=\n      continuous_add.tendsto' _ _ (zero_add _)\n    have h' := (nhds_basis_balanced ğ•œ E).prod (nhds_basis_balanced ğ•œ E)\n    simp_rw [â† nhds_prod_eq, id] at h'\n    rcases h.basis_left h' U hU with âŸ¨x, hx, h''âŸ©\n    rcases hs x.snd hx.2.1 with âŸ¨t, ht, hsâŸ©\n    refine Absorbs.mono_right ?_ hs\n    rw [ht.absorbs_biUnion]\n    have hx_fstsnd : x.fst + x.snd âŠ† U := add_subset_iff.mpr fun z1 hz1 z2 hz2 â†¦\n      h'' <| mk_mem_prod hz1 hz2\n    refine fun y _ => Absorbs.mono_left ?_ hx_fstsnd\n    -- TODO: with dot notation, Lean timeouts on the next line. Why?\n    exact Absorbent.vadd_absorbs (absorbent_nhds_zero hx.1.1) hx.2.2.absorbs_self\n  else\n    haveI : BoundedSpace ğ•œ := âŸ¨Metric.isBounded_iff.2 âŸ¨1, by simp_all [dist_eq_norm]âŸ©âŸ©\n    exact Bornology.IsVonNBounded.of_boundedSpace\n\n"}
{"name":"Filter.Tendsto.isVonNBounded_range","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâµ : NormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : ContinuousSMul ğ•œ E\nf : Nat â†’ E\nx : E\nhf : Filter.Tendsto f Filter.atTop (nhds x)\nâŠ¢ Bornology.IsVonNBounded ğ•œ (Set.range f)","decl":"variable (ğ•œ) in\ntheorem Filter.Tendsto.isVonNBounded_range [NormedField ğ•œ] [AddCommGroup E] [Module ğ•œ E]\n    [TopologicalSpace E] [TopologicalAddGroup E] [ContinuousSMul ğ•œ E]\n    {f : â„• â†’ E} {x : E} (hf : Tendsto f atTop (ğ“ x)) : Bornology.IsVonNBounded ğ•œ (range f) :=\n  letI := TopologicalAddGroup.toUniformSpace E\n  haveI := comm_topologicalAddGroup_is_uniform (G := E)\n  hf.cauchySeq.totallyBounded_range.isVonNBounded ğ•œ\n\n"}
{"name":"Bornology.IsVonNBounded.restrict_scalars_of_nontrivial","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\nE : Type u_3\ninstâœâ¸ : NormedField ğ•œ\ninstâœâ· : NormedRing ğ•œ'\ninstâœâ¶ : NormedAlgebra ğ•œ ğ•œ'\ninstâœâµ : Nontrivial ğ•œ'\ninstâœâ´ : Zero E\ninstâœÂ³ : TopologicalSpace E\ninstâœÂ² : SMul ğ•œ E\ninstâœÂ¹ : MulAction ğ•œ' E\ninstâœ : IsScalarTower ğ•œ ğ•œ' E\ns : Set E\nh : Bornology.IsVonNBounded ğ•œ' s\nâŠ¢ Bornology.IsVonNBounded ğ•œ s","decl":"variable (ğ•œ) in\nprotected theorem Bornology.IsVonNBounded.restrict_scalars_of_nontrivial\n    [NormedField ğ•œ] [NormedRing ğ•œ'] [NormedAlgebra ğ•œ ğ•œ'] [Nontrivial ğ•œ']\n    [Zero E] [TopologicalSpace E]\n    [SMul ğ•œ E] [MulAction ğ•œ' E] [IsScalarTower ğ•œ ğ•œ' E] {s : Set E}\n    (h : IsVonNBounded ğ•œ' s) : IsVonNBounded ğ•œ s := by\n  intro V hV\n  refine (h hV).restrict_scalars <| AntilipschitzWith.tendsto_cobounded (K := â€–(1 : ğ•œ')â€–â‚Šâ»Â¹) ?_\n  refine AntilipschitzWith.of_le_mul_nndist fun x y â†¦ ?_\n  rw [nndist_eq_nnnorm, nndist_eq_nnnorm, â† sub_smul, nnnorm_smul, â† div_eq_inv_mul,\n    mul_div_cancel_rightâ‚€ _ (nnnorm_ne_zero_iff.2 one_ne_zero)]\n\n"}
{"name":"Bornology.IsVonNBounded.restrict_scalars","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\nE : Type u_3\ninstâœâ· : NormedField ğ•œ\ninstâœâ¶ : NormedRing ğ•œ'\ninstâœâµ : NormedAlgebra ğ•œ ğ•œ'\ninstâœâ´ : Zero E\ninstâœÂ³ : TopologicalSpace E\ninstâœÂ² : SMul ğ•œ E\ninstâœÂ¹ : MulActionWithZero ğ•œ' E\ninstâœ : IsScalarTower ğ•œ ğ•œ' E\ns : Set E\nh : Bornology.IsVonNBounded ğ•œ' s\nâŠ¢ Bornology.IsVonNBounded ğ•œ s","decl":"variable (ğ•œ) in\nprotected theorem Bornology.IsVonNBounded.restrict_scalars\n    [NormedField ğ•œ] [NormedRing ğ•œ'] [NormedAlgebra ğ•œ ğ•œ']\n    [Zero E] [TopologicalSpace E]\n    [SMul ğ•œ E] [MulActionWithZero ğ•œ' E] [IsScalarTower ğ•œ ğ•œ' E] {s : Set E}\n    (h : IsVonNBounded ğ•œ' s) : IsVonNBounded ğ•œ s :=\n  match subsingleton_or_nontrivial ğ•œ' with\n  | .inl _ =>\n    have : Subsingleton E := MulActionWithZero.subsingleton ğ•œ' E\n    IsVonNBounded.of_subsingleton\n  | .inr _ =>\n    h.restrict_scalars_of_nontrivial _\n\n"}
{"name":"NormedSpace.isVonNBounded_of_isBounded","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\ns : Set E\nh : Bornology.IsBounded s\nâŠ¢ Bornology.IsVonNBounded ğ•œ s","decl":"theorem isVonNBounded_of_isBounded {s : Set E} (h : Bornology.IsBounded s) :\n    Bornology.IsVonNBounded ğ•œ s := by\n  rcases h.subset_ball 0 with âŸ¨r, hrâŸ©\n  rw [Metric.nhds_basis_ball.isVonNBounded_iff]\n  rw [â† ball_normSeminorm ğ•œ E] at hr âŠ¢\n  exact fun Îµ hÎµ â†¦ ((normSeminorm ğ•œ E).ball_zero_absorbs_ball_zero hÎµ).mono_right hr\n\n"}
{"name":"NormedSpace.isVonNBounded_ball","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nr : Real\nâŠ¢ Bornology.IsVonNBounded ğ•œ (Metric.ball 0 r)","decl":"theorem isVonNBounded_ball (r : â„) : Bornology.IsVonNBounded ğ•œ (Metric.ball (0 : E) r) :=\n  isVonNBounded_of_isBounded _ Metric.isBounded_ball\n\n"}
{"name":"NormedSpace.isVonNBounded_closedBall","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nr : Real\nâŠ¢ Bornology.IsVonNBounded ğ•œ (Metric.closedBall 0 r)","decl":"theorem isVonNBounded_closedBall (r : â„) :\n    Bornology.IsVonNBounded ğ•œ (Metric.closedBall (0 : E) r) :=\n  isVonNBounded_of_isBounded _ Metric.isBounded_closedBall\n\n"}
{"name":"NormedSpace.isVonNBounded_iff","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\ns : Set E\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ s) (Bornology.IsBounded s)","decl":"theorem isVonNBounded_iff {s : Set E} : Bornology.IsVonNBounded ğ•œ s â†” Bornology.IsBounded s := by\n  refine âŸ¨fun h â†¦ ?_, isVonNBounded_of_isBounded _âŸ©\n  rcases (h (Metric.ball_mem_nhds 0 zero_lt_one)).exists_pos with âŸ¨Ï, hÏ, hÏballâŸ©\n  rcases NormedField.exists_lt_norm ğ•œ Ï with âŸ¨a, haâŸ©\n  specialize hÏball a ha.le\n  rw [â† ball_normSeminorm ğ•œ E, Seminorm.smul_ball_zero (norm_pos_iff.1 <| hÏ.trans ha),\n    ball_normSeminorm] at hÏball\n  exact Metric.isBounded_ball.subset hÏball\n\n"}
{"name":"NormedSpace.isVonNBounded_iff'","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\ns : Set E\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ s) (Exists fun r => âˆ€ (x : E), Membership.mem s x â†’ LE.le (Norm.norm x) r)","decl":"theorem isVonNBounded_iff' {s : Set E} :\n    Bornology.IsVonNBounded ğ•œ s â†” âˆƒ r : â„, âˆ€ x âˆˆ s, â€–xâ€– â‰¤ r := by\n  rw [NormedSpace.isVonNBounded_iff, isBounded_iff_forall_norm_le]\n\n"}
{"name":"NormedSpace.image_isVonNBounded_iff","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nÎ± : Type u_6\nf : Î± â†’ E\ns : Set Î±\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ (Set.image f s)) (Exists fun r => âˆ€ (x : Î±), Membership.mem s x â†’ LE.le (Norm.norm (f x)) r)","decl":"theorem image_isVonNBounded_iff {Î± : Type*} {f : Î± â†’ E} {s : Set Î±} :\n    Bornology.IsVonNBounded ğ•œ (f '' s) â†” âˆƒ r : â„, âˆ€ x âˆˆ s, â€–f xâ€– â‰¤ r := by\n  simp_rw [isVonNBounded_iff', Set.forall_mem_image]\n\n"}
{"name":"NormedSpace.vonNBornology_eq","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nâŠ¢ Eq (Bornology.vonNBornology ğ•œ E) PseudoMetricSpace.toBornology","decl":"/-- In a normed space, the von Neumann bornology (`Bornology.vonNBornology`) is equal to the\nmetric bornology. -/\ntheorem vonNBornology_eq : Bornology.vonNBornology ğ•œ E = PseudoMetricSpace.toBornology := by\n  rw [Bornology.ext_iff_isBounded]\n  intro s\n  rw [Bornology.isBounded_iff_isVonNBounded]\n  exact isVonNBounded_iff _\n\n"}
{"name":"NormedSpace.isBounded_iff_subset_smul_ball","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\ns : Set E\nâŠ¢ Iff (Bornology.IsBounded s) (Exists fun a => HasSubset.Subset s (HSMul.hSMul a (Metric.ball 0 1)))","decl":"theorem isBounded_iff_subset_smul_ball {s : Set E} :\n    Bornology.IsBounded s â†” âˆƒ a : ğ•œ, s âŠ† a â€¢ Metric.ball (0 : E) 1 := by\n  rw [â† isVonNBounded_iff ğ•œ]\n  constructor\n  Â· intro h\n    rcases (h (Metric.ball_mem_nhds 0 zero_lt_one)).exists_pos with âŸ¨Ï, _, hÏballâŸ©\n    rcases NormedField.exists_lt_norm ğ•œ Ï with âŸ¨a, haâŸ©\n    exact âŸ¨a, hÏball a ha.leâŸ©\n  Â· rintro âŸ¨a, haâŸ©\n    exact ((isVonNBounded_ball ğ•œ E 1).image (a â€¢ (1 : E â†’L[ğ•œ] E))).subset ha\n\n"}
{"name":"NormedSpace.isBounded_iff_subset_smul_closedBall","module":"Mathlib.Analysis.LocallyConvex.Bounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\ns : Set E\nâŠ¢ Iff (Bornology.IsBounded s) (Exists fun a => HasSubset.Subset s (HSMul.hSMul a (Metric.closedBall 0 1)))","decl":"theorem isBounded_iff_subset_smul_closedBall {s : Set E} :\n    Bornology.IsBounded s â†” âˆƒ a : ğ•œ, s âŠ† a â€¢ Metric.closedBall (0 : E) 1 := by\n  constructor\n  Â· rw [isBounded_iff_subset_smul_ball ğ•œ]\n    exact Exists.imp fun a ha => ha.trans <| Set.smul_set_mono <| Metric.ball_subset_closedBall\n  Â· rw [â† isVonNBounded_iff ğ•œ]\n    rintro âŸ¨a, haâŸ©\n    exact ((isVonNBounded_closedBall ğ•œ E 1).image (a â€¢ (1 : E â†’L[ğ•œ] E))).subset ha\n\n"}
