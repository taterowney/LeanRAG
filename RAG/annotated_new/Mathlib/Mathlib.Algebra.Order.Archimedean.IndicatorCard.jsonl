{"name":"Set.sum_indicator_eventually_eq_card","module":"Mathlib.Algebra.Order.Archimedean.IndicatorCard","initialProofState":"α : Type u_1\ninst✝ : AddCommMonoid α\na : α\ns : Set Nat\nhs : s.Finite\n⊢ Filter.Eventually (fun n => Eq ((Finset.range n).sum fun k => s.indicator (fun x => a) k) (HSMul.hSMul (Nat.card ↑s) a)) Filter.atTop","decl":"lemma sum_indicator_eventually_eq_card {α : Type*} [AddCommMonoid α] (a : α) {s : Set ℕ}\n    (hs : s.Finite) :\n    ∀ᶠ n in atTop, ∑ k ∈ Finset.range n, s.indicator (fun _ ↦ a) k = (Nat.card s) • a := by\n  have key : ∀ x ∈ hs.toFinset, s.indicator (fun _ ↦ a) x = a := by\n    intro x hx\n    rw [indicator_of_mem (hs.mem_toFinset.1 hx) (fun _ ↦ a)]\n  rw [Nat.card_eq_card_finite_toFinset hs, ← sum_eq_card_nsmul key, eventually_atTop]\n  obtain ⟨m, hm⟩ := hs.bddAbove\n  refine ⟨m + 1, fun n n_m ↦ (sum_subset ?_ ?_).symm⟩ <;> intro x <;> rw [hs.mem_toFinset]\n  · rw [Finset.mem_range]\n    exact fun x_s ↦ ((mem_upperBounds.1 hm) x x_s).trans_lt (Nat.lt_of_succ_le n_m)\n  · exact fun _ x_s ↦ indicator_of_not_mem x_s (fun _ ↦ a)\n\n"}
{"name":"Set.infinite_iff_tendsto_sum_indicator_atTop","module":"Mathlib.Algebra.Order.Archimedean.IndicatorCard","initialProofState":"R : Type u_1\ninst✝² : OrderedAddCommMonoid R\ninst✝¹ : AddLeftStrictMono R\ninst✝ : Archimedean R\nr : R\nh : LT.lt 0 r\ns : Set Nat\n⊢ Iff s.Infinite (Filter.Tendsto (fun n => (Finset.range n).sum fun k => s.indicator (fun x => r) k) Filter.atTop Filter.atTop)","decl":"lemma infinite_iff_tendsto_sum_indicator_atTop {R : Type*} [OrderedAddCommMonoid R]\n    [AddLeftStrictMono R] [Archimedean R] {r : R} (h : 0 < r) {s : Set ℕ} :\n    s.Infinite ↔ atTop.Tendsto (fun n ↦ ∑ k ∈ Finset.range n, s.indicator (fun _ ↦ r) k) atTop := by\n  constructor\n  · have h_mono : Monotone fun n ↦ ∑ k ∈ Finset.range n, s.indicator (fun _ ↦ r) k := by\n      refine (sum_mono_set_of_nonneg ?_).comp range_mono\n      exact (fun _ ↦ indicator_nonneg (fun _ _ ↦ h.le) _)\n    rw [h_mono.tendsto_atTop_atTop_iff]\n    intro hs n\n    obtain ⟨n', hn'⟩ := exists_lt_nsmul h n\n    obtain ⟨t, t_s, t_card⟩ := hs.exists_subset_card_eq n'\n    obtain ⟨m, hm⟩ := t.bddAbove\n    refine ⟨m + 1, hn'.le.trans ?_⟩\n    apply (sum_le_sum fun i _ ↦ (indicator_le_indicator_of_subset t_s (fun _ ↦ h.le)) i).trans_eq'\n    have h : t ⊆ Finset.range (m + 1) := by\n      intro i i_t\n      rw [Finset.mem_range]\n      exact (hm i_t).trans_lt (lt_add_one m)\n    rw [sum_indicator_subset (fun _ ↦ r) h, sum_eq_card_nsmul (fun _ _ ↦ rfl), t_card]\n  · contrapose\n    intro hs\n    rw [not_infinite] at hs\n    rw [tendsto_congr' (sum_indicator_eventually_eq_card r hs), tendsto_atTop_atTop]\n    push_neg\n    obtain ⟨m, hm⟩ := exists_lt_nsmul h (Nat.card s • r)\n    exact ⟨m • r, fun n ↦ ⟨n, le_refl n, not_le_of_lt hm⟩⟩\n\n"}
{"name":"Set.limsup_eq_tendsto_sum_indicator_atTop","module":"Mathlib.Algebra.Order.Archimedean.IndicatorCard","initialProofState":"α : Type u_1\nR : Type u_2\ninst✝² : OrderedAddCommMonoid R\ninst✝¹ : AddLeftStrictMono R\ninst✝ : Archimedean R\nr : R\nh : LT.lt 0 r\ns : Nat → Set α\n⊢ Eq (Filter.limsup s Filter.atTop) (setOf fun ω => Filter.Tendsto (fun n => (Finset.range n).sum fun k => (s k).indicator (fun x => r) ω) Filter.atTop Filter.atTop)","decl":"lemma limsup_eq_tendsto_sum_indicator_atTop {α R : Type*} [OrderedAddCommMonoid R]\n    [AddLeftStrictMono R] [Archimedean R] {r : R} (h : 0 < r) (s : ℕ → Set α) :\n    atTop.limsup s = { ω | atTop.Tendsto\n      (fun n ↦ ∑ k ∈ Finset.range n, (s k).indicator (fun _ ↦ r) ω) atTop } := by\n  nth_rw 1 [← Nat.cofinite_eq_atTop, cofinite.limsup_set_eq]\n  ext ω\n  rw [mem_setOf_eq, mem_setOf_eq, infinite_iff_tendsto_sum_indicator_atTop h, iff_eq_eq]\n  congr\n\n"}
