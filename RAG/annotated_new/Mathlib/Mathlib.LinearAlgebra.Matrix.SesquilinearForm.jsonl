{"name":"Matrix.toLinearMap₂'Aux_single","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R₁ : Type u_2\nS₁ : Type u_3\nR₂ : Type u_4\nS₂ : Type u_5\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝¹¹ : Semiring R₁\ninst✝¹⁰ : Semiring S₁\ninst✝⁹ : Semiring R₂\ninst✝⁸ : Semiring S₂\ninst✝⁷ : AddCommMonoid N₂\ninst✝⁶ : Module S₁ N₂\ninst✝⁵ : Module S₂ N₂\ninst✝⁴ : SMulCommClass S₂ S₁ N₂\ninst✝³ : Fintype n\ninst✝² : Fintype m\nσ₁ : RingHom R₁ S₁\nσ₂ : RingHom R₂ S₂\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq m\nf : Matrix n m N₂\ni : n\nj : m\n⊢ Eq (((Matrix.toLinearMap₂'Aux σ₁ σ₂ f) (Pi.single i 1)) (Pi.single j 1)) (f i j)","decl":"theorem Matrix.toLinearMap₂'Aux_single (f : Matrix n m N₂) (i : n) (j : m) :\n    f.toLinearMap₂'Aux σ₁ σ₂ (Pi.single i 1) (Pi.single j 1) = f i j := by\n  rw [Matrix.toLinearMap₂'Aux, mk₂'ₛₗ_apply]\n  have : (∑ i', ∑ j', (if i = i' then (1 : S₁) else (0 : S₁)) •\n        (if j = j' then (1 : S₂) else (0 : S₂)) • f i' j') =\n      f i j := by\n    simp_rw [← Finset.smul_sum]\n    simp only [op_smul_eq_smul, ite_smul, one_smul, zero_smul, sum_ite_eq, mem_univ, ↓reduceIte]\n  rw [← this]\n  exact Finset.sum_congr rfl fun _ _ => Finset.sum_congr rfl fun _ _ => by aesop\n\n"}
{"name":"LinearMap.toMatrix₂Aux_apply","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nS₁ : Type u_3\nR₂ : Type u_4\nS₂ : Type u_5\nM₁ : Type u_6\nM₂ : Type u_7\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝¹⁵ : CommSemiring R\ninst✝¹⁴ : Semiring R₁\ninst✝¹³ : Semiring S₁\ninst✝¹² : Semiring R₂\ninst✝¹¹ : Semiring S₂\ninst✝¹⁰ : AddCommMonoid M₁\ninst✝⁹ : Module R₁ M₁\ninst✝⁸ : AddCommMonoid M₂\ninst✝⁷ : Module R₂ M₂\ninst✝⁶ : AddCommMonoid N₂\ninst✝⁵ : Module R N₂\ninst✝⁴ : Module S₁ N₂\ninst✝³ : Module S₂ N₂\ninst✝² : SMulCommClass S₁ R N₂\ninst✝¹ : SMulCommClass S₂ R N₂\ninst✝ : SMulCommClass S₂ S₁ N₂\nσ₁ : RingHom R₁ S₁\nσ₂ : RingHom R₂ S₂\nf : LinearMap σ₁ M₁ (LinearMap σ₂ M₂ N₂)\nb₁ : n → M₁\nb₂ : m → M₂\ni : n\nj : m\n⊢ Eq ((LinearMap.toMatrix₂Aux R b₁ b₂) f i j) ((f (b₁ i)) (b₂ j))","decl":"@[simp]\ntheorem LinearMap.toMatrix₂Aux_apply (f : M₁ →ₛₗ[σ₁] M₂ →ₛₗ[σ₂] N₂) (b₁ : n → M₁) (b₂ : m → M₂)\n    (i : n) (j : m) : LinearMap.toMatrix₂Aux R b₁ b₂ f i j = f (b₁ i) (b₂ j) :=\n  rfl\n\n"}
{"name":"LinearMap.toLinearMap₂'Aux_toMatrix₂Aux","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nS₁ : Type u_3\nR₂ : Type u_4\nS₂ : Type u_5\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝¹⁵ : CommSemiring R\ninst✝¹⁴ : Semiring R₁\ninst✝¹³ : Semiring S₁\ninst✝¹² : Semiring R₂\ninst✝¹¹ : Semiring S₂\ninst✝¹⁰ : AddCommMonoid N₂\ninst✝⁹ : Module R N₂\ninst✝⁸ : Module S₁ N₂\ninst✝⁷ : Module S₂ N₂\ninst✝⁶ : SMulCommClass S₁ R N₂\ninst✝⁵ : SMulCommClass S₂ R N₂\ninst✝⁴ : SMulCommClass S₂ S₁ N₂\nσ₁ : RingHom R₁ S₁\nσ₂ : RingHom R₂ S₂\ninst✝³ : Fintype n\ninst✝² : Fintype m\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq m\nf : LinearMap σ₁ (n → R₁) (LinearMap σ₂ (m → R₂) N₂)\n⊢ Eq (Matrix.toLinearMap₂'Aux σ₁ σ₂ ((LinearMap.toMatrix₂Aux R (fun i => Pi.single i 1) fun j => Pi.single j 1) f)) f","decl":"theorem LinearMap.toLinearMap₂'Aux_toMatrix₂Aux (f : (n → R₁) →ₛₗ[σ₁] (m → R₂) →ₛₗ[σ₂] N₂) :\n    Matrix.toLinearMap₂'Aux σ₁ σ₂\n        (LinearMap.toMatrix₂Aux R (fun i => Pi.single i 1) (fun j => Pi.single j 1) f) =\n      f := by\n  refine ext_basis (Pi.basisFun R₁ n) (Pi.basisFun R₂ m) fun i j => ?_\n  simp_rw [Pi.basisFun_apply, Matrix.toLinearMap₂'Aux_single, LinearMap.toMatrix₂Aux_apply]\n\n"}
{"name":"Matrix.toMatrix₂Aux_toLinearMap₂'Aux","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nS₁ : Type u_3\nR₂ : Type u_4\nS₂ : Type u_5\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝¹⁵ : CommSemiring R\ninst✝¹⁴ : Semiring R₁\ninst✝¹³ : Semiring S₁\ninst✝¹² : Semiring R₂\ninst✝¹¹ : Semiring S₂\ninst✝¹⁰ : AddCommMonoid N₂\ninst✝⁹ : Module R N₂\ninst✝⁸ : Module S₁ N₂\ninst✝⁷ : Module S₂ N₂\ninst✝⁶ : SMulCommClass S₁ R N₂\ninst✝⁵ : SMulCommClass S₂ R N₂\ninst✝⁴ : SMulCommClass S₂ S₁ N₂\nσ₁ : RingHom R₁ S₁\nσ₂ : RingHom R₂ S₂\ninst✝³ : Fintype n\ninst✝² : Fintype m\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq m\nf : Matrix n m N₂\n⊢ Eq ((LinearMap.toMatrix₂Aux R (fun i => Pi.single i 1) fun j => Pi.single j 1) (Matrix.toLinearMap₂'Aux σ₁ σ₂ f)) f","decl":"theorem Matrix.toMatrix₂Aux_toLinearMap₂'Aux (f : Matrix n m N₂) :\n    LinearMap.toMatrix₂Aux R (fun i => Pi.single i 1)\n        (fun j => Pi.single j 1) (f.toLinearMap₂'Aux σ₁ σ₂) =\n      f := by\n  ext i j\n  simp_rw [LinearMap.toMatrix₂Aux_apply, Matrix.toLinearMap₂'Aux_single]\n\n"}
{"name":"Matrix.toLinearMapₛₗ₂'_aux_eq","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nS₁ : Type u_3\nR₂ : Type u_4\nS₂ : Type u_5\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝¹⁵ : CommSemiring R\ninst✝¹⁴ : AddCommMonoid N₂\ninst✝¹³ : Module R N₂\ninst✝¹² : Semiring R₁\ninst✝¹¹ : Semiring R₂\ninst✝¹⁰ : Semiring S₁\ninst✝⁹ : Semiring S₂\ninst✝⁸ : Module S₁ N₂\ninst✝⁷ : Module S₂ N₂\ninst✝⁶ : SMulCommClass S₁ R N₂\ninst✝⁵ : SMulCommClass S₂ R N₂\ninst✝⁴ : SMulCommClass S₂ S₁ N₂\nσ₁ : RingHom R₁ S₁\nσ₂ : RingHom R₂ S₂\ninst✝³ : Fintype n\ninst✝² : Fintype m\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq m\nM : Matrix n m N₂\n⊢ Eq (Matrix.toLinearMap₂'Aux σ₁ σ₂ M) ((Matrix.toLinearMapₛₗ₂' R σ₁ σ₂) M)","decl":"theorem Matrix.toLinearMapₛₗ₂'_aux_eq (M : Matrix n m N₂) :\n    Matrix.toLinearMap₂'Aux σ₁ σ₂ M = Matrix.toLinearMapₛₗ₂' R σ₁ σ₂ M :=\n  rfl\n\n"}
{"name":"Matrix.toLinearMapₛₗ₂'_apply","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nS₁ : Type u_3\nR₂ : Type u_4\nS₂ : Type u_5\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝¹⁵ : CommSemiring R\ninst✝¹⁴ : AddCommMonoid N₂\ninst✝¹³ : Module R N₂\ninst✝¹² : Semiring R₁\ninst✝¹¹ : Semiring R₂\ninst✝¹⁰ : Semiring S₁\ninst✝⁹ : Semiring S₂\ninst✝⁸ : Module S₁ N₂\ninst✝⁷ : Module S₂ N₂\ninst✝⁶ : SMulCommClass S₁ R N₂\ninst✝⁵ : SMulCommClass S₂ R N₂\ninst✝⁴ : SMulCommClass S₂ S₁ N₂\nσ₁ : RingHom R₁ S₁\nσ₂ : RingHom R₂ S₂\ninst✝³ : Fintype n\ninst✝² : Fintype m\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq m\nM : Matrix n m N₂\nx : n → R₁\ny : m → R₂\n⊢ Eq ((((Matrix.toLinearMapₛₗ₂' R σ₁ σ₂) M) x) y) (Finset.univ.sum fun i => Finset.univ.sum fun j => HSMul.hSMul (σ₁ (x i)) (HSMul.hSMul (σ₂ (y j)) (M i j)))","decl":"theorem Matrix.toLinearMapₛₗ₂'_apply (M : Matrix n m N₂) (x : n → R₁) (y : m → R₂) :\n    -- porting note: we don't seem to have `∑ i j` as valid notation yet\n    Matrix.toLinearMapₛₗ₂' R σ₁ σ₂ M x y = ∑ i, ∑ j, σ₁ (x i) •  σ₂ (y j) • M i j := by\n  rw [toLinearMapₛₗ₂', toMatrixₛₗ₂', LinearEquiv.coe_symm_mk, toLinearMap₂'Aux, mk₂'ₛₗ_apply]\n  apply Finset.sum_congr rfl fun _ _ => Finset.sum_congr rfl fun _ _ => by\n    rw [smul_comm]\n\n"}
{"name":"Matrix.toLinearMap₂'_apply","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nS₁ : Type u_3\nS₂ : Type u_5\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝¹³ : CommSemiring R\ninst✝¹² : AddCommMonoid N₂\ninst✝¹¹ : Module R N₂\ninst✝¹⁰ : Semiring S₁\ninst✝⁹ : Semiring S₂\ninst✝⁸ : Module S₁ N₂\ninst✝⁷ : Module S₂ N₂\ninst✝⁶ : SMulCommClass S₁ R N₂\ninst✝⁵ : SMulCommClass S₂ R N₂\ninst✝⁴ : SMulCommClass S₂ S₁ N₂\ninst✝³ : Fintype n\ninst✝² : Fintype m\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq m\nM : Matrix n m N₂\nx : n → S₁\ny : m → S₂\n⊢ Eq ((((Matrix.toLinearMap₂' R) M) x) y) (Finset.univ.sum fun i => Finset.univ.sum fun j => HSMul.hSMul (x i) (HSMul.hSMul (y j) (M i j)))","decl":"theorem Matrix.toLinearMap₂'_apply (M : Matrix n m N₂) (x : n → S₁) (y : m → S₂) :\n    -- porting note: we don't seem to have `∑ i j` as valid notation yet\n    Matrix.toLinearMap₂' R M x y = ∑ i, ∑ j, x i • y j • M i j :=\n  Finset.sum_congr rfl fun _ _ => Finset.sum_congr rfl fun _ _ => by\n    rw [RingHom.id_apply, RingHom.id_apply, smul_comm]\n\n"}
{"name":"Matrix.toLinearMap₂'_apply'","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"n : Type u_11\nm : Type u_12\ninst✝⁴ : Fintype n\ninst✝³ : Fintype m\ninst✝² : DecidableEq n\ninst✝¹ : DecidableEq m\nT : Type u_16\ninst✝ : CommSemiring T\nM : Matrix n m T\nv : n → T\nw : m → T\n⊢ Eq ((((Matrix.toLinearMap₂' T) M) v) w) (dotProduct v (M.mulVec w))","decl":"theorem Matrix.toLinearMap₂'_apply' {T : Type*} [CommSemiring T] (M : Matrix n m T) (v : n → T)\n    (w : m → T) : Matrix.toLinearMap₂' T M v w = dotProduct v (M *ᵥ w) := by\n  simp_rw [Matrix.toLinearMap₂'_apply, dotProduct, Matrix.mulVec, dotProduct]\n  refine Finset.sum_congr rfl fun _ _ => ?_\n  rw [Finset.mul_sum]\n  refine Finset.sum_congr rfl fun _ _ => ?_\n  rw [smul_eq_mul, smul_eq_mul, mul_comm (w _), ← mul_assoc]\n\n"}
{"name":"Matrix.toLinearMapₛₗ₂'_single","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nS₁ : Type u_3\nR₂ : Type u_4\nS₂ : Type u_5\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝¹⁵ : CommSemiring R\ninst✝¹⁴ : AddCommMonoid N₂\ninst✝¹³ : Module R N₂\ninst✝¹² : Semiring R₁\ninst✝¹¹ : Semiring R₂\ninst✝¹⁰ : Semiring S₁\ninst✝⁹ : Semiring S₂\ninst✝⁸ : Module S₁ N₂\ninst✝⁷ : Module S₂ N₂\ninst✝⁶ : SMulCommClass S₁ R N₂\ninst✝⁵ : SMulCommClass S₂ R N₂\ninst✝⁴ : SMulCommClass S₂ S₁ N₂\nσ₁ : RingHom R₁ S₁\nσ₂ : RingHom R₂ S₂\ninst✝³ : Fintype n\ninst✝² : Fintype m\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq m\nM : Matrix n m N₂\ni : n\nj : m\n⊢ Eq ((((Matrix.toLinearMapₛₗ₂' R σ₁ σ₂) M) (Pi.single i 1)) (Pi.single j 1)) (M i j)","decl":"@[simp]\ntheorem Matrix.toLinearMapₛₗ₂'_single (M : Matrix n m N₂) (i : n) (j : m) :\n    Matrix.toLinearMapₛₗ₂' R σ₁ σ₂ M (Pi.single i 1) (Pi.single j 1) = M i j :=\n  Matrix.toLinearMap₂'Aux_single σ₁ σ₂ M i j\n\n"}
{"name":"Matrix.toLinearMapₛₗ₂'_stdBasis","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nS₁ : Type u_3\nR₂ : Type u_4\nS₂ : Type u_5\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝¹⁵ : CommSemiring R\ninst✝¹⁴ : AddCommMonoid N₂\ninst✝¹³ : Module R N₂\ninst✝¹² : Semiring R₁\ninst✝¹¹ : Semiring R₂\ninst✝¹⁰ : Semiring S₁\ninst✝⁹ : Semiring S₂\ninst✝⁸ : Module S₁ N₂\ninst✝⁷ : Module S₂ N₂\ninst✝⁶ : SMulCommClass S₁ R N₂\ninst✝⁵ : SMulCommClass S₂ R N₂\ninst✝⁴ : SMulCommClass S₂ S₁ N₂\nσ₁ : RingHom R₁ S₁\nσ₂ : RingHom R₂ S₂\ninst✝³ : Fintype n\ninst✝² : Fintype m\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq m\nM : Matrix n m N₂\ni : n\nj : m\n⊢ Eq ((((Matrix.toLinearMapₛₗ₂' R σ₁ σ₂) M) ((LinearMap.stdBasis R₁ (fun x => R₁) i) 1)) ((LinearMap.stdBasis R₂ (fun x => R₂) j) 1)) (M i j)","decl":"set_option linter.deprecated false in\n@[simp, deprecated Matrix.toLinearMapₛₗ₂'_single (since := \"2024-08-09\")]\ntheorem Matrix.toLinearMapₛₗ₂'_stdBasis (M : Matrix n m N₂) (i : n) (j : m) :\n    Matrix.toLinearMapₛₗ₂' R σ₁ σ₂ M (LinearMap.stdBasis R₁ (fun _ => R₁) i 1)\n      (LinearMap.stdBasis R₂ (fun _ => R₂) j 1) = M i j :=\n  Matrix.toLinearMapₛₗ₂'_single ..\n\n"}
{"name":"Matrix.toLinearMap₂'_single","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid N₂\ninst✝⁴ : Module R N₂\ninst✝³ : Fintype n\ninst✝² : Fintype m\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq m\nM : Matrix n m N₂\ni : n\nj : m\n⊢ Eq ((((Matrix.toLinearMap₂' R) M) (Pi.single i 1)) (Pi.single j 1)) (M i j)","decl":"@[simp]\ntheorem Matrix.toLinearMap₂'_single (M : Matrix n m N₂) (i : n) (j : m) :\n    Matrix.toLinearMap₂' R M (Pi.single i 1) (Pi.single j 1) = M i j :=\n  Matrix.toLinearMap₂'Aux_single _ _ M i j\n\n"}
{"name":"Matrix.toLinearMap₂'_stdBasis","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid N₂\ninst✝⁴ : Module R N₂\ninst✝³ : Fintype n\ninst✝² : Fintype m\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq m\nM : Matrix n m N₂\ni : n\nj : m\n⊢ Eq ((((Matrix.toLinearMap₂' R) M) ((LinearMap.stdBasis R (fun x => R) i) 1)) ((LinearMap.stdBasis R (fun x => R) j) 1)) (M i j)","decl":"set_option linter.deprecated false in\n@[simp, deprecated Matrix.toLinearMap₂'_single (since := \"2024-08-09\")]\ntheorem Matrix.toLinearMap₂'_stdBasis (M : Matrix n m N₂) (i : n) (j : m) :\n    Matrix.toLinearMap₂' R M (LinearMap.stdBasis R (fun _ => R) i 1)\n      (LinearMap.stdBasis R (fun _ => R) j 1) = M i j :=\n  show Matrix.toLinearMap₂' R M (Pi.single i 1) (Pi.single j 1) = M i j\n  from Matrix.toLinearMap₂'Aux_single _ _ M i j\n\n"}
{"name":"LinearMap.toMatrixₛₗ₂'_symm","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nS₁ : Type u_3\nR₂ : Type u_4\nS₂ : Type u_5\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝¹⁵ : CommSemiring R\ninst✝¹⁴ : AddCommMonoid N₂\ninst✝¹³ : Module R N₂\ninst✝¹² : Semiring R₁\ninst✝¹¹ : Semiring R₂\ninst✝¹⁰ : Semiring S₁\ninst✝⁹ : Semiring S₂\ninst✝⁸ : Module S₁ N₂\ninst✝⁷ : Module S₂ N₂\ninst✝⁶ : SMulCommClass S₁ R N₂\ninst✝⁵ : SMulCommClass S₂ R N₂\ninst✝⁴ : SMulCommClass S₂ S₁ N₂\nσ₁ : RingHom R₁ S₁\nσ₂ : RingHom R₂ S₂\ninst✝³ : Fintype n\ninst✝² : Fintype m\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq m\n⊢ Eq (LinearMap.toMatrixₛₗ₂' R).symm (Matrix.toLinearMapₛₗ₂' R σ₁ σ₂)","decl":"@[simp]\ntheorem LinearMap.toMatrixₛₗ₂'_symm :\n    ((LinearMap.toMatrixₛₗ₂' R).symm : Matrix n m N₂ ≃ₗ[R] _) = Matrix.toLinearMapₛₗ₂' R σ₁ σ₂ :=\n  rfl\n\n"}
{"name":"Matrix.toLinearMapₛₗ₂'_symm","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nS₁ : Type u_3\nR₂ : Type u_4\nS₂ : Type u_5\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝¹⁵ : CommSemiring R\ninst✝¹⁴ : AddCommMonoid N₂\ninst✝¹³ : Module R N₂\ninst✝¹² : Semiring R₁\ninst✝¹¹ : Semiring R₂\ninst✝¹⁰ : Semiring S₁\ninst✝⁹ : Semiring S₂\ninst✝⁸ : Module S₁ N₂\ninst✝⁷ : Module S₂ N₂\ninst✝⁶ : SMulCommClass S₁ R N₂\ninst✝⁵ : SMulCommClass S₂ R N₂\ninst✝⁴ : SMulCommClass S₂ S₁ N₂\nσ₁ : RingHom R₁ S₁\nσ₂ : RingHom R₂ S₂\ninst✝³ : Fintype n\ninst✝² : Fintype m\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq m\n⊢ Eq (Matrix.toLinearMapₛₗ₂' R σ₁ σ₂).symm (LinearMap.toMatrixₛₗ₂' R)","decl":"@[simp]\ntheorem Matrix.toLinearMapₛₗ₂'_symm :\n    ((Matrix.toLinearMapₛₗ₂' R σ₁ σ₂).symm : _ ≃ₗ[R] Matrix n m N₂) = LinearMap.toMatrixₛₗ₂' R :=\n  (LinearMap.toMatrixₛₗ₂' R).symm_symm\n\n"}
{"name":"Matrix.toLinearMapₛₗ₂'_toMatrix'","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nS₁ : Type u_3\nR₂ : Type u_4\nS₂ : Type u_5\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝¹⁵ : CommSemiring R\ninst✝¹⁴ : AddCommMonoid N₂\ninst✝¹³ : Module R N₂\ninst✝¹² : Semiring R₁\ninst✝¹¹ : Semiring R₂\ninst✝¹⁰ : Semiring S₁\ninst✝⁹ : Semiring S₂\ninst✝⁸ : Module S₁ N₂\ninst✝⁷ : Module S₂ N₂\ninst✝⁶ : SMulCommClass S₁ R N₂\ninst✝⁵ : SMulCommClass S₂ R N₂\ninst✝⁴ : SMulCommClass S₂ S₁ N₂\nσ₁ : RingHom R₁ S₁\nσ₂ : RingHom R₂ S₂\ninst✝³ : Fintype n\ninst✝² : Fintype m\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq m\nB : LinearMap σ₁ (n → R₁) (LinearMap σ₂ (m → R₂) N₂)\n⊢ Eq ((Matrix.toLinearMapₛₗ₂' R σ₁ σ₂) ((LinearMap.toMatrixₛₗ₂' R) B)) B","decl":"@[simp]\ntheorem Matrix.toLinearMapₛₗ₂'_toMatrix' (B : (n → R₁) →ₛₗ[σ₁] (m → R₂) →ₛₗ[σ₂] N₂) :\n    Matrix.toLinearMapₛₗ₂' R σ₁ σ₂ (LinearMap.toMatrixₛₗ₂' R B) = B :=\n  (Matrix.toLinearMapₛₗ₂' R σ₁ σ₂).apply_symm_apply B\n\n"}
{"name":"Matrix.toLinearMap₂'_toMatrix'","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nS₁ : Type u_3\nS₂ : Type u_5\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝¹³ : CommSemiring R\ninst✝¹² : AddCommMonoid N₂\ninst✝¹¹ : Module R N₂\ninst✝¹⁰ : Semiring S₁\ninst✝⁹ : Semiring S₂\ninst✝⁸ : Module S₁ N₂\ninst✝⁷ : Module S₂ N₂\ninst✝⁶ : SMulCommClass S₁ R N₂\ninst✝⁵ : SMulCommClass S₂ R N₂\ninst✝⁴ : SMulCommClass S₂ S₁ N₂\ninst✝³ : Fintype n\ninst✝² : Fintype m\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq m\nB : LinearMap (RingHom.id S₁) (n → S₁) (LinearMap (RingHom.id S₂) (m → S₂) N₂)\n⊢ Eq ((Matrix.toLinearMap₂' R) ((LinearMap.toMatrix₂' R) B)) B","decl":"@[simp]\ntheorem Matrix.toLinearMap₂'_toMatrix' (B : (n → S₁) →ₗ[S₁] (m → S₂) →ₗ[S₂] N₂) :\n    Matrix.toLinearMap₂' R (LinearMap.toMatrix₂' R B) = B :=\n  (Matrix.toLinearMap₂' R).apply_symm_apply B\n\n"}
{"name":"LinearMap.toMatrix'_toLinearMapₛₗ₂'","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nS₁ : Type u_3\nR₂ : Type u_4\nS₂ : Type u_5\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝¹⁵ : CommSemiring R\ninst✝¹⁴ : AddCommMonoid N₂\ninst✝¹³ : Module R N₂\ninst✝¹² : Semiring R₁\ninst✝¹¹ : Semiring R₂\ninst✝¹⁰ : Semiring S₁\ninst✝⁹ : Semiring S₂\ninst✝⁸ : Module S₁ N₂\ninst✝⁷ : Module S₂ N₂\ninst✝⁶ : SMulCommClass S₁ R N₂\ninst✝⁵ : SMulCommClass S₂ R N₂\ninst✝⁴ : SMulCommClass S₂ S₁ N₂\nσ₁ : RingHom R₁ S₁\nσ₂ : RingHom R₂ S₂\ninst✝³ : Fintype n\ninst✝² : Fintype m\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq m\nM : Matrix n m N₂\n⊢ Eq ((LinearMap.toMatrixₛₗ₂' R) ((Matrix.toLinearMapₛₗ₂' R σ₁ σ₂) M)) M","decl":"@[simp]\ntheorem LinearMap.toMatrix'_toLinearMapₛₗ₂' (M : Matrix n m N₂) :\n    LinearMap.toMatrixₛₗ₂' R (Matrix.toLinearMapₛₗ₂' R σ₁ σ₂ M) = M :=\n  (LinearMap.toMatrixₛₗ₂' R).apply_symm_apply M\n\n"}
{"name":"LinearMap.toMatrix'_toLinearMap₂'","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nS₁ : Type u_3\nS₂ : Type u_5\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝¹³ : CommSemiring R\ninst✝¹² : AddCommMonoid N₂\ninst✝¹¹ : Module R N₂\ninst✝¹⁰ : Semiring S₁\ninst✝⁹ : Semiring S₂\ninst✝⁸ : Module S₁ N₂\ninst✝⁷ : Module S₂ N₂\ninst✝⁶ : SMulCommClass S₁ R N₂\ninst✝⁵ : SMulCommClass S₂ R N₂\ninst✝⁴ : SMulCommClass S₂ S₁ N₂\ninst✝³ : Fintype n\ninst✝² : Fintype m\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq m\nM : Matrix n m N₂\n⊢ Eq ((LinearMap.toMatrix₂' R) ((Matrix.toLinearMap₂' R) M)) M","decl":"@[simp]\ntheorem LinearMap.toMatrix'_toLinearMap₂' (M : Matrix n m N₂) :\n    LinearMap.toMatrix₂' R (Matrix.toLinearMap₂' R (S₁ := S₁) (S₂ := S₂) M) = M :=\n  (LinearMap.toMatrixₛₗ₂' R).apply_symm_apply M\n\n"}
{"name":"LinearMap.toMatrixₛₗ₂'_apply","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nS₁ : Type u_3\nR₂ : Type u_4\nS₂ : Type u_5\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝¹⁵ : CommSemiring R\ninst✝¹⁴ : AddCommMonoid N₂\ninst✝¹³ : Module R N₂\ninst✝¹² : Semiring R₁\ninst✝¹¹ : Semiring R₂\ninst✝¹⁰ : Semiring S₁\ninst✝⁹ : Semiring S₂\ninst✝⁸ : Module S₁ N₂\ninst✝⁷ : Module S₂ N₂\ninst✝⁶ : SMulCommClass S₁ R N₂\ninst✝⁵ : SMulCommClass S₂ R N₂\ninst✝⁴ : SMulCommClass S₂ S₁ N₂\nσ₁ : RingHom R₁ S₁\nσ₂ : RingHom R₂ S₂\ninst✝³ : Fintype n\ninst✝² : Fintype m\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq m\nB : LinearMap σ₁ (n → R₁) (LinearMap σ₂ (m → R₂) N₂)\ni : n\nj : m\n⊢ Eq ((LinearMap.toMatrixₛₗ₂' R) B i j) ((B (Pi.single i 1)) (Pi.single j 1))","decl":"@[simp]\ntheorem LinearMap.toMatrixₛₗ₂'_apply (B : (n → R₁) →ₛₗ[σ₁] (m → R₂) →ₛₗ[σ₂] N₂) (i : n) (j : m) :\n    LinearMap.toMatrixₛₗ₂' R B i j = B (Pi.single i 1) (Pi.single j 1) :=\n  rfl\n\n"}
{"name":"LinearMap.toMatrix₂'_apply","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nS₁ : Type u_3\nS₂ : Type u_5\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝¹³ : CommSemiring R\ninst✝¹² : AddCommMonoid N₂\ninst✝¹¹ : Module R N₂\ninst✝¹⁰ : Semiring S₁\ninst✝⁹ : Semiring S₂\ninst✝⁸ : Module S₁ N₂\ninst✝⁷ : Module S₂ N₂\ninst✝⁶ : SMulCommClass S₁ R N₂\ninst✝⁵ : SMulCommClass S₂ R N₂\ninst✝⁴ : SMulCommClass S₂ S₁ N₂\ninst✝³ : Fintype n\ninst✝² : Fintype m\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq m\nB : LinearMap (RingHom.id S₁) (n → S₁) (LinearMap (RingHom.id S₂) (m → S₂) N₂)\ni : n\nj : m\n⊢ Eq ((LinearMap.toMatrix₂' R) B i j) ((B (Pi.single i 1)) (Pi.single j 1))","decl":"@[simp]\ntheorem LinearMap.toMatrix₂'_apply (B : (n → S₁) →ₗ[S₁] (m → S₂) →ₗ[S₂] N₂) (i : n) (j : m) :\n    LinearMap.toMatrix₂' R B i j = B (Pi.single i 1) (Pi.single j 1) :=\n  rfl\n\n"}
{"name":"LinearMap.toMatrix₂'_compl₁₂","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"n : Type u_11\nm : Type u_12\nn' : Type u_13\nm' : Type u_14\nR : Type u_16\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Fintype n\ninst✝⁶ : Fintype m\ninst✝⁵ : DecidableEq n\ninst✝⁴ : DecidableEq m\ninst✝³ : Fintype n'\ninst✝² : Fintype m'\ninst✝¹ : DecidableEq n'\ninst✝ : DecidableEq m'\nB : LinearMap (RingHom.id R) (n → R) (LinearMap (RingHom.id R) (m → R) R)\nl : LinearMap (RingHom.id R) (n' → R) (n → R)\nr : LinearMap (RingHom.id R) (m' → R) (m → R)\n⊢ Eq ((LinearMap.toMatrix₂' R) (B.compl₁₂ l r)) (HMul.hMul (HMul.hMul (LinearMap.toMatrix' l).transpose ((LinearMap.toMatrix₂' R) B)) (LinearMap.toMatrix' r))","decl":"@[simp]\ntheorem LinearMap.toMatrix₂'_compl₁₂ (B : (n → R) →ₗ[R] (m → R) →ₗ[R] R) (l : (n' → R) →ₗ[R] n → R)\n    (r : (m' → R) →ₗ[R] m → R) :\n    toMatrix₂' R (B.compl₁₂ l r) = (toMatrix' l)ᵀ * toMatrix₂' R B * toMatrix' r := by\n  ext i j\n  simp only [LinearMap.toMatrix₂'_apply, LinearMap.compl₁₂_apply, transpose_apply, Matrix.mul_apply,\n    LinearMap.toMatrix', LinearEquiv.coe_mk, sum_mul]\n  rw [sum_comm]\n  conv_lhs => rw [← LinearMap.sum_repr_mul_repr_mul (Pi.basisFun R n) (Pi.basisFun R m) (l _) (r _)]\n  rw [Finsupp.sum_fintype]\n  · apply sum_congr rfl\n    rintro i' -\n    rw [Finsupp.sum_fintype]\n    · apply sum_congr rfl\n      rintro j' -\n      simp only [smul_eq_mul, Pi.basisFun_repr, mul_assoc, mul_comm, mul_left_comm,\n        Pi.basisFun_apply, of_apply]\n    · intros\n      simp only [zero_smul, smul_zero]\n  · intros\n    simp only [zero_smul, Finsupp.sum_zero]\n\n"}
{"name":"LinearMap.toMatrix₂'_comp","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"n : Type u_11\nm : Type u_12\nn' : Type u_13\nR : Type u_16\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Fintype n\ninst✝⁴ : Fintype m\ninst✝³ : DecidableEq n\ninst✝² : DecidableEq m\ninst✝¹ : Fintype n'\ninst✝ : DecidableEq n'\nB : LinearMap (RingHom.id R) (n → R) (LinearMap (RingHom.id R) (m → R) R)\nf : LinearMap (RingHom.id R) (n' → R) (n → R)\n⊢ Eq ((LinearMap.toMatrix₂' R) (B.comp f)) (HMul.hMul (LinearMap.toMatrix' f).transpose ((LinearMap.toMatrix₂' R) B))","decl":"theorem LinearMap.toMatrix₂'_comp (B : (n → R) →ₗ[R] (m → R) →ₗ[R] R) (f : (n' → R) →ₗ[R] n → R) :\n    toMatrix₂' R (B.comp f) = (toMatrix' f)ᵀ * toMatrix₂' R B := by\n  rw [← LinearMap.compl₂_id (B.comp f), ← LinearMap.compl₁₂]\n  simp\n\n"}
{"name":"LinearMap.toMatrix₂'_compl₂","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"n : Type u_11\nm : Type u_12\nm' : Type u_14\nR : Type u_16\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Fintype n\ninst✝⁴ : Fintype m\ninst✝³ : DecidableEq n\ninst✝² : DecidableEq m\ninst✝¹ : Fintype m'\ninst✝ : DecidableEq m'\nB : LinearMap (RingHom.id R) (n → R) (LinearMap (RingHom.id R) (m → R) R)\nf : LinearMap (RingHom.id R) (m' → R) (m → R)\n⊢ Eq ((LinearMap.toMatrix₂' R) (B.compl₂ f)) (HMul.hMul ((LinearMap.toMatrix₂' R) B) (LinearMap.toMatrix' f))","decl":"theorem LinearMap.toMatrix₂'_compl₂ (B : (n → R) →ₗ[R] (m → R) →ₗ[R] R) (f : (m' → R) →ₗ[R] m → R) :\n    toMatrix₂' R (B.compl₂ f) = toMatrix₂' R B * toMatrix' f := by\n  rw [← LinearMap.comp_id B, ← LinearMap.compl₁₂]\n  simp\n\n"}
{"name":"LinearMap.mul_toMatrix₂'_mul","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"n : Type u_11\nm : Type u_12\nn' : Type u_13\nm' : Type u_14\nR : Type u_16\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Fintype n\ninst✝⁶ : Fintype m\ninst✝⁵ : DecidableEq n\ninst✝⁴ : DecidableEq m\ninst✝³ : Fintype n'\ninst✝² : Fintype m'\ninst✝¹ : DecidableEq n'\ninst✝ : DecidableEq m'\nB : LinearMap (RingHom.id R) (n → R) (LinearMap (RingHom.id R) (m → R) R)\nM : Matrix n' n R\nN : Matrix m m' R\n⊢ Eq (HMul.hMul (HMul.hMul M ((LinearMap.toMatrix₂' R) B)) N) ((LinearMap.toMatrix₂' R) (B.compl₁₂ (Matrix.toLin' M.transpose) (Matrix.toLin' N)))","decl":"theorem LinearMap.mul_toMatrix₂'_mul (B : (n → R) →ₗ[R] (m → R) →ₗ[R] R) (M : Matrix n' n R)\n    (N : Matrix m m' R) :\n    M * toMatrix₂' R B * N = toMatrix₂' R (B.compl₁₂ (toLin' Mᵀ) (toLin' N)) := by\n  simp\n\n"}
{"name":"LinearMap.mul_toMatrix'","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"n : Type u_11\nm : Type u_12\nn' : Type u_13\nR : Type u_16\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Fintype n\ninst✝⁴ : Fintype m\ninst✝³ : DecidableEq n\ninst✝² : DecidableEq m\ninst✝¹ : Fintype n'\ninst✝ : DecidableEq n'\nB : LinearMap (RingHom.id R) (n → R) (LinearMap (RingHom.id R) (m → R) R)\nM : Matrix n' n R\n⊢ Eq (HMul.hMul M ((LinearMap.toMatrix₂' R) B)) ((LinearMap.toMatrix₂' R) (B.comp (Matrix.toLin' M.transpose)))","decl":"theorem LinearMap.mul_toMatrix' (B : (n → R) →ₗ[R] (m → R) →ₗ[R] R) (M : Matrix n' n R) :\n    M * toMatrix₂' R B = toMatrix₂' R (B.comp <| toLin' Mᵀ) := by\n  simp only [B.toMatrix₂'_comp, transpose_transpose, toMatrix'_toLin']\n\n"}
{"name":"LinearMap.toMatrix₂'_mul","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"n : Type u_11\nm : Type u_12\nm' : Type u_14\nR : Type u_16\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Fintype n\ninst✝⁴ : Fintype m\ninst✝³ : DecidableEq n\ninst✝² : DecidableEq m\ninst✝¹ : Fintype m'\ninst✝ : DecidableEq m'\nB : LinearMap (RingHom.id R) (n → R) (LinearMap (RingHom.id R) (m → R) R)\nM : Matrix m m' R\n⊢ Eq (HMul.hMul ((LinearMap.toMatrix₂' R) B) M) ((LinearMap.toMatrix₂' R) (B.compl₂ (Matrix.toLin' M)))","decl":"theorem LinearMap.toMatrix₂'_mul (B : (n → R) →ₗ[R] (m → R) →ₗ[R] R) (M : Matrix m m' R) :\n    toMatrix₂' R B * M = toMatrix₂' R (B.compl₂ <| toLin' M) := by\n  simp only [B.toMatrix₂'_compl₂, toMatrix'_toLin']\n\n"}
{"name":"Matrix.toLinearMap₂'_comp","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"n : Type u_11\nm : Type u_12\nn' : Type u_13\nm' : Type u_14\nR : Type u_16\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Fintype n\ninst✝⁶ : Fintype m\ninst✝⁵ : DecidableEq n\ninst✝⁴ : DecidableEq m\ninst✝³ : Fintype n'\ninst✝² : Fintype m'\ninst✝¹ : DecidableEq n'\ninst✝ : DecidableEq m'\nM : Matrix n m R\nP : Matrix n n' R\nQ : Matrix m m' R\n⊢ Eq (((Matrix.toLinearMap₂' R) M).compl₁₂ (Matrix.toLin' P) (Matrix.toLin' Q)) ((Matrix.toLinearMap₂' R) (HMul.hMul (HMul.hMul P.transpose M) Q))","decl":"theorem Matrix.toLinearMap₂'_comp (M : Matrix n m R) (P : Matrix n n' R) (Q : Matrix m m' R) :\n    LinearMap.compl₁₂ (Matrix.toLinearMap₂' R M) (toLin' P) (toLin' Q) =\n      toLinearMap₂' R (Pᵀ * M * Q) :=\n  (LinearMap.toMatrix₂' R).injective (by simp)\n\n"}
{"name":"LinearMap.toMatrix₂_apply","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nM₁ : Type u_6\nM₂ : Type u_7\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M₁\ninst✝⁸ : Module R M₁\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : Module R M₂\ninst✝⁵ : AddCommMonoid N₂\ninst✝⁴ : Module R N₂\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\ninst✝¹ : DecidableEq m\ninst✝ : Fintype m\nb₁ : Basis n R M₁\nb₂ : Basis m R M₂\nB : LinearMap (RingHom.id R) M₁ (LinearMap (RingHom.id R) M₂ N₂)\ni : n\nj : m\n⊢ Eq ((LinearMap.toMatrix₂ b₁ b₂) B i j) ((B (b₁ i)) (b₂ j))","decl":"@[simp]\ntheorem LinearMap.toMatrix₂_apply (B : M₁ →ₗ[R] M₂ →ₗ[R] N₂) (i : n) (j : m) :\n    LinearMap.toMatrix₂ b₁ b₂ B i j = B (b₁ i) (b₂ j) := by\n  simp only [toMatrix₂, LinearEquiv.trans_apply, toMatrix₂'_apply, LinearEquiv.arrowCongr_apply,\n    Basis.equivFun_symm_apply, Pi.single_apply, ite_smul, one_smul, zero_smul, sum_ite_eq',\n    mem_univ, ↓reduceIte, LinearEquiv.refl_apply]\n\n"}
{"name":"Matrix.toLinearMap₂_apply","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nM₁ : Type u_6\nM₂ : Type u_7\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M₁\ninst✝⁸ : Module R M₁\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : Module R M₂\ninst✝⁵ : AddCommMonoid N₂\ninst✝⁴ : Module R N₂\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\ninst✝¹ : DecidableEq m\ninst✝ : Fintype m\nb₁ : Basis n R M₁\nb₂ : Basis m R M₂\nM : Matrix n m N₂\nx : M₁\ny : M₂\n⊢ Eq ((((Matrix.toLinearMap₂ b₁ b₂) M) x) y) (Finset.univ.sum fun i => Finset.univ.sum fun j => HSMul.hSMul ((b₁.repr x) i) (HSMul.hSMul ((b₂.repr y) j) (M i j)))","decl":"@[simp]\ntheorem Matrix.toLinearMap₂_apply (M : Matrix n m N₂) (x : M₁) (y : M₂) :\n    Matrix.toLinearMap₂ b₁ b₂ M x y = ∑ i, ∑ j, b₁.repr x i • b₂.repr y j • M i j :=\n  Finset.sum_congr rfl fun _ _ => Finset.sum_congr rfl fun _ _ =>\n    smul_algebra_smul_comm ((RingHom.id R) ((Basis.equivFun b₁) x _))\n    ((RingHom.id R) ((Basis.equivFun b₂) y _)) (M _ _)\n\n-- Not a `simp` lemma since `LinearMap.toMatrix₂` needs an extra argument\n"}
{"name":"LinearMap.toMatrix₂Aux_eq","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nM₁ : Type u_6\nM₂ : Type u_7\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M₁\ninst✝⁸ : Module R M₁\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : Module R M₂\ninst✝⁵ : AddCommMonoid N₂\ninst✝⁴ : Module R N₂\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\ninst✝¹ : DecidableEq m\ninst✝ : Fintype m\nb₁ : Basis n R M₁\nb₂ : Basis m R M₂\nB : LinearMap (RingHom.id R) M₁ (LinearMap (RingHom.id R) M₂ N₂)\n⊢ Eq ((LinearMap.toMatrix₂Aux R ⇑b₁ ⇑b₂) B) ((LinearMap.toMatrix₂ b₁ b₂) B)","decl":"theorem LinearMap.toMatrix₂Aux_eq (B : M₁ →ₗ[R] M₂ →ₗ[R] N₂) :\n    LinearMap.toMatrix₂Aux R b₁ b₂ B = LinearMap.toMatrix₂ b₁ b₂ B :=\n  Matrix.ext fun i j => by rw [LinearMap.toMatrix₂_apply, LinearMap.toMatrix₂Aux_apply]\n\n"}
{"name":"LinearMap.toMatrix₂_symm","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nM₁ : Type u_6\nM₂ : Type u_7\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M₁\ninst✝⁸ : Module R M₁\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : Module R M₂\ninst✝⁵ : AddCommMonoid N₂\ninst✝⁴ : Module R N₂\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\ninst✝¹ : DecidableEq m\ninst✝ : Fintype m\nb₁ : Basis n R M₁\nb₂ : Basis m R M₂\n⊢ Eq (LinearMap.toMatrix₂ b₁ b₂).symm (Matrix.toLinearMap₂ b₁ b₂)","decl":"@[simp]\ntheorem LinearMap.toMatrix₂_symm :\n    (LinearMap.toMatrix₂ b₁ b₂).symm = Matrix.toLinearMap₂ (N₂ := N₂) b₁ b₂ :=\n  rfl\n\n"}
{"name":"Matrix.toLinearMap₂_symm","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nM₁ : Type u_6\nM₂ : Type u_7\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M₁\ninst✝⁸ : Module R M₁\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : Module R M₂\ninst✝⁵ : AddCommMonoid N₂\ninst✝⁴ : Module R N₂\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\ninst✝¹ : DecidableEq m\ninst✝ : Fintype m\nb₁ : Basis n R M₁\nb₂ : Basis m R M₂\n⊢ Eq (Matrix.toLinearMap₂ b₁ b₂).symm (LinearMap.toMatrix₂ b₁ b₂)","decl":"@[simp]\ntheorem Matrix.toLinearMap₂_symm :\n    (Matrix.toLinearMap₂ b₁ b₂).symm = LinearMap.toMatrix₂ (N₂ := N₂) b₁ b₂ :=\n  (LinearMap.toMatrix₂ b₁ b₂).symm_symm\n\n"}
{"name":"Matrix.toLinearMap₂_basisFun","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid N₂\ninst✝⁴ : Module R N₂\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\ninst✝¹ : DecidableEq m\ninst✝ : Fintype m\n⊢ Eq (Matrix.toLinearMap₂ (Pi.basisFun R n) (Pi.basisFun R m)) (Matrix.toLinearMap₂' R)","decl":"theorem Matrix.toLinearMap₂_basisFun :\n    Matrix.toLinearMap₂ (Pi.basisFun R n) (Pi.basisFun R m) =\n      Matrix.toLinearMap₂' R (N₂ := N₂) := by\n  ext M\n  simp only [coe_comp, coe_single, Function.comp_apply, toLinearMap₂_apply, Pi.basisFun_repr,\n    toLinearMap₂'_apply]\n\n"}
{"name":"LinearMap.toMatrix₂_basisFun","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid N₂\ninst✝⁴ : Module R N₂\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\ninst✝¹ : DecidableEq m\ninst✝ : Fintype m\n⊢ Eq (LinearMap.toMatrix₂ (Pi.basisFun R n) (Pi.basisFun R m)) (LinearMap.toMatrix₂' R)","decl":"theorem LinearMap.toMatrix₂_basisFun :\n    LinearMap.toMatrix₂ (Pi.basisFun R n) (Pi.basisFun R m) =\n    LinearMap.toMatrix₂' R (N₂ := N₂) := by\n  ext B\n  rw [LinearMap.toMatrix₂_apply, LinearMap.toMatrix₂'_apply, Pi.basisFun_apply, Pi.basisFun_apply]\n\n"}
{"name":"Matrix.toLinearMap₂_toMatrix₂","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nM₁ : Type u_6\nM₂ : Type u_7\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M₁\ninst✝⁸ : Module R M₁\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : Module R M₂\ninst✝⁵ : AddCommMonoid N₂\ninst✝⁴ : Module R N₂\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\ninst✝¹ : DecidableEq m\ninst✝ : Fintype m\nb₁ : Basis n R M₁\nb₂ : Basis m R M₂\nB : LinearMap (RingHom.id R) M₁ (LinearMap (RingHom.id R) M₂ N₂)\n⊢ Eq ((Matrix.toLinearMap₂ b₁ b₂) ((LinearMap.toMatrix₂ b₁ b₂) B)) B","decl":"@[simp]\ntheorem Matrix.toLinearMap₂_toMatrix₂ (B : M₁ →ₗ[R] M₂ →ₗ[R] N₂) :\n    Matrix.toLinearMap₂ b₁ b₂ (LinearMap.toMatrix₂ b₁ b₂ B) = B :=\n  (Matrix.toLinearMap₂ b₁ b₂).apply_symm_apply B\n\n"}
{"name":"LinearMap.toMatrix₂_toLinearMap₂","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nM₁ : Type u_6\nM₂ : Type u_7\nN₂ : Type u_10\nn : Type u_11\nm : Type u_12\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M₁\ninst✝⁸ : Module R M₁\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : Module R M₂\ninst✝⁵ : AddCommMonoid N₂\ninst✝⁴ : Module R N₂\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\ninst✝¹ : DecidableEq m\ninst✝ : Fintype m\nb₁ : Basis n R M₁\nb₂ : Basis m R M₂\nM : Matrix n m N₂\n⊢ Eq ((LinearMap.toMatrix₂ b₁ b₂) ((Matrix.toLinearMap₂ b₁ b₂) M)) M","decl":"@[simp]\ntheorem LinearMap.toMatrix₂_toLinearMap₂ (M : Matrix n m N₂) :\n    LinearMap.toMatrix₂ b₁ b₂ (Matrix.toLinearMap₂ b₁ b₂ M) = M :=\n  (LinearMap.toMatrix₂ b₁ b₂).apply_symm_apply M\n\n"}
{"name":"LinearMap.toMatrix₂_compl₁₂","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nM₁ : Type u_6\nM₂ : Type u_7\nM₁' : Type u_8\nM₂' : Type u_9\nn : Type u_11\nm : Type u_12\nn' : Type u_13\nm' : Type u_14\ninst✝¹⁶ : CommSemiring R\ninst✝¹⁵ : AddCommMonoid M₁\ninst✝¹⁴ : Module R M₁\ninst✝¹³ : AddCommMonoid M₂\ninst✝¹² : Module R M₂\ninst✝¹¹ : DecidableEq n\ninst✝¹⁰ : Fintype n\ninst✝⁹ : DecidableEq m\ninst✝⁸ : Fintype m\nb₁ : Basis n R M₁\nb₂ : Basis m R M₂\ninst✝⁷ : AddCommMonoid M₁'\ninst✝⁶ : Module R M₁'\ninst✝⁵ : AddCommMonoid M₂'\ninst✝⁴ : Module R M₂'\nb₁' : Basis n' R M₁'\nb₂' : Basis m' R M₂'\ninst✝³ : Fintype n'\ninst✝² : Fintype m'\ninst✝¹ : DecidableEq n'\ninst✝ : DecidableEq m'\nB : LinearMap (RingHom.id R) M₁ (LinearMap (RingHom.id R) M₂ R)\nl : LinearMap (RingHom.id R) M₁' M₁\nr : LinearMap (RingHom.id R) M₂' M₂\n⊢ Eq ((LinearMap.toMatrix₂ b₁' b₂') (B.compl₁₂ l r)) (HMul.hMul (HMul.hMul ((LinearMap.toMatrix b₁' b₁) l).transpose ((LinearMap.toMatrix₂ b₁ b₂) B)) ((LinearMap.toMatrix b₂' b₂) r))","decl":"theorem LinearMap.toMatrix₂_compl₁₂ (B : M₁ →ₗ[R] M₂ →ₗ[R] R) (l : M₁' →ₗ[R] M₁)\n    (r : M₂' →ₗ[R] M₂) :\n    LinearMap.toMatrix₂ b₁' b₂' (B.compl₁₂ l r) =\n      (toMatrix b₁' b₁ l)ᵀ * LinearMap.toMatrix₂ b₁ b₂ B * toMatrix b₂' b₂ r := by\n  ext i j\n  simp only [LinearMap.toMatrix₂_apply, compl₁₂_apply, transpose_apply, Matrix.mul_apply,\n    LinearMap.toMatrix_apply, LinearEquiv.coe_mk, sum_mul]\n  rw [sum_comm]\n  conv_lhs => rw [← LinearMap.sum_repr_mul_repr_mul b₁ b₂]\n  rw [Finsupp.sum_fintype]\n  · apply sum_congr rfl\n    rintro i' -\n    rw [Finsupp.sum_fintype]\n    · apply sum_congr rfl\n      rintro j' -\n      simp only [smul_eq_mul, LinearMap.toMatrix_apply, Basis.equivFun_apply, mul_assoc, mul_comm,\n        mul_left_comm]\n    · intros\n      simp only [zero_smul, smul_zero]\n  · intros\n    simp only [zero_smul, Finsupp.sum_zero]\n\n"}
{"name":"LinearMap.toMatrix₂_comp","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nM₁ : Type u_6\nM₂ : Type u_7\nM₁' : Type u_8\nn : Type u_11\nm : Type u_12\nn' : Type u_13\ninst✝¹² : CommSemiring R\ninst✝¹¹ : AddCommMonoid M₁\ninst✝¹⁰ : Module R M₁\ninst✝⁹ : AddCommMonoid M₂\ninst✝⁸ : Module R M₂\ninst✝⁷ : DecidableEq n\ninst✝⁶ : Fintype n\ninst✝⁵ : DecidableEq m\ninst✝⁴ : Fintype m\nb₁ : Basis n R M₁\nb₂ : Basis m R M₂\ninst✝³ : AddCommMonoid M₁'\ninst✝² : Module R M₁'\nb₁' : Basis n' R M₁'\ninst✝¹ : Fintype n'\ninst✝ : DecidableEq n'\nB : LinearMap (RingHom.id R) M₁ (LinearMap (RingHom.id R) M₂ R)\nf : LinearMap (RingHom.id R) M₁' M₁\n⊢ Eq ((LinearMap.toMatrix₂ b₁' b₂) (B.comp f)) (HMul.hMul ((LinearMap.toMatrix b₁' b₁) f).transpose ((LinearMap.toMatrix₂ b₁ b₂) B))","decl":"theorem LinearMap.toMatrix₂_comp (B : M₁ →ₗ[R] M₂ →ₗ[R] R) (f : M₁' →ₗ[R] M₁) :\n    LinearMap.toMatrix₂ b₁' b₂ (B.comp f) =\n      (toMatrix b₁' b₁ f)ᵀ * LinearMap.toMatrix₂ b₁ b₂ B := by\n  rw [← LinearMap.compl₂_id (B.comp f), ← LinearMap.compl₁₂, LinearMap.toMatrix₂_compl₁₂ b₁ b₂]\n  simp\n\n"}
{"name":"LinearMap.toMatrix₂_compl₂","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nM₁ : Type u_6\nM₂ : Type u_7\nM₂' : Type u_9\nn : Type u_11\nm : Type u_12\nm' : Type u_14\ninst✝¹² : CommSemiring R\ninst✝¹¹ : AddCommMonoid M₁\ninst✝¹⁰ : Module R M₁\ninst✝⁹ : AddCommMonoid M₂\ninst✝⁸ : Module R M₂\ninst✝⁷ : DecidableEq n\ninst✝⁶ : Fintype n\ninst✝⁵ : DecidableEq m\ninst✝⁴ : Fintype m\nb₁ : Basis n R M₁\nb₂ : Basis m R M₂\ninst✝³ : AddCommMonoid M₂'\ninst✝² : Module R M₂'\nb₂' : Basis m' R M₂'\ninst✝¹ : Fintype m'\ninst✝ : DecidableEq m'\nB : LinearMap (RingHom.id R) M₁ (LinearMap (RingHom.id R) M₂ R)\nf : LinearMap (RingHom.id R) M₂' M₂\n⊢ Eq ((LinearMap.toMatrix₂ b₁ b₂') (B.compl₂ f)) (HMul.hMul ((LinearMap.toMatrix₂ b₁ b₂) B) ((LinearMap.toMatrix b₂' b₂) f))","decl":"theorem LinearMap.toMatrix₂_compl₂ (B : M₁ →ₗ[R] M₂ →ₗ[R] R) (f : M₂' →ₗ[R] M₂) :\n    LinearMap.toMatrix₂ b₁ b₂' (B.compl₂ f) =\n      LinearMap.toMatrix₂ b₁ b₂ B * toMatrix b₂' b₂ f := by\n  rw [← LinearMap.comp_id B, ← LinearMap.compl₁₂, LinearMap.toMatrix₂_compl₁₂ b₁ b₂]\n  simp\n\n"}
{"name":"LinearMap.toMatrix₂_mul_basis_toMatrix","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nM₁ : Type u_6\nM₂ : Type u_7\nn : Type u_11\nm : Type u_12\nn' : Type u_13\nm' : Type u_14\ninst✝¹² : CommSemiring R\ninst✝¹¹ : AddCommMonoid M₁\ninst✝¹⁰ : Module R M₁\ninst✝⁹ : AddCommMonoid M₂\ninst✝⁸ : Module R M₂\ninst✝⁷ : DecidableEq n\ninst✝⁶ : Fintype n\ninst✝⁵ : DecidableEq m\ninst✝⁴ : Fintype m\nb₁ : Basis n R M₁\nb₂ : Basis m R M₂\ninst✝³ : Fintype n'\ninst✝² : Fintype m'\ninst✝¹ : DecidableEq n'\ninst✝ : DecidableEq m'\nc₁ : Basis n' R M₁\nc₂ : Basis m' R M₂\nB : LinearMap (RingHom.id R) M₁ (LinearMap (RingHom.id R) M₂ R)\n⊢ Eq (HMul.hMul (HMul.hMul (b₁.toMatrix ⇑c₁).transpose ((LinearMap.toMatrix₂ b₁ b₂) B)) (b₂.toMatrix ⇑c₂)) ((LinearMap.toMatrix₂ c₁ c₂) B)","decl":"@[simp]\ntheorem LinearMap.toMatrix₂_mul_basis_toMatrix (c₁ : Basis n' R M₁) (c₂ : Basis m' R M₂)\n    (B : M₁ →ₗ[R] M₂ →ₗ[R] R) :\n    (b₁.toMatrix c₁)ᵀ * LinearMap.toMatrix₂ b₁ b₂ B * b₂.toMatrix c₂ =\n      LinearMap.toMatrix₂ c₁ c₂ B := by\n  simp_rw [← LinearMap.toMatrix_id_eq_basis_toMatrix]\n  rw [← LinearMap.toMatrix₂_compl₁₂, LinearMap.compl₁₂_id_id]\n\n"}
{"name":"LinearMap.mul_toMatrix₂_mul","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nM₁ : Type u_6\nM₂ : Type u_7\nM₁' : Type u_8\nM₂' : Type u_9\nn : Type u_11\nm : Type u_12\nn' : Type u_13\nm' : Type u_14\ninst✝¹⁶ : CommSemiring R\ninst✝¹⁵ : AddCommMonoid M₁\ninst✝¹⁴ : Module R M₁\ninst✝¹³ : AddCommMonoid M₂\ninst✝¹² : Module R M₂\ninst✝¹¹ : DecidableEq n\ninst✝¹⁰ : Fintype n\ninst✝⁹ : DecidableEq m\ninst✝⁸ : Fintype m\nb₁ : Basis n R M₁\nb₂ : Basis m R M₂\ninst✝⁷ : AddCommMonoid M₁'\ninst✝⁶ : Module R M₁'\ninst✝⁵ : AddCommMonoid M₂'\ninst✝⁴ : Module R M₂'\nb₁' : Basis n' R M₁'\nb₂' : Basis m' R M₂'\ninst✝³ : Fintype n'\ninst✝² : Fintype m'\ninst✝¹ : DecidableEq n'\ninst✝ : DecidableEq m'\nB : LinearMap (RingHom.id R) M₁ (LinearMap (RingHom.id R) M₂ R)\nM : Matrix n' n R\nN : Matrix m m' R\n⊢ Eq (HMul.hMul (HMul.hMul M ((LinearMap.toMatrix₂ b₁ b₂) B)) N) ((LinearMap.toMatrix₂ b₁' b₂') (B.compl₁₂ ((Matrix.toLin b₁' b₁) M.transpose) ((Matrix.toLin b₂' b₂) N)))","decl":"theorem LinearMap.mul_toMatrix₂_mul (B : M₁ →ₗ[R] M₂ →ₗ[R] R) (M : Matrix n' n R)\n    (N : Matrix m m' R) :\n    M * LinearMap.toMatrix₂ b₁ b₂ B * N =\n      LinearMap.toMatrix₂ b₁' b₂' (B.compl₁₂ (toLin b₁' b₁ Mᵀ) (toLin b₂' b₂ N)) := by\n  simp_rw [LinearMap.toMatrix₂_compl₁₂ b₁ b₂, toMatrix_toLin, transpose_transpose]\n\n"}
{"name":"LinearMap.mul_toMatrix₂","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nM₁ : Type u_6\nM₂ : Type u_7\nM₁' : Type u_8\nn : Type u_11\nm : Type u_12\nn' : Type u_13\ninst✝¹² : CommSemiring R\ninst✝¹¹ : AddCommMonoid M₁\ninst✝¹⁰ : Module R M₁\ninst✝⁹ : AddCommMonoid M₂\ninst✝⁸ : Module R M₂\ninst✝⁷ : DecidableEq n\ninst✝⁶ : Fintype n\ninst✝⁵ : DecidableEq m\ninst✝⁴ : Fintype m\nb₁ : Basis n R M₁\nb₂ : Basis m R M₂\ninst✝³ : AddCommMonoid M₁'\ninst✝² : Module R M₁'\nb₁' : Basis n' R M₁'\ninst✝¹ : Fintype n'\ninst✝ : DecidableEq n'\nB : LinearMap (RingHom.id R) M₁ (LinearMap (RingHom.id R) M₂ R)\nM : Matrix n' n R\n⊢ Eq (HMul.hMul M ((LinearMap.toMatrix₂ b₁ b₂) B)) ((LinearMap.toMatrix₂ b₁' b₂) (B.comp ((Matrix.toLin b₁' b₁) M.transpose)))","decl":"theorem LinearMap.mul_toMatrix₂ (B : M₁ →ₗ[R] M₂ →ₗ[R] R) (M : Matrix n' n R) :\n    M * LinearMap.toMatrix₂ b₁ b₂ B =\n      LinearMap.toMatrix₂ b₁' b₂ (B.comp (toLin b₁' b₁ Mᵀ)) := by\n  rw [LinearMap.toMatrix₂_comp b₁, toMatrix_toLin, transpose_transpose]\n\n"}
{"name":"LinearMap.toMatrix₂_mul","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nM₁ : Type u_6\nM₂ : Type u_7\nM₂' : Type u_9\nn : Type u_11\nm : Type u_12\nm' : Type u_14\ninst✝¹² : CommSemiring R\ninst✝¹¹ : AddCommMonoid M₁\ninst✝¹⁰ : Module R M₁\ninst✝⁹ : AddCommMonoid M₂\ninst✝⁸ : Module R M₂\ninst✝⁷ : DecidableEq n\ninst✝⁶ : Fintype n\ninst✝⁵ : DecidableEq m\ninst✝⁴ : Fintype m\nb₁ : Basis n R M₁\nb₂ : Basis m R M₂\ninst✝³ : AddCommMonoid M₂'\ninst✝² : Module R M₂'\nb₂' : Basis m' R M₂'\ninst✝¹ : Fintype m'\ninst✝ : DecidableEq m'\nB : LinearMap (RingHom.id R) M₁ (LinearMap (RingHom.id R) M₂ R)\nM : Matrix m m' R\n⊢ Eq (HMul.hMul ((LinearMap.toMatrix₂ b₁ b₂) B) M) ((LinearMap.toMatrix₂ b₁ b₂') (B.compl₂ ((Matrix.toLin b₂' b₂) M)))","decl":"theorem LinearMap.toMatrix₂_mul (B : M₁ →ₗ[R] M₂ →ₗ[R] R) (M : Matrix m m' R) :\n    LinearMap.toMatrix₂ b₁ b₂ B * M =\n      LinearMap.toMatrix₂ b₁ b₂' (B.compl₂ (toLin b₂' b₂ M)) := by\n  rw [LinearMap.toMatrix₂_compl₂ b₁ b₂, toMatrix_toLin]\n\n"}
{"name":"Matrix.toLinearMap₂_compl₁₂","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nM₁ : Type u_6\nM₂ : Type u_7\nM₁' : Type u_8\nM₂' : Type u_9\nn : Type u_11\nm : Type u_12\nn' : Type u_13\nm' : Type u_14\ninst✝¹⁶ : CommSemiring R\ninst✝¹⁵ : AddCommMonoid M₁\ninst✝¹⁴ : Module R M₁\ninst✝¹³ : AddCommMonoid M₂\ninst✝¹² : Module R M₂\ninst✝¹¹ : DecidableEq n\ninst✝¹⁰ : Fintype n\ninst✝⁹ : DecidableEq m\ninst✝⁸ : Fintype m\nb₁ : Basis n R M₁\nb₂ : Basis m R M₂\ninst✝⁷ : AddCommMonoid M₁'\ninst✝⁶ : Module R M₁'\ninst✝⁵ : AddCommMonoid M₂'\ninst✝⁴ : Module R M₂'\nb₁' : Basis n' R M₁'\nb₂' : Basis m' R M₂'\ninst✝³ : Fintype n'\ninst✝² : Fintype m'\ninst✝¹ : DecidableEq n'\ninst✝ : DecidableEq m'\nM : Matrix n m R\nP : Matrix n n' R\nQ : Matrix m m' R\n⊢ Eq (((Matrix.toLinearMap₂ b₁ b₂) M).compl₁₂ ((Matrix.toLin b₁' b₁) P) ((Matrix.toLin b₂' b₂) Q)) ((Matrix.toLinearMap₂ b₁' b₂') (HMul.hMul (HMul.hMul P.transpose M) Q))","decl":"theorem Matrix.toLinearMap₂_compl₁₂ (M : Matrix n m R) (P : Matrix n n' R) (Q : Matrix m m' R) :\n    (Matrix.toLinearMap₂ b₁ b₂ M).compl₁₂ (toLin b₁' b₁ P) (toLin b₂' b₂ Q) =\n      Matrix.toLinearMap₂ b₁' b₂' (Pᵀ * M * Q) :=\n  (LinearMap.toMatrix₂ b₁' b₂').injective\n    (by\n      simp only [LinearMap.toMatrix₂_compl₁₂ b₁ b₂, LinearMap.toMatrix₂_toLinearMap₂,\n        toMatrix_toLin])\n\n"}
{"name":"isAdjointPair_toLinearMap₂'","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nn : Type u_11\nn' : Type u_13\ninst✝⁴ : CommRing R\ninst✝³ : Fintype n\ninst✝² : Fintype n'\nJ : Matrix n n R\nJ' : Matrix n' n' R\nA : Matrix n' n R\nA' : Matrix n n' R\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq n'\n⊢ Iff (((Matrix.toLinearMap₂' R) J).IsAdjointPair ((Matrix.toLinearMap₂' R) J') ⇑(Matrix.toLin' A) ⇑(Matrix.toLin' A')) (J.IsAdjointPair J' A A')","decl":"@[simp]\ntheorem isAdjointPair_toLinearMap₂' :\n    LinearMap.IsAdjointPair (Matrix.toLinearMap₂' R J) (Matrix.toLinearMap₂' R J')\n        (Matrix.toLin' A) (Matrix.toLin' A') ↔\n      Matrix.IsAdjointPair J J' A A' := by\n  rw [isAdjointPair_iff_comp_eq_compl₂]\n  have h :\n    ∀ B B' : (n → R) →ₗ[R] (n' → R) →ₗ[R] R,\n      B = B' ↔ LinearMap.toMatrix₂' R B = LinearMap.toMatrix₂' R B' := by\n    intro B B'\n    constructor <;> intro h\n    · rw [h]\n    · exact (LinearMap.toMatrix₂' R).injective h\n  simp_rw [h, LinearMap.toMatrix₂'_comp, LinearMap.toMatrix₂'_compl₂,\n    LinearMap.toMatrix'_toLin', LinearMap.toMatrix'_toLinearMap₂']\n  rfl\n\n"}
{"name":"isAdjointPair_toLinearMap₂","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nM₁ : Type u_6\nM₂ : Type u_7\nn : Type u_11\nn' : Type u_13\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommMonoid M₁\ninst✝⁶ : Module R M₁\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M₂\ninst✝³ : Fintype n\ninst✝² : Fintype n'\nb₁ : Basis n R M₁\nb₂ : Basis n' R M₂\nJ : Matrix n n R\nJ' : Matrix n' n' R\nA : Matrix n' n R\nA' : Matrix n n' R\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq n'\n⊢ Iff (((Matrix.toLinearMap₂ b₁ b₁) J).IsAdjointPair ((Matrix.toLinearMap₂ b₂ b₂) J') ⇑((Matrix.toLin b₁ b₂) A) ⇑((Matrix.toLin b₂ b₁) A')) (J.IsAdjointPair J' A A')","decl":"@[simp]\ntheorem isAdjointPair_toLinearMap₂ :\n    LinearMap.IsAdjointPair (Matrix.toLinearMap₂ b₁ b₁ J)\n      (Matrix.toLinearMap₂ b₂ b₂ J') (Matrix.toLin b₁ b₂ A) (Matrix.toLin b₂ b₁ A') ↔\n      Matrix.IsAdjointPair J J' A A' := by\n  rw [isAdjointPair_iff_comp_eq_compl₂]\n  have h :\n    ∀ B B' : M₁ →ₗ[R] M₂ →ₗ[R] R,\n      B = B' ↔ LinearMap.toMatrix₂ b₁ b₂ B = LinearMap.toMatrix₂ b₁ b₂ B' := by\n    intro B B'\n    constructor <;> intro h\n    · rw [h]\n    · exact (LinearMap.toMatrix₂ b₁ b₂).injective h\n  simp_rw [h, LinearMap.toMatrix₂_comp b₂ b₂, LinearMap.toMatrix₂_compl₂ b₁ b₁,\n    LinearMap.toMatrix_toLin, LinearMap.toMatrix₂_toLinearMap₂]\n  rfl\n\n"}
{"name":"Matrix.isAdjointPair_equiv","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nn : Type u_11\ninst✝² : CommRing R\ninst✝¹ : Fintype n\nJ A₁ A₂ : Matrix n n R\ninst✝ : DecidableEq n\nP : Matrix n n R\nh : IsUnit P\n⊢ Iff ((HMul.hMul (HMul.hMul P.transpose J) P).IsAdjointPair (HMul.hMul (HMul.hMul P.transpose J) P) A₁ A₂) (J.IsAdjointPair J (HMul.hMul (HMul.hMul P A₁) (Inv.inv P)) (HMul.hMul (HMul.hMul P A₂) (Inv.inv P)))","decl":"theorem Matrix.isAdjointPair_equiv (P : Matrix n n R) (h : IsUnit P) :\n    (Pᵀ * J * P).IsAdjointPair (Pᵀ * J * P) A₁ A₂ ↔\n      J.IsAdjointPair J (P * A₁ * P⁻¹) (P * A₂ * P⁻¹) := by\n  have h' : IsUnit P.det := P.isUnit_iff_isUnit_det.mp h\n  let u := P.nonsingInvUnit h'\n  let v := Pᵀ.nonsingInvUnit (P.isUnit_det_transpose h')\n  let x := A₁ᵀ * Pᵀ * J\n  let y := J * P * A₂\n  suffices x * u = v * y ↔ v⁻¹ * x = y * u⁻¹ by\n    dsimp only [Matrix.IsAdjointPair]\n    simp only [Matrix.transpose_mul]\n    simp only [← mul_assoc, P.transpose_nonsing_inv]\n    convert this using 2\n    · rw [mul_assoc, mul_assoc, ← mul_assoc J]\n      rfl\n    · rw [mul_assoc, mul_assoc, ← mul_assoc _ _ J]\n      rfl\n  rw [Units.eq_mul_inv_iff_mul_eq]\n  conv_rhs => rw [mul_assoc]\n  rw [v.inv_mul_eq_iff_eq_mul]\n\n"}
{"name":"mem_pairSelfAdjointMatricesSubmodule","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nn : Type u_11\ninst✝² : CommRing R\ninst✝¹ : Fintype n\nJ J₂ A₁ : Matrix n n R\ninst✝ : DecidableEq n\n⊢ Iff (Membership.mem (pairSelfAdjointMatricesSubmodule J J₂) A₁) (J.IsAdjointPair J₂ A₁ A₁)","decl":"@[simp]\ntheorem mem_pairSelfAdjointMatricesSubmodule :\n    A₁ ∈ pairSelfAdjointMatricesSubmodule J J₂ ↔ Matrix.IsAdjointPair J J₂ A₁ A₁ := by\n  simp only [pairSelfAdjointMatricesSubmodule, LinearEquiv.coe_coe, LinearMap.toMatrix'_apply,\n    Submodule.mem_map, mem_isPairSelfAdjointSubmodule]\n  constructor\n  · rintro ⟨f, hf, hA⟩\n    have hf' : f = toLin' A₁ := by rw [← hA, Matrix.toLin'_toMatrix']\n    rw [hf'] at hf\n    rw [← isAdjointPair_toLinearMap₂']\n    exact hf\n  · intro h\n    refine ⟨toLin' A₁, ?_, LinearMap.toMatrix'_toLin' _⟩\n    exact (isAdjointPair_toLinearMap₂' _ _ _ _).mpr h\n\n"}
{"name":"mem_selfAdjointMatricesSubmodule","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nn : Type u_11\ninst✝² : CommRing R\ninst✝¹ : Fintype n\nJ A₁ : Matrix n n R\ninst✝ : DecidableEq n\n⊢ Iff (Membership.mem (selfAdjointMatricesSubmodule J) A₁) (J.IsSelfAdjoint A₁)","decl":"@[simp]\ntheorem mem_selfAdjointMatricesSubmodule :\n    A₁ ∈ selfAdjointMatricesSubmodule J ↔ J.IsSelfAdjoint A₁ := by\n  erw [mem_pairSelfAdjointMatricesSubmodule]\n  rfl\n\n"}
{"name":"mem_skewAdjointMatricesSubmodule","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R : Type u_1\nn : Type u_11\ninst✝² : CommRing R\ninst✝¹ : Fintype n\nJ A₁ : Matrix n n R\ninst✝ : DecidableEq n\n⊢ Iff (Membership.mem (skewAdjointMatricesSubmodule J) A₁) (J.IsSkewAdjoint A₁)","decl":"@[simp]\ntheorem mem_skewAdjointMatricesSubmodule :\n    A₁ ∈ skewAdjointMatricesSubmodule J ↔ J.IsSkewAdjoint A₁ := by\n  erw [mem_pairSelfAdjointMatricesSubmodule]\n  simp [Matrix.IsSkewAdjoint, Matrix.IsAdjointPair]\n\n"}
{"name":"Matrix.separatingLeft_toLinearMap₂'_iff_separatingLeft_toLinearMap₂","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R₁ : Type u_2\nM₁ : Type u_6\nι : Type u_15\ninst✝⁴ : CommRing R₁\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R₁ M₁\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nM : Matrix ι ι R₁\nb : Basis ι R₁ M₁\n⊢ Iff ((Matrix.toLinearMap₂' R₁) M).SeparatingLeft ((Matrix.toLinearMap₂ b b) M).SeparatingLeft","decl":"theorem _root_.Matrix.separatingLeft_toLinearMap₂'_iff_separatingLeft_toLinearMap₂\n    {M : Matrix ι ι R₁} (b : Basis ι R₁ M₁) :\n    (Matrix.toLinearMap₂' R₁ M).SeparatingLeft (R := R₁) ↔\n      (Matrix.toLinearMap₂ b b M).SeparatingLeft :=\n  (separatingLeft_congr_iff b.equivFun.symm b.equivFun.symm).symm\n\n-- Lemmas transferring nondegeneracy between a matrix and its associated bilinear form\n"}
{"name":"Matrix.Nondegenerate.toLinearMap₂'","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R₁ : Type u_2\nι : Type u_15\ninst✝² : CommRing R₁\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nM : Matrix ι ι R₁\nh : M.Nondegenerate\n⊢ ((Matrix.toLinearMap₂' R₁) M).SeparatingLeft","decl":"theorem _root_.Matrix.Nondegenerate.toLinearMap₂' {M : Matrix ι ι R₁} (h : M.Nondegenerate) :\n    (Matrix.toLinearMap₂' R₁ M).SeparatingLeft (R := R₁) := fun x hx =>\n  h.eq_zero_of_ortho fun y => by simpa only [toLinearMap₂'_apply'] using hx y\n\n"}
{"name":"Matrix.separatingLeft_toLinearMap₂'_iff","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R₁ : Type u_2\nι : Type u_15\ninst✝² : CommRing R₁\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nM : Matrix ι ι R₁\n⊢ Iff ((Matrix.toLinearMap₂' R₁) M).SeparatingLeft M.Nondegenerate","decl":"@[simp]\ntheorem _root_.Matrix.separatingLeft_toLinearMap₂'_iff {M : Matrix ι ι R₁} :\n    (Matrix.toLinearMap₂' R₁ M).SeparatingLeft (R := R₁) ↔ M.Nondegenerate :=\n  ⟨fun h v hv => h v fun w => (M.toLinearMap₂'_apply' _ _).trans <| hv w,\n    Matrix.Nondegenerate.toLinearMap₂'⟩\n\n"}
{"name":"Matrix.Nondegenerate.toLinearMap₂","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R₁ : Type u_2\nM₁ : Type u_6\nι : Type u_15\ninst✝⁴ : CommRing R₁\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R₁ M₁\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nM : Matrix ι ι R₁\nh : M.Nondegenerate\nb : Basis ι R₁ M₁\n⊢ ((Matrix.toLinearMap₂ b b) M).SeparatingLeft","decl":"theorem _root_.Matrix.Nondegenerate.toLinearMap₂ {M : Matrix ι ι R₁} (h : M.Nondegenerate)\n    (b : Basis ι R₁ M₁) : (toLinearMap₂ b b M).SeparatingLeft :=\n  (Matrix.separatingLeft_toLinearMap₂'_iff_separatingLeft_toLinearMap₂ b).mp h.toLinearMap₂'\n\n"}
{"name":"Matrix.separatingLeft_toLinearMap₂_iff","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R₁ : Type u_2\nM₁ : Type u_6\nι : Type u_15\ninst✝⁴ : CommRing R₁\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R₁ M₁\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nM : Matrix ι ι R₁\nb : Basis ι R₁ M₁\n⊢ Iff ((Matrix.toLinearMap₂ b b) M).SeparatingLeft M.Nondegenerate","decl":"@[simp]\ntheorem _root_.Matrix.separatingLeft_toLinearMap₂_iff {M : Matrix ι ι R₁} (b : Basis ι R₁ M₁) :\n    (toLinearMap₂ b b M).SeparatingLeft ↔ M.Nondegenerate := by\n  rw [← Matrix.separatingLeft_toLinearMap₂'_iff_separatingLeft_toLinearMap₂,\n    Matrix.separatingLeft_toLinearMap₂'_iff]\n\n-- Lemmas transferring nondegeneracy between a bilinear form and its associated matrix\n"}
{"name":"LinearMap.nondegenerate_toMatrix₂'_iff","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R₁ : Type u_2\nι : Type u_15\ninst✝² : CommRing R₁\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nB : LinearMap (RingHom.id R₁) (ι → R₁) (LinearMap (RingHom.id R₁) (ι → R₁) R₁)\n⊢ Iff ((LinearMap.toMatrix₂' R₁) B).Nondegenerate B.SeparatingLeft","decl":"@[simp]\ntheorem nondegenerate_toMatrix₂'_iff {B : (ι → R₁) →ₗ[R₁] (ι → R₁) →ₗ[R₁] R₁} :\n    (LinearMap.toMatrix₂' R₁ B).Nondegenerate ↔ B.SeparatingLeft :=\n  Matrix.separatingLeft_toLinearMap₂'_iff.symm.trans <|\n    (Matrix.toLinearMap₂'_toMatrix' (R := R₁) B).symm ▸ Iff.rfl\n\n"}
{"name":"LinearMap.SeparatingLeft.toMatrix₂'","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R₁ : Type u_2\nι : Type u_15\ninst✝² : CommRing R₁\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nB : LinearMap (RingHom.id R₁) (ι → R₁) (LinearMap (RingHom.id R₁) (ι → R₁) R₁)\nh : B.SeparatingLeft\n⊢ ((LinearMap.toMatrix₂' R₁) B).Nondegenerate","decl":"theorem SeparatingLeft.toMatrix₂' {B : (ι → R₁) →ₗ[R₁] (ι → R₁) →ₗ[R₁] R₁} (h : B.SeparatingLeft) :\n    (LinearMap.toMatrix₂' R₁ B).Nondegenerate :=\n  nondegenerate_toMatrix₂'_iff.mpr h\n\n"}
{"name":"LinearMap.nondegenerate_toMatrix_iff","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R₁ : Type u_2\nM₁ : Type u_6\nι : Type u_15\ninst✝⁴ : CommRing R₁\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R₁ M₁\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nB : LinearMap (RingHom.id R₁) M₁ (LinearMap (RingHom.id R₁) M₁ R₁)\nb : Basis ι R₁ M₁\n⊢ Iff ((LinearMap.toMatrix₂ b b) B).Nondegenerate B.SeparatingLeft","decl":"@[simp]\ntheorem nondegenerate_toMatrix_iff {B : M₁ →ₗ[R₁] M₁ →ₗ[R₁] R₁} (b : Basis ι R₁ M₁) :\n    (toMatrix₂ b b B).Nondegenerate ↔ B.SeparatingLeft :=\n  (Matrix.separatingLeft_toLinearMap₂_iff b).symm.trans <|\n    (Matrix.toLinearMap₂_toMatrix₂ b b B).symm ▸ Iff.rfl\n\n"}
{"name":"LinearMap.SeparatingLeft.toMatrix₂","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R₁ : Type u_2\nM₁ : Type u_6\nι : Type u_15\ninst✝⁴ : CommRing R₁\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R₁ M₁\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nB : LinearMap (RingHom.id R₁) M₁ (LinearMap (RingHom.id R₁) M₁ R₁)\nh : B.SeparatingLeft\nb : Basis ι R₁ M₁\n⊢ ((LinearMap.toMatrix₂ b b) B).Nondegenerate","decl":"theorem SeparatingLeft.toMatrix₂ {B : M₁ →ₗ[R₁] M₁ →ₗ[R₁] R₁} (h : B.SeparatingLeft)\n    (b : Basis ι R₁ M₁) : (toMatrix₂ b b B).Nondegenerate :=\n  (nondegenerate_toMatrix_iff b).mpr h\n\n-- Some shorthands for combining the above with `Matrix.nondegenerate_of_det_ne_zero`\n"}
{"name":"LinearMap.separatingLeft_toLinearMap₂'_iff_det_ne_zero","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R₁ : Type u_2\nι : Type u_15\ninst✝³ : CommRing R₁\ninst✝² : DecidableEq ι\ninst✝¹ : Fintype ι\ninst✝ : IsDomain R₁\nM : Matrix ι ι R₁\n⊢ Iff ((Matrix.toLinearMap₂' R₁) M).SeparatingLeft (Ne M.det 0)","decl":"theorem separatingLeft_toLinearMap₂'_iff_det_ne_zero {M : Matrix ι ι R₁} :\n    (Matrix.toLinearMap₂' R₁ M).SeparatingLeft (R := R₁) ↔ M.det ≠ 0 := by\n  rw [Matrix.separatingLeft_toLinearMap₂'_iff, Matrix.nondegenerate_iff_det_ne_zero]\n\n"}
{"name":"LinearMap.separatingLeft_toLinearMap₂'_of_det_ne_zero'","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R₁ : Type u_2\nι : Type u_15\ninst✝³ : CommRing R₁\ninst✝² : DecidableEq ι\ninst✝¹ : Fintype ι\ninst✝ : IsDomain R₁\nM : Matrix ι ι R₁\nh : Ne M.det 0\n⊢ ((Matrix.toLinearMap₂' R₁) M).SeparatingLeft","decl":"theorem separatingLeft_toLinearMap₂'_of_det_ne_zero' (M : Matrix ι ι R₁) (h : M.det ≠ 0) :\n    (Matrix.toLinearMap₂' R₁ M).SeparatingLeft (R := R₁) :=\n  separatingLeft_toLinearMap₂'_iff_det_ne_zero.mpr h\n\n"}
{"name":"LinearMap.separatingLeft_iff_det_ne_zero","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R₁ : Type u_2\nM₁ : Type u_6\nι : Type u_15\ninst✝⁵ : CommRing R₁\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : Module R₁ M₁\ninst✝² : DecidableEq ι\ninst✝¹ : Fintype ι\ninst✝ : IsDomain R₁\nB : LinearMap (RingHom.id R₁) M₁ (LinearMap (RingHom.id R₁) M₁ R₁)\nb : Basis ι R₁ M₁\n⊢ Iff B.SeparatingLeft (Ne ((LinearMap.toMatrix₂ b b) B).det 0)","decl":"theorem separatingLeft_iff_det_ne_zero {B : M₁ →ₗ[R₁] M₁ →ₗ[R₁] R₁} (b : Basis ι R₁ M₁) :\n    B.SeparatingLeft ↔ (toMatrix₂ b b B).det ≠ 0 := by\n  rw [← Matrix.nondegenerate_iff_det_ne_zero, nondegenerate_toMatrix_iff]\n\n"}
{"name":"LinearMap.separatingLeft_of_det_ne_zero","module":"Mathlib.LinearAlgebra.Matrix.SesquilinearForm","initialProofState":"R₁ : Type u_2\nM₁ : Type u_6\nι : Type u_15\ninst✝⁵ : CommRing R₁\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : Module R₁ M₁\ninst✝² : DecidableEq ι\ninst✝¹ : Fintype ι\ninst✝ : IsDomain R₁\nB : LinearMap (RingHom.id R₁) M₁ (LinearMap (RingHom.id R₁) M₁ R₁)\nb : Basis ι R₁ M₁\nh : Ne ((LinearMap.toMatrix₂ b b) B).det 0\n⊢ B.SeparatingLeft","decl":"theorem separatingLeft_of_det_ne_zero {B : M₁ →ₗ[R₁] M₁ →ₗ[R₁] R₁} (b : Basis ι R₁ M₁)\n    (h : (toMatrix₂ b b B).det ≠ 0) : B.SeparatingLeft :=\n  (separatingLeft_iff_det_ne_zero b).mpr h\n\n"}
