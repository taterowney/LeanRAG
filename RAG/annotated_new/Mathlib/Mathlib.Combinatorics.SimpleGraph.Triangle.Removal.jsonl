{"name":"SimpleGraph.triangleRemovalBound_pos","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Removal","initialProofState":"ε : Real\nhε : LT.lt 0 ε\nhε₁ : LE.le ε 1\n⊢ LT.lt 0 (SimpleGraph.triangleRemovalBound ε)","decl":"lemma triangleRemovalBound_pos (hε : 0 < ε) (hε₁ : ε ≤ 1) : 0 < triangleRemovalBound ε := by\n  have : 0 < 1 - ε / 4 := by linarith\n  unfold triangleRemovalBound\n  positivity\n\n"}
{"name":"SimpleGraph.triangleRemovalBound_nonpos","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Removal","initialProofState":"ε : Real\nhε : LE.le ε 0\n⊢ LE.le (SimpleGraph.triangleRemovalBound ε) 0","decl":"lemma triangleRemovalBound_nonpos (hε : ε ≤ 0) : triangleRemovalBound ε ≤ 0 := by\n  rw [triangleRemovalBound, ceil_eq_zero.2 (div_nonpos_of_nonneg_of_nonpos _ hε)] <;> simp\n\n"}
{"name":"SimpleGraph.triangleRemovalBound_mul_cube_lt","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Removal","initialProofState":"ε : Real\nhε : LT.lt 0 ε\n⊢ LT.lt (HMul.hMul (SimpleGraph.triangleRemovalBound ε) (HPow.hPow (↑(Nat.ceil (HDiv.hDiv 4 ε))) 3)) 1","decl":"lemma triangleRemovalBound_mul_cube_lt (hε : 0 < ε) :\n    triangleRemovalBound ε * ⌈4 / ε⌉₊ ^ 3 < 1 := by\n  calc\n    _ ≤ (2 * ⌈4 / ε⌉₊ ^ 3 : ℝ)⁻¹ * ↑⌈4 / ε⌉₊ ^ 3 := by gcongr; exact min_le_left _ _\n    _ = 2⁻¹ := by rw [mul_inv, inv_mul_cancel_right₀]; positivity\n    _ < 1 := by norm_num\n\n"}
{"name":"SimpleGraph.regularityReduced_edges_card_aux","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Removal","initialProofState":"α : Type u_1\ninst✝³ : DecidableEq α\ninst✝² : Fintype α\nG : SimpleGraph α\ninst✝¹ : DecidableRel G.Adj\nP : Finpartition Finset.univ\nε : Real\ninst✝ : Nonempty α\nhε : LT.lt 0 ε\nhP : P.IsEquipartition\nhPε : P.IsUniform G (HDiv.hDiv ε 8)\nhP' : LE.le (HDiv.hDiv 4 ε) ↑P.parts.card\n⊢ LT.lt (HMul.hMul 2 (HSub.hSub ↑G.edgeFinset.card ↑(SimpleGraph.regularityReduced P G (HDiv.hDiv ε 8) (HDiv.hDiv ε 4)).edgeFinset.card)) (HMul.hMul (HMul.hMul 2 ε) ↑(HPow.hPow (Fintype.card α) 2))","decl":"lemma regularityReduced_edges_card_aux [Nonempty α] (hε : 0 < ε) (hP : P.IsEquipartition)\n    (hPε : P.IsUniform G (ε/8)) (hP' : 4 / ε ≤ #P.parts) :\n    2 * (#G.edgeFinset - #(G.regularityReduced P (ε/8) (ε/4)).edgeFinset : ℝ)\n      < 2 * ε * (card α ^ 2 : ℕ) := by\n  let A := (P.nonUniforms G (ε/8)).biUnion fun (U, V) ↦ U ×ˢ V\n  let B := P.parts.biUnion offDiag\n  let C := (P.sparsePairs G (ε/4)).biUnion fun (U, V) ↦ G.interedges U V\n  calc\n    _ = (#((univ ×ˢ univ).filter fun (x, y) ↦\n          G.Adj x y ∧ ¬(G.regularityReduced P (ε / 8) (ε /4)).Adj x y) : ℝ) := by\n      rw [univ_product_univ, mul_sub, filter_and_not, cast_card_sdiff]\n      · norm_cast\n        rw [two_mul_card_edgeFinset, two_mul_card_edgeFinset]\n      · exact monotone_filter_right _ fun xy hxy ↦ regularityReduced_le hxy\n    _ ≤ #(A ∪ B ∪ C) := by gcongr; exact unreduced_edges_subset\n    _ ≤ #(A ∪ B) + #C := mod_cast (card_union_le _ _)\n    _ ≤ #A + #B + #C := by gcongr; exact mod_cast card_union_le _ _\n    _ < 4 * (ε / 8) * card α ^ 2 + _ + _ := by\n      gcongr; exact hP.sum_nonUniforms_lt univ_nonempty (by positivity) hPε\n    _ ≤ _ + ε / 2 * card α ^ 2 + 4 * (ε / 4) * card α ^ 2 := by\n      gcongr\n      · exact hP.card_biUnion_offDiag_le hε hP'\n      · exact hP.card_interedges_sparsePairs_le (G := G) (ε := ε / 4) (by positivity)\n    _ = 2 * ε * (card α ^ 2 : ℕ) := by norm_cast; ring\n\n"}
{"name":"SimpleGraph.FarFromTriangleFree.le_card_cliqueFinset","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Removal","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : Real\nhG : G.FarFromTriangleFree ε\n⊢ LE.le (HMul.hMul (SimpleGraph.triangleRemovalBound ε) (HPow.hPow (↑(Fintype.card α)) 3)) ↑(G.cliqueFinset 3).card","decl":"/-- **Triangle Removal Lemma**. If not all triangles can be removed by removing few edges (on the\norder of `(card α)^2`), then there were many triangles to start with (on the order of\n`(card α)^3`). -/\nlemma FarFromTriangleFree.le_card_cliqueFinset (hG : G.FarFromTriangleFree ε) :\n    triangleRemovalBound ε * card α ^ 3 ≤ #(G.cliqueFinset 3) := by\n  cases isEmpty_or_nonempty α\n  · simp [Fintype.card_eq_zero]\n  obtain hε | hε := le_or_lt ε 0\n  · apply (mul_nonpos_of_nonpos_of_nonneg (triangleRemovalBound_nonpos hε) _).trans <;> positivity\n  let l : ℕ := ⌈4 / ε⌉₊\n  have hl : 4/ε ≤ l := le_ceil (4/ε)\n  cases' le_total (card α) l with hl' hl'\n  · calc\n      _ ≤ triangleRemovalBound ε * ↑l ^ 3 := by\n        gcongr; exact (triangleRemovalBound_pos hε hG.lt_one.le).le\n      _ ≤ (1 : ℝ) := (triangleRemovalBound_mul_cube_lt hε).le\n      _ ≤ _ := by simpa [one_le_iff_ne_zero] using (hG.cliqueFinset_nonempty hε).card_pos.ne'\n  obtain ⟨P, hP₁, hP₂, hP₃, hP₄⟩ := szemeredi_regularity G (by positivity : 0 < ε / 8) hl'\n  have : 4/ε ≤ #P.parts := hl.trans (cast_le.2 hP₂)\n  have k := regularityReduced_edges_card_aux hε hP₁ hP₄ this\n  rw [mul_assoc] at k\n  replace k := lt_of_mul_lt_mul_left k zero_le_two\n  obtain ⟨t, ht⟩ := hG.cliqueFinset_nonempty' regularityReduced_le k\n  exact triangle_removal_aux hε hP₁ hP₃ ht\n\n"}
{"name":"SimpleGraph.triangle_removal","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Removal","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : Real\nhG : LT.lt (↑(G.cliqueFinset 3).card) (HMul.hMul (SimpleGraph.triangleRemovalBound ε) (HPow.hPow (↑(Fintype.card α)) 3))\n⊢ Exists fun G' => And (LE.le G' G) (Exists fun x => And (LT.lt (HSub.hSub ↑G.edgeFinset.card ↑G'.edgeFinset.card) (HMul.hMul ε ↑(HPow.hPow (Fintype.card α) 2))) (G'.CliqueFree 3))","decl":"/-- **Triangle Removal Lemma**. If there are not too many triangles (on the order of `(card α)^3`)\nthen they can all be removed by removing a few edges (on the order of `(card α)^2`). -/\nlemma triangle_removal (hG : #(G.cliqueFinset 3) < triangleRemovalBound ε * card α ^ 3) :\n    ∃ G' ≤ G, ∃ _ : DecidableRel G'.Adj,\n      (#G.edgeFinset - #G'.edgeFinset : ℝ) < ε * (card α^2 : ℕ) ∧ G'.CliqueFree 3 := by\n  by_contra! h\n  refine hG.not_le (farFromTriangleFree_iff.2 ?_).le_card_cliqueFinset\n  intros G' _ hG hG'\n  exact le_of_not_lt fun i ↦ h G' hG _ i hG'\n\n"}
