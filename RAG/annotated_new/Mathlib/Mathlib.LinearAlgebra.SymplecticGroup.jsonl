{"name":"Matrix.J_transpose","module":"Mathlib.LinearAlgebra.SymplecticGroup","initialProofState":"l : Type u_1\nR : Type u_2\ninst✝¹ : DecidableEq l\ninst✝ : CommRing R\n⊢ Eq (Matrix.J l R).transpose (Neg.neg (Matrix.J l R))","decl":"@[simp]\ntheorem J_transpose : (J l R)ᵀ = -J l R := by\n  rw [J, fromBlocks_transpose, ← neg_one_smul R (fromBlocks _ _ _ _ : Matrix (l ⊕ l) (l ⊕ l) R),\n    fromBlocks_smul, Matrix.transpose_zero, Matrix.transpose_one, transpose_neg]\n  simp [fromBlocks]\n\n"}
{"name":"Matrix.J_squared","module":"Mathlib.LinearAlgebra.SymplecticGroup","initialProofState":"l : Type u_1\nR : Type u_2\ninst✝² : DecidableEq l\ninst✝¹ : CommRing R\ninst✝ : Fintype l\n⊢ Eq (HMul.hMul (Matrix.J l R) (Matrix.J l R)) (-1)","decl":"theorem J_squared : J l R * J l R = -1 := by\n  rw [J, fromBlocks_multiply]\n  simp only [Matrix.zero_mul, Matrix.neg_mul, zero_add, neg_zero, Matrix.one_mul, add_zero]\n  rw [← neg_zero, ← Matrix.fromBlocks_neg, ← fromBlocks_one]\n\n"}
{"name":"Matrix.J_inv","module":"Mathlib.LinearAlgebra.SymplecticGroup","initialProofState":"l : Type u_1\nR : Type u_2\ninst✝² : DecidableEq l\ninst✝¹ : CommRing R\ninst✝ : Fintype l\n⊢ Eq (Inv.inv (Matrix.J l R)) (Neg.neg (Matrix.J l R))","decl":"theorem J_inv : (J l R)⁻¹ = -J l R := by\n  refine Matrix.inv_eq_right_inv ?_\n  rw [Matrix.mul_neg, J_squared]\n  exact neg_neg 1\n\n"}
{"name":"Matrix.J_det_mul_J_det","module":"Mathlib.LinearAlgebra.SymplecticGroup","initialProofState":"l : Type u_1\nR : Type u_2\ninst✝² : DecidableEq l\ninst✝¹ : CommRing R\ninst✝ : Fintype l\n⊢ Eq (HMul.hMul (Matrix.J l R).det (Matrix.J l R).det) 1","decl":"theorem J_det_mul_J_det : det (J l R) * det (J l R) = 1 := by\n  rw [← det_mul, J_squared, ← one_smul R (-1 : Matrix _ _ R), smul_neg, ← neg_smul, det_smul,\n    Fintype.card_sum, det_one, mul_one]\n  apply Even.neg_one_pow\n  exact Even.add_self _\n\n"}
{"name":"Matrix.isUnit_det_J","module":"Mathlib.LinearAlgebra.SymplecticGroup","initialProofState":"l : Type u_1\nR : Type u_2\ninst✝² : DecidableEq l\ninst✝¹ : CommRing R\ninst✝ : Fintype l\n⊢ IsUnit (Matrix.J l R).det","decl":"theorem isUnit_det_J : IsUnit (det (J l R)) :=\n  isUnit_iff_exists_inv.mpr ⟨det (J l R), J_det_mul_J_det _ _⟩\n\n"}
{"name":"SymplecticGroup.mem_iff","module":"Mathlib.LinearAlgebra.SymplecticGroup","initialProofState":"l : Type u_1\nR : Type u_2\ninst✝² : DecidableEq l\ninst✝¹ : Fintype l\ninst✝ : CommRing R\nA : Matrix (Sum l l) (Sum l l) R\n⊢ Iff (Membership.mem (Matrix.symplecticGroup l R) A) (Eq (HMul.hMul (HMul.hMul A (Matrix.J l R)) A.transpose) (Matrix.J l R))","decl":"theorem mem_iff {A : Matrix (l ⊕ l) (l ⊕ l) R} :\n    A ∈ symplecticGroup l R ↔ A * J l R * Aᵀ = J l R := by simp [symplecticGroup]\n\n"}
{"name":"SymplecticGroup.J_mem","module":"Mathlib.LinearAlgebra.SymplecticGroup","initialProofState":"l : Type u_1\nR : Type u_2\ninst✝² : DecidableEq l\ninst✝¹ : Fintype l\ninst✝ : CommRing R\n⊢ Membership.mem (Matrix.symplecticGroup l R) (Matrix.J l R)","decl":"theorem J_mem : J l R ∈ symplecticGroup l R := by\n  rw [mem_iff, J, fromBlocks_multiply, fromBlocks_transpose, fromBlocks_multiply]\n  simp\n\n"}
{"name":"SymplecticGroup.coe_J","module":"Mathlib.LinearAlgebra.SymplecticGroup","initialProofState":"l : Type u_1\nR : Type u_2\ninst✝² : DecidableEq l\ninst✝¹ : Fintype l\ninst✝ : CommRing R\n⊢ Eq (↑(SymplecticGroup.symJ l R)) (Matrix.J l R)","decl":"@[simp]\ntheorem coe_J : ↑(symJ l R) = J l R := rfl\n\n"}
{"name":"SymplecticGroup.neg_mem","module":"Mathlib.LinearAlgebra.SymplecticGroup","initialProofState":"l : Type u_1\nR : Type u_2\ninst✝² : DecidableEq l\ninst✝¹ : Fintype l\ninst✝ : CommRing R\nA : Matrix (Sum l l) (Sum l l) R\nh : Membership.mem (Matrix.symplecticGroup l R) A\n⊢ Membership.mem (Matrix.symplecticGroup l R) (Neg.neg A)","decl":"theorem neg_mem (h : A ∈ symplecticGroup l R) : -A ∈ symplecticGroup l R := by\n  rw [mem_iff] at h ⊢\n  simp [h]\n\n"}
{"name":"SymplecticGroup.symplectic_det","module":"Mathlib.LinearAlgebra.SymplecticGroup","initialProofState":"l : Type u_1\nR : Type u_2\ninst✝² : DecidableEq l\ninst✝¹ : Fintype l\ninst✝ : CommRing R\nA : Matrix (Sum l l) (Sum l l) R\nhA : Membership.mem (Matrix.symplecticGroup l R) A\n⊢ IsUnit A.det","decl":"theorem symplectic_det (hA : A ∈ symplecticGroup l R) : IsUnit <| det A := by\n  rw [isUnit_iff_exists_inv]\n  use A.det\n  refine (isUnit_det_J l R).mul_left_cancel ?_\n  rw [mul_one]\n  rw [mem_iff] at hA\n  apply_fun det at hA\n  simp only [det_mul, det_transpose] at hA\n  rw [mul_comm A.det, mul_assoc] at hA\n  exact hA\n\n"}
{"name":"SymplecticGroup.transpose_mem","module":"Mathlib.LinearAlgebra.SymplecticGroup","initialProofState":"l : Type u_1\nR : Type u_2\ninst✝² : DecidableEq l\ninst✝¹ : Fintype l\ninst✝ : CommRing R\nA : Matrix (Sum l l) (Sum l l) R\nhA : Membership.mem (Matrix.symplecticGroup l R) A\n⊢ Membership.mem (Matrix.symplecticGroup l R) A.transpose","decl":"theorem transpose_mem (hA : A ∈ symplecticGroup l R) : Aᵀ ∈ symplecticGroup l R := by\n  rw [mem_iff] at hA ⊢\n  rw [transpose_transpose]\n  have huA := symplectic_det hA\n  have huAT : IsUnit Aᵀ.det := by\n    rw [Matrix.det_transpose]\n    exact huA\n  calc\n    Aᵀ * J l R * A = (-Aᵀ) * (J l R)⁻¹ * A := by\n      rw [J_inv]\n      simp\n    _ = (-Aᵀ) * (A * J l R * Aᵀ)⁻¹ * A := by rw [hA]\n    _ = -(Aᵀ * (Aᵀ⁻¹ * (J l R)⁻¹)) * A⁻¹ * A := by\n      simp only [Matrix.mul_inv_rev, Matrix.mul_assoc, Matrix.neg_mul]\n    _ = -(J l R)⁻¹ := by\n      rw [mul_nonsing_inv_cancel_left _ _ huAT, nonsing_inv_mul_cancel_right _ _ huA]\n    _ = J l R := by simp [J_inv]\n\n"}
{"name":"SymplecticGroup.transpose_mem_iff","module":"Mathlib.LinearAlgebra.SymplecticGroup","initialProofState":"l : Type u_1\nR : Type u_2\ninst✝² : DecidableEq l\ninst✝¹ : Fintype l\ninst✝ : CommRing R\nA : Matrix (Sum l l) (Sum l l) R\n⊢ Iff (Membership.mem (Matrix.symplecticGroup l R) A.transpose) (Membership.mem (Matrix.symplecticGroup l R) A)","decl":"@[simp]\ntheorem transpose_mem_iff : Aᵀ ∈ symplecticGroup l R ↔ A ∈ symplecticGroup l R :=\n  ⟨fun hA => by simpa using transpose_mem hA, transpose_mem⟩\n\n"}
{"name":"SymplecticGroup.mem_iff'","module":"Mathlib.LinearAlgebra.SymplecticGroup","initialProofState":"l : Type u_1\nR : Type u_2\ninst✝² : DecidableEq l\ninst✝¹ : Fintype l\ninst✝ : CommRing R\nA : Matrix (Sum l l) (Sum l l) R\n⊢ Iff (Membership.mem (Matrix.symplecticGroup l R) A) (Eq (HMul.hMul (HMul.hMul A.transpose (Matrix.J l R)) A) (Matrix.J l R))","decl":"theorem mem_iff' : A ∈ symplecticGroup l R ↔ Aᵀ * J l R * A = J l R := by\n  rw [← transpose_mem_iff, mem_iff, transpose_transpose]\n\n"}
{"name":"SymplecticGroup.coe_inv","module":"Mathlib.LinearAlgebra.SymplecticGroup","initialProofState":"l : Type u_1\nR : Type u_2\ninst✝² : DecidableEq l\ninst✝¹ : Fintype l\ninst✝ : CommRing R\nA : Subtype fun x => Membership.mem (Matrix.symplecticGroup l R) x\n⊢ Eq (↑(Inv.inv A)) (HMul.hMul (HMul.hMul (Neg.neg (Matrix.J l R)) (↑A).transpose) (Matrix.J l R))","decl":"theorem coe_inv (A : symplecticGroup l R) : (↑A⁻¹ : Matrix _ _ _) = (-J l R) * (↑A)ᵀ * J l R := rfl\n\n"}
{"name":"SymplecticGroup.inv_left_mul_aux","module":"Mathlib.LinearAlgebra.SymplecticGroup","initialProofState":"l : Type u_1\nR : Type u_2\ninst✝² : DecidableEq l\ninst✝¹ : Fintype l\ninst✝ : CommRing R\nA : Matrix (Sum l l) (Sum l l) R\nhA : Membership.mem (Matrix.symplecticGroup l R) A\n⊢ Eq (Neg.neg (HMul.hMul (HMul.hMul (HMul.hMul (Matrix.J l R) A.transpose) (Matrix.J l R)) A)) 1","decl":"theorem inv_left_mul_aux (hA : A ∈ symplecticGroup l R) : -(J l R * Aᵀ * J l R * A) = 1 :=\n  calc\n    -(J l R * Aᵀ * J l R * A) = (-J l R) * (Aᵀ * J l R * A) := by\n      simp only [Matrix.mul_assoc, Matrix.neg_mul]\n    _ = (-J l R) * J l R := by\n      rw [mem_iff'] at hA\n      rw [hA]\n    _ = (-1 : R) • (J l R * J l R) := by simp only [Matrix.neg_mul, neg_smul, one_smul]\n    _ = (-1 : R) • (-1 : Matrix _ _ _) := by rw [J_squared]\n    _ = 1 := by simp only [neg_smul_neg, one_smul]\n\n"}
{"name":"SymplecticGroup.coe_inv'","module":"Mathlib.LinearAlgebra.SymplecticGroup","initialProofState":"l : Type u_1\nR : Type u_2\ninst✝² : DecidableEq l\ninst✝¹ : Fintype l\ninst✝ : CommRing R\nA : Subtype fun x => Membership.mem (Matrix.symplecticGroup l R) x\n⊢ Eq (↑(Inv.inv A)) (Inv.inv ↑A)","decl":"theorem coe_inv' (A : symplecticGroup l R) : (↑A⁻¹ : Matrix (l ⊕ l) (l ⊕ l) R) = (↑A)⁻¹ := by\n  refine (coe_inv A).trans (inv_eq_left_inv ?_).symm\n  simp [inv_left_mul_aux, coe_inv]\n\n"}
{"name":"SymplecticGroup.inv_eq_symplectic_inv","module":"Mathlib.LinearAlgebra.SymplecticGroup","initialProofState":"l : Type u_1\nR : Type u_2\ninst✝² : DecidableEq l\ninst✝¹ : Fintype l\ninst✝ : CommRing R\nA : Matrix (Sum l l) (Sum l l) R\nhA : Membership.mem (Matrix.symplecticGroup l R) A\n⊢ Eq (Inv.inv A) (HMul.hMul (HMul.hMul (Neg.neg (Matrix.J l R)) A.transpose) (Matrix.J l R))","decl":"theorem inv_eq_symplectic_inv (A : Matrix (l ⊕ l) (l ⊕ l) R) (hA : A ∈ symplecticGroup l R) :\n    A⁻¹ = (-J l R) * Aᵀ * J l R :=\n  inv_eq_left_inv (by simp only [Matrix.neg_mul, inv_left_mul_aux hA])\n\n"}
