{"name":"Subadditive.lim_le_div","module":"Mathlib.Analysis.Subadditive","initialProofState":"u : Nat → Real\nh : Subadditive u\nhbdd : BddBelow (Set.range fun n => HDiv.hDiv (u n) ↑n)\nn : Nat\nhn : Ne n 0\n⊢ LE.le h.lim (HDiv.hDiv (u n) ↑n)","decl":"theorem lim_le_div (hbdd : BddBelow (range fun n => u n / n)) {n : ℕ} (hn : n ≠ 0) :\n    h.lim ≤ u n / n := by\n  rw [Subadditive.lim]\n  exact csInf_le (hbdd.mono <| image_subset_range _ _) ⟨n, hn.bot_lt, rfl⟩\n\n"}
{"name":"Subadditive.apply_mul_add_le","module":"Mathlib.Analysis.Subadditive","initialProofState":"u : Nat → Real\nh : Subadditive u\nk n r : Nat\n⊢ LE.le (u (HAdd.hAdd (HMul.hMul k n) r)) (HAdd.hAdd (HMul.hMul (↑k) (u n)) (u r))","decl":"include h in\ntheorem apply_mul_add_le (k n r) : u (k * n + r) ≤ k * u n + u r := by\n  induction k with\n  | zero => simp only [Nat.cast_zero, zero_mul, zero_add]; rfl\n  | succ k IH =>\n    calc\n      u ((k + 1) * n + r) = u (n + (k * n + r)) := by congr 1; ring\n      _ ≤ u n + u (k * n + r) := h _ _\n      _ ≤ u n + (k * u n + u r) := add_le_add_left IH _\n      _ = (k + 1 : ℕ) * u n + u r := by simp; ring\n\n"}
{"name":"Subadditive.eventually_div_lt_of_div_lt","module":"Mathlib.Analysis.Subadditive","initialProofState":"u : Nat → Real\nh : Subadditive u\nL : Real\nn : Nat\nhn : Ne n 0\nhL : LT.lt (HDiv.hDiv (u n) ↑n) L\n⊢ Filter.Eventually (fun p => LT.lt (HDiv.hDiv (u p) ↑p) L) Filter.atTop","decl":"include h in\ntheorem eventually_div_lt_of_div_lt {L : ℝ} {n : ℕ} (hn : n ≠ 0) (hL : u n / n < L) :\n    ∀ᶠ p in atTop, u p / p < L := by\n  /- It suffices to prove the statement for each arithmetic progression `(n * · + r)`. -/\n  refine .atTop_of_arithmetic hn fun r _ => ?_\n  /- `(k * u n + u r) / (k * n + r)` tends to `u n / n < L`, hence\n  `(k * u n + u r) / (k * n + r) < L` for sufficiently large `k`. -/\n  have A : Tendsto (fun x : ℝ => (u n + u r / x) / (n + r / x)) atTop (𝓝 ((u n + 0) / (n + 0))) :=\n    (tendsto_const_nhds.add <| tendsto_const_nhds.div_atTop tendsto_id).div\n      (tendsto_const_nhds.add <| tendsto_const_nhds.div_atTop tendsto_id) <| by simpa\n  have B : Tendsto (fun x => (x * u n + u r) / (x * n + r)) atTop (𝓝 (u n / n)) := by\n    rw [add_zero, add_zero] at A\n    refine A.congr' <| (eventually_ne_atTop 0).mono fun x hx => ?_\n    simp only [(· ∘ ·), add_div' _ _ _ hx, div_div_div_cancel_right₀ hx, mul_comm]\n  refine ((B.comp tendsto_natCast_atTop_atTop).eventually (gt_mem_nhds hL)).mono fun k hk => ?_\n  /- Finally, we use an upper estimate on `u (k * n + r)` to get an estimate on\n  `u (k * n + r) / (k * n + r)`. -/\n  rw [mul_comm]\n  refine lt_of_le_of_lt ?_ hk\n  simp only [(· ∘ ·), ← Nat.cast_add, ← Nat.cast_mul]\n  exact div_le_div_of_nonneg_right (h.apply_mul_add_le _ _ _) (Nat.cast_nonneg _)\n\n"}
{"name":"Subadditive.tendsto_lim","module":"Mathlib.Analysis.Subadditive","initialProofState":"u : Nat → Real\nh : Subadditive u\nhbdd : BddBelow (Set.range fun n => HDiv.hDiv (u n) ↑n)\n⊢ Filter.Tendsto (fun n => HDiv.hDiv (u n) ↑n) Filter.atTop (nhds h.lim)","decl":"/-- Fekete's lemma: a subadditive sequence which is bounded below converges. -/\ntheorem tendsto_lim (hbdd : BddBelow (range fun n => u n / n)) :\n    Tendsto (fun n => u n / n) atTop (𝓝 h.lim) := by\n  refine tendsto_order.2 ⟨fun l hl => ?_, fun L hL => ?_⟩\n  · refine eventually_atTop.2\n      ⟨1, fun n hn => hl.trans_le (h.lim_le_div hbdd (zero_lt_one.trans_le hn).ne')⟩\n  · obtain ⟨n, npos, hn⟩ : ∃ n : ℕ, 0 < n ∧ u n / n < L := by\n      rw [Subadditive.lim] at hL\n      rcases exists_lt_of_csInf_lt (by simp) hL with ⟨x, hx, xL⟩\n      rcases (mem_image _ _ _).1 hx with ⟨n, hn, rfl⟩\n      exact ⟨n, zero_lt_one.trans_le hn, xL⟩\n    exact h.eventually_div_lt_of_div_lt npos.ne' hn\n\n"}
