{"name":"Finset.mem_sigma","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Finset ι\nt : (i : ι) → Finset (α i)\na : Sigma fun i => α i\n⊢ Iff (Membership.mem (s.sigma t) a) (And (Membership.mem s a.fst) (Membership.mem (t a.fst) a.snd))","decl":"@[simp]\ntheorem mem_sigma {a : Σi, α i} : a ∈ s.sigma t ↔ a.1 ∈ s ∧ a.2 ∈ t a.1 :=\n  Multiset.mem_sigma\n\n"}
{"name":"Finset.coe_sigma","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Finset ι\nt : (i : ι) → Finset (α i)\n⊢ Eq (↑(s.sigma t)) ((↑s).sigma fun i => ↑(t i))","decl":"@[simp, norm_cast]\ntheorem coe_sigma (s : Finset ι) (t : ∀ i, Finset (α i)) :\n    (s.sigma t : Set (Σ i, α i)) = (s : Set ι).sigma fun i ↦ (t i : Set (α i)) :=\n  Set.ext fun _ => mem_sigma\n\n"}
{"name":"Finset.sigma_nonempty","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Finset ι\nt : (i : ι) → Finset (α i)\n⊢ Iff (s.sigma t).Nonempty (Exists fun i => And (Membership.mem s i) (t i).Nonempty)","decl":"@[simp]\ntheorem sigma_nonempty : (s.sigma t).Nonempty ↔ ∃ i ∈ s, (t i).Nonempty := by simp [Finset.Nonempty]\n\n"}
{"name":"Finset.Aesop.sigma_nonempty_of_exists_nonempty","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Finset ι\nt : (i : ι) → Finset (α i)\na✝ : Exists fun i => And (Membership.mem s i) (t i).Nonempty\n⊢ (s.sigma t).Nonempty","decl":"@[aesop safe apply (rule_sets := [finsetNonempty])]\nalias ⟨_, Aesop.sigma_nonempty_of_exists_nonempty⟩ := sigma_nonempty\n\n"}
{"name":"Finset.sigma_eq_empty","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Finset ι\nt : (i : ι) → Finset (α i)\n⊢ Iff (Eq (s.sigma t) EmptyCollection.emptyCollection) (∀ (i : ι), Membership.mem s i → Eq (t i) EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem sigma_eq_empty : s.sigma t = ∅ ↔ ∀ i ∈ s, t i = ∅ := by\n  simp only [← not_nonempty_iff_eq_empty, sigma_nonempty, not_exists, not_and]\n\n"}
{"name":"Finset.sigma_mono","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns₁ s₂ : Finset ι\nt₁ t₂ : (i : ι) → Finset (α i)\nhs : HasSubset.Subset s₁ s₂\nht : ∀ (i : ι), HasSubset.Subset (t₁ i) (t₂ i)\n⊢ HasSubset.Subset (s₁.sigma t₁) (s₂.sigma t₂)","decl":"@[mono]\ntheorem sigma_mono (hs : s₁ ⊆ s₂) (ht : ∀ i, t₁ i ⊆ t₂ i) : s₁.sigma t₁ ⊆ s₂.sigma t₂ :=\n  fun ⟨i, _⟩ h =>\n  let ⟨hi, ha⟩ := mem_sigma.1 h\n  mem_sigma.2 ⟨hs hi, ht i ha⟩\n\n"}
{"name":"Finset.pairwiseDisjoint_map_sigmaMk","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Finset ι\nt : (i : ι) → Finset (α i)\n⊢ (↑s).PairwiseDisjoint fun i => Finset.map (Function.Embedding.sigmaMk i) (t i)","decl":"theorem pairwiseDisjoint_map_sigmaMk :\n    (s : Set ι).PairwiseDisjoint fun i => (t i).map (Embedding.sigmaMk i) := by\n  intro i _ j _ hij\n  rw [Function.onFun, disjoint_left]\n  simp_rw [mem_map, Function.Embedding.sigmaMk_apply]\n  rintro _ ⟨y, _, rfl⟩ ⟨z, _, hz'⟩\n  exact hij (congr_arg Sigma.fst hz'.symm)\n\n"}
{"name":"Finset.disjiUnion_map_sigma_mk","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Finset ι\nt : (i : ι) → Finset (α i)\n⊢ Eq (s.disjiUnion (fun i => Finset.map (Function.Embedding.sigmaMk i) (t i)) ⋯) (s.sigma t)","decl":"@[simp]\ntheorem disjiUnion_map_sigma_mk :\n    s.disjiUnion (fun i => (t i).map (Embedding.sigmaMk i)) pairwiseDisjoint_map_sigmaMk =\n      s.sigma t :=\n  rfl\n\n"}
{"name":"Finset.sigma_eq_biUnion","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : DecidableEq (Sigma fun i => α i)\ns : Finset ι\nt : (i : ι) → Finset (α i)\n⊢ Eq (s.sigma t) (s.biUnion fun i => Finset.map (Function.Embedding.sigmaMk i) (t i))","decl":"theorem sigma_eq_biUnion [DecidableEq (Σi, α i)] (s : Finset ι) (t : ∀ i, Finset (α i)) :\n    s.sigma t = s.biUnion fun i => (t i).map <| Embedding.sigmaMk i := by\n  ext ⟨x, y⟩\n  simp [and_left_comm]\n\n"}
{"name":"Finset.sup_sigma","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : Type u_3\ns : Finset ι\nt : (i : ι) → Finset (α i)\nf : (Sigma fun i => α i) → β\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderBot β\n⊢ Eq ((s.sigma t).sup f) (s.sup fun i => (t i).sup fun b => f ⟨i, b⟩)","decl":"theorem sup_sigma [SemilatticeSup β] [OrderBot β] :\n    (s.sigma t).sup f = s.sup fun i => (t i).sup fun b => f ⟨i, b⟩ := by\n  simp only [le_antisymm_iff, Finset.sup_le_iff, mem_sigma, and_imp, Sigma.forall]\n  exact\n    ⟨fun i a hi ha => (le_sup hi).trans' <| le_sup (f := fun a => f ⟨i, a⟩) ha, fun i hi a ha =>\n      le_sup <| mem_sigma.2 ⟨hi, ha⟩⟩\n\n"}
{"name":"Finset.inf_sigma","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : Type u_3\ns : Finset ι\nt : (i : ι) → Finset (α i)\nf : (Sigma fun i => α i) → β\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderTop β\n⊢ Eq ((s.sigma t).inf f) (s.inf fun i => (t i).inf fun b => f ⟨i, b⟩)","decl":"theorem inf_sigma [SemilatticeInf β] [OrderTop β] :\n    (s.sigma t).inf f = s.inf fun i => (t i).inf fun b => f ⟨i, b⟩ :=\n  @sup_sigma _ _ βᵒᵈ _ _ _ _ _\n\n"}
{"name":"biSup_finsetSigma","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : Type u_3\ninst✝ : CompleteLattice β\ns : Finset ι\nt : (i : ι) → Finset (α i)\nf : Sigma α → β\n⊢ Eq (iSup fun ij => iSup fun h => f ij) (iSup fun i => iSup fun h => iSup fun j => iSup fun h => f ⟨i, j⟩)","decl":"theorem _root_.biSup_finsetSigma [CompleteLattice β] (s : Finset ι) (t : ∀ i, Finset (α i))\n    (f : Sigma α → β) : ⨆ ij ∈ s.sigma t, f ij = ⨆ (i ∈ s) (j ∈ t i), f ⟨i, j⟩ := by\n  simp_rw [← Finset.iSup_coe, Finset.coe_sigma, biSup_sigma]\n\n"}
{"name":"biSup_finsetSigma'","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : Type u_3\ninst✝ : CompleteLattice β\ns : Finset ι\nt : (i : ι) → Finset (α i)\nf : (i : ι) → α i → β\n⊢ Eq (iSup fun i => iSup fun h => iSup fun j => iSup fun h => f i j) (iSup fun ij => iSup fun h => f ij.fst ij.snd)","decl":"theorem _root_.biSup_finsetSigma' [CompleteLattice β] (s : Finset ι) (t : ∀ i, Finset (α i))\n    (f : ∀ i, α i → β) : ⨆ (i ∈ s) (j ∈ t i), f i j = ⨆ ij ∈ s.sigma t, f ij.fst ij.snd :=\n  Eq.symm (biSup_finsetSigma _ _ _)\n\n"}
{"name":"biInf_finsetSigma","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : Type u_3\ninst✝ : CompleteLattice β\ns : Finset ι\nt : (i : ι) → Finset (α i)\nf : Sigma α → β\n⊢ Eq (iInf fun ij => iInf fun h => f ij) (iInf fun i => iInf fun h => iInf fun j => iInf fun h => f ⟨i, j⟩)","decl":"theorem _root_.biInf_finsetSigma [CompleteLattice β] (s : Finset ι) (t : ∀ i, Finset (α i))\n    (f : Sigma α → β) : ⨅ ij ∈ s.sigma t, f ij = ⨅ (i ∈ s) (j ∈ t i), f ⟨i, j⟩ :=\n  biSup_finsetSigma (β := βᵒᵈ) _ _ _\n\n"}
{"name":"biInf_finsetSigma'","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : Type u_3\ninst✝ : CompleteLattice β\ns : Finset ι\nt : (i : ι) → Finset (α i)\nf : (i : ι) → α i → β\n⊢ Eq (iInf fun i => iInf fun h => iInf fun j => iInf fun h => f i j) (iInf fun ij => iInf fun h => f ij.fst ij.snd)","decl":"theorem _root_.biInf_finsetSigma' [CompleteLattice β] (s : Finset ι) (t : ∀ i, Finset (α i))\n    (f : ∀ i, α i → β) : ⨅ (i ∈ s) (j ∈ t i), f i j = ⨅ ij ∈ s.sigma t, f ij.fst ij.snd :=\n  Eq.symm (biInf_finsetSigma _ _ _)\n\n"}
{"name":"Set.biUnion_finsetSigma","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : Type u_3\ns : Finset ι\nt : (i : ι) → Finset (α i)\nf : Sigma α → Set β\n⊢ Eq (Set.iUnion fun ij => Set.iUnion fun h => f ij) (Set.iUnion fun i => Set.iUnion fun h => Set.iUnion fun j => Set.iUnion fun h => f ⟨i, j⟩)","decl":"theorem _root_.Set.biUnion_finsetSigma (s : Finset ι) (t : ∀ i, Finset (α i))\n    (f : Sigma α → Set β) : ⋃ ij ∈ s.sigma t, f ij = ⋃ i ∈ s, ⋃ j ∈ t i, f ⟨i, j⟩ :=\n  biSup_finsetSigma _ _ _\n\n"}
{"name":"Set.biUnion_finsetSigma'","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : Type u_3\ns : Finset ι\nt : (i : ι) → Finset (α i)\nf : (i : ι) → α i → Set β\n⊢ Eq (Set.iUnion fun i => Set.iUnion fun h => Set.iUnion fun j => Set.iUnion fun h => f i j) (Set.iUnion fun ij => Set.iUnion fun h => f ij.fst ij.snd)","decl":"theorem _root_.Set.biUnion_finsetSigma' (s : Finset ι) (t : ∀ i, Finset (α i))\n    (f : ∀ i, α i → Set β) : ⋃ i ∈ s, ⋃ j ∈ t i, f i j = ⋃ ij ∈ s.sigma t, f ij.fst ij.snd :=\n  biSup_finsetSigma' _ _ _\n\n"}
{"name":"Set.biInter_finsetSigma","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : Type u_3\ns : Finset ι\nt : (i : ι) → Finset (α i)\nf : Sigma α → Set β\n⊢ Eq (Set.iInter fun ij => Set.iInter fun h => f ij) (Set.iInter fun i => Set.iInter fun h => Set.iInter fun j => Set.iInter fun h => f ⟨i, j⟩)","decl":"theorem _root_.Set.biInter_finsetSigma (s : Finset ι) (t : ∀ i, Finset (α i))\n    (f : Sigma α → Set β) : ⋂ ij ∈ s.sigma t, f ij = ⋂ i ∈ s, ⋂ j ∈ t i, f ⟨i, j⟩ :=\n  biInf_finsetSigma _ _ _\n\n"}
{"name":"Set.biInter_finsetSigma'","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : Type u_3\ns : Finset ι\nt : (i : ι) → Finset (α i)\nf : (i : ι) → α i → Set β\n⊢ Eq (Set.iInter fun i => Set.iInter fun h => Set.iInter fun j => Set.iInter fun h => f i j) (Set.iInter fun ij => Set.iInter fun h => f ij.fst ij.snd)","decl":"theorem _root_.Set.biInter_finsetSigma' (s : Finset ι) (t : ∀ i, Finset (α i))\n    (f : ∀ i, α i → Set β) : ⋂ i ∈ s, ⋂ j ∈ t i, f i j = ⋂ ij ∈ s.sigma t, f ij.1 ij.2 :=\n  biInf_finsetSigma' _ _ _\n\n"}
{"name":"Finset.mem_sigmaLift","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : ι → Type u_3\nγ : ι → Type u_4\ninst✝ : DecidableEq ι\nf : ⦃i : ι⦄ → α i → β i → Finset (γ i)\na : Sigma α\nb : Sigma β\nx : Sigma γ\n⊢ Iff (Membership.mem (Finset.sigmaLift f a b) x) (Exists fun ha => Exists fun hb => Membership.mem (f (Eq.rec a.snd ha) (Eq.rec b.snd hb)) x.snd)","decl":"theorem mem_sigmaLift (f : ∀ ⦃i⦄, α i → β i → Finset (γ i)) (a : Sigma α) (b : Sigma β)\n    (x : Sigma γ) :\n    x ∈ sigmaLift f a b ↔ ∃ (ha : a.1 = x.1) (hb : b.1 = x.1), x.2 ∈ f (ha ▸ a.2) (hb ▸ b.2) := by\n  obtain ⟨⟨i, a⟩, j, b⟩ := a, b\n  obtain rfl | h := Decidable.eq_or_ne i j\n  · constructor\n    · simp_rw [sigmaLift]\n      simp only [dite_eq_ite, ite_true, mem_map, Embedding.sigmaMk_apply, forall_exists_index,\n        and_imp]\n      rintro x hx rfl\n      exact ⟨rfl, rfl, hx⟩\n    · rintro ⟨⟨⟩, ⟨⟩, hx⟩\n      rw [sigmaLift, dif_pos rfl, mem_map]\n      exact ⟨_, hx, by simp [Sigma.ext_iff]⟩\n  · rw [sigmaLift, dif_neg h]\n    refine iff_of_false (not_mem_empty _) ?_\n    rintro ⟨⟨⟩, ⟨⟩, _⟩\n    exact h rfl\n\n"}
{"name":"Finset.mk_mem_sigmaLift","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : ι → Type u_3\nγ : ι → Type u_4\ninst✝ : DecidableEq ι\nf : ⦃i : ι⦄ → α i → β i → Finset (γ i)\ni : ι\na : α i\nb : β i\nx : γ i\n⊢ Iff (Membership.mem (Finset.sigmaLift f ⟨i, a⟩ ⟨i, b⟩) ⟨i, x⟩) (Membership.mem (f a b) x)","decl":"theorem mk_mem_sigmaLift (f : ∀ ⦃i⦄, α i → β i → Finset (γ i)) (i : ι) (a : α i) (b : β i)\n    (x : γ i) : (⟨i, x⟩ : Sigma γ) ∈ sigmaLift f ⟨i, a⟩ ⟨i, b⟩ ↔ x ∈ f a b := by\n  rw [sigmaLift, dif_pos rfl, mem_map]\n  refine ⟨?_, fun hx => ⟨_, hx, rfl⟩⟩\n  rintro ⟨x, hx, _, rfl⟩\n  exact hx\n\n"}
{"name":"Finset.not_mem_sigmaLift_of_ne_left","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : ι → Type u_3\nγ : ι → Type u_4\ninst✝ : DecidableEq ι\nf : ⦃i : ι⦄ → α i → β i → Finset (γ i)\na : Sigma α\nb : Sigma β\nx : Sigma γ\nh : Ne a.fst x.fst\n⊢ Not (Membership.mem (Finset.sigmaLift f a b) x)","decl":"theorem not_mem_sigmaLift_of_ne_left (f : ∀ ⦃i⦄, α i → β i → Finset (γ i)) (a : Sigma α)\n    (b : Sigma β) (x : Sigma γ) (h : a.1 ≠ x.1) : x ∉ sigmaLift f a b := by\n  rw [mem_sigmaLift]\n  exact fun H => h H.fst\n\n"}
{"name":"Finset.not_mem_sigmaLift_of_ne_right","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : ι → Type u_3\nγ : ι → Type u_4\ninst✝ : DecidableEq ι\nf : ⦃i : ι⦄ → α i → β i → Finset (γ i)\na : Sigma α\nb : Sigma β\nx : Sigma γ\nh : Ne b.fst x.fst\n⊢ Not (Membership.mem (Finset.sigmaLift f a b) x)","decl":"theorem not_mem_sigmaLift_of_ne_right (f : ∀ ⦃i⦄, α i → β i → Finset (γ i)) {a : Sigma α}\n    (b : Sigma β) {x : Sigma γ} (h : b.1 ≠ x.1) : x ∉ sigmaLift f a b := by\n  rw [mem_sigmaLift]\n  exact fun H => h H.snd.fst\n\n"}
{"name":"Finset.sigmaLift_nonempty","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : ι → Type u_3\nγ : ι → Type u_4\ninst✝ : DecidableEq ι\nf : ⦃i : ι⦄ → α i → β i → Finset (γ i)\na : Sigma fun i => α i\nb : Sigma fun i => β i\n⊢ Iff (Finset.sigmaLift f a b).Nonempty (Exists fun h => (f (Eq.rec a.snd h) b.snd).Nonempty)","decl":"theorem sigmaLift_nonempty :\n    (sigmaLift f a b).Nonempty ↔ ∃ h : a.1 = b.1, (f (h ▸ a.2) b.2).Nonempty := by\n  simp_rw [nonempty_iff_ne_empty, sigmaLift]\n  split_ifs with h <;> simp [h]\n\n"}
{"name":"Finset.sigmaLift_eq_empty","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : ι → Type u_3\nγ : ι → Type u_4\ninst✝ : DecidableEq ι\nf : ⦃i : ι⦄ → α i → β i → Finset (γ i)\na : Sigma fun i => α i\nb : Sigma fun i => β i\n⊢ Iff (Eq (Finset.sigmaLift f a b) EmptyCollection.emptyCollection) (∀ (h : Eq a.fst b.fst), Eq (f (Eq.rec a.snd h) b.snd) EmptyCollection.emptyCollection)","decl":"theorem sigmaLift_eq_empty : sigmaLift f a b = ∅ ↔ ∀ h : a.1 = b.1, f (h ▸ a.2) b.2 = ∅ := by\n  simp_rw [sigmaLift]\n  split_ifs with h\n  · simp [h, forall_prop_of_true h]\n  · simp [h, forall_prop_of_false h]\n\n"}
{"name":"Finset.sigmaLift_mono","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : ι → Type u_3\nγ : ι → Type u_4\ninst✝ : DecidableEq ι\nf g : ⦃i : ι⦄ → α i → β i → Finset (γ i)\nh : ∀ ⦃i : ι⦄ ⦃a : α i⦄ ⦃b : β i⦄, HasSubset.Subset (f a b) (g a b)\na : Sigma fun i => α i\nb : Sigma fun i => β i\n⊢ HasSubset.Subset (Finset.sigmaLift f a b) (Finset.sigmaLift g a b)","decl":"theorem sigmaLift_mono (h : ∀ ⦃i⦄ ⦃a : α i⦄ ⦃b : β i⦄, f a b ⊆ g a b) (a : Σi, α i) (b : Σi, β i) :\n    sigmaLift f a b ⊆ sigmaLift g a b := by\n  rintro x hx\n  rw [mem_sigmaLift] at hx ⊢\n  obtain ⟨ha, hb, hx⟩ := hx\n  exact ⟨ha, hb, h hx⟩\n\n"}
{"name":"Finset.card_sigmaLift","module":"Mathlib.Data.Finset.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : ι → Type u_3\nγ : ι → Type u_4\ninst✝ : DecidableEq ι\nf : ⦃i : ι⦄ → α i → β i → Finset (γ i)\na : Sigma fun i => α i\nb : Sigma fun i => β i\n⊢ Eq (Finset.sigmaLift f a b).card (dite (Eq a.fst b.fst) (fun h => (f (Eq.rec a.snd h) b.snd).card) fun x => 0)","decl":"theorem card_sigmaLift :\n    (sigmaLift f a b).card = dite (a.1 = b.1) (fun h => (f (h ▸ a.2) b.2).card) fun _ => 0 := by\n  simp_rw [sigmaLift]\n  split_ifs with h <;> simp [h]\n\n"}
