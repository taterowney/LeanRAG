{"name":"RingHom.Flat.id","module":"Mathlib.RingTheory.RingHom.Flat","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ (RingHom.id R).Flat","decl":"variable (R) in\n/-- The identity of a ring is flat. -/\nlemma id : RingHom.Flat (RingHom.id R) :=\n  Module.Flat.self\n\n"}
{"name":"RingHom.Flat.comp","module":"Mathlib.RingTheory.RingHom.Flat","initialProofState":"R : Type u_1\nS : Type u_2\nT : Type u_3\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : CommRing T\nf : RingHom R S\ng : RingHom S T\nhf : f.Flat\nhg : g.Flat\n⊢ (g.comp f).Flat","decl":"/-- Composition of flat ring homomorphisms is flat. -/\nlemma comp {f : R →+* S} {g : S →+* T} (hf : f.Flat) (hg : g.Flat) : Flat (g.comp f) := by\n  algebraize [f, g, (g.comp f)]\n  exact Module.Flat.trans R S T\n\n"}
{"name":"RingHom.Flat.of_bijective","module":"Mathlib.RingTheory.RingHom.Flat","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nhf : Function.Bijective ⇑f\n⊢ f.Flat","decl":"/-- Bijective ring maps are flat. -/\nlemma of_bijective {f : R →+* S} (hf : Function.Bijective f) : Flat f := by\n  algebraize [f]\n  exact Module.Flat.of_linearEquiv (LinearEquiv.ofBijective (Algebra.linearMap R S) hf).symm\n\n"}
{"name":"RingHom.Flat.containsIdentities","module":"Mathlib.RingTheory.RingHom.Flat","initialProofState":"⊢ RingHom.ContainsIdentities fun {R S} [CommRing R] [CommRing S] => RingHom.Flat","decl":"lemma containsIdentities : ContainsIdentities Flat := id\n\n"}
{"name":"RingHom.Flat.stableUnderComposition","module":"Mathlib.RingTheory.RingHom.Flat","initialProofState":"⊢ RingHom.StableUnderComposition fun {R S} [CommRing R] [CommRing S] => RingHom.Flat","decl":"lemma stableUnderComposition : StableUnderComposition Flat := by\n  introv R hf hg\n  exact hf.comp hg\n\n"}
{"name":"RingHom.Flat.respectsIso","module":"Mathlib.RingTheory.RingHom.Flat","initialProofState":"⊢ RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => RingHom.Flat","decl":"lemma respectsIso : RespectsIso Flat := by\n  apply stableUnderComposition.respectsIso\n  introv\n  exact of_bijective e.bijective\n\n"}
{"name":"RingHom.Flat.isStableUnderBaseChange","module":"Mathlib.RingTheory.RingHom.Flat","initialProofState":"⊢ RingHom.IsStableUnderBaseChange fun {R S} [CommRing R] [CommRing S] => RingHom.Flat","decl":"lemma isStableUnderBaseChange : IsStableUnderBaseChange Flat := by\n  apply IsStableUnderBaseChange.mk _ respectsIso\n  introv h\n  replace h : Module.Flat R T := by\n    rw [RingHom.Flat] at h; convert h; ext; simp_rw [Algebra.smul_def]; rfl\n  suffices Module.Flat S (S ⊗[R] T) by\n    rw [RingHom.Flat]; convert this; congr; ext; simp_rw [Algebra.smul_def]; rfl\n  exact inferInstance\n\n"}
{"name":"RingHom.Flat.holdsForLocalizationAway","module":"Mathlib.RingTheory.RingHom.Flat","initialProofState":"⊢ RingHom.HoldsForLocalizationAway fun {R S} [CommRing R] [CommRing S] => RingHom.Flat","decl":"lemma holdsForLocalizationAway : HoldsForLocalizationAway Flat := by\n  introv R h\n  suffices Module.Flat R S by\n    rw [RingHom.Flat]; convert this; ext; simp_rw [Algebra.smul_def]; rfl\n  exact IsLocalization.flat _ (Submonoid.powers r)\n\n"}
{"name":"RingHom.Flat.ofLocalizationSpanTarget","module":"Mathlib.RingTheory.RingHom.Flat","initialProofState":"⊢ RingHom.OfLocalizationSpanTarget fun {R S} [CommRing R] [CommRing S] => RingHom.Flat","decl":"lemma ofLocalizationSpanTarget : OfLocalizationSpanTarget Flat := by\n  introv R hsp h\n  algebraize_only [f]\n  refine Module.flat_of_isLocalized_span _ _ s hsp _\n    (fun r ↦ Algebra.linearMap S <| Localization.Away r.1) ?_\n  dsimp only [RingHom.Flat] at h\n  convert h; ext\n  apply Algebra.smul_def\n\n"}
{"name":"RingHom.Flat.propertyIsLocal","module":"Mathlib.RingTheory.RingHom.Flat","initialProofState":"⊢ RingHom.PropertyIsLocal fun {R S} [CommRing R] [CommRing S] => RingHom.Flat","decl":"/-- Flat is a local property of ring homomorphisms. -/\nlemma propertyIsLocal : PropertyIsLocal Flat where\n  localizationAwayPreserves := isStableUnderBaseChange.localizationPreserves.away\n  ofLocalizationSpanTarget := ofLocalizationSpanTarget\n  ofLocalizationSpan := ofLocalizationSpanTarget.ofLocalizationSpan\n    (stableUnderComposition.stableUnderCompositionWithLocalizationAway\n      holdsForLocalizationAway).left\n  StableUnderCompositionWithLocalizationAwayTarget :=\n    (stableUnderComposition.stableUnderCompositionWithLocalizationAway\n      holdsForLocalizationAway).right\n\n"}
{"name":"RingHom.Flat.ofLocalizationPrime","module":"Mathlib.RingTheory.RingHom.Flat","initialProofState":"⊢ RingHom.OfLocalizationPrime fun {R S} [CommRing R] [CommRing S] => RingHom.Flat","decl":"lemma ofLocalizationPrime : OfLocalizationPrime Flat := by\n  introv R h\n  algebraize_only [f]\n  rw [RingHom.Flat]\n  apply Module.flat_of_isLocalized_maximal S S (fun P ↦ Localization.AtPrime P)\n    (fun P ↦ Algebra.linearMap S _)\n  intro P _\n  algebraize_only [Localization.localRingHom (Ideal.comap f P) P f rfl]\n  have : IsScalarTower R (Localization.AtPrime (Ideal.comap f P)) (Localization.AtPrime P) :=\n    .of_algebraMap_eq fun x ↦ (Localization.localRingHom_to_map _ _ _ rfl x).symm\n  replace h : Module.Flat (Localization.AtPrime (Ideal.comap f P)) (Localization.AtPrime P) := h ..\n  exact Module.Flat.trans R (Localization.AtPrime <| Ideal.comap f P) (Localization.AtPrime P)\n\n"}
{"name":"RingHom.Flat.localRingHom","module":"Mathlib.RingTheory.RingHom.Flat","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\nf : RingHom R S\nhf : f.Flat\nP : Ideal S\ninst✝¹ : P.IsPrime\nQ : Ideal R\ninst✝ : Q.IsPrime\nhQP : Eq Q (Ideal.comap f P)\n⊢ (Localization.localRingHom Q P f hQP).Flat","decl":"lemma localRingHom {f : R →+* S} (hf : f.Flat)\n    (P : Ideal S) [P.IsPrime] (Q : Ideal R) [Q.IsPrime] (hQP : Q = Ideal.comap f P) :\n    (Localization.localRingHom Q P f hQP).Flat := by\n  subst hQP\n  algebraize [f, Localization.localRingHom (Ideal.comap f P) P f rfl]\n  have : IsScalarTower R (Localization.AtPrime (Ideal.comap f P)) (Localization.AtPrime P) :=\n    .of_algebraMap_eq fun x ↦ (Localization.localRingHom_to_map _ _ _ rfl x).symm\n  rw [RingHom.Flat, Module.flat_iff_of_isLocalization\n    (S := (Localization.AtPrime (Ideal.comap f P))) (p := (Ideal.comap f P).primeCompl)]\n  exact Module.Flat.trans R S (Localization.AtPrime P)\n\n"}
