{"name":"MeasureTheory.FinMeasAdditive.zero","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_7\ninst‚úù : AddCommMonoid Œ≤\n‚ä¢ MeasureTheory.FinMeasAdditive Œº 0","decl":"theorem zero : FinMeasAdditive Œº (0 : Set Œ± ‚Üí Œ≤) := fun _ _ _ _ _ _ _ => by simp\n\n"}
{"name":"MeasureTheory.FinMeasAdditive.add","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_7\ninst‚úù : AddCommMonoid Œ≤\nT T' : Set Œ± ‚Üí Œ≤\nhT : MeasureTheory.FinMeasAdditive Œº T\nhT' : MeasureTheory.FinMeasAdditive Œº T'\n‚ä¢ MeasureTheory.FinMeasAdditive Œº (HAdd.hAdd T T')","decl":"theorem add (hT : FinMeasAdditive Œº T) (hT' : FinMeasAdditive Œº T') :\n    FinMeasAdditive Œº (T + T') := by\n  intro s t hs ht hŒºs hŒºt hst\n  simp only [hT s t hs ht hŒºs hŒºt hst, hT' s t hs ht hŒºs hŒºt hst, Pi.add_apply]\n  abel\n\n"}
{"name":"MeasureTheory.FinMeasAdditive.smul","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nùïú : Type u_6\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_7\ninst‚úù¬≤ : AddCommMonoid Œ≤\nT : Set Œ± ‚Üí Œ≤\ninst‚úù¬π : Monoid ùïú\ninst‚úù : DistribMulAction ùïú Œ≤\nhT : MeasureTheory.FinMeasAdditive Œº T\nc : ùïú\n‚ä¢ MeasureTheory.FinMeasAdditive Œº fun s => HSMul.hSMul c (T s)","decl":"theorem smul [Monoid ùïú] [DistribMulAction ùïú Œ≤] (hT : FinMeasAdditive Œº T) (c : ùïú) :\n    FinMeasAdditive Œº fun s => c ‚Ä¢ T s := fun s t hs ht hŒºs hŒºt hst => by\n  simp [hT s t hs ht hŒºs hŒºt hst]\n\n"}
{"name":"MeasureTheory.FinMeasAdditive.of_eq_top_imp_eq_top","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_7\ninst‚úù : AddCommMonoid Œ≤\nT : Set Œ± ‚Üí Œ≤\nŒº' : MeasureTheory.Measure Œ±\nh : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí Eq (Œº s) Top.top ‚Üí Eq (Œº' s) Top.top\nhT : MeasureTheory.FinMeasAdditive Œº T\n‚ä¢ MeasureTheory.FinMeasAdditive Œº' T","decl":"theorem of_eq_top_imp_eq_top {Œº' : Measure Œ±} (h : ‚àÄ s, MeasurableSet s ‚Üí Œº s = ‚àû ‚Üí Œº' s = ‚àû)\n    (hT : FinMeasAdditive Œº T) : FinMeasAdditive Œº' T := fun s t hs ht hŒº's hŒº't hst =>\n  hT s t hs ht (mt (h s hs) hŒº's) (mt (h t ht) hŒº't) hst\n\n"}
{"name":"MeasureTheory.FinMeasAdditive.of_smul_measure","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_7\ninst‚úù : AddCommMonoid Œ≤\nT : Set Œ± ‚Üí Œ≤\nc : ENNReal\nhc_ne_top : Ne c Top.top\nhT : MeasureTheory.FinMeasAdditive (HSMul.hSMul c Œº) T\n‚ä¢ MeasureTheory.FinMeasAdditive Œº T","decl":"theorem of_smul_measure (c : ‚Ñù‚â•0‚àû) (hc_ne_top : c ‚â† ‚àû) (hT : FinMeasAdditive (c ‚Ä¢ Œº) T) :\n    FinMeasAdditive Œº T := by\n  refine of_eq_top_imp_eq_top (fun s _ hŒºs => ?_) hT\n  rw [Measure.smul_apply, smul_eq_mul, ENNReal.mul_eq_top] at hŒºs\n  simp only [hc_ne_top, or_false, Ne, false_and] at hŒºs\n  exact hŒºs.2\n\n"}
{"name":"MeasureTheory.FinMeasAdditive.smul_measure","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_7\ninst‚úù : AddCommMonoid Œ≤\nT : Set Œ± ‚Üí Œ≤\nc : ENNReal\nhc_ne_zero : Ne c 0\nhT : MeasureTheory.FinMeasAdditive Œº T\n‚ä¢ MeasureTheory.FinMeasAdditive (HSMul.hSMul c Œº) T","decl":"theorem smul_measure (c : ‚Ñù‚â•0‚àû) (hc_ne_zero : c ‚â† 0) (hT : FinMeasAdditive Œº T) :\n    FinMeasAdditive (c ‚Ä¢ Œº) T := by\n  refine of_eq_top_imp_eq_top (fun s _ hŒºs => ?_) hT\n  rw [Measure.smul_apply, smul_eq_mul, ENNReal.mul_eq_top]\n  simp only [hc_ne_zero, true_and, Ne, not_false_iff]\n  exact Or.inl hŒºs\n\n"}
{"name":"MeasureTheory.FinMeasAdditive.smul_measure_iff","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_7\ninst‚úù : AddCommMonoid Œ≤\nT : Set Œ± ‚Üí Œ≤\nc : ENNReal\nhc_ne_zero : Ne c 0\nhc_ne_top : Ne c Top.top\n‚ä¢ Iff (MeasureTheory.FinMeasAdditive (HSMul.hSMul c Œº) T) (MeasureTheory.FinMeasAdditive Œº T)","decl":"theorem smul_measure_iff (c : ‚Ñù‚â•0‚àû) (hc_ne_zero : c ‚â† 0) (hc_ne_top : c ‚â† ‚àû) :\n    FinMeasAdditive (c ‚Ä¢ Œº) T ‚Üî FinMeasAdditive Œº T :=\n  ‚ü®fun hT => of_smul_measure c hc_ne_top hT, fun hT => smul_measure c hc_ne_zero hT‚ü©\n\n"}
{"name":"MeasureTheory.FinMeasAdditive.map_empty_eq_zero","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_8\ninst‚úù : AddCancelMonoid Œ≤\nT : Set Œ± ‚Üí Œ≤\nhT : MeasureTheory.FinMeasAdditive Œº T\n‚ä¢ Eq (T EmptyCollection.emptyCollection) 0","decl":"theorem map_empty_eq_zero {Œ≤} [AddCancelMonoid Œ≤] {T : Set Œ± ‚Üí Œ≤} (hT : FinMeasAdditive Œº T) :\n    T ‚àÖ = 0 := by\n  have h_empty : Œº ‚àÖ ‚â† ‚àû := (measure_empty.le.trans_lt ENNReal.coe_lt_top).ne\n  specialize hT ‚àÖ ‚àÖ MeasurableSet.empty MeasurableSet.empty h_empty h_empty (disjoint_empty _)\n  rw [Set.union_empty] at hT\n  nth_rw 1 [‚Üê add_zero (T ‚àÖ)] at hT\n  exact (add_left_cancel hT).symm\n\n"}
{"name":"MeasureTheory.FinMeasAdditive.map_iUnion_fin_meas_set_eq_sum","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_7\ninst‚úù : AddCommMonoid Œ≤\nT : Set Œ± ‚Üí Œ≤\nT_empty : Eq (T EmptyCollection.emptyCollection) 0\nh_add : MeasureTheory.FinMeasAdditive Œº T\nŒπ : Type u_8\nS : Œπ ‚Üí Set Œ±\nsŒπ : Finset Œπ\nhS_meas : ‚àÄ (i : Œπ), MeasurableSet (S i)\nhSp : ‚àÄ (i : Œπ), Membership.mem sŒπ i ‚Üí Ne (Œº (S i)) Top.top\nh_disj : ‚àÄ (i : Œπ), Membership.mem sŒπ i ‚Üí ‚àÄ (j : Œπ), Membership.mem sŒπ j ‚Üí Ne i j ‚Üí Disjoint (S i) (S j)\n‚ä¢ Eq (T (Set.iUnion fun i => Set.iUnion fun h => S i)) (sŒπ.sum fun i => T (S i))","decl":"theorem map_iUnion_fin_meas_set_eq_sum (T : Set Œ± ‚Üí Œ≤) (T_empty : T ‚àÖ = 0)\n    (h_add : FinMeasAdditive Œº T) {Œπ} (S : Œπ ‚Üí Set Œ±) (sŒπ : Finset Œπ)\n    (hS_meas : ‚àÄ i, MeasurableSet (S i)) (hSp : ‚àÄ i ‚àà sŒπ, Œº (S i) ‚â† ‚àû)\n    (h_disj : ‚àÄ·µâ (i ‚àà sŒπ) (j ‚àà sŒπ), i ‚â† j ‚Üí Disjoint (S i) (S j)) :\n    T (‚ãÉ i ‚àà sŒπ, S i) = ‚àë i ‚àà sŒπ, T (S i) := by\n  classical\n  revert hSp h_disj\n  refine Finset.induction_on sŒπ ?_ ?_\n  ¬∑ simp only [Finset.not_mem_empty, IsEmpty.forall_iff, iUnion_false, iUnion_empty, sum_empty,\n      forall‚ÇÇ_true_iff, imp_true_iff, forall_true_left, not_false_iff, T_empty]\n  intro a s has h hps h_disj\n  rw [Finset.sum_insert has, ‚Üê h]\n  swap; ¬∑ exact fun i hi => hps i (Finset.mem_insert_of_mem hi)\n  swap\n  ¬∑ exact fun i hi j hj hij =>\n      h_disj i (Finset.mem_insert_of_mem hi) j (Finset.mem_insert_of_mem hj) hij\n  rw [‚Üê\n    h_add (S a) (‚ãÉ i ‚àà s, S i) (hS_meas a) (measurableSet_biUnion _ fun i _ => hS_meas i)\n      (hps a (Finset.mem_insert_self a s))]\n  ¬∑ congr; convert Finset.iSup_insert a s S\n  ¬∑ exact (measure_biUnion_lt_top s.finite_toSet fun i hi ‚Ü¶\n      (hps i <| Finset.mem_insert_of_mem hi).lt_top).ne\n  ¬∑ simp_rw [Set.disjoint_iUnion_right]\n    intro i hi\n    refine h_disj a (Finset.mem_insert_self a s) i (Finset.mem_insert_of_mem hi) fun hai ‚Ü¶ ?_\n    rw [‚Üê hai] at hi\n    exact has hi\n\n"}
{"name":"MeasureTheory.DominatedFinMeasAdditive.zero","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_7\ninst‚úù : SeminormedAddCommGroup Œ≤\nC : Real\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nhC : LE.le 0 C\n‚ä¢ MeasureTheory.DominatedFinMeasAdditive Œº 0 C","decl":"theorem zero {m : MeasurableSpace Œ±} (Œº : Measure Œ±) (hC : 0 ‚â§ C) :\n    DominatedFinMeasAdditive Œº (0 : Set Œ± ‚Üí Œ≤) C := by\n  refine ‚ü®FinMeasAdditive.zero, fun s _ _ => ?_‚ü©\n  rw [Pi.zero_apply, norm_zero]\n  exact mul_nonneg hC toReal_nonneg\n\n"}
{"name":"MeasureTheory.DominatedFinMeasAdditive.eq_zero_of_measure_zero","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_8\ninst‚úù : NormedAddCommGroup Œ≤\nT : Set Œ± ‚Üí Œ≤\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\ns : Set Œ±\nhs : MeasurableSet s\nhs_zero : Eq (Œº s) 0\n‚ä¢ Eq (T s) 0","decl":"theorem eq_zero_of_measure_zero {Œ≤ : Type*} [NormedAddCommGroup Œ≤] {T : Set Œ± ‚Üí Œ≤} {C : ‚Ñù}\n    (hT : DominatedFinMeasAdditive Œº T C) {s : Set Œ±} (hs : MeasurableSet s) (hs_zero : Œº s = 0) :\n    T s = 0 := by\n  refine norm_eq_zero.mp ?_\n  refine ((hT.2 s hs (by simp [hs_zero])).trans (le_of_eq ?_)).antisymm (norm_nonneg _)\n  rw [hs_zero, ENNReal.zero_toReal, mul_zero]\n\n"}
{"name":"MeasureTheory.DominatedFinMeasAdditive.eq_zero","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_8\ninst‚úù : NormedAddCommGroup Œ≤\nT : Set Œ± ‚Üí Œ≤\nC : Real\nx‚úù : MeasurableSpace Œ±\nhT : MeasureTheory.DominatedFinMeasAdditive 0 T C\ns : Set Œ±\nhs : MeasurableSet s\n‚ä¢ Eq (T s) 0","decl":"theorem eq_zero {Œ≤ : Type*} [NormedAddCommGroup Œ≤] {T : Set Œ± ‚Üí Œ≤} {C : ‚Ñù} {_ : MeasurableSpace Œ±}\n    (hT : DominatedFinMeasAdditive (0 : Measure Œ±) T C) {s : Set Œ±} (hs : MeasurableSet s) :\n    T s = 0 :=\n  eq_zero_of_measure_zero hT hs (by simp only [Measure.coe_zero, Pi.zero_apply])\n\n"}
{"name":"MeasureTheory.DominatedFinMeasAdditive.add","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_7\ninst‚úù : SeminormedAddCommGroup Œ≤\nT T' : Set Œ± ‚Üí Œ≤\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº T' C'\n‚ä¢ MeasureTheory.DominatedFinMeasAdditive Œº (HAdd.hAdd T T') (HAdd.hAdd C C')","decl":"theorem add (hT : DominatedFinMeasAdditive Œº T C) (hT' : DominatedFinMeasAdditive Œº T' C') :\n    DominatedFinMeasAdditive Œº (T + T') (C + C') := by\n  refine ‚ü®hT.1.add hT'.1, fun s hs hŒºs => ?_‚ü©\n  rw [Pi.add_apply, add_mul]\n  exact (norm_add_le _ _).trans (add_le_add (hT.2 s hs hŒºs) (hT'.2 s hs hŒºs))\n\n"}
{"name":"MeasureTheory.DominatedFinMeasAdditive.smul","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nùïú : Type u_6\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_7\ninst‚úù¬≤ : SeminormedAddCommGroup Œ≤\nT : Set Œ± ‚Üí Œ≤\nC : Real\ninst‚úù¬π : NormedField ùïú\ninst‚úù : NormedSpace ùïú Œ≤\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nc : ùïú\n‚ä¢ MeasureTheory.DominatedFinMeasAdditive Œº (fun s => HSMul.hSMul c (T s)) (HMul.hMul (Norm.norm c) C)","decl":"theorem smul [NormedField ùïú] [NormedSpace ùïú Œ≤] (hT : DominatedFinMeasAdditive Œº T C) (c : ùïú) :\n    DominatedFinMeasAdditive Œº (fun s => c ‚Ä¢ T s) (‚Äñc‚Äñ * C) := by\n  refine ‚ü®hT.1.smul c, fun s hs hŒºs => ?_‚ü©\n  dsimp only\n  rw [norm_smul, mul_assoc]\n  exact mul_le_mul le_rfl (hT.2 s hs hŒºs) (norm_nonneg _) (norm_nonneg _)\n\n"}
{"name":"MeasureTheory.DominatedFinMeasAdditive.of_measure_le","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_7\ninst‚úù : SeminormedAddCommGroup Œ≤\nT : Set Œ± ‚Üí Œ≤\nC : Real\nŒº' : MeasureTheory.Measure Œ±\nh : LE.le Œº Œº'\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhC : LE.le 0 C\n‚ä¢ MeasureTheory.DominatedFinMeasAdditive Œº' T C","decl":"theorem of_measure_le {Œº' : Measure Œ±} (h : Œº ‚â§ Œº') (hT : DominatedFinMeasAdditive Œº T C)\n    (hC : 0 ‚â§ C) : DominatedFinMeasAdditive Œº' T C := by\n  have h' : ‚àÄ s, Œº s = ‚àû ‚Üí Œº' s = ‚àû := fun s hs ‚Ü¶ top_unique <| hs.symm.trans_le (h _)\n  refine ‚ü®hT.1.of_eq_top_imp_eq_top fun s _ ‚Ü¶ h' s, fun s hs hŒº's ‚Ü¶ ?_‚ü©\n  have hŒºs : Œº s < ‚àû := (h s).trans_lt hŒº's\n  calc\n    ‚ÄñT s‚Äñ ‚â§ C * (Œº s).toReal := hT.2 s hs hŒºs\n    _ ‚â§ C * (Œº' s).toReal := by gcongr; exacts [hŒº's.ne, h _]\n\n"}
{"name":"MeasureTheory.DominatedFinMeasAdditive.add_measure_right","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_7\ninst‚úù : SeminormedAddCommGroup Œ≤\nT : Set Œ± ‚Üí Œ≤\nC : Real\nx‚úù : MeasurableSpace Œ±\nŒº ŒΩ : MeasureTheory.Measure Œ±\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhC : LE.le 0 C\n‚ä¢ MeasureTheory.DominatedFinMeasAdditive (HAdd.hAdd Œº ŒΩ) T C","decl":"theorem add_measure_right {_ : MeasurableSpace Œ±} (Œº ŒΩ : Measure Œ±)\n    (hT : DominatedFinMeasAdditive Œº T C) (hC : 0 ‚â§ C) : DominatedFinMeasAdditive (Œº + ŒΩ) T C :=\n  of_measure_le (Measure.le_add_right le_rfl) hT hC\n\n"}
{"name":"MeasureTheory.DominatedFinMeasAdditive.add_measure_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_7\ninst‚úù : SeminormedAddCommGroup Œ≤\nT : Set Œ± ‚Üí Œ≤\nC : Real\nx‚úù : MeasurableSpace Œ±\nŒº ŒΩ : MeasureTheory.Measure Œ±\nhT : MeasureTheory.DominatedFinMeasAdditive ŒΩ T C\nhC : LE.le 0 C\n‚ä¢ MeasureTheory.DominatedFinMeasAdditive (HAdd.hAdd Œº ŒΩ) T C","decl":"theorem add_measure_left {_ : MeasurableSpace Œ±} (Œº ŒΩ : Measure Œ±)\n    (hT : DominatedFinMeasAdditive ŒΩ T C) (hC : 0 ‚â§ C) : DominatedFinMeasAdditive (Œº + ŒΩ) T C :=\n  of_measure_le (Measure.le_add_left le_rfl) hT hC\n\n"}
{"name":"MeasureTheory.DominatedFinMeasAdditive.of_smul_measure","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_7\ninst‚úù : SeminormedAddCommGroup Œ≤\nT : Set Œ± ‚Üí Œ≤\nC : Real\nc : ENNReal\nhc_ne_top : Ne c Top.top\nhT : MeasureTheory.DominatedFinMeasAdditive (HSMul.hSMul c Œº) T C\n‚ä¢ MeasureTheory.DominatedFinMeasAdditive Œº T (HMul.hMul c.toReal C)","decl":"theorem of_smul_measure (c : ‚Ñù‚â•0‚àû) (hc_ne_top : c ‚â† ‚àû) (hT : DominatedFinMeasAdditive (c ‚Ä¢ Œº) T C) :\n    DominatedFinMeasAdditive Œº T (c.toReal * C) := by\n  have h : ‚àÄ s, MeasurableSet s ‚Üí c ‚Ä¢ Œº s = ‚àû ‚Üí Œº s = ‚àû := by\n    intro s _ hcŒºs\n    simp only [hc_ne_top, Algebra.id.smul_eq_mul, ENNReal.mul_eq_top, or_false, Ne,\n      false_and] at hcŒºs\n    exact hcŒºs.2\n  refine ‚ü®hT.1.of_eq_top_imp_eq_top (Œº := c ‚Ä¢ Œº) h, fun s hs hŒºs => ?_‚ü©\n  have hcŒºs : c ‚Ä¢ Œº s ‚â† ‚àû := mt (h s hs) hŒºs.ne\n  rw [smul_eq_mul] at hcŒºs\n  simp_rw [DominatedFinMeasAdditive, Measure.smul_apply, smul_eq_mul, toReal_mul] at hT\n  refine (hT.2 s hs hcŒºs.lt_top).trans (le_of_eq ?_)\n  ring\n\n"}
{"name":"MeasureTheory.DominatedFinMeasAdditive.of_measure_le_smul","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_7\ninst‚úù : SeminormedAddCommGroup Œ≤\nT : Set Œ± ‚Üí Œ≤\nC : Real\nŒº' : MeasureTheory.Measure Œ±\nc : ENNReal\nhc : Ne c Top.top\nh : LE.le Œº (HSMul.hSMul c Œº')\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhC : LE.le 0 C\n‚ä¢ MeasureTheory.DominatedFinMeasAdditive Œº' T (HMul.hMul c.toReal C)","decl":"theorem of_measure_le_smul {Œº' : Measure Œ±} (c : ‚Ñù‚â•0‚àû) (hc : c ‚â† ‚àû) (h : Œº ‚â§ c ‚Ä¢ Œº')\n    (hT : DominatedFinMeasAdditive Œº T C) (hC : 0 ‚â§ C) :\n    DominatedFinMeasAdditive Œº' T (c.toReal * C) :=\n  (hT.of_measure_le h hC).of_smul_measure c hc\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_zero","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nF : Type u_3\nF' : Type u_4\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace Real F\ninst‚úù¬π : NormedAddCommGroup F'\ninst‚úù : NormedSpace Real F'\nm : MeasurableSpace Œ±\nf : MeasureTheory.SimpleFunc Œ± F\n‚ä¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc 0 f) 0","decl":"@[simp]\ntheorem setToSimpleFunc_zero {m : MeasurableSpace Œ±} (f : Œ± ‚Üí‚Çõ F) :\n    setToSimpleFunc (0 : Set Œ± ‚Üí F ‚ÜíL[‚Ñù] F') f = 0 := by simp [setToSimpleFunc]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_zero'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF' : Type u_4\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F'\ninst‚úù : NormedSpace Real F'\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F'\nh_zero : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí Eq (T s) 0\nf : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Integrable (‚áëf) Œº\n‚ä¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T f) 0","decl":"theorem setToSimpleFunc_zero' {T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F'}\n    (h_zero : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí T s = 0) (f : Œ± ‚Üí‚Çõ E) (hf : Integrable f Œº) :\n    setToSimpleFunc T f = 0 := by\n  simp_rw [setToSimpleFunc]\n  refine sum_eq_zero fun x _ => ?_\n  by_cases hx0 : x = 0\n  ¬∑ simp [hx0]\n  rw [h_zero (f ‚Åª¬π' ({x} : Set E)) (measurableSet_fiber _ _)\n      (measure_preimage_lt_top_of_integrable f hf hx0),\n    ContinuousLinearMap.zero_apply]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_zero_apply","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nF : Type u_3\nF' : Type u_4\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace Real F\ninst‚úù¬π : NormedAddCommGroup F'\ninst‚úù : NormedSpace Real F'\nm : MeasurableSpace Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) F F'\n‚ä¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T 0) 0","decl":"@[simp]\ntheorem setToSimpleFunc_zero_apply {m : MeasurableSpace Œ±} (T : Set Œ± ‚Üí F ‚ÜíL[‚Ñù] F') :\n    setToSimpleFunc T (0 : Œ± ‚Üí‚Çõ F) = 0 := by\n  cases isEmpty_or_nonempty Œ± <;> simp [setToSimpleFunc]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_eq_sum_filter","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nF : Type u_3\nF' : Type u_4\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : NormedAddCommGroup F'\ninst‚úù¬π : NormedSpace Real F'\ninst‚úù : DecidablePred fun x => Ne x 0\nm : MeasurableSpace Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) F F'\nf : MeasureTheory.SimpleFunc Œ± F\n‚ä¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T f) ((Finset.filter (fun x => Ne x 0) f.range).sum fun x => (T (Set.preimage (‚áëf) (Singleton.singleton x))) x)","decl":"theorem setToSimpleFunc_eq_sum_filter [DecidablePred fun x ‚Ü¶ x ‚â† (0 : F)]\n    {m : MeasurableSpace Œ±} (T : Set Œ± ‚Üí F ‚ÜíL[‚Ñù] F') (f : Œ± ‚Üí‚Çõ F) :\n    setToSimpleFunc T f = ‚àë x ‚àà f.range with x ‚â† 0, T (f ‚Åª¬π' {x}) x := by\n  symm\n  refine sum_filter_of_ne fun x _ => mt fun hx0 => ?_\n  rw [hx0]\n  exact ContinuousLinearMap.map_zero _\n\n"}
{"name":"MeasureTheory.SimpleFunc.map_setToSimpleFunc","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nF : Type u_3\nF' : Type u_4\nG : Type u_5\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : NormedAddCommGroup F'\ninst‚úù¬π : NormedSpace Real F'\ninst‚úù : NormedAddCommGroup G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) F F'\nh_add : MeasureTheory.FinMeasAdditive Œº T\nf : MeasureTheory.SimpleFunc Œ± G\nhf : MeasureTheory.Integrable (‚áëf) Œº\ng : G ‚Üí F\nhg : Eq (g 0) 0\n‚ä¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T (MeasureTheory.SimpleFunc.map g f)) (f.range.sum fun x => (T (Set.preimage (‚áëf) (Singleton.singleton x))) (g x))","decl":"theorem map_setToSimpleFunc (T : Set Œ± ‚Üí F ‚ÜíL[‚Ñù] F') (h_add : FinMeasAdditive Œº T) {f : Œ± ‚Üí‚Çõ G}\n    (hf : Integrable f Œº) {g : G ‚Üí F} (hg : g 0 = 0) :\n    (f.map g).setToSimpleFunc T = ‚àë x ‚àà f.range, T (f ‚Åª¬π' {x}) (g x) := by\n  classical\n  have T_empty : T ‚àÖ = 0 := h_add.map_empty_eq_zero\n  have hfp : ‚àÄ x ‚àà f.range, x ‚â† 0 ‚Üí Œº (f ‚Åª¬π' {x}) ‚â† ‚àû := fun x _ hx0 =>\n    (measure_preimage_lt_top_of_integrable f hf hx0).ne\n  simp only [setToSimpleFunc, range_map]\n  refine Finset.sum_image' _ fun b hb => ?_\n  rcases mem_range.1 hb with ‚ü®a, rfl‚ü©\n  by_cases h0 : g (f a) = 0\n  ¬∑ simp_rw [h0]\n    rw [ContinuousLinearMap.map_zero, Finset.sum_eq_zero fun x hx => ?_]\n    rw [mem_filter] at hx\n    rw [hx.2, ContinuousLinearMap.map_zero]\n  have h_left_eq :\n    T (map g f ‚Åª¬π' {g (f a)}) (g (f a))\n      = T (f ‚Åª¬π' ({b ‚àà f.range | g b = g (f a)} : Finset _)) (g (f a)) := by\n    congr; rw [map_preimage_singleton]\n  rw [h_left_eq]\n  have h_left_eq' :\n    T (f ‚Åª¬π' ({b ‚àà f.range | g b = g (f a)} : Finset _)) (g (f a))\n      = T (‚ãÉ y ‚àà {b ‚àà f.range | g b = g (f a)}, f ‚Åª¬π' {y}) (g (f a)) := by\n    congr; rw [‚Üê Finset.set_biUnion_preimage_singleton]\n  rw [h_left_eq']\n  rw [h_add.map_iUnion_fin_meas_set_eq_sum T T_empty]\n  ¬∑ simp only [sum_apply, ContinuousLinearMap.coe_sum']\n    refine Finset.sum_congr rfl fun x hx => ?_\n    rw [mem_filter] at hx\n    rw [hx.2]\n  ¬∑ exact fun i => measurableSet_fiber _ _\n  ¬∑ intro i hi\n    rw [mem_filter] at hi\n    refine hfp i hi.1 fun hi0 => ?_\n    rw [hi0, hg] at hi\n    exact h0 hi.2.symm\n  ¬∑ intro i _j hi _ hij\n    rw [Set.disjoint_iff]\n    intro x hx\n    rw [Set.mem_inter_iff, Set.mem_preimage, Set.mem_preimage, Set.mem_singleton_iff,\n      Set.mem_singleton_iff] at hx\n    rw [‚Üê hx.1, ‚Üê hx.2] at hij\n    exact absurd rfl hij\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_congr'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nh_add : MeasureTheory.FinMeasAdditive Œº T\nf g : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Integrable (‚áëf) Œº\nhg : MeasureTheory.Integrable (‚áëg) Œº\nh : Pairwise fun x y => Eq (T (Inter.inter (Set.preimage (‚áëf) (Singleton.singleton x)) (Set.preimage (‚áëg) (Singleton.singleton y)))) 0\n‚ä¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T f) (MeasureTheory.SimpleFunc.setToSimpleFunc T g)","decl":"theorem setToSimpleFunc_congr' (T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F) (h_add : FinMeasAdditive Œº T) {f g : Œ± ‚Üí‚Çõ E}\n    (hf : Integrable f Œº) (hg : Integrable g Œº)\n    (h : Pairwise fun x y => T (f ‚Åª¬π' {x} ‚à© g ‚Åª¬π' {y}) = 0) :\n    f.setToSimpleFunc T = g.setToSimpleFunc T :=\n  show ((pair f g).map Prod.fst).setToSimpleFunc T = ((pair f g).map Prod.snd).setToSimpleFunc T by\n    have h_pair : Integrable (f.pair g) Œº := integrable_pair hf hg\n    rw [map_setToSimpleFunc T h_add h_pair Prod.fst_zero]\n    rw [map_setToSimpleFunc T h_add h_pair Prod.snd_zero]\n    refine Finset.sum_congr rfl fun p hp => ?_\n    rcases mem_range.1 hp with ‚ü®a, rfl‚ü©\n    by_cases eq : f a = g a\n    ¬∑ dsimp only [pair_apply]; rw [eq]\n    ¬∑ have : T (pair f g ‚Åª¬π' {(f a, g a)}) = 0 := by\n        have h_eq : T ((‚áë(f.pair g)) ‚Åª¬π' {(f a, g a)}) = T (f ‚Åª¬π' {f a} ‚à© g ‚Åª¬π' {g a}) := by\n          congr; rw [pair_preimage_singleton f g]\n        rw [h_eq]\n        exact h eq\n      simp only [this, ContinuousLinearMap.zero_apply, pair_apply]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_congr","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nh_zero : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí Eq (Œº s) 0 ‚Üí Eq (T s) 0\nh_add : MeasureTheory.FinMeasAdditive Œº T\nf g : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Integrable (‚áëf) Œº\nh : (MeasureTheory.ae Œº).EventuallyEq ‚áëf ‚áëg\n‚ä¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T f) (MeasureTheory.SimpleFunc.setToSimpleFunc T g)","decl":"theorem setToSimpleFunc_congr (T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F)\n    (h_zero : ‚àÄ s, MeasurableSet s ‚Üí Œº s = 0 ‚Üí T s = 0) (h_add : FinMeasAdditive Œº T) {f g : Œ± ‚Üí‚Çõ E}\n    (hf : Integrable f Œº) (h : f =·µê[Œº] g) : f.setToSimpleFunc T = g.setToSimpleFunc T := by\n  refine setToSimpleFunc_congr' T h_add hf ((integrable_congr h).mp hf) ?_\n  refine fun x y hxy => h_zero _ ((measurableSet_fiber f x).inter (measurableSet_fiber g y)) ?_\n  rw [EventuallyEq, ae_iff] at h\n  refine measure_mono_null (fun z => ?_) h\n  simp_rw [Set.mem_inter_iff, Set.mem_setOf_eq, Set.mem_preimage, Set.mem_singleton_iff]\n  intro h\n  rwa [h.1, h.2]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_congr_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nh : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí Eq (T s) (T' s)\nf : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Integrable (‚áëf) Œº\n‚ä¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T f) (MeasureTheory.SimpleFunc.setToSimpleFunc T' f)","decl":"theorem setToSimpleFunc_congr_left (T T' : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F)\n    (h : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí T s = T' s) (f : Œ± ‚Üí‚Çõ E) (hf : Integrable f Œº) :\n    setToSimpleFunc T f = setToSimpleFunc T' f := by\n  simp_rw [setToSimpleFunc]\n  refine sum_congr rfl fun x _ => ?_\n  by_cases hx0 : x = 0\n  ¬∑ simp [hx0]\n  ¬∑ rw [h (f ‚Åª¬π' {x}) (SimpleFunc.measurableSet_fiber _ _)\n        (SimpleFunc.measure_preimage_lt_top_of_integrable _ hf hx0)]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_add_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nF : Type u_3\nF' : Type u_4\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace Real F\ninst‚úù¬π : NormedAddCommGroup F'\ninst‚úù : NormedSpace Real F'\nm : MeasurableSpace Œ±\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) F F'\nf : MeasureTheory.SimpleFunc Œ± F\n‚ä¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc (HAdd.hAdd T T') f) (HAdd.hAdd (MeasureTheory.SimpleFunc.setToSimpleFunc T f) (MeasureTheory.SimpleFunc.setToSimpleFunc T' f))","decl":"theorem setToSimpleFunc_add_left {m : MeasurableSpace Œ±} (T T' : Set Œ± ‚Üí F ‚ÜíL[‚Ñù] F') {f : Œ± ‚Üí‚Çõ F} :\n    setToSimpleFunc (T + T') f = setToSimpleFunc T f + setToSimpleFunc T' f := by\n  simp_rw [setToSimpleFunc, Pi.add_apply]\n  push_cast\n  simp_rw [Pi.add_apply, sum_add_distrib]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_add_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT T' T'' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nh_add : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí Eq (T'' s) (HAdd.hAdd (T s) (T' s))\nf : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Integrable (‚áëf) Œº\n‚ä¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T'' f) (HAdd.hAdd (MeasureTheory.SimpleFunc.setToSimpleFunc T f) (MeasureTheory.SimpleFunc.setToSimpleFunc T' f))","decl":"theorem setToSimpleFunc_add_left' (T T' T'' : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F)\n    (h_add : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí T'' s = T s + T' s) {f : Œ± ‚Üí‚Çõ E}\n    (hf : Integrable f Œº) : setToSimpleFunc T'' f = setToSimpleFunc T f + setToSimpleFunc T' f := by\n  classical\n  simp_rw [setToSimpleFunc_eq_sum_filter]\n  suffices\n    ‚àÄ x ‚àà {x ‚àà f.range | x ‚â† 0}, T'' (f ‚Åª¬π' {x}) = T (f ‚Åª¬π' {x}) + T' (f ‚Åª¬π' {x}) by\n    rw [‚Üê sum_add_distrib]\n    refine Finset.sum_congr rfl fun x hx => ?_\n    rw [this x hx]\n    push_cast\n    rw [Pi.add_apply]\n  intro x hx\n  refine\n    h_add (f ‚Åª¬π' {x}) (measurableSet_preimage _ _) (measure_preimage_lt_top_of_integrable _ hf ?_)\n  rw [mem_filter] at hx\n  exact hx.2\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_smul_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nF : Type u_3\nF' : Type u_4\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace Real F\ninst‚úù¬π : NormedAddCommGroup F'\ninst‚úù : NormedSpace Real F'\nm : MeasurableSpace Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) F F'\nc : Real\nf : MeasureTheory.SimpleFunc Œ± F\n‚ä¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc (fun s => HSMul.hSMul c (T s)) f) (HSMul.hSMul c (MeasureTheory.SimpleFunc.setToSimpleFunc T f))","decl":"theorem setToSimpleFunc_smul_left {m : MeasurableSpace Œ±} (T : Set Œ± ‚Üí F ‚ÜíL[‚Ñù] F') (c : ‚Ñù)\n    (f : Œ± ‚Üí‚Çõ F) : setToSimpleFunc (fun s => c ‚Ä¢ T s) f = c ‚Ä¢ setToSimpleFunc T f := by\n  simp_rw [setToSimpleFunc, ContinuousLinearMap.smul_apply, smul_sum]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_smul_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF' : Type u_4\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F'\ninst‚úù : NormedSpace Real F'\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F'\nc : Real\nh_smul : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí Eq (T' s) (HSMul.hSMul c (T s))\nf : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Integrable (‚áëf) Œº\n‚ä¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T' f) (HSMul.hSMul c (MeasureTheory.SimpleFunc.setToSimpleFunc T f))","decl":"theorem setToSimpleFunc_smul_left' (T T' : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F') (c : ‚Ñù)\n    (h_smul : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí T' s = c ‚Ä¢ T s) {f : Œ± ‚Üí‚Çõ E} (hf : Integrable f Œº) :\n    setToSimpleFunc T' f = c ‚Ä¢ setToSimpleFunc T f := by\n  classical\n  simp_rw [setToSimpleFunc_eq_sum_filter]\n  suffices ‚àÄ x ‚àà {x ‚àà f.range | x ‚â† 0}, T' (f ‚Åª¬π' {x}) = c ‚Ä¢ T (f ‚Åª¬π' {x}) by\n    rw [smul_sum]\n    refine Finset.sum_congr rfl fun x hx => ?_\n    rw [this x hx]\n    rfl\n  intro x hx\n  refine\n    h_smul (f ‚Åª¬π' {x}) (measurableSet_preimage _ _) (measure_preimage_lt_top_of_integrable _ hf ?_)\n  rw [mem_filter] at hx\n  exact hx.2\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_add","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nh_add : MeasureTheory.FinMeasAdditive Œº T\nf g : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Integrable (‚áëf) Œº\nhg : MeasureTheory.Integrable (‚áëg) Œº\n‚ä¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T (HAdd.hAdd f g)) (HAdd.hAdd (MeasureTheory.SimpleFunc.setToSimpleFunc T f) (MeasureTheory.SimpleFunc.setToSimpleFunc T g))","decl":"theorem setToSimpleFunc_add (T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F) (h_add : FinMeasAdditive Œº T) {f g : Œ± ‚Üí‚Çõ E}\n    (hf : Integrable f Œº) (hg : Integrable g Œº) :\n    setToSimpleFunc T (f + g) = setToSimpleFunc T f + setToSimpleFunc T g :=\n  have hp_pair : Integrable (f.pair g) Œº := integrable_pair hf hg\n  calc\n    setToSimpleFunc T (f + g) = ‚àë x ‚àà (pair f g).range, T (pair f g ‚Åª¬π' {x}) (x.fst + x.snd) := by\n      rw [add_eq_map‚ÇÇ, map_setToSimpleFunc T h_add hp_pair]; simp\n    _ = ‚àë x ‚àà (pair f g).range, (T (pair f g ‚Åª¬π' {x}) x.fst + T (pair f g ‚Åª¬π' {x}) x.snd) :=\n      (Finset.sum_congr rfl fun _ _ => ContinuousLinearMap.map_add _ _ _)\n    _ = (‚àë x ‚àà (pair f g).range, T (pair f g ‚Åª¬π' {x}) x.fst) +\n          ‚àë x ‚àà (pair f g).range, T (pair f g ‚Åª¬π' {x}) x.snd := by\n      rw [Finset.sum_add_distrib]\n    _ = ((pair f g).map Prod.fst).setToSimpleFunc T +\n          ((pair f g).map Prod.snd).setToSimpleFunc T := by\n      rw [map_setToSimpleFunc T h_add hp_pair Prod.snd_zero,\n        map_setToSimpleFunc T h_add hp_pair Prod.fst_zero]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_neg","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nh_add : MeasureTheory.FinMeasAdditive Œº T\nf : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Integrable (‚áëf) Œº\n‚ä¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T (Neg.neg f)) (Neg.neg (MeasureTheory.SimpleFunc.setToSimpleFunc T f))","decl":"theorem setToSimpleFunc_neg (T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F) (h_add : FinMeasAdditive Œº T) {f : Œ± ‚Üí‚Çõ E}\n    (hf : Integrable f Œº) : setToSimpleFunc T (-f) = -setToSimpleFunc T f :=\n  calc\n    setToSimpleFunc T (-f) = setToSimpleFunc T (f.map Neg.neg) := rfl\n    _ = -setToSimpleFunc T f := by\n      rw [map_setToSimpleFunc T h_add hf neg_zero, setToSimpleFunc, ‚Üê sum_neg_distrib]\n      exact Finset.sum_congr rfl fun x _ => ContinuousLinearMap.map_neg _ _\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_sub","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nh_add : MeasureTheory.FinMeasAdditive Œº T\nf g : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Integrable (‚áëf) Œº\nhg : MeasureTheory.Integrable (‚áëg) Œº\n‚ä¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T (HSub.hSub f g)) (HSub.hSub (MeasureTheory.SimpleFunc.setToSimpleFunc T f) (MeasureTheory.SimpleFunc.setToSimpleFunc T g))","decl":"theorem setToSimpleFunc_sub (T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F) (h_add : FinMeasAdditive Œº T) {f g : Œ± ‚Üí‚Çõ E}\n    (hf : Integrable f Œº) (hg : Integrable g Œº) :\n    setToSimpleFunc T (f - g) = setToSimpleFunc T f - setToSimpleFunc T g := by\n  rw [sub_eq_add_neg, setToSimpleFunc_add T h_add hf, setToSimpleFunc_neg T h_add hg,\n    sub_eq_add_neg]\n  rw [integrable_iff] at hg ‚ä¢\n  intro x hx_ne\n  change Œº (Neg.neg ‚àò g ‚Åª¬π' {x}) < ‚àû\n  rw [preimage_comp, neg_preimage, Set.neg_singleton]\n  refine hg (-x) ?_\n  simp [hx_ne]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_smul_real","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nh_add : MeasureTheory.FinMeasAdditive Œº T\nc : Real\nf : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Integrable (‚áëf) Œº\n‚ä¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T (HSMul.hSMul c f)) (HSMul.hSMul c (MeasureTheory.SimpleFunc.setToSimpleFunc T f))","decl":"theorem setToSimpleFunc_smul_real (T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F) (h_add : FinMeasAdditive Œº T) (c : ‚Ñù)\n    {f : Œ± ‚Üí‚Çõ E} (hf : Integrable f Œº) : setToSimpleFunc T (c ‚Ä¢ f) = c ‚Ä¢ setToSimpleFunc T f :=\n  calc\n    setToSimpleFunc T (c ‚Ä¢ f) = ‚àë x ‚àà f.range, T (f ‚Åª¬π' {x}) (c ‚Ä¢ x) := by\n      rw [smul_eq_map c f, map_setToSimpleFunc T h_add hf]; dsimp only; rw [smul_zero]\n    _ = ‚àë x ‚àà f.range, c ‚Ä¢ T (f ‚Åª¬π' {x}) x :=\n      (Finset.sum_congr rfl fun b _ => by rw [ContinuousLinearMap.map_smul (T (f ‚Åª¬π' {b})) c b])\n    _ = c ‚Ä¢ setToSimpleFunc T f := by simp only [setToSimpleFunc, smul_sum, smul_smul, mul_comm]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_smul","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nF : Type u_3\nùïú : Type u_6\ninst‚úù‚Å∂ : NormedAddCommGroup F\ninst‚úù‚Åµ : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nE : Type u_7\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : NormedSpace ùïú F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nh_add : MeasureTheory.FinMeasAdditive Œº T\nh_smul : ‚àÄ (c : ùïú) (s : Set Œ±) (x : E), Eq ((T s) (HSMul.hSMul c x)) (HSMul.hSMul c ((T s) x))\nc : ùïú\nf : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Integrable (‚áëf) Œº\n‚ä¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T (HSMul.hSMul c f)) (HSMul.hSMul c (MeasureTheory.SimpleFunc.setToSimpleFunc T f))","decl":"theorem setToSimpleFunc_smul {E} [NormedAddCommGroup E] [NormedField ùïú] [NormedSpace ùïú E]\n    [NormedSpace ‚Ñù E] [NormedSpace ùïú F] (T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F) (h_add : FinMeasAdditive Œº T)\n    (h_smul : ‚àÄ c : ùïú, ‚àÄ s x, T s (c ‚Ä¢ x) = c ‚Ä¢ T s x) (c : ùïú) {f : Œ± ‚Üí‚Çõ E} (hf : Integrable f Œº) :\n    setToSimpleFunc T (c ‚Ä¢ f) = c ‚Ä¢ setToSimpleFunc T f :=\n  calc\n    setToSimpleFunc T (c ‚Ä¢ f) = ‚àë x ‚àà f.range, T (f ‚Åª¬π' {x}) (c ‚Ä¢ x) := by\n      rw [smul_eq_map c f, map_setToSimpleFunc T h_add hf]; dsimp only; rw [smul_zero]\n    _ = ‚àë x ‚àà f.range, c ‚Ä¢ T (f ‚Åª¬π' {x}) x := Finset.sum_congr rfl fun b _ => by rw [h_smul]\n    _ = c ‚Ä¢ setToSimpleFunc T f := by simp only [setToSimpleFunc, smul_sum, smul_smul, mul_comm]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_mono_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace Real F\nG'' : Type u_8\ninst‚úù¬π : NormedLatticeAddCommGroup G''\ninst‚úù : NormedSpace Real G''\nm : MeasurableSpace Œ±\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) F G''\nhTT' : ‚àÄ (s : Set Œ±) (x : F), LE.le ((T s) x) ((T' s) x)\nf : MeasureTheory.SimpleFunc Œ± F\n‚ä¢ LE.le (MeasureTheory.SimpleFunc.setToSimpleFunc T f) (MeasureTheory.SimpleFunc.setToSimpleFunc T' f)","decl":"theorem setToSimpleFunc_mono_left {m : MeasurableSpace Œ±} (T T' : Set Œ± ‚Üí F ‚ÜíL[‚Ñù] G'')\n    (hTT' : ‚àÄ s x, T s x ‚â§ T' s x) (f : Œ± ‚Üí‚Çõ F) : setToSimpleFunc T f ‚â§ setToSimpleFunc T' f := by\n  simp_rw [setToSimpleFunc]; exact sum_le_sum fun i _ => hTT' _ i\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_mono_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nG'' : Type u_8\ninst‚úù¬π : NormedLatticeAddCommGroup G''\ninst‚úù : NormedSpace Real G''\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E G''\nhTT' : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí ‚àÄ (x : E), LE.le ((T s) x) ((T' s) x)\nf : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Integrable (‚áëf) Œº\n‚ä¢ LE.le (MeasureTheory.SimpleFunc.setToSimpleFunc T f) (MeasureTheory.SimpleFunc.setToSimpleFunc T' f)","decl":"theorem setToSimpleFunc_mono_left' (T T' : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] G'')\n    (hTT' : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí ‚àÄ x, T s x ‚â§ T' s x) (f : Œ± ‚Üí‚Çõ E)\n    (hf : Integrable f Œº) : setToSimpleFunc T f ‚â§ setToSimpleFunc T' f := by\n  refine sum_le_sum fun i _ => ?_\n  by_cases h0 : i = 0\n  ¬∑ simp [h0]\n  ¬∑ exact hTT' _ (measurableSet_fiber _ _) (measure_preimage_lt_top_of_integrable _ hf h0) i\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_nonneg","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nG' : Type u_7\nG'' : Type u_8\ninst‚úù¬≥ : NormedLatticeAddCommGroup G''\ninst‚úù¬≤ : NormedSpace Real G''\ninst‚úù¬π : NormedLatticeAddCommGroup G'\ninst‚úù : NormedSpace Real G'\nm : MeasurableSpace Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) G' G''\nhT_nonneg : ‚àÄ (s : Set Œ±) (x : G'), LE.le 0 x ‚Üí LE.le 0 ((T s) x)\nf : MeasureTheory.SimpleFunc Œ± G'\nhf : LE.le 0 f\n‚ä¢ LE.le 0 (MeasureTheory.SimpleFunc.setToSimpleFunc T f)","decl":"theorem setToSimpleFunc_nonneg {m : MeasurableSpace Œ±} (T : Set Œ± ‚Üí G' ‚ÜíL[‚Ñù] G'')\n    (hT_nonneg : ‚àÄ s x, 0 ‚â§ x ‚Üí 0 ‚â§ T s x) (f : Œ± ‚Üí‚Çõ G') (hf : 0 ‚â§ f) :\n    0 ‚â§ setToSimpleFunc T f := by\n  refine sum_nonneg fun i hi => hT_nonneg _ i ?_\n  rw [mem_range] at hi\n  obtain ‚ü®y, hy‚ü© := Set.mem_range.mp hi\n  rw [‚Üê hy]\n  refine le_trans ?_ (hf y)\n  simp\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_nonneg'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nG' : Type u_7\nG'' : Type u_8\ninst‚úù¬≥ : NormedLatticeAddCommGroup G''\ninst‚úù¬≤ : NormedSpace Real G''\ninst‚úù¬π : NormedLatticeAddCommGroup G'\ninst‚úù : NormedSpace Real G'\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) G' G''\nhT_nonneg : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí ‚àÄ (x : G'), LE.le 0 x ‚Üí LE.le 0 ((T s) x)\nf : MeasureTheory.SimpleFunc Œ± G'\nhf : LE.le 0 f\nhfi : MeasureTheory.Integrable (‚áëf) Œº\n‚ä¢ LE.le 0 (MeasureTheory.SimpleFunc.setToSimpleFunc T f)","decl":"theorem setToSimpleFunc_nonneg' (T : Set Œ± ‚Üí G' ‚ÜíL[‚Ñù] G'')\n    (hT_nonneg : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí ‚àÄ x, 0 ‚â§ x ‚Üí 0 ‚â§ T s x) (f : Œ± ‚Üí‚Çõ G') (hf : 0 ‚â§ f)\n    (hfi : Integrable f Œº) : 0 ‚â§ setToSimpleFunc T f := by\n  refine sum_nonneg fun i hi => ?_\n  by_cases h0 : i = 0\n  ¬∑ simp [h0]\n  refine\n    hT_nonneg _ (measurableSet_fiber _ _) (measure_preimage_lt_top_of_integrable _ hfi h0) i ?_\n  rw [mem_range] at hi\n  obtain ‚ü®y, hy‚ü© := Set.mem_range.mp hi\n  rw [‚Üê hy]\n  convert hf y\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_mono","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nG' : Type u_7\nG'' : Type u_8\ninst‚úù¬≥ : NormedLatticeAddCommGroup G''\ninst‚úù¬≤ : NormedSpace Real G''\ninst‚úù¬π : NormedLatticeAddCommGroup G'\ninst‚úù : NormedSpace Real G'\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) G' G''\nh_add : MeasureTheory.FinMeasAdditive Œº T\nhT_nonneg : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí ‚àÄ (x : G'), LE.le 0 x ‚Üí LE.le 0 ((T s) x)\nf g : MeasureTheory.SimpleFunc Œ± G'\nhfi : MeasureTheory.Integrable (‚áëf) Œº\nhgi : MeasureTheory.Integrable (‚áëg) Œº\nhfg : LE.le f g\n‚ä¢ LE.le (MeasureTheory.SimpleFunc.setToSimpleFunc T f) (MeasureTheory.SimpleFunc.setToSimpleFunc T g)","decl":"theorem setToSimpleFunc_mono {T : Set Œ± ‚Üí G' ‚ÜíL[‚Ñù] G''} (h_add : FinMeasAdditive Œº T)\n    (hT_nonneg : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí ‚àÄ x, 0 ‚â§ x ‚Üí 0 ‚â§ T s x) {f g : Œ± ‚Üí‚Çõ G'}\n    (hfi : Integrable f Œº) (hgi : Integrable g Œº) (hfg : f ‚â§ g) :\n    setToSimpleFunc T f ‚â§ setToSimpleFunc T g := by\n  rw [‚Üê sub_nonneg, ‚Üê setToSimpleFunc_sub T h_add hgi hfi]\n  refine setToSimpleFunc_nonneg' T hT_nonneg _ ?_ (hgi.sub hfi)\n  intro x\n  simp only [coe_sub, sub_nonneg, coe_zero, Pi.zero_apply, Pi.sub_apply]\n  exact hfg x\n\n"}
{"name":"MeasureTheory.SimpleFunc.norm_setToSimpleFunc_le_sum_opNorm","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nF : Type u_3\nF' : Type u_4\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace Real F\ninst‚úù¬π : NormedAddCommGroup F'\ninst‚úù : NormedSpace Real F'\nm : MeasurableSpace Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) F' F\nf : MeasureTheory.SimpleFunc Œ± F'\n‚ä¢ LE.le (Norm.norm (MeasureTheory.SimpleFunc.setToSimpleFunc T f)) (f.range.sum fun x => HMul.hMul (Norm.norm (T (Set.preimage (‚áëf) (Singleton.singleton x)))) (Norm.norm x))","decl":"theorem norm_setToSimpleFunc_le_sum_opNorm {m : MeasurableSpace Œ±} (T : Set Œ± ‚Üí F' ‚ÜíL[‚Ñù] F)\n    (f : Œ± ‚Üí‚Çõ F') : ‚Äñf.setToSimpleFunc T‚Äñ ‚â§ ‚àë x ‚àà f.range, ‚ÄñT (f ‚Åª¬π' {x})‚Äñ * ‚Äñx‚Äñ :=\n  calc\n    ‚Äñ‚àë x ‚àà f.range, T (f ‚Åª¬π' {x}) x‚Äñ ‚â§ ‚àë x ‚àà f.range, ‚ÄñT (f ‚Åª¬π' {x}) x‚Äñ := norm_sum_le _ _\n    _ ‚â§ ‚àë x ‚àà f.range, ‚ÄñT (f ‚Åª¬π' {x})‚Äñ * ‚Äñx‚Äñ := by\n      refine Finset.sum_le_sum fun b _ => ?_; simp_rw [ContinuousLinearMap.le_opNorm]\n\n"}
{"name":"MeasureTheory.SimpleFunc.norm_setToSimpleFunc_le_sum_mul_norm","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nF : Type u_3\nF' : Type u_4\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace Real F\ninst‚úù¬π : NormedAddCommGroup F'\ninst‚úù : NormedSpace Real F'\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) F F'\nC : Real\nhT_norm : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LE.le (Norm.norm (T s)) (HMul.hMul C (Œº s).toReal)\nf : MeasureTheory.SimpleFunc Œ± F\n‚ä¢ LE.le (Norm.norm (MeasureTheory.SimpleFunc.setToSimpleFunc T f)) (HMul.hMul C (f.range.sum fun x => HMul.hMul (Œº (Set.preimage (‚áëf) (Singleton.singleton x))).toReal (Norm.norm x)))","decl":"theorem norm_setToSimpleFunc_le_sum_mul_norm (T : Set Œ± ‚Üí F ‚ÜíL[‚Ñù] F') {C : ‚Ñù}\n    (hT_norm : ‚àÄ s, MeasurableSet s ‚Üí ‚ÄñT s‚Äñ ‚â§ C * (Œº s).toReal) (f : Œ± ‚Üí‚Çõ F) :\n    ‚Äñf.setToSimpleFunc T‚Äñ ‚â§ C * ‚àë x ‚àà f.range, (Œº (f ‚Åª¬π' {x})).toReal * ‚Äñx‚Äñ :=\n  calc\n    ‚Äñf.setToSimpleFunc T‚Äñ ‚â§ ‚àë x ‚àà f.range, ‚ÄñT (f ‚Åª¬π' {x})‚Äñ * ‚Äñx‚Äñ :=\n      norm_setToSimpleFunc_le_sum_opNorm T f\n    _ ‚â§ ‚àë x ‚àà f.range, C * (Œº (f ‚Åª¬π' {x})).toReal * ‚Äñx‚Äñ := by\n      gcongr\n      exact hT_norm _ <| SimpleFunc.measurableSet_fiber _ _\n    _ ‚â§ C * ‚àë x ‚àà f.range, (Œº (f ‚Åª¬π' {x})).toReal * ‚Äñx‚Äñ := by simp_rw [mul_sum, ‚Üê mul_assoc]; rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.norm_setToSimpleFunc_le_sum_mul_norm_of_integrable","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF' : Type u_4\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F'\ninst‚úù : NormedSpace Real F'\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F'\nC : Real\nhT_norm : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí LE.le (Norm.norm (T s)) (HMul.hMul C (Œº s).toReal)\nf : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Integrable (‚áëf) Œº\n‚ä¢ LE.le (Norm.norm (MeasureTheory.SimpleFunc.setToSimpleFunc T f)) (HMul.hMul C (f.range.sum fun x => HMul.hMul (Œº (Set.preimage (‚áëf) (Singleton.singleton x))).toReal (Norm.norm x)))","decl":"theorem norm_setToSimpleFunc_le_sum_mul_norm_of_integrable (T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F') {C : ‚Ñù}\n    (hT_norm : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí ‚ÄñT s‚Äñ ‚â§ C * (Œº s).toReal) (f : Œ± ‚Üí‚Çõ E)\n    (hf : Integrable f Œº) :\n    ‚Äñf.setToSimpleFunc T‚Äñ ‚â§ C * ‚àë x ‚àà f.range, (Œº (f ‚Åª¬π' {x})).toReal * ‚Äñx‚Äñ :=\n  calc\n    ‚Äñf.setToSimpleFunc T‚Äñ ‚â§ ‚àë x ‚àà f.range, ‚ÄñT (f ‚Åª¬π' {x})‚Äñ * ‚Äñx‚Äñ :=\n      norm_setToSimpleFunc_le_sum_opNorm T f\n    _ ‚â§ ‚àë x ‚àà f.range, C * (Œº (f ‚Åª¬π' {x})).toReal * ‚Äñx‚Äñ := by\n      refine Finset.sum_le_sum fun b hb => ?_\n      obtain rfl | hb := eq_or_ne b 0\n      ¬∑ simp\n      gcongr\n      exact hT_norm _ (SimpleFunc.measurableSet_fiber _ _) <|\n        SimpleFunc.measure_preimage_lt_top_of_integrable _ hf hb\n    _ ‚â§ C * ‚àë x ‚àà f.range, (Œº (f ‚Åª¬π' {x})).toReal * ‚Äñx‚Äñ := by simp_rw [mul_sum, ‚Üê mul_assoc]; rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_indicator","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nF : Type u_3\nF' : Type u_4\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace Real F\ninst‚úù¬π : NormedAddCommGroup F'\ninst‚úù : NormedSpace Real F'\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) F F'\nhT_empty : Eq (T EmptyCollection.emptyCollection) 0\nm : MeasurableSpace Œ±\ns : Set Œ±\nhs : MeasurableSet s\nx : F\n‚ä¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T (MeasureTheory.SimpleFunc.piecewise s hs (MeasureTheory.SimpleFunc.const Œ± x) (MeasureTheory.SimpleFunc.const Œ± 0))) ((T s) x)","decl":"theorem setToSimpleFunc_indicator (T : Set Œ± ‚Üí F ‚ÜíL[‚Ñù] F') (hT_empty : T ‚àÖ = 0)\n    {m : MeasurableSpace Œ±} {s : Set Œ±} (hs : MeasurableSet s) (x : F) :\n    SimpleFunc.setToSimpleFunc T\n        (SimpleFunc.piecewise s hs (SimpleFunc.const Œ± x) (SimpleFunc.const Œ± 0)) =\n      T s x := by\n  classical\n  obtain rfl | hs_empty := s.eq_empty_or_nonempty\n  ¬∑ simp only [hT_empty, ContinuousLinearMap.zero_apply, piecewise_empty, const_zero,\n      setToSimpleFunc_zero_apply]\n  simp_rw [setToSimpleFunc]\n  obtain rfl | hs_univ := eq_or_ne s univ\n  ¬∑ haveI hŒ± := hs_empty.to_type\n    simp [‚Üê Function.const_def]\n  rw [range_indicator hs hs_empty hs_univ]\n  by_cases hx0 : x = 0\n  ¬∑ simp_rw [hx0]; simp\n  rw [sum_insert]\n  swap; ¬∑ rw [Finset.mem_singleton]; exact hx0\n  rw [sum_singleton, (T _).map_zero, add_zero]\n  congr\n  simp only [coe_piecewise, piecewise_eq_indicator, coe_const, Function.const_zero,\n    piecewise_eq_indicator]\n  rw [indicator_preimage, ‚Üê Function.const_def, preimage_const_of_mem]\n  swap; ¬∑ exact Set.mem_singleton x\n  rw [‚Üê Function.const_zero, ‚Üê Function.const_def, preimage_const_of_not_mem]\n  swap; ¬∑ rw [Set.mem_singleton_iff]; exact Ne.symm hx0\n  simp\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_const'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nF : Type u_3\nF' : Type u_4\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : NormedAddCommGroup F'\ninst‚úù¬π : NormedSpace Real F'\ninst‚úù : Nonempty Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) F F'\nx : F\nm : MeasurableSpace Œ±\n‚ä¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T (MeasureTheory.SimpleFunc.const Œ± x)) ((T Set.univ) x)","decl":"theorem setToSimpleFunc_const' [Nonempty Œ±] (T : Set Œ± ‚Üí F ‚ÜíL[‚Ñù] F') (x : F)\n    {m : MeasurableSpace Œ±} : SimpleFunc.setToSimpleFunc T (SimpleFunc.const Œ± x) = T univ x := by\n  simp only [setToSimpleFunc, range_const, Set.mem_singleton, preimage_const_of_mem,\n    sum_singleton, ‚Üê Function.const_def, coe_const]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_const","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nF : Type u_3\nF' : Type u_4\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace Real F\ninst‚úù¬π : NormedAddCommGroup F'\ninst‚úù : NormedSpace Real F'\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) F F'\nhT_empty : Eq (T EmptyCollection.emptyCollection) 0\nx : F\nm : MeasurableSpace Œ±\n‚ä¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T (MeasureTheory.SimpleFunc.const Œ± x)) ((T Set.univ) x)","decl":"theorem setToSimpleFunc_const (T : Set Œ± ‚Üí F ‚ÜíL[‚Ñù] F') (hT_empty : T ‚àÖ = 0) (x : F)\n    {m : MeasurableSpace Œ±} : SimpleFunc.setToSimpleFunc T (SimpleFunc.const Œ± x) = T univ x := by\n  cases isEmpty_or_nonempty Œ±\n  ¬∑ have h_univ_empty : (univ : Set Œ±) = ‚àÖ := Subsingleton.elim _ _\n    rw [h_univ_empty, hT_empty]\n    simp only [setToSimpleFunc, ContinuousLinearMap.zero_apply, sum_empty,\n      range_eq_empty_of_isEmpty]\n  ¬∑ exact setToSimpleFunc_const' T x\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.norm_eq_sum_mul","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù : NormedAddCommGroup G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc G 1 Œº) x\n‚ä¢ Eq (Norm.norm f) ((MeasureTheory.Lp.simpleFunc.toSimpleFunc f).range.sum fun x => HMul.hMul (Œº (Set.preimage (‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc f)) (Singleton.singleton x))).toReal (Norm.norm x))","decl":"theorem norm_eq_sum_mul (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] G) :\n    ‚Äñf‚Äñ = ‚àë x ‚àà (toSimpleFunc f).range, (Œº (toSimpleFunc f ‚Åª¬π' {x})).toReal * ‚Äñx‚Äñ := by\n  rw [norm_toSimpleFunc, eLpNorm_one_eq_lintegral_enorm]\n  have h_eq := SimpleFunc.map_apply (‚Äñ¬∑‚Äñ‚Çë) (toSimpleFunc f)\n  simp_rw [‚Üê h_eq]\n  rw [SimpleFunc.lintegral_eq_lintegral, SimpleFunc.map_lintegral, ENNReal.toReal_sum]\n  ¬∑ congr\n    ext1 x\n    rw [ENNReal.toReal_mul, mul_comm, ‚Üê ofReal_norm_eq_enorm,\n      ENNReal.toReal_ofReal (norm_nonneg _)]\n  ¬∑ intro x _\n    by_cases hx0 : x = 0\n    ¬∑ rw [hx0]; simp\n    ¬∑ exact\n        ENNReal.mul_ne_top ENNReal.coe_ne_top\n          (SimpleFunc.measure_preimage_lt_top_of_integrable _ (SimpleFunc.integrable f) hx0).ne\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_eq_setToSimpleFunc","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T f) (MeasureTheory.SimpleFunc.setToSimpleFunc T (MeasureTheory.Lp.simpleFunc.toSimpleFunc f))","decl":"theorem setToL1S_eq_setToSimpleFunc (T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F) (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) :\n    setToL1S T f = (toSimpleFunc f).setToSimpleFunc T :=\n  rfl\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_zero_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S 0 f) 0","decl":"@[simp]\ntheorem setToL1S_zero_left (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) : setToL1S (0 : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F) f = 0 :=\n  SimpleFunc.setToSimpleFunc_zero _\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_zero_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nh_zero : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí Eq (T s) 0\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T f) 0","decl":"theorem setToL1S_zero_left' {T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F}\n    (h_zero : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí T s = 0) (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) : setToL1S T f = 0 :=\n  SimpleFunc.setToSimpleFunc_zero' h_zero _ (SimpleFunc.integrable f)\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_congr","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nh_zero : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí Eq (Œº s) 0 ‚Üí Eq (T s) 0\nh_add : MeasureTheory.FinMeasAdditive Œº T\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\nh : (MeasureTheory.ae Œº).EventuallyEq ‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc f) ‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc g)\n‚ä¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T f) (MeasureTheory.L1.SimpleFunc.setToL1S T g)","decl":"theorem setToL1S_congr (T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F) (h_zero : ‚àÄ s, MeasurableSet s ‚Üí Œº s = 0 ‚Üí T s = 0)\n    (h_add : FinMeasAdditive Œº T) {f g : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E} (h : toSimpleFunc f =·µê[Œº] toSimpleFunc g) :\n    setToL1S T f = setToL1S T g :=\n  SimpleFunc.setToSimpleFunc_congr T h_zero h_add (SimpleFunc.integrable f) h\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_congr_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nh : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí Eq (T s) (T' s)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T f) (MeasureTheory.L1.SimpleFunc.setToL1S T' f)","decl":"theorem setToL1S_congr_left (T T' : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F)\n    (h : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí T s = T' s) (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) :\n    setToL1S T f = setToL1S T' f :=\n  SimpleFunc.setToSimpleFunc_congr_left T T' h (simpleFunc.toSimpleFunc f) (SimpleFunc.integrable f)\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_congr_measure","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº Œº' : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nh_zero : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí Eq (Œº s) 0 ‚Üí Eq (T s) 0\nh_add : MeasureTheory.FinMeasAdditive Œº T\nhŒº : Œº.AbsolutelyContinuous Œº'\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\nf' : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº') x\nh : (MeasureTheory.ae Œº).EventuallyEq ‚Üë‚Üë‚Üëf ‚Üë‚Üë‚Üëf'\n‚ä¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T f) (MeasureTheory.L1.SimpleFunc.setToL1S T f')","decl":"/-- `setToL1S` does not change if we replace the measure `Œº` by `Œº'` with `Œº ‚â™ Œº'`. The statement\nuses two functions `f` and `f'` because they have to belong to different types, but morally these\nare the same function (we have `f =·µê[Œº] f'`). -/\ntheorem setToL1S_congr_measure {Œº' : Measure Œ±} (T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F)\n    (h_zero : ‚àÄ s, MeasurableSet s ‚Üí Œº s = 0 ‚Üí T s = 0) (h_add : FinMeasAdditive Œº T) (hŒº : Œº ‚â™ Œº')\n    (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) (f' : Œ± ‚Üí‚ÇÅ‚Çõ[Œº'] E) (h : (f : Œ± ‚Üí E) =·µê[Œº] f') :\n    setToL1S T f = setToL1S T f' := by\n  refine SimpleFunc.setToSimpleFunc_congr T h_zero h_add (SimpleFunc.integrable f) ?_\n  refine (toSimpleFunc_eq_toFun f).trans ?_\n  suffices (f' : Œ± ‚Üí E) =·µê[Œº] simpleFunc.toSimpleFunc f' from h.trans this\n  have goal' : (f' : Œ± ‚Üí E) =·µê[Œº'] simpleFunc.toSimpleFunc f' := (toSimpleFunc_eq_toFun f').symm\n  exact hŒº.ae_eq goal'\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_add_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S (HAdd.hAdd T T') f) (HAdd.hAdd (MeasureTheory.L1.SimpleFunc.setToL1S T f) (MeasureTheory.L1.SimpleFunc.setToL1S T' f))","decl":"theorem setToL1S_add_left (T T' : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F) (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) :\n    setToL1S (T + T') f = setToL1S T f + setToL1S T' f :=\n  SimpleFunc.setToSimpleFunc_add_left T T'\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_add_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT T' T'' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nh_add : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí Eq (T'' s) (HAdd.hAdd (T s) (T' s))\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T'' f) (HAdd.hAdd (MeasureTheory.L1.SimpleFunc.setToL1S T f) (MeasureTheory.L1.SimpleFunc.setToL1S T' f))","decl":"theorem setToL1S_add_left' (T T' T'' : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F)\n    (h_add : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí T'' s = T s + T' s) (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) :\n    setToL1S T'' f = setToL1S T f + setToL1S T' f :=\n  SimpleFunc.setToSimpleFunc_add_left' T T' T'' h_add (SimpleFunc.integrable f)\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_smul_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nc : Real\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S (fun s => HSMul.hSMul c (T s)) f) (HSMul.hSMul c (MeasureTheory.L1.SimpleFunc.setToL1S T f))","decl":"theorem setToL1S_smul_left (T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F) (c : ‚Ñù) (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) :\n    setToL1S (fun s => c ‚Ä¢ T s) f = c ‚Ä¢ setToL1S T f :=\n  SimpleFunc.setToSimpleFunc_smul_left T c _\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_smul_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nc : Real\nh_smul : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí Eq (T' s) (HSMul.hSMul c (T s))\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T' f) (HSMul.hSMul c (MeasureTheory.L1.SimpleFunc.setToL1S T f))","decl":"theorem setToL1S_smul_left' (T T' : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F) (c : ‚Ñù)\n    (h_smul : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí T' s = c ‚Ä¢ T s) (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) :\n    setToL1S T' f = c ‚Ä¢ setToL1S T f :=\n  SimpleFunc.setToSimpleFunc_smul_left' T T' c h_smul (SimpleFunc.integrable f)\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_add","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nh_zero : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí Eq (Œº s) 0 ‚Üí Eq (T s) 0\nh_add : MeasureTheory.FinMeasAdditive Œº T\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T (HAdd.hAdd f g)) (HAdd.hAdd (MeasureTheory.L1.SimpleFunc.setToL1S T f) (MeasureTheory.L1.SimpleFunc.setToL1S T g))","decl":"theorem setToL1S_add (T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F) (h_zero : ‚àÄ s, MeasurableSet s ‚Üí Œº s = 0 ‚Üí T s = 0)\n    (h_add : FinMeasAdditive Œº T) (f g : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) :\n    setToL1S T (f + g) = setToL1S T f + setToL1S T g := by\n  simp_rw [setToL1S]\n  rw [‚Üê SimpleFunc.setToSimpleFunc_add T h_add (SimpleFunc.integrable f)\n      (SimpleFunc.integrable g)]\n  exact\n    SimpleFunc.setToSimpleFunc_congr T h_zero h_add (SimpleFunc.integrable _)\n      (add_toSimpleFunc f g)\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_neg","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nh_zero : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí Eq (Œº s) 0 ‚Üí Eq (T s) 0\nh_add : MeasureTheory.FinMeasAdditive Œº T\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T (Neg.neg f)) (Neg.neg (MeasureTheory.L1.SimpleFunc.setToL1S T f))","decl":"theorem setToL1S_neg {T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F} (h_zero : ‚àÄ s, MeasurableSet s ‚Üí Œº s = 0 ‚Üí T s = 0)\n    (h_add : FinMeasAdditive Œº T) (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) : setToL1S T (-f) = -setToL1S T f := by\n  simp_rw [setToL1S]\n  have : simpleFunc.toSimpleFunc (-f) =·µê[Œº] ‚áë(-simpleFunc.toSimpleFunc f) :=\n    neg_toSimpleFunc f\n  rw [SimpleFunc.setToSimpleFunc_congr T h_zero h_add (SimpleFunc.integrable _) this]\n  exact SimpleFunc.setToSimpleFunc_neg T h_add (SimpleFunc.integrable f)\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_sub","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nh_zero : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí Eq (Œº s) 0 ‚Üí Eq (T s) 0\nh_add : MeasureTheory.FinMeasAdditive Œº T\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T (HSub.hSub f g)) (HSub.hSub (MeasureTheory.L1.SimpleFunc.setToL1S T f) (MeasureTheory.L1.SimpleFunc.setToL1S T g))","decl":"theorem setToL1S_sub {T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F} (h_zero : ‚àÄ s, MeasurableSet s ‚Üí Œº s = 0 ‚Üí T s = 0)\n    (h_add : FinMeasAdditive Œº T) (f g : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) :\n    setToL1S T (f - g) = setToL1S T f - setToL1S T g := by\n  rw [sub_eq_add_neg, setToL1S_add T h_zero h_add, setToL1S_neg h_zero h_add, sub_eq_add_neg]\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_smul_real","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nh_zero : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí Eq (Œº s) 0 ‚Üí Eq (T s) 0\nh_add : MeasureTheory.FinMeasAdditive Œº T\nc : Real\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T (HSMul.hSMul c f)) (HSMul.hSMul c (MeasureTheory.L1.SimpleFunc.setToL1S T f))","decl":"theorem setToL1S_smul_real (T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F)\n    (h_zero : ‚àÄ s, MeasurableSet s ‚Üí Œº s = 0 ‚Üí T s = 0) (h_add : FinMeasAdditive Œº T) (c : ‚Ñù)\n    (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) : setToL1S T (c ‚Ä¢ f) = c ‚Ä¢ setToL1S T f := by\n  simp_rw [setToL1S]\n  rw [‚Üê SimpleFunc.setToSimpleFunc_smul_real T h_add c (SimpleFunc.integrable f)]\n  refine SimpleFunc.setToSimpleFunc_congr T h_zero h_add (SimpleFunc.integrable _) ?_\n  exact smul_toSimpleFunc c f\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_smul","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nF : Type u_3\nùïú : Type u_6\ninst‚úù‚Å∂ : NormedAddCommGroup F\ninst‚úù‚Åµ : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å¥ : NormedField ùïú\nE : Type u_7\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedSpace ùïú E\ninst‚úù : NormedSpace ùïú F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nh_zero : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí Eq (Œº s) 0 ‚Üí Eq (T s) 0\nh_add : MeasureTheory.FinMeasAdditive Œº T\nh_smul : ‚àÄ (c : ùïú) (s : Set Œ±) (x : E), Eq ((T s) (HSMul.hSMul c x)) (HSMul.hSMul c ((T s) x))\nc : ùïú\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T (HSMul.hSMul c f)) (HSMul.hSMul c (MeasureTheory.L1.SimpleFunc.setToL1S T f))","decl":"theorem setToL1S_smul {E} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [NormedSpace ùïú E]\n    [NormedSpace ùïú F] (T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F) (h_zero : ‚àÄ s, MeasurableSet s ‚Üí Œº s = 0 ‚Üí T s = 0)\n    (h_add : FinMeasAdditive Œº T) (h_smul : ‚àÄ c : ùïú, ‚àÄ s x, T s (c ‚Ä¢ x) = c ‚Ä¢ T s x) (c : ùïú)\n    (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) : setToL1S T (c ‚Ä¢ f) = c ‚Ä¢ setToL1S T f := by\n  simp_rw [setToL1S]\n  rw [‚Üê SimpleFunc.setToSimpleFunc_smul T h_add h_smul c (SimpleFunc.integrable f)]\n  refine SimpleFunc.setToSimpleFunc_congr T h_zero h_add (SimpleFunc.integrable _) ?_\n  exact smul_toSimpleFunc c f\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.norm_setToL1S_le","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT_norm : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí LE.le (Norm.norm (T s)) (HMul.hMul C (Œº s).toReal)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ LE.le (Norm.norm (MeasureTheory.L1.SimpleFunc.setToL1S T f)) (HMul.hMul C (Norm.norm f))","decl":"theorem norm_setToL1S_le (T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F) {C : ‚Ñù}\n    (hT_norm : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí ‚ÄñT s‚Äñ ‚â§ C * (Œº s).toReal) (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) :\n    ‚ÄñsetToL1S T f‚Äñ ‚â§ C * ‚Äñf‚Äñ := by\n  rw [setToL1S, norm_eq_sum_mul f]\n  exact\n    SimpleFunc.norm_setToSimpleFunc_le_sum_mul_norm_of_integrable T hT_norm _\n      (SimpleFunc.integrable f)\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_indicatorConst","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\ns : Set Œ±\nh_zero : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí Eq (Œº s) 0 ‚Üí Eq (T s) 0\nh_add : MeasureTheory.FinMeasAdditive Œº T\nhs : MeasurableSet s\nhŒºs : LT.lt (Œº s) Top.top\nx : E\n‚ä¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T (MeasureTheory.Lp.simpleFunc.indicatorConst 1 hs ‚ãØ x)) ((T s) x)","decl":"theorem setToL1S_indicatorConst {T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F} {s : Set Œ±}\n    (h_zero : ‚àÄ s, MeasurableSet s ‚Üí Œº s = 0 ‚Üí T s = 0) (h_add : FinMeasAdditive Œº T)\n    (hs : MeasurableSet s) (hŒºs : Œº s < ‚àû) (x : E) :\n    setToL1S T (simpleFunc.indicatorConst 1 hs hŒºs.ne x) = T s x := by\n  have h_empty : T ‚àÖ = 0 := h_zero _ MeasurableSet.empty measure_empty\n  rw [setToL1S_eq_setToSimpleFunc]\n  refine Eq.trans ?_ (SimpleFunc.setToSimpleFunc_indicator T h_empty hs x)\n  refine SimpleFunc.setToSimpleFunc_congr T h_zero h_add (SimpleFunc.integrable _) ?_\n  exact toSimpleFunc_indicatorConst hs hŒºs.ne x\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_const","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nh_zero : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí Eq (Œº s) 0 ‚Üí Eq (T s) 0\nh_add : MeasureTheory.FinMeasAdditive Œº T\nx : E\n‚ä¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T (MeasureTheory.Lp.simpleFunc.indicatorConst 1 ‚ãØ ‚ãØ x)) ((T Set.univ) x)","decl":"theorem setToL1S_const [IsFiniteMeasure Œº] {T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F}\n    (h_zero : ‚àÄ s, MeasurableSet s ‚Üí Œº s = 0 ‚Üí T s = 0) (h_add : FinMeasAdditive Œº T) (x : E) :\n    setToL1S T (simpleFunc.indicatorConst 1 MeasurableSet.univ (measure_ne_top Œº _) x) = T univ x :=\n  setToL1S_indicatorConst h_zero h_add MeasurableSet.univ (measure_lt_top _ _) x\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_mono_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nG'' : Type u_7\ninst‚úù¬π : NormedLatticeAddCommGroup G''\ninst‚úù : NormedSpace Real G''\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E G''\nhTT' : ‚àÄ (s : Set Œ±) (x : E), LE.le ((T s) x) ((T' s) x)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ LE.le (MeasureTheory.L1.SimpleFunc.setToL1S T f) (MeasureTheory.L1.SimpleFunc.setToL1S T' f)","decl":"theorem setToL1S_mono_left {T T' : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] G''} (hTT' : ‚àÄ s x, T s x ‚â§ T' s x)\n    (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) : setToL1S T f ‚â§ setToL1S T' f :=\n  SimpleFunc.setToSimpleFunc_mono_left T T' hTT' _\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_mono_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nG'' : Type u_7\ninst‚úù¬π : NormedLatticeAddCommGroup G''\ninst‚úù : NormedSpace Real G''\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E G''\nhTT' : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí ‚àÄ (x : E), LE.le ((T s) x) ((T' s) x)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ LE.le (MeasureTheory.L1.SimpleFunc.setToL1S T f) (MeasureTheory.L1.SimpleFunc.setToL1S T' f)","decl":"theorem setToL1S_mono_left' {T T' : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] G''}\n    (hTT' : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí ‚àÄ x, T s x ‚â§ T' s x) (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) :\n    setToL1S T f ‚â§ setToL1S T' f :=\n  SimpleFunc.setToSimpleFunc_mono_left' T T' hTT' _ (SimpleFunc.integrable f)\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_nonneg","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nG'' : Type u_7\nG' : Type u_8\ninst‚úù¬≥ : NormedLatticeAddCommGroup G'\ninst‚úù¬≤ : NormedSpace Real G'\ninst‚úù¬π : NormedLatticeAddCommGroup G''\ninst‚úù : NormedSpace Real G''\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) G'' G'\nh_zero : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí Eq (Œº s) 0 ‚Üí Eq (T s) 0\nh_add : MeasureTheory.FinMeasAdditive Œº T\nhT_nonneg : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí ‚àÄ (x : G''), LE.le 0 x ‚Üí LE.le 0 ((T s) x)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc G'' 1 Œº) x\nhf : LE.le 0 f\n‚ä¢ LE.le 0 (MeasureTheory.L1.SimpleFunc.setToL1S T f)","decl":"theorem setToL1S_nonneg (h_zero : ‚àÄ s, MeasurableSet s ‚Üí Œº s = 0 ‚Üí T s = 0)\n    (h_add : FinMeasAdditive Œº T)\n    (hT_nonneg : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí ‚àÄ x, 0 ‚â§ x ‚Üí 0 ‚â§ T s x) {f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] G''}\n    (hf : 0 ‚â§ f) : 0 ‚â§ setToL1S T f := by\n  simp_rw [setToL1S]\n  obtain ‚ü®f', hf', hff'‚ü© : ‚àÉ f' : Œ± ‚Üí‚Çõ G'', 0 ‚â§ f' ‚àß simpleFunc.toSimpleFunc f =·µê[Œº] f' := by\n    obtain ‚ü®f'', hf'', hff''‚ü© := exists_simpleFunc_nonneg_ae_eq hf\n    exact ‚ü®f'', hf'', (Lp.simpleFunc.toSimpleFunc_eq_toFun f).trans hff''‚ü©\n  rw [SimpleFunc.setToSimpleFunc_congr _ h_zero h_add (SimpleFunc.integrable _) hff']\n  exact\n    SimpleFunc.setToSimpleFunc_nonneg' T hT_nonneg _ hf' ((SimpleFunc.integrable f).congr hff')\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_mono","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nG'' : Type u_7\nG' : Type u_8\ninst‚úù¬≥ : NormedLatticeAddCommGroup G'\ninst‚úù¬≤ : NormedSpace Real G'\ninst‚úù¬π : NormedLatticeAddCommGroup G''\ninst‚úù : NormedSpace Real G''\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) G'' G'\nh_zero : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí Eq (Œº s) 0 ‚Üí Eq (T s) 0\nh_add : MeasureTheory.FinMeasAdditive Œº T\nhT_nonneg : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí ‚àÄ (x : G''), LE.le 0 x ‚Üí LE.le 0 ((T s) x)\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc G'' 1 Œº) x\nhfg : LE.le f g\n‚ä¢ LE.le (MeasureTheory.L1.SimpleFunc.setToL1S T f) (MeasureTheory.L1.SimpleFunc.setToL1S T g)","decl":"theorem setToL1S_mono (h_zero : ‚àÄ s, MeasurableSet s ‚Üí Œº s = 0 ‚Üí T s = 0)\n    (h_add : FinMeasAdditive Œº T)\n    (hT_nonneg : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí ‚àÄ x, 0 ‚â§ x ‚Üí 0 ‚â§ T s x) {f g : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] G''}\n    (hfg : f ‚â§ g) : setToL1S T f ‚â§ setToL1S T g := by\n  rw [‚Üê sub_nonneg] at hfg ‚ä¢\n  rw [‚Üê setToL1S_sub h_zero h_add]\n  exact setToL1S_nonneg h_zero h_add hT_nonneg hfg\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_zero_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº 0 C\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº hT) f) 0","decl":"@[simp]\ntheorem setToL1SCLM_zero_left (hT : DominatedFinMeasAdditive Œº (0 : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F) C)\n    (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) : setToL1SCLM Œ± E Œº hT f = 0 :=\n  setToL1S_zero_left _\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_zero_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nh_zero : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí Eq (T s) 0\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº hT) f) 0","decl":"theorem setToL1SCLM_zero_left' (hT : DominatedFinMeasAdditive Œº T C)\n    (h_zero : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí T s = 0) (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) :\n    setToL1SCLM Œ± E Œº hT f = 0 :=\n  setToL1S_zero_left' h_zero f\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_congr_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº T' C'\nh : Eq T T'\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº hT) f) ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº hT') f)","decl":"theorem setToL1SCLM_congr_left (hT : DominatedFinMeasAdditive Œº T C)\n    (hT' : DominatedFinMeasAdditive Œº T' C') (h : T = T') (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) :\n    setToL1SCLM Œ± E Œº hT f = setToL1SCLM Œ± E Œº hT' f :=\n  setToL1S_congr_left T T' (fun _ _ _ => by rw [h]) f\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_congr_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº T' C'\nh : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí Eq (T s) (T' s)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº hT) f) ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº hT') f)","decl":"theorem setToL1SCLM_congr_left' (hT : DominatedFinMeasAdditive Œº T C)\n    (hT' : DominatedFinMeasAdditive Œº T' C') (h : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí T s = T' s)\n    (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) : setToL1SCLM Œ± E Œº hT f = setToL1SCLM Œ± E Œº hT' f :=\n  setToL1S_congr_left T T' h f\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_congr_measure","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nŒº' : MeasureTheory.Measure Œ±\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº' T C'\nhŒº : Œº.AbsolutelyContinuous Œº'\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\nf' : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº') x\nh : (MeasureTheory.ae Œº).EventuallyEq ‚Üë‚Üë‚Üëf ‚Üë‚Üë‚Üëf'\n‚ä¢ Eq ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº hT) f) ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº' hT') f')","decl":"theorem setToL1SCLM_congr_measure {Œº' : Measure Œ±} (hT : DominatedFinMeasAdditive Œº T C)\n    (hT' : DominatedFinMeasAdditive Œº' T C') (hŒº : Œº ‚â™ Œº') (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) (f' : Œ± ‚Üí‚ÇÅ‚Çõ[Œº'] E)\n    (h : (f : Œ± ‚Üí E) =·µê[Œº] f') : setToL1SCLM Œ± E Œº hT f = setToL1SCLM Œ± E Œº' hT' f' :=\n  setToL1S_congr_measure T (fun _ => hT.eq_zero_of_measure_zero) hT.1 hŒº _ _ h\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_add_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº T' C'\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº ‚ãØ) f) (HAdd.hAdd ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº hT) f) ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº hT') f))","decl":"theorem setToL1SCLM_add_left (hT : DominatedFinMeasAdditive Œº T C)\n    (hT' : DominatedFinMeasAdditive Œº T' C') (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) :\n    setToL1SCLM Œ± E Œº (hT.add hT') f = setToL1SCLM Œ± E Œº hT f + setToL1SCLM Œ± E Œº hT' f :=\n  setToL1S_add_left T T' f\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_add_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT T' T'' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC C' C'' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº T' C'\nhT'' : MeasureTheory.DominatedFinMeasAdditive Œº T'' C''\nh_add : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí Eq (T'' s) (HAdd.hAdd (T s) (T' s))\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº hT'') f) (HAdd.hAdd ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº hT) f) ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº hT') f))","decl":"theorem setToL1SCLM_add_left' (hT : DominatedFinMeasAdditive Œº T C)\n    (hT' : DominatedFinMeasAdditive Œº T' C') (hT'' : DominatedFinMeasAdditive Œº T'' C'')\n    (h_add : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí T'' s = T s + T' s) (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) :\n    setToL1SCLM Œ± E Œº hT'' f = setToL1SCLM Œ± E Œº hT f + setToL1SCLM Œ± E Œº hT' f :=\n  setToL1S_add_left' T T' T'' h_add f\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_smul_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC c : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº ‚ãØ) f) (HSMul.hSMul c ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº hT) f))","decl":"theorem setToL1SCLM_smul_left (c : ‚Ñù) (hT : DominatedFinMeasAdditive Œº T C) (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) :\n    setToL1SCLM Œ± E Œº (hT.smul c) f = c ‚Ä¢ setToL1SCLM Œ± E Œº hT f :=\n  setToL1S_smul_left T c f\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_smul_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC C' c : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº T' C'\nh_smul : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí Eq (T' s) (HSMul.hSMul c (T s))\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº hT') f) (HSMul.hSMul c ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº hT) f))","decl":"theorem setToL1SCLM_smul_left' (c : ‚Ñù) (hT : DominatedFinMeasAdditive Œº T C)\n    (hT' : DominatedFinMeasAdditive Œº T' C')\n    (h_smul : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí T' s = c ‚Ä¢ T s) (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) :\n    setToL1SCLM Œ± E Œº hT' f = c ‚Ä¢ setToL1SCLM Œ± E Œº hT f :=\n  setToL1S_smul_left' T T' c h_smul f\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.norm_setToL1SCLM_le","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhC : LE.le 0 C\n‚ä¢ LE.le (Norm.norm (MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº hT)) C","decl":"theorem norm_setToL1SCLM_le {T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F} {C : ‚Ñù} (hT : DominatedFinMeasAdditive Œº T C)\n    (hC : 0 ‚â§ C) : ‚ÄñsetToL1SCLM Œ± E Œº hT‚Äñ ‚â§ C :=\n  LinearMap.mkContinuous_norm_le _ hC _\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.norm_setToL1SCLM_le'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\n‚ä¢ LE.le (Norm.norm (MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº hT)) (Max.max C 0)","decl":"theorem norm_setToL1SCLM_le' {T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F} {C : ‚Ñù} (hT : DominatedFinMeasAdditive Œº T C) :\n    ‚ÄñsetToL1SCLM Œ± E Œº hT‚Äñ ‚â§ max C 0 :=\n  LinearMap.mkContinuous_norm_le' _ _\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_const","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nx : E\n‚ä¢ Eq ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº hT) (MeasureTheory.Lp.simpleFunc.indicatorConst 1 ‚ãØ ‚ãØ x)) ((T Set.univ) x)","decl":"theorem setToL1SCLM_const [IsFiniteMeasure Œº] {T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F} {C : ‚Ñù}\n    (hT : DominatedFinMeasAdditive Œº T C) (x : E) :\n    setToL1SCLM Œ± E Œº hT (simpleFunc.indicatorConst 1 MeasurableSet.univ (measure_ne_top Œº _) x) =\n      T univ x :=\n  setToL1S_const (fun _ => hT.eq_zero_of_measure_zero) hT.1 x\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_mono_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nG'' : Type u_8\ninst‚úù¬π : NormedLatticeAddCommGroup G''\ninst‚úù : NormedSpace Real G''\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E G''\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº T' C'\nhTT' : ‚àÄ (s : Set Œ±) (x : E), LE.le ((T s) x) ((T' s) x)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ LE.le ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº hT) f) ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº hT') f)","decl":"theorem setToL1SCLM_mono_left {T T' : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] G''} {C C' : ‚Ñù}\n    (hT : DominatedFinMeasAdditive Œº T C) (hT' : DominatedFinMeasAdditive Œº T' C')\n    (hTT' : ‚àÄ s x, T s x ‚â§ T' s x) (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) :\n    setToL1SCLM Œ± E Œº hT f ‚â§ setToL1SCLM Œ± E Œº hT' f :=\n  SimpleFunc.setToSimpleFunc_mono_left T T' hTT' _\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_mono_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nG'' : Type u_8\ninst‚úù¬π : NormedLatticeAddCommGroup G''\ninst‚úù : NormedSpace Real G''\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E G''\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº T' C'\nhTT' : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí ‚àÄ (x : E), LE.le ((T s) x) ((T' s) x)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ LE.le ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº hT) f) ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº hT') f)","decl":"theorem setToL1SCLM_mono_left' {T T' : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] G''} {C C' : ‚Ñù}\n    (hT : DominatedFinMeasAdditive Œº T C) (hT' : DominatedFinMeasAdditive Œº T' C')\n    (hTT' : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí ‚àÄ x, T s x ‚â§ T' s x) (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) :\n    setToL1SCLM Œ± E Œº hT f ‚â§ setToL1SCLM Œ± E Œº hT' f :=\n  SimpleFunc.setToSimpleFunc_mono_left' T T' hTT' _ (SimpleFunc.integrable f)\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_nonneg","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nG' : Type u_7\nG'' : Type u_8\ninst‚úù¬≥ : NormedLatticeAddCommGroup G''\ninst‚úù¬≤ : NormedSpace Real G''\ninst‚úù¬π : NormedLatticeAddCommGroup G'\ninst‚úù : NormedSpace Real G'\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) G' G''\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT_nonneg : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí ‚àÄ (x : G'), LE.le 0 x ‚Üí LE.le 0 ((T s) x)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc G' 1 Œº) x\nhf : LE.le 0 f\n‚ä¢ LE.le 0 ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± G' Œº hT) f)","decl":"theorem setToL1SCLM_nonneg {T : Set Œ± ‚Üí G' ‚ÜíL[‚Ñù] G''} {C : ‚Ñù} (hT : DominatedFinMeasAdditive Œº T C)\n    (hT_nonneg : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí ‚àÄ x, 0 ‚â§ x ‚Üí 0 ‚â§ T s x) {f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] G'}\n    (hf : 0 ‚â§ f) : 0 ‚â§ setToL1SCLM Œ± G' Œº hT f :=\n  setToL1S_nonneg (fun _ => hT.eq_zero_of_measure_zero) hT.1 hT_nonneg hf\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_mono","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nG' : Type u_7\nG'' : Type u_8\ninst‚úù¬≥ : NormedLatticeAddCommGroup G''\ninst‚úù¬≤ : NormedSpace Real G''\ninst‚úù¬π : NormedLatticeAddCommGroup G'\ninst‚úù : NormedSpace Real G'\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) G' G''\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT_nonneg : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí ‚àÄ (x : G'), LE.le 0 x ‚Üí LE.le 0 ((T s) x)\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc G' 1 Œº) x\nhfg : LE.le f g\n‚ä¢ LE.le ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± G' Œº hT) f) ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± G' Œº hT) g)","decl":"theorem setToL1SCLM_mono {T : Set Œ± ‚Üí G' ‚ÜíL[‚Ñù] G''} {C : ‚Ñù} (hT : DominatedFinMeasAdditive Œº T C)\n    (hT_nonneg : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí ‚àÄ x, 0 ‚â§ x ‚Üí 0 ‚â§ T s x) {f g : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] G'}\n    (hfg : f ‚â§ g) : setToL1SCLM Œ± G' Œº hT f ‚â§ setToL1SCLM Œ± G' Œº hT g :=\n  setToL1S_mono (fun _ => hT.eq_zero_of_measure_zero) hT.1 hT_nonneg hfg\n\n"}
{"name":"MeasureTheory.L1.setToL1_eq_setToL1SCLM","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq ((MeasureTheory.L1.setToL1 hT) ‚Üëf) ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº hT) f)","decl":"theorem setToL1_eq_setToL1SCLM (hT : DominatedFinMeasAdditive Œº T C) (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) :\n    setToL1 hT f = setToL1SCLM Œ± E Œº hT f :=\n  uniformly_extend_of_ind simpleFunc.isUniformInducing (simpleFunc.denseRange one_ne_top)\n    (setToL1SCLM Œ± E Œº hT).uniformContinuous _\n\n"}
{"name":"MeasureTheory.L1.setToL1_eq_setToL1'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nùïú : Type u_6\ninst‚úù‚Å∑ : NormedAddCommGroup E\ninst‚úù‚Å∂ : NormedSpace Real E\ninst‚úù‚Åµ : NormedAddCommGroup F\ninst‚úù‚Å¥ : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : NontriviallyNormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nh_smul : ‚àÄ (c : ùïú) (s : Set Œ±) (x : E), Eq ((T s) (HSMul.hSMul c x)) (HSMul.hSMul c ((T s) x))\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ Eq ((MeasureTheory.L1.setToL1 hT) f) ((MeasureTheory.L1.setToL1' ùïú hT h_smul) f)","decl":"theorem setToL1_eq_setToL1' (hT : DominatedFinMeasAdditive Œº T C)\n    (h_smul : ‚àÄ c : ùïú, ‚àÄ s x, T s (c ‚Ä¢ x) = c ‚Ä¢ T s x) (f : Œ± ‚Üí‚ÇÅ[Œº] E) :\n    setToL1 hT f = setToL1' ùïú hT h_smul f :=\n  rfl\n\n"}
{"name":"MeasureTheory.L1.setToL1_zero_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº 0 C\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ Eq ((MeasureTheory.L1.setToL1 hT) f) 0","decl":"@[simp]\ntheorem setToL1_zero_left (hT : DominatedFinMeasAdditive Œº (0 : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F) C)\n    (f : Œ± ‚Üí‚ÇÅ[Œº] E) : setToL1 hT f = 0 := by\n  suffices setToL1 hT = 0 by rw [this]; simp\n  refine ContinuousLinearMap.extend_unique (setToL1SCLM Œ± E Œº hT) _ _ _ _ ?_\n  ext1 f\n  rw [setToL1SCLM_zero_left hT f, ContinuousLinearMap.zero_comp, ContinuousLinearMap.zero_apply]\n\n"}
{"name":"MeasureTheory.L1.setToL1_zero_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nh_zero : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí Eq (T s) 0\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ Eq ((MeasureTheory.L1.setToL1 hT) f) 0","decl":"theorem setToL1_zero_left' (hT : DominatedFinMeasAdditive Œº T C)\n    (h_zero : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí T s = 0) (f : Œ± ‚Üí‚ÇÅ[Œº] E) : setToL1 hT f = 0 := by\n  suffices setToL1 hT = 0 by rw [this]; simp\n  refine ContinuousLinearMap.extend_unique (setToL1SCLM Œ± E Œº hT) _ _ _ _ ?_\n  ext1 f\n  rw [setToL1SCLM_zero_left' hT h_zero f, ContinuousLinearMap.zero_comp,\n    ContinuousLinearMap.zero_apply]\n\n"}
{"name":"MeasureTheory.L1.setToL1_congr_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº T' C'\nh : Eq T T'\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ Eq ((MeasureTheory.L1.setToL1 hT) f) ((MeasureTheory.L1.setToL1 hT') f)","decl":"theorem setToL1_congr_left (T T' : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F) {C C' : ‚Ñù}\n    (hT : DominatedFinMeasAdditive Œº T C) (hT' : DominatedFinMeasAdditive Œº T' C') (h : T = T')\n    (f : Œ± ‚Üí‚ÇÅ[Œº] E) : setToL1 hT f = setToL1 hT' f := by\n  suffices setToL1 hT = setToL1 hT' by rw [this]\n  refine ContinuousLinearMap.extend_unique (setToL1SCLM Œ± E Œº hT) _ _ _ _ ?_\n  ext1 f\n  suffices setToL1 hT' f = setToL1SCLM Œ± E Œº hT f by rw [‚Üê this]; rfl\n  rw [setToL1_eq_setToL1SCLM]\n  exact setToL1SCLM_congr_left hT' hT h.symm f\n\n"}
{"name":"MeasureTheory.L1.setToL1_congr_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº T' C'\nh : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí Eq (T s) (T' s)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ Eq ((MeasureTheory.L1.setToL1 hT) f) ((MeasureTheory.L1.setToL1 hT') f)","decl":"theorem setToL1_congr_left' (T T' : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F) {C C' : ‚Ñù}\n    (hT : DominatedFinMeasAdditive Œº T C) (hT' : DominatedFinMeasAdditive Œº T' C')\n    (h : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí T s = T' s) (f : Œ± ‚Üí‚ÇÅ[Œº] E) :\n    setToL1 hT f = setToL1 hT' f := by\n  suffices setToL1 hT = setToL1 hT' by rw [this]\n  refine ContinuousLinearMap.extend_unique (setToL1SCLM Œ± E Œº hT) _ _ _ _ ?_\n  ext1 f\n  suffices setToL1 hT' f = setToL1SCLM Œ± E Œº hT f by rw [‚Üê this]; rfl\n  rw [setToL1_eq_setToL1SCLM]\n  exact (setToL1SCLM_congr_left' hT hT' h f).symm\n\n"}
{"name":"MeasureTheory.L1.setToL1_add_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº T' C'\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ Eq ((MeasureTheory.L1.setToL1 ‚ãØ) f) (HAdd.hAdd ((MeasureTheory.L1.setToL1 hT) f) ((MeasureTheory.L1.setToL1 hT') f))","decl":"theorem setToL1_add_left (hT : DominatedFinMeasAdditive Œº T C)\n    (hT' : DominatedFinMeasAdditive Œº T' C') (f : Œ± ‚Üí‚ÇÅ[Œº] E) :\n    setToL1 (hT.add hT') f = setToL1 hT f + setToL1 hT' f := by\n  suffices setToL1 (hT.add hT') = setToL1 hT + setToL1 hT' by\n    rw [this, ContinuousLinearMap.add_apply]\n  refine ContinuousLinearMap.extend_unique (setToL1SCLM Œ± E Œº (hT.add hT')) _ _ _ _ ?_\n  ext1 f\n  suffices setToL1 hT f + setToL1 hT' f = setToL1SCLM Œ± E Œº (hT.add hT') f by\n    rw [‚Üê this]; rfl\n  rw [setToL1_eq_setToL1SCLM, setToL1_eq_setToL1SCLM, setToL1SCLM_add_left hT hT']\n\n"}
{"name":"MeasureTheory.L1.setToL1_add_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT T' T'' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC C' C'' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº T' C'\nhT'' : MeasureTheory.DominatedFinMeasAdditive Œº T'' C''\nh_add : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí Eq (T'' s) (HAdd.hAdd (T s) (T' s))\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ Eq ((MeasureTheory.L1.setToL1 hT'') f) (HAdd.hAdd ((MeasureTheory.L1.setToL1 hT) f) ((MeasureTheory.L1.setToL1 hT') f))","decl":"theorem setToL1_add_left' (hT : DominatedFinMeasAdditive Œº T C)\n    (hT' : DominatedFinMeasAdditive Œº T' C') (hT'' : DominatedFinMeasAdditive Œº T'' C'')\n    (h_add : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí T'' s = T s + T' s) (f : Œ± ‚Üí‚ÇÅ[Œº] E) :\n    setToL1 hT'' f = setToL1 hT f + setToL1 hT' f := by\n  suffices setToL1 hT'' = setToL1 hT + setToL1 hT' by rw [this, ContinuousLinearMap.add_apply]\n  refine ContinuousLinearMap.extend_unique (setToL1SCLM Œ± E Œº hT'') _ _ _ _ ?_\n  ext1 f\n  suffices setToL1 hT f + setToL1 hT' f = setToL1SCLM Œ± E Œº hT'' f by rw [‚Üê this]; congr\n  rw [setToL1_eq_setToL1SCLM, setToL1_eq_setToL1SCLM,\n    setToL1SCLM_add_left' hT hT' hT'' h_add]\n\n"}
{"name":"MeasureTheory.L1.setToL1_smul_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nc : Real\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ Eq ((MeasureTheory.L1.setToL1 ‚ãØ) f) (HSMul.hSMul c ((MeasureTheory.L1.setToL1 hT) f))","decl":"theorem setToL1_smul_left (hT : DominatedFinMeasAdditive Œº T C) (c : ‚Ñù) (f : Œ± ‚Üí‚ÇÅ[Œº] E) :\n    setToL1 (hT.smul c) f = c ‚Ä¢ setToL1 hT f := by\n  suffices setToL1 (hT.smul c) = c ‚Ä¢ setToL1 hT by rw [this, ContinuousLinearMap.smul_apply]\n  refine ContinuousLinearMap.extend_unique (setToL1SCLM Œ± E Œº (hT.smul c)) _ _ _ _ ?_\n  ext1 f\n  suffices c ‚Ä¢ setToL1 hT f = setToL1SCLM Œ± E Œº (hT.smul c) f by rw [‚Üê this]; congr\n  rw [setToL1_eq_setToL1SCLM, setToL1SCLM_smul_left c hT]\n\n"}
{"name":"MeasureTheory.L1.setToL1_smul_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº T' C'\nc : Real\nh_smul : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí Eq (T' s) (HSMul.hSMul c (T s))\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ Eq ((MeasureTheory.L1.setToL1 hT') f) (HSMul.hSMul c ((MeasureTheory.L1.setToL1 hT) f))","decl":"theorem setToL1_smul_left' (hT : DominatedFinMeasAdditive Œº T C)\n    (hT' : DominatedFinMeasAdditive Œº T' C') (c : ‚Ñù)\n    (h_smul : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí T' s = c ‚Ä¢ T s) (f : Œ± ‚Üí‚ÇÅ[Œº] E) :\n    setToL1 hT' f = c ‚Ä¢ setToL1 hT f := by\n  suffices setToL1 hT' = c ‚Ä¢ setToL1 hT by rw [this, ContinuousLinearMap.smul_apply]\n  refine ContinuousLinearMap.extend_unique (setToL1SCLM Œ± E Œº hT') _ _ _ _ ?_\n  ext1 f\n  suffices c ‚Ä¢ setToL1 hT f = setToL1SCLM Œ± E Œº hT' f by rw [‚Üê this]; congr\n  rw [setToL1_eq_setToL1SCLM, setToL1SCLM_smul_left' c hT hT' h_smul]\n\n"}
{"name":"MeasureTheory.L1.setToL1_smul","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nùïú : Type u_6\ninst‚úù‚Å∑ : NormedAddCommGroup E\ninst‚úù‚Å∂ : NormedSpace Real E\ninst‚úù‚Åµ : NormedAddCommGroup F\ninst‚úù‚Å¥ : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : NontriviallyNormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nh_smul : ‚àÄ (c : ùïú) (s : Set Œ±) (x : E), Eq ((T s) (HSMul.hSMul c x)) (HSMul.hSMul c ((T s) x))\nc : ùïú\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ Eq ((MeasureTheory.L1.setToL1 hT) (HSMul.hSMul c f)) (HSMul.hSMul c ((MeasureTheory.L1.setToL1 hT) f))","decl":"theorem setToL1_smul (hT : DominatedFinMeasAdditive Œº T C)\n    (h_smul : ‚àÄ c : ùïú, ‚àÄ s x, T s (c ‚Ä¢ x) = c ‚Ä¢ T s x) (c : ùïú) (f : Œ± ‚Üí‚ÇÅ[Œº] E) :\n    setToL1 hT (c ‚Ä¢ f) = c ‚Ä¢ setToL1 hT f := by\n  rw [setToL1_eq_setToL1' hT h_smul, setToL1_eq_setToL1' hT h_smul]\n  exact ContinuousLinearMap.map_smul _ _ _\n\n"}
{"name":"MeasureTheory.L1.setToL1_simpleFunc_indicatorConst","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\ns : Set Œ±\nhs : MeasurableSet s\nhŒºs : LT.lt (Œº s) Top.top\nx : E\n‚ä¢ Eq ((MeasureTheory.L1.setToL1 hT) ‚Üë(MeasureTheory.Lp.simpleFunc.indicatorConst 1 hs ‚ãØ x)) ((T s) x)","decl":"theorem setToL1_simpleFunc_indicatorConst (hT : DominatedFinMeasAdditive Œº T C) {s : Set Œ±}\n    (hs : MeasurableSet s) (hŒºs : Œº s < ‚àû) (x : E) :\n    setToL1 hT (simpleFunc.indicatorConst 1 hs hŒºs.ne x) = T s x := by\n  rw [setToL1_eq_setToL1SCLM]\n  exact setToL1S_indicatorConst (fun s => hT.eq_zero_of_measure_zero) hT.1 hs hŒºs x\n\n"}
{"name":"MeasureTheory.L1.setToL1_indicatorConstLp","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\ns : Set Œ±\nhs : MeasurableSet s\nhŒºs : Ne (Œº s) Top.top\nx : E\n‚ä¢ Eq ((MeasureTheory.L1.setToL1 hT) (MeasureTheory.indicatorConstLp 1 hs hŒºs x)) ((T s) x)","decl":"theorem setToL1_indicatorConstLp (hT : DominatedFinMeasAdditive Œº T C) {s : Set Œ±}\n    (hs : MeasurableSet s) (hŒºs : Œº s ‚â† ‚àû) (x : E) :\n    setToL1 hT (indicatorConstLp 1 hs hŒºs x) = T s x := by\n  rw [‚Üê Lp.simpleFunc.coe_indicatorConst hs hŒºs x]\n  exact setToL1_simpleFunc_indicatorConst hT hs hŒºs.lt_top x\n\n"}
{"name":"MeasureTheory.L1.setToL1_const","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nx : E\n‚ä¢ Eq ((MeasureTheory.L1.setToL1 hT) (MeasureTheory.indicatorConstLp 1 ‚ãØ ‚ãØ x)) ((T Set.univ) x)","decl":"theorem setToL1_const [IsFiniteMeasure Œº] (hT : DominatedFinMeasAdditive Œº T C) (x : E) :\n    setToL1 hT (indicatorConstLp 1 MeasurableSet.univ (measure_ne_top _ _) x) = T univ x :=\n  setToL1_indicatorConstLp hT MeasurableSet.univ (measure_ne_top _ _) x\n\n"}
{"name":"MeasureTheory.L1.setToL1_mono_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nG'' : Type u_8\ninst‚úù¬≤ : NormedLatticeAddCommGroup G''\ninst‚úù¬π : NormedSpace Real G''\ninst‚úù : CompleteSpace G''\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E G''\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº T' C'\nhTT' : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí ‚àÄ (x : E), LE.le ((T s) x) ((T' s) x)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ LE.le ((MeasureTheory.L1.setToL1 hT) f) ((MeasureTheory.L1.setToL1 hT') f)","decl":"theorem setToL1_mono_left' {T T' : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] G''} {C C' : ‚Ñù}\n    (hT : DominatedFinMeasAdditive Œº T C) (hT' : DominatedFinMeasAdditive Œº T' C')\n    (hTT' : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí ‚àÄ x, T s x ‚â§ T' s x) (f : Œ± ‚Üí‚ÇÅ[Œº] E) :\n    setToL1 hT f ‚â§ setToL1 hT' f := by\n  induction f using Lp.induction (hp_ne_top := one_ne_top) with\n  | @h_ind c s hs hŒºs =>\n    rw [setToL1_simpleFunc_indicatorConst hT hs hŒºs, setToL1_simpleFunc_indicatorConst hT' hs hŒºs]\n    exact hTT' s hs hŒºs c\n  | @h_add f g hf hg _ hf_le hg_le =>\n    rw [(setToL1 hT).map_add, (setToL1 hT').map_add]\n    exact add_le_add hf_le hg_le\n  | h_closed => exact isClosed_le (setToL1 hT).continuous (setToL1 hT').continuous\n\n"}
{"name":"MeasureTheory.L1.setToL1_mono_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nG'' : Type u_8\ninst‚úù¬≤ : NormedLatticeAddCommGroup G''\ninst‚úù¬π : NormedSpace Real G''\ninst‚úù : CompleteSpace G''\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E G''\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº T' C'\nhTT' : ‚àÄ (s : Set Œ±) (x : E), LE.le ((T s) x) ((T' s) x)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ LE.le ((MeasureTheory.L1.setToL1 hT) f) ((MeasureTheory.L1.setToL1 hT') f)","decl":"theorem setToL1_mono_left {T T' : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] G''} {C C' : ‚Ñù}\n    (hT : DominatedFinMeasAdditive Œº T C) (hT' : DominatedFinMeasAdditive Œº T' C')\n    (hTT' : ‚àÄ s x, T s x ‚â§ T' s x) (f : Œ± ‚Üí‚ÇÅ[Œº] E) : setToL1 hT f ‚â§ setToL1 hT' f :=\n  setToL1_mono_left' hT hT' (fun s _ _ x => hTT' s x) f\n\n"}
{"name":"MeasureTheory.L1.setToL1_nonneg","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nG' : Type u_7\nG'' : Type u_8\ninst‚úù‚Å¥ : NormedLatticeAddCommGroup G''\ninst‚úù¬≥ : NormedSpace Real G''\ninst‚úù¬≤ : CompleteSpace G''\ninst‚úù¬π : NormedLatticeAddCommGroup G'\ninst‚úù : NormedSpace Real G'\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) G' G''\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT_nonneg : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí ‚àÄ (x : G'), LE.le 0 x ‚Üí LE.le 0 ((T s) x)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp G' 1 Œº) x\nhf : LE.le 0 f\n‚ä¢ LE.le 0 ((MeasureTheory.L1.setToL1 hT) f)","decl":"theorem setToL1_nonneg {T : Set Œ± ‚Üí G' ‚ÜíL[‚Ñù] G''} {C : ‚Ñù} (hT : DominatedFinMeasAdditive Œº T C)\n    (hT_nonneg : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí ‚àÄ x, 0 ‚â§ x ‚Üí 0 ‚â§ T s x) {f : Œ± ‚Üí‚ÇÅ[Œº] G'}\n    (hf : 0 ‚â§ f) : 0 ‚â§ setToL1 hT f := by\n  suffices ‚àÄ f : { g : Œ± ‚Üí‚ÇÅ[Œº] G' // 0 ‚â§ g }, 0 ‚â§ setToL1 hT f from\n    this (‚ü®f, hf‚ü© : { g : Œ± ‚Üí‚ÇÅ[Œº] G' // 0 ‚â§ g })\n  refine fun g =>\n    @isClosed_property { g : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] G' // 0 ‚â§ g } { g : Œ± ‚Üí‚ÇÅ[Œº] G' // 0 ‚â§ g } _ _\n      (fun g => 0 ‚â§ setToL1 hT g)\n      (denseRange_coeSimpleFuncNonnegToLpNonneg 1 Œº G' one_ne_top) ?_ ?_ g\n  ¬∑ exact isClosed_le continuous_zero ((setToL1 hT).continuous.comp continuous_induced_dom)\n  ¬∑ intro g\n    have : (coeSimpleFuncNonnegToLpNonneg 1 Œº G' g : Œ± ‚Üí‚ÇÅ[Œº] G') = (g : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] G') := rfl\n    rw [this, setToL1_eq_setToL1SCLM]\n    exact setToL1S_nonneg (fun s => hT.eq_zero_of_measure_zero) hT.1 hT_nonneg g.2\n\n"}
{"name":"MeasureTheory.L1.setToL1_mono","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nG' : Type u_7\nG'' : Type u_8\ninst‚úù‚Å¥ : NormedLatticeAddCommGroup G''\ninst‚úù¬≥ : NormedSpace Real G''\ninst‚úù¬≤ : CompleteSpace G''\ninst‚úù¬π : NormedLatticeAddCommGroup G'\ninst‚úù : NormedSpace Real G'\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) G' G''\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT_nonneg : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí ‚àÄ (x : G'), LE.le 0 x ‚Üí LE.le 0 ((T s) x)\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp G' 1 Œº) x\nhfg : LE.le f g\n‚ä¢ LE.le ((MeasureTheory.L1.setToL1 hT) f) ((MeasureTheory.L1.setToL1 hT) g)","decl":"theorem setToL1_mono {T : Set Œ± ‚Üí G' ‚ÜíL[‚Ñù] G''} {C : ‚Ñù} (hT : DominatedFinMeasAdditive Œº T C)\n    (hT_nonneg : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí ‚àÄ x, 0 ‚â§ x ‚Üí 0 ‚â§ T s x) {f g : Œ± ‚Üí‚ÇÅ[Œº] G'}\n    (hfg : f ‚â§ g) : setToL1 hT f ‚â§ setToL1 hT g := by\n  rw [‚Üê sub_nonneg] at hfg ‚ä¢\n  rw [‚Üê (setToL1 hT).map_sub]\n  exact setToL1_nonneg hT hT_nonneg hfg\n\n"}
{"name":"MeasureTheory.L1.norm_setToL1_le_norm_setToL1SCLM","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\n‚ä¢ LE.le (Norm.norm (MeasureTheory.L1.setToL1 hT)) (Norm.norm (MeasureTheory.L1.SimpleFunc.setToL1SCLM Œ± E Œº hT))","decl":"theorem norm_setToL1_le_norm_setToL1SCLM (hT : DominatedFinMeasAdditive Œº T C) :\n    ‚ÄñsetToL1 hT‚Äñ ‚â§ ‚ÄñsetToL1SCLM Œ± E Œº hT‚Äñ :=\n  calc\n    ‚ÄñsetToL1 hT‚Äñ ‚â§ (1 : ‚Ñù‚â•0) * ‚ÄñsetToL1SCLM Œ± E Œº hT‚Äñ := by\n      refine\n        ContinuousLinearMap.opNorm_extend_le (setToL1SCLM Œ± E Œº hT) (coeToLp Œ± E ‚Ñù)\n          (simpleFunc.denseRange one_ne_top) fun x => le_of_eq ?_\n      rw [NNReal.coe_one, one_mul]\n      rfl\n    _ = ‚ÄñsetToL1SCLM Œ± E Œº hT‚Äñ := by rw [NNReal.coe_one, one_mul]\n\n"}
{"name":"MeasureTheory.L1.norm_setToL1_le_mul_norm","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhC : LE.le 0 C\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ LE.le (Norm.norm ((MeasureTheory.L1.setToL1 hT) f)) (HMul.hMul C (Norm.norm f))","decl":"theorem norm_setToL1_le_mul_norm (hT : DominatedFinMeasAdditive Œº T C) (hC : 0 ‚â§ C)\n    (f : Œ± ‚Üí‚ÇÅ[Œº] E) : ‚ÄñsetToL1 hT f‚Äñ ‚â§ C * ‚Äñf‚Äñ :=\n  calc\n    ‚ÄñsetToL1 hT f‚Äñ ‚â§ ‚ÄñsetToL1SCLM Œ± E Œº hT‚Äñ * ‚Äñf‚Äñ :=\n      ContinuousLinearMap.le_of_opNorm_le _ (norm_setToL1_le_norm_setToL1SCLM hT) _\n    _ ‚â§ C * ‚Äñf‚Äñ := mul_le_mul (norm_setToL1SCLM_le hT hC) le_rfl (norm_nonneg _) hC\n\n"}
{"name":"MeasureTheory.L1.norm_setToL1_le_mul_norm'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ LE.le (Norm.norm ((MeasureTheory.L1.setToL1 hT) f)) (HMul.hMul (Max.max C 0) (Norm.norm f))","decl":"theorem norm_setToL1_le_mul_norm' (hT : DominatedFinMeasAdditive Œº T C) (f : Œ± ‚Üí‚ÇÅ[Œº] E) :\n    ‚ÄñsetToL1 hT f‚Äñ ‚â§ max C 0 * ‚Äñf‚Äñ :=\n  calc\n    ‚ÄñsetToL1 hT f‚Äñ ‚â§ ‚ÄñsetToL1SCLM Œ± E Œº hT‚Äñ * ‚Äñf‚Äñ :=\n      ContinuousLinearMap.le_of_opNorm_le _ (norm_setToL1_le_norm_setToL1SCLM hT) _\n    _ ‚â§ max C 0 * ‚Äñf‚Äñ :=\n      mul_le_mul (norm_setToL1SCLM_le' hT) le_rfl (norm_nonneg _) (le_max_right _ _)\n\n"}
{"name":"MeasureTheory.L1.norm_setToL1_le","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhC : LE.le 0 C\n‚ä¢ LE.le (Norm.norm (MeasureTheory.L1.setToL1 hT)) C","decl":"theorem norm_setToL1_le (hT : DominatedFinMeasAdditive Œº T C) (hC : 0 ‚â§ C) : ‚ÄñsetToL1 hT‚Äñ ‚â§ C :=\n  ContinuousLinearMap.opNorm_le_bound _ hC (norm_setToL1_le_mul_norm hT hC)\n\n"}
{"name":"MeasureTheory.L1.norm_setToL1_le'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\n‚ä¢ LE.le (Norm.norm (MeasureTheory.L1.setToL1 hT)) (Max.max C 0)","decl":"theorem norm_setToL1_le' (hT : DominatedFinMeasAdditive Œº T C) : ‚ÄñsetToL1 hT‚Äñ ‚â§ max C 0 :=\n  ContinuousLinearMap.opNorm_le_bound _ (le_max_right _ _) (norm_setToL1_le_mul_norm' hT)\n\n"}
{"name":"MeasureTheory.L1.setToL1_lipschitz","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\n‚ä¢ LipschitzWith C.toNNReal ‚áë(MeasureTheory.L1.setToL1 hT)","decl":"theorem setToL1_lipschitz (hT : DominatedFinMeasAdditive Œº T C) :\n    LipschitzWith (Real.toNNReal C) (setToL1 hT) :=\n  (setToL1 hT).lipschitz.weaken (norm_setToL1_le' hT)\n\n"}
{"name":"MeasureTheory.L1.tendsto_setToL1","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\nŒπ : Type u_7\nfs : Œπ ‚Üí Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\nl : Filter Œπ\nhfs : Filter.Tendsto fs l (nhds f)\n‚ä¢ Filter.Tendsto (fun i => (MeasureTheory.L1.setToL1 hT) (fs i)) l (nhds ((MeasureTheory.L1.setToL1 hT) f))","decl":"/-- If `fs i ‚Üí f` in `L1`, then `setToL1 hT (fs i) ‚Üí setToL1 hT f`. -/\ntheorem tendsto_setToL1 (hT : DominatedFinMeasAdditive Œº T C) (f : Œ± ‚Üí‚ÇÅ[Œº] E) {Œπ}\n    (fs : Œπ ‚Üí Œ± ‚Üí‚ÇÅ[Œº] E) {l : Filter Œπ} (hfs : Tendsto fs l (ùìù f)) :\n    Tendsto (fun i => setToL1 hT (fs i)) l (ùìù <| setToL1 hT f) :=\n  ((setToL1 hT).continuous.tendsto _).comp hfs\n\n"}
{"name":"MeasureTheory.setToFun_eq","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nf : Œ± ‚Üí E\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhf : MeasureTheory.Integrable f Œº\n‚ä¢ Eq (MeasureTheory.setToFun Œº T hT f) ((MeasureTheory.L1.setToL1 hT) (MeasureTheory.Integrable.toL1 f hf))","decl":"theorem setToFun_eq (hT : DominatedFinMeasAdditive Œº T C) (hf : Integrable f Œº) :\n    setToFun Œº T hT f = L1.setToL1 hT (hf.toL1 f) :=\n  dif_pos hf\n\n"}
{"name":"MeasureTheory.L1.setToFun_eq_setToL1","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.setToFun Œº T hT ‚Üë‚Üëf) ((MeasureTheory.L1.setToL1 hT) f)","decl":"theorem L1.setToFun_eq_setToL1 (hT : DominatedFinMeasAdditive Œº T C) (f : Œ± ‚Üí‚ÇÅ[Œº] E) :\n    setToFun Œº T hT f = L1.setToL1 hT f := by\n  rw [setToFun_eq hT (L1.integrable_coeFn f), Integrable.toL1_coeFn]\n\n"}
{"name":"MeasureTheory.setToFun_undef","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nf : Œ± ‚Üí E\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhf : Not (MeasureTheory.Integrable f Œº)\n‚ä¢ Eq (MeasureTheory.setToFun Œº T hT f) 0","decl":"theorem setToFun_undef (hT : DominatedFinMeasAdditive Œº T C) (hf : ¬¨Integrable f Œº) :\n    setToFun Œº T hT f = 0 :=\n  dif_neg hf\n\n"}
{"name":"MeasureTheory.setToFun_non_aEStronglyMeasurable","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nf : Œ± ‚Üí E\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhf : Not (MeasureTheory.AEStronglyMeasurable f Œº)\n‚ä¢ Eq (MeasureTheory.setToFun Œº T hT f) 0","decl":"theorem setToFun_non_aEStronglyMeasurable (hT : DominatedFinMeasAdditive Œº T C)\n    (hf : ¬¨AEStronglyMeasurable f Œº) : setToFun Œº T hT f = 0 :=\n  setToFun_undef hT (not_and_of_not_left _ hf)\n\n"}
{"name":"MeasureTheory.setToFun_congr_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº T' C'\nh : Eq T T'\nf : Œ± ‚Üí E\n‚ä¢ Eq (MeasureTheory.setToFun Œº T hT f) (MeasureTheory.setToFun Œº T' hT' f)","decl":"theorem setToFun_congr_left (hT : DominatedFinMeasAdditive Œº T C)\n    (hT' : DominatedFinMeasAdditive Œº T' C') (h : T = T') (f : Œ± ‚Üí E) :\n    setToFun Œº T hT f = setToFun Œº T' hT' f := by\n  by_cases hf : Integrable f Œº\n  ¬∑ simp_rw [setToFun_eq _ hf, L1.setToL1_congr_left T T' hT hT' h]\n  ¬∑ simp_rw [setToFun_undef _ hf]\n\n"}
{"name":"MeasureTheory.setToFun_congr_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº T' C'\nh : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí Eq (T s) (T' s)\nf : Œ± ‚Üí E\n‚ä¢ Eq (MeasureTheory.setToFun Œº T hT f) (MeasureTheory.setToFun Œº T' hT' f)","decl":"theorem setToFun_congr_left' (hT : DominatedFinMeasAdditive Œº T C)\n    (hT' : DominatedFinMeasAdditive Œº T' C') (h : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí T s = T' s)\n    (f : Œ± ‚Üí E) : setToFun Œº T hT f = setToFun Œº T' hT' f := by\n  by_cases hf : Integrable f Œº\n  ¬∑ simp_rw [setToFun_eq _ hf, L1.setToL1_congr_left' T T' hT hT' h]\n  ¬∑ simp_rw [setToFun_undef _ hf]\n\n"}
{"name":"MeasureTheory.setToFun_add_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº T' C'\nf : Œ± ‚Üí E\n‚ä¢ Eq (MeasureTheory.setToFun Œº (HAdd.hAdd T T') ‚ãØ f) (HAdd.hAdd (MeasureTheory.setToFun Œº T hT f) (MeasureTheory.setToFun Œº T' hT' f))","decl":"theorem setToFun_add_left (hT : DominatedFinMeasAdditive Œº T C)\n    (hT' : DominatedFinMeasAdditive Œº T' C') (f : Œ± ‚Üí E) :\n    setToFun Œº (T + T') (hT.add hT') f = setToFun Œº T hT f + setToFun Œº T' hT' f := by\n  by_cases hf : Integrable f Œº\n  ¬∑ simp_rw [setToFun_eq _ hf, L1.setToL1_add_left hT hT']\n  ¬∑ simp_rw [setToFun_undef _ hf, add_zero]\n\n"}
{"name":"MeasureTheory.setToFun_add_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT T' T'' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC C' C'' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº T' C'\nhT'' : MeasureTheory.DominatedFinMeasAdditive Œº T'' C''\nh_add : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí Eq (T'' s) (HAdd.hAdd (T s) (T' s))\nf : Œ± ‚Üí E\n‚ä¢ Eq (MeasureTheory.setToFun Œº T'' hT'' f) (HAdd.hAdd (MeasureTheory.setToFun Œº T hT f) (MeasureTheory.setToFun Œº T' hT' f))","decl":"theorem setToFun_add_left' (hT : DominatedFinMeasAdditive Œº T C)\n    (hT' : DominatedFinMeasAdditive Œº T' C') (hT'' : DominatedFinMeasAdditive Œº T'' C'')\n    (h_add : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí T'' s = T s + T' s) (f : Œ± ‚Üí E) :\n    setToFun Œº T'' hT'' f = setToFun Œº T hT f + setToFun Œº T' hT' f := by\n  by_cases hf : Integrable f Œº\n  ¬∑ simp_rw [setToFun_eq _ hf, L1.setToL1_add_left' hT hT' hT'' h_add]\n  ¬∑ simp_rw [setToFun_undef _ hf, add_zero]\n\n"}
{"name":"MeasureTheory.setToFun_smul_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nc : Real\nf : Œ± ‚Üí E\n‚ä¢ Eq (MeasureTheory.setToFun Œº (fun s => HSMul.hSMul c (T s)) ‚ãØ f) (HSMul.hSMul c (MeasureTheory.setToFun Œº T hT f))","decl":"theorem setToFun_smul_left (hT : DominatedFinMeasAdditive Œº T C) (c : ‚Ñù) (f : Œ± ‚Üí E) :\n    setToFun Œº (fun s => c ‚Ä¢ T s) (hT.smul c) f = c ‚Ä¢ setToFun Œº T hT f := by\n  by_cases hf : Integrable f Œº\n  ¬∑ simp_rw [setToFun_eq _ hf, L1.setToL1_smul_left hT c]\n  ¬∑ simp_rw [setToFun_undef _ hf, smul_zero]\n\n"}
{"name":"MeasureTheory.setToFun_smul_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº T' C'\nc : Real\nh_smul : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí Eq (T' s) (HSMul.hSMul c (T s))\nf : Œ± ‚Üí E\n‚ä¢ Eq (MeasureTheory.setToFun Œº T' hT' f) (HSMul.hSMul c (MeasureTheory.setToFun Œº T hT f))","decl":"theorem setToFun_smul_left' (hT : DominatedFinMeasAdditive Œº T C)\n    (hT' : DominatedFinMeasAdditive Œº T' C') (c : ‚Ñù)\n    (h_smul : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí T' s = c ‚Ä¢ T s) (f : Œ± ‚Üí E) :\n    setToFun Œº T' hT' f = c ‚Ä¢ setToFun Œº T hT f := by\n  by_cases hf : Integrable f Œº\n  ¬∑ simp_rw [setToFun_eq _ hf, L1.setToL1_smul_left' hT hT' c h_smul]\n  ¬∑ simp_rw [setToFun_undef _ hf, smul_zero]\n\n"}
{"name":"MeasureTheory.setToFun_zero","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\n‚ä¢ Eq (MeasureTheory.setToFun Œº T hT 0) 0","decl":"@[simp]\ntheorem setToFun_zero (hT : DominatedFinMeasAdditive Œº T C) : setToFun Œº T hT (0 : Œ± ‚Üí E) = 0 := by\n  erw [setToFun_eq hT (integrable_zero _ _ _), Integrable.toL1_zero, ContinuousLinearMap.map_zero]\n\n"}
{"name":"MeasureTheory.setToFun_zero_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nC : Real\nf : Œ± ‚Üí E\nhT : MeasureTheory.DominatedFinMeasAdditive Œº 0 C\n‚ä¢ Eq (MeasureTheory.setToFun Œº 0 hT f) 0","decl":"@[simp]\ntheorem setToFun_zero_left {hT : DominatedFinMeasAdditive Œº (0 : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F) C} :\n    setToFun Œº 0 hT f = 0 := by\n  by_cases hf : Integrable f Œº\n  ¬∑ rw [setToFun_eq hT hf]; exact L1.setToL1_zero_left hT _\n  ¬∑ exact setToFun_undef hT hf\n\n"}
{"name":"MeasureTheory.setToFun_zero_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nf : Œ± ‚Üí E\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nh_zero : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí Eq (T s) 0\n‚ä¢ Eq (MeasureTheory.setToFun Œº T hT f) 0","decl":"theorem setToFun_zero_left' (hT : DominatedFinMeasAdditive Œº T C)\n    (h_zero : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí T s = 0) : setToFun Œº T hT f = 0 := by\n  by_cases hf : Integrable f Œº\n  ¬∑ rw [setToFun_eq hT hf]; exact L1.setToL1_zero_left' hT h_zero _\n  ¬∑ exact setToFun_undef hT hf\n\n"}
{"name":"MeasureTheory.setToFun_add","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nf g : Œ± ‚Üí E\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhf : MeasureTheory.Integrable f Œº\nhg : MeasureTheory.Integrable g Œº\n‚ä¢ Eq (MeasureTheory.setToFun Œº T hT (HAdd.hAdd f g)) (HAdd.hAdd (MeasureTheory.setToFun Œº T hT f) (MeasureTheory.setToFun Œº T hT g))","decl":"theorem setToFun_add (hT : DominatedFinMeasAdditive Œº T C) (hf : Integrable f Œº)\n    (hg : Integrable g Œº) : setToFun Œº T hT (f + g) = setToFun Œº T hT f + setToFun Œº T hT g := by\n  rw [setToFun_eq hT (hf.add hg), setToFun_eq hT hf, setToFun_eq hT hg, Integrable.toL1_add,\n    (L1.setToL1 hT).map_add]\n\n"}
{"name":"MeasureTheory.setToFun_finset_sum'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nŒπ : Type u_7\ns : Finset Œπ\nf : Œπ ‚Üí Œ± ‚Üí E\nhf : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí MeasureTheory.Integrable (f i) Œº\n‚ä¢ Eq (MeasureTheory.setToFun Œº T hT (s.sum fun i => f i)) (s.sum fun i => MeasureTheory.setToFun Œº T hT (f i))","decl":"theorem setToFun_finset_sum' (hT : DominatedFinMeasAdditive Œº T C) {Œπ} (s : Finset Œπ)\n    {f : Œπ ‚Üí Œ± ‚Üí E} (hf : ‚àÄ i ‚àà s, Integrable (f i) Œº) :\n    setToFun Œº T hT (‚àë i ‚àà s, f i) = ‚àë i ‚àà s, setToFun Œº T hT (f i) := by\n  classical\n  revert hf\n  refine Finset.induction_on s ?_ ?_\n  ¬∑ intro _\n    simp only [setToFun_zero, Finset.sum_empty]\n  ¬∑ intro i s his ih hf\n    simp only [his, Finset.sum_insert, not_false_iff]\n    rw [setToFun_add hT (hf i (Finset.mem_insert_self i s)) _]\n    ¬∑ rw [ih fun i hi => hf i (Finset.mem_insert_of_mem hi)]\n    ¬∑ convert integrable_finset_sum s fun i hi => hf i (Finset.mem_insert_of_mem hi) with x\n      simp\n\n"}
{"name":"MeasureTheory.setToFun_finset_sum","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nŒπ : Type u_7\ns : Finset Œπ\nf : Œπ ‚Üí Œ± ‚Üí E\nhf : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí MeasureTheory.Integrable (f i) Œº\n‚ä¢ Eq (MeasureTheory.setToFun Œº T hT fun a => s.sum fun i => f i a) (s.sum fun i => MeasureTheory.setToFun Œº T hT (f i))","decl":"theorem setToFun_finset_sum (hT : DominatedFinMeasAdditive Œº T C) {Œπ} (s : Finset Œπ) {f : Œπ ‚Üí Œ± ‚Üí E}\n    (hf : ‚àÄ i ‚àà s, Integrable (f i) Œº) :\n    (setToFun Œº T hT fun a => ‚àë i ‚àà s, f i a) = ‚àë i ‚àà s, setToFun Œº T hT (f i) := by\n  convert setToFun_finset_sum' hT s hf with a; simp\n\n"}
{"name":"MeasureTheory.setToFun_neg","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nf : Œ± ‚Üí E\n‚ä¢ Eq (MeasureTheory.setToFun Œº T hT (Neg.neg f)) (Neg.neg (MeasureTheory.setToFun Œº T hT f))","decl":"theorem setToFun_neg (hT : DominatedFinMeasAdditive Œº T C) (f : Œ± ‚Üí E) :\n    setToFun Œº T hT (-f) = -setToFun Œº T hT f := by\n  by_cases hf : Integrable f Œº\n  ¬∑ rw [setToFun_eq hT hf, setToFun_eq hT hf.neg, Integrable.toL1_neg,\n      (L1.setToL1 hT).map_neg]\n  ¬∑ rw [setToFun_undef hT hf, setToFun_undef hT, neg_zero]\n    rwa [‚Üê integrable_neg_iff] at hf\n\n"}
{"name":"MeasureTheory.setToFun_sub","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nf g : Œ± ‚Üí E\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhf : MeasureTheory.Integrable f Œº\nhg : MeasureTheory.Integrable g Œº\n‚ä¢ Eq (MeasureTheory.setToFun Œº T hT (HSub.hSub f g)) (HSub.hSub (MeasureTheory.setToFun Œº T hT f) (MeasureTheory.setToFun Œº T hT g))","decl":"theorem setToFun_sub (hT : DominatedFinMeasAdditive Œº T C) (hf : Integrable f Œº)\n    (hg : Integrable g Œº) : setToFun Œº T hT (f - g) = setToFun Œº T hT f - setToFun Œº T hT g := by\n  rw [sub_eq_add_neg, sub_eq_add_neg, setToFun_add hT hf hg.neg, setToFun_neg hT g]\n\n"}
{"name":"MeasureTheory.setToFun_smul","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nùïú : Type u_6\ninst‚úù‚Å∑ : NormedAddCommGroup E\ninst‚úù‚Å∂ : NormedSpace Real E\ninst‚úù‚Åµ : NormedAddCommGroup F\ninst‚úù‚Å¥ : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\ninst‚úù¬≤ : NontriviallyNormedField ùïú\ninst‚úù¬π : NormedSpace ùïú E\ninst‚úù : NormedSpace ùïú F\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nh_smul : ‚àÄ (c : ùïú) (s : Set Œ±) (x : E), Eq ((T s) (HSMul.hSMul c x)) (HSMul.hSMul c ((T s) x))\nc : ùïú\nf : Œ± ‚Üí E\n‚ä¢ Eq (MeasureTheory.setToFun Œº T hT (HSMul.hSMul c f)) (HSMul.hSMul c (MeasureTheory.setToFun Œº T hT f))","decl":"theorem setToFun_smul [NontriviallyNormedField ùïú] [NormedSpace ùïú E] [NormedSpace ùïú F]\n    (hT : DominatedFinMeasAdditive Œº T C) (h_smul : ‚àÄ c : ùïú, ‚àÄ s x, T s (c ‚Ä¢ x) = c ‚Ä¢ T s x) (c : ùïú)\n    (f : Œ± ‚Üí E) : setToFun Œº T hT (c ‚Ä¢ f) = c ‚Ä¢ setToFun Œº T hT f := by\n  by_cases hf : Integrable f Œº\n  ¬∑ rw [setToFun_eq hT hf, setToFun_eq hT, Integrable.toL1_smul',\n      L1.setToL1_smul hT h_smul c _]\n  ¬∑ by_cases hr : c = 0\n    ¬∑ rw [hr]; simp\n    ¬∑ have hf' : ¬¨Integrable (c ‚Ä¢ f) Œº := by rwa [integrable_smul_iff hr f]\n      rw [setToFun_undef hT hf, setToFun_undef hT hf', smul_zero]\n\n"}
{"name":"MeasureTheory.setToFun_congr_ae","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nf g : Œ± ‚Üí E\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nh : (MeasureTheory.ae Œº).EventuallyEq f g\n‚ä¢ Eq (MeasureTheory.setToFun Œº T hT f) (MeasureTheory.setToFun Œº T hT g)","decl":"theorem setToFun_congr_ae (hT : DominatedFinMeasAdditive Œº T C) (h : f =·µê[Œº] g) :\n    setToFun Œº T hT f = setToFun Œº T hT g := by\n  by_cases hfi : Integrable f Œº\n  ¬∑ have hgi : Integrable g Œº := hfi.congr h\n    rw [setToFun_eq hT hfi, setToFun_eq hT hgi, (Integrable.toL1_eq_toL1_iff f g hfi hgi).2 h]\n  ¬∑ have hgi : ¬¨Integrable g Œº := by rw [integrable_congr h] at hfi; exact hfi\n    rw [setToFun_undef hT hfi, setToFun_undef hT hgi]\n\n"}
{"name":"MeasureTheory.setToFun_measure_zero","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nf : Œ± ‚Üí E\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nh : Eq Œº 0\n‚ä¢ Eq (MeasureTheory.setToFun Œº T hT f) 0","decl":"theorem setToFun_measure_zero (hT : DominatedFinMeasAdditive Œº T C) (h : Œº = 0) :\n    setToFun Œº T hT f = 0 := by\n  have : f =·µê[Œº] 0 := by simp [h, EventuallyEq]\n  rw [setToFun_congr_ae hT this, setToFun_zero]\n\n"}
{"name":"MeasureTheory.setToFun_measure_zero'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nf : Œ± ‚Üí E\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nh : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí Eq (Œº s) 0\n‚ä¢ Eq (MeasureTheory.setToFun Œº T hT f) 0","decl":"theorem setToFun_measure_zero' (hT : DominatedFinMeasAdditive Œº T C)\n    (h : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí Œº s = 0) : setToFun Œº T hT f = 0 :=\n  setToFun_zero_left' hT fun s hs hŒºs => hT.eq_zero_of_measure_zero hs (h s hs hŒºs)\n\n"}
{"name":"MeasureTheory.setToFun_toL1","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nf : Œ± ‚Üí E\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhf : MeasureTheory.Integrable f Œº\n‚ä¢ Eq (MeasureTheory.setToFun Œº T hT ‚Üë‚Üë(MeasureTheory.Integrable.toL1 f hf)) (MeasureTheory.setToFun Œº T hT f)","decl":"theorem setToFun_toL1 (hT : DominatedFinMeasAdditive Œº T C) (hf : Integrable f Œº) :\n    setToFun Œº T hT (hf.toL1 f) = setToFun Œº T hT f :=\n  setToFun_congr_ae hT hf.coeFn_toL1\n\n"}
{"name":"MeasureTheory.setToFun_indicator_const","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\ns : Set Œ±\nhs : MeasurableSet s\nhŒºs : Ne (Œº s) Top.top\nx : E\n‚ä¢ Eq (MeasureTheory.setToFun Œº T hT (s.indicator fun x_1 => x)) ((T s) x)","decl":"theorem setToFun_indicator_const (hT : DominatedFinMeasAdditive Œº T C) {s : Set Œ±}\n    (hs : MeasurableSet s) (hŒºs : Œº s ‚â† ‚àû) (x : E) :\n    setToFun Œº T hT (s.indicator fun _ => x) = T s x := by\n  rw [setToFun_congr_ae hT (@indicatorConstLp_coeFn _ _ _ 1 _ _ _ hs hŒºs x).symm]\n  rw [L1.setToFun_eq_setToL1 hT]\n  exact L1.setToL1_indicatorConstLp hT hs hŒºs x\n\n"}
{"name":"MeasureTheory.setToFun_const","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nx : E\n‚ä¢ Eq (MeasureTheory.setToFun Œº T hT fun x_1 => x) ((T Set.univ) x)","decl":"theorem setToFun_const [IsFiniteMeasure Œº] (hT : DominatedFinMeasAdditive Œº T C) (x : E) :\n    (setToFun Œº T hT fun _ => x) = T univ x := by\n  have : (fun _ : Œ± => x) = Set.indicator univ fun _ => x := (indicator_univ _).symm\n  rw [this]\n  exact setToFun_indicator_const hT MeasurableSet.univ (measure_ne_top _ _) x\n\n"}
{"name":"MeasureTheory.setToFun_mono_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nG'' : Type u_8\ninst‚úù¬≤ : NormedLatticeAddCommGroup G''\ninst‚úù¬π : NormedSpace Real G''\ninst‚úù : CompleteSpace G''\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E G''\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº T' C'\nhTT' : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí ‚àÄ (x : E), LE.le ((T s) x) ((T' s) x)\nf : Œ± ‚Üí E\n‚ä¢ LE.le (MeasureTheory.setToFun Œº T hT f) (MeasureTheory.setToFun Œº T' hT' f)","decl":"theorem setToFun_mono_left' {T T' : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] G''} {C C' : ‚Ñù}\n    (hT : DominatedFinMeasAdditive Œº T C) (hT' : DominatedFinMeasAdditive Œº T' C')\n    (hTT' : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí ‚àÄ x, T s x ‚â§ T' s x) (f : Œ± ‚Üí E) :\n    setToFun Œº T hT f ‚â§ setToFun Œº T' hT' f := by\n  by_cases hf : Integrable f Œº\n  ¬∑ simp_rw [setToFun_eq _ hf]; exact L1.setToL1_mono_left' hT hT' hTT' _\n  ¬∑ simp_rw [setToFun_undef _ hf]; rfl\n\n"}
{"name":"MeasureTheory.setToFun_mono_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nG'' : Type u_8\ninst‚úù¬≤ : NormedLatticeAddCommGroup G''\ninst‚úù¬π : NormedSpace Real G''\ninst‚úù : CompleteSpace G''\nT T' : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E G''\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº T' C'\nhTT' : ‚àÄ (s : Set Œ±) (x : E), LE.le ((T s) x) ((T' s) x)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ LE.le (MeasureTheory.setToFun Œº T hT ‚Üë‚Üëf) (MeasureTheory.setToFun Œº T' hT' ‚Üë‚Üëf)","decl":"theorem setToFun_mono_left {T T' : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] G''} {C C' : ‚Ñù}\n    (hT : DominatedFinMeasAdditive Œº T C) (hT' : DominatedFinMeasAdditive Œº T' C')\n    (hTT' : ‚àÄ s x, T s x ‚â§ T' s x) (f : Œ± ‚Üí‚ÇÅ[Œº] E) : setToFun Œº T hT f ‚â§ setToFun Œº T' hT' f :=\n  setToFun_mono_left' hT hT' (fun s _ _ x => hTT' s x) f\n\n"}
{"name":"MeasureTheory.setToFun_nonneg","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nG' : Type u_7\nG'' : Type u_8\ninst‚úù‚Å¥ : NormedLatticeAddCommGroup G''\ninst‚úù¬≥ : NormedSpace Real G''\ninst‚úù¬≤ : CompleteSpace G''\ninst‚úù¬π : NormedLatticeAddCommGroup G'\ninst‚úù : NormedSpace Real G'\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) G' G''\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT_nonneg : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí ‚àÄ (x : G'), LE.le 0 x ‚Üí LE.le 0 ((T s) x)\nf : Œ± ‚Üí G'\nhf : (MeasureTheory.ae Œº).EventuallyLE 0 f\n‚ä¢ LE.le 0 (MeasureTheory.setToFun Œº T hT f)","decl":"theorem setToFun_nonneg {T : Set Œ± ‚Üí G' ‚ÜíL[‚Ñù] G''} {C : ‚Ñù} (hT : DominatedFinMeasAdditive Œº T C)\n    (hT_nonneg : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí ‚àÄ x, 0 ‚â§ x ‚Üí 0 ‚â§ T s x) {f : Œ± ‚Üí G'}\n    (hf : 0 ‚â§·µê[Œº] f) : 0 ‚â§ setToFun Œº T hT f := by\n  by_cases hfi : Integrable f Œº\n  ¬∑ simp_rw [setToFun_eq _ hfi]\n    refine L1.setToL1_nonneg hT hT_nonneg ?_\n    rw [‚Üê Lp.coeFn_le]\n    have h0 := Lp.coeFn_zero G' 1 Œº\n    have h := Integrable.coeFn_toL1 hfi\n    filter_upwards [h0, h, hf] with _ h0a ha hfa\n    rw [h0a, ha]\n    exact hfa\n  ¬∑ simp_rw [setToFun_undef _ hfi]; rfl\n\n"}
{"name":"MeasureTheory.setToFun_mono","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nG' : Type u_7\nG'' : Type u_8\ninst‚úù‚Å¥ : NormedLatticeAddCommGroup G''\ninst‚úù¬≥ : NormedSpace Real G''\ninst‚úù¬≤ : CompleteSpace G''\ninst‚úù¬π : NormedLatticeAddCommGroup G'\ninst‚úù : NormedSpace Real G'\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) G' G''\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT_nonneg : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí ‚àÄ (x : G'), LE.le 0 x ‚Üí LE.le 0 ((T s) x)\nf g : Œ± ‚Üí G'\nhf : MeasureTheory.Integrable f Œº\nhg : MeasureTheory.Integrable g Œº\nhfg : (MeasureTheory.ae Œº).EventuallyLE f g\n‚ä¢ LE.le (MeasureTheory.setToFun Œº T hT f) (MeasureTheory.setToFun Œº T hT g)","decl":"theorem setToFun_mono {T : Set Œ± ‚Üí G' ‚ÜíL[‚Ñù] G''} {C : ‚Ñù} (hT : DominatedFinMeasAdditive Œº T C)\n    (hT_nonneg : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí ‚àÄ x, 0 ‚â§ x ‚Üí 0 ‚â§ T s x) {f g : Œ± ‚Üí G'}\n    (hf : Integrable f Œº) (hg : Integrable g Œº) (hfg : f ‚â§·µê[Œº] g) :\n    setToFun Œº T hT f ‚â§ setToFun Œº T hT g := by\n  rw [‚Üê sub_nonneg, ‚Üê setToFun_sub hT hg hf]\n  refine setToFun_nonneg hT hT_nonneg (hfg.mono fun a ha => ?_)\n  rw [Pi.sub_apply, Pi.zero_apply, sub_nonneg]\n  exact ha\n\n"}
{"name":"MeasureTheory.continuous_setToFun","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\n‚ä¢ Continuous fun f => MeasureTheory.setToFun Œº T hT ‚Üë‚Üëf","decl":"@[continuity]\ntheorem continuous_setToFun (hT : DominatedFinMeasAdditive Œº T C) :\n    Continuous fun f : Œ± ‚Üí‚ÇÅ[Œº] E => setToFun Œº T hT f := by\n  simp_rw [L1.setToFun_eq_setToL1 hT]; exact ContinuousLinearMap.continuous _\n\n"}
{"name":"MeasureTheory.tendsto_setToFun_of_L1","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nŒπ : Type u_7\nf : Œ± ‚Üí E\nhfi : MeasureTheory.Integrable f Œº\nfs : Œπ ‚Üí Œ± ‚Üí E\nl : Filter Œπ\nhfsi : Filter.Eventually (fun i => MeasureTheory.Integrable (fs i) Œº) l\nhfs : Filter.Tendsto (fun i => MeasureTheory.lintegral Œº fun x => ENorm.enorm (HSub.hSub (fs i x) (f x))) l (nhds 0)\n‚ä¢ Filter.Tendsto (fun i => MeasureTheory.setToFun Œº T hT (fs i)) l (nhds (MeasureTheory.setToFun Œº T hT f))","decl":"/-- If `F i ‚Üí f` in `L1`, then `setToFun Œº T hT (F i) ‚Üí setToFun Œº T hT f`. -/\ntheorem tendsto_setToFun_of_L1 (hT : DominatedFinMeasAdditive Œº T C) {Œπ} (f : Œ± ‚Üí E)\n    (hfi : Integrable f Œº) {fs : Œπ ‚Üí Œ± ‚Üí E} {l : Filter Œπ} (hfsi : ‚àÄ·∂† i in l, Integrable (fs i) Œº)\n    (hfs : Tendsto (fun i => ‚à´‚Åª x, ‚Äñfs i x - f x‚Äñ‚Çë ‚àÇŒº) l (ùìù 0)) :\n    Tendsto (fun i => setToFun Œº T hT (fs i)) l (ùìù <| setToFun Œº T hT f) := by\n  classical\n    let f_lp := hfi.toL1 f\n    let F_lp i := if hFi : Integrable (fs i) Œº then hFi.toL1 (fs i) else 0\n    have tendsto_L1 : Tendsto F_lp l (ùìù f_lp) := by\n      rw [Lp.tendsto_Lp_iff_tendsto_‚Ñíp']\n      simp_rw [eLpNorm_one_eq_lintegral_enorm, Pi.sub_apply]\n      refine (tendsto_congr' ?_).mp hfs\n      filter_upwards [hfsi] with i hi\n      refine lintegral_congr_ae ?_\n      filter_upwards [hi.coeFn_toL1, hfi.coeFn_toL1] with x hxi hxf\n      simp_rw [F_lp, dif_pos hi, hxi, f_lp, hxf]\n    suffices Tendsto (fun i => setToFun Œº T hT (F_lp i)) l (ùìù (setToFun Œº T hT f)) by\n      refine (tendsto_congr' ?_).mp this\n      filter_upwards [hfsi] with i hi\n      suffices h_ae_eq : F_lp i =·µê[Œº] fs i from setToFun_congr_ae hT h_ae_eq\n      simp_rw [F_lp, dif_pos hi]\n      exact hi.coeFn_toL1\n    rw [setToFun_congr_ae hT hfi.coeFn_toL1.symm]\n    exact ((continuous_setToFun hT).tendsto f_lp).comp tendsto_L1\n\n"}
{"name":"MeasureTheory.tendsto_setToFun_approxOn_of_measurable","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å∑ : NormedAddCommGroup E\ninst‚úù‚Å∂ : NormedSpace Real E\ninst‚úù‚Åµ : NormedAddCommGroup F\ninst‚úù‚Å¥ : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\ninst‚úù¬≤ : MeasurableSpace E\ninst‚úù¬π : BorelSpace E\nf : Œ± ‚Üí E\ns : Set E\ninst‚úù : TopologicalSpace.SeparableSpace ‚Üës\nhfi : MeasureTheory.Integrable f Œº\nhfm : Measurable f\nhs : Filter.Eventually (fun x => Membership.mem (closure s) (f x)) (MeasureTheory.ae Œº)\ny‚ÇÄ : E\nh‚ÇÄ : Membership.mem s y‚ÇÄ\nh‚ÇÄi : MeasureTheory.Integrable (fun x => y‚ÇÄ) Œº\n‚ä¢ Filter.Tendsto (fun n => MeasureTheory.setToFun Œº T hT ‚áë(MeasureTheory.SimpleFunc.approxOn f hfm s y‚ÇÄ h‚ÇÄ n)) Filter.atTop (nhds (MeasureTheory.setToFun Œº T hT f))","decl":"theorem tendsto_setToFun_approxOn_of_measurable (hT : DominatedFinMeasAdditive Œº T C)\n    [MeasurableSpace E] [BorelSpace E] {f : Œ± ‚Üí E} {s : Set E} [SeparableSpace s]\n    (hfi : Integrable f Œº) (hfm : Measurable f) (hs : ‚àÄ·µê x ‚àÇŒº, f x ‚àà closure s) {y‚ÇÄ : E}\n    (h‚ÇÄ : y‚ÇÄ ‚àà s) (h‚ÇÄi : Integrable (fun _ => y‚ÇÄ) Œº) :\n    Tendsto (fun n => setToFun Œº T hT (SimpleFunc.approxOn f hfm s y‚ÇÄ h‚ÇÄ n)) atTop\n      (ùìù <| setToFun Œº T hT f) :=\n  tendsto_setToFun_of_L1 hT _ hfi\n    (Eventually.of_forall (SimpleFunc.integrable_approxOn hfm hfi h‚ÇÄ h‚ÇÄi))\n    (SimpleFunc.tendsto_approxOn_L1_enorm hfm _ hs (hfi.sub h‚ÇÄi).2)\n\n"}
{"name":"MeasureTheory.tendsto_setToFun_approxOn_of_measurable_of_range_subset","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å∑ : NormedAddCommGroup E\ninst‚úù‚Å∂ : NormedSpace Real E\ninst‚úù‚Åµ : NormedAddCommGroup F\ninst‚úù‚Å¥ : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\ninst‚úù¬≤ : MeasurableSpace E\ninst‚úù¬π : BorelSpace E\nf : Œ± ‚Üí E\nfmeas : Measurable f\nhf : MeasureTheory.Integrable f Œº\ns : Set E\ninst‚úù : TopologicalSpace.SeparableSpace ‚Üës\nhs : HasSubset.Subset (Union.union (Set.range f) (Singleton.singleton 0)) s\n‚ä¢ Filter.Tendsto (fun n => MeasureTheory.setToFun Œº T hT ‚áë(MeasureTheory.SimpleFunc.approxOn f fmeas s 0 ‚ãØ n)) Filter.atTop (nhds (MeasureTheory.setToFun Œº T hT f))","decl":"theorem tendsto_setToFun_approxOn_of_measurable_of_range_subset\n    (hT : DominatedFinMeasAdditive Œº T C) [MeasurableSpace E] [BorelSpace E] {f : Œ± ‚Üí E}\n    (fmeas : Measurable f) (hf : Integrable f Œº) (s : Set E) [SeparableSpace s]\n    (hs : range f ‚à™ {0} ‚äÜ s) :\n    Tendsto (fun n => setToFun Œº T hT (SimpleFunc.approxOn f fmeas s 0 (hs <| by simp) n)) atTop\n      (ùìù <| setToFun Œº T hT f) := by\n  refine tendsto_setToFun_approxOn_of_measurable hT hf fmeas ?_ _ (integrable_zero _ _ _)\n  exact Eventually.of_forall fun x => subset_closure (hs (Set.mem_union_left _ (mem_range_self _)))\n\n"}
{"name":"MeasureTheory.continuous_L1_toL1","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù : NormedAddCommGroup G\nm : MeasurableSpace Œ±\nŒº Œº' : MeasureTheory.Measure Œ±\nc' : ENNReal\nhc' : Ne c' Top.top\nhŒº'_le : LE.le Œº' (HSMul.hSMul c' Œº)\n‚ä¢ Continuous fun f => MeasureTheory.Integrable.toL1 ‚Üë‚Üëf ‚ãØ","decl":"/-- Auxiliary lemma for `setToFun_congr_measure`: the function sending `f : Œ± ‚Üí‚ÇÅ[Œº] G` to\n`f : Œ± ‚Üí‚ÇÅ[Œº'] G` is continuous when `Œº' ‚â§ c' ‚Ä¢ Œº` for `c' ‚â† ‚àû`. -/\ntheorem continuous_L1_toL1 {Œº' : Measure Œ±} (c' : ‚Ñù‚â•0‚àû) (hc' : c' ‚â† ‚àû) (hŒº'_le : Œº' ‚â§ c' ‚Ä¢ Œº) :\n    Continuous fun f : Œ± ‚Üí‚ÇÅ[Œº] G =>\n      (Integrable.of_measure_le_smul c' hc' hŒº'_le (L1.integrable_coeFn f)).toL1 f := by\n  by_cases hc'0 : c' = 0\n  ¬∑ have hŒº'0 : Œº' = 0 := by rw [‚Üê Measure.nonpos_iff_eq_zero']; refine hŒº'_le.trans ?_; simp [hc'0]\n    have h_im_zero :\n      (fun f : Œ± ‚Üí‚ÇÅ[Œº] G =>\n          (Integrable.of_measure_le_smul c' hc' hŒº'_le (L1.integrable_coeFn f)).toL1 f) =\n        0 := by\n      ext1 f; ext1; simp_rw [hŒº'0]; simp only [ae_zero, EventuallyEq, eventually_bot]\n    rw [h_im_zero]\n    exact continuous_zero\n  rw [Metric.continuous_iff]\n  intro f Œµ hŒµ_pos\n  use Œµ / 2 / c'.toReal\n  refine ‚ü®div_pos (half_pos hŒµ_pos) (toReal_pos hc'0 hc'), ?_‚ü©\n  intro g hfg\n  rw [Lp.dist_def] at hfg ‚ä¢\n  let h_int := fun f' : Œ± ‚Üí‚ÇÅ[Œº] G => (L1.integrable_coeFn f').of_measure_le_smul c' hc' hŒº'_le\n  have :\n    eLpNorm (‚áë(Integrable.toL1 g (h_int g)) - ‚áë(Integrable.toL1 f (h_int f))) 1 Œº' =\n      eLpNorm (‚áëg - ‚áëf) 1 Œº' :=\n    eLpNorm_congr_ae ((Integrable.coeFn_toL1 _).sub (Integrable.coeFn_toL1 _))\n  rw [this]\n  have h_eLpNorm_ne_top : eLpNorm (‚áëg - ‚áëf) 1 Œº ‚â† ‚àû := by\n    rw [‚Üê eLpNorm_congr_ae (Lp.coeFn_sub _ _)]; exact Lp.eLpNorm_ne_top _\n  calc\n    (eLpNorm (‚áëg - ‚áëf) 1 Œº').toReal ‚â§ (c' * eLpNorm (‚áëg - ‚áëf) 1 Œº).toReal := by\n      refine toReal_mono (ENNReal.mul_ne_top hc' h_eLpNorm_ne_top) ?_\n      refine (eLpNorm_mono_measure (‚áëg - ‚áëf) hŒº'_le).trans_eq ?_\n      rw [eLpNorm_smul_measure_of_ne_zero hc'0, smul_eq_mul]\n      simp\n    _ = c'.toReal * (eLpNorm (‚áëg - ‚áëf) 1 Œº).toReal := toReal_mul\n    _ ‚â§ c'.toReal * (Œµ / 2 / c'.toReal) := by gcongr\n    _ = Œµ / 2 := by\n      refine mul_div_cancel‚ÇÄ (Œµ / 2) ?_; rw [Ne, toReal_eq_zero_iff]; simp [hc', hc'0]\n    _ < Œµ := half_lt_self hŒµ_pos\n\n"}
{"name":"MeasureTheory.setToFun_congr_measure_of_integrable","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nŒº' : MeasureTheory.Measure Œ±\nc' : ENNReal\nhc' : Ne c' Top.top\nhŒº'_le : LE.le Œº' (HSMul.hSMul c' Œº)\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº' T C'\nf : Œ± ‚Üí E\nhfŒº : MeasureTheory.Integrable f Œº\n‚ä¢ Eq (MeasureTheory.setToFun Œº T hT f) (MeasureTheory.setToFun Œº' T hT' f)","decl":"theorem setToFun_congr_measure_of_integrable {Œº' : Measure Œ±} (c' : ‚Ñù‚â•0‚àû) (hc' : c' ‚â† ‚àû)\n    (hŒº'_le : Œº' ‚â§ c' ‚Ä¢ Œº) (hT : DominatedFinMeasAdditive Œº T C)\n    (hT' : DominatedFinMeasAdditive Œº' T C') (f : Œ± ‚Üí E) (hfŒº : Integrable f Œº) :\n    setToFun Œº T hT f = setToFun Œº' T hT' f := by\n  -- integrability for `Œº` implies integrability for `Œº'`.\n  have h_int : ‚àÄ g : Œ± ‚Üí E, Integrable g Œº ‚Üí Integrable g Œº' := fun g hg =>\n    Integrable.of_measure_le_smul c' hc' hŒº'_le hg\n  -- We use `Integrable.induction`\n  apply hfŒº.induction (P := fun f => setToFun Œº T hT f = setToFun Œº' T hT' f)\n  ¬∑ intro c s hs hŒºs\n    have hŒº's : Œº' s ‚â† ‚àû := by\n      refine ((hŒº'_le s).trans_lt ?_).ne\n      rw [Measure.smul_apply, smul_eq_mul]\n      exact ENNReal.mul_lt_top hc'.lt_top hŒºs\n    rw [setToFun_indicator_const hT hs hŒºs.ne, setToFun_indicator_const hT' hs hŒº's]\n  ¬∑ intro f‚ÇÇ g‚ÇÇ _ hf‚ÇÇ hg‚ÇÇ h_eq_f h_eq_g\n    rw [setToFun_add hT hf‚ÇÇ hg‚ÇÇ, setToFun_add hT' (h_int f‚ÇÇ hf‚ÇÇ) (h_int g‚ÇÇ hg‚ÇÇ), h_eq_f, h_eq_g]\n  ¬∑ refine isClosed_eq (continuous_setToFun hT) ?_\n    have :\n      (fun f : Œ± ‚Üí‚ÇÅ[Œº] E => setToFun Œº' T hT' f) = fun f : Œ± ‚Üí‚ÇÅ[Œº] E =>\n        setToFun Œº' T hT' ((h_int f (L1.integrable_coeFn f)).toL1 f) := by\n      ext1 f; exact setToFun_congr_ae hT' (Integrable.coeFn_toL1 _).symm\n    rw [this]\n    exact (continuous_setToFun hT').comp (continuous_L1_toL1 c' hc' hŒº'_le)\n  ¬∑ intro f‚ÇÇ g‚ÇÇ hfg _ hf_eq\n    have hfg' : f‚ÇÇ =·µê[Œº'] g‚ÇÇ := (Measure.absolutelyContinuous_of_le_smul hŒº'_le).ae_eq hfg\n    rw [‚Üê setToFun_congr_ae hT hfg, hf_eq, setToFun_congr_ae hT' hfg']\n\n"}
{"name":"MeasureTheory.setToFun_congr_measure","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nŒº' : MeasureTheory.Measure Œ±\nc c' : ENNReal\nhc : Ne c Top.top\nhc' : Ne c' Top.top\nhŒº_le : LE.le Œº (HSMul.hSMul c Œº')\nhŒº'_le : LE.le Œº' (HSMul.hSMul c' Œº)\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Œº' T C'\nf : Œ± ‚Üí E\n‚ä¢ Eq (MeasureTheory.setToFun Œº T hT f) (MeasureTheory.setToFun Œº' T hT' f)","decl":"theorem setToFun_congr_measure {Œº' : Measure Œ±} (c c' : ‚Ñù‚â•0‚àû) (hc : c ‚â† ‚àû) (hc' : c' ‚â† ‚àû)\n    (hŒº_le : Œº ‚â§ c ‚Ä¢ Œº') (hŒº'_le : Œº' ‚â§ c' ‚Ä¢ Œº) (hT : DominatedFinMeasAdditive Œº T C)\n    (hT' : DominatedFinMeasAdditive Œº' T C') (f : Œ± ‚Üí E) :\n    setToFun Œº T hT f = setToFun Œº' T hT' f := by\n  by_cases hf : Integrable f Œº\n  ¬∑ exact setToFun_congr_measure_of_integrable c' hc' hŒº'_le hT hT' f hf\n  ¬∑ -- if `f` is not integrable, both `setToFun` are 0.\n    have h_int : ‚àÄ g : Œ± ‚Üí E, ¬¨Integrable g Œº ‚Üí ¬¨Integrable g Œº' := fun g =>\n      mt fun h => h.of_measure_le_smul _ hc hŒº_le\n    simp_rw [setToFun_undef _ hf, setToFun_undef _ (h_int f hf)]\n\n"}
{"name":"MeasureTheory.setToFun_congr_measure_of_add_right","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nŒº' : MeasureTheory.Measure Œ±\nhT_add : MeasureTheory.DominatedFinMeasAdditive (HAdd.hAdd Œº Œº') T C'\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nf : Œ± ‚Üí E\nhf : MeasureTheory.Integrable f (HAdd.hAdd Œº Œº')\n‚ä¢ Eq (MeasureTheory.setToFun (HAdd.hAdd Œº Œº') T hT_add f) (MeasureTheory.setToFun Œº T hT f)","decl":"theorem setToFun_congr_measure_of_add_right {Œº' : Measure Œ±}\n    (hT_add : DominatedFinMeasAdditive (Œº + Œº') T C') (hT : DominatedFinMeasAdditive Œº T C)\n    (f : Œ± ‚Üí E) (hf : Integrable f (Œº + Œº')) :\n    setToFun (Œº + Œº') T hT_add f = setToFun Œº T hT f := by\n  refine setToFun_congr_measure_of_integrable 1 one_ne_top ?_ hT_add hT f hf\n  rw [one_smul]\n  nth_rw 1 [‚Üê add_zero Œº]\n  exact add_le_add le_rfl bot_le\n\n"}
{"name":"MeasureTheory.setToFun_congr_measure_of_add_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nŒº' : MeasureTheory.Measure Œ±\nhT_add : MeasureTheory.DominatedFinMeasAdditive (HAdd.hAdd Œº Œº') T C'\nhT : MeasureTheory.DominatedFinMeasAdditive Œº' T C\nf : Œ± ‚Üí E\nhf : MeasureTheory.Integrable f (HAdd.hAdd Œº Œº')\n‚ä¢ Eq (MeasureTheory.setToFun (HAdd.hAdd Œº Œº') T hT_add f) (MeasureTheory.setToFun Œº' T hT f)","decl":"theorem setToFun_congr_measure_of_add_left {Œº' : Measure Œ±}\n    (hT_add : DominatedFinMeasAdditive (Œº + Œº') T C') (hT : DominatedFinMeasAdditive Œº' T C)\n    (f : Œ± ‚Üí E) (hf : Integrable f (Œº + Œº')) :\n    setToFun (Œº + Œº') T hT_add f = setToFun Œº' T hT f := by\n  refine setToFun_congr_measure_of_integrable 1 one_ne_top ?_ hT_add hT f hf\n  rw [one_smul]\n  nth_rw 1 [‚Üê zero_add Œº']\n  exact add_le_add bot_le le_rfl\n\n"}
{"name":"MeasureTheory.setToFun_top_smul_measure","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive (HSMul.hSMul Top.top Œº) T C\nf : Œ± ‚Üí E\n‚ä¢ Eq (MeasureTheory.setToFun (HSMul.hSMul Top.top Œº) T hT f) 0","decl":"theorem setToFun_top_smul_measure (hT : DominatedFinMeasAdditive (‚àû ‚Ä¢ Œº) T C) (f : Œ± ‚Üí E) :\n    setToFun (‚àû ‚Ä¢ Œº) T hT f = 0 := by\n  refine setToFun_measure_zero' hT fun s _ hŒºs => ?_\n  rw [lt_top_iff_ne_top] at hŒºs\n  simp only [true_and, Measure.smul_apply, ENNReal.mul_eq_top, eq_self_iff_true,\n    top_ne_zero, Ne, not_false_iff, not_or, Classical.not_not, smul_eq_mul] at hŒºs\n  simp only [hŒºs.right, Measure.smul_apply, mul_zero, smul_eq_mul]\n\n"}
{"name":"MeasureTheory.setToFun_congr_smul_measure","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nc : ENNReal\nhc_ne_top : Ne c Top.top\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhT_smul : MeasureTheory.DominatedFinMeasAdditive (HSMul.hSMul c Œº) T C'\nf : Œ± ‚Üí E\n‚ä¢ Eq (MeasureTheory.setToFun Œº T hT f) (MeasureTheory.setToFun (HSMul.hSMul c Œº) T hT_smul f)","decl":"theorem setToFun_congr_smul_measure (c : ‚Ñù‚â•0‚àû) (hc_ne_top : c ‚â† ‚àû)\n    (hT : DominatedFinMeasAdditive Œº T C) (hT_smul : DominatedFinMeasAdditive (c ‚Ä¢ Œº) T C')\n    (f : Œ± ‚Üí E) : setToFun Œº T hT f = setToFun (c ‚Ä¢ Œº) T hT_smul f := by\n  by_cases hc0 : c = 0\n  ¬∑ simp [hc0] at hT_smul\n    have h : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí T s = 0 := fun s hs _ => hT_smul.eq_zero hs\n    rw [setToFun_zero_left' _ h, setToFun_measure_zero]\n    simp [hc0]\n  refine setToFun_congr_measure c‚Åª¬π c ?_ hc_ne_top (le_of_eq ?_) le_rfl hT hT_smul f\n  ¬∑ simp [hc0]\n  ¬∑ rw [smul_smul, ENNReal.inv_mul_cancel hc0 hc_ne_top, one_smul]\n\n"}
{"name":"MeasureTheory.norm_setToFun_le_mul_norm","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\nhC : LE.le 0 C\n‚ä¢ LE.le (Norm.norm (MeasureTheory.setToFun Œº T hT ‚Üë‚Üëf)) (HMul.hMul C (Norm.norm f))","decl":"theorem norm_setToFun_le_mul_norm (hT : DominatedFinMeasAdditive Œº T C) (f : Œ± ‚Üí‚ÇÅ[Œº] E)\n    (hC : 0 ‚â§ C) : ‚ÄñsetToFun Œº T hT f‚Äñ ‚â§ C * ‚Äñf‚Äñ := by\n  rw [L1.setToFun_eq_setToL1]; exact L1.norm_setToL1_le_mul_norm hT hC f\n\n"}
{"name":"MeasureTheory.norm_setToFun_le_mul_norm'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ LE.le (Norm.norm (MeasureTheory.setToFun Œº T hT ‚Üë‚Üëf)) (HMul.hMul (Max.max C 0) (Norm.norm f))","decl":"theorem norm_setToFun_le_mul_norm' (hT : DominatedFinMeasAdditive Œº T C) (f : Œ± ‚Üí‚ÇÅ[Œº] E) :\n    ‚ÄñsetToFun Œº T hT f‚Äñ ‚â§ max C 0 * ‚Äñf‚Äñ := by\n  rw [L1.setToFun_eq_setToL1]; exact L1.norm_setToL1_le_mul_norm' hT f\n\n"}
{"name":"MeasureTheory.norm_setToFun_le","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nf : Œ± ‚Üí E\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhf : MeasureTheory.Integrable f Œº\nhC : LE.le 0 C\n‚ä¢ LE.le (Norm.norm (MeasureTheory.setToFun Œº T hT f)) (HMul.hMul C (Norm.norm (MeasureTheory.Integrable.toL1 f hf)))","decl":"theorem norm_setToFun_le (hT : DominatedFinMeasAdditive Œº T C) (hf : Integrable f Œº) (hC : 0 ‚â§ C) :\n    ‚ÄñsetToFun Œº T hT f‚Äñ ‚â§ C * ‚Äñhf.toL1 f‚Äñ := by\n  rw [setToFun_eq hT hf]; exact L1.norm_setToL1_le_mul_norm hT hC _\n\n"}
{"name":"MeasureTheory.norm_setToFun_le'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nf : Œ± ‚Üí E\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nhf : MeasureTheory.Integrable f Œº\n‚ä¢ LE.le (Norm.norm (MeasureTheory.setToFun Œº T hT f)) (HMul.hMul (Max.max C 0) (Norm.norm (MeasureTheory.Integrable.toL1 f hf)))","decl":"theorem norm_setToFun_le' (hT : DominatedFinMeasAdditive Œº T C) (hf : Integrable f Œº) :\n    ‚ÄñsetToFun Œº T hT f‚Äñ ‚â§ max C 0 * ‚Äñhf.toL1 f‚Äñ := by\n  rw [setToFun_eq hT hf]; exact L1.norm_setToL1_le_mul_norm' hT _\n\n"}
{"name":"MeasureTheory.tendsto_setToFun_of_dominated_convergence","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nfs : Nat ‚Üí Œ± ‚Üí E\nf : Œ± ‚Üí E\nbound : Œ± ‚Üí Real\nfs_measurable : ‚àÄ (n : Nat), MeasureTheory.AEStronglyMeasurable (fs n) Œº\nbound_integrable : MeasureTheory.Integrable bound Œº\nh_bound : ‚àÄ (n : Nat), Filter.Eventually (fun a => LE.le (Norm.norm (fs n a)) (bound a)) (MeasureTheory.ae Œº)\nh_lim : Filter.Eventually (fun a => Filter.Tendsto (fun n => fs n a) Filter.atTop (nhds (f a))) (MeasureTheory.ae Œº)\n‚ä¢ Filter.Tendsto (fun n => MeasureTheory.setToFun Œº T hT (fs n)) Filter.atTop (nhds (MeasureTheory.setToFun Œº T hT f))","decl":"/-- Lebesgue dominated convergence theorem provides sufficient conditions under which almost\n  everywhere convergence of a sequence of functions implies the convergence of their image by\n  `setToFun`.\n  We could weaken the condition `bound_integrable` to require `HasFiniteIntegral bound Œº` instead\n  (i.e. not requiring that `bound` is measurable), but in all applications proving integrability\n  is easier. -/\ntheorem tendsto_setToFun_of_dominated_convergence (hT : DominatedFinMeasAdditive Œº T C)\n    {fs : ‚Ñï ‚Üí Œ± ‚Üí E} {f : Œ± ‚Üí E} (bound : Œ± ‚Üí ‚Ñù)\n    (fs_measurable : ‚àÄ n, AEStronglyMeasurable (fs n) Œº) (bound_integrable : Integrable bound Œº)\n    (h_bound : ‚àÄ n, ‚àÄ·µê a ‚àÇŒº, ‚Äñfs n a‚Äñ ‚â§ bound a)\n    (h_lim : ‚àÄ·µê a ‚àÇŒº, Tendsto (fun n => fs n a) atTop (ùìù (f a))) :\n    Tendsto (fun n => setToFun Œº T hT (fs n)) atTop (ùìù <| setToFun Œº T hT f) := by\n  -- `f` is a.e.-measurable, since it is the a.e.-pointwise limit of a.e.-measurable functions.\n  have f_measurable : AEStronglyMeasurable f Œº :=\n    aestronglyMeasurable_of_tendsto_ae _ fs_measurable h_lim\n  -- all functions we consider are integrable\n  have fs_int : ‚àÄ n, Integrable (fs n) Œº := fun n =>\n    bound_integrable.mono' (fs_measurable n) (h_bound _)\n  have f_int : Integrable f Œº :=\n    ‚ü®f_measurable,\n      hasFiniteIntegral_of_dominated_convergence bound_integrable.hasFiniteIntegral h_bound\n        h_lim‚ü©\n  -- it suffices to prove the result for the corresponding L1 functions\n  suffices\n    Tendsto (fun n => L1.setToL1 hT ((fs_int n).toL1 (fs n))) atTop\n      (ùìù (L1.setToL1 hT (f_int.toL1 f))) by\n    convert this with n\n    ¬∑ exact setToFun_eq hT (fs_int n)\n    ¬∑ exact setToFun_eq hT f_int\n  -- the convergence of setToL1 follows from the convergence of the L1 functions\n  refine L1.tendsto_setToL1 hT _ _ ?_\n  -- up to some rewriting, what we need to prove is `h_lim`\n  rw [tendsto_iff_norm_sub_tendsto_zero]\n  have lintegral_norm_tendsto_zero :\n    Tendsto (fun n => ENNReal.toReal <| ‚à´‚Åª a, ENNReal.ofReal ‚Äñfs n a - f a‚Äñ ‚àÇŒº) atTop (ùìù 0) :=\n    (tendsto_toReal zero_ne_top).comp\n      (tendsto_lintegral_norm_of_dominated_convergence fs_measurable\n        bound_integrable.hasFiniteIntegral h_bound h_lim)\n  convert lintegral_norm_tendsto_zero with n\n  rw [L1.norm_def]\n  congr 1\n  refine lintegral_congr_ae ?_\n  rw [‚Üê Integrable.toL1_sub]\n  refine ((fs_int n).sub f_int).coeFn_toL1.mono fun x hx => ?_\n  dsimp only\n  rw [hx, ofReal_norm_eq_enorm, Pi.sub_apply]\n\n"}
{"name":"MeasureTheory.tendsto_setToFun_filter_of_dominated_convergence","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nŒπ : Type u_7\nl : Filter Œπ\ninst‚úù : l.IsCountablyGenerated\nfs : Œπ ‚Üí Œ± ‚Üí E\nf : Œ± ‚Üí E\nbound : Œ± ‚Üí Real\nhfs_meas : Filter.Eventually (fun n => MeasureTheory.AEStronglyMeasurable (fs n) Œº) l\nh_bound : Filter.Eventually (fun n => Filter.Eventually (fun a => LE.le (Norm.norm (fs n a)) (bound a)) (MeasureTheory.ae Œº)) l\nbound_integrable : MeasureTheory.Integrable bound Œº\nh_lim : Filter.Eventually (fun a => Filter.Tendsto (fun n => fs n a) l (nhds (f a))) (MeasureTheory.ae Œº)\n‚ä¢ Filter.Tendsto (fun n => MeasureTheory.setToFun Œº T hT (fs n)) l (nhds (MeasureTheory.setToFun Œº T hT f))","decl":"/-- Lebesgue dominated convergence theorem for filters with a countable basis -/\ntheorem tendsto_setToFun_filter_of_dominated_convergence (hT : DominatedFinMeasAdditive Œº T C) {Œπ}\n    {l : Filter Œπ} [l.IsCountablyGenerated] {fs : Œπ ‚Üí Œ± ‚Üí E} {f : Œ± ‚Üí E} (bound : Œ± ‚Üí ‚Ñù)\n    (hfs_meas : ‚àÄ·∂† n in l, AEStronglyMeasurable (fs n) Œº)\n    (h_bound : ‚àÄ·∂† n in l, ‚àÄ·µê a ‚àÇŒº, ‚Äñfs n a‚Äñ ‚â§ bound a) (bound_integrable : Integrable bound Œº)\n    (h_lim : ‚àÄ·µê a ‚àÇŒº, Tendsto (fun n => fs n a) l (ùìù (f a))) :\n    Tendsto (fun n => setToFun Œº T hT (fs n)) l (ùìù <| setToFun Œº T hT f) := by\n  rw [tendsto_iff_seq_tendsto]\n  intro x xl\n  have hxl : ‚àÄ s ‚àà l, ‚àÉ a, ‚àÄ b ‚â• a, x b ‚àà s := by rwa [tendsto_atTop'] at xl\n  have h :\n    { x : Œπ | (fun n => AEStronglyMeasurable (fs n) Œº) x } ‚à©\n        { x : Œπ | (fun n => ‚àÄ·µê a ‚àÇŒº, ‚Äñfs n a‚Äñ ‚â§ bound a) x } ‚àà l :=\n    inter_mem hfs_meas h_bound\n  obtain ‚ü®k, h‚ü© := hxl _ h\n  rw [‚Üê tendsto_add_atTop_iff_nat k]\n  refine tendsto_setToFun_of_dominated_convergence hT bound ?_ bound_integrable ?_ ?_\n  ¬∑ exact fun n => (h _ (self_le_add_left _ _)).1\n  ¬∑ exact fun n => (h _ (self_le_add_left _ _)).2\n  ¬∑ filter_upwards [h_lim]\n    refine fun a h_lin => @Tendsto.comp _ _ _ (fun n => x (n + k)) (fun n => fs n a) _ _ _ h_lin ?_\n    rw [tendsto_add_atTop_iff_nat]\n    assumption\n\n"}
{"name":"MeasureTheory.continuousWithinAt_setToFun_of_dominated","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nX : Type u_7\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : FirstCountableTopology X\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nfs : X ‚Üí Œ± ‚Üí E\nx‚ÇÄ : X\nbound : Œ± ‚Üí Real\ns : Set X\nhfs_meas : Filter.Eventually (fun x => MeasureTheory.AEStronglyMeasurable (fs x) Œº) (nhdsWithin x‚ÇÄ s)\nh_bound : Filter.Eventually (fun x => Filter.Eventually (fun a => LE.le (Norm.norm (fs x a)) (bound a)) (MeasureTheory.ae Œº)) (nhdsWithin x‚ÇÄ s)\nbound_integrable : MeasureTheory.Integrable bound Œº\nh_cont : Filter.Eventually (fun a => ContinuousWithinAt (fun x => fs x a) s x‚ÇÄ) (MeasureTheory.ae Œº)\n‚ä¢ ContinuousWithinAt (fun x => MeasureTheory.setToFun Œº T hT (fs x)) s x‚ÇÄ","decl":"theorem continuousWithinAt_setToFun_of_dominated (hT : DominatedFinMeasAdditive Œº T C)\n    {fs : X ‚Üí Œ± ‚Üí E} {x‚ÇÄ : X} {bound : Œ± ‚Üí ‚Ñù} {s : Set X}\n    (hfs_meas : ‚àÄ·∂† x in ùìù[s] x‚ÇÄ, AEStronglyMeasurable (fs x) Œº)\n    (h_bound : ‚àÄ·∂† x in ùìù[s] x‚ÇÄ, ‚àÄ·µê a ‚àÇŒº, ‚Äñfs x a‚Äñ ‚â§ bound a) (bound_integrable : Integrable bound Œº)\n    (h_cont : ‚àÄ·µê a ‚àÇŒº, ContinuousWithinAt (fun x => fs x a) s x‚ÇÄ) :\n    ContinuousWithinAt (fun x => setToFun Œº T hT (fs x)) s x‚ÇÄ :=\n  tendsto_setToFun_filter_of_dominated_convergence hT bound ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫\n\n"}
{"name":"MeasureTheory.continuousAt_setToFun_of_dominated","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nX : Type u_7\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : FirstCountableTopology X\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nfs : X ‚Üí Œ± ‚Üí E\nx‚ÇÄ : X\nbound : Œ± ‚Üí Real\nhfs_meas : Filter.Eventually (fun x => MeasureTheory.AEStronglyMeasurable (fs x) Œº) (nhds x‚ÇÄ)\nh_bound : Filter.Eventually (fun x => Filter.Eventually (fun a => LE.le (Norm.norm (fs x a)) (bound a)) (MeasureTheory.ae Œº)) (nhds x‚ÇÄ)\nbound_integrable : MeasureTheory.Integrable bound Œº\nh_cont : Filter.Eventually (fun a => ContinuousAt (fun x => fs x a) x‚ÇÄ) (MeasureTheory.ae Œº)\n‚ä¢ ContinuousAt (fun x => MeasureTheory.setToFun Œº T hT (fs x)) x‚ÇÄ","decl":"theorem continuousAt_setToFun_of_dominated (hT : DominatedFinMeasAdditive Œº T C) {fs : X ‚Üí Œ± ‚Üí E}\n    {x‚ÇÄ : X} {bound : Œ± ‚Üí ‚Ñù} (hfs_meas : ‚àÄ·∂† x in ùìù x‚ÇÄ, AEStronglyMeasurable (fs x) Œº)\n    (h_bound : ‚àÄ·∂† x in ùìù x‚ÇÄ, ‚àÄ·µê a ‚àÇŒº, ‚Äñfs x a‚Äñ ‚â§ bound a) (bound_integrable : Integrable bound Œº)\n    (h_cont : ‚àÄ·µê a ‚àÇŒº, ContinuousAt (fun x => fs x a) x‚ÇÄ) :\n    ContinuousAt (fun x => setToFun Œº T hT (fs x)) x‚ÇÄ :=\n  tendsto_setToFun_filter_of_dominated_convergence hT bound ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫\n\n"}
{"name":"MeasureTheory.continuousOn_setToFun_of_dominated","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nX : Type u_7\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : FirstCountableTopology X\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nfs : X ‚Üí Œ± ‚Üí E\nbound : Œ± ‚Üí Real\ns : Set X\nhfs_meas : ‚àÄ (x : X), Membership.mem s x ‚Üí MeasureTheory.AEStronglyMeasurable (fs x) Œº\nh_bound : ‚àÄ (x : X), Membership.mem s x ‚Üí Filter.Eventually (fun a => LE.le (Norm.norm (fs x a)) (bound a)) (MeasureTheory.ae Œº)\nbound_integrable : MeasureTheory.Integrable bound Œº\nh_cont : Filter.Eventually (fun a => ContinuousOn (fun x => fs x a) s) (MeasureTheory.ae Œº)\n‚ä¢ ContinuousOn (fun x => MeasureTheory.setToFun Œº T hT (fs x)) s","decl":"theorem continuousOn_setToFun_of_dominated (hT : DominatedFinMeasAdditive Œº T C) {fs : X ‚Üí Œ± ‚Üí E}\n    {bound : Œ± ‚Üí ‚Ñù} {s : Set X} (hfs_meas : ‚àÄ x ‚àà s, AEStronglyMeasurable (fs x) Œº)\n    (h_bound : ‚àÄ x ‚àà s, ‚àÄ·µê a ‚àÇŒº, ‚Äñfs x a‚Äñ ‚â§ bound a) (bound_integrable : Integrable bound Œº)\n    (h_cont : ‚àÄ·µê a ‚àÇŒº, ContinuousOn (fun x => fs x a) s) :\n    ContinuousOn (fun x => setToFun Œº T hT (fs x)) s := by\n  intro x hx\n  refine continuousWithinAt_setToFun_of_dominated hT ?_ ?_ bound_integrable ?_\n  ¬∑ filter_upwards [self_mem_nhdsWithin] with x hx using hfs_meas x hx\n  ¬∑ filter_upwards [self_mem_nhdsWithin] with x hx using h_bound x hx\n  ¬∑ filter_upwards [h_cont] with a ha using ha x hx\n\n"}
{"name":"MeasureTheory.continuous_setToFun_of_dominated","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : CompleteSpace F\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nX : Type u_7\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : FirstCountableTopology X\nhT : MeasureTheory.DominatedFinMeasAdditive Œº T C\nfs : X ‚Üí Œ± ‚Üí E\nbound : Œ± ‚Üí Real\nhfs_meas : ‚àÄ (x : X), MeasureTheory.AEStronglyMeasurable (fs x) Œº\nh_bound : ‚àÄ (x : X), Filter.Eventually (fun a => LE.le (Norm.norm (fs x a)) (bound a)) (MeasureTheory.ae Œº)\nbound_integrable : MeasureTheory.Integrable bound Œº\nh_cont : Filter.Eventually (fun a => Continuous fun x => fs x a) (MeasureTheory.ae Œº)\n‚ä¢ Continuous fun x => MeasureTheory.setToFun Œº T hT (fs x)","decl":"theorem continuous_setToFun_of_dominated (hT : DominatedFinMeasAdditive Œº T C) {fs : X ‚Üí Œ± ‚Üí E}\n    {bound : Œ± ‚Üí ‚Ñù} (hfs_meas : ‚àÄ x, AEStronglyMeasurable (fs x) Œº)\n    (h_bound : ‚àÄ x, ‚àÄ·µê a ‚àÇŒº, ‚Äñfs x a‚Äñ ‚â§ bound a) (bound_integrable : Integrable bound Œº)\n    (h_cont : ‚àÄ·µê a ‚àÇŒº, Continuous fun x => fs x a) : Continuous fun x => setToFun Œº T hT (fs x) :=\n  continuous_iff_continuousAt.mpr fun _ =>\n    continuousAt_setToFun_of_dominated hT (Eventually.of_forall hfs_meas)\n        (Eventually.of_forall h_bound) ‚Äπ_‚Ä∫ <|\n      h_cont.mono fun _ => Continuous.continuousAt\n\n"}
