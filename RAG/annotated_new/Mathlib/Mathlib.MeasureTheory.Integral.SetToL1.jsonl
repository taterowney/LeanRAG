{"name":"MeasureTheory.FinMeasAdditive.zero","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_7\ninstâœ : AddCommMonoid Î²\nâŠ¢ MeasureTheory.FinMeasAdditive Î¼ 0","decl":"theorem zero : FinMeasAdditive Î¼ (0 : Set Î± â†’ Î²) := fun _ _ _ _ _ _ _ => by simp\n\n"}
{"name":"MeasureTheory.FinMeasAdditive.add","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_7\ninstâœ : AddCommMonoid Î²\nT T' : Set Î± â†’ Î²\nhT : MeasureTheory.FinMeasAdditive Î¼ T\nhT' : MeasureTheory.FinMeasAdditive Î¼ T'\nâŠ¢ MeasureTheory.FinMeasAdditive Î¼ (HAdd.hAdd T T')","decl":"theorem add (hT : FinMeasAdditive Î¼ T) (hT' : FinMeasAdditive Î¼ T') :\n    FinMeasAdditive Î¼ (T + T') := by\n  intro s t hs ht hÎ¼s hÎ¼t hst\n  simp only [hT s t hs ht hÎ¼s hÎ¼t hst, hT' s t hs ht hÎ¼s hÎ¼t hst, Pi.add_apply]\n  abel\n\n"}
{"name":"MeasureTheory.FinMeasAdditive.smul","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nğ•œ : Type u_6\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_7\ninstâœÂ² : AddCommMonoid Î²\nT : Set Î± â†’ Î²\ninstâœÂ¹ : Monoid ğ•œ\ninstâœ : DistribMulAction ğ•œ Î²\nhT : MeasureTheory.FinMeasAdditive Î¼ T\nc : ğ•œ\nâŠ¢ MeasureTheory.FinMeasAdditive Î¼ fun s => HSMul.hSMul c (T s)","decl":"theorem smul [Monoid ğ•œ] [DistribMulAction ğ•œ Î²] (hT : FinMeasAdditive Î¼ T) (c : ğ•œ) :\n    FinMeasAdditive Î¼ fun s => c â€¢ T s := fun s t hs ht hÎ¼s hÎ¼t hst => by\n  simp [hT s t hs ht hÎ¼s hÎ¼t hst]\n\n"}
{"name":"MeasureTheory.FinMeasAdditive.of_eq_top_imp_eq_top","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_7\ninstâœ : AddCommMonoid Î²\nT : Set Î± â†’ Î²\nÎ¼' : MeasureTheory.Measure Î±\nh : âˆ€ (s : Set Î±), MeasurableSet s â†’ Eq (Î¼ s) Top.top â†’ Eq (Î¼' s) Top.top\nhT : MeasureTheory.FinMeasAdditive Î¼ T\nâŠ¢ MeasureTheory.FinMeasAdditive Î¼' T","decl":"theorem of_eq_top_imp_eq_top {Î¼' : Measure Î±} (h : âˆ€ s, MeasurableSet s â†’ Î¼ s = âˆ â†’ Î¼' s = âˆ)\n    (hT : FinMeasAdditive Î¼ T) : FinMeasAdditive Î¼' T := fun s t hs ht hÎ¼'s hÎ¼'t hst =>\n  hT s t hs ht (mt (h s hs) hÎ¼'s) (mt (h t ht) hÎ¼'t) hst\n\n"}
{"name":"MeasureTheory.FinMeasAdditive.of_smul_measure","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_7\ninstâœ : AddCommMonoid Î²\nT : Set Î± â†’ Î²\nc : ENNReal\nhc_ne_top : Ne c Top.top\nhT : MeasureTheory.FinMeasAdditive (HSMul.hSMul c Î¼) T\nâŠ¢ MeasureTheory.FinMeasAdditive Î¼ T","decl":"theorem of_smul_measure (c : â„â‰¥0âˆ) (hc_ne_top : c â‰  âˆ) (hT : FinMeasAdditive (c â€¢ Î¼) T) :\n    FinMeasAdditive Î¼ T := by\n  refine of_eq_top_imp_eq_top (fun s _ hÎ¼s => ?_) hT\n  rw [Measure.smul_apply, smul_eq_mul, ENNReal.mul_eq_top] at hÎ¼s\n  simp only [hc_ne_top, or_false, Ne, false_and] at hÎ¼s\n  exact hÎ¼s.2\n\n"}
{"name":"MeasureTheory.FinMeasAdditive.smul_measure","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_7\ninstâœ : AddCommMonoid Î²\nT : Set Î± â†’ Î²\nc : ENNReal\nhc_ne_zero : Ne c 0\nhT : MeasureTheory.FinMeasAdditive Î¼ T\nâŠ¢ MeasureTheory.FinMeasAdditive (HSMul.hSMul c Î¼) T","decl":"theorem smul_measure (c : â„â‰¥0âˆ) (hc_ne_zero : c â‰  0) (hT : FinMeasAdditive Î¼ T) :\n    FinMeasAdditive (c â€¢ Î¼) T := by\n  refine of_eq_top_imp_eq_top (fun s _ hÎ¼s => ?_) hT\n  rw [Measure.smul_apply, smul_eq_mul, ENNReal.mul_eq_top]\n  simp only [hc_ne_zero, true_and, Ne, not_false_iff]\n  exact Or.inl hÎ¼s\n\n"}
{"name":"MeasureTheory.FinMeasAdditive.smul_measure_iff","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_7\ninstâœ : AddCommMonoid Î²\nT : Set Î± â†’ Î²\nc : ENNReal\nhc_ne_zero : Ne c 0\nhc_ne_top : Ne c Top.top\nâŠ¢ Iff (MeasureTheory.FinMeasAdditive (HSMul.hSMul c Î¼) T) (MeasureTheory.FinMeasAdditive Î¼ T)","decl":"theorem smul_measure_iff (c : â„â‰¥0âˆ) (hc_ne_zero : c â‰  0) (hc_ne_top : c â‰  âˆ) :\n    FinMeasAdditive (c â€¢ Î¼) T â†” FinMeasAdditive Î¼ T :=\n  âŸ¨fun hT => of_smul_measure c hc_ne_top hT, fun hT => smul_measure c hc_ne_zero hTâŸ©\n\n"}
{"name":"MeasureTheory.FinMeasAdditive.map_empty_eq_zero","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_8\ninstâœ : AddCancelMonoid Î²\nT : Set Î± â†’ Î²\nhT : MeasureTheory.FinMeasAdditive Î¼ T\nâŠ¢ Eq (T EmptyCollection.emptyCollection) 0","decl":"theorem map_empty_eq_zero {Î²} [AddCancelMonoid Î²] {T : Set Î± â†’ Î²} (hT : FinMeasAdditive Î¼ T) :\n    T âˆ… = 0 := by\n  have h_empty : Î¼ âˆ… â‰  âˆ := (measure_empty.le.trans_lt ENNReal.coe_lt_top).ne\n  specialize hT âˆ… âˆ… MeasurableSet.empty MeasurableSet.empty h_empty h_empty (disjoint_empty _)\n  rw [Set.union_empty] at hT\n  nth_rw 1 [â† add_zero (T âˆ…)] at hT\n  exact (add_left_cancel hT).symm\n\n"}
{"name":"MeasureTheory.FinMeasAdditive.map_iUnion_fin_meas_set_eq_sum","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_7\ninstâœ : AddCommMonoid Î²\nT : Set Î± â†’ Î²\nT_empty : Eq (T EmptyCollection.emptyCollection) 0\nh_add : MeasureTheory.FinMeasAdditive Î¼ T\nÎ¹ : Type u_8\nS : Î¹ â†’ Set Î±\nsÎ¹ : Finset Î¹\nhS_meas : âˆ€ (i : Î¹), MeasurableSet (S i)\nhSp : âˆ€ (i : Î¹), Membership.mem sÎ¹ i â†’ Ne (Î¼ (S i)) Top.top\nh_disj : âˆ€ (i : Î¹), Membership.mem sÎ¹ i â†’ âˆ€ (j : Î¹), Membership.mem sÎ¹ j â†’ Ne i j â†’ Disjoint (S i) (S j)\nâŠ¢ Eq (T (Set.iUnion fun i => Set.iUnion fun h => S i)) (sÎ¹.sum fun i => T (S i))","decl":"theorem map_iUnion_fin_meas_set_eq_sum (T : Set Î± â†’ Î²) (T_empty : T âˆ… = 0)\n    (h_add : FinMeasAdditive Î¼ T) {Î¹} (S : Î¹ â†’ Set Î±) (sÎ¹ : Finset Î¹)\n    (hS_meas : âˆ€ i, MeasurableSet (S i)) (hSp : âˆ€ i âˆˆ sÎ¹, Î¼ (S i) â‰  âˆ)\n    (h_disj : âˆ€áµ‰ (i âˆˆ sÎ¹) (j âˆˆ sÎ¹), i â‰  j â†’ Disjoint (S i) (S j)) :\n    T (â‹ƒ i âˆˆ sÎ¹, S i) = âˆ‘ i âˆˆ sÎ¹, T (S i) := by\n  classical\n  revert hSp h_disj\n  refine Finset.induction_on sÎ¹ ?_ ?_\n  Â· simp only [Finset.not_mem_empty, IsEmpty.forall_iff, iUnion_false, iUnion_empty, sum_empty,\n      forallâ‚‚_true_iff, imp_true_iff, forall_true_left, not_false_iff, T_empty]\n  intro a s has h hps h_disj\n  rw [Finset.sum_insert has, â† h]\n  swap; Â· exact fun i hi => hps i (Finset.mem_insert_of_mem hi)\n  swap\n  Â· exact fun i hi j hj hij =>\n      h_disj i (Finset.mem_insert_of_mem hi) j (Finset.mem_insert_of_mem hj) hij\n  rw [â†\n    h_add (S a) (â‹ƒ i âˆˆ s, S i) (hS_meas a) (measurableSet_biUnion _ fun i _ => hS_meas i)\n      (hps a (Finset.mem_insert_self a s))]\n  Â· congr; convert Finset.iSup_insert a s S\n  Â· exact (measure_biUnion_lt_top s.finite_toSet fun i hi â†¦\n      (hps i <| Finset.mem_insert_of_mem hi).lt_top).ne\n  Â· simp_rw [Set.disjoint_iUnion_right]\n    intro i hi\n    refine h_disj a (Finset.mem_insert_self a s) i (Finset.mem_insert_of_mem hi) fun hai â†¦ ?_\n    rw [â† hai] at hi\n    exact has hi\n\n"}
{"name":"MeasureTheory.DominatedFinMeasAdditive.zero","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nÎ² : Type u_7\ninstâœ : SeminormedAddCommGroup Î²\nC : Real\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nhC : LE.le 0 C\nâŠ¢ MeasureTheory.DominatedFinMeasAdditive Î¼ 0 C","decl":"theorem zero {m : MeasurableSpace Î±} (Î¼ : Measure Î±) (hC : 0 â‰¤ C) :\n    DominatedFinMeasAdditive Î¼ (0 : Set Î± â†’ Î²) C := by\n  refine âŸ¨FinMeasAdditive.zero, fun s _ _ => ?_âŸ©\n  rw [Pi.zero_apply, norm_zero]\n  exact mul_nonneg hC toReal_nonneg\n\n"}
{"name":"MeasureTheory.DominatedFinMeasAdditive.eq_zero_of_measure_zero","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_8\ninstâœ : NormedAddCommGroup Î²\nT : Set Î± â†’ Î²\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\ns : Set Î±\nhs : MeasurableSet s\nhs_zero : Eq (Î¼ s) 0\nâŠ¢ Eq (T s) 0","decl":"theorem eq_zero_of_measure_zero {Î² : Type*} [NormedAddCommGroup Î²] {T : Set Î± â†’ Î²} {C : â„}\n    (hT : DominatedFinMeasAdditive Î¼ T C) {s : Set Î±} (hs : MeasurableSet s) (hs_zero : Î¼ s = 0) :\n    T s = 0 := by\n  refine norm_eq_zero.mp ?_\n  refine ((hT.2 s hs (by simp [hs_zero])).trans (le_of_eq ?_)).antisymm (norm_nonneg _)\n  rw [hs_zero, ENNReal.zero_toReal, mul_zero]\n\n"}
{"name":"MeasureTheory.DominatedFinMeasAdditive.eq_zero","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nÎ² : Type u_8\ninstâœ : NormedAddCommGroup Î²\nT : Set Î± â†’ Î²\nC : Real\nxâœ : MeasurableSpace Î±\nhT : MeasureTheory.DominatedFinMeasAdditive 0 T C\ns : Set Î±\nhs : MeasurableSet s\nâŠ¢ Eq (T s) 0","decl":"theorem eq_zero {Î² : Type*} [NormedAddCommGroup Î²] {T : Set Î± â†’ Î²} {C : â„} {_ : MeasurableSpace Î±}\n    (hT : DominatedFinMeasAdditive (0 : Measure Î±) T C) {s : Set Î±} (hs : MeasurableSet s) :\n    T s = 0 :=\n  eq_zero_of_measure_zero hT hs (by simp only [Measure.coe_zero, Pi.zero_apply])\n\n"}
{"name":"MeasureTheory.DominatedFinMeasAdditive.add","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_7\ninstâœ : SeminormedAddCommGroup Î²\nT T' : Set Î± â†’ Î²\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼ T' C'\nâŠ¢ MeasureTheory.DominatedFinMeasAdditive Î¼ (HAdd.hAdd T T') (HAdd.hAdd C C')","decl":"theorem add (hT : DominatedFinMeasAdditive Î¼ T C) (hT' : DominatedFinMeasAdditive Î¼ T' C') :\n    DominatedFinMeasAdditive Î¼ (T + T') (C + C') := by\n  refine âŸ¨hT.1.add hT'.1, fun s hs hÎ¼s => ?_âŸ©\n  rw [Pi.add_apply, add_mul]\n  exact (norm_add_le _ _).trans (add_le_add (hT.2 s hs hÎ¼s) (hT'.2 s hs hÎ¼s))\n\n"}
{"name":"MeasureTheory.DominatedFinMeasAdditive.smul","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nğ•œ : Type u_6\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_7\ninstâœÂ² : SeminormedAddCommGroup Î²\nT : Set Î± â†’ Î²\nC : Real\ninstâœÂ¹ : NormedField ğ•œ\ninstâœ : NormedSpace ğ•œ Î²\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nc : ğ•œ\nâŠ¢ MeasureTheory.DominatedFinMeasAdditive Î¼ (fun s => HSMul.hSMul c (T s)) (HMul.hMul (Norm.norm c) C)","decl":"theorem smul [NormedField ğ•œ] [NormedSpace ğ•œ Î²] (hT : DominatedFinMeasAdditive Î¼ T C) (c : ğ•œ) :\n    DominatedFinMeasAdditive Î¼ (fun s => c â€¢ T s) (â€–câ€– * C) := by\n  refine âŸ¨hT.1.smul c, fun s hs hÎ¼s => ?_âŸ©\n  dsimp only\n  rw [norm_smul, mul_assoc]\n  exact mul_le_mul le_rfl (hT.2 s hs hÎ¼s) (norm_nonneg _) (norm_nonneg _)\n\n"}
{"name":"MeasureTheory.DominatedFinMeasAdditive.of_measure_le","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_7\ninstâœ : SeminormedAddCommGroup Î²\nT : Set Î± â†’ Î²\nC : Real\nÎ¼' : MeasureTheory.Measure Î±\nh : LE.le Î¼ Î¼'\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhC : LE.le 0 C\nâŠ¢ MeasureTheory.DominatedFinMeasAdditive Î¼' T C","decl":"theorem of_measure_le {Î¼' : Measure Î±} (h : Î¼ â‰¤ Î¼') (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hC : 0 â‰¤ C) : DominatedFinMeasAdditive Î¼' T C := by\n  have h' : âˆ€ s, Î¼ s = âˆ â†’ Î¼' s = âˆ := fun s hs â†¦ top_unique <| hs.symm.trans_le (h _)\n  refine âŸ¨hT.1.of_eq_top_imp_eq_top fun s _ â†¦ h' s, fun s hs hÎ¼'s â†¦ ?_âŸ©\n  have hÎ¼s : Î¼ s < âˆ := (h s).trans_lt hÎ¼'s\n  calc\n    â€–T sâ€– â‰¤ C * (Î¼ s).toReal := hT.2 s hs hÎ¼s\n    _ â‰¤ C * (Î¼' s).toReal := by gcongr; exacts [hÎ¼'s.ne, h _]\n\n"}
{"name":"MeasureTheory.DominatedFinMeasAdditive.add_measure_right","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nÎ² : Type u_7\ninstâœ : SeminormedAddCommGroup Î²\nT : Set Î± â†’ Î²\nC : Real\nxâœ : MeasurableSpace Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhC : LE.le 0 C\nâŠ¢ MeasureTheory.DominatedFinMeasAdditive (HAdd.hAdd Î¼ Î½) T C","decl":"theorem add_measure_right {_ : MeasurableSpace Î±} (Î¼ Î½ : Measure Î±)\n    (hT : DominatedFinMeasAdditive Î¼ T C) (hC : 0 â‰¤ C) : DominatedFinMeasAdditive (Î¼ + Î½) T C :=\n  of_measure_le (Measure.le_add_right le_rfl) hT hC\n\n"}
{"name":"MeasureTheory.DominatedFinMeasAdditive.add_measure_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nÎ² : Type u_7\ninstâœ : SeminormedAddCommGroup Î²\nT : Set Î± â†’ Î²\nC : Real\nxâœ : MeasurableSpace Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\nhT : MeasureTheory.DominatedFinMeasAdditive Î½ T C\nhC : LE.le 0 C\nâŠ¢ MeasureTheory.DominatedFinMeasAdditive (HAdd.hAdd Î¼ Î½) T C","decl":"theorem add_measure_left {_ : MeasurableSpace Î±} (Î¼ Î½ : Measure Î±)\n    (hT : DominatedFinMeasAdditive Î½ T C) (hC : 0 â‰¤ C) : DominatedFinMeasAdditive (Î¼ + Î½) T C :=\n  of_measure_le (Measure.le_add_left le_rfl) hT hC\n\n"}
{"name":"MeasureTheory.DominatedFinMeasAdditive.of_smul_measure","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_7\ninstâœ : SeminormedAddCommGroup Î²\nT : Set Î± â†’ Î²\nC : Real\nc : ENNReal\nhc_ne_top : Ne c Top.top\nhT : MeasureTheory.DominatedFinMeasAdditive (HSMul.hSMul c Î¼) T C\nâŠ¢ MeasureTheory.DominatedFinMeasAdditive Î¼ T (HMul.hMul c.toReal C)","decl":"theorem of_smul_measure (c : â„â‰¥0âˆ) (hc_ne_top : c â‰  âˆ) (hT : DominatedFinMeasAdditive (c â€¢ Î¼) T C) :\n    DominatedFinMeasAdditive Î¼ T (c.toReal * C) := by\n  have h : âˆ€ s, MeasurableSet s â†’ c â€¢ Î¼ s = âˆ â†’ Î¼ s = âˆ := by\n    intro s _ hcÎ¼s\n    simp only [hc_ne_top, Algebra.id.smul_eq_mul, ENNReal.mul_eq_top, or_false, Ne,\n      false_and] at hcÎ¼s\n    exact hcÎ¼s.2\n  refine âŸ¨hT.1.of_eq_top_imp_eq_top (Î¼ := c â€¢ Î¼) h, fun s hs hÎ¼s => ?_âŸ©\n  have hcÎ¼s : c â€¢ Î¼ s â‰  âˆ := mt (h s hs) hÎ¼s.ne\n  rw [smul_eq_mul] at hcÎ¼s\n  simp_rw [DominatedFinMeasAdditive, Measure.smul_apply, smul_eq_mul, toReal_mul] at hT\n  refine (hT.2 s hs hcÎ¼s.lt_top).trans (le_of_eq ?_)\n  ring\n\n"}
{"name":"MeasureTheory.DominatedFinMeasAdditive.of_measure_le_smul","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_7\ninstâœ : SeminormedAddCommGroup Î²\nT : Set Î± â†’ Î²\nC : Real\nÎ¼' : MeasureTheory.Measure Î±\nc : ENNReal\nhc : Ne c Top.top\nh : LE.le Î¼ (HSMul.hSMul c Î¼')\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhC : LE.le 0 C\nâŠ¢ MeasureTheory.DominatedFinMeasAdditive Î¼' T (HMul.hMul c.toReal C)","decl":"theorem of_measure_le_smul {Î¼' : Measure Î±} (c : â„â‰¥0âˆ) (hc : c â‰  âˆ) (h : Î¼ â‰¤ c â€¢ Î¼')\n    (hT : DominatedFinMeasAdditive Î¼ T C) (hC : 0 â‰¤ C) :\n    DominatedFinMeasAdditive Î¼' T (c.toReal * C) :=\n  (hT.of_measure_le h hC).of_smul_measure c hc\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_zero","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nF : Type u_3\nF' : Type u_4\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real F\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace Real F'\nm : MeasurableSpace Î±\nf : MeasureTheory.SimpleFunc Î± F\nâŠ¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc 0 f) 0","decl":"@[simp]\ntheorem setToSimpleFunc_zero {m : MeasurableSpace Î±} (f : Î± â†’â‚› F) :\n    setToSimpleFunc (0 : Set Î± â†’ F â†’L[â„] F') f = 0 := by simp [setToSimpleFunc]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_zero'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF' : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace Real F'\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F'\nh_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (T s) 0\nf : MeasureTheory.SimpleFunc Î± E\nhf : MeasureTheory.Integrable (â‡‘f) Î¼\nâŠ¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T f) 0","decl":"theorem setToSimpleFunc_zero' {T : Set Î± â†’ E â†’L[â„] F'}\n    (h_zero : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ T s = 0) (f : Î± â†’â‚› E) (hf : Integrable f Î¼) :\n    setToSimpleFunc T f = 0 := by\n  simp_rw [setToSimpleFunc]\n  refine sum_eq_zero fun x _ => ?_\n  by_cases hx0 : x = 0\n  Â· simp [hx0]\n  rw [h_zero (f â»Â¹' ({x} : Set E)) (measurableSet_fiber _ _)\n      (measure_preimage_lt_top_of_integrable f hf hx0),\n    ContinuousLinearMap.zero_apply]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_zero_apply","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nF : Type u_3\nF' : Type u_4\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real F\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace Real F'\nm : MeasurableSpace Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) F F'\nâŠ¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T 0) 0","decl":"@[simp]\ntheorem setToSimpleFunc_zero_apply {m : MeasurableSpace Î±} (T : Set Î± â†’ F â†’L[â„] F') :\n    setToSimpleFunc T (0 : Î± â†’â‚› F) = 0 := by\n  cases isEmpty_or_nonempty Î± <;> simp [setToSimpleFunc]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_eq_sum_filter","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nF : Type u_3\nF' : Type u_4\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\ninstâœÂ² : NormedAddCommGroup F'\ninstâœÂ¹ : NormedSpace Real F'\ninstâœ : DecidablePred fun x => Ne x 0\nm : MeasurableSpace Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) F F'\nf : MeasureTheory.SimpleFunc Î± F\nâŠ¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T f) ((Finset.filter (fun x => Ne x 0) f.range).sum fun x => (T (Set.preimage (â‡‘f) (Singleton.singleton x))) x)","decl":"theorem setToSimpleFunc_eq_sum_filter [DecidablePred fun x â†¦ x â‰  (0 : F)]\n    {m : MeasurableSpace Î±} (T : Set Î± â†’ F â†’L[â„] F') (f : Î± â†’â‚› F) :\n    setToSimpleFunc T f = âˆ‘ x âˆˆ f.range with x â‰  0, T (f â»Â¹' {x}) x := by\n  symm\n  refine sum_filter_of_ne fun x _ => mt fun hx0 => ?_\n  rw [hx0]\n  exact ContinuousLinearMap.map_zero _\n\n"}
{"name":"MeasureTheory.SimpleFunc.map_setToSimpleFunc","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nF : Type u_3\nF' : Type u_4\nG : Type u_5\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\ninstâœÂ² : NormedAddCommGroup F'\ninstâœÂ¹ : NormedSpace Real F'\ninstâœ : NormedAddCommGroup G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) F F'\nh_add : MeasureTheory.FinMeasAdditive Î¼ T\nf : MeasureTheory.SimpleFunc Î± G\nhf : MeasureTheory.Integrable (â‡‘f) Î¼\ng : G â†’ F\nhg : Eq (g 0) 0\nâŠ¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T (MeasureTheory.SimpleFunc.map g f)) (f.range.sum fun x => (T (Set.preimage (â‡‘f) (Singleton.singleton x))) (g x))","decl":"theorem map_setToSimpleFunc (T : Set Î± â†’ F â†’L[â„] F') (h_add : FinMeasAdditive Î¼ T) {f : Î± â†’â‚› G}\n    (hf : Integrable f Î¼) {g : G â†’ F} (hg : g 0 = 0) :\n    (f.map g).setToSimpleFunc T = âˆ‘ x âˆˆ f.range, T (f â»Â¹' {x}) (g x) := by\n  classical\n  have T_empty : T âˆ… = 0 := h_add.map_empty_eq_zero\n  have hfp : âˆ€ x âˆˆ f.range, x â‰  0 â†’ Î¼ (f â»Â¹' {x}) â‰  âˆ := fun x _ hx0 =>\n    (measure_preimage_lt_top_of_integrable f hf hx0).ne\n  simp only [setToSimpleFunc, range_map]\n  refine Finset.sum_image' _ fun b hb => ?_\n  rcases mem_range.1 hb with âŸ¨a, rflâŸ©\n  by_cases h0 : g (f a) = 0\n  Â· simp_rw [h0]\n    rw [ContinuousLinearMap.map_zero, Finset.sum_eq_zero fun x hx => ?_]\n    rw [mem_filter] at hx\n    rw [hx.2, ContinuousLinearMap.map_zero]\n  have h_left_eq :\n    T (map g f â»Â¹' {g (f a)}) (g (f a))\n      = T (f â»Â¹' ({b âˆˆ f.range | g b = g (f a)} : Finset _)) (g (f a)) := by\n    congr; rw [map_preimage_singleton]\n  rw [h_left_eq]\n  have h_left_eq' :\n    T (f â»Â¹' ({b âˆˆ f.range | g b = g (f a)} : Finset _)) (g (f a))\n      = T (â‹ƒ y âˆˆ {b âˆˆ f.range | g b = g (f a)}, f â»Â¹' {y}) (g (f a)) := by\n    congr; rw [â† Finset.set_biUnion_preimage_singleton]\n  rw [h_left_eq']\n  rw [h_add.map_iUnion_fin_meas_set_eq_sum T T_empty]\n  Â· simp only [sum_apply, ContinuousLinearMap.coe_sum']\n    refine Finset.sum_congr rfl fun x hx => ?_\n    rw [mem_filter] at hx\n    rw [hx.2]\n  Â· exact fun i => measurableSet_fiber _ _\n  Â· intro i hi\n    rw [mem_filter] at hi\n    refine hfp i hi.1 fun hi0 => ?_\n    rw [hi0, hg] at hi\n    exact h0 hi.2.symm\n  Â· intro i _j hi _ hij\n    rw [Set.disjoint_iff]\n    intro x hx\n    rw [Set.mem_inter_iff, Set.mem_preimage, Set.mem_preimage, Set.mem_singleton_iff,\n      Set.mem_singleton_iff] at hx\n    rw [â† hx.1, â† hx.2] at hij\n    exact absurd rfl hij\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_congr'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nh_add : MeasureTheory.FinMeasAdditive Î¼ T\nf g : MeasureTheory.SimpleFunc Î± E\nhf : MeasureTheory.Integrable (â‡‘f) Î¼\nhg : MeasureTheory.Integrable (â‡‘g) Î¼\nh : Pairwise fun x y => Eq (T (Inter.inter (Set.preimage (â‡‘f) (Singleton.singleton x)) (Set.preimage (â‡‘g) (Singleton.singleton y)))) 0\nâŠ¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T f) (MeasureTheory.SimpleFunc.setToSimpleFunc T g)","decl":"theorem setToSimpleFunc_congr' (T : Set Î± â†’ E â†’L[â„] F) (h_add : FinMeasAdditive Î¼ T) {f g : Î± â†’â‚› E}\n    (hf : Integrable f Î¼) (hg : Integrable g Î¼)\n    (h : Pairwise fun x y => T (f â»Â¹' {x} âˆ© g â»Â¹' {y}) = 0) :\n    f.setToSimpleFunc T = g.setToSimpleFunc T :=\n  show ((pair f g).map Prod.fst).setToSimpleFunc T = ((pair f g).map Prod.snd).setToSimpleFunc T by\n    have h_pair : Integrable (f.pair g) Î¼ := integrable_pair hf hg\n    rw [map_setToSimpleFunc T h_add h_pair Prod.fst_zero]\n    rw [map_setToSimpleFunc T h_add h_pair Prod.snd_zero]\n    refine Finset.sum_congr rfl fun p hp => ?_\n    rcases mem_range.1 hp with âŸ¨a, rflâŸ©\n    by_cases eq : f a = g a\n    Â· dsimp only [pair_apply]; rw [eq]\n    Â· have : T (pair f g â»Â¹' {(f a, g a)}) = 0 := by\n        have h_eq : T ((â‡‘(f.pair g)) â»Â¹' {(f a, g a)}) = T (f â»Â¹' {f a} âˆ© g â»Â¹' {g a}) := by\n          congr; rw [pair_preimage_singleton f g]\n        rw [h_eq]\n        exact h eq\n      simp only [this, ContinuousLinearMap.zero_apply, pair_apply]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_congr","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nh_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ Eq (Î¼ s) 0 â†’ Eq (T s) 0\nh_add : MeasureTheory.FinMeasAdditive Î¼ T\nf g : MeasureTheory.SimpleFunc Î± E\nhf : MeasureTheory.Integrable (â‡‘f) Î¼\nh : (MeasureTheory.ae Î¼).EventuallyEq â‡‘f â‡‘g\nâŠ¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T f) (MeasureTheory.SimpleFunc.setToSimpleFunc T g)","decl":"theorem setToSimpleFunc_congr (T : Set Î± â†’ E â†’L[â„] F)\n    (h_zero : âˆ€ s, MeasurableSet s â†’ Î¼ s = 0 â†’ T s = 0) (h_add : FinMeasAdditive Î¼ T) {f g : Î± â†’â‚› E}\n    (hf : Integrable f Î¼) (h : f =áµ[Î¼] g) : f.setToSimpleFunc T = g.setToSimpleFunc T := by\n  refine setToSimpleFunc_congr' T h_add hf ((integrable_congr h).mp hf) ?_\n  refine fun x y hxy => h_zero _ ((measurableSet_fiber f x).inter (measurableSet_fiber g y)) ?_\n  rw [EventuallyEq, ae_iff] at h\n  refine measure_mono_null (fun z => ?_) h\n  simp_rw [Set.mem_inter_iff, Set.mem_setOf_eq, Set.mem_preimage, Set.mem_singleton_iff]\n  intro h\n  rwa [h.1, h.2]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_congr_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nh : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (T s) (T' s)\nf : MeasureTheory.SimpleFunc Î± E\nhf : MeasureTheory.Integrable (â‡‘f) Î¼\nâŠ¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T f) (MeasureTheory.SimpleFunc.setToSimpleFunc T' f)","decl":"theorem setToSimpleFunc_congr_left (T T' : Set Î± â†’ E â†’L[â„] F)\n    (h : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ T s = T' s) (f : Î± â†’â‚› E) (hf : Integrable f Î¼) :\n    setToSimpleFunc T f = setToSimpleFunc T' f := by\n  simp_rw [setToSimpleFunc]\n  refine sum_congr rfl fun x _ => ?_\n  by_cases hx0 : x = 0\n  Â· simp [hx0]\n  Â· rw [h (f â»Â¹' {x}) (SimpleFunc.measurableSet_fiber _ _)\n        (SimpleFunc.measure_preimage_lt_top_of_integrable _ hf hx0)]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_add_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nF : Type u_3\nF' : Type u_4\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real F\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace Real F'\nm : MeasurableSpace Î±\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) F F'\nf : MeasureTheory.SimpleFunc Î± F\nâŠ¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc (HAdd.hAdd T T') f) (HAdd.hAdd (MeasureTheory.SimpleFunc.setToSimpleFunc T f) (MeasureTheory.SimpleFunc.setToSimpleFunc T' f))","decl":"theorem setToSimpleFunc_add_left {m : MeasurableSpace Î±} (T T' : Set Î± â†’ F â†’L[â„] F') {f : Î± â†’â‚› F} :\n    setToSimpleFunc (T + T') f = setToSimpleFunc T f + setToSimpleFunc T' f := by\n  simp_rw [setToSimpleFunc, Pi.add_apply]\n  push_cast\n  simp_rw [Pi.add_apply, sum_add_distrib]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_add_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT T' T'' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nh_add : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (T'' s) (HAdd.hAdd (T s) (T' s))\nf : MeasureTheory.SimpleFunc Î± E\nhf : MeasureTheory.Integrable (â‡‘f) Î¼\nâŠ¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T'' f) (HAdd.hAdd (MeasureTheory.SimpleFunc.setToSimpleFunc T f) (MeasureTheory.SimpleFunc.setToSimpleFunc T' f))","decl":"theorem setToSimpleFunc_add_left' (T T' T'' : Set Î± â†’ E â†’L[â„] F)\n    (h_add : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ T'' s = T s + T' s) {f : Î± â†’â‚› E}\n    (hf : Integrable f Î¼) : setToSimpleFunc T'' f = setToSimpleFunc T f + setToSimpleFunc T' f := by\n  classical\n  simp_rw [setToSimpleFunc_eq_sum_filter]\n  suffices\n    âˆ€ x âˆˆ {x âˆˆ f.range | x â‰  0}, T'' (f â»Â¹' {x}) = T (f â»Â¹' {x}) + T' (f â»Â¹' {x}) by\n    rw [â† sum_add_distrib]\n    refine Finset.sum_congr rfl fun x hx => ?_\n    rw [this x hx]\n    push_cast\n    rw [Pi.add_apply]\n  intro x hx\n  refine\n    h_add (f â»Â¹' {x}) (measurableSet_preimage _ _) (measure_preimage_lt_top_of_integrable _ hf ?_)\n  rw [mem_filter] at hx\n  exact hx.2\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_smul_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nF : Type u_3\nF' : Type u_4\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real F\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace Real F'\nm : MeasurableSpace Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) F F'\nc : Real\nf : MeasureTheory.SimpleFunc Î± F\nâŠ¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc (fun s => HSMul.hSMul c (T s)) f) (HSMul.hSMul c (MeasureTheory.SimpleFunc.setToSimpleFunc T f))","decl":"theorem setToSimpleFunc_smul_left {m : MeasurableSpace Î±} (T : Set Î± â†’ F â†’L[â„] F') (c : â„)\n    (f : Î± â†’â‚› F) : setToSimpleFunc (fun s => c â€¢ T s) f = c â€¢ setToSimpleFunc T f := by\n  simp_rw [setToSimpleFunc, ContinuousLinearMap.smul_apply, smul_sum]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_smul_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF' : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace Real F'\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F'\nc : Real\nh_smul : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (T' s) (HSMul.hSMul c (T s))\nf : MeasureTheory.SimpleFunc Î± E\nhf : MeasureTheory.Integrable (â‡‘f) Î¼\nâŠ¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T' f) (HSMul.hSMul c (MeasureTheory.SimpleFunc.setToSimpleFunc T f))","decl":"theorem setToSimpleFunc_smul_left' (T T' : Set Î± â†’ E â†’L[â„] F') (c : â„)\n    (h_smul : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ T' s = c â€¢ T s) {f : Î± â†’â‚› E} (hf : Integrable f Î¼) :\n    setToSimpleFunc T' f = c â€¢ setToSimpleFunc T f := by\n  classical\n  simp_rw [setToSimpleFunc_eq_sum_filter]\n  suffices âˆ€ x âˆˆ {x âˆˆ f.range | x â‰  0}, T' (f â»Â¹' {x}) = c â€¢ T (f â»Â¹' {x}) by\n    rw [smul_sum]\n    refine Finset.sum_congr rfl fun x hx => ?_\n    rw [this x hx]\n    rfl\n  intro x hx\n  refine\n    h_smul (f â»Â¹' {x}) (measurableSet_preimage _ _) (measure_preimage_lt_top_of_integrable _ hf ?_)\n  rw [mem_filter] at hx\n  exact hx.2\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_add","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nh_add : MeasureTheory.FinMeasAdditive Î¼ T\nf g : MeasureTheory.SimpleFunc Î± E\nhf : MeasureTheory.Integrable (â‡‘f) Î¼\nhg : MeasureTheory.Integrable (â‡‘g) Î¼\nâŠ¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T (HAdd.hAdd f g)) (HAdd.hAdd (MeasureTheory.SimpleFunc.setToSimpleFunc T f) (MeasureTheory.SimpleFunc.setToSimpleFunc T g))","decl":"theorem setToSimpleFunc_add (T : Set Î± â†’ E â†’L[â„] F) (h_add : FinMeasAdditive Î¼ T) {f g : Î± â†’â‚› E}\n    (hf : Integrable f Î¼) (hg : Integrable g Î¼) :\n    setToSimpleFunc T (f + g) = setToSimpleFunc T f + setToSimpleFunc T g :=\n  have hp_pair : Integrable (f.pair g) Î¼ := integrable_pair hf hg\n  calc\n    setToSimpleFunc T (f + g) = âˆ‘ x âˆˆ (pair f g).range, T (pair f g â»Â¹' {x}) (x.fst + x.snd) := by\n      rw [add_eq_mapâ‚‚, map_setToSimpleFunc T h_add hp_pair]; simp\n    _ = âˆ‘ x âˆˆ (pair f g).range, (T (pair f g â»Â¹' {x}) x.fst + T (pair f g â»Â¹' {x}) x.snd) :=\n      (Finset.sum_congr rfl fun _ _ => ContinuousLinearMap.map_add _ _ _)\n    _ = (âˆ‘ x âˆˆ (pair f g).range, T (pair f g â»Â¹' {x}) x.fst) +\n          âˆ‘ x âˆˆ (pair f g).range, T (pair f g â»Â¹' {x}) x.snd := by\n      rw [Finset.sum_add_distrib]\n    _ = ((pair f g).map Prod.fst).setToSimpleFunc T +\n          ((pair f g).map Prod.snd).setToSimpleFunc T := by\n      rw [map_setToSimpleFunc T h_add hp_pair Prod.snd_zero,\n        map_setToSimpleFunc T h_add hp_pair Prod.fst_zero]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_neg","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nh_add : MeasureTheory.FinMeasAdditive Î¼ T\nf : MeasureTheory.SimpleFunc Î± E\nhf : MeasureTheory.Integrable (â‡‘f) Î¼\nâŠ¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T (Neg.neg f)) (Neg.neg (MeasureTheory.SimpleFunc.setToSimpleFunc T f))","decl":"theorem setToSimpleFunc_neg (T : Set Î± â†’ E â†’L[â„] F) (h_add : FinMeasAdditive Î¼ T) {f : Î± â†’â‚› E}\n    (hf : Integrable f Î¼) : setToSimpleFunc T (-f) = -setToSimpleFunc T f :=\n  calc\n    setToSimpleFunc T (-f) = setToSimpleFunc T (f.map Neg.neg) := rfl\n    _ = -setToSimpleFunc T f := by\n      rw [map_setToSimpleFunc T h_add hf neg_zero, setToSimpleFunc, â† sum_neg_distrib]\n      exact Finset.sum_congr rfl fun x _ => ContinuousLinearMap.map_neg _ _\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_sub","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nh_add : MeasureTheory.FinMeasAdditive Î¼ T\nf g : MeasureTheory.SimpleFunc Î± E\nhf : MeasureTheory.Integrable (â‡‘f) Î¼\nhg : MeasureTheory.Integrable (â‡‘g) Î¼\nâŠ¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T (HSub.hSub f g)) (HSub.hSub (MeasureTheory.SimpleFunc.setToSimpleFunc T f) (MeasureTheory.SimpleFunc.setToSimpleFunc T g))","decl":"theorem setToSimpleFunc_sub (T : Set Î± â†’ E â†’L[â„] F) (h_add : FinMeasAdditive Î¼ T) {f g : Î± â†’â‚› E}\n    (hf : Integrable f Î¼) (hg : Integrable g Î¼) :\n    setToSimpleFunc T (f - g) = setToSimpleFunc T f - setToSimpleFunc T g := by\n  rw [sub_eq_add_neg, setToSimpleFunc_add T h_add hf, setToSimpleFunc_neg T h_add hg,\n    sub_eq_add_neg]\n  rw [integrable_iff] at hg âŠ¢\n  intro x hx_ne\n  change Î¼ (Neg.neg âˆ˜ g â»Â¹' {x}) < âˆ\n  rw [preimage_comp, neg_preimage, Set.neg_singleton]\n  refine hg (-x) ?_\n  simp [hx_ne]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_smul_real","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nh_add : MeasureTheory.FinMeasAdditive Î¼ T\nc : Real\nf : MeasureTheory.SimpleFunc Î± E\nhf : MeasureTheory.Integrable (â‡‘f) Î¼\nâŠ¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T (HSMul.hSMul c f)) (HSMul.hSMul c (MeasureTheory.SimpleFunc.setToSimpleFunc T f))","decl":"theorem setToSimpleFunc_smul_real (T : Set Î± â†’ E â†’L[â„] F) (h_add : FinMeasAdditive Î¼ T) (c : â„)\n    {f : Î± â†’â‚› E} (hf : Integrable f Î¼) : setToSimpleFunc T (c â€¢ f) = c â€¢ setToSimpleFunc T f :=\n  calc\n    setToSimpleFunc T (c â€¢ f) = âˆ‘ x âˆˆ f.range, T (f â»Â¹' {x}) (c â€¢ x) := by\n      rw [smul_eq_map c f, map_setToSimpleFunc T h_add hf]; dsimp only; rw [smul_zero]\n    _ = âˆ‘ x âˆˆ f.range, c â€¢ T (f â»Â¹' {x}) x :=\n      (Finset.sum_congr rfl fun b _ => by rw [ContinuousLinearMap.map_smul (T (f â»Â¹' {b})) c b])\n    _ = c â€¢ setToSimpleFunc T f := by simp only [setToSimpleFunc, smul_sum, smul_smul, mul_comm]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_smul","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nF : Type u_3\nğ•œ : Type u_6\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_7\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : NormedSpace ğ•œ F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nh_add : MeasureTheory.FinMeasAdditive Î¼ T\nh_smul : âˆ€ (c : ğ•œ) (s : Set Î±) (x : E), Eq ((T s) (HSMul.hSMul c x)) (HSMul.hSMul c ((T s) x))\nc : ğ•œ\nf : MeasureTheory.SimpleFunc Î± E\nhf : MeasureTheory.Integrable (â‡‘f) Î¼\nâŠ¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T (HSMul.hSMul c f)) (HSMul.hSMul c (MeasureTheory.SimpleFunc.setToSimpleFunc T f))","decl":"theorem setToSimpleFunc_smul {E} [NormedAddCommGroup E] [NormedField ğ•œ] [NormedSpace ğ•œ E]\n    [NormedSpace â„ E] [NormedSpace ğ•œ F] (T : Set Î± â†’ E â†’L[â„] F) (h_add : FinMeasAdditive Î¼ T)\n    (h_smul : âˆ€ c : ğ•œ, âˆ€ s x, T s (c â€¢ x) = c â€¢ T s x) (c : ğ•œ) {f : Î± â†’â‚› E} (hf : Integrable f Î¼) :\n    setToSimpleFunc T (c â€¢ f) = c â€¢ setToSimpleFunc T f :=\n  calc\n    setToSimpleFunc T (c â€¢ f) = âˆ‘ x âˆˆ f.range, T (f â»Â¹' {x}) (c â€¢ x) := by\n      rw [smul_eq_map c f, map_setToSimpleFunc T h_add hf]; dsimp only; rw [smul_zero]\n    _ = âˆ‘ x âˆˆ f.range, c â€¢ T (f â»Â¹' {x}) x := Finset.sum_congr rfl fun b _ => by rw [h_smul]\n    _ = c â€¢ setToSimpleFunc T f := by simp only [setToSimpleFunc, smul_sum, smul_smul, mul_comm]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_mono_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real F\nG'' : Type u_8\ninstâœÂ¹ : NormedLatticeAddCommGroup G''\ninstâœ : NormedSpace Real G''\nm : MeasurableSpace Î±\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) F G''\nhTT' : âˆ€ (s : Set Î±) (x : F), LE.le ((T s) x) ((T' s) x)\nf : MeasureTheory.SimpleFunc Î± F\nâŠ¢ LE.le (MeasureTheory.SimpleFunc.setToSimpleFunc T f) (MeasureTheory.SimpleFunc.setToSimpleFunc T' f)","decl":"theorem setToSimpleFunc_mono_left {m : MeasurableSpace Î±} (T T' : Set Î± â†’ F â†’L[â„] G'')\n    (hTT' : âˆ€ s x, T s x â‰¤ T' s x) (f : Î± â†’â‚› F) : setToSimpleFunc T f â‰¤ setToSimpleFunc T' f := by\n  simp_rw [setToSimpleFunc]; exact sum_le_sum fun i _ => hTT' _ i\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_mono_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nG'' : Type u_8\ninstâœÂ¹ : NormedLatticeAddCommGroup G''\ninstâœ : NormedSpace Real G''\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E G''\nhTT' : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ âˆ€ (x : E), LE.le ((T s) x) ((T' s) x)\nf : MeasureTheory.SimpleFunc Î± E\nhf : MeasureTheory.Integrable (â‡‘f) Î¼\nâŠ¢ LE.le (MeasureTheory.SimpleFunc.setToSimpleFunc T f) (MeasureTheory.SimpleFunc.setToSimpleFunc T' f)","decl":"theorem setToSimpleFunc_mono_left' (T T' : Set Î± â†’ E â†’L[â„] G'')\n    (hTT' : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ€ x, T s x â‰¤ T' s x) (f : Î± â†’â‚› E)\n    (hf : Integrable f Î¼) : setToSimpleFunc T f â‰¤ setToSimpleFunc T' f := by\n  refine sum_le_sum fun i _ => ?_\n  by_cases h0 : i = 0\n  Â· simp [h0]\n  Â· exact hTT' _ (measurableSet_fiber _ _) (measure_preimage_lt_top_of_integrable _ hf h0) i\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_nonneg","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nG' : Type u_7\nG'' : Type u_8\ninstâœÂ³ : NormedLatticeAddCommGroup G''\ninstâœÂ² : NormedSpace Real G''\ninstâœÂ¹ : NormedLatticeAddCommGroup G'\ninstâœ : NormedSpace Real G'\nm : MeasurableSpace Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) G' G''\nhT_nonneg : âˆ€ (s : Set Î±) (x : G'), LE.le 0 x â†’ LE.le 0 ((T s) x)\nf : MeasureTheory.SimpleFunc Î± G'\nhf : LE.le 0 f\nâŠ¢ LE.le 0 (MeasureTheory.SimpleFunc.setToSimpleFunc T f)","decl":"theorem setToSimpleFunc_nonneg {m : MeasurableSpace Î±} (T : Set Î± â†’ G' â†’L[â„] G'')\n    (hT_nonneg : âˆ€ s x, 0 â‰¤ x â†’ 0 â‰¤ T s x) (f : Î± â†’â‚› G') (hf : 0 â‰¤ f) :\n    0 â‰¤ setToSimpleFunc T f := by\n  refine sum_nonneg fun i hi => hT_nonneg _ i ?_\n  rw [mem_range] at hi\n  obtain âŸ¨y, hyâŸ© := Set.mem_range.mp hi\n  rw [â† hy]\n  refine le_trans ?_ (hf y)\n  simp\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_nonneg'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nG' : Type u_7\nG'' : Type u_8\ninstâœÂ³ : NormedLatticeAddCommGroup G''\ninstâœÂ² : NormedSpace Real G''\ninstâœÂ¹ : NormedLatticeAddCommGroup G'\ninstâœ : NormedSpace Real G'\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) G' G''\nhT_nonneg : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ âˆ€ (x : G'), LE.le 0 x â†’ LE.le 0 ((T s) x)\nf : MeasureTheory.SimpleFunc Î± G'\nhf : LE.le 0 f\nhfi : MeasureTheory.Integrable (â‡‘f) Î¼\nâŠ¢ LE.le 0 (MeasureTheory.SimpleFunc.setToSimpleFunc T f)","decl":"theorem setToSimpleFunc_nonneg' (T : Set Î± â†’ G' â†’L[â„] G'')\n    (hT_nonneg : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ€ x, 0 â‰¤ x â†’ 0 â‰¤ T s x) (f : Î± â†’â‚› G') (hf : 0 â‰¤ f)\n    (hfi : Integrable f Î¼) : 0 â‰¤ setToSimpleFunc T f := by\n  refine sum_nonneg fun i hi => ?_\n  by_cases h0 : i = 0\n  Â· simp [h0]\n  refine\n    hT_nonneg _ (measurableSet_fiber _ _) (measure_preimage_lt_top_of_integrable _ hfi h0) i ?_\n  rw [mem_range] at hi\n  obtain âŸ¨y, hyâŸ© := Set.mem_range.mp hi\n  rw [â† hy]\n  convert hf y\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_mono","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nG' : Type u_7\nG'' : Type u_8\ninstâœÂ³ : NormedLatticeAddCommGroup G''\ninstâœÂ² : NormedSpace Real G''\ninstâœÂ¹ : NormedLatticeAddCommGroup G'\ninstâœ : NormedSpace Real G'\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) G' G''\nh_add : MeasureTheory.FinMeasAdditive Î¼ T\nhT_nonneg : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ âˆ€ (x : G'), LE.le 0 x â†’ LE.le 0 ((T s) x)\nf g : MeasureTheory.SimpleFunc Î± G'\nhfi : MeasureTheory.Integrable (â‡‘f) Î¼\nhgi : MeasureTheory.Integrable (â‡‘g) Î¼\nhfg : LE.le f g\nâŠ¢ LE.le (MeasureTheory.SimpleFunc.setToSimpleFunc T f) (MeasureTheory.SimpleFunc.setToSimpleFunc T g)","decl":"theorem setToSimpleFunc_mono {T : Set Î± â†’ G' â†’L[â„] G''} (h_add : FinMeasAdditive Î¼ T)\n    (hT_nonneg : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ€ x, 0 â‰¤ x â†’ 0 â‰¤ T s x) {f g : Î± â†’â‚› G'}\n    (hfi : Integrable f Î¼) (hgi : Integrable g Î¼) (hfg : f â‰¤ g) :\n    setToSimpleFunc T f â‰¤ setToSimpleFunc T g := by\n  rw [â† sub_nonneg, â† setToSimpleFunc_sub T h_add hgi hfi]\n  refine setToSimpleFunc_nonneg' T hT_nonneg _ ?_ (hgi.sub hfi)\n  intro x\n  simp only [coe_sub, sub_nonneg, coe_zero, Pi.zero_apply, Pi.sub_apply]\n  exact hfg x\n\n"}
{"name":"MeasureTheory.SimpleFunc.norm_setToSimpleFunc_le_sum_opNorm","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nF : Type u_3\nF' : Type u_4\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real F\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace Real F'\nm : MeasurableSpace Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) F' F\nf : MeasureTheory.SimpleFunc Î± F'\nâŠ¢ LE.le (Norm.norm (MeasureTheory.SimpleFunc.setToSimpleFunc T f)) (f.range.sum fun x => HMul.hMul (Norm.norm (T (Set.preimage (â‡‘f) (Singleton.singleton x)))) (Norm.norm x))","decl":"theorem norm_setToSimpleFunc_le_sum_opNorm {m : MeasurableSpace Î±} (T : Set Î± â†’ F' â†’L[â„] F)\n    (f : Î± â†’â‚› F') : â€–f.setToSimpleFunc Tâ€– â‰¤ âˆ‘ x âˆˆ f.range, â€–T (f â»Â¹' {x})â€– * â€–xâ€– :=\n  calc\n    â€–âˆ‘ x âˆˆ f.range, T (f â»Â¹' {x}) xâ€– â‰¤ âˆ‘ x âˆˆ f.range, â€–T (f â»Â¹' {x}) xâ€– := norm_sum_le _ _\n    _ â‰¤ âˆ‘ x âˆˆ f.range, â€–T (f â»Â¹' {x})â€– * â€–xâ€– := by\n      refine Finset.sum_le_sum fun b _ => ?_; simp_rw [ContinuousLinearMap.le_opNorm]\n\n"}
{"name":"MeasureTheory.SimpleFunc.norm_setToSimpleFunc_le_sum_mul_norm","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nF : Type u_3\nF' : Type u_4\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real F\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace Real F'\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) F F'\nC : Real\nhT_norm : âˆ€ (s : Set Î±), MeasurableSet s â†’ LE.le (Norm.norm (T s)) (HMul.hMul C (Î¼ s).toReal)\nf : MeasureTheory.SimpleFunc Î± F\nâŠ¢ LE.le (Norm.norm (MeasureTheory.SimpleFunc.setToSimpleFunc T f)) (HMul.hMul C (f.range.sum fun x => HMul.hMul (Î¼ (Set.preimage (â‡‘f) (Singleton.singleton x))).toReal (Norm.norm x)))","decl":"theorem norm_setToSimpleFunc_le_sum_mul_norm (T : Set Î± â†’ F â†’L[â„] F') {C : â„}\n    (hT_norm : âˆ€ s, MeasurableSet s â†’ â€–T sâ€– â‰¤ C * (Î¼ s).toReal) (f : Î± â†’â‚› F) :\n    â€–f.setToSimpleFunc Tâ€– â‰¤ C * âˆ‘ x âˆˆ f.range, (Î¼ (f â»Â¹' {x})).toReal * â€–xâ€– :=\n  calc\n    â€–f.setToSimpleFunc Tâ€– â‰¤ âˆ‘ x âˆˆ f.range, â€–T (f â»Â¹' {x})â€– * â€–xâ€– :=\n      norm_setToSimpleFunc_le_sum_opNorm T f\n    _ â‰¤ âˆ‘ x âˆˆ f.range, C * (Î¼ (f â»Â¹' {x})).toReal * â€–xâ€– := by\n      gcongr\n      exact hT_norm _ <| SimpleFunc.measurableSet_fiber _ _\n    _ â‰¤ C * âˆ‘ x âˆˆ f.range, (Î¼ (f â»Â¹' {x})).toReal * â€–xâ€– := by simp_rw [mul_sum, â† mul_assoc]; rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.norm_setToSimpleFunc_le_sum_mul_norm_of_integrable","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF' : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace Real F'\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F'\nC : Real\nhT_norm : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ LE.le (Norm.norm (T s)) (HMul.hMul C (Î¼ s).toReal)\nf : MeasureTheory.SimpleFunc Î± E\nhf : MeasureTheory.Integrable (â‡‘f) Î¼\nâŠ¢ LE.le (Norm.norm (MeasureTheory.SimpleFunc.setToSimpleFunc T f)) (HMul.hMul C (f.range.sum fun x => HMul.hMul (Î¼ (Set.preimage (â‡‘f) (Singleton.singleton x))).toReal (Norm.norm x)))","decl":"theorem norm_setToSimpleFunc_le_sum_mul_norm_of_integrable (T : Set Î± â†’ E â†’L[â„] F') {C : â„}\n    (hT_norm : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ â€–T sâ€– â‰¤ C * (Î¼ s).toReal) (f : Î± â†’â‚› E)\n    (hf : Integrable f Î¼) :\n    â€–f.setToSimpleFunc Tâ€– â‰¤ C * âˆ‘ x âˆˆ f.range, (Î¼ (f â»Â¹' {x})).toReal * â€–xâ€– :=\n  calc\n    â€–f.setToSimpleFunc Tâ€– â‰¤ âˆ‘ x âˆˆ f.range, â€–T (f â»Â¹' {x})â€– * â€–xâ€– :=\n      norm_setToSimpleFunc_le_sum_opNorm T f\n    _ â‰¤ âˆ‘ x âˆˆ f.range, C * (Î¼ (f â»Â¹' {x})).toReal * â€–xâ€– := by\n      refine Finset.sum_le_sum fun b hb => ?_\n      obtain rfl | hb := eq_or_ne b 0\n      Â· simp\n      gcongr\n      exact hT_norm _ (SimpleFunc.measurableSet_fiber _ _) <|\n        SimpleFunc.measure_preimage_lt_top_of_integrable _ hf hb\n    _ â‰¤ C * âˆ‘ x âˆˆ f.range, (Î¼ (f â»Â¹' {x})).toReal * â€–xâ€– := by simp_rw [mul_sum, â† mul_assoc]; rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_indicator","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nF : Type u_3\nF' : Type u_4\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real F\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace Real F'\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) F F'\nhT_empty : Eq (T EmptyCollection.emptyCollection) 0\nm : MeasurableSpace Î±\ns : Set Î±\nhs : MeasurableSet s\nx : F\nâŠ¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T (MeasureTheory.SimpleFunc.piecewise s hs (MeasureTheory.SimpleFunc.const Î± x) (MeasureTheory.SimpleFunc.const Î± 0))) ((T s) x)","decl":"theorem setToSimpleFunc_indicator (T : Set Î± â†’ F â†’L[â„] F') (hT_empty : T âˆ… = 0)\n    {m : MeasurableSpace Î±} {s : Set Î±} (hs : MeasurableSet s) (x : F) :\n    SimpleFunc.setToSimpleFunc T\n        (SimpleFunc.piecewise s hs (SimpleFunc.const Î± x) (SimpleFunc.const Î± 0)) =\n      T s x := by\n  classical\n  obtain rfl | hs_empty := s.eq_empty_or_nonempty\n  Â· simp only [hT_empty, ContinuousLinearMap.zero_apply, piecewise_empty, const_zero,\n      setToSimpleFunc_zero_apply]\n  simp_rw [setToSimpleFunc]\n  obtain rfl | hs_univ := eq_or_ne s univ\n  Â· haveI hÎ± := hs_empty.to_type\n    simp [â† Function.const_def]\n  rw [range_indicator hs hs_empty hs_univ]\n  by_cases hx0 : x = 0\n  Â· simp_rw [hx0]; simp\n  rw [sum_insert]\n  swap; Â· rw [Finset.mem_singleton]; exact hx0\n  rw [sum_singleton, (T _).map_zero, add_zero]\n  congr\n  simp only [coe_piecewise, piecewise_eq_indicator, coe_const, Function.const_zero,\n    piecewise_eq_indicator]\n  rw [indicator_preimage, â† Function.const_def, preimage_const_of_mem]\n  swap; Â· exact Set.mem_singleton x\n  rw [â† Function.const_zero, â† Function.const_def, preimage_const_of_not_mem]\n  swap; Â· rw [Set.mem_singleton_iff]; exact Ne.symm hx0\n  simp\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_const'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nF : Type u_3\nF' : Type u_4\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\ninstâœÂ² : NormedAddCommGroup F'\ninstâœÂ¹ : NormedSpace Real F'\ninstâœ : Nonempty Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) F F'\nx : F\nm : MeasurableSpace Î±\nâŠ¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T (MeasureTheory.SimpleFunc.const Î± x)) ((T Set.univ) x)","decl":"theorem setToSimpleFunc_const' [Nonempty Î±] (T : Set Î± â†’ F â†’L[â„] F') (x : F)\n    {m : MeasurableSpace Î±} : SimpleFunc.setToSimpleFunc T (SimpleFunc.const Î± x) = T univ x := by\n  simp only [setToSimpleFunc, range_const, Set.mem_singleton, preimage_const_of_mem,\n    sum_singleton, â† Function.const_def, coe_const]\n\n"}
{"name":"MeasureTheory.SimpleFunc.setToSimpleFunc_const","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nF : Type u_3\nF' : Type u_4\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real F\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace Real F'\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) F F'\nhT_empty : Eq (T EmptyCollection.emptyCollection) 0\nx : F\nm : MeasurableSpace Î±\nâŠ¢ Eq (MeasureTheory.SimpleFunc.setToSimpleFunc T (MeasureTheory.SimpleFunc.const Î± x)) ((T Set.univ) x)","decl":"theorem setToSimpleFunc_const (T : Set Î± â†’ F â†’L[â„] F') (hT_empty : T âˆ… = 0) (x : F)\n    {m : MeasurableSpace Î±} : SimpleFunc.setToSimpleFunc T (SimpleFunc.const Î± x) = T univ x := by\n  cases isEmpty_or_nonempty Î±\n  Â· have h_univ_empty : (univ : Set Î±) = âˆ… := Subsingleton.elim _ _\n    rw [h_univ_empty, hT_empty]\n    simp only [setToSimpleFunc, ContinuousLinearMap.zero_apply, sum_empty,\n      range_eq_empty_of_isEmpty]\n  Â· exact setToSimpleFunc_const' T x\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.norm_eq_sum_mul","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœ : NormedAddCommGroup G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc G 1 Î¼) x\nâŠ¢ Eq (Norm.norm f) ((MeasureTheory.Lp.simpleFunc.toSimpleFunc f).range.sum fun x => HMul.hMul (Î¼ (Set.preimage (â‡‘(MeasureTheory.Lp.simpleFunc.toSimpleFunc f)) (Singleton.singleton x))).toReal (Norm.norm x))","decl":"theorem norm_eq_sum_mul (f : Î± â†’â‚â‚›[Î¼] G) :\n    â€–fâ€– = âˆ‘ x âˆˆ (toSimpleFunc f).range, (Î¼ (toSimpleFunc f â»Â¹' {x})).toReal * â€–xâ€– := by\n  rw [norm_toSimpleFunc, eLpNorm_one_eq_lintegral_enorm]\n  have h_eq := SimpleFunc.map_apply (â€–Â·â€–â‚‘) (toSimpleFunc f)\n  simp_rw [â† h_eq]\n  rw [SimpleFunc.lintegral_eq_lintegral, SimpleFunc.map_lintegral, ENNReal.toReal_sum]\n  Â· congr\n    ext1 x\n    rw [ENNReal.toReal_mul, mul_comm, â† ofReal_norm_eq_enorm,\n      ENNReal.toReal_ofReal (norm_nonneg _)]\n  Â· intro x _\n    by_cases hx0 : x = 0\n    Â· rw [hx0]; simp\n    Â· exact\n        ENNReal.mul_ne_top ENNReal.coe_ne_top\n          (SimpleFunc.measure_preimage_lt_top_of_integrable _ (SimpleFunc.integrable f) hx0).ne\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_eq_setToSimpleFunc","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T f) (MeasureTheory.SimpleFunc.setToSimpleFunc T (MeasureTheory.Lp.simpleFunc.toSimpleFunc f))","decl":"theorem setToL1S_eq_setToSimpleFunc (T : Set Î± â†’ E â†’L[â„] F) (f : Î± â†’â‚â‚›[Î¼] E) :\n    setToL1S T f = (toSimpleFunc f).setToSimpleFunc T :=\n  rfl\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_zero_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S 0 f) 0","decl":"@[simp]\ntheorem setToL1S_zero_left (f : Î± â†’â‚â‚›[Î¼] E) : setToL1S (0 : Set Î± â†’ E â†’L[â„] F) f = 0 :=\n  SimpleFunc.setToSimpleFunc_zero _\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_zero_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nh_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (T s) 0\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T f) 0","decl":"theorem setToL1S_zero_left' {T : Set Î± â†’ E â†’L[â„] F}\n    (h_zero : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ T s = 0) (f : Î± â†’â‚â‚›[Î¼] E) : setToL1S T f = 0 :=\n  SimpleFunc.setToSimpleFunc_zero' h_zero _ (SimpleFunc.integrable f)\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_congr","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nh_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ Eq (Î¼ s) 0 â†’ Eq (T s) 0\nh_add : MeasureTheory.FinMeasAdditive Î¼ T\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nh : (MeasureTheory.ae Î¼).EventuallyEq â‡‘(MeasureTheory.Lp.simpleFunc.toSimpleFunc f) â‡‘(MeasureTheory.Lp.simpleFunc.toSimpleFunc g)\nâŠ¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T f) (MeasureTheory.L1.SimpleFunc.setToL1S T g)","decl":"theorem setToL1S_congr (T : Set Î± â†’ E â†’L[â„] F) (h_zero : âˆ€ s, MeasurableSet s â†’ Î¼ s = 0 â†’ T s = 0)\n    (h_add : FinMeasAdditive Î¼ T) {f g : Î± â†’â‚â‚›[Î¼] E} (h : toSimpleFunc f =áµ[Î¼] toSimpleFunc g) :\n    setToL1S T f = setToL1S T g :=\n  SimpleFunc.setToSimpleFunc_congr T h_zero h_add (SimpleFunc.integrable f) h\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_congr_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nh : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (T s) (T' s)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T f) (MeasureTheory.L1.SimpleFunc.setToL1S T' f)","decl":"theorem setToL1S_congr_left (T T' : Set Î± â†’ E â†’L[â„] F)\n    (h : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ T s = T' s) (f : Î± â†’â‚â‚›[Î¼] E) :\n    setToL1S T f = setToL1S T' f :=\n  SimpleFunc.setToSimpleFunc_congr_left T T' h (simpleFunc.toSimpleFunc f) (SimpleFunc.integrable f)\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_congr_measure","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ Î¼' : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nh_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ Eq (Î¼ s) 0 â†’ Eq (T s) 0\nh_add : MeasureTheory.FinMeasAdditive Î¼ T\nhÎ¼ : Î¼.AbsolutelyContinuous Î¼'\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nf' : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼') x\nh : (MeasureTheory.ae Î¼).EventuallyEq â†‘â†‘â†‘f â†‘â†‘â†‘f'\nâŠ¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T f) (MeasureTheory.L1.SimpleFunc.setToL1S T f')","decl":"/-- `setToL1S` does not change if we replace the measure `Î¼` by `Î¼'` with `Î¼ â‰ª Î¼'`. The statement\nuses two functions `f` and `f'` because they have to belong to different types, but morally these\nare the same function (we have `f =áµ[Î¼] f'`). -/\ntheorem setToL1S_congr_measure {Î¼' : Measure Î±} (T : Set Î± â†’ E â†’L[â„] F)\n    (h_zero : âˆ€ s, MeasurableSet s â†’ Î¼ s = 0 â†’ T s = 0) (h_add : FinMeasAdditive Î¼ T) (hÎ¼ : Î¼ â‰ª Î¼')\n    (f : Î± â†’â‚â‚›[Î¼] E) (f' : Î± â†’â‚â‚›[Î¼'] E) (h : (f : Î± â†’ E) =áµ[Î¼] f') :\n    setToL1S T f = setToL1S T f' := by\n  refine SimpleFunc.setToSimpleFunc_congr T h_zero h_add (SimpleFunc.integrable f) ?_\n  refine (toSimpleFunc_eq_toFun f).trans ?_\n  suffices (f' : Î± â†’ E) =áµ[Î¼] simpleFunc.toSimpleFunc f' from h.trans this\n  have goal' : (f' : Î± â†’ E) =áµ[Î¼'] simpleFunc.toSimpleFunc f' := (toSimpleFunc_eq_toFun f').symm\n  exact hÎ¼.ae_eq goal'\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_add_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S (HAdd.hAdd T T') f) (HAdd.hAdd (MeasureTheory.L1.SimpleFunc.setToL1S T f) (MeasureTheory.L1.SimpleFunc.setToL1S T' f))","decl":"theorem setToL1S_add_left (T T' : Set Î± â†’ E â†’L[â„] F) (f : Î± â†’â‚â‚›[Î¼] E) :\n    setToL1S (T + T') f = setToL1S T f + setToL1S T' f :=\n  SimpleFunc.setToSimpleFunc_add_left T T'\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_add_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT T' T'' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nh_add : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (T'' s) (HAdd.hAdd (T s) (T' s))\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T'' f) (HAdd.hAdd (MeasureTheory.L1.SimpleFunc.setToL1S T f) (MeasureTheory.L1.SimpleFunc.setToL1S T' f))","decl":"theorem setToL1S_add_left' (T T' T'' : Set Î± â†’ E â†’L[â„] F)\n    (h_add : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ T'' s = T s + T' s) (f : Î± â†’â‚â‚›[Î¼] E) :\n    setToL1S T'' f = setToL1S T f + setToL1S T' f :=\n  SimpleFunc.setToSimpleFunc_add_left' T T' T'' h_add (SimpleFunc.integrable f)\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_smul_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nc : Real\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S (fun s => HSMul.hSMul c (T s)) f) (HSMul.hSMul c (MeasureTheory.L1.SimpleFunc.setToL1S T f))","decl":"theorem setToL1S_smul_left (T : Set Î± â†’ E â†’L[â„] F) (c : â„) (f : Î± â†’â‚â‚›[Î¼] E) :\n    setToL1S (fun s => c â€¢ T s) f = c â€¢ setToL1S T f :=\n  SimpleFunc.setToSimpleFunc_smul_left T c _\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_smul_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nc : Real\nh_smul : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (T' s) (HSMul.hSMul c (T s))\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T' f) (HSMul.hSMul c (MeasureTheory.L1.SimpleFunc.setToL1S T f))","decl":"theorem setToL1S_smul_left' (T T' : Set Î± â†’ E â†’L[â„] F) (c : â„)\n    (h_smul : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ T' s = c â€¢ T s) (f : Î± â†’â‚â‚›[Î¼] E) :\n    setToL1S T' f = c â€¢ setToL1S T f :=\n  SimpleFunc.setToSimpleFunc_smul_left' T T' c h_smul (SimpleFunc.integrable f)\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_add","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nh_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ Eq (Î¼ s) 0 â†’ Eq (T s) 0\nh_add : MeasureTheory.FinMeasAdditive Î¼ T\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T (HAdd.hAdd f g)) (HAdd.hAdd (MeasureTheory.L1.SimpleFunc.setToL1S T f) (MeasureTheory.L1.SimpleFunc.setToL1S T g))","decl":"theorem setToL1S_add (T : Set Î± â†’ E â†’L[â„] F) (h_zero : âˆ€ s, MeasurableSet s â†’ Î¼ s = 0 â†’ T s = 0)\n    (h_add : FinMeasAdditive Î¼ T) (f g : Î± â†’â‚â‚›[Î¼] E) :\n    setToL1S T (f + g) = setToL1S T f + setToL1S T g := by\n  simp_rw [setToL1S]\n  rw [â† SimpleFunc.setToSimpleFunc_add T h_add (SimpleFunc.integrable f)\n      (SimpleFunc.integrable g)]\n  exact\n    SimpleFunc.setToSimpleFunc_congr T h_zero h_add (SimpleFunc.integrable _)\n      (add_toSimpleFunc f g)\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_neg","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nh_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ Eq (Î¼ s) 0 â†’ Eq (T s) 0\nh_add : MeasureTheory.FinMeasAdditive Î¼ T\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T (Neg.neg f)) (Neg.neg (MeasureTheory.L1.SimpleFunc.setToL1S T f))","decl":"theorem setToL1S_neg {T : Set Î± â†’ E â†’L[â„] F} (h_zero : âˆ€ s, MeasurableSet s â†’ Î¼ s = 0 â†’ T s = 0)\n    (h_add : FinMeasAdditive Î¼ T) (f : Î± â†’â‚â‚›[Î¼] E) : setToL1S T (-f) = -setToL1S T f := by\n  simp_rw [setToL1S]\n  have : simpleFunc.toSimpleFunc (-f) =áµ[Î¼] â‡‘(-simpleFunc.toSimpleFunc f) :=\n    neg_toSimpleFunc f\n  rw [SimpleFunc.setToSimpleFunc_congr T h_zero h_add (SimpleFunc.integrable _) this]\n  exact SimpleFunc.setToSimpleFunc_neg T h_add (SimpleFunc.integrable f)\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_sub","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nh_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ Eq (Î¼ s) 0 â†’ Eq (T s) 0\nh_add : MeasureTheory.FinMeasAdditive Î¼ T\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T (HSub.hSub f g)) (HSub.hSub (MeasureTheory.L1.SimpleFunc.setToL1S T f) (MeasureTheory.L1.SimpleFunc.setToL1S T g))","decl":"theorem setToL1S_sub {T : Set Î± â†’ E â†’L[â„] F} (h_zero : âˆ€ s, MeasurableSet s â†’ Î¼ s = 0 â†’ T s = 0)\n    (h_add : FinMeasAdditive Î¼ T) (f g : Î± â†’â‚â‚›[Î¼] E) :\n    setToL1S T (f - g) = setToL1S T f - setToL1S T g := by\n  rw [sub_eq_add_neg, setToL1S_add T h_zero h_add, setToL1S_neg h_zero h_add, sub_eq_add_neg]\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_smul_real","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nh_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ Eq (Î¼ s) 0 â†’ Eq (T s) 0\nh_add : MeasureTheory.FinMeasAdditive Î¼ T\nc : Real\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T (HSMul.hSMul c f)) (HSMul.hSMul c (MeasureTheory.L1.SimpleFunc.setToL1S T f))","decl":"theorem setToL1S_smul_real (T : Set Î± â†’ E â†’L[â„] F)\n    (h_zero : âˆ€ s, MeasurableSet s â†’ Î¼ s = 0 â†’ T s = 0) (h_add : FinMeasAdditive Î¼ T) (c : â„)\n    (f : Î± â†’â‚â‚›[Î¼] E) : setToL1S T (c â€¢ f) = c â€¢ setToL1S T f := by\n  simp_rw [setToL1S]\n  rw [â† SimpleFunc.setToSimpleFunc_smul_real T h_add c (SimpleFunc.integrable f)]\n  refine SimpleFunc.setToSimpleFunc_congr T h_zero h_add (SimpleFunc.integrable _) ?_\n  exact smul_toSimpleFunc c f\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_smul","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nF : Type u_3\nğ•œ : Type u_6\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœâ´ : NormedField ğ•œ\nE : Type u_7\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œ F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nh_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ Eq (Î¼ s) 0 â†’ Eq (T s) 0\nh_add : MeasureTheory.FinMeasAdditive Î¼ T\nh_smul : âˆ€ (c : ğ•œ) (s : Set Î±) (x : E), Eq ((T s) (HSMul.hSMul c x)) (HSMul.hSMul c ((T s) x))\nc : ğ•œ\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T (HSMul.hSMul c f)) (HSMul.hSMul c (MeasureTheory.L1.SimpleFunc.setToL1S T f))","decl":"theorem setToL1S_smul {E} [NormedAddCommGroup E] [NormedSpace â„ E] [NormedSpace ğ•œ E]\n    [NormedSpace ğ•œ F] (T : Set Î± â†’ E â†’L[â„] F) (h_zero : âˆ€ s, MeasurableSet s â†’ Î¼ s = 0 â†’ T s = 0)\n    (h_add : FinMeasAdditive Î¼ T) (h_smul : âˆ€ c : ğ•œ, âˆ€ s x, T s (c â€¢ x) = c â€¢ T s x) (c : ğ•œ)\n    (f : Î± â†’â‚â‚›[Î¼] E) : setToL1S T (c â€¢ f) = c â€¢ setToL1S T f := by\n  simp_rw [setToL1S]\n  rw [â† SimpleFunc.setToSimpleFunc_smul T h_add h_smul c (SimpleFunc.integrable f)]\n  refine SimpleFunc.setToSimpleFunc_congr T h_zero h_add (SimpleFunc.integrable _) ?_\n  exact smul_toSimpleFunc c f\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.norm_setToL1S_le","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT_norm : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ LE.le (Norm.norm (T s)) (HMul.hMul C (Î¼ s).toReal)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ LE.le (Norm.norm (MeasureTheory.L1.SimpleFunc.setToL1S T f)) (HMul.hMul C (Norm.norm f))","decl":"theorem norm_setToL1S_le (T : Set Î± â†’ E â†’L[â„] F) {C : â„}\n    (hT_norm : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ â€–T sâ€– â‰¤ C * (Î¼ s).toReal) (f : Î± â†’â‚â‚›[Î¼] E) :\n    â€–setToL1S T fâ€– â‰¤ C * â€–fâ€– := by\n  rw [setToL1S, norm_eq_sum_mul f]\n  exact\n    SimpleFunc.norm_setToSimpleFunc_le_sum_mul_norm_of_integrable T hT_norm _\n      (SimpleFunc.integrable f)\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_indicatorConst","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\ns : Set Î±\nh_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ Eq (Î¼ s) 0 â†’ Eq (T s) 0\nh_add : MeasureTheory.FinMeasAdditive Î¼ T\nhs : MeasurableSet s\nhÎ¼s : LT.lt (Î¼ s) Top.top\nx : E\nâŠ¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T (MeasureTheory.Lp.simpleFunc.indicatorConst 1 hs â‹¯ x)) ((T s) x)","decl":"theorem setToL1S_indicatorConst {T : Set Î± â†’ E â†’L[â„] F} {s : Set Î±}\n    (h_zero : âˆ€ s, MeasurableSet s â†’ Î¼ s = 0 â†’ T s = 0) (h_add : FinMeasAdditive Î¼ T)\n    (hs : MeasurableSet s) (hÎ¼s : Î¼ s < âˆ) (x : E) :\n    setToL1S T (simpleFunc.indicatorConst 1 hs hÎ¼s.ne x) = T s x := by\n  have h_empty : T âˆ… = 0 := h_zero _ MeasurableSet.empty measure_empty\n  rw [setToL1S_eq_setToSimpleFunc]\n  refine Eq.trans ?_ (SimpleFunc.setToSimpleFunc_indicator T h_empty hs x)\n  refine SimpleFunc.setToSimpleFunc_congr T h_zero h_add (SimpleFunc.integrable _) ?_\n  exact toSimpleFunc_indicatorConst hs hÎ¼s.ne x\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_const","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nh_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ Eq (Î¼ s) 0 â†’ Eq (T s) 0\nh_add : MeasureTheory.FinMeasAdditive Î¼ T\nx : E\nâŠ¢ Eq (MeasureTheory.L1.SimpleFunc.setToL1S T (MeasureTheory.Lp.simpleFunc.indicatorConst 1 â‹¯ â‹¯ x)) ((T Set.univ) x)","decl":"theorem setToL1S_const [IsFiniteMeasure Î¼] {T : Set Î± â†’ E â†’L[â„] F}\n    (h_zero : âˆ€ s, MeasurableSet s â†’ Î¼ s = 0 â†’ T s = 0) (h_add : FinMeasAdditive Î¼ T) (x : E) :\n    setToL1S T (simpleFunc.indicatorConst 1 MeasurableSet.univ (measure_ne_top Î¼ _) x) = T univ x :=\n  setToL1S_indicatorConst h_zero h_add MeasurableSet.univ (measure_lt_top _ _) x\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_mono_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nG'' : Type u_7\ninstâœÂ¹ : NormedLatticeAddCommGroup G''\ninstâœ : NormedSpace Real G''\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E G''\nhTT' : âˆ€ (s : Set Î±) (x : E), LE.le ((T s) x) ((T' s) x)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ LE.le (MeasureTheory.L1.SimpleFunc.setToL1S T f) (MeasureTheory.L1.SimpleFunc.setToL1S T' f)","decl":"theorem setToL1S_mono_left {T T' : Set Î± â†’ E â†’L[â„] G''} (hTT' : âˆ€ s x, T s x â‰¤ T' s x)\n    (f : Î± â†’â‚â‚›[Î¼] E) : setToL1S T f â‰¤ setToL1S T' f :=\n  SimpleFunc.setToSimpleFunc_mono_left T T' hTT' _\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_mono_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nG'' : Type u_7\ninstâœÂ¹ : NormedLatticeAddCommGroup G''\ninstâœ : NormedSpace Real G''\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E G''\nhTT' : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ âˆ€ (x : E), LE.le ((T s) x) ((T' s) x)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ LE.le (MeasureTheory.L1.SimpleFunc.setToL1S T f) (MeasureTheory.L1.SimpleFunc.setToL1S T' f)","decl":"theorem setToL1S_mono_left' {T T' : Set Î± â†’ E â†’L[â„] G''}\n    (hTT' : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ€ x, T s x â‰¤ T' s x) (f : Î± â†’â‚â‚›[Î¼] E) :\n    setToL1S T f â‰¤ setToL1S T' f :=\n  SimpleFunc.setToSimpleFunc_mono_left' T T' hTT' _ (SimpleFunc.integrable f)\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_nonneg","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nG'' : Type u_7\nG' : Type u_8\ninstâœÂ³ : NormedLatticeAddCommGroup G'\ninstâœÂ² : NormedSpace Real G'\ninstâœÂ¹ : NormedLatticeAddCommGroup G''\ninstâœ : NormedSpace Real G''\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) G'' G'\nh_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ Eq (Î¼ s) 0 â†’ Eq (T s) 0\nh_add : MeasureTheory.FinMeasAdditive Î¼ T\nhT_nonneg : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ âˆ€ (x : G''), LE.le 0 x â†’ LE.le 0 ((T s) x)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc G'' 1 Î¼) x\nhf : LE.le 0 f\nâŠ¢ LE.le 0 (MeasureTheory.L1.SimpleFunc.setToL1S T f)","decl":"theorem setToL1S_nonneg (h_zero : âˆ€ s, MeasurableSet s â†’ Î¼ s = 0 â†’ T s = 0)\n    (h_add : FinMeasAdditive Î¼ T)\n    (hT_nonneg : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ€ x, 0 â‰¤ x â†’ 0 â‰¤ T s x) {f : Î± â†’â‚â‚›[Î¼] G''}\n    (hf : 0 â‰¤ f) : 0 â‰¤ setToL1S T f := by\n  simp_rw [setToL1S]\n  obtain âŸ¨f', hf', hff'âŸ© : âˆƒ f' : Î± â†’â‚› G'', 0 â‰¤ f' âˆ§ simpleFunc.toSimpleFunc f =áµ[Î¼] f' := by\n    obtain âŸ¨f'', hf'', hff''âŸ© := exists_simpleFunc_nonneg_ae_eq hf\n    exact âŸ¨f'', hf'', (Lp.simpleFunc.toSimpleFunc_eq_toFun f).trans hff''âŸ©\n  rw [SimpleFunc.setToSimpleFunc_congr _ h_zero h_add (SimpleFunc.integrable _) hff']\n  exact\n    SimpleFunc.setToSimpleFunc_nonneg' T hT_nonneg _ hf' ((SimpleFunc.integrable f).congr hff')\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1S_mono","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nG'' : Type u_7\nG' : Type u_8\ninstâœÂ³ : NormedLatticeAddCommGroup G'\ninstâœÂ² : NormedSpace Real G'\ninstâœÂ¹ : NormedLatticeAddCommGroup G''\ninstâœ : NormedSpace Real G''\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) G'' G'\nh_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ Eq (Î¼ s) 0 â†’ Eq (T s) 0\nh_add : MeasureTheory.FinMeasAdditive Î¼ T\nhT_nonneg : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ âˆ€ (x : G''), LE.le 0 x â†’ LE.le 0 ((T s) x)\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc G'' 1 Î¼) x\nhfg : LE.le f g\nâŠ¢ LE.le (MeasureTheory.L1.SimpleFunc.setToL1S T f) (MeasureTheory.L1.SimpleFunc.setToL1S T g)","decl":"theorem setToL1S_mono (h_zero : âˆ€ s, MeasurableSet s â†’ Î¼ s = 0 â†’ T s = 0)\n    (h_add : FinMeasAdditive Î¼ T)\n    (hT_nonneg : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ€ x, 0 â‰¤ x â†’ 0 â‰¤ T s x) {f g : Î± â†’â‚â‚›[Î¼] G''}\n    (hfg : f â‰¤ g) : setToL1S T f â‰¤ setToL1S T g := by\n  rw [â† sub_nonneg] at hfg âŠ¢\n  rw [â† setToL1S_sub h_zero h_add]\n  exact setToL1S_nonneg h_zero h_add hT_nonneg hfg\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_zero_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ 0 C\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ hT) f) 0","decl":"@[simp]\ntheorem setToL1SCLM_zero_left (hT : DominatedFinMeasAdditive Î¼ (0 : Set Î± â†’ E â†’L[â„] F) C)\n    (f : Î± â†’â‚â‚›[Î¼] E) : setToL1SCLM Î± E Î¼ hT f = 0 :=\n  setToL1S_zero_left _\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_zero_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nh_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (T s) 0\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ hT) f) 0","decl":"theorem setToL1SCLM_zero_left' (hT : DominatedFinMeasAdditive Î¼ T C)\n    (h_zero : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ T s = 0) (f : Î± â†’â‚â‚›[Î¼] E) :\n    setToL1SCLM Î± E Î¼ hT f = 0 :=\n  setToL1S_zero_left' h_zero f\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_congr_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼ T' C'\nh : Eq T T'\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ hT) f) ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ hT') f)","decl":"theorem setToL1SCLM_congr_left (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hT' : DominatedFinMeasAdditive Î¼ T' C') (h : T = T') (f : Î± â†’â‚â‚›[Î¼] E) :\n    setToL1SCLM Î± E Î¼ hT f = setToL1SCLM Î± E Î¼ hT' f :=\n  setToL1S_congr_left T T' (fun _ _ _ => by rw [h]) f\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_congr_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼ T' C'\nh : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (T s) (T' s)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ hT) f) ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ hT') f)","decl":"theorem setToL1SCLM_congr_left' (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hT' : DominatedFinMeasAdditive Î¼ T' C') (h : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ T s = T' s)\n    (f : Î± â†’â‚â‚›[Î¼] E) : setToL1SCLM Î± E Î¼ hT f = setToL1SCLM Î± E Î¼ hT' f :=\n  setToL1S_congr_left T T' h f\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_congr_measure","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nÎ¼' : MeasureTheory.Measure Î±\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼' T C'\nhÎ¼ : Î¼.AbsolutelyContinuous Î¼'\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nf' : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼') x\nh : (MeasureTheory.ae Î¼).EventuallyEq â†‘â†‘â†‘f â†‘â†‘â†‘f'\nâŠ¢ Eq ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ hT) f) ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼' hT') f')","decl":"theorem setToL1SCLM_congr_measure {Î¼' : Measure Î±} (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hT' : DominatedFinMeasAdditive Î¼' T C') (hÎ¼ : Î¼ â‰ª Î¼') (f : Î± â†’â‚â‚›[Î¼] E) (f' : Î± â†’â‚â‚›[Î¼'] E)\n    (h : (f : Î± â†’ E) =áµ[Î¼] f') : setToL1SCLM Î± E Î¼ hT f = setToL1SCLM Î± E Î¼' hT' f' :=\n  setToL1S_congr_measure T (fun _ => hT.eq_zero_of_measure_zero) hT.1 hÎ¼ _ _ h\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_add_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼ T' C'\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ â‹¯) f) (HAdd.hAdd ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ hT) f) ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ hT') f))","decl":"theorem setToL1SCLM_add_left (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hT' : DominatedFinMeasAdditive Î¼ T' C') (f : Î± â†’â‚â‚›[Î¼] E) :\n    setToL1SCLM Î± E Î¼ (hT.add hT') f = setToL1SCLM Î± E Î¼ hT f + setToL1SCLM Î± E Î¼ hT' f :=\n  setToL1S_add_left T T' f\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_add_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT T' T'' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC C' C'' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼ T' C'\nhT'' : MeasureTheory.DominatedFinMeasAdditive Î¼ T'' C''\nh_add : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (T'' s) (HAdd.hAdd (T s) (T' s))\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ hT'') f) (HAdd.hAdd ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ hT) f) ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ hT') f))","decl":"theorem setToL1SCLM_add_left' (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hT' : DominatedFinMeasAdditive Î¼ T' C') (hT'' : DominatedFinMeasAdditive Î¼ T'' C'')\n    (h_add : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ T'' s = T s + T' s) (f : Î± â†’â‚â‚›[Î¼] E) :\n    setToL1SCLM Î± E Î¼ hT'' f = setToL1SCLM Î± E Î¼ hT f + setToL1SCLM Î± E Î¼ hT' f :=\n  setToL1S_add_left' T T' T'' h_add f\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_smul_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC c : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ â‹¯) f) (HSMul.hSMul c ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ hT) f))","decl":"theorem setToL1SCLM_smul_left (c : â„) (hT : DominatedFinMeasAdditive Î¼ T C) (f : Î± â†’â‚â‚›[Î¼] E) :\n    setToL1SCLM Î± E Î¼ (hT.smul c) f = c â€¢ setToL1SCLM Î± E Î¼ hT f :=\n  setToL1S_smul_left T c f\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_smul_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC C' c : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼ T' C'\nh_smul : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (T' s) (HSMul.hSMul c (T s))\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ hT') f) (HSMul.hSMul c ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ hT) f))","decl":"theorem setToL1SCLM_smul_left' (c : â„) (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hT' : DominatedFinMeasAdditive Î¼ T' C')\n    (h_smul : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ T' s = c â€¢ T s) (f : Î± â†’â‚â‚›[Î¼] E) :\n    setToL1SCLM Î± E Î¼ hT' f = c â€¢ setToL1SCLM Î± E Î¼ hT f :=\n  setToL1S_smul_left' T T' c h_smul f\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.norm_setToL1SCLM_le","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhC : LE.le 0 C\nâŠ¢ LE.le (Norm.norm (MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ hT)) C","decl":"theorem norm_setToL1SCLM_le {T : Set Î± â†’ E â†’L[â„] F} {C : â„} (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hC : 0 â‰¤ C) : â€–setToL1SCLM Î± E Î¼ hTâ€– â‰¤ C :=\n  LinearMap.mkContinuous_norm_le _ hC _\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.norm_setToL1SCLM_le'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nâŠ¢ LE.le (Norm.norm (MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ hT)) (Max.max C 0)","decl":"theorem norm_setToL1SCLM_le' {T : Set Î± â†’ E â†’L[â„] F} {C : â„} (hT : DominatedFinMeasAdditive Î¼ T C) :\n    â€–setToL1SCLM Î± E Î¼ hTâ€– â‰¤ max C 0 :=\n  LinearMap.mkContinuous_norm_le' _ _\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_const","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nx : E\nâŠ¢ Eq ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ hT) (MeasureTheory.Lp.simpleFunc.indicatorConst 1 â‹¯ â‹¯ x)) ((T Set.univ) x)","decl":"theorem setToL1SCLM_const [IsFiniteMeasure Î¼] {T : Set Î± â†’ E â†’L[â„] F} {C : â„}\n    (hT : DominatedFinMeasAdditive Î¼ T C) (x : E) :\n    setToL1SCLM Î± E Î¼ hT (simpleFunc.indicatorConst 1 MeasurableSet.univ (measure_ne_top Î¼ _) x) =\n      T univ x :=\n  setToL1S_const (fun _ => hT.eq_zero_of_measure_zero) hT.1 x\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_mono_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nG'' : Type u_8\ninstâœÂ¹ : NormedLatticeAddCommGroup G''\ninstâœ : NormedSpace Real G''\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E G''\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼ T' C'\nhTT' : âˆ€ (s : Set Î±) (x : E), LE.le ((T s) x) ((T' s) x)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ LE.le ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ hT) f) ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ hT') f)","decl":"theorem setToL1SCLM_mono_left {T T' : Set Î± â†’ E â†’L[â„] G''} {C C' : â„}\n    (hT : DominatedFinMeasAdditive Î¼ T C) (hT' : DominatedFinMeasAdditive Î¼ T' C')\n    (hTT' : âˆ€ s x, T s x â‰¤ T' s x) (f : Î± â†’â‚â‚›[Î¼] E) :\n    setToL1SCLM Î± E Î¼ hT f â‰¤ setToL1SCLM Î± E Î¼ hT' f :=\n  SimpleFunc.setToSimpleFunc_mono_left T T' hTT' _\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_mono_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nG'' : Type u_8\ninstâœÂ¹ : NormedLatticeAddCommGroup G''\ninstâœ : NormedSpace Real G''\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E G''\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼ T' C'\nhTT' : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ âˆ€ (x : E), LE.le ((T s) x) ((T' s) x)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ LE.le ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ hT) f) ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ hT') f)","decl":"theorem setToL1SCLM_mono_left' {T T' : Set Î± â†’ E â†’L[â„] G''} {C C' : â„}\n    (hT : DominatedFinMeasAdditive Î¼ T C) (hT' : DominatedFinMeasAdditive Î¼ T' C')\n    (hTT' : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ€ x, T s x â‰¤ T' s x) (f : Î± â†’â‚â‚›[Î¼] E) :\n    setToL1SCLM Î± E Î¼ hT f â‰¤ setToL1SCLM Î± E Î¼ hT' f :=\n  SimpleFunc.setToSimpleFunc_mono_left' T T' hTT' _ (SimpleFunc.integrable f)\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_nonneg","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nG' : Type u_7\nG'' : Type u_8\ninstâœÂ³ : NormedLatticeAddCommGroup G''\ninstâœÂ² : NormedSpace Real G''\ninstâœÂ¹ : NormedLatticeAddCommGroup G'\ninstâœ : NormedSpace Real G'\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) G' G''\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT_nonneg : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ âˆ€ (x : G'), LE.le 0 x â†’ LE.le 0 ((T s) x)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc G' 1 Î¼) x\nhf : LE.le 0 f\nâŠ¢ LE.le 0 ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± G' Î¼ hT) f)","decl":"theorem setToL1SCLM_nonneg {T : Set Î± â†’ G' â†’L[â„] G''} {C : â„} (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hT_nonneg : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ€ x, 0 â‰¤ x â†’ 0 â‰¤ T s x) {f : Î± â†’â‚â‚›[Î¼] G'}\n    (hf : 0 â‰¤ f) : 0 â‰¤ setToL1SCLM Î± G' Î¼ hT f :=\n  setToL1S_nonneg (fun _ => hT.eq_zero_of_measure_zero) hT.1 hT_nonneg hf\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.setToL1SCLM_mono","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nG' : Type u_7\nG'' : Type u_8\ninstâœÂ³ : NormedLatticeAddCommGroup G''\ninstâœÂ² : NormedSpace Real G''\ninstâœÂ¹ : NormedLatticeAddCommGroup G'\ninstâœ : NormedSpace Real G'\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) G' G''\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT_nonneg : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ âˆ€ (x : G'), LE.le 0 x â†’ LE.le 0 ((T s) x)\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc G' 1 Î¼) x\nhfg : LE.le f g\nâŠ¢ LE.le ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± G' Î¼ hT) f) ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± G' Î¼ hT) g)","decl":"theorem setToL1SCLM_mono {T : Set Î± â†’ G' â†’L[â„] G''} {C : â„} (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hT_nonneg : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ€ x, 0 â‰¤ x â†’ 0 â‰¤ T s x) {f g : Î± â†’â‚â‚›[Î¼] G'}\n    (hfg : f â‰¤ g) : setToL1SCLM Î± G' Î¼ hT f â‰¤ setToL1SCLM Î± G' Î¼ hT g :=\n  setToL1S_mono (fun _ => hT.eq_zero_of_measure_zero) hT.1 hT_nonneg hfg\n\n"}
{"name":"MeasureTheory.L1.setToL1_eq_setToL1SCLM","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq ((MeasureTheory.L1.setToL1 hT) â†‘f) ((MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ hT) f)","decl":"theorem setToL1_eq_setToL1SCLM (hT : DominatedFinMeasAdditive Î¼ T C) (f : Î± â†’â‚â‚›[Î¼] E) :\n    setToL1 hT f = setToL1SCLM Î± E Î¼ hT f :=\n  uniformly_extend_of_ind simpleFunc.isUniformInducing (simpleFunc.denseRange one_ne_top)\n    (setToL1SCLM Î± E Î¼ hT).uniformContinuous _\n\n"}
{"name":"MeasureTheory.L1.setToL1_eq_setToL1'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\nğ•œ : Type u_6\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nh_smul : âˆ€ (c : ğ•œ) (s : Set Î±) (x : E), Eq ((T s) (HSMul.hSMul c x)) (HSMul.hSMul c ((T s) x))\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ Eq ((MeasureTheory.L1.setToL1 hT) f) ((MeasureTheory.L1.setToL1' ğ•œ hT h_smul) f)","decl":"theorem setToL1_eq_setToL1' (hT : DominatedFinMeasAdditive Î¼ T C)\n    (h_smul : âˆ€ c : ğ•œ, âˆ€ s x, T s (c â€¢ x) = c â€¢ T s x) (f : Î± â†’â‚[Î¼] E) :\n    setToL1 hT f = setToL1' ğ•œ hT h_smul f :=\n  rfl\n\n"}
{"name":"MeasureTheory.L1.setToL1_zero_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ 0 C\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ Eq ((MeasureTheory.L1.setToL1 hT) f) 0","decl":"@[simp]\ntheorem setToL1_zero_left (hT : DominatedFinMeasAdditive Î¼ (0 : Set Î± â†’ E â†’L[â„] F) C)\n    (f : Î± â†’â‚[Î¼] E) : setToL1 hT f = 0 := by\n  suffices setToL1 hT = 0 by rw [this]; simp\n  refine ContinuousLinearMap.extend_unique (setToL1SCLM Î± E Î¼ hT) _ _ _ _ ?_\n  ext1 f\n  rw [setToL1SCLM_zero_left hT f, ContinuousLinearMap.zero_comp, ContinuousLinearMap.zero_apply]\n\n"}
{"name":"MeasureTheory.L1.setToL1_zero_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nh_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (T s) 0\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ Eq ((MeasureTheory.L1.setToL1 hT) f) 0","decl":"theorem setToL1_zero_left' (hT : DominatedFinMeasAdditive Î¼ T C)\n    (h_zero : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ T s = 0) (f : Î± â†’â‚[Î¼] E) : setToL1 hT f = 0 := by\n  suffices setToL1 hT = 0 by rw [this]; simp\n  refine ContinuousLinearMap.extend_unique (setToL1SCLM Î± E Î¼ hT) _ _ _ _ ?_\n  ext1 f\n  rw [setToL1SCLM_zero_left' hT h_zero f, ContinuousLinearMap.zero_comp,\n    ContinuousLinearMap.zero_apply]\n\n"}
{"name":"MeasureTheory.L1.setToL1_congr_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼ T' C'\nh : Eq T T'\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ Eq ((MeasureTheory.L1.setToL1 hT) f) ((MeasureTheory.L1.setToL1 hT') f)","decl":"theorem setToL1_congr_left (T T' : Set Î± â†’ E â†’L[â„] F) {C C' : â„}\n    (hT : DominatedFinMeasAdditive Î¼ T C) (hT' : DominatedFinMeasAdditive Î¼ T' C') (h : T = T')\n    (f : Î± â†’â‚[Î¼] E) : setToL1 hT f = setToL1 hT' f := by\n  suffices setToL1 hT = setToL1 hT' by rw [this]\n  refine ContinuousLinearMap.extend_unique (setToL1SCLM Î± E Î¼ hT) _ _ _ _ ?_\n  ext1 f\n  suffices setToL1 hT' f = setToL1SCLM Î± E Î¼ hT f by rw [â† this]; rfl\n  rw [setToL1_eq_setToL1SCLM]\n  exact setToL1SCLM_congr_left hT' hT h.symm f\n\n"}
{"name":"MeasureTheory.L1.setToL1_congr_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼ T' C'\nh : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (T s) (T' s)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ Eq ((MeasureTheory.L1.setToL1 hT) f) ((MeasureTheory.L1.setToL1 hT') f)","decl":"theorem setToL1_congr_left' (T T' : Set Î± â†’ E â†’L[â„] F) {C C' : â„}\n    (hT : DominatedFinMeasAdditive Î¼ T C) (hT' : DominatedFinMeasAdditive Î¼ T' C')\n    (h : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ T s = T' s) (f : Î± â†’â‚[Î¼] E) :\n    setToL1 hT f = setToL1 hT' f := by\n  suffices setToL1 hT = setToL1 hT' by rw [this]\n  refine ContinuousLinearMap.extend_unique (setToL1SCLM Î± E Î¼ hT) _ _ _ _ ?_\n  ext1 f\n  suffices setToL1 hT' f = setToL1SCLM Î± E Î¼ hT f by rw [â† this]; rfl\n  rw [setToL1_eq_setToL1SCLM]\n  exact (setToL1SCLM_congr_left' hT hT' h f).symm\n\n"}
{"name":"MeasureTheory.L1.setToL1_add_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼ T' C'\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ Eq ((MeasureTheory.L1.setToL1 â‹¯) f) (HAdd.hAdd ((MeasureTheory.L1.setToL1 hT) f) ((MeasureTheory.L1.setToL1 hT') f))","decl":"theorem setToL1_add_left (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hT' : DominatedFinMeasAdditive Î¼ T' C') (f : Î± â†’â‚[Î¼] E) :\n    setToL1 (hT.add hT') f = setToL1 hT f + setToL1 hT' f := by\n  suffices setToL1 (hT.add hT') = setToL1 hT + setToL1 hT' by\n    rw [this, ContinuousLinearMap.add_apply]\n  refine ContinuousLinearMap.extend_unique (setToL1SCLM Î± E Î¼ (hT.add hT')) _ _ _ _ ?_\n  ext1 f\n  suffices setToL1 hT f + setToL1 hT' f = setToL1SCLM Î± E Î¼ (hT.add hT') f by\n    rw [â† this]; rfl\n  rw [setToL1_eq_setToL1SCLM, setToL1_eq_setToL1SCLM, setToL1SCLM_add_left hT hT']\n\n"}
{"name":"MeasureTheory.L1.setToL1_add_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT T' T'' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC C' C'' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼ T' C'\nhT'' : MeasureTheory.DominatedFinMeasAdditive Î¼ T'' C''\nh_add : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (T'' s) (HAdd.hAdd (T s) (T' s))\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ Eq ((MeasureTheory.L1.setToL1 hT'') f) (HAdd.hAdd ((MeasureTheory.L1.setToL1 hT) f) ((MeasureTheory.L1.setToL1 hT') f))","decl":"theorem setToL1_add_left' (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hT' : DominatedFinMeasAdditive Î¼ T' C') (hT'' : DominatedFinMeasAdditive Î¼ T'' C'')\n    (h_add : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ T'' s = T s + T' s) (f : Î± â†’â‚[Î¼] E) :\n    setToL1 hT'' f = setToL1 hT f + setToL1 hT' f := by\n  suffices setToL1 hT'' = setToL1 hT + setToL1 hT' by rw [this, ContinuousLinearMap.add_apply]\n  refine ContinuousLinearMap.extend_unique (setToL1SCLM Î± E Î¼ hT'') _ _ _ _ ?_\n  ext1 f\n  suffices setToL1 hT f + setToL1 hT' f = setToL1SCLM Î± E Î¼ hT'' f by rw [â† this]; congr\n  rw [setToL1_eq_setToL1SCLM, setToL1_eq_setToL1SCLM,\n    setToL1SCLM_add_left' hT hT' hT'' h_add]\n\n"}
{"name":"MeasureTheory.L1.setToL1_smul_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nc : Real\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ Eq ((MeasureTheory.L1.setToL1 â‹¯) f) (HSMul.hSMul c ((MeasureTheory.L1.setToL1 hT) f))","decl":"theorem setToL1_smul_left (hT : DominatedFinMeasAdditive Î¼ T C) (c : â„) (f : Î± â†’â‚[Î¼] E) :\n    setToL1 (hT.smul c) f = c â€¢ setToL1 hT f := by\n  suffices setToL1 (hT.smul c) = c â€¢ setToL1 hT by rw [this, ContinuousLinearMap.smul_apply]\n  refine ContinuousLinearMap.extend_unique (setToL1SCLM Î± E Î¼ (hT.smul c)) _ _ _ _ ?_\n  ext1 f\n  suffices c â€¢ setToL1 hT f = setToL1SCLM Î± E Î¼ (hT.smul c) f by rw [â† this]; congr\n  rw [setToL1_eq_setToL1SCLM, setToL1SCLM_smul_left c hT]\n\n"}
{"name":"MeasureTheory.L1.setToL1_smul_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼ T' C'\nc : Real\nh_smul : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (T' s) (HSMul.hSMul c (T s))\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ Eq ((MeasureTheory.L1.setToL1 hT') f) (HSMul.hSMul c ((MeasureTheory.L1.setToL1 hT) f))","decl":"theorem setToL1_smul_left' (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hT' : DominatedFinMeasAdditive Î¼ T' C') (c : â„)\n    (h_smul : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ T' s = c â€¢ T s) (f : Î± â†’â‚[Î¼] E) :\n    setToL1 hT' f = c â€¢ setToL1 hT f := by\n  suffices setToL1 hT' = c â€¢ setToL1 hT by rw [this, ContinuousLinearMap.smul_apply]\n  refine ContinuousLinearMap.extend_unique (setToL1SCLM Î± E Î¼ hT') _ _ _ _ ?_\n  ext1 f\n  suffices c â€¢ setToL1 hT f = setToL1SCLM Î± E Î¼ hT' f by rw [â† this]; congr\n  rw [setToL1_eq_setToL1SCLM, setToL1SCLM_smul_left' c hT hT' h_smul]\n\n"}
{"name":"MeasureTheory.L1.setToL1_smul","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\nğ•œ : Type u_6\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nh_smul : âˆ€ (c : ğ•œ) (s : Set Î±) (x : E), Eq ((T s) (HSMul.hSMul c x)) (HSMul.hSMul c ((T s) x))\nc : ğ•œ\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ Eq ((MeasureTheory.L1.setToL1 hT) (HSMul.hSMul c f)) (HSMul.hSMul c ((MeasureTheory.L1.setToL1 hT) f))","decl":"theorem setToL1_smul (hT : DominatedFinMeasAdditive Î¼ T C)\n    (h_smul : âˆ€ c : ğ•œ, âˆ€ s x, T s (c â€¢ x) = c â€¢ T s x) (c : ğ•œ) (f : Î± â†’â‚[Î¼] E) :\n    setToL1 hT (c â€¢ f) = c â€¢ setToL1 hT f := by\n  rw [setToL1_eq_setToL1' hT h_smul, setToL1_eq_setToL1' hT h_smul]\n  exact ContinuousLinearMap.map_smul _ _ _\n\n"}
{"name":"MeasureTheory.L1.setToL1_simpleFunc_indicatorConst","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\ns : Set Î±\nhs : MeasurableSet s\nhÎ¼s : LT.lt (Î¼ s) Top.top\nx : E\nâŠ¢ Eq ((MeasureTheory.L1.setToL1 hT) â†‘(MeasureTheory.Lp.simpleFunc.indicatorConst 1 hs â‹¯ x)) ((T s) x)","decl":"theorem setToL1_simpleFunc_indicatorConst (hT : DominatedFinMeasAdditive Î¼ T C) {s : Set Î±}\n    (hs : MeasurableSet s) (hÎ¼s : Î¼ s < âˆ) (x : E) :\n    setToL1 hT (simpleFunc.indicatorConst 1 hs hÎ¼s.ne x) = T s x := by\n  rw [setToL1_eq_setToL1SCLM]\n  exact setToL1S_indicatorConst (fun s => hT.eq_zero_of_measure_zero) hT.1 hs hÎ¼s x\n\n"}
{"name":"MeasureTheory.L1.setToL1_indicatorConstLp","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\ns : Set Î±\nhs : MeasurableSet s\nhÎ¼s : Ne (Î¼ s) Top.top\nx : E\nâŠ¢ Eq ((MeasureTheory.L1.setToL1 hT) (MeasureTheory.indicatorConstLp 1 hs hÎ¼s x)) ((T s) x)","decl":"theorem setToL1_indicatorConstLp (hT : DominatedFinMeasAdditive Î¼ T C) {s : Set Î±}\n    (hs : MeasurableSet s) (hÎ¼s : Î¼ s â‰  âˆ) (x : E) :\n    setToL1 hT (indicatorConstLp 1 hs hÎ¼s x) = T s x := by\n  rw [â† Lp.simpleFunc.coe_indicatorConst hs hÎ¼s x]\n  exact setToL1_simpleFunc_indicatorConst hT hs hÎ¼s.lt_top x\n\n"}
{"name":"MeasureTheory.L1.setToL1_const","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nx : E\nâŠ¢ Eq ((MeasureTheory.L1.setToL1 hT) (MeasureTheory.indicatorConstLp 1 â‹¯ â‹¯ x)) ((T Set.univ) x)","decl":"theorem setToL1_const [IsFiniteMeasure Î¼] (hT : DominatedFinMeasAdditive Î¼ T C) (x : E) :\n    setToL1 hT (indicatorConstLp 1 MeasurableSet.univ (measure_ne_top _ _) x) = T univ x :=\n  setToL1_indicatorConstLp hT MeasurableSet.univ (measure_ne_top _ _) x\n\n"}
{"name":"MeasureTheory.L1.setToL1_mono_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nG'' : Type u_8\ninstâœÂ² : NormedLatticeAddCommGroup G''\ninstâœÂ¹ : NormedSpace Real G''\ninstâœ : CompleteSpace G''\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E G''\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼ T' C'\nhTT' : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ âˆ€ (x : E), LE.le ((T s) x) ((T' s) x)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ LE.le ((MeasureTheory.L1.setToL1 hT) f) ((MeasureTheory.L1.setToL1 hT') f)","decl":"theorem setToL1_mono_left' {T T' : Set Î± â†’ E â†’L[â„] G''} {C C' : â„}\n    (hT : DominatedFinMeasAdditive Î¼ T C) (hT' : DominatedFinMeasAdditive Î¼ T' C')\n    (hTT' : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ€ x, T s x â‰¤ T' s x) (f : Î± â†’â‚[Î¼] E) :\n    setToL1 hT f â‰¤ setToL1 hT' f := by\n  induction f using Lp.induction (hp_ne_top := one_ne_top) with\n  | @h_ind c s hs hÎ¼s =>\n    rw [setToL1_simpleFunc_indicatorConst hT hs hÎ¼s, setToL1_simpleFunc_indicatorConst hT' hs hÎ¼s]\n    exact hTT' s hs hÎ¼s c\n  | @h_add f g hf hg _ hf_le hg_le =>\n    rw [(setToL1 hT).map_add, (setToL1 hT').map_add]\n    exact add_le_add hf_le hg_le\n  | h_closed => exact isClosed_le (setToL1 hT).continuous (setToL1 hT').continuous\n\n"}
{"name":"MeasureTheory.L1.setToL1_mono_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nG'' : Type u_8\ninstâœÂ² : NormedLatticeAddCommGroup G''\ninstâœÂ¹ : NormedSpace Real G''\ninstâœ : CompleteSpace G''\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E G''\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼ T' C'\nhTT' : âˆ€ (s : Set Î±) (x : E), LE.le ((T s) x) ((T' s) x)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ LE.le ((MeasureTheory.L1.setToL1 hT) f) ((MeasureTheory.L1.setToL1 hT') f)","decl":"theorem setToL1_mono_left {T T' : Set Î± â†’ E â†’L[â„] G''} {C C' : â„}\n    (hT : DominatedFinMeasAdditive Î¼ T C) (hT' : DominatedFinMeasAdditive Î¼ T' C')\n    (hTT' : âˆ€ s x, T s x â‰¤ T' s x) (f : Î± â†’â‚[Î¼] E) : setToL1 hT f â‰¤ setToL1 hT' f :=\n  setToL1_mono_left' hT hT' (fun s _ _ x => hTT' s x) f\n\n"}
{"name":"MeasureTheory.L1.setToL1_nonneg","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nG' : Type u_7\nG'' : Type u_8\ninstâœâ´ : NormedLatticeAddCommGroup G''\ninstâœÂ³ : NormedSpace Real G''\ninstâœÂ² : CompleteSpace G''\ninstâœÂ¹ : NormedLatticeAddCommGroup G'\ninstâœ : NormedSpace Real G'\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) G' G''\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT_nonneg : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ âˆ€ (x : G'), LE.le 0 x â†’ LE.le 0 ((T s) x)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp G' 1 Î¼) x\nhf : LE.le 0 f\nâŠ¢ LE.le 0 ((MeasureTheory.L1.setToL1 hT) f)","decl":"theorem setToL1_nonneg {T : Set Î± â†’ G' â†’L[â„] G''} {C : â„} (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hT_nonneg : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ€ x, 0 â‰¤ x â†’ 0 â‰¤ T s x) {f : Î± â†’â‚[Î¼] G'}\n    (hf : 0 â‰¤ f) : 0 â‰¤ setToL1 hT f := by\n  suffices âˆ€ f : { g : Î± â†’â‚[Î¼] G' // 0 â‰¤ g }, 0 â‰¤ setToL1 hT f from\n    this (âŸ¨f, hfâŸ© : { g : Î± â†’â‚[Î¼] G' // 0 â‰¤ g })\n  refine fun g =>\n    @isClosed_property { g : Î± â†’â‚â‚›[Î¼] G' // 0 â‰¤ g } { g : Î± â†’â‚[Î¼] G' // 0 â‰¤ g } _ _\n      (fun g => 0 â‰¤ setToL1 hT g)\n      (denseRange_coeSimpleFuncNonnegToLpNonneg 1 Î¼ G' one_ne_top) ?_ ?_ g\n  Â· exact isClosed_le continuous_zero ((setToL1 hT).continuous.comp continuous_induced_dom)\n  Â· intro g\n    have : (coeSimpleFuncNonnegToLpNonneg 1 Î¼ G' g : Î± â†’â‚[Î¼] G') = (g : Î± â†’â‚â‚›[Î¼] G') := rfl\n    rw [this, setToL1_eq_setToL1SCLM]\n    exact setToL1S_nonneg (fun s => hT.eq_zero_of_measure_zero) hT.1 hT_nonneg g.2\n\n"}
{"name":"MeasureTheory.L1.setToL1_mono","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nG' : Type u_7\nG'' : Type u_8\ninstâœâ´ : NormedLatticeAddCommGroup G''\ninstâœÂ³ : NormedSpace Real G''\ninstâœÂ² : CompleteSpace G''\ninstâœÂ¹ : NormedLatticeAddCommGroup G'\ninstâœ : NormedSpace Real G'\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) G' G''\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT_nonneg : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ âˆ€ (x : G'), LE.le 0 x â†’ LE.le 0 ((T s) x)\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp G' 1 Î¼) x\nhfg : LE.le f g\nâŠ¢ LE.le ((MeasureTheory.L1.setToL1 hT) f) ((MeasureTheory.L1.setToL1 hT) g)","decl":"theorem setToL1_mono {T : Set Î± â†’ G' â†’L[â„] G''} {C : â„} (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hT_nonneg : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ€ x, 0 â‰¤ x â†’ 0 â‰¤ T s x) {f g : Î± â†’â‚[Î¼] G'}\n    (hfg : f â‰¤ g) : setToL1 hT f â‰¤ setToL1 hT g := by\n  rw [â† sub_nonneg] at hfg âŠ¢\n  rw [â† (setToL1 hT).map_sub]\n  exact setToL1_nonneg hT hT_nonneg hfg\n\n"}
{"name":"MeasureTheory.L1.norm_setToL1_le_norm_setToL1SCLM","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nâŠ¢ LE.le (Norm.norm (MeasureTheory.L1.setToL1 hT)) (Norm.norm (MeasureTheory.L1.SimpleFunc.setToL1SCLM Î± E Î¼ hT))","decl":"theorem norm_setToL1_le_norm_setToL1SCLM (hT : DominatedFinMeasAdditive Î¼ T C) :\n    â€–setToL1 hTâ€– â‰¤ â€–setToL1SCLM Î± E Î¼ hTâ€– :=\n  calc\n    â€–setToL1 hTâ€– â‰¤ (1 : â„â‰¥0) * â€–setToL1SCLM Î± E Î¼ hTâ€– := by\n      refine\n        ContinuousLinearMap.opNorm_extend_le (setToL1SCLM Î± E Î¼ hT) (coeToLp Î± E â„)\n          (simpleFunc.denseRange one_ne_top) fun x => le_of_eq ?_\n      rw [NNReal.coe_one, one_mul]\n      rfl\n    _ = â€–setToL1SCLM Î± E Î¼ hTâ€– := by rw [NNReal.coe_one, one_mul]\n\n"}
{"name":"MeasureTheory.L1.norm_setToL1_le_mul_norm","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhC : LE.le 0 C\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ LE.le (Norm.norm ((MeasureTheory.L1.setToL1 hT) f)) (HMul.hMul C (Norm.norm f))","decl":"theorem norm_setToL1_le_mul_norm (hT : DominatedFinMeasAdditive Î¼ T C) (hC : 0 â‰¤ C)\n    (f : Î± â†’â‚[Î¼] E) : â€–setToL1 hT fâ€– â‰¤ C * â€–fâ€– :=\n  calc\n    â€–setToL1 hT fâ€– â‰¤ â€–setToL1SCLM Î± E Î¼ hTâ€– * â€–fâ€– :=\n      ContinuousLinearMap.le_of_opNorm_le _ (norm_setToL1_le_norm_setToL1SCLM hT) _\n    _ â‰¤ C * â€–fâ€– := mul_le_mul (norm_setToL1SCLM_le hT hC) le_rfl (norm_nonneg _) hC\n\n"}
{"name":"MeasureTheory.L1.norm_setToL1_le_mul_norm'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ LE.le (Norm.norm ((MeasureTheory.L1.setToL1 hT) f)) (HMul.hMul (Max.max C 0) (Norm.norm f))","decl":"theorem norm_setToL1_le_mul_norm' (hT : DominatedFinMeasAdditive Î¼ T C) (f : Î± â†’â‚[Î¼] E) :\n    â€–setToL1 hT fâ€– â‰¤ max C 0 * â€–fâ€– :=\n  calc\n    â€–setToL1 hT fâ€– â‰¤ â€–setToL1SCLM Î± E Î¼ hTâ€– * â€–fâ€– :=\n      ContinuousLinearMap.le_of_opNorm_le _ (norm_setToL1_le_norm_setToL1SCLM hT) _\n    _ â‰¤ max C 0 * â€–fâ€– :=\n      mul_le_mul (norm_setToL1SCLM_le' hT) le_rfl (norm_nonneg _) (le_max_right _ _)\n\n"}
{"name":"MeasureTheory.L1.norm_setToL1_le","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhC : LE.le 0 C\nâŠ¢ LE.le (Norm.norm (MeasureTheory.L1.setToL1 hT)) C","decl":"theorem norm_setToL1_le (hT : DominatedFinMeasAdditive Î¼ T C) (hC : 0 â‰¤ C) : â€–setToL1 hTâ€– â‰¤ C :=\n  ContinuousLinearMap.opNorm_le_bound _ hC (norm_setToL1_le_mul_norm hT hC)\n\n"}
{"name":"MeasureTheory.L1.norm_setToL1_le'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nâŠ¢ LE.le (Norm.norm (MeasureTheory.L1.setToL1 hT)) (Max.max C 0)","decl":"theorem norm_setToL1_le' (hT : DominatedFinMeasAdditive Î¼ T C) : â€–setToL1 hTâ€– â‰¤ max C 0 :=\n  ContinuousLinearMap.opNorm_le_bound _ (le_max_right _ _) (norm_setToL1_le_mul_norm' hT)\n\n"}
{"name":"MeasureTheory.L1.setToL1_lipschitz","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nâŠ¢ LipschitzWith C.toNNReal â‡‘(MeasureTheory.L1.setToL1 hT)","decl":"theorem setToL1_lipschitz (hT : DominatedFinMeasAdditive Î¼ T C) :\n    LipschitzWith (Real.toNNReal C) (setToL1 hT) :=\n  (setToL1 hT).lipschitz.weaken (norm_setToL1_le' hT)\n\n"}
{"name":"MeasureTheory.L1.tendsto_setToL1","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nÎ¹ : Type u_7\nfs : Î¹ â†’ Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nl : Filter Î¹\nhfs : Filter.Tendsto fs l (nhds f)\nâŠ¢ Filter.Tendsto (fun i => (MeasureTheory.L1.setToL1 hT) (fs i)) l (nhds ((MeasureTheory.L1.setToL1 hT) f))","decl":"/-- If `fs i â†’ f` in `L1`, then `setToL1 hT (fs i) â†’ setToL1 hT f`. -/\ntheorem tendsto_setToL1 (hT : DominatedFinMeasAdditive Î¼ T C) (f : Î± â†’â‚[Î¼] E) {Î¹}\n    (fs : Î¹ â†’ Î± â†’â‚[Î¼] E) {l : Filter Î¹} (hfs : Tendsto fs l (ğ“ f)) :\n    Tendsto (fun i => setToL1 hT (fs i)) l (ğ“ <| setToL1 hT f) :=\n  ((setToL1 hT).continuous.tendsto _).comp hfs\n\n"}
{"name":"MeasureTheory.setToFun_eq","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nf : Î± â†’ E\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T hT f) ((MeasureTheory.L1.setToL1 hT) (MeasureTheory.Integrable.toL1 f hf))","decl":"theorem setToFun_eq (hT : DominatedFinMeasAdditive Î¼ T C) (hf : Integrable f Î¼) :\n    setToFun Î¼ T hT f = L1.setToL1 hT (hf.toL1 f) :=\n  dif_pos hf\n\n"}
{"name":"MeasureTheory.L1.setToFun_eq_setToL1","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T hT â†‘â†‘f) ((MeasureTheory.L1.setToL1 hT) f)","decl":"theorem L1.setToFun_eq_setToL1 (hT : DominatedFinMeasAdditive Î¼ T C) (f : Î± â†’â‚[Î¼] E) :\n    setToFun Î¼ T hT f = L1.setToL1 hT f := by\n  rw [setToFun_eq hT (L1.integrable_coeFn f), Integrable.toL1_coeFn]\n\n"}
{"name":"MeasureTheory.setToFun_undef","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nf : Î± â†’ E\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhf : Not (MeasureTheory.Integrable f Î¼)\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T hT f) 0","decl":"theorem setToFun_undef (hT : DominatedFinMeasAdditive Î¼ T C) (hf : Â¬Integrable f Î¼) :\n    setToFun Î¼ T hT f = 0 :=\n  dif_neg hf\n\n"}
{"name":"MeasureTheory.setToFun_non_aEStronglyMeasurable","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nf : Î± â†’ E\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhf : Not (MeasureTheory.AEStronglyMeasurable f Î¼)\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T hT f) 0","decl":"theorem setToFun_non_aEStronglyMeasurable (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hf : Â¬AEStronglyMeasurable f Î¼) : setToFun Î¼ T hT f = 0 :=\n  setToFun_undef hT (not_and_of_not_left _ hf)\n\n"}
{"name":"MeasureTheory.setToFun_congr_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼ T' C'\nh : Eq T T'\nf : Î± â†’ E\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T hT f) (MeasureTheory.setToFun Î¼ T' hT' f)","decl":"theorem setToFun_congr_left (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hT' : DominatedFinMeasAdditive Î¼ T' C') (h : T = T') (f : Î± â†’ E) :\n    setToFun Î¼ T hT f = setToFun Î¼ T' hT' f := by\n  by_cases hf : Integrable f Î¼\n  Â· simp_rw [setToFun_eq _ hf, L1.setToL1_congr_left T T' hT hT' h]\n  Â· simp_rw [setToFun_undef _ hf]\n\n"}
{"name":"MeasureTheory.setToFun_congr_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼ T' C'\nh : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (T s) (T' s)\nf : Î± â†’ E\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T hT f) (MeasureTheory.setToFun Î¼ T' hT' f)","decl":"theorem setToFun_congr_left' (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hT' : DominatedFinMeasAdditive Î¼ T' C') (h : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ T s = T' s)\n    (f : Î± â†’ E) : setToFun Î¼ T hT f = setToFun Î¼ T' hT' f := by\n  by_cases hf : Integrable f Î¼\n  Â· simp_rw [setToFun_eq _ hf, L1.setToL1_congr_left' T T' hT hT' h]\n  Â· simp_rw [setToFun_undef _ hf]\n\n"}
{"name":"MeasureTheory.setToFun_add_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼ T' C'\nf : Î± â†’ E\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ (HAdd.hAdd T T') â‹¯ f) (HAdd.hAdd (MeasureTheory.setToFun Î¼ T hT f) (MeasureTheory.setToFun Î¼ T' hT' f))","decl":"theorem setToFun_add_left (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hT' : DominatedFinMeasAdditive Î¼ T' C') (f : Î± â†’ E) :\n    setToFun Î¼ (T + T') (hT.add hT') f = setToFun Î¼ T hT f + setToFun Î¼ T' hT' f := by\n  by_cases hf : Integrable f Î¼\n  Â· simp_rw [setToFun_eq _ hf, L1.setToL1_add_left hT hT']\n  Â· simp_rw [setToFun_undef _ hf, add_zero]\n\n"}
{"name":"MeasureTheory.setToFun_add_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT T' T'' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC C' C'' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼ T' C'\nhT'' : MeasureTheory.DominatedFinMeasAdditive Î¼ T'' C''\nh_add : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (T'' s) (HAdd.hAdd (T s) (T' s))\nf : Î± â†’ E\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T'' hT'' f) (HAdd.hAdd (MeasureTheory.setToFun Î¼ T hT f) (MeasureTheory.setToFun Î¼ T' hT' f))","decl":"theorem setToFun_add_left' (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hT' : DominatedFinMeasAdditive Î¼ T' C') (hT'' : DominatedFinMeasAdditive Î¼ T'' C'')\n    (h_add : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ T'' s = T s + T' s) (f : Î± â†’ E) :\n    setToFun Î¼ T'' hT'' f = setToFun Î¼ T hT f + setToFun Î¼ T' hT' f := by\n  by_cases hf : Integrable f Î¼\n  Â· simp_rw [setToFun_eq _ hf, L1.setToL1_add_left' hT hT' hT'' h_add]\n  Â· simp_rw [setToFun_undef _ hf, add_zero]\n\n"}
{"name":"MeasureTheory.setToFun_smul_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nc : Real\nf : Î± â†’ E\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ (fun s => HSMul.hSMul c (T s)) â‹¯ f) (HSMul.hSMul c (MeasureTheory.setToFun Î¼ T hT f))","decl":"theorem setToFun_smul_left (hT : DominatedFinMeasAdditive Î¼ T C) (c : â„) (f : Î± â†’ E) :\n    setToFun Î¼ (fun s => c â€¢ T s) (hT.smul c) f = c â€¢ setToFun Î¼ T hT f := by\n  by_cases hf : Integrable f Î¼\n  Â· simp_rw [setToFun_eq _ hf, L1.setToL1_smul_left hT c]\n  Â· simp_rw [setToFun_undef _ hf, smul_zero]\n\n"}
{"name":"MeasureTheory.setToFun_smul_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼ T' C'\nc : Real\nh_smul : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (T' s) (HSMul.hSMul c (T s))\nf : Î± â†’ E\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T' hT' f) (HSMul.hSMul c (MeasureTheory.setToFun Î¼ T hT f))","decl":"theorem setToFun_smul_left' (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hT' : DominatedFinMeasAdditive Î¼ T' C') (c : â„)\n    (h_smul : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ T' s = c â€¢ T s) (f : Î± â†’ E) :\n    setToFun Î¼ T' hT' f = c â€¢ setToFun Î¼ T hT f := by\n  by_cases hf : Integrable f Î¼\n  Â· simp_rw [setToFun_eq _ hf, L1.setToL1_smul_left' hT hT' c h_smul]\n  Â· simp_rw [setToFun_undef _ hf, smul_zero]\n\n"}
{"name":"MeasureTheory.setToFun_zero","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T hT 0) 0","decl":"@[simp]\ntheorem setToFun_zero (hT : DominatedFinMeasAdditive Î¼ T C) : setToFun Î¼ T hT (0 : Î± â†’ E) = 0 := by\n  erw [setToFun_eq hT (integrable_zero _ _ _), Integrable.toL1_zero, ContinuousLinearMap.map_zero]\n\n"}
{"name":"MeasureTheory.setToFun_zero_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nC : Real\nf : Î± â†’ E\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ 0 C\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ 0 hT f) 0","decl":"@[simp]\ntheorem setToFun_zero_left {hT : DominatedFinMeasAdditive Î¼ (0 : Set Î± â†’ E â†’L[â„] F) C} :\n    setToFun Î¼ 0 hT f = 0 := by\n  by_cases hf : Integrable f Î¼\n  Â· rw [setToFun_eq hT hf]; exact L1.setToL1_zero_left hT _\n  Â· exact setToFun_undef hT hf\n\n"}
{"name":"MeasureTheory.setToFun_zero_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nf : Î± â†’ E\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nh_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (T s) 0\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T hT f) 0","decl":"theorem setToFun_zero_left' (hT : DominatedFinMeasAdditive Î¼ T C)\n    (h_zero : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ T s = 0) : setToFun Î¼ T hT f = 0 := by\n  by_cases hf : Integrable f Î¼\n  Â· rw [setToFun_eq hT hf]; exact L1.setToL1_zero_left' hT h_zero _\n  Â· exact setToFun_undef hT hf\n\n"}
{"name":"MeasureTheory.setToFun_add","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nf g : Î± â†’ E\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T hT (HAdd.hAdd f g)) (HAdd.hAdd (MeasureTheory.setToFun Î¼ T hT f) (MeasureTheory.setToFun Î¼ T hT g))","decl":"theorem setToFun_add (hT : DominatedFinMeasAdditive Î¼ T C) (hf : Integrable f Î¼)\n    (hg : Integrable g Î¼) : setToFun Î¼ T hT (f + g) = setToFun Î¼ T hT f + setToFun Î¼ T hT g := by\n  rw [setToFun_eq hT (hf.add hg), setToFun_eq hT hf, setToFun_eq hT hg, Integrable.toL1_add,\n    (L1.setToL1 hT).map_add]\n\n"}
{"name":"MeasureTheory.setToFun_finset_sum'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nÎ¹ : Type u_7\ns : Finset Î¹\nf : Î¹ â†’ Î± â†’ E\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ MeasureTheory.Integrable (f i) Î¼\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T hT (s.sum fun i => f i)) (s.sum fun i => MeasureTheory.setToFun Î¼ T hT (f i))","decl":"theorem setToFun_finset_sum' (hT : DominatedFinMeasAdditive Î¼ T C) {Î¹} (s : Finset Î¹)\n    {f : Î¹ â†’ Î± â†’ E} (hf : âˆ€ i âˆˆ s, Integrable (f i) Î¼) :\n    setToFun Î¼ T hT (âˆ‘ i âˆˆ s, f i) = âˆ‘ i âˆˆ s, setToFun Î¼ T hT (f i) := by\n  classical\n  revert hf\n  refine Finset.induction_on s ?_ ?_\n  Â· intro _\n    simp only [setToFun_zero, Finset.sum_empty]\n  Â· intro i s his ih hf\n    simp only [his, Finset.sum_insert, not_false_iff]\n    rw [setToFun_add hT (hf i (Finset.mem_insert_self i s)) _]\n    Â· rw [ih fun i hi => hf i (Finset.mem_insert_of_mem hi)]\n    Â· convert integrable_finset_sum s fun i hi => hf i (Finset.mem_insert_of_mem hi) with x\n      simp\n\n"}
{"name":"MeasureTheory.setToFun_finset_sum","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nÎ¹ : Type u_7\ns : Finset Î¹\nf : Î¹ â†’ Î± â†’ E\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ MeasureTheory.Integrable (f i) Î¼\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T hT fun a => s.sum fun i => f i a) (s.sum fun i => MeasureTheory.setToFun Î¼ T hT (f i))","decl":"theorem setToFun_finset_sum (hT : DominatedFinMeasAdditive Î¼ T C) {Î¹} (s : Finset Î¹) {f : Î¹ â†’ Î± â†’ E}\n    (hf : âˆ€ i âˆˆ s, Integrable (f i) Î¼) :\n    (setToFun Î¼ T hT fun a => âˆ‘ i âˆˆ s, f i a) = âˆ‘ i âˆˆ s, setToFun Î¼ T hT (f i) := by\n  convert setToFun_finset_sum' hT s hf with a; simp\n\n"}
{"name":"MeasureTheory.setToFun_neg","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nf : Î± â†’ E\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T hT (Neg.neg f)) (Neg.neg (MeasureTheory.setToFun Î¼ T hT f))","decl":"theorem setToFun_neg (hT : DominatedFinMeasAdditive Î¼ T C) (f : Î± â†’ E) :\n    setToFun Î¼ T hT (-f) = -setToFun Î¼ T hT f := by\n  by_cases hf : Integrable f Î¼\n  Â· rw [setToFun_eq hT hf, setToFun_eq hT hf.neg, Integrable.toL1_neg,\n      (L1.setToL1 hT).map_neg]\n  Â· rw [setToFun_undef hT hf, setToFun_undef hT, neg_zero]\n    rwa [â† integrable_neg_iff] at hf\n\n"}
{"name":"MeasureTheory.setToFun_sub","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nf g : Î± â†’ E\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T hT (HSub.hSub f g)) (HSub.hSub (MeasureTheory.setToFun Î¼ T hT f) (MeasureTheory.setToFun Î¼ T hT g))","decl":"theorem setToFun_sub (hT : DominatedFinMeasAdditive Î¼ T C) (hf : Integrable f Î¼)\n    (hg : Integrable g Î¼) : setToFun Î¼ T hT (f - g) = setToFun Î¼ T hT f - setToFun Î¼ T hT g := by\n  rw [sub_eq_add_neg, sub_eq_add_neg, setToFun_add hT hf hg.neg, setToFun_neg hT g]\n\n"}
{"name":"MeasureTheory.setToFun_smul","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\nğ•œ : Type u_6\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œ F\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nh_smul : âˆ€ (c : ğ•œ) (s : Set Î±) (x : E), Eq ((T s) (HSMul.hSMul c x)) (HSMul.hSMul c ((T s) x))\nc : ğ•œ\nf : Î± â†’ E\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T hT (HSMul.hSMul c f)) (HSMul.hSMul c (MeasureTheory.setToFun Î¼ T hT f))","decl":"theorem setToFun_smul [NontriviallyNormedField ğ•œ] [NormedSpace ğ•œ E] [NormedSpace ğ•œ F]\n    (hT : DominatedFinMeasAdditive Î¼ T C) (h_smul : âˆ€ c : ğ•œ, âˆ€ s x, T s (c â€¢ x) = c â€¢ T s x) (c : ğ•œ)\n    (f : Î± â†’ E) : setToFun Î¼ T hT (c â€¢ f) = c â€¢ setToFun Î¼ T hT f := by\n  by_cases hf : Integrable f Î¼\n  Â· rw [setToFun_eq hT hf, setToFun_eq hT, Integrable.toL1_smul',\n      L1.setToL1_smul hT h_smul c _]\n  Â· by_cases hr : c = 0\n    Â· rw [hr]; simp\n    Â· have hf' : Â¬Integrable (c â€¢ f) Î¼ := by rwa [integrable_smul_iff hr f]\n      rw [setToFun_undef hT hf, setToFun_undef hT hf', smul_zero]\n\n"}
{"name":"MeasureTheory.setToFun_congr_ae","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nf g : Î± â†’ E\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nh : (MeasureTheory.ae Î¼).EventuallyEq f g\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T hT f) (MeasureTheory.setToFun Î¼ T hT g)","decl":"theorem setToFun_congr_ae (hT : DominatedFinMeasAdditive Î¼ T C) (h : f =áµ[Î¼] g) :\n    setToFun Î¼ T hT f = setToFun Î¼ T hT g := by\n  by_cases hfi : Integrable f Î¼\n  Â· have hgi : Integrable g Î¼ := hfi.congr h\n    rw [setToFun_eq hT hfi, setToFun_eq hT hgi, (Integrable.toL1_eq_toL1_iff f g hfi hgi).2 h]\n  Â· have hgi : Â¬Integrable g Î¼ := by rw [integrable_congr h] at hfi; exact hfi\n    rw [setToFun_undef hT hfi, setToFun_undef hT hgi]\n\n"}
{"name":"MeasureTheory.setToFun_measure_zero","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nf : Î± â†’ E\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nh : Eq Î¼ 0\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T hT f) 0","decl":"theorem setToFun_measure_zero (hT : DominatedFinMeasAdditive Î¼ T C) (h : Î¼ = 0) :\n    setToFun Î¼ T hT f = 0 := by\n  have : f =áµ[Î¼] 0 := by simp [h, EventuallyEq]\n  rw [setToFun_congr_ae hT this, setToFun_zero]\n\n"}
{"name":"MeasureTheory.setToFun_measure_zero'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nf : Î± â†’ E\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nh : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (Î¼ s) 0\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T hT f) 0","decl":"theorem setToFun_measure_zero' (hT : DominatedFinMeasAdditive Î¼ T C)\n    (h : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ Î¼ s = 0) : setToFun Î¼ T hT f = 0 :=\n  setToFun_zero_left' hT fun s hs hÎ¼s => hT.eq_zero_of_measure_zero hs (h s hs hÎ¼s)\n\n"}
{"name":"MeasureTheory.setToFun_toL1","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nf : Î± â†’ E\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T hT â†‘â†‘(MeasureTheory.Integrable.toL1 f hf)) (MeasureTheory.setToFun Î¼ T hT f)","decl":"theorem setToFun_toL1 (hT : DominatedFinMeasAdditive Î¼ T C) (hf : Integrable f Î¼) :\n    setToFun Î¼ T hT (hf.toL1 f) = setToFun Î¼ T hT f :=\n  setToFun_congr_ae hT hf.coeFn_toL1\n\n"}
{"name":"MeasureTheory.setToFun_indicator_const","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\ns : Set Î±\nhs : MeasurableSet s\nhÎ¼s : Ne (Î¼ s) Top.top\nx : E\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T hT (s.indicator fun x_1 => x)) ((T s) x)","decl":"theorem setToFun_indicator_const (hT : DominatedFinMeasAdditive Î¼ T C) {s : Set Î±}\n    (hs : MeasurableSet s) (hÎ¼s : Î¼ s â‰  âˆ) (x : E) :\n    setToFun Î¼ T hT (s.indicator fun _ => x) = T s x := by\n  rw [setToFun_congr_ae hT (@indicatorConstLp_coeFn _ _ _ 1 _ _ _ hs hÎ¼s x).symm]\n  rw [L1.setToFun_eq_setToL1 hT]\n  exact L1.setToL1_indicatorConstLp hT hs hÎ¼s x\n\n"}
{"name":"MeasureTheory.setToFun_const","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nx : E\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T hT fun x_1 => x) ((T Set.univ) x)","decl":"theorem setToFun_const [IsFiniteMeasure Î¼] (hT : DominatedFinMeasAdditive Î¼ T C) (x : E) :\n    (setToFun Î¼ T hT fun _ => x) = T univ x := by\n  have : (fun _ : Î± => x) = Set.indicator univ fun _ => x := (indicator_univ _).symm\n  rw [this]\n  exact setToFun_indicator_const hT MeasurableSet.univ (measure_ne_top _ _) x\n\n"}
{"name":"MeasureTheory.setToFun_mono_left'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nG'' : Type u_8\ninstâœÂ² : NormedLatticeAddCommGroup G''\ninstâœÂ¹ : NormedSpace Real G''\ninstâœ : CompleteSpace G''\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E G''\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼ T' C'\nhTT' : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ âˆ€ (x : E), LE.le ((T s) x) ((T' s) x)\nf : Î± â†’ E\nâŠ¢ LE.le (MeasureTheory.setToFun Î¼ T hT f) (MeasureTheory.setToFun Î¼ T' hT' f)","decl":"theorem setToFun_mono_left' {T T' : Set Î± â†’ E â†’L[â„] G''} {C C' : â„}\n    (hT : DominatedFinMeasAdditive Î¼ T C) (hT' : DominatedFinMeasAdditive Î¼ T' C')\n    (hTT' : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ€ x, T s x â‰¤ T' s x) (f : Î± â†’ E) :\n    setToFun Î¼ T hT f â‰¤ setToFun Î¼ T' hT' f := by\n  by_cases hf : Integrable f Î¼\n  Â· simp_rw [setToFun_eq _ hf]; exact L1.setToL1_mono_left' hT hT' hTT' _\n  Â· simp_rw [setToFun_undef _ hf]; rfl\n\n"}
{"name":"MeasureTheory.setToFun_mono_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nG'' : Type u_8\ninstâœÂ² : NormedLatticeAddCommGroup G''\ninstâœÂ¹ : NormedSpace Real G''\ninstâœ : CompleteSpace G''\nT T' : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E G''\nC C' : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼ T' C'\nhTT' : âˆ€ (s : Set Î±) (x : E), LE.le ((T s) x) ((T' s) x)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ LE.le (MeasureTheory.setToFun Î¼ T hT â†‘â†‘f) (MeasureTheory.setToFun Î¼ T' hT' â†‘â†‘f)","decl":"theorem setToFun_mono_left {T T' : Set Î± â†’ E â†’L[â„] G''} {C C' : â„}\n    (hT : DominatedFinMeasAdditive Î¼ T C) (hT' : DominatedFinMeasAdditive Î¼ T' C')\n    (hTT' : âˆ€ s x, T s x â‰¤ T' s x) (f : Î± â†’â‚[Î¼] E) : setToFun Î¼ T hT f â‰¤ setToFun Î¼ T' hT' f :=\n  setToFun_mono_left' hT hT' (fun s _ _ x => hTT' s x) f\n\n"}
{"name":"MeasureTheory.setToFun_nonneg","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nG' : Type u_7\nG'' : Type u_8\ninstâœâ´ : NormedLatticeAddCommGroup G''\ninstâœÂ³ : NormedSpace Real G''\ninstâœÂ² : CompleteSpace G''\ninstâœÂ¹ : NormedLatticeAddCommGroup G'\ninstâœ : NormedSpace Real G'\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) G' G''\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT_nonneg : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ âˆ€ (x : G'), LE.le 0 x â†’ LE.le 0 ((T s) x)\nf : Î± â†’ G'\nhf : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nâŠ¢ LE.le 0 (MeasureTheory.setToFun Î¼ T hT f)","decl":"theorem setToFun_nonneg {T : Set Î± â†’ G' â†’L[â„] G''} {C : â„} (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hT_nonneg : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ€ x, 0 â‰¤ x â†’ 0 â‰¤ T s x) {f : Î± â†’ G'}\n    (hf : 0 â‰¤áµ[Î¼] f) : 0 â‰¤ setToFun Î¼ T hT f := by\n  by_cases hfi : Integrable f Î¼\n  Â· simp_rw [setToFun_eq _ hfi]\n    refine L1.setToL1_nonneg hT hT_nonneg ?_\n    rw [â† Lp.coeFn_le]\n    have h0 := Lp.coeFn_zero G' 1 Î¼\n    have h := Integrable.coeFn_toL1 hfi\n    filter_upwards [h0, h, hf] with _ h0a ha hfa\n    rw [h0a, ha]\n    exact hfa\n  Â· simp_rw [setToFun_undef _ hfi]; rfl\n\n"}
{"name":"MeasureTheory.setToFun_mono","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nG' : Type u_7\nG'' : Type u_8\ninstâœâ´ : NormedLatticeAddCommGroup G''\ninstâœÂ³ : NormedSpace Real G''\ninstâœÂ² : CompleteSpace G''\ninstâœÂ¹ : NormedLatticeAddCommGroup G'\ninstâœ : NormedSpace Real G'\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) G' G''\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT_nonneg : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ âˆ€ (x : G'), LE.le 0 x â†’ LE.le 0 ((T s) x)\nf g : Î± â†’ G'\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nhfg : (MeasureTheory.ae Î¼).EventuallyLE f g\nâŠ¢ LE.le (MeasureTheory.setToFun Î¼ T hT f) (MeasureTheory.setToFun Î¼ T hT g)","decl":"theorem setToFun_mono {T : Set Î± â†’ G' â†’L[â„] G''} {C : â„} (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hT_nonneg : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ€ x, 0 â‰¤ x â†’ 0 â‰¤ T s x) {f g : Î± â†’ G'}\n    (hf : Integrable f Î¼) (hg : Integrable g Î¼) (hfg : f â‰¤áµ[Î¼] g) :\n    setToFun Î¼ T hT f â‰¤ setToFun Î¼ T hT g := by\n  rw [â† sub_nonneg, â† setToFun_sub hT hg hf]\n  refine setToFun_nonneg hT hT_nonneg (hfg.mono fun a ha => ?_)\n  rw [Pi.sub_apply, Pi.zero_apply, sub_nonneg]\n  exact ha\n\n"}
{"name":"MeasureTheory.continuous_setToFun","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nâŠ¢ Continuous fun f => MeasureTheory.setToFun Î¼ T hT â†‘â†‘f","decl":"@[continuity]\ntheorem continuous_setToFun (hT : DominatedFinMeasAdditive Î¼ T C) :\n    Continuous fun f : Î± â†’â‚[Î¼] E => setToFun Î¼ T hT f := by\n  simp_rw [L1.setToFun_eq_setToL1 hT]; exact ContinuousLinearMap.continuous _\n\n"}
{"name":"MeasureTheory.tendsto_setToFun_of_L1","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nÎ¹ : Type u_7\nf : Î± â†’ E\nhfi : MeasureTheory.Integrable f Î¼\nfs : Î¹ â†’ Î± â†’ E\nl : Filter Î¹\nhfsi : Filter.Eventually (fun i => MeasureTheory.Integrable (fs i) Î¼) l\nhfs : Filter.Tendsto (fun i => MeasureTheory.lintegral Î¼ fun x => ENorm.enorm (HSub.hSub (fs i x) (f x))) l (nhds 0)\nâŠ¢ Filter.Tendsto (fun i => MeasureTheory.setToFun Î¼ T hT (fs i)) l (nhds (MeasureTheory.setToFun Î¼ T hT f))","decl":"/-- If `F i â†’ f` in `L1`, then `setToFun Î¼ T hT (F i) â†’ setToFun Î¼ T hT f`. -/\ntheorem tendsto_setToFun_of_L1 (hT : DominatedFinMeasAdditive Î¼ T C) {Î¹} (f : Î± â†’ E)\n    (hfi : Integrable f Î¼) {fs : Î¹ â†’ Î± â†’ E} {l : Filter Î¹} (hfsi : âˆ€á¶  i in l, Integrable (fs i) Î¼)\n    (hfs : Tendsto (fun i => âˆ«â» x, â€–fs i x - f xâ€–â‚‘ âˆ‚Î¼) l (ğ“ 0)) :\n    Tendsto (fun i => setToFun Î¼ T hT (fs i)) l (ğ“ <| setToFun Î¼ T hT f) := by\n  classical\n    let f_lp := hfi.toL1 f\n    let F_lp i := if hFi : Integrable (fs i) Î¼ then hFi.toL1 (fs i) else 0\n    have tendsto_L1 : Tendsto F_lp l (ğ“ f_lp) := by\n      rw [Lp.tendsto_Lp_iff_tendsto_â„’p']\n      simp_rw [eLpNorm_one_eq_lintegral_enorm, Pi.sub_apply]\n      refine (tendsto_congr' ?_).mp hfs\n      filter_upwards [hfsi] with i hi\n      refine lintegral_congr_ae ?_\n      filter_upwards [hi.coeFn_toL1, hfi.coeFn_toL1] with x hxi hxf\n      simp_rw [F_lp, dif_pos hi, hxi, f_lp, hxf]\n    suffices Tendsto (fun i => setToFun Î¼ T hT (F_lp i)) l (ğ“ (setToFun Î¼ T hT f)) by\n      refine (tendsto_congr' ?_).mp this\n      filter_upwards [hfsi] with i hi\n      suffices h_ae_eq : F_lp i =áµ[Î¼] fs i from setToFun_congr_ae hT h_ae_eq\n      simp_rw [F_lp, dif_pos hi]\n      exact hi.coeFn_toL1\n    rw [setToFun_congr_ae hT hfi.coeFn_toL1.symm]\n    exact ((continuous_setToFun hT).tendsto f_lp).comp tendsto_L1\n\n"}
{"name":"MeasureTheory.tendsto_setToFun_approxOn_of_measurable","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nf : Î± â†’ E\ns : Set E\ninstâœ : TopologicalSpace.SeparableSpace â†‘s\nhfi : MeasureTheory.Integrable f Î¼\nhfm : Measurable f\nhs : Filter.Eventually (fun x => Membership.mem (closure s) (f x)) (MeasureTheory.ae Î¼)\nyâ‚€ : E\nhâ‚€ : Membership.mem s yâ‚€\nhâ‚€i : MeasureTheory.Integrable (fun x => yâ‚€) Î¼\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.setToFun Î¼ T hT â‡‘(MeasureTheory.SimpleFunc.approxOn f hfm s yâ‚€ hâ‚€ n)) Filter.atTop (nhds (MeasureTheory.setToFun Î¼ T hT f))","decl":"theorem tendsto_setToFun_approxOn_of_measurable (hT : DominatedFinMeasAdditive Î¼ T C)\n    [MeasurableSpace E] [BorelSpace E] {f : Î± â†’ E} {s : Set E} [SeparableSpace s]\n    (hfi : Integrable f Î¼) (hfm : Measurable f) (hs : âˆ€áµ x âˆ‚Î¼, f x âˆˆ closure s) {yâ‚€ : E}\n    (hâ‚€ : yâ‚€ âˆˆ s) (hâ‚€i : Integrable (fun _ => yâ‚€) Î¼) :\n    Tendsto (fun n => setToFun Î¼ T hT (SimpleFunc.approxOn f hfm s yâ‚€ hâ‚€ n)) atTop\n      (ğ“ <| setToFun Î¼ T hT f) :=\n  tendsto_setToFun_of_L1 hT _ hfi\n    (Eventually.of_forall (SimpleFunc.integrable_approxOn hfm hfi hâ‚€ hâ‚€i))\n    (SimpleFunc.tendsto_approxOn_L1_enorm hfm _ hs (hfi.sub hâ‚€i).2)\n\n"}
{"name":"MeasureTheory.tendsto_setToFun_approxOn_of_measurable_of_range_subset","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nf : Î± â†’ E\nfmeas : Measurable f\nhf : MeasureTheory.Integrable f Î¼\ns : Set E\ninstâœ : TopologicalSpace.SeparableSpace â†‘s\nhs : HasSubset.Subset (Union.union (Set.range f) (Singleton.singleton 0)) s\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.setToFun Î¼ T hT â‡‘(MeasureTheory.SimpleFunc.approxOn f fmeas s 0 â‹¯ n)) Filter.atTop (nhds (MeasureTheory.setToFun Î¼ T hT f))","decl":"theorem tendsto_setToFun_approxOn_of_measurable_of_range_subset\n    (hT : DominatedFinMeasAdditive Î¼ T C) [MeasurableSpace E] [BorelSpace E] {f : Î± â†’ E}\n    (fmeas : Measurable f) (hf : Integrable f Î¼) (s : Set E) [SeparableSpace s]\n    (hs : range f âˆª {0} âŠ† s) :\n    Tendsto (fun n => setToFun Î¼ T hT (SimpleFunc.approxOn f fmeas s 0 (hs <| by simp) n)) atTop\n      (ğ“ <| setToFun Î¼ T hT f) := by\n  refine tendsto_setToFun_approxOn_of_measurable hT hf fmeas ?_ _ (integrable_zero _ _ _)\n  exact Eventually.of_forall fun x => subset_closure (hs (Set.mem_union_left _ (mem_range_self _)))\n\n"}
{"name":"MeasureTheory.continuous_L1_toL1","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœ : NormedAddCommGroup G\nm : MeasurableSpace Î±\nÎ¼ Î¼' : MeasureTheory.Measure Î±\nc' : ENNReal\nhc' : Ne c' Top.top\nhÎ¼'_le : LE.le Î¼' (HSMul.hSMul c' Î¼)\nâŠ¢ Continuous fun f => MeasureTheory.Integrable.toL1 â†‘â†‘f â‹¯","decl":"/-- Auxiliary lemma for `setToFun_congr_measure`: the function sending `f : Î± â†’â‚[Î¼] G` to\n`f : Î± â†’â‚[Î¼'] G` is continuous when `Î¼' â‰¤ c' â€¢ Î¼` for `c' â‰  âˆ`. -/\ntheorem continuous_L1_toL1 {Î¼' : Measure Î±} (c' : â„â‰¥0âˆ) (hc' : c' â‰  âˆ) (hÎ¼'_le : Î¼' â‰¤ c' â€¢ Î¼) :\n    Continuous fun f : Î± â†’â‚[Î¼] G =>\n      (Integrable.of_measure_le_smul c' hc' hÎ¼'_le (L1.integrable_coeFn f)).toL1 f := by\n  by_cases hc'0 : c' = 0\n  Â· have hÎ¼'0 : Î¼' = 0 := by rw [â† Measure.nonpos_iff_eq_zero']; refine hÎ¼'_le.trans ?_; simp [hc'0]\n    have h_im_zero :\n      (fun f : Î± â†’â‚[Î¼] G =>\n          (Integrable.of_measure_le_smul c' hc' hÎ¼'_le (L1.integrable_coeFn f)).toL1 f) =\n        0 := by\n      ext1 f; ext1; simp_rw [hÎ¼'0]; simp only [ae_zero, EventuallyEq, eventually_bot]\n    rw [h_im_zero]\n    exact continuous_zero\n  rw [Metric.continuous_iff]\n  intro f Îµ hÎµ_pos\n  use Îµ / 2 / c'.toReal\n  refine âŸ¨div_pos (half_pos hÎµ_pos) (toReal_pos hc'0 hc'), ?_âŸ©\n  intro g hfg\n  rw [Lp.dist_def] at hfg âŠ¢\n  let h_int := fun f' : Î± â†’â‚[Î¼] G => (L1.integrable_coeFn f').of_measure_le_smul c' hc' hÎ¼'_le\n  have :\n    eLpNorm (â‡‘(Integrable.toL1 g (h_int g)) - â‡‘(Integrable.toL1 f (h_int f))) 1 Î¼' =\n      eLpNorm (â‡‘g - â‡‘f) 1 Î¼' :=\n    eLpNorm_congr_ae ((Integrable.coeFn_toL1 _).sub (Integrable.coeFn_toL1 _))\n  rw [this]\n  have h_eLpNorm_ne_top : eLpNorm (â‡‘g - â‡‘f) 1 Î¼ â‰  âˆ := by\n    rw [â† eLpNorm_congr_ae (Lp.coeFn_sub _ _)]; exact Lp.eLpNorm_ne_top _\n  calc\n    (eLpNorm (â‡‘g - â‡‘f) 1 Î¼').toReal â‰¤ (c' * eLpNorm (â‡‘g - â‡‘f) 1 Î¼).toReal := by\n      refine toReal_mono (ENNReal.mul_ne_top hc' h_eLpNorm_ne_top) ?_\n      refine (eLpNorm_mono_measure (â‡‘g - â‡‘f) hÎ¼'_le).trans_eq ?_\n      rw [eLpNorm_smul_measure_of_ne_zero hc'0, smul_eq_mul]\n      simp\n    _ = c'.toReal * (eLpNorm (â‡‘g - â‡‘f) 1 Î¼).toReal := toReal_mul\n    _ â‰¤ c'.toReal * (Îµ / 2 / c'.toReal) := by gcongr\n    _ = Îµ / 2 := by\n      refine mul_div_cancelâ‚€ (Îµ / 2) ?_; rw [Ne, toReal_eq_zero_iff]; simp [hc', hc'0]\n    _ < Îµ := half_lt_self hÎµ_pos\n\n"}
{"name":"MeasureTheory.setToFun_congr_measure_of_integrable","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nÎ¼' : MeasureTheory.Measure Î±\nc' : ENNReal\nhc' : Ne c' Top.top\nhÎ¼'_le : LE.le Î¼' (HSMul.hSMul c' Î¼)\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼' T C'\nf : Î± â†’ E\nhfÎ¼ : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T hT f) (MeasureTheory.setToFun Î¼' T hT' f)","decl":"theorem setToFun_congr_measure_of_integrable {Î¼' : Measure Î±} (c' : â„â‰¥0âˆ) (hc' : c' â‰  âˆ)\n    (hÎ¼'_le : Î¼' â‰¤ c' â€¢ Î¼) (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hT' : DominatedFinMeasAdditive Î¼' T C') (f : Î± â†’ E) (hfÎ¼ : Integrable f Î¼) :\n    setToFun Î¼ T hT f = setToFun Î¼' T hT' f := by\n  -- integrability for `Î¼` implies integrability for `Î¼'`.\n  have h_int : âˆ€ g : Î± â†’ E, Integrable g Î¼ â†’ Integrable g Î¼' := fun g hg =>\n    Integrable.of_measure_le_smul c' hc' hÎ¼'_le hg\n  -- We use `Integrable.induction`\n  apply hfÎ¼.induction (P := fun f => setToFun Î¼ T hT f = setToFun Î¼' T hT' f)\n  Â· intro c s hs hÎ¼s\n    have hÎ¼'s : Î¼' s â‰  âˆ := by\n      refine ((hÎ¼'_le s).trans_lt ?_).ne\n      rw [Measure.smul_apply, smul_eq_mul]\n      exact ENNReal.mul_lt_top hc'.lt_top hÎ¼s\n    rw [setToFun_indicator_const hT hs hÎ¼s.ne, setToFun_indicator_const hT' hs hÎ¼'s]\n  Â· intro fâ‚‚ gâ‚‚ _ hfâ‚‚ hgâ‚‚ h_eq_f h_eq_g\n    rw [setToFun_add hT hfâ‚‚ hgâ‚‚, setToFun_add hT' (h_int fâ‚‚ hfâ‚‚) (h_int gâ‚‚ hgâ‚‚), h_eq_f, h_eq_g]\n  Â· refine isClosed_eq (continuous_setToFun hT) ?_\n    have :\n      (fun f : Î± â†’â‚[Î¼] E => setToFun Î¼' T hT' f) = fun f : Î± â†’â‚[Î¼] E =>\n        setToFun Î¼' T hT' ((h_int f (L1.integrable_coeFn f)).toL1 f) := by\n      ext1 f; exact setToFun_congr_ae hT' (Integrable.coeFn_toL1 _).symm\n    rw [this]\n    exact (continuous_setToFun hT').comp (continuous_L1_toL1 c' hc' hÎ¼'_le)\n  Â· intro fâ‚‚ gâ‚‚ hfg _ hf_eq\n    have hfg' : fâ‚‚ =áµ[Î¼'] gâ‚‚ := (Measure.absolutelyContinuous_of_le_smul hÎ¼'_le).ae_eq hfg\n    rw [â† setToFun_congr_ae hT hfg, hf_eq, setToFun_congr_ae hT' hfg']\n\n"}
{"name":"MeasureTheory.setToFun_congr_measure","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nÎ¼' : MeasureTheory.Measure Î±\nc c' : ENNReal\nhc : Ne c Top.top\nhc' : Ne c' Top.top\nhÎ¼_le : LE.le Î¼ (HSMul.hSMul c Î¼')\nhÎ¼'_le : LE.le Î¼' (HSMul.hSMul c' Î¼)\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT' : MeasureTheory.DominatedFinMeasAdditive Î¼' T C'\nf : Î± â†’ E\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T hT f) (MeasureTheory.setToFun Î¼' T hT' f)","decl":"theorem setToFun_congr_measure {Î¼' : Measure Î±} (c c' : â„â‰¥0âˆ) (hc : c â‰  âˆ) (hc' : c' â‰  âˆ)\n    (hÎ¼_le : Î¼ â‰¤ c â€¢ Î¼') (hÎ¼'_le : Î¼' â‰¤ c' â€¢ Î¼) (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hT' : DominatedFinMeasAdditive Î¼' T C') (f : Î± â†’ E) :\n    setToFun Î¼ T hT f = setToFun Î¼' T hT' f := by\n  by_cases hf : Integrable f Î¼\n  Â· exact setToFun_congr_measure_of_integrable c' hc' hÎ¼'_le hT hT' f hf\n  Â· -- if `f` is not integrable, both `setToFun` are 0.\n    have h_int : âˆ€ g : Î± â†’ E, Â¬Integrable g Î¼ â†’ Â¬Integrable g Î¼' := fun g =>\n      mt fun h => h.of_measure_le_smul _ hc hÎ¼_le\n    simp_rw [setToFun_undef _ hf, setToFun_undef _ (h_int f hf)]\n\n"}
{"name":"MeasureTheory.setToFun_congr_measure_of_add_right","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nÎ¼' : MeasureTheory.Measure Î±\nhT_add : MeasureTheory.DominatedFinMeasAdditive (HAdd.hAdd Î¼ Î¼') T C'\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nf : Î± â†’ E\nhf : MeasureTheory.Integrable f (HAdd.hAdd Î¼ Î¼')\nâŠ¢ Eq (MeasureTheory.setToFun (HAdd.hAdd Î¼ Î¼') T hT_add f) (MeasureTheory.setToFun Î¼ T hT f)","decl":"theorem setToFun_congr_measure_of_add_right {Î¼' : Measure Î±}\n    (hT_add : DominatedFinMeasAdditive (Î¼ + Î¼') T C') (hT : DominatedFinMeasAdditive Î¼ T C)\n    (f : Î± â†’ E) (hf : Integrable f (Î¼ + Î¼')) :\n    setToFun (Î¼ + Î¼') T hT_add f = setToFun Î¼ T hT f := by\n  refine setToFun_congr_measure_of_integrable 1 one_ne_top ?_ hT_add hT f hf\n  rw [one_smul]\n  nth_rw 1 [â† add_zero Î¼]\n  exact add_le_add le_rfl bot_le\n\n"}
{"name":"MeasureTheory.setToFun_congr_measure_of_add_left","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nÎ¼' : MeasureTheory.Measure Î±\nhT_add : MeasureTheory.DominatedFinMeasAdditive (HAdd.hAdd Î¼ Î¼') T C'\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼' T C\nf : Î± â†’ E\nhf : MeasureTheory.Integrable f (HAdd.hAdd Î¼ Î¼')\nâŠ¢ Eq (MeasureTheory.setToFun (HAdd.hAdd Î¼ Î¼') T hT_add f) (MeasureTheory.setToFun Î¼' T hT f)","decl":"theorem setToFun_congr_measure_of_add_left {Î¼' : Measure Î±}\n    (hT_add : DominatedFinMeasAdditive (Î¼ + Î¼') T C') (hT : DominatedFinMeasAdditive Î¼' T C)\n    (f : Î± â†’ E) (hf : Integrable f (Î¼ + Î¼')) :\n    setToFun (Î¼ + Î¼') T hT_add f = setToFun Î¼' T hT f := by\n  refine setToFun_congr_measure_of_integrable 1 one_ne_top ?_ hT_add hT f hf\n  rw [one_smul]\n  nth_rw 1 [â† zero_add Î¼']\n  exact add_le_add bot_le le_rfl\n\n"}
{"name":"MeasureTheory.setToFun_top_smul_measure","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive (HSMul.hSMul Top.top Î¼) T C\nf : Î± â†’ E\nâŠ¢ Eq (MeasureTheory.setToFun (HSMul.hSMul Top.top Î¼) T hT f) 0","decl":"theorem setToFun_top_smul_measure (hT : DominatedFinMeasAdditive (âˆ â€¢ Î¼) T C) (f : Î± â†’ E) :\n    setToFun (âˆ â€¢ Î¼) T hT f = 0 := by\n  refine setToFun_measure_zero' hT fun s _ hÎ¼s => ?_\n  rw [lt_top_iff_ne_top] at hÎ¼s\n  simp only [true_and, Measure.smul_apply, ENNReal.mul_eq_top, eq_self_iff_true,\n    top_ne_zero, Ne, not_false_iff, not_or, Classical.not_not, smul_eq_mul] at hÎ¼s\n  simp only [hÎ¼s.right, Measure.smul_apply, mul_zero, smul_eq_mul]\n\n"}
{"name":"MeasureTheory.setToFun_congr_smul_measure","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC C' : Real\nc : ENNReal\nhc_ne_top : Ne c Top.top\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhT_smul : MeasureTheory.DominatedFinMeasAdditive (HSMul.hSMul c Î¼) T C'\nf : Î± â†’ E\nâŠ¢ Eq (MeasureTheory.setToFun Î¼ T hT f) (MeasureTheory.setToFun (HSMul.hSMul c Î¼) T hT_smul f)","decl":"theorem setToFun_congr_smul_measure (c : â„â‰¥0âˆ) (hc_ne_top : c â‰  âˆ)\n    (hT : DominatedFinMeasAdditive Î¼ T C) (hT_smul : DominatedFinMeasAdditive (c â€¢ Î¼) T C')\n    (f : Î± â†’ E) : setToFun Î¼ T hT f = setToFun (c â€¢ Î¼) T hT_smul f := by\n  by_cases hc0 : c = 0\n  Â· simp [hc0] at hT_smul\n    have h : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ T s = 0 := fun s hs _ => hT_smul.eq_zero hs\n    rw [setToFun_zero_left' _ h, setToFun_measure_zero]\n    simp [hc0]\n  refine setToFun_congr_measure câ»Â¹ c ?_ hc_ne_top (le_of_eq ?_) le_rfl hT hT_smul f\n  Â· simp [hc0]\n  Â· rw [smul_smul, ENNReal.inv_mul_cancel hc0 hc_ne_top, one_smul]\n\n"}
{"name":"MeasureTheory.norm_setToFun_le_mul_norm","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nhC : LE.le 0 C\nâŠ¢ LE.le (Norm.norm (MeasureTheory.setToFun Î¼ T hT â†‘â†‘f)) (HMul.hMul C (Norm.norm f))","decl":"theorem norm_setToFun_le_mul_norm (hT : DominatedFinMeasAdditive Î¼ T C) (f : Î± â†’â‚[Î¼] E)\n    (hC : 0 â‰¤ C) : â€–setToFun Î¼ T hT fâ€– â‰¤ C * â€–fâ€– := by\n  rw [L1.setToFun_eq_setToL1]; exact L1.norm_setToL1_le_mul_norm hT hC f\n\n"}
{"name":"MeasureTheory.norm_setToFun_le_mul_norm'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ LE.le (Norm.norm (MeasureTheory.setToFun Î¼ T hT â†‘â†‘f)) (HMul.hMul (Max.max C 0) (Norm.norm f))","decl":"theorem norm_setToFun_le_mul_norm' (hT : DominatedFinMeasAdditive Î¼ T C) (f : Î± â†’â‚[Î¼] E) :\n    â€–setToFun Î¼ T hT fâ€– â‰¤ max C 0 * â€–fâ€– := by\n  rw [L1.setToFun_eq_setToL1]; exact L1.norm_setToL1_le_mul_norm' hT f\n\n"}
{"name":"MeasureTheory.norm_setToFun_le","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nf : Î± â†’ E\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhf : MeasureTheory.Integrable f Î¼\nhC : LE.le 0 C\nâŠ¢ LE.le (Norm.norm (MeasureTheory.setToFun Î¼ T hT f)) (HMul.hMul C (Norm.norm (MeasureTheory.Integrable.toL1 f hf)))","decl":"theorem norm_setToFun_le (hT : DominatedFinMeasAdditive Î¼ T C) (hf : Integrable f Î¼) (hC : 0 â‰¤ C) :\n    â€–setToFun Î¼ T hT fâ€– â‰¤ C * â€–hf.toL1 fâ€– := by\n  rw [setToFun_eq hT hf]; exact L1.norm_setToL1_le_mul_norm hT hC _\n\n"}
{"name":"MeasureTheory.norm_setToFun_le'","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nf : Î± â†’ E\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ LE.le (Norm.norm (MeasureTheory.setToFun Î¼ T hT f)) (HMul.hMul (Max.max C 0) (Norm.norm (MeasureTheory.Integrable.toL1 f hf)))","decl":"theorem norm_setToFun_le' (hT : DominatedFinMeasAdditive Î¼ T C) (hf : Integrable f Î¼) :\n    â€–setToFun Î¼ T hT fâ€– â‰¤ max C 0 * â€–hf.toL1 fâ€– := by\n  rw [setToFun_eq hT hf]; exact L1.norm_setToL1_le_mul_norm' hT _\n\n"}
{"name":"MeasureTheory.tendsto_setToFun_of_dominated_convergence","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nfs : Nat â†’ Î± â†’ E\nf : Î± â†’ E\nbound : Î± â†’ Real\nfs_measurable : âˆ€ (n : Nat), MeasureTheory.AEStronglyMeasurable (fs n) Î¼\nbound_integrable : MeasureTheory.Integrable bound Î¼\nh_bound : âˆ€ (n : Nat), Filter.Eventually (fun a => LE.le (Norm.norm (fs n a)) (bound a)) (MeasureTheory.ae Î¼)\nh_lim : Filter.Eventually (fun a => Filter.Tendsto (fun n => fs n a) Filter.atTop (nhds (f a))) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.setToFun Î¼ T hT (fs n)) Filter.atTop (nhds (MeasureTheory.setToFun Î¼ T hT f))","decl":"/-- Lebesgue dominated convergence theorem provides sufficient conditions under which almost\n  everywhere convergence of a sequence of functions implies the convergence of their image by\n  `setToFun`.\n  We could weaken the condition `bound_integrable` to require `HasFiniteIntegral bound Î¼` instead\n  (i.e. not requiring that `bound` is measurable), but in all applications proving integrability\n  is easier. -/\ntheorem tendsto_setToFun_of_dominated_convergence (hT : DominatedFinMeasAdditive Î¼ T C)\n    {fs : â„• â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„)\n    (fs_measurable : âˆ€ n, AEStronglyMeasurable (fs n) Î¼) (bound_integrable : Integrable bound Î¼)\n    (h_bound : âˆ€ n, âˆ€áµ a âˆ‚Î¼, â€–fs n aâ€– â‰¤ bound a)\n    (h_lim : âˆ€áµ a âˆ‚Î¼, Tendsto (fun n => fs n a) atTop (ğ“ (f a))) :\n    Tendsto (fun n => setToFun Î¼ T hT (fs n)) atTop (ğ“ <| setToFun Î¼ T hT f) := by\n  -- `f` is a.e.-measurable, since it is the a.e.-pointwise limit of a.e.-measurable functions.\n  have f_measurable : AEStronglyMeasurable f Î¼ :=\n    aestronglyMeasurable_of_tendsto_ae _ fs_measurable h_lim\n  -- all functions we consider are integrable\n  have fs_int : âˆ€ n, Integrable (fs n) Î¼ := fun n =>\n    bound_integrable.mono' (fs_measurable n) (h_bound _)\n  have f_int : Integrable f Î¼ :=\n    âŸ¨f_measurable,\n      hasFiniteIntegral_of_dominated_convergence bound_integrable.hasFiniteIntegral h_bound\n        h_limâŸ©\n  -- it suffices to prove the result for the corresponding L1 functions\n  suffices\n    Tendsto (fun n => L1.setToL1 hT ((fs_int n).toL1 (fs n))) atTop\n      (ğ“ (L1.setToL1 hT (f_int.toL1 f))) by\n    convert this with n\n    Â· exact setToFun_eq hT (fs_int n)\n    Â· exact setToFun_eq hT f_int\n  -- the convergence of setToL1 follows from the convergence of the L1 functions\n  refine L1.tendsto_setToL1 hT _ _ ?_\n  -- up to some rewriting, what we need to prove is `h_lim`\n  rw [tendsto_iff_norm_sub_tendsto_zero]\n  have lintegral_norm_tendsto_zero :\n    Tendsto (fun n => ENNReal.toReal <| âˆ«â» a, ENNReal.ofReal â€–fs n a - f aâ€– âˆ‚Î¼) atTop (ğ“ 0) :=\n    (tendsto_toReal zero_ne_top).comp\n      (tendsto_lintegral_norm_of_dominated_convergence fs_measurable\n        bound_integrable.hasFiniteIntegral h_bound h_lim)\n  convert lintegral_norm_tendsto_zero with n\n  rw [L1.norm_def]\n  congr 1\n  refine lintegral_congr_ae ?_\n  rw [â† Integrable.toL1_sub]\n  refine ((fs_int n).sub f_int).coeFn_toL1.mono fun x hx => ?_\n  dsimp only\n  rw [hx, ofReal_norm_eq_enorm, Pi.sub_apply]\n\n"}
{"name":"MeasureTheory.tendsto_setToFun_filter_of_dominated_convergence","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nÎ¹ : Type u_7\nl : Filter Î¹\ninstâœ : l.IsCountablyGenerated\nfs : Î¹ â†’ Î± â†’ E\nf : Î± â†’ E\nbound : Î± â†’ Real\nhfs_meas : Filter.Eventually (fun n => MeasureTheory.AEStronglyMeasurable (fs n) Î¼) l\nh_bound : Filter.Eventually (fun n => Filter.Eventually (fun a => LE.le (Norm.norm (fs n a)) (bound a)) (MeasureTheory.ae Î¼)) l\nbound_integrable : MeasureTheory.Integrable bound Î¼\nh_lim : Filter.Eventually (fun a => Filter.Tendsto (fun n => fs n a) l (nhds (f a))) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.setToFun Î¼ T hT (fs n)) l (nhds (MeasureTheory.setToFun Î¼ T hT f))","decl":"/-- Lebesgue dominated convergence theorem for filters with a countable basis -/\ntheorem tendsto_setToFun_filter_of_dominated_convergence (hT : DominatedFinMeasAdditive Î¼ T C) {Î¹}\n    {l : Filter Î¹} [l.IsCountablyGenerated] {fs : Î¹ â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„)\n    (hfs_meas : âˆ€á¶  n in l, AEStronglyMeasurable (fs n) Î¼)\n    (h_bound : âˆ€á¶  n in l, âˆ€áµ a âˆ‚Î¼, â€–fs n aâ€– â‰¤ bound a) (bound_integrable : Integrable bound Î¼)\n    (h_lim : âˆ€áµ a âˆ‚Î¼, Tendsto (fun n => fs n a) l (ğ“ (f a))) :\n    Tendsto (fun n => setToFun Î¼ T hT (fs n)) l (ğ“ <| setToFun Î¼ T hT f) := by\n  rw [tendsto_iff_seq_tendsto]\n  intro x xl\n  have hxl : âˆ€ s âˆˆ l, âˆƒ a, âˆ€ b â‰¥ a, x b âˆˆ s := by rwa [tendsto_atTop'] at xl\n  have h :\n    { x : Î¹ | (fun n => AEStronglyMeasurable (fs n) Î¼) x } âˆ©\n        { x : Î¹ | (fun n => âˆ€áµ a âˆ‚Î¼, â€–fs n aâ€– â‰¤ bound a) x } âˆˆ l :=\n    inter_mem hfs_meas h_bound\n  obtain âŸ¨k, hâŸ© := hxl _ h\n  rw [â† tendsto_add_atTop_iff_nat k]\n  refine tendsto_setToFun_of_dominated_convergence hT bound ?_ bound_integrable ?_ ?_\n  Â· exact fun n => (h _ (self_le_add_left _ _)).1\n  Â· exact fun n => (h _ (self_le_add_left _ _)).2\n  Â· filter_upwards [h_lim]\n    refine fun a h_lin => @Tendsto.comp _ _ _ (fun n => x (n + k)) (fun n => fs n a) _ _ _ h_lin ?_\n    rw [tendsto_add_atTop_iff_nat]\n    assumption\n\n"}
{"name":"MeasureTheory.continuousWithinAt_setToFun_of_dominated","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Real E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nX : Type u_7\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : FirstCountableTopology X\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nfs : X â†’ Î± â†’ E\nxâ‚€ : X\nbound : Î± â†’ Real\ns : Set X\nhfs_meas : Filter.Eventually (fun x => MeasureTheory.AEStronglyMeasurable (fs x) Î¼) (nhdsWithin xâ‚€ s)\nh_bound : Filter.Eventually (fun x => Filter.Eventually (fun a => LE.le (Norm.norm (fs x a)) (bound a)) (MeasureTheory.ae Î¼)) (nhdsWithin xâ‚€ s)\nbound_integrable : MeasureTheory.Integrable bound Î¼\nh_cont : Filter.Eventually (fun a => ContinuousWithinAt (fun x => fs x a) s xâ‚€) (MeasureTheory.ae Î¼)\nâŠ¢ ContinuousWithinAt (fun x => MeasureTheory.setToFun Î¼ T hT (fs x)) s xâ‚€","decl":"theorem continuousWithinAt_setToFun_of_dominated (hT : DominatedFinMeasAdditive Î¼ T C)\n    {fs : X â†’ Î± â†’ E} {xâ‚€ : X} {bound : Î± â†’ â„} {s : Set X}\n    (hfs_meas : âˆ€á¶  x in ğ“[s] xâ‚€, AEStronglyMeasurable (fs x) Î¼)\n    (h_bound : âˆ€á¶  x in ğ“[s] xâ‚€, âˆ€áµ a âˆ‚Î¼, â€–fs x aâ€– â‰¤ bound a) (bound_integrable : Integrable bound Î¼)\n    (h_cont : âˆ€áµ a âˆ‚Î¼, ContinuousWithinAt (fun x => fs x a) s xâ‚€) :\n    ContinuousWithinAt (fun x => setToFun Î¼ T hT (fs x)) s xâ‚€ :=\n  tendsto_setToFun_filter_of_dominated_convergence hT bound â€¹_â€º â€¹_â€º â€¹_â€º â€¹_â€º\n\n"}
{"name":"MeasureTheory.continuousAt_setToFun_of_dominated","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Real E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nX : Type u_7\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : FirstCountableTopology X\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nfs : X â†’ Î± â†’ E\nxâ‚€ : X\nbound : Î± â†’ Real\nhfs_meas : Filter.Eventually (fun x => MeasureTheory.AEStronglyMeasurable (fs x) Î¼) (nhds xâ‚€)\nh_bound : Filter.Eventually (fun x => Filter.Eventually (fun a => LE.le (Norm.norm (fs x a)) (bound a)) (MeasureTheory.ae Î¼)) (nhds xâ‚€)\nbound_integrable : MeasureTheory.Integrable bound Î¼\nh_cont : Filter.Eventually (fun a => ContinuousAt (fun x => fs x a) xâ‚€) (MeasureTheory.ae Î¼)\nâŠ¢ ContinuousAt (fun x => MeasureTheory.setToFun Î¼ T hT (fs x)) xâ‚€","decl":"theorem continuousAt_setToFun_of_dominated (hT : DominatedFinMeasAdditive Î¼ T C) {fs : X â†’ Î± â†’ E}\n    {xâ‚€ : X} {bound : Î± â†’ â„} (hfs_meas : âˆ€á¶  x in ğ“ xâ‚€, AEStronglyMeasurable (fs x) Î¼)\n    (h_bound : âˆ€á¶  x in ğ“ xâ‚€, âˆ€áµ a âˆ‚Î¼, â€–fs x aâ€– â‰¤ bound a) (bound_integrable : Integrable bound Î¼)\n    (h_cont : âˆ€áµ a âˆ‚Î¼, ContinuousAt (fun x => fs x a) xâ‚€) :\n    ContinuousAt (fun x => setToFun Î¼ T hT (fs x)) xâ‚€ :=\n  tendsto_setToFun_filter_of_dominated_convergence hT bound â€¹_â€º â€¹_â€º â€¹_â€º â€¹_â€º\n\n"}
{"name":"MeasureTheory.continuousOn_setToFun_of_dominated","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Real E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nX : Type u_7\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : FirstCountableTopology X\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nfs : X â†’ Î± â†’ E\nbound : Î± â†’ Real\ns : Set X\nhfs_meas : âˆ€ (x : X), Membership.mem s x â†’ MeasureTheory.AEStronglyMeasurable (fs x) Î¼\nh_bound : âˆ€ (x : X), Membership.mem s x â†’ Filter.Eventually (fun a => LE.le (Norm.norm (fs x a)) (bound a)) (MeasureTheory.ae Î¼)\nbound_integrable : MeasureTheory.Integrable bound Î¼\nh_cont : Filter.Eventually (fun a => ContinuousOn (fun x => fs x a) s) (MeasureTheory.ae Î¼)\nâŠ¢ ContinuousOn (fun x => MeasureTheory.setToFun Î¼ T hT (fs x)) s","decl":"theorem continuousOn_setToFun_of_dominated (hT : DominatedFinMeasAdditive Î¼ T C) {fs : X â†’ Î± â†’ E}\n    {bound : Î± â†’ â„} {s : Set X} (hfs_meas : âˆ€ x âˆˆ s, AEStronglyMeasurable (fs x) Î¼)\n    (h_bound : âˆ€ x âˆˆ s, âˆ€áµ a âˆ‚Î¼, â€–fs x aâ€– â‰¤ bound a) (bound_integrable : Integrable bound Î¼)\n    (h_cont : âˆ€áµ a âˆ‚Î¼, ContinuousOn (fun x => fs x a) s) :\n    ContinuousOn (fun x => setToFun Î¼ T hT (fs x)) s := by\n  intro x hx\n  refine continuousWithinAt_setToFun_of_dominated hT ?_ ?_ bound_integrable ?_\n  Â· filter_upwards [self_mem_nhdsWithin] with x hx using hfs_meas x hx\n  Â· filter_upwards [self_mem_nhdsWithin] with x hx using h_bound x hx\n  Â· filter_upwards [h_cont] with a ha using ha x hx\n\n"}
{"name":"MeasureTheory.continuous_setToFun_of_dominated","module":"Mathlib.MeasureTheory.Integral.SetToL1","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Real E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : CompleteSpace F\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nX : Type u_7\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : FirstCountableTopology X\nhT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C\nfs : X â†’ Î± â†’ E\nbound : Î± â†’ Real\nhfs_meas : âˆ€ (x : X), MeasureTheory.AEStronglyMeasurable (fs x) Î¼\nh_bound : âˆ€ (x : X), Filter.Eventually (fun a => LE.le (Norm.norm (fs x a)) (bound a)) (MeasureTheory.ae Î¼)\nbound_integrable : MeasureTheory.Integrable bound Î¼\nh_cont : Filter.Eventually (fun a => Continuous fun x => fs x a) (MeasureTheory.ae Î¼)\nâŠ¢ Continuous fun x => MeasureTheory.setToFun Î¼ T hT (fs x)","decl":"theorem continuous_setToFun_of_dominated (hT : DominatedFinMeasAdditive Î¼ T C) {fs : X â†’ Î± â†’ E}\n    {bound : Î± â†’ â„} (hfs_meas : âˆ€ x, AEStronglyMeasurable (fs x) Î¼)\n    (h_bound : âˆ€ x, âˆ€áµ a âˆ‚Î¼, â€–fs x aâ€– â‰¤ bound a) (bound_integrable : Integrable bound Î¼)\n    (h_cont : âˆ€áµ a âˆ‚Î¼, Continuous fun x => fs x a) : Continuous fun x => setToFun Î¼ T hT (fs x) :=\n  continuous_iff_continuousAt.mpr fun _ =>\n    continuousAt_setToFun_of_dominated hT (Eventually.of_forall hfs_meas)\n        (Eventually.of_forall h_bound) â€¹_â€º <|\n      h_cont.mono fun _ => Continuous.continuousAt\n\n"}
