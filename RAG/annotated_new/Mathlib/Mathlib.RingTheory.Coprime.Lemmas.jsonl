{"name":"Int.isCoprime_iff_gcd_eq_one","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"m n : Int\n⊢ Iff (IsCoprime m n) (Eq (m.gcd n) 1)","decl":"theorem Int.isCoprime_iff_gcd_eq_one {m n : ℤ} : IsCoprime m n ↔ Int.gcd m n = 1 := by\n  constructor\n  · rintro ⟨a, b, h⟩\n    refine Nat.dvd_one.mp (Int.gcd_dvd_iff.mpr ⟨a, b, ?_⟩)\n    rwa [mul_comm m, mul_comm n, eq_comm]\n  · rw [← Int.ofNat_inj, IsCoprime, Int.gcd_eq_gcd_ab, mul_comm m, mul_comm n, Nat.cast_one]\n    intro h\n    exact ⟨_, _, h⟩\n\n"}
{"name":"Nat.isCoprime_iff_coprime","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"m n : Nat\n⊢ Iff (IsCoprime ↑m ↑n) (m.Coprime n)","decl":"theorem Nat.isCoprime_iff_coprime {m n : ℕ} : IsCoprime (m : ℤ) n ↔ Nat.Coprime m n := by\n  rw [Int.isCoprime_iff_gcd_eq_one, Int.gcd_natCast_natCast]\n\n"}
{"name":"Nat.Coprime.isCoprime","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"m n : Nat\na✝ : m.Coprime n\n⊢ IsCoprime ↑m ↑n","decl":"alias ⟨IsCoprime.nat_coprime, Nat.Coprime.isCoprime⟩ := Nat.isCoprime_iff_coprime\n\n"}
{"name":"IsCoprime.nat_coprime","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"m n : Nat\na✝ : IsCoprime ↑m ↑n\n⊢ m.Coprime n","decl":"alias ⟨IsCoprime.nat_coprime, Nat.Coprime.isCoprime⟩ := Nat.isCoprime_iff_coprime\n\n"}
{"name":"Nat.Coprime.cast","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"R : Type u_1\ninst✝ : CommRing R\na b : Nat\nh : a.Coprime b\n⊢ IsCoprime ↑a ↑b","decl":"theorem Nat.Coprime.cast {R : Type*} [CommRing R] {a b : ℕ} (h : Nat.Coprime a b) :\n    IsCoprime (a : R) (b : R) := by\n  rw [← isCoprime_iff_coprime] at h\n  rw [← Int.cast_natCast a, ← Int.cast_natCast b]\n  exact IsCoprime.intCast h\n\n"}
{"name":"ne_zero_or_ne_zero_of_nat_coprime","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"A : Type u\ninst✝¹ : CommRing A\ninst✝ : Nontrivial A\na b : Nat\nh : a.Coprime b\n⊢ Or (Ne (↑a) 0) (Ne (↑b) 0)","decl":"theorem ne_zero_or_ne_zero_of_nat_coprime {A : Type u} [CommRing A] [Nontrivial A] {a b : ℕ}\n    (h : Nat.Coprime a b) : (a : A) ≠ 0 ∨ (b : A) ≠ 0 :=\n  IsCoprime.ne_zero_or_ne_zero (R := A) <| by\n    simpa only [map_natCast] using IsCoprime.map (Nat.Coprime.isCoprime h) (Int.castRingHom A)\n\n"}
{"name":"IsCoprime.prod_left","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"R : Type u\nI : Type v\ninst✝ : CommSemiring R\nx : R\ns : I → R\nt : Finset I\na✝ : ∀ (i : I), Membership.mem t i → IsCoprime (s i) x\n⊢ IsCoprime (t.prod fun i => s i) x","decl":"theorem IsCoprime.prod_left : (∀ i ∈ t, IsCoprime (s i) x) → IsCoprime (∏ i ∈ t, s i) x := by\n  classical\n  refine Finset.induction_on t (fun _ ↦ isCoprime_one_left) fun b t hbt ih H ↦ ?_\n  rw [Finset.prod_insert hbt]\n  rw [Finset.forall_mem_insert] at H\n  exact H.1.mul_left (ih H.2)\n\n"}
{"name":"IsCoprime.prod_right","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"R : Type u\nI : Type v\ninst✝ : CommSemiring R\nx : R\ns : I → R\nt : Finset I\na✝ : ∀ (i : I), Membership.mem t i → IsCoprime x (s i)\n⊢ IsCoprime x (t.prod fun i => s i)","decl":"theorem IsCoprime.prod_right : (∀ i ∈ t, IsCoprime x (s i)) → IsCoprime x (∏ i ∈ t, s i) := by\n  simpa only [isCoprime_comm] using IsCoprime.prod_left (R := R)\n\n"}
{"name":"IsCoprime.prod_left_iff","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"R : Type u\nI : Type v\ninst✝ : CommSemiring R\nx : R\ns : I → R\nt : Finset I\n⊢ Iff (IsCoprime (t.prod fun i => s i) x) (∀ (i : I), Membership.mem t i → IsCoprime (s i) x)","decl":"theorem IsCoprime.prod_left_iff : IsCoprime (∏ i ∈ t, s i) x ↔ ∀ i ∈ t, IsCoprime (s i) x := by\n  classical\n  refine Finset.induction_on t (iff_of_true isCoprime_one_left fun _ ↦ by simp) fun b t hbt ih ↦ ?_\n  rw [Finset.prod_insert hbt, IsCoprime.mul_left_iff, ih, Finset.forall_mem_insert]\n\n"}
{"name":"IsCoprime.prod_right_iff","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"R : Type u\nI : Type v\ninst✝ : CommSemiring R\nx : R\ns : I → R\nt : Finset I\n⊢ Iff (IsCoprime x (t.prod fun i => s i)) (∀ (i : I), Membership.mem t i → IsCoprime x (s i))","decl":"theorem IsCoprime.prod_right_iff : IsCoprime x (∏ i ∈ t, s i) ↔ ∀ i ∈ t, IsCoprime x (s i) := by\n  simpa only [isCoprime_comm] using IsCoprime.prod_left_iff (R := R)\n\n"}
{"name":"IsCoprime.of_prod_left","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"R : Type u\nI : Type v\ninst✝ : CommSemiring R\nx : R\ns : I → R\nt : Finset I\nH1 : IsCoprime (t.prod fun i => s i) x\ni : I\nhit : Membership.mem t i\n⊢ IsCoprime (s i) x","decl":"theorem IsCoprime.of_prod_left (H1 : IsCoprime (∏ i ∈ t, s i) x) (i : I) (hit : i ∈ t) :\n    IsCoprime (s i) x :=\n  IsCoprime.prod_left_iff.1 H1 i hit\n\n"}
{"name":"IsCoprime.of_prod_right","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"R : Type u\nI : Type v\ninst✝ : CommSemiring R\nx : R\ns : I → R\nt : Finset I\nH1 : IsCoprime x (t.prod fun i => s i)\ni : I\nhit : Membership.mem t i\n⊢ IsCoprime x (s i)","decl":"theorem IsCoprime.of_prod_right (H1 : IsCoprime x (∏ i ∈ t, s i)) (i : I) (hit : i ∈ t) :\n    IsCoprime x (s i) :=\n  IsCoprime.prod_right_iff.1 H1 i hit\n\n-- Porting note: removed names of things due to linter, but they seem helpful\n"}
{"name":"Finset.prod_dvd_of_coprime","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"R : Type u\nI : Type v\ninst✝ : CommSemiring R\nz : R\ns : I → R\nt : Finset I\na✝¹ : (↑t).Pairwise (Function.onFun IsCoprime s)\na✝ : ∀ (i : I), Membership.mem t i → Dvd.dvd (s i) z\n⊢ Dvd.dvd (t.prod fun x => s x) z","decl":"theorem Finset.prod_dvd_of_coprime :\n    (t : Set I).Pairwise (IsCoprime on s) → (∀ i ∈ t, s i ∣ z) → (∏ x ∈ t, s x) ∣ z := by\n  classical\n  exact Finset.induction_on t (fun _ _ ↦ one_dvd z)\n    (by\n      intro a r har ih Hs Hs1\n      rw [Finset.prod_insert har]\n      have aux1 : a ∈ (↑(insert a r) : Set I) := Finset.mem_insert_self a r\n      refine\n        (IsCoprime.prod_right fun i hir ↦\n              Hs aux1 (Finset.mem_insert_of_mem hir) <| by\n                rintro rfl\n                exact har hir).mul_dvd\n          (Hs1 a aux1) (ih (Hs.mono ?_) fun i hi ↦ Hs1 i <| Finset.mem_insert_of_mem hi)\n      simp only [Finset.coe_insert, Set.subset_insert])\n\n"}
{"name":"Fintype.prod_dvd_of_coprime","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"R : Type u\nI : Type v\ninst✝¹ : CommSemiring R\nz : R\ns : I → R\ninst✝ : Fintype I\nHs : Pairwise (Function.onFun IsCoprime s)\nHs1 : ∀ (i : I), Dvd.dvd (s i) z\n⊢ Dvd.dvd (Finset.univ.prod fun x => s x) z","decl":"theorem Fintype.prod_dvd_of_coprime [Fintype I] (Hs : Pairwise (IsCoprime on s))\n    (Hs1 : ∀ i, s i ∣ z) : (∏ x, s x) ∣ z :=\n  Finset.prod_dvd_of_coprime (Hs.set_pairwise _) fun i _ ↦ Hs1 i\n\n"}
{"name":"exists_sum_eq_one_iff_pairwise_coprime","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"R : Type u\nI : Type v\ninst✝¹ : CommSemiring R\ns : I → R\nt : Finset I\ninst✝ : DecidableEq I\nh : t.Nonempty\n⊢ Iff (Exists fun μ => Eq (t.sum fun i => HMul.hMul (μ i) ((SDiff.sdiff t (Singleton.singleton i)).prod fun j => s j)) 1) (Pairwise (Function.onFun IsCoprime fun i => s ↑i))","decl":"theorem exists_sum_eq_one_iff_pairwise_coprime [DecidableEq I] (h : t.Nonempty) :\n    (∃ μ : I → R, (∑ i ∈ t, μ i * ∏ j ∈ t \\ {i}, s j) = 1) ↔\n      Pairwise (IsCoprime on fun i : t ↦ s i) := by\n  induction h using Finset.Nonempty.cons_induction with\n  | singleton =>\n    simp [exists_apply_eq, Pairwise, Function.onFun]\n  | cons a t hat h ih =>\n    rw [pairwise_cons']\n    have mem : ∀ x ∈ t, a ∈ insert a t \\ {x} := fun x hx ↦ by\n      rw [mem_sdiff, mem_singleton]\n      exact ⟨mem_insert_self _ _, fun ha ↦ hat (ha ▸ hx)⟩\n    constructor\n    · rintro ⟨μ, hμ⟩\n      rw [sum_cons, cons_eq_insert, sdiff_singleton_eq_erase, erase_insert hat] at hμ\n      refine ⟨ih.mp ⟨Pi.single h.choose (μ a * s h.choose) + μ * fun _ ↦ s a, ?_⟩, fun b hb ↦ ?_⟩\n      · rw [prod_eq_mul_prod_diff_singleton h.choose_spec, ← mul_assoc, ←\n          @if_pos _ _ h.choose_spec R (_ * _) 0, ← sum_pi_single', ← sum_add_distrib] at hμ\n        rw [← hμ, sum_congr rfl]\n        intro x hx\n        dsimp -- Porting note: terms were showing as sort of `HAdd.hadd` instead of `+`\n        -- this whole proof pretty much breaks and has to be rewritten from scratch\n        rw [add_mul]\n        congr 1\n        · by_cases hx : x = h.choose\n          · rw [hx, Pi.single_eq_same, Pi.single_eq_same]\n          · rw [Pi.single_eq_of_ne hx, Pi.single_eq_of_ne hx, zero_mul]\n        · rw [mul_assoc]\n          congr\n          rw [prod_eq_prod_diff_singleton_mul (mem x hx) _, mul_comm]\n          congr 2\n          rw [sdiff_sdiff_comm, sdiff_singleton_eq_erase a, erase_insert hat]\n      · have : IsCoprime (s b) (s a) :=\n          ⟨μ a * ∏ i ∈ t \\ {b}, s i, ∑ i ∈ t, μ i * ∏ j ∈ t \\ {i}, s j, ?_⟩\n        · exact ⟨this.symm, this⟩\n        rw [mul_assoc, ← prod_eq_prod_diff_singleton_mul hb, sum_mul, ← hμ, sum_congr rfl]\n        intro x hx\n        rw [mul_assoc]\n        congr\n        rw [prod_eq_prod_diff_singleton_mul (mem x hx) _]\n        congr 2\n        rw [sdiff_sdiff_comm, sdiff_singleton_eq_erase a, erase_insert hat]\n    · rintro ⟨hs, Hb⟩\n      obtain ⟨μ, hμ⟩ := ih.mpr hs\n      obtain ⟨u, v, huv⟩ := IsCoprime.prod_left fun b hb ↦ (Hb b hb).right\n      use fun i ↦ if i = a then u else v * μ i\n      have hμ' : (∑ i ∈ t, v * ((μ i * ∏ j ∈ t \\ {i}, s j) * s a)) = v * s a := by\n        rw [← mul_sum, ← sum_mul, hμ, one_mul]\n      rw [sum_cons, cons_eq_insert, sdiff_singleton_eq_erase, erase_insert hat]\n      simp only [↓reduceIte, ite_mul]\n      rw [← huv, ← hμ', sum_congr rfl]\n      intro x hx\n      rw [mul_assoc, if_neg fun ha : x = a ↦ hat (ha.casesOn hx)]\n      rw [mul_assoc]\n      congr\n      rw [prod_eq_prod_diff_singleton_mul (mem x hx) _]\n      congr 2\n      rw [sdiff_sdiff_comm, sdiff_singleton_eq_erase a, erase_insert hat]\n\n"}
{"name":"exists_sum_eq_one_iff_pairwise_coprime'","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"R : Type u\nI : Type v\ninst✝³ : CommSemiring R\ns : I → R\ninst✝² : Fintype I\ninst✝¹ : Nonempty I\ninst✝ : DecidableEq I\n⊢ Iff (Exists fun μ => Eq (Finset.univ.sum fun i => HMul.hMul (μ i) ((HasCompl.compl (Singleton.singleton i)).prod fun j => s j)) 1) (Pairwise (Function.onFun IsCoprime s))","decl":"theorem exists_sum_eq_one_iff_pairwise_coprime' [Fintype I] [Nonempty I] [DecidableEq I] :\n    (∃ μ : I → R, (∑ i : I, μ i * ∏ j ∈ {i}ᶜ, s j) = 1) ↔ Pairwise (IsCoprime on s) := by\n  convert exists_sum_eq_one_iff_pairwise_coprime Finset.univ_nonempty (s := s) using 1\n  simp only [Function.onFun, pairwise_subtype_iff_pairwise_finset', coe_univ, Set.pairwise_univ]\n\n-- Porting note: a lot of the capitalization wasn't working\n"}
{"name":"pairwise_coprime_iff_coprime_prod","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"R : Type u\nI : Type v\ninst✝¹ : CommSemiring R\ns : I → R\nt : Finset I\ninst✝ : DecidableEq I\n⊢ Iff (Pairwise (Function.onFun IsCoprime fun i => s ↑i)) (∀ (i : I), Membership.mem t i → IsCoprime (s i) ((SDiff.sdiff t (Singleton.singleton i)).prod fun j => s j))","decl":"theorem pairwise_coprime_iff_coprime_prod [DecidableEq I] :\n    Pairwise (IsCoprime on fun i : t ↦ s i) ↔ ∀ i ∈ t, IsCoprime (s i) (∏ j ∈ t \\ {i}, s j) := by\n  refine ⟨fun hp i hi ↦ IsCoprime.prod_right_iff.mpr fun j hj ↦ ?_, fun hp ↦ ?_⟩\n  · rw [Finset.mem_sdiff, Finset.mem_singleton] at hj\n    obtain ⟨hj, ji⟩ := hj\n    refine @hp ⟨i, hi⟩ ⟨j, hj⟩ fun h ↦ ji (congrArg Subtype.val h).symm\n    -- Porting note: is there a better way compared to the old `congr_arg coe h`?\n  · rintro ⟨i, hi⟩ ⟨j, hj⟩ h\n    apply IsCoprime.prod_right_iff.mp (hp i hi)\n    exact Finset.mem_sdiff.mpr ⟨hj, fun f ↦ h <| Subtype.ext (Finset.mem_singleton.mp f).symm⟩\n\n"}
{"name":"IsCoprime.pow_left","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y : R\nm : Nat\nH : IsCoprime x y\n⊢ IsCoprime (HPow.hPow x m) y","decl":"theorem IsCoprime.pow_left (H : IsCoprime x y) : IsCoprime (x ^ m) y := by\n  rw [← Finset.card_range m, ← Finset.prod_const]\n  exact IsCoprime.prod_left fun _ _ ↦ H\n\n"}
{"name":"IsCoprime.pow_right","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y : R\nn : Nat\nH : IsCoprime x y\n⊢ IsCoprime x (HPow.hPow y n)","decl":"theorem IsCoprime.pow_right (H : IsCoprime x y) : IsCoprime x (y ^ n) := by\n  rw [← Finset.card_range n, ← Finset.prod_const]\n  exact IsCoprime.prod_right fun _ _ ↦ H\n\n"}
{"name":"IsCoprime.pow","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y : R\nm n : Nat\nH : IsCoprime x y\n⊢ IsCoprime (HPow.hPow x m) (HPow.hPow y n)","decl":"theorem IsCoprime.pow (H : IsCoprime x y) : IsCoprime (x ^ m) (y ^ n) :=\n  H.pow_left.pow_right\n\n"}
{"name":"IsCoprime.pow_left_iff","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y : R\nm : Nat\nhm : LT.lt 0 m\n⊢ Iff (IsCoprime (HPow.hPow x m) y) (IsCoprime x y)","decl":"theorem IsCoprime.pow_left_iff (hm : 0 < m) : IsCoprime (x ^ m) y ↔ IsCoprime x y := by\n  refine ⟨fun h ↦ ?_, IsCoprime.pow_left⟩\n  rw [← Finset.card_range m, ← Finset.prod_const] at h\n  exact h.of_prod_left 0 (Finset.mem_range.mpr hm)\n\n"}
{"name":"IsCoprime.pow_right_iff","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y : R\nm : Nat\nhm : LT.lt 0 m\n⊢ Iff (IsCoprime x (HPow.hPow y m)) (IsCoprime x y)","decl":"theorem IsCoprime.pow_right_iff (hm : 0 < m) : IsCoprime x (y ^ m) ↔ IsCoprime x y :=\n  isCoprime_comm.trans <| (IsCoprime.pow_left_iff hm).trans <| isCoprime_comm\n\n"}
{"name":"IsCoprime.pow_iff","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y : R\nm n : Nat\nhm : LT.lt 0 m\nhn : LT.lt 0 n\n⊢ Iff (IsCoprime (HPow.hPow x m) (HPow.hPow y n)) (IsCoprime x y)","decl":"theorem IsCoprime.pow_iff (hm : 0 < m) (hn : 0 < n) : IsCoprime (x ^ m) (y ^ n) ↔ IsCoprime x y :=\n  (IsCoprime.pow_left_iff hm).trans <| IsCoprime.pow_right_iff hn\n\n"}
{"name":"IsRelPrime.prod_left","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"α : Type u_2\nI : Type u_1\ninst✝¹ : CommMonoid α\ninst✝ : DecompositionMonoid α\nx : α\ns : I → α\nt : Finset I\na✝ : ∀ (i : I), Membership.mem t i → IsRelPrime (s i) x\n⊢ IsRelPrime (t.prod fun i => s i) x","decl":"theorem IsRelPrime.prod_left : (∀ i ∈ t, IsRelPrime (s i) x) → IsRelPrime (∏ i ∈ t, s i) x := by\n  classical\n  refine Finset.induction_on t (fun _ ↦ isRelPrime_one_left) fun b t hbt ih H ↦ ?_\n  rw [Finset.prod_insert hbt]\n  rw [Finset.forall_mem_insert] at H\n  exact H.1.mul_left (ih H.2)\n\n"}
{"name":"IsRelPrime.prod_right","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"α : Type u_2\nI : Type u_1\ninst✝¹ : CommMonoid α\ninst✝ : DecompositionMonoid α\nx : α\ns : I → α\nt : Finset I\na✝ : ∀ (i : I), Membership.mem t i → IsRelPrime x (s i)\n⊢ IsRelPrime x (t.prod fun i => s i)","decl":"theorem IsRelPrime.prod_right : (∀ i ∈ t, IsRelPrime x (s i)) → IsRelPrime x (∏ i ∈ t, s i) := by\n  simpa only [isRelPrime_comm] using IsRelPrime.prod_left (α := α)\n\n"}
{"name":"IsRelPrime.prod_left_iff","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"α : Type u_1\nI : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : DecompositionMonoid α\nx : α\ns : I → α\nt : Finset I\n⊢ Iff (IsRelPrime (t.prod fun i => s i) x) (∀ (i : I), Membership.mem t i → IsRelPrime (s i) x)","decl":"theorem IsRelPrime.prod_left_iff : IsRelPrime (∏ i ∈ t, s i) x ↔ ∀ i ∈ t, IsRelPrime (s i) x := by\n  classical\n  refine Finset.induction_on t (iff_of_true isRelPrime_one_left fun _ ↦ by simp) fun b t hbt ih ↦ ?_\n  rw [Finset.prod_insert hbt, IsRelPrime.mul_left_iff, ih, Finset.forall_mem_insert]\n\n"}
{"name":"IsRelPrime.prod_right_iff","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"α : Type u_1\nI : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : DecompositionMonoid α\nx : α\ns : I → α\nt : Finset I\n⊢ Iff (IsRelPrime x (t.prod fun i => s i)) (∀ (i : I), Membership.mem t i → IsRelPrime x (s i))","decl":"theorem IsRelPrime.prod_right_iff : IsRelPrime x (∏ i ∈ t, s i) ↔ ∀ i ∈ t, IsRelPrime x (s i) := by\n  simpa only [isRelPrime_comm] using IsRelPrime.prod_left_iff (α := α)\n\n"}
{"name":"IsRelPrime.of_prod_left","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"α : Type u_1\nI : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : DecompositionMonoid α\nx : α\ns : I → α\nt : Finset I\nH1 : IsRelPrime (t.prod fun i => s i) x\ni : I\nhit : Membership.mem t i\n⊢ IsRelPrime (s i) x","decl":"theorem IsRelPrime.of_prod_left (H1 : IsRelPrime (∏ i ∈ t, s i) x) (i : I) (hit : i ∈ t) :\n    IsRelPrime (s i) x :=\n  IsRelPrime.prod_left_iff.1 H1 i hit\n\n"}
{"name":"IsRelPrime.of_prod_right","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"α : Type u_1\nI : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : DecompositionMonoid α\nx : α\ns : I → α\nt : Finset I\nH1 : IsRelPrime x (t.prod fun i => s i)\ni : I\nhit : Membership.mem t i\n⊢ IsRelPrime x (s i)","decl":"theorem IsRelPrime.of_prod_right (H1 : IsRelPrime x (∏ i ∈ t, s i)) (i : I) (hit : i ∈ t) :\n    IsRelPrime x (s i) :=\n  IsRelPrime.prod_right_iff.1 H1 i hit\n\n"}
{"name":"Finset.prod_dvd_of_isRelPrime","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"α : Type u_2\nI : Type u_1\ninst✝¹ : CommMonoid α\ninst✝ : DecompositionMonoid α\nz : α\ns : I → α\nt : Finset I\na✝¹ : (↑t).Pairwise (Function.onFun IsRelPrime s)\na✝ : ∀ (i : I), Membership.mem t i → Dvd.dvd (s i) z\n⊢ Dvd.dvd (t.prod fun x => s x) z","decl":"theorem Finset.prod_dvd_of_isRelPrime :\n    (t : Set I).Pairwise (IsRelPrime on s) → (∀ i ∈ t, s i ∣ z) → (∏ x ∈ t, s x) ∣ z := by\n  classical\n  exact Finset.induction_on t (fun _ _ ↦ one_dvd z)\n    (by\n      intro a r har ih Hs Hs1\n      rw [Finset.prod_insert har]\n      have aux1 : a ∈ (↑(insert a r) : Set I) := Finset.mem_insert_self a r\n      refine\n        (IsRelPrime.prod_right fun i hir ↦\n              Hs aux1 (Finset.mem_insert_of_mem hir) <| by\n                rintro rfl\n                exact har hir).mul_dvd\n          (Hs1 a aux1) (ih (Hs.mono ?_) fun i hi ↦ Hs1 i <| Finset.mem_insert_of_mem hi)\n      simp only [Finset.coe_insert, Set.subset_insert])\n\n"}
{"name":"Fintype.prod_dvd_of_isRelPrime","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"α : Type u_2\nI : Type u_1\ninst✝² : CommMonoid α\ninst✝¹ : DecompositionMonoid α\nz : α\ns : I → α\ninst✝ : Fintype I\nHs : Pairwise (Function.onFun IsRelPrime s)\nHs1 : ∀ (i : I), Dvd.dvd (s i) z\n⊢ Dvd.dvd (Finset.univ.prod fun x => s x) z","decl":"theorem Fintype.prod_dvd_of_isRelPrime [Fintype I] (Hs : Pairwise (IsRelPrime on s))\n    (Hs1 : ∀ i, s i ∣ z) : (∏ x, s x) ∣ z :=\n  Finset.prod_dvd_of_isRelPrime (Hs.set_pairwise _) fun i _ ↦ Hs1 i\n\n"}
{"name":"pairwise_isRelPrime_iff_isRelPrime_prod","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"α : Type u_2\nI : Type u_1\ninst✝² : CommMonoid α\ninst✝¹ : DecompositionMonoid α\ns : I → α\nt : Finset I\ninst✝ : DecidableEq I\n⊢ Iff (Pairwise (Function.onFun IsRelPrime fun i => s ↑i)) (∀ (i : I), Membership.mem t i → IsRelPrime (s i) ((SDiff.sdiff t (Singleton.singleton i)).prod fun j => s j))","decl":"theorem pairwise_isRelPrime_iff_isRelPrime_prod [DecidableEq I] :\n    Pairwise (IsRelPrime on fun i : t ↦ s i) ↔ ∀ i ∈ t, IsRelPrime (s i) (∏ j ∈ t \\ {i}, s j) := by\n  refine ⟨fun hp i hi ↦ IsRelPrime.prod_right_iff.mpr fun j hj ↦ ?_, fun hp ↦ ?_⟩\n  · rw [Finset.mem_sdiff, Finset.mem_singleton] at hj\n    obtain ⟨hj, ji⟩ := hj\n    exact @hp ⟨i, hi⟩ ⟨j, hj⟩ fun h ↦ ji (congrArg Subtype.val h).symm\n  · rintro ⟨i, hi⟩ ⟨j, hj⟩ h\n    apply IsRelPrime.prod_right_iff.mp (hp i hi)\n    exact Finset.mem_sdiff.mpr ⟨hj, fun f ↦ h <| Subtype.ext (Finset.mem_singleton.mp f).symm⟩\n\n"}
{"name":"IsRelPrime.pow_left","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"α : Type u_1\ninst✝¹ : CommMonoid α\ninst✝ : DecompositionMonoid α\nx y : α\nm : Nat\nH : IsRelPrime x y\n⊢ IsRelPrime (HPow.hPow x m) y","decl":"theorem pow_left (H : IsRelPrime x y) : IsRelPrime (x ^ m) y := by\n  rw [← Finset.card_range m, ← Finset.prod_const]\n  exact IsRelPrime.prod_left fun _ _ ↦ H\n\n"}
{"name":"IsRelPrime.pow_right","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"α : Type u_1\ninst✝¹ : CommMonoid α\ninst✝ : DecompositionMonoid α\nx y : α\nn : Nat\nH : IsRelPrime x y\n⊢ IsRelPrime x (HPow.hPow y n)","decl":"theorem pow_right (H : IsRelPrime x y) : IsRelPrime x (y ^ n) := by\n  rw [← Finset.card_range n, ← Finset.prod_const]\n  exact IsRelPrime.prod_right fun _ _ ↦ H\n\n"}
{"name":"IsRelPrime.pow","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"α : Type u_1\ninst✝¹ : CommMonoid α\ninst✝ : DecompositionMonoid α\nx y : α\nm n : Nat\nH : IsRelPrime x y\n⊢ IsRelPrime (HPow.hPow x m) (HPow.hPow y n)","decl":"theorem pow (H : IsRelPrime x y) : IsRelPrime (x ^ m) (y ^ n) :=\n  H.pow_left.pow_right\n\n"}
{"name":"IsRelPrime.pow_left_iff","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"α : Type u_1\ninst✝¹ : CommMonoid α\ninst✝ : DecompositionMonoid α\nx y : α\nm : Nat\nhm : LT.lt 0 m\n⊢ Iff (IsRelPrime (HPow.hPow x m) y) (IsRelPrime x y)","decl":"theorem pow_left_iff (hm : 0 < m) : IsRelPrime (x ^ m) y ↔ IsRelPrime x y := by\n  refine ⟨fun h ↦ ?_, IsRelPrime.pow_left⟩\n  rw [← Finset.card_range m, ← Finset.prod_const] at h\n  exact h.of_prod_left 0 (Finset.mem_range.mpr hm)\n\n"}
{"name":"IsRelPrime.pow_right_iff","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"α : Type u_1\ninst✝¹ : CommMonoid α\ninst✝ : DecompositionMonoid α\nx y : α\nm : Nat\nhm : LT.lt 0 m\n⊢ Iff (IsRelPrime x (HPow.hPow y m)) (IsRelPrime x y)","decl":"theorem pow_right_iff (hm : 0 < m) : IsRelPrime x (y ^ m) ↔ IsRelPrime x y :=\n  isRelPrime_comm.trans <| (IsRelPrime.pow_left_iff hm).trans <| isRelPrime_comm\n\n"}
{"name":"IsRelPrime.pow_iff","module":"Mathlib.RingTheory.Coprime.Lemmas","initialProofState":"α : Type u_1\ninst✝¹ : CommMonoid α\ninst✝ : DecompositionMonoid α\nx y : α\nm n : Nat\nhm : LT.lt 0 m\nhn : LT.lt 0 n\n⊢ Iff (IsRelPrime (HPow.hPow x m) (HPow.hPow y n)) (IsRelPrime x y)","decl":"theorem pow_iff (hm : 0 < m) (hn : 0 < n) :\n    IsRelPrime (x ^ m) (y ^ n) ↔ IsRelPrime x y :=\n  (IsRelPrime.pow_left_iff hm).trans (IsRelPrime.pow_right_iff hn)\n\n"}
