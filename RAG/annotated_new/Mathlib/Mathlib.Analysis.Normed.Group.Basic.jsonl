{"name":"enorm_eq_nnnorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_8\ninst✝ : NNNorm E\nx : E\n⊢ Eq (ENorm.enorm x) ↑(NNNorm.nnnorm x)","decl":"lemma enorm_eq_nnnorm (x : E) : ‖x‖ₑ = ‖x‖₊ := rfl\n\n"}
{"name":"toNNReal_enorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_8\ninst✝ : NNNorm E\nx : E\n⊢ Eq (ENorm.enorm x).toNNReal (NNNorm.nnnorm x)","decl":"@[simp] lemma toNNReal_enorm (x : E) : ‖x‖ₑ.toNNReal = ‖x‖₊ := rfl\n\n"}
{"name":"coe_le_enorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_8\ninst✝ : NNNorm E\nx : E\nr : NNReal\n⊢ Iff (LE.le (↑r) (ENorm.enorm x)) (LE.le r (NNNorm.nnnorm x))","decl":"@[simp, norm_cast] lemma coe_le_enorm : r ≤ ‖x‖ₑ ↔ r ≤ ‖x‖₊ := by simp [enorm]\n"}
{"name":"enorm_le_coe","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_8\ninst✝ : NNNorm E\nx : E\nr : NNReal\n⊢ Iff (LE.le (ENorm.enorm x) ↑r) (LE.le (NNNorm.nnnorm x) r)","decl":"@[simp, norm_cast] lemma enorm_le_coe : ‖x‖ₑ ≤ r ↔ ‖x‖₊ ≤ r := by simp [enorm]\n"}
{"name":"coe_lt_enorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_8\ninst✝ : NNNorm E\nx : E\nr : NNReal\n⊢ Iff (LT.lt (↑r) (ENorm.enorm x)) (LT.lt r (NNNorm.nnnorm x))","decl":"@[simp, norm_cast] lemma coe_lt_enorm : r < ‖x‖ₑ ↔ r < ‖x‖₊ := by simp [enorm]\n"}
{"name":"enorm_lt_coe","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_8\ninst✝ : NNNorm E\nx : E\nr : NNReal\n⊢ Iff (LT.lt (ENorm.enorm x) ↑r) (LT.lt (NNNorm.nnnorm x) r)","decl":"@[simp, norm_cast] lemma enorm_lt_coe : ‖x‖ₑ < r ↔ ‖x‖₊ < r := by simp [enorm]\n\n"}
{"name":"enorm_ne_top","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_8\ninst✝ : NNNorm E\nx : E\n⊢ Ne (ENorm.enorm x) Top.top","decl":"@[simp] lemma enorm_ne_top : ‖x‖ₑ ≠ ∞ := by simp [enorm]\n"}
{"name":"enorm_lt_top","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_8\ninst✝ : NNNorm E\nx : E\n⊢ LT.lt (ENorm.enorm x) Top.top","decl":"@[simp] lemma enorm_lt_top : ‖x‖ₑ < ∞ := by simp [enorm]\n\n"}
{"name":"SeminormedAddGroup.dist_eq","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_8\nself : SeminormedAddGroup E\nx y : E\n⊢ Eq (Dist.dist x y) (Norm.norm (HSub.hSub x y))","decl":"/-- A seminormed group is an additive group endowed with a norm for which `dist x y = ‖x - y‖`\ndefines a pseudometric space structure. -/\nclass SeminormedAddGroup (E : Type*) extends Norm E, AddGroup E, PseudoMetricSpace E where\n  dist := fun x y => ‖x - y‖\n  /-- The distance function is induced by the norm. -/\n  dist_eq : ∀ x y, dist x y = ‖x - y‖ := by aesop\n\n"}
{"name":"SeminormedGroup.dist_eq","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_8\nself : SeminormedGroup E\nx y : E\n⊢ Eq (Dist.dist x y) (Norm.norm (HDiv.hDiv x y))","decl":"/-- A seminormed group is a group endowed with a norm for which `dist x y = ‖x / y‖` defines a\npseudometric space structure. -/\n@[to_additive]\nclass SeminormedGroup (E : Type*) extends Norm E, Group E, PseudoMetricSpace E where\n  dist := fun x y => ‖x / y‖\n  /-- The distance function is induced by the norm. -/\n  dist_eq : ∀ x y, dist x y = ‖x / y‖ := by aesop\n\n"}
{"name":"NormedAddGroup.dist_eq","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_8\nself : NormedAddGroup E\nx y : E\n⊢ Eq (Dist.dist x y) (Norm.norm (HSub.hSub x y))","decl":"/-- A normed group is an additive group endowed with a norm for which `dist x y = ‖x - y‖` defines a\nmetric space structure. -/\nclass NormedAddGroup (E : Type*) extends Norm E, AddGroup E, MetricSpace E where\n  dist := fun x y => ‖x - y‖\n  /-- The distance function is induced by the norm. -/\n  dist_eq : ∀ x y, dist x y = ‖x - y‖ := by aesop\n\n"}
{"name":"NormedGroup.dist_eq","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_8\nself : NormedGroup E\nx y : E\n⊢ Eq (Dist.dist x y) (Norm.norm (HDiv.hDiv x y))","decl":"/-- A normed group is a group endowed with a norm for which `dist x y = ‖x / y‖` defines a metric\nspace structure. -/\n@[to_additive]\nclass NormedGroup (E : Type*) extends Norm E, Group E, MetricSpace E where\n  dist := fun x y => ‖x / y‖\n  /-- The distance function is induced by the norm. -/\n  dist_eq : ∀ x y, dist x y = ‖x / y‖ := by aesop\n\n"}
{"name":"SeminormedAddCommGroup.dist_eq","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_8\nself : SeminormedAddCommGroup E\nx y : E\n⊢ Eq (Dist.dist x y) (Norm.norm (HSub.hSub x y))","decl":"/-- A seminormed group is an additive group endowed with a norm for which `dist x y = ‖x - y‖`\ndefines a pseudometric space structure. -/\nclass SeminormedAddCommGroup (E : Type*) extends Norm E, AddCommGroup E,\n  PseudoMetricSpace E where\n  dist := fun x y => ‖x - y‖\n  /-- The distance function is induced by the norm. -/\n  dist_eq : ∀ x y, dist x y = ‖x - y‖ := by aesop\n\n"}
{"name":"SeminormedCommGroup.dist_eq","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_8\nself : SeminormedCommGroup E\nx y : E\n⊢ Eq (Dist.dist x y) (Norm.norm (HDiv.hDiv x y))","decl":"/-- A seminormed group is a group endowed with a norm for which `dist x y = ‖x / y‖`\ndefines a pseudometric space structure. -/\n@[to_additive]\nclass SeminormedCommGroup (E : Type*) extends Norm E, CommGroup E, PseudoMetricSpace E where\n  dist := fun x y => ‖x / y‖\n  /-- The distance function is induced by the norm. -/\n  dist_eq : ∀ x y, dist x y = ‖x / y‖ := by aesop\n\n"}
{"name":"NormedAddCommGroup.dist_eq","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_8\nself : NormedAddCommGroup E\nx y : E\n⊢ Eq (Dist.dist x y) (Norm.norm (HSub.hSub x y))","decl":"/-- A normed group is an additive group endowed with a norm for which `dist x y = ‖x - y‖` defines a\nmetric space structure. -/\nclass NormedAddCommGroup (E : Type*) extends Norm E, AddCommGroup E, MetricSpace E where\n  dist := fun x y => ‖x - y‖\n  /-- The distance function is induced by the norm. -/\n  dist_eq : ∀ x y, dist x y = ‖x - y‖ := by aesop\n\n"}
{"name":"NormedCommGroup.dist_eq","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_8\nself : NormedCommGroup E\nx y : E\n⊢ Eq (Dist.dist x y) (Norm.norm (HDiv.hDiv x y))","decl":"/-- A normed group is a group endowed with a norm for which `dist x y = ‖x / y‖` defines a metric\nspace structure. -/\n@[to_additive]\nclass NormedCommGroup (E : Type*) extends Norm E, CommGroup E, MetricSpace E where\n  dist := fun x y => ‖x / y‖\n  /-- The distance function is induced by the norm. -/\n  dist_eq : ∀ x y, dist x y = ‖x / y‖ := by aesop\n\n-- See note [lower instance priority]\n"}
{"name":"dist_eq_norm_sub","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ Eq (Dist.dist a b) (Norm.norm (HSub.hSub a b))","decl":"@[to_additive]\ntheorem dist_eq_norm_div (a b : E) : dist a b = ‖a / b‖ :=\n  SeminormedGroup.dist_eq _ _\n\n"}
{"name":"dist_eq_norm_div","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\n⊢ Eq (Dist.dist a b) (Norm.norm (HDiv.hDiv a b))","decl":"@[to_additive]\ntheorem dist_eq_norm_div (a b : E) : dist a b = ‖a / b‖ :=\n  SeminormedGroup.dist_eq _ _\n\n"}
{"name":"dist_eq_norm_sub'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ Eq (Dist.dist a b) (Norm.norm (HSub.hSub b a))","decl":"@[to_additive]\ntheorem dist_eq_norm_div' (a b : E) : dist a b = ‖b / a‖ := by rw [dist_comm, dist_eq_norm_div]\n\n"}
{"name":"dist_eq_norm_div'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\n⊢ Eq (Dist.dist a b) (Norm.norm (HDiv.hDiv b a))","decl":"@[to_additive]\ntheorem dist_eq_norm_div' (a b : E) : dist a b = ‖b / a‖ := by rw [dist_comm, dist_eq_norm_div]\n\n"}
{"name":"dist_eq_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ Eq (Dist.dist a b) (Norm.norm (HSub.hSub a b))","decl":"alias dist_eq_norm := dist_eq_norm_sub\n\n"}
{"name":"dist_eq_norm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ Eq (Dist.dist a b) (Norm.norm (HSub.hSub b a))","decl":"alias dist_eq_norm' := dist_eq_norm_sub'\n\n"}
{"name":"DiscreteTopology.of_forall_le_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nr : Real\nhpos : LT.lt 0 r\nhr : ∀ (x : E), Ne x 0 → LE.le r (Norm.norm x)\n⊢ DiscreteTopology E","decl":"@[to_additive of_forall_le_norm]\nlemma DiscreteTopology.of_forall_le_norm' (hpos : 0 < r) (hr : ∀ x : E, x ≠ 1 → r ≤ ‖x‖) :\n    DiscreteTopology E :=\n  .of_forall_le_dist hpos fun x y hne ↦ by\n    simp only [dist_eq_norm_div]\n    exact hr _ (div_ne_one.2 hne)\n\n"}
{"name":"DiscreteTopology.of_forall_le_norm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nr : Real\nhpos : LT.lt 0 r\nhr : ∀ (x : E), Ne x 1 → LE.le r (Norm.norm x)\n⊢ DiscreteTopology E","decl":"@[to_additive of_forall_le_norm]\nlemma DiscreteTopology.of_forall_le_norm' (hpos : 0 < r) (hr : ∀ x : E, x ≠ 1 → r ≤ ‖x‖) :\n    DiscreteTopology E :=\n  .of_forall_le_dist hpos fun x y hne ↦ by\n    simp only [dist_eq_norm_div]\n    exact hr _ (div_ne_one.2 hne)\n\n"}
{"name":"dist_one_right","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\n⊢ Eq (Dist.dist a 1) (Norm.norm a)","decl":"@[to_additive (attr := simp)]\ntheorem dist_one_right (a : E) : dist a 1 = ‖a‖ := by rw [dist_eq_norm_div, div_one]\n\n"}
{"name":"dist_zero_right","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\n⊢ Eq (Dist.dist a 0) (Norm.norm a)","decl":"@[to_additive (attr := simp)]\ntheorem dist_one_right (a : E) : dist a 1 = ‖a‖ := by rw [dist_eq_norm_div, div_one]\n\n"}
{"name":"inseparable_one_iff_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\n⊢ Iff (Inseparable a 1) (Eq (Norm.norm a) 0)","decl":"@[to_additive]\ntheorem inseparable_one_iff_norm {a : E} : Inseparable a 1 ↔ ‖a‖ = 0 := by\n  rw [Metric.inseparable_iff, dist_one_right]\n\n"}
{"name":"inseparable_zero_iff_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\n⊢ Iff (Inseparable a 0) (Eq (Norm.norm a) 0)","decl":"@[to_additive]\ntheorem inseparable_one_iff_norm {a : E} : Inseparable a 1 ↔ ‖a‖ = 0 := by\n  rw [Metric.inseparable_iff, dist_one_right]\n\n"}
{"name":"dist_zero_left","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\n⊢ Eq (Dist.dist 0 a) (Norm.norm a)","decl":"@[to_additive]\nlemma dist_one_left (a : E) : dist 1 a = ‖a‖ := by rw [dist_comm, dist_one_right]\n\n"}
{"name":"dist_one_left","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\n⊢ Eq (Dist.dist 1 a) (Norm.norm a)","decl":"@[to_additive]\nlemma dist_one_left (a : E) : dist 1 a = ‖a‖ := by rw [dist_comm, dist_one_right]\n\n"}
{"name":"dist_one","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\n⊢ Eq (Dist.dist 1) Norm.norm","decl":"@[to_additive (attr := simp)]\nlemma dist_one : dist (1 : E) = norm := funext dist_one_left\n\n"}
{"name":"dist_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\n⊢ Eq (Dist.dist 0) Norm.norm","decl":"@[to_additive (attr := simp)]\nlemma dist_one : dist (1 : E) = norm := funext dist_one_left\n\n"}
{"name":"norm_sub_rev","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ Eq (Norm.norm (HSub.hSub a b)) (Norm.norm (HSub.hSub b a))","decl":"@[to_additive]\ntheorem norm_div_rev (a b : E) : ‖a / b‖ = ‖b / a‖ := by\n  simpa only [dist_eq_norm_div] using dist_comm a b\n\n"}
{"name":"norm_div_rev","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\n⊢ Eq (Norm.norm (HDiv.hDiv a b)) (Norm.norm (HDiv.hDiv b a))","decl":"@[to_additive]\ntheorem norm_div_rev (a b : E) : ‖a / b‖ = ‖b / a‖ := by\n  simpa only [dist_eq_norm_div] using dist_comm a b\n\n"}
{"name":"norm_neg","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\n⊢ Eq (Norm.norm (Neg.neg a)) (Norm.norm a)","decl":"@[to_additive (attr := simp) norm_neg]\ntheorem norm_inv' (a : E) : ‖a⁻¹‖ = ‖a‖ := by simpa using norm_div_rev 1 a\n\n"}
{"name":"norm_inv'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\n⊢ Eq (Norm.norm (Inv.inv a)) (Norm.norm a)","decl":"@[to_additive (attr := simp) norm_neg]\ntheorem norm_inv' (a : E) : ‖a⁻¹‖ = ‖a‖ := by simpa using norm_div_rev 1 a\n\n"}
{"name":"norm_abs_zsmul","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\nn : Int\n⊢ Eq (Norm.norm (HSMul.hSMul (abs n) a)) (Norm.norm (HSMul.hSMul n a))","decl":"@[to_additive (attr := simp) norm_abs_zsmul]\ntheorem norm_zpow_abs (a : E) (n : ℤ) : ‖a ^ |n|‖ = ‖a ^ n‖ := by\n  rcases le_total 0 n with hn | hn <;> simp [hn, abs_of_nonneg, abs_of_nonpos]\n\n"}
{"name":"norm_zpow_abs","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\nn : Int\n⊢ Eq (Norm.norm (HPow.hPow a (abs n))) (Norm.norm (HPow.hPow a n))","decl":"@[to_additive (attr := simp) norm_abs_zsmul]\ntheorem norm_zpow_abs (a : E) (n : ℤ) : ‖a ^ |n|‖ = ‖a ^ n‖ := by\n  rcases le_total 0 n with hn | hn <;> simp [hn, abs_of_nonneg, abs_of_nonpos]\n\n"}
{"name":"norm_natAbs_smul","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\nn : Int\n⊢ Eq (Norm.norm (HSMul.hSMul n.natAbs a)) (Norm.norm (HSMul.hSMul n a))","decl":"@[to_additive (attr := simp) norm_natAbs_smul]\ntheorem norm_pow_natAbs (a : E) (n : ℤ) : ‖a ^ n.natAbs‖ = ‖a ^ n‖ := by\n  rw [← zpow_natCast, ← Int.abs_eq_natAbs, norm_zpow_abs]\n\n"}
{"name":"norm_pow_natAbs","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\nn : Int\n⊢ Eq (Norm.norm (HPow.hPow a n.natAbs)) (Norm.norm (HPow.hPow a n))","decl":"@[to_additive (attr := simp) norm_natAbs_smul]\ntheorem norm_pow_natAbs (a : E) (n : ℤ) : ‖a ^ n.natAbs‖ = ‖a ^ n‖ := by\n  rw [← zpow_natCast, ← Int.abs_eq_natAbs, norm_zpow_abs]\n\n"}
{"name":"norm_isUnit_zsmul","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\nn : Int\nhn : IsUnit n\n⊢ Eq (Norm.norm (HSMul.hSMul n a)) (Norm.norm a)","decl":"@[to_additive norm_isUnit_zsmul]\ntheorem norm_zpow_isUnit (a : E) {n : ℤ} (hn : IsUnit n) : ‖a ^ n‖ = ‖a‖ := by\n  rw [← norm_pow_natAbs, Int.isUnit_iff_natAbs_eq.mp hn, pow_one]\n\n"}
{"name":"norm_zpow_isUnit","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\nn : Int\nhn : IsUnit n\n⊢ Eq (Norm.norm (HPow.hPow a n)) (Norm.norm a)","decl":"@[to_additive norm_isUnit_zsmul]\ntheorem norm_zpow_isUnit (a : E) {n : ℤ} (hn : IsUnit n) : ‖a ^ n‖ = ‖a‖ := by\n  rw [← norm_pow_natAbs, Int.isUnit_iff_natAbs_eq.mp hn, pow_one]\n\n"}
{"name":"norm_units_zsmul","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_8\ninst✝ : SeminormedAddGroup E\nn : Units Int\na : E\n⊢ Eq (Norm.norm (HSMul.hSMul n a)) (Norm.norm a)","decl":"@[simp]\ntheorem norm_units_zsmul {E : Type*} [SeminormedAddGroup E] (n : ℤˣ) (a : E) : ‖n • a‖ = ‖a‖ :=\n  norm_isUnit_zsmul a n.isUnit\n\n"}
{"name":"dist_indicator","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝ : SeminormedAddGroup E\ns t : Set α\nf : α → E\nx : α\n⊢ Eq (Dist.dist (s.indicator f x) (t.indicator f x)) (Norm.norm ((symmDiff s t).indicator f x))","decl":"open scoped symmDiff in\n@[to_additive]\ntheorem dist_mulIndicator (s t : Set α) (f : α → E) (x : α) :\n    dist (s.mulIndicator f x) (t.mulIndicator f x) = ‖(s ∆ t).mulIndicator f x‖ := by\n  rw [dist_eq_norm_div, Set.apply_mulIndicator_symmDiff norm_inv']\n\n"}
{"name":"dist_mulIndicator","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝ : SeminormedGroup E\ns t : Set α\nf : α → E\nx : α\n⊢ Eq (Dist.dist (s.mulIndicator f x) (t.mulIndicator f x)) (Norm.norm ((symmDiff s t).mulIndicator f x))","decl":"open scoped symmDiff in\n@[to_additive]\ntheorem dist_mulIndicator (s t : Set α) (f : α → E) (x : α) :\n    dist (s.mulIndicator f x) (t.mulIndicator f x) = ‖(s ∆ t).mulIndicator f x‖ := by\n  rw [dist_eq_norm_div, Set.apply_mulIndicator_symmDiff norm_inv']\n\n"}
{"name":"norm_mul_le'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\n⊢ LE.le (Norm.norm (HMul.hMul a b)) (HAdd.hAdd (Norm.norm a) (Norm.norm b))","decl":"/-- **Triangle inequality** for the norm. -/\n@[to_additive norm_add_le \"**Triangle inequality** for the norm.\"]\ntheorem norm_mul_le' (a b : E) : ‖a * b‖ ≤ ‖a‖ + ‖b‖ := by\n  simpa [dist_eq_norm_div] using dist_triangle a 1 b⁻¹\n\n"}
{"name":"norm_add_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ LE.le (Norm.norm (HAdd.hAdd a b)) (HAdd.hAdd (Norm.norm a) (Norm.norm b))","decl":"/-- **Triangle inequality** for the norm. -/\n@[to_additive norm_add_le \"**Triangle inequality** for the norm.\"]\ntheorem norm_mul_le' (a b : E) : ‖a * b‖ ≤ ‖a‖ + ‖b‖ := by\n  simpa [dist_eq_norm_div] using dist_triangle a 1 b⁻¹\n\n"}
{"name":"norm_mul_le_of_le'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na₁ a₂ : E\nr₁ r₂ : Real\nh₁ : LE.le (Norm.norm a₁) r₁\nh₂ : LE.le (Norm.norm a₂) r₂\n⊢ LE.le (Norm.norm (HMul.hMul a₁ a₂)) (HAdd.hAdd r₁ r₂)","decl":"/-- **Triangle inequality** for the norm. -/\n@[to_additive norm_add_le_of_le \"**Triangle inequality** for the norm.\"]\ntheorem norm_mul_le_of_le' (h₁ : ‖a₁‖ ≤ r₁) (h₂ : ‖a₂‖ ≤ r₂) : ‖a₁ * a₂‖ ≤ r₁ + r₂ :=\n  (norm_mul_le' a₁ a₂).trans <| add_le_add h₁ h₂\n\n"}
{"name":"norm_add_le_of_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na₁ a₂ : E\nr₁ r₂ : Real\nh₁ : LE.le (Norm.norm a₁) r₁\nh₂ : LE.le (Norm.norm a₂) r₂\n⊢ LE.le (Norm.norm (HAdd.hAdd a₁ a₂)) (HAdd.hAdd r₁ r₂)","decl":"/-- **Triangle inequality** for the norm. -/\n@[to_additive norm_add_le_of_le \"**Triangle inequality** for the norm.\"]\ntheorem norm_mul_le_of_le' (h₁ : ‖a₁‖ ≤ r₁) (h₂ : ‖a₂‖ ≤ r₂) : ‖a₁ * a₂‖ ≤ r₁ + r₂ :=\n  (norm_mul_le' a₁ a₂).trans <| add_le_add h₁ h₂\n\n"}
{"name":"norm_mul₃_le'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b c : E\n⊢ LE.le (Norm.norm (HMul.hMul (HMul.hMul a b) c)) (HAdd.hAdd (HAdd.hAdd (Norm.norm a) (Norm.norm b)) (Norm.norm c))","decl":"/-- **Triangle inequality** for the norm. -/\n@[to_additive norm_add₃_le \"**Triangle inequality** for the norm.\"]\nlemma norm_mul₃_le' : ‖a * b * c‖ ≤ ‖a‖ + ‖b‖ + ‖c‖ := norm_mul_le_of_le' (norm_mul_le' _ _) le_rfl\n\n"}
{"name":"norm_add₃_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b c : E\n⊢ LE.le (Norm.norm (HAdd.hAdd (HAdd.hAdd a b) c)) (HAdd.hAdd (HAdd.hAdd (Norm.norm a) (Norm.norm b)) (Norm.norm c))","decl":"/-- **Triangle inequality** for the norm. -/\n@[to_additive norm_add₃_le \"**Triangle inequality** for the norm.\"]\nlemma norm_mul₃_le' : ‖a * b * c‖ ≤ ‖a‖ + ‖b‖ + ‖c‖ := norm_mul_le_of_le' (norm_mul_le' _ _) le_rfl\n\n"}
{"name":"norm_sub_le_norm_sub_add_norm_sub","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b c : E\n⊢ LE.le (Norm.norm (HSub.hSub a c)) (HAdd.hAdd (Norm.norm (HSub.hSub a b)) (Norm.norm (HSub.hSub b c)))","decl":"@[to_additive]\nlemma norm_div_le_norm_div_add_norm_div (a b c : E) : ‖a / c‖ ≤ ‖a / b‖ + ‖b / c‖ := by\n  simpa only [dist_eq_norm_div] using dist_triangle a b c\n\n"}
{"name":"norm_div_le_norm_div_add_norm_div","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b c : E\n⊢ LE.le (Norm.norm (HDiv.hDiv a c)) (HAdd.hAdd (Norm.norm (HDiv.hDiv a b)) (Norm.norm (HDiv.hDiv b c)))","decl":"@[to_additive]\nlemma norm_div_le_norm_div_add_norm_div (a b c : E) : ‖a / c‖ ≤ ‖a / b‖ + ‖b / c‖ := by\n  simpa only [dist_eq_norm_div] using dist_triangle a b c\n\n"}
{"name":"norm_nonneg'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\n⊢ LE.le 0 (Norm.norm a)","decl":"@[to_additive (attr := simp) norm_nonneg]\ntheorem norm_nonneg' (a : E) : 0 ≤ ‖a‖ := by\n  rw [← dist_one_right]\n  exact dist_nonneg\n\n"}
{"name":"norm_nonneg","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\n⊢ LE.le 0 (Norm.norm a)","decl":"@[to_additive (attr := simp) norm_nonneg]\ntheorem norm_nonneg' (a : E) : 0 ≤ ‖a‖ := by\n  rw [← dist_one_right]\n  exact dist_nonneg\n\n"}
{"name":"abs_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nz : E\n⊢ Eq (abs (Norm.norm z)) (Norm.norm z)","decl":"@[to_additive (attr := simp) abs_norm]\ntheorem abs_norm' (z : E) : |‖z‖| = ‖z‖ := abs_of_nonneg <| norm_nonneg' _\n\n"}
{"name":"abs_norm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nz : E\n⊢ Eq (abs (Norm.norm z)) (Norm.norm z)","decl":"@[to_additive (attr := simp) abs_norm]\ntheorem abs_norm' (z : E) : |‖z‖| = ‖z‖ := abs_of_nonneg <| norm_nonneg' _\n\n"}
{"name":"norm_one'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\n⊢ Eq (Norm.norm 1) 0","decl":"@[to_additive (attr := simp) norm_zero]\ntheorem norm_one' : ‖(1 : E)‖ = 0 := by rw [← dist_one_right, dist_self]\n\n"}
{"name":"norm_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\n⊢ Eq (Norm.norm 0) 0","decl":"@[to_additive (attr := simp) norm_zero]\ntheorem norm_one' : ‖(1 : E)‖ = 0 := by rw [← dist_one_right, dist_self]\n\n"}
{"name":"ne_one_of_norm_ne_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\na✝ : Ne (Norm.norm a) 0\n⊢ Ne a 1","decl":"@[to_additive]\ntheorem ne_one_of_norm_ne_zero : ‖a‖ ≠ 0 → a ≠ 1 :=\n  mt <| by\n    rintro rfl\n    exact norm_one'\n\n"}
{"name":"ne_zero_of_norm_ne_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\na✝ : Ne (Norm.norm a) 0\n⊢ Ne a 0","decl":"@[to_additive]\ntheorem ne_one_of_norm_ne_zero : ‖a‖ ≠ 0 → a ≠ 1 :=\n  mt <| by\n    rintro rfl\n    exact norm_one'\n\n"}
{"name":"norm_of_subsingleton'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝¹ : SeminormedGroup E\ninst✝ : Subsingleton E\na : E\n⊢ Eq (Norm.norm a) 0","decl":"@[to_additive (attr := nontriviality) norm_of_subsingleton]\ntheorem norm_of_subsingleton' [Subsingleton E] (a : E) : ‖a‖ = 0 := by\n  rw [Subsingleton.elim a 1, norm_one']\n\n"}
{"name":"norm_of_subsingleton","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝¹ : SeminormedAddGroup E\ninst✝ : Subsingleton E\na : E\n⊢ Eq (Norm.norm a) 0","decl":"@[to_additive (attr := nontriviality) norm_of_subsingleton]\ntheorem norm_of_subsingleton' [Subsingleton E] (a : E) : ‖a‖ = 0 := by\n  rw [Subsingleton.elim a 1, norm_one']\n\n"}
{"name":"zero_lt_one_add_norm_sq'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nx : E\n⊢ LT.lt 0 (HAdd.hAdd 1 (HPow.hPow (Norm.norm x) 2))","decl":"@[to_additive zero_lt_one_add_norm_sq]\ntheorem zero_lt_one_add_norm_sq' (x : E) : 0 < 1 + ‖x‖ ^ 2 := by\n  positivity\n\n"}
{"name":"zero_lt_one_add_norm_sq","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nx : E\n⊢ LT.lt 0 (HAdd.hAdd 1 (HPow.hPow (Norm.norm x) 2))","decl":"@[to_additive zero_lt_one_add_norm_sq]\ntheorem zero_lt_one_add_norm_sq' (x : E) : 0 < 1 + ‖x‖ ^ 2 := by\n  positivity\n\n"}
{"name":"norm_sub_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ LE.le (Norm.norm (HSub.hSub a b)) (HAdd.hAdd (Norm.norm a) (Norm.norm b))","decl":"@[to_additive]\ntheorem norm_div_le (a b : E) : ‖a / b‖ ≤ ‖a‖ + ‖b‖ := by\n  simpa [dist_eq_norm_div] using dist_triangle a 1 b\n\n"}
{"name":"norm_div_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\n⊢ LE.le (Norm.norm (HDiv.hDiv a b)) (HAdd.hAdd (Norm.norm a) (Norm.norm b))","decl":"@[to_additive]\ntheorem norm_div_le (a b : E) : ‖a / b‖ ≤ ‖a‖ + ‖b‖ := by\n  simpa [dist_eq_norm_div] using dist_triangle a 1 b\n\n"}
{"name":"norm_div_le_of_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na₁ a₂ : E\nr₁ r₂ : Real\nH₁ : LE.le (Norm.norm a₁) r₁\nH₂ : LE.le (Norm.norm a₂) r₂\n⊢ LE.le (Norm.norm (HDiv.hDiv a₁ a₂)) (HAdd.hAdd r₁ r₂)","decl":"@[to_additive]\ntheorem norm_div_le_of_le {r₁ r₂ : ℝ} (H₁ : ‖a₁‖ ≤ r₁) (H₂ : ‖a₂‖ ≤ r₂) : ‖a₁ / a₂‖ ≤ r₁ + r₂ :=\n  (norm_div_le a₁ a₂).trans <| add_le_add H₁ H₂\n\n"}
{"name":"norm_sub_le_of_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na₁ a₂ : E\nr₁ r₂ : Real\nH₁ : LE.le (Norm.norm a₁) r₁\nH₂ : LE.le (Norm.norm a₂) r₂\n⊢ LE.le (Norm.norm (HSub.hSub a₁ a₂)) (HAdd.hAdd r₁ r₂)","decl":"@[to_additive]\ntheorem norm_div_le_of_le {r₁ r₂ : ℝ} (H₁ : ‖a₁‖ ≤ r₁) (H₂ : ‖a₂‖ ≤ r₂) : ‖a₁ / a₂‖ ≤ r₁ + r₂ :=\n  (norm_div_le a₁ a₂).trans <| add_le_add H₁ H₂\n\n"}
{"name":"dist_le_norm_add_norm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\n⊢ LE.le (Dist.dist a b) (HAdd.hAdd (Norm.norm a) (Norm.norm b))","decl":"@[to_additive dist_le_norm_add_norm]\ntheorem dist_le_norm_add_norm' (a b : E) : dist a b ≤ ‖a‖ + ‖b‖ := by\n  rw [dist_eq_norm_div]\n  apply norm_div_le\n\n"}
{"name":"dist_le_norm_add_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ LE.le (Dist.dist a b) (HAdd.hAdd (Norm.norm a) (Norm.norm b))","decl":"@[to_additive dist_le_norm_add_norm]\ntheorem dist_le_norm_add_norm' (a b : E) : dist a b ≤ ‖a‖ + ‖b‖ := by\n  rw [dist_eq_norm_div]\n  apply norm_div_le\n\n"}
{"name":"abs_norm_sub_norm_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ LE.le (abs (HSub.hSub (Norm.norm a) (Norm.norm b))) (Norm.norm (HSub.hSub a b))","decl":"@[to_additive abs_norm_sub_norm_le]\ntheorem abs_norm_sub_norm_le' (a b : E) : |‖a‖ - ‖b‖| ≤ ‖a / b‖ := by\n  simpa [dist_eq_norm_div] using abs_dist_sub_le a b 1\n\n"}
{"name":"abs_norm_sub_norm_le'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\n⊢ LE.le (abs (HSub.hSub (Norm.norm a) (Norm.norm b))) (Norm.norm (HDiv.hDiv a b))","decl":"@[to_additive abs_norm_sub_norm_le]\ntheorem abs_norm_sub_norm_le' (a b : E) : |‖a‖ - ‖b‖| ≤ ‖a / b‖ := by\n  simpa [dist_eq_norm_div] using abs_dist_sub_le a b 1\n\n"}
{"name":"norm_sub_norm_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ LE.le (HSub.hSub (Norm.norm a) (Norm.norm b)) (Norm.norm (HSub.hSub a b))","decl":"@[to_additive norm_sub_norm_le]\ntheorem norm_sub_norm_le' (a b : E) : ‖a‖ - ‖b‖ ≤ ‖a / b‖ :=\n  (le_abs_self _).trans (abs_norm_sub_norm_le' a b)\n\n"}
{"name":"norm_sub_norm_le'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\n⊢ LE.le (HSub.hSub (Norm.norm a) (Norm.norm b)) (Norm.norm (HDiv.hDiv a b))","decl":"@[to_additive norm_sub_norm_le]\ntheorem norm_sub_norm_le' (a b : E) : ‖a‖ - ‖b‖ ≤ ‖a / b‖ :=\n  (le_abs_self _).trans (abs_norm_sub_norm_le' a b)\n\n"}
{"name":"dist_norm_norm_le'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\n⊢ LE.le (Dist.dist (Norm.norm a) (Norm.norm b)) (Norm.norm (HDiv.hDiv a b))","decl":"@[to_additive dist_norm_norm_le]\ntheorem dist_norm_norm_le' (a b : E) : dist ‖a‖ ‖b‖ ≤ ‖a / b‖ :=\n  abs_norm_sub_norm_le' a b\n\n"}
{"name":"dist_norm_norm_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ LE.le (Dist.dist (Norm.norm a) (Norm.norm b)) (Norm.norm (HSub.hSub a b))","decl":"@[to_additive dist_norm_norm_le]\ntheorem dist_norm_norm_le' (a b : E) : dist ‖a‖ ‖b‖ ≤ ‖a / b‖ :=\n  abs_norm_sub_norm_le' a b\n\n"}
{"name":"norm_le_norm_add_norm_div'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nu v : E\n⊢ LE.le (Norm.norm u) (HAdd.hAdd (Norm.norm v) (Norm.norm (HDiv.hDiv u v)))","decl":"@[to_additive]\ntheorem norm_le_norm_add_norm_div' (u v : E) : ‖u‖ ≤ ‖v‖ + ‖u / v‖ := by\n  rw [add_comm]\n  refine (norm_mul_le' _ _).trans_eq' ?_\n  rw [div_mul_cancel]\n\n"}
{"name":"norm_le_norm_add_norm_sub'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nu v : E\n⊢ LE.le (Norm.norm u) (HAdd.hAdd (Norm.norm v) (Norm.norm (HSub.hSub u v)))","decl":"@[to_additive]\ntheorem norm_le_norm_add_norm_div' (u v : E) : ‖u‖ ≤ ‖v‖ + ‖u / v‖ := by\n  rw [add_comm]\n  refine (norm_mul_le' _ _).trans_eq' ?_\n  rw [div_mul_cancel]\n\n"}
{"name":"norm_le_norm_add_norm_sub","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nu v : E\n⊢ LE.le (Norm.norm v) (HAdd.hAdd (Norm.norm u) (Norm.norm (HSub.hSub u v)))","decl":"@[to_additive]\ntheorem norm_le_norm_add_norm_div (u v : E) : ‖v‖ ≤ ‖u‖ + ‖u / v‖ := by\n  rw [norm_div_rev]\n  exact norm_le_norm_add_norm_div' v u\n\n"}
{"name":"norm_le_norm_add_norm_div","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nu v : E\n⊢ LE.le (Norm.norm v) (HAdd.hAdd (Norm.norm u) (Norm.norm (HDiv.hDiv u v)))","decl":"@[to_additive]\ntheorem norm_le_norm_add_norm_div (u v : E) : ‖v‖ ≤ ‖u‖ + ‖u / v‖ := by\n  rw [norm_div_rev]\n  exact norm_le_norm_add_norm_div' v u\n\n"}
{"name":"norm_le_insert'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nu v : E\n⊢ LE.le (Norm.norm u) (HAdd.hAdd (Norm.norm v) (Norm.norm (HSub.hSub u v)))","decl":"alias norm_le_insert' := norm_le_norm_add_norm_sub'\n"}
{"name":"norm_le_insert","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nu v : E\n⊢ LE.le (Norm.norm v) (HAdd.hAdd (Norm.norm u) (Norm.norm (HSub.hSub u v)))","decl":"alias norm_le_insert := norm_le_norm_add_norm_sub\n\n"}
{"name":"norm_le_add_norm_add","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nu v : E\n⊢ LE.le (Norm.norm u) (HAdd.hAdd (Norm.norm (HAdd.hAdd u v)) (Norm.norm v))","decl":"@[to_additive]\ntheorem norm_le_mul_norm_add (u v : E) : ‖u‖ ≤ ‖u * v‖ + ‖v‖ :=\n  calc\n    ‖u‖ = ‖u * v / v‖ := by rw [mul_div_cancel_right]\n    _ ≤ ‖u * v‖ + ‖v‖ := norm_div_le _ _\n\n"}
{"name":"norm_le_mul_norm_add","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nu v : E\n⊢ LE.le (Norm.norm u) (HAdd.hAdd (Norm.norm (HMul.hMul u v)) (Norm.norm v))","decl":"@[to_additive]\ntheorem norm_le_mul_norm_add (u v : E) : ‖u‖ ≤ ‖u * v‖ + ‖v‖ :=\n  calc\n    ‖u‖ = ‖u * v / v‖ := by rw [mul_div_cancel_right]\n    _ ≤ ‖u * v‖ + ‖v‖ := norm_div_le _ _\n\n"}
{"name":"norm_le_mul_norm_add'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nu v : E\n⊢ LE.le (Norm.norm v) (HAdd.hAdd (Norm.norm (HMul.hMul u v)) (Norm.norm u))","decl":"/-- An analogue of `norm_le_mul_norm_add` for the multiplication from the left. -/\n@[to_additive \"An analogue of `norm_le_add_norm_add` for the addition from the left.\"]\ntheorem norm_le_mul_norm_add' (u v : E) : ‖v‖ ≤ ‖u * v‖ + ‖u‖ :=\n  calc\n    ‖v‖ = ‖u⁻¹ * (u * v)‖ := by rw [← mul_assoc, inv_mul_cancel, one_mul]\n    _ ≤ ‖u⁻¹‖ + ‖u * v‖ := norm_mul_le' u⁻¹ (u * v)\n    _ = ‖u * v‖ + ‖u‖ := by rw [norm_inv', add_comm]\n\n"}
{"name":"norm_le_add_norm_add'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nu v : E\n⊢ LE.le (Norm.norm v) (HAdd.hAdd (Norm.norm (HAdd.hAdd u v)) (Norm.norm u))","decl":"/-- An analogue of `norm_le_mul_norm_add` for the multiplication from the left. -/\n@[to_additive \"An analogue of `norm_le_add_norm_add` for the addition from the left.\"]\ntheorem norm_le_mul_norm_add' (u v : E) : ‖v‖ ≤ ‖u * v‖ + ‖u‖ :=\n  calc\n    ‖v‖ = ‖u⁻¹ * (u * v)‖ := by rw [← mul_assoc, inv_mul_cancel, one_mul]\n    _ ≤ ‖u⁻¹‖ + ‖u * v‖ := norm_mul_le' u⁻¹ (u * v)\n    _ = ‖u * v‖ + ‖u‖ := by rw [norm_inv', add_comm]\n\n"}
{"name":"norm_mul_eq_norm_right","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nx y : E\nh : Eq (Norm.norm x) 0\n⊢ Eq (Norm.norm (HMul.hMul x y)) (Norm.norm y)","decl":"@[to_additive]\nlemma norm_mul_eq_norm_right {x : E} (y : E) (h : ‖x‖ = 0) : ‖x * y‖ = ‖y‖ := by\n  apply le_antisymm ?_ ?_\n  · simpa [h] using norm_mul_le' x y\n  · simpa [h] using norm_le_mul_norm_add' x y\n\n"}
{"name":"norm_add_eq_norm_right","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nx y : E\nh : Eq (Norm.norm x) 0\n⊢ Eq (Norm.norm (HAdd.hAdd x y)) (Norm.norm y)","decl":"@[to_additive]\nlemma norm_mul_eq_norm_right {x : E} (y : E) (h : ‖x‖ = 0) : ‖x * y‖ = ‖y‖ := by\n  apply le_antisymm ?_ ?_\n  · simpa [h] using norm_mul_le' x y\n  · simpa [h] using norm_le_mul_norm_add' x y\n\n"}
{"name":"norm_mul_eq_norm_left","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nx y : E\nh : Eq (Norm.norm y) 0\n⊢ Eq (Norm.norm (HMul.hMul x y)) (Norm.norm x)","decl":"@[to_additive]\nlemma norm_mul_eq_norm_left (x : E) {y : E} (h : ‖y‖ = 0) : ‖x * y‖ = ‖x‖ := by\n  apply le_antisymm ?_ ?_\n  · simpa [h] using norm_mul_le' x y\n  · simpa [h] using norm_le_mul_norm_add x y\n\n"}
{"name":"norm_add_eq_norm_left","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nx y : E\nh : Eq (Norm.norm y) 0\n⊢ Eq (Norm.norm (HAdd.hAdd x y)) (Norm.norm x)","decl":"@[to_additive]\nlemma norm_mul_eq_norm_left (x : E) {y : E} (h : ‖y‖ = 0) : ‖x * y‖ = ‖x‖ := by\n  apply le_antisymm ?_ ?_\n  · simpa [h] using norm_mul_le' x y\n  · simpa [h] using norm_le_mul_norm_add x y\n\n"}
{"name":"norm_sub_eq_norm_right","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nx y : E\nh : Eq (Norm.norm x) 0\n⊢ Eq (Norm.norm (HSub.hSub x y)) (Norm.norm y)","decl":"@[to_additive]\nlemma norm_div_eq_norm_right {x : E} (y : E) (h : ‖x‖ = 0) : ‖x / y‖ = ‖y‖ := by\n  apply le_antisymm ?_ ?_\n  · simpa [h] using norm_div_le x y\n  · simpa [h, norm_div_rev x y] using norm_sub_norm_le' y x\n\n"}
{"name":"norm_div_eq_norm_right","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nx y : E\nh : Eq (Norm.norm x) 0\n⊢ Eq (Norm.norm (HDiv.hDiv x y)) (Norm.norm y)","decl":"@[to_additive]\nlemma norm_div_eq_norm_right {x : E} (y : E) (h : ‖x‖ = 0) : ‖x / y‖ = ‖y‖ := by\n  apply le_antisymm ?_ ?_\n  · simpa [h] using norm_div_le x y\n  · simpa [h, norm_div_rev x y] using norm_sub_norm_le' y x\n\n"}
{"name":"norm_div_eq_norm_left","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nx y : E\nh : Eq (Norm.norm y) 0\n⊢ Eq (Norm.norm (HDiv.hDiv x y)) (Norm.norm x)","decl":"@[to_additive]\nlemma norm_div_eq_norm_left (x : E) {y : E} (h : ‖y‖ = 0) : ‖x / y‖ = ‖x‖ := by\n  apply le_antisymm ?_ ?_\n  · simpa [h] using norm_div_le x y\n  · simpa [h] using norm_sub_norm_le' x y\n\n"}
{"name":"norm_sub_eq_norm_left","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nx y : E\nh : Eq (Norm.norm y) 0\n⊢ Eq (Norm.norm (HSub.hSub x y)) (Norm.norm x)","decl":"@[to_additive]\nlemma norm_div_eq_norm_left (x : E) {y : E} (h : ‖y‖ = 0) : ‖x / y‖ = ‖x‖ := by\n  apply le_antisymm ?_ ?_\n  · simpa [h] using norm_div_le x y\n  · simpa [h] using norm_sub_norm_le' x y\n\n"}
{"name":"ball_eq","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\ny : E\nε : Real\n⊢ Eq (Metric.ball y ε) (setOf fun x => LT.lt (Norm.norm (HSub.hSub x y)) ε)","decl":"@[to_additive ball_eq]\ntheorem ball_eq' (y : E) (ε : ℝ) : ball y ε = { x | ‖x / y‖ < ε } :=\n  Set.ext fun a => by simp [dist_eq_norm_div]\n\n"}
{"name":"ball_eq'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\ny : E\nε : Real\n⊢ Eq (Metric.ball y ε) (setOf fun x => LT.lt (Norm.norm (HDiv.hDiv x y)) ε)","decl":"@[to_additive ball_eq]\ntheorem ball_eq' (y : E) (ε : ℝ) : ball y ε = { x | ‖x / y‖ < ε } :=\n  Set.ext fun a => by simp [dist_eq_norm_div]\n\n"}
{"name":"ball_one_eq","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nr : Real\n⊢ Eq (Metric.ball 1 r) (setOf fun x => LT.lt (Norm.norm x) r)","decl":"@[to_additive]\ntheorem ball_one_eq (r : ℝ) : ball (1 : E) r = { x | ‖x‖ < r } :=\n  Set.ext fun a => by simp\n\n"}
{"name":"ball_zero_eq","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nr : Real\n⊢ Eq (Metric.ball 0 r) (setOf fun x => LT.lt (Norm.norm x) r)","decl":"@[to_additive]\ntheorem ball_one_eq (r : ℝ) : ball (1 : E) r = { x | ‖x‖ < r } :=\n  Set.ext fun a => by simp\n\n"}
{"name":"mem_ball_iff_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\nr : Real\n⊢ Iff (Membership.mem (Metric.ball a r) b) (LT.lt (Norm.norm (HSub.hSub b a)) r)","decl":"@[to_additive mem_ball_iff_norm]\ntheorem mem_ball_iff_norm'' : b ∈ ball a r ↔ ‖b / a‖ < r := by rw [mem_ball, dist_eq_norm_div]\n\n"}
{"name":"mem_ball_iff_norm''","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\nr : Real\n⊢ Iff (Membership.mem (Metric.ball a r) b) (LT.lt (Norm.norm (HDiv.hDiv b a)) r)","decl":"@[to_additive mem_ball_iff_norm]\ntheorem mem_ball_iff_norm'' : b ∈ ball a r ↔ ‖b / a‖ < r := by rw [mem_ball, dist_eq_norm_div]\n\n"}
{"name":"mem_ball_iff_norm'''","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\nr : Real\n⊢ Iff (Membership.mem (Metric.ball a r) b) (LT.lt (Norm.norm (HDiv.hDiv a b)) r)","decl":"@[to_additive mem_ball_iff_norm']\ntheorem mem_ball_iff_norm''' : b ∈ ball a r ↔ ‖a / b‖ < r := by rw [mem_ball', dist_eq_norm_div]\n\n"}
{"name":"mem_ball_iff_norm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\nr : Real\n⊢ Iff (Membership.mem (Metric.ball a r) b) (LT.lt (Norm.norm (HSub.hSub a b)) r)","decl":"@[to_additive mem_ball_iff_norm']\ntheorem mem_ball_iff_norm''' : b ∈ ball a r ↔ ‖a / b‖ < r := by rw [mem_ball', dist_eq_norm_div]\n\n"}
{"name":"mem_ball_zero_iff","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\nr : Real\n⊢ Iff (Membership.mem (Metric.ball 0 r) a) (LT.lt (Norm.norm a) r)","decl":"@[to_additive]\ntheorem mem_ball_one_iff : a ∈ ball (1 : E) r ↔ ‖a‖ < r := by rw [mem_ball, dist_one_right]\n\n"}
{"name":"mem_ball_one_iff","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\nr : Real\n⊢ Iff (Membership.mem (Metric.ball 1 r) a) (LT.lt (Norm.norm a) r)","decl":"@[to_additive]\ntheorem mem_ball_one_iff : a ∈ ball (1 : E) r ↔ ‖a‖ < r := by rw [mem_ball, dist_one_right]\n\n"}
{"name":"mem_closedBall_iff_norm''","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\nr : Real\n⊢ Iff (Membership.mem (Metric.closedBall a r) b) (LE.le (Norm.norm (HDiv.hDiv b a)) r)","decl":"@[to_additive mem_closedBall_iff_norm]\ntheorem mem_closedBall_iff_norm'' : b ∈ closedBall a r ↔ ‖b / a‖ ≤ r := by\n  rw [mem_closedBall, dist_eq_norm_div]\n\n"}
{"name":"mem_closedBall_iff_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\nr : Real\n⊢ Iff (Membership.mem (Metric.closedBall a r) b) (LE.le (Norm.norm (HSub.hSub b a)) r)","decl":"@[to_additive mem_closedBall_iff_norm]\ntheorem mem_closedBall_iff_norm'' : b ∈ closedBall a r ↔ ‖b / a‖ ≤ r := by\n  rw [mem_closedBall, dist_eq_norm_div]\n\n"}
{"name":"mem_closedBall_one_iff","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\nr : Real\n⊢ Iff (Membership.mem (Metric.closedBall 1 r) a) (LE.le (Norm.norm a) r)","decl":"@[to_additive]\ntheorem mem_closedBall_one_iff : a ∈ closedBall (1 : E) r ↔ ‖a‖ ≤ r := by\n  rw [mem_closedBall, dist_one_right]\n\n"}
{"name":"mem_closedBall_zero_iff","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\nr : Real\n⊢ Iff (Membership.mem (Metric.closedBall 0 r) a) (LE.le (Norm.norm a) r)","decl":"@[to_additive]\ntheorem mem_closedBall_one_iff : a ∈ closedBall (1 : E) r ↔ ‖a‖ ≤ r := by\n  rw [mem_closedBall, dist_one_right]\n\n"}
{"name":"mem_closedBall_iff_norm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\nr : Real\n⊢ Iff (Membership.mem (Metric.closedBall a r) b) (LE.le (Norm.norm (HSub.hSub a b)) r)","decl":"@[to_additive mem_closedBall_iff_norm']\ntheorem mem_closedBall_iff_norm''' : b ∈ closedBall a r ↔ ‖a / b‖ ≤ r := by\n  rw [mem_closedBall', dist_eq_norm_div]\n\n"}
{"name":"mem_closedBall_iff_norm'''","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\nr : Real\n⊢ Iff (Membership.mem (Metric.closedBall a r) b) (LE.le (Norm.norm (HDiv.hDiv a b)) r)","decl":"@[to_additive mem_closedBall_iff_norm']\ntheorem mem_closedBall_iff_norm''' : b ∈ closedBall a r ↔ ‖a / b‖ ≤ r := by\n  rw [mem_closedBall', dist_eq_norm_div]\n\n"}
{"name":"norm_le_of_mem_closedBall'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\nr : Real\nh : Membership.mem (Metric.closedBall a r) b\n⊢ LE.le (Norm.norm b) (HAdd.hAdd (Norm.norm a) r)","decl":"@[to_additive norm_le_of_mem_closedBall]\ntheorem norm_le_of_mem_closedBall' (h : b ∈ closedBall a r) : ‖b‖ ≤ ‖a‖ + r :=\n  (norm_le_norm_add_norm_div' _ _).trans <| add_le_add_left (by rwa [← dist_eq_norm_div]) _\n\n"}
{"name":"norm_le_of_mem_closedBall","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\nr : Real\nh : Membership.mem (Metric.closedBall a r) b\n⊢ LE.le (Norm.norm b) (HAdd.hAdd (Norm.norm a) r)","decl":"@[to_additive norm_le_of_mem_closedBall]\ntheorem norm_le_of_mem_closedBall' (h : b ∈ closedBall a r) : ‖b‖ ≤ ‖a‖ + r :=\n  (norm_le_norm_add_norm_div' _ _).trans <| add_le_add_left (by rwa [← dist_eq_norm_div]) _\n\n"}
{"name":"norm_le_norm_add_const_of_dist_le'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\nr : Real\na✝ : LE.le (Dist.dist a b) r\n⊢ LE.le (Norm.norm a) (HAdd.hAdd (Norm.norm b) r)","decl":"@[to_additive norm_le_norm_add_const_of_dist_le]\ntheorem norm_le_norm_add_const_of_dist_le' : dist a b ≤ r → ‖a‖ ≤ ‖b‖ + r :=\n  norm_le_of_mem_closedBall'\n\n"}
{"name":"norm_le_norm_add_const_of_dist_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\nr : Real\na✝ : LE.le (Dist.dist a b) r\n⊢ LE.le (Norm.norm a) (HAdd.hAdd (Norm.norm b) r)","decl":"@[to_additive norm_le_norm_add_const_of_dist_le]\ntheorem norm_le_norm_add_const_of_dist_le' : dist a b ≤ r → ‖a‖ ≤ ‖b‖ + r :=\n  norm_le_of_mem_closedBall'\n\n"}
{"name":"norm_lt_of_mem_ball'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\nr : Real\nh : Membership.mem (Metric.ball a r) b\n⊢ LT.lt (Norm.norm b) (HAdd.hAdd (Norm.norm a) r)","decl":"@[to_additive norm_lt_of_mem_ball]\ntheorem norm_lt_of_mem_ball' (h : b ∈ ball a r) : ‖b‖ < ‖a‖ + r :=\n  (norm_le_norm_add_norm_div' _ _).trans_lt <| add_lt_add_left (by rwa [← dist_eq_norm_div]) _\n\n"}
{"name":"norm_lt_of_mem_ball","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\nr : Real\nh : Membership.mem (Metric.ball a r) b\n⊢ LT.lt (Norm.norm b) (HAdd.hAdd (Norm.norm a) r)","decl":"@[to_additive norm_lt_of_mem_ball]\ntheorem norm_lt_of_mem_ball' (h : b ∈ ball a r) : ‖b‖ < ‖a‖ + r :=\n  (norm_le_norm_add_norm_div' _ _).trans_lt <| add_lt_add_left (by rwa [← dist_eq_norm_div]) _\n\n"}
{"name":"norm_sub_sub_norm_sub_le_norm_sub","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nu v w : E\n⊢ LE.le (HSub.hSub (Norm.norm (HSub.hSub u w)) (Norm.norm (HSub.hSub v w))) (Norm.norm (HSub.hSub u v))","decl":"@[to_additive]\ntheorem norm_div_sub_norm_div_le_norm_div (u v w : E) : ‖u / w‖ - ‖v / w‖ ≤ ‖u / v‖ := by\n  simpa only [div_div_div_cancel_right] using norm_sub_norm_le' (u / w) (v / w)\n\n"}
{"name":"norm_div_sub_norm_div_le_norm_div","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nu v w : E\n⊢ LE.le (HSub.hSub (Norm.norm (HDiv.hDiv u w)) (Norm.norm (HDiv.hDiv v w))) (Norm.norm (HDiv.hDiv u v))","decl":"@[to_additive]\ntheorem norm_div_sub_norm_div_le_norm_div (u v w : E) : ‖u / w‖ - ‖v / w‖ ≤ ‖u / v‖ := by\n  simpa only [div_div_div_cancel_right] using norm_sub_norm_le' (u / w) (v / w)\n\n"}
{"name":"mem_sphere_iff_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\nr : Real\n⊢ Iff (Membership.mem (Metric.sphere a r) b) (Eq (Norm.norm (HSub.hSub b a)) r)","decl":"@[to_additive (attr := simp 1001) mem_sphere_iff_norm]\n-- Porting note: increase priority so the left-hand side doesn't reduce\ntheorem mem_sphere_iff_norm' : b ∈ sphere a r ↔ ‖b / a‖ = r := by simp [dist_eq_norm_div]\n\n"}
{"name":"mem_sphere_iff_norm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\nr : Real\n⊢ Iff (Membership.mem (Metric.sphere a r) b) (Eq (Norm.norm (HDiv.hDiv b a)) r)","decl":"@[to_additive (attr := simp 1001) mem_sphere_iff_norm]\n-- Porting note: increase priority so the left-hand side doesn't reduce\ntheorem mem_sphere_iff_norm' : b ∈ sphere a r ↔ ‖b / a‖ = r := by simp [dist_eq_norm_div]\n\n"}
{"name":"mem_sphere_zero_iff_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\nr : Real\n⊢ Iff (Membership.mem (Metric.sphere 0 r) a) (Eq (Norm.norm a) r)","decl":"@[to_additive] -- `simp` can prove this\ntheorem mem_sphere_one_iff_norm : a ∈ sphere (1 : E) r ↔ ‖a‖ = r := by simp [dist_eq_norm_div]\n\n"}
{"name":"mem_sphere_one_iff_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\nr : Real\n⊢ Iff (Membership.mem (Metric.sphere 1 r) a) (Eq (Norm.norm a) r)","decl":"@[to_additive] -- `simp` can prove this\ntheorem mem_sphere_one_iff_norm : a ∈ sphere (1 : E) r ↔ ‖a‖ = r := by simp [dist_eq_norm_div]\n\n"}
{"name":"norm_eq_of_mem_sphere","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nr : Real\nx : ↑(Metric.sphere 0 r)\n⊢ Eq (Norm.norm ↑x) r","decl":"@[to_additive (attr := simp) norm_eq_of_mem_sphere]\ntheorem norm_eq_of_mem_sphere' (x : sphere (1 : E) r) : ‖(x : E)‖ = r :=\n  mem_sphere_one_iff_norm.mp x.2\n\n"}
{"name":"norm_eq_of_mem_sphere'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nr : Real\nx : ↑(Metric.sphere 1 r)\n⊢ Eq (Norm.norm ↑x) r","decl":"@[to_additive (attr := simp) norm_eq_of_mem_sphere]\ntheorem norm_eq_of_mem_sphere' (x : sphere (1 : E) r) : ‖(x : E)‖ = r :=\n  mem_sphere_one_iff_norm.mp x.2\n\n"}
{"name":"ne_one_of_mem_sphere","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nr : Real\nhr : Ne r 0\nx : ↑(Metric.sphere 1 r)\n⊢ Ne (↑x) 1","decl":"@[to_additive]\ntheorem ne_one_of_mem_sphere (hr : r ≠ 0) (x : sphere (1 : E) r) : (x : E) ≠ 1 :=\n  ne_one_of_norm_ne_zero <| by rwa [norm_eq_of_mem_sphere' x]\n\n"}
{"name":"ne_zero_of_mem_sphere","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nr : Real\nhr : Ne r 0\nx : ↑(Metric.sphere 0 r)\n⊢ Ne (↑x) 0","decl":"@[to_additive]\ntheorem ne_one_of_mem_sphere (hr : r ≠ 0) (x : sphere (1 : E) r) : (x : E) ≠ 1 :=\n  ne_one_of_norm_ne_zero <| by rwa [norm_eq_of_mem_sphere' x]\n\n"}
{"name":"ne_one_of_mem_unit_sphere","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nx : ↑(Metric.sphere 1 1)\n⊢ Ne (↑x) 1","decl":"@[to_additive ne_zero_of_mem_unit_sphere]\ntheorem ne_one_of_mem_unit_sphere (x : sphere (1 : E) 1) : (x : E) ≠ 1 :=\n  ne_one_of_mem_sphere one_ne_zero _\n\n"}
{"name":"ne_zero_of_mem_unit_sphere","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nx : ↑(Metric.sphere 0 1)\n⊢ Ne (↑x) 0","decl":"@[to_additive ne_zero_of_mem_unit_sphere]\ntheorem ne_one_of_mem_unit_sphere (x : sphere (1 : E) 1) : (x : E) ≠ 1 :=\n  ne_one_of_mem_sphere one_ne_zero _\n\n"}
{"name":"coe_normGroupSeminorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\n⊢ Eq (⇑(normGroupSeminorm E)) Norm.norm","decl":"@[to_additive (attr := simp)]\ntheorem coe_normGroupSeminorm : ⇑(normGroupSeminorm E) = norm :=\n  rfl\n\n"}
{"name":"coe_normAddGroupSeminorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\n⊢ Eq (⇑(normAddGroupSeminorm E)) Norm.norm","decl":"@[to_additive (attr := simp)]\ntheorem coe_normGroupSeminorm : ⇑(normGroupSeminorm E) = norm :=\n  rfl\n\n"}
{"name":"NormedAddCommGroup.tendsto_nhds_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝ : SeminormedAddGroup E\nf : α → E\nl : Filter α\n⊢ Iff (Filter.Tendsto f l (nhds 0)) (∀ (ε : Real), GT.gt ε 0 → Filter.Eventually (fun x => LT.lt (Norm.norm (f x)) ε) l)","decl":"@[to_additive]\ntheorem NormedCommGroup.tendsto_nhds_one {f : α → E} {l : Filter α} :\n    Tendsto f l (𝓝 1) ↔ ∀ ε > 0, ∀ᶠ x in l, ‖f x‖ < ε :=\n  Metric.tendsto_nhds.trans <| by simp only [dist_one_right]\n\n"}
{"name":"NormedCommGroup.tendsto_nhds_one","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝ : SeminormedGroup E\nf : α → E\nl : Filter α\n⊢ Iff (Filter.Tendsto f l (nhds 1)) (∀ (ε : Real), GT.gt ε 0 → Filter.Eventually (fun x => LT.lt (Norm.norm (f x)) ε) l)","decl":"@[to_additive]\ntheorem NormedCommGroup.tendsto_nhds_one {f : α → E} {l : Filter α} :\n    Tendsto f l (𝓝 1) ↔ ∀ ε > 0, ∀ᶠ x in l, ‖f x‖ < ε :=\n  Metric.tendsto_nhds.trans <| by simp only [dist_one_right]\n\n"}
{"name":"NormedAddCommGroup.tendsto_nhds_nhds","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\nF : Type u_6\ninst✝¹ : SeminormedAddGroup E\ninst✝ : SeminormedAddGroup F\nf : E → F\nx : E\ny : F\n⊢ Iff (Filter.Tendsto f (nhds x) (nhds y)) (∀ (ε : Real), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ (x' : E), LT.lt (Norm.norm (HSub.hSub x' x)) δ → LT.lt (Norm.norm (HSub.hSub (f x') y)) ε))","decl":"@[to_additive]\ntheorem NormedCommGroup.tendsto_nhds_nhds {f : E → F} {x : E} {y : F} :\n    Tendsto f (𝓝 x) (𝓝 y) ↔ ∀ ε > 0, ∃ δ > 0, ∀ x', ‖x' / x‖ < δ → ‖f x' / y‖ < ε := by\n  simp_rw [Metric.tendsto_nhds_nhds, dist_eq_norm_div]\n\n"}
{"name":"NormedCommGroup.tendsto_nhds_nhds","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\nF : Type u_6\ninst✝¹ : SeminormedGroup E\ninst✝ : SeminormedGroup F\nf : E → F\nx : E\ny : F\n⊢ Iff (Filter.Tendsto f (nhds x) (nhds y)) (∀ (ε : Real), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ (x' : E), LT.lt (Norm.norm (HDiv.hDiv x' x)) δ → LT.lt (Norm.norm (HDiv.hDiv (f x') y)) ε))","decl":"@[to_additive]\ntheorem NormedCommGroup.tendsto_nhds_nhds {f : E → F} {x : E} {y : F} :\n    Tendsto f (𝓝 x) (𝓝 y) ↔ ∀ ε > 0, ∃ δ > 0, ∀ x', ‖x' / x‖ < δ → ‖f x' / y‖ < ε := by\n  simp_rw [Metric.tendsto_nhds_nhds, dist_eq_norm_div]\n\n"}
{"name":"NormedCommGroup.nhds_basis_norm_lt","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nx : E\n⊢ (nhds x).HasBasis (fun ε => LT.lt 0 ε) fun ε => setOf fun y => LT.lt (Norm.norm (HDiv.hDiv y x)) ε","decl":"@[to_additive]\ntheorem NormedCommGroup.nhds_basis_norm_lt (x : E) :\n    (𝓝 x).HasBasis (fun ε : ℝ => 0 < ε) fun ε => { y | ‖y / x‖ < ε } := by\n  simp_rw [← ball_eq']\n  exact Metric.nhds_basis_ball\n\n"}
{"name":"NormedAddCommGroup.nhds_basis_norm_lt","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nx : E\n⊢ (nhds x).HasBasis (fun ε => LT.lt 0 ε) fun ε => setOf fun y => LT.lt (Norm.norm (HSub.hSub y x)) ε","decl":"@[to_additive]\ntheorem NormedCommGroup.nhds_basis_norm_lt (x : E) :\n    (𝓝 x).HasBasis (fun ε : ℝ => 0 < ε) fun ε => { y | ‖y / x‖ < ε } := by\n  simp_rw [← ball_eq']\n  exact Metric.nhds_basis_ball\n\n"}
{"name":"NormedCommGroup.nhds_one_basis_norm_lt","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\n⊢ (nhds 1).HasBasis (fun ε => LT.lt 0 ε) fun ε => setOf fun y => LT.lt (Norm.norm y) ε","decl":"@[to_additive]\ntheorem NormedCommGroup.nhds_one_basis_norm_lt :\n    (𝓝 (1 : E)).HasBasis (fun ε : ℝ => 0 < ε) fun ε => { y | ‖y‖ < ε } := by\n  convert NormedCommGroup.nhds_basis_norm_lt (1 : E)\n  simp\n\n"}
{"name":"NormedAddCommGroup.nhds_zero_basis_norm_lt","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\n⊢ (nhds 0).HasBasis (fun ε => LT.lt 0 ε) fun ε => setOf fun y => LT.lt (Norm.norm y) ε","decl":"@[to_additive]\ntheorem NormedCommGroup.nhds_one_basis_norm_lt :\n    (𝓝 (1 : E)).HasBasis (fun ε : ℝ => 0 < ε) fun ε => { y | ‖y‖ < ε } := by\n  convert NormedCommGroup.nhds_basis_norm_lt (1 : E)\n  simp\n\n"}
{"name":"NormedCommGroup.uniformity_basis_dist","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\n⊢ (uniformity E).HasBasis (fun ε => LT.lt 0 ε) fun ε => setOf fun p => LT.lt (Norm.norm (HDiv.hDiv p.1 p.2)) ε","decl":"@[to_additive]\ntheorem NormedCommGroup.uniformity_basis_dist :\n    (𝓤 E).HasBasis (fun ε : ℝ => 0 < ε) fun ε => { p : E × E | ‖p.fst / p.snd‖ < ε } := by\n  convert Metric.uniformity_basis_dist (α := E) using 1\n  simp [dist_eq_norm_div]\n\n"}
{"name":"NormedAddCommGroup.uniformity_basis_dist","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\n⊢ (uniformity E).HasBasis (fun ε => LT.lt 0 ε) fun ε => setOf fun p => LT.lt (Norm.norm (HSub.hSub p.1 p.2)) ε","decl":"@[to_additive]\ntheorem NormedCommGroup.uniformity_basis_dist :\n    (𝓤 E).HasBasis (fun ε : ℝ => 0 < ε) fun ε => { p : E × E | ‖p.fst / p.snd‖ < ε } := by\n  convert Metric.uniformity_basis_dist (α := E) using 1\n  simp [dist_eq_norm_div]\n\n"}
{"name":"coe_nnnorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\n⊢ Eq (↑(NNNorm.nnnorm a)) (Norm.norm a)","decl":"@[to_additive (attr := simp, norm_cast) coe_nnnorm]\ntheorem coe_nnnorm' (a : E) : (‖a‖₊ : ℝ) = ‖a‖ := rfl\n\n"}
{"name":"coe_nnnorm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\n⊢ Eq (↑(NNNorm.nnnorm a)) (Norm.norm a)","decl":"@[to_additive (attr := simp, norm_cast) coe_nnnorm]\ntheorem coe_nnnorm' (a : E) : (‖a‖₊ : ℝ) = ‖a‖ := rfl\n\n"}
{"name":"coe_comp_nnnorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\n⊢ Eq (Function.comp NNReal.toReal NNNorm.nnnorm) Norm.norm","decl":"@[to_additive (attr := simp) coe_comp_nnnorm]\ntheorem coe_comp_nnnorm' : (toReal : ℝ≥0 → ℝ) ∘ (nnnorm : E → ℝ≥0) = norm :=\n  rfl\n\n"}
{"name":"coe_comp_nnnorm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\n⊢ Eq (Function.comp NNReal.toReal NNNorm.nnnorm) Norm.norm","decl":"@[to_additive (attr := simp) coe_comp_nnnorm]\ntheorem coe_comp_nnnorm' : (toReal : ℝ≥0 → ℝ) ∘ (nnnorm : E → ℝ≥0) = norm :=\n  rfl\n\n"}
{"name":"norm_toNNReal'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\n⊢ Eq (Norm.norm a).toNNReal (NNNorm.nnnorm a)","decl":"@[to_additive (attr := simp) norm_toNNReal]\ntheorem norm_toNNReal' : ‖a‖.toNNReal = ‖a‖₊ :=\n  @Real.toNNReal_coe ‖a‖₊\n\n"}
{"name":"norm_toNNReal","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\n⊢ Eq (Norm.norm a).toNNReal (NNNorm.nnnorm a)","decl":"@[to_additive (attr := simp) norm_toNNReal]\ntheorem norm_toNNReal' : ‖a‖.toNNReal = ‖a‖₊ :=\n  @Real.toNNReal_coe ‖a‖₊\n\n"}
{"name":"toReal_enorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nx : E\n⊢ Eq (ENorm.enorm x).toReal (Norm.norm x)","decl":"@[to_additive (attr := simp) toReal_enorm]\nlemma toReal_enorm' (x : E) : ‖x‖ₑ.toReal = ‖x‖ := by simp [enorm]\n\n"}
{"name":"toReal_enorm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nx : E\n⊢ Eq (ENorm.enorm x).toReal (Norm.norm x)","decl":"@[to_additive (attr := simp) toReal_enorm]\nlemma toReal_enorm' (x : E) : ‖x‖ₑ.toReal = ‖x‖ := by simp [enorm]\n\n"}
{"name":"ofReal_norm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nx : E\n⊢ Eq (ENNReal.ofReal (Norm.norm x)) (ENorm.enorm x)","decl":"@[to_additive (attr := simp) ofReal_norm]\nlemma ofReal_norm' (x : E) : .ofReal ‖x‖ = ‖x‖ₑ := by\n  simp [enorm, ENNReal.ofReal, Real.toNNReal, nnnorm]\n\n"}
{"name":"ofReal_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nx : E\n⊢ Eq (ENNReal.ofReal (Norm.norm x)) (ENorm.enorm x)","decl":"@[to_additive (attr := simp) ofReal_norm]\nlemma ofReal_norm' (x : E) : .ofReal ‖x‖ = ‖x‖ₑ := by\n  simp [enorm, ENNReal.ofReal, Real.toNNReal, nnnorm]\n\n"}
{"name":"nndist_eq_nnnorm_sub","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ Eq (NNDist.nndist a b) (NNNorm.nnnorm (HSub.hSub a b))","decl":"@[to_additive]\ntheorem nndist_eq_nnnorm_div (a b : E) : nndist a b = ‖a / b‖₊ :=\n  NNReal.eq <| dist_eq_norm_div _ _\n\n"}
{"name":"nndist_eq_nnnorm_div","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\n⊢ Eq (NNDist.nndist a b) (NNNorm.nnnorm (HDiv.hDiv a b))","decl":"@[to_additive]\ntheorem nndist_eq_nnnorm_div (a b : E) : nndist a b = ‖a / b‖₊ :=\n  NNReal.eq <| dist_eq_norm_div _ _\n\n"}
{"name":"nndist_eq_nnnorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ Eq (NNDist.nndist a b) (NNNorm.nnnorm (HSub.hSub a b))","decl":"alias nndist_eq_nnnorm := nndist_eq_nnnorm_sub\n\n"}
{"name":"nndist_one_right","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\n⊢ Eq (NNDist.nndist a 1) (NNNorm.nnnorm a)","decl":"@[to_additive (attr := simp)]\ntheorem nndist_one_right (a : E) : nndist a 1 = ‖a‖₊ := by simp [nndist_eq_nnnorm_div]\n\n"}
{"name":"nndist_zero_right","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\n⊢ Eq (NNDist.nndist a 0) (NNNorm.nnnorm a)","decl":"@[to_additive (attr := simp)]\ntheorem nndist_one_right (a : E) : nndist a 1 = ‖a‖₊ := by simp [nndist_eq_nnnorm_div]\n\n"}
{"name":"edist_zero_right","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\n⊢ Eq (EDist.edist a 0) (ENorm.enorm a)","decl":"@[to_additive (attr := simp)]\nlemma edist_one_right (a : E) : edist a 1 = ‖a‖ₑ := by simp [edist_nndist, nndist_one_right, enorm]\n\n"}
{"name":"edist_one_right","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\n⊢ Eq (EDist.edist a 1) (ENorm.enorm a)","decl":"@[to_additive (attr := simp)]\nlemma edist_one_right (a : E) : edist a 1 = ‖a‖ₑ := by simp [edist_nndist, nndist_one_right, enorm]\n\n"}
{"name":"nnnorm_one'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\n⊢ Eq (NNNorm.nnnorm 1) 0","decl":"@[to_additive (attr := simp) nnnorm_zero]\ntheorem nnnorm_one' : ‖(1 : E)‖₊ = 0 := NNReal.eq norm_one'\n\n"}
{"name":"nnnorm_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\n⊢ Eq (NNNorm.nnnorm 0) 0","decl":"@[to_additive (attr := simp) nnnorm_zero]\ntheorem nnnorm_one' : ‖(1 : E)‖₊ = 0 := NNReal.eq norm_one'\n\n"}
{"name":"ne_zero_of_nnnorm_ne_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\na✝ : Ne (NNNorm.nnnorm a) 0\n⊢ Ne a 0","decl":"@[to_additive]\ntheorem ne_one_of_nnnorm_ne_zero {a : E} : ‖a‖₊ ≠ 0 → a ≠ 1 :=\n  mt <| by\n    rintro rfl\n    exact nnnorm_one'\n\n"}
{"name":"ne_one_of_nnnorm_ne_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\na✝ : Ne (NNNorm.nnnorm a) 0\n⊢ Ne a 1","decl":"@[to_additive]\ntheorem ne_one_of_nnnorm_ne_zero {a : E} : ‖a‖₊ ≠ 0 → a ≠ 1 :=\n  mt <| by\n    rintro rfl\n    exact nnnorm_one'\n\n"}
{"name":"nnnorm_add_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ LE.le (NNNorm.nnnorm (HAdd.hAdd a b)) (HAdd.hAdd (NNNorm.nnnorm a) (NNNorm.nnnorm b))","decl":"@[to_additive nnnorm_add_le]\ntheorem nnnorm_mul_le' (a b : E) : ‖a * b‖₊ ≤ ‖a‖₊ + ‖b‖₊ :=\n  NNReal.coe_le_coe.1 <| norm_mul_le' a b\n\n"}
{"name":"nnnorm_mul_le'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\n⊢ LE.le (NNNorm.nnnorm (HMul.hMul a b)) (HAdd.hAdd (NNNorm.nnnorm a) (NNNorm.nnnorm b))","decl":"@[to_additive nnnorm_add_le]\ntheorem nnnorm_mul_le' (a b : E) : ‖a * b‖₊ ≤ ‖a‖₊ + ‖b‖₊ :=\n  NNReal.coe_le_coe.1 <| norm_mul_le' a b\n\n"}
{"name":"enorm_add_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ LE.le (ENorm.enorm (HAdd.hAdd a b)) (HAdd.hAdd (ENorm.enorm a) (ENorm.enorm b))","decl":"@[to_additive enorm_add_le]\nlemma enorm_mul_le' (a b : E) : ‖a * b‖ₑ ≤ ‖a‖ₑ + ‖b‖ₑ := by\n  simpa [enorm, ← ENNReal.coe_add] using nnnorm_mul_le' a b\n\n"}
{"name":"enorm_mul_le'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\n⊢ LE.le (ENorm.enorm (HMul.hMul a b)) (HAdd.hAdd (ENorm.enorm a) (ENorm.enorm b))","decl":"@[to_additive enorm_add_le]\nlemma enorm_mul_le' (a b : E) : ‖a * b‖ₑ ≤ ‖a‖ₑ + ‖b‖ₑ := by\n  simpa [enorm, ← ENNReal.coe_add] using nnnorm_mul_le' a b\n\n"}
{"name":"norm_pow_le_mul_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\nn : Nat\n⊢ LE.le (Norm.norm (HPow.hPow a n)) (HMul.hMul (↑n) (Norm.norm a))","decl":"@[to_additive norm_nsmul_le]\nlemma norm_pow_le_mul_norm : ∀ {n : ℕ}, ‖a ^ n‖ ≤ n * ‖a‖\n  | 0 => by simp\n  | n + 1 => by simpa [pow_succ, add_mul] using norm_mul_le_of_le' norm_pow_le_mul_norm le_rfl\n\n"}
{"name":"norm_nsmul_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\nn : Nat\n⊢ LE.le (Norm.norm (HSMul.hSMul n a)) (HMul.hMul (↑n) (Norm.norm a))","decl":"@[to_additive norm_nsmul_le]\nlemma norm_pow_le_mul_norm : ∀ {n : ℕ}, ‖a ^ n‖ ≤ n * ‖a‖\n  | 0 => by simp\n  | n + 1 => by simpa [pow_succ, add_mul] using norm_mul_le_of_le' norm_pow_le_mul_norm le_rfl\n\n"}
{"name":"nnnorm_pow_le_mul_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\nn : Nat\n⊢ LE.le (NNNorm.nnnorm (HPow.hPow a n)) (HMul.hMul (↑n) (NNNorm.nnnorm a))","decl":"@[to_additive nnnorm_nsmul_le]\nlemma nnnorm_pow_le_mul_norm {n : ℕ} : ‖a ^ n‖₊ ≤ n * ‖a‖₊ := by\n  simpa only [← NNReal.coe_le_coe, NNReal.coe_mul, NNReal.coe_natCast] using norm_pow_le_mul_norm\n\n"}
{"name":"nnnorm_nsmul_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\nn : Nat\n⊢ LE.le (NNNorm.nnnorm (HSMul.hSMul n a)) (HMul.hMul (↑n) (NNNorm.nnnorm a))","decl":"@[to_additive nnnorm_nsmul_le]\nlemma nnnorm_pow_le_mul_norm {n : ℕ} : ‖a ^ n‖₊ ≤ n * ‖a‖₊ := by\n  simpa only [← NNReal.coe_le_coe, NNReal.coe_mul, NNReal.coe_natCast] using norm_pow_le_mul_norm\n\n"}
{"name":"nnnorm_neg","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\n⊢ Eq (NNNorm.nnnorm (Neg.neg a)) (NNNorm.nnnorm a)","decl":"@[to_additive (attr := simp) nnnorm_neg]\ntheorem nnnorm_inv' (a : E) : ‖a⁻¹‖₊ = ‖a‖₊ :=\n  NNReal.eq <| norm_inv' a\n\n"}
{"name":"nnnorm_inv'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\n⊢ Eq (NNNorm.nnnorm (Inv.inv a)) (NNNorm.nnnorm a)","decl":"@[to_additive (attr := simp) nnnorm_neg]\ntheorem nnnorm_inv' (a : E) : ‖a⁻¹‖₊ = ‖a‖₊ :=\n  NNReal.eq <| norm_inv' a\n\n"}
{"name":"enorm_neg","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\n⊢ Eq (ENorm.enorm (Neg.neg a)) (ENorm.enorm a)","decl":"@[to_additive (attr := simp) enorm_neg]\nlemma enorm_inv' (a : E) : ‖a⁻¹‖ₑ = ‖a‖ₑ := by simp [enorm]\n\n"}
{"name":"enorm_inv'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\n⊢ Eq (ENorm.enorm (Inv.inv a)) (ENorm.enorm a)","decl":"@[to_additive (attr := simp) enorm_neg]\nlemma enorm_inv' (a : E) : ‖a⁻¹‖ₑ = ‖a‖ₑ := by simp [enorm]\n\n"}
{"name":"nnnorm_zpow_abs","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\nn : Int\n⊢ Eq (NNNorm.nnnorm (HPow.hPow a (abs n))) (NNNorm.nnnorm (HPow.hPow a n))","decl":"@[to_additive (attr := simp) nnnorm_abs_zsmul]\ntheorem nnnorm_zpow_abs (a : E) (n : ℤ) : ‖a ^ |n|‖₊ = ‖a ^ n‖₊ :=\n  NNReal.eq <| norm_zpow_abs a n\n\n"}
{"name":"nnnorm_abs_zsmul","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\nn : Int\n⊢ Eq (NNNorm.nnnorm (HSMul.hSMul (abs n) a)) (NNNorm.nnnorm (HSMul.hSMul n a))","decl":"@[to_additive (attr := simp) nnnorm_abs_zsmul]\ntheorem nnnorm_zpow_abs (a : E) (n : ℤ) : ‖a ^ |n|‖₊ = ‖a ^ n‖₊ :=\n  NNReal.eq <| norm_zpow_abs a n\n\n"}
{"name":"nnnorm_natAbs_smul","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\nn : Int\n⊢ Eq (NNNorm.nnnorm (HSMul.hSMul n.natAbs a)) (NNNorm.nnnorm (HSMul.hSMul n a))","decl":"@[to_additive (attr := simp) nnnorm_natAbs_smul]\ntheorem nnnorm_pow_natAbs (a : E) (n : ℤ) : ‖a ^ n.natAbs‖₊ = ‖a ^ n‖₊ :=\n  NNReal.eq <| norm_pow_natAbs a n\n\n"}
{"name":"nnnorm_pow_natAbs","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\nn : Int\n⊢ Eq (NNNorm.nnnorm (HPow.hPow a n.natAbs)) (NNNorm.nnnorm (HPow.hPow a n))","decl":"@[to_additive (attr := simp) nnnorm_natAbs_smul]\ntheorem nnnorm_pow_natAbs (a : E) (n : ℤ) : ‖a ^ n.natAbs‖₊ = ‖a ^ n‖₊ :=\n  NNReal.eq <| norm_pow_natAbs a n\n\n"}
{"name":"nnnorm_isUnit_zsmul","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\nn : Int\nhn : IsUnit n\n⊢ Eq (NNNorm.nnnorm (HSMul.hSMul n a)) (NNNorm.nnnorm a)","decl":"@[to_additive nnnorm_isUnit_zsmul]\ntheorem nnnorm_zpow_isUnit (a : E) {n : ℤ} (hn : IsUnit n) : ‖a ^ n‖₊ = ‖a‖₊ :=\n  NNReal.eq <| norm_zpow_isUnit a hn\n\n"}
{"name":"nnnorm_zpow_isUnit","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\nn : Int\nhn : IsUnit n\n⊢ Eq (NNNorm.nnnorm (HPow.hPow a n)) (NNNorm.nnnorm a)","decl":"@[to_additive nnnorm_isUnit_zsmul]\ntheorem nnnorm_zpow_isUnit (a : E) {n : ℤ} (hn : IsUnit n) : ‖a ^ n‖₊ = ‖a‖₊ :=\n  NNReal.eq <| norm_zpow_isUnit a hn\n\n"}
{"name":"nnnorm_units_zsmul","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_8\ninst✝ : SeminormedAddGroup E\nn : Units Int\na : E\n⊢ Eq (NNNorm.nnnorm (HSMul.hSMul n a)) (NNNorm.nnnorm a)","decl":"@[simp]\ntheorem nnnorm_units_zsmul {E : Type*} [SeminormedAddGroup E] (n : ℤˣ) (a : E) : ‖n • a‖₊ = ‖a‖₊ :=\n  NNReal.eq <| norm_isUnit_zsmul a n.isUnit\n\n"}
{"name":"nndist_one_left","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\n⊢ Eq (NNDist.nndist 1 a) (NNNorm.nnnorm a)","decl":"@[to_additive (attr := simp)]\ntheorem nndist_one_left (a : E) : nndist 1 a = ‖a‖₊ := by simp [nndist_eq_nnnorm_div]\n\n"}
{"name":"nndist_zero_left","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\n⊢ Eq (NNDist.nndist 0 a) (NNNorm.nnnorm a)","decl":"@[to_additive (attr := simp)]\ntheorem nndist_one_left (a : E) : nndist 1 a = ‖a‖₊ := by simp [nndist_eq_nnnorm_div]\n\n"}
{"name":"edist_one_left","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\n⊢ Eq (EDist.edist 1 a) ↑(NNNorm.nnnorm a)","decl":"@[to_additive (attr := simp)]\ntheorem edist_one_left (a : E) : edist 1 a = ‖a‖₊ := by\n  rw [edist_nndist, nndist_one_left]\n\n"}
{"name":"edist_zero_left","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\n⊢ Eq (EDist.edist 0 a) ↑(NNNorm.nnnorm a)","decl":"@[to_additive (attr := simp)]\ntheorem edist_one_left (a : E) : edist 1 a = ‖a‖₊ := by\n  rw [edist_nndist, nndist_one_left]\n\n"}
{"name":"nndist_mulIndicator","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝ : SeminormedGroup E\ns t : Set α\nf : α → E\nx : α\n⊢ Eq (NNDist.nndist (s.mulIndicator f x) (t.mulIndicator f x)) (NNNorm.nnnorm ((symmDiff s t).mulIndicator f x))","decl":"open scoped symmDiff in\n@[to_additive]\ntheorem nndist_mulIndicator (s t : Set α) (f : α → E) (x : α) :\n    nndist (s.mulIndicator f x) (t.mulIndicator f x) = ‖(s ∆ t).mulIndicator f x‖₊ :=\n  NNReal.eq <| dist_mulIndicator s t f x\n\n"}
{"name":"nndist_indicator","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝ : SeminormedAddGroup E\ns t : Set α\nf : α → E\nx : α\n⊢ Eq (NNDist.nndist (s.indicator f x) (t.indicator f x)) (NNNorm.nnnorm ((symmDiff s t).indicator f x))","decl":"open scoped symmDiff in\n@[to_additive]\ntheorem nndist_mulIndicator (s t : Set α) (f : α → E) (x : α) :\n    nndist (s.mulIndicator f x) (t.mulIndicator f x) = ‖(s ∆ t).mulIndicator f x‖₊ :=\n  NNReal.eq <| dist_mulIndicator s t f x\n\n"}
{"name":"nnnorm_div_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\n⊢ LE.le (NNNorm.nnnorm (HDiv.hDiv a b)) (HAdd.hAdd (NNNorm.nnnorm a) (NNNorm.nnnorm b))","decl":"@[to_additive]\ntheorem nnnorm_div_le (a b : E) : ‖a / b‖₊ ≤ ‖a‖₊ + ‖b‖₊ :=\n  NNReal.coe_le_coe.1 <| norm_div_le _ _\n\n"}
{"name":"nnnorm_sub_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ LE.le (NNNorm.nnnorm (HSub.hSub a b)) (HAdd.hAdd (NNNorm.nnnorm a) (NNNorm.nnnorm b))","decl":"@[to_additive]\ntheorem nnnorm_div_le (a b : E) : ‖a / b‖₊ ≤ ‖a‖₊ + ‖b‖₊ :=\n  NNReal.coe_le_coe.1 <| norm_div_le _ _\n\n"}
{"name":"enorm_sub_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ LE.le (ENorm.enorm (HSub.hSub a b)) (HAdd.hAdd (ENorm.enorm a) (ENorm.enorm b))","decl":"@[to_additive]\nlemma enorm_div_le : ‖a / b‖ₑ ≤ ‖a‖ₑ + ‖b‖ₑ := by\n  simpa [enorm, ← ENNReal.coe_add] using nnnorm_div_le a b\n\n"}
{"name":"enorm_div_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\n⊢ LE.le (ENorm.enorm (HDiv.hDiv a b)) (HAdd.hAdd (ENorm.enorm a) (ENorm.enorm b))","decl":"@[to_additive]\nlemma enorm_div_le : ‖a / b‖ₑ ≤ ‖a‖ₑ + ‖b‖ₑ := by\n  simpa [enorm, ← ENNReal.coe_add] using nnnorm_div_le a b\n\n"}
{"name":"nndist_nnnorm_nnnorm_le'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\n⊢ LE.le (NNDist.nndist (NNNorm.nnnorm a) (NNNorm.nnnorm b)) (NNNorm.nnnorm (HDiv.hDiv a b))","decl":"@[to_additive nndist_nnnorm_nnnorm_le]\ntheorem nndist_nnnorm_nnnorm_le' (a b : E) : nndist ‖a‖₊ ‖b‖₊ ≤ ‖a / b‖₊ :=\n  NNReal.coe_le_coe.1 <| dist_norm_norm_le' a b\n\n"}
{"name":"nndist_nnnorm_nnnorm_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ LE.le (NNDist.nndist (NNNorm.nnnorm a) (NNNorm.nnnorm b)) (NNNorm.nnnorm (HSub.hSub a b))","decl":"@[to_additive nndist_nnnorm_nnnorm_le]\ntheorem nndist_nnnorm_nnnorm_le' (a b : E) : nndist ‖a‖₊ ‖b‖₊ ≤ ‖a / b‖₊ :=\n  NNReal.coe_le_coe.1 <| dist_norm_norm_le' a b\n\n"}
{"name":"nnnorm_le_nnnorm_add_nnnorm_div","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\n⊢ LE.le (NNNorm.nnnorm b) (HAdd.hAdd (NNNorm.nnnorm a) (NNNorm.nnnorm (HDiv.hDiv a b)))","decl":"@[to_additive]\ntheorem nnnorm_le_nnnorm_add_nnnorm_div (a b : E) : ‖b‖₊ ≤ ‖a‖₊ + ‖a / b‖₊ :=\n  norm_le_norm_add_norm_div _ _\n\n"}
{"name":"nnnorm_le_nnnorm_add_nnnorm_sub","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ LE.le (NNNorm.nnnorm b) (HAdd.hAdd (NNNorm.nnnorm a) (NNNorm.nnnorm (HSub.hSub a b)))","decl":"@[to_additive]\ntheorem nnnorm_le_nnnorm_add_nnnorm_div (a b : E) : ‖b‖₊ ≤ ‖a‖₊ + ‖a / b‖₊ :=\n  norm_le_norm_add_norm_div _ _\n\n"}
{"name":"nnnorm_le_nnnorm_add_nnnorm_div'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\n⊢ LE.le (NNNorm.nnnorm a) (HAdd.hAdd (NNNorm.nnnorm b) (NNNorm.nnnorm (HDiv.hDiv a b)))","decl":"@[to_additive]\ntheorem nnnorm_le_nnnorm_add_nnnorm_div' (a b : E) : ‖a‖₊ ≤ ‖b‖₊ + ‖a / b‖₊ :=\n  norm_le_norm_add_norm_div' _ _\n\n"}
{"name":"nnnorm_le_nnnorm_add_nnnorm_sub'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ LE.le (NNNorm.nnnorm a) (HAdd.hAdd (NNNorm.nnnorm b) (NNNorm.nnnorm (HSub.hSub a b)))","decl":"@[to_additive]\ntheorem nnnorm_le_nnnorm_add_nnnorm_div' (a b : E) : ‖a‖₊ ≤ ‖b‖₊ + ‖a / b‖₊ :=\n  norm_le_norm_add_norm_div' _ _\n\n"}
{"name":"nnnorm_le_insert'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ LE.le (NNNorm.nnnorm a) (HAdd.hAdd (NNNorm.nnnorm b) (NNNorm.nnnorm (HSub.hSub a b)))","decl":"alias nnnorm_le_insert' := nnnorm_le_nnnorm_add_nnnorm_sub'\n\n"}
{"name":"nnnorm_le_insert","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ LE.le (NNNorm.nnnorm b) (HAdd.hAdd (NNNorm.nnnorm a) (NNNorm.nnnorm (HSub.hSub a b)))","decl":"alias nnnorm_le_insert := nnnorm_le_nnnorm_add_nnnorm_sub\n\n"}
{"name":"nnnorm_le_mul_nnnorm_add","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\n⊢ LE.le (NNNorm.nnnorm a) (HAdd.hAdd (NNNorm.nnnorm (HMul.hMul a b)) (NNNorm.nnnorm b))","decl":"@[to_additive]\ntheorem nnnorm_le_mul_nnnorm_add (a b : E) : ‖a‖₊ ≤ ‖a * b‖₊ + ‖b‖₊ :=\n  norm_le_mul_norm_add _ _\n\n"}
{"name":"nnnorm_le_add_nnnorm_add","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ LE.le (NNNorm.nnnorm a) (HAdd.hAdd (NNNorm.nnnorm (HAdd.hAdd a b)) (NNNorm.nnnorm b))","decl":"@[to_additive]\ntheorem nnnorm_le_mul_nnnorm_add (a b : E) : ‖a‖₊ ≤ ‖a * b‖₊ + ‖b‖₊ :=\n  norm_le_mul_norm_add _ _\n\n"}
{"name":"nnnorm_le_mul_nnnorm_add'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\n⊢ LE.le (NNNorm.nnnorm b) (HAdd.hAdd (NNNorm.nnnorm (HMul.hMul a b)) (NNNorm.nnnorm a))","decl":"/-- An analogue of `nnnorm_le_mul_nnnorm_add` for the multiplication from the left. -/\n@[to_additive \"An analogue of `nnnorm_le_add_nnnorm_add` for the addition from the left.\"]\ntheorem nnnorm_le_mul_nnnorm_add' (a b : E) : ‖b‖₊ ≤ ‖a * b‖₊ + ‖a‖₊ :=\n  norm_le_mul_norm_add' _ _\n\n"}
{"name":"nnnorm_le_add_nnnorm_add'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ LE.le (NNNorm.nnnorm b) (HAdd.hAdd (NNNorm.nnnorm (HAdd.hAdd a b)) (NNNorm.nnnorm a))","decl":"/-- An analogue of `nnnorm_le_mul_nnnorm_add` for the multiplication from the left. -/\n@[to_additive \"An analogue of `nnnorm_le_add_nnnorm_add` for the addition from the left.\"]\ntheorem nnnorm_le_mul_nnnorm_add' (a b : E) : ‖b‖₊ ≤ ‖a * b‖₊ + ‖a‖₊ :=\n  norm_le_mul_norm_add' _ _\n\n"}
{"name":"nnnorm_mul_eq_nnnorm_right","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nx y : E\nh : Eq (NNNorm.nnnorm x) 0\n⊢ Eq (NNNorm.nnnorm (HMul.hMul x y)) (NNNorm.nnnorm y)","decl":"@[to_additive]\nlemma nnnorm_mul_eq_nnnorm_right {x : E} (y : E) (h : ‖x‖₊ = 0) : ‖x * y‖₊ = ‖y‖₊ :=\n  NNReal.eq <| norm_mul_eq_norm_right _ <| congr_arg NNReal.toReal h\n\n"}
{"name":"nnnorm_add_eq_nnnorm_right","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nx y : E\nh : Eq (NNNorm.nnnorm x) 0\n⊢ Eq (NNNorm.nnnorm (HAdd.hAdd x y)) (NNNorm.nnnorm y)","decl":"@[to_additive]\nlemma nnnorm_mul_eq_nnnorm_right {x : E} (y : E) (h : ‖x‖₊ = 0) : ‖x * y‖₊ = ‖y‖₊ :=\n  NNReal.eq <| norm_mul_eq_norm_right _ <| congr_arg NNReal.toReal h\n\n"}
{"name":"nnnorm_mul_eq_nnnorm_left","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nx y : E\nh : Eq (NNNorm.nnnorm y) 0\n⊢ Eq (NNNorm.nnnorm (HMul.hMul x y)) (NNNorm.nnnorm x)","decl":"@[to_additive]\nlemma nnnorm_mul_eq_nnnorm_left (x : E) {y : E} (h : ‖y‖₊ = 0) : ‖x * y‖₊ = ‖x‖₊ :=\n  NNReal.eq <| norm_mul_eq_norm_left _ <| congr_arg NNReal.toReal h\n\n"}
{"name":"nnnorm_add_eq_nnnorm_left","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nx y : E\nh : Eq (NNNorm.nnnorm y) 0\n⊢ Eq (NNNorm.nnnorm (HAdd.hAdd x y)) (NNNorm.nnnorm x)","decl":"@[to_additive]\nlemma nnnorm_mul_eq_nnnorm_left (x : E) {y : E} (h : ‖y‖₊ = 0) : ‖x * y‖₊ = ‖x‖₊ :=\n  NNReal.eq <| norm_mul_eq_norm_left _ <| congr_arg NNReal.toReal h\n\n"}
{"name":"nnnorm_div_eq_nnnorm_right","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nx y : E\nh : Eq (NNNorm.nnnorm x) 0\n⊢ Eq (NNNorm.nnnorm (HDiv.hDiv x y)) (NNNorm.nnnorm y)","decl":"@[to_additive]\nlemma nnnorm_div_eq_nnnorm_right {x : E} (y : E) (h : ‖x‖₊ = 0) : ‖x / y‖₊ = ‖y‖₊ :=\n  NNReal.eq <| norm_div_eq_norm_right _ <| congr_arg NNReal.toReal h\n\n"}
{"name":"nnnorm_sub_eq_nnnorm_right","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nx y : E\nh : Eq (NNNorm.nnnorm x) 0\n⊢ Eq (NNNorm.nnnorm (HSub.hSub x y)) (NNNorm.nnnorm y)","decl":"@[to_additive]\nlemma nnnorm_div_eq_nnnorm_right {x : E} (y : E) (h : ‖x‖₊ = 0) : ‖x / y‖₊ = ‖y‖₊ :=\n  NNReal.eq <| norm_div_eq_norm_right _ <| congr_arg NNReal.toReal h\n\n"}
{"name":"nnnorm_div_eq_nnnorm_left","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nx y : E\nh : Eq (NNNorm.nnnorm y) 0\n⊢ Eq (NNNorm.nnnorm (HDiv.hDiv x y)) (NNNorm.nnnorm x)","decl":"@[to_additive]\nlemma nnnorm_div_eq_nnnorm_left (x : E) {y : E} (h : ‖y‖₊ = 0) : ‖x / y‖₊ = ‖x‖₊ :=\n  NNReal.eq <| norm_div_eq_norm_left _ <| congr_arg NNReal.toReal h\n\n"}
{"name":"nnnorm_sub_eq_nnnorm_left","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nx y : E\nh : Eq (NNNorm.nnnorm y) 0\n⊢ Eq (NNNorm.nnnorm (HSub.hSub x y)) (NNNorm.nnnorm x)","decl":"@[to_additive]\nlemma nnnorm_div_eq_nnnorm_left (x : E) {y : E} (h : ‖y‖₊ = 0) : ‖x / y‖₊ = ‖x‖₊ :=\n  NNReal.eq <| norm_div_eq_norm_left _ <| congr_arg NNReal.toReal h\n\n"}
{"name":"toReal_coe_nnnorm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\n⊢ Eq (↑(NNNorm.nnnorm a)).toReal (Norm.norm a)","decl":"/-- The non negative norm seen as an `ENNReal` and then as a `Real` is equal to the norm. -/\n@[to_additive toReal_coe_nnnorm \"The non negative norm seen as an `ENNReal` and\nthen as a `Real` is equal to the norm.\"]\ntheorem toReal_coe_nnnorm' (a : E) : (‖a‖₊ : ℝ≥0∞).toReal = ‖a‖ := rfl\n\n"}
{"name":"toReal_coe_nnnorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\n⊢ Eq (↑(NNNorm.nnnorm a)).toReal (Norm.norm a)","decl":"/-- The non negative norm seen as an `ENNReal` and then as a `Real` is equal to the norm. -/\n@[to_additive toReal_coe_nnnorm \"The non negative norm seen as an `ENNReal` and\nthen as a `Real` is equal to the norm.\"]\ntheorem toReal_coe_nnnorm' (a : E) : (‖a‖₊ : ℝ≥0∞).toReal = ‖a‖ := rfl\n\n"}
{"name":"edist_mulIndicator","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝ : SeminormedGroup E\ns t : Set α\nf : α → E\nx : α\n⊢ Eq (EDist.edist (s.mulIndicator f x) (t.mulIndicator f x)) ↑(NNNorm.nnnorm ((symmDiff s t).mulIndicator f x))","decl":"open scoped symmDiff in\n@[to_additive]\ntheorem edist_mulIndicator (s t : Set α) (f : α → E) (x : α) :\n    edist (s.mulIndicator f x) (t.mulIndicator f x) = ‖(s ∆ t).mulIndicator f x‖₊ := by\n  rw [edist_nndist, nndist_mulIndicator]\n\n"}
{"name":"edist_indicator","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝ : SeminormedAddGroup E\ns t : Set α\nf : α → E\nx : α\n⊢ Eq (EDist.edist (s.indicator f x) (t.indicator f x)) ↑(NNNorm.nnnorm ((symmDiff s t).indicator f x))","decl":"open scoped symmDiff in\n@[to_additive]\ntheorem edist_mulIndicator (s t : Set α) (f : α → E) (x : α) :\n    edist (s.mulIndicator f x) (t.mulIndicator f x) = ‖(s ∆ t).mulIndicator f x‖₊ := by\n  rw [edist_nndist, nndist_mulIndicator]\n\n"}
{"name":"enorm_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\n⊢ Eq (ENorm.enorm 0) 0","decl":"@[to_additive (attr := simp) enorm_zero] lemma enorm_one' : ‖(1 : E)‖ₑ = 0 := by simp [enorm]\n\n"}
{"name":"enorm_one'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\n⊢ Eq (ENorm.enorm 1) 0","decl":"@[to_additive (attr := simp) enorm_zero] lemma enorm_one' : ‖(1 : E)‖ₑ = 0 := by simp [enorm]\n\n"}
{"name":"ofReal_norm_eq_enorm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\n⊢ Eq (ENNReal.ofReal (Norm.norm a)) (ENorm.enorm a)","decl":"@[to_additive ofReal_norm_eq_enorm]\nlemma ofReal_norm_eq_enorm' (a : E) : .ofReal ‖a‖ = ‖a‖ₑ := ENNReal.ofReal_eq_coe_nnreal _\n\n"}
{"name":"ofReal_norm_eq_enorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\n⊢ Eq (ENNReal.ofReal (Norm.norm a)) (ENorm.enorm a)","decl":"@[to_additive ofReal_norm_eq_enorm]\nlemma ofReal_norm_eq_enorm' (a : E) : .ofReal ‖a‖ = ‖a‖ₑ := ENNReal.ofReal_eq_coe_nnreal _\n\n"}
{"name":"ofReal_norm_eq_coe_nnnorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\n⊢ Eq (ENNReal.ofReal (Norm.norm a)) (ENorm.enorm a)","decl":"@[deprecated (since := \"2025-01-17\")] alias ofReal_norm_eq_coe_nnnorm := ofReal_norm_eq_enorm\n"}
{"name":"ofReal_norm_eq_coe_nnnorm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\n⊢ Eq (ENNReal.ofReal (Norm.norm a)) (ENorm.enorm a)","decl":"@[deprecated (since := \"2025-01-17\")] alias ofReal_norm_eq_coe_nnnorm' := ofReal_norm_eq_enorm'\n\n"}
{"name":"enorm_eq_self","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"x : ENNReal\n⊢ Eq (ENorm.enorm x) x","decl":"@[simp] lemma enorm_eq_self (x : ℝ≥0∞) : ‖x‖ₑ = x := rfl\n\n"}
{"name":"edist_eq_enorm_sub","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ Eq (EDist.edist a b) (ENorm.enorm (HSub.hSub a b))","decl":"@[to_additive]\ntheorem edist_eq_enorm_div (a b : E) : edist a b = ‖a / b‖ₑ := by\n  rw [edist_dist, dist_eq_norm_div, ofReal_norm_eq_enorm']\n\n"}
{"name":"edist_eq_enorm_div","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\n⊢ Eq (EDist.edist a b) (ENorm.enorm (HDiv.hDiv a b))","decl":"@[to_additive]\ntheorem edist_eq_enorm_div (a b : E) : edist a b = ‖a / b‖ₑ := by\n  rw [edist_dist, dist_eq_norm_div, ofReal_norm_eq_enorm']\n\n"}
{"name":"edist_eq_coe_nnnorm_sub","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na b : E\n⊢ Eq (EDist.edist a b) (ENorm.enorm (HSub.hSub a b))","decl":"@[deprecated (since := \"2025-01-17\")] alias edist_eq_coe_nnnorm_sub := edist_eq_enorm_sub\n"}
{"name":"edist_eq_coe_nnnorm_div","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na b : E\n⊢ Eq (EDist.edist a b) (ENorm.enorm (HDiv.hDiv a b))","decl":"@[deprecated (since := \"2025-01-17\")] alias edist_eq_coe_nnnorm_div := edist_eq_enorm_div\n\n"}
{"name":"edist_one_eq_enorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nx : E\n⊢ Eq (EDist.edist x 1) (ENorm.enorm x)","decl":"@[to_additive]\ntheorem edist_one_eq_enorm (x : E) : edist x 1 = ‖x‖ₑ := by rw [edist_eq_enorm_div, div_one]\n\n"}
{"name":"edist_zero_eq_enorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nx : E\n⊢ Eq (EDist.edist x 0) (ENorm.enorm x)","decl":"@[to_additive]\ntheorem edist_one_eq_enorm (x : E) : edist x 1 = ‖x‖ₑ := by rw [edist_eq_enorm_div, div_one]\n\n"}
{"name":"edist_eq_coe_nnnorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nx : E\n⊢ Eq (EDist.edist x 0) (ENorm.enorm x)","decl":"@[deprecated (since := \"2025-01-17\")] alias edist_eq_coe_nnnorm := edist_zero_eq_enorm\n"}
{"name":"edist_eq_coe_nnnorm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nx : E\n⊢ Eq (EDist.edist x 1) (ENorm.enorm x)","decl":"@[deprecated (since := \"2025-01-17\")] alias edist_eq_coe_nnnorm' := edist_one_eq_enorm\n\n"}
{"name":"mem_emetric_ball_one_iff","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\na : E\nr : ENNReal\n⊢ Iff (Membership.mem (EMetric.ball 1 r) a) (LT.lt (ENorm.enorm a) r)","decl":"@[to_additive]\ntheorem mem_emetric_ball_one_iff {r : ℝ≥0∞} : a ∈ EMetric.ball 1 r ↔ ‖a‖ₑ < r := by\n  rw [EMetric.mem_ball, edist_one_eq_enorm]\n\n"}
{"name":"mem_emetric_ball_zero_iff","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\nr : ENNReal\n⊢ Iff (Membership.mem (EMetric.ball 0 r) a) (LT.lt (ENorm.enorm a) r)","decl":"@[to_additive]\ntheorem mem_emetric_ball_one_iff {r : ℝ≥0∞} : a ∈ EMetric.ball 1 r ↔ ‖a‖ₑ < r := by\n  rw [EMetric.mem_ball, edist_one_eq_enorm]\n\n"}
{"name":"tendsto_iff_norm_div_tendsto_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝ : SeminormedGroup E\nf : α → E\na : Filter α\nb : E\n⊢ Iff (Filter.Tendsto f a (nhds b)) (Filter.Tendsto (fun e => Norm.norm (HDiv.hDiv (f e) b)) a (nhds 0))","decl":"@[to_additive]\ntheorem tendsto_iff_norm_div_tendsto_zero {f : α → E} {a : Filter α} {b : E} :\n    Tendsto f a (𝓝 b) ↔ Tendsto (fun e => ‖f e / b‖) a (𝓝 0) := by\n  simp only [← dist_eq_norm_div, ← tendsto_iff_dist_tendsto_zero]\n\n"}
{"name":"tendsto_iff_norm_sub_tendsto_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝ : SeminormedAddGroup E\nf : α → E\na : Filter α\nb : E\n⊢ Iff (Filter.Tendsto f a (nhds b)) (Filter.Tendsto (fun e => Norm.norm (HSub.hSub (f e) b)) a (nhds 0))","decl":"@[to_additive]\ntheorem tendsto_iff_norm_div_tendsto_zero {f : α → E} {a : Filter α} {b : E} :\n    Tendsto f a (𝓝 b) ↔ Tendsto (fun e => ‖f e / b‖) a (𝓝 0) := by\n  simp only [← dist_eq_norm_div, ← tendsto_iff_dist_tendsto_zero]\n\n"}
{"name":"tendsto_one_iff_norm_tendsto_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝ : SeminormedGroup E\nf : α → E\na : Filter α\n⊢ Iff (Filter.Tendsto f a (nhds 1)) (Filter.Tendsto (fun x => Norm.norm (f x)) a (nhds 0))","decl":"@[to_additive]\ntheorem tendsto_one_iff_norm_tendsto_zero {f : α → E} {a : Filter α} :\n    Tendsto f a (𝓝 1) ↔ Tendsto (‖f ·‖) a (𝓝 0) :=\n  tendsto_iff_norm_div_tendsto_zero.trans <| by simp only [div_one]\n\n"}
{"name":"tendsto_zero_iff_norm_tendsto_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝ : SeminormedAddGroup E\nf : α → E\na : Filter α\n⊢ Iff (Filter.Tendsto f a (nhds 0)) (Filter.Tendsto (fun x => Norm.norm (f x)) a (nhds 0))","decl":"@[to_additive]\ntheorem tendsto_one_iff_norm_tendsto_zero {f : α → E} {a : Filter α} :\n    Tendsto f a (𝓝 1) ↔ Tendsto (‖f ·‖) a (𝓝 0) :=\n  tendsto_iff_norm_div_tendsto_zero.trans <| by simp only [div_one]\n\n"}
{"name":"comap_norm_nhds_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\n⊢ Eq (Filter.comap Norm.norm (nhds 0)) (nhds 0)","decl":"@[to_additive]\ntheorem comap_norm_nhds_one : comap norm (𝓝 0) = 𝓝 (1 : E) := by\n  simpa only [dist_one_right] using nhds_comap_dist (1 : E)\n\n"}
{"name":"comap_norm_nhds_one","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\n⊢ Eq (Filter.comap Norm.norm (nhds 0)) (nhds 1)","decl":"@[to_additive]\ntheorem comap_norm_nhds_one : comap norm (𝓝 0) = 𝓝 (1 : E) := by\n  simpa only [dist_one_right] using nhds_comap_dist (1 : E)\n\n"}
{"name":"squeeze_one_norm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝ : SeminormedGroup E\nf : α → E\na : α → Real\nt₀ : Filter α\nh : Filter.Eventually (fun n => LE.le (Norm.norm (f n)) (a n)) t₀\nh' : Filter.Tendsto a t₀ (nhds 0)\n⊢ Filter.Tendsto f t₀ (nhds 1)","decl":"/-- Special case of the sandwich theorem: if the norm of `f` is eventually bounded by a real\nfunction `a` which tends to `0`, then `f` tends to `1` (neutral element of `SeminormedGroup`).\nIn this pair of lemmas (`squeeze_one_norm'` and `squeeze_one_norm`), following a convention of\nsimilar lemmas in `Topology.MetricSpace.Basic` and `Topology.Algebra.Order`, the `'` version is\nphrased using \"eventually\" and the non-`'` version is phrased absolutely. -/\n@[to_additive \"Special case of the sandwich theorem: if the norm of `f` is eventually bounded by a\nreal function `a` which tends to `0`, then `f` tends to `0`. In this pair of lemmas\n(`squeeze_zero_norm'` and `squeeze_zero_norm`), following a convention of similar lemmas in\n`Topology.MetricSpace.Pseudo.Defs` and `Topology.Algebra.Order`, the `'` version is phrased using\n\\\"eventually\\\" and the non-`'` version is phrased absolutely.\"]\ntheorem squeeze_one_norm' {f : α → E} {a : α → ℝ} {t₀ : Filter α} (h : ∀ᶠ n in t₀, ‖f n‖ ≤ a n)\n    (h' : Tendsto a t₀ (𝓝 0)) : Tendsto f t₀ (𝓝 1) :=\n  tendsto_one_iff_norm_tendsto_zero.2 <|\n    squeeze_zero' (Eventually.of_forall fun _n => norm_nonneg' _) h h'\n\n"}
{"name":"squeeze_zero_norm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝ : SeminormedAddGroup E\nf : α → E\na : α → Real\nt₀ : Filter α\nh : Filter.Eventually (fun n => LE.le (Norm.norm (f n)) (a n)) t₀\nh' : Filter.Tendsto a t₀ (nhds 0)\n⊢ Filter.Tendsto f t₀ (nhds 0)","decl":"/-- Special case of the sandwich theorem: if the norm of `f` is eventually bounded by a real\nfunction `a` which tends to `0`, then `f` tends to `1` (neutral element of `SeminormedGroup`).\nIn this pair of lemmas (`squeeze_one_norm'` and `squeeze_one_norm`), following a convention of\nsimilar lemmas in `Topology.MetricSpace.Basic` and `Topology.Algebra.Order`, the `'` version is\nphrased using \"eventually\" and the non-`'` version is phrased absolutely. -/\n@[to_additive \"Special case of the sandwich theorem: if the norm of `f` is eventually bounded by a\nreal function `a` which tends to `0`, then `f` tends to `0`. In this pair of lemmas\n(`squeeze_zero_norm'` and `squeeze_zero_norm`), following a convention of similar lemmas in\n`Topology.MetricSpace.Pseudo.Defs` and `Topology.Algebra.Order`, the `'` version is phrased using\n\\\"eventually\\\" and the non-`'` version is phrased absolutely.\"]\ntheorem squeeze_one_norm' {f : α → E} {a : α → ℝ} {t₀ : Filter α} (h : ∀ᶠ n in t₀, ‖f n‖ ≤ a n)\n    (h' : Tendsto a t₀ (𝓝 0)) : Tendsto f t₀ (𝓝 1) :=\n  tendsto_one_iff_norm_tendsto_zero.2 <|\n    squeeze_zero' (Eventually.of_forall fun _n => norm_nonneg' _) h h'\n\n"}
{"name":"squeeze_zero_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝ : SeminormedAddGroup E\nf : α → E\na : α → Real\nt₀ : Filter α\nh : ∀ (n : α), LE.le (Norm.norm (f n)) (a n)\na✝ : Filter.Tendsto a t₀ (nhds 0)\n⊢ Filter.Tendsto f t₀ (nhds 0)","decl":"/-- Special case of the sandwich theorem: if the norm of `f` is bounded by a real function `a` which\ntends to `0`, then `f` tends to `1`. -/\n@[to_additive \"Special case of the sandwich theorem: if the norm of `f` is bounded by a real\nfunction `a` which tends to `0`, then `f` tends to `0`.\"]\ntheorem squeeze_one_norm {f : α → E} {a : α → ℝ} {t₀ : Filter α} (h : ∀ n, ‖f n‖ ≤ a n) :\n    Tendsto a t₀ (𝓝 0) → Tendsto f t₀ (𝓝 1) :=\n  squeeze_one_norm' <| Eventually.of_forall h\n\n"}
{"name":"squeeze_one_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝ : SeminormedGroup E\nf : α → E\na : α → Real\nt₀ : Filter α\nh : ∀ (n : α), LE.le (Norm.norm (f n)) (a n)\na✝ : Filter.Tendsto a t₀ (nhds 0)\n⊢ Filter.Tendsto f t₀ (nhds 1)","decl":"/-- Special case of the sandwich theorem: if the norm of `f` is bounded by a real function `a` which\ntends to `0`, then `f` tends to `1`. -/\n@[to_additive \"Special case of the sandwich theorem: if the norm of `f` is bounded by a real\nfunction `a` which tends to `0`, then `f` tends to `0`.\"]\ntheorem squeeze_one_norm {f : α → E} {a : α → ℝ} {t₀ : Filter α} (h : ∀ n, ‖f n‖ ≤ a n) :\n    Tendsto a t₀ (𝓝 0) → Tendsto f t₀ (𝓝 1) :=\n  squeeze_one_norm' <| Eventually.of_forall h\n\n"}
{"name":"tendsto_norm_div_self","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nx : E\n⊢ Filter.Tendsto (fun a => Norm.norm (HDiv.hDiv a x)) (nhds x) (nhds 0)","decl":"@[to_additive]\ntheorem tendsto_norm_div_self (x : E) : Tendsto (fun a => ‖a / x‖) (𝓝 x) (𝓝 0) := by\n  simpa [dist_eq_norm_div] using\n    tendsto_id.dist (tendsto_const_nhds : Tendsto (fun _a => (x : E)) (𝓝 x) _)\n\n"}
{"name":"tendsto_norm_sub_self","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nx : E\n⊢ Filter.Tendsto (fun a => Norm.norm (HSub.hSub a x)) (nhds x) (nhds 0)","decl":"@[to_additive]\ntheorem tendsto_norm_div_self (x : E) : Tendsto (fun a => ‖a / x‖) (𝓝 x) (𝓝 0) := by\n  simpa [dist_eq_norm_div] using\n    tendsto_id.dist (tendsto_const_nhds : Tendsto (fun _a => (x : E)) (𝓝 x) _)\n\n"}
{"name":"tendsto_norm_div_self_nhdsGE","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nx : E\n⊢ Filter.Tendsto (fun a => Norm.norm (HDiv.hDiv a x)) (nhds x) (nhdsWithin 0 (Set.Ici 0))","decl":"@[to_additive]\ntheorem tendsto_norm_div_self_nhdsGE (x : E) : Tendsto (fun a ↦ ‖a / x‖) (𝓝 x) (𝓝[≥] 0) :=\n  tendsto_nhdsWithin_iff.mpr ⟨tendsto_norm_div_self x, by simp⟩\n\n"}
{"name":"tendsto_norm_sub_self_nhdsGE","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nx : E\n⊢ Filter.Tendsto (fun a => Norm.norm (HSub.hSub a x)) (nhds x) (nhdsWithin 0 (Set.Ici 0))","decl":"@[to_additive]\ntheorem tendsto_norm_div_self_nhdsGE (x : E) : Tendsto (fun a ↦ ‖a / x‖) (𝓝 x) (𝓝[≥] 0) :=\n  tendsto_nhdsWithin_iff.mpr ⟨tendsto_norm_div_self x, by simp⟩\n\n"}
{"name":"tendsto_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nx : E\n⊢ Filter.Tendsto (fun a => Norm.norm a) (nhds x) (nhds (Norm.norm x))","decl":"@[to_additive tendsto_norm]\ntheorem tendsto_norm' {x : E} : Tendsto (fun a => ‖a‖) (𝓝 x) (𝓝 ‖x‖) := by\n  simpa using tendsto_id.dist (tendsto_const_nhds : Tendsto (fun _a => (1 : E)) _ _)\n\n"}
{"name":"tendsto_norm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nx : E\n⊢ Filter.Tendsto (fun a => Norm.norm a) (nhds x) (nhds (Norm.norm x))","decl":"@[to_additive tendsto_norm]\ntheorem tendsto_norm' {x : E} : Tendsto (fun a => ‖a‖) (𝓝 x) (𝓝 ‖x‖) := by\n  simpa using tendsto_id.dist (tendsto_const_nhds : Tendsto (fun _a => (1 : E)) _ _)\n\n"}
{"name":"tendsto_norm_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\n⊢ Filter.Tendsto (fun a => Norm.norm a) (nhds 0) (nhds 0)","decl":"/-- See `tendsto_norm_one` for a version with pointed neighborhoods. -/\n@[to_additive \"See `tendsto_norm_zero` for a version with pointed neighborhoods.\"]\ntheorem tendsto_norm_one : Tendsto (fun a : E => ‖a‖) (𝓝 1) (𝓝 0) := by\n  simpa using tendsto_norm_div_self (1 : E)\n\n"}
{"name":"tendsto_norm_one","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\n⊢ Filter.Tendsto (fun a => Norm.norm a) (nhds 1) (nhds 0)","decl":"/-- See `tendsto_norm_one` for a version with pointed neighborhoods. -/\n@[to_additive \"See `tendsto_norm_zero` for a version with pointed neighborhoods.\"]\ntheorem tendsto_norm_one : Tendsto (fun a : E => ‖a‖) (𝓝 1) (𝓝 0) := by\n  simpa using tendsto_norm_div_self (1 : E)\n\n"}
{"name":"continuous_norm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\n⊢ Continuous fun a => Norm.norm a","decl":"@[to_additive (attr := continuity) continuous_norm]\ntheorem continuous_norm' : Continuous fun a : E => ‖a‖ := by\n  simpa using continuous_id.dist (continuous_const : Continuous fun _a => (1 : E))\n\n"}
{"name":"continuous_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\n⊢ Continuous fun a => Norm.norm a","decl":"@[to_additive (attr := continuity) continuous_norm]\ntheorem continuous_norm' : Continuous fun a : E => ‖a‖ := by\n  simpa using continuous_id.dist (continuous_const : Continuous fun _a => (1 : E))\n\n"}
{"name":"continuous_nnnorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\n⊢ Continuous fun a => NNNorm.nnnorm a","decl":"@[to_additive (attr := continuity) continuous_nnnorm]\ntheorem continuous_nnnorm' : Continuous fun a : E => ‖a‖₊ :=\n  continuous_norm'.subtype_mk _\n\n"}
{"name":"continuous_nnnorm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\n⊢ Continuous fun a => NNNorm.nnnorm a","decl":"@[to_additive (attr := continuity) continuous_nnnorm]\ntheorem continuous_nnnorm' : Continuous fun a : E => ‖a‖₊ :=\n  continuous_norm'.subtype_mk _\n\n"}
{"name":"continuous_enorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\n⊢ Continuous fun a => ENorm.enorm a","decl":"@[to_additive (attr := continuity) continuous_enorm]\nlemma continuous_enorm' : Continuous fun a : E ↦ ‖a‖ₑ :=\n  ENNReal.isOpenEmbedding_coe.continuous.comp continuous_nnnorm'\n\n"}
{"name":"continuous_enorm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\n⊢ Continuous fun a => ENorm.enorm a","decl":"@[to_additive (attr := continuity) continuous_enorm]\nlemma continuous_enorm' : Continuous fun a : E ↦ ‖a‖ₑ :=\n  ENNReal.isOpenEmbedding_coe.continuous.comp continuous_nnnorm'\n\n"}
{"name":"Inseparable.norm_eq_norm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nu v : E\nh : Inseparable u v\n⊢ Eq (Norm.norm u) (Norm.norm v)","decl":"set_option linter.docPrime false in\n@[to_additive Inseparable.norm_eq_norm]\ntheorem Inseparable.norm_eq_norm' {u v : E} (h : Inseparable u v) : ‖u‖ = ‖v‖ :=\n  h.map continuous_norm' |>.eq\n\n"}
{"name":"Inseparable.norm_eq_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nu v : E\nh : Inseparable u v\n⊢ Eq (Norm.norm u) (Norm.norm v)","decl":"set_option linter.docPrime false in\n@[to_additive Inseparable.norm_eq_norm]\ntheorem Inseparable.norm_eq_norm' {u v : E} (h : Inseparable u v) : ‖u‖ = ‖v‖ :=\n  h.map continuous_norm' |>.eq\n\n"}
{"name":"Inseparable.nnnorm_eq_nnnorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nu v : E\nh : Inseparable u v\n⊢ Eq (NNNorm.nnnorm u) (NNNorm.nnnorm v)","decl":"set_option linter.docPrime false in\n@[to_additive Inseparable.nnnorm_eq_nnnorm]\ntheorem Inseparable.nnnorm_eq_nnnorm' {u v : E} (h : Inseparable u v) : ‖u‖₊ = ‖v‖₊ :=\n  h.map continuous_nnnorm' |>.eq\n\n"}
{"name":"Inseparable.nnnorm_eq_nnnorm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nu v : E\nh : Inseparable u v\n⊢ Eq (NNNorm.nnnorm u) (NNNorm.nnnorm v)","decl":"set_option linter.docPrime false in\n@[to_additive Inseparable.nnnorm_eq_nnnorm]\ntheorem Inseparable.nnnorm_eq_nnnorm' {u v : E} (h : Inseparable u v) : ‖u‖₊ = ‖v‖₊ :=\n  h.map continuous_nnnorm' |>.eq\n\n"}
{"name":"mem_closure_one_iff_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\nx : E\n⊢ Iff (Membership.mem (closure (Singleton.singleton 1)) x) (Eq (Norm.norm x) 0)","decl":"@[to_additive]\ntheorem mem_closure_one_iff_norm {x : E} : x ∈ closure ({1} : Set E) ↔ ‖x‖ = 0 := by\n  rw [← closedBall_zero', mem_closedBall_one_iff, (norm_nonneg' x).le_iff_eq]\n\n"}
{"name":"mem_closure_zero_iff_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\nx : E\n⊢ Iff (Membership.mem (closure (Singleton.singleton 0)) x) (Eq (Norm.norm x) 0)","decl":"@[to_additive]\ntheorem mem_closure_one_iff_norm {x : E} : x ∈ closure ({1} : Set E) ↔ ‖x‖ = 0 := by\n  rw [← closedBall_zero', mem_closedBall_one_iff, (norm_nonneg' x).le_iff_eq]\n\n"}
{"name":"closure_one_eq","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\n⊢ Eq (closure (Singleton.singleton 1)) (setOf fun x => Eq (Norm.norm x) 0)","decl":"@[to_additive]\ntheorem closure_one_eq : closure ({1} : Set E) = { x | ‖x‖ = 0 } :=\n  Set.ext fun _x => mem_closure_one_iff_norm\n\n"}
{"name":"closure_zero_eq","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\n⊢ Eq (closure (Singleton.singleton 0)) (setOf fun x => Eq (Norm.norm x) 0)","decl":"@[to_additive]\ntheorem closure_one_eq : closure ({1} : Set E) = { x | ‖x‖ = 0 } :=\n  Set.ext fun _x => mem_closure_one_iff_norm\n\n"}
{"name":"Filter.Tendsto.norm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝ : SeminormedGroup E\na : E\nl : Filter α\nf : α → E\nh : Filter.Tendsto f l (nhds a)\n⊢ Filter.Tendsto (fun x => Norm.norm (f x)) l (nhds (Norm.norm a))","decl":"@[to_additive Filter.Tendsto.norm]\ntheorem Filter.Tendsto.norm' (h : Tendsto f l (𝓝 a)) : Tendsto (fun x => ‖f x‖) l (𝓝 ‖a‖) :=\n  tendsto_norm'.comp h\n\n"}
{"name":"Filter.Tendsto.norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\nl : Filter α\nf : α → E\nh : Filter.Tendsto f l (nhds a)\n⊢ Filter.Tendsto (fun x => Norm.norm (f x)) l (nhds (Norm.norm a))","decl":"@[to_additive Filter.Tendsto.norm]\ntheorem Filter.Tendsto.norm' (h : Tendsto f l (𝓝 a)) : Tendsto (fun x => ‖f x‖) l (𝓝 ‖a‖) :=\n  tendsto_norm'.comp h\n\n"}
{"name":"Filter.Tendsto.nnnorm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝ : SeminormedGroup E\na : E\nl : Filter α\nf : α → E\nh : Filter.Tendsto f l (nhds a)\n⊢ Filter.Tendsto (fun x => NNNorm.nnnorm (f x)) l (nhds (NNNorm.nnnorm a))","decl":"@[to_additive Filter.Tendsto.nnnorm]\ntheorem Filter.Tendsto.nnnorm' (h : Tendsto f l (𝓝 a)) : Tendsto (fun x => ‖f x‖₊) l (𝓝 ‖a‖₊) :=\n  Tendsto.comp continuous_nnnorm'.continuousAt h\n\n"}
{"name":"Filter.Tendsto.nnnorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\nl : Filter α\nf : α → E\nh : Filter.Tendsto f l (nhds a)\n⊢ Filter.Tendsto (fun x => NNNorm.nnnorm (f x)) l (nhds (NNNorm.nnnorm a))","decl":"@[to_additive Filter.Tendsto.nnnorm]\ntheorem Filter.Tendsto.nnnorm' (h : Tendsto f l (𝓝 a)) : Tendsto (fun x => ‖f x‖₊) l (𝓝 ‖a‖₊) :=\n  Tendsto.comp continuous_nnnorm'.continuousAt h\n\n"}
{"name":"Filter.Tendsto.enorm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝ : SeminormedGroup E\na : E\nl : Filter α\nf : α → E\nh : Filter.Tendsto f l (nhds a)\n⊢ Filter.Tendsto (fun x => ENorm.enorm (f x)) l (nhds (ENorm.enorm a))","decl":"@[to_additive Filter.Tendsto.enorm]\nlemma Filter.Tendsto.enorm' (h : Tendsto f l (𝓝 a)) : Tendsto (‖f ·‖ₑ) l (𝓝 ‖a‖ₑ) :=\n  .comp continuous_enorm'.continuousAt h\n\n"}
{"name":"Filter.Tendsto.enorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝ : SeminormedAddGroup E\na : E\nl : Filter α\nf : α → E\nh : Filter.Tendsto f l (nhds a)\n⊢ Filter.Tendsto (fun x => ENorm.enorm (f x)) l (nhds (ENorm.enorm a))","decl":"@[to_additive Filter.Tendsto.enorm]\nlemma Filter.Tendsto.enorm' (h : Tendsto f l (𝓝 a)) : Tendsto (‖f ·‖ₑ) l (𝓝 ‖a‖ₑ) :=\n  .comp continuous_enorm'.continuousAt h\n\n"}
{"name":"Continuous.norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : SeminormedAddGroup E\ninst✝ : TopologicalSpace α\nf : α → E\na✝ : Continuous f\n⊢ Continuous fun x => Norm.norm (f x)","decl":"@[to_additive (attr := fun_prop) Continuous.norm]\ntheorem Continuous.norm' : Continuous f → Continuous fun x => ‖f x‖ :=\n  continuous_norm'.comp\n\n"}
{"name":"Continuous.norm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : SeminormedGroup E\ninst✝ : TopologicalSpace α\nf : α → E\na✝ : Continuous f\n⊢ Continuous fun x => Norm.norm (f x)","decl":"@[to_additive (attr := fun_prop) Continuous.norm]\ntheorem Continuous.norm' : Continuous f → Continuous fun x => ‖f x‖ :=\n  continuous_norm'.comp\n\n"}
{"name":"Continuous.nnnorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : SeminormedAddGroup E\ninst✝ : TopologicalSpace α\nf : α → E\na✝ : Continuous f\n⊢ Continuous fun x => NNNorm.nnnorm (f x)","decl":"@[to_additive (attr := fun_prop) Continuous.nnnorm]\ntheorem Continuous.nnnorm' : Continuous f → Continuous fun x => ‖f x‖₊ :=\n  continuous_nnnorm'.comp\n\n"}
{"name":"Continuous.nnnorm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : SeminormedGroup E\ninst✝ : TopologicalSpace α\nf : α → E\na✝ : Continuous f\n⊢ Continuous fun x => NNNorm.nnnorm (f x)","decl":"@[to_additive (attr := fun_prop) Continuous.nnnorm]\ntheorem Continuous.nnnorm' : Continuous f → Continuous fun x => ‖f x‖₊ :=\n  continuous_nnnorm'.comp\n\n"}
{"name":"Continuous.enorm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : SeminormedGroup E\ninst✝ : TopologicalSpace α\nf : α → E\na✝ : Continuous f\n⊢ Continuous fun x => ENorm.enorm (f x)","decl":"@[to_additive (attr := fun_prop) Continuous.enorm]\nlemma Continuous.enorm' : Continuous f → Continuous (‖f ·‖ₑ) := continuous_enorm'.comp\n\n"}
{"name":"Continuous.enorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : SeminormedAddGroup E\ninst✝ : TopologicalSpace α\nf : α → E\na✝ : Continuous f\n⊢ Continuous fun x => ENorm.enorm (f x)","decl":"@[to_additive (attr := fun_prop) Continuous.enorm]\nlemma Continuous.enorm' : Continuous f → Continuous (‖f ·‖ₑ) := continuous_enorm'.comp\n\n"}
{"name":"ContinuousAt.norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : SeminormedAddGroup E\ninst✝ : TopologicalSpace α\nf : α → E\na : α\nh : ContinuousAt f a\n⊢ ContinuousAt (fun x => Norm.norm (f x)) a","decl":"@[to_additive (attr := fun_prop) ContinuousAt.norm]\ntheorem ContinuousAt.norm' {a : α} (h : ContinuousAt f a) : ContinuousAt (fun x => ‖f x‖) a :=\n  Tendsto.norm' h\n\n"}
{"name":"ContinuousAt.norm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : SeminormedGroup E\ninst✝ : TopologicalSpace α\nf : α → E\na : α\nh : ContinuousAt f a\n⊢ ContinuousAt (fun x => Norm.norm (f x)) a","decl":"@[to_additive (attr := fun_prop) ContinuousAt.norm]\ntheorem ContinuousAt.norm' {a : α} (h : ContinuousAt f a) : ContinuousAt (fun x => ‖f x‖) a :=\n  Tendsto.norm' h\n\n"}
{"name":"ContinuousAt.nnnorm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : SeminormedGroup E\ninst✝ : TopologicalSpace α\nf : α → E\na : α\nh : ContinuousAt f a\n⊢ ContinuousAt (fun x => NNNorm.nnnorm (f x)) a","decl":"@[to_additive (attr := fun_prop) ContinuousAt.nnnorm]\ntheorem ContinuousAt.nnnorm' {a : α} (h : ContinuousAt f a) : ContinuousAt (fun x => ‖f x‖₊) a :=\n  Tendsto.nnnorm' h\n\n"}
{"name":"ContinuousAt.nnnorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : SeminormedAddGroup E\ninst✝ : TopologicalSpace α\nf : α → E\na : α\nh : ContinuousAt f a\n⊢ ContinuousAt (fun x => NNNorm.nnnorm (f x)) a","decl":"@[to_additive (attr := fun_prop) ContinuousAt.nnnorm]\ntheorem ContinuousAt.nnnorm' {a : α} (h : ContinuousAt f a) : ContinuousAt (fun x => ‖f x‖₊) a :=\n  Tendsto.nnnorm' h\n\n"}
{"name":"ContinuousAt.enorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : SeminormedAddGroup E\ninst✝ : TopologicalSpace α\nf : α → E\na : α\nh : ContinuousAt f a\n⊢ ContinuousAt (fun x => ENorm.enorm (f x)) a","decl":"@[to_additive (attr := fun_prop) ContinuousAt.enorm]\nlemma ContinuousAt.enorm' (h : ContinuousAt f a) : ContinuousAt (‖f ·‖ₑ) a := Tendsto.enorm' h\n\n"}
{"name":"ContinuousAt.enorm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : SeminormedGroup E\ninst✝ : TopologicalSpace α\nf : α → E\na : α\nh : ContinuousAt f a\n⊢ ContinuousAt (fun x => ENorm.enorm (f x)) a","decl":"@[to_additive (attr := fun_prop) ContinuousAt.enorm]\nlemma ContinuousAt.enorm' (h : ContinuousAt f a) : ContinuousAt (‖f ·‖ₑ) a := Tendsto.enorm' h\n\n"}
{"name":"ContinuousWithinAt.norm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : SeminormedGroup E\ninst✝ : TopologicalSpace α\nf : α → E\ns : Set α\na : α\nh : ContinuousWithinAt f s a\n⊢ ContinuousWithinAt (fun x => Norm.norm (f x)) s a","decl":"@[to_additive ContinuousWithinAt.norm]\ntheorem ContinuousWithinAt.norm' {s : Set α} {a : α} (h : ContinuousWithinAt f s a) :\n    ContinuousWithinAt (fun x => ‖f x‖) s a :=\n  Tendsto.norm' h\n\n"}
{"name":"ContinuousWithinAt.norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : SeminormedAddGroup E\ninst✝ : TopologicalSpace α\nf : α → E\ns : Set α\na : α\nh : ContinuousWithinAt f s a\n⊢ ContinuousWithinAt (fun x => Norm.norm (f x)) s a","decl":"@[to_additive ContinuousWithinAt.norm]\ntheorem ContinuousWithinAt.norm' {s : Set α} {a : α} (h : ContinuousWithinAt f s a) :\n    ContinuousWithinAt (fun x => ‖f x‖) s a :=\n  Tendsto.norm' h\n\n"}
{"name":"ContinuousWithinAt.nnnorm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : SeminormedGroup E\ninst✝ : TopologicalSpace α\nf : α → E\ns : Set α\na : α\nh : ContinuousWithinAt f s a\n⊢ ContinuousWithinAt (fun x => NNNorm.nnnorm (f x)) s a","decl":"@[to_additive ContinuousWithinAt.nnnorm]\ntheorem ContinuousWithinAt.nnnorm' {s : Set α} {a : α} (h : ContinuousWithinAt f s a) :\n    ContinuousWithinAt (fun x => ‖f x‖₊) s a :=\n  Tendsto.nnnorm' h\n\n"}
{"name":"ContinuousWithinAt.nnnorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : SeminormedAddGroup E\ninst✝ : TopologicalSpace α\nf : α → E\ns : Set α\na : α\nh : ContinuousWithinAt f s a\n⊢ ContinuousWithinAt (fun x => NNNorm.nnnorm (f x)) s a","decl":"@[to_additive ContinuousWithinAt.nnnorm]\ntheorem ContinuousWithinAt.nnnorm' {s : Set α} {a : α} (h : ContinuousWithinAt f s a) :\n    ContinuousWithinAt (fun x => ‖f x‖₊) s a :=\n  Tendsto.nnnorm' h\n\n"}
{"name":"ContinuousWithinAt.enorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : SeminormedAddGroup E\ninst✝ : TopologicalSpace α\nf : α → E\ns : Set α\na : α\nh : ContinuousWithinAt f s a\n⊢ ContinuousWithinAt (fun x => ENorm.enorm (f x)) s a","decl":"@[to_additive ContinuousWithinAt.enorm]\nlemma ContinuousWithinAt.enorm' (h : ContinuousWithinAt f s a) : ContinuousWithinAt (‖f ·‖ₑ) s a :=\n  Tendsto.enorm' h\n\n"}
{"name":"ContinuousWithinAt.enorm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : SeminormedGroup E\ninst✝ : TopologicalSpace α\nf : α → E\ns : Set α\na : α\nh : ContinuousWithinAt f s a\n⊢ ContinuousWithinAt (fun x => ENorm.enorm (f x)) s a","decl":"@[to_additive ContinuousWithinAt.enorm]\nlemma ContinuousWithinAt.enorm' (h : ContinuousWithinAt f s a) : ContinuousWithinAt (‖f ·‖ₑ) s a :=\n  Tendsto.enorm' h\n\n"}
{"name":"ContinuousOn.norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : SeminormedAddGroup E\ninst✝ : TopologicalSpace α\nf : α → E\ns : Set α\nh : ContinuousOn f s\n⊢ ContinuousOn (fun x => Norm.norm (f x)) s","decl":"@[to_additive (attr := fun_prop) ContinuousOn.norm]\ntheorem ContinuousOn.norm' {s : Set α} (h : ContinuousOn f s) : ContinuousOn (fun x => ‖f x‖) s :=\n  fun x hx => (h x hx).norm'\n\n"}
{"name":"ContinuousOn.norm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : SeminormedGroup E\ninst✝ : TopologicalSpace α\nf : α → E\ns : Set α\nh : ContinuousOn f s\n⊢ ContinuousOn (fun x => Norm.norm (f x)) s","decl":"@[to_additive (attr := fun_prop) ContinuousOn.norm]\ntheorem ContinuousOn.norm' {s : Set α} (h : ContinuousOn f s) : ContinuousOn (fun x => ‖f x‖) s :=\n  fun x hx => (h x hx).norm'\n\n"}
{"name":"ContinuousOn.nnnorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : SeminormedAddGroup E\ninst✝ : TopologicalSpace α\nf : α → E\ns : Set α\nh : ContinuousOn f s\n⊢ ContinuousOn (fun x => NNNorm.nnnorm (f x)) s","decl":"@[to_additive (attr := fun_prop) ContinuousOn.nnnorm]\ntheorem ContinuousOn.nnnorm' {s : Set α} (h : ContinuousOn f s) :\n    ContinuousOn (fun x => ‖f x‖₊) s := fun x hx => (h x hx).nnnorm'\n\n"}
{"name":"ContinuousOn.nnnorm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : SeminormedGroup E\ninst✝ : TopologicalSpace α\nf : α → E\ns : Set α\nh : ContinuousOn f s\n⊢ ContinuousOn (fun x => NNNorm.nnnorm (f x)) s","decl":"@[to_additive (attr := fun_prop) ContinuousOn.nnnorm]\ntheorem ContinuousOn.nnnorm' {s : Set α} (h : ContinuousOn f s) :\n    ContinuousOn (fun x => ‖f x‖₊) s := fun x hx => (h x hx).nnnorm'\n\n"}
{"name":"ContinuousOn.enorm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : SeminormedGroup E\ninst✝ : TopologicalSpace α\nf : α → E\ns : Set α\nh : ContinuousOn f s\n⊢ ContinuousOn (fun x => ENorm.enorm (f x)) s","decl":"@[to_additive (attr := fun_prop) ContinuousOn.enorm]\nlemma ContinuousOn.enorm' (h : ContinuousOn f s) : ContinuousOn (‖f ·‖ₑ) s :=\n  fun x hx => (h x hx).enorm'\n\n"}
{"name":"ContinuousOn.enorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : SeminormedAddGroup E\ninst✝ : TopologicalSpace α\nf : α → E\ns : Set α\nh : ContinuousOn f s\n⊢ ContinuousOn (fun x => ENorm.enorm (f x)) s","decl":"@[to_additive (attr := fun_prop) ContinuousOn.enorm]\nlemma ContinuousOn.enorm' (h : ContinuousOn f s) : ContinuousOn (‖f ·‖ₑ) s :=\n  fun x hx => (h x hx).enorm'\n\n"}
{"name":"eventually_ne_of_tendsto_norm_atTop","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝ : SeminormedAddGroup E\nl : Filter α\nf : α → E\nh : Filter.Tendsto (fun y => Norm.norm (f y)) l Filter.atTop\nx : E\n⊢ Filter.Eventually (fun y => Ne (f y) x) l","decl":"/-- If `‖y‖ → ∞`, then we can assume `y ≠ x` for any fixed `x`. -/\n@[to_additive eventually_ne_of_tendsto_norm_atTop \"If `‖y‖→∞`, then we can assume `y≠x` for any\nfixed `x`\"]\ntheorem eventually_ne_of_tendsto_norm_atTop' {l : Filter α} {f : α → E}\n    (h : Tendsto (fun y => ‖f y‖) l atTop) (x : E) : ∀ᶠ y in l, f y ≠ x :=\n  (h.eventually_ne_atTop _).mono fun _x => ne_of_apply_ne norm\n\n"}
{"name":"eventually_ne_of_tendsto_norm_atTop'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝ : SeminormedGroup E\nl : Filter α\nf : α → E\nh : Filter.Tendsto (fun y => Norm.norm (f y)) l Filter.atTop\nx : E\n⊢ Filter.Eventually (fun y => Ne (f y) x) l","decl":"/-- If `‖y‖ → ∞`, then we can assume `y ≠ x` for any fixed `x`. -/\n@[to_additive eventually_ne_of_tendsto_norm_atTop \"If `‖y‖→∞`, then we can assume `y≠x` for any\nfixed `x`\"]\ntheorem eventually_ne_of_tendsto_norm_atTop' {l : Filter α} {f : α → E}\n    (h : Tendsto (fun y => ‖f y‖) l atTop) (x : E) : ∀ᶠ y in l, f y ≠ x :=\n  (h.eventually_ne_atTop _).mono fun _x => ne_of_apply_ne norm\n\n"}
{"name":"SeminormedAddCommGroup.mem_closure_iff","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\ns : Set E\na : E\n⊢ Iff (Membership.mem (closure s) a) (∀ (ε : Real), LT.lt 0 ε → Exists fun b => And (Membership.mem s b) (LT.lt (Norm.norm (HSub.hSub a b)) ε))","decl":"@[to_additive]\ntheorem SeminormedCommGroup.mem_closure_iff :\n    a ∈ closure s ↔ ∀ ε, 0 < ε → ∃ b ∈ s, ‖a / b‖ < ε := by\n  simp [Metric.mem_closure_iff, dist_eq_norm_div]\n\n"}
{"name":"SeminormedCommGroup.mem_closure_iff","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\ns : Set E\na : E\n⊢ Iff (Membership.mem (closure s) a) (∀ (ε : Real), LT.lt 0 ε → Exists fun b => And (Membership.mem s b) (LT.lt (Norm.norm (HDiv.hDiv a b)) ε))","decl":"@[to_additive]\ntheorem SeminormedCommGroup.mem_closure_iff :\n    a ∈ closure s ↔ ∀ ε, 0 < ε → ∃ b ∈ s, ‖a / b‖ < ε := by\n  simp [Metric.mem_closure_iff, dist_eq_norm_div]\n\n"}
{"name":"SeminormedAddGroup.tendstoUniformlyOn_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"ι : Type u_3\nκ : Type u_4\nG : Type u_7\ninst✝ : SeminormedAddGroup G\nf : ι → κ → G\ns : Set κ\nl : Filter ι\n⊢ Iff (TendstoUniformlyOn f 0 l s) (∀ (ε : Real), GT.gt ε 0 → Filter.Eventually (fun i => ∀ (x : κ), Membership.mem s x → LT.lt (Norm.norm (f i x)) ε) l)","decl":"@[to_additive]\ntheorem SeminormedGroup.tendstoUniformlyOn_one {f : ι → κ → G} {s : Set κ} {l : Filter ι} :\n    TendstoUniformlyOn f 1 l s ↔ ∀ ε > 0, ∀ᶠ i in l, ∀ x ∈ s, ‖f i x‖ < ε := by\n  simp only [tendstoUniformlyOn_iff, Pi.one_apply, dist_one_left]\n\n"}
{"name":"SeminormedGroup.tendstoUniformlyOn_one","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"ι : Type u_3\nκ : Type u_4\nG : Type u_7\ninst✝ : SeminormedGroup G\nf : ι → κ → G\ns : Set κ\nl : Filter ι\n⊢ Iff (TendstoUniformlyOn f 1 l s) (∀ (ε : Real), GT.gt ε 0 → Filter.Eventually (fun i => ∀ (x : κ), Membership.mem s x → LT.lt (Norm.norm (f i x)) ε) l)","decl":"@[to_additive]\ntheorem SeminormedGroup.tendstoUniformlyOn_one {f : ι → κ → G} {s : Set κ} {l : Filter ι} :\n    TendstoUniformlyOn f 1 l s ↔ ∀ ε > 0, ∀ᶠ i in l, ∀ x ∈ s, ‖f i x‖ < ε := by\n  simp only [tendstoUniformlyOn_iff, Pi.one_apply, dist_one_left]\n\n"}
{"name":"SeminormedGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_one","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"ι : Type u_3\nκ : Type u_4\nG : Type u_7\ninst✝ : SeminormedGroup G\nf : ι → κ → G\nl : Filter ι\nl' : Filter κ\n⊢ Iff (UniformCauchySeqOnFilter f l l') (TendstoUniformlyOnFilter (fun n z => HDiv.hDiv (f n.1 z) (f n.2 z)) 1 (SProd.sprod l l) l')","decl":"@[to_additive]\ntheorem SeminormedGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_one {f : ι → κ → G}\n    {l : Filter ι} {l' : Filter κ} :\n    UniformCauchySeqOnFilter f l l' ↔\n      TendstoUniformlyOnFilter (fun n : ι × ι => fun z => f n.fst z / f n.snd z) 1 (l ×ˢ l) l' := by\n  refine ⟨fun hf u hu => ?_, fun hf u hu => ?_⟩\n  · obtain ⟨ε, hε, H⟩ := uniformity_basis_dist.mem_uniformity_iff.mp hu\n    refine\n      (hf { p : G × G | dist p.fst p.snd < ε } <| dist_mem_uniformity hε).mono fun x hx =>\n        H 1 (f x.fst.fst x.snd / f x.fst.snd x.snd) ?_\n    simpa [dist_eq_norm_div, norm_div_rev] using hx\n  · obtain ⟨ε, hε, H⟩ := uniformity_basis_dist.mem_uniformity_iff.mp hu\n    refine\n      (hf { p : G × G | dist p.fst p.snd < ε } <| dist_mem_uniformity hε).mono fun x hx =>\n        H (f x.fst.fst x.snd) (f x.fst.snd x.snd) ?_\n    simpa [dist_eq_norm_div, norm_div_rev] using hx\n\n"}
{"name":"SeminormedAddGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"ι : Type u_3\nκ : Type u_4\nG : Type u_7\ninst✝ : SeminormedAddGroup G\nf : ι → κ → G\nl : Filter ι\nl' : Filter κ\n⊢ Iff (UniformCauchySeqOnFilter f l l') (TendstoUniformlyOnFilter (fun n z => HSub.hSub (f n.1 z) (f n.2 z)) 0 (SProd.sprod l l) l')","decl":"@[to_additive]\ntheorem SeminormedGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_one {f : ι → κ → G}\n    {l : Filter ι} {l' : Filter κ} :\n    UniformCauchySeqOnFilter f l l' ↔\n      TendstoUniformlyOnFilter (fun n : ι × ι => fun z => f n.fst z / f n.snd z) 1 (l ×ˢ l) l' := by\n  refine ⟨fun hf u hu => ?_, fun hf u hu => ?_⟩\n  · obtain ⟨ε, hε, H⟩ := uniformity_basis_dist.mem_uniformity_iff.mp hu\n    refine\n      (hf { p : G × G | dist p.fst p.snd < ε } <| dist_mem_uniformity hε).mono fun x hx =>\n        H 1 (f x.fst.fst x.snd / f x.fst.snd x.snd) ?_\n    simpa [dist_eq_norm_div, norm_div_rev] using hx\n  · obtain ⟨ε, hε, H⟩ := uniformity_basis_dist.mem_uniformity_iff.mp hu\n    refine\n      (hf { p : G × G | dist p.fst p.snd < ε } <| dist_mem_uniformity hε).mono fun x hx =>\n        H (f x.fst.fst x.snd) (f x.fst.snd x.snd) ?_\n    simpa [dist_eq_norm_div, norm_div_rev] using hx\n\n"}
{"name":"SeminormedAddGroup.uniformCauchySeqOn_iff_tendstoUniformlyOn_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"ι : Type u_3\nκ : Type u_4\nG : Type u_7\ninst✝ : SeminormedAddGroup G\nf : ι → κ → G\ns : Set κ\nl : Filter ι\n⊢ Iff (UniformCauchySeqOn f l s) (TendstoUniformlyOn (fun n z => HSub.hSub (f n.1 z) (f n.2 z)) 0 (SProd.sprod l l) s)","decl":"@[to_additive]\ntheorem SeminormedGroup.uniformCauchySeqOn_iff_tendstoUniformlyOn_one {f : ι → κ → G} {s : Set κ}\n    {l : Filter ι} :\n    UniformCauchySeqOn f l s ↔\n      TendstoUniformlyOn (fun n : ι × ι => fun z => f n.fst z / f n.snd z) 1 (l ×ˢ l) s := by\n  rw [tendstoUniformlyOn_iff_tendstoUniformlyOnFilter,\n    uniformCauchySeqOn_iff_uniformCauchySeqOnFilter,\n    SeminormedGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_one]\n\n"}
{"name":"SeminormedGroup.uniformCauchySeqOn_iff_tendstoUniformlyOn_one","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"ι : Type u_3\nκ : Type u_4\nG : Type u_7\ninst✝ : SeminormedGroup G\nf : ι → κ → G\ns : Set κ\nl : Filter ι\n⊢ Iff (UniformCauchySeqOn f l s) (TendstoUniformlyOn (fun n z => HDiv.hDiv (f n.1 z) (f n.2 z)) 1 (SProd.sprod l l) s)","decl":"@[to_additive]\ntheorem SeminormedGroup.uniformCauchySeqOn_iff_tendstoUniformlyOn_one {f : ι → κ → G} {s : Set κ}\n    {l : Filter ι} :\n    UniformCauchySeqOn f l s ↔\n      TendstoUniformlyOn (fun n : ι × ι => fun z => f n.fst z / f n.snd z) 1 (l ×ˢ l) s := by\n  rw [tendstoUniformlyOn_iff_tendstoUniformlyOnFilter,\n    uniformCauchySeqOn_iff_uniformCauchySeqOnFilter,\n    SeminormedGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_one]\n\n"}
{"name":"dist_neg","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddCommGroup E\nx y : E\n⊢ Eq (Dist.dist (Neg.neg x) y) (Dist.dist x (Neg.neg y))","decl":"@[to_additive]\ntheorem dist_inv (x y : E) : dist x⁻¹ y = dist x y⁻¹ := by\n  simp_rw [dist_eq_norm_div, ← norm_inv' (x⁻¹ / y), inv_div, div_inv_eq_mul, mul_comm]\n\n"}
{"name":"dist_inv","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedCommGroup E\nx y : E\n⊢ Eq (Dist.dist (Inv.inv x) y) (Dist.dist x (Inv.inv y))","decl":"@[to_additive]\ntheorem dist_inv (x y : E) : dist x⁻¹ y = dist x y⁻¹ := by\n  simp_rw [dist_eq_norm_div, ← norm_inv' (x⁻¹ / y), inv_div, div_inv_eq_mul, mul_comm]\n\n"}
{"name":"norm_multiset_sum_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_8\ninst✝ : SeminormedAddCommGroup E\nm : Multiset E\n⊢ LE.le (Norm.norm m.sum) (Multiset.map (fun x => Norm.norm x) m).sum","decl":"theorem norm_multiset_sum_le {E} [SeminormedAddCommGroup E] (m : Multiset E) :\n    ‖m.sum‖ ≤ (m.map fun x => ‖x‖).sum :=\n  m.le_sum_of_subadditive norm norm_zero norm_add_le\n\n"}
{"name":"norm_multiset_prod_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedCommGroup E\nm : Multiset E\n⊢ LE.le (Norm.norm m.prod) (Multiset.map (fun x => Norm.norm x) m).sum","decl":"@[to_additive existing]\ntheorem norm_multiset_prod_le (m : Multiset E) : ‖m.prod‖ ≤ (m.map fun x => ‖x‖).sum := by\n  rw [← Multiplicative.ofAdd_le, ofAdd_multiset_prod, Multiset.map_map]\n  refine Multiset.le_prod_of_submultiplicative (Multiplicative.ofAdd ∘ norm) ?_ (fun x y => ?_) _\n  · simp only [comp_apply, norm_one', ofAdd_zero]\n  · exact norm_mul_le' x y\n\n-- Porting note: had to add `ι` here because otherwise the universe order gets switched compared to\n-- `norm_prod_le` below\n"}
{"name":"norm_sum_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"ι : Type u_8\nE : Type u_9\ninst✝ : SeminormedAddCommGroup E\ns : Finset ι\nf : ι → E\n⊢ LE.le (Norm.norm (s.sum fun i => f i)) (s.sum fun i => Norm.norm (f i))","decl":"@[bound]\ntheorem norm_sum_le {ι E} [SeminormedAddCommGroup E] (s : Finset ι) (f : ι → E) :\n    ‖∑ i ∈ s, f i‖ ≤ ∑ i ∈ s, ‖f i‖ :=\n  s.le_sum_of_subadditive norm norm_zero norm_add_le f\n\n"}
{"name":"norm_prod_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"ι : Type u_3\nE : Type u_5\ninst✝ : SeminormedCommGroup E\ns : Finset ι\nf : ι → E\n⊢ LE.le (Norm.norm (s.prod fun i => f i)) (s.sum fun i => Norm.norm (f i))","decl":"@[to_additive existing]\ntheorem norm_prod_le (s : Finset ι) (f : ι → E) : ‖∏ i ∈ s, f i‖ ≤ ∑ i ∈ s, ‖f i‖ := by\n  rw [← Multiplicative.ofAdd_le, ofAdd_sum]\n  refine Finset.le_prod_of_submultiplicative (Multiplicative.ofAdd ∘ norm) ?_ (fun x y => ?_) _ _\n  · simp only [comp_apply, norm_one', ofAdd_zero]\n  · exact norm_mul_le' x y\n\n"}
{"name":"norm_prod_le_of_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"ι : Type u_3\nE : Type u_5\ninst✝ : SeminormedCommGroup E\ns : Finset ι\nf : ι → E\nn : ι → Real\nh : ∀ (b : ι), Membership.mem s b → LE.le (Norm.norm (f b)) (n b)\n⊢ LE.le (Norm.norm (s.prod fun b => f b)) (s.sum fun b => n b)","decl":"@[to_additive]\ntheorem norm_prod_le_of_le (s : Finset ι) {f : ι → E} {n : ι → ℝ} (h : ∀ b ∈ s, ‖f b‖ ≤ n b) :\n    ‖∏ b ∈ s, f b‖ ≤ ∑ b ∈ s, n b :=\n  (norm_prod_le s f).trans <| Finset.sum_le_sum h\n\n"}
{"name":"norm_sum_le_of_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"ι : Type u_3\nE : Type u_5\ninst✝ : SeminormedAddCommGroup E\ns : Finset ι\nf : ι → E\nn : ι → Real\nh : ∀ (b : ι), Membership.mem s b → LE.le (Norm.norm (f b)) (n b)\n⊢ LE.le (Norm.norm (s.sum fun b => f b)) (s.sum fun b => n b)","decl":"@[to_additive]\ntheorem norm_prod_le_of_le (s : Finset ι) {f : ι → E} {n : ι → ℝ} (h : ∀ b ∈ s, ‖f b‖ ≤ n b) :\n    ‖∏ b ∈ s, f b‖ ≤ ∑ b ∈ s, n b :=\n  (norm_prod_le s f).trans <| Finset.sum_le_sum h\n\n"}
{"name":"dist_prod_prod_le_of_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"ι : Type u_3\nE : Type u_5\ninst✝ : SeminormedCommGroup E\ns : Finset ι\nf a : ι → E\nd : ι → Real\nh : ∀ (b : ι), Membership.mem s b → LE.le (Dist.dist (f b) (a b)) (d b)\n⊢ LE.le (Dist.dist (s.prod fun b => f b) (s.prod fun b => a b)) (s.sum fun b => d b)","decl":"@[to_additive]\ntheorem dist_prod_prod_le_of_le (s : Finset ι) {f a : ι → E} {d : ι → ℝ}\n    (h : ∀ b ∈ s, dist (f b) (a b) ≤ d b) :\n    dist (∏ b ∈ s, f b) (∏ b ∈ s, a b) ≤ ∑ b ∈ s, d b := by\n  simp only [dist_eq_norm_div, ← Finset.prod_div_distrib] at *\n  exact norm_prod_le_of_le s h\n\n"}
{"name":"dist_sum_sum_le_of_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"ι : Type u_3\nE : Type u_5\ninst✝ : SeminormedAddCommGroup E\ns : Finset ι\nf a : ι → E\nd : ι → Real\nh : ∀ (b : ι), Membership.mem s b → LE.le (Dist.dist (f b) (a b)) (d b)\n⊢ LE.le (Dist.dist (s.sum fun b => f b) (s.sum fun b => a b)) (s.sum fun b => d b)","decl":"@[to_additive]\ntheorem dist_prod_prod_le_of_le (s : Finset ι) {f a : ι → E} {d : ι → ℝ}\n    (h : ∀ b ∈ s, dist (f b) (a b) ≤ d b) :\n    dist (∏ b ∈ s, f b) (∏ b ∈ s, a b) ≤ ∑ b ∈ s, d b := by\n  simp only [dist_eq_norm_div, ← Finset.prod_div_distrib] at *\n  exact norm_prod_le_of_le s h\n\n"}
{"name":"dist_sum_sum_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"ι : Type u_3\nE : Type u_5\ninst✝ : SeminormedAddCommGroup E\ns : Finset ι\nf a : ι → E\n⊢ LE.le (Dist.dist (s.sum fun b => f b) (s.sum fun b => a b)) (s.sum fun b => Dist.dist (f b) (a b))","decl":"@[to_additive]\ntheorem dist_prod_prod_le (s : Finset ι) (f a : ι → E) :\n    dist (∏ b ∈ s, f b) (∏ b ∈ s, a b) ≤ ∑ b ∈ s, dist (f b) (a b) :=\n  dist_prod_prod_le_of_le s fun _ _ => le_rfl\n\n"}
{"name":"dist_prod_prod_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"ι : Type u_3\nE : Type u_5\ninst✝ : SeminormedCommGroup E\ns : Finset ι\nf a : ι → E\n⊢ LE.le (Dist.dist (s.prod fun b => f b) (s.prod fun b => a b)) (s.sum fun b => Dist.dist (f b) (a b))","decl":"@[to_additive]\ntheorem dist_prod_prod_le (s : Finset ι) (f a : ι → E) :\n    dist (∏ b ∈ s, f b) (∏ b ∈ s, a b) ≤ ∑ b ∈ s, dist (f b) (a b) :=\n  dist_prod_prod_le_of_le s fun _ _ => le_rfl\n\n"}
{"name":"add_mem_ball_iff_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddCommGroup E\na b : E\nr : Real\n⊢ Iff (Membership.mem (Metric.ball a r) (HAdd.hAdd a b)) (LT.lt (Norm.norm b) r)","decl":"@[to_additive]\ntheorem mul_mem_ball_iff_norm : a * b ∈ ball a r ↔ ‖b‖ < r := by\n  rw [mem_ball_iff_norm'', mul_div_cancel_left]\n\n"}
{"name":"mul_mem_ball_iff_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedCommGroup E\na b : E\nr : Real\n⊢ Iff (Membership.mem (Metric.ball a r) (HMul.hMul a b)) (LT.lt (Norm.norm b) r)","decl":"@[to_additive]\ntheorem mul_mem_ball_iff_norm : a * b ∈ ball a r ↔ ‖b‖ < r := by\n  rw [mem_ball_iff_norm'', mul_div_cancel_left]\n\n"}
{"name":"mul_mem_closedBall_iff_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedCommGroup E\na b : E\nr : Real\n⊢ Iff (Membership.mem (Metric.closedBall a r) (HMul.hMul a b)) (LE.le (Norm.norm b) r)","decl":"@[to_additive]\ntheorem mul_mem_closedBall_iff_norm : a * b ∈ closedBall a r ↔ ‖b‖ ≤ r := by\n  rw [mem_closedBall_iff_norm'', mul_div_cancel_left]\n\n"}
{"name":"add_mem_closedBall_iff_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddCommGroup E\na b : E\nr : Real\n⊢ Iff (Membership.mem (Metric.closedBall a r) (HAdd.hAdd a b)) (LE.le (Norm.norm b) r)","decl":"@[to_additive]\ntheorem mul_mem_closedBall_iff_norm : a * b ∈ closedBall a r ↔ ‖b‖ ≤ r := by\n  rw [mem_closedBall_iff_norm'', mul_div_cancel_left]\n\n"}
{"name":"preimage_add_ball","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddCommGroup E\na b : E\nr : Real\n⊢ Eq (Set.preimage (fun x => HAdd.hAdd b x) (Metric.ball a r)) (Metric.ball (HSub.hSub a b) r)","decl":"@[to_additive (attr := simp 1001)]\n-- Porting note: increase priority so that the left-hand side doesn't simplify\ntheorem preimage_mul_ball (a b : E) (r : ℝ) : (b * ·) ⁻¹' ball a r = ball (a / b) r := by\n  ext c\n  simp only [dist_eq_norm_div, Set.mem_preimage, mem_ball, div_div_eq_mul_div, mul_comm]\n\n"}
{"name":"preimage_mul_ball","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedCommGroup E\na b : E\nr : Real\n⊢ Eq (Set.preimage (fun x => HMul.hMul b x) (Metric.ball a r)) (Metric.ball (HDiv.hDiv a b) r)","decl":"@[to_additive (attr := simp 1001)]\n-- Porting note: increase priority so that the left-hand side doesn't simplify\ntheorem preimage_mul_ball (a b : E) (r : ℝ) : (b * ·) ⁻¹' ball a r = ball (a / b) r := by\n  ext c\n  simp only [dist_eq_norm_div, Set.mem_preimage, mem_ball, div_div_eq_mul_div, mul_comm]\n\n"}
{"name":"preimage_mul_closedBall","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedCommGroup E\na b : E\nr : Real\n⊢ Eq (Set.preimage (fun x => HMul.hMul b x) (Metric.closedBall a r)) (Metric.closedBall (HDiv.hDiv a b) r)","decl":"@[to_additive (attr := simp 1001)]\n-- Porting note: increase priority so that the left-hand side doesn't simplify\ntheorem preimage_mul_closedBall (a b : E) (r : ℝ) :\n    (b * ·) ⁻¹' closedBall a r = closedBall (a / b) r := by\n  ext c\n  simp only [dist_eq_norm_div, Set.mem_preimage, mem_closedBall, div_div_eq_mul_div, mul_comm]\n\n"}
{"name":"preimage_add_closedBall","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddCommGroup E\na b : E\nr : Real\n⊢ Eq (Set.preimage (fun x => HAdd.hAdd b x) (Metric.closedBall a r)) (Metric.closedBall (HSub.hSub a b) r)","decl":"@[to_additive (attr := simp 1001)]\n-- Porting note: increase priority so that the left-hand side doesn't simplify\ntheorem preimage_mul_closedBall (a b : E) (r : ℝ) :\n    (b * ·) ⁻¹' closedBall a r = closedBall (a / b) r := by\n  ext c\n  simp only [dist_eq_norm_div, Set.mem_preimage, mem_closedBall, div_div_eq_mul_div, mul_comm]\n\n"}
{"name":"preimage_add_sphere","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddCommGroup E\na b : E\nr : Real\n⊢ Eq (Set.preimage (fun x => HAdd.hAdd b x) (Metric.sphere a r)) (Metric.sphere (HSub.hSub a b) r)","decl":"@[to_additive (attr := simp)]\ntheorem preimage_mul_sphere (a b : E) (r : ℝ) : (b * ·) ⁻¹' sphere a r = sphere (a / b) r := by\n  ext c\n  simp only [Set.mem_preimage, mem_sphere_iff_norm', div_div_eq_mul_div, mul_comm]\n\n\n"}
{"name":"preimage_mul_sphere","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedCommGroup E\na b : E\nr : Real\n⊢ Eq (Set.preimage (fun x => HMul.hMul b x) (Metric.sphere a r)) (Metric.sphere (HDiv.hDiv a b) r)","decl":"@[to_additive (attr := simp)]\ntheorem preimage_mul_sphere (a b : E) (r : ℝ) : (b * ·) ⁻¹' sphere a r = sphere (a / b) r := by\n  ext c\n  simp only [Set.mem_preimage, mem_sphere_iff_norm', div_div_eq_mul_div, mul_comm]\n\n\n"}
{"name":"pow_mem_closedBall","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedCommGroup E\na b : E\nr : Real\nn : Nat\nh : Membership.mem (Metric.closedBall b r) a\n⊢ Membership.mem (Metric.closedBall (HPow.hPow b n) (HSMul.hSMul n r)) (HPow.hPow a n)","decl":"@[to_additive]\ntheorem pow_mem_closedBall {n : ℕ} (h : a ∈ closedBall b r) :\n    a ^ n ∈ closedBall (b ^ n) (n • r) := by\n  simp only [mem_closedBall, dist_eq_norm_div, ← div_pow] at h ⊢\n  refine norm_pow_le_mul_norm.trans ?_\n  simpa only [nsmul_eq_mul] using mul_le_mul_of_nonneg_left h n.cast_nonneg\n\n"}
{"name":"nsmul_mem_closedBall","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddCommGroup E\na b : E\nr : Real\nn : Nat\nh : Membership.mem (Metric.closedBall b r) a\n⊢ Membership.mem (Metric.closedBall (HSMul.hSMul n b) (HSMul.hSMul n r)) (HSMul.hSMul n a)","decl":"@[to_additive]\ntheorem pow_mem_closedBall {n : ℕ} (h : a ∈ closedBall b r) :\n    a ^ n ∈ closedBall (b ^ n) (n • r) := by\n  simp only [mem_closedBall, dist_eq_norm_div, ← div_pow] at h ⊢\n  refine norm_pow_le_mul_norm.trans ?_\n  simpa only [nsmul_eq_mul] using mul_le_mul_of_nonneg_left h n.cast_nonneg\n\n"}
{"name":"pow_mem_ball","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedCommGroup E\na b : E\nr : Real\nn : Nat\nhn : LT.lt 0 n\nh : Membership.mem (Metric.ball b r) a\n⊢ Membership.mem (Metric.ball (HPow.hPow b n) (HSMul.hSMul n r)) (HPow.hPow a n)","decl":"@[to_additive]\ntheorem pow_mem_ball {n : ℕ} (hn : 0 < n) (h : a ∈ ball b r) : a ^ n ∈ ball (b ^ n) (n • r) := by\n  simp only [mem_ball, dist_eq_norm_div, ← div_pow] at h ⊢\n  refine lt_of_le_of_lt norm_pow_le_mul_norm ?_\n  replace hn : 0 < (n : ℝ) := by norm_cast\n  rw [nsmul_eq_mul]\n  nlinarith\n\n"}
{"name":"nsmul_mem_ball","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddCommGroup E\na b : E\nr : Real\nn : Nat\nhn : LT.lt 0 n\nh : Membership.mem (Metric.ball b r) a\n⊢ Membership.mem (Metric.ball (HSMul.hSMul n b) (HSMul.hSMul n r)) (HSMul.hSMul n a)","decl":"@[to_additive]\ntheorem pow_mem_ball {n : ℕ} (hn : 0 < n) (h : a ∈ ball b r) : a ^ n ∈ ball (b ^ n) (n • r) := by\n  simp only [mem_ball, dist_eq_norm_div, ← div_pow] at h ⊢\n  refine lt_of_le_of_lt norm_pow_le_mul_norm ?_\n  replace hn : 0 < (n : ℝ) := by norm_cast\n  rw [nsmul_eq_mul]\n  nlinarith\n\n"}
{"name":"mul_mem_closedBall_mul_iff","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedCommGroup E\na b : E\nr : Real\nc : E\n⊢ Iff (Membership.mem (Metric.closedBall (HMul.hMul b c) r) (HMul.hMul a c)) (Membership.mem (Metric.closedBall b r) a)","decl":"@[to_additive]\ntheorem mul_mem_closedBall_mul_iff {c : E} : a * c ∈ closedBall (b * c) r ↔ a ∈ closedBall b r := by\n  simp only [mem_closedBall, dist_eq_norm_div, mul_div_mul_right_eq_div]\n\n"}
{"name":"add_mem_closedBall_add_iff","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddCommGroup E\na b : E\nr : Real\nc : E\n⊢ Iff (Membership.mem (Metric.closedBall (HAdd.hAdd b c) r) (HAdd.hAdd a c)) (Membership.mem (Metric.closedBall b r) a)","decl":"@[to_additive]\ntheorem mul_mem_closedBall_mul_iff {c : E} : a * c ∈ closedBall (b * c) r ↔ a ∈ closedBall b r := by\n  simp only [mem_closedBall, dist_eq_norm_div, mul_div_mul_right_eq_div]\n\n"}
{"name":"add_mem_ball_add_iff","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddCommGroup E\na b : E\nr : Real\nc : E\n⊢ Iff (Membership.mem (Metric.ball (HAdd.hAdd b c) r) (HAdd.hAdd a c)) (Membership.mem (Metric.ball b r) a)","decl":"@[to_additive]\ntheorem mul_mem_ball_mul_iff {c : E} : a * c ∈ ball (b * c) r ↔ a ∈ ball b r := by\n  simp only [mem_ball, dist_eq_norm_div, mul_div_mul_right_eq_div]\n\n"}
{"name":"mul_mem_ball_mul_iff","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedCommGroup E\na b : E\nr : Real\nc : E\n⊢ Iff (Membership.mem (Metric.ball (HMul.hMul b c) r) (HMul.hMul a c)) (Membership.mem (Metric.ball b r) a)","decl":"@[to_additive]\ntheorem mul_mem_ball_mul_iff {c : E} : a * c ∈ ball (b * c) r ↔ a ∈ ball b r := by\n  simp only [mem_ball, dist_eq_norm_div, mul_div_mul_right_eq_div]\n\n"}
{"name":"vadd_closedBall''","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddCommGroup E\na b : E\nr : Real\n⊢ Eq (HVAdd.hVAdd a (Metric.closedBall b r)) (Metric.closedBall (HVAdd.hVAdd a b) r)","decl":"@[to_additive]\ntheorem smul_closedBall'' : a • closedBall b r = closedBall (a • b) r := by\n  ext\n  simp [mem_closedBall, Set.mem_smul_set, dist_eq_norm_div, div_eq_inv_mul, ←\n    eq_inv_mul_iff_mul_eq, mul_assoc]\n\n"}
{"name":"smul_closedBall''","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedCommGroup E\na b : E\nr : Real\n⊢ Eq (HSMul.hSMul a (Metric.closedBall b r)) (Metric.closedBall (HSMul.hSMul a b) r)","decl":"@[to_additive]\ntheorem smul_closedBall'' : a • closedBall b r = closedBall (a • b) r := by\n  ext\n  simp [mem_closedBall, Set.mem_smul_set, dist_eq_norm_div, div_eq_inv_mul, ←\n    eq_inv_mul_iff_mul_eq, mul_assoc]\n\n"}
{"name":"vadd_ball''","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddCommGroup E\na b : E\nr : Real\n⊢ Eq (HVAdd.hVAdd a (Metric.ball b r)) (Metric.ball (HVAdd.hVAdd a b) r)","decl":"@[to_additive]\ntheorem smul_ball'' : a • ball b r = ball (a • b) r := by\n  ext\n  simp [mem_ball, Set.mem_smul_set, dist_eq_norm_div, _root_.div_eq_inv_mul,\n    ← eq_inv_mul_iff_mul_eq, mul_assoc]\n\n"}
{"name":"smul_ball''","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedCommGroup E\na b : E\nr : Real\n⊢ Eq (HSMul.hSMul a (Metric.ball b r)) (Metric.ball (HSMul.hSMul a b) r)","decl":"@[to_additive]\ntheorem smul_ball'' : a • ball b r = ball (a • b) r := by\n  ext\n  simp [mem_ball, Set.mem_smul_set, dist_eq_norm_div, _root_.div_eq_inv_mul,\n    ← eq_inv_mul_iff_mul_eq, mul_assoc]\n\n"}
{"name":"controlled_sum_of_mem_closure","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddCommGroup E\na : E\ns : AddSubgroup E\nhg : Membership.mem (closure ↑s) a\nb : Nat → Real\nb_pos : ∀ (n : Nat), LT.lt 0 (b n)\n⊢ Exists fun v => And (Filter.Tendsto (fun n => (Finset.range (HAdd.hAdd n 1)).sum fun i => v i) Filter.atTop (nhds a)) (And (∀ (n : Nat), Membership.mem s (v n)) (And (LT.lt (Norm.norm (HSub.hSub (v 0) a)) (b 0)) (∀ (n : Nat), LT.lt 0 n → LT.lt (Norm.norm (v n)) (b n))))","decl":"@[to_additive]\ntheorem controlled_prod_of_mem_closure {s : Subgroup E} (hg : a ∈ closure (s : Set E)) {b : ℕ → ℝ}\n    (b_pos : ∀ n, 0 < b n) :\n    ∃ v : ℕ → E,\n      Tendsto (fun n => ∏ i ∈ range (n + 1), v i) atTop (𝓝 a) ∧\n        (∀ n, v n ∈ s) ∧ ‖v 0 / a‖ < b 0 ∧ ∀ n, 0 < n → ‖v n‖ < b n := by\n  obtain ⟨u : ℕ → E, u_in : ∀ n, u n ∈ s, lim_u : Tendsto u atTop (𝓝 a)⟩ :=\n    mem_closure_iff_seq_limit.mp hg\n  obtain ⟨n₀, hn₀⟩ : ∃ n₀, ∀ n ≥ n₀, ‖u n / a‖ < b 0 :=\n    haveI : { x | ‖x / a‖ < b 0 } ∈ 𝓝 a := by\n      simp_rw [← dist_eq_norm_div]\n      exact Metric.ball_mem_nhds _ (b_pos _)\n    Filter.tendsto_atTop'.mp lim_u _ this\n  set z : ℕ → E := fun n => u (n + n₀)\n  have lim_z : Tendsto z atTop (𝓝 a) := lim_u.comp (tendsto_add_atTop_nat n₀)\n  have mem_𝓤 : ∀ n, { p : E × E | ‖p.1 / p.2‖ < b (n + 1) } ∈ 𝓤 E := fun n => by\n    simpa [← dist_eq_norm_div] using Metric.dist_mem_uniformity (b_pos <| n + 1)\n  obtain ⟨φ : ℕ → ℕ, φ_extr : StrictMono φ, hφ : ∀ n, ‖z (φ <| n + 1) / z (φ n)‖ < b (n + 1)⟩ :=\n    lim_z.cauchySeq.subseq_mem mem_𝓤\n  set w : ℕ → E := z ∘ φ\n  have hw : Tendsto w atTop (𝓝 a) := lim_z.comp φ_extr.tendsto_atTop\n  set v : ℕ → E := fun i => if i = 0 then w 0 else w i / w (i - 1)\n  refine ⟨v, Tendsto.congr (Finset.eq_prod_range_div' w) hw, ?_, hn₀ _ (n₀.le_add_left _), ?_⟩\n  · rintro ⟨⟩\n    · change w 0 ∈ s\n      apply u_in\n    · apply s.div_mem <;> apply u_in\n  · intro l hl\n    obtain ⟨k, rfl⟩ : ∃ k, l = k + 1 := Nat.exists_eq_succ_of_ne_zero hl.ne'\n    apply hφ\n\n"}
{"name":"controlled_prod_of_mem_closure","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedCommGroup E\na : E\ns : Subgroup E\nhg : Membership.mem (closure ↑s) a\nb : Nat → Real\nb_pos : ∀ (n : Nat), LT.lt 0 (b n)\n⊢ Exists fun v => And (Filter.Tendsto (fun n => (Finset.range (HAdd.hAdd n 1)).prod fun i => v i) Filter.atTop (nhds a)) (And (∀ (n : Nat), Membership.mem s (v n)) (And (LT.lt (Norm.norm (HDiv.hDiv (v 0) a)) (b 0)) (∀ (n : Nat), LT.lt 0 n → LT.lt (Norm.norm (v n)) (b n))))","decl":"@[to_additive]\ntheorem controlled_prod_of_mem_closure {s : Subgroup E} (hg : a ∈ closure (s : Set E)) {b : ℕ → ℝ}\n    (b_pos : ∀ n, 0 < b n) :\n    ∃ v : ℕ → E,\n      Tendsto (fun n => ∏ i ∈ range (n + 1), v i) atTop (𝓝 a) ∧\n        (∀ n, v n ∈ s) ∧ ‖v 0 / a‖ < b 0 ∧ ∀ n, 0 < n → ‖v n‖ < b n := by\n  obtain ⟨u : ℕ → E, u_in : ∀ n, u n ∈ s, lim_u : Tendsto u atTop (𝓝 a)⟩ :=\n    mem_closure_iff_seq_limit.mp hg\n  obtain ⟨n₀, hn₀⟩ : ∃ n₀, ∀ n ≥ n₀, ‖u n / a‖ < b 0 :=\n    haveI : { x | ‖x / a‖ < b 0 } ∈ 𝓝 a := by\n      simp_rw [← dist_eq_norm_div]\n      exact Metric.ball_mem_nhds _ (b_pos _)\n    Filter.tendsto_atTop'.mp lim_u _ this\n  set z : ℕ → E := fun n => u (n + n₀)\n  have lim_z : Tendsto z atTop (𝓝 a) := lim_u.comp (tendsto_add_atTop_nat n₀)\n  have mem_𝓤 : ∀ n, { p : E × E | ‖p.1 / p.2‖ < b (n + 1) } ∈ 𝓤 E := fun n => by\n    simpa [← dist_eq_norm_div] using Metric.dist_mem_uniformity (b_pos <| n + 1)\n  obtain ⟨φ : ℕ → ℕ, φ_extr : StrictMono φ, hφ : ∀ n, ‖z (φ <| n + 1) / z (φ n)‖ < b (n + 1)⟩ :=\n    lim_z.cauchySeq.subseq_mem mem_𝓤\n  set w : ℕ → E := z ∘ φ\n  have hw : Tendsto w atTop (𝓝 a) := lim_z.comp φ_extr.tendsto_atTop\n  set v : ℕ → E := fun i => if i = 0 then w 0 else w i / w (i - 1)\n  refine ⟨v, Tendsto.congr (Finset.eq_prod_range_div' w) hw, ?_, hn₀ _ (n₀.le_add_left _), ?_⟩\n  · rintro ⟨⟩\n    · change w 0 ∈ s\n      apply u_in\n    · apply s.div_mem <;> apply u_in\n  · intro l hl\n    obtain ⟨k, rfl⟩ : ∃ k, l = k + 1 := Nat.exists_eq_succ_of_ne_zero hl.ne'\n    apply hφ\n\n"}
{"name":"controlled_sum_of_mem_closure_range","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\nF : Type u_6\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : SeminormedAddCommGroup F\nj : AddMonoidHom E F\nb : F\nhb : Membership.mem (closure ↑j.range) b\nf : Nat → Real\nb_pos : ∀ (n : Nat), LT.lt 0 (f n)\n⊢ Exists fun a => And (Filter.Tendsto (fun n => (Finset.range (HAdd.hAdd n 1)).sum fun i => j (a i)) Filter.atTop (nhds b)) (And (LT.lt (Norm.norm (HSub.hSub (j (a 0)) b)) (f 0)) (∀ (n : Nat), LT.lt 0 n → LT.lt (Norm.norm (j (a n))) (f n)))","decl":"@[to_additive]\ntheorem controlled_prod_of_mem_closure_range {j : E →* F} {b : F}\n    (hb : b ∈ closure (j.range : Set F)) {f : ℕ → ℝ} (b_pos : ∀ n, 0 < f n) :\n    ∃ a : ℕ → E,\n      Tendsto (fun n => ∏ i ∈ range (n + 1), j (a i)) atTop (𝓝 b) ∧\n        ‖j (a 0) / b‖ < f 0 ∧ ∀ n, 0 < n → ‖j (a n)‖ < f n := by\n  obtain ⟨v, sum_v, v_in, hv₀, hv_pos⟩ := controlled_prod_of_mem_closure hb b_pos\n  choose g hg using v_in\n  exact\n    ⟨g, by simpa [← hg] using sum_v, by simpa [hg 0] using hv₀,\n      fun n hn => by simpa [hg] using hv_pos n hn⟩\n\n"}
{"name":"controlled_prod_of_mem_closure_range","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\nF : Type u_6\ninst✝¹ : SeminormedCommGroup E\ninst✝ : SeminormedCommGroup F\nj : MonoidHom E F\nb : F\nhb : Membership.mem (closure ↑j.range) b\nf : Nat → Real\nb_pos : ∀ (n : Nat), LT.lt 0 (f n)\n⊢ Exists fun a => And (Filter.Tendsto (fun n => (Finset.range (HAdd.hAdd n 1)).prod fun i => j (a i)) Filter.atTop (nhds b)) (And (LT.lt (Norm.norm (HDiv.hDiv (j (a 0)) b)) (f 0)) (∀ (n : Nat), LT.lt 0 n → LT.lt (Norm.norm (j (a n))) (f n)))","decl":"@[to_additive]\ntheorem controlled_prod_of_mem_closure_range {j : E →* F} {b : F}\n    (hb : b ∈ closure (j.range : Set F)) {f : ℕ → ℝ} (b_pos : ∀ n, 0 < f n) :\n    ∃ a : ℕ → E,\n      Tendsto (fun n => ∏ i ∈ range (n + 1), j (a i)) atTop (𝓝 b) ∧\n        ‖j (a 0) / b‖ < f 0 ∧ ∀ n, 0 < n → ‖j (a n)‖ < f n := by\n  obtain ⟨v, sum_v, v_in, hv₀, hv_pos⟩ := controlled_prod_of_mem_closure hb b_pos\n  choose g hg using v_in\n  exact\n    ⟨g, by simpa [← hg] using sum_v, by simpa [hg 0] using hv₀,\n      fun n hn => by simpa [hg] using hv_pos n hn⟩\n\n"}
{"name":"nnnorm_multiset_prod_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedCommGroup E\nm : Multiset E\n⊢ LE.le (NNNorm.nnnorm m.prod) (Multiset.map (fun x => NNNorm.nnnorm x) m).sum","decl":"@[to_additive]\ntheorem nnnorm_multiset_prod_le (m : Multiset E) : ‖m.prod‖₊ ≤ (m.map fun x => ‖x‖₊).sum :=\n  NNReal.coe_le_coe.1 <| by\n    push_cast\n    rw [Multiset.map_map]\n    exact norm_multiset_prod_le _\n\n"}
{"name":"nnnorm_multiset_sum_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddCommGroup E\nm : Multiset E\n⊢ LE.le (NNNorm.nnnorm m.sum) (Multiset.map (fun x => NNNorm.nnnorm x) m).sum","decl":"@[to_additive]\ntheorem nnnorm_multiset_prod_le (m : Multiset E) : ‖m.prod‖₊ ≤ (m.map fun x => ‖x‖₊).sum :=\n  NNReal.coe_le_coe.1 <| by\n    push_cast\n    rw [Multiset.map_map]\n    exact norm_multiset_prod_le _\n\n"}
{"name":"nnnorm_sum_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"ι : Type u_3\nE : Type u_5\ninst✝ : SeminormedAddCommGroup E\ns : Finset ι\nf : ι → E\n⊢ LE.le (NNNorm.nnnorm (s.sum fun a => f a)) (s.sum fun a => NNNorm.nnnorm (f a))","decl":"@[to_additive]\ntheorem nnnorm_prod_le (s : Finset ι) (f : ι → E) : ‖∏ a ∈ s, f a‖₊ ≤ ∑ a ∈ s, ‖f a‖₊ :=\n  NNReal.coe_le_coe.1 <| by\n    push_cast\n    exact norm_prod_le _ _\n\n"}
{"name":"nnnorm_prod_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"ι : Type u_3\nE : Type u_5\ninst✝ : SeminormedCommGroup E\ns : Finset ι\nf : ι → E\n⊢ LE.le (NNNorm.nnnorm (s.prod fun a => f a)) (s.sum fun a => NNNorm.nnnorm (f a))","decl":"@[to_additive]\ntheorem nnnorm_prod_le (s : Finset ι) (f : ι → E) : ‖∏ a ∈ s, f a‖₊ ≤ ∑ a ∈ s, ‖f a‖₊ :=\n  NNReal.coe_le_coe.1 <| by\n    push_cast\n    exact norm_prod_le _ _\n\n"}
{"name":"nnnorm_sum_le_of_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"ι : Type u_3\nE : Type u_5\ninst✝ : SeminormedAddCommGroup E\ns : Finset ι\nf : ι → E\nn : ι → NNReal\nh : ∀ (b : ι), Membership.mem s b → LE.le (NNNorm.nnnorm (f b)) (n b)\n⊢ LE.le (NNNorm.nnnorm (s.sum fun b => f b)) (s.sum fun b => n b)","decl":"@[to_additive]\ntheorem nnnorm_prod_le_of_le (s : Finset ι) {f : ι → E} {n : ι → ℝ≥0} (h : ∀ b ∈ s, ‖f b‖₊ ≤ n b) :\n    ‖∏ b ∈ s, f b‖₊ ≤ ∑ b ∈ s, n b :=\n  (norm_prod_le_of_le s h).trans_eq (NNReal.coe_sum ..).symm\n\n"}
{"name":"nnnorm_prod_le_of_le","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"ι : Type u_3\nE : Type u_5\ninst✝ : SeminormedCommGroup E\ns : Finset ι\nf : ι → E\nn : ι → NNReal\nh : ∀ (b : ι), Membership.mem s b → LE.le (NNNorm.nnnorm (f b)) (n b)\n⊢ LE.le (NNNorm.nnnorm (s.prod fun b => f b)) (s.sum fun b => n b)","decl":"@[to_additive]\ntheorem nnnorm_prod_le_of_le (s : Finset ι) {f : ι → E} {n : ι → ℝ≥0} (h : ∀ b ∈ s, ‖f b‖₊ ≤ n b) :\n    ‖∏ b ∈ s, f b‖₊ ≤ ∑ b ∈ s, n b :=\n  (norm_prod_le_of_le s h).trans_eq (NNReal.coe_sum ..).symm\n\n"}
{"name":"Real.norm_eq_abs","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"r : Real\n⊢ Eq (Norm.norm r) (abs r)","decl":"@[simp]\ntheorem norm_eq_abs (r : ℝ) : ‖r‖ = |r| :=\n  rfl\n\n"}
{"name":"Real.norm_of_nonneg","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"r : Real\nhr : LE.le 0 r\n⊢ Eq (Norm.norm r) r","decl":"theorem norm_of_nonneg (hr : 0 ≤ r) : ‖r‖ = r :=\n  abs_of_nonneg hr\n\n"}
{"name":"Real.norm_of_nonpos","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"r : Real\nhr : LE.le r 0\n⊢ Eq (Norm.norm r) (Neg.neg r)","decl":"theorem norm_of_nonpos (hr : r ≤ 0) : ‖r‖ = -r :=\n  abs_of_nonpos hr\n\n"}
{"name":"Real.le_norm_self","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"r : Real\n⊢ LE.le r (Norm.norm r)","decl":"theorem le_norm_self (r : ℝ) : r ≤ ‖r‖ :=\n  le_abs_self r\n\n"}
{"name":"Real.norm_natCast","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"n : Nat\n⊢ Eq (Norm.norm ↑n) ↑n","decl":"@[simp 1100] lemma norm_natCast (n : ℕ) : ‖(n : ℝ)‖ = n := abs_of_nonneg n.cast_nonneg\n"}
{"name":"Real.nnnorm_natCast","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"n : Nat\n⊢ Eq (NNNorm.nnnorm ↑n) ↑n","decl":"@[simp 1100] lemma nnnorm_natCast (n : ℕ) : ‖(n : ℝ)‖₊ = n := NNReal.eq <| norm_natCast _\n"}
{"name":"Real.enorm_natCast","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"n : Nat\n⊢ Eq (ENorm.enorm ↑n) ↑n","decl":"@[simp 1100] lemma enorm_natCast (n : ℕ) : ‖(n : ℝ)‖ₑ = n := by simp [enorm]\n\n"}
{"name":"Real.norm_ofNat","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Norm.norm (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp 1100] lemma norm_ofNat (n : ℕ) [n.AtLeastTwo] :\n    ‖(ofNat(n) : ℝ)‖ = ofNat(n) := norm_natCast n\n\n"}
{"name":"Real.nnnorm_ofNat","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (NNNorm.nnnorm (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp 1100] lemma nnnorm_ofNat (n : ℕ) [n.AtLeastTwo] :\n    ‖(ofNat(n) : ℝ)‖₊ = ofNat(n) := nnnorm_natCast n\n\n"}
{"name":"Real.norm_two","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"⊢ Eq (Norm.norm 2) 2","decl":"lemma norm_two : ‖(2 : ℝ)‖ = 2 := abs_of_pos zero_lt_two\n"}
{"name":"Real.nnnorm_two","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"⊢ Eq (NNNorm.nnnorm 2) 2","decl":"lemma nnnorm_two : ‖(2 : ℝ)‖₊ = 2 := NNReal.eq <| by simp\n\n"}
{"name":"Real.norm_nnratCast","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"q : NNRat\n⊢ Eq (Norm.norm ↑q) ↑q","decl":"@[simp 1100, norm_cast]\nlemma norm_nnratCast (q : ℚ≥0) : ‖(q : ℝ)‖ = q := norm_of_nonneg q.cast_nonneg\n\n"}
{"name":"Real.nnnorm_nnratCast","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"q : NNRat\n⊢ Eq (NNNorm.nnnorm ↑q) ↑q","decl":"@[simp 1100, norm_cast]\nlemma nnnorm_nnratCast (q : ℚ≥0) : ‖(q : ℝ)‖₊ = q := by simp [nnnorm, -norm_eq_abs]\n\n"}
{"name":"Real.nnnorm_of_nonneg","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"r : Real\nhr : LE.le 0 r\n⊢ Eq (NNNorm.nnnorm r) ⟨r, hr⟩","decl":"theorem nnnorm_of_nonneg (hr : 0 ≤ r) : ‖r‖₊ = ⟨r, hr⟩ :=\n  NNReal.eq <| norm_of_nonneg hr\n\n"}
{"name":"Real.enorm_of_nonneg","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"r : Real\nhr : LE.le 0 r\n⊢ Eq (ENorm.enorm r) (ENNReal.ofReal r)","decl":"lemma enorm_of_nonneg (hr : 0 ≤ r) : ‖r‖ₑ = .ofReal r := by\n  simp [enorm, nnnorm_of_nonneg hr, ENNReal.ofReal, toNNReal, hr]\n\n"}
{"name":"Real.nnnorm_abs","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"r : Real\n⊢ Eq (NNNorm.nnnorm (abs r)) (NNNorm.nnnorm r)","decl":"@[simp] lemma nnnorm_abs (r : ℝ) : ‖|r|‖₊ = ‖r‖₊ := by simp [nnnorm]\n"}
{"name":"Real.enorm_abs","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"r : Real\n⊢ Eq (ENorm.enorm (abs r)) (ENorm.enorm r)","decl":"@[simp] lemma enorm_abs (r : ℝ) : ‖|r|‖ₑ = ‖r‖ₑ := by simp [enorm]\n\n"}
{"name":"Real.enorm_eq_ofReal","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"r : Real\nhr : LE.le 0 r\n⊢ Eq (ENorm.enorm r) (ENNReal.ofReal r)","decl":"theorem enorm_eq_ofReal (hr : 0 ≤ r) : ‖r‖ₑ = .ofReal r := by\n  rw [← ofReal_norm_eq_enorm, norm_of_nonneg hr]\n\n"}
{"name":"Real.ennnorm_eq_ofReal","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"r : Real\nhr : LE.le 0 r\n⊢ Eq (ENorm.enorm r) (ENNReal.ofReal r)","decl":"@[deprecated (since := \"2025-01-17\")] alias ennnorm_eq_ofReal := enorm_eq_ofReal\n\n"}
{"name":"Real.enorm_eq_ofReal_abs","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"r : Real\n⊢ Eq (ENorm.enorm r) (ENNReal.ofReal (abs r))","decl":"theorem enorm_eq_ofReal_abs (r : ℝ) : ‖r‖ₑ = ENNReal.ofReal |r| := by\n  rw [← enorm_eq_ofReal (abs_nonneg _), enorm_abs]\n\n"}
{"name":"Real.ennnorm_eq_ofReal_abs","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"r : Real\n⊢ Eq (ENorm.enorm r) (ENNReal.ofReal (abs r))","decl":"@[deprecated (since := \"2025-01-17\")] alias ennnorm_eq_ofReal_abs := enorm_eq_ofReal_abs\n\n"}
{"name":"Real.toNNReal_eq_nnnorm_of_nonneg","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"r : Real\nhr : LE.le 0 r\n⊢ Eq r.toNNReal (NNNorm.nnnorm r)","decl":"theorem toNNReal_eq_nnnorm_of_nonneg (hr : 0 ≤ r) : r.toNNReal = ‖r‖₊ := by\n  rw [Real.toNNReal_of_nonneg hr]\n  ext\n  rw [coe_mk, coe_nnnorm r, Real.norm_eq_abs r, abs_of_nonneg hr]\n  -- Porting note: this is due to the change from `Subtype.val` to `NNReal.toReal` for the coercion\n\n"}
{"name":"Real.ofReal_le_enorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"r : Real\n⊢ LE.le (ENNReal.ofReal r) (ENorm.enorm r)","decl":"theorem ofReal_le_enorm (r : ℝ) : ENNReal.ofReal r ≤ ‖r‖ₑ := by\n  rw [enorm_eq_ofReal_abs]; gcongr; exact le_abs_self _\n\n"}
{"name":"Real.ofReal_le_ennnorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"r : Real\n⊢ LE.le (ENNReal.ofReal r) (ENorm.enorm r)","decl":"@[deprecated (since := \"2025-01-17\")] alias ofReal_le_ennnorm := ofReal_le_enorm\n\n"}
{"name":"NNReal.nnnorm_eq_self","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"x : NNReal\n⊢ Eq (NNNorm.nnnorm x) x","decl":"@[simp] lemma nnnorm_eq_self (x : ℝ≥0) : ‖x‖₊ = x := rfl\n\n"}
{"name":"norm_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddCommGroup E\nx : E\n⊢ Eq (Norm.norm (Norm.norm x)) (Norm.norm x)","decl":"@[to_additive (attr := simp 1001) norm_norm]\nlemma norm_norm' (x : E) : ‖‖x‖‖ = ‖x‖ := Real.norm_of_nonneg (norm_nonneg' _)\n\n"}
{"name":"norm_norm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedCommGroup E\nx : E\n⊢ Eq (Norm.norm (Norm.norm x)) (Norm.norm x)","decl":"@[to_additive (attr := simp 1001) norm_norm]\nlemma norm_norm' (x : E) : ‖‖x‖‖ = ‖x‖ := Real.norm_of_nonneg (norm_nonneg' _)\n\n"}
{"name":"nnnorm_norm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedCommGroup E\nx : E\n⊢ Eq (NNNorm.nnnorm (Norm.norm x)) (NNNorm.nnnorm x)","decl":"@[to_additive (attr := simp) nnnorm_norm]\nlemma nnnorm_norm' (x : E) : ‖‖x‖‖₊ = ‖x‖₊ := by simp [nnnorm]\n\n"}
{"name":"nnnorm_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddCommGroup E\nx : E\n⊢ Eq (NNNorm.nnnorm (Norm.norm x)) (NNNorm.nnnorm x)","decl":"@[to_additive (attr := simp) nnnorm_norm]\nlemma nnnorm_norm' (x : E) : ‖‖x‖‖₊ = ‖x‖₊ := by simp [nnnorm]\n\n"}
{"name":"enorm_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddCommGroup E\nx : E\n⊢ Eq (ENorm.enorm (Norm.norm x)) (ENorm.enorm x)","decl":"@[to_additive (attr := simp) enorm_norm]\nlemma enorm_norm' (x : E) : ‖‖x‖‖ₑ = ‖x‖ₑ := by simp [enorm]\n\n"}
{"name":"enorm_norm'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedCommGroup E\nx : E\n⊢ Eq (ENorm.enorm (Norm.norm x)) (ENorm.enorm x)","decl":"@[to_additive (attr := simp) enorm_norm]\nlemma enorm_norm' (x : E) : ‖‖x‖‖ₑ = ‖x‖ₑ := by simp [enorm]\n\n"}
{"name":"norm_le_zero_iff'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\na : E\n⊢ Iff (LE.le (Norm.norm a) 0) (Eq a 1)","decl":"@[to_additive (attr := simp) norm_le_zero_iff]\nlemma norm_le_zero_iff' : ‖a‖ ≤ 0 ↔ a = 1 := by rw [← dist_one_right, dist_le_zero]\n\n"}
{"name":"norm_le_zero_iff","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedAddGroup E\na : E\n⊢ Iff (LE.le (Norm.norm a) 0) (Eq a 0)","decl":"@[to_additive (attr := simp) norm_le_zero_iff]\nlemma norm_le_zero_iff' : ‖a‖ ≤ 0 ↔ a = 1 := by rw [← dist_one_right, dist_le_zero]\n\n"}
{"name":"norm_pos_iff","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedAddGroup E\na : E\n⊢ Iff (LT.lt 0 (Norm.norm a)) (Ne a 0)","decl":"@[to_additive (attr := simp) norm_pos_iff]\nlemma norm_pos_iff' : 0 < ‖a‖ ↔ a ≠ 1 := by rw [← not_le, norm_le_zero_iff']\n\n"}
{"name":"norm_pos_iff'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\na : E\n⊢ Iff (LT.lt 0 (Norm.norm a)) (Ne a 1)","decl":"@[to_additive (attr := simp) norm_pos_iff]\nlemma norm_pos_iff' : 0 < ‖a‖ ↔ a ≠ 1 := by rw [← not_le, norm_le_zero_iff']\n\n"}
{"name":"norm_eq_zero'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\na : E\n⊢ Iff (Eq (Norm.norm a) 0) (Eq a 1)","decl":"@[to_additive (attr := simp) norm_eq_zero]\nlemma norm_eq_zero' : ‖a‖ = 0 ↔ a = 1 := (norm_nonneg' a).le_iff_eq.symm.trans norm_le_zero_iff'\n\n"}
{"name":"norm_eq_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedAddGroup E\na : E\n⊢ Iff (Eq (Norm.norm a) 0) (Eq a 0)","decl":"@[to_additive (attr := simp) norm_eq_zero]\nlemma norm_eq_zero' : ‖a‖ = 0 ↔ a = 1 := (norm_nonneg' a).le_iff_eq.symm.trans norm_le_zero_iff'\n\n"}
{"name":"norm_ne_zero_iff'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\na : E\n⊢ Iff (Ne (Norm.norm a) 0) (Ne a 1)","decl":"@[to_additive norm_ne_zero_iff]\nlemma norm_ne_zero_iff' : ‖a‖ ≠ 0 ↔ a ≠ 1 := norm_eq_zero'.not\n\n"}
{"name":"norm_ne_zero_iff","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedAddGroup E\na : E\n⊢ Iff (Ne (Norm.norm a) 0) (Ne a 0)","decl":"@[to_additive norm_ne_zero_iff]\nlemma norm_ne_zero_iff' : ‖a‖ ≠ 0 ↔ a ≠ 1 := norm_eq_zero'.not\n\n"}
{"name":"norm_le_zero_iff''","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\na : E\n⊢ Iff (LE.le (Norm.norm a) 0) (Eq a 1)","decl":"@[deprecated (since := \"2024-11-24\")] alias norm_le_zero_iff'' := norm_le_zero_iff'\n"}
{"name":"norm_le_zero_iff'''","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\na : E\n⊢ Iff (LE.le (Norm.norm a) 0) (Eq a 1)","decl":"@[deprecated (since := \"2024-11-24\")] alias norm_le_zero_iff''' := norm_le_zero_iff'\n"}
{"name":"norm_pos_iff''","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\na : E\n⊢ Iff (LT.lt 0 (Norm.norm a)) (Ne a 1)","decl":"@[deprecated (since := \"2024-11-24\")] alias norm_pos_iff'' := norm_pos_iff'\n"}
{"name":"norm_eq_zero''","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\na : E\n⊢ Iff (Eq (Norm.norm a) 0) (Eq a 1)","decl":"@[deprecated (since := \"2024-11-24\")] alias norm_eq_zero'' := norm_eq_zero'\n"}
{"name":"norm_eq_zero'''","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\na : E\n⊢ Iff (Eq (Norm.norm a) 0) (Eq a 1)","decl":"@[deprecated (since := \"2024-11-24\")] alias norm_eq_zero''' := norm_eq_zero'\n\n"}
{"name":"norm_div_eq_zero_iff","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\na b : E\n⊢ Iff (Eq (Norm.norm (HDiv.hDiv a b)) 0) (Eq a b)","decl":"@[to_additive]\ntheorem norm_div_eq_zero_iff : ‖a / b‖ = 0 ↔ a = b := by rw [norm_eq_zero', div_eq_one]\n\n"}
{"name":"norm_sub_eq_zero_iff","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedAddGroup E\na b : E\n⊢ Iff (Eq (Norm.norm (HSub.hSub a b)) 0) (Eq a b)","decl":"@[to_additive]\ntheorem norm_div_eq_zero_iff : ‖a / b‖ = 0 ↔ a = b := by rw [norm_eq_zero', div_eq_one]\n\n"}
{"name":"norm_sub_pos_iff","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedAddGroup E\na b : E\n⊢ Iff (LT.lt 0 (Norm.norm (HSub.hSub a b))) (Ne a b)","decl":"@[to_additive]\ntheorem norm_div_pos_iff : 0 < ‖a / b‖ ↔ a ≠ b := by\n  rw [(norm_nonneg' _).lt_iff_ne, ne_comm]\n  exact norm_div_eq_zero_iff.not\n\n"}
{"name":"norm_div_pos_iff","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\na b : E\n⊢ Iff (LT.lt 0 (Norm.norm (HDiv.hDiv a b))) (Ne a b)","decl":"@[to_additive]\ntheorem norm_div_pos_iff : 0 < ‖a / b‖ ↔ a ≠ b := by\n  rw [(norm_nonneg' _).lt_iff_ne, ne_comm]\n  exact norm_div_eq_zero_iff.not\n\n"}
{"name":"eq_of_norm_sub_le_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedAddGroup E\na b : E\nh : LE.le (Norm.norm (HSub.hSub a b)) 0\n⊢ Eq a b","decl":"@[to_additive eq_of_norm_sub_le_zero]\ntheorem eq_of_norm_div_le_zero (h : ‖a / b‖ ≤ 0) : a = b := by\n  rwa [← div_eq_one, ← norm_le_zero_iff']\n\n"}
{"name":"eq_of_norm_div_le_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\na b : E\nh : LE.le (Norm.norm (HDiv.hDiv a b)) 0\n⊢ Eq a b","decl":"@[to_additive eq_of_norm_sub_le_zero]\ntheorem eq_of_norm_div_le_zero (h : ‖a / b‖ ≤ 0) : a = b := by\n  rwa [← div_eq_one, ← norm_le_zero_iff']\n\n"}
{"name":"eq_of_norm_div_eq_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\na b : E\na✝ : Eq (Norm.norm (HDiv.hDiv a b)) 0\n⊢ Eq a b","decl":"alias ⟨eq_of_norm_div_eq_zero, _⟩ := norm_div_eq_zero_iff\n\n"}
{"name":"eq_of_norm_sub_eq_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedAddGroup E\na b : E\na✝ : Eq (Norm.norm (HSub.hSub a b)) 0\n⊢ Eq a b","decl":"attribute [to_additive] eq_of_norm_div_eq_zero\n\n"}
{"name":"eq_one_or_norm_pos","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\na : E\n⊢ Or (Eq a 1) (LT.lt 0 (Norm.norm a))","decl":"@[to_additive]\ntheorem eq_one_or_norm_pos (a : E) : a = 1 ∨ 0 < ‖a‖ := by\n  simpa [eq_comm] using (norm_nonneg' a).eq_or_lt\n\n"}
{"name":"eq_zero_or_norm_pos","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedAddGroup E\na : E\n⊢ Or (Eq a 0) (LT.lt 0 (Norm.norm a))","decl":"@[to_additive]\ntheorem eq_one_or_norm_pos (a : E) : a = 1 ∨ 0 < ‖a‖ := by\n  simpa [eq_comm] using (norm_nonneg' a).eq_or_lt\n\n"}
{"name":"eq_one_or_nnnorm_pos","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\na : E\n⊢ Or (Eq a 1) (LT.lt 0 (NNNorm.nnnorm a))","decl":"@[to_additive]\ntheorem eq_one_or_nnnorm_pos (a : E) : a = 1 ∨ 0 < ‖a‖₊ :=\n  eq_one_or_norm_pos a\n\n"}
{"name":"eq_zero_or_nnnorm_pos","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedAddGroup E\na : E\n⊢ Or (Eq a 0) (LT.lt 0 (NNNorm.nnnorm a))","decl":"@[to_additive]\ntheorem eq_one_or_nnnorm_pos (a : E) : a = 1 ∨ 0 < ‖a‖₊ :=\n  eq_one_or_norm_pos a\n\n"}
{"name":"nnnorm_eq_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedAddGroup E\na : E\n⊢ Iff (Eq (NNNorm.nnnorm a) 0) (Eq a 0)","decl":"@[to_additive (attr := simp) nnnorm_eq_zero]\ntheorem nnnorm_eq_zero' : ‖a‖₊ = 0 ↔ a = 1 := by\n  rw [← NNReal.coe_eq_zero, coe_nnnorm', norm_eq_zero']\n\n"}
{"name":"nnnorm_eq_zero'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\na : E\n⊢ Iff (Eq (NNNorm.nnnorm a) 0) (Eq a 1)","decl":"@[to_additive (attr := simp) nnnorm_eq_zero]\ntheorem nnnorm_eq_zero' : ‖a‖₊ = 0 ↔ a = 1 := by\n  rw [← NNReal.coe_eq_zero, coe_nnnorm', norm_eq_zero']\n\n"}
{"name":"enorm_eq_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedAddGroup E\na : E\n⊢ Iff (Eq (ENorm.enorm a) 0) (Eq a 0)","decl":"@[to_additive (attr := simp) enorm_eq_zero]\nlemma enorm_eq_zero' : ‖a‖ₑ = 0 ↔ a = 1 := by simp [enorm]\n\n"}
{"name":"enorm_eq_zero'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\na : E\n⊢ Iff (Eq (ENorm.enorm a) 0) (Eq a 1)","decl":"@[to_additive (attr := simp) enorm_eq_zero]\nlemma enorm_eq_zero' : ‖a‖ₑ = 0 ↔ a = 1 := by simp [enorm]\n\n"}
{"name":"nnnorm_ne_zero_iff'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\na : E\n⊢ Iff (Ne (NNNorm.nnnorm a) 0) (Ne a 1)","decl":"@[to_additive nnnorm_ne_zero_iff]\ntheorem nnnorm_ne_zero_iff' : ‖a‖₊ ≠ 0 ↔ a ≠ 1 :=\n  nnnorm_eq_zero'.not\n\n"}
{"name":"nnnorm_ne_zero_iff","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedAddGroup E\na : E\n⊢ Iff (Ne (NNNorm.nnnorm a) 0) (Ne a 0)","decl":"@[to_additive nnnorm_ne_zero_iff]\ntheorem nnnorm_ne_zero_iff' : ‖a‖₊ ≠ 0 ↔ a ≠ 1 :=\n  nnnorm_eq_zero'.not\n\n"}
{"name":"enorm_ne_zero'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\na : E\n⊢ Iff (Ne (ENorm.enorm a) 0) (Ne a 1)","decl":"@[to_additive enorm_ne_zero]\nlemma enorm_ne_zero' : ‖a‖ₑ ≠ 0 ↔ a ≠ 1 := enorm_eq_zero'.ne\n\n"}
{"name":"enorm_ne_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedAddGroup E\na : E\n⊢ Iff (Ne (ENorm.enorm a) 0) (Ne a 0)","decl":"@[to_additive enorm_ne_zero]\nlemma enorm_ne_zero' : ‖a‖ₑ ≠ 0 ↔ a ≠ 1 := enorm_eq_zero'.ne\n\n"}
{"name":"nnnorm_pos","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedAddGroup E\na : E\n⊢ Iff (LT.lt 0 (NNNorm.nnnorm a)) (Ne a 0)","decl":"@[to_additive (attr := simp) nnnorm_pos]\nlemma nnnorm_pos' : 0 < ‖a‖₊ ↔ a ≠ 1 := pos_iff_ne_zero.trans nnnorm_ne_zero_iff'\n\n"}
{"name":"nnnorm_pos'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\na : E\n⊢ Iff (LT.lt 0 (NNNorm.nnnorm a)) (Ne a 1)","decl":"@[to_additive (attr := simp) nnnorm_pos]\nlemma nnnorm_pos' : 0 < ‖a‖₊ ↔ a ≠ 1 := pos_iff_ne_zero.trans nnnorm_ne_zero_iff'\n\n"}
{"name":"enorm_pos","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedAddGroup E\na : E\n⊢ Iff (LT.lt 0 (ENorm.enorm a)) (Ne a 0)","decl":"@[to_additive (attr := simp) enorm_pos]\nlemma enorm_pos' : 0 < ‖a‖ₑ ↔ a ≠ 1 := pos_iff_ne_zero.trans enorm_ne_zero'\n\n"}
{"name":"enorm_pos'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\na : E\n⊢ Iff (LT.lt 0 (ENorm.enorm a)) (Ne a 1)","decl":"@[to_additive (attr := simp) enorm_pos]\nlemma enorm_pos' : 0 < ‖a‖ₑ ↔ a ≠ 1 := pos_iff_ne_zero.trans enorm_ne_zero'\n\n"}
{"name":"tendsto_norm_nhdsNE_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedAddGroup E\n⊢ Filter.Tendsto Norm.norm (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) (nhdsWithin 0 (Set.Ioi 0))","decl":"/-- See `tendsto_norm_one` for a version with full neighborhoods. -/\n@[to_additive \"See `tendsto_norm_zero` for a version with full neighborhoods.\"]\nlemma tendsto_norm_nhdsNE_one : Tendsto (norm : E → ℝ) (𝓝[≠] 1) (𝓝[>] 0) :=\n  tendsto_norm_one.inf <| tendsto_principal_principal.2 fun _ hx ↦ norm_pos_iff'.2 hx\n\n"}
{"name":"tendsto_norm_nhdsNE_one","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\n⊢ Filter.Tendsto Norm.norm (nhdsWithin 1 (HasCompl.compl (Singleton.singleton 1))) (nhdsWithin 0 (Set.Ioi 0))","decl":"/-- See `tendsto_norm_one` for a version with full neighborhoods. -/\n@[to_additive \"See `tendsto_norm_zero` for a version with full neighborhoods.\"]\nlemma tendsto_norm_nhdsNE_one : Tendsto (norm : E → ℝ) (𝓝[≠] 1) (𝓝[>] 0) :=\n  tendsto_norm_one.inf <| tendsto_principal_principal.2 fun _ hx ↦ norm_pos_iff'.2 hx\n\n"}
{"name":"tendsto_norm_zero'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedAddGroup E\n⊢ Filter.Tendsto Norm.norm (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) (nhdsWithin 0 (Set.Ioi 0))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias tendsto_norm_zero' := tendsto_norm_nhdsNE_zero\n"}
{"name":"tendsto_norm_one'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\n⊢ Filter.Tendsto Norm.norm (nhdsWithin 1 (HasCompl.compl (Singleton.singleton 1))) (nhdsWithin 0 (Set.Ioi 0))","decl":"@[to_additive existing, deprecated (since := \"2024-12-22\")]\nalias tendsto_norm_one' := tendsto_norm_nhdsNE_one\n\n"}
{"name":"tendsto_norm_nhdsWithin_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedAddGroup E\n⊢ Filter.Tendsto Norm.norm (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) (nhdsWithin 0 (Set.Ioi 0))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias tendsto_norm_nhdsWithin_zero := tendsto_norm_nhdsNE_zero\n"}
{"name":"tendsto_norm_nhdsWithin_one","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\n⊢ Filter.Tendsto Norm.norm (nhdsWithin 1 (HasCompl.compl (Singleton.singleton 1))) (nhdsWithin 0 (Set.Ioi 0))","decl":"@[to_additive existing, deprecated (since := \"2024-12-22\")]\nalias tendsto_norm_nhdsWithin_one := tendsto_norm_nhdsNE_one\n\n"}
{"name":"tendsto_norm_div_self_nhdsNE","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\na : E\n⊢ Filter.Tendsto (fun x => Norm.norm (HDiv.hDiv x a)) (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) (nhdsWithin 0 (Set.Ioi 0))","decl":"@[to_additive]\ntheorem tendsto_norm_div_self_nhdsNE (a : E) : Tendsto (fun x => ‖x / a‖) (𝓝[≠] a) (𝓝[>] 0) :=\n  (tendsto_norm_div_self a).inf <|\n    tendsto_principal_principal.2 fun _x hx => norm_pos_iff'.2 <| div_ne_one.2 hx\n\n"}
{"name":"tendsto_norm_sub_self_nhdsNE","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedAddGroup E\na : E\n⊢ Filter.Tendsto (fun x => Norm.norm (HSub.hSub x a)) (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) (nhdsWithin 0 (Set.Ioi 0))","decl":"@[to_additive]\ntheorem tendsto_norm_div_self_nhdsNE (a : E) : Tendsto (fun x => ‖x / a‖) (𝓝[≠] a) (𝓝[>] 0) :=\n  (tendsto_norm_div_self a).inf <|\n    tendsto_principal_principal.2 fun _x hx => norm_pos_iff'.2 <| div_ne_one.2 hx\n\n"}
{"name":"tendsto_norm_sub_self_punctured_nhds","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedAddGroup E\na : E\n⊢ Filter.Tendsto (fun x => Norm.norm (HSub.hSub x a)) (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) (nhdsWithin 0 (Set.Ioi 0))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias tendsto_norm_sub_self_punctured_nhds := tendsto_norm_sub_self_nhdsNE\n"}
{"name":"tendsto_norm_div_self_punctured_nhds","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\na : E\n⊢ Filter.Tendsto (fun x => Norm.norm (HDiv.hDiv x a)) (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) (nhdsWithin 0 (Set.Ioi 0))","decl":"@[to_additive existing, deprecated (since := \"2024-12-22\")]\nalias tendsto_norm_div_self_punctured_nhds := tendsto_norm_div_self_nhdsNE\n\n"}
{"name":"coe_normGroupNorm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\n⊢ Eq (⇑(normGroupNorm E)) Norm.norm","decl":"@[simp]\ntheorem coe_normGroupNorm : ⇑(normGroupNorm E) = norm :=\n  rfl\n\n"}
{"name":"comap_norm_nhdsGT_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedAddGroup E\n⊢ Eq (Filter.comap Norm.norm (nhdsWithin 0 (Set.Ioi 0))) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0)))","decl":"/-- A version of `comap_norm_nhdsGT_zero` for a multiplicative normed group. -/\n@[to_additive comap_norm_nhdsGT_zero]\nlemma comap_norm_nhdsGT_zero' : comap norm (𝓝[>] 0) = 𝓝[≠] (1 : E) := by\n  simp [nhdsWithin, comap_norm_nhds_one, Set.preimage, Set.compl_def]\n\n"}
{"name":"comap_norm_nhdsGT_zero'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\n⊢ Eq (Filter.comap Norm.norm (nhdsWithin 0 (Set.Ioi 0))) (nhdsWithin 1 (HasCompl.compl (Singleton.singleton 1)))","decl":"/-- A version of `comap_norm_nhdsGT_zero` for a multiplicative normed group. -/\n@[to_additive comap_norm_nhdsGT_zero]\nlemma comap_norm_nhdsGT_zero' : comap norm (𝓝[>] 0) = 𝓝[≠] (1 : E) := by\n  simp [nhdsWithin, comap_norm_nhds_one, Set.preimage, Set.compl_def]\n\n"}
{"name":"comap_norm_nhdsWithin_Ioi_zero","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedAddGroup E\n⊢ Eq (Filter.comap Norm.norm (nhdsWithin 0 (Set.Ioi 0))) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0)))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias comap_norm_nhdsWithin_Ioi_zero := comap_norm_nhdsGT_zero\n"}
{"name":"comap_norm_nhdsWithin_Ioi_zero'","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : NormedGroup E\n⊢ Eq (Filter.comap Norm.norm (nhdsWithin 0 (Set.Ioi 0))) (nhdsWithin 1 (HasCompl.compl (Singleton.singleton 1)))","decl":"@[to_additive existing comap_norm_nhdsWithin_Ioi_zero, deprecated (since := \"2024-12-22\")]\nalias comap_norm_nhdsWithin_Ioi_zero' := comap_norm_nhdsGT_zero'\n\n"}
{"name":"hasCompactSupport_norm_iff","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : NormedAddGroup E\ninst✝ : TopologicalSpace α\nf : α → E\n⊢ Iff (HasCompactSupport fun x => Norm.norm (f x)) (HasCompactSupport f)","decl":"theorem hasCompactSupport_norm_iff : (HasCompactSupport fun x => ‖f x‖) ↔ HasCompactSupport f :=\n  hasCompactSupport_comp_left norm_eq_zero\n\n"}
{"name":"HasCompactSupport.norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"α : Type u_2\nE : Type u_5\ninst✝¹ : NormedAddGroup E\ninst✝ : TopologicalSpace α\nf : α → E\na✝ : HasCompactSupport f\n⊢ HasCompactSupport fun x => Norm.norm (f x)","decl":"alias ⟨_, HasCompactSupport.norm⟩ := hasCompactSupport_norm_iff\n\n"}
{"name":"AddSubgroup.coe_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\ns : AddSubgroup E\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (Norm.norm x) (Norm.norm ↑x)","decl":"/-- If `x` is an element of a subgroup `s` of a seminormed group `E`, its norm in `s` is equal to\nits norm in `E`. -/\n@[to_additive (attr := simp) \"If `x` is an element of a subgroup `s` of a seminormed group `E`, its\nnorm in `s` is equal to its norm in `E`.\"]\ntheorem coe_norm (x : s) : ‖x‖ = ‖(x : E)‖ :=\n  rfl\n\n"}
{"name":"Subgroup.coe_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\ns : Subgroup E\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (Norm.norm x) (Norm.norm ↑x)","decl":"/-- If `x` is an element of a subgroup `s` of a seminormed group `E`, its norm in `s` is equal to\nits norm in `E`. -/\n@[to_additive (attr := simp) \"If `x` is an element of a subgroup `s` of a seminormed group `E`, its\nnorm in `s` is equal to its norm in `E`.\"]\ntheorem coe_norm (x : s) : ‖x‖ = ‖(x : E)‖ :=\n  rfl\n\n"}
{"name":"AddSubgroup.norm_coe","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedAddGroup E\ns : AddSubgroup E\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (Norm.norm ↑x) (Norm.norm x)","decl":"/-- If `x` is an element of a subgroup `s` of a seminormed group `E`, its norm in `s` is equal to\nits norm in `E`.\n\nThis is a reversed version of the `simp` lemma `Subgroup.coe_norm` for use by `norm_cast`. -/\n@[to_additive (attr := norm_cast) \"If `x` is an element of a subgroup `s` of a seminormed group `E`,\nits norm in `s` is equal to its norm in `E`.\n\nThis is a reversed version of the `simp` lemma `AddSubgroup.coe_norm` for use by `norm_cast`.\"]\ntheorem norm_coe {s : Subgroup E} (x : s) : ‖(x : E)‖ = ‖x‖ :=\n  rfl\n\n"}
{"name":"Subgroup.norm_coe","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝ : SeminormedGroup E\ns : Subgroup E\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (Norm.norm ↑x) (Norm.norm x)","decl":"/-- If `x` is an element of a subgroup `s` of a seminormed group `E`, its norm in `s` is equal to\nits norm in `E`.\n\nThis is a reversed version of the `simp` lemma `Subgroup.coe_norm` for use by `norm_cast`. -/\n@[to_additive (attr := norm_cast) \"If `x` is an element of a subgroup `s` of a seminormed group `E`,\nits norm in `s` is equal to its norm in `E`.\n\nThis is a reversed version of the `simp` lemma `AddSubgroup.coe_norm` for use by `norm_cast`.\"]\ntheorem norm_coe {s : Subgroup E} (x : s) : ‖(x : E)‖ = ‖x‖ :=\n  rfl\n\n"}
{"name":"AddSubgroupClass.coe_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝² : SeminormedAddGroup E\nS : Type u_8\ninst✝¹ : SetLike S E\ninst✝ : AddSubgroupClass S E\ns : S\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (Norm.norm x) (Norm.norm ↑x)","decl":"/-- If `x` is an element of a subgroup `s` of a seminormed group `E`, its norm in `s` is equal to\nits norm in `E`. -/\n@[to_additive (attr := simp) \"If `x` is an element of an additive subgroup `s` of a seminormed\nadditive group `E`, its norm in `s` is equal to its norm in `E`.\"]\ntheorem coe_norm (x : s) : ‖x‖ = ‖(x : E)‖ :=\n  rfl\n\n"}
{"name":"SubgroupClass.coe_norm","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"E : Type u_5\ninst✝² : SeminormedGroup E\nS : Type u_8\ninst✝¹ : SetLike S E\ninst✝ : SubgroupClass S E\ns : S\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (Norm.norm x) (Norm.norm ↑x)","decl":"/-- If `x` is an element of a subgroup `s` of a seminormed group `E`, its norm in `s` is equal to\nits norm in `E`. -/\n@[to_additive (attr := simp) \"If `x` is an element of an additive subgroup `s` of a seminormed\nadditive group `E`, its norm in `s` is equal to its norm in `E`.\"]\ntheorem coe_norm (x : s) : ‖x‖ = ‖(x : E)‖ :=\n  rfl\n\n"}
{"name":"tendsto_norm_atTop_atTop","module":"Mathlib.Analysis.Normed.Group.Basic","initialProofState":"⊢ Filter.Tendsto Norm.norm Filter.atTop Filter.atTop","decl":"lemma tendsto_norm_atTop_atTop : Tendsto (norm : ℝ → ℝ) atTop atTop := tendsto_abs_atTop_atTop\n\n"}
