{"name":"CategoryTheory.LocalizerMorphism.RightResolution.hw","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nself : Φ.RightResolution X₂\n⊢ W₂ self.w","decl":"/-- The category of right resolutions of an object in the target category\nof a localizer morphism. -/\nstructure RightResolution (X₂ : C₂) where\n  /-- an object in the source category -/\n  {X₁ : C₁}\n  /-- a morphism to an object of the form `Φ.functor.obj X₁` -/\n  w : X₂ ⟶ Φ.functor.obj X₁\n  hw : W₂ w\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.mk.inj","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nX₁✝ : C₁\nw✝ : Quiver.Hom X₂ (Φ.functor.obj X₁✝)\nhw✝ : W₂ w✝\nX₁ : C₁\nw : Quiver.Hom X₂ (Φ.functor.obj X₁)\nhw : W₂ w\nx✝ : Eq (CategoryTheory.LocalizerMorphism.RightResolution.mk w✝ hw✝) (CategoryTheory.LocalizerMorphism.RightResolution.mk w hw)\n⊢ And (Eq X₁✝ X₁) (HEq w✝ w)","decl":"/-- The category of right resolutions of an object in the target category\nof a localizer morphism. -/\nstructure RightResolution (X₂ : C₂) where\n  /-- an object in the source category -/\n  {X₁ : C₁}\n  /-- a morphism to an object of the form `Φ.functor.obj X₁` -/\n  w : X₂ ⟶ Φ.functor.obj X₁\n  hw : W₂ w\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\ninst✝³ : SizeOf C₁\ninst✝² : SizeOf C₂\ninst✝¹ : ⦃X Y : C₁⦄ → (x : Quiver.Hom X Y) → SizeOf (W₁ x)\ninst✝ : ⦃X Y : C₂⦄ → (x : Quiver.Hom X Y) → SizeOf (W₂ x)\nX₁ : C₁\nw : Quiver.Hom X₂ (Φ.functor.obj X₁)\nhw : W₂ w\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.LocalizerMorphism.RightResolution.mk w hw)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf X₁)) (SizeOf.sizeOf w)) (SizeOf.sizeOf hw))","decl":"/-- The category of right resolutions of an object in the target category\nof a localizer morphism. -/\nstructure RightResolution (X₂ : C₂) where\n  /-- an object in the source category -/\n  {X₁ : C₁}\n  /-- a morphism to an object of the form `Φ.functor.obj X₁` -/\n  w : X₂ ⟶ Φ.functor.obj X₁\n  hw : W₂ w\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.mk.injEq","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nX₁✝ : C₁\nw✝ : Quiver.Hom X₂ (Φ.functor.obj X₁✝)\nhw✝ : W₂ w✝\nX₁ : C₁\nw : Quiver.Hom X₂ (Φ.functor.obj X₁)\nhw : W₂ w\n⊢ Eq (Eq (CategoryTheory.LocalizerMorphism.RightResolution.mk w✝ hw✝) (CategoryTheory.LocalizerMorphism.RightResolution.mk w hw)) (And (Eq X₁✝ X₁) (HEq w✝ w))","decl":"/-- The category of right resolutions of an object in the target category\nof a localizer morphism. -/\nstructure RightResolution (X₂ : C₂) where\n  /-- an object in the source category -/\n  {X₁ : C₁}\n  /-- a morphism to an object of the form `Φ.functor.obj X₁` -/\n  w : X₂ ⟶ Φ.functor.obj X₁\n  hw : W₂ w\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.hw","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nself : Φ.LeftResolution X₂\n⊢ W₂ self.w","decl":"/-- The category of left resolutions of an object in the target category\nof a localizer morphism. -/\nstructure LeftResolution (X₂ : C₂) where\n  /-- an object in the source category -/\n  {X₁ : C₁}\n  /-- a morphism from an object of the form `Φ.functor.obj X₁` -/\n  w : Φ.functor.obj X₁ ⟶ X₂\n  hw : W₂ w\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.mk.inj","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nX₁✝ : C₁\nw✝ : Quiver.Hom (Φ.functor.obj X₁✝) X₂\nhw✝ : W₂ w✝\nX₁ : C₁\nw : Quiver.Hom (Φ.functor.obj X₁) X₂\nhw : W₂ w\nx✝ : Eq (CategoryTheory.LocalizerMorphism.LeftResolution.mk w✝ hw✝) (CategoryTheory.LocalizerMorphism.LeftResolution.mk w hw)\n⊢ And (Eq X₁✝ X₁) (HEq w✝ w)","decl":"/-- The category of left resolutions of an object in the target category\nof a localizer morphism. -/\nstructure LeftResolution (X₂ : C₂) where\n  /-- an object in the source category -/\n  {X₁ : C₁}\n  /-- a morphism from an object of the form `Φ.functor.obj X₁` -/\n  w : Φ.functor.obj X₁ ⟶ X₂\n  hw : W₂ w\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\ninst✝³ : SizeOf C₁\ninst✝² : SizeOf C₂\ninst✝¹ : ⦃X Y : C₁⦄ → (x : Quiver.Hom X Y) → SizeOf (W₁ x)\ninst✝ : ⦃X Y : C₂⦄ → (x : Quiver.Hom X Y) → SizeOf (W₂ x)\nX₁ : C₁\nw : Quiver.Hom (Φ.functor.obj X₁) X₂\nhw : W₂ w\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.LocalizerMorphism.LeftResolution.mk w hw)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf X₁)) (SizeOf.sizeOf w)) (SizeOf.sizeOf hw))","decl":"/-- The category of left resolutions of an object in the target category\nof a localizer morphism. -/\nstructure LeftResolution (X₂ : C₂) where\n  /-- an object in the source category -/\n  {X₁ : C₁}\n  /-- a morphism from an object of the form `Φ.functor.obj X₁` -/\n  w : Φ.functor.obj X₁ ⟶ X₂\n  hw : W₂ w\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.mk.injEq","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nX₁✝ : C₁\nw✝ : Quiver.Hom (Φ.functor.obj X₁✝) X₂\nhw✝ : W₂ w✝\nX₁ : C₁\nw : Quiver.Hom (Φ.functor.obj X₁) X₂\nhw : W₂ w\n⊢ Eq (Eq (CategoryTheory.LocalizerMorphism.LeftResolution.mk w✝ hw✝) (CategoryTheory.LocalizerMorphism.LeftResolution.mk w hw)) (And (Eq X₁✝ X₁) (HEq w✝ w))","decl":"/-- The category of left resolutions of an object in the target category\nof a localizer morphism. -/\nstructure LeftResolution (X₂ : C₂) where\n  /-- an object in the source category -/\n  {X₁ : C₁}\n  /-- a morphism from an object of the form `Φ.functor.obj X₁` -/\n  w : Φ.functor.obj X₁ ⟶ X₂\n  hw : W₂ w\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.mk_surjective","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nR : Φ.RightResolution X₂\n⊢ Exists fun X₁ => Exists fun w => Exists fun hw => Eq R (CategoryTheory.LocalizerMorphism.RightResolution.mk w hw)","decl":"variable {Φ X₂} in\nlemma RightResolution.mk_surjective (R : Φ.RightResolution X₂) :\n    ∃ (X₁ : C₁) (w : X₂ ⟶ Φ.functor.obj X₁) (hw : W₂ w), R = RightResolution.mk w hw :=\n  ⟨_, R.w, R.hw, rfl⟩\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.mk_surjective","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nL : Φ.LeftResolution X₂\n⊢ Exists fun X₁ => Exists fun w => Exists fun hw => Eq L (CategoryTheory.LocalizerMorphism.LeftResolution.mk w hw)","decl":"variable {Φ X₂} in\nlemma LeftResolution.mk_surjective (L : Φ.LeftResolution X₂) :\n    ∃ (X₁ : C₁) (w : Φ.functor.obj X₁ ⟶ X₂) (hw : W₂ w), L = LeftResolution.mk w hw :=\n  ⟨_, L.w, L.hw, rfl⟩\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.Hom.comm","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nR R' : Φ.RightResolution X₂\nself : R.Hom R'\n⊢ Eq (CategoryTheory.CategoryStruct.comp R.w (Φ.functor.map self.f)) R'.w","decl":"/-- The type of morphisms in the category `Φ.RightResolution X₂` (when `W₁` is multiplicative). -/\n@[ext]\nstructure Hom (R R' : Φ.RightResolution X₂) where\n  /-- a morphism in the source category -/\n  f : R.X₁ ⟶ R'.X₁\n  hf : W₁ f\n  comm : R.w ≫ Φ.functor.map f = R'.w := by aesop_cat\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nR R' : Φ.RightResolution X₂\ninst✝³ : SizeOf C₁\ninst✝² : SizeOf C₂\ninst✝¹ : ⦃X Y : C₁⦄ → (x : Quiver.Hom X Y) → SizeOf (W₁ x)\ninst✝ : ⦃X Y : C₂⦄ → (x : Quiver.Hom X Y) → SizeOf (W₂ x)\nf : Quiver.Hom R.X₁ R'.X₁\nhf : W₁ f\ncomm : autoParam (Eq (CategoryTheory.CategoryStruct.comp R.w (Φ.functor.map f)) R'.w) _auto✝\n⊢ Eq (SizeOf.sizeOf { f := f, hf := hf, comm := comm }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf f)) (SizeOf.sizeOf hf)) (SizeOf.sizeOf comm))","decl":"/-- The type of morphisms in the category `Φ.RightResolution X₂` (when `W₁` is multiplicative). -/\n@[ext]\nstructure Hom (R R' : Φ.RightResolution X₂) where\n  /-- a morphism in the source category -/\n  f : R.X₁ ⟶ R'.X₁\n  hf : W₁ f\n  comm : R.w ≫ Φ.functor.map f = R'.w := by aesop_cat\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.Hom.mk.inj","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nR R' : Φ.RightResolution X₂\nf✝ : Quiver.Hom R.X₁ R'.X₁\nhf✝ : W₁ f✝\ncomm✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp R.w (Φ.functor.map f✝)) R'.w) _auto✝\nf : Quiver.Hom R.X₁ R'.X₁\nhf : W₁ f\ncomm : autoParam (Eq (CategoryTheory.CategoryStruct.comp R.w (Φ.functor.map f)) R'.w) _auto✝\nx✝ : Eq { f := f✝, hf := hf✝, comm := comm✝ } { f := f, hf := hf, comm := comm }\n⊢ Eq f✝ f","decl":"/-- The type of morphisms in the category `Φ.RightResolution X₂` (when `W₁` is multiplicative). -/\n@[ext]\nstructure Hom (R R' : Φ.RightResolution X₂) where\n  /-- a morphism in the source category -/\n  f : R.X₁ ⟶ R'.X₁\n  hf : W₁ f\n  comm : R.w ≫ Φ.functor.map f = R'.w := by aesop_cat\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.Hom.ext_iff","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nR R' : Φ.RightResolution X₂\nx y : R.Hom R'\n⊢ Iff (Eq x y) (Eq x.f y.f)","decl":"/-- The type of morphisms in the category `Φ.RightResolution X₂` (when `W₁` is multiplicative). -/\n@[ext]\nstructure Hom (R R' : Φ.RightResolution X₂) where\n  /-- a morphism in the source category -/\n  f : R.X₁ ⟶ R'.X₁\n  hf : W₁ f\n  comm : R.w ≫ Φ.functor.map f = R'.w := by aesop_cat\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.Hom.hf","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nR R' : Φ.RightResolution X₂\nself : R.Hom R'\n⊢ W₁ self.f","decl":"/-- The type of morphisms in the category `Φ.RightResolution X₂` (when `W₁` is multiplicative). -/\n@[ext]\nstructure Hom (R R' : Φ.RightResolution X₂) where\n  /-- a morphism in the source category -/\n  f : R.X₁ ⟶ R'.X₁\n  hf : W₁ f\n  comm : R.w ≫ Φ.functor.map f = R'.w := by aesop_cat\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nR R' : Φ.RightResolution X₂\nf✝ : Quiver.Hom R.X₁ R'.X₁\nhf✝ : W₁ f✝\ncomm✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp R.w (Φ.functor.map f✝)) R'.w) _auto✝\nf : Quiver.Hom R.X₁ R'.X₁\nhf : W₁ f\ncomm : autoParam (Eq (CategoryTheory.CategoryStruct.comp R.w (Φ.functor.map f)) R'.w) _auto✝\n⊢ Eq (Eq { f := f✝, hf := hf✝, comm := comm✝ } { f := f, hf := hf, comm := comm }) (Eq f✝ f)","decl":"/-- The type of morphisms in the category `Φ.RightResolution X₂` (when `W₁` is multiplicative). -/\n@[ext]\nstructure Hom (R R' : Φ.RightResolution X₂) where\n  /-- a morphism in the source category -/\n  f : R.X₁ ⟶ R'.X₁\n  hf : W₁ f\n  comm : R.w ≫ Φ.functor.map f = R'.w := by aesop_cat\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.Hom.ext","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nR R' : Φ.RightResolution X₂\nx y : R.Hom R'\nf : Eq x.f y.f\n⊢ Eq x y","decl":"/-- The type of morphisms in the category `Φ.RightResolution X₂` (when `W₁` is multiplicative). -/\n@[ext]\nstructure Hom (R R' : Φ.RightResolution X₂) where\n  /-- a morphism in the source category -/\n  f : R.X₁ ⟶ R'.X₁\n  hf : W₁ f\n  comm : R.w ≫ Φ.functor.map f = R'.w := by aesop_cat\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.Hom.comm_assoc","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nR R' : Φ.RightResolution X₂\nself : R.Hom R'\nZ : C₂\nh : Quiver.Hom (Φ.functor.obj R'.X₁) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp R.w (CategoryTheory.CategoryStruct.comp (Φ.functor.map self.f) h)) (CategoryTheory.CategoryStruct.comp R'.w h)","decl":"attribute [reassoc (attr := simp)] Hom.comm\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.Hom.id_f","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\ninst✝ : W₁.ContainsIdentities\nR : Φ.RightResolution X₂\n⊢ Eq (CategoryTheory.LocalizerMorphism.RightResolution.Hom.id R).f (CategoryTheory.CategoryStruct.id R.X₁)","decl":"/-- The identity of a object in `Φ.RightResolution X₂`. -/\n@[simps]\ndef Hom.id [W₁.ContainsIdentities] (R : Φ.RightResolution X₂) : Hom R R where\n  f := 𝟙 _\n  hf := W₁.id_mem _\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.Hom.comp_f","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\ninst✝ : W₁.IsMultiplicative\nR R' R'' : Φ.RightResolution X₂\nφ : R.Hom R'\nψ : R'.Hom R''\n⊢ Eq (φ.comp ψ).f (CategoryTheory.CategoryStruct.comp φ.f ψ.f)","decl":"/-- The composition of morphisms in `Φ.RightResolution X₂`. -/\n@[simps]\ndef Hom.comp {R R' R'' : Φ.RightResolution X₂}\n    (φ : Hom R R') (ψ : Hom R' R'') :\n    Hom R R'' where\n  f := φ.f ≫ ψ.f\n  hf := W₁.comp_mem _ _ φ.hf ψ.hf\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.id_f","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\ninst✝ : W₁.IsMultiplicative\nR : Φ.RightResolution X₂\n⊢ Eq (CategoryTheory.CategoryStruct.id R).f (CategoryTheory.CategoryStruct.id R.X₁)","decl":"@[simp]\nlemma id_f (R : Φ.RightResolution X₂) : Hom.f (𝟙 R) = 𝟙 R.X₁ := rfl\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.comp_f_assoc","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\ninst✝ : W₁.IsMultiplicative\nR R' R'' : Φ.RightResolution X₂\nφ : Quiver.Hom R R'\nψ : Quiver.Hom R' R''\nZ : C₁\nh : Quiver.Hom R''.X₁ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp φ ψ).f h) (CategoryTheory.CategoryStruct.comp φ.f (CategoryTheory.CategoryStruct.comp ψ.f h))","decl":"@[simp, reassoc]\nlemma comp_f {R R' R'' : Φ.RightResolution X₂} (φ : R ⟶ R') (ψ : R' ⟶ R'') :\n    (φ ≫ ψ).f = φ.f ≫ ψ.f := rfl\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.comp_f","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\ninst✝ : W₁.IsMultiplicative\nR R' R'' : Φ.RightResolution X₂\nφ : Quiver.Hom R R'\nψ : Quiver.Hom R' R''\n⊢ Eq (CategoryTheory.CategoryStruct.comp φ ψ).f (CategoryTheory.CategoryStruct.comp φ.f ψ.f)","decl":"@[simp, reassoc]\nlemma comp_f {R R' R'' : Φ.RightResolution X₂} (φ : R ⟶ R') (ψ : R' ⟶ R'') :\n    (φ ≫ ψ).f = φ.f ≫ ψ.f := rfl\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.hom_ext_iff","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\ninst✝ : W₁.IsMultiplicative\nR R' : Φ.RightResolution X₂\nφ₁ φ₂ : Quiver.Hom R R'\n⊢ Iff (Eq φ₁ φ₂) (Eq φ₁.f φ₂.f)","decl":"@[ext]\nlemma hom_ext {R R' : Φ.RightResolution X₂} {φ₁ φ₂ : R ⟶ R'} (h : φ₁.f = φ₂.f) :\n    φ₁ = φ₂ :=\n  Hom.ext h\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.hom_ext","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\ninst✝ : W₁.IsMultiplicative\nR R' : Φ.RightResolution X₂\nφ₁ φ₂ : Quiver.Hom R R'\nh : Eq φ₁.f φ₂.f\n⊢ Eq φ₁ φ₂","decl":"@[ext]\nlemma hom_ext {R R' : Φ.RightResolution X₂} {φ₁ φ₂ : R ⟶ R'} (h : φ₁.f = φ₂.f) :\n    φ₁ = φ₂ :=\n  Hom.ext h\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.Hom.comm","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nL L' : Φ.LeftResolution X₂\nself : L.Hom L'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Φ.functor.map self.f) L'.w) L.w","decl":"/-- The type of morphisms in the category `Φ.LeftResolution X₂` (when `W₁` is multiplicative). -/\n@[ext]\nstructure Hom (L L' : Φ.LeftResolution X₂) where\n  /-- a morphism in the source category -/\n  f : L.X₁ ⟶ L'.X₁\n  hf : W₁ f\n  comm : Φ.functor.map f ≫ L'.w = L.w := by aesop_cat\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nL L' : Φ.LeftResolution X₂\ninst✝³ : SizeOf C₁\ninst✝² : SizeOf C₂\ninst✝¹ : ⦃X Y : C₁⦄ → (x : Quiver.Hom X Y) → SizeOf (W₁ x)\ninst✝ : ⦃X Y : C₂⦄ → (x : Quiver.Hom X Y) → SizeOf (W₂ x)\nf : Quiver.Hom L.X₁ L'.X₁\nhf : W₁ f\ncomm : autoParam (Eq (CategoryTheory.CategoryStruct.comp (Φ.functor.map f) L'.w) L.w) _auto✝\n⊢ Eq (SizeOf.sizeOf { f := f, hf := hf, comm := comm }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf f)) (SizeOf.sizeOf hf)) (SizeOf.sizeOf comm))","decl":"/-- The type of morphisms in the category `Φ.LeftResolution X₂` (when `W₁` is multiplicative). -/\n@[ext]\nstructure Hom (L L' : Φ.LeftResolution X₂) where\n  /-- a morphism in the source category -/\n  f : L.X₁ ⟶ L'.X₁\n  hf : W₁ f\n  comm : Φ.functor.map f ≫ L'.w = L.w := by aesop_cat\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.Hom.mk.inj","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nL L' : Φ.LeftResolution X₂\nf✝ : Quiver.Hom L.X₁ L'.X₁\nhf✝ : W₁ f✝\ncomm✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (Φ.functor.map f✝) L'.w) L.w) _auto✝\nf : Quiver.Hom L.X₁ L'.X₁\nhf : W₁ f\ncomm : autoParam (Eq (CategoryTheory.CategoryStruct.comp (Φ.functor.map f) L'.w) L.w) _auto✝\nx✝ : Eq { f := f✝, hf := hf✝, comm := comm✝ } { f := f, hf := hf, comm := comm }\n⊢ Eq f✝ f","decl":"/-- The type of morphisms in the category `Φ.LeftResolution X₂` (when `W₁` is multiplicative). -/\n@[ext]\nstructure Hom (L L' : Φ.LeftResolution X₂) where\n  /-- a morphism in the source category -/\n  f : L.X₁ ⟶ L'.X₁\n  hf : W₁ f\n  comm : Φ.functor.map f ≫ L'.w = L.w := by aesop_cat\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.Hom.ext_iff","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nL L' : Φ.LeftResolution X₂\nx y : L.Hom L'\n⊢ Iff (Eq x y) (Eq x.f y.f)","decl":"/-- The type of morphisms in the category `Φ.LeftResolution X₂` (when `W₁` is multiplicative). -/\n@[ext]\nstructure Hom (L L' : Φ.LeftResolution X₂) where\n  /-- a morphism in the source category -/\n  f : L.X₁ ⟶ L'.X₁\n  hf : W₁ f\n  comm : Φ.functor.map f ≫ L'.w = L.w := by aesop_cat\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nL L' : Φ.LeftResolution X₂\nf✝ : Quiver.Hom L.X₁ L'.X₁\nhf✝ : W₁ f✝\ncomm✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (Φ.functor.map f✝) L'.w) L.w) _auto✝\nf : Quiver.Hom L.X₁ L'.X₁\nhf : W₁ f\ncomm : autoParam (Eq (CategoryTheory.CategoryStruct.comp (Φ.functor.map f) L'.w) L.w) _auto✝\n⊢ Eq (Eq { f := f✝, hf := hf✝, comm := comm✝ } { f := f, hf := hf, comm := comm }) (Eq f✝ f)","decl":"/-- The type of morphisms in the category `Φ.LeftResolution X₂` (when `W₁` is multiplicative). -/\n@[ext]\nstructure Hom (L L' : Φ.LeftResolution X₂) where\n  /-- a morphism in the source category -/\n  f : L.X₁ ⟶ L'.X₁\n  hf : W₁ f\n  comm : Φ.functor.map f ≫ L'.w = L.w := by aesop_cat\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.Hom.hf","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nL L' : Φ.LeftResolution X₂\nself : L.Hom L'\n⊢ W₁ self.f","decl":"/-- The type of morphisms in the category `Φ.LeftResolution X₂` (when `W₁` is multiplicative). -/\n@[ext]\nstructure Hom (L L' : Φ.LeftResolution X₂) where\n  /-- a morphism in the source category -/\n  f : L.X₁ ⟶ L'.X₁\n  hf : W₁ f\n  comm : Φ.functor.map f ≫ L'.w = L.w := by aesop_cat\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.Hom.ext","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nL L' : Φ.LeftResolution X₂\nx y : L.Hom L'\nf : Eq x.f y.f\n⊢ Eq x y","decl":"/-- The type of morphisms in the category `Φ.LeftResolution X₂` (when `W₁` is multiplicative). -/\n@[ext]\nstructure Hom (L L' : Φ.LeftResolution X₂) where\n  /-- a morphism in the source category -/\n  f : L.X₁ ⟶ L'.X₁\n  hf : W₁ f\n  comm : Φ.functor.map f ≫ L'.w = L.w := by aesop_cat\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.Hom.comm_assoc","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nL L' : Φ.LeftResolution X₂\nself : L.Hom L'\nZ : C₂\nh : Quiver.Hom X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Φ.functor.map self.f) (CategoryTheory.CategoryStruct.comp L'.w h)) (CategoryTheory.CategoryStruct.comp L.w h)","decl":"attribute [reassoc (attr := simp)] Hom.comm\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.Hom.id_f","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\ninst✝ : W₁.ContainsIdentities\nL : Φ.LeftResolution X₂\n⊢ Eq (CategoryTheory.LocalizerMorphism.LeftResolution.Hom.id L).f (CategoryTheory.CategoryStruct.id L.X₁)","decl":"/-- The identity of a object in `Φ.LeftResolution X₂`. -/\n@[simps]\ndef Hom.id [W₁.ContainsIdentities] (L : Φ.LeftResolution X₂) : Hom L L where\n  f := 𝟙 _\n  hf := W₁.id_mem _\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.Hom.comp_f","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\ninst✝ : W₁.IsMultiplicative\nL L' L'' : Φ.LeftResolution X₂\nφ : L.Hom L'\nψ : L'.Hom L''\n⊢ Eq (φ.comp ψ).f (CategoryTheory.CategoryStruct.comp φ.f ψ.f)","decl":"/-- The composition of morphisms in `Φ.LeftResolution X₂`. -/\n@[simps]\ndef Hom.comp {L L' L'' : Φ.LeftResolution X₂}\n    (φ : Hom L L') (ψ : Hom L' L'') :\n    Hom L L'' where\n  f := φ.f ≫ ψ.f\n  hf := W₁.comp_mem _ _ φ.hf ψ.hf\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.id_f","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\ninst✝ : W₁.IsMultiplicative\nL : Φ.LeftResolution X₂\n⊢ Eq (CategoryTheory.CategoryStruct.id L).f (CategoryTheory.CategoryStruct.id L.X₁)","decl":"@[simp]\nlemma id_f (L : Φ.LeftResolution X₂) : Hom.f (𝟙 L) = 𝟙 L.X₁ := rfl\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.comp_f_assoc","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\ninst✝ : W₁.IsMultiplicative\nL L' L'' : Φ.LeftResolution X₂\nφ : Quiver.Hom L L'\nψ : Quiver.Hom L' L''\nZ : C₁\nh : Quiver.Hom L''.X₁ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp φ ψ).f h) (CategoryTheory.CategoryStruct.comp φ.f (CategoryTheory.CategoryStruct.comp ψ.f h))","decl":"@[simp, reassoc]\nlemma comp_f {L L' L'' : Φ.LeftResolution X₂} (φ : L ⟶ L') (ψ : L' ⟶ L'') :\n    (φ ≫ ψ).f = φ.f ≫ ψ.f := rfl\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.comp_f","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\ninst✝ : W₁.IsMultiplicative\nL L' L'' : Φ.LeftResolution X₂\nφ : Quiver.Hom L L'\nψ : Quiver.Hom L' L''\n⊢ Eq (CategoryTheory.CategoryStruct.comp φ ψ).f (CategoryTheory.CategoryStruct.comp φ.f ψ.f)","decl":"@[simp, reassoc]\nlemma comp_f {L L' L'' : Φ.LeftResolution X₂} (φ : L ⟶ L') (ψ : L' ⟶ L'') :\n    (φ ≫ ψ).f = φ.f ≫ ψ.f := rfl\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.hom_ext_iff","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\ninst✝ : W₁.IsMultiplicative\nL L' : Φ.LeftResolution X₂\nφ₁ φ₂ : Quiver.Hom L L'\n⊢ Iff (Eq φ₁ φ₂) (Eq φ₁.f φ₂.f)","decl":"@[ext]\nlemma hom_ext {L L' : Φ.LeftResolution X₂} {φ₁ φ₂ : L ⟶ L'} (h : φ₁.f = φ₂.f) :\n    φ₁ = φ₂ :=\n  Hom.ext h\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.hom_ext","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\ninst✝ : W₁.IsMultiplicative\nL L' : Φ.LeftResolution X₂\nφ₁ φ₂ : Quiver.Hom L L'\nh : Eq φ₁.f φ₂.f\n⊢ Eq φ₁ φ₂","decl":"@[ext]\nlemma hom_ext {L L' : Φ.LeftResolution X₂} {φ₁ φ₂ : L ⟶ L'} (h : φ₁.f = φ₂.f) :\n    φ₁ = φ₂ :=\n  Hom.ext h\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.op_X₁","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nL : Φ.LeftResolution X₂\n⊢ Eq L.op.X₁ { unop := L.X₁ }","decl":"/-- The canonical map `Φ.LeftResolution X₂ → Φ.op.RightResolution (Opposite.op X₂)`. -/\n@[simps]\ndef LeftResolution.op {X₂ : C₂} (L : Φ.LeftResolution X₂) :\n    Φ.op.RightResolution (Opposite.op X₂) where\n  X₁ := Opposite.op L.X₁\n  w := L.w.op\n  hw := L.hw\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.op_w","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nL : Φ.LeftResolution X₂\n⊢ Eq L.op.w L.w.op","decl":"/-- The canonical map `Φ.LeftResolution X₂ → Φ.op.RightResolution (Opposite.op X₂)`. -/\n@[simps]\ndef LeftResolution.op {X₂ : C₂} (L : Φ.LeftResolution X₂) :\n    Φ.op.RightResolution (Opposite.op X₂) where\n  X₁ := Opposite.op L.X₁\n  w := L.w.op\n  hw := L.hw\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.unop_w","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : Opposite C₂\nL : Φ.op.LeftResolution X₂\n⊢ Eq L.unop.w L.w.unop","decl":"/-- The canonical map `Φ.op.LeftResolution X₂ → Φ.RightResolution X₂`. -/\n@[simps]\ndef LeftResolution.unop {X₂ : C₂ᵒᵖ} (L : Φ.op.LeftResolution X₂) :\n    Φ.RightResolution X₂.unop where\n  X₁ := Opposite.unop L.X₁\n  w := L.w.unop\n  hw := L.hw\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.unop_X₁","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : Opposite C₂\nL : Φ.op.LeftResolution X₂\n⊢ Eq L.unop.X₁ (Opposite.unop L.X₁)","decl":"/-- The canonical map `Φ.op.LeftResolution X₂ → Φ.RightResolution X₂`. -/\n@[simps]\ndef LeftResolution.unop {X₂ : C₂ᵒᵖ} (L : Φ.op.LeftResolution X₂) :\n    Φ.RightResolution X₂.unop where\n  X₁ := Opposite.unop L.X₁\n  w := L.w.unop\n  hw := L.hw\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.op_X₁","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nL : Φ.RightResolution X₂\n⊢ Eq L.op.X₁ { unop := L.X₁ }","decl":"/-- The canonical map `Φ.RightResolution X₂ → Φ.op.LeftResolution (Opposite.op X₂)`. -/\n@[simps]\ndef RightResolution.op {X₂ : C₂} (L : Φ.RightResolution X₂) :\n    Φ.op.LeftResolution (Opposite.op X₂) where\n  X₁ := Opposite.op L.X₁\n  w := L.w.op\n  hw := L.hw\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.op_w","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\nL : Φ.RightResolution X₂\n⊢ Eq L.op.w L.w.op","decl":"/-- The canonical map `Φ.RightResolution X₂ → Φ.op.LeftResolution (Opposite.op X₂)`. -/\n@[simps]\ndef RightResolution.op {X₂ : C₂} (L : Φ.RightResolution X₂) :\n    Φ.op.LeftResolution (Opposite.op X₂) where\n  X₁ := Opposite.op L.X₁\n  w := L.w.op\n  hw := L.hw\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.unop_w","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : Opposite C₂\nL : Φ.op.RightResolution X₂\n⊢ Eq L.unop.w L.w.unop","decl":"/-- The canonical map `Φ.op.RightResolution X₂ → Φ.LeftResolution X₂`. -/\n@[simps]\ndef RightResolution.unop {X₂ : C₂ᵒᵖ} (L : Φ.op.RightResolution X₂) :\n    Φ.LeftResolution X₂.unop where\n  X₁ := Opposite.unop L.X₁\n  w := L.w.unop\n  hw := L.hw\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.unop_X₁","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : Opposite C₂\nL : Φ.op.RightResolution X₂\n⊢ Eq L.unop.X₁ (Opposite.unop L.X₁)","decl":"/-- The canonical map `Φ.op.RightResolution X₂ → Φ.LeftResolution X₂`. -/\n@[simps]\ndef RightResolution.unop {X₂ : C₂ᵒᵖ} (L : Φ.op.RightResolution X₂) :\n    Φ.LeftResolution X₂.unop where\n  X₁ := Opposite.unop L.X₁\n  w := L.w.unop\n  hw := L.hw\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.nonempty_leftResolution_iff_op","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_6, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_5, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\n⊢ Iff (Nonempty (Φ.LeftResolution X₂)) (Nonempty (Φ.op.RightResolution { unop := X₂ }))","decl":"lemma nonempty_leftResolution_iff_op (X₂ : C₂) :\n    Nonempty (Φ.LeftResolution X₂) ↔ Nonempty (Φ.op.RightResolution (Opposite.op X₂)) :=\n  Equiv.nonempty_congr\n    { toFun := fun L => L.op\n      invFun := fun R => R.unop\n      left_inv := fun _ => rfl\n      right_inv := fun _ => rfl }\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.nonempty_rightResolution_iff_op","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_6, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_5, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\n⊢ Iff (Nonempty (Φ.RightResolution X₂)) (Nonempty (Φ.op.LeftResolution { unop := X₂ }))","decl":"lemma nonempty_rightResolution_iff_op (X₂ : C₂) :\n    Nonempty (Φ.RightResolution X₂) ↔ Nonempty (Φ.op.LeftResolution (Opposite.op X₂)) :=\n  Equiv.nonempty_congr\n    { toFun := fun R => R.op\n      invFun := fun L => L.unop\n      left_inv := fun _ => rfl\n      right_inv := fun _ => rfl }\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.hasLeftResolutions_iff_op","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\n⊢ Iff Φ.HasLeftResolutions Φ.op.HasRightResolutions","decl":"lemma hasLeftResolutions_iff_op : Φ.HasLeftResolutions ↔ Φ.op.HasRightResolutions :=\n  ⟨fun _ X₂ => ⟨(Classical.arbitrary (Φ.LeftResolution X₂.unop)).op⟩,\n    fun _ X₂ => ⟨(Classical.arbitrary (Φ.op.RightResolution (Opposite.op X₂))).unop⟩⟩\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.hasRightResolutions_iff_op","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\n⊢ Iff Φ.HasRightResolutions Φ.op.HasLeftResolutions","decl":"lemma hasRightResolutions_iff_op : Φ.HasRightResolutions ↔ Φ.op.HasLeftResolutions :=\n  ⟨fun _ X₂ => ⟨(Classical.arbitrary (Φ.RightResolution X₂.unop)).op⟩,\n    fun _ X₂ => ⟨(Classical.arbitrary (Φ.op.LeftResolution (Opposite.op X₂))).unop⟩⟩\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.opFunctor_obj","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\ninst✝ : W₁.IsMultiplicative\nL : Opposite (Φ.LeftResolution X₂)\n⊢ Eq ((CategoryTheory.LocalizerMorphism.LeftResolution.opFunctor Φ X₂).obj L) (Opposite.unop L).op","decl":"/-- The functor `(Φ.LeftResolution X₂)ᵒᵖ ⥤ Φ.op.RightResolution (Opposite.op X₂)`. -/\n@[simps]\ndef LeftResolution.opFunctor (X₂ : C₂) [W₁.IsMultiplicative] :\n    (Φ.LeftResolution X₂)ᵒᵖ ⥤ Φ.op.RightResolution (Opposite.op X₂) where\n  obj L := L.unop.op\n  map φ :=\n    { f := φ.unop.f.op\n      hf := φ.unop.hf\n      comm := Quiver.Hom.unop_inj φ.unop.comm }\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.opFunctor_map_f","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\ninst✝ : W₁.IsMultiplicative\nX✝ Y✝ : Opposite (Φ.LeftResolution X₂)\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.LocalizerMorphism.LeftResolution.opFunctor Φ X₂).map φ).f φ.unop.f.op","decl":"/-- The functor `(Φ.LeftResolution X₂)ᵒᵖ ⥤ Φ.op.RightResolution (Opposite.op X₂)`. -/\n@[simps]\ndef LeftResolution.opFunctor (X₂ : C₂) [W₁.IsMultiplicative] :\n    (Φ.LeftResolution X₂)ᵒᵖ ⥤ Φ.op.RightResolution (Opposite.op X₂) where\n  obj L := L.unop.op\n  map φ :=\n    { f := φ.unop.f.op\n      hf := φ.unop.hf\n      comm := Quiver.Hom.unop_inj φ.unop.comm }\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.unopFunctor_obj","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : Opposite C₂\ninst✝ : W₁.IsMultiplicative\nR : Opposite (Φ.op.RightResolution X₂)\n⊢ Eq ((CategoryTheory.LocalizerMorphism.RightResolution.unopFunctor Φ X₂).obj R) (Opposite.unop R).unop","decl":"/-- The functor `(Φ.op.RightResolution X₂)ᵒᵖ ⥤ Φ.LeftResolution X₂.unop`. -/\n@[simps]\ndef RightResolution.unopFunctor (X₂ : C₂ᵒᵖ) [W₁.IsMultiplicative] :\n    (Φ.op.RightResolution X₂)ᵒᵖ ⥤ Φ.LeftResolution X₂.unop where\n  obj R := R.unop.unop\n  map φ :=\n    { f := φ.unop.f.unop\n      hf := φ.unop.hf\n      comm := Quiver.Hom.op_inj φ.unop.comm }\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.RightResolution.unopFunctor_map_f","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : Opposite C₂\ninst✝ : W₁.IsMultiplicative\nX✝ Y✝ : Opposite (Φ.op.RightResolution X₂)\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.LocalizerMorphism.RightResolution.unopFunctor Φ X₂).map φ).f φ.unop.f.unop","decl":"/-- The functor `(Φ.op.RightResolution X₂)ᵒᵖ ⥤ Φ.LeftResolution X₂.unop`. -/\n@[simps]\ndef RightResolution.unopFunctor (X₂ : C₂ᵒᵖ) [W₁.IsMultiplicative] :\n    (Φ.op.RightResolution X₂)ᵒᵖ ⥤ Φ.LeftResolution X₂.unop where\n  obj R := R.unop.unop\n  map φ :=\n    { f := φ.unop.f.unop\n      hf := φ.unop.hf\n      comm := Quiver.Hom.op_inj φ.unop.comm }\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.opEquivalence_functor","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\ninst✝ : W₁.IsMultiplicative\n⊢ Eq (CategoryTheory.LocalizerMorphism.LeftResolution.opEquivalence Φ X₂).functor (CategoryTheory.LocalizerMorphism.LeftResolution.opFunctor Φ X₂)","decl":"/-- The equivalence of categories\n`(Φ.LeftResolution X₂)ᵒᵖ ≌ Φ.op.RightResolution (Opposite.op X₂)`. -/\n@[simps]\ndef LeftResolution.opEquivalence (X₂ : C₂) [W₁.IsMultiplicative] :\n    (Φ.LeftResolution X₂)ᵒᵖ ≌ Φ.op.RightResolution (Opposite.op X₂) where\n  functor := LeftResolution.opFunctor Φ X₂\n  inverse := (RightResolution.unopFunctor Φ (Opposite.op X₂)).rightOp\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.opEquivalence_unitIso","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\ninst✝ : W₁.IsMultiplicative\n⊢ Eq (CategoryTheory.LocalizerMorphism.LeftResolution.opEquivalence Φ X₂).unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id (Opposite (Φ.LeftResolution X₂))))","decl":"/-- The equivalence of categories\n`(Φ.LeftResolution X₂)ᵒᵖ ≌ Φ.op.RightResolution (Opposite.op X₂)`. -/\n@[simps]\ndef LeftResolution.opEquivalence (X₂ : C₂) [W₁.IsMultiplicative] :\n    (Φ.LeftResolution X₂)ᵒᵖ ≌ Φ.op.RightResolution (Opposite.op X₂) where\n  functor := LeftResolution.opFunctor Φ X₂\n  inverse := (RightResolution.unopFunctor Φ (Opposite.op X₂)).rightOp\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.opEquivalence_inverse","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\ninst✝ : W₁.IsMultiplicative\n⊢ Eq (CategoryTheory.LocalizerMorphism.LeftResolution.opEquivalence Φ X₂).inverse (CategoryTheory.LocalizerMorphism.RightResolution.unopFunctor Φ { unop := X₂ }).rightOp","decl":"/-- The equivalence of categories\n`(Φ.LeftResolution X₂)ᵒᵖ ≌ Φ.op.RightResolution (Opposite.op X₂)`. -/\n@[simps]\ndef LeftResolution.opEquivalence (X₂ : C₂) [W₁.IsMultiplicative] :\n    (Φ.LeftResolution X₂)ᵒᵖ ≌ Φ.op.RightResolution (Opposite.op X₂) where\n  functor := LeftResolution.opFunctor Φ X₂\n  inverse := (RightResolution.unopFunctor Φ (Opposite.op X₂)).rightOp\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.LeftResolution.opEquivalence_counitIso","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nX₂ : C₂\ninst✝ : W₁.IsMultiplicative\n⊢ Eq (CategoryTheory.LocalizerMorphism.LeftResolution.opEquivalence Φ X₂).counitIso (CategoryTheory.Iso.refl ((CategoryTheory.LocalizerMorphism.RightResolution.unopFunctor Φ { unop := X₂ }).rightOp.comp (CategoryTheory.LocalizerMorphism.LeftResolution.opFunctor Φ X₂)))","decl":"/-- The equivalence of categories\n`(Φ.LeftResolution X₂)ᵒᵖ ≌ Φ.op.RightResolution (Opposite.op X₂)`. -/\n@[simps]\ndef LeftResolution.opEquivalence (X₂ : C₂) [W₁.IsMultiplicative] :\n    (Φ.LeftResolution X₂)ᵒᵖ ≌ Φ.op.RightResolution (Opposite.op X₂) where\n  functor := LeftResolution.opFunctor Φ X₂\n  inverse := (RightResolution.unopFunctor Φ (Opposite.op X₂)).rightOp\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.essSurj_of_hasRightResolutions","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD₂ : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_6, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_7, u_3} D₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nL₂ : CategoryTheory.Functor C₂ D₂\ninst✝¹ : L₂.IsLocalization W₂\ninst✝ : Φ.HasRightResolutions\n⊢ (Φ.functor.comp L₂).EssSurj","decl":"lemma essSurj_of_hasRightResolutions [Φ.HasRightResolutions] : (Φ.functor ⋙ L₂).EssSurj where\n  mem_essImage X₂ := by\n    have := Localization.essSurj L₂ W₂\n    have R : Φ.RightResolution (L₂.objPreimage X₂) := Classical.arbitrary _\n    exact ⟨R.X₁, ⟨(Localization.isoOfHom L₂ W₂ _ R.hw).symm ≪≫ L₂.objObjPreimageIso X₂⟩⟩\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.isIso_iff_of_hasRightResolutions","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD₂ : Type u_3\nH : Type u_4\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} C₂\ninst✝³ : CategoryTheory.Category.{u_7, u_3} D₂\ninst✝² : CategoryTheory.Category.{u_8, u_4} H\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nL₂ : CategoryTheory.Functor C₂ D₂\ninst✝¹ : L₂.IsLocalization W₂\ninst✝ : Φ.HasRightResolutions\nF G : CategoryTheory.Functor D₂ H\nα : Quiver.Hom F G\n⊢ Iff (CategoryTheory.IsIso α) (∀ (X₁ : C₁), CategoryTheory.IsIso (α.app (L₂.obj (Φ.functor.obj X₁))))","decl":"lemma isIso_iff_of_hasRightResolutions [Φ.HasRightResolutions] {F G : D₂ ⥤ H} (α : F ⟶ G) :\n    IsIso α ↔ ∀ (X₁ : C₁), IsIso (α.app (L₂.obj (Φ.functor.obj X₁))) := by\n  constructor\n  · intros\n    infer_instance\n  · intro hα\n    have : ∀ (X₂ : D₂), IsIso (α.app X₂) := fun X₂ => by\n      have := Φ.essSurj_of_hasRightResolutions L₂\n      rw [← NatTrans.isIso_app_iff_of_iso α ((Φ.functor ⋙ L₂).objObjPreimageIso X₂)]\n      apply hα\n    exact NatIso.isIso_of_isIso_app α\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.essSurj_of_hasLeftResolutions","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD₂ : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_6, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_7, u_3} D₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nL₂ : CategoryTheory.Functor C₂ D₂\ninst✝¹ : L₂.IsLocalization W₂\ninst✝ : Φ.HasLeftResolutions\n⊢ (Φ.functor.comp L₂).EssSurj","decl":"lemma essSurj_of_hasLeftResolutions [Φ.HasLeftResolutions] : (Φ.functor ⋙ L₂).EssSurj where\n  mem_essImage X₂ := by\n    have := Localization.essSurj L₂ W₂\n    have L : Φ.LeftResolution (L₂.objPreimage X₂) := Classical.arbitrary _\n    exact ⟨L.X₁, ⟨Localization.isoOfHom L₂ W₂ _ L.hw ≪≫ L₂.objObjPreimageIso X₂⟩⟩\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.isIso_iff_of_hasLeftResolutions","module":"Mathlib.CategoryTheory.Localization.Resolution","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD₂ : Type u_3\nH : Type u_4\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} C₂\ninst✝³ : CategoryTheory.Category.{u_7, u_3} D₂\ninst✝² : CategoryTheory.Category.{u_8, u_4} H\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nΦ : CategoryTheory.LocalizerMorphism W₁ W₂\nL₂ : CategoryTheory.Functor C₂ D₂\ninst✝¹ : L₂.IsLocalization W₂\ninst✝ : Φ.HasLeftResolutions\nF G : CategoryTheory.Functor D₂ H\nα : Quiver.Hom F G\n⊢ Iff (CategoryTheory.IsIso α) (∀ (X₁ : C₁), CategoryTheory.IsIso (α.app (L₂.obj (Φ.functor.obj X₁))))","decl":"lemma isIso_iff_of_hasLeftResolutions [Φ.HasLeftResolutions] {F G : D₂ ⥤ H} (α : F ⟶ G) :\n    IsIso α ↔ ∀ (X₁ : C₁), IsIso (α.app (L₂.obj (Φ.functor.obj X₁))) := by\n  constructor\n  · intros\n    infer_instance\n  · intro hα\n    have : ∀ (X₂ : D₂), IsIso (α.app X₂) := fun X₂ => by\n      have := Φ.essSurj_of_hasLeftResolutions L₂\n      rw [← NatTrans.isIso_app_iff_of_iso α ((Φ.functor ⋙ L₂).objObjPreimageIso X₂)]\n      apply hα\n    exact NatIso.isIso_of_isIso_app α\n\n"}
