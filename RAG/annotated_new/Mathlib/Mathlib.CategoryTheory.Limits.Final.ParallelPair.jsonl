{"name":"CategoryTheory.Limits.parallelPair_initial_mk'","module":"Mathlib.CategoryTheory.Limits.Final.ParallelPair","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf g : Quiver.Hom X Y\nh₁ : ∀ (Z : C), Nonempty (Quiver.Hom X Z)\nh₂ : ∀ ⦃Z : C⦄ (i j : Quiver.Hom X Z), CategoryTheory.Zigzag (CategoryTheory.CostructuredArrow.mk i) (CategoryTheory.CostructuredArrow.mk j)\n⊢ (CategoryTheory.Limits.parallelPair f g).Initial","decl":"lemma parallelPair_initial_mk' {X Y : C} (f g : X ⟶ Y)\n    (h₁ : ∀ Z, Nonempty (X ⟶ Z))\n    (h₂ : ∀ ⦃Z : C⦄ (i j : X ⟶ Z),\n      Zigzag (J := CostructuredArrow (parallelPair f g) Z)\n        (mk (Y := zero) i) (mk (Y := zero) j)) :\n    (parallelPair f g).Initial where\n  out Z := by\n    have : Nonempty (CostructuredArrow (parallelPair f g) Z) :=\n      ⟨mk (Y := zero) (h₁ Z).some⟩\n    have : ∀ (x : CostructuredArrow (parallelPair f g) Z), Zigzag x\n      (mk (Y := zero) (h₁ Z).some) := by\n        rintro ⟨(_|_), ⟨⟩, φ⟩\n        · apply h₂\n        · refine Zigzag.trans ?_ (h₂ (f ≫ φ) _)\n          exact Zigzag.of_inv (homMk left)\n    exact zigzag_isConnected (fun x y => (this x).trans (this y).symm)\n\n"}
{"name":"CategoryTheory.Limits.parallelPair_initial_mk","module":"Mathlib.CategoryTheory.Limits.Final.ParallelPair","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf g : Quiver.Hom X Y\nh₁ : ∀ (Z : C), Nonempty (Quiver.Hom X Z)\nh₂ : ∀ ⦃Z : C⦄ (i j : Quiver.Hom X Z), Exists fun a => And (Eq i (CategoryTheory.CategoryStruct.comp f a)) (Eq j (CategoryTheory.CategoryStruct.comp g a))\n⊢ (CategoryTheory.Limits.parallelPair f g).Initial","decl":"lemma parallelPair_initial_mk {X Y : C} (f g : X ⟶ Y)\n    (h₁ : ∀ Z, Nonempty (X ⟶ Z))\n    (h₂ : ∀ ⦃Z : C⦄ (i j : X ⟶ Z), ∃ (a : Y ⟶ Z), i = f ≫ a ∧ j = g ≫ a) :\n    (parallelPair f g).Initial :=\n  parallelPair_initial_mk' f g h₁ (fun Z i j => by\n    obtain ⟨a, rfl, rfl⟩ := h₂ i j\n    let f₁ : (mk (Y := zero) (f ≫ a) : CostructuredArrow (parallelPair f g) Z) ⟶ mk (Y := one) a :=\n      homMk left\n    let f₂ : (mk (Y := zero) (g ≫ a) : CostructuredArrow (parallelPair f g) Z) ⟶ mk (Y := one) a :=\n      homMk right\n    exact Zigzag.of_hom_inv f₁ f₂)\n\n"}
