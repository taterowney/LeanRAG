{"name":"eigenvalue_mem_ball","module":"Mathlib.LinearAlgebra.Matrix.Gershgorin","initialProofState":"K : Type u_1\nn : Type u_2\ninst✝² : NormedField K\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix n n K\nμ : K\nhμ : Module.End.HasEigenvalue (Matrix.toLin' A) μ\n⊢ Exists fun k => Membership.mem (Metric.closedBall (A k k) ((Finset.univ.erase k).sum fun j => Norm.norm (A k j))) μ","decl":"/-- **Gershgorin's circle theorem**: for any eigenvalue `μ` of a square matrix `A`, there exists an\nindex `k` such that `μ` lies in the closed ball of center the diagonal term `A k k` and of\nradius the sum of the norms `∑ j ≠ k, ‖A k j‖. -/\ntheorem eigenvalue_mem_ball {μ : K} (hμ : Module.End.HasEigenvalue (Matrix.toLin' A) μ) :\n    ∃ k, μ ∈ Metric.closedBall (A k k) (∑ j ∈ Finset.univ.erase k, ‖A k j‖) := by\n  cases isEmpty_or_nonempty n\n  · exfalso\n    exact hμ Submodule.eq_bot_of_subsingleton\n  · obtain ⟨v, h_eg, h_nz⟩ := hμ.exists_hasEigenvector\n    obtain ⟨i, -, h_i⟩ := Finset.exists_mem_eq_sup' Finset.univ_nonempty (fun i => ‖v i‖)\n    have h_nz : v i ≠ 0 := by\n      contrapose! h_nz\n      ext j\n      rw [Pi.zero_apply, ← norm_le_zero_iff]\n      refine (h_i ▸ Finset.le_sup' (fun i => ‖v i‖) (Finset.mem_univ j)).trans ?_\n      exact norm_le_zero_iff.mpr h_nz\n    have h_le : ∀ j, ‖v j * (v i)⁻¹‖ ≤ 1 := fun j => by\n      rw [norm_mul, norm_inv, mul_inv_le_iff₀ (norm_pos_iff.mpr h_nz), one_mul]\n      exact h_i ▸ Finset.le_sup' (fun i => ‖v i‖) (Finset.mem_univ j)\n    simp_rw [mem_closedBall_iff_norm']\n    refine ⟨i, ?_⟩\n    calc\n      _ = ‖(A i i * v i - μ * v i) * (v i)⁻¹‖ := by congr; field_simp [h_nz]; ring\n      _ = ‖(A i i * v i - ∑ j, A i j * v j) * (v i)⁻¹‖ := by\n                rw [show μ * v i = ∑ x : n, A i x * v x by\n                  rw [← dotProduct, ← Matrix.mulVec]\n                  exact (congrFun (Module.End.mem_eigenspace_iff.mp h_eg) i).symm]\n      _ = ‖(∑ j ∈ Finset.univ.erase i, A i j * v j) * (v i)⁻¹‖ := by\n                rw [Finset.sum_erase_eq_sub (Finset.mem_univ i), ← neg_sub, neg_mul, norm_neg]\n      _ ≤ ∑ j ∈ Finset.univ.erase i, ‖A i j‖ * ‖v j * (v i)⁻¹‖ := by\n                rw [Finset.sum_mul]\n                exact (norm_sum_le _ _).trans (le_of_eq (by simp_rw [mul_assoc, norm_mul]))\n      _ ≤ ∑ j ∈ Finset.univ.erase i, ‖A i j‖ :=\n                (Finset.sum_le_sum fun j _ => mul_le_of_le_one_right (norm_nonneg _) (h_le j))\n\n"}
{"name":"det_ne_zero_of_sum_row_lt_diag","module":"Mathlib.LinearAlgebra.Matrix.Gershgorin","initialProofState":"K : Type u_1\nn : Type u_2\ninst✝² : NormedField K\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix n n K\nh : ∀ (k : n), LT.lt ((Finset.univ.erase k).sum fun j => Norm.norm (A k j)) (Norm.norm (A k k))\n⊢ Ne A.det 0","decl":"/-- If `A` is a row strictly dominant diagonal matrix, then it's determinant is nonzero. -/\ntheorem det_ne_zero_of_sum_row_lt_diag (h : ∀ k, ∑ j ∈ Finset.univ.erase k, ‖A k j‖ < ‖A k k‖) :\n    A.det ≠ 0 := by\n  contrapose! h\n  suffices ∃ k, 0 ∈ Metric.closedBall (A k k) (∑ j ∈ Finset.univ.erase k, ‖A k j‖) by\n    exact this.imp (fun a h ↦ by rwa [mem_closedBall_iff_norm', sub_zero] at h)\n  refine eigenvalue_mem_ball ?_\n  rw [Module.End.hasEigenvalue_iff, Module.End.eigenspace_zero, ne_comm]\n  exact ne_of_lt (LinearMap.bot_lt_ker_of_det_eq_zero (by rwa [LinearMap.det_toLin']))\n\n"}
{"name":"det_ne_zero_of_sum_col_lt_diag","module":"Mathlib.LinearAlgebra.Matrix.Gershgorin","initialProofState":"K : Type u_1\nn : Type u_2\ninst✝² : NormedField K\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix n n K\nh : ∀ (k : n), LT.lt ((Finset.univ.erase k).sum fun i => Norm.norm (A i k)) (Norm.norm (A k k))\n⊢ Ne A.det 0","decl":"/-- If `A` is a column strictly dominant diagonal matrix, then it's determinant is nonzero. -/\ntheorem det_ne_zero_of_sum_col_lt_diag (h : ∀ k, ∑ i ∈ Finset.univ.erase k, ‖A i k‖ < ‖A k k‖) :\n    A.det ≠ 0 := by\n  rw [← Matrix.det_transpose]\n  exact det_ne_zero_of_sum_row_lt_diag (by simp_rw [Matrix.transpose_apply]; exact h)\n"}
