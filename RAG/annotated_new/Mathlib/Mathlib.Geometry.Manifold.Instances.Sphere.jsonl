{"name":"stereoToFun_apply","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nv x : E\n⊢ Eq (stereoToFun v x) (HSMul.hSMul (HDiv.hDiv 2 (HSub.hSub 1 (((innerSL Real) v) x))) ((orthogonalProjection (Submodule.span Real (Singleton.singleton v)).orthogonal) x))","decl":"@[simp]\ntheorem stereoToFun_apply (x : E) :\n    stereoToFun v x = (2 / ((1 : ℝ) - innerSL ℝ v x)) • orthogonalProjection (ℝ ∙ v)ᗮ x :=\n  rfl\n\n"}
{"name":"contDiffOn_stereoToFun","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nv : E\nn : WithTop ENat\n⊢ ContDiffOn Real n (stereoToFun v) (setOf fun x => Ne (((innerSL Real) v) x) 1)","decl":"theorem contDiffOn_stereoToFun {n : WithTop ℕ∞} :\n    ContDiffOn ℝ n (stereoToFun v) {x : E | innerSL _ v x ≠ (1 : ℝ)} := by\n  refine ContDiffOn.smul ?_ (orthogonalProjection (ℝ ∙ v)ᗮ).contDiff.contDiffOn\n  refine contDiff_const.contDiffOn.div ?_ ?_\n  · exact (contDiff_const.sub (innerSL ℝ v).contDiff).contDiffOn\n  · intro x h h'\n    exact h (sub_eq_zero.mp h').symm\n\n"}
{"name":"continuousOn_stereoToFun","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nv : E\n⊢ ContinuousOn (stereoToFun v) (setOf fun x => Ne (((innerSL Real) v) x) 1)","decl":"theorem continuousOn_stereoToFun :\n    ContinuousOn (stereoToFun v) {x : E | innerSL _ v x ≠ (1 : ℝ)} :=\n  (contDiffOn_stereoToFun (n := 0)).continuousOn\n\n"}
{"name":"stereoInvFunAux_apply","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nv w : E\n⊢ Eq (stereoInvFunAux v w) (HSMul.hSMul (Inv.inv (HAdd.hAdd (HPow.hPow (Norm.norm w) 2) 4)) (HAdd.hAdd (HSMul.hSMul 4 w) (HSMul.hSMul (HSub.hSub (HPow.hPow (Norm.norm w) 2) 4) v)))","decl":"@[simp]\ntheorem stereoInvFunAux_apply (w : E) :\n    stereoInvFunAux v w = (‖w‖ ^ 2 + 4)⁻¹ • ((4 : ℝ) • w + (‖w‖ ^ 2 - 4) • v) :=\n  rfl\n\n"}
{"name":"stereoInvFunAux_mem","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nv : E\nhv : Eq (Norm.norm v) 1\nw : E\nhw : Membership.mem (Submodule.span Real (Singleton.singleton v)).orthogonal w\n⊢ Membership.mem (Metric.sphere 0 1) (stereoInvFunAux v w)","decl":"theorem stereoInvFunAux_mem (hv : ‖v‖ = 1) {w : E} (hw : w ∈ (ℝ ∙ v)ᗮ) :\n    stereoInvFunAux v w ∈ sphere (0 : E) 1 := by\n  have h₁ : (0 : ℝ) < ‖w‖ ^ 2 + 4 := by positivity\n  suffices ‖(4 : ℝ) • w + (‖w‖ ^ 2 - 4) • v‖ = ‖w‖ ^ 2 + 4 by\n    simp only [mem_sphere_zero_iff_norm, norm_smul, Real.norm_eq_abs, abs_inv, this,\n      abs_of_pos h₁, stereoInvFunAux_apply, inv_mul_cancel₀ h₁.ne']\n  suffices ‖(4 : ℝ) • w + (‖w‖ ^ 2 - 4) • v‖ ^ 2 = (‖w‖ ^ 2 + 4) ^ 2 by\n    simpa only [sq_eq_sq_iff_abs_eq_abs, abs_norm, abs_of_pos h₁] using this\n  rw [Submodule.mem_orthogonal_singleton_iff_inner_left] at hw\n  simp [norm_add_sq_real, norm_smul, inner_smul_left, inner_smul_right, hw, mul_pow,\n    Real.norm_eq_abs, hv]\n  ring\n\n"}
{"name":"hasFDerivAt_stereoInvFunAux","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nv : E\n⊢ HasFDerivAt (stereoInvFunAux v) (ContinuousLinearMap.id Real E) 0","decl":"theorem hasFDerivAt_stereoInvFunAux (v : E) :\n    HasFDerivAt (stereoInvFunAux v) (ContinuousLinearMap.id ℝ E) 0 := by\n  have h₀ : HasFDerivAt (fun w : E => ‖w‖ ^ 2) (0 : E →L[ℝ] ℝ) 0 := by\n    convert (hasStrictFDerivAt_norm_sq (0 : E)).hasFDerivAt\n    simp only [map_zero, smul_zero]\n  have h₁ : HasFDerivAt (fun w : E => (‖w‖ ^ 2 + 4)⁻¹) (0 : E →L[ℝ] ℝ) 0 := by\n    convert (hasFDerivAt_inv _).comp _ (h₀.add (hasFDerivAt_const 4 0)) <;> simp\n  have h₂ : HasFDerivAt (fun w => (4 : ℝ) • w + (‖w‖ ^ 2 - 4) • v)\n      ((4 : ℝ) • ContinuousLinearMap.id ℝ E) 0 := by\n    convert ((hasFDerivAt_const (4 : ℝ) 0).smul (hasFDerivAt_id 0)).add\n      ((h₀.sub (hasFDerivAt_const (4 : ℝ) 0)).smul (hasFDerivAt_const v 0)) using 1\n    ext w\n    simp\n  convert h₁.smul h₂ using 1\n  ext w\n  simp\n\n"}
{"name":"hasFDerivAt_stereoInvFunAux_comp_coe","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nv : E\n⊢ HasFDerivAt (Function.comp (stereoInvFunAux v) Subtype.val) (Submodule.span Real (Singleton.singleton v)).orthogonal.subtypeL 0","decl":"theorem hasFDerivAt_stereoInvFunAux_comp_coe (v : E) :\n    HasFDerivAt (stereoInvFunAux v ∘ ((↑) : (ℝ ∙ v)ᗮ → E)) (ℝ ∙ v)ᗮ.subtypeL 0 := by\n  have : HasFDerivAt (stereoInvFunAux v) (ContinuousLinearMap.id ℝ E) ((ℝ ∙ v)ᗮ.subtypeL 0) :=\n    hasFDerivAt_stereoInvFunAux v\n  refine this.comp (0 : (ℝ ∙ v)ᗮ) (by apply ContinuousLinearMap.hasFDerivAt)\n\n"}
{"name":"contDiff_stereoInvFunAux","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nv : E\nm : WithTop ENat\n⊢ ContDiff Real m (stereoInvFunAux v)","decl":"theorem contDiff_stereoInvFunAux {m : WithTop ℕ∞} : ContDiff ℝ m (stereoInvFunAux v) := by\n  have h₀ : ContDiff ℝ ω fun w : E => ‖w‖ ^ 2 := contDiff_norm_sq ℝ\n  have h₁ : ContDiff ℝ ω fun w : E => (‖w‖ ^ 2 + 4)⁻¹ := by\n    refine (h₀.add contDiff_const).inv ?_\n    intro x\n    nlinarith\n  have h₂ : ContDiff ℝ ω fun w => (4 : ℝ) • w + (‖w‖ ^ 2 - 4) • v := by\n    refine (contDiff_const.smul contDiff_id).add ?_\n    exact (h₀.sub contDiff_const).smul contDiff_const\n  exact (h₁.smul h₂).of_le le_top\n\n"}
{"name":"stereoInvFun_apply","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nv : E\nhv : Eq (Norm.norm v) 1\nw : Subtype fun x => Membership.mem (Submodule.span Real (Singleton.singleton v)).orthogonal x\n⊢ Eq (↑(stereoInvFun hv w)) (HSMul.hSMul (Inv.inv (HAdd.hAdd (HPow.hPow (Norm.norm w) 2) 4)) (HAdd.hAdd (HSMul.hSMul 4 ↑w) (HSMul.hSMul (HSub.hSub (HPow.hPow (Norm.norm w) 2) 4) v)))","decl":"@[simp]\ntheorem stereoInvFun_apply (hv : ‖v‖ = 1) (w : (ℝ ∙ v)ᗮ) :\n    (stereoInvFun hv w : E) = (‖w‖ ^ 2 + 4)⁻¹ • ((4 : ℝ) • w + (‖w‖ ^ 2 - 4) • v) :=\n  rfl\n\n"}
{"name":"stereoInvFun_ne_north_pole","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nv : E\nhv : Eq (Norm.norm v) 1\nw : Subtype fun x => Membership.mem (Submodule.span Real (Singleton.singleton v)).orthogonal x\n⊢ Ne (stereoInvFun hv w) ⟨v, ⋯⟩","decl":"open scoped InnerProductSpace in\ntheorem stereoInvFun_ne_north_pole (hv : ‖v‖ = 1) (w : (ℝ ∙ v)ᗮ) :\n    stereoInvFun hv w ≠ (⟨v, by simp [hv]⟩ : sphere (0 : E) 1) := by\n  refine Subtype.coe_ne_coe.1 ?_\n  rw [← inner_lt_one_iff_real_of_norm_one _ hv]\n  · have hw : ⟪v, w⟫_ℝ = 0 := Submodule.mem_orthogonal_singleton_iff_inner_right.mp w.2\n    have hw' : (‖(w : E)‖ ^ 2 + 4)⁻¹ * (‖(w : E)‖ ^ 2 - 4) < 1 := by\n      rw [inv_mul_lt_iff₀']\n      · linarith\n      positivity\n    simpa [real_inner_comm, inner_add_right, inner_smul_right, real_inner_self_eq_norm_mul_norm, hw,\n      hv] using hw'\n  · simpa using stereoInvFunAux_mem hv w.2\n\n"}
{"name":"continuous_stereoInvFun","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nv : E\nhv : Eq (Norm.norm v) 1\n⊢ Continuous (stereoInvFun hv)","decl":"theorem continuous_stereoInvFun (hv : ‖v‖ = 1) : Continuous (stereoInvFun hv) :=\n  continuous_induced_rng.2\n    ((contDiff_stereoInvFunAux (m := 0)).continuous.comp continuous_subtype_val)\n\n"}
{"name":"stereo_left_inv","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nv : E\nhv : Eq (Norm.norm v) 1\nx : ↑(Metric.sphere 0 1)\nhx : Ne (↑x) v\n⊢ Eq (stereoInvFun hv (stereoToFun v ↑x)) x","decl":"open scoped InnerProductSpace in\nattribute [-simp] AddSubgroupClass.coe_norm Submodule.coe_norm in\ntheorem stereo_left_inv (hv : ‖v‖ = 1) {x : sphere (0 : E) 1} (hx : (x : E) ≠ v) :\n    stereoInvFun hv (stereoToFun v x) = x := by\n  ext\n  simp only [stereoToFun_apply, stereoInvFun_apply, smul_add]\n  -- name two frequently-occurring quantities and write down their basic properties\n  set a : ℝ := innerSL _ v x\n  set y := orthogonalProjection (ℝ ∙ v)ᗮ x\n  have split : ↑x = a • v + ↑y := by\n    convert (orthogonalProjection_add_orthogonalProjection_orthogonal (ℝ ∙ v) x).symm\n    exact (orthogonalProjection_unit_singleton ℝ hv x).symm\n  have hvy : ⟪v, y⟫_ℝ = 0 := Submodule.mem_orthogonal_singleton_iff_inner_right.mp y.2\n  have pythag : 1 = a ^ 2 + ‖y‖ ^ 2 := by\n    have hvy' : ⟪a • v, y⟫_ℝ = 0 := by simp only [inner_smul_left, hvy, mul_zero]\n    convert norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero _ _ hvy' using 2\n    · simp [← split]\n    · simp [norm_smul, hv, ← sq, sq_abs]\n    · exact sq _\n  -- a fact which will be helpful for clearing denominators in the main calculation\n  have ha : 0 < 1 - a := by\n    have : a < 1 := (inner_lt_one_iff_real_of_norm_one hv (by simp)).mpr hx.symm\n    linarith\n  rw [split, Submodule.coe_smul_of_tower]\n  simp only [norm_smul, norm_div, RCLike.norm_ofNat, Real.norm_eq_abs, abs_of_nonneg ha.le]\n  match_scalars\n  · field_simp\n    linear_combination 4 * (1 - a) * pythag\n  · field_simp\n    linear_combination 4 * (a - 1) ^ 3 * pythag\n\n"}
{"name":"stereo_right_inv","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nv : E\nhv : Eq (Norm.norm v) 1\nw : Subtype fun x => Membership.mem (Submodule.span Real (Singleton.singleton v)).orthogonal x\n⊢ Eq (stereoToFun v ↑(stereoInvFun hv w)) w","decl":"theorem stereo_right_inv (hv : ‖v‖ = 1) (w : (ℝ ∙ v)ᗮ) : stereoToFun v (stereoInvFun hv w) = w := by\n  simp only [stereoToFun, stereoInvFun, stereoInvFunAux, smul_add, map_add, map_smul, innerSL_apply,\n    orthogonalProjection_mem_subspace_eq_self]\n  have h₁ : orthogonalProjection (ℝ ∙ v)ᗮ v = 0 :=\n    orthogonalProjection_orthogonalComplement_singleton_eq_zero v\n  -- Porting note: was innerSL _ and now just inner\n  have h₂ : inner v w = (0 : ℝ) := Submodule.mem_orthogonal_singleton_iff_inner_right.mp w.2\n  -- Porting note: was innerSL _ and now just inner\n  have h₃ : inner v v = (1 : ℝ) := by simp [real_inner_self_eq_norm_mul_norm, hv]\n  rw [h₁, h₂, h₃]\n  match_scalars\n  -- TODO(https://github.com/leanprover-community/mathlib4/issues/15486): used to be `field_simp`, but was really slow\n  -- replaced by `simp only ...` to speed up. Reinstate `field_simp` once it is faster.\n  simp (disch := field_simp_discharge) only [add_div', add_sub_sub_cancel, div_div,\n    div_div_eq_mul_div, div_eq_iff, div_mul_eq_mul_div, inv_eq_one_div,\n    mul_div_assoc', mul_one, mul_zero, one_mul, smul_eq_mul, sub_div', zero_add, zero_div, zero_mul]\n  ring\n\n"}
{"name":"stereographic_apply","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nv : E\nhv : Eq (Norm.norm v) 1\nx : ↑(Metric.sphere 0 1)\n⊢ Eq (↑(stereographic hv) x) (HSMul.hSMul (HDiv.hDiv 2 (HSub.hSub 1 (Inner.inner v ↑x))) ((orthogonalProjection (Submodule.span Real (Singleton.singleton v)).orthogonal) ↑x))","decl":"theorem stereographic_apply (hv : ‖v‖ = 1) (x : sphere (0 : E) 1) :\n    stereographic hv x = (2 / ((1 : ℝ) - inner v x)) • orthogonalProjection (ℝ ∙ v)ᗮ x :=\n  rfl\n\n"}
{"name":"stereographic_source","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nv : E\nhv : Eq (Norm.norm v) 1\n⊢ Eq (stereographic hv).source (HasCompl.compl (Singleton.singleton ⟨v, ⋯⟩))","decl":"@[simp]\ntheorem stereographic_source (hv : ‖v‖ = 1) : (stereographic hv).source = {⟨v, by simp [hv]⟩}ᶜ :=\n  rfl\n\n"}
{"name":"stereographic_target","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nv : E\nhv : Eq (Norm.norm v) 1\n⊢ Eq (stereographic hv).target Set.univ","decl":"@[simp]\ntheorem stereographic_target (hv : ‖v‖ = 1) : (stereographic hv).target = Set.univ :=\n  rfl\n\n"}
{"name":"stereographic_apply_neg","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nv : ↑(Metric.sphere 0 1)\n⊢ Eq (↑(stereographic ⋯) (Neg.neg v)) 0","decl":"@[simp]\ntheorem stereographic_apply_neg (v : sphere (0 : E) 1) :\n    stereographic (norm_eq_of_mem_sphere v) (-v) = 0 := by\n  simp [stereographic_apply, orthogonalProjection_orthogonalComplement_singleton_eq_zero]\n\n"}
{"name":"stereographic_neg_apply","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nv : ↑(Metric.sphere 0 1)\n⊢ Eq (↑(stereographic ⋯) v) 0","decl":"@[simp]\ntheorem stereographic_neg_apply (v : sphere (0 : E) 1) :\n    stereographic (norm_eq_of_mem_sphere (-v)) v = 0 := by\n  convert stereographic_apply_neg (-v)\n  ext1\n  simp\n\n"}
{"name":"stereographic'_source","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\nn : Nat\ninst✝ : Fact (Eq (Module.finrank Real E) (HAdd.hAdd n 1))\nv : ↑(Metric.sphere 0 1)\n⊢ Eq (stereographic' n v).source (HasCompl.compl (Singleton.singleton v))","decl":"@[simp]\ntheorem stereographic'_source {n : ℕ} [Fact (finrank ℝ E = n + 1)] (v : sphere (0 : E) 1) :\n    (stereographic' n v).source = {v}ᶜ := by simp [stereographic']\n\n"}
{"name":"stereographic'_target","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\nn : Nat\ninst✝ : Fact (Eq (Module.finrank Real E) (HAdd.hAdd n 1))\nv : ↑(Metric.sphere 0 1)\n⊢ Eq (stereographic' n v).target Set.univ","decl":"@[simp]\ntheorem stereographic'_target {n : ℕ} [Fact (finrank ℝ E = n + 1)] (v : sphere (0 : E) 1) :\n    (stereographic' n v).target = Set.univ := by simp [stereographic']\n\n"}
{"name":"sphere_ext_iff","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nu v : ↑(Metric.sphere 0 1)\n⊢ Iff (Eq u v) (Eq (Inner.inner ↑u ↑v) 1)","decl":"theorem sphere_ext_iff (u v : sphere (0 : E) 1) : u = v ↔ ⟪(u : E), v⟫_ℝ = 1 := by\n  simp [Subtype.ext_iff, inner_eq_one_iff_of_norm_one]\n\n"}
{"name":"stereographic'_symm_apply","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\nn : Nat\ninst✝ : Fact (Eq (Module.finrank Real E) (HAdd.hAdd n 1))\nv : ↑(Metric.sphere 0 1)\nx : EuclideanSpace Real (Fin n)\n⊢ Eq (↑(↑(stereographic' n v).symm x))\n    (let U := (OrthonormalBasis.fromOrthogonalSpanSingleton n ⋯).repr;\n    HAdd.hAdd (HSMul.hSMul (Inv.inv (HAdd.hAdd (HPow.hPow (Norm.norm ↑(U.symm x)) 2) 4)) (HSMul.hSMul 4 ↑(U.symm x))) (HSMul.hSMul (Inv.inv (HAdd.hAdd (HPow.hPow (Norm.norm ↑(U.symm x)) 2) 4)) (HSMul.hSMul (HSub.hSub (HPow.hPow (Norm.norm ↑(U.symm x)) 2) 4) ↑v)))","decl":"theorem stereographic'_symm_apply {n : ℕ} [Fact (finrank ℝ E = n + 1)] (v : sphere (0 : E) 1)\n    (x : EuclideanSpace ℝ (Fin n)) :\n    ((stereographic' n v).symm x : E) =\n      let U : (ℝ ∙ (v : E))ᗮ ≃ₗᵢ[ℝ] EuclideanSpace ℝ (Fin n) :=\n        (OrthonormalBasis.fromOrthogonalSpanSingleton n (ne_zero_of_mem_unit_sphere v)).repr\n      (‖(U.symm x : E)‖ ^ 2 + 4)⁻¹ • (4 : ℝ) • (U.symm x : E) +\n        (‖(U.symm x : E)‖ ^ 2 + 4)⁻¹ • (‖(U.symm x : E)‖ ^ 2 - 4) • v.val := by\n  simp [real_inner_comm, stereographic, stereographic', ← Submodule.coe_norm]\n\n"}
{"name":"EuclideanSpace.instIsManifoldSphere","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\nn : Nat\ninst✝ : Fact (Eq (Module.finrank Real E) (HAdd.hAdd n 1))\n⊢ IsManifold (modelWithCornersSelf Real (EuclideanSpace Real (Fin n))) Top.top ↑(Metric.sphere 0 1)","decl":"/-- The unit sphere in an `n + 1`-dimensional inner product space `E` is an analytic manifold,\nmodelled on the Euclidean space of dimension `n`. -/\ninstance EuclideanSpace.instIsManifoldSphere\n    {n : ℕ} [Fact (finrank ℝ E = n + 1)] :\n    IsManifold (𝓡 n) ω (sphere (0 : E) 1) :=\n  isManifold_of_contDiffOn (𝓡 n) ω (sphere (0 : E) 1)\n    (by\n      rintro _ _ ⟨v, rfl⟩ ⟨v', rfl⟩\n      let U :=\n        (-- Removed type ascription, and this helped for some reason with timeout issues?\n            OrthonormalBasis.fromOrthogonalSpanSingleton (𝕜 := ℝ)\n            n (ne_zero_of_mem_unit_sphere v)).repr\n      let U' :=\n        (-- Removed type ascription, and this helped for some reason with timeout issues?\n            OrthonormalBasis.fromOrthogonalSpanSingleton (𝕜 := ℝ)\n            n (ne_zero_of_mem_unit_sphere v')).repr\n      have H₁ := U'.contDiff.comp_contDiffOn (contDiffOn_stereoToFun (n := ω))\n      -- Porting note: need to help with implicit variables again\n      have H₂ := (contDiff_stereoInvFunAux (m := ω) (v := v.val)|>.comp\n        (ℝ ∙ (v : E))ᗮ.subtypeL.contDiff).comp U.symm.contDiff\n      convert H₁.comp_inter (H₂.contDiffOn : ContDiffOn ℝ ω _ Set.univ) using 1\n      -- -- squeezed from `ext, simp [sphere_ext_iff, stereographic'_symm_apply, real_inner_comm]`\n      simp only [PartialHomeomorph.trans_toPartialEquiv, PartialHomeomorph.symm_toPartialEquiv,\n        PartialEquiv.trans_source, PartialEquiv.symm_source, stereographic'_target,\n        stereographic'_source]\n      simp only [modelWithCornersSelf_coe, modelWithCornersSelf_coe_symm, Set.preimage_id,\n        Set.range_id, Set.inter_univ, Set.univ_inter, Set.compl_singleton_eq, Set.preimage_setOf_eq]\n      simp only [id, comp_apply, Submodule.subtypeL_apply, PartialHomeomorph.coe_coe_symm,\n        innerSL_apply, Ne, sphere_ext_iff, real_inner_comm (v' : E)]\n      rfl)\n\n"}
{"name":"instIsManifoldRealEuclideanSpaceFinModelWithCornersSelfTopWithTopENatElemHAddNatOfNatSphere","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"n : Nat\n⊢ IsManifold (modelWithCornersSelf Real (EuclideanSpace Real (Fin n))) Top.top ↑(Metric.sphere 0 1)","decl":"instance (n : ℕ) : IsManifold (𝓡 n) ω (sphere (0 :  EuclideanSpace ℝ (Fin (n + 1))) 1) :=\n  haveI := Fact.mk (@finrank_euclideanSpace_fin ℝ _ (n + 1))\n  EuclideanSpace.instIsManifoldSphere\n\n"}
{"name":"contMDiff_coe_sphere","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\nm : WithTop ENat\nn : Nat\ninst✝ : Fact (Eq (Module.finrank Real E) (HAdd.hAdd n 1))\n⊢ ContMDiff (modelWithCornersSelf Real (EuclideanSpace Real (Fin n))) (modelWithCornersSelf Real E) m Subtype.val","decl":"/-- The inclusion map (i.e., `coe`) from the sphere in `E` to `E` is analytic. -/\ntheorem contMDiff_coe_sphere {m : WithTop ℕ∞} {n : ℕ} [Fact (finrank ℝ E = n + 1)] :\n    ContMDiff (𝓡 n) 𝓘(ℝ, E) m ((↑) : sphere (0 : E) 1 → E) := by\n  -- Porting note: trouble with filling these implicit variables in the instance\n  have := EuclideanSpace.instIsManifoldSphere (E := E) (n := n)\n  rw [contMDiff_iff]\n  constructor\n  · exact continuous_subtype_val\n  · intro v _\n    let U : _ ≃ₗᵢ[ℝ] _ :=\n      (-- Again, partially removing type ascription...\n          OrthonormalBasis.fromOrthogonalSpanSingleton\n          n (ne_zero_of_mem_unit_sphere (-v))).repr\n    exact\n      ((contDiff_stereoInvFunAux.comp (ℝ ∙ (-v : E))ᗮ.subtypeL.contDiff).comp\n          U.symm.contDiff).contDiffOn\n\n"}
{"name":"ContMDiff.codRestrict_sphere","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : InnerProductSpace Real E\nm : WithTop ENat\nF : Type u_2\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace Real F\nH : Type u_3\ninst✝⁴ : TopologicalSpace H\nI : ModelWithCorners Real F H\nM : Type u_4\ninst✝³ : TopologicalSpace M\ninst✝² : ChartedSpace H M\ninst✝¹ : IsManifold I m M\nn : Nat\ninst✝ : Fact (Eq (Module.finrank Real E) (HAdd.hAdd n 1))\nf : M → E\nhf : ContMDiff I (modelWithCornersSelf Real E) m f\nhf' : ∀ (x : M), Membership.mem (Metric.sphere 0 1) (f x)\n⊢ ContMDiff I (modelWithCornersSelf Real (EuclideanSpace Real (Fin n))) m (Set.codRestrict f (Metric.sphere 0 1) hf')","decl":"/-- If a `C^m` function `f : M → E`, where `M` is some manifold, takes values in the\nsphere, then it restricts to a `C^m` function from `M` to the sphere. -/\ntheorem ContMDiff.codRestrict_sphere {n : ℕ} [Fact (finrank ℝ E = n + 1)] {f : M → E}\n    (hf : ContMDiff I 𝓘(ℝ, E) m f) (hf' : ∀ x, f x ∈ sphere (0 : E) 1) :\n    ContMDiff I (𝓡 n) m (Set.codRestrict _ _ hf' : M → sphere (0 : E) 1) := by\n  rw [contMDiff_iff_target]\n  refine ⟨continuous_induced_rng.2 hf.continuous, ?_⟩\n  intro v\n  let U : _ ≃ₗᵢ[ℝ] _ :=\n    (-- Again, partially removing type ascription... Weird that this helps!\n        OrthonormalBasis.fromOrthogonalSpanSingleton\n        n (ne_zero_of_mem_unit_sphere (-v))).repr\n  have h : ContDiffOn ℝ ω _ Set.univ := U.contDiff.contDiffOn\n  have H₁ := (h.comp_inter contDiffOn_stereoToFun).contMDiffOn\n  have H₂ : ContMDiffOn _ _ _ _ Set.univ := hf.contMDiffOn\n  convert (H₁.of_le le_top).comp' H₂ using 1\n  ext x\n  have hfxv : f x = -↑v ↔ ⟪f x, -↑v⟫_ℝ = 1 := by\n    have hfx : ‖f x‖ = 1 := by simpa using hf' x\n    rw [inner_eq_one_iff_of_norm_one hfx]\n    exact norm_eq_of_mem_sphere (-v)\n  -- Porting note: unfold more\n  dsimp [chartAt, Set.codRestrict, ChartedSpace.chartAt]\n  simp [not_iff_not, Subtype.ext_iff, hfxv, real_inner_comm]\n\n"}
{"name":"contMDiff_neg_sphere","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\nm : WithTop ENat\nn : Nat\ninst✝ : Fact (Eq (Module.finrank Real E) (HAdd.hAdd n 1))\n⊢ ContMDiff (modelWithCornersSelf Real (EuclideanSpace Real (Fin n))) (modelWithCornersSelf Real (EuclideanSpace Real (Fin n))) m fun x => Neg.neg x","decl":"/-- The antipodal map is analytic. -/\ntheorem contMDiff_neg_sphere {m : WithTop ℕ∞} {n : ℕ} [Fact (finrank ℝ E = n + 1)] :\n    ContMDiff (𝓡 n) (𝓡 n) m fun x : sphere (0 : E) 1 => -x := by\n  -- this doesn't elaborate well in term mode\n  apply ContMDiff.codRestrict_sphere\n  apply contDiff_neg.contMDiff.comp _\n  exact contMDiff_coe_sphere\n\n"}
{"name":"range_mfderiv_coe_sphere","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\nn : Nat\ninst✝ : Fact (Eq (Module.finrank Real E) (HAdd.hAdd n 1))\nv : ↑(Metric.sphere 0 1)\n⊢ Eq (LinearMap.range (mfderiv (modelWithCornersSelf Real (EuclideanSpace Real (Fin n))) (modelWithCornersSelf Real E) Subtype.val v)) (Submodule.span Real (Singleton.singleton ↑v)).orthogonal","decl":"/-- Consider the differential of the inclusion of the sphere in `E` at the point `v` as a continuous\nlinear map from `TangentSpace (𝓡 n) v` to `E`.  The range of this map is the orthogonal complement\nof `v` in `E`.\n\nNote that there is an abuse here of the defeq between `E` and the tangent space to `E` at `(v:E`).\nIn general this defeq is not canonical, but in this case (the tangent space of a vector space) it is\ncanonical. -/\ntheorem range_mfderiv_coe_sphere {n : ℕ} [Fact (finrank ℝ E = n + 1)] (v : sphere (0 : E) 1) :\n    LinearMap.range (mfderiv (𝓡 n) 𝓘(ℝ, E) ((↑) : sphere (0 : E) 1 → E) v :\n    TangentSpace (𝓡 n) v →L[ℝ] E) = (ℝ ∙ (v : E))ᗮ := by\n  rw [((contMDiff_coe_sphere v).mdifferentiableAt le_top).mfderiv]\n  dsimp [chartAt]\n  simp only [chartAt, stereographic_neg_apply, fderivWithin_univ,\n    LinearIsometryEquiv.toHomeomorph_symm, LinearIsometryEquiv.coe_toHomeomorph,\n    LinearIsometryEquiv.map_zero, mfld_simps]\n  let U := (OrthonormalBasis.fromOrthogonalSpanSingleton (𝕜 := ℝ) n\n    (ne_zero_of_mem_unit_sphere (-v))).repr\n  -- Porting note: this `suffices` was a `change`\n  suffices\n      LinearMap.range (fderiv ℝ ((stereoInvFunAux (-v : E) ∘ (↑)) ∘ U.symm) 0) = (ℝ ∙ (v : E))ᗮ by\n    convert this using 3\n    apply stereographic'_neg\n  have :\n    HasFDerivAt (stereoInvFunAux (-v : E) ∘ (Subtype.val : (ℝ ∙ (↑(-v) : E))ᗮ → E))\n      (ℝ ∙ (↑(-v) : E))ᗮ.subtypeL (U.symm 0) := by\n    convert hasFDerivAt_stereoInvFunAux_comp_coe (-v : E)\n    simp\n  convert congrArg LinearMap.range (this.comp 0 U.symm.toContinuousLinearEquiv.hasFDerivAt).fderiv\n  symm\n  convert\n    (U.symm : EuclideanSpace ℝ (Fin n) ≃ₗᵢ[ℝ] (ℝ ∙ (↑(-v) : E))ᗮ).range_comp\n      (ℝ ∙ (↑(-v) : E))ᗮ.subtype using 1\n  simp only [Submodule.range_subtype, coe_neg_sphere]\n  congr 1\n  -- we must show `Submodule.span ℝ {v} = Submodule.span ℝ {-v}`\n  apply Submodule.span_eq_span\n  · simp only [Set.singleton_subset_iff, SetLike.mem_coe]\n    rw [← Submodule.neg_mem_iff]\n    exact Submodule.mem_span_singleton_self (-v : E)\n  · simp only [Set.singleton_subset_iff, SetLike.mem_coe]\n    rw [Submodule.neg_mem_iff]\n    exact Submodule.mem_span_singleton_self (v : E)\n\n"}
{"name":"mfderiv_coe_sphere_injective","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\nn : Nat\ninst✝ : Fact (Eq (Module.finrank Real E) (HAdd.hAdd n 1))\nv : ↑(Metric.sphere 0 1)\n⊢ Function.Injective ⇑(mfderiv (modelWithCornersSelf Real (EuclideanSpace Real (Fin n))) (modelWithCornersSelf Real E) Subtype.val v)","decl":"/-- Consider the differential of the inclusion of the sphere in `E` at the point `v` as a continuous\nlinear map from `TangentSpace (𝓡 n) v` to `E`.  This map is injective. -/\ntheorem mfderiv_coe_sphere_injective {n : ℕ} [Fact (finrank ℝ E = n + 1)] (v : sphere (0 : E) 1) :\n    Injective (mfderiv (𝓡 n) 𝓘(ℝ, E) ((↑) : sphere (0 : E) 1 → E) v) := by\n  rw [((contMDiff_coe_sphere v).mdifferentiableAt le_top).mfderiv]\n  simp only [chartAt, stereographic', stereographic_neg_apply, fderivWithin_univ,\n    LinearIsometryEquiv.toHomeomorph_symm, LinearIsometryEquiv.coe_toHomeomorph,\n    LinearIsometryEquiv.map_zero, mfld_simps]\n  let U := (OrthonormalBasis.fromOrthogonalSpanSingleton\n      (𝕜 := ℝ) n (ne_zero_of_mem_unit_sphere (-v))).repr\n  suffices Injective (fderiv ℝ ((stereoInvFunAux (-v : E) ∘ (↑)) ∘ U.symm) 0) by\n    convert this using 3\n    apply stereographic'_neg\n  have : HasFDerivAt (stereoInvFunAux (-v : E) ∘ (Subtype.val : (ℝ ∙ (↑(-v) : E))ᗮ → E))\n      (ℝ ∙ (↑(-v) : E))ᗮ.subtypeL (U.symm 0) := by\n    convert hasFDerivAt_stereoInvFunAux_comp_coe (-v : E)\n    simp\n  have := congr_arg DFunLike.coe <| (this.comp 0 U.symm.toContinuousLinearEquiv.hasFDerivAt).fderiv\n  refine Eq.subst this.symm ?_\n  rw [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe]\n  simpa [- Subtype.val_injective] using Subtype.val_injective\n\n"}
{"name":"finrank_real_complex_fact'","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"⊢ Fact (Eq (Module.finrank Real Complex) (HAdd.hAdd 1 1))","decl":"theorem finrank_real_complex_fact' : Fact (finrank ℝ ℂ = 1 + 1) :=\n  finrank_real_complex_fact\n\n"}
{"name":"instIsManifoldRealEuclideanSpaceFinOfNatNatModelWithCornersSelfTopWithTopENatCircle","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"⊢ IsManifold (modelWithCornersSelf Real (EuclideanSpace Real (Fin 1))) Top.top Circle","decl":"instance : IsManifold (𝓡 1) ω Circle :=\n  EuclideanSpace.instIsManifoldSphere (E := ℂ)\n\n"}
{"name":"instLieGroupRealEuclideanSpaceFinOfNatNatModelWithCornersSelfTopWithTopENatCircle","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"⊢ LieGroup (modelWithCornersSelf Real (EuclideanSpace Real (Fin 1))) Top.top Circle","decl":"/-- The unit circle in `ℂ` is an analytic Lie group. -/\ninstance : LieGroup (𝓡 1) ω Circle where\n  contMDiff_mul := by\n    apply ContMDiff.codRestrict_sphere\n    let c : Circle → ℂ := (↑)\n    have h₂ : ContMDiff (𝓘(ℝ, ℂ).prod 𝓘(ℝ, ℂ)) 𝓘(ℝ, ℂ) ω fun z : ℂ × ℂ => z.fst * z.snd := by\n      rw [contMDiff_iff]\n      exact ⟨continuous_mul, fun x y => contDiff_mul.contDiffOn⟩\n    -- Porting note: needed to fill in first 3 arguments or could not figure out typeclasses\n    suffices h₁ : ContMDiff ((𝓡 1).prod (𝓡 1)) (𝓘(ℝ, ℂ).prod 𝓘(ℝ, ℂ)) ω (Prod.map c c) from\n      h₂.comp h₁\n    apply ContMDiff.prod_map <;>\n    exact contMDiff_coe_sphere\n  contMDiff_inv := by\n    apply ContMDiff.codRestrict_sphere\n    simp only [← Circle.coe_inv, Circle.coe_inv_eq_conj]\n    exact Complex.conjCLE.contDiff.contMDiff.comp contMDiff_coe_sphere\n\n"}
{"name":"contMDiff_circleExp","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"m : WithTop ENat\n⊢ ContMDiff (modelWithCornersSelf Real Real) (modelWithCornersSelf Real (EuclideanSpace Real (Fin 1))) m ⇑Circle.exp","decl":"/-- The map `fun t ↦ exp (t * I)` from `ℝ` to the unit circle in `ℂ` is analytic. -/\ntheorem contMDiff_circleExp {m : WithTop ℕ∞} : ContMDiff 𝓘(ℝ, ℝ) (𝓡 1) m Circle.exp :=\n  (contDiff_exp.comp (contDiff_id.smul contDiff_const)).contMDiff.codRestrict_sphere _\n\n"}
