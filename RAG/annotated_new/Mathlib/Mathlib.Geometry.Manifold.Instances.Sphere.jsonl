{"name":"stereoToFun_apply","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nv x : E\nâŠ¢ Eq (stereoToFun v x) (HSMul.hSMul (HDiv.hDiv 2 (HSub.hSub 1 (((innerSL Real) v) x))) ((orthogonalProjection (Submodule.span Real (Singleton.singleton v)).orthogonal) x))","decl":"@[simp]\ntheorem stereoToFun_apply (x : E) :\n    stereoToFun v x = (2 / ((1 : â„) - innerSL â„ v x)) â€¢ orthogonalProjection (â„ âˆ™ v)á—® x :=\n  rfl\n\n"}
{"name":"contDiffOn_stereoToFun","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nv : E\nn : WithTop ENat\nâŠ¢ ContDiffOn Real n (stereoToFun v) (setOf fun x => Ne (((innerSL Real) v) x) 1)","decl":"theorem contDiffOn_stereoToFun {n : WithTop â„•âˆ} :\n    ContDiffOn â„ n (stereoToFun v) {x : E | innerSL _ v x â‰  (1 : â„)} := by\n  refine ContDiffOn.smul ?_ (orthogonalProjection (â„ âˆ™ v)á—®).contDiff.contDiffOn\n  refine contDiff_const.contDiffOn.div ?_ ?_\n  Â· exact (contDiff_const.sub (innerSL â„ v).contDiff).contDiffOn\n  Â· intro x h h'\n    exact h (sub_eq_zero.mp h').symm\n\n"}
{"name":"continuousOn_stereoToFun","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nv : E\nâŠ¢ ContinuousOn (stereoToFun v) (setOf fun x => Ne (((innerSL Real) v) x) 1)","decl":"theorem continuousOn_stereoToFun :\n    ContinuousOn (stereoToFun v) {x : E | innerSL _ v x â‰  (1 : â„)} :=\n  (contDiffOn_stereoToFun (n := 0)).continuousOn\n\n"}
{"name":"stereoInvFunAux_apply","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nv w : E\nâŠ¢ Eq (stereoInvFunAux v w) (HSMul.hSMul (Inv.inv (HAdd.hAdd (HPow.hPow (Norm.norm w) 2) 4)) (HAdd.hAdd (HSMul.hSMul 4 w) (HSMul.hSMul (HSub.hSub (HPow.hPow (Norm.norm w) 2) 4) v)))","decl":"@[simp]\ntheorem stereoInvFunAux_apply (w : E) :\n    stereoInvFunAux v w = (â€–wâ€– ^ 2 + 4)â»Â¹ â€¢ ((4 : â„) â€¢ w + (â€–wâ€– ^ 2 - 4) â€¢ v) :=\n  rfl\n\n"}
{"name":"stereoInvFunAux_mem","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nv : E\nhv : Eq (Norm.norm v) 1\nw : E\nhw : Membership.mem (Submodule.span Real (Singleton.singleton v)).orthogonal w\nâŠ¢ Membership.mem (Metric.sphere 0 1) (stereoInvFunAux v w)","decl":"theorem stereoInvFunAux_mem (hv : â€–vâ€– = 1) {w : E} (hw : w âˆˆ (â„ âˆ™ v)á—®) :\n    stereoInvFunAux v w âˆˆ sphere (0 : E) 1 := by\n  have hâ‚ : (0 : â„) < â€–wâ€– ^ 2 + 4 := by positivity\n  suffices â€–(4 : â„) â€¢ w + (â€–wâ€– ^ 2 - 4) â€¢ vâ€– = â€–wâ€– ^ 2 + 4 by\n    simp only [mem_sphere_zero_iff_norm, norm_smul, Real.norm_eq_abs, abs_inv, this,\n      abs_of_pos hâ‚, stereoInvFunAux_apply, inv_mul_cancelâ‚€ hâ‚.ne']\n  suffices â€–(4 : â„) â€¢ w + (â€–wâ€– ^ 2 - 4) â€¢ vâ€– ^ 2 = (â€–wâ€– ^ 2 + 4) ^ 2 by\n    simpa only [sq_eq_sq_iff_abs_eq_abs, abs_norm, abs_of_pos hâ‚] using this\n  rw [Submodule.mem_orthogonal_singleton_iff_inner_left] at hw\n  simp [norm_add_sq_real, norm_smul, inner_smul_left, inner_smul_right, hw, mul_pow,\n    Real.norm_eq_abs, hv]\n  ring\n\n"}
{"name":"hasFDerivAt_stereoInvFunAux","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nv : E\nâŠ¢ HasFDerivAt (stereoInvFunAux v) (ContinuousLinearMap.id Real E) 0","decl":"theorem hasFDerivAt_stereoInvFunAux (v : E) :\n    HasFDerivAt (stereoInvFunAux v) (ContinuousLinearMap.id â„ E) 0 := by\n  have hâ‚€ : HasFDerivAt (fun w : E => â€–wâ€– ^ 2) (0 : E â†’L[â„] â„) 0 := by\n    convert (hasStrictFDerivAt_norm_sq (0 : E)).hasFDerivAt\n    simp only [map_zero, smul_zero]\n  have hâ‚ : HasFDerivAt (fun w : E => (â€–wâ€– ^ 2 + 4)â»Â¹) (0 : E â†’L[â„] â„) 0 := by\n    convert (hasFDerivAt_inv _).comp _ (hâ‚€.add (hasFDerivAt_const 4 0)) <;> simp\n  have hâ‚‚ : HasFDerivAt (fun w => (4 : â„) â€¢ w + (â€–wâ€– ^ 2 - 4) â€¢ v)\n      ((4 : â„) â€¢ ContinuousLinearMap.id â„ E) 0 := by\n    convert ((hasFDerivAt_const (4 : â„) 0).smul (hasFDerivAt_id 0)).add\n      ((hâ‚€.sub (hasFDerivAt_const (4 : â„) 0)).smul (hasFDerivAt_const v 0)) using 1\n    ext w\n    simp\n  convert hâ‚.smul hâ‚‚ using 1\n  ext w\n  simp\n\n"}
{"name":"hasFDerivAt_stereoInvFunAux_comp_coe","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nv : E\nâŠ¢ HasFDerivAt (Function.comp (stereoInvFunAux v) Subtype.val) (Submodule.span Real (Singleton.singleton v)).orthogonal.subtypeL 0","decl":"theorem hasFDerivAt_stereoInvFunAux_comp_coe (v : E) :\n    HasFDerivAt (stereoInvFunAux v âˆ˜ ((â†‘) : (â„ âˆ™ v)á—® â†’ E)) (â„ âˆ™ v)á—®.subtypeL 0 := by\n  have : HasFDerivAt (stereoInvFunAux v) (ContinuousLinearMap.id â„ E) ((â„ âˆ™ v)á—®.subtypeL 0) :=\n    hasFDerivAt_stereoInvFunAux v\n  refine this.comp (0 : (â„ âˆ™ v)á—®) (by apply ContinuousLinearMap.hasFDerivAt)\n\n"}
{"name":"contDiff_stereoInvFunAux","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nv : E\nm : WithTop ENat\nâŠ¢ ContDiff Real m (stereoInvFunAux v)","decl":"theorem contDiff_stereoInvFunAux {m : WithTop â„•âˆ} : ContDiff â„ m (stereoInvFunAux v) := by\n  have hâ‚€ : ContDiff â„ Ï‰ fun w : E => â€–wâ€– ^ 2 := contDiff_norm_sq â„\n  have hâ‚ : ContDiff â„ Ï‰ fun w : E => (â€–wâ€– ^ 2 + 4)â»Â¹ := by\n    refine (hâ‚€.add contDiff_const).inv ?_\n    intro x\n    nlinarith\n  have hâ‚‚ : ContDiff â„ Ï‰ fun w => (4 : â„) â€¢ w + (â€–wâ€– ^ 2 - 4) â€¢ v := by\n    refine (contDiff_const.smul contDiff_id).add ?_\n    exact (hâ‚€.sub contDiff_const).smul contDiff_const\n  exact (hâ‚.smul hâ‚‚).of_le le_top\n\n"}
{"name":"stereoInvFun_apply","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nv : E\nhv : Eq (Norm.norm v) 1\nw : Subtype fun x => Membership.mem (Submodule.span Real (Singleton.singleton v)).orthogonal x\nâŠ¢ Eq (â†‘(stereoInvFun hv w)) (HSMul.hSMul (Inv.inv (HAdd.hAdd (HPow.hPow (Norm.norm w) 2) 4)) (HAdd.hAdd (HSMul.hSMul 4 â†‘w) (HSMul.hSMul (HSub.hSub (HPow.hPow (Norm.norm w) 2) 4) v)))","decl":"@[simp]\ntheorem stereoInvFun_apply (hv : â€–vâ€– = 1) (w : (â„ âˆ™ v)á—®) :\n    (stereoInvFun hv w : E) = (â€–wâ€– ^ 2 + 4)â»Â¹ â€¢ ((4 : â„) â€¢ w + (â€–wâ€– ^ 2 - 4) â€¢ v) :=\n  rfl\n\n"}
{"name":"stereoInvFun_ne_north_pole","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nv : E\nhv : Eq (Norm.norm v) 1\nw : Subtype fun x => Membership.mem (Submodule.span Real (Singleton.singleton v)).orthogonal x\nâŠ¢ Ne (stereoInvFun hv w) âŸ¨v, â‹¯âŸ©","decl":"open scoped InnerProductSpace in\ntheorem stereoInvFun_ne_north_pole (hv : â€–vâ€– = 1) (w : (â„ âˆ™ v)á—®) :\n    stereoInvFun hv w â‰  (âŸ¨v, by simp [hv]âŸ© : sphere (0 : E) 1) := by\n  refine Subtype.coe_ne_coe.1 ?_\n  rw [â† inner_lt_one_iff_real_of_norm_one _ hv]\n  Â· have hw : âŸªv, wâŸ«_â„ = 0 := Submodule.mem_orthogonal_singleton_iff_inner_right.mp w.2\n    have hw' : (â€–(w : E)â€– ^ 2 + 4)â»Â¹ * (â€–(w : E)â€– ^ 2 - 4) < 1 := by\n      rw [inv_mul_lt_iffâ‚€']\n      Â· linarith\n      positivity\n    simpa [real_inner_comm, inner_add_right, inner_smul_right, real_inner_self_eq_norm_mul_norm, hw,\n      hv] using hw'\n  Â· simpa using stereoInvFunAux_mem hv w.2\n\n"}
{"name":"continuous_stereoInvFun","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nv : E\nhv : Eq (Norm.norm v) 1\nâŠ¢ Continuous (stereoInvFun hv)","decl":"theorem continuous_stereoInvFun (hv : â€–vâ€– = 1) : Continuous (stereoInvFun hv) :=\n  continuous_induced_rng.2\n    ((contDiff_stereoInvFunAux (m := 0)).continuous.comp continuous_subtype_val)\n\n"}
{"name":"stereo_left_inv","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nv : E\nhv : Eq (Norm.norm v) 1\nx : â†‘(Metric.sphere 0 1)\nhx : Ne (â†‘x) v\nâŠ¢ Eq (stereoInvFun hv (stereoToFun v â†‘x)) x","decl":"open scoped InnerProductSpace in\nattribute [-simp] AddSubgroupClass.coe_norm Submodule.coe_norm in\ntheorem stereo_left_inv (hv : â€–vâ€– = 1) {x : sphere (0 : E) 1} (hx : (x : E) â‰  v) :\n    stereoInvFun hv (stereoToFun v x) = x := by\n  ext\n  simp only [stereoToFun_apply, stereoInvFun_apply, smul_add]\n  -- name two frequently-occurring quantities and write down their basic properties\n  set a : â„ := innerSL _ v x\n  set y := orthogonalProjection (â„ âˆ™ v)á—® x\n  have split : â†‘x = a â€¢ v + â†‘y := by\n    convert (orthogonalProjection_add_orthogonalProjection_orthogonal (â„ âˆ™ v) x).symm\n    exact (orthogonalProjection_unit_singleton â„ hv x).symm\n  have hvy : âŸªv, yâŸ«_â„ = 0 := Submodule.mem_orthogonal_singleton_iff_inner_right.mp y.2\n  have pythag : 1 = a ^ 2 + â€–yâ€– ^ 2 := by\n    have hvy' : âŸªa â€¢ v, yâŸ«_â„ = 0 := by simp only [inner_smul_left, hvy, mul_zero]\n    convert norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero _ _ hvy' using 2\n    Â· simp [â† split]\n    Â· simp [norm_smul, hv, â† sq, sq_abs]\n    Â· exact sq _\n  -- a fact which will be helpful for clearing denominators in the main calculation\n  have ha : 0 < 1 - a := by\n    have : a < 1 := (inner_lt_one_iff_real_of_norm_one hv (by simp)).mpr hx.symm\n    linarith\n  rw [split, Submodule.coe_smul_of_tower]\n  simp only [norm_smul, norm_div, RCLike.norm_ofNat, Real.norm_eq_abs, abs_of_nonneg ha.le]\n  match_scalars\n  Â· field_simp\n    linear_combination 4 * (1 - a) * pythag\n  Â· field_simp\n    linear_combination 4 * (a - 1) ^ 3 * pythag\n\n"}
{"name":"stereo_right_inv","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nv : E\nhv : Eq (Norm.norm v) 1\nw : Subtype fun x => Membership.mem (Submodule.span Real (Singleton.singleton v)).orthogonal x\nâŠ¢ Eq (stereoToFun v â†‘(stereoInvFun hv w)) w","decl":"theorem stereo_right_inv (hv : â€–vâ€– = 1) (w : (â„ âˆ™ v)á—®) : stereoToFun v (stereoInvFun hv w) = w := by\n  simp only [stereoToFun, stereoInvFun, stereoInvFunAux, smul_add, map_add, map_smul, innerSL_apply,\n    orthogonalProjection_mem_subspace_eq_self]\n  have hâ‚ : orthogonalProjection (â„ âˆ™ v)á—® v = 0 :=\n    orthogonalProjection_orthogonalComplement_singleton_eq_zero v\n  -- Porting note: was innerSL _ and now just inner\n  have hâ‚‚ : inner v w = (0 : â„) := Submodule.mem_orthogonal_singleton_iff_inner_right.mp w.2\n  -- Porting note: was innerSL _ and now just inner\n  have hâ‚ƒ : inner v v = (1 : â„) := by simp [real_inner_self_eq_norm_mul_norm, hv]\n  rw [hâ‚, hâ‚‚, hâ‚ƒ]\n  match_scalars\n  -- TODO(https://github.com/leanprover-community/mathlib4/issues/15486): used to be `field_simp`, but was really slow\n  -- replaced by `simp only ...` to speed up. Reinstate `field_simp` once it is faster.\n  simp (disch := field_simp_discharge) only [add_div', add_sub_sub_cancel, div_div,\n    div_div_eq_mul_div, div_eq_iff, div_mul_eq_mul_div, inv_eq_one_div,\n    mul_div_assoc', mul_one, mul_zero, one_mul, smul_eq_mul, sub_div', zero_add, zero_div, zero_mul]\n  ring\n\n"}
{"name":"stereographic_apply","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nv : E\nhv : Eq (Norm.norm v) 1\nx : â†‘(Metric.sphere 0 1)\nâŠ¢ Eq (â†‘(stereographic hv) x) (HSMul.hSMul (HDiv.hDiv 2 (HSub.hSub 1 (Inner.inner v â†‘x))) ((orthogonalProjection (Submodule.span Real (Singleton.singleton v)).orthogonal) â†‘x))","decl":"theorem stereographic_apply (hv : â€–vâ€– = 1) (x : sphere (0 : E) 1) :\n    stereographic hv x = (2 / ((1 : â„) - inner v x)) â€¢ orthogonalProjection (â„ âˆ™ v)á—® x :=\n  rfl\n\n"}
{"name":"stereographic_source","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nv : E\nhv : Eq (Norm.norm v) 1\nâŠ¢ Eq (stereographic hv).source (HasCompl.compl (Singleton.singleton âŸ¨v, â‹¯âŸ©))","decl":"@[simp]\ntheorem stereographic_source (hv : â€–vâ€– = 1) : (stereographic hv).source = {âŸ¨v, by simp [hv]âŸ©}á¶œ :=\n  rfl\n\n"}
{"name":"stereographic_target","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nv : E\nhv : Eq (Norm.norm v) 1\nâŠ¢ Eq (stereographic hv).target Set.univ","decl":"@[simp]\ntheorem stereographic_target (hv : â€–vâ€– = 1) : (stereographic hv).target = Set.univ :=\n  rfl\n\n"}
{"name":"stereographic_apply_neg","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nv : â†‘(Metric.sphere 0 1)\nâŠ¢ Eq (â†‘(stereographic â‹¯) (Neg.neg v)) 0","decl":"@[simp]\ntheorem stereographic_apply_neg (v : sphere (0 : E) 1) :\n    stereographic (norm_eq_of_mem_sphere v) (-v) = 0 := by\n  simp [stereographic_apply, orthogonalProjection_orthogonalComplement_singleton_eq_zero]\n\n"}
{"name":"stereographic_neg_apply","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nv : â†‘(Metric.sphere 0 1)\nâŠ¢ Eq (â†‘(stereographic â‹¯) v) 0","decl":"@[simp]\ntheorem stereographic_neg_apply (v : sphere (0 : E) 1) :\n    stereographic (norm_eq_of_mem_sphere (-v)) v = 0 := by\n  convert stereographic_apply_neg (-v)\n  ext1\n  simp\n\n"}
{"name":"stereographic'_source","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace Real E\nn : Nat\ninstâœ : Fact (Eq (Module.finrank Real E) (HAdd.hAdd n 1))\nv : â†‘(Metric.sphere 0 1)\nâŠ¢ Eq (stereographic' n v).source (HasCompl.compl (Singleton.singleton v))","decl":"@[simp]\ntheorem stereographic'_source {n : â„•} [Fact (finrank â„ E = n + 1)] (v : sphere (0 : E) 1) :\n    (stereographic' n v).source = {v}á¶œ := by simp [stereographic']\n\n"}
{"name":"stereographic'_target","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace Real E\nn : Nat\ninstâœ : Fact (Eq (Module.finrank Real E) (HAdd.hAdd n 1))\nv : â†‘(Metric.sphere 0 1)\nâŠ¢ Eq (stereographic' n v).target Set.univ","decl":"@[simp]\ntheorem stereographic'_target {n : â„•} [Fact (finrank â„ E = n + 1)] (v : sphere (0 : E) 1) :\n    (stereographic' n v).target = Set.univ := by simp [stereographic']\n\n"}
{"name":"sphere_ext_iff","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nu v : â†‘(Metric.sphere 0 1)\nâŠ¢ Iff (Eq u v) (Eq (Inner.inner â†‘u â†‘v) 1)","decl":"theorem sphere_ext_iff (u v : sphere (0 : E) 1) : u = v â†” âŸª(u : E), vâŸ«_â„ = 1 := by\n  simp [Subtype.ext_iff, inner_eq_one_iff_of_norm_one]\n\n"}
{"name":"stereographic'_symm_apply","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace Real E\nn : Nat\ninstâœ : Fact (Eq (Module.finrank Real E) (HAdd.hAdd n 1))\nv : â†‘(Metric.sphere 0 1)\nx : EuclideanSpace Real (Fin n)\nâŠ¢ Eq (â†‘(â†‘(stereographic' n v).symm x))\n    (let U := (OrthonormalBasis.fromOrthogonalSpanSingleton n â‹¯).repr;\n    HAdd.hAdd (HSMul.hSMul (Inv.inv (HAdd.hAdd (HPow.hPow (Norm.norm â†‘(U.symm x)) 2) 4)) (HSMul.hSMul 4 â†‘(U.symm x))) (HSMul.hSMul (Inv.inv (HAdd.hAdd (HPow.hPow (Norm.norm â†‘(U.symm x)) 2) 4)) (HSMul.hSMul (HSub.hSub (HPow.hPow (Norm.norm â†‘(U.symm x)) 2) 4) â†‘v)))","decl":"theorem stereographic'_symm_apply {n : â„•} [Fact (finrank â„ E = n + 1)] (v : sphere (0 : E) 1)\n    (x : EuclideanSpace â„ (Fin n)) :\n    ((stereographic' n v).symm x : E) =\n      let U : (â„ âˆ™ (v : E))á—® â‰ƒâ‚—áµ¢[â„] EuclideanSpace â„ (Fin n) :=\n        (OrthonormalBasis.fromOrthogonalSpanSingleton n (ne_zero_of_mem_unit_sphere v)).repr\n      (â€–(U.symm x : E)â€– ^ 2 + 4)â»Â¹ â€¢ (4 : â„) â€¢ (U.symm x : E) +\n        (â€–(U.symm x : E)â€– ^ 2 + 4)â»Â¹ â€¢ (â€–(U.symm x : E)â€– ^ 2 - 4) â€¢ v.val := by\n  simp [real_inner_comm, stereographic, stereographic', â† Submodule.coe_norm]\n\n"}
{"name":"EuclideanSpace.instIsManifoldSphere","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace Real E\nn : Nat\ninstâœ : Fact (Eq (Module.finrank Real E) (HAdd.hAdd n 1))\nâŠ¢ IsManifold (modelWithCornersSelf Real (EuclideanSpace Real (Fin n))) Top.top â†‘(Metric.sphere 0 1)","decl":"/-- The unit sphere in an `n + 1`-dimensional inner product space `E` is an analytic manifold,\nmodelled on the Euclidean space of dimension `n`. -/\ninstance EuclideanSpace.instIsManifoldSphere\n    {n : â„•} [Fact (finrank â„ E = n + 1)] :\n    IsManifold (ğ“¡ n) Ï‰ (sphere (0 : E) 1) :=\n  isManifold_of_contDiffOn (ğ“¡ n) Ï‰ (sphere (0 : E) 1)\n    (by\n      rintro _ _ âŸ¨v, rflâŸ© âŸ¨v', rflâŸ©\n      let U :=\n        (-- Removed type ascription, and this helped for some reason with timeout issues?\n            OrthonormalBasis.fromOrthogonalSpanSingleton (ğ•œ := â„)\n            n (ne_zero_of_mem_unit_sphere v)).repr\n      let U' :=\n        (-- Removed type ascription, and this helped for some reason with timeout issues?\n            OrthonormalBasis.fromOrthogonalSpanSingleton (ğ•œ := â„)\n            n (ne_zero_of_mem_unit_sphere v')).repr\n      have Hâ‚ := U'.contDiff.comp_contDiffOn (contDiffOn_stereoToFun (n := Ï‰))\n      -- Porting note: need to help with implicit variables again\n      have Hâ‚‚ := (contDiff_stereoInvFunAux (m := Ï‰) (v := v.val)|>.comp\n        (â„ âˆ™ (v : E))á—®.subtypeL.contDiff).comp U.symm.contDiff\n      convert Hâ‚.comp_inter (Hâ‚‚.contDiffOn : ContDiffOn â„ Ï‰ _ Set.univ) using 1\n      -- -- squeezed from `ext, simp [sphere_ext_iff, stereographic'_symm_apply, real_inner_comm]`\n      simp only [PartialHomeomorph.trans_toPartialEquiv, PartialHomeomorph.symm_toPartialEquiv,\n        PartialEquiv.trans_source, PartialEquiv.symm_source, stereographic'_target,\n        stereographic'_source]\n      simp only [modelWithCornersSelf_coe, modelWithCornersSelf_coe_symm, Set.preimage_id,\n        Set.range_id, Set.inter_univ, Set.univ_inter, Set.compl_singleton_eq, Set.preimage_setOf_eq]\n      simp only [id, comp_apply, Submodule.subtypeL_apply, PartialHomeomorph.coe_coe_symm,\n        innerSL_apply, Ne, sphere_ext_iff, real_inner_comm (v' : E)]\n      rfl)\n\n"}
{"name":"instIsManifoldRealEuclideanSpaceFinModelWithCornersSelfTopWithTopENatElemHAddNatOfNatSphere","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"n : Nat\nâŠ¢ IsManifold (modelWithCornersSelf Real (EuclideanSpace Real (Fin n))) Top.top â†‘(Metric.sphere 0 1)","decl":"instance (n : â„•) : IsManifold (ğ“¡ n) Ï‰ (sphere (0 :  EuclideanSpace â„ (Fin (n + 1))) 1) :=\n  haveI := Fact.mk (@finrank_euclideanSpace_fin â„ _ (n + 1))\n  EuclideanSpace.instIsManifoldSphere\n\n"}
{"name":"contMDiff_coe_sphere","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace Real E\nm : WithTop ENat\nn : Nat\ninstâœ : Fact (Eq (Module.finrank Real E) (HAdd.hAdd n 1))\nâŠ¢ ContMDiff (modelWithCornersSelf Real (EuclideanSpace Real (Fin n))) (modelWithCornersSelf Real E) m Subtype.val","decl":"/-- The inclusion map (i.e., `coe`) from the sphere in `E` to `E` is analytic. -/\ntheorem contMDiff_coe_sphere {m : WithTop â„•âˆ} {n : â„•} [Fact (finrank â„ E = n + 1)] :\n    ContMDiff (ğ“¡ n) ğ“˜(â„, E) m ((â†‘) : sphere (0 : E) 1 â†’ E) := by\n  -- Porting note: trouble with filling these implicit variables in the instance\n  have := EuclideanSpace.instIsManifoldSphere (E := E) (n := n)\n  rw [contMDiff_iff]\n  constructor\n  Â· exact continuous_subtype_val\n  Â· intro v _\n    let U : _ â‰ƒâ‚—áµ¢[â„] _ :=\n      (-- Again, partially removing type ascription...\n          OrthonormalBasis.fromOrthogonalSpanSingleton\n          n (ne_zero_of_mem_unit_sphere (-v))).repr\n    exact\n      ((contDiff_stereoInvFunAux.comp (â„ âˆ™ (-v : E))á—®.subtypeL.contDiff).comp\n          U.symm.contDiff).contDiffOn\n\n"}
{"name":"ContMDiff.codRestrict_sphere","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : InnerProductSpace Real E\nm : WithTop ENat\nF : Type u_2\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace Real F\nH : Type u_3\ninstâœâ´ : TopologicalSpace H\nI : ModelWithCorners Real F H\nM : Type u_4\ninstâœÂ³ : TopologicalSpace M\ninstâœÂ² : ChartedSpace H M\ninstâœÂ¹ : IsManifold I m M\nn : Nat\ninstâœ : Fact (Eq (Module.finrank Real E) (HAdd.hAdd n 1))\nf : M â†’ E\nhf : ContMDiff I (modelWithCornersSelf Real E) m f\nhf' : âˆ€ (x : M), Membership.mem (Metric.sphere 0 1) (f x)\nâŠ¢ ContMDiff I (modelWithCornersSelf Real (EuclideanSpace Real (Fin n))) m (Set.codRestrict f (Metric.sphere 0 1) hf')","decl":"/-- If a `C^m` function `f : M â†’ E`, where `M` is some manifold, takes values in the\nsphere, then it restricts to a `C^m` function from `M` to the sphere. -/\ntheorem ContMDiff.codRestrict_sphere {n : â„•} [Fact (finrank â„ E = n + 1)] {f : M â†’ E}\n    (hf : ContMDiff I ğ“˜(â„, E) m f) (hf' : âˆ€ x, f x âˆˆ sphere (0 : E) 1) :\n    ContMDiff I (ğ“¡ n) m (Set.codRestrict _ _ hf' : M â†’ sphere (0 : E) 1) := by\n  rw [contMDiff_iff_target]\n  refine âŸ¨continuous_induced_rng.2 hf.continuous, ?_âŸ©\n  intro v\n  let U : _ â‰ƒâ‚—áµ¢[â„] _ :=\n    (-- Again, partially removing type ascription... Weird that this helps!\n        OrthonormalBasis.fromOrthogonalSpanSingleton\n        n (ne_zero_of_mem_unit_sphere (-v))).repr\n  have h : ContDiffOn â„ Ï‰ _ Set.univ := U.contDiff.contDiffOn\n  have Hâ‚ := (h.comp_inter contDiffOn_stereoToFun).contMDiffOn\n  have Hâ‚‚ : ContMDiffOn _ _ _ _ Set.univ := hf.contMDiffOn\n  convert (Hâ‚.of_le le_top).comp' Hâ‚‚ using 1\n  ext x\n  have hfxv : f x = -â†‘v â†” âŸªf x, -â†‘vâŸ«_â„ = 1 := by\n    have hfx : â€–f xâ€– = 1 := by simpa using hf' x\n    rw [inner_eq_one_iff_of_norm_one hfx]\n    exact norm_eq_of_mem_sphere (-v)\n  -- Porting note: unfold more\n  dsimp [chartAt, Set.codRestrict, ChartedSpace.chartAt]\n  simp [not_iff_not, Subtype.ext_iff, hfxv, real_inner_comm]\n\n"}
{"name":"contMDiff_neg_sphere","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace Real E\nm : WithTop ENat\nn : Nat\ninstâœ : Fact (Eq (Module.finrank Real E) (HAdd.hAdd n 1))\nâŠ¢ ContMDiff (modelWithCornersSelf Real (EuclideanSpace Real (Fin n))) (modelWithCornersSelf Real (EuclideanSpace Real (Fin n))) m fun x => Neg.neg x","decl":"/-- The antipodal map is analytic. -/\ntheorem contMDiff_neg_sphere {m : WithTop â„•âˆ} {n : â„•} [Fact (finrank â„ E = n + 1)] :\n    ContMDiff (ğ“¡ n) (ğ“¡ n) m fun x : sphere (0 : E) 1 => -x := by\n  -- this doesn't elaborate well in term mode\n  apply ContMDiff.codRestrict_sphere\n  apply contDiff_neg.contMDiff.comp _\n  exact contMDiff_coe_sphere\n\n"}
{"name":"range_mfderiv_coe_sphere","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace Real E\nn : Nat\ninstâœ : Fact (Eq (Module.finrank Real E) (HAdd.hAdd n 1))\nv : â†‘(Metric.sphere 0 1)\nâŠ¢ Eq (LinearMap.range (mfderiv (modelWithCornersSelf Real (EuclideanSpace Real (Fin n))) (modelWithCornersSelf Real E) Subtype.val v)) (Submodule.span Real (Singleton.singleton â†‘v)).orthogonal","decl":"/-- Consider the differential of the inclusion of the sphere in `E` at the point `v` as a continuous\nlinear map from `TangentSpace (ğ“¡ n) v` to `E`.  The range of this map is the orthogonal complement\nof `v` in `E`.\n\nNote that there is an abuse here of the defeq between `E` and the tangent space to `E` at `(v:E`).\nIn general this defeq is not canonical, but in this case (the tangent space of a vector space) it is\ncanonical. -/\ntheorem range_mfderiv_coe_sphere {n : â„•} [Fact (finrank â„ E = n + 1)] (v : sphere (0 : E) 1) :\n    LinearMap.range (mfderiv (ğ“¡ n) ğ“˜(â„, E) ((â†‘) : sphere (0 : E) 1 â†’ E) v :\n    TangentSpace (ğ“¡ n) v â†’L[â„] E) = (â„ âˆ™ (v : E))á—® := by\n  rw [((contMDiff_coe_sphere v).mdifferentiableAt le_top).mfderiv]\n  dsimp [chartAt]\n  simp only [chartAt, stereographic_neg_apply, fderivWithin_univ,\n    LinearIsometryEquiv.toHomeomorph_symm, LinearIsometryEquiv.coe_toHomeomorph,\n    LinearIsometryEquiv.map_zero, mfld_simps]\n  let U := (OrthonormalBasis.fromOrthogonalSpanSingleton (ğ•œ := â„) n\n    (ne_zero_of_mem_unit_sphere (-v))).repr\n  -- Porting note: this `suffices` was a `change`\n  suffices\n      LinearMap.range (fderiv â„ ((stereoInvFunAux (-v : E) âˆ˜ (â†‘)) âˆ˜ U.symm) 0) = (â„ âˆ™ (v : E))á—® by\n    convert this using 3\n    apply stereographic'_neg\n  have :\n    HasFDerivAt (stereoInvFunAux (-v : E) âˆ˜ (Subtype.val : (â„ âˆ™ (â†‘(-v) : E))á—® â†’ E))\n      (â„ âˆ™ (â†‘(-v) : E))á—®.subtypeL (U.symm 0) := by\n    convert hasFDerivAt_stereoInvFunAux_comp_coe (-v : E)\n    simp\n  convert congrArg LinearMap.range (this.comp 0 U.symm.toContinuousLinearEquiv.hasFDerivAt).fderiv\n  symm\n  convert\n    (U.symm : EuclideanSpace â„ (Fin n) â‰ƒâ‚—áµ¢[â„] (â„ âˆ™ (â†‘(-v) : E))á—®).range_comp\n      (â„ âˆ™ (â†‘(-v) : E))á—®.subtype using 1\n  simp only [Submodule.range_subtype, coe_neg_sphere]\n  congr 1\n  -- we must show `Submodule.span â„ {v} = Submodule.span â„ {-v}`\n  apply Submodule.span_eq_span\n  Â· simp only [Set.singleton_subset_iff, SetLike.mem_coe]\n    rw [â† Submodule.neg_mem_iff]\n    exact Submodule.mem_span_singleton_self (-v : E)\n  Â· simp only [Set.singleton_subset_iff, SetLike.mem_coe]\n    rw [Submodule.neg_mem_iff]\n    exact Submodule.mem_span_singleton_self (v : E)\n\n"}
{"name":"mfderiv_coe_sphere_injective","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace Real E\nn : Nat\ninstâœ : Fact (Eq (Module.finrank Real E) (HAdd.hAdd n 1))\nv : â†‘(Metric.sphere 0 1)\nâŠ¢ Function.Injective â‡‘(mfderiv (modelWithCornersSelf Real (EuclideanSpace Real (Fin n))) (modelWithCornersSelf Real E) Subtype.val v)","decl":"/-- Consider the differential of the inclusion of the sphere in `E` at the point `v` as a continuous\nlinear map from `TangentSpace (ğ“¡ n) v` to `E`.  This map is injective. -/\ntheorem mfderiv_coe_sphere_injective {n : â„•} [Fact (finrank â„ E = n + 1)] (v : sphere (0 : E) 1) :\n    Injective (mfderiv (ğ“¡ n) ğ“˜(â„, E) ((â†‘) : sphere (0 : E) 1 â†’ E) v) := by\n  rw [((contMDiff_coe_sphere v).mdifferentiableAt le_top).mfderiv]\n  simp only [chartAt, stereographic', stereographic_neg_apply, fderivWithin_univ,\n    LinearIsometryEquiv.toHomeomorph_symm, LinearIsometryEquiv.coe_toHomeomorph,\n    LinearIsometryEquiv.map_zero, mfld_simps]\n  let U := (OrthonormalBasis.fromOrthogonalSpanSingleton\n      (ğ•œ := â„) n (ne_zero_of_mem_unit_sphere (-v))).repr\n  suffices Injective (fderiv â„ ((stereoInvFunAux (-v : E) âˆ˜ (â†‘)) âˆ˜ U.symm) 0) by\n    convert this using 3\n    apply stereographic'_neg\n  have : HasFDerivAt (stereoInvFunAux (-v : E) âˆ˜ (Subtype.val : (â„ âˆ™ (â†‘(-v) : E))á—® â†’ E))\n      (â„ âˆ™ (â†‘(-v) : E))á—®.subtypeL (U.symm 0) := by\n    convert hasFDerivAt_stereoInvFunAux_comp_coe (-v : E)\n    simp\n  have := congr_arg DFunLike.coe <| (this.comp 0 U.symm.toContinuousLinearEquiv.hasFDerivAt).fderiv\n  refine Eq.subst this.symm ?_\n  rw [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe]\n  simpa [- Subtype.val_injective] using Subtype.val_injective\n\n"}
{"name":"finrank_real_complex_fact'","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"âŠ¢ Fact (Eq (Module.finrank Real Complex) (HAdd.hAdd 1 1))","decl":"theorem finrank_real_complex_fact' : Fact (finrank â„ â„‚ = 1 + 1) :=\n  finrank_real_complex_fact\n\n"}
{"name":"instIsManifoldRealEuclideanSpaceFinOfNatNatModelWithCornersSelfTopWithTopENatCircle","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"âŠ¢ IsManifold (modelWithCornersSelf Real (EuclideanSpace Real (Fin 1))) Top.top Circle","decl":"instance : IsManifold (ğ“¡ 1) Ï‰ Circle :=\n  EuclideanSpace.instIsManifoldSphere (E := â„‚)\n\n"}
{"name":"instLieGroupRealEuclideanSpaceFinOfNatNatModelWithCornersSelfTopWithTopENatCircle","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"âŠ¢ LieGroup (modelWithCornersSelf Real (EuclideanSpace Real (Fin 1))) Top.top Circle","decl":"/-- The unit circle in `â„‚` is an analytic Lie group. -/\ninstance : LieGroup (ğ“¡ 1) Ï‰ Circle where\n  contMDiff_mul := by\n    apply ContMDiff.codRestrict_sphere\n    let c : Circle â†’ â„‚ := (â†‘)\n    have hâ‚‚ : ContMDiff (ğ“˜(â„, â„‚).prod ğ“˜(â„, â„‚)) ğ“˜(â„, â„‚) Ï‰ fun z : â„‚ Ã— â„‚ => z.fst * z.snd := by\n      rw [contMDiff_iff]\n      exact âŸ¨continuous_mul, fun x y => contDiff_mul.contDiffOnâŸ©\n    -- Porting note: needed to fill in first 3 arguments or could not figure out typeclasses\n    suffices hâ‚ : ContMDiff ((ğ“¡ 1).prod (ğ“¡ 1)) (ğ“˜(â„, â„‚).prod ğ“˜(â„, â„‚)) Ï‰ (Prod.map c c) from\n      hâ‚‚.comp hâ‚\n    apply ContMDiff.prod_map <;>\n    exact contMDiff_coe_sphere\n  contMDiff_inv := by\n    apply ContMDiff.codRestrict_sphere\n    simp only [â† Circle.coe_inv, Circle.coe_inv_eq_conj]\n    exact Complex.conjCLE.contDiff.contMDiff.comp contMDiff_coe_sphere\n\n"}
{"name":"contMDiff_circleExp","module":"Mathlib.Geometry.Manifold.Instances.Sphere","initialProofState":"m : WithTop ENat\nâŠ¢ ContMDiff (modelWithCornersSelf Real Real) (modelWithCornersSelf Real (EuclideanSpace Real (Fin 1))) m â‡‘Circle.exp","decl":"/-- The map `fun t â†¦ exp (t * I)` from `â„` to the unit circle in `â„‚` is analytic. -/\ntheorem contMDiff_circleExp {m : WithTop â„•âˆ} : ContMDiff ğ“˜(â„, â„) (ğ“¡ 1) m Circle.exp :=\n  (contDiff_exp.comp (contDiff_id.smul contDiff_const)).contMDiff.codRestrict_sphere _\n\n"}
