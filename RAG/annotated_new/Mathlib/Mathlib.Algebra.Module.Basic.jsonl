{"name":"Units.neg_smul","module":"Mathlib.Algebra.Module.Basic","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nu : Units R\nx : M\n⊢ Eq (HSMul.hSMul (Neg.neg u) x) (Neg.neg (HSMul.hSMul u x))","decl":"@[simp]\ntheorem Units.neg_smul [Ring R] [AddCommGroup M] [Module R M] (u : Rˣ) (x : M) :\n    -u • x = -(u • x) := by\n  rw [Units.smul_def, Units.val_neg, _root_.neg_smul, Units.smul_def]\n\n"}
{"name":"invOf_two_smul_add_invOf_two_smul","module":"Mathlib.Algebra.Module.Basic","initialProofState":"M : Type u_3\nR : Type u_5\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Invertible 2\nx : M\n⊢ Eq (HAdd.hAdd (HSMul.hSMul (Invertible.invOf 2) x) (HSMul.hSMul (Invertible.invOf 2) x)) x","decl":"@[simp]\ntheorem invOf_two_smul_add_invOf_two_smul (R) [Semiring R] [AddCommMonoid M] [Module R M]\n    [Invertible (2 : R)] (x : M) :\n    (⅟ 2 : R) • x + (⅟ 2 : R) • x = x :=\n  Convex.combo_self invOf_two_add_invOf_two _\n\n"}
{"name":"map_inv_natCast_smul","module":"Mathlib.Algebra.Module.Basic","initialProofState":"M : Type u_3\nM₂ : Type u_4\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\nF : Type u_5\ninst✝⁵ : FunLike F M M₂\ninst✝⁴ : AddMonoidHomClass F M M₂\nf : F\nR : Type u_6\nS : Type u_7\ninst✝³ : DivisionSemiring R\ninst✝² : DivisionSemiring S\ninst✝¹ : Module R M\ninst✝ : Module S M₂\nn : Nat\nx : M\n⊢ Eq (f (HSMul.hSMul (Inv.inv ↑n) x)) (HSMul.hSMul (Inv.inv ↑n) (f x))","decl":"theorem map_inv_natCast_smul [AddCommMonoid M] [AddCommMonoid M₂] {F : Type*} [FunLike F M M₂]\n    [AddMonoidHomClass F M M₂] (f : F) (R S : Type*)\n    [DivisionSemiring R] [DivisionSemiring S] [Module R M]\n    [Module S M₂] (n : ℕ) (x : M) : f ((n⁻¹ : R) • x) = (n⁻¹ : S) • f x := by\n  by_cases hR : (n : R) = 0 <;> by_cases hS : (n : S) = 0\n  · simp [hR, hS, map_zero f]\n  · suffices ∀ y, f y = 0 by rw [this, this, smul_zero]\n    clear x\n    intro x\n    rw [← inv_smul_smul₀ hS (f x), ← map_natCast_smul f R S]\n    simp [hR, map_zero f]\n  · suffices ∀ y, f y = 0 by simp [this]\n    clear x\n    intro x\n    rw [← smul_inv_smul₀ hR x, map_natCast_smul f R S, hS, zero_smul]\n  · rw [← inv_smul_smul₀ hS (f _), ← map_natCast_smul f R S, smul_inv_smul₀ hR]\n\n"}
{"name":"map_inv_intCast_smul","module":"Mathlib.Algebra.Module.Basic","initialProofState":"M : Type u_3\nM₂ : Type u_4\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup M₂\nF : Type u_5\ninst✝⁵ : FunLike F M M₂\ninst✝⁴ : AddMonoidHomClass F M M₂\nf : F\nR : Type u_6\nS : Type u_7\ninst✝³ : DivisionRing R\ninst✝² : DivisionRing S\ninst✝¹ : Module R M\ninst✝ : Module S M₂\nz : Int\nx : M\n⊢ Eq (f (HSMul.hSMul (Inv.inv ↑z) x)) (HSMul.hSMul (Inv.inv ↑z) (f x))","decl":"theorem map_inv_intCast_smul [AddCommGroup M] [AddCommGroup M₂] {F : Type*} [FunLike F M M₂]\n    [AddMonoidHomClass F M M₂] (f : F) (R S : Type*) [DivisionRing R] [DivisionRing S] [Module R M]\n    [Module S M₂] (z : ℤ) (x : M) : f ((z⁻¹ : R) • x) = (z⁻¹ : S) • f x := by\n  obtain ⟨n, rfl | rfl⟩ := z.eq_nat_or_neg\n  · rw [Int.cast_natCast, Int.cast_natCast, map_inv_natCast_smul _ R S]\n  · simp_rw [Int.cast_neg, Int.cast_natCast, inv_neg, neg_smul, map_neg,\n      map_inv_natCast_smul _ R S]\n\n"}
{"name":"inv_natCast_smul_eq","module":"Mathlib.Algebra.Module.Basic","initialProofState":"E : Type u_5\nR : Type u_6\nS : Type u_7\ninst✝⁴ : AddCommMonoid E\ninst✝³ : DivisionSemiring R\ninst✝² : DivisionSemiring S\ninst✝¹ : Module R E\ninst✝ : Module S E\nn : Nat\nx : E\n⊢ Eq (HSMul.hSMul (Inv.inv ↑n) x) (HSMul.hSMul (Inv.inv ↑n) x)","decl":"/-- If `E` is a vector space over two division semirings `R` and `S`, then scalar multiplications\nagree on inverses of natural numbers in `R` and `S`. -/\ntheorem inv_natCast_smul_eq {E : Type*} (R S : Type*) [AddCommMonoid E] [DivisionSemiring R]\n    [DivisionSemiring S] [Module R E] [Module S E] (n : ℕ) (x : E) :\n    (n⁻¹ : R) • x = (n⁻¹ : S) • x :=\n  map_inv_natCast_smul (AddMonoidHom.id E) R S n x\n\n"}
{"name":"inv_intCast_smul_eq","module":"Mathlib.Algebra.Module.Basic","initialProofState":"E : Type u_5\nR : Type u_6\nS : Type u_7\ninst✝⁴ : AddCommGroup E\ninst✝³ : DivisionRing R\ninst✝² : DivisionRing S\ninst✝¹ : Module R E\ninst✝ : Module S E\nn : Int\nx : E\n⊢ Eq (HSMul.hSMul (Inv.inv ↑n) x) (HSMul.hSMul (Inv.inv ↑n) x)","decl":"/-- If `E` is a vector space over two division rings `R` and `S`, then scalar multiplications\nagree on inverses of integer numbers in `R` and `S`. -/\ntheorem inv_intCast_smul_eq {E : Type*} (R S : Type*) [AddCommGroup E] [DivisionRing R]\n    [DivisionRing S] [Module R E] [Module S E] (n : ℤ) (x : E) : (n⁻¹ : R) • x = (n⁻¹ : S) • x :=\n  map_inv_intCast_smul (AddMonoidHom.id E) R S n x\n\n"}
{"name":"inv_natCast_smul_comm","module":"Mathlib.Algebra.Module.Basic","initialProofState":"α : Type u_5\nE : Type u_6\nR : Type u_7\ninst✝⁴ : AddCommMonoid E\ninst✝³ : DivisionSemiring R\ninst✝² : Monoid α\ninst✝¹ : Module R E\ninst✝ : DistribMulAction α E\nn : Nat\ns : α\nx : E\n⊢ Eq (HSMul.hSMul (Inv.inv ↑n) (HSMul.hSMul s x)) (HSMul.hSMul s (HSMul.hSMul (Inv.inv ↑n) x))","decl":"/-- If `E` is a vector space over a division semiring `R` and has a monoid action by `α`, then that\naction commutes by scalar multiplication of inverses of natural numbers in `R`. -/\ntheorem inv_natCast_smul_comm {α E : Type*} (R : Type*) [AddCommMonoid E] [DivisionSemiring R]\n    [Monoid α] [Module R E] [DistribMulAction α E] (n : ℕ) (s : α) (x : E) :\n    (n⁻¹ : R) • s • x = s • (n⁻¹ : R) • x :=\n  (map_inv_natCast_smul (DistribMulAction.toAddMonoidHom E s) R R n x).symm\n\n"}
{"name":"inv_intCast_smul_comm","module":"Mathlib.Algebra.Module.Basic","initialProofState":"α : Type u_5\nE : Type u_6\nR : Type u_7\ninst✝⁴ : AddCommGroup E\ninst✝³ : DivisionRing R\ninst✝² : Monoid α\ninst✝¹ : Module R E\ninst✝ : DistribMulAction α E\nn : Int\ns : α\nx : E\n⊢ Eq (HSMul.hSMul (Inv.inv ↑n) (HSMul.hSMul s x)) (HSMul.hSMul s (HSMul.hSMul (Inv.inv ↑n) x))","decl":"/-- If `E` is a vector space over a division ring `R` and has a monoid action by `α`, then that\naction commutes by scalar multiplication of inverses of integers in `R` -/\ntheorem inv_intCast_smul_comm {α E : Type*} (R : Type*) [AddCommGroup E] [DivisionRing R]\n    [Monoid α] [Module R E] [DistribMulAction α E] (n : ℤ) (s : α) (x : E) :\n    (n⁻¹ : R) • s • x = s • (n⁻¹ : R) • x :=\n  (map_inv_intCast_smul (DistribMulAction.toAddMonoidHom E s) R R n x).symm\n\n"}
{"name":"Function.support_smul_subset_left","module":"Mathlib.Algebra.Module.Basic","initialProofState":"α : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝² : Zero R\ninst✝¹ : Zero M\ninst✝ : SMulWithZero R M\nf : α → R\ng : α → M\n⊢ HasSubset.Subset (Function.support (HSMul.hSMul f g)) (Function.support f)","decl":"lemma support_smul_subset_left [Zero R] [Zero M] [SMulWithZero R M] (f : α → R) (g : α → M) :\n    support (f • g) ⊆ support f := fun x hfg hf ↦\n  hfg <| by rw [Pi.smul_apply', hf, zero_smul]\n\n-- Changed (2024-01-21): this lemma was generalised;\n-- the old version is now called `support_const_smul_subset`.\n"}
{"name":"Function.support_smul_subset_right","module":"Mathlib.Algebra.Module.Basic","initialProofState":"α : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝¹ : Zero M\ninst✝ : SMulZeroClass R M\nf : α → R\ng : α → M\n⊢ HasSubset.Subset (Function.support (HSMul.hSMul f g)) (Function.support g)","decl":"lemma support_smul_subset_right [Zero M] [SMulZeroClass R M] (f : α → R) (g : α → M) :\n    support (f • g) ⊆ support g :=\n  fun x hbf hf ↦ hbf <| by rw [Pi.smul_apply', hf, smul_zero]\n\n"}
{"name":"Function.support_const_smul_of_ne_zero","module":"Mathlib.Algebra.Module.Basic","initialProofState":"α : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝³ : Zero R\ninst✝² : Zero M\ninst✝¹ : SMulWithZero R M\ninst✝ : NoZeroSMulDivisors R M\nc : R\ng : α → M\nhc : Ne c 0\n⊢ Eq (Function.support (HSMul.hSMul c g)) (Function.support g)","decl":"lemma support_const_smul_of_ne_zero [Zero R] [Zero M] [SMulWithZero R M] [NoZeroSMulDivisors R M]\n    (c : R) (g : α → M) (hc : c ≠ 0) : support (c • g) = support g :=\n  ext fun x ↦ by simp only [hc, mem_support, Pi.smul_apply, Ne, smul_eq_zero, false_or]\n\n"}
{"name":"Function.support_smul","module":"Mathlib.Algebra.Module.Basic","initialProofState":"α : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝³ : Zero R\ninst✝² : Zero M\ninst✝¹ : SMulWithZero R M\ninst✝ : NoZeroSMulDivisors R M\nf : α → R\ng : α → M\n⊢ Eq (Function.support (HSMul.hSMul f g)) (Inter.inter (Function.support f) (Function.support g))","decl":"lemma support_smul [Zero R] [Zero M] [SMulWithZero R M] [NoZeroSMulDivisors R M] (f : α → R)\n    (g : α → M) : support (f • g) = support f ∩ support g :=\n  ext fun _ => smul_ne_zero_iff\n\n"}
{"name":"Function.support_const_smul_subset","module":"Mathlib.Algebra.Module.Basic","initialProofState":"α : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝¹ : Zero M\ninst✝ : SMulZeroClass R M\na : R\nf : α → M\n⊢ HasSubset.Subset (Function.support (HSMul.hSMul a f)) (Function.support f)","decl":"lemma support_const_smul_subset [Zero M] [SMulZeroClass R M] (a : R) (f : α → M) :\n    support (a • f) ⊆ support f := support_smul_subset_right (fun _ ↦ a) f\n\n"}
{"name":"Set.indicator_smul_apply","module":"Mathlib.Algebra.Module.Basic","initialProofState":"α : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝¹ : Zero M\ninst✝ : SMulZeroClass R M\ns : Set α\nr : α → R\nf : α → M\na : α\n⊢ Eq (s.indicator (fun a => HSMul.hSMul (r a) (f a)) a) (HSMul.hSMul (r a) (s.indicator f a))","decl":"lemma indicator_smul_apply (s : Set α) (r : α → R) (f : α → M) (a : α) :\n    indicator s (fun a ↦ r a • f a) a = r a • indicator s f a := by\n  dsimp only [indicator]\n  split_ifs\n  exacts [rfl, (smul_zero (r a)).symm]\n\n"}
{"name":"Set.indicator_smul","module":"Mathlib.Algebra.Module.Basic","initialProofState":"α : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝¹ : Zero M\ninst✝ : SMulZeroClass R M\ns : Set α\nr : α → R\nf : α → M\n⊢ Eq (s.indicator fun a => HSMul.hSMul (r a) (f a)) fun a => HSMul.hSMul (r a) (s.indicator f a)","decl":"lemma indicator_smul (s : Set α) (r : α → R) (f : α → M) :\n    indicator s (fun a ↦ r a • f a) = fun a ↦ r a • indicator s f a :=\n  funext <| indicator_smul_apply s r f\n\n"}
{"name":"Set.indicator_const_smul_apply","module":"Mathlib.Algebra.Module.Basic","initialProofState":"α : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝¹ : Zero M\ninst✝ : SMulZeroClass R M\ns : Set α\nr : R\nf : α → M\na : α\n⊢ Eq (s.indicator (fun x => HSMul.hSMul r (f x)) a) (HSMul.hSMul r (s.indicator f a))","decl":"lemma indicator_const_smul_apply (s : Set α) (r : R) (f : α → M) (a : α) :\n    indicator s (r • f ·) a = r • indicator s f a :=\n  indicator_smul_apply s (fun _ ↦ r) f a\n\n"}
{"name":"Set.indicator_const_smul","module":"Mathlib.Algebra.Module.Basic","initialProofState":"α : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝¹ : Zero M\ninst✝ : SMulZeroClass R M\ns : Set α\nr : R\nf : α → M\n⊢ Eq (s.indicator fun x => HSMul.hSMul r (f x)) fun x => HSMul.hSMul r (s.indicator f x)","decl":"lemma indicator_const_smul (s : Set α) (r : R) (f : α → M) :\n    indicator s (r • f ·) = (r • indicator s f ·) :=\n  funext <| indicator_const_smul_apply s r f\n\n"}
{"name":"Set.indicator_smul_apply_left","module":"Mathlib.Algebra.Module.Basic","initialProofState":"α : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝² : Zero R\ninst✝¹ : Zero M\ninst✝ : SMulWithZero R M\ns : Set α\nr : α → R\nf : α → M\na : α\n⊢ Eq (s.indicator (fun a => HSMul.hSMul (r a) (f a)) a) (HSMul.hSMul (s.indicator r a) (f a))","decl":"lemma indicator_smul_apply_left (s : Set α) (r : α → R) (f : α → M) (a : α) :\n    indicator s (fun a ↦ r a • f a) a = indicator s r a • f a := by\n  dsimp only [indicator]\n  split_ifs\n  exacts [rfl, (zero_smul _ (f a)).symm]\n\n"}
{"name":"Set.indicator_smul_left","module":"Mathlib.Algebra.Module.Basic","initialProofState":"α : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝² : Zero R\ninst✝¹ : Zero M\ninst✝ : SMulWithZero R M\ns : Set α\nr : α → R\nf : α → M\n⊢ Eq (s.indicator fun a => HSMul.hSMul (r a) (f a)) fun a => HSMul.hSMul (s.indicator r a) (f a)","decl":"lemma indicator_smul_left (s : Set α) (r : α → R) (f : α → M) :\n    indicator s (fun a ↦ r a • f a) = fun a ↦ indicator s r a • f a :=\n  funext <| indicator_smul_apply_left _ _ _\n\n"}
{"name":"Set.indicator_smul_const_apply","module":"Mathlib.Algebra.Module.Basic","initialProofState":"α : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝² : Zero R\ninst✝¹ : Zero M\ninst✝ : SMulWithZero R M\ns : Set α\nr : α → R\nm : M\na : α\n⊢ Eq (s.indicator (fun x => HSMul.hSMul (r x) m) a) (HSMul.hSMul (s.indicator r a) m)","decl":"lemma indicator_smul_const_apply (s : Set α) (r : α → R) (m : M) (a : α) :\n    indicator s (r · • m) a = indicator s r a • m := indicator_smul_apply_left _ _ _ _\n\n"}
{"name":"Set.indicator_smul_const","module":"Mathlib.Algebra.Module.Basic","initialProofState":"α : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝² : Zero R\ninst✝¹ : Zero M\ninst✝ : SMulWithZero R M\ns : Set α\nr : α → R\nm : M\n⊢ Eq (s.indicator fun x => HSMul.hSMul (r x) m) fun x => HSMul.hSMul (s.indicator r x) m","decl":"lemma indicator_smul_const (s : Set α) (r : α → R) (m : M) :\n    indicator s (r · • m) = (indicator s r · • m) :=\n  funext <| indicator_smul_const_apply _ _ _\n\n"}
{"name":"Set.smul_indicator_one_apply","module":"Mathlib.Algebra.Module.Basic","initialProofState":"α : Type u_1\nR : Type u_2\ninst✝ : MulZeroOneClass R\ns : Set α\nr : R\na : α\n⊢ Eq (HSMul.hSMul r (s.indicator 1 a)) (s.indicator (fun x => r) a)","decl":"lemma smul_indicator_one_apply (s : Set α) (r : R) (a : α) :\n    r • s.indicator (1 : α → R) a = s.indicator (fun _ ↦ r) a := by\n  simp_rw [← indicator_const_smul_apply, Pi.one_apply, smul_eq_mul, mul_one]\n\n"}
