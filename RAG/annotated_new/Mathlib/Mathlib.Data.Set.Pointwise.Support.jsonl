{"name":"mulSupport_comp_inv_smul","module":"Mathlib.Data.Set.Pointwise.Support","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : Group α\ninst✝¹ : MulAction α β\ninst✝ : One γ\nc : α\nf : β → γ\n⊢ Eq (Function.mulSupport fun x => f (HSMul.hSMul (Inv.inv c) x)) (HSMul.hSMul c (Function.mulSupport f))","decl":"theorem mulSupport_comp_inv_smul [One γ] (c : α) (f : β → γ) :\n    (mulSupport fun x ↦ f (c⁻¹ • x)) = c • mulSupport f := by\n  ext x\n  simp only [mem_smul_set_iff_inv_smul_mem, mem_mulSupport]\n\n/- Note: to_additive also automatically translates `SMul` to `VAdd`, so we give the additive version\nmanually. -/\n"}
{"name":"support_comp_inv_smul","module":"Mathlib.Data.Set.Pointwise.Support","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : Group α\ninst✝¹ : MulAction α β\ninst✝ : Zero γ\nc : α\nf : β → γ\n⊢ Eq (Function.support fun x => f (HSMul.hSMul (Inv.inv c) x)) (HSMul.hSMul c (Function.support f))","decl":"theorem support_comp_inv_smul [Zero γ] (c : α) (f : β → γ) :\n    (support fun x ↦ f (c⁻¹ • x)) = c • support f := by\n  ext x\n  simp only [mem_smul_set_iff_inv_smul_mem, mem_support]\n\n"}
{"name":"mulSupport_comp_inv_smul₀","module":"Mathlib.Data.Set.Pointwise.Support","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : GroupWithZero α\ninst✝¹ : MulAction α β\ninst✝ : One γ\nc : α\nhc : Ne c 0\nf : β → γ\n⊢ Eq (Function.mulSupport fun x => f (HSMul.hSMul (Inv.inv c) x)) (HSMul.hSMul c (Function.mulSupport f))","decl":"theorem mulSupport_comp_inv_smul₀ [One γ] {c : α} (hc : c ≠ 0) (f : β → γ) :\n    (mulSupport fun x ↦ f (c⁻¹ • x)) = c • mulSupport f := by\n  ext x\n  simp only [mem_smul_set_iff_inv_smul_mem₀ hc, mem_mulSupport]\n\n/- Note: to_additive also automatically translates `SMul` to `VAdd`, so we give the additive version\nmanually. -/\n"}
{"name":"support_comp_inv_smul₀","module":"Mathlib.Data.Set.Pointwise.Support","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : GroupWithZero α\ninst✝¹ : MulAction α β\ninst✝ : Zero γ\nc : α\nhc : Ne c 0\nf : β → γ\n⊢ Eq (Function.support fun x => f (HSMul.hSMul (Inv.inv c) x)) (HSMul.hSMul c (Function.support f))","decl":"theorem support_comp_inv_smul₀ [Zero γ] {c : α} (hc : c ≠ 0) (f : β → γ) :\n    (support fun x ↦ f (c⁻¹ • x)) = c • support f := by\n  ext x\n  simp only [mem_smul_set_iff_inv_smul_mem₀ hc, mem_support]\n\n"}
