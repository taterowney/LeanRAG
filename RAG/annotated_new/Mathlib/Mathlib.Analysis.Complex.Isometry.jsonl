{"name":"rotation_apply","module":"Mathlib.Analysis.Complex.Isometry","initialProofState":"a : Circle\nz : Complex\n⊢ Eq ((rotation a) z) (HMul.hMul (↑a) z)","decl":"@[simp]\ntheorem rotation_apply (a : Circle) (z : ℂ) : rotation a z = a * z :=\n  rfl\n\n"}
{"name":"rotation_symm","module":"Mathlib.Analysis.Complex.Isometry","initialProofState":"a : Circle\n⊢ Eq (rotation a).symm (rotation (Inv.inv a))","decl":"@[simp]\ntheorem rotation_symm (a : Circle) : (rotation a).symm = rotation a⁻¹ :=\n  LinearIsometryEquiv.ext fun _ => rfl\n\n"}
{"name":"rotation_trans","module":"Mathlib.Analysis.Complex.Isometry","initialProofState":"a b : Circle\n⊢ Eq ((rotation a).trans (rotation b)) (rotation (HMul.hMul b a))","decl":"@[simp]\ntheorem rotation_trans (a b : Circle) : (rotation a).trans (rotation b) = rotation (b * a) := by\n  ext1\n  simp\n\n"}
{"name":"rotation_ne_conjLIE","module":"Mathlib.Analysis.Complex.Isometry","initialProofState":"a : Circle\n⊢ Ne (rotation a) Complex.conjLIE","decl":"theorem rotation_ne_conjLIE (a : Circle) : rotation a ≠ conjLIE := by\n  intro h\n  have h1 : rotation a 1 = conj 1 := LinearIsometryEquiv.congr_fun h 1\n  have hI : rotation a I = conj I := LinearIsometryEquiv.congr_fun h I\n  rw [rotation_apply, RingHom.map_one, mul_one] at h1\n  rw [rotation_apply, conj_I, ← neg_one_mul, mul_left_inj' I_ne_zero, h1, eq_neg_self_iff] at hI\n  exact one_ne_zero hI\n\n"}
{"name":"rotationOf_coe","module":"Mathlib.Analysis.Complex.Isometry","initialProofState":"e : LinearIsometryEquiv (RingHom.id Real) Complex Complex\n⊢ Eq (↑(rotationOf e)) (HDiv.hDiv (e 1) ↑(Complex.abs (e 1)))","decl":"/-- Takes an element of `ℂ ≃ₗᵢ[ℝ] ℂ` and checks if it is a rotation, returns an element of the\nunit circle. -/\n@[simps]\ndef rotationOf (e : ℂ ≃ₗᵢ[ℝ] ℂ) : Circle :=\n  ⟨e 1 / Complex.abs (e 1), by simp [Submonoid.unitSphere, ← Complex.norm_eq_abs]⟩\n\n"}
{"name":"rotationOf_rotation","module":"Mathlib.Analysis.Complex.Isometry","initialProofState":"a : Circle\n⊢ Eq (rotationOf (rotation a)) a","decl":"@[simp]\ntheorem rotationOf_rotation (a : Circle) : rotationOf (rotation a) = a :=\n  Subtype.ext <| by simp\n\n"}
{"name":"rotation_injective","module":"Mathlib.Analysis.Complex.Isometry","initialProofState":"⊢ Function.Injective ⇑rotation","decl":"theorem rotation_injective : Function.Injective rotation :=\n  Function.LeftInverse.injective rotationOf_rotation\n\n"}
{"name":"LinearIsometry.re_apply_eq_re_of_add_conj_eq","module":"Mathlib.Analysis.Complex.Isometry","initialProofState":"f : LinearIsometry (RingHom.id Real) Complex Complex\nh₃ : ∀ (z : Complex), Eq (HAdd.hAdd z ((starRingEnd Complex) z)) (HAdd.hAdd (f z) ((starRingEnd Complex) (f z)))\nz : Complex\n⊢ Eq (f z).re z.re","decl":"theorem LinearIsometry.re_apply_eq_re_of_add_conj_eq (f : ℂ →ₗᵢ[ℝ] ℂ)\n    (h₃ : ∀ z, z + conj z = f z + conj (f z)) (z : ℂ) : (f z).re = z.re := by\n  simpa [Complex.ext_iff, add_re, add_im, conj_re, conj_im, ← two_mul,\n    show (2 : ℝ) ≠ 0 by simp [two_ne_zero]] using (h₃ z).symm\n\n"}
{"name":"LinearIsometry.im_apply_eq_im_or_neg_of_re_apply_eq_re","module":"Mathlib.Analysis.Complex.Isometry","initialProofState":"f : LinearIsometry (RingHom.id Real) Complex Complex\nh₂ : ∀ (z : Complex), Eq (f z).re z.re\nz : Complex\n⊢ Or (Eq (f z).im z.im) (Eq (f z).im (Neg.neg z.im))","decl":"theorem LinearIsometry.im_apply_eq_im_or_neg_of_re_apply_eq_re {f : ℂ →ₗᵢ[ℝ] ℂ}\n    (h₂ : ∀ z, (f z).re = z.re) (z : ℂ) : (f z).im = z.im ∨ (f z).im = -z.im := by\n  have h₁ := f.norm_map z\n  simp only [Complex.abs_def, norm_eq_abs] at h₁\n  rwa [Real.sqrt_inj (normSq_nonneg _) (normSq_nonneg _), normSq_apply (f z), normSq_apply z,\n    h₂, add_left_cancel_iff, mul_self_eq_mul_self_iff] at h₁\n\n"}
{"name":"LinearIsometry.im_apply_eq_im","module":"Mathlib.Analysis.Complex.Isometry","initialProofState":"f : LinearIsometry (RingHom.id Real) Complex Complex\nh : Eq (f 1) 1\nz : Complex\n⊢ Eq (HAdd.hAdd z ((starRingEnd Complex) z)) (HAdd.hAdd (f z) ((starRingEnd Complex) (f z)))","decl":"theorem LinearIsometry.im_apply_eq_im {f : ℂ →ₗᵢ[ℝ] ℂ} (h : f 1 = 1) (z : ℂ) :\n    z + conj z = f z + conj (f z) := by\n  have : ‖f z - 1‖ = ‖z - 1‖ := by rw [← f.norm_map (z - 1), f.map_sub, h]\n  apply_fun fun x => x ^ 2 at this\n  simp only [norm_eq_abs, ← normSq_eq_abs] at this\n  rw [← ofReal_inj, ← mul_conj, ← mul_conj] at this\n  rw [RingHom.map_sub, RingHom.map_sub] at this\n  simp only [sub_mul, mul_sub, one_mul, mul_one] at this\n  rw [mul_conj, normSq_eq_abs, ← norm_eq_abs, LinearIsometry.norm_map] at this\n  rw [mul_conj, normSq_eq_abs, ← norm_eq_abs] at this\n  simp only [sub_sub, sub_right_inj, mul_one, ofReal_pow, RingHom.map_one, norm_eq_abs] at this\n  simp only [add_sub, sub_left_inj] at this\n  rw [add_comm, ← this, add_comm]\n\n"}
{"name":"LinearIsometry.re_apply_eq_re","module":"Mathlib.Analysis.Complex.Isometry","initialProofState":"f : LinearIsometry (RingHom.id Real) Complex Complex\nh : Eq (f 1) 1\nz : Complex\n⊢ Eq (f z).re z.re","decl":"theorem LinearIsometry.re_apply_eq_re {f : ℂ →ₗᵢ[ℝ] ℂ} (h : f 1 = 1) (z : ℂ) : (f z).re = z.re := by\n  apply LinearIsometry.re_apply_eq_re_of_add_conj_eq\n  intro z\n  apply LinearIsometry.im_apply_eq_im h\n\n"}
{"name":"linear_isometry_complex_aux","module":"Mathlib.Analysis.Complex.Isometry","initialProofState":"f : LinearIsometryEquiv (RingHom.id Real) Complex Complex\nh : Eq (f 1) 1\n⊢ Or (Eq f (LinearIsometryEquiv.refl Real Complex)) (Eq f Complex.conjLIE)","decl":"theorem linear_isometry_complex_aux {f : ℂ ≃ₗᵢ[ℝ] ℂ} (h : f 1 = 1) :\n    f = LinearIsometryEquiv.refl ℝ ℂ ∨ f = conjLIE := by\n  have h0 : f I = I ∨ f I = -I := by\n    simp only [Complex.ext_iff, ← and_or_left, neg_re, I_re, neg_im, neg_zero]\n    constructor\n    · rw [← I_re]\n      exact @LinearIsometry.re_apply_eq_re f.toLinearIsometry h I\n    · apply @LinearIsometry.im_apply_eq_im_or_neg_of_re_apply_eq_re f.toLinearIsometry\n      intro z\n      rw [@LinearIsometry.re_apply_eq_re f.toLinearIsometry h]\n  refine h0.imp (fun h' : f I = I => ?_) fun h' : f I = -I => ?_ <;>\n    · apply LinearIsometryEquiv.toLinearEquiv_injective\n      apply Complex.basisOneI.ext'\n      intro i\n      fin_cases i <;> simp [h, h']\n\n"}
{"name":"linear_isometry_complex","module":"Mathlib.Analysis.Complex.Isometry","initialProofState":"f : LinearIsometryEquiv (RingHom.id Real) Complex Complex\n⊢ Exists fun a => Or (Eq f (rotation a)) (Eq f (Complex.conjLIE.trans (rotation a)))","decl":"theorem linear_isometry_complex (f : ℂ ≃ₗᵢ[ℝ] ℂ) :\n    ∃ a : Circle, f = rotation a ∨ f = conjLIE.trans (rotation a) := by\n  let a : Circle := ⟨f 1, by simp [Submonoid.unitSphere, ← Complex.norm_eq_abs, f.norm_map]⟩\n  use a\n  have : (f.trans (rotation a).symm) 1 = 1 := by simpa [a] using rotation_apply a⁻¹ (f 1)\n  refine (linear_isometry_complex_aux this).imp (fun h₁ => ?_) fun h₂ => ?_\n  · simpa using eq_mul_of_inv_mul_eq h₁\n  · exact eq_mul_of_inv_mul_eq h₂\n\n"}
{"name":"toMatrix_rotation","module":"Mathlib.Analysis.Complex.Isometry","initialProofState":"a : Circle\n⊢ Eq ((LinearMap.toMatrix Complex.basisOneI Complex.basisOneI) ↑(rotation a).toLinearEquiv) ↑(Matrix.planeConformalMatrix (↑a).re (↑a).im ⋯)","decl":"/-- The matrix representation of `rotation a` is equal to the conformal matrix\n`!![re a, -im a; im a, re a]`. -/\ntheorem toMatrix_rotation (a : Circle) :\n    LinearMap.toMatrix basisOneI basisOneI (rotation a).toLinearEquiv =\n      Matrix.planeConformalMatrix (re a) (im a) (by simp [pow_two, ← normSq_apply]) := by\n  ext i j\n  simp only [LinearMap.toMatrix_apply, coe_basisOneI, LinearEquiv.coe_coe,\n    LinearIsometryEquiv.coe_toLinearEquiv, rotation_apply, coe_basisOneI_repr, mul_re, mul_im,\n    Matrix.val_planeConformalMatrix, Matrix.of_apply, Matrix.cons_val', Matrix.empty_val',\n    Matrix.cons_val_fin_one]\n  fin_cases i <;> fin_cases j <;> simp\n\n"}
{"name":"det_rotation","module":"Mathlib.Analysis.Complex.Isometry","initialProofState":"a : Circle\n⊢ Eq (LinearMap.det ↑(rotation a).toLinearEquiv) 1","decl":"/-- The determinant of `rotation` (as a linear map) is equal to `1`. -/\n@[simp]\ntheorem det_rotation (a : Circle) : LinearMap.det ((rotation a).toLinearEquiv : ℂ →ₗ[ℝ] ℂ) = 1 := by\n  rw [← LinearMap.det_toMatrix basisOneI, toMatrix_rotation, Matrix.det_fin_two]\n  simp [← normSq_apply]\n\n"}
{"name":"linearEquiv_det_rotation","module":"Mathlib.Analysis.Complex.Isometry","initialProofState":"a : Circle\n⊢ Eq (LinearEquiv.det (rotation a).toLinearEquiv) 1","decl":"/-- The determinant of `rotation` (as a linear equiv) is equal to `1`. -/\n@[simp]\ntheorem linearEquiv_det_rotation (a : Circle) : LinearEquiv.det (rotation a).toLinearEquiv = 1 := by\n  rw [← Units.eq_iff, LinearEquiv.coe_det, det_rotation, Units.val_one]\n"}
