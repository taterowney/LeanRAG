{"name":"IsPrimitiveRoot.isIntegral","module":"Mathlib.RingTheory.RootsOfUnity.Minpoly","initialProofState":"n : Nat\nK : Type u_1\ninst✝ : CommRing K\nμ : K\nh : IsPrimitiveRoot μ n\nhpos : LT.lt 0 n\n⊢ IsIntegral Int μ","decl":"/-- `μ` is integral over `ℤ`. -/\n-- Porting note: `hpos` was in the `variable` line, with an `omit` in mathlib3 just after this\n-- declaration. For some reason, in Lean4, `hpos` gets included also in the declarations below,\n-- even if it is not used in the proof.\ntheorem isIntegral (hpos : 0 < n) : IsIntegral ℤ μ := by\n  use X ^ n - 1\n  constructor\n  · exact monic_X_pow_sub_C 1 (ne_of_lt hpos).symm\n  · simp only [((IsPrimitiveRoot.iff_def μ n).mp h).left, eval₂_one, eval₂_X_pow, eval₂_sub,\n      sub_self]\n\n"}
{"name":"IsPrimitiveRoot.minpoly_dvd_x_pow_sub_one","module":"Mathlib.RingTheory.RootsOfUnity.Minpoly","initialProofState":"n : Nat\nK : Type u_1\ninst✝² : CommRing K\nμ : K\nh : IsPrimitiveRoot μ n\ninst✝¹ : IsDomain K\ninst✝ : CharZero K\n⊢ Dvd.dvd (minpoly Int μ) (HSub.hSub (HPow.hPow Polynomial.X n) 1)","decl":"/-- The minimal polynomial of a root of unity `μ` divides `X ^ n - 1`. -/\ntheorem minpoly_dvd_x_pow_sub_one : minpoly ℤ μ ∣ X ^ n - 1 := by\n  rcases n.eq_zero_or_pos with (rfl | h0)\n  · simp\n  apply minpoly.isIntegrallyClosed_dvd (isIntegral h h0)\n  simp only [((IsPrimitiveRoot.iff_def μ n).mp h).left, aeval_X_pow, eq_intCast, Int.cast_one,\n    aeval_one, map_sub, sub_self]\n\n"}
{"name":"IsPrimitiveRoot.separable_minpoly_mod","module":"Mathlib.RingTheory.RootsOfUnity.Minpoly","initialProofState":"n : Nat\nK : Type u_1\ninst✝³ : CommRing K\nμ : K\nh : IsPrimitiveRoot μ n\ninst✝² : IsDomain K\ninst✝¹ : CharZero K\np : Nat\ninst✝ : Fact (Nat.Prime p)\nhdiv : Not (Dvd.dvd p n)\n⊢ (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly Int μ)).Separable","decl":"/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is separable. -/\ntheorem separable_minpoly_mod {p : ℕ} [Fact p.Prime] (hdiv : ¬p ∣ n) :\n    Separable (map (Int.castRingHom (ZMod p)) (minpoly ℤ μ)) := by\n  have hdvd : map (Int.castRingHom (ZMod p)) (minpoly ℤ μ) ∣ X ^ n - 1 := by\n    convert RingHom.map_dvd (mapRingHom (Int.castRingHom (ZMod p)))\n        (minpoly_dvd_x_pow_sub_one h)\n    simp only [map_sub, map_pow, coe_mapRingHom, map_X, map_one]\n  refine Separable.of_dvd (separable_X_pow_sub_C 1 ?_ one_ne_zero) hdvd\n  by_contra hzero\n  exact hdiv ((ZMod.natCast_zmod_eq_zero_iff_dvd n p).1 hzero)\n\n"}
{"name":"IsPrimitiveRoot.squarefree_minpoly_mod","module":"Mathlib.RingTheory.RootsOfUnity.Minpoly","initialProofState":"n : Nat\nK : Type u_1\ninst✝³ : CommRing K\nμ : K\nh : IsPrimitiveRoot μ n\ninst✝² : IsDomain K\ninst✝¹ : CharZero K\np : Nat\ninst✝ : Fact (Nat.Prime p)\nhdiv : Not (Dvd.dvd p n)\n⊢ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly Int μ))","decl":"/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. -/\ntheorem squarefree_minpoly_mod {p : ℕ} [Fact p.Prime] (hdiv : ¬p ∣ n) :\n    Squarefree (map (Int.castRingHom (ZMod p)) (minpoly ℤ μ)) :=\n  (separable_minpoly_mod h hdiv).squarefree\n\n"}
{"name":"IsPrimitiveRoot.minpoly_dvd_expand","module":"Mathlib.RingTheory.RootsOfUnity.Minpoly","initialProofState":"n : Nat\nK : Type u_1\ninst✝² : CommRing K\nμ : K\nh : IsPrimitiveRoot μ n\ninst✝¹ : IsDomain K\ninst✝ : CharZero K\np : Nat\nhdiv : Not (Dvd.dvd p n)\n⊢ Dvd.dvd (minpoly Int μ) ((Polynomial.expand Int p) (minpoly Int (HPow.hPow μ p)))","decl":"/-- Let `P` be the minimal polynomial of a root of unity `μ` and `Q` be the minimal polynomial of\n`μ ^ p`, where `p` is a natural number that does not divide `n`. Then `P` divides `expand ℤ p Q`. -/\ntheorem minpoly_dvd_expand {p : ℕ} (hdiv : ¬p ∣ n) :\n    minpoly ℤ μ ∣ expand ℤ p (minpoly ℤ (μ ^ p)) := by\n  rcases n.eq_zero_or_pos with (rfl | hpos)\n  · simp_all\n  letI : IsIntegrallyClosed ℤ := GCDMonoid.toIsIntegrallyClosed\n  refine minpoly.isIntegrallyClosed_dvd (h.isIntegral hpos) ?_\n  rw [aeval_def, coe_expand, ← comp, eval₂_eq_eval_map, map_comp, Polynomial.map_pow, map_X,\n    eval_comp, eval_pow, eval_X, ← eval₂_eq_eval_map, ← aeval_def]\n  exact minpoly.aeval _ _\n\n"}
{"name":"IsPrimitiveRoot.minpoly_dvd_pow_mod","module":"Mathlib.RingTheory.RootsOfUnity.Minpoly","initialProofState":"n : Nat\nK : Type u_1\ninst✝² : CommRing K\nμ : K\nh : IsPrimitiveRoot μ n\ninst✝¹ : IsDomain K\ninst✝ : CharZero K\np : Nat\nhprime : Fact (Nat.Prime p)\nhdiv : Not (Dvd.dvd p n)\n⊢ Dvd.dvd (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly Int μ)) (HPow.hPow (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly Int (HPow.hPow μ p))) p)","decl":"/-- Let `P` be the minimal polynomial of a root of unity `μ` and `Q` be the minimal polynomial of\n`μ ^ p`, where `p` is a prime that does not divide `n`. Then `P` divides `Q ^ p` modulo `p`. -/\ntheorem minpoly_dvd_pow_mod {p : ℕ} [hprime : Fact p.Prime] (hdiv : ¬p ∣ n) :\n    map (Int.castRingHom (ZMod p)) (minpoly ℤ μ) ∣\n      map (Int.castRingHom (ZMod p)) (minpoly ℤ (μ ^ p)) ^ p := by\n  set Q := minpoly ℤ (μ ^ p)\n  have hfrob :\n    map (Int.castRingHom (ZMod p)) Q ^ p = map (Int.castRingHom (ZMod p)) (expand ℤ p Q) := by\n    rw [← ZMod.expand_card, map_expand]\n  rw [hfrob]\n  apply RingHom.map_dvd (mapRingHom (Int.castRingHom (ZMod p)))\n  exact minpoly_dvd_expand h hdiv\n\n"}
{"name":"IsPrimitiveRoot.minpoly_dvd_mod_p","module":"Mathlib.RingTheory.RootsOfUnity.Minpoly","initialProofState":"n : Nat\nK : Type u_1\ninst✝³ : CommRing K\nμ : K\nh : IsPrimitiveRoot μ n\ninst✝² : IsDomain K\ninst✝¹ : CharZero K\np : Nat\ninst✝ : Fact (Nat.Prime p)\nhdiv : Not (Dvd.dvd p n)\n⊢ Dvd.dvd (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly Int μ)) (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly Int (HPow.hPow μ p)))","decl":"/-- Let `P` be the minimal polynomial of a root of unity `μ` and `Q` be the minimal polynomial of\n`μ ^ p`, where `p` is a prime that does not divide `n`. Then `P` divides `Q` modulo `p`. -/\ntheorem minpoly_dvd_mod_p {p : ℕ} [Fact p.Prime] (hdiv : ¬p ∣ n) :\n    map (Int.castRingHom (ZMod p)) (minpoly ℤ μ) ∣\n      map (Int.castRingHom (ZMod p)) (minpoly ℤ (μ ^ p)) :=\n  (squarefree_minpoly_mod h hdiv).isRadical _ _ (minpoly_dvd_pow_mod h hdiv)\n\n"}
{"name":"IsPrimitiveRoot.minpoly_eq_pow","module":"Mathlib.RingTheory.RootsOfUnity.Minpoly","initialProofState":"n : Nat\nK : Type u_1\ninst✝² : CommRing K\nμ : K\nh : IsPrimitiveRoot μ n\ninst✝¹ : IsDomain K\ninst✝ : CharZero K\np : Nat\nhprime : Fact (Nat.Prime p)\nhdiv : Not (Dvd.dvd p n)\n⊢ Eq (minpoly Int μ) (minpoly Int (HPow.hPow μ p))","decl":"/-- If `p` is a prime that does not divide `n`,\nthen the minimal polynomials of a primitive `n`-th root of unity `μ`\nand of `μ ^ p` are the same. -/\ntheorem minpoly_eq_pow {p : ℕ} [hprime : Fact p.Prime] (hdiv : ¬p ∣ n) :\n    minpoly ℤ μ = minpoly ℤ (μ ^ p) := by\n  classical\n  by_cases hn : n = 0\n  · simp_all\n  have hpos := Nat.pos_of_ne_zero hn\n  by_contra hdiff\n  set P := minpoly ℤ μ\n  set Q := minpoly ℤ (μ ^ p)\n  have Pmonic : P.Monic := minpoly.monic (h.isIntegral hpos)\n  have Qmonic : Q.Monic := minpoly.monic ((h.pow_of_prime hprime.1 hdiv).isIntegral hpos)\n  have Pirr : Irreducible P := minpoly.irreducible (h.isIntegral hpos)\n  have Qirr : Irreducible Q := minpoly.irreducible ((h.pow_of_prime hprime.1 hdiv).isIntegral hpos)\n  have PQprim : IsPrimitive (P * Q) := Pmonic.isPrimitive.mul Qmonic.isPrimitive\n  have prod : P * Q ∣ X ^ n - 1 := by\n    rw [IsPrimitive.Int.dvd_iff_map_cast_dvd_map_cast (P * Q) (X ^ n - 1) PQprim\n        (monic_X_pow_sub_C (1 : ℤ) (ne_of_gt hpos)).isPrimitive,\n      Polynomial.map_mul]\n    refine IsCoprime.mul_dvd ?_ ?_ ?_\n    · have aux := IsPrimitive.Int.irreducible_iff_irreducible_map_cast Pmonic.isPrimitive\n      refine (dvd_or_isCoprime _ _ (aux.1 Pirr)).resolve_left ?_\n      rw [map_dvd_map (Int.castRingHom ℚ) Int.cast_injective Pmonic]\n      intro hdiv\n      refine hdiff (eq_of_monic_of_associated Pmonic Qmonic ?_)\n      exact associated_of_dvd_dvd hdiv (Pirr.dvd_symm Qirr hdiv)\n    · apply (map_dvd_map (Int.castRingHom ℚ) Int.cast_injective Pmonic).2\n      exact minpoly_dvd_x_pow_sub_one h\n    · apply (map_dvd_map (Int.castRingHom ℚ) Int.cast_injective Qmonic).2\n      exact minpoly_dvd_x_pow_sub_one (pow_of_prime h hprime.1 hdiv)\n  replace prod := RingHom.map_dvd (mapRingHom (Int.castRingHom (ZMod p))) prod\n  rw [coe_mapRingHom, Polynomial.map_mul, Polynomial.map_sub, Polynomial.map_one,\n    Polynomial.map_pow, map_X] at prod\n  obtain ⟨R, hR⟩ := minpoly_dvd_mod_p h hdiv\n  rw [hR, ← mul_assoc, ← Polynomial.map_mul, ← sq, Polynomial.map_pow] at prod\n  have habs : map (Int.castRingHom (ZMod p)) P ^ 2 ∣ map (Int.castRingHom (ZMod p)) P ^ 2 * R := by\n    use R\n  replace habs :=\n    lt_of_lt_of_le (Nat.cast_lt.2 one_lt_two)\n      (le_emultiplicity_of_pow_dvd (dvd_trans habs prod))\n  have hfree : Squarefree (X ^ n - 1 : (ZMod p)[X]) :=\n    (separable_X_pow_sub_C 1 (fun h => hdiv <| (ZMod.natCast_zmod_eq_zero_iff_dvd n p).1 h)\n        one_ne_zero).squarefree\n  cases'\n    (squarefree_iff_emultiplicity_le_one (X ^ n - 1)).1 hfree\n      (map (Int.castRingHom (ZMod p)) P) with\n    hle hunit\n  · rw [Nat.cast_one] at habs; exact hle.not_lt habs\n  · replace hunit := degree_eq_zero_of_isUnit hunit\n    rw [degree_map_eq_of_leadingCoeff_ne_zero (Int.castRingHom (ZMod p)) _] at hunit\n    · exact (minpoly.degree_pos (isIntegral h hpos)).ne' hunit\n    simp only [Pmonic, eq_intCast, Monic.leadingCoeff, Int.cast_one, Ne, not_false_iff,\n      one_ne_zero]\n\n"}
{"name":"IsPrimitiveRoot.minpoly_eq_pow_coprime","module":"Mathlib.RingTheory.RootsOfUnity.Minpoly","initialProofState":"n : Nat\nK : Type u_1\ninst✝² : CommRing K\nμ : K\nh : IsPrimitiveRoot μ n\ninst✝¹ : IsDomain K\ninst✝ : CharZero K\nm : Nat\nhcop : m.Coprime n\n⊢ Eq (minpoly Int μ) (minpoly Int (HPow.hPow μ m))","decl":"/-- If `m : ℕ` is coprime with `n`,\nthen the minimal polynomials of a primitive `n`-th root of unity `μ`\nand of `μ ^ m` are the same. -/\ntheorem minpoly_eq_pow_coprime {m : ℕ} (hcop : Nat.Coprime m n) :\n    minpoly ℤ μ = minpoly ℤ (μ ^ m) := by\n  revert n hcop\n  refine UniqueFactorizationMonoid.induction_on_prime m ?_ ?_ ?_\n  · intro h hn\n    congr\n    simpa [(Nat.coprime_zero_left _).mp hn] using h\n  · intro u hunit _ _\n    congr\n    simp [Nat.isUnit_iff.mp hunit]\n  · intro a p _ hprime\n    intro hind h hcop\n    rw [hind h (Nat.Coprime.coprime_mul_left hcop)]; clear hind\n    replace hprime := hprime.nat_prime\n    have hdiv := (Nat.Prime.coprime_iff_not_dvd hprime).1 (Nat.Coprime.coprime_mul_right hcop)\n    haveI := Fact.mk hprime\n    rw [minpoly_eq_pow (h.pow_of_coprime a (Nat.Coprime.coprime_mul_left hcop)) hdiv]\n    congr 1\n    ring\n\n"}
{"name":"IsPrimitiveRoot.pow_isRoot_minpoly","module":"Mathlib.RingTheory.RootsOfUnity.Minpoly","initialProofState":"n : Nat\nK : Type u_1\ninst✝² : CommRing K\nμ : K\nh : IsPrimitiveRoot μ n\ninst✝¹ : IsDomain K\ninst✝ : CharZero K\nm : Nat\nhcop : m.Coprime n\n⊢ (Polynomial.map (Int.castRingHom K) (minpoly Int μ)).IsRoot (HPow.hPow μ m)","decl":"/-- If `m : ℕ` is coprime with `n`,\nthen the minimal polynomial of a primitive `n`-th root of unity `μ`\nhas `μ ^ m` as root. -/\ntheorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :\n    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by\n  simp only [minpoly_eq_pow_coprime h hcop, IsRoot.def, eval_map]\n  exact minpoly.aeval ℤ (μ ^ m)\n\n"}
{"name":"IsPrimitiveRoot.is_roots_of_minpoly","module":"Mathlib.RingTheory.RootsOfUnity.Minpoly","initialProofState":"n : Nat\nK : Type u_1\ninst✝³ : CommRing K\nμ : K\nh : IsPrimitiveRoot μ n\ninst✝² : IsDomain K\ninst✝¹ : CharZero K\ninst✝ : DecidableEq K\n⊢ HasSubset.Subset (primitiveRoots n K) (Polynomial.map (Int.castRingHom K) (minpoly Int μ)).roots.toFinset","decl":"/-- `primitiveRoots n K` is a subset of the roots of the minimal polynomial of a primitive\n`n`-th root of unity `μ`. -/\ntheorem is_roots_of_minpoly [DecidableEq K] :\n    primitiveRoots n K ⊆ (map (Int.castRingHom K) (minpoly ℤ μ)).roots.toFinset := by\n  by_cases hn : n = 0; · simp_all\n  have : NeZero n := ⟨hn⟩\n  have hpos := Nat.pos_of_ne_zero hn\n  intro x hx\n  obtain ⟨m, _, hcop, rfl⟩ := (isPrimitiveRoot_iff h).1 ((mem_primitiveRoots hpos).1 hx)\n  simp only [Multiset.mem_toFinset, mem_roots]\n  convert pow_isRoot_minpoly h hcop using 0\n  rw [← mem_roots]\n  exact map_monic_ne_zero <| minpoly.monic <| isIntegral h hpos\n\n"}
{"name":"IsPrimitiveRoot.totient_le_degree_minpoly","module":"Mathlib.RingTheory.RootsOfUnity.Minpoly","initialProofState":"n : Nat\nK : Type u_1\ninst✝² : CommRing K\nμ : K\nh : IsPrimitiveRoot μ n\ninst✝¹ : IsDomain K\ninst✝ : CharZero K\n⊢ LE.le n.totient (minpoly Int μ).natDegree","decl":"/-- The degree of the minimal polynomial of `μ` is at least `totient n`. -/\ntheorem totient_le_degree_minpoly : Nat.totient n ≤ (minpoly ℤ μ).natDegree := by\n  classical\n  let P : ℤ[X] := minpoly ℤ μ\n  -- minimal polynomial of `μ`\n  let P_K : K[X] := map (Int.castRingHom K) P\n  -- minimal polynomial of `μ` sent to `K[X]`\n  calc\n    n.totient = (primitiveRoots n K).card := h.card_primitiveRoots.symm\n    _ ≤ P_K.roots.toFinset.card := Finset.card_le_card (is_roots_of_minpoly h)\n    _ ≤ Multiset.card P_K.roots := Multiset.toFinset_card_le _\n    _ ≤ P_K.natDegree := card_roots' _\n    _ ≤ P.natDegree := natDegree_map_le\n\n"}
