{"name":"MulChar.eq_iff","module":"Mathlib.NumberTheory.MulChar.Lemmas","initialProofState":"R : Type u_1\nR' : Type u_2\ninst✝¹ : CommMonoid R\ninst✝ : CommMonoidWithZero R'\ng : Units R\nhg : ∀ (x : Units R), Membership.mem (Subgroup.zpowers g) x\nχ₁ χ₂ : MulChar R R'\n⊢ Iff (Eq χ₁ χ₂) (Eq (χ₁ ↑g) (χ₂ ↑g))","decl":"/-- Two multiplicative characters on a monoid whose unit group is generated by `g`\nare equal if and only if they agree on `g`. -/\nlemma eq_iff {R R' : Type*} [CommMonoid R] [CommMonoidWithZero R'] {g : Rˣ}\n    (hg : ∀ x, x ∈ Subgroup.zpowers g) (χ₁ χ₂ : MulChar R R') :\n    χ₁ = χ₂ ↔ χ₁ g.val = χ₂ g.val := by\n  rw [← Equiv.apply_eq_iff_eq equivToUnitHom, MonoidHom.eq_iff_eq_on_generator hg,\n    ← coe_equivToUnitHom, ← coe_equivToUnitHom, Units.ext_iff]\n\n\n"}
{"name":"MulChar.starComp_apply","module":"Mathlib.NumberTheory.MulChar.Lemmas","initialProofState":"R : Type u_1\nR' : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing R'\ninst✝ : StarRing R'\nχ : MulChar R R'\na : R\n⊢ Eq (χ.starComp a) ((starRingEnd R') (χ a))","decl":"/-- Define the conjugation (`star`) of a multiplicative character by conjugating pointwise. -/\n@[simps!]\ndef starComp [StarRing R'] (χ : MulChar R R') : MulChar R R' :=\n  χ.ringHomComp (starRingEnd R')\n\n"}
{"name":"MulChar.star_apply","module":"Mathlib.NumberTheory.MulChar.Lemmas","initialProofState":"R : Type u_1\nR' : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing R'\ninst✝ : StarRing R'\nχ : MulChar R R'\na : R\n⊢ Eq ((Star.star χ) a) (Star.star (χ a))","decl":"@[simp]\nlemma star_apply [StarRing R'] (χ : MulChar R R') (a : R) : (star χ) a = star (χ a) :=\n  rfl\n\n"}
{"name":"MulChar.apply_mem_rootsOfUnity","module":"Mathlib.NumberTheory.MulChar.Lemmas","initialProofState":"R : Type u_1\nR' : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing R'\ninst✝ : Fintype (Units R)\na : Units R\nχ : MulChar R R'\n⊢ Membership.mem (rootsOfUnity (Fintype.card (Units R)) R') ((MulChar.equivToUnitHom χ) a)","decl":"/-- The values of a multiplicative character on `R` are `n`th roots of unity, where `n = #Rˣ`. -/\nlemma apply_mem_rootsOfUnity [Fintype Rˣ] (a : Rˣ) {χ : MulChar R R'} :\n    equivToUnitHom χ a ∈ rootsOfUnity (Fintype.card Rˣ) R' := by\n  rw [mem_rootsOfUnity, ← map_pow, ← (equivToUnitHom χ).map_one, pow_card_eq_one]\n\n"}
{"name":"MulChar.star_eq_inv","module":"Mathlib.NumberTheory.MulChar.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Finite (Units R)\nχ : MulChar R Complex\n⊢ Eq (Star.star χ) (Inv.inv χ)","decl":"open Complex in\n/-- The conjugate of a multiplicative character with values in `ℂ` is its inverse. -/\nlemma star_eq_inv (χ : MulChar R ℂ) : star χ = χ⁻¹ := by\n  cases nonempty_fintype Rˣ\n  ext1 a\n  simp only [inv_apply_eq_inv']\n  exact (inv_eq_conj <| norm_eq_one_of_mem_rootsOfUnity <| χ.apply_mem_rootsOfUnity a).symm\n\n"}
{"name":"MulChar.star_apply'","module":"Mathlib.NumberTheory.MulChar.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Finite (Units R)\nχ : MulChar R Complex\na : R\n⊢ Eq (Star.star (χ a)) ((Inv.inv χ) a)","decl":"lemma star_apply' (χ : MulChar R ℂ) (a : R) : star (χ a) = χ⁻¹ a := by\n  simp only [RCLike.star_def, ← star_eq_inv, star_apply]\n\n"}
{"name":"MulChar.ofRootOfUnity_spec","module":"Mathlib.NumberTheory.MulChar.Lemmas","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\ninst✝² : Fintype M\ninst✝¹ : DecidableEq M\nR : Type u_2\ninst✝ : CommMonoidWithZero R\nζ : Units R\nhζ : Membership.mem (rootsOfUnity (Fintype.card (Units M)) R) ζ\ng : Units M\nhg : ∀ (x : Units M), Membership.mem (Subgroup.zpowers g) x\n⊢ Eq ((MulChar.ofRootOfUnity hζ hg) ↑g) ↑ζ","decl":"lemma ofRootOfUnity_spec {ζ : Rˣ} (hζ : ζ ∈ rootsOfUnity (Fintype.card Mˣ) R)\n    {g : Mˣ} (hg : ∀ x, x ∈ Subgroup.zpowers g) :\n    ofRootOfUnity hζ hg g = ζ := by\n  simp only [ofRootOfUnity, ofUnitHom_eq, equivToUnitHom_symm_coe,\n    monoidHomOfForallMemZpowers_apply_gen]\n\n"}
{"name":"MulChar.exists_mulChar_orderOf","module":"Mathlib.NumberTheory.MulChar.Lemmas","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\nR : Type u_2\ninst✝ : CommRing R\nn : Nat\nh : Dvd.dvd n (HSub.hSub (Fintype.card F) 1)\nζ : R\nhζ : IsPrimitiveRoot ζ n\n⊢ Exists fun χ => Eq (orderOf χ) n","decl":"/-- There is a character of order `n` on `F` if `#F ≡ 1 mod n` and the target contains\na primitive `n`th root of unity. -/\nlemma exists_mulChar_orderOf {n : ℕ} (h : n ∣ Fintype.card F - 1) {ζ : R}\n    (hζ : IsPrimitiveRoot ζ n) :\n    ∃ χ : MulChar F R, orderOf χ = n := by\n  classical\n  have hn₀ : 0 < n := by\n    refine Nat.pos_of_ne_zero fun hn ↦ ?_\n    simp only [hn, zero_dvd_iff, Nat.sub_eq_zero_iff_le] at h\n    exact (Fintype.one_lt_card.trans_le h).false\n  let e := MulChar.equiv_rootsOfUnity F R\n  let ζ' : Rˣ := (hζ.isUnit hn₀).unit\n  have h' : ζ' ^ (Fintype.card Fˣ : ℕ) = 1 :=\n    Units.ext_iff.mpr <| (hζ.pow_eq_one_iff_dvd _).mpr <| Fintype.card_units (α := F) ▸ h\n  use e.symm ⟨ζ', (mem_rootsOfUnity (Fintype.card Fˣ) ζ').mpr h'⟩\n  rw [e.symm.orderOf_eq, orderOf_eq_iff hn₀]\n  refine ⟨?_, fun m hm hm₀ h ↦ ?_⟩\n  · ext\n    push_cast\n    exact hζ.pow_eq_one\n  · rw [Subtype.ext_iff, Units.ext_iff] at h\n    push_cast at h\n    exact ((Nat.le_of_dvd hm₀ <| hζ.dvd_of_pow_eq_one _ h).trans_lt hm).false\n\n"}
{"name":"MulChar.orderOf_dvd_card_sub_one","module":"Mathlib.NumberTheory.MulChar.Lemmas","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\nR : Type u_2\ninst✝ : CommRing R\nχ : MulChar F R\n⊢ Dvd.dvd (orderOf χ) (HSub.hSub (Fintype.card F) 1)","decl":"/-- If there is a multiplicative character of order `n` on `F`, then `#F ≡ 1 mod n`. -/\nlemma orderOf_dvd_card_sub_one (χ : MulChar F R) : orderOf χ ∣ Fintype.card F - 1 := by\n  classical\n  rw [← Fintype.card_units]\n  exact orderOf_dvd_of_pow_eq_one χ.pow_card_eq_one\n\n"}
{"name":"MulChar.exists_mulChar_orderOf_eq_card_units","module":"Mathlib.NumberTheory.MulChar.Lemmas","initialProofState":"F : Type u_1\ninst✝³ : Field F\ninst✝² : Fintype F\nR : Type u_2\ninst✝¹ : CommRing R\ninst✝ : DecidableEq F\nζ : R\nhζ : IsPrimitiveRoot ζ (Fintype.card (Units F))\n⊢ Exists fun χ => Eq (orderOf χ) (Fintype.card (Units F))","decl":"/-- There is always a character on `F` of order `#F-1` with values in a ring that has\na primitive `(#F-1)`th root of unity. -/\nlemma exists_mulChar_orderOf_eq_card_units [DecidableEq F]\n    {ζ : R} (hζ : IsPrimitiveRoot ζ (Fintype.card Fˣ)) :\n    ∃ χ : MulChar F R, orderOf χ = Fintype.card Fˣ :=\n  exists_mulChar_orderOf F (by rw [Fintype.card_units]) hζ\n\n"}
{"name":"MulChar.apply_mem_rootsOfUnity_orderOf","module":"Mathlib.NumberTheory.MulChar.Lemmas","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Finite F\nR : Type u_2\ninst✝ : CommRing R\nχ : MulChar F R\na : F\nha : Ne a 0\n⊢ Exists fun ζ => And (Membership.mem (rootsOfUnity (orderOf χ) R) ζ) (Eq (↑ζ) (χ a))","decl":"lemma apply_mem_rootsOfUnity_orderOf (χ : MulChar F R) {a : F} (ha : a ≠ 0) :\n    ∃ ζ ∈ rootsOfUnity (orderOf χ) R, ζ = χ a := by\n  have hu : IsUnit (χ a) := ha.isUnit.map χ\n  refine ⟨hu.unit, ?_, hu.unit_spec⟩\n  rw [mem_rootsOfUnity, Units.ext_iff, Units.val_pow_eq_pow_val, Units.val_one,\n    IsUnit.unit_spec, ← χ.pow_apply' χ.orderOf_pos.ne', pow_orderOf_eq_one,\n    show a = (isUnit_iff_ne_zero.mpr ha).unit by simp only [IsUnit.unit_spec],\n    MulChar.one_apply_coe]\n\n"}
{"name":"MulChar.apply_mem_rootsOfUnity_of_pow_eq_one","module":"Mathlib.NumberTheory.MulChar.Lemmas","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Finite F\nR : Type u_2\ninst✝ : CommRing R\nχ : MulChar F R\nn : Nat\nhχ : Eq (HPow.hPow χ n) 1\na : F\nha : Ne a 0\n⊢ Exists fun ζ => And (Membership.mem (rootsOfUnity n R) ζ) (Eq (↑ζ) (χ a))","decl":"/-- The non-zero values of a multiplicative character `χ` such that `χ^n = 1`\nare `n`th roots of unity. -/\nlemma apply_mem_rootsOfUnity_of_pow_eq_one {χ : MulChar F R} {n : ℕ} (hχ : χ ^ n = 1)\n    {a : F} (ha : a ≠ 0) :\n    ∃ ζ ∈ rootsOfUnity n R, ζ = χ a := by\n  obtain ⟨μ, hμ₁, hμ₂⟩ := χ.apply_mem_rootsOfUnity_orderOf ha\n  exact ⟨μ, rootsOfUnity_le_of_dvd (orderOf_dvd_of_pow_eq_one hχ) hμ₁, hμ₂⟩\n\n-- Results involving primitive roots of unity require `R` to be an integral domain.\n"}
{"name":"MulChar.exists_apply_eq_pow","module":"Mathlib.NumberTheory.MulChar.Lemmas","initialProofState":"F : Type u_1\ninst✝⁴ : Field F\ninst✝³ : Finite F\nR : Type u_2\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\nχ : MulChar F R\nn : Nat\ninst✝ : NeZero n\nhχ : Eq (HPow.hPow χ n) 1\nμ : R\nhμ : IsPrimitiveRoot μ n\na : F\nha : Ne a 0\n⊢ Exists fun k => And (LT.lt k n) (Eq (χ a) (HPow.hPow μ k))","decl":"/-- If `χ` is a multiplicative character with `χ^n = 1` and `μ` is a primitive `n`th root\nof unity, then, for `a ≠ 0`, there is some `k` such that `χ a = μ^k`. -/\nlemma exists_apply_eq_pow {χ : MulChar F R} {n : ℕ} [NeZero n] (hχ : χ ^ n = 1) {μ : R}\n    (hμ : IsPrimitiveRoot μ n) {a : F} (ha : a ≠ 0) :\n    ∃ k < n, χ a = μ ^ k := by\n  obtain ⟨ζ, hζ₁, hζ₂⟩ := apply_mem_rootsOfUnity_of_pow_eq_one hχ ha\n  have hζ' : ζ.val ^ n = 1 := (mem_rootsOfUnity' n ↑ζ).mp hζ₁\n  obtain ⟨k, hk₁, hk₂⟩ := hμ.eq_pow_of_pow_eq_one hζ'\n  exact ⟨k, hk₁, (hζ₂ ▸ hk₂).symm⟩\n\n"}
{"name":"MulChar.apply_mem_algebraAdjoin_of_pow_eq_one","module":"Mathlib.NumberTheory.MulChar.Lemmas","initialProofState":"F : Type u_1\ninst✝⁴ : Field F\ninst✝³ : Finite F\nR : Type u_2\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\nχ : MulChar F R\nn : Nat\ninst✝ : NeZero n\nhχ : Eq (HPow.hPow χ n) 1\nμ : R\nhμ : IsPrimitiveRoot μ n\na : F\n⊢ Membership.mem (Algebra.adjoin Int (Singleton.singleton μ)) (χ a)","decl":"/-- The values of a multiplicative character `χ` such that `χ^n = 1` are contained in `ℤ[μ]` when\n`μ` is a primitive `n`th root of unity. -/\nlemma apply_mem_algebraAdjoin_of_pow_eq_one {χ : MulChar F R} {n : ℕ} [NeZero n] (hχ : χ ^ n = 1)\n    {μ : R} (hμ : IsPrimitiveRoot μ n) (a : F) :\n    χ a ∈ Algebra.adjoin ℤ {μ} := by\n  rcases eq_or_ne a 0 with rfl | h\n  · exact χ.map_zero ▸ Subalgebra.zero_mem _\n  · obtain ⟨ζ, hζ₁, hζ₂⟩ := apply_mem_rootsOfUnity_of_pow_eq_one hχ h\n    rw [mem_rootsOfUnity, Units.ext_iff, Units.val_pow_eq_pow_val] at hζ₁\n    obtain ⟨k, _, hk⟩ := IsPrimitiveRoot.eq_pow_of_pow_eq_one hμ hζ₁\n    exact hζ₂ ▸ hk ▸ Subalgebra.pow_mem _ (Algebra.self_mem_adjoin_singleton ℤ μ) k\n\n"}
{"name":"MulChar.apply_mem_algebraAdjoin","module":"Mathlib.NumberTheory.MulChar.Lemmas","initialProofState":"F : Type u_1\ninst✝³ : Field F\ninst✝² : Finite F\nR : Type u_2\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nχ : MulChar F R\nμ : R\nhμ : IsPrimitiveRoot μ (orderOf χ)\na : F\n⊢ Membership.mem (Algebra.adjoin Int (Singleton.singleton μ)) (χ a)","decl":"/-- The values of a multiplicative character of order `n` are contained in `ℤ[μ]` when\n`μ` is a primitive `n`th root of unity. -/\nlemma apply_mem_algebraAdjoin {χ : MulChar F R} {μ : R} (hμ : IsPrimitiveRoot μ (orderOf χ))\n    (a : F) :\n    χ a ∈ Algebra.adjoin ℤ {μ} :=\n  have : NeZero (orderOf χ) := ⟨χ.orderOf_pos.ne'⟩\n  apply_mem_algebraAdjoin_of_pow_eq_one (pow_orderOf_eq_one χ) hμ a\n\n"}
