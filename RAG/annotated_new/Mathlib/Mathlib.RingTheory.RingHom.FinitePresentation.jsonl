{"name":"RingHom.finitePresentation_localizationPreserves","module":"Mathlib.RingTheory.RingHom.FinitePresentation","initialProofState":"⊢ RingHom.LocalizationPreserves @RingHom.FinitePresentation","decl":"/-- Being finitely-presented is preserved by localizations. -/\ntheorem finitePresentation_localizationPreserves : LocalizationPreserves @FinitePresentation := by\n  introv R hf\n  letI := f.toAlgebra\n  letI := ((algebraMap S S').comp f).toAlgebra\n  let f' : R' →+* S' := IsLocalization.map S' f M.le_comap_map\n  letI := f'.toAlgebra\n  haveI : IsScalarTower R R' S' :=\n    IsScalarTower.of_algebraMap_eq' (IsLocalization.map_comp M.le_comap_map).symm\n  obtain ⟨n, g, hgsurj, hgker⟩ := hf\n  let MX : Submonoid (MvPolynomial (Fin n) R) :=\n    Algebra.algebraMapSubmonoid (MvPolynomial (Fin n) R) M\n  haveI : IsLocalization MX (MvPolynomial (Fin n) R') :=\n    inferInstanceAs <| IsLocalization (M.map MvPolynomial.C) (MvPolynomial (Fin n) R')\n  haveI : IsScalarTower R S S' := IsScalarTower.of_algebraMap_eq' rfl\n  haveI : IsLocalization (Algebra.algebraMapSubmonoid S M) S' :=\n    inferInstanceAs <| IsLocalization (M.map f) S'\n  let g' : MvPolynomial (Fin n) R' →ₐ[R'] S' := IsLocalization.mapₐ M R' _ S' g\n  let k : RingHom.ker g →ₗ[MvPolynomial (Fin n) R] RingHom.ker g' :=\n    AlgHom.toKerIsLocalization M R' _ S' g\n  have : IsLocalizedModule MX k := AlgHom.toKerIsLocalization_isLocalizedModule M _ _ _ g\n  have : Module.Finite (MvPolynomial (Fin n) R) (ker g) := Module.Finite.iff_fg.mpr hgker\n  exact ⟨n, g', IsLocalization.mapₐ_surjective_of_surjective M R' _ S' g hgsurj,\n    Module.Finite.iff_fg.mp (Module.Finite.of_isLocalizedModule MX k)⟩\n\n"}
{"name":"RingHom.finitePresentation_stableUnderComposition","module":"Mathlib.RingTheory.RingHom.FinitePresentation","initialProofState":"⊢ RingHom.StableUnderComposition @RingHom.FinitePresentation","decl":"/-- Being finitely-presented is stable under composition. -/\ntheorem finitePresentation_stableUnderComposition : StableUnderComposition @FinitePresentation := by\n  introv R hf hg\n  exact hg.comp hf\n\n"}
{"name":"RingHom.finitePresentation_holdsForLocalizationAway","module":"Mathlib.RingTheory.RingHom.FinitePresentation","initialProofState":"⊢ RingHom.HoldsForLocalizationAway @RingHom.FinitePresentation","decl":"/-- If `R` is a ring, then `Rᵣ` is `R`-finitely-presented for any `r : R`. -/\ntheorem finitePresentation_holdsForLocalizationAway :\n    HoldsForLocalizationAway @FinitePresentation := by\n  introv R _\n  suffices Algebra.FinitePresentation R S by\n    rw [RingHom.FinitePresentation]\n    convert this; ext\n    rw [Algebra.smul_def]; rfl\n  exact IsLocalization.Away.finitePresentation r\n\n"}
{"name":"RingHom.finitePresentation_ofLocalizationSpanTarget_aux","module":"Mathlib.RingTheory.RingHom.FinitePresentation","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : CommRing A\ninst✝² : Algebra R S\ninst✝¹ : Algebra R A\ninst✝ : Algebra.FinitePresentation R A\nf : AlgHom R A S\nhf : Function.Surjective ⇑f\nt : Finset A\nht : Eq (Ideal.span ↑t) Top.top\nH : ∀ (g : Subtype fun x => Membership.mem t x), Algebra.FinitePresentation R (Localization.Away (f ↑g))\n⊢ Algebra.FinitePresentation R S","decl":"/--\nIf `S` is an `R`-algebra with a surjection from a finitely-presented `R`-algebra `A`, such that\nlocalized at a spanning set `{ r }` of elements of `A`, `Sᵣ` is finitely-presented, then\n`S` is finitely presented.\nThis is almost `finitePresentation_ofLocalizationSpanTarget`. The difference is,\nthat here the set `t` generates the unit ideal of `A`, while in the general version,\nit only generates a quotient of `A`.\n-/\nlemma finitePresentation_ofLocalizationSpanTarget_aux\n    {R S A : Type*} [CommRing R] [CommRing S] [CommRing A] [Algebra R S] [Algebra R A]\n    [Algebra.FinitePresentation R A] (f : A →ₐ[R] S) (hf : Function.Surjective f)\n    (t : Finset A) (ht : Ideal.span (t : Set A) = ⊤)\n    (H : ∀ g : t, Algebra.FinitePresentation R (Localization.Away (f g))) :\n    Algebra.FinitePresentation R S := by\n  apply Algebra.FinitePresentation.of_surjective hf\n  apply ker_fg_of_localizationSpan t ht\n  intro g\n  let f' : Localization.Away g.val →ₐ[R] Localization.Away (f g) :=\n    Localization.awayMapₐ f g.val\n  have (g : t) : Algebra.FinitePresentation R (Localization.Away g.val) :=\n    haveI : Algebra.FinitePresentation A (Localization.Away g.val) :=\n      IsLocalization.Away.finitePresentation g.val\n    Algebra.FinitePresentation.trans R A (Localization.Away g.val)\n  apply Algebra.FinitePresentation.ker_fG_of_surjective f'\n  exact IsLocalization.Away.mapₐ_surjective_of_surjective _ hf\n\n"}
{"name":"RingHom.finitePresentation_ofLocalizationSpanTarget","module":"Mathlib.RingTheory.RingHom.FinitePresentation","initialProofState":"⊢ RingHom.OfLocalizationSpanTarget @RingHom.FinitePresentation","decl":"/-- Finite-presentation can be checked on a standard covering of the target. -/\ntheorem finitePresentation_ofLocalizationSpanTarget :\n    OfLocalizationSpanTarget @FinitePresentation := by\n  rw [ofLocalizationSpanTarget_iff_finite]\n  introv R hs H\n  classical\n  letI := f.toAlgebra\n  replace H : ∀ r : s, Algebra.FinitePresentation R (Localization.Away (r : S)) := by\n    intro r; simp_rw [RingHom.FinitePresentation] at H\n    convert H r; ext; simp_rw [Algebra.smul_def]; rfl\n  /-\n  We already know that `S` is of finite type over `R`, so we have a surjection\n  `MvPolynomial (Fin n) R →ₐ[R] S`. To reason about the kernel, we want to check it on the stalks\n  of preimages of `s`. But the preimages do not necessarily span `MvPolynomial (Fin n) R`, so\n  we quotient out by an ideal and apply `finitePresentation_ofLocalizationSpanTarget_aux`.\n  -/\n  have hfintype : Algebra.FiniteType R S := by\n    apply finiteType_ofLocalizationSpanTarget f s hs\n    intro r\n    convert_to Algebra.FiniteType R (Localization.Away r.val)\n    · rw [RingHom.FiniteType]\n      constructor <;> intro h <;> convert h <;> ext <;> simp_rw [Algebra.smul_def] <;> rfl\n    · infer_instance\n  rw [RingHom.FinitePresentation]\n  obtain ⟨n, f, hf⟩ := Algebra.FiniteType.iff_quotient_mvPolynomial''.mp hfintype\n  obtain ⟨l, hl⟩ := (Finsupp.mem_span_iff_linearCombination S (s : Set S) 1).mp\n      (show (1 : S) ∈ Ideal.span (s : Set S) by rw [hs]; trivial)\n  choose g' hg' using (fun g : s ↦ hf g)\n  choose h' hh' using (fun g : s ↦ hf (l g))\n  let I : Ideal (MvPolynomial (Fin n) R) := Ideal.span { ∑ g : s, g' g * h' g - 1 }\n  let A := MvPolynomial (Fin n) R ⧸ I\n  have hfI : ∀ a ∈ I, f a = 0 := by\n    intro p hp\n    simp only [Finset.univ_eq_attach, I, Ideal.mem_span_singleton] at hp\n    obtain ⟨q, rfl⟩ := hp\n    simp only [map_mul, map_sub, map_sum, map_one, hg', hh']\n    erw [Finsupp.linearCombination_apply_of_mem_supported S (s := s.attach)] at hl\n    · rw [← hl]\n      simp only [Finset.coe_sort_coe, smul_eq_mul, mul_comm, sub_self, mul_zero, zero_mul]\n    · rintro a -\n      simp\n  let f' : A →ₐ[R] S := Ideal.Quotient.liftₐ I f hfI\n  have hf' : Function.Surjective f' :=\n    Ideal.Quotient.lift_surjective_of_surjective I hfI hf\n  let t : Finset A := Finset.image (fun g ↦ g' g) Finset.univ\n  have ht : Ideal.span (t : Set A) = ⊤ := by\n    rw [Ideal.eq_top_iff_one]\n    have : ∑ g : { x // x ∈ s }, g' g * h' g = (1 : A) := by\n      apply eq_of_sub_eq_zero\n      rw [← map_one (Ideal.Quotient.mk I), ← map_sub, Ideal.Quotient.eq_zero_iff_mem]\n      apply Ideal.subset_span\n      simp\n    simp_rw [← this, Finset.univ_eq_attach, map_sum, map_mul]\n    refine Ideal.sum_mem _ (fun g _ ↦ Ideal.mul_mem_right _ _ <| Ideal.subset_span ?_)\n    simp [t]\n  have : Algebra.FinitePresentation R A := by\n    apply Algebra.FinitePresentation.quotient\n    simp only [Finset.univ_eq_attach, I]\n    exact ⟨{∑ g ∈ s.attach, g' g * h' g - 1}, by simp⟩\n  have Ht (g : t) : Algebra.FinitePresentation R (Localization.Away (f' g)) := by\n    have : ∃ (a : S) (hb : a ∈ s), (Ideal.Quotient.mk I) (g' ⟨a, hb⟩) = g.val := by\n      obtain ⟨g, hg⟩ := g\n      convert hg\n      simp [A, f', t]\n    obtain ⟨r, hr, hrr⟩ := this\n    simp only [f']\n    rw [← hrr, Ideal.Quotient.liftₐ_apply, Ideal.Quotient.lift_mk]\n    simp_rw [coe_coe]\n    rw [hg']\n    apply H\n  exact finitePresentation_ofLocalizationSpanTarget_aux f' hf' t ht Ht\n\n"}
{"name":"RingHom.finitePresentation_isLocal","module":"Mathlib.RingTheory.RingHom.FinitePresentation","initialProofState":"⊢ RingHom.PropertyIsLocal @RingHom.FinitePresentation","decl":"/-- Being finitely-presented is a local property of rings. -/\ntheorem finitePresentation_isLocal : PropertyIsLocal @FinitePresentation :=\n  ⟨finitePresentation_localizationPreserves.away,\n    finitePresentation_ofLocalizationSpanTarget,\n    finitePresentation_ofLocalizationSpanTarget.ofLocalizationSpan\n      (finitePresentation_stableUnderComposition.stableUnderCompositionWithLocalizationAway\n        finitePresentation_holdsForLocalizationAway).left,\n    (finitePresentation_stableUnderComposition.stableUnderCompositionWithLocalizationAway\n      finitePresentation_holdsForLocalizationAway).right⟩\n\n"}
{"name":"RingHom.finitePresentation_respectsIso","module":"Mathlib.RingTheory.RingHom.FinitePresentation","initialProofState":"⊢ RingHom.RespectsIso @RingHom.FinitePresentation","decl":"/-- Being finitely-presented respects isomorphisms. -/\ntheorem finitePresentation_respectsIso : RingHom.RespectsIso @RingHom.FinitePresentation :=\n  RingHom.finitePresentation_isLocal.respectsIso\n\n"}
{"name":"RingHom.finitePresentation_isStableUnderBaseChange","module":"Mathlib.RingTheory.RingHom.FinitePresentation","initialProofState":"⊢ RingHom.IsStableUnderBaseChange @RingHom.FinitePresentation","decl":"/-- Being finitely-presented is stable under base change. -/\ntheorem finitePresentation_isStableUnderBaseChange :\n    IsStableUnderBaseChange @FinitePresentation := by\n  apply IsStableUnderBaseChange.mk\n  · exact finitePresentation_respectsIso\n  · introv h\n    replace h : Algebra.FinitePresentation R T := by\n      rw [RingHom.FinitePresentation] at h; convert h; ext; simp_rw [Algebra.smul_def]; rfl\n    suffices Algebra.FinitePresentation S (S ⊗[R] T) by\n      rw [RingHom.FinitePresentation]; convert this; ext; simp_rw [Algebra.smul_def]; rfl\n    infer_instance\n\n"}
