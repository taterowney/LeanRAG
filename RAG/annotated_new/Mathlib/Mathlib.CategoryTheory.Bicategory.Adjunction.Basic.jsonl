{"name":"CategoryTheory.Bicategory.rightZigzag_idempotent_of_left_triangle","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nf : Quiver.Hom a b\ng : Quiver.Hom b a\nη : Quiver.Hom (CategoryTheory.CategoryStruct.id a) (CategoryTheory.CategoryStruct.comp f g)\nε : Quiver.Hom (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.id b)\nh : Eq (CategoryTheory.Bicategory.leftZigzag η ε) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor f).hom (CategoryTheory.Bicategory.rightUnitor f).inv)\n⊢ Eq (CategoryTheory.bicategoricalComp (CategoryTheory.Bicategory.rightZigzag η ε) (CategoryTheory.Bicategory.rightZigzag η ε)) (CategoryTheory.Bicategory.rightZigzag η ε)","decl":"theorem rightZigzag_idempotent_of_left_triangle\n    (η : 𝟙 a ⟶ f ≫ g) (ε : g ≫ f ⟶ 𝟙 b) (h : leftZigzag η ε = (λ_ _).hom ≫ (ρ_ _).inv) :\n    rightZigzag η ε ⊗≫ rightZigzag η ε = rightZigzag η ε := by\n  dsimp only [rightZigzag]\n  calc\n    _ = g ◁ η ⊗≫ ((ε ▷ g ▷ 𝟙 a) ≫ (𝟙 b ≫ g) ◁ η) ⊗≫ ε ▷ g := by\n      bicategory\n    _ = 𝟙 _ ⊗≫ g ◁ (η ▷ 𝟙 a ≫ (f ≫ g) ◁ η) ⊗≫ (ε ▷ (g ≫ f) ≫ 𝟙 b ◁ ε) ▷ g ⊗≫ 𝟙 _ := by\n      rw [← whisker_exchange]; bicategory\n    _ = g ◁ η ⊗≫ g ◁ leftZigzag η ε ▷ g ⊗≫ ε ▷ g := by\n      rw [← whisker_exchange,  ← whisker_exchange, leftZigzag]; bicategory\n    _ = g ◁ η ⊗≫ ε ▷ g := by\n      rw [h]; bicategory\n\n"}
{"name":"CategoryTheory.Bicategory.Adjunction.left_triangle","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nf : Quiver.Hom a b\ng : Quiver.Hom b a\nself : CategoryTheory.Bicategory.Adjunction f g\n⊢ Eq (CategoryTheory.Bicategory.leftZigzag self.unit self.counit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor f).hom (CategoryTheory.Bicategory.rightUnitor f).inv)","decl":"/-- Adjunction between two 1-morphisms. -/\nstructure Adjunction (f : a ⟶ b) (g : b ⟶ a) where\n  /-- The unit of an adjunction. -/\n  unit : 𝟙 a ⟶ f ≫ g\n  /-- The counit of an adjunction. -/\n  counit : g ≫ f ⟶ 𝟙 b\n  /-- The composition of the unit and the counit is equal to the identity up to unitors. -/\n  left_triangle : leftZigzag unit counit = (λ_ _).hom ≫ (ρ_ _).inv := by aesop_cat\n  /-- The composition of the unit and the counit is equal to the identity up to unitors. -/\n  right_triangle : rightZigzag unit counit = (ρ_ _).hom ≫ (λ_ _).inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.Bicategory.Adjunction.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝¹ : CategoryTheory.Bicategory B\na b : B\nf : Quiver.Hom a b\ng : Quiver.Hom b a\ninst✝ : SizeOf B\nunit : Quiver.Hom (CategoryTheory.CategoryStruct.id a) (CategoryTheory.CategoryStruct.comp f g)\ncounit : Quiver.Hom (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.id b)\nleft_triangle : autoParam (Eq (CategoryTheory.Bicategory.leftZigzag unit counit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor f).hom (CategoryTheory.Bicategory.rightUnitor f).inv)) _auto✝\nright_triangle : autoParam (Eq (CategoryTheory.Bicategory.rightZigzag unit counit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor g).hom (CategoryTheory.Bicategory.leftUnitor g).inv)) _auto✝\n⊢ Eq (SizeOf.sizeOf { unit := unit, counit := counit, left_triangle := left_triangle, right_triangle := right_triangle }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf unit)) (SizeOf.sizeOf counit)) (SizeOf.sizeOf left_triangle)) (SizeOf.sizeOf right_triangle))","decl":"/-- Adjunction between two 1-morphisms. -/\nstructure Adjunction (f : a ⟶ b) (g : b ⟶ a) where\n  /-- The unit of an adjunction. -/\n  unit : 𝟙 a ⟶ f ≫ g\n  /-- The counit of an adjunction. -/\n  counit : g ≫ f ⟶ 𝟙 b\n  /-- The composition of the unit and the counit is equal to the identity up to unitors. -/\n  left_triangle : leftZigzag unit counit = (λ_ _).hom ≫ (ρ_ _).inv := by aesop_cat\n  /-- The composition of the unit and the counit is equal to the identity up to unitors. -/\n  right_triangle : rightZigzag unit counit = (ρ_ _).hom ≫ (λ_ _).inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.Bicategory.Adjunction.mk.inj","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nf : Quiver.Hom a b\ng : Quiver.Hom b a\nunit✝ : Quiver.Hom (CategoryTheory.CategoryStruct.id a) (CategoryTheory.CategoryStruct.comp f g)\ncounit✝ : Quiver.Hom (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.id b)\nleft_triangle✝ : autoParam (Eq (CategoryTheory.Bicategory.leftZigzag unit✝ counit✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor f).hom (CategoryTheory.Bicategory.rightUnitor f).inv)) _auto✝\nright_triangle✝ : autoParam (Eq (CategoryTheory.Bicategory.rightZigzag unit✝ counit✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor g).hom (CategoryTheory.Bicategory.leftUnitor g).inv)) _auto✝\nunit : Quiver.Hom (CategoryTheory.CategoryStruct.id a) (CategoryTheory.CategoryStruct.comp f g)\ncounit : Quiver.Hom (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.id b)\nleft_triangle : autoParam (Eq (CategoryTheory.Bicategory.leftZigzag unit counit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor f).hom (CategoryTheory.Bicategory.rightUnitor f).inv)) _auto✝\nright_triangle : autoParam (Eq (CategoryTheory.Bicategory.rightZigzag unit counit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor g).hom (CategoryTheory.Bicategory.leftUnitor g).inv)) _auto✝\nx✝ : Eq { unit := unit✝, counit := counit✝, left_triangle := left_triangle✝, right_triangle := right_triangle✝ } { unit := unit, counit := counit, left_triangle := left_triangle, right_triangle := right_triangle }\n⊢ And (Eq unit✝ unit) (Eq counit✝ counit)","decl":"/-- Adjunction between two 1-morphisms. -/\nstructure Adjunction (f : a ⟶ b) (g : b ⟶ a) where\n  /-- The unit of an adjunction. -/\n  unit : 𝟙 a ⟶ f ≫ g\n  /-- The counit of an adjunction. -/\n  counit : g ≫ f ⟶ 𝟙 b\n  /-- The composition of the unit and the counit is equal to the identity up to unitors. -/\n  left_triangle : leftZigzag unit counit = (λ_ _).hom ≫ (ρ_ _).inv := by aesop_cat\n  /-- The composition of the unit and the counit is equal to the identity up to unitors. -/\n  right_triangle : rightZigzag unit counit = (ρ_ _).hom ≫ (λ_ _).inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.Bicategory.Adjunction.mk.injEq","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nf : Quiver.Hom a b\ng : Quiver.Hom b a\nunit✝ : Quiver.Hom (CategoryTheory.CategoryStruct.id a) (CategoryTheory.CategoryStruct.comp f g)\ncounit✝ : Quiver.Hom (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.id b)\nleft_triangle✝ : autoParam (Eq (CategoryTheory.Bicategory.leftZigzag unit✝ counit✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor f).hom (CategoryTheory.Bicategory.rightUnitor f).inv)) _auto✝\nright_triangle✝ : autoParam (Eq (CategoryTheory.Bicategory.rightZigzag unit✝ counit✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor g).hom (CategoryTheory.Bicategory.leftUnitor g).inv)) _auto✝\nunit : Quiver.Hom (CategoryTheory.CategoryStruct.id a) (CategoryTheory.CategoryStruct.comp f g)\ncounit : Quiver.Hom (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.id b)\nleft_triangle : autoParam (Eq (CategoryTheory.Bicategory.leftZigzag unit counit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor f).hom (CategoryTheory.Bicategory.rightUnitor f).inv)) _auto✝\nright_triangle : autoParam (Eq (CategoryTheory.Bicategory.rightZigzag unit counit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor g).hom (CategoryTheory.Bicategory.leftUnitor g).inv)) _auto✝\n⊢ Eq (Eq { unit := unit✝, counit := counit✝, left_triangle := left_triangle✝, right_triangle := right_triangle✝ } { unit := unit, counit := counit, left_triangle := left_triangle, right_triangle := right_triangle }) (And (Eq unit✝ unit) (Eq counit✝ counit))","decl":"/-- Adjunction between two 1-morphisms. -/\nstructure Adjunction (f : a ⟶ b) (g : b ⟶ a) where\n  /-- The unit of an adjunction. -/\n  unit : 𝟙 a ⟶ f ≫ g\n  /-- The counit of an adjunction. -/\n  counit : g ≫ f ⟶ 𝟙 b\n  /-- The composition of the unit and the counit is equal to the identity up to unitors. -/\n  left_triangle : leftZigzag unit counit = (λ_ _).hom ≫ (ρ_ _).inv := by aesop_cat\n  /-- The composition of the unit and the counit is equal to the identity up to unitors. -/\n  right_triangle : rightZigzag unit counit = (ρ_ _).hom ≫ (λ_ _).inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.Bicategory.Adjunction.right_triangle","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nf : Quiver.Hom a b\ng : Quiver.Hom b a\nself : CategoryTheory.Bicategory.Adjunction f g\n⊢ Eq (CategoryTheory.Bicategory.rightZigzag self.unit self.counit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor g).hom (CategoryTheory.Bicategory.leftUnitor g).inv)","decl":"/-- Adjunction between two 1-morphisms. -/\nstructure Adjunction (f : a ⟶ b) (g : b ⟶ a) where\n  /-- The unit of an adjunction. -/\n  unit : 𝟙 a ⟶ f ≫ g\n  /-- The counit of an adjunction. -/\n  counit : g ≫ f ⟶ 𝟙 b\n  /-- The composition of the unit and the counit is equal to the identity up to unitors. -/\n  left_triangle : leftZigzag unit counit = (λ_ _).hom ≫ (ρ_ _).inv := by aesop_cat\n  /-- The composition of the unit and the counit is equal to the identity up to unitors. -/\n  right_triangle : rightZigzag unit counit = (ρ_ _).hom ≫ (λ_ _).inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.Bicategory.Adjunction.comp_left_triangle_aux","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b c : B\nf₁ : Quiver.Hom a b\ng₁ : Quiver.Hom b a\nf₂ : Quiver.Hom b c\ng₂ : Quiver.Hom c b\nadj₁ : CategoryTheory.Bicategory.Adjunction f₁ g₁\nadj₂ : CategoryTheory.Bicategory.Adjunction f₂ g₂\n⊢ Eq (CategoryTheory.Bicategory.leftZigzag (adj₁.compUnit adj₂) (adj₁.compCounit adj₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (CategoryTheory.CategoryStruct.comp f₁ f₂)).hom (CategoryTheory.Bicategory.rightUnitor (CategoryTheory.CategoryStruct.comp f₁ f₂)).inv)","decl":"theorem comp_left_triangle_aux (adj₁ : f₁ ⊣ g₁) (adj₂ : f₂ ⊣ g₂) :\n    leftZigzag (compUnit adj₁ adj₂) (compCounit adj₁ adj₂) = (λ_ _).hom ≫ (ρ_ _).inv := by\n  calc\n    _ = 𝟙 _ ⊗≫\n          adj₁.unit ▷ (f₁ ≫ f₂) ⊗≫\n            f₁ ◁ (adj₂.unit ▷ (g₁ ≫ f₁) ≫ (f₂ ≫ g₂) ◁ adj₁.counit) ▷ f₂ ⊗≫\n              (f₁ ≫ f₂) ◁ adj₂.counit ⊗≫ 𝟙 _ := by\n      dsimp only [compUnit, compCounit]; bicategory\n    _ = 𝟙 _ ⊗≫\n          (leftZigzag adj₁.unit adj₁.counit) ▷ f₂ ⊗≫\n            f₁ ◁ (leftZigzag adj₂.unit adj₂.counit) ⊗≫ 𝟙 _ := by\n      rw [← whisker_exchange]; bicategory\n    _ = _ := by\n      simp_rw [left_triangle]; bicategory\n\n"}
{"name":"CategoryTheory.Bicategory.Adjunction.comp_right_triangle_aux","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b c : B\nf₁ : Quiver.Hom a b\ng₁ : Quiver.Hom b a\nf₂ : Quiver.Hom b c\ng₂ : Quiver.Hom c b\nadj₁ : CategoryTheory.Bicategory.Adjunction f₁ g₁\nadj₂ : CategoryTheory.Bicategory.Adjunction f₂ g₂\n⊢ Eq (CategoryTheory.Bicategory.rightZigzag (adj₁.compUnit adj₂) (adj₁.compCounit adj₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (CategoryTheory.CategoryStruct.comp g₂ g₁)).hom (CategoryTheory.Bicategory.leftUnitor (CategoryTheory.CategoryStruct.comp g₂ g₁)).inv)","decl":"theorem comp_right_triangle_aux (adj₁ : f₁ ⊣ g₁) (adj₂ : f₂ ⊣ g₂) :\n    rightZigzag (compUnit adj₁ adj₂) (compCounit adj₁ adj₂) = (ρ_ _).hom ≫ (λ_ _).inv := by\n  calc\n    _ = 𝟙 _ ⊗≫\n          (g₂ ≫ g₁) ◁ adj₁.unit ⊗≫\n            g₂ ◁ ((g₁ ≫ f₁) ◁ adj₂.unit ≫ adj₁.counit ▷ (f₂ ≫ g₂)) ▷ g₁ ⊗≫\n              adj₂.counit ▷ (g₂ ≫ g₁) ⊗≫ 𝟙 _ := by\n      dsimp only [compUnit, compCounit]; bicategory\n    _ = 𝟙 _ ⊗≫\n          g₂ ◁ (rightZigzag adj₁.unit adj₁.counit) ⊗≫\n            (rightZigzag adj₂.unit adj₂.counit) ▷ g₁ ⊗≫ 𝟙 _ := by\n      rw [whisker_exchange]; bicategory\n    _ = _ := by\n      simp_rw [right_triangle]; bicategory\n\n"}
{"name":"CategoryTheory.Bicategory.Adjunction.comp_unit","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b c : B\nf₁ : Quiver.Hom a b\ng₁ : Quiver.Hom b a\nf₂ : Quiver.Hom b c\ng₂ : Quiver.Hom c b\nadj₁ : CategoryTheory.Bicategory.Adjunction f₁ g₁\nadj₂ : CategoryTheory.Bicategory.Adjunction f₂ g₂\n⊢ Eq (adj₁.comp adj₂).unit (adj₁.compUnit adj₂)","decl":"/-- Composition of adjunctions. -/\n@[simps]\ndef comp (adj₁ : f₁ ⊣ g₁) (adj₂ : f₂ ⊣ g₂) : f₁ ≫ f₂ ⊣ g₂ ≫ g₁ where\n  unit := compUnit adj₁ adj₂\n  counit := compCounit adj₁ adj₂\n  left_triangle := by apply comp_left_triangle_aux\n  right_triangle := by apply comp_right_triangle_aux\n\n"}
{"name":"CategoryTheory.Bicategory.Adjunction.comp_counit","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b c : B\nf₁ : Quiver.Hom a b\ng₁ : Quiver.Hom b a\nf₂ : Quiver.Hom b c\ng₂ : Quiver.Hom c b\nadj₁ : CategoryTheory.Bicategory.Adjunction f₁ g₁\nadj₂ : CategoryTheory.Bicategory.Adjunction f₂ g₂\n⊢ Eq (adj₁.comp adj₂).counit (adj₁.compCounit adj₂)","decl":"/-- Composition of adjunctions. -/\n@[simps]\ndef comp (adj₁ : f₁ ⊣ g₁) (adj₂ : f₂ ⊣ g₂) : f₁ ≫ f₂ ⊣ g₂ ≫ g₁ where\n  unit := compUnit adj₁ adj₂\n  counit := compCounit adj₁ adj₂\n  left_triangle := by apply comp_left_triangle_aux\n  right_triangle := by apply comp_right_triangle_aux\n\n"}
{"name":"CategoryTheory.Bicategory.leftZigzagIso_hom","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nf : Quiver.Hom a b\ng : Quiver.Hom b a\nη : CategoryTheory.Iso (CategoryTheory.CategoryStruct.id a) (CategoryTheory.CategoryStruct.comp f g)\nε : CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.id b)\n⊢ Eq (CategoryTheory.Bicategory.leftZigzagIso η ε).hom (CategoryTheory.Bicategory.leftZigzag η.hom ε.hom)","decl":"@[simp]\ntheorem leftZigzagIso_hom : (leftZigzagIso η ε).hom = leftZigzag η.hom ε.hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Bicategory.rightZigzagIso_hom","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nf : Quiver.Hom a b\ng : Quiver.Hom b a\nη : CategoryTheory.Iso (CategoryTheory.CategoryStruct.id a) (CategoryTheory.CategoryStruct.comp f g)\nε : CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.id b)\n⊢ Eq (CategoryTheory.Bicategory.rightZigzagIso η ε).hom (CategoryTheory.Bicategory.rightZigzag η.hom ε.hom)","decl":"@[simp]\ntheorem rightZigzagIso_hom : (rightZigzagIso η ε).hom = rightZigzag η.hom ε.hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Bicategory.leftZigzagIso_inv","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nf : Quiver.Hom a b\ng : Quiver.Hom b a\nη : CategoryTheory.Iso (CategoryTheory.CategoryStruct.id a) (CategoryTheory.CategoryStruct.comp f g)\nε : CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.id b)\n⊢ Eq (CategoryTheory.Bicategory.leftZigzagIso η ε).inv (CategoryTheory.Bicategory.rightZigzag ε.inv η.inv)","decl":"@[simp]\ntheorem leftZigzagIso_inv : (leftZigzagIso η ε).inv = rightZigzag ε.inv η.inv := by\n  simp [bicategoricalComp, bicategoricalIsoComp]\n\n"}
{"name":"CategoryTheory.Bicategory.rightZigzagIso_inv","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nf : Quiver.Hom a b\ng : Quiver.Hom b a\nη : CategoryTheory.Iso (CategoryTheory.CategoryStruct.id a) (CategoryTheory.CategoryStruct.comp f g)\nε : CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.id b)\n⊢ Eq (CategoryTheory.Bicategory.rightZigzagIso η ε).inv (CategoryTheory.Bicategory.leftZigzag ε.inv η.inv)","decl":"@[simp]\ntheorem rightZigzagIso_inv : (rightZigzagIso η ε).inv = leftZigzag ε.inv η.inv := by\n  simp [bicategoricalComp, bicategoricalIsoComp]\n\n"}
{"name":"CategoryTheory.Bicategory.leftZigzagIso_symm","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nf : Quiver.Hom a b\ng : Quiver.Hom b a\nη : CategoryTheory.Iso (CategoryTheory.CategoryStruct.id a) (CategoryTheory.CategoryStruct.comp f g)\nε : CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.id b)\n⊢ Eq (CategoryTheory.Bicategory.leftZigzagIso η ε).symm (CategoryTheory.Bicategory.rightZigzagIso ε.symm η.symm)","decl":"@[simp]\ntheorem leftZigzagIso_symm : (leftZigzagIso η ε).symm = rightZigzagIso ε.symm η.symm :=\n  Iso.ext (leftZigzagIso_inv η ε)\n\n"}
{"name":"CategoryTheory.Bicategory.rightZigzagIso_symm","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nf : Quiver.Hom a b\ng : Quiver.Hom b a\nη : CategoryTheory.Iso (CategoryTheory.CategoryStruct.id a) (CategoryTheory.CategoryStruct.comp f g)\nε : CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.id b)\n⊢ Eq (CategoryTheory.Bicategory.rightZigzagIso η ε).symm (CategoryTheory.Bicategory.leftZigzagIso ε.symm η.symm)","decl":"@[simp]\ntheorem rightZigzagIso_symm : (rightZigzagIso η ε).symm = leftZigzagIso ε.symm η.symm :=\n  Iso.ext (rightZigzagIso_inv η ε)\n\n"}
{"name":"CategoryTheory.Bicategory.instIsIsoHomLeftZigzagHom","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nf : Quiver.Hom a b\ng : Quiver.Hom b a\nη : CategoryTheory.Iso (CategoryTheory.CategoryStruct.id a) (CategoryTheory.CategoryStruct.comp f g)\nε : CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.id b)\n⊢ CategoryTheory.IsIso (CategoryTheory.Bicategory.leftZigzag η.hom ε.hom)","decl":"instance : IsIso (leftZigzag η.hom ε.hom) := inferInstanceAs <| IsIso (leftZigzagIso η ε).hom\n\n"}
{"name":"CategoryTheory.Bicategory.instIsIsoHomRightZigzagHom","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nf : Quiver.Hom a b\ng : Quiver.Hom b a\nη : CategoryTheory.Iso (CategoryTheory.CategoryStruct.id a) (CategoryTheory.CategoryStruct.comp f g)\nε : CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.id b)\n⊢ CategoryTheory.IsIso (CategoryTheory.Bicategory.rightZigzag η.hom ε.hom)","decl":"instance : IsIso (rightZigzag η.hom ε.hom) := inferInstanceAs <| IsIso (rightZigzagIso η ε).hom\n\n"}
{"name":"CategoryTheory.Bicategory.right_triangle_of_left_triangle","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nf : Quiver.Hom a b\ng : Quiver.Hom b a\nη : CategoryTheory.Iso (CategoryTheory.CategoryStruct.id a) (CategoryTheory.CategoryStruct.comp f g)\nε : CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.id b)\nh : Eq (CategoryTheory.Bicategory.leftZigzag η.hom ε.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor f).hom (CategoryTheory.Bicategory.rightUnitor f).inv)\n⊢ Eq (CategoryTheory.Bicategory.rightZigzag η.hom ε.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor g).hom (CategoryTheory.Bicategory.leftUnitor g).inv)","decl":"theorem right_triangle_of_left_triangle (h : leftZigzag η.hom ε.hom = (λ_ f).hom ≫ (ρ_ f).inv) :\n    rightZigzag η.hom ε.hom = (ρ_ g).hom ≫ (λ_ g).inv := by\n  rw [← cancel_epi (rightZigzag η.hom ε.hom ≫ (λ_ g).hom ≫ (ρ_ g).inv)]\n  calc\n    _ = rightZigzag η.hom ε.hom ⊗≫ rightZigzag η.hom ε.hom := by bicategory\n    _ = rightZigzag η.hom ε.hom := rightZigzag_idempotent_of_left_triangle _ _ h\n    _ = _ := by simp\n\n"}
{"name":"CategoryTheory.Bicategory.adjointifyCounit_left_triangle","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nf : Quiver.Hom a b\ng : Quiver.Hom b a\nη : CategoryTheory.Iso (CategoryTheory.CategoryStruct.id a) (CategoryTheory.CategoryStruct.comp f g)\nε : CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.id b)\n⊢ Eq (CategoryTheory.Bicategory.leftZigzagIso η (CategoryTheory.Bicategory.adjointifyCounit η ε)) ((CategoryTheory.Bicategory.leftUnitor f).trans (CategoryTheory.Bicategory.rightUnitor f).symm)","decl":"theorem adjointifyCounit_left_triangle (η : 𝟙 a ≅ f ≫ g) (ε : g ≫ f ≅ 𝟙 b) :\n    leftZigzagIso η (adjointifyCounit η ε) = λ_ f ≪≫ (ρ_ f).symm := by\n  apply Iso.ext\n  dsimp [adjointifyCounit, bicategoricalIsoComp]\n  calc\n    _ = 𝟙 _ ⊗≫ (η.hom ▷ (f ≫ 𝟙 b) ≫ (f ≫ g) ◁ f ◁ ε.inv) ⊗≫\n          f ◁ g ◁ η.inv ▷ f ⊗≫ f ◁ ε.hom := by\n      bicategory\n    _ = 𝟙 _ ⊗≫ f ◁ ε.inv ⊗≫ (η.hom ▷ (f ≫ g) ≫ (f ≫ g) ◁ η.inv) ▷ f ⊗≫ f ◁ ε.hom := by\n      rw [← whisker_exchange η.hom (f ◁ ε.inv)]; bicategory\n    _ = 𝟙 _ ⊗≫ f ◁ ε.inv ⊗≫ (η.inv ≫ η.hom) ▷ f ⊗≫ f ◁ ε.hom := by\n      rw [← whisker_exchange η.hom η.inv]; bicategory\n    _ = 𝟙 _ ⊗≫ f ◁ (ε.inv ≫ ε.hom) := by\n      rw [Iso.inv_hom_id]; bicategory\n    _ = _ := by\n      rw [Iso.inv_hom_id]; bicategory\n\n"}
{"name":"CategoryTheory.Bicategory.Equivalence.mk.injEq","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nhom✝ : Quiver.Hom a b\ninv✝ : Quiver.Hom b a\nunit✝ : CategoryTheory.Iso (CategoryTheory.CategoryStruct.id a) (CategoryTheory.CategoryStruct.comp hom✝ inv✝)\ncounit✝ : CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp inv✝ hom✝) (CategoryTheory.CategoryStruct.id b)\nleft_triangle✝ : autoParam (Eq (CategoryTheory.Bicategory.leftZigzagIso unit✝ counit✝) ((CategoryTheory.Bicategory.leftUnitor hom✝).trans (CategoryTheory.Bicategory.rightUnitor hom✝).symm)) _auto✝\nhom : Quiver.Hom a b\ninv : Quiver.Hom b a\nunit : CategoryTheory.Iso (CategoryTheory.CategoryStruct.id a) (CategoryTheory.CategoryStruct.comp hom inv)\ncounit : CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp inv hom) (CategoryTheory.CategoryStruct.id b)\nleft_triangle : autoParam (Eq (CategoryTheory.Bicategory.leftZigzagIso unit counit) ((CategoryTheory.Bicategory.leftUnitor hom).trans (CategoryTheory.Bicategory.rightUnitor hom).symm)) _auto✝\n⊢ Eq (Eq { hom := hom✝, inv := inv✝, unit := unit✝, counit := counit✝, left_triangle := left_triangle✝ } { hom := hom, inv := inv, unit := unit, counit := counit, left_triangle := left_triangle }) (And (Eq hom✝ hom) (And (Eq inv✝ inv) (And (HEq unit✝ unit) (HEq counit✝ counit))))","decl":"/-- Adjoint equivalences between two objects. -/\nstructure Equivalence (a b : B) where\n  /-- A 1-morphism in one direction. -/\n  hom : a ⟶ b\n  /-- A 1-morphism in the other direction. -/\n  inv : b ⟶ a\n  /-- The composition `hom ≫ inv` is isomorphic to the identity. -/\n  unit : 𝟙 a ≅ hom ≫ inv\n  /-- The composition `inv ≫ hom` is isomorphic to the identity. -/\n  counit : inv ≫ hom ≅ 𝟙 b\n  /-- The composition of the unit and the counit is equal to the identity up to unitors. -/\n  left_triangle : leftZigzagIso unit counit = λ_ hom ≪≫ (ρ_ hom).symm := by aesop_cat\n\n"}
{"name":"CategoryTheory.Bicategory.Equivalence.mk.inj","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nhom✝ : Quiver.Hom a b\ninv✝ : Quiver.Hom b a\nunit✝ : CategoryTheory.Iso (CategoryTheory.CategoryStruct.id a) (CategoryTheory.CategoryStruct.comp hom✝ inv✝)\ncounit✝ : CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp inv✝ hom✝) (CategoryTheory.CategoryStruct.id b)\nleft_triangle✝ : autoParam (Eq (CategoryTheory.Bicategory.leftZigzagIso unit✝ counit✝) ((CategoryTheory.Bicategory.leftUnitor hom✝).trans (CategoryTheory.Bicategory.rightUnitor hom✝).symm)) _auto✝\nhom : Quiver.Hom a b\ninv : Quiver.Hom b a\nunit : CategoryTheory.Iso (CategoryTheory.CategoryStruct.id a) (CategoryTheory.CategoryStruct.comp hom inv)\ncounit : CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp inv hom) (CategoryTheory.CategoryStruct.id b)\nleft_triangle : autoParam (Eq (CategoryTheory.Bicategory.leftZigzagIso unit counit) ((CategoryTheory.Bicategory.leftUnitor hom).trans (CategoryTheory.Bicategory.rightUnitor hom).symm)) _auto✝\nx✝ : Eq { hom := hom✝, inv := inv✝, unit := unit✝, counit := counit✝, left_triangle := left_triangle✝ } { hom := hom, inv := inv, unit := unit, counit := counit, left_triangle := left_triangle }\n⊢ And (Eq hom✝ hom) (And (Eq inv✝ inv) (And (HEq unit✝ unit) (HEq counit✝ counit)))","decl":"/-- Adjoint equivalences between two objects. -/\nstructure Equivalence (a b : B) where\n  /-- A 1-morphism in one direction. -/\n  hom : a ⟶ b\n  /-- A 1-morphism in the other direction. -/\n  inv : b ⟶ a\n  /-- The composition `hom ≫ inv` is isomorphic to the identity. -/\n  unit : 𝟙 a ≅ hom ≫ inv\n  /-- The composition `inv ≫ hom` is isomorphic to the identity. -/\n  counit : inv ≫ hom ≅ 𝟙 b\n  /-- The composition of the unit and the counit is equal to the identity up to unitors. -/\n  left_triangle : leftZigzagIso unit counit = λ_ hom ≪≫ (ρ_ hom).symm := by aesop_cat\n\n"}
{"name":"CategoryTheory.Bicategory.Equivalence.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝¹ : CategoryTheory.Bicategory B\na b : B\ninst✝ : SizeOf B\nhom : Quiver.Hom a b\ninv : Quiver.Hom b a\nunit : CategoryTheory.Iso (CategoryTheory.CategoryStruct.id a) (CategoryTheory.CategoryStruct.comp hom inv)\ncounit : CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp inv hom) (CategoryTheory.CategoryStruct.id b)\nleft_triangle : autoParam (Eq (CategoryTheory.Bicategory.leftZigzagIso unit counit) ((CategoryTheory.Bicategory.leftUnitor hom).trans (CategoryTheory.Bicategory.rightUnitor hom).symm)) _auto✝\n⊢ Eq (SizeOf.sizeOf { hom := hom, inv := inv, unit := unit, counit := counit, left_triangle := left_triangle }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf hom)) (SizeOf.sizeOf inv)) (SizeOf.sizeOf unit)) (SizeOf.sizeOf counit)) (SizeOf.sizeOf left_triangle))","decl":"/-- Adjoint equivalences between two objects. -/\nstructure Equivalence (a b : B) where\n  /-- A 1-morphism in one direction. -/\n  hom : a ⟶ b\n  /-- A 1-morphism in the other direction. -/\n  inv : b ⟶ a\n  /-- The composition `hom ≫ inv` is isomorphic to the identity. -/\n  unit : 𝟙 a ≅ hom ≫ inv\n  /-- The composition `inv ≫ hom` is isomorphic to the identity. -/\n  counit : inv ≫ hom ≅ 𝟙 b\n  /-- The composition of the unit and the counit is equal to the identity up to unitors. -/\n  left_triangle : leftZigzagIso unit counit = λ_ hom ≪≫ (ρ_ hom).symm := by aesop_cat\n\n"}
{"name":"CategoryTheory.Bicategory.Equivalence.left_triangle","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nself : CategoryTheory.Bicategory.Equivalence a b\n⊢ Eq (CategoryTheory.Bicategory.leftZigzagIso self.unit self.counit) ((CategoryTheory.Bicategory.leftUnitor self.hom).trans (CategoryTheory.Bicategory.rightUnitor self.hom).symm)","decl":"/-- Adjoint equivalences between two objects. -/\nstructure Equivalence (a b : B) where\n  /-- A 1-morphism in one direction. -/\n  hom : a ⟶ b\n  /-- A 1-morphism in the other direction. -/\n  inv : b ⟶ a\n  /-- The composition `hom ≫ inv` is isomorphic to the identity. -/\n  unit : 𝟙 a ≅ hom ≫ inv\n  /-- The composition `inv ≫ hom` is isomorphic to the identity. -/\n  counit : inv ≫ hom ≅ 𝟙 b\n  /-- The composition of the unit and the counit is equal to the identity up to unitors. -/\n  left_triangle : leftZigzagIso unit counit = λ_ hom ≪≫ (ρ_ hom).symm := by aesop_cat\n\n"}
{"name":"CategoryTheory.Bicategory.Equivalence.left_triangle_hom","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\ne : CategoryTheory.Bicategory.Equivalence a b\n⊢ Eq (CategoryTheory.Bicategory.leftZigzag e.unit.hom e.counit.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor e.hom).hom (CategoryTheory.Bicategory.rightUnitor e.hom).inv)","decl":"theorem left_triangle_hom (e : a ≌ b) :\n    leftZigzag e.unit.hom e.counit.hom = (λ_ e.hom).hom ≫ (ρ_ e.hom).inv :=\n  congrArg Iso.hom e.left_triangle\n\n"}
{"name":"CategoryTheory.Bicategory.Equivalence.right_triangle","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\ne : CategoryTheory.Bicategory.Equivalence a b\n⊢ Eq (CategoryTheory.Bicategory.rightZigzagIso e.unit e.counit) ((CategoryTheory.Bicategory.rightUnitor e.inv).trans (CategoryTheory.Bicategory.leftUnitor e.inv).symm)","decl":"theorem right_triangle (e : a ≌ b) :\n    rightZigzagIso e.unit e.counit = ρ_ e.inv ≪≫ (λ_ e.inv).symm :=\n  Iso.ext (right_triangle_of_left_triangle e.unit e.counit e.left_triangle_hom)\n\n"}
{"name":"CategoryTheory.Bicategory.Equivalence.right_triangle_hom","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\ne : CategoryTheory.Bicategory.Equivalence a b\n⊢ Eq (CategoryTheory.Bicategory.rightZigzag e.unit.hom e.counit.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor e.inv).hom (CategoryTheory.Bicategory.leftUnitor e.inv).inv)","decl":"theorem right_triangle_hom (e : a ≌ b) :\n    rightZigzag e.unit.hom e.counit.hom = (ρ_ e.inv).hom ≫ (λ_ e.inv).inv :=\n  congrArg Iso.hom e.right_triangle\n\n"}
{"name":"CategoryTheory.Bicategory.RightAdjoint.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝¹ : CategoryTheory.Bicategory B\na b : B\nleft : Quiver.Hom a b\ninst✝ : SizeOf B\nright : Quiver.Hom b a\nadj : CategoryTheory.Bicategory.Adjunction left right\n⊢ Eq (SizeOf.sizeOf { right := right, adj := adj }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf right)) (SizeOf.sizeOf adj))","decl":"/-- A structure giving a chosen right adjoint of a 1-morphism `left`. -/\nstructure RightAdjoint (left : a ⟶ b) where\n  /-- The right adjoint to `left`. -/\n  right : b ⟶ a\n  /-- The adjunction between `left` and `right`. -/\n  adj : left ⊣ right\n\n"}
{"name":"CategoryTheory.Bicategory.RightAdjoint.mk.injEq","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nleft : Quiver.Hom a b\nright✝ : Quiver.Hom b a\nadj✝ : CategoryTheory.Bicategory.Adjunction left right✝\nright : Quiver.Hom b a\nadj : CategoryTheory.Bicategory.Adjunction left right\n⊢ Eq (Eq { right := right✝, adj := adj✝ } { right := right, adj := adj }) (And (Eq right✝ right) (HEq adj✝ adj))","decl":"/-- A structure giving a chosen right adjoint of a 1-morphism `left`. -/\nstructure RightAdjoint (left : a ⟶ b) where\n  /-- The right adjoint to `left`. -/\n  right : b ⟶ a\n  /-- The adjunction between `left` and `right`. -/\n  adj : left ⊣ right\n\n"}
{"name":"CategoryTheory.Bicategory.RightAdjoint.mk.inj","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nleft : Quiver.Hom a b\nright✝ : Quiver.Hom b a\nadj✝ : CategoryTheory.Bicategory.Adjunction left right✝\nright : Quiver.Hom b a\nadj : CategoryTheory.Bicategory.Adjunction left right\nx✝ : Eq { right := right✝, adj := adj✝ } { right := right, adj := adj }\n⊢ And (Eq right✝ right) (HEq adj✝ adj)","decl":"/-- A structure giving a chosen right adjoint of a 1-morphism `left`. -/\nstructure RightAdjoint (left : a ⟶ b) where\n  /-- The right adjoint to `left`. -/\n  right : b ⟶ a\n  /-- The adjunction between `left` and `right`. -/\n  adj : left ⊣ right\n\n"}
{"name":"CategoryTheory.Bicategory.IsLeftAdjoint.nonempty","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nleft : Quiver.Hom a b\nself : CategoryTheory.Bicategory.IsLeftAdjoint left\n⊢ Nonempty (CategoryTheory.Bicategory.RightAdjoint left)","decl":"/-- The existence of a right adjoint of `f`. -/\nclass IsLeftAdjoint (left : a ⟶ b) : Prop where mk' ::\n  nonempty : Nonempty (RightAdjoint left)\n\n"}
{"name":"CategoryTheory.Bicategory.IsLeftAdjoint.mk","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nf : Quiver.Hom a b\ng : Quiver.Hom b a\nadj : CategoryTheory.Bicategory.Adjunction f g\n⊢ CategoryTheory.Bicategory.IsLeftAdjoint f","decl":"theorem IsLeftAdjoint.mk (adj : f ⊣ g) : IsLeftAdjoint f :=\n  ⟨⟨g, adj⟩⟩\n\n"}
{"name":"CategoryTheory.Bicategory.LeftAdjoint.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝¹ : CategoryTheory.Bicategory B\na b : B\nright : Quiver.Hom b a\ninst✝ : SizeOf B\nleft : Quiver.Hom a b\nadj : CategoryTheory.Bicategory.Adjunction left right\n⊢ Eq (SizeOf.sizeOf { left := left, adj := adj }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf left)) (SizeOf.sizeOf adj))","decl":"/-- A structure giving a chosen left adjoint of a 1-morphism `right`. -/\nstructure LeftAdjoint (right : b ⟶ a) where\n  /-- The left adjoint to `right`. -/\n  left : a ⟶ b\n  /-- The adjunction between `left` and `right`. -/\n  adj : left ⊣ right\n\n"}
{"name":"CategoryTheory.Bicategory.LeftAdjoint.mk.injEq","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nright : Quiver.Hom b a\nleft✝ : Quiver.Hom a b\nadj✝ : CategoryTheory.Bicategory.Adjunction left✝ right\nleft : Quiver.Hom a b\nadj : CategoryTheory.Bicategory.Adjunction left right\n⊢ Eq (Eq { left := left✝, adj := adj✝ } { left := left, adj := adj }) (And (Eq left✝ left) (HEq adj✝ adj))","decl":"/-- A structure giving a chosen left adjoint of a 1-morphism `right`. -/\nstructure LeftAdjoint (right : b ⟶ a) where\n  /-- The left adjoint to `right`. -/\n  left : a ⟶ b\n  /-- The adjunction between `left` and `right`. -/\n  adj : left ⊣ right\n\n"}
{"name":"CategoryTheory.Bicategory.LeftAdjoint.mk.inj","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nright : Quiver.Hom b a\nleft✝ : Quiver.Hom a b\nadj✝ : CategoryTheory.Bicategory.Adjunction left✝ right\nleft : Quiver.Hom a b\nadj : CategoryTheory.Bicategory.Adjunction left right\nx✝ : Eq { left := left✝, adj := adj✝ } { left := left, adj := adj }\n⊢ And (Eq left✝ left) (HEq adj✝ adj)","decl":"/-- A structure giving a chosen left adjoint of a 1-morphism `right`. -/\nstructure LeftAdjoint (right : b ⟶ a) where\n  /-- The left adjoint to `right`. -/\n  left : a ⟶ b\n  /-- The adjunction between `left` and `right`. -/\n  adj : left ⊣ right\n\n"}
{"name":"CategoryTheory.Bicategory.IsRightAdjoint.nonempty","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nright : Quiver.Hom b a\nself : CategoryTheory.Bicategory.IsRightAdjoint right\n⊢ Nonempty (CategoryTheory.Bicategory.LeftAdjoint right)","decl":"/-- The existence of a left adjoint of `f`. -/\nclass IsRightAdjoint (right : b ⟶ a) : Prop where mk' ::\n  nonempty : Nonempty (LeftAdjoint right)\n\n"}
{"name":"CategoryTheory.Bicategory.IsRightAdjoint.mk","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Basic","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b : B\nf : Quiver.Hom a b\ng : Quiver.Hom b a\nadj : CategoryTheory.Bicategory.Adjunction f g\n⊢ CategoryTheory.Bicategory.IsRightAdjoint g","decl":"theorem IsRightAdjoint.mk (adj : f ⊣ g) : IsRightAdjoint g :=\n  ⟨⟨f, adj⟩⟩\n\n"}
