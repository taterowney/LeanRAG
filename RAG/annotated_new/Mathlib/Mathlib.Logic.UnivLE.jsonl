{"name":"univLE_max","module":"Mathlib.Logic.UnivLE","initialProofState":"⊢ UnivLE.{u, max u v}","decl":"theorem univLE_max : UnivLE.{u, max u v} := fun α ↦ small_max.{v} α\n\n"}
{"name":"Small.trans_univLE","module":"Mathlib.Logic.UnivLE","initialProofState":"α : Type w\nhα : Small.{u, w} α\nh : UnivLE.{u, v}\n⊢ Small.{v, w} α","decl":"theorem Small.trans_univLE (α : Type w) [hα : Small.{u} α] [h : UnivLE.{u, v}] :\n    Small.{v} α :=\n  let ⟨β, ⟨f⟩⟩ := hα.equiv_small\n  let ⟨_, ⟨g⟩⟩ := (h β).equiv_small\n  ⟨_, ⟨f.trans g⟩⟩\n\n"}
{"name":"UnivLE.trans","module":"Mathlib.Logic.UnivLE","initialProofState":"inst✝¹ : UnivLE.{u, v}\ninst✝ : UnivLE.{v, w}\n⊢ UnivLE.{u, w}","decl":"theorem UnivLE.trans [UnivLE.{u, v}] [UnivLE.{v, w}] : UnivLE.{u, w} :=\n  fun α ↦ Small.trans_univLE α\n\n/- This is the crucial instance that subsumes `univLE_max`. -/\n"}
{"name":"univLE_of_max","module":"Mathlib.Logic.UnivLE","initialProofState":"inst✝ : UnivLE.{max u v, v}\n⊢ UnivLE.{u, v}","decl":"instance univLE_of_max [UnivLE.{max u v, v}] : UnivLE.{u, v} := @UnivLE.trans univLE_max ‹_›\n\n/- When `small_Pi` from `Mathlib.Logic.Small.Basic` is imported, we have : -/\n-- example (α : Type u) (β : Type v) [UnivLE.{u, v}] : Small.{v} (α → β) := inferInstance\n\n"}
