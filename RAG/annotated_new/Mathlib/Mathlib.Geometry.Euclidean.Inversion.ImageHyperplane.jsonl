{"name":"EuclideanGeometry.inversion_mem_perpBisector_inversion_iff","module":"Mathlib.Geometry.Euclidean.Inversion.ImageHyperplane","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc x y : P\nR : Real\nhR : Ne R 0\nhx : Ne x c\nhy : Ne y c\n⊢ Iff (Membership.mem (AffineSubspace.perpBisector c (EuclideanGeometry.inversion c R y)) (EuclideanGeometry.inversion c R x)) (Eq (Dist.dist x y) (Dist.dist y c))","decl":"/-- The inversion with center `c` and radius `R` maps a sphere passing through the center to a\nhyperplane. -/\ntheorem inversion_mem_perpBisector_inversion_iff (hR : R ≠ 0) (hx : x ≠ c) (hy : y ≠ c) :\n    inversion c R x ∈ perpBisector c (inversion c R y) ↔ dist x y = dist y c := by\n  rw [mem_perpBisector_iff_dist_eq, dist_inversion_inversion hx hy, dist_inversion_center]\n  have hx' := dist_ne_zero.2 hx\n  have hy' := dist_ne_zero.2 hy\n  -- takes 300ms, but the \"equivalent\" simp call fails -> hard to speed up\n  field_simp [mul_assoc, mul_comm, hx, hx.symm, eq_comm]\n\n"}
{"name":"EuclideanGeometry.inversion_mem_perpBisector_inversion_iff'","module":"Mathlib.Geometry.Euclidean.Inversion.ImageHyperplane","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc x y : P\nR : Real\nhR : Ne R 0\nhy : Ne y c\n⊢ Iff (Membership.mem (AffineSubspace.perpBisector c (EuclideanGeometry.inversion c R y)) (EuclideanGeometry.inversion c R x)) (And (Eq (Dist.dist x y) (Dist.dist y c)) (Ne x c))","decl":"/-- The inversion with center `c` and radius `R` maps a sphere passing through the center to a\nhyperplane. -/\ntheorem inversion_mem_perpBisector_inversion_iff' (hR : R ≠ 0) (hy : y ≠ c) :\n    inversion c R x ∈ perpBisector c (inversion c R y) ↔ dist x y = dist y c ∧ x ≠ c := by\n  rcases eq_or_ne x c with rfl | hx\n  · simp [*]\n  · simp [inversion_mem_perpBisector_inversion_iff hR hx hy, hx]\n\n"}
{"name":"EuclideanGeometry.preimage_inversion_perpBisector_inversion","module":"Mathlib.Geometry.Euclidean.Inversion.ImageHyperplane","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc y : P\nR : Real\nhR : Ne R 0\nhy : Ne y c\n⊢ Eq (Set.preimage (EuclideanGeometry.inversion c R) ↑(AffineSubspace.perpBisector c (EuclideanGeometry.inversion c R y))) (SDiff.sdiff (Metric.sphere y (Dist.dist y c)) (Singleton.singleton c))","decl":"theorem preimage_inversion_perpBisector_inversion (hR : R ≠ 0) (hy : y ≠ c) :\n    inversion c R ⁻¹' perpBisector c (inversion c R y) = sphere y (dist y c) \\ {c} :=\n  Set.ext fun _ ↦ inversion_mem_perpBisector_inversion_iff' hR hy\n\n"}
{"name":"EuclideanGeometry.preimage_inversion_perpBisector","module":"Mathlib.Geometry.Euclidean.Inversion.ImageHyperplane","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc y : P\nR : Real\nhR : Ne R 0\nhy : Ne y c\n⊢ Eq (Set.preimage (EuclideanGeometry.inversion c R) ↑(AffineSubspace.perpBisector c y)) (SDiff.sdiff (Metric.sphere (EuclideanGeometry.inversion c R y) (HDiv.hDiv (HPow.hPow R 2) (Dist.dist y c))) (Singleton.singleton c))","decl":"theorem preimage_inversion_perpBisector (hR : R ≠ 0) (hy : y ≠ c) :\n    inversion c R ⁻¹' perpBisector c y = sphere (inversion c R y) (R ^ 2 / dist y c) \\ {c} := by\n  rw [← dist_inversion_center, ← preimage_inversion_perpBisector_inversion hR,\n    inversion_inversion] <;> simp [*]\n\n"}
{"name":"EuclideanGeometry.image_inversion_perpBisector","module":"Mathlib.Geometry.Euclidean.Inversion.ImageHyperplane","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc y : P\nR : Real\nhR : Ne R 0\nhy : Ne y c\n⊢ Eq (Set.image (EuclideanGeometry.inversion c R) ↑(AffineSubspace.perpBisector c y)) (SDiff.sdiff (Metric.sphere (EuclideanGeometry.inversion c R y) (HDiv.hDiv (HPow.hPow R 2) (Dist.dist y c))) (Singleton.singleton c))","decl":"theorem image_inversion_perpBisector (hR : R ≠ 0) (hy : y ≠ c) :\n    inversion c R '' perpBisector c y = sphere (inversion c R y) (R ^ 2 / dist y c) \\ {c} := by\n  rw [image_eq_preimage_of_inverse (inversion_involutive _ hR) (inversion_involutive _ hR),\n    preimage_inversion_perpBisector hR hy]\n\n"}
{"name":"EuclideanGeometry.preimage_inversion_sphere_dist_center","module":"Mathlib.Geometry.Euclidean.Inversion.ImageHyperplane","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc y : P\nR : Real\nhR : Ne R 0\nhy : Ne y c\n⊢ Eq (Set.preimage (EuclideanGeometry.inversion c R) (Metric.sphere y (Dist.dist y c))) (Insert.insert c ↑(AffineSubspace.perpBisector c (EuclideanGeometry.inversion c R y)))","decl":"theorem preimage_inversion_sphere_dist_center (hR : R ≠ 0) (hy : y ≠ c) :\n    inversion c R ⁻¹' sphere y (dist y c) =\n      insert c (perpBisector c (inversion c R y) : Set P) := by\n  ext x\n  rcases eq_or_ne x c with rfl | hx; · simp [dist_comm]\n  rw [mem_preimage, mem_sphere, ← inversion_mem_perpBisector_inversion_iff hR] <;> simp [*]\n\n"}
{"name":"EuclideanGeometry.image_inversion_sphere_dist_center","module":"Mathlib.Geometry.Euclidean.Inversion.ImageHyperplane","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc y : P\nR : Real\nhR : Ne R 0\nhy : Ne y c\n⊢ Eq (Set.image (EuclideanGeometry.inversion c R) (Metric.sphere y (Dist.dist y c))) (Insert.insert c ↑(AffineSubspace.perpBisector c (EuclideanGeometry.inversion c R y)))","decl":"theorem image_inversion_sphere_dist_center (hR : R ≠ 0) (hy : y ≠ c) :\n    inversion c R '' sphere y (dist y c) = insert c (perpBisector c (inversion c R y) : Set P) := by\n  rw [image_eq_preimage_of_inverse (inversion_involutive _ hR) (inversion_involutive _ hR),\n    preimage_inversion_sphere_dist_center hR hy]\n\n"}
{"name":"EuclideanGeometry.mapsTo_inversion_affineSubspace_of_mem","module":"Mathlib.Geometry.Euclidean.Inversion.ImageHyperplane","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc : P\nR : Real\np : AffineSubspace Real P\nhp : Membership.mem p c\n⊢ Set.MapsTo (EuclideanGeometry.inversion c R) ↑p ↑p","decl":"/-- Inversion sends an affine subspace passing through the center to itself. -/\ntheorem mapsTo_inversion_affineSubspace_of_mem {p : AffineSubspace ℝ P} (hp : c ∈ p) :\n    MapsTo (inversion c R) p p := fun _ ↦ AffineMap.lineMap_mem _ hp\n\n"}
{"name":"EuclideanGeometry.image_inversion_affineSubspace_of_mem","module":"Mathlib.Geometry.Euclidean.Inversion.ImageHyperplane","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc : P\nR : Real\np : AffineSubspace Real P\nhR : Ne R 0\nhp : Membership.mem p c\n⊢ Eq (Set.image (EuclideanGeometry.inversion c R) ↑p) ↑p","decl":"/-- Inversion sends an affine subspace passing through the center to itself. -/\ntheorem image_inversion_affineSubspace_of_mem {p : AffineSubspace ℝ P} (hR : R ≠ 0) (hp : c ∈ p) :\n    inversion c R '' p = p :=\n  (mapsTo_inversion_affineSubspace_of_mem hp).image_subset.antisymm fun x hx ↦\n    ⟨inversion c R x, mapsTo_inversion_affineSubspace_of_mem hp hx, inversion_inversion _ hR _⟩\n\n"}
