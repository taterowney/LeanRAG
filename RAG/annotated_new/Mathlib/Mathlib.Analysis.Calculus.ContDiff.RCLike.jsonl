{"name":"HasFTaylorSeriesUpToOn.hasStrictFDerivAt","module":"Mathlib.Analysis.Calculus.ContDiff.RCLike","initialProofState":"ğ•‚ : Type u_1\ninstâœâ´ : RCLike ğ•‚\nE' : Type u_2\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ğ•‚ E'\nF' : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace ğ•‚ F'\nn : WithTop ENat\ns : Set E'\nf : E' â†’ F'\nx : E'\np : E' â†’ FormalMultilinearSeries ğ•‚ E' F'\nhf : HasFTaylorSeriesUpToOn n f p s\nhn : LE.le 1 n\nhs : Membership.mem (nhds x) s\nâŠ¢ HasStrictFDerivAt f ((continuousMultilinearCurryFin1 ğ•‚ E' F') (p x 1)) x","decl":"/-- If a function has a Taylor series at order at least 1, then at points in the interior of the\n    domain of definition, the term of order 1 of this series is a strict derivative of `f`. -/\ntheorem HasFTaylorSeriesUpToOn.hasStrictFDerivAt {n : WithTop â„•âˆ}\n    {s : Set E'} {f : E' â†’ F'} {x : E'}\n    {p : E' â†’ FormalMultilinearSeries ğ•‚ E' F'} (hf : HasFTaylorSeriesUpToOn n f p s) (hn : 1 â‰¤ n)\n    (hs : s âˆˆ ğ“ x) : HasStrictFDerivAt f ((continuousMultilinearCurryFin1 ğ•‚ E' F') (p x 1)) x :=\n  hasStrictFDerivAt_of_hasFDerivAt_of_continuousAt (hf.eventually_hasFDerivAt hn hs) <|\n    (continuousMultilinearCurryFin1 ğ•‚ E' F').continuousAt.comp <| (hf.cont 1 hn).continuousAt hs\n\n"}
{"name":"ContDiffAt.hasStrictFDerivAt'","module":"Mathlib.Analysis.Calculus.ContDiff.RCLike","initialProofState":"n : WithTop ENat\nğ•‚ : Type u_1\ninstâœâ´ : RCLike ğ•‚\nE' : Type u_2\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ğ•‚ E'\nF' : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace ğ•‚ F'\nf : E' â†’ F'\nf' : ContinuousLinearMap (RingHom.id ğ•‚) E' F'\nx : E'\nhf : ContDiffAt ğ•‚ n f x\nhf' : HasFDerivAt f f' x\nhn : LE.le 1 n\nâŠ¢ HasStrictFDerivAt f f' x","decl":"/-- If a function is `C^n` with `1 â‰¤ n` around a point, and its derivative at that point is given to\nus as `f'`, then `f'` is also a strict derivative. -/\ntheorem ContDiffAt.hasStrictFDerivAt' {f : E' â†’ F'} {f' : E' â†’L[ğ•‚] F'} {x : E'}\n    (hf : ContDiffAt ğ•‚ n f x) (hf' : HasFDerivAt f f' x) (hn : 1 â‰¤ n) :\n    HasStrictFDerivAt f f' x := by\n  rcases hf.of_le hn 1 le_rfl with âŸ¨u, H, p, hpâŸ©\n  simp only [nhdsWithin_univ, mem_univ, insert_eq_of_mem] at H\n  have := hp.hasStrictFDerivAt le_rfl H\n  rwa [hf'.unique this.hasFDerivAt]\n\n"}
{"name":"ContDiffAt.hasStrictDerivAt'","module":"Mathlib.Analysis.Calculus.ContDiff.RCLike","initialProofState":"n : WithTop ENat\nğ•‚ : Type u_1\ninstâœÂ² : RCLike ğ•‚\nF' : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace ğ•‚ F'\nf : ğ•‚ â†’ F'\nf' : F'\nx : ğ•‚\nhf : ContDiffAt ğ•‚ n f x\nhf' : HasDerivAt f f' x\nhn : LE.le 1 n\nâŠ¢ HasStrictDerivAt f f' x","decl":"/-- If a function is `C^n` with `1 â‰¤ n` around a point, and its derivative at that point is given to\nus as `f'`, then `f'` is also a strict derivative. -/\ntheorem ContDiffAt.hasStrictDerivAt' {f : ğ•‚ â†’ F'} {f' : F'} {x : ğ•‚} (hf : ContDiffAt ğ•‚ n f x)\n    (hf' : HasDerivAt f f' x) (hn : 1 â‰¤ n) : HasStrictDerivAt f f' x :=\n  hf.hasStrictFDerivAt' hf' hn\n\n"}
{"name":"ContDiffAt.hasStrictFDerivAt","module":"Mathlib.Analysis.Calculus.ContDiff.RCLike","initialProofState":"n : WithTop ENat\nğ•‚ : Type u_1\ninstâœâ´ : RCLike ğ•‚\nE' : Type u_2\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ğ•‚ E'\nF' : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace ğ•‚ F'\nf : E' â†’ F'\nx : E'\nhf : ContDiffAt ğ•‚ n f x\nhn : LE.le 1 n\nâŠ¢ HasStrictFDerivAt f (fderiv ğ•‚ f x) x","decl":"/-- If a function is `C^n` with `1 â‰¤ n` around a point, then the derivative of `f` at this point\nis also a strict derivative. -/\ntheorem ContDiffAt.hasStrictFDerivAt {f : E' â†’ F'} {x : E'} (hf : ContDiffAt ğ•‚ n f x) (hn : 1 â‰¤ n) :\n    HasStrictFDerivAt f (fderiv ğ•‚ f x) x :=\n  hf.hasStrictFDerivAt' (hf.differentiableAt hn).hasFDerivAt hn\n\n"}
{"name":"ContDiffAt.hasStrictDerivAt","module":"Mathlib.Analysis.Calculus.ContDiff.RCLike","initialProofState":"n : WithTop ENat\nğ•‚ : Type u_1\ninstâœÂ² : RCLike ğ•‚\nF' : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace ğ•‚ F'\nf : ğ•‚ â†’ F'\nx : ğ•‚\nhf : ContDiffAt ğ•‚ n f x\nhn : LE.le 1 n\nâŠ¢ HasStrictDerivAt f (deriv f x) x","decl":"/-- If a function is `C^n` with `1 â‰¤ n` around a point, then the derivative of `f` at this point\nis also a strict derivative. -/\ntheorem ContDiffAt.hasStrictDerivAt {f : ğ•‚ â†’ F'} {x : ğ•‚} (hf : ContDiffAt ğ•‚ n f x) (hn : 1 â‰¤ n) :\n    HasStrictDerivAt f (deriv f x) x :=\n  (hf.hasStrictFDerivAt hn).hasStrictDerivAt\n\n"}
{"name":"ContDiff.hasStrictFDerivAt","module":"Mathlib.Analysis.Calculus.ContDiff.RCLike","initialProofState":"n : WithTop ENat\nğ•‚ : Type u_1\ninstâœâ´ : RCLike ğ•‚\nE' : Type u_2\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ğ•‚ E'\nF' : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace ğ•‚ F'\nf : E' â†’ F'\nx : E'\nhf : ContDiff ğ•‚ n f\nhn : LE.le 1 n\nâŠ¢ HasStrictFDerivAt f (fderiv ğ•‚ f x) x","decl":"/-- If a function is `C^n` with `1 â‰¤ n`, then the derivative of `f` is also a strict derivative. -/\ntheorem ContDiff.hasStrictFDerivAt {f : E' â†’ F'} {x : E'} (hf : ContDiff ğ•‚ n f) (hn : 1 â‰¤ n) :\n    HasStrictFDerivAt f (fderiv ğ•‚ f x) x :=\n  hf.contDiffAt.hasStrictFDerivAt hn\n\n"}
{"name":"ContDiff.hasStrictDerivAt","module":"Mathlib.Analysis.Calculus.ContDiff.RCLike","initialProofState":"n : WithTop ENat\nğ•‚ : Type u_1\ninstâœÂ² : RCLike ğ•‚\nF' : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace ğ•‚ F'\nf : ğ•‚ â†’ F'\nx : ğ•‚\nhf : ContDiff ğ•‚ n f\nhn : LE.le 1 n\nâŠ¢ HasStrictDerivAt f (deriv f x) x","decl":"/-- If a function is `C^n` with `1 â‰¤ n`, then the derivative of `f` is also a strict derivative. -/\ntheorem ContDiff.hasStrictDerivAt {f : ğ•‚ â†’ F'} {x : ğ•‚} (hf : ContDiff ğ•‚ n f) (hn : 1 â‰¤ n) :\n    HasStrictDerivAt f (deriv f x) x :=\n  hf.contDiffAt.hasStrictDerivAt hn\n\n"}
{"name":"HasFTaylorSeriesUpToOn.exists_lipschitzOnWith_of_nnnorm_lt","module":"Mathlib.Analysis.Calculus.ContDiff.RCLike","initialProofState":"E : Type u_4\nF : Type u_5\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : E â†’ F\np : E â†’ FormalMultilinearSeries Real E F\ns : Set E\nx : E\nhf : HasFTaylorSeriesUpToOn 1 f p (Insert.insert x s)\nhs : Convex Real s\nK : NNReal\nhK : LT.lt (NNNorm.nnnorm (p x 1)) K\nâŠ¢ Exists fun t => And (Membership.mem (nhdsWithin x s) t) (LipschitzOnWith K f t)","decl":"/-- If `f` has a formal Taylor series `p` up to order `1` on `{x} âˆª s`, where `s` is a convex set,\nand `â€–p x 1â€–â‚Š < K`, then `f` is `K`-Lipschitz in a neighborhood of `x` within `s`. -/\ntheorem HasFTaylorSeriesUpToOn.exists_lipschitzOnWith_of_nnnorm_lt {E F : Type*}\n    [NormedAddCommGroup E] [NormedSpace â„ E] [NormedAddCommGroup F] [NormedSpace â„ F] {f : E â†’ F}\n    {p : E â†’ FormalMultilinearSeries â„ E F} {s : Set E} {x : E}\n    (hf : HasFTaylorSeriesUpToOn 1 f p (insert x s)) (hs : Convex â„ s) (K : â„â‰¥0)\n    (hK : â€–p x 1â€–â‚Š < K) : âˆƒ t âˆˆ ğ“[s] x, LipschitzOnWith K f t := by\n  set f' := fun y => continuousMultilinearCurryFin1 â„ E F (p y 1)\n  have hder : âˆ€ y âˆˆ s, HasFDerivWithinAt f (f' y) s y := fun y hy =>\n    (hf.hasFDerivWithinAt le_rfl (subset_insert x s hy)).mono (subset_insert x s)\n  have hcont : ContinuousWithinAt f' s x :=\n    (continuousMultilinearCurryFin1 â„ E F).continuousAt.comp_continuousWithinAt\n      ((hf.cont _ le_rfl _ (mem_insert _ _)).mono (subset_insert x s))\n  replace hK : â€–f' xâ€–â‚Š < K := by simpa only [f', LinearIsometryEquiv.nnnorm_map]\n  exact\n    hs.exists_nhdsWithin_lipschitzOnWith_of_hasFDerivWithinAt_of_nnnorm_lt\n      (eventually_nhdsWithin_iff.2 <| Eventually.of_forall hder) hcont K hK\n\n"}
{"name":"HasFTaylorSeriesUpToOn.exists_lipschitzOnWith","module":"Mathlib.Analysis.Calculus.ContDiff.RCLike","initialProofState":"E : Type u_4\nF : Type u_5\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : E â†’ F\np : E â†’ FormalMultilinearSeries Real E F\ns : Set E\nx : E\nhf : HasFTaylorSeriesUpToOn 1 f p (Insert.insert x s)\nhs : Convex Real s\nâŠ¢ Exists fun K => Exists fun t => And (Membership.mem (nhdsWithin x s) t) (LipschitzOnWith K f t)","decl":"/-- If `f` has a formal Taylor series `p` up to order `1` on `{x} âˆª s`, where `s` is a convex set,\nthen `f` is Lipschitz in a neighborhood of `x` within `s`. -/\ntheorem HasFTaylorSeriesUpToOn.exists_lipschitzOnWith {E F : Type*} [NormedAddCommGroup E]\n    [NormedSpace â„ E] [NormedAddCommGroup F] [NormedSpace â„ F] {f : E â†’ F}\n    {p : E â†’ FormalMultilinearSeries â„ E F} {s : Set E} {x : E}\n    (hf : HasFTaylorSeriesUpToOn 1 f p (insert x s)) (hs : Convex â„ s) :\n    âˆƒ K, âˆƒ t âˆˆ ğ“[s] x, LipschitzOnWith K f t :=\n  (exists_gt _).imp <| hf.exists_lipschitzOnWith_of_nnnorm_lt hs\n\n"}
{"name":"ContDiffWithinAt.exists_lipschitzOnWith","module":"Mathlib.Analysis.Calculus.ContDiff.RCLike","initialProofState":"E : Type u_4\nF : Type u_5\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : E â†’ F\ns : Set E\nx : E\nhf : ContDiffWithinAt Real 1 f s x\nhs : Convex Real s\nâŠ¢ Exists fun K => Exists fun t => And (Membership.mem (nhdsWithin x s) t) (LipschitzOnWith K f t)","decl":"/-- If `f` is `C^1` within a convex set `s` at `x`, then it is Lipschitz on a neighborhood of `x`\nwithin `s`. -/\ntheorem ContDiffWithinAt.exists_lipschitzOnWith {E F : Type*} [NormedAddCommGroup E]\n    [NormedSpace â„ E] [NormedAddCommGroup F] [NormedSpace â„ F] {f : E â†’ F} {s : Set E} {x : E}\n    (hf : ContDiffWithinAt â„ 1 f s x) (hs : Convex â„ s) :\n    âˆƒ K : â„â‰¥0, âˆƒ t âˆˆ ğ“[s] x, LipschitzOnWith K f t := by\n  rcases hf 1 le_rfl with âŸ¨t, hst, p, hpâŸ©\n  rcases Metric.mem_nhdsWithin_iff.mp hst with âŸ¨Îµ, Îµ0, hÎµâŸ©\n  replace hp : HasFTaylorSeriesUpToOn 1 f p (Metric.ball x Îµ âˆ© insert x s) := hp.mono hÎµ\n  clear hst hÎµ t\n  rw [â† insert_eq_of_mem (Metric.mem_ball_self Îµ0), â† insert_inter_distrib] at hp\n  rcases hp.exists_lipschitzOnWith ((convex_ball _ _).inter hs) with âŸ¨K, t, hst, hftâŸ©\n  rw [inter_comm, â† nhdsWithin_restrict' _ (Metric.ball_mem_nhds _ Îµ0)] at hst\n  exact âŸ¨K, t, hst, hftâŸ©\n\n"}
{"name":"ContDiffAt.exists_lipschitzOnWith_of_nnnorm_lt","module":"Mathlib.Analysis.Calculus.ContDiff.RCLike","initialProofState":"ğ•‚ : Type u_1\ninstâœâ´ : RCLike ğ•‚\nE' : Type u_2\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ğ•‚ E'\nF' : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace ğ•‚ F'\nf : E' â†’ F'\nx : E'\nhf : ContDiffAt ğ•‚ 1 f x\nK : NNReal\nhK : LT.lt (NNNorm.nnnorm (fderiv ğ•‚ f x)) K\nâŠ¢ Exists fun t => And (Membership.mem (nhds x) t) (LipschitzOnWith K f t)","decl":"/-- If `f` is `C^1` at `x` and `K > â€–fderiv ğ•‚ f xâ€–`, then `f` is `K`-Lipschitz in a neighborhood of\n`x`. -/\ntheorem ContDiffAt.exists_lipschitzOnWith_of_nnnorm_lt {f : E' â†’ F'} {x : E'}\n    (hf : ContDiffAt ğ•‚ 1 f x) (K : â„â‰¥0) (hK : â€–fderiv ğ•‚ f xâ€–â‚Š < K) :\n    âˆƒ t âˆˆ ğ“ x, LipschitzOnWith K f t :=\n  (hf.hasStrictFDerivAt le_rfl).exists_lipschitzOnWith_of_nnnorm_lt K hK\n\n"}
{"name":"ContDiffAt.exists_lipschitzOnWith","module":"Mathlib.Analysis.Calculus.ContDiff.RCLike","initialProofState":"ğ•‚ : Type u_1\ninstâœâ´ : RCLike ğ•‚\nE' : Type u_2\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ğ•‚ E'\nF' : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace ğ•‚ F'\nf : E' â†’ F'\nx : E'\nhf : ContDiffAt ğ•‚ 1 f x\nâŠ¢ Exists fun K => Exists fun t => And (Membership.mem (nhds x) t) (LipschitzOnWith K f t)","decl":"/-- If `f` is `C^1` at `x`, then `f` is Lipschitz in a neighborhood of `x`. -/\ntheorem ContDiffAt.exists_lipschitzOnWith {f : E' â†’ F'} {x : E'} (hf : ContDiffAt ğ•‚ 1 f x) :\n    âˆƒ K, âˆƒ t âˆˆ ğ“ x, LipschitzOnWith K f t :=\n  (hf.hasStrictFDerivAt le_rfl).exists_lipschitzOnWith\n\n"}
{"name":"ContDiff.locallyLipschitz","module":"Mathlib.Analysis.Calculus.ContDiff.RCLike","initialProofState":"ğ•‚ : Type u_1\ninstâœâ´ : RCLike ğ•‚\nE' : Type u_2\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ğ•‚ E'\nF' : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace ğ•‚ F'\nf : E' â†’ F'\nhf : ContDiff ğ•‚ 1 f\nâŠ¢ LocallyLipschitz f","decl":"/-- If `f` is `C^1`, it is locally Lipschitz. -/\nlemma ContDiff.locallyLipschitz {f : E' â†’ F'} (hf : ContDiff ğ•‚ 1 f) : LocallyLipschitz f := by\n  intro x\n  rcases hf.contDiffAt.exists_lipschitzOnWith with âŸ¨K, t, ht, hfâŸ©\n  use K, t\n\n"}
{"name":"ContDiff.lipschitzWith_of_hasCompactSupport","module":"Mathlib.Analysis.Calculus.ContDiff.RCLike","initialProofState":"n : WithTop ENat\nğ•‚ : Type u_1\ninstâœâ´ : RCLike ğ•‚\nE' : Type u_2\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ğ•‚ E'\nF' : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace ğ•‚ F'\nf : E' â†’ F'\nhf : HasCompactSupport f\nh'f : ContDiff ğ•‚ n f\nhn : LE.le 1 n\nâŠ¢ Exists fun C => LipschitzWith C f","decl":"/-- A `C^1` function with compact support is Lipschitz. -/\ntheorem ContDiff.lipschitzWith_of_hasCompactSupport {f : E' â†’ F'}\n    (hf : HasCompactSupport f) (h'f : ContDiff ğ•‚ n f) (hn : 1 â‰¤ n) :\n    âˆƒ C, LipschitzWith C f := by\n  obtain âŸ¨C, hCâŸ© := (hf.fderiv ğ•‚).exists_bound_of_continuous (h'f.continuous_fderiv hn)\n  refine âŸ¨âŸ¨max C 0, le_max_right _ _âŸ©, ?_âŸ©\n  apply lipschitzWith_of_nnnorm_fderiv_le (h'f.differentiable hn) (fun x â†¦ ?_)\n  simp [â† NNReal.coe_le_coe, hC x]\n\n"}
