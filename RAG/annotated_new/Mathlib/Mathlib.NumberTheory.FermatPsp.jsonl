{"name":"Nat.coprime_of_probablePrime","module":"Mathlib.NumberTheory.FermatPsp","initialProofState":"n b : Nat\nh : n.ProbablePrime b\nh₁ : LE.le 1 n\nh₂ : LE.le 1 b\n⊢ n.Coprime b","decl":"/-- If `n` passes the Fermat primality test to base `b`, then `n` is coprime with `b`, assuming that\n`n` and `b` are both positive.\n-/\ntheorem coprime_of_probablePrime {n b : ℕ} (h : ProbablePrime n b) (h₁ : 1 ≤ n) (h₂ : 1 ≤ b) :\n    Nat.Coprime n b := by\n  by_cases h₃ : 2 ≤ n\n  · -- To prove that `n` is coprime with `b`, we need to show that for all prime factors of `n`,\n    -- we can derive a contradiction if `n` divides `b`.\n    apply Nat.coprime_of_dvd\n    -- If `k` is a prime number that divides both `n` and `b`, then we know that `n = m * k` and\n    -- `b = j * k` for some natural numbers `m` and `j`. We substitute these into the hypothesis.\n    rintro k hk ⟨m, rfl⟩ ⟨j, rfl⟩\n    -- Because prime numbers do not divide 1, it suffices to show that `k ∣ 1` to prove a\n    -- contradiction\n    apply Nat.Prime.not_dvd_one hk\n    -- Since `n` divides `b ^ (n - 1) - 1`, `k` also divides `b ^ (n - 1) - 1`\n    replace h := dvd_of_mul_right_dvd h\n    -- Because `k` divides `b ^ (n - 1) - 1`, if we can show that `k` also divides `b ^ (n - 1)`,\n    -- then we know `k` divides 1.\n    rw [Nat.dvd_add_iff_right h, Nat.sub_add_cancel (Nat.one_le_pow _ _ h₂)]\n    -- Since `k` divides `b`, `k` also divides any power of `b` except `b ^ 0`. Therefore, it\n    -- suffices to show that `n - 1` isn't zero. However, we know that `n - 1` isn't zero because we\n    -- assumed `2 ≤ n` when doing `by_cases`.\n    refine dvd_of_mul_right_dvd (dvd_pow_self (k * j) ?_)\n    omega\n  -- If `n = 1`, then it follows trivially that `n` is coprime with `b`.\n  · rw [show n = 1 by omega]\n    norm_num\n\n"}
{"name":"Nat.probablePrime_iff_modEq","module":"Mathlib.NumberTheory.FermatPsp","initialProofState":"n b : Nat\nh : LE.le 1 b\n⊢ Iff (n.ProbablePrime b) (n.ModEq (HPow.hPow b (HSub.hSub n 1)) 1)","decl":"theorem probablePrime_iff_modEq (n : ℕ) {b : ℕ} (h : 1 ≤ b) :\n    ProbablePrime n b ↔ b ^ (n - 1) ≡ 1 [MOD n] := by\n  have : 1 ≤ b ^ (n - 1) := one_le_pow₀ h\n  -- For exact mod_cast\n  rw [Nat.ModEq.comm]\n  constructor\n  · intro h₁\n    apply Nat.modEq_of_dvd\n    exact mod_cast h₁\n  · intro h₁\n    exact mod_cast Nat.ModEq.dvd h₁\n\n"}
{"name":"Nat.coprime_of_fermatPsp","module":"Mathlib.NumberTheory.FermatPsp","initialProofState":"n b : Nat\nh : n.FermatPsp b\nh₁ : LE.le 1 b\n⊢ n.Coprime b","decl":"/-- If `n` is a Fermat pseudoprime to base `b`, then `n` is coprime with `b`, assuming that `b` is\npositive.\n\nThis lemma is a small wrapper based on `coprime_of_probablePrime`\n-/\ntheorem coprime_of_fermatPsp {n b : ℕ} (h : FermatPsp n b) (h₁ : 1 ≤ b) : Nat.Coprime n b := by\n  rcases h with ⟨hp, _, hn₂⟩\n  exact coprime_of_probablePrime hp (by omega) h₁\n\n"}
{"name":"Nat.fermatPsp_base_one","module":"Mathlib.NumberTheory.FermatPsp","initialProofState":"n : Nat\nh₁ : LT.lt 1 n\nh₂ : Not (Nat.Prime n)\n⊢ n.FermatPsp 1","decl":"/-- All composite numbers are Fermat pseudoprimes to base 1.\n-/\ntheorem fermatPsp_base_one {n : ℕ} (h₁ : 1 < n) (h₂ : ¬n.Prime) : FermatPsp n 1 := by\n  refine ⟨show n ∣ 1 ^ (n - 1) - 1 from ?_, h₂, h₁⟩\n  exact show 0 = 1 ^ (n - 1) - 1 by norm_num ▸ dvd_zero n\n\n-- Lemmas that are needed to prove statements in this file, but aren't directly related to Fermat\n-- pseudoprimes\n"}
{"name":"Nat.exists_infinite_pseudoprimes","module":"Mathlib.NumberTheory.FermatPsp","initialProofState":"b : Nat\nh : LE.le 1 b\nm : Nat\n⊢ Exists fun n => And (n.FermatPsp b) (LE.le m n)","decl":"/-- For all positive bases, there exist infinite **Fermat pseudoprimes** to that base.\nGiven in this form: for all numbers `b ≥ 1` and `m`, there exists a pseudoprime `n` to base `b` such\nthat `m ≤ n`. This form is similar to `Nat.exists_infinite_primes`.\n-/\ntheorem exists_infinite_pseudoprimes {b : ℕ} (h : 1 ≤ b) (m : ℕ) :\n    ∃ n : ℕ, FermatPsp n b ∧ m ≤ n := by\n  by_cases b_ge_two : 2 ≤ b\n  -- If `2 ≤ b`, then because there exist infinite prime numbers, there is a prime number p with\n  -- `m ≤ p` and `¬p ∣ b*(b^2 - 1)`. We pick a prime number `b*(b^2 - 1) + 1 + m ≤ p` because we\n  -- automatically know that `p` is greater than m and that it does not divide `b*(b^2 - 1)`\n  -- (because `p` can't divide a number less than `p`).\n  -- From `p`, we can use the lemmas we proved earlier to show that\n  -- `((b^p - 1)/(b - 1)) * ((b^p + 1)/(b + 1))` is a pseudoprime to base `b`.\n  · have h := Nat.exists_infinite_primes (b * (b ^ 2 - 1) + 1 + m)\n    cases' h with p hp\n    cases' hp with hp₁ hp₂\n    have h₁ : 0 < b := pos_of_gt (Nat.succ_le_iff.mp b_ge_two)\n    have h₂ : 4 ≤ b ^ 2 := pow_le_pow_left' b_ge_two 2\n    have h₃ : 0 < b ^ 2 - 1 := tsub_pos_of_lt (gt_of_ge_of_gt h₂ (by norm_num))\n    have h₄ : 0 < b * (b ^ 2 - 1) := mul_pos h₁ h₃\n    have h₅ : b * (b ^ 2 - 1) < p := by omega\n    have h₆ : ¬p ∣ b * (b ^ 2 - 1) := Nat.not_dvd_of_pos_of_lt h₄ h₅\n    have h₇ : b ≤ b * (b ^ 2 - 1) := Nat.le_mul_of_pos_right _ h₃\n    have h₈ : 2 ≤ b * (b ^ 2 - 1) := le_trans b_ge_two h₇\n    have h₉ : 2 < p := gt_of_gt_of_ge h₅ h₈\n    have h₁₀ := psp_from_prime_gt_p b_ge_two hp₂ h₉\n    use psp_from_prime b p\n    constructor\n    · exact psp_from_prime_psp b_ge_two hp₂ h₉ h₆\n    · exact le_trans (show m ≤ p by omega) (le_of_lt h₁₀)\n  -- If `¬2 ≤ b`, then `b = 1`. Since all composite numbers are pseudoprimes to base 1, we can pick\n  -- any composite number greater than m. We choose `2 * (m + 2)` because it is greater than `m` and\n  -- is composite for all natural numbers `m`.\n  · have h₁ : b = 1 := by omega\n    rw [h₁]\n    use 2 * (m + 2)\n    have : ¬Nat.Prime (2 * (m + 2)) := Nat.not_prime_mul (by omega) (by omega)\n    exact ⟨fermatPsp_base_one (by omega) this, by omega⟩\n\n"}
{"name":"Nat.frequently_atTop_fermatPsp","module":"Mathlib.NumberTheory.FermatPsp","initialProofState":"b : Nat\nh : LE.le 1 b\n⊢ Filter.Frequently (fun n => n.FermatPsp b) Filter.atTop","decl":"theorem frequently_atTop_fermatPsp {b : ℕ} (h : 1 ≤ b) : ∃ᶠ n in Filter.atTop, FermatPsp n b := by\n  -- Based on the proof of `Nat.frequently_atTop_modEq_one`\n  refine Filter.frequently_atTop.2 fun n => ?_\n  obtain ⟨p, hp⟩ := exists_infinite_pseudoprimes h n\n  exact ⟨p, hp.2, hp.1⟩\n\n"}
{"name":"Nat.infinite_setOf_pseudoprimes","module":"Mathlib.NumberTheory.FermatPsp","initialProofState":"b : Nat\nh : LE.le 1 b\n⊢ (setOf fun n => n.FermatPsp b).Infinite","decl":"/-- Infinite set variant of `Nat.exists_infinite_pseudoprimes`\n-/\ntheorem infinite_setOf_pseudoprimes {b : ℕ} (h : 1 ≤ b) :\n    Set.Infinite { n : ℕ | FermatPsp n b } :=\n  Nat.frequently_atTop_iff_infinite.mp (frequently_atTop_fermatPsp h)\n\n"}
