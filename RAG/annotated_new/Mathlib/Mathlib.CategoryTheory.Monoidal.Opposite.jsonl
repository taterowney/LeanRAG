{"name":"CategoryTheory.MonoidalOpposite.mop.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : SizeOf C\nunmop : C\n‚ä¢ Eq (SizeOf.sizeOf { unmop := unmop }) (HAdd.hAdd 1 (SizeOf.sizeOf unmop))","decl":"/-- The type of objects of the opposite (or \"reverse\") monoidal category.\nUse the notation `C·¥π·µí·µñ`. -/\nstructure MonoidalOpposite (C : Type u‚ÇÅ) where\n  /-- The object of `MonoidalOpposite C` that represents `x : C`. -/ mop ::\n  /-- The object of `C` represented by `x : MonoidalOpposite C`. -/ unmop : C\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.mop.injEq","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\nunmop‚úù unmop : C\n‚ä¢ Eq (Eq { unmop := unmop‚úù } { unmop := unmop }) (Eq unmop‚úù unmop)","decl":"/-- The type of objects of the opposite (or \"reverse\") monoidal category.\nUse the notation `C·¥π·µí·µñ`. -/\nstructure MonoidalOpposite (C : Type u‚ÇÅ) where\n  /-- The object of `MonoidalOpposite C` that represents `x : C`. -/ mop ::\n  /-- The object of `C` represented by `x : MonoidalOpposite C`. -/ unmop : C\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.mop.inj","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\nunmop‚úù unmop : C\nx‚úù : Eq { unmop := unmop‚úù } { unmop := unmop }\n‚ä¢ Eq unmop‚úù unmop","decl":"/-- The type of objects of the opposite (or \"reverse\") monoidal category.\nUse the notation `C·¥π·µí·µñ`. -/\nstructure MonoidalOpposite (C : Type u‚ÇÅ) where\n  /-- The object of `MonoidalOpposite C` that represents `x : C`. -/ mop ::\n  /-- The object of `C` represented by `x : MonoidalOpposite C`. -/ unmop : C\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.mop_injective","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\n‚ä¢ Function.Injective CategoryTheory.MonoidalOpposite.mop","decl":"theorem mop_injective : Function.Injective (mop : C ‚Üí C·¥π·µí·µñ) := @mop.inj C\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.unmop_injective","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\n‚ä¢ Function.Injective CategoryTheory.MonoidalOpposite.unmop","decl":"theorem unmop_injective : Function.Injective (unmop : C·¥π·µí·µñ ‚Üí C) :=\n  fun _ _ h => congrArg mop h\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.mop_inj_iff","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\nx y : C\n‚ä¢ Iff (Eq { unmop := x } { unmop := y }) (Eq x y)","decl":"theorem mop_inj_iff (x y : C) : mop x = mop y ‚Üî x = y := mop_injective.eq_iff\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.unmop_inj_iff","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\nx y : CategoryTheory.MonoidalOpposite C\n‚ä¢ Iff (Eq x.unmop y.unmop) (Eq x y)","decl":"@[simp]\ntheorem unmop_inj_iff (x y : C·¥π·µí·µñ) : unmop x = unmop y ‚Üî x = y := unmop_injective.eq_iff\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.mop_unmop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\nX : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq { unmop := X.unmop } X","decl":"@[simp]\ntheorem mop_unmop (X : C·¥π·µí·µñ) : mop (unmop X) = X := rfl\n\n-- can't be simp bc after putting the lhs in whnf it's `X = X`\n"}
{"name":"CategoryTheory.MonoidalOpposite.unmop_mop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\nX : C\n‚ä¢ Eq { unmop := X }.unmop X","decl":"theorem unmop_mop (X : C) : unmop (mop X) = X := rfl\n\n"}
{"name":"Quiver.Hom.mop_inj","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\n‚ä¢ Function.Injective Quiver.Hom.mop","decl":"theorem mop_inj {X Y : C} :\n    Function.Injective (Quiver.Hom.mop : (X ‚ü∂ Y) ‚Üí (mop' X ‚ü∂ mop' Y)) :=\n  fun _ _ H => congr_arg Quiver.Hom.unmop H\n\n"}
{"name":"Quiver.Hom.unmop_inj","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : CategoryTheory.MonoidalOpposite C\n‚ä¢ Function.Injective Quiver.Hom.unmop","decl":"theorem unmop_inj {X Y : C·¥π·µí·µñ} :\n    Function.Injective (Quiver.Hom.unmop : (X ‚ü∂ Y) ‚Üí (unmop' X ‚ü∂ unmop' Y)) :=\n  fun _ _ H => congr_arg Quiver.Hom.mop H\n\n"}
{"name":"Quiver.Hom.unmop_mop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq f.mop.unmop f","decl":"@[simp]\ntheorem unmop_mop {X Y : C} {f : X ‚ü∂ Y} : f.mop.unmop = f :=\n  rfl\n\n"}
{"name":"Quiver.Hom.mop_unmop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : CategoryTheory.MonoidalOpposite C\nf : Quiver.Hom X Y\n‚ä¢ Eq f.unmop.mop f","decl":"@[simp]\ntheorem mop_unmop {X Y : C·¥π·µí·µñ} {f : X ‚ü∂ Y} : f.unmop.mop = f :=\n  rfl\n\n"}
{"name":"CategoryTheory.mop_comp","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).mop (CategoryTheory.CategoryStruct.comp f.mop g.mop)","decl":"@[simp]\ntheorem mop_comp {X Y Z : C} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} :\n    (f ‚â´ g).mop = f.mop ‚â´ g.mop := rfl\n\n"}
{"name":"CategoryTheory.mop_id","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X).mop (CategoryTheory.CategoryStruct.id { unmop := X })","decl":"@[simp]\ntheorem mop_id {X : C} : (ùüô X).mop = ùüô (mop X) := rfl\n\n"}
{"name":"CategoryTheory.unmop_comp","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : CategoryTheory.MonoidalOpposite C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).unmop (CategoryTheory.CategoryStruct.comp f.unmop g.unmop)","decl":"@[simp]\ntheorem unmop_comp {X Y Z : C·¥π·µí·µñ} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} :\n    (f ‚â´ g).unmop = f.unmop ‚â´ g.unmop := rfl\n\n"}
{"name":"CategoryTheory.unmop_id","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X).unmop (CategoryTheory.CategoryStruct.id X.unmop)","decl":"@[simp]\ntheorem unmop_id {X : C·¥π·µí·µñ} : (ùüô X).unmop = ùüô (unmop X) := rfl\n\n"}
{"name":"CategoryTheory.unmop_id_mop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id { unmop := X }).unmop (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\ntheorem unmop_id_mop {X : C} : (ùüô (mop X)).unmop = ùüô X := rfl\n\n"}
{"name":"CategoryTheory.mop_id_unmop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X.unmop).mop (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\ntheorem mop_id_unmop {X : C·¥π·µí·µñ} : (ùüô (unmop X)).mop = ùüô X := rfl\n\n"}
{"name":"CategoryTheory.mopFunctor_obj","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nunmop : C\n‚ä¢ Eq ((CategoryTheory.mopFunctor C).obj unmop) { unmop := unmop }","decl":"/-- The identity functor on `C`, viewed as a functor from `C` to its monoidal opposite. -/\n@[simps obj map] -- need to specify `obj, map` or else we generate `mopFunctor_obj_unmop`\ndef mopFunctor : C ‚•§ C·¥π·µí·µñ := Functor.mk ‚ü®mop, .mop‚ü©\n"}
{"name":"CategoryTheory.mopFunctor_map","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.mopFunctor C).map f) f.mop","decl":"/-- The identity functor on `C`, viewed as a functor from `C` to its monoidal opposite. -/\n@[simps obj map] -- need to specify `obj, map` or else we generate `mopFunctor_obj_unmop`\ndef mopFunctor : C ‚•§ C·¥π·µí·µñ := Functor.mk ‚ü®mop, .mop‚ü©\n"}
{"name":"CategoryTheory.unmopFunctor_map","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX‚úù Y‚úù : CategoryTheory.MonoidalOpposite C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.unmopFunctor C).map f) f.unmop","decl":"/-- The identity functor on `C`, viewed as a functor from the monoidal opposite of `C` to `C`. -/\n@[simps obj map] -- not necessary but the symmetry with `mopFunctor` looks nicer\ndef unmopFunctor : C·¥π·µí·µñ ‚•§ C := Functor.mk ‚ü®unmop, .unmop‚ü©\n\n"}
{"name":"CategoryTheory.unmopFunctor_obj","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nself : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq ((CategoryTheory.unmopFunctor C).obj self) self.unmop","decl":"/-- The identity functor on `C`, viewed as a functor from the monoidal opposite of `C` to `C`. -/\n@[simps obj map] -- not necessary but the symmetry with `mopFunctor` looks nicer\ndef unmopFunctor : C·¥π·µí·µñ ‚•§ C := Functor.mk ‚ü®unmop, .unmop‚ü©\n\n"}
{"name":"CategoryTheory.IsIso.instMonoidalOppositeMop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ CategoryTheory.IsIso f.mop","decl":"instance {X Y : C} (f : X ‚ü∂ Y) [IsIso f] : IsIso f.mop :=\n  (mopFunctor C).map_isIso f\n"}
{"name":"CategoryTheory.IsIso.instUnmopOfMonoidalOpposite","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : CategoryTheory.MonoidalOpposite C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ CategoryTheory.IsIso f.unmop","decl":"instance {X Y : C·¥π·µí·µñ} (f : X ‚ü∂ Y) [IsIso f] : IsIso f.unmop :=\n  (unmopFunctor C).map_isIso f\n\n"}
{"name":"CategoryTheory.op_tensorObj","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y : C\n‚ä¢ Eq { unop := CategoryTheory.MonoidalCategoryStruct.tensorObj X Y } (CategoryTheory.MonoidalCategoryStruct.tensorObj { unop := X } { unop := Y })","decl":"@[simp] lemma op_tensorObj (X Y : C) : op (X ‚äó Y) = op X ‚äó op Y := rfl\n"}
{"name":"CategoryTheory.unop_tensorObj","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y : Opposite C\n‚ä¢ Eq (Opposite.unop (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) (CategoryTheory.MonoidalCategoryStruct.tensorObj (Opposite.unop X) (Opposite.unop Y))","decl":"@[simp] lemma unop_tensorObj (X Y : C·µí·µñ) : unop (X ‚äó Y) = unop X ‚äó unop Y := rfl\n\n"}
{"name":"CategoryTheory.op_tensorUnit","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ Eq { unop := CategoryTheory.MonoidalCategoryStruct.tensorUnit } CategoryTheory.MonoidalCategoryStruct.tensorUnit","decl":"@[simp] lemma op_tensorUnit : op (ùüô_ C) = ùüô_ C·µí·µñ := rfl\n"}
{"name":"CategoryTheory.unop_tensorUnit","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ Eq (Opposite.unop CategoryTheory.MonoidalCategoryStruct.tensorUnit) CategoryTheory.MonoidalCategoryStruct.tensorUnit","decl":"@[simp] lemma unop_tensorUnit : unop (ùüô_ C·µí·µñ) = ùüô_ C := rfl\n\n"}
{"name":"CategoryTheory.op_tensorHom","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚ÇÅ Y‚ÇÅ X‚ÇÇ Y‚ÇÇ : C\nf : Quiver.Hom X‚ÇÅ Y‚ÇÅ\ng : Quiver.Hom X‚ÇÇ Y‚ÇÇ\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f g).op (CategoryTheory.MonoidalCategoryStruct.tensorHom f.op g.op)","decl":"@[simp] lemma op_tensorHom {X‚ÇÅ Y‚ÇÅ X‚ÇÇ Y‚ÇÇ : C} (f : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (g : X‚ÇÇ ‚ü∂ Y‚ÇÇ) :\n    (f ‚äó g).op = f.op ‚äó g.op := rfl\n"}
{"name":"CategoryTheory.unop_tensorHom","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚ÇÅ Y‚ÇÅ X‚ÇÇ Y‚ÇÇ : Opposite C\nf : Quiver.Hom X‚ÇÅ Y‚ÇÅ\ng : Quiver.Hom X‚ÇÇ Y‚ÇÇ\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f g).unop (CategoryTheory.MonoidalCategoryStruct.tensorHom f.unop g.unop)","decl":"@[simp] lemma unop_tensorHom {X‚ÇÅ Y‚ÇÅ X‚ÇÇ Y‚ÇÇ : C·µí·µñ} (f : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (g : X‚ÇÇ ‚ü∂ Y‚ÇÇ) :\n    (f ‚äó g).unop = f.unop ‚äó g.unop := rfl\n\n"}
{"name":"CategoryTheory.op_whiskerLeft","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y Z : C\nf : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f).op (CategoryTheory.MonoidalCategoryStruct.whiskerLeft { unop := X } f.op)","decl":"@[simp] lemma op_whiskerLeft (X : C) {Y Z : C} (f : Y ‚ü∂ Z) :\n    (X ‚óÅ f).op = op X ‚óÅ f.op := rfl\n"}
{"name":"CategoryTheory.unop_whiskerLeft","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y Z : Opposite C\nf : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f).unop (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (Opposite.unop X) f.unop)","decl":"@[simp] lemma unop_whiskerLeft (X : C·µí·µñ) {Y Z : C·µí·µñ} (f : Y ‚ü∂ Z) :\n    (X ‚óÅ f).unop =  unop X ‚óÅ f.unop := rfl\n\n"}
{"name":"CategoryTheory.op_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z).op (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.op { unop := Z })","decl":"@[simp] lemma op_whiskerRight {X Y : C} (f : X ‚ü∂ Y) (Z : C) :\n    (f ‚ñ∑ Z).op = f.op ‚ñ∑ op Z := rfl\n"}
{"name":"CategoryTheory.unop_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y : Opposite C\nf : Quiver.Hom X Y\nZ : Opposite C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z).unop (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.unop (Opposite.unop Z))","decl":"@[simp] lemma unop_whiskerRight {X Y : C·µí·µñ} (f : X ‚ü∂ Y) (Z : C·µí·µñ) :\n    (f ‚ñ∑ Z).unop = f.unop ‚ñ∑ unop Z := rfl\n\n"}
{"name":"CategoryTheory.op_associator","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y Z : C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).op (CategoryTheory.MonoidalCategoryStruct.associator { unop := X } { unop := Y } { unop := Z }).symm","decl":"@[simp] lemma op_associator (X Y Z : C) :\n    (Œ±_ X Y Z).op = (Œ±_ (op X) (op Y) (op Z)).symm := rfl\n"}
{"name":"CategoryTheory.unop_associator","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y Z : Opposite C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).unop (CategoryTheory.MonoidalCategoryStruct.associator (Opposite.unop X) (Opposite.unop Y) (Opposite.unop Z)).symm","decl":"@[simp] lemma unop_associator (X Y Z : C·µí·µñ) :\n    (Œ±_ X Y Z).unop = (Œ±_ (unop X) (unop Y) (unop Z)).symm := rfl\n\n"}
{"name":"CategoryTheory.op_hom_associator","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y Z : C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom.op (CategoryTheory.MonoidalCategoryStruct.associator { unop := X } { unop := Y } { unop := Z }).inv","decl":"@[simp] lemma op_hom_associator (X Y Z : C) :\n    (Œ±_ X Y Z).hom.op = (Œ±_ (op X) (op Y) (op Z)).inv := rfl\n"}
{"name":"CategoryTheory.unop_hom_associator","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y Z : Opposite C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom.unop (CategoryTheory.MonoidalCategoryStruct.associator (Opposite.unop X) (Opposite.unop Y) (Opposite.unop Z)).inv","decl":"@[simp] lemma unop_hom_associator (X Y Z : C·µí·µñ) :\n    (Œ±_ X Y Z).hom.unop = (Œ±_ (unop X) (unop Y) (unop Z)).inv := rfl\n\n"}
{"name":"CategoryTheory.op_inv_associator","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y Z : C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv.op (CategoryTheory.MonoidalCategoryStruct.associator { unop := X } { unop := Y } { unop := Z }).hom","decl":"@[simp] lemma op_inv_associator (X Y Z : C) :\n    (Œ±_ X Y Z).inv.op = (Œ±_ (op X) (op Y) (op Z)).hom := rfl\n"}
{"name":"CategoryTheory.unop_inv_associator","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y Z : Opposite C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv.unop (CategoryTheory.MonoidalCategoryStruct.associator (Opposite.unop X) (Opposite.unop Y) (Opposite.unop Z)).hom","decl":"@[simp] lemma unop_inv_associator (X Y Z : C·µí·µñ) :\n    (Œ±_ X Y Z).inv.unop = (Œ±_ (unop X) (unop Y) (unop Z)).hom := rfl\n\n"}
{"name":"CategoryTheory.op_leftUnitor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).op (CategoryTheory.MonoidalCategoryStruct.leftUnitor { unop := X }).symm","decl":"@[simp] lemma op_leftUnitor (X : C) : (Œª_ X).op = (Œª_ (op X)).symm := rfl\n"}
{"name":"CategoryTheory.unop_leftUnitor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : Opposite C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).unop (CategoryTheory.MonoidalCategoryStruct.leftUnitor (Opposite.unop X)).symm","decl":"@[simp] lemma unop_leftUnitor (X : C·µí·µñ) : (Œª_ X).unop = (Œª_ (unop X)).symm := rfl\n\n"}
{"name":"CategoryTheory.op_hom_leftUnitor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom.op (CategoryTheory.MonoidalCategoryStruct.leftUnitor { unop := X }).inv","decl":"@[simp] lemma op_hom_leftUnitor (X : C) : (Œª_ X).hom.op = (Œª_ (op X)).inv := rfl\n"}
{"name":"CategoryTheory.unop_hom_leftUnitor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : Opposite C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom.unop (CategoryTheory.MonoidalCategoryStruct.leftUnitor (Opposite.unop X)).inv","decl":"@[simp] lemma unop_hom_leftUnitor (X : C·µí·µñ) : (Œª_ X).hom.unop = (Œª_ (unop X)).inv := rfl\n\n"}
{"name":"CategoryTheory.op_inv_leftUnitor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv.op (CategoryTheory.MonoidalCategoryStruct.leftUnitor { unop := X }).hom","decl":"@[simp] lemma op_inv_leftUnitor (X : C) : (Œª_ X).inv.op = (Œª_ (op X)).hom := rfl\n"}
{"name":"CategoryTheory.unop_inv_leftUnitor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : Opposite C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv.unop (CategoryTheory.MonoidalCategoryStruct.leftUnitor (Opposite.unop X)).hom","decl":"@[simp] lemma unop_inv_leftUnitor (X : C·µí·µñ) : (Œª_ X).inv.unop = (Œª_ (unop X)).hom := rfl\n\n"}
{"name":"CategoryTheory.op_rightUnitor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).op (CategoryTheory.MonoidalCategoryStruct.rightUnitor { unop := X }).symm","decl":"@[simp] lemma op_rightUnitor (X : C) : (œÅ_ X).op = (œÅ_ (op X)).symm := rfl\n"}
{"name":"CategoryTheory.unop_rightUnitor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : Opposite C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).unop (CategoryTheory.MonoidalCategoryStruct.rightUnitor (Opposite.unop X)).symm","decl":"@[simp] lemma unop_rightUnitor (X : C·µí·µñ) : (œÅ_ X).unop = (œÅ_ (unop X)).symm := rfl\n\n"}
{"name":"CategoryTheory.op_hom_rightUnitor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom.op (CategoryTheory.MonoidalCategoryStruct.rightUnitor { unop := X }).inv","decl":"@[simp] lemma op_hom_rightUnitor (X : C) : (œÅ_ X).hom.op = (œÅ_ (op X)).inv := rfl\n"}
{"name":"CategoryTheory.unop_hom_rightUnitor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : Opposite C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom.unop (CategoryTheory.MonoidalCategoryStruct.rightUnitor (Opposite.unop X)).inv","decl":"@[simp] lemma unop_hom_rightUnitor (X : C·µí·µñ) : (œÅ_ X).hom.unop = (œÅ_ (unop X)).inv := rfl\n\n"}
{"name":"CategoryTheory.op_inv_rightUnitor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv.op (CategoryTheory.MonoidalCategoryStruct.rightUnitor { unop := X }).hom","decl":"@[simp] lemma op_inv_rightUnitor (X : C) : (œÅ_ X).inv.op = (œÅ_ (op X)).hom := rfl\n"}
{"name":"CategoryTheory.unop_inv_rightUnitor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : Opposite C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv.unop (CategoryTheory.MonoidalCategoryStruct.rightUnitor (Opposite.unop X)).hom","decl":"@[simp] lemma unop_inv_rightUnitor (X : C·µí·µñ) : (œÅ_ X).inv.unop = (œÅ_ (unop X)).hom := rfl\n\n"}
{"name":"CategoryTheory.op_tensor_op","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f.op g.op) (CategoryTheory.MonoidalCategoryStruct.tensorHom f g).op","decl":"theorem op_tensor_op {W X Y Z : C} (f : W ‚ü∂ X) (g : Y ‚ü∂ Z) : f.op ‚äó g.op = (f ‚äó g).op := rfl\n\n"}
{"name":"CategoryTheory.unop_tensor_unop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nW X Y Z : Opposite C\nf : Quiver.Hom W X\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f.unop g.unop) (CategoryTheory.MonoidalCategoryStruct.tensorHom f g).unop","decl":"theorem unop_tensor_unop {W X Y Z : C·µí·µñ} (f : W ‚ü∂ X) (g : Y ‚ü∂ Z) :\n    f.unop ‚äó g.unop = (f ‚äó g).unop := rfl\n\n"}
{"name":"CategoryTheory.mop_tensorObj","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y : C\n‚ä¢ Eq { unmop := CategoryTheory.MonoidalCategoryStruct.tensorObj X Y } (CategoryTheory.MonoidalCategoryStruct.tensorObj { unmop := Y } { unmop := X })","decl":"@[simp] lemma mop_tensorObj (X Y : C) : mop (X ‚äó Y) = mop Y ‚äó mop X := rfl\n"}
{"name":"CategoryTheory.unmop_tensorObj","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).unmop (CategoryTheory.MonoidalCategoryStruct.tensorObj Y.unmop X.unmop)","decl":"@[simp] lemma unmop_tensorObj (X Y : C·¥π·µí·µñ) : unmop (X ‚äó Y) = unmop Y ‚äó unmop X := rfl\n\n"}
{"name":"CategoryTheory.mop_tensorUnit","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ Eq { unmop := CategoryTheory.MonoidalCategoryStruct.tensorUnit } CategoryTheory.MonoidalCategoryStruct.tensorUnit","decl":"@[simp] lemma mop_tensorUnit : mop (ùüô_ C) = ùüô_ C·¥π·µí·µñ := rfl\n"}
{"name":"CategoryTheory.unmop_tensorUnit","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ Eq CategoryTheory.MonoidalCategoryStruct.tensorUnit.unmop CategoryTheory.MonoidalCategoryStruct.tensorUnit","decl":"@[simp] lemma unmop_tensorUnit : unmop (ùüô_ C·¥π·µí·µñ) = ùüô_ C := rfl\n\n"}
{"name":"CategoryTheory.mop_tensorHom","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚ÇÅ Y‚ÇÅ X‚ÇÇ Y‚ÇÇ : C\nf : Quiver.Hom X‚ÇÅ Y‚ÇÅ\ng : Quiver.Hom X‚ÇÇ Y‚ÇÇ\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f g).mop (CategoryTheory.MonoidalCategoryStruct.tensorHom g.mop f.mop)","decl":"@[simp] lemma mop_tensorHom {X‚ÇÅ Y‚ÇÅ X‚ÇÇ Y‚ÇÇ : C} (f : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (g : X‚ÇÇ ‚ü∂ Y‚ÇÇ) :\n    (f ‚äó g).mop = g.mop ‚äó f.mop := rfl\n"}
{"name":"CategoryTheory.unmop_tensorHom","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚ÇÅ Y‚ÇÅ X‚ÇÇ Y‚ÇÇ : CategoryTheory.MonoidalOpposite C\nf : Quiver.Hom X‚ÇÅ Y‚ÇÅ\ng : Quiver.Hom X‚ÇÇ Y‚ÇÇ\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f g).unmop (CategoryTheory.MonoidalCategoryStruct.tensorHom g.unmop f.unmop)","decl":"@[simp] lemma unmop_tensorHom {X‚ÇÅ Y‚ÇÅ X‚ÇÇ Y‚ÇÇ : C·¥π·µí·µñ} (f : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (g : X‚ÇÇ ‚ü∂ Y‚ÇÇ) :\n    (f ‚äó g).unmop = g.unmop ‚äó f.unmop := rfl\n\n"}
{"name":"CategoryTheory.mop_whiskerLeft","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y Z : C\nf : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f).mop (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.mop { unmop := X })","decl":"@[simp] lemma mop_whiskerLeft (X : C) {Y Z : C} (f : Y ‚ü∂ Z) :\n    (X ‚óÅ f).mop = f.mop ‚ñ∑ mop X := rfl\n"}
{"name":"CategoryTheory.unmop_whiskerLeft","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y Z : CategoryTheory.MonoidalOpposite C\nf : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f).unmop (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.unmop X.unmop)","decl":"@[simp] lemma unmop_whiskerLeft (X : C·¥π·µí·µñ) {Y Z : C·¥π·µí·µñ} (f : Y ‚ü∂ Z) :\n    (X ‚óÅ f).unmop = f.unmop ‚ñ∑ unmop X := rfl\n\n"}
{"name":"CategoryTheory.mop_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z).mop (CategoryTheory.MonoidalCategoryStruct.whiskerLeft { unmop := Z } f.mop)","decl":"@[simp] lemma mop_whiskerRight {X Y : C} (f : X ‚ü∂ Y) (Z : C) :\n    (f ‚ñ∑ Z).mop = mop Z ‚óÅ f.mop := rfl\n"}
{"name":"CategoryTheory.unmop_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.MonoidalOpposite C\nf : Quiver.Hom X Y\nZ : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z).unmop (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z.unmop f.unmop)","decl":"@[simp] lemma unmop_whiskerRight {X Y : C·¥π·µí·µñ} (f : X ‚ü∂ Y) (Z : C·¥π·µí·µñ) :\n    (f ‚ñ∑ Z).unmop = unmop Z ‚óÅ f.unmop := rfl\n\n"}
{"name":"CategoryTheory.mop_associator","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y Z : C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).mop (CategoryTheory.MonoidalCategoryStruct.associator { unmop := Z } { unmop := Y } { unmop := X }).symm","decl":"@[simp] lemma mop_associator (X Y Z : C) :\n    (Œ±_ X Y Z).mop = (Œ±_ (mop Z) (mop Y) (mop X)).symm := rfl\n"}
{"name":"CategoryTheory.unmop_associator","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y Z : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).unmop (CategoryTheory.MonoidalCategoryStruct.associator Z.unmop Y.unmop X.unmop).symm","decl":"@[simp] lemma unmop_associator (X Y Z : C·¥π·µí·µñ) :\n    (Œ±_ X Y Z).unmop = (Œ±_ (unmop Z) (unmop Y) (unmop X)).symm := rfl\n\n"}
{"name":"CategoryTheory.mop_hom_associator","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y Z : C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom.mop (CategoryTheory.MonoidalCategoryStruct.associator { unmop := Z } { unmop := Y } { unmop := X }).inv","decl":"@[simp] lemma mop_hom_associator (X Y Z : C) :\n    (Œ±_ X Y Z).hom.mop = (Œ±_ (mop Z) (mop Y) (mop X)).inv := rfl\n"}
{"name":"CategoryTheory.unmop_hom_associator","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y Z : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom.unmop (CategoryTheory.MonoidalCategoryStruct.associator Z.unmop Y.unmop X.unmop).inv","decl":"@[simp] lemma unmop_hom_associator (X Y Z : C·¥π·µí·µñ) :\n    (Œ±_ X Y Z).hom.unmop = (Œ±_ (unmop Z) (unmop Y) (unmop X)).inv := rfl\n\n"}
{"name":"CategoryTheory.mop_inv_associator","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y Z : C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv.mop (CategoryTheory.MonoidalCategoryStruct.associator { unmop := Z } { unmop := Y } { unmop := X }).hom","decl":"@[simp] lemma mop_inv_associator (X Y Z : C) :\n    (Œ±_ X Y Z).inv.mop = (Œ±_ (mop Z) (mop Y) (mop X)).hom := rfl\n"}
{"name":"CategoryTheory.unmop_inv_associator","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y Z : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv.unmop (CategoryTheory.MonoidalCategoryStruct.associator Z.unmop Y.unmop X.unmop).hom","decl":"@[simp] lemma unmop_inv_associator (X Y Z : C·¥π·µí·µñ) :\n    (Œ±_ X Y Z).inv.unmop = (Œ±_ (unmop Z) (unmop Y) (unmop X)).hom := rfl\n\n"}
{"name":"CategoryTheory.mop_leftUnitor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).mop (CategoryTheory.MonoidalCategoryStruct.rightUnitor { unmop := X })","decl":"@[simp] lemma mop_leftUnitor (X : C) : (Œª_ X).mop = (œÅ_ (mop X)) := rfl\n"}
{"name":"CategoryTheory.unmop_leftUnitor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).unmop (CategoryTheory.MonoidalCategoryStruct.rightUnitor X.unmop)","decl":"@[simp] lemma unmop_leftUnitor (X : C·¥π·µí·µñ) : (Œª_ X).unmop = œÅ_ (unmop X) := rfl\n\n"}
{"name":"CategoryTheory.mop_hom_leftUnitor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom.mop (CategoryTheory.MonoidalCategoryStruct.rightUnitor { unmop := X }).hom","decl":"@[simp] lemma mop_hom_leftUnitor (X : C) : (Œª_ X).hom.mop = (œÅ_ (mop X)).hom := rfl\n"}
{"name":"CategoryTheory.unmop_hom_leftUnitor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom.unmop (CategoryTheory.MonoidalCategoryStruct.rightUnitor X.unmop).hom","decl":"@[simp] lemma unmop_hom_leftUnitor (X : C·¥π·µí·µñ) : (Œª_ X).hom.unmop = (œÅ_ (unmop X)).hom := rfl\n\n"}
{"name":"CategoryTheory.mop_inv_leftUnitor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv.mop (CategoryTheory.MonoidalCategoryStruct.rightUnitor { unmop := X }).inv","decl":"@[simp] lemma mop_inv_leftUnitor (X : C) : (Œª_ X).inv.mop = (œÅ_ (mop X)).inv := rfl\n"}
{"name":"CategoryTheory.unmop_inv_leftUnitor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv.unmop (CategoryTheory.MonoidalCategoryStruct.rightUnitor X.unmop).inv","decl":"@[simp] lemma unmop_inv_leftUnitor (X : C·¥π·µí·µñ) : (Œª_ X).inv.unmop = (œÅ_ (unmop X)).inv := rfl\n\n"}
{"name":"CategoryTheory.mop_rightUnitor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).mop (CategoryTheory.MonoidalCategoryStruct.leftUnitor { unmop := X })","decl":"@[simp] lemma mop_rightUnitor (X : C) : (œÅ_ X).mop = (Œª_ (mop X)) := rfl\n"}
{"name":"CategoryTheory.unmop_rightUnitor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).unmop (CategoryTheory.MonoidalCategoryStruct.leftUnitor X.unmop)","decl":"@[simp] lemma unmop_rightUnitor (X : C·¥π·µí·µñ) : (œÅ_ X).unmop = Œª_ (unmop X) := rfl\n\n"}
{"name":"CategoryTheory.mop_hom_rightUnitor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom.mop (CategoryTheory.MonoidalCategoryStruct.leftUnitor { unmop := X }).hom","decl":"@[simp] lemma mop_hom_rightUnitor (X : C) : (œÅ_ X).hom.mop = (Œª_ (mop X)).hom := rfl\n"}
{"name":"CategoryTheory.unmop_hom_rightUnitor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom.unmop (CategoryTheory.MonoidalCategoryStruct.leftUnitor X.unmop).hom","decl":"@[simp] lemma unmop_hom_rightUnitor (X : C·¥π·µí·µñ) : (œÅ_ X).hom.unmop = (Œª_ (unmop X)).hom := rfl\n\n"}
{"name":"CategoryTheory.mop_inv_rightUnitor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv.mop (CategoryTheory.MonoidalCategoryStruct.leftUnitor { unmop := X }).inv","decl":"@[simp] lemma mop_inv_rightUnitor (X : C) : (œÅ_ X).inv.mop = (Œª_ (mop X)).inv := rfl\n"}
{"name":"CategoryTheory.unmop_inv_rightUnitor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv.unmop (CategoryTheory.MonoidalCategoryStruct.leftUnitor X.unmop).inv","decl":"@[simp] lemma unmop_inv_rightUnitor (X : C·¥π·µí·µñ) : (œÅ_ X).inv.unmop = (Œª_ (unmop X)).inv := rfl\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.mopEquiv_inverse","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ Eq (CategoryTheory.MonoidalOpposite.mopEquiv C).inverse (CategoryTheory.unmopFunctor C)","decl":"/-- The (identity) equivalence between `C` and its monoidal opposite. -/\n@[simps] def MonoidalOpposite.mopEquiv : C ‚âå C·¥π·µí·µñ where\n  functor   := mopFunctor C\n  inverse   := unmopFunctor C\n  unitIso   := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.mopEquiv_counitIso","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ Eq (CategoryTheory.MonoidalOpposite.mopEquiv C).counitIso (CategoryTheory.Iso.refl ((CategoryTheory.unmopFunctor C).comp (CategoryTheory.mopFunctor C)))","decl":"/-- The (identity) equivalence between `C` and its monoidal opposite. -/\n@[simps] def MonoidalOpposite.mopEquiv : C ‚âå C·¥π·µí·µñ where\n  functor   := mopFunctor C\n  inverse   := unmopFunctor C\n  unitIso   := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.mopEquiv_functor","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ Eq (CategoryTheory.MonoidalOpposite.mopEquiv C).functor (CategoryTheory.mopFunctor C)","decl":"/-- The (identity) equivalence between `C` and its monoidal opposite. -/\n@[simps] def MonoidalOpposite.mopEquiv : C ‚âå C·¥π·µí·µñ where\n  functor   := mopFunctor C\n  inverse   := unmopFunctor C\n  unitIso   := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.mopEquiv_unitIso","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ Eq (CategoryTheory.MonoidalOpposite.mopEquiv C).unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id C))","decl":"/-- The (identity) equivalence between `C` and its monoidal opposite. -/\n@[simps] def MonoidalOpposite.mopEquiv : C ‚âå C·¥π·µí·µñ where\n  functor   := mopFunctor C\n  inverse   := unmopFunctor C\n  unitIso   := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.unmopEquiv_counitIso_inv_app","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq ((CategoryTheory.MonoidalOpposite.unmopEquiv C).counitIso.inv.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The (identity) equivalence between `C·¥π·µí·µñ` and `C`. -/\n@[simps!] def MonoidalOpposite.unmopEquiv : C·¥π·µí·µñ ‚âå C := (mopEquiv C).symm\n\n-- todo: upgrade to monoidal equivalence\n"}
{"name":"CategoryTheory.MonoidalOpposite.unmopEquiv_inverse_map_unmop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.MonoidalOpposite.unmopEquiv C).inverse.map f).unmop f","decl":"/-- The (identity) equivalence between `C·¥π·µí·µñ` and `C`. -/\n@[simps!] def MonoidalOpposite.unmopEquiv : C·¥π·µí·µñ ‚âå C := (mopEquiv C).symm\n\n-- todo: upgrade to monoidal equivalence\n"}
{"name":"CategoryTheory.MonoidalOpposite.unmopEquiv_counitIso_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq ((CategoryTheory.MonoidalOpposite.unmopEquiv C).counitIso.hom.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The (identity) equivalence between `C·¥π·µí·µñ` and `C`. -/\n@[simps!] def MonoidalOpposite.unmopEquiv : C·¥π·µí·µñ ‚âå C := (mopEquiv C).symm\n\n-- todo: upgrade to monoidal equivalence\n"}
{"name":"CategoryTheory.MonoidalOpposite.unmopEquiv_unitIso_inv_app_unmop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq ((CategoryTheory.MonoidalOpposite.unmopEquiv C).unitIso.inv.app X).unmop (CategoryTheory.CategoryStruct.id X.unmop)","decl":"/-- The (identity) equivalence between `C·¥π·µí·µñ` and `C`. -/\n@[simps!] def MonoidalOpposite.unmopEquiv : C·¥π·µí·µñ ‚âå C := (mopEquiv C).symm\n\n-- todo: upgrade to monoidal equivalence\n"}
{"name":"CategoryTheory.MonoidalOpposite.unmopEquiv_inverse_obj_unmop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nunmop : C\n‚ä¢ Eq ((CategoryTheory.MonoidalOpposite.unmopEquiv C).inverse.obj unmop).unmop unmop","decl":"/-- The (identity) equivalence between `C·¥π·µí·µñ` and `C`. -/\n@[simps!] def MonoidalOpposite.unmopEquiv : C·¥π·µí·µñ ‚âå C := (mopEquiv C).symm\n\n-- todo: upgrade to monoidal equivalence\n"}
{"name":"CategoryTheory.MonoidalOpposite.unmopEquiv_functor_map","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX‚úù Y‚úù : CategoryTheory.MonoidalOpposite C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.MonoidalOpposite.unmopEquiv C).functor.map f) f.unmop","decl":"/-- The (identity) equivalence between `C·¥π·µí·µñ` and `C`. -/\n@[simps!] def MonoidalOpposite.unmopEquiv : C·¥π·µí·µñ ‚âå C := (mopEquiv C).symm\n\n-- todo: upgrade to monoidal equivalence\n"}
{"name":"CategoryTheory.MonoidalOpposite.unmopEquiv_functor_obj","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nself : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq ((CategoryTheory.MonoidalOpposite.unmopEquiv C).functor.obj self) self.unmop","decl":"/-- The (identity) equivalence between `C·¥π·µí·µñ` and `C`. -/\n@[simps!] def MonoidalOpposite.unmopEquiv : C·¥π·µí·µñ ‚âå C := (mopEquiv C).symm\n\n-- todo: upgrade to monoidal equivalence\n"}
{"name":"CategoryTheory.MonoidalOpposite.unmopEquiv_unitIso_hom_app_unmop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq ((CategoryTheory.MonoidalOpposite.unmopEquiv C).unitIso.hom.app X).unmop (CategoryTheory.CategoryStruct.id X.unmop)","decl":"/-- The (identity) equivalence between `C·¥π·µí·µñ` and `C`. -/\n@[simps!] def MonoidalOpposite.unmopEquiv : C·¥π·µí·µñ ‚âå C := (mopEquiv C).symm\n\n-- todo: upgrade to monoidal equivalence\n"}
{"name":"CategoryTheory.MonoidalOpposite.mopMopEquivalence_unitIso_hom_app_unmop_unmop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : CategoryTheory.MonoidalOpposite (CategoryTheory.MonoidalOpposite C)\n‚ä¢ Eq ((CategoryTheory.MonoidalOpposite.mopMopEquivalence C).unitIso.hom.app X).unmop.unmop (CategoryTheory.CategoryStruct.id X.unmop).unmop","decl":"/-- The equivalence between `C` and its monoidal opposite's monoidal opposite. -/\n@[simps!] def MonoidalOpposite.mopMopEquivalence : C·¥π·µí·µñ·¥π·µí·µñ ‚âå C :=\n  .trans (MonoidalOpposite.unmopEquiv C·¥π·µí·µñ) (MonoidalOpposite.unmopEquiv C)\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.mopMopEquivalence_inverse_obj_unmop_unmop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq ((CategoryTheory.MonoidalOpposite.mopMopEquivalence C).inverse.obj X).unmop.unmop X","decl":"/-- The equivalence between `C` and its monoidal opposite's monoidal opposite. -/\n@[simps!] def MonoidalOpposite.mopMopEquivalence : C·¥π·µí·µñ·¥π·µí·µñ ‚âå C :=\n  .trans (MonoidalOpposite.unmopEquiv C·¥π·µí·µñ) (MonoidalOpposite.unmopEquiv C)\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.mopMopEquivalence_unitIso_inv_app_unmop_unmop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : CategoryTheory.MonoidalOpposite (CategoryTheory.MonoidalOpposite C)\n‚ä¢ Eq ((CategoryTheory.MonoidalOpposite.mopMopEquivalence C).unitIso.inv.app X).unmop.unmop (CategoryTheory.CategoryStruct.id X.unmop).unmop","decl":"/-- The equivalence between `C` and its monoidal opposite's monoidal opposite. -/\n@[simps!] def MonoidalOpposite.mopMopEquivalence : C·¥π·µí·µñ·¥π·µí·µñ ‚âå C :=\n  .trans (MonoidalOpposite.unmopEquiv C·¥π·µí·µñ) (MonoidalOpposite.unmopEquiv C)\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.mopMopEquivalence_functor_map","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX‚úù Y‚úù : CategoryTheory.MonoidalOpposite (CategoryTheory.MonoidalOpposite C)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.MonoidalOpposite.mopMopEquivalence C).functor.map f) f.unmop.unmop","decl":"/-- The equivalence between `C` and its monoidal opposite's monoidal opposite. -/\n@[simps!] def MonoidalOpposite.mopMopEquivalence : C·¥π·µí·µñ·¥π·µí·µñ ‚âå C :=\n  .trans (MonoidalOpposite.unmopEquiv C·¥π·µí·µñ) (MonoidalOpposite.unmopEquiv C)\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.mopMopEquivalence_inverse_map_unmop_unmop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.MonoidalOpposite.mopMopEquivalence C).inverse.map f).unmop.unmop f","decl":"/-- The equivalence between `C` and its monoidal opposite's monoidal opposite. -/\n@[simps!] def MonoidalOpposite.mopMopEquivalence : C·¥π·µí·µñ·¥π·µí·µñ ‚âå C :=\n  .trans (MonoidalOpposite.unmopEquiv C·¥π·µí·µñ) (MonoidalOpposite.unmopEquiv C)\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.mopMopEquivalence_counitIso_inv_app","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq ((CategoryTheory.MonoidalOpposite.mopMopEquivalence C).counitIso.inv.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The equivalence between `C` and its monoidal opposite's monoidal opposite. -/\n@[simps!] def MonoidalOpposite.mopMopEquivalence : C·¥π·µí·µñ·¥π·µí·µñ ‚âå C :=\n  .trans (MonoidalOpposite.unmopEquiv C·¥π·µí·µñ) (MonoidalOpposite.unmopEquiv C)\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.mopMopEquivalence_counitIso_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq ((CategoryTheory.MonoidalOpposite.mopMopEquivalence C).counitIso.hom.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The equivalence between `C` and its monoidal opposite's monoidal opposite. -/\n@[simps!] def MonoidalOpposite.mopMopEquivalence : C·¥π·µí·µñ·¥π·µí·µñ ‚âå C :=\n  .trans (MonoidalOpposite.unmopEquiv C·¥π·µí·µñ) (MonoidalOpposite.unmopEquiv C)\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.mopMopEquivalence_functor_obj","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : CategoryTheory.MonoidalOpposite (CategoryTheory.MonoidalOpposite C)\n‚ä¢ Eq ((CategoryTheory.MonoidalOpposite.mopMopEquivalence C).functor.obj X) X.unmop.unmop","decl":"/-- The equivalence between `C` and its monoidal opposite's monoidal opposite. -/\n@[simps!] def MonoidalOpposite.mopMopEquivalence : C·¥π·µí·µñ·¥π·µí·µñ ‚âå C :=\n  .trans (MonoidalOpposite.unmopEquiv C·¥π·µí·µñ) (MonoidalOpposite.unmopEquiv C)\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.tensorIso_hom_app_unmop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : Prod (CategoryTheory.MonoidalOpposite C) (CategoryTheory.MonoidalOpposite C)\n‚ä¢ Eq ((CategoryTheory.MonoidalOpposite.tensorIso C).hom.app X).unmop (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X.2.unmop X.1.unmop))","decl":"/-- The identification `mop X ‚äó mop Y = mop (Y ‚äó X)` as a natural isomorphism. -/\n@[simps!]\ndef MonoidalOpposite.tensorIso :\n    tensor C·¥π·µí·µñ ‚âÖ (unmopFunctor C).prod (unmopFunctor C) ‚ãô\n      Prod.swap C C ‚ãô tensor C ‚ãô mopFunctor C :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.tensorIso_inv_app_unmop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : Prod (CategoryTheory.MonoidalOpposite C) (CategoryTheory.MonoidalOpposite C)\n‚ä¢ Eq ((CategoryTheory.MonoidalOpposite.tensorIso C).inv.app X).unmop (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X.2.unmop X.1.unmop))","decl":"/-- The identification `mop X ‚äó mop Y = mop (Y ‚äó X)` as a natural isomorphism. -/\n@[simps!]\ndef MonoidalOpposite.tensorIso :\n    tensor C·¥π·µí·µñ ‚âÖ (unmopFunctor C).prod (unmopFunctor C) ‚ãô\n      Prod.swap C C ‚ãô tensor C ‚ãô mopFunctor C :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.tensorLeftIso_hom_app_unmop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚úù X : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq (X‚úù.tensorLeftIso.hom.app X).unmop (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X.unmop X‚úù.unmop))","decl":"/-- The identification `X ‚äó - = mop (- ‚äó unmop X)` as a natural isomorphism. -/\n@[simps!]\ndef MonoidalOpposite.tensorLeftIso (X : C·¥π·µí·µñ) :\n    tensorLeft X ‚âÖ unmopFunctor C ‚ãô tensorRight (unmop X) ‚ãô mopFunctor C :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.tensorLeftIso_inv_app_unmop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚úù X : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq (X‚úù.tensorLeftIso.inv.app X).unmop (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X.unmop X‚úù.unmop))","decl":"/-- The identification `X ‚äó - = mop (- ‚äó unmop X)` as a natural isomorphism. -/\n@[simps!]\ndef MonoidalOpposite.tensorLeftIso (X : C·¥π·µí·µñ) :\n    tensorLeft X ‚âÖ unmopFunctor C ‚ãô tensorRight (unmop X) ‚ãô mopFunctor C :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.tensorLeftMopIso_inv_app_unmop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚úù : C\nX : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq ((CategoryTheory.MonoidalOpposite.tensorLeftMopIso X‚úù).inv.app X).unmop (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X.unmop X‚úù))","decl":"/-- The identification `mop X ‚äó - = mop (- ‚äó X)` as a natural isomorphism. -/\n@[simps!]\ndef MonoidalOpposite.tensorLeftMopIso (X : C) :\n    tensorLeft (mop X) ‚âÖ unmopFunctor C ‚ãô tensorRight X ‚ãô mopFunctor C :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.tensorLeftMopIso_hom_app_unmop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚úù : C\nX : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq ((CategoryTheory.MonoidalOpposite.tensorLeftMopIso X‚úù).hom.app X).unmop (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X.unmop X‚úù))","decl":"/-- The identification `mop X ‚äó - = mop (- ‚äó X)` as a natural isomorphism. -/\n@[simps!]\ndef MonoidalOpposite.tensorLeftMopIso (X : C) :\n    tensorLeft (mop X) ‚âÖ unmopFunctor C ‚ãô tensorRight X ‚ãô mopFunctor C :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.tensorLeftUnmopIso_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚úù : CategoryTheory.MonoidalOpposite C\nX : C\n‚ä¢ Eq (X‚úù.tensorLeftUnmopIso.hom.app X) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X‚úù.unmop X))","decl":"/-- The identification `unmop X ‚äó - = unmop (mop - ‚äó X)` as a natural isomorphism. -/\n@[simps!]\ndef MonoidalOpposite.tensorLeftUnmopIso (X : C·¥π·µí·µñ) :\n    tensorLeft (unmop X) ‚âÖ mopFunctor C ‚ãô tensorRight X ‚ãô unmopFunctor C :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.tensorLeftUnmopIso_inv_app","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚úù : CategoryTheory.MonoidalOpposite C\nX : C\n‚ä¢ Eq (X‚úù.tensorLeftUnmopIso.inv.app X) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X‚úù.unmop X))","decl":"/-- The identification `unmop X ‚äó - = unmop (mop - ‚äó X)` as a natural isomorphism. -/\n@[simps!]\ndef MonoidalOpposite.tensorLeftUnmopIso (X : C·¥π·µí·µñ) :\n    tensorLeft (unmop X) ‚âÖ mopFunctor C ‚ãô tensorRight X ‚ãô unmopFunctor C :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.tensorRightIso_hom_app_unmop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚úù X : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq (X‚úù.tensorRightIso.hom.app X).unmop (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X‚úù.unmop X.unmop))","decl":"/-- The identification `- ‚äó X = mop (unmop X ‚äó -)` as a natural isomorphism. -/\n@[simps!]\ndef MonoidalOpposite.tensorRightIso (X : C·¥π·µí·µñ) :\n    tensorRight X ‚âÖ unmopFunctor C ‚ãô tensorLeft (unmop X) ‚ãô mopFunctor C :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.tensorRightIso_inv_app_unmop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚úù X : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq (X‚úù.tensorRightIso.inv.app X).unmop (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X‚úù.unmop X.unmop))","decl":"/-- The identification `- ‚äó X = mop (unmop X ‚äó -)` as a natural isomorphism. -/\n@[simps!]\ndef MonoidalOpposite.tensorRightIso (X : C·¥π·µí·µñ) :\n    tensorRight X ‚âÖ unmopFunctor C ‚ãô tensorLeft (unmop X) ‚ãô mopFunctor C :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.tensorRightMopIso_inv_app_unmop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚úù : C\nX : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq ((CategoryTheory.MonoidalOpposite.tensorRightMopIso X‚úù).inv.app X).unmop (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X‚úù X.unmop))","decl":"/-- The identification `- ‚äó mop X = mop (- ‚äó unmop X)` as a natural isomorphism. -/\n@[simps!]\ndef MonoidalOpposite.tensorRightMopIso (X : C) :\n    tensorRight (mop X) ‚âÖ unmopFunctor C ‚ãô tensorLeft X ‚ãô mopFunctor C :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.tensorRightMopIso_hom_app_unmop","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚úù : C\nX : CategoryTheory.MonoidalOpposite C\n‚ä¢ Eq ((CategoryTheory.MonoidalOpposite.tensorRightMopIso X‚úù).hom.app X).unmop (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X‚úù X.unmop))","decl":"/-- The identification `- ‚äó mop X = mop (- ‚äó unmop X)` as a natural isomorphism. -/\n@[simps!]\ndef MonoidalOpposite.tensorRightMopIso (X : C) :\n    tensorRight (mop X) ‚âÖ unmopFunctor C ‚ãô tensorLeft X ‚ãô mopFunctor C :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.tensorRightUnmopIso_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚úù : CategoryTheory.MonoidalOpposite C\nX : C\n‚ä¢ Eq (X‚úù.tensorRightUnmopIso.hom.app X) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X X‚úù.unmop))","decl":"/-- The identification `- ‚äó unmop X = unmop (X ‚äó mop -)` as a natural isomorphism. -/\n@[simps!]\ndef MonoidalOpposite.tensorRightUnmopIso (X : C·¥π·µí·µñ) :\n    tensorRight (unmop X) ‚âÖ mopFunctor C ‚ãô tensorLeft X ‚ãô unmopFunctor C :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.tensorRightUnmopIso_inv_app","module":"Mathlib.CategoryTheory.Monoidal.Opposite","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚úù : CategoryTheory.MonoidalOpposite C\nX : C\n‚ä¢ Eq (X‚úù.tensorRightUnmopIso.inv.app X) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X X‚úù.unmop))","decl":"/-- The identification `- ‚äó unmop X = unmop (X ‚äó mop -)` as a natural isomorphism. -/\n@[simps!]\ndef MonoidalOpposite.tensorRightUnmopIso (X : C·¥π·µí·µñ) :\n    tensorRight (unmop X) ‚âÖ mopFunctor C ‚ãô tensorLeft X ‚ãô unmopFunctor C :=\n  Iso.refl _\n\n"}
