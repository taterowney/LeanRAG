{"name":"Path.Homotopy.continuous_reflTransSymmAux","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"âŠ¢ Continuous Path.Homotopy.reflTransSymmAux","decl":"@[continuity]\ntheorem continuous_reflTransSymmAux : Continuous reflTransSymmAux := by\n  refine continuous_if_le ?_ ?_ (Continuous.continuousOn ?_) (Continuous.continuousOn ?_) ?_\n  Â· continuity\n  Â· continuity\n  Â· continuity\n  Â· continuity\n  intro x hx\n  norm_num [hx, mul_assoc]\n\n"}
{"name":"Path.Homotopy.reflTransSymmAux_mem_I","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"x : Prod â†‘unitInterval â†‘unitInterval\nâŠ¢ Membership.mem unitInterval (Path.Homotopy.reflTransSymmAux x)","decl":"theorem reflTransSymmAux_mem_I (x : I Ã— I) : reflTransSymmAux x âˆˆ I := by\n  dsimp only [reflTransSymmAux]\n  split_ifs\n  Â· constructor\n    Â· apply mul_nonneg\n      Â· apply mul_nonneg\n        Â· unit_interval\n        Â· norm_num\n      Â· unit_interval\n    Â· rw [mul_assoc]\n      apply mul_le_oneâ‚€\n      Â· unit_interval\n      Â· apply mul_nonneg\n        Â· norm_num\n        Â· unit_interval\n      Â· linarith\n  Â· constructor\n    Â· apply mul_nonneg\n      Â· unit_interval\n      linarith [unitInterval.nonneg x.2, unitInterval.le_one x.2]\n    Â· apply mul_le_oneâ‚€\n      Â· unit_interval\n      Â· linarith [unitInterval.nonneg x.2, unitInterval.le_one x.2]\n      Â· linarith [unitInterval.nonneg x.2, unitInterval.le_one x.2]\n\n"}
{"name":"Path.Homotopy.continuous_transReflReparamAux","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"âŠ¢ Continuous Path.Homotopy.transReflReparamAux","decl":"@[continuity]\ntheorem continuous_transReflReparamAux : Continuous transReflReparamAux := by\n  refine continuous_if_le ?_ ?_ (Continuous.continuousOn ?_) (Continuous.continuousOn ?_) ?_ <;>\n    [continuity; continuity; continuity; continuity; skip]\n  intro x hx\n  simp [hx]\n\n"}
{"name":"Path.Homotopy.transReflReparamAux_mem_I","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"t : â†‘unitInterval\nâŠ¢ Membership.mem unitInterval (Path.Homotopy.transReflReparamAux t)","decl":"theorem transReflReparamAux_mem_I (t : I) : transReflReparamAux t âˆˆ I := by\n  unfold transReflReparamAux\n  split_ifs <;> constructor <;> linarith [unitInterval.le_one t, unitInterval.nonneg t]\n\n"}
{"name":"Path.Homotopy.transReflReparamAux_zero","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"âŠ¢ Eq (Path.Homotopy.transReflReparamAux 0) 0","decl":"theorem transReflReparamAux_zero : transReflReparamAux 0 = 0 := by\n  norm_num [transReflReparamAux]\n\n"}
{"name":"Path.Homotopy.transReflReparamAux_one","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"âŠ¢ Eq (Path.Homotopy.transReflReparamAux 1) 1","decl":"theorem transReflReparamAux_one : transReflReparamAux 1 = 1 := by\n  norm_num [transReflReparamAux]\n\n"}
{"name":"Path.Homotopy.trans_refl_reparam","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nxâ‚€ xâ‚ : X\np : Path xâ‚€ xâ‚\nâŠ¢ Eq (p.trans (Path.refl xâ‚)) (p.reparam (fun t => âŸ¨Path.Homotopy.transReflReparamAux t, â‹¯âŸ©) â‹¯ â‹¯ â‹¯)","decl":"theorem trans_refl_reparam (p : Path xâ‚€ xâ‚) :\n    p.trans (Path.refl xâ‚) =\n      p.reparam (fun t => âŸ¨transReflReparamAux t, transReflReparamAux_mem_I tâŸ©) (by continuity)\n        (Subtype.ext transReflReparamAux_zero) (Subtype.ext transReflReparamAux_one) := by\n  ext\n  unfold transReflReparamAux\n  simp only [Path.trans_apply, not_le, coe_reparam, Function.comp_apply, one_div, Path.refl_apply]\n  split_ifs\n  Â· rfl\n  Â· rfl\n  Â· simp\n  Â· simp\n\n"}
{"name":"Path.Homotopy.continuous_transAssocReparamAux","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"âŠ¢ Continuous Path.Homotopy.transAssocReparamAux","decl":"@[continuity]\ntheorem continuous_transAssocReparamAux : Continuous transAssocReparamAux := by\n  refine continuous_if_le ?_ ?_ (Continuous.continuousOn ?_)\n    (continuous_if_le ?_ ?_\n      (Continuous.continuousOn ?_) (Continuous.continuousOn ?_) ?_).continuousOn\n      ?_ <;>\n    [continuity; continuity; continuity; continuity; continuity; continuity; continuity; skip;\n      skip] <;>\n    Â· intro x hx\n      norm_num [hx]\n\n"}
{"name":"Path.Homotopy.transAssocReparamAux_mem_I","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"t : â†‘unitInterval\nâŠ¢ Membership.mem unitInterval (Path.Homotopy.transAssocReparamAux t)","decl":"theorem transAssocReparamAux_mem_I (t : I) : transAssocReparamAux t âˆˆ I := by\n  unfold transAssocReparamAux\n  split_ifs <;> constructor <;> linarith [unitInterval.le_one t, unitInterval.nonneg t]\n\n"}
{"name":"Path.Homotopy.transAssocReparamAux_zero","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"âŠ¢ Eq (Path.Homotopy.transAssocReparamAux 0) 0","decl":"theorem transAssocReparamAux_zero : transAssocReparamAux 0 = 0 := by\n  norm_num [transAssocReparamAux]\n\n"}
{"name":"Path.Homotopy.transAssocReparamAux_one","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"âŠ¢ Eq (Path.Homotopy.transAssocReparamAux 1) 1","decl":"theorem transAssocReparamAux_one : transAssocReparamAux 1 = 1 := by\n  norm_num [transAssocReparamAux]\n\n"}
{"name":"Path.Homotopy.trans_assoc_reparam","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nxâ‚€ xâ‚ xâ‚‚ xâ‚ƒ : X\np : Path xâ‚€ xâ‚\nq : Path xâ‚ xâ‚‚\nr : Path xâ‚‚ xâ‚ƒ\nâŠ¢ Eq ((p.trans q).trans r) ((p.trans (q.trans r)).reparam (fun t => âŸ¨Path.Homotopy.transAssocReparamAux t, â‹¯âŸ©) â‹¯ â‹¯ â‹¯)","decl":"theorem trans_assoc_reparam {xâ‚€ xâ‚ xâ‚‚ xâ‚ƒ : X} (p : Path xâ‚€ xâ‚) (q : Path xâ‚ xâ‚‚) (r : Path xâ‚‚ xâ‚ƒ) :\n    (p.trans q).trans r =\n      (p.trans (q.trans r)).reparam\n        (fun t => âŸ¨transAssocReparamAux t, transAssocReparamAux_mem_I tâŸ©) (by continuity)\n        (Subtype.ext transAssocReparamAux_zero) (Subtype.ext transAssocReparamAux_one) := by\n  ext x\n  simp only [transAssocReparamAux, Path.trans_apply, mul_inv_cancel_leftâ‚€, not_le,\n    Function.comp_apply, Ne, not_false_iff, one_ne_zero, mul_ite, Subtype.coe_mk,\n    Path.coe_reparam]\n  -- TODO: why does split_ifs not reduce the ifs??????\n  split_ifs with hâ‚ hâ‚‚ hâ‚ƒ hâ‚„ hâ‚…\n  Â· rfl\n  Â· exfalso\n    linarith\n  Â· exfalso\n    linarith\n  Â· exfalso\n    linarith\n  Â· exfalso\n    linarith\n  Â· exfalso\n    linarith\n  Â· exfalso\n    linarith\n  Â· have h : 2 * (2 * (x : â„)) - 1 = 2 * (2 * (â†‘x + 1 / 4) - 1) := by linarith\n    simp [hâ‚‚, hâ‚, h, dif_neg (show Â¬False from id), dif_pos True.intro, if_false, if_true]\n  Â· exfalso\n    linarith\n  Â· exfalso\n    linarith\n  Â· exfalso\n    linarith\n  Â· exfalso\n    linarith\n  Â· exfalso\n    linarith\n  Â· exfalso\n    linarith\n  Â· congr\n    ring\n\n"}
{"name":"FundamentalGroupoid.ext_iff","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u\nx y : FundamentalGroupoid X\nâŠ¢ Iff (Eq x y) (Eq x.as y.as)","decl":"/-- The fundamental groupoid of a space `X` is defined to be a wrapper around `X`, and we\nsubsequently put a `CategoryTheory.Groupoid` structure on it. -/\n@[ext]\nstructure FundamentalGroupoid (X : Type u) where\n  /-- View a term of `FundamentalGroupoid X` as a term of `X`. -/\n  as : X\n\n"}
{"name":"FundamentalGroupoid.mk.sizeOf_spec","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u\ninstâœ : SizeOf X\nas : X\nâŠ¢ Eq (SizeOf.sizeOf { as := as }) (HAdd.hAdd 1 (SizeOf.sizeOf as))","decl":"/-- The fundamental groupoid of a space `X` is defined to be a wrapper around `X`, and we\nsubsequently put a `CategoryTheory.Groupoid` structure on it. -/\n@[ext]\nstructure FundamentalGroupoid (X : Type u) where\n  /-- View a term of `FundamentalGroupoid X` as a term of `X`. -/\n  as : X\n\n"}
{"name":"FundamentalGroupoid.mk.injEq","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u\nasâœ as : X\nâŠ¢ Eq (Eq { as := asâœ } { as := as }) (Eq asâœ as)","decl":"/-- The fundamental groupoid of a space `X` is defined to be a wrapper around `X`, and we\nsubsequently put a `CategoryTheory.Groupoid` structure on it. -/\n@[ext]\nstructure FundamentalGroupoid (X : Type u) where\n  /-- View a term of `FundamentalGroupoid X` as a term of `X`. -/\n  as : X\n\n"}
{"name":"FundamentalGroupoid.mk.inj","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u\nasâœ as : X\nxâœ : Eq { as := asâœ } { as := as }\nâŠ¢ Eq asâœ as","decl":"/-- The fundamental groupoid of a space `X` is defined to be a wrapper around `X`, and we\nsubsequently put a `CategoryTheory.Groupoid` structure on it. -/\n@[ext]\nstructure FundamentalGroupoid (X : Type u) where\n  /-- View a term of `FundamentalGroupoid X` as a term of `X`. -/\n  as : X\n\n"}
{"name":"FundamentalGroupoid.ext","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u\nx y : FundamentalGroupoid X\nas : Eq x.as y.as\nâŠ¢ Eq x y","decl":"/-- The fundamental groupoid of a space `X` is defined to be a wrapper around `X`, and we\nsubsequently put a `CategoryTheory.Groupoid` structure on it. -/\n@[ext]\nstructure FundamentalGroupoid (X : Type u) where\n  /-- View a term of `FundamentalGroupoid X` as a term of `X`. -/\n  as : X\n\n"}
{"name":"FundamentalGroupoid.equiv_symm_apply_as","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u_1\nx : X\nâŠ¢ Eq ((FundamentalGroupoid.equiv X).symm x).as x","decl":"/-- The equivalence between `X` and the underlying type of its fundamental groupoid.\n  This is useful for transferring constructions (instances, etc.)\n  from `X` to `Ï€â‚“ X`. -/\n@[simps]\ndef equiv (X : Type*) : FundamentalGroupoid X â‰ƒ X where\n  toFun x := x.as\n  invFun x := .mk x\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"FundamentalGroupoid.equiv_apply","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u_1\nx : FundamentalGroupoid X\nâŠ¢ Eq ((FundamentalGroupoid.equiv X) x) x.as","decl":"/-- The equivalence between `X` and the underlying type of its fundamental groupoid.\n  This is useful for transferring constructions (instances, etc.)\n  from `X` to `Ï€â‚“ X`. -/\n@[simps]\ndef equiv (X : Type*) : FundamentalGroupoid X â‰ƒ X where\n  toFun x := x.as\n  invFun x := .mk x\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"FundamentalGroupoid.isEmpty_iff","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u_1\nâŠ¢ Iff (IsEmpty (FundamentalGroupoid X)) (IsEmpty X)","decl":"@[simp]\nlemma isEmpty_iff (X : Type*) :\n    IsEmpty (FundamentalGroupoid X) â†” IsEmpty X :=\n  equiv _ |>.isEmpty_congr\n\n"}
{"name":"FundamentalGroupoid.instIsEmpty","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u_1\ninstâœ : IsEmpty X\nâŠ¢ IsEmpty (FundamentalGroupoid X)","decl":"instance (X : Type*) [IsEmpty X] :\n    IsEmpty (FundamentalGroupoid X) :=\n  equiv _ |>.isEmpty\n\n"}
{"name":"FundamentalGroupoid.nonempty_iff","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u_1\nâŠ¢ Iff (Nonempty (FundamentalGroupoid X)) (Nonempty X)","decl":"@[simp]\nlemma nonempty_iff (X : Type*) :\n    Nonempty (FundamentalGroupoid X) â†” Nonempty X :=\n  equiv _ |>.nonempty_congr\n\n"}
{"name":"FundamentalGroupoid.instNonempty","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u_1\ninstâœ : Nonempty X\nâŠ¢ Nonempty (FundamentalGroupoid X)","decl":"instance (X : Type*) [Nonempty X] :\n    Nonempty (FundamentalGroupoid X) :=\n  equiv _ |>.nonempty\n\n"}
{"name":"FundamentalGroupoid.subsingleton_iff","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u_1\nâŠ¢ Iff (Subsingleton (FundamentalGroupoid X)) (Subsingleton X)","decl":"@[simp]\nlemma subsingleton_iff (X : Type*) :\n    Subsingleton (FundamentalGroupoid X) â†” Subsingleton X :=\n  equiv _ |>.subsingleton_congr\n\n"}
{"name":"FundamentalGroupoid.instSubsingleton","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u_1\ninstâœ : Subsingleton X\nâŠ¢ Subsingleton (FundamentalGroupoid X)","decl":"instance (X : Type*) [Subsingleton X] :\n    Subsingleton (FundamentalGroupoid X) :=\n  equiv _ |>.subsingleton\n\n-- TODO: It seems that `Equiv.nontrivial_congr` doesn't exist.\n-- Once it is added, please add the corresponding lemma and instance.\n\n"}
{"name":"FundamentalGroupoid.comp_eq","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nx y z : FundamentalGroupoid X\np : Quiver.Hom x y\nq : Quiver.Hom y z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp p q) (Path.Homotopic.Quotient.comp p q)","decl":"theorem comp_eq (x y z : FundamentalGroupoid X) (p : x âŸ¶ y) (q : y âŸ¶ z) : p â‰« q = p.comp q := rfl\n\n"}
{"name":"FundamentalGroupoid.id_eq_path_refl","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nx : FundamentalGroupoid X\nâŠ¢ Eq (CategoryTheory.CategoryStruct.id x) (Quotient.mk (Path.Homotopic.setoid x.as x.as) (Path.refl x.as))","decl":"theorem id_eq_path_refl (x : FundamentalGroupoid X) : ğŸ™ x = âŸ¦Path.refl x.asâŸ§ := rfl\n\n"}
{"name":"FundamentalGroupoid.map_eq","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X Y : TopCat\nxâ‚€ xâ‚ : â†‘X\nf : ContinuousMap â†‘X â†‘Y\np : Path.Homotopic.Quotient xâ‚€ xâ‚\nâŠ¢ Eq ((FundamentalGroupoid.fundamentalGroupoidFunctor.map f).map p) (p.mapFn f)","decl":"theorem map_eq {X Y : TopCat} {xâ‚€ xâ‚ : X} (f : C(X, Y)) (p : Path.Homotopic.Quotient xâ‚€ xâ‚) :\n    (Ï€â‚˜ f).map p = p.mapFn f := rfl\n\n"}
