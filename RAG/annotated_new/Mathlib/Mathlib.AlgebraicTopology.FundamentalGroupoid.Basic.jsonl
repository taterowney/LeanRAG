{"name":"Path.Homotopy.continuous_reflTransSymmAux","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"⊢ Continuous Path.Homotopy.reflTransSymmAux","decl":"@[continuity]\ntheorem continuous_reflTransSymmAux : Continuous reflTransSymmAux := by\n  refine continuous_if_le ?_ ?_ (Continuous.continuousOn ?_) (Continuous.continuousOn ?_) ?_\n  · continuity\n  · continuity\n  · continuity\n  · continuity\n  intro x hx\n  norm_num [hx, mul_assoc]\n\n"}
{"name":"Path.Homotopy.reflTransSymmAux_mem_I","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"x : Prod ↑unitInterval ↑unitInterval\n⊢ Membership.mem unitInterval (Path.Homotopy.reflTransSymmAux x)","decl":"theorem reflTransSymmAux_mem_I (x : I × I) : reflTransSymmAux x ∈ I := by\n  dsimp only [reflTransSymmAux]\n  split_ifs\n  · constructor\n    · apply mul_nonneg\n      · apply mul_nonneg\n        · unit_interval\n        · norm_num\n      · unit_interval\n    · rw [mul_assoc]\n      apply mul_le_one₀\n      · unit_interval\n      · apply mul_nonneg\n        · norm_num\n        · unit_interval\n      · linarith\n  · constructor\n    · apply mul_nonneg\n      · unit_interval\n      linarith [unitInterval.nonneg x.2, unitInterval.le_one x.2]\n    · apply mul_le_one₀\n      · unit_interval\n      · linarith [unitInterval.nonneg x.2, unitInterval.le_one x.2]\n      · linarith [unitInterval.nonneg x.2, unitInterval.le_one x.2]\n\n"}
{"name":"Path.Homotopy.continuous_transReflReparamAux","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"⊢ Continuous Path.Homotopy.transReflReparamAux","decl":"@[continuity]\ntheorem continuous_transReflReparamAux : Continuous transReflReparamAux := by\n  refine continuous_if_le ?_ ?_ (Continuous.continuousOn ?_) (Continuous.continuousOn ?_) ?_ <;>\n    [continuity; continuity; continuity; continuity; skip]\n  intro x hx\n  simp [hx]\n\n"}
{"name":"Path.Homotopy.transReflReparamAux_mem_I","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"t : ↑unitInterval\n⊢ Membership.mem unitInterval (Path.Homotopy.transReflReparamAux t)","decl":"theorem transReflReparamAux_mem_I (t : I) : transReflReparamAux t ∈ I := by\n  unfold transReflReparamAux\n  split_ifs <;> constructor <;> linarith [unitInterval.le_one t, unitInterval.nonneg t]\n\n"}
{"name":"Path.Homotopy.transReflReparamAux_zero","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"⊢ Eq (Path.Homotopy.transReflReparamAux 0) 0","decl":"theorem transReflReparamAux_zero : transReflReparamAux 0 = 0 := by\n  norm_num [transReflReparamAux]\n\n"}
{"name":"Path.Homotopy.transReflReparamAux_one","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"⊢ Eq (Path.Homotopy.transReflReparamAux 1) 1","decl":"theorem transReflReparamAux_one : transReflReparamAux 1 = 1 := by\n  norm_num [transReflReparamAux]\n\n"}
{"name":"Path.Homotopy.trans_refl_reparam","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx₀ x₁ : X\np : Path x₀ x₁\n⊢ Eq (p.trans (Path.refl x₁)) (p.reparam (fun t => ⟨Path.Homotopy.transReflReparamAux t, ⋯⟩) ⋯ ⋯ ⋯)","decl":"theorem trans_refl_reparam (p : Path x₀ x₁) :\n    p.trans (Path.refl x₁) =\n      p.reparam (fun t => ⟨transReflReparamAux t, transReflReparamAux_mem_I t⟩) (by continuity)\n        (Subtype.ext transReflReparamAux_zero) (Subtype.ext transReflReparamAux_one) := by\n  ext\n  unfold transReflReparamAux\n  simp only [Path.trans_apply, not_le, coe_reparam, Function.comp_apply, one_div, Path.refl_apply]\n  split_ifs\n  · rfl\n  · rfl\n  · simp\n  · simp\n\n"}
{"name":"Path.Homotopy.continuous_transAssocReparamAux","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"⊢ Continuous Path.Homotopy.transAssocReparamAux","decl":"@[continuity]\ntheorem continuous_transAssocReparamAux : Continuous transAssocReparamAux := by\n  refine continuous_if_le ?_ ?_ (Continuous.continuousOn ?_)\n    (continuous_if_le ?_ ?_\n      (Continuous.continuousOn ?_) (Continuous.continuousOn ?_) ?_).continuousOn\n      ?_ <;>\n    [continuity; continuity; continuity; continuity; continuity; continuity; continuity; skip;\n      skip] <;>\n    · intro x hx\n      norm_num [hx]\n\n"}
{"name":"Path.Homotopy.transAssocReparamAux_mem_I","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"t : ↑unitInterval\n⊢ Membership.mem unitInterval (Path.Homotopy.transAssocReparamAux t)","decl":"theorem transAssocReparamAux_mem_I (t : I) : transAssocReparamAux t ∈ I := by\n  unfold transAssocReparamAux\n  split_ifs <;> constructor <;> linarith [unitInterval.le_one t, unitInterval.nonneg t]\n\n"}
{"name":"Path.Homotopy.transAssocReparamAux_zero","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"⊢ Eq (Path.Homotopy.transAssocReparamAux 0) 0","decl":"theorem transAssocReparamAux_zero : transAssocReparamAux 0 = 0 := by\n  norm_num [transAssocReparamAux]\n\n"}
{"name":"Path.Homotopy.transAssocReparamAux_one","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"⊢ Eq (Path.Homotopy.transAssocReparamAux 1) 1","decl":"theorem transAssocReparamAux_one : transAssocReparamAux 1 = 1 := by\n  norm_num [transAssocReparamAux]\n\n"}
{"name":"Path.Homotopy.trans_assoc_reparam","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx₀ x₁ x₂ x₃ : X\np : Path x₀ x₁\nq : Path x₁ x₂\nr : Path x₂ x₃\n⊢ Eq ((p.trans q).trans r) ((p.trans (q.trans r)).reparam (fun t => ⟨Path.Homotopy.transAssocReparamAux t, ⋯⟩) ⋯ ⋯ ⋯)","decl":"theorem trans_assoc_reparam {x₀ x₁ x₂ x₃ : X} (p : Path x₀ x₁) (q : Path x₁ x₂) (r : Path x₂ x₃) :\n    (p.trans q).trans r =\n      (p.trans (q.trans r)).reparam\n        (fun t => ⟨transAssocReparamAux t, transAssocReparamAux_mem_I t⟩) (by continuity)\n        (Subtype.ext transAssocReparamAux_zero) (Subtype.ext transAssocReparamAux_one) := by\n  ext x\n  simp only [transAssocReparamAux, Path.trans_apply, mul_inv_cancel_left₀, not_le,\n    Function.comp_apply, Ne, not_false_iff, one_ne_zero, mul_ite, Subtype.coe_mk,\n    Path.coe_reparam]\n  -- TODO: why does split_ifs not reduce the ifs??????\n  split_ifs with h₁ h₂ h₃ h₄ h₅\n  · rfl\n  · exfalso\n    linarith\n  · exfalso\n    linarith\n  · exfalso\n    linarith\n  · exfalso\n    linarith\n  · exfalso\n    linarith\n  · exfalso\n    linarith\n  · have h : 2 * (2 * (x : ℝ)) - 1 = 2 * (2 * (↑x + 1 / 4) - 1) := by linarith\n    simp [h₂, h₁, h, dif_neg (show ¬False from id), dif_pos True.intro, if_false, if_true]\n  · exfalso\n    linarith\n  · exfalso\n    linarith\n  · exfalso\n    linarith\n  · exfalso\n    linarith\n  · exfalso\n    linarith\n  · exfalso\n    linarith\n  · congr\n    ring\n\n"}
{"name":"FundamentalGroupoid.ext_iff","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u\nx y : FundamentalGroupoid X\n⊢ Iff (Eq x y) (Eq x.as y.as)","decl":"/-- The fundamental groupoid of a space `X` is defined to be a wrapper around `X`, and we\nsubsequently put a `CategoryTheory.Groupoid` structure on it. -/\n@[ext]\nstructure FundamentalGroupoid (X : Type u) where\n  /-- View a term of `FundamentalGroupoid X` as a term of `X`. -/\n  as : X\n\n"}
{"name":"FundamentalGroupoid.mk.sizeOf_spec","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u\ninst✝ : SizeOf X\nas : X\n⊢ Eq (SizeOf.sizeOf { as := as }) (HAdd.hAdd 1 (SizeOf.sizeOf as))","decl":"/-- The fundamental groupoid of a space `X` is defined to be a wrapper around `X`, and we\nsubsequently put a `CategoryTheory.Groupoid` structure on it. -/\n@[ext]\nstructure FundamentalGroupoid (X : Type u) where\n  /-- View a term of `FundamentalGroupoid X` as a term of `X`. -/\n  as : X\n\n"}
{"name":"FundamentalGroupoid.mk.injEq","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u\nas✝ as : X\n⊢ Eq (Eq { as := as✝ } { as := as }) (Eq as✝ as)","decl":"/-- The fundamental groupoid of a space `X` is defined to be a wrapper around `X`, and we\nsubsequently put a `CategoryTheory.Groupoid` structure on it. -/\n@[ext]\nstructure FundamentalGroupoid (X : Type u) where\n  /-- View a term of `FundamentalGroupoid X` as a term of `X`. -/\n  as : X\n\n"}
{"name":"FundamentalGroupoid.mk.inj","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u\nas✝ as : X\nx✝ : Eq { as := as✝ } { as := as }\n⊢ Eq as✝ as","decl":"/-- The fundamental groupoid of a space `X` is defined to be a wrapper around `X`, and we\nsubsequently put a `CategoryTheory.Groupoid` structure on it. -/\n@[ext]\nstructure FundamentalGroupoid (X : Type u) where\n  /-- View a term of `FundamentalGroupoid X` as a term of `X`. -/\n  as : X\n\n"}
{"name":"FundamentalGroupoid.ext","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u\nx y : FundamentalGroupoid X\nas : Eq x.as y.as\n⊢ Eq x y","decl":"/-- The fundamental groupoid of a space `X` is defined to be a wrapper around `X`, and we\nsubsequently put a `CategoryTheory.Groupoid` structure on it. -/\n@[ext]\nstructure FundamentalGroupoid (X : Type u) where\n  /-- View a term of `FundamentalGroupoid X` as a term of `X`. -/\n  as : X\n\n"}
{"name":"FundamentalGroupoid.equiv_symm_apply_as","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u_1\nx : X\n⊢ Eq ((FundamentalGroupoid.equiv X).symm x).as x","decl":"/-- The equivalence between `X` and the underlying type of its fundamental groupoid.\n  This is useful for transferring constructions (instances, etc.)\n  from `X` to `πₓ X`. -/\n@[simps]\ndef equiv (X : Type*) : FundamentalGroupoid X ≃ X where\n  toFun x := x.as\n  invFun x := .mk x\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"FundamentalGroupoid.equiv_apply","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u_1\nx : FundamentalGroupoid X\n⊢ Eq ((FundamentalGroupoid.equiv X) x) x.as","decl":"/-- The equivalence between `X` and the underlying type of its fundamental groupoid.\n  This is useful for transferring constructions (instances, etc.)\n  from `X` to `πₓ X`. -/\n@[simps]\ndef equiv (X : Type*) : FundamentalGroupoid X ≃ X where\n  toFun x := x.as\n  invFun x := .mk x\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"FundamentalGroupoid.isEmpty_iff","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u_1\n⊢ Iff (IsEmpty (FundamentalGroupoid X)) (IsEmpty X)","decl":"@[simp]\nlemma isEmpty_iff (X : Type*) :\n    IsEmpty (FundamentalGroupoid X) ↔ IsEmpty X :=\n  equiv _ |>.isEmpty_congr\n\n"}
{"name":"FundamentalGroupoid.instIsEmpty","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u_1\ninst✝ : IsEmpty X\n⊢ IsEmpty (FundamentalGroupoid X)","decl":"instance (X : Type*) [IsEmpty X] :\n    IsEmpty (FundamentalGroupoid X) :=\n  equiv _ |>.isEmpty\n\n"}
{"name":"FundamentalGroupoid.nonempty_iff","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u_1\n⊢ Iff (Nonempty (FundamentalGroupoid X)) (Nonempty X)","decl":"@[simp]\nlemma nonempty_iff (X : Type*) :\n    Nonempty (FundamentalGroupoid X) ↔ Nonempty X :=\n  equiv _ |>.nonempty_congr\n\n"}
{"name":"FundamentalGroupoid.instNonempty","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u_1\ninst✝ : Nonempty X\n⊢ Nonempty (FundamentalGroupoid X)","decl":"instance (X : Type*) [Nonempty X] :\n    Nonempty (FundamentalGroupoid X) :=\n  equiv _ |>.nonempty\n\n"}
{"name":"FundamentalGroupoid.subsingleton_iff","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u_1\n⊢ Iff (Subsingleton (FundamentalGroupoid X)) (Subsingleton X)","decl":"@[simp]\nlemma subsingleton_iff (X : Type*) :\n    Subsingleton (FundamentalGroupoid X) ↔ Subsingleton X :=\n  equiv _ |>.subsingleton_congr\n\n"}
{"name":"FundamentalGroupoid.instSubsingleton","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u_1\ninst✝ : Subsingleton X\n⊢ Subsingleton (FundamentalGroupoid X)","decl":"instance (X : Type*) [Subsingleton X] :\n    Subsingleton (FundamentalGroupoid X) :=\n  equiv _ |>.subsingleton\n\n-- TODO: It seems that `Equiv.nontrivial_congr` doesn't exist.\n-- Once it is added, please add the corresponding lemma and instance.\n\n"}
{"name":"FundamentalGroupoid.comp_eq","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx y z : FundamentalGroupoid X\np : Quiver.Hom x y\nq : Quiver.Hom y z\n⊢ Eq (CategoryTheory.CategoryStruct.comp p q) (Path.Homotopic.Quotient.comp p q)","decl":"theorem comp_eq (x y z : FundamentalGroupoid X) (p : x ⟶ y) (q : y ⟶ z) : p ≫ q = p.comp q := rfl\n\n"}
{"name":"FundamentalGroupoid.id_eq_path_refl","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : FundamentalGroupoid X\n⊢ Eq (CategoryTheory.CategoryStruct.id x) (Quotient.mk (Path.Homotopic.setoid x.as x.as) (Path.refl x.as))","decl":"theorem id_eq_path_refl (x : FundamentalGroupoid X) : 𝟙 x = ⟦Path.refl x.as⟧ := rfl\n\n"}
{"name":"FundamentalGroupoid.map_eq","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic","initialProofState":"X Y : TopCat\nx₀ x₁ : ↑X\nf : ContinuousMap ↑X ↑Y\np : Path.Homotopic.Quotient x₀ x₁\n⊢ Eq ((FundamentalGroupoid.fundamentalGroupoidFunctor.map f).map p) (p.mapFn f)","decl":"theorem map_eq {X Y : TopCat} {x₀ x₁ : X} (f : C(X, Y)) (p : Path.Homotopic.Quotient x₀ x₁) :\n    (πₘ f).map p = p.mapFn f := rfl\n\n"}
