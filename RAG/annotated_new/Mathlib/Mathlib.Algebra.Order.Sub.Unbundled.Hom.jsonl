{"name":"AddHom.le_map_tsub","module":"Mathlib.Algebra.Order.Sub.Unbundled.Hom","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁷ : Preorder α\ninst✝⁶ : Add α\ninst✝⁵ : Sub α\ninst✝⁴ : OrderedSub α\ninst✝³ : Preorder β\ninst✝² : Add β\ninst✝¹ : Sub β\ninst✝ : OrderedSub β\nf : AddHom α β\nhf : Monotone ⇑f\na b : α\n⊢ LE.le (HSub.hSub (f a) (f b)) (f (HSub.hSub a b))","decl":"theorem AddHom.le_map_tsub [Preorder β] [Add β] [Sub β] [OrderedSub β] (f : AddHom α β)\n    (hf : Monotone f) (a b : α) : f a - f b ≤ f (a - b) := by\n  rw [tsub_le_iff_right, ← f.map_add]\n  exact hf le_tsub_add\n\n"}
{"name":"le_mul_tsub","module":"Mathlib.Algebra.Order.Sub.Unbundled.Hom","initialProofState":"R : Type u_3\ninst✝⁴ : Distrib R\ninst✝³ : Preorder R\ninst✝² : Sub R\ninst✝¹ : OrderedSub R\ninst✝ : MulLeftMono R\na b c : R\n⊢ LE.le (HSub.hSub (HMul.hMul a b) (HMul.hMul a c)) (HMul.hMul a (HSub.hSub b c))","decl":"theorem le_mul_tsub {R : Type*} [Distrib R] [Preorder R] [Sub R] [OrderedSub R]\n    [MulLeftMono R] {a b c : R} : a * b - a * c ≤ a * (b - c) :=\n  (AddHom.mulLeft a).le_map_tsub (monotone_id.const_mul' a) _ _\n\n"}
{"name":"le_tsub_mul","module":"Mathlib.Algebra.Order.Sub.Unbundled.Hom","initialProofState":"R : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : Preorder R\ninst✝² : Sub R\ninst✝¹ : OrderedSub R\ninst✝ : MulLeftMono R\na b c : R\n⊢ LE.le (HSub.hSub (HMul.hMul a c) (HMul.hMul b c)) (HMul.hMul (HSub.hSub a b) c)","decl":"theorem le_tsub_mul {R : Type*} [CommSemiring R] [Preorder R] [Sub R] [OrderedSub R]\n    [MulLeftMono R] {a b c : R} : a * c - b * c ≤ (a - b) * c := by\n  simpa only [mul_comm _ c] using le_mul_tsub\n\n"}
{"name":"OrderIso.map_tsub","module":"Mathlib.Algebra.Order.Sub.Unbundled.Hom","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝⁷ : Preorder M\ninst✝⁶ : Add M\ninst✝⁵ : Sub M\ninst✝⁴ : OrderedSub M\ninst✝³ : PartialOrder N\ninst✝² : Add N\ninst✝¹ : Sub N\ninst✝ : OrderedSub N\ne : OrderIso M N\nh_add : ∀ (a b : M), Eq (e (HAdd.hAdd a b)) (HAdd.hAdd (e a) (e b))\na b : M\n⊢ Eq (e (HSub.hSub a b)) (HSub.hSub (e a) (e b))","decl":"/-- An order isomorphism between types with ordered subtraction preserves subtraction provided that\nit preserves addition. -/\ntheorem OrderIso.map_tsub {M N : Type*} [Preorder M] [Add M] [Sub M] [OrderedSub M]\n    [PartialOrder N] [Add N] [Sub N] [OrderedSub N] (e : M ≃o N)\n    (h_add : ∀ a b, e (a + b) = e a + e b) (a b : M) : e (a - b) = e a - e b := by\n  let e_add : M ≃+ N := { e with map_add' := h_add }\n  refine le_antisymm ?_ (e_add.toAddHom.le_map_tsub e.monotone a b)\n  suffices e (e.symm (e a) - e.symm (e b)) ≤ e (e.symm (e a - e b)) by simpa\n  exact e.monotone (e_add.symm.toAddHom.le_map_tsub e.symm.monotone _ _)\n\n"}
{"name":"AddMonoidHom.le_map_tsub","module":"Mathlib.Algebra.Order.Sub.Unbundled.Hom","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁷ : Preorder α\ninst✝⁶ : AddCommMonoid α\ninst✝⁵ : Sub α\ninst✝⁴ : OrderedSub α\ninst✝³ : Preorder β\ninst✝² : AddCommMonoid β\ninst✝¹ : Sub β\ninst✝ : OrderedSub β\nf : AddMonoidHom α β\nhf : Monotone ⇑f\na b : α\n⊢ LE.le (HSub.hSub (f a) (f b)) (f (HSub.hSub a b))","decl":"theorem AddMonoidHom.le_map_tsub [Preorder β] [AddCommMonoid β] [Sub β] [OrderedSub β] (f : α →+ β)\n    (hf : Monotone f) (a b : α) : f a - f b ≤ f (a - b) :=\n  f.toAddHom.le_map_tsub hf a b\n\n"}
