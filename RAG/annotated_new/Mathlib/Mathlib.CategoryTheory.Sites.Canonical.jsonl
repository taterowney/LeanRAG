{"name":"CategoryTheory.Sheaf.isSheafFor_bind","module":"Mathlib.CategoryTheory.Sites.Canonical","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nP : CategoryTheory.Functor (Opposite C) (Type v)\nU : CategoryTheory.Sieve X\nB : ‚¶ÉY : C‚¶Ñ ‚Üí ‚¶Éf : Quiver.Hom Y X‚¶Ñ ‚Üí U.arrows f ‚Üí CategoryTheory.Sieve Y\nhU : CategoryTheory.Presieve.IsSheafFor P U.arrows\nhB : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Quiver.Hom Y X‚¶Ñ (hf : U.arrows f), CategoryTheory.Presieve.IsSheafFor P (B hf).arrows\nhB' : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Quiver.Hom Y X‚¶Ñ (h : U.arrows f) ‚¶ÉZ : C‚¶Ñ (g : Quiver.Hom Z Y), CategoryTheory.Presieve.IsSeparatedFor P (CategoryTheory.Sieve.pullback g (B h)).arrows\n‚ä¢ CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Sieve.bind U.arrows B).arrows","decl":"/--\nTo show `P` is a sheaf for the binding of `U` with `B`, it suffices to show that `P` is a sheaf for\n`U`, that `P` is a sheaf for each sieve in `B`, and that it is separated for any pullback of any\nsieve in `B`.\n\nThis is mostly an auxiliary lemma to show `isSheafFor_trans`.\nAdapted from [Elephant], Lemma C2.1.7(i) with suggestions as mentioned in\nhttps://math.stackexchange.com/a/358709/\n-/\ntheorem isSheafFor_bind (P : C·µí·µñ ‚•§ Type v) (U : Sieve X) (B : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, U f ‚Üí Sieve Y)\n    (hU : Presieve.IsSheafFor P (U : Presieve X))\n    (hB : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (hf : U f), Presieve.IsSheafFor P (B hf : Presieve Y))\n    (hB' : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (h : U f) ‚¶ÉZ‚¶Ñ (g : Z ‚ü∂ Y),\n      Presieve.IsSeparatedFor P (((B h).pullback g) : Presieve Z)) :\n    Presieve.IsSheafFor P (Sieve.bind (U : Presieve X) B : Presieve X) := by\n  intro s hs\n  let y : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (hf : U f), Presieve.FamilyOfElements P (B hf : Presieve Y) :=\n    fun Y f hf Z g hg => s _ (Presieve.bind_comp _ _ hg)\n  have hy : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (hf : U f), (y hf).Compatible := by\n    intro Y f H Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ comm\n    apply hs\n    apply reassoc_of% comm\n  let t : Presieve.FamilyOfElements P (U : Presieve X) :=\n    fun Y f hf => (hB hf).amalgamate (y hf) (hy hf)\n  have ht : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (hf : U f), (y hf).IsAmalgamation (t f hf) := fun Y f hf =>\n    (hB hf).isAmalgamation _\n  have hT : t.Compatible := by\n    rw [Presieve.compatible_iff_sieveCompatible]\n    intro Z W f h hf\n    apply (hB (U.downward_closed hf h)).isSeparatedFor.ext\n    intro Y l hl\n    apply (hB' hf (l ‚â´ h)).ext\n    intro M m hm\n    have : bind U B (m ‚â´ l ‚â´ h ‚â´ f) := by simpa using (Presieve.bind_comp f hf hm : bind U B _)\n    trans s (m ‚â´ l ‚â´ h ‚â´ f) this\n    ¬∑ have := ht (U.downward_closed hf h) _ ((B _).downward_closed hl m)\n      rw [op_comp, FunctorToTypes.map_comp_apply] at this\n      rw [this]\n      change s _ _ = s _ _\n      -- Porting note: the proof was `by simp`\n      congr 1\n      simp only [assoc]\n    ¬∑ have h : s _ _ = _ := (ht hf _ hm).symm\n      -- Porting note: this was done by `simp only [assoc] at`\n      conv_lhs at h => congr; rw [assoc, assoc]\n      rw [h]\n      simp only [op_comp, assoc, FunctorToTypes.map_comp_apply]\n  refine ‚ü®hU.amalgamate t hT, ?_, ?_‚ü©\n  ¬∑ rintro Z _ ‚ü®Y, f, g, hg, hf, rfl‚ü©\n    rw [op_comp, FunctorToTypes.map_comp_apply, Presieve.IsSheafFor.valid_glue _ _ _ hg]\n    apply ht hg _ hf\n  ¬∑ intro y hy\n    apply hU.isSeparatedFor.ext\n    intro Y f hf\n    apply (hB hf).isSeparatedFor.ext\n    intro Z g hg\n    rw [‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp, hy _ (Presieve.bind_comp _ _ hg),\n      hU.valid_glue _ _ hf, ht hf _ hg]\n\n"}
{"name":"CategoryTheory.Sheaf.isSheafFor_trans","module":"Mathlib.CategoryTheory.Sites.Canonical","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nP : CategoryTheory.Functor (Opposite C) (Type v)\nR S : CategoryTheory.Sieve X\nhR : CategoryTheory.Presieve.IsSheafFor P R.arrows\nhR' : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Quiver.Hom Y X‚¶Ñ, S.arrows f ‚Üí CategoryTheory.Presieve.IsSeparatedFor P (CategoryTheory.Sieve.pullback f R).arrows\nhS : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Quiver.Hom Y X‚¶Ñ, R.arrows f ‚Üí CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Sieve.pullback f S).arrows\n‚ä¢ CategoryTheory.Presieve.IsSheafFor P S.arrows","decl":"/-- Given two sieves `R` and `S`, to show that `P` is a sheaf for `S`, we can show:\n* `P` is a sheaf for `R`\n* `P` is a sheaf for the pullback of `S` along any arrow in `R`\n* `P` is separated for the pullback of `R` along any arrow in `S`.\n\nThis is mostly an auxiliary lemma to construct `finestTopology`.\nAdapted from [Elephant], Lemma C2.1.7(ii) with suggestions as mentioned in\nhttps://math.stackexchange.com/a/358709\n-/\ntheorem isSheafFor_trans (P : C·µí·µñ ‚•§ Type v) (R S : Sieve X)\n    (hR : Presieve.IsSheafFor P (R : Presieve X))\n    (hR' : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (_ : S f), Presieve.IsSeparatedFor P (R.pullback f : Presieve Y))\n    (hS : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (_ : R f), Presieve.IsSheafFor P (S.pullback f : Presieve Y)) :\n    Presieve.IsSheafFor P (S : Presieve X) := by\n  have : (bind R fun Y f _ => S.pullback f : Presieve X) ‚â§ S := by\n    rintro Z f ‚ü®W, f, g, hg, hf : S _, rfl‚ü©\n    apply hf\n  apply Presieve.isSheafFor_subsieve_aux P this\n  ¬∑ apply isSheafFor_bind _ _ _ hR hS\n    intro Y f hf Z g\n    rw [‚Üê pullback_comp]\n    apply (hS (R.downward_closed hf _)).isSeparatedFor\n  ¬∑ intro Y f hf\n    have : Sieve.pullback f (bind R fun T (k : T ‚ü∂ X) (_ : R k) => pullback k S) =\n        R.pullback f := by\n      ext Z g\n      constructor\n      ¬∑ rintro ‚ü®W, k, l, hl, _, comm‚ü©\n        rw [pullback_apply, ‚Üê comm]\n        simp [hl]\n      ¬∑ intro a\n        refine ‚ü®Z, ùüô Z, _, a, ?_‚ü©\n        simp [hf]\n    rw [this]\n    apply hR' hf\n\n"}
{"name":"CategoryTheory.Sheaf.sheaf_for_finestTopology","module":"Mathlib.CategoryTheory.Sites.Canonical","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type v)\nPs : Set (CategoryTheory.Functor (Opposite C) (Type v))\nh : Membership.mem Ps P\n‚ä¢ CategoryTheory.Presieve.IsSheaf (CategoryTheory.Sheaf.finestTopology Ps) P","decl":"/-- Check that if `P ‚àà Ps`, then `P` is indeed a sheaf for the finest topology on `Ps`. -/\ntheorem sheaf_for_finestTopology (Ps : Set (C·µí·µñ ‚•§ Type v)) (h : P ‚àà Ps) :\n    Presieve.IsSheaf (finestTopology Ps) P := fun X S hS => by\n  simpa using hS _ ‚ü®‚ü®_, _, ‚ü®_, h, rfl‚ü©, rfl‚ü©, rfl‚ü© _ (ùüô _)\n\n"}
{"name":"CategoryTheory.Sheaf.le_finestTopology","module":"Mathlib.CategoryTheory.Sites.Canonical","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nPs : Set (CategoryTheory.Functor (Opposite C) (Type v))\nJ : CategoryTheory.GrothendieckTopology C\nhJ : ‚àÄ (P : CategoryTheory.Functor (Opposite C) (Type v)), Membership.mem Ps P ‚Üí CategoryTheory.Presieve.IsSheaf J P\n‚ä¢ LE.le J (CategoryTheory.Sheaf.finestTopology Ps)","decl":"/--\nCheck that if each `P ‚àà Ps` is a sheaf for `J`, then `J` is a subtopology of `finestTopology Ps`.\n-/\ntheorem le_finestTopology (Ps : Set (C·µí·µñ ‚•§ Type v)) (J : GrothendieckTopology C)\n    (hJ : ‚àÄ P ‚àà Ps, Presieve.IsSheaf J P) : J ‚â§ finestTopology Ps := by\n  rintro X S hS _ ‚ü®‚ü®_, _, ‚ü®P, hP, rfl‚ü©, rfl‚ü©, rfl‚ü©\n  intro Y f\n  -- this can't be combined with the previous because the `subst` is applied at the end\n  exact hJ P hP (S.pullback f) (J.pullback_stable f hS)\n\n"}
{"name":"CategoryTheory.Sheaf.isSheaf_yoneda_obj","module":"Mathlib.CategoryTheory.Sites.Canonical","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\n‚ä¢ CategoryTheory.Presieve.IsSheaf (CategoryTheory.Sheaf.canonicalTopology C) (CategoryTheory.yoneda.obj X)","decl":"/-- `yoneda.obj X` is a sheaf for the canonical topology. -/\ntheorem isSheaf_yoneda_obj (X : C) : Presieve.IsSheaf (canonicalTopology C) (yoneda.obj X) :=\n  fun _ _ hS => sheaf_for_finestTopology _ (Set.mem_range_self _) _ hS\n\n"}
{"name":"CategoryTheory.Sheaf.isSheaf_of_isRepresentable","module":"Mathlib.CategoryTheory.Sites.Canonical","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type v)\ninst‚úù : P.IsRepresentable\n‚ä¢ CategoryTheory.Presieve.IsSheaf (CategoryTheory.Sheaf.canonicalTopology C) P","decl":"/-- A representable functor is a sheaf for the canonical topology. -/\ntheorem isSheaf_of_isRepresentable (P : C·µí·µñ ‚•§ Type v) [P.IsRepresentable] :\n    Presieve.IsSheaf (canonicalTopology C) P :=\n  Presieve.isSheaf_iso (canonicalTopology C) P.reprW (isSheaf_yoneda_obj _)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Subcanonical.le_canonical","module":"Mathlib.CategoryTheory.Sites.Canonical","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nself : J.Subcanonical\n‚ä¢ LE.le J (CategoryTheory.Sheaf.canonicalTopology C)","decl":"/-- A subcanonical topology is a topology which is smaller than the canonical topology.\nEquivalently, a topology is subcanonical iff every representable is a sheaf.\n-/\nclass Subcanonical (J : GrothendieckTopology C) : Prop where\n  le_canonical : J ‚â§ canonicalTopology C\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.le_canonical","module":"Mathlib.CategoryTheory.Sites.Canonical","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst‚úù : J.Subcanonical\n‚ä¢ LE.le J (CategoryTheory.Sheaf.canonicalTopology C)","decl":"lemma le_canonical (J : GrothendieckTopology C) [Subcanonical J] : J ‚â§ canonicalTopology C :=\n  Subcanonical.le_canonical\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.instSubcanonicalCanonicalTopology","module":"Mathlib.CategoryTheory.Sites.Canonical","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ (CategoryTheory.Sheaf.canonicalTopology C).Subcanonical","decl":"instance : (canonicalTopology C).Subcanonical where\n  le_canonical := le_rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Subcanonical.of_isSheaf_yoneda_obj","module":"Mathlib.CategoryTheory.Sites.Canonical","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nh : ‚àÄ (X : C), CategoryTheory.Presieve.IsSheaf J (CategoryTheory.yoneda.obj X)\n‚ä¢ J.Subcanonical","decl":"/-- If every functor `yoneda.obj X` is a `J`-sheaf, then `J` is subcanonical. -/\ntheorem of_isSheaf_yoneda_obj (J : GrothendieckTopology C)\n    (h : ‚àÄ X, Presieve.IsSheaf J (yoneda.obj X)) : Subcanonical J where\n  le_canonical := le_finestTopology _ _ (by rintro P ‚ü®X, rfl‚ü©; apply h)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Subcanonical.isSheaf_of_isRepresentable","module":"Mathlib.CategoryTheory.Sites.Canonical","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst‚úù¬π : J.Subcanonical\nP : CategoryTheory.Functor (Opposite C) (Type v)\ninst‚úù : P.IsRepresentable\n‚ä¢ CategoryTheory.Presieve.IsSheaf J P","decl":"/-- If `J` is subcanonical, then any representable is a `J`-sheaf. -/\ntheorem isSheaf_of_isRepresentable {J : GrothendieckTopology C} [Subcanonical J]\n    (P : C·µí·µñ ‚•§ Type v) [P.IsRepresentable] : Presieve.IsSheaf J P :=\n  Presieve.isSheaf_of_le _ J.le_canonical (Sheaf.isSheaf_of_isRepresentable P)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.yoneda_map_val","module":"Mathlib.CategoryTheory.Sites.Canonical","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst‚úù : J.Subcanonical\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (J.yoneda.map f).val (CategoryTheory.yoneda.map f)","decl":"/--\nIf `J` is subcanonical, we obtain a \"Yoneda\" functor from the defining site\ninto the sheaf category.\n-/\n@[simps]\ndef yoneda [J.Subcanonical] : C ‚•§ Sheaf J (Type v) where\n  obj X := ‚ü®CategoryTheory.yoneda.obj X, by\n    rw [isSheaf_iff_isSheaf_of_type]\n    apply Subcanonical.isSheaf_of_isRepresentable‚ü©\n  map f := ‚ü®CategoryTheory.yoneda.map f‚ü©\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.yoneda_obj_val","module":"Mathlib.CategoryTheory.Sites.Canonical","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst‚úù : J.Subcanonical\nX : C\n‚ä¢ Eq (J.yoneda.obj X).val (CategoryTheory.yoneda.obj X)","decl":"/--\nIf `J` is subcanonical, we obtain a \"Yoneda\" functor from the defining site\ninto the sheaf category.\n-/\n@[simps]\ndef yoneda [J.Subcanonical] : C ‚•§ Sheaf J (Type v) where\n  obj X := ‚ü®CategoryTheory.yoneda.obj X, by\n    rw [isSheaf_iff_isSheaf_of_type]\n    apply Subcanonical.isSheaf_of_isRepresentable‚ü©\n  map f := ‚ü®CategoryTheory.yoneda.map f‚ü©\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.instFullSheafTypeYoneda","module":"Mathlib.CategoryTheory.Sites.Canonical","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst‚úù : J.Subcanonical\n‚ä¢ J.yoneda.Full","decl":"instance : (J.yoneda).Full := (J.yonedaFullyFaithful).full\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.instFaithfulSheafTypeYoneda","module":"Mathlib.CategoryTheory.Sites.Canonical","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst‚úù : J.Subcanonical\n‚ä¢ J.yoneda.Faithful","decl":"instance : (J.yoneda).Faithful := (J.yonedaFullyFaithful).faithful\n\n"}
{"name":"CategoryTheory.Sheaf.Subcanonical.of_isSheaf_yoneda_obj","module":"Mathlib.CategoryTheory.Sites.Canonical","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nh : ‚àÄ (X : C), CategoryTheory.Presieve.IsSheaf J (CategoryTheory.yoneda.obj X)\n‚ä¢ J.Subcanonical","decl":"@[deprecated (since := \"2024-10-29\")] alias Sheaf.Subcanonical.of_isSheaf_yoneda_obj :=\n  GrothendieckTopology.Subcanonical.of_isSheaf_yoneda_obj\n"}
{"name":"CategoryTheory.Sheaf.Subcanonical.isSheaf_of_isRepresentable","module":"Mathlib.CategoryTheory.Sites.Canonical","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst‚úù¬π : J.Subcanonical\nP : CategoryTheory.Functor (Opposite C) (Type v)\ninst‚úù : P.IsRepresentable\n‚ä¢ CategoryTheory.Presieve.IsSheaf J P","decl":"@[deprecated (since := \"2024-10-29\")] alias Sheaf.Subcanonical.isSheaf_of_isRepresentable :=\n  GrothendieckTopology.Subcanonical.isSheaf_of_isRepresentable\n"}
