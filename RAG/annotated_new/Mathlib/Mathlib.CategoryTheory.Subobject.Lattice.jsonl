{"name":"CategoryTheory.MonoOver.top_left","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq Top.top.obj.left X","decl":"@[simp]\ntheorem top_left (X : C) : ((‚ä§ : MonoOver X) : C) = X :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonoOver.top_arrow","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq Top.top.arrow (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\ntheorem top_arrow (X : C) : (‚ä§ : MonoOver X).arrow = ùüô X :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonoOver.bot_left","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Limits.HasInitial C\ninst‚úù : CategoryTheory.Limits.InitialMonoClass C\nX : C\n‚ä¢ Eq Bot.bot.obj.left (CategoryTheory.Limits.initial C)","decl":"@[simp]\ntheorem bot_left (X : C) : ((‚ä• : MonoOver X) : C) = ‚ä•_ C :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonoOver.bot_arrow","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Limits.HasInitial C\ninst‚úù : CategoryTheory.Limits.InitialMonoClass C\nX : C\n‚ä¢ Eq Bot.bot.arrow (CategoryTheory.Limits.initial.to X)","decl":"@[simp]\ntheorem bot_arrow {X : C} : (‚ä• : MonoOver X).arrow = initial.to X :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonoOver.bot_arrow_eq_zero","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nB : C\n‚ä¢ Eq Bot.bot.arrow 0","decl":"theorem bot_arrow_eq_zero [HasZeroMorphisms C] {B : C} : (‚ä• : MonoOver B).arrow = 0 :=\n  zero_of_source_iso_zero _ botCoeIsoZero\n\n"}
{"name":"CategoryTheory.MonoOver.inf_obj","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nA : C\nf : CategoryTheory.MonoOver A\n‚ä¢ Eq (CategoryTheory.MonoOver.inf.obj f) ((CategoryTheory.MonoOver.pullback f.arrow).comp (CategoryTheory.MonoOver.map f.arrow))","decl":"/-- When `[HasPullbacks C]`, `MonoOver A` has \"intersections\", functorial in both arguments.\n\nAs `MonoOver A` is only a preorder, this doesn't satisfy the axioms of `SemilatticeInf`,\nbut we reuse all the names from `SemilatticeInf` because they will be used to construct\n`SemilatticeInf (subobject A)` shortly.\n-/\n@[simps]\ndef inf {A : C} : MonoOver A ‚•§ MonoOver A ‚•§ MonoOver A where\n  obj f := pullback f.arrow ‚ãô map f.arrow\n  map k :=\n    { app := fun g => by\n        apply homMk _ _\n        ¬∑ apply pullback.lift (pullback.fst _ _) (pullback.snd _ _ ‚â´ k.left) _\n          rw [pullback.condition, assoc, w k]\n        dsimp\n        rw [pullback.lift_snd_assoc, assoc, w k] }\n\n"}
{"name":"CategoryTheory.MonoOver.inf_map_app","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nA : C\nX‚úù Y‚úù : CategoryTheory.MonoOver A\nk : Quiver.Hom X‚úù Y‚úù\ng : CategoryTheory.MonoOver A\n‚ä¢ Eq ((CategoryTheory.MonoOver.inf.map k).app g) (CategoryTheory.MonoOver.homMk (CategoryTheory.Limits.pullback.lift (CategoryTheory.Limits.pullback.fst ((CategoryTheory.MonoOver.forget A).obj g).hom X‚úù.arrow) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd ((CategoryTheory.MonoOver.forget A).obj g).hom X‚úù.arrow) k.left) ‚ãØ) ‚ãØ)","decl":"/-- When `[HasPullbacks C]`, `MonoOver A` has \"intersections\", functorial in both arguments.\n\nAs `MonoOver A` is only a preorder, this doesn't satisfy the axioms of `SemilatticeInf`,\nbut we reuse all the names from `SemilatticeInf` because they will be used to construct\n`SemilatticeInf (subobject A)` shortly.\n-/\n@[simps]\ndef inf {A : C} : MonoOver A ‚•§ MonoOver A ‚•§ MonoOver A where\n  obj f := pullback f.arrow ‚ãô map f.arrow\n  map k :=\n    { app := fun g => by\n        apply homMk _ _\n        ¬∑ apply pullback.lift (pullback.fst _ _) (pullback.snd _ _ ‚â´ k.left) _\n          rw [pullback.condition, assoc, w k]\n        dsimp\n        rw [pullback.lift_snd_assoc, assoc, w k] }\n\n"}
{"name":"CategoryTheory.Subobject.top_eq_id","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB : C\n‚ä¢ Eq Top.top (CategoryTheory.Subobject.mk (CategoryTheory.CategoryStruct.id B))","decl":"theorem top_eq_id (B : C) : (‚ä§ : Subobject B) = Subobject.mk (ùüô B) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subobject.underlyingIso_top_hom","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB : C\n‚ä¢ Eq (CategoryTheory.Subobject.underlyingIso (CategoryTheory.CategoryStruct.id B)).hom Top.top.arrow","decl":"theorem underlyingIso_top_hom {B : C} : (underlyingIso (ùüô B)).hom = (‚ä§ : Subobject B).arrow := by\n  convert underlyingIso_hom_comp_eq_mk (ùüô B)\n  simp only [comp_id]\n\n"}
{"name":"CategoryTheory.Subobject.top_arrow_isIso","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB : C\n‚ä¢ CategoryTheory.IsIso Top.top.arrow","decl":"instance top_arrow_isIso {B : C} : IsIso (‚ä§ : Subobject B).arrow := by\n  rw [‚Üê underlyingIso_top_hom]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Subobject.underlyingIso_inv_top_arrow","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.underlyingIso (CategoryTheory.CategoryStruct.id B)).inv Top.top.arrow) (CategoryTheory.CategoryStruct.id B)","decl":"@[reassoc (attr := simp)]\ntheorem underlyingIso_inv_top_arrow {B : C} :\n    (underlyingIso _).inv ‚â´ (‚ä§ : Subobject B).arrow = ùüô B :=\n  underlyingIso_arrow _\n\n"}
{"name":"CategoryTheory.Subobject.underlyingIso_inv_top_arrow_assoc","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB Z : C\nh : Quiver.Hom B Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.underlyingIso (CategoryTheory.CategoryStruct.id B)).inv (CategoryTheory.CategoryStruct.comp Top.top.arrow h)) h","decl":"@[reassoc (attr := simp)]\ntheorem underlyingIso_inv_top_arrow {B : C} :\n    (underlyingIso _).inv ‚â´ (‚ä§ : Subobject B).arrow = ùüô B :=\n  underlyingIso_arrow _\n\n"}
{"name":"CategoryTheory.Subobject.map_top","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ Eq ((CategoryTheory.Subobject.map f).obj Top.top) (CategoryTheory.Subobject.mk f)","decl":"@[simp]\ntheorem map_top (f : X ‚ü∂ Y) [Mono f] : (map f).obj ‚ä§ = Subobject.mk f :=\n  Quotient.sound' ‚ü®MonoOver.mapTop f‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.top_factors","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA B : C\nf : Quiver.Hom A B\n‚ä¢ Top.top.Factors f","decl":"theorem top_factors {A B : C} (f : A ‚ü∂ B) : (‚ä§ : Subobject B).Factors f :=\n  ‚ü®f, comp_id _‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.isIso_iff_mk_eq_top","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ Iff (CategoryTheory.IsIso f) (Eq (CategoryTheory.Subobject.mk f) Top.top)","decl":"theorem isIso_iff_mk_eq_top {X Y : C} (f : X ‚ü∂ Y) [Mono f] : IsIso f ‚Üî mk f = ‚ä§ :=\n  ‚ü®fun _ => mk_eq_mk_of_comm _ _ (asIso f) (Category.comp_id _), fun h => by\n    rw [‚Üê ofMkLEMk_comp h.le, Category.comp_id]\n    exact (isoOfMkEqMk _ _ h).isIso_hom‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.isIso_arrow_iff_eq_top","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nY : C\nP : CategoryTheory.Subobject Y\n‚ä¢ Iff (CategoryTheory.IsIso P.arrow) (Eq P Top.top)","decl":"theorem isIso_arrow_iff_eq_top {Y : C} (P : Subobject Y) : IsIso P.arrow ‚Üî P = ‚ä§ := by\n  rw [isIso_iff_mk_eq_top, mk_arrow]\n\n"}
{"name":"CategoryTheory.Subobject.isIso_top_arrow","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nY : C\n‚ä¢ CategoryTheory.IsIso Top.top.arrow","decl":"instance isIso_top_arrow {Y : C} : IsIso (‚ä§ : Subobject Y).arrow := by rw [isIso_arrow_iff_eq_top]\n\n"}
{"name":"CategoryTheory.Subobject.mk_eq_top_of_isIso","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ Eq (CategoryTheory.Subobject.mk f) Top.top","decl":"theorem mk_eq_top_of_isIso {X Y : C} (f : X ‚ü∂ Y) [IsIso f] : mk f = ‚ä§ :=\n  (isIso_iff_mk_eq_top f).mp inferInstance\n\n"}
{"name":"CategoryTheory.Subobject.eq_top_of_isIso_arrow","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nY : C\nP : CategoryTheory.Subobject Y\ninst‚úù : CategoryTheory.IsIso P.arrow\n‚ä¢ Eq P Top.top","decl":"theorem eq_top_of_isIso_arrow {Y : C} (P : Subobject Y) [IsIso P.arrow] : P = ‚ä§ :=\n  (isIso_arrow_iff_eq_top P).mp inferInstance\n\n"}
{"name":"CategoryTheory.Subobject.pullback_top","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Subobject.pullback f).obj Top.top) Top.top","decl":"theorem pullback_top (f : X ‚ü∂ Y) : (pullback f).obj ‚ä§ = ‚ä§ :=\n  Quotient.sound' ‚ü®MonoOver.pullbackTop f‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.pullback_self","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Limits.HasPullbacks C\nA B : C\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ Eq ((CategoryTheory.Subobject.pullback f).obj (CategoryTheory.Subobject.mk f)) Top.top","decl":"theorem pullback_self {A B : C} (f : A ‚ü∂ B) [Mono f] : (pullback f).obj (mk f) = ‚ä§ :=\n  Quotient.sound' ‚ü®MonoOver.pullbackSelf f‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.bot_eq_initial_to","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Limits.HasInitial C\ninst‚úù : CategoryTheory.Limits.InitialMonoClass C\nB : C\n‚ä¢ Eq Bot.bot (CategoryTheory.Subobject.mk (CategoryTheory.Limits.initial.to B))","decl":"theorem bot_eq_initial_to {B : C} : (‚ä• : Subobject B) = Subobject.mk (initial.to B) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subobject.map_bot","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasInitial C\ninst‚úù¬π : CategoryTheory.Limits.InitialMonoClass C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ Eq ((CategoryTheory.Subobject.map f).obj Bot.bot) Bot.bot","decl":"theorem map_bot (f : X ‚ü∂ Y) [Mono f] : (map f).obj ‚ä• = ‚ä• :=\n  Quotient.sound' ‚ü®MonoOver.mapBot f‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.bot_eq_zero","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nB : C\n‚ä¢ Eq Bot.bot (CategoryTheory.Subobject.mk 0)","decl":"theorem bot_eq_zero {B : C} : (‚ä• : Subobject B) = Subobject.mk (0 : 0 ‚ü∂ B) :=\n  mk_eq_mk_of_comm _ _ (initialIsInitial.uniqueUpToIso HasZeroObject.zeroIsInitial)\n    (by simp [eq_iff_true_of_subsingleton])\n\n"}
{"name":"CategoryTheory.Subobject.bot_arrow","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nB : C\n‚ä¢ Eq Bot.bot.arrow 0","decl":"@[simp]\ntheorem bot_arrow {B : C} : (‚ä• : Subobject B).arrow = 0 :=\n  zero_of_source_iso_zero _ botCoeIsoZero\n\n"}
{"name":"CategoryTheory.Subobject.bot_factors_iff_zero","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nA B : C\nf : Quiver.Hom A B\n‚ä¢ Iff (Bot.bot.Factors f) (Eq f 0)","decl":"theorem bot_factors_iff_zero {A B : C} (f : A ‚ü∂ B) : (‚ä• : Subobject B).Factors f ‚Üî f = 0 :=\n  ‚ü®by\n    rintro ‚ü®h, rfl‚ü©\n    simp only [MonoOver.bot_arrow_eq_zero, Functor.id_obj, Functor.const_obj_obj,\n      MonoOver.bot_left, comp_zero],\n   by\n    rintro rfl\n    exact ‚ü®0, by simp‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.mk_eq_bot_iff_zero","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ Iff (Eq (CategoryTheory.Subobject.mk f) Bot.bot) (Eq f 0)","decl":"theorem mk_eq_bot_iff_zero {f : X ‚ü∂ Y} [Mono f] : Subobject.mk f = ‚ä• ‚Üî f = 0 :=\n  ‚ü®fun h => by simpa [h, bot_factors_iff_zero] using mk_factors_self f, fun h =>\n    mk_eq_mk_of_comm _ _ ((isoZeroOfMonoEqZero h).trans HasZeroObject.zeroIsoInitial) (by simp [h])‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.functor_obj","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX : Opposite C\n‚ä¢ Eq ((CategoryTheory.Subobject.functor C).obj X) (CategoryTheory.Subobject (Opposite.unop X))","decl":"/-- Sending `X : C` to `Subobject X` is a contravariant functor `C·µí·µñ ‚•§ Type`. -/\n@[simps]\ndef functor [HasPullbacks C] : C·µí·µñ ‚•§ Type max u‚ÇÅ v‚ÇÅ where\n  obj X := Subobject X.unop\n  map f := (pullback f.unop).obj\n  map_id _ := funext pullback_id\n  map_comp _ _ := funext (pullback_comp _ _)\n\n"}
{"name":"CategoryTheory.Subobject.functor_map","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX‚úù Y‚úù : Opposite C\nf : Quiver.Hom X‚úù Y‚úù\na‚úù : CategoryTheory.Subobject (Opposite.unop X‚úù)\n‚ä¢ Eq ((CategoryTheory.Subobject.functor C).map f a‚úù) ((CategoryTheory.Subobject.pullback f.unop).obj a‚úù)","decl":"/-- Sending `X : C` to `Subobject X` is a contravariant functor `C·µí·µñ ‚•§ Type`. -/\n@[simps]\ndef functor [HasPullbacks C] : C·µí·µñ ‚•§ Type max u‚ÇÅ v‚ÇÅ where\n  obj X := Subobject X.unop\n  map f := (pullback f.unop).obj\n  map_id _ := funext pullback_id\n  map_comp _ _ := funext (pullback_comp _ _)\n\n"}
{"name":"CategoryTheory.Subobject.inf_le_left","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nA : C\nf g : CategoryTheory.Subobject A\n‚ä¢ LE.le ((CategoryTheory.Subobject.inf.obj f).obj g) f","decl":"theorem inf_le_left {A : C} (f g : Subobject A) : (inf.obj f).obj g ‚â§ f :=\n  Quotient.inductionOn‚ÇÇ' f g fun _ _ => ‚ü®MonoOver.infLELeft _ _‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.inf_le_right","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nA : C\nf g : CategoryTheory.Subobject A\n‚ä¢ LE.le ((CategoryTheory.Subobject.inf.obj f).obj g) g","decl":"theorem inf_le_right {A : C} (f g : Subobject A) : (inf.obj f).obj g ‚â§ g :=\n  Quotient.inductionOn‚ÇÇ' f g fun _ _ => ‚ü®MonoOver.infLERight _ _‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.le_inf","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nA : C\nh f g : CategoryTheory.Subobject A\na‚úù¬π : LE.le h f\na‚úù : LE.le h g\n‚ä¢ LE.le h ((CategoryTheory.Subobject.inf.obj f).obj g)","decl":"theorem le_inf {A : C} (h f g : Subobject A) : h ‚â§ f ‚Üí h ‚â§ g ‚Üí h ‚â§ (inf.obj f).obj g :=\n  Quotient.inductionOn‚ÇÉ' h f g\n    (by\n      rintro f g h ‚ü®k‚ü© ‚ü®l‚ü©\n      exact ‚ü®MonoOver.leInf _ _ _ k l‚ü©)\n\n"}
{"name":"CategoryTheory.Subobject.factors_left_of_inf_factors","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nA B : C\nX Y : CategoryTheory.Subobject B\nf : Quiver.Hom A B\nh : (Min.min X Y).Factors f\n‚ä¢ X.Factors f","decl":"theorem factors_left_of_inf_factors {A B : C} {X Y : Subobject B} {f : A ‚ü∂ B}\n    (h : (X ‚äì Y).Factors f) : X.Factors f :=\n  factors_of_le _ (inf_le_left _ _) h\n\n"}
{"name":"CategoryTheory.Subobject.factors_right_of_inf_factors","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nA B : C\nX Y : CategoryTheory.Subobject B\nf : Quiver.Hom A B\nh : (Min.min X Y).Factors f\n‚ä¢ Y.Factors f","decl":"theorem factors_right_of_inf_factors {A B : C} {X Y : Subobject B} {f : A ‚ü∂ B}\n    (h : (X ‚äì Y).Factors f) : Y.Factors f :=\n  factors_of_le _ (inf_le_right _ _) h\n\n"}
{"name":"CategoryTheory.Subobject.inf_factors","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nA B : C\nX Y : CategoryTheory.Subobject B\nf : Quiver.Hom A B\n‚ä¢ Iff ((Min.min X Y).Factors f) (And (X.Factors f) (Y.Factors f))","decl":"@[simp]\ntheorem inf_factors {A B : C} {X Y : Subobject B} (f : A ‚ü∂ B) :\n    (X ‚äì Y).Factors f ‚Üî X.Factors f ‚àß Y.Factors f :=\n  ‚ü®fun h => ‚ü®factors_left_of_inf_factors h, factors_right_of_inf_factors h‚ü©, by\n    revert X Y\n    apply Quotient.ind‚ÇÇ'\n    rintro X Y ‚ü®‚ü®g‚ÇÅ, rfl‚ü©, ‚ü®g‚ÇÇ, hg‚ÇÇ‚ü©‚ü©\n    exact ‚ü®_, pullback.lift_snd_assoc _ _ hg‚ÇÇ _‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.inf_arrow_factors_left","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nB : C\nX Y : CategoryTheory.Subobject B\n‚ä¢ X.Factors (Min.min X Y).arrow","decl":"theorem inf_arrow_factors_left {B : C} (X Y : Subobject B) : X.Factors (X ‚äì Y).arrow :=\n  (factors_iff _ _).mpr ‚ü®ofLE (X ‚äì Y) X (inf_le_left X Y), by simp‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.inf_arrow_factors_right","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nB : C\nX Y : CategoryTheory.Subobject B\n‚ä¢ Y.Factors (Min.min X Y).arrow","decl":"theorem inf_arrow_factors_right {B : C} (X Y : Subobject B) : Y.Factors (X ‚äì Y).arrow :=\n  (factors_iff _ _).mpr ‚ü®ofLE (X ‚äì Y) Y (inf_le_right X Y), by simp‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.finset_inf_factors","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nI : Type u_1\nA B : C\ns : Finset I\nP : I ‚Üí CategoryTheory.Subobject B\nf : Quiver.Hom A B\n‚ä¢ Iff ((s.inf P).Factors f) (‚àÄ (i : I), Membership.mem s i ‚Üí (P i).Factors f)","decl":"@[simp]\ntheorem finset_inf_factors {I : Type*} {A B : C} {s : Finset I} {P : I ‚Üí Subobject B} (f : A ‚ü∂ B) :\n    (s.inf P).Factors f ‚Üî ‚àÄ i ‚àà s, (P i).Factors f := by\n  classical\n  induction s using Finset.induction_on with\n  | empty => simp [top_factors]\n  | insert _ ih => simp [ih]\n\n-- `i` is explicit here because often we'd like to defer a proof of `m`\n"}
{"name":"CategoryTheory.Subobject.finset_inf_arrow_factors","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nI : Type u_1\nB : C\ns : Finset I\nP : I ‚Üí CategoryTheory.Subobject B\ni : I\nm : Membership.mem s i\n‚ä¢ (P i).Factors (s.inf P).arrow","decl":"theorem finset_inf_arrow_factors {I : Type*} {B : C} (s : Finset I) (P : I ‚Üí Subobject B) (i : I)\n    (m : i ‚àà s) : (P i).Factors (s.inf P).arrow := by\n  classical\n  revert i m\n  induction s using Finset.induction_on with\n  | empty => rintro _ ‚ü®‚ü©\n  | insert _ ih =>\n    intro _ m\n    rw [Finset.inf_insert]\n    simp only [Finset.mem_insert] at m\n    rcases m with (rfl | m)\n    ¬∑ rw [‚Üê factorThru_arrow _ _ (inf_arrow_factors_left _ _)]\n      exact factors_comp_arrow _\n    ¬∑ rw [‚Üê factorThru_arrow _ _ (inf_arrow_factors_right _ _)]\n      apply factors_of_factors_right\n      exact ih _ m\n\n"}
{"name":"CategoryTheory.Subobject.inf_eq_map_pullback'","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nA : C\nf‚ÇÅ : CategoryTheory.MonoOver A\nf‚ÇÇ : CategoryTheory.Subobject A\n‚ä¢ Eq ((CategoryTheory.Subobject.inf.obj (Quotient.mk'' f‚ÇÅ)).obj f‚ÇÇ) ((CategoryTheory.Subobject.map f‚ÇÅ.arrow).obj ((CategoryTheory.Subobject.pullback f‚ÇÅ.arrow).obj f‚ÇÇ))","decl":"theorem inf_eq_map_pullback' {A : C} (f‚ÇÅ : MonoOver A) (f‚ÇÇ : Subobject A) :\n    (Subobject.inf.obj (Quotient.mk'' f‚ÇÅ)).obj f‚ÇÇ =\n      (Subobject.map f‚ÇÅ.arrow).obj ((Subobject.pullback f‚ÇÅ.arrow).obj f‚ÇÇ) := by\n  induction' f‚ÇÇ using Quotient.inductionOn' with f‚ÇÇ\n  rfl\n\n"}
{"name":"CategoryTheory.Subobject.inf_eq_map_pullback","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nA : C\nf‚ÇÅ : CategoryTheory.MonoOver A\nf‚ÇÇ : CategoryTheory.Subobject A\n‚ä¢ Eq (Min.min (Quotient.mk'' f‚ÇÅ) f‚ÇÇ) ((CategoryTheory.Subobject.map f‚ÇÅ.arrow).obj ((CategoryTheory.Subobject.pullback f‚ÇÅ.arrow).obj f‚ÇÇ))","decl":"theorem inf_eq_map_pullback {A : C} (f‚ÇÅ : MonoOver A) (f‚ÇÇ : Subobject A) :\n    (Quotient.mk'' f‚ÇÅ ‚äì f‚ÇÇ : Subobject A) = (map f‚ÇÅ.arrow).obj ((pullback f‚ÇÅ.arrow).obj f‚ÇÇ) :=\n  inf_eq_map_pullback' f‚ÇÅ f‚ÇÇ\n\n"}
{"name":"CategoryTheory.Subobject.prod_eq_inf","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Limits.HasPullbacks C\nA : C\nf‚ÇÅ f‚ÇÇ : CategoryTheory.Subobject A\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct f‚ÇÅ f‚ÇÇ\n‚ä¢ Eq (CategoryTheory.Limits.prod f‚ÇÅ f‚ÇÇ) (Min.min f‚ÇÅ f‚ÇÇ)","decl":"theorem prod_eq_inf {A : C} {f‚ÇÅ f‚ÇÇ : Subobject A} [HasBinaryProduct f‚ÇÅ f‚ÇÇ] :\n    (f‚ÇÅ ‚®Ø f‚ÇÇ) = f‚ÇÅ ‚äì f‚ÇÇ := by\n  apply le_antisymm\n  ¬∑ refine le_inf _ _ _ (Limits.prod.fst.le) (Limits.prod.snd.le)\n  ¬∑ apply leOfHom\n    exact prod.lift (inf_le_left _ _).hom (inf_le_right _ _).hom\n\n"}
{"name":"CategoryTheory.Subobject.inf_def","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nB : C\nm m' : CategoryTheory.Subobject B\n‚ä¢ Eq (Min.min m m') ((CategoryTheory.Subobject.inf.obj m).obj m')","decl":"theorem inf_def {B : C} (m m' : Subobject B) : m ‚äì m' = (inf.obj m).obj m' :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subobject.inf_pullback","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : C\ng : Quiver.Hom X Y\nf‚ÇÅ f‚ÇÇ : CategoryTheory.Subobject Y\n‚ä¢ Eq ((CategoryTheory.Subobject.pullback g).obj (Min.min f‚ÇÅ f‚ÇÇ)) (Min.min ((CategoryTheory.Subobject.pullback g).obj f‚ÇÅ) ((CategoryTheory.Subobject.pullback g).obj f‚ÇÇ))","decl":"/-- `‚äì` commutes with pullback. -/\ntheorem inf_pullback {X Y : C} (g : X ‚ü∂ Y) (f‚ÇÅ f‚ÇÇ) :\n    (pullback g).obj (f‚ÇÅ ‚äì f‚ÇÇ) = (pullback g).obj f‚ÇÅ ‚äì (pullback g).obj f‚ÇÇ := by\n  revert f‚ÇÅ\n  apply Quotient.ind'\n  intro f‚ÇÅ\n  erw [inf_def, inf_def, inf_eq_map_pullback', inf_eq_map_pullback', ‚Üê pullback_comp, ‚Üê\n    map_pullback pullback.condition (pullbackIsPullback f‚ÇÅ.arrow g), ‚Üê pullback_comp,\n    pullback.condition]\n  rfl\n\n"}
{"name":"CategoryTheory.Subobject.inf_map","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Limits.HasPullbacks C\nX Y : C\ng : Quiver.Hom Y X\ninst‚úù : CategoryTheory.Mono g\nf‚ÇÅ f‚ÇÇ : CategoryTheory.Subobject Y\n‚ä¢ Eq ((CategoryTheory.Subobject.map g).obj (Min.min f‚ÇÅ f‚ÇÇ)) (Min.min ((CategoryTheory.Subobject.map g).obj f‚ÇÅ) ((CategoryTheory.Subobject.map g).obj f‚ÇÇ))","decl":"/-- `‚äì` commutes with map. -/\ntheorem inf_map {X Y : C} (g : Y ‚ü∂ X) [Mono g] (f‚ÇÅ f‚ÇÇ) :\n    (map g).obj (f‚ÇÅ ‚äì f‚ÇÇ) = (map g).obj f‚ÇÅ ‚äì (map g).obj f‚ÇÇ := by\n  revert f‚ÇÅ\n  apply Quotient.ind'\n  intro f‚ÇÅ\n  erw [inf_def, inf_def, inf_eq_map_pullback', inf_eq_map_pullback', ‚Üê map_comp]\n  dsimp\n  rw [pullback_comp, pullback_map_self]\n\n"}
{"name":"CategoryTheory.Subobject.sup_factors_of_factors_left","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Limits.HasImages C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts C\nA B : C\nX Y : CategoryTheory.Subobject B\nf : Quiver.Hom A B\nP : X.Factors f\n‚ä¢ (Max.max X Y).Factors f","decl":"theorem sup_factors_of_factors_left {A B : C} {X Y : Subobject B} {f : A ‚ü∂ B} (P : X.Factors f) :\n    (X ‚äî Y).Factors f :=\n  factors_of_le f le_sup_left P\n\n"}
{"name":"CategoryTheory.Subobject.sup_factors_of_factors_right","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Limits.HasImages C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts C\nA B : C\nX Y : CategoryTheory.Subobject B\nf : Quiver.Hom A B\nP : Y.Factors f\n‚ä¢ (Max.max X Y).Factors f","decl":"theorem sup_factors_of_factors_right {A B : C} {X Y : Subobject B} {f : A ‚ü∂ B} (P : Y.Factors f) :\n    (X ‚äî Y).Factors f :=\n  factors_of_le f le_sup_right P\n\n"}
{"name":"CategoryTheory.Subobject.finset_sup_factors","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasImages C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryCoproducts C\ninst‚úù¬π : CategoryTheory.Limits.HasInitial C\ninst‚úù : CategoryTheory.Limits.InitialMonoClass C\nI : Type u_1\nA B : C\ns : Finset I\nP : I ‚Üí CategoryTheory.Subobject B\nf : Quiver.Hom A B\nh : Exists fun i => And (Membership.mem s i) ((P i).Factors f)\n‚ä¢ (s.sup P).Factors f","decl":"theorem finset_sup_factors {I : Type*} {A B : C} {s : Finset I} {P : I ‚Üí Subobject B} {f : A ‚ü∂ B}\n    (h : ‚àÉ i ‚àà s, (P i).Factors f) : (s.sup P).Factors f := by\n  classical\n  revert h\n  induction s using Finset.induction_on with\n  | empty => rintro ‚ü®_, ‚ü®‚ü®‚ü©, _‚ü©‚ü©\n  | insert _ ih =>\n    rintro ‚ü®j, ‚ü®m, h‚ü©‚ü©\n    simp only [Finset.sup_insert]\n    simp only [Finset.mem_insert] at m\n    rcases m with (rfl | m)\n    ¬∑ exact sup_factors_of_factors_left h\n    ¬∑ exact sup_factors_of_factors_right (ih ‚ü®j, ‚ü®m, h‚ü©‚ü©)\n\n"}
{"name":"CategoryTheory.Subobject.wideCospan_map_term","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.LocallySmall.{w, v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.WellPowered.{w, v‚ÇÅ, u‚ÇÅ} C\nA : C\ns : Set (CategoryTheory.Subobject A)\nj : ‚Üë(Set.image (‚áë(equivShrink (CategoryTheory.Subobject A))) s)\n‚ä¢ Eq ((CategoryTheory.Subobject.wideCospan s).map (CategoryTheory.Limits.WidePullbackShape.Hom.term j)) ((equivShrink (CategoryTheory.Subobject A)).symm ‚Üëj).arrow","decl":"@[simp]\ntheorem wideCospan_map_term {A : C} (s : Set (Subobject A)) (j) :\n    (wideCospan s).map (WidePullbackShape.Hom.term j) =\n      ((equivShrink (Subobject A)).symm j).arrow :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subobject.leInfCone_œÄ_app_none","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.LocallySmall.{w, v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.WellPowered.{w, v‚ÇÅ, u‚ÇÅ} C\nA : C\ns : Set (CategoryTheory.Subobject A)\nf : CategoryTheory.Subobject A\nk : ‚àÄ (g : CategoryTheory.Subobject A), Membership.mem s g ‚Üí LE.le f g\n‚ä¢ Eq ((CategoryTheory.Subobject.leInfCone s f k).œÄ.app Option.none) f.arrow","decl":"@[simp]\ntheorem leInfCone_œÄ_app_none {A : C} (s : Set (Subobject A)) (f : Subobject A)\n    (k : ‚àÄ g ‚àà s, f ‚â§ g) : (leInfCone s f k).œÄ.app none = f.arrow :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subobject.widePullbackŒπ_mono","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.LocallySmall.{w, v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.WellPowered.{w, v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasWidePullbacks C\nA : C\ns : Set (CategoryTheory.Subobject A)\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Subobject.widePullbackŒπ s)","decl":"instance widePullbackŒπ_mono {A : C} (s : Set (Subobject A)) : Mono (widePullbackŒπ s) :=\n  ‚ü®fun u v h =>\n    limit.hom_ext fun j => by\n      cases j\n      ¬∑ exact h\n      ¬∑ apply (cancel_mono ((equivShrink (Subobject A)).symm _).arrow).1\n        rw [assoc, assoc]\n        erw [limit.w (wideCospan s) (WidePullbackShape.Hom.term _)]\n        exact h‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.sInf_le","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.LocallySmall.{w, v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.WellPowered.{w, v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasWidePullbacks C\nA : C\ns : Set (CategoryTheory.Subobject A)\nf : CategoryTheory.Subobject A\nhf : Membership.mem s f\n‚ä¢ LE.le (CategoryTheory.Subobject.sInf s) f","decl":"theorem sInf_le {A : C} (s : Set (Subobject A)) (f) (hf : f ‚àà s) : sInf s ‚â§ f := by\n  fapply le_of_comm\n  ¬∑ exact (underlyingIso _).hom ‚â´\n      Limits.limit.œÄ (wideCospan s)\n        (some ‚ü®equivShrink (Subobject A) f,\n          Set.mem_image_of_mem (equivShrink (Subobject A)) hf‚ü©) ‚â´\n      eqToHom (congr_arg (fun X : Subobject A => (X : C)) (Equiv.symm_apply_apply _ _))\n  ¬∑ dsimp [sInf]\n    simp only [Category.comp_id, Category.assoc, ‚Üê underlyingIso_hom_comp_eq_mk,\n      Subobject.arrow_congr, congrArg_mpr_hom_left, Iso.cancel_iso_hom_left]\n    convert limit.w (wideCospan s) (WidePullbackShape.Hom.term _)\n    simp\n\n"}
{"name":"CategoryTheory.Subobject.le_sInf","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.LocallySmall.{w, v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.WellPowered.{w, v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasWidePullbacks C\nA : C\ns : Set (CategoryTheory.Subobject A)\nf : CategoryTheory.Subobject A\nk : ‚àÄ (g : CategoryTheory.Subobject A), Membership.mem s g ‚Üí LE.le f g\n‚ä¢ LE.le f (CategoryTheory.Subobject.sInf s)","decl":"theorem le_sInf {A : C} (s : Set (Subobject A)) (f : Subobject A) (k : ‚àÄ g ‚àà s, f ‚â§ g) :\n    f ‚â§ sInf s := by\n  fapply le_of_comm\n  ¬∑ exact Limits.limit.lift _ (leInfCone s f k) ‚â´ (underlyingIso _).inv\n  ¬∑ dsimp [sInf]\n    rw [assoc, underlyingIso_arrow, widePullbackŒπ, limit.lift_œÄ, leInfCone_œÄ_app_none]\n\n"}
{"name":"CategoryTheory.Subobject.le_sSup","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.LocallySmall.{w, v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.WellPowered.{w, v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Limits.HasCoproducts C\ninst‚úù : CategoryTheory.Limits.HasImages C\nA : C\ns : Set (CategoryTheory.Subobject A)\nf : CategoryTheory.Subobject A\nhf : Membership.mem s f\n‚ä¢ LE.le f (CategoryTheory.Subobject.sSup s)","decl":"theorem le_sSup {A : C} (s : Set (Subobject A)) (f) (hf : f ‚àà s) : f ‚â§ sSup s := by\n  fapply le_of_comm\n  ¬∑ refine eqToHom ?_ ‚â´ Sigma.Œπ _ ‚ü®equivShrink (Subobject A) f, by simpa [Set.mem_image] using hf‚ü©\n      ‚â´ factorThruImage _ ‚â´ (underlyingIso _).inv\n    exact (congr_arg (fun X : Subobject A => (X : C)) (Equiv.symm_apply_apply _ _).symm)\n  ¬∑ simp [sSup, smallCoproductDesc]\n\n"}
{"name":"CategoryTheory.Subobject.symm_apply_mem_iff_mem_image","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ne : Equiv Œ± Œ≤\ns : Set Œ±\nx : Œ≤\n‚ä¢ Iff (Membership.mem s (e.symm x)) (Membership.mem (Set.image (‚áëe) s) x)","decl":"theorem symm_apply_mem_iff_mem_image {Œ± Œ≤ : Type*} (e : Œ± ‚âÉ Œ≤) (s : Set Œ±) (x : Œ≤) :\n    e.symm x ‚àà s ‚Üî x ‚àà e '' s :=\n  ‚ü®fun h => ‚ü®e.symm x, h, by simp‚ü©, by\n    rintro ‚ü®a, m, rfl‚ü©\n    simpa using m‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.sSup_le","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.LocallySmall.{w, v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.WellPowered.{w, v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Limits.HasCoproducts C\ninst‚úù : CategoryTheory.Limits.HasImages C\nA : C\ns : Set (CategoryTheory.Subobject A)\nf : CategoryTheory.Subobject A\nk : ‚àÄ (g : CategoryTheory.Subobject A), Membership.mem s g ‚Üí LE.le g f\n‚ä¢ LE.le (CategoryTheory.Subobject.sSup s) f","decl":"theorem sSup_le {A : C} (s : Set (Subobject A)) (f : Subobject A) (k : ‚àÄ g ‚àà s, g ‚â§ f) :\n    sSup s ‚â§ f := by\n  fapply le_of_comm\n  ¬∑ refine(underlyingIso _).hom ‚â´ image.lift ‚ü®_, f.arrow, ?_, ?_‚ü©\n    ¬∑ refine Sigma.desc ?_\n      rintro ‚ü®g, m‚ü©\n      refine underlying.map (homOfLE (k _ ?_))\n      simpa using m\n    ¬∑ ext\n      dsimp [smallCoproductDesc]\n      simp\n  ¬∑ dsimp [sSup]\n    rw [assoc, image.lift_fac, underlyingIso_hom_comp_eq_mk]\n\n"}
{"name":"CategoryTheory.Subobject.nontrivial_of_not_isZero","module":"Mathlib.CategoryTheory.Subobject.Lattice","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\nX : C\nh : Not (CategoryTheory.Limits.IsZero X)\n‚ä¢ Nontrivial (CategoryTheory.Subobject X)","decl":"/-- A nonzero object has nontrivial subobject lattice. -/\ntheorem nontrivial_of_not_isZero {X : C} (h : ¬¨IsZero X) : Nontrivial (Subobject X) :=\n  ‚ü®‚ü®mk (0 : 0 ‚ü∂ X), mk (ùüô X), fun w => h (IsZero.of_iso (isZero_zero C) (isoOfMkEqMk _ _ w).symm)‚ü©‚ü©\n\n"}
