{"name":"Ideal.toCharacterSpace_apply_eq_zero_of_mem","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\ninstâœÂ³ : NormedCommRing A\ninstâœÂ² : NormedAlgebra Complex A\ninstâœÂ¹ : CompleteSpace A\nI : Ideal A\ninstâœ : I.IsMaximal\na : A\nha : Membership.mem I a\nâŠ¢ Eq (I.toCharacterSpace a) 0","decl":"theorem Ideal.toCharacterSpace_apply_eq_zero_of_mem {a : A} (ha : a âˆˆ I) :\n    I.toCharacterSpace a = 0 := by\n  unfold Ideal.toCharacterSpace\n  simp only [CharacterSpace.equivAlgHom_symm_coe, AlgHom.coe_comp, AlgHom.coe_coe,\n    Quotient.mkâ‚_eq_mk, Function.comp_apply, NormedRing.algEquivComplexOfComplete_symm_apply]\n  simp_rw [Quotient.eq_zero_iff_mem.mpr ha, spectrum.zero_eq]\n  exact Set.eq_of_mem_singleton (Set.singleton_nonempty (0 : â„‚)).some_mem\n\n"}
{"name":"WeakDual.CharacterSpace.exists_apply_eq_zero","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\ninstâœÂ² : NormedCommRing A\ninstâœÂ¹ : NormedAlgebra Complex A\ninstâœ : CompleteSpace A\na : A\nha : Not (IsUnit a)\nâŠ¢ Exists fun f => Eq (f a) 0","decl":"/-- If `a : A` is not a unit, then some character takes the value zero at `a`. This is equivalent\nto `gelfandTransform â„‚ A a` takes the value zero at some character. -/\ntheorem WeakDual.CharacterSpace.exists_apply_eq_zero {a : A} (ha : Â¬IsUnit a) :\n    âˆƒ f : characterSpace â„‚ A, f a = 0 := by\n  obtain âŸ¨M, hM, haMâŸ© := (span {a}).exists_le_maximal (span_singleton_ne_top ha)\n  exact\n    âŸ¨M.toCharacterSpace,\n      M.toCharacterSpace_apply_eq_zero_of_mem\n        (haM (mem_span_singleton.mpr âŸ¨1, (mul_one a).symmâŸ©))âŸ©\n\n"}
{"name":"WeakDual.CharacterSpace.mem_spectrum_iff_exists","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\ninstâœÂ² : NormedCommRing A\ninstâœÂ¹ : NormedAlgebra Complex A\ninstâœ : CompleteSpace A\na : A\nz : Complex\nâŠ¢ Iff (Membership.mem (spectrum Complex a) z) (Exists fun f => Eq (f a) z)","decl":"theorem WeakDual.CharacterSpace.mem_spectrum_iff_exists {a : A} {z : â„‚} :\n    z âˆˆ spectrum â„‚ a â†” âˆƒ f : characterSpace â„‚ A, f a = z := by\n  refine âŸ¨fun hz => ?_, ?_âŸ©\n  Â· obtain âŸ¨f, hfâŸ© := WeakDual.CharacterSpace.exists_apply_eq_zero hz\n    simp only [map_sub, sub_eq_zero, AlgHomClass.commutes] at hf\n    exact âŸ¨_, hf.symmâŸ©\n  Â· rintro âŸ¨f, rflâŸ©\n    exact AlgHom.apply_mem_spectrum f a\n\n"}
{"name":"spectrum.gelfandTransform_eq","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\ninstâœÂ² : NormedCommRing A\ninstâœÂ¹ : NormedAlgebra Complex A\ninstâœ : CompleteSpace A\na : A\nâŠ¢ Eq (spectrum Complex ((WeakDual.gelfandTransform Complex A) a)) (spectrum Complex a)","decl":"/-- The Gelfand transform is spectrum-preserving. -/\ntheorem spectrum.gelfandTransform_eq (a : A) :\n    spectrum â„‚ (gelfandTransform â„‚ A a) = spectrum â„‚ a := by\n  ext z\n  rw [ContinuousMap.spectrum_eq_range, WeakDual.CharacterSpace.mem_spectrum_iff_exists]\n  exact Iff.rfl\n\n"}
{"name":"instNonemptyElemWeakDualComplexCharacterSpaceOfNontrivial","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\ninstâœÂ³ : NormedCommRing A\ninstâœÂ² : NormedAlgebra Complex A\ninstâœÂ¹ : CompleteSpace A\ninstâœ : Nontrivial A\nâŠ¢ Nonempty â†‘(WeakDual.characterSpace Complex A)","decl":"instance [Nontrivial A] : Nonempty (characterSpace â„‚ A) :=\n  âŸ¨Classical.choose <|\n      WeakDual.CharacterSpace.exists_apply_eq_zero <| zero_mem_nonunits.2 zero_ne_oneâŸ©\n\n"}
{"name":"gelfandTransform_map_star","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\ninstâœ : CommCStarAlgebra A\na : A\nâŠ¢ Eq ((WeakDual.gelfandTransform Complex A) (Star.star a)) (Star.star ((WeakDual.gelfandTransform Complex A) a))","decl":"theorem gelfandTransform_map_star (a : A) :\n    gelfandTransform â„‚ A (star a) = star (gelfandTransform â„‚ A a) :=\n  ContinuousMap.ext fun Ï† => map_star Ï† a\n\n"}
{"name":"gelfandTransform_isometry","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\ninstâœ : CommCStarAlgebra A\nâŠ¢ Isometry â‡‘(WeakDual.gelfandTransform Complex A)","decl":"/-- The Gelfand transform is an isometry when the algebra is a Câ‹†-algebra over `â„‚`. -/\ntheorem gelfandTransform_isometry : Isometry (gelfandTransform â„‚ A) := by\n  nontriviality A\n  refine AddMonoidHomClass.isometry_of_norm (gelfandTransform â„‚ A) fun a => ?_\n  /- By `spectrum.gelfandTransform_eq`, the spectra of `star a * a` and its\n    `gelfandTransform` coincide. Therefore, so do their spectral radii, and since they are\n    self-adjoint, so also do their norms. Applying the Câ‹†-property of the norm and taking square\n    roots shows that the norm is preserved. -/\n  have : spectralRadius â„‚ (gelfandTransform â„‚ A (star a * a)) = spectralRadius â„‚ (star a * a) := by\n    unfold spectralRadius; rw [spectrum.gelfandTransform_eq]\n  rw [map_mul, (IsSelfAdjoint.star_mul_self a).spectralRadius_eq_nnnorm, gelfandTransform_map_star,\n    (IsSelfAdjoint.star_mul_self (gelfandTransform â„‚ A a)).spectralRadius_eq_nnnorm] at this\n  simp only [ENNReal.coe_inj, CStarRing.nnnorm_star_mul_self, â† sq] at this\n  simpa only [Function.comp_apply, NNReal.sqrt_sq] using\n    congr_arg (((â†‘) : â„â‰¥0 â†’ â„) âˆ˜ â‡‘NNReal.sqrt) this\n\n"}
{"name":"gelfandTransform_bijective","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\ninstâœ : CommCStarAlgebra A\nâŠ¢ Function.Bijective â‡‘(WeakDual.gelfandTransform Complex A)","decl":"/-- The Gelfand transform is bijective when the algebra is a Câ‹†-algebra over `â„‚`. -/\ntheorem gelfandTransform_bijective : Function.Bijective (gelfandTransform â„‚ A) := by\n  refine âŸ¨(gelfandTransform_isometry A).injective, ?_âŸ©\n  /- The range of `gelfandTransform â„‚ A` is actually a `StarSubalgebra`. The key lemma below may be\n    hard to spot; it's `map_star` coming from `WeakDual.Complex.instStarHomClass`, which is a\n    nontrivial result. -/\n  let rng : StarSubalgebra â„‚ C(characterSpace â„‚ A, â„‚) :=\n    { toSubalgebra := (gelfandTransform â„‚ A).range\n      star_mem' := by\n        rintro - âŸ¨a, rflâŸ©\n        use star a\n        ext1 Ï†\n        dsimp\n        simp only [map_star, RCLike.star_def] }\n  suffices rng = âŠ¤ from\n    fun x => show x âˆˆ rng from this.symm â–¸ StarSubalgebra.mem_top\n  /- Because the `gelfandTransform â„‚ A` is an isometry, it has closed range, and so by the\n    Stone-Weierstrass theorem, it suffices to show that the image of the Gelfand transform separates\n    points in `C(characterSpace â„‚ A, â„‚)` and is closed under `star`. -/\n  have h : rng.topologicalClosure = rng := le_antisymm\n    (StarSubalgebra.topologicalClosure_minimal le_rfl\n      (gelfandTransform_isometry A).isClosedEmbedding.isClosed_range)\n    (StarSubalgebra.le_topologicalClosure _)\n  refine h â–¸ ContinuousMap.starSubalgebra_topologicalClosure_eq_top_of_separatesPoints\n    _ (fun _ _ => ?_)\n  /- Separating points just means that elements of the `characterSpace` which agree at all points\n    of `A` are the same functional, which is just extensionality. -/\n  contrapose!\n  exact fun h => Subtype.ext (ContinuousLinearMap.ext fun a =>\n    h (gelfandTransform â„‚ A a) âŸ¨gelfandTransform â„‚ A a, âŸ¨a, rflâŸ©, rflâŸ©)\n\n"}
{"name":"gelfandStarTransform_symm_apply","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\ninstâœ : CommCStarAlgebra A\naâœ : ContinuousMap (â†‘(WeakDual.characterSpace Complex A)) Complex\nâŠ¢ Eq ((gelfandStarTransform A).symm aâœ) ((â†‘(RingEquiv.ofBijective { toAlgHom := WeakDual.gelfandTransform Complex A, map_star' := â‹¯ } â‹¯)).symm aâœ)","decl":"/-- The Gelfand transform as a `StarAlgEquiv` between a commutative unital Câ‹†-algebra over `â„‚`\nand the continuous functions on its `characterSpace`. -/\n@[simps!]\nnoncomputable def gelfandStarTransform : A â‰ƒâ‹†â‚[â„‚] C(characterSpace â„‚ A, â„‚) :=\n  StarAlgEquiv.ofBijective\n    (show A â†’â‹†â‚[â„‚] C(characterSpace â„‚ A, â„‚) from\n      { gelfandTransform â„‚ A with map_star' := fun x => gelfandTransform_map_star x })\n    (gelfandTransform_bijective A)\n\n"}
{"name":"gelfandStarTransform_apply_apply","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\ninstâœ : CommCStarAlgebra A\na : A\nÏ† : â†‘(WeakDual.characterSpace Complex A)\nâŠ¢ Eq (((gelfandStarTransform A) a) Ï†) (Ï† a)","decl":"/-- The Gelfand transform as a `StarAlgEquiv` between a commutative unital Câ‹†-algebra over `â„‚`\nand the continuous functions on its `characterSpace`. -/\n@[simps!]\nnoncomputable def gelfandStarTransform : A â‰ƒâ‹†â‚[â„‚] C(characterSpace â„‚ A, â„‚) :=\n  StarAlgEquiv.ofBijective\n    (show A â†’â‹†â‚[â„‚] C(characterSpace â„‚ A, â„‚) from\n      { gelfandTransform â„‚ A with map_star' := fun x => gelfandTransform_map_star x })\n    (gelfandTransform_bijective A)\n\n"}
{"name":"WeakDual.CharacterSpace.compContinuousMap_apply","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\nB : Type u_2\nğ•œ : Type u_4\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NormedRing A\ninstâœâ¶ : NormedAlgebra ğ•œ A\ninstâœâµ : CompleteSpace A\ninstâœâ´ : StarRing A\ninstâœÂ³ : NormedRing B\ninstâœÂ² : NormedAlgebra ğ•œ B\ninstâœÂ¹ : CompleteSpace B\ninstâœ : StarRing B\nÏˆ : StarAlgHom ğ•œ A B\nÏ† : â†‘(WeakDual.characterSpace ğ•œ B)\nâŠ¢ Eq ((WeakDual.CharacterSpace.compContinuousMap Ïˆ) Ï†) (WeakDual.CharacterSpace.equivAlgHom.symm ((WeakDual.CharacterSpace.equivAlgHom Ï†).comp Ïˆ.toAlgHom))","decl":"/-- The functorial map taking `Ïˆ : A â†’â‹†â‚[â„‚] B` to a continuous function\n`characterSpace â„‚ B â†’ characterSpace â„‚ A` obtained by pre-composition with `Ïˆ`. -/\n@[simps]\nnoncomputable def compContinuousMap (Ïˆ : A â†’â‹†â‚[ğ•œ] B) :\n    C(characterSpace ğ•œ B, characterSpace ğ•œ A) where\n  toFun Ï† := equivAlgHom.symm ((equivAlgHom Ï†).comp Ïˆ.toAlgHom)\n  continuous_toFun :=\n    Continuous.subtype_mk\n      (continuous_of_continuous_eval fun a => map_continuous <| gelfandTransform ğ•œ B (Ïˆ a)) _\n\n"}
{"name":"WeakDual.CharacterSpace.compContinuousMap_id","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\nğ•œ : Type u_4\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedRing A\ninstâœÂ² : NormedAlgebra ğ•œ A\ninstâœÂ¹ : CompleteSpace A\ninstâœ : StarRing A\nâŠ¢ Eq (WeakDual.CharacterSpace.compContinuousMap (StarAlgHom.id ğ•œ A)) (ContinuousMap.id â†‘(WeakDual.characterSpace ğ•œ A))","decl":"/-- `WeakDual.CharacterSpace.compContinuousMap` sends the identity to the identity. -/\n@[simp]\ntheorem compContinuousMap_id :\n    compContinuousMap (StarAlgHom.id ğ•œ A) = ContinuousMap.id (characterSpace ğ•œ A) :=\n  ContinuousMap.ext fun _a => ext fun _x => rfl\n\n"}
{"name":"WeakDual.CharacterSpace.compContinuousMap_comp","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\nB : Type u_2\nC : Type u_3\nğ•œ : Type u_4\ninstâœÂ¹Â² : NontriviallyNormedField ğ•œ\ninstâœÂ¹Â¹ : NormedRing A\ninstâœÂ¹â° : NormedAlgebra ğ•œ A\ninstâœâ¹ : CompleteSpace A\ninstâœâ¸ : StarRing A\ninstâœâ· : NormedRing B\ninstâœâ¶ : NormedAlgebra ğ•œ B\ninstâœâµ : CompleteSpace B\ninstâœâ´ : StarRing B\ninstâœÂ³ : NormedRing C\ninstâœÂ² : NormedAlgebra ğ•œ C\ninstâœÂ¹ : CompleteSpace C\ninstâœ : StarRing C\nÏˆâ‚‚ : StarAlgHom ğ•œ B C\nÏˆâ‚ : StarAlgHom ğ•œ A B\nâŠ¢ Eq (WeakDual.CharacterSpace.compContinuousMap (Ïˆâ‚‚.comp Ïˆâ‚)) ((WeakDual.CharacterSpace.compContinuousMap Ïˆâ‚).comp (WeakDual.CharacterSpace.compContinuousMap Ïˆâ‚‚))","decl":"/-- `WeakDual.CharacterSpace.compContinuousMap` is functorial. -/\n@[simp]\ntheorem compContinuousMap_comp (Ïˆâ‚‚ : B â†’â‹†â‚[ğ•œ] C) (Ïˆâ‚ : A â†’â‹†â‚[ğ•œ] B) :\n    compContinuousMap (Ïˆâ‚‚.comp Ïˆâ‚) = (compContinuousMap Ïˆâ‚).comp (compContinuousMap Ïˆâ‚‚) :=\n  ContinuousMap.ext fun _a => ext fun _x => rfl\n\n"}
{"name":"gelfandStarTransform_naturality","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\nB : Type u_2\ninstâœÂ¹ : CommCStarAlgebra A\ninstâœ : CommCStarAlgebra B\nÏ† : StarAlgHom Complex A B\nâŠ¢ Eq ((â†‘(gelfandStarTransform B)).comp Ï†) ((ContinuousMap.compStarAlgHom' Complex Complex (WeakDual.CharacterSpace.compContinuousMap Ï†)).comp â†‘(gelfandStarTransform A))","decl":"open CharacterSpace in\n/--\nConsider the contravariant functors between compact Hausdorff spaces and commutative unital\nCâ‹†algebras `F : Cpct â†’ CommCStarAlg := X â†¦ C(X, â„‚)` and\n`G : CommCStarAlg â†’ Cpct := A â†’ characterSpace â„‚ A` whose actions on morphisms are given by\n`WeakDual.CharacterSpace.compContinuousMap` and `ContinuousMap.compStarAlgHom'`, respectively.\n\nThen `Î· : id â†’ F âˆ˜ G := gelfandStarTransform` is a natural isomorphism implementing (half of)\nthe duality between these categories. That is, for commutative unital Câ‹†-algebras `A` and `B` and\n`Ï† : A â†’â‹†â‚[â„‚] B` the following diagram commutes:\n\n```\nA  --- Î· A ---> C(characterSpace â„‚ A, â„‚)\n\n|                     |\n\nÏ†                  (F âˆ˜ G) Ï†\n\n|                     |\nV                     V\n\nB  --- Î· B ---> C(characterSpace â„‚ B, â„‚)\n```\n-/\ntheorem gelfandStarTransform_naturality {A B : Type*} [CommCStarAlgebra A] [CommCStarAlgebra B]\n    (Ï† : A â†’â‹†â‚[â„‚] B) :\n    (gelfandStarTransform B : _ â†’â‹†â‚[â„‚] _).comp Ï† =\n      (compContinuousMap Ï† |>.compStarAlgHom' â„‚ â„‚).comp (gelfandStarTransform A : _ â†’â‹†â‚[â„‚] _) := by\n  rfl\n\n"}
{"name":"WeakDual.CharacterSpace.homeoEval_naturality","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"X : Type u_1\nY : Type u_2\nğ•œ : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : TopologicalSpace X\ninstâœâ´ : CompactSpace X\ninstâœÂ³ : T2Space X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : CompactSpace Y\ninstâœ : T2Space Y\nf : ContinuousMap X Y\nâŠ¢ Eq ((â†‘(WeakDual.CharacterSpace.homeoEval Y ğ•œ)).comp f) ((WeakDual.CharacterSpace.compContinuousMap (ContinuousMap.compStarAlgHom' ğ•œ ğ•œ f)).comp â†‘(WeakDual.CharacterSpace.homeoEval X ğ•œ))","decl":"/--\nConsider the contravariant functors between compact Hausdorff spaces and commutative unital\nCâ‹†algebras `F : Cpct â†’ CommCStarAlg := X â†¦ C(X, â„‚)` and\n`G : CommCStarAlg â†’ Cpct := A â†’ characterSpace â„‚ A` whose actions on morphisms are given by\n`WeakDual.CharacterSpace.compContinuousMap` and `ContinuousMap.compStarAlgHom'`, respectively.\n\nThen `Î· : id â†’ G âˆ˜ F := WeakDual.CharacterSpace.homeoEval` is a natural isomorphism implementing\n(half of) the duality between these categories. That is, for compact Hausdorff spaces `X` and `Y`,\n`f : C(X, Y)` the following diagram commutes:\n\n```\nX  --- Î· X ---> characterSpace â„‚ C(X, â„‚)\n\n|                     |\n\nf                  (G âˆ˜ F) f\n\n|                     |\nV                     V\n\nY  --- Î· Y ---> characterSpace â„‚ C(Y, â„‚)\n```\n-/\nlemma WeakDual.CharacterSpace.homeoEval_naturality {X Y ğ•œ : Type*} [RCLike ğ•œ] [TopologicalSpace X]\n    [CompactSpace X] [T2Space X] [TopologicalSpace Y] [CompactSpace Y] [T2Space Y] (f : C(X, Y)) :\n    (homeoEval Y ğ•œ : C(_, _)).comp f =\n      (f.compStarAlgHom' ğ•œ ğ•œ |> compContinuousMap).comp (homeoEval X ğ•œ : C(_, _)) :=\n  rfl\n"}
