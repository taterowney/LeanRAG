{"name":"Ideal.toCharacterSpace_apply_eq_zero_of_mem","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\ninst✝³ : NormedCommRing A\ninst✝² : NormedAlgebra Complex A\ninst✝¹ : CompleteSpace A\nI : Ideal A\ninst✝ : I.IsMaximal\na : A\nha : Membership.mem I a\n⊢ Eq (I.toCharacterSpace a) 0","decl":"theorem Ideal.toCharacterSpace_apply_eq_zero_of_mem {a : A} (ha : a ∈ I) :\n    I.toCharacterSpace a = 0 := by\n  unfold Ideal.toCharacterSpace\n  simp only [CharacterSpace.equivAlgHom_symm_coe, AlgHom.coe_comp, AlgHom.coe_coe,\n    Quotient.mkₐ_eq_mk, Function.comp_apply, NormedRing.algEquivComplexOfComplete_symm_apply]\n  simp_rw [Quotient.eq_zero_iff_mem.mpr ha, spectrum.zero_eq]\n  exact Set.eq_of_mem_singleton (Set.singleton_nonempty (0 : ℂ)).some_mem\n\n"}
{"name":"WeakDual.CharacterSpace.exists_apply_eq_zero","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\ninst✝² : NormedCommRing A\ninst✝¹ : NormedAlgebra Complex A\ninst✝ : CompleteSpace A\na : A\nha : Not (IsUnit a)\n⊢ Exists fun f => Eq (f a) 0","decl":"/-- If `a : A` is not a unit, then some character takes the value zero at `a`. This is equivalent\nto `gelfandTransform ℂ A a` takes the value zero at some character. -/\ntheorem WeakDual.CharacterSpace.exists_apply_eq_zero {a : A} (ha : ¬IsUnit a) :\n    ∃ f : characterSpace ℂ A, f a = 0 := by\n  obtain ⟨M, hM, haM⟩ := (span {a}).exists_le_maximal (span_singleton_ne_top ha)\n  exact\n    ⟨M.toCharacterSpace,\n      M.toCharacterSpace_apply_eq_zero_of_mem\n        (haM (mem_span_singleton.mpr ⟨1, (mul_one a).symm⟩))⟩\n\n"}
{"name":"WeakDual.CharacterSpace.mem_spectrum_iff_exists","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\ninst✝² : NormedCommRing A\ninst✝¹ : NormedAlgebra Complex A\ninst✝ : CompleteSpace A\na : A\nz : Complex\n⊢ Iff (Membership.mem (spectrum Complex a) z) (Exists fun f => Eq (f a) z)","decl":"theorem WeakDual.CharacterSpace.mem_spectrum_iff_exists {a : A} {z : ℂ} :\n    z ∈ spectrum ℂ a ↔ ∃ f : characterSpace ℂ A, f a = z := by\n  refine ⟨fun hz => ?_, ?_⟩\n  · obtain ⟨f, hf⟩ := WeakDual.CharacterSpace.exists_apply_eq_zero hz\n    simp only [map_sub, sub_eq_zero, AlgHomClass.commutes] at hf\n    exact ⟨_, hf.symm⟩\n  · rintro ⟨f, rfl⟩\n    exact AlgHom.apply_mem_spectrum f a\n\n"}
{"name":"spectrum.gelfandTransform_eq","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\ninst✝² : NormedCommRing A\ninst✝¹ : NormedAlgebra Complex A\ninst✝ : CompleteSpace A\na : A\n⊢ Eq (spectrum Complex ((WeakDual.gelfandTransform Complex A) a)) (spectrum Complex a)","decl":"/-- The Gelfand transform is spectrum-preserving. -/\ntheorem spectrum.gelfandTransform_eq (a : A) :\n    spectrum ℂ (gelfandTransform ℂ A a) = spectrum ℂ a := by\n  ext z\n  rw [ContinuousMap.spectrum_eq_range, WeakDual.CharacterSpace.mem_spectrum_iff_exists]\n  exact Iff.rfl\n\n"}
{"name":"instNonemptyElemWeakDualComplexCharacterSpaceOfNontrivial","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\ninst✝³ : NormedCommRing A\ninst✝² : NormedAlgebra Complex A\ninst✝¹ : CompleteSpace A\ninst✝ : Nontrivial A\n⊢ Nonempty ↑(WeakDual.characterSpace Complex A)","decl":"instance [Nontrivial A] : Nonempty (characterSpace ℂ A) :=\n  ⟨Classical.choose <|\n      WeakDual.CharacterSpace.exists_apply_eq_zero <| zero_mem_nonunits.2 zero_ne_one⟩\n\n"}
{"name":"gelfandTransform_map_star","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\ninst✝ : CommCStarAlgebra A\na : A\n⊢ Eq ((WeakDual.gelfandTransform Complex A) (Star.star a)) (Star.star ((WeakDual.gelfandTransform Complex A) a))","decl":"theorem gelfandTransform_map_star (a : A) :\n    gelfandTransform ℂ A (star a) = star (gelfandTransform ℂ A a) :=\n  ContinuousMap.ext fun φ => map_star φ a\n\n"}
{"name":"gelfandTransform_isometry","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\ninst✝ : CommCStarAlgebra A\n⊢ Isometry ⇑(WeakDual.gelfandTransform Complex A)","decl":"/-- The Gelfand transform is an isometry when the algebra is a C⋆-algebra over `ℂ`. -/\ntheorem gelfandTransform_isometry : Isometry (gelfandTransform ℂ A) := by\n  nontriviality A\n  refine AddMonoidHomClass.isometry_of_norm (gelfandTransform ℂ A) fun a => ?_\n  /- By `spectrum.gelfandTransform_eq`, the spectra of `star a * a` and its\n    `gelfandTransform` coincide. Therefore, so do their spectral radii, and since they are\n    self-adjoint, so also do their norms. Applying the C⋆-property of the norm and taking square\n    roots shows that the norm is preserved. -/\n  have : spectralRadius ℂ (gelfandTransform ℂ A (star a * a)) = spectralRadius ℂ (star a * a) := by\n    unfold spectralRadius; rw [spectrum.gelfandTransform_eq]\n  rw [map_mul, (IsSelfAdjoint.star_mul_self a).spectralRadius_eq_nnnorm, gelfandTransform_map_star,\n    (IsSelfAdjoint.star_mul_self (gelfandTransform ℂ A a)).spectralRadius_eq_nnnorm] at this\n  simp only [ENNReal.coe_inj, CStarRing.nnnorm_star_mul_self, ← sq] at this\n  simpa only [Function.comp_apply, NNReal.sqrt_sq] using\n    congr_arg (((↑) : ℝ≥0 → ℝ) ∘ ⇑NNReal.sqrt) this\n\n"}
{"name":"gelfandTransform_bijective","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\ninst✝ : CommCStarAlgebra A\n⊢ Function.Bijective ⇑(WeakDual.gelfandTransform Complex A)","decl":"/-- The Gelfand transform is bijective when the algebra is a C⋆-algebra over `ℂ`. -/\ntheorem gelfandTransform_bijective : Function.Bijective (gelfandTransform ℂ A) := by\n  refine ⟨(gelfandTransform_isometry A).injective, ?_⟩\n  /- The range of `gelfandTransform ℂ A` is actually a `StarSubalgebra`. The key lemma below may be\n    hard to spot; it's `map_star` coming from `WeakDual.Complex.instStarHomClass`, which is a\n    nontrivial result. -/\n  let rng : StarSubalgebra ℂ C(characterSpace ℂ A, ℂ) :=\n    { toSubalgebra := (gelfandTransform ℂ A).range\n      star_mem' := by\n        rintro - ⟨a, rfl⟩\n        use star a\n        ext1 φ\n        dsimp\n        simp only [map_star, RCLike.star_def] }\n  suffices rng = ⊤ from\n    fun x => show x ∈ rng from this.symm ▸ StarSubalgebra.mem_top\n  /- Because the `gelfandTransform ℂ A` is an isometry, it has closed range, and so by the\n    Stone-Weierstrass theorem, it suffices to show that the image of the Gelfand transform separates\n    points in `C(characterSpace ℂ A, ℂ)` and is closed under `star`. -/\n  have h : rng.topologicalClosure = rng := le_antisymm\n    (StarSubalgebra.topologicalClosure_minimal le_rfl\n      (gelfandTransform_isometry A).isClosedEmbedding.isClosed_range)\n    (StarSubalgebra.le_topologicalClosure _)\n  refine h ▸ ContinuousMap.starSubalgebra_topologicalClosure_eq_top_of_separatesPoints\n    _ (fun _ _ => ?_)\n  /- Separating points just means that elements of the `characterSpace` which agree at all points\n    of `A` are the same functional, which is just extensionality. -/\n  contrapose!\n  exact fun h => Subtype.ext (ContinuousLinearMap.ext fun a =>\n    h (gelfandTransform ℂ A a) ⟨gelfandTransform ℂ A a, ⟨a, rfl⟩, rfl⟩)\n\n"}
{"name":"gelfandStarTransform_symm_apply","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\ninst✝ : CommCStarAlgebra A\na✝ : ContinuousMap (↑(WeakDual.characterSpace Complex A)) Complex\n⊢ Eq ((gelfandStarTransform A).symm a✝) ((↑(RingEquiv.ofBijective { toAlgHom := WeakDual.gelfandTransform Complex A, map_star' := ⋯ } ⋯)).symm a✝)","decl":"/-- The Gelfand transform as a `StarAlgEquiv` between a commutative unital C⋆-algebra over `ℂ`\nand the continuous functions on its `characterSpace`. -/\n@[simps!]\nnoncomputable def gelfandStarTransform : A ≃⋆ₐ[ℂ] C(characterSpace ℂ A, ℂ) :=\n  StarAlgEquiv.ofBijective\n    (show A →⋆ₐ[ℂ] C(characterSpace ℂ A, ℂ) from\n      { gelfandTransform ℂ A with map_star' := fun x => gelfandTransform_map_star x })\n    (gelfandTransform_bijective A)\n\n"}
{"name":"gelfandStarTransform_apply_apply","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\ninst✝ : CommCStarAlgebra A\na : A\nφ : ↑(WeakDual.characterSpace Complex A)\n⊢ Eq (((gelfandStarTransform A) a) φ) (φ a)","decl":"/-- The Gelfand transform as a `StarAlgEquiv` between a commutative unital C⋆-algebra over `ℂ`\nand the continuous functions on its `characterSpace`. -/\n@[simps!]\nnoncomputable def gelfandStarTransform : A ≃⋆ₐ[ℂ] C(characterSpace ℂ A, ℂ) :=\n  StarAlgEquiv.ofBijective\n    (show A →⋆ₐ[ℂ] C(characterSpace ℂ A, ℂ) from\n      { gelfandTransform ℂ A with map_star' := fun x => gelfandTransform_map_star x })\n    (gelfandTransform_bijective A)\n\n"}
{"name":"WeakDual.CharacterSpace.compContinuousMap_apply","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\nB : Type u_2\n𝕜 : Type u_4\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : NormedRing A\ninst✝⁶ : NormedAlgebra 𝕜 A\ninst✝⁵ : CompleteSpace A\ninst✝⁴ : StarRing A\ninst✝³ : NormedRing B\ninst✝² : NormedAlgebra 𝕜 B\ninst✝¹ : CompleteSpace B\ninst✝ : StarRing B\nψ : StarAlgHom 𝕜 A B\nφ : ↑(WeakDual.characterSpace 𝕜 B)\n⊢ Eq ((WeakDual.CharacterSpace.compContinuousMap ψ) φ) (WeakDual.CharacterSpace.equivAlgHom.symm ((WeakDual.CharacterSpace.equivAlgHom φ).comp ψ.toAlgHom))","decl":"/-- The functorial map taking `ψ : A →⋆ₐ[ℂ] B` to a continuous function\n`characterSpace ℂ B → characterSpace ℂ A` obtained by pre-composition with `ψ`. -/\n@[simps]\nnoncomputable def compContinuousMap (ψ : A →⋆ₐ[𝕜] B) :\n    C(characterSpace 𝕜 B, characterSpace 𝕜 A) where\n  toFun φ := equivAlgHom.symm ((equivAlgHom φ).comp ψ.toAlgHom)\n  continuous_toFun :=\n    Continuous.subtype_mk\n      (continuous_of_continuous_eval fun a => map_continuous <| gelfandTransform 𝕜 B (ψ a)) _\n\n"}
{"name":"WeakDual.CharacterSpace.compContinuousMap_id","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\n𝕜 : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedRing A\ninst✝² : NormedAlgebra 𝕜 A\ninst✝¹ : CompleteSpace A\ninst✝ : StarRing A\n⊢ Eq (WeakDual.CharacterSpace.compContinuousMap (StarAlgHom.id 𝕜 A)) (ContinuousMap.id ↑(WeakDual.characterSpace 𝕜 A))","decl":"/-- `WeakDual.CharacterSpace.compContinuousMap` sends the identity to the identity. -/\n@[simp]\ntheorem compContinuousMap_id :\n    compContinuousMap (StarAlgHom.id 𝕜 A) = ContinuousMap.id (characterSpace 𝕜 A) :=\n  ContinuousMap.ext fun _a => ext fun _x => rfl\n\n"}
{"name":"WeakDual.CharacterSpace.compContinuousMap_comp","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\nB : Type u_2\nC : Type u_3\n𝕜 : Type u_4\ninst✝¹² : NontriviallyNormedField 𝕜\ninst✝¹¹ : NormedRing A\ninst✝¹⁰ : NormedAlgebra 𝕜 A\ninst✝⁹ : CompleteSpace A\ninst✝⁸ : StarRing A\ninst✝⁷ : NormedRing B\ninst✝⁶ : NormedAlgebra 𝕜 B\ninst✝⁵ : CompleteSpace B\ninst✝⁴ : StarRing B\ninst✝³ : NormedRing C\ninst✝² : NormedAlgebra 𝕜 C\ninst✝¹ : CompleteSpace C\ninst✝ : StarRing C\nψ₂ : StarAlgHom 𝕜 B C\nψ₁ : StarAlgHom 𝕜 A B\n⊢ Eq (WeakDual.CharacterSpace.compContinuousMap (ψ₂.comp ψ₁)) ((WeakDual.CharacterSpace.compContinuousMap ψ₁).comp (WeakDual.CharacterSpace.compContinuousMap ψ₂))","decl":"/-- `WeakDual.CharacterSpace.compContinuousMap` is functorial. -/\n@[simp]\ntheorem compContinuousMap_comp (ψ₂ : B →⋆ₐ[𝕜] C) (ψ₁ : A →⋆ₐ[𝕜] B) :\n    compContinuousMap (ψ₂.comp ψ₁) = (compContinuousMap ψ₁).comp (compContinuousMap ψ₂) :=\n  ContinuousMap.ext fun _a => ext fun _x => rfl\n\n"}
{"name":"gelfandStarTransform_naturality","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝¹ : CommCStarAlgebra A\ninst✝ : CommCStarAlgebra B\nφ : StarAlgHom Complex A B\n⊢ Eq ((↑(gelfandStarTransform B)).comp φ) ((ContinuousMap.compStarAlgHom' Complex Complex (WeakDual.CharacterSpace.compContinuousMap φ)).comp ↑(gelfandStarTransform A))","decl":"open CharacterSpace in\n/--\nConsider the contravariant functors between compact Hausdorff spaces and commutative unital\nC⋆algebras `F : Cpct → CommCStarAlg := X ↦ C(X, ℂ)` and\n`G : CommCStarAlg → Cpct := A → characterSpace ℂ A` whose actions on morphisms are given by\n`WeakDual.CharacterSpace.compContinuousMap` and `ContinuousMap.compStarAlgHom'`, respectively.\n\nThen `η : id → F ∘ G := gelfandStarTransform` is a natural isomorphism implementing (half of)\nthe duality between these categories. That is, for commutative unital C⋆-algebras `A` and `B` and\n`φ : A →⋆ₐ[ℂ] B` the following diagram commutes:\n\n```\nA  --- η A ---> C(characterSpace ℂ A, ℂ)\n\n|                     |\n\nφ                  (F ∘ G) φ\n\n|                     |\nV                     V\n\nB  --- η B ---> C(characterSpace ℂ B, ℂ)\n```\n-/\ntheorem gelfandStarTransform_naturality {A B : Type*} [CommCStarAlgebra A] [CommCStarAlgebra B]\n    (φ : A →⋆ₐ[ℂ] B) :\n    (gelfandStarTransform B : _ →⋆ₐ[ℂ] _).comp φ =\n      (compContinuousMap φ |>.compStarAlgHom' ℂ ℂ).comp (gelfandStarTransform A : _ →⋆ₐ[ℂ] _) := by\n  rfl\n\n"}
{"name":"WeakDual.CharacterSpace.homeoEval_naturality","module":"Mathlib.Analysis.CStarAlgebra.GelfandDuality","initialProofState":"X : Type u_1\nY : Type u_2\n𝕜 : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : CompactSpace X\ninst✝³ : T2Space X\ninst✝² : TopologicalSpace Y\ninst✝¹ : CompactSpace Y\ninst✝ : T2Space Y\nf : ContinuousMap X Y\n⊢ Eq ((↑(WeakDual.CharacterSpace.homeoEval Y 𝕜)).comp f) ((WeakDual.CharacterSpace.compContinuousMap (ContinuousMap.compStarAlgHom' 𝕜 𝕜 f)).comp ↑(WeakDual.CharacterSpace.homeoEval X 𝕜))","decl":"/--\nConsider the contravariant functors between compact Hausdorff spaces and commutative unital\nC⋆algebras `F : Cpct → CommCStarAlg := X ↦ C(X, ℂ)` and\n`G : CommCStarAlg → Cpct := A → characterSpace ℂ A` whose actions on morphisms are given by\n`WeakDual.CharacterSpace.compContinuousMap` and `ContinuousMap.compStarAlgHom'`, respectively.\n\nThen `η : id → G ∘ F := WeakDual.CharacterSpace.homeoEval` is a natural isomorphism implementing\n(half of) the duality between these categories. That is, for compact Hausdorff spaces `X` and `Y`,\n`f : C(X, Y)` the following diagram commutes:\n\n```\nX  --- η X ---> characterSpace ℂ C(X, ℂ)\n\n|                     |\n\nf                  (G ∘ F) f\n\n|                     |\nV                     V\n\nY  --- η Y ---> characterSpace ℂ C(Y, ℂ)\n```\n-/\nlemma WeakDual.CharacterSpace.homeoEval_naturality {X Y 𝕜 : Type*} [RCLike 𝕜] [TopologicalSpace X]\n    [CompactSpace X] [T2Space X] [TopologicalSpace Y] [CompactSpace Y] [T2Space Y] (f : C(X, Y)) :\n    (homeoEval Y 𝕜 : C(_, _)).comp f =\n      (f.compStarAlgHom' 𝕜 𝕜 |> compContinuousMap).comp (homeoEval X 𝕜 : C(_, _)) :=\n  rfl\n"}
