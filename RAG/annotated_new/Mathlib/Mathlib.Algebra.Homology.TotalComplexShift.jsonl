{"name":"HomologicalComplex₂.shiftFunctor₁XXIso_refl","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\na b x : Int\n⊢ Eq (K.shiftFunctor₁XXIso a x (HAdd.hAdd a x) ⋯ b) (CategoryTheory.Iso.refl ((((HomologicalComplex₂.shiftFunctor₁ C x).obj K).X a).X b))","decl":"@[simp]\nlemma shiftFunctor₁XXIso_refl (a b x : ℤ) :\n    K.shiftFunctor₁XXIso a x (a + x) rfl b = Iso.refl _ := rfl\n\n"}
{"name":"HomologicalComplex₂.shiftFunctor₂XXIso_refl","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\na b y : Int\n⊢ Eq (K.shiftFunctor₂XXIso a b y (HAdd.hAdd b y) ⋯) (CategoryTheory.Iso.refl ((((HomologicalComplex₂.shiftFunctor₂ C y).obj K).X a).X b))","decl":"@[simp]\nlemma shiftFunctor₂XXIso_refl (a b y : ℤ) :\n    K.shiftFunctor₂XXIso a b y (b + y) rfl = Iso.refl _ := rfl\n\n"}
{"name":"HomologicalComplex₂.instHasTotalIntObjUpShiftFunctor₁","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\nx : Int\ninst✝ : K.HasTotal (ComplexShape.up Int)\n⊢ ((HomologicalComplex₂.shiftFunctor₁ C x).obj K).HasTotal (ComplexShape.up Int)","decl":"instance : ((shiftFunctor₁ C x).obj K).HasTotal (up ℤ) := fun n =>\n  hasCoproduct_of_equiv_of_iso (K.toGradedObject.mapObjFun (π (up ℤ) (up ℤ) (up ℤ)) (n + x)) _\n    { toFun := fun ⟨⟨a, b⟩, h⟩ => ⟨⟨a + x, b⟩, by\n        simp only [Set.mem_preimage, instTotalComplexShape_π, Set.mem_singleton_iff] at h ⊢\n        omega⟩\n      invFun := fun ⟨⟨a, b⟩, h⟩ => ⟨(a - x, b), by\n        simp only [Set.mem_preimage, instTotalComplexShape_π, Set.mem_singleton_iff] at h ⊢\n        omega⟩\n      left_inv := by\n        rintro ⟨⟨a, b⟩, h⟩\n        ext\n        · dsimp\n          omega\n        · rfl\n      right_inv := by\n        intro ⟨⟨a, b⟩, h⟩\n        ext\n        · dsimp\n          omega\n        · rfl }\n    (fun _ => Iso.refl _)\n\n"}
{"name":"HomologicalComplex₂.instHasTotalIntObjUpShiftFunctor₂","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\ny : Int\ninst✝ : K.HasTotal (ComplexShape.up Int)\n⊢ ((HomologicalComplex₂.shiftFunctor₂ C y).obj K).HasTotal (ComplexShape.up Int)","decl":"instance : ((shiftFunctor₂ C y).obj K).HasTotal (up ℤ) := fun n =>\n  hasCoproduct_of_equiv_of_iso (K.toGradedObject.mapObjFun (π (up ℤ) (up ℤ) (up ℤ)) (n + y)) _\n    { toFun := fun ⟨⟨a, b⟩, h⟩ => ⟨⟨a, b + y⟩, by\n        simp only [Set.mem_preimage, instTotalComplexShape_π, Set.mem_singleton_iff] at h ⊢\n        omega⟩\n      invFun := fun ⟨⟨a, b⟩, h⟩ => ⟨(a, b - y), by\n        simp only [Set.mem_preimage, instTotalComplexShape_π, Set.mem_singleton_iff] at h ⊢\n        omega⟩\n      left_inv _ := by simp\n      right_inv _ := by simp }\n    (fun _ => Iso.refl _)\n\n"}
{"name":"HomologicalComplex₂.instHasTotalIntObjUpCompShiftFunctor₂ShiftFunctor₁","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\nx y : Int\n⊢ (((HomologicalComplex₂.shiftFunctor₂ C y).comp (HomologicalComplex₂.shiftFunctor₁ C x)).obj K).HasTotal (ComplexShape.up Int)","decl":"instance : ((shiftFunctor₂ C y ⋙ shiftFunctor₁ C x).obj K).HasTotal (up ℤ) := by\n  dsimp\n  infer_instance\n\n"}
{"name":"HomologicalComplex₂.instHasTotalIntObjUpCompShiftFunctor₁ShiftFunctor₂","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\nx y : Int\n⊢ (((HomologicalComplex₂.shiftFunctor₁ C x).comp (HomologicalComplex₂.shiftFunctor₂ C y)).obj K).HasTotal (ComplexShape.up Int)","decl":"instance : ((shiftFunctor₁ C x ⋙ shiftFunctor₂ C y).obj K).HasTotal (up ℤ) := by\n  dsimp\n  infer_instance\n\n"}
{"name":"HomologicalComplex₂.D₁_totalShift₁XIso_hom_assoc","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\nx : Int\ninst✝ : K.HasTotal (ComplexShape.up Int)\nn₀ n₁ n₀' n₁' : Int\nh₀ : Eq (HAdd.hAdd n₀ x) n₀'\nh₁ : Eq (HAdd.hAdd n₁ x) n₁'\nZ : C\nh : Quiver.Hom ((K.total (ComplexShape.up Int)).X n₁') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((HomologicalComplex₂.shiftFunctor₁ C x).obj K).D₁ (ComplexShape.up Int) n₀ n₁) (CategoryTheory.CategoryStruct.comp (K.totalShift₁XIso x n₁ n₁' h₁).hom h)) (CategoryTheory.CategoryStruct.comp (HSMul.hSMul x.negOnePow (CategoryTheory.CategoryStruct.comp (K.totalShift₁XIso x n₀ n₀' h₀).hom (K.D₁ (ComplexShape.up Int) n₀' n₁'))) h)","decl":"@[reassoc]\nlemma D₁_totalShift₁XIso_hom (n₀ n₁ n₀' n₁' : ℤ) (h₀ : n₀ + x = n₀') (h₁ : n₁ + x = n₁') :\n    ((shiftFunctor₁ C x).obj K).D₁ (up ℤ) n₀ n₁ ≫ (K.totalShift₁XIso x n₁ n₁' h₁).hom =\n      x.negOnePow • ((K.totalShift₁XIso x n₀ n₀' h₀).hom ≫ K.D₁ (up ℤ) n₀' n₁') := by\n  by_cases h : (up ℤ).Rel n₀ n₁\n  · apply total.hom_ext\n    intro p q hpq\n    dsimp at h hpq\n    dsimp [totalShift₁XIso]\n    rw [ι_D₁_assoc, Linear.comp_units_smul, ι_totalDesc_assoc, ι_D₁,\n      ((shiftFunctor₁ C x).obj K).d₁_eq _ rfl _ _ (by dsimp; omega),\n      K.d₁_eq _ (show p + x + 1 = p + 1 + x by omega) _ _ (by dsimp; omega)]\n    dsimp\n    rw [one_smul, Category.assoc, ι_totalDesc, one_smul, Linear.units_smul_comp]\n  · rw [D₁_shape _ _ _ _ h, zero_comp, D₁_shape, comp_zero, smul_zero]\n    intro h'\n    apply h\n    dsimp at h' ⊢\n    omega\n\n"}
{"name":"HomologicalComplex₂.D₁_totalShift₁XIso_hom","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\nx : Int\ninst✝ : K.HasTotal (ComplexShape.up Int)\nn₀ n₁ n₀' n₁' : Int\nh₀ : Eq (HAdd.hAdd n₀ x) n₀'\nh₁ : Eq (HAdd.hAdd n₁ x) n₁'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((HomologicalComplex₂.shiftFunctor₁ C x).obj K).D₁ (ComplexShape.up Int) n₀ n₁) (K.totalShift₁XIso x n₁ n₁' h₁).hom) (HSMul.hSMul x.negOnePow (CategoryTheory.CategoryStruct.comp (K.totalShift₁XIso x n₀ n₀' h₀).hom (K.D₁ (ComplexShape.up Int) n₀' n₁')))","decl":"@[reassoc]\nlemma D₁_totalShift₁XIso_hom (n₀ n₁ n₀' n₁' : ℤ) (h₀ : n₀ + x = n₀') (h₁ : n₁ + x = n₁') :\n    ((shiftFunctor₁ C x).obj K).D₁ (up ℤ) n₀ n₁ ≫ (K.totalShift₁XIso x n₁ n₁' h₁).hom =\n      x.negOnePow • ((K.totalShift₁XIso x n₀ n₀' h₀).hom ≫ K.D₁ (up ℤ) n₀' n₁') := by\n  by_cases h : (up ℤ).Rel n₀ n₁\n  · apply total.hom_ext\n    intro p q hpq\n    dsimp at h hpq\n    dsimp [totalShift₁XIso]\n    rw [ι_D₁_assoc, Linear.comp_units_smul, ι_totalDesc_assoc, ι_D₁,\n      ((shiftFunctor₁ C x).obj K).d₁_eq _ rfl _ _ (by dsimp; omega),\n      K.d₁_eq _ (show p + x + 1 = p + 1 + x by omega) _ _ (by dsimp; omega)]\n    dsimp\n    rw [one_smul, Category.assoc, ι_totalDesc, one_smul, Linear.units_smul_comp]\n  · rw [D₁_shape _ _ _ _ h, zero_comp, D₁_shape, comp_zero, smul_zero]\n    intro h'\n    apply h\n    dsimp at h' ⊢\n    omega\n\n"}
{"name":"HomologicalComplex₂.D₂_totalShift₁XIso_hom_assoc","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\nx : Int\ninst✝ : K.HasTotal (ComplexShape.up Int)\nn₀ n₁ n₀' n₁' : Int\nh₀ : Eq (HAdd.hAdd n₀ x) n₀'\nh₁ : Eq (HAdd.hAdd n₁ x) n₁'\nZ : C\nh : Quiver.Hom ((K.total (ComplexShape.up Int)).X n₁') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((HomologicalComplex₂.shiftFunctor₁ C x).obj K).D₂ (ComplexShape.up Int) n₀ n₁) (CategoryTheory.CategoryStruct.comp (K.totalShift₁XIso x n₁ n₁' h₁).hom h)) (CategoryTheory.CategoryStruct.comp (HSMul.hSMul x.negOnePow (CategoryTheory.CategoryStruct.comp (K.totalShift₁XIso x n₀ n₀' h₀).hom (K.D₂ (ComplexShape.up Int) n₀' n₁'))) h)","decl":"@[reassoc]\nlemma D₂_totalShift₁XIso_hom (n₀ n₁ n₀' n₁' : ℤ) (h₀ : n₀ + x = n₀') (h₁ : n₁ + x = n₁') :\n    ((shiftFunctor₁ C x).obj K).D₂ (up ℤ) n₀ n₁ ≫ (K.totalShift₁XIso x n₁ n₁' h₁).hom =\n      x.negOnePow • ((K.totalShift₁XIso x n₀ n₀' h₀).hom ≫ K.D₂ (up ℤ) n₀' n₁') := by\n  by_cases h : (up ℤ).Rel n₀ n₁\n  · apply total.hom_ext\n    intro p q hpq\n    dsimp at h hpq\n    dsimp [totalShift₁XIso]\n    rw [ι_D₂_assoc, Linear.comp_units_smul, ι_totalDesc_assoc, ι_D₂,\n      ((shiftFunctor₁ C x).obj K).d₂_eq _ _ rfl _ (by dsimp; omega),\n      K.d₂_eq _ _ rfl _ (by dsimp; omega), smul_smul,\n      Linear.units_smul_comp, Category.assoc, ι_totalDesc]\n    dsimp\n    congr 1\n    rw [add_comm p, Int.negOnePow_add, ← mul_assoc, Int.units_mul_self, one_mul]\n  · rw [D₂_shape _ _ _ _ h, zero_comp, D₂_shape, comp_zero, smul_zero]\n    intro h'\n    apply h\n    dsimp at h' ⊢\n    omega\n\n"}
{"name":"HomologicalComplex₂.D₂_totalShift₁XIso_hom","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\nx : Int\ninst✝ : K.HasTotal (ComplexShape.up Int)\nn₀ n₁ n₀' n₁' : Int\nh₀ : Eq (HAdd.hAdd n₀ x) n₀'\nh₁ : Eq (HAdd.hAdd n₁ x) n₁'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((HomologicalComplex₂.shiftFunctor₁ C x).obj K).D₂ (ComplexShape.up Int) n₀ n₁) (K.totalShift₁XIso x n₁ n₁' h₁).hom) (HSMul.hSMul x.negOnePow (CategoryTheory.CategoryStruct.comp (K.totalShift₁XIso x n₀ n₀' h₀).hom (K.D₂ (ComplexShape.up Int) n₀' n₁')))","decl":"@[reassoc]\nlemma D₂_totalShift₁XIso_hom (n₀ n₁ n₀' n₁' : ℤ) (h₀ : n₀ + x = n₀') (h₁ : n₁ + x = n₁') :\n    ((shiftFunctor₁ C x).obj K).D₂ (up ℤ) n₀ n₁ ≫ (K.totalShift₁XIso x n₁ n₁' h₁).hom =\n      x.negOnePow • ((K.totalShift₁XIso x n₀ n₀' h₀).hom ≫ K.D₂ (up ℤ) n₀' n₁') := by\n  by_cases h : (up ℤ).Rel n₀ n₁\n  · apply total.hom_ext\n    intro p q hpq\n    dsimp at h hpq\n    dsimp [totalShift₁XIso]\n    rw [ι_D₂_assoc, Linear.comp_units_smul, ι_totalDesc_assoc, ι_D₂,\n      ((shiftFunctor₁ C x).obj K).d₂_eq _ _ rfl _ (by dsimp; omega),\n      K.d₂_eq _ _ rfl _ (by dsimp; omega), smul_smul,\n      Linear.units_smul_comp, Category.assoc, ι_totalDesc]\n    dsimp\n    congr 1\n    rw [add_comm p, Int.negOnePow_add, ← mul_assoc, Int.units_mul_self, one_mul]\n  · rw [D₂_shape _ _ _ _ h, zero_comp, D₂_shape, comp_zero, smul_zero]\n    intro h'\n    apply h\n    dsimp at h' ⊢\n    omega\n\n"}
{"name":"HomologicalComplex₂.ι_totalShift₁Iso_hom_f","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\nx : Int\ninst✝ : K.HasTotal (ComplexShape.up Int)\na b n : Int\nh : Eq (HAdd.hAdd a b) n\na' : Int\nha' : Eq a' (HAdd.hAdd a x)\nn' : Int\nhn' : Eq n' (HAdd.hAdd n x)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((HomologicalComplex₂.shiftFunctor₁ C x).obj K).ιTotal (ComplexShape.up Int) a b n h) ((K.totalShift₁Iso x).hom.f n)) (CategoryTheory.CategoryStruct.comp (K.shiftFunctor₁XXIso a x a' ha' b).hom (CategoryTheory.CategoryStruct.comp (K.ιTotal (ComplexShape.up Int) a' b n' ⋯) (CochainComplex.shiftFunctorObjXIso (K.total (ComplexShape.up Int)) x n n' hn').inv))","decl":"@[reassoc]\nlemma ι_totalShift₁Iso_hom_f (a b n : ℤ) (h : a + b = n) (a' : ℤ) (ha' : a' = a + x)\n    (n' : ℤ) (hn' : n' = n + x) :\n    ((shiftFunctor₁ C x).obj K).ιTotal (up ℤ) a b n h ≫ (K.totalShift₁Iso x).hom.f n =\n      (K.shiftFunctor₁XXIso a x a' ha' b).hom ≫ K.ιTotal (up ℤ) a' b n' (by dsimp; omega) ≫\n        (CochainComplex.shiftFunctorObjXIso (K.total (up ℤ)) x n n' hn').inv := by\n  subst ha' hn'\n  dsimp [totalShift₁Iso, totalShift₁XIso]\n  simp only [ι_totalDesc, comp_id, id_comp]\n\n"}
{"name":"HomologicalComplex₂.ι_totalShift₁Iso_hom_f_assoc","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\nx : Int\ninst✝ : K.HasTotal (ComplexShape.up Int)\na b n : Int\nh✝ : Eq (HAdd.hAdd a b) n\na' : Int\nha' : Eq a' (HAdd.hAdd a x)\nn' : Int\nhn' : Eq n' (HAdd.hAdd n x)\nZ : C\nh : Quiver.Hom (((CategoryTheory.shiftFunctor (HomologicalComplex C (ComplexShape.up Int)) x).obj (K.total (ComplexShape.up Int))).X n) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((HomologicalComplex₂.shiftFunctor₁ C x).obj K).ιTotal (ComplexShape.up Int) a b n h✝) (CategoryTheory.CategoryStruct.comp ((K.totalShift₁Iso x).hom.f n) h)) (CategoryTheory.CategoryStruct.comp (K.shiftFunctor₁XXIso a x a' ha' b).hom (CategoryTheory.CategoryStruct.comp (K.ιTotal (ComplexShape.up Int) a' b n' ⋯) (CategoryTheory.CategoryStruct.comp (CochainComplex.shiftFunctorObjXIso (K.total (ComplexShape.up Int)) x n n' hn').inv h)))","decl":"@[reassoc]\nlemma ι_totalShift₁Iso_hom_f (a b n : ℤ) (h : a + b = n) (a' : ℤ) (ha' : a' = a + x)\n    (n' : ℤ) (hn' : n' = n + x) :\n    ((shiftFunctor₁ C x).obj K).ιTotal (up ℤ) a b n h ≫ (K.totalShift₁Iso x).hom.f n =\n      (K.shiftFunctor₁XXIso a x a' ha' b).hom ≫ K.ιTotal (up ℤ) a' b n' (by dsimp; omega) ≫\n        (CochainComplex.shiftFunctorObjXIso (K.total (up ℤ)) x n n' hn').inv := by\n  subst ha' hn'\n  dsimp [totalShift₁Iso, totalShift₁XIso]\n  simp only [ι_totalDesc, comp_id, id_comp]\n\n"}
{"name":"HomologicalComplex₂.ι_totalShift₁Iso_inv_f_assoc","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\nx : Int\ninst✝ : K.HasTotal (ComplexShape.up Int)\na b n : Int\nh✝ : Eq (HAdd.hAdd a b) n\na' n' : Int\nha' : Eq (HAdd.hAdd a' b) n'\nhn' : Eq n' (HAdd.hAdd n x)\nZ : C\nh : Quiver.Hom ((((HomologicalComplex₂.shiftFunctor₁ C x).obj K).total (ComplexShape.up Int)).X n) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.ιTotal (ComplexShape.up Int) a' b n' ha') (CategoryTheory.CategoryStruct.comp (CochainComplex.shiftFunctorObjXIso (K.total (ComplexShape.up Int)) x n n' hn').inv (CategoryTheory.CategoryStruct.comp ((K.totalShift₁Iso x).inv.f n) h))) (CategoryTheory.CategoryStruct.comp (K.shiftFunctor₁XXIso a x a' ⋯ b).inv (CategoryTheory.CategoryStruct.comp (((HomologicalComplex₂.shiftFunctor₁ C x).obj K).ιTotal (ComplexShape.up Int) a b n h✝) h))","decl":"@[reassoc]\nlemma ι_totalShift₁Iso_inv_f (a b n : ℤ) (h : a + b = n) (a' n' : ℤ)\n    (ha' : a' + b = n') (hn' : n' = n + x) :\n    K.ιTotal (up ℤ) a' b n' ha' ≫\n      (CochainComplex.shiftFunctorObjXIso (K.total (up ℤ)) x n n' hn').inv ≫\n        (K.totalShift₁Iso x).inv.f n =\n      (K.shiftFunctor₁XXIso a x a' (by omega) b).inv ≫\n        ((shiftFunctor₁ C x).obj K).ιTotal (up ℤ) a b n h := by\n  subst hn'\n  obtain rfl : a = a' - x := by omega\n  dsimp [totalShift₁Iso, totalShift₁XIso, shiftFunctor₁XXIso, XXIsoOfEq]\n  simp only [id_comp, ι_totalDesc]\n\n"}
{"name":"HomologicalComplex₂.ι_totalShift₁Iso_inv_f","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\nx : Int\ninst✝ : K.HasTotal (ComplexShape.up Int)\na b n : Int\nh : Eq (HAdd.hAdd a b) n\na' n' : Int\nha' : Eq (HAdd.hAdd a' b) n'\nhn' : Eq n' (HAdd.hAdd n x)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.ιTotal (ComplexShape.up Int) a' b n' ha') (CategoryTheory.CategoryStruct.comp (CochainComplex.shiftFunctorObjXIso (K.total (ComplexShape.up Int)) x n n' hn').inv ((K.totalShift₁Iso x).inv.f n))) (CategoryTheory.CategoryStruct.comp (K.shiftFunctor₁XXIso a x a' ⋯ b).inv (((HomologicalComplex₂.shiftFunctor₁ C x).obj K).ιTotal (ComplexShape.up Int) a b n h))","decl":"@[reassoc]\nlemma ι_totalShift₁Iso_inv_f (a b n : ℤ) (h : a + b = n) (a' n' : ℤ)\n    (ha' : a' + b = n') (hn' : n' = n + x) :\n    K.ιTotal (up ℤ) a' b n' ha' ≫\n      (CochainComplex.shiftFunctorObjXIso (K.total (up ℤ)) x n n' hn').inv ≫\n        (K.totalShift₁Iso x).inv.f n =\n      (K.shiftFunctor₁XXIso a x a' (by omega) b).inv ≫\n        ((shiftFunctor₁ C x).obj K).ιTotal (up ℤ) a b n h := by\n  subst hn'\n  obtain rfl : a = a' - x := by omega\n  dsimp [totalShift₁Iso, totalShift₁XIso, shiftFunctor₁XXIso, XXIsoOfEq]\n  simp only [id_comp, ι_totalDesc]\n\n"}
{"name":"HomologicalComplex₂.totalShift₁Iso_hom_naturality_assoc","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nK L : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\nf : Quiver.Hom K L\nx : Int\ninst✝¹ : K.HasTotal (ComplexShape.up Int)\ninst✝ : L.HasTotal (ComplexShape.up Int)\nZ : HomologicalComplex C (ComplexShape.up Int)\nh : Quiver.Hom ((CategoryTheory.shiftFunctor (HomologicalComplex C (ComplexShape.up Int)) x).obj (L.total (ComplexShape.up Int))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex₂.total.map ((HomologicalComplex₂.shiftFunctor₁ C x).map f) (ComplexShape.up Int)) (CategoryTheory.CategoryStruct.comp (L.totalShift₁Iso x).hom h)) (CategoryTheory.CategoryStruct.comp (K.totalShift₁Iso x).hom (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (HomologicalComplex C (ComplexShape.up Int)) x).map (HomologicalComplex₂.total.map f (ComplexShape.up Int))) h))","decl":"variable {K L} in\n@[reassoc]\nlemma totalShift₁Iso_hom_naturality [L.HasTotal (up ℤ)] :\n    total.map ((shiftFunctor₁ C x).map f) (up ℤ) ≫ (L.totalShift₁Iso x).hom =\n      (K.totalShift₁Iso x).hom ≫ (total.map f (up ℤ))⟦x⟧' := by\n  ext n i₁ i₂ h\n  dsimp at h ⊢\n  rw [ιTotal_map_assoc, L.ι_totalShift₁Iso_hom_f x i₁ i₂ n h _ rfl _ rfl,\n    K.ι_totalShift₁Iso_hom_f_assoc x i₁ i₂ n h _ rfl _ rfl]\n  dsimp\n  rw [id_comp, id_comp, id_comp, comp_id, ιTotal_map]\n\n"}
{"name":"HomologicalComplex₂.totalShift₁Iso_hom_naturality","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nK L : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\nf : Quiver.Hom K L\nx : Int\ninst✝¹ : K.HasTotal (ComplexShape.up Int)\ninst✝ : L.HasTotal (ComplexShape.up Int)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex₂.total.map ((HomologicalComplex₂.shiftFunctor₁ C x).map f) (ComplexShape.up Int)) (L.totalShift₁Iso x).hom) (CategoryTheory.CategoryStruct.comp (K.totalShift₁Iso x).hom ((CategoryTheory.shiftFunctor (HomologicalComplex C (ComplexShape.up Int)) x).map (HomologicalComplex₂.total.map f (ComplexShape.up Int))))","decl":"variable {K L} in\n@[reassoc]\nlemma totalShift₁Iso_hom_naturality [L.HasTotal (up ℤ)] :\n    total.map ((shiftFunctor₁ C x).map f) (up ℤ) ≫ (L.totalShift₁Iso x).hom =\n      (K.totalShift₁Iso x).hom ≫ (total.map f (up ℤ))⟦x⟧' := by\n  ext n i₁ i₂ h\n  dsimp at h ⊢\n  rw [ιTotal_map_assoc, L.ι_totalShift₁Iso_hom_f x i₁ i₂ n h _ rfl _ rfl,\n    K.ι_totalShift₁Iso_hom_f_assoc x i₁ i₂ n h _ rfl _ rfl]\n  dsimp\n  rw [id_comp, id_comp, id_comp, comp_id, ιTotal_map]\n\n"}
{"name":"HomologicalComplex₂.D₁_totalShift₂XIso_hom_assoc","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\ny : Int\ninst✝ : K.HasTotal (ComplexShape.up Int)\nn₀ n₁ n₀' n₁' : Int\nh₀ : Eq (HAdd.hAdd n₀ y) n₀'\nh₁ : Eq (HAdd.hAdd n₁ y) n₁'\nZ : C\nh : Quiver.Hom ((K.total (ComplexShape.up Int)).X n₁') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((HomologicalComplex₂.shiftFunctor₂ C y).obj K).D₁ (ComplexShape.up Int) n₀ n₁) (CategoryTheory.CategoryStruct.comp (K.totalShift₂XIso y n₁ n₁' h₁).hom h)) (CategoryTheory.CategoryStruct.comp (HSMul.hSMul y.negOnePow (CategoryTheory.CategoryStruct.comp (K.totalShift₂XIso y n₀ n₀' h₀).hom (K.D₁ (ComplexShape.up Int) n₀' n₁'))) h)","decl":"@[reassoc]\nlemma D₁_totalShift₂XIso_hom (n₀ n₁ n₀' n₁' : ℤ) (h₀ : n₀ + y = n₀') (h₁ : n₁ + y = n₁') :\n    ((shiftFunctor₂ C y).obj K).D₁ (up ℤ) n₀ n₁ ≫ (K.totalShift₂XIso y n₁ n₁' h₁).hom =\n      y.negOnePow • ((K.totalShift₂XIso y n₀ n₀' h₀).hom ≫ K.D₁ (up ℤ) n₀' n₁') := by\n  by_cases h : (up ℤ).Rel n₀ n₁\n  · apply total.hom_ext\n    intro p q hpq\n    dsimp at h hpq\n    dsimp [totalShift₂XIso]\n    rw [ι_D₁_assoc, Linear.comp_units_smul, ι_totalDesc_assoc, Linear.units_smul_comp,\n      ι_D₁, smul_smul, ((shiftFunctor₂ C y).obj K).d₁_eq _ rfl _ _ (by dsimp; omega),\n      K.d₁_eq _ rfl _ _ (by dsimp; omega)]\n    dsimp\n    rw [one_smul, one_smul, Category.assoc, ι_totalDesc, Linear.comp_units_smul,\n      ← Int.negOnePow_add]\n    congr 2\n    linarith\n  · rw [D₁_shape _ _ _ _ h, zero_comp, D₁_shape, comp_zero, smul_zero]\n    intro h'\n    apply h\n    dsimp at h' ⊢\n    omega\n\n"}
{"name":"HomologicalComplex₂.D₁_totalShift₂XIso_hom","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\ny : Int\ninst✝ : K.HasTotal (ComplexShape.up Int)\nn₀ n₁ n₀' n₁' : Int\nh₀ : Eq (HAdd.hAdd n₀ y) n₀'\nh₁ : Eq (HAdd.hAdd n₁ y) n₁'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((HomologicalComplex₂.shiftFunctor₂ C y).obj K).D₁ (ComplexShape.up Int) n₀ n₁) (K.totalShift₂XIso y n₁ n₁' h₁).hom) (HSMul.hSMul y.negOnePow (CategoryTheory.CategoryStruct.comp (K.totalShift₂XIso y n₀ n₀' h₀).hom (K.D₁ (ComplexShape.up Int) n₀' n₁')))","decl":"@[reassoc]\nlemma D₁_totalShift₂XIso_hom (n₀ n₁ n₀' n₁' : ℤ) (h₀ : n₀ + y = n₀') (h₁ : n₁ + y = n₁') :\n    ((shiftFunctor₂ C y).obj K).D₁ (up ℤ) n₀ n₁ ≫ (K.totalShift₂XIso y n₁ n₁' h₁).hom =\n      y.negOnePow • ((K.totalShift₂XIso y n₀ n₀' h₀).hom ≫ K.D₁ (up ℤ) n₀' n₁') := by\n  by_cases h : (up ℤ).Rel n₀ n₁\n  · apply total.hom_ext\n    intro p q hpq\n    dsimp at h hpq\n    dsimp [totalShift₂XIso]\n    rw [ι_D₁_assoc, Linear.comp_units_smul, ι_totalDesc_assoc, Linear.units_smul_comp,\n      ι_D₁, smul_smul, ((shiftFunctor₂ C y).obj K).d₁_eq _ rfl _ _ (by dsimp; omega),\n      K.d₁_eq _ rfl _ _ (by dsimp; omega)]\n    dsimp\n    rw [one_smul, one_smul, Category.assoc, ι_totalDesc, Linear.comp_units_smul,\n      ← Int.negOnePow_add]\n    congr 2\n    linarith\n  · rw [D₁_shape _ _ _ _ h, zero_comp, D₁_shape, comp_zero, smul_zero]\n    intro h'\n    apply h\n    dsimp at h' ⊢\n    omega\n\n"}
{"name":"HomologicalComplex₂.D₂_totalShift₂XIso_hom","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\ny : Int\ninst✝ : K.HasTotal (ComplexShape.up Int)\nn₀ n₁ n₀' n₁' : Int\nh₀ : Eq (HAdd.hAdd n₀ y) n₀'\nh₁ : Eq (HAdd.hAdd n₁ y) n₁'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((HomologicalComplex₂.shiftFunctor₂ C y).obj K).D₂ (ComplexShape.up Int) n₀ n₁) (K.totalShift₂XIso y n₁ n₁' h₁).hom) (HSMul.hSMul y.negOnePow (CategoryTheory.CategoryStruct.comp (K.totalShift₂XIso y n₀ n₀' h₀).hom (K.D₂ (ComplexShape.up Int) n₀' n₁')))","decl":"@[reassoc]\nlemma D₂_totalShift₂XIso_hom (n₀ n₁ n₀' n₁' : ℤ) (h₀ : n₀ + y = n₀') (h₁ : n₁ + y = n₁') :\n    ((shiftFunctor₂ C y).obj K).D₂ (up ℤ) n₀ n₁ ≫ (K.totalShift₂XIso y n₁ n₁' h₁).hom =\n      y.negOnePow • ((K.totalShift₂XIso y n₀ n₀' h₀).hom ≫ K.D₂ (up ℤ) n₀' n₁') := by\n  by_cases h : (up ℤ).Rel n₀ n₁\n  · apply total.hom_ext\n    intro p q hpq\n    dsimp at h hpq\n    dsimp [totalShift₂XIso]\n    rw [ι_D₂_assoc, Linear.comp_units_smul, ι_totalDesc_assoc, Linear.units_smul_comp,\n      smul_smul, ι_D₂, ((shiftFunctor₂ C y).obj K).d₂_eq _ _ rfl _ (by dsimp; omega),\n      K.d₂_eq _ _ (show q + y + 1 = q + 1 + y by omega) _ (by dsimp; omega),\n      Linear.units_smul_comp, Category.assoc, smul_smul, ι_totalDesc]\n    dsimp\n    rw [Linear.units_smul_comp, Linear.comp_units_smul, smul_smul, smul_smul,\n      ← Int.negOnePow_add, ← Int.negOnePow_add, ← Int.negOnePow_add,\n      ← Int.negOnePow_add]\n    congr 2\n    omega\n  · rw [D₂_shape _ _ _ _ h, zero_comp, D₂_shape, comp_zero, smul_zero]\n    intro h'\n    apply h\n    dsimp at h' ⊢\n    omega\n\n"}
{"name":"HomologicalComplex₂.D₂_totalShift₂XIso_hom_assoc","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\ny : Int\ninst✝ : K.HasTotal (ComplexShape.up Int)\nn₀ n₁ n₀' n₁' : Int\nh₀ : Eq (HAdd.hAdd n₀ y) n₀'\nh₁ : Eq (HAdd.hAdd n₁ y) n₁'\nZ : C\nh : Quiver.Hom ((K.total (ComplexShape.up Int)).X n₁') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((HomologicalComplex₂.shiftFunctor₂ C y).obj K).D₂ (ComplexShape.up Int) n₀ n₁) (CategoryTheory.CategoryStruct.comp (K.totalShift₂XIso y n₁ n₁' h₁).hom h)) (CategoryTheory.CategoryStruct.comp (HSMul.hSMul y.negOnePow (CategoryTheory.CategoryStruct.comp (K.totalShift₂XIso y n₀ n₀' h₀).hom (K.D₂ (ComplexShape.up Int) n₀' n₁'))) h)","decl":"@[reassoc]\nlemma D₂_totalShift₂XIso_hom (n₀ n₁ n₀' n₁' : ℤ) (h₀ : n₀ + y = n₀') (h₁ : n₁ + y = n₁') :\n    ((shiftFunctor₂ C y).obj K).D₂ (up ℤ) n₀ n₁ ≫ (K.totalShift₂XIso y n₁ n₁' h₁).hom =\n      y.negOnePow • ((K.totalShift₂XIso y n₀ n₀' h₀).hom ≫ K.D₂ (up ℤ) n₀' n₁') := by\n  by_cases h : (up ℤ).Rel n₀ n₁\n  · apply total.hom_ext\n    intro p q hpq\n    dsimp at h hpq\n    dsimp [totalShift₂XIso]\n    rw [ι_D₂_assoc, Linear.comp_units_smul, ι_totalDesc_assoc, Linear.units_smul_comp,\n      smul_smul, ι_D₂, ((shiftFunctor₂ C y).obj K).d₂_eq _ _ rfl _ (by dsimp; omega),\n      K.d₂_eq _ _ (show q + y + 1 = q + 1 + y by omega) _ (by dsimp; omega),\n      Linear.units_smul_comp, Category.assoc, smul_smul, ι_totalDesc]\n    dsimp\n    rw [Linear.units_smul_comp, Linear.comp_units_smul, smul_smul, smul_smul,\n      ← Int.negOnePow_add, ← Int.negOnePow_add, ← Int.negOnePow_add,\n      ← Int.negOnePow_add]\n    congr 2\n    omega\n  · rw [D₂_shape _ _ _ _ h, zero_comp, D₂_shape, comp_zero, smul_zero]\n    intro h'\n    apply h\n    dsimp at h' ⊢\n    omega\n\n"}
{"name":"HomologicalComplex₂.ι_totalShift₂Iso_hom_f","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\ny : Int\ninst✝ : K.HasTotal (ComplexShape.up Int)\na b n : Int\nh : Eq (HAdd.hAdd a b) n\nb' : Int\nhb' : Eq b' (HAdd.hAdd b y)\nn' : Int\nhn' : Eq n' (HAdd.hAdd n y)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((HomologicalComplex₂.shiftFunctor₂ C y).obj K).ιTotal (ComplexShape.up Int) a b n h) ((K.totalShift₂Iso y).hom.f n)) (HSMul.hSMul (HMul.hMul a y).negOnePow (CategoryTheory.CategoryStruct.comp (K.shiftFunctor₂XXIso a b y b' hb').hom (CategoryTheory.CategoryStruct.comp (K.ιTotal (ComplexShape.up Int) a b' n' ⋯) (CochainComplex.shiftFunctorObjXIso (K.total (ComplexShape.up Int)) y n n' hn').inv)))","decl":"@[reassoc]\nlemma ι_totalShift₂Iso_hom_f (a b n : ℤ) (h : a + b = n) (b' : ℤ) (hb' : b' = b + y)\n    (n' : ℤ) (hn' : n' = n + y) :\n    ((shiftFunctor₂ C y).obj K).ιTotal (up ℤ) a b n h ≫ (K.totalShift₂Iso y).hom.f n =\n      (a * y).negOnePow • (K.shiftFunctor₂XXIso a b y b' hb').hom ≫\n        K.ιTotal (up ℤ) a b' n' (by dsimp; omega) ≫\n          (CochainComplex.shiftFunctorObjXIso (K.total (up ℤ)) y n n' hn').inv := by\n  subst hb' hn'\n  dsimp [totalShift₂Iso, totalShift₂XIso]\n  simp only [ι_totalDesc, comp_id, id_comp]\n\n"}
{"name":"HomologicalComplex₂.ι_totalShift₂Iso_hom_f_assoc","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\ny : Int\ninst✝ : K.HasTotal (ComplexShape.up Int)\na b n : Int\nh✝ : Eq (HAdd.hAdd a b) n\nb' : Int\nhb' : Eq b' (HAdd.hAdd b y)\nn' : Int\nhn' : Eq n' (HAdd.hAdd n y)\nZ : C\nh : Quiver.Hom (((CategoryTheory.shiftFunctor (HomologicalComplex C (ComplexShape.up Int)) y).obj (K.total (ComplexShape.up Int))).X n) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((HomologicalComplex₂.shiftFunctor₂ C y).obj K).ιTotal (ComplexShape.up Int) a b n h✝) (CategoryTheory.CategoryStruct.comp ((K.totalShift₂Iso y).hom.f n) h)) (CategoryTheory.CategoryStruct.comp (HSMul.hSMul (HMul.hMul a y).negOnePow (CategoryTheory.CategoryStruct.comp (K.shiftFunctor₂XXIso a b y b' hb').hom (CategoryTheory.CategoryStruct.comp (K.ιTotal (ComplexShape.up Int) a b' n' ⋯) (CochainComplex.shiftFunctorObjXIso (K.total (ComplexShape.up Int)) y n n' hn').inv))) h)","decl":"@[reassoc]\nlemma ι_totalShift₂Iso_hom_f (a b n : ℤ) (h : a + b = n) (b' : ℤ) (hb' : b' = b + y)\n    (n' : ℤ) (hn' : n' = n + y) :\n    ((shiftFunctor₂ C y).obj K).ιTotal (up ℤ) a b n h ≫ (K.totalShift₂Iso y).hom.f n =\n      (a * y).negOnePow • (K.shiftFunctor₂XXIso a b y b' hb').hom ≫\n        K.ιTotal (up ℤ) a b' n' (by dsimp; omega) ≫\n          (CochainComplex.shiftFunctorObjXIso (K.total (up ℤ)) y n n' hn').inv := by\n  subst hb' hn'\n  dsimp [totalShift₂Iso, totalShift₂XIso]\n  simp only [ι_totalDesc, comp_id, id_comp]\n\n"}
{"name":"HomologicalComplex₂.ι_totalShift₂Iso_inv_f_assoc","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\ny : Int\ninst✝ : K.HasTotal (ComplexShape.up Int)\na b n : Int\nh✝ : Eq (HAdd.hAdd a b) n\nb' n' : Int\nhb' : Eq (HAdd.hAdd a b') n'\nhn' : Eq n' (HAdd.hAdd n y)\nZ : C\nh : Quiver.Hom ((((HomologicalComplex₂.shiftFunctor₂ C y).obj K).total (ComplexShape.up Int)).X n) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.ιTotal (ComplexShape.up Int) a b' n' hb') (CategoryTheory.CategoryStruct.comp (CochainComplex.shiftFunctorObjXIso (K.total (ComplexShape.up Int)) y n n' hn').inv (CategoryTheory.CategoryStruct.comp ((K.totalShift₂Iso y).inv.f n) h))) (CategoryTheory.CategoryStruct.comp (HSMul.hSMul (HMul.hMul a y).negOnePow (CategoryTheory.CategoryStruct.comp (K.shiftFunctor₂XXIso a b y b' ⋯).inv (((HomologicalComplex₂.shiftFunctor₂ C y).obj K).ιTotal (ComplexShape.up Int) a b n h✝))) h)","decl":"@[reassoc]\nlemma ι_totalShift₂Iso_inv_f (a b n : ℤ) (h : a + b = n) (b' n' : ℤ)\n    (hb' : a + b' = n') (hn' : n' = n + y) :\n    K.ιTotal (up ℤ) a b' n' hb' ≫\n      (CochainComplex.shiftFunctorObjXIso (K.total (up ℤ)) y n n' hn').inv ≫\n        (K.totalShift₂Iso y).inv.f n =\n      (a * y).negOnePow • (K.shiftFunctor₂XXIso a b y b' (by omega)).inv ≫\n        ((shiftFunctor₂ C y).obj K).ιTotal (up ℤ) a b n h := by\n  subst hn'\n  obtain rfl : b = b' - y := by omega\n  dsimp [totalShift₂Iso, totalShift₂XIso, shiftFunctor₂XXIso, XXIsoOfEq]\n  simp only [id_comp, ι_totalDesc]\n\n"}
{"name":"HomologicalComplex₂.ι_totalShift₂Iso_inv_f","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\ny : Int\ninst✝ : K.HasTotal (ComplexShape.up Int)\na b n : Int\nh : Eq (HAdd.hAdd a b) n\nb' n' : Int\nhb' : Eq (HAdd.hAdd a b') n'\nhn' : Eq n' (HAdd.hAdd n y)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.ιTotal (ComplexShape.up Int) a b' n' hb') (CategoryTheory.CategoryStruct.comp (CochainComplex.shiftFunctorObjXIso (K.total (ComplexShape.up Int)) y n n' hn').inv ((K.totalShift₂Iso y).inv.f n))) (HSMul.hSMul (HMul.hMul a y).negOnePow (CategoryTheory.CategoryStruct.comp (K.shiftFunctor₂XXIso a b y b' ⋯).inv (((HomologicalComplex₂.shiftFunctor₂ C y).obj K).ιTotal (ComplexShape.up Int) a b n h)))","decl":"@[reassoc]\nlemma ι_totalShift₂Iso_inv_f (a b n : ℤ) (h : a + b = n) (b' n' : ℤ)\n    (hb' : a + b' = n') (hn' : n' = n + y) :\n    K.ιTotal (up ℤ) a b' n' hb' ≫\n      (CochainComplex.shiftFunctorObjXIso (K.total (up ℤ)) y n n' hn').inv ≫\n        (K.totalShift₂Iso y).inv.f n =\n      (a * y).negOnePow • (K.shiftFunctor₂XXIso a b y b' (by omega)).inv ≫\n        ((shiftFunctor₂ C y).obj K).ιTotal (up ℤ) a b n h := by\n  subst hn'\n  obtain rfl : b = b' - y := by omega\n  dsimp [totalShift₂Iso, totalShift₂XIso, shiftFunctor₂XXIso, XXIsoOfEq]\n  simp only [id_comp, ι_totalDesc]\n\n"}
{"name":"HomologicalComplex₂.totalShift₂Iso_hom_naturality","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nK L : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\nf : Quiver.Hom K L\ny : Int\ninst✝¹ : K.HasTotal (ComplexShape.up Int)\ninst✝ : L.HasTotal (ComplexShape.up Int)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex₂.total.map ((HomologicalComplex₂.shiftFunctor₂ C y).map f) (ComplexShape.up Int)) (L.totalShift₂Iso y).hom) (CategoryTheory.CategoryStruct.comp (K.totalShift₂Iso y).hom ((CategoryTheory.shiftFunctor (HomologicalComplex C (ComplexShape.up Int)) y).map (HomologicalComplex₂.total.map f (ComplexShape.up Int))))","decl":"variable {K L} in\n@[reassoc]\nlemma totalShift₂Iso_hom_naturality [L.HasTotal (up ℤ)] :\n    total.map ((shiftFunctor₂ C y).map f) (up ℤ) ≫ (L.totalShift₂Iso y).hom =\n      (K.totalShift₂Iso y).hom ≫ (total.map f (up ℤ))⟦y⟧' := by\n  ext n i₁ i₂ h\n  dsimp at h ⊢\n  rw [ιTotal_map_assoc, L.ι_totalShift₂Iso_hom_f y i₁ i₂ n h _ rfl _ rfl,\n    K.ι_totalShift₂Iso_hom_f_assoc y i₁ i₂ n h _ rfl _ rfl]\n  dsimp\n  rw [id_comp, id_comp, comp_id, comp_id, Linear.comp_units_smul,\n    Linear.units_smul_comp, ιTotal_map]\n\n"}
{"name":"HomologicalComplex₂.totalShift₂Iso_hom_naturality_assoc","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nK L : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\nf : Quiver.Hom K L\ny : Int\ninst✝¹ : K.HasTotal (ComplexShape.up Int)\ninst✝ : L.HasTotal (ComplexShape.up Int)\nZ : HomologicalComplex C (ComplexShape.up Int)\nh : Quiver.Hom ((CategoryTheory.shiftFunctor (HomologicalComplex C (ComplexShape.up Int)) y).obj (L.total (ComplexShape.up Int))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex₂.total.map ((HomologicalComplex₂.shiftFunctor₂ C y).map f) (ComplexShape.up Int)) (CategoryTheory.CategoryStruct.comp (L.totalShift₂Iso y).hom h)) (CategoryTheory.CategoryStruct.comp (K.totalShift₂Iso y).hom (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (HomologicalComplex C (ComplexShape.up Int)) y).map (HomologicalComplex₂.total.map f (ComplexShape.up Int))) h))","decl":"variable {K L} in\n@[reassoc]\nlemma totalShift₂Iso_hom_naturality [L.HasTotal (up ℤ)] :\n    total.map ((shiftFunctor₂ C y).map f) (up ℤ) ≫ (L.totalShift₂Iso y).hom =\n      (K.totalShift₂Iso y).hom ≫ (total.map f (up ℤ))⟦y⟧' := by\n  ext n i₁ i₂ h\n  dsimp at h ⊢\n  rw [ιTotal_map_assoc, L.ι_totalShift₂Iso_hom_f y i₁ i₂ n h _ rfl _ rfl,\n    K.ι_totalShift₂Iso_hom_f_assoc y i₁ i₂ n h _ rfl _ rfl]\n  dsimp\n  rw [id_comp, id_comp, comp_id, comp_id, Linear.comp_units_smul,\n    Linear.units_smul_comp, ιTotal_map]\n\n"}
{"name":"HomologicalComplex₂.totalShift₁Iso_trans_totalShift₂Iso","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\nx y : Int\ninst✝ : K.HasTotal (ComplexShape.up Int)\n⊢ Eq ((((HomologicalComplex₂.shiftFunctor₂ C y).obj K).totalShift₁Iso x).trans ((CategoryTheory.shiftFunctor (CochainComplex C Int) x).mapIso (K.totalShift₂Iso y))) (HSMul.hSMul (HMul.hMul x y).negOnePow ((HomologicalComplex₂.total.mapIso ((HomologicalComplex₂.shiftFunctor₁₂CommIso C x y).app K) (ComplexShape.up Int)).trans ((((HomologicalComplex₂.shiftFunctor₁ C x).obj K).totalShift₂Iso y).trans (((CategoryTheory.shiftFunctor (HomologicalComplex C (ComplexShape.up Int)) y).mapIso (K.totalShift₁Iso x)).trans ((CategoryTheory.shiftFunctorComm (CochainComplex C Int) x y).app (K.total (ComplexShape.up Int)))))))","decl":"/-- The compatibility isomorphisms of the total complex with the shifts\nin both variables \"commute\" only up to a sign `(x * y).negOnePow`. -/\nlemma totalShift₁Iso_trans_totalShift₂Iso :\n    ((shiftFunctor₂ C y).obj K).totalShift₁Iso x ≪≫\n      (shiftFunctor (CochainComplex C ℤ) x).mapIso (K.totalShift₂Iso y) =\n    (x * y).negOnePow • (total.mapIso ((shiftFunctor₁₂CommIso C x y).app K) (up ℤ)) ≪≫\n      ((shiftFunctor₁ C x).obj K).totalShift₂Iso y ≪≫\n      (shiftFunctor _ y).mapIso (K.totalShift₁Iso x) ≪≫\n      (shiftFunctorComm (CochainComplex C ℤ) x y).app _ := by\n  ext n n₁ n₂ h\n  dsimp at h ⊢\n  rw [Linear.comp_units_smul,ι_totalShift₁Iso_hom_f_assoc _ x n₁ n₂ n h _ rfl _ rfl,\n    ιTotal_map_assoc, ι_totalShift₂Iso_hom_f_assoc _ y n₁ n₂ n h _ rfl _ rfl,\n    Linear.units_smul_comp, Linear.comp_units_smul]\n  dsimp [shiftFunctor₁₂CommIso]\n  rw [id_comp, id_comp, id_comp, id_comp, comp_id,\n    ι_totalShift₂Iso_hom_f _ y (n₁ + x) n₂ (n + x) (by omega) _ rfl _ rfl, smul_smul,\n    ← Int.negOnePow_add, add_mul, add_comm (x * y)]\n  dsimp\n  rw [id_comp, comp_id,\n    ι_totalShift₁Iso_hom_f_assoc _ x n₁ (n₂ + y) (n + y) (by omega) _ rfl (n + x + y) (by omega),\n    CochainComplex.shiftFunctorComm_hom_app_f]\n  dsimp\n  rw [Iso.inv_hom_id, comp_id, id_comp]\n\n"}
{"name":"HomologicalComplex₂.totalShift₁Iso_hom_totalShift₂Iso_hom_assoc","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\nx y : Int\ninst✝ : K.HasTotal (ComplexShape.up Int)\nZ : HomologicalComplex C (ComplexShape.up Int)\nh : Quiver.Hom ((CategoryTheory.shiftFunctor (HomologicalComplex C (ComplexShape.up Int)) x).obj ((CategoryTheory.shiftFunctor (HomologicalComplex C (ComplexShape.up Int)) y).obj (K.total (ComplexShape.up Int)))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((HomologicalComplex₂.shiftFunctor₂ C y).obj K).totalShift₁Iso x).hom (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (HomologicalComplex C (ComplexShape.up Int)) x).map (K.totalShift₂Iso y).hom) h)) (CategoryTheory.CategoryStruct.comp (HSMul.hSMul (HMul.hMul x y).negOnePow (CategoryTheory.CategoryStruct.comp (HomologicalComplex₂.total.map ((HomologicalComplex₂.shiftFunctor₁₂CommIso C x y).hom.app K) (ComplexShape.up Int)) (CategoryTheory.CategoryStruct.comp (((HomologicalComplex₂.shiftFunctor₁ C x).obj K).totalShift₂Iso y).hom (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (HomologicalComplex C (ComplexShape.up Int)) y).map (K.totalShift₁Iso x).hom) ((CategoryTheory.shiftFunctorComm (CochainComplex C Int) x y).hom.app (K.total (ComplexShape.up Int))))))) h)","decl":"/-- The compatibility isomorphisms of the total complex with the shifts\nin both variables \"commute\" only up to a sign `(x * y).negOnePow`. -/\n@[reassoc]\nlemma totalShift₁Iso_hom_totalShift₂Iso_hom :\n    (((shiftFunctor₂ C y).obj K).totalShift₁Iso x).hom ≫ (K.totalShift₂Iso y).hom⟦x⟧' =\n      (x * y).negOnePow • (total.map ((shiftFunctor₁₂CommIso C x y).hom.app K) (up ℤ) ≫\n          (((shiftFunctor₁ C x).obj K).totalShift₂Iso y).hom ≫\n          (K.totalShift₁Iso x).hom⟦y⟧' ≫\n          (shiftFunctorComm (CochainComplex C ℤ) x y).hom.app _) :=\n  congr_arg Iso.hom (totalShift₁Iso_trans_totalShift₂Iso K x y)\n\n"}
{"name":"HomologicalComplex₂.totalShift₁Iso_hom_totalShift₂Iso_hom","module":"Mathlib.Algebra.Homology.TotalComplexShift","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : HomologicalComplex₂ C (ComplexShape.up Int) (ComplexShape.up Int)\nx y : Int\ninst✝ : K.HasTotal (ComplexShape.up Int)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((HomologicalComplex₂.shiftFunctor₂ C y).obj K).totalShift₁Iso x).hom ((CategoryTheory.shiftFunctor (HomologicalComplex C (ComplexShape.up Int)) x).map (K.totalShift₂Iso y).hom)) (HSMul.hSMul (HMul.hMul x y).negOnePow (CategoryTheory.CategoryStruct.comp (HomologicalComplex₂.total.map ((HomologicalComplex₂.shiftFunctor₁₂CommIso C x y).hom.app K) (ComplexShape.up Int)) (CategoryTheory.CategoryStruct.comp (((HomologicalComplex₂.shiftFunctor₁ C x).obj K).totalShift₂Iso y).hom (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (HomologicalComplex C (ComplexShape.up Int)) y).map (K.totalShift₁Iso x).hom) ((CategoryTheory.shiftFunctorComm (CochainComplex C Int) x y).hom.app (K.total (ComplexShape.up Int)))))))","decl":"/-- The compatibility isomorphisms of the total complex with the shifts\nin both variables \"commute\" only up to a sign `(x * y).negOnePow`. -/\n@[reassoc]\nlemma totalShift₁Iso_hom_totalShift₂Iso_hom :\n    (((shiftFunctor₂ C y).obj K).totalShift₁Iso x).hom ≫ (K.totalShift₂Iso y).hom⟦x⟧' =\n      (x * y).negOnePow • (total.map ((shiftFunctor₁₂CommIso C x y).hom.app K) (up ℤ) ≫\n          (((shiftFunctor₁ C x).obj K).totalShift₂Iso y).hom ≫\n          (K.totalShift₁Iso x).hom⟦y⟧' ≫\n          (shiftFunctorComm (CochainComplex C ℤ) x y).hom.app _) :=\n  congr_arg Iso.hom (totalShift₁Iso_trans_totalShift₂Iso K x y)\n\n"}
