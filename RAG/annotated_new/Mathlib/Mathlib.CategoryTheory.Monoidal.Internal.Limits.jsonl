{"name":"Mon_.limit_mul","module":"Mathlib.CategoryTheory.Monoidal.Internal.Limits","initialProofState":"J : Type w\ninst✝³ : CategoryTheory.SmallCategory J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst✝ : CategoryTheory.MonoidalCategory C\nF : CategoryTheory.Functor J (Mon_ C)\n⊢ Eq (Mon_.limit F).mul (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ CategoryTheory.Limits.lim (F.comp (Mon_.forget C)) (F.comp (Mon_.forget C))) (CategoryTheory.Limits.limMap (CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverseObj F).mul))","decl":"/-- We construct the (candidate) limit of a functor `F : J ⥤ Mon_ C`\nby interpreting it as a functor `Mon_ (J ⥤ C)`,\nand noting that taking limits is a lax monoidal functor,\nand hence sends monoid objects to monoid objects.\n-/\n@[simps!]\ndef limit (F : J ⥤ Mon_ C) : Mon_ C :=\n  lim.mapMon.obj ((monFunctorCategoryEquivalence J C).inverse.obj F)\n\n"}
{"name":"Mon_.limit_X","module":"Mathlib.CategoryTheory.Monoidal.Internal.Limits","initialProofState":"J : Type w\ninst✝³ : CategoryTheory.SmallCategory J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst✝ : CategoryTheory.MonoidalCategory C\nF : CategoryTheory.Functor J (Mon_ C)\n⊢ Eq (Mon_.limit F).X (CategoryTheory.Limits.limit (F.comp (Mon_.forget C)))","decl":"/-- We construct the (candidate) limit of a functor `F : J ⥤ Mon_ C`\nby interpreting it as a functor `Mon_ (J ⥤ C)`,\nand noting that taking limits is a lax monoidal functor,\nand hence sends monoid objects to monoid objects.\n-/\n@[simps!]\ndef limit (F : J ⥤ Mon_ C) : Mon_ C :=\n  lim.mapMon.obj ((monFunctorCategoryEquivalence J C).inverse.obj F)\n\n"}
{"name":"Mon_.limit_one","module":"Mathlib.CategoryTheory.Monoidal.Internal.Limits","initialProofState":"J : Type w\ninst✝³ : CategoryTheory.SmallCategory J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst✝ : CategoryTheory.MonoidalCategory C\nF : CategoryTheory.Functor J (Mon_ C)\n⊢ Eq (Mon_.limit F).one (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.ε CategoryTheory.Limits.lim) (CategoryTheory.Limits.limMap (CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverseObj F).one))","decl":"/-- We construct the (candidate) limit of a functor `F : J ⥤ Mon_ C`\nby interpreting it as a functor `Mon_ (J ⥤ C)`,\nand noting that taking limits is a lax monoidal functor,\nand hence sends monoid objects to monoid objects.\n-/\n@[simps!]\ndef limit (F : J ⥤ Mon_ C) : Mon_ C :=\n  lim.mapMon.obj ((monFunctorCategoryEquivalence J C).inverse.obj F)\n\n"}
{"name":"Mon_.limitCone_π_app_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.Limits","initialProofState":"J : Type w\ninst✝³ : CategoryTheory.SmallCategory J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst✝ : CategoryTheory.MonoidalCategory C\nF : CategoryTheory.Functor J (Mon_ C)\nj : J\n⊢ Eq ((Mon_.limitCone F).π.app j).hom (CategoryTheory.Limits.limit.π (F.comp (Mon_.forget C)) j)","decl":"/-- Implementation of `Mon_.hasLimits`: a limiting cone over a functor `F : J ⥤ Mon_ C`.\n-/\n@[simps]\ndef limitCone (F : J ⥤ Mon_ C) : Cone F where\n  pt := limit F\n  π :=\n    { app := fun j => { hom := limit.π (F ⋙ Mon_.forget C) j }\n      naturality := fun j j' f => by ext; exact (limit.cone (F ⋙ Mon_.forget C)).π.naturality f }\n\n"}
{"name":"Mon_.limitCone_pt","module":"Mathlib.CategoryTheory.Monoidal.Internal.Limits","initialProofState":"J : Type w\ninst✝³ : CategoryTheory.SmallCategory J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst✝ : CategoryTheory.MonoidalCategory C\nF : CategoryTheory.Functor J (Mon_ C)\n⊢ Eq (Mon_.limitCone F).pt (Mon_.limit F)","decl":"/-- Implementation of `Mon_.hasLimits`: a limiting cone over a functor `F : J ⥤ Mon_ C`.\n-/\n@[simps]\ndef limitCone (F : J ⥤ Mon_ C) : Cone F where\n  pt := limit F\n  π :=\n    { app := fun j => { hom := limit.π (F ⋙ Mon_.forget C) j }\n      naturality := fun j j' f => by ext; exact (limit.cone (F ⋙ Mon_.forget C)).π.naturality f }\n\n"}
{"name":"Mon_.limitConeIsLimit_lift_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.Limits","initialProofState":"J : Type w\ninst✝³ : CategoryTheory.SmallCategory J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst✝ : CategoryTheory.MonoidalCategory C\nF : CategoryTheory.Functor J (Mon_ C)\ns : CategoryTheory.Limits.Cone F\n⊢ Eq ((Mon_.limitConeIsLimit F).lift s).hom (CategoryTheory.Limits.limit.lift (F.comp (Mon_.forget C)) ((Mon_.forget C).mapCone s))","decl":"/-- Implementation of `Mon_.hasLimitsOfShape`:\nthe proposed cone over a functor `F : J ⥤ Mon_ C` is a limit cone.\n-/\n@[simps]\ndef limitConeIsLimit (F : J ⥤ Mon_ C) : IsLimit (limitCone F) where\n  lift s :=\n    { hom := limit.lift (F ⋙ Mon_.forget C) ((Mon_.forget C).mapCone s)\n      mul_hom := limit.hom_ext (fun j ↦ by\n        dsimp\n        simp only [Category.assoc, limit.lift_π, Functor.mapCone_pt, forget_obj,\n          Functor.mapCone_π_app, forget_map, Hom.mul_hom, limMap_π, tensorObj_obj, Functor.comp_obj,\n          MonFunctorCategoryEquivalence.inverseObj_mul_app, lim_μ_π_assoc, lim_obj,\n          ← MonoidalCategory.tensor_comp_assoc]) }\n  fac s h := by ext; simp\n  uniq s m w := by\n    ext1\n    refine limit.hom_ext (fun j => ?_)\n    dsimp; simp only [Mon_.forget_map, limit.lift_π, Functor.mapCone_π_app]\n    exact congr_arg Mon_.Hom.hom (w j)\n\n"}
{"name":"Mon_.hasLimitsOfShape","module":"Mathlib.CategoryTheory.Monoidal.Internal.Limits","initialProofState":"J : Type w\ninst✝³ : CategoryTheory.SmallCategory J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\n⊢ CategoryTheory.Limits.HasLimitsOfShape J (Mon_ C)","decl":"instance hasLimitsOfShape [HasLimitsOfShape J C] : HasLimitsOfShape J (Mon_ C) where\n  has_limit := fun F => HasLimit.mk\n    { cone := limitCone F\n      isLimit := limitConeIsLimit F }\n\n"}
{"name":"Mon_.forget_freservesLimitsOfShape","module":"Mathlib.CategoryTheory.Monoidal.Internal.Limits","initialProofState":"J : Type w\ninst✝³ : CategoryTheory.SmallCategory J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst✝ : CategoryTheory.MonoidalCategory C\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J (Mon_.forget C)","decl":"instance forget_freservesLimitsOfShape : PreservesLimitsOfShape J (Mon_.forget C) where\n  preservesLimit := fun {F} =>\n    preservesLimit_of_preserves_limit_cone (limitConeIsLimit F)\n      (IsLimit.ofIsoLimit (limit.isLimit (F ⋙ Mon_.forget C)) (forgetMapConeLimitConeIso F).symm)\n\n"}
