{"name":"Sym.coe_injective","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\n⊢ Function.Injective Sym.toMultiset","decl":"theorem coe_injective : Injective ((↑) : Sym α n → Multiset α) :=\n  Subtype.coe_injective\n\n"}
{"name":"Sym.coe_inj","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ns₁ s₂ : Sym α n\n⊢ Iff (Eq ↑s₁ ↑s₂) (Eq s₁ s₂)","decl":"@[simp, norm_cast]\ntheorem coe_inj {s₁ s₂ : Sym α n} : (s₁ : Multiset α) = s₂ ↔ s₁ = s₂ :=\n  coe_injective.eq_iff\n\n"}
{"name":"Sym.ext_iff","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ns₁ s₂ : Sym α n\n⊢ Iff (Eq s₁ s₂) (Eq ↑s₁ ↑s₂)","decl":"@[ext] theorem ext {s₁ s₂ : Sym α n} (h : (s₁ : Multiset α) = ↑s₂) : s₁ = s₂ :=\n  coe_injective h\n\n"}
{"name":"Sym.ext","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ns₁ s₂ : Sym α n\nh : Eq ↑s₁ ↑s₂\n⊢ Eq s₁ s₂","decl":"@[ext] theorem ext {s₁ s₂ : Sym α n} (h : (s₁ : Multiset α) = ↑s₂) : s₁ = s₂ :=\n  coe_injective h\n\n"}
{"name":"Sym.val_eq_coe","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ns : Sym α n\n⊢ Eq ↑s ↑s","decl":"@[simp]\ntheorem val_eq_coe (s : Sym α n) : s.1 = ↑s :=\n  rfl\n\n"}
{"name":"Sym.coe_nil","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\n⊢ Eq (↑Sym.nil) 0","decl":"@[simp]\ntheorem coe_nil : ↑(@Sym.nil α) = (0 : Multiset α) :=\n  rfl\n\n"}
{"name":"Sym.cons_inj_right","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\na : α\ns s' : Sym α n\n⊢ Iff (Eq (Sym.cons a s) (Sym.cons a s')) (Eq s s')","decl":"@[simp]\ntheorem cons_inj_right (a : α) (s s' : Sym α n) : a ::ₛ s = a ::ₛ s' ↔ s = s' :=\n  Subtype.ext_iff.trans <| (Multiset.cons_inj_right _).trans Subtype.ext_iff.symm\n\n"}
{"name":"Sym.cons_inj_left","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\na a' : α\ns : Sym α n\n⊢ Iff (Eq (Sym.cons a s) (Sym.cons a' s)) (Eq a a')","decl":"@[simp]\ntheorem cons_inj_left (a a' : α) (s : Sym α n) : a ::ₛ s = a' ::ₛ s ↔ a = a' :=\n  Subtype.ext_iff.trans <| Multiset.cons_inj_left _\n\n"}
{"name":"Sym.cons_swap","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\na b : α\ns : Sym α n\n⊢ Eq (Sym.cons a (Sym.cons b s)) (Sym.cons b (Sym.cons a s))","decl":"theorem cons_swap (a b : α) (s : Sym α n) : a ::ₛ b ::ₛ s = b ::ₛ a ::ₛ s :=\n  Subtype.ext <| Multiset.cons_swap a b s.1\n\n"}
{"name":"Sym.coe_cons","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ns : Sym α n\na : α\n⊢ Eq (↑(Sym.cons a s)) (Multiset.cons a ↑s)","decl":"theorem coe_cons (s : Sym α n) (a : α) : (a ::ₛ s : Multiset α) = a ::ₘ s :=\n  rfl\n\n"}
{"name":"Sym.ofVector_nil","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\n⊢ Eq (Sym.ofVector List.Vector.nil) Sym.nil","decl":"@[simp]\ntheorem ofVector_nil : ↑(Vector.nil : List.Vector α 0) = (Sym.nil : Sym α 0) :=\n  rfl\n\n"}
{"name":"Sym.ofVector_cons","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\na : α\nv : List.Vector α n\n⊢ Eq (Sym.ofVector (List.Vector.cons a v)) (Sym.cons a (Sym.ofVector v))","decl":"@[simp]\ntheorem ofVector_cons (a : α) (v : List.Vector α n) :\n    ↑(Vector.cons a v) = a ::ₛ (↑v : Sym α n) := by\n  cases v\n  rfl\n\n"}
{"name":"Sym.card_coe","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ns : Sym α n\n⊢ Eq (↑s).card n","decl":"@[simp]\ntheorem card_coe : Multiset.card (s : Multiset α) = n := s.prop\n\n"}
{"name":"Sym.coe_mk","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ns : Multiset α\nh : Eq s.card n\n⊢ Eq (↑(Sym.mk s h)) s","decl":"@[simp, norm_cast] lemma coe_mk (s : Multiset α) (h : Multiset.card s = n) : mk s h = s := rfl\n\n"}
{"name":"Sym.mem_mk","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\na : α\ns : Multiset α\nh : Eq s.card n\n⊢ Iff (Membership.mem (Sym.mk s h) a) (Membership.mem s a)","decl":"@[simp]\ntheorem mem_mk (a : α) (s : Multiset α) (h : Multiset.card s = n) : a ∈ mk s h ↔ a ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Sym.forall","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\np : Sym α n → Prop\n⊢ Iff (∀ (s : Sym α n), p s) (∀ (s : Multiset α) (hs : Eq s.card n), p (Sym.mk s hs))","decl":"lemma «forall» {p : Sym α n → Prop} :\n    (∀ s : Sym α n, p s) ↔ ∀ (s : Multiset α) (hs : Multiset.card s = n), p (Sym.mk s hs) := by\n  simp [Sym]\n\n"}
{"name":"Sym.exists","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\np : Sym α n → Prop\n⊢ Iff (Exists fun s => p s) (Exists fun s => Exists fun hs => p (Sym.mk s hs))","decl":"lemma «exists» {p : Sym α n → Prop} :\n    (∃ s : Sym α n, p s) ↔ ∃ (s : Multiset α) (hs : Multiset.card s = n), p (Sym.mk s hs) := by\n  simp [Sym]\n\n"}
{"name":"Sym.not_mem_nil","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\na : α\n⊢ Not (Membership.mem Sym.nil a)","decl":"@[simp]\ntheorem not_mem_nil (a : α) : ¬ a ∈ (nil : Sym α 0) :=\n  Multiset.not_mem_zero a\n\n"}
{"name":"Sym.mem_cons","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ns : Sym α n\na b : α\n⊢ Iff (Membership.mem (Sym.cons b s) a) (Or (Eq a b) (Membership.mem s a))","decl":"@[simp]\ntheorem mem_cons : a ∈ b ::ₛ s ↔ a = b ∨ a ∈ s :=\n  Multiset.mem_cons\n\n"}
{"name":"Sym.mem_coe","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ns : Sym α n\na : α\n⊢ Iff (Membership.mem (↑s) a) (Membership.mem s a)","decl":"@[simp]\ntheorem mem_coe : a ∈ (s : Multiset α) ↔ a ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Sym.mem_cons_of_mem","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ns : Sym α n\na b : α\nh : Membership.mem s a\n⊢ Membership.mem (Sym.cons b s) a","decl":"theorem mem_cons_of_mem (h : a ∈ s) : a ∈ b ::ₛ s :=\n  Multiset.mem_cons_of_mem h\n\n"}
{"name":"Sym.mem_cons_self","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\na : α\ns : Sym α n\n⊢ Membership.mem (Sym.cons a s) a","decl":"theorem mem_cons_self (a : α) (s : Sym α n) : a ∈ a ::ₛ s :=\n  Multiset.mem_cons_self a s.1\n\n"}
{"name":"Sym.cons_of_coe_eq","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\na : α\nv : List.Vector α n\n⊢ Eq (Sym.cons a (Sym.ofVector v)) (Sym.ofVector (List.Vector.cons a v))","decl":"theorem cons_of_coe_eq (a : α) (v : List.Vector α n) : a ::ₛ (↑v : Sym α n) = ↑(a ::ᵥ v) :=\n  Subtype.ext <| by\n    cases v\n    rfl\n\n"}
{"name":"Sym.sound","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\na b : List.Vector α n\nh : (↑a).Perm ↑b\n⊢ Eq (Sym.ofVector a) (Sym.ofVector b)","decl":"open scoped List in\ntheorem sound {a b : List.Vector α n} (h : a.val ~ b.val) : (↑a : Sym α n) = ↑b :=\n  Subtype.ext <| Quotient.sound h\n\n"}
{"name":"Sym.erase_mk","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : DecidableEq α\nm : Multiset α\nhc : Eq m.card (HAdd.hAdd n 1)\na : α\nh : Membership.mem m a\n⊢ Eq ((Sym.mk m hc).erase a h) (Sym.mk (m.erase a) ⋯)","decl":"@[simp]\ntheorem erase_mk [DecidableEq α] (m : Multiset α)\n    (hc : Multiset.card m = n + 1) (a : α) (h : a ∈ m) :\n    (mk m hc).erase a h =mk (m.erase a)\n        (by rw [Multiset.card_erase_of_mem h, hc, Nat.add_one, Nat.pred_succ]) :=\n  rfl\n\n"}
{"name":"Sym.coe_erase","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : DecidableEq α\ns : Sym α n.succ\na : α\nh : Membership.mem s a\n⊢ Eq (↑(s.erase a h)) ((↑s).erase a)","decl":"@[simp]\ntheorem coe_erase [DecidableEq α] {s : Sym α n.succ} {a : α} (h : a ∈ s) :\n    (s.erase a h : Multiset α) = Multiset.erase s a :=\n  rfl\n\n"}
{"name":"Sym.cons_erase","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : DecidableEq α\ns : Sym α n.succ\na : α\nh : Membership.mem s a\n⊢ Eq (Sym.cons a (s.erase a h)) s","decl":"@[simp]\ntheorem cons_erase [DecidableEq α] {s : Sym α n.succ} {a : α} (h : a ∈ s) : a ::ₛ s.erase a h = s :=\n  coe_injective <| Multiset.cons_erase h\n\n"}
{"name":"Sym.erase_cons_head","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : DecidableEq α\ns : Sym α n\na : α\nh : optParam (Membership.mem (Sym.cons a s) a) ⋯\n⊢ Eq ((Sym.cons a s).erase a h) s","decl":"@[simp]\ntheorem erase_cons_head [DecidableEq α] (s : Sym α n) (a : α)\n    (h : a ∈ a ::ₛ s := mem_cons_self a s) : (a ::ₛ s).erase a h = s :=\n  coe_injective <| Multiset.erase_cons_head a s.1\n\n"}
{"name":"Sym.cons_equiv_eq_equiv_cons","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_3\nn : Nat\na : α\ns : Sym α n\n⊢ Eq (Sym.cons' a (Sym.symEquivSym' s)) (Sym.symEquivSym' (Sym.cons a s))","decl":"theorem cons_equiv_eq_equiv_cons (α : Type*) (n : ℕ) (a : α) (s : Sym α n) :\n    (a::symEquivSym' s) = symEquivSym' (a ::ₛ s) := by\n  rcases s with ⟨⟨l⟩, _⟩\n  rfl\n\n"}
{"name":"Sym.toMultiset_zero","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\n⊢ Eq (↑0) 0","decl":"@[simp] theorem toMultiset_zero : toMultiset (0 : Sym α 0) = 0 := rfl\n\n"}
{"name":"Sym.eq_nil_of_card_zero","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\ns : Sym α 0\n⊢ Eq s Sym.nil","decl":"theorem eq_nil_of_card_zero (s : Sym α 0) : s = nil :=\n  Subtype.ext <| Multiset.card_eq_zero.1 s.2\n\n"}
{"name":"Sym.replicate_succ","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\na : α\nn : Nat\n⊢ Eq (Sym.replicate n.succ a) (Sym.cons a (Sym.replicate n a))","decl":"theorem replicate_succ {a : α} {n : ℕ} : replicate n.succ a = a ::ₛ replicate n a :=\n  rfl\n\n"}
{"name":"Sym.coe_replicate","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\na : α\n⊢ Eq (↑(Sym.replicate n a)) (Multiset.replicate n a)","decl":"theorem coe_replicate : (replicate n a : Multiset α) = Multiset.replicate n a :=\n  rfl\n\n"}
{"name":"Sym.mem_replicate","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\na b : α\n⊢ Iff (Membership.mem (Sym.replicate n a) b) (And (Ne n 0) (Eq b a))","decl":"@[simp]\ntheorem mem_replicate : b ∈ replicate n a ↔ n ≠ 0 ∧ b = a :=\n  Multiset.mem_replicate\n\n"}
{"name":"Sym.eq_replicate_iff","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ns : Sym α n\na : α\n⊢ Iff (Eq s (Sym.replicate n a)) (∀ (b : α), Membership.mem s b → Eq b a)","decl":"theorem eq_replicate_iff : s = replicate n a ↔ ∀ b ∈ s, b = a := by\n  erw [Subtype.ext_iff, Multiset.eq_replicate]\n  exact and_iff_right s.2\n\n"}
{"name":"Sym.exists_mem","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ns : Sym α n.succ\n⊢ Exists fun a => Membership.mem s a","decl":"theorem exists_mem (s : Sym α n.succ) : ∃ a, a ∈ s :=\n  Multiset.card_pos_iff_exists_mem.1 <| s.2.symm ▸ n.succ_pos\n\n"}
{"name":"Sym.exists_cons_of_mem","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ns : Sym α (HAdd.hAdd n 1)\na : α\nh : Membership.mem s a\n⊢ Exists fun t => Eq s (Sym.cons a t)","decl":"theorem exists_cons_of_mem {s : Sym α (n + 1)} {a : α} (h : a ∈ s) : ∃ t, s = a ::ₛ t := by\n  obtain ⟨m, h⟩ := Multiset.exists_cons_of_mem h\n  have : Multiset.card m = n := by\n    apply_fun Multiset.card at h\n    rw [s.2, Multiset.card_cons, add_left_inj] at h\n    exact h.symm\n  use ⟨m, this⟩\n  apply Subtype.ext\n  exact h\n\n"}
{"name":"Sym.exists_eq_cons_of_succ","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ns : Sym α n.succ\n⊢ Exists fun a => Exists fun s' => Eq s (Sym.cons a s')","decl":"theorem exists_eq_cons_of_succ (s : Sym α n.succ) : ∃ (a : α) (s' : Sym α n), s = a ::ₛ s' := by\n  obtain ⟨a, ha⟩ := exists_mem s\n  classical exact ⟨a, s.erase a ha, (cons_erase ha).symm⟩\n\n"}
{"name":"Sym.eq_replicate","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\na : α\nn : Nat\ns : Sym α n\n⊢ Iff (Eq s (Sym.replicate n a)) (∀ (b : α), Membership.mem s b → Eq b a)","decl":"theorem eq_replicate {a : α} {n : ℕ} {s : Sym α n} : s = replicate n a ↔ ∀ b ∈ s, b = a :=\n  Subtype.ext_iff.trans <| Multiset.eq_replicate.trans <| and_iff_right s.prop\n\n"}
{"name":"Sym.eq_replicate_of_subsingleton","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\ninst✝ : Subsingleton α\na : α\nn : Nat\ns : Sym α n\n⊢ Eq s (Sym.replicate n a)","decl":"theorem eq_replicate_of_subsingleton [Subsingleton α] (a : α) {n : ℕ} (s : Sym α n) :\n    s = replicate n a :=\n  eq_replicate.2 fun _ _ => Subsingleton.elim _ _\n\n"}
{"name":"Sym.instSubsingleton","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\ninst✝ : Subsingleton α\nn : Nat\n⊢ Subsingleton (Sym α n)","decl":"instance [Subsingleton α] (n : ℕ) : Subsingleton (Sym α n) :=\n  ⟨by\n    cases n\n    · simp [eq_iff_true_of_subsingleton]\n    · intro s s'\n      obtain ⟨b, -⟩ := exists_mem s\n      rw [eq_replicate_of_subsingleton b s', eq_replicate_of_subsingleton b s]⟩\n\n"}
{"name":"Sym.instIsEmptySucc","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : IsEmpty α\n⊢ IsEmpty (Sym α n.succ)","decl":"instance (n : ℕ) [IsEmpty α] : IsEmpty (Sym α n.succ) :=\n  ⟨fun s => by\n    obtain ⟨a, -⟩ := exists_mem s\n    exact isEmptyElim a⟩\n\n"}
{"name":"Sym.replicate_right_inj","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\na b : α\nn : Nat\nh : Ne n 0\n⊢ Iff (Eq (Sym.replicate n a) (Sym.replicate n b)) (Eq a b)","decl":"theorem replicate_right_inj {a b : α} {n : ℕ} (h : n ≠ 0) : replicate n a = replicate n b ↔ a = b :=\n  Subtype.ext_iff.trans (Multiset.replicate_right_inj h)\n\n"}
{"name":"Sym.replicate_right_injective","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\nh : Ne n 0\n⊢ Function.Injective (Sym.replicate n)","decl":"theorem replicate_right_injective {n : ℕ} (h : n ≠ 0) :\n    Function.Injective (replicate n : α → Sym α n) := fun _ _ => (replicate_right_inj h).1\n\n"}
{"name":"Sym.instNontrivialHAddNatOfNat","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : Nontrivial α\n⊢ Nontrivial (Sym α (HAdd.hAdd n 1))","decl":"instance (n : ℕ) [Nontrivial α] : Nontrivial (Sym α (n + 1)) :=\n  (replicate_right_injective n.succ_ne_zero).nontrivial\n\n"}
{"name":"Sym.mem_map","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Nat\nf : α → β\nb : β\nl : Sym α n\n⊢ Iff (Membership.mem (Sym.map f l) b) (Exists fun a => And (Membership.mem l a) (Eq (f a) b))","decl":"@[simp]\ntheorem mem_map {n : ℕ} {f : α → β} {b : β} {l : Sym α n} :\n    b ∈ Sym.map f l ↔ ∃ a, a ∈ l ∧ f a = b :=\n  Multiset.mem_map\n\n"}
{"name":"Sym.map_id'","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_3\nn : Nat\ns : Sym α n\n⊢ Eq (Sym.map (fun x => x) s) s","decl":"/-- Note: `Sym.map_id` is not simp-normal, as simp ends up unfolding `id` with `Sym.map_congr` -/\n@[simp]\ntheorem map_id' {α : Type*} {n : ℕ} (s : Sym α n) : Sym.map (fun x : α => x) s = s := by\n  ext; simp only [map, Multiset.map_id', ← val_eq_coe]\n\n"}
{"name":"Sym.map_id","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_3\nn : Nat\ns : Sym α n\n⊢ Eq (Sym.map id s) s","decl":"theorem map_id {α : Type*} {n : ℕ} (s : Sym α n) : Sym.map id s = s := by\n  ext; simp only [map, id_eq, Multiset.map_id', ← val_eq_coe]\n\n"}
{"name":"Sym.map_map","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\nn : Nat\ng : β → γ\nf : α → β\ns : Sym α n\n⊢ Eq (Sym.map g (Sym.map f s)) (Sym.map (Function.comp g f) s)","decl":"@[simp]\ntheorem map_map {α β γ : Type*} {n : ℕ} (g : β → γ) (f : α → β) (s : Sym α n) :\n    Sym.map g (Sym.map f s) = Sym.map (g ∘ f) s :=\n  Subtype.ext <| by dsimp only [Sym.map]; simp\n\n"}
{"name":"Sym.map_zero","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (Sym.map f 0) 0","decl":"@[simp]\ntheorem map_zero (f : α → β) : Sym.map f (0 : Sym α 0) = (0 : Sym β 0) :=\n  rfl\n\n"}
{"name":"Sym.map_cons","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Nat\nf : α → β\na : α\ns : Sym α n\n⊢ Eq (Sym.map f (Sym.cons a s)) (Sym.cons (f a) (Sym.map f s))","decl":"@[simp]\ntheorem map_cons {n : ℕ} (f : α → β) (a : α) (s : Sym α n) : (a ::ₛ s).map f = f a ::ₛ s.map f :=\n  ext <| Multiset.map_cons _ _ _\n\n"}
{"name":"Sym.map_congr","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Nat\nf g : α → β\ns : Sym α n\nh : ∀ (x : α), Membership.mem s x → Eq (f x) (g x)\n⊢ Eq (Sym.map f s) (Sym.map g s)","decl":"@[congr]\ntheorem map_congr {f g : α → β} {s : Sym α n} (h : ∀ x ∈ s, f x = g x) : map f s = map g s :=\n  Subtype.ext <| Multiset.map_congr rfl h\n\n"}
{"name":"Sym.map_mk","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Nat\nf : α → β\nm : Multiset α\nhc : Eq m.card n\n⊢ Eq (Sym.map f (Sym.mk m hc)) (Sym.mk (Multiset.map f m) ⋯)","decl":"@[simp]\ntheorem map_mk {f : α → β} {m : Multiset α} {hc : Multiset.card m = n} :\n    map f (mk m hc) = mk (m.map f) (by simp [hc]) :=\n  rfl\n\n"}
{"name":"Sym.coe_map","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Nat\ns : Sym α n\nf : α → β\n⊢ Eq (↑(Sym.map f s)) (Multiset.map f ↑s)","decl":"@[simp]\ntheorem coe_map (s : Sym α n) (f : α → β) : ↑(s.map f) = Multiset.map f s :=\n  rfl\n\n"}
{"name":"Sym.map_injective","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\nn : Nat\n⊢ Function.Injective (Sym.map f)","decl":"theorem map_injective {f : α → β} (hf : Injective f) (n : ℕ) :\n    Injective (map f : Sym α n → Sym β n) := fun _ _ h =>\n  coe_injective <| Multiset.map_injective hf <| coe_inj.2 h\n\n"}
{"name":"Sym.equivCongr_symm_apply","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Nat\ne : Equiv α β\nx : Sym β n\n⊢ Eq ((Sym.equivCongr e).symm x) (Sym.map (⇑e.symm) x)","decl":"/-- Mapping an equivalence `α ≃ β` using `Sym.map` gives an equivalence between `Sym α n` and\n`Sym β n`. -/\n@[simps]\ndef equivCongr (e : α ≃ β) : Sym α n ≃ Sym β n where\n  toFun := map e\n  invFun := map e.symm\n  left_inv x := by rw [map_map, Equiv.symm_comp_self, map_id]\n  right_inv x := by rw [map_map, Equiv.self_comp_symm, map_id]\n\n"}
{"name":"Sym.equivCongr_apply","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Nat\ne : Equiv α β\nx : Sym α n\n⊢ Eq ((Sym.equivCongr e) x) (Sym.map (⇑e) x)","decl":"/-- Mapping an equivalence `α ≃ β` using `Sym.map` gives an equivalence between `Sym α n` and\n`Sym β n`. -/\n@[simps]\ndef equivCongr (e : α ≃ β) : Sym α n ≃ Sym β n where\n  toFun := map e\n  invFun := map e.symm\n  left_inv x := by rw [map_map, Equiv.symm_comp_self, map_id]\n  right_inv x := by rw [map_map, Equiv.self_comp_symm, map_id]\n\n"}
{"name":"Sym.attach_mk","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\nm : Multiset α\nhc : Eq m.card n\n⊢ Eq (Sym.mk m hc).attach (Sym.mk m.attach ⋯)","decl":"@[simp]\ntheorem attach_mk {m : Multiset α} {hc : Multiset.card m = n} :\n    attach (mk m hc) = mk m.attach (Multiset.card_attach.trans hc) :=\n  rfl\n\n"}
{"name":"Sym.coe_attach","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ns : Sym α n\n⊢ Eq (↑s.attach) (↑s).attach","decl":"@[simp]\ntheorem coe_attach (s : Sym α n) : (s.attach : Multiset { a // a ∈ s }) =\n    Multiset.attach (s : Multiset α) :=\n  rfl\n\n"}
{"name":"Sym.attach_map_coe","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ns : Sym α n\n⊢ Eq (Sym.map Subtype.val s.attach) s","decl":"theorem attach_map_coe (s : Sym α n) : s.attach.map (↑) = s :=\n  coe_injective <| Multiset.attach_map_val _\n\n"}
{"name":"Sym.mem_attach","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ns : Sym α n\nx : Subtype fun x => Membership.mem s x\n⊢ Membership.mem s.attach x","decl":"@[simp]\ntheorem mem_attach (s : Sym α n) (x : { x // x ∈ s }) : x ∈ s.attach :=\n  Multiset.mem_attach _ _\n\n"}
{"name":"Sym.attach_nil","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\n⊢ Eq Sym.nil.attach Sym.nil","decl":"@[simp]\ntheorem attach_nil : (nil : Sym α 0).attach = nil :=\n  rfl\n\n"}
{"name":"Sym.attach_cons","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\nx : α\ns : Sym α n\n⊢ Eq (Sym.cons x s).attach (Sym.cons ⟨x, ⋯⟩ (Sym.map (fun x_1 => ⟨↑x_1, ⋯⟩) s.attach))","decl":"@[simp]\ntheorem attach_cons (x : α) (s : Sym α n) :\n    (cons x s).attach =\n      cons ⟨x, mem_cons_self _ _⟩ (s.attach.map fun x => ⟨x, mem_cons_of_mem x.prop⟩) :=\n  coe_injective <| Multiset.attach_cons _ _\n\n"}
{"name":"Sym.cast_rfl","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ns : Sym α n\n⊢ Eq ((Sym.cast ⋯) s) s","decl":"@[simp]\ntheorem cast_rfl : Sym.cast rfl s = s :=\n  Subtype.ext rfl\n\n"}
{"name":"Sym.cast_cast","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn n' : Nat\ns : Sym α n\nn'' : Nat\nh : Eq n n'\nh' : Eq n' n''\n⊢ Eq ((Sym.cast h') ((Sym.cast h) s)) ((Sym.cast ⋯) s)","decl":"@[simp]\ntheorem cast_cast {n'' : ℕ} (h : n = n') (h' : n' = n'') :\n    Sym.cast h' (Sym.cast h s) = Sym.cast (h.trans h') s :=\n  rfl\n\n"}
{"name":"Sym.coe_cast","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn m : Nat\ns : Sym α n\nh : Eq n m\n⊢ Eq ↑((Sym.cast h) s) ↑s","decl":"@[simp]\ntheorem coe_cast (h : n = m) : (Sym.cast h s : Multiset α) = s :=\n  rfl\n\n"}
{"name":"Sym.mem_cast","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn m : Nat\ns : Sym α n\na : α\nh : Eq n m\n⊢ Iff (Membership.mem ((Sym.cast h) s) a) (Membership.mem s a)","decl":"@[simp]\ntheorem mem_cast (h : n = m) : a ∈ Sym.cast h s ↔ a ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Sym.append_inj_right","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn n' : Nat\ns : Sym α n\nt t' : Sym α n'\n⊢ Iff (Eq (s.append t) (s.append t')) (Eq t t')","decl":"@[simp]\ntheorem append_inj_right (s : Sym α n) {t t' : Sym α n'} : s.append t = s.append t' ↔ t = t' :=\n  Subtype.ext_iff.trans <| (add_right_inj _).trans Subtype.ext_iff.symm\n\n"}
{"name":"Sym.append_inj_left","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn n' : Nat\ns s' : Sym α n\nt : Sym α n'\n⊢ Iff (Eq (s.append t) (s'.append t)) (Eq s s')","decl":"@[simp]\ntheorem append_inj_left {s s' : Sym α n} (t : Sym α n') : s.append t = s'.append t ↔ s = s' :=\n  Subtype.ext_iff.trans <| (add_left_inj _).trans Subtype.ext_iff.symm\n\n"}
{"name":"Sym.append_comm","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn' : Nat\ns s' : Sym α n'\n⊢ Eq (s.append s') ((Sym.cast ⋯) (s'.append s))","decl":"theorem append_comm (s : Sym α n') (s' : Sym α n') :\n    s.append s' = Sym.cast (add_comm _ _) (s'.append s) := by\n  ext\n  simp [append, add_comm]\n\n"}
{"name":"Sym.coe_append","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn n' : Nat\ns : Sym α n\ns' : Sym α n'\n⊢ Eq (↑(s.append s')) (HAdd.hAdd ↑s ↑s')","decl":"@[simp, norm_cast]\ntheorem coe_append (s : Sym α n) (s' : Sym α n') : (s.append s' : Multiset α) = s + s' :=\n  rfl\n\n"}
{"name":"Sym.mem_append_iff","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn m : Nat\ns : Sym α n\na : α\ns' : Sym α m\n⊢ Iff (Membership.mem (s.append s') a) (Or (Membership.mem s a) (Membership.mem s' a))","decl":"theorem mem_append_iff {s' : Sym α m} : a ∈ s.append s' ↔ a ∈ s ∨ a ∈ s' :=\n  Multiset.mem_add\n\n"}
{"name":"Sym.coe_fill","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\na : α\ni : Fin (HAdd.hAdd n 1)\nm : Sym α (HSub.hSub n ↑i)\n⊢ Eq (↑(Sym.fill a i m)) (HAdd.hAdd ↑m ↑(Sym.replicate (↑i) a))","decl":"theorem coe_fill {a : α} {i : Fin (n + 1)} {m : Sym α (n - i)} :\n    (fill a i m : Multiset α) = m + replicate i a :=\n  rfl\n\n"}
{"name":"Sym.mem_fill_iff","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\na b : α\ni : Fin (HAdd.hAdd n 1)\ns : Sym α (HSub.hSub n ↑i)\n⊢ Iff (Membership.mem (Sym.fill b i s) a) (Or (And (Ne (↑i) 0) (Eq a b)) (Membership.mem s a))","decl":"theorem mem_fill_iff {a b : α} {i : Fin (n + 1)} {s : Sym α (n - i)} :\n    a ∈ Sym.fill b i s ↔ (i : ℕ) ≠ 0 ∧ a = b ∨ a ∈ s := by\n  rw [fill, mem_cast, mem_append_iff, or_comm, mem_replicate]\n\n"}
{"name":"Sym.sigma_sub_ext","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\nm₁ m₂ : Sigma fun i => Sym α (HSub.hSub n ↑i)\nh : Eq ↑m₁.snd ↑m₂.snd\n⊢ Eq m₁ m₂","decl":"theorem sigma_sub_ext {m₁ m₂ : Σi : Fin (n + 1), Sym α (n - i)} (h : (m₁.2 : Multiset α) = m₂.2) :\n    m₁ = m₂ :=\n  Sigma.subtype_ext\n    (Fin.ext <| by\n      rw [← Nat.sub_sub_self (Nat.le_of_lt_succ m₁.1.is_lt), ← m₁.2.2, val_eq_coe, h,\n        ← val_eq_coe, m₂.2.2, Nat.sub_sub_self (Nat.le_of_lt_succ m₂.1.is_lt)])\n    h\n\n"}
{"name":"Sym.fill_filterNe","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : DecidableEq α\na : α\nm : Sym α n\n⊢ Eq (Sym.fill a (Sym.filterNe a m).fst (Sym.filterNe a m).snd) m","decl":"theorem fill_filterNe [DecidableEq α] (a : α) (m : Sym α n) :\n    (m.filterNe a).2.fill a (m.filterNe a).1 = m :=\n  Sym.ext\n    (by\n      rw [coe_fill, filterNe, ← val_eq_coe, Subtype.coe_mk, Fin.val_mk]\n      ext b; dsimp\n      rw [count_add, count_filter, Sym.coe_replicate, count_replicate]\n      obtain rfl | h := eq_or_ne a b\n      · rw [if_pos rfl, if_neg (not_not.2 rfl), zero_add]\n      · rw [if_pos h, if_neg h, add_zero])\n\n"}
{"name":"Sym.filter_ne_fill","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : DecidableEq α\na : α\nm : Sigma fun i => Sym α (HSub.hSub n ↑i)\nh : Not (Membership.mem m.snd a)\n⊢ Eq (Sym.filterNe a (Sym.fill a m.fst m.snd)) m","decl":"theorem filter_ne_fill [DecidableEq α] (a : α) (m : Σi : Fin (n + 1), Sym α (n - i)) (h : a ∉ m.2) :\n    (m.2.fill a m.1).filterNe a = m :=\n  sigma_sub_ext\n    (by\n      rw [filterNe, ← val_eq_coe, Subtype.coe_mk, val_eq_coe, coe_fill]\n      rw [filter_add, filter_eq_self.2, add_right_eq_self, eq_zero_iff_forall_not_mem]\n      · intro b hb\n        rw [mem_filter, Sym.mem_coe, mem_replicate] at hb\n        exact hb.2 hb.1.2.symm\n      · exact fun a ha ha' => h <| ha'.symm ▸ ha)\n\n"}
{"name":"Sym.count_coe_fill_self_of_not_mem","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : DecidableEq α\na : α\ni : Fin (HAdd.hAdd n 1)\ns : Sym α (HSub.hSub n ↑i)\nhx : Not (Membership.mem s a)\n⊢ Eq (Multiset.count a ↑(Sym.fill a i s)) ↑i","decl":"theorem count_coe_fill_self_of_not_mem [DecidableEq α] {a : α} {i : Fin (n + 1)} {s : Sym α (n - i)}\n    (hx : a ∉ s) :\n    count a (fill a i s : Multiset α) = i := by\n  simp [coe_fill, coe_replicate, hx]\n\n"}
{"name":"Sym.count_coe_fill_of_ne","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : DecidableEq α\na x : α\ni : Fin (HAdd.hAdd n 1)\ns : Sym α (HSub.hSub n ↑i)\nhx : Ne x a\n⊢ Eq (Multiset.count x ↑(Sym.fill a i s)) (Multiset.count x ↑s)","decl":"theorem count_coe_fill_of_ne [DecidableEq α] {a x : α} {i : Fin (n + 1)} {s : Sym α (n - i)}\n    (hx : x ≠ a) :\n    count x (fill a i s : Multiset α) = count x s := by\n  suffices x ∉ Multiset.replicate i a by simp [coe_fill, coe_replicate, this]\n  simp [Multiset.mem_replicate, hx]\n\n"}
{"name":"SymOptionSuccEquiv.encode_of_none_mem","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : DecidableEq α\ns : Sym (Option α) n.succ\nh : Membership.mem s Option.none\n⊢ Eq (SymOptionSuccEquiv.encode s) (Sum.inl (s.erase Option.none h))","decl":"@[simp]\ntheorem encode_of_none_mem [DecidableEq α] (s : Sym (Option α) n.succ) (h : none ∈ s) :\n    encode s = Sum.inl (s.erase none h) :=\n  dif_pos h\n\n"}
{"name":"SymOptionSuccEquiv.encode_of_not_none_mem","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : DecidableEq α\ns : Sym (Option α) n.succ\nh : Not (Membership.mem s Option.none)\n⊢ Eq (SymOptionSuccEquiv.encode s) (Sum.inr (Sym.map (fun o => (↑o).get ⋯) s.attach))","decl":"@[simp]\ntheorem encode_of_not_none_mem [DecidableEq α] (s : Sym (Option α) n.succ) (h : ¬none ∈ s) :\n    encode s =\n      Sum.inr\n        (s.attach.map fun o =>\n          o.1.get <| Option.ne_none_iff_isSome.1 <| ne_of_mem_of_not_mem o.2 h) :=\n  dif_neg h\n\n"}
{"name":"SymOptionSuccEquiv.decode_inl","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ns : Sym (Option α) n\n⊢ Eq (SymOptionSuccEquiv.decode (Sum.inl s)) (Sym.cons Option.none s)","decl":"@[simp]\ntheorem decode_inl (s : Sym (Option α) n) : decode (Sum.inl s) = none ::ₛ s :=\n  rfl\n\n"}
{"name":"SymOptionSuccEquiv.decode_inr","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ns : Sym α n.succ\n⊢ Eq (SymOptionSuccEquiv.decode (Sum.inr s)) (Sym.map (⇑Function.Embedding.some) s)","decl":"@[simp]\ntheorem decode_inr (s : Sym α n.succ) : decode (Sum.inr s) = s.map Embedding.some :=\n  rfl\n\n"}
{"name":"SymOptionSuccEquiv.decode_encode","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : DecidableEq α\ns : Sym (Option α) n.succ\n⊢ Eq (SymOptionSuccEquiv.decode (SymOptionSuccEquiv.encode s)) s","decl":"@[simp]\ntheorem decode_encode [DecidableEq α] (s : Sym (Option α) n.succ) : decode (encode s) = s := by\n  by_cases h : none ∈ s\n  · simp [h]\n  · simp only [decode, h, not_false_iff, encode_of_not_none_mem, Embedding.some_apply, map_map,\n      comp_apply, Option.some_get]\n    convert s.attach_map_coe\n\n"}
{"name":"SymOptionSuccEquiv.encode_decode","module":"Mathlib.Data.Sym.Basic","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : DecidableEq α\ns : Sum (Sym (Option α) n) (Sym α n.succ)\n⊢ Eq (SymOptionSuccEquiv.encode (SymOptionSuccEquiv.decode s)) s","decl":"@[simp]\ntheorem encode_decode [DecidableEq α] (s : Sym (Option α) n ⊕ Sym α n.succ) :\n    encode (decode s) = s := by\n  obtain s | s := s\n  · simp\n  · unfold SymOptionSuccEquiv.encode\n    split_ifs with h\n    · obtain ⟨a, _, ha⟩ := Multiset.mem_map.mp h\n      exact Option.some_ne_none _ ha\n    · refine congr_arg Sum.inr ?_\n      refine map_injective (Option.some_injective _) _ ?_\n      refine Eq.trans ?_ (.trans (SymOptionSuccEquiv.decode (Sum.inr s)).attach_map_coe ?_) <;> simp\n\n"}
