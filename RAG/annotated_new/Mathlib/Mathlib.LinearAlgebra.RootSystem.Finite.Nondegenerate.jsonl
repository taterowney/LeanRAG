{"name":"RootPairing.IsAnisotropic.corootForm_coroot_ne_zero","module":"Mathlib.LinearAlgebra.RootSystem.Finite.Nondegenerate","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : CommRing R\ninst✝¹ : Module R M\ninst✝ : Module R N\nP : RootPairing ι R M N\nself : P.IsAnisotropic\ni : ι\n⊢ Ne ((P.CorootForm (P.coroot i)) (P.coroot i)) 0","decl":"/-- We say a finite root pairing is anisotropic if there are no roots / coroots which have length\nzero wrt the root / coroot forms.\n\nExamples include crystallographic pairings in characteristic zero\n`RootPairing.instIsAnisotropicOfIsCrystallographic` and pairings over ordered scalars.\n`RootPairing.instIsAnisotropicOfLinearOrderedCommRing`. -/\nclass IsAnisotropic : Prop where\n  rootForm_root_ne_zero (i : ι) : P.RootForm (P.root i) (P.root i) ≠ 0\n  corootForm_coroot_ne_zero (i : ι) : P.CorootForm (P.coroot i) (P.coroot i) ≠ 0\n\n"}
{"name":"RootPairing.IsAnisotropic.rootForm_root_ne_zero","module":"Mathlib.LinearAlgebra.RootSystem.Finite.Nondegenerate","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : CommRing R\ninst✝¹ : Module R M\ninst✝ : Module R N\nP : RootPairing ι R M N\nself : P.IsAnisotropic\ni : ι\n⊢ Ne ((P.RootForm (P.root i)) (P.root i)) 0","decl":"/-- We say a finite root pairing is anisotropic if there are no roots / coroots which have length\nzero wrt the root / coroot forms.\n\nExamples include crystallographic pairings in characteristic zero\n`RootPairing.instIsAnisotropicOfIsCrystallographic` and pairings over ordered scalars.\n`RootPairing.instIsAnisotropicOfLinearOrderedCommRing`. -/\nclass IsAnisotropic : Prop where\n  rootForm_root_ne_zero (i : ι) : P.RootForm (P.root i) (P.root i) ≠ 0\n  corootForm_coroot_ne_zero (i : ι) : P.CorootForm (P.coroot i) (P.coroot i) ≠ 0\n\n"}
{"name":"RootPairing.instIsAnisotropicFlip","module":"Mathlib.LinearAlgebra.RootSystem.Finite.Nondegenerate","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁶ : Fintype ι\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : CommRing R\ninst✝² : Module R M\ninst✝¹ : Module R N\nP : RootPairing ι R M N\ninst✝ : P.IsAnisotropic\n⊢ P.flip.IsAnisotropic","decl":"instance [P.IsAnisotropic] : P.flip.IsAnisotropic where\n  rootForm_root_ne_zero := IsAnisotropic.corootForm_coroot_ne_zero\n  corootForm_coroot_ne_zero := IsAnisotropic.rootForm_root_ne_zero\n\n"}
{"name":"RootPairing.instIsAnisotropicOfIsCrystallographic","module":"Mathlib.LinearAlgebra.RootSystem.Finite.Nondegenerate","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁷ : Fintype ι\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : CommRing R\ninst✝³ : Module R M\ninst✝² : Module R N\nP : RootPairing ι R M N\ninst✝¹ : CharZero R\ninst✝ : P.IsCrystallographic\n⊢ P.IsAnisotropic","decl":"instance instIsAnisotropicOfIsCrystallographic [CharZero R] [P.IsCrystallographic] :\n    IsAnisotropic P where\n  rootForm_root_ne_zero := P.rootForm_root_ne_zero_aux\n  corootForm_coroot_ne_zero := P.flip.rootForm_root_ne_zero_aux\n\n"}
{"name":"RootPairing.finrank_rootSpan_map_polarization_eq_finrank_corootSpan","module":"Mathlib.LinearAlgebra.RootSystem.Finite.Nondegenerate","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁷ : Fintype ι\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : CommRing R\ninst✝³ : IsDomain R\ninst✝² : Module R M\ninst✝¹ : Module R N\nP : RootPairing ι R M N\ninst✝ : P.IsAnisotropic\n⊢ Eq (Module.finrank R (Subtype fun x => Membership.mem (Submodule.map P.Polarization P.rootSpan) x)) (Module.finrank R (Subtype fun x => Membership.mem P.corootSpan x))","decl":"@[simp]\nlemma finrank_rootSpan_map_polarization_eq_finrank_corootSpan :\n    finrank R (P.rootSpan.map P.Polarization) = finrank R P.corootSpan := by\n  rw [← LinearMap.range_domRestrict]\n  apply (Submodule.finrank_mono P.range_polarization_domRestrict_le_span_coroot).antisymm\n  have : IsReflexive R N := PerfectPairing.reflexive_right P.toPerfectPairing\n  have h_ne : ∏ i, P.RootForm (P.root i) (P.root i) ≠ 0 :=\n    Finset.prod_ne_zero_iff.mpr fun i _ ↦ IsAnisotropic.rootForm_root_ne_zero i\n  refine LinearMap.finrank_le_of_isSMulRegular P.corootSpan\n    (LinearMap.range (P.Polarization.domRestrict P.rootSpan))\n    (smul_right_injective N h_ne)\n    fun _ hx => ?_\n  obtain ⟨c, hc⟩ := (mem_span_range_iff_exists_fun R).mp hx\n  rw [← hc, Finset.smul_sum]\n  simp_rw [smul_smul, mul_comm, ← smul_smul]\n  exact Submodule.sum_smul_mem (LinearMap.range (P.Polarization.domRestrict P.rootSpan)) c\n    (fun c _ ↦ prod_rootForm_smul_coroot_mem_range_domRestrict P c)\n\n"}
{"name":"RootPairing.finrank_corootSpan_eq","module":"Mathlib.LinearAlgebra.RootSystem.Finite.Nondegenerate","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁷ : Fintype ι\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : CommRing R\ninst✝³ : IsDomain R\ninst✝² : Module R M\ninst✝¹ : Module R N\nP : RootPairing ι R M N\ninst✝ : P.IsAnisotropic\n⊢ Eq (Module.finrank R (Subtype fun x => Membership.mem P.corootSpan x)) (Module.finrank R (Subtype fun x => Membership.mem P.rootSpan x))","decl":"lemma finrank_corootSpan_eq :\n    finrank R P.corootSpan = finrank R P.rootSpan :=\n  le_antisymm P.finrank_corootSpan_le P.flip.finrank_corootSpan_le\n\n"}
{"name":"RootPairing.disjoint_rootSpan_ker_rootForm","module":"Mathlib.LinearAlgebra.RootSystem.Finite.Nondegenerate","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁷ : Fintype ι\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : CommRing R\ninst✝³ : IsDomain R\ninst✝² : Module R M\ninst✝¹ : Module R N\nP : RootPairing ι R M N\ninst✝ : P.IsAnisotropic\n⊢ Disjoint P.rootSpan (LinearMap.ker P.RootForm)","decl":"lemma disjoint_rootSpan_ker_rootForm :\n    Disjoint P.rootSpan (LinearMap.ker P.RootForm) := by\n  have : IsReflexive R M := PerfectPairing.reflexive_left P.toPerfectPairing\n  rw [← P.ker_polarization_eq_ker_rootForm]\n  refine Submodule.disjoint_ker_of_finrank_le (L := P.rootSpan) P.Polarization ?_\n  rw [P.finrank_rootSpan_map_polarization_eq_finrank_corootSpan, P.finrank_corootSpan_eq]\n\n"}
{"name":"RootPairing.disjoint_corootSpan_ker_corootForm","module":"Mathlib.LinearAlgebra.RootSystem.Finite.Nondegenerate","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁷ : Fintype ι\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : CommRing R\ninst✝³ : IsDomain R\ninst✝² : Module R M\ninst✝¹ : Module R N\nP : RootPairing ι R M N\ninst✝ : P.IsAnisotropic\n⊢ Disjoint P.corootSpan (LinearMap.ker P.CorootForm)","decl":"lemma disjoint_corootSpan_ker_corootForm :\n    Disjoint P.corootSpan (LinearMap.ker P.CorootForm) :=\n  P.flip.disjoint_rootSpan_ker_rootForm\n\n"}
{"name":"RootPairing.isCompl_rootSpan_ker_rootForm","module":"Mathlib.LinearAlgebra.RootSystem.Finite.Nondegenerate","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁶ : Fintype ι\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Field R\ninst✝² : Module R M\ninst✝¹ : Module R N\nP : RootPairing ι R M N\ninst✝ : P.IsAnisotropic\n⊢ IsCompl P.rootSpan (LinearMap.ker P.RootForm)","decl":"lemma isCompl_rootSpan_ker_rootForm :\n    IsCompl P.rootSpan (LinearMap.ker P.RootForm) := by\n  have _iM : IsReflexive R M := PerfectPairing.reflexive_left P.toPerfectPairing\n  have _iN : IsReflexive R N := PerfectPairing.reflexive_right P.toPerfectPairing\n  refine (Submodule.isCompl_iff_disjoint _ _ ?_).mpr P.disjoint_rootSpan_ker_rootForm\n  have aux : finrank R M = finrank R P.rootSpan + finrank R P.corootSpan.dualAnnihilator := by\n    rw [P.toPerfectPairing.finrank_eq, ← P.finrank_corootSpan_eq,\n      Subspace.finrank_add_finrank_dualAnnihilator_eq P.corootSpan]\n  rw [aux, add_le_add_iff_left]\n  convert Submodule.finrank_mono P.corootSpan_dualAnnihilator_le_ker_rootForm\n  exact (LinearEquiv.finrank_map_eq _ _).symm\n\n"}
{"name":"RootPairing.isCompl_corootSpan_ker_corootForm","module":"Mathlib.LinearAlgebra.RootSystem.Finite.Nondegenerate","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁶ : Fintype ι\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Field R\ninst✝² : Module R M\ninst✝¹ : Module R N\nP : RootPairing ι R M N\ninst✝ : P.IsAnisotropic\n⊢ IsCompl P.corootSpan (LinearMap.ker P.CorootForm)","decl":"lemma isCompl_corootSpan_ker_corootForm :\n    IsCompl P.corootSpan (LinearMap.ker P.CorootForm) :=\n  P.flip.isCompl_rootSpan_ker_rootForm\n\n"}
{"name":"RootPairing.ker_rootForm_eq_dualAnnihilator","module":"Mathlib.LinearAlgebra.RootSystem.Finite.Nondegenerate","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁶ : Fintype ι\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Field R\ninst✝² : Module R M\ninst✝¹ : Module R N\nP : RootPairing ι R M N\ninst✝ : P.IsAnisotropic\n⊢ Eq (LinearMap.ker P.RootForm) (Submodule.map P.toDualLeft.symm P.corootSpan.dualAnnihilator)","decl":"lemma ker_rootForm_eq_dualAnnihilator :\n    LinearMap.ker P.RootForm = P.corootSpan.dualAnnihilator.map P.toDualLeft.symm := by\n  have _iM : IsReflexive R M := PerfectPairing.reflexive_left P.toPerfectPairing\n  have _iN : IsReflexive R N := PerfectPairing.reflexive_right P.toPerfectPairing\n  suffices finrank R (LinearMap.ker P.RootForm) = finrank R P.corootSpan.dualAnnihilator by\n    refine (Submodule.eq_of_le_of_finrank_eq P.corootSpan_dualAnnihilator_le_ker_rootForm ?_).symm\n    rw [this]\n    apply LinearEquiv.finrank_map_eq\n  have aux0 := Subspace.finrank_add_finrank_dualAnnihilator_eq P.corootSpan\n  have aux1 := Submodule.finrank_add_eq_of_isCompl P.isCompl_rootSpan_ker_rootForm\n  rw [← P.finrank_corootSpan_eq, P.toPerfectPairing.finrank_eq] at aux1\n  omega\n\n"}
{"name":"RootPairing.ker_corootForm_eq_dualAnnihilator","module":"Mathlib.LinearAlgebra.RootSystem.Finite.Nondegenerate","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁶ : Fintype ι\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Field R\ninst✝² : Module R M\ninst✝¹ : Module R N\nP : RootPairing ι R M N\ninst✝ : P.IsAnisotropic\n⊢ Eq (LinearMap.ker P.CorootForm) (Submodule.map P.toDualRight.symm P.rootSpan.dualAnnihilator)","decl":"lemma ker_corootForm_eq_dualAnnihilator :\n    LinearMap.ker P.CorootForm = P.rootSpan.dualAnnihilator.map P.toDualRight.symm :=\n  P.flip.ker_rootForm_eq_dualAnnihilator\n\n"}
{"name":"RootPairing.instIsBalanced_1","module":"Mathlib.LinearAlgebra.RootSystem.Finite.Nondegenerate","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : Field R\ninst✝¹ : Module R M\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ P.IsBalanced","decl":"instance : P.IsBalanced where\n    isPerfectCompl :=\n  { isCompl_left := by\n      simpa only [ker_rootForm_eq_dualAnnihilator] using P.isCompl_rootSpan_ker_rootForm\n    isCompl_right := by\n      simpa only [ker_corootForm_eq_dualAnnihilator] using P.isCompl_corootSpan_ker_corootForm }\n\n"}
{"name":"RootPairing.rootForm_restrict_nondegenerate_of_isAnisotropic","module":"Mathlib.LinearAlgebra.RootSystem.Finite.Nondegenerate","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁶ : Fintype ι\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Field R\ninst✝² : Module R M\ninst✝¹ : Module R N\nP : RootPairing ι R M N\ninst✝ : P.IsAnisotropic\n⊢ LinearMap.Nondegenerate (P.RootForm.restrict P.rootSpan)","decl":"/-- See also `RootPairing.rootForm_restrict_nondegenerate_of_ordered`.\n\nNote that this applies to crystallographic root systems in characteristic zero via\n`RootPairing.instIsAnisotropicOfIsCrystallographic`. -/\nlemma rootForm_restrict_nondegenerate_of_isAnisotropic :\n    LinearMap.Nondegenerate (P.RootForm.restrict P.rootSpan) :=\n  P.rootForm_symmetric.nondegenerate_restrict_of_isCompl_ker P.isCompl_rootSpan_ker_rootForm\n\n"}
{"name":"RootPairing.orthogonal_rootSpan_eq","module":"Mathlib.LinearAlgebra.RootSystem.Finite.Nondegenerate","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁶ : Fintype ι\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Field R\ninst✝² : Module R M\ninst✝¹ : Module R N\nP : RootPairing ι R M N\ninst✝ : P.IsAnisotropic\n⊢ Eq (P.RootForm.orthogonal P.rootSpan) (LinearMap.ker P.RootForm)","decl":"@[simp]\nlemma orthogonal_rootSpan_eq :\n    P.RootForm.orthogonal P.rootSpan = LinearMap.ker P.RootForm := by\n  rw [← LinearMap.BilinForm.orthogonal_top_eq_ker P.rootForm_symmetric.isRefl]\n  refine le_antisymm ?_ (by intro; aesop)\n  rintro x hx y -\n  simp only [LinearMap.BilinForm.mem_orthogonal_iff, LinearMap.BilinForm.IsOrtho] at hx ⊢\n  obtain ⟨u, hu, v, hv, rfl⟩ : ∃ᵉ (u ∈ P.rootSpan) (v ∈ LinearMap.ker P.RootForm), u + v = y := by\n    rw [← Submodule.mem_sup, P.isCompl_rootSpan_ker_rootForm.sup_eq_top]; exact Submodule.mem_top\n  simp only [LinearMap.mem_ker] at hv\n  simp [hx _ hu, hv]\n\n"}
{"name":"RootPairing.orthogonal_corootSpan_eq","module":"Mathlib.LinearAlgebra.RootSystem.Finite.Nondegenerate","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁶ : Fintype ι\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Field R\ninst✝² : Module R M\ninst✝¹ : Module R N\nP : RootPairing ι R M N\ninst✝ : P.IsAnisotropic\n⊢ Eq (P.CorootForm.orthogonal P.corootSpan) (LinearMap.ker P.CorootForm)","decl":"@[simp]\nlemma orthogonal_corootSpan_eq :\n    P.CorootForm.orthogonal P.corootSpan = LinearMap.ker P.CorootForm :=\n  P.flip.orthogonal_rootSpan_eq\n\n"}
{"name":"RootPairing.rootSpan_eq_top_iff","module":"Mathlib.LinearAlgebra.RootSystem.Finite.Nondegenerate","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁶ : Fintype ι\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Field R\ninst✝² : Module R M\ninst✝¹ : Module R N\nP : RootPairing ι R M N\ninst✝ : P.IsAnisotropic\n⊢ Iff (Eq P.rootSpan Top.top) (Eq P.corootSpan Top.top)","decl":"lemma rootSpan_eq_top_iff :\n    P.rootSpan = ⊤ ↔ P.corootSpan = ⊤ := by\n  have := P.toPerfectPairing.reflexive_left\n  have := P.toPerfectPairing.reflexive_right\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩ <;> apply Submodule.eq_top_of_finrank_eq\n  · rw [P.finrank_corootSpan_eq, h, finrank_top, P.toPerfectPairing.finrank_eq]\n  · rw [← P.finrank_corootSpan_eq, h, finrank_top, P.toPerfectPairing.finrank_eq]\n\n"}
{"name":"RootPairing.instIsAnisotropicOfLinearOrderedCommRing","module":"Mathlib.LinearAlgebra.RootSystem.Finite.Nondegenerate","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : LinearOrderedCommRing R\ninst✝¹ : Module R M\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ P.IsAnisotropic","decl":"instance instIsAnisotropicOfLinearOrderedCommRing : IsAnisotropic P where\n  rootForm_root_ne_zero i := (P.rootForm_root_self_pos i).ne'\n  corootForm_coroot_ne_zero i := (P.flip.rootForm_root_self_pos i).ne'\n\n"}
{"name":"RootPairing.rootForm_restrict_nondegenerate_of_ordered","module":"Mathlib.LinearAlgebra.RootSystem.Finite.Nondegenerate","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : LinearOrderedCommRing R\ninst✝¹ : Module R M\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ LinearMap.Nondegenerate (P.RootForm.restrict P.rootSpan)","decl":"/-- See also `RootPairing.rootForm_restrict_nondegenerate_of_isAnisotropic`. -/\nlemma rootForm_restrict_nondegenerate_of_ordered :\n    LinearMap.Nondegenerate (P.RootForm.restrict P.rootSpan) :=\n  (P.RootForm.nondegenerate_restrict_iff_disjoint_ker (rootForm_self_non_neg P)\n    P.rootForm_symmetric).mpr P.disjoint_rootSpan_ker_rootForm\n\n"}
{"name":"RootPairing.eq_zero_of_mem_rootSpan_of_rootForm_self_eq_zero","module":"Mathlib.LinearAlgebra.RootSystem.Finite.Nondegenerate","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : LinearOrderedCommRing R\ninst✝¹ : Module R M\ninst✝ : Module R N\nP : RootPairing ι R M N\nx : M\nhx : Membership.mem P.rootSpan x\nhx' : Eq ((P.RootForm x) x) 0\n⊢ Eq x 0","decl":"lemma eq_zero_of_mem_rootSpan_of_rootForm_self_eq_zero {x : M}\n    (hx : x ∈ P.rootSpan) (hx' : P.RootForm x x = 0) :\n    x = 0 := by\n  have : x ∈ P.rootSpan ⊓ LinearMap.ker P.RootForm := ⟨hx, P.rootForm_self_eq_zero_iff.mp hx'⟩\n  simpa [P.disjoint_rootSpan_ker_rootForm.eq_bot] using this\n\n"}
{"name":"RootPairing.rootForm_pos_of_ne_zero","module":"Mathlib.LinearAlgebra.RootSystem.Finite.Nondegenerate","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : LinearOrderedCommRing R\ninst✝¹ : Module R M\ninst✝ : Module R N\nP : RootPairing ι R M N\nx : M\nhx : Membership.mem P.rootSpan x\nh : Ne x 0\n⊢ LT.lt 0 ((P.RootForm x) x)","decl":"lemma rootForm_pos_of_ne_zero {x : M} (hx : x ∈ P.rootSpan) (h : x ≠ 0) :\n    0 < P.RootForm x x := by\n  apply (P.rootForm_self_non_neg x).lt_of_ne\n  contrapose! h\n  exact P.eq_zero_of_mem_rootSpan_of_rootForm_self_eq_zero hx h.symm\n\n"}
{"name":"RootSystem.rootForm_anisotropic","module":"Mathlib.LinearAlgebra.RootSystem.Finite.Nondegenerate","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : LinearOrderedCommRing R\ninst✝¹ : Module R M\ninst✝ : Module R N\nP : RootSystem ι R M N\n⊢ (LinearMap.BilinMap.toQuadraticMap P.RootForm).Anisotropic","decl":"lemma _root_.RootSystem.rootForm_anisotropic (P : RootSystem ι R M N) :\n    P.RootForm.toQuadraticMap.Anisotropic :=\n  fun x ↦ P.eq_zero_of_mem_rootSpan_of_rootForm_self_eq_zero <| by\n    simpa only [rootSpan, P.span_root_eq_top] using Submodule.mem_top\n\n"}
