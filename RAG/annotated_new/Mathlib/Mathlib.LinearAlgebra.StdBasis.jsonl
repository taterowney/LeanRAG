{"name":"LinearMap.stdBasis_apply","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝³ : Semiring R\nφ : ι → Type u_3\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\ni : ι\nb : φ i\n⊢ Eq ((LinearMap.stdBasis R φ i) b) (Function.update 0 i b)","decl":"set_option linter.deprecated false in\n@[deprecated Pi.single (since := \"2024-08-09\")]\ntheorem stdBasis_apply (i : ι) (b : φ i) : stdBasis R φ i b = update (0 : (a : ι) → φ a) i b :=\n  rfl\n\n"}
{"name":"LinearMap.stdBasis_apply'","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝¹ : Semiring R\ninst✝ : DecidableEq ι\ni i' : ι\n⊢ Eq ((LinearMap.stdBasis R (fun _x => R) i) 1 i') (ite (Eq i i') 1 0)","decl":"set_option linter.deprecated false in\n@[simp, deprecated Pi.single_apply (since := \"2024-08-09\")]\ntheorem stdBasis_apply' (i i' : ι) : (stdBasis R (fun _x : ι => R) i) 1 i' = ite (i = i') 1 0 := by\n  simp_rw [stdBasis, single_apply, Pi.single_apply, eq_comm]\n\n"}
{"name":"LinearMap.coe_stdBasis","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝³ : Semiring R\nφ : ι → Type u_3\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\ni : ι\n⊢ Eq (⇑(LinearMap.stdBasis R φ i)) (Pi.single i)","decl":"set_option linter.deprecated false in\n@[deprecated LinearMap.coe_single (since := \"2024-08-09\")]\ntheorem coe_stdBasis (i : ι) : ⇑(stdBasis R φ i) = Pi.single i :=\n  rfl\n\n"}
{"name":"LinearMap.stdBasis_same","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝³ : Semiring R\nφ : ι → Type u_3\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\ni : ι\nb : φ i\n⊢ Eq ((LinearMap.stdBasis R φ i) b i) b","decl":"set_option linter.deprecated false in\n@[simp, deprecated Pi.single_eq_same (since := \"2024-08-09\")]\ntheorem stdBasis_same (i : ι) (b : φ i) : stdBasis R φ i b i = b :=\n  Pi.single_eq_same ..\n\n"}
{"name":"LinearMap.stdBasis_ne","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝³ : Semiring R\nφ : ι → Type u_3\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\ni j : ι\nh : Ne j i\nb : φ i\n⊢ Eq ((LinearMap.stdBasis R φ i) b j) 0","decl":"set_option linter.deprecated false in\n@[deprecated Pi.single_eq_of_ne (since := \"2024-08-09\")]\ntheorem stdBasis_ne (i j : ι) (h : j ≠ i) (b : φ i) : stdBasis R φ i b j = 0 :=\n  Pi.single_eq_of_ne h b\n\n"}
{"name":"LinearMap.stdBasis_eq_pi_diag","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝³ : Semiring R\nφ : ι → Type u_3\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\ni : ι\n⊢ Eq (LinearMap.stdBasis R φ i) (LinearMap.pi (LinearMap.diag i))","decl":"set_option linter.deprecated false in\n@[deprecated single_eq_pi_diag (since := \"2024-08-09\")]\ntheorem stdBasis_eq_pi_diag (i : ι) : stdBasis R φ i = pi (diag i) :=\n  single_eq_pi_diag ..\n\n"}
{"name":"LinearMap.ker_stdBasis","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝³ : Semiring R\nφ : ι → Type u_3\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\ni : ι\n⊢ Eq (LinearMap.ker (LinearMap.stdBasis R φ i)) Bot.bot","decl":"set_option linter.deprecated false in\n@[deprecated ker_single (since := \"2024-08-09\")]\ntheorem ker_stdBasis (i : ι) : ker (stdBasis R φ i) = ⊥ :=\n  ker_single ..\n\n"}
{"name":"LinearMap.proj_comp_stdBasis","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝³ : Semiring R\nφ : ι → Type u_3\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\ni j : ι\n⊢ Eq ((LinearMap.proj i).comp (LinearMap.stdBasis R φ j)) (LinearMap.diag j i)","decl":"set_option linter.deprecated false in\n@[deprecated proj_comp_single (since := \"2024-08-09\")]\ntheorem proj_comp_stdBasis (i j : ι) : (proj i).comp (stdBasis R φ j) = diag j i :=\n  proj_comp_single ..\n\n"}
{"name":"LinearMap.proj_stdBasis_same","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝³ : Semiring R\nφ : ι → Type u_3\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\ni : ι\n⊢ Eq ((LinearMap.proj i).comp (LinearMap.stdBasis R φ i)) LinearMap.id","decl":"set_option linter.deprecated false in\n@[deprecated proj_comp_single_same (since := \"2024-08-09\")]\ntheorem proj_stdBasis_same (i : ι) : (proj i).comp (stdBasis R φ i) = id :=\n  proj_comp_single_same ..\n\n"}
{"name":"LinearMap.proj_stdBasis_ne","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝³ : Semiring R\nφ : ι → Type u_3\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\ni j : ι\nh : Ne i j\n⊢ Eq ((LinearMap.proj i).comp (LinearMap.stdBasis R φ j)) 0","decl":"set_option linter.deprecated false in\n@[deprecated proj_comp_single_ne (since := \"2024-08-09\")]\ntheorem proj_stdBasis_ne (i j : ι) (h : i ≠ j) : (proj i).comp (stdBasis R φ j) = 0 :=\n  proj_comp_single_ne R φ i j h\n\n"}
{"name":"LinearMap.iSup_range_stdBasis_le_iInf_ker_proj","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝³ : Semiring R\nφ : ι → Type u_3\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\nI J : Set ι\nh : Disjoint I J\n⊢ LE.le (iSup fun i => iSup fun h => LinearMap.range (LinearMap.stdBasis R φ i)) (iInf fun i => iInf fun h => LinearMap.ker (LinearMap.proj i))","decl":"set_option linter.deprecated false in\n@[deprecated iSup_range_single_le_iInf_ker_proj (since := \"2024-08-09\")]\ntheorem iSup_range_stdBasis_le_iInf_ker_proj (I J : Set ι) (h : Disjoint I J) :\n    ⨆ i ∈ I, range (stdBasis R φ i) ≤ ⨅ i ∈ J, ker (proj i : (∀ i, φ i) →ₗ[R] φ i) :=\n  iSup_range_single_le_iInf_ker_proj R φ I J h\n\n"}
{"name":"LinearMap.iInf_ker_proj_le_iSup_range_stdBasis","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝³ : Semiring R\nφ : ι → Type u_3\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\nI : Finset ι\nJ : Set ι\nhu : HasSubset.Subset Set.univ (Union.union (↑I) J)\n⊢ LE.le (iInf fun i => iInf fun h => LinearMap.ker (LinearMap.proj i)) (iSup fun i => iSup fun h => LinearMap.range (LinearMap.stdBasis R φ i))","decl":"set_option linter.deprecated false in\n@[deprecated iInf_ker_proj_le_iSup_range_single (since := \"2024-08-09\")]\ntheorem iInf_ker_proj_le_iSup_range_stdBasis {I : Finset ι} {J : Set ι} (hu : Set.univ ⊆ ↑I ∪ J) :\n    ⨅ i ∈ J, ker (proj i : (∀ i, φ i) →ₗ[R] φ i) ≤ ⨆ i ∈ I, range (stdBasis R φ i) :=\n  iInf_ker_proj_le_iSup_range_single R φ hu\n\n"}
{"name":"LinearMap.iSup_range_stdBasis_eq_iInf_ker_proj","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝³ : Semiring R\nφ : ι → Type u_3\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\nI J : Set ι\nhd : Disjoint I J\nhu : HasSubset.Subset Set.univ (Union.union I J)\nhI : I.Finite\n⊢ Eq (iSup fun i => iSup fun h => LinearMap.range (LinearMap.stdBasis R φ i)) (iInf fun i => iInf fun h => LinearMap.ker (LinearMap.proj i))","decl":"set_option linter.deprecated false in\n@[deprecated iSup_range_single_eq_iInf_ker_proj (since := \"2024-08-09\")]\ntheorem iSup_range_stdBasis_eq_iInf_ker_proj {I J : Set ι} (hd : Disjoint I J)\n    (hu : Set.univ ⊆ I ∪ J) (hI : Set.Finite I) :\n    ⨆ i ∈ I, range (stdBasis R φ i) = ⨅ i ∈ J, ker (proj i : (∀ i, φ i) →ₗ[R] φ i) :=\n  iSup_range_single_eq_iInf_ker_proj _ _ hd hu hI\n\n"}
{"name":"LinearMap.iSup_range_stdBasis","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝⁴ : Semiring R\nφ : ι → Type u_3\ninst✝³ : (i : ι) → AddCommMonoid (φ i)\ninst✝² : (i : ι) → Module R (φ i)\ninst✝¹ : DecidableEq ι\ninst✝ : Finite ι\n⊢ Eq (iSup fun i => LinearMap.range (LinearMap.stdBasis R φ i)) Top.top","decl":"set_option linter.deprecated false in\n@[deprecated iSup_range_single (since := \"2024-08-09\")]\ntheorem iSup_range_stdBasis [Finite ι] : ⨆ i, range (stdBasis R φ i) = ⊤ :=\n  iSup_range_single ..\n\n"}
{"name":"LinearMap.disjoint_stdBasis_stdBasis","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝³ : Semiring R\nφ : ι → Type u_3\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\nI J : Set ι\nh : Disjoint I J\n⊢ Disjoint (iSup fun i => iSup fun h => LinearMap.range (LinearMap.stdBasis R φ i)) (iSup fun i => iSup fun h => LinearMap.range (LinearMap.stdBasis R φ i))","decl":"set_option linter.deprecated false in\n@[deprecated disjoint_single_single (since := \"2024-08-09\")]\ntheorem disjoint_stdBasis_stdBasis (I J : Set ι) (h : Disjoint I J) :\n    Disjoint (⨆ i ∈ I, range (stdBasis R φ i)) (⨆ i ∈ J, range (stdBasis R φ i)) :=\n  disjoint_single_single R φ I J h\n\n"}
{"name":"LinearMap.stdBasis_eq_single","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝¹ : Semiring R\ninst✝ : DecidableEq ι\na : R\n⊢ Eq (fun i => (LinearMap.stdBasis R (fun x => R) i) a) fun i => ⇑(Finsupp.single i a)","decl":"set_option linter.deprecated false in\n@[deprecated \"You can probably use Finsupp.single_eq_pi_single here\" (since := \"2024-08-09\")]\ntheorem stdBasis_eq_single {a : R} :\n    (fun i : ι => (stdBasis R (fun _ : ι => R) i) a) = fun i : ι => ↑(Finsupp.single i a) :=\n  funext fun i => (Finsupp.single_eq_pi_single i a).symm\n\n"}
{"name":"Pi.linearIndependent_single","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nη : Type u_2\nιs : η → Type u_3\nMs : η → Type u_4\ninst✝³ : Ring R\ninst✝² : (i : η) → AddCommGroup (Ms i)\ninst✝¹ : (i : η) → Module R (Ms i)\ninst✝ : DecidableEq η\nv : (j : η) → ιs j → Ms j\nhs : ∀ (i : η), LinearIndependent R (v i)\n⊢ LinearIndependent R fun ji => Pi.single ji.fst (v ji.fst ji.snd)","decl":"theorem linearIndependent_single [Ring R] [∀ i, AddCommGroup (Ms i)] [∀ i, Module R (Ms i)]\n    [DecidableEq η] (v : ∀ j, ιs j → Ms j) (hs : ∀ i, LinearIndependent R (v i)) :\n    LinearIndependent R fun ji : Σj, ιs j ↦ Pi.single ji.1 (v ji.1 ji.2) := by\n  have hs' : ∀ j : η, LinearIndependent R fun i : ιs j => LinearMap.single R Ms j (v j i) := by\n    intro j\n    exact (hs j).map' _ (LinearMap.ker_single _ _ _)\n  apply linearIndependent_iUnion_finite hs'\n  intro j J _ hiJ\n  have h₀ :\n    ∀ j, span R (range fun i : ιs j => LinearMap.single R Ms j (v j i)) ≤\n      LinearMap.range (LinearMap.single R Ms j) := by\n    intro j\n    rw [span_le, LinearMap.range_coe]\n    apply range_comp_subset_range\n  have h₁ :\n    span R (range fun i : ιs j => LinearMap.single R Ms j (v j i)) ≤\n      ⨆ i ∈ ({j} : Set _), LinearMap.range (LinearMap.single R Ms i) := by\n    rw [@iSup_singleton _ _ _ fun i => LinearMap.range (LinearMap.single R (Ms) i)]\n    apply h₀\n  have h₂ :\n    ⨆ j ∈ J, span R (range fun i : ιs j => LinearMap.single R Ms j (v j i)) ≤\n      ⨆ j ∈ J, LinearMap.range (LinearMap.single R (fun j : η => Ms j) j) :=\n    iSup₂_mono fun i _ => h₀ i\n  have h₃ : Disjoint (fun i : η => i ∈ ({j} : Set _)) J := by\n    convert Set.disjoint_singleton_left.2 hiJ using 0\n  exact (disjoint_single_single _ _ _ _ h₃).mono h₁ h₂\n\n"}
{"name":"Pi.linearIndependent_stdBasis","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nη : Type u_2\nιs : η → Type u_3\nMs : η → Type u_4\ninst✝³ : Ring R\ninst✝² : (i : η) → AddCommGroup (Ms i)\ninst✝¹ : (i : η) → Module R (Ms i)\ninst✝ : DecidableEq η\nv : (j : η) → ιs j → Ms j\nhs : ∀ (i : η), LinearIndependent R (v i)\n⊢ LinearIndependent R fun ji => (LinearMap.stdBasis R Ms ji.fst) (v ji.fst ji.snd)","decl":"set_option linter.deprecated false in\n@[deprecated linearIndependent_single (since := \"2024-08-09\")]\ntheorem linearIndependent_stdBasis [Ring R] [∀ i, AddCommGroup (Ms i)] [∀ i, Module R (Ms i)]\n    [DecidableEq η] (v : ∀ j, ιs j → Ms j) (hs : ∀ i, LinearIndependent R (v i)) :\n    LinearIndependent R fun ji : Σj, ιs j => stdBasis R Ms ji.1 (v ji.1 ji.2) :=\n  linearIndependent_single _ hs\n\n"}
{"name":"Pi.basis_repr_single","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nη : Type u_2\nιs : η → Type u_3\nMs : η → Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : (i : η) → AddCommMonoid (Ms i)\ninst✝² : (i : η) → Module R (Ms i)\ninst✝¹ : Fintype η\ninst✝ : DecidableEq η\ns : (j : η) → Basis (ιs j) R (Ms j)\nj : η\ni : ιs j\n⊢ Eq ((Pi.basis s).repr (Pi.single j ((s j) i))) (Finsupp.single ⟨j, i⟩ 1)","decl":"@[simp]\ntheorem basis_repr_single [DecidableEq η] (s : ∀ j, Basis (ιs j) R (Ms j)) (j i) :\n    (Pi.basis s).repr (Pi.single j (s j i)) = Finsupp.single ⟨j, i⟩ 1 := by\n  classical\n  ext ⟨j', i'⟩\n  by_cases hj : j = j'\n  · subst hj\n    -- Porting note: needed to add more lemmas\n    simp only [Pi.basis, LinearEquiv.trans_apply, Basis.repr_self, Pi.single_eq_same,\n      LinearEquiv.piCongrRight, Finsupp.sigmaFinsuppLEquivPiFinsupp_symm_apply,\n      Basis.repr_symm_apply, LinearEquiv.coe_mk, ne_eq, Sigma.mk.inj_iff, heq_eq_eq, true_and]\n    symm\n    simp [Finsupp.single_apply]\n  simp only [Pi.basis, LinearEquiv.trans_apply, Finsupp.sigmaFinsuppLEquivPiFinsupp_symm_apply,\n    LinearEquiv.piCongrRight, coe_single]\n  dsimp\n  rw [Pi.single_eq_of_ne (Ne.symm hj), LinearEquiv.map_zero, Finsupp.zero_apply,\n    Finsupp.single_eq_of_ne]\n  rintro ⟨⟩\n  contradiction\n\n"}
{"name":"Pi.basis_repr_stdBasis","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nη : Type u_2\nιs : η → Type u_3\nMs : η → Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : (i : η) → AddCommMonoid (Ms i)\ninst✝² : (i : η) → Module R (Ms i)\ninst✝¹ : Fintype η\ninst✝ : DecidableEq η\ns : (j : η) → Basis (ιs j) R (Ms j)\nj : η\ni : ιs j\n⊢ Eq ((Pi.basis s).repr ((LinearMap.stdBasis R Ms j) ((s j) i))) (Finsupp.single ⟨j, i⟩ 1)","decl":"set_option linter.deprecated false in\n@[simp, deprecated basis_repr_single (since := \"2024-08-09\")]\ntheorem basis_repr_stdBasis [DecidableEq η] (s : ∀ j, Basis (ιs j) R (Ms j)) (j i) :\n    (Pi.basis s).repr (stdBasis R _ j (s j i)) = Finsupp.single ⟨j, i⟩ 1 :=\n  basis_repr_single ..\n\n"}
{"name":"Pi.basis_apply","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nη : Type u_2\nιs : η → Type u_3\nMs : η → Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : (i : η) → AddCommMonoid (Ms i)\ninst✝² : (i : η) → Module R (Ms i)\ninst✝¹ : Fintype η\ninst✝ : DecidableEq η\ns : (j : η) → Basis (ιs j) R (Ms j)\nji : Sigma fun j => ιs j\n⊢ Eq ((Pi.basis s) ji) (Pi.single ji.fst ((s ji.fst) ji.snd))","decl":"@[simp]\ntheorem basis_apply [DecidableEq η] (s : ∀ j, Basis (ιs j) R (Ms j)) (ji) :\n    Pi.basis s ji = Pi.single ji.1 (s ji.1 ji.2) :=\n  Basis.apply_eq_iff.mpr (by simp)\n\n"}
{"name":"Pi.basis_repr","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nη : Type u_2\nιs : η → Type u_3\nMs : η → Type u_4\ninst✝³ : Semiring R\ninst✝² : (i : η) → AddCommMonoid (Ms i)\ninst✝¹ : (i : η) → Module R (Ms i)\ninst✝ : Fintype η\ns : (j : η) → Basis (ιs j) R (Ms j)\nx : (j : η) → Ms j\nji : Sigma fun j => ιs j\n⊢ Eq (((Pi.basis s).repr x) ji) (((s ji.fst).repr (x ji.fst)) ji.snd)","decl":"@[simp]\ntheorem basis_repr (s : ∀ j, Basis (ιs j) R (Ms j)) (x) (ji) :\n    (Pi.basis s).repr x ji = (s ji.1).repr (x ji.1) ji.2 :=\n  rfl\n\n"}
{"name":"Pi.basisFun_apply","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nη : Type u_2\ninst✝² : Semiring R\ninst✝¹ : Finite η\ninst✝ : DecidableEq η\ni : η\n⊢ Eq ((Pi.basisFun R η) i) (Pi.single i 1)","decl":"@[simp]\ntheorem basisFun_apply [DecidableEq η] (i) :\n    basisFun R η i = Pi.single i 1 := by\n  simp only [basisFun, Basis.coe_ofEquivFun, LinearEquiv.refl_symm, LinearEquiv.refl_apply]\n\n"}
{"name":"Pi.basisFun_repr","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nη : Type u_2\ninst✝¹ : Semiring R\ninst✝ : Finite η\nx : η → R\ni : η\n⊢ Eq (((Pi.basisFun R η).repr x) i) (x i)","decl":"@[simp]\ntheorem basisFun_repr (x : η → R) (i : η) : (Pi.basisFun R η).repr x i = x i := by simp [basisFun]\n\n"}
{"name":"Pi.basisFun_equivFun","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"R : Type u_1\nη : Type u_2\ninst✝¹ : Semiring R\ninst✝ : Finite η\n⊢ Eq (Pi.basisFun R η).equivFun (LinearEquiv.refl R (η → R))","decl":"@[simp]\ntheorem basisFun_equivFun : (Pi.basisFun R η).equivFun = LinearEquiv.refl _ _ :=\n  Basis.equivFun_ofEquivFun _\n\n"}
{"name":"Module.piEquiv_apply_apply","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"ι : Type u_5\nR : Type u_6\nM : Type u_7\ninst✝³ : Fintype ι\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nv : ι → M\nw : ι → R\n⊢ Eq (((Module.piEquiv ι R M) v) w) (Finset.univ.sum fun i => HSMul.hSMul (w i) (v i))","decl":"lemma piEquiv_apply_apply (ι R M : Type*) [Fintype ι] [CommSemiring R]\n    [AddCommMonoid M] [Module R M] (v : ι → M) (w : ι → R) :\n    piEquiv ι R M v w = ∑ i, w i • v i := by\n  simp only [piEquiv, Basis.constr_apply_fintype, Basis.equivFun_apply]\n  congr\n\n"}
{"name":"Module.range_piEquiv","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝³ : Finite ι\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nv : ι → M\n⊢ Eq (LinearMap.range ((Module.piEquiv ι R M) v)) (Submodule.span R (Set.range v))","decl":"@[simp] lemma range_piEquiv (v : ι → M) :\n    LinearMap.range (piEquiv ι R M v) = span R (range v) :=\n  Basis.constr_range _ _\n\n"}
{"name":"Module.surjective_piEquiv_apply_iff","module":"Mathlib.LinearAlgebra.StdBasis","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝³ : Finite ι\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nv : ι → M\n⊢ Iff (Function.Surjective ⇑((Module.piEquiv ι R M) v)) (Eq (Submodule.span R (Set.range v)) Top.top)","decl":"@[simp] lemma surjective_piEquiv_apply_iff (v : ι → M) :\n    Surjective (piEquiv ι R M v) ↔ span R (range v) = ⊤ := by\n  rw [← LinearMap.range_eq_top, range_piEquiv]\n\n"}
