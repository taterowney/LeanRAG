{"name":"WeakFEPair.mk.injEq","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf‚úù g‚úù : Real ‚Üí E\nk‚úù : Real\nŒµ‚úù : Complex\nf‚ÇÄ‚úù g‚ÇÄ‚úù : E\nhf_int‚úù : MeasureTheory.LocallyIntegrableOn f‚úù (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhg_int‚úù : MeasureTheory.LocallyIntegrableOn g‚úù (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhk‚úù : LT.lt 0 k‚úù\nhŒµ‚úù : Ne Œµ‚úù 0\nh_feq‚úù : ‚àÄ (x : Real), Membership.mem (Set.Ioi 0) x ‚Üí Eq (f‚úù (HDiv.hDiv 1 x)) (HSMul.hSMul (HMul.hMul Œµ‚úù ‚Üë(HPow.hPow x k‚úù)) (g‚úù x))\nhf_top‚úù : ‚àÄ (r : Real), Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (f‚úù x) f‚ÇÄ‚úù) fun x => HPow.hPow x r\nhg_top‚úù : ‚àÄ (r : Real), Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (g‚úù x) g‚ÇÄ‚úù) fun x => HPow.hPow x r\nf g : Real ‚Üí E\nk : Real\nŒµ : Complex\nf‚ÇÄ g‚ÇÄ : E\nhf_int : MeasureTheory.LocallyIntegrableOn f (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhg_int : MeasureTheory.LocallyIntegrableOn g (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhk : LT.lt 0 k\nhŒµ : Ne Œµ 0\nh_feq : ‚àÄ (x : Real), Membership.mem (Set.Ioi 0) x ‚Üí Eq (f (HDiv.hDiv 1 x)) (HSMul.hSMul (HMul.hMul Œµ ‚Üë(HPow.hPow x k)) (g x))\nhf_top : ‚àÄ (r : Real), Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (f x) f‚ÇÄ) fun x => HPow.hPow x r\nhg_top : ‚àÄ (r : Real), Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (g x) g‚ÇÄ) fun x => HPow.hPow x r\n‚ä¢ Eq (Eq { f := f‚úù, g := g‚úù, k := k‚úù, Œµ := Œµ‚úù, f‚ÇÄ := f‚ÇÄ‚úù, g‚ÇÄ := g‚ÇÄ‚úù, hf_int := hf_int‚úù, hg_int := hg_int‚úù, hk := hk‚úù, hŒµ := hŒµ‚úù, h_feq := h_feq‚úù, hf_top := hf_top‚úù, hg_top := hg_top‚úù } { f := f, g := g, k := k, Œµ := Œµ, f‚ÇÄ := f‚ÇÄ, g‚ÇÄ := g‚ÇÄ, hf_int := hf_int, hg_int := hg_int, hk := hk, hŒµ := hŒµ, h_feq := h_feq, hf_top := hf_top, hg_top := hg_top }) (And (Eq f‚úù f) (And (Eq g‚úù g) (And (Eq k‚úù k) (And (Eq Œµ‚úù Œµ) (And (Eq f‚ÇÄ‚úù f‚ÇÄ) (Eq g‚ÇÄ‚úù g‚ÇÄ))))))","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(most general version: rapid decay at `‚àû` up to constant terms) -/\nstructure WeakFEPair where\n  /-- The functions whose Mellin transform we study -/\n  (f g : ‚Ñù ‚Üí E)\n  /-- Weight (exponent in the functional equation) -/\n  (k : ‚Ñù)\n  /-- Root number -/\n  (Œµ : ‚ÑÇ)\n  /-- Constant terms at `‚àû` -/\n  (f‚ÇÄ g‚ÇÄ : E)\n  (hf_int : LocallyIntegrableOn f (Ioi 0))\n  (hg_int : LocallyIntegrableOn g (Ioi 0))\n  (hk : 0 < k)\n  (hŒµ : Œµ ‚â† 0)\n  (h_feq : ‚àÄ x ‚àà Ioi 0, f (1 / x) = (Œµ * ‚Üë(x ^ k)) ‚Ä¢ g x)\n  (hf_top (r : ‚Ñù) : (f ¬∑ - f‚ÇÄ) =O[atTop] (¬∑ ^ r))\n  (hg_top (r : ‚Ñù) : (g ¬∑ - g‚ÇÄ) =O[atTop] (¬∑ ^ r))\n\n"}
{"name":"WeakFEPair.hg_int","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nself : WeakFEPair E\n‚ä¢ MeasureTheory.LocallyIntegrableOn self.g (Set.Ioi 0) MeasureTheory.MeasureSpace.volume","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(most general version: rapid decay at `‚àû` up to constant terms) -/\nstructure WeakFEPair where\n  /-- The functions whose Mellin transform we study -/\n  (f g : ‚Ñù ‚Üí E)\n  /-- Weight (exponent in the functional equation) -/\n  (k : ‚Ñù)\n  /-- Root number -/\n  (Œµ : ‚ÑÇ)\n  /-- Constant terms at `‚àû` -/\n  (f‚ÇÄ g‚ÇÄ : E)\n  (hf_int : LocallyIntegrableOn f (Ioi 0))\n  (hg_int : LocallyIntegrableOn g (Ioi 0))\n  (hk : 0 < k)\n  (hŒµ : Œµ ‚â† 0)\n  (h_feq : ‚àÄ x ‚àà Ioi 0, f (1 / x) = (Œµ * ‚Üë(x ^ k)) ‚Ä¢ g x)\n  (hf_top (r : ‚Ñù) : (f ¬∑ - f‚ÇÄ) =O[atTop] (¬∑ ^ r))\n  (hg_top (r : ‚Ñù) : (g ¬∑ - g‚ÇÄ) =O[atTop] (¬∑ ^ r))\n\n"}
{"name":"WeakFEPair.h_feq","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nself : WeakFEPair E\nx : Real\na‚úù : Membership.mem (Set.Ioi 0) x\n‚ä¢ Eq (self.f (HDiv.hDiv 1 x)) (HSMul.hSMul (HMul.hMul self.Œµ ‚Üë(HPow.hPow x self.k)) (self.g x))","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(most general version: rapid decay at `‚àû` up to constant terms) -/\nstructure WeakFEPair where\n  /-- The functions whose Mellin transform we study -/\n  (f g : ‚Ñù ‚Üí E)\n  /-- Weight (exponent in the functional equation) -/\n  (k : ‚Ñù)\n  /-- Root number -/\n  (Œµ : ‚ÑÇ)\n  /-- Constant terms at `‚àû` -/\n  (f‚ÇÄ g‚ÇÄ : E)\n  (hf_int : LocallyIntegrableOn f (Ioi 0))\n  (hg_int : LocallyIntegrableOn g (Ioi 0))\n  (hk : 0 < k)\n  (hŒµ : Œµ ‚â† 0)\n  (h_feq : ‚àÄ x ‚àà Ioi 0, f (1 / x) = (Œµ * ‚Üë(x ^ k)) ‚Ä¢ g x)\n  (hf_top (r : ‚Ñù) : (f ¬∑ - f‚ÇÄ) =O[atTop] (¬∑ ^ r))\n  (hg_top (r : ‚Ñù) : (g ¬∑ - g‚ÇÄ) =O[atTop] (¬∑ ^ r))\n\n"}
{"name":"WeakFEPair.hg_top","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nself : WeakFEPair E\nr : Real\n‚ä¢ Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (self.g x) self.g‚ÇÄ) fun x => HPow.hPow x r","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(most general version: rapid decay at `‚àû` up to constant terms) -/\nstructure WeakFEPair where\n  /-- The functions whose Mellin transform we study -/\n  (f g : ‚Ñù ‚Üí E)\n  /-- Weight (exponent in the functional equation) -/\n  (k : ‚Ñù)\n  /-- Root number -/\n  (Œµ : ‚ÑÇ)\n  /-- Constant terms at `‚àû` -/\n  (f‚ÇÄ g‚ÇÄ : E)\n  (hf_int : LocallyIntegrableOn f (Ioi 0))\n  (hg_int : LocallyIntegrableOn g (Ioi 0))\n  (hk : 0 < k)\n  (hŒµ : Œµ ‚â† 0)\n  (h_feq : ‚àÄ x ‚àà Ioi 0, f (1 / x) = (Œµ * ‚Üë(x ^ k)) ‚Ä¢ g x)\n  (hf_top (r : ‚Ñù) : (f ¬∑ - f‚ÇÄ) =O[atTop] (¬∑ ^ r))\n  (hg_top (r : ‚Ñù) : (g ¬∑ - g‚ÇÄ) =O[atTop] (¬∑ ^ r))\n\n"}
{"name":"WeakFEPair.hŒµ","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nself : WeakFEPair E\n‚ä¢ Ne self.Œµ 0","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(most general version: rapid decay at `‚àû` up to constant terms) -/\nstructure WeakFEPair where\n  /-- The functions whose Mellin transform we study -/\n  (f g : ‚Ñù ‚Üí E)\n  /-- Weight (exponent in the functional equation) -/\n  (k : ‚Ñù)\n  /-- Root number -/\n  (Œµ : ‚ÑÇ)\n  /-- Constant terms at `‚àû` -/\n  (f‚ÇÄ g‚ÇÄ : E)\n  (hf_int : LocallyIntegrableOn f (Ioi 0))\n  (hg_int : LocallyIntegrableOn g (Ioi 0))\n  (hk : 0 < k)\n  (hŒµ : Œµ ‚â† 0)\n  (h_feq : ‚àÄ x ‚àà Ioi 0, f (1 / x) = (Œµ * ‚Üë(x ^ k)) ‚Ä¢ g x)\n  (hf_top (r : ‚Ñù) : (f ¬∑ - f‚ÇÄ) =O[atTop] (¬∑ ^ r))\n  (hg_top (r : ‚Ñù) : (g ¬∑ - g‚ÇÄ) =O[atTop] (¬∑ ^ r))\n\n"}
{"name":"WeakFEPair.hk","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nself : WeakFEPair E\n‚ä¢ LT.lt 0 self.k","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(most general version: rapid decay at `‚àû` up to constant terms) -/\nstructure WeakFEPair where\n  /-- The functions whose Mellin transform we study -/\n  (f g : ‚Ñù ‚Üí E)\n  /-- Weight (exponent in the functional equation) -/\n  (k : ‚Ñù)\n  /-- Root number -/\n  (Œµ : ‚ÑÇ)\n  /-- Constant terms at `‚àû` -/\n  (f‚ÇÄ g‚ÇÄ : E)\n  (hf_int : LocallyIntegrableOn f (Ioi 0))\n  (hg_int : LocallyIntegrableOn g (Ioi 0))\n  (hk : 0 < k)\n  (hŒµ : Œµ ‚â† 0)\n  (h_feq : ‚àÄ x ‚àà Ioi 0, f (1 / x) = (Œµ * ‚Üë(x ^ k)) ‚Ä¢ g x)\n  (hf_top (r : ‚Ñù) : (f ¬∑ - f‚ÇÄ) =O[atTop] (¬∑ ^ r))\n  (hg_top (r : ‚Ñù) : (g ¬∑ - g‚ÇÄ) =O[atTop] (¬∑ ^ r))\n\n"}
{"name":"WeakFEPair.hf_top","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nself : WeakFEPair E\nr : Real\n‚ä¢ Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (self.f x) self.f‚ÇÄ) fun x => HPow.hPow x r","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(most general version: rapid decay at `‚àû` up to constant terms) -/\nstructure WeakFEPair where\n  /-- The functions whose Mellin transform we study -/\n  (f g : ‚Ñù ‚Üí E)\n  /-- Weight (exponent in the functional equation) -/\n  (k : ‚Ñù)\n  /-- Root number -/\n  (Œµ : ‚ÑÇ)\n  /-- Constant terms at `‚àû` -/\n  (f‚ÇÄ g‚ÇÄ : E)\n  (hf_int : LocallyIntegrableOn f (Ioi 0))\n  (hg_int : LocallyIntegrableOn g (Ioi 0))\n  (hk : 0 < k)\n  (hŒµ : Œµ ‚â† 0)\n  (h_feq : ‚àÄ x ‚àà Ioi 0, f (1 / x) = (Œµ * ‚Üë(x ^ k)) ‚Ä¢ g x)\n  (hf_top (r : ‚Ñù) : (f ¬∑ - f‚ÇÄ) =O[atTop] (¬∑ ^ r))\n  (hg_top (r : ‚Ñù) : (g ¬∑ - g‚ÇÄ) =O[atTop] (¬∑ ^ r))\n\n"}
{"name":"WeakFEPair.mk.sizeOf_spec","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Complex E\ninst‚úù : SizeOf E\nf g : Real ‚Üí E\nk : Real\nŒµ : Complex\nf‚ÇÄ g‚ÇÄ : E\nhf_int : MeasureTheory.LocallyIntegrableOn f (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhg_int : MeasureTheory.LocallyIntegrableOn g (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhk : LT.lt 0 k\nhŒµ : Ne Œµ 0\nh_feq : ‚àÄ (x : Real), Membership.mem (Set.Ioi 0) x ‚Üí Eq (f (HDiv.hDiv 1 x)) (HSMul.hSMul (HMul.hMul Œµ ‚Üë(HPow.hPow x k)) (g x))\nhf_top : ‚àÄ (r : Real), Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (f x) f‚ÇÄ) fun x => HPow.hPow x r\nhg_top : ‚àÄ (r : Real), Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (g x) g‚ÇÄ) fun x => HPow.hPow x r\n‚ä¢ Eq (SizeOf.sizeOf { f := f, g := g, k := k, Œµ := Œµ, f‚ÇÄ := f‚ÇÄ, g‚ÇÄ := g‚ÇÄ, hf_int := hf_int, hg_int := hg_int, hk := hk, hŒµ := hŒµ, h_feq := h_feq, hf_top := hf_top, hg_top := hg_top }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf k)) (SizeOf.sizeOf Œµ)) (SizeOf.sizeOf f‚ÇÄ)) (SizeOf.sizeOf g‚ÇÄ)) (SizeOf.sizeOf hk))","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(most general version: rapid decay at `‚àû` up to constant terms) -/\nstructure WeakFEPair where\n  /-- The functions whose Mellin transform we study -/\n  (f g : ‚Ñù ‚Üí E)\n  /-- Weight (exponent in the functional equation) -/\n  (k : ‚Ñù)\n  /-- Root number -/\n  (Œµ : ‚ÑÇ)\n  /-- Constant terms at `‚àû` -/\n  (f‚ÇÄ g‚ÇÄ : E)\n  (hf_int : LocallyIntegrableOn f (Ioi 0))\n  (hg_int : LocallyIntegrableOn g (Ioi 0))\n  (hk : 0 < k)\n  (hŒµ : Œµ ‚â† 0)\n  (h_feq : ‚àÄ x ‚àà Ioi 0, f (1 / x) = (Œµ * ‚Üë(x ^ k)) ‚Ä¢ g x)\n  (hf_top (r : ‚Ñù) : (f ¬∑ - f‚ÇÄ) =O[atTop] (¬∑ ^ r))\n  (hg_top (r : ‚Ñù) : (g ¬∑ - g‚ÇÄ) =O[atTop] (¬∑ ^ r))\n\n"}
{"name":"WeakFEPair.hf_int","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nself : WeakFEPair E\n‚ä¢ MeasureTheory.LocallyIntegrableOn self.f (Set.Ioi 0) MeasureTheory.MeasureSpace.volume","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(most general version: rapid decay at `‚àû` up to constant terms) -/\nstructure WeakFEPair where\n  /-- The functions whose Mellin transform we study -/\n  (f g : ‚Ñù ‚Üí E)\n  /-- Weight (exponent in the functional equation) -/\n  (k : ‚Ñù)\n  /-- Root number -/\n  (Œµ : ‚ÑÇ)\n  /-- Constant terms at `‚àû` -/\n  (f‚ÇÄ g‚ÇÄ : E)\n  (hf_int : LocallyIntegrableOn f (Ioi 0))\n  (hg_int : LocallyIntegrableOn g (Ioi 0))\n  (hk : 0 < k)\n  (hŒµ : Œµ ‚â† 0)\n  (h_feq : ‚àÄ x ‚àà Ioi 0, f (1 / x) = (Œµ * ‚Üë(x ^ k)) ‚Ä¢ g x)\n  (hf_top (r : ‚Ñù) : (f ¬∑ - f‚ÇÄ) =O[atTop] (¬∑ ^ r))\n  (hg_top (r : ‚Ñù) : (g ¬∑ - g‚ÇÄ) =O[atTop] (¬∑ ^ r))\n\n"}
{"name":"WeakFEPair.mk.inj","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf‚úù g‚úù : Real ‚Üí E\nk‚úù : Real\nŒµ‚úù : Complex\nf‚ÇÄ‚úù g‚ÇÄ‚úù : E\nhf_int‚úù : MeasureTheory.LocallyIntegrableOn f‚úù (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhg_int‚úù : MeasureTheory.LocallyIntegrableOn g‚úù (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhk‚úù : LT.lt 0 k‚úù\nhŒµ‚úù : Ne Œµ‚úù 0\nh_feq‚úù : ‚àÄ (x : Real), Membership.mem (Set.Ioi 0) x ‚Üí Eq (f‚úù (HDiv.hDiv 1 x)) (HSMul.hSMul (HMul.hMul Œµ‚úù ‚Üë(HPow.hPow x k‚úù)) (g‚úù x))\nhf_top‚úù : ‚àÄ (r : Real), Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (f‚úù x) f‚ÇÄ‚úù) fun x => HPow.hPow x r\nhg_top‚úù : ‚àÄ (r : Real), Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (g‚úù x) g‚ÇÄ‚úù) fun x => HPow.hPow x r\nf g : Real ‚Üí E\nk : Real\nŒµ : Complex\nf‚ÇÄ g‚ÇÄ : E\nhf_int : MeasureTheory.LocallyIntegrableOn f (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhg_int : MeasureTheory.LocallyIntegrableOn g (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhk : LT.lt 0 k\nhŒµ : Ne Œµ 0\nh_feq : ‚àÄ (x : Real), Membership.mem (Set.Ioi 0) x ‚Üí Eq (f (HDiv.hDiv 1 x)) (HSMul.hSMul (HMul.hMul Œµ ‚Üë(HPow.hPow x k)) (g x))\nhf_top : ‚àÄ (r : Real), Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (f x) f‚ÇÄ) fun x => HPow.hPow x r\nhg_top : ‚àÄ (r : Real), Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (g x) g‚ÇÄ) fun x => HPow.hPow x r\nx‚úù : Eq { f := f‚úù, g := g‚úù, k := k‚úù, Œµ := Œµ‚úù, f‚ÇÄ := f‚ÇÄ‚úù, g‚ÇÄ := g‚ÇÄ‚úù, hf_int := hf_int‚úù, hg_int := hg_int‚úù, hk := hk‚úù, hŒµ := hŒµ‚úù, h_feq := h_feq‚úù, hf_top := hf_top‚úù, hg_top := hg_top‚úù } { f := f, g := g, k := k, Œµ := Œµ, f‚ÇÄ := f‚ÇÄ, g‚ÇÄ := g‚ÇÄ, hf_int := hf_int, hg_int := hg_int, hk := hk, hŒµ := hŒµ, h_feq := h_feq, hf_top := hf_top, hg_top := hg_top }\n‚ä¢ And (Eq f‚úù f) (And (Eq g‚úù g) (And (Eq k‚úù k) (And (Eq Œµ‚úù Œµ) (And (Eq f‚ÇÄ‚úù f‚ÇÄ) (Eq g‚ÇÄ‚úù g‚ÇÄ)))))","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(most general version: rapid decay at `‚àû` up to constant terms) -/\nstructure WeakFEPair where\n  /-- The functions whose Mellin transform we study -/\n  (f g : ‚Ñù ‚Üí E)\n  /-- Weight (exponent in the functional equation) -/\n  (k : ‚Ñù)\n  /-- Root number -/\n  (Œµ : ‚ÑÇ)\n  /-- Constant terms at `‚àû` -/\n  (f‚ÇÄ g‚ÇÄ : E)\n  (hf_int : LocallyIntegrableOn f (Ioi 0))\n  (hg_int : LocallyIntegrableOn g (Ioi 0))\n  (hk : 0 < k)\n  (hŒµ : Œµ ‚â† 0)\n  (h_feq : ‚àÄ x ‚àà Ioi 0, f (1 / x) = (Œµ * ‚Üë(x ^ k)) ‚Ä¢ g x)\n  (hf_top (r : ‚Ñù) : (f ¬∑ - f‚ÇÄ) =O[atTop] (¬∑ ^ r))\n  (hg_top (r : ‚Ñù) : (g ¬∑ - g‚ÇÄ) =O[atTop] (¬∑ ^ r))\n\n"}
{"name":"StrongFEPair.mk.inj","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\ntoWeakFEPair‚úù : WeakFEPair E\nhf‚ÇÄ‚úù : Eq toWeakFEPair‚úù.f‚ÇÄ 0\nhg‚ÇÄ‚úù : Eq toWeakFEPair‚úù.g‚ÇÄ 0\ntoWeakFEPair : WeakFEPair E\nhf‚ÇÄ : Eq toWeakFEPair.f‚ÇÄ 0\nhg‚ÇÄ : Eq toWeakFEPair.g‚ÇÄ 0\nx‚úù : Eq { toWeakFEPair := toWeakFEPair‚úù, hf‚ÇÄ := hf‚ÇÄ‚úù, hg‚ÇÄ := hg‚ÇÄ‚úù } { toWeakFEPair := toWeakFEPair, hf‚ÇÄ := hf‚ÇÄ, hg‚ÇÄ := hg‚ÇÄ }\n‚ä¢ Eq toWeakFEPair‚úù toWeakFEPair","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(version without constant terms) -/\nstructure StrongFEPair extends WeakFEPair E where (hf‚ÇÄ : f‚ÇÄ = 0) (hg‚ÇÄ : g‚ÇÄ = 0)\n\n"}
{"name":"StrongFEPair.mk.sizeOf_spec","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Complex E\ninst‚úù : SizeOf E\ntoWeakFEPair : WeakFEPair E\nhf‚ÇÄ : Eq toWeakFEPair.f‚ÇÄ 0\nhg‚ÇÄ : Eq toWeakFEPair.g‚ÇÄ 0\n‚ä¢ Eq (SizeOf.sizeOf { toWeakFEPair := toWeakFEPair, hf‚ÇÄ := hf‚ÇÄ, hg‚ÇÄ := hg‚ÇÄ }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toWeakFEPair)) (SizeOf.sizeOf hf‚ÇÄ)) (SizeOf.sizeOf hg‚ÇÄ))","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(version without constant terms) -/\nstructure StrongFEPair extends WeakFEPair E where (hf‚ÇÄ : f‚ÇÄ = 0) (hg‚ÇÄ : g‚ÇÄ = 0)\n\n"}
{"name":"StrongFEPair.hg‚ÇÄ","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nself : StrongFEPair E\n‚ä¢ Eq self.g‚ÇÄ 0","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(version without constant terms) -/\nstructure StrongFEPair extends WeakFEPair E where (hf‚ÇÄ : f‚ÇÄ = 0) (hg‚ÇÄ : g‚ÇÄ = 0)\n\n"}
{"name":"StrongFEPair.hf‚ÇÄ","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nself : StrongFEPair E\n‚ä¢ Eq self.f‚ÇÄ 0","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(version without constant terms) -/\nstructure StrongFEPair extends WeakFEPair E where (hf‚ÇÄ : f‚ÇÄ = 0) (hg‚ÇÄ : g‚ÇÄ = 0)\n\n"}
{"name":"StrongFEPair.mk.injEq","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\ntoWeakFEPair‚úù : WeakFEPair E\nhf‚ÇÄ‚úù : Eq toWeakFEPair‚úù.f‚ÇÄ 0\nhg‚ÇÄ‚úù : Eq toWeakFEPair‚úù.g‚ÇÄ 0\ntoWeakFEPair : WeakFEPair E\nhf‚ÇÄ : Eq toWeakFEPair.f‚ÇÄ 0\nhg‚ÇÄ : Eq toWeakFEPair.g‚ÇÄ 0\n‚ä¢ Eq (Eq { toWeakFEPair := toWeakFEPair‚úù, hf‚ÇÄ := hf‚ÇÄ‚úù, hg‚ÇÄ := hg‚ÇÄ‚úù } { toWeakFEPair := toWeakFEPair, hf‚ÇÄ := hf‚ÇÄ, hg‚ÇÄ := hg‚ÇÄ }) (Eq toWeakFEPair‚úù toWeakFEPair)","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(version without constant terms) -/\nstructure StrongFEPair extends WeakFEPair E where (hf‚ÇÄ : f‚ÇÄ = 0) (hg‚ÇÄ : g‚ÇÄ = 0)\n\n"}
{"name":"WeakFEPair.h_feq'","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nP : WeakFEPair E\nx : Real\nhx : LT.lt 0 x\n‚ä¢ Eq (P.g (HDiv.hDiv 1 x)) (HSMul.hSMul (HMul.hMul (Inv.inv P.Œµ) ‚Üë(HPow.hPow x P.k)) (P.f x))","decl":"/-- Reformulated functional equation with `f` and `g` interchanged. -/\nlemma WeakFEPair.h_feq' (P : WeakFEPair E) (x : ‚Ñù) (hx : 0 < x) :\n    P.g (1 / x) = (P.Œµ‚Åª¬π * ‚Üë(x ^ P.k)) ‚Ä¢ P.f x := by\n  rw [(div_div_cancel‚ÇÄ (one_ne_zero' ‚Ñù) ‚ñ∏ P.h_feq (1 / x) (one_div_pos.mpr hx):), ‚Üê mul_smul]\n  convert (one_smul ‚ÑÇ (P.g (1 / x))).symm using 2\n  rw [one_div, inv_rpow hx.le, ofReal_inv]\n  field_simp [P.hŒµ, (rpow_pos_of_pos hx _).ne']\n\n"}
{"name":"WeakFEPair.hf_zero","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nP : WeakFEPair E\nr : Real\n‚ä¢ Asymptotics.IsBigO (nhdsWithin 0 (Set.Ioi 0)) (fun x => HSub.hSub (P.f x) (HSMul.hSMul (HMul.hMul P.Œµ ‚Üë(HPow.hPow x (Neg.neg P.k))) P.g‚ÇÄ)) fun x => HPow.hPow x r","decl":"/-- As `x ‚Üí 0`, we have `f x = x ^ (-P.k) ‚Ä¢ constant` up to a rapidly decaying error. -/\nlemma hf_zero (P : WeakFEPair E) (r : ‚Ñù) :\n    (fun x ‚Ü¶ P.f x - (P.Œµ * ‚Üë(x ^ (-P.k))) ‚Ä¢ P.g‚ÇÄ) =O[ùìù[>] 0] (¬∑ ^ r) := by\n  have := (P.hg_top (-(r + P.k))).comp_tendsto tendsto_inv_nhdsGT_zero\n  simp_rw [IsBigO, IsBigOWith, eventually_nhdsWithin_iff] at this ‚ä¢\n  obtain ‚ü®C, hC‚ü© := this\n  use ‚ÄñP.Œµ‚Äñ * C\n  filter_upwards [hC] with x hC' (hx : 0 < x)\n  have h_nv2 : ‚Üë(x ^ P.k) ‚â† (0 : ‚ÑÇ) := ofReal_ne_zero.mpr (rpow_pos_of_pos hx _).ne'\n  have h_nv : P.Œµ‚Åª¬π * ‚Üë(x ^ P.k) ‚â† 0 := mul_ne_zero P.symm.hŒµ h_nv2\n  specialize hC' hx\n  simp_rw [Function.comp_apply, ‚Üê one_div, P.h_feq' _ hx] at hC'\n  rw [‚Üê ((mul_inv_cancel‚ÇÄ h_nv).symm ‚ñ∏ one_smul ‚ÑÇ P.g‚ÇÄ :), mul_smul _ _ P.g‚ÇÄ, ‚Üê smul_sub, norm_smul,\n    ‚Üê le_div_iff‚ÇÄ' (lt_of_le_of_ne (norm_nonneg _) (norm_ne_zero_iff.mpr h_nv).symm)] at hC'\n  convert hC' using 1\n  ¬∑ congr 3\n    rw [rpow_neg hx.le]\n    field_simp\n  ¬∑ simp_rw [norm_mul, norm_real, one_div, inv_rpow hx.le, rpow_neg hx.le, inv_inv, norm_inv,\n      norm_of_nonneg (rpow_pos_of_pos hx _).le, rpow_add hx]\n    field_simp\n    ring\n\n"}
{"name":"WeakFEPair.hf_zero'","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nP : WeakFEPair E\n‚ä¢ Asymptotics.IsBigO (nhdsWithin 0 (Set.Ioi 0)) (fun x => HSub.hSub (P.f x) P.f‚ÇÄ) fun x => HPow.hPow x (Neg.neg P.k)","decl":"/-- Power asymptotic for `f - f‚ÇÄ` as `x ‚Üí 0`. -/\nlemma hf_zero' (P : WeakFEPair E) :\n    (fun x : ‚Ñù ‚Ü¶ P.f x - P.f‚ÇÄ) =O[ùìù[>] 0] (¬∑ ^ (-P.k)) := by\n  simp_rw [‚Üê fun x ‚Ü¶ sub_add_sub_cancel (P.f x) ((P.Œµ * ‚Üë(x ^ (-P.k))) ‚Ä¢ P.g‚ÇÄ) P.f‚ÇÄ]\n  refine (P.hf_zero _).add (IsBigO.sub ?_ ?_)\n  ¬∑ rw [‚Üê isBigO_norm_norm]\n    simp_rw [mul_smul, norm_smul, mul_comm _ ‚ÄñP.g‚ÇÄ‚Äñ, ‚Üê mul_assoc, norm_real]\n    apply (isBigO_refl _ _).const_mul_left\n  ¬∑ refine IsBigO.of_bound ‚ÄñP.f‚ÇÄ‚Äñ (eventually_nhdsWithin_iff.mpr ?_)\n    filter_upwards [eventually_le_nhds zero_lt_one] with x hx' (hx : 0 < x)\n    apply le_mul_of_one_le_right (norm_nonneg _)\n    rw [norm_of_nonneg (rpow_pos_of_pos hx _).le, rpow_neg hx.le]\n    exact (one_le_inv‚ÇÄ (rpow_pos_of_pos hx _)).2 (rpow_le_one hx.le hx' P.hk.le)\n\n"}
{"name":"StrongFEPair.hf_top'","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nP : StrongFEPair E\nr : Real\n‚ä¢ Asymptotics.IsBigO Filter.atTop P.f fun x => HPow.hPow x r","decl":"/-- As `x ‚Üí ‚àû`, `f x` decays faster than any power of `x`. -/\nlemma hf_top' (r : ‚Ñù) : P.f =O[atTop] (¬∑ ^ r) := by\n  simpa [P.hf‚ÇÄ] using P.hf_top r\n\n"}
{"name":"StrongFEPair.hf_zero'","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nP : StrongFEPair E\nr : Real\n‚ä¢ Asymptotics.IsBigO (nhdsWithin 0 (Set.Ioi 0)) P.f fun x => HPow.hPow x r","decl":"/-- As `x ‚Üí 0`, `f x` decays faster than any power of `x`. -/\nlemma hf_zero' (r : ‚Ñù) : P.f =O[ùìù[>] 0] (¬∑ ^ r) := by\n  simpa using (P.hg‚ÇÄ ‚ñ∏ P.hf_zero r :)\n\n"}
{"name":"StrongFEPair.hasMellin","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nP : StrongFEPair E\ns : Complex\n‚ä¢ HasMellin P.f s (P.Œõ s)","decl":"/-- The Mellin transform of `f` is well-defined and equal to `P.Œõ s`, for all `s`. -/\ntheorem hasMellin (s : ‚ÑÇ) : HasMellin P.f s (P.Œõ s) :=\n  let ‚ü®_, ht‚ü© := exists_gt s.re\n  let ‚ü®_, hu‚ü© := exists_lt s.re\n  ‚ü®mellinConvergent_of_isBigO_rpow P.hf_int (P.hf_top' _) ht (P.hf_zero' _) hu, rfl‚ü©\n\n"}
{"name":"StrongFEPair.Œõ_eq","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nP : StrongFEPair E\n‚ä¢ Eq P.Œõ (mellin P.f)","decl":"lemma Œõ_eq : P.Œõ = mellin P.f := rfl\n\n"}
{"name":"StrongFEPair.symm_Œõ_eq","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nP : StrongFEPair E\n‚ä¢ Eq P.symm.Œõ (mellin P.g)","decl":"lemma symm_Œõ_eq : P.symm.Œõ = mellin P.g := rfl\n\n"}
{"name":"StrongFEPair.differentiable_Œõ","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nP : StrongFEPair E\n‚ä¢ Differentiable Complex P.Œõ","decl":"/-- If `(f, g)` are a strong FE pair, then the Mellin transform of `f` is entire. -/\ntheorem differentiable_Œõ : Differentiable ‚ÑÇ P.Œõ := fun s ‚Ü¶\n  let ‚ü®_, ht‚ü© := exists_gt s.re\n  let ‚ü®_, hu‚ü© := exists_lt s.re\n  mellin_differentiableAt_of_isBigO_rpow P.hf_int (P.hf_top' _) ht (P.hf_zero' _) hu\n\n"}
{"name":"StrongFEPair.functional_equation","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nP : StrongFEPair E\ns : Complex\n‚ä¢ Eq (P.Œõ (HSub.hSub (‚ÜëP.k) s)) (HSMul.hSMul P.Œµ (P.symm.Œõ s))","decl":"/-- Main theorem about strong FE pairs: if `(f, g)` are a strong FE pair, then the Mellin\ntransforms of `f` and `g` are related by `s ‚Ü¶ k - s`.\n\nThis is proved by making a substitution `t ‚Ü¶ t‚Åª¬π` in the Mellin transform integral. -/\ntheorem functional_equation (s : ‚ÑÇ) :\n    P.Œõ (P.k - s) = P.Œµ ‚Ä¢ P.symm.Œõ s := by\n  -- unfold definition:\n  rw [P.Œõ_eq, P.symm_Œõ_eq]\n  -- substitute `t ‚Ü¶ t‚Åª¬π` in `mellin P.g s`\n  have step1 := mellin_comp_rpow P.g (-s) (-1)\n  simp_rw [abs_neg, abs_one, inv_one, one_smul, ofReal_neg, ofReal_one, div_neg, div_one, neg_neg,\n    rpow_neg_one, ‚Üê one_div] at step1\n  -- introduce a power of `t` to match the hypothesis `P.h_feq`\n  have step2 := mellin_cpow_smul (fun t ‚Ü¶ P.g (1 / t)) (P.k - s) (-P.k)\n  rw [‚Üê sub_eq_add_neg, sub_right_comm, sub_self, zero_sub, step1] at step2\n  -- put in the constant `P.Œµ`\n  have step3 := mellin_const_smul (fun t ‚Ü¶ (t : ‚ÑÇ) ^ (-P.k : ‚ÑÇ) ‚Ä¢ P.g (1 / t)) (P.k - s) P.Œµ\n  rw [step2] at step3\n  rw [‚Üê step3]\n  -- now the integrand matches `P.h_feq'` on `Ioi 0`, so we can apply `setIntegral_congr_fun`\n  refine setIntegral_congr_fun measurableSet_Ioi (fun t ht ‚Ü¶ ?_)\n  simp_rw [P.h_feq' t ht, ‚Üê mul_smul]\n  -- some simple `cpow` arithmetic to finish\n  rw [cpow_neg, ofReal_cpow (le_of_lt ht)]\n  have : (t : ‚ÑÇ) ^ (P.k : ‚ÑÇ) ‚â† 0 := by simpa [‚Üê ofReal_cpow ht.le] using (rpow_pos_of_pos ht _).ne'\n  field_simp [P.hŒµ]\n\n"}
{"name":"WeakFEPair.hf_modif_int","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nP : WeakFEPair E\n‚ä¢ MeasureTheory.LocallyIntegrableOn P.f_modif (Set.Ioi 0) MeasureTheory.MeasureSpace.volume","decl":"lemma hf_modif_int :\n    LocallyIntegrableOn P.f_modif (Ioi 0) := by\n  have : LocallyIntegrableOn (fun x : ‚Ñù ‚Ü¶ (P.Œµ * ‚Üë(x ^ (-P.k))) ‚Ä¢ P.g‚ÇÄ) (Ioi 0) := by\n    refine ContinuousOn.locallyIntegrableOn ?_ measurableSet_Ioi\n    refine continuousOn_of_forall_continuousAt (fun x (hx : 0 < x) ‚Ü¶ ?_)\n    refine (continuousAt_const.mul ?_).smul continuousAt_const\n    exact continuous_ofReal.continuousAt.comp (continuousAt_rpow_const _ _ (Or.inl hx.ne'))\n  refine LocallyIntegrableOn.add (fun x hx ‚Ü¶ ?_) (fun x hx ‚Ü¶ ?_)\n  ¬∑ obtain ‚ü®s, hs, hs'‚ü© := P.hf_int.sub (locallyIntegrableOn_const _) x hx\n    refine ‚ü®s, hs, ?_‚ü©\n    rw [IntegrableOn, integrable_indicator_iff measurableSet_Ioi, IntegrableOn,\n      Measure.restrict_restrict measurableSet_Ioi, ‚Üê IntegrableOn]\n    exact hs'.mono_set Set.inter_subset_right\n  ¬∑ obtain ‚ü®s, hs, hs'‚ü© := P.hf_int.sub this x hx\n    refine ‚ü®s, hs, ?_‚ü©\n    rw [IntegrableOn, integrable_indicator_iff measurableSet_Ioo, IntegrableOn,\n      Measure.restrict_restrict measurableSet_Ioo, ‚Üê IntegrableOn]\n    exact hs'.mono_set Set.inter_subset_right\n\n"}
{"name":"WeakFEPair.hf_modif_FE","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nP : WeakFEPair E\nx : Real\nhx : LT.lt 0 x\n‚ä¢ Eq (P.f_modif (HDiv.hDiv 1 x)) (HSMul.hSMul (HMul.hMul P.Œµ ‚Üë(HPow.hPow x P.k)) (P.g_modif x))","decl":"lemma hf_modif_FE (x : ‚Ñù) (hx : 0 < x) :\n    P.f_modif (1 / x) = (P.Œµ * ‚Üë(x ^ P.k)) ‚Ä¢ P.g_modif x := by\n  rcases lt_trichotomy 1 x with hx' | rfl | hx'\n  ¬∑ have : 1 / x < 1 := by rwa [one_div_lt hx one_pos, div_one]\n    rw [f_modif, Pi.add_apply, indicator_of_not_mem (not_mem_Ioi.mpr this.le),\n      zero_add, indicator_of_mem (mem_Ioo.mpr ‚ü®div_pos one_pos hx, this‚ü©), g_modif, Pi.add_apply,\n      indicator_of_mem (mem_Ioi.mpr hx'), indicator_of_not_mem\n      (not_mem_Ioo_of_ge hx'.le), add_zero, P.h_feq _ hx, smul_sub]\n    simp_rw [rpow_neg (one_div_pos.mpr hx).le, one_div, inv_rpow hx.le, inv_inv]\n  ¬∑ simp [f_modif, g_modif]\n  ¬∑ have : 1 < 1 / x := by rwa [lt_one_div one_pos hx, div_one]\n    rw [f_modif, Pi.add_apply, indicator_of_mem (mem_Ioi.mpr this),\n      indicator_of_not_mem (not_mem_Ioo_of_ge this.le), add_zero, g_modif, Pi.add_apply,\n      indicator_of_not_mem (not_mem_Ioi.mpr hx'.le),\n      indicator_of_mem (mem_Ioo.mpr ‚ü®hx, hx'‚ü©), zero_add, P.h_feq _ hx, smul_sub]\n    simp_rw [rpow_neg hx.le, ‚Üê mul_smul]\n    field_simp [(rpow_pos_of_pos hx P.k).ne', P.hŒµ]\n\n"}
{"name":"WeakFEPair.f_modif_aux1","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nP : WeakFEPair E\n‚ä¢ Set.EqOn (fun x => HAdd.hAdd (HSub.hSub (P.f_modif x) (P.f x)) P.f‚ÇÄ) (HAdd.hAdd ((Set.Ioo 0 1).indicator fun x => HSub.hSub P.f‚ÇÄ (HSMul.hSMul (HMul.hMul P.Œµ ‚Üë(HPow.hPow x (Neg.neg P.k))) P.g‚ÇÄ)) ((Singleton.singleton 1).indicator fun x => HSub.hSub P.f‚ÇÄ (P.f 1))) (Set.Ioi 0)","decl":"lemma f_modif_aux1 : EqOn (fun x ‚Ü¶ P.f_modif x - P.f x + P.f‚ÇÄ)\n    ((Ioo 0 1).indicator (fun x : ‚Ñù ‚Ü¶ P.f‚ÇÄ - (P.Œµ * ‚Üë(x ^ (-P.k))) ‚Ä¢ P.g‚ÇÄ)\n    + ({1} : Set ‚Ñù).indicator (fun _ ‚Ü¶ P.f‚ÇÄ - P.f 1)) (Ioi 0) := by\n  intro x (hx : 0 < x)\n  simp_rw [f_modif, Pi.add_apply]\n  rcases lt_trichotomy x 1 with hx' | rfl | hx'\n  ¬∑ simp_rw [indicator_of_not_mem (not_mem_Ioi.mpr hx'.le),\n      indicator_of_mem (mem_Ioo.mpr ‚ü®hx, hx'‚ü©),\n      indicator_of_not_mem (mem_singleton_iff.not.mpr hx'.ne)]\n    abel\n  ¬∑ simp [add_comm, sub_eq_add_neg]\n  ¬∑ simp_rw [indicator_of_mem (mem_Ioi.mpr hx'),\n      indicator_of_not_mem (not_mem_Ioo_of_ge hx'.le),\n      indicator_of_not_mem (mem_singleton_iff.not.mpr hx'.ne')]\n    abel\n\n"}
{"name":"WeakFEPair.f_modif_aux2","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Complex E\nP : WeakFEPair E\ninst‚úù : CompleteSpace E\ns : Complex\nhs : LT.lt P.k s.re\n‚ä¢ Eq (mellin (fun x => HAdd.hAdd (HSub.hSub (P.f_modif x) (P.f x)) P.f‚ÇÄ) s) (HAdd.hAdd (HSMul.hSMul (HDiv.hDiv 1 s) P.f‚ÇÄ) (HSMul.hSMul (HDiv.hDiv P.Œµ (HSub.hSub (‚ÜëP.k) s)) P.g‚ÇÄ))","decl":"/-- Compute the Mellin transform of the modifying term used to kill off the constants at\n`0` and `‚àû`. -/\nlemma f_modif_aux2 [CompleteSpace E] {s : ‚ÑÇ} (hs : P.k < re s) :\n    mellin (fun x ‚Ü¶ P.f_modif x - P.f x + P.f‚ÇÄ) s = (1 / s) ‚Ä¢ P.f‚ÇÄ + (P.Œµ  / (P.k - s)) ‚Ä¢ P.g‚ÇÄ := by\n  have h_re1 : -1 < re (s - 1) := by simpa using P.hk.trans hs\n  have h_re2 : -1 < re (s - P.k - 1) := by simpa using hs\n  calc\n  _ = ‚à´ (x : ‚Ñù) in Ioi 0, (x : ‚ÑÇ) ^ (s - 1) ‚Ä¢\n      ((Ioo 0 1).indicator (fun t : ‚Ñù ‚Ü¶ P.f‚ÇÄ - (P.Œµ * ‚Üë(t ^ (-P.k))) ‚Ä¢ P.g‚ÇÄ) x\n      + ({1} : Set ‚Ñù).indicator (fun _ ‚Ü¶ P.f‚ÇÄ - P.f 1) x) :=\n    setIntegral_congr_fun measurableSet_Ioi (fun x hx ‚Ü¶ by simp [f_modif_aux1 P hx])\n  _ = ‚à´ (x : ‚Ñù) in Ioi 0, (x : ‚ÑÇ) ^ (s - 1) ‚Ä¢ ((Ioo 0 1).indicator\n      (fun t : ‚Ñù ‚Ü¶ P.f‚ÇÄ - (P.Œµ * ‚Üë(t ^ (-P.k))) ‚Ä¢ P.g‚ÇÄ) x) := by\n    refine setIntegral_congr_ae measurableSet_Ioi (eventually_of_mem (U := {1}·∂ú)\n        (compl_mem_ae_iff.mpr (subsingleton_singleton.measure_zero _)) (fun x hx _ ‚Ü¶ ?_))\n    rw [indicator_of_not_mem hx, add_zero]\n  _ = ‚à´ (x : ‚Ñù) in Ioc 0 1, (x : ‚ÑÇ) ^ (s - 1) ‚Ä¢ (P.f‚ÇÄ - (P.Œµ * ‚Üë(x ^ (-P.k))) ‚Ä¢ P.g‚ÇÄ) := by\n    simp_rw [‚Üê indicator_smul, setIntegral_indicator measurableSet_Ioo,\n      inter_eq_right.mpr Ioo_subset_Ioi_self, integral_Ioc_eq_integral_Ioo]\n  _ = ‚à´ x : ‚Ñù in Ioc 0 1, ((x : ‚ÑÇ) ^ (s - 1) ‚Ä¢ P.f‚ÇÄ - P.Œµ ‚Ä¢ (x : ‚ÑÇ) ^ (s - P.k - 1) ‚Ä¢ P.g‚ÇÄ) := by\n    refine setIntegral_congr_fun measurableSet_Ioc (fun x ‚ü®hx, _‚ü© ‚Ü¶ ?_)\n    rw [ofReal_cpow hx.le, ofReal_neg, smul_sub, ‚Üê mul_smul, mul_comm, mul_assoc, mul_smul,\n      mul_comm, ‚Üê cpow_add _ _ (ofReal_ne_zero.mpr hx.ne'), ‚Üê sub_eq_add_neg, sub_right_comm]\n  _ = (‚à´ (x : ‚Ñù) in Ioc 0 1, (x : ‚ÑÇ) ^ (s - 1)) ‚Ä¢ P.f‚ÇÄ\n        - P.Œµ ‚Ä¢ (‚à´ (x : ‚Ñù) in Ioc 0 1, (x : ‚ÑÇ) ^ (s - P.k - 1)) ‚Ä¢ P.g‚ÇÄ := by\n    rw [integral_sub, integral_smul, integral_smul_const, integral_smul_const]\n    ¬∑ apply Integrable.smul_const\n      rw [‚Üê IntegrableOn, ‚Üê intervalIntegrable_iff_integrableOn_Ioc_of_le zero_le_one]\n      exact intervalIntegral.intervalIntegrable_cpow' h_re1\n    ¬∑ refine (Integrable.smul_const ?_ _).smul _\n      rw [‚Üê IntegrableOn, ‚Üê intervalIntegrable_iff_integrableOn_Ioc_of_le zero_le_one]\n      exact intervalIntegral.intervalIntegrable_cpow' h_re2\n  _ = _ := by simp_rw [‚Üê intervalIntegral.integral_of_le zero_le_one,\n      integral_cpow (Or.inl h_re1), integral_cpow (Or.inl h_re2), ofReal_zero, ofReal_one,\n      one_cpow, sub_add_cancel, zero_cpow fun h ‚Ü¶ lt_irrefl _ (P.hk.le.trans_lt (zero_re ‚ñ∏ h ‚ñ∏ hs)),\n      zero_cpow (sub_ne_zero.mpr (fun h ‚Ü¶ lt_irrefl _ ((ofReal_re _) ‚ñ∏ h ‚ñ∏ hs)) : s - P.k ‚â† 0),\n      sub_zero, sub_eq_add_neg (_ ‚Ä¢  _), ‚Üê mul_smul, ‚Üê neg_smul, mul_one_div, ‚Üê div_neg, neg_sub]\n\n"}
{"name":"WeakFEPair.Œõ‚ÇÄ_eq","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nP : WeakFEPair E\ns : Complex\n‚ä¢ Eq (P.Œõ‚ÇÄ s) (HAdd.hAdd (HAdd.hAdd (P.Œõ s) (HSMul.hSMul (HDiv.hDiv 1 s) P.f‚ÇÄ)) (HSMul.hSMul (HDiv.hDiv P.Œµ (HSub.hSub (‚ÜëP.k) s)) P.g‚ÇÄ))","decl":"lemma Œõ‚ÇÄ_eq (s : ‚ÑÇ) : P.Œõ‚ÇÄ s = P.Œõ s + (1 / s) ‚Ä¢ P.f‚ÇÄ + (P.Œµ / (P.k - s)) ‚Ä¢ P.g‚ÇÄ := by\n  unfold Œõ Œõ‚ÇÄ\n  abel\n\n"}
{"name":"WeakFEPair.symm_Œõ‚ÇÄ_eq","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nP : WeakFEPair E\ns : Complex\n‚ä¢ Eq (P.symm.Œõ‚ÇÄ s) (HAdd.hAdd (HAdd.hAdd (P.symm.Œõ s) (HSMul.hSMul (HDiv.hDiv 1 s) P.g‚ÇÄ)) (HSMul.hSMul (HDiv.hDiv (Inv.inv P.Œµ) (HSub.hSub (‚ÜëP.k) s)) P.f‚ÇÄ))","decl":"lemma symm_Œõ‚ÇÄ_eq (s : ‚ÑÇ) :\n    P.symm.Œõ‚ÇÄ s = P.symm.Œõ s + (1 / s) ‚Ä¢ P.g‚ÇÄ + (P.Œµ‚Åª¬π / (P.k - s)) ‚Ä¢ P.f‚ÇÄ := by\n  rw [P.symm.Œõ‚ÇÄ_eq]\n  rfl\n\n"}
{"name":"WeakFEPair.differentiable_Œõ‚ÇÄ","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nP : WeakFEPair E\n‚ä¢ Differentiable Complex P.Œõ‚ÇÄ","decl":"theorem differentiable_Œõ‚ÇÄ : Differentiable ‚ÑÇ P.Œõ‚ÇÄ := P.toStrongFEPair.differentiable_Œõ\n\n"}
{"name":"WeakFEPair.differentiableAt_Œõ","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nP : WeakFEPair E\ns : Complex\nhs : Or (Ne s 0) (Eq P.f‚ÇÄ 0)\nhs' : Or (Ne s ‚ÜëP.k) (Eq P.g‚ÇÄ 0)\n‚ä¢ DifferentiableAt Complex P.Œõ s","decl":"theorem differentiableAt_Œõ {s : ‚ÑÇ} (hs : s ‚â† 0 ‚à® P.f‚ÇÄ = 0) (hs' : s ‚â† P.k ‚à® P.g‚ÇÄ = 0) :\n    DifferentiableAt ‚ÑÇ P.Œõ s := by\n  refine ((P.differentiable_Œõ‚ÇÄ s).sub ?_).sub ?_\n  ¬∑ rcases hs with hs | hs\n    ¬∑ simpa using (differentiableAt_inv hs).smul_const _\n    ¬∑ simp [hs]\n  ¬∑ rcases hs' with hs' | hs'\n    ¬∑ apply DifferentiableAt.smul_const\n      apply (differentiableAt_const _).div ((differentiableAt_const _).sub (differentiable_id _))\n      simpa [sub_eq_zero, eq_comm]\n    ¬∑ simp [hs']\n\n"}
{"name":"WeakFEPair.hasMellin","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Complex E\nP : WeakFEPair E\ninst‚úù : CompleteSpace E\ns : Complex\nhs : LT.lt P.k s.re\n‚ä¢ HasMellin (fun x => HSub.hSub (P.f x) P.f‚ÇÄ) s (P.Œõ s)","decl":"/-- Relation between `Œõ s` and the Mellin transform of `f - f‚ÇÄ`, where the latter is defined. -/\ntheorem hasMellin [CompleteSpace E]\n    {s : ‚ÑÇ} (hs : P.k < s.re) : HasMellin (P.f ¬∑ - P.f‚ÇÄ) s (P.Œõ s) := by\n  have hc1 : MellinConvergent (P.f ¬∑ - P.f‚ÇÄ) s :=\n    let ‚ü®_, ht‚ü© := exists_gt s.re\n    mellinConvergent_of_isBigO_rpow (P.hf_int.sub (locallyIntegrableOn_const _)) (P.hf_top _) ht\n      P.hf_zero' hs\n  refine ‚ü®hc1, ?_‚ü©\n  have hc2 : HasMellin P.f_modif s (P.Œõ‚ÇÄ s) := P.toStrongFEPair.hasMellin s\n  have hc3 : mellin (fun x ‚Ü¶ f_modif P x - f P x + P.f‚ÇÄ) s =\n    (1 / s) ‚Ä¢ P.f‚ÇÄ + (P.Œµ / (‚ÜëP.k - s)) ‚Ä¢ P.g‚ÇÄ := P.f_modif_aux2 hs\n  have := (hasMellin_sub hc2.1 hc1).2\n  simp_rw [‚Üê sub_add, hc3, eq_sub_iff_add_eq, ‚Üê eq_sub_iff_add_eq', ‚Üê sub_sub] at this\n  exact this\n\n"}
{"name":"WeakFEPair.functional_equation‚ÇÄ","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nP : WeakFEPair E\ns : Complex\n‚ä¢ Eq (P.Œõ‚ÇÄ (HSub.hSub (‚ÜëP.k) s)) (HSMul.hSMul P.Œµ (P.symm.Œõ‚ÇÄ s))","decl":"/-- Functional equation formulated for `Œõ‚ÇÄ`. -/\ntheorem functional_equation‚ÇÄ (s : ‚ÑÇ) : P.Œõ‚ÇÄ (P.k - s) = P.Œµ ‚Ä¢ P.symm.Œõ‚ÇÄ s :=\n  P.toStrongFEPair.functional_equation s\n\n"}
{"name":"WeakFEPair.functional_equation","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nP : WeakFEPair E\ns : Complex\n‚ä¢ Eq (P.Œõ (HSub.hSub (‚ÜëP.k) s)) (HSMul.hSMul P.Œµ (P.symm.Œõ s))","decl":"/-- Functional equation formulated for `Œõ`. -/\ntheorem functional_equation (s : ‚ÑÇ) :\n    P.Œõ (P.k - s) = P.Œµ ‚Ä¢ P.symm.Œõ s := by\n  linear_combination (norm := module) P.functional_equation‚ÇÄ s - P.Œõ‚ÇÄ_eq (P.k - s)\n    + congr(P.Œµ ‚Ä¢ $(P.symm_Œõ‚ÇÄ_eq s)) + congr(($(mul_inv_cancel‚ÇÄ P.hŒµ) / ((P.k:‚ÑÇ) - s)) ‚Ä¢ P.f‚ÇÄ)\n\n"}
{"name":"WeakFEPair.Œõ_residue_k","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nP : WeakFEPair E\n‚ä¢ Filter.Tendsto (fun s => HSMul.hSMul (HSub.hSub s ‚ÜëP.k) (P.Œõ s)) (nhdsWithin (‚ÜëP.k) (HasCompl.compl (Singleton.singleton ‚ÜëP.k))) (nhds (HSMul.hSMul P.Œµ P.g‚ÇÄ))","decl":"/-- The residue of `Œõ` at `s = k` is equal to `Œµ ‚Ä¢ g‚ÇÄ`. -/\ntheorem Œõ_residue_k :\n    Tendsto (fun s : ‚ÑÇ ‚Ü¶ (s - P.k) ‚Ä¢ P.Œõ s) (ùìù[‚â†] P.k) (ùìù (P.Œµ ‚Ä¢ P.g‚ÇÄ)) := by\n  simp_rw [Œõ, smul_sub, (by simp : ùìù (P.Œµ ‚Ä¢ P.g‚ÇÄ) = ùìù (0 - 0 - -P.Œµ ‚Ä¢ P.g‚ÇÄ))]\n  refine ((Tendsto.sub ?_ ?_).mono_left nhdsWithin_le_nhds).sub ?_\n  ¬∑ rw [(by rw [sub_self, zero_smul] : ùìù 0 = ùìù ((P.k - P.k : ‚ÑÇ) ‚Ä¢ P.Œõ‚ÇÄ P.k))]\n    apply ((continuous_sub_right _).smul P.differentiable_Œõ‚ÇÄ.continuous).tendsto\n  ¬∑ rw [(by rw [sub_self, zero_smul] : ùìù 0 = ùìù ((P.k - P.k : ‚ÑÇ) ‚Ä¢ (1 / P.k : ‚ÑÇ) ‚Ä¢ P.f‚ÇÄ))]\n    refine (continuous_sub_right _).continuousAt.smul (ContinuousAt.smul ?_ continuousAt_const)\n    exact continuousAt_const.div continuousAt_id (ofReal_ne_zero.mpr P.hk.ne')\n  ¬∑ refine (tendsto_const_nhds.mono_left nhdsWithin_le_nhds).congr' ?_\n    refine eventually_nhdsWithin_of_forall (fun s (hs : s ‚â† P.k) ‚Ü¶ ?_)\n    match_scalars\n    field_simp [sub_ne_zero.mpr hs.symm]\n    ring\n\n"}
{"name":"WeakFEPair.Œõ_residue_zero","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nP : WeakFEPair E\n‚ä¢ Filter.Tendsto (fun s => HSMul.hSMul s (P.Œõ s)) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) (nhds (Neg.neg P.f‚ÇÄ))","decl":"/-- The residue of `Œõ` at `s = 0` is equal to `-f‚ÇÄ`. -/\ntheorem Œõ_residue_zero :\n    Tendsto (fun s : ‚ÑÇ ‚Ü¶ s ‚Ä¢ P.Œõ s) (ùìù[‚â†] 0) (ùìù (-P.f‚ÇÄ)) := by\n  simp_rw [Œõ, smul_sub, (by simp : ùìù (-P.f‚ÇÄ) = ùìù (((0 : ‚ÑÇ) ‚Ä¢ P.Œõ‚ÇÄ 0) - P.f‚ÇÄ - 0))]\n  refine ((Tendsto.mono_left ?_ nhdsWithin_le_nhds).sub ?_).sub ?_\n  ¬∑ exact (continuous_id.smul P.differentiable_Œõ‚ÇÄ.continuous).tendsto _\n  ¬∑ refine (tendsto_const_nhds.mono_left nhdsWithin_le_nhds).congr' ?_\n    refine eventually_nhdsWithin_of_forall (fun s (hs : s ‚â† 0) ‚Ü¶ ?_)\n    match_scalars\n    field_simp [sub_ne_zero.mpr hs.symm]\n  ¬∑ rw [show ùìù 0 = ùìù ((0 : ‚ÑÇ) ‚Ä¢ (P.Œµ / (P.k - 0 : ‚ÑÇ)) ‚Ä¢ P.g‚ÇÄ) by rw [zero_smul]]\n    exact (continuousAt_id.smul ((continuousAt_const.div ((continuous_sub_left _).continuousAt)\n      (by simpa using P.hk.ne')).smul continuousAt_const)).mono_left nhdsWithin_le_nhds\n\n"}
