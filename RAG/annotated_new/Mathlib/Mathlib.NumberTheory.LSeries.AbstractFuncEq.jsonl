{"name":"WeakFEPair.mk.injEq","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf✝ g✝ : Real → E\nk✝ : Real\nε✝ : Complex\nf₀✝ g₀✝ : E\nhf_int✝ : MeasureTheory.LocallyIntegrableOn f✝ (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhg_int✝ : MeasureTheory.LocallyIntegrableOn g✝ (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhk✝ : LT.lt 0 k✝\nhε✝ : Ne ε✝ 0\nh_feq✝ : ∀ (x : Real), Membership.mem (Set.Ioi 0) x → Eq (f✝ (HDiv.hDiv 1 x)) (HSMul.hSMul (HMul.hMul ε✝ ↑(HPow.hPow x k✝)) (g✝ x))\nhf_top✝ : ∀ (r : Real), Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (f✝ x) f₀✝) fun x => HPow.hPow x r\nhg_top✝ : ∀ (r : Real), Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (g✝ x) g₀✝) fun x => HPow.hPow x r\nf g : Real → E\nk : Real\nε : Complex\nf₀ g₀ : E\nhf_int : MeasureTheory.LocallyIntegrableOn f (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhg_int : MeasureTheory.LocallyIntegrableOn g (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhk : LT.lt 0 k\nhε : Ne ε 0\nh_feq : ∀ (x : Real), Membership.mem (Set.Ioi 0) x → Eq (f (HDiv.hDiv 1 x)) (HSMul.hSMul (HMul.hMul ε ↑(HPow.hPow x k)) (g x))\nhf_top : ∀ (r : Real), Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (f x) f₀) fun x => HPow.hPow x r\nhg_top : ∀ (r : Real), Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (g x) g₀) fun x => HPow.hPow x r\n⊢ Eq (Eq { f := f✝, g := g✝, k := k✝, ε := ε✝, f₀ := f₀✝, g₀ := g₀✝, hf_int := hf_int✝, hg_int := hg_int✝, hk := hk✝, hε := hε✝, h_feq := h_feq✝, hf_top := hf_top✝, hg_top := hg_top✝ } { f := f, g := g, k := k, ε := ε, f₀ := f₀, g₀ := g₀, hf_int := hf_int, hg_int := hg_int, hk := hk, hε := hε, h_feq := h_feq, hf_top := hf_top, hg_top := hg_top }) (And (Eq f✝ f) (And (Eq g✝ g) (And (Eq k✝ k) (And (Eq ε✝ ε) (And (Eq f₀✝ f₀) (Eq g₀✝ g₀))))))","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(most general version: rapid decay at `∞` up to constant terms) -/\nstructure WeakFEPair where\n  /-- The functions whose Mellin transform we study -/\n  (f g : ℝ → E)\n  /-- Weight (exponent in the functional equation) -/\n  (k : ℝ)\n  /-- Root number -/\n  (ε : ℂ)\n  /-- Constant terms at `∞` -/\n  (f₀ g₀ : E)\n  (hf_int : LocallyIntegrableOn f (Ioi 0))\n  (hg_int : LocallyIntegrableOn g (Ioi 0))\n  (hk : 0 < k)\n  (hε : ε ≠ 0)\n  (h_feq : ∀ x ∈ Ioi 0, f (1 / x) = (ε * ↑(x ^ k)) • g x)\n  (hf_top (r : ℝ) : (f · - f₀) =O[atTop] (· ^ r))\n  (hg_top (r : ℝ) : (g · - g₀) =O[atTop] (· ^ r))\n\n"}
{"name":"WeakFEPair.hg_int","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nself : WeakFEPair E\n⊢ MeasureTheory.LocallyIntegrableOn self.g (Set.Ioi 0) MeasureTheory.MeasureSpace.volume","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(most general version: rapid decay at `∞` up to constant terms) -/\nstructure WeakFEPair where\n  /-- The functions whose Mellin transform we study -/\n  (f g : ℝ → E)\n  /-- Weight (exponent in the functional equation) -/\n  (k : ℝ)\n  /-- Root number -/\n  (ε : ℂ)\n  /-- Constant terms at `∞` -/\n  (f₀ g₀ : E)\n  (hf_int : LocallyIntegrableOn f (Ioi 0))\n  (hg_int : LocallyIntegrableOn g (Ioi 0))\n  (hk : 0 < k)\n  (hε : ε ≠ 0)\n  (h_feq : ∀ x ∈ Ioi 0, f (1 / x) = (ε * ↑(x ^ k)) • g x)\n  (hf_top (r : ℝ) : (f · - f₀) =O[atTop] (· ^ r))\n  (hg_top (r : ℝ) : (g · - g₀) =O[atTop] (· ^ r))\n\n"}
{"name":"WeakFEPair.h_feq","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nself : WeakFEPair E\nx : Real\na✝ : Membership.mem (Set.Ioi 0) x\n⊢ Eq (self.f (HDiv.hDiv 1 x)) (HSMul.hSMul (HMul.hMul self.ε ↑(HPow.hPow x self.k)) (self.g x))","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(most general version: rapid decay at `∞` up to constant terms) -/\nstructure WeakFEPair where\n  /-- The functions whose Mellin transform we study -/\n  (f g : ℝ → E)\n  /-- Weight (exponent in the functional equation) -/\n  (k : ℝ)\n  /-- Root number -/\n  (ε : ℂ)\n  /-- Constant terms at `∞` -/\n  (f₀ g₀ : E)\n  (hf_int : LocallyIntegrableOn f (Ioi 0))\n  (hg_int : LocallyIntegrableOn g (Ioi 0))\n  (hk : 0 < k)\n  (hε : ε ≠ 0)\n  (h_feq : ∀ x ∈ Ioi 0, f (1 / x) = (ε * ↑(x ^ k)) • g x)\n  (hf_top (r : ℝ) : (f · - f₀) =O[atTop] (· ^ r))\n  (hg_top (r : ℝ) : (g · - g₀) =O[atTop] (· ^ r))\n\n"}
{"name":"WeakFEPair.hg_top","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nself : WeakFEPair E\nr : Real\n⊢ Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (self.g x) self.g₀) fun x => HPow.hPow x r","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(most general version: rapid decay at `∞` up to constant terms) -/\nstructure WeakFEPair where\n  /-- The functions whose Mellin transform we study -/\n  (f g : ℝ → E)\n  /-- Weight (exponent in the functional equation) -/\n  (k : ℝ)\n  /-- Root number -/\n  (ε : ℂ)\n  /-- Constant terms at `∞` -/\n  (f₀ g₀ : E)\n  (hf_int : LocallyIntegrableOn f (Ioi 0))\n  (hg_int : LocallyIntegrableOn g (Ioi 0))\n  (hk : 0 < k)\n  (hε : ε ≠ 0)\n  (h_feq : ∀ x ∈ Ioi 0, f (1 / x) = (ε * ↑(x ^ k)) • g x)\n  (hf_top (r : ℝ) : (f · - f₀) =O[atTop] (· ^ r))\n  (hg_top (r : ℝ) : (g · - g₀) =O[atTop] (· ^ r))\n\n"}
{"name":"WeakFEPair.hε","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nself : WeakFEPair E\n⊢ Ne self.ε 0","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(most general version: rapid decay at `∞` up to constant terms) -/\nstructure WeakFEPair where\n  /-- The functions whose Mellin transform we study -/\n  (f g : ℝ → E)\n  /-- Weight (exponent in the functional equation) -/\n  (k : ℝ)\n  /-- Root number -/\n  (ε : ℂ)\n  /-- Constant terms at `∞` -/\n  (f₀ g₀ : E)\n  (hf_int : LocallyIntegrableOn f (Ioi 0))\n  (hg_int : LocallyIntegrableOn g (Ioi 0))\n  (hk : 0 < k)\n  (hε : ε ≠ 0)\n  (h_feq : ∀ x ∈ Ioi 0, f (1 / x) = (ε * ↑(x ^ k)) • g x)\n  (hf_top (r : ℝ) : (f · - f₀) =O[atTop] (· ^ r))\n  (hg_top (r : ℝ) : (g · - g₀) =O[atTop] (· ^ r))\n\n"}
{"name":"WeakFEPair.hk","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nself : WeakFEPair E\n⊢ LT.lt 0 self.k","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(most general version: rapid decay at `∞` up to constant terms) -/\nstructure WeakFEPair where\n  /-- The functions whose Mellin transform we study -/\n  (f g : ℝ → E)\n  /-- Weight (exponent in the functional equation) -/\n  (k : ℝ)\n  /-- Root number -/\n  (ε : ℂ)\n  /-- Constant terms at `∞` -/\n  (f₀ g₀ : E)\n  (hf_int : LocallyIntegrableOn f (Ioi 0))\n  (hg_int : LocallyIntegrableOn g (Ioi 0))\n  (hk : 0 < k)\n  (hε : ε ≠ 0)\n  (h_feq : ∀ x ∈ Ioi 0, f (1 / x) = (ε * ↑(x ^ k)) • g x)\n  (hf_top (r : ℝ) : (f · - f₀) =O[atTop] (· ^ r))\n  (hg_top (r : ℝ) : (g · - g₀) =O[atTop] (· ^ r))\n\n"}
{"name":"WeakFEPair.hf_top","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nself : WeakFEPair E\nr : Real\n⊢ Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (self.f x) self.f₀) fun x => HPow.hPow x r","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(most general version: rapid decay at `∞` up to constant terms) -/\nstructure WeakFEPair where\n  /-- The functions whose Mellin transform we study -/\n  (f g : ℝ → E)\n  /-- Weight (exponent in the functional equation) -/\n  (k : ℝ)\n  /-- Root number -/\n  (ε : ℂ)\n  /-- Constant terms at `∞` -/\n  (f₀ g₀ : E)\n  (hf_int : LocallyIntegrableOn f (Ioi 0))\n  (hg_int : LocallyIntegrableOn g (Ioi 0))\n  (hk : 0 < k)\n  (hε : ε ≠ 0)\n  (h_feq : ∀ x ∈ Ioi 0, f (1 / x) = (ε * ↑(x ^ k)) • g x)\n  (hf_top (r : ℝ) : (f · - f₀) =O[atTop] (· ^ r))\n  (hg_top (r : ℝ) : (g · - g₀) =O[atTop] (· ^ r))\n\n"}
{"name":"WeakFEPair.mk.sizeOf_spec","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : SizeOf E\nf g : Real → E\nk : Real\nε : Complex\nf₀ g₀ : E\nhf_int : MeasureTheory.LocallyIntegrableOn f (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhg_int : MeasureTheory.LocallyIntegrableOn g (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhk : LT.lt 0 k\nhε : Ne ε 0\nh_feq : ∀ (x : Real), Membership.mem (Set.Ioi 0) x → Eq (f (HDiv.hDiv 1 x)) (HSMul.hSMul (HMul.hMul ε ↑(HPow.hPow x k)) (g x))\nhf_top : ∀ (r : Real), Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (f x) f₀) fun x => HPow.hPow x r\nhg_top : ∀ (r : Real), Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (g x) g₀) fun x => HPow.hPow x r\n⊢ Eq (SizeOf.sizeOf { f := f, g := g, k := k, ε := ε, f₀ := f₀, g₀ := g₀, hf_int := hf_int, hg_int := hg_int, hk := hk, hε := hε, h_feq := h_feq, hf_top := hf_top, hg_top := hg_top }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf k)) (SizeOf.sizeOf ε)) (SizeOf.sizeOf f₀)) (SizeOf.sizeOf g₀)) (SizeOf.sizeOf hk))","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(most general version: rapid decay at `∞` up to constant terms) -/\nstructure WeakFEPair where\n  /-- The functions whose Mellin transform we study -/\n  (f g : ℝ → E)\n  /-- Weight (exponent in the functional equation) -/\n  (k : ℝ)\n  /-- Root number -/\n  (ε : ℂ)\n  /-- Constant terms at `∞` -/\n  (f₀ g₀ : E)\n  (hf_int : LocallyIntegrableOn f (Ioi 0))\n  (hg_int : LocallyIntegrableOn g (Ioi 0))\n  (hk : 0 < k)\n  (hε : ε ≠ 0)\n  (h_feq : ∀ x ∈ Ioi 0, f (1 / x) = (ε * ↑(x ^ k)) • g x)\n  (hf_top (r : ℝ) : (f · - f₀) =O[atTop] (· ^ r))\n  (hg_top (r : ℝ) : (g · - g₀) =O[atTop] (· ^ r))\n\n"}
{"name":"WeakFEPair.hf_int","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nself : WeakFEPair E\n⊢ MeasureTheory.LocallyIntegrableOn self.f (Set.Ioi 0) MeasureTheory.MeasureSpace.volume","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(most general version: rapid decay at `∞` up to constant terms) -/\nstructure WeakFEPair where\n  /-- The functions whose Mellin transform we study -/\n  (f g : ℝ → E)\n  /-- Weight (exponent in the functional equation) -/\n  (k : ℝ)\n  /-- Root number -/\n  (ε : ℂ)\n  /-- Constant terms at `∞` -/\n  (f₀ g₀ : E)\n  (hf_int : LocallyIntegrableOn f (Ioi 0))\n  (hg_int : LocallyIntegrableOn g (Ioi 0))\n  (hk : 0 < k)\n  (hε : ε ≠ 0)\n  (h_feq : ∀ x ∈ Ioi 0, f (1 / x) = (ε * ↑(x ^ k)) • g x)\n  (hf_top (r : ℝ) : (f · - f₀) =O[atTop] (· ^ r))\n  (hg_top (r : ℝ) : (g · - g₀) =O[atTop] (· ^ r))\n\n"}
{"name":"WeakFEPair.mk.inj","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf✝ g✝ : Real → E\nk✝ : Real\nε✝ : Complex\nf₀✝ g₀✝ : E\nhf_int✝ : MeasureTheory.LocallyIntegrableOn f✝ (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhg_int✝ : MeasureTheory.LocallyIntegrableOn g✝ (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhk✝ : LT.lt 0 k✝\nhε✝ : Ne ε✝ 0\nh_feq✝ : ∀ (x : Real), Membership.mem (Set.Ioi 0) x → Eq (f✝ (HDiv.hDiv 1 x)) (HSMul.hSMul (HMul.hMul ε✝ ↑(HPow.hPow x k✝)) (g✝ x))\nhf_top✝ : ∀ (r : Real), Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (f✝ x) f₀✝) fun x => HPow.hPow x r\nhg_top✝ : ∀ (r : Real), Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (g✝ x) g₀✝) fun x => HPow.hPow x r\nf g : Real → E\nk : Real\nε : Complex\nf₀ g₀ : E\nhf_int : MeasureTheory.LocallyIntegrableOn f (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhg_int : MeasureTheory.LocallyIntegrableOn g (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhk : LT.lt 0 k\nhε : Ne ε 0\nh_feq : ∀ (x : Real), Membership.mem (Set.Ioi 0) x → Eq (f (HDiv.hDiv 1 x)) (HSMul.hSMul (HMul.hMul ε ↑(HPow.hPow x k)) (g x))\nhf_top : ∀ (r : Real), Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (f x) f₀) fun x => HPow.hPow x r\nhg_top : ∀ (r : Real), Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (g x) g₀) fun x => HPow.hPow x r\nx✝ : Eq { f := f✝, g := g✝, k := k✝, ε := ε✝, f₀ := f₀✝, g₀ := g₀✝, hf_int := hf_int✝, hg_int := hg_int✝, hk := hk✝, hε := hε✝, h_feq := h_feq✝, hf_top := hf_top✝, hg_top := hg_top✝ } { f := f, g := g, k := k, ε := ε, f₀ := f₀, g₀ := g₀, hf_int := hf_int, hg_int := hg_int, hk := hk, hε := hε, h_feq := h_feq, hf_top := hf_top, hg_top := hg_top }\n⊢ And (Eq f✝ f) (And (Eq g✝ g) (And (Eq k✝ k) (And (Eq ε✝ ε) (And (Eq f₀✝ f₀) (Eq g₀✝ g₀)))))","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(most general version: rapid decay at `∞` up to constant terms) -/\nstructure WeakFEPair where\n  /-- The functions whose Mellin transform we study -/\n  (f g : ℝ → E)\n  /-- Weight (exponent in the functional equation) -/\n  (k : ℝ)\n  /-- Root number -/\n  (ε : ℂ)\n  /-- Constant terms at `∞` -/\n  (f₀ g₀ : E)\n  (hf_int : LocallyIntegrableOn f (Ioi 0))\n  (hg_int : LocallyIntegrableOn g (Ioi 0))\n  (hk : 0 < k)\n  (hε : ε ≠ 0)\n  (h_feq : ∀ x ∈ Ioi 0, f (1 / x) = (ε * ↑(x ^ k)) • g x)\n  (hf_top (r : ℝ) : (f · - f₀) =O[atTop] (· ^ r))\n  (hg_top (r : ℝ) : (g · - g₀) =O[atTop] (· ^ r))\n\n"}
{"name":"StrongFEPair.mk.inj","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\ntoWeakFEPair✝ : WeakFEPair E\nhf₀✝ : Eq toWeakFEPair✝.f₀ 0\nhg₀✝ : Eq toWeakFEPair✝.g₀ 0\ntoWeakFEPair : WeakFEPair E\nhf₀ : Eq toWeakFEPair.f₀ 0\nhg₀ : Eq toWeakFEPair.g₀ 0\nx✝ : Eq { toWeakFEPair := toWeakFEPair✝, hf₀ := hf₀✝, hg₀ := hg₀✝ } { toWeakFEPair := toWeakFEPair, hf₀ := hf₀, hg₀ := hg₀ }\n⊢ Eq toWeakFEPair✝ toWeakFEPair","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(version without constant terms) -/\nstructure StrongFEPair extends WeakFEPair E where (hf₀ : f₀ = 0) (hg₀ : g₀ = 0)\n\n"}
{"name":"StrongFEPair.mk.sizeOf_spec","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : SizeOf E\ntoWeakFEPair : WeakFEPair E\nhf₀ : Eq toWeakFEPair.f₀ 0\nhg₀ : Eq toWeakFEPair.g₀ 0\n⊢ Eq (SizeOf.sizeOf { toWeakFEPair := toWeakFEPair, hf₀ := hf₀, hg₀ := hg₀ }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toWeakFEPair)) (SizeOf.sizeOf hf₀)) (SizeOf.sizeOf hg₀))","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(version without constant terms) -/\nstructure StrongFEPair extends WeakFEPair E where (hf₀ : f₀ = 0) (hg₀ : g₀ = 0)\n\n"}
{"name":"StrongFEPair.hg₀","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nself : StrongFEPair E\n⊢ Eq self.g₀ 0","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(version without constant terms) -/\nstructure StrongFEPair extends WeakFEPair E where (hf₀ : f₀ = 0) (hg₀ : g₀ = 0)\n\n"}
{"name":"StrongFEPair.hf₀","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nself : StrongFEPair E\n⊢ Eq self.f₀ 0","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(version without constant terms) -/\nstructure StrongFEPair extends WeakFEPair E where (hf₀ : f₀ = 0) (hg₀ : g₀ = 0)\n\n"}
{"name":"StrongFEPair.mk.injEq","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\ntoWeakFEPair✝ : WeakFEPair E\nhf₀✝ : Eq toWeakFEPair✝.f₀ 0\nhg₀✝ : Eq toWeakFEPair✝.g₀ 0\ntoWeakFEPair : WeakFEPair E\nhf₀ : Eq toWeakFEPair.f₀ 0\nhg₀ : Eq toWeakFEPair.g₀ 0\n⊢ Eq (Eq { toWeakFEPair := toWeakFEPair✝, hf₀ := hf₀✝, hg₀ := hg₀✝ } { toWeakFEPair := toWeakFEPair, hf₀ := hf₀, hg₀ := hg₀ }) (Eq toWeakFEPair✝ toWeakFEPair)","decl":"/-- A structure designed to hold the hypotheses for the Mellin-functional-equation argument\n(version without constant terms) -/\nstructure StrongFEPair extends WeakFEPair E where (hf₀ : f₀ = 0) (hg₀ : g₀ = 0)\n\n"}
{"name":"WeakFEPair.h_feq'","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nP : WeakFEPair E\nx : Real\nhx : LT.lt 0 x\n⊢ Eq (P.g (HDiv.hDiv 1 x)) (HSMul.hSMul (HMul.hMul (Inv.inv P.ε) ↑(HPow.hPow x P.k)) (P.f x))","decl":"/-- Reformulated functional equation with `f` and `g` interchanged. -/\nlemma WeakFEPair.h_feq' (P : WeakFEPair E) (x : ℝ) (hx : 0 < x) :\n    P.g (1 / x) = (P.ε⁻¹ * ↑(x ^ P.k)) • P.f x := by\n  rw [(div_div_cancel₀ (one_ne_zero' ℝ) ▸ P.h_feq (1 / x) (one_div_pos.mpr hx):), ← mul_smul]\n  convert (one_smul ℂ (P.g (1 / x))).symm using 2\n  rw [one_div, inv_rpow hx.le, ofReal_inv]\n  field_simp [P.hε, (rpow_pos_of_pos hx _).ne']\n\n"}
{"name":"WeakFEPair.hf_zero","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nP : WeakFEPair E\nr : Real\n⊢ Asymptotics.IsBigO (nhdsWithin 0 (Set.Ioi 0)) (fun x => HSub.hSub (P.f x) (HSMul.hSMul (HMul.hMul P.ε ↑(HPow.hPow x (Neg.neg P.k))) P.g₀)) fun x => HPow.hPow x r","decl":"/-- As `x → 0`, we have `f x = x ^ (-P.k) • constant` up to a rapidly decaying error. -/\nlemma hf_zero (P : WeakFEPair E) (r : ℝ) :\n    (fun x ↦ P.f x - (P.ε * ↑(x ^ (-P.k))) • P.g₀) =O[𝓝[>] 0] (· ^ r) := by\n  have := (P.hg_top (-(r + P.k))).comp_tendsto tendsto_inv_nhdsGT_zero\n  simp_rw [IsBigO, IsBigOWith, eventually_nhdsWithin_iff] at this ⊢\n  obtain ⟨C, hC⟩ := this\n  use ‖P.ε‖ * C\n  filter_upwards [hC] with x hC' (hx : 0 < x)\n  have h_nv2 : ↑(x ^ P.k) ≠ (0 : ℂ) := ofReal_ne_zero.mpr (rpow_pos_of_pos hx _).ne'\n  have h_nv : P.ε⁻¹ * ↑(x ^ P.k) ≠ 0 := mul_ne_zero P.symm.hε h_nv2\n  specialize hC' hx\n  simp_rw [Function.comp_apply, ← one_div, P.h_feq' _ hx] at hC'\n  rw [← ((mul_inv_cancel₀ h_nv).symm ▸ one_smul ℂ P.g₀ :), mul_smul _ _ P.g₀, ← smul_sub, norm_smul,\n    ← le_div_iff₀' (lt_of_le_of_ne (norm_nonneg _) (norm_ne_zero_iff.mpr h_nv).symm)] at hC'\n  convert hC' using 1\n  · congr 3\n    rw [rpow_neg hx.le]\n    field_simp\n  · simp_rw [norm_mul, norm_real, one_div, inv_rpow hx.le, rpow_neg hx.le, inv_inv, norm_inv,\n      norm_of_nonneg (rpow_pos_of_pos hx _).le, rpow_add hx]\n    field_simp\n    ring\n\n"}
{"name":"WeakFEPair.hf_zero'","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nP : WeakFEPair E\n⊢ Asymptotics.IsBigO (nhdsWithin 0 (Set.Ioi 0)) (fun x => HSub.hSub (P.f x) P.f₀) fun x => HPow.hPow x (Neg.neg P.k)","decl":"/-- Power asymptotic for `f - f₀` as `x → 0`. -/\nlemma hf_zero' (P : WeakFEPair E) :\n    (fun x : ℝ ↦ P.f x - P.f₀) =O[𝓝[>] 0] (· ^ (-P.k)) := by\n  simp_rw [← fun x ↦ sub_add_sub_cancel (P.f x) ((P.ε * ↑(x ^ (-P.k))) • P.g₀) P.f₀]\n  refine (P.hf_zero _).add (IsBigO.sub ?_ ?_)\n  · rw [← isBigO_norm_norm]\n    simp_rw [mul_smul, norm_smul, mul_comm _ ‖P.g₀‖, ← mul_assoc, norm_real]\n    apply (isBigO_refl _ _).const_mul_left\n  · refine IsBigO.of_bound ‖P.f₀‖ (eventually_nhdsWithin_iff.mpr ?_)\n    filter_upwards [eventually_le_nhds zero_lt_one] with x hx' (hx : 0 < x)\n    apply le_mul_of_one_le_right (norm_nonneg _)\n    rw [norm_of_nonneg (rpow_pos_of_pos hx _).le, rpow_neg hx.le]\n    exact (one_le_inv₀ (rpow_pos_of_pos hx _)).2 (rpow_le_one hx.le hx' P.hk.le)\n\n"}
{"name":"StrongFEPair.hf_top'","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nP : StrongFEPair E\nr : Real\n⊢ Asymptotics.IsBigO Filter.atTop P.f fun x => HPow.hPow x r","decl":"/-- As `x → ∞`, `f x` decays faster than any power of `x`. -/\nlemma hf_top' (r : ℝ) : P.f =O[atTop] (· ^ r) := by\n  simpa [P.hf₀] using P.hf_top r\n\n"}
{"name":"StrongFEPair.hf_zero'","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nP : StrongFEPair E\nr : Real\n⊢ Asymptotics.IsBigO (nhdsWithin 0 (Set.Ioi 0)) P.f fun x => HPow.hPow x r","decl":"/-- As `x → 0`, `f x` decays faster than any power of `x`. -/\nlemma hf_zero' (r : ℝ) : P.f =O[𝓝[>] 0] (· ^ r) := by\n  simpa using (P.hg₀ ▸ P.hf_zero r :)\n\n"}
{"name":"StrongFEPair.hasMellin","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nP : StrongFEPair E\ns : Complex\n⊢ HasMellin P.f s (P.Λ s)","decl":"/-- The Mellin transform of `f` is well-defined and equal to `P.Λ s`, for all `s`. -/\ntheorem hasMellin (s : ℂ) : HasMellin P.f s (P.Λ s) :=\n  let ⟨_, ht⟩ := exists_gt s.re\n  let ⟨_, hu⟩ := exists_lt s.re\n  ⟨mellinConvergent_of_isBigO_rpow P.hf_int (P.hf_top' _) ht (P.hf_zero' _) hu, rfl⟩\n\n"}
{"name":"StrongFEPair.Λ_eq","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nP : StrongFEPair E\n⊢ Eq P.Λ (mellin P.f)","decl":"lemma Λ_eq : P.Λ = mellin P.f := rfl\n\n"}
{"name":"StrongFEPair.symm_Λ_eq","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nP : StrongFEPair E\n⊢ Eq P.symm.Λ (mellin P.g)","decl":"lemma symm_Λ_eq : P.symm.Λ = mellin P.g := rfl\n\n"}
{"name":"StrongFEPair.differentiable_Λ","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nP : StrongFEPair E\n⊢ Differentiable Complex P.Λ","decl":"/-- If `(f, g)` are a strong FE pair, then the Mellin transform of `f` is entire. -/\ntheorem differentiable_Λ : Differentiable ℂ P.Λ := fun s ↦\n  let ⟨_, ht⟩ := exists_gt s.re\n  let ⟨_, hu⟩ := exists_lt s.re\n  mellin_differentiableAt_of_isBigO_rpow P.hf_int (P.hf_top' _) ht (P.hf_zero' _) hu\n\n"}
{"name":"StrongFEPair.functional_equation","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nP : StrongFEPair E\ns : Complex\n⊢ Eq (P.Λ (HSub.hSub (↑P.k) s)) (HSMul.hSMul P.ε (P.symm.Λ s))","decl":"/-- Main theorem about strong FE pairs: if `(f, g)` are a strong FE pair, then the Mellin\ntransforms of `f` and `g` are related by `s ↦ k - s`.\n\nThis is proved by making a substitution `t ↦ t⁻¹` in the Mellin transform integral. -/\ntheorem functional_equation (s : ℂ) :\n    P.Λ (P.k - s) = P.ε • P.symm.Λ s := by\n  -- unfold definition:\n  rw [P.Λ_eq, P.symm_Λ_eq]\n  -- substitute `t ↦ t⁻¹` in `mellin P.g s`\n  have step1 := mellin_comp_rpow P.g (-s) (-1)\n  simp_rw [abs_neg, abs_one, inv_one, one_smul, ofReal_neg, ofReal_one, div_neg, div_one, neg_neg,\n    rpow_neg_one, ← one_div] at step1\n  -- introduce a power of `t` to match the hypothesis `P.h_feq`\n  have step2 := mellin_cpow_smul (fun t ↦ P.g (1 / t)) (P.k - s) (-P.k)\n  rw [← sub_eq_add_neg, sub_right_comm, sub_self, zero_sub, step1] at step2\n  -- put in the constant `P.ε`\n  have step3 := mellin_const_smul (fun t ↦ (t : ℂ) ^ (-P.k : ℂ) • P.g (1 / t)) (P.k - s) P.ε\n  rw [step2] at step3\n  rw [← step3]\n  -- now the integrand matches `P.h_feq'` on `Ioi 0`, so we can apply `setIntegral_congr_fun`\n  refine setIntegral_congr_fun measurableSet_Ioi (fun t ht ↦ ?_)\n  simp_rw [P.h_feq' t ht, ← mul_smul]\n  -- some simple `cpow` arithmetic to finish\n  rw [cpow_neg, ofReal_cpow (le_of_lt ht)]\n  have : (t : ℂ) ^ (P.k : ℂ) ≠ 0 := by simpa [← ofReal_cpow ht.le] using (rpow_pos_of_pos ht _).ne'\n  field_simp [P.hε]\n\n"}
{"name":"WeakFEPair.hf_modif_int","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nP : WeakFEPair E\n⊢ MeasureTheory.LocallyIntegrableOn P.f_modif (Set.Ioi 0) MeasureTheory.MeasureSpace.volume","decl":"lemma hf_modif_int :\n    LocallyIntegrableOn P.f_modif (Ioi 0) := by\n  have : LocallyIntegrableOn (fun x : ℝ ↦ (P.ε * ↑(x ^ (-P.k))) • P.g₀) (Ioi 0) := by\n    refine ContinuousOn.locallyIntegrableOn ?_ measurableSet_Ioi\n    refine continuousOn_of_forall_continuousAt (fun x (hx : 0 < x) ↦ ?_)\n    refine (continuousAt_const.mul ?_).smul continuousAt_const\n    exact continuous_ofReal.continuousAt.comp (continuousAt_rpow_const _ _ (Or.inl hx.ne'))\n  refine LocallyIntegrableOn.add (fun x hx ↦ ?_) (fun x hx ↦ ?_)\n  · obtain ⟨s, hs, hs'⟩ := P.hf_int.sub (locallyIntegrableOn_const _) x hx\n    refine ⟨s, hs, ?_⟩\n    rw [IntegrableOn, integrable_indicator_iff measurableSet_Ioi, IntegrableOn,\n      Measure.restrict_restrict measurableSet_Ioi, ← IntegrableOn]\n    exact hs'.mono_set Set.inter_subset_right\n  · obtain ⟨s, hs, hs'⟩ := P.hf_int.sub this x hx\n    refine ⟨s, hs, ?_⟩\n    rw [IntegrableOn, integrable_indicator_iff measurableSet_Ioo, IntegrableOn,\n      Measure.restrict_restrict measurableSet_Ioo, ← IntegrableOn]\n    exact hs'.mono_set Set.inter_subset_right\n\n"}
{"name":"WeakFEPair.hf_modif_FE","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nP : WeakFEPair E\nx : Real\nhx : LT.lt 0 x\n⊢ Eq (P.f_modif (HDiv.hDiv 1 x)) (HSMul.hSMul (HMul.hMul P.ε ↑(HPow.hPow x P.k)) (P.g_modif x))","decl":"lemma hf_modif_FE (x : ℝ) (hx : 0 < x) :\n    P.f_modif (1 / x) = (P.ε * ↑(x ^ P.k)) • P.g_modif x := by\n  rcases lt_trichotomy 1 x with hx' | rfl | hx'\n  · have : 1 / x < 1 := by rwa [one_div_lt hx one_pos, div_one]\n    rw [f_modif, Pi.add_apply, indicator_of_not_mem (not_mem_Ioi.mpr this.le),\n      zero_add, indicator_of_mem (mem_Ioo.mpr ⟨div_pos one_pos hx, this⟩), g_modif, Pi.add_apply,\n      indicator_of_mem (mem_Ioi.mpr hx'), indicator_of_not_mem\n      (not_mem_Ioo_of_ge hx'.le), add_zero, P.h_feq _ hx, smul_sub]\n    simp_rw [rpow_neg (one_div_pos.mpr hx).le, one_div, inv_rpow hx.le, inv_inv]\n  · simp [f_modif, g_modif]\n  · have : 1 < 1 / x := by rwa [lt_one_div one_pos hx, div_one]\n    rw [f_modif, Pi.add_apply, indicator_of_mem (mem_Ioi.mpr this),\n      indicator_of_not_mem (not_mem_Ioo_of_ge this.le), add_zero, g_modif, Pi.add_apply,\n      indicator_of_not_mem (not_mem_Ioi.mpr hx'.le),\n      indicator_of_mem (mem_Ioo.mpr ⟨hx, hx'⟩), zero_add, P.h_feq _ hx, smul_sub]\n    simp_rw [rpow_neg hx.le, ← mul_smul]\n    field_simp [(rpow_pos_of_pos hx P.k).ne', P.hε]\n\n"}
{"name":"WeakFEPair.f_modif_aux1","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nP : WeakFEPair E\n⊢ Set.EqOn (fun x => HAdd.hAdd (HSub.hSub (P.f_modif x) (P.f x)) P.f₀) (HAdd.hAdd ((Set.Ioo 0 1).indicator fun x => HSub.hSub P.f₀ (HSMul.hSMul (HMul.hMul P.ε ↑(HPow.hPow x (Neg.neg P.k))) P.g₀)) ((Singleton.singleton 1).indicator fun x => HSub.hSub P.f₀ (P.f 1))) (Set.Ioi 0)","decl":"lemma f_modif_aux1 : EqOn (fun x ↦ P.f_modif x - P.f x + P.f₀)\n    ((Ioo 0 1).indicator (fun x : ℝ ↦ P.f₀ - (P.ε * ↑(x ^ (-P.k))) • P.g₀)\n    + ({1} : Set ℝ).indicator (fun _ ↦ P.f₀ - P.f 1)) (Ioi 0) := by\n  intro x (hx : 0 < x)\n  simp_rw [f_modif, Pi.add_apply]\n  rcases lt_trichotomy x 1 with hx' | rfl | hx'\n  · simp_rw [indicator_of_not_mem (not_mem_Ioi.mpr hx'.le),\n      indicator_of_mem (mem_Ioo.mpr ⟨hx, hx'⟩),\n      indicator_of_not_mem (mem_singleton_iff.not.mpr hx'.ne)]\n    abel\n  · simp [add_comm, sub_eq_add_neg]\n  · simp_rw [indicator_of_mem (mem_Ioi.mpr hx'),\n      indicator_of_not_mem (not_mem_Ioo_of_ge hx'.le),\n      indicator_of_not_mem (mem_singleton_iff.not.mpr hx'.ne')]\n    abel\n\n"}
{"name":"WeakFEPair.f_modif_aux2","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\nP : WeakFEPair E\ninst✝ : CompleteSpace E\ns : Complex\nhs : LT.lt P.k s.re\n⊢ Eq (mellin (fun x => HAdd.hAdd (HSub.hSub (P.f_modif x) (P.f x)) P.f₀) s) (HAdd.hAdd (HSMul.hSMul (HDiv.hDiv 1 s) P.f₀) (HSMul.hSMul (HDiv.hDiv P.ε (HSub.hSub (↑P.k) s)) P.g₀))","decl":"/-- Compute the Mellin transform of the modifying term used to kill off the constants at\n`0` and `∞`. -/\nlemma f_modif_aux2 [CompleteSpace E] {s : ℂ} (hs : P.k < re s) :\n    mellin (fun x ↦ P.f_modif x - P.f x + P.f₀) s = (1 / s) • P.f₀ + (P.ε  / (P.k - s)) • P.g₀ := by\n  have h_re1 : -1 < re (s - 1) := by simpa using P.hk.trans hs\n  have h_re2 : -1 < re (s - P.k - 1) := by simpa using hs\n  calc\n  _ = ∫ (x : ℝ) in Ioi 0, (x : ℂ) ^ (s - 1) •\n      ((Ioo 0 1).indicator (fun t : ℝ ↦ P.f₀ - (P.ε * ↑(t ^ (-P.k))) • P.g₀) x\n      + ({1} : Set ℝ).indicator (fun _ ↦ P.f₀ - P.f 1) x) :=\n    setIntegral_congr_fun measurableSet_Ioi (fun x hx ↦ by simp [f_modif_aux1 P hx])\n  _ = ∫ (x : ℝ) in Ioi 0, (x : ℂ) ^ (s - 1) • ((Ioo 0 1).indicator\n      (fun t : ℝ ↦ P.f₀ - (P.ε * ↑(t ^ (-P.k))) • P.g₀) x) := by\n    refine setIntegral_congr_ae measurableSet_Ioi (eventually_of_mem (U := {1}ᶜ)\n        (compl_mem_ae_iff.mpr (subsingleton_singleton.measure_zero _)) (fun x hx _ ↦ ?_))\n    rw [indicator_of_not_mem hx, add_zero]\n  _ = ∫ (x : ℝ) in Ioc 0 1, (x : ℂ) ^ (s - 1) • (P.f₀ - (P.ε * ↑(x ^ (-P.k))) • P.g₀) := by\n    simp_rw [← indicator_smul, setIntegral_indicator measurableSet_Ioo,\n      inter_eq_right.mpr Ioo_subset_Ioi_self, integral_Ioc_eq_integral_Ioo]\n  _ = ∫ x : ℝ in Ioc 0 1, ((x : ℂ) ^ (s - 1) • P.f₀ - P.ε • (x : ℂ) ^ (s - P.k - 1) • P.g₀) := by\n    refine setIntegral_congr_fun measurableSet_Ioc (fun x ⟨hx, _⟩ ↦ ?_)\n    rw [ofReal_cpow hx.le, ofReal_neg, smul_sub, ← mul_smul, mul_comm, mul_assoc, mul_smul,\n      mul_comm, ← cpow_add _ _ (ofReal_ne_zero.mpr hx.ne'), ← sub_eq_add_neg, sub_right_comm]\n  _ = (∫ (x : ℝ) in Ioc 0 1, (x : ℂ) ^ (s - 1)) • P.f₀\n        - P.ε • (∫ (x : ℝ) in Ioc 0 1, (x : ℂ) ^ (s - P.k - 1)) • P.g₀ := by\n    rw [integral_sub, integral_smul, integral_smul_const, integral_smul_const]\n    · apply Integrable.smul_const\n      rw [← IntegrableOn, ← intervalIntegrable_iff_integrableOn_Ioc_of_le zero_le_one]\n      exact intervalIntegral.intervalIntegrable_cpow' h_re1\n    · refine (Integrable.smul_const ?_ _).smul _\n      rw [← IntegrableOn, ← intervalIntegrable_iff_integrableOn_Ioc_of_le zero_le_one]\n      exact intervalIntegral.intervalIntegrable_cpow' h_re2\n  _ = _ := by simp_rw [← intervalIntegral.integral_of_le zero_le_one,\n      integral_cpow (Or.inl h_re1), integral_cpow (Or.inl h_re2), ofReal_zero, ofReal_one,\n      one_cpow, sub_add_cancel, zero_cpow fun h ↦ lt_irrefl _ (P.hk.le.trans_lt (zero_re ▸ h ▸ hs)),\n      zero_cpow (sub_ne_zero.mpr (fun h ↦ lt_irrefl _ ((ofReal_re _) ▸ h ▸ hs)) : s - P.k ≠ 0),\n      sub_zero, sub_eq_add_neg (_ •  _), ← mul_smul, ← neg_smul, mul_one_div, ← div_neg, neg_sub]\n\n"}
{"name":"WeakFEPair.Λ₀_eq","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nP : WeakFEPair E\ns : Complex\n⊢ Eq (P.Λ₀ s) (HAdd.hAdd (HAdd.hAdd (P.Λ s) (HSMul.hSMul (HDiv.hDiv 1 s) P.f₀)) (HSMul.hSMul (HDiv.hDiv P.ε (HSub.hSub (↑P.k) s)) P.g₀))","decl":"lemma Λ₀_eq (s : ℂ) : P.Λ₀ s = P.Λ s + (1 / s) • P.f₀ + (P.ε / (P.k - s)) • P.g₀ := by\n  unfold Λ Λ₀\n  abel\n\n"}
{"name":"WeakFEPair.symm_Λ₀_eq","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nP : WeakFEPair E\ns : Complex\n⊢ Eq (P.symm.Λ₀ s) (HAdd.hAdd (HAdd.hAdd (P.symm.Λ s) (HSMul.hSMul (HDiv.hDiv 1 s) P.g₀)) (HSMul.hSMul (HDiv.hDiv (Inv.inv P.ε) (HSub.hSub (↑P.k) s)) P.f₀))","decl":"lemma symm_Λ₀_eq (s : ℂ) :\n    P.symm.Λ₀ s = P.symm.Λ s + (1 / s) • P.g₀ + (P.ε⁻¹ / (P.k - s)) • P.f₀ := by\n  rw [P.symm.Λ₀_eq]\n  rfl\n\n"}
{"name":"WeakFEPair.differentiable_Λ₀","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nP : WeakFEPair E\n⊢ Differentiable Complex P.Λ₀","decl":"theorem differentiable_Λ₀ : Differentiable ℂ P.Λ₀ := P.toStrongFEPair.differentiable_Λ\n\n"}
{"name":"WeakFEPair.differentiableAt_Λ","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nP : WeakFEPair E\ns : Complex\nhs : Or (Ne s 0) (Eq P.f₀ 0)\nhs' : Or (Ne s ↑P.k) (Eq P.g₀ 0)\n⊢ DifferentiableAt Complex P.Λ s","decl":"theorem differentiableAt_Λ {s : ℂ} (hs : s ≠ 0 ∨ P.f₀ = 0) (hs' : s ≠ P.k ∨ P.g₀ = 0) :\n    DifferentiableAt ℂ P.Λ s := by\n  refine ((P.differentiable_Λ₀ s).sub ?_).sub ?_\n  · rcases hs with hs | hs\n    · simpa using (differentiableAt_inv hs).smul_const _\n    · simp [hs]\n  · rcases hs' with hs' | hs'\n    · apply DifferentiableAt.smul_const\n      apply (differentiableAt_const _).div ((differentiableAt_const _).sub (differentiable_id _))\n      simpa [sub_eq_zero, eq_comm]\n    · simp [hs']\n\n"}
{"name":"WeakFEPair.hasMellin","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\nP : WeakFEPair E\ninst✝ : CompleteSpace E\ns : Complex\nhs : LT.lt P.k s.re\n⊢ HasMellin (fun x => HSub.hSub (P.f x) P.f₀) s (P.Λ s)","decl":"/-- Relation between `Λ s` and the Mellin transform of `f - f₀`, where the latter is defined. -/\ntheorem hasMellin [CompleteSpace E]\n    {s : ℂ} (hs : P.k < s.re) : HasMellin (P.f · - P.f₀) s (P.Λ s) := by\n  have hc1 : MellinConvergent (P.f · - P.f₀) s :=\n    let ⟨_, ht⟩ := exists_gt s.re\n    mellinConvergent_of_isBigO_rpow (P.hf_int.sub (locallyIntegrableOn_const _)) (P.hf_top _) ht\n      P.hf_zero' hs\n  refine ⟨hc1, ?_⟩\n  have hc2 : HasMellin P.f_modif s (P.Λ₀ s) := P.toStrongFEPair.hasMellin s\n  have hc3 : mellin (fun x ↦ f_modif P x - f P x + P.f₀) s =\n    (1 / s) • P.f₀ + (P.ε / (↑P.k - s)) • P.g₀ := P.f_modif_aux2 hs\n  have := (hasMellin_sub hc2.1 hc1).2\n  simp_rw [← sub_add, hc3, eq_sub_iff_add_eq, ← eq_sub_iff_add_eq', ← sub_sub] at this\n  exact this\n\n"}
{"name":"WeakFEPair.functional_equation₀","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nP : WeakFEPair E\ns : Complex\n⊢ Eq (P.Λ₀ (HSub.hSub (↑P.k) s)) (HSMul.hSMul P.ε (P.symm.Λ₀ s))","decl":"/-- Functional equation formulated for `Λ₀`. -/\ntheorem functional_equation₀ (s : ℂ) : P.Λ₀ (P.k - s) = P.ε • P.symm.Λ₀ s :=\n  P.toStrongFEPair.functional_equation s\n\n"}
{"name":"WeakFEPair.functional_equation","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nP : WeakFEPair E\ns : Complex\n⊢ Eq (P.Λ (HSub.hSub (↑P.k) s)) (HSMul.hSMul P.ε (P.symm.Λ s))","decl":"/-- Functional equation formulated for `Λ`. -/\ntheorem functional_equation (s : ℂ) :\n    P.Λ (P.k - s) = P.ε • P.symm.Λ s := by\n  linear_combination (norm := module) P.functional_equation₀ s - P.Λ₀_eq (P.k - s)\n    + congr(P.ε • $(P.symm_Λ₀_eq s)) + congr(($(mul_inv_cancel₀ P.hε) / ((P.k:ℂ) - s)) • P.f₀)\n\n"}
{"name":"WeakFEPair.Λ_residue_k","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nP : WeakFEPair E\n⊢ Filter.Tendsto (fun s => HSMul.hSMul (HSub.hSub s ↑P.k) (P.Λ s)) (nhdsWithin (↑P.k) (HasCompl.compl (Singleton.singleton ↑P.k))) (nhds (HSMul.hSMul P.ε P.g₀))","decl":"/-- The residue of `Λ` at `s = k` is equal to `ε • g₀`. -/\ntheorem Λ_residue_k :\n    Tendsto (fun s : ℂ ↦ (s - P.k) • P.Λ s) (𝓝[≠] P.k) (𝓝 (P.ε • P.g₀)) := by\n  simp_rw [Λ, smul_sub, (by simp : 𝓝 (P.ε • P.g₀) = 𝓝 (0 - 0 - -P.ε • P.g₀))]\n  refine ((Tendsto.sub ?_ ?_).mono_left nhdsWithin_le_nhds).sub ?_\n  · rw [(by rw [sub_self, zero_smul] : 𝓝 0 = 𝓝 ((P.k - P.k : ℂ) • P.Λ₀ P.k))]\n    apply ((continuous_sub_right _).smul P.differentiable_Λ₀.continuous).tendsto\n  · rw [(by rw [sub_self, zero_smul] : 𝓝 0 = 𝓝 ((P.k - P.k : ℂ) • (1 / P.k : ℂ) • P.f₀))]\n    refine (continuous_sub_right _).continuousAt.smul (ContinuousAt.smul ?_ continuousAt_const)\n    exact continuousAt_const.div continuousAt_id (ofReal_ne_zero.mpr P.hk.ne')\n  · refine (tendsto_const_nhds.mono_left nhdsWithin_le_nhds).congr' ?_\n    refine eventually_nhdsWithin_of_forall (fun s (hs : s ≠ P.k) ↦ ?_)\n    match_scalars\n    field_simp [sub_ne_zero.mpr hs.symm]\n    ring\n\n"}
{"name":"WeakFEPair.Λ_residue_zero","module":"Mathlib.NumberTheory.LSeries.AbstractFuncEq","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nP : WeakFEPair E\n⊢ Filter.Tendsto (fun s => HSMul.hSMul s (P.Λ s)) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) (nhds (Neg.neg P.f₀))","decl":"/-- The residue of `Λ` at `s = 0` is equal to `-f₀`. -/\ntheorem Λ_residue_zero :\n    Tendsto (fun s : ℂ ↦ s • P.Λ s) (𝓝[≠] 0) (𝓝 (-P.f₀)) := by\n  simp_rw [Λ, smul_sub, (by simp : 𝓝 (-P.f₀) = 𝓝 (((0 : ℂ) • P.Λ₀ 0) - P.f₀ - 0))]\n  refine ((Tendsto.mono_left ?_ nhdsWithin_le_nhds).sub ?_).sub ?_\n  · exact (continuous_id.smul P.differentiable_Λ₀.continuous).tendsto _\n  · refine (tendsto_const_nhds.mono_left nhdsWithin_le_nhds).congr' ?_\n    refine eventually_nhdsWithin_of_forall (fun s (hs : s ≠ 0) ↦ ?_)\n    match_scalars\n    field_simp [sub_ne_zero.mpr hs.symm]\n  · rw [show 𝓝 0 = 𝓝 ((0 : ℂ) • (P.ε / (P.k - 0 : ℂ)) • P.g₀) by rw [zero_smul]]\n    exact (continuousAt_id.smul ((continuousAt_const.div ((continuous_sub_left _).continuousAt)\n      (by simpa using P.hk.ne')).smul continuousAt_const)).mono_left nhdsWithin_le_nhds\n\n"}
