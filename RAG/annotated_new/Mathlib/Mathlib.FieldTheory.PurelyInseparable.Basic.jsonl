{"name":"IsPurelyInseparable.inseparable'","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : CommRing F\ninst✝¹ : Ring E\ninst✝ : Algebra F E\nself : IsPurelyInseparable F E\nx : E\na✝ : IsSeparable F x\n⊢ Membership.mem (algebraMap F E).range x","decl":"/-- Typeclass for purely inseparable field extensions: an algebraic extension `E / F` is purely\ninseparable if and only if the minimal polynomial of every element of `E ∖ F` is not separable.\n\nWe define this for general (commutative) rings and only assume `F` and `E` are fields\nif this is needed for a proof. -/\nclass IsPurelyInseparable : Prop where\n  isIntegral : Algebra.IsIntegral F E\n  inseparable' (x : E) : IsSeparable F x → x ∈ (algebraMap F E).range\n\n"}
{"name":"IsPurelyInseparable.isIntegral","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : CommRing F\ninst✝¹ : Ring E\ninst✝ : Algebra F E\nself : IsPurelyInseparable F E\n⊢ Algebra.IsIntegral F E","decl":"/-- Typeclass for purely inseparable field extensions: an algebraic extension `E / F` is purely\ninseparable if and only if the minimal polynomial of every element of `E ∖ F` is not separable.\n\nWe define this for general (commutative) rings and only assume `F` and `E` are fields\nif this is needed for a proof. -/\nclass IsPurelyInseparable : Prop where\n  isIntegral : Algebra.IsIntegral F E\n  inseparable' (x : E) : IsSeparable F x → x ∈ (algebraMap F E).range\n\n"}
{"name":"IsPurelyInseparable.isIntegral'","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝³ : CommRing F\ninst✝² : Ring E\ninst✝¹ : Algebra F E\ninst✝ : IsPurelyInseparable F E\nx : E\n⊢ IsIntegral F x","decl":"variable {E} in\ntheorem IsPurelyInseparable.isIntegral' [IsPurelyInseparable F E] (x : E) : IsIntegral F x :=\n  Algebra.IsIntegral.isIntegral _\n\n"}
{"name":"IsPurelyInseparable.isAlgebraic","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁴ : CommRing F\ninst✝³ : Ring E\ninst✝² : Algebra F E\ninst✝¹ : Nontrivial F\ninst✝ : IsPurelyInseparable F E\n⊢ Algebra.IsAlgebraic F E","decl":"theorem IsPurelyInseparable.isAlgebraic [Nontrivial F] [IsPurelyInseparable F E] :\n    Algebra.IsAlgebraic F E := inferInstance\n\n"}
{"name":"IsPurelyInseparable.inseparable","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝³ : CommRing F\ninst✝² : Ring E\ninst✝¹ : Algebra F E\ninst✝ : IsPurelyInseparable F E\nx : E\na✝ : IsSeparable F x\n⊢ Membership.mem (algebraMap F E).range x","decl":"theorem IsPurelyInseparable.inseparable [IsPurelyInseparable F E] :\n    ∀ x : E, IsSeparable F x → x ∈ (algebraMap F E).range :=\n  IsPurelyInseparable.inseparable'\n\n"}
{"name":"isPurelyInseparable_iff","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : CommRing F\ninst✝¹ : Ring E\ninst✝ : Algebra F E\n⊢ Iff (IsPurelyInseparable F E) (∀ (x : E), And (IsIntegral F x) (IsSeparable F x → Membership.mem (algebraMap F E).range x))","decl":"theorem isPurelyInseparable_iff : IsPurelyInseparable F E ↔ ∀ x : E,\n    IsIntegral F x ∧ (IsSeparable F x → x ∈ (algebraMap F E).range) :=\n  ⟨fun h x ↦ ⟨h.isIntegral' _ x, h.inseparable' x⟩, fun h ↦ ⟨⟨fun x ↦ (h x).1⟩, fun x ↦ (h x).2⟩⟩\n\n"}
{"name":"AlgEquiv.isPurelyInseparable","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁵ : CommRing F\ninst✝⁴ : Ring E\ninst✝³ : Algebra F E\nK : Type u_3\ninst✝² : Ring K\ninst✝¹ : Algebra F K\ne : AlgEquiv F K E\ninst✝ : IsPurelyInseparable F K\n⊢ IsPurelyInseparable F E","decl":"/-- Transfer `IsPurelyInseparable` across an `AlgEquiv`. -/\ntheorem AlgEquiv.isPurelyInseparable (e : K ≃ₐ[F] E) [IsPurelyInseparable F K] :\n    IsPurelyInseparable F E := by\n  refine ⟨⟨fun _ ↦ by rw [← isIntegral_algEquiv e.symm]; exact IsPurelyInseparable.isIntegral' F _⟩,\n    fun x h ↦ ?_⟩\n  rw [IsSeparable, ← minpoly.algEquiv_eq e.symm] at h\n  simpa only [RingHom.mem_range, algebraMap_eq_apply] using IsPurelyInseparable.inseparable F _ h\n\n"}
{"name":"AlgEquiv.isPurelyInseparable_iff","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁴ : CommRing F\ninst✝³ : Ring E\ninst✝² : Algebra F E\nK : Type u_3\ninst✝¹ : Ring K\ninst✝ : Algebra F K\ne : AlgEquiv F K E\n⊢ Iff (IsPurelyInseparable F K) (IsPurelyInseparable F E)","decl":"theorem AlgEquiv.isPurelyInseparable_iff (e : K ≃ₐ[F] E) :\n    IsPurelyInseparable F K ↔ IsPurelyInseparable F E :=\n  ⟨fun _ ↦ e.isPurelyInseparable, fun _ ↦ e.symm.isPurelyInseparable⟩\n\n"}
{"name":"Algebra.IsAlgebraic.isPurelyInseparable_of_isSepClosed","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝⁵ : Field F\ninst✝⁴ : Ring E\ninst✝³ : IsDomain E\ninst✝² : Algebra F E\ninst✝¹ : Algebra.IsAlgebraic F E\ninst✝ : IsSepClosed F\n⊢ IsPurelyInseparable F E","decl":"/-- If `E / F` is an algebraic extension, `F` is separably closed,\nthen `E / F` is purely inseparable. -/\ninstance Algebra.IsAlgebraic.isPurelyInseparable_of_isSepClosed\n    {F : Type u} {E : Type v} [Field F] [Ring E] [IsDomain E] [Algebra F E]\n    [Algebra.IsAlgebraic F E] [IsSepClosed F] : IsPurelyInseparable F E :=\n  ⟨inferInstance, fun x h ↦ minpoly.mem_range_of_degree_eq_one F x <|\n    IsSepClosed.degree_eq_one_of_irreducible F (minpoly.irreducible\n      (Algebra.IsIntegral.isIntegral _)) h⟩\n\n"}
{"name":"IsPurelyInseparable.surjective_algebraMap_of_isSeparable","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁴ : CommRing F\ninst✝³ : Ring E\ninst✝² : Algebra F E\ninst✝¹ : IsPurelyInseparable F E\ninst✝ : Algebra.IsSeparable F E\n⊢ Function.Surjective ⇑(algebraMap F E)","decl":"/-- If `E / F` is both purely inseparable and separable, then `algebraMap F E` is surjective. -/\ntheorem IsPurelyInseparable.surjective_algebraMap_of_isSeparable\n    [IsPurelyInseparable F E] [Algebra.IsSeparable F E] : Function.Surjective (algebraMap F E) :=\n  fun x ↦ IsPurelyInseparable.inseparable F x (Algebra.IsSeparable.isSeparable F x)\n\n"}
{"name":"IsPurelyInseparable.bijective_algebraMap_of_isSeparable","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁶ : CommRing F\ninst✝⁵ : Ring E\ninst✝⁴ : Algebra F E\ninst✝³ : Nontrivial E\ninst✝² : NoZeroSMulDivisors F E\ninst✝¹ : IsPurelyInseparable F E\ninst✝ : Algebra.IsSeparable F E\n⊢ Function.Bijective ⇑(algebraMap F E)","decl":"/-- If `E / F` is both purely inseparable and separable, then `algebraMap F E` is bijective. -/\ntheorem IsPurelyInseparable.bijective_algebraMap_of_isSeparable\n    [Nontrivial E] [NoZeroSMulDivisors F E]\n    [IsPurelyInseparable F E] [Algebra.IsSeparable F E] : Function.Bijective (algebraMap F E) :=\n  ⟨NoZeroSMulDivisors.algebraMap_injective F E, surjective_algebraMap_of_isSeparable F E⟩\n\n"}
{"name":"Subalgebra.eq_bot_of_isPurelyInseparable_of_isSeparable","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁴ : CommRing F\ninst✝³ : Ring E\ninst✝² : Algebra F E\nL : Subalgebra F E\ninst✝¹ : IsPurelyInseparable F (Subtype fun x => Membership.mem L x)\ninst✝ : Algebra.IsSeparable F (Subtype fun x => Membership.mem L x)\n⊢ Eq L Bot.bot","decl":"variable {F E} in\n/-- If a subalgebra of `E / F` is both purely inseparable and separable, then it is equal\nto `F`. -/\ntheorem Subalgebra.eq_bot_of_isPurelyInseparable_of_isSeparable (L : Subalgebra F E)\n    [IsPurelyInseparable F L] [Algebra.IsSeparable F L] : L = ⊥ := bot_unique fun x hx ↦ by\n  obtain ⟨y, hy⟩ := IsPurelyInseparable.surjective_algebraMap_of_isSeparable F L ⟨x, hx⟩\n  exact ⟨y, congr_arg (Subalgebra.val _) hy⟩\n\n"}
{"name":"IntermediateField.eq_bot_of_isPurelyInseparable_of_isSeparable","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nL : IntermediateField F E\ninst✝¹ : IsPurelyInseparable F (Subtype fun x => Membership.mem L x)\ninst✝ : Algebra.IsSeparable F (Subtype fun x => Membership.mem L x)\n⊢ Eq L Bot.bot","decl":"/-- If an intermediate field of `E / F` is both purely inseparable and separable, then it is equal\nto `F`. -/\ntheorem IntermediateField.eq_bot_of_isPurelyInseparable_of_isSeparable\n    {F : Type u} {E : Type v} [Field F] [Field E] [Algebra F E] (L : IntermediateField F E)\n    [IsPurelyInseparable F L] [Algebra.IsSeparable F L] : L = ⊥ := bot_unique fun x hx ↦ by\n  obtain ⟨y, hy⟩ := IsPurelyInseparable.surjective_algebraMap_of_isSeparable F L ⟨x, hx⟩\n  exact ⟨y, congr_arg (algebraMap L E) hy⟩\n\n"}
{"name":"separableClosure.eq_bot_of_isPurelyInseparable","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : IsPurelyInseparable F E\n⊢ Eq (separableClosure F E) Bot.bot","decl":"/-- If `E / F` is purely inseparable, then the separable closure of `F` in `E` is\nequal to `F`. -/\ntheorem separableClosure.eq_bot_of_isPurelyInseparable\n    (F : Type u) (E : Type v) [Field F] [Field E] [Algebra F E] [IsPurelyInseparable F E] :\n    separableClosure F E = ⊥ :=\n  bot_unique fun x h ↦ IsPurelyInseparable.inseparable F x (mem_separableClosure_iff.1 h)\n\n"}
{"name":"separableClosure.eq_bot_iff","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.IsAlgebraic F E\n⊢ Iff (Eq (separableClosure F E) Bot.bot) (IsPurelyInseparable F E)","decl":"/-- If `E / F` is an algebraic extension, then the separable closure of `F` in `E` is\nequal to `F` if and only if `E / F` is purely inseparable. -/\ntheorem separableClosure.eq_bot_iff\n    {F : Type u} {E : Type v} [Field F] [Field E] [Algebra F E] [Algebra.IsAlgebraic F E] :\n    separableClosure F E = ⊥ ↔ IsPurelyInseparable F E :=\n  ⟨fun h ↦ isPurelyInseparable_iff.2 fun x ↦ ⟨Algebra.IsIntegral.isIntegral x, fun hs ↦ by\n    simpa only [h] using mem_separableClosure_iff.2 hs⟩, fun _ ↦ eq_bot_of_isPurelyInseparable F E⟩\n\n"}
{"name":"isPurelyInseparable_self","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u_1\ninst✝ : CommRing F\n⊢ IsPurelyInseparable F F","decl":"instance isPurelyInseparable_self : IsPurelyInseparable F F :=\n  ⟨inferInstance, fun x _ ↦ ⟨x, rfl⟩⟩\n\n"}
{"name":"isPurelyInseparable_iff_pow_mem","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Ring E\ninst✝² : IsDomain E\ninst✝¹ : Algebra F E\nq : Nat\ninst✝ : ExpChar F q\n⊢ Iff (IsPurelyInseparable F E) (∀ (x : E), Exists fun n => Membership.mem (algebraMap F E).range (HPow.hPow x (HPow.hPow q n)))","decl":"/-- A field extension `E / F` of exponential characteristic `q` is purely inseparable\nif and only if for every element `x` of `E`, there exists a natural number `n` such that\n`x ^ (q ^ n)` is contained in `F`. -/\n@[stacks 09HE]\ntheorem isPurelyInseparable_iff_pow_mem :\n    IsPurelyInseparable F E ↔ ∀ x : E, ∃ n : ℕ, x ^ q ^ n ∈ (algebraMap F E).range := by\n  rw [isPurelyInseparable_iff]\n  refine ⟨fun h x ↦ ?_, fun h x ↦ ?_⟩\n  · obtain ⟨g, h1, n, h2⟩ := (minpoly.irreducible (h x).1).hasSeparableContraction q\n    exact ⟨n, (h _).2 <| h1.of_dvd <| minpoly.dvd F _ <| by\n      simpa only [expand_aeval, minpoly.aeval] using congr_arg (aeval x) h2⟩\n  have hdeg := (minpoly.natSepDegree_eq_one_iff_pow_mem q).2 (h x)\n  have halg : IsIntegral F x := by_contra fun h' ↦ by\n    simp only [minpoly.eq_zero h', natSepDegree_zero, zero_ne_one] at hdeg\n  refine ⟨halg, fun hsep ↦ ?_⟩\n  rwa [hsep.natSepDegree_eq_natDegree, minpoly.natDegree_eq_one_iff] at hdeg\n\n"}
{"name":"IsPurelyInseparable.pow_mem","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝⁵ : Field F\ninst✝⁴ : Ring E\ninst✝³ : IsDomain E\ninst✝² : Algebra F E\nq : Nat\ninst✝¹ : ExpChar F q\nx : E\ninst✝ : IsPurelyInseparable F E\n⊢ Exists fun n => Membership.mem (algebraMap F E).range (HPow.hPow x (HPow.hPow q n))","decl":"theorem IsPurelyInseparable.pow_mem [IsPurelyInseparable F E] :\n    ∃ n : ℕ, x ^ q ^ n ∈ (algebraMap F E).range :=\n  (isPurelyInseparable_iff_pow_mem F q).1 ‹_› x\n\n"}
{"name":"IsPurelyInseparable.tower_bot","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝⁷ : Field F\ninst✝⁶ : Field E\ninst✝⁵ : Algebra F E\nK : Type w\ninst✝⁴ : Field K\ninst✝³ : Algebra F K\ninst✝² : Algebra E K\ninst✝¹ : IsScalarTower F E K\ninst✝ : IsPurelyInseparable F K\n⊢ IsPurelyInseparable F E","decl":"/-- If `K / E / F` is a field extension tower such that `K / F` is purely inseparable,\nthen `E / F` is also purely inseparable. -/\ntheorem IsPurelyInseparable.tower_bot [Algebra E K] [IsScalarTower F E K]\n    [IsPurelyInseparable F K] : IsPurelyInseparable F E := by\n  refine ⟨⟨fun x ↦ (isIntegral' F (algebraMap E K x)).tower_bot_of_field⟩, fun x h ↦ ?_⟩\n  rw [IsSeparable, ← minpoly.algebraMap_eq (algebraMap E K).injective] at h\n  obtain ⟨y, h⟩ := inseparable F _ h\n  exact ⟨y, (algebraMap E K).injective (h.symm ▸ (IsScalarTower.algebraMap_apply F E K y).symm)⟩\n\n"}
{"name":"IsPurelyInseparable.tower_top","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nK : Type w\ninst✝³ : Field K\ninst✝² : Algebra F K\ninst✝¹ : Algebra E K\ninst✝ : IsScalarTower F E K\nh : IsPurelyInseparable F K\n⊢ IsPurelyInseparable E K","decl":"/-- If `K / E / F` is a field extension tower such that `K / F` is purely inseparable,\nthen `K / E` is also purely inseparable. -/\ntheorem IsPurelyInseparable.tower_top [Algebra E K] [IsScalarTower F E K]\n    [h : IsPurelyInseparable F K] : IsPurelyInseparable E K := by\n  obtain ⟨q, _⟩ := ExpChar.exists F\n  haveI := expChar_of_injective_algebraMap (algebraMap F E).injective q\n  rw [isPurelyInseparable_iff_pow_mem _ q] at h ⊢\n  intro x\n  obtain ⟨n, y, h⟩ := h x\n  exact ⟨n, (algebraMap F E) y, h.symm ▸ (IsScalarTower.algebraMap_apply F E K y).symm⟩\n\n"}
{"name":"IsPurelyInseparable.trans","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nK : Type w\ninst✝³ : Field K\ninst✝² : Algebra F K\ninst✝¹ : Algebra E K\ninst✝ : IsScalarTower F E K\nh1 : IsPurelyInseparable F E\nh2 : IsPurelyInseparable E K\n⊢ IsPurelyInseparable F K","decl":"/-- If `E / F` and `K / E` are both purely inseparable extensions, then `K / F` is also\npurely inseparable. -/\n@[stacks 02JJ \"See also 00GM\"]\ntheorem IsPurelyInseparable.trans [Algebra E K] [IsScalarTower F E K]\n    [h1 : IsPurelyInseparable F E] [h2 : IsPurelyInseparable E K] : IsPurelyInseparable F K := by\n  obtain ⟨q, _⟩ := ExpChar.exists F\n  haveI := expChar_of_injective_algebraMap (algebraMap F E).injective q\n  rw [isPurelyInseparable_iff_pow_mem _ q] at h1 h2 ⊢\n  intro x\n  obtain ⟨n, y, h2⟩ := h2 x\n  obtain ⟨m, z, h1⟩ := h1 y\n  refine ⟨n + m, z, ?_⟩\n  rw [IsScalarTower.algebraMap_apply F E K, h1, map_pow, h2, ← pow_mul, ← pow_add]\n\n"}
{"name":"IntermediateField.isPurelyInseparable_tower_bot","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\ninst✝³ : Field F\nK : Type w\ninst✝² : Field K\ninst✝¹ : Algebra F K\nM : IntermediateField F K\ninst✝ : IsPurelyInseparable F K\n⊢ IsPurelyInseparable F (Subtype fun x => Membership.mem M x)","decl":"instance isPurelyInseparable_tower_bot [IsPurelyInseparable F K] : IsPurelyInseparable F M :=\n  IsPurelyInseparable.tower_bot F M K\n\n"}
{"name":"IntermediateField.isPurelyInseparable_tower_top","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\ninst✝³ : Field F\nK : Type w\ninst✝² : Field K\ninst✝¹ : Algebra F K\nM : IntermediateField F K\ninst✝ : IsPurelyInseparable F K\n⊢ IsPurelyInseparable (Subtype fun x => Membership.mem M x) K","decl":"instance isPurelyInseparable_tower_top [IsPurelyInseparable F K] : IsPurelyInseparable M K :=\n  IsPurelyInseparable.tower_top F M K\n\n"}
{"name":"isPurelyInseparable_iff_natSepDegree_eq_one","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Iff (IsPurelyInseparable F E) (∀ (x : E), Eq (minpoly F x).natSepDegree 1)","decl":"/-- A field extension `E / F` is purely inseparable if and only if for every element `x` of `E`,\nits minimal polynomial has separable degree one. -/\ntheorem isPurelyInseparable_iff_natSepDegree_eq_one :\n    IsPurelyInseparable F E ↔ ∀ x : E, (minpoly F x).natSepDegree = 1 := by\n  obtain ⟨q, _⟩ := ExpChar.exists F\n  simp_rw [isPurelyInseparable_iff_pow_mem F q, minpoly.natSepDegree_eq_one_iff_pow_mem q]\n\n"}
{"name":"IsPurelyInseparable.natSepDegree_eq_one","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : IsPurelyInseparable F E\nx : E\n⊢ Eq (minpoly F x).natSepDegree 1","decl":"theorem IsPurelyInseparable.natSepDegree_eq_one [IsPurelyInseparable F E] (x : E) :\n    (minpoly F x).natSepDegree = 1 :=\n  (isPurelyInseparable_iff_natSepDegree_eq_one F).1 ‹_› x\n\n"}
{"name":"isPurelyInseparable_iff_minpoly_eq_X_pow_sub_C","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nq : Nat\nhF : ExpChar F q\n⊢ Iff (IsPurelyInseparable F E) (∀ (x : E), Exists fun n => Exists fun y => Eq (minpoly F x) (HSub.hSub (HPow.hPow Polynomial.X (HPow.hPow q n)) (Polynomial.C y)))","decl":"/-- A field extension `E / F` of exponential characteristic `q` is purely inseparable\nif and only if for every element `x` of `E`, the minimal polynomial of `x` over `F` is of form\n`X ^ (q ^ n) - y` for some natural number `n` and some element `y` of `F`. -/\ntheorem isPurelyInseparable_iff_minpoly_eq_X_pow_sub_C (q : ℕ) [hF : ExpChar F q] :\n    IsPurelyInseparable F E ↔ ∀ x : E, ∃ (n : ℕ) (y : F), minpoly F x = X ^ q ^ n - C y := by\n  simp_rw [isPurelyInseparable_iff_natSepDegree_eq_one,\n    minpoly.natSepDegree_eq_one_iff_eq_X_pow_sub_C q]\n\n"}
{"name":"IsPurelyInseparable.minpoly_eq_X_pow_sub_C","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nq : Nat\ninst✝¹ : ExpChar F q\ninst✝ : IsPurelyInseparable F E\nx : E\n⊢ Exists fun n => Exists fun y => Eq (minpoly F x) (HSub.hSub (HPow.hPow Polynomial.X (HPow.hPow q n)) (Polynomial.C y))","decl":"theorem IsPurelyInseparable.minpoly_eq_X_pow_sub_C (q : ℕ) [ExpChar F q] [IsPurelyInseparable F E]\n    (x : E) : ∃ (n : ℕ) (y : F), minpoly F x = X ^ q ^ n - C y :=\n  (isPurelyInseparable_iff_minpoly_eq_X_pow_sub_C F q).1 ‹_› x\n\n"}
{"name":"isPurelyInseparable_iff_minpoly_eq_X_sub_C_pow","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nq : Nat\nhF : ExpChar F q\n⊢ Iff (IsPurelyInseparable F E) (∀ (x : E), Exists fun n => Eq (Polynomial.map (algebraMap F E) (minpoly F x)) (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C x)) (HPow.hPow q n)))","decl":"/-- A field extension `E / F` of exponential characteristic `q` is purely inseparable\nif and only if for every element `x` of `E`, the minimal polynomial of `x` over `F` is of form\n`(X - x) ^ (q ^ n)` for some natural number `n`. -/\ntheorem isPurelyInseparable_iff_minpoly_eq_X_sub_C_pow (q : ℕ) [hF : ExpChar F q] :\n    IsPurelyInseparable F E ↔\n    ∀ x : E, ∃ n : ℕ, (minpoly F x).map (algebraMap F E) = (X - C x) ^ q ^ n := by\n  simp_rw [isPurelyInseparable_iff_natSepDegree_eq_one,\n    minpoly.natSepDegree_eq_one_iff_eq_X_sub_C_pow q]\n\n"}
{"name":"IsPurelyInseparable.minpoly_eq_X_sub_C_pow","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nq : Nat\ninst✝¹ : ExpChar F q\ninst✝ : IsPurelyInseparable F E\nx : E\n⊢ Exists fun n => Eq (Polynomial.map (algebraMap F E) (minpoly F x)) (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C x)) (HPow.hPow q n))","decl":"theorem IsPurelyInseparable.minpoly_eq_X_sub_C_pow (q : ℕ) [ExpChar F q] [IsPurelyInseparable F E]\n    (x : E) : ∃ n : ℕ, (minpoly F x).map (algebraMap F E) = (X - C x) ^ q ^ n :=\n  (isPurelyInseparable_iff_minpoly_eq_X_sub_C_pow F q).1 ‹_› x\n\n"}
{"name":"isPurelyInseparable_of_finSepDegree_eq_one","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nhdeg : Eq (Field.finSepDegree F E) 1\n⊢ IsPurelyInseparable F E","decl":"variable {F E} in\n/-- If an extension has finite separable degree one, then it is purely inseparable. -/\ntheorem isPurelyInseparable_of_finSepDegree_eq_one\n    (hdeg : finSepDegree F E = 1) : IsPurelyInseparable F E := by\n  by_cases H : Algebra.IsAlgebraic F E\n  · rw [isPurelyInseparable_iff]\n    refine fun x ↦ ⟨Algebra.IsIntegral.isIntegral x, fun hsep ↦ ?_⟩\n    have : Algebra.IsAlgebraic F⟮x⟯ E := Algebra.IsAlgebraic.tower_top (K := F) F⟮x⟯\n    have := finSepDegree_mul_finSepDegree_of_isAlgebraic F F⟮x⟯ E\n    rw [hdeg, mul_eq_one, (finSepDegree_adjoin_simple_eq_finrank_iff F E x\n        (Algebra.IsAlgebraic.isAlgebraic x)).2 hsep,\n      IntermediateField.finrank_eq_one_iff] at this\n    simpa only [this.1] using mem_adjoin_simple_self F x\n  · rw [← Algebra.transcendental_iff_not_isAlgebraic] at H\n    simp [finSepDegree_eq_zero_of_transcendental F E] at hdeg\n\n"}
{"name":"IsPurelyInseparable.injective_comp_algebraMap","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝⁵ : Field F\ninst✝⁴ : Field E\ninst✝³ : Algebra F E\ninst✝² : IsPurelyInseparable F E\nL : Type u_2\ninst✝¹ : CommRing L\ninst✝ : IsReduced L\n⊢ Function.Injective fun f => f.comp (algebraMap F E)","decl":"/-- If `E / F` is purely inseparable, then for any reduced ring `L`, the map `(E →+* L) → (F →+* L)`\ninduced by `algebraMap F E` is injective. In particular, a purely inseparable field extension\nis an epimorphism in the category of fields. -/\ntheorem injective_comp_algebraMap [CommRing L] [IsReduced L] :\n    Function.Injective fun f : E →+* L ↦ f.comp (algebraMap F E) := fun f g heq ↦ by\n  ext x\n  let q := ringExpChar F\n  obtain ⟨n, y, h⟩ := IsPurelyInseparable.pow_mem F q x\n  replace heq := congr($heq y)\n  simp_rw [RingHom.comp_apply, h, map_pow] at heq\n  nontriviality L\n  haveI := expChar_of_injective_ringHom (f.comp (algebraMap F E)).injective q\n  exact iterateFrobenius_inj L q n heq\n\n"}
{"name":"IsPurelyInseparable.injective_restrictDomain","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝¹⁰ : Field F\ninst✝⁹ : Field E\ninst✝⁸ : Algebra F E\ninst✝⁷ : IsPurelyInseparable F E\nR : Type u_1\nL : Type u_2\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Algebra R F\ninst✝⁴ : Algebra R E\ninst✝³ : CommRing L\ninst✝² : IsReduced L\ninst✝¹ : Algebra R L\ninst✝ : IsScalarTower R F E\n⊢ Function.Injective (AlgHom.restrictDomain F)","decl":"theorem injective_restrictDomain [CommRing L] [IsReduced L] [Algebra R L] [IsScalarTower R F E] :\n    Function.Injective (AlgHom.restrictDomain (A := R) F (C := E) (D := L)) := fun _ _ eq ↦\n  AlgHom.coe_ringHom_injective <| injective_comp_algebraMap F E L <| congr_arg AlgHom.toRingHom eq\n\n"}
{"name":"IsPurelyInseparable.instNonemptyAlgHomOfPerfectField","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\ninst✝³ : IsPurelyInseparable F E\nL : Type u_2\ninst✝² : Field L\ninst✝¹ : PerfectField L\ninst✝ : Algebra F L\n⊢ Nonempty (AlgHom F E L)","decl":"instance [Field L] [PerfectField L] [Algebra F L] : Nonempty (E →ₐ[F] L) :=\n  nonempty_algHom_of_splits fun x ↦ ⟨IsPurelyInseparable.isIntegral' _ _,\n    have ⟨q, _⟩ := ExpChar.exists F\n    PerfectField.splits_of_natSepDegree_eq_one (algebraMap F L)\n      ((minpoly.natSepDegree_eq_one_iff_eq_X_pow_sub_C q).mpr <|\n        IsPurelyInseparable.minpoly_eq_X_pow_sub_C F q x)⟩\n\n"}
{"name":"IsPurelyInseparable.bijective_comp_algebraMap","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝⁵ : Field F\ninst✝⁴ : Field E\ninst✝³ : Algebra F E\ninst✝² : IsPurelyInseparable F E\nL : Type u_2\ninst✝¹ : Field L\ninst✝ : PerfectField L\n⊢ Function.Bijective fun f => f.comp (algebraMap F E)","decl":"theorem bijective_comp_algebraMap [Field L] [PerfectField L] :\n    Function.Bijective fun f : E →+* L ↦ f.comp (algebraMap F E) :=\n  ⟨injective_comp_algebraMap F E L, fun g ↦ let _ := g.toAlgebra\n    ⟨_, (Classical.arbitrary <| E →ₐ[F] L).comp_algebraMap⟩⟩\n\n"}
{"name":"IsPurelyInseparable.bijective_restrictDomain","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝¹⁰ : Field F\ninst✝⁹ : Field E\ninst✝⁸ : Algebra F E\ninst✝⁷ : IsPurelyInseparable F E\nR : Type u_1\nL : Type u_2\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Algebra R F\ninst✝⁴ : Algebra R E\ninst✝³ : Field L\ninst✝² : PerfectField L\ninst✝¹ : Algebra R L\ninst✝ : IsScalarTower R F E\n⊢ Function.Bijective (AlgHom.restrictDomain F)","decl":"theorem bijective_restrictDomain [Field L] [PerfectField L] [Algebra R L] [IsScalarTower R F E] :\n    Function.Bijective (AlgHom.restrictDomain (A := R) F (C := E) (D := L)) :=\n  ⟨injective_restrictDomain F E R L, fun g ↦ let _ := g.toAlgebra\n    let f := Classical.arbitrary (E →ₐ[F] L)\n    ⟨f.restrictScalars R, AlgHom.coe_ringHom_injective f.comp_algebraMap⟩⟩\n\n"}
{"name":"instSubsingletonAlgHomOfIsPurelyInseparable","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\ninst✝³ : IsPurelyInseparable F E\nL : Type w\ninst✝² : CommRing L\ninst✝¹ : IsReduced L\ninst✝ : Algebra F L\n⊢ Subsingleton (AlgHom F E L)","decl":"/-- If `E / F` is purely inseparable, then for any reduced `F`-algebra `L`, there exists at most one\n`F`-algebra homomorphism from `E` to `L`. -/\ninstance instSubsingletonAlgHomOfIsPurelyInseparable [IsPurelyInseparable F E] (L : Type w)\n    [CommRing L] [IsReduced L] [Algebra F L] : Subsingleton (E →ₐ[F] L) where\n  allEq f g := AlgHom.coe_ringHom_injective <|\n    IsPurelyInseparable.injective_comp_algebraMap F E L (by simp_rw [AlgHom.comp_algebraMap])\n\n"}
{"name":"IsPurelyInseparable.finSepDegree_eq_one","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : IsPurelyInseparable F E\n⊢ Eq (Field.finSepDegree F E) 1","decl":"/-- A purely inseparable extension has finite separable degree one. -/\ntheorem IsPurelyInseparable.finSepDegree_eq_one [IsPurelyInseparable F E] :\n    finSepDegree F E = 1 := Nat.card_unique\n\n"}
{"name":"IsPurelyInseparable.sepDegree_eq_one","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : IsPurelyInseparable F E\n⊢ Eq (Field.sepDegree F E) 1","decl":"/-- A purely inseparable extension has separable degree one. -/\ntheorem IsPurelyInseparable.sepDegree_eq_one [IsPurelyInseparable F E] :\n    sepDegree F E = 1 := by\n  rw [sepDegree, separableClosure.eq_bot_of_isPurelyInseparable, IntermediateField.rank_bot]\n\n"}
{"name":"IsPurelyInseparable.insepDegree_eq","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : IsPurelyInseparable F E\n⊢ Eq (Field.insepDegree F E) (Module.rank F E)","decl":"/-- A purely inseparable extension has inseparable degree equal to degree. -/\ntheorem IsPurelyInseparable.insepDegree_eq [IsPurelyInseparable F E] :\n    insepDegree F E = Module.rank F E := by\n  rw [insepDegree, separableClosure.eq_bot_of_isPurelyInseparable, rank_bot']\n\n"}
{"name":"IsPurelyInseparable.finInsepDegree_eq","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : IsPurelyInseparable F E\n⊢ Eq (Field.finInsepDegree F E) (Module.finrank F E)","decl":"/-- A purely inseparable extension has finite inseparable degree equal to degree. -/\ntheorem IsPurelyInseparable.finInsepDegree_eq [IsPurelyInseparable F E] :\n    finInsepDegree F E = finrank F E := congr(Cardinal.toNat $(insepDegree_eq F E))\n\n"}
{"name":"isPurelyInseparable_iff_finSepDegree_eq_one","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Iff (IsPurelyInseparable F E) (Eq (Field.finSepDegree F E) 1)","decl":"/-- An extension is purely inseparable if and only if it has finite separable degree one. -/\ntheorem isPurelyInseparable_iff_finSepDegree_eq_one :\n    IsPurelyInseparable F E ↔ finSepDegree F E = 1 :=\n  ⟨fun _ ↦ IsPurelyInseparable.finSepDegree_eq_one F E,\n    fun h ↦ isPurelyInseparable_of_finSepDegree_eq_one h⟩\n\n"}
{"name":"isPurelyInseparable_iff_fd_isPurelyInseparable","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.IsAlgebraic F E\n⊢ Iff (IsPurelyInseparable F E) (∀ (L : IntermediateField F E), FiniteDimensional F (Subtype fun x => Membership.mem L x) → IsPurelyInseparable F (Subtype fun x => Membership.mem L x))","decl":"variable {F E} in\n/-- An algebraic extension is purely inseparable if and only if all of its finite dimensional\nsubextensions are purely inseparable. -/\ntheorem isPurelyInseparable_iff_fd_isPurelyInseparable [Algebra.IsAlgebraic F E] :\n    IsPurelyInseparable F E ↔\n    ∀ L : IntermediateField F E, FiniteDimensional F L → IsPurelyInseparable F L := by\n  refine ⟨fun _ _ _ ↦ IsPurelyInseparable.tower_bot F _ E,\n    fun h ↦ isPurelyInseparable_iff.2 fun x ↦ ?_⟩\n  have hx : IsIntegral F x := Algebra.IsIntegral.isIntegral x\n  refine ⟨hx, fun _ ↦ ?_⟩\n  obtain ⟨y, h⟩ := (h _ (adjoin.finiteDimensional hx)).inseparable' _ <|\n    show Separable (minpoly F (AdjoinSimple.gen F x)) by rwa [minpoly_eq]\n  exact ⟨y, congr_arg (algebraMap _ E) h⟩\n\n"}
{"name":"IsPurelyInseparable.normal","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : IsPurelyInseparable F E\n⊢ Normal F E","decl":"/-- A purely inseparable extension is normal. -/\ninstance IsPurelyInseparable.normal [IsPurelyInseparable F E] : Normal F E where\n  toIsAlgebraic := isAlgebraic F E\n  splits' x := by\n    obtain ⟨n, h⟩ := IsPurelyInseparable.minpoly_eq_X_sub_C_pow F (ringExpChar F) x\n    rw [← splits_id_iff_splits, h]\n    exact splits_pow _ (splits_X_sub_C _) _\n\n"}
{"name":"separableClosure.isPurelyInseparable","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.IsAlgebraic F E\n⊢ IsPurelyInseparable (Subtype fun x => Membership.mem (separableClosure F E) x) E","decl":"/-- If `E / F` is algebraic, then `E` is purely inseparable over the\nseparable closure of `F` in `E`. -/\n@[stacks 030K \"$E/E_{sep}$ is purely inseparable.\"]\ninstance separableClosure.isPurelyInseparable [Algebra.IsAlgebraic F E] :\n    IsPurelyInseparable (separableClosure F E) E := isPurelyInseparable_iff.2 fun x ↦ by\n  set L := separableClosure F E\n  refine ⟨(IsAlgebraic.tower_top L (Algebra.IsAlgebraic.isAlgebraic (R := F) x)).isIntegral,\n    fun h ↦ ?_⟩\n  haveI := (isSeparable_adjoin_simple_iff_isSeparable L E).2 h\n  haveI : Algebra.IsSeparable F (restrictScalars F L⟮x⟯) := Algebra.IsSeparable.trans F L L⟮x⟯\n  have hx : x ∈ restrictScalars F L⟮x⟯ := mem_adjoin_simple_self _ x\n  exact ⟨⟨x, mem_separableClosure_iff.2 <| isSeparable_of_mem_isSeparable F E hx⟩, rfl⟩\n\n"}
{"name":"Field.Emb.cardinal_separableClosure","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.IsAlgebraic F E\n⊢ Eq (Cardinal.mk (Field.Emb F (Subtype fun x => Membership.mem (separableClosure F E) x))) (Cardinal.mk (Field.Emb F E))","decl":"open Cardinal in\ntheorem Field.Emb.cardinal_separableClosure [Algebra.IsAlgebraic F E] :\n    #(Field.Emb F <| separableClosure F E) = #(Field.Emb F E) := by\n  rw [← (embProdEmbOfIsAlgebraic F (separableClosure F E) E).cardinal_eq,\n    mk_prod, mk_eq_one (Emb _ E), lift_one, mul_one, lift_id]\n\n"}
{"name":"separableClosure_le","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nL : IntermediateField F E\nh : IsPurelyInseparable (Subtype fun x => Membership.mem L x) E\n⊢ LE.le (separableClosure F E) L","decl":"/-- An intermediate field of `E / F` contains the separable closure of `F` in `E`\nif `E` is purely inseparable over it. -/\ntheorem separableClosure_le (L : IntermediateField F E)\n    [h : IsPurelyInseparable L E] : separableClosure F E ≤ L := fun x hx ↦ by\n  obtain ⟨y, rfl⟩ := h.inseparable' _ <|\n    IsSeparable.tower_top L (mem_separableClosure_iff.1 hx)\n  exact y.2\n\n"}
{"name":"separableClosure_le_iff","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.IsAlgebraic F E\nL : IntermediateField F E\n⊢ Iff (LE.le (separableClosure F E) L) (IsPurelyInseparable (Subtype fun x => Membership.mem L x) E)","decl":"/-- If `E / F` is algebraic, then an intermediate field of `E / F` contains the\nseparable closure of `F` in `E` if and only if `E` is purely inseparable over it. -/\ntheorem separableClosure_le_iff [Algebra.IsAlgebraic F E] (L : IntermediateField F E) :\n    separableClosure F E ≤ L ↔ IsPurelyInseparable L E := by\n  refine ⟨fun h ↦ ?_, fun _ ↦ separableClosure_le F E L⟩\n  have := separableClosure.isPurelyInseparable F E\n  letI := (inclusion h).toAlgebra\n  letI : SMul (separableClosure F E) L := Algebra.toSMul\n  haveI : IsScalarTower (separableClosure F E) L E := IsScalarTower.of_algebraMap_eq (congrFun rfl)\n  exact IsPurelyInseparable.tower_top (separableClosure F E) L E\n\n"}
{"name":"eq_separableClosure","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nL : IntermediateField F E\ninst✝¹ : Algebra.IsSeparable F (Subtype fun x => Membership.mem L x)\ninst✝ : IsPurelyInseparable (Subtype fun x => Membership.mem L x) E\n⊢ Eq L (separableClosure F E)","decl":"/-- If an intermediate field of `E / F` is separable over `F`, and `E` is purely inseparable\nover it, then it is equal to the separable closure of `F` in `E`. -/\ntheorem eq_separableClosure (L : IntermediateField F E)\n    [Algebra.IsSeparable F L] [IsPurelyInseparable L E] : L = separableClosure F E :=\n  le_antisymm (le_separableClosure F E L) (separableClosure_le F E L)\n\n"}
{"name":"eq_separableClosure_iff","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.IsAlgebraic F E\nL : IntermediateField F E\n⊢ Iff (Eq L (separableClosure F E)) (And (Algebra.IsSeparable F (Subtype fun x => Membership.mem L x)) (IsPurelyInseparable (Subtype fun x => Membership.mem L x) E))","decl":"open separableClosure in\n/-- If `E / F` is algebraic, then an intermediate field of `E / F` is equal to the separable closure\nof `F` in `E` if and only if it is separable over `F`, and `E` is purely inseparable\nover it. -/\ntheorem eq_separableClosure_iff [Algebra.IsAlgebraic F E] (L : IntermediateField F E) :\n    L = separableClosure F E ↔ Algebra.IsSeparable F L ∧ IsPurelyInseparable L E :=\n  ⟨by rintro rfl; exact ⟨isSeparable F E, isPurelyInseparable F E⟩,\n   fun ⟨_, _⟩ ↦ eq_separableClosure F E L⟩\n\n"}
{"name":"IsPurelyInseparable.of_injective_comp_algebraMap","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝⁵ : Field F\ninst✝⁴ : Field E\ninst✝³ : Algebra F E\nL : Type w\ninst✝² : Field L\ninst✝¹ : IsAlgClosed L\ninst✝ : Nonempty (RingHom E L)\nh : Function.Injective fun f => f.comp (algebraMap F E)\n⊢ IsPurelyInseparable F E","decl":"/-- If `L` is an algebraically closed field containing `E`, such that the map\n`(E →+* L) → (F →+* L)` induced by `algebraMap F E` is injective, then `E / F` is\npurely inseparable. As a corollary, epimorphisms in the category of fields must be\npurely inseparable extensions. -/\ntheorem IsPurelyInseparable.of_injective_comp_algebraMap (L : Type w) [Field L] [IsAlgClosed L]\n    [Nonempty (E →+* L)] (h : Function.Injective fun f : E →+* L ↦ f.comp (algebraMap F E)) :\n    IsPurelyInseparable F E := by\n  rw [isPurelyInseparable_iff_finSepDegree_eq_one, finSepDegree, Nat.card_eq_one_iff_unique]\n  letI := (Classical.arbitrary (E →+* L)).toAlgebra\n  let j : AlgebraicClosure E →ₐ[E] L := IsAlgClosed.lift\n  exact ⟨⟨fun f g ↦ DFunLike.ext' <| j.injective.comp_left (congr_arg (⇑) <|\n    @h (j.toRingHom.comp f) (j.toRingHom.comp g) (by ext; simp))⟩, inferInstance⟩\n\n"}
{"name":"IntermediateField.isPurelyInseparable_bot","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ IsPurelyInseparable F (Subtype fun x => Membership.mem Bot.bot x)","decl":"instance isPurelyInseparable_bot : IsPurelyInseparable F (⊥ : IntermediateField F E) :=\n  (botEquiv F E).symm.isPurelyInseparable\n\n"}
{"name":"isSepClosed_iff_isPurelyInseparable_algebraicClosure","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : IsAlgClosure F E\n⊢ Iff (IsSepClosed F) (IsPurelyInseparable F E)","decl":"/-- If `E` is an algebraic closure of `F`, then `F` is separably closed if and only if `E / F` is\npurely inseparable. -/\ntheorem isSepClosed_iff_isPurelyInseparable_algebraicClosure [IsAlgClosure F E] :\n    IsSepClosed F ↔ IsPurelyInseparable F E :=\n  ⟨fun _ ↦ inferInstance, fun H ↦ by\n    haveI := IsAlgClosure.isAlgClosed F (K := E)\n    rwa [← separableClosure.eq_bot_iff, IsSepClosed.separableClosure_eq_bot_iff] at H⟩\n\n"}
{"name":"Algebra.IsAlgebraic.isSepClosed","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\ninst✝¹ : Algebra.IsAlgebraic F E\ninst✝ : IsSepClosed F\n⊢ IsSepClosed E","decl":"variable {F E} in\n/-- If `E / F` is an algebraic extension, `F` is separably closed,\nthen `E` is also separably closed. -/\ntheorem Algebra.IsAlgebraic.isSepClosed [Algebra.IsAlgebraic F E]\n    [IsSepClosed F] : IsSepClosed E :=\n  have : Algebra.IsAlgebraic F (AlgebraicClosure E) := Algebra.IsAlgebraic.trans (L := E)\n  (isSepClosed_iff_isPurelyInseparable_algebraicClosure E _).mpr\n    (IsPurelyInseparable.tower_top F E <| AlgebraicClosure E)\n\n"}
{"name":"Field.finSepDegree_eq","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.IsAlgebraic F E\n⊢ Eq (Field.finSepDegree F E) (Cardinal.toNat (Field.sepDegree F E))","decl":"/-- If `E / F` is algebraic, then the `Field.finSepDegree F E` is equal to `Field.sepDegree F E`\nas a natural number. This means that the cardinality of `Field.Emb F E` and the degree of\n`(separableClosure F E) / F` are both finite or infinite, and when they are finite, they\ncoincide. -/\n@[stacks 09HJ \"`sepDegree` is defined as the right hand side of 09HJ\"]\ntheorem finSepDegree_eq [Algebra.IsAlgebraic F E] :\n    finSepDegree F E = Cardinal.toNat (sepDegree F E) := by\n  have : Algebra.IsAlgebraic (separableClosure F E) E := Algebra.IsAlgebraic.tower_top (K := F) _\n  have h := finSepDegree_mul_finSepDegree_of_isAlgebraic F (separableClosure F E) E |>.symm\n  haveI := separableClosure.isSeparable F E\n  haveI := separableClosure.isPurelyInseparable F E\n  rwa [finSepDegree_eq_finrank_of_isSeparable F (separableClosure F E),\n    IsPurelyInseparable.finSepDegree_eq_one (separableClosure F E) E, mul_one] at h\n\n"}
{"name":"Field.finSepDegree_mul_finInsepDegree","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Eq (HMul.hMul (Field.finSepDegree F E) (Field.finInsepDegree F E)) (Module.finrank F E)","decl":"/-- The finite separable degree multiply by the finite inseparable degree is equal\nto the (finite) field extension degree. -/\ntheorem finSepDegree_mul_finInsepDegree : finSepDegree F E * finInsepDegree F E = finrank F E := by\n  by_cases halg : Algebra.IsAlgebraic F E\n  · have := congr_arg Cardinal.toNat (sepDegree_mul_insepDegree F E)\n    rwa [Cardinal.toNat_mul, ← finSepDegree_eq F E] at this\n  rw [finInsepDegree, finrank_of_infinite_dimensional (K := F) (V := E) fun _ ↦\n      halg (Algebra.IsAlgebraic.of_finite F E),\n    finrank_of_infinite_dimensional (K := separableClosure F E) (V := E) fun _ ↦\n      halg ((separableClosure.isAlgebraic F E).trans),\n    mul_zero]\n\n"}
{"name":"separableClosure.adjoin_eq_of_isAlgebraic_of_isSeparable","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝⁸ : Field F\ninst✝⁷ : Field E\ninst✝⁶ : Algebra F E\nK : Type w\ninst✝⁵ : Field K\ninst✝⁴ : Algebra F K\ninst✝³ : Algebra E K\ninst✝² : IsScalarTower F E K\ninst✝¹ : Algebra.IsAlgebraic F E\ninst✝ : Algebra.IsSeparable E K\n⊢ Eq (IntermediateField.adjoin E ↑(separableClosure F K)) Top.top","decl":"/-- If `K / E / F` is a field extension tower, such that `E / F` is algebraic and `K / E`\nis separable, then `E` adjoin `separableClosure F K` is equal to `K`. It is a special case of\n`separableClosure.adjoin_eq_of_isAlgebraic`, and is an intermediate result used to prove it. -/\nlemma adjoin_eq_of_isAlgebraic_of_isSeparable [Algebra.IsAlgebraic F E]\n    [Algebra.IsSeparable E K] : adjoin E (separableClosure F K : Set K) = ⊤ :=\n  top_unique fun x _ ↦ by\n    set S := separableClosure F K\n    set L := adjoin E (S : Set K)\n    have := Algebra.isSeparable_tower_top_of_isSeparable E L K\n    let i : S →+* L := Subsemiring.inclusion fun x hx ↦ subset_adjoin E (S : Set K) hx\n    let _ : Algebra S L := i.toAlgebra\n    let _ : SMul S L := Algebra.toSMul\n    have : IsScalarTower S L K := IsScalarTower.of_algebraMap_eq (congrFun rfl)\n    have : Algebra.IsAlgebraic F K := Algebra.IsAlgebraic.trans (L := E)\n    have : IsPurelyInseparable S K := separableClosure.isPurelyInseparable F K\n    have := IsPurelyInseparable.tower_top S L K\n    obtain ⟨y, rfl⟩ := IsPurelyInseparable.surjective_algebraMap_of_isSeparable L K x\n    exact y.2\n\n"}
{"name":"separableClosure.adjoin_eq_of_isAlgebraic","module":"Mathlib.FieldTheory.PurelyInseparable.Basic","initialProofState":"F : Type u\nE : Type v\ninst✝⁷ : Field F\ninst✝⁶ : Field E\ninst✝⁵ : Algebra F E\nK : Type w\ninst✝⁴ : Field K\ninst✝³ : Algebra F K\ninst✝² : Algebra E K\ninst✝¹ : IsScalarTower F E K\ninst✝ : Algebra.IsAlgebraic F E\n⊢ Eq (IntermediateField.adjoin E ↑(separableClosure F K)) (separableClosure E K)","decl":"/-- If `K / E / F` is a field extension tower, such that `E / F` is algebraic, then\n`E` adjoin `separableClosure F K` is equal to `separableClosure E K`. -/\ntheorem adjoin_eq_of_isAlgebraic [Algebra.IsAlgebraic F E] :\n    adjoin E (separableClosure F K) = separableClosure E K := by\n  set S := separableClosure E K\n  have h := congr_arg lift (adjoin_eq_of_isAlgebraic_of_isSeparable (F := F) S)\n  rw [lift_top, lift_adjoin] at h\n  haveI : IsScalarTower F S K := IsScalarTower.of_algebraMap_eq (congrFun rfl)\n  rw [← h, ← map_eq_of_separableClosure_eq_bot F (separableClosure_eq_bot E K)]\n  simp only [S, coe_map, IsScalarTower.coe_toAlgHom', IntermediateField.algebraMap_apply]\n\n"}
