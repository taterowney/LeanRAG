{"name":"IsSl2Triple.h_ne_zero","module":"Mathlib.Algebra.Lie.Sl2","initialProofState":"L : Type u_2\ninst✝ : LieRing L\nh e f : L\nself : IsSl2Triple h e f\n⊢ Ne h 0","decl":"variable {L} in\n/-- An `sl₂` triple within a Lie ring `L` is a triple of elements `h`, `e`, `f` obeying relations\nwhich ensure that the Lie subalgebra they generate is equivalent to `sl₂`. -/\nstructure IsSl2Triple (h e f : L) : Prop where\n  h_ne_zero : h ≠ 0\n  lie_e_f : ⁅e, f⁆ = h\n  lie_h_e_nsmul : ⁅h, e⁆ = 2 • e\n  lie_h_f_nsmul : ⁅h, f⁆ = - (2 • f)\n\n"}
{"name":"IsSl2Triple.lie_e_f","module":"Mathlib.Algebra.Lie.Sl2","initialProofState":"L : Type u_2\ninst✝ : LieRing L\nh e f : L\nself : IsSl2Triple h e f\n⊢ Eq (Bracket.bracket e f) h","decl":"variable {L} in\n/-- An `sl₂` triple within a Lie ring `L` is a triple of elements `h`, `e`, `f` obeying relations\nwhich ensure that the Lie subalgebra they generate is equivalent to `sl₂`. -/\nstructure IsSl2Triple (h e f : L) : Prop where\n  h_ne_zero : h ≠ 0\n  lie_e_f : ⁅e, f⁆ = h\n  lie_h_e_nsmul : ⁅h, e⁆ = 2 • e\n  lie_h_f_nsmul : ⁅h, f⁆ = - (2 • f)\n\n"}
{"name":"IsSl2Triple.lie_h_e_nsmul","module":"Mathlib.Algebra.Lie.Sl2","initialProofState":"L : Type u_2\ninst✝ : LieRing L\nh e f : L\nself : IsSl2Triple h e f\n⊢ Eq (Bracket.bracket h e) (HSMul.hSMul 2 e)","decl":"variable {L} in\n/-- An `sl₂` triple within a Lie ring `L` is a triple of elements `h`, `e`, `f` obeying relations\nwhich ensure that the Lie subalgebra they generate is equivalent to `sl₂`. -/\nstructure IsSl2Triple (h e f : L) : Prop where\n  h_ne_zero : h ≠ 0\n  lie_e_f : ⁅e, f⁆ = h\n  lie_h_e_nsmul : ⁅h, e⁆ = 2 • e\n  lie_h_f_nsmul : ⁅h, f⁆ = - (2 • f)\n\n"}
{"name":"IsSl2Triple.lie_h_f_nsmul","module":"Mathlib.Algebra.Lie.Sl2","initialProofState":"L : Type u_2\ninst✝ : LieRing L\nh e f : L\nself : IsSl2Triple h e f\n⊢ Eq (Bracket.bracket h f) (Neg.neg (HSMul.hSMul 2 f))","decl":"variable {L} in\n/-- An `sl₂` triple within a Lie ring `L` is a triple of elements `h`, `e`, `f` obeying relations\nwhich ensure that the Lie subalgebra they generate is equivalent to `sl₂`. -/\nstructure IsSl2Triple (h e f : L) : Prop where\n  h_ne_zero : h ≠ 0\n  lie_e_f : ⁅e, f⁆ = h\n  lie_h_e_nsmul : ⁅h, e⁆ = 2 • e\n  lie_h_f_nsmul : ⁅h, f⁆ = - (2 • f)\n\n"}
{"name":"IsSl2Triple.symm","module":"Mathlib.Algebra.Lie.Sl2","initialProofState":"L : Type u_2\ninst✝ : LieRing L\nh e f : L\nht : IsSl2Triple h e f\n⊢ IsSl2Triple (Neg.neg h) f e","decl":"lemma symm (ht : IsSl2Triple h e f) : IsSl2Triple (-h) f e where\n  h_ne_zero := by simpa using ht.h_ne_zero\n  lie_e_f := by rw [← neg_eq_iff_eq_neg, lie_skew, ht.lie_e_f]\n  lie_h_e_nsmul := by rw [neg_lie, neg_eq_iff_eq_neg, ht.lie_h_f_nsmul]\n  lie_h_f_nsmul := by rw [neg_lie, neg_inj, ht.lie_h_e_nsmul]\n\n"}
{"name":"IsSl2Triple.symm_iff","module":"Mathlib.Algebra.Lie.Sl2","initialProofState":"L : Type u_2\ninst✝ : LieRing L\nh e f : L\n⊢ Iff (IsSl2Triple (Neg.neg h) f e) (IsSl2Triple h e f)","decl":"@[simp] lemma symm_iff : IsSl2Triple (-h) f e ↔ IsSl2Triple h e f :=\n  ⟨fun t ↦ neg_neg h ▸ t.symm, symm⟩\n\n"}
{"name":"IsSl2Triple.lie_h_e_smul","module":"Mathlib.Algebra.Lie.Sl2","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nh e f : L\nt : IsSl2Triple h e f\n⊢ Eq (Bracket.bracket h e) (HSMul.hSMul 2 e)","decl":"lemma lie_h_e_smul (t : IsSl2Triple h e f) : ⁅h, e⁆ = (2 : R) • e := by\n  simp [t.lie_h_e_nsmul, two_smul]\n\n"}
{"name":"IsSl2Triple.lie_lie_smul_f","module":"Mathlib.Algebra.Lie.Sl2","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nh e f : L\nt : IsSl2Triple h e f\n⊢ Eq (Bracket.bracket h f) (Neg.neg (HSMul.hSMul 2 f))","decl":"lemma lie_lie_smul_f (t : IsSl2Triple h e f) : ⁅h, f⁆ = -((2 : R) • f) := by\n  simp [t.lie_h_f_nsmul, two_smul]\n\n"}
{"name":"IsSl2Triple.e_ne_zero","module":"Mathlib.Algebra.Lie.Sl2","initialProofState":"L : Type u_2\ninst✝ : LieRing L\nh e f : L\nt : IsSl2Triple h e f\n⊢ Ne e 0","decl":"lemma e_ne_zero (t : IsSl2Triple h e f) : e ≠ 0 := by\n  have := t.h_ne_zero\n  contrapose! this\n  simpa [this] using t.lie_e_f.symm\n\n"}
{"name":"IsSl2Triple.f_ne_zero","module":"Mathlib.Algebra.Lie.Sl2","initialProofState":"L : Type u_2\ninst✝ : LieRing L\nh e f : L\nt : IsSl2Triple h e f\n⊢ Ne f 0","decl":"lemma f_ne_zero (t : IsSl2Triple h e f) : f ≠ 0 := by\n  have := t.h_ne_zero\n  contrapose! this\n  simpa [this] using t.lie_e_f.symm\n\n"}
{"name":"IsSl2Triple.HasPrimitiveVectorWith.lie_h","module":"Mathlib.Algebra.Lie.Sl2","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nh e f : L\nt : IsSl2Triple h e f\nm : M\nμ : R\nself : t.HasPrimitiveVectorWith m μ\n⊢ Eq (Bracket.bracket h m) (HSMul.hSMul μ m)","decl":"/-- Given a representation of a Lie algebra with distinguished `sl₂` triple, a vector is said to be\nprimitive if it is a simultaneous eigenvector for the action of both `h`, `e`, and the eigenvalue\nfor `e` is zero. -/\nstructure HasPrimitiveVectorWith (t : IsSl2Triple h e f) (m : M) (μ : R) : Prop where\n  ne_zero : m ≠ 0\n  lie_h : ⁅h, m⁆ = μ • m\n  lie_e : ⁅e, m⁆ = 0\n\n"}
{"name":"IsSl2Triple.HasPrimitiveVectorWith.lie_e","module":"Mathlib.Algebra.Lie.Sl2","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nh e f : L\nt : IsSl2Triple h e f\nm : M\nμ : R\nself : t.HasPrimitiveVectorWith m μ\n⊢ Eq (Bracket.bracket e m) 0","decl":"/-- Given a representation of a Lie algebra with distinguished `sl₂` triple, a vector is said to be\nprimitive if it is a simultaneous eigenvector for the action of both `h`, `e`, and the eigenvalue\nfor `e` is zero. -/\nstructure HasPrimitiveVectorWith (t : IsSl2Triple h e f) (m : M) (μ : R) : Prop where\n  ne_zero : m ≠ 0\n  lie_h : ⁅h, m⁆ = μ • m\n  lie_e : ⁅e, m⁆ = 0\n\n"}
{"name":"IsSl2Triple.HasPrimitiveVectorWith.ne_zero","module":"Mathlib.Algebra.Lie.Sl2","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nh e f : L\nt : IsSl2Triple h e f\nm : M\nμ : R\nself : t.HasPrimitiveVectorWith m μ\n⊢ Ne m 0","decl":"/-- Given a representation of a Lie algebra with distinguished `sl₂` triple, a vector is said to be\nprimitive if it is a simultaneous eigenvector for the action of both `h`, `e`, and the eigenvalue\nfor `e` is zero. -/\nstructure HasPrimitiveVectorWith (t : IsSl2Triple h e f) (m : M) (μ : R) : Prop where\n  ne_zero : m ≠ 0\n  lie_h : ⁅h, m⁆ = μ • m\n  lie_e : ⁅e, m⁆ = 0\n\n"}
{"name":"IsSl2Triple.HasPrimitiveVectorWith.mk'","module":"Mathlib.Algebra.Lie.Sl2","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\nh e f : L\ninst✝ : NoZeroSMulDivisors Int M\nt : IsSl2Triple h e f\nm : M\nμ ρ : R\nhm : Ne m 0\nhm' : Eq (Bracket.bracket h m) (HSMul.hSMul μ m)\nhe : Eq (Bracket.bracket e m) (HSMul.hSMul ρ m)\n⊢ t.HasPrimitiveVectorWith m μ","decl":"/-- Given a representation of a Lie algebra with distinguished `sl₂` triple, a simultaneous\neigenvector for the action of both `h` and `e` necessarily has eigenvalue zero for `e`. -/\nlemma HasPrimitiveVectorWith.mk' [NoZeroSMulDivisors ℤ M] (t : IsSl2Triple h e f) (m : M) (μ ρ : R)\n    (hm : m ≠ 0) (hm' : ⁅h, m⁆ = μ • m) (he : ⁅e, m⁆ = ρ • m) :\n    HasPrimitiveVectorWith t m μ  where\n  ne_zero := hm\n  lie_h := hm'\n  lie_e := by\n    suffices 2 • ⁅e, m⁆ = 0 by simpa using this\n    rw [← nsmul_lie, ← t.lie_h_e_nsmul, lie_lie, hm', lie_smul, he, lie_smul, hm',\n      smul_smul, smul_smul, mul_comm ρ μ, sub_self]\n\n"}
{"name":"IsSl2Triple.HasPrimitiveVectorWith.lie_f_pow_toEnd_f","module":"Mathlib.Algebra.Lie.Sl2","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nh e f : L\nm : M\nμ : R\nt : IsSl2Triple h e f\nP : t.HasPrimitiveVectorWith m μ\nn : Nat\n⊢ Eq (Bracket.bracket f ((HPow.hPow ((LieModule.toEnd R L M) f) n) m)) ((HPow.hPow ((LieModule.toEnd R L M) f) (HAdd.hAdd n 1)) m)","decl":"set_option linter.unusedVariables false in\n@[nolint unusedArguments]\nlemma lie_f_pow_toEnd_f (P : HasPrimitiveVectorWith t m μ) (n : ℕ) :\n    ⁅f, ψ n⁆ = ψ (n + 1) := by\n  simp [pow_succ']\n\n"}
{"name":"IsSl2Triple.HasPrimitiveVectorWith.lie_h_pow_toEnd_f","module":"Mathlib.Algebra.Lie.Sl2","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nh e f : L\nm : M\nμ : R\nt : IsSl2Triple h e f\nP : t.HasPrimitiveVectorWith m μ\nn : Nat\n⊢ Eq (Bracket.bracket h ((HPow.hPow ((LieModule.toEnd R L M) f) n) m)) (HSMul.hSMul (HSub.hSub μ (HMul.hMul 2 ↑n)) ((HPow.hPow ((LieModule.toEnd R L M) f) n) m))","decl":"lemma lie_h_pow_toEnd_f (n : ℕ) :\n    ⁅h, ψ n⁆ = (μ - 2 * n) • ψ n := by\n  induction n with\n  | zero => simpa using P.lie_h\n  | succ n ih =>\n    rw [pow_succ', LinearMap.mul_apply, toEnd_apply_apply, Nat.cast_add, Nat.cast_one,\n      leibniz_lie h, t.lie_lie_smul_f R, ← neg_smul, ih, lie_smul, smul_lie, ← add_smul]\n    congr\n    ring\n\n"}
{"name":"IsSl2Triple.HasPrimitiveVectorWith.lie_e_pow_succ_toEnd_f","module":"Mathlib.Algebra.Lie.Sl2","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nh e f : L\nm : M\nμ : R\nt : IsSl2Triple h e f\nP : t.HasPrimitiveVectorWith m μ\nn : Nat\n⊢ Eq (Bracket.bracket e ((HPow.hPow ((LieModule.toEnd R L M) f) (HAdd.hAdd n 1)) m)) (HSMul.hSMul (HMul.hMul (HAdd.hAdd (↑n) 1) (HSub.hSub μ ↑n)) ((HPow.hPow ((LieModule.toEnd R L M) f) n) m))","decl":"lemma lie_e_pow_succ_toEnd_f (n : ℕ) :\n    ⁅e, ψ (n + 1)⁆ = ((n + 1) * (μ - n)) • ψ n := by\n  induction n with\n  | zero =>\n      simp only [zero_add, pow_one, toEnd_apply_apply, Nat.cast_zero, sub_zero, one_mul,\n        pow_zero, LinearMap.one_apply, leibniz_lie e, t.lie_e_f, P.lie_e, P.lie_h, lie_zero,\n        add_zero]\n  | succ n ih =>\n    rw [pow_succ', LinearMap.mul_apply, toEnd_apply_apply, leibniz_lie e, t.lie_e_f,\n      lie_h_pow_toEnd_f P, ih, lie_smul, lie_f_pow_toEnd_f P, ← add_smul,\n      Nat.cast_add, Nat.cast_one]\n    congr\n    ring\n\n"}
{"name":"IsSl2Triple.HasPrimitiveVectorWith.exists_nat","module":"Mathlib.Algebra.Lie.Sl2","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\nh e f : L\nm : M\nμ : R\nt : IsSl2Triple h e f\nP : t.HasPrimitiveVectorWith m μ\ninst✝³ : IsNoetherian R M\ninst✝² : NoZeroSMulDivisors R M\ninst✝¹ : IsDomain R\ninst✝ : CharZero R\n⊢ Exists fun n => Eq μ ↑n","decl":"/-- The eigenvalue of a primitive vector must be a natural number if the representation is\nfinite-dimensional. -/\nlemma exists_nat [IsNoetherian R M] [NoZeroSMulDivisors R M] [IsDomain R] [CharZero R] :\n    ∃ n : ℕ, μ = n := by\n  suffices ∃ n : ℕ, (ψ n) = 0 by\n    obtain ⟨n, hn₁, hn₂⟩ := Nat.exists_not_and_succ_of_not_zero_of_exists P.ne_zero this\n    refine ⟨n, ?_⟩\n    have := lie_e_pow_succ_toEnd_f P n\n    rw [hn₂, lie_zero, eq_comm, smul_eq_zero_iff_left hn₁, mul_eq_zero, sub_eq_zero] at this\n    exact this.resolve_left <| Nat.cast_add_one_ne_zero n\n  have hs : (range <| fun (n : ℕ) ↦ μ - 2 * n).Infinite := by\n    rw [infinite_range_iff (fun n m ↦ by simp)]; infer_instance\n  by_contra! contra\n  exact hs ((toEnd R L M h).eigenvectors_linearIndependent\n    {μ - 2 * n | n : ℕ}\n    (fun ⟨s, hs⟩ ↦ ψ Classical.choose hs)\n    (fun ⟨r, hr⟩ ↦ by simp [lie_h_pow_toEnd_f P, Classical.choose_spec hr, contra,\n      Module.End.hasEigenvector_iff, Module.End.mem_eigenspace_iff])).finite\n\n"}
{"name":"IsSl2Triple.HasPrimitiveVectorWith.pow_toEnd_f_ne_zero_of_eq_nat","module":"Mathlib.Algebra.Lie.Sl2","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\nh e f : L\nm : M\nμ : R\nt : IsSl2Triple h e f\nP : t.HasPrimitiveVectorWith m μ\ninst✝¹ : CharZero R\ninst✝ : NoZeroSMulDivisors R M\nn : Nat\nhn : Eq μ ↑n\ni : Nat\nhi : LE.le i n\n⊢ Ne ((HPow.hPow ((LieModule.toEnd R L M) f) i) m) 0","decl":"lemma pow_toEnd_f_ne_zero_of_eq_nat\n    [CharZero R] [NoZeroSMulDivisors R M]\n    {n : ℕ} (hn : μ = n) {i} (hi : i ≤ n) : (ψ i) ≠ 0 := by\n  intro H\n  induction i\n  · exact P.ne_zero (by simpa using H)\n  · next i IH =>\n    have : ((i + 1) * (n - i) : ℤ) • (toEnd R L M f ^ i) m = 0 := by\n      have := congr_arg (⁅e, ·⁆) H\n      simpa [← Int.cast_smul_eq_zsmul R, P.lie_e_pow_succ_toEnd_f, hn] using this\n    rw [← Int.cast_smul_eq_zsmul R, smul_eq_zero, Int.cast_eq_zero, mul_eq_zero, sub_eq_zero,\n      Nat.cast_inj, ← @Nat.cast_one ℤ, ← Nat.cast_add, Nat.cast_eq_zero] at this\n    simp only [add_eq_zero, one_ne_zero, and_false, false_or] at this\n    exact (hi.trans_eq (this.resolve_right (IH (i.le_succ.trans hi)))).not_lt i.lt_succ_self\n\n"}
{"name":"IsSl2Triple.HasPrimitiveVectorWith.pow_toEnd_f_eq_zero_of_eq_nat","module":"Mathlib.Algebra.Lie.Sl2","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\nh e f : L\nm : M\nμ : R\nt : IsSl2Triple h e f\nP : t.HasPrimitiveVectorWith m μ\ninst✝³ : IsNoetherian R M\ninst✝² : NoZeroSMulDivisors R M\ninst✝¹ : IsDomain R\ninst✝ : CharZero R\nn : Nat\nhn : Eq μ ↑n\n⊢ Eq ((HPow.hPow ((LieModule.toEnd R L M) f) (HAdd.hAdd n 1)) m) 0","decl":"lemma pow_toEnd_f_eq_zero_of_eq_nat\n    [IsNoetherian R M] [NoZeroSMulDivisors R M] [IsDomain R] [CharZero R]\n    {n : ℕ} (hn : μ = n) : (ψ (n + 1)) = 0 := by\n  by_contra h\n  have : t.HasPrimitiveVectorWith (ψ (n + 1)) (n - 2 * (n + 1) : R) :=\n    { ne_zero := h\n      lie_h := (P.lie_h_pow_toEnd_f _).trans (by simp [hn])\n      lie_e := (P.lie_e_pow_succ_toEnd_f _).trans (by simp [hn]) }\n  obtain ⟨m, hm⟩ := this.exists_nat\n  have : (n : ℤ) < m + 2 * (n + 1) := by omega\n  exact this.ne (Int.cast_injective (α := R) <| by simpa [sub_eq_iff_eq_add] using hm)\n\n"}
