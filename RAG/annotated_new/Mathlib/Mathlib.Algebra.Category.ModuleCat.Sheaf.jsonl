{"name":"SheafOfModules.isSheaf","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nself : SheafOfModules R\n‚ä¢ CategoryTheory.Presheaf.IsSheaf J self.val.presheaf","decl":"/-- A sheaf of modules is a presheaf of modules such that the underlying presheaf\nof abelian groups is a sheaf. -/\nstructure SheafOfModules where\n  /-- the underlying presheaf of modules of a sheaf of modules -/\n  val : PresheafOfModules.{v} R.val\n  isSheaf : Presheaf.IsSheaf J val.presheaf\n\n"}
{"name":"SheafOfModules.mk.inj","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nval‚úù : PresheafOfModules R.val\nisSheaf‚úù : CategoryTheory.Presheaf.IsSheaf J val‚úù.presheaf\nval : PresheafOfModules R.val\nisSheaf : CategoryTheory.Presheaf.IsSheaf J val.presheaf\nx‚úù : Eq { val := val‚úù, isSheaf := isSheaf‚úù } { val := val, isSheaf := isSheaf }\n‚ä¢ Eq val‚úù val","decl":"/-- A sheaf of modules is a presheaf of modules such that the underlying presheaf\nof abelian groups is a sheaf. -/\nstructure SheafOfModules where\n  /-- the underlying presheaf of modules of a sheaf of modules -/\n  val : PresheafOfModules.{v} R.val\n  isSheaf : Presheaf.IsSheaf J val.presheaf\n\n"}
{"name":"SheafOfModules.mk.sizeOf_spec","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\ninst‚úù : SizeOf C\nval : PresheafOfModules R.val\nisSheaf : CategoryTheory.Presheaf.IsSheaf J val.presheaf\n‚ä¢ Eq (SizeOf.sizeOf { val := val, isSheaf := isSheaf }) (HAdd.hAdd 1 (SizeOf.sizeOf val))","decl":"/-- A sheaf of modules is a presheaf of modules such that the underlying presheaf\nof abelian groups is a sheaf. -/\nstructure SheafOfModules where\n  /-- the underlying presheaf of modules of a sheaf of modules -/\n  val : PresheafOfModules.{v} R.val\n  isSheaf : Presheaf.IsSheaf J val.presheaf\n\n"}
{"name":"SheafOfModules.mk.injEq","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nval‚úù : PresheafOfModules R.val\nisSheaf‚úù : CategoryTheory.Presheaf.IsSheaf J val‚úù.presheaf\nval : PresheafOfModules R.val\nisSheaf : CategoryTheory.Presheaf.IsSheaf J val.presheaf\n‚ä¢ Eq (Eq { val := val‚úù, isSheaf := isSheaf‚úù } { val := val, isSheaf := isSheaf }) (Eq val‚úù val)","decl":"/-- A sheaf of modules is a presheaf of modules such that the underlying presheaf\nof abelian groups is a sheaf. -/\nstructure SheafOfModules where\n  /-- the underlying presheaf of modules of a sheaf of modules -/\n  val : PresheafOfModules.{v} R.val\n  isSheaf : Presheaf.IsSheaf J val.presheaf\n\n"}
{"name":"SheafOfModules.Hom.mk.sizeOf_spec","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nX Y : SheafOfModules R\ninst‚úù : SizeOf C\nval : Quiver.Hom X.val Y.val\n‚ä¢ Eq (SizeOf.sizeOf { val := val }) (HAdd.hAdd 1 (SizeOf.sizeOf val))","decl":"/-- A morphism between sheaves of modules is a morphism between the underlying\npresheaves of modules. -/\n@[ext]\nstructure Hom (X Y : SheafOfModules.{v} R) where\n  /-- a morphism between the underlying presheaves of modules -/\n  val : X.val ‚ü∂ Y.val\n\n"}
{"name":"SheafOfModules.Hom.mk.inj","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nX Y : SheafOfModules R\nval‚úù val : Quiver.Hom X.val Y.val\nx‚úù : Eq { val := val‚úù } { val := val }\n‚ä¢ Eq val‚úù val","decl":"/-- A morphism between sheaves of modules is a morphism between the underlying\npresheaves of modules. -/\n@[ext]\nstructure Hom (X Y : SheafOfModules.{v} R) where\n  /-- a morphism between the underlying presheaves of modules -/\n  val : X.val ‚ü∂ Y.val\n\n"}
{"name":"SheafOfModules.Hom.ext_iff","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nX Y : SheafOfModules R\nx y : X.Hom Y\n‚ä¢ Iff (Eq x y) (Eq x.val y.val)","decl":"/-- A morphism between sheaves of modules is a morphism between the underlying\npresheaves of modules. -/\n@[ext]\nstructure Hom (X Y : SheafOfModules.{v} R) where\n  /-- a morphism between the underlying presheaves of modules -/\n  val : X.val ‚ü∂ Y.val\n\n"}
{"name":"SheafOfModules.Hom.mk.injEq","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nX Y : SheafOfModules R\nval‚úù val : Quiver.Hom X.val Y.val\n‚ä¢ Eq (Eq { val := val‚úù } { val := val }) (Eq val‚úù val)","decl":"/-- A morphism between sheaves of modules is a morphism between the underlying\npresheaves of modules. -/\n@[ext]\nstructure Hom (X Y : SheafOfModules.{v} R) where\n  /-- a morphism between the underlying presheaves of modules -/\n  val : X.val ‚ü∂ Y.val\n\n"}
{"name":"SheafOfModules.Hom.ext","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nX Y : SheafOfModules R\nx y : X.Hom Y\nval : Eq x.val y.val\n‚ä¢ Eq x y","decl":"/-- A morphism between sheaves of modules is a morphism between the underlying\npresheaves of modules. -/\n@[ext]\nstructure Hom (X Y : SheafOfModules.{v} R) where\n  /-- a morphism between the underlying presheaves of modules -/\n  val : X.val ‚ü∂ Y.val\n\n"}
{"name":"SheafOfModules.hom_ext_iff","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nX Y : SheafOfModules R\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (Eq f.val g.val)","decl":"@[ext]\nlemma hom_ext {X Y : SheafOfModules.{v} R} {f g : X ‚ü∂ Y} (h : f.val = g.val) : f = g :=\n  Hom.ext h\n\n"}
{"name":"SheafOfModules.hom_ext","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nX Y : SheafOfModules R\nf g : Quiver.Hom X Y\nh : Eq f.val g.val\n‚ä¢ Eq f g","decl":"@[ext]\nlemma hom_ext {X Y : SheafOfModules.{v} R} {f g : X ‚ü∂ Y} (h : f.val = g.val) : f = g :=\n  Hom.ext h\n\n"}
{"name":"SheafOfModules.id_val","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nX : SheafOfModules R\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X).val (CategoryTheory.CategoryStruct.id X.val)","decl":"@[simp]\nlemma id_val (X : SheafOfModules.{v} R) : Hom.val (ùüô X) = ùüô X.val := rfl\n\n"}
{"name":"SheafOfModules.comp_val","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nX Y Z : SheafOfModules R\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).val (CategoryTheory.CategoryStruct.comp f.val g.val)","decl":"@[simp, reassoc]\nlemma comp_val {X Y Z : SheafOfModules.{v} R} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    (f ‚â´ g).val = f.val ‚â´ g.val := rfl\n\n"}
{"name":"SheafOfModules.comp_val_assoc","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nX Y Z‚úù : SheafOfModules R\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z‚úù\nZ : PresheafOfModules R.val\nh : Quiver.Hom Z‚úù.val Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g).val h) (CategoryTheory.CategoryStruct.comp f.val (CategoryTheory.CategoryStruct.comp g.val h))","decl":"@[simp, reassoc]\nlemma comp_val {X Y Z : SheafOfModules.{v} R} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    (f ‚â´ g).val = f.val ‚â´ g.val := rfl\n\n"}
{"name":"SheafOfModules.forget_obj","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nF : SheafOfModules R\n‚ä¢ Eq ((SheafOfModules.forget R).obj F) F.val","decl":"/-- The forgetful functor `SheafOfModules.{v} R ‚•§ PresheafOfModules R.val`. -/\n@[simps]\ndef forget : SheafOfModules.{v} R ‚•§ PresheafOfModules R.val where\n  obj F := F.val\n  map œÜ := œÜ.val\n\n"}
{"name":"SheafOfModules.forget_map","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nX‚úù Y‚úù : SheafOfModules R\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((SheafOfModules.forget R).map œÜ) œÜ.val","decl":"/-- The forgetful functor `SheafOfModules.{v} R ‚•§ PresheafOfModules R.val`. -/\n@[simps]\ndef forget : SheafOfModules.{v} R ‚•§ PresheafOfModules R.val where\n  obj F := F.val\n  map œÜ := œÜ.val\n\n"}
{"name":"SheafOfModules.fullyFaithfulForget_preimage_val","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nX‚úù Y‚úù : SheafOfModules R\nœÜ : Quiver.Hom ((SheafOfModules.forget R).obj X‚úù) ((SheafOfModules.forget R).obj Y‚úù)\n‚ä¢ Eq ((SheafOfModules.fullyFaithfulForget R).preimage œÜ).val œÜ","decl":"/-- The forget functor `SheafOfModules R ‚•§ PresheafOfModules R.val` is fully faithful. -/\n@[simps]\ndef fullyFaithfulForget : (forget.{v} R).FullyFaithful where\n  preimage œÜ := ‚ü®œÜ‚ü©\n\n"}
{"name":"SheafOfModules.instFaithfulPresheafOfModulesValRingCatForget","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\n‚ä¢ (SheafOfModules.forget R).Faithful","decl":"instance : (forget.{v} R).Faithful := (fullyFaithfulForget R).faithful\n\n"}
{"name":"SheafOfModules.instFullPresheafOfModulesValRingCatForget","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\n‚ä¢ (SheafOfModules.forget R).Full","decl":"instance : (forget.{v} R).Full := (fullyFaithfulForget R).full\n\n"}
{"name":"SheafOfModules.instReflectsIsomorphismsPresheafOfModulesValRingCatForget","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\n‚ä¢ (SheafOfModules.forget R).ReflectsIsomorphisms","decl":"instance : (forget.{v} R).ReflectsIsomorphisms := (fullyFaithfulForget R).reflectsIsomorphisms\n\n"}
{"name":"SheafOfModules.toSheaf_obj_val","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\n‚ä¢ Eq ((SheafOfModules.toSheaf R).obj M).val M.val.presheaf","decl":"/-- The forget functor `SheafOfModules R ‚•§ Sheaf J AddCommGrp`. -/\n@[simps]\ndef toSheaf : SheafOfModules.{v} R ‚•§ Sheaf J AddCommGrp.{v} where\n  obj M := ‚ü®_, M.isSheaf‚ü©\n  map f := { val := (forget R ‚ãô PresheafOfModules.toPresheaf R.val).map f }\n\n"}
{"name":"SheafOfModules.toSheaf_map_val","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nX‚úù Y‚úù : SheafOfModules R\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((SheafOfModules.toSheaf R).map f).val (((SheafOfModules.forget R).comp (PresheafOfModules.toPresheaf R.val)).map f)","decl":"/-- The forget functor `SheafOfModules R ‚•§ Sheaf J AddCommGrp`. -/\n@[simps]\ndef toSheaf : SheafOfModules.{v} R ‚•§ Sheaf J AddCommGrp.{v} where\n  obj M := ‚ü®_, M.isSheaf‚ü©\n  map f := { val := (forget R ‚ãô PresheafOfModules.toPresheaf R.val).map f }\n\n"}
{"name":"SheafOfModules.forgetToSheafModuleCat_map_val","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nX : Opposite C\nhX : CategoryTheory.Limits.IsInitial X\nX‚úù Y‚úù : SheafOfModules R\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((SheafOfModules.forgetToSheafModuleCat R X hX).map f).val ((PresheafOfModules.forgetToPresheafModuleCat X hX).map f.val)","decl":"/--\nThe forgetful functor from sheaves of modules over sheaf of ring `R` to sheaves of `R(X)`-module\nwhen `X` is initial.\n-/\n@[simps]\nnoncomputable def forgetToSheafModuleCat\n      (X : C·µí·µñ) (hX : Limits.IsInitial X)  :\n    SheafOfModules.{w} R ‚•§ Sheaf J (ModuleCat.{w} (R.1.obj X)) where\n  obj M := ‚ü®(PresheafOfModules.forgetToPresheafModuleCat X hX).obj M.1,\n    Presheaf.isSheaf_of_isSheaf_comp _ _\n      (forget‚ÇÇ (ModuleCat.{w} (R.1.obj X)) AddCommGrp.{w}) M.isSheaf‚ü©\n  map f := { val := (PresheafOfModules.forgetToPresheafModuleCat X hX).map f.1 }\n\n"}
{"name":"SheafOfModules.forgetToSheafModuleCat_obj_val","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nX : Opposite C\nhX : CategoryTheory.Limits.IsInitial X\nM : SheafOfModules R\n‚ä¢ Eq ((SheafOfModules.forgetToSheafModuleCat R X hX).obj M).val ((PresheafOfModules.forgetToPresheafModuleCat X hX).obj M.val)","decl":"/--\nThe forgetful functor from sheaves of modules over sheaf of ring `R` to sheaves of `R(X)`-module\nwhen `X` is initial.\n-/\n@[simps]\nnoncomputable def forgetToSheafModuleCat\n      (X : C·µí·µñ) (hX : Limits.IsInitial X)  :\n    SheafOfModules.{w} R ‚•§ Sheaf J (ModuleCat.{w} (R.1.obj X)) where\n  obj M := ‚ü®(PresheafOfModules.forgetToPresheafModuleCat X hX).obj M.1,\n    Presheaf.isSheaf_of_isSheaf_comp _ _\n      (forget‚ÇÇ (ModuleCat.{w} (R.1.obj X)) AddCommGrp.{w}) M.isSheaf‚ü©\n  map f := { val := (PresheafOfModules.forgetToPresheafModuleCat X hX).map f.1 }\n\n"}
{"name":"SheafOfModules.instFaithfulSheafAddCommGrpToSheaf","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\n‚ä¢ (SheafOfModules.toSheaf R).Faithful","decl":"instance : (toSheaf.{v} R).Faithful :=\n  Functor.Faithful.of_comp_iso (toSheafCompSheafToPresheafIso.{v} R)\n\n"}
{"name":"SheafOfModules.add_val","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM N : SheafOfModules R\nf g : Quiver.Hom M N\n‚ä¢ Eq (HAdd.hAdd f g).val (HAdd.hAdd f.val g.val)","decl":"@[simp]\nlemma add_val {M N : SheafOfModules.{v} R} (f g : M ‚ü∂ N) :\n    (f + g).val = f.val + g.val := rfl\n\n"}
{"name":"SheafOfModules.instAdditivePresheafOfModulesValRingCatForget","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\n‚ä¢ (SheafOfModules.forget R).Additive","decl":"instance : (forget R).Additive where\n\n"}
{"name":"SheafOfModules.instAdditiveSheafAddCommGrpToSheaf","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\n‚ä¢ (SheafOfModules.toSheaf R).Additive","decl":"instance : (toSheaf R).Additive where\n\n"}
{"name":"SheafOfModules.sectionsMap_comp","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM N P : SheafOfModules R\nf : Quiver.Hom M N\ng : Quiver.Hom N P\ns : M.sections\n‚ä¢ Eq (SheafOfModules.sectionsMap (CategoryTheory.CategoryStruct.comp f g) s) (SheafOfModules.sectionsMap g (SheafOfModules.sectionsMap f s))","decl":"@[simp]\nlemma sectionsMap_comp {M N P : SheafOfModules.{v} R} (f : M ‚ü∂ N) (g : N ‚ü∂ P) (s : M.sections) :\n    sectionsMap (f ‚â´ g) s = sectionsMap g (sectionsMap f s) := rfl\n\n"}
{"name":"SheafOfModules.sectionsMap_id","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ns : M.sections\n‚ä¢ Eq (SheafOfModules.sectionsMap (CategoryTheory.CategoryStruct.id M) s) s","decl":"@[simp]\nlemma sectionsMap_id {M : SheafOfModules.{v} R} (s : M.sections) :\n    sectionsMap (ùüô M) s = s := rfl\n\n"}
{"name":"SheafOfModules.sectionsFunctor_map","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nX‚úù Y‚úù : SheafOfModules R\nf : Quiver.Hom X‚úù Y‚úù\ns : X‚úù.sections\n‚ä¢ Eq ((SheafOfModules.sectionsFunctor R).map f s) (SheafOfModules.sectionsMap f s)","decl":"variable (R) in\n/-- The functor which sends a sheaf of modules to its type of sections. -/\n@[simps]\ndef sectionsFunctor : SheafOfModules.{v} R ‚•§ Type _ where\n  obj := sections\n  map f := sectionsMap f\n\n"}
{"name":"SheafOfModules.sectionsFunctor_obj","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\n‚ä¢ Eq ((SheafOfModules.sectionsFunctor R).obj M) M.sections","decl":"variable (R) in\n/-- The functor which sends a sheaf of modules to its type of sections. -/\n@[simps]\ndef sectionsFunctor : SheafOfModules.{v} R ‚•§ Type _ where\n  obj := sections\n  map f := sectionsMap f\n\n"}
{"name":"SheafOfModules.unit_val","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\ninst‚úù : J.HasSheafCompose (CategoryTheory.forget‚ÇÇ RingCat AddCommGrp)\n‚ä¢ Eq (SheafOfModules.unit R).val (PresheafOfModules.unit R.val)","decl":"variable (R) in\n/-- The obvious free sheaf of modules of rank `1`. -/\n@[simps]\ndef unit : SheafOfModules R where\n  val := PresheafOfModules.unit R.val\n  isSheaf := ((sheafCompose J (forget‚ÇÇ RingCat.{u} AddCommGrp.{u})).obj R).cond\n\n"}
{"name":"SheafOfModules.unitHomEquiv_apply_coe","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\ninst‚úù : J.HasSheafCompose (CategoryTheory.forget‚ÇÇ RingCat AddCommGrp)\nM : SheafOfModules R\nf : Quiver.Hom (SheafOfModules.unit R) M\nX : Opposite C\n‚ä¢ Eq (‚Üë(M.unitHomEquiv f) X) ((CategoryTheory.ConcreteCategory.hom (f.val.app X)) 1)","decl":"@[simp]\nlemma unitHomEquiv_apply_coe (M : SheafOfModules R) (f : unit R ‚ü∂ M) (X : C·µí·µñ) :\n    (M.unitHomEquiv f).val X = f.val.app X (1 : R.val.obj X) := rfl\n\n"}
{"name":"SheafOfModules.unitHomEquiv_comp_apply","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\ninst‚úù : J.HasSheafCompose (CategoryTheory.forget‚ÇÇ RingCat AddCommGrp)\nM N : SheafOfModules R\nf : Quiver.Hom (SheafOfModules.unit R) M\np : Quiver.Hom M N\n‚ä¢ Eq (N.unitHomEquiv (CategoryTheory.CategoryStruct.comp f p)) (SheafOfModules.sectionsMap p (M.unitHomEquiv f))","decl":"lemma unitHomEquiv_comp_apply {M N : SheafOfModules.{u} R}\n    (f : unit R ‚ü∂ M) (p : M ‚ü∂ N) :\n    N.unitHomEquiv (f ‚â´ p) = sectionsMap p (M.unitHomEquiv f) := rfl\n\n"}
{"name":"SheafOfModules.unitHomEquiv_symm_comp","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\ninst‚úù : J.HasSheafCompose (CategoryTheory.forget‚ÇÇ RingCat AddCommGrp)\nM N : SheafOfModules R\ns : M.sections\np : Quiver.Hom M N\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (M.unitHomEquiv.symm s) p) (N.unitHomEquiv.symm (SheafOfModules.sectionsMap p s))","decl":"lemma unitHomEquiv_symm_comp {M N : SheafOfModules.{u} R} (s : M.sections) (p : M ‚ü∂ N) :\n    M.unitHomEquiv.symm s ‚â´ p = N.unitHomEquiv.symm (sectionsMap p s) :=\n  N.unitHomEquiv.injective (by simp [unitHomEquiv_comp_apply])\n\n"}
{"name":"PresheafOfModules.homEquivOfIsLocallyBijective_symm_apply","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM‚ÇÅ M‚ÇÇ : PresheafOfModules R\nf : Quiver.Hom M‚ÇÅ M‚ÇÇ\nN : PresheafOfModules R\nhN : CategoryTheory.Presheaf.IsSheaf J N.presheaf\ninst‚úù¬≤ : J.WEqualsLocallyBijective AddCommGrp\ninst‚úù¬π : PresheafOfModules.IsLocallySurjective J f\ninst‚úù : PresheafOfModules.IsLocallyInjective J f\nœà : Quiver.Hom M‚ÇÅ N\n‚ä¢ Eq ((PresheafOfModules.homEquivOfIsLocallyBijective f hN).symm œà) (PresheafOfModules.homMk ((CategoryTheory.Localization.LeftBousfield.W.homEquiv ‚ãØ N.presheaf hN).symm ((PresheafOfModules.toPresheaf R).map œà)) ‚ãØ)","decl":"/-- The bijection `(M‚ÇÇ ‚ü∂ N) ‚âÉ (M‚ÇÅ ‚ü∂ N)` induced by a locally bijective morphism\n`f : M‚ÇÅ ‚ü∂ M‚ÇÇ` of presheaves of modules, when `N` is a sheaf. -/\n@[simps]\nnoncomputable def homEquivOfIsLocallyBijective : (M‚ÇÇ ‚ü∂ N) ‚âÉ (M‚ÇÅ ‚ü∂ N) where\n  toFun œÜ := f ‚â´ œÜ\n  invFun œà := homMk (((J.W_of_isLocallyBijective\n      ((PresheafOfModules.toPresheaf R).map f)).homEquiv _ hN).symm\n      ((PresheafOfModules.toPresheaf R).map œà)) (by\n        obtain ‚ü®œÜ, hœÜ‚ü© := ((J.W_of_isLocallyBijective\n          ((PresheafOfModules.toPresheaf R).map f)).homEquiv _ hN).surjective\n          ((PresheafOfModules.toPresheaf R).map œà)\n        simp only [‚Üê hœÜ, Equiv.symm_apply_apply]\n        replace hœÜ : ‚àÄ (Z : C·µí·µñ) (x : M‚ÇÅ.obj Z), œÜ.app Z (f.app Z x) = œà.app Z x :=\n          fun Z x ‚Ü¶ congr_fun ((forget _).congr_map (congr_app hœÜ Z)) x\n        intro X r y\n        apply hN.isSeparated _ _\n          (Presheaf.imageSieve_mem J ((toPresheaf R).map f) y)\n        rintro Y p ‚ü®x : M‚ÇÅ.obj _, hx : f.app _ x = M‚ÇÇ.map p.op y‚ü©\n        have hœÜ' : ‚àÄ (z : M‚ÇÇ.obj X), œÜ.app _ (M‚ÇÇ.map p.op z) =\n            N.map p.op (œÜ.app _ z) := congr_fun ((forget _).congr_map (œÜ.naturality p.op))\n        change N.map p.op (œÜ.app X (r ‚Ä¢ y)) = N.map p.op (r ‚Ä¢ œÜ.app X y)\n        rw [‚Üê hœÜ', M‚ÇÇ.map_smul, ‚Üê hx, ‚Üê (f.app _).hom.map_smul, hœÜ, (œà.app _).hom.map_smul,\n          ‚Üê hœÜ, hx, N.map_smul, hœÜ'])\n  left_inv œÜ := (toPresheaf _).map_injective\n    (((J.W_of_isLocallyBijective\n      ((PresheafOfModules.toPresheaf R).map f)).homEquiv _ hN).left_inv\n      ((PresheafOfModules.toPresheaf R).map œÜ))\n  right_inv œà := (toPresheaf _).map_injective\n    (((J.W_of_isLocallyBijective\n      ((PresheafOfModules.toPresheaf R).map f)).homEquiv _ hN).right_inv\n      ((PresheafOfModules.toPresheaf R).map œà))\n\n"}
{"name":"PresheafOfModules.homEquivOfIsLocallyBijective_apply","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM‚ÇÅ M‚ÇÇ : PresheafOfModules R\nf : Quiver.Hom M‚ÇÅ M‚ÇÇ\nN : PresheafOfModules R\nhN : CategoryTheory.Presheaf.IsSheaf J N.presheaf\ninst‚úù¬≤ : J.WEqualsLocallyBijective AddCommGrp\ninst‚úù¬π : PresheafOfModules.IsLocallySurjective J f\ninst‚úù : PresheafOfModules.IsLocallyInjective J f\nœÜ : Quiver.Hom M‚ÇÇ N\n‚ä¢ Eq ((PresheafOfModules.homEquivOfIsLocallyBijective f hN) œÜ) (CategoryTheory.CategoryStruct.comp f œÜ)","decl":"/-- The bijection `(M‚ÇÇ ‚ü∂ N) ‚âÉ (M‚ÇÅ ‚ü∂ N)` induced by a locally bijective morphism\n`f : M‚ÇÅ ‚ü∂ M‚ÇÇ` of presheaves of modules, when `N` is a sheaf. -/\n@[simps]\nnoncomputable def homEquivOfIsLocallyBijective : (M‚ÇÇ ‚ü∂ N) ‚âÉ (M‚ÇÅ ‚ü∂ N) where\n  toFun œÜ := f ‚â´ œÜ\n  invFun œà := homMk (((J.W_of_isLocallyBijective\n      ((PresheafOfModules.toPresheaf R).map f)).homEquiv _ hN).symm\n      ((PresheafOfModules.toPresheaf R).map œà)) (by\n        obtain ‚ü®œÜ, hœÜ‚ü© := ((J.W_of_isLocallyBijective\n          ((PresheafOfModules.toPresheaf R).map f)).homEquiv _ hN).surjective\n          ((PresheafOfModules.toPresheaf R).map œà)\n        simp only [‚Üê hœÜ, Equiv.symm_apply_apply]\n        replace hœÜ : ‚àÄ (Z : C·µí·µñ) (x : M‚ÇÅ.obj Z), œÜ.app Z (f.app Z x) = œà.app Z x :=\n          fun Z x ‚Ü¶ congr_fun ((forget _).congr_map (congr_app hœÜ Z)) x\n        intro X r y\n        apply hN.isSeparated _ _\n          (Presheaf.imageSieve_mem J ((toPresheaf R).map f) y)\n        rintro Y p ‚ü®x : M‚ÇÅ.obj _, hx : f.app _ x = M‚ÇÇ.map p.op y‚ü©\n        have hœÜ' : ‚àÄ (z : M‚ÇÇ.obj X), œÜ.app _ (M‚ÇÇ.map p.op z) =\n            N.map p.op (œÜ.app _ z) := congr_fun ((forget _).congr_map (œÜ.naturality p.op))\n        change N.map p.op (œÜ.app X (r ‚Ä¢ y)) = N.map p.op (r ‚Ä¢ œÜ.app X y)\n        rw [‚Üê hœÜ', M‚ÇÇ.map_smul, ‚Üê hx, ‚Üê (f.app _).hom.map_smul, hœÜ, (œà.app _).hom.map_smul,\n          ‚Üê hœÜ, hx, N.map_smul, hœÜ'])\n  left_inv œÜ := (toPresheaf _).map_injective\n    (((J.W_of_isLocallyBijective\n      ((PresheafOfModules.toPresheaf R).map f)).homEquiv _ hN).left_inv\n      ((PresheafOfModules.toPresheaf R).map œÜ))\n  right_inv œà := (toPresheaf _).map_injective\n    (((J.W_of_isLocallyBijective\n      ((PresheafOfModules.toPresheaf R).map f)).homEquiv _ hN).right_inv\n      ((PresheafOfModules.toPresheaf R).map œà))\n\n"}
