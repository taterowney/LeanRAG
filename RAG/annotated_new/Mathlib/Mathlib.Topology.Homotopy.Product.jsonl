{"name":"ContinuousMap.HomotopyRel.pi_apply","module":"Mathlib.Topology.Homotopy.Product","initialProofState":"I : Type u_1\nA : Type u_2\nX : I → Type u_3\ninst✝¹ : (i : I) → TopologicalSpace (X i)\ninst✝ : TopologicalSpace A\nf g : (i : I) → ContinuousMap A (X i)\nS : Set A\nhomotopies : (i : I) → (f i).HomotopyRel (g i) S\na : Prod (↑unitInterval) A\ni : I\n⊢ Eq ((ContinuousMap.HomotopyRel.pi homotopies) a i) ((homotopies i) a)","decl":"/-- The relative product homotopy of `homotopies` between functions `f` and `g` -/\n@[simps!]\ndef HomotopyRel.pi (homotopies : ∀ i : I, HomotopyRel (f i) (g i) S) :\n    HomotopyRel (pi f) (pi g) S :=\n  { Homotopy.pi fun i => (homotopies i).toHomotopy with\n    prop' := by\n      intro t x hx\n      dsimp only [coe_mk, pi_eval, toFun_eq_coe, HomotopyWith.coe_toContinuousMap]\n      simp only [funext_iff, ← forall_and]\n      intro i\n      exact (homotopies i).prop' t x hx }\n\n"}
{"name":"ContinuousMap.Homotopy.prod_apply","module":"Mathlib.Topology.Homotopy.Product","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\nA : Type u_3\ninst✝ : TopologicalSpace A\nf₀ f₁ : ContinuousMap A α\ng₀ g₁ : ContinuousMap A β\nF : f₀.Homotopy f₁\nG : g₀.Homotopy g₁\nt : Prod (↑unitInterval) A\n⊢ Eq ((F.prod G) t) { fst := F t, snd := G t }","decl":"/-- The product of homotopies `F` and `G`,\n  where `F` takes `f₀` to `f₁` and `G` takes `g₀` to `g₁` -/\n@[simps]\ndef Homotopy.prod (F : Homotopy f₀ f₁) (G : Homotopy g₀ g₁) :\n    Homotopy (ContinuousMap.prodMk f₀ g₀) (ContinuousMap.prodMk f₁ g₁) where\n  toFun t := (F t, G t)\n  map_zero_left x := by simp only [prod_eval, Homotopy.apply_zero]\n  map_one_left x := by simp only [prod_eval, Homotopy.apply_one]\n\n"}
{"name":"ContinuousMap.HomotopyRel.prod_apply","module":"Mathlib.Topology.Homotopy.Product","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\nA : Type u_3\ninst✝ : TopologicalSpace A\nf₀ f₁ : ContinuousMap A α\ng₀ g₁ : ContinuousMap A β\nS : Set A\nF : f₀.HomotopyRel f₁ S\nG : g₀.HomotopyRel g₁ S\nt : Prod (↑unitInterval) A\n⊢ Eq ((F.prod G) t) { fst := F t, snd := G t }","decl":"/-- The relative product of homotopies `F` and `G`,\n  where `F` takes `f₀` to `f₁` and `G` takes `g₀` to `g₁` -/\n@[simps!]\ndef HomotopyRel.prod (F : HomotopyRel f₀ f₁ S) (G : HomotopyRel g₀ g₁ S) :\n    HomotopyRel (prodMk f₀ g₀) (prodMk f₁ g₁) S where\n  toHomotopy := Homotopy.prod F.toHomotopy G.toHomotopy\n  prop' t x hx := Prod.ext (F.prop' t x hx) (G.prop' t x hx)\n\n"}
{"name":"Path.Homotopic.pi_lift","module":"Mathlib.Topology.Homotopy.Product","initialProofState":"ι : Type u_1\nX : ι → Type u_2\ninst✝ : (i : ι) → TopologicalSpace (X i)\nas bs : (i : ι) → X i\nγ : (i : ι) → Path (as i) (bs i)\n⊢ Eq (Path.Homotopic.pi fun i => Quotient.mk (Path.Homotopic.setoid (as i) (bs i)) (γ i)) (Quotient.mk (Path.Homotopic.setoid as bs) (Path.pi γ))","decl":"theorem pi_lift (γ : ∀ i, Path (as i) (bs i)) :\n    (Path.Homotopic.pi fun i => ⟦γ i⟧) = ⟦Path.pi γ⟧ := by unfold pi; simp\n\n"}
{"name":"Path.Homotopic.comp_pi_eq_pi_comp","module":"Mathlib.Topology.Homotopy.Product","initialProofState":"ι : Type u_1\nX : ι → Type u_2\ninst✝ : (i : ι) → TopologicalSpace (X i)\nas bs cs : (i : ι) → X i\nγ₀ : (i : ι) → Path.Homotopic.Quotient (as i) (bs i)\nγ₁ : (i : ι) → Path.Homotopic.Quotient (bs i) (cs i)\n⊢ Eq ((Path.Homotopic.pi γ₀).comp (Path.Homotopic.pi γ₁)) (Path.Homotopic.pi fun i => (γ₀ i).comp (γ₁ i))","decl":"/-- Composition and products commute.\n  This is `Path.trans_pi_eq_pi_trans` descended to path homotopy classes. -/\ntheorem comp_pi_eq_pi_comp (γ₀ : ∀ i, Path.Homotopic.Quotient (as i) (bs i))\n    (γ₁ : ∀ i, Path.Homotopic.Quotient (bs i) (cs i)) : pi γ₀ ⬝ pi γ₁ = pi fun i ↦ γ₀ i ⬝ γ₁ i := by\n  induction γ₁ using Quotient.induction_on_pi with | _ a =>\n  induction γ₀ using Quotient.induction_on_pi\n  simp only [pi_lift]\n  rw [← Path.Homotopic.comp_lift, Path.trans_pi_eq_pi_trans, ← pi_lift]\n  rfl\n\n"}
{"name":"Path.Homotopic.proj_pi","module":"Mathlib.Topology.Homotopy.Product","initialProofState":"ι : Type u_1\nX : ι → Type u_2\ninst✝ : (i : ι) → TopologicalSpace (X i)\nas bs : (i : ι) → X i\ni : ι\npaths : (i : ι) → Path.Homotopic.Quotient (as i) (bs i)\n⊢ Eq (Path.Homotopic.proj i (Path.Homotopic.pi paths)) (paths i)","decl":"/-- Lemmas showing projection is the inverse of pi. -/\n@[simp]\ntheorem proj_pi (i : ι) (paths : ∀ i, Path.Homotopic.Quotient (as i) (bs i)) :\n    proj i (pi paths) = paths i := by\n  induction paths using Quotient.induction_on_pi\n  rw [proj, pi_lift, ← Path.Homotopic.map_lift]\n  congr\n\n"}
{"name":"Path.Homotopic.pi_proj","module":"Mathlib.Topology.Homotopy.Product","initialProofState":"ι : Type u_1\nX : ι → Type u_2\ninst✝ : (i : ι) → TopologicalSpace (X i)\nas bs : (i : ι) → X i\np : Path.Homotopic.Quotient as bs\n⊢ Eq (Path.Homotopic.pi fun i => Path.Homotopic.proj i p) p","decl":"@[simp]\ntheorem pi_proj (p : Path.Homotopic.Quotient as bs) : (pi fun i => proj i p) = p := by\n  induction p using Quotient.inductionOn\n  simp_rw [proj, ← Path.Homotopic.map_lift]\n  erw [pi_lift]\n  congr\n\n"}
{"name":"Path.Homotopic.prod_lift","module":"Mathlib.Topology.Homotopy.Product","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\na₁ a₂ : α\nb₁ b₂ : β\np₁ : Path a₁ a₂\np₂ : Path b₁ b₂\n⊢ Eq (Path.Homotopic.prod (Quotient.mk (Path.Homotopic.setoid a₁ a₂) p₁) (Quotient.mk (Path.Homotopic.setoid b₁ b₂) p₂)) (Quotient.mk (Path.Homotopic.setoid { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ }) (p₁.prod p₂))","decl":"theorem prod_lift : prod ⟦p₁⟧ ⟦p₂⟧ = ⟦p₁.prod p₂⟧ :=\n  rfl\n\n"}
{"name":"Path.Homotopic.comp_prod_eq_prod_comp","module":"Mathlib.Topology.Homotopy.Product","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\na₁ a₂ a₃ : α\nb₁ b₂ b₃ : β\nq₁ : Path.Homotopic.Quotient a₁ a₂\nq₂ : Path.Homotopic.Quotient b₁ b₂\nr₁ : Path.Homotopic.Quotient a₂ a₃\nr₂ : Path.Homotopic.Quotient b₂ b₃\n⊢ Eq ((Path.Homotopic.prod q₁ q₂).comp (Path.Homotopic.prod r₁ r₂)) (Path.Homotopic.prod (q₁.comp r₁) (q₂.comp r₂))","decl":"/-- Products commute with path composition.\n    This is `trans_prod_eq_prod_trans` descended to the quotient. -/\ntheorem comp_prod_eq_prod_comp : prod q₁ q₂ ⬝ prod r₁ r₂ = prod (q₁ ⬝ r₁) (q₂ ⬝ r₂) := by\n  induction q₁, q₂ using Quotient.inductionOn₂\n  induction r₁, r₂ using Quotient.inductionOn₂\n  simp only [prod_lift, ← Path.Homotopic.comp_lift, Path.trans_prod_eq_prod_trans]\n\n"}
{"name":"Path.Homotopic.projLeft_prod","module":"Mathlib.Topology.Homotopy.Product","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\na₁ a₂ : α\nb₁ b₂ : β\nq₁ : Path.Homotopic.Quotient a₁ a₂\nq₂ : Path.Homotopic.Quotient b₁ b₂\n⊢ Eq (Path.Homotopic.projLeft (Path.Homotopic.prod q₁ q₂)) q₁","decl":"/-- Lemmas showing projection is the inverse of product. -/\n@[simp]\ntheorem projLeft_prod : projLeft (prod q₁ q₂) = q₁ := by\n  induction q₁, q₂ using Quotient.inductionOn₂\n  rw [projLeft, prod_lift, ← Path.Homotopic.map_lift]\n  congr\n\n"}
{"name":"Path.Homotopic.projRight_prod","module":"Mathlib.Topology.Homotopy.Product","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\na₁ a₂ : α\nb₁ b₂ : β\nq₁ : Path.Homotopic.Quotient a₁ a₂\nq₂ : Path.Homotopic.Quotient b₁ b₂\n⊢ Eq (Path.Homotopic.projRight (Path.Homotopic.prod q₁ q₂)) q₂","decl":"@[simp]\ntheorem projRight_prod : projRight (prod q₁ q₂) = q₂ := by\n  induction q₁, q₂ using Quotient.inductionOn₂\n  rw [projRight, prod_lift, ← Path.Homotopic.map_lift]\n  congr\n\n"}
{"name":"Path.Homotopic.prod_projLeft_projRight","module":"Mathlib.Topology.Homotopy.Product","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\na₁ a₂ : α\nb₁ b₂ : β\np : Path.Homotopic.Quotient { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ }\n⊢ Eq (Path.Homotopic.prod (Path.Homotopic.projLeft p) (Path.Homotopic.projRight p)) p","decl":"@[simp]\ntheorem prod_projLeft_projRight (p : Path.Homotopic.Quotient (a₁, b₁) (a₂, b₂)) :\n    prod (projLeft p) (projRight p) = p := by\n  induction p using Quotient.inductionOn\n  simp only [projLeft, projRight, ← Path.Homotopic.map_lift, prod_lift]\n  congr\n\n"}
