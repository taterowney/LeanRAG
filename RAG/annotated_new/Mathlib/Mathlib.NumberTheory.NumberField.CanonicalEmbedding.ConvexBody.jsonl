{"name":"NumberField.mixedEmbedding.convexBodyLT_mem","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝ : Field K\nf : NumberField.InfinitePlace K → NNReal\nx : K\n⊢ Iff (Membership.mem (NumberField.mixedEmbedding.convexBodyLT K f) ((NumberField.mixedEmbedding K) x)) (∀ (w : NumberField.InfinitePlace K), LT.lt (w x) ↑(f w))","decl":"theorem convexBodyLT_mem {x : K} :\n    mixedEmbedding K x ∈ (convexBodyLT K f) ↔ ∀ w : InfinitePlace K, w x < f w := by\n  simp_rw [mixedEmbedding, RingHom.prod_apply, Set.mem_prod, Set.mem_pi, Set.mem_univ,\n    forall_true_left, mem_ball_zero_iff, Pi.ringHom_apply, ← Complex.norm_real,\n    embedding_of_isReal_apply, Subtype.forall, ← forall₂_or_left, ← not_isReal_iff_isComplex, em,\n    forall_true_left, norm_embedding_eq]\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodyLT_neg_mem","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝ : Field K\nf : NumberField.InfinitePlace K → NNReal\nx : NumberField.mixedEmbedding.mixedSpace K\nhx : Membership.mem (NumberField.mixedEmbedding.convexBodyLT K f) x\n⊢ Membership.mem (NumberField.mixedEmbedding.convexBodyLT K f) (Neg.neg x)","decl":"theorem convexBodyLT_neg_mem (x : mixedSpace K) (hx : x ∈ (convexBodyLT K f)) :\n    -x ∈ (convexBodyLT K f) := by\n  simp only [Set.mem_prod, Prod.fst_neg, Set.mem_pi, Set.mem_univ, Pi.neg_apply,\n    mem_ball_zero_iff, norm_neg, Real.norm_eq_abs, forall_true_left, Subtype.forall,\n    Prod.snd_neg, Complex.norm_eq_abs] at hx ⊢\n  exact hx\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodyLT_convex","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝ : Field K\nf : NumberField.InfinitePlace K → NNReal\n⊢ Convex Real (NumberField.mixedEmbedding.convexBodyLT K f)","decl":"theorem convexBodyLT_convex : Convex ℝ (convexBodyLT K f) :=\n  Convex.prod (convex_pi (fun _ _ => convex_ball _ _)) (convex_pi (fun _ _ => convex_ball _ _))\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodyLTFactor_ne_zero","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\n⊢ Ne (NumberField.mixedEmbedding.convexBodyLTFactor K) 0","decl":"theorem convexBodyLTFactor_ne_zero : convexBodyLTFactor K ≠ 0 :=\n  mul_ne_zero (pow_ne_zero _ two_ne_zero) (pow_ne_zero _ pi_ne_zero)\n\n"}
{"name":"NumberField.mixedEmbedding.one_le_convexBodyLTFactor","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\n⊢ LE.le 1 (NumberField.mixedEmbedding.convexBodyLTFactor K)","decl":"theorem one_le_convexBodyLTFactor : 1 ≤ convexBodyLTFactor K :=\n  one_le_mul (one_le_pow₀ one_le_two) (one_le_pow₀ (one_le_two.trans Real.two_le_pi))\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodyLT_volume","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\nf : NumberField.InfinitePlace K → NNReal\ninst✝ : NumberField K\n⊢ Eq (MeasureTheory.MeasureSpace.volume (NumberField.mixedEmbedding.convexBodyLT K f)) (HMul.hMul ↑(NumberField.mixedEmbedding.convexBodyLTFactor K) ↑(Finset.univ.prod fun w => HPow.hPow (f w) w.mult))","decl":"open scoped Classical in\n/-- The volume of `(ConvexBodyLt K f)` where `convexBodyLT K f` is the set of points `x`\nsuch that `‖x w‖ < f w` for all infinite places `w`. -/\ntheorem convexBodyLT_volume :\n    volume (convexBodyLT K f) = (convexBodyLTFactor K) * ∏ w, (f w) ^ (mult w) := by\n  calc\n    _ = (∏ x : {w // InfinitePlace.IsReal w}, ENNReal.ofReal (2 * (f x.val))) *\n          ∏ x : {w // InfinitePlace.IsComplex w}, ENNReal.ofReal (f x.val) ^ 2 * NNReal.pi := by\n      simp_rw [volume_eq_prod, prod_prod, volume_pi, pi_pi, Real.volume_ball, Complex.volume_ball]\n    _ = ((2 : ℝ≥0) ^ nrRealPlaces K\n          * (∏ x : {w // InfinitePlace.IsReal w}, ENNReal.ofReal (f x.val)))\n          * ((∏ x : {w // IsComplex w}, ENNReal.ofReal (f x.val) ^ 2) *\n            NNReal.pi ^ nrComplexPlaces K) := by\n      simp_rw [ofReal_mul (by norm_num : 0 ≤ (2 : ℝ)), Finset.prod_mul_distrib, Finset.prod_const,\n        Finset.card_univ, ofReal_ofNat, ofReal_coe_nnreal, coe_ofNat]\n    _ = (convexBodyLTFactor K) * ((∏ x : {w // InfinitePlace.IsReal w}, .ofReal (f x.val)) *\n        (∏ x : {w // IsComplex w}, ENNReal.ofReal (f x.val) ^ 2)) := by\n      simp_rw [convexBodyLTFactor, coe_mul, ENNReal.coe_pow]\n      ring\n    _ = (convexBodyLTFactor K) * ∏ w, (f w) ^ (mult w) := by\n      simp_rw [mult, pow_ite, pow_one, Finset.prod_ite, ofReal_coe_nnreal, not_isReal_iff_isComplex,\n        coe_mul, coe_finset_prod, ENNReal.coe_pow]\n      congr 2\n      · refine (Finset.prod_subtype (Finset.univ.filter _) ?_ (fun w => (f w : ℝ≥0∞))).symm\n        exact fun _ => by simp only [Finset.mem_univ, forall_true_left, Finset.mem_filter, true_and]\n      · refine (Finset.prod_subtype (Finset.univ.filter _) ?_ (fun w => (f w : ℝ≥0∞) ^ 2)).symm\n        exact fun _ => by simp only [Finset.mem_univ, forall_true_left, Finset.mem_filter, true_and]\n\n"}
{"name":"NumberField.mixedEmbedding.adjust_f","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\nf : NumberField.InfinitePlace K → NNReal\ninst✝ : NumberField K\nw₁ : NumberField.InfinitePlace K\nB : NNReal\nhf : ∀ (w : NumberField.InfinitePlace K), Ne w w₁ → Ne (f w) 0\n⊢ Exists fun g => And (∀ (w : NumberField.InfinitePlace K), Ne w w₁ → Eq (g w) (f w)) (Eq (Finset.univ.prod fun w => HPow.hPow (g w) w.mult) B)","decl":"/-- This is a technical result: quite often, we want to impose conditions at all infinite places\nbut one and choose the value at the remaining place so that we can apply\n`exists_ne_zero_mem_ringOfIntegers_lt`. -/\ntheorem adjust_f {w₁ : InfinitePlace K} (B : ℝ≥0) (hf : ∀ w, w ≠ w₁ → f w ≠ 0) :\n    ∃ g : InfinitePlace K → ℝ≥0, (∀ w, w ≠ w₁ → g w = f w) ∧ ∏ w, (g w) ^ mult w = B := by\n  classical\n  let S := ∏ w ∈ Finset.univ.erase w₁, (f w) ^ mult w\n  refine ⟨Function.update f w₁ ((B * S⁻¹) ^ (mult w₁ : ℝ)⁻¹), ?_, ?_⟩\n  · exact fun w hw => Function.update_of_ne hw _ f\n  · rw [← Finset.mul_prod_erase Finset.univ _ (Finset.mem_univ w₁), Function.update_self,\n      Finset.prod_congr rfl fun w hw => by rw [Function.update_of_ne (Finset.ne_of_mem_erase hw)],\n      ← NNReal.rpow_natCast, ← NNReal.rpow_mul, inv_mul_cancel₀, NNReal.rpow_one, mul_assoc,\n      inv_mul_cancel₀, mul_one]\n    · rw [Finset.prod_ne_zero_iff]\n      exact fun w hw => pow_ne_zero _ (hf w (Finset.ne_of_mem_erase hw))\n    · rw [mult]; split_ifs <;> norm_num\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodyLT'_mem","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝ : Field K\nf : NumberField.InfinitePlace K → NNReal\nw₀ : Subtype fun w => w.IsComplex\nx : K\n⊢ Iff (Membership.mem (NumberField.mixedEmbedding.convexBodyLT' K f w₀) ((NumberField.mixedEmbedding K) x)) (And (∀ (w : NumberField.InfinitePlace K), Ne w ↑w₀ → LT.lt (w x) ↑(f w)) (And (LT.lt (abs ((↑w₀).embedding x).re) 1) (LT.lt (abs ((↑w₀).embedding x).im) (HPow.hPow (↑(f ↑w₀)) 2))))","decl":"theorem convexBodyLT'_mem {x : K} :\n    mixedEmbedding K x ∈ convexBodyLT' K f w₀ ↔\n      (∀ w : InfinitePlace K, w ≠ w₀ → w x < f w) ∧\n      |(w₀.val.embedding x).re| < 1 ∧ |(w₀.val.embedding x).im| < (f w₀ : ℝ) ^ 2 := by\n  simp_rw [mixedEmbedding, RingHom.prod_apply, Set.mem_prod, Set.mem_pi, Set.mem_univ,\n    forall_true_left, Pi.ringHom_apply, mem_ball_zero_iff, ← Complex.norm_real,\n    embedding_of_isReal_apply, norm_embedding_eq, Subtype.forall]\n  refine ⟨fun ⟨h₁, h₂⟩ ↦ ⟨fun w h_ne ↦ ?_, ?_⟩, fun ⟨h₁, h₂⟩ ↦ ⟨fun w hw ↦ ?_, fun w hw ↦ ?_⟩⟩\n  · by_cases hw : IsReal w\n    · exact norm_embedding_eq w _ ▸ h₁ w hw\n    · specialize h₂ w (not_isReal_iff_isComplex.mp hw)\n      rw [apply_ite (w.embedding x ∈ ·), Set.mem_setOf_eq,\n        mem_ball_zero_iff, norm_embedding_eq] at h₂\n      rwa [if_neg (by exact Subtype.coe_ne_coe.1 h_ne)] at h₂\n  · simpa [if_true] using h₂ w₀.val w₀.prop\n  · exact h₁ w (ne_of_isReal_isComplex hw w₀.prop)\n  · by_cases h_ne : w = w₀\n    · simpa [h_ne]\n    · rw [if_neg (by exact Subtype.coe_ne_coe.1 h_ne)]\n      rw [mem_ball_zero_iff, norm_embedding_eq]\n      exact h₁ w h_ne\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodyLT'_neg_mem","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝ : Field K\nf : NumberField.InfinitePlace K → NNReal\nw₀ : Subtype fun w => w.IsComplex\nx : NumberField.mixedEmbedding.mixedSpace K\nhx : Membership.mem (NumberField.mixedEmbedding.convexBodyLT' K f w₀) x\n⊢ Membership.mem (NumberField.mixedEmbedding.convexBodyLT' K f w₀) (Neg.neg x)","decl":"theorem convexBodyLT'_neg_mem (x : mixedSpace K) (hx : x ∈ convexBodyLT' K f w₀) :\n    -x ∈ convexBodyLT' K f w₀ := by\n  simp only [Set.mem_prod, Set.mem_pi, Set.mem_univ, mem_ball, dist_zero_right, Real.norm_eq_abs,\n    true_implies, Subtype.forall, Prod.fst_neg, Pi.neg_apply, norm_neg, Prod.snd_neg] at hx ⊢\n  convert hx using 3\n  split_ifs <;> simp\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodyLT'_convex","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝ : Field K\nf : NumberField.InfinitePlace K → NNReal\nw₀ : Subtype fun w => w.IsComplex\n⊢ Convex Real (NumberField.mixedEmbedding.convexBodyLT' K f w₀)","decl":"theorem convexBodyLT'_convex : Convex ℝ (convexBodyLT' K f w₀) := by\n  refine Convex.prod (convex_pi (fun _ _ => convex_ball _ _)) (convex_pi (fun _ _ => ?_))\n  split_ifs\n  · simp_rw [abs_lt]\n    refine Convex.inter ((convex_halfSpace_re_gt _).inter (convex_halfSpace_re_lt _))\n      ((convex_halfSpace_im_gt _).inter (convex_halfSpace_im_lt _))\n  · exact convex_ball _ _\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodyLT'Factor_ne_zero","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\n⊢ Ne (NumberField.mixedEmbedding.convexBodyLT'Factor K) 0","decl":"theorem convexBodyLT'Factor_ne_zero : convexBodyLT'Factor K ≠ 0 :=\n  mul_ne_zero (pow_ne_zero _ two_ne_zero) (pow_ne_zero _ pi_ne_zero)\n\n"}
{"name":"NumberField.mixedEmbedding.one_le_convexBodyLT'Factor","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\n⊢ LE.le 1 (NumberField.mixedEmbedding.convexBodyLT'Factor K)","decl":"theorem one_le_convexBodyLT'Factor : 1 ≤ convexBodyLT'Factor K :=\n  one_le_mul (one_le_pow₀ one_le_two) (one_le_pow₀ (one_le_two.trans Real.two_le_pi))\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodyLT'_volume","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\nf : NumberField.InfinitePlace K → NNReal\nw₀ : Subtype fun w => w.IsComplex\ninst✝ : NumberField K\n⊢ Eq (MeasureTheory.MeasureSpace.volume (NumberField.mixedEmbedding.convexBodyLT' K f w₀)) (HMul.hMul ↑(NumberField.mixedEmbedding.convexBodyLT'Factor K) ↑(Finset.univ.prod fun w => HPow.hPow (f w) w.mult))","decl":"open scoped Classical in\ntheorem convexBodyLT'_volume :\n    volume (convexBodyLT' K f w₀) = convexBodyLT'Factor K * ∏ w, (f w) ^ (mult w) := by\n  have vol_box : ∀ B : ℝ≥0, volume {x : ℂ | |x.re| < 1 ∧ |x.im| < B^2} = 4*B^2 := by\n    intro B\n    rw [← (Complex.volume_preserving_equiv_real_prod.symm).measure_preimage]\n    · simp_rw [Set.preimage_setOf_eq, Complex.measurableEquivRealProd_symm_apply]\n      rw [show {a : ℝ × ℝ | |a.1| < 1 ∧ |a.2| < B ^ 2} =\n        Set.Ioo (-1 : ℝ) (1 : ℝ) ×ˢ Set.Ioo (- (B : ℝ) ^ 2) ((B : ℝ) ^ 2) by\n          ext; simp_rw [Set.mem_setOf_eq, Set.mem_prod, Set.mem_Ioo, abs_lt]]\n      simp_rw [volume_eq_prod, prod_prod, Real.volume_Ioo, sub_neg_eq_add, one_add_one_eq_two,\n        ← two_mul, ofReal_mul zero_le_two, ofReal_pow (coe_nonneg B), ofReal_ofNat,\n        ofReal_coe_nnreal, ← mul_assoc, show (2 : ℝ≥0∞) * 2 = 4 by norm_num]\n    · refine (MeasurableSet.inter ?_ ?_).nullMeasurableSet\n      · exact measurableSet_lt (measurable_norm.comp Complex.measurable_re) measurable_const\n      · exact measurableSet_lt (measurable_norm.comp Complex.measurable_im) measurable_const\n  calc\n    _ = (∏ x : {w // InfinitePlace.IsReal w}, ENNReal.ofReal (2 * (f x.val))) *\n          ((∏ x ∈ Finset.univ.erase  w₀, ENNReal.ofReal (f x.val) ^ 2 * pi) *\n          (4 * (f w₀) ^ 2)) := by\n      simp_rw [volume_eq_prod, prod_prod, volume_pi, pi_pi, Real.volume_ball]\n      rw [← Finset.prod_erase_mul _ _ (Finset.mem_univ w₀)]\n      congr 2\n      · refine Finset.prod_congr rfl (fun w' hw' ↦ ?_)\n        rw [if_neg (Finset.ne_of_mem_erase hw'), Complex.volume_ball]\n      · simpa only [ite_true] using vol_box (f w₀)\n    _ = ((2 : ℝ≥0) ^ nrRealPlaces K *\n          (∏ x : {w // InfinitePlace.IsReal w}, ENNReal.ofReal (f x.val))) *\n            ((∏ x ∈ Finset.univ.erase  w₀, ENNReal.ofReal (f x.val) ^ 2) *\n              ↑pi ^ (nrComplexPlaces K - 1) * (4 * (f w₀) ^ 2)) := by\n      simp_rw [ofReal_mul (by norm_num : 0 ≤ (2 : ℝ)), Finset.prod_mul_distrib, Finset.prod_const,\n        Finset.card_erase_of_mem (Finset.mem_univ _), Finset.card_univ, ofReal_ofNat,\n        ofReal_coe_nnreal, coe_ofNat]\n    _ = convexBodyLT'Factor K * (∏ x : {w // InfinitePlace.IsReal w}, ENNReal.ofReal (f x.val))\n        * (∏ x : {w // IsComplex w}, ENNReal.ofReal (f x.val) ^ 2) := by\n      rw [show (4 : ℝ≥0∞) = (2 : ℝ≥0) ^ 2 by norm_num, convexBodyLT'Factor, pow_add,\n        ← Finset.prod_erase_mul _ _ (Finset.mem_univ w₀), ofReal_coe_nnreal]\n      simp_rw [coe_mul, ENNReal.coe_pow]\n      ring\n    _ = convexBodyLT'Factor K * ∏ w, (f w) ^ (mult w) := by\n      simp_rw [mult, pow_ite, pow_one, Finset.prod_ite, ofReal_coe_nnreal, not_isReal_iff_isComplex,\n        coe_mul, coe_finset_prod, ENNReal.coe_pow, mul_assoc]\n      congr 3\n      · refine (Finset.prod_subtype (Finset.univ.filter _) ?_ (fun w => (f w : ℝ≥0∞))).symm\n        exact fun _ => by simp only [Finset.mem_univ, forall_true_left, Finset.mem_filter, true_and]\n      · refine (Finset.prod_subtype (Finset.univ.filter _) ?_ (fun w => (f w : ℝ≥0∞) ^ 2)).symm\n        exact fun _ => by simp only [Finset.mem_univ, forall_true_left, Finset.mem_filter, true_and]\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodySumFun_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\n⊢ Eq (NumberField.mixedEmbedding.convexBodySumFun x) (Finset.univ.sum fun w => HMul.hMul (↑w.mult) ((NumberField.mixedEmbedding.normAtPlace w) x))","decl":"theorem convexBodySumFun_apply (x : mixedSpace K) :\n    convexBodySumFun x = ∑ w,  mult w * normAtPlace w x := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodySumFun_apply'","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\n⊢ Eq (NumberField.mixedEmbedding.convexBodySumFun x) (HAdd.hAdd (Finset.univ.sum fun w => Norm.norm (x.1 w)) (HMul.hMul 2 (Finset.univ.sum fun w => Norm.norm (x.2 w))))","decl":"open scoped Classical in\ntheorem convexBodySumFun_apply' (x : mixedSpace K) :\n    convexBodySumFun x = ∑ w, ‖x.1 w‖ + 2 * ∑ w, ‖x.2 w‖ := by\n  simp_rw [convexBodySumFun_apply, ← Finset.sum_add_sum_compl {w | IsReal w}.toFinset,\n    Set.toFinset_setOf, Finset.compl_filter, not_isReal_iff_isComplex, ← Finset.subtype_univ,\n    ← Finset.univ.sum_subtype_eq_sum_filter, Finset.mul_sum]\n  congr\n  · ext w\n    rw [mult, if_pos w.prop, normAtPlace_apply_isReal, Nat.cast_one, one_mul]\n  · ext w\n    rw [mult, if_neg (not_isReal_iff_isComplex.mpr w.prop), normAtPlace_apply_isComplex,\n      Nat.cast_ofNat]\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodySumFun_nonneg","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\n⊢ LE.le 0 (NumberField.mixedEmbedding.convexBodySumFun x)","decl":"theorem convexBodySumFun_nonneg (x : mixedSpace K) :\n    0 ≤ convexBodySumFun x :=\n  Finset.sum_nonneg (fun _ _ => mul_nonneg (Nat.cast_pos.mpr mult_pos).le (normAtPlace_nonneg _ _))\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodySumFun_neg","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\n⊢ Eq (NumberField.mixedEmbedding.convexBodySumFun (Neg.neg x)) (NumberField.mixedEmbedding.convexBodySumFun x)","decl":"theorem convexBodySumFun_neg (x : mixedSpace K) :\n    convexBodySumFun (- x) = convexBodySumFun x := by\n  simp_rw [convexBodySumFun, normAtPlace_neg]\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodySumFun_add_le","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nx y : NumberField.mixedEmbedding.mixedSpace K\n⊢ LE.le (NumberField.mixedEmbedding.convexBodySumFun (HAdd.hAdd x y)) (HAdd.hAdd (NumberField.mixedEmbedding.convexBodySumFun x) (NumberField.mixedEmbedding.convexBodySumFun y))","decl":"theorem convexBodySumFun_add_le (x y : mixedSpace K) :\n    convexBodySumFun (x + y) ≤ convexBodySumFun x + convexBodySumFun y := by\n  simp_rw [convexBodySumFun, ← Finset.sum_add_distrib, ← mul_add]\n  exact Finset.sum_le_sum\n    fun _ _ ↦ mul_le_mul_of_nonneg_left (normAtPlace_add_le _ x y) (Nat.cast_pos.mpr mult_pos).le\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodySumFun_smul","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nc : Real\nx : NumberField.mixedEmbedding.mixedSpace K\n⊢ Eq (NumberField.mixedEmbedding.convexBodySumFun (HSMul.hSMul c x)) (HMul.hMul (abs c) (NumberField.mixedEmbedding.convexBodySumFun x))","decl":"theorem convexBodySumFun_smul (c : ℝ) (x : mixedSpace K) :\n    convexBodySumFun (c • x) = |c| * convexBodySumFun x := by\n  simp_rw [convexBodySumFun, normAtPlace_smul, ← mul_assoc, mul_comm, Finset.mul_sum, mul_assoc]\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodySumFun_eq_zero_iff","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\n⊢ Iff (Eq (NumberField.mixedEmbedding.convexBodySumFun x) 0) (Eq x 0)","decl":"theorem convexBodySumFun_eq_zero_iff (x : mixedSpace K) :\n    convexBodySumFun x = 0 ↔ x = 0 := by\n  rw [← forall_normAtPlace_eq_zero_iff, convexBodySumFun, Finset.sum_eq_zero_iff_of_nonneg\n    fun _ _ ↦ mul_nonneg (Nat.cast_pos.mpr mult_pos).le (normAtPlace_nonneg _ _)]\n  conv =>\n    enter [1, w, hw]\n    rw [mul_left_mem_nonZeroDivisors_eq_zero_iff\n      (mem_nonZeroDivisors_iff_ne_zero.mpr <| Nat.cast_ne_zero.mpr mult_ne_zero)]\n  simp_rw [Finset.mem_univ, true_implies]\n\n"}
{"name":"NumberField.mixedEmbedding.norm_le_convexBodySumFun","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\n⊢ LE.le (Norm.norm x) (NumberField.mixedEmbedding.convexBodySumFun x)","decl":"open scoped Classical in\ntheorem norm_le_convexBodySumFun (x : mixedSpace K) : ‖x‖ ≤ convexBodySumFun x := by\n  rw [norm_eq_sup'_normAtPlace]\n  refine (Finset.sup'_le_iff _ _).mpr fun w _ ↦ ?_\n  rw [convexBodySumFun_apply, ← Finset.univ.add_sum_erase _ (Finset.mem_univ w)]\n  refine le_add_of_le_of_nonneg  ?_ ?_\n  · exact le_mul_of_one_le_left (normAtPlace_nonneg w x) one_le_mult\n  · exact Finset.sum_nonneg (fun _ _ => mul_nonneg (Nat.cast_pos.mpr mult_pos).le\n      (normAtPlace_nonneg _ _))\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodySumFun_continuous","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\n⊢ Continuous NumberField.mixedEmbedding.convexBodySumFun","decl":"theorem convexBodySumFun_continuous :\n    Continuous (convexBodySumFun : mixedSpace K → ℝ) := by\n  refine continuous_finset_sum Finset.univ fun w ↦ ?_\n  obtain hw | hw := isReal_or_isComplex w\n  all_goals\n  · simp only [normAtPlace_apply_isReal, normAtPlace_apply_isComplex, hw]\n    fun_prop\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodySum_volume_eq_zero_of_le_zero","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nB : Real\nhB : LE.le B 0\n⊢ Eq (MeasureTheory.MeasureSpace.volume (NumberField.mixedEmbedding.convexBodySum K B)) 0","decl":"open scoped Classical in\ntheorem convexBodySum_volume_eq_zero_of_le_zero {B} (hB : B ≤ 0) :\n    volume (convexBodySum K B) = 0 := by\n  obtain hB | hB := lt_or_eq_of_le hB\n  · suffices convexBodySum K B = ∅ by rw [this, measure_empty]\n    ext x\n    refine ⟨fun hx => ?_, fun h => h.elim⟩\n    rw [Set.mem_setOf] at hx\n    linarith [convexBodySumFun_nonneg x]\n  · suffices convexBodySum K B = { 0 } by rw [this, measure_singleton]\n    ext\n    rw [convexBodySum, Set.mem_setOf_eq, Set.mem_singleton_iff, hB, ← convexBodySumFun_eq_zero_iff]\n    exact (convexBodySumFun_nonneg _).le_iff_eq\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodySum_mem","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nB : Real\nx : K\n⊢ Iff (Membership.mem (NumberField.mixedEmbedding.convexBodySum K B) ((NumberField.mixedEmbedding K) x)) (LE.le (Finset.univ.sum fun w => HMul.hMul (↑w.mult) (↑w x)) B)","decl":"theorem convexBodySum_mem {x : K} :\n    mixedEmbedding K x ∈ (convexBodySum K B) ↔\n      ∑ w : InfinitePlace K, (mult w) * w.val x ≤ B := by\n  simp_rw [Set.mem_setOf_eq, convexBodySumFun, normAtPlace_apply]\n  rfl\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodySum_neg_mem","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nB : Real\nx : NumberField.mixedEmbedding.mixedSpace K\nhx : Membership.mem (NumberField.mixedEmbedding.convexBodySum K B) x\n⊢ Membership.mem (NumberField.mixedEmbedding.convexBodySum K B) (Neg.neg x)","decl":"theorem convexBodySum_neg_mem {x : mixedSpace K} (hx : x ∈ (convexBodySum K B)) :\n    -x ∈ (convexBodySum K B) := by\n  rw [Set.mem_setOf, convexBodySumFun_neg]\n  exact hx\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodySum_convex","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nB : Real\n⊢ Convex Real (NumberField.mixedEmbedding.convexBodySum K B)","decl":"theorem convexBodySum_convex : Convex ℝ (convexBodySum K B) := by\n  refine Convex_subadditive_le (fun _ _ => convexBodySumFun_add_le _ _) (fun c x h => ?_) B\n  convert le_of_eq (convexBodySumFun_smul c x)\n  exact (abs_eq_self.mpr h).symm\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodySum_isBounded","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nB : Real\n⊢ Bornology.IsBounded (NumberField.mixedEmbedding.convexBodySum K B)","decl":"theorem convexBodySum_isBounded : Bornology.IsBounded (convexBodySum K B) := by\n  classical\n  refine Metric.isBounded_iff.mpr ⟨B + B, fun x hx y hy => ?_⟩\n  refine le_trans (norm_sub_le x y) (add_le_add ?_ ?_)\n  · exact le_trans (norm_le_convexBodySumFun x) hx\n  · exact le_trans (norm_le_convexBodySumFun y) hy\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodySum_compact","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nB : Real\n⊢ IsCompact (NumberField.mixedEmbedding.convexBodySum K B)","decl":"theorem convexBodySum_compact : IsCompact (convexBodySum K B) := by\n  classical\n  rw [Metric.isCompact_iff_isClosed_bounded]\n  refine ⟨?_, convexBodySum_isBounded K B⟩\n  convert IsClosed.preimage (convexBodySumFun_continuous K) (isClosed_Icc : IsClosed (Set.Icc 0 B))\n  ext\n  simp [convexBodySumFun_nonneg]\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodySumFactor_ne_zero","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\n⊢ Ne (NumberField.mixedEmbedding.convexBodySumFactor K) 0","decl":"theorem convexBodySumFactor_ne_zero : convexBodySumFactor K ≠ 0 := by\n  refine div_ne_zero ?_ <| Nat.cast_ne_zero.mpr (Nat.factorial_ne_zero _)\n  exact mul_ne_zero (pow_ne_zero _ two_ne_zero)\n    (pow_ne_zero _ (div_ne_zero NNReal.pi_ne_zero two_ne_zero))\n\n"}
{"name":"NumberField.mixedEmbedding.convexBodySum_volume","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nB : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (NumberField.mixedEmbedding.convexBodySum K B)) (HMul.hMul (↑(NumberField.mixedEmbedding.convexBodySumFactor K)) (HPow.hPow (ENNReal.ofReal B) (Module.finrank Rat K)))","decl":"open MeasureTheory MeasureTheory.Measure Real in\nopen scoped Classical in\ntheorem convexBodySum_volume :\n    volume (convexBodySum K B) = (convexBodySumFactor K) * (.ofReal B) ^ (finrank ℚ K) := by\n  obtain hB | hB := le_or_lt B 0\n  · rw [convexBodySum_volume_eq_zero_of_le_zero K hB, ofReal_eq_zero.mpr hB, zero_pow, mul_zero]\n    exact finrank_pos.ne'\n  · suffices volume (convexBodySum K 1) = (convexBodySumFactor K) by\n      rw [mul_comm]\n      convert addHaar_smul volume B (convexBodySum K 1)\n      · simp_rw [← Set.preimage_smul_inv₀ (ne_of_gt hB), Set.preimage_setOf_eq, convexBodySumFun,\n        normAtPlace_smul, abs_inv, abs_eq_self.mpr (le_of_lt hB), ← mul_assoc, mul_comm, mul_assoc,\n        ← Finset.mul_sum, inv_mul_le_iff₀ hB, mul_one]\n      · rw [abs_pow, ofReal_pow (abs_nonneg _), abs_eq_self.mpr (le_of_lt hB),\n          mixedEmbedding.finrank]\n      · exact this.symm\n    rw [MeasureTheory.measure_le_eq_lt _ ((convexBodySumFun_eq_zero_iff 0).mpr rfl)\n      convexBodySumFun_neg convexBodySumFun_add_le\n      (fun hx => (convexBodySumFun_eq_zero_iff _).mp hx)\n      (fun r x => le_of_eq (convexBodySumFun_smul r x))]\n    rw [measure_lt_one_eq_integral_div_gamma (g := fun x : (mixedSpace K) => convexBodySumFun x)\n      volume ((convexBodySumFun_eq_zero_iff 0).mpr rfl) convexBodySumFun_neg convexBodySumFun_add_le\n      (fun hx => (convexBodySumFun_eq_zero_iff _).mp hx)\n      (fun r x => le_of_eq (convexBodySumFun_smul r x)) zero_lt_one]\n    simp_rw [mixedEmbedding.finrank, div_one, Gamma_nat_eq_factorial, ofReal_div_of_pos\n      (Nat.cast_pos.mpr (Nat.factorial_pos _)), Real.rpow_one, ofReal_natCast]\n    suffices ∫ x : mixedSpace K, exp (-convexBodySumFun x) =\n        (2 : ℝ) ^ nrRealPlaces K * (π / 2) ^ nrComplexPlaces K by\n      rw [this, convexBodySumFactor, ofReal_mul (by positivity), ofReal_pow zero_le_two,\n        ofReal_pow (by positivity), ofReal_div_of_pos zero_lt_two, ofReal_ofNat,\n        ← NNReal.coe_real_pi, ofReal_coe_nnreal, coe_div (Nat.cast_ne_zero.mpr\n        (Nat.factorial_ne_zero _)), coe_mul, coe_pow, coe_pow, coe_ofNat, coe_div two_ne_zero,\n        coe_ofNat, coe_natCast]\n    calc\n      _ = (∫ x : {w : InfinitePlace K // IsReal w} → ℝ, ∏ w, exp (- ‖x w‖)) *\n              (∫ x : {w : InfinitePlace K // IsComplex w} → ℂ, ∏ w, exp (- 2 * ‖x w‖)) := by\n        simp_rw [convexBodySumFun_apply', neg_add, ← neg_mul, Finset.mul_sum,\n          ← Finset.sum_neg_distrib, exp_add, exp_sum, ← integral_prod_mul, volume_eq_prod]\n      _ = (∫ x : ℝ, exp (-|x|)) ^ nrRealPlaces K *\n              (∫ x : ℂ, Real.exp (-2 * ‖x‖)) ^ nrComplexPlaces K := by\n        rw [integral_fintype_prod_eq_pow _ (fun x => exp (- ‖x‖)), integral_fintype_prod_eq_pow _\n          (fun x => exp (- 2 * ‖x‖))]\n        simp_rw [norm_eq_abs]\n      _ =  (2 * Gamma (1 / 1 + 1)) ^ nrRealPlaces K *\n              (π * (2 : ℝ) ^ (-(2 : ℝ) / 1) * Gamma (2 / 1 + 1)) ^ nrComplexPlaces K := by\n        rw [integral_comp_abs (f := fun x => exp (- x)), ← integral_exp_neg_rpow zero_lt_one,\n          ← Complex.integral_exp_neg_mul_rpow le_rfl zero_lt_two]\n        simp_rw [Real.rpow_one]\n      _ = (2 : ℝ) ^ nrRealPlaces K * (π / 2) ^ nrComplexPlaces K := by\n        simp_rw [div_one, one_add_one_eq_two, Gamma_add_one two_ne_zero, Gamma_two, mul_one,\n          mul_assoc, ← Real.rpow_add_one two_ne_zero, show (-2 : ℝ) + 1 = -1 by norm_num,\n          Real.rpow_neg_one, div_eq_mul_inv]\n\n"}
{"name":"NumberField.mixedEmbedding.volume_fundamentalDomain_fractionalIdealLatticeBasis","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nI : Units (FractionalIdeal (nonZeroDivisors (NumberField.RingOfIntegers K)) K)\n⊢ Eq (MeasureTheory.MeasureSpace.volume (ZSpan.fundamentalDomain (NumberField.mixedEmbedding.fractionalIdealLatticeBasis K I))) (HMul.hMul (ENNReal.ofReal ↑(FractionalIdeal.absNorm ↑I)) (MeasureTheory.MeasureSpace.volume (ZSpan.fundamentalDomain (NumberField.mixedEmbedding.latticeBasis K))))","decl":"open scoped Classical in\ntheorem volume_fundamentalDomain_fractionalIdealLatticeBasis :\n    volume (fundamentalDomain (fractionalIdealLatticeBasis K I)) =\n      .ofReal (FractionalIdeal.absNorm I.1) *  volume (fundamentalDomain (latticeBasis K)) := by\n  let e : (Module.Free.ChooseBasisIndex ℤ I) ≃ (Module.Free.ChooseBasisIndex ℤ (𝓞 K)) := by\n    refine Fintype.equivOfCardEq ?_\n    rw [← finrank_eq_card_chooseBasisIndex, ← finrank_eq_card_chooseBasisIndex,\n      fractionalIdeal_rank]\n  rw [← fundamentalDomain_reindex (fractionalIdealLatticeBasis K I) e,\n    measure_fundamentalDomain ((fractionalIdealLatticeBasis K I).reindex e)]\n  · rw [show (fractionalIdealLatticeBasis K I).reindex e = (mixedEmbedding K) ∘\n        (basisOfFractionalIdeal K I) ∘ e.symm by\n      ext1; simp only [Basis.coe_reindex, Function.comp_apply, fractionalIdealLatticeBasis_apply]]\n    rw [mixedEmbedding.det_basisOfFractionalIdeal_eq_norm]\n\n"}
{"name":"NumberField.mixedEmbedding.minkowskiBound_lt_top","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nI : Units (FractionalIdeal (nonZeroDivisors (NumberField.RingOfIntegers K)) K)\n⊢ LT.lt (NumberField.mixedEmbedding.minkowskiBound K I) Top.top","decl":"theorem minkowskiBound_lt_top : minkowskiBound K I < ⊤ := by\n  classical\n  refine ENNReal.mul_lt_top ?_ ?_\n  · exact (fundamentalDomain_isBounded _).measure_lt_top\n  · exact ENNReal.pow_lt_top (lt_top_iff_ne_top.mpr ENNReal.ofNat_ne_top) _\n\n"}
{"name":"NumberField.mixedEmbedding.minkowskiBound_pos","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nI : Units (FractionalIdeal (nonZeroDivisors (NumberField.RingOfIntegers K)) K)\n⊢ LT.lt 0 (NumberField.mixedEmbedding.minkowskiBound K I)","decl":"theorem minkowskiBound_pos : 0 < minkowskiBound K I := by\n  classical\n  refine zero_lt_iff.mpr (mul_ne_zero ?_ ?_)\n  · exact ZSpan.measure_fundamentalDomain_ne_zero _\n  · exact ENNReal.pow_ne_zero two_ne_zero _\n\n"}
{"name":"NumberField.mixedEmbedding.exists_ne_zero_mem_ideal_lt","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nf : NumberField.InfinitePlace K → NNReal\nI : Units (FractionalIdeal (nonZeroDivisors (NumberField.RingOfIntegers K)) K)\nh : LT.lt (NumberField.mixedEmbedding.minkowskiBound K I) (MeasureTheory.MeasureSpace.volume (NumberField.mixedEmbedding.convexBodyLT K f))\n⊢ Exists fun a => And (Membership.mem (↑I) a) (And (Ne a 0) (∀ (w : NumberField.InfinitePlace K), LT.lt (w a) ↑(f w)))","decl":"open scoped Classical in\n/-- Let `I` be a fractional ideal of `K`. Assume that `f : InfinitePlace K → ℝ≥0` is such that\n`minkowskiBound K I < volume (convexBodyLT K f)` where `convexBodyLT K f` is the set of\npoints `x` such that `‖x w‖ < f w` for all infinite places `w` (see `convexBodyLT_volume` for\nthe computation of this volume), then there exists a nonzero algebraic number `a` in `I` such\nthat `w a < f w` for all infinite places `w`. -/\ntheorem exists_ne_zero_mem_ideal_lt (h : minkowskiBound K I < volume (convexBodyLT K f)) :\n    ∃ a ∈ (I : FractionalIdeal (𝓞 K)⁰ K), a ≠ 0 ∧ ∀ w : InfinitePlace K, w a < f w := by\n  have h_fund := ZSpan.isAddFundamentalDomain' (fractionalIdealLatticeBasis K I) volume\n  have : Countable (span ℤ (Set.range (fractionalIdealLatticeBasis K I))).toAddSubgroup := by\n    change Countable (span ℤ (Set.range (fractionalIdealLatticeBasis K I)))\n    infer_instance\n  obtain ⟨⟨x, hx⟩, h_nz, h_mem⟩ := exists_ne_zero_mem_lattice_of_measure_mul_two_pow_lt_measure\n    h_fund (convexBodyLT_neg_mem K f) (convexBodyLT_convex K f) h\n  rw [mem_toAddSubgroup, mem_span_fractionalIdealLatticeBasis] at hx\n  obtain ⟨a, ha, rfl⟩ := hx\n  exact ⟨a, ha, by simpa using h_nz, (convexBodyLT_mem K f).mp h_mem⟩\n\n"}
{"name":"NumberField.mixedEmbedding.exists_ne_zero_mem_ideal_lt'","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nf : NumberField.InfinitePlace K → NNReal\nI : Units (FractionalIdeal (nonZeroDivisors (NumberField.RingOfIntegers K)) K)\nw₀ : Subtype fun w => w.IsComplex\nh : LT.lt (NumberField.mixedEmbedding.minkowskiBound K I) (MeasureTheory.MeasureSpace.volume (NumberField.mixedEmbedding.convexBodyLT' K f w₀))\n⊢ Exists fun a => And (Membership.mem (↑I) a) (And (Ne a 0) (And (∀ (w : NumberField.InfinitePlace K), Ne w ↑w₀ → LT.lt (w a) ↑(f w)) (And (LT.lt (abs ((↑w₀).embedding a).re) 1) (LT.lt (abs ((↑w₀).embedding a).im) (HPow.hPow (↑(f ↑w₀)) 2)))))","decl":"open scoped Classical in\n/-- A version of `exists_ne_zero_mem_ideal_lt` where the absolute value of the real part of `a` is\nsmaller than `1` at some fixed complex place. This is useful to ensure that `a` is not real. -/\ntheorem exists_ne_zero_mem_ideal_lt' (w₀ : {w : InfinitePlace K // IsComplex w})\n    (h : minkowskiBound K I < volume (convexBodyLT' K f w₀)) :\n    ∃ a ∈ (I : FractionalIdeal (𝓞 K)⁰ K), a ≠ 0 ∧ (∀ w : InfinitePlace K, w ≠ w₀ → w a < f w) ∧\n      |(w₀.val.embedding a).re| < 1 ∧ |(w₀.val.embedding a).im| < (f w₀ : ℝ) ^ 2 := by\n  have h_fund := ZSpan.isAddFundamentalDomain' (fractionalIdealLatticeBasis K I) volume\n  have : Countable (span ℤ (Set.range (fractionalIdealLatticeBasis K I))).toAddSubgroup := by\n    change Countable (span ℤ (Set.range (fractionalIdealLatticeBasis K I)))\n    infer_instance\n  obtain ⟨⟨x, hx⟩, h_nz, h_mem⟩ := exists_ne_zero_mem_lattice_of_measure_mul_two_pow_lt_measure\n    h_fund (convexBodyLT'_neg_mem K f w₀) (convexBodyLT'_convex K f w₀) h\n  rw [mem_toAddSubgroup, mem_span_fractionalIdealLatticeBasis] at hx\n  obtain ⟨a, ha, rfl⟩ := hx\n  exact ⟨a, ha, by simpa using h_nz, (convexBodyLT'_mem K f w₀).mp h_mem⟩\n\n"}
{"name":"NumberField.mixedEmbedding.exists_ne_zero_mem_ringOfIntegers_lt","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nf : NumberField.InfinitePlace K → NNReal\nh : LT.lt (NumberField.mixedEmbedding.minkowskiBound K 1) (MeasureTheory.MeasureSpace.volume (NumberField.mixedEmbedding.convexBodyLT K f))\n⊢ Exists fun a => And (Ne a 0) (∀ (w : NumberField.InfinitePlace K), LT.lt (w ↑a) ↑(f w))","decl":"open scoped Classical in\n/-- A version of `exists_ne_zero_mem_ideal_lt` for the ring of integers of `K`. -/\ntheorem exists_ne_zero_mem_ringOfIntegers_lt (h : minkowskiBound K ↑1 < volume (convexBodyLT K f)) :\n    ∃ a : 𝓞 K, a ≠ 0 ∧ ∀ w : InfinitePlace K, w a < f w := by\n  obtain ⟨_, h_mem, h_nz, h_bd⟩ := exists_ne_zero_mem_ideal_lt K ↑1 h\n  obtain ⟨a, rfl⟩ := (FractionalIdeal.mem_one_iff _).mp h_mem\n  exact ⟨a, RingOfIntegers.coe_ne_zero_iff.mp h_nz, h_bd⟩\n\n"}
{"name":"NumberField.mixedEmbedding.exists_ne_zero_mem_ringOfIntegers_lt'","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nf : NumberField.InfinitePlace K → NNReal\nw₀ : Subtype fun w => w.IsComplex\nh : LT.lt (NumberField.mixedEmbedding.minkowskiBound K 1) (MeasureTheory.MeasureSpace.volume (NumberField.mixedEmbedding.convexBodyLT' K f w₀))\n⊢ Exists fun a => And (Ne a 0) (And (∀ (w : NumberField.InfinitePlace K), Ne w ↑w₀ → LT.lt (w ↑a) ↑(f w)) (And (LT.lt (abs ((↑w₀).embedding ↑a).re) 1) (LT.lt (abs ((↑w₀).embedding ↑a).im) (HPow.hPow (↑(f ↑w₀)) 2))))","decl":"open scoped Classical in\n/-- A version of `exists_ne_zero_mem_ideal_lt'` for the ring of integers of `K`. -/\ntheorem exists_ne_zero_mem_ringOfIntegers_lt' (w₀ : {w : InfinitePlace K // IsComplex w})\n    (h : minkowskiBound K ↑1 < volume (convexBodyLT' K f w₀)) :\n    ∃ a : 𝓞 K, a ≠ 0 ∧ (∀ w : InfinitePlace K, w ≠ w₀ → w a < f w) ∧\n      |(w₀.val.embedding a).re| < 1 ∧ |(w₀.val.embedding a).im| < (f w₀ : ℝ) ^ 2 := by\n  obtain ⟨_, h_mem, h_nz, h_bd⟩ := exists_ne_zero_mem_ideal_lt' K ↑1 w₀ h\n  obtain ⟨a, rfl⟩ := (FractionalIdeal.mem_one_iff _).mp h_mem\n  exact ⟨a, RingOfIntegers.coe_ne_zero_iff.mp h_nz, h_bd⟩\n\n"}
{"name":"NumberField.mixedEmbedding.exists_primitive_element_lt_of_isReal","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nw₀ : NumberField.InfinitePlace K\nhw₀ : w₀.IsReal\nB : NNReal\nhB : LT.lt (NumberField.mixedEmbedding.minkowskiBound K 1) (HMul.hMul ↑(NumberField.mixedEmbedding.convexBodyLTFactor K) ↑B)\n⊢ Exists fun a => And (Eq (IntermediateField.adjoin Rat (Singleton.singleton ↑a)) Top.top) (∀ (w : NumberField.InfinitePlace K), LT.lt (w ↑a) ↑(Max.max B 1))","decl":"theorem exists_primitive_element_lt_of_isReal {w₀ : InfinitePlace K} (hw₀ : IsReal w₀) {B : ℝ≥0}\n    (hB : minkowskiBound K ↑1 < convexBodyLTFactor K * B) :\n    ∃ a : 𝓞 K, ℚ⟮(a : K)⟯ = ⊤ ∧\n      ∀ w : InfinitePlace K, w a < max B 1 := by\n  classical\n  have : minkowskiBound K ↑1 < volume (convexBodyLT K (fun w ↦ if w = w₀ then B else 1)) := by\n    rw [convexBodyLT_volume, ← Finset.prod_erase_mul _ _ (Finset.mem_univ w₀)]\n    simp_rw [ite_pow, one_pow]\n    rw [Finset.prod_ite_eq']\n    simp_rw [Finset.not_mem_erase, ite_false, mult, hw₀, ite_true, one_mul, pow_one]\n    exact hB\n  obtain ⟨a, h_nz, h_le⟩ := exists_ne_zero_mem_ringOfIntegers_lt K this\n  refine ⟨a, ?_, fun w ↦ lt_of_lt_of_le (h_le w) ?_⟩\n  · exact is_primitive_element_of_infinitePlace_lt h_nz\n      (fun w h_ne ↦ by convert (if_neg h_ne) ▸ h_le w) (Or.inl hw₀)\n  · split_ifs <;> simp\n\n"}
{"name":"NumberField.mixedEmbedding.exists_primitive_element_lt_of_isComplex","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nw₀ : NumberField.InfinitePlace K\nhw₀ : w₀.IsComplex\nB : NNReal\nhB : LT.lt (NumberField.mixedEmbedding.minkowskiBound K 1) (HMul.hMul ↑(NumberField.mixedEmbedding.convexBodyLT'Factor K) ↑B)\n⊢ Exists fun a => And (Eq (IntermediateField.adjoin Rat (Singleton.singleton ↑a)) Top.top) (∀ (w : NumberField.InfinitePlace K), LT.lt (w ↑a) (HAdd.hAdd 1 (HPow.hPow (↑B) 2)).sqrt)","decl":"theorem exists_primitive_element_lt_of_isComplex {w₀ : InfinitePlace K} (hw₀ : IsComplex w₀)\n    {B : ℝ≥0} (hB : minkowskiBound K ↑1 < convexBodyLT'Factor K * B) :\n    ∃ a : 𝓞 K, ℚ⟮(a : K)⟯ = ⊤ ∧\n      ∀ w : InfinitePlace K, w a < Real.sqrt (1 + B ^ 2) := by\n  classical\n  have : minkowskiBound K ↑1 <\n      volume (convexBodyLT' K (fun w ↦ if w = w₀ then NNReal.sqrt B else 1) ⟨w₀, hw₀⟩) := by\n    rw [convexBodyLT'_volume, ← Finset.prod_erase_mul _ _ (Finset.mem_univ w₀)]\n    simp_rw [ite_pow, one_pow]\n    rw [Finset.prod_ite_eq']\n    simp_rw [Finset.not_mem_erase, ite_false, mult, not_isReal_iff_isComplex.mpr hw₀,\n      ite_true, ite_false, one_mul, NNReal.sq_sqrt]\n    exact hB\n  obtain ⟨a, h_nz, h_le, h_le₀⟩ := exists_ne_zero_mem_ringOfIntegers_lt' K ⟨w₀, hw₀⟩ this\n  refine ⟨a, ?_, fun w ↦ ?_⟩\n  · exact is_primitive_element_of_infinitePlace_lt h_nz\n      (fun w h_ne ↦ by convert if_neg h_ne ▸ h_le w h_ne) (Or.inr h_le₀.1)\n  · by_cases h_eq : w = w₀\n    · rw [if_pos rfl] at h_le₀\n      dsimp only at h_le₀\n      rw [h_eq, ← norm_embedding_eq, Real.lt_sqrt (norm_nonneg _), ← Complex.re_add_im\n        (embedding w₀ _), Complex.norm_eq_abs, Complex.abs_add_mul_I, Real.sq_sqrt (by positivity)]\n      refine add_lt_add ?_ ?_\n      · rw [← sq_abs, sq_lt_one_iff₀ (abs_nonneg _)]\n        exact h_le₀.1\n      · rw [sq_lt_sq, NNReal.abs_eq, ← NNReal.sq_sqrt B]\n        exact h_le₀.2\n    · refine lt_of_lt_of_le (if_neg h_eq ▸ h_le w h_eq) ?_\n      rw [NNReal.coe_one, Real.le_sqrt' zero_lt_one, one_pow]\n      norm_num\n\n"}
{"name":"NumberField.mixedEmbedding.exists_ne_zero_mem_ideal_of_norm_le","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nI : Units (FractionalIdeal (nonZeroDivisors (NumberField.RingOfIntegers K)) K)\nB : Real\nh : LE.le (NumberField.mixedEmbedding.minkowskiBound K I) (MeasureTheory.MeasureSpace.volume (NumberField.mixedEmbedding.convexBodySum K B))\n⊢ Exists fun a => And (Membership.mem (↑I) a) (And (Ne a 0) (LE.le (↑(abs ((Algebra.norm Rat) a))) (HPow.hPow (HDiv.hDiv B ↑(Module.finrank Rat K)) (Module.finrank Rat K))))","decl":"open scoped Classical in\n/-- Let `I` be a fractional ideal of `K`. Assume that `B : ℝ` is such that\n`minkowskiBound K I < volume (convexBodySum K B)` where `convexBodySum K B` is the set of points\n`x` such that `∑ w real, ‖x w‖ + 2 * ∑ w complex, ‖x w‖ ≤ B` (see `convexBodySum_volume` for\nthe computation of this volume), then there exists a nonzero algebraic number `a` in `I` such\nthat `|Norm a| < (B / d) ^ d` where `d` is the degree of `K`. -/\ntheorem exists_ne_zero_mem_ideal_of_norm_le {B : ℝ}\n    (h : (minkowskiBound K I) ≤ volume (convexBodySum K B)) :\n    ∃ a ∈ (I : FractionalIdeal (𝓞 K)⁰ K), a ≠ 0 ∧\n      |Algebra.norm ℚ (a : K)| ≤ (B / finrank ℚ K) ^ finrank ℚ K := by\n  have hB : 0 ≤ B := by\n    contrapose! h\n    rw [convexBodySum_volume_eq_zero_of_le_zero K (le_of_lt h)]\n    exact minkowskiBound_pos K I\n  -- Some inequalities that will be useful later on\n  have h1 : 0 < (finrank ℚ K : ℝ)⁻¹ := inv_pos.mpr (Nat.cast_pos.mpr finrank_pos)\n  have h2 : 0 ≤ B / (finrank ℚ K) := div_nonneg hB (Nat.cast_nonneg _)\n  have h_fund := ZSpan.isAddFundamentalDomain' (fractionalIdealLatticeBasis K I) volume\n  have : Countable (span ℤ (Set.range (fractionalIdealLatticeBasis K I))).toAddSubgroup := by\n    change Countable (span ℤ (Set.range (fractionalIdealLatticeBasis K I)))\n    infer_instance\n  obtain ⟨⟨x, hx⟩, h_nz, h_mem⟩ := exists_ne_zero_mem_lattice_of_measure_mul_two_pow_le_measure\n      h_fund (fun _ ↦ convexBodySum_neg_mem K B) (convexBodySum_convex K B)\n      (convexBodySum_compact K B) h\n  rw [mem_toAddSubgroup, mem_span_fractionalIdealLatticeBasis] at hx\n  obtain ⟨a, ha, rfl⟩ := hx\n  refine ⟨a, ha, by simpa using h_nz, ?_⟩\n  rw [← rpow_natCast, ← rpow_le_rpow_iff (by simp only [Rat.cast_abs, abs_nonneg])\n      (rpow_nonneg h2 _) h1, ← rpow_mul h2,  mul_inv_cancel₀ (Nat.cast_ne_zero.mpr\n      (ne_of_gt finrank_pos)), rpow_one, le_div_iff₀' (Nat.cast_pos.mpr finrank_pos)]\n  refine le_trans ?_ ((convexBodySum_mem K B).mp h_mem)\n  rw [← le_div_iff₀' (Nat.cast_pos.mpr finrank_pos), ← sum_mult_eq, Nat.cast_sum]\n  refine le_trans ?_ (geom_mean_le_arith_mean Finset.univ _ _ (fun _ _ => Nat.cast_nonneg _)\n    ?_ (fun _ _ => AbsoluteValue.nonneg _ _))\n  · simp_rw [← prod_eq_abs_norm, rpow_natCast]\n    exact le_of_eq rfl\n  · rw [← Nat.cast_sum, sum_mult_eq, Nat.cast_pos]\n    exact finrank_pos\n\n"}
{"name":"NumberField.mixedEmbedding.exists_ne_zero_mem_ringOfIntegers_of_norm_le","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nB : Real\nh : LE.le (NumberField.mixedEmbedding.minkowskiBound K 1) (MeasureTheory.MeasureSpace.volume (NumberField.mixedEmbedding.convexBodySum K B))\n⊢ Exists fun a => And (Ne a 0) (LE.le (↑(abs ((Algebra.norm Rat) ↑a))) (HPow.hPow (HDiv.hDiv B ↑(Module.finrank Rat K)) (Module.finrank Rat K)))","decl":"open scoped Classical in\ntheorem exists_ne_zero_mem_ringOfIntegers_of_norm_le {B : ℝ}\n    (h : (minkowskiBound K ↑1) ≤ volume (convexBodySum K B)) :\n    ∃ a : 𝓞 K, a ≠ 0 ∧ |Algebra.norm ℚ (a : K)| ≤ (B / finrank ℚ K) ^ finrank ℚ K := by\n  obtain ⟨_, h_mem, h_nz, h_bd⟩ := exists_ne_zero_mem_ideal_of_norm_le K ↑1 h\n  obtain ⟨a, rfl⟩ := (FractionalIdeal.mem_one_iff _).mp h_mem\n  exact ⟨a, RingOfIntegers.coe_ne_zero_iff.mp h_nz, h_bd⟩\n\n"}
