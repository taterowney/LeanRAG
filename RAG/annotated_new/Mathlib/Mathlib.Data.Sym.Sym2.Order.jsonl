{"name":"Sym2.sup_mk","module":"Mathlib.Data.Sym.Sym2.Order","initialProofState":"α : Type u_1\ninst✝ : SemilatticeSup α\na b : α\n⊢ Eq (Sym2.mk { fst := a, snd := b }).sup (Max.max a b)","decl":"@[simp] theorem sup_mk [SemilatticeSup α] (a b : α) : s(a, b).sup = a ⊔ b := rfl\n\n"}
{"name":"Sym2.inf_mk","module":"Mathlib.Data.Sym.Sym2.Order","initialProofState":"α : Type u_1\ninst✝ : SemilatticeInf α\na b : α\n⊢ Eq (Sym2.mk { fst := a, snd := b }).inf (Min.min a b)","decl":"@[simp] theorem inf_mk [SemilatticeInf α] (a b : α) : s(a, b).inf = a ⊓ b := rfl\n\n"}
{"name":"Sym2.inf_le_sup","module":"Mathlib.Data.Sym.Sym2.Order","initialProofState":"α : Type u_1\ninst✝ : Lattice α\ns : Sym2 α\n⊢ LE.le s.inf s.sup","decl":"protected theorem inf_le_sup [Lattice α] (s : Sym2 α) : s.inf ≤ s.sup := by\n  cases s using Sym2.ind; simp [_root_.inf_le_sup]\n\n"}
{"name":"Sym2.sortEquiv_symm_apply","module":"Mathlib.Data.Sym.Sym2.Order","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\np : Subtype fun p => LE.le p.1 p.2\n⊢ Eq (Sym2.sortEquiv.symm p) (Sym2.mk ↑p)","decl":"/-- In a linear order, symmetric squares are canonically identified with ordered pairs. -/\n@[simps!]\ndef sortEquiv [LinearOrder α] : Sym2 α ≃ { p : α × α // p.1 ≤ p.2 } where\n  toFun s := ⟨(s.inf, s.sup), Sym2.inf_le_sup _⟩\n  invFun p := Sym2.mk p\n  left_inv := Sym2.ind fun a b => mk_eq_mk_iff.mpr <| by\n    cases le_total a b with\n    | inl h => simp [h]\n    | inr h => simp [h]\n  right_inv := Subtype.rec <| Prod.rec fun x y hxy =>\n    Subtype.ext <| Prod.ext (by simp [hxy]) (by simp [hxy])\n\n"}
{"name":"Sym2.sortEquiv_apply_coe","module":"Mathlib.Data.Sym.Sym2.Order","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Sym2 α\n⊢ Eq ↑(Sym2.sortEquiv s) { fst := s.inf, snd := s.sup }","decl":"/-- In a linear order, symmetric squares are canonically identified with ordered pairs. -/\n@[simps!]\ndef sortEquiv [LinearOrder α] : Sym2 α ≃ { p : α × α // p.1 ≤ p.2 } where\n  toFun s := ⟨(s.inf, s.sup), Sym2.inf_le_sup _⟩\n  invFun p := Sym2.mk p\n  left_inv := Sym2.ind fun a b => mk_eq_mk_iff.mpr <| by\n    cases le_total a b with\n    | inl h => simp [h]\n    | inr h => simp [h]\n  right_inv := Subtype.rec <| Prod.rec fun x y hxy =>\n    Subtype.ext <| Prod.ext (by simp [hxy]) (by simp [hxy])\n\n"}
