{"name":"Complex.mk.sizeOf_spec","module":"Mathlib.Data.Complex.Basic","initialProofState":"re im : Real\n⊢ Eq (SizeOf.sizeOf { re := re, im := im }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf re)) (SizeOf.sizeOf im))","decl":"/-- Complex numbers consist of two `Real`s: a real part `re` and an imaginary part `im`. -/\nstructure Complex : Type where\n  /-- The real part of a complex number. -/\n  re : ℝ\n  /-- The imaginary part of a complex number. -/\n  im : ℝ\n\n"}
{"name":"Complex.mk.injEq","module":"Mathlib.Data.Complex.Basic","initialProofState":"re✝ im✝ re im : Real\n⊢ Eq (Eq { re := re✝, im := im✝ } { re := re, im := im }) (And (Eq re✝ re) (Eq im✝ im))","decl":"/-- Complex numbers consist of two `Real`s: a real part `re` and an imaginary part `im`. -/\nstructure Complex : Type where\n  /-- The real part of a complex number. -/\n  re : ℝ\n  /-- The imaginary part of a complex number. -/\n  im : ℝ\n\n"}
{"name":"Complex.mk.inj","module":"Mathlib.Data.Complex.Basic","initialProofState":"re✝ im✝ re im : Real\nx✝ : Eq { re := re✝, im := im✝ } { re := re, im := im }\n⊢ And (Eq re✝ re) (Eq im✝ im)","decl":"/-- Complex numbers consist of two `Real`s: a real part `re` and an imaginary part `im`. -/\nstructure Complex : Type where\n  /-- The real part of a complex number. -/\n  re : ℝ\n  /-- The imaginary part of a complex number. -/\n  im : ℝ\n\n"}
{"name":"Complex.equivRealProd_apply","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq (Complex.equivRealProd z) { fst := z.re, snd := z.im }","decl":"/-- The equivalence between the complex numbers and `ℝ × ℝ`. -/\n@[simps apply]\ndef equivRealProd : ℂ ≃ ℝ × ℝ where\n  toFun z := ⟨z.re, z.im⟩\n  invFun p := ⟨p.1, p.2⟩\n  left_inv := fun ⟨_, _⟩ => rfl\n  right_inv := fun ⟨_, _⟩ => rfl\n\n"}
{"name":"Complex.eta","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq { re := z.re, im := z.im } z","decl":"@[simp]\ntheorem eta : ∀ z : ℂ, Complex.mk z.re z.im = z\n  | ⟨_, _⟩ => rfl\n\n-- We only mark this lemma with `ext` *locally* to avoid it applying whenever terms of `ℂ` appear.\n"}
{"name":"Complex.ext","module":"Mathlib.Data.Complex.Basic","initialProofState":"z w : Complex\na✝¹ : Eq z.re w.re\na✝ : Eq z.im w.im\n⊢ Eq z w","decl":"theorem ext : ∀ {z w : ℂ}, z.re = w.re → z.im = w.im → z = w\n  | ⟨_, _⟩, ⟨_, _⟩, rfl, rfl => rfl\n\n"}
{"name":"Complex.ext_iff","module":"Mathlib.Data.Complex.Basic","initialProofState":"z w : Complex\n⊢ Iff (Eq z w) (And (Eq z.re w.re) (Eq z.im w.im))","decl":"attribute [local ext] Complex.ext\n\n"}
{"name":"Complex.forall","module":"Mathlib.Data.Complex.Basic","initialProofState":"p : Complex → Prop\n⊢ Iff (∀ (x : Complex), p x) (∀ (a b : Real), p { re := a, im := b })","decl":"lemma «forall» {p : ℂ → Prop} : (∀ x, p x) ↔ ∀ a b, p ⟨a, b⟩ := by aesop\n"}
{"name":"Complex.exists","module":"Mathlib.Data.Complex.Basic","initialProofState":"p : Complex → Prop\n⊢ Iff (Exists fun x => p x) (Exists fun a => Exists fun b => p { re := a, im := b })","decl":"lemma «exists» {p : ℂ → Prop} : (∃ x, p x) ↔ ∃ a b, p ⟨a, b⟩ := by aesop\n\n"}
{"name":"Complex.re_surjective","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Function.Surjective Complex.re","decl":"theorem re_surjective : Surjective re := fun x => ⟨⟨x, 0⟩, rfl⟩\n\n"}
{"name":"Complex.im_surjective","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Function.Surjective Complex.im","decl":"theorem im_surjective : Surjective im := fun y => ⟨⟨0, y⟩, rfl⟩\n\n"}
{"name":"Complex.range_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Eq (Set.range Complex.re) Set.univ","decl":"@[simp]\ntheorem range_re : range re = univ :=\n  re_surjective.range_eq\n\n"}
{"name":"Complex.range_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Eq (Set.range Complex.im) Set.univ","decl":"@[simp]\ntheorem range_im : range im = univ :=\n  im_surjective.range_eq\n\n-- Porting note: refactored instance to allow `norm_cast` to work\n"}
{"name":"Complex.ofReal_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"r : Real\n⊢ Eq (↑r).re r","decl":"@[simp, norm_cast]\ntheorem ofReal_re (r : ℝ) : Complex.re (r : ℂ) = r :=\n  rfl\n\n"}
{"name":"Complex.ofReal_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"r : Real\n⊢ Eq (↑r).im 0","decl":"@[simp, norm_cast]\ntheorem ofReal_im (r : ℝ) : (r : ℂ).im = 0 :=\n  rfl\n\n"}
{"name":"Complex.ofReal_def","module":"Mathlib.Data.Complex.Basic","initialProofState":"r : Real\n⊢ Eq ↑r { re := r, im := 0 }","decl":"theorem ofReal_def (r : ℝ) : (r : ℂ) = ⟨r, 0⟩ :=\n  rfl\n\n"}
{"name":"Complex.ofReal_inj","module":"Mathlib.Data.Complex.Basic","initialProofState":"z w : Real\n⊢ Iff (Eq ↑z ↑w) (Eq z w)","decl":"@[simp, norm_cast]\ntheorem ofReal_inj {z w : ℝ} : (z : ℂ) = w ↔ z = w :=\n  ⟨congrArg re, by apply congrArg⟩\n\n-- Porting note: made coercion explicit\n"}
{"name":"Complex.ofReal_injective","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Function.Injective Complex.ofReal","decl":"theorem ofReal_injective : Function.Injective ((↑) : ℝ → ℂ) := fun _ _ => congrArg re\n\n-- Porting note: made coercion explicit\n"}
{"name":"Complex.canLift","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ CanLift Complex Real Complex.ofReal fun z => Eq z.im 0","decl":"instance canLift : CanLift ℂ ℝ (↑) fun z => z.im = 0 where\n  prf z hz := ⟨z.re, ext rfl hz.symm⟩\n\n"}
{"name":"Complex.mem_reProdIm","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\ns t : Set Real\n⊢ Iff (Membership.mem (Complex.reProdIm s t) z) (And (Membership.mem s z.re) (Membership.mem t z.im))","decl":"theorem mem_reProdIm {z : ℂ} {s t : Set ℝ} : z ∈ s ×ℂ t ↔ z.re ∈ s ∧ z.im ∈ t :=\n  Iff.rfl\n\n"}
{"name":"Complex.zero_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Eq (Complex.re 0) 0","decl":"@[simp]\ntheorem zero_re : (0 : ℂ).re = 0 :=\n  rfl\n\n"}
{"name":"Complex.zero_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Eq (Complex.im 0) 0","decl":"@[simp]\ntheorem zero_im : (0 : ℂ).im = 0 :=\n  rfl\n\n"}
{"name":"Complex.ofReal_zero","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\ntheorem ofReal_zero : ((0 : ℝ) : ℂ) = 0 :=\n  rfl\n\n"}
{"name":"Complex.ofReal_eq_zero","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Real\n⊢ Iff (Eq (↑z) 0) (Eq z 0)","decl":"@[simp]\ntheorem ofReal_eq_zero {z : ℝ} : (z : ℂ) = 0 ↔ z = 0 :=\n  ofReal_inj\n\n"}
{"name":"Complex.ofReal_ne_zero","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Real\n⊢ Iff (Ne (↑z) 0) (Ne z 0)","decl":"theorem ofReal_ne_zero {z : ℝ} : (z : ℂ) ≠ 0 ↔ z ≠ 0 :=\n  not_congr ofReal_eq_zero\n\n"}
{"name":"Complex.one_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Eq (Complex.re 1) 1","decl":"@[simp]\ntheorem one_re : (1 : ℂ).re = 1 :=\n  rfl\n\n"}
{"name":"Complex.one_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Eq (Complex.im 1) 0","decl":"@[simp]\ntheorem one_im : (1 : ℂ).im = 0 :=\n  rfl\n\n"}
{"name":"Complex.ofReal_one","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\ntheorem ofReal_one : ((1 : ℝ) : ℂ) = 1 :=\n  rfl\n\n"}
{"name":"Complex.ofReal_eq_one","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Real\n⊢ Iff (Eq (↑z) 1) (Eq z 1)","decl":"@[simp]\ntheorem ofReal_eq_one {z : ℝ} : (z : ℂ) = 1 ↔ z = 1 :=\n  ofReal_inj\n\n"}
{"name":"Complex.ofReal_ne_one","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Real\n⊢ Iff (Ne (↑z) 1) (Ne z 1)","decl":"theorem ofReal_ne_one {z : ℝ} : (z : ℂ) ≠ 1 ↔ z ≠ 1 :=\n  not_congr ofReal_eq_one\n\n"}
{"name":"Complex.add_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"z w : Complex\n⊢ Eq (HAdd.hAdd z w).re (HAdd.hAdd z.re w.re)","decl":"@[simp]\ntheorem add_re (z w : ℂ) : (z + w).re = z.re + w.re :=\n  rfl\n\n"}
{"name":"Complex.add_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"z w : Complex\n⊢ Eq (HAdd.hAdd z w).im (HAdd.hAdd z.im w.im)","decl":"@[simp]\ntheorem add_im (z w : ℂ) : (z + w).im = z.im + w.im :=\n  rfl\n\n-- replaced by `re_ofNat`\n-- replaced by `im_ofNat`\n\n"}
{"name":"Complex.ofReal_add","module":"Mathlib.Data.Complex.Basic","initialProofState":"r s : Real\n⊢ Eq (↑(HAdd.hAdd r s)) (HAdd.hAdd ↑r ↑s)","decl":"@[simp, norm_cast]\ntheorem ofReal_add (r s : ℝ) : ((r + s : ℝ) : ℂ) = r + s :=\n  Complex.ext_iff.2 <| by simp [ofReal]\n\n-- replaced by `Complex.ofReal_ofNat`\n\n"}
{"name":"Complex.neg_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq (Neg.neg z).re (Neg.neg z.re)","decl":"@[simp]\ntheorem neg_re (z : ℂ) : (-z).re = -z.re :=\n  rfl\n\n"}
{"name":"Complex.neg_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq (Neg.neg z).im (Neg.neg z.im)","decl":"@[simp]\ntheorem neg_im (z : ℂ) : (-z).im = -z.im :=\n  rfl\n\n"}
{"name":"Complex.ofReal_neg","module":"Mathlib.Data.Complex.Basic","initialProofState":"r : Real\n⊢ Eq (↑(Neg.neg r)) (Neg.neg ↑r)","decl":"@[simp, norm_cast]\ntheorem ofReal_neg (r : ℝ) : ((-r : ℝ) : ℂ) = -r :=\n  Complex.ext_iff.2 <| by simp [ofReal]\n\n"}
{"name":"Complex.mul_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"z w : Complex\n⊢ Eq (HMul.hMul z w).re (HSub.hSub (HMul.hMul z.re w.re) (HMul.hMul z.im w.im))","decl":"@[simp]\ntheorem mul_re (z w : ℂ) : (z * w).re = z.re * w.re - z.im * w.im :=\n  rfl\n\n"}
{"name":"Complex.mul_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"z w : Complex\n⊢ Eq (HMul.hMul z w).im (HAdd.hAdd (HMul.hMul z.re w.im) (HMul.hMul z.im w.re))","decl":"@[simp]\ntheorem mul_im (z w : ℂ) : (z * w).im = z.re * w.im + z.im * w.re :=\n  rfl\n\n"}
{"name":"Complex.ofReal_mul","module":"Mathlib.Data.Complex.Basic","initialProofState":"r s : Real\n⊢ Eq (↑(HMul.hMul r s)) (HMul.hMul ↑r ↑s)","decl":"@[simp, norm_cast]\ntheorem ofReal_mul (r s : ℝ) : ((r * s : ℝ) : ℂ) = r * s :=\n  Complex.ext_iff.2 <| by simp [ofReal]\n\n"}
{"name":"Complex.re_ofReal_mul","module":"Mathlib.Data.Complex.Basic","initialProofState":"r : Real\nz : Complex\n⊢ Eq (HMul.hMul (↑r) z).re (HMul.hMul r z.re)","decl":"theorem re_ofReal_mul (r : ℝ) (z : ℂ) : (r * z).re = r * z.re := by simp [ofReal]\n\n"}
{"name":"Complex.im_ofReal_mul","module":"Mathlib.Data.Complex.Basic","initialProofState":"r : Real\nz : Complex\n⊢ Eq (HMul.hMul (↑r) z).im (HMul.hMul r z.im)","decl":"theorem im_ofReal_mul (r : ℝ) (z : ℂ) : (r * z).im = r * z.im := by simp [ofReal]\n\n"}
{"name":"Complex.re_mul_ofReal","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\nr : Real\n⊢ Eq (HMul.hMul z ↑r).re (HMul.hMul z.re r)","decl":"lemma re_mul_ofReal (z : ℂ) (r : ℝ) : (z * r).re = z.re *  r := by simp [ofReal]\n"}
{"name":"Complex.im_mul_ofReal","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\nr : Real\n⊢ Eq (HMul.hMul z ↑r).im (HMul.hMul z.im r)","decl":"lemma im_mul_ofReal (z : ℂ) (r : ℝ) : (z * r).im = z.im *  r := by simp [ofReal]\n\n"}
{"name":"Complex.ofReal_mul'","module":"Mathlib.Data.Complex.Basic","initialProofState":"r : Real\nz : Complex\n⊢ Eq (HMul.hMul (↑r) z) { re := HMul.hMul r z.re, im := HMul.hMul r z.im }","decl":"theorem ofReal_mul' (r : ℝ) (z : ℂ) : ↑r * z = ⟨r * z.re, r * z.im⟩ :=\n  ext (re_ofReal_mul _ _) (im_ofReal_mul _ _)\n\n"}
{"name":"Complex.I_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Eq Complex.I.re 0","decl":"@[simp]\ntheorem I_re : I.re = 0 :=\n  rfl\n\n"}
{"name":"Complex.I_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Eq Complex.I.im 1","decl":"@[simp]\ntheorem I_im : I.im = 1 :=\n  rfl\n\n"}
{"name":"Complex.I_mul_I","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Eq (HMul.hMul Complex.I Complex.I) (-1)","decl":"@[simp]\ntheorem I_mul_I : I * I = -1 :=\n  Complex.ext_iff.2 <| by simp\n\n"}
{"name":"Complex.I_mul","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq (HMul.hMul Complex.I z) { re := Neg.neg z.im, im := z.re }","decl":"theorem I_mul (z : ℂ) : I * z = ⟨-z.im, z.re⟩ :=\n  Complex.ext_iff.2 <| by simp\n\n"}
{"name":"Complex.I_ne_zero","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Ne Complex.I 0","decl":"@[simp] lemma I_ne_zero : (I : ℂ) ≠ 0 := mt (congr_arg im) zero_ne_one.symm\n\n"}
{"name":"Complex.mk_eq_add_mul_I","module":"Mathlib.Data.Complex.Basic","initialProofState":"a b : Real\n⊢ Eq { re := a, im := b } (HAdd.hAdd (↑a) (HMul.hMul (↑b) Complex.I))","decl":"theorem mk_eq_add_mul_I (a b : ℝ) : Complex.mk a b = a + b * I :=\n  Complex.ext_iff.2 <| by simp [ofReal]\n\n"}
{"name":"Complex.re_add_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq (HAdd.hAdd (↑z.re) (HMul.hMul (↑z.im) Complex.I)) z","decl":"@[simp]\ntheorem re_add_im (z : ℂ) : (z.re : ℂ) + z.im * I = z :=\n  Complex.ext_iff.2 <| by simp [ofReal]\n\n"}
{"name":"Complex.mul_I_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq (HMul.hMul z Complex.I).re (Neg.neg z.im)","decl":"theorem mul_I_re (z : ℂ) : (z * I).re = -z.im := by simp\n\n"}
{"name":"Complex.mul_I_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq (HMul.hMul z Complex.I).im z.re","decl":"theorem mul_I_im (z : ℂ) : (z * I).im = z.re := by simp\n\n"}
{"name":"Complex.I_mul_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq (HMul.hMul Complex.I z).re (Neg.neg z.im)","decl":"theorem I_mul_re (z : ℂ) : (I * z).re = -z.im := by simp\n\n"}
{"name":"Complex.I_mul_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq (HMul.hMul Complex.I z).im z.re","decl":"theorem I_mul_im (z : ℂ) : (I * z).im = z.re := by simp\n\n"}
{"name":"Complex.equivRealProd_symm_apply","module":"Mathlib.Data.Complex.Basic","initialProofState":"p : Prod Real Real\n⊢ Eq (Complex.equivRealProd.symm p) (HAdd.hAdd (↑p.1) (HMul.hMul (↑p.2) Complex.I))","decl":"@[simp]\ntheorem equivRealProd_symm_apply (p : ℝ × ℝ) : equivRealProd.symm p = p.1 + p.2 * I := by\n  ext <;> simp [Complex.equivRealProd, ofReal]\n\n"}
{"name":"Complex.equivRealProdAddHom_symm_apply_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"p : Prod Real Real\n⊢ Eq (Complex.equivRealProdAddHom.symm p).re p.1","decl":"/-- The natural `AddEquiv` from `ℂ` to `ℝ × ℝ`. -/\n@[simps! (config := { simpRhs := true }) apply symm_apply_re symm_apply_im]\ndef equivRealProdAddHom : ℂ ≃+ ℝ × ℝ :=\n  { equivRealProd with map_add' := by simp }\n\n"}
{"name":"Complex.equivRealProdAddHom_apply","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq (Complex.equivRealProdAddHom z) { fst := z.re, snd := z.im }","decl":"/-- The natural `AddEquiv` from `ℂ` to `ℝ × ℝ`. -/\n@[simps! (config := { simpRhs := true }) apply symm_apply_re symm_apply_im]\ndef equivRealProdAddHom : ℂ ≃+ ℝ × ℝ :=\n  { equivRealProd with map_add' := by simp }\n\n"}
{"name":"Complex.equivRealProdAddHom_symm_apply_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"p : Prod Real Real\n⊢ Eq (Complex.equivRealProdAddHom.symm p).im p.2","decl":"/-- The natural `AddEquiv` from `ℂ` to `ℝ × ℝ`. -/\n@[simps! (config := { simpRhs := true }) apply symm_apply_re symm_apply_im]\ndef equivRealProdAddHom : ℂ ≃+ ℝ × ℝ :=\n  { equivRealProd with map_add' := by simp }\n\n"}
{"name":"Complex.equivRealProdAddHom_symm_apply","module":"Mathlib.Data.Complex.Basic","initialProofState":"p : Prod Real Real\n⊢ Eq (Complex.equivRealProdAddHom.symm p) (HAdd.hAdd (↑p.1) (HMul.hMul (↑p.2) Complex.I))","decl":"theorem equivRealProdAddHom_symm_apply (p : ℝ × ℝ) :\n    equivRealProdAddHom.symm p = p.1 + p.2 * I := equivRealProd_symm_apply p\n\n"}
{"name":"Complex.instNontrivial","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Nontrivial Complex","decl":"instance : Nontrivial ℂ :=\n  domain_nontrivial re rfl rfl\n\n-- Porting note: moved from `Module/Data/Complex/Basic.lean`\n"}
{"name":"Complex.smul_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"R : Type u_1\ninst✝ : SMul R Real\nr : R\nz : Complex\n⊢ Eq (HSMul.hSMul r z).re (HSMul.hSMul r z.re)","decl":"theorem smul_re (r : R) (z : ℂ) : (r • z).re = r • z.re := by simp [(· • ·), SMul.smul]\n\n"}
{"name":"Complex.smul_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"R : Type u_1\ninst✝ : SMul R Real\nr : R\nz : Complex\n⊢ Eq (HSMul.hSMul r z).im (HSMul.hSMul r z.im)","decl":"theorem smul_im (r : R) (z : ℂ) : (r • z).im = r • z.im := by simp [(· • ·), SMul.smul]\n\n"}
{"name":"Complex.real_smul","module":"Mathlib.Data.Complex.Basic","initialProofState":"x : Real\nz : Complex\n⊢ Eq (HSMul.hSMul x z) (HMul.hMul (↑x) z)","decl":"@[simp]\ntheorem real_smul {x : ℝ} {z : ℂ} : x • z = x * z :=\n  rfl\n\n"}
{"name":"Complex.coe_reAddGroupHom","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Eq (⇑Complex.reAddGroupHom) Complex.re","decl":"@[simp]\ntheorem coe_reAddGroupHom : (reAddGroupHom : ℂ → ℝ) = re :=\n  rfl\n\n"}
{"name":"Complex.coe_imAddGroupHom","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Eq (⇑Complex.imAddGroupHom) Complex.im","decl":"@[simp]\ntheorem coe_imAddGroupHom : (imAddGroupHom : ℂ → ℝ) = im :=\n  rfl\n\n"}
{"name":"Complex.ofReal_ofNat","module":"Mathlib.Data.Complex.Basic","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (↑(OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp, norm_cast] lemma ofReal_ofNat (n : ℕ) [n.AtLeastTwo] : ofReal ofNat(n) = ofNat(n) := rfl\n"}
{"name":"Complex.ofReal_natCast","module":"Mathlib.Data.Complex.Basic","initialProofState":"n : Nat\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast] lemma ofReal_natCast (n : ℕ) : ofReal n = n := rfl\n"}
{"name":"Complex.ofReal_intCast","module":"Mathlib.Data.Complex.Basic","initialProofState":"n : Int\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast] lemma ofReal_intCast (n : ℤ) : ofReal n = n := rfl\n"}
{"name":"Complex.ofReal_nnratCast","module":"Mathlib.Data.Complex.Basic","initialProofState":"q : NNRat\n⊢ Eq ↑↑q ↑q","decl":"@[simp, norm_cast] lemma ofReal_nnratCast (q : ℚ≥0) : ofReal q = q := rfl\n"}
{"name":"Complex.ofReal_ratCast","module":"Mathlib.Data.Complex.Basic","initialProofState":"q : Rat\n⊢ Eq ↑↑q ↑q","decl":"@[simp, norm_cast] lemma ofReal_ratCast (q : ℚ) : ofReal q = q := rfl\n\n"}
{"name":"Complex.re_ofNat","module":"Mathlib.Data.Complex.Basic","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n).re (OfNat.ofNat n)","decl":"@[simp]\nlemma re_ofNat (n : ℕ) [n.AtLeastTwo] : (ofNat(n) : ℂ).re = ofNat(n) := rfl\n"}
{"name":"Complex.im_ofNat","module":"Mathlib.Data.Complex.Basic","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n).im 0","decl":"@[simp] lemma im_ofNat (n : ℕ) [n.AtLeastTwo] : (ofNat(n) : ℂ).im = 0 := rfl\n"}
{"name":"Complex.natCast_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"n : Nat\n⊢ Eq (↑n).re ↑n","decl":"@[simp, norm_cast] lemma natCast_re (n : ℕ) : (n : ℂ).re = n := rfl\n"}
{"name":"Complex.natCast_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"n : Nat\n⊢ Eq (↑n).im 0","decl":"@[simp, norm_cast] lemma natCast_im (n : ℕ) : (n : ℂ).im = 0 := rfl\n"}
{"name":"Complex.intCast_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"n : Int\n⊢ Eq (↑n).re ↑n","decl":"@[simp, norm_cast] lemma intCast_re (n : ℤ) : (n : ℂ).re = n := rfl\n"}
{"name":"Complex.intCast_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"n : Int\n⊢ Eq (↑n).im 0","decl":"@[simp, norm_cast] lemma intCast_im (n : ℤ) : (n : ℂ).im = 0 := rfl\n"}
{"name":"Complex.re_nnratCast","module":"Mathlib.Data.Complex.Basic","initialProofState":"q : NNRat\n⊢ Eq (↑q).re ↑q","decl":"@[simp, norm_cast] lemma re_nnratCast (q : ℚ≥0) : (q : ℂ).re = q := rfl\n"}
{"name":"Complex.im_nnratCast","module":"Mathlib.Data.Complex.Basic","initialProofState":"q : NNRat\n⊢ Eq (↑q).im 0","decl":"@[simp, norm_cast] lemma im_nnratCast (q : ℚ≥0) : (q : ℂ).im = 0 := rfl\n"}
{"name":"Complex.ratCast_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"q : Rat\n⊢ Eq (↑q).re ↑q","decl":"@[simp, norm_cast] lemma ratCast_re (q : ℚ) : (q : ℂ).re = q := rfl\n"}
{"name":"Complex.ratCast_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"q : Rat\n⊢ Eq (↑q).im 0","decl":"@[simp, norm_cast] lemma ratCast_im (q : ℚ) : (q : ℂ).im = 0 := rfl\n\n"}
{"name":"Complex.re_nsmul","module":"Mathlib.Data.Complex.Basic","initialProofState":"n : Nat\nz : Complex\n⊢ Eq (HSMul.hSMul n z).re (HSMul.hSMul n z.re)","decl":"lemma re_nsmul (n : ℕ) (z : ℂ) : (n • z).re = n • z.re := smul_re ..\n"}
{"name":"Complex.im_nsmul","module":"Mathlib.Data.Complex.Basic","initialProofState":"n : Nat\nz : Complex\n⊢ Eq (HSMul.hSMul n z).im (HSMul.hSMul n z.im)","decl":"lemma im_nsmul (n : ℕ) (z : ℂ) : (n • z).im = n • z.im := smul_im ..\n"}
{"name":"Complex.re_zsmul","module":"Mathlib.Data.Complex.Basic","initialProofState":"n : Int\nz : Complex\n⊢ Eq (HSMul.hSMul n z).re (HSMul.hSMul n z.re)","decl":"lemma re_zsmul (n : ℤ) (z : ℂ) : (n • z).re = n • z.re := smul_re ..\n"}
{"name":"Complex.im_zsmul","module":"Mathlib.Data.Complex.Basic","initialProofState":"n : Int\nz : Complex\n⊢ Eq (HSMul.hSMul n z).im (HSMul.hSMul n z.im)","decl":"lemma im_zsmul (n : ℤ) (z : ℂ) : (n • z).im = n • z.im := smul_im ..\n"}
{"name":"Complex.re_nnqsmul","module":"Mathlib.Data.Complex.Basic","initialProofState":"q : NNRat\nz : Complex\n⊢ Eq (HSMul.hSMul q z).re (HSMul.hSMul q z.re)","decl":"@[simp] lemma re_nnqsmul (q : ℚ≥0) (z : ℂ) : (q • z).re = q • z.re := smul_re ..\n"}
{"name":"Complex.im_nnqsmul","module":"Mathlib.Data.Complex.Basic","initialProofState":"q : NNRat\nz : Complex\n⊢ Eq (HSMul.hSMul q z).im (HSMul.hSMul q z.im)","decl":"@[simp] lemma im_nnqsmul (q : ℚ≥0) (z : ℂ) : (q • z).im = q • z.im := smul_im ..\n"}
{"name":"Complex.re_qsmul","module":"Mathlib.Data.Complex.Basic","initialProofState":"q : Rat\nz : Complex\n⊢ Eq (HSMul.hSMul q z).re (HSMul.hSMul q z.re)","decl":"@[simp] lemma re_qsmul (q : ℚ) (z : ℂ) : (q • z).re = q • z.re := smul_re ..\n"}
{"name":"Complex.im_qsmul","module":"Mathlib.Data.Complex.Basic","initialProofState":"q : Rat\nz : Complex\n⊢ Eq (HSMul.hSMul q z).im (HSMul.hSMul q z.im)","decl":"@[simp] lemma im_qsmul (q : ℚ) (z : ℂ) : (q • z).im = q • z.im := smul_im ..\n\n"}
{"name":"Complex.ofReal_nsmul","module":"Mathlib.Data.Complex.Basic","initialProofState":"n : Nat\nr : Real\n⊢ Eq (↑(HSMul.hSMul n r)) (HSMul.hSMul n ↑r)","decl":"@[norm_cast] lemma ofReal_nsmul (n : ℕ) (r : ℝ) : ↑(n • r) = n • (r : ℂ) := by simp\n"}
{"name":"Complex.ofReal_zsmul","module":"Mathlib.Data.Complex.Basic","initialProofState":"n : Int\nr : Real\n⊢ Eq (↑(HSMul.hSMul n r)) (HSMul.hSMul n ↑r)","decl":"@[norm_cast] lemma ofReal_zsmul (n : ℤ) (r : ℝ) : ↑(n • r) = n • (r : ℂ) := by simp\n\n"}
{"name":"Complex.conj_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq ((starRingEnd Complex) z).re z.re","decl":"@[simp]\ntheorem conj_re (z : ℂ) : (conj z).re = z.re :=\n  rfl\n\n"}
{"name":"Complex.conj_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq ((starRingEnd Complex) z).im (Neg.neg z.im)","decl":"@[simp]\ntheorem conj_im (z : ℂ) : (conj z).im = -z.im :=\n  rfl\n\n"}
{"name":"Complex.conj_ofReal","module":"Mathlib.Data.Complex.Basic","initialProofState":"r : Real\n⊢ Eq ((starRingEnd Complex) ↑r) ↑r","decl":"@[simp]\ntheorem conj_ofReal (r : ℝ) : conj (r : ℂ) = r :=\n  Complex.ext_iff.2 <| by simp [star]\n\n"}
{"name":"Complex.conj_I","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Eq ((starRingEnd Complex) Complex.I) (Neg.neg Complex.I)","decl":"@[simp]\ntheorem conj_I : conj I = -I :=\n  Complex.ext_iff.2 <| by simp\n\n"}
{"name":"Complex.conj_natCast","module":"Mathlib.Data.Complex.Basic","initialProofState":"n : Nat\n⊢ Eq ((starRingEnd Complex) ↑n) ↑n","decl":"theorem conj_natCast (n : ℕ) : conj (n : ℂ) = n := map_natCast _ _\n\n"}
{"name":"Complex.conj_ofNat","module":"Mathlib.Data.Complex.Basic","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq ((starRingEnd Complex) (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"theorem conj_ofNat (n : ℕ) [n.AtLeastTwo] : conj (ofNat(n) : ℂ) = ofNat(n) :=\n  map_ofNat _ _\n\n-- @[simp]\n/- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): `simp` attribute removed as the result could be proved\nby `simp only [@map_neg, Complex.conj_i, @neg_neg]`\n-/\n"}
{"name":"Complex.conj_neg_I","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Eq ((starRingEnd Complex) (Neg.neg Complex.I)) Complex.I","decl":"theorem conj_neg_I : conj (-I) = I :=\n  Complex.ext_iff.2 <| by simp\n\n"}
{"name":"Complex.conj_eq_iff_real","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Iff (Eq ((starRingEnd Complex) z) z) (Exists fun r => Eq z ↑r)","decl":"theorem conj_eq_iff_real {z : ℂ} : conj z = z ↔ ∃ r : ℝ, z = r :=\n  ⟨fun h => ⟨z.re, ext rfl <| eq_zero_of_neg_eq (congr_arg im h)⟩, fun ⟨h, e⟩ => by\n    rw [e, conj_ofReal]⟩\n\n"}
{"name":"Complex.conj_eq_iff_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Iff (Eq ((starRingEnd Complex) z) z) (Eq (↑z.re) z)","decl":"theorem conj_eq_iff_re {z : ℂ} : conj z = z ↔ (z.re : ℂ) = z :=\n  conj_eq_iff_real.trans ⟨by rintro ⟨r, rfl⟩; simp [ofReal], fun h => ⟨_, h.symm⟩⟩\n\n"}
{"name":"Complex.conj_eq_iff_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Iff (Eq ((starRingEnd Complex) z) z) (Eq z.im 0)","decl":"theorem conj_eq_iff_im {z : ℂ} : conj z = z ↔ z.im = 0 :=\n  ⟨fun h => add_self_eq_zero.mp (neg_eq_iff_add_eq_zero.mp (congr_arg im h)), fun h =>\n    ext rfl (neg_eq_iff_add_eq_zero.mpr (add_self_eq_zero.mpr h))⟩\n\n-- `simpNF` complains about this being provable by `RCLike.star_def` even\n-- though it's not imported by this file.\n-- Porting note: linter `simpNF` not found\n"}
{"name":"Complex.star_def","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Eq Star.star ⇑(starRingEnd Complex)","decl":"@[simp]\ntheorem star_def : (Star.star : ℂ → ℂ) = conj :=\n  rfl\n\n"}
{"name":"Complex.normSq_apply","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq (Complex.normSq z) (HAdd.hAdd (HMul.hMul z.re z.re) (HMul.hMul z.im z.im))","decl":"theorem normSq_apply (z : ℂ) : normSq z = z.re * z.re + z.im * z.im :=\n  rfl\n\n"}
{"name":"Complex.normSq_ofReal","module":"Mathlib.Data.Complex.Basic","initialProofState":"r : Real\n⊢ Eq (Complex.normSq ↑r) (HMul.hMul r r)","decl":"@[simp]\ntheorem normSq_ofReal (r : ℝ) : normSq r = r * r := by\n  simp [normSq, ofReal]\n\n"}
{"name":"Complex.normSq_natCast","module":"Mathlib.Data.Complex.Basic","initialProofState":"n : Nat\n⊢ Eq (Complex.normSq ↑n) (HMul.hMul ↑n ↑n)","decl":"@[simp]\ntheorem normSq_natCast (n : ℕ) : normSq n = n * n := normSq_ofReal _\n\n"}
{"name":"Complex.normSq_intCast","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Int\n⊢ Eq (Complex.normSq ↑z) (HMul.hMul ↑z ↑z)","decl":"@[simp]\ntheorem normSq_intCast (z : ℤ) : normSq z = z * z := normSq_ofReal _\n\n"}
{"name":"Complex.normSq_ratCast","module":"Mathlib.Data.Complex.Basic","initialProofState":"q : Rat\n⊢ Eq (Complex.normSq ↑q) (HMul.hMul ↑q ↑q)","decl":"@[simp]\ntheorem normSq_ratCast (q : ℚ) : normSq q = q * q := normSq_ofReal _\n\n"}
{"name":"Complex.normSq_ofNat","module":"Mathlib.Data.Complex.Basic","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Complex.normSq (OfNat.ofNat n)) (HMul.hMul (OfNat.ofNat n) (OfNat.ofNat n))","decl":"@[simp]\ntheorem normSq_ofNat (n : ℕ) [n.AtLeastTwo] :\n    normSq (ofNat(n) : ℂ) = ofNat(n) * ofNat(n) :=\n  normSq_natCast _\n\n"}
{"name":"Complex.normSq_mk","module":"Mathlib.Data.Complex.Basic","initialProofState":"x y : Real\n⊢ Eq (Complex.normSq { re := x, im := y }) (HAdd.hAdd (HMul.hMul x x) (HMul.hMul y y))","decl":"@[simp]\ntheorem normSq_mk (x y : ℝ) : normSq ⟨x, y⟩ = x * x + y * y :=\n  rfl\n\n"}
{"name":"Complex.normSq_add_mul_I","module":"Mathlib.Data.Complex.Basic","initialProofState":"x y : Real\n⊢ Eq (Complex.normSq (HAdd.hAdd (↑x) (HMul.hMul (↑y) Complex.I))) (HAdd.hAdd (HPow.hPow x 2) (HPow.hPow y 2))","decl":"theorem normSq_add_mul_I (x y : ℝ) : normSq (x + y * I) = x ^ 2 + y ^ 2 := by\n  rw [← mk_eq_add_mul_I, normSq_mk, sq, sq]\n\n"}
{"name":"Complex.normSq_eq_conj_mul_self","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq (↑(Complex.normSq z)) (HMul.hMul ((starRingEnd Complex) z) z)","decl":"theorem normSq_eq_conj_mul_self {z : ℂ} : (normSq z : ℂ) = conj z * z := by\n  ext <;> simp [normSq, mul_comm, ofReal]\n\n-- @[simp]\n/- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): `simp` attribute removed as linter reports this can be proved\nby `simp only [@map_zero]` -/\n"}
{"name":"Complex.normSq_zero","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Eq (Complex.normSq 0) 0","decl":"theorem normSq_zero : normSq 0 = 0 :=\n  normSq.map_zero\n\n-- @[simp]\n/- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): `simp` attribute removed as linter reports this can be proved\nby `simp only [@map_one]` -/\n"}
{"name":"Complex.normSq_one","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Eq (Complex.normSq 1) 1","decl":"theorem normSq_one : normSq 1 = 1 :=\n  normSq.map_one\n\n"}
{"name":"Complex.normSq_I","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Eq (Complex.normSq Complex.I) 1","decl":"@[simp]\ntheorem normSq_I : normSq I = 1 := by simp [normSq]\n\n"}
{"name":"Complex.normSq_nonneg","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ LE.le 0 (Complex.normSq z)","decl":"theorem normSq_nonneg (z : ℂ) : 0 ≤ normSq z :=\n  add_nonneg (mul_self_nonneg _) (mul_self_nonneg _)\n\n"}
{"name":"Complex.normSq_eq_zero","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Iff (Eq (Complex.normSq z) 0) (Eq z 0)","decl":"theorem normSq_eq_zero {z : ℂ} : normSq z = 0 ↔ z = 0 :=\n  ⟨fun h =>\n    ext (eq_zero_of_mul_self_add_mul_self_eq_zero h)\n      (eq_zero_of_mul_self_add_mul_self_eq_zero <| (add_comm _ _).trans h),\n    fun h => h.symm ▸ normSq_zero⟩\n\n"}
{"name":"Complex.normSq_pos","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Iff (LT.lt 0 (Complex.normSq z)) (Ne z 0)","decl":"@[simp]\ntheorem normSq_pos {z : ℂ} : 0 < normSq z ↔ z ≠ 0 :=\n  (normSq_nonneg z).lt_iff_ne.trans <| not_congr (eq_comm.trans normSq_eq_zero)\n\n"}
{"name":"Complex.normSq_neg","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq (Complex.normSq (Neg.neg z)) (Complex.normSq z)","decl":"@[simp]\ntheorem normSq_neg (z : ℂ) : normSq (-z) = normSq z := by simp [normSq]\n\n"}
{"name":"Complex.normSq_conj","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq (Complex.normSq ((starRingEnd Complex) z)) (Complex.normSq z)","decl":"@[simp]\ntheorem normSq_conj (z : ℂ) : normSq (conj z) = normSq z := by simp [normSq]\n\n"}
{"name":"Complex.normSq_mul","module":"Mathlib.Data.Complex.Basic","initialProofState":"z w : Complex\n⊢ Eq (Complex.normSq (HMul.hMul z w)) (HMul.hMul (Complex.normSq z) (Complex.normSq w))","decl":"theorem normSq_mul (z w : ℂ) : normSq (z * w) = normSq z * normSq w :=\n  normSq.map_mul z w\n\n"}
{"name":"Complex.normSq_add","module":"Mathlib.Data.Complex.Basic","initialProofState":"z w : Complex\n⊢ Eq (Complex.normSq (HAdd.hAdd z w)) (HAdd.hAdd (HAdd.hAdd (Complex.normSq z) (Complex.normSq w)) (HMul.hMul 2 (HMul.hMul z ((starRingEnd Complex) w)).re))","decl":"theorem normSq_add (z w : ℂ) : normSq (z + w) = normSq z + normSq w + 2 * (z * conj w).re := by\n  dsimp [normSq]; ring\n\n"}
{"name":"Complex.re_sq_le_normSq","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ LE.le (HMul.hMul z.re z.re) (Complex.normSq z)","decl":"theorem re_sq_le_normSq (z : ℂ) : z.re * z.re ≤ normSq z :=\n  le_add_of_nonneg_right (mul_self_nonneg _)\n\n"}
{"name":"Complex.im_sq_le_normSq","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ LE.le (HMul.hMul z.im z.im) (Complex.normSq z)","decl":"theorem im_sq_le_normSq (z : ℂ) : z.im * z.im ≤ normSq z :=\n  le_add_of_nonneg_left (mul_self_nonneg _)\n\n"}
{"name":"Complex.mul_conj","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq (HMul.hMul z ((starRingEnd Complex) z)) ↑(Complex.normSq z)","decl":"theorem mul_conj (z : ℂ) : z * conj z = normSq z :=\n  Complex.ext_iff.2 <| by simp [normSq, mul_comm, sub_eq_neg_add, add_comm, ofReal]\n\n"}
{"name":"Complex.add_conj","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq (HAdd.hAdd z ((starRingEnd Complex) z)) ↑(HMul.hMul 2 z.re)","decl":"theorem add_conj (z : ℂ) : z + conj z = (2 * z.re : ℝ) :=\n  Complex.ext_iff.2 <| by simp [two_mul, ofReal]\n\n"}
{"name":"Complex.ofRealHom_eq_coe","module":"Mathlib.Data.Complex.Basic","initialProofState":"r : Real\n⊢ Eq (Complex.ofRealHom r) ↑r","decl":"@[simp] lemma ofRealHom_eq_coe (r : ℝ) : ofRealHom r = r := rfl\n\n"}
{"name":"Complex.ofReal_comp_add","module":"Mathlib.Data.Complex.Basic","initialProofState":"α : Type u_1\nf g : α → Real\n⊢ Eq (Function.comp Complex.ofReal (HAdd.hAdd f g)) (HAdd.hAdd (Function.comp Complex.ofReal f) (Function.comp Complex.ofReal g))","decl":"@[simp] lemma ofReal_comp_add (f g : α → ℝ) : ofReal ∘ (f + g) = ofReal ∘ f + ofReal ∘ g :=\n  map_comp_add ofRealHom ..\n\n"}
{"name":"Complex.ofReal_comp_sub","module":"Mathlib.Data.Complex.Basic","initialProofState":"α : Type u_1\nf g : α → Real\n⊢ Eq (Function.comp Complex.ofReal (HSub.hSub f g)) (HSub.hSub (Function.comp Complex.ofReal f) (Function.comp Complex.ofReal g))","decl":"@[simp] lemma ofReal_comp_sub (f g : α → ℝ) : ofReal ∘ (f - g) = ofReal ∘ f - ofReal ∘ g :=\n  map_comp_sub ofRealHom ..\n\n"}
{"name":"Complex.ofReal_comp_neg","module":"Mathlib.Data.Complex.Basic","initialProofState":"α : Type u_1\nf : α → Real\n⊢ Eq (Function.comp Complex.ofReal (Neg.neg f)) (Neg.neg (Function.comp Complex.ofReal f))","decl":"@[simp] lemma ofReal_comp_neg (f : α → ℝ) : ofReal ∘ (-f) = -(ofReal ∘ f) :=\n  map_comp_neg ofRealHom _\n\n"}
{"name":"Complex.ofReal_comp_nsmul","module":"Mathlib.Data.Complex.Basic","initialProofState":"α : Type u_1\nn : Nat\nf : α → Real\n⊢ Eq (Function.comp Complex.ofReal (HSMul.hSMul n f)) (HSMul.hSMul n (Function.comp Complex.ofReal f))","decl":"lemma ofReal_comp_nsmul (n : ℕ) (f : α → ℝ) : ofReal ∘ (n • f) = n • (ofReal ∘ f) :=\n  map_comp_nsmul ofRealHom ..\n\n"}
{"name":"Complex.ofReal_comp_zsmul","module":"Mathlib.Data.Complex.Basic","initialProofState":"α : Type u_1\nn : Int\nf : α → Real\n⊢ Eq (Function.comp Complex.ofReal (HSMul.hSMul n f)) (HSMul.hSMul n (Function.comp Complex.ofReal f))","decl":"lemma ofReal_comp_zsmul (n : ℤ) (f : α → ℝ) : ofReal ∘ (n • f) = n • (ofReal ∘ f) :=\n  map_comp_zsmul ofRealHom ..\n\n"}
{"name":"Complex.ofReal_comp_mul","module":"Mathlib.Data.Complex.Basic","initialProofState":"α : Type u_1\nf g : α → Real\n⊢ Eq (Function.comp Complex.ofReal (HMul.hMul f g)) (HMul.hMul (Function.comp Complex.ofReal f) (Function.comp Complex.ofReal g))","decl":"@[simp] lemma ofReal_comp_mul (f g : α → ℝ) : ofReal ∘ (f * g) = ofReal ∘ f * ofReal ∘ g :=\n  map_comp_mul ofRealHom ..\n\n"}
{"name":"Complex.ofReal_comp_pow","module":"Mathlib.Data.Complex.Basic","initialProofState":"α : Type u_1\nf : α → Real\nn : Nat\n⊢ Eq (Function.comp Complex.ofReal (HPow.hPow f n)) (HPow.hPow (Function.comp Complex.ofReal f) n)","decl":"@[simp] lemma ofReal_comp_pow (f : α → ℝ) (n : ℕ) : ofReal ∘ (f ^ n) = (ofReal ∘ f) ^ n :=\n  map_comp_pow ofRealHom ..\n\n"}
{"name":"Complex.I_sq","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Eq (HPow.hPow Complex.I 2) (-1)","decl":"@[simp]\ntheorem I_sq : I ^ 2 = -1 := by rw [sq, I_mul_I]\n\n"}
{"name":"Complex.I_pow_four","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Eq (HPow.hPow Complex.I 4) 1","decl":"@[simp]\ntheorem I_pow_four : I ^ 4 = 1 := by rw [(by norm_num : 4 = 2 * 2), pow_mul, I_sq, neg_one_sq]\n\n"}
{"name":"Complex.sub_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"z w : Complex\n⊢ Eq (HSub.hSub z w).re (HSub.hSub z.re w.re)","decl":"@[simp]\ntheorem sub_re (z w : ℂ) : (z - w).re = z.re - w.re :=\n  rfl\n\n"}
{"name":"Complex.sub_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"z w : Complex\n⊢ Eq (HSub.hSub z w).im (HSub.hSub z.im w.im)","decl":"@[simp]\ntheorem sub_im (z w : ℂ) : (z - w).im = z.im - w.im :=\n  rfl\n\n"}
{"name":"Complex.ofReal_sub","module":"Mathlib.Data.Complex.Basic","initialProofState":"r s : Real\n⊢ Eq (↑(HSub.hSub r s)) (HSub.hSub ↑r ↑s)","decl":"@[simp, norm_cast]\ntheorem ofReal_sub (r s : ℝ) : ((r - s : ℝ) : ℂ) = r - s :=\n  Complex.ext_iff.2 <| by simp [ofReal]\n\n"}
{"name":"Complex.ofReal_pow","module":"Mathlib.Data.Complex.Basic","initialProofState":"r : Real\nn : Nat\n⊢ Eq (↑(HPow.hPow r n)) (HPow.hPow (↑r) n)","decl":"@[simp, norm_cast]\ntheorem ofReal_pow (r : ℝ) (n : ℕ) : ((r ^ n : ℝ) : ℂ) = (r : ℂ) ^ n := by\n  induction n <;> simp [*, ofReal_mul, pow_succ]\n\n"}
{"name":"Complex.sub_conj","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq (HSub.hSub z ((starRingEnd Complex) z)) (HMul.hMul (↑(HMul.hMul 2 z.im)) Complex.I)","decl":"theorem sub_conj (z : ℂ) : z - conj z = (2 * z.im : ℝ) * I :=\n  Complex.ext_iff.2 <| by simp [two_mul, sub_eq_add_neg, ofReal]\n\n"}
{"name":"Complex.normSq_sub","module":"Mathlib.Data.Complex.Basic","initialProofState":"z w : Complex\n⊢ Eq (Complex.normSq (HSub.hSub z w)) (HSub.hSub (HAdd.hAdd (Complex.normSq z) (Complex.normSq w)) (HMul.hMul 2 (HMul.hMul z ((starRingEnd Complex) w)).re))","decl":"theorem normSq_sub (z w : ℂ) : normSq (z - w) = normSq z + normSq w - 2 * (z * conj w).re := by\n  rw [sub_eq_add_neg, normSq_add]\n  simp only [RingHom.map_neg, mul_neg, neg_re, normSq_neg]\n  ring\n\n"}
{"name":"Complex.inv_def","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq (Inv.inv z) (HMul.hMul ((starRingEnd Complex) z) ↑(Inv.inv (Complex.normSq z)))","decl":"theorem inv_def (z : ℂ) : z⁻¹ = conj z * ((normSq z)⁻¹ : ℝ) :=\n  rfl\n\n"}
{"name":"Complex.inv_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq (Inv.inv z).re (HDiv.hDiv z.re (Complex.normSq z))","decl":"@[simp]\ntheorem inv_re (z : ℂ) : z⁻¹.re = z.re / normSq z := by simp [inv_def, division_def, ofReal]\n\n"}
{"name":"Complex.inv_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq (Inv.inv z).im (HDiv.hDiv (Neg.neg z.im) (Complex.normSq z))","decl":"@[simp]\ntheorem inv_im (z : ℂ) : z⁻¹.im = -z.im / normSq z := by simp [inv_def, division_def, ofReal]\n\n"}
{"name":"Complex.ofReal_inv","module":"Mathlib.Data.Complex.Basic","initialProofState":"r : Real\n⊢ Eq (↑(Inv.inv r)) (Inv.inv ↑r)","decl":"@[simp, norm_cast]\ntheorem ofReal_inv (r : ℝ) : ((r⁻¹ : ℝ) : ℂ) = (r : ℂ)⁻¹ :=\n  Complex.ext_iff.2 <| by simp [ofReal]\n\n"}
{"name":"Complex.inv_zero","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Eq (Inv.inv 0) 0","decl":"protected theorem inv_zero : (0⁻¹ : ℂ) = 0 := by\n  rw [← ofReal_zero, ← ofReal_inv, inv_zero]\n\n"}
{"name":"Complex.mul_inv_cancel","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\nh : Ne z 0\n⊢ Eq (HMul.hMul z (Inv.inv z)) 1","decl":"protected theorem mul_inv_cancel {z : ℂ} (h : z ≠ 0) : z * z⁻¹ = 1 := by\n  rw [inv_def, ← mul_assoc, mul_conj, ← ofReal_mul, mul_inv_cancel₀ (mt normSq_eq_zero.1 h),\n    ofReal_one]\n\n"}
{"name":"Complex.div_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"z w : Complex\n⊢ Eq (HDiv.hDiv z w).re (HAdd.hAdd (HDiv.hDiv (HMul.hMul z.re w.re) (Complex.normSq w)) (HDiv.hDiv (HMul.hMul z.im w.im) (Complex.normSq w)))","decl":"lemma div_re (z w : ℂ) : (z / w).re = z.re * w.re / normSq w + z.im * w.im / normSq w := by\n  simp [div_eq_mul_inv, mul_assoc, sub_eq_add_neg]\n\n"}
{"name":"Complex.div_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"z w : Complex\n⊢ Eq (HDiv.hDiv z w).im (HSub.hSub (HDiv.hDiv (HMul.hMul z.im w.re) (Complex.normSq w)) (HDiv.hDiv (HMul.hMul z.re w.im) (Complex.normSq w)))","decl":"lemma div_im (z w : ℂ) : (z / w).im = z.im * w.re / normSq w - z.re * w.im / normSq w := by\n  simp [div_eq_mul_inv, mul_assoc, sub_eq_add_neg, add_comm]\n\n"}
{"name":"Complex.ofReal_nnqsmul","module":"Mathlib.Data.Complex.Basic","initialProofState":"q : NNRat\nr : Real\n⊢ Eq (↑(HSMul.hSMul q r)) (HSMul.hSMul q ↑r)","decl":"@[simp, norm_cast]\nlemma ofReal_nnqsmul (q : ℚ≥0) (r : ℝ) : ofReal (q • r) = q • r := by simp [NNRat.smul_def]\n\n"}
{"name":"Complex.ofReal_qsmul","module":"Mathlib.Data.Complex.Basic","initialProofState":"q : Rat\nr : Real\n⊢ Eq (↑(HSMul.hSMul q r)) (HSMul.hSMul q ↑r)","decl":"@[simp, norm_cast]\nlemma ofReal_qsmul (q : ℚ) (r : ℝ) : ofReal (q • r) = q • r := by simp [Rat.smul_def]\n\n"}
{"name":"Complex.conj_inv","module":"Mathlib.Data.Complex.Basic","initialProofState":"x : Complex\n⊢ Eq ((starRingEnd Complex) (Inv.inv x)) (Inv.inv ((starRingEnd Complex) x))","decl":"theorem conj_inv (x : ℂ) : conj x⁻¹ = (conj x)⁻¹ :=\n  star_inv₀ _\n\n"}
{"name":"Complex.ofReal_div","module":"Mathlib.Data.Complex.Basic","initialProofState":"r s : Real\n⊢ Eq (↑(HDiv.hDiv r s)) (HDiv.hDiv ↑r ↑s)","decl":"@[simp, norm_cast]\ntheorem ofReal_div (r s : ℝ) : ((r / s : ℝ) : ℂ) = r / s := map_div₀ ofRealHom r s\n\n"}
{"name":"Complex.ofReal_zpow","module":"Mathlib.Data.Complex.Basic","initialProofState":"r : Real\nn : Int\n⊢ Eq (↑(HPow.hPow r n)) (HPow.hPow (↑r) n)","decl":"@[simp, norm_cast]\ntheorem ofReal_zpow (r : ℝ) (n : ℤ) : ((r ^ n : ℝ) : ℂ) = (r : ℂ) ^ n := map_zpow₀ ofRealHom r n\n\n"}
{"name":"Complex.div_I","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq (HDiv.hDiv z Complex.I) (Neg.neg (HMul.hMul z Complex.I))","decl":"@[simp]\ntheorem div_I (z : ℂ) : z / I = -(z * I) :=\n  (div_eq_iff_mul_eq I_ne_zero).2 <| by simp [mul_assoc]\n\n"}
{"name":"Complex.inv_I","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ Eq (Inv.inv Complex.I) (Neg.neg Complex.I)","decl":"@[simp]\ntheorem inv_I : I⁻¹ = -I := by\n  rw [inv_eq_one_div, div_I, one_mul]\n\n-- @[simp]\n/- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): `simp` attribute removed as linter reports this can be proved\nby `simp only [@map_inv₀]` -/\n"}
{"name":"Complex.normSq_inv","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq (Complex.normSq (Inv.inv z)) (Inv.inv (Complex.normSq z))","decl":"theorem normSq_inv (z : ℂ) : normSq z⁻¹ = (normSq z)⁻¹ :=\n  map_inv₀ normSq z\n\n-- @[simp]\n/- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): `simp` attribute removed as linter reports this can be proved\nby `simp only [@map_div₀]` -/\n"}
{"name":"Complex.normSq_div","module":"Mathlib.Data.Complex.Basic","initialProofState":"z w : Complex\n⊢ Eq (Complex.normSq (HDiv.hDiv z w)) (HDiv.hDiv (Complex.normSq z) (Complex.normSq w))","decl":"theorem normSq_div (z w : ℂ) : normSq (z / w) = normSq z / normSq w :=\n  map_div₀ normSq z w\n\n"}
{"name":"Complex.div_ofReal","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\nx : Real\n⊢ Eq (HDiv.hDiv z ↑x) { re := HDiv.hDiv z.re x, im := HDiv.hDiv z.im x }","decl":"lemma div_ofReal (z : ℂ) (x : ℝ) : z / x = ⟨z.re / x, z.im / x⟩ := by\n  simp_rw [div_eq_inv_mul, ← ofReal_inv, ofReal_mul']\n\n"}
{"name":"Complex.div_natCast","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\nn : Nat\n⊢ Eq (HDiv.hDiv z ↑n) { re := HDiv.hDiv z.re ↑n, im := HDiv.hDiv z.im ↑n }","decl":"lemma div_natCast (z : ℂ) (n : ℕ) : z / n = ⟨z.re / n, z.im / n⟩ :=\n  mod_cast div_ofReal z n\n\n"}
{"name":"Complex.div_intCast","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\nn : Int\n⊢ Eq (HDiv.hDiv z ↑n) { re := HDiv.hDiv z.re ↑n, im := HDiv.hDiv z.im ↑n }","decl":"lemma div_intCast (z : ℂ) (n : ℤ) : z / n = ⟨z.re / n, z.im / n⟩ :=\n  mod_cast div_ofReal z n\n\n"}
{"name":"Complex.div_ratCast","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\nx : Rat\n⊢ Eq (HDiv.hDiv z ↑x) { re := HDiv.hDiv z.re ↑x, im := HDiv.hDiv z.im ↑x }","decl":"lemma div_ratCast (z : ℂ) (x : ℚ) : z / x = ⟨z.re / x, z.im / x⟩ :=\n  mod_cast div_ofReal z x\n\n"}
{"name":"Complex.div_ofNat","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (HDiv.hDiv z (OfNat.ofNat n)) { re := HDiv.hDiv z.re (OfNat.ofNat n), im := HDiv.hDiv z.im (OfNat.ofNat n) }","decl":"lemma div_ofNat (z : ℂ) (n : ℕ) [n.AtLeastTwo] :\n    z / ofNat(n) = ⟨z.re / ofNat(n), z.im / ofNat(n)⟩ :=\n  div_natCast z n\n\n"}
{"name":"Complex.div_ofReal_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\nx : Real\n⊢ Eq (HDiv.hDiv z ↑x).re (HDiv.hDiv z.re x)","decl":"@[simp] lemma div_ofReal_re (z : ℂ) (x : ℝ) : (z / x).re = z.re / x := by rw [div_ofReal]\n"}
{"name":"Complex.div_ofReal_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\nx : Real\n⊢ Eq (HDiv.hDiv z ↑x).im (HDiv.hDiv z.im x)","decl":"@[simp] lemma div_ofReal_im (z : ℂ) (x : ℝ) : (z / x).im = z.im / x := by rw [div_ofReal]\n"}
{"name":"Complex.div_natCast_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\nn : Nat\n⊢ Eq (HDiv.hDiv z ↑n).re (HDiv.hDiv z.re ↑n)","decl":"@[simp] lemma div_natCast_re (z : ℂ) (n : ℕ) : (z / n).re = z.re / n := by rw [div_natCast]\n"}
{"name":"Complex.div_natCast_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\nn : Nat\n⊢ Eq (HDiv.hDiv z ↑n).im (HDiv.hDiv z.im ↑n)","decl":"@[simp] lemma div_natCast_im (z : ℂ) (n : ℕ) : (z / n).im = z.im / n := by rw [div_natCast]\n"}
{"name":"Complex.div_intCast_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\nn : Int\n⊢ Eq (HDiv.hDiv z ↑n).re (HDiv.hDiv z.re ↑n)","decl":"@[simp] lemma div_intCast_re (z : ℂ) (n : ℤ) : (z / n).re = z.re / n := by rw [div_intCast]\n"}
{"name":"Complex.div_intCast_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\nn : Int\n⊢ Eq (HDiv.hDiv z ↑n).im (HDiv.hDiv z.im ↑n)","decl":"@[simp] lemma div_intCast_im (z : ℂ) (n : ℤ) : (z / n).im = z.im / n := by rw [div_intCast]\n"}
{"name":"Complex.div_ratCast_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\nx : Rat\n⊢ Eq (HDiv.hDiv z ↑x).re (HDiv.hDiv z.re ↑x)","decl":"@[simp] lemma div_ratCast_re (z : ℂ) (x : ℚ) : (z / x).re = z.re / x := by rw [div_ratCast]\n"}
{"name":"Complex.div_ratCast_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\nx : Rat\n⊢ Eq (HDiv.hDiv z ↑x).im (HDiv.hDiv z.im ↑x)","decl":"@[simp] lemma div_ratCast_im (z : ℂ) (x : ℚ) : (z / x).im = z.im / x := by rw [div_ratCast]\n\n"}
{"name":"Complex.div_ofNat_re","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (HDiv.hDiv z (OfNat.ofNat n)).re (HDiv.hDiv z.re (OfNat.ofNat n))","decl":"@[simp]\nlemma div_ofNat_re (z : ℂ) (n : ℕ) [n.AtLeastTwo] :\n    (z / ofNat(n)).re = z.re / ofNat(n) := div_natCast_re z n\n\n"}
{"name":"Complex.div_ofNat_im","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (HDiv.hDiv z (OfNat.ofNat n)).im (HDiv.hDiv z.im (OfNat.ofNat n))","decl":"@[simp]\nlemma div_ofNat_im (z : ℂ) (n : ℕ) [n.AtLeastTwo] :\n    (z / ofNat(n)).im = z.im / ofNat(n) := div_natCast_im z n\n\n"}
{"name":"Complex.instCharZero","module":"Mathlib.Data.Complex.Basic","initialProofState":"⊢ CharZero Complex","decl":"instance instCharZero : CharZero ℂ :=\n  charZero_of_inj_zero fun n h => by rwa [← ofReal_natCast, ofReal_eq_zero, Nat.cast_eq_zero] at h\n\n"}
{"name":"Complex.re_eq_add_conj","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq (↑z.re) (HDiv.hDiv (HAdd.hAdd z ((starRingEnd Complex) z)) 2)","decl":"/-- A complex number `z` plus its conjugate `conj z` is `2` times its real part. -/\ntheorem re_eq_add_conj (z : ℂ) : (z.re : ℂ) = (z + conj z) / 2 := by\n  simp only [add_conj, ofReal_mul, ofReal_ofNat, mul_div_cancel_left₀ (z.re : ℂ) two_ne_zero]\n\n"}
{"name":"Complex.im_eq_sub_conj","module":"Mathlib.Data.Complex.Basic","initialProofState":"z : Complex\n⊢ Eq (↑z.im) (HDiv.hDiv (HSub.hSub z ((starRingEnd Complex) z)) (HMul.hMul 2 Complex.I))","decl":"/-- A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. -/\ntheorem im_eq_sub_conj (z : ℂ) : (z.im : ℂ) = (z - conj z) / (2 * I) := by\n  simp only [sub_conj, ofReal_mul, ofReal_ofNat, mul_right_comm,\n    mul_div_cancel_left₀ _ (mul_ne_zero two_ne_zero I_ne_zero : 2 * I ≠ 0)]\n\n"}
{"name":"Complex.preimage_equivRealProd_prod","module":"Mathlib.Data.Complex.Basic","initialProofState":"s t : Set Real\n⊢ Eq (Set.preimage (⇑Complex.equivRealProd) (SProd.sprod s t)) (Complex.reProdIm s t)","decl":"/-- The preimage under `equivRealProd` of `s ×ˢ t` is `s ×ℂ t`. -/\nlemma preimage_equivRealProd_prod (s t : Set ℝ) : equivRealProd ⁻¹' (s ×ˢ t) = s ×ℂ t := rfl\n\n"}
{"name":"Complex.reProdIm_subset_iff","module":"Mathlib.Data.Complex.Basic","initialProofState":"s s₁ t t₁ : Set Real\n⊢ Iff (HasSubset.Subset (Complex.reProdIm s t) (Complex.reProdIm s₁ t₁)) (HasSubset.Subset (SProd.sprod s t) (SProd.sprod s₁ t₁))","decl":"/-- The inequality `s × t ⊆ s₁ × t₁` holds in `ℂ` iff it holds in `ℝ × ℝ`. -/\nlemma reProdIm_subset_iff {s s₁ t t₁ : Set ℝ} : s ×ℂ t ⊆ s₁ ×ℂ t₁ ↔ s ×ˢ t ⊆ s₁ ×ˢ t₁ := by\n  rw [← @preimage_equivRealProd_prod s t, ← @preimage_equivRealProd_prod s₁ t₁]\n  exact Equiv.preimage_subset equivRealProd _ _\n\n"}
{"name":"Complex.reProdIm_subset_iff'","module":"Mathlib.Data.Complex.Basic","initialProofState":"s s₁ t t₁ : Set Real\n⊢ Iff (HasSubset.Subset (Complex.reProdIm s t) (Complex.reProdIm s₁ t₁)) (Or (And (HasSubset.Subset s s₁) (HasSubset.Subset t t₁)) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection)))","decl":"/-- If `s ⊆ s₁ ⊆ ℝ` and `t ⊆ t₁ ⊆ ℝ`, then `s × t ⊆ s₁ × t₁` in `ℂ`. -/\nlemma reProdIm_subset_iff' {s s₁ t t₁ : Set ℝ} :\n    s ×ℂ t ⊆ s₁ ×ℂ t₁ ↔ s ⊆ s₁ ∧ t ⊆ t₁ ∨ s = ∅ ∨ t = ∅ := by\n  convert prod_subset_prod_iff\n  exact reProdIm_subset_iff\n\n"}
{"name":"Complex.reProdIm_nonempty","module":"Mathlib.Data.Complex.Basic","initialProofState":"s t : Set Real\n⊢ Iff (Complex.reProdIm s t).Nonempty (And s.Nonempty t.Nonempty)","decl":"@[simp] lemma reProdIm_nonempty : (s ×ℂ t).Nonempty ↔ s.Nonempty ∧ t.Nonempty := by\n  simp [Set.Nonempty, reProdIm, Complex.exists]\n\n"}
{"name":"Complex.reProdIm_eq_empty","module":"Mathlib.Data.Complex.Basic","initialProofState":"s t : Set Real\n⊢ Iff (Eq (Complex.reProdIm s t) EmptyCollection.emptyCollection) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection))","decl":"@[simp] lemma reProdIm_eq_empty : s ×ℂ t = ∅ ↔ s = ∅ ∨ t = ∅ := by\n  simp [← not_nonempty_iff_eq_empty, reProdIm_nonempty, -not_and, not_and_or]\n\n"}
{"name":"Complex.horizontalSegment_eq","module":"Mathlib.Data.Complex.Basic","initialProofState":"a₁ a₂ b : Real\n⊢ Eq (Set.image (fun x => HAdd.hAdd (↑x) (HMul.hMul (↑b) Complex.I)) (Set.uIcc a₁ a₂)) (Complex.reProdIm (Set.uIcc a₁ a₂) (Singleton.singleton b))","decl":"/-- A real segment `[a₁, a₂]` translated by `b * I` is the complex line segment. -/\nlemma horizontalSegment_eq (a₁ a₂ b : ℝ) :\n    (fun (x : ℝ) ↦ x + b * I) '' [[a₁, a₂]] = [[a₁, a₂]] ×ℂ {b} := by\n  rw [← preimage_equivRealProd_prod]\n  ext x\n  constructor\n  · intro hx\n    obtain ⟨x₁, hx₁, hx₁'⟩ := hx\n    simp [← hx₁', mem_preimage, mem_prod, hx₁]\n  · intro hx\n    obtain ⟨x₁, hx₁, hx₁', hx₁''⟩ := hx\n    refine ⟨x.re, x₁, by simp⟩\n\n"}
{"name":"Complex.verticalSegment_eq","module":"Mathlib.Data.Complex.Basic","initialProofState":"a b₁ b₂ : Real\n⊢ Eq (Set.image (fun y => HAdd.hAdd (↑a) (HMul.hMul (↑y) Complex.I)) (Set.uIcc b₁ b₂)) (Complex.reProdIm (Singleton.singleton a) (Set.uIcc b₁ b₂))","decl":"/-- A vertical segment `[b₁, b₂]` translated by `a` is the complex line segment. -/\nlemma verticalSegment_eq (a b₁ b₂ : ℝ) :\n    (fun (y : ℝ) ↦ a + y * I) '' [[b₁, b₂]] = {a} ×ℂ [[b₁, b₂]] := by\n  rw [← preimage_equivRealProd_prod]\n  ext x\n  constructor\n  · intro hx\n    obtain ⟨x₁, hx₁, hx₁'⟩ := hx\n    simp [← hx₁', mem_preimage, mem_prod, hx₁]\n  · intro hx\n    simp only [equivRealProd_apply, singleton_prod, mem_image, Prod.mk.injEq,\n      exists_eq_right_right, mem_preimage] at hx\n    obtain ⟨x₁, hx₁, hx₁', hx₁''⟩ := hx\n    refine ⟨x.im, x₁, by simp⟩\n\n"}
