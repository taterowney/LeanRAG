{"name":"CategoryTheory.Abelian.FunctorCategory.coimageObjIso_inv","module":"Mathlib.CategoryTheory.Abelian.FunctorCategory","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type w\ninst✝¹ : CategoryTheory.Category.{z, w} D\ninst✝ : CategoryTheory.Abelian D\nF G : CategoryTheory.Functor C D\nα : Quiver.Hom F G\nX : C\n⊢ Eq (CategoryTheory.Abelian.FunctorCategory.coimageObjIso α X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.map (CategoryTheory.Limits.kernel.ι (α.app X)) ((CategoryTheory.Limits.kernel.ι α).app X) (CategoryTheory.Limits.PreservesKernel.iso ((CategoryTheory.evaluation C D).obj X) α).inv (CategoryTheory.CategoryStruct.id (F.obj X)) ⋯) (CategoryTheory.Limits.cokernelComparison (CategoryTheory.Limits.kernel.ι α) ((CategoryTheory.evaluation C D).obj X)))","decl":"/-- The abelian coimage in a functor category can be calculated componentwise. -/\n@[simps!]\ndef coimageObjIso : (Abelian.coimage α).obj X ≅ Abelian.coimage (α.app X) :=\n  PreservesCokernel.iso ((evaluation C D).obj X) _ ≪≫\n    cokernel.mapIso _ _ (PreservesKernel.iso ((evaluation C D).obj X) _) (Iso.refl _)\n      (by\n        dsimp\n        simp only [Category.comp_id, PreservesKernel.iso_hom]\n        exact (kernelComparison_comp_ι _ ((evaluation C D).obj X)).symm)\n\n"}
{"name":"CategoryTheory.Abelian.FunctorCategory.coimageObjIso_hom","module":"Mathlib.CategoryTheory.Abelian.FunctorCategory","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type w\ninst✝¹ : CategoryTheory.Category.{z, w} D\ninst✝ : CategoryTheory.Abelian D\nF G : CategoryTheory.Functor C D\nα : Quiver.Hom F G\nX : C\n⊢ Eq (CategoryTheory.Abelian.FunctorCategory.coimageObjIso α X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesCokernel.iso ((CategoryTheory.evaluation C D).obj X) (CategoryTheory.Limits.kernel.ι α)).hom (CategoryTheory.Limits.cokernel.map ((CategoryTheory.Limits.kernel.ι α).app X) (CategoryTheory.Limits.kernel.ι (α.app X)) (CategoryTheory.Limits.kernelComparison α ((CategoryTheory.evaluation C D).obj X)) (CategoryTheory.CategoryStruct.id (F.obj X)) ⋯))","decl":"/-- The abelian coimage in a functor category can be calculated componentwise. -/\n@[simps!]\ndef coimageObjIso : (Abelian.coimage α).obj X ≅ Abelian.coimage (α.app X) :=\n  PreservesCokernel.iso ((evaluation C D).obj X) _ ≪≫\n    cokernel.mapIso _ _ (PreservesKernel.iso ((evaluation C D).obj X) _) (Iso.refl _)\n      (by\n        dsimp\n        simp only [Category.comp_id, PreservesKernel.iso_hom]\n        exact (kernelComparison_comp_ι _ ((evaluation C D).obj X)).symm)\n\n"}
{"name":"CategoryTheory.Abelian.FunctorCategory.imageObjIso_inv","module":"Mathlib.CategoryTheory.Abelian.FunctorCategory","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type w\ninst✝¹ : CategoryTheory.Category.{z, w} D\ninst✝ : CategoryTheory.Abelian D\nF G : CategoryTheory.Functor C D\nα : Quiver.Hom F G\nX : C\n⊢ Eq (CategoryTheory.Abelian.FunctorCategory.imageObjIso α X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.map (CategoryTheory.Limits.cokernel.π (α.app X)) ((CategoryTheory.Limits.cokernel.π α).app X) (CategoryTheory.CategoryStruct.id (G.obj X)) (CategoryTheory.Limits.cokernelComparison α ((CategoryTheory.evaluation C D).obj X)) ⋯) (CategoryTheory.Limits.PreservesKernel.iso ((CategoryTheory.evaluation C D).obj X) (CategoryTheory.Limits.cokernel.π α)).inv)","decl":"/-- The abelian image in a functor category can be calculated componentwise. -/\n@[simps!]\ndef imageObjIso : (Abelian.image α).obj X ≅ Abelian.image (α.app X) :=\n  PreservesKernel.iso ((evaluation C D).obj X) _ ≪≫\n    kernel.mapIso _ _ (Iso.refl _) (PreservesCokernel.iso ((evaluation C D).obj X) _)\n      (by\n        apply (cancel_mono (PreservesCokernel.iso ((evaluation C D).obj X) α).inv).1\n        simp only [Category.assoc, Iso.hom_inv_id]\n        dsimp\n        simp only [PreservesCokernel.iso_inv, Category.id_comp, Category.comp_id]\n        exact (π_comp_cokernelComparison _ ((evaluation C D).obj X)).symm)\n\n"}
{"name":"CategoryTheory.Abelian.FunctorCategory.imageObjIso_hom","module":"Mathlib.CategoryTheory.Abelian.FunctorCategory","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type w\ninst✝¹ : CategoryTheory.Category.{z, w} D\ninst✝ : CategoryTheory.Abelian D\nF G : CategoryTheory.Functor C D\nα : Quiver.Hom F G\nX : C\n⊢ Eq (CategoryTheory.Abelian.FunctorCategory.imageObjIso α X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelComparison (CategoryTheory.Limits.cokernel.π α) ((CategoryTheory.evaluation C D).obj X)) (CategoryTheory.Limits.kernel.map ((CategoryTheory.Limits.cokernel.π α).app X) (CategoryTheory.Limits.cokernel.π (α.app X)) (CategoryTheory.CategoryStruct.id (G.obj X)) (CategoryTheory.Limits.PreservesCokernel.iso ((CategoryTheory.evaluation C D).obj X) α).hom ⋯))","decl":"/-- The abelian image in a functor category can be calculated componentwise. -/\n@[simps!]\ndef imageObjIso : (Abelian.image α).obj X ≅ Abelian.image (α.app X) :=\n  PreservesKernel.iso ((evaluation C D).obj X) _ ≪≫\n    kernel.mapIso _ _ (Iso.refl _) (PreservesCokernel.iso ((evaluation C D).obj X) _)\n      (by\n        apply (cancel_mono (PreservesCokernel.iso ((evaluation C D).obj X) α).inv).1\n        simp only [Category.assoc, Iso.hom_inv_id]\n        dsimp\n        simp only [PreservesCokernel.iso_inv, Category.id_comp, Category.comp_id]\n        exact (π_comp_cokernelComparison _ ((evaluation C D).obj X)).symm)\n\n"}
{"name":"CategoryTheory.Abelian.FunctorCategory.coimageImageComparison_app","module":"Mathlib.CategoryTheory.Abelian.FunctorCategory","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type w\ninst✝¹ : CategoryTheory.Category.{z, w} D\ninst✝ : CategoryTheory.Abelian D\nF G : CategoryTheory.Functor C D\nα : Quiver.Hom F G\nX : C\n⊢ Eq (CategoryTheory.Abelian.coimageImageComparison (α.app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.FunctorCategory.coimageObjIso α X).inv (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Abelian.coimageImageComparison α).app X) (CategoryTheory.Abelian.FunctorCategory.imageObjIso α X).hom))","decl":"theorem coimageImageComparison_app :\n    coimageImageComparison (α.app X) =\n      (coimageObjIso α X).inv ≫ (coimageImageComparison α).app X ≫ (imageObjIso α X).hom := by\n  ext\n  dsimp\n  dsimp [imageObjIso, coimageObjIso, cokernel.map]\n  simp only [coimage_image_factorisation, PreservesKernel.iso_hom, Category.assoc,\n    kernel.lift_ι, Category.comp_id, PreservesCokernel.iso_inv,\n    cokernel.π_desc_assoc, Category.id_comp]\n  erw [kernelComparison_comp_ι _ ((evaluation C D).obj X),\n    π_comp_cokernelComparison_assoc _ ((evaluation C D).obj X)]\n  conv_lhs => rw [← coimage_image_factorisation α]\n  rfl\n\n"}
{"name":"CategoryTheory.Abelian.FunctorCategory.coimageImageComparison_app'","module":"Mathlib.CategoryTheory.Abelian.FunctorCategory","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type w\ninst✝¹ : CategoryTheory.Category.{z, w} D\ninst✝ : CategoryTheory.Abelian D\nF G : CategoryTheory.Functor C D\nα : Quiver.Hom F G\nX : C\n⊢ Eq ((CategoryTheory.Abelian.coimageImageComparison α).app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.FunctorCategory.coimageObjIso α X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.coimageImageComparison (α.app X)) (CategoryTheory.Abelian.FunctorCategory.imageObjIso α X).inv))","decl":"theorem coimageImageComparison_app' :\n    (coimageImageComparison α).app X =\n      (coimageObjIso α X).hom ≫ coimageImageComparison (α.app X) ≫ (imageObjIso α X).inv := by\n  simp only [coimageImageComparison_app, Iso.hom_inv_id_assoc, Iso.hom_inv_id, Category.assoc,\n    Category.comp_id]\n\n"}
{"name":"CategoryTheory.Abelian.FunctorCategory.functor_category_isIso_coimageImageComparison","module":"Mathlib.CategoryTheory.Abelian.FunctorCategory","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type w\ninst✝¹ : CategoryTheory.Category.{z, w} D\ninst✝ : CategoryTheory.Abelian D\nF G : CategoryTheory.Functor C D\nα : Quiver.Hom F G\n⊢ CategoryTheory.IsIso (CategoryTheory.Abelian.coimageImageComparison α)","decl":"instance functor_category_isIso_coimageImageComparison :\n    IsIso (Abelian.coimageImageComparison α) := by\n  have : ∀ X : C, IsIso ((Abelian.coimageImageComparison α).app X) := by\n    intros\n    rw [coimageImageComparison_app']\n    infer_instance\n  apply NatIso.isIso_of_isIso_app\n\n"}
