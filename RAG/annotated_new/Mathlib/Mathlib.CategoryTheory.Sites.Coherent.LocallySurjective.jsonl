{"name":"CategoryTheory.regularTopology.isLocallySurjective_iff","module":"Mathlib.CategoryTheory.Sites.Coherent.LocallySurjective","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹ : CategoryTheory.HasForget D\ninst✝ : CategoryTheory.Preregular C\nF G : CategoryTheory.Functor (Opposite C) D\nf : Quiver.Hom F G\n⊢ Iff (CategoryTheory.Presheaf.IsLocallySurjective (CategoryTheory.regularTopology C) f) (∀ (X : C) (y : (CategoryTheory.forget D).obj (G.obj { unop := X })), Exists fun X' => Exists fun φ => Exists fun x => Exists fun x => Eq ((f.app { unop := X' }) x) ((G.map { unop := φ }) y))","decl":"lemma regularTopology.isLocallySurjective_iff [Preregular C] {F G : Cᵒᵖ ⥤ D} (f : F ⟶ G) :\n    Presheaf.IsLocallySurjective (regularTopology C) f ↔\n      ∀ (X : C) (y : G.obj ⟨X⟩), (∃ (X' : C) (φ : X' ⟶ X) (_ : EffectiveEpi φ) (x : F.obj ⟨X'⟩),\n        f.app ⟨X'⟩ x = G.map ⟨φ⟩ y) := by\n  constructor\n  · intro ⟨h⟩ X y\n    specialize h y\n    rw [regularTopology.mem_sieves_iff_hasEffectiveEpi] at h\n    obtain ⟨X', π, h, h'⟩ := h\n    exact ⟨X', π, h, h'⟩\n  · intro h\n    refine ⟨fun y ↦ ?_⟩\n    obtain ⟨X', π, h, h'⟩ := h _ y\n    rw [regularTopology.mem_sieves_iff_hasEffectiveEpi]\n    exact ⟨X', π, h, h'⟩\n\n"}
{"name":"CategoryTheory.extensiveTopology.surjective_of_isLocallySurjective_sheaf_of_types","module":"Mathlib.CategoryTheory.Sites.Coherent.LocallySurjective","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.FinitaryPreExtensive C\nF G : CategoryTheory.Functor (Opposite C) (Type w)\nf : Quiver.Hom F G\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteProducts F\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts G\nh : CategoryTheory.Presheaf.IsLocallySurjective (CategoryTheory.extensiveTopology C) f\nX : C\n⊢ Function.Surjective (f.app { unop := X })","decl":"lemma extensiveTopology.surjective_of_isLocallySurjective_sheaf_of_types [FinitaryPreExtensive C]\n    {F G : Cᵒᵖ ⥤ Type w} (f : F ⟶ G) [PreservesFiniteProducts F] [PreservesFiniteProducts G]\n      (h : Presheaf.IsLocallySurjective (extensiveTopology C) f) {X : C} :\n        Function.Surjective (f.app (op X)) := by\n  intro x\n  replace h := h.1 x\n  rw [mem_sieves_iff_contains_colimit_cofan] at h\n  obtain ⟨α, _, Y, π, h, h'⟩ := h\n  let y : (a : α) → (F.obj ⟨Y a⟩) := fun a ↦ (h' a).choose\n  let _ : Fintype α := Fintype.ofFinite _\n  let ht := (Types.productLimitCone (fun a ↦ F.obj ⟨Y a⟩)).isLimit\n  let ht' := (Functor.Initial.isLimitWhiskerEquiv (Discrete.opposite α).inverse\n    (Cocone.op (Cofan.mk X π))).symm h.some.op\n  let i : ((a : α) → (F.obj ⟨Y a⟩)) ≅ (F.obj ⟨X⟩) :=\n    ht.conePointsIsoOfNatIso (isLimitOfPreserves F ht')\n      (Discrete.natIso (fun _ ↦ (Iso.refl (F.obj ⟨_⟩))))\n  refine ⟨i.hom y, ?_⟩\n  apply Concrete.isLimit_ext _ (isLimitOfPreserves G ht')\n  intro ⟨a⟩\n  simp only [Functor.comp_obj, Discrete.opposite_inverse_obj, Functor.op_obj, Discrete.functor_obj,\n    Functor.mapCone_pt, Cone.whisker_pt, Cocone.op_pt, Cofan.mk_pt, Functor.const_obj_obj,\n    Functor.mapCone_π_app, Cone.whisker_π, Cocone.op_π, whiskerLeft_app, NatTrans.op_app,\n    Cofan.mk_ι_app]\n  have : f.app ⟨Y a⟩ (y a) = G.map (π a).op x := (h' a).choose_spec\n  change _ = G.map (π a).op x\n  rw [← this]\n  erw [← NatTrans.naturality_apply (φ := f)]\n  change f.app _ ((i.hom ≫ F.map (π a).op) y) = _\n  erw [IsLimit.map_π]\n  rfl\n\n"}
{"name":"CategoryTheory.extensiveTopology.surjective_of_isLocallySurjective_sheafOfTypes","module":"Mathlib.CategoryTheory.Sites.Coherent.LocallySurjective","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.FinitaryPreExtensive C\nF G : CategoryTheory.Functor (Opposite C) (Type w)\nf : Quiver.Hom F G\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteProducts F\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts G\nh : CategoryTheory.Presheaf.IsLocallySurjective (CategoryTheory.extensiveTopology C) f\nX : C\n⊢ Function.Surjective (f.app { unop := X })","decl":"@[deprecated (since := \"2024-11-26\")]\nalias extensiveTopology.surjective_of_isLocallySurjective_sheafOfTypes :=\n  extensiveTopology.surjective_of_isLocallySurjective_sheaf_of_types\n\n"}
{"name":"CategoryTheory.extensiveTopology.presheafIsLocallySurjective_iff","module":"Mathlib.CategoryTheory.Sites.Coherent.LocallySurjective","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.HasForget D\ninst✝³ : CategoryTheory.FinitaryPreExtensive C\nF G : CategoryTheory.Functor (Opposite C) D\nf : Quiver.Hom F G\ninst✝² : CategoryTheory.Limits.PreservesFiniteProducts F\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteProducts G\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts (CategoryTheory.forget D)\n⊢ Iff (CategoryTheory.Presheaf.IsLocallySurjective (CategoryTheory.extensiveTopology C) f) (∀ (X : C), Function.Surjective ⇑(f.app { unop := X }))","decl":"lemma extensiveTopology.presheafIsLocallySurjective_iff [FinitaryPreExtensive C] {F G : Cᵒᵖ ⥤ D}\n    (f : F ⟶ G) [PreservesFiniteProducts F] [PreservesFiniteProducts G]\n      [PreservesFiniteProducts (forget D)] : Presheaf.IsLocallySurjective (extensiveTopology C) f ↔\n        ∀ (X : C), Function.Surjective (f.app (op X)) := by\n  constructor\n  · rw [Presheaf.isLocallySurjective_iff_whisker_forget (J := extensiveTopology C)]\n    exact fun h _ ↦ surjective_of_isLocallySurjective_sheaf_of_types (whiskerRight f (forget D)) h\n  · intro h\n    refine ⟨fun {X} y ↦ ?_⟩\n    obtain ⟨x, hx⟩ := h X y\n    convert (extensiveTopology C).top_mem' X\n    rw [← Sieve.id_mem_iff_eq_top]\n    simpa [Presheaf.imageSieve] using ⟨x, hx⟩\n\n"}
{"name":"CategoryTheory.extensiveTopology.isLocallySurjective_iff","module":"Mathlib.CategoryTheory.Sites.Coherent.LocallySurjective","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.HasForget D\ninst✝¹ : CategoryTheory.FinitaryExtensive C\nF G : CategoryTheory.Sheaf (CategoryTheory.extensiveTopology C) D\nf : Quiver.Hom F G\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts (CategoryTheory.forget D)\n⊢ Iff (CategoryTheory.Sheaf.IsLocallySurjective f) (∀ (X : C), Function.Surjective ⇑(f.val.app { unop := X }))","decl":"lemma extensiveTopology.isLocallySurjective_iff [FinitaryExtensive C]\n    {F G : Sheaf (extensiveTopology C) D} (f : F ⟶ G)\n      [PreservesFiniteProducts (forget D)] : IsLocallySurjective f ↔\n        ∀ (X : C), Function.Surjective (f.val.app (op X)) :=\n  extensiveTopology.presheafIsLocallySurjective_iff _ f.val\n\n"}
{"name":"CategoryTheory.regularTopology.isLocallySurjective_sheaf_of_types","module":"Mathlib.CategoryTheory.Sites.Coherent.LocallySurjective","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preregular C\ninst✝² : CategoryTheory.FinitaryPreExtensive C\nF G : CategoryTheory.Functor (Opposite C) (Type w)\nf : Quiver.Hom F G\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteProducts F\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts G\nh : CategoryTheory.Presheaf.IsLocallySurjective (CategoryTheory.coherentTopology C) f\n⊢ CategoryTheory.Presheaf.IsLocallySurjective (CategoryTheory.regularTopology C) f","decl":"lemma regularTopology.isLocallySurjective_sheaf_of_types [Preregular C] [FinitaryPreExtensive C]\n    {F G : Cᵒᵖ ⥤ Type w} (f : F ⟶ G) [PreservesFiniteProducts F] [PreservesFiniteProducts G]\n      (h : Presheaf.IsLocallySurjective (coherentTopology C) f) :\n        Presheaf.IsLocallySurjective (regularTopology C) f where\n  imageSieve_mem y := by\n    replace h := h.1 y\n    rw [coherentTopology.mem_sieves_iff_hasEffectiveEpiFamily] at h\n    obtain ⟨α, _, Z, π, h, h'⟩ := h\n    rw [mem_sieves_iff_hasEffectiveEpi]\n    let x : (a : α) → (F.obj ⟨Z a⟩) := fun a ↦ (h' a).choose\n    let _ : Fintype α := Fintype.ofFinite _\n    let i' : ((a : α) → (F.obj ⟨Z a⟩)) ≅ (F.obj ⟨∐ Z⟩) := (Types.productIso _).symm ≪≫\n      (PreservesProduct.iso F _).symm ≪≫ F.mapIso (opCoproductIsoProduct _).symm\n    refine ⟨∐ Z, Sigma.desc π, inferInstance, i'.hom x, ?_⟩\n    have := preservesLimitsOfShape_of_equiv (Discrete.opposite α).symm G\n    apply Concrete.isLimit_ext _ (isLimitOfPreserves G (coproductIsCoproduct Z).op)\n    intro ⟨⟨a⟩⟩\n    simp only [Functor.comp_obj, Functor.op_obj, Discrete.functor_obj, Functor.mapCone_pt,\n      Cocone.op_pt, Cofan.mk_pt, Functor.const_obj_obj, Functor.mapCone_π_app, Cocone.op_π,\n      NatTrans.op_app, Cofan.mk_ι_app, Functor.mapIso_symm, Iso.symm_hom, Iso.trans_hom,\n      Functor.mapIso_inv, types_comp_apply, i', ← NatTrans.naturality_apply]\n    have : f.app ⟨Z a⟩ (x a) = G.map (π a).op y := (h' a).choose_spec\n    convert this\n    · change F.map _ (F.map _ _) = _\n      rw [← FunctorToTypes.map_comp_apply, opCoproductIsoProduct_inv_comp_ι, ← piComparison_comp_π]\n      change ((PreservesProduct.iso F _).hom ≫ _) _ = _\n      have := Types.productIso_hom_comp_eval (fun a ↦ F.obj (op (Z a))) a\n      rw [← Iso.eq_inv_comp] at this\n      simp only [types_comp_apply, inv_hom_id_apply, congrFun this x]\n    · change G.map _ (G.map _ _) = _\n      simp only [← FunctorToTypes.map_comp_apply, ← op_comp, Sigma.ι_desc]\n\n"}
{"name":"CategoryTheory.regularTopology.isLocallySurjective_sheafOfTypes","module":"Mathlib.CategoryTheory.Sites.Coherent.LocallySurjective","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preregular C\ninst✝² : CategoryTheory.FinitaryPreExtensive C\nF G : CategoryTheory.Functor (Opposite C) (Type w)\nf : Quiver.Hom F G\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteProducts F\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts G\nh : CategoryTheory.Presheaf.IsLocallySurjective (CategoryTheory.coherentTopology C) f\n⊢ CategoryTheory.Presheaf.IsLocallySurjective (CategoryTheory.regularTopology C) f","decl":"@[deprecated (since := \"2024-11-26\")] alias regularTopology.isLocallySurjective_sheafOfTypes :=\nregularTopology.isLocallySurjective_sheaf_of_types\n\n"}
{"name":"CategoryTheory.coherentTopology.presheafIsLocallySurjective_iff","module":"Mathlib.CategoryTheory.Sites.Coherent.LocallySurjective","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁵ : CategoryTheory.HasForget D\nF G : CategoryTheory.Functor (Opposite C) D\nf : Quiver.Hom F G\ninst✝⁴ : CategoryTheory.Preregular C\ninst✝³ : CategoryTheory.FinitaryPreExtensive C\ninst✝² : CategoryTheory.Limits.PreservesFiniteProducts F\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteProducts G\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts (CategoryTheory.forget D)\n⊢ Iff (CategoryTheory.Presheaf.IsLocallySurjective (CategoryTheory.coherentTopology C) f) (CategoryTheory.Presheaf.IsLocallySurjective (CategoryTheory.regularTopology C) f)","decl":"lemma coherentTopology.presheafIsLocallySurjective_iff {F G : Cᵒᵖ ⥤ D} (f : F ⟶ G)\n    [Preregular C] [FinitaryPreExtensive C] [PreservesFiniteProducts F] [PreservesFiniteProducts G]\n      [PreservesFiniteProducts (forget D)] :\n        Presheaf.IsLocallySurjective (coherentTopology C) f ↔\n          Presheaf.IsLocallySurjective (regularTopology C) f := by\n  constructor\n  · rw [Presheaf.isLocallySurjective_iff_whisker_forget,\n      Presheaf.isLocallySurjective_iff_whisker_forget (J := regularTopology C)]\n    exact regularTopology.isLocallySurjective_sheaf_of_types _\n  · refine Presheaf.isLocallySurjective_of_le (J := regularTopology C) ?_ _\n    rw [← extensive_regular_generate_coherent]\n    exact (Coverage.gi _).gc.monotone_l le_sup_right\n\n"}
{"name":"CategoryTheory.coherentTopology.isLocallySurjective_iff","module":"Mathlib.CategoryTheory.Sites.Coherent.LocallySurjective","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.HasForget D\ninst✝² : CategoryTheory.Preregular C\ninst✝¹ : CategoryTheory.FinitaryExtensive C\nF G : CategoryTheory.Sheaf (CategoryTheory.coherentTopology C) D\nf : Quiver.Hom F G\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts (CategoryTheory.forget D)\n⊢ Iff (CategoryTheory.Sheaf.IsLocallySurjective f) (CategoryTheory.Presheaf.IsLocallySurjective (CategoryTheory.regularTopology C) f.val)","decl":"lemma coherentTopology.isLocallySurjective_iff [Preregular C] [FinitaryExtensive C]\n    {F G : Sheaf (coherentTopology C) D} (f : F ⟶ G) [PreservesFiniteProducts (forget D)] :\n      IsLocallySurjective f ↔ Presheaf.IsLocallySurjective (regularTopology C) f.val :=\n  presheafIsLocallySurjective_iff _ f.val\n\n"}
