{"name":"MulOpposite.instIsDomain","module":"Mathlib.Algebra.Ring.Opposite","initialProofState":"α : Type u_1\ninst✝¹ : Ring α\ninst✝ : IsDomain α\n⊢ IsDomain (MulOpposite α)","decl":"instance instIsDomain [Ring α] [IsDomain α] : IsDomain αᵐᵒᵖ :=\n  NoZeroDivisors.to_isDomain _\n\n"}
{"name":"AddOpposite.instIsDomain","module":"Mathlib.Algebra.Ring.Opposite","initialProofState":"α : Type u_1\ninst✝¹ : Ring α\ninst✝ : IsDomain α\n⊢ IsDomain (AddOpposite α)","decl":"instance instIsDomain [Ring α] [IsDomain α] : IsDomain αᵃᵒᵖ :=\n  NoZeroDivisors.to_isDomain _\n\n"}
{"name":"NonUnitalRingHom.toOpposite_apply","module":"Mathlib.Algebra.Ring.Opposite","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\nf : NonUnitalRingHom R S\nhf : ∀ (x y : R), Commute (f x) (f y)\n⊢ Eq (⇑(f.toOpposite hf)) (Function.comp MulOpposite.op ⇑f)","decl":"/-- A non-unital ring homomorphism `f : R →ₙ+* S` such that `f x` commutes with `f y` for all `x, y`\ndefines a non-unital ring homomorphism to `Sᵐᵒᵖ`. -/\n@[simps (config := .asFn)]\ndef NonUnitalRingHom.toOpposite {R S : Type*} [NonUnitalNonAssocSemiring R]\n    [NonUnitalNonAssocSemiring S] (f : R →ₙ+* S) (hf : ∀ x y, Commute (f x) (f y)) : R →ₙ+* Sᵐᵒᵖ :=\n  { ((opAddEquiv : S ≃+ Sᵐᵒᵖ).toAddMonoidHom.comp ↑f : R →+ Sᵐᵒᵖ), f.toMulHom.toOpposite hf with\n    toFun := MulOpposite.op ∘ f }\n\n"}
{"name":"NonUnitalRingHom.fromOpposite_apply","module":"Mathlib.Algebra.Ring.Opposite","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\nf : NonUnitalRingHom R S\nhf : ∀ (x y : R), Commute (f x) (f y)\n⊢ Eq (⇑(f.fromOpposite hf)) (Function.comp (⇑f) MulOpposite.unop)","decl":"/-- A non-unital ring homomorphism `f : R →ₙ* S` such that `f x` commutes with `f y` for all `x, y`\ndefines a non-unital ring homomorphism from `Rᵐᵒᵖ`. -/\n@[simps (config := .asFn)]\ndef NonUnitalRingHom.fromOpposite {R S : Type*} [NonUnitalNonAssocSemiring R]\n    [NonUnitalNonAssocSemiring S] (f : R →ₙ+* S) (hf : ∀ x y, Commute (f x) (f y)) : Rᵐᵒᵖ →ₙ+* S :=\n  { (f.toAddMonoidHom.comp (opAddEquiv : R ≃+ Rᵐᵒᵖ).symm.toAddMonoidHom : Rᵐᵒᵖ →+ S),\n    f.toMulHom.fromOpposite hf with toFun := f ∘ MulOpposite.unop }\n\n"}
{"name":"NonUnitalRingHom.op_symm_apply_apply","module":"Mathlib.Algebra.Ring.Opposite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : NonUnitalNonAssocSemiring β\nf : NonUnitalRingHom (MulOpposite α) (MulOpposite β)\na✝ : α\n⊢ Eq ((NonUnitalRingHom.op.symm f) a✝) ((↑(AddMonoidHom.mulUnop f.toAddMonoidHom)).toFun a✝)","decl":"/-- A non-unital ring hom `α →ₙ+* β` can equivalently be viewed as a non-unital ring hom\n`αᵐᵒᵖ →+* βᵐᵒᵖ`. This is the action of the (fully faithful) `ᵐᵒᵖ`-functor on morphisms. -/\n@[simps]\ndef NonUnitalRingHom.op {α β} [NonUnitalNonAssocSemiring α] [NonUnitalNonAssocSemiring β] :\n    (α →ₙ+* β) ≃ (αᵐᵒᵖ →ₙ+* βᵐᵒᵖ) where\n  toFun f := { AddMonoidHom.mulOp f.toAddMonoidHom, MulHom.op f.toMulHom with }\n  invFun f := { AddMonoidHom.mulUnop f.toAddMonoidHom, MulHom.unop f.toMulHom with }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"NonUnitalRingHom.op_apply_apply","module":"Mathlib.Algebra.Ring.Opposite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : NonUnitalNonAssocSemiring β\nf : NonUnitalRingHom α β\na✝ : MulOpposite α\n⊢ Eq ((NonUnitalRingHom.op f) a✝) ((↑(AddMonoidHom.mulOp f.toAddMonoidHom)).toFun a✝)","decl":"/-- A non-unital ring hom `α →ₙ+* β` can equivalently be viewed as a non-unital ring hom\n`αᵐᵒᵖ →+* βᵐᵒᵖ`. This is the action of the (fully faithful) `ᵐᵒᵖ`-functor on morphisms. -/\n@[simps]\ndef NonUnitalRingHom.op {α β} [NonUnitalNonAssocSemiring α] [NonUnitalNonAssocSemiring β] :\n    (α →ₙ+* β) ≃ (αᵐᵒᵖ →ₙ+* βᵐᵒᵖ) where\n  toFun f := { AddMonoidHom.mulOp f.toAddMonoidHom, MulHom.op f.toMulHom with }\n  invFun f := { AddMonoidHom.mulUnop f.toAddMonoidHom, MulHom.unop f.toMulHom with }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"RingHom.toOpposite_apply","module":"Mathlib.Algebra.Ring.Opposite","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nhf : ∀ (x y : R), Commute (f x) (f y)\n⊢ Eq (⇑(f.toOpposite hf)) (Function.comp MulOpposite.op ⇑f)","decl":"/-- A ring homomorphism `f : R →+* S` such that `f x` commutes with `f y` for all `x, y` defines\na ring homomorphism to `Sᵐᵒᵖ`. -/\n@[simps (config := .asFn)]\ndef RingHom.toOpposite {R S : Type*} [Semiring R] [Semiring S] (f : R →+* S)\n    (hf : ∀ x y, Commute (f x) (f y)) : R →+* Sᵐᵒᵖ :=\n  { ((opAddEquiv : S ≃+ Sᵐᵒᵖ).toAddMonoidHom.comp ↑f : R →+ Sᵐᵒᵖ), f.toMonoidHom.toOpposite hf with\n    toFun := MulOpposite.op ∘ f }\n\n"}
{"name":"RingHom.fromOpposite_apply","module":"Mathlib.Algebra.Ring.Opposite","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nhf : ∀ (x y : R), Commute (f x) (f y)\n⊢ Eq (⇑(f.fromOpposite hf)) (Function.comp (⇑f) MulOpposite.unop)","decl":"/-- A ring homomorphism `f : R →+* S` such that `f x` commutes with `f y` for all `x, y` defines\na ring homomorphism from `Rᵐᵒᵖ`. -/\n@[simps (config := .asFn)]\ndef RingHom.fromOpposite {R S : Type*} [Semiring R] [Semiring S] (f : R →+* S)\n    (hf : ∀ x y, Commute (f x) (f y)) : Rᵐᵒᵖ →+* S :=\n  { (f.toAddMonoidHom.comp (opAddEquiv : R ≃+ Rᵐᵒᵖ).symm.toAddMonoidHom : Rᵐᵒᵖ →+ S),\n    f.toMonoidHom.fromOpposite hf with toFun := f ∘ MulOpposite.unop }\n\n"}
{"name":"RingHom.op_symm_apply_apply","module":"Mathlib.Algebra.Ring.Opposite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : NonAssocSemiring α\ninst✝ : NonAssocSemiring β\nf : RingHom (MulOpposite α) (MulOpposite β)\na✝ : α\n⊢ Eq ((RingHom.op.symm f) a✝) (MulOpposite.unop (f (MulOpposite.op a✝)))","decl":"/-- A ring hom `α →+* β` can equivalently be viewed as a ring hom `αᵐᵒᵖ →+* βᵐᵒᵖ`. This is the\naction of the (fully faithful) `ᵐᵒᵖ`-functor on morphisms. -/\n@[simps!]\ndef RingHom.op {α β} [NonAssocSemiring α] [NonAssocSemiring β] :\n    (α →+* β) ≃ (αᵐᵒᵖ →+* βᵐᵒᵖ) where\n  toFun f := { AddMonoidHom.mulOp f.toAddMonoidHom, MonoidHom.op f.toMonoidHom with }\n  invFun f := { AddMonoidHom.mulUnop f.toAddMonoidHom, MonoidHom.unop f.toMonoidHom with }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"RingHom.op_apply_apply","module":"Mathlib.Algebra.Ring.Opposite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : NonAssocSemiring α\ninst✝ : NonAssocSemiring β\nf : RingHom α β\na✝ : MulOpposite α\n⊢ Eq ((RingHom.op f) a✝) (MulOpposite.op (f (MulOpposite.unop a✝)))","decl":"/-- A ring hom `α →+* β` can equivalently be viewed as a ring hom `αᵐᵒᵖ →+* βᵐᵒᵖ`. This is the\naction of the (fully faithful) `ᵐᵒᵖ`-functor on morphisms. -/\n@[simps!]\ndef RingHom.op {α β} [NonAssocSemiring α] [NonAssocSemiring β] :\n    (α →+* β) ≃ (αᵐᵒᵖ →+* βᵐᵒᵖ) where\n  toFun f := { AddMonoidHom.mulOp f.toAddMonoidHom, MonoidHom.op f.toMonoidHom with }\n  invFun f := { AddMonoidHom.mulUnop f.toAddMonoidHom, MonoidHom.unop f.toMonoidHom with }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
