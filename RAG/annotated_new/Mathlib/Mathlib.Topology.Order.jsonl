{"name":"TopologicalSpace.GenerateOpen.brecOn","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\ng : Set (Set Œ±)\nmotive‚úù : (a : Set Œ±) ‚Üí TopologicalSpace.GenerateOpen g a ‚Üí Prop\na‚úù : Set Œ±\nx‚úù : TopologicalSpace.GenerateOpen g a‚úù\nih‚úù : ‚àÄ (a : Set Œ±) (x : TopologicalSpace.GenerateOpen g a), x.below ‚Üí motive‚úù a x\n‚ä¢ motive‚úù a‚úù x‚úù","decl":"/-- The open sets of the least topology containing a collection of basic sets. -/\ninductive GenerateOpen (g : Set (Set Œ±)) : Set Œ± ‚Üí Prop\n  | basic : ‚àÄ s ‚àà g, GenerateOpen g s\n  | univ : GenerateOpen g univ\n  | inter : ‚àÄ s t, GenerateOpen g s ‚Üí GenerateOpen g t ‚Üí GenerateOpen g (s ‚à© t)\n  | sUnion : ‚àÄ S : Set (Set Œ±), (‚àÄ s ‚àà S, GenerateOpen g s) ‚Üí GenerateOpen g (‚ãÉ‚ÇÄ S)\n\n"}
{"name":"TopologicalSpace.isOpen_generateFrom_of_mem","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\ng : Set (Set Œ±)\ns : Set Œ±\nhs : Membership.mem g s\n‚ä¢ IsOpen s","decl":"theorem isOpen_generateFrom_of_mem {g : Set (Set Œ±)} {s : Set Œ±} (hs : s ‚àà g) :\n    IsOpen[generateFrom g] s :=\n  GenerateOpen.basic s hs\n\n"}
{"name":"TopologicalSpace.nhds_generateFrom","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\ng : Set (Set Œ±)\na : Œ±\n‚ä¢ Eq (nhds a) (iInf fun s => iInf fun h => Filter.principal s)","decl":"theorem nhds_generateFrom {g : Set (Set Œ±)} {a : Œ±} :\n    @nhds Œ± (generateFrom g) a = ‚®Ö s ‚àà { s | a ‚àà s ‚àß s ‚àà g }, ùìü s := by\n  letI := generateFrom g\n  rw [nhds_def]\n  refine le_antisymm (biInf_mono fun s ‚ü®as, sg‚ü© => ‚ü®as, .basic _ sg‚ü©) <| le_iInf‚ÇÇ ?_\n  rintro s ‚ü®ha, hs‚ü©\n  induction hs with\n  | basic _ hs => exact iInf‚ÇÇ_le _ ‚ü®ha, hs‚ü©\n  | univ => exact le_top.trans_eq principal_univ.symm\n  | inter _ _ _ _ hs ht => exact (le_inf (hs ha.1) (ht ha.2)).trans_eq inf_principal\n  | sUnion _ _ hS =>\n    let ‚ü®t, htS, hat‚ü© := ha\n    exact (hS t htS hat).trans (principal_mono.2 <| subset_sUnion_of_mem htS)\n\n"}
{"name":"TopologicalSpace.tendsto_nhds_generateFrom_iff","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type u_1\nm : Œ± ‚Üí Œ≤\nf : Filter Œ±\ng : Set (Set Œ≤)\nb : Œ≤\n‚ä¢ Iff (Filter.Tendsto m f (nhds b)) (‚àÄ (s : Set Œ≤), Membership.mem g s ‚Üí Membership.mem s b ‚Üí Membership.mem f (Set.preimage m s))","decl":"lemma tendsto_nhds_generateFrom_iff {Œ≤ : Type*} {m : Œ± ‚Üí Œ≤} {f : Filter Œ±} {g : Set (Set Œ≤)}\n    {b : Œ≤} : Tendsto m f (@nhds Œ≤ (generateFrom g) b) ‚Üî ‚àÄ s ‚àà g, b ‚àà s ‚Üí m ‚Åª¬π' s ‚àà f := by\n  simp only [nhds_generateFrom, @forall_swap (b ‚àà _), tendsto_iInf, mem_setOf_eq, and_imp,\n    tendsto_principal]; rfl\n\n"}
{"name":"TopologicalSpace.nhds_mkOfNhds_of_hasBasis","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nn : Œ± ‚Üí Filter Œ±\nŒπ : Œ± ‚Üí Sort u_1\np : (a : Œ±) ‚Üí Œπ a ‚Üí Prop\ns : (a : Œ±) ‚Üí Œπ a ‚Üí Set Œ±\nhb : ‚àÄ (a : Œ±), (n a).HasBasis (p a) (s a)\nhpure : ‚àÄ (a : Œ±) (i : Œπ a), p a i ‚Üí Membership.mem (s a i) a\nhopen : ‚àÄ (a : Œ±) (i : Œπ a), p a i ‚Üí Filter.Eventually (fun x => Membership.mem (n x) (s a i)) (n a)\na : Œ±\n‚ä¢ Eq (nhds a) (n a)","decl":"theorem nhds_mkOfNhds_of_hasBasis {n : Œ± ‚Üí Filter Œ±} {Œπ : Œ± ‚Üí Sort*} {p : ‚àÄ a, Œπ a ‚Üí Prop}\n    {s : ‚àÄ a, Œπ a ‚Üí Set Œ±} (hb : ‚àÄ a, (n a).HasBasis (p a) (s a))\n    (hpure : ‚àÄ a i, p a i ‚Üí a ‚àà s a i) (hopen : ‚àÄ a i, p a i ‚Üí ‚àÄ·∂† x in n a, s a i ‚àà n x) (a : Œ±) :\n    @nhds Œ± (.mkOfNhds n) a = n a := by\n  let t : TopologicalSpace Œ± := .mkOfNhds n\n  apply le_antisymm\n  ¬∑ intro U hU\n    replace hpure : pure ‚â§ n := fun x ‚Ü¶ (hb x).ge_iff.2 (hpure x)\n    refine mem_nhds_iff.2 ‚ü®{x | U ‚àà n x}, fun x hx ‚Ü¶ hpure x hx, fun x hx ‚Ü¶ ?_, hU‚ü©\n    rcases (hb x).mem_iff.1 hx with ‚ü®i, hpi, hi‚ü©\n    exact (hopen x i hpi).mono fun y hy ‚Ü¶ mem_of_superset hy hi\n  ¬∑ exact (nhds_basis_opens a).ge_iff.2 fun U ‚ü®haU, hUo‚ü© ‚Ü¶ hUo a haU\n\n"}
{"name":"TopologicalSpace.nhds_mkOfNhds","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nn : Œ± ‚Üí Filter Œ±\na : Œ±\nh‚ÇÄ : LE.le Pure.pure n\nh‚ÇÅ : ‚àÄ (a : Œ±) (s : Set Œ±), Membership.mem (n a) s ‚Üí Filter.Eventually (fun y => Membership.mem (n y) s) (n a)\n‚ä¢ Eq (nhds a) (n a)","decl":"theorem nhds_mkOfNhds (n : Œ± ‚Üí Filter Œ±) (a : Œ±) (h‚ÇÄ : pure ‚â§ n)\n    (h‚ÇÅ : ‚àÄ a, ‚àÄ s ‚àà n a, ‚àÄ·∂† y in n a, s ‚àà n y) :\n    @nhds Œ± (TopologicalSpace.mkOfNhds n) a = n a :=\n  nhds_mkOfNhds_of_hasBasis (fun a ‚Ü¶ (n a).basis_sets) h‚ÇÄ h‚ÇÅ _\n\n"}
{"name":"TopologicalSpace.nhds_mkOfNhds_single","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\ninst‚úù : DecidableEq Œ±\na‚ÇÄ : Œ±\nl : Filter Œ±\nh : LE.le (Pure.pure a‚ÇÄ) l\nb : Œ±\n‚ä¢ Eq (nhds b) (Function.update Pure.pure a‚ÇÄ l b)","decl":"theorem nhds_mkOfNhds_single [DecidableEq Œ±] {a‚ÇÄ : Œ±} {l : Filter Œ±} (h : pure a‚ÇÄ ‚â§ l) (b : Œ±) :\n    @nhds Œ± (TopologicalSpace.mkOfNhds (update pure a‚ÇÄ l)) b =\n      (update pure a‚ÇÄ l : Œ± ‚Üí Filter Œ±) b := by\n  refine nhds_mkOfNhds _ _ (le_update_iff.mpr ‚ü®h, fun _ _ => le_rfl‚ü©) fun a s hs => ?_\n  rcases eq_or_ne a a‚ÇÄ with (rfl | ha)\n  ¬∑ filter_upwards [hs] with b hb\n    rcases eq_or_ne b a with (rfl | hb)\n    ¬∑ exact hs\n    ¬∑ rwa [update_of_ne hb]\n  ¬∑ simpa only [update_of_ne ha, mem_pure, eventually_pure] using hs\n\n"}
{"name":"TopologicalSpace.nhds_mkOfNhds_filterBasis","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nB : Œ± ‚Üí FilterBasis Œ±\na : Œ±\nh‚ÇÄ : ‚àÄ (x : Œ±) (n : Set Œ±), Membership.mem (B x) n ‚Üí Membership.mem n x\nh‚ÇÅ : ‚àÄ (x : Œ±) (n : Set Œ±), Membership.mem (B x) n ‚Üí Exists fun n‚ÇÅ => And (Membership.mem (B x) n‚ÇÅ) (‚àÄ (x' : Œ±), Membership.mem n‚ÇÅ x' ‚Üí Exists fun n‚ÇÇ => And (Membership.mem (B x') n‚ÇÇ) (HasSubset.Subset n‚ÇÇ n))\n‚ä¢ Eq (nhds a) (B a).filter","decl":"theorem nhds_mkOfNhds_filterBasis (B : Œ± ‚Üí FilterBasis Œ±) (a : Œ±) (h‚ÇÄ : ‚àÄ x, ‚àÄ n ‚àà B x, x ‚àà n)\n    (h‚ÇÅ : ‚àÄ x, ‚àÄ n ‚àà B x, ‚àÉ n‚ÇÅ ‚àà B x, ‚àÄ x' ‚àà n‚ÇÅ, ‚àÉ n‚ÇÇ ‚àà B x', n‚ÇÇ ‚äÜ n) :\n    @nhds Œ± (TopologicalSpace.mkOfNhds fun x => (B x).filter) a = (B a).filter :=\n  nhds_mkOfNhds_of_hasBasis (fun a ‚Ü¶ (B a).hasBasis) h‚ÇÄ h‚ÇÅ a\n\n"}
{"name":"TopologicalSpace.le_def","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nt s : TopologicalSpace Œ±\n‚ä¢ Iff (LE.le t s) (LE.le IsOpen IsOpen)","decl":"protected theorem le_def {Œ±} {t s : TopologicalSpace Œ±} : t ‚â§ s ‚Üî IsOpen[s] ‚â§ IsOpen[t] :=\n  Iff.rfl\n\n"}
{"name":"TopologicalSpace.le_generateFrom_iff_subset_isOpen","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\ng : Set (Set Œ±)\nt : TopologicalSpace Œ±\n‚ä¢ Iff (LE.le t (TopologicalSpace.generateFrom g)) (HasSubset.Subset g (setOf fun s => IsOpen s))","decl":"theorem le_generateFrom_iff_subset_isOpen {g : Set (Set Œ±)} {t : TopologicalSpace Œ±} :\n    t ‚â§ generateFrom g ‚Üî g ‚äÜ { s | IsOpen[t] s } :=\n  ‚ü®fun ht s hs => ht _ <| .basic s hs, fun hg _s hs =>\n    hs.recOn (fun _ h => hg h) isOpen_univ (fun _ _ _ _ => IsOpen.inter) fun _ _ => isOpen_sUnion‚ü©\n\n"}
{"name":"TopologicalSpace.mkOfClosure_sets","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\ns : Set (Set Œ±)\nhs : Eq (setOf fun u => TopologicalSpace.GenerateOpen s u) s\n‚ä¢ Eq (TopologicalSpace.mkOfClosure s hs) (TopologicalSpace.generateFrom s)","decl":"theorem mkOfClosure_sets {s : Set (Set Œ±)} {hs : { u | GenerateOpen s u } = s} :\n    TopologicalSpace.mkOfClosure s hs = generateFrom s :=\n  TopologicalSpace.ext hs.symm\n\n"}
{"name":"TopologicalSpace.gc_generateFrom","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\n‚ä¢ GaloisConnection (fun t => OrderDual.toDual (setOf fun s => IsOpen s)) (Function.comp TopologicalSpace.generateFrom ‚áëOrderDual.ofDual)","decl":"theorem gc_generateFrom (Œ±) :\n    GaloisConnection (fun t : TopologicalSpace Œ± => OrderDual.toDual { s | IsOpen[t] s })\n      (generateFrom ‚àò OrderDual.ofDual) := fun _ _ =>\n  le_generateFrom_iff_subset_isOpen.symm\n\n"}
{"name":"TopologicalSpace.generateFrom_anti","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\ng‚ÇÅ g‚ÇÇ : Set (Set Œ±)\nh : HasSubset.Subset g‚ÇÅ g‚ÇÇ\n‚ä¢ LE.le (TopologicalSpace.generateFrom g‚ÇÇ) (TopologicalSpace.generateFrom g‚ÇÅ)","decl":"@[mono, gcongr]\ntheorem generateFrom_anti {Œ±} {g‚ÇÅ g‚ÇÇ : Set (Set Œ±)} (h : g‚ÇÅ ‚äÜ g‚ÇÇ) :\n    generateFrom g‚ÇÇ ‚â§ generateFrom g‚ÇÅ :=\n  (gc_generateFrom _).monotone_u h\n\n"}
{"name":"TopologicalSpace.generateFrom_setOf_isOpen","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\n‚ä¢ Eq (TopologicalSpace.generateFrom (setOf fun s => IsOpen s)) t","decl":"theorem generateFrom_setOf_isOpen (t : TopologicalSpace Œ±) :\n    generateFrom { s | IsOpen[t] s } = t :=\n  (gciGenerateFrom Œ±).u_l_eq t\n\n"}
{"name":"TopologicalSpace.leftInverse_generateFrom","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\n‚ä¢ Function.LeftInverse TopologicalSpace.generateFrom fun t => setOf fun s => IsOpen s","decl":"theorem leftInverse_generateFrom :\n    LeftInverse generateFrom fun t : TopologicalSpace Œ± => { s | IsOpen[t] s } :=\n  (gciGenerateFrom Œ±).u_l_leftInverse\n\n"}
{"name":"TopologicalSpace.generateFrom_surjective","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\n‚ä¢ Function.Surjective TopologicalSpace.generateFrom","decl":"theorem generateFrom_surjective : Surjective (generateFrom : Set (Set Œ±) ‚Üí TopologicalSpace Œ±) :=\n  (gciGenerateFrom Œ±).u_surjective\n\n"}
{"name":"TopologicalSpace.setOf_isOpen_injective","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\n‚ä¢ Function.Injective fun t => setOf fun s => IsOpen s","decl":"theorem setOf_isOpen_injective : Injective fun t : TopologicalSpace Œ± => { s | IsOpen[t] s } :=\n  (gciGenerateFrom Œ±).l_injective\n\n"}
{"name":"IsOpen.mono","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nt‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±\ns : Set Œ±\nhs : IsOpen s\nh : LE.le t‚ÇÅ t‚ÇÇ\n‚ä¢ IsOpen s","decl":"theorem IsOpen.mono (hs : IsOpen[t‚ÇÇ] s) (h : t‚ÇÅ ‚â§ t‚ÇÇ) : IsOpen[t‚ÇÅ] s := h s hs\n\n"}
{"name":"IsClosed.mono","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nt‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±\ns : Set Œ±\nhs : IsClosed s\nh : LE.le t‚ÇÅ t‚ÇÇ\n‚ä¢ IsClosed s","decl":"theorem IsClosed.mono (hs : IsClosed[t‚ÇÇ] s) (h : t‚ÇÅ ‚â§ t‚ÇÇ) : IsClosed[t‚ÇÅ] s :=\n  (@isOpen_compl_iff Œ± s t‚ÇÅ).mp <| hs.isOpen_compl.mono h\n\n"}
{"name":"closure.mono","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nt‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±\ns : Set Œ±\nh : LE.le t‚ÇÅ t‚ÇÇ\n‚ä¢ HasSubset.Subset (closure s) (closure s)","decl":"theorem closure.mono (h : t‚ÇÅ ‚â§ t‚ÇÇ) : closure[t‚ÇÅ] s ‚äÜ closure[t‚ÇÇ] s :=\n  @closure_minimal _ s (@closure _ t‚ÇÇ s) t‚ÇÅ subset_closure (IsClosed.mono isClosed_closure h)\n\n"}
{"name":"isOpen_implies_isOpen_iff","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nt‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±\n‚ä¢ Iff (‚àÄ (s : Set Œ±), IsOpen s ‚Üí IsOpen s) (LE.le t‚ÇÇ t‚ÇÅ)","decl":"theorem isOpen_implies_isOpen_iff : (‚àÄ s, IsOpen[t‚ÇÅ] s ‚Üí IsOpen[t‚ÇÇ] s) ‚Üî t‚ÇÇ ‚â§ t‚ÇÅ :=\n  Iff.rfl\n\n"}
{"name":"TopologicalSpace.isOpen_top_iff","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_2\nU : Set Œ±\n‚ä¢ Iff (IsOpen U) (Or (Eq U EmptyCollection.emptyCollection) (Eq U Set.univ))","decl":"/-- The only open sets in the indiscrete topology are the empty set and the whole space. -/\ntheorem TopologicalSpace.isOpen_top_iff {Œ±} (U : Set Œ±) : IsOpen[‚ä§] U ‚Üî U = ‚àÖ ‚à® U = univ :=\n  ‚ü®fun h => by\n    induction h with\n    | basic _ h => exact False.elim h\n    | univ => exact .inr rfl\n    | inter _ _ _ _ h‚ÇÅ h‚ÇÇ =>\n      rcases h‚ÇÅ with (rfl | rfl) <;> rcases h‚ÇÇ with (rfl | rfl) <;> simp\n    | sUnion _ _ ih => exact sUnion_mem_empty_univ ih, by\n      rintro (rfl | rfl)\n      exacts [@isOpen_empty _ ‚ä§, @isOpen_univ _ ‚ä§]‚ü©\n\n"}
{"name":"DiscreteTopology.eq_bot","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_2\nt : TopologicalSpace Œ±\nself : DiscreteTopology Œ±\n‚ä¢ Eq t Bot.bot","decl":"/-- A topological space is discrete if every set is open, that is,\n  its topology equals the discrete topology `‚ä•`. -/\nclass DiscreteTopology (Œ± : Type*) [t : TopologicalSpace Œ±] : Prop where\n  /-- The `TopologicalSpace` structure on a type with discrete topology is equal to `‚ä•`. -/\n  eq_bot : t = ‚ä•\n\n"}
{"name":"discreteTopology_bot","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_2\n‚ä¢ DiscreteTopology Œ±","decl":"theorem discreteTopology_bot (Œ± : Type*) : @DiscreteTopology Œ± ‚ä• :=\n  @DiscreteTopology.mk Œ± ‚ä• rfl\n\n"}
{"name":"isOpen_discrete","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : DiscreteTopology Œ±\ns : Set Œ±\n‚ä¢ IsOpen s","decl":"@[simp]\ntheorem isOpen_discrete (s : Set Œ±) : IsOpen s := (@DiscreteTopology.eq_bot Œ± _).symm ‚ñ∏ trivial\n\n"}
{"name":"isClosed_discrete","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : DiscreteTopology Œ±\ns : Set Œ±\n‚ä¢ IsClosed s","decl":"@[simp] theorem isClosed_discrete (s : Set Œ±) : IsClosed s := ‚ü®isOpen_discrete _‚ü©\n\n"}
{"name":"closure_discrete","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : DiscreteTopology Œ±\ns : Set Œ±\n‚ä¢ Eq (closure s) s","decl":"@[simp] theorem closure_discrete (s : Set Œ±) : closure s = s := (isClosed_discrete _).closure_eq\n\n"}
{"name":"dense_discrete","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : DiscreteTopology Œ±\ns : Set Œ±\n‚ä¢ Iff (Dense s) (Eq s Set.univ)","decl":"@[simp] theorem dense_discrete {s : Set Œ±} : Dense s ‚Üî s = univ := by simp [dense_iff_closure_eq]\n\n"}
{"name":"denseRange_discrete","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : DiscreteTopology Œ±\nŒπ : Type u_3\nf : Œπ ‚Üí Œ±\n‚ä¢ Iff (DenseRange f) (Function.Surjective f)","decl":"@[simp]\ntheorem denseRange_discrete {Œπ : Type*} {f : Œπ ‚Üí Œ±} : DenseRange f ‚Üî Surjective f := by\n  rw [DenseRange, dense_discrete, range_eq_univ]\n\n"}
{"name":"continuous_of_discreteTopology","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : DiscreteTopology Œ±\nŒ≤ : Type u_2\ninst‚úù : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Continuous f","decl":"@[nontriviality, continuity, fun_prop]\ntheorem continuous_of_discreteTopology [TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤} : Continuous f :=\n  continuous_def.2 fun _ _ => isOpen_discrete _\n\n"}
{"name":"continuous_discrete_rng","module":"Mathlib.Topology.Order","initialProofState":"Œ≤ : Type u_2\nŒ± : Type u_3\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : DiscreteTopology Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (Continuous f) (‚àÄ (b : Œ≤), IsOpen (Set.preimage f (Singleton.singleton b)))","decl":"/-- A function to a discrete topological space is continuous if and only if the preimage of every\nsingleton is open. -/\ntheorem continuous_discrete_rng {Œ±} [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [DiscreteTopology Œ≤]\n    {f : Œ± ‚Üí Œ≤} : Continuous f ‚Üî ‚àÄ b : Œ≤, IsOpen (f ‚Åª¬π' {b}) :=\n  ‚ü®fun h _ => (isOpen_discrete _).preimage h, fun h => ‚ü®fun s _ => by\n    rw [‚Üê biUnion_of_singleton s, preimage_iUnion‚ÇÇ]\n    exact isOpen_biUnion fun _ _ => h _‚ü©‚ü©\n\n"}
{"name":"nhds_discrete","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : DiscreteTopology Œ±\n‚ä¢ Eq nhds Pure.pure","decl":"@[simp]\ntheorem nhds_discrete (Œ± : Type*) [TopologicalSpace Œ±] [DiscreteTopology Œ±] : @nhds Œ± _ = pure :=\n  le_antisymm (fun _ s hs => (isOpen_discrete s).mem_nhds hs) pure_le_nhds\n\n"}
{"name":"mem_nhds_discrete","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : DiscreteTopology Œ±\nx : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (nhds x) s) (Membership.mem s x)","decl":"theorem mem_nhds_discrete {x : Œ±} {s : Set Œ±} :\n    s ‚àà ùìù x ‚Üî x ‚àà s := by rw [nhds_discrete, mem_pure]\n\n"}
{"name":"le_of_nhds_le_nhds","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nt‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±\nh : ‚àÄ (x : Œ±), LE.le (nhds x) (nhds x)\n‚ä¢ LE.le t‚ÇÅ t‚ÇÇ","decl":"theorem le_of_nhds_le_nhds (h : ‚àÄ x, @nhds Œ± t‚ÇÅ x ‚â§ @nhds Œ± t‚ÇÇ x) : t‚ÇÅ ‚â§ t‚ÇÇ := fun s => by\n  rw [@isOpen_iff_mem_nhds _ _ t‚ÇÅ, @isOpen_iff_mem_nhds Œ± _ t‚ÇÇ]\n  exact fun hs a ha => h _ (hs _ ha)\n\n"}
{"name":"eq_bot_of_singletons_open","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nt : TopologicalSpace Œ±\nh : ‚àÄ (x : Œ±), IsOpen (Singleton.singleton x)\n‚ä¢ Eq t Bot.bot","decl":"theorem eq_bot_of_singletons_open {t : TopologicalSpace Œ±} (h : ‚àÄ x, IsOpen[t] {x}) : t = ‚ä• :=\n  bot_unique fun s _ => biUnion_of_singleton s ‚ñ∏ isOpen_biUnion fun x _ => h x\n\n"}
{"name":"forall_open_iff_discrete","module":"Mathlib.Topology.Order","initialProofState":"X : Type u_2\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (‚àÄ (s : Set X), IsOpen s) (DiscreteTopology X)","decl":"theorem forall_open_iff_discrete {X : Type*} [TopologicalSpace X] :\n    (‚àÄ s : Set X, IsOpen s) ‚Üî DiscreteTopology X :=\n  ‚ü®fun h => ‚ü®eq_bot_of_singletons_open fun _ => h _‚ü©, @isOpen_discrete _ _‚ü©\n\n"}
{"name":"discreteTopology_iff_forall_isClosed","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ Iff (DiscreteTopology Œ±) (‚àÄ (s : Set Œ±), IsClosed s)","decl":"theorem discreteTopology_iff_forall_isClosed [TopologicalSpace Œ±] :\n    DiscreteTopology Œ± ‚Üî ‚àÄ s : Set Œ±, IsClosed s :=\n  forall_open_iff_discrete.symm.trans <| compl_surjective.forall.trans <| forall_congr' fun _ ‚Ü¶\n    isOpen_compl_iff\n\n"}
{"name":"singletons_open_iff_discrete","module":"Mathlib.Topology.Order","initialProofState":"X : Type u_2\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (‚àÄ (a : X), IsOpen (Singleton.singleton a)) (DiscreteTopology X)","decl":"theorem singletons_open_iff_discrete {X : Type*} [TopologicalSpace X] :\n    (‚àÄ a : X, IsOpen ({a} : Set X)) ‚Üî DiscreteTopology X :=\n  ‚ü®fun h => ‚ü®eq_bot_of_singletons_open h‚ü©, fun a _ => @isOpen_discrete _ _ a _‚ü©\n\n"}
{"name":"DiscreteTopology.of_finite_of_isClosed_singleton","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Finite Œ±\nh : ‚àÄ (a : Œ±), IsClosed (Singleton.singleton a)\n‚ä¢ DiscreteTopology Œ±","decl":"theorem DiscreteTopology.of_finite_of_isClosed_singleton [TopologicalSpace Œ±] [Finite Œ±]\n    (h : ‚àÄ a : Œ±, IsClosed {a}) : DiscreteTopology Œ± :=\n  discreteTopology_iff_forall_isClosed.mpr fun s ‚Ü¶\n    s.iUnion_of_singleton_coe ‚ñ∏ isClosed_iUnion_of_finite fun _ ‚Ü¶ h _\n\n"}
{"name":"discreteTopology_iff_singleton_mem_nhds","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ Iff (DiscreteTopology Œ±) (‚àÄ (x : Œ±), Membership.mem (nhds x) (Singleton.singleton x))","decl":"theorem discreteTopology_iff_singleton_mem_nhds [TopologicalSpace Œ±] :\n    DiscreteTopology Œ± ‚Üî ‚àÄ x : Œ±, {x} ‚àà ùìù x := by\n  simp only [‚Üê singletons_open_iff_discrete, isOpen_iff_mem_nhds, mem_singleton_iff, forall_eq]\n\n"}
{"name":"discreteTopology_iff_nhds","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ Iff (DiscreteTopology Œ±) (‚àÄ (x : Œ±), Eq (nhds x) (Pure.pure x))","decl":"/-- This lemma characterizes discrete topological spaces as those whose singletons are\nneighbourhoods. -/\ntheorem discreteTopology_iff_nhds [TopologicalSpace Œ±] :\n    DiscreteTopology Œ± ‚Üî ‚àÄ x : Œ±, ùìù x = pure x := by\n  simp [discreteTopology_iff_singleton_mem_nhds, le_pure_iff]\n  apply forall_congr' (fun x ‚Ü¶ ?_)\n  simp [le_antisymm_iff, pure_le_nhds x]\n\n"}
{"name":"discreteTopology_iff_nhds_ne","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ Iff (DiscreteTopology Œ±) (‚àÄ (x : Œ±), Eq (nhdsWithin x (HasCompl.compl (Singleton.singleton x))) Bot.bot)","decl":"theorem discreteTopology_iff_nhds_ne [TopologicalSpace Œ±] :\n    DiscreteTopology Œ± ‚Üî ‚àÄ x : Œ±, ùìù[‚â†] x = ‚ä• := by\n  simp only [discreteTopology_iff_singleton_mem_nhds, nhdsWithin, inf_principal_eq_bot, compl_compl]\n\n"}
{"name":"DiscreteTopology.of_continuous_injective","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : DiscreteTopology Œ≤\nf : Œ± ‚Üí Œ≤\nhc : Continuous f\nhinj : Function.Injective f\n‚ä¢ DiscreteTopology Œ±","decl":"/-- If the codomain of a continuous injective function has discrete topology,\nthen so does the domain.\n\nSee also `Embedding.discreteTopology` for an important special case. -/\ntheorem DiscreteTopology.of_continuous_injective\n    {Œ≤ : Type*} [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [DiscreteTopology Œ≤] {f : Œ± ‚Üí Œ≤}\n    (hc : Continuous f) (hinj : Injective f) : DiscreteTopology Œ± :=\n  forall_open_iff_discrete.1 fun s ‚Ü¶ hinj.preimage_image s ‚ñ∏ (isOpen_discrete _).preimage hc\n\n"}
{"name":"isOpen_induced_iff","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nt : TopologicalSpace Œ≤\ns : Set Œ±\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsOpen s) (Exists fun t_1 => And (IsOpen t_1) (Eq (Set.preimage f t_1) s))","decl":"theorem isOpen_induced_iff [t : TopologicalSpace Œ≤] {s : Set Œ±} {f : Œ± ‚Üí Œ≤} :\n    IsOpen[t.induced f] s ‚Üî ‚àÉ t, IsOpen t ‚àß f ‚Åª¬π' t = s :=\n  Iff.rfl\n\n"}
{"name":"isClosed_induced_iff","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nt : TopologicalSpace Œ≤\ns : Set Œ±\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsClosed s) (Exists fun t_1 => And (IsClosed t_1) (Eq (Set.preimage f t_1) s))","decl":"theorem isClosed_induced_iff [t : TopologicalSpace Œ≤] {s : Set Œ±} {f : Œ± ‚Üí Œ≤} :\n    IsClosed[t.induced f] s ‚Üî ‚àÉ t, IsClosed t ‚àß f ‚Åª¬π' t = s := by\n  letI := t.induced f\n  simp only [‚Üê isOpen_compl_iff, isOpen_induced_iff]\n  exact compl_surjective.exists.trans (by simp only [preimage_compl, compl_inj_iff])\n\n"}
{"name":"isOpen_coinduced","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nt : TopologicalSpace Œ±\ns : Set Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsOpen s) (IsOpen (Set.preimage f s))","decl":"theorem isOpen_coinduced {t : TopologicalSpace Œ±} {s : Set Œ≤} {f : Œ± ‚Üí Œ≤} :\n    IsOpen[t.coinduced f] s ‚Üî IsOpen (f ‚Åª¬π' s) :=\n  Iff.rfl\n\n"}
{"name":"isClosed_coinduced","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nt : TopologicalSpace Œ±\ns : Set Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsClosed s) (IsClosed (Set.preimage f s))","decl":"theorem isClosed_coinduced {t : TopologicalSpace Œ±} {s : Set Œ≤} {f : Œ± ‚Üí Œ≤} :\n    IsClosed[t.coinduced f] s ‚Üî IsClosed (f ‚Åª¬π' s) := by\n  simp only [‚Üê isOpen_compl_iff, isOpen_coinduced (f := f), preimage_compl]\n\n"}
{"name":"preimage_nhds_coinduced","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : TopologicalSpace Œ±\nœÄ : Œ± ‚Üí Œ≤\ns : Set Œ≤\na : Œ±\nhs : Membership.mem (nhds (œÄ a)) s\n‚ä¢ Membership.mem (nhds a) (Set.preimage œÄ s)","decl":"theorem preimage_nhds_coinduced [TopologicalSpace Œ±] {œÄ : Œ± ‚Üí Œ≤} {s : Set Œ≤} {a : Œ±}\n    (hs : s ‚àà @nhds Œ≤ (TopologicalSpace.coinduced œÄ ‚Äπ_‚Ä∫) (œÄ a)) : œÄ ‚Åª¬π' s ‚àà ùìù a := by\n  letI := TopologicalSpace.coinduced œÄ ‚Äπ_‚Ä∫\n  rcases mem_nhds_iff.mp hs with ‚ü®V, hVs, V_op, mem_V‚ü©\n  exact mem_nhds_iff.mpr ‚ü®œÄ ‚Åª¬π' V, Set.preimage_mono hVs, V_op, mem_V‚ü©\n\n"}
{"name":"Continuous.coinduced_le","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nt : TopologicalSpace Œ±\nt' : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\nh : Continuous f\n‚ä¢ LE.le (TopologicalSpace.coinduced f t) t'","decl":"theorem Continuous.coinduced_le (h : Continuous[t, t'] f) : t.coinduced f ‚â§ t' :=\n  (@continuous_def Œ± Œ≤ t t').1 h\n\n"}
{"name":"coinduced_le_iff_le_induced","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Œ± ‚Üí Œ≤\ntŒ± : TopologicalSpace Œ±\ntŒ≤ : TopologicalSpace Œ≤\n‚ä¢ Iff (LE.le (TopologicalSpace.coinduced f tŒ±) tŒ≤) (LE.le tŒ± (TopologicalSpace.induced f tŒ≤))","decl":"theorem coinduced_le_iff_le_induced {f : Œ± ‚Üí Œ≤} {tŒ± : TopologicalSpace Œ±}\n    {tŒ≤ : TopologicalSpace Œ≤} : tŒ±.coinduced f ‚â§ tŒ≤ ‚Üî tŒ± ‚â§ tŒ≤.induced f :=\n  ‚ü®fun h _s ‚ü®_t, ht, hst‚ü© => hst ‚ñ∏ h _ ht, fun h s hs => h _ ‚ü®s, hs, rfl‚ü©‚ü©\n\n"}
{"name":"Continuous.le_induced","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nt : TopologicalSpace Œ±\nt' : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\nh : Continuous f\n‚ä¢ LE.le t (TopologicalSpace.induced f t')","decl":"theorem Continuous.le_induced (h : Continuous[t, t'] f) : t ‚â§ t'.induced f :=\n  coinduced_le_iff_le_induced.1 h.coinduced_le\n\n"}
{"name":"gc_coinduced_induced","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Œ± ‚Üí Œ≤\n‚ä¢ GaloisConnection (TopologicalSpace.coinduced f) (TopologicalSpace.induced f)","decl":"theorem gc_coinduced_induced (f : Œ± ‚Üí Œ≤) :\n    GaloisConnection (TopologicalSpace.coinduced f) (TopologicalSpace.induced f) := fun _ _ =>\n  coinduced_le_iff_le_induced\n\n"}
{"name":"induced_mono","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nt‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±\ng : Œ≤ ‚Üí Œ±\nh : LE.le t‚ÇÅ t‚ÇÇ\n‚ä¢ LE.le (TopologicalSpace.induced g t‚ÇÅ) (TopologicalSpace.induced g t‚ÇÇ)","decl":"theorem induced_mono (h : t‚ÇÅ ‚â§ t‚ÇÇ) : t‚ÇÅ.induced g ‚â§ t‚ÇÇ.induced g :=\n  (gc_coinduced_induced g).monotone_u h\n\n"}
{"name":"coinduced_mono","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nt‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±\nf : Œ± ‚Üí Œ≤\nh : LE.le t‚ÇÅ t‚ÇÇ\n‚ä¢ LE.le (TopologicalSpace.coinduced f t‚ÇÅ) (TopologicalSpace.coinduced f t‚ÇÇ)","decl":"theorem coinduced_mono (h : t‚ÇÅ ‚â§ t‚ÇÇ) : t‚ÇÅ.coinduced f ‚â§ t‚ÇÇ.coinduced f :=\n  (gc_coinduced_induced f).monotone_l h\n\n"}
{"name":"induced_top","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ng : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (TopologicalSpace.induced g Top.top) Top.top","decl":"@[simp]\ntheorem induced_top : (‚ä§ : TopologicalSpace Œ±).induced g = ‚ä§ :=\n  (gc_coinduced_induced g).u_top\n\n"}
{"name":"induced_inf","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nt‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±\ng : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (TopologicalSpace.induced g (Min.min t‚ÇÅ t‚ÇÇ)) (Min.min (TopologicalSpace.induced g t‚ÇÅ) (TopologicalSpace.induced g t‚ÇÇ))","decl":"@[simp]\ntheorem induced_inf : (t‚ÇÅ ‚äì t‚ÇÇ).induced g = t‚ÇÅ.induced g ‚äì t‚ÇÇ.induced g :=\n  (gc_coinduced_induced g).u_inf\n\n"}
{"name":"induced_iInf","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ng : Œ≤ ‚Üí Œ±\nŒπ : Sort w\nt : Œπ ‚Üí TopologicalSpace Œ±\n‚ä¢ Eq (TopologicalSpace.induced g (iInf fun i => t i)) (iInf fun i => TopologicalSpace.induced g (t i))","decl":"@[simp]\ntheorem induced_iInf {Œπ : Sort w} {t : Œπ ‚Üí TopologicalSpace Œ±} :\n    (‚®Ö i, t i).induced g = ‚®Ö i, (t i).induced g :=\n  (gc_coinduced_induced g).u_iInf\n\n"}
{"name":"induced_sInf","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ng : Œ≤ ‚Üí Œ±\ns : Set (TopologicalSpace Œ±)\n‚ä¢ Eq (TopologicalSpace.induced g (InfSet.sInf s)) (InfSet.sInf (Set.image (TopologicalSpace.induced g) s))","decl":"@[simp]\ntheorem induced_sInf {s : Set (TopologicalSpace Œ±)} :\n    TopologicalSpace.induced g (sInf s) = sInf (TopologicalSpace.induced g '' s) := by\n  rw [sInf_eq_iInf', sInf_image', induced_iInf]\n\n"}
{"name":"coinduced_bot","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Œ± ‚Üí Œ≤\n‚ä¢ Eq (TopologicalSpace.coinduced f Bot.bot) Bot.bot","decl":"@[simp]\ntheorem coinduced_bot : (‚ä• : TopologicalSpace Œ±).coinduced f = ‚ä• :=\n  (gc_coinduced_induced f).l_bot\n\n"}
{"name":"coinduced_sup","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nt‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±\nf : Œ± ‚Üí Œ≤\n‚ä¢ Eq (TopologicalSpace.coinduced f (Max.max t‚ÇÅ t‚ÇÇ)) (Max.max (TopologicalSpace.coinduced f t‚ÇÅ) (TopologicalSpace.coinduced f t‚ÇÇ))","decl":"@[simp]\ntheorem coinduced_sup : (t‚ÇÅ ‚äî t‚ÇÇ).coinduced f = t‚ÇÅ.coinduced f ‚äî t‚ÇÇ.coinduced f :=\n  (gc_coinduced_induced f).l_sup\n\n"}
{"name":"coinduced_iSup","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Œ± ‚Üí Œ≤\nŒπ : Sort w\nt : Œπ ‚Üí TopologicalSpace Œ±\n‚ä¢ Eq (TopologicalSpace.coinduced f (iSup fun i => t i)) (iSup fun i => TopologicalSpace.coinduced f (t i))","decl":"@[simp]\ntheorem coinduced_iSup {Œπ : Sort w} {t : Œπ ‚Üí TopologicalSpace Œ±} :\n    (‚®Ü i, t i).coinduced f = ‚®Ü i, (t i).coinduced f :=\n  (gc_coinduced_induced f).l_iSup\n\n"}
{"name":"coinduced_sSup","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Œ± ‚Üí Œ≤\ns : Set (TopologicalSpace Œ±)\n‚ä¢ Eq (TopologicalSpace.coinduced f (SupSet.sSup s)) (SupSet.sSup (Set.image (TopologicalSpace.coinduced f) s))","decl":"@[simp]\ntheorem coinduced_sSup {s : Set (TopologicalSpace Œ±)} :\n    TopologicalSpace.coinduced f (sSup s) = sSup ((TopologicalSpace.coinduced f) '' s) := by\n  rw [sSup_eq_iSup', sSup_image', coinduced_iSup]\n\n"}
{"name":"induced_id","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nt : TopologicalSpace Œ±\n‚ä¢ Eq (TopologicalSpace.induced id t) t","decl":"theorem induced_id [t : TopologicalSpace Œ±] : t.induced id = t :=\n  TopologicalSpace.ext <|\n    funext fun s => propext <| ‚ü®fun ‚ü®_, hs, h‚ü© => h ‚ñ∏ hs, fun hs => ‚ü®s, hs, rfl‚ü©‚ü©\n\n"}
{"name":"induced_compose","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ntŒ≥ : TopologicalSpace Œ≥\nf : Œ± ‚Üí Œ≤\ng : Œ≤ ‚Üí Œ≥\n‚ä¢ Eq (TopologicalSpace.induced f (TopologicalSpace.induced g tŒ≥)) (TopologicalSpace.induced (Function.comp g f) tŒ≥)","decl":"theorem induced_compose {tŒ≥ : TopologicalSpace Œ≥} {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} :\n    (tŒ≥.induced g).induced f = tŒ≥.induced (g ‚àò f) :=\n  TopologicalSpace.ext <|\n    funext fun _ => propext\n      ‚ü®fun ‚ü®_, ‚ü®s, hs, h‚ÇÇ‚ü©, h‚ÇÅ‚ü© => h‚ÇÅ ‚ñ∏ h‚ÇÇ ‚ñ∏ ‚ü®s, hs, rfl‚ü©,\n        fun ‚ü®s, hs, h‚ü© => ‚ü®preimage g s, ‚ü®s, hs, rfl‚ü©, h ‚ñ∏ rfl‚ü©‚ü©\n\n"}
{"name":"induced_const","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nt : TopologicalSpace Œ±\nx : Œ±\n‚ä¢ Eq (TopologicalSpace.induced (fun x_1 => x) t) Top.top","decl":"theorem induced_const [t : TopologicalSpace Œ±] {x : Œ±} : (t.induced fun _ : Œ≤ => x) = ‚ä§ :=\n  le_antisymm le_top (@continuous_const Œ≤ Œ± ‚ä§ t x).le_induced\n\n"}
{"name":"coinduced_id","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nt : TopologicalSpace Œ±\n‚ä¢ Eq (TopologicalSpace.coinduced id t) t","decl":"theorem coinduced_id [t : TopologicalSpace Œ±] : t.coinduced id = t :=\n  TopologicalSpace.ext rfl\n\n"}
{"name":"coinduced_compose","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ntŒ± : TopologicalSpace Œ±\nf : Œ± ‚Üí Œ≤\ng : Œ≤ ‚Üí Œ≥\n‚ä¢ Eq (TopologicalSpace.coinduced g (TopologicalSpace.coinduced f tŒ±)) (TopologicalSpace.coinduced (Function.comp g f) tŒ±)","decl":"theorem coinduced_compose [tŒ± : TopologicalSpace Œ±] {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} :\n    (tŒ±.coinduced f).coinduced g = tŒ±.coinduced (g ‚àò f) :=\n  TopologicalSpace.ext rfl\n\n"}
{"name":"Equiv.induced_symm","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_4\nŒ≤ : Type u_5\ne : Equiv Œ± Œ≤\n‚ä¢ Eq (TopologicalSpace.induced ‚áëe.symm) (TopologicalSpace.coinduced ‚áëe)","decl":"theorem Equiv.induced_symm {Œ± Œ≤ : Type*} (e : Œ± ‚âÉ Œ≤) :\n    TopologicalSpace.induced e.symm = TopologicalSpace.coinduced e := by\n  ext t U\n  rw [isOpen_induced_iff, isOpen_coinduced]\n  simp only [e.symm.preimage_eq_iff_eq_image, exists_eq_right, ‚Üê preimage_equiv_eq_image_symm]\n\n"}
{"name":"Equiv.coinduced_symm","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_4\nŒ≤ : Type u_5\ne : Equiv Œ± Œ≤\n‚ä¢ Eq (TopologicalSpace.coinduced ‚áëe.symm) (TopologicalSpace.induced ‚áëe)","decl":"theorem Equiv.coinduced_symm {Œ± Œ≤ : Type*} (e : Œ± ‚âÉ Œ≤) :\n    TopologicalSpace.coinduced e.symm = TopologicalSpace.induced e :=\n  e.symm.induced_symm.symm\n\n"}
{"name":"Subsingleton.discreteTopology","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : Subsingleton Œ±\n‚ä¢ DiscreteTopology Œ±","decl":"instance (priority := 100) Subsingleton.discreteTopology [t : TopologicalSpace Œ±] [Subsingleton Œ±] :\n    DiscreteTopology Œ± :=\n  ‚ü®Unique.eq_default t‚ü©\n\n"}
{"name":"instDiscreteTopologyEmpty","module":"Mathlib.Topology.Order","initialProofState":"‚ä¢ DiscreteTopology Empty","decl":"instance : DiscreteTopology Empty := ‚ü®rfl‚ü©\n\n"}
{"name":"instDiscreteTopologyPEmpty","module":"Mathlib.Topology.Order","initialProofState":"‚ä¢ DiscreteTopology PEmpty.{u_1 + 1}","decl":"instance : DiscreteTopology PEmpty := ‚ü®rfl‚ü©\n\n"}
{"name":"instDiscreteTopologyPUnit","module":"Mathlib.Topology.Order","initialProofState":"‚ä¢ DiscreteTopology PUnit.{u_1 + 1}","decl":"instance : DiscreteTopology PUnit := ‚ü®rfl‚ü©\n\n"}
{"name":"instDiscreteTopologyBool","module":"Mathlib.Topology.Order","initialProofState":"‚ä¢ DiscreteTopology Bool","decl":"instance : DiscreteTopology Bool := ‚ü®rfl‚ü©\n\n"}
{"name":"instDiscreteTopologyNat","module":"Mathlib.Topology.Order","initialProofState":"‚ä¢ DiscreteTopology Nat","decl":"instance : DiscreteTopology ‚Ñï := ‚ü®rfl‚ü©\n\n"}
{"name":"instDiscreteTopologyInt","module":"Mathlib.Topology.Order","initialProofState":"‚ä¢ DiscreteTopology Int","decl":"instance : DiscreteTopology ‚Ñ§ := ‚ü®rfl‚ü©\n\n"}
{"name":"instDiscreteTopologyFin","module":"Mathlib.Topology.Order","initialProofState":"n : Nat\n‚ä¢ DiscreteTopology (Fin n)","decl":"instance {n} : DiscreteTopology (Fin n) := ‚ü®rfl‚ü©\n\n"}
{"name":"continuous_empty_function","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : IsEmpty Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Continuous f","decl":"theorem continuous_empty_function [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [IsEmpty Œ≤]\n    (f : Œ± ‚Üí Œ≤) : Continuous f :=\n  letI := Function.isEmpty f\n  continuous_of_discreteTopology\n\n"}
{"name":"le_generateFrom","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ng : Set (Set Œ±)\nh : ‚àÄ (s : Set Œ±), Membership.mem g s ‚Üí IsOpen s\n‚ä¢ LE.le t (TopologicalSpace.generateFrom g)","decl":"theorem le_generateFrom {t : TopologicalSpace Œ±} {g : Set (Set Œ±)} (h : ‚àÄ s ‚àà g, IsOpen s) :\n    t ‚â§ generateFrom g :=\n  le_generateFrom_iff_subset_isOpen.2 h\n\n"}
{"name":"induced_generateFrom_eq","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nb : Set (Set Œ≤)\nf : Œ± ‚Üí Œ≤\n‚ä¢ Eq (TopologicalSpace.induced f (TopologicalSpace.generateFrom b)) (TopologicalSpace.generateFrom (Set.image (Set.preimage f) b))","decl":"theorem induced_generateFrom_eq {Œ± Œ≤} {b : Set (Set Œ≤)} {f : Œ± ‚Üí Œ≤} :\n    (generateFrom b).induced f = generateFrom (preimage f '' b) :=\n  le_antisymm (le_generateFrom <| forall_mem_image.2 fun s hs => ‚ü®s, GenerateOpen.basic _ hs, rfl‚ü©)\n    (coinduced_le_iff_le_induced.1 <| le_generateFrom fun _s hs => .basic _ (mem_image_of_mem _ hs))\n\n"}
{"name":"le_induced_generateFrom","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nt : TopologicalSpace Œ±\nb : Set (Set Œ≤)\nf : Œ± ‚Üí Œ≤\nh : ‚àÄ (a : Set Œ≤), Membership.mem b a ‚Üí IsOpen (Set.preimage f a)\n‚ä¢ LE.le t (TopologicalSpace.induced f (TopologicalSpace.generateFrom b))","decl":"theorem le_induced_generateFrom {Œ± Œ≤} [t : TopologicalSpace Œ±] {b : Set (Set Œ≤)} {f : Œ± ‚Üí Œ≤}\n    (h : ‚àÄ a : Set Œ≤, a ‚àà b ‚Üí IsOpen (f ‚Åª¬π' a)) : t ‚â§ induced f (generateFrom b) := by\n  rw [induced_generateFrom_eq]\n  apply le_generateFrom\n  simp only [mem_image, and_imp, forall_apply_eq_imp_iff‚ÇÇ, exists_imp]\n  exact h\n\n"}
{"name":"generateFrom_insert_of_generateOpen","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\ns : Set (Set Œ±)\nt : Set Œ±\nht : TopologicalSpace.GenerateOpen s t\n‚ä¢ Eq (TopologicalSpace.generateFrom (Insert.insert t s)) (TopologicalSpace.generateFrom s)","decl":"lemma generateFrom_insert_of_generateOpen {Œ± : Type*} {s : Set (Set Œ±)} {t : Set Œ±}\n    (ht : GenerateOpen s t) : generateFrom (insert t s) = generateFrom s := by\n  refine le_antisymm (generateFrom_anti <| subset_insert t s) (le_generateFrom ?_)\n  rintro t (rfl | h)\n  ¬∑ exact ht\n  ¬∑ exact isOpen_generateFrom_of_mem h\n\n"}
{"name":"generateFrom_insert_univ","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\ns : Set (Set Œ±)\n‚ä¢ Eq (TopologicalSpace.generateFrom (Insert.insert Set.univ s)) (TopologicalSpace.generateFrom s)","decl":"@[simp]\nlemma generateFrom_insert_univ {Œ± : Type*} {s : Set (Set Œ±)} :\n    generateFrom (insert univ s) = generateFrom s :=\n  generateFrom_insert_of_generateOpen .univ\n\n"}
{"name":"generateFrom_insert_empty","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\ns : Set (Set Œ±)\n‚ä¢ Eq (TopologicalSpace.generateFrom (Insert.insert EmptyCollection.emptyCollection s)) (TopologicalSpace.generateFrom s)","decl":"@[simp]\nlemma generateFrom_insert_empty {Œ± : Type*} {s : Set (Set Œ±)} :\n    generateFrom (insert ‚àÖ s) = generateFrom s := by\n  rw [‚Üê sUnion_empty]\n  exact generateFrom_insert_of_generateOpen (.sUnion ‚àÖ (fun s_1 a ‚Ü¶ False.elim a))\n\n"}
{"name":"gc_nhds","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\na : Œ±\n‚ä¢ GaloisConnection (nhdsAdjoint a) fun t => nhds a","decl":"theorem gc_nhds (a : Œ±) : GaloisConnection (nhdsAdjoint a) fun t => @nhds Œ± t a := fun f t => by\n  rw [le_nhds_iff]\n  exact ‚ü®fun H s hs has => H _ has hs, fun H s has hs => H _ hs has‚ü©\n\n"}
{"name":"nhds_mono","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nt‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±\na : Œ±\nh : LE.le t‚ÇÅ t‚ÇÇ\n‚ä¢ LE.le (nhds a) (nhds a)","decl":"theorem nhds_mono {t‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±} {a : Œ±} (h : t‚ÇÅ ‚â§ t‚ÇÇ) :\n    @nhds Œ± t‚ÇÅ a ‚â§ @nhds Œ± t‚ÇÇ a :=\n  (gc_nhds a).monotone_u h\n\n"}
{"name":"le_iff_nhds","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nt t' : TopologicalSpace Œ±\n‚ä¢ Iff (LE.le t t') (‚àÄ (x : Œ±), LE.le (nhds x) (nhds x))","decl":"theorem le_iff_nhds {Œ± : Type*} (t t' : TopologicalSpace Œ±) :\n    t ‚â§ t' ‚Üî ‚àÄ x, @nhds Œ± t x ‚â§ @nhds Œ± t' x :=\n  ‚ü®fun h _ => nhds_mono h, le_of_nhds_le_nhds‚ü©\n\n"}
{"name":"isOpen_singleton_nhdsAdjoint","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\na b : Œ±\nf : Filter Œ±\nhb : Ne b a\n‚ä¢ IsOpen (Singleton.singleton b)","decl":"theorem isOpen_singleton_nhdsAdjoint {Œ± : Type*} {a b : Œ±} (f : Filter Œ±) (hb : b ‚â† a) :\n    IsOpen[nhdsAdjoint a f] {b} := fun h ‚Ü¶\n  absurd h hb.symm\n\n"}
{"name":"nhds_nhdsAdjoint_same","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\na : Œ±\nf : Filter Œ±\n‚ä¢ Eq (nhds a) (Max.max (Pure.pure a) f)","decl":"theorem nhds_nhdsAdjoint_same (a : Œ±) (f : Filter Œ±) :\n    @nhds Œ± (nhdsAdjoint a f) a = pure a ‚äî f := by\n  let _ := nhdsAdjoint a f\n  apply le_antisymm\n  ¬∑ rintro t ‚ü®hat : a ‚àà t, htf : t ‚àà f‚ü©\n    exact IsOpen.mem_nhds (fun _ ‚Ü¶ htf) hat\n  ¬∑ exact sup_le (pure_le_nhds _) ((gc_nhds a).le_u_l f)\n\n"}
{"name":"nhds_nhdsAdjoint_of_ne","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\na b : Œ±\nf : Filter Œ±\nh : Ne b a\n‚ä¢ Eq (nhds b) (Pure.pure b)","decl":"theorem nhds_nhdsAdjoint_of_ne {a b : Œ±} (f : Filter Œ±) (h : b ‚â† a) :\n    @nhds Œ± (nhdsAdjoint a f) b = pure b :=\n  let _ := nhdsAdjoint a f\n  (isOpen_singleton_iff_nhds_eq_pure _).1 <| isOpen_singleton_nhdsAdjoint f h\n\n"}
{"name":"nhds_nhdsAdjoint","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\ninst‚úù : DecidableEq Œ±\na : Œ±\nf : Filter Œ±\n‚ä¢ Eq nhds (Function.update Pure.pure a (Max.max (Pure.pure a) f))","decl":"theorem nhds_nhdsAdjoint [DecidableEq Œ±] (a : Œ±) (f : Filter Œ±) :\n    @nhds Œ± (nhdsAdjoint a f) = update pure a (pure a ‚äî f) :=\n  eq_update_iff.2 ‚ü®nhds_nhdsAdjoint_same .., fun _ ‚Ü¶ nhds_nhdsAdjoint_of_ne _‚ü©\n\n"}
{"name":"le_nhdsAdjoint_iff'","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\na : Œ±\nf : Filter Œ±\nt : TopologicalSpace Œ±\n‚ä¢ Iff (LE.le t (nhdsAdjoint a f)) (And (LE.le (nhds a) (Max.max (Pure.pure a) f)) (‚àÄ (b : Œ±), Ne b a ‚Üí Eq (nhds b) (Pure.pure b)))","decl":"theorem le_nhdsAdjoint_iff' {a : Œ±} {f : Filter Œ±} {t : TopologicalSpace Œ±} :\n    t ‚â§ nhdsAdjoint a f ‚Üî @nhds Œ± t a ‚â§ pure a ‚äî f ‚àß ‚àÄ b ‚â† a, @nhds Œ± t b = pure b := by\n  classical\n  simp_rw [le_iff_nhds, nhds_nhdsAdjoint, forall_update_iff, (pure_le_nhds _).le_iff_eq]\n\n"}
{"name":"le_nhdsAdjoint_iff","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\na : Œ±\nf : Filter Œ±\nt : TopologicalSpace Œ±\n‚ä¢ Iff (LE.le t (nhdsAdjoint a f)) (And (LE.le (nhds a) (Max.max (Pure.pure a) f)) (‚àÄ (b : Œ±), Ne b a ‚Üí IsOpen (Singleton.singleton b)))","decl":"theorem le_nhdsAdjoint_iff {Œ± : Type*} (a : Œ±) (f : Filter Œ±) (t : TopologicalSpace Œ±) :\n    t ‚â§ nhdsAdjoint a f ‚Üî @nhds Œ± t a ‚â§ pure a ‚äî f ‚àß ‚àÄ b ‚â† a, IsOpen[t] {b} := by\n  simp only [le_nhdsAdjoint_iff', @isOpen_singleton_iff_nhds_eq_pure Œ± t]\n\n"}
{"name":"nhds_iInf","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒπ : Sort u_1\nt : Œπ ‚Üí TopologicalSpace Œ±\na : Œ±\n‚ä¢ Eq (nhds a) (iInf fun i => nhds a)","decl":"theorem nhds_iInf {Œπ : Sort*} {t : Œπ ‚Üí TopologicalSpace Œ±} {a : Œ±} :\n    @nhds Œ± (iInf t) a = ‚®Ö i, @nhds Œ± (t i) a :=\n  (gc_nhds a).u_iInf\n\n"}
{"name":"nhds_sInf","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\ns : Set (TopologicalSpace Œ±)\na : Œ±\n‚ä¢ Eq (nhds a) (iInf fun t => iInf fun h => nhds a)","decl":"theorem nhds_sInf {s : Set (TopologicalSpace Œ±)} {a : Œ±} :\n    @nhds Œ± (sInf s) a = ‚®Ö t ‚àà s, @nhds Œ± t a :=\n  (gc_nhds a).u_sInf\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: timeouts without `b‚ÇÅ := t‚ÇÅ`\n"}
{"name":"nhds_inf","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nt‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±\na : Œ±\n‚ä¢ Eq (nhds a) (Min.min (nhds a) (nhds a))","decl":"theorem nhds_inf {t‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±} {a : Œ±} :\n    @nhds Œ± (t‚ÇÅ ‚äì t‚ÇÇ) a = @nhds Œ± t‚ÇÅ a ‚äì @nhds Œ± t‚ÇÇ a :=\n  (gc_nhds a).u_inf (b‚ÇÅ := t‚ÇÅ)\n\n"}
{"name":"nhds_top","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\na : Œ±\n‚ä¢ Eq (nhds a) Top.top","decl":"theorem nhds_top {a : Œ±} : @nhds Œ± ‚ä§ a = ‚ä§ :=\n  (gc_nhds a).u_top\n\n"}
{"name":"isOpen_sup","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nt‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±\ns : Set Œ±\n‚ä¢ Iff (IsOpen s) (And (IsOpen s) (IsOpen s))","decl":"theorem isOpen_sup {t‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±} {s : Set Œ±} :\n    IsOpen[t‚ÇÅ ‚äî t‚ÇÇ] s ‚Üî IsOpen[t‚ÇÅ] s ‚àß IsOpen[t‚ÇÇ] s :=\n  Iff.rfl\n\n"}
{"name":"continuous_iff_coinduced_le","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nt‚ÇÅ : TopologicalSpace Œ±\nt‚ÇÇ : TopologicalSpace Œ≤\n‚ä¢ Iff (Continuous f) (LE.le (TopologicalSpace.coinduced f t‚ÇÅ) t‚ÇÇ)","decl":"theorem continuous_iff_coinduced_le {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ : TopologicalSpace Œ≤} :\n    Continuous[t‚ÇÅ, t‚ÇÇ] f ‚Üî coinduced f t‚ÇÅ ‚â§ t‚ÇÇ :=\n  continuous_def\n\n"}
{"name":"continuous_iff_le_induced","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nt‚ÇÅ : TopologicalSpace Œ±\nt‚ÇÇ : TopologicalSpace Œ≤\n‚ä¢ Iff (Continuous f) (LE.le t‚ÇÅ (TopologicalSpace.induced f t‚ÇÇ))","decl":"theorem continuous_iff_le_induced {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ : TopologicalSpace Œ≤} :\n    Continuous[t‚ÇÅ, t‚ÇÇ] f ‚Üî t‚ÇÅ ‚â§ induced f t‚ÇÇ :=\n  Iff.trans continuous_iff_coinduced_le (gc_coinduced_induced f _ _)\n\n"}
{"name":"continuous_generateFrom_iff","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nt : TopologicalSpace Œ±\nb : Set (Set Œ≤)\n‚ä¢ Iff (Continuous f) (‚àÄ (s : Set Œ≤), Membership.mem b s ‚Üí IsOpen (Set.preimage f s))","decl":"lemma continuous_generateFrom_iff {t : TopologicalSpace Œ±} {b : Set (Set Œ≤)} :\n    Continuous[t, generateFrom b] f ‚Üî ‚àÄ s ‚àà b, IsOpen (f ‚Åª¬π' s) := by\n  rw [continuous_iff_coinduced_le, le_generateFrom_iff_subset_isOpen]\n  simp only [isOpen_coinduced, preimage_id', subset_def, mem_setOf]\n\n"}
{"name":"continuous_induced_dom","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nt : TopologicalSpace Œ≤\n‚ä¢ Continuous f","decl":"@[continuity, fun_prop]\ntheorem continuous_induced_dom {t : TopologicalSpace Œ≤} : Continuous[induced f t, t] f :=\n  continuous_iff_le_induced.2 le_rfl\n\n"}
{"name":"continuous_induced_rng","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type u_1\nf : Œ± ‚Üí Œ≤\ng : Œ≥ ‚Üí Œ±\nt‚ÇÇ : TopologicalSpace Œ≤\nt‚ÇÅ : TopologicalSpace Œ≥\n‚ä¢ Iff (Continuous g) (Continuous (Function.comp f g))","decl":"theorem continuous_induced_rng {g : Œ≥ ‚Üí Œ±} {t‚ÇÇ : TopologicalSpace Œ≤} {t‚ÇÅ : TopologicalSpace Œ≥} :\n    Continuous[t‚ÇÅ, induced f t‚ÇÇ] g ‚Üî Continuous[t‚ÇÅ, t‚ÇÇ] (f ‚àò g) := by\n  simp only [continuous_iff_le_induced, induced_compose]\n\n"}
{"name":"continuous_coinduced_rng","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nt : TopologicalSpace Œ±\n‚ä¢ Continuous f","decl":"theorem continuous_coinduced_rng {t : TopologicalSpace Œ±} :\n    Continuous[t, coinduced f t] f :=\n  continuous_iff_coinduced_le.2 le_rfl\n\n"}
{"name":"continuous_coinduced_dom","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type u_1\nf : Œ± ‚Üí Œ≤\ng : Œ≤ ‚Üí Œ≥\nt‚ÇÅ : TopologicalSpace Œ±\nt‚ÇÇ : TopologicalSpace Œ≥\n‚ä¢ Iff (Continuous g) (Continuous (Function.comp g f))","decl":"theorem continuous_coinduced_dom {g : Œ≤ ‚Üí Œ≥} {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ : TopologicalSpace Œ≥} :\n    Continuous[coinduced f t‚ÇÅ, t‚ÇÇ] g ‚Üî Continuous[t‚ÇÅ, t‚ÇÇ] (g ‚àò f) := by\n  simp only [continuous_iff_coinduced_le, coinduced_compose]\n\n"}
{"name":"continuous_le_dom","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nt‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±\nt‚ÇÉ : TopologicalSpace Œ≤\nh‚ÇÅ : LE.le t‚ÇÇ t‚ÇÅ\nh‚ÇÇ : Continuous f\n‚ä¢ Continuous f","decl":"theorem continuous_le_dom {t‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±} {t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÅ)\n    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÉ] f) : Continuous[t‚ÇÇ, t‚ÇÉ] f := by\n  rw [continuous_iff_le_induced] at h‚ÇÇ ‚ä¢\n  exact le_trans h‚ÇÅ h‚ÇÇ\n\n"}
{"name":"continuous_le_rng","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nt‚ÇÅ : TopologicalSpace Œ±\nt‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤\nh‚ÇÅ : LE.le t‚ÇÇ t‚ÇÉ\nh‚ÇÇ : Continuous f\n‚ä¢ Continuous f","decl":"theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)\n    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by\n  rw [continuous_iff_coinduced_le] at h‚ÇÇ ‚ä¢\n  exact le_trans h‚ÇÇ h‚ÇÅ\n\n"}
{"name":"continuous_sup_dom","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nt‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±\nt‚ÇÉ : TopologicalSpace Œ≤\n‚ä¢ Iff (Continuous f) (And (Continuous f) (Continuous f))","decl":"theorem continuous_sup_dom {t‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±} {t‚ÇÉ : TopologicalSpace Œ≤} :\n    Continuous[t‚ÇÅ ‚äî t‚ÇÇ, t‚ÇÉ] f ‚Üî Continuous[t‚ÇÅ, t‚ÇÉ] f ‚àß Continuous[t‚ÇÇ, t‚ÇÉ] f := by\n  simp only [continuous_iff_le_induced, sup_le_iff]\n\n"}
{"name":"continuous_sup_rng_left","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nt‚ÇÅ : TopologicalSpace Œ±\nt‚ÇÉ t‚ÇÇ : TopologicalSpace Œ≤\na‚úù : Continuous f\n‚ä¢ Continuous f","decl":"theorem continuous_sup_rng_left {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÉ t‚ÇÇ : TopologicalSpace Œ≤} :\n    Continuous[t‚ÇÅ, t‚ÇÇ] f ‚Üí Continuous[t‚ÇÅ, t‚ÇÇ ‚äî t‚ÇÉ] f :=\n  continuous_le_rng le_sup_left\n\n"}
{"name":"continuous_sup_rng_right","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nt‚ÇÅ : TopologicalSpace Œ±\nt‚ÇÉ t‚ÇÇ : TopologicalSpace Œ≤\na‚úù : Continuous f\n‚ä¢ Continuous f","decl":"theorem continuous_sup_rng_right {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÉ t‚ÇÇ : TopologicalSpace Œ≤} :\n    Continuous[t‚ÇÅ, t‚ÇÉ] f ‚Üí Continuous[t‚ÇÅ, t‚ÇÇ ‚äî t‚ÇÉ] f :=\n  continuous_le_rng le_sup_right\n\n"}
{"name":"continuous_sSup_dom","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nT : Set (TopologicalSpace Œ±)\nt‚ÇÇ : TopologicalSpace Œ≤\n‚ä¢ Iff (Continuous f) (‚àÄ (t : TopologicalSpace Œ±), Membership.mem T t ‚Üí Continuous f)","decl":"theorem continuous_sSup_dom {T : Set (TopologicalSpace Œ±)} {t‚ÇÇ : TopologicalSpace Œ≤} :\n    Continuous[sSup T, t‚ÇÇ] f ‚Üî ‚àÄ t ‚àà T, Continuous[t, t‚ÇÇ] f := by\n  simp only [continuous_iff_le_induced, sSup_le_iff]\n\n"}
{"name":"continuous_sSup_rng","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nt‚ÇÅ : TopologicalSpace Œ±\nt‚ÇÇ : Set (TopologicalSpace Œ≤)\nt : TopologicalSpace Œ≤\nh‚ÇÅ : Membership.mem t‚ÇÇ t\nhf : Continuous f\n‚ä¢ Continuous f","decl":"theorem continuous_sSup_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ : Set (TopologicalSpace Œ≤)}\n    {t : TopologicalSpace Œ≤} (h‚ÇÅ : t ‚àà t‚ÇÇ) (hf : Continuous[t‚ÇÅ, t] f) :\n    Continuous[t‚ÇÅ, sSup t‚ÇÇ] f :=\n  continuous_iff_coinduced_le.2 <| le_sSup_of_le h‚ÇÅ <| continuous_iff_coinduced_le.1 hf\n\n"}
{"name":"continuous_iSup_dom","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nŒπ : Sort u_2\nt‚ÇÅ : Œπ ‚Üí TopologicalSpace Œ±\nt‚ÇÇ : TopologicalSpace Œ≤\n‚ä¢ Iff (Continuous f) (‚àÄ (i : Œπ), Continuous f)","decl":"theorem continuous_iSup_dom {t‚ÇÅ : Œπ ‚Üí TopologicalSpace Œ±} {t‚ÇÇ : TopologicalSpace Œ≤} :\n    Continuous[iSup t‚ÇÅ, t‚ÇÇ] f ‚Üî ‚àÄ i, Continuous[t‚ÇÅ i, t‚ÇÇ] f := by\n  simp only [continuous_iff_le_induced, iSup_le_iff]\n\n"}
{"name":"continuous_iSup_rng","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nŒπ : Sort u_2\nt‚ÇÅ : TopologicalSpace Œ±\nt‚ÇÇ : Œπ ‚Üí TopologicalSpace Œ≤\ni : Œπ\nh : Continuous f\n‚ä¢ Continuous f","decl":"theorem continuous_iSup_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ : Œπ ‚Üí TopologicalSpace Œ≤} {i : Œπ}\n    (h : Continuous[t‚ÇÅ, t‚ÇÇ i] f) : Continuous[t‚ÇÅ, iSup t‚ÇÇ] f :=\n  continuous_sSup_rng ‚ü®i, rfl‚ü© h\n\n"}
{"name":"continuous_inf_rng","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nt‚ÇÅ : TopologicalSpace Œ±\nt‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤\n‚ä¢ Iff (Continuous f) (And (Continuous f) (Continuous f))","decl":"theorem continuous_inf_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} :\n    Continuous[t‚ÇÅ, t‚ÇÇ ‚äì t‚ÇÉ] f ‚Üî Continuous[t‚ÇÅ, t‚ÇÇ] f ‚àß Continuous[t‚ÇÅ, t‚ÇÉ] f := by\n  simp only [continuous_iff_coinduced_le, le_inf_iff]\n\n"}
{"name":"continuous_inf_dom_left","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nt‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±\nt‚ÇÉ : TopologicalSpace Œ≤\na‚úù : Continuous f\n‚ä¢ Continuous f","decl":"theorem continuous_inf_dom_left {t‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±} {t‚ÇÉ : TopologicalSpace Œ≤} :\n    Continuous[t‚ÇÅ, t‚ÇÉ] f ‚Üí Continuous[t‚ÇÅ ‚äì t‚ÇÇ, t‚ÇÉ] f :=\n  continuous_le_dom inf_le_left\n\n"}
{"name":"continuous_inf_dom_right","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nt‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±\nt‚ÇÉ : TopologicalSpace Œ≤\na‚úù : Continuous f\n‚ä¢ Continuous f","decl":"theorem continuous_inf_dom_right {t‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±} {t‚ÇÉ : TopologicalSpace Œ≤} :\n    Continuous[t‚ÇÇ, t‚ÇÉ] f ‚Üí Continuous[t‚ÇÅ ‚äì t‚ÇÇ, t‚ÇÉ] f :=\n  continuous_le_dom inf_le_right\n\n"}
{"name":"continuous_sInf_dom","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nt‚ÇÅ : Set (TopologicalSpace Œ±)\nt‚ÇÇ : TopologicalSpace Œ≤\nt : TopologicalSpace Œ±\nh‚ÇÅ : Membership.mem t‚ÇÅ t\na‚úù : Continuous f\n‚ä¢ Continuous f","decl":"theorem continuous_sInf_dom {t‚ÇÅ : Set (TopologicalSpace Œ±)} {t‚ÇÇ : TopologicalSpace Œ≤}\n    {t : TopologicalSpace Œ±} (h‚ÇÅ : t ‚àà t‚ÇÅ) :\n    Continuous[t, t‚ÇÇ] f ‚Üí Continuous[sInf t‚ÇÅ, t‚ÇÇ] f :=\n  continuous_le_dom <| sInf_le h‚ÇÅ\n\n"}
{"name":"continuous_sInf_rng","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nt‚ÇÅ : TopologicalSpace Œ±\nT : Set (TopologicalSpace Œ≤)\n‚ä¢ Iff (Continuous f) (‚àÄ (t : TopologicalSpace Œ≤), Membership.mem T t ‚Üí Continuous f)","decl":"theorem continuous_sInf_rng {t‚ÇÅ : TopologicalSpace Œ±} {T : Set (TopologicalSpace Œ≤)} :\n    Continuous[t‚ÇÅ, sInf T] f ‚Üî ‚àÄ t ‚àà T, Continuous[t‚ÇÅ, t] f := by\n  simp only [continuous_iff_coinduced_le, le_sInf_iff]\n\n"}
{"name":"continuous_iInf_dom","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nŒπ : Sort u_2\nt‚ÇÅ : Œπ ‚Üí TopologicalSpace Œ±\nt‚ÇÇ : TopologicalSpace Œ≤\ni : Œπ\na‚úù : Continuous f\n‚ä¢ Continuous f","decl":"theorem continuous_iInf_dom {t‚ÇÅ : Œπ ‚Üí TopologicalSpace Œ±} {t‚ÇÇ : TopologicalSpace Œ≤} {i : Œπ} :\n    Continuous[t‚ÇÅ i, t‚ÇÇ] f ‚Üí Continuous[iInf t‚ÇÅ, t‚ÇÇ] f :=\n  continuous_le_dom <| iInf_le _ _\n\n"}
{"name":"continuous_iInf_rng","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nŒπ : Sort u_2\nt‚ÇÅ : TopologicalSpace Œ±\nt‚ÇÇ : Œπ ‚Üí TopologicalSpace Œ≤\n‚ä¢ Iff (Continuous f) (‚àÄ (i : Œπ), Continuous f)","decl":"theorem continuous_iInf_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ : Œπ ‚Üí TopologicalSpace Œ≤} :\n    Continuous[t‚ÇÅ, iInf t‚ÇÇ] f ‚Üî ‚àÄ i, Continuous[t‚ÇÅ, t‚ÇÇ i] f := by\n  simp only [continuous_iff_coinduced_le, le_iInf_iff]\n\n"}
{"name":"continuous_bot","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nt : TopologicalSpace Œ≤\n‚ä¢ Continuous f","decl":"@[continuity, fun_prop]\ntheorem continuous_bot {t : TopologicalSpace Œ≤} : Continuous[‚ä•, t] f :=\n  continuous_iff_le_induced.2 bot_le\n\n"}
{"name":"continuous_top","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nt : TopologicalSpace Œ±\n‚ä¢ Continuous f","decl":"@[continuity, fun_prop]\ntheorem continuous_top {t : TopologicalSpace Œ±} : Continuous[t, ‚ä§] f :=\n  continuous_iff_coinduced_le.2 le_top\n\n"}
{"name":"continuous_id_iff_le","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nt t' : TopologicalSpace Œ±\n‚ä¢ Iff (Continuous id) (LE.le t t')","decl":"theorem continuous_id_iff_le {t t' : TopologicalSpace Œ±} : Continuous[t, t'] id ‚Üî t ‚â§ t' :=\n  @continuous_def _ _ t t' id\n\n"}
{"name":"continuous_id_of_le","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nt t' : TopologicalSpace Œ±\nh : LE.le t t'\n‚ä¢ Continuous id","decl":"theorem continuous_id_of_le {t t' : TopologicalSpace Œ±} (h : t ‚â§ t') : Continuous[t, t'] id :=\n  continuous_id_iff_le.2 h\n\n-- ùìù in the induced topology\n"}
{"name":"mem_nhds_induced","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nT : TopologicalSpace Œ±\nf : Œ≤ ‚Üí Œ±\na : Œ≤\ns : Set Œ≤\n‚ä¢ Iff (Membership.mem (nhds a) s) (Exists fun u => And (Membership.mem (nhds (f a)) u) (HasSubset.Subset (Set.preimage f u) s))","decl":"theorem mem_nhds_induced [T : TopologicalSpace Œ±] (f : Œ≤ ‚Üí Œ±) (a : Œ≤) (s : Set Œ≤) :\n    s ‚àà @nhds Œ≤ (TopologicalSpace.induced f T) a ‚Üî ‚àÉ u ‚àà ùìù (f a), f ‚Åª¬π' u ‚äÜ s := by\n  letI := T.induced f\n  simp_rw [mem_nhds_iff, isOpen_induced_iff]\n  constructor\n  ¬∑ rintro ‚ü®u, usub, ‚ü®v, openv, rfl‚ü©, au‚ü©\n    exact ‚ü®v, ‚ü®v, Subset.rfl, openv, au‚ü©, usub‚ü©\n  ¬∑ rintro ‚ü®u, ‚ü®v, vsubu, openv, amem‚ü©, finvsub‚ü©\n    exact ‚ü®f ‚Åª¬π' v, (Set.preimage_mono vsubu).trans finvsub, ‚ü®‚ü®v, openv, rfl‚ü©, amem‚ü©‚ü©\n\n"}
{"name":"nhds_induced","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nT : TopologicalSpace Œ±\nf : Œ≤ ‚Üí Œ±\na : Œ≤\n‚ä¢ Eq (nhds a) (Filter.comap f (nhds (f a)))","decl":"theorem nhds_induced [T : TopologicalSpace Œ±] (f : Œ≤ ‚Üí Œ±) (a : Œ≤) :\n    @nhds Œ≤ (TopologicalSpace.induced f T) a = comap f (ùìù (f a)) := by\n  ext s\n  rw [mem_nhds_induced, mem_comap]\n\n"}
{"name":"induced_iff_nhds_eq","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ntŒ± : TopologicalSpace Œ±\ntŒ≤ : TopologicalSpace Œ≤\nf : Œ≤ ‚Üí Œ±\n‚ä¢ Iff (Eq tŒ≤ (TopologicalSpace.induced f tŒ±)) (‚àÄ (b : Œ≤), Eq (nhds b) (Filter.comap f (nhds (f b))))","decl":"theorem induced_iff_nhds_eq [tŒ± : TopologicalSpace Œ±] [tŒ≤ : TopologicalSpace Œ≤] (f : Œ≤ ‚Üí Œ±) :\n    tŒ≤ = tŒ±.induced f ‚Üî ‚àÄ b, ùìù b = comap f (ùìù <| f b) := by\n  simp only [ext_iff_nhds, nhds_induced]\n\n"}
{"name":"map_nhds_induced_of_surjective","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nT : TopologicalSpace Œ±\nf : Œ≤ ‚Üí Œ±\nhf : Function.Surjective f\na : Œ≤\n‚ä¢ Eq (Filter.map f (nhds a)) (nhds (f a))","decl":"theorem map_nhds_induced_of_surjective [T : TopologicalSpace Œ±] {f : Œ≤ ‚Üí Œ±} (hf : Surjective f)\n    (a : Œ≤) : map f (@nhds Œ≤ (TopologicalSpace.induced f T) a) = ùìù (f a) := by\n  rw [nhds_induced, map_comap_of_surjective hf]\n\n"}
{"name":"continuous_nhdsAdjoint_dom","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\na : Œ±\nl : Filter Œ±\n‚ä¢ Iff (Continuous f) (Filter.Tendsto f l (nhds (f a)))","decl":"theorem continuous_nhdsAdjoint_dom [TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤} {a : Œ±} {l : Filter Œ±} :\n    Continuous[nhdsAdjoint a l, _] f ‚Üî Tendsto f l (ùìù (f a)) := by\n  simp_rw [continuous_iff_le_induced, gc_nhds _ _, nhds_induced, tendsto_iff_comap]\n\n"}
{"name":"coinduced_nhdsAdjoint","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\na : Œ±\nl : Filter Œ±\n‚ä¢ Eq (TopologicalSpace.coinduced f (nhdsAdjoint a l)) (nhdsAdjoint (f a) (Filter.map f l))","decl":"theorem coinduced_nhdsAdjoint (f : Œ± ‚Üí Œ≤) (a : Œ±) (l : Filter Œ±) :\n    coinduced f (nhdsAdjoint a l) = nhdsAdjoint (f a) (map f l) :=\n  eq_of_forall_ge_iff fun _ ‚Ü¶ by\n    rw [gc_nhds, ‚Üê continuous_iff_coinduced_le, continuous_nhdsAdjoint_dom, Tendsto]\n\n"}
{"name":"isOpen_induced_eq","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nt : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\n‚ä¢ Iff (IsOpen s) (Membership.mem (Set.image (Set.preimage f) (setOf fun s => IsOpen s)) s)","decl":"theorem isOpen_induced_eq {s : Set Œ±} :\n    IsOpen[induced f t] s ‚Üî s ‚àà preimage f '' { s | IsOpen s } :=\n  Iff.rfl\n\n"}
{"name":"isOpen_induced","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nt : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ≤\nh : IsOpen s\n‚ä¢ IsOpen (Set.preimage f s)","decl":"theorem isOpen_induced {s : Set Œ≤} (h : IsOpen s) : IsOpen[induced f t] (f ‚Åª¬π' s) :=\n  ‚ü®s, h, rfl‚ü©\n\n"}
{"name":"map_nhds_induced_eq","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nt : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\na : Œ±\n‚ä¢ Eq (Filter.map f (nhds a)) (nhdsWithin (f a) (Set.range f))","decl":"theorem map_nhds_induced_eq (a : Œ±) : map f (@nhds Œ± (induced f t) a) = ùìù[range f] f a := by\n  rw [nhds_induced, Filter.map_comap, nhdsWithin]\n\n"}
{"name":"map_nhds_induced_of_mem","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nt : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\na : Œ±\nh : Membership.mem (nhds (f a)) (Set.range f)\n‚ä¢ Eq (Filter.map f (nhds a)) (nhds (f a))","decl":"theorem map_nhds_induced_of_mem {a : Œ±} (h : range f ‚àà ùìù (f a)) :\n    map f (@nhds Œ± (induced f t) a) = ùìù (f a) := by rw [nhds_induced, Filter.map_comap_of_mem h]\n\n"}
{"name":"closure_induced","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nt : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\na : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (closure s) a) (Membership.mem (closure (Set.image f s)) (f a))","decl":"theorem closure_induced {f : Œ± ‚Üí Œ≤} {a : Œ±} {s : Set Œ±} :\n    a ‚àà @closure Œ± (t.induced f) s ‚Üî f a ‚àà closure (f '' s) := by\n  letI := t.induced f\n  simp only [mem_closure_iff_frequently, nhds_induced, frequently_comap, mem_image, and_comm]\n\n"}
{"name":"isClosed_induced_iff'","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nt : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\n‚ä¢ Iff (IsClosed s) (‚àÄ (a : Œ±), Membership.mem (closure (Set.image f s)) (f a) ‚Üí Membership.mem s a)","decl":"theorem isClosed_induced_iff' {f : Œ± ‚Üí Œ≤} {s : Set Œ±} :\n    IsClosed[t.induced f] s ‚Üî ‚àÄ a, f a ‚àà closure (f '' s) ‚Üí a ‚àà s := by\n  letI := t.induced f\n  simp only [‚Üê closure_subset_iff_isClosed, subset_def, closure_induced]\n\n"}
{"name":"isOpen_singleton_true","module":"Mathlib.Topology.Order","initialProofState":"‚ä¢ IsOpen (Singleton.singleton True)","decl":"@[simp]\ntheorem isOpen_singleton_true : IsOpen ({True} : Set Prop) :=\n  TopologicalSpace.GenerateOpen.basic _ (mem_singleton _)\n\n"}
{"name":"nhds_true","module":"Mathlib.Topology.Order","initialProofState":"‚ä¢ Eq (nhds True) (Pure.pure True)","decl":"@[simp]\ntheorem nhds_true : ùìù True = pure True :=\n  le_antisymm (le_pure_iff.2 <| isOpen_singleton_true.mem_nhds <| mem_singleton _) (pure_le_nhds _)\n\n"}
{"name":"nhds_false","module":"Mathlib.Topology.Order","initialProofState":"‚ä¢ Eq (nhds False) Top.top","decl":"@[simp]\ntheorem nhds_false : ùìù False = ‚ä§ :=\n  TopologicalSpace.nhds_generateFrom.trans <| by simp [@and_comm (_ ‚àà _), iInter_and]\n\n"}
{"name":"tendsto_nhds_true","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\np : Œ± ‚Üí Prop\n‚ä¢ Iff (Filter.Tendsto p l (nhds True)) (Filter.Eventually (fun x => p x) l)","decl":"theorem tendsto_nhds_true {l : Filter Œ±} {p : Œ± ‚Üí Prop} :\n    Tendsto p l (ùìù True) ‚Üî ‚àÄ·∂† x in l, p x := by simp\n\n"}
{"name":"tendsto_nhds_Prop","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\np : Œ± ‚Üí Prop\nq : Prop\n‚ä¢ Iff (Filter.Tendsto p l (nhds q)) (q ‚Üí Filter.Eventually (fun x => p x) l)","decl":"theorem tendsto_nhds_Prop {l : Filter Œ±} {p : Œ± ‚Üí Prop} {q : Prop} :\n    Tendsto p l (ùìù q) ‚Üî (q ‚Üí ‚àÄ·∂† x in l, p x) := by\n  by_cases q <;> simp [*]\n\n"}
{"name":"continuous_Prop","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\np : Œ± ‚Üí Prop\n‚ä¢ Iff (Continuous p) (IsOpen (setOf fun x => p x))","decl":"theorem continuous_Prop {p : Œ± ‚Üí Prop} : Continuous p ‚Üî IsOpen { x | p x } := by\n  simp only [continuous_iff_continuousAt, ContinuousAt, tendsto_nhds_Prop, isOpen_iff_mem_nhds]; rfl\n\n"}
{"name":"isOpen_iff_continuous_mem","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\ns : Set Œ±\n‚ä¢ Iff (IsOpen s) (Continuous fun x => Membership.mem s x)","decl":"theorem isOpen_iff_continuous_mem {s : Set Œ±} : IsOpen s ‚Üî Continuous (¬∑ ‚àà s) :=\n  continuous_Prop.symm\n\n"}
{"name":"generateFrom_union","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\na‚ÇÅ a‚ÇÇ : Set (Set Œ±)\n‚ä¢ Eq (TopologicalSpace.generateFrom (Union.union a‚ÇÅ a‚ÇÇ)) (Min.min (TopologicalSpace.generateFrom a‚ÇÅ) (TopologicalSpace.generateFrom a‚ÇÇ))","decl":"theorem generateFrom_union (a‚ÇÅ a‚ÇÇ : Set (Set Œ±)) :\n    generateFrom (a‚ÇÅ ‚à™ a‚ÇÇ) = generateFrom a‚ÇÅ ‚äì generateFrom a‚ÇÇ :=\n  (gc_generateFrom Œ±).u_inf\n\n"}
{"name":"setOf_isOpen_sup","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nt‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±\n‚ä¢ Eq (setOf fun s => IsOpen s) (Inter.inter (setOf fun s => IsOpen s) (setOf fun s => IsOpen s))","decl":"theorem setOf_isOpen_sup (t‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±) :\n    { s | IsOpen[t‚ÇÅ ‚äî t‚ÇÇ] s } = { s | IsOpen[t‚ÇÅ] s } ‚à© { s | IsOpen[t‚ÇÇ] s } :=\n  rfl\n\n"}
{"name":"generateFrom_iUnion","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒπ : Sort v\nf : Œπ ‚Üí Set (Set Œ±)\n‚ä¢ Eq (TopologicalSpace.generateFrom (Set.iUnion fun i => f i)) (iInf fun i => TopologicalSpace.generateFrom (f i))","decl":"theorem generateFrom_iUnion {f : Œπ ‚Üí Set (Set Œ±)} :\n    generateFrom (‚ãÉ i, f i) = ‚®Ö i, generateFrom (f i) :=\n  (gc_generateFrom Œ±).u_iInf\n\n"}
{"name":"setOf_isOpen_iSup","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒπ : Sort v\nt : Œπ ‚Üí TopologicalSpace Œ±\n‚ä¢ Eq (setOf fun s => IsOpen s) (Set.iInter fun i => setOf fun s => IsOpen s)","decl":"theorem setOf_isOpen_iSup {t : Œπ ‚Üí TopologicalSpace Œ±} :\n    { s | IsOpen[‚®Ü i, t i] s } = ‚ãÇ i, { s | IsOpen[t i] s } :=\n  (gc_generateFrom Œ±).l_iSup\n\n"}
{"name":"generateFrom_sUnion","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nS : Set (Set (Set Œ±))\n‚ä¢ Eq (TopologicalSpace.generateFrom S.sUnion) (iInf fun s => iInf fun h => TopologicalSpace.generateFrom s)","decl":"theorem generateFrom_sUnion {S : Set (Set (Set Œ±))} :\n    generateFrom (‚ãÉ‚ÇÄ S) = ‚®Ö s ‚àà S, generateFrom s :=\n  (gc_generateFrom Œ±).u_sInf\n\n"}
{"name":"setOf_isOpen_sSup","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nT : Set (TopologicalSpace Œ±)\n‚ä¢ Eq (setOf fun s => IsOpen s) (Set.iInter fun t => Set.iInter fun h => setOf fun s => IsOpen s)","decl":"theorem setOf_isOpen_sSup {T : Set (TopologicalSpace Œ±)} :\n    { s | IsOpen[sSup T] s } = ‚ãÇ t ‚àà T, { s | IsOpen[t] s } :=\n  (gc_generateFrom Œ±).l_sSup\n\n"}
{"name":"generateFrom_union_isOpen","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\na b : TopologicalSpace Œ±\n‚ä¢ Eq (TopologicalSpace.generateFrom (Union.union (setOf fun s => IsOpen s) (setOf fun s => IsOpen s))) (Min.min a b)","decl":"theorem generateFrom_union_isOpen (a b : TopologicalSpace Œ±) :\n    generateFrom ({ s | IsOpen[a] s } ‚à™ { s | IsOpen[b] s }) = a ‚äì b :=\n  (gciGenerateFrom Œ±).u_inf_l _ _\n\n"}
{"name":"generateFrom_iUnion_isOpen","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒπ : Sort v\nf : Œπ ‚Üí TopologicalSpace Œ±\n‚ä¢ Eq (TopologicalSpace.generateFrom (Set.iUnion fun i => setOf fun s => IsOpen s)) (iInf fun i => f i)","decl":"theorem generateFrom_iUnion_isOpen (f : Œπ ‚Üí TopologicalSpace Œ±) :\n    generateFrom (‚ãÉ i, { s | IsOpen[f i] s }) = ‚®Ö i, f i :=\n  (gciGenerateFrom Œ±).u_iInf_l _\n\n"}
{"name":"generateFrom_inter","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\na b : TopologicalSpace Œ±\n‚ä¢ Eq (TopologicalSpace.generateFrom (Inter.inter (setOf fun s => IsOpen s) (setOf fun s => IsOpen s))) (Max.max a b)","decl":"theorem generateFrom_inter (a b : TopologicalSpace Œ±) :\n    generateFrom ({ s | IsOpen[a] s } ‚à© { s | IsOpen[b] s }) = a ‚äî b :=\n  (gciGenerateFrom Œ±).u_sup_l _ _\n\n"}
{"name":"generateFrom_iInter","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒπ : Sort v\nf : Œπ ‚Üí TopologicalSpace Œ±\n‚ä¢ Eq (TopologicalSpace.generateFrom (Set.iInter fun i => setOf fun s => IsOpen s)) (iSup fun i => f i)","decl":"theorem generateFrom_iInter (f : Œπ ‚Üí TopologicalSpace Œ±) :\n    generateFrom (‚ãÇ i, { s | IsOpen[f i] s }) = ‚®Ü i, f i :=\n  (gciGenerateFrom Œ±).u_iSup_l _\n\n"}
{"name":"generateFrom_iInter_of_generateFrom_eq_self","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒπ : Sort v\nf : Œπ ‚Üí Set (Set Œ±)\nhf : ‚àÄ (i : Œπ), Eq (setOf fun s => IsOpen s) (f i)\n‚ä¢ Eq (TopologicalSpace.generateFrom (Set.iInter fun i => f i)) (iSup fun i => TopologicalSpace.generateFrom (f i))","decl":"theorem generateFrom_iInter_of_generateFrom_eq_self (f : Œπ ‚Üí Set (Set Œ±))\n    (hf : ‚àÄ i, { s | IsOpen[generateFrom (f i)] s } = f i) :\n    generateFrom (‚ãÇ i, f i) = ‚®Ü i, generateFrom (f i) :=\n  (gciGenerateFrom Œ±).u_iSup_of_lu_eq_self f hf\n\n"}
{"name":"isOpen_iSup_iff","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒπ : Sort v\nt : Œπ ‚Üí TopologicalSpace Œ±\ns : Set Œ±\n‚ä¢ Iff (IsOpen s) (‚àÄ (i : Œπ), IsOpen s)","decl":"theorem isOpen_iSup_iff {s : Set Œ±} : IsOpen[‚®Ü i, t i] s ‚Üî ‚àÄ i, IsOpen[t i] s :=\n  show s ‚àà {s | IsOpen[iSup t] s} ‚Üî s ‚àà { x : Set Œ± | ‚àÄ i : Œπ, IsOpen[t i] x } by\n    simp [setOf_isOpen_iSup]\n\n"}
{"name":"isOpen_sSup_iff","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\ns : Set Œ±\nT : Set (TopologicalSpace Œ±)\n‚ä¢ Iff (IsOpen s) (‚àÄ (t : TopologicalSpace Œ±), Membership.mem T t ‚Üí IsOpen s)","decl":"theorem isOpen_sSup_iff {s : Set Œ±} {T : Set (TopologicalSpace Œ±)} :\n    IsOpen[sSup T] s ‚Üî ‚àÄ t ‚àà T, IsOpen[t] s := by\n  simp only [sSup_eq_iSup, isOpen_iSup_iff]\n\n"}
{"name":"isClosed_iSup_iff","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\nŒπ : Sort v\nt : Œπ ‚Üí TopologicalSpace Œ±\ns : Set Œ±\n‚ä¢ Iff (IsClosed s) (‚àÄ (i : Œπ), IsClosed s)","decl":"theorem isClosed_iSup_iff {s : Set Œ±} : IsClosed[‚®Ü i, t i] s ‚Üî ‚àÄ i, IsClosed[t i] s := by\n  simp only [‚Üê @isOpen_compl_iff _ _ (‚®Ü i, t i), ‚Üê @isOpen_compl_iff _ _ (t _), isOpen_iSup_iff]\n\n"}
{"name":"isClosed_sSup_iff","module":"Mathlib.Topology.Order","initialProofState":"Œ± : Type u\ns : Set Œ±\nT : Set (TopologicalSpace Œ±)\n‚ä¢ Iff (IsClosed s) (‚àÄ (t : TopologicalSpace Œ±), Membership.mem T t ‚Üí IsClosed s)","decl":"theorem isClosed_sSup_iff {s : Set Œ±} {T : Set (TopologicalSpace Œ±)} :\n    IsClosed[sSup T] s ‚Üî ‚àÄ t ‚àà T, IsClosed[t] s := by\n  simp only [sSup_eq_iSup, isClosed_iSup_iff]\n\n"}
