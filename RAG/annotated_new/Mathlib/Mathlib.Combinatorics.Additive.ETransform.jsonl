{"name":"Finset.mulDysonETransform_snd","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : CommGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (Finset.mulDysonETransform e x).2 (Inter.inter x.2 (HSMul.hSMul (Inv.inv e) x.1))","decl":"/-- The **Dyson e-transform**. Turns `(s, t)` into `(s ∪ e • t, t ∩ e⁻¹ • s)`. This reduces the\nproduct of the two sets. -/\n@[to_additive (attr := simps) \"The **Dyson e-transform**.\nTurns `(s, t)` into `(s ∪ e +ᵥ t, t ∩ -e +ᵥ s)`. This reduces the sum of the two sets.\"]\ndef mulDysonETransform : Finset α × Finset α :=\n  (x.1 ∪ e • x.2, x.2 ∩ e⁻¹ • x.1)\n\n"}
{"name":"Finset.addDysonETransform_fst","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : AddCommGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (Finset.addDysonETransform e x).1 (Union.union x.1 (HVAdd.hVAdd e x.2))","decl":"/-- The **Dyson e-transform**. Turns `(s, t)` into `(s ∪ e • t, t ∩ e⁻¹ • s)`. This reduces the\nproduct of the two sets. -/\n@[to_additive (attr := simps) \"The **Dyson e-transform**.\nTurns `(s, t)` into `(s ∪ e +ᵥ t, t ∩ -e +ᵥ s)`. This reduces the sum of the two sets.\"]\ndef mulDysonETransform : Finset α × Finset α :=\n  (x.1 ∪ e • x.2, x.2 ∩ e⁻¹ • x.1)\n\n"}
{"name":"Finset.addDysonETransform_snd","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : AddCommGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (Finset.addDysonETransform e x).2 (Inter.inter x.2 (HVAdd.hVAdd (Neg.neg e) x.1))","decl":"/-- The **Dyson e-transform**. Turns `(s, t)` into `(s ∪ e • t, t ∩ e⁻¹ • s)`. This reduces the\nproduct of the two sets. -/\n@[to_additive (attr := simps) \"The **Dyson e-transform**.\nTurns `(s, t)` into `(s ∪ e +ᵥ t, t ∩ -e +ᵥ s)`. This reduces the sum of the two sets.\"]\ndef mulDysonETransform : Finset α × Finset α :=\n  (x.1 ∪ e • x.2, x.2 ∩ e⁻¹ • x.1)\n\n"}
{"name":"Finset.mulDysonETransform_fst","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : CommGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (Finset.mulDysonETransform e x).1 (Union.union x.1 (HSMul.hSMul e x.2))","decl":"/-- The **Dyson e-transform**. Turns `(s, t)` into `(s ∪ e • t, t ∩ e⁻¹ • s)`. This reduces the\nproduct of the two sets. -/\n@[to_additive (attr := simps) \"The **Dyson e-transform**.\nTurns `(s, t)` into `(s ∪ e +ᵥ t, t ∩ -e +ᵥ s)`. This reduces the sum of the two sets.\"]\ndef mulDysonETransform : Finset α × Finset α :=\n  (x.1 ∪ e • x.2, x.2 ∩ e⁻¹ • x.1)\n\n"}
{"name":"Finset.mulDysonETransform.subset","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : CommGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ HasSubset.Subset (HMul.hMul (Finset.mulDysonETransform e x).1 (Finset.mulDysonETransform e x).2) (HMul.hMul x.1 x.2)","decl":"@[to_additive]\ntheorem mulDysonETransform.subset :\n    (mulDysonETransform e x).1 * (mulDysonETransform e x).2 ⊆ x.1 * x.2 := by\n  refine union_mul_inter_subset_union.trans (union_subset Subset.rfl ?_)\n  rw [mul_smul_comm, smul_mul_assoc, inv_smul_smul, mul_comm]\n\n"}
{"name":"Finset.addDysonETransform.subset","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : AddCommGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ HasSubset.Subset (HAdd.hAdd (Finset.addDysonETransform e x).1 (Finset.addDysonETransform e x).2) (HAdd.hAdd x.1 x.2)","decl":"@[to_additive]\ntheorem mulDysonETransform.subset :\n    (mulDysonETransform e x).1 * (mulDysonETransform e x).2 ⊆ x.1 * x.2 := by\n  refine union_mul_inter_subset_union.trans (union_subset Subset.rfl ?_)\n  rw [mul_smul_comm, smul_mul_assoc, inv_smul_smul, mul_comm]\n\n"}
{"name":"Finset.mulDysonETransform.card","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : CommGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (HAdd.hAdd (Finset.mulDysonETransform e x).1.card (Finset.mulDysonETransform e x).2.card) (HAdd.hAdd x.1.card x.2.card)","decl":"@[to_additive]\ntheorem mulDysonETransform.card :\n    (mulDysonETransform e x).1.card + (mulDysonETransform e x).2.card = x.1.card + x.2.card := by\n  dsimp\n  rw [← card_smul_finset e (_ ∩ _), smul_finset_inter, smul_inv_smul, inter_comm,\n    card_union_add_card_inter, card_smul_finset]\n\n"}
{"name":"Finset.addDysonETransform.card","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : AddCommGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (HAdd.hAdd (Finset.addDysonETransform e x).1.card (Finset.addDysonETransform e x).2.card) (HAdd.hAdd x.1.card x.2.card)","decl":"@[to_additive]\ntheorem mulDysonETransform.card :\n    (mulDysonETransform e x).1.card + (mulDysonETransform e x).2.card = x.1.card + x.2.card := by\n  dsimp\n  rw [← card_smul_finset e (_ ∩ _), smul_finset_inter, smul_inv_smul, inter_comm,\n    card_union_add_card_inter, card_smul_finset]\n\n"}
{"name":"Finset.addDysonETransform_idem","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : AddCommGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (Finset.addDysonETransform e (Finset.addDysonETransform e x)) (Finset.addDysonETransform e x)","decl":"@[to_additive (attr := simp)]\ntheorem mulDysonETransform_idem :\n    mulDysonETransform e (mulDysonETransform e x) = mulDysonETransform e x := by\n  ext : 1 <;> dsimp\n  · rw [smul_finset_inter, smul_inv_smul, inter_comm, union_eq_left]\n    exact inter_subset_union\n  · rw [smul_finset_union, inv_smul_smul, union_comm, inter_eq_left]\n    exact inter_subset_union\n\n"}
{"name":"Finset.mulDysonETransform_idem","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : CommGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (Finset.mulDysonETransform e (Finset.mulDysonETransform e x)) (Finset.mulDysonETransform e x)","decl":"@[to_additive (attr := simp)]\ntheorem mulDysonETransform_idem :\n    mulDysonETransform e (mulDysonETransform e x) = mulDysonETransform e x := by\n  ext : 1 <;> dsimp\n  · rw [smul_finset_inter, smul_inv_smul, inter_comm, union_eq_left]\n    exact inter_subset_union\n  · rw [smul_finset_union, inv_smul_smul, union_comm, inter_eq_left]\n    exact inter_subset_union\n\n"}
{"name":"Finset.mulDysonETransform.smul_finset_snd_subset_fst","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : CommGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ HasSubset.Subset (HSMul.hSMul e (Finset.mulDysonETransform e x).2) (Finset.mulDysonETransform e x).1","decl":"@[to_additive]\ntheorem mulDysonETransform.smul_finset_snd_subset_fst :\n    e • (mulDysonETransform e x).2 ⊆ (mulDysonETransform e x).1 := by\n  dsimp\n  rw [smul_finset_inter, smul_inv_smul, inter_comm]\n  exact inter_subset_union\n\n"}
{"name":"Finset.addDysonETransform.vadd_finset_snd_subset_fst","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : AddCommGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ HasSubset.Subset (HVAdd.hVAdd e (Finset.addDysonETransform e x).2) (Finset.addDysonETransform e x).1","decl":"@[to_additive]\ntheorem mulDysonETransform.smul_finset_snd_subset_fst :\n    e • (mulDysonETransform e x).2 ⊆ (mulDysonETransform e x).1 := by\n  dsimp\n  rw [smul_finset_inter, smul_inv_smul, inter_comm]\n  exact inter_subset_union\n\n"}
{"name":"Finset.addETransformLeft_fst","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : AddGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (Finset.addETransformLeft e x).1 (Inter.inter x.1 (HVAdd.hVAdd (AddOpposite.op e) x.1))","decl":"/-- An **e-transform**. Turns `(s, t)` into `(s ∩ s • e, t ∪ e⁻¹ • t)`. This reduces the\nproduct of the two sets. -/\n@[to_additive (attr := simps) \"An **e-transform**.\nTurns `(s, t)` into `(s ∩ s +ᵥ e, t ∪ -e +ᵥ t)`. This reduces the sum of the two sets.\"]\ndef mulETransformLeft : Finset α × Finset α :=\n  (x.1 ∩ op e • x.1, x.2 ∪ e⁻¹ • x.2)\n\n"}
{"name":"Finset.addETransformLeft_snd","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : AddGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (Finset.addETransformLeft e x).2 (Union.union x.2 (HVAdd.hVAdd (Neg.neg e) x.2))","decl":"/-- An **e-transform**. Turns `(s, t)` into `(s ∩ s • e, t ∪ e⁻¹ • t)`. This reduces the\nproduct of the two sets. -/\n@[to_additive (attr := simps) \"An **e-transform**.\nTurns `(s, t)` into `(s ∩ s +ᵥ e, t ∪ -e +ᵥ t)`. This reduces the sum of the two sets.\"]\ndef mulETransformLeft : Finset α × Finset α :=\n  (x.1 ∩ op e • x.1, x.2 ∪ e⁻¹ • x.2)\n\n"}
{"name":"Finset.mulETransformLeft_fst","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Group α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (Finset.mulETransformLeft e x).1 (Inter.inter x.1 (HSMul.hSMul (MulOpposite.op e) x.1))","decl":"/-- An **e-transform**. Turns `(s, t)` into `(s ∩ s • e, t ∪ e⁻¹ • t)`. This reduces the\nproduct of the two sets. -/\n@[to_additive (attr := simps) \"An **e-transform**.\nTurns `(s, t)` into `(s ∩ s +ᵥ e, t ∪ -e +ᵥ t)`. This reduces the sum of the two sets.\"]\ndef mulETransformLeft : Finset α × Finset α :=\n  (x.1 ∩ op e • x.1, x.2 ∪ e⁻¹ • x.2)\n\n"}
{"name":"Finset.mulETransformLeft_snd","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Group α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (Finset.mulETransformLeft e x).2 (Union.union x.2 (HSMul.hSMul (Inv.inv e) x.2))","decl":"/-- An **e-transform**. Turns `(s, t)` into `(s ∩ s • e, t ∪ e⁻¹ • t)`. This reduces the\nproduct of the two sets. -/\n@[to_additive (attr := simps) \"An **e-transform**.\nTurns `(s, t)` into `(s ∩ s +ᵥ e, t ∪ -e +ᵥ t)`. This reduces the sum of the two sets.\"]\ndef mulETransformLeft : Finset α × Finset α :=\n  (x.1 ∩ op e • x.1, x.2 ∪ e⁻¹ • x.2)\n\n"}
{"name":"Finset.mulETransformRight_snd","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Group α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (Finset.mulETransformRight e x).2 (Inter.inter x.2 (HSMul.hSMul (Inv.inv e) x.2))","decl":"/-- An **e-transform**. Turns `(s, t)` into `(s ∪ s • e, t ∩ e⁻¹ • t)`. This reduces the\nproduct of the two sets. -/\n@[to_additive (attr := simps) \"An **e-transform**.\nTurns `(s, t)` into `(s ∪ s +ᵥ e, t ∩ -e +ᵥ t)`. This reduces the sum of the two sets.\"]\ndef mulETransformRight : Finset α × Finset α :=\n  (x.1 ∪ op e • x.1, x.2 ∩ e⁻¹ • x.2)\n\n"}
{"name":"Finset.addETransformRight_fst","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : AddGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (Finset.addETransformRight e x).1 (Union.union x.1 (HVAdd.hVAdd (AddOpposite.op e) x.1))","decl":"/-- An **e-transform**. Turns `(s, t)` into `(s ∪ s • e, t ∩ e⁻¹ • t)`. This reduces the\nproduct of the two sets. -/\n@[to_additive (attr := simps) \"An **e-transform**.\nTurns `(s, t)` into `(s ∪ s +ᵥ e, t ∩ -e +ᵥ t)`. This reduces the sum of the two sets.\"]\ndef mulETransformRight : Finset α × Finset α :=\n  (x.1 ∪ op e • x.1, x.2 ∩ e⁻¹ • x.2)\n\n"}
{"name":"Finset.addETransformRight_snd","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : AddGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (Finset.addETransformRight e x).2 (Inter.inter x.2 (HVAdd.hVAdd (Neg.neg e) x.2))","decl":"/-- An **e-transform**. Turns `(s, t)` into `(s ∪ s • e, t ∩ e⁻¹ • t)`. This reduces the\nproduct of the two sets. -/\n@[to_additive (attr := simps) \"An **e-transform**.\nTurns `(s, t)` into `(s ∪ s +ᵥ e, t ∩ -e +ᵥ t)`. This reduces the sum of the two sets.\"]\ndef mulETransformRight : Finset α × Finset α :=\n  (x.1 ∪ op e • x.1, x.2 ∩ e⁻¹ • x.2)\n\n"}
{"name":"Finset.mulETransformRight_fst","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Group α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (Finset.mulETransformRight e x).1 (Union.union x.1 (HSMul.hSMul (MulOpposite.op e) x.1))","decl":"/-- An **e-transform**. Turns `(s, t)` into `(s ∪ s • e, t ∩ e⁻¹ • t)`. This reduces the\nproduct of the two sets. -/\n@[to_additive (attr := simps) \"An **e-transform**.\nTurns `(s, t)` into `(s ∪ s +ᵥ e, t ∩ -e +ᵥ t)`. This reduces the sum of the two sets.\"]\ndef mulETransformRight : Finset α × Finset α :=\n  (x.1 ∪ op e • x.1, x.2 ∩ e⁻¹ • x.2)\n\n"}
{"name":"Finset.addETransformLeft_zero","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : AddGroup α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (Finset.addETransformLeft 0 x) x","decl":"@[to_additive (attr := simp)]\ntheorem mulETransformLeft_one : mulETransformLeft 1 x = x := by simp [mulETransformLeft]\n\n"}
{"name":"Finset.mulETransformLeft_one","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Group α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (Finset.mulETransformLeft 1 x) x","decl":"@[to_additive (attr := simp)]\ntheorem mulETransformLeft_one : mulETransformLeft 1 x = x := by simp [mulETransformLeft]\n\n"}
{"name":"Finset.mulETransformRight_one","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Group α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (Finset.mulETransformRight 1 x) x","decl":"@[to_additive (attr := simp)]\ntheorem mulETransformRight_one : mulETransformRight 1 x = x := by simp [mulETransformRight]\n\n"}
{"name":"Finset.addETransformRight_zero","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : AddGroup α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (Finset.addETransformRight 0 x) x","decl":"@[to_additive (attr := simp)]\ntheorem mulETransformRight_one : mulETransformRight 1 x = x := by simp [mulETransformRight]\n\n"}
{"name":"Finset.mulETransformLeft.fst_mul_snd_subset","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Group α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ HasSubset.Subset (HMul.hMul (Finset.mulETransformLeft e x).1 (Finset.mulETransformLeft e x).2) (HMul.hMul x.1 x.2)","decl":"@[to_additive]\ntheorem mulETransformLeft.fst_mul_snd_subset :\n    (mulETransformLeft e x).1 * (mulETransformLeft e x).2 ⊆ x.1 * x.2 := by\n  refine inter_mul_union_subset_union.trans (union_subset Subset.rfl ?_)\n  rw [op_smul_finset_mul_eq_mul_smul_finset, smul_inv_smul]\n\n"}
{"name":"Finset.addETransformLeft.fst_add_snd_subset","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : AddGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ HasSubset.Subset (HAdd.hAdd (Finset.addETransformLeft e x).1 (Finset.addETransformLeft e x).2) (HAdd.hAdd x.1 x.2)","decl":"@[to_additive]\ntheorem mulETransformLeft.fst_mul_snd_subset :\n    (mulETransformLeft e x).1 * (mulETransformLeft e x).2 ⊆ x.1 * x.2 := by\n  refine inter_mul_union_subset_union.trans (union_subset Subset.rfl ?_)\n  rw [op_smul_finset_mul_eq_mul_smul_finset, smul_inv_smul]\n\n"}
{"name":"Finset.mulETransformRight.fst_mul_snd_subset","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Group α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ HasSubset.Subset (HMul.hMul (Finset.mulETransformRight e x).1 (Finset.mulETransformRight e x).2) (HMul.hMul x.1 x.2)","decl":"@[to_additive]\ntheorem mulETransformRight.fst_mul_snd_subset :\n    (mulETransformRight e x).1 * (mulETransformRight e x).2 ⊆ x.1 * x.2 := by\n  refine union_mul_inter_subset_union.trans (union_subset Subset.rfl ?_)\n  rw [op_smul_finset_mul_eq_mul_smul_finset, smul_inv_smul]\n\n"}
{"name":"Finset.addETransformRight.fst_add_snd_subset","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : AddGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ HasSubset.Subset (HAdd.hAdd (Finset.addETransformRight e x).1 (Finset.addETransformRight e x).2) (HAdd.hAdd x.1 x.2)","decl":"@[to_additive]\ntheorem mulETransformRight.fst_mul_snd_subset :\n    (mulETransformRight e x).1 * (mulETransformRight e x).2 ⊆ x.1 * x.2 := by\n  refine union_mul_inter_subset_union.trans (union_subset Subset.rfl ?_)\n  rw [op_smul_finset_mul_eq_mul_smul_finset, smul_inv_smul]\n\n"}
{"name":"Finset.addETransformLeft.card","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : AddGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (HAdd.hAdd (Finset.addETransformLeft e x).1.card (Finset.addETransformRight e x).1.card) (HMul.hMul 2 x.1.card)","decl":"@[to_additive]\ntheorem mulETransformLeft.card :\n    (mulETransformLeft e x).1.card + (mulETransformRight e x).1.card = 2 * x.1.card :=\n  (card_inter_add_card_union _ _).trans <| by rw [card_smul_finset, two_mul]\n\n"}
{"name":"Finset.mulETransformLeft.card","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Group α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (HAdd.hAdd (Finset.mulETransformLeft e x).1.card (Finset.mulETransformRight e x).1.card) (HMul.hMul 2 x.1.card)","decl":"@[to_additive]\ntheorem mulETransformLeft.card :\n    (mulETransformLeft e x).1.card + (mulETransformRight e x).1.card = 2 * x.1.card :=\n  (card_inter_add_card_union _ _).trans <| by rw [card_smul_finset, two_mul]\n\n"}
{"name":"Finset.addETransformRight.card","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : AddGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (HAdd.hAdd (Finset.addETransformLeft e x).2.card (Finset.addETransformRight e x).2.card) (HMul.hMul 2 x.2.card)","decl":"@[to_additive]\ntheorem mulETransformRight.card :\n    (mulETransformLeft e x).2.card + (mulETransformRight e x).2.card = 2 * x.2.card :=\n  (card_union_add_card_inter _ _).trans <| by rw [card_smul_finset, two_mul]\n\n"}
{"name":"Finset.mulETransformRight.card","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Group α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (HAdd.hAdd (Finset.mulETransformLeft e x).2.card (Finset.mulETransformRight e x).2.card) (HMul.hMul 2 x.2.card)","decl":"@[to_additive]\ntheorem mulETransformRight.card :\n    (mulETransformLeft e x).2.card + (mulETransformRight e x).2.card = 2 * x.2.card :=\n  (card_union_add_card_inter _ _).trans <| by rw [card_smul_finset, two_mul]\n\n"}
{"name":"Finset.MulETransform.card","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Group α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (HAdd.hAdd (HAdd.hAdd (Finset.mulETransformLeft e x).1.card (Finset.mulETransformLeft e x).2.card) (HAdd.hAdd (Finset.mulETransformRight e x).1.card (Finset.mulETransformRight e x).2.card)) (HAdd.hAdd (HAdd.hAdd x.1.card x.2.card) (HAdd.hAdd x.1.card x.2.card))","decl":"/-- This statement is meant to be combined with `le_or_lt_of_add_le_add` and similar lemmas. -/\n@[to_additive AddETransform.card \"This statement is meant to be combined with\n`le_or_lt_of_add_le_add` and similar lemmas.\"]\nprotected theorem MulETransform.card :\n    (mulETransformLeft e x).1.card + (mulETransformLeft e x).2.card +\n        ((mulETransformRight e x).1.card + (mulETransformRight e x).2.card) =\n      x.1.card + x.2.card + (x.1.card + x.2.card) := by\n  rw [add_add_add_comm, mulETransformLeft.card, mulETransformRight.card, ← mul_add, two_mul]\n\n"}
{"name":"Finset.AddETransform.card","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : AddGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (HAdd.hAdd (HAdd.hAdd (Finset.addETransformLeft e x).1.card (Finset.addETransformLeft e x).2.card) (HAdd.hAdd (Finset.addETransformRight e x).1.card (Finset.addETransformRight e x).2.card)) (HAdd.hAdd (HAdd.hAdd x.1.card x.2.card) (HAdd.hAdd x.1.card x.2.card))","decl":"/-- This statement is meant to be combined with `le_or_lt_of_add_le_add` and similar lemmas. -/\n@[to_additive AddETransform.card \"This statement is meant to be combined with\n`le_or_lt_of_add_le_add` and similar lemmas.\"]\nprotected theorem MulETransform.card :\n    (mulETransformLeft e x).1.card + (mulETransformLeft e x).2.card +\n        ((mulETransformRight e x).1.card + (mulETransformRight e x).2.card) =\n      x.1.card + x.2.card + (x.1.card + x.2.card) := by\n  rw [add_add_add_comm, mulETransformLeft.card, mulETransformRight.card, ← mul_add, two_mul]\n\n"}
{"name":"Finset.mulETransformLeft_inv","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : CommGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (Finset.mulETransformLeft (Inv.inv e) x) (Finset.mulETransformRight e x.swap).swap","decl":"@[to_additive (attr := simp)]\ntheorem mulETransformLeft_inv : mulETransformLeft e⁻¹ x = (mulETransformRight e x.swap).swap := by\n  simp [-op_inv, op_smul_eq_smul, mulETransformLeft, mulETransformRight]\n\n"}
{"name":"Finset.addETransformLeft_neg","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : AddCommGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (Finset.addETransformLeft (Neg.neg e) x) (Finset.addETransformRight e x.swap).swap","decl":"@[to_additive (attr := simp)]\ntheorem mulETransformLeft_inv : mulETransformLeft e⁻¹ x = (mulETransformRight e x.swap).swap := by\n  simp [-op_inv, op_smul_eq_smul, mulETransformLeft, mulETransformRight]\n\n"}
{"name":"Finset.mulETransformRight_inv","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : CommGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (Finset.mulETransformRight (Inv.inv e) x) (Finset.mulETransformLeft e x.swap).swap","decl":"@[to_additive (attr := simp)]\ntheorem mulETransformRight_inv : mulETransformRight e⁻¹ x = (mulETransformLeft e x.swap).swap := by\n  simp [-op_inv, op_smul_eq_smul, mulETransformLeft, mulETransformRight]\n\n"}
{"name":"Finset.addETransformRight_neg","module":"Mathlib.Combinatorics.Additive.ETransform","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : AddCommGroup α\ne : α\nx : Prod (Finset α) (Finset α)\n⊢ Eq (Finset.addETransformRight (Neg.neg e) x) (Finset.addETransformLeft e x.swap).swap","decl":"@[to_additive (attr := simp)]\ntheorem mulETransformRight_inv : mulETransformRight e⁻¹ x = (mulETransformLeft e x.swap).swap := by\n  simp [-op_inv, op_smul_eq_smul, mulETransformLeft, mulETransformRight]\n\n"}
