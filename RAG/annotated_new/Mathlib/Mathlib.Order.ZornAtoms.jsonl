{"name":"IsCoatomic.of_isChain_bounded","module":"Mathlib.Order.ZornAtoms","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\nh : ∀ (c : Set α), IsChain (fun x1 x2 => LE.le x1 x2) c → c.Nonempty → Not (Membership.mem c Top.top) → Exists fun x => And (Ne x Top.top) (Membership.mem (upperBounds c) x)\n⊢ IsCoatomic α","decl":"/-- **Zorn's lemma**: A partial order is coatomic if every nonempty chain `c`, `⊤ ∉ c`, has an upper\nbound not equal to `⊤`. -/\ntheorem IsCoatomic.of_isChain_bounded {α : Type*} [PartialOrder α] [OrderTop α]\n    (h : ∀ c : Set α, IsChain (· ≤ ·) c → c.Nonempty → ⊤ ∉ c → ∃ x ≠ ⊤, x ∈ upperBounds c) :\n    IsCoatomic α := by\n  refine ⟨fun x => le_top.eq_or_lt.imp_right fun hx => ?_⟩\n  have := zorn_le_nonempty₀ (Ico x ⊤) (fun c hxc hc y hy => ?_) x (left_mem_Ico.2 hx)\n  · obtain ⟨y, hxy, hmax⟩ := this\n    refine ⟨y, ⟨hmax.prop.2.ne, fun z hyz ↦ le_top.eq_or_lt.resolve_right fun hz => ?_⟩, hxy⟩\n    exact hyz.ne <| hmax.eq_of_le ⟨hxy.trans hyz.le, hz⟩ hyz.le\n  rcases h c hc ⟨y, hy⟩ fun h => (hxc h).2.ne rfl with ⟨z, hz, hcz⟩\n  exact ⟨z, ⟨le_trans (hxc hy).1 (hcz hy), hz.lt_top⟩, hcz⟩\n\n"}
{"name":"IsAtomic.of_isChain_bounded","module":"Mathlib.Order.ZornAtoms","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\nh : ∀ (c : Set α), IsChain (fun x1 x2 => LE.le x1 x2) c → c.Nonempty → Not (Membership.mem c Bot.bot) → Exists fun x => And (Ne x Bot.bot) (Membership.mem (lowerBounds c) x)\n⊢ IsAtomic α","decl":"/-- **Zorn's lemma**: A partial order is atomic if every nonempty chain `c`, `⊥ ∉ c`, has a lower\nbound not equal to `⊥`. -/\ntheorem IsAtomic.of_isChain_bounded {α : Type*} [PartialOrder α] [OrderBot α]\n    (h :\n      ∀ c : Set α,\n        IsChain (· ≤ ·) c → c.Nonempty → ⊥ ∉ c → ∃ x ≠ ⊥, x ∈ lowerBounds c) :\n    IsAtomic α :=\n  isCoatomic_dual_iff_isAtomic.mp <| IsCoatomic.of_isChain_bounded fun c hc => h c hc.symm\n"}
