{"name":"mulIndicator_eventuallyEq","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nM : Type u_3\ninst‚úù : One M\ns t : Set Œ±\nf g : Œ± ‚Üí M\nl : Filter Œ±\nhf : (Min.min l (Filter.principal s)).EventuallyEq f g\nhs : l.EventuallyEq s t\n‚ä¢ l.EventuallyEq (s.mulIndicator f) (t.mulIndicator g)","decl":"@[to_additive]\ntheorem mulIndicator_eventuallyEq (hf : f =·∂†[l ‚äì ùìü s] g) (hs : s =·∂†[l] t) :\n    mulIndicator s f =·∂†[l] mulIndicator t g :=\n  (eventually_inf_principal.1 hf).mp <| hs.mem_iff.mono fun x hst hfg =>\n    by_cases\n      (fun hxs : x ‚àà s => by simp only [*, hst.1 hxs, mulIndicator_of_mem])\n      (fun hxs => by simp only [mulIndicator_of_not_mem, hxs, mt hst.2 hxs, not_false_eq_true])\n\n"}
{"name":"indicator_eventuallyEq","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nM : Type u_3\ninst‚úù : Zero M\ns t : Set Œ±\nf g : Œ± ‚Üí M\nl : Filter Œ±\nhf : (Min.min l (Filter.principal s)).EventuallyEq f g\nhs : l.EventuallyEq s t\n‚ä¢ l.EventuallyEq (s.indicator f) (t.indicator g)","decl":"@[to_additive]\ntheorem mulIndicator_eventuallyEq (hf : f =·∂†[l ‚äì ùìü s] g) (hs : s =·∂†[l] t) :\n    mulIndicator s f =·∂†[l] mulIndicator t g :=\n  (eventually_inf_principal.1 hf).mp <| hs.mem_iff.mono fun x hst hfg =>\n    by_cases\n      (fun hxs : x ‚àà s => by simp only [*, hst.1 hxs, mulIndicator_of_mem])\n      (fun hxs => by simp only [mulIndicator_of_not_mem, hxs, mt hst.2 hxs, not_false_eq_true])\n\n"}
{"name":"indicator_union_eventuallyEq","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nM : Type u_3\ninst‚úù : AddMonoid M\ns t : Set Œ±\nf : Œ± ‚Üí M\nl : Filter Œ±\nh : Filter.Eventually (fun a => Not (Membership.mem (Inter.inter s t) a)) l\n‚ä¢ l.EventuallyEq ((Union.union s t).indicator f) (HAdd.hAdd (s.indicator f) (t.indicator f))","decl":"@[to_additive]\ntheorem mulIndicator_union_eventuallyEq (h : ‚àÄ·∂† a in l, a ‚àâ s ‚à© t) :\n    mulIndicator (s ‚à™ t) f =·∂†[l] mulIndicator s f * mulIndicator t f :=\n  h.mono fun _a ha => mulIndicator_union_of_not_mem_inter ha _\n\n"}
{"name":"mulIndicator_union_eventuallyEq","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nM : Type u_3\ninst‚úù : Monoid M\ns t : Set Œ±\nf : Œ± ‚Üí M\nl : Filter Œ±\nh : Filter.Eventually (fun a => Not (Membership.mem (Inter.inter s t) a)) l\n‚ä¢ l.EventuallyEq ((Union.union s t).mulIndicator f) (HMul.hMul (s.mulIndicator f) (t.mulIndicator f))","decl":"@[to_additive]\ntheorem mulIndicator_union_eventuallyEq (h : ‚àÄ·∂† a in l, a ‚àâ s ‚à© t) :\n    mulIndicator (s ‚à™ t) f =·∂†[l] mulIndicator s f * mulIndicator t f :=\n  h.mono fun _a ha => mulIndicator_union_of_not_mem_inter ha _\n\n"}
{"name":"indicator_eventuallyLE_indicator","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : Zero Œ≤\ninst‚úù : Preorder Œ≤\ns : Set Œ±\nf g : Œ± ‚Üí Œ≤\nl : Filter Œ±\nh : (Min.min l (Filter.principal s)).EventuallyLE f g\n‚ä¢ l.EventuallyLE (s.indicator f) (s.indicator g)","decl":"@[to_additive]\ntheorem mulIndicator_eventuallyLE_mulIndicator (h : f ‚â§·∂†[l ‚äì ùìü s] g) :\n    mulIndicator s f ‚â§·∂†[l] mulIndicator s g :=\n  (eventually_inf_principal.1 h).mono fun _ => mulIndicator_rel_mulIndicator le_rfl\n\n"}
{"name":"mulIndicator_eventuallyLE_mulIndicator","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : One Œ≤\ninst‚úù : Preorder Œ≤\ns : Set Œ±\nf g : Œ± ‚Üí Œ≤\nl : Filter Œ±\nh : (Min.min l (Filter.principal s)).EventuallyLE f g\n‚ä¢ l.EventuallyLE (s.mulIndicator f) (s.mulIndicator g)","decl":"@[to_additive]\ntheorem mulIndicator_eventuallyLE_mulIndicator (h : f ‚â§·∂†[l ‚äì ùìü s] g) :\n    mulIndicator s f ‚â§·∂†[l] mulIndicator s g :=\n  (eventually_inf_principal.1 h).mono fun _ => mulIndicator_rel_mulIndicator le_rfl\n\n"}
{"name":"Monotone.mulIndicator_eventuallyEq_iUnion","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_5\ninst‚úù¬π : Preorder Œπ\ninst‚úù : One Œ≤\ns : Œπ ‚Üí Set Œ±\nhs : Monotone s\nf : Œ± ‚Üí Œ≤\na : Œ±\n‚ä¢ Filter.atTop.EventuallyEq (fun i => (s i).mulIndicator f a) fun x => (Set.iUnion fun i => s i).mulIndicator f a","decl":"@[to_additive]\ntheorem Monotone.mulIndicator_eventuallyEq_iUnion {Œπ} [Preorder Œπ] [One Œ≤] (s : Œπ ‚Üí Set Œ±)\n    (hs : Monotone s) (f : Œ± ‚Üí Œ≤) (a : Œ±) :\n    (fun i => mulIndicator (s i) f a) =·∂†[atTop] fun _ ‚Ü¶ mulIndicator (‚ãÉ i, s i) f a := by\n  classical exact hs.piecewise_eventually_eq_iUnion f 1 a\n\n"}
{"name":"Monotone.indicator_eventuallyEq_iUnion","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_5\ninst‚úù¬π : Preorder Œπ\ninst‚úù : Zero Œ≤\ns : Œπ ‚Üí Set Œ±\nhs : Monotone s\nf : Œ± ‚Üí Œ≤\na : Œ±\n‚ä¢ Filter.atTop.EventuallyEq (fun i => (s i).indicator f a) fun x => (Set.iUnion fun i => s i).indicator f a","decl":"@[to_additive]\ntheorem Monotone.mulIndicator_eventuallyEq_iUnion {Œπ} [Preorder Œπ] [One Œ≤] (s : Œπ ‚Üí Set Œ±)\n    (hs : Monotone s) (f : Œ± ‚Üí Œ≤) (a : Œ±) :\n    (fun i => mulIndicator (s i) f a) =·∂†[atTop] fun _ ‚Ü¶ mulIndicator (‚ãÉ i, s i) f a := by\n  classical exact hs.piecewise_eventually_eq_iUnion f 1 a\n\n"}
{"name":"Monotone.tendsto_mulIndicator","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_5\ninst‚úù¬π : Preorder Œπ\ninst‚úù : One Œ≤\ns : Œπ ‚Üí Set Œ±\nhs : Monotone s\nf : Œ± ‚Üí Œ≤\na : Œ±\n‚ä¢ Filter.Tendsto (fun i => (s i).mulIndicator f a) Filter.atTop (Pure.pure ((Set.iUnion fun i => s i).mulIndicator f a))","decl":"@[to_additive]\ntheorem Monotone.tendsto_mulIndicator {Œπ} [Preorder Œπ] [One Œ≤] (s : Œπ ‚Üí Set Œ±) (hs : Monotone s)\n    (f : Œ± ‚Üí Œ≤) (a : Œ±) :\n    Tendsto (fun i => mulIndicator (s i) f a) atTop (pure <| mulIndicator (‚ãÉ i, s i) f a) :=\n  tendsto_pure.2 <| hs.mulIndicator_eventuallyEq_iUnion s f a\n\n"}
{"name":"Monotone.tendsto_indicator","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_5\ninst‚úù¬π : Preorder Œπ\ninst‚úù : Zero Œ≤\ns : Œπ ‚Üí Set Œ±\nhs : Monotone s\nf : Œ± ‚Üí Œ≤\na : Œ±\n‚ä¢ Filter.Tendsto (fun i => (s i).indicator f a) Filter.atTop (Pure.pure ((Set.iUnion fun i => s i).indicator f a))","decl":"@[to_additive]\ntheorem Monotone.tendsto_mulIndicator {Œπ} [Preorder Œπ] [One Œ≤] (s : Œπ ‚Üí Set Œ±) (hs : Monotone s)\n    (f : Œ± ‚Üí Œ≤) (a : Œ±) :\n    Tendsto (fun i => mulIndicator (s i) f a) atTop (pure <| mulIndicator (‚ãÉ i, s i) f a) :=\n  tendsto_pure.2 <| hs.mulIndicator_eventuallyEq_iUnion s f a\n\n"}
{"name":"Antitone.mulIndicator_eventuallyEq_iInter","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_5\ninst‚úù¬π : Preorder Œπ\ninst‚úù : One Œ≤\ns : Œπ ‚Üí Set Œ±\nhs : Antitone s\nf : Œ± ‚Üí Œ≤\na : Œ±\n‚ä¢ Filter.atTop.EventuallyEq (fun i => (s i).mulIndicator f a) fun x => (Set.iInter fun i => s i).mulIndicator f a","decl":"@[to_additive]\ntheorem Antitone.mulIndicator_eventuallyEq_iInter {Œπ} [Preorder Œπ] [One Œ≤] (s : Œπ ‚Üí Set Œ±)\n    (hs : Antitone s) (f : Œ± ‚Üí Œ≤) (a : Œ±) :\n    (fun i => mulIndicator (s i) f a) =·∂†[atTop] fun _ ‚Ü¶ mulIndicator (‚ãÇ i, s i) f a := by\n  classical exact hs.piecewise_eventually_eq_iInter f 1 a\n\n"}
{"name":"Antitone.indicator_eventuallyEq_iInter","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_5\ninst‚úù¬π : Preorder Œπ\ninst‚úù : Zero Œ≤\ns : Œπ ‚Üí Set Œ±\nhs : Antitone s\nf : Œ± ‚Üí Œ≤\na : Œ±\n‚ä¢ Filter.atTop.EventuallyEq (fun i => (s i).indicator f a) fun x => (Set.iInter fun i => s i).indicator f a","decl":"@[to_additive]\ntheorem Antitone.mulIndicator_eventuallyEq_iInter {Œπ} [Preorder Œπ] [One Œ≤] (s : Œπ ‚Üí Set Œ±)\n    (hs : Antitone s) (f : Œ± ‚Üí Œ≤) (a : Œ±) :\n    (fun i => mulIndicator (s i) f a) =·∂†[atTop] fun _ ‚Ü¶ mulIndicator (‚ãÇ i, s i) f a := by\n  classical exact hs.piecewise_eventually_eq_iInter f 1 a\n\n"}
{"name":"Antitone.tendsto_indicator","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_5\ninst‚úù¬π : Preorder Œπ\ninst‚úù : Zero Œ≤\ns : Œπ ‚Üí Set Œ±\nhs : Antitone s\nf : Œ± ‚Üí Œ≤\na : Œ±\n‚ä¢ Filter.Tendsto (fun i => (s i).indicator f a) Filter.atTop (Pure.pure ((Set.iInter fun i => s i).indicator f a))","decl":"@[to_additive]\ntheorem Antitone.tendsto_mulIndicator {Œπ} [Preorder Œπ] [One Œ≤] (s : Œπ ‚Üí Set Œ±) (hs : Antitone s)\n    (f : Œ± ‚Üí Œ≤) (a : Œ±) :\n    Tendsto (fun i => mulIndicator (s i) f a) atTop (pure <| mulIndicator (‚ãÇ i, s i) f a) :=\n  tendsto_pure.2 <| hs.mulIndicator_eventuallyEq_iInter s f a\n\n"}
{"name":"Antitone.tendsto_mulIndicator","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_5\ninst‚úù¬π : Preorder Œπ\ninst‚úù : One Œ≤\ns : Œπ ‚Üí Set Œ±\nhs : Antitone s\nf : Œ± ‚Üí Œ≤\na : Œ±\n‚ä¢ Filter.Tendsto (fun i => (s i).mulIndicator f a) Filter.atTop (Pure.pure ((Set.iInter fun i => s i).mulIndicator f a))","decl":"@[to_additive]\ntheorem Antitone.tendsto_mulIndicator {Œπ} [Preorder Œπ] [One Œ≤] (s : Œπ ‚Üí Set Œ±) (hs : Antitone s)\n    (f : Œ± ‚Üí Œ≤) (a : Œ±) :\n    Tendsto (fun i => mulIndicator (s i) f a) atTop (pure <| mulIndicator (‚ãÇ i, s i) f a) :=\n  tendsto_pure.2 <| hs.mulIndicator_eventuallyEq_iInter s f a\n\n"}
{"name":"indicator_biUnion_finset_eventuallyEq","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_5\ninst‚úù : Zero Œ≤\ns : Œπ ‚Üí Set Œ±\nf : Œ± ‚Üí Œ≤\na : Œ±\n‚ä¢ Filter.atTop.EventuallyEq (fun n => (Set.iUnion fun i => Set.iUnion fun h => s i).indicator f a) fun x => (Set.iUnion s).indicator f a","decl":"@[to_additive]\ntheorem mulIndicator_biUnion_finset_eventuallyEq {Œπ} [One Œ≤] (s : Œπ ‚Üí Set Œ±) (f : Œ± ‚Üí Œ≤) (a : Œ±) :\n    (fun n : Finset Œπ => mulIndicator (‚ãÉ i ‚àà n, s i) f a) =·∂†[atTop]\n      fun _ ‚Ü¶ mulIndicator (iUnion s) f a := by\n  rw [iUnion_eq_iUnion_finset s]\n  apply Monotone.mulIndicator_eventuallyEq_iUnion\n  exact fun _ _ ‚Ü¶ biUnion_subset_biUnion_left\n\n"}
{"name":"mulIndicator_biUnion_finset_eventuallyEq","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_5\ninst‚úù : One Œ≤\ns : Œπ ‚Üí Set Œ±\nf : Œ± ‚Üí Œ≤\na : Œ±\n‚ä¢ Filter.atTop.EventuallyEq (fun n => (Set.iUnion fun i => Set.iUnion fun h => s i).mulIndicator f a) fun x => (Set.iUnion s).mulIndicator f a","decl":"@[to_additive]\ntheorem mulIndicator_biUnion_finset_eventuallyEq {Œπ} [One Œ≤] (s : Œπ ‚Üí Set Œ±) (f : Œ± ‚Üí Œ≤) (a : Œ±) :\n    (fun n : Finset Œπ => mulIndicator (‚ãÉ i ‚àà n, s i) f a) =·∂†[atTop]\n      fun _ ‚Ü¶ mulIndicator (iUnion s) f a := by\n  rw [iUnion_eq_iUnion_finset s]\n  apply Monotone.mulIndicator_eventuallyEq_iUnion\n  exact fun _ _ ‚Ü¶ biUnion_subset_biUnion_left\n\n"}
{"name":"tendsto_indicator_biUnion_finset","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_5\ninst‚úù : Zero Œ≤\ns : Œπ ‚Üí Set Œ±\nf : Œ± ‚Üí Œ≤\na : Œ±\n‚ä¢ Filter.Tendsto (fun n => (Set.iUnion fun i => Set.iUnion fun h => s i).indicator f a) Filter.atTop (Pure.pure ((Set.iUnion s).indicator f a))","decl":"@[to_additive]\ntheorem tendsto_mulIndicator_biUnion_finset {Œπ} [One Œ≤] (s : Œπ ‚Üí Set Œ±) (f : Œ± ‚Üí Œ≤) (a : Œ±) :\n    Tendsto (fun n : Finset Œπ => mulIndicator (‚ãÉ i ‚àà n, s i) f a) atTop\n      (pure <| mulIndicator (iUnion s) f a) :=\n  tendsto_pure.2 <| mulIndicator_biUnion_finset_eventuallyEq s f a\n\n"}
{"name":"tendsto_mulIndicator_biUnion_finset","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_5\ninst‚úù : One Œ≤\ns : Œπ ‚Üí Set Œ±\nf : Œ± ‚Üí Œ≤\na : Œ±\n‚ä¢ Filter.Tendsto (fun n => (Set.iUnion fun i => Set.iUnion fun h => s i).mulIndicator f a) Filter.atTop (Pure.pure ((Set.iUnion s).mulIndicator f a))","decl":"@[to_additive]\ntheorem tendsto_mulIndicator_biUnion_finset {Œπ} [One Œ≤] (s : Œπ ‚Üí Set Œ±) (f : Œ± ‚Üí Œ≤) (a : Œ±) :\n    Tendsto (fun n : Finset Œπ => mulIndicator (‚ãÉ i ‚àà n, s i) f a) atTop\n      (pure <| mulIndicator (iUnion s) f a) :=\n  tendsto_pure.2 <| mulIndicator_biUnion_finset_eventuallyEq s f a\n\n"}
{"name":"Filter.EventuallyEq.mulSupport","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : One Œ≤\nf g : Œ± ‚Üí Œ≤\nl : Filter Œ±\nh : l.EventuallyEq f g\n‚ä¢ l.EventuallyEq (Function.mulSupport f) (Function.mulSupport g)","decl":"@[to_additive]\nprotected theorem Filter.EventuallyEq.mulSupport [One Œ≤] {f g : Œ± ‚Üí Œ≤} {l : Filter Œ±}\n    (h : f =·∂†[l] g) :\n    Function.mulSupport f =·∂†[l] Function.mulSupport g :=\n  h.preimage ({1}·∂ú : Set Œ≤)\n\n"}
{"name":"Filter.EventuallyEq.support","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : Zero Œ≤\nf g : Œ± ‚Üí Œ≤\nl : Filter Œ±\nh : l.EventuallyEq f g\n‚ä¢ l.EventuallyEq (Function.support f) (Function.support g)","decl":"@[to_additive]\nprotected theorem Filter.EventuallyEq.mulSupport [One Œ≤] {f g : Œ± ‚Üí Œ≤} {l : Filter Œ±}\n    (h : f =·∂†[l] g) :\n    Function.mulSupport f =·∂†[l] Function.mulSupport g :=\n  h.preimage ({1}·∂ú : Set Œ≤)\n\n"}
{"name":"Filter.EventuallyEq.indicator","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : Zero Œ≤\nl : Filter Œ±\nf g : Œ± ‚Üí Œ≤\ns : Set Œ±\nhfg : l.EventuallyEq f g\n‚ä¢ l.EventuallyEq (s.indicator f) (s.indicator g)","decl":"@[to_additive]\nprotected theorem Filter.EventuallyEq.mulIndicator [One Œ≤] {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} {s : Set Œ±}\n    (hfg : f =·∂†[l] g) : s.mulIndicator f =·∂†[l] s.mulIndicator g :=\n  mulIndicator_eventuallyEq (hfg.filter_mono inf_le_left) EventuallyEq.rfl\n\n"}
{"name":"Filter.EventuallyEq.mulIndicator","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : One Œ≤\nl : Filter Œ±\nf g : Œ± ‚Üí Œ≤\ns : Set Œ±\nhfg : l.EventuallyEq f g\n‚ä¢ l.EventuallyEq (s.mulIndicator f) (s.mulIndicator g)","decl":"@[to_additive]\nprotected theorem Filter.EventuallyEq.mulIndicator [One Œ≤] {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} {s : Set Œ±}\n    (hfg : f =·∂†[l] g) : s.mulIndicator f =·∂†[l] s.mulIndicator g :=\n  mulIndicator_eventuallyEq (hfg.filter_mono inf_le_left) EventuallyEq.rfl\n\n"}
{"name":"Filter.EventuallyEq.indicator_zero","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : Zero Œ≤\nl : Filter Œ±\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nhf : l.EventuallyEq f 0\n‚ä¢ l.EventuallyEq (s.indicator f) 0","decl":"@[to_additive]\ntheorem Filter.EventuallyEq.mulIndicator_one [One Œ≤] {l : Filter Œ±} {f : Œ± ‚Üí Œ≤} {s : Set Œ±}\n    (hf : f =·∂†[l] 1) : s.mulIndicator f =·∂†[l] 1 :=\n  hf.mulIndicator.trans <| by rw [mulIndicator_one']\n\n"}
{"name":"Filter.EventuallyEq.mulIndicator_one","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : One Œ≤\nl : Filter Œ±\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nhf : l.EventuallyEq f 1\n‚ä¢ l.EventuallyEq (s.mulIndicator f) 1","decl":"@[to_additive]\ntheorem Filter.EventuallyEq.mulIndicator_one [One Œ≤] {l : Filter Œ±} {f : Œ± ‚Üí Œ≤} {s : Set Œ±}\n    (hf : f =·∂†[l] 1) : s.mulIndicator f =·∂†[l] 1 :=\n  hf.mulIndicator.trans <| by rw [mulIndicator_one']\n\n"}
{"name":"Filter.EventuallyEq.of_indicator","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : Zero Œ≤\nl : Filter Œ±\nf : Œ± ‚Üí Œ≤\nhf : Filter.Eventually (fun x => Ne (f x) 0) l\ns t : Set Œ±\nh : l.EventuallyEq (s.indicator f) (t.indicator f)\n‚ä¢ l.EventuallyEq s t","decl":"@[to_additive]\ntheorem Filter.EventuallyEq.of_mulIndicator [One Œ≤] {l : Filter Œ±} {f : Œ± ‚Üí Œ≤}\n    (hf : ‚àÄ·∂† x in l, f x ‚â† 1) {s t : Set Œ±} (h : s.mulIndicator f =·∂†[l] t.mulIndicator f) :\n    s =·∂†[l] t := by\n  have : ‚àÄ {s : Set Œ±}, Function.mulSupport (s.mulIndicator f) =·∂†[l] s := fun {s} ‚Ü¶ by\n    rw [mulSupport_mulIndicator]\n    exact (hf.mono fun x hx ‚Ü¶ and_iff_left hx).set_eq\n  exact this.symm.trans <| h.mulSupport.trans this\n\n"}
{"name":"Filter.EventuallyEq.of_mulIndicator","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : One Œ≤\nl : Filter Œ±\nf : Œ± ‚Üí Œ≤\nhf : Filter.Eventually (fun x => Ne (f x) 1) l\ns t : Set Œ±\nh : l.EventuallyEq (s.mulIndicator f) (t.mulIndicator f)\n‚ä¢ l.EventuallyEq s t","decl":"@[to_additive]\ntheorem Filter.EventuallyEq.of_mulIndicator [One Œ≤] {l : Filter Œ±} {f : Œ± ‚Üí Œ≤}\n    (hf : ‚àÄ·∂† x in l, f x ‚â† 1) {s t : Set Œ±} (h : s.mulIndicator f =·∂†[l] t.mulIndicator f) :\n    s =·∂†[l] t := by\n  have : ‚àÄ {s : Set Œ±}, Function.mulSupport (s.mulIndicator f) =·∂†[l] s := fun {s} ‚Ü¶ by\n    rw [mulSupport_mulIndicator]\n    exact (hf.mono fun x hx ‚Ü¶ and_iff_left hx).set_eq\n  exact this.symm.trans <| h.mulSupport.trans this\n\n"}
{"name":"Filter.EventuallyEq.of_mulIndicator_const","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : One Œ≤\nl : Filter Œ±\nc : Œ≤\nhc : Ne c 1\ns t : Set Œ±\nh : l.EventuallyEq (s.mulIndicator fun x => c) (t.mulIndicator fun x => c)\n‚ä¢ l.EventuallyEq s t","decl":"@[to_additive]\ntheorem Filter.EventuallyEq.of_mulIndicator_const [One Œ≤] {l : Filter Œ±} {c : Œ≤} (hc : c ‚â† 1)\n    {s t : Set Œ±} (h : s.mulIndicator (fun _ ‚Ü¶ c) =·∂†[l] t.mulIndicator fun _ ‚Ü¶ c) : s =·∂†[l] t :=\n  .of_mulIndicator (Eventually.of_forall fun _ ‚Ü¶ hc) h\n\n"}
{"name":"Filter.EventuallyEq.of_indicator_const","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : Zero Œ≤\nl : Filter Œ±\nc : Œ≤\nhc : Ne c 0\ns t : Set Œ±\nh : l.EventuallyEq (s.indicator fun x => c) (t.indicator fun x => c)\n‚ä¢ l.EventuallyEq s t","decl":"@[to_additive]\ntheorem Filter.EventuallyEq.of_mulIndicator_const [One Œ≤] {l : Filter Œ±} {c : Œ≤} (hc : c ‚â† 1)\n    {s t : Set Œ±} (h : s.mulIndicator (fun _ ‚Ü¶ c) =·∂†[l] t.mulIndicator fun _ ‚Ü¶ c) : s =·∂†[l] t :=\n  .of_mulIndicator (Eventually.of_forall fun _ ‚Ü¶ hc) h\n\n"}
{"name":"Filter.indicator_const_eventuallyEq","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : Zero Œ≤\nl : Filter Œ±\nc : Œ≤\nhc : Ne c 0\ns t : Set Œ±\n‚ä¢ Iff (l.EventuallyEq (s.indicator fun x => c) (t.indicator fun x => c)) (l.EventuallyEq s t)","decl":"@[to_additive]\ntheorem Filter.mulIndicator_const_eventuallyEq [One Œ≤] {l : Filter Œ±} {c : Œ≤} (hc : c ‚â† 1)\n    {s t : Set Œ±} : s.mulIndicator (fun _ ‚Ü¶ c) =·∂†[l] t.mulIndicator (fun _ ‚Ü¶ c) ‚Üî s =·∂†[l] t :=\n  ‚ü®.of_mulIndicator_const hc, mulIndicator_eventuallyEq .rfl‚ü©\n"}
{"name":"Filter.mulIndicator_const_eventuallyEq","module":"Mathlib.Order.Filter.IndicatorFunction","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : One Œ≤\nl : Filter Œ±\nc : Œ≤\nhc : Ne c 1\ns t : Set Œ±\n‚ä¢ Iff (l.EventuallyEq (s.mulIndicator fun x => c) (t.mulIndicator fun x => c)) (l.EventuallyEq s t)","decl":"@[to_additive]\ntheorem Filter.mulIndicator_const_eventuallyEq [One Œ≤] {l : Filter Œ±} {c : Œ≤} (hc : c ‚â† 1)\n    {s t : Set Œ±} : s.mulIndicator (fun _ ‚Ü¶ c) =·∂†[l] t.mulIndicator (fun _ ‚Ü¶ c) ‚Üî s =·∂†[l] t :=\n  ‚ü®.of_mulIndicator_const hc, mulIndicator_eventuallyEq .rfl‚ü©\n"}
