{"name":"MeasureTheory.Measure.IsOpenPosMeasure.open_pos","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nself : Œº.IsOpenPosMeasure\nU : Set X\na‚úù¬π : IsOpen U\na‚úù : U.Nonempty\n‚ä¢ Ne (Œº U) 0","decl":"/-- A measure is said to be `IsOpenPosMeasure` if it is positive on nonempty open sets. -/\nclass IsOpenPosMeasure : Prop where\n  open_pos : ‚àÄ U : Set X, IsOpen U ‚Üí U.Nonempty ‚Üí Œº U ‚â† 0\n\n"}
{"name":"IsOpen.measure_ne_zero","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\nU : Set X\nhU : IsOpen U\nhne : U.Nonempty\n‚ä¢ Ne (Œº U) 0","decl":"theorem _root_.IsOpen.measure_ne_zero (hU : IsOpen U) (hne : U.Nonempty) : Œº U ‚â† 0 :=\n  IsOpenPosMeasure.open_pos U hU hne\n\n"}
{"name":"IsOpen.measure_pos","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\nU : Set X\nhU : IsOpen U\nhne : U.Nonempty\n‚ä¢ LT.lt 0 (Œº U)","decl":"theorem _root_.IsOpen.measure_pos (hU : IsOpen U) (hne : U.Nonempty) : 0 < Œº U :=\n  (hU.measure_ne_zero Œº hne).bot_lt\n\n"}
{"name":"MeasureTheory.Measure.instNeZeroOfNonempty","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù¬π : Œº.IsOpenPosMeasure\ninst‚úù : Nonempty X\n‚ä¢ NeZero Œº","decl":"instance (priority := 100) [Nonempty X] : NeZero Œº :=\n  ‚ü®measure_univ_pos.mp <| isOpen_univ.measure_pos Œº univ_nonempty‚ü©\n\n"}
{"name":"IsOpen.measure_pos_iff","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\nU : Set X\nhU : IsOpen U\n‚ä¢ Iff (LT.lt 0 (Œº U)) U.Nonempty","decl":"theorem _root_.IsOpen.measure_pos_iff (hU : IsOpen U) : 0 < Œº U ‚Üî U.Nonempty :=\n  ‚ü®fun h => nonempty_iff_ne_empty.2 fun he => h.ne' <| he.symm ‚ñ∏ measure_empty, hU.measure_pos Œº‚ü©\n\n"}
{"name":"IsOpen.measure_eq_zero_iff","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\nU : Set X\nhU : IsOpen U\n‚ä¢ Iff (Eq (Œº U) 0) (Eq U EmptyCollection.emptyCollection)","decl":"theorem _root_.IsOpen.measure_eq_zero_iff (hU : IsOpen U) : Œº U = 0 ‚Üî U = ‚àÖ := by\n  simpa only [not_lt, nonpos_iff_eq_zero, not_nonempty_iff_eq_empty] using\n    not_congr (hU.measure_pos_iff Œº)\n\n"}
{"name":"MeasureTheory.Measure.measure_pos_of_nonempty_interior","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\ns : Set X\nh : (interior s).Nonempty\n‚ä¢ LT.lt 0 (Œº s)","decl":"theorem measure_pos_of_nonempty_interior (h : (interior s).Nonempty) : 0 < Œº s :=\n  (isOpen_interior.measure_pos Œº h).trans_le (measure_mono interior_subset)\n\n"}
{"name":"MeasureTheory.Measure.measure_pos_of_mem_nhds","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\ns : Set X\nx : X\nh : Membership.mem (nhds x) s\n‚ä¢ LT.lt 0 (Œº s)","decl":"theorem measure_pos_of_mem_nhds (h : s ‚àà ùìù x) : 0 < Œº s :=\n  measure_pos_of_nonempty_interior _ ‚ü®x, mem_interior_iff_mem_nhds.2 h‚ü©\n\n"}
{"name":"MeasureTheory.Measure.isOpenPosMeasure_smul","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\nc : ENNReal\nh : Ne c 0\n‚ä¢ (HSMul.hSMul c Œº).IsOpenPosMeasure","decl":"theorem isOpenPosMeasure_smul {c : ‚Ñù‚â•0‚àû} (h : c ‚â† 0) : IsOpenPosMeasure (c ‚Ä¢ Œº) :=\n  ‚ü®fun _U Uo Une => mul_ne_zero h (Uo.measure_ne_zero Œº Une)‚ü©\n\n"}
{"name":"MeasureTheory.Measure.AbsolutelyContinuous.isOpenPosMeasure","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nm : MeasurableSpace X\nŒº ŒΩ : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\nh : Œº.AbsolutelyContinuous ŒΩ\n‚ä¢ ŒΩ.IsOpenPosMeasure","decl":"protected theorem AbsolutelyContinuous.isOpenPosMeasure (h : Œº ‚â™ ŒΩ) : IsOpenPosMeasure ŒΩ :=\n  ‚ü®fun _U ho hne h‚ÇÄ => ho.measure_ne_zero Œº hne (h h‚ÇÄ)‚ü©\n\n"}
{"name":"LE.le.isOpenPosMeasure","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nm : MeasurableSpace X\nŒº ŒΩ : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\nh : LE.le Œº ŒΩ\n‚ä¢ ŒΩ.IsOpenPosMeasure","decl":"theorem _root_.LE.le.isOpenPosMeasure (h : Œº ‚â§ ŒΩ) : IsOpenPosMeasure ŒΩ :=\n  h.absolutelyContinuous.isOpenPosMeasure\n\n"}
{"name":"IsOpen.measure_zero_iff_eq_empty","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\nU : Set X\nhU : IsOpen U\n‚ä¢ Iff (Eq (Œº U) 0) (Eq U EmptyCollection.emptyCollection)","decl":"theorem _root_.IsOpen.measure_zero_iff_eq_empty (hU : IsOpen U) :\n    Œº U = 0 ‚Üî U = ‚àÖ :=\n  ‚ü®fun h ‚Ü¶ (hU.measure_eq_zero_iff Œº).mp h, fun h ‚Ü¶ by simp [h]‚ü©\n\n"}
{"name":"IsOpen.ae_eq_empty_iff_eq","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\nU : Set X\nhU : IsOpen U\n‚ä¢ Iff ((MeasureTheory.ae Œº).EventuallyEq U EmptyCollection.emptyCollection) (Eq U EmptyCollection.emptyCollection)","decl":"theorem _root_.IsOpen.ae_eq_empty_iff_eq (hU : IsOpen U) :\n    U =·µê[Œº] (‚àÖ : Set X) ‚Üî U = ‚àÖ := by\n  rw [ae_eq_empty, hU.measure_zero_iff_eq_empty]\n\n"}
{"name":"IsOpen.eq_empty_of_measure_zero","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\nU : Set X\nhU : IsOpen U\nh‚ÇÄ : Eq (Œº U) 0\n‚ä¢ Eq U EmptyCollection.emptyCollection","decl":"/-- An open null set w.r.t. an `IsOpenPosMeasure` is empty. -/\ntheorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h‚ÇÄ : Œº U = 0) : U = ‚àÖ :=\n  (hU.measure_eq_zero_iff Œº).mp h‚ÇÄ\n\n"}
{"name":"IsClosed.ae_eq_univ_iff_eq","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\nF : Set X\nhF : IsClosed F\n‚ä¢ Iff ((MeasureTheory.ae Œº).EventuallyEq F Set.univ) (Eq F Set.univ)","decl":"theorem _root_.IsClosed.ae_eq_univ_iff_eq (hF : IsClosed F) :\n    F =·µê[Œº] univ ‚Üî F = univ := by\n  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ by rw [h]‚ü©\n  rwa [ae_eq_univ, hF.isOpen_compl.measure_eq_zero_iff Œº, compl_empty_iff] at h\n\n"}
{"name":"IsClosed.measure_eq_univ_iff_eq","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù¬≥ : TopologicalSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù¬≤ : Œº.IsOpenPosMeasure\nF : Set X\ninst‚úù¬π : OpensMeasurableSpace X\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhF : IsClosed F\n‚ä¢ Iff (Eq (Œº F) (Œº Set.univ)) (Eq F Set.univ)","decl":"theorem _root_.IsClosed.measure_eq_univ_iff_eq [OpensMeasurableSpace X] [IsFiniteMeasure Œº]\n    (hF : IsClosed F) :\n    Œº F = Œº univ ‚Üî F = univ := by\n  rw [‚Üê ae_eq_univ_iff_measure_eq hF.measurableSet.nullMeasurableSet, hF.ae_eq_univ_iff_eq]\n\n"}
{"name":"IsClosed.measure_eq_one_iff_eq_univ","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù¬≥ : TopologicalSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù¬≤ : Œº.IsOpenPosMeasure\nF : Set X\ninst‚úù¬π : OpensMeasurableSpace X\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\nhF : IsClosed F\n‚ä¢ Iff (Eq (Œº F) 1) (Eq F Set.univ)","decl":"theorem _root_.IsClosed.measure_eq_one_iff_eq_univ [OpensMeasurableSpace X] [IsProbabilityMeasure Œº]\n    (hF : IsClosed F) :\n    Œº F = 1 ‚Üî F = univ := by\n  rw [‚Üê measure_univ (Œº := Œº), hF.measure_eq_univ_iff_eq]\n\n"}
{"name":"MeasureTheory.Measure.interior_eq_empty_of_null","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\ns : Set X\nhs : Eq (Œº s) 0\n‚ä¢ Eq (interior s) EmptyCollection.emptyCollection","decl":"/-- A null set has empty interior. -/\ntheorem interior_eq_empty_of_null (hs : Œº s = 0) : interior s = ‚àÖ :=\n  isOpen_interior.eq_empty_of_measure_zero <| measure_mono_null interior_subset hs\n\n"}
{"name":"MeasureTheory.Measure.dense_of_ae","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\np : X ‚Üí Prop\nhp : Filter.Eventually (fun x => p x) (MeasureTheory.ae Œº)\n‚ä¢ Dense (setOf fun x => p x)","decl":"/-- A property satisfied almost everywhere is satisfied on a dense subset. -/\ntheorem dense_of_ae {p : X ‚Üí Prop} (hp : ‚àÄ·µê x ‚àÇŒº, p x) : Dense {x | p x} := by\n  rw [dense_iff_closure_eq, closure_eq_compl_interior_compl, compl_univ_iff]\n  exact Œº.interior_eq_empty_of_null hp\n\n"}
{"name":"MeasureTheory.Measure.eqOn_open_of_ae_eq","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\nm : MeasurableSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : T2Space Y\nŒº : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\nU : Set X\nf g : X ‚Üí Y\nh : (MeasureTheory.ae (Œº.restrict U)).EventuallyEq f g\nhU : IsOpen U\nhf : ContinuousOn f U\nhg : ContinuousOn g U\n‚ä¢ Set.EqOn f g U","decl":"/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem eqOn_open_of_ae_eq {f g : X ‚Üí Y} (h : f =·µê[Œº.restrict U] g) (hU : IsOpen U)\n    (hf : ContinuousOn f U) (hg : ContinuousOn g U) : EqOn f g U := by\n  replace h := ae_imp_of_ae_restrict h\n  simp only [EventuallyEq, ae_iff, Classical.not_imp] at h\n  have : IsOpen (U ‚à© { a | f a ‚â† g a }) := by\n    refine isOpen_iff_mem_nhds.mpr fun a ha => inter_mem (hU.mem_nhds ha.1) ?_\n    rcases ha with ‚ü®ha : a ‚àà U, ha' : (f a, g a) ‚àà (diagonal Y)·∂ú‚ü©\n    exact\n      (hf.continuousAt (hU.mem_nhds ha)).prod_mk_nhds (hg.continuousAt (hU.mem_nhds ha))\n        (isClosed_diagonal.isOpen_compl.mem_nhds ha')\n  replace := (this.eq_empty_of_measure_zero h).le\n  exact fun x hx => Classical.not_not.1 fun h => this ‚ü®hx, h‚ü©\n\n"}
{"name":"MeasureTheory.Measure.eq_of_ae_eq","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\nm : MeasurableSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : T2Space Y\nŒº : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\nf g : X ‚Üí Y\nh : (MeasureTheory.ae Œº).EventuallyEq f g\nhf : Continuous f\nhg : Continuous g\n‚ä¢ Eq f g","decl":"/-- If two continuous functions are a.e. equal, then they are equal. -/\ntheorem eq_of_ae_eq {f g : X ‚Üí Y} (h : f =·µê[Œº] g) (hf : Continuous f) (hg : Continuous g) : f = g :=\n  suffices EqOn f g univ from funext fun _ => this trivial\n  eqOn_open_of_ae_eq (ae_restrict_of_ae h) isOpen_univ hf.continuousOn hg.continuousOn\n\n"}
{"name":"MeasureTheory.Measure.eqOn_of_ae_eq","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\nm : MeasurableSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : T2Space Y\nŒº : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\ns : Set X\nf g : X ‚Üí Y\nh : (MeasureTheory.ae (Œº.restrict s)).EventuallyEq f g\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nhU : HasSubset.Subset s (closure (interior s))\n‚ä¢ Set.EqOn f g s","decl":"theorem eqOn_of_ae_eq {f g : X ‚Üí Y} (h : f =·µê[Œº.restrict s] g) (hf : ContinuousOn f s)\n    (hg : ContinuousOn g s) (hU : s ‚äÜ closure (interior s)) : EqOn f g s :=\n  have : interior s ‚äÜ s := interior_subset\n  (eqOn_open_of_ae_eq (ae_restrict_of_ae_restrict_of_subset this h) isOpen_interior (hf.mono this)\n        (hg.mono this)).of_subset_closure\n    hf hg this hU\n\n"}
{"name":"Continuous.ae_eq_iff_eq","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\nm : MeasurableSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : T2Space Y\nŒº : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\nf g : X ‚Üí Y\nhf : Continuous f\nhg : Continuous g\n‚ä¢ Iff ((MeasureTheory.ae Œº).EventuallyEq f g) (Eq f g)","decl":"theorem _root_.Continuous.ae_eq_iff_eq {f g : X ‚Üí Y} (hf : Continuous f) (hg : Continuous g) :\n    f =·µê[Œº] g ‚Üî f = g :=\n  ‚ü®fun h => eq_of_ae_eq h hf hg, fun h => h ‚ñ∏ EventuallyEq.rfl‚ü©\n\n"}
{"name":"Continuous.isOpenPosMeasure_map","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù‚Åµ : TopologicalSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù‚Å¥ : Œº.IsOpenPosMeasure\ninst‚úù¬≥ : OpensMeasurableSpace X\nZ : Type u_3\ninst‚úù¬≤ : TopologicalSpace Z\ninst‚úù¬π : MeasurableSpace Z\ninst‚úù : BorelSpace Z\nf : X ‚Üí Z\nhf : Continuous f\nhf_surj : Function.Surjective f\n‚ä¢ (MeasureTheory.Measure.map f Œº).IsOpenPosMeasure","decl":"theorem _root_.Continuous.isOpenPosMeasure_map [OpensMeasurableSpace X]\n    {Z : Type*} [TopologicalSpace Z] [MeasurableSpace Z] [BorelSpace Z]\n    {f : X ‚Üí Z} (hf : Continuous f) (hf_surj : Function.Surjective f) :\n    (Measure.map f Œº).IsOpenPosMeasure := by\n  refine ‚ü®fun U hUo hUne => ?_‚ü©\n  rw [Measure.map_apply hf.measurable hUo.measurableSet]\n  exact (hUo.preimage hf).measure_ne_zero Œº (hf_surj.nonempty_preimage.mpr hUne)\n\n"}
{"name":"MeasureTheory.Measure.measure_Ioi_pos","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù‚Å¥ : TopologicalSpace X\ninst‚úù¬≥ : LinearOrder X\ninst‚úù¬≤ : OrderTopology X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù¬π : Œº.IsOpenPosMeasure\ninst‚úù : NoMaxOrder X\na : X\n‚ä¢ LT.lt 0 (Œº (Set.Ioi a))","decl":"theorem measure_Ioi_pos [NoMaxOrder X] (a : X) : 0 < Œº (Ioi a) :=\n  isOpen_Ioi.measure_pos Œº nonempty_Ioi\n\n"}
{"name":"MeasureTheory.Measure.measure_Iio_pos","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù‚Å¥ : TopologicalSpace X\ninst‚úù¬≥ : LinearOrder X\ninst‚úù¬≤ : OrderTopology X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù¬π : Œº.IsOpenPosMeasure\ninst‚úù : NoMinOrder X\na : X\n‚ä¢ LT.lt 0 (Œº (Set.Iio a))","decl":"theorem measure_Iio_pos [NoMinOrder X] (a : X) : 0 < Œº (Iio a) :=\n  isOpen_Iio.measure_pos Œº nonempty_Iio\n\n"}
{"name":"MeasureTheory.Measure.measure_Ioo_pos","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù‚Å¥ : TopologicalSpace X\ninst‚úù¬≥ : LinearOrder X\ninst‚úù¬≤ : OrderTopology X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù¬π : Œº.IsOpenPosMeasure\ninst‚úù : DenselyOrdered X\na b : X\n‚ä¢ Iff (LT.lt 0 (Œº (Set.Ioo a b))) (LT.lt a b)","decl":"theorem measure_Ioo_pos [DenselyOrdered X] {a b : X} : 0 < Œº (Ioo a b) ‚Üî a < b :=\n  (isOpen_Ioo.measure_pos_iff Œº).trans nonempty_Ioo\n\n"}
{"name":"MeasureTheory.Measure.measure_Ioo_eq_zero","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù‚Å¥ : TopologicalSpace X\ninst‚úù¬≥ : LinearOrder X\ninst‚úù¬≤ : OrderTopology X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù¬π : Œº.IsOpenPosMeasure\ninst‚úù : DenselyOrdered X\na b : X\n‚ä¢ Iff (Eq (Œº (Set.Ioo a b)) 0) (LE.le b a)","decl":"theorem measure_Ioo_eq_zero [DenselyOrdered X] {a b : X} : Œº (Ioo a b) = 0 ‚Üî b ‚â§ a :=\n  (isOpen_Ioo.measure_eq_zero_iff Œº).trans (Ioo_eq_empty_iff.trans not_lt)\n\n"}
{"name":"MeasureTheory.Measure.eqOn_Ioo_of_ae_eq","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù‚Åµ : TopologicalSpace X\ninst‚úù‚Å¥ : LinearOrder X\ninst‚úù¬≥ : OrderTopology X\nm : MeasurableSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : T2Space Y\nŒº : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\na b : X\nf g : X ‚Üí Y\nhfg : (MeasureTheory.ae (Œº.restrict (Set.Ioo a b))).EventuallyEq f g\nhf : ContinuousOn f (Set.Ioo a b)\nhg : ContinuousOn g (Set.Ioo a b)\n‚ä¢ Set.EqOn f g (Set.Ioo a b)","decl":"theorem eqOn_Ioo_of_ae_eq {a b : X} {f g : X ‚Üí Y} (hfg : f =·µê[Œº.restrict (Ioo a b)] g)\n    (hf : ContinuousOn f (Ioo a b)) (hg : ContinuousOn g (Ioo a b)) : EqOn f g (Ioo a b) :=\n  eqOn_of_ae_eq hfg hf hg Ioo_subset_closure_interior\n\n"}
{"name":"MeasureTheory.Measure.eqOn_Ioc_of_ae_eq","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù‚Å∂ : TopologicalSpace X\ninst‚úù‚Åµ : LinearOrder X\ninst‚úù‚Å¥ : OrderTopology X\nm : MeasurableSpace X\ninst‚úù¬≥ : TopologicalSpace Y\ninst‚úù¬≤ : T2Space Y\nŒº : MeasureTheory.Measure X\ninst‚úù¬π : Œº.IsOpenPosMeasure\ninst‚úù : DenselyOrdered X\na b : X\nf g : X ‚Üí Y\nhfg : (MeasureTheory.ae (Œº.restrict (Set.Ioc a b))).EventuallyEq f g\nhf : ContinuousOn f (Set.Ioc a b)\nhg : ContinuousOn g (Set.Ioc a b)\n‚ä¢ Set.EqOn f g (Set.Ioc a b)","decl":"theorem eqOn_Ioc_of_ae_eq [DenselyOrdered X] {a b : X} {f g : X ‚Üí Y}\n    (hfg : f =·µê[Œº.restrict (Ioc a b)] g) (hf : ContinuousOn f (Ioc a b))\n    (hg : ContinuousOn g (Ioc a b)) : EqOn f g (Ioc a b) :=\n  eqOn_of_ae_eq hfg hf hg (Ioc_subset_closure_interior _ _)\n\n"}
{"name":"MeasureTheory.Measure.eqOn_Ico_of_ae_eq","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù‚Å∂ : TopologicalSpace X\ninst‚úù‚Åµ : LinearOrder X\ninst‚úù‚Å¥ : OrderTopology X\nm : MeasurableSpace X\ninst‚úù¬≥ : TopologicalSpace Y\ninst‚úù¬≤ : T2Space Y\nŒº : MeasureTheory.Measure X\ninst‚úù¬π : Œº.IsOpenPosMeasure\ninst‚úù : DenselyOrdered X\na b : X\nf g : X ‚Üí Y\nhfg : (MeasureTheory.ae (Œº.restrict (Set.Ico a b))).EventuallyEq f g\nhf : ContinuousOn f (Set.Ico a b)\nhg : ContinuousOn g (Set.Ico a b)\n‚ä¢ Set.EqOn f g (Set.Ico a b)","decl":"theorem eqOn_Ico_of_ae_eq [DenselyOrdered X] {a b : X} {f g : X ‚Üí Y}\n    (hfg : f =·µê[Œº.restrict (Ico a b)] g) (hf : ContinuousOn f (Ico a b))\n    (hg : ContinuousOn g (Ico a b)) : EqOn f g (Ico a b) :=\n  eqOn_of_ae_eq hfg hf hg (Ico_subset_closure_interior _ _)\n\n"}
{"name":"MeasureTheory.Measure.eqOn_Icc_of_ae_eq","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù‚Å∂ : TopologicalSpace X\ninst‚úù‚Åµ : LinearOrder X\ninst‚úù‚Å¥ : OrderTopology X\nm : MeasurableSpace X\ninst‚úù¬≥ : TopologicalSpace Y\ninst‚úù¬≤ : T2Space Y\nŒº : MeasureTheory.Measure X\ninst‚úù¬π : Œº.IsOpenPosMeasure\ninst‚úù : DenselyOrdered X\na b : X\nhne : Ne a b\nf g : X ‚Üí Y\nhfg : (MeasureTheory.ae (Œº.restrict (Set.Icc a b))).EventuallyEq f g\nhf : ContinuousOn f (Set.Icc a b)\nhg : ContinuousOn g (Set.Icc a b)\n‚ä¢ Set.EqOn f g (Set.Icc a b)","decl":"theorem eqOn_Icc_of_ae_eq [DenselyOrdered X] {a b : X} (hne : a ‚â† b) {f g : X ‚Üí Y}\n    (hfg : f =·µê[Œº.restrict (Icc a b)] g) (hf : ContinuousOn f (Icc a b))\n    (hg : ContinuousOn g (Icc a b)) : EqOn f g (Icc a b) :=\n  eqOn_of_ae_eq hfg hf hg (closure_interior_Icc hne).symm.subset\n\n"}
{"name":"Metric.measure_ball_pos","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù¬π : PseudoMetricSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\nx : X\nr : Real\nhr : LT.lt 0 r\n‚ä¢ LT.lt 0 (Œº (Metric.ball x r))","decl":"theorem measure_ball_pos (x : X) {r : ‚Ñù} (hr : 0 < r) : 0 < Œº (ball x r) :=\n  isOpen_ball.measure_pos Œº (nonempty_ball.2 hr)\n\n"}
{"name":"Metric.measure_closedBall_pos","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù¬π : PseudoMetricSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\nx : X\nr : Real\nhr : LT.lt 0 r\n‚ä¢ LT.lt 0 (Œº (Metric.closedBall x r))","decl":"/-- See also `Metric.measure_closedBall_pos_iff`. -/\ntheorem measure_closedBall_pos (x : X) {r : ‚Ñù} (hr : 0 < r) : 0 < Œº (closedBall x r) :=\n  (measure_ball_pos Œº x hr).trans_le (measure_mono ball_subset_closedBall)\n\n"}
{"name":"Metric.measure_closedBall_pos_iff","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_2\ninst‚úù¬≤ : MetricSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù¬π : Œº.IsOpenPosMeasure\ninst‚úù : MeasureTheory.NoAtoms Œº\nx : X\nr : Real\n‚ä¢ Iff (LT.lt 0 (Œº (Metric.closedBall x r))) (LT.lt 0 r)","decl":"@[simp] lemma measure_closedBall_pos_iff {X : Type*} [MetricSpace X] {m : MeasurableSpace X}\n    (Œº : Measure X) [IsOpenPosMeasure Œº] [NoAtoms Œº] {x : X} {r : ‚Ñù} :\n    0 < Œº (closedBall x r) ‚Üî 0 < r := by\n  refine ‚ü®fun h ‚Ü¶ ?_, measure_closedBall_pos Œº x‚ü©\n  contrapose! h\n  rw [(subsingleton_closedBall x h).measure_zero Œº]\n\n"}
{"name":"EMetric.measure_ball_pos","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù¬π : PseudoEMetricSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\nx : X\nr : ENNReal\nhr : Ne r 0\n‚ä¢ LT.lt 0 (Œº (EMetric.ball x r))","decl":"theorem measure_ball_pos (x : X) {r : ‚Ñù‚â•0‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=\n  isOpen_ball.measure_pos Œº ‚ü®x, mem_ball_self hr.bot_lt‚ü©\n\n"}
{"name":"EMetric.measure_closedBall_pos","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù¬π : PseudoEMetricSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\nx : X\nr : ENNReal\nhr : Ne r 0\n‚ä¢ LT.lt 0 (Œº (EMetric.closedBall x r))","decl":"theorem measure_closedBall_pos (x : X) {r : ‚Ñù‚â•0‚àû} (hr : r ‚â† 0) : 0 < Œº (closedBall x r) :=\n  (measure_ball_pos Œº x hr).trans_le (measure_mono ball_subset_closedBall)\n\n"}
{"name":"IsNowhereDense.of_isClosed_null","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : MeasurableSpace X\ns : Set X\nŒº : MeasureTheory.Measure X\ninst‚úù : Œº.IsOpenPosMeasure\nh‚ÇÅs : IsClosed s\nh‚ÇÇs : Eq (Œº s) 0\n‚ä¢ IsNowhereDense s","decl":"/-- A *closed* measure zero subset is nowhere dense. (Closedness is required: for instance, the\nrational numbers are countable (thus have measure zero), but are dense (hence not nowhere dense). -/\nlemma IsNowhereDense.of_isClosed_null (h‚ÇÅs : IsClosed s) (h‚ÇÇs : Œº s = 0) :\n    IsNowhereDense s := h‚ÇÅs.isNowhereDense_iff.mpr (interior_eq_empty_of_null h‚ÇÇs)\n\n"}
{"name":"IsMeagre.of_isSigmaCompact_null","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : MeasurableSpace X\ns : Set X\nŒº : MeasureTheory.Measure X\ninst‚úù¬π : Œº.IsOpenPosMeasure\ninst‚úù : T2Space X\nh‚ÇÅs : IsSigmaCompact s\nh‚ÇÇs : Eq (Œº s) 0\n‚ä¢ IsMeagre s","decl":"/-- A œÉ-compact measure zero subset is meagre.\n(More generally, every FœÉ set of measure zero is meagre.) -/\nlemma IsMeagre.of_isSigmaCompact_null [T2Space X] (h‚ÇÅs : IsSigmaCompact s) (h‚ÇÇs : Œº s = 0) :\n    IsMeagre s := by\n  rcases h‚ÇÅs with ‚ü®K, hcompact, hcover‚ü©\n  have h (n : ‚Ñï) : IsNowhereDense (K n) := by\n    have : Œº (K n) = 0 := measure_mono_null (hcover ‚ñ∏ subset_iUnion K n) h‚ÇÇs\n    exact .of_isClosed_null (hcompact n).isClosed this\n  rw [isMeagre_iff_countable_union_isNowhereDense]\n  exact ‚ü®range K, fun t ‚ü®n, hn‚ü© ‚Ü¶ hn ‚ñ∏ h n, countable_range K, hcover.symm.subset‚ü©\n\n"}
