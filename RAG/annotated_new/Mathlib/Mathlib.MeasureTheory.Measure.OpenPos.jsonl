{"name":"MeasureTheory.Measure.IsOpenPosMeasure.open_pos","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nself : Î¼.IsOpenPosMeasure\nU : Set X\naâœÂ¹ : IsOpen U\naâœ : U.Nonempty\nâŠ¢ Ne (Î¼ U) 0","decl":"/-- A measure is said to be `IsOpenPosMeasure` if it is positive on nonempty open sets. -/\nclass IsOpenPosMeasure : Prop where\n  open_pos : âˆ€ U : Set X, IsOpen U â†’ U.Nonempty â†’ Î¼ U â‰  0\n\n"}
{"name":"IsOpen.measure_ne_zero","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\nU : Set X\nhU : IsOpen U\nhne : U.Nonempty\nâŠ¢ Ne (Î¼ U) 0","decl":"theorem _root_.IsOpen.measure_ne_zero (hU : IsOpen U) (hne : U.Nonempty) : Î¼ U â‰  0 :=\n  IsOpenPosMeasure.open_pos U hU hne\n\n"}
{"name":"IsOpen.measure_pos","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\nU : Set X\nhU : IsOpen U\nhne : U.Nonempty\nâŠ¢ LT.lt 0 (Î¼ U)","decl":"theorem _root_.IsOpen.measure_pos (hU : IsOpen U) (hne : U.Nonempty) : 0 < Î¼ U :=\n  (hU.measure_ne_zero Î¼ hne).bot_lt\n\n"}
{"name":"MeasureTheory.Measure.instNeZeroOfNonempty","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœÂ² : TopologicalSpace X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : Î¼.IsOpenPosMeasure\ninstâœ : Nonempty X\nâŠ¢ NeZero Î¼","decl":"instance (priority := 100) [Nonempty X] : NeZero Î¼ :=\n  âŸ¨measure_univ_pos.mp <| isOpen_univ.measure_pos Î¼ univ_nonemptyâŸ©\n\n"}
{"name":"IsOpen.measure_pos_iff","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\nU : Set X\nhU : IsOpen U\nâŠ¢ Iff (LT.lt 0 (Î¼ U)) U.Nonempty","decl":"theorem _root_.IsOpen.measure_pos_iff (hU : IsOpen U) : 0 < Î¼ U â†” U.Nonempty :=\n  âŸ¨fun h => nonempty_iff_ne_empty.2 fun he => h.ne' <| he.symm â–¸ measure_empty, hU.measure_pos Î¼âŸ©\n\n"}
{"name":"IsOpen.measure_eq_zero_iff","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\nU : Set X\nhU : IsOpen U\nâŠ¢ Iff (Eq (Î¼ U) 0) (Eq U EmptyCollection.emptyCollection)","decl":"theorem _root_.IsOpen.measure_eq_zero_iff (hU : IsOpen U) : Î¼ U = 0 â†” U = âˆ… := by\n  simpa only [not_lt, nonpos_iff_eq_zero, not_nonempty_iff_eq_empty] using\n    not_congr (hU.measure_pos_iff Î¼)\n\n"}
{"name":"MeasureTheory.Measure.measure_pos_of_nonempty_interior","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\ns : Set X\nh : (interior s).Nonempty\nâŠ¢ LT.lt 0 (Î¼ s)","decl":"theorem measure_pos_of_nonempty_interior (h : (interior s).Nonempty) : 0 < Î¼ s :=\n  (isOpen_interior.measure_pos Î¼ h).trans_le (measure_mono interior_subset)\n\n"}
{"name":"MeasureTheory.Measure.measure_pos_of_mem_nhds","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\ns : Set X\nx : X\nh : Membership.mem (nhds x) s\nâŠ¢ LT.lt 0 (Î¼ s)","decl":"theorem measure_pos_of_mem_nhds (h : s âˆˆ ğ“ x) : 0 < Î¼ s :=\n  measure_pos_of_nonempty_interior _ âŸ¨x, mem_interior_iff_mem_nhds.2 hâŸ©\n\n"}
{"name":"MeasureTheory.Measure.isOpenPosMeasure_smul","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\nc : ENNReal\nh : Ne c 0\nâŠ¢ (HSMul.hSMul c Î¼).IsOpenPosMeasure","decl":"theorem isOpenPosMeasure_smul {c : â„â‰¥0âˆ} (h : c â‰  0) : IsOpenPosMeasure (c â€¢ Î¼) :=\n  âŸ¨fun _U Uo Une => mul_ne_zero h (Uo.measure_ne_zero Î¼ Une)âŸ©\n\n"}
{"name":"MeasureTheory.Measure.AbsolutelyContinuous.isOpenPosMeasure","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\nm : MeasurableSpace X\nÎ¼ Î½ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\nh : Î¼.AbsolutelyContinuous Î½\nâŠ¢ Î½.IsOpenPosMeasure","decl":"protected theorem AbsolutelyContinuous.isOpenPosMeasure (h : Î¼ â‰ª Î½) : IsOpenPosMeasure Î½ :=\n  âŸ¨fun _U ho hne hâ‚€ => ho.measure_ne_zero Î¼ hne (h hâ‚€)âŸ©\n\n"}
{"name":"LE.le.isOpenPosMeasure","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\nm : MeasurableSpace X\nÎ¼ Î½ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\nh : LE.le Î¼ Î½\nâŠ¢ Î½.IsOpenPosMeasure","decl":"theorem _root_.LE.le.isOpenPosMeasure (h : Î¼ â‰¤ Î½) : IsOpenPosMeasure Î½ :=\n  h.absolutelyContinuous.isOpenPosMeasure\n\n"}
{"name":"IsOpen.measure_zero_iff_eq_empty","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\nU : Set X\nhU : IsOpen U\nâŠ¢ Iff (Eq (Î¼ U) 0) (Eq U EmptyCollection.emptyCollection)","decl":"theorem _root_.IsOpen.measure_zero_iff_eq_empty (hU : IsOpen U) :\n    Î¼ U = 0 â†” U = âˆ… :=\n  âŸ¨fun h â†¦ (hU.measure_eq_zero_iff Î¼).mp h, fun h â†¦ by simp [h]âŸ©\n\n"}
{"name":"IsOpen.ae_eq_empty_iff_eq","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\nU : Set X\nhU : IsOpen U\nâŠ¢ Iff ((MeasureTheory.ae Î¼).EventuallyEq U EmptyCollection.emptyCollection) (Eq U EmptyCollection.emptyCollection)","decl":"theorem _root_.IsOpen.ae_eq_empty_iff_eq (hU : IsOpen U) :\n    U =áµ[Î¼] (âˆ… : Set X) â†” U = âˆ… := by\n  rw [ae_eq_empty, hU.measure_zero_iff_eq_empty]\n\n"}
{"name":"IsOpen.eq_empty_of_measure_zero","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\nU : Set X\nhU : IsOpen U\nhâ‚€ : Eq (Î¼ U) 0\nâŠ¢ Eq U EmptyCollection.emptyCollection","decl":"/-- An open null set w.r.t. an `IsOpenPosMeasure` is empty. -/\ntheorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (hâ‚€ : Î¼ U = 0) : U = âˆ… :=\n  (hU.measure_eq_zero_iff Î¼).mp hâ‚€\n\n"}
{"name":"IsClosed.ae_eq_univ_iff_eq","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\nF : Set X\nhF : IsClosed F\nâŠ¢ Iff ((MeasureTheory.ae Î¼).EventuallyEq F Set.univ) (Eq F Set.univ)","decl":"theorem _root_.IsClosed.ae_eq_univ_iff_eq (hF : IsClosed F) :\n    F =áµ[Î¼] univ â†” F = univ := by\n  refine âŸ¨fun h â†¦ ?_, fun h â†¦ by rw [h]âŸ©\n  rwa [ae_eq_univ, hF.isOpen_compl.measure_eq_zero_iff Î¼, compl_empty_iff] at h\n\n"}
{"name":"IsClosed.measure_eq_univ_iff_eq","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœÂ³ : TopologicalSpace X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ² : Î¼.IsOpenPosMeasure\nF : Set X\ninstâœÂ¹ : OpensMeasurableSpace X\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhF : IsClosed F\nâŠ¢ Iff (Eq (Î¼ F) (Î¼ Set.univ)) (Eq F Set.univ)","decl":"theorem _root_.IsClosed.measure_eq_univ_iff_eq [OpensMeasurableSpace X] [IsFiniteMeasure Î¼]\n    (hF : IsClosed F) :\n    Î¼ F = Î¼ univ â†” F = univ := by\n  rw [â† ae_eq_univ_iff_measure_eq hF.measurableSet.nullMeasurableSet, hF.ae_eq_univ_iff_eq]\n\n"}
{"name":"IsClosed.measure_eq_one_iff_eq_univ","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœÂ³ : TopologicalSpace X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ² : Î¼.IsOpenPosMeasure\nF : Set X\ninstâœÂ¹ : OpensMeasurableSpace X\ninstâœ : MeasureTheory.IsProbabilityMeasure Î¼\nhF : IsClosed F\nâŠ¢ Iff (Eq (Î¼ F) 1) (Eq F Set.univ)","decl":"theorem _root_.IsClosed.measure_eq_one_iff_eq_univ [OpensMeasurableSpace X] [IsProbabilityMeasure Î¼]\n    (hF : IsClosed F) :\n    Î¼ F = 1 â†” F = univ := by\n  rw [â† measure_univ (Î¼ := Î¼), hF.measure_eq_univ_iff_eq]\n\n"}
{"name":"MeasureTheory.Measure.interior_eq_empty_of_null","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\ns : Set X\nhs : Eq (Î¼ s) 0\nâŠ¢ Eq (interior s) EmptyCollection.emptyCollection","decl":"/-- A null set has empty interior. -/\ntheorem interior_eq_empty_of_null (hs : Î¼ s = 0) : interior s = âˆ… :=\n  isOpen_interior.eq_empty_of_measure_zero <| measure_mono_null interior_subset hs\n\n"}
{"name":"MeasureTheory.Measure.dense_of_ae","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\np : X â†’ Prop\nhp : Filter.Eventually (fun x => p x) (MeasureTheory.ae Î¼)\nâŠ¢ Dense (setOf fun x => p x)","decl":"/-- A property satisfied almost everywhere is satisfied on a dense subset. -/\ntheorem dense_of_ae {p : X â†’ Prop} (hp : âˆ€áµ x âˆ‚Î¼, p x) : Dense {x | p x} := by\n  rw [dense_iff_closure_eq, closure_eq_compl_interior_compl, compl_univ_iff]\n  exact Î¼.interior_eq_empty_of_null hp\n\n"}
{"name":"MeasureTheory.Measure.eqOn_open_of_ae_eq","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ³ : TopologicalSpace X\nm : MeasurableSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : T2Space Y\nÎ¼ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\nU : Set X\nf g : X â†’ Y\nh : (MeasureTheory.ae (Î¼.restrict U)).EventuallyEq f g\nhU : IsOpen U\nhf : ContinuousOn f U\nhg : ContinuousOn g U\nâŠ¢ Set.EqOn f g U","decl":"/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem eqOn_open_of_ae_eq {f g : X â†’ Y} (h : f =áµ[Î¼.restrict U] g) (hU : IsOpen U)\n    (hf : ContinuousOn f U) (hg : ContinuousOn g U) : EqOn f g U := by\n  replace h := ae_imp_of_ae_restrict h\n  simp only [EventuallyEq, ae_iff, Classical.not_imp] at h\n  have : IsOpen (U âˆ© { a | f a â‰  g a }) := by\n    refine isOpen_iff_mem_nhds.mpr fun a ha => inter_mem (hU.mem_nhds ha.1) ?_\n    rcases ha with âŸ¨ha : a âˆˆ U, ha' : (f a, g a) âˆˆ (diagonal Y)á¶œâŸ©\n    exact\n      (hf.continuousAt (hU.mem_nhds ha)).prod_mk_nhds (hg.continuousAt (hU.mem_nhds ha))\n        (isClosed_diagonal.isOpen_compl.mem_nhds ha')\n  replace := (this.eq_empty_of_measure_zero h).le\n  exact fun x hx => Classical.not_not.1 fun h => this âŸ¨hx, hâŸ©\n\n"}
{"name":"MeasureTheory.Measure.eq_of_ae_eq","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ³ : TopologicalSpace X\nm : MeasurableSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : T2Space Y\nÎ¼ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\nf g : X â†’ Y\nh : (MeasureTheory.ae Î¼).EventuallyEq f g\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Eq f g","decl":"/-- If two continuous functions are a.e. equal, then they are equal. -/\ntheorem eq_of_ae_eq {f g : X â†’ Y} (h : f =áµ[Î¼] g) (hf : Continuous f) (hg : Continuous g) : f = g :=\n  suffices EqOn f g univ from funext fun _ => this trivial\n  eqOn_open_of_ae_eq (ae_restrict_of_ae h) isOpen_univ hf.continuousOn hg.continuousOn\n\n"}
{"name":"MeasureTheory.Measure.eqOn_of_ae_eq","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ³ : TopologicalSpace X\nm : MeasurableSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : T2Space Y\nÎ¼ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\ns : Set X\nf g : X â†’ Y\nh : (MeasureTheory.ae (Î¼.restrict s)).EventuallyEq f g\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nhU : HasSubset.Subset s (closure (interior s))\nâŠ¢ Set.EqOn f g s","decl":"theorem eqOn_of_ae_eq {f g : X â†’ Y} (h : f =áµ[Î¼.restrict s] g) (hf : ContinuousOn f s)\n    (hg : ContinuousOn g s) (hU : s âŠ† closure (interior s)) : EqOn f g s :=\n  have : interior s âŠ† s := interior_subset\n  (eqOn_open_of_ae_eq (ae_restrict_of_ae_restrict_of_subset this h) isOpen_interior (hf.mono this)\n        (hg.mono this)).of_subset_closure\n    hf hg this hU\n\n"}
{"name":"Continuous.ae_eq_iff_eq","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ³ : TopologicalSpace X\nm : MeasurableSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : T2Space Y\nÎ¼ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\nf g : X â†’ Y\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Iff ((MeasureTheory.ae Î¼).EventuallyEq f g) (Eq f g)","decl":"theorem _root_.Continuous.ae_eq_iff_eq {f g : X â†’ Y} (hf : Continuous f) (hg : Continuous g) :\n    f =áµ[Î¼] g â†” f = g :=\n  âŸ¨fun h => eq_of_ae_eq h hf hg, fun h => h â–¸ EventuallyEq.rflâŸ©\n\n"}
{"name":"Continuous.isOpenPosMeasure_map","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœâµ : TopologicalSpace X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœâ´ : Î¼.IsOpenPosMeasure\ninstâœÂ³ : OpensMeasurableSpace X\nZ : Type u_3\ninstâœÂ² : TopologicalSpace Z\ninstâœÂ¹ : MeasurableSpace Z\ninstâœ : BorelSpace Z\nf : X â†’ Z\nhf : Continuous f\nhf_surj : Function.Surjective f\nâŠ¢ (MeasureTheory.Measure.map f Î¼).IsOpenPosMeasure","decl":"theorem _root_.Continuous.isOpenPosMeasure_map [OpensMeasurableSpace X]\n    {Z : Type*} [TopologicalSpace Z] [MeasurableSpace Z] [BorelSpace Z]\n    {f : X â†’ Z} (hf : Continuous f) (hf_surj : Function.Surjective f) :\n    (Measure.map f Î¼).IsOpenPosMeasure := by\n  refine âŸ¨fun U hUo hUne => ?_âŸ©\n  rw [Measure.map_apply hf.measurable hUo.measurableSet]\n  exact (hUo.preimage hf).measure_ne_zero Î¼ (hf_surj.nonempty_preimage.mpr hUne)\n\n"}
{"name":"MeasureTheory.Measure.measure_Ioi_pos","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : LinearOrder X\ninstâœÂ² : OrderTopology X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : Î¼.IsOpenPosMeasure\ninstâœ : NoMaxOrder X\na : X\nâŠ¢ LT.lt 0 (Î¼ (Set.Ioi a))","decl":"theorem measure_Ioi_pos [NoMaxOrder X] (a : X) : 0 < Î¼ (Ioi a) :=\n  isOpen_Ioi.measure_pos Î¼ nonempty_Ioi\n\n"}
{"name":"MeasureTheory.Measure.measure_Iio_pos","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : LinearOrder X\ninstâœÂ² : OrderTopology X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : Î¼.IsOpenPosMeasure\ninstâœ : NoMinOrder X\na : X\nâŠ¢ LT.lt 0 (Î¼ (Set.Iio a))","decl":"theorem measure_Iio_pos [NoMinOrder X] (a : X) : 0 < Î¼ (Iio a) :=\n  isOpen_Iio.measure_pos Î¼ nonempty_Iio\n\n"}
{"name":"MeasureTheory.Measure.measure_Ioo_pos","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : LinearOrder X\ninstâœÂ² : OrderTopology X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : Î¼.IsOpenPosMeasure\ninstâœ : DenselyOrdered X\na b : X\nâŠ¢ Iff (LT.lt 0 (Î¼ (Set.Ioo a b))) (LT.lt a b)","decl":"theorem measure_Ioo_pos [DenselyOrdered X] {a b : X} : 0 < Î¼ (Ioo a b) â†” a < b :=\n  (isOpen_Ioo.measure_pos_iff Î¼).trans nonempty_Ioo\n\n"}
{"name":"MeasureTheory.Measure.measure_Ioo_eq_zero","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : LinearOrder X\ninstâœÂ² : OrderTopology X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : Î¼.IsOpenPosMeasure\ninstâœ : DenselyOrdered X\na b : X\nâŠ¢ Iff (Eq (Î¼ (Set.Ioo a b)) 0) (LE.le b a)","decl":"theorem measure_Ioo_eq_zero [DenselyOrdered X] {a b : X} : Î¼ (Ioo a b) = 0 â†” b â‰¤ a :=\n  (isOpen_Ioo.measure_eq_zero_iff Î¼).trans (Ioo_eq_empty_iff.trans not_lt)\n\n"}
{"name":"MeasureTheory.Measure.eqOn_Ioo_of_ae_eq","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœâµ : TopologicalSpace X\ninstâœâ´ : LinearOrder X\ninstâœÂ³ : OrderTopology X\nm : MeasurableSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : T2Space Y\nÎ¼ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\na b : X\nf g : X â†’ Y\nhfg : (MeasureTheory.ae (Î¼.restrict (Set.Ioo a b))).EventuallyEq f g\nhf : ContinuousOn f (Set.Ioo a b)\nhg : ContinuousOn g (Set.Ioo a b)\nâŠ¢ Set.EqOn f g (Set.Ioo a b)","decl":"theorem eqOn_Ioo_of_ae_eq {a b : X} {f g : X â†’ Y} (hfg : f =áµ[Î¼.restrict (Ioo a b)] g)\n    (hf : ContinuousOn f (Ioo a b)) (hg : ContinuousOn g (Ioo a b)) : EqOn f g (Ioo a b) :=\n  eqOn_of_ae_eq hfg hf hg Ioo_subset_closure_interior\n\n"}
{"name":"MeasureTheory.Measure.eqOn_Ioc_of_ae_eq","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœâ¶ : TopologicalSpace X\ninstâœâµ : LinearOrder X\ninstâœâ´ : OrderTopology X\nm : MeasurableSpace X\ninstâœÂ³ : TopologicalSpace Y\ninstâœÂ² : T2Space Y\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : Î¼.IsOpenPosMeasure\ninstâœ : DenselyOrdered X\na b : X\nf g : X â†’ Y\nhfg : (MeasureTheory.ae (Î¼.restrict (Set.Ioc a b))).EventuallyEq f g\nhf : ContinuousOn f (Set.Ioc a b)\nhg : ContinuousOn g (Set.Ioc a b)\nâŠ¢ Set.EqOn f g (Set.Ioc a b)","decl":"theorem eqOn_Ioc_of_ae_eq [DenselyOrdered X] {a b : X} {f g : X â†’ Y}\n    (hfg : f =áµ[Î¼.restrict (Ioc a b)] g) (hf : ContinuousOn f (Ioc a b))\n    (hg : ContinuousOn g (Ioc a b)) : EqOn f g (Ioc a b) :=\n  eqOn_of_ae_eq hfg hf hg (Ioc_subset_closure_interior _ _)\n\n"}
{"name":"MeasureTheory.Measure.eqOn_Ico_of_ae_eq","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœâ¶ : TopologicalSpace X\ninstâœâµ : LinearOrder X\ninstâœâ´ : OrderTopology X\nm : MeasurableSpace X\ninstâœÂ³ : TopologicalSpace Y\ninstâœÂ² : T2Space Y\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : Î¼.IsOpenPosMeasure\ninstâœ : DenselyOrdered X\na b : X\nf g : X â†’ Y\nhfg : (MeasureTheory.ae (Î¼.restrict (Set.Ico a b))).EventuallyEq f g\nhf : ContinuousOn f (Set.Ico a b)\nhg : ContinuousOn g (Set.Ico a b)\nâŠ¢ Set.EqOn f g (Set.Ico a b)","decl":"theorem eqOn_Ico_of_ae_eq [DenselyOrdered X] {a b : X} {f g : X â†’ Y}\n    (hfg : f =áµ[Î¼.restrict (Ico a b)] g) (hf : ContinuousOn f (Ico a b))\n    (hg : ContinuousOn g (Ico a b)) : EqOn f g (Ico a b) :=\n  eqOn_of_ae_eq hfg hf hg (Ico_subset_closure_interior _ _)\n\n"}
{"name":"MeasureTheory.Measure.eqOn_Icc_of_ae_eq","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœâ¶ : TopologicalSpace X\ninstâœâµ : LinearOrder X\ninstâœâ´ : OrderTopology X\nm : MeasurableSpace X\ninstâœÂ³ : TopologicalSpace Y\ninstâœÂ² : T2Space Y\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : Î¼.IsOpenPosMeasure\ninstâœ : DenselyOrdered X\na b : X\nhne : Ne a b\nf g : X â†’ Y\nhfg : (MeasureTheory.ae (Î¼.restrict (Set.Icc a b))).EventuallyEq f g\nhf : ContinuousOn f (Set.Icc a b)\nhg : ContinuousOn g (Set.Icc a b)\nâŠ¢ Set.EqOn f g (Set.Icc a b)","decl":"theorem eqOn_Icc_of_ae_eq [DenselyOrdered X] {a b : X} (hne : a â‰  b) {f g : X â†’ Y}\n    (hfg : f =áµ[Î¼.restrict (Icc a b)] g) (hf : ContinuousOn f (Icc a b))\n    (hg : ContinuousOn g (Icc a b)) : EqOn f g (Icc a b) :=\n  eqOn_of_ae_eq hfg hf hg (closure_interior_Icc hne).symm.subset\n\n"}
{"name":"Metric.measure_ball_pos","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœÂ¹ : PseudoMetricSpace X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\nx : X\nr : Real\nhr : LT.lt 0 r\nâŠ¢ LT.lt 0 (Î¼ (Metric.ball x r))","decl":"theorem measure_ball_pos (x : X) {r : â„} (hr : 0 < r) : 0 < Î¼ (ball x r) :=\n  isOpen_ball.measure_pos Î¼ (nonempty_ball.2 hr)\n\n"}
{"name":"Metric.measure_closedBall_pos","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœÂ¹ : PseudoMetricSpace X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\nx : X\nr : Real\nhr : LT.lt 0 r\nâŠ¢ LT.lt 0 (Î¼ (Metric.closedBall x r))","decl":"/-- See also `Metric.measure_closedBall_pos_iff`. -/\ntheorem measure_closedBall_pos (x : X) {r : â„} (hr : 0 < r) : 0 < Î¼ (closedBall x r) :=\n  (measure_ball_pos Î¼ x hr).trans_le (measure_mono ball_subset_closedBall)\n\n"}
{"name":"Metric.measure_closedBall_pos_iff","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_2\ninstâœÂ² : MetricSpace X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : Î¼.IsOpenPosMeasure\ninstâœ : MeasureTheory.NoAtoms Î¼\nx : X\nr : Real\nâŠ¢ Iff (LT.lt 0 (Î¼ (Metric.closedBall x r))) (LT.lt 0 r)","decl":"@[simp] lemma measure_closedBall_pos_iff {X : Type*} [MetricSpace X] {m : MeasurableSpace X}\n    (Î¼ : Measure X) [IsOpenPosMeasure Î¼] [NoAtoms Î¼] {x : X} {r : â„} :\n    0 < Î¼ (closedBall x r) â†” 0 < r := by\n  refine âŸ¨fun h â†¦ ?_, measure_closedBall_pos Î¼ xâŸ©\n  contrapose! h\n  rw [(subsingleton_closedBall x h).measure_zero Î¼]\n\n"}
{"name":"EMetric.measure_ball_pos","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœÂ¹ : PseudoEMetricSpace X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\nx : X\nr : ENNReal\nhr : Ne r 0\nâŠ¢ LT.lt 0 (Î¼ (EMetric.ball x r))","decl":"theorem measure_ball_pos (x : X) {r : â„â‰¥0âˆ} (hr : r â‰  0) : 0 < Î¼ (ball x r) :=\n  isOpen_ball.measure_pos Î¼ âŸ¨x, mem_ball_self hr.bot_ltâŸ©\n\n"}
{"name":"EMetric.measure_closedBall_pos","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœÂ¹ : PseudoEMetricSpace X\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\nx : X\nr : ENNReal\nhr : Ne r 0\nâŠ¢ LT.lt 0 (Î¼ (EMetric.closedBall x r))","decl":"theorem measure_closedBall_pos (x : X) {r : â„â‰¥0âˆ} (hr : r â‰  0) : 0 < Î¼ (closedBall x r) :=\n  (measure_ball_pos Î¼ x hr).trans_le (measure_mono ball_subset_closedBall)\n\n"}
{"name":"IsNowhereDense.of_isClosed_null","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : MeasurableSpace X\ns : Set X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : Î¼.IsOpenPosMeasure\nhâ‚s : IsClosed s\nhâ‚‚s : Eq (Î¼ s) 0\nâŠ¢ IsNowhereDense s","decl":"/-- A *closed* measure zero subset is nowhere dense. (Closedness is required: for instance, the\nrational numbers are countable (thus have measure zero), but are dense (hence not nowhere dense). -/\nlemma IsNowhereDense.of_isClosed_null (hâ‚s : IsClosed s) (hâ‚‚s : Î¼ s = 0) :\n    IsNowhereDense s := hâ‚s.isNowhereDense_iff.mpr (interior_eq_empty_of_null hâ‚‚s)\n\n"}
{"name":"IsMeagre.of_isSigmaCompact_null","module":"Mathlib.MeasureTheory.Measure.OpenPos","initialProofState":"X : Type u_1\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : MeasurableSpace X\ns : Set X\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : Î¼.IsOpenPosMeasure\ninstâœ : T2Space X\nhâ‚s : IsSigmaCompact s\nhâ‚‚s : Eq (Î¼ s) 0\nâŠ¢ IsMeagre s","decl":"/-- A Ïƒ-compact measure zero subset is meagre.\n(More generally, every FÏƒ set of measure zero is meagre.) -/\nlemma IsMeagre.of_isSigmaCompact_null [T2Space X] (hâ‚s : IsSigmaCompact s) (hâ‚‚s : Î¼ s = 0) :\n    IsMeagre s := by\n  rcases hâ‚s with âŸ¨K, hcompact, hcoverâŸ©\n  have h (n : â„•) : IsNowhereDense (K n) := by\n    have : Î¼ (K n) = 0 := measure_mono_null (hcover â–¸ subset_iUnion K n) hâ‚‚s\n    exact .of_isClosed_null (hcompact n).isClosed this\n  rw [isMeagre_iff_countable_union_isNowhereDense]\n  exact âŸ¨range K, fun t âŸ¨n, hnâŸ© â†¦ hn â–¸ h n, countable_range K, hcover.symm.subsetâŸ©\n\n"}
