{"name":"CategoryTheory.CategoryOfElements.CreatesLimitsAux.π_liftedConeElement'","module":"Mathlib.CategoryTheory.Limits.Elements","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor C (Type w)\nI : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} I\ninst✝ : Small.{w, u₁} I\nF : CategoryTheory.Functor I A.Elements\ni : I\n⊢ Eq (CategoryTheory.Limits.limit.π ((F.comp (CategoryTheory.CategoryOfElements.π A)).comp A) i (CategoryTheory.CategoryOfElements.CreatesLimitsAux.liftedConeElement' F)) (F.obj i).snd","decl":"@[simp]\nlemma π_liftedConeElement' (i : I) :\n    limit.π ((F ⋙ π A) ⋙ A) i (liftedConeElement' F) = (F.obj i).2 :=\n  Types.Limit.π_mk _ _ _ _\n\n"}
{"name":"CategoryTheory.CategoryOfElements.CreatesLimitsAux.map_lift_mapCone","module":"Mathlib.CategoryTheory.Limits.Elements","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor C (Type w)\nI : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} I\ninst✝² : Small.{w, u₁} I\nF : CategoryTheory.Functor I A.Elements\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape I C\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape I A\nc : CategoryTheory.Limits.Cone F\n⊢ Eq (A.map (CategoryTheory.Limits.limit.lift (F.comp (CategoryTheory.CategoryOfElements.π A)) ((CategoryTheory.CategoryOfElements.π A).mapCone c)) c.pt.snd) (CategoryTheory.CategoryOfElements.CreatesLimitsAux.liftedConeElement F)","decl":"@[simp]\nlemma map_lift_mapCone (c : Cone F) :\n    A.map (limit.lift (F ⋙ π A) ((π A).mapCone c)) c.pt.snd = liftedConeElement F := by\n  apply (preservesLimitIso A (F ⋙ π A)).toEquiv.injective\n  ext i\n  have h₁ := congrFun (preservesLimitIso_hom_π A (F ⋙ π A) i)\n    (A.map (limit.lift (F ⋙ π A) ((π A).mapCone c)) c.pt.snd)\n  have h₂ := (c.π.app i).property\n  simp_all [← FunctorToTypes.map_comp_apply, liftedConeElement]\n\n"}
{"name":"CategoryTheory.CategoryOfElements.CreatesLimitsAux.map_π_liftedConeElement","module":"Mathlib.CategoryTheory.Limits.Elements","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor C (Type w)\nI : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} I\ninst✝² : Small.{w, u₁} I\nF : CategoryTheory.Functor I A.Elements\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape I C\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape I A\ni : I\n⊢ Eq (A.map (CategoryTheory.Limits.limit.π (F.comp (CategoryTheory.CategoryOfElements.π A)) i) (CategoryTheory.CategoryOfElements.CreatesLimitsAux.liftedConeElement F)) (F.obj i).snd","decl":"@[simp]\nlemma map_π_liftedConeElement (i : I) :\n    A.map (limit.π (F ⋙ π A) i) (liftedConeElement F) = (F.obj i).snd := by\n  have := congrFun\n    (preservesLimitIso_inv_π A (F ⋙ π A) i) (liftedConeElement' F)\n  simp_all [liftedConeElement]\n\n"}
{"name":"CategoryTheory.CategoryOfElements.CreatesLimitsAux.liftedCone_π_app_coe","module":"Mathlib.CategoryTheory.Limits.Elements","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor C (Type w)\nI : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} I\ninst✝² : Small.{w, u₁} I\nF : CategoryTheory.Functor I A.Elements\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape I C\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape I A\ni : I\n⊢ Eq (↑((CategoryTheory.CategoryOfElements.CreatesLimitsAux.liftedCone F).π.app i)) (CategoryTheory.Limits.limit.π (F.comp (CategoryTheory.CategoryOfElements.π A)) i)","decl":"/-- (implementation) The constructured limit cone. -/\n@[simps]\nnoncomputable def liftedCone : Cone F where\n  pt := ⟨_, liftedConeElement F⟩\n  π :=\n    { app := fun i => ⟨limit.π (F ⋙ π A) i, by simp⟩\n      naturality := fun i i' f => by ext; simpa using (limit.w _ _).symm }\n\n"}
{"name":"CategoryTheory.CategoryOfElements.CreatesLimitsAux.liftedCone_pt_fst","module":"Mathlib.CategoryTheory.Limits.Elements","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor C (Type w)\nI : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} I\ninst✝² : Small.{w, u₁} I\nF : CategoryTheory.Functor I A.Elements\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape I C\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape I A\n⊢ Eq (CategoryTheory.CategoryOfElements.CreatesLimitsAux.liftedCone F).pt.fst (CategoryTheory.Limits.limit (F.comp (CategoryTheory.CategoryOfElements.π A)))","decl":"/-- (implementation) The constructured limit cone. -/\n@[simps]\nnoncomputable def liftedCone : Cone F where\n  pt := ⟨_, liftedConeElement F⟩\n  π :=\n    { app := fun i => ⟨limit.π (F ⋙ π A) i, by simp⟩\n      naturality := fun i i' f => by ext; simpa using (limit.w _ _).symm }\n\n"}
{"name":"CategoryTheory.CategoryOfElements.CreatesLimitsAux.liftedCone_pt_snd","module":"Mathlib.CategoryTheory.Limits.Elements","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor C (Type w)\nI : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} I\ninst✝² : Small.{w, u₁} I\nF : CategoryTheory.Functor I A.Elements\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape I C\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape I A\n⊢ Eq (CategoryTheory.CategoryOfElements.CreatesLimitsAux.liftedCone F).pt.snd (CategoryTheory.CategoryOfElements.CreatesLimitsAux.liftedConeElement F)","decl":"/-- (implementation) The constructured limit cone. -/\n@[simps]\nnoncomputable def liftedCone : Cone F where\n  pt := ⟨_, liftedConeElement F⟩\n  π :=\n    { app := fun i => ⟨limit.π (F ⋙ π A) i, by simp⟩\n      naturality := fun i i' f => by ext; simpa using (limit.w _ _).symm }\n\n"}
{"name":"CategoryTheory.CategoryOfElements.instHasLimitsOfShapeElements","module":"Mathlib.CategoryTheory.Limits.Elements","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor C (Type w)\nI : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} I\ninst✝² : Small.{w, u₁} I\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape I C\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape I A\n⊢ CategoryTheory.Limits.HasLimitsOfShape I A.Elements","decl":"instance : HasLimitsOfShape I A.Elements :=\n  hasLimitsOfShape_of_hasLimitsOfShape_createsLimitsOfShape (π A)\n\n"}
