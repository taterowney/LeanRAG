{"name":"CategoryTheory.PreOneHypercover.mk.injEq","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nS : C\nI₀✝ : Type w\nX✝ : I₀✝ → C\nf✝ : (i : I₀✝) → Quiver.Hom (X✝ i) S\nI₁✝ : I₀✝ → I₀✝ → Type w\nY✝ : ⦃i₁ i₂ : I₀✝⦄ → I₁✝ i₁ i₂ → C\np₁✝ : ⦃i₁ i₂ : I₀✝⦄ → (j : I₁✝ i₁ i₂) → Quiver.Hom (Y✝ j) (X✝ i₁)\np₂✝ : ⦃i₁ i₂ : I₀✝⦄ → (j : I₁✝ i₁ i₂) → Quiver.Hom (Y✝ j) (X✝ i₂)\nw✝ : ∀ ⦃i₁ i₂ : I₀✝⦄ (j : I₁✝ i₁ i₂), Eq (CategoryTheory.CategoryStruct.comp (p₁✝ j) (f✝ i₁)) (CategoryTheory.CategoryStruct.comp (p₂✝ j) (f✝ i₂))\nI₀ : Type w\nX : I₀ → C\nf : (i : I₀) → Quiver.Hom (X i) S\nI₁ : I₀ → I₀ → Type w\nY : ⦃i₁ i₂ : I₀⦄ → I₁ i₁ i₂ → C\np₁ : ⦃i₁ i₂ : I₀⦄ → (j : I₁ i₁ i₂) → Quiver.Hom (Y j) (X i₁)\np₂ : ⦃i₁ i₂ : I₀⦄ → (j : I₁ i₁ i₂) → Quiver.Hom (Y j) (X i₂)\nw : ∀ ⦃i₁ i₂ : I₀⦄ (j : I₁ i₁ i₂), Eq (CategoryTheory.CategoryStruct.comp (p₁ j) (f i₁)) (CategoryTheory.CategoryStruct.comp (p₂ j) (f i₂))\n⊢ Eq (Eq { I₀ := I₀✝, X := X✝, f := f✝, I₁ := I₁✝, Y := Y✝, p₁ := p₁✝, p₂ := p₂✝, w := w✝ } { I₀ := I₀, X := X, f := f, I₁ := I₁, Y := Y, p₁ := p₁, p₂ := p₂, w := w }) (And (Eq I₀✝ I₀) (And (HEq X✝ X) (And (HEq f✝ f) (And (HEq I₁✝ I₁) (And (HEq Y✝ Y) (And (HEq p₁✝ p₁) (HEq p₂✝ p₂)))))))","decl":"/-- The categorical data that is involved in a `1`-hypercover of an object `S`. This\nconsists of a family of morphisms `f i : X i ⟶ S` for `i : I₀`, and for each\ntuple `(i₁, i₂)` of elements in `I₀`, a family of objects `Y j` indexed by\na type `I₁ i₁ i₂`, which are equipped with a map to the fibre product of `X i₁`\nand `X i₂`, which is phrased here as the data of the two projections\n`p₁ : Y j ⟶ X i₁`, `p₂ : Y j ⟶ X i₂` and the relation `p₁ j ≫ f i₁ = p₂ j ≫ f i₂`.\n(See `GrothendieckTopology.OneHypercover` for the topological conditions.) -/\nstructure PreOneHypercover (S : C) where\n  /-- the index type of the covering of `S` -/\n  I₀ : Type w\n  /-- the objects in the covering of `S` -/\n  X (i : I₀) : C\n  /-- the morphisms in the covering of `S` -/\n  f (i : I₀) : X i ⟶ S\n  /-- the index type of the coverings of the fibre products -/\n  I₁ (i₁ i₂ : I₀) : Type w\n  /-- the objects in the coverings of the fibre products  -/\n  Y ⦃i₁ i₂ : I₀⦄ (j : I₁ i₁ i₂) : C\n  /-- the first projection `Y j ⟶ X i₁` -/\n  p₁ ⦃i₁ i₂ : I₀⦄ (j : I₁ i₁ i₂) : Y j ⟶ X i₁\n  /-- the second projection `Y j ⟶ X i₂` -/\n  p₂ ⦃i₁ i₂ : I₀⦄ (j : I₁ i₁ i₂) : Y j ⟶ X i₂\n  w ⦃i₁ i₂ : I₀⦄ (j : I₁ i₁ i₂) : p₁ j ≫ f i₁ = p₂ j ≫ f i₂\n\n"}
{"name":"CategoryTheory.PreOneHypercover.w","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nS : C\nself : CategoryTheory.PreOneHypercover S\ni₁ i₂ : self.I₀\nj : self.I₁ i₁ i₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.p₁ j) (self.f i₁)) (CategoryTheory.CategoryStruct.comp (self.p₂ j) (self.f i₂))","decl":"/-- The categorical data that is involved in a `1`-hypercover of an object `S`. This\nconsists of a family of morphisms `f i : X i ⟶ S` for `i : I₀`, and for each\ntuple `(i₁, i₂)` of elements in `I₀`, a family of objects `Y j` indexed by\na type `I₁ i₁ i₂`, which are equipped with a map to the fibre product of `X i₁`\nand `X i₂`, which is phrased here as the data of the two projections\n`p₁ : Y j ⟶ X i₁`, `p₂ : Y j ⟶ X i₂` and the relation `p₁ j ≫ f i₁ = p₂ j ≫ f i₂`.\n(See `GrothendieckTopology.OneHypercover` for the topological conditions.) -/\nstructure PreOneHypercover (S : C) where\n  /-- the index type of the covering of `S` -/\n  I₀ : Type w\n  /-- the objects in the covering of `S` -/\n  X (i : I₀) : C\n  /-- the morphisms in the covering of `S` -/\n  f (i : I₀) : X i ⟶ S\n  /-- the index type of the coverings of the fibre products -/\n  I₁ (i₁ i₂ : I₀) : Type w\n  /-- the objects in the coverings of the fibre products  -/\n  Y ⦃i₁ i₂ : I₀⦄ (j : I₁ i₁ i₂) : C\n  /-- the first projection `Y j ⟶ X i₁` -/\n  p₁ ⦃i₁ i₂ : I₀⦄ (j : I₁ i₁ i₂) : Y j ⟶ X i₁\n  /-- the second projection `Y j ⟶ X i₂` -/\n  p₂ ⦃i₁ i₂ : I₀⦄ (j : I₁ i₁ i₂) : Y j ⟶ X i₂\n  w ⦃i₁ i₂ : I₀⦄ (j : I₁ i₁ i₂) : p₁ j ≫ f i₁ = p₂ j ≫ f i₂\n\n"}
{"name":"CategoryTheory.PreOneHypercover.mk.inj","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nS : C\nI₀✝ : Type w\nX✝ : I₀✝ → C\nf✝ : (i : I₀✝) → Quiver.Hom (X✝ i) S\nI₁✝ : I₀✝ → I₀✝ → Type w\nY✝ : ⦃i₁ i₂ : I₀✝⦄ → I₁✝ i₁ i₂ → C\np₁✝ : ⦃i₁ i₂ : I₀✝⦄ → (j : I₁✝ i₁ i₂) → Quiver.Hom (Y✝ j) (X✝ i₁)\np₂✝ : ⦃i₁ i₂ : I₀✝⦄ → (j : I₁✝ i₁ i₂) → Quiver.Hom (Y✝ j) (X✝ i₂)\nw✝ : ∀ ⦃i₁ i₂ : I₀✝⦄ (j : I₁✝ i₁ i₂), Eq (CategoryTheory.CategoryStruct.comp (p₁✝ j) (f✝ i₁)) (CategoryTheory.CategoryStruct.comp (p₂✝ j) (f✝ i₂))\nI₀ : Type w\nX : I₀ → C\nf : (i : I₀) → Quiver.Hom (X i) S\nI₁ : I₀ → I₀ → Type w\nY : ⦃i₁ i₂ : I₀⦄ → I₁ i₁ i₂ → C\np₁ : ⦃i₁ i₂ : I₀⦄ → (j : I₁ i₁ i₂) → Quiver.Hom (Y j) (X i₁)\np₂ : ⦃i₁ i₂ : I₀⦄ → (j : I₁ i₁ i₂) → Quiver.Hom (Y j) (X i₂)\nw : ∀ ⦃i₁ i₂ : I₀⦄ (j : I₁ i₁ i₂), Eq (CategoryTheory.CategoryStruct.comp (p₁ j) (f i₁)) (CategoryTheory.CategoryStruct.comp (p₂ j) (f i₂))\nx✝ : Eq { I₀ := I₀✝, X := X✝, f := f✝, I₁ := I₁✝, Y := Y✝, p₁ := p₁✝, p₂ := p₂✝, w := w✝ } { I₀ := I₀, X := X, f := f, I₁ := I₁, Y := Y, p₁ := p₁, p₂ := p₂, w := w }\n⊢ And (Eq I₀✝ I₀) (And (HEq X✝ X) (And (HEq f✝ f) (And (HEq I₁✝ I₁) (And (HEq Y✝ Y) (And (HEq p₁✝ p₁) (HEq p₂✝ p₂))))))","decl":"/-- The categorical data that is involved in a `1`-hypercover of an object `S`. This\nconsists of a family of morphisms `f i : X i ⟶ S` for `i : I₀`, and for each\ntuple `(i₁, i₂)` of elements in `I₀`, a family of objects `Y j` indexed by\na type `I₁ i₁ i₂`, which are equipped with a map to the fibre product of `X i₁`\nand `X i₂`, which is phrased here as the data of the two projections\n`p₁ : Y j ⟶ X i₁`, `p₂ : Y j ⟶ X i₂` and the relation `p₁ j ≫ f i₁ = p₂ j ≫ f i₂`.\n(See `GrothendieckTopology.OneHypercover` for the topological conditions.) -/\nstructure PreOneHypercover (S : C) where\n  /-- the index type of the covering of `S` -/\n  I₀ : Type w\n  /-- the objects in the covering of `S` -/\n  X (i : I₀) : C\n  /-- the morphisms in the covering of `S` -/\n  f (i : I₀) : X i ⟶ S\n  /-- the index type of the coverings of the fibre products -/\n  I₁ (i₁ i₂ : I₀) : Type w\n  /-- the objects in the coverings of the fibre products  -/\n  Y ⦃i₁ i₂ : I₀⦄ (j : I₁ i₁ i₂) : C\n  /-- the first projection `Y j ⟶ X i₁` -/\n  p₁ ⦃i₁ i₂ : I₀⦄ (j : I₁ i₁ i₂) : Y j ⟶ X i₁\n  /-- the second projection `Y j ⟶ X i₂` -/\n  p₂ ⦃i₁ i₂ : I₀⦄ (j : I₁ i₁ i₂) : Y j ⟶ X i₂\n  w ⦃i₁ i₂ : I₀⦄ (j : I₁ i₁ i₂) : p₁ j ≫ f i₁ = p₂ j ≫ f i₂\n\n"}
{"name":"CategoryTheory.PreOneHypercover.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nS : C\ninst✝ : SizeOf C\nI₀ : Type w\nX : I₀ → C\nf : (i : I₀) → Quiver.Hom (X i) S\nI₁ : I₀ → I₀ → Type w\nY : ⦃i₁ i₂ : I₀⦄ → I₁ i₁ i₂ → C\np₁ : ⦃i₁ i₂ : I₀⦄ → (j : I₁ i₁ i₂) → Quiver.Hom (Y j) (X i₁)\np₂ : ⦃i₁ i₂ : I₀⦄ → (j : I₁ i₁ i₂) → Quiver.Hom (Y j) (X i₂)\nw : ∀ ⦃i₁ i₂ : I₀⦄ (j : I₁ i₁ i₂), Eq (CategoryTheory.CategoryStruct.comp (p₁ j) (f i₁)) (CategoryTheory.CategoryStruct.comp (p₂ j) (f i₂))\n⊢ Eq (SizeOf.sizeOf { I₀ := I₀, X := X, f := f, I₁ := I₁, Y := Y, p₁ := p₁, p₂ := p₂, w := w }) (HAdd.hAdd 1 (SizeOf.sizeOf I₀))","decl":"/-- The categorical data that is involved in a `1`-hypercover of an object `S`. This\nconsists of a family of morphisms `f i : X i ⟶ S` for `i : I₀`, and for each\ntuple `(i₁, i₂)` of elements in `I₀`, a family of objects `Y j` indexed by\na type `I₁ i₁ i₂`, which are equipped with a map to the fibre product of `X i₁`\nand `X i₂`, which is phrased here as the data of the two projections\n`p₁ : Y j ⟶ X i₁`, `p₂ : Y j ⟶ X i₂` and the relation `p₁ j ≫ f i₁ = p₂ j ≫ f i₂`.\n(See `GrothendieckTopology.OneHypercover` for the topological conditions.) -/\nstructure PreOneHypercover (S : C) where\n  /-- the index type of the covering of `S` -/\n  I₀ : Type w\n  /-- the objects in the covering of `S` -/\n  X (i : I₀) : C\n  /-- the morphisms in the covering of `S` -/\n  f (i : I₀) : X i ⟶ S\n  /-- the index type of the coverings of the fibre products -/\n  I₁ (i₁ i₂ : I₀) : Type w\n  /-- the objects in the coverings of the fibre products  -/\n  Y ⦃i₁ i₂ : I₀⦄ (j : I₁ i₁ i₂) : C\n  /-- the first projection `Y j ⟶ X i₁` -/\n  p₁ ⦃i₁ i₂ : I₀⦄ (j : I₁ i₁ i₂) : Y j ⟶ X i₁\n  /-- the second projection `Y j ⟶ X i₂` -/\n  p₂ ⦃i₁ i₂ : I₀⦄ (j : I₁ i₁ i₂) : Y j ⟶ X i₂\n  w ⦃i₁ i₂ : I₀⦄ (j : I₁ i₁ i₂) : p₁ j ≫ f i₁ = p₂ j ≫ f i₂\n\n"}
{"name":"CategoryTheory.PreOneHypercover.sieve₁_apply","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nS : C\nE : CategoryTheory.PreOneHypercover S\ni₁ i₂ : E.I₀\nW : C\np₁ : Quiver.Hom W (E.X i₁)\np₂ : Quiver.Hom W (E.X i₂)\nZ : C\ng : Quiver.Hom Z W\n⊢ Eq ((E.sieve₁ p₁ p₂).arrows g) (Exists fun j => Exists fun h => And (Eq (CategoryTheory.CategoryStruct.comp g p₁) (CategoryTheory.CategoryStruct.comp h (E.p₁ j))) (Eq (CategoryTheory.CategoryStruct.comp g p₂) (CategoryTheory.CategoryStruct.comp h (E.p₂ j))))","decl":"/-- Given an object `W` equipped with morphisms `p₁ : W ⟶ E.X i₁`, `p₂ : W ⟶ E.X i₂`,\nthis is the sieve of `W` which consists of morphisms `g : Z ⟶ W` such that there exists `j`\nand `h : Z ⟶ E.Y j` such that `g ≫ p₁ = h ≫ E.p₁ j` and `g ≫ p₂ = h ≫ E.p₂ j`.\nSee lemmas `sieve₁_eq_pullback_sieve₁'` and `sieve₁'_eq_sieve₁` for equational lemmas\nregarding this sieve. -/\n@[simps]\ndef sieve₁ {i₁ i₂ : E.I₀} {W : C} (p₁ : W ⟶ E.X i₁) (p₂ : W ⟶ E.X i₂) : Sieve W where\n  arrows Z g := ∃ (j : E.I₁ i₁ i₂) (h : Z ⟶ E.Y j), g ≫ p₁ = h ≫ E.p₁ j ∧ g ≫ p₂ = h ≫ E.p₂ j\n  downward_closed := by\n    rintro Z Z' g ⟨j, h, fac₁, fac₂⟩ φ\n    exact ⟨j, φ ≫ h, by simpa using φ ≫= fac₁, by simpa using φ ≫= fac₂⟩\n\n"}
{"name":"CategoryTheory.PreOneHypercover.sieve₁_eq_pullback_sieve₁'","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nS : C\nE : CategoryTheory.PreOneHypercover S\ni₁ i₂ : E.I₀\ninst✝ : CategoryTheory.Limits.HasPullback (E.f i₁) (E.f i₂)\nW : C\np₁ : Quiver.Hom W (E.X i₁)\np₂ : Quiver.Hom W (E.X i₂)\nw : Eq (CategoryTheory.CategoryStruct.comp p₁ (E.f i₁)) (CategoryTheory.CategoryStruct.comp p₂ (E.f i₂))\n⊢ Eq (E.sieve₁ p₁ p₂) (CategoryTheory.Sieve.pullback (CategoryTheory.Limits.pullback.lift p₁ p₂ w) (E.sieve₁' i₁ i₂))","decl":"lemma sieve₁_eq_pullback_sieve₁' {W : C} (p₁ : W ⟶ E.X i₁) (p₂ : W ⟶ E.X i₂)\n    (w : p₁ ≫ E.f i₁ = p₂ ≫ E.f i₂) :\n    E.sieve₁ p₁ p₂ = (E.sieve₁' i₁ i₂).pullback (pullback.lift _ _ w) := by\n  ext Z g\n  constructor\n  · rintro ⟨j, h, fac₁, fac₂⟩\n    exact ⟨_, h, _, ⟨j⟩, by aesop_cat⟩\n  · rintro ⟨_, h, w, ⟨j⟩, fac⟩\n    exact ⟨j, h, by simpa using fac.symm =≫ pullback.fst _ _,\n      by simpa using fac.symm =≫ pullback.snd _ _⟩\n\n"}
{"name":"CategoryTheory.PreOneHypercover.sieve₁'_eq_sieve₁","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nS : C\nE : CategoryTheory.PreOneHypercover S\ni₁ i₂ : E.I₀\ninst✝ : CategoryTheory.Limits.HasPullback (E.f i₁) (E.f i₂)\n⊢ Eq (E.sieve₁' i₁ i₂) (E.sieve₁ (CategoryTheory.Limits.pullback.fst (E.f i₁) (E.f i₂)) (CategoryTheory.Limits.pullback.snd (E.f i₁) (E.f i₂)))","decl":"variable (i₁ i₂) in\nlemma sieve₁'_eq_sieve₁ : E.sieve₁' i₁ i₂ = E.sieve₁ (pullback.fst _ _) (pullback.snd _ _) := by\n  rw [← Sieve.pullback_id (S := E.sieve₁' i₁ i₂),\n    sieve₁_eq_pullback_sieve₁' _ _ _ pullback.condition]\n  congr\n  aesop_cat\n\n"}
{"name":"CategoryTheory.PreOneHypercover.multicospanIndex_R","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} A\nS : C\nE : CategoryTheory.PreOneHypercover S\nF : CategoryTheory.Functor (Opposite C) A\n⊢ Eq (E.multicospanIndex F).R E.I₁'","decl":"/-- The diagram of the multifork attached to a presheaf\n`F : Cᵒᵖ ⥤ A`, `S : C` and `E : PreOneHypercover S`. -/\n@[simps]\ndef multicospanIndex (F : Cᵒᵖ ⥤ A) : MulticospanIndex A where\n  L := E.I₀\n  R := E.I₁'\n  fstTo j := j.1.1\n  sndTo j := j.1.2\n  left i := F.obj (Opposite.op (E.X i))\n  right j := F.obj (Opposite.op (E.Y j.2))\n  fst j := F.map ((E.p₁ j.2).op)\n  snd j := F.map ((E.p₂ j.2).op)\n\n"}
{"name":"CategoryTheory.PreOneHypercover.multicospanIndex_sndTo","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} A\nS : C\nE : CategoryTheory.PreOneHypercover S\nF : CategoryTheory.Functor (Opposite C) A\nj : E.I₁'\n⊢ Eq ((E.multicospanIndex F).sndTo j) j.fst.2","decl":"/-- The diagram of the multifork attached to a presheaf\n`F : Cᵒᵖ ⥤ A`, `S : C` and `E : PreOneHypercover S`. -/\n@[simps]\ndef multicospanIndex (F : Cᵒᵖ ⥤ A) : MulticospanIndex A where\n  L := E.I₀\n  R := E.I₁'\n  fstTo j := j.1.1\n  sndTo j := j.1.2\n  left i := F.obj (Opposite.op (E.X i))\n  right j := F.obj (Opposite.op (E.Y j.2))\n  fst j := F.map ((E.p₁ j.2).op)\n  snd j := F.map ((E.p₂ j.2).op)\n\n"}
{"name":"CategoryTheory.PreOneHypercover.multicospanIndex_fst","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} A\nS : C\nE : CategoryTheory.PreOneHypercover S\nF : CategoryTheory.Functor (Opposite C) A\nj : E.I₁'\n⊢ Eq ((E.multicospanIndex F).fst j) (F.map (E.p₁ j.snd).op)","decl":"/-- The diagram of the multifork attached to a presheaf\n`F : Cᵒᵖ ⥤ A`, `S : C` and `E : PreOneHypercover S`. -/\n@[simps]\ndef multicospanIndex (F : Cᵒᵖ ⥤ A) : MulticospanIndex A where\n  L := E.I₀\n  R := E.I₁'\n  fstTo j := j.1.1\n  sndTo j := j.1.2\n  left i := F.obj (Opposite.op (E.X i))\n  right j := F.obj (Opposite.op (E.Y j.2))\n  fst j := F.map ((E.p₁ j.2).op)\n  snd j := F.map ((E.p₂ j.2).op)\n\n"}
{"name":"CategoryTheory.PreOneHypercover.multicospanIndex_left","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} A\nS : C\nE : CategoryTheory.PreOneHypercover S\nF : CategoryTheory.Functor (Opposite C) A\ni : E.I₀\n⊢ Eq ((E.multicospanIndex F).left i) (F.obj { unop := E.X i })","decl":"/-- The diagram of the multifork attached to a presheaf\n`F : Cᵒᵖ ⥤ A`, `S : C` and `E : PreOneHypercover S`. -/\n@[simps]\ndef multicospanIndex (F : Cᵒᵖ ⥤ A) : MulticospanIndex A where\n  L := E.I₀\n  R := E.I₁'\n  fstTo j := j.1.1\n  sndTo j := j.1.2\n  left i := F.obj (Opposite.op (E.X i))\n  right j := F.obj (Opposite.op (E.Y j.2))\n  fst j := F.map ((E.p₁ j.2).op)\n  snd j := F.map ((E.p₂ j.2).op)\n\n"}
{"name":"CategoryTheory.PreOneHypercover.multicospanIndex_fstTo","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} A\nS : C\nE : CategoryTheory.PreOneHypercover S\nF : CategoryTheory.Functor (Opposite C) A\nj : E.I₁'\n⊢ Eq ((E.multicospanIndex F).fstTo j) j.fst.1","decl":"/-- The diagram of the multifork attached to a presheaf\n`F : Cᵒᵖ ⥤ A`, `S : C` and `E : PreOneHypercover S`. -/\n@[simps]\ndef multicospanIndex (F : Cᵒᵖ ⥤ A) : MulticospanIndex A where\n  L := E.I₀\n  R := E.I₁'\n  fstTo j := j.1.1\n  sndTo j := j.1.2\n  left i := F.obj (Opposite.op (E.X i))\n  right j := F.obj (Opposite.op (E.Y j.2))\n  fst j := F.map ((E.p₁ j.2).op)\n  snd j := F.map ((E.p₂ j.2).op)\n\n"}
{"name":"CategoryTheory.PreOneHypercover.multicospanIndex_right","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} A\nS : C\nE : CategoryTheory.PreOneHypercover S\nF : CategoryTheory.Functor (Opposite C) A\nj : E.I₁'\n⊢ Eq ((E.multicospanIndex F).right j) (F.obj { unop := E.Y j.snd })","decl":"/-- The diagram of the multifork attached to a presheaf\n`F : Cᵒᵖ ⥤ A`, `S : C` and `E : PreOneHypercover S`. -/\n@[simps]\ndef multicospanIndex (F : Cᵒᵖ ⥤ A) : MulticospanIndex A where\n  L := E.I₀\n  R := E.I₁'\n  fstTo j := j.1.1\n  sndTo j := j.1.2\n  left i := F.obj (Opposite.op (E.X i))\n  right j := F.obj (Opposite.op (E.Y j.2))\n  fst j := F.map ((E.p₁ j.2).op)\n  snd j := F.map ((E.p₂ j.2).op)\n\n"}
{"name":"CategoryTheory.PreOneHypercover.multicospanIndex_snd","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} A\nS : C\nE : CategoryTheory.PreOneHypercover S\nF : CategoryTheory.Functor (Opposite C) A\nj : E.I₁'\n⊢ Eq ((E.multicospanIndex F).snd j) (F.map (E.p₂ j.snd).op)","decl":"/-- The diagram of the multifork attached to a presheaf\n`F : Cᵒᵖ ⥤ A`, `S : C` and `E : PreOneHypercover S`. -/\n@[simps]\ndef multicospanIndex (F : Cᵒᵖ ⥤ A) : MulticospanIndex A where\n  L := E.I₀\n  R := E.I₁'\n  fstTo j := j.1.1\n  sndTo j := j.1.2\n  left i := F.obj (Opposite.op (E.X i))\n  right j := F.obj (Opposite.op (E.Y j.2))\n  fst j := F.map ((E.p₁ j.2).op)\n  snd j := F.map ((E.p₂ j.2).op)\n\n"}
{"name":"CategoryTheory.PreOneHypercover.multicospanIndex_L","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} A\nS : C\nE : CategoryTheory.PreOneHypercover S\nF : CategoryTheory.Functor (Opposite C) A\n⊢ Eq (E.multicospanIndex F).L E.I₀","decl":"/-- The diagram of the multifork attached to a presheaf\n`F : Cᵒᵖ ⥤ A`, `S : C` and `E : PreOneHypercover S`. -/\n@[simps]\ndef multicospanIndex (F : Cᵒᵖ ⥤ A) : MulticospanIndex A where\n  L := E.I₀\n  R := E.I₁'\n  fstTo j := j.1.1\n  sndTo j := j.1.2\n  left i := F.obj (Opposite.op (E.X i))\n  right j := F.obj (Opposite.op (E.Y j.2))\n  fst j := F.map ((E.p₁ j.2).op)\n  snd j := F.map ((E.p₂ j.2).op)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.OneHypercover.mem₁","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nS : C\nself : J.OneHypercover S\ni₁ i₂ : self.I₀\nW : C\np₁ : Quiver.Hom W (self.X i₁)\np₂ : Quiver.Hom W (self.X i₂)\nw : Eq (CategoryTheory.CategoryStruct.comp p₁ (self.f i₁)) (CategoryTheory.CategoryStruct.comp p₂ (self.f i₂))\n⊢ Membership.mem (J W) (self.sieve₁ p₁ p₂)","decl":"/-- The type of `1`-hypercovers of an object `S : C` in a category equipped with a\nGrothendieck topology `J`. This can be constructed from a covering of `S` and\na covering of the fibre products of the objects in this covering (see `OneHypercover.mk'`). -/\nstructure OneHypercover (S : C) extends PreOneHypercover.{w} S where\n  mem₀ : toPreOneHypercover.sieve₀ ∈ J S\n  mem₁ (i₁ i₂ : I₀) ⦃W : C⦄ (p₁ : W ⟶ X i₁) (p₂ : W ⟶ X i₂) (w : p₁ ≫ f i₁ = p₂ ≫ f i₂) :\n    toPreOneHypercover.sieve₁ p₁ p₂ ∈ J W\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.OneHypercover.mk.inj","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nS : C\ntoPreOneHypercover✝ : CategoryTheory.PreOneHypercover S\nmem₀✝ : Membership.mem (J S) toPreOneHypercover✝.sieve₀\nmem₁✝ : ∀ (i₁ i₂ : toPreOneHypercover✝.I₀) ⦃W : C⦄ (p₁ : Quiver.Hom W (toPreOneHypercover✝.X i₁)) (p₂ : Quiver.Hom W (toPreOneHypercover✝.X i₂)), Eq (CategoryTheory.CategoryStruct.comp p₁ (toPreOneHypercover✝.f i₁)) (CategoryTheory.CategoryStruct.comp p₂ (toPreOneHypercover✝.f i₂)) → Membership.mem (J W) (toPreOneHypercover✝.sieve₁ p₁ p₂)\ntoPreOneHypercover : CategoryTheory.PreOneHypercover S\nmem₀ : Membership.mem (J S) toPreOneHypercover.sieve₀\nmem₁ : ∀ (i₁ i₂ : toPreOneHypercover.I₀) ⦃W : C⦄ (p₁ : Quiver.Hom W (toPreOneHypercover.X i₁)) (p₂ : Quiver.Hom W (toPreOneHypercover.X i₂)), Eq (CategoryTheory.CategoryStruct.comp p₁ (toPreOneHypercover.f i₁)) (CategoryTheory.CategoryStruct.comp p₂ (toPreOneHypercover.f i₂)) → Membership.mem (J W) (toPreOneHypercover.sieve₁ p₁ p₂)\nx✝ : Eq { toPreOneHypercover := toPreOneHypercover✝, mem₀ := mem₀✝, mem₁ := mem₁✝ } { toPreOneHypercover := toPreOneHypercover, mem₀ := mem₀, mem₁ := mem₁ }\n⊢ Eq toPreOneHypercover✝ toPreOneHypercover","decl":"/-- The type of `1`-hypercovers of an object `S : C` in a category equipped with a\nGrothendieck topology `J`. This can be constructed from a covering of `S` and\na covering of the fibre products of the objects in this covering (see `OneHypercover.mk'`). -/\nstructure OneHypercover (S : C) extends PreOneHypercover.{w} S where\n  mem₀ : toPreOneHypercover.sieve₀ ∈ J S\n  mem₁ (i₁ i₂ : I₀) ⦃W : C⦄ (p₁ : W ⟶ X i₁) (p₂ : W ⟶ X i₂) (w : p₁ ≫ f i₁ = p₂ ≫ f i₂) :\n    toPreOneHypercover.sieve₁ p₁ p₂ ∈ J W\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.OneHypercover.mem₀","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nS : C\nself : J.OneHypercover S\n⊢ Membership.mem (J S) self.sieve₀","decl":"/-- The type of `1`-hypercovers of an object `S : C` in a category equipped with a\nGrothendieck topology `J`. This can be constructed from a covering of `S` and\na covering of the fibre products of the objects in this covering (see `OneHypercover.mk'`). -/\nstructure OneHypercover (S : C) extends PreOneHypercover.{w} S where\n  mem₀ : toPreOneHypercover.sieve₀ ∈ J S\n  mem₁ (i₁ i₂ : I₀) ⦃W : C⦄ (p₁ : W ⟶ X i₁) (p₂ : W ⟶ X i₂) (w : p₁ ≫ f i₁ = p₂ ≫ f i₂) :\n    toPreOneHypercover.sieve₁ p₁ p₂ ∈ J W\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.OneHypercover.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nS : C\ninst✝ : SizeOf C\ntoPreOneHypercover : CategoryTheory.PreOneHypercover S\nmem₀ : Membership.mem (J S) toPreOneHypercover.sieve₀\nmem₁ : ∀ (i₁ i₂ : toPreOneHypercover.I₀) ⦃W : C⦄ (p₁ : Quiver.Hom W (toPreOneHypercover.X i₁)) (p₂ : Quiver.Hom W (toPreOneHypercover.X i₂)), Eq (CategoryTheory.CategoryStruct.comp p₁ (toPreOneHypercover.f i₁)) (CategoryTheory.CategoryStruct.comp p₂ (toPreOneHypercover.f i₂)) → Membership.mem (J W) (toPreOneHypercover.sieve₁ p₁ p₂)\n⊢ Eq (SizeOf.sizeOf { toPreOneHypercover := toPreOneHypercover, mem₀ := mem₀, mem₁ := mem₁ }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toPreOneHypercover)) (SizeOf.sizeOf mem₀))","decl":"/-- The type of `1`-hypercovers of an object `S : C` in a category equipped with a\nGrothendieck topology `J`. This can be constructed from a covering of `S` and\na covering of the fibre products of the objects in this covering (see `OneHypercover.mk'`). -/\nstructure OneHypercover (S : C) extends PreOneHypercover.{w} S where\n  mem₀ : toPreOneHypercover.sieve₀ ∈ J S\n  mem₁ (i₁ i₂ : I₀) ⦃W : C⦄ (p₁ : W ⟶ X i₁) (p₂ : W ⟶ X i₂) (w : p₁ ≫ f i₁ = p₂ ≫ f i₂) :\n    toPreOneHypercover.sieve₁ p₁ p₂ ∈ J W\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.OneHypercover.mk.injEq","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nS : C\ntoPreOneHypercover✝ : CategoryTheory.PreOneHypercover S\nmem₀✝ : Membership.mem (J S) toPreOneHypercover✝.sieve₀\nmem₁✝ : ∀ (i₁ i₂ : toPreOneHypercover✝.I₀) ⦃W : C⦄ (p₁ : Quiver.Hom W (toPreOneHypercover✝.X i₁)) (p₂ : Quiver.Hom W (toPreOneHypercover✝.X i₂)), Eq (CategoryTheory.CategoryStruct.comp p₁ (toPreOneHypercover✝.f i₁)) (CategoryTheory.CategoryStruct.comp p₂ (toPreOneHypercover✝.f i₂)) → Membership.mem (J W) (toPreOneHypercover✝.sieve₁ p₁ p₂)\ntoPreOneHypercover : CategoryTheory.PreOneHypercover S\nmem₀ : Membership.mem (J S) toPreOneHypercover.sieve₀\nmem₁ : ∀ (i₁ i₂ : toPreOneHypercover.I₀) ⦃W : C⦄ (p₁ : Quiver.Hom W (toPreOneHypercover.X i₁)) (p₂ : Quiver.Hom W (toPreOneHypercover.X i₂)), Eq (CategoryTheory.CategoryStruct.comp p₁ (toPreOneHypercover.f i₁)) (CategoryTheory.CategoryStruct.comp p₂ (toPreOneHypercover.f i₂)) → Membership.mem (J W) (toPreOneHypercover.sieve₁ p₁ p₂)\n⊢ Eq (Eq { toPreOneHypercover := toPreOneHypercover✝, mem₀ := mem₀✝, mem₁ := mem₁✝ } { toPreOneHypercover := toPreOneHypercover, mem₀ := mem₀, mem₁ := mem₁ }) (Eq toPreOneHypercover✝ toPreOneHypercover)","decl":"/-- The type of `1`-hypercovers of an object `S : C` in a category equipped with a\nGrothendieck topology `J`. This can be constructed from a covering of `S` and\na covering of the fibre products of the objects in this covering (see `OneHypercover.mk'`). -/\nstructure OneHypercover (S : C) extends PreOneHypercover.{w} S where\n  mem₀ : toPreOneHypercover.sieve₀ ∈ J S\n  mem₁ (i₁ i₂ : I₀) ⦃W : C⦄ (p₁ : W ⟶ X i₁) (p₂ : W ⟶ X i₂) (w : p₁ ≫ f i₁ = p₂ ≫ f i₂) :\n    toPreOneHypercover.sieve₁ p₁ p₂ ∈ J W\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.OneHypercover.mem_sieve₁'","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nS : C\nE : J.OneHypercover S\ni₁ i₂ : E.I₀\ninst✝ : CategoryTheory.Limits.HasPullback (E.f i₁) (E.f i₂)\n⊢ Membership.mem (J (CategoryTheory.Limits.pullback (E.f i₁) (E.f i₂))) (E.sieve₁' i₁ i₂)","decl":"lemma OneHypercover.mem_sieve₁' {S : C} (E : J.OneHypercover S)\n    (i₁ i₂ : E.I₀) [HasPullback (E.f i₁) (E.f i₂)] :\n    E.sieve₁' i₁ i₂ ∈ J _ := by\n  rw [E.sieve₁'_eq_sieve₁]\n  exact mem₁ _ _ _ _ _ pullback.condition\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.OneHypercover.mk'_toPreOneHypercover","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nS : C\nE : CategoryTheory.PreOneHypercover S\ninst✝ : E.HasPullbacks\nmem₀ : Membership.mem (J S) E.sieve₀\nmem₁' : ∀ (i₁ i₂ : E.I₀), Membership.mem (J (CategoryTheory.Limits.pullback (E.f i₁) (E.f i₂))) (E.sieve₁' i₁ i₂)\n⊢ Eq (CategoryTheory.GrothendieckTopology.OneHypercover.mk' E mem₀ mem₁').toPreOneHypercover E","decl":"/-- In order to check that a certain data is a `1`-hypercover of `S`, it suffices to\ncheck that the data provides a covering of `S` and of the fibre products. -/\n@[simps toPreOneHypercover]\ndef mk' {S : C} (E : PreOneHypercover S) [E.HasPullbacks]\n    (mem₀ : E.sieve₀ ∈ J S) (mem₁' : ∀ (i₁ i₂ : E.I₀), E.sieve₁' i₁ i₂ ∈ J _) :\n    J.OneHypercover S where\n  toPreOneHypercover := E\n  mem₀ := mem₀\n  mem₁ i₁ i₂ W p₁ p₂ w := by\n    rw [E.sieve₁_eq_pullback_sieve₁' _ _ w]\n    exact J.pullback_stable' _ (mem₁' i₁ i₂)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.OneHypercover.multiforkLift_map_assoc","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA : Type u_1\ninst✝ : CategoryTheory.Category.{u_3, u_1} A\nJ : CategoryTheory.GrothendieckTopology C\nS : C\nE : J.OneHypercover S\nF : CategoryTheory.Sheaf J A\nc : CategoryTheory.Limits.Multifork (E.multicospanIndex F.val)\ni₀ : E.I₀\nZ : A\nh : Quiver.Hom (F.val.obj { unop := E.X i₀ }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GrothendieckTopology.OneHypercover.multiforkLift c) (CategoryTheory.CategoryStruct.comp (F.val.map (E.f i₀).op) h)) (CategoryTheory.CategoryStruct.comp (c.ι i₀) h)","decl":"@[reassoc]\nlemma multiforkLift_map (i₀ : E.I₀) : multiforkLift c ≫ F.val.map (E.f i₀).op = c.ι i₀ := by\n  simp [multiforkLift]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.OneHypercover.multiforkLift_map","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA : Type u_1\ninst✝ : CategoryTheory.Category.{u_3, u_1} A\nJ : CategoryTheory.GrothendieckTopology C\nS : C\nE : J.OneHypercover S\nF : CategoryTheory.Sheaf J A\nc : CategoryTheory.Limits.Multifork (E.multicospanIndex F.val)\ni₀ : E.I₀\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GrothendieckTopology.OneHypercover.multiforkLift c) (F.val.map (E.f i₀).op)) (c.ι i₀)","decl":"@[reassoc]\nlemma multiforkLift_map (i₀ : E.I₀) : multiforkLift c ≫ F.val.map (E.f i₀).op = c.ι i₀ := by\n  simp [multiforkLift]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.preOneHypercover_I₁","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\nS : J.Cover X\nf₁ f₂ : S.Arrow\n⊢ Eq (S.preOneHypercover.I₁ f₁ f₂) (f₁.Relation f₂)","decl":"/-- The tautological 1-pre-hypercover induced by `S : J.Cover X`. Its index type `I₀`\nis given by `S.Arrow` (i.e. all the morphisms in the sieve `S`), while `I₁` is given\nby all possible pullback cones. -/\n@[simps]\ndef preOneHypercover : PreOneHypercover.{max u v} X where\n  I₀ := S.Arrow\n  X f := f.Y\n  f f := f.f\n  I₁ f₁ f₂ := f₁.Relation f₂\n  Y _ _ r := r.Z\n  p₁ _ _ r := r.g₁\n  p₂ _ _ r := r.g₂\n  w _ _ r := r.w\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.preOneHypercover_f","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\nS : J.Cover X\nf : S.Arrow\n⊢ Eq (S.preOneHypercover.f f) f.f","decl":"/-- The tautological 1-pre-hypercover induced by `S : J.Cover X`. Its index type `I₀`\nis given by `S.Arrow` (i.e. all the morphisms in the sieve `S`), while `I₁` is given\nby all possible pullback cones. -/\n@[simps]\ndef preOneHypercover : PreOneHypercover.{max u v} X where\n  I₀ := S.Arrow\n  X f := f.Y\n  f f := f.f\n  I₁ f₁ f₂ := f₁.Relation f₂\n  Y _ _ r := r.Z\n  p₁ _ _ r := r.g₁\n  p₂ _ _ r := r.g₂\n  w _ _ r := r.w\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.preOneHypercover_p₁","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\nS : J.Cover X\nx✝¹ x✝ : S.Arrow\nr : x✝¹.Relation x✝\n⊢ Eq (S.preOneHypercover.p₁ r) r.g₁","decl":"/-- The tautological 1-pre-hypercover induced by `S : J.Cover X`. Its index type `I₀`\nis given by `S.Arrow` (i.e. all the morphisms in the sieve `S`), while `I₁` is given\nby all possible pullback cones. -/\n@[simps]\ndef preOneHypercover : PreOneHypercover.{max u v} X where\n  I₀ := S.Arrow\n  X f := f.Y\n  f f := f.f\n  I₁ f₁ f₂ := f₁.Relation f₂\n  Y _ _ r := r.Z\n  p₁ _ _ r := r.g₁\n  p₂ _ _ r := r.g₂\n  w _ _ r := r.w\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.preOneHypercover_p₂","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\nS : J.Cover X\nx✝¹ x✝ : S.Arrow\nr : x✝¹.Relation x✝\n⊢ Eq (S.preOneHypercover.p₂ r) r.g₂","decl":"/-- The tautological 1-pre-hypercover induced by `S : J.Cover X`. Its index type `I₀`\nis given by `S.Arrow` (i.e. all the morphisms in the sieve `S`), while `I₁` is given\nby all possible pullback cones. -/\n@[simps]\ndef preOneHypercover : PreOneHypercover.{max u v} X where\n  I₀ := S.Arrow\n  X f := f.Y\n  f f := f.f\n  I₁ f₁ f₂ := f₁.Relation f₂\n  Y _ _ r := r.Z\n  p₁ _ _ r := r.g₁\n  p₂ _ _ r := r.g₂\n  w _ _ r := r.w\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.preOneHypercover_Y","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\nS : J.Cover X\nx✝¹ x✝ : S.Arrow\nr : x✝¹.Relation x✝\n⊢ Eq (S.preOneHypercover.Y r) r.Z","decl":"/-- The tautological 1-pre-hypercover induced by `S : J.Cover X`. Its index type `I₀`\nis given by `S.Arrow` (i.e. all the morphisms in the sieve `S`), while `I₁` is given\nby all possible pullback cones. -/\n@[simps]\ndef preOneHypercover : PreOneHypercover.{max u v} X where\n  I₀ := S.Arrow\n  X f := f.Y\n  f f := f.f\n  I₁ f₁ f₂ := f₁.Relation f₂\n  Y _ _ r := r.Z\n  p₁ _ _ r := r.g₁\n  p₂ _ _ r := r.g₂\n  w _ _ r := r.w\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.preOneHypercover_X","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\nS : J.Cover X\nf : S.Arrow\n⊢ Eq (S.preOneHypercover.X f) f.Y","decl":"/-- The tautological 1-pre-hypercover induced by `S : J.Cover X`. Its index type `I₀`\nis given by `S.Arrow` (i.e. all the morphisms in the sieve `S`), while `I₁` is given\nby all possible pullback cones. -/\n@[simps]\ndef preOneHypercover : PreOneHypercover.{max u v} X where\n  I₀ := S.Arrow\n  X f := f.Y\n  f f := f.f\n  I₁ f₁ f₂ := f₁.Relation f₂\n  Y _ _ r := r.Z\n  p₁ _ _ r := r.g₁\n  p₂ _ _ r := r.g₂\n  w _ _ r := r.w\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.preOneHypercover_I₀","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\nS : J.Cover X\n⊢ Eq S.preOneHypercover.I₀ S.Arrow","decl":"/-- The tautological 1-pre-hypercover induced by `S : J.Cover X`. Its index type `I₀`\nis given by `S.Arrow` (i.e. all the morphisms in the sieve `S`), while `I₁` is given\nby all possible pullback cones. -/\n@[simps]\ndef preOneHypercover : PreOneHypercover.{max u v} X where\n  I₀ := S.Arrow\n  X f := f.Y\n  f f := f.f\n  I₁ f₁ f₂ := f₁.Relation f₂\n  Y _ _ r := r.Z\n  p₁ _ _ r := r.g₁\n  p₂ _ _ r := r.g₂\n  w _ _ r := r.w\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.preOneHypercover_sieve₀","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\nS : J.Cover X\n⊢ Eq S.preOneHypercover.sieve₀ ↑S","decl":"@[simp]\nlemma preOneHypercover_sieve₀ : S.preOneHypercover.sieve₀ = S.1 := by\n  ext Y f\n  constructor\n  · rintro ⟨_, _, _, ⟨g⟩, rfl⟩\n    exact S.1.downward_closed g.hf _\n  · intro hf\n    exact Sieve.ofArrows_mk _ _ ({ hf := hf } : S.Arrow)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.preOneHypercover_sieve₁","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\nS : J.Cover X\nf₁ f₂ : S.Arrow\nW : C\np₁ : Quiver.Hom W f₁.Y\np₂ : Quiver.Hom W f₂.Y\nw : Eq (CategoryTheory.CategoryStruct.comp p₁ f₁.f) (CategoryTheory.CategoryStruct.comp p₂ f₂.f)\n⊢ Eq (S.preOneHypercover.sieve₁ p₁ p₂) Top.top","decl":"lemma preOneHypercover_sieve₁ (f₁ f₂ : S.Arrow) {W : C} (p₁ : W ⟶ f₁.Y) (p₂ : W ⟶ f₂.Y)\n    (w : p₁ ≫ f₁.f = p₂ ≫ f₂.f) :\n    S.preOneHypercover.sieve₁ p₁ p₂ = ⊤ := by\n  ext Y f\n  simp only [Sieve.top_apply, iff_true]\n  exact ⟨{ w := w}, f, rfl, rfl⟩\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.oneHypercover_toPreOneHypercover","module":"Mathlib.CategoryTheory.Sites.OneHypercover","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\nS : J.Cover X\n⊢ Eq S.oneHypercover.toPreOneHypercover S.preOneHypercover","decl":"/-- The tautological 1-hypercover induced by `S : J.Cover X`. Its index type `I₀`\nis given by `S.Arrow` (i.e. all the morphisms in the sieve `S`), while `I₁` is given\nby all possible pullback cones. -/\n@[simps toPreOneHypercover]\ndef oneHypercover : J.OneHypercover X where\n  toPreOneHypercover := S.preOneHypercover\n  mem₀ := by simp\n  mem₁ f₁ f₂ _ p₁ p₂ w := by simp [S.preOneHypercover_sieve₁ f₁ f₂ p₁ p₂ w]\n\n"}
