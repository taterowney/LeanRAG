{"name":"AddAction.le_period","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\nm : M\na : α\nn : Nat\nperiod_pos : LT.lt 0 (AddAction.period m a)\nmoved : ∀ (k : Nat), LT.lt 0 k → LT.lt k n → Ne (HVAdd.hVAdd (HSMul.hSMul k m) a) a\n⊢ LE.le n (AddAction.period m a)","decl":"/-- If the action is periodic, then a lower bound for its period can be computed. -/\n@[to_additive \"If the action is periodic, then a lower bound for its period can be computed.\"]\ntheorem le_period {m : M} {a : α} {n : ℕ} (period_pos : 0 < period m a)\n    (moved : ∀ k, 0 < k → k < n → m ^ k • a ≠ a) : n ≤ period m a :=\n  le_of_not_gt fun period_lt_n =>\n    moved _ period_pos period_lt_n <| pow_period_smul m a\n\n"}
{"name":"MulAction.le_period","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\nm : M\na : α\nn : Nat\nperiod_pos : LT.lt 0 (MulAction.period m a)\nmoved : ∀ (k : Nat), LT.lt 0 k → LT.lt k n → Ne (HSMul.hSMul (HPow.hPow m k) a) a\n⊢ LE.le n (MulAction.period m a)","decl":"/-- If the action is periodic, then a lower bound for its period can be computed. -/\n@[to_additive \"If the action is periodic, then a lower bound for its period can be computed.\"]\ntheorem le_period {m : M} {a : α} {n : ℕ} (period_pos : 0 < period m a)\n    (moved : ∀ k, 0 < k → k < n → m ^ k • a ≠ a) : n ≤ period m a :=\n  le_of_not_gt fun period_lt_n =>\n    moved _ period_pos period_lt_n <| pow_period_smul m a\n\n"}
{"name":"MulAction.period_le_of_fixed","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\nm : M\na : α\nn : Nat\nn_pos : LT.lt 0 n\nfixed : Eq (HSMul.hSMul (HPow.hPow m n) a) a\n⊢ LE.le (MulAction.period m a) n","decl":"/-- If for some `n`, `m ^ n • a = a`, then `period m a ≤ n`. -/\n@[to_additive \"If for some `n`, `(n • m) +ᵥ a = a`, then `period m a ≤ n`.\"]\ntheorem period_le_of_fixed {m : M} {a : α} {n : ℕ} (n_pos : 0 < n) (fixed : m ^ n • a = a) :\n    period m a ≤ n :=\n  (isPeriodicPt_smul_iff.mpr fixed).minimalPeriod_le n_pos\n\n"}
{"name":"AddAction.period_le_of_fixed","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\nm : M\na : α\nn : Nat\nn_pos : LT.lt 0 n\nfixed : Eq (HVAdd.hVAdd (HSMul.hSMul n m) a) a\n⊢ LE.le (AddAction.period m a) n","decl":"/-- If for some `n`, `m ^ n • a = a`, then `period m a ≤ n`. -/\n@[to_additive \"If for some `n`, `(n • m) +ᵥ a = a`, then `period m a ≤ n`.\"]\ntheorem period_le_of_fixed {m : M} {a : α} {n : ℕ} (n_pos : 0 < n) (fixed : m ^ n • a = a) :\n    period m a ≤ n :=\n  (isPeriodicPt_smul_iff.mpr fixed).minimalPeriod_le n_pos\n\n"}
{"name":"AddAction.period_pos_of_fixed","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\nm : M\na : α\nn : Nat\nn_pos : LT.lt 0 n\nfixed : Eq (HVAdd.hVAdd (HSMul.hSMul n m) a) a\n⊢ LT.lt 0 (AddAction.period m a)","decl":"/-- If for some `n`, `m ^ n • a = a`, then `0 < period m a`. -/\n@[to_additive \"If for some `n`, `(n • m) +ᵥ a = a`, then `0 < period m a`.\"]\ntheorem period_pos_of_fixed {m : M} {a : α} {n : ℕ} (n_pos : 0 < n) (fixed : m ^ n • a = a) :\n    0 < period m a :=\n  (isPeriodicPt_smul_iff.mpr fixed).minimalPeriod_pos n_pos\n\n"}
{"name":"MulAction.period_pos_of_fixed","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\nm : M\na : α\nn : Nat\nn_pos : LT.lt 0 n\nfixed : Eq (HSMul.hSMul (HPow.hPow m n) a) a\n⊢ LT.lt 0 (MulAction.period m a)","decl":"/-- If for some `n`, `m ^ n • a = a`, then `0 < period m a`. -/\n@[to_additive \"If for some `n`, `(n • m) +ᵥ a = a`, then `0 < period m a`.\"]\ntheorem period_pos_of_fixed {m : M} {a : α} {n : ℕ} (n_pos : 0 < n) (fixed : m ^ n • a = a) :\n    0 < period m a :=\n  (isPeriodicPt_smul_iff.mpr fixed).minimalPeriod_pos n_pos\n\n"}
{"name":"MulAction.period_eq_one_iff","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\nm : M\na : α\n⊢ Iff (Eq (MulAction.period m a) 1) (Eq (HSMul.hSMul m a) a)","decl":"@[to_additive]\ntheorem period_eq_one_iff {m : M} {a : α} : period m a = 1 ↔ m • a = a :=\n  ⟨fun eq_one => pow_one m ▸ eq_one ▸ pow_period_smul m a,\n   fun fixed => le_antisymm\n    (period_le_of_fixed one_pos (by simpa))\n    (period_pos_of_fixed one_pos (by simpa))⟩\n\n"}
{"name":"AddAction.period_eq_zero_iff","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\nm : M\na : α\n⊢ Iff (Eq (AddAction.period m a) 1) (Eq (HVAdd.hVAdd m a) a)","decl":"@[to_additive]\ntheorem period_eq_one_iff {m : M} {a : α} : period m a = 1 ↔ m • a = a :=\n  ⟨fun eq_one => pow_one m ▸ eq_one ▸ pow_period_smul m a,\n   fun fixed => le_antisymm\n    (period_le_of_fixed one_pos (by simpa))\n    (period_pos_of_fixed one_pos (by simpa))⟩\n\n"}
{"name":"AddAction.nsmul_vadd_ne_of_lt_period","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\nm : M\na : α\nn : Nat\nn_pos : LT.lt 0 n\nn_lt_period : LT.lt n (AddAction.period m a)\n⊢ Ne (HVAdd.hVAdd (HSMul.hSMul n m) a) a","decl":"/-- For any non-zero `n` less than the period of `m` on `a`, `a` is moved by `m ^ n`. -/\n@[to_additive \"For any non-zero `n` less than the period of `m` on `a`, `a` is moved by `n • m`.\"]\ntheorem pow_smul_ne_of_lt_period {m : M} {a : α} {n : ℕ} (n_pos : 0 < n)\n    (n_lt_period : n < period m a) : m ^ n • a ≠ a := fun a_fixed =>\n  not_le_of_gt n_lt_period <| period_le_of_fixed n_pos a_fixed\n\n"}
{"name":"MulAction.pow_smul_ne_of_lt_period","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\nm : M\na : α\nn : Nat\nn_pos : LT.lt 0 n\nn_lt_period : LT.lt n (MulAction.period m a)\n⊢ Ne (HSMul.hSMul (HPow.hPow m n) a) a","decl":"/-- For any non-zero `n` less than the period of `m` on `a`, `a` is moved by `m ^ n`. -/\n@[to_additive \"For any non-zero `n` less than the period of `m` on `a`, `a` is moved by `n • m`.\"]\ntheorem pow_smul_ne_of_lt_period {m : M} {a : α} {n : ℕ} (n_pos : 0 < n)\n    (n_lt_period : n < period m a) : m ^ n • a ≠ a := fun a_fixed =>\n  not_le_of_gt n_lt_period <| period_le_of_fixed n_pos a_fixed\n\n"}
{"name":"AddAction.period_zero","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\na : α\n⊢ Eq (AddAction.period 0 a) 1","decl":"variable (M) in\n@[to_additive (attr := simp)]\ntheorem period_one (a : α) : period (1 : M) a = 1 := period_eq_one_iff.mpr (one_smul M a)\n\n"}
{"name":"MulAction.period_one","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\na : α\n⊢ Eq (MulAction.period 1 a) 1","decl":"variable (M) in\n@[to_additive (attr := simp)]\ntheorem period_one (a : α) : period (1 : M) a = 1 := period_eq_one_iff.mpr (one_smul M a)\n\n"}
{"name":"AddAction.period_neg","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nG : Type u\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ng : G\na : α\n⊢ Eq (AddAction.period (Neg.neg g) a) (AddAction.period g a)","decl":"@[to_additive (attr := simp)]\ntheorem period_inv (g : G) (a : α) : period g⁻¹ a = period g a := by\n  simp only [period_eq_minimalPeriod, Function.minimalPeriod_eq_minimalPeriod_iff,\n    isPeriodicPt_smul_iff]\n  intro n\n  rw [smul_eq_iff_eq_inv_smul, eq_comm, ← zpow_natCast, inv_zpow, inv_inv, zpow_natCast]\n\n"}
{"name":"MulAction.period_inv","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nG : Type u\ninst✝¹ : Group G\ninst✝ : MulAction G α\ng : G\na : α\n⊢ Eq (MulAction.period (Inv.inv g) a) (MulAction.period g a)","decl":"@[to_additive (attr := simp)]\ntheorem period_inv (g : G) (a : α) : period g⁻¹ a = period g a := by\n  simp only [period_eq_minimalPeriod, Function.minimalPeriod_eq_minimalPeriod_iff,\n    isPeriodicPt_smul_iff]\n  intro n\n  rw [smul_eq_iff_eq_inv_smul, eq_comm, ← zpow_natCast, inv_zpow, inv_inv, zpow_natCast]\n\n"}
{"name":"AddAction.period_dvd_addOrderOf","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\nm : M\na : α\n⊢ Dvd.dvd (AddAction.period m a) (addOrderOf m)","decl":"@[to_additive]\ntheorem period_dvd_orderOf (m : M) (a : α) : period m a ∣ orderOf m := by\n  rw [← pow_smul_eq_iff_period_dvd, pow_orderOf_eq_one, one_smul]\n\n"}
{"name":"MulAction.period_dvd_orderOf","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\nm : M\na : α\n⊢ Dvd.dvd (MulAction.period m a) (orderOf m)","decl":"@[to_additive]\ntheorem period_dvd_orderOf (m : M) (a : α) : period m a ∣ orderOf m := by\n  rw [← pow_smul_eq_iff_period_dvd, pow_orderOf_eq_one, one_smul]\n\n"}
{"name":"MulAction.period_pos_of_orderOf_pos","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\nm : M\norder_pos : LT.lt 0 (orderOf m)\na : α\n⊢ LT.lt 0 (MulAction.period m a)","decl":"@[to_additive]\ntheorem period_pos_of_orderOf_pos {m : M} (order_pos : 0 < orderOf m) (a : α) :\n    0 < period m a :=\n  Nat.pos_of_dvd_of_pos (period_dvd_orderOf m a) order_pos\n\n"}
{"name":"AddAction.period_pos_of_addOrderOf_pos","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\nm : M\norder_pos : LT.lt 0 (addOrderOf m)\na : α\n⊢ LT.lt 0 (AddAction.period m a)","decl":"@[to_additive]\ntheorem period_pos_of_orderOf_pos {m : M} (order_pos : 0 < orderOf m) (a : α) :\n    0 < period m a :=\n  Nat.pos_of_dvd_of_pos (period_dvd_orderOf m a) order_pos\n\n"}
{"name":"AddAction.period_le_addOrderOf","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\nm : M\norder_pos : LT.lt 0 (addOrderOf m)\na : α\n⊢ LE.le (AddAction.period m a) (addOrderOf m)","decl":"@[to_additive]\ntheorem period_le_orderOf {m : M} (order_pos : 0 < orderOf m) (a : α) :\n    period m a ≤ orderOf m :=\n  Nat.le_of_dvd order_pos (period_dvd_orderOf m a)\n\n"}
{"name":"MulAction.period_le_orderOf","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\nm : M\norder_pos : LT.lt 0 (orderOf m)\na : α\n⊢ LE.le (MulAction.period m a) (orderOf m)","decl":"@[to_additive]\ntheorem period_le_orderOf {m : M} (order_pos : 0 < orderOf m) (a : α) :\n    period m a ≤ orderOf m :=\n  Nat.le_of_dvd order_pos (period_dvd_orderOf m a)\n\n"}
{"name":"AddAction.period_dvd_exponent","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\nm : M\na : α\n⊢ Dvd.dvd (AddAction.period m a) (AddMonoid.exponent M)","decl":"@[to_additive]\ntheorem period_dvd_exponent (m : M) (a : α) : period m a ∣ Monoid.exponent M := by\n  rw [← pow_smul_eq_iff_period_dvd, Monoid.pow_exponent_eq_one, one_smul]\n\n"}
{"name":"MulAction.period_dvd_exponent","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\nm : M\na : α\n⊢ Dvd.dvd (MulAction.period m a) (Monoid.exponent M)","decl":"@[to_additive]\ntheorem period_dvd_exponent (m : M) (a : α) : period m a ∣ Monoid.exponent M := by\n  rw [← pow_smul_eq_iff_period_dvd, Monoid.pow_exponent_eq_one, one_smul]\n\n"}
{"name":"MulAction.period_pos_of_exponent_pos","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\nexp_pos : LT.lt 0 (Monoid.exponent M)\nm : M\na : α\n⊢ LT.lt 0 (MulAction.period m a)","decl":"@[to_additive]\ntheorem period_pos_of_exponent_pos (exp_pos : 0 < Monoid.exponent M) (m : M) (a : α) :\n    0 < period m a :=\n  Nat.pos_of_dvd_of_pos (period_dvd_exponent m a) exp_pos\n\n"}
{"name":"AddAction.period_pos_of_exponent_pos","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\nexp_pos : LT.lt 0 (AddMonoid.exponent M)\nm : M\na : α\n⊢ LT.lt 0 (AddAction.period m a)","decl":"@[to_additive]\ntheorem period_pos_of_exponent_pos (exp_pos : 0 < Monoid.exponent M) (m : M) (a : α) :\n    0 < period m a :=\n  Nat.pos_of_dvd_of_pos (period_dvd_exponent m a) exp_pos\n\n"}
{"name":"MulAction.period_le_exponent","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\nexp_pos : LT.lt 0 (Monoid.exponent M)\nm : M\na : α\n⊢ LE.le (MulAction.period m a) (Monoid.exponent M)","decl":"@[to_additive]\ntheorem period_le_exponent (exp_pos : 0 < Monoid.exponent M) (m : M) (a : α) :\n    period m a ≤ Monoid.exponent M :=\n  Nat.le_of_dvd exp_pos (period_dvd_exponent m a)\n\n"}
{"name":"AddAction.period_le_exponent","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\nexp_pos : LT.lt 0 (AddMonoid.exponent M)\nm : M\na : α\n⊢ LE.le (AddAction.period m a) (AddMonoid.exponent M)","decl":"@[to_additive]\ntheorem period_le_exponent (exp_pos : 0 < Monoid.exponent M) (m : M) (a : α) :\n    period m a ≤ Monoid.exponent M :=\n  Nat.le_of_dvd exp_pos (period_dvd_exponent m a)\n\n"}
{"name":"MulAction.period_bounded_of_exponent_pos","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\nexp_pos : LT.lt 0 (Monoid.exponent M)\nm : M\n⊢ BddAbove (Set.range fun a => MulAction.period m a)","decl":"@[to_additive]\ntheorem period_bounded_of_exponent_pos (exp_pos : 0 < Monoid.exponent M) (m : M) :\n    BddAbove (Set.range (fun a : α => period m a)) := by\n  use Monoid.exponent M\n  simpa [upperBounds] using period_le_exponent exp_pos _\n\n"}
{"name":"AddAction.period_bounded_of_exponent_pos","module":"Mathlib.GroupTheory.GroupAction.Period","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\nexp_pos : LT.lt 0 (AddMonoid.exponent M)\nm : M\n⊢ BddAbove (Set.range fun a => AddAction.period m a)","decl":"@[to_additive]\ntheorem period_bounded_of_exponent_pos (exp_pos : 0 < Monoid.exponent M) (m : M) :\n    BddAbove (Set.range (fun a : α => period m a)) := by\n  use Monoid.exponent M\n  simpa [upperBounds] using period_le_exponent exp_pos _\n\n"}
