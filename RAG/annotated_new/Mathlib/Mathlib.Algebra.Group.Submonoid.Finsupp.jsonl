{"name":"AddSubmonoid.exists_finsupp_of_mem_closure_range","module":"Mathlib.Algebra.Group.Submonoid.Finsupp","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nι : Type u_2\nf : ι → M\nx : M\nhx : Membership.mem (AddSubmonoid.closure (Set.range f)) x\n⊢ Exists fun a => Eq x (a.sum fun x1 x2 => HSMul.hSMul x2 (f x1))","decl":"@[to_additive]\ntheorem exists_finsupp_of_mem_closure_range (hx : x ∈ closure (Set.range f)) :\n    ∃ a : ι →₀ ℕ, x = a.prod (f · ^ ·) := by\n  classical\n  induction hx using closure_induction with\n  | mem x h => obtain ⟨i, rfl⟩ := h; exact ⟨Finsupp.single i 1, by simp⟩\n  | one => use 0; simp\n  | mul x y hx hy hx' hy' =>\n    obtain ⟨⟨v, rfl⟩, w, rfl⟩ := And.intro hx' hy'\n    use v + w\n    rw [Finsupp.prod_add_index]\n    · simp\n    · simp [pow_add]\n\n"}
{"name":"Submonoid.exists_finsupp_of_mem_closure_range","module":"Mathlib.Algebra.Group.Submonoid.Finsupp","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nι : Type u_2\nf : ι → M\nx : M\nhx : Membership.mem (Submonoid.closure (Set.range f)) x\n⊢ Exists fun a => Eq x (a.prod fun x1 x2 => HPow.hPow (f x1) x2)","decl":"@[to_additive]\ntheorem exists_finsupp_of_mem_closure_range (hx : x ∈ closure (Set.range f)) :\n    ∃ a : ι →₀ ℕ, x = a.prod (f · ^ ·) := by\n  classical\n  induction hx using closure_induction with\n  | mem x h => obtain ⟨i, rfl⟩ := h; exact ⟨Finsupp.single i 1, by simp⟩\n  | one => use 0; simp\n  | mul x y hx hy hx' hy' =>\n    obtain ⟨⟨v, rfl⟩, w, rfl⟩ := And.intro hx' hy'\n    use v + w\n    rw [Finsupp.prod_add_index]\n    · simp\n    · simp [pow_add]\n\n"}
{"name":"AddSubmonoid.mem_closure_range_iff","module":"Mathlib.Algebra.Group.Submonoid.Finsupp","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nι : Type u_2\nf : ι → M\nx : M\n⊢ Iff (Membership.mem (AddSubmonoid.closure (Set.range f)) x) (Exists fun a => Eq x (a.sum fun x1 x2 => HSMul.hSMul x2 (f x1)))","decl":"variable {f x} in\n@[to_additive]\ntheorem mem_closure_range_iff :\n    x ∈ closure (Set.range f) ↔ ∃ a : ι →₀ ℕ, x = a.prod (f · ^ ·) := by\n  refine ⟨exists_finsupp_of_mem_closure_range f x, ?_⟩\n  rintro ⟨a, rfl⟩\n  exact prod_mem _ fun i hi ↦ pow_mem (subset_closure (Set.mem_range_self i)) _\n\n"}
{"name":"Submonoid.mem_closure_range_iff","module":"Mathlib.Algebra.Group.Submonoid.Finsupp","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nι : Type u_2\nf : ι → M\nx : M\n⊢ Iff (Membership.mem (Submonoid.closure (Set.range f)) x) (Exists fun a => Eq x (a.prod fun x1 x2 => HPow.hPow (f x1) x2))","decl":"variable {f x} in\n@[to_additive]\ntheorem mem_closure_range_iff :\n    x ∈ closure (Set.range f) ↔ ∃ a : ι →₀ ℕ, x = a.prod (f · ^ ·) := by\n  refine ⟨exists_finsupp_of_mem_closure_range f x, ?_⟩\n  rintro ⟨a, rfl⟩\n  exact prod_mem _ fun i hi ↦ pow_mem (subset_closure (Set.mem_range_self i)) _\n\n"}
{"name":"Submonoid.exists_of_mem_closure_range","module":"Mathlib.Algebra.Group.Submonoid.Finsupp","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nι : Type u_2\nf : ι → M\nx : M\ninst✝ : Fintype ι\nhx : Membership.mem (Submonoid.closure (Set.range f)) x\n⊢ Exists fun a => Eq x (Finset.univ.prod fun i => HPow.hPow (f i) (a i))","decl":"@[to_additive]\ntheorem exists_of_mem_closure_range [Fintype ι] (hx : x ∈ closure (Set.range f)) :\n    ∃ a : ι → ℕ, x = ∏ i, f i ^ a i := by\n  obtain ⟨a, rfl⟩ := exists_finsupp_of_mem_closure_range f x hx\n  exact ⟨a, by simp⟩\n\n"}
{"name":"AddSubmonoid.exists_of_mem_closure_range","module":"Mathlib.Algebra.Group.Submonoid.Finsupp","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nι : Type u_2\nf : ι → M\nx : M\ninst✝ : Fintype ι\nhx : Membership.mem (AddSubmonoid.closure (Set.range f)) x\n⊢ Exists fun a => Eq x (Finset.univ.sum fun i => HSMul.hSMul (a i) (f i))","decl":"@[to_additive]\ntheorem exists_of_mem_closure_range [Fintype ι] (hx : x ∈ closure (Set.range f)) :\n    ∃ a : ι → ℕ, x = ∏ i, f i ^ a i := by\n  obtain ⟨a, rfl⟩ := exists_finsupp_of_mem_closure_range f x hx\n  exact ⟨a, by simp⟩\n\n"}
{"name":"AddSubmonoid.mem_closure_range_iff_of_fintype","module":"Mathlib.Algebra.Group.Submonoid.Finsupp","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nι : Type u_2\nf : ι → M\nx : M\ninst✝ : Fintype ι\n⊢ Iff (Membership.mem (AddSubmonoid.closure (Set.range f)) x) (Exists fun a => Eq x (Finset.univ.sum fun i => HSMul.hSMul (a i) (f i)))","decl":"variable {f x} in\n@[to_additive]\ntheorem mem_closure_range_iff_of_fintype [Fintype ι] :\n    x ∈ closure (Set.range f) ↔ ∃ a : ι → ℕ, x = ∏ i, f i ^ a i := by\n  rw [Finsupp.equivFunOnFinite.symm.exists_congr_left, mem_closure_range_iff]\n  simp\n\n"}
{"name":"Submonoid.mem_closure_range_iff_of_fintype","module":"Mathlib.Algebra.Group.Submonoid.Finsupp","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nι : Type u_2\nf : ι → M\nx : M\ninst✝ : Fintype ι\n⊢ Iff (Membership.mem (Submonoid.closure (Set.range f)) x) (Exists fun a => Eq x (Finset.univ.prod fun i => HPow.hPow (f i) (a i)))","decl":"variable {f x} in\n@[to_additive]\ntheorem mem_closure_range_iff_of_fintype [Fintype ι] :\n    x ∈ closure (Set.range f) ↔ ∃ a : ι → ℕ, x = ∏ i, f i ^ a i := by\n  rw [Finsupp.equivFunOnFinite.symm.exists_congr_left, mem_closure_range_iff]\n  simp\n\n"}
