{"name":"Complex.hasStrictFDerivAt_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"p : Prod Complex Complex\nhp : Membership.mem Complex.slitPlane p.1\n⊢ HasStrictFDerivAt (fun x => HPow.hPow x.1 x.2) (HAdd.hAdd (HSMul.hSMul (HMul.hMul p.2 (HPow.hPow p.1 (HSub.hSub p.2 1))) (ContinuousLinearMap.fst Complex Complex Complex)) (HSMul.hSMul (HMul.hMul (HPow.hPow p.1 p.2) (Complex.log p.1)) (ContinuousLinearMap.snd Complex Complex Complex))) p","decl":"theorem hasStrictFDerivAt_cpow {p : ℂ × ℂ} (hp : p.1 ∈ slitPlane) :\n    HasStrictFDerivAt (fun x : ℂ × ℂ => x.1 ^ x.2)\n      ((p.2 * p.1 ^ (p.2 - 1)) • ContinuousLinearMap.fst ℂ ℂ ℂ +\n        (p.1 ^ p.2 * log p.1) • ContinuousLinearMap.snd ℂ ℂ ℂ) p := by\n  have A : p.1 ≠ 0 := slitPlane_ne_zero hp\n  have : (fun x : ℂ × ℂ => x.1 ^ x.2) =ᶠ[𝓝 p] fun x => exp (log x.1 * x.2) :=\n    ((isOpen_ne.preimage continuous_fst).eventually_mem A).mono fun p hp =>\n      cpow_def_of_ne_zero hp _\n  rw [cpow_sub _ _ A, cpow_one, mul_div_left_comm, mul_smul, mul_smul]\n  refine HasStrictFDerivAt.congr_of_eventuallyEq ?_ this.symm\n  simpa only [cpow_def_of_ne_zero A, div_eq_mul_inv, mul_smul, add_comm, smul_add] using\n    ((hasStrictFDerivAt_fst.clog hp).mul hasStrictFDerivAt_snd).cexp\n\n"}
{"name":"Complex.hasStrictFDerivAt_cpow'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"x y : Complex\nhp : Membership.mem Complex.slitPlane x\n⊢ HasStrictFDerivAt (fun x => HPow.hPow x.1 x.2) (HAdd.hAdd (HSMul.hSMul (HMul.hMul y (HPow.hPow x (HSub.hSub y 1))) (ContinuousLinearMap.fst Complex Complex Complex)) (HSMul.hSMul (HMul.hMul (HPow.hPow x y) (Complex.log x)) (ContinuousLinearMap.snd Complex Complex Complex))) { fst := x, snd := y }","decl":"theorem hasStrictFDerivAt_cpow' {x y : ℂ} (hp : x ∈ slitPlane) :\n    HasStrictFDerivAt (fun x : ℂ × ℂ => x.1 ^ x.2)\n      ((y * x ^ (y - 1)) • ContinuousLinearMap.fst ℂ ℂ ℂ +\n        (x ^ y * log x) • ContinuousLinearMap.snd ℂ ℂ ℂ) (x, y) :=\n  @hasStrictFDerivAt_cpow (x, y) hp\n\n"}
{"name":"Complex.hasStrictDerivAt_const_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"x y : Complex\nh : Or (Ne x 0) (Ne y 0)\n⊢ HasStrictDerivAt (fun y => HPow.hPow x y) (HMul.hMul (HPow.hPow x y) (Complex.log x)) y","decl":"theorem hasStrictDerivAt_const_cpow {x y : ℂ} (h : x ≠ 0 ∨ y ≠ 0) :\n    HasStrictDerivAt (fun y => x ^ y) (x ^ y * log x) y := by\n  rcases em (x = 0) with (rfl | hx)\n  · replace h := h.neg_resolve_left rfl\n    rw [log_zero, mul_zero]\n    refine (hasStrictDerivAt_const y 0).congr_of_eventuallyEq ?_\n    exact (isOpen_ne.eventually_mem h).mono fun y hy => (zero_cpow hy).symm\n  · simpa only [cpow_def_of_ne_zero hx, mul_one] using\n      ((hasStrictDerivAt_id y).const_mul (log x)).cexp\n\n"}
{"name":"Complex.hasFDerivAt_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"p : Prod Complex Complex\nhp : Membership.mem Complex.slitPlane p.1\n⊢ HasFDerivAt (fun x => HPow.hPow x.1 x.2) (HAdd.hAdd (HSMul.hSMul (HMul.hMul p.2 (HPow.hPow p.1 (HSub.hSub p.2 1))) (ContinuousLinearMap.fst Complex Complex Complex)) (HSMul.hSMul (HMul.hMul (HPow.hPow p.1 p.2) (Complex.log p.1)) (ContinuousLinearMap.snd Complex Complex Complex))) p","decl":"theorem hasFDerivAt_cpow {p : ℂ × ℂ} (hp : p.1 ∈ slitPlane) :\n    HasFDerivAt (fun x : ℂ × ℂ => x.1 ^ x.2)\n      ((p.2 * p.1 ^ (p.2 - 1)) • ContinuousLinearMap.fst ℂ ℂ ℂ +\n        (p.1 ^ p.2 * log p.1) • ContinuousLinearMap.snd ℂ ℂ ℂ) p :=\n  (hasStrictFDerivAt_cpow hp).hasFDerivAt\n\n"}
{"name":"HasStrictFDerivAt.cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf g : E → Complex\nf' g' : ContinuousLinearMap (RingHom.id Complex) E Complex\nx : E\nhf : HasStrictFDerivAt f f' x\nhg : HasStrictFDerivAt g g' x\nh0 : Membership.mem Complex.slitPlane (f x)\n⊢ HasStrictFDerivAt (fun x => HPow.hPow (f x) (g x)) (HAdd.hAdd (HSMul.hSMul (HMul.hMul (g x) (HPow.hPow (f x) (HSub.hSub (g x) 1))) f') (HSMul.hSMul (HMul.hMul (HPow.hPow (f x) (g x)) (Complex.log (f x))) g')) x","decl":"theorem HasStrictFDerivAt.cpow (hf : HasStrictFDerivAt f f' x) (hg : HasStrictFDerivAt g g' x)\n    (h0 : f x ∈ slitPlane) : HasStrictFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) • f' + (f x ^ g x * Complex.log (f x)) • g') x := by\n  convert (@hasStrictFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp x (hf.prod hg)\n\n"}
{"name":"HasStrictFDerivAt.const_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : E → Complex\nf' : ContinuousLinearMap (RingHom.id Complex) E Complex\nx : E\nc : Complex\nhf : HasStrictFDerivAt f f' x\nh0 : Or (Ne c 0) (Ne (f x) 0)\n⊢ HasStrictFDerivAt (fun x => HPow.hPow c (f x)) (HSMul.hSMul (HMul.hMul (HPow.hPow c (f x)) (Complex.log c)) f') x","decl":"theorem HasStrictFDerivAt.const_cpow (hf : HasStrictFDerivAt f f' x) (h0 : c ≠ 0 ∨ f x ≠ 0) :\n    HasStrictFDerivAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) • f') x :=\n  (hasStrictDerivAt_const_cpow h0).comp_hasStrictFDerivAt x hf\n\n"}
{"name":"HasFDerivAt.cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf g : E → Complex\nf' g' : ContinuousLinearMap (RingHom.id Complex) E Complex\nx : E\nhf : HasFDerivAt f f' x\nhg : HasFDerivAt g g' x\nh0 : Membership.mem Complex.slitPlane (f x)\n⊢ HasFDerivAt (fun x => HPow.hPow (f x) (g x)) (HAdd.hAdd (HSMul.hSMul (HMul.hMul (g x) (HPow.hPow (f x) (HSub.hSub (g x) 1))) f') (HSMul.hSMul (HMul.hMul (HPow.hPow (f x) (g x)) (Complex.log (f x))) g')) x","decl":"theorem HasFDerivAt.cpow (hf : HasFDerivAt f f' x) (hg : HasFDerivAt g g' x)\n    (h0 : f x ∈ slitPlane) : HasFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) • f' + (f x ^ g x * Complex.log (f x)) • g') x := by\n  convert (@Complex.hasFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp x (hf.prod hg)\n\n"}
{"name":"HasFDerivAt.const_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : E → Complex\nf' : ContinuousLinearMap (RingHom.id Complex) E Complex\nx : E\nc : Complex\nhf : HasFDerivAt f f' x\nh0 : Or (Ne c 0) (Ne (f x) 0)\n⊢ HasFDerivAt (fun x => HPow.hPow c (f x)) (HSMul.hSMul (HMul.hMul (HPow.hPow c (f x)) (Complex.log c)) f') x","decl":"theorem HasFDerivAt.const_cpow (hf : HasFDerivAt f f' x) (h0 : c ≠ 0 ∨ f x ≠ 0) :\n    HasFDerivAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) • f') x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasFDerivAt x hf\n\n"}
{"name":"HasFDerivWithinAt.cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf g : E → Complex\nf' g' : ContinuousLinearMap (RingHom.id Complex) E Complex\nx : E\ns : Set E\nhf : HasFDerivWithinAt f f' s x\nhg : HasFDerivWithinAt g g' s x\nh0 : Membership.mem Complex.slitPlane (f x)\n⊢ HasFDerivWithinAt (fun x => HPow.hPow (f x) (g x)) (HAdd.hAdd (HSMul.hSMul (HMul.hMul (g x) (HPow.hPow (f x) (HSub.hSub (g x) 1))) f') (HSMul.hSMul (HMul.hMul (HPow.hPow (f x) (g x)) (Complex.log (f x))) g')) s x","decl":"theorem HasFDerivWithinAt.cpow (hf : HasFDerivWithinAt f f' s x) (hg : HasFDerivWithinAt g g' s x)\n    (h0 : f x ∈ slitPlane) : HasFDerivWithinAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) • f' + (f x ^ g x * Complex.log (f x)) • g') s x := by\n  convert\n    (@Complex.hasFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp_hasFDerivWithinAt x (hf.prod hg)\n\n"}
{"name":"HasFDerivWithinAt.const_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : E → Complex\nf' : ContinuousLinearMap (RingHom.id Complex) E Complex\nx : E\ns : Set E\nc : Complex\nhf : HasFDerivWithinAt f f' s x\nh0 : Or (Ne c 0) (Ne (f x) 0)\n⊢ HasFDerivWithinAt (fun x => HPow.hPow c (f x)) (HSMul.hSMul (HMul.hMul (HPow.hPow c (f x)) (Complex.log c)) f') s x","decl":"theorem HasFDerivWithinAt.const_cpow (hf : HasFDerivWithinAt f f' s x) (h0 : c ≠ 0 ∨ f x ≠ 0) :\n    HasFDerivWithinAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) • f') s x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasFDerivWithinAt x hf\n\n"}
{"name":"DifferentiableAt.cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf g : E → Complex\nx : E\nhf : DifferentiableAt Complex f x\nhg : DifferentiableAt Complex g x\nh0 : Membership.mem Complex.slitPlane (f x)\n⊢ DifferentiableAt Complex (fun x => HPow.hPow (f x) (g x)) x","decl":"theorem DifferentiableAt.cpow (hf : DifferentiableAt ℂ f x) (hg : DifferentiableAt ℂ g x)\n    (h0 : f x ∈ slitPlane) : DifferentiableAt ℂ (fun x => f x ^ g x) x :=\n  (hf.hasFDerivAt.cpow hg.hasFDerivAt h0).differentiableAt\n\n"}
{"name":"DifferentiableAt.const_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : E → Complex\nx : E\nc : Complex\nhf : DifferentiableAt Complex f x\nh0 : Or (Ne c 0) (Ne (f x) 0)\n⊢ DifferentiableAt Complex (fun x => HPow.hPow c (f x)) x","decl":"theorem DifferentiableAt.const_cpow (hf : DifferentiableAt ℂ f x) (h0 : c ≠ 0 ∨ f x ≠ 0) :\n    DifferentiableAt ℂ (fun x => c ^ f x) x :=\n  (hf.hasFDerivAt.const_cpow h0).differentiableAt\n\n"}
{"name":"DifferentiableAt.cpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : E → Complex\nx : E\nc : Complex\nhf : DifferentiableAt Complex f x\nh0 : Membership.mem Complex.slitPlane (f x)\n⊢ DifferentiableAt Complex (fun x => HPow.hPow (f x) c) x","decl":"theorem DifferentiableAt.cpow_const (hf : DifferentiableAt ℂ f x) (h0 : f x ∈ slitPlane) :\n    DifferentiableAt ℂ (fun x => f x ^ c) x :=\n  hf.cpow (differentiableAt_const c) h0\n\n"}
{"name":"DifferentiableWithinAt.cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf g : E → Complex\nx : E\ns : Set E\nhf : DifferentiableWithinAt Complex f s x\nhg : DifferentiableWithinAt Complex g s x\nh0 : Membership.mem Complex.slitPlane (f x)\n⊢ DifferentiableWithinAt Complex (fun x => HPow.hPow (f x) (g x)) s x","decl":"theorem DifferentiableWithinAt.cpow (hf : DifferentiableWithinAt ℂ f s x)\n    (hg : DifferentiableWithinAt ℂ g s x) (h0 : f x ∈ slitPlane) :\n    DifferentiableWithinAt ℂ (fun x => f x ^ g x) s x :=\n  (hf.hasFDerivWithinAt.cpow hg.hasFDerivWithinAt h0).differentiableWithinAt\n\n"}
{"name":"DifferentiableWithinAt.const_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : E → Complex\nx : E\ns : Set E\nc : Complex\nhf : DifferentiableWithinAt Complex f s x\nh0 : Or (Ne c 0) (Ne (f x) 0)\n⊢ DifferentiableWithinAt Complex (fun x => HPow.hPow c (f x)) s x","decl":"theorem DifferentiableWithinAt.const_cpow (hf : DifferentiableWithinAt ℂ f s x)\n    (h0 : c ≠ 0 ∨ f x ≠ 0) : DifferentiableWithinAt ℂ (fun x => c ^ f x) s x :=\n  (hf.hasFDerivWithinAt.const_cpow h0).differentiableWithinAt\n\n"}
{"name":"DifferentiableWithinAt.cpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : E → Complex\nx : E\ns : Set E\nc : Complex\nhf : DifferentiableWithinAt Complex f s x\nh0 : Membership.mem Complex.slitPlane (f x)\n⊢ DifferentiableWithinAt Complex (fun x => HPow.hPow (f x) c) s x","decl":"theorem DifferentiableWithinAt.cpow_const (hf : DifferentiableWithinAt ℂ f s x)\n    (h0 : f x ∈ slitPlane) :\n    DifferentiableWithinAt ℂ (fun x => f x ^ c) s x :=\n  hf.cpow (differentiableWithinAt_const c) h0\n\n"}
{"name":"DifferentiableOn.cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf g : E → Complex\ns : Set E\nhf : DifferentiableOn Complex f s\nhg : DifferentiableOn Complex g s\nh0 : Set.MapsTo f s Complex.slitPlane\n⊢ DifferentiableOn Complex (fun x => HPow.hPow (f x) (g x)) s","decl":"theorem DifferentiableOn.cpow (hf : DifferentiableOn ℂ f s) (hg : DifferentiableOn ℂ g s)\n    (h0 : Set.MapsTo f s slitPlane) : DifferentiableOn ℂ (fun x ↦ f x ^ g x) s :=\n  fun x hx ↦ (hf x hx).cpow (hg x hx) (h0 hx)\n\n"}
{"name":"DifferentiableOn.const_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : E → Complex\ns : Set E\nc : Complex\nhf : DifferentiableOn Complex f s\nh0 : Or (Ne c 0) (∀ (x : E), Membership.mem s x → Ne (f x) 0)\n⊢ DifferentiableOn Complex (fun x => HPow.hPow c (f x)) s","decl":"theorem DifferentiableOn.const_cpow (hf : DifferentiableOn ℂ f s)\n    (h0 : c ≠ 0 ∨ ∀ x ∈ s, f x ≠ 0) : DifferentiableOn ℂ (fun x ↦ c ^ f x) s :=\n  fun x hx ↦ (hf x hx).const_cpow (h0.imp_right fun h ↦ h x hx)\n\n"}
{"name":"DifferentiableOn.cpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : E → Complex\ns : Set E\nc : Complex\nhf : DifferentiableOn Complex f s\nh0 : ∀ (x : E), Membership.mem s x → Membership.mem Complex.slitPlane (f x)\n⊢ DifferentiableOn Complex (fun x => HPow.hPow (f x) c) s","decl":"theorem DifferentiableOn.cpow_const (hf : DifferentiableOn ℂ f s)\n    (h0 : ∀ x ∈ s, f x ∈ slitPlane) :\n    DifferentiableOn ℂ (fun x => f x ^ c) s :=\n  hf.cpow (differentiableOn_const c) h0\n\n"}
{"name":"Differentiable.cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf g : E → Complex\nhf : Differentiable Complex f\nhg : Differentiable Complex g\nh0 : ∀ (x : E), Membership.mem Complex.slitPlane (f x)\n⊢ Differentiable Complex fun x => HPow.hPow (f x) (g x)","decl":"theorem Differentiable.cpow (hf : Differentiable ℂ f) (hg : Differentiable ℂ g)\n    (h0 : ∀ x, f x ∈ slitPlane) : Differentiable ℂ (fun x ↦ f x ^ g x) :=\n  fun x ↦ (hf x).cpow (hg x) (h0 x)\n\n"}
{"name":"Differentiable.const_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : E → Complex\nc : Complex\nhf : Differentiable Complex f\nh0 : Or (Ne c 0) (∀ (x : E), Ne (f x) 0)\n⊢ Differentiable Complex fun x => HPow.hPow c (f x)","decl":"theorem Differentiable.const_cpow (hf : Differentiable ℂ f)\n    (h0 : c ≠ 0 ∨ ∀ x, f x ≠ 0) : Differentiable ℂ (fun x ↦ c ^ f x) :=\n  fun x ↦ (hf x).const_cpow (h0.imp_right fun h ↦ h x)\n\n"}
{"name":"differentiable_const_cpow_of_neZero","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"z : Complex\ninst✝ : NeZero z\n⊢ Differentiable Complex fun s => HPow.hPow z s","decl":"@[fun_prop]\nlemma differentiable_const_cpow_of_neZero (z : ℂ) [NeZero z] :\n    Differentiable ℂ fun s : ℂ ↦ z ^ s :=\n  differentiable_id.const_cpow (.inl <| NeZero.ne z)\n\n"}
{"name":"differentiableAt_const_cpow_of_neZero","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"z : Complex\ninst✝ : NeZero z\nt : Complex\n⊢ DifferentiableAt Complex (fun s => HPow.hPow z s) t","decl":"@[fun_prop]\nlemma differentiableAt_const_cpow_of_neZero (z : ℂ) [NeZero z] (t : ℂ) :\n    DifferentiableAt ℂ (fun s : ℂ ↦ z ^ s) t :=\n  differentiableAt_id.const_cpow (.inl <| NeZero.ne z)\n\n"}
{"name":"HasStrictDerivAt.cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"f g : Complex → Complex\nf' g' x : Complex\nhf : HasStrictDerivAt f f' x\nhg : HasStrictDerivAt g g' x\nh0 : Membership.mem Complex.slitPlane (f x)\n⊢ HasStrictDerivAt (fun x => HPow.hPow (f x) (g x)) (HAdd.hAdd (HMul.hMul (HMul.hMul (g x) (HPow.hPow (f x) (HSub.hSub (g x) 1))) f') (HMul.hMul (HMul.hMul (HPow.hPow (f x) (g x)) (Complex.log (f x))) g')) x","decl":"nonrec theorem HasStrictDerivAt.cpow (hf : HasStrictDerivAt f f' x) (hg : HasStrictDerivAt g g' x)\n    (h0 : f x ∈ slitPlane) : HasStrictDerivAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') x := by\n  simpa using (hf.cpow hg h0).hasStrictDerivAt\n\n"}
{"name":"HasStrictDerivAt.const_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"f : Complex → Complex\nf' x c : Complex\nhf : HasStrictDerivAt f f' x\nh : Or (Ne c 0) (Ne (f x) 0)\n⊢ HasStrictDerivAt (fun x => HPow.hPow c (f x)) (HMul.hMul (HMul.hMul (HPow.hPow c (f x)) (Complex.log c)) f') x","decl":"theorem HasStrictDerivAt.const_cpow (hf : HasStrictDerivAt f f' x) (h : c ≠ 0 ∨ f x ≠ 0) :\n    HasStrictDerivAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') x :=\n  (hasStrictDerivAt_const_cpow h).comp x hf\n\n"}
{"name":"Complex.hasStrictDerivAt_cpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"x c : Complex\nh : Membership.mem Complex.slitPlane x\n⊢ HasStrictDerivAt (fun z => HPow.hPow z c) (HMul.hMul c (HPow.hPow x (HSub.hSub c 1))) x","decl":"theorem Complex.hasStrictDerivAt_cpow_const (h : x ∈ slitPlane) :\n    HasStrictDerivAt (fun z : ℂ => z ^ c) (c * x ^ (c - 1)) x := by\n  simpa only [mul_zero, add_zero, mul_one] using\n    (hasStrictDerivAt_id x).cpow (hasStrictDerivAt_const x c) h\n\n"}
{"name":"HasStrictDerivAt.cpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"f : Complex → Complex\nf' x c : Complex\nhf : HasStrictDerivAt f f' x\nh0 : Membership.mem Complex.slitPlane (f x)\n⊢ HasStrictDerivAt (fun x => HPow.hPow (f x) c) (HMul.hMul (HMul.hMul c (HPow.hPow (f x) (HSub.hSub c 1))) f') x","decl":"theorem HasStrictDerivAt.cpow_const (hf : HasStrictDerivAt f f' x)\n    (h0 : f x ∈ slitPlane) :\n    HasStrictDerivAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).comp x hf\n\n"}
{"name":"HasDerivAt.cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"f g : Complex → Complex\nf' g' x : Complex\nhf : HasDerivAt f f' x\nhg : HasDerivAt g g' x\nh0 : Membership.mem Complex.slitPlane (f x)\n⊢ HasDerivAt (fun x => HPow.hPow (f x) (g x)) (HAdd.hAdd (HMul.hMul (HMul.hMul (g x) (HPow.hPow (f x) (HSub.hSub (g x) 1))) f') (HMul.hMul (HMul.hMul (HPow.hPow (f x) (g x)) (Complex.log (f x))) g')) x","decl":"theorem HasDerivAt.cpow (hf : HasDerivAt f f' x) (hg : HasDerivAt g g' x)\n    (h0 : f x ∈ slitPlane) : HasDerivAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') x := by\n  simpa only [aux] using (hf.hasFDerivAt.cpow hg h0).hasDerivAt\n\n"}
{"name":"HasDerivAt.const_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"f : Complex → Complex\nf' x c : Complex\nhf : HasDerivAt f f' x\nh0 : Or (Ne c 0) (Ne (f x) 0)\n⊢ HasDerivAt (fun x => HPow.hPow c (f x)) (HMul.hMul (HMul.hMul (HPow.hPow c (f x)) (Complex.log c)) f') x","decl":"theorem HasDerivAt.const_cpow (hf : HasDerivAt f f' x) (h0 : c ≠ 0 ∨ f x ≠ 0) :\n    HasDerivAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp x hf\n\n"}
{"name":"HasDerivAt.cpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"f : Complex → Complex\nf' x c : Complex\nhf : HasDerivAt f f' x\nh0 : Membership.mem Complex.slitPlane (f x)\n⊢ HasDerivAt (fun x => HPow.hPow (f x) c) (HMul.hMul (HMul.hMul c (HPow.hPow (f x) (HSub.hSub c 1))) f') x","decl":"theorem HasDerivAt.cpow_const (hf : HasDerivAt f f' x) (h0 : f x ∈ slitPlane) :\n    HasDerivAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).hasDerivAt.comp x hf\n\n"}
{"name":"HasDerivWithinAt.cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"f g : Complex → Complex\ns : Set Complex\nf' g' x : Complex\nhf : HasDerivWithinAt f f' s x\nhg : HasDerivWithinAt g g' s x\nh0 : Membership.mem Complex.slitPlane (f x)\n⊢ HasDerivWithinAt (fun x => HPow.hPow (f x) (g x)) (HAdd.hAdd (HMul.hMul (HMul.hMul (g x) (HPow.hPow (f x) (HSub.hSub (g x) 1))) f') (HMul.hMul (HMul.hMul (HPow.hPow (f x) (g x)) (Complex.log (f x))) g')) s x","decl":"theorem HasDerivWithinAt.cpow (hf : HasDerivWithinAt f f' s x) (hg : HasDerivWithinAt g g' s x)\n    (h0 : f x ∈ slitPlane) : HasDerivWithinAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') s x := by\n  simpa only [aux] using (hf.hasFDerivWithinAt.cpow hg h0).hasDerivWithinAt\n\n"}
{"name":"HasDerivWithinAt.const_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"f : Complex → Complex\ns : Set Complex\nf' x c : Complex\nhf : HasDerivWithinAt f f' s x\nh0 : Or (Ne c 0) (Ne (f x) 0)\n⊢ HasDerivWithinAt (fun x => HPow.hPow c (f x)) (HMul.hMul (HMul.hMul (HPow.hPow c (f x)) (Complex.log c)) f') s x","decl":"theorem HasDerivWithinAt.const_cpow (hf : HasDerivWithinAt f f' s x) (h0 : c ≠ 0 ∨ f x ≠ 0) :\n    HasDerivWithinAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') s x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasDerivWithinAt x hf\n\n"}
{"name":"HasDerivWithinAt.cpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"f : Complex → Complex\ns : Set Complex\nf' x c : Complex\nhf : HasDerivWithinAt f f' s x\nh0 : Membership.mem Complex.slitPlane (f x)\n⊢ HasDerivWithinAt (fun x => HPow.hPow (f x) c) (HMul.hMul (HMul.hMul c (HPow.hPow (f x) (HSub.hSub c 1))) f') s x","decl":"theorem HasDerivWithinAt.cpow_const (hf : HasDerivWithinAt f f' s x)\n    (h0 : f x ∈ slitPlane) :\n    HasDerivWithinAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') s x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).hasDerivAt.comp_hasDerivWithinAt x hf\n\n"}
{"name":"hasDerivAt_ofReal_cpow_const'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"x : Real\nhx : Ne x 0\nr : Complex\nhr : Ne r (-1)\n⊢ HasDerivAt (fun y => HDiv.hDiv (HPow.hPow (↑y) (HAdd.hAdd r 1)) (HAdd.hAdd r 1)) (HPow.hPow (↑x) r) x","decl":"/-- Although `fun x => x ^ r` for fixed `r` is *not* complex-differentiable along the negative real\nline, it is still real-differentiable, and the derivative is what one would formally expect.\nSee `hasDerivAt_ofReal_cpow_const` for an alternate formulation. -/\ntheorem hasDerivAt_ofReal_cpow_const' {x : ℝ} (hx : x ≠ 0) {r : ℂ} (hr : r ≠ -1) :\n    HasDerivAt (fun y : ℝ => (y : ℂ) ^ (r + 1) / (r + 1)) (x ^ r) x := by\n  rw [Ne, ← add_eq_zero_iff_eq_neg, ← Ne] at hr\n  rcases lt_or_gt_of_ne hx.symm with (hx | hx)\n  · -- easy case : `0 < x`\n    -- Porting note: proof used to be\n    -- convert (((hasDerivAt_id (x : ℂ)).cpow_const _).div_const (r + 1)).comp_ofReal using 1\n    -- · rw [add_sub_cancel, id.def, mul_one, mul_comm, mul_div_cancel _ hr]\n    -- · rw [id.def, ofReal_re]; exact Or.inl hx\n    apply HasDerivAt.comp_ofReal (e := fun y => (y : ℂ) ^ (r + 1) / (r + 1))\n    convert HasDerivAt.div_const (𝕜 := ℂ) ?_ (r + 1) using 1\n    · exact (mul_div_cancel_right₀ _ hr).symm\n    · convert HasDerivAt.cpow_const ?_ ?_ using 1\n      · rw [add_sub_cancel_right, mul_comm]; exact (mul_one _).symm\n      · exact hasDerivAt_id (x : ℂ)\n      · simp [hx]\n  · -- harder case : `x < 0`\n    have : ∀ᶠ y : ℝ in 𝓝 x,\n        (y : ℂ) ^ (r + 1) / (r + 1) = (-y : ℂ) ^ (r + 1) * exp (π * I * (r + 1)) / (r + 1) := by\n      refine Filter.eventually_of_mem (Iio_mem_nhds hx) fun y hy => ?_\n      rw [ofReal_cpow_of_nonpos (le_of_lt hy)]\n    refine HasDerivAt.congr_of_eventuallyEq ?_ this\n    rw [ofReal_cpow_of_nonpos (le_of_lt hx)]\n    suffices HasDerivAt (fun y : ℝ => (-↑y) ^ (r + 1) * exp (↑π * I * (r + 1)))\n        ((r + 1) * (-↑x) ^ r * exp (↑π * I * r)) x by\n      convert this.div_const (r + 1) using 1\n      conv_rhs => rw [mul_assoc, mul_comm, mul_div_cancel_right₀ _ hr]\n    rw [mul_add ((π : ℂ) * _), mul_one, exp_add, exp_pi_mul_I, mul_comm (_ : ℂ) (-1 : ℂ),\n      neg_one_mul]\n    simp_rw [mul_neg, ← neg_mul, ← ofReal_neg]\n    suffices HasDerivAt (fun y : ℝ => (↑(-y) : ℂ) ^ (r + 1)) (-(r + 1) * ↑(-x) ^ r) x by\n      convert this.neg.mul_const _ using 1; ring\n    suffices HasDerivAt (fun y : ℝ => (y : ℂ) ^ (r + 1)) ((r + 1) * ↑(-x) ^ r) (-x) by\n      convert @HasDerivAt.scomp ℝ _ ℂ _ _ x ℝ _ _ _ _ _ _ _ _ this (hasDerivAt_neg x) using 1\n      rw [real_smul, ofReal_neg 1, ofReal_one]; ring\n    suffices HasDerivAt (fun y : ℂ => y ^ (r + 1)) ((r + 1) * ↑(-x) ^ r) ↑(-x) by\n      exact this.comp_ofReal\n    conv in ↑_ ^ _ => rw [(by ring : r = r + 1 - 1)]\n    convert HasDerivAt.cpow_const ?_ ?_ using 1\n    · rw [add_sub_cancel_right, add_sub_cancel_right]; exact (mul_one _).symm\n    · exact hasDerivAt_id ((-x : ℝ) : ℂ)\n    · simp [hx]\n\n"}
{"name":"hasDerivAt_ofReal_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"x : Real\nhx : Ne x 0\nr : Complex\nhr : Ne r (-1)\n⊢ HasDerivAt (fun y => HDiv.hDiv (HPow.hPow (↑y) (HAdd.hAdd r 1)) (HAdd.hAdd r 1)) (HPow.hPow (↑x) r) x","decl":"@[deprecated (since := \"2024-12-15\")] alias hasDerivAt_ofReal_cpow := hasDerivAt_ofReal_cpow_const'\n\n"}
{"name":"hasDerivAt_ofReal_cpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"x : Real\nhx : Ne x 0\nr : Complex\nhr : Ne r 0\n⊢ HasDerivAt (fun y => HPow.hPow (↑y) r) (HMul.hMul r (HPow.hPow (↑x) (HSub.hSub r 1))) x","decl":"/-- An alternate formulation of `hasDerivAt_ofReal_cpow_const'`. -/\ntheorem hasDerivAt_ofReal_cpow_const {x : ℝ} (hx : x ≠ 0) {r : ℂ} (hr : r ≠ 0) :\n    HasDerivAt (fun y : ℝ => (y : ℂ) ^ r) (r * x ^ (r - 1)) x := by\n  have := HasDerivAt.const_mul r <| hasDerivAt_ofReal_cpow_const' hx\n    (by rwa [ne_eq, sub_eq_neg_self])\n  simpa [sub_add_cancel, mul_div_cancel₀ _ hr] using this\n\n"}
{"name":"DifferentiableAt.ofReal_cpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"c : Complex\nf : Real → Real\nx : Real\nhf : DifferentiableAt Real f x\nh0 : Ne (f x) 0\nh1 : Ne c 0\n⊢ DifferentiableAt Real (fun y => HPow.hPow (↑(f y)) c) x","decl":"/-- A version of `DifferentiableAt.cpow_const` for a real function. -/\ntheorem DifferentiableAt.ofReal_cpow_const {f : ℝ → ℝ} {x : ℝ} (hf : DifferentiableAt ℝ f x)\n    (h0 : f x ≠ 0) (h1 : c ≠ 0) :\n    DifferentiableAt ℝ (fun (y : ℝ) => (f y : ℂ) ^ c) x :=\n  (hasDerivAt_ofReal_cpow_const h0 h1).differentiableAt.comp x hf\n\n"}
{"name":"Complex.deriv_cpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"x c : Complex\nhx : Membership.mem Complex.slitPlane x\n⊢ Eq (deriv (fun x => HPow.hPow x c) x) (HMul.hMul c (HPow.hPow x (HSub.hSub c 1)))","decl":"theorem Complex.deriv_cpow_const (hx : x ∈ Complex.slitPlane) :\n    deriv (fun (x : ℂ) ↦ x ^ c) x = c * x ^ (c - 1) :=\n  (hasStrictDerivAt_cpow_const hx).hasDerivAt.deriv\n\n"}
{"name":"Complex.deriv_ofReal_cpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"c : Complex\nx : Real\nhx : Ne x 0\nhc : Ne c 0\n⊢ Eq (deriv (fun x => HPow.hPow (↑x) c) x) (HMul.hMul c (HPow.hPow (↑x) (HSub.hSub c 1)))","decl":"/-- A version of `Complex.deriv_cpow_const` for a real variable. -/\ntheorem Complex.deriv_ofReal_cpow_const {x : ℝ} (hx : x ≠ 0) (hc : c ≠ 0) :\n    deriv (fun x : ℝ ↦ (x : ℂ) ^ c) x = c * x ^ (c - 1) :=\n  (hasDerivAt_ofReal_cpow_const hx hc).deriv\n\n"}
{"name":"deriv_cpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"f : Complex → Complex\nx c : Complex\nhf : DifferentiableAt Complex f x\nhx : Membership.mem Complex.slitPlane (f x)\n⊢ Eq (deriv (fun x => HPow.hPow (f x) c) x) (HMul.hMul (HMul.hMul c (HPow.hPow (f x) (HSub.hSub c 1))) (deriv f x))","decl":"theorem deriv_cpow_const (hf : DifferentiableAt ℂ f x) (hx : f x ∈ Complex.slitPlane) :\n    deriv (fun (x : ℂ) ↦ f x ^ c) x = c * f x ^ (c - 1) * deriv f x :=\n  (hf.hasDerivAt.cpow_const hx).deriv\n\n"}
{"name":"isTheta_deriv_ofReal_cpow_const_atTop","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"c : Complex\nhc : Ne c 0\n⊢ Asymptotics.IsTheta Filter.atTop (deriv fun x => HPow.hPow (↑x) c) fun x => HPow.hPow x (HSub.hSub c.re 1)","decl":"theorem isTheta_deriv_ofReal_cpow_const_atTop {c : ℂ} (hc : c ≠ 0) :\n    deriv (fun (x : ℝ) => (x : ℂ) ^ c) =Θ[atTop] fun x => x ^ (c.re - 1) := by\n  calc\n    _ =ᶠ[atTop] fun x : ℝ ↦ c * x ^ (c - 1) := by\n      filter_upwards [eventually_ne_atTop 0] with x hx using by rw [deriv_ofReal_cpow_const hx hc]\n    _ =Θ[atTop] fun x : ℝ ↦ ‖(x : ℂ) ^ (c - 1)‖ :=\n      (Asymptotics.IsTheta.of_norm_eventuallyEq EventuallyEq.rfl).const_mul_left hc\n    _ =ᶠ[atTop] fun x ↦ x ^ (c.re - 1) := by\n      filter_upwards [eventually_gt_atTop 0] with x hx\n      rw [norm_eq_abs, abs_cpow_eq_rpow_re_of_pos hx, sub_re, one_re]\n\n"}
{"name":"isBigO_deriv_ofReal_cpow_const_atTop","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"c : Complex\n⊢ Asymptotics.IsBigO Filter.atTop (deriv fun x => HPow.hPow (↑x) c) fun x => HPow.hPow x (HSub.hSub c.re 1)","decl":"theorem isBigO_deriv_ofReal_cpow_const_atTop (c : ℂ) :\n    deriv (fun (x : ℝ) => (x : ℂ) ^ c) =O[atTop] fun x => x ^ (c.re - 1) := by\n  obtain rfl | hc := eq_or_ne c 0\n  · simp_rw [cpow_zero, deriv_const', Asymptotics.isBigO_zero]\n  · exact (isTheta_deriv_ofReal_cpow_const_atTop hc).1\n\n"}
{"name":"Real.hasStrictFDerivAt_rpow_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"p : Prod Real Real\nhp : LT.lt 0 p.1\n⊢ HasStrictFDerivAt (fun x => HPow.hPow x.1 x.2) (HAdd.hAdd (HSMul.hSMul (HMul.hMul p.2 (HPow.hPow p.1 (HSub.hSub p.2 1))) (ContinuousLinearMap.fst Real Real Real)) (HSMul.hSMul (HMul.hMul (HPow.hPow p.1 p.2) (Real.log p.1)) (ContinuousLinearMap.snd Real Real Real))) p","decl":"/-- `(x, y) ↦ x ^ y` is strictly differentiable at `p : ℝ × ℝ` such that `0 < p.fst`. -/\ntheorem hasStrictFDerivAt_rpow_of_pos (p : ℝ × ℝ) (hp : 0 < p.1) :\n    HasStrictFDerivAt (fun x : ℝ × ℝ => x.1 ^ x.2)\n      ((p.2 * p.1 ^ (p.2 - 1)) • ContinuousLinearMap.fst ℝ ℝ ℝ +\n        (p.1 ^ p.2 * log p.1) • ContinuousLinearMap.snd ℝ ℝ ℝ) p := by\n  have : (fun x : ℝ × ℝ => x.1 ^ x.2) =ᶠ[𝓝 p] fun x => exp (log x.1 * x.2) :=\n    (continuousAt_fst.eventually (lt_mem_nhds hp)).mono fun p hp => rpow_def_of_pos hp _\n  refine HasStrictFDerivAt.congr_of_eventuallyEq ?_ this.symm\n  convert ((hasStrictFDerivAt_fst.log hp.ne').mul hasStrictFDerivAt_snd).exp using 1\n  rw [rpow_sub_one hp.ne', ← rpow_def_of_pos hp, smul_add, smul_smul, mul_div_left_comm,\n    div_eq_mul_inv, smul_smul, smul_smul, mul_assoc, add_comm]\n\n"}
{"name":"Real.hasStrictFDerivAt_rpow_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"p : Prod Real Real\nhp : LT.lt p.1 0\n⊢ HasStrictFDerivAt (fun x => HPow.hPow x.1 x.2) (HAdd.hAdd (HSMul.hSMul (HMul.hMul p.2 (HPow.hPow p.1 (HSub.hSub p.2 1))) (ContinuousLinearMap.fst Real Real Real)) (HSMul.hSMul (HSub.hSub (HMul.hMul (HPow.hPow p.1 p.2) (Real.log p.1)) (HMul.hMul (HMul.hMul (Real.exp (HMul.hMul (Real.log p.1) p.2)) (Real.sin (HMul.hMul p.2 Real.pi))) Real.pi)) (ContinuousLinearMap.snd Real Real Real))) p","decl":"/-- `(x, y) ↦ x ^ y` is strictly differentiable at `p : ℝ × ℝ` such that `p.fst < 0`. -/\ntheorem hasStrictFDerivAt_rpow_of_neg (p : ℝ × ℝ) (hp : p.1 < 0) :\n    HasStrictFDerivAt (fun x : ℝ × ℝ => x.1 ^ x.2)\n      ((p.2 * p.1 ^ (p.2 - 1)) • ContinuousLinearMap.fst ℝ ℝ ℝ +\n        (p.1 ^ p.2 * log p.1 - exp (log p.1 * p.2) * sin (p.2 * π) * π) •\n          ContinuousLinearMap.snd ℝ ℝ ℝ) p := by\n  have : (fun x : ℝ × ℝ => x.1 ^ x.2) =ᶠ[𝓝 p] fun x => exp (log x.1 * x.2) * cos (x.2 * π) :=\n    (continuousAt_fst.eventually (gt_mem_nhds hp)).mono fun p hp => rpow_def_of_neg hp _\n  refine HasStrictFDerivAt.congr_of_eventuallyEq ?_ this.symm\n  convert ((hasStrictFDerivAt_fst.log hp.ne).mul hasStrictFDerivAt_snd).exp.mul\n    (hasStrictFDerivAt_snd.mul_const π).cos using 1\n  simp_rw [rpow_sub_one hp.ne, smul_add, ← add_assoc, smul_smul, ← add_smul, ← mul_assoc,\n    mul_comm (cos _), ← rpow_def_of_neg hp]\n  rw [div_eq_mul_inv, add_comm]; congr 2 <;> ring\n\n"}
{"name":"Real.contDiffAt_rpow_of_ne","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"p : Prod Real Real\nhp : Ne p.1 0\nn : WithTop ENat\n⊢ ContDiffAt Real n (fun p => HPow.hPow p.1 p.2) p","decl":"/-- The function `fun (x, y) => x ^ y` is infinitely smooth at `(x, y)` unless `x = 0`. -/\ntheorem contDiffAt_rpow_of_ne (p : ℝ × ℝ) (hp : p.1 ≠ 0) {n : WithTop ℕ∞} :\n    ContDiffAt ℝ n (fun p : ℝ × ℝ => p.1 ^ p.2) p := by\n  cases' hp.lt_or_lt with hneg hpos\n  exacts\n    [(((contDiffAt_fst.log hneg.ne).mul contDiffAt_snd).exp.mul\n          (contDiffAt_snd.mul contDiffAt_const).cos).congr_of_eventuallyEq\n      ((continuousAt_fst.eventually (gt_mem_nhds hneg)).mono fun p hp => rpow_def_of_neg hp _),\n    ((contDiffAt_fst.log hpos.ne').mul contDiffAt_snd).exp.congr_of_eventuallyEq\n      ((continuousAt_fst.eventually (lt_mem_nhds hpos)).mono fun p hp => rpow_def_of_pos hp _)]\n\n"}
{"name":"Real.differentiableAt_rpow_of_ne","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"p : Prod Real Real\nhp : Ne p.1 0\n⊢ DifferentiableAt Real (fun p => HPow.hPow p.1 p.2) p","decl":"theorem differentiableAt_rpow_of_ne (p : ℝ × ℝ) (hp : p.1 ≠ 0) :\n    DifferentiableAt ℝ (fun p : ℝ × ℝ => p.1 ^ p.2) p :=\n  (contDiffAt_rpow_of_ne p hp).differentiableAt le_rfl\n\n"}
{"name":"HasStrictDerivAt.rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"x : Real\nf g : Real → Real\nf' g' : Real\nhf : HasStrictDerivAt f f' x\nhg : HasStrictDerivAt g g' x\nh : LT.lt 0 (f x)\n⊢ HasStrictDerivAt (fun x => HPow.hPow (f x) (g x)) (HAdd.hAdd (HMul.hMul (HMul.hMul f' (g x)) (HPow.hPow (f x) (HSub.hSub (g x) 1))) (HMul.hMul (HMul.hMul g' (HPow.hPow (f x) (g x))) (Real.log (f x)))) x","decl":"theorem _root_.HasStrictDerivAt.rpow {f g : ℝ → ℝ} {f' g' : ℝ} (hf : HasStrictDerivAt f f' x)\n    (hg : HasStrictDerivAt g g' x) (h : 0 < f x) : HasStrictDerivAt (fun x => f x ^ g x)\n      (f' * g x * f x ^ (g x - 1) + g' * f x ^ g x * Real.log (f x)) x := by\n  convert (hasStrictFDerivAt_rpow_of_pos ((fun x => (f x, g x)) x) h).comp_hasStrictDerivAt x\n    (hf.prod hg) using 1\n  simp [mul_assoc, mul_comm, mul_left_comm]\n\n"}
{"name":"Real.hasStrictDerivAt_rpow_const_of_ne","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"x : Real\nhx : Ne x 0\np : Real\n⊢ HasStrictDerivAt (fun x => HPow.hPow x p) (HMul.hMul p (HPow.hPow x (HSub.hSub p 1))) x","decl":"theorem hasStrictDerivAt_rpow_const_of_ne {x : ℝ} (hx : x ≠ 0) (p : ℝ) :\n    HasStrictDerivAt (fun x => x ^ p) (p * x ^ (p - 1)) x := by\n  cases' hx.lt_or_lt with hx hx\n  · have := (hasStrictFDerivAt_rpow_of_neg (x, p) hx).comp_hasStrictDerivAt x\n      ((hasStrictDerivAt_id x).prod (hasStrictDerivAt_const x p))\n    convert this using 1; simp\n  · simpa using (hasStrictDerivAt_id x).rpow (hasStrictDerivAt_const x p) hx\n\n"}
{"name":"Real.hasStrictDerivAt_const_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"a : Real\nha : LT.lt 0 a\nx : Real\n⊢ HasStrictDerivAt (fun x => HPow.hPow a x) (HMul.hMul (HPow.hPow a x) (Real.log a)) x","decl":"theorem hasStrictDerivAt_const_rpow {a : ℝ} (ha : 0 < a) (x : ℝ) :\n    HasStrictDerivAt (fun x => a ^ x) (a ^ x * log a) x := by\n  simpa using (hasStrictDerivAt_const _ _).rpow (hasStrictDerivAt_id x) ha\n\n"}
{"name":"Real.differentiableAt_rpow_const_of_ne","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"p x : Real\nhx : Ne x 0\n⊢ DifferentiableAt Real (fun x => HPow.hPow x p) x","decl":"lemma differentiableAt_rpow_const_of_ne (p : ℝ) {x : ℝ} (hx : x ≠ 0) :\n    DifferentiableAt ℝ (fun x => x ^ p) x :=\n  (hasStrictDerivAt_rpow_const_of_ne hx p).differentiableAt\n\n"}
{"name":"Real.differentiableOn_rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"p : Real\n⊢ DifferentiableOn Real (fun x => HPow.hPow x p) (HasCompl.compl (Singleton.singleton 0))","decl":"lemma differentiableOn_rpow_const (p : ℝ) :\n    DifferentiableOn ℝ (fun x => (x : ℝ) ^ p) {0}ᶜ :=\n  fun _ hx => (Real.differentiableAt_rpow_const_of_ne p hx).differentiableWithinAt\n\n"}
{"name":"Real.hasStrictDerivAt_const_rpow_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"a x : Real\nha : LT.lt a 0\n⊢ HasStrictDerivAt (fun x => HPow.hPow a x) (HSub.hSub (HMul.hMul (HPow.hPow a x) (Real.log a)) (HMul.hMul (HMul.hMul (Real.exp (HMul.hMul (Real.log a) x)) (Real.sin (HMul.hMul x Real.pi))) Real.pi)) x","decl":"/-- This lemma says that `fun x => a ^ x` is strictly differentiable for `a < 0`. Note that these\nvalues of `a` are outside of the \"official\" domain of `a ^ x`, and we may redefine `a ^ x`\nfor negative `a` if some other definition will be more convenient. -/\ntheorem hasStrictDerivAt_const_rpow_of_neg {a x : ℝ} (ha : a < 0) :\n    HasStrictDerivAt (fun x => a ^ x) (a ^ x * log a - exp (log a * x) * sin (x * π) * π) x := by\n  simpa using (hasStrictFDerivAt_rpow_of_neg (a, x) ha).comp_hasStrictDerivAt x\n    ((hasStrictDerivAt_const _ _).prod (hasStrictDerivAt_id _))\n\n"}
{"name":"Real.hasDerivAt_rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"x p : Real\nh : Or (Ne x 0) (LE.le 1 p)\n⊢ HasDerivAt (fun x => HPow.hPow x p) (HMul.hMul p (HPow.hPow x (HSub.hSub p 1))) x","decl":"theorem hasDerivAt_rpow_const {x p : ℝ} (h : x ≠ 0 ∨ 1 ≤ p) :\n    HasDerivAt (fun x => x ^ p) (p * x ^ (p - 1)) x := by\n  rcases ne_or_eq x 0 with (hx | rfl)\n  · exact (hasStrictDerivAt_rpow_const_of_ne hx _).hasDerivAt\n  replace h : 1 ≤ p := h.neg_resolve_left rfl\n  apply hasDerivAt_of_hasDerivAt_of_ne fun x hx =>\n    (hasStrictDerivAt_rpow_const_of_ne hx p).hasDerivAt\n  exacts [continuousAt_id.rpow_const (Or.inr (zero_le_one.trans h)),\n    continuousAt_const.mul (continuousAt_id.rpow_const (Or.inr (sub_nonneg.2 h)))]\n\n"}
{"name":"Real.differentiable_rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"p : Real\nhp : LE.le 1 p\n⊢ Differentiable Real fun x => HPow.hPow x p","decl":"theorem differentiable_rpow_const {p : ℝ} (hp : 1 ≤ p) : Differentiable ℝ fun x : ℝ => x ^ p :=\n  fun _ => (hasDerivAt_rpow_const (Or.inr hp)).differentiableAt\n\n"}
{"name":"Real.deriv_rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"x p : Real\nh : Or (Ne x 0) (LE.le 1 p)\n⊢ Eq (deriv (fun x => HPow.hPow x p) x) (HMul.hMul p (HPow.hPow x (HSub.hSub p 1)))","decl":"theorem deriv_rpow_const {x p : ℝ} (h : x ≠ 0 ∨ 1 ≤ p) :\n    deriv (fun x : ℝ => x ^ p) x = p * x ^ (p - 1) :=\n  (hasDerivAt_rpow_const h).deriv\n\n"}
{"name":"Real.deriv_rpow_const'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"p : Real\nh : LE.le 1 p\n⊢ Eq (deriv fun x => HPow.hPow x p) fun x => HMul.hMul p (HPow.hPow x (HSub.hSub p 1))","decl":"theorem deriv_rpow_const' {p : ℝ} (h : 1 ≤ p) :\n    (deriv fun x : ℝ => x ^ p) = fun x => p * x ^ (p - 1) :=\n  funext fun _ => deriv_rpow_const (Or.inr h)\n\n"}
{"name":"Real.contDiffAt_rpow_const_of_ne","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"x p : Real\nn : WithTop ENat\nh : Ne x 0\n⊢ ContDiffAt Real n (fun x => HPow.hPow x p) x","decl":"theorem contDiffAt_rpow_const_of_ne {x p : ℝ} {n : WithTop ℕ∞} (h : x ≠ 0) :\n    ContDiffAt ℝ n (fun x => x ^ p) x :=\n  (contDiffAt_rpow_of_ne (x, p) h).comp x (contDiffAt_id.prod contDiffAt_const)\n\n"}
{"name":"Real.contDiff_rpow_const_of_le","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"p : Real\nn : Nat\nh : LE.le (↑n) p\n⊢ ContDiff Real ↑n fun x => HPow.hPow x p","decl":"theorem contDiff_rpow_const_of_le {p : ℝ} {n : ℕ} (h : ↑n ≤ p) :\n    ContDiff ℝ n fun x : ℝ => x ^ p := by\n  induction' n with n ihn generalizing p\n  · exact contDiff_zero.2 (continuous_id.rpow_const fun x => Or.inr <| by simpa using h)\n  · have h1 : 1 ≤ p := le_trans (by simp) h\n    rw [Nat.cast_succ, ← le_sub_iff_add_le] at h\n    rw [show ((n + 1 : ℕ) : WithTop ℕ∞) = n + 1 from rfl,\n      contDiff_succ_iff_deriv, deriv_rpow_const' h1]\n    simp only [WithTop.natCast_ne_top, analyticOn_univ, IsEmpty.forall_iff, true_and]\n    exact ⟨differentiable_rpow_const h1, contDiff_const.mul (ihn h)⟩\n\n"}
{"name":"Real.contDiffAt_rpow_const_of_le","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"x p : Real\nn : Nat\nh : LE.le (↑n) p\n⊢ ContDiffAt Real (↑n) (fun x => HPow.hPow x p) x","decl":"theorem contDiffAt_rpow_const_of_le {x p : ℝ} {n : ℕ} (h : ↑n ≤ p) :\n    ContDiffAt ℝ n (fun x : ℝ => x ^ p) x :=\n  (contDiff_rpow_const_of_le h).contDiffAt\n\n"}
{"name":"Real.contDiffAt_rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"x p : Real\nn : Nat\nh : Or (Ne x 0) (LE.le (↑n) p)\n⊢ ContDiffAt Real (↑n) (fun x => HPow.hPow x p) x","decl":"theorem contDiffAt_rpow_const {x p : ℝ} {n : ℕ} (h : x ≠ 0 ∨ ↑n ≤ p) :\n    ContDiffAt ℝ n (fun x : ℝ => x ^ p) x :=\n  h.elim contDiffAt_rpow_const_of_ne contDiffAt_rpow_const_of_le\n\n"}
{"name":"Real.hasStrictDerivAt_rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"x p : Real\nhx : Or (Ne x 0) (LE.le 1 p)\n⊢ HasStrictDerivAt (fun x => HPow.hPow x p) (HMul.hMul p (HPow.hPow x (HSub.hSub p 1))) x","decl":"theorem hasStrictDerivAt_rpow_const {x p : ℝ} (hx : x ≠ 0 ∨ 1 ≤ p) :\n    HasStrictDerivAt (fun x => x ^ p) (p * x ^ (p - 1)) x :=\n  ContDiffAt.hasStrictDerivAt' (contDiffAt_rpow_const (by rwa [← Nat.cast_one] at hx))\n    (hasDerivAt_rpow_const hx) le_rfl\n\n"}
{"name":"HasFDerivWithinAt.rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf g : E → Real\nf' g' : ContinuousLinearMap (RingHom.id Real) E Real\nx : E\ns : Set E\nhf : HasFDerivWithinAt f f' s x\nhg : HasFDerivWithinAt g g' s x\nh : LT.lt 0 (f x)\n⊢ HasFDerivWithinAt (fun x => HPow.hPow (f x) (g x)) (HAdd.hAdd (HSMul.hSMul (HMul.hMul (g x) (HPow.hPow (f x) (HSub.hSub (g x) 1))) f') (HSMul.hSMul (HMul.hMul (HPow.hPow (f x) (g x)) (Real.log (f x))) g')) s x","decl":"theorem HasFDerivWithinAt.rpow (hf : HasFDerivWithinAt f f' s x) (hg : HasFDerivWithinAt g g' s x)\n    (h : 0 < f x) : HasFDerivWithinAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) • f' + (f x ^ g x * Real.log (f x)) • g') s x := by\n  exact (hasStrictFDerivAt_rpow_of_pos (f x, g x) h).hasFDerivAt.comp_hasFDerivWithinAt x\n    (hf.prod hg)\n\n"}
{"name":"HasFDerivAt.rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf g : E → Real\nf' g' : ContinuousLinearMap (RingHom.id Real) E Real\nx : E\nhf : HasFDerivAt f f' x\nhg : HasFDerivAt g g' x\nh : LT.lt 0 (f x)\n⊢ HasFDerivAt (fun x => HPow.hPow (f x) (g x)) (HAdd.hAdd (HSMul.hSMul (HMul.hMul (g x) (HPow.hPow (f x) (HSub.hSub (g x) 1))) f') (HSMul.hSMul (HMul.hMul (HPow.hPow (f x) (g x)) (Real.log (f x))) g')) x","decl":"theorem HasFDerivAt.rpow (hf : HasFDerivAt f f' x) (hg : HasFDerivAt g g' x) (h : 0 < f x) :\n    HasFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) • f' + (f x ^ g x * Real.log (f x)) • g') x := by\n  exact (hasStrictFDerivAt_rpow_of_pos (f x, g x) h).hasFDerivAt.comp x (hf.prod hg)\n\n"}
{"name":"HasStrictFDerivAt.rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf g : E → Real\nf' g' : ContinuousLinearMap (RingHom.id Real) E Real\nx : E\nhf : HasStrictFDerivAt f f' x\nhg : HasStrictFDerivAt g g' x\nh : LT.lt 0 (f x)\n⊢ HasStrictFDerivAt (fun x => HPow.hPow (f x) (g x)) (HAdd.hAdd (HSMul.hSMul (HMul.hMul (g x) (HPow.hPow (f x) (HSub.hSub (g x) 1))) f') (HSMul.hSMul (HMul.hMul (HPow.hPow (f x) (g x)) (Real.log (f x))) g')) x","decl":"theorem HasStrictFDerivAt.rpow (hf : HasStrictFDerivAt f f' x) (hg : HasStrictFDerivAt g g' x)\n    (h : 0 < f x) : HasStrictFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) • f' + (f x ^ g x * Real.log (f x)) • g') x :=\n  (hasStrictFDerivAt_rpow_of_pos (f x, g x) h).comp x (hf.prod hg)\n\n"}
{"name":"DifferentiableWithinAt.rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf g : E → Real\nx : E\ns : Set E\nhf : DifferentiableWithinAt Real f s x\nhg : DifferentiableWithinAt Real g s x\nh : Ne (f x) 0\n⊢ DifferentiableWithinAt Real (fun x => HPow.hPow (f x) (g x)) s x","decl":"theorem DifferentiableWithinAt.rpow (hf : DifferentiableWithinAt ℝ f s x)\n    (hg : DifferentiableWithinAt ℝ g s x) (h : f x ≠ 0) :\n    DifferentiableWithinAt ℝ (fun x => f x ^ g x) s x := by\n  exact (differentiableAt_rpow_of_ne (f x, g x) h).comp_differentiableWithinAt x (hf.prod hg)\n\n"}
{"name":"DifferentiableAt.rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf g : E → Real\nx : E\nhf : DifferentiableAt Real f x\nhg : DifferentiableAt Real g x\nh : Ne (f x) 0\n⊢ DifferentiableAt Real (fun x => HPow.hPow (f x) (g x)) x","decl":"theorem DifferentiableAt.rpow (hf : DifferentiableAt ℝ f x) (hg : DifferentiableAt ℝ g x)\n    (h : f x ≠ 0) : DifferentiableAt ℝ (fun x => f x ^ g x) x := by\n  exact (differentiableAt_rpow_of_ne (f x, g x) h).comp x (hf.prod hg)\n\n"}
{"name":"DifferentiableOn.rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf g : E → Real\ns : Set E\nhf : DifferentiableOn Real f s\nhg : DifferentiableOn Real g s\nh : ∀ (x : E), Membership.mem s x → Ne (f x) 0\n⊢ DifferentiableOn Real (fun x => HPow.hPow (f x) (g x)) s","decl":"theorem DifferentiableOn.rpow (hf : DifferentiableOn ℝ f s) (hg : DifferentiableOn ℝ g s)\n    (h : ∀ x ∈ s, f x ≠ 0) : DifferentiableOn ℝ (fun x => f x ^ g x) s := fun x hx =>\n  (hf x hx).rpow (hg x hx) (h x hx)\n\n"}
{"name":"Differentiable.rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf g : E → Real\nhf : Differentiable Real f\nhg : Differentiable Real g\nh : ∀ (x : E), Ne (f x) 0\n⊢ Differentiable Real fun x => HPow.hPow (f x) (g x)","decl":"theorem Differentiable.rpow (hf : Differentiable ℝ f) (hg : Differentiable ℝ g) (h : ∀ x, f x ≠ 0) :\n    Differentiable ℝ fun x => f x ^ g x := fun x => (hf x).rpow (hg x) (h x)\n\n"}
{"name":"HasFDerivWithinAt.rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nf' : ContinuousLinearMap (RingHom.id Real) E Real\nx : E\ns : Set E\np : Real\nhf : HasFDerivWithinAt f f' s x\nh : Or (Ne (f x) 0) (LE.le 1 p)\n⊢ HasFDerivWithinAt (fun x => HPow.hPow (f x) p) (HSMul.hSMul (HMul.hMul p (HPow.hPow (f x) (HSub.hSub p 1))) f') s x","decl":"theorem HasFDerivWithinAt.rpow_const (hf : HasFDerivWithinAt f f' s x) (h : f x ≠ 0 ∨ 1 ≤ p) :\n    HasFDerivWithinAt (fun x => f x ^ p) ((p * f x ^ (p - 1)) • f') s x :=\n  (hasDerivAt_rpow_const h).comp_hasFDerivWithinAt x hf\n\n"}
{"name":"HasFDerivAt.rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nf' : ContinuousLinearMap (RingHom.id Real) E Real\nx : E\np : Real\nhf : HasFDerivAt f f' x\nh : Or (Ne (f x) 0) (LE.le 1 p)\n⊢ HasFDerivAt (fun x => HPow.hPow (f x) p) (HSMul.hSMul (HMul.hMul p (HPow.hPow (f x) (HSub.hSub p 1))) f') x","decl":"theorem HasFDerivAt.rpow_const (hf : HasFDerivAt f f' x) (h : f x ≠ 0 ∨ 1 ≤ p) :\n    HasFDerivAt (fun x => f x ^ p) ((p * f x ^ (p - 1)) • f') x :=\n  (hasDerivAt_rpow_const h).comp_hasFDerivAt x hf\n\n"}
{"name":"HasStrictFDerivAt.rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nf' : ContinuousLinearMap (RingHom.id Real) E Real\nx : E\np : Real\nhf : HasStrictFDerivAt f f' x\nh : Or (Ne (f x) 0) (LE.le 1 p)\n⊢ HasStrictFDerivAt (fun x => HPow.hPow (f x) p) (HSMul.hSMul (HMul.hMul p (HPow.hPow (f x) (HSub.hSub p 1))) f') x","decl":"theorem HasStrictFDerivAt.rpow_const (hf : HasStrictFDerivAt f f' x) (h : f x ≠ 0 ∨ 1 ≤ p) :\n    HasStrictFDerivAt (fun x => f x ^ p) ((p * f x ^ (p - 1)) • f') x :=\n  (hasStrictDerivAt_rpow_const h).comp_hasStrictFDerivAt x hf\n\n"}
{"name":"DifferentiableWithinAt.rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nx : E\ns : Set E\np : Real\nhf : DifferentiableWithinAt Real f s x\nh : Or (Ne (f x) 0) (LE.le 1 p)\n⊢ DifferentiableWithinAt Real (fun x => HPow.hPow (f x) p) s x","decl":"theorem DifferentiableWithinAt.rpow_const (hf : DifferentiableWithinAt ℝ f s x)\n    (h : f x ≠ 0 ∨ 1 ≤ p) : DifferentiableWithinAt ℝ (fun x => f x ^ p) s x :=\n  (hf.hasFDerivWithinAt.rpow_const h).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nx : E\np : Real\nhf : DifferentiableAt Real f x\nh : Or (Ne (f x) 0) (LE.le 1 p)\n⊢ DifferentiableAt Real (fun x => HPow.hPow (f x) p) x","decl":"@[simp]\ntheorem DifferentiableAt.rpow_const (hf : DifferentiableAt ℝ f x) (h : f x ≠ 0 ∨ 1 ≤ p) :\n    DifferentiableAt ℝ (fun x => f x ^ p) x :=\n  (hf.hasFDerivAt.rpow_const h).differentiableAt\n\n"}
{"name":"DifferentiableOn.rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\ns : Set E\np : Real\nhf : DifferentiableOn Real f s\nh : ∀ (x : E), Membership.mem s x → Or (Ne (f x) 0) (LE.le 1 p)\n⊢ DifferentiableOn Real (fun x => HPow.hPow (f x) p) s","decl":"theorem DifferentiableOn.rpow_const (hf : DifferentiableOn ℝ f s) (h : ∀ x ∈ s, f x ≠ 0 ∨ 1 ≤ p) :\n    DifferentiableOn ℝ (fun x => f x ^ p) s := fun x hx => (hf x hx).rpow_const (h x hx)\n\n"}
{"name":"Differentiable.rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\np : Real\nhf : Differentiable Real f\nh : ∀ (x : E), Or (Ne (f x) 0) (LE.le 1 p)\n⊢ Differentiable Real fun x => HPow.hPow (f x) p","decl":"theorem Differentiable.rpow_const (hf : Differentiable ℝ f) (h : ∀ x, f x ≠ 0 ∨ 1 ≤ p) :\n    Differentiable ℝ fun x => f x ^ p := fun x => (hf x).rpow_const (h x)\n\n"}
{"name":"HasFDerivWithinAt.const_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nf' : ContinuousLinearMap (RingHom.id Real) E Real\nx : E\ns : Set E\nc : Real\nhf : HasFDerivWithinAt f f' s x\nhc : LT.lt 0 c\n⊢ HasFDerivWithinAt (fun x => HPow.hPow c (f x)) (HSMul.hSMul (HMul.hMul (HPow.hPow c (f x)) (Real.log c)) f') s x","decl":"theorem HasFDerivWithinAt.const_rpow (hf : HasFDerivWithinAt f f' s x) (hc : 0 < c) :\n    HasFDerivWithinAt (fun x => c ^ f x) ((c ^ f x * Real.log c) • f') s x :=\n  (hasStrictDerivAt_const_rpow hc (f x)).hasDerivAt.comp_hasFDerivWithinAt x hf\n\n"}
{"name":"HasFDerivAt.const_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nf' : ContinuousLinearMap (RingHom.id Real) E Real\nx : E\nc : Real\nhf : HasFDerivAt f f' x\nhc : LT.lt 0 c\n⊢ HasFDerivAt (fun x => HPow.hPow c (f x)) (HSMul.hSMul (HMul.hMul (HPow.hPow c (f x)) (Real.log c)) f') x","decl":"theorem HasFDerivAt.const_rpow (hf : HasFDerivAt f f' x) (hc : 0 < c) :\n    HasFDerivAt (fun x => c ^ f x) ((c ^ f x * Real.log c) • f') x :=\n  (hasStrictDerivAt_const_rpow hc (f x)).hasDerivAt.comp_hasFDerivAt x hf\n\n"}
{"name":"HasStrictFDerivAt.const_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nf' : ContinuousLinearMap (RingHom.id Real) E Real\nx : E\nc : Real\nhf : HasStrictFDerivAt f f' x\nhc : LT.lt 0 c\n⊢ HasStrictFDerivAt (fun x => HPow.hPow c (f x)) (HSMul.hSMul (HMul.hMul (HPow.hPow c (f x)) (Real.log c)) f') x","decl":"theorem HasStrictFDerivAt.const_rpow (hf : HasStrictFDerivAt f f' x) (hc : 0 < c) :\n    HasStrictFDerivAt (fun x => c ^ f x) ((c ^ f x * Real.log c) • f') x :=\n  (hasStrictDerivAt_const_rpow hc (f x)).comp_hasStrictFDerivAt x hf\n\n"}
{"name":"ContDiffWithinAt.rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf g : E → Real\nx : E\ns : Set E\nn : WithTop ENat\nhf : ContDiffWithinAt Real n f s x\nhg : ContDiffWithinAt Real n g s x\nh : Ne (f x) 0\n⊢ ContDiffWithinAt Real n (fun x => HPow.hPow (f x) (g x)) s x","decl":"theorem ContDiffWithinAt.rpow (hf : ContDiffWithinAt ℝ n f s x) (hg : ContDiffWithinAt ℝ n g s x)\n    (h : f x ≠ 0) : ContDiffWithinAt ℝ n (fun x => f x ^ g x) s x := by\n  exact (contDiffAt_rpow_of_ne (f x, g x) h).comp_contDiffWithinAt x (hf.prod hg)\n\n"}
{"name":"ContDiffAt.rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf g : E → Real\nx : E\nn : WithTop ENat\nhf : ContDiffAt Real n f x\nhg : ContDiffAt Real n g x\nh : Ne (f x) 0\n⊢ ContDiffAt Real n (fun x => HPow.hPow (f x) (g x)) x","decl":"theorem ContDiffAt.rpow (hf : ContDiffAt ℝ n f x) (hg : ContDiffAt ℝ n g x) (h : f x ≠ 0) :\n    ContDiffAt ℝ n (fun x => f x ^ g x) x := by\n  exact (contDiffAt_rpow_of_ne (f x, g x) h).comp x (hf.prod hg)\n\n"}
{"name":"ContDiffOn.rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf g : E → Real\ns : Set E\nn : WithTop ENat\nhf : ContDiffOn Real n f s\nhg : ContDiffOn Real n g s\nh : ∀ (x : E), Membership.mem s x → Ne (f x) 0\n⊢ ContDiffOn Real n (fun x => HPow.hPow (f x) (g x)) s","decl":"theorem ContDiffOn.rpow (hf : ContDiffOn ℝ n f s) (hg : ContDiffOn ℝ n g s) (h : ∀ x ∈ s, f x ≠ 0) :\n    ContDiffOn ℝ n (fun x => f x ^ g x) s := fun x hx => (hf x hx).rpow (hg x hx) (h x hx)\n\n"}
{"name":"ContDiff.rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf g : E → Real\nn : WithTop ENat\nhf : ContDiff Real n f\nhg : ContDiff Real n g\nh : ∀ (x : E), Ne (f x) 0\n⊢ ContDiff Real n fun x => HPow.hPow (f x) (g x)","decl":"theorem ContDiff.rpow (hf : ContDiff ℝ n f) (hg : ContDiff ℝ n g) (h : ∀ x, f x ≠ 0) :\n    ContDiff ℝ n fun x => f x ^ g x :=\n  contDiff_iff_contDiffAt.mpr fun x => hf.contDiffAt.rpow hg.contDiffAt (h x)\n\n"}
{"name":"ContDiffWithinAt.rpow_const_of_ne","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nx : E\ns : Set E\np : Real\nn : WithTop ENat\nhf : ContDiffWithinAt Real n f s x\nh : Ne (f x) 0\n⊢ ContDiffWithinAt Real n (fun x => HPow.hPow (f x) p) s x","decl":"theorem ContDiffWithinAt.rpow_const_of_ne (hf : ContDiffWithinAt ℝ n f s x) (h : f x ≠ 0) :\n    ContDiffWithinAt ℝ n (fun x => f x ^ p) s x :=\n  hf.rpow contDiffWithinAt_const h\n\n"}
{"name":"ContDiffAt.rpow_const_of_ne","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nx : E\np : Real\nn : WithTop ENat\nhf : ContDiffAt Real n f x\nh : Ne (f x) 0\n⊢ ContDiffAt Real n (fun x => HPow.hPow (f x) p) x","decl":"theorem ContDiffAt.rpow_const_of_ne (hf : ContDiffAt ℝ n f x) (h : f x ≠ 0) :\n    ContDiffAt ℝ n (fun x => f x ^ p) x :=\n  hf.rpow contDiffAt_const h\n\n"}
{"name":"ContDiffOn.rpow_const_of_ne","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\ns : Set E\np : Real\nn : WithTop ENat\nhf : ContDiffOn Real n f s\nh : ∀ (x : E), Membership.mem s x → Ne (f x) 0\n⊢ ContDiffOn Real n (fun x => HPow.hPow (f x) p) s","decl":"theorem ContDiffOn.rpow_const_of_ne (hf : ContDiffOn ℝ n f s) (h : ∀ x ∈ s, f x ≠ 0) :\n    ContDiffOn ℝ n (fun x => f x ^ p) s := fun x hx => (hf x hx).rpow_const_of_ne (h x hx)\n\n"}
{"name":"ContDiff.rpow_const_of_ne","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\np : Real\nn : WithTop ENat\nhf : ContDiff Real n f\nh : ∀ (x : E), Ne (f x) 0\n⊢ ContDiff Real n fun x => HPow.hPow (f x) p","decl":"theorem ContDiff.rpow_const_of_ne (hf : ContDiff ℝ n f) (h : ∀ x, f x ≠ 0) :\n    ContDiff ℝ n fun x => f x ^ p :=\n  hf.rpow contDiff_const h\n\n"}
{"name":"ContDiffWithinAt.rpow_const_of_le","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nx : E\ns : Set E\np : Real\nm : Nat\nhf : ContDiffWithinAt Real (↑m) f s x\nh : LE.le (↑m) p\n⊢ ContDiffWithinAt Real (↑m) (fun x => HPow.hPow (f x) p) s x","decl":"theorem ContDiffWithinAt.rpow_const_of_le (hf : ContDiffWithinAt ℝ m f s x) (h : ↑m ≤ p) :\n    ContDiffWithinAt ℝ m (fun x => f x ^ p) s x :=\n  (contDiffAt_rpow_const_of_le h).comp_contDiffWithinAt x hf\n\n"}
{"name":"ContDiffAt.rpow_const_of_le","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nx : E\np : Real\nm : Nat\nhf : ContDiffAt Real (↑m) f x\nh : LE.le (↑m) p\n⊢ ContDiffAt Real (↑m) (fun x => HPow.hPow (f x) p) x","decl":"theorem ContDiffAt.rpow_const_of_le (hf : ContDiffAt ℝ m f x) (h : ↑m ≤ p) :\n    ContDiffAt ℝ m (fun x => f x ^ p) x := by\n  rw [← contDiffWithinAt_univ] at *; exact hf.rpow_const_of_le h\n\n"}
{"name":"ContDiffOn.rpow_const_of_le","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\ns : Set E\np : Real\nm : Nat\nhf : ContDiffOn Real (↑m) f s\nh : LE.le (↑m) p\n⊢ ContDiffOn Real (↑m) (fun x => HPow.hPow (f x) p) s","decl":"theorem ContDiffOn.rpow_const_of_le (hf : ContDiffOn ℝ m f s) (h : ↑m ≤ p) :\n    ContDiffOn ℝ m (fun x => f x ^ p) s := fun x hx => (hf x hx).rpow_const_of_le h\n\n"}
{"name":"ContDiff.rpow_const_of_le","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\np : Real\nm : Nat\nhf : ContDiff Real (↑m) f\nh : LE.le (↑m) p\n⊢ ContDiff Real ↑m fun x => HPow.hPow (f x) p","decl":"theorem ContDiff.rpow_const_of_le (hf : ContDiff ℝ m f) (h : ↑m ≤ p) :\n    ContDiff ℝ m fun x => f x ^ p :=\n  contDiff_iff_contDiffAt.mpr fun _ => hf.contDiffAt.rpow_const_of_le h\n\n"}
{"name":"HasDerivWithinAt.rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"f g : Real → Real\nf' g' x : Real\ns : Set Real\nhf : HasDerivWithinAt f f' s x\nhg : HasDerivWithinAt g g' s x\nh : LT.lt 0 (f x)\n⊢ HasDerivWithinAt (fun x => HPow.hPow (f x) (g x)) (HAdd.hAdd (HMul.hMul (HMul.hMul f' (g x)) (HPow.hPow (f x) (HSub.hSub (g x) 1))) (HMul.hMul (HMul.hMul g' (HPow.hPow (f x) (g x))) (Real.log (f x)))) s x","decl":"theorem HasDerivWithinAt.rpow (hf : HasDerivWithinAt f f' s x) (hg : HasDerivWithinAt g g' s x)\n    (h : 0 < f x) : HasDerivWithinAt (fun x => f x ^ g x)\n      (f' * g x * f x ^ (g x - 1) + g' * f x ^ g x * Real.log (f x)) s x := by\n  convert (hf.hasFDerivWithinAt.rpow hg.hasFDerivWithinAt h).hasDerivWithinAt using 1\n  dsimp; ring\n\n"}
{"name":"HasDerivAt.rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"f g : Real → Real\nf' g' x : Real\nhf : HasDerivAt f f' x\nhg : HasDerivAt g g' x\nh : LT.lt 0 (f x)\n⊢ HasDerivAt (fun x => HPow.hPow (f x) (g x)) (HAdd.hAdd (HMul.hMul (HMul.hMul f' (g x)) (HPow.hPow (f x) (HSub.hSub (g x) 1))) (HMul.hMul (HMul.hMul g' (HPow.hPow (f x) (g x))) (Real.log (f x)))) x","decl":"theorem HasDerivAt.rpow (hf : HasDerivAt f f' x) (hg : HasDerivAt g g' x) (h : 0 < f x) :\n    HasDerivAt (fun x => f x ^ g x)\n      (f' * g x * f x ^ (g x - 1) + g' * f x ^ g x * Real.log (f x)) x := by\n  rw [← hasDerivWithinAt_univ] at *\n  exact hf.rpow hg h\n\n"}
{"name":"HasDerivWithinAt.rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"f : Real → Real\nf' x p : Real\ns : Set Real\nhf : HasDerivWithinAt f f' s x\nhx : Or (Ne (f x) 0) (LE.le 1 p)\n⊢ HasDerivWithinAt (fun y => HPow.hPow (f y) p) (HMul.hMul (HMul.hMul f' p) (HPow.hPow (f x) (HSub.hSub p 1))) s x","decl":"theorem HasDerivWithinAt.rpow_const (hf : HasDerivWithinAt f f' s x) (hx : f x ≠ 0 ∨ 1 ≤ p) :\n    HasDerivWithinAt (fun y => f y ^ p) (f' * p * f x ^ (p - 1)) s x := by\n  convert (hasDerivAt_rpow_const hx).comp_hasDerivWithinAt x hf using 1\n  ring\n\n"}
{"name":"HasDerivAt.rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"f : Real → Real\nf' x p : Real\nhf : HasDerivAt f f' x\nhx : Or (Ne (f x) 0) (LE.le 1 p)\n⊢ HasDerivAt (fun y => HPow.hPow (f y) p) (HMul.hMul (HMul.hMul f' p) (HPow.hPow (f x) (HSub.hSub p 1))) x","decl":"theorem HasDerivAt.rpow_const (hf : HasDerivAt f f' x) (hx : f x ≠ 0 ∨ 1 ≤ p) :\n    HasDerivAt (fun y => f y ^ p) (f' * p * f x ^ (p - 1)) x := by\n  rw [← hasDerivWithinAt_univ] at *\n  exact hf.rpow_const hx\n\n"}
{"name":"derivWithin_rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"f : Real → Real\nx p : Real\ns : Set Real\nhf : DifferentiableWithinAt Real f s x\nhx : Or (Ne (f x) 0) (LE.le 1 p)\nhxs : UniqueDiffWithinAt Real s x\n⊢ Eq (derivWithin (fun x => HPow.hPow (f x) p) s x) (HMul.hMul (HMul.hMul (derivWithin f s x) p) (HPow.hPow (f x) (HSub.hSub p 1)))","decl":"theorem derivWithin_rpow_const (hf : DifferentiableWithinAt ℝ f s x) (hx : f x ≠ 0 ∨ 1 ≤ p)\n    (hxs : UniqueDiffWithinAt ℝ s x) :\n    derivWithin (fun x => f x ^ p) s x = derivWithin f s x * p * f x ^ (p - 1) :=\n  (hf.hasDerivWithinAt.rpow_const hx).derivWithin hxs\n\n"}
{"name":"deriv_rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"f : Real → Real\nx p : Real\nhf : DifferentiableAt Real f x\nhx : Or (Ne (f x) 0) (LE.le 1 p)\n⊢ Eq (deriv (fun x => HPow.hPow (f x) p) x) (HMul.hMul (HMul.hMul (deriv f x) p) (HPow.hPow (f x) (HSub.hSub p 1)))","decl":"@[simp]\ntheorem deriv_rpow_const (hf : DifferentiableAt ℝ f x) (hx : f x ≠ 0 ∨ 1 ≤ p) :\n    deriv (fun x => f x ^ p) x = deriv f x * p * f x ^ (p - 1) :=\n  (hf.hasDerivAt.rpow_const hx).deriv\n\n"}
{"name":"deriv_norm_ofReal_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"c : Complex\nt : Real\nht : LT.lt 0 t\n⊢ Eq (deriv (fun x => Norm.norm (HPow.hPow (↑x) c)) t) (HMul.hMul c.re (HPow.hPow t (HSub.hSub c.re 1)))","decl":"theorem deriv_norm_ofReal_cpow (c : ℂ) {t : ℝ} (ht : 0 < t) :\n    (deriv fun x : ℝ ↦ ‖(x : ℂ) ^ c‖) t = c.re * t ^ (c.re - 1) := by\n  rw [EventuallyEq.deriv_eq (f := fun x ↦ x ^ c.re)]\n  · rw [Real.deriv_rpow_const (Or.inl ht.ne')]\n  · filter_upwards [eventually_gt_nhds ht] with x hx\n    rw [Complex.norm_eq_abs, Complex.abs_cpow_eq_rpow_re_of_pos hx]\n\n"}
{"name":"isTheta_deriv_rpow_const_atTop","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"p : Real\nhp : Ne p 0\n⊢ Asymptotics.IsTheta Filter.atTop (deriv fun x => HPow.hPow x p) fun x => HPow.hPow x (HSub.hSub p 1)","decl":"lemma isTheta_deriv_rpow_const_atTop {p : ℝ} (hp : p ≠ 0) :\n    deriv (fun (x : ℝ) => x ^ p) =Θ[atTop] fun x => x ^ (p-1) := by\n  calc deriv (fun (x : ℝ) => x ^ p) =ᶠ[atTop] fun x => p * x ^ (p - 1) := by\n              filter_upwards [eventually_ne_atTop 0] with x hx\n              rw [Real.deriv_rpow_const (Or.inl hx)]\n       _ =Θ[atTop] fun x => x ^ (p-1) :=\n              Asymptotics.IsTheta.const_mul_left hp Asymptotics.isTheta_rfl\n\n"}
{"name":"isBigO_deriv_rpow_const_atTop","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"p : Real\n⊢ Asymptotics.IsBigO Filter.atTop (deriv fun x => HPow.hPow x p) fun x => HPow.hPow x (HSub.hSub p 1)","decl":"lemma isBigO_deriv_rpow_const_atTop (p : ℝ) :\n    deriv (fun (x : ℝ) => x ^ p) =O[atTop] fun x => x ^ (p-1) := by\n  rcases eq_or_ne p 0 with rfl | hp\n  case inl =>\n    simp [zero_sub, Real.rpow_neg_one, Real.rpow_zero, deriv_const', Asymptotics.isBigO_zero]\n  case inr =>\n    exact (isTheta_deriv_rpow_const_atTop hp).1\n\n"}
{"name":"tendsto_one_plus_div_rpow_exp","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"t : Real\n⊢ Filter.Tendsto (fun x => HPow.hPow (HAdd.hAdd 1 (HDiv.hDiv t x)) x) Filter.atTop (nhds (Real.exp t))","decl":"/-- The function `(1 + t/x) ^ x` tends to `exp t` at `+∞`. -/\ntheorem tendsto_one_plus_div_rpow_exp (t : ℝ) :\n    Tendsto (fun x : ℝ => (1 + t / x) ^ x) atTop (𝓝 (exp t)) := by\n  apply ((Real.continuous_exp.tendsto _).comp (tendsto_mul_log_one_plus_div_atTop t)).congr' _\n  have h₁ : (1 : ℝ) / 2 < 1 := by norm_num\n  have h₂ : Tendsto (fun x : ℝ => 1 + t / x) atTop (𝓝 1) := by\n    simpa using (tendsto_inv_atTop_zero.const_mul t).const_add 1\n  refine (h₂.eventually_const_le h₁).mono fun x hx => ?_\n  have hx' : 0 < 1 + t / x := by linarith\n  simp [mul_comm x, exp_mul, exp_log hx']\n\n"}
{"name":"tendsto_one_plus_div_pow_exp","module":"Mathlib.Analysis.SpecialFunctions.Pow.Deriv","initialProofState":"t : Real\n⊢ Filter.Tendsto (fun x => HPow.hPow (HAdd.hAdd 1 (HDiv.hDiv t ↑x)) x) Filter.atTop (nhds (Real.exp t))","decl":"/-- The function `(1 + t/x) ^ x` tends to `exp t` at `+∞` for naturals `x`. -/\ntheorem tendsto_one_plus_div_pow_exp (t : ℝ) :\n    Tendsto (fun x : ℕ => (1 + t / (x : ℝ)) ^ x) atTop (𝓝 (Real.exp t)) :=\n  ((tendsto_one_plus_div_rpow_exp t).comp tendsto_natCast_atTop_atTop).congr (by simp)\n\n"}
