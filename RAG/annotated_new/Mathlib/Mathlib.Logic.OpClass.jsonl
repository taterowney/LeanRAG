{"name":"IsSymmOp.symm_op","module":"Mathlib.Logic.OpClass","initialProofState":"α : Sort u\nβ : Sort v\nop : α → α → β\nself : IsSymmOp op\na b : α\n⊢ Eq (op a b) (op b a)","decl":"/-- `IsSymmOp op` where `op : α → α → β` says that `op` is a symmetric operation,\ni.e. `op a b = op b a`.\nIt is the natural generalisation of `Std.Commutative` (`β = α`) and `IsSymm` (`β = Prop`). -/\nclass IsSymmOp (op : α → α → β) : Prop where\n  /-- A symmetric operation satisfies `op a b = op b a`. -/\n  symm_op : ∀ a b, op a b = op b a\n\n"}
{"name":"LeftCommutative.left_comm","module":"Mathlib.Logic.OpClass","initialProofState":"α : Sort u\nβ : Sort v\nop : α → β → β\nself : LeftCommutative op\na₁ a₂ : α\nb : β\n⊢ Eq (op a₁ (op a₂ b)) (op a₂ (op a₁ b))","decl":"/-- `LeftCommutative op` where `op : α → β → β` says that `op` is a left-commutative operation,\ni.e. `op a₁ (op a₂ b) = op a₂ (op a₁ b)`. -/\nclass LeftCommutative (op : α → β → β) : Prop where\n  /-- A left-commutative operation satisfies `op a₁ (op a₂ b) = op a₂ (op a₁ b)`. -/\n  left_comm : (a₁ a₂ : α) → (b : β) → op a₁ (op a₂ b) = op a₂ (op a₁ b)\n\n"}
{"name":"RightCommutative.right_comm","module":"Mathlib.Logic.OpClass","initialProofState":"α : Sort u\nβ : Sort v\nop : β → α → β\nself : RightCommutative op\nb : β\na₁ a₂ : α\n⊢ Eq (op (op b a₁) a₂) (op (op b a₂) a₁)","decl":"/-- `RightCommutative op` where `op : β → α → β` says that `op` is a right-commutative operation,\ni.e. `op (op b a₁) a₂ = op (op b a₂) a₁`. -/\nclass RightCommutative (op : β → α → β) : Prop where\n  /-- A right-commutative operation satisfies `op (op b a₁) a₂ = op (op b a₂) a₁`. -/\n  right_comm : (b : β) → (a₁ a₂ : α) → op (op b a₁) a₂ = op (op b a₂) a₁\n\n"}
{"name":"isSymmOp_of_isCommutative","module":"Mathlib.Logic.OpClass","initialProofState":"α : Sort u\nop : α → α → α\ninst✝ : Std.Commutative op\n⊢ IsSymmOp op","decl":"instance (priority := 100) isSymmOp_of_isCommutative (α : Sort u) (op : α → α → α)\n    [Std.Commutative op] : IsSymmOp op where symm_op := Std.Commutative.comm\n\n"}
{"name":"IsSymmOp.flip_eq","module":"Mathlib.Logic.OpClass","initialProofState":"α : Sort u\nβ : Sort v\nop : α → α → β\ninst✝ : IsSymmOp op\n⊢ Eq (flip op) op","decl":"theorem IsSymmOp.flip_eq (op : α → α → β) [IsSymmOp op] : flip op = op :=\n  funext fun a ↦ funext fun b ↦ (IsSymmOp.symm_op a b).symm\n\n"}
{"name":"instRightCommutativeOfLeftCommutative","module":"Mathlib.Logic.OpClass","initialProofState":"α : Sort u\nβ : Sort v\nf : α → β → β\nh : LeftCommutative f\n⊢ RightCommutative fun x y => f y x","decl":"instance {f : α → β → β} [h : LeftCommutative f] : RightCommutative (fun x y ↦ f y x) :=\n  ⟨fun _ _ _ ↦ (h.left_comm _ _ _).symm⟩\n\n"}
{"name":"instLeftCommutativeOfRightCommutative","module":"Mathlib.Logic.OpClass","initialProofState":"α : Sort u\nβ : Sort v\nf : β → α → β\nh : RightCommutative f\n⊢ LeftCommutative fun x y => f y x","decl":"instance {f : β → α → β} [h : RightCommutative f] : LeftCommutative (fun x y ↦ f y x) :=\n  ⟨fun _ _ _ ↦ (h.right_comm _ _ _).symm⟩\n\n"}
{"name":"instLeftCommutativeOfCommutativeOfAssociative","module":"Mathlib.Logic.OpClass","initialProofState":"α : Sort u\nf : α → α → α\nhc : Std.Commutative f\nha : Std.Associative f\n⊢ LeftCommutative f","decl":"instance {f : α → α → α} [hc : Std.Commutative f] [ha : Std.Associative f] : LeftCommutative f :=\n  ⟨fun a b c ↦ by rw [← ha.assoc, hc.comm a, ha.assoc]⟩\n\n"}
{"name":"instRightCommutativeOfCommutativeOfAssociative","module":"Mathlib.Logic.OpClass","initialProofState":"α : Sort u\nf : α → α → α\nhc : Std.Commutative f\nha : Std.Associative f\n⊢ RightCommutative f","decl":"instance {f : α → α → α} [hc : Std.Commutative f] [ha : Std.Associative f] : RightCommutative f :=\n  ⟨fun a b c ↦ by rw [ha.assoc, hc.comm b, ha.assoc]⟩\n"}
