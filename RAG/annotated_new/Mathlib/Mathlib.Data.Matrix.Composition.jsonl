{"name":"Matrix.comp_apply","module":"Mathlib.Data.Matrix.Composition","initialProofState":"I : Type u_1\nJ : Type u_2\nK : Type u_3\nL : Type u_4\nR : Type u_5\nm : Matrix I J (Matrix K L R)\nik : Prod I K\njl : Prod J L\n⊢ Eq ((Matrix.comp I J K L R) m ik jl) (m ik.1 jl.1 ik.2 jl.2)","decl":"/-- I by J matrix where each entry is a K by L matrix is equivalent to\n    I × K by J × L matrix -/\n@[simps]\ndef comp : Matrix I J (Matrix K L R) ≃ Matrix (I × K) (J × L) R where\n  toFun m ik jl := m ik.1 jl.1 ik.2 jl.2\n  invFun n i j k l := n (i, k) (j, l)\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"Matrix.comp_symm_apply","module":"Mathlib.Data.Matrix.Composition","initialProofState":"I : Type u_1\nJ : Type u_2\nK : Type u_3\nL : Type u_4\nR : Type u_5\nn : Matrix (Prod I K) (Prod J L) R\ni : I\nj : J\nk : K\nl : L\n⊢ Eq ((Matrix.comp I J K L R).symm n i j k l) (n { fst := i, snd := k } { fst := j, snd := l })","decl":"/-- I by J matrix where each entry is a K by L matrix is equivalent to\n    I × K by J × L matrix -/\n@[simps]\ndef comp : Matrix I J (Matrix K L R) ≃ Matrix (I × K) (J × L) R where\n  toFun m ik jl := m ik.1 jl.1 ik.2 jl.2\n  invFun n i j k l := n (i, k) (j, l)\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"Matrix.comp_map_map","module":"Mathlib.Data.Matrix.Composition","initialProofState":"I : Type u_1\nJ : Type u_2\nK : Type u_3\nL : Type u_4\nR : Type u_5\nR' : Type u_6\nM : Matrix I J (Matrix K L R)\nf : R → R'\n⊢ Eq ((Matrix.comp I J K L R') (M.map fun M' => M'.map f)) (((Matrix.comp I J K L R) M).map f)","decl":"theorem comp_map_map (M : Matrix I J (Matrix K L R)) (f : R → R') :\n  comp I J K L _ (M.map (fun M' => M'.map f)) = (comp I J K L _ M).map f := rfl\n\n"}
{"name":"Matrix.comp_stdBasisMatrix_stdBasisMatrix","module":"Mathlib.Data.Matrix.Composition","initialProofState":"I : Type u_1\nJ : Type u_2\nK : Type u_3\nL : Type u_4\nR : Type u_5\ninst✝⁴ : DecidableEq I\ninst✝³ : DecidableEq J\ninst✝² : DecidableEq K\ninst✝¹ : DecidableEq L\ninst✝ : Zero R\ni : I\nj : J\nk : K\nl : L\nr : R\n⊢ Eq ((Matrix.comp I J K L R) (Matrix.stdBasisMatrix i j (Matrix.stdBasisMatrix k l r))) (Matrix.stdBasisMatrix { fst := i, snd := k } { fst := j, snd := l } r)","decl":"@[simp]\ntheorem comp_stdBasisMatrix_stdBasisMatrix\n    [DecidableEq I] [DecidableEq J] [DecidableEq K] [DecidableEq L] [Zero R] (i j k l r) :\n    comp I J K L R (stdBasisMatrix i j (stdBasisMatrix k l r))\n      = stdBasisMatrix (i, k) (j, l) r := by\n  ext ⟨i', k'⟩ ⟨j', l'⟩\n  dsimp [comp_apply]\n  obtain hi | rfl := ne_or_eq i i'\n  · rw [StdBasisMatrix.apply_of_row_ne hi,\n      StdBasisMatrix.apply_of_row_ne (ne_of_apply_ne Prod.fst hi), Matrix.zero_apply]\n  obtain hj | rfl := ne_or_eq j j'\n  · rw [StdBasisMatrix.apply_of_col_ne _ _ hj,\n      StdBasisMatrix.apply_of_col_ne _ _ (ne_of_apply_ne Prod.fst hj), Matrix.zero_apply]\n  rw [StdBasisMatrix.apply_same]\n  obtain hk | rfl := ne_or_eq k k'\n  · rw [StdBasisMatrix.apply_of_row_ne hk,\n      StdBasisMatrix.apply_of_row_ne (ne_of_apply_ne Prod.snd hk)]\n  obtain hj | rfl := ne_or_eq l l'\n  · rw [StdBasisMatrix.apply_of_col_ne _ _ hj,\n      StdBasisMatrix.apply_of_col_ne _ _ (ne_of_apply_ne Prod.snd hj)]\n  rw [StdBasisMatrix.apply_same, StdBasisMatrix.apply_same]\n\n"}
{"name":"Matrix.comp_symm_stdBasisMatrix","module":"Mathlib.Data.Matrix.Composition","initialProofState":"I : Type u_1\nJ : Type u_2\nK : Type u_3\nL : Type u_4\nR : Type u_5\ninst✝⁴ : DecidableEq I\ninst✝³ : DecidableEq J\ninst✝² : DecidableEq K\ninst✝¹ : DecidableEq L\ninst✝ : Zero R\nii : Prod I K\njj : Prod J L\nr : R\n⊢ Eq ((Matrix.comp I J K L R).symm (Matrix.stdBasisMatrix ii jj r)) (Matrix.stdBasisMatrix ii.1 jj.1 (Matrix.stdBasisMatrix ii.2 jj.2 r))","decl":"@[simp]\ntheorem comp_symm_stdBasisMatrix\n    [DecidableEq I] [DecidableEq J] [DecidableEq K] [DecidableEq L] [Zero R] (ii jj r) :\n    (comp I J K L R).symm (stdBasisMatrix ii jj r) =\n      (stdBasisMatrix ii.1 jj.1 (stdBasisMatrix ii.2 jj.2 r)) :=\n  (comp I J K L R).symm_apply_eq.2 <| comp_stdBasisMatrix_stdBasisMatrix _ _ _ _ _ |>.symm\n\n\n"}
{"name":"Matrix.comp_diagonal_diagonal","module":"Mathlib.Data.Matrix.Composition","initialProofState":"I : Type u_1\nJ : Type u_2\nR : Type u_5\ninst✝² : DecidableEq I\ninst✝¹ : DecidableEq J\ninst✝ : Zero R\nd : I → J → R\n⊢ Eq ((Matrix.comp I I J J R) (Matrix.diagonal fun i => Matrix.diagonal fun j => d i j)) (Matrix.diagonal fun ij => d ij.1 ij.2)","decl":"@[simp]\ntheorem comp_diagonal_diagonal [DecidableEq I] [DecidableEq J] [Zero R] (d : I → J → R) :\n    comp I I J J R (diagonal fun i => diagonal fun j => d i j)\n      = diagonal fun ij => d ij.1 ij.2 := by\n  ext ⟨i₁, j₁⟩ ⟨i₂, j₂⟩\n  dsimp [comp_apply]\n  obtain hi | rfl := ne_or_eq i₁ i₂\n  · rw [diagonal_apply_ne _ hi, diagonal_apply_ne _ (ne_of_apply_ne Prod.fst hi),\n      Matrix.zero_apply]\n  rw [diagonal_apply_eq]\n  obtain hj | rfl := ne_or_eq j₁ j₂\n  · rw [diagonal_apply_ne _ hj, diagonal_apply_ne _ (ne_of_apply_ne Prod.snd hj)]\n  rw [diagonal_apply_eq, diagonal_apply_eq]\n\n"}
{"name":"Matrix.comp_symm_diagonal","module":"Mathlib.Data.Matrix.Composition","initialProofState":"I : Type u_1\nJ : Type u_2\nR : Type u_5\ninst✝² : DecidableEq I\ninst✝¹ : DecidableEq J\ninst✝ : Zero R\nd : Prod I J → R\n⊢ Eq ((Matrix.comp I I J J R).symm (Matrix.diagonal d)) (Matrix.diagonal fun i => Matrix.diagonal fun j => d { fst := i, snd := j })","decl":"@[simp]\ntheorem comp_symm_diagonal [DecidableEq I] [DecidableEq J] [Zero R] (d : I × J → R) :\n    (comp I I J J R).symm (diagonal d) = diagonal fun i => diagonal fun j => d (i, j) :=\n  (comp I I J J R).symm_apply_eq.2 <| (comp_diagonal_diagonal fun i j => d (i, j)).symm\n\n"}
{"name":"Matrix.comp_transpose","module":"Mathlib.Data.Matrix.Composition","initialProofState":"I : Type u_1\nJ : Type u_2\nK : Type u_3\nL : Type u_4\nR : Type u_5\nM : Matrix I J (Matrix K L R)\n⊢ Eq ((Matrix.comp J I K L R) M.transpose) ((Matrix.comp I J L K R) (M.map fun x => x.transpose)).transpose","decl":"theorem comp_transpose (M : Matrix I J (Matrix K L R)) :\n  comp J I K L R Mᵀ = (comp _ _ _ _ R <| M.map (·ᵀ))ᵀ := rfl\n\n"}
{"name":"Matrix.comp_map_transpose","module":"Mathlib.Data.Matrix.Composition","initialProofState":"I : Type u_1\nJ : Type u_2\nK : Type u_3\nL : Type u_4\nR : Type u_5\nM : Matrix I J (Matrix K L R)\n⊢ Eq ((Matrix.comp I J L K R) (M.map fun x => x.transpose)) ((Matrix.comp J I K L R) M.transpose).transpose","decl":"theorem comp_map_transpose (M : Matrix I J (Matrix K L R)) :\n  comp I J L K R (M.map (·ᵀ)) = (comp _ _ _ _ R Mᵀ)ᵀ := rfl\n\n"}
{"name":"Matrix.comp_symm_transpose","module":"Mathlib.Data.Matrix.Composition","initialProofState":"I : Type u_1\nJ : Type u_2\nK : Type u_3\nL : Type u_4\nR : Type u_5\nM : Matrix (Prod I K) (Prod J L) R\n⊢ Eq ((Matrix.comp J I L K R).symm M.transpose) (((Matrix.comp I J K L R).symm M).map fun x => x.transpose).transpose","decl":"theorem comp_symm_transpose (M : Matrix (I × K) (J × L) R) :\n  (comp J I L K R).symm Mᵀ = (((comp I J K L R).symm M).map (·ᵀ))ᵀ := rfl\n\n"}
{"name":"Matrix.compAddEquiv_apply","module":"Mathlib.Data.Matrix.Composition","initialProofState":"I : Type u_1\nJ : Type u_2\nK : Type u_3\nL : Type u_4\nR : Type u_5\ninst✝ : AddCommMonoid R\nM : Matrix I J (Matrix K L R)\n⊢ Eq ((Matrix.compAddEquiv I J K L R) M) ((Matrix.comp I J K L R) M)","decl":"@[simp]\ntheorem compAddEquiv_apply (M : Matrix I J (Matrix K L R)) :\n    compAddEquiv I J K L R M = comp I J K L R M := rfl\n\n"}
{"name":"Matrix.compAddEquiv_symm_apply","module":"Mathlib.Data.Matrix.Composition","initialProofState":"I : Type u_1\nJ : Type u_2\nK : Type u_3\nL : Type u_4\nR : Type u_5\ninst✝ : AddCommMonoid R\nM : Matrix (Prod I K) (Prod J L) R\n⊢ Eq ((Matrix.compAddEquiv I J K L R).symm M) ((Matrix.comp I J K L R).symm M)","decl":"@[simp]\ntheorem compAddEquiv_symm_apply (M : Matrix (I × K) (J × L) R) :\n    (compAddEquiv I J K L R).symm M = (comp I J K L R).symm M := rfl\n\n"}
{"name":"Matrix.compRingEquiv_apply","module":"Mathlib.Data.Matrix.Composition","initialProofState":"I : Type u_1\nJ : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : Fintype I\ninst✝ : Fintype J\nM : Matrix I I (Matrix J J R)\n⊢ Eq ((Matrix.compRingEquiv I J R) M) ((Matrix.comp I I J J R) M)","decl":"@[simp]\ntheorem compRingEquiv_apply (M : Matrix I I (Matrix J J R)) :\n    compRingEquiv I J R M = comp I I J J R M := rfl\n\n"}
{"name":"Matrix.compRingEquiv_symm_apply","module":"Mathlib.Data.Matrix.Composition","initialProofState":"I : Type u_1\nJ : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : Fintype I\ninst✝ : Fintype J\nM : Matrix (Prod I J) (Prod I J) R\n⊢ Eq ((Matrix.compRingEquiv I J R).symm M) ((Matrix.comp I I J J R).symm M)","decl":"@[simp]\ntheorem compRingEquiv_symm_apply (M : Matrix (I × J) (I × J) R) :\n    (compRingEquiv I J R).symm M = (comp I I J J R).symm M := rfl\n\n"}
{"name":"Matrix.compLinearEquiv_apply","module":"Mathlib.Data.Matrix.Composition","initialProofState":"I : Type u_1\nJ : Type u_2\nL : Type u_4\nR : Type u_5\nK : Type u_7\ninst✝² : CommSemiring K\ninst✝¹ : AddCommMonoid R\ninst✝ : Module K R\na✝ : Matrix I J (Matrix K L R)\n⊢ Eq ((Matrix.compLinearEquiv I J L R K) a✝) ((Matrix.comp I J K L R) a✝)","decl":"/-- `Matrix.comp` as `LinearEquiv` -/\n@[simps!]\ndef compLinearEquiv : Matrix I J (Matrix K L R) ≃ₗ[K] Matrix (I × K) (J × L) R where\n  __ := Matrix.compAddEquiv I J K L R\n  map_smul' _ _ := rfl\n\n"}
{"name":"Matrix.compLinearEquiv_symm_apply","module":"Mathlib.Data.Matrix.Composition","initialProofState":"I : Type u_1\nJ : Type u_2\nL : Type u_4\nR : Type u_5\nK : Type u_7\ninst✝² : CommSemiring K\ninst✝¹ : AddCommMonoid R\ninst✝ : Module K R\na✝ : Matrix (Prod I K) (Prod J L) R\n⊢ Eq ((Matrix.compLinearEquiv I J L R K).symm a✝) ((Matrix.comp I J K L R).symm a✝)","decl":"/-- `Matrix.comp` as `LinearEquiv` -/\n@[simps!]\ndef compLinearEquiv : Matrix I J (Matrix K L R) ≃ₗ[K] Matrix (I × K) (J × L) R where\n  __ := Matrix.compAddEquiv I J K L R\n  map_smul' _ _ := rfl\n\n"}
{"name":"Matrix.compAlgEquiv_apply","module":"Mathlib.Data.Matrix.Composition","initialProofState":"I : Type u_1\nJ : Type u_2\nR : Type u_5\nK : Type u_7\ninst✝⁶ : CommSemiring K\ninst✝⁵ : Semiring R\ninst✝⁴ : Fintype I\ninst✝³ : Fintype J\ninst✝² : Algebra K R\ninst✝¹ : DecidableEq I\ninst✝ : DecidableEq J\nM : Matrix I I (Matrix J J R)\n⊢ Eq ((Matrix.compAlgEquiv I J R K) M) ((Matrix.comp I I J J R) M)","decl":"@[simp]\ntheorem compAlgEquiv_apply (M : Matrix I I (Matrix J J R)) :\n    compAlgEquiv I J R K M = comp I I J J R M := rfl\n\n"}
{"name":"Matrix.compAlgEquiv_symm_apply","module":"Mathlib.Data.Matrix.Composition","initialProofState":"I : Type u_1\nJ : Type u_2\nR : Type u_5\nK : Type u_7\ninst✝⁶ : CommSemiring K\ninst✝⁵ : Semiring R\ninst✝⁴ : Fintype I\ninst✝³ : Fintype J\ninst✝² : Algebra K R\ninst✝¹ : DecidableEq I\ninst✝ : DecidableEq J\nM : Matrix (Prod I J) (Prod I J) R\n⊢ Eq ((Matrix.compAlgEquiv I J R K).symm M) ((Matrix.comp I I J J R).symm M)","decl":"@[simp]\ntheorem compAlgEquiv_symm_apply (M : Matrix (I × J) (I × J) R) :\n    (compAlgEquiv I J R K).symm M = (comp I I J J R).symm M := rfl\n\n"}
