{"name":"CategoryTheory.Functor.essImage.ofIso","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nY Y' : D\nh : CategoryTheory.Iso Y Y'\nhY : Membership.mem F.essImage Y\n‚ä¢ Membership.mem F.essImage Y'","decl":"/-- Being in the essential image is a \"hygienic\" property: it is preserved under isomorphism. -/\ntheorem essImage.ofIso {Y Y' : D} (h : Y ‚âÖ Y') (hY : Y ‚àà essImage F) : Y' ‚àà essImage F :=\n  hY.imp fun _ => Nonempty.map (¬∑ ‚â™‚â´ h)\n\n"}
{"name":"CategoryTheory.Functor.essImage.ofNatIso","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF F' : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F F'\nY : D\nhY : Membership.mem F.essImage Y\n‚ä¢ Membership.mem F'.essImage Y","decl":"/-- If `Y` is in the essential image of `F` then it is in the essential image of `F'` as long as\n`F ‚âÖ F'`.\n-/\ntheorem essImage.ofNatIso {F' : C ‚•§ D} (h : F ‚âÖ F') {Y : D} (hY : Y ‚àà essImage F) :\n    Y ‚àà essImage F' :=\n  hY.imp fun X => Nonempty.map fun t => h.symm.app X ‚â™‚â´ t\n\n"}
{"name":"CategoryTheory.Functor.essImage_eq_of_natIso","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF F' : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F F'\n‚ä¢ Eq F.essImage F'.essImage","decl":"/-- Isomorphic functors have equal essential images. -/\ntheorem essImage_eq_of_natIso {F' : C ‚•§ D} (h : F ‚âÖ F') : essImage F = essImage F' :=\n  funext fun _ => propext ‚ü®essImage.ofNatIso h, essImage.ofNatIso h.symm‚ü©\n\n"}
{"name":"CategoryTheory.Functor.obj_mem_essImage","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D C\nY : D\n‚ä¢ Membership.mem F.essImage (F.obj Y)","decl":"/-- An object in the image is in the essential image. -/\ntheorem obj_mem_essImage (F : D ‚•§ C) (Y : D) : F.obj Y ‚àà essImage F :=\n  ‚ü®Y, ‚ü®Iso.refl _‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Functor.essImageInclusion_map","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX‚úù Y‚úù : CategoryTheory.InducedCategory D CategoryTheory.FullSubcategory.obj\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (F.essImageInclusion.map f) f","decl":"/-- The essential image as a subcategory has a fully faithful inclusion into the target category. -/\n@[simps!]\ndef essImageInclusion (F : C ‚•§ D) : F.EssImageSubcategory ‚•§ D :=\n  fullSubcategoryInclusion _\n\n-- Porting note: `deriving Full` is not able to derive this instance\n"}
{"name":"CategoryTheory.Functor.essImageInclusion_obj","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.FullSubcategory F.essImage\n‚ä¢ Eq (F.essImageInclusion.obj self) self.obj","decl":"/-- The essential image as a subcategory has a fully faithful inclusion into the target category. -/\n@[simps!]\ndef essImageInclusion (F : C ‚•§ D) : F.EssImageSubcategory ‚•§ D :=\n  fullSubcategoryInclusion _\n\n-- Porting note: `deriving Full` is not able to derive this instance\n"}
{"name":"CategoryTheory.Functor.instFullEssImageSubcategoryEssImageInclusion","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\n‚ä¢ F.essImageInclusion.Full","decl":"instance : Full (essImageInclusion F) :=\n  (inferInstance : Full (fullSubcategoryInclusion _))\n\n-- Porting note: `deriving Faithful` is not able to derive this instance\n"}
{"name":"CategoryTheory.Functor.instFaithfulEssImageSubcategoryEssImageInclusion","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\n‚ä¢ F.essImageInclusion.Faithful","decl":"instance : Faithful (essImageInclusion F) :=\n  (inferInstance : Faithful (fullSubcategoryInclusion _))\n\n"}
{"name":"CategoryTheory.Functor.essImage_ext","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : F.EssImageSubcategory\nf g : Quiver.Hom X Y\nh : Eq (F.essImageInclusion.map f) (F.essImageInclusion.map g)\n‚ä¢ Eq f g","decl":"lemma essImage_ext (F : C ‚•§ D) {X Y : F.EssImageSubcategory} (f g : X ‚ü∂ Y)\n    (h : F.essImageInclusion.map f = F.essImageInclusion.map g) : f = g := by\n  simpa using h\n\n"}
{"name":"CategoryTheory.Functor.toEssImage_map","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (F.toEssImage.map f) (F.map f)","decl":"/--\nGiven a functor `F : C ‚•§ D`, we have an (essentially surjective) functor from `C` to the essential\nimage of `F`.\n-/\n@[simps!]\ndef toEssImage (F : C ‚•§ D) : C ‚•§ F.EssImageSubcategory :=\n  FullSubcategory.lift _ F (obj_mem_essImage _)\n\n"}
{"name":"CategoryTheory.Functor.toEssImage_obj_obj","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\n‚ä¢ Eq (F.toEssImage.obj X).obj (F.obj X)","decl":"/--\nGiven a functor `F : C ‚•§ D`, we have an (essentially surjective) functor from `C` to the essential\nimage of `F`.\n-/\n@[simps!]\ndef toEssImage (F : C ‚•§ D) : C ‚•§ F.EssImageSubcategory :=\n  FullSubcategory.lift _ F (obj_mem_essImage _)\n\n"}
{"name":"CategoryTheory.Functor.toEssImageCompEssentialImageInclusion_inv_app","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\n‚ä¢ Eq (F.toEssImageCompEssentialImageInclusion.inv.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- The functor `F` factorises through its essential image, where the first functor is essentially\nsurjective and the second is fully faithful.\n-/\n@[simps!]\ndef toEssImageCompEssentialImageInclusion (F : C ‚•§ D) : F.toEssImage ‚ãô F.essImageInclusion ‚âÖ F :=\n  FullSubcategory.lift_comp_inclusion _ _ _\n\n"}
{"name":"CategoryTheory.Functor.toEssImageCompEssentialImageInclusion_hom_app","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\n‚ä¢ Eq (F.toEssImageCompEssentialImageInclusion.hom.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- The functor `F` factorises through its essential image, where the first functor is essentially\nsurjective and the second is fully faithful.\n-/\n@[simps!]\ndef toEssImageCompEssentialImageInclusion (F : C ‚•§ D) : F.toEssImage ‚ãô F.essImageInclusion ‚âÖ F :=\n  FullSubcategory.lift_comp_inclusion _ _ _\n\n"}
{"name":"CategoryTheory.Functor.EssSurj.mem_essImage","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nself : F.EssSurj\nY : D\n‚ä¢ Membership.mem F.essImage Y","decl":"/-- A functor `F : C ‚•§ D` is essentially surjective if every object of `D` is in the essential\nimage of `F`. In other words, for every `Y : D`, there is some `X : C` with `F.obj X ‚âÖ Y`. -/\n@[stacks 001C]\nclass EssSurj (F : C ‚•§ D) : Prop where\n  /-- All the objects of the target category are in the essential image. -/\n  mem_essImage (Y : D) : Y ‚àà F.essImage\n\n"}
{"name":"CategoryTheory.Functor.EssSurj.toEssImage","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\n‚ä¢ F.toEssImage.EssSurj","decl":"instance EssSurj.toEssImage : EssSurj F.toEssImage where\n  mem_essImage := fun ‚ü®_, hY‚ü© =>\n    ‚ü®_, ‚ü®‚ü®_, _, hY.getIso.hom_inv_id, hY.getIso.inv_hom_id‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Functor.essSurj_of_surj","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nh : Function.Surjective F.obj\n‚ä¢ F.EssSurj","decl":"theorem essSurj_of_surj (h : Function.Surjective F.obj) : EssSurj F where\n  mem_essImage Y := by\n    obtain ‚ü®X, rfl‚ü© := h Y\n    apply obj_mem_essImage\n\n"}
{"name":"CategoryTheory.Functor.Faithful.toEssImage","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Faithful\n‚ä¢ F.toEssImage.Faithful","decl":"/-- The induced functor of a faithful functor is faithful. -/\ninstance Faithful.toEssImage (F : C ‚•§ D) [Faithful F] : Faithful F.toEssImage :=\n  Faithful.of_comp_iso F.toEssImageCompEssentialImageInclusion\n\n"}
{"name":"CategoryTheory.Functor.Full.toEssImage","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Full\n‚ä¢ F.toEssImage.Full","decl":"/-- The induced functor of a full functor is full. -/\ninstance Full.toEssImage (F : C ‚•§ D) [Full F] : Full F.toEssImage :=\n  Full.of_comp_faithful_iso F.toEssImageCompEssentialImageInclusion\n\n"}
{"name":"CategoryTheory.Functor.instEssSurjId","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ (CategoryTheory.Functor.id C).EssSurj","decl":"instance instEssSurjId : EssSurj (ùü≠ C) where\n  mem_essImage Y := ‚ü®Y, ‚ü®Iso.refl _‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Functor.essSurj_of_iso","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\ninst‚úù : F.EssSurj\nŒ± : CategoryTheory.Iso F G\n‚ä¢ G.EssSurj","decl":"lemma essSurj_of_iso {F G : C ‚•§ D} [EssSurj F] (Œ± : F ‚âÖ G) : EssSurj G where\n  mem_essImage Y := Functor.essImage.ofNatIso Œ± (EssSurj.mem_essImage Y)\n\n"}
{"name":"CategoryTheory.Functor.essSurj_comp","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\nE : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : F.EssSurj\ninst‚úù : G.EssSurj\n‚ä¢ (F.comp G).EssSurj","decl":"instance essSurj_comp (F : C ‚•§ D) (G : D ‚•§ E) [F.EssSurj] [G.EssSurj] :\n    (F ‚ãô G).EssSurj where\n  mem_essImage Z := ‚ü®_, ‚ü®G.mapIso (F.objObjPreimageIso _) ‚â™‚â´ G.objObjPreimageIso Z‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Functor.essSurj_of_comp_fully_faithful","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\nE : Type u‚ÇÉ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬≤ : (F.comp G).EssSurj\ninst‚úù¬π : G.Faithful\ninst‚úù : G.Full\n‚ä¢ F.EssSurj","decl":"lemma essSurj_of_comp_fully_faithful (F : C ‚•§ D) (G : D ‚•§ E) [(F ‚ãô G).EssSurj]\n    [G.Faithful] [G.Full] : F.EssSurj where\n  mem_essImage X := ‚ü®_, ‚ü®G.preimageIso ((F ‚ãô G).objObjPreimageIso (G.obj X))‚ü©‚ü©\n\n"}
