{"name":"CategoryTheory.Functor.essImage.ofIso","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nY Y' : D\nh : CategoryTheory.Iso Y Y'\nhY : Membership.mem F.essImage Y\n⊢ Membership.mem F.essImage Y'","decl":"/-- Being in the essential image is a \"hygienic\" property: it is preserved under isomorphism. -/\ntheorem essImage.ofIso {Y Y' : D} (h : Y ≅ Y') (hY : Y ∈ essImage F) : Y' ∈ essImage F :=\n  hY.imp fun _ => Nonempty.map (· ≪≫ h)\n\n"}
{"name":"CategoryTheory.Functor.essImage.ofNatIso","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF F' : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F F'\nY : D\nhY : Membership.mem F.essImage Y\n⊢ Membership.mem F'.essImage Y","decl":"/-- If `Y` is in the essential image of `F` then it is in the essential image of `F'` as long as\n`F ≅ F'`.\n-/\ntheorem essImage.ofNatIso {F' : C ⥤ D} (h : F ≅ F') {Y : D} (hY : Y ∈ essImage F) :\n    Y ∈ essImage F' :=\n  hY.imp fun X => Nonempty.map fun t => h.symm.app X ≪≫ t\n\n"}
{"name":"CategoryTheory.Functor.essImage_eq_of_natIso","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF F' : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F F'\n⊢ Eq F.essImage F'.essImage","decl":"/-- Isomorphic functors have equal essential images. -/\ntheorem essImage_eq_of_natIso {F' : C ⥤ D} (h : F ≅ F') : essImage F = essImage F' :=\n  funext fun _ => propext ⟨essImage.ofNatIso h, essImage.ofNatIso h.symm⟩\n\n"}
{"name":"CategoryTheory.Functor.obj_mem_essImage","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor D C\nY : D\n⊢ Membership.mem F.essImage (F.obj Y)","decl":"/-- An object in the image is in the essential image. -/\ntheorem obj_mem_essImage (F : D ⥤ C) (Y : D) : F.obj Y ∈ essImage F :=\n  ⟨Y, ⟨Iso.refl _⟩⟩\n\n"}
{"name":"CategoryTheory.Functor.essImageInclusion_map","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX✝ Y✝ : CategoryTheory.InducedCategory D CategoryTheory.FullSubcategory.obj\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (F.essImageInclusion.map f) f","decl":"/-- The essential image as a subcategory has a fully faithful inclusion into the target category. -/\n@[simps!]\ndef essImageInclusion (F : C ⥤ D) : F.EssImageSubcategory ⥤ D :=\n  fullSubcategoryInclusion _\n\n-- Porting note: `deriving Full` is not able to derive this instance\n"}
{"name":"CategoryTheory.Functor.essImageInclusion_obj","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.FullSubcategory F.essImage\n⊢ Eq (F.essImageInclusion.obj self) self.obj","decl":"/-- The essential image as a subcategory has a fully faithful inclusion into the target category. -/\n@[simps!]\ndef essImageInclusion (F : C ⥤ D) : F.EssImageSubcategory ⥤ D :=\n  fullSubcategoryInclusion _\n\n-- Porting note: `deriving Full` is not able to derive this instance\n"}
{"name":"CategoryTheory.Functor.instFullEssImageSubcategoryEssImageInclusion","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\n⊢ F.essImageInclusion.Full","decl":"instance : Full (essImageInclusion F) :=\n  (inferInstance : Full (fullSubcategoryInclusion _))\n\n-- Porting note: `deriving Faithful` is not able to derive this instance\n"}
{"name":"CategoryTheory.Functor.instFaithfulEssImageSubcategoryEssImageInclusion","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\n⊢ F.essImageInclusion.Faithful","decl":"instance : Faithful (essImageInclusion F) :=\n  (inferInstance : Faithful (fullSubcategoryInclusion _))\n\n"}
{"name":"CategoryTheory.Functor.essImage_ext","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : F.EssImageSubcategory\nf g : Quiver.Hom X Y\nh : Eq (F.essImageInclusion.map f) (F.essImageInclusion.map g)\n⊢ Eq f g","decl":"lemma essImage_ext (F : C ⥤ D) {X Y : F.EssImageSubcategory} (f g : X ⟶ Y)\n    (h : F.essImageInclusion.map f = F.essImageInclusion.map g) : f = g := by\n  simpa using h\n\n"}
{"name":"CategoryTheory.Functor.toEssImage_map","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (F.toEssImage.map f) (F.map f)","decl":"/--\nGiven a functor `F : C ⥤ D`, we have an (essentially surjective) functor from `C` to the essential\nimage of `F`.\n-/\n@[simps!]\ndef toEssImage (F : C ⥤ D) : C ⥤ F.EssImageSubcategory :=\n  FullSubcategory.lift _ F (obj_mem_essImage _)\n\n"}
{"name":"CategoryTheory.Functor.toEssImage_obj_obj","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\n⊢ Eq (F.toEssImage.obj X).obj (F.obj X)","decl":"/--\nGiven a functor `F : C ⥤ D`, we have an (essentially surjective) functor from `C` to the essential\nimage of `F`.\n-/\n@[simps!]\ndef toEssImage (F : C ⥤ D) : C ⥤ F.EssImageSubcategory :=\n  FullSubcategory.lift _ F (obj_mem_essImage _)\n\n"}
{"name":"CategoryTheory.Functor.toEssImageCompEssentialImageInclusion_inv_app","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\n⊢ Eq (F.toEssImageCompEssentialImageInclusion.inv.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- The functor `F` factorises through its essential image, where the first functor is essentially\nsurjective and the second is fully faithful.\n-/\n@[simps!]\ndef toEssImageCompEssentialImageInclusion (F : C ⥤ D) : F.toEssImage ⋙ F.essImageInclusion ≅ F :=\n  FullSubcategory.lift_comp_inclusion _ _ _\n\n"}
{"name":"CategoryTheory.Functor.toEssImageCompEssentialImageInclusion_hom_app","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\n⊢ Eq (F.toEssImageCompEssentialImageInclusion.hom.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- The functor `F` factorises through its essential image, where the first functor is essentially\nsurjective and the second is fully faithful.\n-/\n@[simps!]\ndef toEssImageCompEssentialImageInclusion (F : C ⥤ D) : F.toEssImage ⋙ F.essImageInclusion ≅ F :=\n  FullSubcategory.lift_comp_inclusion _ _ _\n\n"}
{"name":"CategoryTheory.Functor.EssSurj.mem_essImage","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nself : F.EssSurj\nY : D\n⊢ Membership.mem F.essImage Y","decl":"/-- A functor `F : C ⥤ D` is essentially surjective if every object of `D` is in the essential\nimage of `F`. In other words, for every `Y : D`, there is some `X : C` with `F.obj X ≅ Y`. -/\n@[stacks 001C]\nclass EssSurj (F : C ⥤ D) : Prop where\n  /-- All the objects of the target category are in the essential image. -/\n  mem_essImage (Y : D) : Y ∈ F.essImage\n\n"}
{"name":"CategoryTheory.Functor.EssSurj.toEssImage","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\n⊢ F.toEssImage.EssSurj","decl":"instance EssSurj.toEssImage : EssSurj F.toEssImage where\n  mem_essImage := fun ⟨_, hY⟩ =>\n    ⟨_, ⟨⟨_, _, hY.getIso.hom_inv_id, hY.getIso.inv_hom_id⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Functor.essSurj_of_surj","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nh : Function.Surjective F.obj\n⊢ F.EssSurj","decl":"theorem essSurj_of_surj (h : Function.Surjective F.obj) : EssSurj F where\n  mem_essImage Y := by\n    obtain ⟨X, rfl⟩ := h Y\n    apply obj_mem_essImage\n\n"}
{"name":"CategoryTheory.Functor.Faithful.toEssImage","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : F.Faithful\n⊢ F.toEssImage.Faithful","decl":"/-- The induced functor of a faithful functor is faithful. -/\ninstance Faithful.toEssImage (F : C ⥤ D) [Faithful F] : Faithful F.toEssImage :=\n  Faithful.of_comp_iso F.toEssImageCompEssentialImageInclusion\n\n"}
{"name":"CategoryTheory.Functor.Full.toEssImage","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : F.Full\n⊢ F.toEssImage.Full","decl":"/-- The induced functor of a full functor is full. -/\ninstance Full.toEssImage (F : C ⥤ D) [Full F] : Full F.toEssImage :=\n  Full.of_comp_faithful_iso F.toEssImageCompEssentialImageInclusion\n\n"}
{"name":"CategoryTheory.Functor.instEssSurjId","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ (CategoryTheory.Functor.id C).EssSurj","decl":"instance instEssSurjId : EssSurj (𝟭 C) where\n  mem_essImage Y := ⟨Y, ⟨Iso.refl _⟩⟩\n\n"}
{"name":"CategoryTheory.Functor.essSurj_of_iso","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF G : CategoryTheory.Functor C D\ninst✝ : F.EssSurj\nα : CategoryTheory.Iso F G\n⊢ G.EssSurj","decl":"lemma essSurj_of_iso {F G : C ⥤ D} [EssSurj F] (α : F ≅ G) : EssSurj G where\n  mem_essImage Y := Functor.essImage.ofNatIso α (EssSurj.mem_essImage Y)\n\n"}
{"name":"CategoryTheory.Functor.essSurj_comp","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u₁\nD : Type u₂\nE : Type u₃\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : F.EssSurj\ninst✝ : G.EssSurj\n⊢ (F.comp G).EssSurj","decl":"instance essSurj_comp (F : C ⥤ D) (G : D ⥤ E) [F.EssSurj] [G.EssSurj] :\n    (F ⋙ G).EssSurj where\n  mem_essImage Z := ⟨_, ⟨G.mapIso (F.objObjPreimageIso _) ≪≫ G.objObjPreimageIso Z⟩⟩\n\n"}
{"name":"CategoryTheory.Functor.essSurj_of_comp_fully_faithful","module":"Mathlib.CategoryTheory.EssentialImage","initialProofState":"C : Type u₁\nD : Type u₂\nE : Type u₃\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝² : (F.comp G).EssSurj\ninst✝¹ : G.Faithful\ninst✝ : G.Full\n⊢ F.EssSurj","decl":"lemma essSurj_of_comp_fully_faithful (F : C ⥤ D) (G : D ⥤ E) [(F ⋙ G).EssSurj]\n    [G.Faithful] [G.Full] : F.EssSurj where\n  mem_essImage X := ⟨_, ⟨G.preimageIso ((F ⋙ G).objObjPreimageIso (G.obj X))⟩⟩\n\n"}
