{"name":"val_unitOfInvertible","module":"Mathlib.Algebra.Group.Invertible.Basic","initialProofState":"α : Type u\ninst✝¹ : Monoid α\na : α\ninst✝ : Invertible a\n⊢ Eq (↑(unitOfInvertible a)) a","decl":"/-- An `Invertible` element is a unit. -/\n@[simps]\ndef unitOfInvertible [Monoid α] (a : α) [Invertible a] : αˣ where\n  val := a\n  inv := ⅟ a\n  val_inv := by simp\n  inv_val := by simp\n\n"}
{"name":"val_inv_unitOfInvertible","module":"Mathlib.Algebra.Group.Invertible.Basic","initialProofState":"α : Type u\ninst✝¹ : Monoid α\na : α\ninst✝ : Invertible a\n⊢ Eq (↑(Inv.inv (unitOfInvertible a))) (Invertible.invOf a)","decl":"/-- An `Invertible` element is a unit. -/\n@[simps]\ndef unitOfInvertible [Monoid α] (a : α) [Invertible a] : αˣ where\n  val := a\n  inv := ⅟ a\n  val_inv := by simp\n  inv_val := by simp\n\n"}
{"name":"isUnit_of_invertible","module":"Mathlib.Algebra.Group.Invertible.Basic","initialProofState":"α : Type u\ninst✝¹ : Monoid α\na : α\ninst✝ : Invertible a\n⊢ IsUnit a","decl":"theorem isUnit_of_invertible [Monoid α] (a : α) [Invertible a] : IsUnit a :=\n  ⟨unitOfInvertible a, rfl⟩\n\n"}
{"name":"invOf_units","module":"Mathlib.Algebra.Group.Invertible.Basic","initialProofState":"α : Type u\ninst✝¹ : Monoid α\nu : Units α\ninst✝ : Invertible ↑u\n⊢ Eq (Invertible.invOf ↑u) ↑(Inv.inv u)","decl":"@[simp]\ntheorem invOf_units [Monoid α] (u : αˣ) [Invertible (u : α)] : ⅟ (u : α) = ↑u⁻¹ :=\n  invOf_eq_right_inv u.mul_inv\n\n"}
{"name":"IsUnit.nonempty_invertible","module":"Mathlib.Algebra.Group.Invertible.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\na : α\nh : IsUnit a\n⊢ Nonempty (Invertible a)","decl":"theorem IsUnit.nonempty_invertible [Monoid α] {a : α} (h : IsUnit a) : Nonempty (Invertible a) :=\n  let ⟨x, hx⟩ := h\n  ⟨x.invertible.copy _ hx.symm⟩\n\n"}
{"name":"nonempty_invertible_iff_isUnit","module":"Mathlib.Algebra.Group.Invertible.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\na : α\n⊢ Iff (Nonempty (Invertible a)) (IsUnit a)","decl":"@[simp]\ntheorem nonempty_invertible_iff_isUnit [Monoid α] (a : α) : Nonempty (Invertible a) ↔ IsUnit a :=\n  ⟨Nonempty.rec <| @isUnit_of_invertible _ _ _, IsUnit.nonempty_invertible⟩\n\n"}
{"name":"Commute.invOf_right","module":"Mathlib.Algebra.Group.Invertible.Basic","initialProofState":"α : Type u\ninst✝¹ : Monoid α\na b : α\ninst✝ : Invertible b\nh : Commute a b\n⊢ Commute a (Invertible.invOf b)","decl":"theorem Commute.invOf_right [Monoid α] {a b : α} [Invertible b] (h : Commute a b) :\n    Commute a (⅟ b) :=\n  calc\n    a * ⅟ b = ⅟ b * (b * a * ⅟ b) := by simp [mul_assoc]\n    _ = ⅟ b * (a * b * ⅟ b) := by rw [h.eq]\n    _ = ⅟ b * a := by simp [mul_assoc]\n\n"}
{"name":"Commute.invOf_left","module":"Mathlib.Algebra.Group.Invertible.Basic","initialProofState":"α : Type u\ninst✝¹ : Monoid α\na b : α\ninst✝ : Invertible b\nh : Commute b a\n⊢ Commute (Invertible.invOf b) a","decl":"theorem Commute.invOf_left [Monoid α] {a b : α} [Invertible b] (h : Commute b a) :\n    Commute (⅟ b) a :=\n  calc\n    ⅟ b * a = ⅟ b * (a * b * ⅟ b) := by simp [mul_assoc]\n    _ = ⅟ b * (b * a * ⅟ b) := by rw [h.eq]\n    _ = a * ⅟ b := by simp [mul_assoc]\n\n"}
{"name":"commute_invOf","module":"Mathlib.Algebra.Group.Invertible.Basic","initialProofState":"M : Type u_1\ninst✝² : One M\ninst✝¹ : Mul M\nm : M\ninst✝ : Invertible m\n⊢ Commute m (Invertible.invOf m)","decl":"theorem commute_invOf {M : Type*} [One M] [Mul M] (m : M) [Invertible m] : Commute m (⅟ m) :=\n  calc\n    m * ⅟ m = 1 := mul_invOf_self m\n    _ = ⅟ m * m := (invOf_mul_self m).symm\n\n"}
{"name":"Invertible.mulLeft_apply","module":"Mathlib.Algebra.Group.Invertible.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\na : α\nx✝¹ : Invertible a\nb : α\nx✝ : Invertible b\n⊢ Eq ((x✝¹.mulLeft b) x✝) (invertibleMul a b)","decl":"/-- `invertibleOfInvertibleMul` and `invertibleMul` as an equivalence. -/\n@[simps apply symm_apply]\ndef Invertible.mulLeft {a : α} (_ : Invertible a) (b : α) : Invertible b ≃ Invertible (a * b) where\n  toFun _ := invertibleMul a b\n  invFun _ := invertibleOfInvertibleMul a _\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _\n\n"}
{"name":"Invertible.mulLeft_symm_apply","module":"Mathlib.Algebra.Group.Invertible.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\na : α\nx✝¹ : Invertible a\nb : α\nx✝ : Invertible (HMul.hMul a b)\n⊢ Eq ((x✝¹.mulLeft b).symm x✝) (invertibleOfInvertibleMul a b)","decl":"/-- `invertibleOfInvertibleMul` and `invertibleMul` as an equivalence. -/\n@[simps apply symm_apply]\ndef Invertible.mulLeft {a : α} (_ : Invertible a) (b : α) : Invertible b ≃ Invertible (a * b) where\n  toFun _ := invertibleMul a b\n  invFun _ := invertibleOfInvertibleMul a _\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _\n\n"}
{"name":"Invertible.mulRight_apply","module":"Mathlib.Algebra.Group.Invertible.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\na b : α\nx✝¹ : Invertible b\nx✝ : Invertible a\n⊢ Eq ((Invertible.mulRight a x✝¹) x✝) (invertibleMul a b)","decl":"/-- `invertibleOfMulInvertible` and `invertibleMul` as an equivalence. -/\n@[simps apply symm_apply]\ndef Invertible.mulRight (a : α) {b : α} (_ : Invertible b) : Invertible a ≃ Invertible (a * b) where\n  toFun _ := invertibleMul a b\n  invFun _ := invertibleOfMulInvertible _ b\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _\n\n"}
{"name":"Invertible.mulRight_symm_apply","module":"Mathlib.Algebra.Group.Invertible.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\na b : α\nx✝¹ : Invertible b\nx✝ : Invertible (HMul.hMul a b)\n⊢ Eq ((Invertible.mulRight a x✝¹).symm x✝) (invertibleOfMulInvertible a b)","decl":"/-- `invertibleOfMulInvertible` and `invertibleMul` as an equivalence. -/\n@[simps apply symm_apply]\ndef Invertible.mulRight (a : α) {b : α} (_ : Invertible b) : Invertible a ≃ Invertible (a * b) where\n  toFun _ := invertibleMul a b\n  invFun _ := invertibleOfMulInvertible _ b\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _\n\n"}
{"name":"invOf_pow","module":"Mathlib.Algebra.Group.Invertible.Basic","initialProofState":"α : Type u\ninst✝² : Monoid α\nm : α\ninst✝¹ : Invertible m\nn : Nat\ninst✝ : Invertible (HPow.hPow m n)\n⊢ Eq (Invertible.invOf (HPow.hPow m n)) (HPow.hPow (Invertible.invOf m) n)","decl":"lemma invOf_pow (m : α) [Invertible m] (n : ℕ) [Invertible (m ^ n)] : ⅟ (m ^ n) = ⅟ m ^ n :=\n  @invertible_unique _ _ _ _ _ (invertiblePow m n) rfl\n\n"}
{"name":"map_invOf","module":"Mathlib.Algebra.Group.Invertible.Basic","initialProofState":"R : Type u_1\nS : Type u_2\nF : Type u_3\ninst✝⁴ : MulOneClass R\ninst✝³ : Monoid S\ninst✝² : FunLike F R S\ninst✝¹ : MonoidHomClass F R S\nf : F\nr : R\ninst✝ : Invertible r\nifr : Invertible (f r)\n⊢ Eq (f (Invertible.invOf r)) (Invertible.invOf (f r))","decl":"/-- Note that the `Invertible (f r)` argument can be satisfied by using `letI := Invertible.map f r`\nbefore applying this lemma. -/\ntheorem map_invOf {R : Type*} {S : Type*} {F : Type*} [MulOneClass R] [Monoid S]\n    [FunLike F R S] [MonoidHomClass F R S] (f : F) (r : R)\n    [Invertible r] [ifr : Invertible (f r)] :\n    f (⅟ r) = ⅟ (f r) :=\n  have h : ifr = Invertible.map f r := Subsingleton.elim _ _\n  by subst h; rfl\n\n"}
{"name":"Invertible.ofLeftInverse_invOf","module":"Mathlib.Algebra.Group.Invertible.Basic","initialProofState":"R : Type u_1\nS : Type u_2\nG : Type u_3\ninst✝⁴ : MulOneClass R\ninst✝³ : MulOneClass S\ninst✝² : FunLike G S R\ninst✝¹ : MonoidHomClass G S R\nf : R → S\ng : G\nr : R\nh : Function.LeftInverse (⇑g) f\ninst✝ : Invertible (f r)\n⊢ Eq (Invertible.invOf r) (Invertible.invOf (g (f r)))","decl":"/-- If a function `f : R → S` has a left-inverse that is a monoid hom,\n  then `r : R` is invertible if `f r` is.\n\nThe inverse is computed as `g (⅟(f r))` -/\n@[simps! (config := .lemmasOnly)]\ndef Invertible.ofLeftInverse {R : Type*} {S : Type*} {G : Type*} [MulOneClass R] [MulOneClass S]\n    [FunLike G S R] [MonoidHomClass G S R] (f : R → S) (g : G) (r : R)\n    (h : Function.LeftInverse g f) [Invertible (f r)] : Invertible r :=\n  (Invertible.map g (f r)).copy _ (h r).symm\n\n"}
{"name":"invertibleEquivOfLeftInverse_apply","module":"Mathlib.Algebra.Group.Invertible.Basic","initialProofState":"R : Type u_1\nS : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\ninst✝³ : FunLike F R S\ninst✝² : MonoidHomClass F R S\ninst✝¹ : FunLike G S R\ninst✝ : MonoidHomClass G S R\nf : F\ng : G\nr : R\nh : Function.LeftInverse ⇑g ⇑f\nx✝ : Invertible (f r)\n⊢ Eq ((invertibleEquivOfLeftInverse f g r h) x✝) (Invertible.ofLeftInverse (⇑f) g r h)","decl":"/-- Invertibility on either side of a monoid hom with a left-inverse is equivalent. -/\n@[simps]\ndef invertibleEquivOfLeftInverse {R : Type*} {S : Type*} {F G : Type*} [Monoid R] [Monoid S]\n    [FunLike F R S] [MonoidHomClass F R S] [FunLike G S R] [MonoidHomClass G S R]\n    (f : F) (g : G) (r : R) (h : Function.LeftInverse g f) : Invertible (f r) ≃ Invertible r where\n  toFun _ := Invertible.ofLeftInverse f _ _ h\n  invFun _ := Invertible.map f _\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _\n"}
{"name":"invertibleEquivOfLeftInverse_symm_apply","module":"Mathlib.Algebra.Group.Invertible.Basic","initialProofState":"R : Type u_1\nS : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\ninst✝³ : FunLike F R S\ninst✝² : MonoidHomClass F R S\ninst✝¹ : FunLike G S R\ninst✝ : MonoidHomClass G S R\nf : F\ng : G\nr : R\nh : Function.LeftInverse ⇑g ⇑f\nx✝ : Invertible r\n⊢ Eq ((invertibleEquivOfLeftInverse f g r h).symm x✝) (Invertible.map f r)","decl":"/-- Invertibility on either side of a monoid hom with a left-inverse is equivalent. -/\n@[simps]\ndef invertibleEquivOfLeftInverse {R : Type*} {S : Type*} {F G : Type*} [Monoid R] [Monoid S]\n    [FunLike F R S] [MonoidHomClass F R S] [FunLike G S R] [MonoidHomClass G S R]\n    (f : F) (g : G) (r : R) (h : Function.LeftInverse g f) : Invertible (f r) ≃ Invertible r where\n  toFun _ := Invertible.ofLeftInverse f _ _ h\n  invFun _ := Invertible.map f _\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _\n"}
