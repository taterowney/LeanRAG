{"name":"CategoryTheory.IsSifted.toFinal","module":"Mathlib.CategoryTheory.Limits.Sifted","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.IsSifted C\n⊢ (CategoryTheory.Functor.diag C).Final","decl":"/-- A category `C` `IsSfited` if\n1. the diagonal functor `C ⥤ C × C` is final.\n2. there exists some object. -/\nclass IsSifted extends IsSiftedOrEmpty C : Prop where\n  [nonempty : Nonempty C]\n\n"}
{"name":"CategoryTheory.IsSifted.nonempty","module":"Mathlib.CategoryTheory.Limits.Sifted","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.IsSifted C\n⊢ Nonempty C","decl":"/-- A category `C` `IsSfited` if\n1. the diagonal functor `C ⥤ C × C` is final.\n2. there exists some object. -/\nclass IsSifted extends IsSiftedOrEmpty C : Prop where\n  [nonempty : Nonempty C]\n\n"}
{"name":"CategoryTheory.IsSifted.isSifted_of_equiv","module":"Mathlib.CategoryTheory.Limits.Sifted","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.IsSifted C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\ne : CategoryTheory.Equivalence D C\n⊢ CategoryTheory.IsSifted D","decl":"/-- Being sifted is preserved by equivalences of categories -/\nlemma isSifted_of_equiv [IsSifted C] {D : Type u₁} [Category.{v₁} D] (e : D ≌ C) : IsSifted D :=\n  letI : Final (diag D) := by\n    letI : D × D ≌ C × C:= Equivalence.prod e e\n    have sq : (e.inverse ⋙ diag D ⋙ this.functor ≅ diag C) :=\n        NatIso.ofComponents (fun c ↦ by dsimp [this]\n                                        exact Iso.prod (e.counitIso.app c) (e.counitIso.app c))\n    apply_rules [final_iff_comp_equivalence _ this.functor|>.mpr,\n      final_iff_final_comp e.inverse _ |>.mpr, final_of_natIso sq.symm]\n  letI : _root_.Nonempty D := ⟨e.inverse.obj (_root_.Nonempty.some IsSifted.nonempty)⟩\n  ⟨⟩\n\n"}
{"name":"CategoryTheory.IsSifted.isSifted_iff_asSmallIsSifted","module":"Mathlib.CategoryTheory.Limits.Sifted","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Iff (CategoryTheory.IsSifted C) (CategoryTheory.IsSifted (CategoryTheory.AsSmall C))","decl":"/-- In particular a category is sifted iff and only if it is so when viewed as a small category -/\nlemma isSifted_iff_asSmallIsSifted : IsSifted C ↔ IsSifted (AsSmall.{w} C) where\n  mp _ := isSifted_of_equiv AsSmall.equiv.symm\n  mpr _ := isSifted_of_equiv AsSmall.equiv\n\n"}
{"name":"CategoryTheory.IsSifted.instIsConnected","module":"Mathlib.CategoryTheory.Limits.Sifted","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsSifted C\n⊢ CategoryTheory.IsConnected C","decl":"/-- A sifted category is connected. -/\ninstance [IsSifted C] : IsConnected C :=\n  isConnected_of_zigzag\n    (by intro c₁ c₂\n        have X : StructuredArrow (c₁, c₂) (diag C) :=\n          letI S : Final (diag C) := by infer_instance\n          Nonempty.some (S.out (c₁, c₂)).is_nonempty\n        use [X.right, c₂]\n        constructor\n        · constructor\n          · exact Zag.of_hom X.hom.fst\n          · simp\n            exact Zag.of_inv X.hom.snd\n        · rfl)\n\n"}
{"name":"CategoryTheory.IsSifted.instIsSiftedOrEmptyOfHasBinaryCoproducts","module":"Mathlib.CategoryTheory.Limits.Sifted","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\n⊢ CategoryTheory.IsSiftedOrEmpty C","decl":"/-- A category with binary coproducts is sifted or empty. -/\ninstance [HasBinaryCoproducts C] : IsSiftedOrEmpty C := by\n    constructor\n    rintro ⟨c₁, c₂⟩\n    haveI : _root_.Nonempty <| StructuredArrow (c₁,c₂) (diag C) :=\n      ⟨.mk ((coprod.inl : c₁ ⟶ c₁ ⨿ c₂), (coprod.inr : c₂ ⟶ c₁ ⨿ c₂))⟩\n    apply isConnected_of_zigzag\n    rintro ⟨_, c, f⟩ ⟨_, c', g⟩\n    dsimp only [const_obj_obj, diag_obj, prod_Hom] at f g\n    use [.mk ((coprod.inl : c₁ ⟶ c₁ ⨿ c₂), (coprod.inr : c₂ ⟶ c₁ ⨿ c₂)), .mk (g.fst, g.snd)]\n    simp only [colimit.cocone_x, diag_obj, Prod.mk.eta, List.chain_cons, List.Chain.nil, and_true,\n      ne_eq, reduceCtorEq, not_false_eq_true, List.getLast_cons, List.cons_ne_self,\n      List.getLast_singleton]\n    exact ⟨⟨Zag.of_inv <| StructuredArrow.homMk <| coprod.desc f.fst f.snd,\n      Zag.of_hom <| StructuredArrow.homMk <| coprod.desc g.fst g.snd⟩, rfl⟩\n\n"}
{"name":"CategoryTheory.IsSifted.isSifted_of_hasBinaryCoproducts_and_nonempty","module":"Mathlib.CategoryTheory.Limits.Sifted","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : Nonempty C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\n⊢ CategoryTheory.IsSifted C","decl":"/-- A nonempty category with binary coproducts is sifted. -/\ninstance isSifted_of_hasBinaryCoproducts_and_nonempty [_root_.Nonempty C] [HasBinaryCoproducts C] :\n    IsSifted C where\n\n"}
{"name":"CategoryTheory.instFinalProdProd'","module":"Mathlib.CategoryTheory.Limits.Sifted","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.IsSiftedOrEmpty C\nD : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} D\nD' : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D'\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor C D'\ninst✝¹ : F.Final\ninst✝ : G.Final\n⊢ (F.prod' G).Final","decl":"instance [F.Final] [G.Final] : (F.prod' G).Final :=\n  show (diag C ⋙ F.prod G).Final from final_comp _ _\n\n"}
