{"name":"Set.vadd_set_subset_add","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Add α\ns t : Set α\na : α\na✝ : Membership.mem s a\n⊢ HasSubset.Subset (HVAdd.hVAdd a t) (HAdd.hAdd s t)","decl":"@[to_additive] lemma smul_set_subset_mul : a ∈ s → a • t ⊆ s * t := image_subset_image2_right\n\n"}
{"name":"Set.smul_set_subset_mul","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns t : Set α\na : α\na✝ : Membership.mem s a\n⊢ HasSubset.Subset (HSMul.hSMul a t) (HMul.hMul s t)","decl":"@[to_additive] lemma smul_set_subset_mul : a ∈ s → a • t ⊆ s * t := image_subset_image2_right\n\n"}
{"name":"Set.op_vadd_set_subset_add","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Add α\ns t : Set α\na : α\na✝ : Membership.mem t a\n⊢ HasSubset.Subset (HVAdd.hVAdd (AddOpposite.op a) s) (HAdd.hAdd s t)","decl":"open scoped RightActions in\n@[to_additive] lemma op_smul_set_subset_mul : a ∈ t → s <• a ⊆ s * t := image_subset_image2_left\n\n"}
{"name":"Set.op_smul_set_subset_mul","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns t : Set α\na : α\na✝ : Membership.mem t a\n⊢ HasSubset.Subset (HSMul.hSMul (MulOpposite.op a) s) (HMul.hMul s t)","decl":"open scoped RightActions in\n@[to_additive] lemma op_smul_set_subset_mul : a ∈ t → s <• a ⊆ s * t := image_subset_image2_left\n\n"}
{"name":"Set.image_op_smul","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns t : Set α\n⊢ Eq (HSMul.hSMul (Set.image MulOpposite.op s) t) (HMul.hMul t s)","decl":"@[to_additive]\ntheorem image_op_smul : (op '' s) • t = t * s := by\n  rw [← image2_smul, ← image2_mul, image2_image_left, image2_swap]\n  rfl\n\n"}
{"name":"Set.image_op_vadd","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Add α\ns t : Set α\n⊢ Eq (HVAdd.hVAdd (Set.image AddOpposite.op s) t) (HAdd.hAdd t s)","decl":"@[to_additive]\ntheorem image_op_smul : (op '' s) • t = t * s := by\n  rw [← image2_smul, ← image2_mul, image2_image_left, image2_swap]\n  rfl\n\n"}
{"name":"Set.iUnion_op_smul_set","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns t : Set α\n⊢ Eq (Set.iUnion fun a => Set.iUnion fun h => HSMul.hSMul (MulOpposite.op a) s) (HMul.hMul s t)","decl":"@[to_additive (attr := simp)]\ntheorem iUnion_op_smul_set (s t : Set α) : ⋃ a ∈ t, MulOpposite.op a • s = s * t :=\n  iUnion_image_right _\n\n"}
{"name":"Set.iUnion_op_vadd_set","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Add α\ns t : Set α\n⊢ Eq (Set.iUnion fun a => Set.iUnion fun h => HVAdd.hVAdd (AddOpposite.op a) s) (HAdd.hAdd s t)","decl":"@[to_additive (attr := simp)]\ntheorem iUnion_op_smul_set (s t : Set α) : ⋃ a ∈ t, MulOpposite.op a • s = s * t :=\n  iUnion_image_right _\n\n"}
{"name":"Set.add_subset_iff_left","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Add α\ns t u : Set α\n⊢ Iff (HasSubset.Subset (HAdd.hAdd s t) u) (∀ (a : α), Membership.mem s a → HasSubset.Subset (HVAdd.hVAdd a t) u)","decl":"@[to_additive]\ntheorem mul_subset_iff_left : s * t ⊆ u ↔ ∀ a ∈ s, a • t ⊆ u :=\n  image2_subset_iff_left\n\n"}
{"name":"Set.mul_subset_iff_left","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns t u : Set α\n⊢ Iff (HasSubset.Subset (HMul.hMul s t) u) (∀ (a : α), Membership.mem s a → HasSubset.Subset (HSMul.hSMul a t) u)","decl":"@[to_additive]\ntheorem mul_subset_iff_left : s * t ⊆ u ↔ ∀ a ∈ s, a • t ⊆ u :=\n  image2_subset_iff_left\n\n"}
{"name":"Set.add_subset_iff_right","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Add α\ns t u : Set α\n⊢ Iff (HasSubset.Subset (HAdd.hAdd s t) u) (∀ (b : α), Membership.mem t b → HasSubset.Subset (HVAdd.hVAdd (AddOpposite.op b) s) u)","decl":"@[to_additive]\ntheorem mul_subset_iff_right : s * t ⊆ u ↔ ∀ b ∈ t, op b • s ⊆ u :=\n  image2_subset_iff_right\n\n"}
{"name":"Set.mul_subset_iff_right","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns t u : Set α\n⊢ Iff (HasSubset.Subset (HMul.hMul s t) u) (∀ (b : α), Membership.mem t b → HasSubset.Subset (HSMul.hSMul (MulOpposite.op b) s) u)","decl":"@[to_additive]\ntheorem mul_subset_iff_right : s * t ⊆ u ↔ ∀ b ∈ t, op b • s ⊆ u :=\n  image2_subset_iff_right\n\n"}
{"name":"Set.pair_add","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Add α\na b : α\ns : Set α\n⊢ Eq (HAdd.hAdd (Insert.insert a (Singleton.singleton b)) s) (Union.union (HVAdd.hVAdd a s) (HVAdd.hVAdd b s))","decl":"@[to_additive] lemma pair_mul (a b : α) (s : Set α) : {a, b} * s = a • s ∪ b • s := by\n  rw [insert_eq, union_mul, singleton_mul, singleton_mul]; rfl\n\n"}
{"name":"Set.pair_mul","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Mul α\na b : α\ns : Set α\n⊢ Eq (HMul.hMul (Insert.insert a (Singleton.singleton b)) s) (Union.union (HSMul.hSMul a s) (HSMul.hSMul b s))","decl":"@[to_additive] lemma pair_mul (a b : α) (s : Set α) : {a, b} * s = a • s ∪ b • s := by\n  rw [insert_eq, union_mul, singleton_mul, singleton_mul]; rfl\n\n"}
{"name":"Set.mul_pair","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns : Set α\na b : α\n⊢ Eq (HMul.hMul s (Insert.insert a (Singleton.singleton b))) (Union.union (HSMul.hSMul (MulOpposite.op a) s) (HSMul.hSMul (MulOpposite.op b) s))","decl":"@[to_additive] lemma mul_pair (s : Set α) (a b : α) : s * {a, b} = s <• a ∪ s <• b := by\n  rw [insert_eq, mul_union, mul_singleton, mul_singleton]; rfl\n\n"}
{"name":"Set.add_pair","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Add α\ns : Set α\na b : α\n⊢ Eq (HAdd.hAdd s (Insert.insert a (Singleton.singleton b))) (Union.union (HVAdd.hVAdd (AddOpposite.op a) s) (HVAdd.hVAdd (AddOpposite.op b) s))","decl":"@[to_additive] lemma mul_pair (s : Set α) (a b : α) : s * {a, b} = s <• a ∪ s <• b := by\n  rw [insert_eq, mul_union, mul_singleton, mul_singleton]; rfl\n\n"}
{"name":"Set.range_add","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Add α\nι : Sort u_5\na : α\nf : ι → α\n⊢ Eq (Set.range fun i => HAdd.hAdd a (f i)) (HVAdd.hVAdd a (Set.range f))","decl":"@[to_additive] lemma range_mul [Mul α] {ι : Sort*} (a : α) (f : ι → α) :\n    range (fun i ↦ a * f i) = a • range f := range_smul a f\n\n"}
{"name":"Set.range_mul","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Mul α\nι : Sort u_5\na : α\nf : ι → α\n⊢ Eq (Set.range fun i => HMul.hMul a (f i)) (HSMul.hSMul a (Set.range f))","decl":"@[to_additive] lemma range_mul [Mul α] {ι : Sort*} (a : α) (f : ι → α) :\n    range (fun i ↦ a * f i) = a • range f := range_smul a f\n\n"}
{"name":"Set.vaddCommClass_set","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : VAdd α γ\ninst✝¹ : VAdd β γ\ninst✝ : VAddCommClass α β γ\n⊢ VAddCommClass α β (Set γ)","decl":"@[to_additive]\ninstance smulCommClass_set [SMul α γ] [SMul β γ] [SMulCommClass α β γ] :\n    SMulCommClass α β (Set γ) :=\n  ⟨fun _ _ ↦ Commute.set_image <| smul_comm _ _⟩\n\n"}
{"name":"Set.smulCommClass_set","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : SMul α γ\ninst✝¹ : SMul β γ\ninst✝ : SMulCommClass α β γ\n⊢ SMulCommClass α β (Set γ)","decl":"@[to_additive]\ninstance smulCommClass_set [SMul α γ] [SMul β γ] [SMulCommClass α β γ] :\n    SMulCommClass α β (Set γ) :=\n  ⟨fun _ _ ↦ Commute.set_image <| smul_comm _ _⟩\n\n"}
{"name":"Set.vaddCommClass_set'","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : VAdd α γ\ninst✝¹ : VAdd β γ\ninst✝ : VAddCommClass α β γ\n⊢ VAddCommClass α (Set β) (Set γ)","decl":"@[to_additive]\ninstance smulCommClass_set' [SMul α γ] [SMul β γ] [SMulCommClass α β γ] :\n    SMulCommClass α (Set β) (Set γ) :=\n  ⟨fun _ _ _ ↦ image_image2_distrib_right <| smul_comm _⟩\n\n"}
{"name":"Set.smulCommClass_set'","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : SMul α γ\ninst✝¹ : SMul β γ\ninst✝ : SMulCommClass α β γ\n⊢ SMulCommClass α (Set β) (Set γ)","decl":"@[to_additive]\ninstance smulCommClass_set' [SMul α γ] [SMul β γ] [SMulCommClass α β γ] :\n    SMulCommClass α (Set β) (Set γ) :=\n  ⟨fun _ _ _ ↦ image_image2_distrib_right <| smul_comm _⟩\n\n"}
{"name":"Set.vaddCommClass_set''","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : VAdd α γ\ninst✝¹ : VAdd β γ\ninst✝ : VAddCommClass α β γ\n⊢ VAddCommClass (Set α) β (Set γ)","decl":"@[to_additive]\ninstance smulCommClass_set'' [SMul α γ] [SMul β γ] [SMulCommClass α β γ] :\n    SMulCommClass (Set α) β (Set γ) :=\n  haveI := SMulCommClass.symm α β γ\n  SMulCommClass.symm _ _ _\n\n"}
{"name":"Set.smulCommClass_set''","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : SMul α γ\ninst✝¹ : SMul β γ\ninst✝ : SMulCommClass α β γ\n⊢ SMulCommClass (Set α) β (Set γ)","decl":"@[to_additive]\ninstance smulCommClass_set'' [SMul α γ] [SMul β γ] [SMulCommClass α β γ] :\n    SMulCommClass (Set α) β (Set γ) :=\n  haveI := SMulCommClass.symm α β γ\n  SMulCommClass.symm _ _ _\n\n"}
{"name":"Set.vaddCommClass","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : VAdd α γ\ninst✝¹ : VAdd β γ\ninst✝ : VAddCommClass α β γ\n⊢ VAddCommClass (Set α) (Set β) (Set γ)","decl":"@[to_additive]\ninstance smulCommClass [SMul α γ] [SMul β γ] [SMulCommClass α β γ] :\n    SMulCommClass (Set α) (Set β) (Set γ) :=\n  ⟨fun _ _ _ ↦ image2_left_comm smul_comm⟩\n\n"}
{"name":"Set.smulCommClass","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : SMul α γ\ninst✝¹ : SMul β γ\ninst✝ : SMulCommClass α β γ\n⊢ SMulCommClass (Set α) (Set β) (Set γ)","decl":"@[to_additive]\ninstance smulCommClass [SMul α γ] [SMul β γ] [SMulCommClass α β γ] :\n    SMulCommClass (Set α) (Set β) (Set γ) :=\n  ⟨fun _ _ _ ↦ image2_left_comm smul_comm⟩\n\n"}
{"name":"Set.vaddAssocClass","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : VAdd α β\ninst✝² : VAdd α γ\ninst✝¹ : VAdd β γ\ninst✝ : VAddAssocClass α β γ\n⊢ VAddAssocClass α β (Set γ)","decl":"@[to_additive vaddAssocClass]\ninstance isScalarTower [SMul α β] [SMul α γ] [SMul β γ] [IsScalarTower α β γ] :\n    IsScalarTower α β (Set γ) where\n  smul_assoc a b T := by simp only [← image_smul, image_image, smul_assoc]\n\n"}
{"name":"Set.isScalarTower","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : SMul α β\ninst✝² : SMul α γ\ninst✝¹ : SMul β γ\ninst✝ : IsScalarTower α β γ\n⊢ IsScalarTower α β (Set γ)","decl":"@[to_additive vaddAssocClass]\ninstance isScalarTower [SMul α β] [SMul α γ] [SMul β γ] [IsScalarTower α β γ] :\n    IsScalarTower α β (Set γ) where\n  smul_assoc a b T := by simp only [← image_smul, image_image, smul_assoc]\n\n"}
{"name":"Set.vaddAssocClass'","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : VAdd α β\ninst✝² : VAdd α γ\ninst✝¹ : VAdd β γ\ninst✝ : VAddAssocClass α β γ\n⊢ VAddAssocClass α (Set β) (Set γ)","decl":"@[to_additive vaddAssocClass']\ninstance isScalarTower' [SMul α β] [SMul α γ] [SMul β γ] [IsScalarTower α β γ] :\n    IsScalarTower α (Set β) (Set γ) :=\n  ⟨fun _ _ _ ↦ image2_image_left_comm <| smul_assoc _⟩\n\n"}
{"name":"Set.isScalarTower'","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : SMul α β\ninst✝² : SMul α γ\ninst✝¹ : SMul β γ\ninst✝ : IsScalarTower α β γ\n⊢ IsScalarTower α (Set β) (Set γ)","decl":"@[to_additive vaddAssocClass']\ninstance isScalarTower' [SMul α β] [SMul α γ] [SMul β γ] [IsScalarTower α β γ] :\n    IsScalarTower α (Set β) (Set γ) :=\n  ⟨fun _ _ _ ↦ image2_image_left_comm <| smul_assoc _⟩\n\n"}
{"name":"Set.isScalarTower''","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : SMul α β\ninst✝² : SMul α γ\ninst✝¹ : SMul β γ\ninst✝ : IsScalarTower α β γ\n⊢ IsScalarTower (Set α) (Set β) (Set γ)","decl":"@[to_additive vaddAssocClass'']\ninstance isScalarTower'' [SMul α β] [SMul α γ] [SMul β γ] [IsScalarTower α β γ] :\n    IsScalarTower (Set α) (Set β) (Set γ) where\n  smul_assoc _ _ _ := image2_assoc smul_assoc\n\n"}
{"name":"Set.vaddAssocClass''","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : VAdd α β\ninst✝² : VAdd α γ\ninst✝¹ : VAdd β γ\ninst✝ : VAddAssocClass α β γ\n⊢ VAddAssocClass (Set α) (Set β) (Set γ)","decl":"@[to_additive vaddAssocClass'']\ninstance isScalarTower'' [SMul α β] [SMul α γ] [SMul β γ] [IsScalarTower α β γ] :\n    IsScalarTower (Set α) (Set β) (Set γ) where\n  smul_assoc _ _ _ := image2_assoc smul_assoc\n\n"}
{"name":"Set.isCentralVAdd","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : VAdd α β\ninst✝¹ : VAdd (AddOpposite α) β\ninst✝ : IsCentralVAdd α β\n⊢ IsCentralVAdd α (Set β)","decl":"@[to_additive]\ninstance isCentralScalar [SMul α β] [SMul αᵐᵒᵖ β] [IsCentralScalar α β] :\n    IsCentralScalar α (Set β) :=\n  ⟨fun _ S ↦ (congr_arg fun f ↦ f '' S) <| funext fun _ ↦ op_smul_eq_smul _ _⟩\n\n"}
{"name":"Set.isCentralScalar","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : SMul α β\ninst✝¹ : SMul (MulOpposite α) β\ninst✝ : IsCentralScalar α β\n⊢ IsCentralScalar α (Set β)","decl":"@[to_additive]\ninstance isCentralScalar [SMul α β] [SMul αᵐᵒᵖ β] [IsCentralScalar α β] :\n    IsCentralScalar α (Set β) :=\n  ⟨fun _ S ↦ (congr_arg fun f ↦ f '' S) <| funext fun _ ↦ op_smul_eq_smul _ _⟩\n\n"}
{"name":"Set.instNoZeroSMulDivisors","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Zero α\ninst✝² : Zero β\ninst✝¹ : SMul α β\ninst✝ : NoZeroSMulDivisors α β\n⊢ NoZeroSMulDivisors (Set α) (Set β)","decl":"instance [Zero α] [Zero β] [SMul α β] [NoZeroSMulDivisors α β] :\n    NoZeroSMulDivisors (Set α) (Set β) :=\n  ⟨fun {s t} h ↦ by\n    by_contra! H\n    have hst : (s • t).Nonempty := h.symm.subst zero_nonempty\n    rw [Ne, ← hst.of_smul_left.subset_zero_iff, Ne,\n      ← hst.of_smul_right.subset_zero_iff] at H\n    simp only [not_subset, mem_zero] at H\n    obtain ⟨⟨a, hs, ha⟩, b, ht, hb⟩ := H\n    exact (eq_zero_or_eq_zero_of_smul_eq_zero <| h.subset <| smul_mem_smul hs ht).elim ha hb⟩\n\n"}
{"name":"Set.noZeroSMulDivisors_set","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Zero α\ninst✝² : Zero β\ninst✝¹ : SMul α β\ninst✝ : NoZeroSMulDivisors α β\n⊢ NoZeroSMulDivisors α (Set β)","decl":"instance noZeroSMulDivisors_set [Zero α] [Zero β] [SMul α β] [NoZeroSMulDivisors α β] :\n    NoZeroSMulDivisors α (Set β) :=\n  ⟨fun {a s} h ↦ by\n    by_contra! H\n    have hst : (a • s).Nonempty := h.symm.subst zero_nonempty\n    rw [Ne, Ne, ← hst.of_image.subset_zero_iff, not_subset] at H\n    obtain ⟨ha, b, ht, hb⟩ := H\n    exact (eq_zero_or_eq_zero_of_smul_eq_zero <| h.subset <| smul_mem_smul_set ht).elim ha hb⟩\n\n"}
{"name":"Set.instNoZeroDivisors","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝² : Zero α\ninst✝¹ : Mul α\ninst✝ : NoZeroDivisors α\n⊢ NoZeroDivisors (Set α)","decl":"instance [Zero α] [Mul α] [NoZeroDivisors α] : NoZeroDivisors (Set α) :=\n  ⟨fun h ↦ eq_zero_or_eq_zero_of_smul_eq_zero h⟩\n\n"}
{"name":"Set.image_vadd_distrib","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : AddZeroClass α\ninst✝² : AddZeroClass β\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\nf : F\na : α\ns : Set α\n⊢ Eq (Set.image (⇑f) (HVAdd.hVAdd a s)) (HVAdd.hVAdd (f a) (Set.image (⇑f) s))","decl":"@[to_additive]\ntheorem image_smul_distrib [MulOneClass α] [MulOneClass β] [FunLike F α β] [MonoidHomClass F α β]\n    (f : F) (a : α) (s : Set α) :\n    f '' (a • s) = f a • f '' s :=\n  image_comm <| map_mul _ _\n\n"}
{"name":"Set.image_smul_distrib","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : MulOneClass α\ninst✝² : MulOneClass β\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\nf : F\na : α\ns : Set α\n⊢ Eq (Set.image (⇑f) (HSMul.hSMul a s)) (HSMul.hSMul (f a) (Set.image (⇑f) s))","decl":"@[to_additive]\ntheorem image_smul_distrib [MulOneClass α] [MulOneClass β] [FunLike F α β] [MonoidHomClass F α β]\n    (f : F) (a : α) (s : Set α) :\n    f '' (a • s) = f a • f '' s :=\n  image_comm <| map_mul _ _\n\n"}
{"name":"Set.image_op_vadd_distrib","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : AddZeroClass α\ninst✝² : AddZeroClass β\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\nf : F\na : α\ns : Set α\n⊢ Eq (Set.image (⇑f) (HVAdd.hVAdd (AddOpposite.op a) s)) (HVAdd.hVAdd (AddOpposite.op (f a)) (Set.image (⇑f) s))","decl":"open scoped RightActions in\n@[to_additive]\nlemma image_op_smul_distrib [MulOneClass α] [MulOneClass β] [FunLike F α β] [MonoidHomClass F α β]\n    (f : F) (a : α) (s : Set α) : f '' (s <• a) = f '' s <• f a := image_comm fun _ ↦ map_mul _ _ _\n\n"}
{"name":"Set.image_op_smul_distrib","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : MulOneClass α\ninst✝² : MulOneClass β\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\nf : F\na : α\ns : Set α\n⊢ Eq (Set.image (⇑f) (HSMul.hSMul (MulOpposite.op a) s)) (HSMul.hSMul (MulOpposite.op (f a)) (Set.image (⇑f) s))","decl":"open scoped RightActions in\n@[to_additive]\nlemma image_op_smul_distrib [MulOneClass α] [MulOneClass β] [FunLike F α β] [MonoidHomClass F α β]\n    (f : F) (a : α) (s : Set α) : f '' (s <• a) = f '' s <• f a := image_comm fun _ ↦ map_mul _ _ _\n\n"}
{"name":"Set.op_vadd_set_vadd_eq_vadd_vadd_set","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : VAdd (AddOpposite α) β\ninst✝¹ : VAdd β γ\ninst✝ : VAdd α γ\na : α\ns : Set β\nt : Set γ\nh : ∀ (a : α) (b : β) (c : γ), Eq (HVAdd.hVAdd (HVAdd.hVAdd (AddOpposite.op a) b) c) (HVAdd.hVAdd b (HVAdd.hVAdd a c))\n⊢ Eq (HVAdd.hVAdd (HVAdd.hVAdd (AddOpposite.op a) s) t) (HVAdd.hVAdd s (HVAdd.hVAdd a t))","decl":"@[to_additive]\ntheorem op_smul_set_smul_eq_smul_smul_set (a : α) (s : Set β) (t : Set γ)\n    (h : ∀ (a : α) (b : β) (c : γ), (op a • b) • c = b • a • c) : (op a • s) • t = s • a • t := by\n  ext\n  simp [mem_smul, mem_smul_set, h]\n\n"}
{"name":"Set.op_smul_set_smul_eq_smul_smul_set","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : SMul (MulOpposite α) β\ninst✝¹ : SMul β γ\ninst✝ : SMul α γ\na : α\ns : Set β\nt : Set γ\nh : ∀ (a : α) (b : β) (c : γ), Eq (HSMul.hSMul (HSMul.hSMul (MulOpposite.op a) b) c) (HSMul.hSMul b (HSMul.hSMul a c))\n⊢ Eq (HSMul.hSMul (HSMul.hSMul (MulOpposite.op a) s) t) (HSMul.hSMul s (HSMul.hSMul a t))","decl":"@[to_additive]\ntheorem op_smul_set_smul_eq_smul_smul_set (a : α) (s : Set β) (t : Set γ)\n    (h : ∀ (a : α) (b : β) (c : γ), (op a • b) • c = b • a • c) : (op a • s) • t = s • a • t := by\n  ext\n  simp [mem_smul, mem_smul_set, h]\n\n"}
{"name":"Set.smul_zero_subset","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Zero β\ninst✝ : SMulZeroClass α β\ns : Set α\n⊢ HasSubset.Subset (HSMul.hSMul s 0) 0","decl":"theorem smul_zero_subset (s : Set α) : s • (0 : Set β) ⊆ 0 := by simp [subset_def, mem_smul]\n\n"}
{"name":"Set.Nonempty.smul_zero","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Zero β\ninst✝ : SMulZeroClass α β\ns : Set α\nhs : s.Nonempty\n⊢ Eq (HSMul.hSMul s 0) 0","decl":"theorem Nonempty.smul_zero (hs : s.Nonempty) : s • (0 : Set β) = 0 :=\n  s.smul_zero_subset.antisymm <| by simpa [mem_smul] using hs\n\n"}
{"name":"Set.zero_mem_smul_set","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Zero β\ninst✝ : SMulZeroClass α β\nt : Set β\na : α\nh : Membership.mem t 0\n⊢ Membership.mem (HSMul.hSMul a t) 0","decl":"theorem zero_mem_smul_set (h : (0 : β) ∈ t) : (0 : β) ∈ a • t := ⟨0, h, smul_zero _⟩\n\n"}
{"name":"Set.zero_mem_smul_set_iff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Zero β\ninst✝² : SMulZeroClass α β\nt : Set β\na : α\ninst✝¹ : Zero α\ninst✝ : NoZeroSMulDivisors α β\nha : Ne a 0\n⊢ Iff (Membership.mem (HSMul.hSMul a t) 0) (Membership.mem t 0)","decl":"theorem zero_mem_smul_set_iff (ha : a ≠ 0) : (0 : β) ∈ a • t ↔ (0 : β) ∈ t := by\n  refine ⟨?_, zero_mem_smul_set⟩\n  rintro ⟨b, hb, h⟩\n  rwa [(eq_zero_or_eq_zero_of_smul_eq_zero h).resolve_left ha] at hb\n\n"}
{"name":"Set.zero_smul_subset","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Zero α\ninst✝¹ : Zero β\ninst✝ : SMulWithZero α β\nt : Set β\n⊢ HasSubset.Subset (HSMul.hSMul 0 t) 0","decl":"theorem zero_smul_subset (t : Set β) : (0 : Set α) • t ⊆ 0 := by simp [subset_def, mem_smul]\n\n"}
{"name":"Set.Nonempty.zero_smul","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Zero α\ninst✝¹ : Zero β\ninst✝ : SMulWithZero α β\nt : Set β\nht : t.Nonempty\n⊢ Eq (HSMul.hSMul 0 t) 0","decl":"theorem Nonempty.zero_smul (ht : t.Nonempty) : (0 : Set α) • t = 0 :=\n  t.zero_smul_subset.antisymm <| by simpa [mem_smul] using ht\n\n"}
{"name":"Set.zero_smul_set","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Zero α\ninst✝¹ : Zero β\ninst✝ : SMulWithZero α β\ns : Set β\nh : s.Nonempty\n⊢ Eq (HSMul.hSMul 0 s) 0","decl":"/-- A nonempty set is scaled by zero to the singleton set containing 0. -/\n@[simp] theorem zero_smul_set {s : Set β} (h : s.Nonempty) : (0 : α) • s = (0 : Set β) := by\n  simp only [← image_smul, image_eta, zero_smul, h.image_const, singleton_zero]\n\n"}
{"name":"Set.zero_smul_set_subset","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Zero α\ninst✝¹ : Zero β\ninst✝ : SMulWithZero α β\ns : Set β\n⊢ HasSubset.Subset (HSMul.hSMul 0 s) 0","decl":"theorem zero_smul_set_subset (s : Set β) : (0 : α) • s ⊆ 0 :=\n  image_subset_iff.2 fun x _ ↦ zero_smul α x\n\n"}
{"name":"Set.subsingleton_zero_smul_set","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Zero α\ninst✝¹ : Zero β\ninst✝ : SMulWithZero α β\ns : Set β\n⊢ (HSMul.hSMul 0 s).Subsingleton","decl":"theorem subsingleton_zero_smul_set (s : Set β) : ((0 : α) • s).Subsingleton :=\n  subsingleton_singleton.anti <| zero_smul_set_subset s\n\n"}
{"name":"Set.zero_mem_smul_iff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Zero α\ninst✝² : Zero β\ninst✝¹ : SMulWithZero α β\ns : Set α\nt : Set β\ninst✝ : NoZeroSMulDivisors α β\n⊢ Iff (Membership.mem (HSMul.hSMul s t) 0) (Or (And (Membership.mem s 0) t.Nonempty) (And (Membership.mem t 0) s.Nonempty))","decl":"theorem zero_mem_smul_iff :\n    (0 : β) ∈ s • t ↔ (0 : α) ∈ s ∧ t.Nonempty ∨ (0 : β) ∈ t ∧ s.Nonempty := by\n  constructor\n  · rintro ⟨a, ha, b, hb, h⟩\n    obtain rfl | rfl := eq_zero_or_eq_zero_of_smul_eq_zero h\n    · exact Or.inl ⟨ha, b, hb⟩\n    · exact Or.inr ⟨hb, a, ha⟩\n  · rintro (⟨hs, b, hb⟩ | ⟨ht, a, ha⟩)\n    · exact ⟨0, hs, b, hb, zero_smul _ _⟩\n    · exact ⟨a, ha, 0, ht, smul_zero _⟩\n\n"}
{"name":"Set.op_smul_set_mul_eq_mul_smul_set","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Semigroup α\na : α\ns t : Set α\n⊢ Eq (HMul.hMul (HSMul.hSMul (MulOpposite.op a) s) t) (HMul.hMul s (HSMul.hSMul a t))","decl":"@[to_additive]\ntheorem op_smul_set_mul_eq_mul_smul_set (a : α) (s : Set α) (t : Set α) :\n    op a • s * t = s * a • t :=\n  op_smul_set_smul_eq_smul_smul_set _ _ _ fun _ _ _ => mul_assoc _ _ _\n\n"}
{"name":"Set.op_vadd_set_add_eq_add_vadd_set","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : AddSemigroup α\na : α\ns t : Set α\n⊢ Eq (HAdd.hAdd (HVAdd.hVAdd (AddOpposite.op a) s) t) (HAdd.hAdd s (HVAdd.hVAdd a t))","decl":"@[to_additive]\ntheorem op_smul_set_mul_eq_mul_smul_set (a : α) (s : Set α) (t : Set α) :\n    op a • s * t = s * a • t :=\n  op_smul_set_smul_eq_smul_smul_set _ _ _ fun _ _ _ => mul_assoc _ _ _\n\n"}
{"name":"Set.pairwiseDisjoint_vadd_iff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝¹ : Add α\ninst✝ : IsLeftCancelAdd α\ns t : Set α\n⊢ Iff (s.PairwiseDisjoint fun x => HVAdd.hVAdd x t) (Set.InjOn (fun p => HAdd.hAdd p.1 p.2) (SProd.sprod s t))","decl":"@[to_additive]\ntheorem pairwiseDisjoint_smul_iff :\n    s.PairwiseDisjoint (· • t) ↔ (s ×ˢ t).InjOn fun p ↦ p.1 * p.2 :=\n  pairwiseDisjoint_image_right_iff fun _ _ ↦ mul_right_injective _\n\n"}
{"name":"Set.pairwiseDisjoint_smul_iff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝¹ : Mul α\ninst✝ : IsLeftCancelMul α\ns t : Set α\n⊢ Iff (s.PairwiseDisjoint fun x => HSMul.hSMul x t) (Set.InjOn (fun p => HMul.hMul p.1 p.2) (SProd.sprod s t))","decl":"@[to_additive]\ntheorem pairwiseDisjoint_smul_iff :\n    s.PairwiseDisjoint (· • t) ↔ (s ×ˢ t).InjOn fun p ↦ p.1 * p.2 :=\n  pairwiseDisjoint_image_right_iff fun _ _ ↦ mul_right_injective _\n\n"}
{"name":"Set.vadd_mem_vadd_set_iff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ns : Set β\na : α\nx : β\n⊢ Iff (Membership.mem (HVAdd.hVAdd a s) (HVAdd.hVAdd a x)) (Membership.mem s x)","decl":"@[to_additive (attr := simp)]\ntheorem smul_mem_smul_set_iff : a • x ∈ a • s ↔ x ∈ s :=\n  (MulAction.injective _).mem_set_image\n\n"}
{"name":"Set.smul_mem_smul_set_iff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\ns : Set β\na : α\nx : β\n⊢ Iff (Membership.mem (HSMul.hSMul a s) (HSMul.hSMul a x)) (Membership.mem s x)","decl":"@[to_additive (attr := simp)]\ntheorem smul_mem_smul_set_iff : a • x ∈ a • s ↔ x ∈ s :=\n  (MulAction.injective _).mem_set_image\n\n"}
{"name":"Set.mem_vadd_set_iff_neg_vadd_mem","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\nA : Set β\na : α\nx : β\n⊢ Iff (Membership.mem (HVAdd.hVAdd a A) x) (Membership.mem A (HVAdd.hVAdd (Neg.neg a) x))","decl":"@[to_additive]\ntheorem mem_smul_set_iff_inv_smul_mem : x ∈ a • A ↔ a⁻¹ • x ∈ A :=\n  show x ∈ MulAction.toPerm a '' A ↔ _ from mem_image_equiv\n\n"}
{"name":"Set.mem_smul_set_iff_inv_smul_mem","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\nA : Set β\na : α\nx : β\n⊢ Iff (Membership.mem (HSMul.hSMul a A) x) (Membership.mem A (HSMul.hSMul (Inv.inv a) x))","decl":"@[to_additive]\ntheorem mem_smul_set_iff_inv_smul_mem : x ∈ a • A ↔ a⁻¹ • x ∈ A :=\n  show x ∈ MulAction.toPerm a '' A ↔ _ from mem_image_equiv\n\n"}
{"name":"Set.mem_inv_smul_set_iff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\nA : Set β\na : α\nx : β\n⊢ Iff (Membership.mem (HSMul.hSMul (Inv.inv a) A) x) (Membership.mem A (HSMul.hSMul a x))","decl":"@[to_additive]\ntheorem mem_inv_smul_set_iff : x ∈ a⁻¹ • A ↔ a • x ∈ A := by\n  simp only [← image_smul, mem_image, inv_smul_eq_iff, exists_eq_right]\n\n"}
{"name":"Set.mem_neg_vadd_set_iff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\nA : Set β\na : α\nx : β\n⊢ Iff (Membership.mem (HVAdd.hVAdd (Neg.neg a) A) x) (Membership.mem A (HVAdd.hVAdd a x))","decl":"@[to_additive]\ntheorem mem_inv_smul_set_iff : x ∈ a⁻¹ • A ↔ a • x ∈ A := by\n  simp only [← image_smul, mem_image, inv_smul_eq_iff, exists_eq_right]\n\n"}
{"name":"Set.mem_smul_set_inv","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Group α\na b : α\ns : Set α\n⊢ Iff (Membership.mem (HSMul.hSMul b (Inv.inv s)) a) (Membership.mem (HSMul.hSMul a s) b)","decl":"@[to_additive (attr := simp)]\nlemma mem_smul_set_inv {s : Set α} : a ∈ b • s⁻¹ ↔ b ∈ a • s := by\n  simp [mem_smul_set_iff_inv_smul_mem]\n\n"}
{"name":"Set.mem_vadd_set_neg","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\na b : α\ns : Set α\n⊢ Iff (Membership.mem (HVAdd.hVAdd b (Neg.neg s)) a) (Membership.mem (HVAdd.hVAdd a s) b)","decl":"@[to_additive (attr := simp)]\nlemma mem_smul_set_inv {s : Set α} : a ∈ b • s⁻¹ ↔ b ∈ a • s := by\n  simp [mem_smul_set_iff_inv_smul_mem]\n\n"}
{"name":"Set.preimage_smul","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\na : α\nt : Set β\n⊢ Eq (Set.preimage (fun x => HSMul.hSMul a x) t) (HSMul.hSMul (Inv.inv a) t)","decl":"@[to_additive]\ntheorem preimage_smul (a : α) (t : Set β) : (fun x ↦ a • x) ⁻¹' t = a⁻¹ • t :=\n  ((MulAction.toPerm a).symm.image_eq_preimage _).symm\n\n"}
{"name":"Set.preimage_vadd","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\na : α\nt : Set β\n⊢ Eq (Set.preimage (fun x => HVAdd.hVAdd a x) t) (HVAdd.hVAdd (Neg.neg a) t)","decl":"@[to_additive]\ntheorem preimage_smul (a : α) (t : Set β) : (fun x ↦ a • x) ⁻¹' t = a⁻¹ • t :=\n  ((MulAction.toPerm a).symm.image_eq_preimage _).symm\n\n"}
{"name":"Set.preimage_vadd_neg","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\na : α\nt : Set β\n⊢ Eq (Set.preimage (fun x => HVAdd.hVAdd (Neg.neg a) x) t) (HVAdd.hVAdd a t)","decl":"@[to_additive]\ntheorem preimage_smul_inv (a : α) (t : Set β) : (fun x ↦ a⁻¹ • x) ⁻¹' t = a • t :=\n  preimage_smul (toUnits a)⁻¹ t\n\n"}
{"name":"Set.preimage_smul_inv","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\na : α\nt : Set β\n⊢ Eq (Set.preimage (fun x => HSMul.hSMul (Inv.inv a) x) t) (HSMul.hSMul a t)","decl":"@[to_additive]\ntheorem preimage_smul_inv (a : α) (t : Set β) : (fun x ↦ a⁻¹ • x) ⁻¹' t = a • t :=\n  preimage_smul (toUnits a)⁻¹ t\n\n"}
{"name":"Set.smul_set_subset_smul_set_iff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\nA B : Set β\na : α\n⊢ Iff (HasSubset.Subset (HSMul.hSMul a A) (HSMul.hSMul a B)) (HasSubset.Subset A B)","decl":"@[to_additive (attr := simp)]\ntheorem smul_set_subset_smul_set_iff : a • A ⊆ a • B ↔ A ⊆ B :=\n  image_subset_image_iff <| MulAction.injective _\n\n"}
{"name":"Set.vadd_set_subset_vadd_set_iff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\nA B : Set β\na : α\n⊢ Iff (HasSubset.Subset (HVAdd.hVAdd a A) (HVAdd.hVAdd a B)) (HasSubset.Subset A B)","decl":"@[to_additive (attr := simp)]\ntheorem smul_set_subset_smul_set_iff : a • A ⊆ a • B ↔ A ⊆ B :=\n  image_subset_image_iff <| MulAction.injective _\n\n"}
{"name":"Set.set_smul_subset_set_smul_iff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\nA B : Set β\na : α\n⊢ Iff (HasSubset.Subset (HSMul.hSMul a A) (HSMul.hSMul a B)) (HasSubset.Subset A B)","decl":"@[deprecated (since := \"2024-12-28\")]\nalias set_smul_subset_set_smul_iff := smul_set_subset_smul_set_iff\n\n"}
{"name":"Set.smul_set_subset_iff_subset_inv_smul_set","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\nA B : Set β\na : α\n⊢ Iff (HasSubset.Subset (HSMul.hSMul a A) B) (HasSubset.Subset A (HSMul.hSMul (Inv.inv a) B))","decl":"@[to_additive]\ntheorem smul_set_subset_iff_subset_inv_smul_set : a • A ⊆ B ↔ A ⊆ a⁻¹ • B :=\n  image_subset_iff.trans <|\n    iff_of_eq <| congr_arg _ <| preimage_equiv_eq_image_symm _ <| MulAction.toPerm _\n\n"}
{"name":"Set.vadd_set_subset_iff_subset_neg_vadd_set","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\nA B : Set β\na : α\n⊢ Iff (HasSubset.Subset (HVAdd.hVAdd a A) B) (HasSubset.Subset A (HVAdd.hVAdd (Neg.neg a) B))","decl":"@[to_additive]\ntheorem smul_set_subset_iff_subset_inv_smul_set : a • A ⊆ B ↔ A ⊆ a⁻¹ • B :=\n  image_subset_iff.trans <|\n    iff_of_eq <| congr_arg _ <| preimage_equiv_eq_image_symm _ <| MulAction.toPerm _\n\n"}
{"name":"Set.set_smul_subset_iff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\nA B : Set β\na : α\n⊢ Iff (HasSubset.Subset (HSMul.hSMul a A) B) (HasSubset.Subset A (HSMul.hSMul (Inv.inv a) B))","decl":"@[deprecated (since := \"2024-12-28\")]\nalias set_smul_subset_iff := smul_set_subset_iff_subset_inv_smul_set\n\n"}
{"name":"Set.subset_smul_set_iff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\nA B : Set β\na : α\n⊢ Iff (HasSubset.Subset A (HSMul.hSMul a B)) (HasSubset.Subset (HSMul.hSMul (Inv.inv a) A) B)","decl":"@[to_additive]\ntheorem subset_smul_set_iff : A ⊆ a • B ↔ a⁻¹ • A ⊆ B :=\n  Iff.symm <|\n    image_subset_iff.trans <|\n      Iff.symm <| iff_of_eq <| congr_arg _ <| image_equiv_eq_preimage_symm _ <| MulAction.toPerm _\n\n"}
{"name":"Set.subset_vadd_set_iff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\nA B : Set β\na : α\n⊢ Iff (HasSubset.Subset A (HVAdd.hVAdd a B)) (HasSubset.Subset (HVAdd.hVAdd (Neg.neg a) A) B)","decl":"@[to_additive]\ntheorem subset_smul_set_iff : A ⊆ a • B ↔ a⁻¹ • A ⊆ B :=\n  Iff.symm <|\n    image_subset_iff.trans <|\n      Iff.symm <| iff_of_eq <| congr_arg _ <| image_equiv_eq_preimage_symm _ <| MulAction.toPerm _\n\n"}
{"name":"Set.subset_set_smul_iff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\nA B : Set β\na : α\n⊢ Iff (HasSubset.Subset A (HSMul.hSMul a B)) (HasSubset.Subset (HSMul.hSMul (Inv.inv a) A) B)","decl":"@[deprecated (since := \"2024-12-28\")] alias subset_set_smul_iff := subset_smul_set_iff\n\n"}
{"name":"Set.vadd_set_inter","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ns t : Set β\na : α\n⊢ Eq (HVAdd.hVAdd a (Inter.inter s t)) (Inter.inter (HVAdd.hVAdd a s) (HVAdd.hVAdd a t))","decl":"@[to_additive]\ntheorem smul_set_inter : a • (s ∩ t) = a • s ∩ a • t :=\n  image_inter <| MulAction.injective a\n\n"}
{"name":"Set.smul_set_inter","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\ns t : Set β\na : α\n⊢ Eq (HSMul.hSMul a (Inter.inter s t)) (Inter.inter (HSMul.hSMul a s) (HSMul.hSMul a t))","decl":"@[to_additive]\ntheorem smul_set_inter : a • (s ∩ t) = a • s ∩ a • t :=\n  image_inter <| MulAction.injective a\n\n"}
{"name":"Set.smul_set_iInter","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\nι : Sort u_5\na : α\nt : ι → Set β\n⊢ Eq (HSMul.hSMul a (Set.iInter fun i => t i)) (Set.iInter fun i => HSMul.hSMul a (t i))","decl":"@[to_additive]\ntheorem smul_set_iInter {ι : Sort*}\n    (a : α) (t : ι → Set β) : (a • ⋂ i, t i) = ⋂ i, a • t i :=\n  image_iInter (MulAction.bijective a) t\n\n"}
{"name":"Set.vadd_set_iInter","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\nι : Sort u_5\na : α\nt : ι → Set β\n⊢ Eq (HVAdd.hVAdd a (Set.iInter fun i => t i)) (Set.iInter fun i => HVAdd.hVAdd a (t i))","decl":"@[to_additive]\ntheorem smul_set_iInter {ι : Sort*}\n    (a : α) (t : ι → Set β) : (a • ⋂ i, t i) = ⋂ i, a • t i :=\n  image_iInter (MulAction.bijective a) t\n\n"}
{"name":"Set.vadd_set_sdiff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ns t : Set β\na : α\n⊢ Eq (HVAdd.hVAdd a (SDiff.sdiff s t)) (SDiff.sdiff (HVAdd.hVAdd a s) (HVAdd.hVAdd a t))","decl":"@[to_additive]\ntheorem smul_set_sdiff : a • (s \\ t) = a • s \\ a • t :=\n  image_diff (MulAction.injective a) _ _\n\n"}
{"name":"Set.smul_set_sdiff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\ns t : Set β\na : α\n⊢ Eq (HSMul.hSMul a (SDiff.sdiff s t)) (SDiff.sdiff (HSMul.hSMul a s) (HSMul.hSMul a t))","decl":"@[to_additive]\ntheorem smul_set_sdiff : a • (s \\ t) = a • s \\ a • t :=\n  image_diff (MulAction.injective a) _ _\n\n"}
{"name":"Set.smul_set_symmDiff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\ns t : Set β\na : α\n⊢ Eq (HSMul.hSMul a (symmDiff s t)) (symmDiff (HSMul.hSMul a s) (HSMul.hSMul a t))","decl":"open scoped symmDiff in\n@[to_additive]\ntheorem smul_set_symmDiff : a • s ∆ t = (a • s) ∆ (a • t) :=\n  image_symmDiff (MulAction.injective a) _ _\n\n"}
{"name":"Set.vadd_set_symmDiff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ns t : Set β\na : α\n⊢ Eq (HVAdd.hVAdd a (symmDiff s t)) (symmDiff (HVAdd.hVAdd a s) (HVAdd.hVAdd a t))","decl":"open scoped symmDiff in\n@[to_additive]\ntheorem smul_set_symmDiff : a • s ∆ t = (a • s) ∆ (a • t) :=\n  image_symmDiff (MulAction.injective a) _ _\n\n"}
{"name":"Set.smul_set_univ","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\na : α\n⊢ Eq (HSMul.hSMul a Set.univ) Set.univ","decl":"@[to_additive (attr := simp)]\ntheorem smul_set_univ : a • (univ : Set β) = univ :=\n  image_univ_of_surjective <| MulAction.surjective a\n\n"}
{"name":"Set.vadd_set_univ","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\na : α\n⊢ Eq (HVAdd.hVAdd a Set.univ) Set.univ","decl":"@[to_additive (attr := simp)]\ntheorem smul_set_univ : a • (univ : Set β) = univ :=\n  image_univ_of_surjective <| MulAction.surjective a\n\n"}
{"name":"Set.vadd_univ","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ns : Set α\nhs : s.Nonempty\n⊢ Eq (HVAdd.hVAdd s Set.univ) Set.univ","decl":"@[to_additive (attr := simp)]\ntheorem smul_univ {s : Set α} (hs : s.Nonempty) : s • (univ : Set β) = univ :=\n  let ⟨a, ha⟩ := hs\n  eq_univ_of_forall fun b ↦ ⟨a, ha, a⁻¹ • b, trivial, smul_inv_smul _ _⟩\n\n"}
{"name":"Set.smul_univ","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\ns : Set α\nhs : s.Nonempty\n⊢ Eq (HSMul.hSMul s Set.univ) Set.univ","decl":"@[to_additive (attr := simp)]\ntheorem smul_univ {s : Set α} (hs : s.Nonempty) : s • (univ : Set β) = univ :=\n  let ⟨a, ha⟩ := hs\n  eq_univ_of_forall fun b ↦ ⟨a, ha, a⁻¹ • b, trivial, smul_inv_smul _ _⟩\n\n"}
{"name":"Set.smul_set_compl","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\ns : Set β\na : α\n⊢ Eq (HSMul.hSMul a (HasCompl.compl s)) (HasCompl.compl (HSMul.hSMul a s))","decl":"@[to_additive]\ntheorem smul_set_compl : a • sᶜ = (a • s)ᶜ := by\n  simp_rw [Set.compl_eq_univ_diff, smul_set_sdiff, smul_set_univ]\n\n"}
{"name":"Set.vadd_set_compl","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ns : Set β\na : α\n⊢ Eq (HVAdd.hVAdd a (HasCompl.compl s)) (HasCompl.compl (HVAdd.hVAdd a s))","decl":"@[to_additive]\ntheorem smul_set_compl : a • sᶜ = (a • s)ᶜ := by\n  simp_rw [Set.compl_eq_univ_diff, smul_set_sdiff, smul_set_univ]\n\n"}
{"name":"Set.smul_inter_ne_empty_iff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Group α\ns t : Set α\nx : α\n⊢ Iff (Ne (Inter.inter (HSMul.hSMul x s) t) EmptyCollection.emptyCollection) (Exists fun a => Exists fun b => And (And (Membership.mem t a) (Membership.mem s b)) (Eq (HMul.hMul a (Inv.inv b)) x))","decl":"@[to_additive]\ntheorem smul_inter_ne_empty_iff {s t : Set α} {x : α} :\n    x • s ∩ t ≠ ∅ ↔ ∃ a b, (a ∈ t ∧ b ∈ s) ∧ a * b⁻¹ = x := by\n  rw [← nonempty_iff_ne_empty]\n  constructor\n  · rintro ⟨a, h, ha⟩\n    obtain ⟨b, hb, rfl⟩ := mem_smul_set.mp h\n    exact ⟨x • b, b, ⟨ha, hb⟩, by simp⟩\n  · rintro ⟨a, b, ⟨ha, hb⟩, rfl⟩\n    exact ⟨a, mem_inter (mem_smul_set.mpr ⟨b, hb, by simp⟩) ha⟩\n\n"}
{"name":"Set.vadd_inter_ne_empty_iff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\ns t : Set α\nx : α\n⊢ Iff (Ne (Inter.inter (HVAdd.hVAdd x s) t) EmptyCollection.emptyCollection) (Exists fun a => Exists fun b => And (And (Membership.mem t a) (Membership.mem s b)) (Eq (HAdd.hAdd a (Neg.neg b)) x))","decl":"@[to_additive]\ntheorem smul_inter_ne_empty_iff {s t : Set α} {x : α} :\n    x • s ∩ t ≠ ∅ ↔ ∃ a b, (a ∈ t ∧ b ∈ s) ∧ a * b⁻¹ = x := by\n  rw [← nonempty_iff_ne_empty]\n  constructor\n  · rintro ⟨a, h, ha⟩\n    obtain ⟨b, hb, rfl⟩ := mem_smul_set.mp h\n    exact ⟨x • b, b, ⟨ha, hb⟩, by simp⟩\n  · rintro ⟨a, b, ⟨ha, hb⟩, rfl⟩\n    exact ⟨a, mem_inter (mem_smul_set.mpr ⟨b, hb, by simp⟩) ha⟩\n\n"}
{"name":"Set.smul_inter_ne_empty_iff'","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Group α\ns t : Set α\nx : α\n⊢ Iff (Ne (Inter.inter (HSMul.hSMul x s) t) EmptyCollection.emptyCollection) (Exists fun a => Exists fun b => And (And (Membership.mem t a) (Membership.mem s b)) (Eq (HDiv.hDiv a b) x))","decl":"@[to_additive]\ntheorem smul_inter_ne_empty_iff' {s t : Set α} {x : α} :\n    x • s ∩ t ≠ ∅ ↔ ∃ a b, (a ∈ t ∧ b ∈ s) ∧ a / b = x := by\n  simp_rw [smul_inter_ne_empty_iff, div_eq_mul_inv]\n\n"}
{"name":"Set.vadd_inter_ne_empty_iff'","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\ns t : Set α\nx : α\n⊢ Iff (Ne (Inter.inter (HVAdd.hVAdd x s) t) EmptyCollection.emptyCollection) (Exists fun a => Exists fun b => And (And (Membership.mem t a) (Membership.mem s b)) (Eq (HSub.hSub a b) x))","decl":"@[to_additive]\ntheorem smul_inter_ne_empty_iff' {s t : Set α} {x : α} :\n    x • s ∩ t ≠ ∅ ↔ ∃ a b, (a ∈ t ∧ b ∈ s) ∧ a / b = x := by\n  simp_rw [smul_inter_ne_empty_iff, div_eq_mul_inv]\n\n"}
{"name":"Set.op_smul_inter_ne_empty_iff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Group α\ns t : Set α\nx : MulOpposite α\n⊢ Iff (Ne (Inter.inter (HSMul.hSMul x s) t) EmptyCollection.emptyCollection) (Exists fun a => Exists fun b => And (And (Membership.mem s a) (Membership.mem t b)) (Eq (HMul.hMul (Inv.inv a) b) (MulOpposite.unop x)))","decl":"@[to_additive]\ntheorem op_smul_inter_ne_empty_iff {s t : Set α} {x : αᵐᵒᵖ} :\n    x • s ∩ t ≠ ∅ ↔ ∃ a b, (a ∈ s ∧ b ∈ t) ∧ a⁻¹ * b = MulOpposite.unop x := by\n  rw [← nonempty_iff_ne_empty]\n  constructor\n  · rintro ⟨a, h, ha⟩\n    obtain ⟨b, hb, rfl⟩ := mem_smul_set.mp h\n    exact ⟨b, x • b, ⟨hb, ha⟩, by simp⟩\n  · rintro ⟨a, b, ⟨ha, hb⟩, H⟩\n    have : MulOpposite.op (a⁻¹ * b) = x := congr_arg MulOpposite.op H\n    exact ⟨b, mem_inter (mem_smul_set.mpr ⟨a, ha, by simp [← this]⟩) hb⟩\n\n"}
{"name":"Set.op_vadd_inter_ne_empty_iff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\ns t : Set α\nx : AddOpposite α\n⊢ Iff (Ne (Inter.inter (HVAdd.hVAdd x s) t) EmptyCollection.emptyCollection) (Exists fun a => Exists fun b => And (And (Membership.mem s a) (Membership.mem t b)) (Eq (HAdd.hAdd (Neg.neg a) b) (AddOpposite.unop x)))","decl":"@[to_additive]\ntheorem op_smul_inter_ne_empty_iff {s t : Set α} {x : αᵐᵒᵖ} :\n    x • s ∩ t ≠ ∅ ↔ ∃ a b, (a ∈ s ∧ b ∈ t) ∧ a⁻¹ * b = MulOpposite.unop x := by\n  rw [← nonempty_iff_ne_empty]\n  constructor\n  · rintro ⟨a, h, ha⟩\n    obtain ⟨b, hb, rfl⟩ := mem_smul_set.mp h\n    exact ⟨b, x • b, ⟨hb, ha⟩, by simp⟩\n  · rintro ⟨a, b, ⟨ha, hb⟩, H⟩\n    have : MulOpposite.op (a⁻¹ * b) = x := congr_arg MulOpposite.op H\n    exact ⟨b, mem_inter (mem_smul_set.mpr ⟨a, ha, by simp [← this]⟩) hb⟩\n\n"}
{"name":"Set.iUnion_neg_vadd","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ns : Set β\n⊢ Eq (Set.iUnion fun g => HVAdd.hVAdd (Neg.neg g) s) (Set.iUnion fun g => HVAdd.hVAdd g s)","decl":"@[to_additive (attr := simp)]\ntheorem iUnion_inv_smul : ⋃ g : α, g⁻¹ • s = ⋃ g : α, g • s :=\n  (Function.Surjective.iSup_congr _ inv_surjective) fun _ ↦ rfl\n\n"}
{"name":"Set.iUnion_inv_smul","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\ns : Set β\n⊢ Eq (Set.iUnion fun g => HSMul.hSMul (Inv.inv g) s) (Set.iUnion fun g => HSMul.hSMul g s)","decl":"@[to_additive (attr := simp)]\ntheorem iUnion_inv_smul : ⋃ g : α, g⁻¹ • s = ⋃ g : α, g • s :=\n  (Function.Surjective.iSup_congr _ inv_surjective) fun _ ↦ rfl\n\n"}
{"name":"Set.iUnion_smul_eq_setOf_exists","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\ns : Set β\n⊢ Eq (Set.iUnion fun g => HSMul.hSMul g s) (setOf fun a => Exists fun g => Membership.mem s (HSMul.hSMul g a))","decl":"@[to_additive]\ntheorem iUnion_smul_eq_setOf_exists {s : Set β} : ⋃ g : α, g • s = { a | ∃ g : α, g • a ∈ s } := by\n  simp_rw [← iUnion_setOf, ← iUnion_inv_smul, ← preimage_smul, preimage]\n\n"}
{"name":"Set.iUnion_vadd_eq_setOf_exists","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ns : Set β\n⊢ Eq (Set.iUnion fun g => HVAdd.hVAdd g s) (setOf fun a => Exists fun g => Membership.mem s (HVAdd.hVAdd g a))","decl":"@[to_additive]\ntheorem iUnion_smul_eq_setOf_exists {s : Set β} : ⋃ g : α, g • s = { a | ∃ g : α, g • a ∈ s } := by\n  simp_rw [← iUnion_setOf, ← iUnion_inv_smul, ← preimage_smul, preimage]\n\n"}
{"name":"Set.neg_vadd_set_distrib","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\na : α\ns : Set α\n⊢ Eq (Neg.neg (HVAdd.hVAdd a s)) (HVAdd.hVAdd (AddOpposite.op (Neg.neg a)) (Neg.neg s))","decl":"@[to_additive (attr := simp)]\nlemma inv_smul_set_distrib (a : α) (s : Set α) : (a • s)⁻¹ = op a⁻¹ • s⁻¹ := by\n  ext; simp [mem_smul_set_iff_inv_smul_mem]\n\n"}
{"name":"Set.inv_smul_set_distrib","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Group α\na : α\ns : Set α\n⊢ Eq (Inv.inv (HSMul.hSMul a s)) (HSMul.hSMul (MulOpposite.op (Inv.inv a)) (Inv.inv s))","decl":"@[to_additive (attr := simp)]\nlemma inv_smul_set_distrib (a : α) (s : Set α) : (a • s)⁻¹ = op a⁻¹ • s⁻¹ := by\n  ext; simp [mem_smul_set_iff_inv_smul_mem]\n\n"}
{"name":"Set.inv_op_smul_set_distrib","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Group α\na : α\ns : Set α\n⊢ Eq (Inv.inv (HSMul.hSMul (MulOpposite.op a) s)) (HSMul.hSMul (Inv.inv a) (Inv.inv s))","decl":"@[to_additive (attr := simp)]\nlemma inv_op_smul_set_distrib (a : α) (s : Set α) : (op a • s)⁻¹ = a⁻¹ • s⁻¹ := by\n  ext; simp [mem_smul_set_iff_inv_smul_mem]\n\n"}
{"name":"Set.neg_op_vadd_set_distrib","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\na : α\ns : Set α\n⊢ Eq (Neg.neg (HVAdd.hVAdd (AddOpposite.op a) s)) (HVAdd.hVAdd (Neg.neg a) (Neg.neg s))","decl":"@[to_additive (attr := simp)]\nlemma inv_op_smul_set_distrib (a : α) (s : Set α) : (op a • s)⁻¹ = a⁻¹ • s⁻¹ := by\n  ext; simp [mem_smul_set_iff_inv_smul_mem]\n\n"}
{"name":"Set.disjoint_vadd_set","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ns t : Set β\na : α\n⊢ Iff (Disjoint (HVAdd.hVAdd a s) (HVAdd.hVAdd a t)) (Disjoint s t)","decl":"@[to_additive (attr := simp)]\nlemma disjoint_smul_set : Disjoint (a • s) (a • t) ↔ Disjoint s t :=\n  disjoint_image_iff <| MulAction.injective _\n\n"}
{"name":"Set.disjoint_smul_set","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\ns t : Set β\na : α\n⊢ Iff (Disjoint (HSMul.hSMul a s) (HSMul.hSMul a t)) (Disjoint s t)","decl":"@[to_additive (attr := simp)]\nlemma disjoint_smul_set : Disjoint (a • s) (a • t) ↔ Disjoint s t :=\n  disjoint_image_iff <| MulAction.injective _\n\n"}
{"name":"Set.disjoint_smul_set_left","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\ns t : Set β\na : α\n⊢ Iff (Disjoint (HSMul.hSMul a s) t) (Disjoint s (HSMul.hSMul (Inv.inv a) t))","decl":"@[to_additive]\nlemma disjoint_smul_set_left : Disjoint (a • s) t ↔ Disjoint s (a⁻¹ • t) := by\n  simpa using disjoint_smul_set (a := a) (t := a⁻¹ • t)\n\n"}
{"name":"Set.disjoint_vadd_set_left","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ns t : Set β\na : α\n⊢ Iff (Disjoint (HVAdd.hVAdd a s) t) (Disjoint s (HVAdd.hVAdd (Neg.neg a) t))","decl":"@[to_additive]\nlemma disjoint_smul_set_left : Disjoint (a • s) t ↔ Disjoint s (a⁻¹ • t) := by\n  simpa using disjoint_smul_set (a := a) (t := a⁻¹ • t)\n\n"}
{"name":"Set.disjoint_smul_set_right","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\ns t : Set β\na : α\n⊢ Iff (Disjoint s (HSMul.hSMul a t)) (Disjoint (HSMul.hSMul (Inv.inv a) s) t)","decl":"@[to_additive]\nlemma disjoint_smul_set_right : Disjoint s (a • t) ↔ Disjoint (a⁻¹ • s) t := by\n  simpa using disjoint_smul_set (a := a) (s := a⁻¹ • s)\n\n"}
{"name":"Set.disjoint_vadd_set_right","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ns t : Set β\na : α\n⊢ Iff (Disjoint s (HVAdd.hVAdd a t)) (Disjoint (HVAdd.hVAdd (Neg.neg a) s) t)","decl":"@[to_additive]\nlemma disjoint_smul_set_right : Disjoint s (a • t) ↔ Disjoint (a⁻¹ • s) t := by\n  simpa using disjoint_smul_set (a := a) (s := a⁻¹ • s)\n\n"}
{"name":"Set.smul_set_disjoint_iff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\ns t : Set β\na : α\n⊢ Iff (Disjoint (HSMul.hSMul a s) (HSMul.hSMul a t)) (Disjoint s t)","decl":"@[to_additive] alias smul_set_disjoint_iff := disjoint_smul_set\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"Set.vadd_set_disjoint_iff","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ns t : Set β\na : α\n⊢ Iff (Disjoint (HVAdd.hVAdd a s) (HVAdd.hVAdd a t)) (Disjoint s t)","decl":"@[to_additive] alias smul_set_disjoint_iff := disjoint_smul_set\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"Set.exists_smul_inter_smul_subset_smul_inv_mul_inter_inv_mul","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : Group α\ns t : Set α\na b : α\n⊢ Exists fun z => HasSubset.Subset (Inter.inter (HSMul.hSMul a s) (HSMul.hSMul b t)) (HSMul.hSMul z (Inter.inter (HMul.hMul (Inv.inv s) s) (HMul.hMul (Inv.inv t) t)))","decl":"/-- Any intersection of translates of two sets `s` and `t` can be covered by a single translate of\n`(s⁻¹ * s) ∩ (t⁻¹ * t)`.\n\nThis is useful to show that the intersection of approximate subgroups is an approximate subgroup. -/\n@[to_additive\n\"Any intersection of translates of two sets `s` and `t` can be covered by a single translate of\n`(-s + s) ∩ (-t + t)`.\n\nThis is useful to show that the intersection of approximate subgroups is an approximate subgroup.\"]\nlemma exists_smul_inter_smul_subset_smul_inv_mul_inter_inv_mul (s t : Set α) (a b : α) :\n    ∃ z : α, a • s ∩ b • t ⊆ z • ((s⁻¹ * s) ∩ (t⁻¹ * t)) := by\n  obtain hAB | ⟨z, hzA, hzB⟩ := (a • s ∩ b • t).eq_empty_or_nonempty\n  · exact ⟨1, by simp [hAB]⟩\n  refine ⟨z, ?_⟩\n  calc\n    a • s ∩ b • t ⊆ (z • s⁻¹) * s ∩ ((z • t⁻¹) * t) := by\n      gcongr <;> apply smul_set_subset_mul <;> simpa\n    _ = z • ((s⁻¹ * s) ∩ (t⁻¹ * t)) := by simp_rw [Set.smul_set_inter, smul_mul_assoc]\n\n"}
{"name":"Set.exists_vadd_inter_vadd_subset_vadd_neg_add_inter_neg_add","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\ns t : Set α\na b : α\n⊢ Exists fun z => HasSubset.Subset (Inter.inter (HVAdd.hVAdd a s) (HVAdd.hVAdd b t)) (HVAdd.hVAdd z (Inter.inter (HAdd.hAdd (Neg.neg s) s) (HAdd.hAdd (Neg.neg t) t)))","decl":"/-- Any intersection of translates of two sets `s` and `t` can be covered by a single translate of\n`(s⁻¹ * s) ∩ (t⁻¹ * t)`.\n\nThis is useful to show that the intersection of approximate subgroups is an approximate subgroup. -/\n@[to_additive\n\"Any intersection of translates of two sets `s` and `t` can be covered by a single translate of\n`(-s + s) ∩ (-t + t)`.\n\nThis is useful to show that the intersection of approximate subgroups is an approximate subgroup.\"]\nlemma exists_smul_inter_smul_subset_smul_inv_mul_inter_inv_mul (s t : Set α) (a b : α) :\n    ∃ z : α, a • s ∩ b • t ⊆ z • ((s⁻¹ * s) ∩ (t⁻¹ * t)) := by\n  obtain hAB | ⟨z, hzA, hzB⟩ := (a • s ∩ b • t).eq_empty_or_nonempty\n  · exact ⟨1, by simp [hAB]⟩\n  refine ⟨z, ?_⟩\n  calc\n    a • s ∩ b • t ⊆ (z • s⁻¹) * s ∩ ((z • t⁻¹) * t) := by\n      gcongr <;> apply smul_set_subset_mul <;> simpa\n    _ = z • ((s⁻¹ * s) ∩ (t⁻¹ * t)) := by simp_rw [Set.smul_set_inter, smul_mul_assoc]\n\n"}
{"name":"Set.mem_invOf_smul_set","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Monoid α\ninst✝¹ : MulAction α β\ns : Set β\na : α\nb : β\ninst✝ : Invertible a\n⊢ Iff (Membership.mem (HSMul.hSMul (Invertible.invOf a) s) b) (Membership.mem s (HSMul.hSMul a b))","decl":"@[simp] lemma mem_invOf_smul_set [Invertible a] : b ∈ ⅟a • s ↔ a • b ∈ s :=\n  mem_inv_smul_set_iff (a := unitOfInvertible a)\n\n"}
{"name":"Set.smul_graphOn","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Group α\ninst✝² : CommGroup β\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\nx : Prod α β\ns : Set α\nf : F\n⊢ Eq (HSMul.hSMul x (Set.graphOn (⇑f) s)) (Set.graphOn (fun a => HMul.hMul (HDiv.hDiv x.2 (f x.1)) (f a)) (HSMul.hSMul x.1 s))","decl":"@[to_additive]\nlemma smul_graphOn (x : α × β) (s : Set α) (f : F) :\n    x • s.graphOn f = (x.1 • s).graphOn fun a ↦ x.2 / f x.1 * f a := by\n  ext ⟨a, b⟩\n  simp [mem_smul_set_iff_inv_smul_mem, Prod.ext_iff, and_comm (a := _ = a), inv_mul_eq_iff_eq_mul,\n    mul_left_comm _ _⁻¹, eq_inv_mul_iff_mul_eq, ← mul_div_right_comm, div_eq_iff_eq_mul, mul_comm b]\n\n"}
{"name":"Set.vadd_graphOn","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : AddGroup α\ninst✝² : AddCommGroup β\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\nx : Prod α β\ns : Set α\nf : F\n⊢ Eq (HVAdd.hVAdd x (Set.graphOn (⇑f) s)) (Set.graphOn (fun a => HAdd.hAdd (HSub.hSub x.2 (f x.1)) (f a)) (HVAdd.hVAdd x.1 s))","decl":"@[to_additive]\nlemma smul_graphOn (x : α × β) (s : Set α) (f : F) :\n    x • s.graphOn f = (x.1 • s).graphOn fun a ↦ x.2 / f x.1 * f a := by\n  ext ⟨a, b⟩\n  simp [mem_smul_set_iff_inv_smul_mem, Prod.ext_iff, and_comm (a := _ = a), inv_mul_eq_iff_eq_mul,\n    mul_left_comm _ _⁻¹, eq_inv_mul_iff_mul_eq, ← mul_div_right_comm, div_eq_iff_eq_mul, mul_comm b]\n\n"}
{"name":"Set.smul_graphOn_univ","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Group α\ninst✝² : CommGroup β\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\nx : Prod α β\nf : F\n⊢ Eq (HSMul.hSMul x (Set.graphOn (⇑f) Set.univ)) (Set.graphOn (fun a => HMul.hMul (HDiv.hDiv x.2 (f x.1)) (f a)) Set.univ)","decl":"@[to_additive]\nlemma smul_graphOn_univ (x : α × β) (f : F) :\n    x • univ.graphOn f = univ.graphOn fun a ↦ x.2 / f x.1 * f a := by simp [smul_graphOn]\n\n"}
{"name":"Set.vadd_graphOn_univ","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : AddGroup α\ninst✝² : AddCommGroup β\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\nx : Prod α β\nf : F\n⊢ Eq (HVAdd.hVAdd x (Set.graphOn (⇑f) Set.univ)) (Set.graphOn (fun a => HAdd.hAdd (HSub.hSub x.2 (f x.1)) (f a)) Set.univ)","decl":"@[to_additive]\nlemma smul_graphOn_univ (x : α × β) (f : F) :\n    x • univ.graphOn f = univ.graphOn fun a ↦ x.2 / f x.1 * f a := by simp [smul_graphOn]\n\n"}
{"name":"Set.smul_div_smul_comm","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : CommGroup α\na : α\ns : Set α\nb : α\nt : Set α\n⊢ Eq (HDiv.hDiv (HSMul.hSMul a s) (HSMul.hSMul b t)) (HSMul.hSMul (HDiv.hDiv a b) (HDiv.hDiv s t))","decl":"@[to_additive] lemma smul_div_smul_comm (a : α) (s : Set α) (b : α) (t : Set α) :\n    a • s / b • t = (a / b) • (s / t) := by\n  simp_rw [← image_smul, smul_eq_mul, ← singleton_mul, mul_div_mul_comm _ s,\n    singleton_div_singleton]\n\n"}
{"name":"Set.vadd_sub_vadd_comm","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : AddCommGroup α\na : α\ns : Set α\nb : α\nt : Set α\n⊢ Eq (HSub.hSub (HVAdd.hVAdd a s) (HVAdd.hVAdd b t)) (HVAdd.hVAdd (HSub.hSub a b) (HSub.hSub s t))","decl":"@[to_additive] lemma smul_div_smul_comm (a : α) (s : Set α) (b : α) (t : Set α) :\n    a • s / b • t = (a / b) • (s / t) := by\n  simp_rw [← image_smul, smul_eq_mul, ← singleton_mul, mul_div_mul_comm _ s,\n    singleton_div_singleton]\n\n"}
{"name":"Set.smul_mem_smul_set_iff₀","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : GroupWithZero α\ninst✝ : MulAction α β\na : α\nha : Ne a 0\nA : Set β\nx : β\n⊢ Iff (Membership.mem (HSMul.hSMul a A) (HSMul.hSMul a x)) (Membership.mem A x)","decl":"@[simp]\ntheorem smul_mem_smul_set_iff₀ (ha : a ≠ 0) (A : Set β) (x : β) : a • x ∈ a • A ↔ x ∈ A :=\n  show Units.mk0 a ha • _ ∈ _ ↔ _ from smul_mem_smul_set_iff\n\n"}
{"name":"Set.mem_smul_set_iff_inv_smul_mem₀","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : GroupWithZero α\ninst✝ : MulAction α β\na : α\nha : Ne a 0\nA : Set β\nx : β\n⊢ Iff (Membership.mem (HSMul.hSMul a A) x) (Membership.mem A (HSMul.hSMul (Inv.inv a) x))","decl":"theorem mem_smul_set_iff_inv_smul_mem₀ (ha : a ≠ 0) (A : Set β) (x : β) : x ∈ a • A ↔ a⁻¹ • x ∈ A :=\n  show _ ∈ Units.mk0 a ha • _ ↔ _ from mem_smul_set_iff_inv_smul_mem\n\n"}
{"name":"Set.mem_inv_smul_set_iff₀","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : GroupWithZero α\ninst✝ : MulAction α β\na : α\nha : Ne a 0\nA : Set β\nx : β\n⊢ Iff (Membership.mem (HSMul.hSMul (Inv.inv a) A) x) (Membership.mem A (HSMul.hSMul a x))","decl":"theorem mem_inv_smul_set_iff₀ (ha : a ≠ 0) (A : Set β) (x : β) : x ∈ a⁻¹ • A ↔ a • x ∈ A :=\n  show _ ∈ (Units.mk0 a ha)⁻¹ • _ ↔ _ from mem_inv_smul_set_iff\n\n"}
{"name":"Set.preimage_smul₀","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : GroupWithZero α\ninst✝ : MulAction α β\na : α\nha : Ne a 0\nt : Set β\n⊢ Eq (Set.preimage (fun x => HSMul.hSMul a x) t) (HSMul.hSMul (Inv.inv a) t)","decl":"theorem preimage_smul₀ (ha : a ≠ 0) (t : Set β) : (fun x ↦ a • x) ⁻¹' t = a⁻¹ • t :=\n  preimage_smul (Units.mk0 a ha) t\n\n"}
{"name":"Set.preimage_smul_inv₀","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : GroupWithZero α\ninst✝ : MulAction α β\na : α\nha : Ne a 0\nt : Set β\n⊢ Eq (Set.preimage (fun x => HSMul.hSMul (Inv.inv a) x) t) (HSMul.hSMul a t)","decl":"theorem preimage_smul_inv₀ (ha : a ≠ 0) (t : Set β) : (fun x ↦ a⁻¹ • x) ⁻¹' t = a • t :=\n  preimage_smul (Units.mk0 a ha)⁻¹ t\n\n"}
{"name":"Set.smul_set_subset_smul_set_iff₀","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : GroupWithZero α\ninst✝ : MulAction α β\na : α\nha : Ne a 0\nA B : Set β\n⊢ Iff (HasSubset.Subset (HSMul.hSMul a A) (HSMul.hSMul a B)) (HasSubset.Subset A B)","decl":"@[simp]\ntheorem smul_set_subset_smul_set_iff₀ (ha : a ≠ 0) {A B : Set β} : a • A ⊆ a • B ↔ A ⊆ B :=\n  show Units.mk0 a ha • _ ⊆ _ ↔ _ from smul_set_subset_smul_set_iff\n\n"}
{"name":"Set.set_smul_subset_set_smul_iff₀","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : GroupWithZero α\ninst✝ : MulAction α β\na : α\nha : Ne a 0\nA B : Set β\n⊢ Iff (HasSubset.Subset (HSMul.hSMul a A) (HSMul.hSMul a B)) (HasSubset.Subset A B)","decl":"@[deprecated (since := \"2024-12-28\")]\nalias set_smul_subset_set_smul_iff₀ := smul_set_subset_smul_set_iff₀\n\n"}
{"name":"Set.smul_set_subset_iff₀","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : GroupWithZero α\ninst✝ : MulAction α β\na : α\nha : Ne a 0\nA B : Set β\n⊢ Iff (HasSubset.Subset (HSMul.hSMul a A) B) (HasSubset.Subset A (HSMul.hSMul (Inv.inv a) B))","decl":"theorem smul_set_subset_iff₀ (ha : a ≠ 0) {A B : Set β} : a • A ⊆ B ↔ A ⊆ a⁻¹ • B :=\n  show Units.mk0 a ha • _ ⊆ _ ↔ _ from smul_set_subset_iff_subset_inv_smul_set\n\n"}
{"name":"Set.set_smul_subset_iff₀","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : GroupWithZero α\ninst✝ : MulAction α β\na : α\nha : Ne a 0\nA B : Set β\n⊢ Iff (HasSubset.Subset (HSMul.hSMul a A) B) (HasSubset.Subset A (HSMul.hSMul (Inv.inv a) B))","decl":"@[deprecated (since := \"2024-12-28\")] alias set_smul_subset_iff₀ := smul_set_subset_iff₀\n\n"}
{"name":"Set.subset_smul_set_iff₀","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : GroupWithZero α\ninst✝ : MulAction α β\na : α\nha : Ne a 0\nA B : Set β\n⊢ Iff (HasSubset.Subset A (HSMul.hSMul a B)) (HasSubset.Subset (HSMul.hSMul (Inv.inv a) A) B)","decl":"theorem subset_smul_set_iff₀ (ha : a ≠ 0) {A B : Set β} : A ⊆ a • B ↔ a⁻¹ • A ⊆ B :=\n  show _ ⊆ Units.mk0 a ha • _ ↔ _ from subset_smul_set_iff\n\n"}
{"name":"Set.subset_set_smul_iff₀","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : GroupWithZero α\ninst✝ : MulAction α β\na : α\nha : Ne a 0\nA B : Set β\n⊢ Iff (HasSubset.Subset A (HSMul.hSMul a B)) (HasSubset.Subset (HSMul.hSMul (Inv.inv a) A) B)","decl":"@[deprecated (since := \"2024-12-28\")] alias subset_set_smul_iff₀ := subset_smul_set_iff₀\n\n"}
{"name":"Set.smul_set_inter₀","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : GroupWithZero α\ninst✝ : MulAction α β\ns t : Set β\na : α\nha : Ne a 0\n⊢ Eq (HSMul.hSMul a (Inter.inter s t)) (Inter.inter (HSMul.hSMul a s) (HSMul.hSMul a t))","decl":"theorem smul_set_inter₀ (ha : a ≠ 0) : a • (s ∩ t) = a • s ∩ a • t :=\n  show Units.mk0 a ha • _ = _ from smul_set_inter\n\n"}
{"name":"Set.smul_set_sdiff₀","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : GroupWithZero α\ninst✝ : MulAction α β\ns t : Set β\na : α\nha : Ne a 0\n⊢ Eq (HSMul.hSMul a (SDiff.sdiff s t)) (SDiff.sdiff (HSMul.hSMul a s) (HSMul.hSMul a t))","decl":"theorem smul_set_sdiff₀ (ha : a ≠ 0) : a • (s \\ t) = a • s \\ a • t :=\n  image_diff (MulAction.injective₀ ha) _ _\n\n"}
{"name":"Set.smul_set_symmDiff₀","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : GroupWithZero α\ninst✝ : MulAction α β\ns t : Set β\na : α\nha : Ne a 0\n⊢ Eq (HSMul.hSMul a (symmDiff s t)) (symmDiff (HSMul.hSMul a s) (HSMul.hSMul a t))","decl":"open scoped symmDiff in\ntheorem smul_set_symmDiff₀ (ha : a ≠ 0) : a • s ∆ t = (a • s) ∆ (a • t) :=\n  image_symmDiff (MulAction.injective₀ ha) _ _\n\n"}
{"name":"Set.smul_set_univ₀","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : GroupWithZero α\ninst✝ : MulAction α β\na : α\nha : Ne a 0\n⊢ Eq (HSMul.hSMul a Set.univ) Set.univ","decl":"theorem smul_set_univ₀ (ha : a ≠ 0) : a • (univ : Set β) = univ :=\n  image_univ_of_surjective <| MulAction.surjective₀ ha\n\n"}
{"name":"Set.smul_univ₀","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : GroupWithZero α\ninst✝ : MulAction α β\ns : Set α\nhs : Not (HasSubset.Subset s 0)\n⊢ Eq (HSMul.hSMul s Set.univ) Set.univ","decl":"theorem smul_univ₀ {s : Set α} (hs : ¬s ⊆ 0) : s • (univ : Set β) = univ :=\n  let ⟨a, ha, ha₀⟩ := not_subset.1 hs\n  eq_univ_of_forall fun b ↦ ⟨a, ha, a⁻¹ • b, trivial, smul_inv_smul₀ ha₀ _⟩\n\n"}
{"name":"Set.smul_univ₀'","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : GroupWithZero α\ninst✝ : MulAction α β\ns : Set α\nhs : s.Nontrivial\n⊢ Eq (HSMul.hSMul s Set.univ) Set.univ","decl":"theorem smul_univ₀' {s : Set α} (hs : s.Nontrivial) : s • (univ : Set β) = univ :=\n  smul_univ₀ hs.not_subset_singleton\n\n"}
{"name":"Set.inv_zero","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : GroupWithZero α\n⊢ Eq (Inv.inv 0) 0","decl":"@[simp] protected lemma inv_zero : (0 : Set α)⁻¹ = 0 := by ext; simp\n\n"}
{"name":"Set.inv_smul_set_distrib₀","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : GroupWithZero α\na : α\ns : Set α\n⊢ Eq (Inv.inv (HSMul.hSMul a s)) (HSMul.hSMul (MulOpposite.op (Inv.inv a)) (Inv.inv s))","decl":"@[simp] lemma inv_smul_set_distrib₀ (a : α) (s : Set α) : (a • s)⁻¹ = op a⁻¹ • s⁻¹ := by\n  obtain rfl | ha := eq_or_ne a 0\n  · obtain rfl | hs := s.eq_empty_or_nonempty <;> simp [*]\n  · ext; simp [mem_smul_set_iff_inv_smul_mem₀, *]\n\n"}
{"name":"Set.inv_op_smul_set_distrib₀","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\ninst✝ : GroupWithZero α\na : α\ns : Set α\n⊢ Eq (Inv.inv (HSMul.hSMul (MulOpposite.op a) s)) (HSMul.hSMul (Inv.inv a) (Inv.inv s))","decl":"@[simp] lemma inv_op_smul_set_distrib₀ (a : α) (s : Set α) : (op a • s)⁻¹ = a⁻¹ • s⁻¹ := by\n  obtain rfl | ha := eq_or_ne a 0\n  · obtain rfl | hs := s.eq_empty_or_nonempty <;> simp [*]\n  · ext; simp [mem_smul_set_iff_inv_smul_mem₀, *]\n\n"}
{"name":"Set.smul_set_neg","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Monoid α\ninst✝¹ : AddGroup β\ninst✝ : DistribMulAction α β\na : α\nt : Set β\n⊢ Eq (HSMul.hSMul a (Neg.neg t)) (Neg.neg (HSMul.hSMul a t))","decl":"@[simp]\ntheorem smul_set_neg : a • -t = -(a • t) := by\n  simp_rw [← image_smul, ← image_neg_eq_neg, image_image, smul_neg]\n\n"}
{"name":"Set.smul_neg","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Monoid α\ninst✝¹ : AddGroup β\ninst✝ : DistribMulAction α β\ns : Set α\nt : Set β\n⊢ Eq (HSMul.hSMul s (Neg.neg t)) (Neg.neg (HSMul.hSMul s t))","decl":"@[simp]\nprotected theorem smul_neg : s • -t = -(s • t) := by\n  simp_rw [← image_neg_eq_neg]\n  exact image_image2_right_comm smul_neg\n\n"}
{"name":"Set.add_smul_subset","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Semiring α\ninst✝¹ : AddCommMonoid β\ninst✝ : Module α β\na b : α\ns : Set β\n⊢ HasSubset.Subset (HSMul.hSMul (HAdd.hAdd a b) s) (HAdd.hAdd (HSMul.hSMul a s) (HSMul.hSMul b s))","decl":"theorem add_smul_subset (a b : α) (s : Set β) : (a + b) • s ⊆ a • s + b • s := by\n  rintro _ ⟨x, hx, rfl⟩\n  simpa only [add_smul] using add_mem_add (smul_mem_smul_set hx) (smul_mem_smul_set hx)\n\n"}
{"name":"Set.neg_smul_set","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Ring α\ninst✝¹ : AddCommGroup β\ninst✝ : Module α β\na : α\nt : Set β\n⊢ Eq (HSMul.hSMul (Neg.neg a) t) (Neg.neg (HSMul.hSMul a t))","decl":"@[simp]\ntheorem neg_smul_set : -a • t = -(a • t) := by\n  simp_rw [← image_smul, ← image_neg_eq_neg, image_image, neg_smul]\n\n"}
{"name":"Set.neg_smul","module":"Mathlib.Data.Set.Pointwise.SMul","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Ring α\ninst✝¹ : AddCommGroup β\ninst✝ : Module α β\ns : Set α\nt : Set β\n⊢ Eq (HSMul.hSMul (Neg.neg s) t) (Neg.neg (HSMul.hSMul s t))","decl":"@[simp]\nprotected theorem neg_smul : -s • t = -(s • t) := by\n  simp_rw [← image_neg_eq_neg]\n  exact image2_image_left_comm neg_smul\n\n"}
