{"name":"Valuation.Integers.wfDvdMonoid_iff_wellFounded_gt_on_v","module":"Mathlib.RingTheory.Valuation.Archimedean","initialProofState":"F : Type u_1\nΓ₀ : Type u_2\nO : Type u_3\ninst✝³ : Field F\ninst✝² : LinearOrderedCommGroupWithZero Γ₀\ninst✝¹ : CommRing O\ninst✝ : Algebra O F\nv : Valuation F Γ₀\nhv : v.Integers O\n⊢ Iff (WfDvdMonoid O) (WellFounded (Function.onFun (fun x1 x2 => GT.gt x1 x2) (Function.comp ⇑v ⇑(algebraMap O F))))","decl":"open scoped Function in\nlemma wfDvdMonoid_iff_wellFounded_gt_on_v (hv : Integers v O) :\n    WfDvdMonoid O ↔ WellFounded ((· > ·) on (v ∘ algebraMap O F)) := by\n  refine ⟨fun _ ↦ wellFounded_dvdNotUnit.mono ?_, fun h ↦ ⟨h.mono ?_⟩⟩ <;>\n  simp [Function.onFun, hv.dvdNotUnit_iff_lt]\n\n"}
{"name":"Valuation.Integers.wellFounded_gt_on_v_iff_discrete_mrange","module":"Mathlib.RingTheory.Valuation.Archimedean","initialProofState":"F : Type u_1\nΓ₀ : Type u_2\nO : Type u_3\ninst✝⁴ : Field F\ninst✝³ : LinearOrderedCommGroupWithZero Γ₀\ninst✝² : CommRing O\ninst✝¹ : Algebra O F\nv : Valuation F Γ₀\ninst✝ : Nontrivial (Units (Subtype fun x => Membership.mem (MonoidHom.mrange v) x))\nhv : v.Integers O\n⊢ Iff (WellFounded (Function.onFun (fun x1 x2 => GT.gt x1 x2) (Function.comp ⇑v ⇑(algebraMap O F)))) (Nonempty (OrderMonoidIso (Subtype fun x => Membership.mem (MonoidHom.mrange v) x) (WithZero (Multiplicative Int))))","decl":"open scoped Function Multiplicative in\nlemma wellFounded_gt_on_v_iff_discrete_mrange [Nontrivial (MonoidHom.mrange v)ˣ]\n    (hv : Integers v O) :\n    WellFounded ((· > ·) on (v ∘ algebraMap O F)) ↔\n      Nonempty (MonoidHom.mrange v ≃*o ℤₘ₀) := by\n  rw [← LinearOrderedCommGroupWithZero.wellFoundedOn_setOf_ge_gt_iff_nonempty_discrete_of_ne_zero\n    one_ne_zero, ← Set.wellFoundedOn_range]\n  classical\n  refine ⟨fun h ↦ (h.mapsTo Subtype.val ?_).mono' (by simp), fun h ↦ (h.mapsTo ?_ ?_).mono' ?_⟩\n  · rintro ⟨_, x, rfl⟩\n    simp only [← Subtype.coe_le_coe, OneMemClass.coe_one, Set.mem_setOf_eq, Set.mem_range,\n      Function.comp_apply]\n    intro hx\n    obtain ⟨y, rfl⟩ := hv.exists_of_le_one hx\n    exact ⟨y, by simp⟩\n  · exact fun x ↦ if hx : x ∈ MonoidHom.mrange v then ⟨x, hx⟩ else 1\n  · intro\n    simp only [Set.mem_range, Function.comp_apply, MonoidHom.mem_mrange, Set.mem_setOf_eq,\n      forall_exists_index]\n    rintro x rfl\n    simp [← Subtype.coe_le_coe, hv.map_le_one]\n  · simp [Function.onFun]\n\n"}
{"name":"Valuation.Integers.isPrincipalIdealRing_iff_not_denselyOrdered","module":"Mathlib.RingTheory.Valuation.Archimedean","initialProofState":"F : Type u_1\nΓ₀ : Type u_2\nO : Type u_3\ninst✝⁴ : Field F\ninst✝³ : LinearOrderedCommGroupWithZero Γ₀\ninst✝² : CommRing O\ninst✝¹ : Algebra O F\nv : Valuation F Γ₀\ninst✝ : MulArchimedean Γ₀\nhv : v.Integers O\n⊢ Iff (IsPrincipalIdealRing O) (Not (DenselyOrdered ↑(Set.range ⇑v)))","decl":"lemma isPrincipalIdealRing_iff_not_denselyOrdered [MulArchimedean Γ₀] (hv : Integers v O) :\n    IsPrincipalIdealRing O ↔ ¬ DenselyOrdered (Set.range v) := by\n  refine ⟨fun _ ↦ not_denselyOrdered_of_isPrincipalIdealRing hv, fun H ↦ ?_⟩\n  rcases subsingleton_or_nontrivial (MonoidHom.mrange v)ˣ with hs|_\n  · have := bijective_algebraMap_of_subsingleton_units_mrange hv\n    exact .of_surjective _ (RingEquiv.ofBijective _ this).symm.surjective\n  have : IsDomain O := hv.hom_inj.isDomain\n  have : ValuationRing O := ValuationRing.of_integers v hv\n  have : IsBezout O := ValuationRing.instIsBezout\n  have := ((IsBezout.TFAE (R := O)).out 1 3)\n  rw [this, hv.wfDvdMonoid_iff_wellFounded_gt_on_v, hv.wellFounded_gt_on_v_iff_discrete_mrange,\n    LinearOrderedCommGroupWithZero.discrete_iff_not_denselyOrdered]\n  exact H\n\n"}
