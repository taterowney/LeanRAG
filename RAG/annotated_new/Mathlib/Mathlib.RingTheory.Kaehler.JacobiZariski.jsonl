{"name":"Algebra.Generators.ofComp_kerCompPreimage","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\nx : Subtype fun x => Membership.mem Q.ker x\n⊢ Eq ((Q.ofComp P).toAlgHom ↑(Q.kerCompPreimage P x)) ↑x","decl":"lemma ofComp_kerCompPreimage (x : Q.ker) :\n    (Q.ofComp P).toAlgHom (kerCompPreimage Q P x) = x := by\n  conv_rhs => rw [← x.1.support_sum_monomial_coeff]\n  rw [kerCompPreimage, map_finsupp_sum, Finsupp.sum]\n  refine Finset.sum_congr rfl fun j _ ↦ ?_\n  simp only [AlgHom.toLinearMap_apply, _root_.map_mul, Hom.toAlgHom_monomial]\n  rw [one_smul, Finsupp.prod_mapDomain_index_inj Sum.inl_injective]\n  rw [rename, ← AlgHom.comp_apply, comp_aeval]\n  simp only [ofComp_val, Sum.elim_inr, Function.comp_apply, self_val, id_eq,\n    Sum.elim_inl, monomial_eq, Hom.toAlgHom_X]\n  congr 1\n  rw [aeval_def, IsScalarTower.algebraMap_eq R S, ← MvPolynomial.algebraMap_eq,\n    ← coe_eval₂Hom, ← map_aeval, P.aeval_val_σ]\n  rfl\n\n"}
{"name":"Algebra.Generators.Cotangent.map_ofComp_ker","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\n⊢ Eq (Submodule.map (Q.ofComp P).toAlgHom.toLinearMap (Submodule.restrictScalars R (Q.comp P).ker)) (Submodule.restrictScalars R Q.ker)","decl":"lemma Cotangent.map_ofComp_ker :\n    Submodule.map (Q.ofComp P).toAlgHom.toLinearMap ((Q.comp P).ker.restrictScalars R) =\n      Q.ker.restrictScalars R := by\n  apply le_antisymm\n  · rintro _ ⟨x, hx, rfl⟩\n    simp only [ker_eq_ker_aeval_val, Submodule.coe_restrictScalars, SetLike.mem_coe,\n      RingHom.mem_ker, AlgHom.toLinearMap_apply, Submodule.restrictScalars_mem] at hx ⊢\n    rw [← hx, Hom.algebraMap_toAlgHom]\n    rfl\n  · intro x hx\n    exact ⟨_, (kerCompPreimage Q P ⟨x, hx⟩).2, ofComp_kerCompPreimage Q P ⟨x, hx⟩⟩\n\n"}
{"name":"Algebra.Generators.Cotangent.surjective_map_ofComp","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\n⊢ Function.Surjective ⇑(Algebra.Extension.Cotangent.map (Q.ofComp P).toExtensionHom)","decl":"lemma Cotangent.surjective_map_ofComp :\n    Function.Surjective (Extension.Cotangent.map (Q.ofComp P).toExtensionHom) := by\n  intro x\n  obtain ⟨⟨x, hx⟩, rfl⟩ := Extension.Cotangent.mk_surjective x\n  have : x ∈ Q.ker.restrictScalars R := hx\n  rw [← map_ofComp_ker Q P] at this\n  obtain ⟨x, hx', rfl⟩ := this\n  exact ⟨.mk ⟨x, hx'⟩, Extension.Cotangent.map_mk _ _⟩\n\n"}
{"name":"Algebra.Generators.Cotangent.exact","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\n⊢ Function.Exact ⇑(LinearMap.liftBaseChange T (Algebra.Extension.Cotangent.map (Q.toComp P).toExtensionHom)) ⇑(Algebra.Extension.Cotangent.map (Q.ofComp P).toExtensionHom)","decl":"open Extension.Cotangent in\nlemma Cotangent.exact :\n    Function.Exact\n      ((Extension.Cotangent.map (Q.toComp P).toExtensionHom).liftBaseChange T)\n      (Extension.Cotangent.map (Q.ofComp P).toExtensionHom) := by\n  apply LinearMap.exact_of_comp_of_mem_range\n  · rw [LinearMap.liftBaseChange_comp, ← Extension.Cotangent.map_comp,\n      EmbeddingLike.map_eq_zero_iff]\n    ext x\n    obtain ⟨⟨x, hx⟩, rfl⟩ := Extension.Cotangent.mk_surjective x\n    simp only [map_mk, Hom.toAlgHom_comp_apply, val_mk, LinearMap.zero_apply, val_zero]\n    convert Q.ker.toCotangent.map_zero\n    trans ((IsScalarTower.toAlgHom R _ _).comp (IsScalarTower.toAlgHom R P.Ring S)) x\n    · congr\n      refine MvPolynomial.algHom_ext fun i ↦ ?_\n      show (Q.ofComp P).toAlgHom ((Q.toComp P).toAlgHom (X i)) = _\n      simp\n    · simp [-self_vars, aeval_val_eq_zero hx]\n  · intro x hx\n    obtain ⟨⟨x : (Q.comp P).Ring, hx'⟩, rfl⟩ := Extension.Cotangent.mk_surjective x\n    replace hx : (Q.ofComp P).toAlgHom x ∈ Q.ker ^ 2 := by\n      simpa only [map_mk, val_mk, val_zero, Ideal.toCotangent_eq_zero] using congr(($hx).val)\n    rw [← Submodule.restrictScalars_mem R, pow_two, Submodule.restrictScalars_mul,\n      ← map_ofComp_ker (P := P), ← Submodule.map_mul, ← Submodule.restrictScalars_mul] at hx\n    obtain ⟨y, hy, e⟩ := hx\n    rw [AlgHom.toLinearMap_apply, eq_comm, ← sub_eq_zero, ← map_sub, ← RingHom.mem_ker,\n      ← map_toComp_ker] at e\n    rw [LinearMap.range_liftBaseChange]\n    let z : (Q.comp P).ker := ⟨x - y, Ideal.sub_mem _ hx' (Ideal.mul_le_left hy)⟩\n    have hz : z.1 ∈ P.ker.map (Q.toComp P).toAlgHom.toRingHom := e\n    have : Extension.Cotangent.mk (P := (Q.comp P).toExtension) ⟨x, hx'⟩ =\n      Extension.Cotangent.mk z := by\n      ext; simpa only [comp_vars, val_mk, Ideal.toCotangent_eq, sub_sub_cancel, pow_two, z]\n    rw [this, ← Submodule.restrictScalars_mem (Q.comp P).Ring, ← Submodule.mem_comap,\n      ← Submodule.span_singleton_le_iff_mem, ← Submodule.map_le_map_iff_of_injective\n      (f := Submodule.subtype _) Subtype.val_injective, Submodule.map_subtype_span_singleton,\n      Submodule.span_singleton_le_iff_mem]\n    refine (show Ideal.map (Q.toComp P).toAlgHom.toRingHom P.ker ≤ _ from ?_) hz\n    rw [Ideal.map_le_iff_le_comap]\n    rintro w hw\n    simp only [AlgHom.toRingHom_eq_coe, Ideal.mem_comap, RingHom.coe_coe,\n      Submodule.mem_map, Submodule.mem_comap, Submodule.restrictScalars_mem, Submodule.coe_subtype,\n      Subtype.exists, exists_and_right, exists_eq_right,\n      toExtension_Ring, toExtension_commRing, toExtension_algebra₂]\n    refine ⟨?_, Submodule.subset_span ⟨Extension.Cotangent.mk ⟨w, hw⟩, ?_⟩⟩\n    · simp only [ker_eq_ker_aeval_val, RingHom.mem_ker, Hom.algebraMap_toAlgHom]\n      rw [aeval_val_eq_zero hw, map_zero]\n    · rw [map_mk]\n      rfl\n\n"}
{"name":"Algebra.Generators.CotangentSpace.compEquiv_symm_inr","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\n⊢ Eq ((↑(Algebra.Generators.CotangentSpace.compEquiv Q P).symm).comp (LinearMap.inr T Q.toExtension.CotangentSpace (TensorProduct S T P.toExtension.CotangentSpace))) (LinearMap.liftBaseChange T (Algebra.Extension.CotangentSpace.map (Q.toComp P).toExtensionHom))","decl":"lemma CotangentSpace.compEquiv_symm_inr :\n    (compEquiv Q P).symm.toLinearMap ∘ₗ\n      LinearMap.inr T Q.toExtension.CotangentSpace (T ⊗[S] P.toExtension.CotangentSpace) =\n        (Extension.CotangentSpace.map (Q.toComp P).toExtensionHom).liftBaseChange T := by\n  classical\n  apply (P.cotangentSpaceBasis.baseChange T).ext\n  intro i\n  apply (Q.comp P).cotangentSpaceBasis.repr.injective\n  ext j\n  simp only [compEquiv, LinearEquiv.trans_symm, LinearEquiv.symm_symm,\n    Basis.baseChange_apply, LinearMap.coe_comp, LinearEquiv.coe_coe, LinearMap.coe_inr,\n    Function.comp_apply, LinearEquiv.trans_apply, Basis.repr_symm_apply, pderiv_X, toComp_val,\n    Basis.repr_linearCombination, LinearMap.liftBaseChange_tmul, one_smul, repr_CotangentSpaceMap]\n  obtain (j | j) := j <;>\n    simp only [comp_vars, Basis.prod_repr_inr, Basis.baseChange_repr_tmul,\n      Basis.repr_self, Basis.prod_repr_inl, map_zero, Finsupp.coe_zero,\n      Pi.zero_apply, ne_eq, not_false_eq_true, Pi.single_eq_of_ne, Pi.single_apply,\n      Finsupp.single_apply, ite_smul, one_smul, zero_smul, Sum.inr.injEq,\n        RingHom.map_ite_one_zero, reduceCtorEq, ↓reduceIte]\n\n"}
{"name":"Algebra.Generators.CotangentSpace.compEquiv_symm_zero","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\nx : TensorProduct S T P.toExtension.CotangentSpace\n⊢ Eq ((Algebra.Generators.CotangentSpace.compEquiv Q P).symm { fst := 0, snd := x }) ((LinearMap.liftBaseChange T (Algebra.Extension.CotangentSpace.map (Q.toComp P).toExtensionHom)) x)","decl":"lemma CotangentSpace.compEquiv_symm_zero (x) :\n    (compEquiv Q P).symm (0, x) =\n        (Extension.CotangentSpace.map (Q.toComp P).toExtensionHom).liftBaseChange T x :=\n  DFunLike.congr_fun (compEquiv_symm_inr Q P) x\n\n"}
{"name":"Algebra.Generators.CotangentSpace.fst_compEquiv","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\n⊢ Eq ((LinearMap.fst T Q.toExtension.CotangentSpace (TensorProduct S T P.toExtension.CotangentSpace)).comp ↑(Algebra.Generators.CotangentSpace.compEquiv Q P)) (Algebra.Extension.CotangentSpace.map (Q.ofComp P).toExtensionHom)","decl":"lemma CotangentSpace.fst_compEquiv :\n    LinearMap.fst T Q.toExtension.CotangentSpace (T ⊗[S] P.toExtension.CotangentSpace) ∘ₗ\n      (compEquiv Q P).toLinearMap = Extension.CotangentSpace.map (Q.ofComp P).toExtensionHom := by\n  classical\n  apply (Q.comp P).cotangentSpaceBasis.ext\n  intro i\n  apply Q.cotangentSpaceBasis.repr.injective\n  ext j\n  simp only [compEquiv, LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply, ofComp_val,\n    LinearEquiv.trans_apply, Basis.repr_self, LinearMap.fst_apply, repr_CotangentSpaceMap]\n  obtain (i | i) := i <;>\n    simp only [comp_vars, Basis.repr_symm_apply, Finsupp.linearCombination_single, Basis.prod_apply,\n      LinearMap.coe_inl, LinearMap.coe_inr, Sum.elim_inl, Function.comp_apply, one_smul,\n      Basis.repr_self, Finsupp.single_apply, pderiv_X, Pi.single_apply, RingHom.map_ite_one_zero,\n      Sum.elim_inr, Function.comp_apply, Basis.baseChange_apply, one_smul,\n      map_zero, Finsupp.coe_zero, Pi.zero_apply, derivation_C]\n\n"}
{"name":"Algebra.Generators.CotangentSpace.fst_compEquiv_apply","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\nx : (Q.comp P).toExtension.CotangentSpace\n⊢ Eq ((Algebra.Generators.CotangentSpace.compEquiv Q P) x).1 ((Algebra.Extension.CotangentSpace.map (Q.ofComp P).toExtensionHom) x)","decl":"lemma CotangentSpace.fst_compEquiv_apply (x) :\n    (compEquiv Q P x).1 = Extension.CotangentSpace.map (Q.ofComp P).toExtensionHom x :=\n  DFunLike.congr_fun (fst_compEquiv Q P) x\n\n"}
{"name":"Algebra.Generators.CotangentSpace.map_toComp_injective","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\n⊢ Function.Injective ⇑(LinearMap.liftBaseChange T (Algebra.Extension.CotangentSpace.map (Q.toComp P).toExtensionHom))","decl":"lemma CotangentSpace.map_toComp_injective :\n    Function.Injective\n      ((Extension.CotangentSpace.map (Q.toComp P).toExtensionHom).liftBaseChange T) := by\n  rw [← compEquiv_symm_inr]\n  apply (compEquiv Q P).symm.injective.comp\n  exact Prod.mk.inj_left _\n\n"}
{"name":"Algebra.Generators.CotangentSpace.map_ofComp_surjective","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\n⊢ Function.Surjective ⇑(Algebra.Extension.CotangentSpace.map (Q.ofComp P).toExtensionHom)","decl":"lemma CotangentSpace.map_ofComp_surjective :\n    Function.Surjective (Extension.CotangentSpace.map (Q.ofComp P).toExtensionHom) := by\n  rw [← fst_compEquiv]\n  exact (Prod.fst_surjective).comp (compEquiv Q P).surjective\n\n"}
{"name":"Algebra.Generators.CotangentSpace.exact","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\n⊢ Function.Exact ⇑(LinearMap.liftBaseChange T (Algebra.Extension.CotangentSpace.map (Q.toComp P).toExtensionHom)) ⇑(Algebra.Extension.CotangentSpace.map (Q.ofComp P).toExtensionHom)","decl":"lemma CotangentSpace.exact :\n    Function.Exact ((Extension.CotangentSpace.map (Q.toComp P).toExtensionHom).liftBaseChange T)\n      (Extension.CotangentSpace.map (Q.ofComp P).toExtensionHom) := by\n  rw [← fst_compEquiv, ← compEquiv_symm_inr]\n  conv_rhs => rw [← LinearEquiv.symm_symm (compEquiv Q P)]\n  rw [LinearEquiv.conj_exact_iff_exact]\n  exact Function.Exact.inr_fst\n\n"}
{"name":"Algebra.Generators.H1Cotangent.δAux_monomial","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nn : Finsupp Q.vars Nat\nr : S\n⊢ Eq ((Algebra.Generators.H1Cotangent.δAux R Q) ((MvPolynomial.monomial n) r)) (TensorProduct.tmul S (n.prod fun x1 x2 => HPow.hPow (Q.val x1) x2) ((KaehlerDifferential.D R S) r))","decl":"lemma δAux_monomial (n r) :\n    δAux R Q (monomial n r) = (n.prod (Q.val · ^ ·)) ⊗ₜ D R S r :=\n  Finsupp.lsum_single _ _ _ _\n\n"}
{"name":"Algebra.Generators.H1Cotangent.δAux_X","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\ni : Q.vars\n⊢ Eq ((Algebra.Generators.H1Cotangent.δAux R Q) (MvPolynomial.X i)) 0","decl":"@[simp]\nlemma δAux_X (i) :\n    δAux R Q (X i) = 0 := by\n  rw [X, δAux_monomial]\n  simp only [Derivation.map_one_eq_zero, tmul_zero]\n\n"}
{"name":"Algebra.Generators.H1Cotangent.δAux_mul","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nx y : Q.Ring\n⊢ Eq ((Algebra.Generators.H1Cotangent.δAux R Q) (HMul.hMul x y)) (HAdd.hAdd (HSMul.hSMul x ((Algebra.Generators.H1Cotangent.δAux R Q) y)) (HSMul.hSMul y ((Algebra.Generators.H1Cotangent.δAux R Q) x)))","decl":"lemma δAux_mul (x y) :\n    δAux R Q (x * y) = x • (δAux R Q y) + y • (δAux R Q x) := by\n  induction' x using MvPolynomial.induction_on' with n r x₁ x₂ hx₁ hx₂\n  · induction' y using MvPolynomial.induction_on' with m s y₁ y₂ hy₁ hy₂\n    · simp only [monomial_mul, δAux_monomial, Derivation.leibniz, tmul_add, tmul_smul,\n        smul_tmul', smul_eq_mul, Algebra.smul_def, algebraMap_apply, aeval_monomial, mul_assoc]\n      rw [mul_comm (m.prod _) (n.prod _)]\n      simp only [pow_zero, implies_true, pow_add, Finsupp.prod_add_index']\n    · simp only [map_add, smul_add, hy₁, hy₂, mul_add, add_smul]; abel\n  · simp only [add_mul, map_add, hx₁, hx₂, add_smul, smul_add]; abel\n\n"}
{"name":"Algebra.Generators.H1Cotangent.δAux_C","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nr : S\n⊢ Eq ((Algebra.Generators.H1Cotangent.δAux R Q) (MvPolynomial.C r)) (TensorProduct.tmul S 1 ((KaehlerDifferential.D R S) r))","decl":"lemma δAux_C (r) :\n    δAux R Q (C r) = 1 ⊗ₜ D R S r := by\n  rw [← monomial_zero', δAux_monomial, Finsupp.prod_zero_index]\n\n"}
{"name":"Algebra.Generators.H1Cotangent.δAux_toAlgHom","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nQ' : Algebra.Generators S T\nf : Q.Hom Q'\nx : Q.Ring\n⊢ Eq ((Algebra.Generators.H1Cotangent.δAux R Q') (f.toAlgHom x)) (HAdd.hAdd ((Algebra.Generators.H1Cotangent.δAux R Q) x) ((Finsupp.linearCombination T (Function.comp (⇑(Algebra.Generators.H1Cotangent.δAux R Q')) f.val)) (Q.cotangentSpaceBasis.repr (TensorProduct.tmul Q.Ring 1 ((KaehlerDifferential.D S Q.Ring) x)))))","decl":"lemma δAux_toAlgHom {Q : Generators.{u₁} S T}\n    {Q' : Generators.{u₃} S T} (f : Hom Q Q') (x) :\n    δAux R Q' (f.toAlgHom x) = δAux R Q x + Finsupp.linearCombination _ (δAux R Q' ∘ f.val)\n      (Q.cotangentSpaceBasis.repr ((1 : T) ⊗ₜ[Q.Ring] D S Q.Ring x :)) := by\n  letI : AddCommGroup (T ⊗[S] Ω[S⁄R]) := inferInstance\n  have : IsScalarTower Q.Ring Q.Ring T := IsScalarTower.left _\n  induction' x using MvPolynomial.induction_on with s x₁ x₂ hx₁ hx₂ p n IH\n  · simp [MvPolynomial.algebraMap_eq, δAux_C]\n  · simp only [map_add, hx₁, hx₂, tmul_add]\n    rw [add_add_add_comm]\n  · simp only [map_mul, Hom.toAlgHom_X, δAux_mul, algebraMap_apply, Hom.algebraMap_toAlgHom,\n      ← @IsScalarTower.algebraMap_smul Q'.Ring T, id.map_eq_id, δAux_X, RingHomCompTriple.comp_eq,\n      RingHom.id_apply, coe_eval₂Hom, IH, Hom.aeval_val, smul_add, map_aeval, tmul_add, tmul_smul,\n      ← @IsScalarTower.algebraMap_smul Q.Ring T, smul_zero, aeval_X, zero_add, Derivation.leibniz,\n      LinearEquiv.map_add, LinearEquiv.map_smul, Basis.repr_self, LinearMap.map_add, one_smul,\n      LinearMap.map_smul, Finsupp.linearCombination_single,\n      Function.comp_apply, ← cotangentSpaceBasis_apply]\n    rw [add_left_comm]\n    rfl\n\n"}
{"name":"Algebra.Generators.H1Cotangent.δAux_ofComp","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\nx : (Q.comp P).Ring\n⊢ Eq ((Algebra.Generators.H1Cotangent.δAux R Q) ((Q.ofComp P).toAlgHom x)) ((LinearMap.baseChange T P.toExtension.toKaehler) ((Algebra.Generators.CotangentSpace.compEquiv Q P) (TensorProduct.tmul (Q.comp P).Ring 1 ((KaehlerDifferential.D R (Q.comp P).Ring) x))).2)","decl":"lemma δAux_ofComp (x : (Q.comp P).Ring) :\n    δAux R Q ((Q.ofComp P).toAlgHom x) =\n      P.toExtension.toKaehler.baseChange T (CotangentSpace.compEquiv Q P\n        (1 ⊗ₜ[(Q.comp P).Ring] (D R (Q.comp P).Ring) x : _)).2 := by\n  letI : AddCommGroup (T ⊗[S] Ω[S⁄R]) := inferInstance\n  have : IsScalarTower (Q.comp P).Ring (Q.comp P).Ring T := IsScalarTower.left _\n  induction' x using MvPolynomial.induction_on with s x₁ x₂ hx₁ hx₂ p n IH\n  · simp only [algHom_C, δAux_C, sub_self, derivation_C, Derivation.map_algebraMap,\n      tmul_zero, map_zero, add_zero, MvPolynomial.algebraMap_apply, Prod.snd_zero]\n  · simp only [map_add, hx₁, hx₂, tmul_add, Prod.snd_add]\n  · simp only [map_mul, Hom.toAlgHom_X, ofComp_val, δAux_mul,\n      ← @IsScalarTower.algebraMap_smul Q.Ring T, algebraMap_apply, Hom.algebraMap_toAlgHom,\n      id.map_eq_id, map_aeval, RingHomCompTriple.comp_eq, comp_val, RingHom.id_apply, coe_eval₂Hom,\n      IH, Derivation.leibniz, tmul_add, tmul_smul, ← cotangentSpaceBasis_apply,\n      ← @IsScalarTower.algebraMap_smul (Q.comp P).Ring T, aeval_X, LinearEquiv.map_add,\n      LinearMapClass.map_smul, Prod.snd_add, Prod.smul_snd, LinearMap.map_add]\n    obtain (n | n) := n\n    · simp only [comp_vars, Sum.elim_inl, δAux_X, smul_zero, aeval_X,\n        CotangentSpace.compEquiv, LinearEquiv.trans_apply, Basis.repr_symm_apply, zero_add,\n        Basis.repr_self, Finsupp.linearCombination_single, Basis.prod_apply, LinearMap.coe_inl,\n        LinearMap.coe_inr, Function.comp_apply, one_smul, map_zero]\n    · simp only [comp_vars, Sum.elim_inr, Function.comp_apply, algHom_C, δAux_C,\n        CotangentSpace.compEquiv, LinearEquiv.trans_apply, Basis.repr_symm_apply,\n        algebraMap_smul, Basis.repr_self, Finsupp.linearCombination_single, Basis.prod_apply,\n        LinearMap.coe_inr, Basis.baseChange_apply, one_smul, LinearMap.baseChange_tmul,\n        toKaehler_cotangentSpaceBasis, add_left_inj, LinearMap.coe_inl]\n      rfl\n\n"}
{"name":"Algebra.Generators.H1Cotangent.map_comp_cotangentComplex_baseChange","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\n⊢ Eq ((LinearMap.liftBaseChange T (Algebra.Extension.CotangentSpace.map (Q.toComp P).toExtensionHom)).comp (LinearMap.baseChange T P.toExtension.cotangentComplex)) ((Q.comp P).toExtension.cotangentComplex.comp (LinearMap.liftBaseChange T (Algebra.Extension.Cotangent.map (Q.toComp P).toExtensionHom)))","decl":"lemma map_comp_cotangentComplex_baseChange :\n    (Extension.CotangentSpace.map (Q.toComp P).toExtensionHom).liftBaseChange T ∘ₗ\n      P.toExtension.cotangentComplex.baseChange T =\n    (Q.comp P).toExtension.cotangentComplex ∘ₗ\n      (Extension.Cotangent.map (Q.toComp P).toExtensionHom).liftBaseChange T := by\n  ext x; simp [Extension.CotangentSpace.map_cotangentComplex]\n\n"}
{"name":"Algebra.Generators.H1Cotangent.exact_δ_map","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\n⊢ Function.Exact ⇑(Algebra.Generators.H1Cotangent.δ Q P) ⇑(KaehlerDifferential.mapBaseChange R S T)","decl":"lemma exact_δ_map :\n    Function.Exact (δ Q P) (mapBaseChange R S T) := by\n  apply SnakeLemma.exact_δ_left (π₂ := (Q.comp P).toExtension.toKaehler)\n    (hπ₂ := (Q.comp P).toExtension.exact_cotangentComplex_toKaehler)\n  · apply (P.cotangentSpaceBasis.baseChange T).ext\n    intro i\n    simp only [Basis.baseChange_apply, LinearMap.coe_comp, Function.comp_apply,\n      LinearMap.baseChange_tmul, toKaehler_cotangentSpaceBasis, mapBaseChange_tmul, map_D,\n      one_smul, comp_vars, LinearMap.liftBaseChange_tmul]\n    rw [cotangentSpaceBasis_apply]\n    conv_rhs => enter [2]; tactic => exact Extension.CotangentSpace.map_tmul ..\n    simp only [map_one, mapBaseChange_tmul, map_D, one_smul]\n    simp [Extension.Hom.toAlgHom]\n  · exact LinearMap.lTensor_surjective T P.toExtension.toKaehler_surjective\n\n"}
{"name":"Algebra.Generators.H1Cotangent.δ_eq","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\nx : Q.toExtension.H1Cotangent\ny : (Q.comp P).toExtension.Cotangent\nhy : Eq ((Algebra.Extension.Cotangent.map (Q.ofComp P).toExtensionHom) y) ↑x\nz : TensorProduct S T P.toExtension.CotangentSpace\nhz : Eq ((LinearMap.liftBaseChange T (Algebra.Extension.CotangentSpace.map (Q.toComp P).toExtensionHom)) z) ((Q.comp P).toExtension.cotangentComplex y)\n⊢ Eq ((Algebra.Generators.H1Cotangent.δ Q P) x) ((LinearMap.baseChange T P.toExtension.toKaehler) z)","decl":"lemma δ_eq (x : Q.toExtension.H1Cotangent) (y)\n    (hy : Extension.Cotangent.map (ofComp Q P).toExtensionHom y = x.1) (z)\n    (hz : (Extension.CotangentSpace.map (toComp Q P).toExtensionHom).liftBaseChange T z =\n      (Q.comp P).toExtension.cotangentComplex y) :\n    δ Q P x = P.toExtension.toKaehler.baseChange T z := by\n  apply SnakeLemma.δ_eq\n  exacts [hy, hz]\n\n"}
{"name":"Algebra.Generators.H1Cotangent.δ_eq_δAux","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\nx : Subtype fun x => Membership.mem Q.ker x\nhx : Membership.mem (LinearMap.ker Q.toExtension.cotangentComplex) (Algebra.Extension.Cotangent.mk x)\n⊢ Eq ((Algebra.Generators.H1Cotangent.δ Q P) ⟨Algebra.Extension.Cotangent.mk x, hx⟩) ((Algebra.Generators.H1Cotangent.δAux R Q) ↑x)","decl":"lemma δ_eq_δAux (x : Q.ker) (hx) :\n    δ Q P ⟨.mk x, hx⟩ = δAux R Q x.1 := by\n  let y := Extension.Cotangent.mk (P := (Q.comp P).toExtension) (Q.kerCompPreimage P x)\n  have hy : (Extension.Cotangent.map (Q.ofComp P).toExtensionHom) y = Extension.Cotangent.mk x := by\n    simp only [y, Extension.Cotangent.map_mk]\n    congr\n    exact ofComp_kerCompPreimage Q P x\n  let z := (CotangentSpace.compEquiv Q P ((Q.comp P).toExtension.cotangentComplex y)).2\n  rw [H1Cotangent.δ_eq (y := y) (z := z)]\n  · rw [← ofComp_kerCompPreimage Q P x, δAux_ofComp]\n    rfl\n  · exact hy\n  · rw [← CotangentSpace.compEquiv_symm_inr]\n    apply (CotangentSpace.compEquiv Q P).injective\n    simp only [LinearMap.coe_comp, LinearEquiv.coe_coe, LinearMap.coe_inr, Function.comp_apply,\n      LinearEquiv.apply_symm_apply, z]\n    ext\n    swap; · rfl\n    show 0 = (LinearMap.fst T Q.toExtension.CotangentSpace (T ⊗[S] P.toExtension.CotangentSpace) ∘ₗ\n      (CotangentSpace.compEquiv Q P).toLinearMap) ((Q.comp P).toExtension.cotangentComplex y)\n    rw [CotangentSpace.fst_compEquiv, Extension.CotangentSpace.map_cotangentComplex, hy, hx]\n\n"}
{"name":"Algebra.Generators.H1Cotangent.δ_eq_δ","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\nP' : Algebra.Generators R S\n⊢ Eq (Algebra.Generators.H1Cotangent.δ Q P) (Algebra.Generators.H1Cotangent.δ Q P')","decl":"lemma δ_eq_δ (Q : Generators.{u₁} S T) (P : Generators.{u₂} R S)\n    (P' : Generators.{u₃} R S) :\n    δ Q P = δ Q P' := by\n  ext ⟨x, hx⟩\n  obtain ⟨x, rfl⟩ := Extension.Cotangent.mk_surjective x\n  rw [δ_eq_δAux, δ_eq_δAux]\n\n"}
{"name":"Algebra.Generators.H1Cotangent.exact_map_δ","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\n⊢ Function.Exact ⇑(Algebra.Extension.H1Cotangent.map (Q.ofComp P).toExtensionHom) ⇑(Algebra.Generators.H1Cotangent.δ Q P)","decl":"lemma exact_map_δ :\n    Function.Exact (Extension.H1Cotangent.map (Q.ofComp P).toExtensionHom) (δ Q P) := by\n  apply SnakeLemma.exact_δ_right\n    (ι₂ := (Q.comp P).toExtension.h1Cotangentι)\n    (hι₂ := LinearMap.exact_subtype_ker_map _)\n  · ext x; rfl\n  · exact Subtype.val_injective\n\n"}
{"name":"Algebra.Generators.H1Cotangent.δ_map","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\nQ' : Algebra.Generators S T\nP' : Algebra.Generators R S\nf : Q'.Hom Q\nx : Q'.toExtension.H1Cotangent\n⊢ Eq ((Algebra.Generators.H1Cotangent.δ Q P) ((Algebra.Extension.H1Cotangent.map f.toExtensionHom) x)) ((Algebra.Generators.H1Cotangent.δ Q' P') x)","decl":"lemma δ_map\n    (Q : Generators.{u₁} S T) (P : Generators.{u₂} R S)\n    (Q' : Generators.{u₃} S T) (P' : Generators.{u₄} R S) (f : Hom Q' Q) (x) :\n    δ Q P (Extension.H1Cotangent.map f.toExtensionHom x) = δ Q' P' x := by\n  letI : AddCommGroup (T ⊗[S] Ω[S⁄R]) := inferInstance\n  obtain ⟨x, hx⟩ := x\n  obtain ⟨⟨y, hy⟩, rfl⟩ := Extension.Cotangent.mk_surjective x\n  show δ _ _ ⟨_, _⟩ = δ _ _ _\n  replace hx : (1 : T) ⊗ₜ[Q'.Ring] (D S Q'.Ring) y = 0 := by\n    simpa only [LinearMap.mem_ker, Extension.cotangentComplex_mk, ker, RingHom.mem_ker] using hx\n  simp only [LinearMap.domRestrict_apply, Extension.Cotangent.map_mk, δ_eq_δAux]\n  refine (δAux_toAlgHom f _).trans ?_\n  rw [hx, map_zero, map_zero, add_zero]\n\n"}
{"name":"Algebra.Generators.H1Cotangent.δ_comp_equiv","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\nQ' : Algebra.Generators S T\nP' : Algebra.Generators R S\n⊢ Eq ((Algebra.Generators.H1Cotangent.δ Q P).comp ↑(Algebra.Generators.H1Cotangent.equiv Q' Q)) (Algebra.Generators.H1Cotangent.δ Q' P')","decl":"lemma δ_comp_equiv\n    (Q : Generators.{u₁} S T) (P : Generators.{u₂} R S)\n    (Q' : Generators.{u₃} S T) (P' : Generators.{u₄} R S) :\n    δ Q P ∘ₗ (H1Cotangent.equiv _ _).toLinearMap = δ Q' P' := by\n  ext x\n  exact δ_map Q P Q' P' _ _\n\n"}
{"name":"Algebra.Generators.H1Cotangent.exact_map_δ'","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type uT\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\nP' : Algebra.Generators R T\nf : P'.Hom Q\n⊢ Function.Exact ⇑(Algebra.Extension.H1Cotangent.map f.toExtensionHom) ⇑(Algebra.Generators.H1Cotangent.δ Q P)","decl":"/-- A variant of `exact_map_δ` that takes in an arbitrary map between generators. -/\nlemma exact_map_δ'\n    (Q : Generators.{u₁} S T) (P : Generators.{u₂} R S) (P' : Generators.{u₃} R T) (f : Hom P' Q) :\n    Function.Exact (Extension.H1Cotangent.map f.toExtensionHom) (δ Q P) := by\n  refine (H1Cotangent.equiv (Q.comp P) P').surjective.comp_exact_iff_exact.mp ?_\n  show Function.Exact ((Extension.H1Cotangent.map f.toExtensionHom).restrictScalars T ∘ₗ\n    (Extension.H1Cotangent.map _)) (δ Q P)\n  rw [← Extension.H1Cotangent.map_comp, Extension.H1Cotangent.map_eq _ (Q.ofComp P).toExtensionHom]\n  exact exact_map_δ Q P\n\n"}
{"name":"Algebra.H1Cotangent.exact_map_δ","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type w\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\n⊢ Function.Exact ⇑(Algebra.H1Cotangent.map R S T T) ⇑(Algebra.H1Cotangent.δ R S T)","decl":"/-- Given algebras `R → S → T`, `H¹(L_{T/R}) → H¹(L_{T/S}) → T ⊗[S] Ω[S/R]` is exact. -/\nlemma H1Cotangent.exact_map_δ : Function.Exact (map R S T T) (δ R S T) :=\n  Generators.H1Cotangent.exact_map_δ' (Generators.self S T)\n    (Generators.self R S) (Generators.self R T) (Generators.defaultHom _ _)\n\n"}
{"name":"Algebra.H1Cotangent.exact_δ_mapBaseChange","module":"Mathlib.RingTheory.Kaehler.JacobiZariski","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type w\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\n⊢ Function.Exact ⇑(Algebra.H1Cotangent.δ R S T) ⇑(KaehlerDifferential.mapBaseChange R S T)","decl":"/-- Given algebras `R → S → T`, `H¹(L_{T/S}) → T ⊗[S] Ω[S/R] → Ω[T/R]` is exact. -/\nlemma H1Cotangent.exact_δ_mapBaseChange : Function.Exact (δ R S T) (mapBaseChange R S T) :=\n  Generators.H1Cotangent.exact_δ_map (Generators.self S T) (Generators.self R S)\n\n"}
