{"name":"Dilation.mk.injEq","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\ntoFunâœ : Î± â†’ Î²\nedist_eq'âœ : Exists fun r => And (Ne r 0) (âˆ€ (x y : Î±), Eq (EDist.edist (toFunâœ x) (toFunâœ y)) (HMul.hMul (â†‘r) (EDist.edist x y)))\ntoFun : Î± â†’ Î²\nedist_eq' : Exists fun r => And (Ne r 0) (âˆ€ (x y : Î±), Eq (EDist.edist (toFun x) (toFun y)) (HMul.hMul (â†‘r) (EDist.edist x y)))\nâŠ¢ Eq (Eq { toFun := toFunâœ, edist_eq' := edist_eq'âœ } { toFun := toFun, edist_eq' := edist_eq' }) (Eq toFunâœ toFun)","decl":"/-- A dilation is a map that uniformly scales the edistance between any two points. -/\nstructure Dilation where\n  toFun : Î± â†’ Î²\n  edist_eq' : âˆƒ r : â„â‰¥0, r â‰  0 âˆ§ âˆ€ x y : Î±, edist (toFun x) (toFun y) = r * edist x y\n\n"}
{"name":"Dilation.edist_eq'","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nself : Dilation Î± Î²\nâŠ¢ Exists fun r => And (Ne r 0) (âˆ€ (x y : Î±), Eq (EDist.edist (self.toFun x) (self.toFun y)) (HMul.hMul (â†‘r) (EDist.edist x y)))","decl":"/-- A dilation is a map that uniformly scales the edistance between any two points. -/\nstructure Dilation where\n  toFun : Î± â†’ Î²\n  edist_eq' : âˆƒ r : â„â‰¥0, r â‰  0 âˆ§ âˆ€ x y : Î±, edist (toFun x) (toFun y) = r * edist x y\n\n"}
{"name":"Dilation.mk.sizeOf_spec","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : PseudoEMetricSpace Î±\ninstâœÂ² : PseudoEMetricSpace Î²\ninstâœÂ¹ : SizeOf Î±\ninstâœ : SizeOf Î²\ntoFun : Î± â†’ Î²\nedist_eq' : Exists fun r => And (Ne r 0) (âˆ€ (x y : Î±), Eq (EDist.edist (toFun x) (toFun y)) (HMul.hMul (â†‘r) (EDist.edist x y)))\nâŠ¢ Eq (SizeOf.sizeOf { toFun := toFun, edist_eq' := edist_eq' }) (HAdd.hAdd 1 (SizeOf.sizeOf edist_eq'))","decl":"/-- A dilation is a map that uniformly scales the edistance between any two points. -/\nstructure Dilation where\n  toFun : Î± â†’ Î²\n  edist_eq' : âˆƒ r : â„â‰¥0, r â‰  0 âˆ§ âˆ€ x y : Î±, edist (toFun x) (toFun y) = r * edist x y\n\n"}
{"name":"Dilation.mk.inj","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\ntoFunâœ : Î± â†’ Î²\nedist_eq'âœ : Exists fun r => And (Ne r 0) (âˆ€ (x y : Î±), Eq (EDist.edist (toFunâœ x) (toFunâœ y)) (HMul.hMul (â†‘r) (EDist.edist x y)))\ntoFun : Î± â†’ Î²\nedist_eq' : Exists fun r => And (Ne r 0) (âˆ€ (x y : Î±), Eq (EDist.edist (toFun x) (toFun y)) (HMul.hMul (â†‘r) (EDist.edist x y)))\nxâœ : Eq { toFun := toFunâœ, edist_eq' := edist_eq'âœ } { toFun := toFun, edist_eq' := edist_eq' }\nâŠ¢ Eq toFunâœ toFun","decl":"/-- A dilation is a map that uniformly scales the edistance between any two points. -/\nstructure Dilation where\n  toFun : Î± â†’ Î²\n  edist_eq' : âˆƒ r : â„â‰¥0, r â‰  0 âˆ§ âˆ€ x y : Î±, edist (toFun x) (toFun y) = r * edist x y\n\n"}
{"name":"DilationClass.edist_eq'","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"F : Type u_3\nÎ± : outParam (Type u_4)\nÎ² : outParam (Type u_5)\ninstâœÂ² : PseudoEMetricSpace Î±\ninstâœÂ¹ : PseudoEMetricSpace Î²\ninstâœ : FunLike F Î± Î²\nself : DilationClass F Î± Î²\nf : F\nâŠ¢ Exists fun r => And (Ne r 0) (âˆ€ (x y : Î±), Eq (EDist.edist (f x) (f y)) (HMul.hMul (â†‘r) (EDist.edist x y)))","decl":"/-- `DilationClass F Î± Î² r` states that `F` is a type of `r`-dilations.\nYou should extend this typeclass when you extend `Dilation`. -/\nclass DilationClass (F : Type*) (Î± Î² : outParam Type*) [PseudoEMetricSpace Î±] [PseudoEMetricSpace Î²]\n    [FunLike F Î± Î²] : Prop where\n  edist_eq' : âˆ€ f : F, âˆƒ r : â„â‰¥0, r â‰  0 âˆ§ âˆ€ x y : Î±, edist (f x) (f y) = r * edist x y\n\n"}
{"name":"Dilation.toDilationClass","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nâŠ¢ DilationClass (Dilation Î± Î²) Î± Î²","decl":"instance toDilationClass : DilationClass (Î± â†’áµˆ Î²) Î± Î² where\n  edist_eq' f := edist_eq' f\n\n"}
{"name":"Dilation.toFun_eq_coe","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nf : Dilation Î± Î²\nâŠ¢ Eq f.toFun â‡‘f","decl":"@[simp]\ntheorem toFun_eq_coe {f : Î± â†’áµˆ Î²} : f.toFun = (f : Î± â†’ Î²) :=\n  rfl\n\n"}
{"name":"Dilation.coe_mk","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nf : Î± â†’ Î²\nh : Exists fun r => And (Ne r 0) (âˆ€ (x y : Î±), Eq (EDist.edist (f x) (f y)) (HMul.hMul (â†‘r) (EDist.edist x y)))\nâŠ¢ Eq (â‡‘{ toFun := f, edist_eq' := h }) f","decl":"@[simp]\ntheorem coe_mk (f : Î± â†’ Î²) (h) : â‡‘(âŸ¨f, hâŸ© : Î± â†’áµˆ Î²) = f :=\n  rfl\n\n"}
{"name":"Dilation.congr_fun","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nf g : Dilation Î± Î²\nh : Eq f g\nx : Î±\nâŠ¢ Eq (f x) (g x)","decl":"protected theorem congr_fun {f g : Î± â†’áµˆ Î²} (h : f = g) (x : Î±) : f x = g x :=\n  DFunLike.congr_fun h x\n\n"}
{"name":"Dilation.congr_arg","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nf : Dilation Î± Î²\nx y : Î±\nh : Eq x y\nâŠ¢ Eq (f x) (f y)","decl":"protected theorem congr_arg (f : Î± â†’áµˆ Î²) {x y : Î±} (h : x = y) : f x = f y :=\n  DFunLike.congr_arg f h\n\n"}
{"name":"Dilation.ext_iff","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nf g : Dilation Î± Î²\nâŠ¢ Iff (Eq f g) (âˆ€ (x : Î±), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext {f g : Î± â†’áµˆ Î²} (h : âˆ€ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"Dilation.ext","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nf g : Dilation Î± Î²\nh : âˆ€ (x : Î±), Eq (f x) (g x)\nâŠ¢ Eq f g","decl":"@[ext]\ntheorem ext {f g : Î± â†’áµˆ Î²} (h : âˆ€ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"Dilation.mk_coe","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nf : Dilation Î± Î²\nh : Exists fun r => And (Ne r 0) (âˆ€ (x y : Î±), Eq (EDist.edist (f x) (f y)) (HMul.hMul (â†‘r) (EDist.edist x y)))\nâŠ¢ Eq { toFun := â‡‘f, edist_eq' := h } f","decl":"@[simp]\ntheorem mk_coe (f : Î± â†’áµˆ Î²) (h) : Dilation.mk f h = f :=\n  ext fun _ => rfl\n\n"}
{"name":"Dilation.copy_toFun","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nf : Dilation Î± Î²\nf' : Î± â†’ Î²\nh : Eq f' â‡‘f\nâŠ¢ Eq (â‡‘(f.copy f' h)) f'","decl":"/-- Copy of a `Dilation` with a new `toFun` equal to the old one. Useful to fix definitional\nequalities. -/\n@[simps (config := .asFn)]\nprotected def copy (f : Î± â†’áµˆ Î²) (f' : Î± â†’ Î²) (h : f' = â‡‘f) : Î± â†’áµˆ Î² where\n  toFun := f'\n  edist_eq' := h.symm â–¸ f.edist_eq'\n\n"}
{"name":"Dilation.copy_eq_self","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nf : Dilation Î± Î²\nf' : Î± â†’ Î²\nh : Eq f' â‡‘f\nâŠ¢ Eq (f.copy f' h) f","decl":"theorem copy_eq_self (f : Î± â†’áµˆ Î²) {f' : Î± â†’ Î²} (h : f' = f) : f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"Dilation.ratio_of_trivial","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : PseudoEMetricSpace Î±\ninstâœÂ² : PseudoEMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nh : âˆ€ (x y : Î±), Or (Eq (EDist.edist x y) 0) (Eq (EDist.edist x y) Top.top)\nâŠ¢ Eq (Dilation.ratio f) 1","decl":"theorem ratio_of_trivial [DilationClass F Î± Î²] (f : F)\n    (h : âˆ€ x y : Î±, edist x y = 0 âˆ¨ edist x y = âˆ) : ratio f = 1 :=\n  if_pos h\n\n"}
{"name":"Dilation.ratio_of_subsingleton","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœâ´ : PseudoEMetricSpace Î±\ninstâœÂ³ : PseudoEMetricSpace Î²\ninstâœÂ² : FunLike F Î± Î²\ninstâœÂ¹ : Subsingleton Î±\ninstâœ : DilationClass F Î± Î²\nf : F\nâŠ¢ Eq (Dilation.ratio f) 1","decl":"@[nontriviality]\ntheorem ratio_of_subsingleton [Subsingleton Î±] [DilationClass F Î± Î²] (f : F) : ratio f = 1 :=\n  if_pos fun x y â†¦ by simp [Subsingleton.elim x y]\n\n"}
{"name":"Dilation.ratio_ne_zero","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : PseudoEMetricSpace Î±\ninstâœÂ² : PseudoEMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nâŠ¢ Ne (Dilation.ratio f) 0","decl":"theorem ratio_ne_zero [DilationClass F Î± Î²] (f : F) : ratio f â‰  0 := by\n  rw [ratio]; split_ifs\n  Â· exact one_ne_zero\n  exact (DilationClass.edist_eq' f).choose_spec.1\n\n"}
{"name":"Dilation.ratio_pos","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : PseudoEMetricSpace Î±\ninstâœÂ² : PseudoEMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nâŠ¢ LT.lt 0 (Dilation.ratio f)","decl":"theorem ratio_pos [DilationClass F Î± Î²] (f : F) : 0 < ratio f :=\n  (ratio_ne_zero f).bot_lt\n\n"}
{"name":"Dilation.edist_eq","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : PseudoEMetricSpace Î±\ninstâœÂ² : PseudoEMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nx y : Î±\nâŠ¢ Eq (EDist.edist (f x) (f y)) (HMul.hMul (â†‘(Dilation.ratio f)) (EDist.edist x y))","decl":"@[simp]\ntheorem edist_eq [DilationClass F Î± Î²] (f : F) (x y : Î±) :\n    edist (f x) (f y) = ratio f * edist x y := by\n  rw [ratio]; split_ifs with key\n  Â· rcases DilationClass.edist_eq' f with âŸ¨r, hne, hrâŸ©\n    replace hr := hr x y\n    cases' key x y with h h\n    Â· simp only [hr, h, mul_zero]\n    Â· simp [hr, h, hne]\n  exact (DilationClass.edist_eq' f).choose_spec.2 x y\n\n"}
{"name":"Dilation.nndist_eq","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_5\nÎ² : Type u_6\nF : Type u_7\ninstâœÂ³ : PseudoMetricSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nx y : Î±\nâŠ¢ Eq (NNDist.nndist (f x) (f y)) (HMul.hMul (Dilation.ratio f) (NNDist.nndist x y))","decl":"@[simp]\ntheorem nndist_eq {Î± Î² F : Type*} [PseudoMetricSpace Î±] [PseudoMetricSpace Î²] [FunLike F Î± Î²]\n    [DilationClass F Î± Î²] (f : F) (x y : Î±) :\n    nndist (f x) (f y) = ratio f * nndist x y := by\n  simp only [â† ENNReal.coe_inj, â† edist_nndist, ENNReal.coe_mul, edist_eq]\n\n"}
{"name":"Dilation.dist_eq","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_5\nÎ² : Type u_6\nF : Type u_7\ninstâœÂ³ : PseudoMetricSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nx y : Î±\nâŠ¢ Eq (Dist.dist (f x) (f y)) (HMul.hMul (â†‘(Dilation.ratio f)) (Dist.dist x y))","decl":"@[simp]\ntheorem dist_eq {Î± Î² F : Type*} [PseudoMetricSpace Î±] [PseudoMetricSpace Î²] [FunLike F Î± Î²]\n    [DilationClass F Î± Î²] (f : F) (x y : Î±) :\n    dist (f x) (f y) = ratio f * dist x y := by\n  simp only [dist_nndist, nndist_eq, NNReal.coe_mul]\n\n"}
{"name":"Dilation.ratio_unique","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : PseudoEMetricSpace Î±\ninstâœÂ² : PseudoEMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nx y : Î±\nr : NNReal\nhâ‚€ : Ne (EDist.edist x y) 0\nhtop : Ne (EDist.edist x y) Top.top\nhr : Eq (EDist.edist (f x) (f y)) (HMul.hMul (â†‘r) (EDist.edist x y))\nâŠ¢ Eq r (Dilation.ratio f)","decl":"/-- The `ratio` is equal to the distance ratio for any two points with nonzero finite distance.\n`dist` and `nndist` versions below -/\ntheorem ratio_unique [DilationClass F Î± Î²] {f : F} {x y : Î±} {r : â„â‰¥0} (hâ‚€ : edist x y â‰  0)\n    (htop : edist x y â‰  âŠ¤) (hr : edist (f x) (f y) = r * edist x y) : r = ratio f := by\n  simpa only [hr, ENNReal.mul_left_inj hâ‚€ htop, ENNReal.coe_inj] using edist_eq f x y\n\n"}
{"name":"Dilation.ratio_unique_of_nndist_ne_zero","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_5\nÎ² : Type u_6\nF : Type u_7\ninstâœÂ³ : PseudoMetricSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nx y : Î±\nr : NNReal\nhxy : Ne (NNDist.nndist x y) 0\nhr : Eq (NNDist.nndist (f x) (f y)) (HMul.hMul r (NNDist.nndist x y))\nâŠ¢ Eq r (Dilation.ratio f)","decl":"/-- The `ratio` is equal to the distance ratio for any two points\nwith nonzero finite distance; `nndist` version -/\ntheorem ratio_unique_of_nndist_ne_zero {Î± Î² F : Type*} [PseudoMetricSpace Î±] [PseudoMetricSpace Î²]\n    [FunLike F Î± Î²] [DilationClass F Î± Î²] {f : F} {x y : Î±} {r : â„â‰¥0} (hxy : nndist x y â‰  0)\n    (hr : nndist (f x) (f y) = r * nndist x y) : r = ratio f :=\n  ratio_unique (by rwa [edist_nndist, ENNReal.coe_ne_zero]) (edist_ne_top x y)\n    (by rw [edist_nndist, edist_nndist, hr, ENNReal.coe_mul])\n\n"}
{"name":"Dilation.ratio_unique_of_dist_ne_zero","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_6\nÎ² : Type u_7\nF : Type u_5\ninstâœÂ³ : PseudoMetricSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nx y : Î±\nr : NNReal\nhxy : Ne (Dist.dist x y) 0\nhr : Eq (Dist.dist (f x) (f y)) (HMul.hMul (â†‘r) (Dist.dist x y))\nâŠ¢ Eq r (Dilation.ratio f)","decl":"/-- The `ratio` is equal to the distance ratio for any two points\nwith nonzero finite distance; `dist` version -/\ntheorem ratio_unique_of_dist_ne_zero {Î± Î²} {F : Type*} [PseudoMetricSpace Î±] [PseudoMetricSpace Î²]\n    [FunLike F Î± Î²] [DilationClass F Î± Î²] {f : F} {x y : Î±} {r : â„â‰¥0} (hxy : dist x y â‰  0)\n    (hr : dist (f x) (f y) = r * dist x y) : r = ratio f :=\n  ratio_unique_of_nndist_ne_zero (NNReal.coe_ne_zero.1 hxy) <|\n    NNReal.eq <| by rw [coe_nndist, hr, NNReal.coe_mul, coe_nndist]\n\n"}
{"name":"Dilation.coe_mkOfNNDistEq","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_5\nÎ² : Type u_6\ninstâœÂ¹ : PseudoMetricSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf : Î± â†’ Î²\nh : Exists fun r => And (Ne r 0) (âˆ€ (x y : Î±), Eq (NNDist.nndist (f x) (f y)) (HMul.hMul r (NNDist.nndist x y)))\nâŠ¢ Eq (â‡‘(Dilation.mkOfNNDistEq f h)) f","decl":"@[simp]\ntheorem coe_mkOfNNDistEq {Î± Î²} [PseudoMetricSpace Î±] [PseudoMetricSpace Î²] (f : Î± â†’ Î²) (h) :\n    â‡‘(mkOfNNDistEq f h : Î± â†’áµˆ Î²) = f :=\n  rfl\n\n"}
{"name":"Dilation.mk_coe_of_nndist_eq","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_5\nÎ² : Type u_6\ninstâœÂ¹ : PseudoMetricSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf : Dilation Î± Î²\nh : Exists fun r => And (Ne r 0) (âˆ€ (x y : Î±), Eq (NNDist.nndist (f x) (f y)) (HMul.hMul r (NNDist.nndist x y)))\nâŠ¢ Eq (Dilation.mkOfNNDistEq (â‡‘f) h) f","decl":"@[simp]\ntheorem mk_coe_of_nndist_eq {Î± Î²} [PseudoMetricSpace Î±] [PseudoMetricSpace Î²] (f : Î± â†’áµˆ Î²)\n    (h) : Dilation.mkOfNNDistEq f h = f :=\n  ext fun _ => rfl\n\n"}
{"name":"Dilation.coe_mkOfDistEq","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_5\nÎ² : Type u_6\ninstâœÂ¹ : PseudoMetricSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf : Î± â†’ Î²\nh : Exists fun r => And (Ne r 0) (âˆ€ (x y : Î±), Eq (Dist.dist (f x) (f y)) (HMul.hMul (â†‘r) (Dist.dist x y)))\nâŠ¢ Eq (â‡‘(Dilation.mkOfDistEq f h)) f","decl":"@[simp]\ntheorem coe_mkOfDistEq {Î± Î²} [PseudoMetricSpace Î±] [PseudoMetricSpace Î²] (f : Î± â†’ Î²) (h) :\n    â‡‘(mkOfDistEq f h : Î± â†’áµˆ Î²) = f :=\n  rfl\n\n"}
{"name":"Dilation.mk_coe_of_dist_eq","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_5\nÎ² : Type u_6\ninstâœÂ¹ : PseudoMetricSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf : Dilation Î± Î²\nh : Exists fun r => And (Ne r 0) (âˆ€ (x y : Î±), Eq (Dist.dist (f x) (f y)) (HMul.hMul (â†‘r) (Dist.dist x y)))\nâŠ¢ Eq (Dilation.mkOfDistEq (â‡‘f) h) f","decl":"@[simp]\ntheorem mk_coe_of_dist_eq {Î± Î²} [PseudoMetricSpace Î±] [PseudoMetricSpace Î²] (f : Î± â†’áµˆ Î²) (h) :\n    Dilation.mkOfDistEq f h = f :=\n  ext fun _ => rfl\n\n"}
{"name":"Isometry.toDilation_toFun","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nf : Î± â†’ Î²\nhf : Isometry f\naâœ : Î±\nâŠ¢ Eq ((Isometry.toDilation f hf) aâœ) (f aâœ)","decl":"/-- Every isometry is a dilation of ratio `1`. -/\n@[simps]\ndef _root_.Isometry.toDilation (f : Î± â†’ Î²) (hf : Isometry f) : Î± â†’áµˆ Î² where\n  toFun := f\n  edist_eq' := âŸ¨1, one_ne_zero, by simpa using hfâŸ©\n\n"}
{"name":"Isometry.toDilation_ratio","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nf : Î± â†’ Î²\nhf : Isometry f\nâŠ¢ Eq (Dilation.ratio (Isometry.toDilation f hf)) 1","decl":"@[simp]\nlemma _root_.Isometry.toDilation_ratio {f : Î± â†’ Î²} {hf : Isometry f} : ratio hf.toDilation = 1 := by\n  by_cases h : âˆ€ x y : Î±, edist x y = 0 âˆ¨ edist x y = âŠ¤\n  Â· exact ratio_of_trivial hf.toDilation h\n  Â· push_neg at h\n    obtain âŸ¨x, y, hâ‚, hâ‚‚âŸ© := h\n    exact ratio_unique hâ‚ hâ‚‚ (by simp [hf x y]) |>.symm\n\n"}
{"name":"Dilation.lipschitz","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : PseudoEMetricSpace Î±\ninstâœÂ² : PseudoEMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nâŠ¢ LipschitzWith (Dilation.ratio f) â‡‘f","decl":"theorem lipschitz : LipschitzWith (ratio f) (f : Î± â†’ Î²) := fun x y => (edist_eq f x y).le\n\n"}
{"name":"Dilation.antilipschitz","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : PseudoEMetricSpace Î±\ninstâœÂ² : PseudoEMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nâŠ¢ AntilipschitzWith (Inv.inv (Dilation.ratio f)) â‡‘f","decl":"theorem antilipschitz : AntilipschitzWith (ratio f)â»Â¹ (f : Î± â†’ Î²) := fun x y => by\n  have hr : ratio f â‰  0 := ratio_ne_zero f\n  exact mod_cast\n    (ENNReal.mul_le_iff_le_inv (ENNReal.coe_ne_zero.2 hr) ENNReal.coe_ne_top).1 (edist_eq f x y).ge\n\n"}
{"name":"Dilation.injective","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î² : Type u_2\nF : Type u_4\ninstâœÂ³ : PseudoEMetricSpace Î²\nÎ± : Type u_5\ninstâœÂ² : EMetricSpace Î±\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nâŠ¢ Function.Injective â‡‘f","decl":"/-- A dilation from an emetric space is injective -/\nprotected theorem injective {Î± : Type*} [EMetricSpace Î±] [FunLike F Î± Î²]  [DilationClass F Î± Î²]\n    (f : F) :\n    Injective f :=\n  (antilipschitz f).injective\n\n"}
{"name":"Dilation.coe_id","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\ninstâœ : PseudoEMetricSpace Î±\nâŠ¢ Eq (â‡‘(Dilation.id Î±)) id","decl":"@[simp]\nprotected theorem coe_id : â‡‘(Dilation.id Î±) = id :=\n  rfl\n\n"}
{"name":"Dilation.ratio_id","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\ninstâœ : PseudoEMetricSpace Î±\nâŠ¢ Eq (Dilation.ratio (Dilation.id Î±)) 1","decl":"theorem ratio_id : ratio (Dilation.id Î±) = 1 := by\n  by_cases h : âˆ€ x y : Î±, edist x y = 0 âˆ¨ edist x y = âˆ\n  Â· rw [ratio, if_pos h]\n  Â· push_neg at h\n    rcases h with âŸ¨x, y, hneâŸ©\n    refine (ratio_unique hne.1 hne.2 ?_).symm\n    simp\n\n"}
{"name":"Dilation.comp_assoc","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : PseudoEMetricSpace Î±\ninstâœÂ² : PseudoEMetricSpace Î²\ninstâœÂ¹ : PseudoEMetricSpace Î³\nÎ´ : Type u_5\ninstâœ : PseudoEMetricSpace Î´\nf : Dilation Î± Î²\ng : Dilation Î² Î³\nh : Dilation Î³ Î´\nâŠ¢ Eq ((h.comp g).comp f) (h.comp (g.comp f))","decl":"theorem comp_assoc {Î´ : Type*} [PseudoEMetricSpace Î´] (f : Î± â†’áµˆ Î²) (g : Î² â†’áµˆ Î³)\n    (h : Î³ â†’áµˆ Î´) : (h.comp g).comp f = h.comp (g.comp f) :=\n  rfl\n\n"}
{"name":"Dilation.coe_comp","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ² : PseudoEMetricSpace Î±\ninstâœÂ¹ : PseudoEMetricSpace Î²\ninstâœ : PseudoEMetricSpace Î³\ng : Dilation Î² Î³\nf : Dilation Î± Î²\nâŠ¢ Eq (â‡‘(g.comp f)) (Function.comp â‡‘g â‡‘f)","decl":"@[simp]\ntheorem coe_comp (g : Î² â†’áµˆ Î³) (f : Î± â†’áµˆ Î²) : (g.comp f : Î± â†’ Î³) = g âˆ˜ f :=\n  rfl\n\n"}
{"name":"Dilation.comp_apply","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ² : PseudoEMetricSpace Î±\ninstâœÂ¹ : PseudoEMetricSpace Î²\ninstâœ : PseudoEMetricSpace Î³\ng : Dilation Î² Î³\nf : Dilation Î± Î²\nx : Î±\nâŠ¢ Eq ((g.comp f) x) (g (f x))","decl":"theorem comp_apply (g : Î² â†’áµˆ Î³) (f : Î± â†’áµˆ Î²) (x : Î±) : (g.comp f : Î± â†’ Î³) x = g (f x) :=\n  rfl\n\n"}
{"name":"Dilation.ratio_comp'","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ² : PseudoEMetricSpace Î±\ninstâœÂ¹ : PseudoEMetricSpace Î²\ninstâœ : PseudoEMetricSpace Î³\ng : Dilation Î² Î³\nf : Dilation Î± Î²\nhne : Exists fun x => Exists fun y => And (Ne (EDist.edist x y) 0) (Ne (EDist.edist x y) Top.top)\nâŠ¢ Eq (Dilation.ratio (g.comp f)) (HMul.hMul (Dilation.ratio g) (Dilation.ratio f))","decl":"/-- Ratio of the composition `g.comp f` of two dilations is the product of their ratios. We assume\nthat there exist two points in `Î±` at extended distance neither `0` nor `âˆ` because otherwise\n`Dilation.ratio (g.comp f) = Dilation.ratio f = 1` while `Dilation.ratio g` can be any number. This\nversion works for most general spaces, see also `Dilation.ratio_comp` for a version assuming that\n`Î±` is a nontrivial metric space. -/\ntheorem ratio_comp' {g : Î² â†’áµˆ Î³} {f : Î± â†’áµˆ Î²}\n    (hne : âˆƒ x y : Î±, edist x y â‰  0 âˆ§ edist x y â‰  âŠ¤) : ratio (g.comp f) = ratio g * ratio f := by\n  rcases hne with âŸ¨x, y, hÎ±âŸ©\n  have hgf := (edist_eq (g.comp f) x y).symm\n  simp_rw [coe_comp, Function.comp, edist_eq, â† mul_assoc, ENNReal.mul_left_inj hÎ±.1 hÎ±.2]\n    at hgf\n  rwa [â† ENNReal.coe_inj, ENNReal.coe_mul]\n\n"}
{"name":"Dilation.comp_id","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nf : Dilation Î± Î²\nâŠ¢ Eq (f.comp (Dilation.id Î±)) f","decl":"@[simp]\ntheorem comp_id (f : Î± â†’áµˆ Î²) : f.comp (Dilation.id Î±) = f :=\n  ext fun _ => rfl\n\n"}
{"name":"Dilation.id_comp","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nf : Dilation Î± Î²\nâŠ¢ Eq ((Dilation.id Î²).comp f) f","decl":"@[simp]\ntheorem id_comp (f : Î± â†’áµˆ Î²) : (Dilation.id Î²).comp f = f :=\n  ext fun _ => rfl\n\n"}
{"name":"Dilation.one_def","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\ninstâœ : PseudoEMetricSpace Î±\nâŠ¢ Eq 1 (Dilation.id Î±)","decl":"theorem one_def : (1 : Î± â†’áµˆ Î±) = Dilation.id Î± :=\n  rfl\n\n"}
{"name":"Dilation.mul_def","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\ninstâœ : PseudoEMetricSpace Î±\nf g : Dilation Î± Î±\nâŠ¢ Eq (HMul.hMul f g) (f.comp g)","decl":"theorem mul_def (f g : Î± â†’áµˆ Î±) : f * g = f.comp g :=\n  rfl\n\n"}
{"name":"Dilation.coe_one","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\ninstâœ : PseudoEMetricSpace Î±\nâŠ¢ Eq (â‡‘1) id","decl":"@[simp]\ntheorem coe_one : â‡‘(1 : Î± â†’áµˆ Î±) = id :=\n  rfl\n\n"}
{"name":"Dilation.coe_mul","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\ninstâœ : PseudoEMetricSpace Î±\nf g : Dilation Î± Î±\nâŠ¢ Eq (â‡‘(HMul.hMul f g)) (Function.comp â‡‘f â‡‘g)","decl":"@[simp]\ntheorem coe_mul (f g : Î± â†’áµˆ Î±) : â‡‘(f * g) = f âˆ˜ g :=\n  rfl\n\n"}
{"name":"Dilation.ratio_one","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\ninstâœ : PseudoEMetricSpace Î±\nâŠ¢ Eq (Dilation.ratio 1) 1","decl":"@[simp] theorem ratio_one : ratio (1 : Î± â†’áµˆ Î±) = 1 := ratio_id\n\n"}
{"name":"Dilation.ratio_mul","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\ninstâœ : PseudoEMetricSpace Î±\nf g : Dilation Î± Î±\nâŠ¢ Eq (Dilation.ratio (HMul.hMul f g)) (HMul.hMul (Dilation.ratio f) (Dilation.ratio g))","decl":"@[simp]\ntheorem ratio_mul (f g : Î± â†’áµˆ Î±) : ratio (f * g) = ratio f * ratio g := by\n  by_cases h : âˆ€ x y : Î±, edist x y = 0 âˆ¨ edist x y = âˆ\n  Â· simp [ratio_of_trivial, h]\n  push_neg at h\n  exact ratio_comp' h\n\n"}
{"name":"Dilation.ratioHom_apply","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\ninstâœ : PseudoEMetricSpace Î±\nf : Dilation Î± Î±\nâŠ¢ Eq (Dilation.ratioHom f) (Dilation.ratio f)","decl":"/-- `Dilation.ratio` as a monoid homomorphism from `Î± â†’áµˆ Î±` to `â„â‰¥0`. -/\n@[simps]\ndef ratioHom : (Î± â†’áµˆ Î±) â†’* â„â‰¥0 := âŸ¨âŸ¨ratio, ratio_oneâŸ©, ratio_mulâŸ©\n\n"}
{"name":"Dilation.ratio_pow","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\ninstâœ : PseudoEMetricSpace Î±\nf : Dilation Î± Î±\nn : Nat\nâŠ¢ Eq (Dilation.ratio (HPow.hPow f n)) (HPow.hPow (Dilation.ratio f) n)","decl":"@[simp]\ntheorem ratio_pow (f : Î± â†’áµˆ Î±) (n : â„•) : ratio (f ^ n) = ratio f ^ n :=\n  ratioHom.map_pow _ _\n\n"}
{"name":"Dilation.cancel_right","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ² : PseudoEMetricSpace Î±\ninstâœÂ¹ : PseudoEMetricSpace Î²\ninstâœ : PseudoEMetricSpace Î³\ngâ‚ gâ‚‚ : Dilation Î² Î³\nf : Dilation Î± Î²\nhf : Function.Surjective â‡‘f\nâŠ¢ Iff (Eq (gâ‚.comp f) (gâ‚‚.comp f)) (Eq gâ‚ gâ‚‚)","decl":"@[simp]\ntheorem cancel_right {gâ‚ gâ‚‚ : Î² â†’áµˆ Î³} {f : Î± â†’áµˆ Î²} (hf : Surjective f) :\n    gâ‚.comp f = gâ‚‚.comp f â†” gâ‚ = gâ‚‚ :=\n  âŸ¨fun h => Dilation.ext <| hf.forall.2 (Dilation.ext_iff.1 h), fun h => h â–¸ rflâŸ©\n\n"}
{"name":"Dilation.cancel_left","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ² : PseudoEMetricSpace Î±\ninstâœÂ¹ : PseudoEMetricSpace Î²\ninstâœ : PseudoEMetricSpace Î³\ng : Dilation Î² Î³\nfâ‚ fâ‚‚ : Dilation Î± Î²\nhg : Function.Injective â‡‘g\nâŠ¢ Iff (Eq (g.comp fâ‚) (g.comp fâ‚‚)) (Eq fâ‚ fâ‚‚)","decl":"@[simp]\ntheorem cancel_left {g : Î² â†’áµˆ Î³} {fâ‚ fâ‚‚ : Î± â†’áµˆ Î²} (hg : Injective g) :\n    g.comp fâ‚ = g.comp fâ‚‚ â†” fâ‚ = fâ‚‚ :=\n  âŸ¨fun h => Dilation.ext fun x => hg <| by rw [â† comp_apply, h, comp_apply], fun h => h â–¸ rflâŸ©\n\n"}
{"name":"Dilation.isUniformInducing","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : PseudoEMetricSpace Î±\ninstâœÂ² : PseudoEMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nâŠ¢ IsUniformInducing â‡‘f","decl":"/-- A dilation from a metric space is a uniform inducing map -/\ntheorem isUniformInducing : IsUniformInducing (f : Î± â†’ Î²) :=\n  (antilipschitz f).isUniformInducing (lipschitz f).uniformContinuous\n\n"}
{"name":"Dilation.uniformInducing","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : PseudoEMetricSpace Î±\ninstâœÂ² : PseudoEMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nâŠ¢ IsUniformInducing â‡‘f","decl":"@[deprecated (since := \"2024-10-05\")]\nalias uniformInducing := isUniformInducing\n\n"}
{"name":"Dilation.tendsto_nhds_iff","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : PseudoEMetricSpace Î±\ninstâœÂ² : PseudoEMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nÎ¹ : Type u_5\ng : Î¹ â†’ Î±\na : Filter Î¹\nb : Î±\nâŠ¢ Iff (Filter.Tendsto g a (nhds b)) (Filter.Tendsto (Function.comp (â‡‘f) g) a (nhds (f b)))","decl":"theorem tendsto_nhds_iff {Î¹ : Type*} {g : Î¹ â†’ Î±} {a : Filter Î¹} {b : Î±} :\n    Filter.Tendsto g a (ğ“ b) â†” Filter.Tendsto ((f : Î± â†’ Î²) âˆ˜ g) a (ğ“ (f b)) :=\n  (Dilation.isUniformInducing f).isInducing.tendsto_nhds_iff\n\n"}
{"name":"Dilation.toContinuous","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : PseudoEMetricSpace Î±\ninstâœÂ² : PseudoEMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nâŠ¢ Continuous â‡‘f","decl":"/-- A dilation is continuous. -/\ntheorem toContinuous : Continuous (f : Î± â†’ Î²) :=\n  (lipschitz f).continuous\n\n"}
{"name":"Dilation.ediam_image","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : PseudoEMetricSpace Î±\ninstâœÂ² : PseudoEMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\ns : Set Î±\nâŠ¢ Eq (EMetric.diam (Set.image (â‡‘f) s)) (HMul.hMul (â†‘(Dilation.ratio f)) (EMetric.diam s))","decl":"/-- Dilations scale the diameter by `ratio f` in pseudoemetric spaces. -/\ntheorem ediam_image (s : Set Î±) : EMetric.diam ((f : Î± â†’ Î²) '' s) = ratio f * EMetric.diam s := by\n  refine ((lipschitz f).ediam_image_le s).antisymm ?_\n  apply ENNReal.mul_le_of_le_div'\n  rw [div_eq_mul_inv, mul_comm, â† ENNReal.coe_inv]\n  exacts [(antilipschitz f).le_mul_ediam_image s, ratio_ne_zero f]\n\n"}
{"name":"Dilation.ediam_range","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : PseudoEMetricSpace Î±\ninstâœÂ² : PseudoEMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nâŠ¢ Eq (EMetric.diam (Set.range â‡‘f)) (HMul.hMul (â†‘(Dilation.ratio f)) (EMetric.diam Set.univ))","decl":"/-- A dilation scales the diameter of the range by `ratio f`. -/\ntheorem ediam_range : EMetric.diam (range (f : Î± â†’ Î²)) = ratio f * EMetric.diam (univ : Set Î±) := by\n  rw [â† image_univ]; exact ediam_image f univ\n\n"}
{"name":"Dilation.mapsTo_emetric_ball","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : PseudoEMetricSpace Î±\ninstâœÂ² : PseudoEMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nx : Î±\nr : ENNReal\nâŠ¢ Set.MapsTo (â‡‘f) (EMetric.ball x r) (EMetric.ball (f x) (HMul.hMul (â†‘(Dilation.ratio f)) r))","decl":"/-- A dilation maps balls to balls and scales the radius by `ratio f`. -/\ntheorem mapsTo_emetric_ball (x : Î±) (r : â„â‰¥0âˆ) :\n    MapsTo (f : Î± â†’ Î²) (EMetric.ball x r) (EMetric.ball (f x) (ratio f * r)) :=\n  fun y hy => (edist_eq f y x).trans_lt <|\n    (ENNReal.mul_lt_mul_left (ENNReal.coe_ne_zero.2 <| ratio_ne_zero f) ENNReal.coe_ne_top).2 hy\n\n"}
{"name":"Dilation.mapsTo_emetric_closedBall","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : PseudoEMetricSpace Î±\ninstâœÂ² : PseudoEMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nx : Î±\nr' : ENNReal\nâŠ¢ Set.MapsTo (â‡‘f) (EMetric.closedBall x r') (EMetric.closedBall (f x) (HMul.hMul (â†‘(Dilation.ratio f)) r'))","decl":"/-- A dilation maps closed balls to closed balls and scales the radius by `ratio f`. -/\ntheorem mapsTo_emetric_closedBall (x : Î±) (r' : â„â‰¥0âˆ) :\n    MapsTo (f : Î± â†’ Î²) (EMetric.closedBall x r') (EMetric.closedBall (f x) (ratio f * r')) :=\n  -- Porting note: Added `by exact`\n  fun y hy => (edist_eq f y x).trans_le <| mul_le_mul_left' (by exact hy) _\n\n"}
{"name":"Dilation.comp_continuousOn_iff","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœâ´ : PseudoEMetricSpace Î±\ninstâœÂ³ : PseudoEMetricSpace Î²\ninstâœÂ² : FunLike F Î± Î²\ninstâœÂ¹ : DilationClass F Î± Î²\nf : F\nÎ³ : Type u_5\ninstâœ : TopologicalSpace Î³\ng : Î³ â†’ Î±\ns : Set Î³\nâŠ¢ Iff (ContinuousOn (Function.comp (â‡‘f) g) s) (ContinuousOn g s)","decl":"theorem comp_continuousOn_iff {Î³} [TopologicalSpace Î³] {g : Î³ â†’ Î±} {s : Set Î³} :\n    ContinuousOn ((f : Î± â†’ Î²) âˆ˜ g) s â†” ContinuousOn g s :=\n  (Dilation.isUniformInducing f).isInducing.continuousOn_iff.symm\n\n"}
{"name":"Dilation.comp_continuous_iff","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœâ´ : PseudoEMetricSpace Î±\ninstâœÂ³ : PseudoEMetricSpace Î²\ninstâœÂ² : FunLike F Î± Î²\ninstâœÂ¹ : DilationClass F Î± Î²\nf : F\nÎ³ : Type u_5\ninstâœ : TopologicalSpace Î³\ng : Î³ â†’ Î±\nâŠ¢ Iff (Continuous (Function.comp (â‡‘f) g)) (Continuous g)","decl":"theorem comp_continuous_iff {Î³} [TopologicalSpace Î³] {g : Î³ â†’ Î±} :\n    Continuous ((f : Î± â†’ Î²) âˆ˜ g) â†” Continuous g :=\n  (Dilation.isUniformInducing f).isInducing.continuous_iff.symm\n\n"}
{"name":"Dilation.isUniformEmbedding","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : EMetricSpace Î±\ninstâœÂ² : FunLike F Î± Î²\ninstâœÂ¹ : PseudoEMetricSpace Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nâŠ¢ IsUniformEmbedding â‡‘f","decl":"/-- A dilation from a metric space is a uniform embedding -/\nlemma isUniformEmbedding [PseudoEMetricSpace Î²] [DilationClass F Î± Î²] (f : F) :\n    IsUniformEmbedding f :=\n  (antilipschitz f).isUniformEmbedding (lipschitz f).uniformContinuous\n\n"}
{"name":"Dilation.uniformEmbedding","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : EMetricSpace Î±\ninstâœÂ² : FunLike F Î± Î²\ninstâœÂ¹ : PseudoEMetricSpace Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nâŠ¢ IsUniformEmbedding â‡‘f","decl":"@[deprecated (since := \"2024-10-01\")] alias uniformEmbedding := isUniformEmbedding\n\n"}
{"name":"Dilation.isEmbedding","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : EMetricSpace Î±\ninstâœÂ² : FunLike F Î± Î²\ninstâœÂ¹ : PseudoEMetricSpace Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nâŠ¢ Topology.IsEmbedding â‡‘f","decl":"/-- A dilation from a metric space is an embedding -/\ntheorem isEmbedding [PseudoEMetricSpace Î²] [DilationClass F Î± Î²] (f : F) :\n    IsEmbedding (f : Î± â†’ Î²) :=\n  (Dilation.isUniformEmbedding f).isEmbedding\n\n"}
{"name":"Dilation.embedding","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : EMetricSpace Î±\ninstâœÂ² : FunLike F Î± Î²\ninstâœÂ¹ : PseudoEMetricSpace Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nâŠ¢ Topology.IsEmbedding â‡‘f","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding := isEmbedding\n\n"}
{"name":"Dilation.isClosedEmbedding","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœâ´ : EMetricSpace Î±\ninstâœÂ³ : FunLike F Î± Î²\ninstâœÂ² : CompleteSpace Î±\ninstâœÂ¹ : EMetricSpace Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nâŠ¢ Topology.IsClosedEmbedding â‡‘f","decl":"/-- A dilation from a complete emetric space is a closed embedding -/\nlemma isClosedEmbedding [CompleteSpace Î±] [EMetricSpace Î²] [DilationClass F Î± Î²] (f : F) :\n    IsClosedEmbedding f :=\n  (antilipschitz f).isClosedEmbedding (lipschitz f).uniformContinuous\n\n"}
{"name":"Dilation.closedEmbedding","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœâ´ : EMetricSpace Î±\ninstâœÂ³ : FunLike F Î± Î²\ninstâœÂ² : CompleteSpace Î±\ninstâœÂ¹ : EMetricSpace Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nâŠ¢ Topology.IsClosedEmbedding â‡‘f","decl":"@[deprecated (since := \"2024-10-20\")] alias closedEmbedding := isClosedEmbedding\n\n"}
{"name":"Dilation.ratio_comp","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : MetricSpace Î±\ninstâœÂ² : Nontrivial Î±\ninstâœÂ¹ : PseudoEMetricSpace Î²\ninstâœ : PseudoEMetricSpace Î³\ng : Dilation Î² Î³\nf : Dilation Î± Î²\nâŠ¢ Eq (Dilation.ratio (g.comp f)) (HMul.hMul (Dilation.ratio g) (Dilation.ratio f))","decl":"/-- Ratio of the composition `g.comp f` of two dilations is the product of their ratios. We assume\nthat the domain `Î±` of `f` is a nontrivial metric space, otherwise\n`Dilation.ratio f = Dilation.ratio (g.comp f) = 1` but `Dilation.ratio g` may have any value.\n\nSee also `Dilation.ratio_comp'` for a version that works for more general spaces. -/\n@[simp]\ntheorem ratio_comp [MetricSpace Î±] [Nontrivial Î±] [PseudoEMetricSpace Î²]\n    [PseudoEMetricSpace Î³] {g : Î² â†’áµˆ Î³} {f : Î± â†’áµˆ Î²} : ratio (g.comp f) = ratio g * ratio f :=\n  ratio_comp' <|\n    let âŸ¨x, y, hneâŸ© := exists_pair_ne Î±; âŸ¨x, y, mt edist_eq_zero.1 hne, edist_ne_top _ _âŸ©\n\n"}
{"name":"Dilation.diam_image","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : PseudoMetricSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\ns : Set Î±\nâŠ¢ Eq (Metric.diam (Set.image (â‡‘f) s)) (HMul.hMul (â†‘(Dilation.ratio f)) (Metric.diam s))","decl":"/-- A dilation scales the diameter by `ratio f` in pseudometric spaces. -/\ntheorem diam_image (s : Set Î±) : Metric.diam ((f : Î± â†’ Î²) '' s) = ratio f * Metric.diam s := by\n  simp [Metric.diam, ediam_image, ENNReal.toReal_mul]\n\n"}
{"name":"Dilation.diam_range","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : PseudoMetricSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nâŠ¢ Eq (Metric.diam (Set.range â‡‘f)) (HMul.hMul (â†‘(Dilation.ratio f)) (Metric.diam Set.univ))","decl":"theorem diam_range : Metric.diam (range (f : Î± â†’ Î²)) = ratio f * Metric.diam (univ : Set Î±) := by\n  rw [â† image_univ, diam_image]\n\n"}
{"name":"Dilation.mapsTo_ball","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : PseudoMetricSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nx : Î±\nr' : Real\nâŠ¢ Set.MapsTo (â‡‘f) (Metric.ball x r') (Metric.ball (f x) (HMul.hMul (â†‘(Dilation.ratio f)) r'))","decl":"/-- A dilation maps balls to balls and scales the radius by `ratio f`. -/\ntheorem mapsTo_ball (x : Î±) (r' : â„) :\n    MapsTo (f : Î± â†’ Î²) (Metric.ball x r') (Metric.ball (f x) (ratio f * r')) :=\n  fun y hy => (dist_eq f y x).trans_lt <| (mul_lt_mul_left <| NNReal.coe_pos.2 <| ratio_pos f).2 hy\n\n"}
{"name":"Dilation.mapsTo_sphere","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : PseudoMetricSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nx : Î±\nr' : Real\nâŠ¢ Set.MapsTo (â‡‘f) (Metric.sphere x r') (Metric.sphere (f x) (HMul.hMul (â†‘(Dilation.ratio f)) r'))","decl":"/-- A dilation maps spheres to spheres and scales the radius by `ratio f`. -/\ntheorem mapsTo_sphere (x : Î±) (r' : â„) :\n    MapsTo (f : Î± â†’ Î²) (Metric.sphere x r') (Metric.sphere (f x) (ratio f * r')) :=\n  fun y hy => Metric.mem_sphere.mp hy â–¸ dist_eq f y x\n\n"}
{"name":"Dilation.mapsTo_closedBall","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : PseudoMetricSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nx : Î±\nr' : Real\nâŠ¢ Set.MapsTo (â‡‘f) (Metric.closedBall x r') (Metric.closedBall (f x) (HMul.hMul (â†‘(Dilation.ratio f)) r'))","decl":"/-- A dilation maps closed balls to closed balls and scales the radius by `ratio f`. -/\ntheorem mapsTo_closedBall (x : Î±) (r' : â„) :\n    MapsTo (f : Î± â†’ Î²) (Metric.closedBall x r') (Metric.closedBall (f x) (ratio f * r')) :=\n  fun y hy => (dist_eq f y x).trans_le <| mul_le_mul_of_nonneg_left hy (NNReal.coe_nonneg _)\n\n"}
{"name":"Dilation.tendsto_cobounded","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : PseudoMetricSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nâŠ¢ Filter.Tendsto (â‡‘f) (Bornology.cobounded Î±) (Bornology.cobounded Î²)","decl":"lemma tendsto_cobounded : Filter.Tendsto f (cobounded Î±) (cobounded Î²) :=\n  (Dilation.antilipschitz f).tendsto_cobounded\n\n"}
{"name":"Dilation.comap_cobounded","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_4\ninstâœÂ³ : PseudoMetricSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nâŠ¢ Eq (Filter.comap (â‡‘f) (Bornology.cobounded Î²)) (Bornology.cobounded Î±)","decl":"@[simp]\nlemma comap_cobounded : Filter.comap f (cobounded Î²) = cobounded Î± :=\n  le_antisymm (lipschitz f).comap_cobounded_le (tendsto_cobounded f).le_comap\n\n"}
