{"name":"Dilation.mk.injEq","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\ntoFun✝ : α → β\nedist_eq'✝ : Exists fun r => And (Ne r 0) (∀ (x y : α), Eq (EDist.edist (toFun✝ x) (toFun✝ y)) (HMul.hMul (↑r) (EDist.edist x y)))\ntoFun : α → β\nedist_eq' : Exists fun r => And (Ne r 0) (∀ (x y : α), Eq (EDist.edist (toFun x) (toFun y)) (HMul.hMul (↑r) (EDist.edist x y)))\n⊢ Eq (Eq { toFun := toFun✝, edist_eq' := edist_eq'✝ } { toFun := toFun, edist_eq' := edist_eq' }) (Eq toFun✝ toFun)","decl":"/-- A dilation is a map that uniformly scales the edistance between any two points. -/\nstructure Dilation where\n  toFun : α → β\n  edist_eq' : ∃ r : ℝ≥0, r ≠ 0 ∧ ∀ x y : α, edist (toFun x) (toFun y) = r * edist x y\n\n"}
{"name":"Dilation.edist_eq'","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nself : Dilation α β\n⊢ Exists fun r => And (Ne r 0) (∀ (x y : α), Eq (EDist.edist (self.toFun x) (self.toFun y)) (HMul.hMul (↑r) (EDist.edist x y)))","decl":"/-- A dilation is a map that uniformly scales the edistance between any two points. -/\nstructure Dilation where\n  toFun : α → β\n  edist_eq' : ∃ r : ℝ≥0, r ≠ 0 ∧ ∀ x y : α, edist (toFun x) (toFun y) = r * edist x y\n\n"}
{"name":"Dilation.mk.sizeOf_spec","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : PseudoEMetricSpace α\ninst✝² : PseudoEMetricSpace β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoFun : α → β\nedist_eq' : Exists fun r => And (Ne r 0) (∀ (x y : α), Eq (EDist.edist (toFun x) (toFun y)) (HMul.hMul (↑r) (EDist.edist x y)))\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, edist_eq' := edist_eq' }) (HAdd.hAdd 1 (SizeOf.sizeOf edist_eq'))","decl":"/-- A dilation is a map that uniformly scales the edistance between any two points. -/\nstructure Dilation where\n  toFun : α → β\n  edist_eq' : ∃ r : ℝ≥0, r ≠ 0 ∧ ∀ x y : α, edist (toFun x) (toFun y) = r * edist x y\n\n"}
{"name":"Dilation.mk.inj","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\ntoFun✝ : α → β\nedist_eq'✝ : Exists fun r => And (Ne r 0) (∀ (x y : α), Eq (EDist.edist (toFun✝ x) (toFun✝ y)) (HMul.hMul (↑r) (EDist.edist x y)))\ntoFun : α → β\nedist_eq' : Exists fun r => And (Ne r 0) (∀ (x y : α), Eq (EDist.edist (toFun x) (toFun y)) (HMul.hMul (↑r) (EDist.edist x y)))\nx✝ : Eq { toFun := toFun✝, edist_eq' := edist_eq'✝ } { toFun := toFun, edist_eq' := edist_eq' }\n⊢ Eq toFun✝ toFun","decl":"/-- A dilation is a map that uniformly scales the edistance between any two points. -/\nstructure Dilation where\n  toFun : α → β\n  edist_eq' : ∃ r : ℝ≥0, r ≠ 0 ∧ ∀ x y : α, edist (toFun x) (toFun y) = r * edist x y\n\n"}
{"name":"DilationClass.edist_eq'","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"F : Type u_3\nα : outParam (Type u_4)\nβ : outParam (Type u_5)\ninst✝² : PseudoEMetricSpace α\ninst✝¹ : PseudoEMetricSpace β\ninst✝ : FunLike F α β\nself : DilationClass F α β\nf : F\n⊢ Exists fun r => And (Ne r 0) (∀ (x y : α), Eq (EDist.edist (f x) (f y)) (HMul.hMul (↑r) (EDist.edist x y)))","decl":"/-- `DilationClass F α β r` states that `F` is a type of `r`-dilations.\nYou should extend this typeclass when you extend `Dilation`. -/\nclass DilationClass (F : Type*) (α β : outParam Type*) [PseudoEMetricSpace α] [PseudoEMetricSpace β]\n    [FunLike F α β] : Prop where\n  edist_eq' : ∀ f : F, ∃ r : ℝ≥0, r ≠ 0 ∧ ∀ x y : α, edist (f x) (f y) = r * edist x y\n\n"}
{"name":"Dilation.toDilationClass","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\n⊢ DilationClass (Dilation α β) α β","decl":"instance toDilationClass : DilationClass (α →ᵈ β) α β where\n  edist_eq' f := edist_eq' f\n\n"}
{"name":"Dilation.toFun_eq_coe","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nf : Dilation α β\n⊢ Eq f.toFun ⇑f","decl":"@[simp]\ntheorem toFun_eq_coe {f : α →ᵈ β} : f.toFun = (f : α → β) :=\n  rfl\n\n"}
{"name":"Dilation.coe_mk","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nf : α → β\nh : Exists fun r => And (Ne r 0) (∀ (x y : α), Eq (EDist.edist (f x) (f y)) (HMul.hMul (↑r) (EDist.edist x y)))\n⊢ Eq (⇑{ toFun := f, edist_eq' := h }) f","decl":"@[simp]\ntheorem coe_mk (f : α → β) (h) : ⇑(⟨f, h⟩ : α →ᵈ β) = f :=\n  rfl\n\n"}
{"name":"Dilation.congr_fun","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nf g : Dilation α β\nh : Eq f g\nx : α\n⊢ Eq (f x) (g x)","decl":"protected theorem congr_fun {f g : α →ᵈ β} (h : f = g) (x : α) : f x = g x :=\n  DFunLike.congr_fun h x\n\n"}
{"name":"Dilation.congr_arg","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nf : Dilation α β\nx y : α\nh : Eq x y\n⊢ Eq (f x) (f y)","decl":"protected theorem congr_arg (f : α →ᵈ β) {x y : α} (h : x = y) : f x = f y :=\n  DFunLike.congr_arg f h\n\n"}
{"name":"Dilation.ext_iff","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nf g : Dilation α β\n⊢ Iff (Eq f g) (∀ (x : α), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext {f g : α →ᵈ β} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"Dilation.ext","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nf g : Dilation α β\nh : ∀ (x : α), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : α →ᵈ β} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"Dilation.mk_coe","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nf : Dilation α β\nh : Exists fun r => And (Ne r 0) (∀ (x y : α), Eq (EDist.edist (f x) (f y)) (HMul.hMul (↑r) (EDist.edist x y)))\n⊢ Eq { toFun := ⇑f, edist_eq' := h } f","decl":"@[simp]\ntheorem mk_coe (f : α →ᵈ β) (h) : Dilation.mk f h = f :=\n  ext fun _ => rfl\n\n"}
{"name":"Dilation.copy_toFun","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nf : Dilation α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"/-- Copy of a `Dilation` with a new `toFun` equal to the old one. Useful to fix definitional\nequalities. -/\n@[simps (config := .asFn)]\nprotected def copy (f : α →ᵈ β) (f' : α → β) (h : f' = ⇑f) : α →ᵈ β where\n  toFun := f'\n  edist_eq' := h.symm ▸ f.edist_eq'\n\n"}
{"name":"Dilation.copy_eq_self","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nf : Dilation α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) f","decl":"theorem copy_eq_self (f : α →ᵈ β) {f' : α → β} (h : f' = f) : f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"Dilation.ratio_of_trivial","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : PseudoEMetricSpace α\ninst✝² : PseudoEMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\nh : ∀ (x y : α), Or (Eq (EDist.edist x y) 0) (Eq (EDist.edist x y) Top.top)\n⊢ Eq (Dilation.ratio f) 1","decl":"theorem ratio_of_trivial [DilationClass F α β] (f : F)\n    (h : ∀ x y : α, edist x y = 0 ∨ edist x y = ∞) : ratio f = 1 :=\n  if_pos h\n\n"}
{"name":"Dilation.ratio_of_subsingleton","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝⁴ : PseudoEMetricSpace α\ninst✝³ : PseudoEMetricSpace β\ninst✝² : FunLike F α β\ninst✝¹ : Subsingleton α\ninst✝ : DilationClass F α β\nf : F\n⊢ Eq (Dilation.ratio f) 1","decl":"@[nontriviality]\ntheorem ratio_of_subsingleton [Subsingleton α] [DilationClass F α β] (f : F) : ratio f = 1 :=\n  if_pos fun x y ↦ by simp [Subsingleton.elim x y]\n\n"}
{"name":"Dilation.ratio_ne_zero","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : PseudoEMetricSpace α\ninst✝² : PseudoEMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\n⊢ Ne (Dilation.ratio f) 0","decl":"theorem ratio_ne_zero [DilationClass F α β] (f : F) : ratio f ≠ 0 := by\n  rw [ratio]; split_ifs\n  · exact one_ne_zero\n  exact (DilationClass.edist_eq' f).choose_spec.1\n\n"}
{"name":"Dilation.ratio_pos","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : PseudoEMetricSpace α\ninst✝² : PseudoEMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\n⊢ LT.lt 0 (Dilation.ratio f)","decl":"theorem ratio_pos [DilationClass F α β] (f : F) : 0 < ratio f :=\n  (ratio_ne_zero f).bot_lt\n\n"}
{"name":"Dilation.edist_eq","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : PseudoEMetricSpace α\ninst✝² : PseudoEMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\nx y : α\n⊢ Eq (EDist.edist (f x) (f y)) (HMul.hMul (↑(Dilation.ratio f)) (EDist.edist x y))","decl":"@[simp]\ntheorem edist_eq [DilationClass F α β] (f : F) (x y : α) :\n    edist (f x) (f y) = ratio f * edist x y := by\n  rw [ratio]; split_ifs with key\n  · rcases DilationClass.edist_eq' f with ⟨r, hne, hr⟩\n    replace hr := hr x y\n    cases' key x y with h h\n    · simp only [hr, h, mul_zero]\n    · simp [hr, h, hne]\n  exact (DilationClass.edist_eq' f).choose_spec.2 x y\n\n"}
{"name":"Dilation.nndist_eq","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_5\nβ : Type u_6\nF : Type u_7\ninst✝³ : PseudoMetricSpace α\ninst✝² : PseudoMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\nx y : α\n⊢ Eq (NNDist.nndist (f x) (f y)) (HMul.hMul (Dilation.ratio f) (NNDist.nndist x y))","decl":"@[simp]\ntheorem nndist_eq {α β F : Type*} [PseudoMetricSpace α] [PseudoMetricSpace β] [FunLike F α β]\n    [DilationClass F α β] (f : F) (x y : α) :\n    nndist (f x) (f y) = ratio f * nndist x y := by\n  simp only [← ENNReal.coe_inj, ← edist_nndist, ENNReal.coe_mul, edist_eq]\n\n"}
{"name":"Dilation.dist_eq","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_5\nβ : Type u_6\nF : Type u_7\ninst✝³ : PseudoMetricSpace α\ninst✝² : PseudoMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\nx y : α\n⊢ Eq (Dist.dist (f x) (f y)) (HMul.hMul (↑(Dilation.ratio f)) (Dist.dist x y))","decl":"@[simp]\ntheorem dist_eq {α β F : Type*} [PseudoMetricSpace α] [PseudoMetricSpace β] [FunLike F α β]\n    [DilationClass F α β] (f : F) (x y : α) :\n    dist (f x) (f y) = ratio f * dist x y := by\n  simp only [dist_nndist, nndist_eq, NNReal.coe_mul]\n\n"}
{"name":"Dilation.ratio_unique","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : PseudoEMetricSpace α\ninst✝² : PseudoEMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\nx y : α\nr : NNReal\nh₀ : Ne (EDist.edist x y) 0\nhtop : Ne (EDist.edist x y) Top.top\nhr : Eq (EDist.edist (f x) (f y)) (HMul.hMul (↑r) (EDist.edist x y))\n⊢ Eq r (Dilation.ratio f)","decl":"/-- The `ratio` is equal to the distance ratio for any two points with nonzero finite distance.\n`dist` and `nndist` versions below -/\ntheorem ratio_unique [DilationClass F α β] {f : F} {x y : α} {r : ℝ≥0} (h₀ : edist x y ≠ 0)\n    (htop : edist x y ≠ ⊤) (hr : edist (f x) (f y) = r * edist x y) : r = ratio f := by\n  simpa only [hr, ENNReal.mul_left_inj h₀ htop, ENNReal.coe_inj] using edist_eq f x y\n\n"}
{"name":"Dilation.ratio_unique_of_nndist_ne_zero","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_5\nβ : Type u_6\nF : Type u_7\ninst✝³ : PseudoMetricSpace α\ninst✝² : PseudoMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\nx y : α\nr : NNReal\nhxy : Ne (NNDist.nndist x y) 0\nhr : Eq (NNDist.nndist (f x) (f y)) (HMul.hMul r (NNDist.nndist x y))\n⊢ Eq r (Dilation.ratio f)","decl":"/-- The `ratio` is equal to the distance ratio for any two points\nwith nonzero finite distance; `nndist` version -/\ntheorem ratio_unique_of_nndist_ne_zero {α β F : Type*} [PseudoMetricSpace α] [PseudoMetricSpace β]\n    [FunLike F α β] [DilationClass F α β] {f : F} {x y : α} {r : ℝ≥0} (hxy : nndist x y ≠ 0)\n    (hr : nndist (f x) (f y) = r * nndist x y) : r = ratio f :=\n  ratio_unique (by rwa [edist_nndist, ENNReal.coe_ne_zero]) (edist_ne_top x y)\n    (by rw [edist_nndist, edist_nndist, hr, ENNReal.coe_mul])\n\n"}
{"name":"Dilation.ratio_unique_of_dist_ne_zero","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_6\nβ : Type u_7\nF : Type u_5\ninst✝³ : PseudoMetricSpace α\ninst✝² : PseudoMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\nx y : α\nr : NNReal\nhxy : Ne (Dist.dist x y) 0\nhr : Eq (Dist.dist (f x) (f y)) (HMul.hMul (↑r) (Dist.dist x y))\n⊢ Eq r (Dilation.ratio f)","decl":"/-- The `ratio` is equal to the distance ratio for any two points\nwith nonzero finite distance; `dist` version -/\ntheorem ratio_unique_of_dist_ne_zero {α β} {F : Type*} [PseudoMetricSpace α] [PseudoMetricSpace β]\n    [FunLike F α β] [DilationClass F α β] {f : F} {x y : α} {r : ℝ≥0} (hxy : dist x y ≠ 0)\n    (hr : dist (f x) (f y) = r * dist x y) : r = ratio f :=\n  ratio_unique_of_nndist_ne_zero (NNReal.coe_ne_zero.1 hxy) <|\n    NNReal.eq <| by rw [coe_nndist, hr, NNReal.coe_mul, coe_nndist]\n\n"}
{"name":"Dilation.coe_mkOfNNDistEq","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nf : α → β\nh : Exists fun r => And (Ne r 0) (∀ (x y : α), Eq (NNDist.nndist (f x) (f y)) (HMul.hMul r (NNDist.nndist x y)))\n⊢ Eq (⇑(Dilation.mkOfNNDistEq f h)) f","decl":"@[simp]\ntheorem coe_mkOfNNDistEq {α β} [PseudoMetricSpace α] [PseudoMetricSpace β] (f : α → β) (h) :\n    ⇑(mkOfNNDistEq f h : α →ᵈ β) = f :=\n  rfl\n\n"}
{"name":"Dilation.mk_coe_of_nndist_eq","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nf : Dilation α β\nh : Exists fun r => And (Ne r 0) (∀ (x y : α), Eq (NNDist.nndist (f x) (f y)) (HMul.hMul r (NNDist.nndist x y)))\n⊢ Eq (Dilation.mkOfNNDistEq (⇑f) h) f","decl":"@[simp]\ntheorem mk_coe_of_nndist_eq {α β} [PseudoMetricSpace α] [PseudoMetricSpace β] (f : α →ᵈ β)\n    (h) : Dilation.mkOfNNDistEq f h = f :=\n  ext fun _ => rfl\n\n"}
{"name":"Dilation.coe_mkOfDistEq","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nf : α → β\nh : Exists fun r => And (Ne r 0) (∀ (x y : α), Eq (Dist.dist (f x) (f y)) (HMul.hMul (↑r) (Dist.dist x y)))\n⊢ Eq (⇑(Dilation.mkOfDistEq f h)) f","decl":"@[simp]\ntheorem coe_mkOfDistEq {α β} [PseudoMetricSpace α] [PseudoMetricSpace β] (f : α → β) (h) :\n    ⇑(mkOfDistEq f h : α →ᵈ β) = f :=\n  rfl\n\n"}
{"name":"Dilation.mk_coe_of_dist_eq","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nf : Dilation α β\nh : Exists fun r => And (Ne r 0) (∀ (x y : α), Eq (Dist.dist (f x) (f y)) (HMul.hMul (↑r) (Dist.dist x y)))\n⊢ Eq (Dilation.mkOfDistEq (⇑f) h) f","decl":"@[simp]\ntheorem mk_coe_of_dist_eq {α β} [PseudoMetricSpace α] [PseudoMetricSpace β] (f : α →ᵈ β) (h) :\n    Dilation.mkOfDistEq f h = f :=\n  ext fun _ => rfl\n\n"}
{"name":"Isometry.toDilation_toFun","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nf : α → β\nhf : Isometry f\na✝ : α\n⊢ Eq ((Isometry.toDilation f hf) a✝) (f a✝)","decl":"/-- Every isometry is a dilation of ratio `1`. -/\n@[simps]\ndef _root_.Isometry.toDilation (f : α → β) (hf : Isometry f) : α →ᵈ β where\n  toFun := f\n  edist_eq' := ⟨1, one_ne_zero, by simpa using hf⟩\n\n"}
{"name":"Isometry.toDilation_ratio","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nf : α → β\nhf : Isometry f\n⊢ Eq (Dilation.ratio (Isometry.toDilation f hf)) 1","decl":"@[simp]\nlemma _root_.Isometry.toDilation_ratio {f : α → β} {hf : Isometry f} : ratio hf.toDilation = 1 := by\n  by_cases h : ∀ x y : α, edist x y = 0 ∨ edist x y = ⊤\n  · exact ratio_of_trivial hf.toDilation h\n  · push_neg at h\n    obtain ⟨x, y, h₁, h₂⟩ := h\n    exact ratio_unique h₁ h₂ (by simp [hf x y]) |>.symm\n\n"}
{"name":"Dilation.lipschitz","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : PseudoEMetricSpace α\ninst✝² : PseudoEMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\n⊢ LipschitzWith (Dilation.ratio f) ⇑f","decl":"theorem lipschitz : LipschitzWith (ratio f) (f : α → β) := fun x y => (edist_eq f x y).le\n\n"}
{"name":"Dilation.antilipschitz","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : PseudoEMetricSpace α\ninst✝² : PseudoEMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\n⊢ AntilipschitzWith (Inv.inv (Dilation.ratio f)) ⇑f","decl":"theorem antilipschitz : AntilipschitzWith (ratio f)⁻¹ (f : α → β) := fun x y => by\n  have hr : ratio f ≠ 0 := ratio_ne_zero f\n  exact mod_cast\n    (ENNReal.mul_le_iff_le_inv (ENNReal.coe_ne_zero.2 hr) ENNReal.coe_ne_top).1 (edist_eq f x y).ge\n\n"}
{"name":"Dilation.injective","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"β : Type u_2\nF : Type u_4\ninst✝³ : PseudoEMetricSpace β\nα : Type u_5\ninst✝² : EMetricSpace α\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\n⊢ Function.Injective ⇑f","decl":"/-- A dilation from an emetric space is injective -/\nprotected theorem injective {α : Type*} [EMetricSpace α] [FunLike F α β]  [DilationClass F α β]\n    (f : F) :\n    Injective f :=\n  (antilipschitz f).injective\n\n"}
{"name":"Dilation.coe_id","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\n⊢ Eq (⇑(Dilation.id α)) id","decl":"@[simp]\nprotected theorem coe_id : ⇑(Dilation.id α) = id :=\n  rfl\n\n"}
{"name":"Dilation.ratio_id","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\n⊢ Eq (Dilation.ratio (Dilation.id α)) 1","decl":"theorem ratio_id : ratio (Dilation.id α) = 1 := by\n  by_cases h : ∀ x y : α, edist x y = 0 ∨ edist x y = ∞\n  · rw [ratio, if_pos h]\n  · push_neg at h\n    rcases h with ⟨x, y, hne⟩\n    refine (ratio_unique hne.1 hne.2 ?_).symm\n    simp\n\n"}
{"name":"Dilation.comp_assoc","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : PseudoEMetricSpace α\ninst✝² : PseudoEMetricSpace β\ninst✝¹ : PseudoEMetricSpace γ\nδ : Type u_5\ninst✝ : PseudoEMetricSpace δ\nf : Dilation α β\ng : Dilation β γ\nh : Dilation γ δ\n⊢ Eq ((h.comp g).comp f) (h.comp (g.comp f))","decl":"theorem comp_assoc {δ : Type*} [PseudoEMetricSpace δ] (f : α →ᵈ β) (g : β →ᵈ γ)\n    (h : γ →ᵈ δ) : (h.comp g).comp f = h.comp (g.comp f) :=\n  rfl\n\n"}
{"name":"Dilation.coe_comp","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : PseudoEMetricSpace α\ninst✝¹ : PseudoEMetricSpace β\ninst✝ : PseudoEMetricSpace γ\ng : Dilation β γ\nf : Dilation α β\n⊢ Eq (⇑(g.comp f)) (Function.comp ⇑g ⇑f)","decl":"@[simp]\ntheorem coe_comp (g : β →ᵈ γ) (f : α →ᵈ β) : (g.comp f : α → γ) = g ∘ f :=\n  rfl\n\n"}
{"name":"Dilation.comp_apply","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : PseudoEMetricSpace α\ninst✝¹ : PseudoEMetricSpace β\ninst✝ : PseudoEMetricSpace γ\ng : Dilation β γ\nf : Dilation α β\nx : α\n⊢ Eq ((g.comp f) x) (g (f x))","decl":"theorem comp_apply (g : β →ᵈ γ) (f : α →ᵈ β) (x : α) : (g.comp f : α → γ) x = g (f x) :=\n  rfl\n\n"}
{"name":"Dilation.ratio_comp'","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : PseudoEMetricSpace α\ninst✝¹ : PseudoEMetricSpace β\ninst✝ : PseudoEMetricSpace γ\ng : Dilation β γ\nf : Dilation α β\nhne : Exists fun x => Exists fun y => And (Ne (EDist.edist x y) 0) (Ne (EDist.edist x y) Top.top)\n⊢ Eq (Dilation.ratio (g.comp f)) (HMul.hMul (Dilation.ratio g) (Dilation.ratio f))","decl":"/-- Ratio of the composition `g.comp f` of two dilations is the product of their ratios. We assume\nthat there exist two points in `α` at extended distance neither `0` nor `∞` because otherwise\n`Dilation.ratio (g.comp f) = Dilation.ratio f = 1` while `Dilation.ratio g` can be any number. This\nversion works for most general spaces, see also `Dilation.ratio_comp` for a version assuming that\n`α` is a nontrivial metric space. -/\ntheorem ratio_comp' {g : β →ᵈ γ} {f : α →ᵈ β}\n    (hne : ∃ x y : α, edist x y ≠ 0 ∧ edist x y ≠ ⊤) : ratio (g.comp f) = ratio g * ratio f := by\n  rcases hne with ⟨x, y, hα⟩\n  have hgf := (edist_eq (g.comp f) x y).symm\n  simp_rw [coe_comp, Function.comp, edist_eq, ← mul_assoc, ENNReal.mul_left_inj hα.1 hα.2]\n    at hgf\n  rwa [← ENNReal.coe_inj, ENNReal.coe_mul]\n\n"}
{"name":"Dilation.comp_id","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nf : Dilation α β\n⊢ Eq (f.comp (Dilation.id α)) f","decl":"@[simp]\ntheorem comp_id (f : α →ᵈ β) : f.comp (Dilation.id α) = f :=\n  ext fun _ => rfl\n\n"}
{"name":"Dilation.id_comp","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nf : Dilation α β\n⊢ Eq ((Dilation.id β).comp f) f","decl":"@[simp]\ntheorem id_comp (f : α →ᵈ β) : (Dilation.id β).comp f = f :=\n  ext fun _ => rfl\n\n"}
{"name":"Dilation.one_def","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\n⊢ Eq 1 (Dilation.id α)","decl":"theorem one_def : (1 : α →ᵈ α) = Dilation.id α :=\n  rfl\n\n"}
{"name":"Dilation.mul_def","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\nf g : Dilation α α\n⊢ Eq (HMul.hMul f g) (f.comp g)","decl":"theorem mul_def (f g : α →ᵈ α) : f * g = f.comp g :=\n  rfl\n\n"}
{"name":"Dilation.coe_one","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\n⊢ Eq (⇑1) id","decl":"@[simp]\ntheorem coe_one : ⇑(1 : α →ᵈ α) = id :=\n  rfl\n\n"}
{"name":"Dilation.coe_mul","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\nf g : Dilation α α\n⊢ Eq (⇑(HMul.hMul f g)) (Function.comp ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_mul (f g : α →ᵈ α) : ⇑(f * g) = f ∘ g :=\n  rfl\n\n"}
{"name":"Dilation.ratio_one","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\n⊢ Eq (Dilation.ratio 1) 1","decl":"@[simp] theorem ratio_one : ratio (1 : α →ᵈ α) = 1 := ratio_id\n\n"}
{"name":"Dilation.ratio_mul","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\nf g : Dilation α α\n⊢ Eq (Dilation.ratio (HMul.hMul f g)) (HMul.hMul (Dilation.ratio f) (Dilation.ratio g))","decl":"@[simp]\ntheorem ratio_mul (f g : α →ᵈ α) : ratio (f * g) = ratio f * ratio g := by\n  by_cases h : ∀ x y : α, edist x y = 0 ∨ edist x y = ∞\n  · simp [ratio_of_trivial, h]\n  push_neg at h\n  exact ratio_comp' h\n\n"}
{"name":"Dilation.ratioHom_apply","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\nf : Dilation α α\n⊢ Eq (Dilation.ratioHom f) (Dilation.ratio f)","decl":"/-- `Dilation.ratio` as a monoid homomorphism from `α →ᵈ α` to `ℝ≥0`. -/\n@[simps]\ndef ratioHom : (α →ᵈ α) →* ℝ≥0 := ⟨⟨ratio, ratio_one⟩, ratio_mul⟩\n\n"}
{"name":"Dilation.ratio_pow","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\nf : Dilation α α\nn : Nat\n⊢ Eq (Dilation.ratio (HPow.hPow f n)) (HPow.hPow (Dilation.ratio f) n)","decl":"@[simp]\ntheorem ratio_pow (f : α →ᵈ α) (n : ℕ) : ratio (f ^ n) = ratio f ^ n :=\n  ratioHom.map_pow _ _\n\n"}
{"name":"Dilation.cancel_right","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : PseudoEMetricSpace α\ninst✝¹ : PseudoEMetricSpace β\ninst✝ : PseudoEMetricSpace γ\ng₁ g₂ : Dilation β γ\nf : Dilation α β\nhf : Function.Surjective ⇑f\n⊢ Iff (Eq (g₁.comp f) (g₂.comp f)) (Eq g₁ g₂)","decl":"@[simp]\ntheorem cancel_right {g₁ g₂ : β →ᵈ γ} {f : α →ᵈ β} (hf : Surjective f) :\n    g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=\n  ⟨fun h => Dilation.ext <| hf.forall.2 (Dilation.ext_iff.1 h), fun h => h ▸ rfl⟩\n\n"}
{"name":"Dilation.cancel_left","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : PseudoEMetricSpace α\ninst✝¹ : PseudoEMetricSpace β\ninst✝ : PseudoEMetricSpace γ\ng : Dilation β γ\nf₁ f₂ : Dilation α β\nhg : Function.Injective ⇑g\n⊢ Iff (Eq (g.comp f₁) (g.comp f₂)) (Eq f₁ f₂)","decl":"@[simp]\ntheorem cancel_left {g : β →ᵈ γ} {f₁ f₂ : α →ᵈ β} (hg : Injective g) :\n    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=\n  ⟨fun h => Dilation.ext fun x => hg <| by rw [← comp_apply, h, comp_apply], fun h => h ▸ rfl⟩\n\n"}
{"name":"Dilation.isUniformInducing","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : PseudoEMetricSpace α\ninst✝² : PseudoEMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\n⊢ IsUniformInducing ⇑f","decl":"/-- A dilation from a metric space is a uniform inducing map -/\ntheorem isUniformInducing : IsUniformInducing (f : α → β) :=\n  (antilipschitz f).isUniformInducing (lipschitz f).uniformContinuous\n\n"}
{"name":"Dilation.uniformInducing","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : PseudoEMetricSpace α\ninst✝² : PseudoEMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\n⊢ IsUniformInducing ⇑f","decl":"@[deprecated (since := \"2024-10-05\")]\nalias uniformInducing := isUniformInducing\n\n"}
{"name":"Dilation.tendsto_nhds_iff","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : PseudoEMetricSpace α\ninst✝² : PseudoEMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\nι : Type u_5\ng : ι → α\na : Filter ι\nb : α\n⊢ Iff (Filter.Tendsto g a (nhds b)) (Filter.Tendsto (Function.comp (⇑f) g) a (nhds (f b)))","decl":"theorem tendsto_nhds_iff {ι : Type*} {g : ι → α} {a : Filter ι} {b : α} :\n    Filter.Tendsto g a (𝓝 b) ↔ Filter.Tendsto ((f : α → β) ∘ g) a (𝓝 (f b)) :=\n  (Dilation.isUniformInducing f).isInducing.tendsto_nhds_iff\n\n"}
{"name":"Dilation.toContinuous","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : PseudoEMetricSpace α\ninst✝² : PseudoEMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\n⊢ Continuous ⇑f","decl":"/-- A dilation is continuous. -/\ntheorem toContinuous : Continuous (f : α → β) :=\n  (lipschitz f).continuous\n\n"}
{"name":"Dilation.ediam_image","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : PseudoEMetricSpace α\ninst✝² : PseudoEMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\ns : Set α\n⊢ Eq (EMetric.diam (Set.image (⇑f) s)) (HMul.hMul (↑(Dilation.ratio f)) (EMetric.diam s))","decl":"/-- Dilations scale the diameter by `ratio f` in pseudoemetric spaces. -/\ntheorem ediam_image (s : Set α) : EMetric.diam ((f : α → β) '' s) = ratio f * EMetric.diam s := by\n  refine ((lipschitz f).ediam_image_le s).antisymm ?_\n  apply ENNReal.mul_le_of_le_div'\n  rw [div_eq_mul_inv, mul_comm, ← ENNReal.coe_inv]\n  exacts [(antilipschitz f).le_mul_ediam_image s, ratio_ne_zero f]\n\n"}
{"name":"Dilation.ediam_range","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : PseudoEMetricSpace α\ninst✝² : PseudoEMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\n⊢ Eq (EMetric.diam (Set.range ⇑f)) (HMul.hMul (↑(Dilation.ratio f)) (EMetric.diam Set.univ))","decl":"/-- A dilation scales the diameter of the range by `ratio f`. -/\ntheorem ediam_range : EMetric.diam (range (f : α → β)) = ratio f * EMetric.diam (univ : Set α) := by\n  rw [← image_univ]; exact ediam_image f univ\n\n"}
{"name":"Dilation.mapsTo_emetric_ball","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : PseudoEMetricSpace α\ninst✝² : PseudoEMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\nx : α\nr : ENNReal\n⊢ Set.MapsTo (⇑f) (EMetric.ball x r) (EMetric.ball (f x) (HMul.hMul (↑(Dilation.ratio f)) r))","decl":"/-- A dilation maps balls to balls and scales the radius by `ratio f`. -/\ntheorem mapsTo_emetric_ball (x : α) (r : ℝ≥0∞) :\n    MapsTo (f : α → β) (EMetric.ball x r) (EMetric.ball (f x) (ratio f * r)) :=\n  fun y hy => (edist_eq f y x).trans_lt <|\n    (ENNReal.mul_lt_mul_left (ENNReal.coe_ne_zero.2 <| ratio_ne_zero f) ENNReal.coe_ne_top).2 hy\n\n"}
{"name":"Dilation.mapsTo_emetric_closedBall","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : PseudoEMetricSpace α\ninst✝² : PseudoEMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\nx : α\nr' : ENNReal\n⊢ Set.MapsTo (⇑f) (EMetric.closedBall x r') (EMetric.closedBall (f x) (HMul.hMul (↑(Dilation.ratio f)) r'))","decl":"/-- A dilation maps closed balls to closed balls and scales the radius by `ratio f`. -/\ntheorem mapsTo_emetric_closedBall (x : α) (r' : ℝ≥0∞) :\n    MapsTo (f : α → β) (EMetric.closedBall x r') (EMetric.closedBall (f x) (ratio f * r')) :=\n  -- Porting note: Added `by exact`\n  fun y hy => (edist_eq f y x).trans_le <| mul_le_mul_left' (by exact hy) _\n\n"}
{"name":"Dilation.comp_continuousOn_iff","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝⁴ : PseudoEMetricSpace α\ninst✝³ : PseudoEMetricSpace β\ninst✝² : FunLike F α β\ninst✝¹ : DilationClass F α β\nf : F\nγ : Type u_5\ninst✝ : TopologicalSpace γ\ng : γ → α\ns : Set γ\n⊢ Iff (ContinuousOn (Function.comp (⇑f) g) s) (ContinuousOn g s)","decl":"theorem comp_continuousOn_iff {γ} [TopologicalSpace γ] {g : γ → α} {s : Set γ} :\n    ContinuousOn ((f : α → β) ∘ g) s ↔ ContinuousOn g s :=\n  (Dilation.isUniformInducing f).isInducing.continuousOn_iff.symm\n\n"}
{"name":"Dilation.comp_continuous_iff","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝⁴ : PseudoEMetricSpace α\ninst✝³ : PseudoEMetricSpace β\ninst✝² : FunLike F α β\ninst✝¹ : DilationClass F α β\nf : F\nγ : Type u_5\ninst✝ : TopologicalSpace γ\ng : γ → α\n⊢ Iff (Continuous (Function.comp (⇑f) g)) (Continuous g)","decl":"theorem comp_continuous_iff {γ} [TopologicalSpace γ] {g : γ → α} :\n    Continuous ((f : α → β) ∘ g) ↔ Continuous g :=\n  (Dilation.isUniformInducing f).isInducing.continuous_iff.symm\n\n"}
{"name":"Dilation.isUniformEmbedding","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : EMetricSpace α\ninst✝² : FunLike F α β\ninst✝¹ : PseudoEMetricSpace β\ninst✝ : DilationClass F α β\nf : F\n⊢ IsUniformEmbedding ⇑f","decl":"/-- A dilation from a metric space is a uniform embedding -/\nlemma isUniformEmbedding [PseudoEMetricSpace β] [DilationClass F α β] (f : F) :\n    IsUniformEmbedding f :=\n  (antilipschitz f).isUniformEmbedding (lipschitz f).uniformContinuous\n\n"}
{"name":"Dilation.uniformEmbedding","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : EMetricSpace α\ninst✝² : FunLike F α β\ninst✝¹ : PseudoEMetricSpace β\ninst✝ : DilationClass F α β\nf : F\n⊢ IsUniformEmbedding ⇑f","decl":"@[deprecated (since := \"2024-10-01\")] alias uniformEmbedding := isUniformEmbedding\n\n"}
{"name":"Dilation.isEmbedding","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : EMetricSpace α\ninst✝² : FunLike F α β\ninst✝¹ : PseudoEMetricSpace β\ninst✝ : DilationClass F α β\nf : F\n⊢ Topology.IsEmbedding ⇑f","decl":"/-- A dilation from a metric space is an embedding -/\ntheorem isEmbedding [PseudoEMetricSpace β] [DilationClass F α β] (f : F) :\n    IsEmbedding (f : α → β) :=\n  (Dilation.isUniformEmbedding f).isEmbedding\n\n"}
{"name":"Dilation.embedding","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : EMetricSpace α\ninst✝² : FunLike F α β\ninst✝¹ : PseudoEMetricSpace β\ninst✝ : DilationClass F α β\nf : F\n⊢ Topology.IsEmbedding ⇑f","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding := isEmbedding\n\n"}
{"name":"Dilation.isClosedEmbedding","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝⁴ : EMetricSpace α\ninst✝³ : FunLike F α β\ninst✝² : CompleteSpace α\ninst✝¹ : EMetricSpace β\ninst✝ : DilationClass F α β\nf : F\n⊢ Topology.IsClosedEmbedding ⇑f","decl":"/-- A dilation from a complete emetric space is a closed embedding -/\nlemma isClosedEmbedding [CompleteSpace α] [EMetricSpace β] [DilationClass F α β] (f : F) :\n    IsClosedEmbedding f :=\n  (antilipschitz f).isClosedEmbedding (lipschitz f).uniformContinuous\n\n"}
{"name":"Dilation.closedEmbedding","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝⁴ : EMetricSpace α\ninst✝³ : FunLike F α β\ninst✝² : CompleteSpace α\ninst✝¹ : EMetricSpace β\ninst✝ : DilationClass F α β\nf : F\n⊢ Topology.IsClosedEmbedding ⇑f","decl":"@[deprecated (since := \"2024-10-20\")] alias closedEmbedding := isClosedEmbedding\n\n"}
{"name":"Dilation.ratio_comp","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : MetricSpace α\ninst✝² : Nontrivial α\ninst✝¹ : PseudoEMetricSpace β\ninst✝ : PseudoEMetricSpace γ\ng : Dilation β γ\nf : Dilation α β\n⊢ Eq (Dilation.ratio (g.comp f)) (HMul.hMul (Dilation.ratio g) (Dilation.ratio f))","decl":"/-- Ratio of the composition `g.comp f` of two dilations is the product of their ratios. We assume\nthat the domain `α` of `f` is a nontrivial metric space, otherwise\n`Dilation.ratio f = Dilation.ratio (g.comp f) = 1` but `Dilation.ratio g` may have any value.\n\nSee also `Dilation.ratio_comp'` for a version that works for more general spaces. -/\n@[simp]\ntheorem ratio_comp [MetricSpace α] [Nontrivial α] [PseudoEMetricSpace β]\n    [PseudoEMetricSpace γ] {g : β →ᵈ γ} {f : α →ᵈ β} : ratio (g.comp f) = ratio g * ratio f :=\n  ratio_comp' <|\n    let ⟨x, y, hne⟩ := exists_pair_ne α; ⟨x, y, mt edist_eq_zero.1 hne, edist_ne_top _ _⟩\n\n"}
{"name":"Dilation.diam_image","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : PseudoMetricSpace α\ninst✝² : PseudoMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\ns : Set α\n⊢ Eq (Metric.diam (Set.image (⇑f) s)) (HMul.hMul (↑(Dilation.ratio f)) (Metric.diam s))","decl":"/-- A dilation scales the diameter by `ratio f` in pseudometric spaces. -/\ntheorem diam_image (s : Set α) : Metric.diam ((f : α → β) '' s) = ratio f * Metric.diam s := by\n  simp [Metric.diam, ediam_image, ENNReal.toReal_mul]\n\n"}
{"name":"Dilation.diam_range","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : PseudoMetricSpace α\ninst✝² : PseudoMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\n⊢ Eq (Metric.diam (Set.range ⇑f)) (HMul.hMul (↑(Dilation.ratio f)) (Metric.diam Set.univ))","decl":"theorem diam_range : Metric.diam (range (f : α → β)) = ratio f * Metric.diam (univ : Set α) := by\n  rw [← image_univ, diam_image]\n\n"}
{"name":"Dilation.mapsTo_ball","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : PseudoMetricSpace α\ninst✝² : PseudoMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\nx : α\nr' : Real\n⊢ Set.MapsTo (⇑f) (Metric.ball x r') (Metric.ball (f x) (HMul.hMul (↑(Dilation.ratio f)) r'))","decl":"/-- A dilation maps balls to balls and scales the radius by `ratio f`. -/\ntheorem mapsTo_ball (x : α) (r' : ℝ) :\n    MapsTo (f : α → β) (Metric.ball x r') (Metric.ball (f x) (ratio f * r')) :=\n  fun y hy => (dist_eq f y x).trans_lt <| (mul_lt_mul_left <| NNReal.coe_pos.2 <| ratio_pos f).2 hy\n\n"}
{"name":"Dilation.mapsTo_sphere","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : PseudoMetricSpace α\ninst✝² : PseudoMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\nx : α\nr' : Real\n⊢ Set.MapsTo (⇑f) (Metric.sphere x r') (Metric.sphere (f x) (HMul.hMul (↑(Dilation.ratio f)) r'))","decl":"/-- A dilation maps spheres to spheres and scales the radius by `ratio f`. -/\ntheorem mapsTo_sphere (x : α) (r' : ℝ) :\n    MapsTo (f : α → β) (Metric.sphere x r') (Metric.sphere (f x) (ratio f * r')) :=\n  fun y hy => Metric.mem_sphere.mp hy ▸ dist_eq f y x\n\n"}
{"name":"Dilation.mapsTo_closedBall","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : PseudoMetricSpace α\ninst✝² : PseudoMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\nx : α\nr' : Real\n⊢ Set.MapsTo (⇑f) (Metric.closedBall x r') (Metric.closedBall (f x) (HMul.hMul (↑(Dilation.ratio f)) r'))","decl":"/-- A dilation maps closed balls to closed balls and scales the radius by `ratio f`. -/\ntheorem mapsTo_closedBall (x : α) (r' : ℝ) :\n    MapsTo (f : α → β) (Metric.closedBall x r') (Metric.closedBall (f x) (ratio f * r')) :=\n  fun y hy => (dist_eq f y x).trans_le <| mul_le_mul_of_nonneg_left hy (NNReal.coe_nonneg _)\n\n"}
{"name":"Dilation.tendsto_cobounded","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : PseudoMetricSpace α\ninst✝² : PseudoMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\n⊢ Filter.Tendsto (⇑f) (Bornology.cobounded α) (Bornology.cobounded β)","decl":"lemma tendsto_cobounded : Filter.Tendsto f (cobounded α) (cobounded β) :=\n  (Dilation.antilipschitz f).tendsto_cobounded\n\n"}
{"name":"Dilation.comap_cobounded","module":"Mathlib.Topology.MetricSpace.Dilation","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Type u_4\ninst✝³ : PseudoMetricSpace α\ninst✝² : PseudoMetricSpace β\ninst✝¹ : FunLike F α β\ninst✝ : DilationClass F α β\nf : F\n⊢ Eq (Filter.comap (⇑f) (Bornology.cobounded β)) (Bornology.cobounded α)","decl":"@[simp]\nlemma comap_cobounded : Filter.comap f (cobounded β) = cobounded α :=\n  le_antisymm (lipschitz f).comap_cobounded_le (tendsto_cobounded f).le_comap\n\n"}
