{"name":"LinearMap.bound_of_shell","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : LinearMap Ïƒâ‚â‚‚ E F\nÎµ C : Real\nÎµ_pos : LT.lt 0 Îµ\nc : ğ•œ\nhc : LT.lt 1 (Norm.norm c)\nhf : âˆ€ (x : E), LE.le (HDiv.hDiv Îµ (Norm.norm c)) (Norm.norm x) â†’ LT.lt (Norm.norm x) Îµ â†’ LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\nx : E\nâŠ¢ LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))","decl":"theorem bound_of_shell [RingHomIsometric Ïƒâ‚â‚‚] (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) {Îµ C : â„} (Îµ_pos : 0 < Îµ) {c : ğ•œ}\n    (hc : 1 < â€–câ€–) (hf : âˆ€ x, Îµ / â€–câ€– â‰¤ â€–xâ€– â†’ â€–xâ€– < Îµ â†’ â€–f xâ€– â‰¤ C * â€–xâ€–) (x : E) :\n    â€–f xâ€– â‰¤ C * â€–xâ€– := by\n  by_cases hx : x = 0; Â· simp [hx]\n  exact SemilinearMapClass.bound_of_shell_semi_normed f Îµ_pos hc hf (norm_ne_zero_iff.2 hx)\n\n"}
{"name":"LinearMap.bound_of_ball_bound","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nFâ‚— : Type u_6\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedAddCommGroup Fâ‚—\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œ Fâ‚—\nr : Real\nr_pos : LT.lt 0 r\nc : Real\nf : LinearMap (RingHom.id ğ•œ) E Fâ‚—\nh : âˆ€ (z : E), Membership.mem (Metric.ball 0 r) z â†’ LE.le (Norm.norm (f z)) c\nâŠ¢ Exists fun C => âˆ€ (z : E), LE.le (Norm.norm (f z)) (HMul.hMul C (Norm.norm z))","decl":"/-- `LinearMap.bound_of_ball_bound'` is a version of this lemma over a field satisfying `RCLike`\nthat produces a concrete bound.\n-/\ntheorem bound_of_ball_bound {r : â„} (r_pos : 0 < r) (c : â„) (f : E â†’â‚—[ğ•œ] Fâ‚—)\n    (h : âˆ€ z âˆˆ Metric.ball (0 : E) r, â€–f zâ€– â‰¤ c) : âˆƒ C, âˆ€ z : E, â€–f zâ€– â‰¤ C * â€–zâ€– := by\n  cases' @NontriviallyNormedField.non_trivial ğ•œ _ with k hk\n  use c * (â€–kâ€– / r)\n  intro z\n  refine bound_of_shell _ r_pos hk (fun x hko hxo => ?_) _\n  calc\n    â€–f xâ€– â‰¤ c := h _ (mem_ball_zero_iff.mpr hxo)\n    _ â‰¤ c * (â€–xâ€– * â€–kâ€– / r) := le_mul_of_one_le_right ?_ ?_\n    _ = _ := by ring\n  Â· exact le_trans (norm_nonneg _) (h 0 (by simp [r_pos]))\n  Â· rw [div_le_iffâ‚€ (zero_lt_one.trans hk)] at hko\n    exact (one_le_div r_pos).mpr hko\n\n"}
{"name":"LinearMap.antilipschitz_of_comap_nhds_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nh : RingHomIsometric Ïƒâ‚â‚‚\nf : LinearMap Ïƒâ‚â‚‚ E F\nhf : LE.le (Filter.comap (â‡‘f) (nhds 0)) (nhds 0)\nâŠ¢ Exists fun K => AntilipschitzWith K â‡‘f","decl":"theorem antilipschitz_of_comap_nhds_le [h : RingHomIsometric Ïƒâ‚â‚‚] (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F)\n    (hf : (ğ“ 0).comap f â‰¤ ğ“ 0) : âˆƒ K, AntilipschitzWith K f := by\n  rcases ((nhds_basis_ball.comap _).le_basis_iff nhds_basis_ball).1 hf 1 one_pos with âŸ¨Îµ, Îµ0, hÎµâŸ©\n  simp only [Set.subset_def, Set.mem_preimage, mem_ball_zero_iff] at hÎµ\n  lift Îµ to â„â‰¥0 using Îµ0.le\n  rcases NormedField.exists_one_lt_norm ğ•œ with âŸ¨c, hcâŸ©\n  refine âŸ¨Îµâ»Â¹ * â€–câ€–â‚Š, AddMonoidHomClass.antilipschitz_of_bound f fun x => ?_âŸ©\n  by_cases hx : f x = 0\n  Â· rw [â† hx] at hf\n    obtain rfl : x = 0 := Specializes.eq (specializes_iff_pure.2 <|\n      ((Filter.tendsto_pure_pure _ _).mono_right (pure_le_nhds _)).le_comap.trans hf)\n    exact norm_zero.trans_le (mul_nonneg (NNReal.coe_nonneg _) (norm_nonneg _))\n  have hcâ‚€ : c â‰  0 := norm_pos_iff.1 (one_pos.trans hc)\n  rw [â† h.1] at hc\n  rcases rescale_to_shell_zpow hc Îµ0 hx with âŸ¨n, -, hlt, -, hleâŸ©\n  simp only [â† map_zpowâ‚€, h.1, â† map_smulâ‚›â‚—] at hlt hle\n  calc\n    â€–xâ€– = â€–c ^ nâ€–â»Â¹ * â€–c ^ n â€¢ xâ€– := by\n      rwa [â† norm_inv, â† norm_smul, inv_smul_smulâ‚€ (zpow_ne_zero _ _)]\n    _ â‰¤ â€–c ^ nâ€–â»Â¹ * 1 := (mul_le_mul_of_nonneg_left (hÎµ _ hlt).le (inv_nonneg.2 (norm_nonneg _)))\n    _ â‰¤ Îµâ»Â¹ * â€–câ€– * â€–f xâ€– := by rwa [mul_one]\n\n"}
{"name":"ContinuousLinearMap.opNorm_zero_iff","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nâŠ¢ Iff (Eq (Norm.norm f) 0) (Eq f 0)","decl":"/-- An operator is zero iff its norm vanishes. -/\ntheorem opNorm_zero_iff [RingHomIsometric Ïƒâ‚â‚‚] : â€–fâ€– = 0 â†” f = 0 :=\n  Iff.intro\n    (fun hn => ContinuousLinearMap.ext fun x => norm_le_zero_iff.1\n      (calc\n        _ â‰¤ â€–fâ€– * â€–xâ€– := le_opNorm _ _\n        _ = _ := by rw [hn, zero_mul]))\n    (by\n      rintro rfl\n      exact opNorm_zero)\n\n\n"}
{"name":"ContinuousLinearMap.norm_id","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : Nontrivial E\nâŠ¢ Eq (Norm.norm (ContinuousLinearMap.id ğ•œ E)) 1","decl":"/-- If a normed space is non-trivial, then the norm of the identity equals `1`. -/\n@[simp]\ntheorem norm_id [Nontrivial E] : â€–id ğ•œ Eâ€– = 1 := by\n  refine norm_id_of_nontrivial_seminorm ?_\n  obtain âŸ¨x, hxâŸ© := exists_ne (0 : E)\n  exact âŸ¨x, ne_of_gt (norm_pos_iff.2 hx)âŸ©\n\n"}
{"name":"ContinuousLinearMap.nnnorm_id","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : Nontrivial E\nâŠ¢ Eq (NNNorm.nnnorm (ContinuousLinearMap.id ğ•œ E)) 1","decl":"@[simp]\nlemma nnnorm_id [Nontrivial E] : â€–id ğ•œ Eâ€–â‚Š = 1 := NNReal.eq norm_id\n\n"}
{"name":"ContinuousLinearMap.normOneClass","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : Nontrivial E\nâŠ¢ NormOneClass (ContinuousLinearMap (RingHom.id ğ•œ) E E)","decl":"instance normOneClass [Nontrivial E] : NormOneClass (E â†’L[ğ•œ] E) :=\n  âŸ¨norm_idâŸ©\n\n"}
{"name":"ContinuousLinearMap.homothety_norm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœ : Nontrivial E\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\na : Real\nhf : âˆ€ (x : E), Eq (Norm.norm (f x)) (HMul.hMul a (Norm.norm x))\nâŠ¢ Eq (Norm.norm f) a","decl":"theorem homothety_norm [RingHomIsometric Ïƒâ‚â‚‚] [Nontrivial E] (f : E â†’SL[Ïƒâ‚â‚‚] F) {a : â„}\n    (hf : âˆ€ x, â€–f xâ€– = a * â€–xâ€–) : â€–fâ€– = a := by\n  obtain âŸ¨x, hxâŸ© : âˆƒ x : E, x â‰  0 := exists_ne 0\n  rw [â† norm_pos_iff] at hx\n  have ha : 0 â‰¤ a := by simpa only [hf, hx, mul_nonneg_iff_of_pos_right] using norm_nonneg (f x)\n  apply le_antisymm (f.opNorm_le_bound ha fun y => le_of_eq (hf y))\n  simpa only [hf, hx, mul_le_mul_right] using f.le_opNorm x\n\n"}
{"name":"ContinuousLinearMap.antilipschitz_of_isEmbedding","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nFâ‚— : Type u_6\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedAddCommGroup Fâ‚—\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œ Fâ‚—\nf : ContinuousLinearMap (RingHom.id ğ•œ) E Fâ‚—\nhf : Topology.IsEmbedding â‡‘f\nâŠ¢ Exists fun K => AntilipschitzWith K â‡‘f","decl":"/-- If a continuous linear map is a topology embedding, then it is expands the distances\nby a positive factor. -/\ntheorem antilipschitz_of_isEmbedding (f : E â†’L[ğ•œ] Fâ‚—) (hf : IsEmbedding f) :\n    âˆƒ K, AntilipschitzWith K f :=\n  f.toLinearMap.antilipschitz_of_comap_nhds_le <| map_zero f â–¸ (hf.nhds_eq_comap 0).ge\n\n"}
{"name":"ContinuousLinearMap.antilipschitz_of_embedding","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nFâ‚— : Type u_6\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedAddCommGroup Fâ‚—\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œ Fâ‚—\nf : ContinuousLinearMap (RingHom.id ğ•œ) E Fâ‚—\nhf : Topology.IsEmbedding â‡‘f\nâŠ¢ Exists fun K => AntilipschitzWith K â‡‘f","decl":"@[deprecated (since := \"2024-10-26\")]\nalias antilipschitz_of_embedding := antilipschitz_of_isEmbedding\n\n"}
{"name":"LinearIsometry.norm_toContinuousLinearMap","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœÂ¹ : Nontrivial E\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : LinearIsometry Ïƒâ‚â‚‚ E F\nâŠ¢ Eq (Norm.norm f.toContinuousLinearMap) 1","decl":"@[simp]\ntheorem norm_toContinuousLinearMap [Nontrivial E] [RingHomIsometric Ïƒâ‚â‚‚] (f : E â†’â‚›â‚—áµ¢[Ïƒâ‚â‚‚] F) :\n    â€–f.toContinuousLinearMapâ€– = 1 :=\n  f.toContinuousLinearMap.homothety_norm <| by simp\n\n"}
{"name":"LinearIsometry.norm_toContinuousLinearMap_comp","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nF : Type u_5\nG : Type u_7\ninstâœÂ¹â° : NormedAddCommGroup E\ninstâœâ¹ : NormedAddCommGroup F\ninstâœâ¸ : NormedAddCommGroup G\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâµ : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedSpace ğ•œâ‚‚ F\ninstâœÂ² : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\ninstâœÂ¹ : RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : LinearIsometry Ïƒâ‚‚â‚ƒ F G\ng : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ Eq (Norm.norm (f.toContinuousLinearMap.comp g)) (Norm.norm g)","decl":"/-- Postcomposition of a continuous linear map with a linear isometry preserves\nthe operator norm. -/\ntheorem norm_toContinuousLinearMap_comp [RingHomIsometric Ïƒâ‚â‚‚] (f : F â†’â‚›â‚—áµ¢[Ïƒâ‚‚â‚ƒ] G)\n    {g : E â†’SL[Ïƒâ‚â‚‚] F} : â€–f.toContinuousLinearMap.comp gâ€– = â€–gâ€– :=\n  opNorm_ext (f.toContinuousLinearMap.comp g) g fun x => by\n    simp only [norm_map, coe_toContinuousLinearMap, coe_comp', Function.comp_apply]\n\n"}
{"name":"ContinuousLinearMap.opNorm_comp_linearIsometryEquiv","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nF : Type u_5\nG : Type u_7\ninstâœÂ¹â¶ : NormedAddCommGroup F\ninstâœÂ¹âµ : NormedAddCommGroup G\ninstâœÂ¹â´ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ¹Â³ : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœÂ¹Â² : NormedSpace ğ•œâ‚‚ F\ninstâœÂ¹Â¹ : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nğ•œâ‚‚' : Type u_8\ninstâœÂ¹â° : NontriviallyNormedField ğ•œâ‚‚'\nF' : Type u_9\ninstâœâ¹ : NormedAddCommGroup F'\ninstâœâ¸ : NormedSpace ğ•œâ‚‚' F'\nÏƒâ‚‚' : RingHom ğ•œâ‚‚' ğ•œâ‚‚\nÏƒâ‚‚'' : RingHom ğ•œâ‚‚ ğ•œâ‚‚'\nÏƒâ‚‚â‚ƒ' : RingHom ğ•œâ‚‚' ğ•œâ‚ƒ\ninstâœâ· : RingHomInvPair Ïƒâ‚‚' Ïƒâ‚‚''\ninstâœâ¶ : RingHomInvPair Ïƒâ‚‚'' Ïƒâ‚‚'\ninstâœâµ : RingHomCompTriple Ïƒâ‚‚' Ïƒâ‚‚â‚ƒ Ïƒâ‚‚â‚ƒ'\ninstâœâ´ : RingHomCompTriple Ïƒâ‚‚'' Ïƒâ‚‚â‚ƒ' Ïƒâ‚‚â‚ƒ\ninstâœÂ³ : RingHomIsometric Ïƒâ‚‚â‚ƒ\ninstâœÂ² : RingHomIsometric Ïƒâ‚‚'\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚‚''\ninstâœ : RingHomIsometric Ïƒâ‚‚â‚ƒ'\nf : ContinuousLinearMap Ïƒâ‚‚â‚ƒ F G\ng : LinearIsometryEquiv Ïƒâ‚‚' F' F\nâŠ¢ Eq (Norm.norm (f.comp g.toLinearIsometry.toContinuousLinearMap)) (Norm.norm f)","decl":"/-- Precomposition with a linear isometry preserves the operator norm. -/\ntheorem opNorm_comp_linearIsometryEquiv (f : F â†’SL[Ïƒâ‚‚â‚ƒ] G) (g : F' â‰ƒâ‚›â‚—áµ¢[Ïƒâ‚‚'] F) :\n    â€–f.comp g.toLinearIsometry.toContinuousLinearMapâ€– = â€–fâ€– := by\n  cases subsingleton_or_nontrivial F'\n  Â· haveI := g.symm.toLinearEquiv.toEquiv.subsingleton\n    simp\n  refine le_antisymm ?_ ?_\n  Â· convert f.opNorm_comp_le g.toLinearIsometry.toContinuousLinearMap\n    simp [g.toLinearIsometry.norm_toContinuousLinearMap]\n  Â· convert (f.comp g.toLinearIsometry.toContinuousLinearMap).opNorm_comp_le\n        g.symm.toLinearIsometry.toContinuousLinearMap\n    Â· ext\n      simp\n    haveI := g.symm.surjective.nontrivial\n    simp [g.symm.toLinearIsometry.norm_toContinuousLinearMap]\n\n"}
{"name":"ContinuousLinearMap.norm_smulRightL","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nFâ‚— : Type u_6\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup Fâ‚—\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œ Fâ‚—\nc : ContinuousLinearMap (RingHom.id ğ•œ) E ğ•œ\ninstâœ : Nontrivial Fâ‚—\nâŠ¢ Eq (Norm.norm ((ContinuousLinearMap.smulRightL ğ•œ E Fâ‚—) c)) (Norm.norm c)","decl":"@[simp]\ntheorem norm_smulRightL (c : E â†’L[ğ•œ] ğ•œ) [Nontrivial Fâ‚—] : â€–smulRightL ğ•œ E Fâ‚— câ€– = â€–câ€– :=\n  ContinuousLinearMap.homothety_norm _ c.norm_smulRight_apply\n\n"}
{"name":"ContinuousLinearMap.norm_smulRightL_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nFâ‚— : Type u_6\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedAddCommGroup Fâ‚—\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œ Fâ‚—\nâŠ¢ LE.le (Norm.norm (ContinuousLinearMap.smulRightL ğ•œ E Fâ‚—)) 1","decl":"set_option maxSynthPendingDepth 2 in\nlemma norm_smulRightL_le : â€–smulRightL ğ•œ E Fâ‚—â€– â‰¤ 1 :=\n  LinearMap.mkContinuousâ‚‚_norm_le _ zero_le_one _\n\n"}
{"name":"Submodule.norm_subtypeL","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : Nontrivial (Subtype fun x => Membership.mem K x)\nâŠ¢ Eq (Norm.norm K.subtypeL) 1","decl":"theorem norm_subtypeL (K : Submodule ğ•œ E) [Nontrivial K] : â€–K.subtypeLâ€– = 1 :=\n  K.subtypeâ‚—áµ¢.norm_toContinuousLinearMap\n\n"}
{"name":"ContinuousLinearEquiv.antilipschitz","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nÏƒâ‚‚â‚ : RingHom ğ•œâ‚‚ ğ•œ\ninstâœÂ² : RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚\ninstâœÂ¹ : RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚\ninstâœ : RingHomIsometric Ïƒâ‚‚â‚\ne : ContinuousLinearEquiv Ïƒâ‚â‚‚ E F\nâŠ¢ AntilipschitzWith (NNNorm.nnnorm â†‘e.symm) â‡‘e","decl":"protected theorem antilipschitz (e : E â‰ƒSL[Ïƒâ‚â‚‚] F) :\n    AntilipschitzWith â€–(e.symm : F â†’SL[Ïƒâ‚‚â‚] E)â€–â‚Š e :=\n  e.symm.lipschitz.to_rightInverse e.left_inv\n\n"}
{"name":"ContinuousLinearEquiv.one_le_norm_mul_norm_symm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœÂ¹â° : NormedAddCommGroup E\ninstâœâ¹ : NormedAddCommGroup F\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nÏƒâ‚‚â‚ : RingHom ğ•œâ‚‚ ğ•œ\ninstâœâ´ : RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚\ninstâœÂ³ : RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚\ninstâœÂ² : RingHomIsometric Ïƒâ‚‚â‚\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœ : Nontrivial E\ne : ContinuousLinearEquiv Ïƒâ‚â‚‚ E F\nâŠ¢ LE.le 1 (HMul.hMul (Norm.norm â†‘e) (Norm.norm â†‘e.symm))","decl":"theorem one_le_norm_mul_norm_symm [RingHomIsometric Ïƒâ‚â‚‚] [Nontrivial E] (e : E â‰ƒSL[Ïƒâ‚â‚‚] F) :\n    1 â‰¤ â€–(e : E â†’SL[Ïƒâ‚â‚‚] F)â€– * â€–(e.symm : F â†’SL[Ïƒâ‚‚â‚] E)â€– := by\n  rw [mul_comm]\n  convert (e.symm : F â†’SL[Ïƒâ‚‚â‚] E).opNorm_comp_le (e : E â†’SL[Ïƒâ‚â‚‚] F)\n  rw [e.coe_symm_comp_coe, ContinuousLinearMap.norm_id]\n\n"}
{"name":"ContinuousLinearEquiv.norm_pos","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœÂ¹â° : NormedAddCommGroup E\ninstâœâ¹ : NormedAddCommGroup F\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nÏƒâ‚‚â‚ : RingHom ğ•œâ‚‚ ğ•œ\ninstâœâ´ : RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚\ninstâœÂ³ : RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚\ninstâœÂ² : RingHomIsometric Ïƒâ‚‚â‚\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœ : Nontrivial E\ne : ContinuousLinearEquiv Ïƒâ‚â‚‚ E F\nâŠ¢ LT.lt 0 (Norm.norm â†‘e)","decl":"theorem norm_pos [RingHomIsometric Ïƒâ‚â‚‚] [Nontrivial E] (e : E â‰ƒSL[Ïƒâ‚â‚‚] F) :\n    0 < â€–(e : E â†’SL[Ïƒâ‚â‚‚] F)â€– :=\n  pos_of_mul_pos_left (lt_of_lt_of_le zero_lt_one e.one_le_norm_mul_norm_symm) (norm_nonneg _)\n\n"}
{"name":"ContinuousLinearEquiv.norm_symm_pos","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœÂ¹â° : NormedAddCommGroup E\ninstâœâ¹ : NormedAddCommGroup F\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nÏƒâ‚‚â‚ : RingHom ğ•œâ‚‚ ğ•œ\ninstâœâ´ : RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚\ninstâœÂ³ : RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚\ninstâœÂ² : RingHomIsometric Ïƒâ‚‚â‚\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœ : Nontrivial E\ne : ContinuousLinearEquiv Ïƒâ‚â‚‚ E F\nâŠ¢ LT.lt 0 (Norm.norm â†‘e.symm)","decl":"theorem norm_symm_pos [RingHomIsometric Ïƒâ‚â‚‚] [Nontrivial E] (e : E â‰ƒSL[Ïƒâ‚â‚‚] F) :\n    0 < â€–(e.symm : F â†’SL[Ïƒâ‚‚â‚] E)â€– :=\n  pos_of_mul_pos_right (zero_lt_one.trans_le e.one_le_norm_mul_norm_symm) (norm_nonneg _)\n\n"}
{"name":"ContinuousLinearEquiv.nnnorm_symm_pos","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœÂ¹â° : NormedAddCommGroup E\ninstâœâ¹ : NormedAddCommGroup F\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nÏƒâ‚‚â‚ : RingHom ğ•œâ‚‚ ğ•œ\ninstâœâ´ : RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚\ninstâœÂ³ : RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚\ninstâœÂ² : RingHomIsometric Ïƒâ‚‚â‚\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœ : Nontrivial E\ne : ContinuousLinearEquiv Ïƒâ‚â‚‚ E F\nâŠ¢ LT.lt 0 (NNNorm.nnnorm â†‘e.symm)","decl":"theorem nnnorm_symm_pos [RingHomIsometric Ïƒâ‚â‚‚] [Nontrivial E] (e : E â‰ƒSL[Ïƒâ‚â‚‚] F) :\n    0 < â€–(e.symm : F â†’SL[Ïƒâ‚‚â‚] E)â€–â‚Š :=\n  e.norm_symm_pos\n\n"}
{"name":"ContinuousLinearEquiv.subsingleton_or_norm_symm_pos","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedAddCommGroup F\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâµ : NormedSpace ğ•œ E\ninstâœâ´ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nÏƒâ‚‚â‚ : RingHom ğ•œâ‚‚ ğ•œ\ninstâœÂ³ : RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚\ninstâœÂ² : RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚‚â‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\ne : ContinuousLinearEquiv Ïƒâ‚â‚‚ E F\nâŠ¢ Or (Subsingleton E) (LT.lt 0 (Norm.norm â†‘e.symm))","decl":"theorem subsingleton_or_norm_symm_pos [RingHomIsometric Ïƒâ‚â‚‚] (e : E â‰ƒSL[Ïƒâ‚â‚‚] F) :\n    Subsingleton E âˆ¨ 0 < â€–(e.symm : F â†’SL[Ïƒâ‚‚â‚] E)â€– := by\n  rcases subsingleton_or_nontrivial E with (_i | _i)\n  Â· left\n    infer_instance\n  Â· right\n    exact e.norm_symm_pos\n\n"}
{"name":"ContinuousLinearEquiv.subsingleton_or_nnnorm_symm_pos","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedAddCommGroup F\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâµ : NormedSpace ğ•œ E\ninstâœâ´ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nÏƒâ‚‚â‚ : RingHom ğ•œâ‚‚ ğ•œ\ninstâœÂ³ : RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚\ninstâœÂ² : RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚‚â‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\ne : ContinuousLinearEquiv Ïƒâ‚â‚‚ E F\nâŠ¢ Or (Subsingleton E) (LT.lt 0 (NNNorm.nnnorm â†‘e.symm))","decl":"theorem subsingleton_or_nnnorm_symm_pos [RingHomIsometric Ïƒâ‚â‚‚] (e : E â‰ƒSL[Ïƒâ‚â‚‚] F) :\n    Subsingleton E âˆ¨ 0 < â€–(e.symm : F â†’SL[Ïƒâ‚‚â‚] E)â€–â‚Š :=\n  subsingleton_or_norm_symm_pos e\n\n"}
{"name":"ContinuousLinearEquiv.coord_norm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NontriviallyNormedField ğ•œ\ninstâœ : NormedSpace ğ•œ E\nx : E\nh : Ne x 0\nâŠ¢ Eq (Norm.norm (ContinuousLinearEquiv.coord ğ•œ x h)) (Inv.inv (Norm.norm x))","decl":"@[simp]\ntheorem coord_norm (x : E) (h : x â‰  0) : â€–coord ğ•œ x hâ€– = â€–xâ€–â»Â¹ := by\n  have hx : 0 < â€–xâ€– := norm_pos_iff.mpr h\n  haveI : Nontrivial (ğ•œ âˆ™ x) := Submodule.nontrivial_span_singleton h\n  exact ContinuousLinearMap.homothety_norm _ fun y =>\n    homothety_inverse _ hx _ (LinearEquiv.toSpanNonzeroSingleton_homothety ğ•œ x h) _\n\n"}
{"name":"NormedSpace.equicontinuous_TFAE","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\nÎ¹ : Type u_8\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NontriviallyNormedField ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœâ´ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : SeminormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œâ‚‚ F\nf : Î¹ â†’ ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ (List.cons (EquicontinuousAt (Function.comp DFunLike.coe f) 0) (List.cons (Equicontinuous (Function.comp DFunLike.coe f)) (List.cons (UniformEquicontinuous (Function.comp DFunLike.coe f)) (List.cons (Exists fun C => âˆ€ (i : Î¹) (x : E), LE.le (Norm.norm ((f i) x)) (HMul.hMul C (Norm.norm x))) (List.cons (Exists fun C => And (GE.ge C 0) (âˆ€ (i : Î¹) (x : E), LE.le (Norm.norm ((f i) x)) (HMul.hMul C (Norm.norm x)))) (List.cons (Exists fun C => âˆ€ (i : Î¹), LE.le (Norm.norm (f i)) C) (List.cons (Exists fun C => And (GE.ge C 0) (âˆ€ (i : Î¹), LE.le (Norm.norm (f i)) C)) (List.cons (BddAbove (Set.range fun x => Norm.norm (f x))) (List.cons (LT.lt (iSup fun i => â†‘(NNNorm.nnnorm (f i))) Top.top) List.nil))))))))).TFAE","decl":"/-- Equivalent characterizations for equicontinuity of a family of continuous linear maps\nbetween normed spaces. See also `WithSeminorms.equicontinuous_TFAE` for similar characterizations\nbetween spaces satisfying `WithSeminorms`. -/\nprotected theorem NormedSpace.equicontinuous_TFAE : List.TFAE\n    [ EquicontinuousAt ((â†‘) âˆ˜ f) 0,\n      Equicontinuous ((â†‘) âˆ˜ f),\n      UniformEquicontinuous ((â†‘) âˆ˜ f),\n      âˆƒ C, âˆ€ i x, â€–f i xâ€– â‰¤ C * â€–xâ€–,\n      âˆƒ C â‰¥ 0, âˆ€ i x, â€–f i xâ€– â‰¤ C * â€–xâ€–,\n      âˆƒ C, âˆ€ i, â€–f iâ€– â‰¤ C,\n      âˆƒ C â‰¥ 0, âˆ€ i, â€–f iâ€– â‰¤ C,\n      BddAbove (Set.range (â€–f Â·â€–)),\n      (â¨† i, (â€–f iâ€–â‚Š : ENNReal)) < âŠ¤ ] := by\n  -- `1 â†” 2 â†” 3` follows from `uniformEquicontinuous_of_equicontinuousAt_zero`\n  tfae_have 1 â†’ 3 := uniformEquicontinuous_of_equicontinuousAt_zero f\n  tfae_have 3 â†’ 2 := UniformEquicontinuous.equicontinuous\n  tfae_have 2 â†’ 1 := fun H â†¦ H 0\n  -- `4 â†” 5 â†” 6 â†” 7 â†” 8 â†” 9` is morally trivial, we just have to use a lot of rewriting\n  -- and `congr` lemmas\n  tfae_have 4 â†” 5 := by\n    rw [exists_ge_and_iff_exists]\n    exact fun Câ‚ Câ‚‚ hC â†¦ forallâ‚‚_imp fun i x â†¦ le_trans' <| by gcongr\n  tfae_have 5 â†” 7 := by\n    refine exists_congr (fun C â†¦ and_congr_right fun hC â†¦ forall_congr' fun i â†¦ ?_)\n    rw [ContinuousLinearMap.opNorm_le_iff hC]\n  tfae_have 7 â†” 8 := by\n    simp_rw [bddAbove_iff_exists_ge (0 : â„), Set.forall_mem_range]\n  tfae_have 6 â†” 8 := by\n    simp_rw [bddAbove_def, Set.forall_mem_range]\n  tfae_have 8 â†” 9 := by\n    rw [ENNReal.iSup_coe_lt_top, â† NNReal.bddAbove_coe, â† Set.range_comp]\n    rfl\n  -- `3 â†” 4` is the interesting part of the result. It is essentially a combination of\n  -- `WithSeminorms.uniformEquicontinuous_iff_exists_continuous_seminorm` which turns\n  -- equicontinuity into existence of some continuous seminorm and\n  -- `Seminorm.bound_of_continuous_normedSpace` which characterize such seminorms.\n  tfae_have 3 â†” 4 := by\n    refine ((norm_withSeminorms ğ•œâ‚‚ F).uniformEquicontinuous_iff_exists_continuous_seminorm _).trans\n      ?_\n    rw [forall_const]\n    constructor\n    Â· intro âŸ¨p, hp, hpfâŸ©\n      rcases p.bound_of_continuous_normedSpace hp with âŸ¨C, -, hCâŸ©\n      exact âŸ¨C, fun i x â†¦ (hpf i x).trans (hC x)âŸ©\n    Â· intro âŸ¨C, hCâŸ©\n      refine âŸ¨C.toNNReal â€¢ normSeminorm ğ•œ E,\n        ((norm_withSeminorms ğ•œ E).continuous_seminorm 0).const_smul C.toNNReal, fun i x â†¦ ?_âŸ©\n      exact (hC i x).trans (mul_le_mul_of_nonneg_right (C.le_coe_toNNReal) (norm_nonneg x))\n  tfae_finish\n\n"}
