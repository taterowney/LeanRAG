{"name":"LinearMap.bound_of_shell","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : LinearMap σ₁₂ E F\nε C : Real\nε_pos : LT.lt 0 ε\nc : 𝕜\nhc : LT.lt 1 (Norm.norm c)\nhf : ∀ (x : E), LE.le (HDiv.hDiv ε (Norm.norm c)) (Norm.norm x) → LT.lt (Norm.norm x) ε → LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\nx : E\n⊢ LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))","decl":"theorem bound_of_shell [RingHomIsometric σ₁₂] (f : E →ₛₗ[σ₁₂] F) {ε C : ℝ} (ε_pos : 0 < ε) {c : 𝕜}\n    (hc : 1 < ‖c‖) (hf : ∀ x, ε / ‖c‖ ≤ ‖x‖ → ‖x‖ < ε → ‖f x‖ ≤ C * ‖x‖) (x : E) :\n    ‖f x‖ ≤ C * ‖x‖ := by\n  by_cases hx : x = 0; · simp [hx]\n  exact SemilinearMapClass.bound_of_shell_semi_normed f ε_pos hc hf (norm_ne_zero_iff.2 hx)\n\n"}
{"name":"LinearMap.bound_of_ball_bound","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nFₗ : Type u_6\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedAddCommGroup Fₗ\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜 Fₗ\nr : Real\nr_pos : LT.lt 0 r\nc : Real\nf : LinearMap (RingHom.id 𝕜) E Fₗ\nh : ∀ (z : E), Membership.mem (Metric.ball 0 r) z → LE.le (Norm.norm (f z)) c\n⊢ Exists fun C => ∀ (z : E), LE.le (Norm.norm (f z)) (HMul.hMul C (Norm.norm z))","decl":"/-- `LinearMap.bound_of_ball_bound'` is a version of this lemma over a field satisfying `RCLike`\nthat produces a concrete bound.\n-/\ntheorem bound_of_ball_bound {r : ℝ} (r_pos : 0 < r) (c : ℝ) (f : E →ₗ[𝕜] Fₗ)\n    (h : ∀ z ∈ Metric.ball (0 : E) r, ‖f z‖ ≤ c) : ∃ C, ∀ z : E, ‖f z‖ ≤ C * ‖z‖ := by\n  cases' @NontriviallyNormedField.non_trivial 𝕜 _ with k hk\n  use c * (‖k‖ / r)\n  intro z\n  refine bound_of_shell _ r_pos hk (fun x hko hxo => ?_) _\n  calc\n    ‖f x‖ ≤ c := h _ (mem_ball_zero_iff.mpr hxo)\n    _ ≤ c * (‖x‖ * ‖k‖ / r) := le_mul_of_one_le_right ?_ ?_\n    _ = _ := by ring\n  · exact le_trans (norm_nonneg _) (h 0 (by simp [r_pos]))\n  · rw [div_le_iff₀ (zero_lt_one.trans hk)] at hko\n    exact (one_le_div r_pos).mpr hko\n\n"}
{"name":"LinearMap.antilipschitz_of_comap_nhds_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NontriviallyNormedField 𝕜₂\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nh : RingHomIsometric σ₁₂\nf : LinearMap σ₁₂ E F\nhf : LE.le (Filter.comap (⇑f) (nhds 0)) (nhds 0)\n⊢ Exists fun K => AntilipschitzWith K ⇑f","decl":"theorem antilipschitz_of_comap_nhds_le [h : RingHomIsometric σ₁₂] (f : E →ₛₗ[σ₁₂] F)\n    (hf : (𝓝 0).comap f ≤ 𝓝 0) : ∃ K, AntilipschitzWith K f := by\n  rcases ((nhds_basis_ball.comap _).le_basis_iff nhds_basis_ball).1 hf 1 one_pos with ⟨ε, ε0, hε⟩\n  simp only [Set.subset_def, Set.mem_preimage, mem_ball_zero_iff] at hε\n  lift ε to ℝ≥0 using ε0.le\n  rcases NormedField.exists_one_lt_norm 𝕜 with ⟨c, hc⟩\n  refine ⟨ε⁻¹ * ‖c‖₊, AddMonoidHomClass.antilipschitz_of_bound f fun x => ?_⟩\n  by_cases hx : f x = 0\n  · rw [← hx] at hf\n    obtain rfl : x = 0 := Specializes.eq (specializes_iff_pure.2 <|\n      ((Filter.tendsto_pure_pure _ _).mono_right (pure_le_nhds _)).le_comap.trans hf)\n    exact norm_zero.trans_le (mul_nonneg (NNReal.coe_nonneg _) (norm_nonneg _))\n  have hc₀ : c ≠ 0 := norm_pos_iff.1 (one_pos.trans hc)\n  rw [← h.1] at hc\n  rcases rescale_to_shell_zpow hc ε0 hx with ⟨n, -, hlt, -, hle⟩\n  simp only [← map_zpow₀, h.1, ← map_smulₛₗ] at hlt hle\n  calc\n    ‖x‖ = ‖c ^ n‖⁻¹ * ‖c ^ n • x‖ := by\n      rwa [← norm_inv, ← norm_smul, inv_smul_smul₀ (zpow_ne_zero _ _)]\n    _ ≤ ‖c ^ n‖⁻¹ * 1 := (mul_le_mul_of_nonneg_left (hε _ hlt).le (inv_nonneg.2 (norm_nonneg _)))\n    _ ≤ ε⁻¹ * ‖c‖ * ‖f x‖ := by rwa [mul_one]\n\n"}
{"name":"ContinuousLinearMap.opNorm_zero_iff","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nf : ContinuousLinearMap σ₁₂ E F\ninst✝ : RingHomIsometric σ₁₂\n⊢ Iff (Eq (Norm.norm f) 0) (Eq f 0)","decl":"/-- An operator is zero iff its norm vanishes. -/\ntheorem opNorm_zero_iff [RingHomIsometric σ₁₂] : ‖f‖ = 0 ↔ f = 0 :=\n  Iff.intro\n    (fun hn => ContinuousLinearMap.ext fun x => norm_le_zero_iff.1\n      (calc\n        _ ≤ ‖f‖ * ‖x‖ := le_opNorm _ _\n        _ = _ := by rw [hn, zero_mul]))\n    (by\n      rintro rfl\n      exact opNorm_zero)\n\n\n"}
{"name":"ContinuousLinearMap.norm_id","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜 : Type u_1\nE : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : Nontrivial E\n⊢ Eq (Norm.norm (ContinuousLinearMap.id 𝕜 E)) 1","decl":"/-- If a normed space is non-trivial, then the norm of the identity equals `1`. -/\n@[simp]\ntheorem norm_id [Nontrivial E] : ‖id 𝕜 E‖ = 1 := by\n  refine norm_id_of_nontrivial_seminorm ?_\n  obtain ⟨x, hx⟩ := exists_ne (0 : E)\n  exact ⟨x, ne_of_gt (norm_pos_iff.2 hx)⟩\n\n"}
{"name":"ContinuousLinearMap.nnnorm_id","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜 : Type u_1\nE : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : Nontrivial E\n⊢ Eq (NNNorm.nnnorm (ContinuousLinearMap.id 𝕜 E)) 1","decl":"@[simp]\nlemma nnnorm_id [Nontrivial E] : ‖id 𝕜 E‖₊ = 1 := NNReal.eq norm_id\n\n"}
{"name":"ContinuousLinearMap.normOneClass","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜 : Type u_1\nE : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : Nontrivial E\n⊢ NormOneClass (ContinuousLinearMap (RingHom.id 𝕜) E E)","decl":"instance normOneClass [Nontrivial E] : NormOneClass (E →L[𝕜] E) :=\n  ⟨norm_id⟩\n\n"}
{"name":"ContinuousLinearMap.homothety_norm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NontriviallyNormedField 𝕜₂\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝¹ : RingHomIsometric σ₁₂\ninst✝ : Nontrivial E\nf : ContinuousLinearMap σ₁₂ E F\na : Real\nhf : ∀ (x : E), Eq (Norm.norm (f x)) (HMul.hMul a (Norm.norm x))\n⊢ Eq (Norm.norm f) a","decl":"theorem homothety_norm [RingHomIsometric σ₁₂] [Nontrivial E] (f : E →SL[σ₁₂] F) {a : ℝ}\n    (hf : ∀ x, ‖f x‖ = a * ‖x‖) : ‖f‖ = a := by\n  obtain ⟨x, hx⟩ : ∃ x : E, x ≠ 0 := exists_ne 0\n  rw [← norm_pos_iff] at hx\n  have ha : 0 ≤ a := by simpa only [hf, hx, mul_nonneg_iff_of_pos_right] using norm_nonneg (f x)\n  apply le_antisymm (f.opNorm_le_bound ha fun y => le_of_eq (hf y))\n  simpa only [hf, hx, mul_le_mul_right] using f.le_opNorm x\n\n"}
{"name":"ContinuousLinearMap.antilipschitz_of_isEmbedding","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nFₗ : Type u_6\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedAddCommGroup Fₗ\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜 Fₗ\nf : ContinuousLinearMap (RingHom.id 𝕜) E Fₗ\nhf : Topology.IsEmbedding ⇑f\n⊢ Exists fun K => AntilipschitzWith K ⇑f","decl":"/-- If a continuous linear map is a topology embedding, then it is expands the distances\nby a positive factor. -/\ntheorem antilipschitz_of_isEmbedding (f : E →L[𝕜] Fₗ) (hf : IsEmbedding f) :\n    ∃ K, AntilipschitzWith K f :=\n  f.toLinearMap.antilipschitz_of_comap_nhds_le <| map_zero f ▸ (hf.nhds_eq_comap 0).ge\n\n"}
{"name":"ContinuousLinearMap.antilipschitz_of_embedding","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nFₗ : Type u_6\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedAddCommGroup Fₗ\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜 Fₗ\nf : ContinuousLinearMap (RingHom.id 𝕜) E Fₗ\nhf : Topology.IsEmbedding ⇑f\n⊢ Exists fun K => AntilipschitzWith K ⇑f","decl":"@[deprecated (since := \"2024-10-26\")]\nalias antilipschitz_of_embedding := antilipschitz_of_isEmbedding\n\n"}
{"name":"LinearIsometry.norm_toContinuousLinearMap","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NontriviallyNormedField 𝕜₂\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝¹ : Nontrivial E\ninst✝ : RingHomIsometric σ₁₂\nf : LinearIsometry σ₁₂ E F\n⊢ Eq (Norm.norm f.toContinuousLinearMap) 1","decl":"@[simp]\ntheorem norm_toContinuousLinearMap [Nontrivial E] [RingHomIsometric σ₁₂] (f : E →ₛₗᵢ[σ₁₂] F) :\n    ‖f.toContinuousLinearMap‖ = 1 :=\n  f.toContinuousLinearMap.homothety_norm <| by simp\n\n"}
{"name":"LinearIsometry.norm_toContinuousLinearMap_comp","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nE : Type u_4\nF : Type u_5\nG : Type u_7\ninst✝¹⁰ : NormedAddCommGroup E\ninst✝⁹ : NormedAddCommGroup F\ninst✝⁸ : NormedAddCommGroup G\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NontriviallyNormedField 𝕜₂\ninst✝⁵ : NontriviallyNormedField 𝕜₃\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedSpace 𝕜₂ F\ninst✝² : NormedSpace 𝕜₃ G\nσ₁₂ : RingHom 𝕜 𝕜₂\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\nσ₁₃ : RingHom 𝕜 𝕜₃\ninst✝¹ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\ninst✝ : RingHomIsometric σ₁₂\nf : LinearIsometry σ₂₃ F G\ng : ContinuousLinearMap σ₁₂ E F\n⊢ Eq (Norm.norm (f.toContinuousLinearMap.comp g)) (Norm.norm g)","decl":"/-- Postcomposition of a continuous linear map with a linear isometry preserves\nthe operator norm. -/\ntheorem norm_toContinuousLinearMap_comp [RingHomIsometric σ₁₂] (f : F →ₛₗᵢ[σ₂₃] G)\n    {g : E →SL[σ₁₂] F} : ‖f.toContinuousLinearMap.comp g‖ = ‖g‖ :=\n  opNorm_ext (f.toContinuousLinearMap.comp g) g fun x => by\n    simp only [norm_map, coe_toContinuousLinearMap, coe_comp', Function.comp_apply]\n\n"}
{"name":"ContinuousLinearMap.opNorm_comp_linearIsometryEquiv","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nF : Type u_5\nG : Type u_7\ninst✝¹⁶ : NormedAddCommGroup F\ninst✝¹⁵ : NormedAddCommGroup G\ninst✝¹⁴ : NontriviallyNormedField 𝕜₂\ninst✝¹³ : NontriviallyNormedField 𝕜₃\ninst✝¹² : NormedSpace 𝕜₂ F\ninst✝¹¹ : NormedSpace 𝕜₃ G\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\n𝕜₂' : Type u_8\ninst✝¹⁰ : NontriviallyNormedField 𝕜₂'\nF' : Type u_9\ninst✝⁹ : NormedAddCommGroup F'\ninst✝⁸ : NormedSpace 𝕜₂' F'\nσ₂' : RingHom 𝕜₂' 𝕜₂\nσ₂'' : RingHom 𝕜₂ 𝕜₂'\nσ₂₃' : RingHom 𝕜₂' 𝕜₃\ninst✝⁷ : RingHomInvPair σ₂' σ₂''\ninst✝⁶ : RingHomInvPair σ₂'' σ₂'\ninst✝⁵ : RingHomCompTriple σ₂' σ₂₃ σ₂₃'\ninst✝⁴ : RingHomCompTriple σ₂'' σ₂₃' σ₂₃\ninst✝³ : RingHomIsometric σ₂₃\ninst✝² : RingHomIsometric σ₂'\ninst✝¹ : RingHomIsometric σ₂''\ninst✝ : RingHomIsometric σ₂₃'\nf : ContinuousLinearMap σ₂₃ F G\ng : LinearIsometryEquiv σ₂' F' F\n⊢ Eq (Norm.norm (f.comp g.toLinearIsometry.toContinuousLinearMap)) (Norm.norm f)","decl":"/-- Precomposition with a linear isometry preserves the operator norm. -/\ntheorem opNorm_comp_linearIsometryEquiv (f : F →SL[σ₂₃] G) (g : F' ≃ₛₗᵢ[σ₂'] F) :\n    ‖f.comp g.toLinearIsometry.toContinuousLinearMap‖ = ‖f‖ := by\n  cases subsingleton_or_nontrivial F'\n  · haveI := g.symm.toLinearEquiv.toEquiv.subsingleton\n    simp\n  refine le_antisymm ?_ ?_\n  · convert f.opNorm_comp_le g.toLinearIsometry.toContinuousLinearMap\n    simp [g.toLinearIsometry.norm_toContinuousLinearMap]\n  · convert (f.comp g.toLinearIsometry.toContinuousLinearMap).opNorm_comp_le\n        g.symm.toLinearIsometry.toContinuousLinearMap\n    · ext\n      simp\n    haveI := g.symm.surjective.nontrivial\n    simp [g.symm.toLinearIsometry.norm_toContinuousLinearMap]\n\n"}
{"name":"ContinuousLinearMap.norm_smulRightL","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nFₗ : Type u_6\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup Fₗ\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜 Fₗ\nc : ContinuousLinearMap (RingHom.id 𝕜) E 𝕜\ninst✝ : Nontrivial Fₗ\n⊢ Eq (Norm.norm ((ContinuousLinearMap.smulRightL 𝕜 E Fₗ) c)) (Norm.norm c)","decl":"@[simp]\ntheorem norm_smulRightL (c : E →L[𝕜] 𝕜) [Nontrivial Fₗ] : ‖smulRightL 𝕜 E Fₗ c‖ = ‖c‖ :=\n  ContinuousLinearMap.homothety_norm _ c.norm_smulRight_apply\n\n"}
{"name":"ContinuousLinearMap.norm_smulRightL_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nFₗ : Type u_6\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedAddCommGroup Fₗ\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜 Fₗ\n⊢ LE.le (Norm.norm (ContinuousLinearMap.smulRightL 𝕜 E Fₗ)) 1","decl":"set_option maxSynthPendingDepth 2 in\nlemma norm_smulRightL_le : ‖smulRightL 𝕜 E Fₗ‖ ≤ 1 :=\n  LinearMap.mkContinuous₂_norm_le _ zero_le_one _\n\n"}
{"name":"Submodule.norm_subtypeL","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜 : Type u_1\nE : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 E\nK : Submodule 𝕜 E\ninst✝ : Nontrivial (Subtype fun x => Membership.mem K x)\n⊢ Eq (Norm.norm K.subtypeL) 1","decl":"theorem norm_subtypeL (K : Submodule 𝕜 E) [Nontrivial K] : ‖K.subtypeL‖ = 1 :=\n  K.subtypeₗᵢ.norm_toContinuousLinearMap\n\n"}
{"name":"ContinuousLinearEquiv.antilipschitz","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NontriviallyNormedField 𝕜₂\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nσ₂₁ : RingHom 𝕜₂ 𝕜\ninst✝² : RingHomInvPair σ₁₂ σ₂₁\ninst✝¹ : RingHomInvPair σ₂₁ σ₁₂\ninst✝ : RingHomIsometric σ₂₁\ne : ContinuousLinearEquiv σ₁₂ E F\n⊢ AntilipschitzWith (NNNorm.nnnorm ↑e.symm) ⇑e","decl":"protected theorem antilipschitz (e : E ≃SL[σ₁₂] F) :\n    AntilipschitzWith ‖(e.symm : F →SL[σ₂₁] E)‖₊ e :=\n  e.symm.lipschitz.to_rightInverse e.left_inv\n\n"}
{"name":"ContinuousLinearEquiv.one_le_norm_mul_norm_symm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝¹⁰ : NormedAddCommGroup E\ninst✝⁹ : NormedAddCommGroup F\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : NontriviallyNormedField 𝕜₂\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nσ₂₁ : RingHom 𝕜₂ 𝕜\ninst✝⁴ : RingHomInvPair σ₁₂ σ₂₁\ninst✝³ : RingHomInvPair σ₂₁ σ₁₂\ninst✝² : RingHomIsometric σ₂₁\ninst✝¹ : RingHomIsometric σ₁₂\ninst✝ : Nontrivial E\ne : ContinuousLinearEquiv σ₁₂ E F\n⊢ LE.le 1 (HMul.hMul (Norm.norm ↑e) (Norm.norm ↑e.symm))","decl":"theorem one_le_norm_mul_norm_symm [RingHomIsometric σ₁₂] [Nontrivial E] (e : E ≃SL[σ₁₂] F) :\n    1 ≤ ‖(e : E →SL[σ₁₂] F)‖ * ‖(e.symm : F →SL[σ₂₁] E)‖ := by\n  rw [mul_comm]\n  convert (e.symm : F →SL[σ₂₁] E).opNorm_comp_le (e : E →SL[σ₁₂] F)\n  rw [e.coe_symm_comp_coe, ContinuousLinearMap.norm_id]\n\n"}
{"name":"ContinuousLinearEquiv.norm_pos","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝¹⁰ : NormedAddCommGroup E\ninst✝⁹ : NormedAddCommGroup F\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : NontriviallyNormedField 𝕜₂\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nσ₂₁ : RingHom 𝕜₂ 𝕜\ninst✝⁴ : RingHomInvPair σ₁₂ σ₂₁\ninst✝³ : RingHomInvPair σ₂₁ σ₁₂\ninst✝² : RingHomIsometric σ₂₁\ninst✝¹ : RingHomIsometric σ₁₂\ninst✝ : Nontrivial E\ne : ContinuousLinearEquiv σ₁₂ E F\n⊢ LT.lt 0 (Norm.norm ↑e)","decl":"theorem norm_pos [RingHomIsometric σ₁₂] [Nontrivial E] (e : E ≃SL[σ₁₂] F) :\n    0 < ‖(e : E →SL[σ₁₂] F)‖ :=\n  pos_of_mul_pos_left (lt_of_lt_of_le zero_lt_one e.one_le_norm_mul_norm_symm) (norm_nonneg _)\n\n"}
{"name":"ContinuousLinearEquiv.norm_symm_pos","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝¹⁰ : NormedAddCommGroup E\ninst✝⁹ : NormedAddCommGroup F\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : NontriviallyNormedField 𝕜₂\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nσ₂₁ : RingHom 𝕜₂ 𝕜\ninst✝⁴ : RingHomInvPair σ₁₂ σ₂₁\ninst✝³ : RingHomInvPair σ₂₁ σ₁₂\ninst✝² : RingHomIsometric σ₂₁\ninst✝¹ : RingHomIsometric σ₁₂\ninst✝ : Nontrivial E\ne : ContinuousLinearEquiv σ₁₂ E F\n⊢ LT.lt 0 (Norm.norm ↑e.symm)","decl":"theorem norm_symm_pos [RingHomIsometric σ₁₂] [Nontrivial E] (e : E ≃SL[σ₁₂] F) :\n    0 < ‖(e.symm : F →SL[σ₂₁] E)‖ :=\n  pos_of_mul_pos_right (zero_lt_one.trans_le e.one_le_norm_mul_norm_symm) (norm_nonneg _)\n\n"}
{"name":"ContinuousLinearEquiv.nnnorm_symm_pos","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝¹⁰ : NormedAddCommGroup E\ninst✝⁹ : NormedAddCommGroup F\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : NontriviallyNormedField 𝕜₂\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nσ₂₁ : RingHom 𝕜₂ 𝕜\ninst✝⁴ : RingHomInvPair σ₁₂ σ₂₁\ninst✝³ : RingHomInvPair σ₂₁ σ₁₂\ninst✝² : RingHomIsometric σ₂₁\ninst✝¹ : RingHomIsometric σ₁₂\ninst✝ : Nontrivial E\ne : ContinuousLinearEquiv σ₁₂ E F\n⊢ LT.lt 0 (NNNorm.nnnorm ↑e.symm)","decl":"theorem nnnorm_symm_pos [RingHomIsometric σ₁₂] [Nontrivial E] (e : E ≃SL[σ₁₂] F) :\n    0 < ‖(e.symm : F →SL[σ₂₁] E)‖₊ :=\n  e.norm_symm_pos\n\n"}
{"name":"ContinuousLinearEquiv.subsingleton_or_norm_symm_pos","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedAddCommGroup F\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NontriviallyNormedField 𝕜₂\ninst✝⁵ : NormedSpace 𝕜 E\ninst✝⁴ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nσ₂₁ : RingHom 𝕜₂ 𝕜\ninst✝³ : RingHomInvPair σ₁₂ σ₂₁\ninst✝² : RingHomInvPair σ₂₁ σ₁₂\ninst✝¹ : RingHomIsometric σ₂₁\ninst✝ : RingHomIsometric σ₁₂\ne : ContinuousLinearEquiv σ₁₂ E F\n⊢ Or (Subsingleton E) (LT.lt 0 (Norm.norm ↑e.symm))","decl":"theorem subsingleton_or_norm_symm_pos [RingHomIsometric σ₁₂] (e : E ≃SL[σ₁₂] F) :\n    Subsingleton E ∨ 0 < ‖(e.symm : F →SL[σ₂₁] E)‖ := by\n  rcases subsingleton_or_nontrivial E with (_i | _i)\n  · left\n    infer_instance\n  · right\n    exact e.norm_symm_pos\n\n"}
{"name":"ContinuousLinearEquiv.subsingleton_or_nnnorm_symm_pos","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedAddCommGroup F\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NontriviallyNormedField 𝕜₂\ninst✝⁵ : NormedSpace 𝕜 E\ninst✝⁴ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nσ₂₁ : RingHom 𝕜₂ 𝕜\ninst✝³ : RingHomInvPair σ₁₂ σ₂₁\ninst✝² : RingHomInvPair σ₂₁ σ₁₂\ninst✝¹ : RingHomIsometric σ₂₁\ninst✝ : RingHomIsometric σ₁₂\ne : ContinuousLinearEquiv σ₁₂ E F\n⊢ Or (Subsingleton E) (LT.lt 0 (NNNorm.nnnorm ↑e.symm))","decl":"theorem subsingleton_or_nnnorm_symm_pos [RingHomIsometric σ₁₂] (e : E ≃SL[σ₁₂] F) :\n    Subsingleton E ∨ 0 < ‖(e.symm : F →SL[σ₂₁] E)‖₊ :=\n  subsingleton_or_norm_symm_pos e\n\n"}
{"name":"ContinuousLinearEquiv.coord_norm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜 : Type u_1\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NontriviallyNormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\nx : E\nh : Ne x 0\n⊢ Eq (Norm.norm (ContinuousLinearEquiv.coord 𝕜 x h)) (Inv.inv (Norm.norm x))","decl":"@[simp]\ntheorem coord_norm (x : E) (h : x ≠ 0) : ‖coord 𝕜 x h‖ = ‖x‖⁻¹ := by\n  have hx : 0 < ‖x‖ := norm_pos_iff.mpr h\n  haveI : Nontrivial (𝕜 ∙ x) := Submodule.nontrivial_span_singleton h\n  exact ContinuousLinearMap.homothety_norm _ fun y =>\n    homothety_inverse _ hx _ (LinearEquiv.toSpanNonzeroSingleton_homothety 𝕜 x h) _\n\n"}
{"name":"NormedSpace.equicontinuous_TFAE","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\nι : Type u_8\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NontriviallyNormedField 𝕜₂\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝⁴ : RingHomIsometric σ₁₂\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : SeminormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜₂ F\nf : ι → ContinuousLinearMap σ₁₂ E F\n⊢ (List.cons (EquicontinuousAt (Function.comp DFunLike.coe f) 0) (List.cons (Equicontinuous (Function.comp DFunLike.coe f)) (List.cons (UniformEquicontinuous (Function.comp DFunLike.coe f)) (List.cons (Exists fun C => ∀ (i : ι) (x : E), LE.le (Norm.norm ((f i) x)) (HMul.hMul C (Norm.norm x))) (List.cons (Exists fun C => And (GE.ge C 0) (∀ (i : ι) (x : E), LE.le (Norm.norm ((f i) x)) (HMul.hMul C (Norm.norm x)))) (List.cons (Exists fun C => ∀ (i : ι), LE.le (Norm.norm (f i)) C) (List.cons (Exists fun C => And (GE.ge C 0) (∀ (i : ι), LE.le (Norm.norm (f i)) C)) (List.cons (BddAbove (Set.range fun x => Norm.norm (f x))) (List.cons (LT.lt (iSup fun i => ↑(NNNorm.nnnorm (f i))) Top.top) List.nil))))))))).TFAE","decl":"/-- Equivalent characterizations for equicontinuity of a family of continuous linear maps\nbetween normed spaces. See also `WithSeminorms.equicontinuous_TFAE` for similar characterizations\nbetween spaces satisfying `WithSeminorms`. -/\nprotected theorem NormedSpace.equicontinuous_TFAE : List.TFAE\n    [ EquicontinuousAt ((↑) ∘ f) 0,\n      Equicontinuous ((↑) ∘ f),\n      UniformEquicontinuous ((↑) ∘ f),\n      ∃ C, ∀ i x, ‖f i x‖ ≤ C * ‖x‖,\n      ∃ C ≥ 0, ∀ i x, ‖f i x‖ ≤ C * ‖x‖,\n      ∃ C, ∀ i, ‖f i‖ ≤ C,\n      ∃ C ≥ 0, ∀ i, ‖f i‖ ≤ C,\n      BddAbove (Set.range (‖f ·‖)),\n      (⨆ i, (‖f i‖₊ : ENNReal)) < ⊤ ] := by\n  -- `1 ↔ 2 ↔ 3` follows from `uniformEquicontinuous_of_equicontinuousAt_zero`\n  tfae_have 1 → 3 := uniformEquicontinuous_of_equicontinuousAt_zero f\n  tfae_have 3 → 2 := UniformEquicontinuous.equicontinuous\n  tfae_have 2 → 1 := fun H ↦ H 0\n  -- `4 ↔ 5 ↔ 6 ↔ 7 ↔ 8 ↔ 9` is morally trivial, we just have to use a lot of rewriting\n  -- and `congr` lemmas\n  tfae_have 4 ↔ 5 := by\n    rw [exists_ge_and_iff_exists]\n    exact fun C₁ C₂ hC ↦ forall₂_imp fun i x ↦ le_trans' <| by gcongr\n  tfae_have 5 ↔ 7 := by\n    refine exists_congr (fun C ↦ and_congr_right fun hC ↦ forall_congr' fun i ↦ ?_)\n    rw [ContinuousLinearMap.opNorm_le_iff hC]\n  tfae_have 7 ↔ 8 := by\n    simp_rw [bddAbove_iff_exists_ge (0 : ℝ), Set.forall_mem_range]\n  tfae_have 6 ↔ 8 := by\n    simp_rw [bddAbove_def, Set.forall_mem_range]\n  tfae_have 8 ↔ 9 := by\n    rw [ENNReal.iSup_coe_lt_top, ← NNReal.bddAbove_coe, ← Set.range_comp]\n    rfl\n  -- `3 ↔ 4` is the interesting part of the result. It is essentially a combination of\n  -- `WithSeminorms.uniformEquicontinuous_iff_exists_continuous_seminorm` which turns\n  -- equicontinuity into existence of some continuous seminorm and\n  -- `Seminorm.bound_of_continuous_normedSpace` which characterize such seminorms.\n  tfae_have 3 ↔ 4 := by\n    refine ((norm_withSeminorms 𝕜₂ F).uniformEquicontinuous_iff_exists_continuous_seminorm _).trans\n      ?_\n    rw [forall_const]\n    constructor\n    · intro ⟨p, hp, hpf⟩\n      rcases p.bound_of_continuous_normedSpace hp with ⟨C, -, hC⟩\n      exact ⟨C, fun i x ↦ (hpf i x).trans (hC x)⟩\n    · intro ⟨C, hC⟩\n      refine ⟨C.toNNReal • normSeminorm 𝕜 E,\n        ((norm_withSeminorms 𝕜 E).continuous_seminorm 0).const_smul C.toNNReal, fun i x ↦ ?_⟩\n      exact (hC i x).trans (mul_le_mul_of_nonneg_right (C.le_coe_toNNReal) (norm_nonneg x))\n  tfae_finish\n\n"}
