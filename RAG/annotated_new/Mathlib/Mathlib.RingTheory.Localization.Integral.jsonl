{"name":"IsLocalization.coeffIntegerNormalization_of_not_mem_support","module":"Mathlib.RingTheory.Localization.Integral","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\np : Polynomial S\ni : Nat\nh : Eq (p.coeff i) 0\n⊢ Eq (IsLocalization.coeffIntegerNormalization M p i) 0","decl":"theorem coeffIntegerNormalization_of_not_mem_support (p : S[X]) (i : ℕ) (h : coeff p i = 0) :\n    coeffIntegerNormalization M p i = 0 := by\n  simp only [coeffIntegerNormalization, h, mem_support_iff, eq_self_iff_true, not_true, Ne,\n    dif_neg, not_false_iff]\n\n"}
{"name":"IsLocalization.coeffIntegerNormalization_mem_support","module":"Mathlib.RingTheory.Localization.Integral","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\np : Polynomial S\ni : Nat\nh : Ne (IsLocalization.coeffIntegerNormalization M p i) 0\n⊢ Membership.mem p.support i","decl":"theorem coeffIntegerNormalization_mem_support (p : S[X]) (i : ℕ)\n    (h : coeffIntegerNormalization M p i ≠ 0) : i ∈ p.support := by\n  contrapose h\n  rw [Ne, Classical.not_not, coeffIntegerNormalization, dif_neg h]\n\n"}
{"name":"IsLocalization.integerNormalization_coeff","module":"Mathlib.RingTheory.Localization.Integral","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\np : Polynomial S\ni : Nat\n⊢ Eq ((IsLocalization.integerNormalization M p).coeff i) (IsLocalization.coeffIntegerNormalization M p i)","decl":"@[simp]\ntheorem integerNormalization_coeff (p : S[X]) (i : ℕ) :\n    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by\n  simp +contextual [integerNormalization, coeff_monomial,\n    coeffIntegerNormalization_of_not_mem_support]\n\n"}
{"name":"IsLocalization.integerNormalization_spec","module":"Mathlib.RingTheory.Localization.Integral","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\np : Polynomial S\n⊢ Exists fun b => ∀ (i : Nat), Eq ((algebraMap R S) ((IsLocalization.integerNormalization M p).coeff i)) (HSMul.hSMul (↑b) (p.coeff i))","decl":"theorem integerNormalization_spec (p : S[X]) :\n    ∃ b : M, ∀ i, algebraMap R S ((integerNormalization M p).coeff i) = (b : R) • p.coeff i := by\n  classical\n  use Classical.choose (exist_integer_multiples_of_finset M (p.support.image p.coeff))\n  intro i\n  rw [integerNormalization_coeff, coeffIntegerNormalization]\n  split_ifs with hi\n  · exact\n      Classical.choose_spec\n        (Classical.choose_spec (exist_integer_multiples_of_finset M (p.support.image p.coeff))\n          (p.coeff i) (Finset.mem_image.mpr ⟨i, hi, rfl⟩))\n  · rw [RingHom.map_zero, not_mem_support_iff.mp hi, smul_zero]\n    -- Porting note: was `convert (smul_zero _).symm, ...`\n\n"}
{"name":"IsLocalization.integerNormalization_map_to_map","module":"Mathlib.RingTheory.Localization.Integral","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\np : Polynomial S\n⊢ Exists fun b => Eq (Polynomial.map (algebraMap R S) (IsLocalization.integerNormalization M p)) (HSMul.hSMul (↑b) p)","decl":"theorem integerNormalization_map_to_map (p : S[X]) :\n    ∃ b : M, (integerNormalization M p).map (algebraMap R S) = (b : R) • p :=\n  let ⟨b, hb⟩ := integerNormalization_spec M p\n  ⟨b,\n    Polynomial.ext fun i => by\n      rw [coeff_map, coeff_smul]\n      exact hb i⟩\n\n"}
{"name":"IsLocalization.integerNormalization_eval₂_eq_zero","module":"Mathlib.RingTheory.Localization.Integral","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : IsLocalization M S\nR' : Type u_3\ninst✝ : CommRing R'\ng : RingHom S R'\np : Polynomial S\nx : R'\nhx : Eq (Polynomial.eval₂ g x p) 0\n⊢ Eq (Polynomial.eval₂ (g.comp (algebraMap R S)) x (IsLocalization.integerNormalization M p)) 0","decl":"theorem integerNormalization_eval₂_eq_zero (g : S →+* R') (p : S[X]) {x : R'}\n    (hx : eval₂ g x p = 0) : eval₂ (g.comp (algebraMap R S)) x (integerNormalization M p) = 0 :=\n  let ⟨b, hb⟩ := integerNormalization_map_to_map M p\n  _root_.trans (eval₂_map (algebraMap R S) g x).symm\n    (by rw [hb, ← IsScalarTower.algebraMap_smul S (b : R) p, eval₂_smul, hx, mul_zero])\n\n"}
{"name":"IsLocalization.integerNormalization_aeval_eq_zero","module":"Mathlib.RingTheory.Localization.Integral","initialProofState":"R : Type u_1\ninst✝⁷ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝⁶ : CommRing S\ninst✝⁵ : Algebra R S\ninst✝⁴ : IsLocalization M S\nR' : Type u_3\ninst✝³ : CommRing R'\ninst✝² : Algebra R R'\ninst✝¹ : Algebra S R'\ninst✝ : IsScalarTower R S R'\np : Polynomial S\nx : R'\nhx : Eq ((Polynomial.aeval x) p) 0\n⊢ Eq ((Polynomial.aeval x) (IsLocalization.integerNormalization M p)) 0","decl":"theorem integerNormalization_aeval_eq_zero [Algebra R R'] [Algebra S R'] [IsScalarTower R S R']\n    (p : S[X]) {x : R'} (hx : aeval x p = 0) : aeval x (integerNormalization M p) = 0 := by\n  rw [aeval_def, IsScalarTower.algebraMap_eq R S R',\n    integerNormalization_eval₂_eq_zero _ (algebraMap _ _) _ hx]\n\n"}
{"name":"IsFractionRing.integerNormalization_eq_zero_iff","module":"Mathlib.RingTheory.Localization.Integral","initialProofState":"A : Type u_3\nK : Type u_4\ninst✝⁴ : CommRing A\ninst✝³ : IsDomain A\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\np : Polynomial K\n⊢ Iff (Eq (IsLocalization.integerNormalization (nonZeroDivisors A) p) 0) (Eq p 0)","decl":"theorem integerNormalization_eq_zero_iff {p : K[X]} :\n    integerNormalization (nonZeroDivisors A) p = 0 ↔ p = 0 := by\n  refine Polynomial.ext_iff.trans (Polynomial.ext_iff.trans ?_).symm\n  obtain ⟨⟨b, nonzero⟩, hb⟩ := integerNormalization_spec (nonZeroDivisors A) p\n  constructor <;> intro h i\n  · -- Porting note: avoided some defeq abuse\n    rw [coeff_zero, ← to_map_eq_zero_iff (K := K), hb i, h i, coeff_zero, smul_zero]\n  · have hi := h i\n    rw [Polynomial.coeff_zero, ← @to_map_eq_zero_iff A _ K, hb i, Algebra.smul_def] at hi\n    apply Or.resolve_left (eq_zero_or_eq_zero_of_mul_eq_zero hi)\n    intro h\n    apply mem_nonZeroDivisors_iff_ne_zero.mp nonzero\n    exact to_map_eq_zero_iff.mp h\n\n"}
{"name":"IsFractionRing.isAlgebraic_iff","module":"Mathlib.RingTheory.Localization.Integral","initialProofState":"A : Type u_3\nK : Type u_4\nC : Type u_5\ninst✝⁸ : CommRing A\ninst✝⁷ : IsDomain A\ninst✝⁶ : Field K\ninst✝⁵ : Algebra A K\ninst✝⁴ : IsFractionRing A K\ninst✝³ : CommRing C\ninst✝² : Algebra A C\ninst✝¹ : Algebra K C\ninst✝ : IsScalarTower A K C\nx : C\n⊢ Iff (IsAlgebraic A x) (IsAlgebraic K x)","decl":"/-- An element of a ring is algebraic over the ring `A` iff it is algebraic\nover the field of fractions of `A`.\n-/\ntheorem isAlgebraic_iff [Algebra A C] [Algebra K C] [IsScalarTower A K C] {x : C} :\n    IsAlgebraic A x ↔ IsAlgebraic K x := by\n  constructor <;> rintro ⟨p, hp, px⟩\n  · refine ⟨p.map (algebraMap A K), fun h => hp (Polynomial.ext fun i => ?_), ?_⟩\n    · have : algebraMap A K (p.coeff i) = 0 :=\n        _root_.trans (Polynomial.coeff_map _ _).symm (by simp [h])\n      exact to_map_eq_zero_iff.mp this\n    · exact (Polynomial.aeval_map_algebraMap K _ _).trans px\n  · exact\n      ⟨integerNormalization _ p, mt integerNormalization_eq_zero_iff.mp hp,\n        integerNormalization_aeval_eq_zero _ p px⟩\n\n"}
{"name":"IsFractionRing.comap_isAlgebraic_iff","module":"Mathlib.RingTheory.Localization.Integral","initialProofState":"A : Type u_3\nK : Type u_4\nC : Type u_5\ninst✝⁸ : CommRing A\ninst✝⁷ : IsDomain A\ninst✝⁶ : Field K\ninst✝⁵ : Algebra A K\ninst✝⁴ : IsFractionRing A K\ninst✝³ : CommRing C\ninst✝² : Algebra A C\ninst✝¹ : Algebra K C\ninst✝ : IsScalarTower A K C\n⊢ Iff (Algebra.IsAlgebraic A C) (Algebra.IsAlgebraic K C)","decl":"/-- A ring is algebraic over the ring `A` iff it is algebraic over the field of fractions of `A`.\n-/\ntheorem comap_isAlgebraic_iff [Algebra A C] [Algebra K C] [IsScalarTower A K C] :\n    Algebra.IsAlgebraic A C ↔ Algebra.IsAlgebraic K C :=\n  ⟨fun h => ⟨fun x => (isAlgebraic_iff A K C).mp (h.isAlgebraic x)⟩,\n   fun h => ⟨fun x => (isAlgebraic_iff A K C).mpr (h.isAlgebraic x)⟩⟩\n\n"}
{"name":"RingHom.isIntegralElem_localization_at_leadingCoeff","module":"Mathlib.RingTheory.Localization.Integral","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\nf : RingHom R S\nx : S\np : Polynomial R\nhf : Eq (Polynomial.eval₂ f x p) 0\nM : Submonoid R\nhM : Membership.mem M p.leadingCoeff\nRₘ : Type u_7\nSₘ : Type u_8\ninst✝⁵ : CommRing Rₘ\ninst✝⁴ : CommRing Sₘ\ninst✝³ : Algebra R Rₘ\ninst✝² : IsLocalization M Rₘ\ninst✝¹ : Algebra S Sₘ\ninst✝ : IsLocalization (Submonoid.map f M) Sₘ\n⊢ (IsLocalization.map Sₘ f ⋯).IsIntegralElem ((algebraMap S Sₘ) x)","decl":"theorem RingHom.isIntegralElem_localization_at_leadingCoeff {R S : Type*} [CommRing R] [CommRing S]\n    (f : R →+* S) (x : S) (p : R[X]) (hf : p.eval₂ f x = 0) (M : Submonoid R)\n    (hM : p.leadingCoeff ∈ M) {Rₘ Sₘ : Type*} [CommRing Rₘ] [CommRing Sₘ] [Algebra R Rₘ]\n    [IsLocalization M Rₘ] [Algebra S Sₘ] [IsLocalization (M.map f : Submonoid S) Sₘ] :\n    (map Sₘ f M.le_comap_map : Rₘ →+* _).IsIntegralElem (algebraMap S Sₘ x) := by\n  by_cases triv : (1 : Rₘ) = 0\n  · exact ⟨0, ⟨_root_.trans leadingCoeff_zero triv.symm, eval₂_zero _ _⟩⟩\n  haveI : Nontrivial Rₘ := nontrivial_of_ne 1 0 triv\n  obtain ⟨b, hb⟩ := isUnit_iff_exists_inv.mp (map_units Rₘ ⟨p.leadingCoeff, hM⟩)\n  refine ⟨p.map (algebraMap R Rₘ) * C b, ⟨?_, ?_⟩⟩\n  · refine monic_mul_C_of_leadingCoeff_mul_eq_one ?_\n    rwa [leadingCoeff_map_of_leadingCoeff_ne_zero (algebraMap R Rₘ)]\n    refine fun hfp => zero_ne_one\n      (_root_.trans (zero_mul b).symm (hfp ▸ hb) : (0 : Rₘ) = 1)\n  · refine eval₂_mul_eq_zero_of_left _ _ _ ?_\n    rw [eval₂_map, IsLocalization.map_comp, ← hom_eval₂ _ f (algebraMap S Sₘ) x]\n    exact _root_.trans (congr_arg (algebraMap S Sₘ) hf) (RingHom.map_zero _)\n\n"}
{"name":"is_integral_localization_at_leadingCoeff","module":"Mathlib.RingTheory.Localization.Integral","initialProofState":"R : Type u_1\ninst✝⁸ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝⁷ : CommRing S\ninst✝⁶ : Algebra R S\nRₘ : Type u_3\nSₘ : Type u_4\ninst✝⁵ : CommRing Rₘ\ninst✝⁴ : CommRing Sₘ\ninst✝³ : Algebra R Rₘ\ninst✝² : IsLocalization M Rₘ\ninst✝¹ : Algebra S Sₘ\ninst✝ : IsLocalization (Algebra.algebraMapSubmonoid S M) Sₘ\nx : S\np : Polynomial R\nhp : Eq ((Polynomial.aeval x) p) 0\nhM : Membership.mem M p.leadingCoeff\n⊢ (IsLocalization.map Sₘ (algebraMap R S) ⋯).IsIntegralElem ((algebraMap S Sₘ) x)","decl":"/-- Given a particular witness to an element being algebraic over an algebra `R → S`,\nWe can localize to a submonoid containing the leading coefficient to make it integral.\nExplicitly, the map between the localizations will be an integral ring morphism -/\ntheorem is_integral_localization_at_leadingCoeff {x : S} (p : R[X]) (hp : aeval x p = 0)\n    (hM : p.leadingCoeff ∈ M) :\n    (map Sₘ (algebraMap R S)\n            (show _ ≤ (Algebra.algebraMapSubmonoid S M).comap _ from M.le_comap_map) :\n          Rₘ →+* _).IsIntegralElem\n      (algebraMap S Sₘ x) :=\n  -- Porting note: added `haveI`\n  haveI : IsLocalization (Submonoid.map (algebraMap R S) M) Sₘ :=\n    inferInstanceAs (IsLocalization (Algebra.algebraMapSubmonoid S M) Sₘ)\n  (algebraMap R S).isIntegralElem_localization_at_leadingCoeff x p hp M hM\n\n"}
{"name":"isIntegral_localization","module":"Mathlib.RingTheory.Localization.Integral","initialProofState":"R : Type u_1\ninst✝⁹ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝⁸ : CommRing S\ninst✝⁷ : Algebra R S\nRₘ : Type u_3\nSₘ : Type u_4\ninst✝⁶ : CommRing Rₘ\ninst✝⁵ : CommRing Sₘ\ninst✝⁴ : Algebra R Rₘ\ninst✝³ : IsLocalization M Rₘ\ninst✝² : Algebra S Sₘ\ninst✝¹ : IsLocalization (Algebra.algebraMapSubmonoid S M) Sₘ\ninst✝ : Algebra.IsIntegral R S\n⊢ (IsLocalization.map Sₘ (algebraMap R S) ⋯).IsIntegral","decl":"/-- If `R → S` is an integral extension, `M` is a submonoid of `R`,\n`Rₘ` is the localization of `R` at `M`,\nand `Sₘ` is the localization of `S` at the image of `M` under the extension map,\nthen the induced map `Rₘ → Sₘ` is also an integral extension -/\ntheorem isIntegral_localization [Algebra.IsIntegral R S] :\n    (map Sₘ (algebraMap R S)\n          (show _ ≤ (Algebra.algebraMapSubmonoid S M).comap _ from M.le_comap_map) :\n        Rₘ →+* _).IsIntegral := by\n  intro x\n  obtain ⟨⟨s, ⟨u, hu⟩⟩, hx⟩ := surj (Algebra.algebraMapSubmonoid S M) x\n  obtain ⟨v, hv⟩ := hu\n  obtain ⟨v', hv'⟩ := isUnit_iff_exists_inv'.1 (map_units Rₘ ⟨v, hv.1⟩)\n  refine @IsIntegral.of_mul_unit Rₘ _ _ _ (localizationAlgebra M S) x (algebraMap S Sₘ u) v' ?_ ?_\n  · replace hv' := congr_arg (@algebraMap Rₘ Sₘ _ _ (localizationAlgebra M S)) hv'\n    rw [RingHom.map_mul, RingHom.map_one, ← RingHom.comp_apply _ (algebraMap R Rₘ)] at hv'\n    -- Porting note: added argument\n    erw [IsLocalization.map_comp\n      (show _ ≤ (Algebra.algebraMapSubmonoid S M).comap _ from M.le_comap_map)] at hv'\n    exact hv.2 ▸ hv'\n  · obtain ⟨p, hp⟩ := Algebra.IsIntegral.isIntegral (R := R) s\n    exact hx.symm ▸ is_integral_localization_at_leadingCoeff p hp.2 (hp.1.symm ▸ M.one_mem)\n\n"}
{"name":"isIntegral_localization'","module":"Mathlib.RingTheory.Localization.Integral","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nhf : f.IsIntegral\nM : Submonoid R\n⊢ (IsLocalization.map (Localization (Submonoid.map (↑f) M)) f ⋯).IsIntegral","decl":"@[nolint unusedHavesSuffices] -- It claims the `have : IsLocalization` line is unnecessary,\n                              -- but remove it and the proof won't work.\ntheorem isIntegral_localization' {R S : Type*} [CommRing R] [CommRing S] {f : R →+* S}\n    (hf : f.IsIntegral) (M : Submonoid R) :\n    (map (Localization (M.map (f : R →* S))) f\n          (M.le_comap_map : _ ≤ Submonoid.comap (f : R →* S) _) :\n        Localization M →+* _).IsIntegral :=\n  -- Porting note: added\n  let _ := f.toAlgebra\n  have : Algebra.IsIntegral R S := ⟨hf⟩\n  have : IsLocalization (Algebra.algebraMapSubmonoid S M)\n    (Localization (Submonoid.map (f : R →* S) M)) := Localization.isLocalization\n  isIntegral_localization\n\n"}
{"name":"IsLocalization.scaleRoots_commonDenom_mem_lifts","module":"Mathlib.RingTheory.Localization.Integral","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Submonoid R\nRₘ : Type u_3\ninst✝² : CommRing Rₘ\ninst✝¹ : Algebra R Rₘ\ninst✝ : IsLocalization M Rₘ\np : Polynomial Rₘ\nhp : Membership.mem (algebraMap R Rₘ).range p.leadingCoeff\n⊢ Membership.mem (Polynomial.lifts (algebraMap R Rₘ)) (p.scaleRoots ((algebraMap R Rₘ) ↑(IsLocalization.commonDenom M p.support p.coeff)))","decl":"theorem IsLocalization.scaleRoots_commonDenom_mem_lifts (p : Rₘ[X])\n    (hp : p.leadingCoeff ∈ (algebraMap R Rₘ).range) :\n    p.scaleRoots (algebraMap R Rₘ <| IsLocalization.commonDenom M p.support p.coeff) ∈\n      Polynomial.lifts (algebraMap R Rₘ) := by\n  rw [Polynomial.lifts_iff_coeff_lifts]\n  intro n\n  rw [Polynomial.coeff_scaleRoots]\n  by_cases h₁ : n ∈ p.support\n  on_goal 1 => by_cases h₂ : n = p.natDegree\n  · rwa [h₂, Polynomial.coeff_natDegree, tsub_self, pow_zero, _root_.mul_one]\n  · have : n + 1 ≤ p.natDegree := lt_of_le_of_ne (Polynomial.le_natDegree_of_mem_supp _ h₁) h₂\n    rw [← tsub_add_cancel_of_le (le_tsub_of_add_le_left this), pow_add, pow_one, mul_comm,\n      _root_.mul_assoc, ← map_pow]\n    change _ ∈ (algebraMap R Rₘ).range\n    apply mul_mem\n    · exact RingHom.mem_range_self _ _\n    · rw [← Algebra.smul_def]\n      exact ⟨_, IsLocalization.map_integerMultiple M p.support p.coeff ⟨n, h₁⟩⟩\n  · rw [Polynomial.not_mem_support_iff] at h₁\n    rw [h₁, zero_mul]\n    exact zero_mem (algebraMap R Rₘ).range\n\n"}
{"name":"IsIntegral.exists_multiple_integral_of_isLocalization","module":"Mathlib.RingTheory.Localization.Integral","initialProofState":"R : Type u_1\ninst✝⁷ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝⁶ : CommRing S\ninst✝⁵ : Algebra R S\nRₘ : Type u_3\ninst✝⁴ : CommRing Rₘ\ninst✝³ : Algebra R Rₘ\ninst✝² : IsLocalization M Rₘ\ninst✝¹ : Algebra Rₘ S\ninst✝ : IsScalarTower R Rₘ S\nx : S\nhx : IsIntegral Rₘ x\n⊢ Exists fun m => IsIntegral R (HSMul.hSMul m x)","decl":"theorem IsIntegral.exists_multiple_integral_of_isLocalization [Algebra Rₘ S] [IsScalarTower R Rₘ S]\n    (x : S) (hx : IsIntegral Rₘ x) : ∃ m : M, IsIntegral R (m • x) := by\n  cases' subsingleton_or_nontrivial Rₘ with _ nontriv\n  · haveI := (_root_.algebraMap Rₘ S).codomain_trivial\n    exact ⟨1, Polynomial.X, Polynomial.monic_X, Subsingleton.elim _ _⟩\n  obtain ⟨p, hp₁, hp₂⟩ := hx\n  -- Porting note: obtain doesn't support side goals\n  have :=\n    lifts_and_natDegree_eq_and_monic (IsLocalization.scaleRoots_commonDenom_mem_lifts M p ?_) ?_\n  · obtain ⟨p', hp'₁, -, hp'₂⟩ := this\n    refine ⟨IsLocalization.commonDenom M p.support p.coeff, p', hp'₂, ?_⟩\n    rw [IsScalarTower.algebraMap_eq R Rₘ S, ← Polynomial.eval₂_map, hp'₁, Submonoid.smul_def,\n      Algebra.smul_def, IsScalarTower.algebraMap_apply R Rₘ S]\n    exact Polynomial.scaleRoots_eval₂_eq_zero _ hp₂\n  · rw [hp₁.leadingCoeff]\n    exact one_mem _\n  · rwa [Polynomial.monic_scaleRoots_iff]\n\n"}
{"name":"IsIntegralClosure.isFractionRing_of_algebraic","module":"Mathlib.RingTheory.Localization.Integral","initialProofState":"A : Type u_3\ninst✝⁹ : CommRing A\nL : Type u_5\ninst✝⁸ : Field L\ninst✝⁷ : Algebra A L\nC : Type u_6\ninst✝⁶ : CommRing C\ninst✝⁵ : IsDomain C\ninst✝⁴ : Algebra C L\ninst✝³ : IsIntegralClosure C A L\ninst✝² : Algebra A C\ninst✝¹ : IsScalarTower A C L\ninst✝ : Algebra.IsAlgebraic A L\ninj : ∀ (x : A), Eq ((algebraMap A L) x) 0 → Eq x 0\n⊢ IsFractionRing C L","decl":"/-- If the field `L` is an algebraic extension of the integral domain `A`,\nthe integral closure `C` of `A` in `L` has fraction field `L`. -/\ntheorem isFractionRing_of_algebraic [Algebra.IsAlgebraic A L]\n    (inj : ∀ x, algebraMap A L x = 0 → x = 0) : IsFractionRing C L :=\n  { map_units' := fun ⟨y, hy⟩ =>\n      IsUnit.mk0 _\n        (show algebraMap C L y ≠ 0 from fun h =>\n          mem_nonZeroDivisors_iff_ne_zero.mp hy\n            ((injective_iff_map_eq_zero (algebraMap C L)).mp (algebraMap_injective C A L) _ h))\n    surj' := fun z =>\n      let ⟨x, hx, int⟩ := (Algebra.IsAlgebraic.isAlgebraic z).exists_integral_multiple\n        ((injective_iff_map_eq_zero _).mpr inj)\n      ⟨⟨mk' C _ int, algebraMap _ _ x, mem_nonZeroDivisors_of_ne_zero fun h ↦\n        hx (inj _ <| by rw [IsScalarTower.algebraMap_apply A C L, h, RingHom.map_zero])⟩, by\n        rw [algebraMap_mk', ← IsScalarTower.algebraMap_apply A C L, Algebra.smul_def, mul_comm]⟩\n    exists_of_eq := fun {x y} h => ⟨1, by simpa using algebraMap_injective C A L h⟩ }\n\n"}
{"name":"IsIntegralClosure.isFractionRing_of_finite_extension","module":"Mathlib.RingTheory.Localization.Integral","initialProofState":"A : Type u_3\nK : Type u_4\ninst✝¹⁵ : CommRing A\nL : Type u_5\ninst✝¹⁴ : Field K\ninst✝¹³ : Field L\ninst✝¹² : Algebra A K\ninst✝¹¹ : Algebra A L\ninst✝¹⁰ : IsFractionRing A K\nC : Type u_6\ninst✝⁹ : CommRing C\ninst✝⁸ : IsDomain C\ninst✝⁷ : Algebra C L\ninst✝⁶ : IsIntegralClosure C A L\ninst✝⁵ : Algebra A C\ninst✝⁴ : IsScalarTower A C L\ninst✝³ : IsDomain A\ninst✝² : Algebra K L\ninst✝¹ : IsScalarTower A K L\ninst✝ : FiniteDimensional K L\n⊢ IsFractionRing C L","decl":"/-- If the field `L` is a finite extension of the fraction field of the integral domain `A`,\nthe integral closure `C` of `A` in `L` has fraction field `L`. -/\ntheorem isFractionRing_of_finite_extension [IsDomain A] [Algebra K L] [IsScalarTower A K L]\n    [FiniteDimensional K L] : IsFractionRing C L :=\n  have : Algebra.IsAlgebraic A L := IsFractionRing.comap_isAlgebraic_iff.mpr\n    (inferInstanceAs (Algebra.IsAlgebraic K L))\n  isFractionRing_of_algebraic A C\n    fun _ hx =>\n    IsFractionRing.to_map_eq_zero_iff.mp\n      ((map_eq_zero <| algebraMap K L).mp <| (IsScalarTower.algebraMap_apply _ _ _ _).symm.trans hx)\n\n"}
{"name":"integralClosure.isFractionRing_of_algebraic","module":"Mathlib.RingTheory.Localization.Integral","initialProofState":"A : Type u_3\ninst✝³ : CommRing A\nL : Type u_5\ninst✝² : Field L\ninst✝¹ : Algebra A L\ninst✝ : Algebra.IsAlgebraic A L\ninj : ∀ (x : A), Eq ((algebraMap A L) x) 0 → Eq x 0\n⊢ IsFractionRing (Subtype fun x => Membership.mem (integralClosure A L) x) L","decl":"/-- If the field `L` is an algebraic extension of the integral domain `A`,\nthe integral closure of `A` in `L` has fraction field `L`. -/\ntheorem isFractionRing_of_algebraic [Algebra A L] [Algebra.IsAlgebraic A L]\n    (inj : ∀ x, algebraMap A L x = 0 → x = 0) : IsFractionRing (integralClosure A L) L :=\n  IsIntegralClosure.isFractionRing_of_algebraic A (integralClosure A L) inj\n\n"}
{"name":"integralClosure.isFractionRing_of_finite_extension","module":"Mathlib.RingTheory.Localization.Integral","initialProofState":"A : Type u_3\nK : Type u_4\ninst✝⁹ : CommRing A\nL : Type u_5\ninst✝⁸ : Field K\ninst✝⁷ : Field L\ninst✝⁶ : Algebra A K\ninst✝⁵ : IsFractionRing A K\ninst✝⁴ : IsDomain A\ninst✝³ : Algebra A L\ninst✝² : Algebra K L\ninst✝¹ : IsScalarTower A K L\ninst✝ : FiniteDimensional K L\n⊢ IsFractionRing (Subtype fun x => Membership.mem (integralClosure A L) x) L","decl":"/-- If the field `L` is a finite extension of the fraction field of the integral domain `A`,\nthe integral closure of `A` in `L` has fraction field `L`. -/\ntheorem isFractionRing_of_finite_extension [IsDomain A] [Algebra A L] [Algebra K L]\n    [IsScalarTower A K L] [FiniteDimensional K L] : IsFractionRing (integralClosure A L) L :=\n  IsIntegralClosure.isFractionRing_of_finite_extension A K L (integralClosure A L)\n\n"}
{"name":"IsFractionRing.isAlgebraic_iff'","module":"Mathlib.RingTheory.Localization.Integral","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommRing R\nS : Type u_2\ninst✝⁹ : CommRing S\ninst✝⁸ : Algebra R S\nK : Type u_4\ninst✝⁷ : Field K\ninst✝⁶ : IsDomain R\ninst✝⁵ : IsDomain S\ninst✝⁴ : Algebra R K\ninst✝³ : Algebra S K\ninst✝² : NoZeroSMulDivisors R K\ninst✝¹ : IsFractionRing S K\ninst✝ : IsScalarTower R S K\n⊢ Iff (Algebra.IsAlgebraic R S) (Algebra.IsAlgebraic R K)","decl":"/-- `S` is algebraic over `R` iff a fraction ring of `S` is algebraic over `R` -/\ntheorem isAlgebraic_iff' [Field K] [IsDomain R] [IsDomain S] [Algebra R K] [Algebra S K]\n    [NoZeroSMulDivisors R K] [IsFractionRing S K] [IsScalarTower R S K] :\n    Algebra.IsAlgebraic R S ↔ Algebra.IsAlgebraic R K := by\n  simp only [Algebra.isAlgebraic_def]\n  constructor\n  · intro h x\n    letI := FractionRing.liftAlgebra R K\n    have := FractionRing.isScalarTower_liftAlgebra R K\n    rw [IsFractionRing.isAlgebraic_iff R (FractionRing R) K, isAlgebraic_iff_isIntegral]\n    obtain ⟨a : S, b, ha, rfl⟩ := div_surjective (A := S) x\n    obtain ⟨f, hf₁, hf₂⟩ := h b\n    rw [div_eq_mul_inv]\n    refine IsIntegral.mul ?_ ?_\n    · rw [← isAlgebraic_iff_isIntegral]\n      refine .extendScalars\n        (NoZeroSMulDivisors.algebraMap_injective R (FractionRing R)) ?_\n      exact .algebraMap (h a)\n    · rw [← isAlgebraic_iff_isIntegral]\n      use (f.map (algebraMap R (FractionRing R))).reverse\n      constructor\n      · rwa [Ne, Polynomial.reverse_eq_zero, ← Polynomial.degree_eq_bot,\n          Polynomial.degree_map_eq_of_injective\n            (NoZeroSMulDivisors.algebraMap_injective R (FractionRing R)),\n          Polynomial.degree_eq_bot]\n      · have : Invertible (algebraMap S K b) :=\n          IsUnit.invertible\n            (isUnit_of_mem_nonZeroDivisors\n              (mem_nonZeroDivisors_iff_ne_zero.2 fun h =>\n                nonZeroDivisors.ne_zero ha\n                  ((injective_iff_map_eq_zero (algebraMap S K)).1\n                    (NoZeroSMulDivisors.algebraMap_injective _ _) b h)))\n        rw [Polynomial.aeval_def, ← invOf_eq_inv, Polynomial.eval₂_reverse_eq_zero_iff,\n          Polynomial.eval₂_map, ← IsScalarTower.algebraMap_eq, ← Polynomial.aeval_def,\n          Polynomial.aeval_algebraMap_apply, hf₂, RingHom.map_zero]\n  · intro h x\n    obtain ⟨f, hf₁, hf₂⟩ := h (algebraMap S K x)\n    use f, hf₁\n    rw [Polynomial.aeval_algebraMap_apply] at hf₂\n    exact\n      (injective_iff_map_eq_zero (algebraMap S K)).1 (NoZeroSMulDivisors.algebraMap_injective _ _) _\n        hf₂\n\n"}
{"name":"IsFractionRing.ideal_span_singleton_map_subset","module":"Mathlib.RingTheory.Localization.Integral","initialProofState":"R : Type u_1\ninst✝¹⁴ : CommRing R\nS : Type u_2\ninst✝¹³ : CommRing S\ninst✝¹² : Algebra R S\nK : Type u_4\nL : Type u_5\ninst✝¹¹ : IsDomain R\ninst✝¹⁰ : IsDomain S\ninst✝⁹ : Field K\ninst✝⁸ : Field L\ninst✝⁷ : Algebra R K\ninst✝⁶ : Algebra R L\ninst✝⁵ : Algebra S L\ninst✝⁴ : Algebra.IsAlgebraic R S\ninst✝³ : IsFractionRing S L\ninst✝² : Algebra K L\ninst✝¹ : IsScalarTower R S L\ninst✝ : IsScalarTower R K L\na : S\nb : Set S\ninj : Function.Injective ⇑(algebraMap R L)\nh : HasSubset.Subset ↑(Ideal.span (Singleton.singleton a)) ↑(Submodule.span R b)\n⊢ HasSubset.Subset ↑(Ideal.span (Singleton.singleton ((algebraMap S L) a))) ↑(Submodule.span K (Set.image (⇑(algebraMap S L)) b))","decl":"/-- If the `S`-multiples of `a` are contained in some `R`-span, then `Frac(S)`-multiples of `a`\nare contained in the equivalent `Frac(R)`-span. -/\ntheorem ideal_span_singleton_map_subset {L : Type*} [IsDomain R] [IsDomain S] [Field K] [Field L]\n    [Algebra R K] [Algebra R L] [Algebra S L] [Algebra.IsAlgebraic R S] [IsFractionRing S L]\n    [Algebra K L] [IsScalarTower R S L] [IsScalarTower R K L] {a : S} {b : Set S}\n    (inj : Function.Injective (algebraMap R L))\n    (h : (Ideal.span ({a} : Set S) : Set S) ⊆ Submodule.span R b) :\n    (Ideal.span ({algebraMap S L a} : Set L) : Set L) ⊆ Submodule.span K (algebraMap S L '' b) := by\n  intro x hx\n  obtain ⟨x', rfl⟩ := Ideal.mem_span_singleton.mp hx\n  obtain ⟨y', z', rfl⟩ := IsLocalization.mk'_surjective S⁰ x'\n  obtain ⟨y, z, hz0, yz_eq⟩ :=\n    Algebra.IsAlgebraic.exists_smul_eq_mul R y' (nonZeroDivisors.coe_ne_zero z')\n  have injRS : Function.Injective (algebraMap R S) := by\n    refine\n      Function.Injective.of_comp (show Function.Injective (algebraMap S L ∘ algebraMap R S) from ?_)\n    rwa [← RingHom.coe_comp, ← IsScalarTower.algebraMap_eq]\n  have hz0' : algebraMap R S z ∈ S⁰ :=\n    map_mem_nonZeroDivisors (algebraMap R S) injRS (mem_nonZeroDivisors_of_ne_zero hz0)\n  have mk_yz_eq : IsLocalization.mk' L y' z' = IsLocalization.mk' L y ⟨_, hz0'⟩ := by\n    rw [Algebra.smul_def, mul_comm _ y, mul_comm _ y'] at yz_eq\n    exact IsLocalization.mk'_eq_of_eq (by rw [mul_comm _ y, mul_comm _ y', yz_eq])\n  suffices hy : algebraMap S L (a * y) ∈ Submodule.span K ((algebraMap S L) '' b) by\n    rw [mk_yz_eq, IsFractionRing.mk'_eq_div, ← IsScalarTower.algebraMap_apply,\n      IsScalarTower.algebraMap_apply R K L, div_eq_mul_inv, ← mul_assoc, mul_comm, ← map_inv₀, ←\n      Algebra.smul_def, ← _root_.map_mul]\n    exact (Submodule.span K _).smul_mem _ hy\n  refine Submodule.span_subset_span R K _ ?_\n  rw [Submodule.span_algebraMap_image_of_tower]\n  -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to specify the value of `f` here:\n  exact Submodule.mem_map_of_mem (f := LinearMap.restrictScalars _ _)\n    (h (Ideal.mem_span_singleton.mpr ⟨y, rfl⟩))\n\n"}
{"name":"isAlgebraic_of_isLocalization","module":"Mathlib.RingTheory.Localization.Integral","initialProofState":"R : Type u_5\ninst✝⁴ : CommRing R\nM : Submonoid R\nS : Type u_6\ninst✝³ : CommRing S\ninst✝² : Nontrivial R\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\n⊢ Algebra.IsAlgebraic R S","decl":"lemma isAlgebraic_of_isLocalization {R} [CommRing R] (M : Submonoid R) (S) [CommRing S]\n    [Nontrivial R] [Algebra R S] [IsLocalization M S] : Algebra.IsAlgebraic R S := by\n  constructor\n  intro x\n  obtain ⟨x, s, rfl⟩ := IsLocalization.mk'_surjective M x\n  by_cases hs : (s : R) = 0\n  · have := IsLocalization.mk'_spec S x s\n    rw [hs, map_zero, mul_zero] at this\n    exact ⟨X, X_ne_zero, by simp [IsLocalization.mk'_eq_mul_mk'_one x, ← this]⟩\n  refine ⟨s • X - C x, ?_, ?_⟩\n  · intro e; apply hs\n    simpa only [coeff_sub, coeff_smul, coeff_X_one, coeff_C_succ, sub_zero, coeff_zero,\n      ← Algebra.algebraMap_eq_smul_one, Submonoid.smul_def,\n      Algebra.id.map_eq_id, RingHom.id_apply] using congr_arg (Polynomial.coeff · 1) e\n  · simp only [map_sub, Algebra.smul_def, Submonoid.smul_def,\n      map_mul, AlgHom.commutes, aeval_X, IsLocalization.mk'_spec', aeval_C, sub_self]\n\n"}
{"name":"isAlgebraic_of_isFractionRing","module":"Mathlib.RingTheory.Localization.Integral","initialProofState":"R : Type u_5\nS : Type u_6\nK : Type u_7\nL : Type u_8\ninst✝¹² : CommRing R\ninst✝¹¹ : CommRing S\ninst✝¹⁰ : Field K\ninst✝⁹ : CommRing L\ninst✝⁸ : Algebra R S\ninst✝⁷ : Algebra R K\ninst✝⁶ : Algebra R L\ninst✝⁵ : Algebra S L\ninst✝⁴ : Algebra K L\ninst✝³ : IsScalarTower R S L\ninst✝² : IsScalarTower R K L\ninst✝¹ : IsFractionRing S L\ninst✝ : Algebra.IsIntegral R S\n⊢ Algebra.IsAlgebraic K L","decl":"open nonZeroDivisors in\nlemma isAlgebraic_of_isFractionRing {R S} (K L) [CommRing R] [CommRing S] [Field K] [CommRing L]\n    [Algebra R S] [Algebra R K] [Algebra R L] [Algebra S L] [Algebra K L] [IsScalarTower R S L]\n    [IsScalarTower R K L] [IsFractionRing S L]\n    [Algebra.IsIntegral R S] : Algebra.IsAlgebraic K L := by\n  constructor\n  intro x\n  obtain ⟨x, s, rfl⟩ := IsLocalization.mk'_surjective S⁰ x\n  apply IsIntegral.isAlgebraic\n  rw [IsLocalization.mk'_eq_mul_mk'_one]\n  apply RingHom.IsIntegralElem.mul\n  · apply IsIntegral.tower_top (R := R)\n    apply IsIntegral.map (IsScalarTower.toAlgHom R S L)\n    exact Algebra.IsIntegral.isIntegral x\n  · show IsIntegral _ _\n    rw [← isAlgebraic_iff_isIntegral, ← IsAlgebraic.invOf_iff, isAlgebraic_iff_isIntegral]\n    apply IsIntegral.tower_top (R := R)\n    apply IsIntegral.map (IsScalarTower.toAlgHom R S L)\n    exact Algebra.IsIntegral.isIntegral (s : S)\n"}
