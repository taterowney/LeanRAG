{"name":"CategoryTheory.Idempotents.natTrans_eq","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nF G : CategoryTheory.Functor (CategoryTheory.Idempotents.Karoubi C) D\nœÜ : Quiver.Hom F G\nP : CategoryTheory.Idempotents.Karoubi C\n‚ä¢ Eq (œÜ.app P) (CategoryTheory.CategoryStruct.comp (F.map P.decompId_i) (CategoryTheory.CategoryStruct.comp (œÜ.app { X := P.X, p := CategoryTheory.CategoryStruct.id P.X, idem := ‚ãØ }) (G.map P.decompId_p)))","decl":"/-- A natural transformation between functors `Karoubi C ‚•§ D` is determined\nby its value on objects coming from `C`. -/\ntheorem natTrans_eq {F G : Karoubi C ‚•§ D} (œÜ : F ‚ü∂ G) (P : Karoubi C) :\n    œÜ.app P = F.map (decompId_i P) ‚â´ œÜ.app P.X ‚â´ G.map (decompId_p P) := by\n  rw [‚Üê œÜ.naturality, ‚Üê assoc, ‚Üê F.map_comp]\n  conv_lhs => rw [‚Üê id_comp (œÜ.app P), ‚Üê F.map_id]\n  congr\n  apply decompId\n\n"}
{"name":"CategoryTheory.Idempotents.FunctorExtension‚ÇÅ.obj_map_f","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C (CategoryTheory.Idempotents.Karoubi D)\nX‚úù Y‚úù : CategoryTheory.Idempotents.Karoubi C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Idempotents.FunctorExtension‚ÇÅ.obj F).map f).f (F.map f.f).f","decl":"/-- The canonical extension of a functor `C ‚•§ Karoubi D` to a functor\n`Karoubi C ‚•§ Karoubi D` -/\n@[simps]\ndef obj (F : C ‚•§ Karoubi D) : Karoubi C ‚•§ Karoubi D where\n  obj P :=\n    ‚ü®(F.obj P.X).X, (F.map P.p).f, by simpa only [F.map_comp, hom_ext_iff] using F.congr_map P.idem‚ü©\n  map f := ‚ü®(F.map f.f).f, by simpa only [F.map_comp, hom_ext_iff] using F.congr_map f.comm‚ü©\n\n"}
{"name":"CategoryTheory.Idempotents.FunctorExtension‚ÇÅ.obj_obj_p","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C (CategoryTheory.Idempotents.Karoubi D)\nP : CategoryTheory.Idempotents.Karoubi C\n‚ä¢ Eq ((CategoryTheory.Idempotents.FunctorExtension‚ÇÅ.obj F).obj P).p (F.map P.p).f","decl":"/-- The canonical extension of a functor `C ‚•§ Karoubi D` to a functor\n`Karoubi C ‚•§ Karoubi D` -/\n@[simps]\ndef obj (F : C ‚•§ Karoubi D) : Karoubi C ‚•§ Karoubi D where\n  obj P :=\n    ‚ü®(F.obj P.X).X, (F.map P.p).f, by simpa only [F.map_comp, hom_ext_iff] using F.congr_map P.idem‚ü©\n  map f := ‚ü®(F.map f.f).f, by simpa only [F.map_comp, hom_ext_iff] using F.congr_map f.comm‚ü©\n\n"}
{"name":"CategoryTheory.Idempotents.FunctorExtension‚ÇÅ.obj_obj_X","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C (CategoryTheory.Idempotents.Karoubi D)\nP : CategoryTheory.Idempotents.Karoubi C\n‚ä¢ Eq ((CategoryTheory.Idempotents.FunctorExtension‚ÇÅ.obj F).obj P).X (F.obj P.X).X","decl":"/-- The canonical extension of a functor `C ‚•§ Karoubi D` to a functor\n`Karoubi C ‚•§ Karoubi D` -/\n@[simps]\ndef obj (F : C ‚•§ Karoubi D) : Karoubi C ‚•§ Karoubi D where\n  obj P :=\n    ‚ü®(F.obj P.X).X, (F.map P.p).f, by simpa only [F.map_comp, hom_ext_iff] using F.congr_map P.idem‚ü©\n  map f := ‚ü®(F.map f.f).f, by simpa only [F.map_comp, hom_ext_iff] using F.congr_map f.comm‚ü©\n\n"}
{"name":"CategoryTheory.Idempotents.FunctorExtension‚ÇÅ.map_app_f","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nF G : CategoryTheory.Functor C (CategoryTheory.Idempotents.Karoubi D)\nœÜ : Quiver.Hom F G\nP : CategoryTheory.Idempotents.Karoubi C\n‚ä¢ Eq ((CategoryTheory.Idempotents.FunctorExtension‚ÇÅ.map œÜ).app P).f (CategoryTheory.CategoryStruct.comp (F.map P.p).f (œÜ.app P.X).f)","decl":"/-- Extension of a natural transformation `œÜ` between functors\n`C ‚•§ karoubi D` to a natural transformation between the\nextension of these functors to `karoubi C ‚•§ karoubi D` -/\n@[simps]\ndef map {F G : C ‚•§ Karoubi D} (œÜ : F ‚ü∂ G) : obj F ‚ü∂ obj G where\n  app P :=\n    { f := (F.map P.p).f ‚â´ (œÜ.app P.X).f\n      comm := by\n        have h := œÜ.naturality P.p\n        have h' := F.congr_map P.idem\n        simp only [hom_ext_iff, Karoubi.comp_f, F.map_comp] at h h'\n        simp only [obj_obj_p, assoc, ‚Üê h]\n        slice_rhs 1 3 => rw [h', h'] }\n  naturality _ _ f := by\n    ext\n    dsimp [obj]\n    have h := œÜ.naturality f.f\n    have h' := F.congr_map (comp_p f)\n    have h'' := F.congr_map (p_comp f)\n    simp only [hom_ext_iff, Functor.map_comp, comp_f] at h h' h'' ‚ä¢\n    slice_rhs 2 3 => rw [‚Üê h]\n    slice_lhs 1 2 => rw [h']\n    slice_rhs 1 2 => rw [h'']\n\n"}
{"name":"CategoryTheory.Idempotents.functorExtension‚ÇÅ_obj","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C (CategoryTheory.Idempotents.Karoubi D)\n‚ä¢ Eq ((CategoryTheory.Idempotents.functorExtension‚ÇÅ C D).obj F) (CategoryTheory.Idempotents.FunctorExtension‚ÇÅ.obj F)","decl":"/-- The canonical functor `(C ‚•§ Karoubi D) ‚•§ (Karoubi C ‚•§ Karoubi D)` -/\n@[simps]\ndef functorExtension‚ÇÅ : (C ‚•§ Karoubi D) ‚•§ Karoubi C ‚•§ Karoubi D where\n  obj := FunctorExtension‚ÇÅ.obj\n  map := FunctorExtension‚ÇÅ.map\n  map_id F := by\n    ext P\n    exact comp_p (F.map P.p)\n  map_comp {F G H} œÜ œÜ' := by\n    ext P\n    simp only [comp_f, FunctorExtension‚ÇÅ.map_app_f, NatTrans.comp_app, assoc]\n    have h := œÜ.naturality P.p\n    have h' := F.congr_map P.idem\n    simp only [hom_ext_iff, comp_f, F.map_comp] at h h'\n    slice_rhs 2 3 => rw [‚Üê h]\n    slice_rhs 1 2 => rw [h']\n    simp only [assoc]\n\n"}
{"name":"CategoryTheory.Idempotents.functorExtension‚ÇÅ_map","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nX‚úù Y‚úù : CategoryTheory.Functor C (CategoryTheory.Idempotents.Karoubi D)\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Idempotents.functorExtension‚ÇÅ C D).map œÜ) (CategoryTheory.Idempotents.FunctorExtension‚ÇÅ.map œÜ)","decl":"/-- The canonical functor `(C ‚•§ Karoubi D) ‚•§ (Karoubi C ‚•§ Karoubi D)` -/\n@[simps]\ndef functorExtension‚ÇÅ : (C ‚•§ Karoubi D) ‚•§ Karoubi C ‚•§ Karoubi D where\n  obj := FunctorExtension‚ÇÅ.obj\n  map := FunctorExtension‚ÇÅ.map\n  map_id F := by\n    ext P\n    exact comp_p (F.map P.p)\n  map_comp {F G H} œÜ œÜ' := by\n    ext P\n    simp only [comp_f, FunctorExtension‚ÇÅ.map_app_f, NatTrans.comp_app, assoc]\n    have h := œÜ.naturality P.p\n    have h' := F.congr_map P.idem\n    simp only [hom_ext_iff, comp_f, F.map_comp] at h h'\n    slice_rhs 2 3 => rw [‚Üê h]\n    slice_rhs 1 2 => rw [h']\n    simp only [assoc]\n\n"}
{"name":"CategoryTheory.Idempotents.functorExtension‚ÇÅCompWhiskeringLeftToKaroubiIso_hom_app_app_f","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nX‚úù : CategoryTheory.Functor C (CategoryTheory.Idempotents.Karoubi D)\nX : C\n‚ä¢ Eq (((CategoryTheory.Idempotents.functorExtension‚ÇÅCompWhiskeringLeftToKaroubiIso C D).hom.app X‚úù).app X).f (X‚úù.obj X).p","decl":"/-- The natural isomorphism expressing that functors `Karoubi C ‚•§ Karoubi D` obtained\nusing `functorExtension‚ÇÅ` actually extends the original functors `C ‚•§ Karoubi D`. -/\n@[simps!]\ndef functorExtension‚ÇÅCompWhiskeringLeftToKaroubiIso :\n    functorExtension‚ÇÅ C D ‚ãô (whiskeringLeft C (Karoubi C) (Karoubi D)).obj (toKaroubi C) ‚âÖ ùü≠ _ :=\n  NatIso.ofComponents\n    (fun F => NatIso.ofComponents\n      (fun X =>\n        { hom := { f := (F.obj X).p }\n          inv := { f := (F.obj X).p } })\n      (fun {X Y} f => by simp))\n    (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Idempotents.functorExtension‚ÇÅCompWhiskeringLeftToKaroubiIso_inv_app_app_f","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nX‚úù : CategoryTheory.Functor C (CategoryTheory.Idempotents.Karoubi D)\nX : C\n‚ä¢ Eq (((CategoryTheory.Idempotents.functorExtension‚ÇÅCompWhiskeringLeftToKaroubiIso C D).inv.app X‚úù).app X).f (X‚úù.obj X).p","decl":"/-- The natural isomorphism expressing that functors `Karoubi C ‚•§ Karoubi D` obtained\nusing `functorExtension‚ÇÅ` actually extends the original functors `C ‚•§ Karoubi D`. -/\n@[simps!]\ndef functorExtension‚ÇÅCompWhiskeringLeftToKaroubiIso :\n    functorExtension‚ÇÅ C D ‚ãô (whiskeringLeft C (Karoubi C) (Karoubi D)).obj (toKaroubi C) ‚âÖ ùü≠ _ :=\n  NatIso.ofComponents\n    (fun F => NatIso.ofComponents\n      (fun X =>\n        { hom := { f := (F.obj X).p }\n          inv := { f := (F.obj X).p } })\n      (fun {X Y} f => by simp))\n    (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Idempotents.KaroubiUniversal‚ÇÅ.counitIso_hom_app_app_f","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nX : CategoryTheory.Functor (CategoryTheory.Idempotents.Karoubi C) (CategoryTheory.Idempotents.Karoubi D)\nP : CategoryTheory.Idempotents.Karoubi C\n‚ä¢ Eq (((CategoryTheory.Idempotents.KaroubiUniversal‚ÇÅ.counitIso C D).hom.app X).app P).f (X.map P.decompId_p).f","decl":"attribute [simps!] KaroubiUniversal‚ÇÅ.counitIso\n\n"}
{"name":"CategoryTheory.Idempotents.KaroubiUniversal‚ÇÅ.counitIso_inv_app_app_f","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nX : CategoryTheory.Functor (CategoryTheory.Idempotents.Karoubi C) (CategoryTheory.Idempotents.Karoubi D)\nP : CategoryTheory.Idempotents.Karoubi C\n‚ä¢ Eq (((CategoryTheory.Idempotents.KaroubiUniversal‚ÇÅ.counitIso C D).inv.app X).app P).f (X.map P.decompId_i).f","decl":"attribute [simps!] KaroubiUniversal‚ÇÅ.counitIso\n\n"}
{"name":"CategoryTheory.Idempotents.karoubiUniversal‚ÇÅ_unitIso","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\n‚ä¢ Eq (CategoryTheory.Idempotents.karoubiUniversal‚ÇÅ C D).unitIso (CategoryTheory.Idempotents.functorExtension‚ÇÅCompWhiskeringLeftToKaroubiIso C D).symm","decl":"/-- The equivalence of categories `(C ‚•§ Karoubi D) ‚âå (Karoubi C ‚•§ Karoubi D)`. -/\n@[simps]\ndef karoubiUniversal‚ÇÅ : C ‚•§ Karoubi D ‚âå Karoubi C ‚•§ Karoubi D where\n  functor := functorExtension‚ÇÅ C D\n  inverse := (whiskeringLeft C (Karoubi C) (Karoubi D)).obj (toKaroubi C)\n  unitIso := (functorExtension‚ÇÅCompWhiskeringLeftToKaroubiIso C D).symm\n  counitIso := KaroubiUniversal‚ÇÅ.counitIso C D\n  functor_unitIso_comp F := by\n    ext P\n    dsimp\n    rw [comp_p, ‚Üê comp_f, ‚Üê F.map_comp, P.idem]\n\n"}
{"name":"CategoryTheory.Idempotents.karoubiUniversal‚ÇÅ_functor","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\n‚ä¢ Eq (CategoryTheory.Idempotents.karoubiUniversal‚ÇÅ C D).functor (CategoryTheory.Idempotents.functorExtension‚ÇÅ C D)","decl":"/-- The equivalence of categories `(C ‚•§ Karoubi D) ‚âå (Karoubi C ‚•§ Karoubi D)`. -/\n@[simps]\ndef karoubiUniversal‚ÇÅ : C ‚•§ Karoubi D ‚âå Karoubi C ‚•§ Karoubi D where\n  functor := functorExtension‚ÇÅ C D\n  inverse := (whiskeringLeft C (Karoubi C) (Karoubi D)).obj (toKaroubi C)\n  unitIso := (functorExtension‚ÇÅCompWhiskeringLeftToKaroubiIso C D).symm\n  counitIso := KaroubiUniversal‚ÇÅ.counitIso C D\n  functor_unitIso_comp F := by\n    ext P\n    dsimp\n    rw [comp_p, ‚Üê comp_f, ‚Üê F.map_comp, P.idem]\n\n"}
{"name":"CategoryTheory.Idempotents.karoubiUniversal‚ÇÅ_counitIso","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\n‚ä¢ Eq (CategoryTheory.Idempotents.karoubiUniversal‚ÇÅ C D).counitIso (CategoryTheory.Idempotents.KaroubiUniversal‚ÇÅ.counitIso C D)","decl":"/-- The equivalence of categories `(C ‚•§ Karoubi D) ‚âå (Karoubi C ‚•§ Karoubi D)`. -/\n@[simps]\ndef karoubiUniversal‚ÇÅ : C ‚•§ Karoubi D ‚âå Karoubi C ‚•§ Karoubi D where\n  functor := functorExtension‚ÇÅ C D\n  inverse := (whiskeringLeft C (Karoubi C) (Karoubi D)).obj (toKaroubi C)\n  unitIso := (functorExtension‚ÇÅCompWhiskeringLeftToKaroubiIso C D).symm\n  counitIso := KaroubiUniversal‚ÇÅ.counitIso C D\n  functor_unitIso_comp F := by\n    ext P\n    dsimp\n    rw [comp_p, ‚Üê comp_f, ‚Üê F.map_comp, P.idem]\n\n"}
{"name":"CategoryTheory.Idempotents.karoubiUniversal‚ÇÅ_inverse","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\n‚ä¢ Eq (CategoryTheory.Idempotents.karoubiUniversal‚ÇÅ C D).inverse ((CategoryTheory.whiskeringLeft C (CategoryTheory.Idempotents.Karoubi C) (CategoryTheory.Idempotents.Karoubi D)).obj (CategoryTheory.Idempotents.toKaroubi C))","decl":"/-- The equivalence of categories `(C ‚•§ Karoubi D) ‚âå (Karoubi C ‚•§ Karoubi D)`. -/\n@[simps]\ndef karoubiUniversal‚ÇÅ : C ‚•§ Karoubi D ‚âå Karoubi C ‚•§ Karoubi D where\n  functor := functorExtension‚ÇÅ C D\n  inverse := (whiskeringLeft C (Karoubi C) (Karoubi D)).obj (toKaroubi C)\n  unitIso := (functorExtension‚ÇÅCompWhiskeringLeftToKaroubiIso C D).symm\n  counitIso := KaroubiUniversal‚ÇÅ.counitIso C D\n  functor_unitIso_comp F := by\n    ext P\n    dsimp\n    rw [comp_p, ‚Üê comp_f, ‚Üê F.map_comp, P.idem]\n\n"}
{"name":"CategoryTheory.Idempotents.functorExtension‚ÇÇ_obj_map_f","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nX : CategoryTheory.Functor C D\nX‚úù Y‚úù : CategoryTheory.Idempotents.Karoubi C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((CategoryTheory.Idempotents.functorExtension‚ÇÇ C D).obj X).map f).f (X.map f.f)","decl":"/-- The canonical functor `(C ‚•§ D) ‚•§ (Karoubi C ‚•§ Karoubi D)` -/\n@[simps!]\ndef functorExtension‚ÇÇ : (C ‚•§ D) ‚•§ Karoubi C ‚•§ Karoubi D :=\n  (whiskeringRight C D (Karoubi D)).obj (toKaroubi D) ‚ãô functorExtension‚ÇÅ C D\n\n"}
{"name":"CategoryTheory.Idempotents.functorExtension‚ÇÇ_obj_obj_X","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nX : CategoryTheory.Functor C D\nP : CategoryTheory.Idempotents.Karoubi C\n‚ä¢ Eq (((CategoryTheory.Idempotents.functorExtension‚ÇÇ C D).obj X).obj P).X (X.obj P.X)","decl":"/-- The canonical functor `(C ‚•§ D) ‚•§ (Karoubi C ‚•§ Karoubi D)` -/\n@[simps!]\ndef functorExtension‚ÇÇ : (C ‚•§ D) ‚•§ Karoubi C ‚•§ Karoubi D :=\n  (whiskeringRight C D (Karoubi D)).obj (toKaroubi D) ‚ãô functorExtension‚ÇÅ C D\n\n"}
{"name":"CategoryTheory.Idempotents.functorExtension‚ÇÇ_map_app_f","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nX‚úù Y‚úù : CategoryTheory.Functor C D\nf : Quiver.Hom X‚úù Y‚úù\nP : CategoryTheory.Idempotents.Karoubi C\n‚ä¢ Eq (((CategoryTheory.Idempotents.functorExtension‚ÇÇ C D).map f).app P).f (CategoryTheory.CategoryStruct.comp (f.app P.X) (Y‚úù.map P.p))","decl":"/-- The canonical functor `(C ‚•§ D) ‚•§ (Karoubi C ‚•§ Karoubi D)` -/\n@[simps!]\ndef functorExtension‚ÇÇ : (C ‚•§ D) ‚•§ Karoubi C ‚•§ Karoubi D :=\n  (whiskeringRight C D (Karoubi D)).obj (toKaroubi D) ‚ãô functorExtension‚ÇÅ C D\n\n"}
{"name":"CategoryTheory.Idempotents.functorExtension‚ÇÇ_obj_obj_p","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nX : CategoryTheory.Functor C D\nP : CategoryTheory.Idempotents.Karoubi C\n‚ä¢ Eq (((CategoryTheory.Idempotents.functorExtension‚ÇÇ C D).obj X).obj P).p (X.map P.p)","decl":"/-- The canonical functor `(C ‚•§ D) ‚•§ (Karoubi C ‚•§ Karoubi D)` -/\n@[simps!]\ndef functorExtension‚ÇÇ : (C ‚•§ D) ‚•§ Karoubi C ‚•§ Karoubi D :=\n  (whiskeringRight C D (Karoubi D)).obj (toKaroubi D) ‚ãô functorExtension‚ÇÅ C D\n\n"}
{"name":"CategoryTheory.Idempotents.functorExtension‚ÇÇCompWhiskeringLeftToKaroubiIso_hom_app_app_f","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nX‚úù : CategoryTheory.Functor C D\nX : C\n‚ä¢ Eq (((CategoryTheory.Idempotents.functorExtension‚ÇÇCompWhiskeringLeftToKaroubiIso C D).hom.app X‚úù).app X).f (CategoryTheory.CategoryStruct.id (X‚úù.obj X))","decl":"/-- The natural isomorphism expressing that functors `Karoubi C ‚•§ Karoubi D` obtained\nusing `functorExtension‚ÇÇ` actually extends the original functors `C ‚•§ D`. -/\n@[simps!]\ndef functorExtension‚ÇÇCompWhiskeringLeftToKaroubiIso :\n    functorExtension‚ÇÇ C D ‚ãô (whiskeringLeft C (Karoubi C) (Karoubi D)).obj (toKaroubi C) ‚âÖ\n      (whiskeringRight C D (Karoubi D)).obj (toKaroubi D) :=\n  NatIso.ofComponents\n    (fun F => NatIso.ofComponents\n      (fun X =>\n        { hom := { f := ùüô _ }\n          inv := { f := ùüô _ } })\n      (by simp))\n    (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Idempotents.functorExtension‚ÇÇCompWhiskeringLeftToKaroubiIso_inv_app_app_f","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nX‚úù : CategoryTheory.Functor C D\nX : C\n‚ä¢ Eq (((CategoryTheory.Idempotents.functorExtension‚ÇÇCompWhiskeringLeftToKaroubiIso C D).inv.app X‚úù).app X).f (CategoryTheory.CategoryStruct.id (X‚úù.obj X))","decl":"/-- The natural isomorphism expressing that functors `Karoubi C ‚•§ Karoubi D` obtained\nusing `functorExtension‚ÇÇ` actually extends the original functors `C ‚•§ D`. -/\n@[simps!]\ndef functorExtension‚ÇÇCompWhiskeringLeftToKaroubiIso :\n    functorExtension‚ÇÇ C D ‚ãô (whiskeringLeft C (Karoubi C) (Karoubi D)).obj (toKaroubi C) ‚âÖ\n      (whiskeringRight C D (Karoubi D)).obj (toKaroubi D) :=\n  NatIso.ofComponents\n    (fun F => NatIso.ofComponents\n      (fun X =>\n        { hom := { f := ùüô _ }\n          inv := { f := ùüô _ } })\n      (by simp))\n    (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Idempotents.karoubiUniversal‚ÇÇ_functor_eq","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù : CategoryTheory.IsIdempotentComplete D\n‚ä¢ Eq (CategoryTheory.Idempotents.karoubiUniversal‚ÇÇ C D).functor (CategoryTheory.Idempotents.functorExtension‚ÇÇ C D)","decl":"theorem karoubiUniversal‚ÇÇ_functor_eq : (karoubiUniversal‚ÇÇ C D).functor = functorExtension‚ÇÇ C D :=\n  rfl\n\n"}
{"name":"CategoryTheory.Idempotents.instIsEquivalenceFunctorKaroubiFunctorExtension‚ÇÇ","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù : CategoryTheory.Category.{u_4, u_2} D\n‚ä¢ (CategoryTheory.Idempotents.functorExtension‚ÇÇ C D).IsEquivalence","decl":"noncomputable instance : (functorExtension‚ÇÇ C D).IsEquivalence := by\n  rw [‚Üê karoubiUniversal‚ÇÇ_functor_eq]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Idempotents.functorExtension_map_app","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù : CategoryTheory.IsIdempotentComplete D\nX‚úù Y‚úù : CategoryTheory.Functor C D\nf : Quiver.Hom X‚úù Y‚úù\nX : CategoryTheory.Idempotents.Karoubi C\n‚ä¢ Eq (((CategoryTheory.Idempotents.functorExtension C D).map f).app X) ((CategoryTheory.Idempotents.toKaroubiEquivalence D).inverse.map (((CategoryTheory.Idempotents.functorExtension‚ÇÇ C D).map f).app X))","decl":"/-- The extension of functors functor `(C ‚•§ D) ‚•§ (Karoubi C ‚•§ D)`\nwhen `D` is idempotent complete. -/\n@[simps!]\nnoncomputable def functorExtension : (C ‚•§ D) ‚•§ Karoubi C ‚•§ D :=\n  functorExtension‚ÇÇ C D ‚ãô\n    (whiskeringRight (Karoubi C) (Karoubi D) D).obj (toKaroubiEquivalence D).inverse\n\n"}
{"name":"CategoryTheory.Idempotents.functorExtension_obj_obj","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù : CategoryTheory.IsIdempotentComplete D\nX‚úù : CategoryTheory.Functor C D\nX : CategoryTheory.Idempotents.Karoubi C\n‚ä¢ Eq (((CategoryTheory.Idempotents.functorExtension C D).obj X‚úù).obj X) ((CategoryTheory.Idempotents.toKaroubiEquivalence D).inverse.obj (((CategoryTheory.Idempotents.functorExtension‚ÇÇ C D).obj X‚úù).obj X))","decl":"/-- The extension of functors functor `(C ‚•§ D) ‚•§ (Karoubi C ‚•§ D)`\nwhen `D` is idempotent complete. -/\n@[simps!]\nnoncomputable def functorExtension : (C ‚•§ D) ‚•§ Karoubi C ‚•§ D :=\n  functorExtension‚ÇÇ C D ‚ãô\n    (whiskeringRight (Karoubi C) (Karoubi D) D).obj (toKaroubiEquivalence D).inverse\n\n"}
{"name":"CategoryTheory.Idempotents.functorExtension_obj_map","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù : CategoryTheory.IsIdempotentComplete D\nX : CategoryTheory.Functor C D\nX‚úù Y‚úù : CategoryTheory.Idempotents.Karoubi C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((CategoryTheory.Idempotents.functorExtension C D).obj X).map f) ((CategoryTheory.Idempotents.toKaroubiEquivalence D).inverse.map (((CategoryTheory.Idempotents.functorExtension‚ÇÇ C D).obj X).map f))","decl":"/-- The extension of functors functor `(C ‚•§ D) ‚•§ (Karoubi C ‚•§ D)`\nwhen `D` is idempotent complete. -/\n@[simps!]\nnoncomputable def functorExtension : (C ‚•§ D) ‚•§ Karoubi C ‚•§ D :=\n  functorExtension‚ÇÇ C D ‚ãô\n    (whiskeringRight (Karoubi C) (Karoubi D) D).obj (toKaroubiEquivalence D).inverse\n\n"}
{"name":"CategoryTheory.Idempotents.karoubiUniversal_functor_eq","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù : CategoryTheory.IsIdempotentComplete D\n‚ä¢ Eq (CategoryTheory.Idempotents.karoubiUniversal C D).functor (CategoryTheory.Idempotents.functorExtension C D)","decl":"theorem karoubiUniversal_functor_eq : (karoubiUniversal C D).functor = functorExtension C D :=\n  rfl\n\n"}
{"name":"CategoryTheory.Idempotents.instIsEquivalenceFunctorKaroubiFunctorExtension","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_2} D\ninst‚úù : CategoryTheory.IsIdempotentComplete D\n‚ä¢ (CategoryTheory.Idempotents.functorExtension C D).IsEquivalence","decl":"noncomputable instance : (functorExtension C D).IsEquivalence := by\n  rw [‚Üê karoubiUniversal_functor_eq]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Idempotents.instIsEquivalenceFunctorKaroubiObjWhiskeringLeftToKaroubi","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\n‚ä¢ ((CategoryTheory.whiskeringLeft C (CategoryTheory.Idempotents.Karoubi C) D).obj (CategoryTheory.Idempotents.toKaroubi C)).IsEquivalence","decl":"instance : ((whiskeringLeft C (Karoubi C) D).obj (toKaroubi C)).IsEquivalence := by\n  have : ((whiskeringLeft C (Karoubi C) D).obj (toKaroubi C) ‚ãô\n    (whiskeringRight C D (Karoubi D)).obj (toKaroubi D) ‚ãô\n    (whiskeringRight C (Karoubi D) D).obj (Functor.inv (toKaroubi D))).IsEquivalence := by\n    change (karoubiUniversal C D).inverse.IsEquivalence\n    infer_instance\n  exact Functor.isEquivalence_of_comp_right _\n    ((whiskeringRight C _ _).obj (toKaroubi D) ‚ãô\n      (whiskeringRight C (Karoubi D) D).obj (Functor.inv (toKaroubi D)))\n\n"}
{"name":"CategoryTheory.Idempotents.whiskeringLeft_obj_preimage_app","module":"Mathlib.CategoryTheory.Idempotents.FunctorExtension","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù : CategoryTheory.IsIdempotentComplete D\nF G : CategoryTheory.Functor (CategoryTheory.Idempotents.Karoubi C) D\nœÑ : Quiver.Hom ((CategoryTheory.Idempotents.toKaroubi C).comp F) ((CategoryTheory.Idempotents.toKaroubi C).comp G)\nP : CategoryTheory.Idempotents.Karoubi C\n‚ä¢ Eq ((((CategoryTheory.whiskeringLeft C (CategoryTheory.Idempotents.Karoubi C) D).obj (CategoryTheory.Idempotents.toKaroubi C)).preimage œÑ).app P) (CategoryTheory.CategoryStruct.comp (F.map P.decompId_i) (CategoryTheory.CategoryStruct.comp (œÑ.app P.X) (G.map P.decompId_p)))","decl":"theorem whiskeringLeft_obj_preimage_app {F G : Karoubi C ‚•§ D}\n    (œÑ : toKaroubi _ ‚ãô F ‚ü∂ toKaroubi _ ‚ãô G) (P : Karoubi C) :\n    (((whiskeringLeft _ _ _).obj (toKaroubi _)).preimage œÑ).app P =\n      F.map P.decompId_i ‚â´ œÑ.app P.X ‚â´ G.map P.decompId_p := by\n  rw [natTrans_eq]\n  congr 2\n  rw [‚Üê congr_app (((whiskeringLeft _ _ _).obj (toKaroubi _)).map_preimage œÑ) P.X]\n  dsimp\n  congr\n\n"}
