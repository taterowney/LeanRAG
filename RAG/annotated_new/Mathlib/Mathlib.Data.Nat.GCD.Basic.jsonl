{"name":"Nat.gcd_greatest","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"a b d : Nat\nhda : Dvd.dvd d a\nhdb : Dvd.dvd d b\nhd : ∀ (e : Nat), Dvd.dvd e a → Dvd.dvd e b → Dvd.dvd e d\n⊢ Eq d (a.gcd b)","decl":"theorem gcd_greatest {a b d : ℕ} (hda : d ∣ a) (hdb : d ∣ b) (hd : ∀ e : ℕ, e ∣ a → e ∣ b → e ∣ d) :\n    d = a.gcd b :=\n  (dvd_antisymm (hd _ (gcd_dvd_left a b) (gcd_dvd_right a b)) (dvd_gcd hda hdb)).symm\n\n"}
{"name":"Nat.gcd_add_mul_right_right","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n k : Nat\n⊢ Eq (m.gcd (HAdd.hAdd n (HMul.hMul k m))) (m.gcd n)","decl":"@[simp]\ntheorem gcd_add_mul_right_right (m n k : ℕ) : gcd m (n + k * m) = gcd m n := by\n  simp [gcd_rec m (n + k * m), gcd_rec m n]\n\n"}
{"name":"Nat.gcd_add_mul_left_right","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n k : Nat\n⊢ Eq (m.gcd (HAdd.hAdd n (HMul.hMul m k))) (m.gcd n)","decl":"@[simp]\ntheorem gcd_add_mul_left_right (m n k : ℕ) : gcd m (n + m * k) = gcd m n := by\n  simp [gcd_rec m (n + m * k), gcd_rec m n]\n\n"}
{"name":"Nat.gcd_mul_right_add_right","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n k : Nat\n⊢ Eq (m.gcd (HAdd.hAdd (HMul.hMul k m) n)) (m.gcd n)","decl":"@[simp]\ntheorem gcd_mul_right_add_right (m n k : ℕ) : gcd m (k * m + n) = gcd m n := by simp [add_comm _ n]\n\n"}
{"name":"Nat.gcd_mul_left_add_right","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n k : Nat\n⊢ Eq (m.gcd (HAdd.hAdd (HMul.hMul m k) n)) (m.gcd n)","decl":"@[simp]\ntheorem gcd_mul_left_add_right (m n k : ℕ) : gcd m (m * k + n) = gcd m n := by simp [add_comm _ n]\n\n"}
{"name":"Nat.gcd_add_mul_right_left","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n k : Nat\n⊢ Eq ((HAdd.hAdd m (HMul.hMul k n)).gcd n) (m.gcd n)","decl":"@[simp]\ntheorem gcd_add_mul_right_left (m n k : ℕ) : gcd (m + k * n) n = gcd m n := by\n  rw [gcd_comm, gcd_add_mul_right_right, gcd_comm]\n\n"}
{"name":"Nat.gcd_add_mul_left_left","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n k : Nat\n⊢ Eq ((HAdd.hAdd m (HMul.hMul n k)).gcd n) (m.gcd n)","decl":"@[simp]\ntheorem gcd_add_mul_left_left (m n k : ℕ) : gcd (m + n * k) n = gcd m n := by\n  rw [gcd_comm, gcd_add_mul_left_right, gcd_comm]\n\n"}
{"name":"Nat.gcd_mul_right_add_left","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n k : Nat\n⊢ Eq ((HAdd.hAdd (HMul.hMul k n) m).gcd n) (m.gcd n)","decl":"@[simp]\ntheorem gcd_mul_right_add_left (m n k : ℕ) : gcd (k * n + m) n = gcd m n := by\n  rw [gcd_comm, gcd_mul_right_add_right, gcd_comm]\n\n"}
{"name":"Nat.gcd_mul_left_add_left","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n k : Nat\n⊢ Eq ((HAdd.hAdd (HMul.hMul n k) m).gcd n) (m.gcd n)","decl":"@[simp]\ntheorem gcd_mul_left_add_left (m n k : ℕ) : gcd (n * k + m) n = gcd m n := by\n  rw [gcd_comm, gcd_mul_left_add_right, gcd_comm]\n\n"}
{"name":"Nat.gcd_add_self_right","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n : Nat\n⊢ Eq (m.gcd (HAdd.hAdd n m)) (m.gcd n)","decl":"@[simp]\ntheorem gcd_add_self_right (m n : ℕ) : gcd m (n + m) = gcd m n :=\n  Eq.trans (by rw [one_mul]) (gcd_add_mul_right_right m n 1)\n\n"}
{"name":"Nat.gcd_add_self_left","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n : Nat\n⊢ Eq ((HAdd.hAdd m n).gcd n) (m.gcd n)","decl":"@[simp]\ntheorem gcd_add_self_left (m n : ℕ) : gcd (m + n) n = gcd m n := by\n  rw [gcd_comm, gcd_add_self_right, gcd_comm]\n\n"}
{"name":"Nat.gcd_self_add_left","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n : Nat\n⊢ Eq ((HAdd.hAdd m n).gcd m) (n.gcd m)","decl":"@[simp]\ntheorem gcd_self_add_left (m n : ℕ) : gcd (m + n) m = gcd n m := by rw [add_comm, gcd_add_self_left]\n\n"}
{"name":"Nat.gcd_self_add_right","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n : Nat\n⊢ Eq (m.gcd (HAdd.hAdd m n)) (m.gcd n)","decl":"@[simp]\ntheorem gcd_self_add_right (m n : ℕ) : gcd m (m + n) = gcd m n := by\n  rw [add_comm, gcd_add_self_right]\n\n"}
{"name":"Nat.gcd_sub_self_left","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n : Nat\nh : LE.le m n\n⊢ Eq ((HSub.hSub n m).gcd m) (n.gcd m)","decl":"@[simp]\ntheorem gcd_sub_self_left {m n : ℕ} (h : m ≤ n) : gcd (n - m) m = gcd n m := by\n  calc\n    gcd (n - m) m = gcd (n - m + m) m := by rw [← gcd_add_self_left (n - m) m]\n                _ = gcd n m := by rw [Nat.sub_add_cancel h]\n\n"}
{"name":"Nat.gcd_sub_self_right","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n : Nat\nh : LE.le m n\n⊢ Eq (m.gcd (HSub.hSub n m)) (m.gcd n)","decl":"@[simp]\ntheorem gcd_sub_self_right {m n : ℕ} (h : m ≤ n) : gcd m (n - m) = gcd m n := by\n  rw [gcd_comm, gcd_sub_self_left h, gcd_comm]\n\n"}
{"name":"Nat.gcd_self_sub_left","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n : Nat\nh : LE.le m n\n⊢ Eq ((HSub.hSub n m).gcd n) (m.gcd n)","decl":"@[simp]\ntheorem gcd_self_sub_left {m n : ℕ} (h : m ≤ n) : gcd (n - m) n = gcd m n := by\n  have := Nat.sub_add_cancel h\n  rw [gcd_comm m n, ← this, gcd_add_self_left (n - m) m]\n  have : gcd (n - m) n = gcd (n - m) m := by\n    nth_rw 2 [← Nat.add_sub_cancel' h]\n    rw [gcd_add_self_right, gcd_comm]\n  convert this\n\n"}
{"name":"Nat.gcd_self_sub_right","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n : Nat\nh : LE.le m n\n⊢ Eq (n.gcd (HSub.hSub n m)) (n.gcd m)","decl":"@[simp]\ntheorem gcd_self_sub_right {m n : ℕ} (h : m ≤ n) : gcd n (n - m) = gcd n m := by\n  rw [gcd_comm, gcd_self_sub_left h, gcd_comm]\n\n"}
{"name":"Nat.lcm_dvd_mul","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n : Nat\n⊢ Dvd.dvd (m.lcm n) (HMul.hMul m n)","decl":"theorem lcm_dvd_mul (m n : ℕ) : lcm m n ∣ m * n :=\n  lcm_dvd (dvd_mul_right _ _) (dvd_mul_left _ _)\n\n"}
{"name":"Nat.lcm_dvd_iff","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n k : Nat\n⊢ Iff (Dvd.dvd (m.lcm n) k) (And (Dvd.dvd m k) (Dvd.dvd n k))","decl":"theorem lcm_dvd_iff {m n k : ℕ} : lcm m n ∣ k ↔ m ∣ k ∧ n ∣ k :=\n  ⟨fun h => ⟨(dvd_lcm_left _ _).trans h, (dvd_lcm_right _ _).trans h⟩, and_imp.2 lcm_dvd⟩\n\n"}
{"name":"Nat.lcm_pos","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n : Nat\na✝¹ : LT.lt 0 m\na✝ : LT.lt 0 n\n⊢ LT.lt 0 (m.lcm n)","decl":"theorem lcm_pos {m n : ℕ} : 0 < m → 0 < n → 0 < m.lcm n := by\n  simp_rw [Nat.pos_iff_ne_zero]\n  exact lcm_ne_zero\n\n"}
{"name":"Nat.lcm_mul_left","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n k : Nat\n⊢ Eq ((HMul.hMul m n).lcm (HMul.hMul m k)) (HMul.hMul m (n.lcm k))","decl":"theorem lcm_mul_left {m n k : ℕ} : (m * n).lcm (m * k) = m * n.lcm k := by\n  apply dvd_antisymm\n  · exact lcm_dvd (mul_dvd_mul_left m (dvd_lcm_left n k)) (mul_dvd_mul_left m (dvd_lcm_right n k))\n  · have h : m ∣ lcm (m * n) (m * k) := (dvd_mul_right m n).trans (dvd_lcm_left (m * n) (m * k))\n    rw [← dvd_div_iff_mul_dvd h, lcm_dvd_iff, dvd_div_iff_mul_dvd h, dvd_div_iff_mul_dvd h,\n      ← lcm_dvd_iff]\n\n"}
{"name":"Nat.lcm_mul_right","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n k : Nat\n⊢ Eq ((HMul.hMul m n).lcm (HMul.hMul k n)) (HMul.hMul (m.lcm k) n)","decl":"theorem lcm_mul_right {m n k : ℕ} : (m * n).lcm (k * n) = m.lcm k * n := by\n rw [mul_comm, mul_comm k n, lcm_mul_left, mul_comm]\n\n"}
{"name":"Nat.Coprime.lcm_eq_mul","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n : Nat\nh : m.Coprime n\n⊢ Eq (m.lcm n) (HMul.hMul m n)","decl":"theorem Coprime.lcm_eq_mul {m n : ℕ} (h : Coprime m n) : lcm m n = m * n := by\n  rw [← one_mul (lcm m n), ← h.gcd_eq_one, gcd_mul_lcm]\n\n"}
{"name":"Nat.Coprime.symmetric","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"⊢ Symmetric Nat.Coprime","decl":"theorem Coprime.symmetric : Symmetric Coprime := fun _ _ => Coprime.symm\n\n"}
{"name":"Nat.Coprime.dvd_mul_right","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n k : Nat\nH : k.Coprime n\n⊢ Iff (Dvd.dvd k (HMul.hMul m n)) (Dvd.dvd k m)","decl":"theorem Coprime.dvd_mul_right {m n k : ℕ} (H : Coprime k n) : k ∣ m * n ↔ k ∣ m :=\n  ⟨H.dvd_of_dvd_mul_right, fun h => dvd_mul_of_dvd_left h n⟩\n\n"}
{"name":"Nat.Coprime.dvd_mul_left","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n k : Nat\nH : k.Coprime m\n⊢ Iff (Dvd.dvd k (HMul.hMul m n)) (Dvd.dvd k n)","decl":"theorem Coprime.dvd_mul_left {m n k : ℕ} (H : Coprime k m) : k ∣ m * n ↔ k ∣ n :=\n  ⟨H.dvd_of_dvd_mul_left, fun h => dvd_mul_of_dvd_right h m⟩\n\n"}
{"name":"Nat.coprime_add_self_right","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n : Nat\n⊢ Iff (m.Coprime (HAdd.hAdd n m)) (m.Coprime n)","decl":"@[simp]\ntheorem coprime_add_self_right {m n : ℕ} : Coprime m (n + m) ↔ Coprime m n := by\n  rw [Coprime, Coprime, gcd_add_self_right]\n\n"}
{"name":"Nat.coprime_self_add_right","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n : Nat\n⊢ Iff (m.Coprime (HAdd.hAdd m n)) (m.Coprime n)","decl":"@[simp]\ntheorem coprime_self_add_right {m n : ℕ} : Coprime m (m + n) ↔ Coprime m n := by\n  rw [add_comm, coprime_add_self_right]\n\n"}
{"name":"Nat.coprime_add_self_left","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n : Nat\n⊢ Iff ((HAdd.hAdd m n).Coprime n) (m.Coprime n)","decl":"@[simp]\ntheorem coprime_add_self_left {m n : ℕ} : Coprime (m + n) n ↔ Coprime m n := by\n  rw [Coprime, Coprime, gcd_add_self_left]\n\n"}
{"name":"Nat.coprime_self_add_left","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n : Nat\n⊢ Iff ((HAdd.hAdd m n).Coprime m) (n.Coprime m)","decl":"@[simp]\ntheorem coprime_self_add_left {m n : ℕ} : Coprime (m + n) m ↔ Coprime n m := by\n  rw [Coprime, Coprime, gcd_self_add_left]\n\n"}
{"name":"Nat.coprime_add_mul_right_right","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n k : Nat\n⊢ Iff (m.Coprime (HAdd.hAdd n (HMul.hMul k m))) (m.Coprime n)","decl":"@[simp]\ntheorem coprime_add_mul_right_right (m n k : ℕ) : Coprime m (n + k * m) ↔ Coprime m n := by\n  rw [Coprime, Coprime, gcd_add_mul_right_right]\n\n"}
{"name":"Nat.coprime_add_mul_left_right","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n k : Nat\n⊢ Iff (m.Coprime (HAdd.hAdd n (HMul.hMul m k))) (m.Coprime n)","decl":"@[simp]\ntheorem coprime_add_mul_left_right (m n k : ℕ) : Coprime m (n + m * k) ↔ Coprime m n := by\n  rw [Coprime, Coprime, gcd_add_mul_left_right]\n\n"}
{"name":"Nat.coprime_mul_right_add_right","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n k : Nat\n⊢ Iff (m.Coprime (HAdd.hAdd (HMul.hMul k m) n)) (m.Coprime n)","decl":"@[simp]\ntheorem coprime_mul_right_add_right (m n k : ℕ) : Coprime m (k * m + n) ↔ Coprime m n := by\n  rw [Coprime, Coprime, gcd_mul_right_add_right]\n\n"}
{"name":"Nat.coprime_mul_left_add_right","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n k : Nat\n⊢ Iff (m.Coprime (HAdd.hAdd (HMul.hMul m k) n)) (m.Coprime n)","decl":"@[simp]\ntheorem coprime_mul_left_add_right (m n k : ℕ) : Coprime m (m * k + n) ↔ Coprime m n := by\n  rw [Coprime, Coprime, gcd_mul_left_add_right]\n\n"}
{"name":"Nat.coprime_add_mul_right_left","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n k : Nat\n⊢ Iff ((HAdd.hAdd m (HMul.hMul k n)).Coprime n) (m.Coprime n)","decl":"@[simp]\ntheorem coprime_add_mul_right_left (m n k : ℕ) : Coprime (m + k * n) n ↔ Coprime m n := by\n  rw [Coprime, Coprime, gcd_add_mul_right_left]\n\n"}
{"name":"Nat.coprime_add_mul_left_left","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n k : Nat\n⊢ Iff ((HAdd.hAdd m (HMul.hMul n k)).Coprime n) (m.Coprime n)","decl":"@[simp]\ntheorem coprime_add_mul_left_left (m n k : ℕ) : Coprime (m + n * k) n ↔ Coprime m n := by\n  rw [Coprime, Coprime, gcd_add_mul_left_left]\n\n"}
{"name":"Nat.coprime_mul_right_add_left","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n k : Nat\n⊢ Iff ((HAdd.hAdd (HMul.hMul k n) m).Coprime n) (m.Coprime n)","decl":"@[simp]\ntheorem coprime_mul_right_add_left (m n k : ℕ) : Coprime (k * n + m) n ↔ Coprime m n := by\n  rw [Coprime, Coprime, gcd_mul_right_add_left]\n\n"}
{"name":"Nat.coprime_mul_left_add_left","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n k : Nat\n⊢ Iff ((HAdd.hAdd (HMul.hMul n k) m).Coprime n) (m.Coprime n)","decl":"@[simp]\ntheorem coprime_mul_left_add_left (m n k : ℕ) : Coprime (n * k + m) n ↔ Coprime m n := by\n  rw [Coprime, Coprime, gcd_mul_left_add_left]\n\n"}
{"name":"Nat.add_coprime_iff_left","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"a b c : Nat\nh : Dvd.dvd c b\n⊢ Iff ((HAdd.hAdd a b).Coprime c) (a.Coprime c)","decl":"lemma add_coprime_iff_left (h : c ∣ b) : Coprime (a + b) c ↔ Coprime a c := by\n  obtain ⟨n, rfl⟩ := h; simp\n\n"}
{"name":"Nat.add_coprime_iff_right","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"a b c : Nat\nh : Dvd.dvd c a\n⊢ Iff ((HAdd.hAdd a b).Coprime c) (b.Coprime c)","decl":"lemma add_coprime_iff_right (h : c ∣ a) : Coprime (a + b) c ↔ Coprime b c := by\n  obtain ⟨n, rfl⟩ := h; simp\n\n"}
{"name":"Nat.coprime_add_iff_left","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"a b c : Nat\nh : Dvd.dvd a c\n⊢ Iff (a.Coprime (HAdd.hAdd b c)) (a.Coprime b)","decl":"lemma coprime_add_iff_left (h : a ∣ c) : Coprime a (b + c) ↔ Coprime a b := by\n  obtain ⟨n, rfl⟩ := h; simp\n\n"}
{"name":"Nat.coprime_add_iff_right","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"a b c : Nat\nh : Dvd.dvd a b\n⊢ Iff (a.Coprime (HAdd.hAdd b c)) (a.Coprime c)","decl":"lemma coprime_add_iff_right (h : a ∣ b) : Coprime a (b + c) ↔ Coprime a c := by\n  obtain ⟨n, rfl⟩ := h; simp\n\n-- TODO: Replace `Nat.Coprime.coprime_dvd_left`\n"}
{"name":"Nat.Coprime.of_dvd_left","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"a₁ a₂ b : Nat\nha : Dvd.dvd a₁ a₂\nh : a₂.Coprime b\n⊢ a₁.Coprime b","decl":"lemma Coprime.of_dvd_left (ha : a₁ ∣ a₂) (h : Coprime a₂ b) : Coprime a₁ b := h.coprime_dvd_left ha\n\n-- TODO: Replace `Nat.Coprime.coprime_dvd_right`\n"}
{"name":"Nat.Coprime.of_dvd_right","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"a b₁ b₂ : Nat\nhb : Dvd.dvd b₁ b₂\nh : a.Coprime b₂\n⊢ a.Coprime b₁","decl":"lemma Coprime.of_dvd_right (hb : b₁ ∣ b₂) (h : Coprime a b₂) : Coprime a b₁ :=\n  h.coprime_dvd_right hb\n\n"}
{"name":"Nat.Coprime.of_dvd","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"a₁ a₂ b₁ b₂ : Nat\nha : Dvd.dvd a₁ a₂\nhb : Dvd.dvd b₁ b₂\nh : a₂.Coprime b₂\n⊢ a₁.Coprime b₁","decl":"lemma Coprime.of_dvd (ha : a₁ ∣ a₂) (hb : b₁ ∣ b₂) (h : Coprime a₂ b₂) : Coprime a₁ b₁ :=\n  (h.of_dvd_left ha).of_dvd_right hb\n\n"}
{"name":"Nat.coprime_sub_self_left","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n : Nat\nh : LE.le m n\n⊢ Iff ((HSub.hSub n m).Coprime m) (n.Coprime m)","decl":"@[simp]\ntheorem coprime_sub_self_left {m n : ℕ} (h : m ≤ n) : Coprime (n - m) m ↔ Coprime n m := by\n  rw [Coprime, Coprime, gcd_sub_self_left h]\n\n"}
{"name":"Nat.coprime_sub_self_right","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n : Nat\nh : LE.le m n\n⊢ Iff (m.Coprime (HSub.hSub n m)) (m.Coprime n)","decl":"@[simp]\ntheorem coprime_sub_self_right {m n : ℕ} (h : m ≤ n) : Coprime m (n - m) ↔ Coprime m n := by\n  rw [Coprime, Coprime, gcd_sub_self_right h]\n\n"}
{"name":"Nat.coprime_self_sub_left","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n : Nat\nh : LE.le m n\n⊢ Iff ((HSub.hSub n m).Coprime n) (m.Coprime n)","decl":"@[simp]\ntheorem coprime_self_sub_left {m n : ℕ} (h : m ≤ n) : Coprime (n - m) n ↔ Coprime m n := by\n  rw [Coprime, Coprime, gcd_self_sub_left h]\n\n"}
{"name":"Nat.coprime_self_sub_right","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n : Nat\nh : LE.le m n\n⊢ Iff (n.Coprime (HSub.hSub n m)) (n.Coprime m)","decl":"@[simp]\ntheorem coprime_self_sub_right {m n : ℕ} (h : m ≤ n) : Coprime n (n - m) ↔ Coprime n m := by\n  rw [Coprime, Coprime, gcd_self_sub_right h]\n\n"}
{"name":"Nat.coprime_pow_left_iff","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"n : Nat\nhn : LT.lt 0 n\na b : Nat\n⊢ Iff ((HPow.hPow a n).Coprime b) (a.Coprime b)","decl":"@[simp]\ntheorem coprime_pow_left_iff {n : ℕ} (hn : 0 < n) (a b : ℕ) :\n    Nat.Coprime (a ^ n) b ↔ Nat.Coprime a b := by\n  obtain ⟨n, rfl⟩ := exists_eq_succ_of_ne_zero (Nat.ne_of_gt hn)\n  rw [Nat.pow_succ, Nat.coprime_mul_iff_left]\n  exact ⟨And.right, fun hab => ⟨hab.pow_left _, hab⟩⟩\n\n"}
{"name":"Nat.coprime_pow_right_iff","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"n : Nat\nhn : LT.lt 0 n\na b : Nat\n⊢ Iff (a.Coprime (HPow.hPow b n)) (a.Coprime b)","decl":"@[simp]\ntheorem coprime_pow_right_iff {n : ℕ} (hn : 0 < n) (a b : ℕ) :\n    Nat.Coprime a (b ^ n) ↔ Nat.Coprime a b := by\n  rw [Nat.coprime_comm, coprime_pow_left_iff hn, Nat.coprime_comm]\n\n"}
{"name":"Nat.not_coprime_zero_zero","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"⊢ Not (Nat.Coprime 0 0)","decl":"theorem not_coprime_zero_zero : ¬Coprime 0 0 := by simp\n\n"}
{"name":"Nat.coprime_one_left_iff","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"n : Nat\n⊢ Iff (Nat.Coprime 1 n) True","decl":"theorem coprime_one_left_iff (n : ℕ) : Coprime 1 n ↔ True := by simp [Coprime]\n\n"}
{"name":"Nat.coprime_one_right_iff","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"n : Nat\n⊢ Iff (n.Coprime 1) True","decl":"theorem coprime_one_right_iff (n : ℕ) : Coprime n 1 ↔ True := by simp [Coprime]\n\n"}
{"name":"Nat.gcd_mul_of_coprime_of_dvd","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"a b c : Nat\nhac : a.Coprime c\nb_dvd_c : Dvd.dvd b c\n⊢ Eq ((HMul.hMul a b).gcd c) b","decl":"theorem gcd_mul_of_coprime_of_dvd {a b c : ℕ} (hac : Coprime a c) (b_dvd_c : b ∣ c) :\n    gcd (a * b) c = b := by\n  rcases exists_eq_mul_left_of_dvd b_dvd_c with ⟨d, rfl⟩\n  rw [gcd_mul_right]\n  convert one_mul b\n  exact Coprime.coprime_mul_right_right hac\n\n"}
{"name":"Nat.Coprime.eq_of_mul_eq_zero","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n : Nat\nh : m.Coprime n\nhmn : Eq (HMul.hMul m n) 0\n⊢ Or (And (Eq m 0) (Eq n 1)) (And (Eq m 1) (Eq n 0))","decl":"theorem Coprime.eq_of_mul_eq_zero {m n : ℕ} (h : m.Coprime n) (hmn : m * n = 0) :\n    m = 0 ∧ n = 1 ∨ m = 1 ∧ n = 0 :=\n  (Nat.mul_eq_zero.mp hmn).imp (fun hm => ⟨hm, n.coprime_zero_left.mp <| hm ▸ h⟩) fun hn =>\n    let eq := hn ▸ h.symm\n    ⟨m.coprime_zero_left.mp <| eq, hn⟩\n\n"}
{"name":"Nat.dvd_mul","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"x m n : Nat\n⊢ Iff (Dvd.dvd x (HMul.hMul m n)) (Exists fun y => Exists fun z => And (Dvd.dvd y m) (And (Dvd.dvd z n) (Eq (HMul.hMul y z) x)))","decl":"theorem dvd_mul {x m n : ℕ} : x ∣ m * n ↔ ∃ y z, y ∣ m ∧ z ∣ n ∧ y * z = x := by\n  constructor\n  · intro h\n    obtain ⟨⟨⟨y, hy⟩, ⟨z, hz⟩⟩, rfl⟩ := prod_dvd_and_dvd_of_dvd_prod h\n    exact ⟨y, z, hy, hz, rfl⟩\n  · rintro ⟨y, z, hy, hz, rfl⟩\n    exact mul_dvd_mul hy hz\n\n"}
{"name":"Nat.pow_dvd_pow_iff","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"a b n : Nat\nn0 : Ne n 0\n⊢ Iff (Dvd.dvd (HPow.hPow a n) (HPow.hPow b n)) (Dvd.dvd a b)","decl":"theorem pow_dvd_pow_iff {a b n : ℕ} (n0 : n ≠ 0) : a ^ n ∣ b ^ n ↔ a ∣ b := by\n  refine ⟨fun h => ?_, fun h => pow_dvd_pow_of_dvd h _⟩\n  rcases Nat.eq_zero_or_pos (gcd a b) with g0 | g0\n  · simp [eq_zero_of_gcd_eq_zero_right g0]\n  rcases exists_coprime' g0 with ⟨g, a', b', g0', co, rfl, rfl⟩\n  rw [mul_pow, mul_pow] at h\n  replace h := Nat.dvd_of_mul_dvd_mul_right (Nat.pow_pos g0') h\n  have := pow_dvd_pow a' <| Nat.pos_of_ne_zero n0\n  rw [pow_one, (co.pow n n).eq_one_of_dvd h] at this\n  simp [eq_one_of_dvd_one this]\n\n"}
{"name":"Nat.coprime_iff_isRelPrime","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n : Nat\n⊢ Iff (m.Coprime n) (IsRelPrime m n)","decl":"theorem coprime_iff_isRelPrime {m n : ℕ} : m.Coprime n ↔ IsRelPrime m n := by\n  simp_rw [coprime_iff_gcd_eq_one, IsRelPrime, ← and_imp, ← dvd_gcd_iff, isUnit_iff_dvd_one]\n  exact ⟨fun h _ ↦ (h ▸ ·), (dvd_one.mp <| · dvd_rfl)⟩\n\n"}
{"name":"Nat.eq_one_of_dvd_coprimes","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"a b k : Nat\nh_ab_coprime : a.Coprime b\nhka : Dvd.dvd k a\nhkb : Dvd.dvd k b\n⊢ Eq k 1","decl":"/-- If `k:ℕ` divides coprime `a` and `b` then `k = 1` -/\ntheorem eq_one_of_dvd_coprimes {a b k : ℕ} (h_ab_coprime : Coprime a b) (hka : k ∣ a)\n    (hkb : k ∣ b) : k = 1 :=\n  dvd_one.mp (isUnit_iff_dvd_one.mp <| coprime_iff_isRelPrime.mp h_ab_coprime hka hkb)\n\n"}
{"name":"Nat.Coprime.mul_add_mul_ne_mul","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"m n a b : Nat\ncop : m.Coprime n\nha : Ne a 0\nhb : Ne b 0\n⊢ Ne (HAdd.hAdd (HMul.hMul a m) (HMul.hMul b n)) (HMul.hMul m n)","decl":"theorem Coprime.mul_add_mul_ne_mul {m n a b : ℕ} (cop : Coprime m n) (ha : a ≠ 0) (hb : b ≠ 0) :\n    a * m + b * n ≠ m * n := by\n  intro h\n  obtain ⟨x, rfl⟩ : n ∣ a :=\n    cop.symm.dvd_of_dvd_mul_right\n      ((Nat.dvd_add_iff_left (Nat.dvd_mul_left n b)).mpr\n        ((congr_arg _ h).mpr (Nat.dvd_mul_left n m)))\n  obtain ⟨y, rfl⟩ : m ∣ b :=\n    cop.dvd_of_dvd_mul_right\n      ((Nat.dvd_add_iff_right (Nat.dvd_mul_left m (n * x))).mpr\n        ((congr_arg _ h).mpr (Nat.dvd_mul_right m n)))\n  rw [mul_comm, mul_ne_zero_iff, ← one_le_iff_ne_zero] at ha hb\n  refine mul_ne_zero hb.2 ha.2 (eq_zero_of_mul_eq_self_left (ne_of_gt (add_le_add ha.1 hb.1)) ?_)\n  rw [← mul_assoc, ← h, Nat.add_mul, Nat.add_mul, mul_comm _ n, ← mul_assoc, mul_comm y]\n\n"}
{"name":"Nat.dvd_gcd_mul_iff_dvd_mul","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"x n m : Nat\n⊢ Iff (Dvd.dvd x (HMul.hMul (x.gcd n) m)) (Dvd.dvd x (HMul.hMul n m))","decl":"theorem dvd_gcd_mul_iff_dvd_mul : x ∣ gcd x n * m ↔ x ∣ n * m := by\n  refine ⟨(·.trans <| mul_dvd_mul_right (x.gcd_dvd_right n) m), fun ⟨y, hy⟩ ↦ ?_⟩\n  rw [← gcd_mul_right, hy, gcd_mul_left]\n  exact dvd_mul_right x (gcd m y)\n\n"}
{"name":"Nat.dvd_mul_gcd_iff_dvd_mul","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"x n m : Nat\n⊢ Iff (Dvd.dvd x (HMul.hMul n (x.gcd m))) (Dvd.dvd x (HMul.hMul n m))","decl":"theorem dvd_mul_gcd_iff_dvd_mul : x ∣ n * gcd x m ↔ x ∣ n * m := by\n  rw [mul_comm, dvd_gcd_mul_iff_dvd_mul, mul_comm]\n\n"}
{"name":"Nat.dvd_gcd_mul_gcd_iff_dvd_mul","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"x n m : Nat\n⊢ Iff (Dvd.dvd x (HMul.hMul (x.gcd n) (x.gcd m))) (Dvd.dvd x (HMul.hMul n m))","decl":"theorem dvd_gcd_mul_gcd_iff_dvd_mul : x ∣ gcd x n * gcd x m ↔ x ∣ n * m := by\n  rw [dvd_gcd_mul_iff_dvd_mul, dvd_mul_gcd_iff_dvd_mul]\n\n"}
{"name":"Nat.gcd_mul_gcd_eq_iff_dvd_mul_of_coprime","module":"Mathlib.Data.Nat.GCD.Basic","initialProofState":"x n m : Nat\nhcop : n.Coprime m\n⊢ Iff (Eq (HMul.hMul (x.gcd n) (x.gcd m)) x) (Dvd.dvd x (HMul.hMul n m))","decl":"theorem gcd_mul_gcd_eq_iff_dvd_mul_of_coprime (hcop : Coprime n m) :\n    gcd x n * gcd x m = x ↔ x ∣ n * m := by\n  refine ⟨fun h ↦ ?_, (dvd_antisymm ?_ <| dvd_gcd_mul_gcd_iff_dvd_mul.mpr ·)⟩\n  refine h ▸ Nat.mul_dvd_mul ?_ ?_ <;> exact x.gcd_dvd_right _\n  refine (hcop.gcd_both x x).mul_dvd_of_dvd_of_dvd ?_ ?_ <;> exact x.gcd_dvd_left _\n\n"}
