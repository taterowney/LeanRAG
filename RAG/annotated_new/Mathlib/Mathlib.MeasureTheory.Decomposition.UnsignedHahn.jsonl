{"name":"MeasureTheory.hahn_decomposition","module":"Mathlib.MeasureTheory.Decomposition.UnsignedHahn","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : MeasureTheory.IsFiniteMeasure ν\n⊢ Exists fun s => And (MeasurableSet s) (And (∀ (t : Set α), MeasurableSet t → HasSubset.Subset t s → LE.le (ν t) (μ t)) (∀ (t : Set α), MeasurableSet t → HasSubset.Subset t (HasCompl.compl s) → LE.le (μ t) (ν t)))","decl":"/-- **Hahn decomposition theorem** -/\ntheorem hahn_decomposition (μ ν : Measure α) [IsFiniteMeasure μ] [IsFiniteMeasure ν] :\n    ∃ s, MeasurableSet s ∧ (∀ t, MeasurableSet t → t ⊆ s → ν t ≤ μ t) ∧\n      ∀ t, MeasurableSet t → t ⊆ sᶜ → μ t ≤ ν t := by\n  let d : Set α → ℝ := fun s => ((μ s).toNNReal : ℝ) - (ν s).toNNReal\n  let c : Set ℝ := d '' { s | MeasurableSet s }\n  let γ : ℝ := sSup c\n  have hμ : ∀ s, μ s ≠ ∞ := measure_ne_top μ\n  have hν : ∀ s, ν s ≠ ∞ := measure_ne_top ν\n  have to_nnreal_μ : ∀ s, ((μ s).toNNReal : ℝ≥0∞) = μ s := fun s => ENNReal.coe_toNNReal <| hμ _\n  have to_nnreal_ν : ∀ s, ((ν s).toNNReal : ℝ≥0∞) = ν s := fun s => ENNReal.coe_toNNReal <| hν _\n  have d_split s t (ht : MeasurableSet t) : d s = d (s \\ t) + d (s ∩ t) := by\n    dsimp only [d]\n    rw [← measure_inter_add_diff s ht, ← measure_inter_add_diff s ht,\n      ENNReal.toNNReal_add (hμ _) (hμ _), ENNReal.toNNReal_add (hν _) (hν _), NNReal.coe_add,\n      NNReal.coe_add]\n    simp only [sub_eq_add_neg, neg_add]\n    abel\n  have d_Union (s : ℕ → Set α) (hm : Monotone s) :\n    Tendsto (fun n => d (s n)) atTop (𝓝 (d (⋃ n, s n))) := by\n    refine Tendsto.sub ?_ ?_ <;>\n      refine NNReal.tendsto_coe.2 <| (ENNReal.tendsto_toNNReal ?_).comp <|\n        tendsto_measure_iUnion_atTop hm\n    · exact hμ _\n    · exact hν _\n  have d_Inter (s : ℕ → Set α) (hs : ∀ n, MeasurableSet (s n)) (hm : ∀ n m, n ≤ m → s m ⊆ s n) :\n        Tendsto (fun n => d (s n)) atTop (𝓝 (d (⋂ n, s n))) := by\n    refine Tendsto.sub ?_ ?_ <;>\n      refine NNReal.tendsto_coe.2 <| (ENNReal.tendsto_toNNReal <| ?_).comp <|\n        tendsto_measure_iInter_atTop (fun n ↦ (hs n).nullMeasurableSet) hm ?_\n    exacts [hμ _, ⟨0, hμ _⟩, hν _, ⟨0, hν _⟩]\n  have bdd_c : BddAbove c := by\n    use (μ univ).toNNReal\n    rintro r ⟨s, _hs, rfl⟩\n    refine le_trans (sub_le_self _ <| NNReal.coe_nonneg _) ?_\n    rw [NNReal.coe_le_coe, ← ENNReal.coe_le_coe, to_nnreal_μ, to_nnreal_μ]\n    exact measure_mono (subset_univ _)\n  have c_nonempty : c.Nonempty := Nonempty.image _ ⟨_, MeasurableSet.empty⟩\n  have d_le_γ : ∀ s, MeasurableSet s → d s ≤ γ := fun s hs => le_csSup bdd_c ⟨s, hs, rfl⟩\n  have (n : ℕ) : ∃ s : Set α, MeasurableSet s ∧ γ - (1 / 2) ^ n < d s := by\n    have : γ - (1 / 2) ^ n < γ := sub_lt_self γ (pow_pos (half_pos zero_lt_one) n)\n    rcases exists_lt_of_lt_csSup c_nonempty this with ⟨r, ⟨s, hs, rfl⟩, hlt⟩\n    exact ⟨s, hs, hlt⟩\n  rcases Classical.axiom_of_choice this with ⟨e, he⟩\n  change ℕ → Set α at e\n  have he₁ : ∀ n, MeasurableSet (e n) := fun n => (he n).1\n  have he₂ : ∀ n, γ - (1 / 2) ^ n < d (e n) := fun n => (he n).2\n  let f : ℕ → ℕ → Set α := fun n m => (Finset.Ico n (m + 1)).inf e\n  have hf n m : MeasurableSet (f n m) := by\n    simp only [f, Finset.inf_eq_iInf]\n    exact MeasurableSet.biInter (to_countable _) fun i _ => he₁ _\n  have f_subset_f {a b c d} (hab : a ≤ b) (hcd : c ≤ d) : f a d ⊆ f b c := by\n    simp_rw [f, Finset.inf_eq_iInf]\n    exact biInter_subset_biInter_left (Finset.Ico_subset_Ico hab <| Nat.succ_le_succ hcd)\n  have f_succ n m (hnm : n ≤ m) : f n (m + 1) = f n m ∩ e (m + 1) := by\n    have : n ≤ m + 1 := le_of_lt (Nat.succ_le_succ hnm)\n    simp_rw [f, Nat.Ico_succ_right_eq_insert_Ico this, Finset.inf_insert, Set.inter_comm]\n    rfl\n  have le_d_f n m (h : m ≤ n) : γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n) := by\n    refine Nat.le_induction ?_ ?_ n h\n    · have := he₂ m\n      simp_rw [f, Nat.Ico_succ_singleton, Finset.inf_singleton]\n      linarith\n    · intro n (hmn : m ≤ n) ih\n      have : γ + (γ - 2 * (1 / 2) ^ m + (1 / 2) ^ (n + 1)) ≤ γ + d (f m (n + 1)) := by\n        calc\n          γ + (γ - 2 * (1 / 2) ^ m + (1 / 2) ^ (n + 1)) =\n              γ + (γ - 2 * (1 / 2) ^ m + ((1 / 2) ^ n - (1 / 2) ^ (n + 1))) := by\n            rw [pow_succ, mul_one_div, _root_.sub_half]\n          _ = γ - (1 / 2) ^ (n + 1) + (γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n) := by\n            simp only [sub_eq_add_neg]; abel\n          _ ≤ d (e (n + 1)) + d (f m n) := add_le_add (le_of_lt <| he₂ _) ih\n          _ ≤ d (e (n + 1)) + d (f m n \\ e (n + 1)) + d (f m (n + 1)) := by\n            rw [f_succ _ _ hmn, d_split (f m n) (e (n + 1)) (he₁ _), add_assoc]\n          _ = d (e (n + 1) ∪ f m n) + d (f m (n + 1)) := by\n            rw [d_split (e (n + 1) ∪ f m n) (e (n + 1)), union_diff_left, union_inter_cancel_left]\n            · abel\n            · exact he₁ _\n          _ ≤ γ + d (f m (n + 1)) := add_le_add_right (d_le_γ _ <| (he₁ _).union (hf _ _)) _\n      exact (add_le_add_iff_left γ).1 this\n  let s := ⋃ m, ⋂ n, f m n\n  have γ_le_d_s : γ ≤ d s := by\n    have hγ : Tendsto (fun m : ℕ => γ - 2 * (1 / 2) ^ m) atTop (𝓝 γ) := by\n      suffices Tendsto (fun m : ℕ => γ - 2 * (1 / 2) ^ m) atTop (𝓝 (γ - 2 * 0)) by\n        simpa only [mul_zero, tsub_zero]\n      exact\n        tendsto_const_nhds.sub <|\n          tendsto_const_nhds.mul <|\n            tendsto_pow_atTop_nhds_zero_of_lt_one (le_of_lt <| half_pos <| zero_lt_one)\n              (half_lt_self zero_lt_one)\n    have hd : Tendsto (fun m => d (⋂ n, f m n)) atTop (𝓝 (d (⋃ m, ⋂ n, f m n))) := by\n      refine d_Union _ ?_\n      exact fun n m hnm =>\n        subset_iInter fun i => Subset.trans (iInter_subset (f n) i) <| f_subset_f hnm <| le_rfl\n    refine le_of_tendsto_of_tendsto' hγ hd fun m => ?_\n    have : Tendsto (fun n => d (f m n)) atTop (𝓝 (d (⋂ n, f m n))) := by\n      refine d_Inter _ ?_ ?_\n      · intro n\n        exact hf _ _\n      · intro n m hnm\n        exact f_subset_f le_rfl hnm\n    refine ge_of_tendsto this (eventually_atTop.2 ⟨m, fun n hmn => ?_⟩)\n    change γ - 2 * (1 / 2) ^ m ≤ d (f m n)\n    refine le_trans ?_ (le_d_f _ _ hmn)\n    exact le_add_of_le_of_nonneg le_rfl (pow_nonneg (le_of_lt <| half_pos <| zero_lt_one) _)\n  have hs : MeasurableSet s := MeasurableSet.iUnion fun n => MeasurableSet.iInter fun m => hf _ _\n  refine ⟨s, hs, ?_, ?_⟩\n  · intro t ht hts\n    have : 0 ≤ d t :=\n      (add_le_add_iff_left γ).1 <|\n        calc\n          γ + 0 ≤ d s := by rw [add_zero]; exact γ_le_d_s\n          _ = d (s \\ t) + d t := by rw [d_split s _ ht, inter_eq_self_of_subset_right hts]\n          _ ≤ γ + d t := add_le_add (d_le_γ _ (hs.diff ht)) le_rfl\n\n    rw [← to_nnreal_μ, ← to_nnreal_ν, ENNReal.coe_le_coe, ← NNReal.coe_le_coe]\n    simpa only [d, le_sub_iff_add_le, zero_add] using this\n  · intro t ht hts\n    have : d t ≤ 0 :=\n      (add_le_add_iff_left γ).1 <|\n        calc\n          γ + d t ≤ d s + d t := by gcongr\n          _ = d (s ∪ t) := by\n            rw [d_split (s ∪ t) _ ht, union_diff_right, union_inter_cancel_right,\n              (subset_compl_iff_disjoint_left.1 hts).sdiff_eq_left]\n          _ ≤ γ + 0 := by rw [add_zero]; exact d_le_γ _ (hs.union ht)\n\n    rw [← to_nnreal_μ, ← to_nnreal_ν, ENNReal.coe_le_coe, ← NNReal.coe_le_coe]\n    simpa only [d, sub_le_iff_le_add, zero_add] using this\n\n"}
