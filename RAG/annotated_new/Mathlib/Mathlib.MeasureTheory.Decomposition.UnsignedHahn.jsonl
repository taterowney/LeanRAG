{"name":"MeasureTheory.hahn_decomposition","module":"Mathlib.MeasureTheory.Decomposition.UnsignedHahn","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\ninstâœÂ¹ : MeasureTheory.IsFiniteMeasure Î¼\ninstâœ : MeasureTheory.IsFiniteMeasure Î½\nâŠ¢ Exists fun s => And (MeasurableSet s) (And (âˆ€ (t : Set Î±), MeasurableSet t â†’ HasSubset.Subset t s â†’ LE.le (Î½ t) (Î¼ t)) (âˆ€ (t : Set Î±), MeasurableSet t â†’ HasSubset.Subset t (HasCompl.compl s) â†’ LE.le (Î¼ t) (Î½ t)))","decl":"/-- **Hahn decomposition theorem** -/\ntheorem hahn_decomposition (Î¼ Î½ : Measure Î±) [IsFiniteMeasure Î¼] [IsFiniteMeasure Î½] :\n    âˆƒ s, MeasurableSet s âˆ§ (âˆ€ t, MeasurableSet t â†’ t âŠ† s â†’ Î½ t â‰¤ Î¼ t) âˆ§\n      âˆ€ t, MeasurableSet t â†’ t âŠ† sá¶œ â†’ Î¼ t â‰¤ Î½ t := by\n  let d : Set Î± â†’ â„ := fun s => ((Î¼ s).toNNReal : â„) - (Î½ s).toNNReal\n  let c : Set â„ := d '' { s | MeasurableSet s }\n  let Î³ : â„ := sSup c\n  have hÎ¼ : âˆ€ s, Î¼ s â‰  âˆ := measure_ne_top Î¼\n  have hÎ½ : âˆ€ s, Î½ s â‰  âˆ := measure_ne_top Î½\n  have to_nnreal_Î¼ : âˆ€ s, ((Î¼ s).toNNReal : â„â‰¥0âˆ) = Î¼ s := fun s => ENNReal.coe_toNNReal <| hÎ¼ _\n  have to_nnreal_Î½ : âˆ€ s, ((Î½ s).toNNReal : â„â‰¥0âˆ) = Î½ s := fun s => ENNReal.coe_toNNReal <| hÎ½ _\n  have d_split s t (ht : MeasurableSet t) : d s = d (s \\ t) + d (s âˆ© t) := by\n    dsimp only [d]\n    rw [â† measure_inter_add_diff s ht, â† measure_inter_add_diff s ht,\n      ENNReal.toNNReal_add (hÎ¼ _) (hÎ¼ _), ENNReal.toNNReal_add (hÎ½ _) (hÎ½ _), NNReal.coe_add,\n      NNReal.coe_add]\n    simp only [sub_eq_add_neg, neg_add]\n    abel\n  have d_Union (s : â„• â†’ Set Î±) (hm : Monotone s) :\n    Tendsto (fun n => d (s n)) atTop (ğ“ (d (â‹ƒ n, s n))) := by\n    refine Tendsto.sub ?_ ?_ <;>\n      refine NNReal.tendsto_coe.2 <| (ENNReal.tendsto_toNNReal ?_).comp <|\n        tendsto_measure_iUnion_atTop hm\n    Â· exact hÎ¼ _\n    Â· exact hÎ½ _\n  have d_Inter (s : â„• â†’ Set Î±) (hs : âˆ€ n, MeasurableSet (s n)) (hm : âˆ€ n m, n â‰¤ m â†’ s m âŠ† s n) :\n        Tendsto (fun n => d (s n)) atTop (ğ“ (d (â‹‚ n, s n))) := by\n    refine Tendsto.sub ?_ ?_ <;>\n      refine NNReal.tendsto_coe.2 <| (ENNReal.tendsto_toNNReal <| ?_).comp <|\n        tendsto_measure_iInter_atTop (fun n â†¦ (hs n).nullMeasurableSet) hm ?_\n    exacts [hÎ¼ _, âŸ¨0, hÎ¼ _âŸ©, hÎ½ _, âŸ¨0, hÎ½ _âŸ©]\n  have bdd_c : BddAbove c := by\n    use (Î¼ univ).toNNReal\n    rintro r âŸ¨s, _hs, rflâŸ©\n    refine le_trans (sub_le_self _ <| NNReal.coe_nonneg _) ?_\n    rw [NNReal.coe_le_coe, â† ENNReal.coe_le_coe, to_nnreal_Î¼, to_nnreal_Î¼]\n    exact measure_mono (subset_univ _)\n  have c_nonempty : c.Nonempty := Nonempty.image _ âŸ¨_, MeasurableSet.emptyâŸ©\n  have d_le_Î³ : âˆ€ s, MeasurableSet s â†’ d s â‰¤ Î³ := fun s hs => le_csSup bdd_c âŸ¨s, hs, rflâŸ©\n  have (n : â„•) : âˆƒ s : Set Î±, MeasurableSet s âˆ§ Î³ - (1 / 2) ^ n < d s := by\n    have : Î³ - (1 / 2) ^ n < Î³ := sub_lt_self Î³ (pow_pos (half_pos zero_lt_one) n)\n    rcases exists_lt_of_lt_csSup c_nonempty this with âŸ¨r, âŸ¨s, hs, rflâŸ©, hltâŸ©\n    exact âŸ¨s, hs, hltâŸ©\n  rcases Classical.axiom_of_choice this with âŸ¨e, heâŸ©\n  change â„• â†’ Set Î± at e\n  have heâ‚ : âˆ€ n, MeasurableSet (e n) := fun n => (he n).1\n  have heâ‚‚ : âˆ€ n, Î³ - (1 / 2) ^ n < d (e n) := fun n => (he n).2\n  let f : â„• â†’ â„• â†’ Set Î± := fun n m => (Finset.Ico n (m + 1)).inf e\n  have hf n m : MeasurableSet (f n m) := by\n    simp only [f, Finset.inf_eq_iInf]\n    exact MeasurableSet.biInter (to_countable _) fun i _ => heâ‚ _\n  have f_subset_f {a b c d} (hab : a â‰¤ b) (hcd : c â‰¤ d) : f a d âŠ† f b c := by\n    simp_rw [f, Finset.inf_eq_iInf]\n    exact biInter_subset_biInter_left (Finset.Ico_subset_Ico hab <| Nat.succ_le_succ hcd)\n  have f_succ n m (hnm : n â‰¤ m) : f n (m + 1) = f n m âˆ© e (m + 1) := by\n    have : n â‰¤ m + 1 := le_of_lt (Nat.succ_le_succ hnm)\n    simp_rw [f, Nat.Ico_succ_right_eq_insert_Ico this, Finset.inf_insert, Set.inter_comm]\n    rfl\n  have le_d_f n m (h : m â‰¤ n) : Î³ - 2 * (1 / 2) ^ m + (1 / 2) ^ n â‰¤ d (f m n) := by\n    refine Nat.le_induction ?_ ?_ n h\n    Â· have := heâ‚‚ m\n      simp_rw [f, Nat.Ico_succ_singleton, Finset.inf_singleton]\n      linarith\n    Â· intro n (hmn : m â‰¤ n) ih\n      have : Î³ + (Î³ - 2 * (1 / 2) ^ m + (1 / 2) ^ (n + 1)) â‰¤ Î³ + d (f m (n + 1)) := by\n        calc\n          Î³ + (Î³ - 2 * (1 / 2) ^ m + (1 / 2) ^ (n + 1)) =\n              Î³ + (Î³ - 2 * (1 / 2) ^ m + ((1 / 2) ^ n - (1 / 2) ^ (n + 1))) := by\n            rw [pow_succ, mul_one_div, _root_.sub_half]\n          _ = Î³ - (1 / 2) ^ (n + 1) + (Î³ - 2 * (1 / 2) ^ m + (1 / 2) ^ n) := by\n            simp only [sub_eq_add_neg]; abel\n          _ â‰¤ d (e (n + 1)) + d (f m n) := add_le_add (le_of_lt <| heâ‚‚ _) ih\n          _ â‰¤ d (e (n + 1)) + d (f m n \\ e (n + 1)) + d (f m (n + 1)) := by\n            rw [f_succ _ _ hmn, d_split (f m n) (e (n + 1)) (heâ‚ _), add_assoc]\n          _ = d (e (n + 1) âˆª f m n) + d (f m (n + 1)) := by\n            rw [d_split (e (n + 1) âˆª f m n) (e (n + 1)), union_diff_left, union_inter_cancel_left]\n            Â· abel\n            Â· exact heâ‚ _\n          _ â‰¤ Î³ + d (f m (n + 1)) := add_le_add_right (d_le_Î³ _ <| (heâ‚ _).union (hf _ _)) _\n      exact (add_le_add_iff_left Î³).1 this\n  let s := â‹ƒ m, â‹‚ n, f m n\n  have Î³_le_d_s : Î³ â‰¤ d s := by\n    have hÎ³ : Tendsto (fun m : â„• => Î³ - 2 * (1 / 2) ^ m) atTop (ğ“ Î³) := by\n      suffices Tendsto (fun m : â„• => Î³ - 2 * (1 / 2) ^ m) atTop (ğ“ (Î³ - 2 * 0)) by\n        simpa only [mul_zero, tsub_zero]\n      exact\n        tendsto_const_nhds.sub <|\n          tendsto_const_nhds.mul <|\n            tendsto_pow_atTop_nhds_zero_of_lt_one (le_of_lt <| half_pos <| zero_lt_one)\n              (half_lt_self zero_lt_one)\n    have hd : Tendsto (fun m => d (â‹‚ n, f m n)) atTop (ğ“ (d (â‹ƒ m, â‹‚ n, f m n))) := by\n      refine d_Union _ ?_\n      exact fun n m hnm =>\n        subset_iInter fun i => Subset.trans (iInter_subset (f n) i) <| f_subset_f hnm <| le_rfl\n    refine le_of_tendsto_of_tendsto' hÎ³ hd fun m => ?_\n    have : Tendsto (fun n => d (f m n)) atTop (ğ“ (d (â‹‚ n, f m n))) := by\n      refine d_Inter _ ?_ ?_\n      Â· intro n\n        exact hf _ _\n      Â· intro n m hnm\n        exact f_subset_f le_rfl hnm\n    refine ge_of_tendsto this (eventually_atTop.2 âŸ¨m, fun n hmn => ?_âŸ©)\n    change Î³ - 2 * (1 / 2) ^ m â‰¤ d (f m n)\n    refine le_trans ?_ (le_d_f _ _ hmn)\n    exact le_add_of_le_of_nonneg le_rfl (pow_nonneg (le_of_lt <| half_pos <| zero_lt_one) _)\n  have hs : MeasurableSet s := MeasurableSet.iUnion fun n => MeasurableSet.iInter fun m => hf _ _\n  refine âŸ¨s, hs, ?_, ?_âŸ©\n  Â· intro t ht hts\n    have : 0 â‰¤ d t :=\n      (add_le_add_iff_left Î³).1 <|\n        calc\n          Î³ + 0 â‰¤ d s := by rw [add_zero]; exact Î³_le_d_s\n          _ = d (s \\ t) + d t := by rw [d_split s _ ht, inter_eq_self_of_subset_right hts]\n          _ â‰¤ Î³ + d t := add_le_add (d_le_Î³ _ (hs.diff ht)) le_rfl\n\n    rw [â† to_nnreal_Î¼, â† to_nnreal_Î½, ENNReal.coe_le_coe, â† NNReal.coe_le_coe]\n    simpa only [d, le_sub_iff_add_le, zero_add] using this\n  Â· intro t ht hts\n    have : d t â‰¤ 0 :=\n      (add_le_add_iff_left Î³).1 <|\n        calc\n          Î³ + d t â‰¤ d s + d t := by gcongr\n          _ = d (s âˆª t) := by\n            rw [d_split (s âˆª t) _ ht, union_diff_right, union_inter_cancel_right,\n              (subset_compl_iff_disjoint_left.1 hts).sdiff_eq_left]\n          _ â‰¤ Î³ + 0 := by rw [add_zero]; exact d_le_Î³ _ (hs.union ht)\n\n    rw [â† to_nnreal_Î¼, â† to_nnreal_Î½, ENNReal.coe_le_coe, â† NNReal.coe_le_coe]\n    simpa only [d, sub_le_iff_le_add, zero_add] using this\n\n"}
