{"name":"approximatesLinearOn_empty","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nc : NNReal\nâŠ¢ ApproximatesLinearOn f f' EmptyCollection.emptyCollection c","decl":"@[simp]\ntheorem approximatesLinearOn_empty (f : E â†’ F) (f' : E â†’L[ğ•œ] F) (c : â„â‰¥0) :\n    ApproximatesLinearOn f f' âˆ… c := by simp [ApproximatesLinearOn]\n\n"}
{"name":"ApproximatesLinearOn.mono_num","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\ns : Set E\nc c' : NNReal\nhc : LE.le c c'\nhf : ApproximatesLinearOn f f' s c\nâŠ¢ ApproximatesLinearOn f f' s c'","decl":"theorem mono_num (hc : c â‰¤ c') (hf : ApproximatesLinearOn f f' s c) :\n    ApproximatesLinearOn f f' s c' := fun x hx y hy =>\n  le_trans (hf x hx y hy) (mul_le_mul_of_nonneg_right hc <| norm_nonneg _)\n\n"}
{"name":"ApproximatesLinearOn.mono_set","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\ns t : Set E\nc : NNReal\nhst : HasSubset.Subset s t\nhf : ApproximatesLinearOn f f' t c\nâŠ¢ ApproximatesLinearOn f f' s c","decl":"theorem mono_set (hst : s âŠ† t) (hf : ApproximatesLinearOn f f' t c) :\n    ApproximatesLinearOn f f' s c := fun x hx y hy => hf x (hst hx) y (hst hy)\n\n"}
{"name":"ApproximatesLinearOn.approximatesLinearOn_iff_lipschitzOnWith","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\ns : Set E\nc : NNReal\nâŠ¢ Iff (ApproximatesLinearOn f f' s c) (LipschitzOnWith c (HSub.hSub f â‡‘f') s)","decl":"theorem approximatesLinearOn_iff_lipschitzOnWith {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {s : Set E}\n    {c : â„â‰¥0} : ApproximatesLinearOn f f' s c â†” LipschitzOnWith c (f - â‡‘f') s := by\n  have : âˆ€ x y, f x - f y - f' (x - y) = (f - f') x - (f - f') y := fun x y â†¦ by\n    simp only [map_sub, Pi.sub_apply]; abel\n  simp only [this, lipschitzOnWith_iff_norm_sub_le, ApproximatesLinearOn]\n\n"}
{"name":"ApproximatesLinearOn.lipschitzOnWith","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\ns : Set E\nc : NNReal\naâœ : ApproximatesLinearOn f f' s c\nâŠ¢ LipschitzOnWith c (HSub.hSub f â‡‘f') s","decl":"alias âŸ¨lipschitzOnWith, _root_.LipschitzOnWith.approximatesLinearOnâŸ© :=\n  approximatesLinearOn_iff_lipschitzOnWith\n\n"}
{"name":"LipschitzOnWith.approximatesLinearOn","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\ns : Set E\nc : NNReal\naâœ : LipschitzOnWith c (HSub.hSub f â‡‘f') s\nâŠ¢ ApproximatesLinearOn f f' s c","decl":"alias âŸ¨lipschitzOnWith, _root_.LipschitzOnWith.approximatesLinearOnâŸ© :=\n  approximatesLinearOn_iff_lipschitzOnWith\n\n"}
{"name":"ApproximatesLinearOn.lipschitz_sub","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\ns : Set E\nc : NNReal\nhf : ApproximatesLinearOn f f' s c\nâŠ¢ LipschitzWith c fun x => HSub.hSub (f â†‘x) (f' â†‘x)","decl":"theorem lipschitz_sub (hf : ApproximatesLinearOn f f' s c) :\n    LipschitzWith c fun x : s => f x - f' x :=\n  hf.lipschitzOnWith.to_restrict\n\n"}
{"name":"ApproximatesLinearOn.lipschitz","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\ns : Set E\nc : NNReal\nhf : ApproximatesLinearOn f f' s c\nâŠ¢ LipschitzWith (HAdd.hAdd (NNNorm.nnnorm f') c) (s.restrict f)","decl":"protected theorem lipschitz (hf : ApproximatesLinearOn f f' s c) :\n    LipschitzWith (â€–f'â€–â‚Š + c) (s.restrict f) := by\n  simpa only [restrict_apply, add_sub_cancel] using\n    (f'.lipschitz.restrict s).add hf.lipschitz_sub\n\n"}
{"name":"ApproximatesLinearOn.continuous","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\ns : Set E\nc : NNReal\nhf : ApproximatesLinearOn f f' s c\nâŠ¢ Continuous (s.restrict f)","decl":"protected theorem continuous (hf : ApproximatesLinearOn f f' s c) : Continuous (s.restrict f) :=\n  hf.lipschitz.continuous\n\n"}
{"name":"ApproximatesLinearOn.continuousOn","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\ns : Set E\nc : NNReal\nhf : ApproximatesLinearOn f f' s c\nâŠ¢ ContinuousOn f s","decl":"protected theorem continuousOn (hf : ApproximatesLinearOn f f' s c) : ContinuousOn f s :=\n  continuousOn_iff_continuous_restrict.2 hf.continuous\n\n"}
{"name":"ApproximatesLinearOn.surjOn_closedBall_of_nonlinearRightInverse","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\ninstâœ : CompleteSpace E\ns : Set E\nc : NNReal\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\nÎµ : Real\nb : E\nÎµ0 : LE.le 0 Îµ\nhÎµ : HasSubset.Subset (Metric.closedBall b Îµ) s\nâŠ¢ Set.SurjOn f (Metric.closedBall b Îµ) (Metric.closedBall (f b) (HMul.hMul (HSub.hSub (Inv.inv â†‘f'symm.nnnorm) â†‘c) Îµ))","decl":"/-- If a function is linearly approximated by a continuous linear map with a (possibly nonlinear)\nright inverse, then it is locally onto: a ball of an explicit radius is included in the image\nof the map. -/\ntheorem surjOn_closedBall_of_nonlinearRightInverse\n    (hf : ApproximatesLinearOn f f' s c)\n    (f'symm : f'.NonlinearRightInverse) {Îµ : â„} {b : E} (Îµ0 : 0 â‰¤ Îµ) (hÎµ : closedBall b Îµ âŠ† s) :\n    SurjOn f (closedBall b Îµ) (closedBall (f b) (((f'symm.nnnorm : â„)â»Â¹ - c) * Îµ)) := by\n  intro y hy\n  rcases le_or_lt (f'symm.nnnorm : â„)â»Â¹ c with hc | hc\n  Â· refine âŸ¨b, by simp [Îµ0], ?_âŸ©\n    have : dist y (f b) â‰¤ 0 :=\n      (mem_closedBall.1 hy).trans (mul_nonpos_of_nonpos_of_nonneg (by linarith) Îµ0)\n    simp only [dist_le_zero] at this\n    rw [this]\n  have If' : (0 : â„) < f'symm.nnnorm := by rw [â† inv_pos]; exact (NNReal.coe_nonneg _).trans_lt hc\n  have Icf' : (c : â„) * f'symm.nnnorm < 1 := by rwa [inv_eq_one_div, lt_div_iffâ‚€ If'] at hc\n  have Jf' : (f'symm.nnnorm : â„) â‰  0 := ne_of_gt If'\n  have Jcf' : (1 : â„) - c * f'symm.nnnorm â‰  0 := by apply ne_of_gt; linarith\n  /- We have to show that `y` can be written as `f x` for some `x âˆˆ closedBall b Îµ`.\n    The idea of the proof is to apply the Banach contraction principle to the map\n    `g : x â†¦ x + f'symm (y - f x)`, as a fixed point of this map satisfies `f x = y`.\n    When `f'symm` is a genuine linear inverse, `g` is a contracting map. In our case, since `f'symm`\n    is nonlinear, this map is not contracting (it is not even continuous), but still the proof of\n    the contraction theorem holds: `uâ‚™ = gâ¿ b` is a Cauchy sequence, converging exponentially fast\n    to the desired point `x`. Instead of appealing to general results, we check this by hand.\n\n    The main point is that `f (u n)` becomes exponentially close to `y`, and therefore\n    `dist (u (n+1)) (u n)` becomes exponentally small, making it possible to get an inductive\n    bound on `dist (u n) b`, from which one checks that `u n` stays in the ball on which one has a\n    control. Therefore, the bound can be checked at the next step, and so on inductively.\n    -/\n  set g := fun x => x + f'symm (y - f x) with hg\n  set u := fun n : â„• => g^[n] b with hu\n  have usucc : âˆ€ n, u (n + 1) = g (u n) := by simp [hu, â† iterate_succ_apply' g _ b]\n  -- First bound: if `f z` is close to `y`, then `g z` is close to `z` (i.e., almost a fixed point).\n  have A : âˆ€ z, dist (g z) z â‰¤ f'symm.nnnorm * dist (f z) y := by\n    intro z\n    rw [dist_eq_norm, hg, add_sub_cancel_left, dist_eq_norm']\n    exact f'symm.bound _\n  -- Second bound: if `z` and `g z` are in the set with good control, then `f (g z)` becomes closer\n  -- to `y` than `f z` was (this uses the linear approximation property, and is the reason for the\n  -- choice of the formula for `g`).\n  have B :\n    âˆ€ z âˆˆ closedBall b Îµ,\n      g z âˆˆ closedBall b Îµ â†’ dist (f (g z)) y â‰¤ c * f'symm.nnnorm * dist (f z) y := by\n    intro z hz hgz\n    set v := f'symm (y - f z)\n    calc\n      dist (f (g z)) y = â€–f (z + v) - yâ€– := by rw [dist_eq_norm]\n      _ = â€–f (z + v) - f z - f' v + f' v - (y - f z)â€– := by congr 1; abel\n      _ = â€–f (z + v) - f z - f' (z + v - z)â€– := by\n        simp only [v, ContinuousLinearMap.NonlinearRightInverse.right_inv, add_sub_cancel_left,\n          sub_add_cancel]\n      _ â‰¤ c * â€–z + v - zâ€– := hf _ (hÎµ hgz) _ (hÎµ hz)\n      _ â‰¤ c * (f'symm.nnnorm * dist (f z) y) := by\n        gcongr\n        simpa [dist_eq_norm'] using f'symm.bound (y - f z)\n      _ = c * f'symm.nnnorm * dist (f z) y := by ring\n  -- Third bound: a complicated bound on `dist w b` (that will show up in the induction) is enough\n  -- to check that `w` is in the ball on which one has controls. Will be used to check that `u n`\n  -- belongs to this ball for all `n`.\n  have C : âˆ€ (n : â„•) (w : E), dist w b â‰¤ f'symm.nnnorm * (1 - ((c : â„) * f'symm.nnnorm) ^ n) /\n      (1 - c * f'symm.nnnorm) * dist (f b) y â†’ w âˆˆ closedBall b Îµ := fun n w hw â†¦ by\n    apply hw.trans\n    rw [div_mul_eq_mul_div, div_le_iffâ‚€]; swap; Â· linarith\n    calc\n      (f'symm.nnnorm : â„) * (1 - ((c : â„) * f'symm.nnnorm) ^ n) * dist (f b) y =\n          f'symm.nnnorm * dist (f b) y * (1 - ((c : â„) * f'symm.nnnorm) ^ n) := by\n        ring\n      _ â‰¤ f'symm.nnnorm * dist (f b) y * 1 := by\n        gcongr\n        rw [sub_le_self_iff]\n        positivity\n      _ â‰¤ f'symm.nnnorm * (((f'symm.nnnorm : â„)â»Â¹ - c) * Îµ) := by\n        rw [mul_one]\n        gcongr\n        exact mem_closedBall'.1 hy\n      _ = Îµ * (1 - c * f'symm.nnnorm) := by field_simp; ring\n\n  /- Main inductive control: `f (u n)` becomes exponentially close to `y`, and therefore\n    `dist (u (n+1)) (u n)` becomes exponentally small, making it possible to get an inductive\n    bound on `dist (u n) b`, from which one checks that `u n` remains in the ball on which we\n    have estimates. -/\n  have D : âˆ€ n : â„•, dist (f (u n)) y â‰¤ ((c : â„) * f'symm.nnnorm) ^ n * dist (f b) y âˆ§\n      dist (u n) b â‰¤ f'symm.nnnorm * (1 - ((c : â„) * f'symm.nnnorm) ^ n) /\n        (1 - (c : â„) * f'symm.nnnorm) * dist (f b) y := fun n â†¦ by\n    induction' n with n IH; Â· simp [hu, le_refl]\n    rw [usucc]\n    have Ign : dist (g (u n)) b â‰¤ f'symm.nnnorm * (1 - ((c : â„) * f'symm.nnnorm) ^ n.succ) /\n        (1 - c * f'symm.nnnorm) * dist (f b) y :=\n      calc\n        dist (g (u n)) b â‰¤ dist (g (u n)) (u n) + dist (u n) b := dist_triangle _ _ _\n        _ â‰¤ f'symm.nnnorm * dist (f (u n)) y + dist (u n) b := add_le_add (A _) le_rfl\n        _ â‰¤ f'symm.nnnorm * (((c : â„) * f'symm.nnnorm) ^ n * dist (f b) y) +\n              f'symm.nnnorm * (1 - ((c : â„) * f'symm.nnnorm) ^ n) / (1 - c * f'symm.nnnorm) *\n                dist (f b) y := by\n                  gcongr\n                  Â· exact IH.1\n                  Â· exact IH.2\n        _ = f'symm.nnnorm * (1 - ((c : â„) * f'symm.nnnorm) ^ n.succ) /\n              (1 - (c : â„) * f'symm.nnnorm) * dist (f b) y := by\n          field_simp [Jcf', pow_succ]; ring\n    refine âŸ¨?_, IgnâŸ©\n    calc\n      dist (f (g (u n))) y â‰¤ c * f'symm.nnnorm * dist (f (u n)) y :=\n        B _ (C n _ IH.2) (C n.succ _ Ign)\n      _ â‰¤ (c : â„) * f'symm.nnnorm * (((c : â„) * f'symm.nnnorm) ^ n * dist (f b) y) := by\n        gcongr\n        apply IH.1\n      _ = ((c : â„) * f'symm.nnnorm) ^ n.succ * dist (f b) y := by simp only [pow_succ']; ring\n  -- Deduce from the inductive bound that `uâ‚™` is a Cauchy sequence, therefore converging.\n  have : CauchySeq u := by\n    refine cauchySeq_of_le_geometric _ (â†‘f'symm.nnnorm * dist (f b) y) Icf' fun n â†¦ ?_\n    calc\n      dist (u n) (u (n + 1)) = dist (g (u n)) (u n) := by rw [usucc, dist_comm]\n      _ â‰¤ f'symm.nnnorm * dist (f (u n)) y := A _\n      _ â‰¤ f'symm.nnnorm * (((c : â„) * f'symm.nnnorm) ^ n * dist (f b) y) := by\n        gcongr\n        exact (D n).1\n      _ = f'symm.nnnorm * dist (f b) y * ((c : â„) * f'symm.nnnorm) ^ n := by ring\n  obtain âŸ¨x, hxâŸ© : âˆƒ x, Tendsto u atTop (ğ“ x) := cauchySeq_tendsto_of_complete this\n  -- As all the `uâ‚™` belong to the ball `closedBall b Îµ`, so does their limit `x`.\n  have xmem : x âˆˆ closedBall b Îµ :=\n    isClosed_ball.mem_of_tendsto hx (Eventually.of_forall fun n => C n _ (D n).2)\n  refine âŸ¨x, xmem, ?_âŸ©\n  -- It remains to check that `f x = y`. This follows from continuity of `f` on `closedBall b Îµ`\n  -- and from the fact that `f uâ‚™` is converging to `y` by construction.\n  have hx' : Tendsto u atTop (ğ“[closedBall b Îµ] x) := by\n    simp only [nhdsWithin, tendsto_inf, hx, true_and, tendsto_principal]\n    exact Eventually.of_forall fun n => C n _ (D n).2\n  have T1 : Tendsto (f âˆ˜ u) atTop (ğ“ (f x)) :=\n    (hf.continuousOn.mono hÎµ x xmem).tendsto.comp hx'\n  have T2 : Tendsto (f âˆ˜ u) atTop (ğ“ y) := by\n    rw [tendsto_iff_dist_tendsto_zero]\n    refine squeeze_zero (fun _ => dist_nonneg) (fun n => (D n).1) ?_\n    simpa using (tendsto_pow_atTop_nhds_zero_of_lt_one (by positivity) Icf').mul tendsto_const_nhds\n  exact tendsto_nhds_unique T1 T2\n\n"}
{"name":"ApproximatesLinearOn.open_image","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\ninstâœ : CompleteSpace E\ns : Set E\nc : NNReal\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\nhs : IsOpen s\nhc : Or (Subsingleton F) (LT.lt c (Inv.inv f'symm.nnnorm))\nâŠ¢ IsOpen (Set.image f s)","decl":"theorem open_image (hf : ApproximatesLinearOn f f' s c) (f'symm : f'.NonlinearRightInverse)\n    (hs : IsOpen s) (hc : Subsingleton F âˆ¨ c < f'symm.nnnormâ»Â¹) : IsOpen (f '' s) := by\n  cases' hc with hE hc\n  Â· exact isOpen_discrete _\n  simp only [isOpen_iff_mem_nhds, nhds_basis_closedBall.mem_iff, forall_mem_image] at hs âŠ¢\n  intro x hx\n  rcases hs x hx with âŸ¨Îµ, Îµ0, hÎµâŸ©\n  refine âŸ¨(f'symm.nnnormâ»Â¹ - c) * Îµ, mul_pos (sub_pos.2 hc) Îµ0, ?_âŸ©\n  exact (hf.surjOn_closedBall_of_nonlinearRightInverse f'symm (le_of_lt Îµ0) hÎµ).mono hÎµ Subset.rfl\n\n"}
{"name":"ApproximatesLinearOn.image_mem_nhds","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\ninstâœ : CompleteSpace E\ns : Set E\nc : NNReal\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\nx : E\nhs : Membership.mem (nhds x) s\nhc : Or (Subsingleton F) (LT.lt c (Inv.inv f'symm.nnnorm))\nâŠ¢ Membership.mem (nhds (f x)) (Set.image f s)","decl":"theorem image_mem_nhds (hf : ApproximatesLinearOn f f' s c) (f'symm : f'.NonlinearRightInverse)\n    {x : E} (hs : s âˆˆ ğ“ x) (hc : Subsingleton F âˆ¨ c < f'symm.nnnormâ»Â¹) : f '' s âˆˆ ğ“ (f x) := by\n  obtain âŸ¨t, hts, ht, xtâŸ© : âˆƒ t, t âŠ† s âˆ§ IsOpen t âˆ§ x âˆˆ t := _root_.mem_nhds_iff.1 hs\n  have := IsOpen.mem_nhds ((hf.mono_set hts).open_image f'symm ht hc) (mem_image_of_mem _ xt)\n  exact mem_of_superset this (image_subset _ hts)\n\n"}
{"name":"ApproximatesLinearOn.map_nhds_eq","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\ninstâœ : CompleteSpace E\ns : Set E\nc : NNReal\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\nx : E\nhs : Membership.mem (nhds x) s\nhc : Or (Subsingleton F) (LT.lt c (Inv.inv f'symm.nnnorm))\nâŠ¢ Eq (Filter.map f (nhds x)) (nhds (f x))","decl":"theorem map_nhds_eq (hf : ApproximatesLinearOn f f' s c) (f'symm : f'.NonlinearRightInverse) {x : E}\n    (hs : s âˆˆ ğ“ x) (hc : Subsingleton F âˆ¨ c < f'symm.nnnormâ»Â¹) : map f (ğ“ x) = ğ“ (f x) := by\n  refine\n    le_antisymm ((hf.continuousOn x (mem_of_mem_nhds hs)).continuousAt hs) (le_map fun t ht => ?_)\n  have : f '' (s âˆ© t) âˆˆ ğ“ (f x) :=\n    (hf.mono_set inter_subset_left).image_mem_nhds f'symm (inter_mem hs ht) hc\n  exact mem_of_superset this (image_subset _ inter_subset_right)\n\n"}
{"name":"ApproximatesLinearOn.antilipschitz","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\ns : Set E\nc : NNReal\nhf : ApproximatesLinearOn f (â†‘f') s c\nhc : Or (Subsingleton E) (LT.lt c (Inv.inv (NNNorm.nnnorm â†‘f'.symm)))\nâŠ¢ AntilipschitzWith (Inv.inv (HSub.hSub (Inv.inv (NNNorm.nnnorm â†‘f'.symm)) c)) (s.restrict f)","decl":"protected theorem antilipschitz (hf : ApproximatesLinearOn f (f' : E â†’L[ğ•œ] F) s c)\n    (hc : Subsingleton E âˆ¨ c < Nâ»Â¹) : AntilipschitzWith (Nâ»Â¹ - c)â»Â¹ (s.restrict f) := by\n  cases' hc with hE hc\n  Â· exact AntilipschitzWith.of_subsingleton\n  convert (f'.antilipschitz.restrict s).add_lipschitzWith hf.lipschitz_sub hc\n  simp [restrict]\n\n"}
{"name":"ApproximatesLinearOn.injective","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\ns : Set E\nc : NNReal\nhf : ApproximatesLinearOn f (â†‘f') s c\nhc : Or (Subsingleton E) (LT.lt c (Inv.inv (NNNorm.nnnorm â†‘f'.symm)))\nâŠ¢ Function.Injective (s.restrict f)","decl":"protected theorem injective (hf : ApproximatesLinearOn f (f' : E â†’L[ğ•œ] F) s c)\n    (hc : Subsingleton E âˆ¨ c < Nâ»Â¹) : Injective (s.restrict f) :=\n  (hf.antilipschitz hc).injective\n\n"}
{"name":"ApproximatesLinearOn.injOn","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\ns : Set E\nc : NNReal\nhf : ApproximatesLinearOn f (â†‘f') s c\nhc : Or (Subsingleton E) (LT.lt c (Inv.inv (NNNorm.nnnorm â†‘f'.symm)))\nâŠ¢ Set.InjOn f s","decl":"protected theorem injOn (hf : ApproximatesLinearOn f (f' : E â†’L[ğ•œ] F) s c)\n    (hc : Subsingleton E âˆ¨ c < Nâ»Â¹) : InjOn f s :=\n  injOn_iff_injective.2 <| hf.injective hc\n\n"}
{"name":"ApproximatesLinearOn.surjective","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nc : NNReal\ninstâœ : CompleteSpace E\nhf : ApproximatesLinearOn f (â†‘f') Set.univ c\nhc : Or (Subsingleton E) (LT.lt c (Inv.inv (NNNorm.nnnorm â†‘f'.symm)))\nâŠ¢ Function.Surjective f","decl":"protected theorem surjective [CompleteSpace E] (hf : ApproximatesLinearOn f (f' : E â†’L[ğ•œ] F) univ c)\n    (hc : Subsingleton E âˆ¨ c < Nâ»Â¹) : Surjective f := by\n  cases' hc with hE hc\n  Â· haveI : Subsingleton F := (Equiv.subsingleton_congr f'.toEquiv).1 hE\n    exact surjective_to_subsingleton _\n  Â· apply forall_of_forall_mem_closedBall (fun y : F => âˆƒ a, f a = y) (f 0) _\n    have hc' : (0 : â„) < Nâ»Â¹ - c := by rw [sub_pos]; exact hc\n    let p : â„ â†’ Prop := fun R => closedBall (f 0) R âŠ† Set.range f\n    have hp : âˆ€á¶  r : â„ in atTop, p ((Nâ»Â¹ - c) * r) := by\n      have hr : âˆ€á¶  r : â„ in atTop, 0 â‰¤ r := eventually_ge_atTop 0\n      refine hr.mono fun r hr => Subset.trans ?_ (image_subset_range f (closedBall 0 r))\n      refine hf.surjOn_closedBall_of_nonlinearRightInverse f'.toNonlinearRightInverse hr ?_\n      exact subset_univ _\n    refine ((tendsto_id.const_mul_atTop hc').frequently hp.frequently).mono ?_\n    exact fun R h y hy => h hy\n\n"}
{"name":"ApproximatesLinearOn.inverse_continuousOn","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\ns : Set E\nc : NNReal\nhf : ApproximatesLinearOn f (â†‘f') s c\nhc : Or (Subsingleton E) (LT.lt c (Inv.inv (NNNorm.nnnorm â†‘f'.symm)))\nâŠ¢ ContinuousOn (â†‘(hf.toPartialEquiv hc).symm) (Set.image f s)","decl":"/-- The inverse function is continuous on `f '' s`.\nUse properties of `PartialHomeomorph` instead. -/\ntheorem inverse_continuousOn (hf : ApproximatesLinearOn f (f' : E â†’L[ğ•œ] F) s c)\n    (hc : Subsingleton E âˆ¨ c < Nâ»Â¹) : ContinuousOn (hf.toPartialEquiv hc).symm (f '' s) := by\n  apply continuousOn_iff_continuous_restrict.2\n  refine ((hf.antilipschitz hc).to_rightInvOn' ?_ (hf.toPartialEquiv hc).right_inv').continuous\n  exact fun x hx => (hf.toPartialEquiv hc).map_target hx\n\n"}
{"name":"ApproximatesLinearOn.to_inv","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\ns : Set E\nc : NNReal\nhf : ApproximatesLinearOn f (â†‘f') s c\nhc : Or (Subsingleton E) (LT.lt c (Inv.inv (NNNorm.nnnorm â†‘f'.symm)))\nâŠ¢ ApproximatesLinearOn (â†‘(hf.toPartialEquiv hc).symm) (â†‘f'.symm) (Set.image f s) (HMul.hMul (HMul.hMul (NNNorm.nnnorm â†‘f'.symm) (Inv.inv (HSub.hSub (Inv.inv (NNNorm.nnnorm â†‘f'.symm)) c))) c)","decl":"/-- The inverse function is approximated linearly on `f '' s` by `f'.symm`. -/\ntheorem to_inv (hf : ApproximatesLinearOn f (f' : E â†’L[ğ•œ] F) s c) (hc : Subsingleton E âˆ¨ c < Nâ»Â¹) :\n    ApproximatesLinearOn (hf.toPartialEquiv hc).symm (f'.symm : F â†’L[ğ•œ] E) (f '' s)\n      (N * (Nâ»Â¹ - c)â»Â¹ * c) := fun x hx y hy â†¦ by\n  set A := hf.toPartialEquiv hc\n  have Af : âˆ€ z, A z = f z := fun z => rfl\n  rcases (mem_image _ _ _).1 hx with âŸ¨x', x's, rflâŸ©\n  rcases (mem_image _ _ _).1 hy with âŸ¨y', y's, rflâŸ©\n  rw [â† Af x', â† Af y', A.left_inv x's, A.left_inv y's]\n  calc\n    â€–x' - y' - f'.symm (A x' - A y')â€– â‰¤ N * â€–f' (x' - y' - f'.symm (A x' - A y'))â€– :=\n      (f' : E â†’L[ğ•œ] F).bound_of_antilipschitz f'.antilipschitz _\n    _ = N * â€–A y' - A x' - f' (y' - x')â€– := by\n      congr 2\n      simp only [ContinuousLinearEquiv.apply_symm_apply, ContinuousLinearEquiv.map_sub]\n      abel\n    _ â‰¤ N * (c * â€–y' - x'â€–) := mul_le_mul_of_nonneg_left (hf _ y's _ x's) (NNReal.coe_nonneg _)\n    _ â‰¤ N * (c * (((Nâ»Â¹ - c)â»Â¹ : â„â‰¥0) * â€–A y' - A x'â€–)) := by\n      gcongr\n      rw [â† dist_eq_norm, â† dist_eq_norm]\n      exact (hf.antilipschitz hc).le_mul_dist âŸ¨y', y'sâŸ© âŸ¨x', x'sâŸ©\n    _ = (N * (Nâ»Â¹ - c)â»Â¹ * c : â„â‰¥0) * â€–A x' - A y'â€– := by\n      simp only [norm_sub_rev, NNReal.coe_mul]; ring\n\n"}
{"name":"ApproximatesLinearOn.toPartialHomeomorph_coe","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\ns : Set E\nc : NNReal\ninstâœ : CompleteSpace E\nhf : ApproximatesLinearOn f (â†‘f') s c\nhc : Or (Subsingleton E) (LT.lt c (Inv.inv (NNNorm.nnnorm â†‘f'.symm)))\nhs : IsOpen s\nâŠ¢ Eq (â†‘(ApproximatesLinearOn.toPartialHomeomorph f s hf hc hs)) f","decl":"@[simp]\ntheorem toPartialHomeomorph_coe (hf : ApproximatesLinearOn f (f' : E â†’L[ğ•œ] F) s c)\n    (hc : Subsingleton E âˆ¨ c < Nâ»Â¹) (hs : IsOpen s) :\n    (hf.toPartialHomeomorph f s hc hs : E â†’ F) = f :=\n  rfl\n\n"}
{"name":"ApproximatesLinearOn.toPartialHomeomorph_source","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\ns : Set E\nc : NNReal\ninstâœ : CompleteSpace E\nhf : ApproximatesLinearOn f (â†‘f') s c\nhc : Or (Subsingleton E) (LT.lt c (Inv.inv (NNNorm.nnnorm â†‘f'.symm)))\nhs : IsOpen s\nâŠ¢ Eq (ApproximatesLinearOn.toPartialHomeomorph f s hf hc hs).source s","decl":"@[simp]\ntheorem toPartialHomeomorph_source (hf : ApproximatesLinearOn f (f' : E â†’L[ğ•œ] F) s c)\n    (hc : Subsingleton E âˆ¨ c < Nâ»Â¹) (hs : IsOpen s) :\n    (hf.toPartialHomeomorph f s hc hs).source = s :=\n  rfl\n\n"}
{"name":"ApproximatesLinearOn.toPartialHomeomorph_target","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\ns : Set E\nc : NNReal\ninstâœ : CompleteSpace E\nhf : ApproximatesLinearOn f (â†‘f') s c\nhc : Or (Subsingleton E) (LT.lt c (Inv.inv (NNNorm.nnnorm â†‘f'.symm)))\nhs : IsOpen s\nâŠ¢ Eq (ApproximatesLinearOn.toPartialHomeomorph f s hf hc hs).target (Set.image f s)","decl":"@[simp]\ntheorem toPartialHomeomorph_target (hf : ApproximatesLinearOn f (f' : E â†’L[ğ•œ] F) s c)\n    (hc : Subsingleton E âˆ¨ c < Nâ»Â¹) (hs : IsOpen s) :\n    (hf.toPartialHomeomorph f s hc hs).target = f '' s :=\n  rfl\n\n"}
{"name":"ApproximatesLinearOn.closedBall_subset_target","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nÎµ : Real\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\ns : Set E\nc : NNReal\ninstâœ : CompleteSpace E\nhf : ApproximatesLinearOn f (â†‘f') s c\nhc : Or (Subsingleton E) (LT.lt c (Inv.inv (NNNorm.nnnorm â†‘f'.symm)))\nhs : IsOpen s\nb : E\nÎµ0 : LE.le 0 Îµ\nhÎµ : HasSubset.Subset (Metric.closedBall b Îµ) s\nâŠ¢ HasSubset.Subset (Metric.closedBall (f b) (HMul.hMul (HSub.hSub â†‘(Inv.inv (NNNorm.nnnorm â†‘f'.symm)) â†‘c) Îµ)) (ApproximatesLinearOn.toPartialHomeomorph f s hf hc hs).target","decl":"theorem closedBall_subset_target (hf : ApproximatesLinearOn f (f' : E â†’L[ğ•œ] F) s c)\n    (hc : Subsingleton E âˆ¨ c < Nâ»Â¹) (hs : IsOpen s) {b : E} (Îµ0 : 0 â‰¤ Îµ) (hÎµ : closedBall b Îµ âŠ† s) :\n    closedBall (f b) ((Nâ»Â¹ - c) * Îµ) âŠ† (hf.toPartialHomeomorph f s hc hs).target :=\n  (hf.surjOn_closedBall_of_nonlinearRightInverse f'.toNonlinearRightInverse Îµ0 hÎµ).mono hÎµ\n    Subset.rfl\n\n"}
