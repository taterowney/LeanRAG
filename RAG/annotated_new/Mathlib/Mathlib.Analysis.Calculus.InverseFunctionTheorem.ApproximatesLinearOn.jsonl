{"name":"approximatesLinearOn_empty","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nc : NNReal\n⊢ ApproximatesLinearOn f f' EmptyCollection.emptyCollection c","decl":"@[simp]\ntheorem approximatesLinearOn_empty (f : E → F) (f' : E →L[𝕜] F) (c : ℝ≥0) :\n    ApproximatesLinearOn f f' ∅ c := by simp [ApproximatesLinearOn]\n\n"}
{"name":"ApproximatesLinearOn.mono_num","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\ns : Set E\nc c' : NNReal\nhc : LE.le c c'\nhf : ApproximatesLinearOn f f' s c\n⊢ ApproximatesLinearOn f f' s c'","decl":"theorem mono_num (hc : c ≤ c') (hf : ApproximatesLinearOn f f' s c) :\n    ApproximatesLinearOn f f' s c' := fun x hx y hy =>\n  le_trans (hf x hx y hy) (mul_le_mul_of_nonneg_right hc <| norm_nonneg _)\n\n"}
{"name":"ApproximatesLinearOn.mono_set","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\ns t : Set E\nc : NNReal\nhst : HasSubset.Subset s t\nhf : ApproximatesLinearOn f f' t c\n⊢ ApproximatesLinearOn f f' s c","decl":"theorem mono_set (hst : s ⊆ t) (hf : ApproximatesLinearOn f f' t c) :\n    ApproximatesLinearOn f f' s c := fun x hx y hy => hf x (hst hx) y (hst hy)\n\n"}
{"name":"ApproximatesLinearOn.approximatesLinearOn_iff_lipschitzOnWith","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\ns : Set E\nc : NNReal\n⊢ Iff (ApproximatesLinearOn f f' s c) (LipschitzOnWith c (HSub.hSub f ⇑f') s)","decl":"theorem approximatesLinearOn_iff_lipschitzOnWith {f : E → F} {f' : E →L[𝕜] F} {s : Set E}\n    {c : ℝ≥0} : ApproximatesLinearOn f f' s c ↔ LipschitzOnWith c (f - ⇑f') s := by\n  have : ∀ x y, f x - f y - f' (x - y) = (f - f') x - (f - f') y := fun x y ↦ by\n    simp only [map_sub, Pi.sub_apply]; abel\n  simp only [this, lipschitzOnWith_iff_norm_sub_le, ApproximatesLinearOn]\n\n"}
{"name":"ApproximatesLinearOn.lipschitzOnWith","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\ns : Set E\nc : NNReal\na✝ : ApproximatesLinearOn f f' s c\n⊢ LipschitzOnWith c (HSub.hSub f ⇑f') s","decl":"alias ⟨lipschitzOnWith, _root_.LipschitzOnWith.approximatesLinearOn⟩ :=\n  approximatesLinearOn_iff_lipschitzOnWith\n\n"}
{"name":"LipschitzOnWith.approximatesLinearOn","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\ns : Set E\nc : NNReal\na✝ : LipschitzOnWith c (HSub.hSub f ⇑f') s\n⊢ ApproximatesLinearOn f f' s c","decl":"alias ⟨lipschitzOnWith, _root_.LipschitzOnWith.approximatesLinearOn⟩ :=\n  approximatesLinearOn_iff_lipschitzOnWith\n\n"}
{"name":"ApproximatesLinearOn.lipschitz_sub","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\ns : Set E\nc : NNReal\nhf : ApproximatesLinearOn f f' s c\n⊢ LipschitzWith c fun x => HSub.hSub (f ↑x) (f' ↑x)","decl":"theorem lipschitz_sub (hf : ApproximatesLinearOn f f' s c) :\n    LipschitzWith c fun x : s => f x - f' x :=\n  hf.lipschitzOnWith.to_restrict\n\n"}
{"name":"ApproximatesLinearOn.lipschitz","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\ns : Set E\nc : NNReal\nhf : ApproximatesLinearOn f f' s c\n⊢ LipschitzWith (HAdd.hAdd (NNNorm.nnnorm f') c) (s.restrict f)","decl":"protected theorem lipschitz (hf : ApproximatesLinearOn f f' s c) :\n    LipschitzWith (‖f'‖₊ + c) (s.restrict f) := by\n  simpa only [restrict_apply, add_sub_cancel] using\n    (f'.lipschitz.restrict s).add hf.lipschitz_sub\n\n"}
{"name":"ApproximatesLinearOn.continuous","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\ns : Set E\nc : NNReal\nhf : ApproximatesLinearOn f f' s c\n⊢ Continuous (s.restrict f)","decl":"protected theorem continuous (hf : ApproximatesLinearOn f f' s c) : Continuous (s.restrict f) :=\n  hf.lipschitz.continuous\n\n"}
{"name":"ApproximatesLinearOn.continuousOn","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\ns : Set E\nc : NNReal\nhf : ApproximatesLinearOn f f' s c\n⊢ ContinuousOn f s","decl":"protected theorem continuousOn (hf : ApproximatesLinearOn f f' s c) : ContinuousOn f s :=\n  continuousOn_iff_continuous_restrict.2 hf.continuous\n\n"}
{"name":"ApproximatesLinearOn.surjOn_closedBall_of_nonlinearRightInverse","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\ninst✝ : CompleteSpace E\ns : Set E\nc : NNReal\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\nε : Real\nb : E\nε0 : LE.le 0 ε\nhε : HasSubset.Subset (Metric.closedBall b ε) s\n⊢ Set.SurjOn f (Metric.closedBall b ε) (Metric.closedBall (f b) (HMul.hMul (HSub.hSub (Inv.inv ↑f'symm.nnnorm) ↑c) ε))","decl":"/-- If a function is linearly approximated by a continuous linear map with a (possibly nonlinear)\nright inverse, then it is locally onto: a ball of an explicit radius is included in the image\nof the map. -/\ntheorem surjOn_closedBall_of_nonlinearRightInverse\n    (hf : ApproximatesLinearOn f f' s c)\n    (f'symm : f'.NonlinearRightInverse) {ε : ℝ} {b : E} (ε0 : 0 ≤ ε) (hε : closedBall b ε ⊆ s) :\n    SurjOn f (closedBall b ε) (closedBall (f b) (((f'symm.nnnorm : ℝ)⁻¹ - c) * ε)) := by\n  intro y hy\n  rcases le_or_lt (f'symm.nnnorm : ℝ)⁻¹ c with hc | hc\n  · refine ⟨b, by simp [ε0], ?_⟩\n    have : dist y (f b) ≤ 0 :=\n      (mem_closedBall.1 hy).trans (mul_nonpos_of_nonpos_of_nonneg (by linarith) ε0)\n    simp only [dist_le_zero] at this\n    rw [this]\n  have If' : (0 : ℝ) < f'symm.nnnorm := by rw [← inv_pos]; exact (NNReal.coe_nonneg _).trans_lt hc\n  have Icf' : (c : ℝ) * f'symm.nnnorm < 1 := by rwa [inv_eq_one_div, lt_div_iff₀ If'] at hc\n  have Jf' : (f'symm.nnnorm : ℝ) ≠ 0 := ne_of_gt If'\n  have Jcf' : (1 : ℝ) - c * f'symm.nnnorm ≠ 0 := by apply ne_of_gt; linarith\n  /- We have to show that `y` can be written as `f x` for some `x ∈ closedBall b ε`.\n    The idea of the proof is to apply the Banach contraction principle to the map\n    `g : x ↦ x + f'symm (y - f x)`, as a fixed point of this map satisfies `f x = y`.\n    When `f'symm` is a genuine linear inverse, `g` is a contracting map. In our case, since `f'symm`\n    is nonlinear, this map is not contracting (it is not even continuous), but still the proof of\n    the contraction theorem holds: `uₙ = gⁿ b` is a Cauchy sequence, converging exponentially fast\n    to the desired point `x`. Instead of appealing to general results, we check this by hand.\n\n    The main point is that `f (u n)` becomes exponentially close to `y`, and therefore\n    `dist (u (n+1)) (u n)` becomes exponentally small, making it possible to get an inductive\n    bound on `dist (u n) b`, from which one checks that `u n` stays in the ball on which one has a\n    control. Therefore, the bound can be checked at the next step, and so on inductively.\n    -/\n  set g := fun x => x + f'symm (y - f x) with hg\n  set u := fun n : ℕ => g^[n] b with hu\n  have usucc : ∀ n, u (n + 1) = g (u n) := by simp [hu, ← iterate_succ_apply' g _ b]\n  -- First bound: if `f z` is close to `y`, then `g z` is close to `z` (i.e., almost a fixed point).\n  have A : ∀ z, dist (g z) z ≤ f'symm.nnnorm * dist (f z) y := by\n    intro z\n    rw [dist_eq_norm, hg, add_sub_cancel_left, dist_eq_norm']\n    exact f'symm.bound _\n  -- Second bound: if `z` and `g z` are in the set with good control, then `f (g z)` becomes closer\n  -- to `y` than `f z` was (this uses the linear approximation property, and is the reason for the\n  -- choice of the formula for `g`).\n  have B :\n    ∀ z ∈ closedBall b ε,\n      g z ∈ closedBall b ε → dist (f (g z)) y ≤ c * f'symm.nnnorm * dist (f z) y := by\n    intro z hz hgz\n    set v := f'symm (y - f z)\n    calc\n      dist (f (g z)) y = ‖f (z + v) - y‖ := by rw [dist_eq_norm]\n      _ = ‖f (z + v) - f z - f' v + f' v - (y - f z)‖ := by congr 1; abel\n      _ = ‖f (z + v) - f z - f' (z + v - z)‖ := by\n        simp only [v, ContinuousLinearMap.NonlinearRightInverse.right_inv, add_sub_cancel_left,\n          sub_add_cancel]\n      _ ≤ c * ‖z + v - z‖ := hf _ (hε hgz) _ (hε hz)\n      _ ≤ c * (f'symm.nnnorm * dist (f z) y) := by\n        gcongr\n        simpa [dist_eq_norm'] using f'symm.bound (y - f z)\n      _ = c * f'symm.nnnorm * dist (f z) y := by ring\n  -- Third bound: a complicated bound on `dist w b` (that will show up in the induction) is enough\n  -- to check that `w` is in the ball on which one has controls. Will be used to check that `u n`\n  -- belongs to this ball for all `n`.\n  have C : ∀ (n : ℕ) (w : E), dist w b ≤ f'symm.nnnorm * (1 - ((c : ℝ) * f'symm.nnnorm) ^ n) /\n      (1 - c * f'symm.nnnorm) * dist (f b) y → w ∈ closedBall b ε := fun n w hw ↦ by\n    apply hw.trans\n    rw [div_mul_eq_mul_div, div_le_iff₀]; swap; · linarith\n    calc\n      (f'symm.nnnorm : ℝ) * (1 - ((c : ℝ) * f'symm.nnnorm) ^ n) * dist (f b) y =\n          f'symm.nnnorm * dist (f b) y * (1 - ((c : ℝ) * f'symm.nnnorm) ^ n) := by\n        ring\n      _ ≤ f'symm.nnnorm * dist (f b) y * 1 := by\n        gcongr\n        rw [sub_le_self_iff]\n        positivity\n      _ ≤ f'symm.nnnorm * (((f'symm.nnnorm : ℝ)⁻¹ - c) * ε) := by\n        rw [mul_one]\n        gcongr\n        exact mem_closedBall'.1 hy\n      _ = ε * (1 - c * f'symm.nnnorm) := by field_simp; ring\n\n  /- Main inductive control: `f (u n)` becomes exponentially close to `y`, and therefore\n    `dist (u (n+1)) (u n)` becomes exponentally small, making it possible to get an inductive\n    bound on `dist (u n) b`, from which one checks that `u n` remains in the ball on which we\n    have estimates. -/\n  have D : ∀ n : ℕ, dist (f (u n)) y ≤ ((c : ℝ) * f'symm.nnnorm) ^ n * dist (f b) y ∧\n      dist (u n) b ≤ f'symm.nnnorm * (1 - ((c : ℝ) * f'symm.nnnorm) ^ n) /\n        (1 - (c : ℝ) * f'symm.nnnorm) * dist (f b) y := fun n ↦ by\n    induction' n with n IH; · simp [hu, le_refl]\n    rw [usucc]\n    have Ign : dist (g (u n)) b ≤ f'symm.nnnorm * (1 - ((c : ℝ) * f'symm.nnnorm) ^ n.succ) /\n        (1 - c * f'symm.nnnorm) * dist (f b) y :=\n      calc\n        dist (g (u n)) b ≤ dist (g (u n)) (u n) + dist (u n) b := dist_triangle _ _ _\n        _ ≤ f'symm.nnnorm * dist (f (u n)) y + dist (u n) b := add_le_add (A _) le_rfl\n        _ ≤ f'symm.nnnorm * (((c : ℝ) * f'symm.nnnorm) ^ n * dist (f b) y) +\n              f'symm.nnnorm * (1 - ((c : ℝ) * f'symm.nnnorm) ^ n) / (1 - c * f'symm.nnnorm) *\n                dist (f b) y := by\n                  gcongr\n                  · exact IH.1\n                  · exact IH.2\n        _ = f'symm.nnnorm * (1 - ((c : ℝ) * f'symm.nnnorm) ^ n.succ) /\n              (1 - (c : ℝ) * f'symm.nnnorm) * dist (f b) y := by\n          field_simp [Jcf', pow_succ]; ring\n    refine ⟨?_, Ign⟩\n    calc\n      dist (f (g (u n))) y ≤ c * f'symm.nnnorm * dist (f (u n)) y :=\n        B _ (C n _ IH.2) (C n.succ _ Ign)\n      _ ≤ (c : ℝ) * f'symm.nnnorm * (((c : ℝ) * f'symm.nnnorm) ^ n * dist (f b) y) := by\n        gcongr\n        apply IH.1\n      _ = ((c : ℝ) * f'symm.nnnorm) ^ n.succ * dist (f b) y := by simp only [pow_succ']; ring\n  -- Deduce from the inductive bound that `uₙ` is a Cauchy sequence, therefore converging.\n  have : CauchySeq u := by\n    refine cauchySeq_of_le_geometric _ (↑f'symm.nnnorm * dist (f b) y) Icf' fun n ↦ ?_\n    calc\n      dist (u n) (u (n + 1)) = dist (g (u n)) (u n) := by rw [usucc, dist_comm]\n      _ ≤ f'symm.nnnorm * dist (f (u n)) y := A _\n      _ ≤ f'symm.nnnorm * (((c : ℝ) * f'symm.nnnorm) ^ n * dist (f b) y) := by\n        gcongr\n        exact (D n).1\n      _ = f'symm.nnnorm * dist (f b) y * ((c : ℝ) * f'symm.nnnorm) ^ n := by ring\n  obtain ⟨x, hx⟩ : ∃ x, Tendsto u atTop (𝓝 x) := cauchySeq_tendsto_of_complete this\n  -- As all the `uₙ` belong to the ball `closedBall b ε`, so does their limit `x`.\n  have xmem : x ∈ closedBall b ε :=\n    isClosed_ball.mem_of_tendsto hx (Eventually.of_forall fun n => C n _ (D n).2)\n  refine ⟨x, xmem, ?_⟩\n  -- It remains to check that `f x = y`. This follows from continuity of `f` on `closedBall b ε`\n  -- and from the fact that `f uₙ` is converging to `y` by construction.\n  have hx' : Tendsto u atTop (𝓝[closedBall b ε] x) := by\n    simp only [nhdsWithin, tendsto_inf, hx, true_and, tendsto_principal]\n    exact Eventually.of_forall fun n => C n _ (D n).2\n  have T1 : Tendsto (f ∘ u) atTop (𝓝 (f x)) :=\n    (hf.continuousOn.mono hε x xmem).tendsto.comp hx'\n  have T2 : Tendsto (f ∘ u) atTop (𝓝 y) := by\n    rw [tendsto_iff_dist_tendsto_zero]\n    refine squeeze_zero (fun _ => dist_nonneg) (fun n => (D n).1) ?_\n    simpa using (tendsto_pow_atTop_nhds_zero_of_lt_one (by positivity) Icf').mul tendsto_const_nhds\n  exact tendsto_nhds_unique T1 T2\n\n"}
{"name":"ApproximatesLinearOn.open_image","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\ninst✝ : CompleteSpace E\ns : Set E\nc : NNReal\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\nhs : IsOpen s\nhc : Or (Subsingleton F) (LT.lt c (Inv.inv f'symm.nnnorm))\n⊢ IsOpen (Set.image f s)","decl":"theorem open_image (hf : ApproximatesLinearOn f f' s c) (f'symm : f'.NonlinearRightInverse)\n    (hs : IsOpen s) (hc : Subsingleton F ∨ c < f'symm.nnnorm⁻¹) : IsOpen (f '' s) := by\n  cases' hc with hE hc\n  · exact isOpen_discrete _\n  simp only [isOpen_iff_mem_nhds, nhds_basis_closedBall.mem_iff, forall_mem_image] at hs ⊢\n  intro x hx\n  rcases hs x hx with ⟨ε, ε0, hε⟩\n  refine ⟨(f'symm.nnnorm⁻¹ - c) * ε, mul_pos (sub_pos.2 hc) ε0, ?_⟩\n  exact (hf.surjOn_closedBall_of_nonlinearRightInverse f'symm (le_of_lt ε0) hε).mono hε Subset.rfl\n\n"}
{"name":"ApproximatesLinearOn.image_mem_nhds","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\ninst✝ : CompleteSpace E\ns : Set E\nc : NNReal\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\nx : E\nhs : Membership.mem (nhds x) s\nhc : Or (Subsingleton F) (LT.lt c (Inv.inv f'symm.nnnorm))\n⊢ Membership.mem (nhds (f x)) (Set.image f s)","decl":"theorem image_mem_nhds (hf : ApproximatesLinearOn f f' s c) (f'symm : f'.NonlinearRightInverse)\n    {x : E} (hs : s ∈ 𝓝 x) (hc : Subsingleton F ∨ c < f'symm.nnnorm⁻¹) : f '' s ∈ 𝓝 (f x) := by\n  obtain ⟨t, hts, ht, xt⟩ : ∃ t, t ⊆ s ∧ IsOpen t ∧ x ∈ t := _root_.mem_nhds_iff.1 hs\n  have := IsOpen.mem_nhds ((hf.mono_set hts).open_image f'symm ht hc) (mem_image_of_mem _ xt)\n  exact mem_of_superset this (image_subset _ hts)\n\n"}
{"name":"ApproximatesLinearOn.map_nhds_eq","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\ninst✝ : CompleteSpace E\ns : Set E\nc : NNReal\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\nx : E\nhs : Membership.mem (nhds x) s\nhc : Or (Subsingleton F) (LT.lt c (Inv.inv f'symm.nnnorm))\n⊢ Eq (Filter.map f (nhds x)) (nhds (f x))","decl":"theorem map_nhds_eq (hf : ApproximatesLinearOn f f' s c) (f'symm : f'.NonlinearRightInverse) {x : E}\n    (hs : s ∈ 𝓝 x) (hc : Subsingleton F ∨ c < f'symm.nnnorm⁻¹) : map f (𝓝 x) = 𝓝 (f x) := by\n  refine\n    le_antisymm ((hf.continuousOn x (mem_of_mem_nhds hs)).continuousAt hs) (le_map fun t ht => ?_)\n  have : f '' (s ∩ t) ∈ 𝓝 (f x) :=\n    (hf.mono_set inter_subset_left).image_mem_nhds f'symm (inter_mem hs ht) hc\n  exact mem_of_superset this (image_subset _ inter_subset_right)\n\n"}
{"name":"ApproximatesLinearOn.antilipschitz","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\ns : Set E\nc : NNReal\nhf : ApproximatesLinearOn f (↑f') s c\nhc : Or (Subsingleton E) (LT.lt c (Inv.inv (NNNorm.nnnorm ↑f'.symm)))\n⊢ AntilipschitzWith (Inv.inv (HSub.hSub (Inv.inv (NNNorm.nnnorm ↑f'.symm)) c)) (s.restrict f)","decl":"protected theorem antilipschitz (hf : ApproximatesLinearOn f (f' : E →L[𝕜] F) s c)\n    (hc : Subsingleton E ∨ c < N⁻¹) : AntilipschitzWith (N⁻¹ - c)⁻¹ (s.restrict f) := by\n  cases' hc with hE hc\n  · exact AntilipschitzWith.of_subsingleton\n  convert (f'.antilipschitz.restrict s).add_lipschitzWith hf.lipschitz_sub hc\n  simp [restrict]\n\n"}
{"name":"ApproximatesLinearOn.injective","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\ns : Set E\nc : NNReal\nhf : ApproximatesLinearOn f (↑f') s c\nhc : Or (Subsingleton E) (LT.lt c (Inv.inv (NNNorm.nnnorm ↑f'.symm)))\n⊢ Function.Injective (s.restrict f)","decl":"protected theorem injective (hf : ApproximatesLinearOn f (f' : E →L[𝕜] F) s c)\n    (hc : Subsingleton E ∨ c < N⁻¹) : Injective (s.restrict f) :=\n  (hf.antilipschitz hc).injective\n\n"}
{"name":"ApproximatesLinearOn.injOn","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\ns : Set E\nc : NNReal\nhf : ApproximatesLinearOn f (↑f') s c\nhc : Or (Subsingleton E) (LT.lt c (Inv.inv (NNNorm.nnnorm ↑f'.symm)))\n⊢ Set.InjOn f s","decl":"protected theorem injOn (hf : ApproximatesLinearOn f (f' : E →L[𝕜] F) s c)\n    (hc : Subsingleton E ∨ c < N⁻¹) : InjOn f s :=\n  injOn_iff_injective.2 <| hf.injective hc\n\n"}
{"name":"ApproximatesLinearOn.surjective","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nc : NNReal\ninst✝ : CompleteSpace E\nhf : ApproximatesLinearOn f (↑f') Set.univ c\nhc : Or (Subsingleton E) (LT.lt c (Inv.inv (NNNorm.nnnorm ↑f'.symm)))\n⊢ Function.Surjective f","decl":"protected theorem surjective [CompleteSpace E] (hf : ApproximatesLinearOn f (f' : E →L[𝕜] F) univ c)\n    (hc : Subsingleton E ∨ c < N⁻¹) : Surjective f := by\n  cases' hc with hE hc\n  · haveI : Subsingleton F := (Equiv.subsingleton_congr f'.toEquiv).1 hE\n    exact surjective_to_subsingleton _\n  · apply forall_of_forall_mem_closedBall (fun y : F => ∃ a, f a = y) (f 0) _\n    have hc' : (0 : ℝ) < N⁻¹ - c := by rw [sub_pos]; exact hc\n    let p : ℝ → Prop := fun R => closedBall (f 0) R ⊆ Set.range f\n    have hp : ∀ᶠ r : ℝ in atTop, p ((N⁻¹ - c) * r) := by\n      have hr : ∀ᶠ r : ℝ in atTop, 0 ≤ r := eventually_ge_atTop 0\n      refine hr.mono fun r hr => Subset.trans ?_ (image_subset_range f (closedBall 0 r))\n      refine hf.surjOn_closedBall_of_nonlinearRightInverse f'.toNonlinearRightInverse hr ?_\n      exact subset_univ _\n    refine ((tendsto_id.const_mul_atTop hc').frequently hp.frequently).mono ?_\n    exact fun R h y hy => h hy\n\n"}
{"name":"ApproximatesLinearOn.inverse_continuousOn","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\ns : Set E\nc : NNReal\nhf : ApproximatesLinearOn f (↑f') s c\nhc : Or (Subsingleton E) (LT.lt c (Inv.inv (NNNorm.nnnorm ↑f'.symm)))\n⊢ ContinuousOn (↑(hf.toPartialEquiv hc).symm) (Set.image f s)","decl":"/-- The inverse function is continuous on `f '' s`.\nUse properties of `PartialHomeomorph` instead. -/\ntheorem inverse_continuousOn (hf : ApproximatesLinearOn f (f' : E →L[𝕜] F) s c)\n    (hc : Subsingleton E ∨ c < N⁻¹) : ContinuousOn (hf.toPartialEquiv hc).symm (f '' s) := by\n  apply continuousOn_iff_continuous_restrict.2\n  refine ((hf.antilipschitz hc).to_rightInvOn' ?_ (hf.toPartialEquiv hc).right_inv').continuous\n  exact fun x hx => (hf.toPartialEquiv hc).map_target hx\n\n"}
{"name":"ApproximatesLinearOn.to_inv","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\ns : Set E\nc : NNReal\nhf : ApproximatesLinearOn f (↑f') s c\nhc : Or (Subsingleton E) (LT.lt c (Inv.inv (NNNorm.nnnorm ↑f'.symm)))\n⊢ ApproximatesLinearOn (↑(hf.toPartialEquiv hc).symm) (↑f'.symm) (Set.image f s) (HMul.hMul (HMul.hMul (NNNorm.nnnorm ↑f'.symm) (Inv.inv (HSub.hSub (Inv.inv (NNNorm.nnnorm ↑f'.symm)) c))) c)","decl":"/-- The inverse function is approximated linearly on `f '' s` by `f'.symm`. -/\ntheorem to_inv (hf : ApproximatesLinearOn f (f' : E →L[𝕜] F) s c) (hc : Subsingleton E ∨ c < N⁻¹) :\n    ApproximatesLinearOn (hf.toPartialEquiv hc).symm (f'.symm : F →L[𝕜] E) (f '' s)\n      (N * (N⁻¹ - c)⁻¹ * c) := fun x hx y hy ↦ by\n  set A := hf.toPartialEquiv hc\n  have Af : ∀ z, A z = f z := fun z => rfl\n  rcases (mem_image _ _ _).1 hx with ⟨x', x's, rfl⟩\n  rcases (mem_image _ _ _).1 hy with ⟨y', y's, rfl⟩\n  rw [← Af x', ← Af y', A.left_inv x's, A.left_inv y's]\n  calc\n    ‖x' - y' - f'.symm (A x' - A y')‖ ≤ N * ‖f' (x' - y' - f'.symm (A x' - A y'))‖ :=\n      (f' : E →L[𝕜] F).bound_of_antilipschitz f'.antilipschitz _\n    _ = N * ‖A y' - A x' - f' (y' - x')‖ := by\n      congr 2\n      simp only [ContinuousLinearEquiv.apply_symm_apply, ContinuousLinearEquiv.map_sub]\n      abel\n    _ ≤ N * (c * ‖y' - x'‖) := mul_le_mul_of_nonneg_left (hf _ y's _ x's) (NNReal.coe_nonneg _)\n    _ ≤ N * (c * (((N⁻¹ - c)⁻¹ : ℝ≥0) * ‖A y' - A x'‖)) := by\n      gcongr\n      rw [← dist_eq_norm, ← dist_eq_norm]\n      exact (hf.antilipschitz hc).le_mul_dist ⟨y', y's⟩ ⟨x', x's⟩\n    _ = (N * (N⁻¹ - c)⁻¹ * c : ℝ≥0) * ‖A x' - A y'‖ := by\n      simp only [norm_sub_rev, NNReal.coe_mul]; ring\n\n"}
{"name":"ApproximatesLinearOn.toPartialHomeomorph_coe","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\ns : Set E\nc : NNReal\ninst✝ : CompleteSpace E\nhf : ApproximatesLinearOn f (↑f') s c\nhc : Or (Subsingleton E) (LT.lt c (Inv.inv (NNNorm.nnnorm ↑f'.symm)))\nhs : IsOpen s\n⊢ Eq (↑(ApproximatesLinearOn.toPartialHomeomorph f s hf hc hs)) f","decl":"@[simp]\ntheorem toPartialHomeomorph_coe (hf : ApproximatesLinearOn f (f' : E →L[𝕜] F) s c)\n    (hc : Subsingleton E ∨ c < N⁻¹) (hs : IsOpen s) :\n    (hf.toPartialHomeomorph f s hc hs : E → F) = f :=\n  rfl\n\n"}
{"name":"ApproximatesLinearOn.toPartialHomeomorph_source","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\ns : Set E\nc : NNReal\ninst✝ : CompleteSpace E\nhf : ApproximatesLinearOn f (↑f') s c\nhc : Or (Subsingleton E) (LT.lt c (Inv.inv (NNNorm.nnnorm ↑f'.symm)))\nhs : IsOpen s\n⊢ Eq (ApproximatesLinearOn.toPartialHomeomorph f s hf hc hs).source s","decl":"@[simp]\ntheorem toPartialHomeomorph_source (hf : ApproximatesLinearOn f (f' : E →L[𝕜] F) s c)\n    (hc : Subsingleton E ∨ c < N⁻¹) (hs : IsOpen s) :\n    (hf.toPartialHomeomorph f s hc hs).source = s :=\n  rfl\n\n"}
{"name":"ApproximatesLinearOn.toPartialHomeomorph_target","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\ns : Set E\nc : NNReal\ninst✝ : CompleteSpace E\nhf : ApproximatesLinearOn f (↑f') s c\nhc : Or (Subsingleton E) (LT.lt c (Inv.inv (NNNorm.nnnorm ↑f'.symm)))\nhs : IsOpen s\n⊢ Eq (ApproximatesLinearOn.toPartialHomeomorph f s hf hc hs).target (Set.image f s)","decl":"@[simp]\ntheorem toPartialHomeomorph_target (hf : ApproximatesLinearOn f (f' : E →L[𝕜] F) s c)\n    (hc : Subsingleton E ∨ c < N⁻¹) (hs : IsOpen s) :\n    (hf.toPartialHomeomorph f s hc hs).target = f '' s :=\n  rfl\n\n"}
{"name":"ApproximatesLinearOn.closedBall_subset_target","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nε : Real\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\ns : Set E\nc : NNReal\ninst✝ : CompleteSpace E\nhf : ApproximatesLinearOn f (↑f') s c\nhc : Or (Subsingleton E) (LT.lt c (Inv.inv (NNNorm.nnnorm ↑f'.symm)))\nhs : IsOpen s\nb : E\nε0 : LE.le 0 ε\nhε : HasSubset.Subset (Metric.closedBall b ε) s\n⊢ HasSubset.Subset (Metric.closedBall (f b) (HMul.hMul (HSub.hSub ↑(Inv.inv (NNNorm.nnnorm ↑f'.symm)) ↑c) ε)) (ApproximatesLinearOn.toPartialHomeomorph f s hf hc hs).target","decl":"theorem closedBall_subset_target (hf : ApproximatesLinearOn f (f' : E →L[𝕜] F) s c)\n    (hc : Subsingleton E ∨ c < N⁻¹) (hs : IsOpen s) {b : E} (ε0 : 0 ≤ ε) (hε : closedBall b ε ⊆ s) :\n    closedBall (f b) ((N⁻¹ - c) * ε) ⊆ (hf.toPartialHomeomorph f s hc hs).target :=\n  (hf.surjOn_closedBall_of_nonlinearRightInverse f'.toNonlinearRightInverse ε0 hε).mono hε\n    Subset.rfl\n\n"}
