{"name":"subtype_val_mono","module":"Mathlib.CategoryTheory.Subobject.Types","initialProofState":"α : Type u\ns : Set α\n⊢ CategoryTheory.Mono (CategoryTheory.asHom Subtype.val)","decl":"theorem subtype_val_mono {α : Type u} (s : Set α) : Mono (↾(Subtype.val : s → α)) :=\n  (mono_iff_injective _).mpr Subtype.val_injective\n\n"}
{"name":"Types.monoOverEquivalenceSet_inverse_map","module":"Mathlib.CategoryTheory.Subobject.Types","initialProofState":"α : Type u\ns t : Set α\nb : Quiver.Hom s t\n⊢ Eq ((Types.monoOverEquivalenceSet α).inverse.map b) (CategoryTheory.MonoOver.homMk (fun w => ⟨↑w, ⋯⟩) ⋯)","decl":"/-- The category of `MonoOver α`, for `α : Type u`, is equivalent to the partial order `Set α`.\n-/\n@[simps]\nnoncomputable def Types.monoOverEquivalenceSet (α : Type u) : MonoOver α ≌ Set α where\n  functor :=\n    { obj := fun f => Set.range f.1.hom\n      map := fun {f g} t =>\n        homOfLE\n          (by\n            rintro a ⟨x, rfl⟩\n            exact ⟨t.1 x, congr_fun t.w x⟩) }\n  inverse :=\n    { obj := fun s => MonoOver.mk' (Subtype.val : s → α)\n      map := fun {s t} b => MonoOver.homMk (fun w => ⟨w.1, Set.mem_of_mem_of_subset w.2 b.le⟩) }\n  unitIso :=\n    NatIso.ofComponents fun f =>\n      MonoOver.isoMk (Equiv.ofInjective f.1.hom ((mono_iff_injective _).mp f.2)).toIso\n  counitIso := NatIso.ofComponents fun _ => eqToIso Subtype.range_val\n\n"}
{"name":"Types.monoOverEquivalenceSet_unitIso","module":"Mathlib.CategoryTheory.Subobject.Types","initialProofState":"α : Type u\n⊢ Eq (Types.monoOverEquivalenceSet α).unitIso (CategoryTheory.NatIso.ofComponents (fun f => CategoryTheory.MonoOver.isoMk (Equiv.ofInjective f.obj.hom ⋯).toIso ⋯) ⋯)","decl":"/-- The category of `MonoOver α`, for `α : Type u`, is equivalent to the partial order `Set α`.\n-/\n@[simps]\nnoncomputable def Types.monoOverEquivalenceSet (α : Type u) : MonoOver α ≌ Set α where\n  functor :=\n    { obj := fun f => Set.range f.1.hom\n      map := fun {f g} t =>\n        homOfLE\n          (by\n            rintro a ⟨x, rfl⟩\n            exact ⟨t.1 x, congr_fun t.w x⟩) }\n  inverse :=\n    { obj := fun s => MonoOver.mk' (Subtype.val : s → α)\n      map := fun {s t} b => MonoOver.homMk (fun w => ⟨w.1, Set.mem_of_mem_of_subset w.2 b.le⟩) }\n  unitIso :=\n    NatIso.ofComponents fun f =>\n      MonoOver.isoMk (Equiv.ofInjective f.1.hom ((mono_iff_injective _).mp f.2)).toIso\n  counitIso := NatIso.ofComponents fun _ => eqToIso Subtype.range_val\n\n"}
{"name":"Types.monoOverEquivalenceSet_functor_obj","module":"Mathlib.CategoryTheory.Subobject.Types","initialProofState":"α : Type u\nf : CategoryTheory.MonoOver α\n⊢ Eq ((Types.monoOverEquivalenceSet α).functor.obj f) (Set.range f.obj.hom)","decl":"/-- The category of `MonoOver α`, for `α : Type u`, is equivalent to the partial order `Set α`.\n-/\n@[simps]\nnoncomputable def Types.monoOverEquivalenceSet (α : Type u) : MonoOver α ≌ Set α where\n  functor :=\n    { obj := fun f => Set.range f.1.hom\n      map := fun {f g} t =>\n        homOfLE\n          (by\n            rintro a ⟨x, rfl⟩\n            exact ⟨t.1 x, congr_fun t.w x⟩) }\n  inverse :=\n    { obj := fun s => MonoOver.mk' (Subtype.val : s → α)\n      map := fun {s t} b => MonoOver.homMk (fun w => ⟨w.1, Set.mem_of_mem_of_subset w.2 b.le⟩) }\n  unitIso :=\n    NatIso.ofComponents fun f =>\n      MonoOver.isoMk (Equiv.ofInjective f.1.hom ((mono_iff_injective _).mp f.2)).toIso\n  counitIso := NatIso.ofComponents fun _ => eqToIso Subtype.range_val\n\n"}
{"name":"Types.monoOverEquivalenceSet_inverse_obj","module":"Mathlib.CategoryTheory.Subobject.Types","initialProofState":"α : Type u\ns : Set α\n⊢ Eq ((Types.monoOverEquivalenceSet α).inverse.obj s) (CategoryTheory.MonoOver.mk' Subtype.val)","decl":"/-- The category of `MonoOver α`, for `α : Type u`, is equivalent to the partial order `Set α`.\n-/\n@[simps]\nnoncomputable def Types.monoOverEquivalenceSet (α : Type u) : MonoOver α ≌ Set α where\n  functor :=\n    { obj := fun f => Set.range f.1.hom\n      map := fun {f g} t =>\n        homOfLE\n          (by\n            rintro a ⟨x, rfl⟩\n            exact ⟨t.1 x, congr_fun t.w x⟩) }\n  inverse :=\n    { obj := fun s => MonoOver.mk' (Subtype.val : s → α)\n      map := fun {s t} b => MonoOver.homMk (fun w => ⟨w.1, Set.mem_of_mem_of_subset w.2 b.le⟩) }\n  unitIso :=\n    NatIso.ofComponents fun f =>\n      MonoOver.isoMk (Equiv.ofInjective f.1.hom ((mono_iff_injective _).mp f.2)).toIso\n  counitIso := NatIso.ofComponents fun _ => eqToIso Subtype.range_val\n\n"}
{"name":"Types.monoOverEquivalenceSet_functor_map","module":"Mathlib.CategoryTheory.Subobject.Types","initialProofState":"α : Type u\nf g : CategoryTheory.MonoOver α\nt : Quiver.Hom f g\n⊢ Eq ((Types.monoOverEquivalenceSet α).functor.map t) (CategoryTheory.homOfLE ⋯)","decl":"/-- The category of `MonoOver α`, for `α : Type u`, is equivalent to the partial order `Set α`.\n-/\n@[simps]\nnoncomputable def Types.monoOverEquivalenceSet (α : Type u) : MonoOver α ≌ Set α where\n  functor :=\n    { obj := fun f => Set.range f.1.hom\n      map := fun {f g} t =>\n        homOfLE\n          (by\n            rintro a ⟨x, rfl⟩\n            exact ⟨t.1 x, congr_fun t.w x⟩) }\n  inverse :=\n    { obj := fun s => MonoOver.mk' (Subtype.val : s → α)\n      map := fun {s t} b => MonoOver.homMk (fun w => ⟨w.1, Set.mem_of_mem_of_subset w.2 b.le⟩) }\n  unitIso :=\n    NatIso.ofComponents fun f =>\n      MonoOver.isoMk (Equiv.ofInjective f.1.hom ((mono_iff_injective _).mp f.2)).toIso\n  counitIso := NatIso.ofComponents fun _ => eqToIso Subtype.range_val\n\n"}
{"name":"Types.monoOverEquivalenceSet_counitIso","module":"Mathlib.CategoryTheory.Subobject.Types","initialProofState":"α : Type u\n⊢ Eq (Types.monoOverEquivalenceSet α).counitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.eqToIso ⋯) ⋯)","decl":"/-- The category of `MonoOver α`, for `α : Type u`, is equivalent to the partial order `Set α`.\n-/\n@[simps]\nnoncomputable def Types.monoOverEquivalenceSet (α : Type u) : MonoOver α ≌ Set α where\n  functor :=\n    { obj := fun f => Set.range f.1.hom\n      map := fun {f g} t =>\n        homOfLE\n          (by\n            rintro a ⟨x, rfl⟩\n            exact ⟨t.1 x, congr_fun t.w x⟩) }\n  inverse :=\n    { obj := fun s => MonoOver.mk' (Subtype.val : s → α)\n      map := fun {s t} b => MonoOver.homMk (fun w => ⟨w.1, Set.mem_of_mem_of_subset w.2 b.le⟩) }\n  unitIso :=\n    NatIso.ofComponents fun f =>\n      MonoOver.isoMk (Equiv.ofInjective f.1.hom ((mono_iff_injective _).mp f.2)).toIso\n  counitIso := NatIso.ofComponents fun _ => eqToIso Subtype.range_val\n\n"}
{"name":"instWellPoweredType","module":"Mathlib.CategoryTheory.Subobject.Types","initialProofState":"⊢ CategoryTheory.WellPowered.{u, u, u + 1} (Type u)","decl":"instance : WellPowered.{u} (Type u) :=\n  wellPowered_of_essentiallySmall_monoOver fun α =>\n    EssentiallySmall.mk' (Types.monoOverEquivalenceSet α)\n\n"}
