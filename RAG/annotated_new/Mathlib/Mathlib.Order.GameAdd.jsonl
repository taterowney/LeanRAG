{"name":"Prod.gameAdd_iff","module":"Mathlib.Order.GameAdd","initialProofState":"α : Type u_1\nβ : Type u_2\nrα : α → α → Prop\nrβ : β → β → Prop\nx y : Prod α β\n⊢ Iff (Prod.GameAdd rα rβ x y) (Or (And (rα x.1 y.1) (Eq x.2 y.2)) (And (rβ x.2 y.2) (Eq x.1 y.1)))","decl":"theorem gameAdd_iff {rα rβ} {x y : α × β} :\n    GameAdd rα rβ x y ↔ rα x.1 y.1 ∧ x.2 = y.2 ∨ rβ x.2 y.2 ∧ x.1 = y.1 := by\n  constructor\n  · rintro (@⟨a₁, a₂, b, h⟩ | @⟨a, b₁, b₂, h⟩)\n    exacts [Or.inl ⟨h, rfl⟩, Or.inr ⟨h, rfl⟩]\n  · revert x y\n    rintro ⟨a₁, b₁⟩ ⟨a₂, b₂⟩ (⟨h, rfl : b₁ = b₂⟩ | ⟨h, rfl : a₁ = a₂⟩)\n    exacts [GameAdd.fst h, GameAdd.snd h]\n\n"}
{"name":"Prod.gameAdd_mk_iff","module":"Mathlib.Order.GameAdd","initialProofState":"α : Type u_1\nβ : Type u_2\nrα : α → α → Prop\nrβ : β → β → Prop\na₁ a₂ : α\nb₁ b₂ : β\n⊢ Iff (Prod.GameAdd rα rβ { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ }) (Or (And (rα a₁ a₂) (Eq b₁ b₂)) (And (rβ b₁ b₂) (Eq a₁ a₂)))","decl":"theorem gameAdd_mk_iff {rα rβ} {a₁ a₂ : α} {b₁ b₂ : β} :\n    GameAdd rα rβ (a₁, b₁) (a₂, b₂) ↔ rα a₁ a₂ ∧ b₁ = b₂ ∨ rβ b₁ b₂ ∧ a₁ = a₂ :=\n  gameAdd_iff\n\n"}
{"name":"Prod.gameAdd_swap_swap","module":"Mathlib.Order.GameAdd","initialProofState":"α : Type u_1\nβ : Type u_2\nrα : α → α → Prop\nrβ : β → β → Prop\na b : Prod α β\n⊢ Iff (Prod.GameAdd rβ rα a.swap b.swap) (Prod.GameAdd rα rβ a b)","decl":"@[simp]\ntheorem gameAdd_swap_swap : ∀ a b : α × β, GameAdd rβ rα a.swap b.swap ↔ GameAdd rα rβ a b :=\n  fun ⟨a₁, b₁⟩ ⟨a₂, b₂⟩ => by rw [Prod.swap, Prod.swap, gameAdd_mk_iff, gameAdd_mk_iff, or_comm]\n\n"}
{"name":"Prod.gameAdd_swap_swap_mk","module":"Mathlib.Order.GameAdd","initialProofState":"α : Type u_1\nβ : Type u_2\nrα : α → α → Prop\nrβ : β → β → Prop\na₁ a₂ : α\nb₁ b₂ : β\n⊢ Iff (Prod.GameAdd rα rβ { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ }) (Prod.GameAdd rβ rα { fst := b₁, snd := a₁ } { fst := b₂, snd := a₂ })","decl":"theorem gameAdd_swap_swap_mk (a₁ a₂ : α) (b₁ b₂ : β) :\n    GameAdd rα rβ (a₁, b₁) (a₂, b₂) ↔ GameAdd rβ rα (b₁, a₁) (b₂, a₂) :=\n  gameAdd_swap_swap rβ rα (b₁, a₁) (b₂, a₂)\n\n"}
{"name":"Prod.gameAdd_le_lex","module":"Mathlib.Order.GameAdd","initialProofState":"α : Type u_1\nβ : Type u_2\nrα : α → α → Prop\nrβ : β → β → Prop\n⊢ LE.le (Prod.GameAdd rα rβ) (Prod.Lex rα rβ)","decl":"/-- `Prod.GameAdd` is a subrelation of `Prod.Lex`. -/\ntheorem gameAdd_le_lex : GameAdd rα rβ ≤ Prod.Lex rα rβ := fun _ _ h =>\n  h.rec (Prod.Lex.left _ _) (Prod.Lex.right _)\n\n"}
{"name":"Prod.rprod_le_transGen_gameAdd","module":"Mathlib.Order.GameAdd","initialProofState":"α : Type u_1\nβ : Type u_2\nrα : α → α → Prop\nrβ : β → β → Prop\n⊢ LE.le (Prod.RProd rα rβ) (Relation.TransGen (Prod.GameAdd rα rβ))","decl":"/-- `Prod.RProd` is a subrelation of the transitive closure of `Prod.GameAdd`. -/\ntheorem rprod_le_transGen_gameAdd : RProd rα rβ ≤ Relation.TransGen (GameAdd rα rβ)\n  | _, _, h => h.rec (by\n      intro _ _ _ _ hα hβ\n      exact Relation.TransGen.tail (Relation.TransGen.single <| GameAdd.fst hα) (GameAdd.snd hβ))\n\n"}
{"name":"Acc.prod_gameAdd","module":"Mathlib.Order.GameAdd","initialProofState":"α : Type u_1\nβ : Type u_2\nrα : α → α → Prop\nrβ : β → β → Prop\na : α\nb : β\nha : Acc rα a\nhb : Acc rβ b\n⊢ Acc (Prod.GameAdd rα rβ) { fst := a, snd := b }","decl":"/-- If `a` is accessible under `rα` and `b` is accessible under `rβ`, then `(a, b)` is\n  accessible under `Prod.GameAdd rα rβ`. Notice that `Prod.lexAccessible` requires the\n  stronger condition `∀ b, Acc rβ b`. -/\ntheorem Acc.prod_gameAdd (ha : Acc rα a) (hb : Acc rβ b) :\n    Acc (Prod.GameAdd rα rβ) (a, b) := by\n  induction' ha with a _ iha generalizing b\n  induction' hb with b hb ihb\n  refine Acc.intro _ fun h => ?_\n  rintro (⟨ra⟩ | ⟨rb⟩)\n  exacts [iha _ ra (Acc.intro b hb), ihb _ rb]\n\n"}
{"name":"WellFounded.prod_gameAdd","module":"Mathlib.Order.GameAdd","initialProofState":"α : Type u_1\nβ : Type u_2\nrα : α → α → Prop\nrβ : β → β → Prop\nhα : WellFounded rα\nhβ : WellFounded rβ\n⊢ WellFounded (Prod.GameAdd rα rβ)","decl":"/-- The `Prod.GameAdd` relation on well-founded inputs is well-founded.\n\n  In particular, the sum of two well-founded games is well-founded. -/\ntheorem WellFounded.prod_gameAdd (hα : WellFounded rα) (hβ : WellFounded rβ) :\n    WellFounded (Prod.GameAdd rα rβ) :=\n  ⟨fun ⟨a, b⟩ => (hα.apply a).prod_gameAdd (hβ.apply b)⟩\n\n"}
{"name":"Prod.GameAdd.fix_eq","module":"Mathlib.Order.GameAdd","initialProofState":"α : Type u_1\nβ : Type u_2\nrα : α → α → Prop\nrβ : β → β → Prop\nC : α → β → Sort u_3\nhα : WellFounded rα\nhβ : WellFounded rβ\nIH : (a₁ : α) → (b₁ : β) → ((a₂ : α) → (b₂ : β) → Prod.GameAdd rα rβ { fst := a₂, snd := b₂ } { fst := a₁, snd := b₁ } → C a₂ b₂) → C a₁ b₁\na : α\nb : β\n⊢ Eq (Prod.GameAdd.fix hα hβ IH a b) (IH a b fun a' b' x => Prod.GameAdd.fix hα hβ IH a' b')","decl":"theorem GameAdd.fix_eq {C : α → β → Sort*} (hα : WellFounded rα) (hβ : WellFounded rβ)\n    (IH : ∀ a₁ b₁, (∀ a₂ b₂, GameAdd rα rβ (a₂, b₂) (a₁, b₁) → C a₂ b₂) → C a₁ b₁) (a : α) (b : β) :\n    GameAdd.fix hα hβ IH a b = IH a b fun a' b' _ => GameAdd.fix hα hβ IH a' b' :=\n  WellFounded.fix_eq _ _ _\n\n"}
{"name":"Prod.GameAdd.induction","module":"Mathlib.Order.GameAdd","initialProofState":"α : Type u_1\nβ : Type u_2\nrα : α → α → Prop\nrβ : β → β → Prop\nC : α → β → Prop\na✝² : WellFounded rα\na✝¹ : WellFounded rβ\na✝ : ∀ (a₁ : α) (b₁ : β), (∀ (a₂ : α) (b₂ : β), Prod.GameAdd rα rβ { fst := a₂, snd := b₂ } { fst := a₁, snd := b₁ } → C a₂ b₂) → C a₁ b₁\na : α\nb : β\n⊢ C a b","decl":"/-- Induction on the well-founded `Prod.GameAdd` relation.\n  Note that it's strictly more general to induct on the lexicographic order instead. -/\ntheorem GameAdd.induction {C : α → β → Prop} :\n    WellFounded rα →\n      WellFounded rβ →\n        (∀ a₁ b₁, (∀ a₂ b₂, GameAdd rα rβ (a₂, b₂) (a₁, b₁) → C a₂ b₂) → C a₁ b₁) → ∀ a b, C a b :=\n  GameAdd.fix\n\n"}
{"name":"Sym2.gameAdd_iff","module":"Mathlib.Order.GameAdd","initialProofState":"α : Type u_1\nrα : α → α → Prop\nx y : Prod α α\n⊢ Iff (Sym2.GameAdd rα (Sym2.mk x) (Sym2.mk y)) (Or (Prod.GameAdd rα rα x y) (Prod.GameAdd rα rα x.swap y))","decl":"theorem gameAdd_iff : ∀ {x y : α × α},\n    GameAdd rα (Sym2.mk x) (Sym2.mk y) ↔ Prod.GameAdd rα rα x y ∨ Prod.GameAdd rα rα x.swap y := by\n  rintro ⟨_, _⟩ ⟨_, _⟩\n  rfl\n\n"}
{"name":"Sym2.gameAdd_mk'_iff","module":"Mathlib.Order.GameAdd","initialProofState":"α : Type u_1\nrα : α → α → Prop\na₁ a₂ b₁ b₂ : α\n⊢ Iff (Sym2.GameAdd rα (Sym2.mk { fst := a₁, snd := b₁ }) (Sym2.mk { fst := a₂, snd := b₂ })) (Or (Prod.GameAdd rα rα { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ }) (Prod.GameAdd rα rα { fst := b₁, snd := a₁ } { fst := a₂, snd := b₂ }))","decl":"theorem gameAdd_mk'_iff {a₁ a₂ b₁ b₂ : α} :\n    GameAdd rα s(a₁, b₁) s(a₂, b₂) ↔\n      Prod.GameAdd rα rα (a₁, b₁) (a₂, b₂) ∨ Prod.GameAdd rα rα (b₁, a₁) (a₂, b₂) :=\n  Iff.rfl\n\n"}
{"name":"Prod.GameAdd.to_sym2","module":"Mathlib.Order.GameAdd","initialProofState":"α : Type u_1\nrα : α → α → Prop\na₁ a₂ b₁ b₂ : α\nh : Prod.GameAdd rα rα { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ }\n⊢ Sym2.GameAdd rα (Sym2.mk { fst := a₁, snd := b₁ }) (Sym2.mk { fst := a₂, snd := b₂ })","decl":"theorem _root_.Prod.GameAdd.to_sym2 {a₁ a₂ b₁ b₂ : α} (h : Prod.GameAdd rα rα (a₁, b₁) (a₂, b₂)) :\n    Sym2.GameAdd rα s(a₁, b₁) s(a₂, b₂) :=\n  gameAdd_mk'_iff.2 <| Or.inl <| h\n\n"}
{"name":"Sym2.GameAdd.fst","module":"Mathlib.Order.GameAdd","initialProofState":"α : Type u_1\nrα : α → α → Prop\na₁ a₂ b : α\nh : rα a₁ a₂\n⊢ Sym2.GameAdd rα (Sym2.mk { fst := a₁, snd := b }) (Sym2.mk { fst := a₂, snd := b })","decl":"theorem GameAdd.fst {a₁ a₂ b : α} (h : rα a₁ a₂) : GameAdd rα s(a₁, b) s(a₂, b) :=\n  (Prod.GameAdd.fst h).to_sym2\n\n"}
{"name":"Sym2.GameAdd.snd","module":"Mathlib.Order.GameAdd","initialProofState":"α : Type u_1\nrα : α → α → Prop\na b₁ b₂ : α\nh : rα b₁ b₂\n⊢ Sym2.GameAdd rα (Sym2.mk { fst := a, snd := b₁ }) (Sym2.mk { fst := a, snd := b₂ })","decl":"theorem GameAdd.snd {a b₁ b₂ : α} (h : rα b₁ b₂) : GameAdd rα s(a, b₁) s(a, b₂) :=\n  (Prod.GameAdd.snd h).to_sym2\n\n"}
{"name":"Sym2.GameAdd.fst_snd","module":"Mathlib.Order.GameAdd","initialProofState":"α : Type u_1\nrα : α → α → Prop\na₁ a₂ b : α\nh : rα a₁ a₂\n⊢ Sym2.GameAdd rα (Sym2.mk { fst := a₁, snd := b }) (Sym2.mk { fst := b, snd := a₂ })","decl":"theorem GameAdd.fst_snd {a₁ a₂ b : α} (h : rα a₁ a₂) : GameAdd rα s(a₁, b) s(b, a₂) := by\n  rw [Sym2.eq_swap]\n  exact GameAdd.snd h\n\n"}
{"name":"Sym2.GameAdd.snd_fst","module":"Mathlib.Order.GameAdd","initialProofState":"α : Type u_1\nrα : α → α → Prop\na₁ a₂ b : α\nh : rα a₁ a₂\n⊢ Sym2.GameAdd rα (Sym2.mk { fst := b, snd := a₁ }) (Sym2.mk { fst := a₂, snd := b })","decl":"theorem GameAdd.snd_fst {a₁ a₂ b : α} (h : rα a₁ a₂) : GameAdd rα s(b, a₁) s(a₂, b) := by\n  rw [Sym2.eq_swap]\n  exact GameAdd.fst h\n\n"}
{"name":"Acc.sym2_gameAdd","module":"Mathlib.Order.GameAdd","initialProofState":"α : Type u_1\nrα : α → α → Prop\na b : α\nha : Acc rα a\nhb : Acc rα b\n⊢ Acc (Sym2.GameAdd rα) (Sym2.mk { fst := a, snd := b })","decl":"theorem Acc.sym2_gameAdd {a b} (ha : Acc rα a) (hb : Acc rα b) :\n    Acc (Sym2.GameAdd rα) s(a, b) := by\n  induction' ha with a _ iha generalizing b\n  induction' hb with b hb ihb\n  refine Acc.intro _ fun s => ?_\n  induction' s with c d\n  rw [Sym2.GameAdd]\n  dsimp\n  rintro ((rc | rd) | (rd | rc))\n  · exact iha c rc ⟨b, hb⟩\n  · exact ihb d rd\n  · rw [Sym2.eq_swap]\n    exact iha d rd ⟨b, hb⟩\n  · rw [Sym2.eq_swap]\n    exact ihb c rc\n\n"}
{"name":"WellFounded.sym2_gameAdd","module":"Mathlib.Order.GameAdd","initialProofState":"α : Type u_1\nrα : α → α → Prop\nh : WellFounded rα\n⊢ WellFounded (Sym2.GameAdd rα)","decl":"/-- The `Sym2.GameAdd` relation on well-founded inputs is well-founded. -/\ntheorem WellFounded.sym2_gameAdd (h : WellFounded rα) : WellFounded (Sym2.GameAdd rα) :=\n  ⟨fun i => Sym2.inductionOn i fun x y => (h.apply x).sym2_gameAdd (h.apply y)⟩\n\n"}
{"name":"Sym2.GameAdd.fix_eq","module":"Mathlib.Order.GameAdd","initialProofState":"α : Type u_1\nrα : α → α → Prop\nC : α → α → Sort u_3\nhr : WellFounded rα\nIH : (a₁ b₁ : α) → ((a₂ b₂ : α) → Sym2.GameAdd rα (Sym2.mk { fst := a₂, snd := b₂ }) (Sym2.mk { fst := a₁, snd := b₁ }) → C a₂ b₂) → C a₁ b₁\na b : α\n⊢ Eq (Sym2.GameAdd.fix hr IH a b) (IH a b fun a' b' x => Sym2.GameAdd.fix hr IH a' b')","decl":"theorem GameAdd.fix_eq {C : α → α → Sort*} (hr : WellFounded rα)\n    (IH : ∀ a₁ b₁, (∀ a₂ b₂, Sym2.GameAdd rα s(a₂, b₂) s(a₁, b₁) → C a₂ b₂) → C a₁ b₁) (a b : α) :\n    GameAdd.fix hr IH a b = IH a b fun a' b' _ => GameAdd.fix hr IH a' b' := by\n  -- Porting note: this was refactored for https://github.com/leanprover-community/mathlib4/pull/3414 (reenableeta), and could perhaps be cleaned up.\n  dsimp [GameAdd.fix]\n  exact WellFounded.fix_eq _ _ _\n\n"}
{"name":"Sym2.GameAdd.induction","module":"Mathlib.Order.GameAdd","initialProofState":"α : Type u_1\nrα C : α → α → Prop\na✝¹ : WellFounded rα\na✝ : ∀ (a₁ b₁ : α), (∀ (a₂ b₂ : α), Sym2.GameAdd rα (Sym2.mk { fst := a₂, snd := b₂ }) (Sym2.mk { fst := a₁, snd := b₁ }) → C a₂ b₂) → C a₁ b₁\na b : α\n⊢ C a b","decl":"/-- Induction on the well-founded `Sym2.GameAdd` relation. -/\ntheorem GameAdd.induction {C : α → α → Prop} :\n    WellFounded rα →\n      (∀ a₁ b₁, (∀ a₂ b₂, Sym2.GameAdd rα s(a₂, b₂) s(a₁, b₁) → C a₂ b₂) → C a₁ b₁) →\n        ∀ a b, C a b :=\n  GameAdd.fix\n\n"}
