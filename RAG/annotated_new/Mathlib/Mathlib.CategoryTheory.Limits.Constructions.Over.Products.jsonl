{"name":"CategoryTheory.Over.ConstructProducts.conesEquivInverseObj_œÄ_app","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nB : C\nJ : Type w\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)\nc : CategoryTheory.Limits.Cone F\nX : CategoryTheory.Limits.WidePullbackShape J\n‚ä¢ Eq ((CategoryTheory.Over.ConstructProducts.conesEquivInverseObj B F c).œÄ.app X) (Option.casesOn X c.pt.hom fun j => (c.œÄ.app { as := j }).left)","decl":"/-- (Impl) A preliminary definition to avoid timeouts. -/\n@[simps]\ndef conesEquivInverseObj (B : C) {J : Type w} (F : Discrete J ‚•§ Over B) (c : Cone F) :\n    Cone (widePullbackDiagramOfDiagramOver B F) where\n  pt := c.pt.left\n  œÄ :=\n    { app := fun X => Option.casesOn X c.pt.hom fun j : J => (c.œÄ.app ‚ü®j‚ü©).left\n      -- `tidy` can do this using `case_bash`, but let's try to be a good `-T50000` citizen:\n      naturality := fun X Y f => by\n        dsimp; cases X <;> cases Y <;> cases f\n        ¬∑ rw [Category.id_comp, Category.comp_id]\n        ¬∑ rw [Over.w, Category.id_comp]\n        ¬∑ rw [Category.id_comp, Category.comp_id] }\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.conesEquivInverseObj_pt","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nB : C\nJ : Type w\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (CategoryTheory.Over.ConstructProducts.conesEquivInverseObj B F c).pt c.pt.left","decl":"/-- (Impl) A preliminary definition to avoid timeouts. -/\n@[simps]\ndef conesEquivInverseObj (B : C) {J : Type w} (F : Discrete J ‚•§ Over B) (c : Cone F) :\n    Cone (widePullbackDiagramOfDiagramOver B F) where\n  pt := c.pt.left\n  œÄ :=\n    { app := fun X => Option.casesOn X c.pt.hom fun j : J => (c.œÄ.app ‚ü®j‚ü©).left\n      -- `tidy` can do this using `case_bash`, but let's try to be a good `-T50000` citizen:\n      naturality := fun X Y f => by\n        dsimp; cases X <;> cases Y <;> cases f\n        ¬∑ rw [Category.id_comp, Category.comp_id]\n        ¬∑ rw [Over.w, Category.id_comp]\n        ¬∑ rw [Category.id_comp, Category.comp_id] }\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.conesEquivInverse_obj","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nB : C\nJ : Type w\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq ((CategoryTheory.Over.ConstructProducts.conesEquivInverse B F).obj c) (CategoryTheory.Over.ConstructProducts.conesEquivInverseObj B F c)","decl":"/-- (Impl) A preliminary definition to avoid timeouts. -/\n@[simps]\ndef conesEquivInverse (B : C) {J : Type w} (F : Discrete J ‚•§ Over B) :\n    Cone F ‚•§ Cone (widePullbackDiagramOfDiagramOver B F) where\n  obj := conesEquivInverseObj B F\n  map f :=\n    { hom := f.hom.left\n      w := fun j => by\n        cases' j with j\n        ¬∑ simp\n        ¬∑ dsimp\n          rw [‚Üê f.w ‚ü®j‚ü©]\n          rfl }\n\n-- Porting note: this should help with the additional `naturality` proof we now have to give in\n-- `conesEquivFunctor`, but doesn't.\n-- attribute [local aesop safe cases (rule_sets := [CategoryTheory])] Discrete\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.conesEquivInverse_map_hom","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nB : C\nJ : Type w\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)\nX‚úù Y‚úù : CategoryTheory.Limits.Cone F\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Over.ConstructProducts.conesEquivInverse B F).map f).hom f.hom.left","decl":"/-- (Impl) A preliminary definition to avoid timeouts. -/\n@[simps]\ndef conesEquivInverse (B : C) {J : Type w} (F : Discrete J ‚•§ Over B) :\n    Cone F ‚•§ Cone (widePullbackDiagramOfDiagramOver B F) where\n  obj := conesEquivInverseObj B F\n  map f :=\n    { hom := f.hom.left\n      w := fun j => by\n        cases' j with j\n        ¬∑ simp\n        ¬∑ dsimp\n          rw [‚Üê f.w ‚ü®j‚ü©]\n          rfl }\n\n-- Porting note: this should help with the additional `naturality` proof we now have to give in\n-- `conesEquivFunctor`, but doesn't.\n-- attribute [local aesop safe cases (rule_sets := [CategoryTheory])] Discrete\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.conesEquivFunctor_map_hom","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nB : C\nJ : Type w\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)\nX‚úù Y‚úù : CategoryTheory.Limits.Cone (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Over.ConstructProducts.conesEquivFunctor B F).map f).hom (CategoryTheory.Over.homMk f.hom ‚ãØ)","decl":"/-- (Impl) A preliminary definition to avoid timeouts. -/\n@[simps]\ndef conesEquivFunctor (B : C) {J : Type w} (F : Discrete J ‚•§ Over B) :\n    Cone (widePullbackDiagramOfDiagramOver B F) ‚•§ Cone F where\n  obj c :=\n    { pt := Over.mk (c.œÄ.app none)\n      œÄ :=\n        { app := fun ‚ü®j‚ü© => Over.homMk (c.œÄ.app (some j)) (c.w (WidePullbackShape.Hom.term j))\n          -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10888): added proof for `naturality`\n          naturality := fun ‚ü®X‚ü© ‚ü®Y‚ü© ‚ü®‚ü®f‚ü©‚ü© => by dsimp at f ‚ä¢; aesop_cat } }\n  map f := { hom := Over.homMk f.hom }\n\n-- Porting note: unfortunately `aesop` can't cope with a `cases` rule here for the type synonym\n-- `WidePullbackShape`.\n-- attribute [local aesop safe cases (rule_sets := [CategoryTheory])] WidePullbackShape\n-- If this worked we could avoid the `rintro` in `conesEquivUnitIso`.\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.conesEquivFunctor_obj_pt","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nB : C\nJ : Type w\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)\nc : CategoryTheory.Limits.Cone (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)\n‚ä¢ Eq ((CategoryTheory.Over.ConstructProducts.conesEquivFunctor B F).obj c).pt (CategoryTheory.Over.mk (c.œÄ.app Option.none))","decl":"/-- (Impl) A preliminary definition to avoid timeouts. -/\n@[simps]\ndef conesEquivFunctor (B : C) {J : Type w} (F : Discrete J ‚•§ Over B) :\n    Cone (widePullbackDiagramOfDiagramOver B F) ‚•§ Cone F where\n  obj c :=\n    { pt := Over.mk (c.œÄ.app none)\n      œÄ :=\n        { app := fun ‚ü®j‚ü© => Over.homMk (c.œÄ.app (some j)) (c.w (WidePullbackShape.Hom.term j))\n          -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10888): added proof for `naturality`\n          naturality := fun ‚ü®X‚ü© ‚ü®Y‚ü© ‚ü®‚ü®f‚ü©‚ü© => by dsimp at f ‚ä¢; aesop_cat } }\n  map f := { hom := Over.homMk f.hom }\n\n-- Porting note: unfortunately `aesop` can't cope with a `cases` rule here for the type synonym\n-- `WidePullbackShape`.\n-- attribute [local aesop safe cases (rule_sets := [CategoryTheory])] WidePullbackShape\n-- If this worked we could avoid the `rintro` in `conesEquivUnitIso`.\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.conesEquivFunctor_obj_œÄ_app","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nB : C\nJ : Type w\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)\nc : CategoryTheory.Limits.Cone (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)\nx‚úù : CategoryTheory.Discrete J\n‚ä¢ Eq (((CategoryTheory.Over.ConstructProducts.conesEquivFunctor B F).obj c).œÄ.app x‚úù) (CategoryTheory.Over.ConstructProducts.conesEquivFunctor.match_1 (fun x => Quiver.Hom (((CategoryTheory.Functor.const (CategoryTheory.Discrete J)).obj (CategoryTheory.Over.mk (c.œÄ.app Option.none))).obj x) (F.obj x)) x‚úù fun j => CategoryTheory.Over.homMk (c.œÄ.app (Option.some j)) ‚ãØ)","decl":"/-- (Impl) A preliminary definition to avoid timeouts. -/\n@[simps]\ndef conesEquivFunctor (B : C) {J : Type w} (F : Discrete J ‚•§ Over B) :\n    Cone (widePullbackDiagramOfDiagramOver B F) ‚•§ Cone F where\n  obj c :=\n    { pt := Over.mk (c.œÄ.app none)\n      œÄ :=\n        { app := fun ‚ü®j‚ü© => Over.homMk (c.œÄ.app (some j)) (c.w (WidePullbackShape.Hom.term j))\n          -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10888): added proof for `naturality`\n          naturality := fun ‚ü®X‚ü© ‚ü®Y‚ü© ‚ü®‚ü®f‚ü©‚ü© => by dsimp at f ‚ä¢; aesop_cat } }\n  map f := { hom := Over.homMk f.hom }\n\n-- Porting note: unfortunately `aesop` can't cope with a `cases` rule here for the type synonym\n-- `WidePullbackShape`.\n-- attribute [local aesop safe cases (rule_sets := [CategoryTheory])] WidePullbackShape\n-- If this worked we could avoid the `rintro` in `conesEquivUnitIso`.\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.conesEquiv_unitIso","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nB : C\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)\n‚ä¢ Eq (CategoryTheory.Over.ConstructProducts.conesEquiv B F).unitIso (CategoryTheory.Over.ConstructProducts.conesEquivUnitIso B F)","decl":"/-- (Impl) Establish an equivalence between the category of cones for `F` and for the \"grown\" `F`.\n-/\n@[simps]\ndef conesEquiv (B : C) (F : Discrete J ‚•§ Over B) :\n    Cone (widePullbackDiagramOfDiagramOver B F) ‚âå Cone F where\n  functor := conesEquivFunctor B F\n  inverse := conesEquivInverse B F\n  unitIso := conesEquivUnitIso B F\n  counitIso := conesEquivCounitIso B F\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.conesEquiv_functor","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nB : C\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)\n‚ä¢ Eq (CategoryTheory.Over.ConstructProducts.conesEquiv B F).functor (CategoryTheory.Over.ConstructProducts.conesEquivFunctor B F)","decl":"/-- (Impl) Establish an equivalence between the category of cones for `F` and for the \"grown\" `F`.\n-/\n@[simps]\ndef conesEquiv (B : C) (F : Discrete J ‚•§ Over B) :\n    Cone (widePullbackDiagramOfDiagramOver B F) ‚âå Cone F where\n  functor := conesEquivFunctor B F\n  inverse := conesEquivInverse B F\n  unitIso := conesEquivUnitIso B F\n  counitIso := conesEquivCounitIso B F\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.conesEquiv_counitIso","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nB : C\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)\n‚ä¢ Eq (CategoryTheory.Over.ConstructProducts.conesEquiv B F).counitIso (CategoryTheory.Over.ConstructProducts.conesEquivCounitIso B F)","decl":"/-- (Impl) Establish an equivalence between the category of cones for `F` and for the \"grown\" `F`.\n-/\n@[simps]\ndef conesEquiv (B : C) (F : Discrete J ‚•§ Over B) :\n    Cone (widePullbackDiagramOfDiagramOver B F) ‚âå Cone F where\n  functor := conesEquivFunctor B F\n  inverse := conesEquivInverse B F\n  unitIso := conesEquivUnitIso B F\n  counitIso := conesEquivCounitIso B F\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.conesEquiv_inverse","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nB : C\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)\n‚ä¢ Eq (CategoryTheory.Over.ConstructProducts.conesEquiv B F).inverse (CategoryTheory.Over.ConstructProducts.conesEquivInverse B F)","decl":"/-- (Impl) Establish an equivalence between the category of cones for `F` and for the \"grown\" `F`.\n-/\n@[simps]\ndef conesEquiv (B : C) (F : Discrete J ‚•§ Over B) :\n    Cone (widePullbackDiagramOfDiagramOver B F) ‚âå Cone F where\n  functor := conesEquivFunctor B F\n  inverse := conesEquivInverse B F\n  unitIso := conesEquivUnitIso B F\n  counitIso := conesEquivCounitIso B F\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.has_over_limit_discrete_of_widePullback_limit","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nB : C\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)\ninst‚úù : CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)\n‚ä¢ CategoryTheory.Limits.HasLimit F","decl":"/-- Use the above equivalence to prove we have a limit. -/\ntheorem has_over_limit_discrete_of_widePullback_limit {B : C} (F : Discrete J ‚•§ Over B)\n    [HasLimit (widePullbackDiagramOfDiagramOver B F)] : HasLimit F :=\n  HasLimit.mk\n    { cone := _\n      isLimit := IsLimit.ofRightAdjoint (conesEquiv B F).symm.toAdjunction\n        (limit.isLimit (widePullbackDiagramOfDiagramOver B F)) }\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.over_product_of_widePullback","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WidePullbackShape J) C\nB : C\n‚ä¢ CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete J) (CategoryTheory.Over B)","decl":"/-- Given a wide pullback in `C`, construct a product in `C/B`. -/\ntheorem over_product_of_widePullback [HasLimitsOfShape (WidePullbackShape J) C] {B : C} :\n    HasLimitsOfShape (Discrete J) (Over B) :=\n  { has_limit := fun F => has_over_limit_discrete_of_widePullback_limit F }\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.over_binaryProduct_of_pullback","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nB : C\n‚ä¢ CategoryTheory.Limits.HasBinaryProducts (CategoryTheory.Over B)","decl":"/-- Given a pullback in `C`, construct a binary product in `C/B`. -/\ntheorem over_binaryProduct_of_pullback [HasPullbacks C] {B : C} : HasBinaryProducts (Over B) :=\n  over_product_of_widePullback\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.over_products_of_widePullbacks","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasWidePullbacks C\nB : C\n‚ä¢ CategoryTheory.Limits.HasProducts (CategoryTheory.Over B)","decl":"/-- Given all wide pullbacks in `C`, construct products in `C/B`. -/\ntheorem over_products_of_widePullbacks [HasWidePullbacks.{w} C] {B : C} :\n    HasProducts.{w} (Over B) :=\n  fun _ => over_product_of_widePullback\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.over_finiteProducts_of_finiteWidePullbacks","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasFiniteWidePullbacks C\nB : C\n‚ä¢ CategoryTheory.Limits.HasFiniteProducts (CategoryTheory.Over B)","decl":"/-- Given all finite wide pullbacks in `C`, construct finite products in `C/B`. -/\ntheorem over_finiteProducts_of_finiteWidePullbacks [HasFiniteWidePullbacks C] {B : C} :\n    HasFiniteProducts (Over B) :=\n  ‚ü®fun _ => over_product_of_widePullback‚ü©\n\n"}
{"name":"CategoryTheory.Over.over_hasTerminal","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nB : C\n‚ä¢ CategoryTheory.Limits.HasTerminal (CategoryTheory.Over B)","decl":"/-- Construct terminal object in the over category. This isn't an instance as it's not typically the\nway we want to define terminal objects.\n(For instance, this gives a terminal object which is different from the generic one given by\n`over_product_of_widePullback` above.)\n-/\ntheorem over_hasTerminal (B : C) : HasTerminal (Over B) where\n  has_limit F := HasLimit.mk\n    { cone :=\n        { pt := Over.mk (ùüô _)\n          œÄ :=\n            { app := fun p => p.as.elim } }\n      isLimit :=\n        { lift := fun s => Over.homMk s.pt.hom\n          fac := fun _ j => j.as.elim\n          uniq := fun s m _ => by\n            simp only\n            ext\n            rw [Over.homMk_left _]\n            have := m.w\n            dsimp at this\n            rwa [Category.comp_id, Category.comp_id] at this } }\n\n"}
{"name":"CategoryTheory.Over.isPullback_of_binaryFan_isLimit","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nY Z : CategoryTheory.Over X\nc : CategoryTheory.Limits.BinaryFan Y Z\nhc : CategoryTheory.Limits.IsLimit c\n‚ä¢ CategoryTheory.IsPullback c.fst.left c.snd.left Y.hom Z.hom","decl":"lemma isPullback_of_binaryFan_isLimit (c : BinaryFan Y Z) (hc : IsLimit c) :\n    IsPullback c.fst.left c.snd.left Y.hom Z.hom :=\n  ‚ü®by simp, ‚ü®((IsLimit.postcomposeHomEquiv (diagramIsoCospan _) _).symm\n    ((IsLimit.ofConeEquiv (ConstructProducts.conesEquiv X _).symm).symm hc)).ofIsoLimit\n    (PullbackCone.isoMk _)‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Over.prodLeftIsoPullback_hom_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX : C\nY Z‚úù : CategoryTheory.Over X\ninst‚úù¬π : CategoryTheory.Limits.HasPullback Y.hom Z‚úù.hom\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Y Z‚úù\nZ : C\nh : Quiver.Hom Y.left Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Y.prodLeftIsoPullback Z‚úù).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst Y.hom Z‚úù.hom) h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst.left h)","decl":"@[reassoc (attr := simp)]\nlemma prodLeftIsoPullback_hom_fst :\n    (prodLeftIsoPullback Y Z).hom ‚â´ pullback.fst _ _ = (prod.fst (X := Y)).left :=\n  IsPullback.isoPullback_hom_fst _\n\n"}
{"name":"CategoryTheory.Over.prodLeftIsoPullback_hom_fst","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX : C\nY Z : CategoryTheory.Over X\ninst‚úù¬π : CategoryTheory.Limits.HasPullback Y.hom Z.hom\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Y.prodLeftIsoPullback Z).hom (CategoryTheory.Limits.pullback.fst Y.hom Z.hom)) CategoryTheory.Limits.prod.fst.left","decl":"@[reassoc (attr := simp)]\nlemma prodLeftIsoPullback_hom_fst :\n    (prodLeftIsoPullback Y Z).hom ‚â´ pullback.fst _ _ = (prod.fst (X := Y)).left :=\n  IsPullback.isoPullback_hom_fst _\n\n"}
{"name":"CategoryTheory.Over.prodLeftIsoPullback_hom_snd","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX : C\nY Z : CategoryTheory.Over X\ninst‚úù¬π : CategoryTheory.Limits.HasPullback Y.hom Z.hom\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Y.prodLeftIsoPullback Z).hom (CategoryTheory.Limits.pullback.snd Y.hom Z.hom)) CategoryTheory.Limits.prod.snd.left","decl":"@[reassoc (attr := simp)]\nlemma prodLeftIsoPullback_hom_snd :\n    (prodLeftIsoPullback Y Z).hom ‚â´ pullback.snd _ _ = (prod.snd (X := Y)).left :=\n  IsPullback.isoPullback_hom_snd _\n\n"}
{"name":"CategoryTheory.Over.prodLeftIsoPullback_hom_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX : C\nY Z‚úù : CategoryTheory.Over X\ninst‚úù¬π : CategoryTheory.Limits.HasPullback Y.hom Z‚úù.hom\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Y Z‚úù\nZ : C\nh : Quiver.Hom Z‚úù.left Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Y.prodLeftIsoPullback Z‚úù).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd Y.hom Z‚úù.hom) h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd.left h)","decl":"@[reassoc (attr := simp)]\nlemma prodLeftIsoPullback_hom_snd :\n    (prodLeftIsoPullback Y Z).hom ‚â´ pullback.snd _ _ = (prod.snd (X := Y)).left :=\n  IsPullback.isoPullback_hom_snd _\n\n"}
{"name":"CategoryTheory.Over.prodLeftIsoPullback_inv_fst","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX : C\nY Z : CategoryTheory.Over X\ninst‚úù¬π : CategoryTheory.Limits.HasPullback Y.hom Z.hom\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Y.prodLeftIsoPullback Z).inv CategoryTheory.Limits.prod.fst.left) (CategoryTheory.Limits.pullback.fst Y.hom Z.hom)","decl":"@[reassoc (attr := simp)]\nlemma prodLeftIsoPullback_inv_fst :\n    (prodLeftIsoPullback Y Z).inv ‚â´ (prod.fst (X := Y)).left = pullback.fst _ _ :=\n  IsPullback.isoPullback_inv_fst _\n\n"}
{"name":"CategoryTheory.Over.prodLeftIsoPullback_inv_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX : C\nY Z‚úù : CategoryTheory.Over X\ninst‚úù¬π : CategoryTheory.Limits.HasPullback Y.hom Z‚úù.hom\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Y Z‚úù\nZ : C\nh : Quiver.Hom Y.left Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Y.prodLeftIsoPullback Z‚úù).inv (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst.left h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst Y.hom Z‚úù.hom) h)","decl":"@[reassoc (attr := simp)]\nlemma prodLeftIsoPullback_inv_fst :\n    (prodLeftIsoPullback Y Z).inv ‚â´ (prod.fst (X := Y)).left = pullback.fst _ _ :=\n  IsPullback.isoPullback_inv_fst _\n\n"}
{"name":"CategoryTheory.Over.prodLeftIsoPullback_inv_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX : C\nY Z‚úù : CategoryTheory.Over X\ninst‚úù¬π : CategoryTheory.Limits.HasPullback Y.hom Z‚úù.hom\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Y Z‚úù\nZ : C\nh : Quiver.Hom Z‚úù.left Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Y.prodLeftIsoPullback Z‚úù).inv (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd.left h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd Y.hom Z‚úù.hom) h)","decl":"@[reassoc (attr := simp)]\nlemma prodLeftIsoPullback_inv_snd :\n    (prodLeftIsoPullback Y Z).inv ‚â´ (prod.snd (X := Y)).left = pullback.snd _ _ :=\n  IsPullback.isoPullback_inv_snd _\n\n"}
{"name":"CategoryTheory.Over.prodLeftIsoPullback_inv_snd","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX : C\nY Z : CategoryTheory.Over X\ninst‚úù¬π : CategoryTheory.Limits.HasPullback Y.hom Z.hom\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Y.prodLeftIsoPullback Z).inv CategoryTheory.Limits.prod.snd.left) (CategoryTheory.Limits.pullback.snd Y.hom Z.hom)","decl":"@[reassoc (attr := simp)]\nlemma prodLeftIsoPullback_inv_snd :\n    (prodLeftIsoPullback Y Z).inv ‚â´ (prod.snd (X := Y)).left = pullback.snd _ _ :=\n  IsPullback.isoPullback_inv_snd _\n\n"}
