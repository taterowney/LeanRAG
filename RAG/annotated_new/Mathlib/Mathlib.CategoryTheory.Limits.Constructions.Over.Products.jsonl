{"name":"CategoryTheory.Over.ConstructProducts.conesEquivInverseObj_π_app","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nB : C\nJ : Type w\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)\nc : CategoryTheory.Limits.Cone F\nX : CategoryTheory.Limits.WidePullbackShape J\n⊢ Eq ((CategoryTheory.Over.ConstructProducts.conesEquivInverseObj B F c).π.app X) (Option.casesOn X c.pt.hom fun j => (c.π.app { as := j }).left)","decl":"/-- (Impl) A preliminary definition to avoid timeouts. -/\n@[simps]\ndef conesEquivInverseObj (B : C) {J : Type w} (F : Discrete J ⥤ Over B) (c : Cone F) :\n    Cone (widePullbackDiagramOfDiagramOver B F) where\n  pt := c.pt.left\n  π :=\n    { app := fun X => Option.casesOn X c.pt.hom fun j : J => (c.π.app ⟨j⟩).left\n      -- `tidy` can do this using `case_bash`, but let's try to be a good `-T50000` citizen:\n      naturality := fun X Y f => by\n        dsimp; cases X <;> cases Y <;> cases f\n        · rw [Category.id_comp, Category.comp_id]\n        · rw [Over.w, Category.id_comp]\n        · rw [Category.id_comp, Category.comp_id] }\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.conesEquivInverseObj_pt","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nB : C\nJ : Type w\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)\nc : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Over.ConstructProducts.conesEquivInverseObj B F c).pt c.pt.left","decl":"/-- (Impl) A preliminary definition to avoid timeouts. -/\n@[simps]\ndef conesEquivInverseObj (B : C) {J : Type w} (F : Discrete J ⥤ Over B) (c : Cone F) :\n    Cone (widePullbackDiagramOfDiagramOver B F) where\n  pt := c.pt.left\n  π :=\n    { app := fun X => Option.casesOn X c.pt.hom fun j : J => (c.π.app ⟨j⟩).left\n      -- `tidy` can do this using `case_bash`, but let's try to be a good `-T50000` citizen:\n      naturality := fun X Y f => by\n        dsimp; cases X <;> cases Y <;> cases f\n        · rw [Category.id_comp, Category.comp_id]\n        · rw [Over.w, Category.id_comp]\n        · rw [Category.id_comp, Category.comp_id] }\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.conesEquivInverse_obj","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nB : C\nJ : Type w\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)\nc : CategoryTheory.Limits.Cone F\n⊢ Eq ((CategoryTheory.Over.ConstructProducts.conesEquivInverse B F).obj c) (CategoryTheory.Over.ConstructProducts.conesEquivInverseObj B F c)","decl":"/-- (Impl) A preliminary definition to avoid timeouts. -/\n@[simps]\ndef conesEquivInverse (B : C) {J : Type w} (F : Discrete J ⥤ Over B) :\n    Cone F ⥤ Cone (widePullbackDiagramOfDiagramOver B F) where\n  obj := conesEquivInverseObj B F\n  map f :=\n    { hom := f.hom.left\n      w := fun j => by\n        cases' j with j\n        · simp\n        · dsimp\n          rw [← f.w ⟨j⟩]\n          rfl }\n\n-- Porting note: this should help with the additional `naturality` proof we now have to give in\n-- `conesEquivFunctor`, but doesn't.\n-- attribute [local aesop safe cases (rule_sets := [CategoryTheory])] Discrete\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.conesEquivInverse_map_hom","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nB : C\nJ : Type w\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)\nX✝ Y✝ : CategoryTheory.Limits.Cone F\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Over.ConstructProducts.conesEquivInverse B F).map f).hom f.hom.left","decl":"/-- (Impl) A preliminary definition to avoid timeouts. -/\n@[simps]\ndef conesEquivInverse (B : C) {J : Type w} (F : Discrete J ⥤ Over B) :\n    Cone F ⥤ Cone (widePullbackDiagramOfDiagramOver B F) where\n  obj := conesEquivInverseObj B F\n  map f :=\n    { hom := f.hom.left\n      w := fun j => by\n        cases' j with j\n        · simp\n        · dsimp\n          rw [← f.w ⟨j⟩]\n          rfl }\n\n-- Porting note: this should help with the additional `naturality` proof we now have to give in\n-- `conesEquivFunctor`, but doesn't.\n-- attribute [local aesop safe cases (rule_sets := [CategoryTheory])] Discrete\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.conesEquivFunctor_map_hom","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nB : C\nJ : Type w\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)\nX✝ Y✝ : CategoryTheory.Limits.Cone (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Over.ConstructProducts.conesEquivFunctor B F).map f).hom (CategoryTheory.Over.homMk f.hom ⋯)","decl":"/-- (Impl) A preliminary definition to avoid timeouts. -/\n@[simps]\ndef conesEquivFunctor (B : C) {J : Type w} (F : Discrete J ⥤ Over B) :\n    Cone (widePullbackDiagramOfDiagramOver B F) ⥤ Cone F where\n  obj c :=\n    { pt := Over.mk (c.π.app none)\n      π :=\n        { app := fun ⟨j⟩ => Over.homMk (c.π.app (some j)) (c.w (WidePullbackShape.Hom.term j))\n          -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10888): added proof for `naturality`\n          naturality := fun ⟨X⟩ ⟨Y⟩ ⟨⟨f⟩⟩ => by dsimp at f ⊢; aesop_cat } }\n  map f := { hom := Over.homMk f.hom }\n\n-- Porting note: unfortunately `aesop` can't cope with a `cases` rule here for the type synonym\n-- `WidePullbackShape`.\n-- attribute [local aesop safe cases (rule_sets := [CategoryTheory])] WidePullbackShape\n-- If this worked we could avoid the `rintro` in `conesEquivUnitIso`.\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.conesEquivFunctor_obj_pt","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nB : C\nJ : Type w\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)\nc : CategoryTheory.Limits.Cone (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)\n⊢ Eq ((CategoryTheory.Over.ConstructProducts.conesEquivFunctor B F).obj c).pt (CategoryTheory.Over.mk (c.π.app Option.none))","decl":"/-- (Impl) A preliminary definition to avoid timeouts. -/\n@[simps]\ndef conesEquivFunctor (B : C) {J : Type w} (F : Discrete J ⥤ Over B) :\n    Cone (widePullbackDiagramOfDiagramOver B F) ⥤ Cone F where\n  obj c :=\n    { pt := Over.mk (c.π.app none)\n      π :=\n        { app := fun ⟨j⟩ => Over.homMk (c.π.app (some j)) (c.w (WidePullbackShape.Hom.term j))\n          -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10888): added proof for `naturality`\n          naturality := fun ⟨X⟩ ⟨Y⟩ ⟨⟨f⟩⟩ => by dsimp at f ⊢; aesop_cat } }\n  map f := { hom := Over.homMk f.hom }\n\n-- Porting note: unfortunately `aesop` can't cope with a `cases` rule here for the type synonym\n-- `WidePullbackShape`.\n-- attribute [local aesop safe cases (rule_sets := [CategoryTheory])] WidePullbackShape\n-- If this worked we could avoid the `rintro` in `conesEquivUnitIso`.\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.conesEquivFunctor_obj_π_app","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nB : C\nJ : Type w\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)\nc : CategoryTheory.Limits.Cone (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)\nx✝ : CategoryTheory.Discrete J\n⊢ Eq (((CategoryTheory.Over.ConstructProducts.conesEquivFunctor B F).obj c).π.app x✝) (CategoryTheory.Over.ConstructProducts.conesEquivFunctor.match_1 (fun x => Quiver.Hom (((CategoryTheory.Functor.const (CategoryTheory.Discrete J)).obj (CategoryTheory.Over.mk (c.π.app Option.none))).obj x) (F.obj x)) x✝ fun j => CategoryTheory.Over.homMk (c.π.app (Option.some j)) ⋯)","decl":"/-- (Impl) A preliminary definition to avoid timeouts. -/\n@[simps]\ndef conesEquivFunctor (B : C) {J : Type w} (F : Discrete J ⥤ Over B) :\n    Cone (widePullbackDiagramOfDiagramOver B F) ⥤ Cone F where\n  obj c :=\n    { pt := Over.mk (c.π.app none)\n      π :=\n        { app := fun ⟨j⟩ => Over.homMk (c.π.app (some j)) (c.w (WidePullbackShape.Hom.term j))\n          -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10888): added proof for `naturality`\n          naturality := fun ⟨X⟩ ⟨Y⟩ ⟨⟨f⟩⟩ => by dsimp at f ⊢; aesop_cat } }\n  map f := { hom := Over.homMk f.hom }\n\n-- Porting note: unfortunately `aesop` can't cope with a `cases` rule here for the type synonym\n-- `WidePullbackShape`.\n-- attribute [local aesop safe cases (rule_sets := [CategoryTheory])] WidePullbackShape\n-- If this worked we could avoid the `rintro` in `conesEquivUnitIso`.\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.conesEquiv_unitIso","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"J : Type w\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nB : C\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)\n⊢ Eq (CategoryTheory.Over.ConstructProducts.conesEquiv B F).unitIso (CategoryTheory.Over.ConstructProducts.conesEquivUnitIso B F)","decl":"/-- (Impl) Establish an equivalence between the category of cones for `F` and for the \"grown\" `F`.\n-/\n@[simps]\ndef conesEquiv (B : C) (F : Discrete J ⥤ Over B) :\n    Cone (widePullbackDiagramOfDiagramOver B F) ≌ Cone F where\n  functor := conesEquivFunctor B F\n  inverse := conesEquivInverse B F\n  unitIso := conesEquivUnitIso B F\n  counitIso := conesEquivCounitIso B F\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.conesEquiv_functor","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"J : Type w\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nB : C\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)\n⊢ Eq (CategoryTheory.Over.ConstructProducts.conesEquiv B F).functor (CategoryTheory.Over.ConstructProducts.conesEquivFunctor B F)","decl":"/-- (Impl) Establish an equivalence between the category of cones for `F` and for the \"grown\" `F`.\n-/\n@[simps]\ndef conesEquiv (B : C) (F : Discrete J ⥤ Over B) :\n    Cone (widePullbackDiagramOfDiagramOver B F) ≌ Cone F where\n  functor := conesEquivFunctor B F\n  inverse := conesEquivInverse B F\n  unitIso := conesEquivUnitIso B F\n  counitIso := conesEquivCounitIso B F\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.conesEquiv_counitIso","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"J : Type w\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nB : C\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)\n⊢ Eq (CategoryTheory.Over.ConstructProducts.conesEquiv B F).counitIso (CategoryTheory.Over.ConstructProducts.conesEquivCounitIso B F)","decl":"/-- (Impl) Establish an equivalence between the category of cones for `F` and for the \"grown\" `F`.\n-/\n@[simps]\ndef conesEquiv (B : C) (F : Discrete J ⥤ Over B) :\n    Cone (widePullbackDiagramOfDiagramOver B F) ≌ Cone F where\n  functor := conesEquivFunctor B F\n  inverse := conesEquivInverse B F\n  unitIso := conesEquivUnitIso B F\n  counitIso := conesEquivCounitIso B F\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.conesEquiv_inverse","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"J : Type w\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nB : C\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)\n⊢ Eq (CategoryTheory.Over.ConstructProducts.conesEquiv B F).inverse (CategoryTheory.Over.ConstructProducts.conesEquivInverse B F)","decl":"/-- (Impl) Establish an equivalence between the category of cones for `F` and for the \"grown\" `F`.\n-/\n@[simps]\ndef conesEquiv (B : C) (F : Discrete J ⥤ Over B) :\n    Cone (widePullbackDiagramOfDiagramOver B F) ≌ Cone F where\n  functor := conesEquivFunctor B F\n  inverse := conesEquivInverse B F\n  unitIso := conesEquivUnitIso B F\n  counitIso := conesEquivCounitIso B F\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.has_over_limit_discrete_of_widePullback_limit","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"J : Type w\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nB : C\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)\ninst✝ : CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)\n⊢ CategoryTheory.Limits.HasLimit F","decl":"/-- Use the above equivalence to prove we have a limit. -/\ntheorem has_over_limit_discrete_of_widePullback_limit {B : C} (F : Discrete J ⥤ Over B)\n    [HasLimit (widePullbackDiagramOfDiagramOver B F)] : HasLimit F :=\n  HasLimit.mk\n    { cone := _\n      isLimit := IsLimit.ofRightAdjoint (conesEquiv B F).symm.toAdjunction\n        (limit.isLimit (widePullbackDiagramOfDiagramOver B F)) }\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.over_product_of_widePullback","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"J : Type w\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WidePullbackShape J) C\nB : C\n⊢ CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete J) (CategoryTheory.Over B)","decl":"/-- Given a wide pullback in `C`, construct a product in `C/B`. -/\ntheorem over_product_of_widePullback [HasLimitsOfShape (WidePullbackShape J) C] {B : C} :\n    HasLimitsOfShape (Discrete J) (Over B) :=\n  { has_limit := fun F => has_over_limit_discrete_of_widePullback_limit F }\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.over_binaryProduct_of_pullback","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nB : C\n⊢ CategoryTheory.Limits.HasBinaryProducts (CategoryTheory.Over B)","decl":"/-- Given a pullback in `C`, construct a binary product in `C/B`. -/\ntheorem over_binaryProduct_of_pullback [HasPullbacks C] {B : C} : HasBinaryProducts (Over B) :=\n  over_product_of_widePullback\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.over_products_of_widePullbacks","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasWidePullbacks C\nB : C\n⊢ CategoryTheory.Limits.HasProducts (CategoryTheory.Over B)","decl":"/-- Given all wide pullbacks in `C`, construct products in `C/B`. -/\ntheorem over_products_of_widePullbacks [HasWidePullbacks.{w} C] {B : C} :\n    HasProducts.{w} (Over B) :=\n  fun _ => over_product_of_widePullback\n\n"}
{"name":"CategoryTheory.Over.ConstructProducts.over_finiteProducts_of_finiteWidePullbacks","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasFiniteWidePullbacks C\nB : C\n⊢ CategoryTheory.Limits.HasFiniteProducts (CategoryTheory.Over B)","decl":"/-- Given all finite wide pullbacks in `C`, construct finite products in `C/B`. -/\ntheorem over_finiteProducts_of_finiteWidePullbacks [HasFiniteWidePullbacks C] {B : C} :\n    HasFiniteProducts (Over B) :=\n  ⟨fun _ => over_product_of_widePullback⟩\n\n"}
{"name":"CategoryTheory.Over.over_hasTerminal","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nB : C\n⊢ CategoryTheory.Limits.HasTerminal (CategoryTheory.Over B)","decl":"/-- Construct terminal object in the over category. This isn't an instance as it's not typically the\nway we want to define terminal objects.\n(For instance, this gives a terminal object which is different from the generic one given by\n`over_product_of_widePullback` above.)\n-/\ntheorem over_hasTerminal (B : C) : HasTerminal (Over B) where\n  has_limit F := HasLimit.mk\n    { cone :=\n        { pt := Over.mk (𝟙 _)\n          π :=\n            { app := fun p => p.as.elim } }\n      isLimit :=\n        { lift := fun s => Over.homMk s.pt.hom\n          fac := fun _ j => j.as.elim\n          uniq := fun s m _ => by\n            simp only\n            ext\n            rw [Over.homMk_left _]\n            have := m.w\n            dsimp at this\n            rwa [Category.comp_id, Category.comp_id] at this } }\n\n"}
{"name":"CategoryTheory.Over.isPullback_of_binaryFan_isLimit","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nY Z : CategoryTheory.Over X\nc : CategoryTheory.Limits.BinaryFan Y Z\nhc : CategoryTheory.Limits.IsLimit c\n⊢ CategoryTheory.IsPullback c.fst.left c.snd.left Y.hom Z.hom","decl":"lemma isPullback_of_binaryFan_isLimit (c : BinaryFan Y Z) (hc : IsLimit c) :\n    IsPullback c.fst.left c.snd.left Y.hom Z.hom :=\n  ⟨by simp, ⟨((IsLimit.postcomposeHomEquiv (diagramIsoCospan _) _).symm\n    ((IsLimit.ofConeEquiv (ConstructProducts.conesEquiv X _).symm).symm hc)).ofIsoLimit\n    (PullbackCone.isoMk _)⟩⟩\n\n"}
{"name":"CategoryTheory.Over.prodLeftIsoPullback_hom_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX : C\nY Z✝ : CategoryTheory.Over X\ninst✝¹ : CategoryTheory.Limits.HasPullback Y.hom Z✝.hom\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Y Z✝\nZ : C\nh : Quiver.Hom Y.left Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Y.prodLeftIsoPullback Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst Y.hom Z✝.hom) h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst.left h)","decl":"@[reassoc (attr := simp)]\nlemma prodLeftIsoPullback_hom_fst :\n    (prodLeftIsoPullback Y Z).hom ≫ pullback.fst _ _ = (prod.fst (X := Y)).left :=\n  IsPullback.isoPullback_hom_fst _\n\n"}
{"name":"CategoryTheory.Over.prodLeftIsoPullback_hom_fst","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX : C\nY Z : CategoryTheory.Over X\ninst✝¹ : CategoryTheory.Limits.HasPullback Y.hom Z.hom\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Y.prodLeftIsoPullback Z).hom (CategoryTheory.Limits.pullback.fst Y.hom Z.hom)) CategoryTheory.Limits.prod.fst.left","decl":"@[reassoc (attr := simp)]\nlemma prodLeftIsoPullback_hom_fst :\n    (prodLeftIsoPullback Y Z).hom ≫ pullback.fst _ _ = (prod.fst (X := Y)).left :=\n  IsPullback.isoPullback_hom_fst _\n\n"}
{"name":"CategoryTheory.Over.prodLeftIsoPullback_hom_snd","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX : C\nY Z : CategoryTheory.Over X\ninst✝¹ : CategoryTheory.Limits.HasPullback Y.hom Z.hom\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Y.prodLeftIsoPullback Z).hom (CategoryTheory.Limits.pullback.snd Y.hom Z.hom)) CategoryTheory.Limits.prod.snd.left","decl":"@[reassoc (attr := simp)]\nlemma prodLeftIsoPullback_hom_snd :\n    (prodLeftIsoPullback Y Z).hom ≫ pullback.snd _ _ = (prod.snd (X := Y)).left :=\n  IsPullback.isoPullback_hom_snd _\n\n"}
{"name":"CategoryTheory.Over.prodLeftIsoPullback_hom_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX : C\nY Z✝ : CategoryTheory.Over X\ninst✝¹ : CategoryTheory.Limits.HasPullback Y.hom Z✝.hom\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Y Z✝\nZ : C\nh : Quiver.Hom Z✝.left Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Y.prodLeftIsoPullback Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd Y.hom Z✝.hom) h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd.left h)","decl":"@[reassoc (attr := simp)]\nlemma prodLeftIsoPullback_hom_snd :\n    (prodLeftIsoPullback Y Z).hom ≫ pullback.snd _ _ = (prod.snd (X := Y)).left :=\n  IsPullback.isoPullback_hom_snd _\n\n"}
{"name":"CategoryTheory.Over.prodLeftIsoPullback_inv_fst","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX : C\nY Z : CategoryTheory.Over X\ninst✝¹ : CategoryTheory.Limits.HasPullback Y.hom Z.hom\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Y.prodLeftIsoPullback Z).inv CategoryTheory.Limits.prod.fst.left) (CategoryTheory.Limits.pullback.fst Y.hom Z.hom)","decl":"@[reassoc (attr := simp)]\nlemma prodLeftIsoPullback_inv_fst :\n    (prodLeftIsoPullback Y Z).inv ≫ (prod.fst (X := Y)).left = pullback.fst _ _ :=\n  IsPullback.isoPullback_inv_fst _\n\n"}
{"name":"CategoryTheory.Over.prodLeftIsoPullback_inv_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX : C\nY Z✝ : CategoryTheory.Over X\ninst✝¹ : CategoryTheory.Limits.HasPullback Y.hom Z✝.hom\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Y Z✝\nZ : C\nh : Quiver.Hom Y.left Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Y.prodLeftIsoPullback Z✝).inv (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst.left h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst Y.hom Z✝.hom) h)","decl":"@[reassoc (attr := simp)]\nlemma prodLeftIsoPullback_inv_fst :\n    (prodLeftIsoPullback Y Z).inv ≫ (prod.fst (X := Y)).left = pullback.fst _ _ :=\n  IsPullback.isoPullback_inv_fst _\n\n"}
{"name":"CategoryTheory.Over.prodLeftIsoPullback_inv_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX : C\nY Z✝ : CategoryTheory.Over X\ninst✝¹ : CategoryTheory.Limits.HasPullback Y.hom Z✝.hom\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Y Z✝\nZ : C\nh : Quiver.Hom Z✝.left Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Y.prodLeftIsoPullback Z✝).inv (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd.left h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd Y.hom Z✝.hom) h)","decl":"@[reassoc (attr := simp)]\nlemma prodLeftIsoPullback_inv_snd :\n    (prodLeftIsoPullback Y Z).inv ≫ (prod.snd (X := Y)).left = pullback.snd _ _ :=\n  IsPullback.isoPullback_inv_snd _\n\n"}
{"name":"CategoryTheory.Over.prodLeftIsoPullback_inv_snd","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Products","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX : C\nY Z : CategoryTheory.Over X\ninst✝¹ : CategoryTheory.Limits.HasPullback Y.hom Z.hom\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Y.prodLeftIsoPullback Z).inv CategoryTheory.Limits.prod.snd.left) (CategoryTheory.Limits.pullback.snd Y.hom Z.hom)","decl":"@[reassoc (attr := simp)]\nlemma prodLeftIsoPullback_inv_snd :\n    (prodLeftIsoPullback Y Z).inv ≫ (prod.snd (X := Y)).left = pullback.snd _ _ :=\n  IsPullback.isoPullback_inv_snd _\n\n"}
