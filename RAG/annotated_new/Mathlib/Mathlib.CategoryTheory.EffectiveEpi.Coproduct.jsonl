{"name":"CategoryTheory.instEffectiveEpiDescOfEffectiveEpiFamily","module":"Mathlib.CategoryTheory.EffectiveEpi.Coproduct","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nB : C\nα : Type u_2\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\ninst✝¹ : CategoryTheory.Limits.HasCoproduct X\ninst✝ : CategoryTheory.EffectiveEpiFamily X π\n⊢ CategoryTheory.EffectiveEpi (CategoryTheory.Limits.Sigma.desc π)","decl":"instance {B : C} {α : Type*} (X : α → C) (π : (a : α) → (X a ⟶ B)) [HasCoproduct X]\n    [EffectiveEpiFamily X π] : EffectiveEpi (Sigma.desc π) := by\n  let e := effectiveEpiStructIsColimitDescOfEffectiveEpiFamily X _ (coproductIsCoproduct _) π\n  simp only [Cofan.mk_pt, coproductIsCoproduct, colimit.cocone_x, IsColimit.ofIsoColimit_desc,\n    Cocones.ext_inv_hom, Iso.refl_inv, colimit.isColimit_desc, Category.id_comp] at e\n  exact ⟨⟨e⟩⟩\n\n"}
{"name":"CategoryTheory.effectiveEpiFamilyStructOfEffectiveEpiDesc_aux","module":"Mathlib.CategoryTheory.EffectiveEpi.Coproduct","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\nB : C\nα : Type u_2\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\ninst✝³ : CategoryTheory.Limits.HasCoproduct X\ninst✝² : ∀ {Z : C} (g : Quiver.Hom Z (CategoryTheory.Limits.sigmaObj X)) (a : α), CategoryTheory.Limits.HasPullback g (CategoryTheory.Limits.Sigma.ι X a)\ninst✝¹ : ∀ {Z : C} (g : Quiver.Hom Z (CategoryTheory.Limits.sigmaObj X)), CategoryTheory.Limits.HasCoproduct fun a => CategoryTheory.Limits.pullback g (CategoryTheory.Limits.Sigma.ι X a)\ninst✝ : ∀ {Z : C} (g : Quiver.Hom Z (CategoryTheory.Limits.sigmaObj X)), CategoryTheory.Epi (CategoryTheory.Limits.Sigma.desc fun a => CategoryTheory.Limits.pullback.fst g (CategoryTheory.Limits.Sigma.ι X a))\nW : C\ne : (a : α) → Quiver.Hom (X a) W\nh : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Quiver.Hom Z (X a₁)) (g₂ : Quiver.Hom Z (X a₂)), Eq (CategoryTheory.CategoryStruct.comp g₁ (π a₁)) (CategoryTheory.CategoryStruct.comp g₂ (π a₂)) → Eq (CategoryTheory.CategoryStruct.comp g₁ (e a₁)) (CategoryTheory.CategoryStruct.comp g₂ (e a₂))\nZ : C\ng₁ g₂ : Quiver.Hom Z (CategoryTheory.Limits.sigmaObj fun b => X b)\nhg : Eq (CategoryTheory.CategoryStruct.comp g₁ (CategoryTheory.Limits.Sigma.desc π)) (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.Sigma.desc π))\n⊢ Eq (CategoryTheory.CategoryStruct.comp g₁ (CategoryTheory.Limits.Sigma.desc e)) (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.Sigma.desc e))","decl":"/--\nThis is an auxiliary lemma used twice in the definition of  `EffectiveEpiFamilyOfEffectiveEpiDesc`.\nIt is the `h` hypothesis of `EffectiveEpi.desc` and `EffectiveEpi.fac`.\n-/\ntheorem effectiveEpiFamilyStructOfEffectiveEpiDesc_aux {B : C} {α : Type*} {X : α → C}\n    {π : (a : α) → X a ⟶ B} [HasCoproduct X]\n    [∀ {Z : C} (g : Z ⟶ ∐ X) (a : α), HasPullback g (Sigma.ι X a)]\n    [∀ {Z : C} (g : Z ⟶ ∐ X), HasCoproduct fun a ↦ pullback g (Sigma.ι X a)]\n    [∀ {Z : C} (g : Z ⟶ ∐ X), Epi (Sigma.desc fun a ↦ pullback.fst g (Sigma.ι X a))]\n    {W : C} {e : (a : α) → X a ⟶ W} (h : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Z ⟶ X a₁) (g₂ : Z ⟶ X a₂),\n      g₁ ≫ π a₁ = g₂ ≫ π a₂ → g₁ ≫ e a₁ = g₂ ≫ e a₂) {Z : C}\n    {g₁ g₂ : Z ⟶ ∐ fun b ↦ X b} (hg : g₁ ≫ Sigma.desc π = g₂ ≫ Sigma.desc π) :\n    g₁ ≫ Sigma.desc e = g₂ ≫ Sigma.desc e := by\n  apply_fun ((Sigma.desc fun a ↦ pullback.fst g₁ (Sigma.ι X a)) ≫ ·) using\n    (fun a b ↦ (cancel_epi _).mp)\n  ext a\n  simp only [colimit.ι_desc_assoc, Discrete.functor_obj, Cofan.mk_pt, Cofan.mk_ι_app]\n  rw [← Category.assoc, pullback.condition]\n  simp only [Category.assoc, colimit.ι_desc, Cofan.mk_pt, Cofan.mk_ι_app]\n  apply_fun ((Sigma.desc fun a ↦ pullback.fst (pullback.fst _ _ ≫ g₂) (Sigma.ι X a)) ≫ ·)\n    using (fun a b ↦ (cancel_epi _).mp)\n  ext b\n  simp only [colimit.ι_desc_assoc, Discrete.functor_obj, Cofan.mk_pt, Cofan.mk_ι_app]\n  simp only [← Category.assoc]\n  rw [(Category.assoc _ _ g₂), pullback.condition]\n  simp only [Category.assoc, colimit.ι_desc, Cofan.mk_pt, Cofan.mk_ι_app]\n  rw [← Category.assoc]\n  apply h\n  apply_fun (pullback.fst g₁ (Sigma.ι X a) ≫ ·) at hg\n  rw [← Category.assoc, pullback.condition] at hg\n  simp only [Category.assoc, colimit.ι_desc, Cofan.mk_pt, Cofan.mk_ι_app] at hg\n  apply_fun ((Sigma.ι (fun a ↦ pullback _ _) b) ≫ (Sigma.desc fun a ↦\n    pullback.fst (pullback.fst _ _ ≫ g₂) (Sigma.ι X a)) ≫ ·) at hg\n  simp only [colimit.ι_desc_assoc, Discrete.functor_obj, Cofan.mk_pt, Cofan.mk_ι_app] at hg\n  simp only [← Category.assoc] at hg\n  rw [(Category.assoc _ _ g₂), pullback.condition] at hg\n  simpa using hg\n\n"}
