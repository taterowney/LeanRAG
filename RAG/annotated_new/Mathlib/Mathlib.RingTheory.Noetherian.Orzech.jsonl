{"name":"IsNoetherian.injective_of_surjective_of_injective","module":"Mathlib.RingTheory.Noetherian.Orzech","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type w\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : IsNoetherian R M\ni f : LinearMap (RingHom.id R) N M\nhi : Function.Injective ⇑i\nhf : Function.Surjective ⇑f\n⊢ Function.Injective ⇑f","decl":"/-- **Orzech's theorem** for Noetherian modules: if `R` is a ring (not necessarily commutative),\n`M` and `N` are `R`-modules, `M` is Noetherian, `i : N →ₗ[R] M` is injective,\n`f : N →ₗ[R] M` is surjective, then `f` is also injective. The proof here is adapted from\nDjoković's paper *Epimorphisms of modules which must be isomorphisms* [djokovic1973],\nutilizing `LinearMap.iterateMapComap`.\nSee also Orzech's original paper: *Onto endomorphisms are isomorphisms* [orzech1971]. -/\ntheorem IsNoetherian.injective_of_surjective_of_injective (i f : N →ₗ[R] M)\n    (hi : Injective i) (hf : Surjective f) : Injective f := by\n  haveI := isNoetherian_of_injective i hi\n  obtain ⟨n, H⟩ := monotone_stabilizes_iff_noetherian.2 ‹_›\n    ⟨_, monotone_nat_of_le_succ <| f.iterateMapComap_le_succ i ⊥ (by simp)⟩\n  exact LinearMap.ker_eq_bot.1 <| bot_unique <|\n    f.ker_le_of_iterateMapComap_eq_succ i ⊥ n (H _ (Nat.le_succ _)) hf hi\n\n"}
{"name":"IsNoetherian.injective_of_surjective_of_submodule","module":"Mathlib.RingTheory.Noetherian.Orzech","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsNoetherian R M\nN : Submodule R M\nf : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem N x) M\nhf : Function.Surjective ⇑f\n⊢ Function.Injective ⇑f","decl":"/-- **Orzech's theorem** for Noetherian modules: if `R` is a ring (not necessarily commutative),\n`M` is a Noetherian `R`-module, `N` is a submodule, `f : N →ₗ[R] M` is surjective, then `f` is also\ninjective. -/\ntheorem IsNoetherian.injective_of_surjective_of_submodule\n    {N : Submodule R M} (f : N →ₗ[R] M) (hf : Surjective f) : Injective f :=\n  IsNoetherian.injective_of_surjective_of_injective N.subtype f N.injective_subtype hf\n\n"}
{"name":"IsNoetherian.injective_of_surjective_endomorphism","module":"Mathlib.RingTheory.Noetherian.Orzech","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsNoetherian R M\nf : LinearMap (RingHom.id R) M M\ns : Function.Surjective ⇑f\n⊢ Function.Injective ⇑f","decl":"/-- Any surjective endomorphism of a Noetherian module is injective. -/\ntheorem IsNoetherian.injective_of_surjective_endomorphism (f : M →ₗ[R] M)\n    (s : Surjective f) : Injective f :=\n  IsNoetherian.injective_of_surjective_of_injective _ f (LinearEquiv.refl _ _).injective s\n\n"}
{"name":"IsNoetherian.bijective_of_surjective_endomorphism","module":"Mathlib.RingTheory.Noetherian.Orzech","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsNoetherian R M\nf : LinearMap (RingHom.id R) M M\ns : Function.Surjective ⇑f\n⊢ Function.Bijective ⇑f","decl":"/-- Any surjective endomorphism of a Noetherian module is bijective. -/\ntheorem IsNoetherian.bijective_of_surjective_endomorphism (f : M →ₗ[R] M)\n    (s : Surjective f) : Bijective f :=\n  ⟨IsNoetherian.injective_of_surjective_endomorphism f s, s⟩\n\n"}
{"name":"IsNoetherian.subsingleton_of_prod_injective","module":"Mathlib.RingTheory.Noetherian.Orzech","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type w\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : IsNoetherian R M\nf : LinearMap (RingHom.id R) (Prod M N) M\ni : Function.Injective ⇑f\n⊢ Subsingleton N","decl":"/-- If `M ⊕ N` embeds into `M`, for `M` noetherian over `R`, then `N` is trivial. -/\ntheorem IsNoetherian.subsingleton_of_prod_injective (f : M × N →ₗ[R] M)\n    (i : Injective f) : Subsingleton N := .intro fun x y ↦ by\n  have h := IsNoetherian.injective_of_surjective_of_injective f _ i LinearMap.fst_surjective\n  simpa using h (show LinearMap.fst R M N (0, x) = LinearMap.fst R M N (0, y) from rfl)\n\n"}
{"name":"IsNoetherian.equivPUnitOfProdInjective_apply","module":"Mathlib.RingTheory.Noetherian.Orzech","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type w\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : IsNoetherian R M\nf : LinearMap (RingHom.id R) (Prod M N) M\ni : Function.Injective ⇑f\nx✝ : N\n⊢ Eq ((IsNoetherian.equivPUnitOfProdInjective f i) x✝) 0","decl":"/-- If `M ⊕ N` embeds into `M`, for `M` noetherian over `R`, then `N` is trivial. -/\n@[simps!]\ndef IsNoetherian.equivPUnitOfProdInjective (f : M × N →ₗ[R] M)\n    (i : Injective f) : N ≃ₗ[R] PUnit.{w + 1} :=\n  haveI := IsNoetherian.subsingleton_of_prod_injective f i\n  .ofSubsingleton _ _\n\n"}
{"name":"IsNoetherian.equivPUnitOfProdInjective_symm_apply","module":"Mathlib.RingTheory.Noetherian.Orzech","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type w\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : IsNoetherian R M\nf : LinearMap (RingHom.id R) (Prod M N) M\ni : Function.Injective ⇑f\nx✝ : PUnit.{w + 1}\n⊢ Eq ((IsNoetherian.equivPUnitOfProdInjective f i).symm x✝) 0","decl":"/-- If `M ⊕ N` embeds into `M`, for `M` noetherian over `R`, then `N` is trivial. -/\n@[simps!]\ndef IsNoetherian.equivPUnitOfProdInjective (f : M × N →ₗ[R] M)\n    (i : Injective f) : N ≃ₗ[R] PUnit.{w + 1} :=\n  haveI := IsNoetherian.subsingleton_of_prod_injective f i\n  .ofSubsingleton _ _\n\n"}
{"name":"IsNoetherianRing.orzechProperty","module":"Mathlib.RingTheory.Noetherian.Orzech","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : IsNoetherianRing R\n⊢ OrzechProperty R","decl":"/-- Any Noetherian ring satisfies Orzech property.\nSee also `IsNoetherian.injective_of_surjective_of_submodule` and\n`IsNoetherian.injective_of_surjective_of_injective`. -/\ninstance (priority := 100) IsNoetherianRing.orzechProperty\n    (R) [Ring R] [IsNoetherianRing R] : OrzechProperty R where\n  injective_of_surjective_of_submodule' {M} :=\n    letI := Module.addCommMonoidToAddCommGroup R (M := M)\n    IsNoetherian.injective_of_surjective_of_submodule\n"}
