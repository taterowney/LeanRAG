{"name":"Set.ext_iff","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\na b : Set α\n⊢ Iff (Eq a b) (∀ (x : α), Iff (Membership.mem a x) (Membership.mem b x))","decl":"attribute [ext] Set.ext\n\n"}
{"name":"Set.mem_setOf_eq","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nx : α\np : α → Prop\n⊢ Eq (Membership.mem (setOf fun y => p y) x) (p x)","decl":"@[simp, mfld_simps] theorem mem_setOf_eq {x : α} {p : α → Prop} : (x ∈ {y | p y}) = p x := rfl\n\n"}
{"name":"Set.mem_univ","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nx : α\n⊢ Membership.mem Set.univ x","decl":"@[simp, mfld_simps] theorem mem_univ (x : α) : x ∈ @univ α := trivial\n\n"}
{"name":"Set.mem_compl_iff","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\ns : Set α\nx : α\n⊢ Iff (Membership.mem (HasCompl.compl s) x) (Not (Membership.mem s x))","decl":"@[simp] theorem mem_compl_iff (s : Set α) (x : α) : x ∈ sᶜ ↔ x ∉ s := Iff.rfl\n\n"}
{"name":"Set.diff_eq","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (SDiff.sdiff s t) (Inter.inter s (HasCompl.compl t))","decl":"theorem diff_eq (s t : Set α) : s \\ t = s ∩ tᶜ := rfl\n\n"}
{"name":"Set.mem_diff","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\ns t : Set α\nx : α\n⊢ Iff (Membership.mem (SDiff.sdiff s t) x) (And (Membership.mem s x) (Not (Membership.mem t x)))","decl":"@[simp] theorem mem_diff {s t : Set α} (x : α) : x ∈ s \\ t ↔ x ∈ s ∧ x ∉ t := Iff.rfl\n\n"}
{"name":"Set.mem_diff_of_mem","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\ns t : Set α\nx : α\nh1 : Membership.mem s x\nh2 : Not (Membership.mem t x)\n⊢ Membership.mem (SDiff.sdiff s t) x","decl":"theorem mem_diff_of_mem {s t : Set α} {x : α} (h1 : x ∈ s) (h2 : x ∉ t) : x ∈ s \\ t := ⟨h1, h2⟩\n\n"}
{"name":"Set.mem_preimage","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set β\na : α\n⊢ Iff (Membership.mem (Set.preimage f s) a) (Membership.mem s (f a))","decl":"@[simp, mfld_simps]\ntheorem mem_preimage {f : α → β} {s : Set β} {a : α} : a ∈ f ⁻¹' s ↔ f a ∈ s := Iff.rfl\n\n"}
{"name":"Set.mem_image","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set α\ny : β\n⊢ Iff (Membership.mem (Set.image f s) y) (Exists fun x => And (Membership.mem s x) (Eq (f x) y))","decl":"@[simp]\ntheorem mem_image (f : α → β) (s : Set α) (y : β) : y ∈ f '' s ↔ ∃ x ∈ s, f x = y :=\n  Iff.rfl\n\n"}
{"name":"Set.mem_image_of_mem","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nx : α\na : Set α\nh : Membership.mem a x\n⊢ Membership.mem (Set.image f a) (f x)","decl":"@[mfld_simps]\ntheorem mem_image_of_mem (f : α → β) {x : α} {a : Set α} (h : x ∈ a) : f x ∈ f '' a :=\n  ⟨_, h, rfl⟩\n\n"}
{"name":"Set.subset_kernImage_iff","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nβ : Type v\ns : Set β\nt : Set α\nf : α → β\n⊢ Iff (HasSubset.Subset s (Set.kernImage f t)) (HasSubset.Subset (Set.preimage f s) t)","decl":"lemma subset_kernImage_iff {s : Set β} {t : Set α} {f : α → β} : s ⊆ kernImage f t ↔ f ⁻¹' s ⊆ t :=\n  ⟨fun h _ hx ↦ h hx rfl,\n    fun h _ hx y hy ↦ h (show f y ∈ s from hy.symm ▸ hx)⟩\n\n"}
{"name":"Set.mem_range","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nι : Sort u_1\nf : ι → α\nx : α\n⊢ Iff (Membership.mem (Set.range f) x) (Exists fun y => Eq (f y) x)","decl":"@[simp] theorem mem_range {x : α} : x ∈ range f ↔ ∃ y, f y = x := Iff.rfl\n\n"}
{"name":"Set.mem_range_self","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nι : Sort u_1\nf : ι → α\ni : ι\n⊢ Membership.mem (Set.range f) (f i)","decl":"@[mfld_simps] theorem mem_range_self (i : ι) : f i ∈ range f := ⟨i, rfl⟩\n\n"}
{"name":"Set.apply_rangeSplitting","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nx : ↑(Set.range f)\n⊢ Eq (f (Set.rangeSplitting f x)) ↑x","decl":"theorem apply_rangeSplitting (f : α → β) (x : range f) : f (rangeSplitting f x) = x :=\n  x.2.choose_spec\n\n"}
{"name":"Set.comp_rangeSplitting","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nβ : Type v\nf : α → β\n⊢ Eq (Function.comp f (Set.rangeSplitting f)) Subtype.val","decl":"@[simp]\ntheorem comp_rangeSplitting (f : α → β) : f ∘ rangeSplitting f = Subtype.val := by\n  ext\n  simp only [Function.comp_apply]\n  apply apply_rangeSplitting\n\n"}
{"name":"Set.prod_eq","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nβ : Type v\ns : Set α\nt : Set β\n⊢ Eq (SProd.sprod s t) (Inter.inter (Set.preimage Prod.fst s) (Set.preimage Prod.snd t))","decl":"theorem prod_eq (s : Set α) (t : Set β) : s ×ˢ t = Prod.fst ⁻¹' s ∩ Prod.snd ⁻¹' t := rfl\n\n"}
{"name":"Set.mem_prod_eq","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nβ : Type v\ns : Set α\nt : Set β\np : Prod α β\n⊢ Eq (Membership.mem (SProd.sprod s t) p) (And (Membership.mem s p.fst) (Membership.mem t p.snd))","decl":"theorem mem_prod_eq : (p ∈ s ×ˢ t) = (p.1 ∈ s ∧ p.2 ∈ t) := rfl\n\n"}
{"name":"Set.mem_prod","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nβ : Type v\ns : Set α\nt : Set β\np : Prod α β\n⊢ Iff (Membership.mem (SProd.sprod s t) p) (And (Membership.mem s p.fst) (Membership.mem t p.snd))","decl":"@[simp, mfld_simps]\ntheorem mem_prod : p ∈ s ×ˢ t ↔ p.1 ∈ s ∧ p.2 ∈ t := .rfl\n\n"}
{"name":"Set.prod_mk_mem_set_prod_eq","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nβ : Type v\na : α\nb : β\ns : Set α\nt : Set β\n⊢ Eq (Membership.mem (SProd.sprod s t) { fst := a, snd := b }) (And (Membership.mem s a) (Membership.mem t b))","decl":"@[mfld_simps]\ntheorem prod_mk_mem_set_prod_eq : ((a, b) ∈ s ×ˢ t) = (a ∈ s ∧ b ∈ t) := rfl\n\n"}
{"name":"Set.mk_mem_prod","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nβ : Type v\na : α\nb : β\ns : Set α\nt : Set β\nha : Membership.mem s a\nhb : Membership.mem t b\n⊢ Membership.mem (SProd.sprod s t) { fst := a, snd := b }","decl":"theorem mk_mem_prod (ha : a ∈ s) (hb : b ∈ t) : (a, b) ∈ s ×ˢ t := ⟨ha, hb⟩\n\n"}
{"name":"Set.mem_diagonal","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nx : α\n⊢ Membership.mem (Set.diagonal α) { fst := x, snd := x }","decl":"theorem mem_diagonal (x : α) : (x, x) ∈ diagonal α := rfl\n\n"}
{"name":"Set.mem_diagonal_iff","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nx : Prod α α\n⊢ Iff (Membership.mem (Set.diagonal α) x) (Eq x.fst x.snd)","decl":"@[simp] theorem mem_diagonal_iff {x : α × α} : x ∈ diagonal α ↔ x.1 = x.2 := .rfl\n\n"}
{"name":"Set.mem_offDiag","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nx : Prod α α\ns : Set α\n⊢ Iff (Membership.mem s.offDiag x) (And (Membership.mem s x.fst) (And (Membership.mem s x.snd) (Ne x.fst x.snd)))","decl":"@[simp]\ntheorem mem_offDiag {x : α × α} {s : Set α} : x ∈ s.offDiag ↔ x.1 ∈ s ∧ x.2 ∈ s ∧ x.1 ≠ x.2 :=\n  Iff.rfl\n\n"}
{"name":"Set.mem_pi","module":"Mathlib.Data.Set.Operations","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Set ι\nt : (i : ι) → Set (α i)\nf : (i : ι) → α i\n⊢ Iff (Membership.mem (s.pi t) f) (∀ (i : ι), Membership.mem s i → Membership.mem (t i) (f i))","decl":"@[simp] theorem mem_pi : f ∈ s.pi t ↔ ∀ i ∈ s, f i ∈ t i := .rfl\n\n"}
{"name":"Set.mem_univ_pi","module":"Mathlib.Data.Set.Operations","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nt : (i : ι) → Set (α i)\nf : (i : ι) → α i\n⊢ Iff (Membership.mem (Set.univ.pi t) f) (∀ (i : ι), Membership.mem (t i) (f i))","decl":"theorem mem_univ_pi : f ∈ pi univ t ↔ ∀ i, f i ∈ t i := by simp\n\n"}
{"name":"Set.mapsTo_image","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set α\n⊢ Set.MapsTo f s (Set.image f s)","decl":"theorem mapsTo_image (f : α → β) (s : Set α) : MapsTo f s (f '' s) := fun _ ↦ mem_image_of_mem f\n\n"}
{"name":"Set.mapsTo_preimage","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nt : Set β\n⊢ Set.MapsTo f (Set.preimage f t) t","decl":"theorem mapsTo_preimage (f : α → β) (t : Set β) : MapsTo f (f ⁻¹' t) t := fun _ ↦ id\n\n"}
{"name":"Set.restrictPreimage_coe","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nβ : Type v\nt : Set β\nf : α → β\na✝ : ↑(Set.preimage f t)\n⊢ Eq (↑(t.restrictPreimage f a✝)) (f ↑a✝)","decl":"/-- The restriction of a function onto the preimage of a set. -/\n@[simps!]\ndef restrictPreimage (t : Set β) (f : α → β) : f ⁻¹' t → t :=\n  (Set.mapsTo_preimage f t).restrict _ _ _\n\n"}
{"name":"Set.mem_image2","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : α → β → γ\ns : Set α\nt : Set β\nc : γ\n⊢ Iff (Membership.mem (Set.image2 f s t) c) (Exists fun a => And (Membership.mem s a) (Exists fun b => And (Membership.mem t b) (Eq (f a b) c)))","decl":"@[simp] theorem mem_image2 : c ∈ image2 f s t ↔ ∃ a ∈ s, ∃ b ∈ t, f a b = c := .rfl\n\n"}
{"name":"Set.mem_image2_of_mem","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : α → β → γ\ns : Set α\nt : Set β\na : α\nb : β\nha : Membership.mem s a\nhb : Membership.mem t b\n⊢ Membership.mem (Set.image2 f s t) (f a b)","decl":"theorem mem_image2_of_mem (ha : a ∈ s) (hb : b ∈ t) : f a b ∈ image2 f s t :=\n  ⟨a, ha, b, hb, rfl⟩\n\n"}
{"name":"Set.mem_seq_iff","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nβ : Type v\ns : Set (α → β)\nt : Set α\nb : β\n⊢ Iff (Membership.mem (s.seq t) b) (Exists fun f => And (Membership.mem s f) (Exists fun a => And (Membership.mem t a) (Eq (f a) b)))","decl":"@[simp]\ntheorem mem_seq_iff {s : Set (α → β)} {t : Set α} {b : β} :\n    b ∈ seq s t ↔ ∃ f ∈ s, ∃ a ∈ t, (f : α → β) a = b :=\n  Iff.rfl\n\n"}
{"name":"Set.seq_eq_image2","module":"Mathlib.Data.Set.Operations","initialProofState":"α : Type u\nβ : Type v\ns : Set (α → β)\nt : Set α\n⊢ Eq (s.seq t) (Set.image2 (fun f a => f a) s t)","decl":"lemma seq_eq_image2 (s : Set (α → β)) (t : Set α) : seq s t = image2 (fun f a ↦ f a) s t := rfl\n\n"}
