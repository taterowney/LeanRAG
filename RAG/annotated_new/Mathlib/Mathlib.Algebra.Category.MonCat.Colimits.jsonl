{"name":"MonCat.Colimits.Prequotient.mul.sizeOf_spec","module":"Mathlib.Algebra.Category.MonCat.Colimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{u, v} J\nF : CategoryTheory.Functor J MonCat\ninst✝ : SizeOf J\na✝¹ a✝ : MonCat.Colimits.Prequotient F\n⊢ Eq (SizeOf.sizeOf (a✝¹.mul a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- An inductive type representing all monoid expressions (without relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient\n  -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient\n  -- Then one generator for each operation\n  | one : Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"MonCat.Colimits.Prequotient.mul.inj","module":"Mathlib.Algebra.Category.MonCat.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{u, v} J\nF : CategoryTheory.Functor J MonCat\na✝³ a✝² a✝¹ a✝ : MonCat.Colimits.Prequotient F\nx✝ : Eq (a✝³.mul a✝²) (a✝¹.mul a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- An inductive type representing all monoid expressions (without relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient\n  -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient\n  -- Then one generator for each operation\n  | one : Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"MonCat.Colimits.Prequotient.mul.injEq","module":"Mathlib.Algebra.Category.MonCat.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{u, v} J\nF : CategoryTheory.Functor J MonCat\na✝³ a✝² a✝¹ a✝ : MonCat.Colimits.Prequotient F\n⊢ Eq (Eq (a✝³.mul a✝²) (a✝¹.mul a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- An inductive type representing all monoid expressions (without relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient\n  -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient\n  -- Then one generator for each operation\n  | one : Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"MonCat.Colimits.Prequotient.of.injEq","module":"Mathlib.Algebra.Category.MonCat.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{u, v} J\nF : CategoryTheory.Functor J MonCat\nj✝ : J\nx✝¹ : ↑(F.obj j✝)\nj : J\nx✝ : ↑(F.obj j)\n⊢ Eq (Eq (MonCat.Colimits.Prequotient.of j✝ x✝¹) (MonCat.Colimits.Prequotient.of j x✝)) (And (Eq j✝ j) (HEq x✝¹ x✝))","decl":"/-- An inductive type representing all monoid expressions (without relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient\n  -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient\n  -- Then one generator for each operation\n  | one : Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"MonCat.Colimits.Prequotient.of.inj","module":"Mathlib.Algebra.Category.MonCat.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{u, v} J\nF : CategoryTheory.Functor J MonCat\nj✝ : J\nx✝² : ↑(F.obj j✝)\nj : J\nx✝¹ : ↑(F.obj j)\nx✝ : Eq (MonCat.Colimits.Prequotient.of j✝ x✝²) (MonCat.Colimits.Prequotient.of j x✝¹)\n⊢ And (Eq j✝ j) (HEq x✝² x✝¹)","decl":"/-- An inductive type representing all monoid expressions (without relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient\n  -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient\n  -- Then one generator for each operation\n  | one : Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"MonCat.Colimits.Prequotient.one.sizeOf_spec","module":"Mathlib.Algebra.Category.MonCat.Colimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{u, v} J\nF : CategoryTheory.Functor J MonCat\ninst✝ : SizeOf J\n⊢ Eq (SizeOf.sizeOf MonCat.Colimits.Prequotient.one) 1","decl":"/-- An inductive type representing all monoid expressions (without relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient\n  -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient\n  -- Then one generator for each operation\n  | one : Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"MonCat.Colimits.Prequotient.of.sizeOf_spec","module":"Mathlib.Algebra.Category.MonCat.Colimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{u, v} J\nF : CategoryTheory.Functor J MonCat\ninst✝ : SizeOf J\nj : J\nx✝ : ↑(F.obj j)\n⊢ Eq (SizeOf.sizeOf (MonCat.Colimits.Prequotient.of j x✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf j)) (SizeOf.sizeOf x✝))","decl":"/-- An inductive type representing all monoid expressions (without relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient\n  -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient\n  -- Then one generator for each operation\n  | one : Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"MonCat.Colimits.quot_one","module":"Mathlib.Algebra.Category.MonCat.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{u, v} J\nF : CategoryTheory.Functor J MonCat\n⊢ Eq (Quot.mk (⇑(MonCat.Colimits.colimitSetoid F)) MonCat.Colimits.Prequotient.one) 1","decl":"@[simp]\ntheorem quot_one : Quot.mk Setoid.r one = (1 : ColimitType F) :=\n  rfl\n\n"}
{"name":"MonCat.Colimits.quot_mul","module":"Mathlib.Algebra.Category.MonCat.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{u, v} J\nF : CategoryTheory.Functor J MonCat\nx y : MonCat.Colimits.Prequotient F\n⊢ Eq (Quot.mk (⇑(MonCat.Colimits.colimitSetoid F)) (x.mul y)) (HMul.hMul (Quot.mk (⇑(MonCat.Colimits.colimitSetoid F)) x) (Quot.mk (⇑(MonCat.Colimits.colimitSetoid F)) y))","decl":"@[simp]\ntheorem quot_mul (x y : Prequotient F) : Quot.mk Setoid.r (mul x y) =\n    @HMul.hMul (ColimitType F) (ColimitType F) (ColimitType F) _\n      (Quot.mk Setoid.r x) (Quot.mk Setoid.r y) :=\n  rfl\n\n"}
{"name":"MonCat.Colimits.cocone_naturality","module":"Mathlib.Algebra.Category.MonCat.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{u, v} J\nF : CategoryTheory.Functor J MonCat\nj j' : J\nf : Quiver.Hom j j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (MonCat.Colimits.coconeMorphism F j')) (MonCat.Colimits.coconeMorphism F j)","decl":"@[simp]\ntheorem cocone_naturality {j j' : J} (f : j ⟶ j') :\n    F.map f ≫ coconeMorphism F j' = coconeMorphism F j := by\n  ext\n  apply Quot.sound\n  apply Relation.map\n\n"}
{"name":"MonCat.Colimits.cocone_naturality_components","module":"Mathlib.Algebra.Category.MonCat.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{u, v} J\nF : CategoryTheory.Functor J MonCat\nj j' : J\nf : Quiver.Hom j j'\nx : ↑(F.obj j)\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (MonCat.Colimits.coconeMorphism F j')) ((CategoryTheory.ConcreteCategory.hom (F.map f)) x)) ((CategoryTheory.ConcreteCategory.hom (MonCat.Colimits.coconeMorphism F j)) x)","decl":"@[simp]\ntheorem cocone_naturality_components (j j' : J) (f : j ⟶ j') (x : F.obj j) :\n    (coconeMorphism F j') (F.map f x) = (coconeMorphism F j) x := by\n  rw [← cocone_naturality F f]\n  rfl\n\n"}
{"name":"MonCat.Colimits.hasColimits_monCat","module":"Mathlib.Algebra.Category.MonCat.Colimits","initialProofState":"⊢ CategoryTheory.Limits.HasColimits MonCat","decl":"instance hasColimits_monCat : HasColimits MonCat where\n  has_colimits_of_shape _ _ :=\n    { has_colimit := fun F =>\n        HasColimit.mk\n          { cocone := colimitCocone F\n            isColimit := colimitIsColimit F } }\n\n"}
