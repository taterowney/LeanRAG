{"name":"Inseparable.inner_eq_inner","module":"Mathlib.Analysis.InnerProductSpace.Completion","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx₁ x₂ y₁ y₂ : E\nhx : Inseparable x₁ x₂\nhy : Inseparable y₁ y₂\n⊢ Eq (Inner.inner x₁ y₁) (Inner.inner x₂ y₂)","decl":"theorem Inseparable.inner_eq_inner {x₁ x₂ y₁ y₂ : E}\n    (hx : Inseparable x₁ x₂) (hy : Inseparable y₁ y₂) :\n    inner x₁ y₁ = (inner x₂ y₂ : 𝕜) :=\n  ((hx.prod hy).map continuous_inner).eq\n\n"}
{"name":"SeparationQuotient.inner_mk_mk","module":"Mathlib.Analysis.InnerProductSpace.Completion","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (Inner.inner (SeparationQuotient.mk x) (SeparationQuotient.mk y)) (Inner.inner x y)","decl":"@[simp]\ntheorem inner_mk_mk (x y : E) :\n    inner (mk x) (mk y) = (inner x y : 𝕜) := rfl\n\n"}
{"name":"UniformSpace.Completion.inner_coe","module":"Mathlib.Analysis.InnerProductSpace.Completion","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\na b : E\n⊢ Eq (Inner.inner ↑a ↑b) (Inner.inner a b)","decl":"@[simp]\ntheorem inner_coe (a b : E) : inner (a : Completion E) (b : Completion E) = (inner a b : 𝕜) :=\n  (isDenseInducing_coe.prodMap isDenseInducing_coe).extend_eq\n    (continuous_inner : Continuous (uncurry inner : E × E → 𝕜)) (a, b)\n\n"}
{"name":"UniformSpace.Completion.continuous_inner","module":"Mathlib.Analysis.InnerProductSpace.Completion","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\n⊢ Continuous (Function.uncurry Inner.inner)","decl":"protected theorem continuous_inner :\n    Continuous (uncurry inner : Completion E × Completion E → 𝕜) := by\n  let inner' : E →+ E →+ 𝕜 :=\n    { toFun := fun x => (innerₛₗ 𝕜 x).toAddMonoidHom\n      map_zero' := by ext x; exact inner_zero_left _\n      map_add' := fun x y => by ext z; exact inner_add_left _ _ _ }\n  have : Continuous fun p : E × E => inner' p.1 p.2 := continuous_inner\n  rw [Completion.toInner, inner, uncurry_curry _]\n  change\n    Continuous\n      (((isDenseInducing_toCompl E).prodMap (isDenseInducing_toCompl E)).extend fun p : E × E =>\n        inner' p.1 p.2)\n  exact (isDenseInducing_toCompl E).extend_Z_bilin (isDenseInducing_toCompl E) this\n\n"}
{"name":"UniformSpace.Completion.Continuous.inner","module":"Mathlib.Analysis.InnerProductSpace.Completion","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : SeminormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\nα : Type u_4\ninst✝ : TopologicalSpace α\nf g : α → UniformSpace.Completion E\nhf : Continuous f\nhg : Continuous g\n⊢ Continuous fun x => Inner.inner (f x) (g x)","decl":"protected theorem Continuous.inner {α : Type*} [TopologicalSpace α] {f g : α → Completion E}\n    (hf : Continuous f) (hg : Continuous g) : Continuous (fun x : α => inner (f x) (g x) : α → 𝕜) :=\n  UniformSpace.Completion.continuous_inner.comp (hf.prod_mk hg :)\n\n"}
