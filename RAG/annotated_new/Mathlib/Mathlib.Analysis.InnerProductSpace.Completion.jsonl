{"name":"Inseparable.inner_eq_inner","module":"Mathlib.Analysis.InnerProductSpace.Completion","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nxâ‚ xâ‚‚ yâ‚ yâ‚‚ : E\nhx : Inseparable xâ‚ xâ‚‚\nhy : Inseparable yâ‚ yâ‚‚\nâŠ¢ Eq (Inner.inner xâ‚ yâ‚) (Inner.inner xâ‚‚ yâ‚‚)","decl":"theorem Inseparable.inner_eq_inner {xâ‚ xâ‚‚ yâ‚ yâ‚‚ : E}\n    (hx : Inseparable xâ‚ xâ‚‚) (hy : Inseparable yâ‚ yâ‚‚) :\n    inner xâ‚ yâ‚ = (inner xâ‚‚ yâ‚‚ : ğ•œ) :=\n  ((hx.prod hy).map continuous_inner).eq\n\n"}
{"name":"SeparationQuotient.inner_mk_mk","module":"Mathlib.Analysis.InnerProductSpace.Completion","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (Inner.inner (SeparationQuotient.mk x) (SeparationQuotient.mk y)) (Inner.inner x y)","decl":"@[simp]\ntheorem inner_mk_mk (x y : E) :\n    inner (mk x) (mk y) = (inner x y : ğ•œ) := rfl\n\n"}
{"name":"UniformSpace.Completion.inner_coe","module":"Mathlib.Analysis.InnerProductSpace.Completion","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\na b : E\nâŠ¢ Eq (Inner.inner â†‘a â†‘b) (Inner.inner a b)","decl":"@[simp]\ntheorem inner_coe (a b : E) : inner (a : Completion E) (b : Completion E) = (inner a b : ğ•œ) :=\n  (isDenseInducing_coe.prodMap isDenseInducing_coe).extend_eq\n    (continuous_inner : Continuous (uncurry inner : E Ã— E â†’ ğ•œ)) (a, b)\n\n"}
{"name":"UniformSpace.Completion.continuous_inner","module":"Mathlib.Analysis.InnerProductSpace.Completion","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nâŠ¢ Continuous (Function.uncurry Inner.inner)","decl":"protected theorem continuous_inner :\n    Continuous (uncurry inner : Completion E Ã— Completion E â†’ ğ•œ) := by\n  let inner' : E â†’+ E â†’+ ğ•œ :=\n    { toFun := fun x => (innerâ‚›â‚— ğ•œ x).toAddMonoidHom\n      map_zero' := by ext x; exact inner_zero_left _\n      map_add' := fun x y => by ext z; exact inner_add_left _ _ _ }\n  have : Continuous fun p : E Ã— E => inner' p.1 p.2 := continuous_inner\n  rw [Completion.toInner, inner, uncurry_curry _]\n  change\n    Continuous\n      (((isDenseInducing_toCompl E).prodMap (isDenseInducing_toCompl E)).extend fun p : E Ã— E =>\n        inner' p.1 p.2)\n  exact (isDenseInducing_toCompl E).extend_Z_bilin (isDenseInducing_toCompl E) this\n\n"}
{"name":"UniformSpace.Completion.Continuous.inner","module":"Mathlib.Analysis.InnerProductSpace.Completion","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nÎ± : Type u_4\ninstâœ : TopologicalSpace Î±\nf g : Î± â†’ UniformSpace.Completion E\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Continuous fun x => Inner.inner (f x) (g x)","decl":"protected theorem Continuous.inner {Î± : Type*} [TopologicalSpace Î±] {f g : Î± â†’ Completion E}\n    (hf : Continuous f) (hg : Continuous g) : Continuous (fun x : Î± => inner (f x) (g x) : Î± â†’ ğ•œ) :=\n  UniformSpace.Completion.continuous_inner.comp (hf.prod_mk hg :)\n\n"}
