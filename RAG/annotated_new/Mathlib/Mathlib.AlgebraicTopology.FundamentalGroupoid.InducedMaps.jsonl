{"name":"ContinuousMap.Homotopy.hcast_def","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.InducedMaps","initialProofState":"X : TopCat\nx‚ÇÄ x‚ÇÅ : ‚ÜëX\nhx‚ÇÄ : Eq x‚ÇÄ x‚ÇÅ\n‚ä¢ Eq (ContinuousMap.Homotopy.hcast hx‚ÇÄ) (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\ntheorem hcast_def {X : TopCat} {x‚ÇÄ x‚ÇÅ : X} (hx‚ÇÄ : x‚ÇÄ = x‚ÇÅ) :\n    hcast hx‚ÇÄ = eqToHom (FundamentalGroupoid.ext hx‚ÇÄ) :=\n  rfl\n\n"}
{"name":"ContinuousMap.Homotopy.heq_path_of_eq_image","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.InducedMaps","initialProofState":"X‚ÇÅ X‚ÇÇ Y : TopCat\nf : ContinuousMap ‚ÜëX‚ÇÅ ‚ÜëY\ng : ContinuousMap ‚ÜëX‚ÇÇ ‚ÜëY\nx‚ÇÄ x‚ÇÅ : ‚ÜëX‚ÇÅ\nx‚ÇÇ x‚ÇÉ : ‚ÜëX‚ÇÇ\np : Path x‚ÇÄ x‚ÇÅ\nq : Path x‚ÇÇ x‚ÇÉ\nhfg : ‚àÄ (t : ‚ÜëunitInterval), Eq (f (p t)) (g (q t))\n‚ä¢ HEq ((FundamentalGroupoid.fundamentalGroupoidFunctor.map f).map (Quotient.mk (Path.Homotopic.setoid { as := x‚ÇÄ }.as { as := x‚ÇÅ }.as) p)) ((FundamentalGroupoid.fundamentalGroupoidFunctor.map g).map (Quotient.mk (Path.Homotopic.setoid { as := x‚ÇÇ }.as { as := x‚ÇÉ }.as) q))","decl":"/-- If `f(p(t) = g(q(t))` for two paths `p` and `q`, then the induced path homotopy classes\n`f(p)` and `g(p)` are the same as well, despite having a priori different types -/\ntheorem heq_path_of_eq_image : HEq ((œÄ‚Çò f).map ‚ü¶p‚üß) ((œÄ‚Çò g).map ‚ü¶q‚üß) := by\n  simp only [map_eq, ‚Üê Path.Homotopic.map_lift]; apply Path.Homotopic.hpath_hext; exact hfg\n\n"}
{"name":"ContinuousMap.Homotopy.eq_path_of_eq_image","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.InducedMaps","initialProofState":"X‚ÇÅ X‚ÇÇ Y : TopCat\nf : ContinuousMap ‚ÜëX‚ÇÅ ‚ÜëY\ng : ContinuousMap ‚ÜëX‚ÇÇ ‚ÜëY\nx‚ÇÄ x‚ÇÅ : ‚ÜëX‚ÇÅ\nx‚ÇÇ x‚ÇÉ : ‚ÜëX‚ÇÇ\np : Path x‚ÇÄ x‚ÇÅ\nq : Path x‚ÇÇ x‚ÇÉ\nhfg : ‚àÄ (t : ‚ÜëunitInterval), Eq (f (p t)) (g (q t))\n‚ä¢ Eq ((FundamentalGroupoid.fundamentalGroupoidFunctor.map f).map (Quotient.mk (Path.Homotopic.setoid { as := x‚ÇÄ }.as { as := x‚ÇÅ }.as) p)) (CategoryTheory.CategoryStruct.comp (ContinuousMap.Homotopy.hcast ‚ãØ) (CategoryTheory.CategoryStruct.comp ((FundamentalGroupoid.fundamentalGroupoidFunctor.map g).map (Quotient.mk (Path.Homotopic.setoid { as := x‚ÇÇ }.as { as := x‚ÇÉ }.as) q)) (ContinuousMap.Homotopy.hcast ‚ãØ)))","decl":"theorem eq_path_of_eq_image :\n    (œÄ‚Çò f).map ‚ü¶p‚üß = hcast (start_path hfg) ‚â´ (œÄ‚Çò g).map ‚ü¶q‚üß ‚â´ hcast (end_path hfg).symm := by\n  rw [conj_eqToHom_iff_heq\n    ((œÄ‚Çò f).map ‚ü¶p‚üß) ((œÄ‚Çò g).map ‚ü¶q‚üß)\n    (FundamentalGroupoid.ext <| start_path hfg)\n    (FundamentalGroupoid.ext <| end_path hfg)]\n  exact heq_path_of_eq_image hfg\n\n"}
{"name":"ContinuousMap.Homotopy.ulift_apply","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.InducedMaps","initialProofState":"X Y : TopCat\nf g : ContinuousMap ‚ÜëX ‚ÜëY\nH : f.Homotopy g\ni : ULift.{u, 0} ‚ÜëunitInterval\nx : ‚ÜëX\n‚ä¢ Eq (H.uliftMap { fst := i, snd := x }) (H { fst := i.down, snd := x })","decl":"theorem ulift_apply (i : ULift.{u} I) (x : X) : H.uliftMap (i, x) = H (i.down, x) :=\n  rfl\n\n"}
{"name":"ContinuousMap.Homotopy.apply_zero_path","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.InducedMaps","initialProofState":"X Y : TopCat\nf g : ContinuousMap ‚ÜëX ‚ÜëY\nH : f.Homotopy g\nx‚ÇÄ x‚ÇÅ : ‚ÜëX\np : Quiver.Hom (FundamentalGroupoid.fromTop x‚ÇÄ) (FundamentalGroupoid.fromTop x‚ÇÅ)\n‚ä¢ Eq ((FundamentalGroupoid.fundamentalGroupoidFunctor.map f).map p) (CategoryTheory.CategoryStruct.comp (ContinuousMap.Homotopy.hcast ‚ãØ) (CategoryTheory.CategoryStruct.comp ((FundamentalGroupoid.fundamentalGroupoidFunctor.map H.uliftMap).map (ContinuousMap.Homotopy.prodToProdTopI (CategoryTheory.CategoryStruct.id (FundamentalGroupoid.fromTop { down := 0 })) p)) (ContinuousMap.Homotopy.hcast ‚ãØ)))","decl":"/-- Proof that `f(p) = H(0 ‚ü∂ 0, p)`, with the appropriate casts -/\ntheorem apply_zero_path : (œÄ‚Çò f).map p = hcast (H.apply_zero x‚ÇÄ).symm ‚â´\n    (œÄ‚Çò H.uliftMap).map (prodToProdTopI (ùüô (@fromTop (TopCat.of _) (ULift.up 0))) p) ‚â´\n    hcast (H.apply_zero x‚ÇÅ) :=\n  Quotient.inductionOn p fun p' => by\n    apply @eq_path_of_eq_image _ _ _ _ H.uliftMap _ _ _ _ _ ((Path.refl (ULift.up _)).prod p')\n    -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n    erw [Path.prod_coe]; simp_rw [ulift_apply]; simp\n\n"}
{"name":"ContinuousMap.Homotopy.apply_one_path","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.InducedMaps","initialProofState":"X Y : TopCat\nf g : ContinuousMap ‚ÜëX ‚ÜëY\nH : f.Homotopy g\nx‚ÇÄ x‚ÇÅ : ‚ÜëX\np : Quiver.Hom (FundamentalGroupoid.fromTop x‚ÇÄ) (FundamentalGroupoid.fromTop x‚ÇÅ)\n‚ä¢ Eq ((FundamentalGroupoid.fundamentalGroupoidFunctor.map g).map p) (CategoryTheory.CategoryStruct.comp (ContinuousMap.Homotopy.hcast ‚ãØ) (CategoryTheory.CategoryStruct.comp ((FundamentalGroupoid.fundamentalGroupoidFunctor.map H.uliftMap).map (ContinuousMap.Homotopy.prodToProdTopI (CategoryTheory.CategoryStruct.id (FundamentalGroupoid.fromTop { down := 1 })) p)) (ContinuousMap.Homotopy.hcast ‚ãØ)))","decl":"/-- Proof that `g(p) = H(1 ‚ü∂ 1, p)`, with the appropriate casts -/\ntheorem apply_one_path : (œÄ‚Çò g).map p = hcast (H.apply_one x‚ÇÄ).symm ‚â´\n    (œÄ‚Çò H.uliftMap).map (prodToProdTopI (ùüô (@fromTop (TopCat.of _) (ULift.up 1))) p) ‚â´\n    hcast (H.apply_one x‚ÇÅ) :=\n  Quotient.inductionOn p fun p' => by\n    apply @eq_path_of_eq_image _ _ _ _ H.uliftMap _ _ _ _ _ ((Path.refl (ULift.up _)).prod p')\n    -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n    erw [Path.prod_coe]; simp_rw [ulift_apply]; simp\n\n"}
{"name":"ContinuousMap.Homotopy.evalAt_eq","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.InducedMaps","initialProofState":"X Y : TopCat\nf g : ContinuousMap ‚ÜëX ‚ÜëY\nH : f.Homotopy g\nx : ‚ÜëX\n‚ä¢ Eq (Quotient.mk (Path.Homotopic.setoid (FundamentalGroupoid.fromTop (f x)).as (FundamentalGroupoid.fromTop (g x)).as) (H.evalAt x)) (CategoryTheory.CategoryStruct.comp (ContinuousMap.Homotopy.hcast ‚ãØ) (CategoryTheory.CategoryStruct.comp ((FundamentalGroupoid.fundamentalGroupoidFunctor.map H.uliftMap).map (ContinuousMap.Homotopy.prodToProdTopI unitInterval.uhpath01 (CategoryTheory.CategoryStruct.id (FundamentalGroupoid.fromTop x)))) (ContinuousMap.Homotopy.hcast ‚ãØ)))","decl":"/-- Proof that `H.evalAt x = H(0 ‚ü∂ 1, x ‚ü∂ x)`, with the appropriate casts -/\ntheorem evalAt_eq (x : X) : ‚ü¶H.evalAt x‚üß = hcast (H.apply_zero x).symm ‚â´\n    (œÄ‚Çò H.uliftMap).map (prodToProdTopI uhpath01 (ùüô (fromTop x))) ‚â´\n      hcast (H.apply_one x).symm.symm := by\n  dsimp only [prodToProdTopI, uhpath01, hcast]\n  refine (@conj_eqToHom_iff_heq (œÄ‚Çì Y) _ _ _ _ _ _ _ _\n    (FundamentalGroupoid.ext <| H.apply_one x).symm).mpr ?_\n  simp only [id_eq_path_refl, prodToProdTop_map, Path.Homotopic.prod_lift, map_eq, ‚Üê\n    Path.Homotopic.map_lift]\n  apply Path.Homotopic.hpath_hext; intro; rfl\n\n-- Finally, we show `d = f(p) ‚â´ H‚ÇÅ = H‚ÇÄ ‚â´ g(p)`\n"}
{"name":"ContinuousMap.Homotopy.eq_diag_path","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.InducedMaps","initialProofState":"X Y : TopCat\nf g : ContinuousMap ‚ÜëX ‚ÜëY\nH : f.Homotopy g\nx‚ÇÄ x‚ÇÅ : ‚ÜëX\np : Quiver.Hom (FundamentalGroupoid.fromTop x‚ÇÄ) (FundamentalGroupoid.fromTop x‚ÇÅ)\n‚ä¢ And (Eq (CategoryTheory.CategoryStruct.comp ((FundamentalGroupoid.fundamentalGroupoidFunctor.map f).map p) (Quotient.mk (Path.Homotopic.setoid ((FundamentalGroupoid.fundamentalGroupoidFunctor.map f).obj (FundamentalGroupoid.fromTop x‚ÇÅ)).as { as := g x‚ÇÅ }.as) (H.evalAt x‚ÇÅ))) (H.diagonalPath' p)) (Eq (CategoryTheory.CategoryStruct.comp (Quotient.mk (Path.Homotopic.setoid (FundamentalGroupoid.fromTop (f x‚ÇÄ)).as { as := g x‚ÇÄ }.as) (H.evalAt x‚ÇÄ)) ((FundamentalGroupoid.fundamentalGroupoidFunctor.map g).map p)) (H.diagonalPath' p))","decl":"theorem eq_diag_path : (œÄ‚Çò f).map p ‚â´ ‚ü¶H.evalAt x‚ÇÅ‚üß = H.diagonalPath' p ‚àß\n    (‚ü¶H.evalAt x‚ÇÄ‚üß ‚â´ (œÄ‚Çò g).map p : fromTop (f x‚ÇÄ) ‚ü∂ fromTop (g x‚ÇÅ)) = H.diagonalPath' p := by\n  rw [H.apply_zero_path, H.apply_one_path, H.evalAt_eq]\n  erw [H.evalAt_eq] -- Porting note: `rw` didn't work, so using `erw`\n  dsimp only [prodToProdTopI]\n  constructor\n  ¬∑ slice_lhs 2 4 => rw [eqToHom_trans, eqToHom_refl] -- Porting note: this ‚Üì `simp` didn't do this\n    slice_lhs 2 4 => simp [‚Üê CategoryTheory.Functor.map_comp]\n    rfl\n  ¬∑ slice_lhs 2 4 => rw [eqToHom_trans, eqToHom_refl] -- Porting note: this ‚Üì `simp` didn't do this\n    slice_lhs 2 4 => simp [‚Üê CategoryTheory.Functor.map_comp]\n    rfl\n\n"}
{"name":"FundamentalGroupoidFunctor.instIsIsoFunctorŒ±GroupoidObjTopCatGrpdFundamentalGroupoidFunctorHomotopicMapsNatIso","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.InducedMaps","initialProofState":"X Y : TopCat\nf g : ContinuousMap ‚ÜëX ‚ÜëY\nH : f.Homotopy g\n‚ä¢ CategoryTheory.IsIso (FundamentalGroupoidFunctor.homotopicMapsNatIso H)","decl":"instance : IsIso (homotopicMapsNatIso H) := by apply NatIso.isIso_of_isIso_app\n\n"}
