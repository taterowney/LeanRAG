{"name":"AlgebraicGeometry.Scheme.GlueData.mk.injEq","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"toGlueData✝ : CategoryTheory.GlueData AlgebraicGeometry.Scheme\nf_open✝ : ∀ (i j : toGlueData✝.J), AlgebraicGeometry.IsOpenImmersion (toGlueData✝.f i j)\ntoGlueData : CategoryTheory.GlueData AlgebraicGeometry.Scheme\nf_open : ∀ (i j : toGlueData.J), AlgebraicGeometry.IsOpenImmersion (toGlueData.f i j)\n⊢ Eq (Eq { toGlueData := toGlueData✝, f_open := f_open✝ } { toGlueData := toGlueData, f_open := f_open }) (Eq toGlueData✝ toGlueData)","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A scheme `U i` for each `i : J`.\n3. A scheme `V i j` for each `i j : J`.\n  (Note that this is `J × J → Scheme` rather than `J → J → Scheme` to connect to the\n  limits library easier.)\n4. An open immersion `f i j : V i j ⟶ U i` for each `i j : ι`.\n5. A transition map `t i j : V i j ⟶ V j i` for each `i j : ι`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j ×[U i] V i k ⟶ V i j ⟶ V j i` factors through `V j k ×[U j] V j i ⟶ V j i` via some\n    `t' : V i j ×[U i] V i k ⟶ V j k ×[U j] V j i`.\n9. `t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _`.\n\nWe can then glue the schemes `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subschemes of the glued space.\n-/\nstructure GlueData extends CategoryTheory.GlueData Scheme where\n  f_open : ∀ i j, IsOpenImmersion (f i j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.mk.inj","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"toGlueData✝ : CategoryTheory.GlueData AlgebraicGeometry.Scheme\nf_open✝ : ∀ (i j : toGlueData✝.J), AlgebraicGeometry.IsOpenImmersion (toGlueData✝.f i j)\ntoGlueData : CategoryTheory.GlueData AlgebraicGeometry.Scheme\nf_open : ∀ (i j : toGlueData.J), AlgebraicGeometry.IsOpenImmersion (toGlueData.f i j)\nx✝ : Eq { toGlueData := toGlueData✝, f_open := f_open✝ } { toGlueData := toGlueData, f_open := f_open }\n⊢ Eq toGlueData✝ toGlueData","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A scheme `U i` for each `i : J`.\n3. A scheme `V i j` for each `i j : J`.\n  (Note that this is `J × J → Scheme` rather than `J → J → Scheme` to connect to the\n  limits library easier.)\n4. An open immersion `f i j : V i j ⟶ U i` for each `i j : ι`.\n5. A transition map `t i j : V i j ⟶ V j i` for each `i j : ι`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j ×[U i] V i k ⟶ V i j ⟶ V j i` factors through `V j k ×[U j] V j i ⟶ V j i` via some\n    `t' : V i j ×[U i] V i k ⟶ V j k ×[U j] V j i`.\n9. `t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _`.\n\nWe can then glue the schemes `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subschemes of the glued space.\n-/\nstructure GlueData extends CategoryTheory.GlueData Scheme where\n  f_open : ∀ i j, IsOpenImmersion (f i j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.mk.sizeOf_spec","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"toGlueData : CategoryTheory.GlueData AlgebraicGeometry.Scheme\nf_open : ∀ (i j : toGlueData.J), AlgebraicGeometry.IsOpenImmersion (toGlueData.f i j)\n⊢ Eq (SizeOf.sizeOf { toGlueData := toGlueData, f_open := f_open }) (HAdd.hAdd 1 (SizeOf.sizeOf toGlueData))","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A scheme `U i` for each `i : J`.\n3. A scheme `V i j` for each `i j : J`.\n  (Note that this is `J × J → Scheme` rather than `J → J → Scheme` to connect to the\n  limits library easier.)\n4. An open immersion `f i j : V i j ⟶ U i` for each `i j : ι`.\n5. A transition map `t i j : V i j ⟶ V j i` for each `i j : ι`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j ×[U i] V i k ⟶ V i j ⟶ V j i` factors through `V j k ×[U j] V j i ⟶ V j i` via some\n    `t' : V i j ×[U i] V i k ⟶ V j k ×[U j] V j i`.\n9. `t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _`.\n\nWe can then glue the schemes `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subschemes of the glued space.\n-/\nstructure GlueData extends CategoryTheory.GlueData Scheme where\n  f_open : ∀ i j, IsOpenImmersion (f i j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.f_open","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"self : AlgebraicGeometry.Scheme.GlueData\ni j : self.J\n⊢ AlgebraicGeometry.IsOpenImmersion (self.f i j)","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A scheme `U i` for each `i : J`.\n3. A scheme `V i j` for each `i j : J`.\n  (Note that this is `J × J → Scheme` rather than `J → J → Scheme` to connect to the\n  limits library easier.)\n4. An open immersion `f i j : V i j ⟶ U i` for each `i j : ι`.\n5. A transition map `t i j : V i j ⟶ V j i` for each `i j : ι`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j ×[U i] V i k ⟶ V i j ⟶ V j i` factors through `V j k ×[U j] V j i ⟶ V j i` via some\n    `t' : V i j ×[U i] V i k ⟶ V j k ×[U j] V j i`.\n9. `t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _`.\n\nWe can then glue the schemes `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subschemes of the glued space.\n-/\nstructure GlueData extends CategoryTheory.GlueData Scheme where\n  f_open : ∀ i j, IsOpenImmersion (f i j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.instIsOpenImmersionFLocallyRingedSpaceToLocallyRingedSpaceGlueData","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni j : D.J\n⊢ AlgebraicGeometry.LocallyRingedSpace.IsOpenImmersion (D.toLocallyRingedSpaceGlueData.f i j)","decl":"instance (i j : 𝖣.J) :\n    LocallyRingedSpace.IsOpenImmersion ((D.toLocallyRingedSpaceGlueData).toGlueData.f i j) := by\n  apply GlueData.f_open\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.instIsOpenImmersionCommRingCatFSheafedSpaceToSheafedSpaceGlueDataToLocallyRingedSpaceGlueData","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni j : D.J\n⊢ AlgebraicGeometry.SheafedSpace.IsOpenImmersion (D.toLocallyRingedSpaceGlueData.toSheafedSpaceGlueData.f i j)","decl":"instance (i j : 𝖣.J) :\n    SheafedSpace.IsOpenImmersion\n      (D.toLocallyRingedSpaceGlueData.toSheafedSpaceGlueData.toGlueData.f i j) := by\n  apply GlueData.f_open\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.instIsOpenImmersionCommRingCatFPresheafedSpaceToPresheafedSpaceGlueDataToSheafedSpaceGlueDataToLocallyRingedSpaceGlueData","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni j : D.J\n⊢ AlgebraicGeometry.PresheafedSpace.IsOpenImmersion (D.toLocallyRingedSpaceGlueData.toSheafedSpaceGlueData.toPresheafedSpaceGlueData.f i j)","decl":"instance (i j : 𝖣.J) :\n    PresheafedSpace.IsOpenImmersion\n      (D.toLocallyRingedSpaceGlueData.toSheafedSpaceGlueData.toPresheafedSpaceGlueData.toGlueData.f\n        i j) := by\n  apply GlueData.f_open\n\n-- Porting note: this was not needed.\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.instIsOpenImmersionιLocallyRingedSpaceToLocallyRingedSpaceGlueData","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni : D.J\n⊢ AlgebraicGeometry.LocallyRingedSpace.IsOpenImmersion (D.toLocallyRingedSpaceGlueData.ι i)","decl":"instance (i : 𝖣.J) :\n    LocallyRingedSpace.IsOpenImmersion ((D.toLocallyRingedSpaceGlueData).toGlueData.ι i) := by\n  apply LocallyRingedSpace.GlueData.ι_isOpenImmersion\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.instPreservesColimitTopCatWalkingMultispanLDiagramRFstFromSndFromMultispanForgetToTop","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\n⊢ CategoryTheory.Limits.PreservesColimit D.diagram.multispan AlgebraicGeometry.Scheme.forgetToTop","decl":"instance : PreservesColimit (𝖣.diagram.multispan) forgetToTop :=\n  inferInstanceAs (PreservesColimit (𝖣.diagram).multispan (forgetToLocallyRingedSpace ⋙\n      LocallyRingedSpace.forgetToSheafedSpace ⋙ SheafedSpace.forget CommRingCat))\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.instHasMulticoequalizerDiagram","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\n⊢ CategoryTheory.Limits.HasMulticoequalizer D.diagram","decl":"instance : HasMulticoequalizer 𝖣.diagram :=\n  hasColimit_of_created _ forgetToLocallyRingedSpace\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.ι_isoLocallyRingedSpace_inv","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni : D.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (D.toLocallyRingedSpaceGlueData.ι i) D.isoLocallyRingedSpace.inv) (AlgebraicGeometry.Scheme.Hom.toLRSHom (D.ι i))","decl":"theorem ι_isoLocallyRingedSpace_inv (i : D.J) :\n    D.toLocallyRingedSpaceGlueData.toGlueData.ι i ≫\n      D.isoLocallyRingedSpace.inv = (𝖣.ι i).toLRSHom :=\n  𝖣.ι_gluedIso_inv forgetToLocallyRingedSpace i\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.ι_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni : D.J\n⊢ AlgebraicGeometry.IsOpenImmersion (D.ι i)","decl":"instance ι_isOpenImmersion (i : D.J) : IsOpenImmersion (𝖣.ι i) := by\n  rw [IsOpenImmersion, ← D.ι_isoLocallyRingedSpace_inv]; infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.ι_jointly_surjective","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\nx : ↑↑D.glued.toPresheafedSpace\n⊢ Exists fun i => Exists fun y => Eq ((D.ι i).base y) x","decl":"theorem ι_jointly_surjective (x : 𝖣.glued.carrier) :\n    ∃ (i : D.J) (y : (D.U i).carrier), (D.ι i).base y = x :=\n  𝖣.ι_jointly_surjective (forgetToTop ⋙ forget TopCat) x\n\n-- Porting note: promote to higher priority to short circuit simplifier\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.glue_condition","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni j : D.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (D.t i j) (CategoryTheory.CategoryStruct.comp (D.f j i) (D.ι j))) (CategoryTheory.CategoryStruct.comp (D.f i j) (D.ι i))","decl":"@[simp (high), reassoc]\ntheorem glue_condition (i j : D.J) : D.t i j ≫ D.f j i ≫ D.ι j = D.f i j ≫ D.ι i :=\n  𝖣.glue_condition i j\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.glue_condition_assoc","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni j : D.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom D.glued Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (D.t i j) (CategoryTheory.CategoryStruct.comp (D.f j i) (CategoryTheory.CategoryStruct.comp (D.ι j) h))) (CategoryTheory.CategoryStruct.comp (D.f i j) (CategoryTheory.CategoryStruct.comp (D.ι i) h))","decl":"@[simp (high), reassoc]\ntheorem glue_condition (i j : D.J) : D.t i j ≫ D.f j i ≫ D.ι j = D.f i j ≫ D.ι i :=\n  𝖣.glue_condition i j\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.ι_isoCarrier_inv","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni : D.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (D.toLocallyRingedSpaceGlueData.toSheafedSpaceGlueData.toPresheafedSpaceGlueData.toTopGlueData.ι i) D.isoCarrier.inv) (D.ι i).base","decl":"@[simp]\ntheorem ι_isoCarrier_inv (i : D.J) :\n    (D_).ι i ≫ D.isoCarrier.inv = (D.ι i).base := by\n  delta isoCarrier\n  rw [Iso.trans_inv, GlueData.ι_gluedIso_inv_assoc, Functor.mapIso_inv, Iso.trans_inv,\n    Functor.mapIso_inv, Iso.trans_inv, SheafedSpace.forgetToPresheafedSpace_map, forget_map,\n    forget_map, ← PresheafedSpace.comp_base, ← Category.assoc,\n    D.toLocallyRingedSpaceGlueData.toSheafedSpaceGlueData.ι_isoPresheafedSpace_inv i]\n  erw [← Category.assoc, D.toLocallyRingedSpaceGlueData.ι_isoSheafedSpace_inv i]\n  change (_ ≫ D.isoLocallyRingedSpace.inv).base = _\n  rw [D.ι_isoLocallyRingedSpace_inv i]\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.ι_eq_iff","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni j : D.J\nx : ↑↑(D.U i).toPresheafedSpace\ny : ↑↑(D.U j).toPresheafedSpace\n⊢ Iff (Eq ((D.ι i).base x) ((D.ι j).base y)) (D.Rel ⟨i, x⟩ ⟨j, y⟩)","decl":"theorem ι_eq_iff (i j : D.J) (x : (D.U i).carrier) (y : (D.U j).carrier) :\n    (𝖣.ι i).base x = (𝖣.ι j).base y ↔ D.Rel ⟨i, x⟩ ⟨j, y⟩ := by\n  refine Iff.trans ?_\n    (TopCat.GlueData.ι_eq_iff_rel\n      D.toLocallyRingedSpaceGlueData.toSheafedSpaceGlueData.toPresheafedSpaceGlueData.toTopGlueData\n      i j x y)\n  rw [← ((TopCat.mono_iff_injective D.isoCarrier.inv).mp _).eq_iff, ← CategoryTheory.comp_apply]\n  · simp_rw [← D.ι_isoCarrier_inv]\n    rfl -- `rfl` was not needed before https://github.com/leanprover-community/mathlib4/pull/13170\n  · infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.isOpen_iff","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\nU : Set ↑↑D.glued.toPresheafedSpace\n⊢ Iff (IsOpen U) (∀ (i : D.J), IsOpen (Set.preimage (⇑(D.ι i).base) U))","decl":"theorem isOpen_iff (U : Set D.glued.carrier) : IsOpen U ↔ ∀ i, IsOpen ((D.ι i).base ⁻¹' U) := by\n  rw [← (TopCat.homeoOfIso D.isoCarrier.symm).isOpen_preimage, TopCat.GlueData.isOpen_iff]\n  apply forall_congr'\n  intro i\n  rw [← Set.preimage_comp, ← ι_isoCarrier_inv]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.openCover_J","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\n⊢ Eq D.openCover.J D.J","decl":"/-- The open cover of the glued space given by the glue data. -/\n@[simps (config := .lemmasOnly)]\ndef openCover (D : Scheme.GlueData) : OpenCover D.glued where\n  J := D.J\n  obj := D.U\n  map := D.ι\n  f x := (D.ι_jointly_surjective x).choose\n  covers x := ⟨_, (D.ι_jointly_surjective x).choose_spec.choose_spec⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.openCover_map","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni : D.J\n⊢ Eq (D.openCover.map i) (D.ι i)","decl":"/-- The open cover of the glued space given by the glue data. -/\n@[simps (config := .lemmasOnly)]\ndef openCover (D : Scheme.GlueData) : OpenCover D.glued where\n  J := D.J\n  obj := D.U\n  map := D.ι\n  f x := (D.ι_jointly_surjective x).choose\n  covers x := ⟨_, (D.ι_jointly_surjective x).choose_spec.choose_spec⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.openCover_f","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\nx : ↑↑D.glued.toPresheafedSpace\n⊢ Eq (D.openCover.f x) ⋯.choose","decl":"/-- The open cover of the glued space given by the glue data. -/\n@[simps (config := .lemmasOnly)]\ndef openCover (D : Scheme.GlueData) : OpenCover D.glued where\n  J := D.J\n  obj := D.U\n  map := D.ι\n  f x := (D.ι_jointly_surjective x).choose\n  covers x := ⟨_, (D.ι_jointly_surjective x).choose_spec.choose_spec⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.openCover_obj","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\na✝ : D.J\n⊢ Eq (D.openCover.obj a✝) (D.U a✝)","decl":"/-- The open cover of the glued space given by the glue data. -/\n@[simps (config := .lemmasOnly)]\ndef openCover (D : Scheme.GlueData) : OpenCover D.glued where\n  J := D.J\n  obj := D.U\n  map := D.ι\n  f x := (D.ι_jointly_surjective x).choose\n  covers x := ⟨_, (D.ι_jointly_surjective x).choose_spec.choose_spec⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCoverT'_fst_fst","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nx y z : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' 𝒰 x y z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (𝒰.map y) (𝒰.map z)) (CategoryTheory.Limits.pullback.fst (𝒰.map y) (𝒰.map x))) (CategoryTheory.Limits.pullback.fst (𝒰.map y) (𝒰.map z)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map y)) (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map z))) (CategoryTheory.Limits.pullback.snd (𝒰.map x) (𝒰.map y)))","decl":"@[simp, reassoc]\ntheorem gluedCoverT'_fst_fst (x y z : 𝒰.J) :\n    𝒰.gluedCoverT' x y z ≫ pullback.fst _ _ ≫ pullback.fst _ _ =\n      pullback.fst _ _ ≫ pullback.snd _ _ := by\n  delta gluedCoverT'; simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCoverT'_fst_fst_assoc","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nx y z : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (𝒰.obj y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' 𝒰 x y z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (𝒰.map y) (𝒰.map z)) (CategoryTheory.Limits.pullback.fst (𝒰.map y) (𝒰.map x))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (𝒰.map y) (𝒰.map z)) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map y)) (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map z))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (𝒰.map x) (𝒰.map y)) h))","decl":"@[simp, reassoc]\ntheorem gluedCoverT'_fst_fst (x y z : 𝒰.J) :\n    𝒰.gluedCoverT' x y z ≫ pullback.fst _ _ ≫ pullback.fst _ _ =\n      pullback.fst _ _ ≫ pullback.snd _ _ := by\n  delta gluedCoverT'; simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCoverT'_fst_snd","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nx y z : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' 𝒰 x y z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (𝒰.map y) (𝒰.map z)) (CategoryTheory.Limits.pullback.fst (𝒰.map y) (𝒰.map x))) (CategoryTheory.Limits.pullback.snd (𝒰.map y) (𝒰.map z)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map y)) (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map z))) (CategoryTheory.Limits.pullback.snd (𝒰.map x) (𝒰.map z)))","decl":"@[simp, reassoc]\ntheorem gluedCoverT'_fst_snd (x y z : 𝒰.J) :\n    gluedCoverT' 𝒰 x y z ≫ pullback.fst _ _ ≫ pullback.snd _ _ =\n      pullback.snd _ _ ≫ pullback.snd _ _ := by\n  delta gluedCoverT'; simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCoverT'_fst_snd_assoc","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nx y z : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (𝒰.obj z) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' 𝒰 x y z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (𝒰.map y) (𝒰.map z)) (CategoryTheory.Limits.pullback.fst (𝒰.map y) (𝒰.map x))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (𝒰.map y) (𝒰.map z)) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map y)) (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map z))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (𝒰.map x) (𝒰.map z)) h))","decl":"@[simp, reassoc]\ntheorem gluedCoverT'_fst_snd (x y z : 𝒰.J) :\n    gluedCoverT' 𝒰 x y z ≫ pullback.fst _ _ ≫ pullback.snd _ _ =\n      pullback.snd _ _ ≫ pullback.snd _ _ := by\n  delta gluedCoverT'; simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCoverT'_snd_fst_assoc","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nx y z : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (𝒰.obj y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' 𝒰 x y z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (𝒰.map y) (𝒰.map z)) (CategoryTheory.Limits.pullback.fst (𝒰.map y) (𝒰.map x))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (𝒰.map y) (𝒰.map x)) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map y)) (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map z))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (𝒰.map x) (𝒰.map y)) h))","decl":"@[simp, reassoc]\ntheorem gluedCoverT'_snd_fst (x y z : 𝒰.J) :\n    gluedCoverT' 𝒰 x y z ≫ pullback.snd _ _ ≫ pullback.fst _ _ =\n      pullback.fst _ _ ≫ pullback.snd _ _ := by\n  delta gluedCoverT'; simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCoverT'_snd_fst","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nx y z : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' 𝒰 x y z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (𝒰.map y) (𝒰.map z)) (CategoryTheory.Limits.pullback.fst (𝒰.map y) (𝒰.map x))) (CategoryTheory.Limits.pullback.fst (𝒰.map y) (𝒰.map x)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map y)) (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map z))) (CategoryTheory.Limits.pullback.snd (𝒰.map x) (𝒰.map y)))","decl":"@[simp, reassoc]\ntheorem gluedCoverT'_snd_fst (x y z : 𝒰.J) :\n    gluedCoverT' 𝒰 x y z ≫ pullback.snd _ _ ≫ pullback.fst _ _ =\n      pullback.fst _ _ ≫ pullback.snd _ _ := by\n  delta gluedCoverT'; simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCoverT'_snd_snd_assoc","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nx y z : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (𝒰.obj x) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' 𝒰 x y z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (𝒰.map y) (𝒰.map z)) (CategoryTheory.Limits.pullback.fst (𝒰.map y) (𝒰.map x))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (𝒰.map y) (𝒰.map x)) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map y)) (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map z))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map y)) h))","decl":"@[simp, reassoc]\ntheorem gluedCoverT'_snd_snd (x y z : 𝒰.J) :\n    gluedCoverT' 𝒰 x y z ≫ pullback.snd _ _ ≫ pullback.snd _ _ =\n      pullback.fst _ _ ≫ pullback.fst _ _ := by\n  delta gluedCoverT'; simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCoverT'_snd_snd","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nx y z : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' 𝒰 x y z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (𝒰.map y) (𝒰.map z)) (CategoryTheory.Limits.pullback.fst (𝒰.map y) (𝒰.map x))) (CategoryTheory.Limits.pullback.snd (𝒰.map y) (𝒰.map x)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map y)) (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map z))) (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map y)))","decl":"@[simp, reassoc]\ntheorem gluedCoverT'_snd_snd (x y z : 𝒰.J) :\n    gluedCoverT' 𝒰 x y z ≫ pullback.snd _ _ ≫ pullback.snd _ _ =\n      pullback.fst _ _ ≫ pullback.fst _ _ := by\n  delta gluedCoverT'; simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.glued_cover_cocycle_fst","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nx y z : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' 𝒰 x y z) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' 𝒰 y z x) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' 𝒰 z x y) (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map y)) (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map z)))))) (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map y)) (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map z)))","decl":"theorem glued_cover_cocycle_fst (x y z : 𝒰.J) :\n    gluedCoverT' 𝒰 x y z ≫ gluedCoverT' 𝒰 y z x ≫ gluedCoverT' 𝒰 z x y ≫ pullback.fst _ _ =\n      pullback.fst _ _ := by\n  apply pullback.hom_ext <;> simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.glued_cover_cocycle_snd","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nx y z : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' 𝒰 x y z) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' 𝒰 y z x) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' 𝒰 z x y) (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map y)) (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map z)))))) (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map y)) (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map z)))","decl":"theorem glued_cover_cocycle_snd (x y z : 𝒰.J) :\n    gluedCoverT' 𝒰 x y z ≫ gluedCoverT' 𝒰 y z x ≫ gluedCoverT' 𝒰 z x y ≫ pullback.snd _ _ =\n      pullback.snd _ _ := by\n  apply pullback.hom_ext <;> simp [pullback.condition]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.glued_cover_cocycle","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nx y z : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' 𝒰 x y z) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' 𝒰 y z x) (AlgebraicGeometry.Scheme.Cover.gluedCoverT' 𝒰 z x y))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map y)) (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map z))))","decl":"theorem glued_cover_cocycle (x y z : 𝒰.J) :\n    gluedCoverT' 𝒰 x y z ≫ gluedCoverT' 𝒰 y z x ≫ gluedCoverT' 𝒰 z x y = 𝟙 _ := by\n  apply pullback.hom_ext <;> simp_rw [Category.id_comp, Category.assoc]\n  · apply glued_cover_cocycle_fst\n  · apply glued_cover_cocycle_snd\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCover_V","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nx✝ : Prod 𝒰.J 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Cover.gluedCover 𝒰).V x✝) (AlgebraicGeometry.Scheme.Cover.gluedCover.match_1 𝒰 (fun x => AlgebraicGeometry.Scheme) x✝ fun x y => CategoryTheory.Limits.pullback (𝒰.map x) (𝒰.map y))","decl":"/-- The glue data associated with an open cover.\nThe canonical isomorphism `𝒰.gluedCover.glued ⟶ X` is provided by `𝒰.fromGlued`. -/\n@[simps]\ndef gluedCover : Scheme.GlueData.{u} where\n  J := 𝒰.J\n  U := 𝒰.obj\n  V := fun ⟨x, y⟩ => pullback (𝒰.map x) (𝒰.map y)\n  f _ _ := pullback.fst _ _\n  f_id _ := inferInstance\n  t _ _ := (pullbackSymmetry _ _).hom\n  t_id x := by simp\n  t' x y z := gluedCoverT' 𝒰 x y z\n  t_fac x y z := by apply pullback.hom_ext <;> simp\n  -- The `cocycle` field could have been `by tidy` but lean timeouts.\n  cocycle x y z := glued_cover_cocycle 𝒰 x y z\n  f_open _ := inferInstance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCover_J","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\n⊢ Eq (AlgebraicGeometry.Scheme.Cover.gluedCover 𝒰).J 𝒰.J","decl":"/-- The glue data associated with an open cover.\nThe canonical isomorphism `𝒰.gluedCover.glued ⟶ X` is provided by `𝒰.fromGlued`. -/\n@[simps]\ndef gluedCover : Scheme.GlueData.{u} where\n  J := 𝒰.J\n  U := 𝒰.obj\n  V := fun ⟨x, y⟩ => pullback (𝒰.map x) (𝒰.map y)\n  f _ _ := pullback.fst _ _\n  f_id _ := inferInstance\n  t _ _ := (pullbackSymmetry _ _).hom\n  t_id x := by simp\n  t' x y z := gluedCoverT' 𝒰 x y z\n  t_fac x y z := by apply pullback.hom_ext <;> simp\n  -- The `cocycle` field could have been `by tidy` but lean timeouts.\n  cocycle x y z := glued_cover_cocycle 𝒰 x y z\n  f_open _ := inferInstance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCover_f","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nx✝¹ x✝ : 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Cover.gluedCover 𝒰).f x✝¹ x✝) (CategoryTheory.Limits.pullback.fst (𝒰.map x✝¹) (𝒰.map x✝))","decl":"/-- The glue data associated with an open cover.\nThe canonical isomorphism `𝒰.gluedCover.glued ⟶ X` is provided by `𝒰.fromGlued`. -/\n@[simps]\ndef gluedCover : Scheme.GlueData.{u} where\n  J := 𝒰.J\n  U := 𝒰.obj\n  V := fun ⟨x, y⟩ => pullback (𝒰.map x) (𝒰.map y)\n  f _ _ := pullback.fst _ _\n  f_id _ := inferInstance\n  t _ _ := (pullbackSymmetry _ _).hom\n  t_id x := by simp\n  t' x y z := gluedCoverT' 𝒰 x y z\n  t_fac x y z := by apply pullback.hom_ext <;> simp\n  -- The `cocycle` field could have been `by tidy` but lean timeouts.\n  cocycle x y z := glued_cover_cocycle 𝒰 x y z\n  f_open _ := inferInstance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCover_t'","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nx y z : 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Cover.gluedCover 𝒰).t' x y z) (AlgebraicGeometry.Scheme.Cover.gluedCoverT' 𝒰 x y z)","decl":"/-- The glue data associated with an open cover.\nThe canonical isomorphism `𝒰.gluedCover.glued ⟶ X` is provided by `𝒰.fromGlued`. -/\n@[simps]\ndef gluedCover : Scheme.GlueData.{u} where\n  J := 𝒰.J\n  U := 𝒰.obj\n  V := fun ⟨x, y⟩ => pullback (𝒰.map x) (𝒰.map y)\n  f _ _ := pullback.fst _ _\n  f_id _ := inferInstance\n  t _ _ := (pullbackSymmetry _ _).hom\n  t_id x := by simp\n  t' x y z := gluedCoverT' 𝒰 x y z\n  t_fac x y z := by apply pullback.hom_ext <;> simp\n  -- The `cocycle` field could have been `by tidy` but lean timeouts.\n  cocycle x y z := glued_cover_cocycle 𝒰 x y z\n  f_open _ := inferInstance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCover_U","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nj : 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Cover.gluedCover 𝒰).U j) (𝒰.obj j)","decl":"/-- The glue data associated with an open cover.\nThe canonical isomorphism `𝒰.gluedCover.glued ⟶ X` is provided by `𝒰.fromGlued`. -/\n@[simps]\ndef gluedCover : Scheme.GlueData.{u} where\n  J := 𝒰.J\n  U := 𝒰.obj\n  V := fun ⟨x, y⟩ => pullback (𝒰.map x) (𝒰.map y)\n  f _ _ := pullback.fst _ _\n  f_id _ := inferInstance\n  t _ _ := (pullbackSymmetry _ _).hom\n  t_id x := by simp\n  t' x y z := gluedCoverT' 𝒰 x y z\n  t_fac x y z := by apply pullback.hom_ext <;> simp\n  -- The `cocycle` field could have been `by tidy` but lean timeouts.\n  cocycle x y z := glued_cover_cocycle 𝒰 x y z\n  f_open _ := inferInstance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCover_t","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nx✝¹ x✝ : 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Cover.gluedCover 𝒰).t x✝¹ x✝) (CategoryTheory.Limits.pullbackSymmetry (𝒰.map x✝¹) (𝒰.map x✝)).hom","decl":"/-- The glue data associated with an open cover.\nThe canonical isomorphism `𝒰.gluedCover.glued ⟶ X` is provided by `𝒰.fromGlued`. -/\n@[simps]\ndef gluedCover : Scheme.GlueData.{u} where\n  J := 𝒰.J\n  U := 𝒰.obj\n  V := fun ⟨x, y⟩ => pullback (𝒰.map x) (𝒰.map y)\n  f _ _ := pullback.fst _ _\n  f_id _ := inferInstance\n  t _ _ := (pullbackSymmetry _ _).hom\n  t_id x := by simp\n  t' x y z := gluedCoverT' 𝒰 x y z\n  t_fac x y z := by apply pullback.hom_ext <;> simp\n  -- The `cocycle` field could have been `by tidy` but lean timeouts.\n  cocycle x y z := glued_cover_cocycle 𝒰 x y z\n  f_open _ := inferInstance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.ι_fromGlued_assoc","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nx : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Scheme.Cover.gluedCover 𝒰).ι x) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.fromGlued 𝒰) h)) (CategoryTheory.CategoryStruct.comp (𝒰.map x) h)","decl":"@[simp, reassoc]\ntheorem ι_fromGlued (x : 𝒰.J) : 𝒰.gluedCover.ι x ≫ 𝒰.fromGlued = 𝒰.map x :=\n  Multicoequalizer.π_desc _ _ _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.ι_fromGlued","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nx : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Scheme.Cover.gluedCover 𝒰).ι x) (AlgebraicGeometry.Scheme.Cover.fromGlued 𝒰)) (𝒰.map x)","decl":"@[simp, reassoc]\ntheorem ι_fromGlued (x : 𝒰.J) : 𝒰.gluedCover.ι x ≫ 𝒰.fromGlued = 𝒰.map x :=\n  Multicoequalizer.π_desc _ _ _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.fromGlued_injective","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\n⊢ Function.Injective ⇑(AlgebraicGeometry.Scheme.Cover.fromGlued 𝒰).base","decl":"theorem fromGlued_injective : Function.Injective 𝒰.fromGlued.base := by\n  intro x y h\n  obtain ⟨i, x, rfl⟩ := 𝒰.gluedCover.ι_jointly_surjective x\n  obtain ⟨j, y, rfl⟩ := 𝒰.gluedCover.ι_jointly_surjective y\n  rw [← CategoryTheory.comp_apply, ← CategoryTheory.comp_apply] at h\n  simp_rw [← Scheme.comp_base] at h\n  rw [ι_fromGlued, ι_fromGlued] at h\n  let e :=\n    (TopCat.pullbackConeIsLimit _ _).conePointUniqueUpToIso\n      (isLimitOfHasPullbackOfPreservesLimit Scheme.forgetToTop (𝒰.map i) (𝒰.map j))\n  rw [𝒰.gluedCover.ι_eq_iff]\n  use e.hom ⟨⟨x, y⟩, h⟩\n  constructor\n  · erw [← comp_apply e.hom, IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingCospan.left]; rfl\n  · erw [← comp_apply e.hom, pullbackSymmetry_hom_comp_fst,\n      IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingCospan.right]\n    rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.fromGlued_stalk_iso","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nx : ↑↑(AlgebraicGeometry.Scheme.Cover.gluedCover 𝒰).glued.toPresheafedSpace\n⊢ CategoryTheory.IsIso (AlgebraicGeometry.Scheme.Hom.stalkMap (AlgebraicGeometry.Scheme.Cover.fromGlued 𝒰) x)","decl":"instance fromGlued_stalk_iso (x : 𝒰.gluedCover.glued.carrier) :\n    IsIso (𝒰.fromGlued.stalkMap x) := by\n  obtain ⟨i, x, rfl⟩ := 𝒰.gluedCover.ι_jointly_surjective x\n  have := stalkMap_congr_hom _ _ (𝒰.ι_fromGlued i) x\n  rw [stalkMap_comp, ← IsIso.eq_comp_inv] at this\n  rw [this]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.fromGlued_open_map","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\n⊢ IsOpenMap ⇑(AlgebraicGeometry.Scheme.Cover.fromGlued 𝒰).base","decl":"theorem fromGlued_open_map : IsOpenMap 𝒰.fromGlued.base := by\n  intro U hU\n  rw [isOpen_iff_forall_mem_open]\n  intro x hx\n  rw [𝒰.gluedCover.isOpen_iff] at hU\n  use 𝒰.fromGlued.base '' U ∩ Set.range (𝒰.map (𝒰.f x)).base\n  use Set.inter_subset_left\n  constructor\n  · rw [← Set.image_preimage_eq_inter_range]\n    apply (show IsOpenImmersion (𝒰.map (𝒰.f x)) from inferInstance).base_open.isOpenMap\n    convert hU (𝒰.f x) using 1\n    rw [← ι_fromGlued]; erw [coe_comp]; rw [Set.preimage_comp]\n    congr! 1\n    exact Set.preimage_image_eq _ 𝒰.fromGlued_injective\n  · exact ⟨hx, 𝒰.covers x⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.fromGlued_isOpenEmbedding","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\n⊢ Topology.IsOpenEmbedding ⇑(AlgebraicGeometry.Scheme.Cover.fromGlued 𝒰).base","decl":"theorem fromGlued_isOpenEmbedding : IsOpenEmbedding 𝒰.fromGlued.base :=\n  .of_continuous_injective_isOpenMap (by fun_prop) 𝒰.fromGlued_injective 𝒰.fromGlued_open_map\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.fromGlued_openEmbedding","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\n⊢ Topology.IsOpenEmbedding ⇑(AlgebraicGeometry.Scheme.Cover.fromGlued 𝒰).base","decl":"@[deprecated (since := \"2024-10-18\")]\nalias fromGlued_openEmbedding := fromGlued_isOpenEmbedding\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.instEpiTopCatBaseCommRingCatFromGlued","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\n⊢ CategoryTheory.Epi (AlgebraicGeometry.Scheme.Cover.fromGlued 𝒰).base","decl":"instance : Epi 𝒰.fromGlued.base := by\n  rw [TopCat.epi_iff_surjective]\n  intro x\n  obtain ⟨y, h⟩ := 𝒰.covers x\n  use (𝒰.gluedCover.ι (𝒰.f x)).base y\n  rw [← CategoryTheory.comp_apply]\n  rw [← 𝒰.ι_fromGlued (𝒰.f x)] at h\n  exact h\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.fromGlued_open_immersion","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\n⊢ AlgebraicGeometry.IsOpenImmersion (AlgebraicGeometry.Scheme.Cover.fromGlued 𝒰)","decl":"instance fromGlued_open_immersion : IsOpenImmersion 𝒰.fromGlued :=\n  IsOpenImmersion.of_stalk_iso _ 𝒰.fromGlued_isOpenEmbedding\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.instIsIsoFromGlued","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\n⊢ CategoryTheory.IsIso (AlgebraicGeometry.Scheme.Cover.fromGlued 𝒰)","decl":"instance : IsIso 𝒰.fromGlued :=\n  let F := Scheme.forgetToLocallyRingedSpace ⋙ LocallyRingedSpace.forgetToSheafedSpace ⋙\n    SheafedSpace.forgetToPresheafedSpace\n  have : IsIso (F.map (fromGlued 𝒰)) := by\n    change IsIso 𝒰.fromGlued.toPshHom\n    apply PresheafedSpace.IsOpenImmersion.to_iso\n  isIso_of_reflects_iso _ F\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.ι_glueMorphisms_assoc","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nY : AlgebraicGeometry.Scheme\nf : (x : 𝒰.J) → Quiver.Hom (𝒰.obj x) Y\nhf : ∀ (x y : 𝒰.J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map y)) (f x)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (𝒰.map x) (𝒰.map y)) (f y))\nx : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (𝒰.map x) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.glueMorphisms 𝒰 f hf) h)) (CategoryTheory.CategoryStruct.comp (f x) h)","decl":"@[simp, reassoc]\ntheorem ι_glueMorphisms {Y : Scheme} (f : ∀ x, 𝒰.obj x ⟶ Y)\n    (hf : ∀ x y, pullback.fst (𝒰.map x) (𝒰.map y) ≫ f x = pullback.snd _ _ ≫ f y)\n    (x : 𝒰.J) : 𝒰.map x ≫ 𝒰.glueMorphisms f hf = f x := by\n  rw [← ι_fromGlued, Category.assoc]\n  erw [IsIso.hom_inv_id_assoc, Multicoequalizer.π_desc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.ι_glueMorphisms","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nY : AlgebraicGeometry.Scheme\nf : (x : 𝒰.J) → Quiver.Hom (𝒰.obj x) Y\nhf : ∀ (x y : 𝒰.J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map y)) (f x)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (𝒰.map x) (𝒰.map y)) (f y))\nx : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (𝒰.map x) (AlgebraicGeometry.Scheme.Cover.glueMorphisms 𝒰 f hf)) (f x)","decl":"@[simp, reassoc]\ntheorem ι_glueMorphisms {Y : Scheme} (f : ∀ x, 𝒰.obj x ⟶ Y)\n    (hf : ∀ x y, pullback.fst (𝒰.map x) (𝒰.map y) ≫ f x = pullback.snd _ _ ≫ f y)\n    (x : 𝒰.J) : 𝒰.map x ≫ 𝒰.glueMorphisms f hf = f x := by\n  rw [← ι_fromGlued, Category.assoc]\n  erw [IsIso.hom_inv_id_assoc, Multicoequalizer.π_desc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.hom_ext","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nY : AlgebraicGeometry.Scheme\nf₁ f₂ : Quiver.Hom X Y\nh : ∀ (x : 𝒰.J), Eq (CategoryTheory.CategoryStruct.comp (𝒰.map x) f₁) (CategoryTheory.CategoryStruct.comp (𝒰.map x) f₂)\n⊢ Eq f₁ f₂","decl":"theorem hom_ext {Y : Scheme} (f₁ f₂ : X ⟶ Y) (h : ∀ x, 𝒰.map x ≫ f₁ = 𝒰.map x ≫ f₂) : f₁ = f₂ := by\n  rw [← cancel_epi 𝒰.fromGlued]\n  apply Multicoequalizer.hom_ext\n  intro x\n  erw [Multicoequalizer.π_desc_assoc]\n  erw [Multicoequalizer.π_desc_assoc]\n  exact h x\n\n"}
