{"name":"AlgebraicGeometry.Scheme.GlueData.mk.injEq","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"toGlueDataâœ : CategoryTheory.GlueData AlgebraicGeometry.Scheme\nf_openâœ : âˆ€ (i j : toGlueDataâœ.J), AlgebraicGeometry.IsOpenImmersion (toGlueDataâœ.f i j)\ntoGlueData : CategoryTheory.GlueData AlgebraicGeometry.Scheme\nf_open : âˆ€ (i j : toGlueData.J), AlgebraicGeometry.IsOpenImmersion (toGlueData.f i j)\nâŠ¢ Eq (Eq { toGlueData := toGlueDataâœ, f_open := f_openâœ } { toGlueData := toGlueData, f_open := f_open }) (Eq toGlueDataâœ toGlueData)","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A scheme `U i` for each `i : J`.\n3. A scheme `V i j` for each `i j : J`.\n  (Note that this is `J Ã— J â†’ Scheme` rather than `J â†’ J â†’ Scheme` to connect to the\n  limits library easier.)\n4. An open immersion `f i j : V i j âŸ¶ U i` for each `i j : Î¹`.\n5. A transition map `t i j : V i j âŸ¶ V j i` for each `i j : Î¹`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j Ã—[U i] V i k âŸ¶ V i j âŸ¶ V j i` factors through `V j k Ã—[U j] V j i âŸ¶ V j i` via some\n    `t' : V i j Ã—[U i] V i k âŸ¶ V j k Ã—[U j] V j i`.\n9. `t' i j k â‰« t' j k i â‰« t' k i j = ğŸ™ _`.\n\nWe can then glue the schemes `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subschemes of the glued space.\n-/\nstructure GlueData extends CategoryTheory.GlueData Scheme where\n  f_open : âˆ€ i j, IsOpenImmersion (f i j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.mk.inj","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"toGlueDataâœ : CategoryTheory.GlueData AlgebraicGeometry.Scheme\nf_openâœ : âˆ€ (i j : toGlueDataâœ.J), AlgebraicGeometry.IsOpenImmersion (toGlueDataâœ.f i j)\ntoGlueData : CategoryTheory.GlueData AlgebraicGeometry.Scheme\nf_open : âˆ€ (i j : toGlueData.J), AlgebraicGeometry.IsOpenImmersion (toGlueData.f i j)\nxâœ : Eq { toGlueData := toGlueDataâœ, f_open := f_openâœ } { toGlueData := toGlueData, f_open := f_open }\nâŠ¢ Eq toGlueDataâœ toGlueData","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A scheme `U i` for each `i : J`.\n3. A scheme `V i j` for each `i j : J`.\n  (Note that this is `J Ã— J â†’ Scheme` rather than `J â†’ J â†’ Scheme` to connect to the\n  limits library easier.)\n4. An open immersion `f i j : V i j âŸ¶ U i` for each `i j : Î¹`.\n5. A transition map `t i j : V i j âŸ¶ V j i` for each `i j : Î¹`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j Ã—[U i] V i k âŸ¶ V i j âŸ¶ V j i` factors through `V j k Ã—[U j] V j i âŸ¶ V j i` via some\n    `t' : V i j Ã—[U i] V i k âŸ¶ V j k Ã—[U j] V j i`.\n9. `t' i j k â‰« t' j k i â‰« t' k i j = ğŸ™ _`.\n\nWe can then glue the schemes `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subschemes of the glued space.\n-/\nstructure GlueData extends CategoryTheory.GlueData Scheme where\n  f_open : âˆ€ i j, IsOpenImmersion (f i j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.mk.sizeOf_spec","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"toGlueData : CategoryTheory.GlueData AlgebraicGeometry.Scheme\nf_open : âˆ€ (i j : toGlueData.J), AlgebraicGeometry.IsOpenImmersion (toGlueData.f i j)\nâŠ¢ Eq (SizeOf.sizeOf { toGlueData := toGlueData, f_open := f_open }) (HAdd.hAdd 1 (SizeOf.sizeOf toGlueData))","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A scheme `U i` for each `i : J`.\n3. A scheme `V i j` for each `i j : J`.\n  (Note that this is `J Ã— J â†’ Scheme` rather than `J â†’ J â†’ Scheme` to connect to the\n  limits library easier.)\n4. An open immersion `f i j : V i j âŸ¶ U i` for each `i j : Î¹`.\n5. A transition map `t i j : V i j âŸ¶ V j i` for each `i j : Î¹`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j Ã—[U i] V i k âŸ¶ V i j âŸ¶ V j i` factors through `V j k Ã—[U j] V j i âŸ¶ V j i` via some\n    `t' : V i j Ã—[U i] V i k âŸ¶ V j k Ã—[U j] V j i`.\n9. `t' i j k â‰« t' j k i â‰« t' k i j = ğŸ™ _`.\n\nWe can then glue the schemes `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subschemes of the glued space.\n-/\nstructure GlueData extends CategoryTheory.GlueData Scheme where\n  f_open : âˆ€ i j, IsOpenImmersion (f i j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.f_open","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"self : AlgebraicGeometry.Scheme.GlueData\ni j : self.J\nâŠ¢ AlgebraicGeometry.IsOpenImmersion (self.f i j)","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A scheme `U i` for each `i : J`.\n3. A scheme `V i j` for each `i j : J`.\n  (Note that this is `J Ã— J â†’ Scheme` rather than `J â†’ J â†’ Scheme` to connect to the\n  limits library easier.)\n4. An open immersion `f i j : V i j âŸ¶ U i` for each `i j : Î¹`.\n5. A transition map `t i j : V i j âŸ¶ V j i` for each `i j : Î¹`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j Ã—[U i] V i k âŸ¶ V i j âŸ¶ V j i` factors through `V j k Ã—[U j] V j i âŸ¶ V j i` via some\n    `t' : V i j Ã—[U i] V i k âŸ¶ V j k Ã—[U j] V j i`.\n9. `t' i j k â‰« t' j k i â‰« t' k i j = ğŸ™ _`.\n\nWe can then glue the schemes `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subschemes of the glued space.\n-/\nstructure GlueData extends CategoryTheory.GlueData Scheme where\n  f_open : âˆ€ i j, IsOpenImmersion (f i j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.instIsOpenImmersionFLocallyRingedSpaceToLocallyRingedSpaceGlueData","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni j : D.J\nâŠ¢ AlgebraicGeometry.LocallyRingedSpace.IsOpenImmersion (D.toLocallyRingedSpaceGlueData.f i j)","decl":"instance (i j : ğ–£.J) :\n    LocallyRingedSpace.IsOpenImmersion ((D.toLocallyRingedSpaceGlueData).toGlueData.f i j) := by\n  apply GlueData.f_open\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.instIsOpenImmersionCommRingCatFSheafedSpaceToSheafedSpaceGlueDataToLocallyRingedSpaceGlueData","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni j : D.J\nâŠ¢ AlgebraicGeometry.SheafedSpace.IsOpenImmersion (D.toLocallyRingedSpaceGlueData.toSheafedSpaceGlueData.f i j)","decl":"instance (i j : ğ–£.J) :\n    SheafedSpace.IsOpenImmersion\n      (D.toLocallyRingedSpaceGlueData.toSheafedSpaceGlueData.toGlueData.f i j) := by\n  apply GlueData.f_open\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.instIsOpenImmersionCommRingCatFPresheafedSpaceToPresheafedSpaceGlueDataToSheafedSpaceGlueDataToLocallyRingedSpaceGlueData","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni j : D.J\nâŠ¢ AlgebraicGeometry.PresheafedSpace.IsOpenImmersion (D.toLocallyRingedSpaceGlueData.toSheafedSpaceGlueData.toPresheafedSpaceGlueData.f i j)","decl":"instance (i j : ğ–£.J) :\n    PresheafedSpace.IsOpenImmersion\n      (D.toLocallyRingedSpaceGlueData.toSheafedSpaceGlueData.toPresheafedSpaceGlueData.toGlueData.f\n        i j) := by\n  apply GlueData.f_open\n\n-- Porting note: this was not needed.\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.instIsOpenImmersionÎ¹LocallyRingedSpaceToLocallyRingedSpaceGlueData","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni : D.J\nâŠ¢ AlgebraicGeometry.LocallyRingedSpace.IsOpenImmersion (D.toLocallyRingedSpaceGlueData.Î¹ i)","decl":"instance (i : ğ–£.J) :\n    LocallyRingedSpace.IsOpenImmersion ((D.toLocallyRingedSpaceGlueData).toGlueData.Î¹ i) := by\n  apply LocallyRingedSpace.GlueData.Î¹_isOpenImmersion\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.instPreservesColimitTopCatWalkingMultispanLDiagramRFstFromSndFromMultispanForgetToTop","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\nâŠ¢ CategoryTheory.Limits.PreservesColimit D.diagram.multispan AlgebraicGeometry.Scheme.forgetToTop","decl":"instance : PreservesColimit (ğ–£.diagram.multispan) forgetToTop :=\n  inferInstanceAs (PreservesColimit (ğ–£.diagram).multispan (forgetToLocallyRingedSpace â‹™\n      LocallyRingedSpace.forgetToSheafedSpace â‹™ SheafedSpace.forget CommRingCat))\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.instHasMulticoequalizerDiagram","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\nâŠ¢ CategoryTheory.Limits.HasMulticoequalizer D.diagram","decl":"instance : HasMulticoequalizer ğ–£.diagram :=\n  hasColimit_of_created _ forgetToLocallyRingedSpace\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.Î¹_isoLocallyRingedSpace_inv","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni : D.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (D.toLocallyRingedSpaceGlueData.Î¹ i) D.isoLocallyRingedSpace.inv) (AlgebraicGeometry.Scheme.Hom.toLRSHom (D.Î¹ i))","decl":"theorem Î¹_isoLocallyRingedSpace_inv (i : D.J) :\n    D.toLocallyRingedSpaceGlueData.toGlueData.Î¹ i â‰«\n      D.isoLocallyRingedSpace.inv = (ğ–£.Î¹ i).toLRSHom :=\n  ğ–£.Î¹_gluedIso_inv forgetToLocallyRingedSpace i\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.Î¹_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni : D.J\nâŠ¢ AlgebraicGeometry.IsOpenImmersion (D.Î¹ i)","decl":"instance Î¹_isOpenImmersion (i : D.J) : IsOpenImmersion (ğ–£.Î¹ i) := by\n  rw [IsOpenImmersion, â† D.Î¹_isoLocallyRingedSpace_inv]; infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.Î¹_jointly_surjective","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\nx : â†‘â†‘D.glued.toPresheafedSpace\nâŠ¢ Exists fun i => Exists fun y => Eq ((D.Î¹ i).base y) x","decl":"theorem Î¹_jointly_surjective (x : ğ–£.glued.carrier) :\n    âˆƒ (i : D.J) (y : (D.U i).carrier), (D.Î¹ i).base y = x :=\n  ğ–£.Î¹_jointly_surjective (forgetToTop â‹™ forget TopCat) x\n\n-- Porting note: promote to higher priority to short circuit simplifier\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.glue_condition","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni j : D.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (D.t i j) (CategoryTheory.CategoryStruct.comp (D.f j i) (D.Î¹ j))) (CategoryTheory.CategoryStruct.comp (D.f i j) (D.Î¹ i))","decl":"@[simp (high), reassoc]\ntheorem glue_condition (i j : D.J) : D.t i j â‰« D.f j i â‰« D.Î¹ j = D.f i j â‰« D.Î¹ i :=\n  ğ–£.glue_condition i j\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.glue_condition_assoc","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni j : D.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom D.glued Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (D.t i j) (CategoryTheory.CategoryStruct.comp (D.f j i) (CategoryTheory.CategoryStruct.comp (D.Î¹ j) h))) (CategoryTheory.CategoryStruct.comp (D.f i j) (CategoryTheory.CategoryStruct.comp (D.Î¹ i) h))","decl":"@[simp (high), reassoc]\ntheorem glue_condition (i j : D.J) : D.t i j â‰« D.f j i â‰« D.Î¹ j = D.f i j â‰« D.Î¹ i :=\n  ğ–£.glue_condition i j\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.Î¹_isoCarrier_inv","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni : D.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (D.toLocallyRingedSpaceGlueData.toSheafedSpaceGlueData.toPresheafedSpaceGlueData.toTopGlueData.Î¹ i) D.isoCarrier.inv) (D.Î¹ i).base","decl":"@[simp]\ntheorem Î¹_isoCarrier_inv (i : D.J) :\n    (D_).Î¹ i â‰« D.isoCarrier.inv = (D.Î¹ i).base := by\n  delta isoCarrier\n  rw [Iso.trans_inv, GlueData.Î¹_gluedIso_inv_assoc, Functor.mapIso_inv, Iso.trans_inv,\n    Functor.mapIso_inv, Iso.trans_inv, SheafedSpace.forgetToPresheafedSpace_map, forget_map,\n    forget_map, â† PresheafedSpace.comp_base, â† Category.assoc,\n    D.toLocallyRingedSpaceGlueData.toSheafedSpaceGlueData.Î¹_isoPresheafedSpace_inv i]\n  erw [â† Category.assoc, D.toLocallyRingedSpaceGlueData.Î¹_isoSheafedSpace_inv i]\n  change (_ â‰« D.isoLocallyRingedSpace.inv).base = _\n  rw [D.Î¹_isoLocallyRingedSpace_inv i]\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.Î¹_eq_iff","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni j : D.J\nx : â†‘â†‘(D.U i).toPresheafedSpace\ny : â†‘â†‘(D.U j).toPresheafedSpace\nâŠ¢ Iff (Eq ((D.Î¹ i).base x) ((D.Î¹ j).base y)) (D.Rel âŸ¨i, xâŸ© âŸ¨j, yâŸ©)","decl":"theorem Î¹_eq_iff (i j : D.J) (x : (D.U i).carrier) (y : (D.U j).carrier) :\n    (ğ–£.Î¹ i).base x = (ğ–£.Î¹ j).base y â†” D.Rel âŸ¨i, xâŸ© âŸ¨j, yâŸ© := by\n  refine Iff.trans ?_\n    (TopCat.GlueData.Î¹_eq_iff_rel\n      D.toLocallyRingedSpaceGlueData.toSheafedSpaceGlueData.toPresheafedSpaceGlueData.toTopGlueData\n      i j x y)\n  rw [â† ((TopCat.mono_iff_injective D.isoCarrier.inv).mp _).eq_iff, â† CategoryTheory.comp_apply]\n  Â· simp_rw [â† D.Î¹_isoCarrier_inv]\n    rfl -- `rfl` was not needed before https://github.com/leanprover-community/mathlib4/pull/13170\n  Â· infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.isOpen_iff","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\nU : Set â†‘â†‘D.glued.toPresheafedSpace\nâŠ¢ Iff (IsOpen U) (âˆ€ (i : D.J), IsOpen (Set.preimage (â‡‘(D.Î¹ i).base) U))","decl":"theorem isOpen_iff (U : Set D.glued.carrier) : IsOpen U â†” âˆ€ i, IsOpen ((D.Î¹ i).base â»Â¹' U) := by\n  rw [â† (TopCat.homeoOfIso D.isoCarrier.symm).isOpen_preimage, TopCat.GlueData.isOpen_iff]\n  apply forall_congr'\n  intro i\n  rw [â† Set.preimage_comp, â† Î¹_isoCarrier_inv]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.openCover_J","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\nâŠ¢ Eq D.openCover.J D.J","decl":"/-- The open cover of the glued space given by the glue data. -/\n@[simps (config := .lemmasOnly)]\ndef openCover (D : Scheme.GlueData) : OpenCover D.glued where\n  J := D.J\n  obj := D.U\n  map := D.Î¹\n  f x := (D.Î¹_jointly_surjective x).choose\n  covers x := âŸ¨_, (D.Î¹_jointly_surjective x).choose_spec.choose_specâŸ©\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.openCover_map","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni : D.J\nâŠ¢ Eq (D.openCover.map i) (D.Î¹ i)","decl":"/-- The open cover of the glued space given by the glue data. -/\n@[simps (config := .lemmasOnly)]\ndef openCover (D : Scheme.GlueData) : OpenCover D.glued where\n  J := D.J\n  obj := D.U\n  map := D.Î¹\n  f x := (D.Î¹_jointly_surjective x).choose\n  covers x := âŸ¨_, (D.Î¹_jointly_surjective x).choose_spec.choose_specâŸ©\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.openCover_f","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\nx : â†‘â†‘D.glued.toPresheafedSpace\nâŠ¢ Eq (D.openCover.f x) â‹¯.choose","decl":"/-- The open cover of the glued space given by the glue data. -/\n@[simps (config := .lemmasOnly)]\ndef openCover (D : Scheme.GlueData) : OpenCover D.glued where\n  J := D.J\n  obj := D.U\n  map := D.Î¹\n  f x := (D.Î¹_jointly_surjective x).choose\n  covers x := âŸ¨_, (D.Î¹_jointly_surjective x).choose_spec.choose_specâŸ©\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.openCover_obj","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\naâœ : D.J\nâŠ¢ Eq (D.openCover.obj aâœ) (D.U aâœ)","decl":"/-- The open cover of the glued space given by the glue data. -/\n@[simps (config := .lemmasOnly)]\ndef openCover (D : Scheme.GlueData) : OpenCover D.glued where\n  J := D.J\n  obj := D.U\n  map := D.Î¹\n  f x := (D.Î¹_jointly_surjective x).choose\n  covers x := âŸ¨_, (D.Î¹_jointly_surjective x).choose_spec.choose_specâŸ©\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCoverT'_fst_fst","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nx y z : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' ğ’° x y z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (ğ’°.map y) (ğ’°.map z)) (CategoryTheory.Limits.pullback.fst (ğ’°.map y) (ğ’°.map x))) (CategoryTheory.Limits.pullback.fst (ğ’°.map y) (ğ’°.map z)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map y)) (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map z))) (CategoryTheory.Limits.pullback.snd (ğ’°.map x) (ğ’°.map y)))","decl":"@[simp, reassoc]\ntheorem gluedCoverT'_fst_fst (x y z : ğ’°.J) :\n    ğ’°.gluedCoverT' x y z â‰« pullback.fst _ _ â‰« pullback.fst _ _ =\n      pullback.fst _ _ â‰« pullback.snd _ _ := by\n  delta gluedCoverT'; simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCoverT'_fst_fst_assoc","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nx y z : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (ğ’°.obj y) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' ğ’° x y z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (ğ’°.map y) (ğ’°.map z)) (CategoryTheory.Limits.pullback.fst (ğ’°.map y) (ğ’°.map x))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (ğ’°.map y) (ğ’°.map z)) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map y)) (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map z))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (ğ’°.map x) (ğ’°.map y)) h))","decl":"@[simp, reassoc]\ntheorem gluedCoverT'_fst_fst (x y z : ğ’°.J) :\n    ğ’°.gluedCoverT' x y z â‰« pullback.fst _ _ â‰« pullback.fst _ _ =\n      pullback.fst _ _ â‰« pullback.snd _ _ := by\n  delta gluedCoverT'; simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCoverT'_fst_snd","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nx y z : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' ğ’° x y z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (ğ’°.map y) (ğ’°.map z)) (CategoryTheory.Limits.pullback.fst (ğ’°.map y) (ğ’°.map x))) (CategoryTheory.Limits.pullback.snd (ğ’°.map y) (ğ’°.map z)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map y)) (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map z))) (CategoryTheory.Limits.pullback.snd (ğ’°.map x) (ğ’°.map z)))","decl":"@[simp, reassoc]\ntheorem gluedCoverT'_fst_snd (x y z : ğ’°.J) :\n    gluedCoverT' ğ’° x y z â‰« pullback.fst _ _ â‰« pullback.snd _ _ =\n      pullback.snd _ _ â‰« pullback.snd _ _ := by\n  delta gluedCoverT'; simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCoverT'_fst_snd_assoc","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nx y z : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (ğ’°.obj z) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' ğ’° x y z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (ğ’°.map y) (ğ’°.map z)) (CategoryTheory.Limits.pullback.fst (ğ’°.map y) (ğ’°.map x))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (ğ’°.map y) (ğ’°.map z)) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map y)) (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map z))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (ğ’°.map x) (ğ’°.map z)) h))","decl":"@[simp, reassoc]\ntheorem gluedCoverT'_fst_snd (x y z : ğ’°.J) :\n    gluedCoverT' ğ’° x y z â‰« pullback.fst _ _ â‰« pullback.snd _ _ =\n      pullback.snd _ _ â‰« pullback.snd _ _ := by\n  delta gluedCoverT'; simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCoverT'_snd_fst_assoc","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nx y z : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (ğ’°.obj y) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' ğ’° x y z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (ğ’°.map y) (ğ’°.map z)) (CategoryTheory.Limits.pullback.fst (ğ’°.map y) (ğ’°.map x))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (ğ’°.map y) (ğ’°.map x)) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map y)) (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map z))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (ğ’°.map x) (ğ’°.map y)) h))","decl":"@[simp, reassoc]\ntheorem gluedCoverT'_snd_fst (x y z : ğ’°.J) :\n    gluedCoverT' ğ’° x y z â‰« pullback.snd _ _ â‰« pullback.fst _ _ =\n      pullback.fst _ _ â‰« pullback.snd _ _ := by\n  delta gluedCoverT'; simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCoverT'_snd_fst","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nx y z : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' ğ’° x y z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (ğ’°.map y) (ğ’°.map z)) (CategoryTheory.Limits.pullback.fst (ğ’°.map y) (ğ’°.map x))) (CategoryTheory.Limits.pullback.fst (ğ’°.map y) (ğ’°.map x)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map y)) (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map z))) (CategoryTheory.Limits.pullback.snd (ğ’°.map x) (ğ’°.map y)))","decl":"@[simp, reassoc]\ntheorem gluedCoverT'_snd_fst (x y z : ğ’°.J) :\n    gluedCoverT' ğ’° x y z â‰« pullback.snd _ _ â‰« pullback.fst _ _ =\n      pullback.fst _ _ â‰« pullback.snd _ _ := by\n  delta gluedCoverT'; simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCoverT'_snd_snd_assoc","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nx y z : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (ğ’°.obj x) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' ğ’° x y z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (ğ’°.map y) (ğ’°.map z)) (CategoryTheory.Limits.pullback.fst (ğ’°.map y) (ğ’°.map x))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (ğ’°.map y) (ğ’°.map x)) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map y)) (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map z))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map y)) h))","decl":"@[simp, reassoc]\ntheorem gluedCoverT'_snd_snd (x y z : ğ’°.J) :\n    gluedCoverT' ğ’° x y z â‰« pullback.snd _ _ â‰« pullback.snd _ _ =\n      pullback.fst _ _ â‰« pullback.fst _ _ := by\n  delta gluedCoverT'; simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCoverT'_snd_snd","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nx y z : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' ğ’° x y z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (ğ’°.map y) (ğ’°.map z)) (CategoryTheory.Limits.pullback.fst (ğ’°.map y) (ğ’°.map x))) (CategoryTheory.Limits.pullback.snd (ğ’°.map y) (ğ’°.map x)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map y)) (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map z))) (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map y)))","decl":"@[simp, reassoc]\ntheorem gluedCoverT'_snd_snd (x y z : ğ’°.J) :\n    gluedCoverT' ğ’° x y z â‰« pullback.snd _ _ â‰« pullback.snd _ _ =\n      pullback.fst _ _ â‰« pullback.fst _ _ := by\n  delta gluedCoverT'; simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.glued_cover_cocycle_fst","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nx y z : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' ğ’° x y z) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' ğ’° y z x) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' ğ’° z x y) (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map y)) (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map z)))))) (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map y)) (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map z)))","decl":"theorem glued_cover_cocycle_fst (x y z : ğ’°.J) :\n    gluedCoverT' ğ’° x y z â‰« gluedCoverT' ğ’° y z x â‰« gluedCoverT' ğ’° z x y â‰« pullback.fst _ _ =\n      pullback.fst _ _ := by\n  apply pullback.hom_ext <;> simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.glued_cover_cocycle_snd","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nx y z : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' ğ’° x y z) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' ğ’° y z x) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' ğ’° z x y) (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map y)) (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map z)))))) (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map y)) (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map z)))","decl":"theorem glued_cover_cocycle_snd (x y z : ğ’°.J) :\n    gluedCoverT' ğ’° x y z â‰« gluedCoverT' ğ’° y z x â‰« gluedCoverT' ğ’° z x y â‰« pullback.snd _ _ =\n      pullback.snd _ _ := by\n  apply pullback.hom_ext <;> simp [pullback.condition]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.glued_cover_cocycle","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nx y z : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' ğ’° x y z) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.gluedCoverT' ğ’° y z x) (AlgebraicGeometry.Scheme.Cover.gluedCoverT' ğ’° z x y))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map y)) (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map z))))","decl":"theorem glued_cover_cocycle (x y z : ğ’°.J) :\n    gluedCoverT' ğ’° x y z â‰« gluedCoverT' ğ’° y z x â‰« gluedCoverT' ğ’° z x y = ğŸ™ _ := by\n  apply pullback.hom_ext <;> simp_rw [Category.id_comp, Category.assoc]\n  Â· apply glued_cover_cocycle_fst\n  Â· apply glued_cover_cocycle_snd\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCover_V","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nxâœ : Prod ğ’°.J ğ’°.J\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.Cover.gluedCover ğ’°).V xâœ) (AlgebraicGeometry.Scheme.Cover.gluedCover.match_1 ğ’° (fun x => AlgebraicGeometry.Scheme) xâœ fun x y => CategoryTheory.Limits.pullback (ğ’°.map x) (ğ’°.map y))","decl":"/-- The glue data associated with an open cover.\nThe canonical isomorphism `ğ’°.gluedCover.glued âŸ¶ X` is provided by `ğ’°.fromGlued`. -/\n@[simps]\ndef gluedCover : Scheme.GlueData.{u} where\n  J := ğ’°.J\n  U := ğ’°.obj\n  V := fun âŸ¨x, yâŸ© => pullback (ğ’°.map x) (ğ’°.map y)\n  f _ _ := pullback.fst _ _\n  f_id _ := inferInstance\n  t _ _ := (pullbackSymmetry _ _).hom\n  t_id x := by simp\n  t' x y z := gluedCoverT' ğ’° x y z\n  t_fac x y z := by apply pullback.hom_ext <;> simp\n  -- The `cocycle` field could have been `by tidy` but lean timeouts.\n  cocycle x y z := glued_cover_cocycle ğ’° x y z\n  f_open _ := inferInstance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCover_J","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nâŠ¢ Eq (AlgebraicGeometry.Scheme.Cover.gluedCover ğ’°).J ğ’°.J","decl":"/-- The glue data associated with an open cover.\nThe canonical isomorphism `ğ’°.gluedCover.glued âŸ¶ X` is provided by `ğ’°.fromGlued`. -/\n@[simps]\ndef gluedCover : Scheme.GlueData.{u} where\n  J := ğ’°.J\n  U := ğ’°.obj\n  V := fun âŸ¨x, yâŸ© => pullback (ğ’°.map x) (ğ’°.map y)\n  f _ _ := pullback.fst _ _\n  f_id _ := inferInstance\n  t _ _ := (pullbackSymmetry _ _).hom\n  t_id x := by simp\n  t' x y z := gluedCoverT' ğ’° x y z\n  t_fac x y z := by apply pullback.hom_ext <;> simp\n  -- The `cocycle` field could have been `by tidy` but lean timeouts.\n  cocycle x y z := glued_cover_cocycle ğ’° x y z\n  f_open _ := inferInstance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCover_f","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nxâœÂ¹ xâœ : ğ’°.J\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.Cover.gluedCover ğ’°).f xâœÂ¹ xâœ) (CategoryTheory.Limits.pullback.fst (ğ’°.map xâœÂ¹) (ğ’°.map xâœ))","decl":"/-- The glue data associated with an open cover.\nThe canonical isomorphism `ğ’°.gluedCover.glued âŸ¶ X` is provided by `ğ’°.fromGlued`. -/\n@[simps]\ndef gluedCover : Scheme.GlueData.{u} where\n  J := ğ’°.J\n  U := ğ’°.obj\n  V := fun âŸ¨x, yâŸ© => pullback (ğ’°.map x) (ğ’°.map y)\n  f _ _ := pullback.fst _ _\n  f_id _ := inferInstance\n  t _ _ := (pullbackSymmetry _ _).hom\n  t_id x := by simp\n  t' x y z := gluedCoverT' ğ’° x y z\n  t_fac x y z := by apply pullback.hom_ext <;> simp\n  -- The `cocycle` field could have been `by tidy` but lean timeouts.\n  cocycle x y z := glued_cover_cocycle ğ’° x y z\n  f_open _ := inferInstance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCover_t'","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nx y z : ğ’°.J\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.Cover.gluedCover ğ’°).t' x y z) (AlgebraicGeometry.Scheme.Cover.gluedCoverT' ğ’° x y z)","decl":"/-- The glue data associated with an open cover.\nThe canonical isomorphism `ğ’°.gluedCover.glued âŸ¶ X` is provided by `ğ’°.fromGlued`. -/\n@[simps]\ndef gluedCover : Scheme.GlueData.{u} where\n  J := ğ’°.J\n  U := ğ’°.obj\n  V := fun âŸ¨x, yâŸ© => pullback (ğ’°.map x) (ğ’°.map y)\n  f _ _ := pullback.fst _ _\n  f_id _ := inferInstance\n  t _ _ := (pullbackSymmetry _ _).hom\n  t_id x := by simp\n  t' x y z := gluedCoverT' ğ’° x y z\n  t_fac x y z := by apply pullback.hom_ext <;> simp\n  -- The `cocycle` field could have been `by tidy` but lean timeouts.\n  cocycle x y z := glued_cover_cocycle ğ’° x y z\n  f_open _ := inferInstance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCover_U","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nj : ğ’°.J\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.Cover.gluedCover ğ’°).U j) (ğ’°.obj j)","decl":"/-- The glue data associated with an open cover.\nThe canonical isomorphism `ğ’°.gluedCover.glued âŸ¶ X` is provided by `ğ’°.fromGlued`. -/\n@[simps]\ndef gluedCover : Scheme.GlueData.{u} where\n  J := ğ’°.J\n  U := ğ’°.obj\n  V := fun âŸ¨x, yâŸ© => pullback (ğ’°.map x) (ğ’°.map y)\n  f _ _ := pullback.fst _ _\n  f_id _ := inferInstance\n  t _ _ := (pullbackSymmetry _ _).hom\n  t_id x := by simp\n  t' x y z := gluedCoverT' ğ’° x y z\n  t_fac x y z := by apply pullback.hom_ext <;> simp\n  -- The `cocycle` field could have been `by tidy` but lean timeouts.\n  cocycle x y z := glued_cover_cocycle ğ’° x y z\n  f_open _ := inferInstance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.gluedCover_t","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nxâœÂ¹ xâœ : ğ’°.J\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.Cover.gluedCover ğ’°).t xâœÂ¹ xâœ) (CategoryTheory.Limits.pullbackSymmetry (ğ’°.map xâœÂ¹) (ğ’°.map xâœ)).hom","decl":"/-- The glue data associated with an open cover.\nThe canonical isomorphism `ğ’°.gluedCover.glued âŸ¶ X` is provided by `ğ’°.fromGlued`. -/\n@[simps]\ndef gluedCover : Scheme.GlueData.{u} where\n  J := ğ’°.J\n  U := ğ’°.obj\n  V := fun âŸ¨x, yâŸ© => pullback (ğ’°.map x) (ğ’°.map y)\n  f _ _ := pullback.fst _ _\n  f_id _ := inferInstance\n  t _ _ := (pullbackSymmetry _ _).hom\n  t_id x := by simp\n  t' x y z := gluedCoverT' ğ’° x y z\n  t_fac x y z := by apply pullback.hom_ext <;> simp\n  -- The `cocycle` field could have been `by tidy` but lean timeouts.\n  cocycle x y z := glued_cover_cocycle ğ’° x y z\n  f_open _ := inferInstance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.Î¹_fromGlued_assoc","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nx : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Scheme.Cover.gluedCover ğ’°).Î¹ x) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.fromGlued ğ’°) h)) (CategoryTheory.CategoryStruct.comp (ğ’°.map x) h)","decl":"@[simp, reassoc]\ntheorem Î¹_fromGlued (x : ğ’°.J) : ğ’°.gluedCover.Î¹ x â‰« ğ’°.fromGlued = ğ’°.map x :=\n  Multicoequalizer.Ï€_desc _ _ _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.Î¹_fromGlued","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nx : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Scheme.Cover.gluedCover ğ’°).Î¹ x) (AlgebraicGeometry.Scheme.Cover.fromGlued ğ’°)) (ğ’°.map x)","decl":"@[simp, reassoc]\ntheorem Î¹_fromGlued (x : ğ’°.J) : ğ’°.gluedCover.Î¹ x â‰« ğ’°.fromGlued = ğ’°.map x :=\n  Multicoequalizer.Ï€_desc _ _ _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.fromGlued_injective","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nâŠ¢ Function.Injective â‡‘(AlgebraicGeometry.Scheme.Cover.fromGlued ğ’°).base","decl":"theorem fromGlued_injective : Function.Injective ğ’°.fromGlued.base := by\n  intro x y h\n  obtain âŸ¨i, x, rflâŸ© := ğ’°.gluedCover.Î¹_jointly_surjective x\n  obtain âŸ¨j, y, rflâŸ© := ğ’°.gluedCover.Î¹_jointly_surjective y\n  rw [â† CategoryTheory.comp_apply, â† CategoryTheory.comp_apply] at h\n  simp_rw [â† Scheme.comp_base] at h\n  rw [Î¹_fromGlued, Î¹_fromGlued] at h\n  let e :=\n    (TopCat.pullbackConeIsLimit _ _).conePointUniqueUpToIso\n      (isLimitOfHasPullbackOfPreservesLimit Scheme.forgetToTop (ğ’°.map i) (ğ’°.map j))\n  rw [ğ’°.gluedCover.Î¹_eq_iff]\n  use e.hom âŸ¨âŸ¨x, yâŸ©, hâŸ©\n  constructor\n  Â· erw [â† comp_apply e.hom, IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingCospan.left]; rfl\n  Â· erw [â† comp_apply e.hom, pullbackSymmetry_hom_comp_fst,\n      IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingCospan.right]\n    rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.fromGlued_stalk_iso","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nx : â†‘â†‘(AlgebraicGeometry.Scheme.Cover.gluedCover ğ’°).glued.toPresheafedSpace\nâŠ¢ CategoryTheory.IsIso (AlgebraicGeometry.Scheme.Hom.stalkMap (AlgebraicGeometry.Scheme.Cover.fromGlued ğ’°) x)","decl":"instance fromGlued_stalk_iso (x : ğ’°.gluedCover.glued.carrier) :\n    IsIso (ğ’°.fromGlued.stalkMap x) := by\n  obtain âŸ¨i, x, rflâŸ© := ğ’°.gluedCover.Î¹_jointly_surjective x\n  have := stalkMap_congr_hom _ _ (ğ’°.Î¹_fromGlued i) x\n  rw [stalkMap_comp, â† IsIso.eq_comp_inv] at this\n  rw [this]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.fromGlued_open_map","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nâŠ¢ IsOpenMap â‡‘(AlgebraicGeometry.Scheme.Cover.fromGlued ğ’°).base","decl":"theorem fromGlued_open_map : IsOpenMap ğ’°.fromGlued.base := by\n  intro U hU\n  rw [isOpen_iff_forall_mem_open]\n  intro x hx\n  rw [ğ’°.gluedCover.isOpen_iff] at hU\n  use ğ’°.fromGlued.base '' U âˆ© Set.range (ğ’°.map (ğ’°.f x)).base\n  use Set.inter_subset_left\n  constructor\n  Â· rw [â† Set.image_preimage_eq_inter_range]\n    apply (show IsOpenImmersion (ğ’°.map (ğ’°.f x)) from inferInstance).base_open.isOpenMap\n    convert hU (ğ’°.f x) using 1\n    rw [â† Î¹_fromGlued]; erw [coe_comp]; rw [Set.preimage_comp]\n    congr! 1\n    exact Set.preimage_image_eq _ ğ’°.fromGlued_injective\n  Â· exact âŸ¨hx, ğ’°.covers xâŸ©\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.fromGlued_isOpenEmbedding","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nâŠ¢ Topology.IsOpenEmbedding â‡‘(AlgebraicGeometry.Scheme.Cover.fromGlued ğ’°).base","decl":"theorem fromGlued_isOpenEmbedding : IsOpenEmbedding ğ’°.fromGlued.base :=\n  .of_continuous_injective_isOpenMap (by fun_prop) ğ’°.fromGlued_injective ğ’°.fromGlued_open_map\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.fromGlued_openEmbedding","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nâŠ¢ Topology.IsOpenEmbedding â‡‘(AlgebraicGeometry.Scheme.Cover.fromGlued ğ’°).base","decl":"@[deprecated (since := \"2024-10-18\")]\nalias fromGlued_openEmbedding := fromGlued_isOpenEmbedding\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.instEpiTopCatBaseCommRingCatFromGlued","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nâŠ¢ CategoryTheory.Epi (AlgebraicGeometry.Scheme.Cover.fromGlued ğ’°).base","decl":"instance : Epi ğ’°.fromGlued.base := by\n  rw [TopCat.epi_iff_surjective]\n  intro x\n  obtain âŸ¨y, hâŸ© := ğ’°.covers x\n  use (ğ’°.gluedCover.Î¹ (ğ’°.f x)).base y\n  rw [â† CategoryTheory.comp_apply]\n  rw [â† ğ’°.Î¹_fromGlued (ğ’°.f x)] at h\n  exact h\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.fromGlued_open_immersion","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nâŠ¢ AlgebraicGeometry.IsOpenImmersion (AlgebraicGeometry.Scheme.Cover.fromGlued ğ’°)","decl":"instance fromGlued_open_immersion : IsOpenImmersion ğ’°.fromGlued :=\n  IsOpenImmersion.of_stalk_iso _ ğ’°.fromGlued_isOpenEmbedding\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.instIsIsoFromGlued","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nâŠ¢ CategoryTheory.IsIso (AlgebraicGeometry.Scheme.Cover.fromGlued ğ’°)","decl":"instance : IsIso ğ’°.fromGlued :=\n  let F := Scheme.forgetToLocallyRingedSpace â‹™ LocallyRingedSpace.forgetToSheafedSpace â‹™\n    SheafedSpace.forgetToPresheafedSpace\n  have : IsIso (F.map (fromGlued ğ’°)) := by\n    change IsIso ğ’°.fromGlued.toPshHom\n    apply PresheafedSpace.IsOpenImmersion.to_iso\n  isIso_of_reflects_iso _ F\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.Î¹_glueMorphisms_assoc","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nY : AlgebraicGeometry.Scheme\nf : (x : ğ’°.J) â†’ Quiver.Hom (ğ’°.obj x) Y\nhf : âˆ€ (x y : ğ’°.J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map y)) (f x)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (ğ’°.map x) (ğ’°.map y)) (f y))\nx : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (ğ’°.map x) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.glueMorphisms ğ’° f hf) h)) (CategoryTheory.CategoryStruct.comp (f x) h)","decl":"@[simp, reassoc]\ntheorem Î¹_glueMorphisms {Y : Scheme} (f : âˆ€ x, ğ’°.obj x âŸ¶ Y)\n    (hf : âˆ€ x y, pullback.fst (ğ’°.map x) (ğ’°.map y) â‰« f x = pullback.snd _ _ â‰« f y)\n    (x : ğ’°.J) : ğ’°.map x â‰« ğ’°.glueMorphisms f hf = f x := by\n  rw [â† Î¹_fromGlued, Category.assoc]\n  erw [IsIso.hom_inv_id_assoc, Multicoequalizer.Ï€_desc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.Î¹_glueMorphisms","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nY : AlgebraicGeometry.Scheme\nf : (x : ğ’°.J) â†’ Quiver.Hom (ğ’°.obj x) Y\nhf : âˆ€ (x y : ğ’°.J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (ğ’°.map x) (ğ’°.map y)) (f x)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (ğ’°.map x) (ğ’°.map y)) (f y))\nx : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (ğ’°.map x) (AlgebraicGeometry.Scheme.Cover.glueMorphisms ğ’° f hf)) (f x)","decl":"@[simp, reassoc]\ntheorem Î¹_glueMorphisms {Y : Scheme} (f : âˆ€ x, ğ’°.obj x âŸ¶ Y)\n    (hf : âˆ€ x y, pullback.fst (ğ’°.map x) (ğ’°.map y) â‰« f x = pullback.snd _ _ â‰« f y)\n    (x : ğ’°.J) : ğ’°.map x â‰« ğ’°.glueMorphisms f hf = f x := by\n  rw [â† Î¹_fromGlued, Category.assoc]\n  erw [IsIso.hom_inv_id_assoc, Multicoequalizer.Ï€_desc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.hom_ext","module":"Mathlib.AlgebraicGeometry.Gluing","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nY : AlgebraicGeometry.Scheme\nfâ‚ fâ‚‚ : Quiver.Hom X Y\nh : âˆ€ (x : ğ’°.J), Eq (CategoryTheory.CategoryStruct.comp (ğ’°.map x) fâ‚) (CategoryTheory.CategoryStruct.comp (ğ’°.map x) fâ‚‚)\nâŠ¢ Eq fâ‚ fâ‚‚","decl":"theorem hom_ext {Y : Scheme} (fâ‚ fâ‚‚ : X âŸ¶ Y) (h : âˆ€ x, ğ’°.map x â‰« fâ‚ = ğ’°.map x â‰« fâ‚‚) : fâ‚ = fâ‚‚ := by\n  rw [â† cancel_epi ğ’°.fromGlued]\n  apply Multicoequalizer.hom_ext\n  intro x\n  erw [Multicoequalizer.Ï€_desc_assoc]\n  erw [Multicoequalizer.Ï€_desc_assoc]\n  exact h x\n\n"}
