{"name":"HasStrictDerivAt.hasStrictFDerivAt_equiv","module":"Mathlib.Analysis.Calculus.Deriv.Inverse","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nf : ğ•œ â†’ ğ•œ\nf' x : ğ•œ\nhf : HasStrictDerivAt f f' x\nhf' : Ne f' 0\nâŠ¢ HasStrictFDerivAt f (â†‘((ContinuousLinearEquiv.unitsEquivAut ğ•œ) (Units.mk0 f' hf'))) x","decl":"theorem HasStrictDerivAt.hasStrictFDerivAt_equiv {f : ğ•œ â†’ ğ•œ} {f' x : ğ•œ}\n    (hf : HasStrictDerivAt f f' x) (hf' : f' â‰  0) :\n    HasStrictFDerivAt f (ContinuousLinearEquiv.unitsEquivAut ğ•œ (Units.mk0 f' hf') : ğ•œ â†’L[ğ•œ] ğ•œ) x :=\n  hf\n\n"}
{"name":"HasDerivAt.hasFDerivAt_equiv","module":"Mathlib.Analysis.Calculus.Deriv.Inverse","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nf : ğ•œ â†’ ğ•œ\nf' x : ğ•œ\nhf : HasDerivAt f f' x\nhf' : Ne f' 0\nâŠ¢ HasFDerivAt f (â†‘((ContinuousLinearEquiv.unitsEquivAut ğ•œ) (Units.mk0 f' hf'))) x","decl":"theorem HasDerivAt.hasFDerivAt_equiv {f : ğ•œ â†’ ğ•œ} {f' x : ğ•œ} (hf : HasDerivAt f f' x)\n    (hf' : f' â‰  0) :\n    HasFDerivAt f (ContinuousLinearEquiv.unitsEquivAut ğ•œ (Units.mk0 f' hf') : ğ•œ â†’L[ğ•œ] ğ•œ) x :=\n  hf\n\n"}
{"name":"HasStrictDerivAt.of_local_left_inverse","module":"Mathlib.Analysis.Calculus.Deriv.Inverse","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nf g : ğ•œ â†’ ğ•œ\nf' a : ğ•œ\nhg : ContinuousAt g a\nhf : HasStrictDerivAt f f' (g a)\nhf' : Ne f' 0\nhfg : Filter.Eventually (fun y => Eq (f (g y)) y) (nhds a)\nâŠ¢ HasStrictDerivAt g (Inv.inv f') a","decl":"/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a` in the strict sense, then `g` has the derivative `f'â»Â¹` at `a`\nin the strict sense.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have an\ninverse function. -/\ntheorem HasStrictDerivAt.of_local_left_inverse {f g : ğ•œ â†’ ğ•œ} {f' a : ğ•œ} (hg : ContinuousAt g a)\n    (hf : HasStrictDerivAt f f' (g a)) (hf' : f' â‰  0) (hfg : âˆ€á¶  y in ğ“ a, f (g y) = y) :\n    HasStrictDerivAt g f'â»Â¹ a :=\n  (hf.hasStrictFDerivAt_equiv hf').of_local_left_inverse hg hfg\n\n"}
{"name":"PartialHomeomorph.hasStrictDerivAt_symm","module":"Mathlib.Analysis.Calculus.Deriv.Inverse","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nf : PartialHomeomorph ğ•œ ğ•œ\na f' : ğ•œ\nha : Membership.mem f.target a\nhf' : Ne f' 0\nhtff' : HasStrictDerivAt (â†‘f) f' (â†‘f.symm a)\nâŠ¢ HasStrictDerivAt (â†‘f.symm) (Inv.inv f') a","decl":"/-- If `f` is a partial homeomorphism defined on a neighbourhood of `f.symm a`, and `f` has a\nnonzero derivative `f'` at `f.symm a` in the strict sense, then `f.symm` has the derivative `f'â»Â¹`\nat `a` in the strict sense.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem PartialHomeomorph.hasStrictDerivAt_symm (f : PartialHomeomorph ğ•œ ğ•œ) {a f' : ğ•œ}\n    (ha : a âˆˆ f.target) (hf' : f' â‰  0) (htff' : HasStrictDerivAt f f' (f.symm a)) :\n    HasStrictDerivAt f.symm f'â»Â¹ a :=\n  htff'.of_local_left_inverse (f.symm.continuousAt ha) hf' (f.eventually_right_inverse ha)\n\n"}
{"name":"HasDerivAt.of_local_left_inverse","module":"Mathlib.Analysis.Calculus.Deriv.Inverse","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nf g : ğ•œ â†’ ğ•œ\nf' a : ğ•œ\nhg : ContinuousAt g a\nhf : HasDerivAt f f' (g a)\nhf' : Ne f' 0\nhfg : Filter.Eventually (fun y => Eq (f (g y)) y) (nhds a)\nâŠ¢ HasDerivAt g (Inv.inv f') a","decl":"/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a`, then `g` has the derivative `f'â»Â¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem HasDerivAt.of_local_left_inverse {f g : ğ•œ â†’ ğ•œ} {f' a : ğ•œ} (hg : ContinuousAt g a)\n    (hf : HasDerivAt f f' (g a)) (hf' : f' â‰  0) (hfg : âˆ€á¶  y in ğ“ a, f (g y) = y) :\n    HasDerivAt g f'â»Â¹ a :=\n  (hf.hasFDerivAt_equiv hf').of_local_left_inverse hg hfg\n\n"}
{"name":"PartialHomeomorph.hasDerivAt_symm","module":"Mathlib.Analysis.Calculus.Deriv.Inverse","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nf : PartialHomeomorph ğ•œ ğ•œ\na f' : ğ•œ\nha : Membership.mem f.target a\nhf' : Ne f' 0\nhtff' : HasDerivAt (â†‘f) f' (â†‘f.symm a)\nâŠ¢ HasDerivAt (â†‘f.symm) (Inv.inv f') a","decl":"/-- If `f` is a partial homeomorphism defined on a neighbourhood of `f.symm a`, and `f` has a\nnonzero derivative `f'` at `f.symm a`, then `f.symm` has the derivative `f'â»Â¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem PartialHomeomorph.hasDerivAt_symm (f : PartialHomeomorph ğ•œ ğ•œ) {a f' : ğ•œ} (ha : a âˆˆ f.target)\n    (hf' : f' â‰  0) (htff' : HasDerivAt f f' (f.symm a)) : HasDerivAt f.symm f'â»Â¹ a :=\n  htff'.of_local_left_inverse (f.symm.continuousAt ha) hf' (f.eventually_right_inverse ha)\n\n"}
{"name":"HasDerivAt.eventually_ne","module":"Mathlib.Analysis.Calculus.Deriv.Inverse","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\nh : HasDerivAt f f' x\nhf' : Ne f' 0\nâŠ¢ Filter.Eventually (fun z => Ne (f z) (f x)) (nhdsWithin x (HasCompl.compl (Singleton.singleton x)))","decl":"theorem HasDerivAt.eventually_ne (h : HasDerivAt f f' x) (hf' : f' â‰  0) :\n    âˆ€á¶  z in ğ“[â‰ ] x, f z â‰  f x :=\n  (hasDerivAt_iff_hasFDerivAt.1 h).eventually_ne\n    âŸ¨â€–f'â€–â»Â¹, fun z => by field_simp [norm_smul, mt norm_eq_zero.1 hf']âŸ©\n\n"}
{"name":"HasDerivAt.tendsto_punctured_nhds","module":"Mathlib.Analysis.Calculus.Deriv.Inverse","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\nh : HasDerivAt f f' x\nhf' : Ne f' 0\nâŠ¢ Filter.Tendsto f (nhdsWithin x (HasCompl.compl (Singleton.singleton x))) (nhdsWithin (f x) (HasCompl.compl (Singleton.singleton (f x))))","decl":"theorem HasDerivAt.tendsto_punctured_nhds (h : HasDerivAt f f' x) (hf' : f' â‰  0) :\n    Tendsto f (ğ“[â‰ ] x) (ğ“[â‰ ] f x) :=\n  tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ h.continuousAt.continuousWithinAt\n    (h.eventually_ne hf')\n\n"}
{"name":"not_differentiableWithinAt_of_local_left_inverse_hasDerivWithinAt_zero","module":"Mathlib.Analysis.Calculus.Deriv.Inverse","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nf g : ğ•œ â†’ ğ•œ\na : ğ•œ\ns t : Set ğ•œ\nha : Membership.mem s a\nhsu : UniqueDiffWithinAt ğ•œ s a\nhf : HasDerivWithinAt f 0 t (g a)\nhst : Set.MapsTo g s t\nhfg : (nhdsWithin a s).EventuallyEq (Function.comp f g) id\nâŠ¢ Not (DifferentiableWithinAt ğ•œ g s a)","decl":"theorem not_differentiableWithinAt_of_local_left_inverse_hasDerivWithinAt_zero {f g : ğ•œ â†’ ğ•œ} {a : ğ•œ}\n    {s t : Set ğ•œ} (ha : a âˆˆ s) (hsu : UniqueDiffWithinAt ğ•œ s a) (hf : HasDerivWithinAt f 0 t (g a))\n    (hst : MapsTo g s t) (hfg : f âˆ˜ g =á¶ [ğ“[s] a] id) : Â¬DifferentiableWithinAt ğ•œ g s a := by\n  intro hg\n  have := (hf.comp a hg.hasDerivWithinAt hst).congr_of_eventuallyEq_of_mem hfg.symm ha\n  simpa using hsu.eq_deriv _ this (hasDerivWithinAt_id _ _)\n\n"}
{"name":"not_differentiableAt_of_local_left_inverse_hasDerivAt_zero","module":"Mathlib.Analysis.Calculus.Deriv.Inverse","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nf g : ğ•œ â†’ ğ•œ\na : ğ•œ\nhf : HasDerivAt f 0 (g a)\nhfg : (nhds a).EventuallyEq (Function.comp f g) id\nâŠ¢ Not (DifferentiableAt ğ•œ g a)","decl":"theorem not_differentiableAt_of_local_left_inverse_hasDerivAt_zero {f g : ğ•œ â†’ ğ•œ} {a : ğ•œ}\n    (hf : HasDerivAt f 0 (g a)) (hfg : f âˆ˜ g =á¶ [ğ“ a] id) : Â¬DifferentiableAt ğ•œ g a := by\n  intro hg\n  have := (hf.comp a hg.hasDerivAt).congr_of_eventuallyEq hfg.symm\n  simpa using this.unique (hasDerivAt_id a)\n"}
