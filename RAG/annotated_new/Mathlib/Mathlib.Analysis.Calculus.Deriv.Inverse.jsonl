{"name":"HasStrictDerivAt.hasStrictFDerivAt_equiv","module":"Mathlib.Analysis.Calculus.Deriv.Inverse","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nf : 𝕜 → 𝕜\nf' x : 𝕜\nhf : HasStrictDerivAt f f' x\nhf' : Ne f' 0\n⊢ HasStrictFDerivAt f (↑((ContinuousLinearEquiv.unitsEquivAut 𝕜) (Units.mk0 f' hf'))) x","decl":"theorem HasStrictDerivAt.hasStrictFDerivAt_equiv {f : 𝕜 → 𝕜} {f' x : 𝕜}\n    (hf : HasStrictDerivAt f f' x) (hf' : f' ≠ 0) :\n    HasStrictFDerivAt f (ContinuousLinearEquiv.unitsEquivAut 𝕜 (Units.mk0 f' hf') : 𝕜 →L[𝕜] 𝕜) x :=\n  hf\n\n"}
{"name":"HasDerivAt.hasFDerivAt_equiv","module":"Mathlib.Analysis.Calculus.Deriv.Inverse","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nf : 𝕜 → 𝕜\nf' x : 𝕜\nhf : HasDerivAt f f' x\nhf' : Ne f' 0\n⊢ HasFDerivAt f (↑((ContinuousLinearEquiv.unitsEquivAut 𝕜) (Units.mk0 f' hf'))) x","decl":"theorem HasDerivAt.hasFDerivAt_equiv {f : 𝕜 → 𝕜} {f' x : 𝕜} (hf : HasDerivAt f f' x)\n    (hf' : f' ≠ 0) :\n    HasFDerivAt f (ContinuousLinearEquiv.unitsEquivAut 𝕜 (Units.mk0 f' hf') : 𝕜 →L[𝕜] 𝕜) x :=\n  hf\n\n"}
{"name":"HasStrictDerivAt.of_local_left_inverse","module":"Mathlib.Analysis.Calculus.Deriv.Inverse","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nf g : 𝕜 → 𝕜\nf' a : 𝕜\nhg : ContinuousAt g a\nhf : HasStrictDerivAt f f' (g a)\nhf' : Ne f' 0\nhfg : Filter.Eventually (fun y => Eq (f (g y)) y) (nhds a)\n⊢ HasStrictDerivAt g (Inv.inv f') a","decl":"/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a` in the strict sense, then `g` has the derivative `f'⁻¹` at `a`\nin the strict sense.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have an\ninverse function. -/\ntheorem HasStrictDerivAt.of_local_left_inverse {f g : 𝕜 → 𝕜} {f' a : 𝕜} (hg : ContinuousAt g a)\n    (hf : HasStrictDerivAt f f' (g a)) (hf' : f' ≠ 0) (hfg : ∀ᶠ y in 𝓝 a, f (g y) = y) :\n    HasStrictDerivAt g f'⁻¹ a :=\n  (hf.hasStrictFDerivAt_equiv hf').of_local_left_inverse hg hfg\n\n"}
{"name":"PartialHomeomorph.hasStrictDerivAt_symm","module":"Mathlib.Analysis.Calculus.Deriv.Inverse","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nf : PartialHomeomorph 𝕜 𝕜\na f' : 𝕜\nha : Membership.mem f.target a\nhf' : Ne f' 0\nhtff' : HasStrictDerivAt (↑f) f' (↑f.symm a)\n⊢ HasStrictDerivAt (↑f.symm) (Inv.inv f') a","decl":"/-- If `f` is a partial homeomorphism defined on a neighbourhood of `f.symm a`, and `f` has a\nnonzero derivative `f'` at `f.symm a` in the strict sense, then `f.symm` has the derivative `f'⁻¹`\nat `a` in the strict sense.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem PartialHomeomorph.hasStrictDerivAt_symm (f : PartialHomeomorph 𝕜 𝕜) {a f' : 𝕜}\n    (ha : a ∈ f.target) (hf' : f' ≠ 0) (htff' : HasStrictDerivAt f f' (f.symm a)) :\n    HasStrictDerivAt f.symm f'⁻¹ a :=\n  htff'.of_local_left_inverse (f.symm.continuousAt ha) hf' (f.eventually_right_inverse ha)\n\n"}
{"name":"HasDerivAt.of_local_left_inverse","module":"Mathlib.Analysis.Calculus.Deriv.Inverse","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nf g : 𝕜 → 𝕜\nf' a : 𝕜\nhg : ContinuousAt g a\nhf : HasDerivAt f f' (g a)\nhf' : Ne f' 0\nhfg : Filter.Eventually (fun y => Eq (f (g y)) y) (nhds a)\n⊢ HasDerivAt g (Inv.inv f') a","decl":"/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a`, then `g` has the derivative `f'⁻¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem HasDerivAt.of_local_left_inverse {f g : 𝕜 → 𝕜} {f' a : 𝕜} (hg : ContinuousAt g a)\n    (hf : HasDerivAt f f' (g a)) (hf' : f' ≠ 0) (hfg : ∀ᶠ y in 𝓝 a, f (g y) = y) :\n    HasDerivAt g f'⁻¹ a :=\n  (hf.hasFDerivAt_equiv hf').of_local_left_inverse hg hfg\n\n"}
{"name":"PartialHomeomorph.hasDerivAt_symm","module":"Mathlib.Analysis.Calculus.Deriv.Inverse","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nf : PartialHomeomorph 𝕜 𝕜\na f' : 𝕜\nha : Membership.mem f.target a\nhf' : Ne f' 0\nhtff' : HasDerivAt (↑f) f' (↑f.symm a)\n⊢ HasDerivAt (↑f.symm) (Inv.inv f') a","decl":"/-- If `f` is a partial homeomorphism defined on a neighbourhood of `f.symm a`, and `f` has a\nnonzero derivative `f'` at `f.symm a`, then `f.symm` has the derivative `f'⁻¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem PartialHomeomorph.hasDerivAt_symm (f : PartialHomeomorph 𝕜 𝕜) {a f' : 𝕜} (ha : a ∈ f.target)\n    (hf' : f' ≠ 0) (htff' : HasDerivAt f f' (f.symm a)) : HasDerivAt f.symm f'⁻¹ a :=\n  htff'.of_local_left_inverse (f.symm.continuousAt ha) hf' (f.eventually_right_inverse ha)\n\n"}
{"name":"HasDerivAt.eventually_ne","module":"Mathlib.Analysis.Calculus.Deriv.Inverse","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\nh : HasDerivAt f f' x\nhf' : Ne f' 0\n⊢ Filter.Eventually (fun z => Ne (f z) (f x)) (nhdsWithin x (HasCompl.compl (Singleton.singleton x)))","decl":"theorem HasDerivAt.eventually_ne (h : HasDerivAt f f' x) (hf' : f' ≠ 0) :\n    ∀ᶠ z in 𝓝[≠] x, f z ≠ f x :=\n  (hasDerivAt_iff_hasFDerivAt.1 h).eventually_ne\n    ⟨‖f'‖⁻¹, fun z => by field_simp [norm_smul, mt norm_eq_zero.1 hf']⟩\n\n"}
{"name":"HasDerivAt.tendsto_punctured_nhds","module":"Mathlib.Analysis.Calculus.Deriv.Inverse","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\nh : HasDerivAt f f' x\nhf' : Ne f' 0\n⊢ Filter.Tendsto f (nhdsWithin x (HasCompl.compl (Singleton.singleton x))) (nhdsWithin (f x) (HasCompl.compl (Singleton.singleton (f x))))","decl":"theorem HasDerivAt.tendsto_punctured_nhds (h : HasDerivAt f f' x) (hf' : f' ≠ 0) :\n    Tendsto f (𝓝[≠] x) (𝓝[≠] f x) :=\n  tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ h.continuousAt.continuousWithinAt\n    (h.eventually_ne hf')\n\n"}
{"name":"not_differentiableWithinAt_of_local_left_inverse_hasDerivWithinAt_zero","module":"Mathlib.Analysis.Calculus.Deriv.Inverse","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nf g : 𝕜 → 𝕜\na : 𝕜\ns t : Set 𝕜\nha : Membership.mem s a\nhsu : UniqueDiffWithinAt 𝕜 s a\nhf : HasDerivWithinAt f 0 t (g a)\nhst : Set.MapsTo g s t\nhfg : (nhdsWithin a s).EventuallyEq (Function.comp f g) id\n⊢ Not (DifferentiableWithinAt 𝕜 g s a)","decl":"theorem not_differentiableWithinAt_of_local_left_inverse_hasDerivWithinAt_zero {f g : 𝕜 → 𝕜} {a : 𝕜}\n    {s t : Set 𝕜} (ha : a ∈ s) (hsu : UniqueDiffWithinAt 𝕜 s a) (hf : HasDerivWithinAt f 0 t (g a))\n    (hst : MapsTo g s t) (hfg : f ∘ g =ᶠ[𝓝[s] a] id) : ¬DifferentiableWithinAt 𝕜 g s a := by\n  intro hg\n  have := (hf.comp a hg.hasDerivWithinAt hst).congr_of_eventuallyEq_of_mem hfg.symm ha\n  simpa using hsu.eq_deriv _ this (hasDerivWithinAt_id _ _)\n\n"}
{"name":"not_differentiableAt_of_local_left_inverse_hasDerivAt_zero","module":"Mathlib.Analysis.Calculus.Deriv.Inverse","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nf g : 𝕜 → 𝕜\na : 𝕜\nhf : HasDerivAt f 0 (g a)\nhfg : (nhds a).EventuallyEq (Function.comp f g) id\n⊢ Not (DifferentiableAt 𝕜 g a)","decl":"theorem not_differentiableAt_of_local_left_inverse_hasDerivAt_zero {f g : 𝕜 → 𝕜} {a : 𝕜}\n    (hf : HasDerivAt f 0 (g a)) (hfg : f ∘ g =ᶠ[𝓝 a] id) : ¬DifferentiableAt 𝕜 g a := by\n  intro hg\n  have := (hf.comp a hg.hasDerivAt).congr_of_eventuallyEq hfg.symm\n  simpa using this.unique (hasDerivAt_id a)\n"}
