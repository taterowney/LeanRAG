{"name":"Sylow.mk.injEq","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\ntoSubgroup✝ : Subgroup G\nisPGroup'✝ : IsPGroup p (Subtype fun x => Membership.mem toSubgroup✝ x)\nis_maximal'✝ : ∀ {Q : Subgroup G}, IsPGroup p (Subtype fun x => Membership.mem Q x) → LE.le toSubgroup✝ Q → Eq Q toSubgroup✝\ntoSubgroup : Subgroup G\nisPGroup' : IsPGroup p (Subtype fun x => Membership.mem toSubgroup x)\nis_maximal' : ∀ {Q : Subgroup G}, IsPGroup p (Subtype fun x => Membership.mem Q x) → LE.le toSubgroup Q → Eq Q toSubgroup\n⊢ Eq (Eq { toSubgroup := toSubgroup✝, isPGroup' := isPGroup'✝, is_maximal' := is_maximal'✝ } { toSubgroup := toSubgroup, isPGroup' := isPGroup', is_maximal' := is_maximal' }) (Eq toSubgroup✝ toSubgroup)","decl":"/-- A Sylow `p`-subgroup is a maximal `p`-subgroup. -/\nstructure Sylow extends Subgroup G where\n  isPGroup' : IsPGroup p toSubgroup\n  is_maximal' : ∀ {Q : Subgroup G}, IsPGroup p Q → toSubgroup ≤ Q → Q = toSubgroup\n\n"}
{"name":"Sylow.mk.sizeOf_spec","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\ninst✝ : SizeOf G\ntoSubgroup : Subgroup G\nisPGroup' : IsPGroup p (Subtype fun x => Membership.mem toSubgroup x)\nis_maximal' : ∀ {Q : Subgroup G}, IsPGroup p (Subtype fun x => Membership.mem Q x) → LE.le toSubgroup Q → Eq Q toSubgroup\n⊢ Eq (SizeOf.sizeOf { toSubgroup := toSubgroup, isPGroup' := isPGroup', is_maximal' := is_maximal' }) (HAdd.hAdd 1 (SizeOf.sizeOf toSubgroup))","decl":"/-- A Sylow `p`-subgroup is a maximal `p`-subgroup. -/\nstructure Sylow extends Subgroup G where\n  isPGroup' : IsPGroup p toSubgroup\n  is_maximal' : ∀ {Q : Subgroup G}, IsPGroup p Q → toSubgroup ≤ Q → Q = toSubgroup\n\n"}
{"name":"Sylow.is_maximal'","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nself : Sylow p G\nQ : Subgroup G\na✝¹ : IsPGroup p (Subtype fun x => Membership.mem Q x)\na✝ : LE.le self.toSubgroup Q\n⊢ Eq Q self.toSubgroup","decl":"/-- A Sylow `p`-subgroup is a maximal `p`-subgroup. -/\nstructure Sylow extends Subgroup G where\n  isPGroup' : IsPGroup p toSubgroup\n  is_maximal' : ∀ {Q : Subgroup G}, IsPGroup p Q → toSubgroup ≤ Q → Q = toSubgroup\n\n"}
{"name":"Sylow.isPGroup'","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nself : Sylow p G\n⊢ IsPGroup p (Subtype fun x => Membership.mem self.toSubgroup x)","decl":"/-- A Sylow `p`-subgroup is a maximal `p`-subgroup. -/\nstructure Sylow extends Subgroup G where\n  isPGroup' : IsPGroup p toSubgroup\n  is_maximal' : ∀ {Q : Subgroup G}, IsPGroup p Q → toSubgroup ≤ Q → Q = toSubgroup\n\n"}
{"name":"Sylow.mk.inj","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\ntoSubgroup✝ : Subgroup G\nisPGroup'✝ : IsPGroup p (Subtype fun x => Membership.mem toSubgroup✝ x)\nis_maximal'✝ : ∀ {Q : Subgroup G}, IsPGroup p (Subtype fun x => Membership.mem Q x) → LE.le toSubgroup✝ Q → Eq Q toSubgroup✝\ntoSubgroup : Subgroup G\nisPGroup' : IsPGroup p (Subtype fun x => Membership.mem toSubgroup x)\nis_maximal' : ∀ {Q : Subgroup G}, IsPGroup p (Subtype fun x => Membership.mem Q x) → LE.le toSubgroup Q → Eq Q toSubgroup\nx✝ : Eq { toSubgroup := toSubgroup✝, isPGroup' := isPGroup'✝, is_maximal' := is_maximal'✝ } { toSubgroup := toSubgroup, isPGroup' := isPGroup', is_maximal' := is_maximal' }\n⊢ Eq toSubgroup✝ toSubgroup","decl":"/-- A Sylow `p`-subgroup is a maximal `p`-subgroup. -/\nstructure Sylow extends Subgroup G where\n  isPGroup' : IsPGroup p toSubgroup\n  is_maximal' : ∀ {Q : Subgroup G}, IsPGroup p Q → toSubgroup ≤ Q → Q = toSubgroup\n\n"}
{"name":"Sylow.ext","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nP Q : Sylow p G\nh : Eq ↑P ↑Q\n⊢ Eq P Q","decl":"@[ext]\ntheorem ext {P Q : Sylow p G} (h : (P : Subgroup G) = Q) : P = Q := by cases P; cases Q; congr\n\n"}
{"name":"Sylow.ext_iff","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nP Q : Sylow p G\n⊢ Iff (Eq P Q) (Eq ↑P ↑Q)","decl":"@[ext]\ntheorem ext {P Q : Sylow p G} (h : (P : Subgroup G) = Q) : P = Q := by cases P; cases Q; congr\n\n"}
{"name":"Sylow.instSubgroupClass","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\n⊢ SubgroupClass (Sylow p G) G","decl":"instance : SubgroupClass (Sylow p G) G where\n  mul_mem := Subgroup.mul_mem _\n  one_mem _ := Subgroup.one_mem _\n  inv_mem := Subgroup.inv_mem _\n\n"}
{"name":"IsPGroup.toSylow_coe","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\ninst✝ : Fact (Nat.Prime p)\nP : Subgroup G\nhP1 : IsPGroup p (Subtype fun x => Membership.mem P x)\nhP2 : Not (Dvd.dvd p P.index)\n⊢ Eq (↑(hP1.toSylow hP2)) P","decl":"@[simp] theorem _root_.IsPGroup.toSylow_coe [Fact p.Prime] {P : Subgroup G}\n    (hP1 : IsPGroup p P) (hP2 : ¬ p ∣ P.index) : (hP1.toSylow hP2) = P :=\n  rfl\n\n"}
{"name":"IsPGroup.mem_toSylow","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\ninst✝ : Fact (Nat.Prime p)\nP : Subgroup G\nhP1 : IsPGroup p (Subtype fun x => Membership.mem P x)\nhP2 : Not (Dvd.dvd p P.index)\ng : G\n⊢ Iff (Membership.mem (hP1.toSylow hP2) g) (Membership.mem P g)","decl":"@[simp] theorem _root_.IsPGroup.mem_toSylow [Fact p.Prime] {P : Subgroup G}\n    (hP1 : IsPGroup p P) (hP2 : ¬ p ∣ P.index) {g : G} : g ∈ hP1.toSylow hP2 ↔ g ∈ P :=\n  .rfl\n\n"}
{"name":"Sylow.coe_ofCard","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : Finite G\np : Nat\ninst✝ : Fact (Nat.Prime p)\nH : Subgroup G\ncard_eq : Eq (Nat.card (Subtype fun x => Membership.mem H x)) (HPow.hPow p ((Nat.card G).factorization p))\n⊢ Eq (↑(Sylow.ofCard H card_eq)) H","decl":"@[simp, norm_cast]\ntheorem coe_ofCard [Finite G] {p : ℕ} [Fact p.Prime] (H : Subgroup G)\n    (card_eq : Nat.card H = p ^ (Nat.card G).factorization p) : ofCard H card_eq = H :=\n  rfl\n\n"}
{"name":"Sylow.coe_comapOfKerIsPGroup","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\nP : Sylow p G\nK : Type u_2\ninst✝ : Group K\nϕ : MonoidHom K G\nhϕ : IsPGroup p (Subtype fun x => Membership.mem ϕ.ker x)\nh : LE.le (↑P) ϕ.range\n⊢ Eq (↑(P.comapOfKerIsPGroup ϕ hϕ h)) (Subgroup.comap ϕ ↑P)","decl":"@[simp]\ntheorem coe_comapOfKerIsPGroup (hϕ : IsPGroup p ϕ.ker) (h : P ≤ ϕ.range) :\n    P.comapOfKerIsPGroup ϕ hϕ h = P.comap ϕ :=\n  rfl\n\n"}
{"name":"Sylow.coe_comapOfInjective","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\nP : Sylow p G\nK : Type u_2\ninst✝ : Group K\nϕ : MonoidHom K G\nhϕ : Function.Injective ⇑ϕ\nh : LE.le (↑P) ϕ.range\n⊢ Eq (↑(P.comapOfInjective ϕ hϕ h)) (Subgroup.comap ϕ ↑P)","decl":"@[simp]\ntheorem coe_comapOfInjective (hϕ : Function.Injective ϕ) (h : P ≤ ϕ.range) :\n    P.comapOfInjective ϕ hϕ h = P.comap ϕ :=\n  rfl\n\n"}
{"name":"Sylow.coe_subtype","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nP : Sylow p G\nN : Subgroup G\nh : LE.le (↑P) N\n⊢ Eq (↑(P.subtype h)) ((↑P).subgroupOf N)","decl":"@[simp]\ntheorem coe_subtype (h : P ≤ N) : P.subtype h = subgroupOf P N :=\n  rfl\n\n"}
{"name":"Sylow.subtype_injective","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nN : Subgroup G\nP Q : Sylow p G\nhP : LE.le (↑P) N\nhQ : LE.le (↑Q) N\nh : Eq (P.subtype hP) (Q.subtype hQ)\n⊢ Eq P Q","decl":"theorem subtype_injective {P Q : Sylow p G} {hP : P ≤ N} {hQ : Q ≤ N}\n    (h : P.subtype hP = Q.subtype hQ) : P = Q := by\n  rw [SetLike.ext_iff] at h ⊢\n  exact fun g => ⟨fun hg => (h ⟨g, hP hg⟩).mp hg, fun hg => (h ⟨g, hQ hg⟩).mpr hg⟩\n\n"}
{"name":"IsPGroup.exists_le_sylow","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nP : Subgroup G\nhP : IsPGroup p (Subtype fun x => Membership.mem P x)\n⊢ Exists fun Q => LE.le P ↑Q","decl":"/-- A generalization of **Sylow's first theorem**.\n  Every `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem IsPGroup.exists_le_sylow {P : Subgroup G} (hP : IsPGroup p P) : ∃ Q : Sylow p G, P ≤ Q :=\n  Exists.elim\n    (zorn_le_nonempty₀ { Q : Subgroup G | IsPGroup p Q }\n      (fun c hc1 hc2 Q hQ =>\n        ⟨{  carrier := ⋃ R : c, R\n            one_mem' := ⟨Q, ⟨⟨Q, hQ⟩, rfl⟩, Q.one_mem⟩\n            inv_mem' := fun {_} ⟨_, ⟨R, rfl⟩, hg⟩ => ⟨R, ⟨R, rfl⟩, R.1.inv_mem hg⟩\n            mul_mem' := fun {_} _ ⟨_, ⟨R, rfl⟩, hg⟩ ⟨_, ⟨S, rfl⟩, hh⟩ =>\n              (hc2.total R.2 S.2).elim (fun T => ⟨S, ⟨S, rfl⟩, S.1.mul_mem (T hg) hh⟩) fun T =>\n                ⟨R, ⟨R, rfl⟩, R.1.mul_mem hg (T hh)⟩ },\n          fun ⟨g, _, ⟨S, rfl⟩, hg⟩ => by\n          refine Exists.imp (fun k hk => ?_) (hc1 S.2 ⟨g, hg⟩)\n          rwa [Subtype.ext_iff, coe_pow] at hk ⊢, fun M hM _ hg => ⟨M, ⟨⟨M, hM⟩, rfl⟩, hg⟩⟩)\n      P hP)\n    fun {Q} h => ⟨⟨Q, h.2.prop, h.2.eq_of_ge⟩, h.1⟩\n\n"}
{"name":"Sylow.nonempty","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\n⊢ Nonempty (Sylow p G)","decl":"instance nonempty : Nonempty (Sylow p G) :=\n  nonempty_of_exists IsPGroup.of_bot.exists_le_sylow\n\n"}
{"name":"Sylow.exists_comap_eq_of_ker_isPGroup","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\nH : Type u_2\ninst✝ : Group H\nP : Sylow p H\nf : MonoidHom H G\nhf : IsPGroup p (Subtype fun x => Membership.mem f.ker x)\n⊢ Exists fun Q => Eq (Subgroup.comap f ↑Q) ↑P","decl":"theorem exists_comap_eq_of_ker_isPGroup {H : Type*} [Group H] (P : Sylow p H) {f : H →* G}\n    (hf : IsPGroup p f.ker) : ∃ Q : Sylow p G, Q.comap f = P :=\n  Exists.imp (fun Q hQ => P.3 (Q.2.comap_of_ker_isPGroup f hf) (map_le_iff_le_comap.mp hQ))\n    (P.2.map f).exists_le_sylow\n\n"}
{"name":"Sylow.exists_comap_eq_of_injective","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\nH : Type u_2\ninst✝ : Group H\nP : Sylow p H\nf : MonoidHom H G\nhf : Function.Injective ⇑f\n⊢ Exists fun Q => Eq (Subgroup.comap f ↑Q) ↑P","decl":"theorem exists_comap_eq_of_injective {H : Type*} [Group H] (P : Sylow p H) {f : H →* G}\n    (hf : Function.Injective f) : ∃ Q : Sylow p G, Q.comap f = P :=\n  P.exists_comap_eq_of_ker_isPGroup (IsPGroup.ker_isPGroup_of_injective hf)\n\n"}
{"name":"Sylow.exists_comap_subtype_eq","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nH : Subgroup G\nP : Sylow p (Subtype fun x => Membership.mem H x)\n⊢ Exists fun Q => Eq (Subgroup.comap H.subtype ↑Q) ↑P","decl":"theorem exists_comap_subtype_eq {H : Subgroup G} (P : Sylow p H) :\n    ∃ Q : Sylow p G, Q.comap H.subtype = P :=\n  P.exists_comap_eq_of_injective Subtype.coe_injective\n\n"}
{"name":"Sylow.finite_of_ker_is_pGroup","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝² : Group G\nH : Type u_2\ninst✝¹ : Group H\nf : MonoidHom H G\nhf : IsPGroup p (Subtype fun x => Membership.mem f.ker x)\ninst✝ : Finite (Sylow p G)\n⊢ Finite (Sylow p H)","decl":"/-- If the kernel of `f : H →* G` is a `p`-group,\n  then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem finite_of_ker_is_pGroup {H : Type*} [Group H] {f : H →* G}\n    (hf : IsPGroup p f.ker) [Finite (Sylow p G)] : Finite (Sylow p H) :=\n  let h_exists := fun P : Sylow p H => P.exists_comap_eq_of_ker_isPGroup hf\n  let g : Sylow p H → Sylow p G := fun P => Classical.choose (h_exists P)\n  have hg : ∀ P : Sylow p H, (g P).1.comap f = P := fun P => Classical.choose_spec (h_exists P)\n  Finite.of_injective g fun P Q h => ext (by rw [← hg, h]; exact (h_exists Q).choose_spec)\n\n"}
{"name":"Sylow.finite_of_injective","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝² : Group G\nH : Type u_2\ninst✝¹ : Group H\nf : MonoidHom H G\nhf : Function.Injective ⇑f\ninst✝ : Finite (Sylow p G)\n⊢ Finite (Sylow p H)","decl":"/-- If `f : H →* G` is injective, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem finite_of_injective {H : Type*} [Group H] {f : H →* G}\n    (hf : Function.Injective f) [Finite (Sylow p G)] : Finite (Sylow p H) :=\n  finite_of_ker_is_pGroup (IsPGroup.ker_isPGroup_of_injective hf)\n\n"}
{"name":"Sylow.instFiniteSubtypeMemSubgroup","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : Finite (Sylow p G)\n⊢ Finite (Sylow p (Subtype fun x => Membership.mem H x))","decl":"/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ninstance (H : Subgroup G) [Finite (Sylow p G)] : Finite (Sylow p H) :=\n  finite_of_injective H.subtype_injective\n\n"}
{"name":"Sylow.pointwise_smul_def","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝² : Group G\nα : Type u_2\ninst✝¹ : Group α\ninst✝ : MulDistribMulAction α G\ng : α\nP : Sylow p G\n⊢ Eq (↑(HSMul.hSMul g P)) (HSMul.hSMul g ↑P)","decl":"theorem pointwise_smul_def {α : Type*} [Group α] [MulDistribMulAction α G] {g : α}\n    {P : Sylow p G} : ↑(g • P) = g • (P : Subgroup G) :=\n  rfl\n\n"}
{"name":"Sylow.smul_def","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\ng : G\nP : Sylow p G\n⊢ Eq (HSMul.hSMul g P) (HSMul.hSMul (MulAut.conj g) P)","decl":"theorem smul_def {g : G} {P : Sylow p G} : g • P = MulAut.conj g • P :=\n  rfl\n\n"}
{"name":"Sylow.coe_subgroup_smul","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\ng : G\nP : Sylow p G\n⊢ Eq (↑(HSMul.hSMul g P)) (HSMul.hSMul (MulAut.conj g) ↑P)","decl":"theorem coe_subgroup_smul {g : G} {P : Sylow p G} :\n    ↑(g • P) = MulAut.conj g • (P : Subgroup G) :=\n  rfl\n\n"}
{"name":"Sylow.coe_smul","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\ng : G\nP : Sylow p G\n⊢ Eq (↑(HSMul.hSMul g P)) (HSMul.hSMul (MulAut.conj g) ↑P)","decl":"theorem coe_smul {g : G} {P : Sylow p G} : ↑(g • P) = MulAut.conj g • (P : Set G) :=\n  rfl\n\n"}
{"name":"Sylow.smul_le","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nP : Sylow p G\nH : Subgroup G\nhP : LE.le (↑P) H\nh : Subtype fun x => Membership.mem H x\n⊢ LE.le (↑(HSMul.hSMul h P)) H","decl":"theorem smul_le {P : Sylow p G} {H : Subgroup G} (hP : P ≤ H) (h : H) : ↑(h • P) ≤ H :=\n  Subgroup.conj_smul_le_of_le hP h\n\n"}
{"name":"Sylow.smul_subtype","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nP : Sylow p G\nH : Subgroup G\nhP : LE.le (↑P) H\nh : Subtype fun x => Membership.mem H x\n⊢ Eq (HSMul.hSMul h (P.subtype hP)) ((HSMul.hSMul h P).subtype ⋯)","decl":"theorem smul_subtype {P : Sylow p G} {H : Subgroup G} (hP : P ≤ H) (h : H) :\n    h • P.subtype hP = (h • P).subtype (smul_le hP h) :=\n  ext (Subgroup.conj_smul_subgroupOf hP h)\n\n"}
{"name":"Sylow.smul_eq_iff_mem_normalizer","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\ng : G\nP : Sylow p G\n⊢ Iff (Eq (HSMul.hSMul g P) P) (Membership.mem (↑P).normalizer g)","decl":"theorem smul_eq_iff_mem_normalizer {g : G} {P : Sylow p G} :\n    g • P = P ↔ g ∈ P.normalizer := by\n  rw [eq_comm, SetLike.ext_iff, ← inv_mem_iff (G := G) (H := normalizer P.toSubgroup),\n      mem_normalizer_iff, inv_inv]\n  exact\n    forall_congr' fun h =>\n      iff_congr Iff.rfl\n        ⟨fun ⟨a, b, c⟩ => c ▸ by simpa [mul_assoc] using b,\n          fun hh => ⟨(MulAut.conj g)⁻¹ h, hh, MulAut.apply_inv_self G (MulAut.conj g) h⟩⟩\n\n"}
{"name":"Sylow.smul_eq_of_normal","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\ng : G\nP : Sylow p G\nh : (↑P).Normal\n⊢ Eq (HSMul.hSMul g P) P","decl":"theorem smul_eq_of_normal {g : G} {P : Sylow p G} [h : P.Normal] :\n    g • P = P := by simp only [smul_eq_iff_mem_normalizer, P.normalizer_eq_top, mem_top]\n\n"}
{"name":"Subgroup.sylow_mem_fixedPoints_iff","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nH : Subgroup G\nP : Sylow p G\n⊢ Iff (Membership.mem (MulAction.fixedPoints (Subtype fun x => Membership.mem H x) (Sylow p G)) P) (LE.le H (↑P).normalizer)","decl":"theorem Subgroup.sylow_mem_fixedPoints_iff (H : Subgroup G) {P : Sylow p G} :\n    P ∈ fixedPoints H (Sylow p G) ↔ H ≤ P.normalizer := by\n  simp_rw [SetLike.le_def, ← Sylow.smul_eq_iff_mem_normalizer]; exact Subtype.forall\n\n"}
{"name":"IsPGroup.inf_normalizer_sylow","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nP : Subgroup G\nhP : IsPGroup p (Subtype fun x => Membership.mem P x)\nQ : Sylow p G\n⊢ Eq (Min.min P (↑Q).normalizer) (Min.min P ↑Q)","decl":"theorem IsPGroup.inf_normalizer_sylow {P : Subgroup G} (hP : IsPGroup p P) (Q : Sylow p G) :\n    P ⊓ Q.normalizer = P ⊓ Q :=\n  le_antisymm\n    (le_inf inf_le_left\n      (sup_eq_right.mp\n        (Q.3 (hP.to_inf_left.to_sup_of_normal_right' Q.2 inf_le_right) le_sup_right)))\n    (inf_le_inf_left P le_normalizer)\n\n"}
{"name":"IsPGroup.sylow_mem_fixedPoints_iff","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nP : Subgroup G\nhP : IsPGroup p (Subtype fun x => Membership.mem P x)\nQ : Sylow p G\n⊢ Iff (Membership.mem (MulAction.fixedPoints (Subtype fun x => Membership.mem P x) (Sylow p G)) Q) (LE.le P ↑Q)","decl":"theorem IsPGroup.sylow_mem_fixedPoints_iff {P : Subgroup G} (hP : IsPGroup p P) {Q : Sylow p G} :\n    Q ∈ fixedPoints P (Sylow p G) ↔ P ≤ Q := by\n  rw [P.sylow_mem_fixedPoints_iff, ← inf_eq_left, hP.inf_normalizer_sylow, inf_eq_left]\n\n"}
{"name":"Sylow.isPretransitive_of_finite","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\nhp : Fact (Nat.Prime p)\ninst✝ : Finite (Sylow p G)\n⊢ MulAction.IsPretransitive G (Sylow p G)","decl":"/-- A generalization of **Sylow's second theorem**.\n  If the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. -/\ninstance Sylow.isPretransitive_of_finite [hp : Fact p.Prime] [Finite (Sylow p G)] :\n    IsPretransitive G (Sylow p G) :=\n  ⟨fun P Q => by\n    classical\n      have H := fun {R : Sylow p G} {S : orbit G P} =>\n        calc\n          S ∈ fixedPoints R (orbit G P) ↔ S.1 ∈ fixedPoints R (Sylow p G) :=\n            forall_congr' fun a => Subtype.ext_iff\n          _ ↔ R.1 ≤ S := R.2.sylow_mem_fixedPoints_iff\n          _ ↔ S.1.1 = R := ⟨fun h => R.3 S.1.2 h, ge_of_eq⟩\n      suffices Set.Nonempty (fixedPoints Q (orbit G P)) by\n        exact Exists.elim this fun R hR => by\n          rw [← Sylow.ext (H.mp hR)]\n          exact R.2\n      apply Q.2.nonempty_fixed_point_of_prime_not_dvd_card\n      refine fun h => hp.out.not_dvd_one (Nat.modEq_zero_iff_dvd.mp ?_)\n      calc\n        1 = Nat.card (fixedPoints P (orbit G P)) := ?_\n        _ ≡ Nat.card (orbit G P) [MOD p] := (P.2.card_modEq_card_fixedPoints (orbit G P)).symm\n        _ ≡ 0 [MOD p] := Nat.modEq_zero_iff_dvd.mpr h\n      rw [← Nat.card_unique (α := ({⟨P, mem_orbit_self P⟩} : Set (orbit G P))), eq_comm]\n      congr\n      rw [Set.eq_singleton_iff_unique_mem]\n      exact ⟨H.mpr rfl, fun R h => Subtype.ext (Sylow.ext (H.mp h))⟩⟩\n\n"}
{"name":"card_sylow_modEq_one","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝² : Group G\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Finite (Sylow p G)\n⊢ p.ModEq (Nat.card (Sylow p G)) 1","decl":"/-- A generalization of **Sylow's third theorem**.\n  If the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem card_sylow_modEq_one [Fact p.Prime] [Finite (Sylow p G)] :\n    Nat.card (Sylow p G) ≡ 1 [MOD p] := by\n  refine Sylow.nonempty.elim fun P : Sylow p G => ?_\n  have : fixedPoints P.1 (Sylow p G) = {P} :=\n    Set.ext fun Q : Sylow p G =>\n      calc\n        Q ∈ fixedPoints P (Sylow p G) ↔ P.1 ≤ Q := P.2.sylow_mem_fixedPoints_iff\n        _ ↔ Q.1 = P.1 := ⟨P.3 Q.2, ge_of_eq⟩\n        _ ↔ Q ∈ {P} := Sylow.ext_iff.symm.trans Set.mem_singleton_iff.symm\n  have : Nat.card (fixedPoints P.1 (Sylow p G)) = 1 := by simp [this]\n  exact (P.2.card_modEq_card_fixedPoints (Sylow p G)).trans (by rw [this])\n\n"}
{"name":"not_dvd_card_sylow","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\nhp : Fact (Nat.Prime p)\ninst✝ : Finite (Sylow p G)\n⊢ Not (Dvd.dvd p (Nat.card (Sylow p G)))","decl":"theorem not_dvd_card_sylow [hp : Fact p.Prime] [Finite (Sylow p G)] : ¬p ∣ Nat.card (Sylow p G) :=\n  fun h =>\n  hp.1.ne_one\n    (Nat.dvd_one.mp\n      ((Nat.modEq_iff_dvd' zero_le_one).mp\n        ((Nat.modEq_zero_iff_dvd.mpr h).symm.trans (card_sylow_modEq_one p G))))\n\n"}
{"name":"Sylow.orbit_eq_top","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝² : Group G\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Finite (Sylow p G)\nP : Sylow p G\n⊢ Eq (MulAction.orbit G P) Top.top","decl":"@[simp]\ntheorem orbit_eq_top [Fact p.Prime] [Finite (Sylow p G)] (P : Sylow p G) : orbit G P = ⊤ :=\n  top_le_iff.mp fun Q _ => exists_smul_eq G P Q\n\n"}
{"name":"Sylow.stabilizer_eq_normalizer","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nP : Sylow p G\n⊢ Eq (MulAction.stabilizer G P) (↑P).normalizer","decl":"theorem stabilizer_eq_normalizer (P : Sylow p G) :\n    stabilizer G P = P.normalizer := by\n  ext; simp [smul_eq_iff_mem_normalizer]\n\n"}
{"name":"Sylow.conj_eq_normalizer_conj_of_mem_centralizer","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝² : Group G\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Finite (Sylow p G)\nP : Sylow p G\nx g : G\nhx : Membership.mem (Subgroup.centralizer ↑P) x\nhy : Membership.mem (Subgroup.centralizer ↑P) (HMul.hMul (HMul.hMul (Inv.inv g) x) g)\n⊢ Exists fun n => And (Membership.mem (↑P).normalizer n) (Eq (HMul.hMul (HMul.hMul (Inv.inv g) x) g) (HMul.hMul (HMul.hMul (Inv.inv n) x) n))","decl":"theorem conj_eq_normalizer_conj_of_mem_centralizer [Fact p.Prime] [Finite (Sylow p G)]\n    (P : Sylow p G) (x g : G) (hx : x ∈ centralizer P)\n    (hy : g⁻¹ * x * g ∈ centralizer P) :\n    ∃ n ∈ P.normalizer, g⁻¹ * x * g = n⁻¹ * x * n := by\n  have h1 : P ≤ centralizer (zpowers x : Set G) := by rwa [le_centralizer_iff, zpowers_le]\n  have h2 : ↑(g • P) ≤ centralizer (zpowers x : Set G) := by\n    rw [le_centralizer_iff, zpowers_le]\n    rintro - ⟨z, hz, rfl⟩\n    specialize hy z hz\n    rwa [← mul_assoc, ← eq_mul_inv_iff_mul_eq, mul_assoc, mul_assoc, mul_assoc, ← mul_assoc,\n      eq_inv_mul_iff_mul_eq, ← mul_assoc, ← mul_assoc] at hy\n  obtain ⟨h, hh⟩ :=\n    exists_smul_eq (centralizer (zpowers x : Set G)) ((g • P).subtype h2) (P.subtype h1)\n  simp_rw [smul_subtype, Subgroup.smul_def, smul_smul] at hh\n  refine ⟨h * g, smul_eq_iff_mem_normalizer.mp (subtype_injective hh), ?_⟩\n  rw [← mul_assoc, Commute.right_comm (h.prop x (mem_zpowers x)), mul_inv_rev, inv_mul_cancel_right]\n\n"}
{"name":"Sylow.conj_eq_normalizer_conj_of_mem","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝² : Group G\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Finite (Sylow p G)\nP : Sylow p G\n_hP : (↑P).IsCommutative\nx g : G\nhx : Membership.mem P x\nhy : Membership.mem P (HMul.hMul (HMul.hMul (Inv.inv g) x) g)\n⊢ Exists fun n => And (Membership.mem (↑P).normalizer n) (Eq (HMul.hMul (HMul.hMul (Inv.inv g) x) g) (HMul.hMul (HMul.hMul (Inv.inv n) x) n))","decl":"theorem conj_eq_normalizer_conj_of_mem [Fact p.Prime] [Finite (Sylow p G)] (P : Sylow p G)\n    [_hP : P.IsCommutative] (x g : G) (hx : x ∈ P) (hy : g⁻¹ * x * g ∈ P) :\n    ∃ n ∈ P.normalizer, g⁻¹ * x * g = n⁻¹ * x * n :=\n  P.conj_eq_normalizer_conj_of_mem_centralizer x g\n    (P.le_centralizer hx) (P.le_centralizer hy)\n\n"}
{"name":"Sylow.instFiniteQuotientSubgroupNormalizerOfFactPrime","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝² : Group G\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Finite (Sylow p G)\nP : Sylow p G\n⊢ Finite (HasQuotient.Quotient G (↑P).normalizer)","decl":"instance [Fact p.Prime] [Finite (Sylow p G)] (P : Sylow p G) :\n    Finite (G ⧸ P.normalizer) :=\n  Finite.of_equiv (Sylow p G) P.equivQuotientNormalizer\n\n"}
{"name":"Sylow.card_eq_card_quotient_normalizer","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝² : Group G\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Finite (Sylow p G)\nP : Sylow p G\n⊢ Eq (Nat.card (Sylow p G)) (Nat.card (HasQuotient.Quotient G (↑P).normalizer))","decl":"theorem card_eq_card_quotient_normalizer [Fact p.Prime] [Finite (Sylow p G)]\n    (P : Sylow p G) : Nat.card (Sylow p G) = Nat.card (G ⧸ P.normalizer) :=\n  Nat.card_congr P.equivQuotientNormalizer\n\n"}
{"name":"card_sylow_eq_card_quotient_normalizer","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝² : Group G\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Finite (Sylow p G)\nP : Sylow p G\n⊢ Eq (Nat.card (Sylow p G)) (Nat.card (HasQuotient.Quotient G (↑P).normalizer))","decl":"@[deprecated (since := \"2024-11-07\")]\nalias _root_.card_sylow_eq_card_quotient_normalizer := card_eq_card_quotient_normalizer\n\n"}
{"name":"Sylow.card_eq_index_normalizer","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝² : Group G\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Finite (Sylow p G)\nP : Sylow p G\n⊢ Eq (Nat.card (Sylow p G)) (↑P).normalizer.index","decl":"theorem card_eq_index_normalizer [Fact p.Prime] [Finite (Sylow p G)] (P : Sylow p G) :\n    Nat.card (Sylow p G) = P.normalizer.index :=\n  P.card_eq_card_quotient_normalizer\n\n"}
{"name":"card_sylow_eq_index_normalizer","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝² : Group G\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Finite (Sylow p G)\nP : Sylow p G\n⊢ Eq (Nat.card (Sylow p G)) (↑P).normalizer.index","decl":"@[deprecated (since := \"2024-11-07\")]\nalias _root_.card_sylow_eq_index_normalizer := card_eq_index_normalizer\n\n"}
{"name":"Sylow.card_dvd_index","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝² : Group G\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Finite (Sylow p G)\nP : Sylow p G\n⊢ Dvd.dvd (Nat.card (Sylow p G)) (↑P).index","decl":"theorem card_dvd_index [Fact p.Prime] [Finite (Sylow p G)] (P : Sylow p G) :\n    Nat.card (Sylow p G) ∣ P.index :=\n  ((congr_arg _ P.card_eq_index_normalizer).mp dvd_rfl).trans\n    (index_dvd_of_le le_normalizer)\n\n"}
{"name":"card_sylow_dvd_index","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝² : Group G\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Finite (Sylow p G)\nP : Sylow p G\n⊢ Dvd.dvd (Nat.card (Sylow p G)) (↑P).index","decl":"@[deprecated (since := \"2024-11-07\")]\nalias _root_.card_sylow_dvd_index := card_dvd_index\n\n"}
{"name":"Sylow.not_dvd_index'","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\nhp : Fact (Nat.Prime p)\ninst✝ : Finite (Sylow p G)\nP : Sylow p G\nhP : Ne ((↑P).relindex (↑P).normalizer) 0\n⊢ Not (Dvd.dvd p (↑P).index)","decl":"/-- A Sylow p-subgroup has index indivisible by `p`, assuming [N(P) : P] < ∞. -/\ntheorem not_dvd_index' [hp : Fact p.Prime] [Finite (Sylow p G)] (P : Sylow p G)\n    (hP : P.relindex P.normalizer ≠ 0) : ¬ p ∣ P.index := by\n  rw [← relindex_mul_index le_normalizer, ← card_eq_index_normalizer]\n  haveI : (P.subtype le_normalizer).Normal :=\n    Subgroup.normal_in_normalizer\n  haveI : (P.subtype le_normalizer).FiniteIndex := ⟨hP⟩\n  replace hP := not_dvd_index_aux (P.subtype le_normalizer)\n  exact hp.1.not_dvd_mul hP (not_dvd_card_sylow p G)\n\n"}
{"name":"not_dvd_index_sylow","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\nhp : Fact (Nat.Prime p)\ninst✝ : Finite (Sylow p G)\nP : Sylow p G\nhP : Ne ((↑P).relindex (↑P).normalizer) 0\n⊢ Not (Dvd.dvd p (↑P).index)","decl":"@[deprecated (since := \"2024-11-03\")]\nalias _root_.not_dvd_index_sylow := not_dvd_index'\n\n"}
{"name":"Sylow.not_dvd_index","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝³ : Group G\ninst✝² : Fact (Nat.Prime p)\ninst✝¹ : Finite (Sylow p G)\nP : Sylow p G\ninst✝ : (↑P).FiniteIndex\n⊢ Not (Dvd.dvd p (↑P).index)","decl":"/-- A Sylow p-subgroup has index indivisible by `p`. -/\ntheorem not_dvd_index [Fact p.Prime] [Finite (Sylow p G)] (P : Sylow p G) [P.FiniteIndex] :\n    ¬ p ∣ P.index :=\n  P.not_dvd_index' Nat.card_pos.ne'\n\n"}
{"name":"not_dvd_index_sylow'","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝³ : Group G\ninst✝² : Fact (Nat.Prime p)\ninst✝¹ : Finite (Sylow p G)\nP : Sylow p G\ninst✝ : (↑P).FiniteIndex\n⊢ Not (Dvd.dvd p (↑P).index)","decl":"@[deprecated (since := \"2024-11-03\")]\nalias _root_.not_dvd_index_sylow' := not_dvd_index\n\n"}
{"name":"Sylow.coe_mapSurjective","module":"Mathlib.GroupTheory.Sylow","initialProofState":"p : Nat\nG : Type u_1\ninst✝³ : Group G\ninst✝² : Finite G\nG' : Type u_2\ninst✝¹ : Group G'\nf : MonoidHom G G'\nhf : Function.Surjective ⇑f\ninst✝ : Fact (Nat.Prime p)\nP : Sylow p G\n⊢ Eq (↑(Sylow.mapSurjective hf P)) (Subgroup.map f ↑P)","decl":"@[simp] theorem coe_mapSurjective [Fact p.Prime] (P : Sylow p G) : P.mapSurjective hf = P.map f :=\n  rfl\n\n"}
{"name":"Sylow.mapSurjective_surjective","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : Finite G\nG' : Type u_2\ninst✝¹ : Group G'\nf : MonoidHom G G'\nhf : Function.Surjective ⇑f\np : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ Function.Surjective (Sylow.mapSurjective hf)","decl":"theorem mapSurjective_surjective (p : ℕ) [Fact p.Prime] :\n    Function.Surjective (Sylow.mapSurjective hf : Sylow p G → Sylow p G') := by\n  have : Finite G' := Finite.of_surjective f hf\n  intro P\n  let Q₀ : Sylow p (P.comap f) := Sylow.nonempty.some\n  let Q : Subgroup G := Q₀.map (P.comap f).subtype\n  have hPQ : Q.map f ≤ P := Subgroup.map_le_iff_le_comap.mpr (Subgroup.map_subtype_le Q₀.1)\n  have hpQ : IsPGroup p Q := Q₀.2.map (P.comap f).subtype\n  have hQ : ¬ p ∣ Q.index := by\n    rw [Subgroup.index_map_subtype Q₀.1, P.index_comap_of_surjective hf]\n    exact Nat.Prime.not_dvd_mul Fact.out Q₀.not_dvd_index P.not_dvd_index\n  use hpQ.toSylow hQ\n  rw [Sylow.ext_iff, Sylow.coe_mapSurjective, eq_comm]\n  exact ((hpQ.map f).toSylow (fun h ↦ hQ (h.trans (Q.index_map_dvd hf)))).3 P.2 hPQ\n\n"}
{"name":"Sylow.normalizer_sup_eq_top","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u_1\ninst✝³ : Group G\np : Nat\ninst✝² : Fact (Nat.Prime p)\nN : Subgroup G\ninst✝¹ : N.Normal\ninst✝ : Finite (Sylow p (Subtype fun x => Membership.mem N x))\nP : Sylow p (Subtype fun x => Membership.mem N x)\n⊢ Eq (Max.max (Subgroup.map N.subtype ↑P).normalizer N) Top.top","decl":"/-- **Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\n  of `N`, then `N_G(P) ⊔ N = G`. -/\ntheorem normalizer_sup_eq_top {p : ℕ} [Fact p.Prime] {N : Subgroup G} [N.Normal]\n    [Finite (Sylow p N)] (P : Sylow p N) :\n    (P.map N.subtype).normalizer ⊔ N = ⊤ := by\n  refine top_le_iff.mp fun g _ => ?_\n  obtain ⟨n, hn⟩ := exists_smul_eq N ((MulAut.conjNormal g : MulAut N) • P) P\n  rw [← inv_mul_cancel_left (↑n) g, sup_comm]\n  apply mul_mem_sup (N.inv_mem n.2)\n  rw [smul_def, ← mul_smul, ← MulAut.conjNormal_val, ← MulAut.conjNormal.map_mul,\n    Sylow.ext_iff, pointwise_smul_def, Subgroup.pointwise_smul_def] at hn\n  have : Function.Injective (MulAut.conj (n * g)).toMonoidHom := (MulAut.conj (n * g)).injective\n  refine fun x ↦ (mem_map_iff_mem this).symm.trans ?_\n  rw [map_map, ← congr_arg (map N.subtype) hn, map_map]\n  rfl\n\n"}
{"name":"Sylow.normalizer_sup_eq_top'","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u_1\ninst✝³ : Group G\np : Nat\ninst✝² : Fact (Nat.Prime p)\nN : Subgroup G\ninst✝¹ : N.Normal\ninst✝ : Finite (Sylow p (Subtype fun x => Membership.mem N x))\nP : Sylow p G\nhP : LE.le (↑P) N\n⊢ Eq (Max.max (↑P).normalizer N) Top.top","decl":"/-- **Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\n  of `N`, then `N_G(P) ⊔ N = G`. -/\ntheorem normalizer_sup_eq_top' {p : ℕ} [Fact p.Prime] {N : Subgroup G} [N.Normal]\n    [Finite (Sylow p N)] (P : Sylow p G) (hP : P ≤ N) : P.normalizer ⊔ N = ⊤ := by\n  rw [← normalizer_sup_eq_top (P.subtype hP), P.coe_subtype, subgroupOf_map_subtype,\n    inf_of_le_left hP]\n\n"}
{"name":"QuotientGroup.card_preimage_mk","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u\ninst✝ : Group G\ns : Subgroup G\nt : Set (HasQuotient.Quotient G s)\n⊢ Eq (Nat.card ↑(Set.preimage QuotientGroup.mk t)) (HMul.hMul (Nat.card (Subtype fun x => Membership.mem s x)) (Nat.card ↑t))","decl":"theorem QuotientGroup.card_preimage_mk (s : Subgroup G) (t : Set (G ⧸ s)) :\n    Nat.card (QuotientGroup.mk ⁻¹' t) = Nat.card s * Nat.card t := by\n  rw [← Nat.card_prod, Nat.card_congr (preimageMkEquivSubgroupProdSet _ _)]\n\n"}
{"name":"Sylow.mem_fixedPoints_mul_left_cosets_iff_mem_normalizer","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : Finite ↑↑H\nx : G\n⊢ Iff (Membership.mem (MulAction.fixedPoints (Subtype fun x => Membership.mem H x) (HasQuotient.Quotient G H)) ↑x) (Membership.mem H.normalizer x)","decl":"theorem mem_fixedPoints_mul_left_cosets_iff_mem_normalizer {H : Subgroup G} [Finite (H : Set G)]\n    {x : G} : (x : G ⧸ H) ∈ MulAction.fixedPoints H (G ⧸ H) ↔ x ∈ normalizer H :=\n  ⟨fun hx =>\n    have ha : ∀ {y : G ⧸ H}, y ∈ orbit H (x : G ⧸ H) → y = x := mem_fixedPoints'.1 hx _\n    (inv_mem_iff (G := G)).1\n      (mem_normalizer_fintype fun n (hn : n ∈ H) =>\n        have : (n⁻¹ * x)⁻¹ * x ∈ H := QuotientGroup.eq.1 (ha ⟨⟨n⁻¹, inv_mem hn⟩, rfl⟩)\n        show _ ∈ H by\n          rw [mul_inv_rev, inv_inv] at this\n          convert this\n          rw [inv_inv]),\n    fun hx : ∀ n : G, n ∈ H ↔ x * n * x⁻¹ ∈ H =>\n    mem_fixedPoints'.2 fun y =>\n      Quotient.inductionOn' y fun y hy =>\n        QuotientGroup.eq.2\n          (let ⟨⟨b, hb₁⟩, hb₂⟩ := hy\n          have hb₂ : (b * x)⁻¹ * y ∈ H := QuotientGroup.eq.1 hb₂\n          (inv_mem_iff (G := G)).1 <|\n            (hx _).2 <|\n              (mul_mem_cancel_left (inv_mem hb₁)).1 <| by\n                rw [hx] at hb₂; simpa [mul_inv_rev, mul_assoc] using hb₂)⟩\n\n"}
{"name":"Sylow.card_quotient_normalizer_modEq_card_quotient","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u\ninst✝¹ : Group G\ninst✝ : Finite G\np n : Nat\nhp : Fact (Nat.Prime p)\nH : Subgroup G\nhH : Eq (Nat.card (Subtype fun x => Membership.mem H x)) (HPow.hPow p n)\n⊢ p.ModEq (Nat.card (HasQuotient.Quotient (Subtype fun x => Membership.mem H.normalizer x) (Subgroup.comap H.normalizer.subtype H))) (Nat.card (HasQuotient.Quotient G H))","decl":"/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\n  mod `p` to the index of `H`. -/\ntheorem card_quotient_normalizer_modEq_card_quotient [Finite G] {p : ℕ} {n : ℕ} [hp : Fact p.Prime]\n    {H : Subgroup G} (hH : Nat.card H = p ^ n) :\n    Nat.card (normalizer H ⧸ Subgroup.comap ((normalizer H).subtype : normalizer H →* G) H) ≡\n      Nat.card (G ⧸ H) [MOD p] := by\n  rw [← Nat.card_congr (fixedPointsMulLeftCosetsEquivQuotient H)]\n  exact ((IsPGroup.of_card hH).card_modEq_card_fixedPoints _).symm\n\n"}
{"name":"Sylow.card_normalizer_modEq_card","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u\ninst✝¹ : Group G\ninst✝ : Finite G\np n : Nat\nhp : Fact (Nat.Prime p)\nH : Subgroup G\nhH : Eq (Nat.card (Subtype fun x => Membership.mem H x)) (HPow.hPow p n)\n⊢ (HPow.hPow p (HAdd.hAdd n 1)).ModEq (Nat.card (Subtype fun x => Membership.mem H.normalizer x)) (Nat.card G)","decl":"/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\n  normalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem card_normalizer_modEq_card [Finite G] {p : ℕ} {n : ℕ} [hp : Fact p.Prime] {H : Subgroup G}\n    (hH : Nat.card H = p ^ n) : Nat.card (normalizer H) ≡ Nat.card G [MOD p ^ (n + 1)] := by\n  have : H.subgroupOf (normalizer H) ≃ H := (subgroupOfEquivOfLe le_normalizer).toEquiv\n  rw [card_eq_card_quotient_mul_card_subgroup H,\n    card_eq_card_quotient_mul_card_subgroup (H.subgroupOf (normalizer H)), Nat.card_congr this,\n    hH, pow_succ']\n  exact (card_quotient_normalizer_modEq_card_quotient hH).mul_right' _\n\n"}
{"name":"Sylow.prime_dvd_card_quotient_normalizer","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u\ninst✝² : Group G\ninst✝¹ : Finite G\np n : Nat\ninst✝ : Fact (Nat.Prime p)\nhdvd : Dvd.dvd (HPow.hPow p (HAdd.hAdd n 1)) (Nat.card G)\nH : Subgroup G\nhH : Eq (Nat.card (Subtype fun x => Membership.mem H x)) (HPow.hPow p n)\n⊢ Dvd.dvd p (Nat.card (HasQuotient.Quotient (Subtype fun x => Membership.mem H.normalizer x) (Subgroup.comap H.normalizer.subtype H)))","decl":"/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\n  index of `H` inside its normalizer. -/\ntheorem prime_dvd_card_quotient_normalizer [Finite G] {p : ℕ} {n : ℕ} [Fact p.Prime]\n    (hdvd : p ^ (n + 1) ∣ Nat.card G) {H : Subgroup G} (hH : Nat.card H = p ^ n) :\n    p ∣ Nat.card (normalizer H ⧸ Subgroup.comap ((normalizer H).subtype : normalizer H →* G) H) :=\n  let ⟨s, hs⟩ := exists_eq_mul_left_of_dvd hdvd\n  have hcard : Nat.card (G ⧸ H) = s * p :=\n    (mul_left_inj' (show Nat.card H ≠ 0 from Nat.card_pos.ne')).1\n      (by\n        rw [← card_eq_card_quotient_mul_card_subgroup H, hH, hs, pow_succ', mul_assoc, mul_comm p])\n  have hm :\n    s * p % p =\n      Nat.card (normalizer H ⧸ Subgroup.comap ((normalizer H).subtype : normalizer H →* G) H) % p :=\n    hcard ▸ (card_quotient_normalizer_modEq_card_quotient hH).symm\n  Nat.dvd_of_mod_eq_zero (by rwa [Nat.mod_eq_zero_of_dvd (dvd_mul_left _ _), eq_comm] at hm)\n\n"}
{"name":"Sylow.prime_pow_dvd_card_normalizer","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u\ninst✝¹ : Group G\ninst✝ : Finite G\np n : Nat\n_hp : Fact (Nat.Prime p)\nhdvd : Dvd.dvd (HPow.hPow p (HAdd.hAdd n 1)) (Nat.card G)\nH : Subgroup G\nhH : Eq (Nat.card (Subtype fun x => Membership.mem H x)) (HPow.hPow p n)\n⊢ Dvd.dvd (HPow.hPow p (HAdd.hAdd n 1)) (Nat.card (Subtype fun x => Membership.mem H.normalizer x))","decl":"/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\n  then `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem prime_pow_dvd_card_normalizer [Finite G] {p : ℕ} {n : ℕ} [_hp : Fact p.Prime]\n    (hdvd : p ^ (n + 1) ∣ Nat.card G) {H : Subgroup G} (hH : Nat.card H = p ^ n) :\n    p ^ (n + 1) ∣ Nat.card (normalizer H) :=\n  Nat.modEq_zero_iff_dvd.1 ((card_normalizer_modEq_card hH).trans hdvd.modEq_zero_nat)\n\n"}
{"name":"Sylow.exists_subgroup_card_pow_succ","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u\ninst✝¹ : Group G\ninst✝ : Finite G\np n : Nat\nhp : Fact (Nat.Prime p)\nhdvd : Dvd.dvd (HPow.hPow p (HAdd.hAdd n 1)) (Nat.card G)\nH : Subgroup G\nhH : Eq (Nat.card (Subtype fun x => Membership.mem H x)) (HPow.hPow p n)\n⊢ Exists fun K => And (Eq (Nat.card (Subtype fun x => Membership.mem K x)) (HPow.hPow p (HAdd.hAdd n 1))) (LE.le H K)","decl":"/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\n  then `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\n  if `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem exists_subgroup_card_pow_succ [Finite G] {p : ℕ} {n : ℕ} [hp : Fact p.Prime]\n    (hdvd : p ^ (n + 1) ∣ Nat.card G) {H : Subgroup G} (hH : Nat.card H = p ^ n) :\n    ∃ K : Subgroup G, Nat.card K = p ^ (n + 1) ∧ H ≤ K :=\n  let ⟨s, hs⟩ := exists_eq_mul_left_of_dvd hdvd\n  have hcard : Nat.card (G ⧸ H) = s * p :=\n    (mul_left_inj' (show Nat.card H ≠ 0 from Nat.card_pos.ne')).1\n      (by\n        rw [← card_eq_card_quotient_mul_card_subgroup H, hH, hs, pow_succ', mul_assoc, mul_comm p])\n  have hm : s * p % p = Nat.card (normalizer H ⧸ H.subgroupOf H.normalizer) % p :=\n    Nat.card_congr (fixedPointsMulLeftCosetsEquivQuotient H) ▸\n      hcard ▸ (IsPGroup.of_card hH).card_modEq_card_fixedPoints _\n  have hm' : p ∣ Nat.card (normalizer H ⧸ H.subgroupOf H.normalizer) :=\n    Nat.dvd_of_mod_eq_zero (by rwa [Nat.mod_eq_zero_of_dvd (dvd_mul_left _ _), eq_comm] at hm)\n  let ⟨x, hx⟩ := @exists_prime_orderOf_dvd_card' _ (QuotientGroup.Quotient.group _) _ _ hp hm'\n  have hequiv : H ≃ H.subgroupOf H.normalizer := (subgroupOfEquivOfLe le_normalizer).symm.toEquiv\n  ⟨Subgroup.map (normalizer H).subtype\n      (Subgroup.comap (mk' (H.subgroupOf H.normalizer)) (zpowers x)), by\n    show Nat.card (Subgroup.map H.normalizer.subtype\n              (comap (mk' (H.subgroupOf H.normalizer)) (Subgroup.zpowers x))) = p ^ (n + 1)\n    suffices Nat.card (Subtype.val ''\n              (Subgroup.comap (mk' (H.subgroupOf H.normalizer)) (zpowers x) : Set H.normalizer)) =\n        p ^ (n + 1)\n      by convert this using 2\n    rw [Nat.card_image_of_injective Subtype.val_injective\n        (Subgroup.comap (mk' (H.subgroupOf H.normalizer)) (zpowers x) : Set H.normalizer),\n      pow_succ, ← hH, Nat.card_congr hequiv, ← hx, ← Nat.card_zpowers, ←\n      Nat.card_prod]\n    exact Nat.card_congr\n      (preimageMkEquivSubgroupProdSet (H.subgroupOf H.normalizer) (zpowers x)), by\n    intro y hy\n    simp only [exists_prop, Subgroup.coeSubtype, mk'_apply, Subgroup.mem_map, Subgroup.mem_comap]\n    refine ⟨⟨y, le_normalizer hy⟩, ⟨0, ?_⟩, rfl⟩\n    dsimp only\n    rw [zpow_zero, eq_comm, QuotientGroup.eq_one_iff]\n    simpa using hy⟩\n\n"}
{"name":"Sylow.exists_subgroup_card_pow_prime_le","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u\ninst✝¹ : Group G\ninst✝ : Finite G\np n m : Nat\n_hp : Fact (Nat.Prime p)\n_hdvd : Dvd.dvd (HPow.hPow p m) (Nat.card G)\nH : Subgroup G\n_hH : Eq (Nat.card (Subtype fun x => Membership.mem H x)) (HPow.hPow p n)\n_hnm : LE.le n m\n⊢ Exists fun K => And (Eq (Nat.card (Subtype fun x => Membership.mem K x)) (HPow.hPow p m)) (LE.le H K)","decl":"/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\n  then `H` is contained in a subgroup of cardinality `p ^ m`\n  if `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem exists_subgroup_card_pow_prime_le [Finite G] (p : ℕ) :\n    ∀ {n m : ℕ} [_hp : Fact p.Prime] (_hdvd : p ^ m ∣ Nat.card G) (H : Subgroup G)\n      (_hH : Nat.card H = p ^ n) (_hnm : n ≤ m), ∃ K : Subgroup G, Nat.card K = p ^ m ∧ H ≤ K\n  | n, m => fun {hdvd H hH hnm} =>\n    (lt_or_eq_of_le hnm).elim\n      (fun hnm : n < m =>\n        have h0m : 0 < m := lt_of_le_of_lt n.zero_le hnm\n        have _wf : m - 1 < m := Nat.sub_lt h0m zero_lt_one\n        have hnm1 : n ≤ m - 1 := le_tsub_of_add_le_right hnm\n        let ⟨K, hK⟩ :=\n          @exists_subgroup_card_pow_prime_le _ _ n (m - 1) _\n            (Nat.pow_dvd_of_le_of_pow_dvd tsub_le_self hdvd) H hH hnm1\n        have hdvd' : p ^ (m - 1 + 1) ∣ Nat.card G := by rwa [tsub_add_cancel_of_le h0m.nat_succ_le]\n        let ⟨K', hK'⟩ := @exists_subgroup_card_pow_succ _ _ _ _ _ _ hdvd' K hK.1\n        ⟨K', by rw [hK'.1, tsub_add_cancel_of_le h0m.nat_succ_le], le_trans hK.2 hK'.2⟩)\n      fun hnm : n = m => ⟨H, by simp [hH, hnm]⟩\n\n"}
{"name":"Sylow.exists_subgroup_card_pow_prime","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u\ninst✝² : Group G\ninst✝¹ : Finite G\np n : Nat\ninst✝ : Fact (Nat.Prime p)\nhdvd : Dvd.dvd (HPow.hPow p n) (Nat.card G)\n⊢ Exists fun K => Eq (Nat.card (Subtype fun x => Membership.mem K x)) (HPow.hPow p n)","decl":"/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\n  the cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem exists_subgroup_card_pow_prime [Finite G] (p : ℕ) {n : ℕ} [Fact p.Prime]\n    (hdvd : p ^ n ∣ Nat.card G) : ∃ K : Subgroup G, Nat.card K = p ^ n :=\n  let ⟨K, hK⟩ := exists_subgroup_card_pow_prime_le p hdvd ⊥\n    (by rw [card_bot, pow_zero]) n.zero_le\n  ⟨K, hK.1⟩\n\n"}
{"name":"Sylow.exists_subgroup_card_pow_prime_of_le_card","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u\ninst✝ : Group G\nn p : Nat\nhp : Nat.Prime p\nh : IsPGroup p G\nhn : LE.le (HPow.hPow p n) (Nat.card G)\n⊢ Exists fun H => Eq (Nat.card (Subtype fun x => Membership.mem H x)) (HPow.hPow p n)","decl":"/-- A special case of **Sylow's first theorem**. If `G` is a `p`-group of size at least `p ^ n`\nthen there is a subgroup of cardinality `p ^ n`. -/\nlemma exists_subgroup_card_pow_prime_of_le_card {n p : ℕ} (hp : p.Prime) (h : IsPGroup p G)\n    (hn : p ^ n ≤ Nat.card G) : ∃ H : Subgroup G, Nat.card H = p ^ n := by\n  have : Fact p.Prime := ⟨hp⟩\n  have : Finite G := Nat.finite_of_card_ne_zero <| by linarith [Nat.one_le_pow n p hp.pos]\n  obtain ⟨m, hm⟩ := h.exists_card_eq\n  refine exists_subgroup_card_pow_prime _ ?_\n  rw [hm] at hn ⊢\n  exact pow_dvd_pow _ <| (Nat.pow_le_pow_iff_right hp.one_lt).1 hn\n\n"}
{"name":"Sylow.exists_subgroup_le_card_pow_prime_of_le_card","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u\ninst✝ : Group G\nn p : Nat\nhp : Nat.Prime p\nh : IsPGroup p G\nH : Subgroup G\nhn : LE.le (HPow.hPow p n) (Nat.card (Subtype fun x => Membership.mem H x))\n⊢ Exists fun H' => And (LE.le H' H) (Eq (Nat.card (Subtype fun x => Membership.mem H' x)) (HPow.hPow p n))","decl":"/-- A special case of **Sylow's first theorem**. If `G` is a `p`-group and `H` a subgroup of size at\nleast `p ^ n` then there is a subgroup of `H` of cardinality `p ^ n`. -/\nlemma exists_subgroup_le_card_pow_prime_of_le_card {n p : ℕ} (hp : p.Prime) (h : IsPGroup p G)\n    {H : Subgroup G} (hn : p ^ n ≤ Nat.card H) : ∃ H' ≤ H, Nat.card H' = p ^ n := by\n  obtain ⟨H', H'card⟩ := exists_subgroup_card_pow_prime_of_le_card hp (h.to_subgroup H) hn\n  refine ⟨H'.map H.subtype, map_subtype_le _, ?_⟩\n  rw [← H'card]\n  let e : H' ≃* H'.map H.subtype := H'.equivMapOfInjective (Subgroup.subtype H) H.subtype_injective\n  exact Nat.card_congr e.symm.toEquiv\n\n"}
{"name":"Sylow.exists_subgroup_le_card_le","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u\ninst✝ : Group G\nk p : Nat\nhp : Nat.Prime p\nh : IsPGroup p G\nH : Subgroup G\nhk : LE.le k (Nat.card (Subtype fun x => Membership.mem H x))\nhk₀ : Ne k 0\n⊢ Exists fun H' => And (LE.le H' H) (And (LE.le (Nat.card (Subtype fun x => Membership.mem H' x)) k) (LT.lt k (HMul.hMul p (Nat.card (Subtype fun x => Membership.mem H' x)))))","decl":"/-- A special case of **Sylow's first theorem**. If `G` is a `p`-group and `H` a subgroup of size at\nleast `k` then there is a subgroup of `H` of cardinality between `k / p` and `k`. -/\nlemma exists_subgroup_le_card_le {k p : ℕ} (hp : p.Prime) (h : IsPGroup p G) {H : Subgroup G}\n    (hk : k ≤ Nat.card H) (hk₀ : k ≠ 0) : ∃ H' ≤ H, Nat.card H' ≤ k ∧ k < p * Nat.card H' := by\n  obtain ⟨m, hmk, hkm⟩ : ∃ s, p ^ s ≤ k ∧ k < p ^ (s + 1) :=\n    exists_nat_pow_near (Nat.one_le_iff_ne_zero.2 hk₀) hp.one_lt\n  obtain ⟨H', H'H, H'card⟩ := exists_subgroup_le_card_pow_prime_of_le_card hp h (hmk.trans hk)\n  refine ⟨H', H'H, ?_⟩\n  simpa only [pow_succ', H'card] using And.intro hmk hkm\n\n"}
{"name":"Sylow.pow_dvd_card_of_pow_dvd_card","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u\ninst✝¹ : Group G\ninst✝ : Finite G\np n : Nat\nhp : Fact (Nat.Prime p)\nP : Sylow p G\nhdvd : Dvd.dvd (HPow.hPow p n) (Nat.card G)\n⊢ Dvd.dvd (HPow.hPow p n) (Nat.card (Subtype fun x => Membership.mem (↑P) x))","decl":"theorem pow_dvd_card_of_pow_dvd_card [Finite G] {p n : ℕ} [hp : Fact p.Prime] (P : Sylow p G)\n    (hdvd : p ^ n ∣ Nat.card G) : p ^ n ∣ Nat.card P := by\n  rw [← index_mul_card P.1] at hdvd\n  exact (hp.1.coprime_pow_of_not_dvd P.not_dvd_index).symm.dvd_of_dvd_mul_left hdvd\n\n"}
{"name":"Sylow.dvd_card_of_dvd_card","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u\ninst✝² : Group G\ninst✝¹ : Finite G\np : Nat\ninst✝ : Fact (Nat.Prime p)\nP : Sylow p G\nhdvd : Dvd.dvd p (Nat.card G)\n⊢ Dvd.dvd p (Nat.card (Subtype fun x => Membership.mem (↑P) x))","decl":"theorem dvd_card_of_dvd_card [Finite G] {p : ℕ} [Fact p.Prime] (P : Sylow p G)\n    (hdvd : p ∣ Nat.card G) : p ∣ Nat.card P := by\n  rw [← pow_one p] at hdvd\n  have key := P.pow_dvd_card_of_pow_dvd_card hdvd\n  rwa [pow_one] at key\n\n"}
{"name":"Sylow.card_coprime_index","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u\ninst✝¹ : Group G\ninst✝ : Finite G\np : Nat\nhp : Fact (Nat.Prime p)\nP : Sylow p G\n⊢ (Nat.card (Subtype fun x => Membership.mem (↑P) x)).Coprime (↑P).index","decl":"/-- Sylow subgroups are Hall subgroups. -/\ntheorem card_coprime_index [Finite G] {p : ℕ} [hp : Fact p.Prime] (P : Sylow p G) :\n    (Nat.card P).Coprime P.index :=\n  let ⟨_n, hn⟩ := IsPGroup.iff_card.mp P.2\n  hn.symm ▸ (hp.1.coprime_pow_of_not_dvd P.not_dvd_index).symm\n\n"}
{"name":"Sylow.ne_bot_of_dvd_card","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u\ninst✝¹ : Group G\ninst✝ : Finite G\np : Nat\nhp : Fact (Nat.Prime p)\nP : Sylow p G\nhdvd : Dvd.dvd p (Nat.card G)\n⊢ Ne (↑P) Bot.bot","decl":"theorem ne_bot_of_dvd_card [Finite G] {p : ℕ} [hp : Fact p.Prime] (P : Sylow p G)\n    (hdvd : p ∣ Nat.card G) : (P : Subgroup G) ≠ ⊥ := by\n  refine fun h => hp.out.not_dvd_one ?_\n  have key : p ∣ Nat.card P := P.dvd_card_of_dvd_card hdvd\n  rwa [h, card_bot] at key\n\n"}
{"name":"Sylow.card_eq_multiplicity","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u\ninst✝¹ : Group G\ninst✝ : Finite G\np : Nat\nhp : Fact (Nat.Prime p)\nP : Sylow p G\n⊢ Eq (Nat.card (Subtype fun x => Membership.mem (↑P) x)) (HPow.hPow p ((Nat.card G).factorization p))","decl":"/-- The cardinality of a Sylow subgroup is `p ^ n`\n where `n` is the multiplicity of `p` in the group order. -/\ntheorem card_eq_multiplicity [Finite G] {p : ℕ} [hp : Fact p.Prime] (P : Sylow p G) :\n    Nat.card P = p ^ Nat.factorization (Nat.card G) p := by\n  obtain ⟨n, heq : Nat.card P = _⟩ := IsPGroup.iff_card.mp P.isPGroup'\n  refine Nat.dvd_antisymm ?_ (P.pow_dvd_card_of_pow_dvd_card (Nat.ordProj_dvd _ p))\n  rw [heq, ← hp.out.pow_dvd_iff_dvd_ordProj (show Nat.card G ≠ 0 from Nat.card_pos.ne'), ← heq]\n  exact P.1.card_subgroup_dvd_card\n\n"}
{"name":"Sylow.characteristic_of_normal","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u\ninst✝² : Group G\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Finite (Sylow p G)\nP : Sylow p G\nh : (↑P).Normal\n⊢ (↑P).Characteristic","decl":"theorem characteristic_of_normal {p : ℕ} [Fact p.Prime] [Finite (Sylow p G)] (P : Sylow p G)\n    (h : P.Normal) : P.Characteristic := by\n  haveI := unique_of_normal P h\n  rw [characteristic_iff_map_eq]\n  intro Φ\n  show (Φ • P).toSubgroup = P.toSubgroup\n  congr\n  simp [eq_iff_true_of_subsingleton]\n\n"}
{"name":"Sylow.normal_of_normalizer_normal","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u\ninst✝² : Group G\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Finite (Sylow p G)\nP : Sylow p G\nhn : (↑P).normalizer.Normal\n⊢ (↑P).Normal","decl":"theorem normal_of_normalizer_normal {p : ℕ} [Fact p.Prime] [Finite (Sylow p G)] (P : Sylow p G)\n    (hn : P.normalizer.Normal) : P.Normal := by\n  rw [← normalizer_eq_top_iff, ← normalizer_sup_eq_top' P le_normalizer, sup_idem]\n\n"}
{"name":"Sylow.normalizer_normalizer","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u\ninst✝² : Group G\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Finite (Sylow p G)\nP : Sylow p G\n⊢ Eq (↑P).normalizer.normalizer (↑P).normalizer","decl":"@[simp]\ntheorem normalizer_normalizer {p : ℕ} [Fact p.Prime] [Finite (Sylow p G)] (P : Sylow p G) :\n    P.normalizer.normalizer = P.normalizer := by\n  have := normal_of_normalizer_normal (P.subtype (le_normalizer.trans le_normalizer))\n  simp_rw [← normalizer_eq_top_iff, coe_subtype, ← subgroupOf_normalizer_eq le_normalizer, ←\n    subgroupOf_normalizer_eq le_rfl, subgroupOf_self] at this\n  rw [← range_subtype P.normalizer.normalizer, MonoidHom.range_eq_map,\n    ← this trivial]\n  exact map_comap_eq_self (le_normalizer.trans (ge_of_eq (range_subtype _)))\n\n"}
{"name":"Sylow.normal_of_all_max_subgroups_normal","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u\ninst✝³ : Group G\ninst✝² : Finite G\nhnc : ∀ (H : Subgroup G), IsCoatom H → H.Normal\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Finite (Sylow p G)\nP : Sylow p G\n⊢ (↑P).Normal","decl":"theorem normal_of_all_max_subgroups_normal [Finite G]\n    (hnc : ∀ H : Subgroup G, IsCoatom H → H.Normal) {p : ℕ} [Fact p.Prime] [Finite (Sylow p G)]\n    (P : Sylow p G) : P.Normal :=\n  normalizer_eq_top_iff.mp\n    (by\n      rcases eq_top_or_exists_le_coatom P.normalizer with (heq | ⟨K, hK, hNK⟩)\n      · exact heq\n      · haveI := hnc _ hK\n        have hPK : P ≤ K := le_trans le_normalizer hNK\n        refine (hK.1 ?_).elim\n        rw [← sup_of_le_right hNK, P.normalizer_sup_eq_top' hPK])\n\n"}
{"name":"Sylow.normal_of_normalizerCondition","module":"Mathlib.GroupTheory.Sylow","initialProofState":"G : Type u\ninst✝² : Group G\nhnc : NormalizerCondition G\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Finite (Sylow p G)\nP : Sylow p G\n⊢ (↑P).Normal","decl":"theorem normal_of_normalizerCondition (hnc : NormalizerCondition G) {p : ℕ} [Fact p.Prime]\n    [Finite (Sylow p G)] (P : Sylow p G) : P.Normal :=\n  normalizer_eq_top_iff.mp <|\n    normalizerCondition_iff_only_full_group_self_normalizing.mp hnc _ <| normalizer_normalizer _\n\n"}
