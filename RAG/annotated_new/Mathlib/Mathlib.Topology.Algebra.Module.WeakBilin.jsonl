{"name":"WeakBilin.instIsScalarTower","module":"Mathlib.Topology.Algebra.Module.WeakBilin","initialProofState":"𝕜 : Type u_2\n𝕝 : Type u_3\nE : Type u_4\nF : Type u_5\ninst✝⁷ : CommSemiring 𝕜\ninst✝⁶ : CommSemiring 𝕝\ninst✝⁵ : AddCommMonoid E\ninst✝⁴ : Module 𝕜 E\ninst✝³ : AddCommMonoid F\ninst✝² : Module 𝕜 F\ninst✝¹ : SMul 𝕝 𝕜\ninst✝ : Module 𝕝 E\ns : IsScalarTower 𝕝 𝕜 E\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\n⊢ IsScalarTower 𝕝 𝕜 (WeakBilin B)","decl":"instance instIsScalarTower [CommSemiring 𝕜] [CommSemiring 𝕝] [AddCommMonoid E] [Module 𝕜 E]\n    [AddCommMonoid F] [Module 𝕜 F] [SMul 𝕝 𝕜] [Module 𝕝 E] [s : IsScalarTower 𝕝 𝕜 E]\n    (B : E →ₗ[𝕜] F →ₗ[𝕜] 𝕜) : IsScalarTower 𝕝 𝕜 (WeakBilin B) := s\n\n"}
{"name":"WeakBilin.coeFn_continuous","module":"Mathlib.Topology.Algebra.Module.WeakBilin","initialProofState":"𝕜 : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁵ : TopologicalSpace 𝕜\ninst✝⁴ : CommSemiring 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : Module 𝕜 E\ninst✝¹ : AddCommMonoid F\ninst✝ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\n⊢ Continuous fun x y => (B x) y","decl":"/-- The coercion `(fun x y => B x y) : E → (F → 𝕜)` is continuous. -/\ntheorem coeFn_continuous : Continuous fun (x : WeakBilin B) y => B x y :=\n  continuous_induced_dom\n\n"}
{"name":"WeakBilin.eval_continuous","module":"Mathlib.Topology.Algebra.Module.WeakBilin","initialProofState":"𝕜 : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁵ : TopologicalSpace 𝕜\ninst✝⁴ : CommSemiring 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : Module 𝕜 E\ninst✝¹ : AddCommMonoid F\ninst✝ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\ny : F\n⊢ Continuous fun x => (B x) y","decl":"theorem eval_continuous (y : F) : Continuous fun x : WeakBilin B => B x y :=\n  (continuous_pi_iff.mp (coeFn_continuous B)) y\n\n"}
{"name":"WeakBilin.continuous_of_continuous_eval","module":"Mathlib.Topology.Algebra.Module.WeakBilin","initialProofState":"α : Type u_1\n𝕜 : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁶ : TopologicalSpace 𝕜\ninst✝⁵ : CommSemiring 𝕜\ninst✝⁴ : AddCommMonoid E\ninst✝³ : Module 𝕜 E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\ninst✝ : TopologicalSpace α\ng : α → WeakBilin B\nh : ∀ (y : F), Continuous fun a => (B (g a)) y\n⊢ Continuous g","decl":"theorem continuous_of_continuous_eval [TopologicalSpace α] {g : α → WeakBilin B}\n    (h : ∀ y, Continuous fun a => B (g a) y) : Continuous g :=\n  continuous_induced_rng.2 (continuous_pi_iff.mpr h)\n\n"}
{"name":"WeakBilin.isEmbedding","module":"Mathlib.Topology.Algebra.Module.WeakBilin","initialProofState":"𝕜 : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁵ : TopologicalSpace 𝕜\ninst✝⁴ : CommSemiring 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : Module 𝕜 E\ninst✝¹ : AddCommMonoid F\ninst✝ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\nhB : Function.Injective ⇑B\n⊢ Topology.IsEmbedding fun x y => (B x) y","decl":"/-- The coercion `(fun x y => B x y) : E → (F → 𝕜)` is an embedding. -/\ntheorem isEmbedding {B : E →ₗ[𝕜] F →ₗ[𝕜] 𝕜} (hB : Function.Injective B) :\n    IsEmbedding fun (x : WeakBilin B) y => B x y :=\n  Function.Injective.isEmbedding_induced <| LinearMap.coe_injective.comp hB\n\n"}
{"name":"WeakBilin.embedding","module":"Mathlib.Topology.Algebra.Module.WeakBilin","initialProofState":"𝕜 : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁵ : TopologicalSpace 𝕜\ninst✝⁴ : CommSemiring 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : Module 𝕜 E\ninst✝¹ : AddCommMonoid F\ninst✝ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\nhB : Function.Injective ⇑B\n⊢ Topology.IsEmbedding fun x y => (B x) y","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding := isEmbedding\n\n"}
{"name":"WeakBilin.tendsto_iff_forall_eval_tendsto","module":"Mathlib.Topology.Algebra.Module.WeakBilin","initialProofState":"α : Type u_1\n𝕜 : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁵ : TopologicalSpace 𝕜\ninst✝⁴ : CommSemiring 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : Module 𝕜 E\ninst✝¹ : AddCommMonoid F\ninst✝ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\nl : Filter α\nf : α → WeakBilin B\nx : WeakBilin B\nhB : Function.Injective ⇑B\n⊢ Iff (Filter.Tendsto f l (nhds x)) (∀ (y : F), Filter.Tendsto (fun i => (B (f i)) y) l (nhds ((B x) y)))","decl":"theorem tendsto_iff_forall_eval_tendsto {l : Filter α} {f : α → WeakBilin B} {x : WeakBilin B}\n    (hB : Function.Injective B) :\n    Tendsto f l (𝓝 x) ↔ ∀ y, Tendsto (fun i => B (f i) y) l (𝓝 (B x y)) := by\n  rw [← tendsto_pi_nhds, (isEmbedding hB).tendsto_nhds_iff]\n  rfl\n\n"}
{"name":"WeakBilin.instContinuousAdd","module":"Mathlib.Topology.Algebra.Module.WeakBilin","initialProofState":"𝕜 : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁶ : TopologicalSpace 𝕜\ninst✝⁵ : CommSemiring 𝕜\ninst✝⁴ : AddCommMonoid E\ninst✝³ : Module 𝕜 E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\ninst✝ : ContinuousAdd 𝕜\n⊢ ContinuousAdd (WeakBilin B)","decl":"/-- Addition in `WeakBilin B` is continuous. -/\ninstance instContinuousAdd [ContinuousAdd 𝕜] : ContinuousAdd (WeakBilin B) := by\n  refine ⟨continuous_induced_rng.2 ?_⟩\n  refine\n    cast (congr_arg _ ?_)\n      (((coeFn_continuous B).comp continuous_fst).add ((coeFn_continuous B).comp continuous_snd))\n  ext\n  simp only [Function.comp_apply, Pi.add_apply, map_add, LinearMap.add_apply]\n\n"}
{"name":"WeakBilin.instContinuousSMul","module":"Mathlib.Topology.Algebra.Module.WeakBilin","initialProofState":"𝕜 : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁶ : TopologicalSpace 𝕜\ninst✝⁵ : CommSemiring 𝕜\ninst✝⁴ : AddCommMonoid E\ninst✝³ : Module 𝕜 E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\ninst✝ : ContinuousSMul 𝕜 𝕜\n⊢ ContinuousSMul 𝕜 (WeakBilin B)","decl":"/-- Scalar multiplication by `𝕜` on `WeakBilin B` is continuous. -/\ninstance instContinuousSMul [ContinuousSMul 𝕜 𝕜] : ContinuousSMul 𝕜 (WeakBilin B) := by\n  refine ⟨continuous_induced_rng.2 ?_⟩\n  refine cast (congr_arg _ ?_) (continuous_fst.smul ((coeFn_continuous B).comp continuous_snd))\n  ext\n  simp only [Function.comp_apply, Pi.smul_apply, LinearMap.map_smulₛₗ, RingHom.id_apply,\n    LinearMap.smul_apply]\n\n"}
{"name":"WeakBilin.instTopologicalAddGroup","module":"Mathlib.Topology.Algebra.Module.WeakBilin","initialProofState":"𝕜 : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁶ : TopologicalSpace 𝕜\ninst✝⁵ : CommRing 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : AddCommGroup F\ninst✝¹ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\ninst✝ : ContinuousAdd 𝕜\n⊢ TopologicalAddGroup (WeakBilin B)","decl":"/-- `WeakBilin B` is a `TopologicalAddGroup`, meaning that addition and negation are\ncontinuous. -/\ninstance instTopologicalAddGroup [ContinuousAdd 𝕜] : TopologicalAddGroup (WeakBilin B) where\n  toContinuousAdd := by infer_instance\n  continuous_neg := by\n    refine continuous_induced_rng.2 (continuous_pi_iff.mpr fun y => ?_)\n    refine cast (congr_arg _ ?_) (eval_continuous B (-y))\n    ext x\n    simp only [map_neg, Function.comp_apply, LinearMap.neg_apply]\n\n"}
