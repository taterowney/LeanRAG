{"name":"Mon_Class.mul_one'","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\nself : Mon_Class X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X Mon_Class.one) Mon_Class.mul) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom","decl":"/-- A monoid object internal to a monoidal category.\n\nWhen the monoidal category is preadditive, this is also sometimes called an \"algebra object\".\n-/\nclass Mon_Class (X : C) where\n  /-- The unit morphism of a monoid object. -/\n  one : ùüô_ C ‚ü∂ X\n  /-- The multiplication morphism of a monoid object. -/\n  mul : X ‚äó X ‚ü∂ X\n  /- For the names of the conditions below, the unprimed names are reserved for the version where\n  the argument `X` is explicit. -/\n  one_mul' : one ‚ñ∑ X ‚â´ mul = (Œª_ X).hom := by aesop_cat\n  mul_one' : X ‚óÅ one ‚â´ mul = (œÅ_ X).hom := by aesop_cat\n  -- Obviously there is some flexibility stating this axiom.\n  -- This one has left- and right-hand sides matching the statement of `Monoid.mul_assoc`,\n  -- and chooses to place the associator on the right-hand side.\n  -- The heuristic is that unitors and associators \"don't have much weight\".\n  mul_assoc' : (mul ‚ñ∑ X) ‚â´ mul = (Œ±_ X X X).hom ‚â´ (X ‚óÅ mul) ‚â´ mul := by aesop_cat\n\n"}
{"name":"Mon_Class.mul_assoc'","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\nself : Mon_Class X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight Mon_Class.mul X) Mon_Class.mul) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X X X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X Mon_Class.mul) Mon_Class.mul))","decl":"/-- A monoid object internal to a monoidal category.\n\nWhen the monoidal category is preadditive, this is also sometimes called an \"algebra object\".\n-/\nclass Mon_Class (X : C) where\n  /-- The unit morphism of a monoid object. -/\n  one : ùüô_ C ‚ü∂ X\n  /-- The multiplication morphism of a monoid object. -/\n  mul : X ‚äó X ‚ü∂ X\n  /- For the names of the conditions below, the unprimed names are reserved for the version where\n  the argument `X` is explicit. -/\n  one_mul' : one ‚ñ∑ X ‚â´ mul = (Œª_ X).hom := by aesop_cat\n  mul_one' : X ‚óÅ one ‚â´ mul = (œÅ_ X).hom := by aesop_cat\n  -- Obviously there is some flexibility stating this axiom.\n  -- This one has left- and right-hand sides matching the statement of `Monoid.mul_assoc`,\n  -- and chooses to place the associator on the right-hand side.\n  -- The heuristic is that unitors and associators \"don't have much weight\".\n  mul_assoc' : (mul ‚ñ∑ X) ‚â´ mul = (Œ±_ X X X).hom ‚â´ (X ‚óÅ mul) ‚â´ mul := by aesop_cat\n\n"}
{"name":"Mon_Class.one_mul'","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\nself : Mon_Class X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight Mon_Class.one X) Mon_Class.mul) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom","decl":"/-- A monoid object internal to a monoidal category.\n\nWhen the monoidal category is preadditive, this is also sometimes called an \"algebra object\".\n-/\nclass Mon_Class (X : C) where\n  /-- The unit morphism of a monoid object. -/\n  one : ùüô_ C ‚ü∂ X\n  /-- The multiplication morphism of a monoid object. -/\n  mul : X ‚äó X ‚ü∂ X\n  /- For the names of the conditions below, the unprimed names are reserved for the version where\n  the argument `X` is explicit. -/\n  one_mul' : one ‚ñ∑ X ‚â´ mul = (Œª_ X).hom := by aesop_cat\n  mul_one' : X ‚óÅ one ‚â´ mul = (œÅ_ X).hom := by aesop_cat\n  -- Obviously there is some flexibility stating this axiom.\n  -- This one has left- and right-hand sides matching the statement of `Monoid.mul_assoc`,\n  -- and chooses to place the associator on the right-hand side.\n  -- The heuristic is that unitors and associators \"don't have much weight\".\n  mul_assoc' : (mul ‚ñ∑ X) ‚â´ mul = (Œ±_ X X X).hom ‚â´ (X ‚óÅ mul) ‚â´ mul := by aesop_cat\n\n"}
{"name":"Mon_Class.one_mul'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\nself : Mon_Class X\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight Mon_Class.one X) (CategoryTheory.CategoryStruct.comp Mon_Class.mul h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom h)","decl":"attribute [reassoc] one_mul' mul_one' mul_assoc'\n\n"}
{"name":"Mon_Class.mul_assoc'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\nself : Mon_Class X\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight Mon_Class.mul X) (CategoryTheory.CategoryStruct.comp Mon_Class.mul h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X X X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X Mon_Class.mul) (CategoryTheory.CategoryStruct.comp Mon_Class.mul h)))","decl":"attribute [reassoc] one_mul' mul_one' mul_assoc'\n\n"}
{"name":"Mon_Class.mul_one'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\nself : Mon_Class X\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X Mon_Class.one) (CategoryTheory.CategoryStruct.comp Mon_Class.mul h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom h)","decl":"attribute [reassoc] one_mul' mul_one' mul_assoc'\n\n"}
{"name":"Mon_Class.one_mul_assoc","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX : C\ninst‚úù : Mon_Class X\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight Mon_Class.one X) (CategoryTheory.CategoryStruct.comp Mon_Class.mul h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom h)","decl":"@[reassoc (attr := simp)]\ntheorem one_mul (X : C) [Mon_Class X] : Œ∑ ‚ñ∑ X ‚â´ Œº = (Œª_ X).hom := one_mul'\n\n"}
{"name":"Mon_Class.one_mul","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX : C\ninst‚úù : Mon_Class X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight Mon_Class.one X) Mon_Class.mul) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom","decl":"@[reassoc (attr := simp)]\ntheorem one_mul (X : C) [Mon_Class X] : Œ∑ ‚ñ∑ X ‚â´ Œº = (Œª_ X).hom := one_mul'\n\n"}
{"name":"Mon_Class.mul_one_assoc","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX : C\ninst‚úù : Mon_Class X\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X Mon_Class.one) (CategoryTheory.CategoryStruct.comp Mon_Class.mul h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom h)","decl":"@[reassoc (attr := simp)]\ntheorem mul_one (X : C) [Mon_Class X] : X ‚óÅ Œ∑ ‚â´ Œº = (œÅ_ X).hom := mul_one'\n\n"}
{"name":"Mon_Class.mul_one","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX : C\ninst‚úù : Mon_Class X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X Mon_Class.one) Mon_Class.mul) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom","decl":"@[reassoc (attr := simp)]\ntheorem mul_one (X : C) [Mon_Class X] : X ‚óÅ Œ∑ ‚â´ Œº = (œÅ_ X).hom := mul_one'\n\n"}
{"name":"Mon_Class.mul_assoc","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX : C\ninst‚úù : Mon_Class X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight Mon_Class.mul X) Mon_Class.mul) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X X X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X Mon_Class.mul) Mon_Class.mul))","decl":"@[reassoc (attr := simp)]\ntheorem mul_assoc (X : C) [Mon_Class X] : Œº ‚ñ∑ X ‚â´ Œº = (Œ±_ X X X).hom ‚â´ X ‚óÅ Œº ‚â´ Œº := mul_assoc'\n\n"}
{"name":"Mon_Class.mul_assoc_assoc","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX : C\ninst‚úù : Mon_Class X\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight Mon_Class.mul X) (CategoryTheory.CategoryStruct.comp Mon_Class.mul h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X X X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X Mon_Class.mul) (CategoryTheory.CategoryStruct.comp Mon_Class.mul h)))","decl":"@[reassoc (attr := simp)]\ntheorem mul_assoc (X : C) [Mon_Class X] : Œº ‚ñ∑ X ‚â´ Œº = (Œ±_ X X X).hom ‚â´ X ‚óÅ Œº ‚â´ Œº := mul_assoc'\n\n"}
{"name":"IsMon_Hom.one_hom","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\nM N : C\ninst‚úù¬π : Mon_Class M\ninst‚úù : Mon_Class N\nf : Quiver.Hom M N\nself : IsMon_Hom f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.one f) Mon_Class.one","decl":"/-- The property that a morphism between monoid objects is a monoid morphism. -/\nclass IsMon_Hom (f : M ‚ü∂ N) : Prop where\n  one_hom : Œ∑ ‚â´ f = Œ∑ := by aesop_cat\n  mul_hom : Œº ‚â´ f = (f ‚äó f) ‚â´ Œº := by aesop_cat\n\n"}
{"name":"IsMon_Hom.mul_hom","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\nM N : C\ninst‚úù¬π : Mon_Class M\ninst‚úù : Mon_Class N\nf : Quiver.Hom M N\nself : IsMon_Hom f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.mul f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f f) Mon_Class.mul)","decl":"/-- The property that a morphism between monoid objects is a monoid morphism. -/\nclass IsMon_Hom (f : M ‚ü∂ N) : Prop where\n  one_hom : Œ∑ ‚â´ f = Œ∑ := by aesop_cat\n  mul_hom : Œº ‚â´ f = (f ‚äó f) ‚â´ Œº := by aesop_cat\n\n"}
{"name":"IsMon_Hom.one_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\nM N : C\ninst‚úù¬π : Mon_Class M\ninst‚úù : Mon_Class N\nf : Quiver.Hom M N\nself : IsMon_Hom f\nZ : C\nh : Quiver.Hom N Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.one (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp Mon_Class.one h)","decl":"attribute [reassoc (attr := simp)] IsMon_Hom.one_hom IsMon_Hom.mul_hom\n\n"}
{"name":"IsMon_Hom.mul_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\nM N : C\ninst‚úù¬π : Mon_Class M\ninst‚úù : Mon_Class N\nf : Quiver.Hom M N\nself : IsMon_Hom f\nZ : C\nh : Quiver.Hom N Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.mul (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f f) (CategoryTheory.CategoryStruct.comp Mon_Class.mul h))","decl":"attribute [reassoc (attr := simp)] IsMon_Hom.one_hom IsMon_Hom.mul_hom\n\n"}
{"name":"Mon_.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : SizeOf C\nX : C\none : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit X\nmul : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X X) X\none_mul : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight one X) mul) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) _auto‚úù\nmul_one : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X one) mul) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) _auto‚úù\nmul_assoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight mul X) mul) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X X X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X mul) mul))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { X := X, one := one, mul := mul, one_mul := one_mul, mul_one := mul_one, mul_assoc := mul_assoc }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf X)) (SizeOf.sizeOf one)) (SizeOf.sizeOf mul)) (SizeOf.sizeOf one_mul)) (SizeOf.sizeOf mul_one)) (SizeOf.sizeOf mul_assoc))","decl":"/-- A monoid object internal to a monoidal category.\n\nWhen the monoidal category is preadditive, this is also sometimes called an \"algebra object\".\n-/\nstructure Mon_ where\n  X : C\n  one : ùüô_ C ‚ü∂ X\n  mul : X ‚äó X ‚ü∂ X\n  one_mul : (one ‚ñ∑ X) ‚â´ mul = (Œª_ X).hom := by aesop_cat\n  mul_one : (X ‚óÅ one) ‚â´ mul = (œÅ_ X).hom := by aesop_cat\n  -- Obviously there is some flexibility stating this axiom.\n  -- This one has left- and right-hand sides matching the statement of `Monoid.mul_assoc`,\n  -- and chooses to place the associator on the right-hand side.\n  -- The heuristic is that unitors and associators \"don't have much weight\".\n  mul_assoc : (mul ‚ñ∑ X) ‚â´ mul = (Œ±_ X X X).hom ‚â´ (X ‚óÅ mul) ‚â´ mul := by aesop_cat\n\n"}
{"name":"Mon_.one_mul","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nself : Mon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.one self.X) self.mul) (CategoryTheory.MonoidalCategoryStruct.leftUnitor self.X).hom","decl":"/-- A monoid object internal to a monoidal category.\n\nWhen the monoidal category is preadditive, this is also sometimes called an \"algebra object\".\n-/\nstructure Mon_ where\n  X : C\n  one : ùüô_ C ‚ü∂ X\n  mul : X ‚äó X ‚ü∂ X\n  one_mul : (one ‚ñ∑ X) ‚â´ mul = (Œª_ X).hom := by aesop_cat\n  mul_one : (X ‚óÅ one) ‚â´ mul = (œÅ_ X).hom := by aesop_cat\n  -- Obviously there is some flexibility stating this axiom.\n  -- This one has left- and right-hand sides matching the statement of `Monoid.mul_assoc`,\n  -- and chooses to place the associator on the right-hand side.\n  -- The heuristic is that unitors and associators \"don't have much weight\".\n  mul_assoc : (mul ‚ñ∑ X) ‚â´ mul = (Œ±_ X X X).hom ‚â´ (X ‚óÅ mul) ‚â´ mul := by aesop_cat\n\n"}
{"name":"Mon_.mul_assoc","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nself : Mon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.mul self.X) self.mul) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator self.X self.X self.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft self.X self.mul) self.mul))","decl":"/-- A monoid object internal to a monoidal category.\n\nWhen the monoidal category is preadditive, this is also sometimes called an \"algebra object\".\n-/\nstructure Mon_ where\n  X : C\n  one : ùüô_ C ‚ü∂ X\n  mul : X ‚äó X ‚ü∂ X\n  one_mul : (one ‚ñ∑ X) ‚â´ mul = (Œª_ X).hom := by aesop_cat\n  mul_one : (X ‚óÅ one) ‚â´ mul = (œÅ_ X).hom := by aesop_cat\n  -- Obviously there is some flexibility stating this axiom.\n  -- This one has left- and right-hand sides matching the statement of `Monoid.mul_assoc`,\n  -- and chooses to place the associator on the right-hand side.\n  -- The heuristic is that unitors and associators \"don't have much weight\".\n  mul_assoc : (mul ‚ñ∑ X) ‚â´ mul = (Œ±_ X X X).hom ‚â´ (X ‚óÅ mul) ‚â´ mul := by aesop_cat\n\n"}
{"name":"Mon_.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚úù : C\none‚úù : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit X‚úù\nmul‚úù : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X‚úù X‚úù) X‚úù\none_mul‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight one‚úù X‚úù) mul‚úù) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X‚úù).hom) _auto‚úù\nmul_one‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X‚úù one‚úù) mul‚úù) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X‚úù).hom) _auto‚úù\nmul_assoc‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight mul‚úù X‚úù) mul‚úù) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X‚úù X‚úù X‚úù).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X‚úù mul‚úù) mul‚úù))) _auto‚úù\nX : C\none : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit X\nmul : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X X) X\none_mul : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight one X) mul) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) _auto‚úù\nmul_one : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X one) mul) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) _auto‚úù\nmul_assoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight mul X) mul) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X X X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X mul) mul))) _auto‚úù\n‚ä¢ Eq (Eq { X := X‚úù, one := one‚úù, mul := mul‚úù, one_mul := one_mul‚úù, mul_one := mul_one‚úù, mul_assoc := mul_assoc‚úù } { X := X, one := one, mul := mul, one_mul := one_mul, mul_one := mul_one, mul_assoc := mul_assoc }) (And (Eq X‚úù X) (And (HEq one‚úù one) (HEq mul‚úù mul)))","decl":"/-- A monoid object internal to a monoidal category.\n\nWhen the monoidal category is preadditive, this is also sometimes called an \"algebra object\".\n-/\nstructure Mon_ where\n  X : C\n  one : ùüô_ C ‚ü∂ X\n  mul : X ‚äó X ‚ü∂ X\n  one_mul : (one ‚ñ∑ X) ‚â´ mul = (Œª_ X).hom := by aesop_cat\n  mul_one : (X ‚óÅ one) ‚â´ mul = (œÅ_ X).hom := by aesop_cat\n  -- Obviously there is some flexibility stating this axiom.\n  -- This one has left- and right-hand sides matching the statement of `Monoid.mul_assoc`,\n  -- and chooses to place the associator on the right-hand side.\n  -- The heuristic is that unitors and associators \"don't have much weight\".\n  mul_assoc : (mul ‚ñ∑ X) ‚â´ mul = (Œ±_ X X X).hom ‚â´ (X ‚óÅ mul) ‚â´ mul := by aesop_cat\n\n"}
{"name":"Mon_.mul_one","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nself : Mon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft self.X self.one) self.mul) (CategoryTheory.MonoidalCategoryStruct.rightUnitor self.X).hom","decl":"/-- A monoid object internal to a monoidal category.\n\nWhen the monoidal category is preadditive, this is also sometimes called an \"algebra object\".\n-/\nstructure Mon_ where\n  X : C\n  one : ùüô_ C ‚ü∂ X\n  mul : X ‚äó X ‚ü∂ X\n  one_mul : (one ‚ñ∑ X) ‚â´ mul = (Œª_ X).hom := by aesop_cat\n  mul_one : (X ‚óÅ one) ‚â´ mul = (œÅ_ X).hom := by aesop_cat\n  -- Obviously there is some flexibility stating this axiom.\n  -- This one has left- and right-hand sides matching the statement of `Monoid.mul_assoc`,\n  -- and chooses to place the associator on the right-hand side.\n  -- The heuristic is that unitors and associators \"don't have much weight\".\n  mul_assoc : (mul ‚ñ∑ X) ‚â´ mul = (Œ±_ X X X).hom ‚â´ (X ‚óÅ mul) ‚â´ mul := by aesop_cat\n\n"}
{"name":"Mon_.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚úù : C\none‚úù : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit X‚úù\nmul‚úù : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X‚úù X‚úù) X‚úù\none_mul‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight one‚úù X‚úù) mul‚úù) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X‚úù).hom) _auto‚úù\nmul_one‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X‚úù one‚úù) mul‚úù) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X‚úù).hom) _auto‚úù\nmul_assoc‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight mul‚úù X‚úù) mul‚úù) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X‚úù X‚úù X‚úù).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X‚úù mul‚úù) mul‚úù))) _auto‚úù\nX : C\none : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit X\nmul : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X X) X\none_mul : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight one X) mul) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) _auto‚úù\nmul_one : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X one) mul) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) _auto‚úù\nmul_assoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight mul X) mul) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X X X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X mul) mul))) _auto‚úù\nx‚úù : Eq { X := X‚úù, one := one‚úù, mul := mul‚úù, one_mul := one_mul‚úù, mul_one := mul_one‚úù, mul_assoc := mul_assoc‚úù } { X := X, one := one, mul := mul, one_mul := one_mul, mul_one := mul_one, mul_assoc := mul_assoc }\n‚ä¢ And (Eq X‚úù X) (And (HEq one‚úù one) (HEq mul‚úù mul))","decl":"/-- A monoid object internal to a monoidal category.\n\nWhen the monoidal category is preadditive, this is also sometimes called an \"algebra object\".\n-/\nstructure Mon_ where\n  X : C\n  one : ùüô_ C ‚ü∂ X\n  mul : X ‚äó X ‚ü∂ X\n  one_mul : (one ‚ñ∑ X) ‚â´ mul = (Œª_ X).hom := by aesop_cat\n  mul_one : (X ‚óÅ one) ‚â´ mul = (œÅ_ X).hom := by aesop_cat\n  -- Obviously there is some flexibility stating this axiom.\n  -- This one has left- and right-hand sides matching the statement of `Monoid.mul_assoc`,\n  -- and chooses to place the associator on the right-hand side.\n  -- The heuristic is that unitors and associators \"don't have much weight\".\n  mul_assoc : (mul ‚ñ∑ X) ‚â´ mul = (Œ±_ X X X).hom ‚â´ (X ‚óÅ mul) ‚â´ mul := by aesop_cat\n\n"}
{"name":"Mon_.mul_one_assoc","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nself : Mon_ C\nZ : C\nh : Quiver.Hom self.X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft self.X self.one) (CategoryTheory.CategoryStruct.comp self.mul h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor self.X).hom h)","decl":"attribute [reassoc] Mon_.one_mul Mon_.mul_one\n\n"}
{"name":"Mon_.one_mul_assoc","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nself : Mon_ C\nZ : C\nh : Quiver.Hom self.X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.one self.X) (CategoryTheory.CategoryStruct.comp self.mul h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor self.X).hom h)","decl":"attribute [reassoc] Mon_.one_mul Mon_.mul_one\n\n"}
{"name":"Mon_.mul_assoc_assoc","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nself : Mon_ C\nZ : C\nh : Quiver.Hom self.X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.mul self.X) (CategoryTheory.CategoryStruct.comp self.mul h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator self.X self.X self.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft self.X self.mul) (CategoryTheory.CategoryStruct.comp self.mul h)))","decl":"attribute [reassoc (attr := simp)] Mon_.mul_assoc\n\n"}
{"name":"Mon_.mk'_one","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX : C\ninst‚úù : Mon_Class X\n‚ä¢ Eq (Mon_.mk' X).one Mon_Class.one","decl":"/-- Construct an object of `Mon_ C` from an object `X : C` and `Mon_Class X` instance. -/\n@[simps]\ndef mk' (X : C) [Mon_Class X] : Mon_ C where\n  X := X\n  one := Œ∑\n  mul := Œº\n\n"}
{"name":"Mon_.mk'_X","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX : C\ninst‚úù : Mon_Class X\n‚ä¢ Eq (Mon_.mk' X).X X","decl":"/-- Construct an object of `Mon_ C` from an object `X : C` and `Mon_Class X` instance. -/\n@[simps]\ndef mk' (X : C) [Mon_Class X] : Mon_ C where\n  X := X\n  one := Œ∑\n  mul := Œº\n\n"}
{"name":"Mon_.mk'_mul","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX : C\ninst‚úù : Mon_Class X\n‚ä¢ Eq (Mon_.mk' X).mul Mon_Class.mul","decl":"/-- Construct an object of `Mon_ C` from an object `X : C` and `Mon_Class X` instance. -/\n@[simps]\ndef mk' (X : C) [Mon_Class X] : Mon_ C where\n  X := X\n  one := Œ∑\n  mul := Œº\n\n"}
{"name":"Mon_.trivial_X","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ Eq (Mon_.trivial C).X CategoryTheory.MonoidalCategoryStruct.tensorUnit","decl":"/-- The trivial monoid object. We later show this is initial in `Mon_ C`.\n-/\n@[simps]\ndef trivial : Mon_ C where\n  X := ùüô_ C\n  one := ùüô _\n  mul := (Œª_ _).hom\n  mul_assoc := by monoidal_coherence\n  mul_one := by monoidal_coherence\n\n"}
{"name":"Mon_.trivial_one","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ Eq (Mon_.trivial C).one (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"/-- The trivial monoid object. We later show this is initial in `Mon_ C`.\n-/\n@[simps]\ndef trivial : Mon_ C where\n  X := ùüô_ C\n  one := ùüô _\n  mul := (Œª_ _).hom\n  mul_assoc := by monoidal_coherence\n  mul_one := by monoidal_coherence\n\n"}
{"name":"Mon_.trivial_mul","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ Eq (Mon_.trivial C).mul (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom","decl":"/-- The trivial monoid object. We later show this is initial in `Mon_ C`.\n-/\n@[simps]\ndef trivial : Mon_ C where\n  X := ùüô_ C\n  one := ùüô _\n  mul := (Œª_ _).hom\n  mul_assoc := by monoidal_coherence\n  mul_one := by monoidal_coherence\n\n"}
{"name":"Mon_.one_mul_hom","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM : Mon_ C\nZ : C\nf : Quiver.Hom Z M.X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom M.one f) M.mul) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor Z).hom f)","decl":"@[simp]\ntheorem one_mul_hom {Z : C} (f : Z ‚ü∂ M.X) : (M.one ‚äó f) ‚â´ M.mul = (Œª_ Z).hom ‚â´ f := by\n  rw [tensorHom_def'_assoc, M.one_mul, leftUnitor_naturality]\n\n"}
{"name":"Mon_.mul_one_hom","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM : Mon_ C\nZ : C\nf : Quiver.Hom Z M.X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f M.one) M.mul) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor Z).hom f)","decl":"@[simp]\ntheorem mul_one_hom {Z : C} (f : Z ‚ü∂ M.X) : (f ‚äó M.one) ‚â´ M.mul = (œÅ_ Z).hom ‚â´ f := by\n  rw [tensorHom_def_assoc, M.mul_one, rightUnitor_naturality]\n\n"}
{"name":"Mon_.mul_assoc_flip","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM : Mon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X M.mul) M.mul) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator M.X M.X M.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight M.mul M.X) M.mul))","decl":"theorem mul_assoc_flip :\n    (M.X ‚óÅ M.mul) ‚â´ M.mul = (Œ±_ M.X M.X M.X).inv ‚â´ (M.mul ‚ñ∑ M.X) ‚â´ M.mul := by simp\n\n"}
{"name":"Mon_.Hom.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N : Mon_ C\nhom‚úù : Quiver.Hom M.X N.X\none_hom‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.one hom‚úù) N.one) _auto‚úù\nmul_hom‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.mul hom‚úù) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom hom‚úù hom‚úù) N.mul)) _auto‚úù\nhom : Quiver.Hom M.X N.X\none_hom : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.one hom) N.one) _auto‚úù\nmul_hom : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.mul hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom hom hom) N.mul)) _auto‚úù\nx‚úù : Eq { hom := hom‚úù, one_hom := one_hom‚úù, mul_hom := mul_hom‚úù } { hom := hom, one_hom := one_hom, mul_hom := mul_hom }\n‚ä¢ Eq hom‚úù hom","decl":"/-- A morphism of monoid objects. -/\n@[ext]\nstructure Hom (M N : Mon_ C) where\n  hom : M.X ‚ü∂ N.X\n  one_hom : M.one ‚â´ hom = N.one := by aesop_cat\n  mul_hom : M.mul ‚â´ hom = (hom ‚äó hom) ‚â´ N.mul := by aesop_cat\n\n"}
{"name":"Mon_.Hom.mul_hom","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N : Mon_ C\nself : M.Hom N\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp M.mul self.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom self.hom self.hom) N.mul)","decl":"/-- A morphism of monoid objects. -/\n@[ext]\nstructure Hom (M N : Mon_ C) where\n  hom : M.X ‚ü∂ N.X\n  one_hom : M.one ‚â´ hom = N.one := by aesop_cat\n  mul_hom : M.mul ‚â´ hom = (hom ‚äó hom) ‚â´ N.mul := by aesop_cat\n\n"}
{"name":"Mon_.Hom.ext","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N : Mon_ C\nx y : M.Hom N\nhom : Eq x.hom y.hom\n‚ä¢ Eq x y","decl":"/-- A morphism of monoid objects. -/\n@[ext]\nstructure Hom (M N : Mon_ C) where\n  hom : M.X ‚ü∂ N.X\n  one_hom : M.one ‚â´ hom = N.one := by aesop_cat\n  mul_hom : M.mul ‚â´ hom = (hom ‚äó hom) ‚â´ N.mul := by aesop_cat\n\n"}
{"name":"Mon_.Hom.one_hom","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N : Mon_ C\nself : M.Hom N\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp M.one self.hom) N.one","decl":"/-- A morphism of monoid objects. -/\n@[ext]\nstructure Hom (M N : Mon_ C) where\n  hom : M.X ‚ü∂ N.X\n  one_hom : M.one ‚â´ hom = N.one := by aesop_cat\n  mul_hom : M.mul ‚â´ hom = (hom ‚äó hom) ‚â´ N.mul := by aesop_cat\n\n"}
{"name":"Mon_.Hom.ext_iff","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N : Mon_ C\nx y : M.Hom N\n‚ä¢ Iff (Eq x y) (Eq x.hom y.hom)","decl":"/-- A morphism of monoid objects. -/\n@[ext]\nstructure Hom (M N : Mon_ C) where\n  hom : M.X ‚ü∂ N.X\n  one_hom : M.one ‚â´ hom = N.one := by aesop_cat\n  mul_hom : M.mul ‚â´ hom = (hom ‚äó hom) ‚â´ N.mul := by aesop_cat\n\n"}
{"name":"Mon_.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nM N : Mon_ C\ninst‚úù : SizeOf C\nhom : Quiver.Hom M.X N.X\none_hom : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.one hom) N.one) _auto‚úù\nmul_hom : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.mul hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom hom hom) N.mul)) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { hom := hom, one_hom := one_hom, mul_hom := mul_hom }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf hom)) (SizeOf.sizeOf one_hom)) (SizeOf.sizeOf mul_hom))","decl":"/-- A morphism of monoid objects. -/\n@[ext]\nstructure Hom (M N : Mon_ C) where\n  hom : M.X ‚ü∂ N.X\n  one_hom : M.one ‚â´ hom = N.one := by aesop_cat\n  mul_hom : M.mul ‚â´ hom = (hom ‚äó hom) ‚â´ N.mul := by aesop_cat\n\n"}
{"name":"Mon_.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N : Mon_ C\nhom‚úù : Quiver.Hom M.X N.X\none_hom‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.one hom‚úù) N.one) _auto‚úù\nmul_hom‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.mul hom‚úù) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom hom‚úù hom‚úù) N.mul)) _auto‚úù\nhom : Quiver.Hom M.X N.X\none_hom : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.one hom) N.one) _auto‚úù\nmul_hom : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.mul hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom hom hom) N.mul)) _auto‚úù\n‚ä¢ Eq (Eq { hom := hom‚úù, one_hom := one_hom‚úù, mul_hom := mul_hom‚úù } { hom := hom, one_hom := one_hom, mul_hom := mul_hom }) (Eq hom‚úù hom)","decl":"/-- A morphism of monoid objects. -/\n@[ext]\nstructure Hom (M N : Mon_ C) where\n  hom : M.X ‚ü∂ N.X\n  one_hom : M.one ‚â´ hom = N.one := by aesop_cat\n  mul_hom : M.mul ‚â´ hom = (hom ‚äó hom) ‚â´ N.mul := by aesop_cat\n\n"}
{"name":"Mon_.Hom.mul_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N : Mon_ C\nself : M.Hom N\nZ : C\nh : Quiver.Hom N.X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp M.mul (CategoryTheory.CategoryStruct.comp self.hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom self.hom self.hom) (CategoryTheory.CategoryStruct.comp N.mul h))","decl":"attribute [reassoc (attr := simp)] Hom.one_hom Hom.mul_hom\n\n"}
{"name":"Mon_.Hom.one_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N : Mon_ C\nself : M.Hom N\nZ : C\nh : Quiver.Hom N.X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp M.one (CategoryTheory.CategoryStruct.comp self.hom h)) (CategoryTheory.CategoryStruct.comp N.one h)","decl":"attribute [reassoc (attr := simp)] Hom.one_hom Hom.mul_hom\n\n"}
{"name":"Mon_.id_hom","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM : Mon_ C\n‚ä¢ Eq M.id.hom (CategoryTheory.CategoryStruct.id M.X)","decl":"/-- The identity morphism on a monoid object. -/\n@[simps]\ndef id (M : Mon_ C) : Hom M M where\n  hom := ùüô M.X\n\n"}
{"name":"Mon_.comp_hom","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N O : Mon_ C\nf : M.Hom N\ng : N.Hom O\n‚ä¢ Eq (Mon_.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"/-- Composition of morphisms of monoid objects. -/\n@[simps]\ndef comp {M N O : Mon_ C} (f : Hom M N) (g : Hom N O) : Hom M O where\n  hom := f.hom ‚â´ g.hom\n\n"}
{"name":"Mon_.ext","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y : Mon_ C\nf g : Quiver.Hom X Y\nw : Eq f.hom g.hom\n‚ä¢ Eq f g","decl":"@[ext]\nlemma ext {X Y : Mon_ C} {f g : X ‚ü∂ Y} (w : f.hom = g.hom) : f = g :=\n  Hom.ext w\n\n"}
{"name":"Mon_.ext_iff","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y : Mon_ C\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (Eq f.hom g.hom)","decl":"@[ext]\nlemma ext {X Y : Mon_ C} {f g : X ‚ü∂ Y} (w : f.hom = g.hom) : f = g :=\n  Hom.ext w\n\n"}
{"name":"Mon_.id_hom'","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM : Mon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id M).hom (CategoryTheory.CategoryStruct.id M.X)","decl":"@[simp]\ntheorem id_hom' (M : Mon_ C) : (ùüô M : Hom M M).hom = ùüô M.X :=\n  rfl\n\n"}
{"name":"Mon_.comp_hom'","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N K : Mon_ C\nf : Quiver.Hom M N\ng : Quiver.Hom N K\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"@[simp]\ntheorem comp_hom' {M N K : Mon_ C} (f : M ‚ü∂ N) (g : N ‚ü∂ K) :\n    (f ‚â´ g : Hom M K).hom = f.hom ‚â´ g.hom :=\n  rfl\n\n"}
{"name":"Mon_.forget_map","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚úù Y‚úù : Mon_ C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((Mon_.forget C).map f) f.hom","decl":"/-- The forgetful functor from monoid objects to the ambient category. -/\n@[simps]\ndef forget : Mon_ C ‚•§ C where\n  obj A := A.X\n  map f := f.hom\n\n"}
{"name":"Mon_.forget_obj","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\n‚ä¢ Eq ((Mon_.forget C).obj A) A.X","decl":"/-- The forgetful functor from monoid objects to the ambient category. -/\n@[simps]\ndef forget : Mon_ C ‚•§ C where\n  obj A := A.X\n  map f := f.hom\n\n"}
{"name":"Mon_.forget_faithful","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ (Mon_.forget C).Faithful","decl":"instance forget_faithful : (forget C).Faithful where\n\n"}
{"name":"Mon_.instIsIsoHomOfMapForget","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nf : Quiver.Hom A B\ne : CategoryTheory.IsIso ((Mon_.forget C).map f)\n‚ä¢ CategoryTheory.IsIso f.hom","decl":"instance {A B : Mon_ C} (f : A ‚ü∂ B) [e : IsIso ((forget C).map f)] : IsIso f.hom :=\n  e\n\n"}
{"name":"Mon_.instReflectsIsomorphismsForget","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ (Mon_.forget C).ReflectsIsomorphisms","decl":"/-- The forgetful functor from monoid objects to the ambient category reflects isomorphisms. -/\ninstance : (forget C).ReflectsIsomorphisms where\n  reflects f e := ‚ü®‚ü®{ hom := inv f.hom }, by aesop_cat‚ü©‚ü©\n\n"}
{"name":"Mon_.mkIso_inv_hom","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N : Mon_ C\nf : CategoryTheory.Iso M.X N.X\none_f : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.one f.hom) N.one) _auto‚úù\nmul_f : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.mul f.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f.hom f.hom) N.mul)) _auto‚úù\n‚ä¢ Eq (Mon_.mkIso f one_f mul_f).inv.hom f.inv","decl":"/-- Construct an isomorphism of monoids by giving an isomorphism between the underlying objects\nand checking compatibility with unit and multiplication only in the forward direction.\n-/\n@[simps]\ndef mkIso {M N : Mon_ C} (f : M.X ‚âÖ N.X) (one_f : M.one ‚â´ f.hom = N.one := by aesop_cat)\n    (mul_f : M.mul ‚â´ f.hom = (f.hom ‚äó f.hom) ‚â´ N.mul := by aesop_cat) : M ‚âÖ N where\n  hom := { hom := f.hom }\n  inv :=\n  { hom := f.inv\n    one_hom := by rw [‚Üê one_f]; simp\n    mul_hom := by\n      rw [‚Üê cancel_mono f.hom]\n      slice_rhs 2 3 => rw [mul_f]\n      simp }\n\n"}
{"name":"Mon_.mkIso_hom_hom","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N : Mon_ C\nf : CategoryTheory.Iso M.X N.X\none_f : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.one f.hom) N.one) _auto‚úù\nmul_f : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.mul f.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f.hom f.hom) N.mul)) _auto‚úù\n‚ä¢ Eq (Mon_.mkIso f one_f mul_f).hom.hom f.hom","decl":"/-- Construct an isomorphism of monoids by giving an isomorphism between the underlying objects\nand checking compatibility with unit and multiplication only in the forward direction.\n-/\n@[simps]\ndef mkIso {M N : Mon_ C} (f : M.X ‚âÖ N.X) (one_f : M.one ‚â´ f.hom = N.one := by aesop_cat)\n    (mul_f : M.mul ‚â´ f.hom = (f.hom ‚äó f.hom) ‚â´ N.mul := by aesop_cat) : M ‚âÖ N where\n  hom := { hom := f.hom }\n  inv :=\n  { hom := f.inv\n    one_hom := by rw [‚Üê one_f]; simp\n    mul_hom := by\n      rw [‚Üê cancel_mono f.hom]\n      slice_rhs 2 3 => rw [mul_f]\n      simp }\n\n"}
{"name":"Mon_.uniqueHomFromTrivial_default_hom","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\n‚ä¢ Eq Inhabited.default.hom A.one","decl":"@[simps]\ninstance uniqueHomFromTrivial (A : Mon_ C) : Unique (trivial C ‚ü∂ A) where\n  default :=\n  { hom := A.one\n    mul_hom := by simp [A.one_mul, unitors_equal] }\n  uniq f := by\n    ext\n    simp only [trivial_X]\n    rw [‚Üê Category.id_comp f.hom]\n    erw [f.one_hom]\n\n"}
{"name":"Mon_.instHasInitial","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ CategoryTheory.Limits.HasInitial (Mon_ C)","decl":"instance : HasInitial (Mon_ C) :=\n  hasInitial_of_unique (trivial C)\n\n"}
{"name":"CategoryTheory.Functor.mapMon_obj_one","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst‚úù : F.LaxMonoidal\nA : Mon_ C\n‚ä¢ Eq (F.mapMon.obj A).one (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Œµ F) (F.map A.one))","decl":"/-- A lax monoidal functor takes monoid objects to monoid objects.\n\nThat is, a lax monoidal functor `F : C ‚•§ D` induces a functor `Mon_ C ‚•§ Mon_ D`.\n-/\n@[simps]\ndef mapMon (F : C ‚•§ D) [F.LaxMonoidal] : Mon_ C ‚•§ Mon_ D where\n  obj A :=\n    { X := F.obj A.X\n      one := Œµ F ‚â´ F.map A.one\n      mul := ¬´Œº¬ª F _ _ ‚â´ F.map A.mul\n      one_mul := by\n        simp_rw [comp_whiskerRight, Category.assoc, Œº_natural_left_assoc,\n          LaxMonoidal.left_unitality]\n        slice_lhs 3 4 => rw [‚Üê F.map_comp, A.one_mul]\n      mul_one := by\n        simp_rw [MonoidalCategory.whiskerLeft_comp, Category.assoc, Œº_natural_right_assoc,\n          LaxMonoidal.right_unitality]\n        slice_lhs 3 4 => rw [‚Üê F.map_comp, A.mul_one]\n      mul_assoc := by\n        simp_rw [comp_whiskerRight, Category.assoc, Œº_natural_left_assoc,\n          MonoidalCategory.whiskerLeft_comp, Category.assoc, Œº_natural_right_assoc]\n        slice_lhs 3 4 => rw [‚Üê F.map_comp, A.mul_assoc]\n        simp }\n  map f :=\n    { hom := F.map f.hom\n      one_hom := by dsimp; rw [Category.assoc, ‚Üê F.map_comp, f.one_hom]\n      mul_hom := by\n        rw [Category.assoc, Œº_natural_assoc, ‚Üê F.map_comp, ‚Üê F.map_comp,\n          f.mul_hom] }\n  map_id _ := by -- the `aesop_cat` autoparam solves this but it's slow\n    simp only [Mon_.id_hom', map_id]\n    rfl\n  map_comp _ _ := by -- the `aesop_cat` autoparam solves this but it's slow\n    simp only [Mon_.comp_hom', map_comp]\n    rfl\n\n"}
{"name":"CategoryTheory.Functor.mapMon_map_hom","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst‚úù : F.LaxMonoidal\nX‚úù Y‚úù : Mon_ C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (F.mapMon.map f).hom (F.map f.hom)","decl":"/-- A lax monoidal functor takes monoid objects to monoid objects.\n\nThat is, a lax monoidal functor `F : C ‚•§ D` induces a functor `Mon_ C ‚•§ Mon_ D`.\n-/\n@[simps]\ndef mapMon (F : C ‚•§ D) [F.LaxMonoidal] : Mon_ C ‚•§ Mon_ D where\n  obj A :=\n    { X := F.obj A.X\n      one := Œµ F ‚â´ F.map A.one\n      mul := ¬´Œº¬ª F _ _ ‚â´ F.map A.mul\n      one_mul := by\n        simp_rw [comp_whiskerRight, Category.assoc, Œº_natural_left_assoc,\n          LaxMonoidal.left_unitality]\n        slice_lhs 3 4 => rw [‚Üê F.map_comp, A.one_mul]\n      mul_one := by\n        simp_rw [MonoidalCategory.whiskerLeft_comp, Category.assoc, Œº_natural_right_assoc,\n          LaxMonoidal.right_unitality]\n        slice_lhs 3 4 => rw [‚Üê F.map_comp, A.mul_one]\n      mul_assoc := by\n        simp_rw [comp_whiskerRight, Category.assoc, Œº_natural_left_assoc,\n          MonoidalCategory.whiskerLeft_comp, Category.assoc, Œº_natural_right_assoc]\n        slice_lhs 3 4 => rw [‚Üê F.map_comp, A.mul_assoc]\n        simp }\n  map f :=\n    { hom := F.map f.hom\n      one_hom := by dsimp; rw [Category.assoc, ‚Üê F.map_comp, f.one_hom]\n      mul_hom := by\n        rw [Category.assoc, Œº_natural_assoc, ‚Üê F.map_comp, ‚Üê F.map_comp,\n          f.mul_hom] }\n  map_id _ := by -- the `aesop_cat` autoparam solves this but it's slow\n    simp only [Mon_.id_hom', map_id]\n    rfl\n  map_comp _ _ := by -- the `aesop_cat` autoparam solves this but it's slow\n    simp only [Mon_.comp_hom', map_comp]\n    rfl\n\n"}
{"name":"CategoryTheory.Functor.mapMon_obj_mul","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst‚úù : F.LaxMonoidal\nA : Mon_ C\n‚ä¢ Eq (F.mapMon.obj A).mul (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Œº F A.X A.X) (F.map A.mul))","decl":"/-- A lax monoidal functor takes monoid objects to monoid objects.\n\nThat is, a lax monoidal functor `F : C ‚•§ D` induces a functor `Mon_ C ‚•§ Mon_ D`.\n-/\n@[simps]\ndef mapMon (F : C ‚•§ D) [F.LaxMonoidal] : Mon_ C ‚•§ Mon_ D where\n  obj A :=\n    { X := F.obj A.X\n      one := Œµ F ‚â´ F.map A.one\n      mul := ¬´Œº¬ª F _ _ ‚â´ F.map A.mul\n      one_mul := by\n        simp_rw [comp_whiskerRight, Category.assoc, Œº_natural_left_assoc,\n          LaxMonoidal.left_unitality]\n        slice_lhs 3 4 => rw [‚Üê F.map_comp, A.one_mul]\n      mul_one := by\n        simp_rw [MonoidalCategory.whiskerLeft_comp, Category.assoc, Œº_natural_right_assoc,\n          LaxMonoidal.right_unitality]\n        slice_lhs 3 4 => rw [‚Üê F.map_comp, A.mul_one]\n      mul_assoc := by\n        simp_rw [comp_whiskerRight, Category.assoc, Œº_natural_left_assoc,\n          MonoidalCategory.whiskerLeft_comp, Category.assoc, Œº_natural_right_assoc]\n        slice_lhs 3 4 => rw [‚Üê F.map_comp, A.mul_assoc]\n        simp }\n  map f :=\n    { hom := F.map f.hom\n      one_hom := by dsimp; rw [Category.assoc, ‚Üê F.map_comp, f.one_hom]\n      mul_hom := by\n        rw [Category.assoc, Œº_natural_assoc, ‚Üê F.map_comp, ‚Üê F.map_comp,\n          f.mul_hom] }\n  map_id _ := by -- the `aesop_cat` autoparam solves this but it's slow\n    simp only [Mon_.id_hom', map_id]\n    rfl\n  map_comp _ _ := by -- the `aesop_cat` autoparam solves this but it's slow\n    simp only [Mon_.comp_hom', map_comp]\n    rfl\n\n"}
{"name":"CategoryTheory.Functor.mapMon_obj_X","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst‚úù : F.LaxMonoidal\nA : Mon_ C\n‚ä¢ Eq (F.mapMon.obj A).X (F.obj A.X)","decl":"/-- A lax monoidal functor takes monoid objects to monoid objects.\n\nThat is, a lax monoidal functor `F : C ‚•§ D` induces a functor `Mon_ C ‚•§ Mon_ D`.\n-/\n@[simps]\ndef mapMon (F : C ‚•§ D) [F.LaxMonoidal] : Mon_ C ‚•§ Mon_ D where\n  obj A :=\n    { X := F.obj A.X\n      one := Œµ F ‚â´ F.map A.one\n      mul := ¬´Œº¬ª F _ _ ‚â´ F.map A.mul\n      one_mul := by\n        simp_rw [comp_whiskerRight, Category.assoc, Œº_natural_left_assoc,\n          LaxMonoidal.left_unitality]\n        slice_lhs 3 4 => rw [‚Üê F.map_comp, A.one_mul]\n      mul_one := by\n        simp_rw [MonoidalCategory.whiskerLeft_comp, Category.assoc, Œº_natural_right_assoc,\n          LaxMonoidal.right_unitality]\n        slice_lhs 3 4 => rw [‚Üê F.map_comp, A.mul_one]\n      mul_assoc := by\n        simp_rw [comp_whiskerRight, Category.assoc, Œº_natural_left_assoc,\n          MonoidalCategory.whiskerLeft_comp, Category.assoc, Œº_natural_right_assoc]\n        slice_lhs 3 4 => rw [‚Üê F.map_comp, A.mul_assoc]\n        simp }\n  map f :=\n    { hom := F.map f.hom\n      one_hom := by dsimp; rw [Category.assoc, ‚Üê F.map_comp, f.one_hom]\n      mul_hom := by\n        rw [Category.assoc, Œº_natural_assoc, ‚Üê F.map_comp, ‚Üê F.map_comp,\n          f.mul_hom] }\n  map_id _ := by -- the `aesop_cat` autoparam solves this but it's slow\n    simp only [Mon_.id_hom', map_id]\n    rfl\n  map_comp _ _ := by -- the `aesop_cat` autoparam solves this but it's slow\n    simp only [Mon_.comp_hom', map_comp]\n    rfl\n\n"}
{"name":"CategoryTheory.Functor.mapMonFunctor_map_app_hom","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nX‚úù Y‚úù : CategoryTheory.LaxMonoidalFunctor C D\nŒ± : Quiver.Hom X‚úù Y‚úù\nA : Mon_ C\n‚ä¢ Eq (((CategoryTheory.Functor.mapMonFunctor C D).map Œ±).app A).hom (Œ±.hom.app A.X)","decl":"/-- `mapMon` is functorial in the lax monoidal functor. -/\n@[simps] -- Porting note: added this, not sure how it worked previously without.\ndef mapMonFunctor : LaxMonoidalFunctor C D ‚•§ Mon_ C ‚•§ Mon_ D where\n  obj F := F.mapMon\n  map Œ± := { app := fun A => { hom := Œ±.hom.app A.X } }\n  map_comp _ _ := rfl\n\n"}
{"name":"CategoryTheory.Functor.mapMonFunctor_obj","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.LaxMonoidalFunctor C D\n‚ä¢ Eq ((CategoryTheory.Functor.mapMonFunctor C D).obj F) F.mapMon","decl":"/-- `mapMon` is functorial in the lax monoidal functor. -/\n@[simps] -- Porting note: added this, not sure how it worked previously without.\ndef mapMonFunctor : LaxMonoidalFunctor C D ‚•§ Mon_ C ‚•§ Mon_ D where\n  obj F := F.mapMon\n  map Œ± := { app := fun A => { hom := Œ±.hom.app A.X } }\n  map_comp _ _ := rfl\n\n"}
{"name":"Mon_.EquivLaxMonoidalFunctorPUnit.laxMonoidalToMon_map","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚úù Y‚úù : CategoryTheory.LaxMonoidalFunctor (CategoryTheory.Discrete PUnit.{u + 1}) C\nŒ± : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((Mon_.EquivLaxMonoidalFunctorPUnit.laxMonoidalToMon C).map Œ±) (((CategoryTheory.Functor.mapMonFunctor (CategoryTheory.Discrete PUnit.{u + 1}) C).map Œ±).app (Mon_.trivial (CategoryTheory.Discrete PUnit.{u + 1})))","decl":"/-- Implementation of `Mon_.equivLaxMonoidalFunctorPUnit`. -/\n@[simps]\ndef laxMonoidalToMon : LaxMonoidalFunctor (Discrete PUnit.{u + 1}) C ‚•§ Mon_ C where\n  obj F := (F.mapMon : Mon_ _ ‚•§ Mon_ C).obj (trivial (Discrete PUnit))\n  map Œ± := ((Functor.mapMonFunctor (Discrete PUnit) C).map Œ±).app _\n\n"}
{"name":"Mon_.EquivLaxMonoidalFunctorPUnit.laxMonoidalToMon_obj","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nF : CategoryTheory.LaxMonoidalFunctor (CategoryTheory.Discrete PUnit.{u + 1}) C\n‚ä¢ Eq ((Mon_.EquivLaxMonoidalFunctorPUnit.laxMonoidalToMon C).obj F) (F.mapMon.obj (Mon_.trivial (CategoryTheory.Discrete PUnit.{u + 1})))","decl":"/-- Implementation of `Mon_.equivLaxMonoidalFunctorPUnit`. -/\n@[simps]\ndef laxMonoidalToMon : LaxMonoidalFunctor (Discrete PUnit.{u + 1}) C ‚•§ Mon_ C where\n  obj F := (F.mapMon : Mon_ _ ‚•§ Mon_ C).obj (trivial (Discrete PUnit))\n  map Œ± := ((Functor.mapMonFunctor (Discrete PUnit) C).map Œ±).app _\n\n"}
{"name":"Mon_.EquivLaxMonoidalFunctorPUnit.monToLaxMonoidalObj_obj","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nx‚úù : CategoryTheory.Discrete PUnit.{u + 1}\n‚ä¢ Eq ((Mon_.EquivLaxMonoidalFunctorPUnit.monToLaxMonoidalObj A).obj x‚úù) A.X","decl":"/-- Implementation of `Mon_.equivLaxMonoidalFunctorPUnit`. -/\n@[simps!]\ndef monToLaxMonoidalObj (A : Mon_ C) :\n    Discrete PUnit.{u + 1} ‚•§ C := (Functor.const _).obj A.X\n\n"}
{"name":"Mon_.EquivLaxMonoidalFunctorPUnit.monToLaxMonoidalObj_map","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nX‚úù Y‚úù : CategoryTheory.Discrete PUnit.{u + 1}\nx‚úù : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((Mon_.EquivLaxMonoidalFunctorPUnit.monToLaxMonoidalObj A).map x‚úù) (CategoryTheory.CategoryStruct.id A.X)","decl":"/-- Implementation of `Mon_.equivLaxMonoidalFunctorPUnit`. -/\n@[simps!]\ndef monToLaxMonoidalObj (A : Mon_ C) :\n    Discrete PUnit.{u + 1} ‚•§ C := (Functor.const _).obj A.X\n\n"}
{"name":"Mon_.EquivLaxMonoidalFunctorPUnit.monToLaxMonoidalObj_Œµ","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\n‚ä¢ Eq (CategoryTheory.Functor.LaxMonoidal.Œµ (Mon_.EquivLaxMonoidalFunctorPUnit.monToLaxMonoidalObj A)) A.one","decl":"@[simp]\nlemma monToLaxMonoidalObj_Œµ (A : Mon_ C) :\n    Œµ (monToLaxMonoidalObj A) = A.one := rfl\n\n"}
{"name":"Mon_.EquivLaxMonoidalFunctorPUnit.monToLaxMonoidalObj_Œº","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nX Y : CategoryTheory.Discrete PUnit.{u_1 + 1}\n‚ä¢ Eq (CategoryTheory.Functor.LaxMonoidal.Œº (Mon_.EquivLaxMonoidalFunctorPUnit.monToLaxMonoidalObj A) X Y) A.mul","decl":"@[simp]\nlemma monToLaxMonoidalObj_Œº (A : Mon_ C) (X Y) :\n    ¬´Œº¬ª (monToLaxMonoidalObj A) X Y = A.mul := rfl\n\n"}
{"name":"Mon_.EquivLaxMonoidalFunctorPUnit.monToLaxMonoidal_map_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚úù Y‚úù : Mon_ C\nf : Quiver.Hom X‚úù Y‚úù\nx‚úù : CategoryTheory.Discrete PUnit.{u + 1}\n‚ä¢ Eq (((Mon_.EquivLaxMonoidalFunctorPUnit.monToLaxMonoidal C).map f).hom.app x‚úù) f.hom","decl":"/-- Implementation of `Mon_.equivLaxMonoidalFunctorPUnit`. -/\n@[simps]\ndef monToLaxMonoidal : Mon_ C ‚•§ LaxMonoidalFunctor (Discrete PUnit.{u + 1}) C where\n  obj A := LaxMonoidalFunctor.of (monToLaxMonoidalObj A)\n  map f :=\n    { hom := { app := fun _ => f.hom }\n      isMonoidal := { } }\n\n"}
{"name":"Mon_.EquivLaxMonoidalFunctorPUnit.monToLaxMonoidal_obj","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\n‚ä¢ Eq ((Mon_.EquivLaxMonoidalFunctorPUnit.monToLaxMonoidal C).obj A) (CategoryTheory.LaxMonoidalFunctor.of (Mon_.EquivLaxMonoidalFunctorPUnit.monToLaxMonoidalObj A))","decl":"/-- Implementation of `Mon_.equivLaxMonoidalFunctorPUnit`. -/\n@[simps]\ndef monToLaxMonoidal : Mon_ C ‚•§ LaxMonoidalFunctor (Discrete PUnit.{u + 1}) C where\n  obj A := LaxMonoidalFunctor.of (monToLaxMonoidalObj A)\n  map f :=\n    { hom := { app := fun _ => f.hom }\n      isMonoidal := { } }\n\n"}
{"name":"Mon_.EquivLaxMonoidalFunctorPUnit.unitIso_inv_app_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚úù : CategoryTheory.LaxMonoidalFunctor (CategoryTheory.Discrete PUnit.{u + 1}) C\nX : CategoryTheory.Discrete PUnit.{u + 1}\n‚ä¢ Eq (((Mon_.EquivLaxMonoidalFunctorPUnit.unitIso C).inv.app X‚úù).hom.app X) (CategoryTheory.CategoryStruct.id (X‚úù.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit))","decl":"/-- Implementation of `Mon_.equivLaxMonoidalFunctorPUnit`. -/\n@[simps!]\ndef unitIso :\n    ùü≠ (LaxMonoidalFunctor (Discrete PUnit.{u + 1}) C) ‚âÖ laxMonoidalToMon C ‚ãô monToLaxMonoidal C :=\n  NatIso.ofComponents\n    (fun F ‚Ü¶ LaxMonoidalFunctor.isoOfComponents (fun _ ‚Ü¶ F.mapIso (eqToIso (by ext))))\n\n"}
{"name":"Mon_.EquivLaxMonoidalFunctorPUnit.unitIso_hom_app_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚úù : CategoryTheory.LaxMonoidalFunctor (CategoryTheory.Discrete PUnit.{u + 1}) C\nX : CategoryTheory.Discrete PUnit.{u + 1}\n‚ä¢ Eq (((Mon_.EquivLaxMonoidalFunctorPUnit.unitIso C).hom.app X‚úù).hom.app X) (CategoryTheory.CategoryStruct.id (X‚úù.obj X))","decl":"/-- Implementation of `Mon_.equivLaxMonoidalFunctorPUnit`. -/\n@[simps!]\ndef unitIso :\n    ùü≠ (LaxMonoidalFunctor (Discrete PUnit.{u + 1}) C) ‚âÖ laxMonoidalToMon C ‚ãô monToLaxMonoidal C :=\n  NatIso.ofComponents\n    (fun F ‚Ü¶ LaxMonoidalFunctor.isoOfComponents (fun _ ‚Ü¶ F.mapIso (eqToIso (by ext))))\n\n"}
{"name":"Mon_.EquivLaxMonoidalFunctorPUnit.counitIso_inv_app_hom","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : Mon_ C\n‚ä¢ Eq ((Mon_.EquivLaxMonoidalFunctorPUnit.counitIso C).inv.app X).hom (CategoryTheory.CategoryStruct.id X.X)","decl":"/-- Implementation of `Mon_.equivLaxMonoidalFunctorPUnit`. -/\n@[simps!]\ndef counitIso : monToLaxMonoidal C ‚ãô laxMonoidalToMon C ‚âÖ ùü≠ (Mon_ C) :=\n  NatIso.ofComponents (fun F ‚Ü¶ mkIso (Iso.refl _))\n\n"}
{"name":"Mon_.EquivLaxMonoidalFunctorPUnit.counitIso_hom_app_hom","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : Mon_ C\n‚ä¢ Eq ((Mon_.EquivLaxMonoidalFunctorPUnit.counitIso C).hom.app X).hom (CategoryTheory.CategoryStruct.id X.X)","decl":"/-- Implementation of `Mon_.equivLaxMonoidalFunctorPUnit`. -/\n@[simps!]\ndef counitIso : monToLaxMonoidal C ‚ãô laxMonoidalToMon C ‚âÖ ùü≠ (Mon_ C) :=\n  NatIso.ofComponents (fun F ‚Ü¶ mkIso (Iso.refl _))\n\n"}
{"name":"Mon_.equivLaxMonoidalFunctorPUnit_counitIso","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ Eq (Mon_.equivLaxMonoidalFunctorPUnit C).counitIso (Mon_.EquivLaxMonoidalFunctorPUnit.counitIso C)","decl":"/--\nMonoid objects in `C` are \"just\" lax monoidal functors from the trivial monoidal category to `C`.\n-/\n@[simps]\ndef equivLaxMonoidalFunctorPUnit : LaxMonoidalFunctor (Discrete PUnit.{u + 1}) C ‚âå Mon_ C where\n  functor := laxMonoidalToMon C\n  inverse := monToLaxMonoidal C\n  unitIso := unitIso C\n  counitIso := counitIso C\n\n"}
{"name":"Mon_.equivLaxMonoidalFunctorPUnit_unitIso","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ Eq (Mon_.equivLaxMonoidalFunctorPUnit C).unitIso (Mon_.EquivLaxMonoidalFunctorPUnit.unitIso C)","decl":"/--\nMonoid objects in `C` are \"just\" lax monoidal functors from the trivial monoidal category to `C`.\n-/\n@[simps]\ndef equivLaxMonoidalFunctorPUnit : LaxMonoidalFunctor (Discrete PUnit.{u + 1}) C ‚âå Mon_ C where\n  functor := laxMonoidalToMon C\n  inverse := monToLaxMonoidal C\n  unitIso := unitIso C\n  counitIso := counitIso C\n\n"}
{"name":"Mon_.equivLaxMonoidalFunctorPUnit_functor","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ Eq (Mon_.equivLaxMonoidalFunctorPUnit C).functor (Mon_.EquivLaxMonoidalFunctorPUnit.laxMonoidalToMon C)","decl":"/--\nMonoid objects in `C` are \"just\" lax monoidal functors from the trivial monoidal category to `C`.\n-/\n@[simps]\ndef equivLaxMonoidalFunctorPUnit : LaxMonoidalFunctor (Discrete PUnit.{u + 1}) C ‚âå Mon_ C where\n  functor := laxMonoidalToMon C\n  inverse := monToLaxMonoidal C\n  unitIso := unitIso C\n  counitIso := counitIso C\n\n"}
{"name":"Mon_.equivLaxMonoidalFunctorPUnit_inverse","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ Eq (Mon_.equivLaxMonoidalFunctorPUnit C).inverse (Mon_.EquivLaxMonoidalFunctorPUnit.monToLaxMonoidal C)","decl":"/--\nMonoid objects in `C` are \"just\" lax monoidal functors from the trivial monoidal category to `C`.\n-/\n@[simps]\ndef equivLaxMonoidalFunctorPUnit : LaxMonoidalFunctor (Discrete PUnit.{u + 1}) C ‚âå Mon_ C where\n  functor := laxMonoidalToMon C\n  inverse := monToLaxMonoidal C\n  unitIso := unitIso C\n  counitIso := counitIso C\n\n"}
{"name":"Mon_.one_associator","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N P : Mon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom M.one N.one)) P.one)) (CategoryTheory.MonoidalCategoryStruct.associator M.X N.X P.X).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom M.one (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom N.one P.one))))","decl":"theorem one_associator {M N P : Mon_ C} :\n    ((Œª_ (ùüô_ C)).inv ‚â´ ((Œª_ (ùüô_ C)).inv ‚â´ (M.one ‚äó N.one) ‚äó P.one)) ‚â´ (Œ±_ M.X N.X P.X).hom =\n      (Œª_ (ùüô_ C)).inv ‚â´ (M.one ‚äó (Œª_ (ùüô_ C)).inv ‚â´ (N.one ‚äó P.one)) := by\n  simp only [Category.assoc, Iso.cancel_iso_inv_left]\n  slice_lhs 1 3 => rw [‚Üê Category.id_comp P.one, tensor_comp]\n  slice_lhs 2 3 => rw [associator_naturality]\n  slice_rhs 1 2 => rw [‚Üê Category.id_comp M.one, tensor_comp]\n  slice_lhs 1 2 => rw [tensorHom_id, ‚Üê leftUnitor_tensor_inv]\n  rw [‚Üê cancel_epi (Œª_ (ùüô_ C)).inv]\n  slice_lhs 1 2 => rw [leftUnitor_inv_naturality]\n  simp\n\n"}
{"name":"Mon_.one_leftUnitor","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM : Mon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit) M.one)) (CategoryTheory.MonoidalCategoryStruct.leftUnitor M.X).hom) M.one","decl":"theorem one_leftUnitor {M : Mon_ C} :\n    ((Œª_ (ùüô_ C)).inv ‚â´ (ùüô (ùüô_ C) ‚äó M.one)) ‚â´ (Œª_ M.X).hom = M.one := by\n  simp\n\n"}
{"name":"Mon_.one_rightUnitor","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM : Mon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom M.one (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit))) (CategoryTheory.MonoidalCategoryStruct.rightUnitor M.X).hom) M.one","decl":"theorem one_rightUnitor {M : Mon_ C} :\n    ((Œª_ (ùüô_ C)).inv ‚â´ (M.one ‚äó ùüô (ùüô_ C))) ‚â´ (œÅ_ M.X).hom = M.one := by\n  simp [‚Üê unitors_equal]\n\n"}
{"name":"Mon_.Mon_tensor_one_mul","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM N : Mon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom M.one N.one)) (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X N.X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorŒº M.X N.X M.X N.X) (CategoryTheory.MonoidalCategoryStruct.tensorHom M.mul N.mul))) (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X N.X)).hom","decl":"theorem Mon_tensor_one_mul (M N : Mon_ C) :\n    (((Œª_ (ùüô_ C)).inv ‚â´ (M.one ‚äó N.one)) ‚ñ∑ (M.X ‚äó N.X)) ‚â´\n        tensorŒº M.X N.X M.X N.X ‚â´ (M.mul ‚äó N.mul) =\n      (Œª_ (M.X ‚äó N.X)).hom := by\n  simp only [comp_whiskerRight_assoc]\n  slice_lhs 2 3 => rw [tensorŒº_natural_left]\n  slice_lhs 3 4 => rw [‚Üê tensor_comp, one_mul M, one_mul N]\n  symm\n  exact tensor_left_unitality M.X N.X\n\n"}
{"name":"Mon_.Mon_tensor_mul_one","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM N : Mon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X N.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom M.one N.one))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorŒº M.X N.X M.X N.X) (CategoryTheory.MonoidalCategoryStruct.tensorHom M.mul N.mul))) (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X N.X)).hom","decl":"theorem Mon_tensor_mul_one (M N : Mon_ C) :\n    (M.X ‚äó N.X) ‚óÅ ((Œª_ (ùüô_ C)).inv ‚â´ (M.one ‚äó N.one)) ‚â´\n        tensorŒº M.X N.X M.X N.X ‚â´ (M.mul ‚äó N.mul) =\n      (œÅ_ (M.X ‚äó N.X)).hom := by\n  simp only [MonoidalCategory.whiskerLeft_comp_assoc]\n  slice_lhs 2 3 => rw [tensorŒº_natural_right]\n  slice_lhs 3 4 => rw [‚Üê tensor_comp, mul_one M, mul_one N]\n  symm\n  exact tensor_right_unitality M.X N.X\n\n"}
{"name":"Mon_.Mon_tensor_mul_assoc","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM N : Mon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorŒº M.X N.X M.X N.X) (CategoryTheory.MonoidalCategoryStruct.tensorHom M.mul N.mul)) (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X N.X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorŒº M.X N.X M.X N.X) (CategoryTheory.MonoidalCategoryStruct.tensorHom M.mul N.mul))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X N.X) (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X N.X) (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X N.X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X N.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorŒº M.X N.X M.X N.X) (CategoryTheory.MonoidalCategoryStruct.tensorHom M.mul N.mul))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorŒº M.X N.X M.X N.X) (CategoryTheory.MonoidalCategoryStruct.tensorHom M.mul N.mul))))","decl":"theorem Mon_tensor_mul_assoc (M N : Mon_ C) :\n    ((tensorŒº M.X N.X M.X N.X ‚â´ (M.mul ‚äó N.mul)) ‚ñ∑ (M.X ‚äó N.X)) ‚â´\n        tensorŒº M.X N.X M.X N.X ‚â´ (M.mul ‚äó N.mul) =\n      (Œ±_ (M.X ‚äó N.X) (M.X ‚äó N.X) (M.X ‚äó N.X)).hom ‚â´\n        ((M.X ‚äó N.X) ‚óÅ (tensorŒº M.X N.X M.X N.X ‚â´ (M.mul ‚äó N.mul))) ‚â´\n          tensorŒº M.X N.X M.X N.X ‚â´ (M.mul ‚äó N.mul) := by\n  simp only [comp_whiskerRight_assoc, MonoidalCategory.whiskerLeft_comp_assoc]\n  slice_lhs 2 3 => rw [tensorŒº_natural_left]\n  slice_lhs 3 4 => rw [‚Üê tensor_comp, mul_assoc M, mul_assoc N, tensor_comp, tensor_comp]\n  slice_lhs 1 3 => rw [tensor_associativity]\n  slice_lhs 3 4 => rw [‚Üê tensorŒº_natural_right]\n  simp\n\n"}
{"name":"Mon_.mul_associator","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM N P : Mon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorŒº (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X N.X) P.X (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X N.X) P.X) (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorŒº M.X N.X M.X N.X) (CategoryTheory.MonoidalCategoryStruct.tensorHom M.mul N.mul)) P.mul)) (CategoryTheory.MonoidalCategoryStruct.associator M.X N.X P.X).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.associator M.X N.X P.X).hom (CategoryTheory.MonoidalCategoryStruct.associator M.X N.X P.X).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorŒº M.X (CategoryTheory.MonoidalCategoryStruct.tensorObj N.X P.X) M.X (CategoryTheory.MonoidalCategoryStruct.tensorObj N.X P.X)) (CategoryTheory.MonoidalCategoryStruct.tensorHom M.mul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorŒº N.X P.X N.X P.X) (CategoryTheory.MonoidalCategoryStruct.tensorHom N.mul P.mul)))))","decl":"theorem mul_associator {M N P : Mon_ C} :\n    (tensorŒº (M.X ‚äó N.X) P.X (M.X ‚äó N.X) P.X ‚â´\n          (tensorŒº M.X N.X M.X N.X ‚â´ (M.mul ‚äó N.mul) ‚äó P.mul)) ‚â´\n        (Œ±_ M.X N.X P.X).hom =\n      ((Œ±_ M.X N.X P.X).hom ‚äó (Œ±_ M.X N.X P.X).hom) ‚â´\n        tensorŒº M.X (N.X ‚äó P.X) M.X (N.X ‚äó P.X) ‚â´\n          (M.mul ‚äó tensorŒº N.X P.X N.X P.X ‚â´ (N.mul ‚äó P.mul)) := by\n  simp only [tensor_obj, prodMonoidal_tensorObj, Category.assoc]\n  slice_lhs 2 3 => rw [‚Üê Category.id_comp P.mul, tensor_comp]\n  slice_lhs 3 4 => rw [associator_naturality]\n  slice_rhs 3 4 => rw [‚Üê Category.id_comp M.mul, tensor_comp]\n  simp only [tensorHom_id, id_tensorHom]\n  slice_lhs 1 3 => rw [associator_monoidal]\n  simp only [Category.assoc]\n\n"}
{"name":"Mon_.mul_leftUnitor","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Mon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorŒº CategoryTheory.MonoidalCategoryStruct.tensorUnit M.X CategoryTheory.MonoidalCategoryStruct.tensorUnit M.X) (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom M.mul)) (CategoryTheory.MonoidalCategoryStruct.leftUnitor M.X).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.leftUnitor M.X).hom (CategoryTheory.MonoidalCategoryStruct.leftUnitor M.X).hom) M.mul)","decl":"theorem mul_leftUnitor {M : Mon_ C} :\n    (tensorŒº (ùüô_ C) M.X (ùüô_ C) M.X ‚â´ ((Œª_ (ùüô_ C)).hom ‚äó M.mul)) ‚â´ (Œª_ M.X).hom =\n      ((Œª_ M.X).hom ‚äó (Œª_ M.X).hom) ‚â´ M.mul := by\n  rw [‚Üê Category.comp_id (Œª_ (ùüô_ C)).hom, ‚Üê Category.id_comp M.mul, tensor_comp]\n  simp only [tensorHom_id, id_tensorHom]\n  slice_lhs 3 4 => rw [leftUnitor_naturality]\n  slice_lhs 1 3 => rw [‚Üê leftUnitor_monoidal]\n  simp only [Category.assoc, Category.id_comp]\n\n"}
{"name":"Mon_.mul_rightUnitor","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Mon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorŒº M.X CategoryTheory.MonoidalCategoryStruct.tensorUnit M.X CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.MonoidalCategoryStruct.tensorHom M.mul (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom)) (CategoryTheory.MonoidalCategoryStruct.rightUnitor M.X).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.rightUnitor M.X).hom (CategoryTheory.MonoidalCategoryStruct.rightUnitor M.X).hom) M.mul)","decl":"theorem mul_rightUnitor {M : Mon_ C} :\n    (tensorŒº M.X (ùüô_ C) M.X (ùüô_ C) ‚â´ (M.mul ‚äó (Œª_ (ùüô_ C)).hom)) ‚â´ (œÅ_ M.X).hom =\n      ((œÅ_ M.X).hom ‚äó (œÅ_ M.X).hom) ‚â´ M.mul := by\n  rw [‚Üê Category.id_comp M.mul, ‚Üê Category.comp_id (Œª_ (ùüô_ C)).hom, tensor_comp]\n  simp only [tensorHom_id, id_tensorHom]\n  slice_lhs 3 4 => rw [rightUnitor_naturality]\n  slice_lhs 1 3 => rw [‚Üê rightUnitor_monoidal]\n  simp only [Category.assoc, Category.id_comp]\n\n"}
{"name":"Mon_.monMonoidalStruct_tensorObj_X","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM N : Mon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj M N).X (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X N.X)","decl":"@[simps tensorObj_X tensorHom_hom]\ninstance monMonoidalStruct : MonoidalCategoryStruct (Mon_ C) :=\n  let tensorObj (M N : Mon_ C) : Mon_ C :=\n    { X := M.X ‚äó N.X\n      one := (Œª_ (ùüô_ C)).inv ‚â´ (M.one ‚äó N.one)\n      mul := tensorŒº M.X N.X M.X N.X ‚â´ (M.mul ‚äó N.mul)\n      one_mul := Mon_tensor_one_mul M N\n      mul_one := Mon_tensor_mul_one M N\n      mul_assoc := Mon_tensor_mul_assoc M N }\n  let tensorHom {X‚ÇÅ Y‚ÇÅ X‚ÇÇ Y‚ÇÇ : Mon_ C} (f : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (g : X‚ÇÇ ‚ü∂ Y‚ÇÇ) :\n      tensorObj _ _ ‚ü∂ tensorObj _ _ :=\n    { hom := f.hom ‚äó g.hom\n      one_hom := by\n        dsimp [tensorObj]\n        slice_lhs 2 3 => rw [‚Üê tensor_comp, Hom.one_hom f, Hom.one_hom g]\n      mul_hom := by\n        dsimp [tensorObj]\n        slice_rhs 1 2 => rw [tensorŒº_natural]\n        slice_lhs 2 3 => rw [‚Üê tensor_comp, Hom.mul_hom f, Hom.mul_hom g, tensor_comp]\n        simp only [Category.assoc] }\n  { tensorObj := tensorObj\n    tensorHom := tensorHom\n    whiskerRight := fun f Y => tensorHom f (ùüô Y)\n    whiskerLeft := fun X _ _ g => tensorHom (ùüô X) g\n    tensorUnit := trivial C\n    associator := fun M N P ‚Ü¶ mkIso (Œ±_ M.X N.X P.X) one_associator mul_associator\n    leftUnitor := fun M ‚Ü¶ mkIso (Œª_ M.X) one_leftUnitor mul_leftUnitor\n    rightUnitor := fun M ‚Ü¶ mkIso (œÅ_ M.X) one_rightUnitor mul_rightUnitor }\n\n"}
{"name":"Mon_.monMonoidalStruct_tensorHom_hom","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX‚ÇÅ‚úù Y‚ÇÅ‚úù X‚ÇÇ‚úù Y‚ÇÇ‚úù : Mon_ C\nf : Quiver.Hom X‚ÇÅ‚úù Y‚ÇÅ‚úù\ng : Quiver.Hom X‚ÇÇ‚úù Y‚ÇÇ‚úù\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f g).hom (CategoryTheory.MonoidalCategoryStruct.tensorHom f.hom g.hom)","decl":"@[simps tensorObj_X tensorHom_hom]\ninstance monMonoidalStruct : MonoidalCategoryStruct (Mon_ C) :=\n  let tensorObj (M N : Mon_ C) : Mon_ C :=\n    { X := M.X ‚äó N.X\n      one := (Œª_ (ùüô_ C)).inv ‚â´ (M.one ‚äó N.one)\n      mul := tensorŒº M.X N.X M.X N.X ‚â´ (M.mul ‚äó N.mul)\n      one_mul := Mon_tensor_one_mul M N\n      mul_one := Mon_tensor_mul_one M N\n      mul_assoc := Mon_tensor_mul_assoc M N }\n  let tensorHom {X‚ÇÅ Y‚ÇÅ X‚ÇÇ Y‚ÇÇ : Mon_ C} (f : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (g : X‚ÇÇ ‚ü∂ Y‚ÇÇ) :\n      tensorObj _ _ ‚ü∂ tensorObj _ _ :=\n    { hom := f.hom ‚äó g.hom\n      one_hom := by\n        dsimp [tensorObj]\n        slice_lhs 2 3 => rw [‚Üê tensor_comp, Hom.one_hom f, Hom.one_hom g]\n      mul_hom := by\n        dsimp [tensorObj]\n        slice_rhs 1 2 => rw [tensorŒº_natural]\n        slice_lhs 2 3 => rw [‚Üê tensor_comp, Hom.mul_hom f, Hom.mul_hom g, tensor_comp]\n        simp only [Category.assoc] }\n  { tensorObj := tensorObj\n    tensorHom := tensorHom\n    whiskerRight := fun f Y => tensorHom f (ùüô Y)\n    whiskerLeft := fun X _ _ g => tensorHom (ùüô X) g\n    tensorUnit := trivial C\n    associator := fun M N P ‚Ü¶ mkIso (Œ±_ M.X N.X P.X) one_associator mul_associator\n    leftUnitor := fun M ‚Ü¶ mkIso (Œª_ M.X) one_leftUnitor mul_leftUnitor\n    rightUnitor := fun M ‚Ü¶ mkIso (œÅ_ M.X) one_rightUnitor mul_rightUnitor }\n\n"}
{"name":"Mon_.tensorUnit_X","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ Eq CategoryTheory.MonoidalCategoryStruct.tensorUnit.X CategoryTheory.MonoidalCategoryStruct.tensorUnit","decl":"@[simp]\ntheorem tensorUnit_X : (ùüô_ (Mon_ C)).X = ùüô_ C := rfl\n\n"}
{"name":"Mon_.tensorUnit_one","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ Eq CategoryTheory.MonoidalCategoryStruct.tensorUnit.one (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"@[simp]\ntheorem tensorUnit_one : (ùüô_ (Mon_ C)).one = ùüô (ùüô_ C) := rfl\n\n"}
{"name":"Mon_.tensorUnit_mul","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ Eq CategoryTheory.MonoidalCategoryStruct.tensorUnit.mul (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom","decl":"@[simp]\ntheorem tensorUnit_mul : (ùüô_ (Mon_ C)).mul = (Œª_ (ùüô_ C)).hom := rfl\n\n"}
{"name":"Mon_.tensorObj_one","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX Y : Mon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).one (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom X.one Y.one))","decl":"@[simp]\ntheorem tensorObj_one (X Y : Mon_ C) : (X ‚äó Y).one = (Œª_ (ùüô_ C)).inv ‚â´ (X.one ‚äó Y.one) := rfl\n\n"}
{"name":"Mon_.tensorObj_mul","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX Y : Mon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).mul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorŒº X.X Y.X X.X Y.X) (CategoryTheory.MonoidalCategoryStruct.tensorHom X.mul Y.mul))","decl":"@[simp]\ntheorem tensorObj_mul (X Y : Mon_ C) :\n    (X ‚äó Y).mul = tensorŒº X.X Y.X X.X Y.X ‚â´ (X.mul ‚äó Y.mul) := rfl\n\n"}
{"name":"Mon_.whiskerLeft_hom","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX Y : Mon_ C\nf : Quiver.Hom X Y\nZ : Mon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z).hom (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.hom Z.X)","decl":"@[simp]\ntheorem whiskerLeft_hom {X Y : Mon_ C} (f : X ‚ü∂ Y) (Z : Mon_ C) :\n    (f ‚ñ∑ Z).hom = f.hom ‚ñ∑ Z.X := by\n  rw [‚Üê tensorHom_id]; rfl\n\n"}
{"name":"Mon_.whiskerRight_hom","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX Y Z : Mon_ C\nf : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.X f.hom)","decl":"@[simp]\ntheorem whiskerRight_hom (X : Mon_ C) {Y Z : Mon_ C} (f : Y ‚ü∂ Z) :\n    (X ‚óÅ f).hom = X.X ‚óÅ f.hom := by\n  rw [‚Üê id_tensorHom]; rfl\n\n"}
{"name":"Mon_.leftUnitor_hom_hom","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX : Mon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom.hom (CategoryTheory.MonoidalCategoryStruct.leftUnitor X.X).hom","decl":"@[simp]\ntheorem leftUnitor_hom_hom (X : Mon_ C) : (Œª_ X).hom.hom = (Œª_ X.X).hom := rfl\n\n"}
{"name":"Mon_.leftUnitor_inv_hom","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX : Mon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv.hom (CategoryTheory.MonoidalCategoryStruct.leftUnitor X.X).inv","decl":"@[simp]\ntheorem leftUnitor_inv_hom (X : Mon_ C) : (Œª_ X).inv.hom = (Œª_ X.X).inv := rfl\n\n"}
{"name":"Mon_.rightUnitor_hom_hom","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX : Mon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom.hom (CategoryTheory.MonoidalCategoryStruct.rightUnitor X.X).hom","decl":"@[simp]\ntheorem rightUnitor_hom_hom (X : Mon_ C) : (œÅ_ X).hom.hom = (œÅ_ X.X).hom := rfl\n\n"}
{"name":"Mon_.rightUnitor_inv_hom","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX : Mon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv.hom (CategoryTheory.MonoidalCategoryStruct.rightUnitor X.X).inv","decl":"@[simp]\ntheorem rightUnitor_inv_hom (X : Mon_ C) : (œÅ_ X).inv.hom = (œÅ_ X.X).inv := rfl\n\n"}
{"name":"Mon_.associator_hom_hom","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX Y Z : Mon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom.hom (CategoryTheory.MonoidalCategoryStruct.associator X.X Y.X Z.X).hom","decl":"@[simp]\ntheorem associator_hom_hom (X Y Z : Mon_ C) : (Œ±_ X Y Z).hom.hom = (Œ±_ X.X Y.X Z.X).hom := rfl\n\n"}
{"name":"Mon_.associator_inv_hom","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX Y Z : Mon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv.hom (CategoryTheory.MonoidalCategoryStruct.associator X.X Y.X Z.X).inv","decl":"@[simp]\ntheorem associator_inv_hom (X Y Z : Mon_ C) : (Œ±_ X Y Z).inv.hom = (Œ±_ X.X Y.X Z.X).inv := rfl\n\n"}
{"name":"Mon_.tensor_one","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM N : Mon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj M N).one (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom M.one N.one))","decl":"@[simp]\ntheorem tensor_one (M N : Mon_ C) : (M ‚äó N).one = (Œª_ (ùüô_ C)).inv ‚â´ (M.one ‚äó N.one) := rfl\n\n"}
{"name":"Mon_.tensor_mul","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM N : Mon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj M N).mul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorŒº M.X N.X M.X N.X) (CategoryTheory.MonoidalCategoryStruct.tensorHom M.mul N.mul))","decl":"@[simp]\ntheorem tensor_mul (M N : Mon_ C) : (M ‚äó N).mul =\n    tensorŒº M.X N.X M.X N.X ‚â´ (M.mul ‚äó N.mul) := rfl\n\n"}
{"name":"Mon_.instMon_ClassTensorObj_mul","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.BraidedCategory C\nM N : C\ninst‚úù¬π : Mon_Class M\ninst‚úù : Mon_Class N\n‚ä¢ Eq Mon_Class.mul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorŒº M N M N) (CategoryTheory.MonoidalCategoryStruct.tensorHom Mon_Class.mul Mon_Class.mul))","decl":"@[simps!]\ninstance {M N : C} [Mon_Class M] [Mon_Class N] : Mon_Class (M ‚äó N) :=\n  inferInstanceAs <| Mon_Class (Mon_.mk' M ‚äó Mon_.mk' N).X\n\n"}
{"name":"Mon_.instMon_ClassTensorObj_one","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.BraidedCategory C\nM N : C\ninst‚úù¬π : Mon_Class M\ninst‚úù : Mon_Class N\n‚ä¢ Eq Mon_Class.one (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom Mon_Class.one Mon_Class.one))","decl":"@[simps!]\ninstance {M N : C} [Mon_Class M] [Mon_Class N] : Mon_Class (M ‚äó N) :=\n  inferInstanceAs <| Mon_Class (Mon_.mk' M ‚äó Mon_.mk' N).X\n\n"}
{"name":"Mon_.forget_Œµ","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ Eq (CategoryTheory.Functor.LaxMonoidal.Œµ (Mon_.forget C)) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"@[simp] theorem forget_Œµ : Œµ (forget C) = ùüô (ùüô_ C) := rfl\n"}
{"name":"Mon_.forget_Œ∑","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Œ∑ (Mon_.forget C)) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"@[simp] theorem forget_Œ∑ : ¬´Œ∑¬ª (forget C) = ùüô (ùüô_ C) := rfl\n"}
{"name":"Mon_.forget_Œº","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX Y : Mon_ C\n‚ä¢ Eq (CategoryTheory.Functor.LaxMonoidal.Œº (Mon_.forget C) X Y) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X.X Y.X))","decl":"@[simp] theorem forget_Œº (X Y : Mon_ C) : ¬´Œº¬ª (forget C) X Y = ùüô (X.X ‚äó Y.X) := rfl\n"}
{"name":"Mon_.forget_Œ¥","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX Y : Mon_ C\n‚ä¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Œ¥ (Mon_.forget C) X Y) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X.X Y.X))","decl":"@[simp] theorem forget_Œ¥ (X Y : Mon_ C) : Œ¥ (forget C) X Y = ùüô (X.X ‚äó Y.X) := rfl\n\n"}
{"name":"Mon_.one_braiding","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX Y : Mon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).one (CategoryTheory.BraidedCategory.braiding X.X Y.X).hom) (CategoryTheory.MonoidalCategoryStruct.tensorObj Y X).one","decl":"theorem one_braiding {X Y : Mon_ C} : (X ‚äó Y).one ‚â´ (Œ≤_ X.X Y.X).hom = (Y ‚äó X).one := by\n  simp only [monMonoidalStruct_tensorObj_X, tensor_one, Category.assoc,\n    BraidedCategory.braiding_naturality, braiding_tensorUnit_right, Iso.cancel_iso_inv_left]\n  monoidal\n\n"}
{"name":"Mon_.mul_braiding","module":"Mathlib.CategoryTheory.Monoidal.Mon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.SymmetricCategory C\nX Y : Mon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).mul (CategoryTheory.BraidedCategory.braiding X.X Y.X).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.BraidedCategory.braiding X.X Y.X).hom (CategoryTheory.BraidedCategory.braiding X.X Y.X).hom) (CategoryTheory.MonoidalCategoryStruct.tensorObj Y X).mul)","decl":"theorem mul_braiding {X Y : Mon_ C} :\n    (X ‚äó Y).mul ‚â´ (Œ≤_ X.X Y.X).hom = ((Œ≤_ X.X Y.X).hom ‚äó (Œ≤_ X.X Y.X).hom) ‚â´ (Y ‚äó X).mul := by\n  dsimp\n  simp only [tensorŒº, Category.assoc, BraidedCategory.braiding_naturality,\n    BraidedCategory.braiding_tensor_right, BraidedCategory.braiding_tensor_left,\n    comp_whiskerRight, whisker_assoc, MonoidalCategory.whiskerLeft_comp, pentagon_assoc,\n    pentagon_inv_hom_hom_hom_inv_assoc, Iso.inv_hom_id_assoc, whiskerLeft_hom_inv_assoc]\n  slice_lhs 3 4 =>\n    -- We use symmetry here:\n    rw [‚Üê MonoidalCategory.whiskerLeft_comp, ‚Üê comp_whiskerRight, SymmetricCategory.symmetry]\n  simp only [id_whiskerRight, MonoidalCategory.whiskerLeft_id, Category.id_comp, Category.assoc,\n    pentagon_inv_assoc, Iso.hom_inv_id_assoc]\n  slice_lhs 1 2 =>\n    rw [‚Üê associator_inv_naturality_left]\n  slice_lhs 2 3 =>\n    rw [Iso.inv_hom_id]\n  rw [Category.id_comp]\n  slice_lhs 2 3 =>\n    rw [‚Üê associator_naturality_right]\n  slice_lhs 1 2 =>\n    rw [‚Üê tensorHom_def]\n  simp only [Category.assoc]\n\n"}
