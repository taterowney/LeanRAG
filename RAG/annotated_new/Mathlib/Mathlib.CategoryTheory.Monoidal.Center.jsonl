{"name":"CategoryTheory.HalfBraiding.naturality","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX : C\nself : CategoryTheory.HalfBraiding X\nU U' : C\nf : Quiver.Hom U U'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) (self.β U').hom) (CategoryTheory.CategoryStruct.comp (self.β U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X))","decl":"/-- A half-braiding on `X : C` is a family of isomorphisms `X ⊗ U ≅ U ⊗ X`,\nmonoidally natural in `U : C`.\n\nThinking of `C` as a 2-category with a single `0`-morphism, these are the same as natural\ntransformations (in the pseudo- sense) of the identity 2-functor on `C`, which send the unique\n`0`-morphism to `X`.\n-/\nstructure HalfBraiding (X : C) where\n  β : ∀ U, X ⊗ U ≅ U ⊗ X\n  monoidal : ∀ U U', (β (U ⊗ U')).hom =\n      (α_ _ _ _).inv ≫\n        ((β U).hom ▷ U') ≫ (α_ _ _ _).hom ≫ (U ◁ (β U').hom) ≫ (α_ _ _ _).inv := by\n    aesop_cat\n  naturality : ∀ {U U'} (f : U ⟶ U'), (X ◁ f) ≫ (β U').hom = (β U).hom ≫ (f ▷ X) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.HalfBraiding.monoidal","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX : C\nself : CategoryTheory.HalfBraiding X\nU U' : C\n⊢ Eq (self.β (CategoryTheory.MonoidalCategoryStruct.tensorObj U U')).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X U U').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (self.β U).hom U') (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator U X U').hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U (self.β U').hom) (CategoryTheory.MonoidalCategoryStruct.associator U U' X).inv))))","decl":"/-- A half-braiding on `X : C` is a family of isomorphisms `X ⊗ U ≅ U ⊗ X`,\nmonoidally natural in `U : C`.\n\nThinking of `C` as a 2-category with a single `0`-morphism, these are the same as natural\ntransformations (in the pseudo- sense) of the identity 2-functor on `C`, which send the unique\n`0`-morphism to `X`.\n-/\nstructure HalfBraiding (X : C) where\n  β : ∀ U, X ⊗ U ≅ U ⊗ X\n  monoidal : ∀ U U', (β (U ⊗ U')).hom =\n      (α_ _ _ _).inv ≫\n        ((β U).hom ▷ U') ≫ (α_ _ _ _).hom ≫ (U ◁ (β U').hom) ≫ (α_ _ _ _).inv := by\n    aesop_cat\n  naturality : ∀ {U U'} (f : U ⟶ U'), (X ◁ f) ≫ (β U').hom = (β U).hom ≫ (f ▷ X) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.HalfBraiding.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nX : C\ninst✝ : SizeOf C\nβ : (U : C) → CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj X U) (CategoryTheory.MonoidalCategoryStruct.tensorObj U X)\nmonoidal : autoParam (∀ (U U' : C), Eq (β (CategoryTheory.MonoidalCategoryStruct.tensorObj U U')).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X U U').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (β U).hom U') (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator U X U').hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U (β U').hom) (CategoryTheory.MonoidalCategoryStruct.associator U U' X).inv))))) _auto✝\nnaturality : autoParam (∀ {U U' : C} (f : Quiver.Hom U U'), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) (β U').hom) (CategoryTheory.CategoryStruct.comp (β U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X))) _auto✝\n⊢ Eq (SizeOf.sizeOf { β := β, monoidal := monoidal, naturality := naturality }) 1","decl":"/-- A half-braiding on `X : C` is a family of isomorphisms `X ⊗ U ≅ U ⊗ X`,\nmonoidally natural in `U : C`.\n\nThinking of `C` as a 2-category with a single `0`-morphism, these are the same as natural\ntransformations (in the pseudo- sense) of the identity 2-functor on `C`, which send the unique\n`0`-morphism to `X`.\n-/\nstructure HalfBraiding (X : C) where\n  β : ∀ U, X ⊗ U ≅ U ⊗ X\n  monoidal : ∀ U U', (β (U ⊗ U')).hom =\n      (α_ _ _ _).inv ≫\n        ((β U).hom ▷ U') ≫ (α_ _ _ _).hom ≫ (U ◁ (β U').hom) ≫ (α_ _ _ _).inv := by\n    aesop_cat\n  naturality : ∀ {U U'} (f : U ⟶ U'), (X ◁ f) ≫ (β U').hom = (β U).hom ≫ (f ▷ X) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.HalfBraiding.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX : C\nβ✝ : (U : C) → CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj X U) (CategoryTheory.MonoidalCategoryStruct.tensorObj U X)\nmonoidal✝ : autoParam (∀ (U U' : C), Eq (β✝ (CategoryTheory.MonoidalCategoryStruct.tensorObj U U')).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X U U').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (β✝ U).hom U') (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator U X U').hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U (β✝ U').hom) (CategoryTheory.MonoidalCategoryStruct.associator U U' X).inv))))) _auto✝\nnaturality✝ : autoParam (∀ {U U' : C} (f : Quiver.Hom U U'), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) (β✝ U').hom) (CategoryTheory.CategoryStruct.comp (β✝ U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X))) _auto✝\nβ : (U : C) → CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj X U) (CategoryTheory.MonoidalCategoryStruct.tensorObj U X)\nmonoidal : autoParam (∀ (U U' : C), Eq (β (CategoryTheory.MonoidalCategoryStruct.tensorObj U U')).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X U U').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (β U).hom U') (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator U X U').hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U (β U').hom) (CategoryTheory.MonoidalCategoryStruct.associator U U' X).inv))))) _auto✝\nnaturality : autoParam (∀ {U U' : C} (f : Quiver.Hom U U'), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) (β U').hom) (CategoryTheory.CategoryStruct.comp (β U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X))) _auto✝\n⊢ Eq (Eq { β := β✝, monoidal := monoidal✝, naturality := naturality✝ } { β := β, monoidal := monoidal, naturality := naturality }) (Eq β✝ β)","decl":"/-- A half-braiding on `X : C` is a family of isomorphisms `X ⊗ U ≅ U ⊗ X`,\nmonoidally natural in `U : C`.\n\nThinking of `C` as a 2-category with a single `0`-morphism, these are the same as natural\ntransformations (in the pseudo- sense) of the identity 2-functor on `C`, which send the unique\n`0`-morphism to `X`.\n-/\nstructure HalfBraiding (X : C) where\n  β : ∀ U, X ⊗ U ≅ U ⊗ X\n  monoidal : ∀ U U', (β (U ⊗ U')).hom =\n      (α_ _ _ _).inv ≫\n        ((β U).hom ▷ U') ≫ (α_ _ _ _).hom ≫ (U ◁ (β U').hom) ≫ (α_ _ _ _).inv := by\n    aesop_cat\n  naturality : ∀ {U U'} (f : U ⟶ U'), (X ◁ f) ≫ (β U').hom = (β U).hom ≫ (f ▷ X) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.HalfBraiding.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX : C\nβ✝ : (U : C) → CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj X U) (CategoryTheory.MonoidalCategoryStruct.tensorObj U X)\nmonoidal✝ : autoParam (∀ (U U' : C), Eq (β✝ (CategoryTheory.MonoidalCategoryStruct.tensorObj U U')).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X U U').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (β✝ U).hom U') (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator U X U').hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U (β✝ U').hom) (CategoryTheory.MonoidalCategoryStruct.associator U U' X).inv))))) _auto✝\nnaturality✝ : autoParam (∀ {U U' : C} (f : Quiver.Hom U U'), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) (β✝ U').hom) (CategoryTheory.CategoryStruct.comp (β✝ U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X))) _auto✝\nβ : (U : C) → CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj X U) (CategoryTheory.MonoidalCategoryStruct.tensorObj U X)\nmonoidal : autoParam (∀ (U U' : C), Eq (β (CategoryTheory.MonoidalCategoryStruct.tensorObj U U')).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X U U').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (β U).hom U') (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator U X U').hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U (β U').hom) (CategoryTheory.MonoidalCategoryStruct.associator U U' X).inv))))) _auto✝\nnaturality : autoParam (∀ {U U' : C} (f : Quiver.Hom U U'), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) (β U').hom) (CategoryTheory.CategoryStruct.comp (β U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X))) _auto✝\nx✝ : Eq { β := β✝, monoidal := monoidal✝, naturality := naturality✝ } { β := β, monoidal := monoidal, naturality := naturality }\n⊢ Eq β✝ β","decl":"/-- A half-braiding on `X : C` is a family of isomorphisms `X ⊗ U ≅ U ⊗ X`,\nmonoidally natural in `U : C`.\n\nThinking of `C` as a 2-category with a single `0`-morphism, these are the same as natural\ntransformations (in the pseudo- sense) of the identity 2-functor on `C`, which send the unique\n`0`-morphism to `X`.\n-/\nstructure HalfBraiding (X : C) where\n  β : ∀ U, X ⊗ U ≅ U ⊗ X\n  monoidal : ∀ U U', (β (U ⊗ U')).hom =\n      (α_ _ _ _).inv ≫\n        ((β U).hom ▷ U') ≫ (α_ _ _ _).hom ≫ (U ◁ (β U').hom) ≫ (α_ _ _ _).inv := by\n    aesop_cat\n  naturality : ∀ {U U'} (f : U ⟶ U'), (X ◁ f) ≫ (β U').hom = (β U).hom ≫ (f ▷ X) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.HalfBraiding.monoidal_assoc","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX : C\nself : CategoryTheory.HalfBraiding X\nU U' Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj U U') X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.β (CategoryTheory.MonoidalCategoryStruct.tensorObj U U')).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X U U').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (self.β U).hom U') (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator U X U').hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U (self.β U').hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator U U' X).inv h)))))","decl":"attribute [reassoc, simp] HalfBraiding.monoidal -- the reassoc lemma is redundant as a simp lemma\n\n"}
{"name":"CategoryTheory.HalfBraiding.naturality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX : C\nself : CategoryTheory.HalfBraiding X\nU U' : C\nf : Quiver.Hom U U'\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj U' X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) (CategoryTheory.CategoryStruct.comp (self.β U').hom h)) (CategoryTheory.CategoryStruct.comp (self.β U).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X) h))","decl":"attribute [simp, reassoc] HalfBraiding.naturality\n\n"}
{"name":"CategoryTheory.Center.Hom.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nf✝ : Quiver.Hom X.fst Y.fst\ncomm✝ : autoParam (∀ (U : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f✝ U) (Y.snd.β U).hom) (CategoryTheory.CategoryStruct.comp (X.snd.β U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U f✝))) _auto✝\nf : Quiver.Hom X.fst Y.fst\ncomm : autoParam (∀ (U : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f U) (Y.snd.β U).hom) (CategoryTheory.CategoryStruct.comp (X.snd.β U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U f))) _auto✝\nx✝ : Eq { f := f✝, comm := comm✝ } { f := f, comm := comm }\n⊢ Eq f✝ f","decl":"/-- A morphism in the Drinfeld center of `C`. -/\n@[ext]\nstructure Hom (X Y : Center C) where\n  f : X.1 ⟶ Y.1\n  comm : ∀ U, (f ▷ U) ≫ (Y.2.β U).hom = (X.2.β U).hom ≫ (U ◁ f) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Center.Hom.ext","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nx y : X.Hom Y\nf : Eq x.f y.f\n⊢ Eq x y","decl":"/-- A morphism in the Drinfeld center of `C`. -/\n@[ext]\nstructure Hom (X Y : Center C) where\n  f : X.1 ⟶ Y.1\n  comm : ∀ U, (f ▷ U) ≫ (Y.2.β U).hom = (X.2.β U).hom ≫ (U ◁ f) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Center.Hom.ext_iff","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nx y : X.Hom Y\n⊢ Iff (Eq x y) (Eq x.f y.f)","decl":"/-- A morphism in the Drinfeld center of `C`. -/\n@[ext]\nstructure Hom (X Y : Center C) where\n  f : X.1 ⟶ Y.1\n  comm : ∀ U, (f ▷ U) ≫ (Y.2.β U).hom = (X.2.β U).hom ≫ (U ◁ f) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Center.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\ninst✝ : SizeOf C\nf : Quiver.Hom X.fst Y.fst\ncomm : autoParam (∀ (U : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f U) (Y.snd.β U).hom) (CategoryTheory.CategoryStruct.comp (X.snd.β U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U f))) _auto✝\n⊢ Eq (SizeOf.sizeOf { f := f, comm := comm }) (HAdd.hAdd 1 (SizeOf.sizeOf f))","decl":"/-- A morphism in the Drinfeld center of `C`. -/\n@[ext]\nstructure Hom (X Y : Center C) where\n  f : X.1 ⟶ Y.1\n  comm : ∀ U, (f ▷ U) ≫ (Y.2.β U).hom = (X.2.β U).hom ≫ (U ◁ f) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Center.Hom.comm","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nself : X.Hom Y\nU : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.f U) (Y.snd.β U).hom) (CategoryTheory.CategoryStruct.comp (X.snd.β U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U self.f))","decl":"/-- A morphism in the Drinfeld center of `C`. -/\n@[ext]\nstructure Hom (X Y : Center C) where\n  f : X.1 ⟶ Y.1\n  comm : ∀ U, (f ▷ U) ≫ (Y.2.β U).hom = (X.2.β U).hom ≫ (U ◁ f) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Center.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nf✝ : Quiver.Hom X.fst Y.fst\ncomm✝ : autoParam (∀ (U : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f✝ U) (Y.snd.β U).hom) (CategoryTheory.CategoryStruct.comp (X.snd.β U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U f✝))) _auto✝\nf : Quiver.Hom X.fst Y.fst\ncomm : autoParam (∀ (U : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f U) (Y.snd.β U).hom) (CategoryTheory.CategoryStruct.comp (X.snd.β U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U f))) _auto✝\n⊢ Eq (Eq { f := f✝, comm := comm✝ } { f := f, comm := comm }) (Eq f✝ f)","decl":"/-- A morphism in the Drinfeld center of `C`. -/\n@[ext]\nstructure Hom (X Y : Center C) where\n  f : X.1 ⟶ Y.1\n  comm : ∀ U, (f ▷ U) ≫ (Y.2.β U).hom = (X.2.β U).hom ≫ (U ◁ f) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Center.Hom.comm_assoc","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nself : X.Hom Y\nU Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj U Y.fst) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.f U) (CategoryTheory.CategoryStruct.comp (Y.snd.β U).hom h)) (CategoryTheory.CategoryStruct.comp (X.snd.β U).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U self.f) h))","decl":"attribute [reassoc (attr := simp)] Hom.comm\n\n"}
{"name":"CategoryTheory.Center.ext","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nf g : Quiver.Hom X Y\nw : Eq f.f g.f\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {X Y : Center C} (f g : X ⟶ Y) (w : f.f = g.f) : f = g := by\n  cases f; cases g; congr\n\n"}
{"name":"CategoryTheory.Center.ext_iff","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nf g : Quiver.Hom X Y\n⊢ Iff (Eq f g) (Eq f.f g.f)","decl":"@[ext]\ntheorem ext {X Y : Center C} (f g : X ⟶ Y) (w : f.f = g.f) : f = g := by\n  cases f; cases g; congr\n\n"}
{"name":"CategoryTheory.Center.id_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX : CategoryTheory.Center C\n⊢ Eq (CategoryTheory.CategoryStruct.id X).f (CategoryTheory.CategoryStruct.id X.fst)","decl":"@[simp]\ntheorem id_f (X : Center C) : Hom.f (𝟙 X) = 𝟙 X.1 :=\n  rfl\n\n"}
{"name":"CategoryTheory.Center.comp_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z : CategoryTheory.Center C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).f (CategoryTheory.CategoryStruct.comp f.f g.f)","decl":"@[simp]\ntheorem comp_f {X Y Z : Center C} (f : X ⟶ Y) (g : Y ⟶ Z) : (f ≫ g).f = f.f ≫ g.f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Center.isoMk_inv_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f.f\n⊢ Eq (CategoryTheory.Center.isoMk f).inv.f (CategoryTheory.inv f.f)","decl":"/-- Construct an isomorphism in the Drinfeld center from\na morphism whose underlying morphism is an isomorphism.\n-/\n@[simps]\ndef isoMk {X Y : Center C} (f : X ⟶ Y) [IsIso f.f] : X ≅ Y where\n  hom := f\n  inv := ⟨inv f.f,\n    fun U => by simp [← cancel_epi (f.f ▷ U), ← comp_whiskerRight_assoc,\n      ← MonoidalCategory.whiskerLeft_comp] ⟩\n\n"}
{"name":"CategoryTheory.Center.isoMk_hom","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f.f\n⊢ Eq (CategoryTheory.Center.isoMk f).hom f","decl":"/-- Construct an isomorphism in the Drinfeld center from\na morphism whose underlying morphism is an isomorphism.\n-/\n@[simps]\ndef isoMk {X Y : Center C} (f : X ⟶ Y) [IsIso f.f] : X ≅ Y where\n  hom := f\n  inv := ⟨inv f.f,\n    fun U => by simp [← cancel_epi (f.f ▷ U), ← comp_whiskerRight_assoc,\n      ← MonoidalCategory.whiskerLeft_comp] ⟩\n\n"}
{"name":"CategoryTheory.Center.isIso_of_f_isIso","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f.f\n⊢ CategoryTheory.IsIso f","decl":"instance isIso_of_f_isIso {X Y : Center C} (f : X ⟶ Y) [IsIso f.f] : IsIso f := by\n  change IsIso (isoMk f).hom\n  infer_instance\n\n"}
{"name":"CategoryTheory.Center.tensorObj_snd_β","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nU : C\n⊢ Eq ((X.tensorObj Y).snd.β U) ((CategoryTheory.MonoidalCategoryStruct.associator X.fst Y.fst U).trans ((CategoryTheory.MonoidalCategory.whiskerLeftIso X.fst (Y.snd.β U)).trans ((CategoryTheory.MonoidalCategoryStruct.associator X.fst U Y.fst).symm.trans ((CategoryTheory.MonoidalCategory.whiskerRightIso (X.snd.β U) Y.fst).trans (CategoryTheory.MonoidalCategoryStruct.associator U X.fst Y.fst)))))","decl":"/-- Auxiliary definition for the `MonoidalCategory` instance on `Center C`. -/\n@[simps]\ndef tensorObj (X Y : Center C) : Center C :=\n  ⟨X.1 ⊗ Y.1,\n    { β := fun U =>\n        α_ _ _ _ ≪≫\n          (whiskerLeftIso X.1 (Y.2.β U)) ≪≫ (α_ _ _ _).symm ≪≫\n            (whiskerRightIso (X.2.β U) Y.1) ≪≫ α_ _ _ _\n      monoidal := fun U U' => by\n        dsimp only [Iso.trans_hom, whiskerLeftIso_hom, Iso.symm_hom, whiskerRightIso_hom]\n        simp only [HalfBraiding.monoidal]\n        -- We'd like to commute `X.1 ◁ U ◁ (HalfBraiding.β Y.2 U').hom`\n        -- and `((HalfBraiding.β X.2 U).hom ▷ U' ▷ Y.1)` past each other.\n        -- We do this with the help of the monoidal composition `⊗≫` and the `coherence` tactic.\n        calc\n          _ = 𝟙 _ ⊗≫\n            X.1 ◁ (HalfBraiding.β Y.2 U).hom ▷ U' ⊗≫\n              (_ ◁ (HalfBraiding.β Y.2 U').hom ≫\n                (HalfBraiding.β X.2 U).hom ▷ _) ⊗≫\n                  U ◁ (HalfBraiding.β X.2 U').hom ▷ Y.1 ⊗≫ 𝟙 _ := by monoidal\n          _ = _ := by rw [whisker_exchange]; monoidal\n      naturality := fun {U U'} f => by\n        dsimp only [Iso.trans_hom, whiskerLeftIso_hom, Iso.symm_hom, whiskerRightIso_hom]\n        calc\n          _ = 𝟙 _ ⊗≫\n            (X.1 ◁ (Y.1 ◁ f ≫ (HalfBraiding.β Y.2 U').hom)) ⊗≫\n              (HalfBraiding.β X.2 U').hom ▷ Y.1 ⊗≫ 𝟙 _ := by monoidal\n          _ = 𝟙 _ ⊗≫\n            X.1 ◁ (HalfBraiding.β Y.2 U).hom ⊗≫\n              (X.1 ◁ f ≫ (HalfBraiding.β X.2 U').hom) ▷ Y.1 ⊗≫ 𝟙 _ := by\n            rw [HalfBraiding.naturality]; monoidal\n          _ = _ := by rw [HalfBraiding.naturality]; monoidal }⟩\n\n"}
{"name":"CategoryTheory.Center.tensorObj_fst","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\n⊢ Eq (X.tensorObj Y).fst (CategoryTheory.MonoidalCategoryStruct.tensorObj X.fst Y.fst)","decl":"/-- Auxiliary definition for the `MonoidalCategory` instance on `Center C`. -/\n@[simps]\ndef tensorObj (X Y : Center C) : Center C :=\n  ⟨X.1 ⊗ Y.1,\n    { β := fun U =>\n        α_ _ _ _ ≪≫\n          (whiskerLeftIso X.1 (Y.2.β U)) ≪≫ (α_ _ _ _).symm ≪≫\n            (whiskerRightIso (X.2.β U) Y.1) ≪≫ α_ _ _ _\n      monoidal := fun U U' => by\n        dsimp only [Iso.trans_hom, whiskerLeftIso_hom, Iso.symm_hom, whiskerRightIso_hom]\n        simp only [HalfBraiding.monoidal]\n        -- We'd like to commute `X.1 ◁ U ◁ (HalfBraiding.β Y.2 U').hom`\n        -- and `((HalfBraiding.β X.2 U).hom ▷ U' ▷ Y.1)` past each other.\n        -- We do this with the help of the monoidal composition `⊗≫` and the `coherence` tactic.\n        calc\n          _ = 𝟙 _ ⊗≫\n            X.1 ◁ (HalfBraiding.β Y.2 U).hom ▷ U' ⊗≫\n              (_ ◁ (HalfBraiding.β Y.2 U').hom ≫\n                (HalfBraiding.β X.2 U).hom ▷ _) ⊗≫\n                  U ◁ (HalfBraiding.β X.2 U').hom ▷ Y.1 ⊗≫ 𝟙 _ := by monoidal\n          _ = _ := by rw [whisker_exchange]; monoidal\n      naturality := fun {U U'} f => by\n        dsimp only [Iso.trans_hom, whiskerLeftIso_hom, Iso.symm_hom, whiskerRightIso_hom]\n        calc\n          _ = 𝟙 _ ⊗≫\n            (X.1 ◁ (Y.1 ◁ f ≫ (HalfBraiding.β Y.2 U').hom)) ⊗≫\n              (HalfBraiding.β X.2 U').hom ▷ Y.1 ⊗≫ 𝟙 _ := by monoidal\n          _ = 𝟙 _ ⊗≫\n            X.1 ◁ (HalfBraiding.β Y.2 U).hom ⊗≫\n              (X.1 ◁ f ≫ (HalfBraiding.β X.2 U').hom) ▷ Y.1 ⊗≫ 𝟙 _ := by\n            rw [HalfBraiding.naturality]; monoidal\n          _ = _ := by rw [HalfBraiding.naturality]; monoidal }⟩\n\n"}
{"name":"CategoryTheory.Center.whiskerLeft_comm","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y₁ Y₂ : CategoryTheory.Center C\nf : Quiver.Hom Y₁ Y₂\nU : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.fst f.f) U) ((X.tensorObj Y₂).snd.β U).hom) (CategoryTheory.CategoryStruct.comp ((X.tensorObj Y₁).snd.β U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.fst f.f)))","decl":"@[reassoc]\ntheorem whiskerLeft_comm (X : Center C) {Y₁ Y₂ : Center C} (f : Y₁ ⟶ Y₂) (U : C) :\n    (X.1 ◁ f.f) ▷ U ≫ ((tensorObj X Y₂).2.β U).hom =\n      ((tensorObj X Y₁).2.β U).hom ≫ U ◁ X.1 ◁ f.f := by\n  dsimp only [tensorObj_fst, tensorObj_snd_β, Iso.trans_hom, whiskerLeftIso_hom,\n    Iso.symm_hom, whiskerRightIso_hom]\n  calc\n    _ = 𝟙 _ ⊗≫\n      X.fst ◁ (f.f ▷ U ≫ (HalfBraiding.β Y₂.snd U).hom) ⊗≫\n        (HalfBraiding.β X.snd U).hom ▷ Y₂.fst ⊗≫ 𝟙 _ := by monoidal\n    _ = 𝟙 _ ⊗≫\n      X.fst ◁ (HalfBraiding.β Y₁.snd U).hom ⊗≫\n        ((X.fst ⊗ U) ◁ f.f ≫ (HalfBraiding.β X.snd U).hom ▷ Y₂.fst) ⊗≫ 𝟙 _ := by\n      rw [f.comm]; monoidal\n    _ = _ := by rw [whisker_exchange]; monoidal\n\n"}
{"name":"CategoryTheory.Center.whiskerLeft_comm_assoc","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y₁ Y₂ : CategoryTheory.Center C\nf : Quiver.Hom Y₁ Y₂\nU Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj U (X.tensorObj Y₂).fst) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.fst f.f) U) (CategoryTheory.CategoryStruct.comp ((X.tensorObj Y₂).snd.β U).hom h)) (CategoryTheory.CategoryStruct.comp ((X.tensorObj Y₁).snd.β U).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.fst f.f)) h))","decl":"@[reassoc]\ntheorem whiskerLeft_comm (X : Center C) {Y₁ Y₂ : Center C} (f : Y₁ ⟶ Y₂) (U : C) :\n    (X.1 ◁ f.f) ▷ U ≫ ((tensorObj X Y₂).2.β U).hom =\n      ((tensorObj X Y₁).2.β U).hom ≫ U ◁ X.1 ◁ f.f := by\n  dsimp only [tensorObj_fst, tensorObj_snd_β, Iso.trans_hom, whiskerLeftIso_hom,\n    Iso.symm_hom, whiskerRightIso_hom]\n  calc\n    _ = 𝟙 _ ⊗≫\n      X.fst ◁ (f.f ▷ U ≫ (HalfBraiding.β Y₂.snd U).hom) ⊗≫\n        (HalfBraiding.β X.snd U).hom ▷ Y₂.fst ⊗≫ 𝟙 _ := by monoidal\n    _ = 𝟙 _ ⊗≫\n      X.fst ◁ (HalfBraiding.β Y₁.snd U).hom ⊗≫\n        ((X.fst ⊗ U) ◁ f.f ≫ (HalfBraiding.β X.snd U).hom ▷ Y₂.fst) ⊗≫ 𝟙 _ := by\n      rw [f.comm]; monoidal\n    _ = _ := by rw [whisker_exchange]; monoidal\n\n"}
{"name":"CategoryTheory.Center.whiskerRight_comm","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX₁ X₂ : CategoryTheory.Center C\nf : Quiver.Hom X₁ X₂\nY : CategoryTheory.Center C\nU : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.f Y.fst) U) ((X₂.tensorObj Y).snd.β U).hom) (CategoryTheory.CategoryStruct.comp ((X₁.tensorObj Y).snd.β U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.f Y.fst)))","decl":"@[reassoc]\ntheorem whiskerRight_comm {X₁ X₂ : Center C} (f : X₁ ⟶ X₂) (Y : Center C) (U : C) :\n    f.f ▷ Y.1 ▷ U ≫ ((tensorObj X₂ Y).2.β U).hom =\n      ((tensorObj X₁ Y).2.β U).hom ≫ U ◁ f.f ▷ Y.1 := by\n  dsimp only [tensorObj_fst, tensorObj_snd_β, Iso.trans_hom, whiskerLeftIso_hom,\n    Iso.symm_hom, whiskerRightIso_hom]\n  calc\n    _ = 𝟙 _ ⊗≫\n      (f.f ▷ (Y.fst ⊗ U) ≫ X₂.fst ◁ (HalfBraiding.β Y.snd U).hom) ⊗≫\n        (HalfBraiding.β X₂.snd U).hom ▷ Y.fst ⊗≫ 𝟙 _ := by monoidal\n    _ = 𝟙 _ ⊗≫\n      X₁.fst ◁ (HalfBraiding.β Y.snd U).hom ⊗≫\n        (f.f ▷ U ≫ (HalfBraiding.β X₂.snd U).hom) ▷ Y.fst ⊗≫ 𝟙 _ := by\n      rw [← whisker_exchange]; monoidal\n    _ = _ := by rw [f.comm]; monoidal\n\n"}
{"name":"CategoryTheory.Center.whiskerRight_comm_assoc","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX₁ X₂ : CategoryTheory.Center C\nf : Quiver.Hom X₁ X₂\nY : CategoryTheory.Center C\nU Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj U (X₂.tensorObj Y).fst) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.f Y.fst) U) (CategoryTheory.CategoryStruct.comp ((X₂.tensorObj Y).snd.β U).hom h)) (CategoryTheory.CategoryStruct.comp ((X₁.tensorObj Y).snd.β U).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.f Y.fst)) h))","decl":"@[reassoc]\ntheorem whiskerRight_comm {X₁ X₂ : Center C} (f : X₁ ⟶ X₂) (Y : Center C) (U : C) :\n    f.f ▷ Y.1 ▷ U ≫ ((tensorObj X₂ Y).2.β U).hom =\n      ((tensorObj X₁ Y).2.β U).hom ≫ U ◁ f.f ▷ Y.1 := by\n  dsimp only [tensorObj_fst, tensorObj_snd_β, Iso.trans_hom, whiskerLeftIso_hom,\n    Iso.symm_hom, whiskerRightIso_hom]\n  calc\n    _ = 𝟙 _ ⊗≫\n      (f.f ▷ (Y.fst ⊗ U) ≫ X₂.fst ◁ (HalfBraiding.β Y.snd U).hom) ⊗≫\n        (HalfBraiding.β X₂.snd U).hom ▷ Y.fst ⊗≫ 𝟙 _ := by monoidal\n    _ = 𝟙 _ ⊗≫\n      X₁.fst ◁ (HalfBraiding.β Y.snd U).hom ⊗≫\n        (f.f ▷ U ≫ (HalfBraiding.β X₂.snd U).hom) ▷ Y.fst ⊗≫ 𝟙 _ := by\n      rw [← whisker_exchange]; monoidal\n    _ = _ := by rw [f.comm]; monoidal\n\n"}
{"name":"CategoryTheory.Center.tensorHom_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX₁ Y₁ X₂ Y₂ : CategoryTheory.Center C\nf : Quiver.Hom X₁ Y₁\ng : Quiver.Hom X₂ Y₂\n⊢ Eq (CategoryTheory.Center.tensorHom f g).f (CategoryTheory.MonoidalCategoryStruct.tensorHom f.f g.f)","decl":"/-- Auxiliary definition for the `MonoidalCategory` instance on `Center C`. -/\n@[simps]\ndef tensorHom {X₁ Y₁ X₂ Y₂ : Center C} (f : X₁ ⟶ Y₁) (g : X₂ ⟶ Y₂) :\n    tensorObj X₁ X₂ ⟶ tensorObj Y₁ Y₂ where\n  f := f.f ⊗ g.f\n  comm U := by\n    rw [tensorHom_def, comp_whiskerRight_assoc, whiskerLeft_comm, whiskerRight_comm_assoc,\n      MonoidalCategory.whiskerLeft_comp]\n\n"}
{"name":"CategoryTheory.Center.tensorUnit_snd_β","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nU : C\n⊢ Eq (CategoryTheory.Center.tensorUnit.snd.β U) ((CategoryTheory.MonoidalCategoryStruct.leftUnitor U).trans (CategoryTheory.MonoidalCategoryStruct.rightUnitor U).symm)","decl":"/-- Auxiliary definition for the `MonoidalCategory` instance on `Center C`. -/\n@[simps]\ndef tensorUnit : Center C :=\n  ⟨𝟙_ C, { β := fun U => λ_ U ≪≫ (ρ_ U).symm }⟩\n\n"}
{"name":"CategoryTheory.Center.tensorUnit_fst","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\n⊢ Eq CategoryTheory.Center.tensorUnit.fst CategoryTheory.MonoidalCategoryStruct.tensorUnit","decl":"/-- Auxiliary definition for the `MonoidalCategory` instance on `Center C`. -/\n@[simps]\ndef tensorUnit : Center C :=\n  ⟨𝟙_ C, { β := fun U => λ_ U ≪≫ (ρ_ U).symm }⟩\n\n"}
{"name":"CategoryTheory.Center.tensor_fst","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).fst (CategoryTheory.MonoidalCategoryStruct.tensorObj X.fst Y.fst)","decl":"@[simp]\ntheorem tensor_fst (X Y : Center C) : (X ⊗ Y).1 = X.1 ⊗ Y.1 :=\n  rfl\n\n"}
{"name":"CategoryTheory.Center.tensor_β","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nU : C\n⊢ Eq ((CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).snd.β U) ((CategoryTheory.MonoidalCategoryStruct.associator X.fst Y.fst U).trans ((CategoryTheory.MonoidalCategory.whiskerLeftIso X.fst (Y.snd.β U)).trans ((CategoryTheory.MonoidalCategoryStruct.associator X.fst U Y.fst).symm.trans ((CategoryTheory.MonoidalCategory.whiskerRightIso (X.snd.β U) Y.fst).trans (CategoryTheory.MonoidalCategoryStruct.associator U X.fst Y.fst)))))","decl":"@[simp]\ntheorem tensor_β (X Y : Center C) (U : C) :\n    (X ⊗ Y).2.β U =\n      α_ _ _ _ ≪≫\n        (whiskerLeftIso X.1 (Y.2.β U)) ≪≫ (α_ _ _ _).symm ≪≫\n          (whiskerRightIso (X.2.β U) Y.1) ≪≫ α_ _ _ _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Center.whiskerLeft_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y₁ Y₂ : CategoryTheory.Center C\nf : Quiver.Hom Y₁ Y₂\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f).f (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.fst f.f)","decl":"@[simp]\ntheorem whiskerLeft_f (X : Center C) {Y₁ Y₂ : Center C} (f : Y₁ ⟶ Y₂) : (X ◁ f).f = X.1 ◁ f.f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Center.whiskerRight_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX₁ X₂ : CategoryTheory.Center C\nf : Quiver.Hom X₁ X₂\nY : CategoryTheory.Center C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y).f (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.f Y.fst)","decl":"@[simp]\ntheorem whiskerRight_f {X₁ X₂ : Center C} (f : X₁ ⟶ X₂) (Y : Center C) : (f ▷ Y).f = f.f ▷ Y.1 :=\n  rfl\n\n"}
{"name":"CategoryTheory.Center.tensor_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX₁ Y₁ X₂ Y₂ : CategoryTheory.Center C\nf : Quiver.Hom X₁ Y₁\ng : Quiver.Hom X₂ Y₂\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f g).f (CategoryTheory.MonoidalCategoryStruct.tensorHom f.f g.f)","decl":"@[simp]\ntheorem tensor_f {X₁ Y₁ X₂ Y₂ : Center C} (f : X₁ ⟶ Y₁) (g : X₂ ⟶ Y₂) : (f ⊗ g).f = f.f ⊗ g.f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Center.tensorUnit_β","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nU : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorUnit.snd.β U) ((CategoryTheory.MonoidalCategoryStruct.leftUnitor U).trans (CategoryTheory.MonoidalCategoryStruct.rightUnitor U).symm)","decl":"@[simp]\ntheorem tensorUnit_β (U : C) : (𝟙_ (Center C)).2.β U = λ_ U ≪≫ (ρ_ U).symm :=\n  rfl\n\n"}
{"name":"CategoryTheory.Center.associator_hom_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z : CategoryTheory.Center C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom.f (CategoryTheory.MonoidalCategoryStruct.associator X.fst Y.fst Z.fst).hom","decl":"@[simp]\ntheorem associator_hom_f (X Y Z : Center C) : Hom.f (α_ X Y Z).hom = (α_ X.1 Y.1 Z.1).hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Center.associator_inv_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z : CategoryTheory.Center C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv.f (CategoryTheory.MonoidalCategoryStruct.associator X.fst Y.fst Z.fst).inv","decl":"@[simp]\ntheorem associator_inv_f (X Y Z : Center C) : Hom.f (α_ X Y Z).inv = (α_ X.1 Y.1 Z.1).inv := by\n  apply Iso.inv_ext' -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): Originally `ext`\n  rw [← associator_hom_f, ← comp_f, Iso.hom_inv_id]; rfl\n\n"}
{"name":"CategoryTheory.Center.leftUnitor_hom_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX : CategoryTheory.Center C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom.f (CategoryTheory.MonoidalCategoryStruct.leftUnitor X.fst).hom","decl":"@[simp]\ntheorem leftUnitor_hom_f (X : Center C) : Hom.f (λ_ X).hom = (λ_ X.1).hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Center.leftUnitor_inv_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX : CategoryTheory.Center C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv.f (CategoryTheory.MonoidalCategoryStruct.leftUnitor X.fst).inv","decl":"@[simp]\ntheorem leftUnitor_inv_f (X : Center C) : Hom.f (λ_ X).inv = (λ_ X.1).inv := by\n  apply Iso.inv_ext' -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): Originally `ext`\n  rw [← leftUnitor_hom_f, ← comp_f, Iso.hom_inv_id]; rfl\n\n"}
{"name":"CategoryTheory.Center.rightUnitor_hom_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX : CategoryTheory.Center C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom.f (CategoryTheory.MonoidalCategoryStruct.rightUnitor X.fst).hom","decl":"@[simp]\ntheorem rightUnitor_hom_f (X : Center C) : Hom.f (ρ_ X).hom = (ρ_ X.1).hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Center.rightUnitor_inv_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX : CategoryTheory.Center C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv.f (CategoryTheory.MonoidalCategoryStruct.rightUnitor X.fst).inv","decl":"@[simp]\ntheorem rightUnitor_inv_f (X : Center C) : Hom.f (ρ_ X).inv = (ρ_ X.1).inv := by\n  apply Iso.inv_ext' -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): Originally `ext`\n  rw [← rightUnitor_hom_f, ← comp_f, Iso.hom_inv_id]; rfl\n\n"}
{"name":"CategoryTheory.Center.forget_map","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX✝ Y✝ : CategoryTheory.Center C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Center.forget C).map f) f.f","decl":"/-- The forgetful monoidal functor from the Drinfeld center to the original category. -/\n@[simps]\ndef forget : Center C ⥤ C where\n  obj X := X.1\n  map f := f.f\n\n"}
{"name":"CategoryTheory.Center.forget_obj","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX : CategoryTheory.Center C\n⊢ Eq ((CategoryTheory.Center.forget C).obj X) X.fst","decl":"/-- The forgetful monoidal functor from the Drinfeld center to the original category. -/\n@[simps]\ndef forget : Center C ⥤ C where\n  obj X := X.1\n  map f := f.f\n\n"}
{"name":"CategoryTheory.Center.forget_ε","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.ε (CategoryTheory.Center.forget C)) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"@[simp] lemma forget_ε : ε (forget C) = 𝟙 _ := rfl\n"}
{"name":"CategoryTheory.Center.forget_η","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.η (CategoryTheory.Center.forget C)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Center.forget C).obj CategoryTheory.MonoidalCategoryStruct.tensorUnit))","decl":"@[simp] lemma forget_η : η (forget C) = 𝟙 _ := rfl\n\n"}
{"name":"CategoryTheory.Center.forget_μ","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.μ (CategoryTheory.Center.forget C) X Y) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj ((CategoryTheory.Center.forget C).obj X) ((CategoryTheory.Center.forget C).obj Y)))","decl":"@[simp] lemma forget_μ (X Y : Center C) : μ (forget C) X Y = 𝟙 _ := rfl\n"}
{"name":"CategoryTheory.Center.forget_δ","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.δ (CategoryTheory.Center.forget C) X Y) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Center.forget C).obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)))","decl":"@[simp] lemma forget_δ (X Y : Center C) : δ (forget C) X Y = 𝟙 _ := rfl\n\n"}
{"name":"CategoryTheory.Center.instReflectsIsomorphismsForget","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\n⊢ (CategoryTheory.Center.forget C).ReflectsIsomorphisms","decl":"instance : (forget C).ReflectsIsomorphisms where\n  reflects f i := by dsimp at i; change IsIso (isoMk f).hom; infer_instance\n\n"}
{"name":"CategoryTheory.Center.braiding_inv_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\n⊢ Eq (X.braiding Y).inv.f (X.snd.β Y.fst).inv","decl":"/-- Auxiliary definition for the `BraidedCategory` instance on `Center C`. -/\n@[simps!]\ndef braiding (X Y : Center C) : X ⊗ Y ≅ Y ⊗ X :=\n  isoMk\n    ⟨(X.2.β Y.1).hom, fun U => by\n      dsimp\n      simp only [Category.assoc]\n      rw [← IsIso.inv_comp_eq, IsIso.Iso.inv_hom, ← HalfBraiding.monoidal_assoc,\n        ← HalfBraiding.naturality_assoc, HalfBraiding.monoidal]\n      simp⟩\n\n"}
{"name":"CategoryTheory.Center.braiding_hom_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\n⊢ Eq (X.braiding Y).hom.f (X.snd.β Y.fst).hom","decl":"/-- Auxiliary definition for the `BraidedCategory` instance on `Center C`. -/\n@[simps!]\ndef braiding (X Y : Center C) : X ⊗ Y ≅ Y ⊗ X :=\n  isoMk\n    ⟨(X.2.β Y.1).hom, fun U => by\n      dsimp\n      simp only [Category.assoc]\n      rw [← IsIso.inv_comp_eq, IsIso.Iso.inv_hom, ← HalfBraiding.monoidal_assoc,\n        ← HalfBraiding.naturality_assoc, HalfBraiding.monoidal]\n      simp⟩\n\n"}
{"name":"CategoryTheory.Center.ofBraidedObj_snd_β","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : C\n⊢ Eq ((CategoryTheory.Center.ofBraidedObj X).snd.β Y) (CategoryTheory.BraidedCategory.braiding X Y)","decl":"/-- Auxiliary construction for `ofBraided`. -/\n@[simps]\ndef ofBraidedObj (X : C) : Center C :=\n  ⟨X, { β := fun Y => β_ X Y}⟩\n\n"}
{"name":"CategoryTheory.Center.ofBraidedObj_fst","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX : C\n⊢ Eq (CategoryTheory.Center.ofBraidedObj X).fst X","decl":"/-- Auxiliary construction for `ofBraided`. -/\n@[simps]\ndef ofBraidedObj (X : C) : Center C :=\n  ⟨X, { β := fun Y => β_ X Y}⟩\n\n"}
{"name":"CategoryTheory.Center.ofBraided_obj","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX : C\n⊢ Eq ((CategoryTheory.Center.ofBraided C).obj X) (CategoryTheory.Center.ofBraidedObj X)","decl":"/-- The functor lifting a braided category to its center, using the braiding as the half-braiding.\n-/\n@[simps]\ndef ofBraided : C ⥤ Center C where\n  obj := ofBraidedObj\n  map f :=\n    { f\n      comm := fun U => braiding_naturality_left f U }\n\n"}
{"name":"CategoryTheory.Center.ofBraided_map_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Center.ofBraided C).map f).f f","decl":"/-- The functor lifting a braided category to its center, using the braiding as the half-braiding.\n-/\n@[simps]\ndef ofBraided : C ⥤ Center C where\n  obj := ofBraidedObj\n  map f :=\n    { f\n      comm := fun U => braiding_naturality_left f U }\n\n"}
{"name":"CategoryTheory.Center.ofBraided_ε_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.ε (CategoryTheory.Center.ofBraided C)).f (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit.fst)","decl":"@[simp] lemma ofBraided_ε_f : (ε (ofBraided C)).f = 𝟙 _ := rfl\n"}
{"name":"CategoryTheory.Center.ofBraided_η_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.η (CategoryTheory.Center.ofBraided C)).f (CategoryTheory.CategoryStruct.id ((CategoryTheory.Center.ofBraided C).obj CategoryTheory.MonoidalCategoryStruct.tensorUnit).fst)","decl":"@[simp] lemma ofBraided_η_f : (η (ofBraided C)).f = 𝟙 _ := rfl\n\n"}
{"name":"CategoryTheory.Center.ofBraided_μ_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : C\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.μ (CategoryTheory.Center.ofBraided C) X Y).f (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj ((CategoryTheory.Center.ofBraided C).obj X) ((CategoryTheory.Center.ofBraided C).obj Y)).fst)","decl":"@[simp] lemma ofBraided_μ_f (X Y : C) : (μ (ofBraided C) X Y).f = 𝟙 _ := rfl\n"}
{"name":"CategoryTheory.Center.ofBraided_δ_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : C\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.δ (CategoryTheory.Center.ofBraided C) X Y).f (CategoryTheory.CategoryStruct.id ((CategoryTheory.Center.ofBraided C).obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)).fst)","decl":"@[simp] lemma ofBraided_δ_f (X Y : C) : (δ (ofBraided C) X Y).f = 𝟙 _ := rfl\n\n"}
