{"name":"CategoryTheory.HalfBraiding.naturality","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX : C\nself : CategoryTheory.HalfBraiding X\nU U' : C\nf : Quiver.Hom U U'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) (self.Î² U').hom) (CategoryTheory.CategoryStruct.comp (self.Î² U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X))","decl":"/-- A half-braiding on `X : C` is a family of isomorphisms `X âŠ— U â‰… U âŠ— X`,\nmonoidally natural in `U : C`.\n\nThinking of `C` as a 2-category with a single `0`-morphism, these are the same as natural\ntransformations (in the pseudo- sense) of the identity 2-functor on `C`, which send the unique\n`0`-morphism to `X`.\n-/\nstructure HalfBraiding (X : C) where\n  Î² : âˆ€ U, X âŠ— U â‰… U âŠ— X\n  monoidal : âˆ€ U U', (Î² (U âŠ— U')).hom =\n      (Î±_ _ _ _).inv â‰«\n        ((Î² U).hom â–· U') â‰« (Î±_ _ _ _).hom â‰« (U â— (Î² U').hom) â‰« (Î±_ _ _ _).inv := by\n    aesop_cat\n  naturality : âˆ€ {U U'} (f : U âŸ¶ U'), (X â— f) â‰« (Î² U').hom = (Î² U).hom â‰« (f â–· X) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.HalfBraiding.monoidal","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX : C\nself : CategoryTheory.HalfBraiding X\nU U' : C\nâŠ¢ Eq (self.Î² (CategoryTheory.MonoidalCategoryStruct.tensorObj U U')).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X U U').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (self.Î² U).hom U') (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator U X U').hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U (self.Î² U').hom) (CategoryTheory.MonoidalCategoryStruct.associator U U' X).inv))))","decl":"/-- A half-braiding on `X : C` is a family of isomorphisms `X âŠ— U â‰… U âŠ— X`,\nmonoidally natural in `U : C`.\n\nThinking of `C` as a 2-category with a single `0`-morphism, these are the same as natural\ntransformations (in the pseudo- sense) of the identity 2-functor on `C`, which send the unique\n`0`-morphism to `X`.\n-/\nstructure HalfBraiding (X : C) where\n  Î² : âˆ€ U, X âŠ— U â‰… U âŠ— X\n  monoidal : âˆ€ U U', (Î² (U âŠ— U')).hom =\n      (Î±_ _ _ _).inv â‰«\n        ((Î² U).hom â–· U') â‰« (Î±_ _ _ _).hom â‰« (U â— (Î² U').hom) â‰« (Î±_ _ _ _).inv := by\n    aesop_cat\n  naturality : âˆ€ {U U'} (f : U âŸ¶ U'), (X â— f) â‰« (Î² U').hom = (Î² U).hom â‰« (f â–· X) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.HalfBraiding.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nX : C\ninstâœ : SizeOf C\nÎ² : (U : C) â†’ CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj X U) (CategoryTheory.MonoidalCategoryStruct.tensorObj U X)\nmonoidal : autoParam (âˆ€ (U U' : C), Eq (Î² (CategoryTheory.MonoidalCategoryStruct.tensorObj U U')).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X U U').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (Î² U).hom U') (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator U X U').hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U (Î² U').hom) (CategoryTheory.MonoidalCategoryStruct.associator U U' X).inv))))) _autoâœ\nnaturality : autoParam (âˆ€ {U U' : C} (f : Quiver.Hom U U'), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) (Î² U').hom) (CategoryTheory.CategoryStruct.comp (Î² U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X))) _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { Î² := Î², monoidal := monoidal, naturality := naturality }) 1","decl":"/-- A half-braiding on `X : C` is a family of isomorphisms `X âŠ— U â‰… U âŠ— X`,\nmonoidally natural in `U : C`.\n\nThinking of `C` as a 2-category with a single `0`-morphism, these are the same as natural\ntransformations (in the pseudo- sense) of the identity 2-functor on `C`, which send the unique\n`0`-morphism to `X`.\n-/\nstructure HalfBraiding (X : C) where\n  Î² : âˆ€ U, X âŠ— U â‰… U âŠ— X\n  monoidal : âˆ€ U U', (Î² (U âŠ— U')).hom =\n      (Î±_ _ _ _).inv â‰«\n        ((Î² U).hom â–· U') â‰« (Î±_ _ _ _).hom â‰« (U â— (Î² U').hom) â‰« (Î±_ _ _ _).inv := by\n    aesop_cat\n  naturality : âˆ€ {U U'} (f : U âŸ¶ U'), (X â— f) â‰« (Î² U').hom = (Î² U).hom â‰« (f â–· X) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.HalfBraiding.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX : C\nÎ²âœ : (U : C) â†’ CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj X U) (CategoryTheory.MonoidalCategoryStruct.tensorObj U X)\nmonoidalâœ : autoParam (âˆ€ (U U' : C), Eq (Î²âœ (CategoryTheory.MonoidalCategoryStruct.tensorObj U U')).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X U U').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (Î²âœ U).hom U') (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator U X U').hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U (Î²âœ U').hom) (CategoryTheory.MonoidalCategoryStruct.associator U U' X).inv))))) _autoâœ\nnaturalityâœ : autoParam (âˆ€ {U U' : C} (f : Quiver.Hom U U'), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) (Î²âœ U').hom) (CategoryTheory.CategoryStruct.comp (Î²âœ U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X))) _autoâœ\nÎ² : (U : C) â†’ CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj X U) (CategoryTheory.MonoidalCategoryStruct.tensorObj U X)\nmonoidal : autoParam (âˆ€ (U U' : C), Eq (Î² (CategoryTheory.MonoidalCategoryStruct.tensorObj U U')).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X U U').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (Î² U).hom U') (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator U X U').hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U (Î² U').hom) (CategoryTheory.MonoidalCategoryStruct.associator U U' X).inv))))) _autoâœ\nnaturality : autoParam (âˆ€ {U U' : C} (f : Quiver.Hom U U'), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) (Î² U').hom) (CategoryTheory.CategoryStruct.comp (Î² U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X))) _autoâœ\nâŠ¢ Eq (Eq { Î² := Î²âœ, monoidal := monoidalâœ, naturality := naturalityâœ } { Î² := Î², monoidal := monoidal, naturality := naturality }) (Eq Î²âœ Î²)","decl":"/-- A half-braiding on `X : C` is a family of isomorphisms `X âŠ— U â‰… U âŠ— X`,\nmonoidally natural in `U : C`.\n\nThinking of `C` as a 2-category with a single `0`-morphism, these are the same as natural\ntransformations (in the pseudo- sense) of the identity 2-functor on `C`, which send the unique\n`0`-morphism to `X`.\n-/\nstructure HalfBraiding (X : C) where\n  Î² : âˆ€ U, X âŠ— U â‰… U âŠ— X\n  monoidal : âˆ€ U U', (Î² (U âŠ— U')).hom =\n      (Î±_ _ _ _).inv â‰«\n        ((Î² U).hom â–· U') â‰« (Î±_ _ _ _).hom â‰« (U â— (Î² U').hom) â‰« (Î±_ _ _ _).inv := by\n    aesop_cat\n  naturality : âˆ€ {U U'} (f : U âŸ¶ U'), (X â— f) â‰« (Î² U').hom = (Î² U).hom â‰« (f â–· X) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.HalfBraiding.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX : C\nÎ²âœ : (U : C) â†’ CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj X U) (CategoryTheory.MonoidalCategoryStruct.tensorObj U X)\nmonoidalâœ : autoParam (âˆ€ (U U' : C), Eq (Î²âœ (CategoryTheory.MonoidalCategoryStruct.tensorObj U U')).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X U U').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (Î²âœ U).hom U') (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator U X U').hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U (Î²âœ U').hom) (CategoryTheory.MonoidalCategoryStruct.associator U U' X).inv))))) _autoâœ\nnaturalityâœ : autoParam (âˆ€ {U U' : C} (f : Quiver.Hom U U'), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) (Î²âœ U').hom) (CategoryTheory.CategoryStruct.comp (Î²âœ U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X))) _autoâœ\nÎ² : (U : C) â†’ CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj X U) (CategoryTheory.MonoidalCategoryStruct.tensorObj U X)\nmonoidal : autoParam (âˆ€ (U U' : C), Eq (Î² (CategoryTheory.MonoidalCategoryStruct.tensorObj U U')).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X U U').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (Î² U).hom U') (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator U X U').hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U (Î² U').hom) (CategoryTheory.MonoidalCategoryStruct.associator U U' X).inv))))) _autoâœ\nnaturality : autoParam (âˆ€ {U U' : C} (f : Quiver.Hom U U'), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) (Î² U').hom) (CategoryTheory.CategoryStruct.comp (Î² U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X))) _autoâœ\nxâœ : Eq { Î² := Î²âœ, monoidal := monoidalâœ, naturality := naturalityâœ } { Î² := Î², monoidal := monoidal, naturality := naturality }\nâŠ¢ Eq Î²âœ Î²","decl":"/-- A half-braiding on `X : C` is a family of isomorphisms `X âŠ— U â‰… U âŠ— X`,\nmonoidally natural in `U : C`.\n\nThinking of `C` as a 2-category with a single `0`-morphism, these are the same as natural\ntransformations (in the pseudo- sense) of the identity 2-functor on `C`, which send the unique\n`0`-morphism to `X`.\n-/\nstructure HalfBraiding (X : C) where\n  Î² : âˆ€ U, X âŠ— U â‰… U âŠ— X\n  monoidal : âˆ€ U U', (Î² (U âŠ— U')).hom =\n      (Î±_ _ _ _).inv â‰«\n        ((Î² U).hom â–· U') â‰« (Î±_ _ _ _).hom â‰« (U â— (Î² U').hom) â‰« (Î±_ _ _ _).inv := by\n    aesop_cat\n  naturality : âˆ€ {U U'} (f : U âŸ¶ U'), (X â— f) â‰« (Î² U').hom = (Î² U).hom â‰« (f â–· X) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.HalfBraiding.monoidal_assoc","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX : C\nself : CategoryTheory.HalfBraiding X\nU U' Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj U U') X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (self.Î² (CategoryTheory.MonoidalCategoryStruct.tensorObj U U')).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X U U').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (self.Î² U).hom U') (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator U X U').hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U (self.Î² U').hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator U U' X).inv h)))))","decl":"attribute [reassoc, simp] HalfBraiding.monoidal -- the reassoc lemma is redundant as a simp lemma\n\n"}
{"name":"CategoryTheory.HalfBraiding.naturality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX : C\nself : CategoryTheory.HalfBraiding X\nU U' : C\nf : Quiver.Hom U U'\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj U' X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) (CategoryTheory.CategoryStruct.comp (self.Î² U').hom h)) (CategoryTheory.CategoryStruct.comp (self.Î² U).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X) h))","decl":"attribute [simp, reassoc] HalfBraiding.naturality\n\n"}
{"name":"CategoryTheory.Center.Hom.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nfâœ : Quiver.Hom X.fst Y.fst\ncommâœ : autoParam (âˆ€ (U : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight fâœ U) (Y.snd.Î² U).hom) (CategoryTheory.CategoryStruct.comp (X.snd.Î² U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U fâœ))) _autoâœ\nf : Quiver.Hom X.fst Y.fst\ncomm : autoParam (âˆ€ (U : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f U) (Y.snd.Î² U).hom) (CategoryTheory.CategoryStruct.comp (X.snd.Î² U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U f))) _autoâœ\nxâœ : Eq { f := fâœ, comm := commâœ } { f := f, comm := comm }\nâŠ¢ Eq fâœ f","decl":"/-- A morphism in the Drinfeld center of `C`. -/\n@[ext]\nstructure Hom (X Y : Center C) where\n  f : X.1 âŸ¶ Y.1\n  comm : âˆ€ U, (f â–· U) â‰« (Y.2.Î² U).hom = (X.2.Î² U).hom â‰« (U â— f) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Center.Hom.ext","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nx y : X.Hom Y\nf : Eq x.f y.f\nâŠ¢ Eq x y","decl":"/-- A morphism in the Drinfeld center of `C`. -/\n@[ext]\nstructure Hom (X Y : Center C) where\n  f : X.1 âŸ¶ Y.1\n  comm : âˆ€ U, (f â–· U) â‰« (Y.2.Î² U).hom = (X.2.Î² U).hom â‰« (U â— f) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Center.Hom.ext_iff","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nx y : X.Hom Y\nâŠ¢ Iff (Eq x y) (Eq x.f y.f)","decl":"/-- A morphism in the Drinfeld center of `C`. -/\n@[ext]\nstructure Hom (X Y : Center C) where\n  f : X.1 âŸ¶ Y.1\n  comm : âˆ€ U, (f â–· U) â‰« (Y.2.Î² U).hom = (X.2.Î² U).hom â‰« (U â— f) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Center.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\ninstâœ : SizeOf C\nf : Quiver.Hom X.fst Y.fst\ncomm : autoParam (âˆ€ (U : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f U) (Y.snd.Î² U).hom) (CategoryTheory.CategoryStruct.comp (X.snd.Î² U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U f))) _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { f := f, comm := comm }) (HAdd.hAdd 1 (SizeOf.sizeOf f))","decl":"/-- A morphism in the Drinfeld center of `C`. -/\n@[ext]\nstructure Hom (X Y : Center C) where\n  f : X.1 âŸ¶ Y.1\n  comm : âˆ€ U, (f â–· U) â‰« (Y.2.Î² U).hom = (X.2.Î² U).hom â‰« (U â— f) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Center.Hom.comm","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nself : X.Hom Y\nU : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.f U) (Y.snd.Î² U).hom) (CategoryTheory.CategoryStruct.comp (X.snd.Î² U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U self.f))","decl":"/-- A morphism in the Drinfeld center of `C`. -/\n@[ext]\nstructure Hom (X Y : Center C) where\n  f : X.1 âŸ¶ Y.1\n  comm : âˆ€ U, (f â–· U) â‰« (Y.2.Î² U).hom = (X.2.Î² U).hom â‰« (U â— f) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Center.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nfâœ : Quiver.Hom X.fst Y.fst\ncommâœ : autoParam (âˆ€ (U : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight fâœ U) (Y.snd.Î² U).hom) (CategoryTheory.CategoryStruct.comp (X.snd.Î² U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U fâœ))) _autoâœ\nf : Quiver.Hom X.fst Y.fst\ncomm : autoParam (âˆ€ (U : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f U) (Y.snd.Î² U).hom) (CategoryTheory.CategoryStruct.comp (X.snd.Î² U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U f))) _autoâœ\nâŠ¢ Eq (Eq { f := fâœ, comm := commâœ } { f := f, comm := comm }) (Eq fâœ f)","decl":"/-- A morphism in the Drinfeld center of `C`. -/\n@[ext]\nstructure Hom (X Y : Center C) where\n  f : X.1 âŸ¶ Y.1\n  comm : âˆ€ U, (f â–· U) â‰« (Y.2.Î² U).hom = (X.2.Î² U).hom â‰« (U â— f) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Center.Hom.comm_assoc","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nself : X.Hom Y\nU Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj U Y.fst) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.f U) (CategoryTheory.CategoryStruct.comp (Y.snd.Î² U).hom h)) (CategoryTheory.CategoryStruct.comp (X.snd.Î² U).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U self.f) h))","decl":"attribute [reassoc (attr := simp)] Hom.comm\n\n"}
{"name":"CategoryTheory.Center.ext","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nf g : Quiver.Hom X Y\nw : Eq f.f g.f\nâŠ¢ Eq f g","decl":"@[ext]\ntheorem ext {X Y : Center C} (f g : X âŸ¶ Y) (w : f.f = g.f) : f = g := by\n  cases f; cases g; congr\n\n"}
{"name":"CategoryTheory.Center.ext_iff","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nf g : Quiver.Hom X Y\nâŠ¢ Iff (Eq f g) (Eq f.f g.f)","decl":"@[ext]\ntheorem ext {X Y : Center C} (f g : X âŸ¶ Y) (w : f.f = g.f) : f = g := by\n  cases f; cases g; congr\n\n"}
{"name":"CategoryTheory.Center.id_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX : CategoryTheory.Center C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.id X).f (CategoryTheory.CategoryStruct.id X.fst)","decl":"@[simp]\ntheorem id_f (X : Center C) : Hom.f (ğŸ™ X) = ğŸ™ X.1 :=\n  rfl\n\n"}
{"name":"CategoryTheory.Center.comp_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y Z : CategoryTheory.Center C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f g).f (CategoryTheory.CategoryStruct.comp f.f g.f)","decl":"@[simp]\ntheorem comp_f {X Y Z : Center C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) : (f â‰« g).f = f.f â‰« g.f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Center.isoMk_inv_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsIso f.f\nâŠ¢ Eq (CategoryTheory.Center.isoMk f).inv.f (CategoryTheory.inv f.f)","decl":"/-- Construct an isomorphism in the Drinfeld center from\na morphism whose underlying morphism is an isomorphism.\n-/\n@[simps]\ndef isoMk {X Y : Center C} (f : X âŸ¶ Y) [IsIso f.f] : X â‰… Y where\n  hom := f\n  inv := âŸ¨inv f.f,\n    fun U => by simp [â† cancel_epi (f.f â–· U), â† comp_whiskerRight_assoc,\n      â† MonoidalCategory.whiskerLeft_comp] âŸ©\n\n"}
{"name":"CategoryTheory.Center.isoMk_hom","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsIso f.f\nâŠ¢ Eq (CategoryTheory.Center.isoMk f).hom f","decl":"/-- Construct an isomorphism in the Drinfeld center from\na morphism whose underlying morphism is an isomorphism.\n-/\n@[simps]\ndef isoMk {X Y : Center C} (f : X âŸ¶ Y) [IsIso f.f] : X â‰… Y where\n  hom := f\n  inv := âŸ¨inv f.f,\n    fun U => by simp [â† cancel_epi (f.f â–· U), â† comp_whiskerRight_assoc,\n      â† MonoidalCategory.whiskerLeft_comp] âŸ©\n\n"}
{"name":"CategoryTheory.Center.isIso_of_f_isIso","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsIso f.f\nâŠ¢ CategoryTheory.IsIso f","decl":"instance isIso_of_f_isIso {X Y : Center C} (f : X âŸ¶ Y) [IsIso f.f] : IsIso f := by\n  change IsIso (isoMk f).hom\n  infer_instance\n\n"}
{"name":"CategoryTheory.Center.tensorObj_snd_Î²","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nU : C\nâŠ¢ Eq ((X.tensorObj Y).snd.Î² U) ((CategoryTheory.MonoidalCategoryStruct.associator X.fst Y.fst U).trans ((CategoryTheory.MonoidalCategory.whiskerLeftIso X.fst (Y.snd.Î² U)).trans ((CategoryTheory.MonoidalCategoryStruct.associator X.fst U Y.fst).symm.trans ((CategoryTheory.MonoidalCategory.whiskerRightIso (X.snd.Î² U) Y.fst).trans (CategoryTheory.MonoidalCategoryStruct.associator U X.fst Y.fst)))))","decl":"/-- Auxiliary definition for the `MonoidalCategory` instance on `Center C`. -/\n@[simps]\ndef tensorObj (X Y : Center C) : Center C :=\n  âŸ¨X.1 âŠ— Y.1,\n    { Î² := fun U =>\n        Î±_ _ _ _ â‰ªâ‰«\n          (whiskerLeftIso X.1 (Y.2.Î² U)) â‰ªâ‰« (Î±_ _ _ _).symm â‰ªâ‰«\n            (whiskerRightIso (X.2.Î² U) Y.1) â‰ªâ‰« Î±_ _ _ _\n      monoidal := fun U U' => by\n        dsimp only [Iso.trans_hom, whiskerLeftIso_hom, Iso.symm_hom, whiskerRightIso_hom]\n        simp only [HalfBraiding.monoidal]\n        -- We'd like to commute `X.1 â— U â— (HalfBraiding.Î² Y.2 U').hom`\n        -- and `((HalfBraiding.Î² X.2 U).hom â–· U' â–· Y.1)` past each other.\n        -- We do this with the help of the monoidal composition `âŠ—â‰«` and the `coherence` tactic.\n        calc\n          _ = ğŸ™ _ âŠ—â‰«\n            X.1 â— (HalfBraiding.Î² Y.2 U).hom â–· U' âŠ—â‰«\n              (_ â— (HalfBraiding.Î² Y.2 U').hom â‰«\n                (HalfBraiding.Î² X.2 U).hom â–· _) âŠ—â‰«\n                  U â— (HalfBraiding.Î² X.2 U').hom â–· Y.1 âŠ—â‰« ğŸ™ _ := by monoidal\n          _ = _ := by rw [whisker_exchange]; monoidal\n      naturality := fun {U U'} f => by\n        dsimp only [Iso.trans_hom, whiskerLeftIso_hom, Iso.symm_hom, whiskerRightIso_hom]\n        calc\n          _ = ğŸ™ _ âŠ—â‰«\n            (X.1 â— (Y.1 â— f â‰« (HalfBraiding.Î² Y.2 U').hom)) âŠ—â‰«\n              (HalfBraiding.Î² X.2 U').hom â–· Y.1 âŠ—â‰« ğŸ™ _ := by monoidal\n          _ = ğŸ™ _ âŠ—â‰«\n            X.1 â— (HalfBraiding.Î² Y.2 U).hom âŠ—â‰«\n              (X.1 â— f â‰« (HalfBraiding.Î² X.2 U').hom) â–· Y.1 âŠ—â‰« ğŸ™ _ := by\n            rw [HalfBraiding.naturality]; monoidal\n          _ = _ := by rw [HalfBraiding.naturality]; monoidal }âŸ©\n\n"}
{"name":"CategoryTheory.Center.tensorObj_fst","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nâŠ¢ Eq (X.tensorObj Y).fst (CategoryTheory.MonoidalCategoryStruct.tensorObj X.fst Y.fst)","decl":"/-- Auxiliary definition for the `MonoidalCategory` instance on `Center C`. -/\n@[simps]\ndef tensorObj (X Y : Center C) : Center C :=\n  âŸ¨X.1 âŠ— Y.1,\n    { Î² := fun U =>\n        Î±_ _ _ _ â‰ªâ‰«\n          (whiskerLeftIso X.1 (Y.2.Î² U)) â‰ªâ‰« (Î±_ _ _ _).symm â‰ªâ‰«\n            (whiskerRightIso (X.2.Î² U) Y.1) â‰ªâ‰« Î±_ _ _ _\n      monoidal := fun U U' => by\n        dsimp only [Iso.trans_hom, whiskerLeftIso_hom, Iso.symm_hom, whiskerRightIso_hom]\n        simp only [HalfBraiding.monoidal]\n        -- We'd like to commute `X.1 â— U â— (HalfBraiding.Î² Y.2 U').hom`\n        -- and `((HalfBraiding.Î² X.2 U).hom â–· U' â–· Y.1)` past each other.\n        -- We do this with the help of the monoidal composition `âŠ—â‰«` and the `coherence` tactic.\n        calc\n          _ = ğŸ™ _ âŠ—â‰«\n            X.1 â— (HalfBraiding.Î² Y.2 U).hom â–· U' âŠ—â‰«\n              (_ â— (HalfBraiding.Î² Y.2 U').hom â‰«\n                (HalfBraiding.Î² X.2 U).hom â–· _) âŠ—â‰«\n                  U â— (HalfBraiding.Î² X.2 U').hom â–· Y.1 âŠ—â‰« ğŸ™ _ := by monoidal\n          _ = _ := by rw [whisker_exchange]; monoidal\n      naturality := fun {U U'} f => by\n        dsimp only [Iso.trans_hom, whiskerLeftIso_hom, Iso.symm_hom, whiskerRightIso_hom]\n        calc\n          _ = ğŸ™ _ âŠ—â‰«\n            (X.1 â— (Y.1 â— f â‰« (HalfBraiding.Î² Y.2 U').hom)) âŠ—â‰«\n              (HalfBraiding.Î² X.2 U').hom â–· Y.1 âŠ—â‰« ğŸ™ _ := by monoidal\n          _ = ğŸ™ _ âŠ—â‰«\n            X.1 â— (HalfBraiding.Î² Y.2 U).hom âŠ—â‰«\n              (X.1 â— f â‰« (HalfBraiding.Î² X.2 U').hom) â–· Y.1 âŠ—â‰« ğŸ™ _ := by\n            rw [HalfBraiding.naturality]; monoidal\n          _ = _ := by rw [HalfBraiding.naturality]; monoidal }âŸ©\n\n"}
{"name":"CategoryTheory.Center.whiskerLeft_comm","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Yâ‚ Yâ‚‚ : CategoryTheory.Center C\nf : Quiver.Hom Yâ‚ Yâ‚‚\nU : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.fst f.f) U) ((X.tensorObj Yâ‚‚).snd.Î² U).hom) (CategoryTheory.CategoryStruct.comp ((X.tensorObj Yâ‚).snd.Î² U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.fst f.f)))","decl":"@[reassoc]\ntheorem whiskerLeft_comm (X : Center C) {Yâ‚ Yâ‚‚ : Center C} (f : Yâ‚ âŸ¶ Yâ‚‚) (U : C) :\n    (X.1 â— f.f) â–· U â‰« ((tensorObj X Yâ‚‚).2.Î² U).hom =\n      ((tensorObj X Yâ‚).2.Î² U).hom â‰« U â— X.1 â— f.f := by\n  dsimp only [tensorObj_fst, tensorObj_snd_Î², Iso.trans_hom, whiskerLeftIso_hom,\n    Iso.symm_hom, whiskerRightIso_hom]\n  calc\n    _ = ğŸ™ _ âŠ—â‰«\n      X.fst â— (f.f â–· U â‰« (HalfBraiding.Î² Yâ‚‚.snd U).hom) âŠ—â‰«\n        (HalfBraiding.Î² X.snd U).hom â–· Yâ‚‚.fst âŠ—â‰« ğŸ™ _ := by monoidal\n    _ = ğŸ™ _ âŠ—â‰«\n      X.fst â— (HalfBraiding.Î² Yâ‚.snd U).hom âŠ—â‰«\n        ((X.fst âŠ— U) â— f.f â‰« (HalfBraiding.Î² X.snd U).hom â–· Yâ‚‚.fst) âŠ—â‰« ğŸ™ _ := by\n      rw [f.comm]; monoidal\n    _ = _ := by rw [whisker_exchange]; monoidal\n\n"}
{"name":"CategoryTheory.Center.whiskerLeft_comm_assoc","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Yâ‚ Yâ‚‚ : CategoryTheory.Center C\nf : Quiver.Hom Yâ‚ Yâ‚‚\nU Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj U (X.tensorObj Yâ‚‚).fst) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.fst f.f) U) (CategoryTheory.CategoryStruct.comp ((X.tensorObj Yâ‚‚).snd.Î² U).hom h)) (CategoryTheory.CategoryStruct.comp ((X.tensorObj Yâ‚).snd.Î² U).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.fst f.f)) h))","decl":"@[reassoc]\ntheorem whiskerLeft_comm (X : Center C) {Yâ‚ Yâ‚‚ : Center C} (f : Yâ‚ âŸ¶ Yâ‚‚) (U : C) :\n    (X.1 â— f.f) â–· U â‰« ((tensorObj X Yâ‚‚).2.Î² U).hom =\n      ((tensorObj X Yâ‚).2.Î² U).hom â‰« U â— X.1 â— f.f := by\n  dsimp only [tensorObj_fst, tensorObj_snd_Î², Iso.trans_hom, whiskerLeftIso_hom,\n    Iso.symm_hom, whiskerRightIso_hom]\n  calc\n    _ = ğŸ™ _ âŠ—â‰«\n      X.fst â— (f.f â–· U â‰« (HalfBraiding.Î² Yâ‚‚.snd U).hom) âŠ—â‰«\n        (HalfBraiding.Î² X.snd U).hom â–· Yâ‚‚.fst âŠ—â‰« ğŸ™ _ := by monoidal\n    _ = ğŸ™ _ âŠ—â‰«\n      X.fst â— (HalfBraiding.Î² Yâ‚.snd U).hom âŠ—â‰«\n        ((X.fst âŠ— U) â— f.f â‰« (HalfBraiding.Î² X.snd U).hom â–· Yâ‚‚.fst) âŠ—â‰« ğŸ™ _ := by\n      rw [f.comm]; monoidal\n    _ = _ := by rw [whisker_exchange]; monoidal\n\n"}
{"name":"CategoryTheory.Center.whiskerRight_comm","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nXâ‚ Xâ‚‚ : CategoryTheory.Center C\nf : Quiver.Hom Xâ‚ Xâ‚‚\nY : CategoryTheory.Center C\nU : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.f Y.fst) U) ((Xâ‚‚.tensorObj Y).snd.Î² U).hom) (CategoryTheory.CategoryStruct.comp ((Xâ‚.tensorObj Y).snd.Î² U).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.f Y.fst)))","decl":"@[reassoc]\ntheorem whiskerRight_comm {Xâ‚ Xâ‚‚ : Center C} (f : Xâ‚ âŸ¶ Xâ‚‚) (Y : Center C) (U : C) :\n    f.f â–· Y.1 â–· U â‰« ((tensorObj Xâ‚‚ Y).2.Î² U).hom =\n      ((tensorObj Xâ‚ Y).2.Î² U).hom â‰« U â— f.f â–· Y.1 := by\n  dsimp only [tensorObj_fst, tensorObj_snd_Î², Iso.trans_hom, whiskerLeftIso_hom,\n    Iso.symm_hom, whiskerRightIso_hom]\n  calc\n    _ = ğŸ™ _ âŠ—â‰«\n      (f.f â–· (Y.fst âŠ— U) â‰« Xâ‚‚.fst â— (HalfBraiding.Î² Y.snd U).hom) âŠ—â‰«\n        (HalfBraiding.Î² Xâ‚‚.snd U).hom â–· Y.fst âŠ—â‰« ğŸ™ _ := by monoidal\n    _ = ğŸ™ _ âŠ—â‰«\n      Xâ‚.fst â— (HalfBraiding.Î² Y.snd U).hom âŠ—â‰«\n        (f.f â–· U â‰« (HalfBraiding.Î² Xâ‚‚.snd U).hom) â–· Y.fst âŠ—â‰« ğŸ™ _ := by\n      rw [â† whisker_exchange]; monoidal\n    _ = _ := by rw [f.comm]; monoidal\n\n"}
{"name":"CategoryTheory.Center.whiskerRight_comm_assoc","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nXâ‚ Xâ‚‚ : CategoryTheory.Center C\nf : Quiver.Hom Xâ‚ Xâ‚‚\nY : CategoryTheory.Center C\nU Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj U (Xâ‚‚.tensorObj Y).fst) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.f Y.fst) U) (CategoryTheory.CategoryStruct.comp ((Xâ‚‚.tensorObj Y).snd.Î² U).hom h)) (CategoryTheory.CategoryStruct.comp ((Xâ‚.tensorObj Y).snd.Î² U).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft U (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.f Y.fst)) h))","decl":"@[reassoc]\ntheorem whiskerRight_comm {Xâ‚ Xâ‚‚ : Center C} (f : Xâ‚ âŸ¶ Xâ‚‚) (Y : Center C) (U : C) :\n    f.f â–· Y.1 â–· U â‰« ((tensorObj Xâ‚‚ Y).2.Î² U).hom =\n      ((tensorObj Xâ‚ Y).2.Î² U).hom â‰« U â— f.f â–· Y.1 := by\n  dsimp only [tensorObj_fst, tensorObj_snd_Î², Iso.trans_hom, whiskerLeftIso_hom,\n    Iso.symm_hom, whiskerRightIso_hom]\n  calc\n    _ = ğŸ™ _ âŠ—â‰«\n      (f.f â–· (Y.fst âŠ— U) â‰« Xâ‚‚.fst â— (HalfBraiding.Î² Y.snd U).hom) âŠ—â‰«\n        (HalfBraiding.Î² Xâ‚‚.snd U).hom â–· Y.fst âŠ—â‰« ğŸ™ _ := by monoidal\n    _ = ğŸ™ _ âŠ—â‰«\n      Xâ‚.fst â— (HalfBraiding.Î² Y.snd U).hom âŠ—â‰«\n        (f.f â–· U â‰« (HalfBraiding.Î² Xâ‚‚.snd U).hom) â–· Y.fst âŠ—â‰« ğŸ™ _ := by\n      rw [â† whisker_exchange]; monoidal\n    _ = _ := by rw [f.comm]; monoidal\n\n"}
{"name":"CategoryTheory.Center.tensorHom_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nXâ‚ Yâ‚ Xâ‚‚ Yâ‚‚ : CategoryTheory.Center C\nf : Quiver.Hom Xâ‚ Yâ‚\ng : Quiver.Hom Xâ‚‚ Yâ‚‚\nâŠ¢ Eq (CategoryTheory.Center.tensorHom f g).f (CategoryTheory.MonoidalCategoryStruct.tensorHom f.f g.f)","decl":"/-- Auxiliary definition for the `MonoidalCategory` instance on `Center C`. -/\n@[simps]\ndef tensorHom {Xâ‚ Yâ‚ Xâ‚‚ Yâ‚‚ : Center C} (f : Xâ‚ âŸ¶ Yâ‚) (g : Xâ‚‚ âŸ¶ Yâ‚‚) :\n    tensorObj Xâ‚ Xâ‚‚ âŸ¶ tensorObj Yâ‚ Yâ‚‚ where\n  f := f.f âŠ— g.f\n  comm U := by\n    rw [tensorHom_def, comp_whiskerRight_assoc, whiskerLeft_comm, whiskerRight_comm_assoc,\n      MonoidalCategory.whiskerLeft_comp]\n\n"}
{"name":"CategoryTheory.Center.tensorUnit_snd_Î²","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nU : C\nâŠ¢ Eq (CategoryTheory.Center.tensorUnit.snd.Î² U) ((CategoryTheory.MonoidalCategoryStruct.leftUnitor U).trans (CategoryTheory.MonoidalCategoryStruct.rightUnitor U).symm)","decl":"/-- Auxiliary definition for the `MonoidalCategory` instance on `Center C`. -/\n@[simps]\ndef tensorUnit : Center C :=\n  âŸ¨ğŸ™_ C, { Î² := fun U => Î»_ U â‰ªâ‰« (Ï_ U).symm }âŸ©\n\n"}
{"name":"CategoryTheory.Center.tensorUnit_fst","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nâŠ¢ Eq CategoryTheory.Center.tensorUnit.fst CategoryTheory.MonoidalCategoryStruct.tensorUnit","decl":"/-- Auxiliary definition for the `MonoidalCategory` instance on `Center C`. -/\n@[simps]\ndef tensorUnit : Center C :=\n  âŸ¨ğŸ™_ C, { Î² := fun U => Î»_ U â‰ªâ‰« (Ï_ U).symm }âŸ©\n\n"}
{"name":"CategoryTheory.Center.tensor_fst","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).fst (CategoryTheory.MonoidalCategoryStruct.tensorObj X.fst Y.fst)","decl":"@[simp]\ntheorem tensor_fst (X Y : Center C) : (X âŠ— Y).1 = X.1 âŠ— Y.1 :=\n  rfl\n\n"}
{"name":"CategoryTheory.Center.tensor_Î²","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nU : C\nâŠ¢ Eq ((CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).snd.Î² U) ((CategoryTheory.MonoidalCategoryStruct.associator X.fst Y.fst U).trans ((CategoryTheory.MonoidalCategory.whiskerLeftIso X.fst (Y.snd.Î² U)).trans ((CategoryTheory.MonoidalCategoryStruct.associator X.fst U Y.fst).symm.trans ((CategoryTheory.MonoidalCategory.whiskerRightIso (X.snd.Î² U) Y.fst).trans (CategoryTheory.MonoidalCategoryStruct.associator U X.fst Y.fst)))))","decl":"@[simp]\ntheorem tensor_Î² (X Y : Center C) (U : C) :\n    (X âŠ— Y).2.Î² U =\n      Î±_ _ _ _ â‰ªâ‰«\n        (whiskerLeftIso X.1 (Y.2.Î² U)) â‰ªâ‰« (Î±_ _ _ _).symm â‰ªâ‰«\n          (whiskerRightIso (X.2.Î² U) Y.1) â‰ªâ‰« Î±_ _ _ _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Center.whiskerLeft_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Yâ‚ Yâ‚‚ : CategoryTheory.Center C\nf : Quiver.Hom Yâ‚ Yâ‚‚\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f).f (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.fst f.f)","decl":"@[simp]\ntheorem whiskerLeft_f (X : Center C) {Yâ‚ Yâ‚‚ : Center C} (f : Yâ‚ âŸ¶ Yâ‚‚) : (X â— f).f = X.1 â— f.f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Center.whiskerRight_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nXâ‚ Xâ‚‚ : CategoryTheory.Center C\nf : Quiver.Hom Xâ‚ Xâ‚‚\nY : CategoryTheory.Center C\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y).f (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.f Y.fst)","decl":"@[simp]\ntheorem whiskerRight_f {Xâ‚ Xâ‚‚ : Center C} (f : Xâ‚ âŸ¶ Xâ‚‚) (Y : Center C) : (f â–· Y).f = f.f â–· Y.1 :=\n  rfl\n\n"}
{"name":"CategoryTheory.Center.tensor_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nXâ‚ Yâ‚ Xâ‚‚ Yâ‚‚ : CategoryTheory.Center C\nf : Quiver.Hom Xâ‚ Yâ‚\ng : Quiver.Hom Xâ‚‚ Yâ‚‚\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f g).f (CategoryTheory.MonoidalCategoryStruct.tensorHom f.f g.f)","decl":"@[simp]\ntheorem tensor_f {Xâ‚ Yâ‚ Xâ‚‚ Yâ‚‚ : Center C} (f : Xâ‚ âŸ¶ Yâ‚) (g : Xâ‚‚ âŸ¶ Yâ‚‚) : (f âŠ— g).f = f.f âŠ— g.f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Center.tensorUnit_Î²","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nU : C\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorUnit.snd.Î² U) ((CategoryTheory.MonoidalCategoryStruct.leftUnitor U).trans (CategoryTheory.MonoidalCategoryStruct.rightUnitor U).symm)","decl":"@[simp]\ntheorem tensorUnit_Î² (U : C) : (ğŸ™_ (Center C)).2.Î² U = Î»_ U â‰ªâ‰« (Ï_ U).symm :=\n  rfl\n\n"}
{"name":"CategoryTheory.Center.associator_hom_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y Z : CategoryTheory.Center C\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom.f (CategoryTheory.MonoidalCategoryStruct.associator X.fst Y.fst Z.fst).hom","decl":"@[simp]\ntheorem associator_hom_f (X Y Z : Center C) : Hom.f (Î±_ X Y Z).hom = (Î±_ X.1 Y.1 Z.1).hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Center.associator_inv_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y Z : CategoryTheory.Center C\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv.f (CategoryTheory.MonoidalCategoryStruct.associator X.fst Y.fst Z.fst).inv","decl":"@[simp]\ntheorem associator_inv_f (X Y Z : Center C) : Hom.f (Î±_ X Y Z).inv = (Î±_ X.1 Y.1 Z.1).inv := by\n  apply Iso.inv_ext' -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): Originally `ext`\n  rw [â† associator_hom_f, â† comp_f, Iso.hom_inv_id]; rfl\n\n"}
{"name":"CategoryTheory.Center.leftUnitor_hom_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX : CategoryTheory.Center C\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom.f (CategoryTheory.MonoidalCategoryStruct.leftUnitor X.fst).hom","decl":"@[simp]\ntheorem leftUnitor_hom_f (X : Center C) : Hom.f (Î»_ X).hom = (Î»_ X.1).hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Center.leftUnitor_inv_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX : CategoryTheory.Center C\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv.f (CategoryTheory.MonoidalCategoryStruct.leftUnitor X.fst).inv","decl":"@[simp]\ntheorem leftUnitor_inv_f (X : Center C) : Hom.f (Î»_ X).inv = (Î»_ X.1).inv := by\n  apply Iso.inv_ext' -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): Originally `ext`\n  rw [â† leftUnitor_hom_f, â† comp_f, Iso.hom_inv_id]; rfl\n\n"}
{"name":"CategoryTheory.Center.rightUnitor_hom_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX : CategoryTheory.Center C\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom.f (CategoryTheory.MonoidalCategoryStruct.rightUnitor X.fst).hom","decl":"@[simp]\ntheorem rightUnitor_hom_f (X : Center C) : Hom.f (Ï_ X).hom = (Ï_ X.1).hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Center.rightUnitor_inv_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX : CategoryTheory.Center C\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv.f (CategoryTheory.MonoidalCategoryStruct.rightUnitor X.fst).inv","decl":"@[simp]\ntheorem rightUnitor_inv_f (X : Center C) : Hom.f (Ï_ X).inv = (Ï_ X.1).inv := by\n  apply Iso.inv_ext' -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): Originally `ext`\n  rw [â† rightUnitor_hom_f, â† comp_f, Iso.hom_inv_id]; rfl\n\n"}
{"name":"CategoryTheory.Center.forget_map","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nXâœ Yâœ : CategoryTheory.Center C\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Center.forget C).map f) f.f","decl":"/-- The forgetful monoidal functor from the Drinfeld center to the original category. -/\n@[simps]\ndef forget : Center C â¥¤ C where\n  obj X := X.1\n  map f := f.f\n\n"}
{"name":"CategoryTheory.Center.forget_obj","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX : CategoryTheory.Center C\nâŠ¢ Eq ((CategoryTheory.Center.forget C).obj X) X.fst","decl":"/-- The forgetful monoidal functor from the Drinfeld center to the original category. -/\n@[simps]\ndef forget : Center C â¥¤ C where\n  obj X := X.1\n  map f := f.f\n\n"}
{"name":"CategoryTheory.Center.forget_Îµ","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nâŠ¢ Eq (CategoryTheory.Functor.LaxMonoidal.Îµ (CategoryTheory.Center.forget C)) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"@[simp] lemma forget_Îµ : Îµ (forget C) = ğŸ™ _ := rfl\n"}
{"name":"CategoryTheory.Center.forget_Î·","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nâŠ¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Î· (CategoryTheory.Center.forget C)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Center.forget C).obj CategoryTheory.MonoidalCategoryStruct.tensorUnit))","decl":"@[simp] lemma forget_Î· : Î· (forget C) = ğŸ™ _ := rfl\n\n"}
{"name":"CategoryTheory.Center.forget_Î¼","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nâŠ¢ Eq (CategoryTheory.Functor.LaxMonoidal.Î¼ (CategoryTheory.Center.forget C) X Y) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj ((CategoryTheory.Center.forget C).obj X) ((CategoryTheory.Center.forget C).obj Y)))","decl":"@[simp] lemma forget_Î¼ (X Y : Center C) : Î¼ (forget C) X Y = ğŸ™ _ := rfl\n"}
{"name":"CategoryTheory.Center.forget_Î´","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nâŠ¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Î´ (CategoryTheory.Center.forget C) X Y) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Center.forget C).obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)))","decl":"@[simp] lemma forget_Î´ (X Y : Center C) : Î´ (forget C) X Y = ğŸ™ _ := rfl\n\n"}
{"name":"CategoryTheory.Center.instReflectsIsomorphismsForget","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nâŠ¢ (CategoryTheory.Center.forget C).ReflectsIsomorphisms","decl":"instance : (forget C).ReflectsIsomorphisms where\n  reflects f i := by dsimp at i; change IsIso (isoMk f).hom; infer_instance\n\n"}
{"name":"CategoryTheory.Center.braiding_inv_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nâŠ¢ Eq (X.braiding Y).inv.f (X.snd.Î² Y.fst).inv","decl":"/-- Auxiliary definition for the `BraidedCategory` instance on `Center C`. -/\n@[simps!]\ndef braiding (X Y : Center C) : X âŠ— Y â‰… Y âŠ— X :=\n  isoMk\n    âŸ¨(X.2.Î² Y.1).hom, fun U => by\n      dsimp\n      simp only [Category.assoc]\n      rw [â† IsIso.inv_comp_eq, IsIso.Iso.inv_hom, â† HalfBraiding.monoidal_assoc,\n        â† HalfBraiding.naturality_assoc, HalfBraiding.monoidal]\n      simpâŸ©\n\n"}
{"name":"CategoryTheory.Center.braiding_hom_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : CategoryTheory.Center C\nâŠ¢ Eq (X.braiding Y).hom.f (X.snd.Î² Y.fst).hom","decl":"/-- Auxiliary definition for the `BraidedCategory` instance on `Center C`. -/\n@[simps!]\ndef braiding (X Y : Center C) : X âŠ— Y â‰… Y âŠ— X :=\n  isoMk\n    âŸ¨(X.2.Î² Y.1).hom, fun U => by\n      dsimp\n      simp only [Category.assoc]\n      rw [â† IsIso.inv_comp_eq, IsIso.Iso.inv_hom, â† HalfBraiding.monoidal_assoc,\n        â† HalfBraiding.naturality_assoc, HalfBraiding.monoidal]\n      simpâŸ©\n\n"}
{"name":"CategoryTheory.Center.ofBraidedObj_snd_Î²","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\ninstâœ : CategoryTheory.BraidedCategory C\nX Y : C\nâŠ¢ Eq ((CategoryTheory.Center.ofBraidedObj X).snd.Î² Y) (CategoryTheory.BraidedCategory.braiding X Y)","decl":"/-- Auxiliary construction for `ofBraided`. -/\n@[simps]\ndef ofBraidedObj (X : C) : Center C :=\n  âŸ¨X, { Î² := fun Y => Î²_ X Y}âŸ©\n\n"}
{"name":"CategoryTheory.Center.ofBraidedObj_fst","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\ninstâœ : CategoryTheory.BraidedCategory C\nX : C\nâŠ¢ Eq (CategoryTheory.Center.ofBraidedObj X).fst X","decl":"/-- Auxiliary construction for `ofBraided`. -/\n@[simps]\ndef ofBraidedObj (X : C) : Center C :=\n  âŸ¨X, { Î² := fun Y => Î²_ X Y}âŸ©\n\n"}
{"name":"CategoryTheory.Center.ofBraided_obj","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\ninstâœ : CategoryTheory.BraidedCategory C\nX : C\nâŠ¢ Eq ((CategoryTheory.Center.ofBraided C).obj X) (CategoryTheory.Center.ofBraidedObj X)","decl":"/-- The functor lifting a braided category to its center, using the braiding as the half-braiding.\n-/\n@[simps]\ndef ofBraided : C â¥¤ Center C where\n  obj := ofBraidedObj\n  map f :=\n    { f\n      comm := fun U => braiding_naturality_left f U }\n\n"}
{"name":"CategoryTheory.Center.ofBraided_map_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\ninstâœ : CategoryTheory.BraidedCategory C\nXâœ Yâœ : C\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Center.ofBraided C).map f).f f","decl":"/-- The functor lifting a braided category to its center, using the braiding as the half-braiding.\n-/\n@[simps]\ndef ofBraided : C â¥¤ Center C where\n  obj := ofBraidedObj\n  map f :=\n    { f\n      comm := fun U => braiding_naturality_left f U }\n\n"}
{"name":"CategoryTheory.Center.ofBraided_Îµ_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\ninstâœ : CategoryTheory.BraidedCategory C\nâŠ¢ Eq (CategoryTheory.Functor.LaxMonoidal.Îµ (CategoryTheory.Center.ofBraided C)).f (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit.fst)","decl":"@[simp] lemma ofBraided_Îµ_f : (Îµ (ofBraided C)).f = ğŸ™ _ := rfl\n"}
{"name":"CategoryTheory.Center.ofBraided_Î·_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\ninstâœ : CategoryTheory.BraidedCategory C\nâŠ¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Î· (CategoryTheory.Center.ofBraided C)).f (CategoryTheory.CategoryStruct.id ((CategoryTheory.Center.ofBraided C).obj CategoryTheory.MonoidalCategoryStruct.tensorUnit).fst)","decl":"@[simp] lemma ofBraided_Î·_f : (Î· (ofBraided C)).f = ğŸ™ _ := rfl\n\n"}
{"name":"CategoryTheory.Center.ofBraided_Î¼_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\ninstâœ : CategoryTheory.BraidedCategory C\nX Y : C\nâŠ¢ Eq (CategoryTheory.Functor.LaxMonoidal.Î¼ (CategoryTheory.Center.ofBraided C) X Y).f (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj ((CategoryTheory.Center.ofBraided C).obj X) ((CategoryTheory.Center.ofBraided C).obj Y)).fst)","decl":"@[simp] lemma ofBraided_Î¼_f (X Y : C) : (Î¼ (ofBraided C) X Y).f = ğŸ™ _ := rfl\n"}
{"name":"CategoryTheory.Center.ofBraided_Î´_f","module":"Mathlib.CategoryTheory.Monoidal.Center","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\ninstâœ : CategoryTheory.BraidedCategory C\nX Y : C\nâŠ¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Î´ (CategoryTheory.Center.ofBraided C) X Y).f (CategoryTheory.CategoryStruct.id ((CategoryTheory.Center.ofBraided C).obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)).fst)","decl":"@[simp] lemma ofBraided_Î´_f (X Y : C) : (Î´ (ofBraided C) X Y).f = ğŸ™ _ := rfl\n\n"}
