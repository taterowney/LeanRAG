{"name":"isLocalHom_of_le_jacobson_bot","module":"Mathlib.RingTheory.Henselian","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : Ideal R\nh : LE.le I Bot.bot.jacobson\n⊢ IsLocalHom (Ideal.Quotient.mk I)","decl":"theorem isLocalHom_of_le_jacobson_bot {R : Type*} [CommRing R] (I : Ideal R)\n    (h : I ≤ Ideal.jacobson ⊥) : IsLocalHom (Ideal.Quotient.mk I) := by\n  constructor\n  intro a h\n  have : IsUnit (Ideal.Quotient.mk (Ideal.jacobson ⊥) a) := by\n    rw [isUnit_iff_exists_inv] at *\n    obtain ⟨b, hb⟩ := h\n    obtain ⟨b, rfl⟩ := Ideal.Quotient.mk_surjective b\n    use Ideal.Quotient.mk _ b\n    rw [← (Ideal.Quotient.mk _).map_one, ← (Ideal.Quotient.mk _).map_mul, Ideal.Quotient.eq] at hb ⊢\n    exact h hb\n  obtain ⟨⟨x, y, h1, h2⟩, rfl : x = _⟩ := this\n  obtain ⟨y, rfl⟩ := Ideal.Quotient.mk_surjective y\n  rw [← (Ideal.Quotient.mk _).map_mul, ← (Ideal.Quotient.mk _).map_one, Ideal.Quotient.eq,\n    Ideal.mem_jacobson_bot] at h1 h2\n  specialize h1 1\n  simp? at h1 says simp only [mul_one, sub_add_cancel, IsUnit.mul_iff] at h1\n  exact h1.1\n\n"}
{"name":"isLocalRingHom_of_le_jacobson_bot","module":"Mathlib.RingTheory.Henselian","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : Ideal R\nh : LE.le I Bot.bot.jacobson\n⊢ IsLocalHom (Ideal.Quotient.mk I)","decl":"@[deprecated (since := \"2024-10-10\")]\nalias isLocalRingHom_of_le_jacobson_bot := isLocalHom_of_le_jacobson_bot\n\n"}
{"name":"HenselianRing.jac","module":"Mathlib.RingTheory.Henselian","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : Ideal R\nself : HenselianRing R I\n⊢ LE.le I Bot.bot.jacobson","decl":"/-- A ring `R` is *Henselian* at an ideal `I` if the following condition holds:\nfor every polynomial `f` over `R`, with a *simple* root `a₀` over the quotient ring `R/I`,\nthere exists a lift `a : R` of `a₀` that is a root of `f`.\n\n(Here, saying that a root `b` of a polynomial `g` is *simple* means that `g.derivative.eval b` is a\nunit. Warning: if `R/I` is not a field then it is not enough to assume that `g` has a factorization\ninto monic linear factors in which `X - b` shows up only once; for example `1` is not a simple root\nof `X^2-1` over `ℤ/4ℤ`.) -/\nclass HenselianRing (R : Type*) [CommRing R] (I : Ideal R) : Prop where\n  jac : I ≤ Ideal.jacobson ⊥\n  is_henselian :\n    ∀ (f : R[X]) (_ : f.Monic) (a₀ : R) (_ : f.eval a₀ ∈ I)\n      (_ : IsUnit (Ideal.Quotient.mk I (f.derivative.eval a₀))), ∃ a : R, f.IsRoot a ∧ a - a₀ ∈ I\n\n"}
{"name":"HenselianRing.is_henselian","module":"Mathlib.RingTheory.Henselian","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : Ideal R\nself : HenselianRing R I\nf : Polynomial R\nx✝² : f.Monic\na₀ : R\nx✝¹ : Membership.mem I (Polynomial.eval a₀ f)\nx✝ : IsUnit ((Ideal.Quotient.mk I) (Polynomial.eval a₀ (Polynomial.derivative f)))\n⊢ Exists fun a => And (f.IsRoot a) (Membership.mem I (HSub.hSub a a₀))","decl":"/-- A ring `R` is *Henselian* at an ideal `I` if the following condition holds:\nfor every polynomial `f` over `R`, with a *simple* root `a₀` over the quotient ring `R/I`,\nthere exists a lift `a : R` of `a₀` that is a root of `f`.\n\n(Here, saying that a root `b` of a polynomial `g` is *simple* means that `g.derivative.eval b` is a\nunit. Warning: if `R/I` is not a field then it is not enough to assume that `g` has a factorization\ninto monic linear factors in which `X - b` shows up only once; for example `1` is not a simple root\nof `X^2-1` over `ℤ/4ℤ`.) -/\nclass HenselianRing (R : Type*) [CommRing R] (I : Ideal R) : Prop where\n  jac : I ≤ Ideal.jacobson ⊥\n  is_henselian :\n    ∀ (f : R[X]) (_ : f.Monic) (a₀ : R) (_ : f.eval a₀ ∈ I)\n      (_ : IsUnit (Ideal.Quotient.mk I (f.derivative.eval a₀))), ∃ a : R, f.IsRoot a ∧ a - a₀ ∈ I\n\n"}
{"name":"HenselianLocalRing.is_henselian","module":"Mathlib.RingTheory.Henselian","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nself : HenselianLocalRing R\nf : Polynomial R\nx✝² : f.Monic\na₀ : R\nx✝¹ : Membership.mem (IsLocalRing.maximalIdeal R) (Polynomial.eval a₀ f)\nx✝ : IsUnit (Polynomial.eval a₀ (Polynomial.derivative f))\n⊢ Exists fun a => And (f.IsRoot a) (Membership.mem (IsLocalRing.maximalIdeal R) (HSub.hSub a a₀))","decl":"/-- A local ring `R` is *Henselian* if the following condition holds:\nfor every polynomial `f` over `R`, with a *simple* root `a₀` over the residue field,\nthere exists a lift `a : R` of `a₀` that is a root of `f`.\n(Recall that a root `b` of a polynomial `g` is *simple* if it is not a double root, so if\n`g.derivative.eval b ≠ 0`.)\n\nIn other words, `R` is local Henselian if it is Henselian at the ideal `I`,\nin the sense of `HenselianRing`. -/\nclass HenselianLocalRing (R : Type*) [CommRing R] extends IsLocalRing R : Prop where\n  is_henselian :\n    ∀ (f : R[X]) (_ : f.Monic) (a₀ : R) (_ : f.eval a₀ ∈ maximalIdeal R)\n      (_ : IsUnit (f.derivative.eval a₀)), ∃ a : R, f.IsRoot a ∧ a - a₀ ∈ maximalIdeal R\n\n-- see Note [lower instance priority]\n"}
{"name":"HenselianLocalRing.toIsLocalRing","module":"Mathlib.RingTheory.Henselian","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nself : HenselianLocalRing R\n⊢ IsLocalRing R","decl":"/-- A local ring `R` is *Henselian* if the following condition holds:\nfor every polynomial `f` over `R`, with a *simple* root `a₀` over the residue field,\nthere exists a lift `a : R` of `a₀` that is a root of `f`.\n(Recall that a root `b` of a polynomial `g` is *simple* if it is not a double root, so if\n`g.derivative.eval b ≠ 0`.)\n\nIn other words, `R` is local Henselian if it is Henselian at the ideal `I`,\nin the sense of `HenselianRing`. -/\nclass HenselianLocalRing (R : Type*) [CommRing R] extends IsLocalRing R : Prop where\n  is_henselian :\n    ∀ (f : R[X]) (_ : f.Monic) (a₀ : R) (_ : f.eval a₀ ∈ maximalIdeal R)\n      (_ : IsUnit (f.derivative.eval a₀)), ∃ a : R, f.IsRoot a ∧ a - a₀ ∈ maximalIdeal R\n\n-- see Note [lower instance priority]\n"}
{"name":"Field.henselian","module":"Mathlib.RingTheory.Henselian","initialProofState":"K : Type u_1\ninst✝ : Field K\n⊢ HenselianLocalRing K","decl":"instance (priority := 100) Field.henselian (K : Type*) [Field K] : HenselianLocalRing K where\n  is_henselian f _ a₀ h₁ _ := by\n    simp only [(maximalIdeal K).eq_bot_of_prime, Ideal.mem_bot] at h₁ ⊢\n    exact ⟨a₀, h₁, sub_self _⟩\n\n"}
{"name":"HenselianLocalRing.TFAE","module":"Mathlib.RingTheory.Henselian","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsLocalRing R\n⊢ (List.cons (HenselianLocalRing R) (List.cons (∀ (f : Polynomial R), f.Monic → ∀ (a₀ : IsLocalRing.ResidueField R), Eq ((Polynomial.aeval a₀) f) 0 → Ne ((Polynomial.aeval a₀) (Polynomial.derivative f)) 0 → Exists fun a => And (f.IsRoot a) (Eq ((IsLocalRing.residue R) a) a₀)) (List.cons (∀ {K : Type u} [inst : Field K] (φ : RingHom R K), Function.Surjective ⇑φ → ∀ (f : Polynomial R), f.Monic → ∀ (a₀ : K), Eq (Polynomial.eval₂ φ a₀ f) 0 → Ne (Polynomial.eval₂ φ a₀ (Polynomial.derivative f)) 0 → Exists fun a => And (f.IsRoot a) (Eq (φ a) a₀)) List.nil))).TFAE","decl":"theorem HenselianLocalRing.TFAE (R : Type u) [CommRing R] [IsLocalRing R] :\n    TFAE\n      [HenselianLocalRing R,\n        ∀ f : R[X], f.Monic → ∀ a₀ : ResidueField R, aeval a₀ f = 0 →\n          aeval a₀ (derivative f) ≠ 0 → ∃ a : R, f.IsRoot a ∧ residue R a = a₀,\n        ∀ {K : Type u} [Field K],\n          ∀ (φ : R →+* K), Surjective φ → ∀ f : R[X], f.Monic → ∀ a₀ : K,\n            f.eval₂ φ a₀ = 0 → f.derivative.eval₂ φ a₀ ≠ 0 → ∃ a : R, f.IsRoot a ∧ φ a = a₀] := by\n  tfae_have 3 → 2\n  | H => H (residue R) Ideal.Quotient.mk_surjective\n  tfae_have 2 → 1\n  | H => by\n    constructor\n    intro f hf a₀ h₁ h₂\n    specialize H f hf (residue R a₀)\n    have aux := flip mem_nonunits_iff.mp h₂\n    simp only [aeval_def, ResidueField.algebraMap_eq, eval₂_at_apply, ←\n      Ideal.Quotient.eq_zero_iff_mem, ← IsLocalRing.mem_maximalIdeal] at H h₁ aux\n    obtain ⟨a, ha₁, ha₂⟩ := H h₁ aux\n    refine ⟨a, ha₁, ?_⟩\n    rw [← Ideal.Quotient.eq_zero_iff_mem]\n    rwa [← sub_eq_zero, ← RingHom.map_sub] at ha₂\n  tfae_have 1 → 3\n  | hR, K, _K, φ, hφ, f, hf, a₀, h₁, h₂ => by\n    obtain ⟨a₀, rfl⟩ := hφ a₀\n    have H := HenselianLocalRing.is_henselian f hf a₀\n    simp only [← ker_eq_maximalIdeal φ hφ, eval₂_at_apply, RingHom.mem_ker] at H h₁ h₂\n    obtain ⟨a, ha₁, ha₂⟩ := H h₁ (by\n      contrapose! h₂\n      rwa [← mem_nonunits_iff, ← mem_maximalIdeal, ← ker_eq_maximalIdeal φ hφ,\n        RingHom.mem_ker] at h₂)\n    refine ⟨a, ha₁, ?_⟩\n    rwa [φ.map_sub, sub_eq_zero] at ha₂\n  tfae_finish\n\n"}
{"name":"instHenselianRingMaximalIdeal","module":"Mathlib.RingTheory.Henselian","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nhR : HenselianLocalRing R\n⊢ HenselianRing R (IsLocalRing.maximalIdeal R)","decl":"instance (R : Type*) [CommRing R] [hR : HenselianLocalRing R] :\n    HenselianRing R (maximalIdeal R) where\n  jac := by\n    rw [Ideal.jacobson, le_sInf_iff]\n    rintro I ⟨-, hI⟩\n    exact (eq_maximalIdeal hI).ge\n  is_henselian := by\n    intro f hf a₀ h₁ h₂\n    refine HenselianLocalRing.is_henselian f hf a₀ h₁ ?_\n    contrapose! h₂\n    rw [← mem_nonunits_iff, ← IsLocalRing.mem_maximalIdeal, ← Ideal.Quotient.eq_zero_iff_mem] at h₂\n    rw [h₂]\n    exact not_isUnit_zero\n\n-- see Note [lower instance priority]\n"}
{"name":"IsAdicComplete.henselianRing","module":"Mathlib.RingTheory.Henselian","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nI : Ideal R\ninst✝ : IsAdicComplete I R\n⊢ HenselianRing R I","decl":"/-- A ring `R` that is `I`-adically complete is Henselian at `I`. -/\ninstance (priority := 100) IsAdicComplete.henselianRing (R : Type*) [CommRing R] (I : Ideal R)\n    [IsAdicComplete I R] : HenselianRing R I where\n  jac := IsAdicComplete.le_jacobson_bot _\n  is_henselian := by\n    intro f _ a₀ h₁ h₂\n    classical\n      let f' := derivative f\n      -- we define a sequence `c n` by starting at `a₀` and then continually\n      -- applying the function sending `b` to `b - f(b)/f'(b)` (Newton's method).\n      -- Note that `f'.eval b` is a unit, because `b` has the same residue as `a₀` modulo `I`.\n      let c : ℕ → R := fun n => Nat.recOn n a₀ fun _ b => b - f.eval b * Ring.inverse (f'.eval b)\n      have hc : ∀ n, c (n + 1) = c n - f.eval (c n) * Ring.inverse (f'.eval (c n)) := by\n        intro n\n        simp only [c, Nat.rec_add_one]\n      -- we now spend some time determining properties of the sequence `c : ℕ → R`\n      -- `hc_mod`: for every `n`, we have `c n ≡ a₀ [SMOD I]`\n      -- `hf'c`  : for every `n`, `f'.eval (c n)` is a unit\n      -- `hfcI`  : for every `n`, `f.eval (c n)` is contained in `I ^ (n+1)`\n      have hc_mod : ∀ n, c n ≡ a₀ [SMOD I] := by\n        intro n\n        induction' n with n ih\n        · rfl\n        rw [hc, sub_eq_add_neg, ← add_zero a₀]\n        refine ih.add ?_\n        rw [SModEq.zero, Ideal.neg_mem_iff]\n        refine I.mul_mem_right _ ?_\n        rw [← SModEq.zero] at h₁ ⊢\n        exact (ih.eval f).trans h₁\n      have hf'c : ∀ n, IsUnit (f'.eval (c n)) := by\n        intro n\n        haveI := isLocalHom_of_le_jacobson_bot I (IsAdicComplete.le_jacobson_bot I)\n        apply IsUnit.of_map (Ideal.Quotient.mk I)\n        convert h₂ using 1\n        exact SModEq.def.mp ((hc_mod n).eval _)\n      have hfcI : ∀ n, f.eval (c n) ∈ I ^ (n + 1) := by\n        intro n\n        induction' n with n ih\n        · simpa only [Nat.rec_zero, zero_add, pow_one] using h₁\n        rw [← taylor_eval_sub (c n), hc, sub_eq_add_neg, sub_eq_add_neg,\n          add_neg_cancel_comm]\n        rw [eval_eq_sum, sum_over_range' _ _ _ (lt_add_of_pos_right _ zero_lt_two), ←\n          Finset.sum_range_add_sum_Ico _ (Nat.le_add_left _ _)]\n        swap\n        · intro i\n          rw [zero_mul]\n        refine Ideal.add_mem _ ?_ ?_\n        · erw [Finset.sum_range_succ]\n          rw [Finset.range_one, Finset.sum_singleton,\n            taylor_coeff_zero, taylor_coeff_one, pow_zero, pow_one, mul_one, mul_neg,\n            mul_left_comm, Ring.mul_inverse_cancel _ (hf'c n), mul_one, add_neg_cancel]\n          exact Ideal.zero_mem _\n        · refine Submodule.sum_mem _ ?_\n          simp only [Finset.mem_Ico]\n          rintro i ⟨h2i, _⟩\n          have aux : n + 2 ≤ i * (n + 1) := by trans 2 * (n + 1) <;> nlinarith only [h2i]\n          refine Ideal.mul_mem_left _ _ (Ideal.pow_le_pow_right aux ?_)\n          rw [pow_mul']\n          exact Ideal.pow_mem_pow ((Ideal.neg_mem_iff _).2 <| Ideal.mul_mem_right _ _ ih) _\n      -- we are now in the position to show that `c : ℕ → R` is a Cauchy sequence\n      have aux : ∀ m n, m ≤ n → c m ≡ c n [SMOD (I ^ m • ⊤ : Ideal R)] := by\n        intro m n hmn\n        rw [← Ideal.one_eq_top, Ideal.smul_eq_mul, mul_one]\n        obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_le hmn\n        clear hmn\n        induction' k with k ih\n        · rw [add_zero]\n        rw [← add_assoc, hc, ← add_zero (c m), sub_eq_add_neg]\n        refine ih.add ?_\n        symm\n        rw [SModEq.zero, Ideal.neg_mem_iff]\n        refine Ideal.mul_mem_right _ _ (Ideal.pow_le_pow_right ?_ (hfcI _))\n        rw [add_assoc]\n        exact le_self_add\n      -- hence the sequence converges to some limit point `a`, which is the `a` we are looking for\n      obtain ⟨a, ha⟩ := IsPrecomplete.prec' c (aux _ _)\n      refine ⟨a, ?_, ?_⟩\n      · show f.IsRoot a\n        suffices ∀ n, f.eval a ≡ 0 [SMOD (I ^ n • ⊤ : Ideal R)] by exact IsHausdorff.haus' _ this\n        intro n\n        specialize ha n\n        rw [← Ideal.one_eq_top, Ideal.smul_eq_mul, mul_one] at ha ⊢\n        refine (ha.symm.eval f).trans ?_\n        rw [SModEq.zero]\n        exact Ideal.pow_le_pow_right le_self_add (hfcI _)\n      · show a - a₀ ∈ I\n        specialize ha (0 + 1)\n        rw [hc, pow_one, ← Ideal.one_eq_top, Ideal.smul_eq_mul, mul_one, sub_eq_add_neg] at ha\n        rw [← SModEq.sub_mem, ← add_zero a₀]\n        refine ha.symm.trans (SModEq.rfl.add ?_)\n        rw [SModEq.zero, Ideal.neg_mem_iff]\n        exact Ideal.mul_mem_right _ _ h₁\n"}
