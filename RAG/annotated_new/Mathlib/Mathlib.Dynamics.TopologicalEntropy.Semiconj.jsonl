{"name":"Dynamics.IsDynCoverOf.image","module":"Mathlib.Dynamics.TopologicalEntropy.Semiconj","initialProofState":"X : Type u_1\nY : Type u_2\nS : X → X\nT : Y → Y\nφ : X → Y\nh : Function.Semiconj φ S T\nF : Set X\nV : Set (Prod Y Y)\nn : Nat\ns : Set X\nh' : Dynamics.IsDynCoverOf S F (Set.preimage (Prod.map φ φ) V) n s\n⊢ Dynamics.IsDynCoverOf T (Set.image φ F) V n (Set.image φ s)","decl":"lemma IsDynCoverOf.image (h : Semiconj φ S T) {F : Set X} {V : Set (Y × Y)} {n : ℕ} {s : Set X}\n    (h' : IsDynCoverOf S F ((map φ φ) ⁻¹' V) n s) :\n    IsDynCoverOf T (φ '' F) V n (φ '' s) := by\n  simp only [IsDynCoverOf, image_subset_iff, preimage_iUnion₂, biUnion_image]\n  refine h'.trans (iUnion₂_mono fun i _ ↦ subset_of_eq ?_)\n  rw [← h.preimage_dynEntourage V n, ball_preimage]\n\n"}
{"name":"Dynamics.IsDynCoverOf.preimage","module":"Mathlib.Dynamics.TopologicalEntropy.Semiconj","initialProofState":"X : Type u_1\nY : Type u_2\nS : X → X\nT : Y → Y\nφ : X → Y\nh : Function.Semiconj φ S T\nF : Set X\nV : Set (Prod Y Y)\nV_symm : SymmetricRel V\nn : Nat\nt : Finset Y\nh' : Dynamics.IsDynCoverOf T (Set.image φ F) V n ↑t\n⊢ Exists fun s => And (Dynamics.IsDynCoverOf S F (Set.preimage (Prod.map φ φ) (compRel V V)) n ↑s) (LE.le s.card t.card)","decl":"lemma IsDynCoverOf.preimage (h : Semiconj φ S T) {F : Set X} {V : Set (Y × Y)}\n    (V_symm : SymmetricRel V) {n : ℕ} {t : Finset Y} (h' : IsDynCoverOf T (φ '' F) V n t) :\n    ∃ s : Finset X, IsDynCoverOf S F ((map φ φ) ⁻¹' (V ○ V)) n s ∧ s.card ≤ t.card := by\n  classical\n  rcases isEmpty_or_nonempty X with _ | _\n  · exact ⟨∅, eq_empty_of_isEmpty F ▸ ⟨isDynCoverOf_empty, Finset.card_empty ▸ zero_le t.card⟩⟩\n  -- If `t` is a dynamical cover of `φ '' F`, then we want to choose one preimage by `φ` for each\n  -- element of `t`. This is complicated by the fact that `t` may not be a subset of `φ '' F`,\n  -- and may not even be in the range of `φ`. Hence, we first modify `t` to make it a subset\n  -- of `φ '' F`. This requires taking larger entourages.\n  rcases h'.nonempty_inter with ⟨s, s_cover, s_card, s_inter⟩\n  choose! g gs_cover using fun (x : Y) (h : x ∈ s) ↦ nonempty_def.1 (s_inter x h)\n  choose! f f_section using fun (y : Y) (a : y ∈ φ '' F) ↦ a\n  refine ⟨s.image (f ∘ g), And.intro ?_ (Finset.card_image_le.trans s_card)⟩\n  simp only [IsDynCoverOf, Finset.mem_coe, image_subset_iff, preimage_iUnion₂] at s_cover ⊢\n  apply s_cover.trans\n  rw [← h.preimage_dynEntourage (V ○ V) n, Finset.set_biUnion_finset_image]\n  refine iUnion₂_mono fun i i_s ↦ ?_\n  rw [comp_apply, ball_preimage, (f_section (g i) (gs_cover i i_s).2).2]\n  refine preimage_mono fun x x_i ↦ mem_ball_dynEntourage_comp T n V_symm x (g i) ⟨i, ?_⟩\n  replace gs_cover := (gs_cover i i_s).1\n  rw [mem_ball_symmetry (V_symm.dynEntourage T n)] at x_i gs_cover\n  exact ⟨x_i, gs_cover⟩\n\n"}
{"name":"Dynamics.le_coverMincard_image","module":"Mathlib.Dynamics.TopologicalEntropy.Semiconj","initialProofState":"X : Type u_1\nY : Type u_2\nS : X → X\nT : Y → Y\nφ : X → Y\nh : Function.Semiconj φ S T\nF : Set X\nV : Set (Prod Y Y)\nV_symm : SymmetricRel V\nn : Nat\n⊢ LE.le (Dynamics.coverMincard S F (Set.preimage (Prod.map φ φ) (compRel V V)) n) (Dynamics.coverMincard T (Set.image φ F) V n)","decl":"lemma le_coverMincard_image (h : Semiconj φ S T) (F : Set X) {V : Set (Y × Y)}\n    (V_symm : SymmetricRel V) (n : ℕ) :\n    coverMincard S F ((map φ φ) ⁻¹' (V ○ V)) n ≤ coverMincard T (φ '' F) V n := by\n  rcases eq_top_or_lt_top (coverMincard T (φ '' F) V n) with h' | h'\n  · exact h' ▸ le_top\n  rcases (coverMincard_finite_iff T (φ '' F) V n).1 h' with ⟨t, t_cover, t_card⟩\n  rcases t_cover.preimage h V_symm with ⟨s, s_cover, s_card⟩\n  rw [← t_card]\n  exact s_cover.coverMincard_le_card.trans (WithTop.coe_le_coe.2 s_card)\n\n"}
{"name":"Dynamics.coverMincard_image_le","module":"Mathlib.Dynamics.TopologicalEntropy.Semiconj","initialProofState":"X : Type u_1\nY : Type u_2\nS : X → X\nT : Y → Y\nφ : X → Y\nh : Function.Semiconj φ S T\nF : Set X\nV : Set (Prod Y Y)\nn : Nat\n⊢ LE.le (Dynamics.coverMincard T (Set.image φ F) V n) (Dynamics.coverMincard S F (Set.preimage (Prod.map φ φ) V) n)","decl":"lemma coverMincard_image_le (h : Semiconj φ S T) (F : Set X) (V : Set (Y × Y)) (n : ℕ) :\n    coverMincard T (φ '' F) V n ≤ coverMincard S F ((map φ φ) ⁻¹' V) n := by\n  classical\n  rcases eq_top_or_lt_top (coverMincard S F ((map φ φ) ⁻¹' V) n) with h' | h'\n  · exact h' ▸ le_top\n  rcases (coverMincard_finite_iff S F ((map φ φ) ⁻¹' V) n).1 h' with ⟨s, s_cover, s_card⟩\n  rw [← s_card]\n  have := s_cover.image h\n  rw [← s.coe_image] at this\n  exact this.coverMincard_le_card.trans (WithTop.coe_le_coe.2 s.card_image_le)\n\n"}
{"name":"Dynamics.le_coverEntropyEntourage_image","module":"Mathlib.Dynamics.TopologicalEntropy.Semiconj","initialProofState":"X : Type u_1\nY : Type u_2\nS : X → X\nT : Y → Y\nφ : X → Y\nh : Function.Semiconj φ S T\nF : Set X\nV : Set (Prod Y Y)\nV_symm : SymmetricRel V\n⊢ LE.le (Dynamics.coverEntropyEntourage S F (Set.preimage (Prod.map φ φ) (compRel V V))) (Dynamics.coverEntropyEntourage T (Set.image φ F) V)","decl":"lemma le_coverEntropyEntourage_image (h : Semiconj φ S T) (F : Set X) {V : Set (Y × Y)}\n    (V_symm : SymmetricRel V) :\n    coverEntropyEntourage S F ((map φ φ) ⁻¹' (V ○ V)) ≤ coverEntropyEntourage T (φ '' F) V :=\n  limsup_le_limsup (Eventually.of_forall fun n ↦ (monotone_div_right_of_nonneg (Nat.cast_nonneg' n)\n    (log_monotone (ENat.toENNReal_mono (le_coverMincard_image h F V_symm n)))))\n\n"}
{"name":"Dynamics.le_coverEntropyInfEntourage_image","module":"Mathlib.Dynamics.TopologicalEntropy.Semiconj","initialProofState":"X : Type u_1\nY : Type u_2\nS : X → X\nT : Y → Y\nφ : X → Y\nh : Function.Semiconj φ S T\nF : Set X\nV : Set (Prod Y Y)\nV_symm : SymmetricRel V\n⊢ LE.le (Dynamics.coverEntropyInfEntourage S F (Set.preimage (Prod.map φ φ) (compRel V V))) (Dynamics.coverEntropyInfEntourage T (Set.image φ F) V)","decl":"lemma le_coverEntropyInfEntourage_image (h : Semiconj φ S T) (F : Set X) {V : Set (Y × Y)}\n    (V_symm : SymmetricRel V) :\n    coverEntropyInfEntourage S F ((map φ φ) ⁻¹' (V ○ V)) ≤ coverEntropyInfEntourage T (φ '' F) V :=\n  liminf_le_liminf (Eventually.of_forall fun n ↦ (monotone_div_right_of_nonneg (Nat.cast_nonneg' n)\n    (log_monotone (ENat.toENNReal_mono (le_coverMincard_image h F V_symm n)))))\n\n"}
{"name":"Dynamics.coverEntropyEntourage_image_le","module":"Mathlib.Dynamics.TopologicalEntropy.Semiconj","initialProofState":"X : Type u_1\nY : Type u_2\nS : X → X\nT : Y → Y\nφ : X → Y\nh : Function.Semiconj φ S T\nF : Set X\nV : Set (Prod Y Y)\n⊢ LE.le (Dynamics.coverEntropyEntourage T (Set.image φ F) V) (Dynamics.coverEntropyEntourage S F (Set.preimage (Prod.map φ φ) V))","decl":"lemma coverEntropyEntourage_image_le (h : Semiconj φ S T) (F : Set X) (V : Set (Y × Y)) :\n    coverEntropyEntourage T (φ '' F) V ≤ coverEntropyEntourage S F ((map φ φ) ⁻¹' V) :=\n  limsup_le_limsup (Eventually.of_forall fun n ↦ (monotone_div_right_of_nonneg (Nat.cast_nonneg' n)\n    (log_monotone (ENat.toENNReal_mono (coverMincard_image_le h F V n)))))\n\n"}
{"name":"Dynamics.coverEntropyInfEntourage_image_le","module":"Mathlib.Dynamics.TopologicalEntropy.Semiconj","initialProofState":"X : Type u_1\nY : Type u_2\nS : X → X\nT : Y → Y\nφ : X → Y\nh : Function.Semiconj φ S T\nF : Set X\nV : Set (Prod Y Y)\n⊢ LE.le (Dynamics.coverEntropyInfEntourage T (Set.image φ F) V) (Dynamics.coverEntropyInfEntourage S F (Set.preimage (Prod.map φ φ) V))","decl":"lemma coverEntropyInfEntourage_image_le (h : Semiconj φ S T) (F : Set X) (V : Set (Y × Y)) :\n    coverEntropyInfEntourage T (φ '' F) V ≤ coverEntropyInfEntourage S F ((map φ φ) ⁻¹' V) :=\n  liminf_le_liminf (Eventually.of_forall fun n ↦ (monotone_div_right_of_nonneg (Nat.cast_nonneg' n)\n    (log_monotone (ENat.toENNReal_mono (coverMincard_image_le h F V n)))))\n\n"}
{"name":"Dynamics.coverEntropy_image_of_comap","module":"Mathlib.Dynamics.TopologicalEntropy.Semiconj","initialProofState":"X : Type u_1\nY : Type u_2\nu : UniformSpace Y\nS : X → X\nT : Y → Y\nφ : X → Y\nh : Function.Semiconj φ S T\nF : Set X\n⊢ Eq (Dynamics.coverEntropy T (Set.image φ F)) (Dynamics.coverEntropy S F)","decl":"/-- The entropy of `φ '' F` equals the entropy of `F` if `X` is endowed with the pullback by `φ`\n  of the uniform structure of `Y`.-/\ntheorem coverEntropy_image_of_comap (u : UniformSpace Y) {S : X → X} {T : Y → Y} {φ : X → Y}\n    (h : Semiconj φ S T) (F : Set X) :\n    coverEntropy T (φ '' F) = @coverEntropy X (comap φ u) S F := by\n  apply le_antisymm\n  · refine iSup₂_le fun V V_uni ↦ (coverEntropyEntourage_image_le h F V).trans ?_\n    apply @coverEntropyEntourage_le_coverEntropy X (comap φ u) S F\n    rw [uniformity_comap φ, mem_comap]\n    exact ⟨V, V_uni, Subset.rfl⟩\n  · refine iSup₂_le fun U U_uni ↦ ?_\n    simp only [uniformity_comap φ, mem_comap] at U_uni\n    rcases U_uni with ⟨V, V_uni, V_sub⟩\n    rcases comp_symm_mem_uniformity_sets V_uni with ⟨W, W_uni, W_symm, W_V⟩\n    apply (coverEntropyEntourage_antitone S F ((preimage_mono W_V).trans V_sub)).trans\n    apply (le_coverEntropyEntourage_image h F W_symm).trans\n    exact coverEntropyEntourage_le_coverEntropy T (φ '' F) W_uni\n\n"}
{"name":"Dynamics.coverEntropyInf_image_of_comap","module":"Mathlib.Dynamics.TopologicalEntropy.Semiconj","initialProofState":"X : Type u_1\nY : Type u_2\nu : UniformSpace Y\nS : X → X\nT : Y → Y\nφ : X → Y\nh : Function.Semiconj φ S T\nF : Set X\n⊢ Eq (Dynamics.coverEntropyInf T (Set.image φ F)) (Dynamics.coverEntropyInf S F)","decl":"/-- The entropy of `φ '' F` equals the entropy of `F` if `X` is endowed with the pullback by `φ`\n  of the uniform structure of `Y`. This version uses a `liminf`.-/\ntheorem coverEntropyInf_image_of_comap (u : UniformSpace Y) {S : X → X} {T : Y → Y} {φ : X → Y}\n    (h : Semiconj φ S T) (F : Set X) :\n    coverEntropyInf T (φ '' F) = @coverEntropyInf X (comap φ u) S F := by\n  apply le_antisymm\n  · refine iSup₂_le fun V V_uni ↦ (coverEntropyInfEntourage_image_le h F V).trans ?_\n    apply @coverEntropyInfEntourage_le_coverEntropyInf X (comap φ u) S F\n    rw [uniformity_comap φ, mem_comap]\n    exact ⟨V, V_uni, Subset.rfl⟩\n  · refine iSup₂_le fun U U_uni ↦ ?_\n    simp only [uniformity_comap φ, mem_comap] at U_uni\n    rcases U_uni with ⟨V, V_uni, V_sub⟩\n    rcases comp_symm_mem_uniformity_sets V_uni with ⟨W, W_uni, W_symm, W_V⟩\n    apply (coverEntropyInfEntourage_antitone S F ((preimage_mono W_V).trans V_sub)).trans\n    apply (le_coverEntropyInfEntourage_image h F W_symm).trans\n    exact coverEntropyInfEntourage_le_coverEntropyInf T (φ '' F) W_uni\n\n"}
{"name":"Dynamics.coverEntropy_restrict_subset","module":"Mathlib.Dynamics.TopologicalEntropy.Semiconj","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nT : X → X\nF G : Set X\nhF : HasSubset.Subset F G\nhG : Set.MapsTo T G G\n⊢ Eq (Dynamics.coverEntropy (Set.MapsTo.restrict T G G hG) (Set.preimage Subtype.val F)) (Dynamics.coverEntropy T F)","decl":"lemma coverEntropy_restrict_subset [UniformSpace X] {T : X → X} {F G : Set X} (hF : F ⊆ G)\n    (hG : MapsTo T G G) :\n    coverEntropy (hG.restrict T G G) (val ⁻¹' F) = coverEntropy T F := by\n  rw [← coverEntropy_image_of_comap _ hG.val_restrict_apply (val ⁻¹' F), image_preimage_coe G F,\n    inter_eq_right.2 hF]\n\n"}
{"name":"Dynamics.coverEntropyInf_restrict_subset","module":"Mathlib.Dynamics.TopologicalEntropy.Semiconj","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nT : X → X\nF G : Set X\nhF : HasSubset.Subset F G\nhG : Set.MapsTo T G G\n⊢ Eq (Dynamics.coverEntropyInf (Set.MapsTo.restrict T G G hG) (Set.preimage Subtype.val F)) (Dynamics.coverEntropyInf T F)","decl":"lemma coverEntropyInf_restrict_subset [UniformSpace X] {T : X → X} {F G : Set X} (hF : F ⊆ G)\n    (hG : MapsTo T G G) :\n    coverEntropyInf (hG.restrict T G G) (val ⁻¹' F) = coverEntropyInf T F := by\n  rw [← coverEntropyInf_image_of_comap _ hG.val_restrict_apply (val ⁻¹' F), image_preimage_coe G F,\n    inter_eq_right.2 hF]\n\n"}
{"name":"Dynamics.coverEntropy_restrict","module":"Mathlib.Dynamics.TopologicalEntropy.Semiconj","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nT : X → X\nF : Set X\nh : Set.MapsTo T F F\n⊢ Eq (Dynamics.coverEntropy (Set.MapsTo.restrict T F F h) Set.univ) (Dynamics.coverEntropy T F)","decl":"/-- The entropy of the restriction of `T` to an invariant set `F` is `coverEntropy S F`. This\ntheorem justifies our definition of `coverEntropy T F`.-/\ntheorem coverEntropy_restrict [UniformSpace X] {T : X → X} {F : Set X} (h : MapsTo T F F) :\n    coverEntropy (h.restrict T F F) univ = coverEntropy T F := by\n  rw [← coverEntropy_restrict_subset Subset.rfl h, coe_preimage_self F]\n\n"}
{"name":"Dynamics.coverEntropy_image_le_of_uniformContinuous","module":"Mathlib.Dynamics.TopologicalEntropy.Semiconj","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : UniformSpace X\ninst✝ : UniformSpace Y\nS : X → X\nT : Y → Y\nφ : X → Y\nh : Function.Semiconj φ S T\nh' : UniformContinuous φ\nF : Set X\n⊢ LE.le (Dynamics.coverEntropy T (Set.image φ F)) (Dynamics.coverEntropy S F)","decl":"/-- The entropy of `φ '' F` is lower than entropy of `F` if  `φ` is uniformly continuous.-/\ntheorem coverEntropy_image_le_of_uniformContinuous [UniformSpace X] [UniformSpace Y] {S : X → X}\n    {T : Y → Y} {φ : X → Y} (h : Semiconj φ S T) (h' : UniformContinuous φ) (F : Set X) :\n    coverEntropy T (φ '' F) ≤ coverEntropy S F := by\n  rw [coverEntropy_image_of_comap _ h F]\n  exact coverEntropy_antitone S F (uniformContinuous_iff.1 h')\n\n"}
{"name":"Dynamics.coverEntropyInf_image_le_of_uniformContinuous","module":"Mathlib.Dynamics.TopologicalEntropy.Semiconj","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : UniformSpace X\ninst✝ : UniformSpace Y\nS : X → X\nT : Y → Y\nφ : X → Y\nh : Function.Semiconj φ S T\nh' : UniformContinuous φ\nF : Set X\n⊢ LE.le (Dynamics.coverEntropyInf T (Set.image φ F)) (Dynamics.coverEntropyInf S F)","decl":"/-- The entropy of `φ '' F` is lower than entropy of `F` if  `φ` is uniformly continuous. This\n  version uses a `liminf`.-/\ntheorem coverEntropyInf_image_le_of_uniformContinuous [UniformSpace X] [UniformSpace Y] {S : X → X}\n    {T : Y → Y} {φ : X → Y} (h : Semiconj φ S T) (h' : UniformContinuous φ) (F : Set X) :\n    coverEntropyInf T (φ '' F) ≤ coverEntropyInf S F := by\n  rw [coverEntropyInf_image_of_comap _ h F]\n  exact coverEntropyInf_antitone S F (uniformContinuous_iff.1 h')\n\n"}
{"name":"Dynamics.coverEntropy_image_le_of_uniformContinuousOn_invariant","module":"Mathlib.Dynamics.TopologicalEntropy.Semiconj","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : UniformSpace X\ninst✝ : UniformSpace Y\nS : X → X\nT : Y → Y\nφ : X → Y\nh : Function.Semiconj φ S T\nF G : Set X\nh' : UniformContinuousOn φ G\nhF : HasSubset.Subset F G\nhG : Set.MapsTo S G G\n⊢ LE.le (Dynamics.coverEntropy T (Set.image φ F)) (Dynamics.coverEntropy S F)","decl":"lemma coverEntropy_image_le_of_uniformContinuousOn_invariant [UniformSpace X] [UniformSpace Y]\n    {S : X → X} {T : Y → Y} {φ : X → Y} (h : Semiconj φ S T) {F G : Set X}\n    (h' : UniformContinuousOn φ G) (hF : F ⊆ G) (hG : MapsTo S G G) :\n    coverEntropy T (φ '' F) ≤ coverEntropy S F := by\n  rw [← coverEntropy_restrict_subset hF hG]\n  have hφ : Semiconj (G.restrict φ) (hG.restrict S G G) T := by\n    intro x\n    rw [G.restrict_apply, G.restrict_apply, hG.val_restrict_apply, h.eq x]\n  apply (coverEntropy_image_le_of_uniformContinuous hφ\n    (uniformContinuousOn_iff_restrict.1 h') (val ⁻¹' F)).trans_eq'\n  rw [← image_image_val_eq_restrict_image, image_preimage_coe G F, inter_eq_right.2 hF]\n\n"}
{"name":"Dynamics.coverEntropyInf_image_le_of_uniformContinuousOn_invariant","module":"Mathlib.Dynamics.TopologicalEntropy.Semiconj","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : UniformSpace X\ninst✝ : UniformSpace Y\nS : X → X\nT : Y → Y\nφ : X → Y\nh : Function.Semiconj φ S T\nF G : Set X\nh' : UniformContinuousOn φ G\nhF : HasSubset.Subset F G\nhG : Set.MapsTo S G G\n⊢ LE.le (Dynamics.coverEntropyInf T (Set.image φ F)) (Dynamics.coverEntropyInf S F)","decl":"lemma coverEntropyInf_image_le_of_uniformContinuousOn_invariant [UniformSpace X] [UniformSpace Y]\n    {S : X → X} {T : Y → Y} {φ : X → Y} (h : Semiconj φ S T) {F G : Set X}\n    (h' : UniformContinuousOn φ G) (hF : F ⊆ G) (hG : MapsTo S G G) :\n    coverEntropyInf T (φ '' F) ≤ coverEntropyInf S F := by\n  rw [← coverEntropyInf_restrict_subset hF hG]\n  have hφ : Semiconj (G.restrict φ) (hG.restrict S G G) T := by\n    intro a\n    rw [G.restrict_apply, G.restrict_apply, hG.val_restrict_apply, h.eq a]\n  apply (coverEntropyInf_image_le_of_uniformContinuous hφ\n    (uniformContinuousOn_iff_restrict.1 h') (val ⁻¹' F)).trans_eq'\n  rw [← image_image_val_eq_restrict_image, image_preimage_coe G F, inter_eq_right.2 hF]\n\n"}
