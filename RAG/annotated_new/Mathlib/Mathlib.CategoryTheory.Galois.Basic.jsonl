{"name":"CategoryTheory.PreGaloisCategory.hasPullbacks","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nself : CategoryTheory.PreGaloisCategory C\n⊢ CategoryTheory.Limits.HasPullbacks C","decl":"/-- Definition of a (Pre)Galois category. Lenstra, Def 3.1, (G1)-(G3) -/\nclass PreGaloisCategory (C : Type u₁) [Category.{u₂, u₁} C] : Prop where\n  /-- `C` has a terminal object (G1). -/\n  hasTerminal : HasTerminal C := by infer_instance\n  /-- `C` has pullbacks (G1). -/\n  hasPullbacks : HasPullbacks C := by infer_instance\n  /-- `C` has finite coproducts (G2). -/\n  hasFiniteCoproducts : HasFiniteCoproducts C := by infer_instance\n  /-- `C` has quotients by finite groups (G2). -/\n  hasQuotientsByFiniteGroups (G : Type u₂) [Group G] [Finite G] :\n    HasColimitsOfShape (SingleObj G) C := by infer_instance\n  /-- Every monomorphism in `C` induces an isomorphism on a direct summand (G3). -/\n  monoInducesIsoOnDirectSummand {X Y : C} (i : X ⟶ Y) [Mono i] : ∃ (Z : C) (u : Z ⟶ Y),\n    Nonempty (IsColimit (BinaryCofan.mk i u))\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.monoInducesIsoOnDirectSummand","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\nself : CategoryTheory.PreGaloisCategory C\nX Y : C\ni : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono i\n⊢ Exists fun Z => Exists fun u => Nonempty (CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.BinaryCofan.mk i u))","decl":"/-- Definition of a (Pre)Galois category. Lenstra, Def 3.1, (G1)-(G3) -/\nclass PreGaloisCategory (C : Type u₁) [Category.{u₂, u₁} C] : Prop where\n  /-- `C` has a terminal object (G1). -/\n  hasTerminal : HasTerminal C := by infer_instance\n  /-- `C` has pullbacks (G1). -/\n  hasPullbacks : HasPullbacks C := by infer_instance\n  /-- `C` has finite coproducts (G2). -/\n  hasFiniteCoproducts : HasFiniteCoproducts C := by infer_instance\n  /-- `C` has quotients by finite groups (G2). -/\n  hasQuotientsByFiniteGroups (G : Type u₂) [Group G] [Finite G] :\n    HasColimitsOfShape (SingleObj G) C := by infer_instance\n  /-- Every monomorphism in `C` induces an isomorphism on a direct summand (G3). -/\n  monoInducesIsoOnDirectSummand {X Y : C} (i : X ⟶ Y) [Mono i] : ∃ (Z : C) (u : Z ⟶ Y),\n    Nonempty (IsColimit (BinaryCofan.mk i u))\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.hasTerminal","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nself : CategoryTheory.PreGaloisCategory C\n⊢ CategoryTheory.Limits.HasTerminal C","decl":"/-- Definition of a (Pre)Galois category. Lenstra, Def 3.1, (G1)-(G3) -/\nclass PreGaloisCategory (C : Type u₁) [Category.{u₂, u₁} C] : Prop where\n  /-- `C` has a terminal object (G1). -/\n  hasTerminal : HasTerminal C := by infer_instance\n  /-- `C` has pullbacks (G1). -/\n  hasPullbacks : HasPullbacks C := by infer_instance\n  /-- `C` has finite coproducts (G2). -/\n  hasFiniteCoproducts : HasFiniteCoproducts C := by infer_instance\n  /-- `C` has quotients by finite groups (G2). -/\n  hasQuotientsByFiniteGroups (G : Type u₂) [Group G] [Finite G] :\n    HasColimitsOfShape (SingleObj G) C := by infer_instance\n  /-- Every monomorphism in `C` induces an isomorphism on a direct summand (G3). -/\n  monoInducesIsoOnDirectSummand {X Y : C} (i : X ⟶ Y) [Mono i] : ∃ (Z : C) (u : Z ⟶ Y),\n    Nonempty (IsColimit (BinaryCofan.mk i u))\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.hasFiniteCoproducts","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nself : CategoryTheory.PreGaloisCategory C\n⊢ CategoryTheory.Limits.HasFiniteCoproducts C","decl":"/-- Definition of a (Pre)Galois category. Lenstra, Def 3.1, (G1)-(G3) -/\nclass PreGaloisCategory (C : Type u₁) [Category.{u₂, u₁} C] : Prop where\n  /-- `C` has a terminal object (G1). -/\n  hasTerminal : HasTerminal C := by infer_instance\n  /-- `C` has pullbacks (G1). -/\n  hasPullbacks : HasPullbacks C := by infer_instance\n  /-- `C` has finite coproducts (G2). -/\n  hasFiniteCoproducts : HasFiniteCoproducts C := by infer_instance\n  /-- `C` has quotients by finite groups (G2). -/\n  hasQuotientsByFiniteGroups (G : Type u₂) [Group G] [Finite G] :\n    HasColimitsOfShape (SingleObj G) C := by infer_instance\n  /-- Every monomorphism in `C` induces an isomorphism on a direct summand (G3). -/\n  monoInducesIsoOnDirectSummand {X Y : C} (i : X ⟶ Y) [Mono i] : ∃ (Z : C) (u : Z ⟶ Y),\n    Nonempty (IsColimit (BinaryCofan.mk i u))\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.hasQuotientsByFiniteGroups","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nself : CategoryTheory.PreGaloisCategory C\nG : Type u₂\ninst✝¹ : Group G\ninst✝ : Finite G\n⊢ CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.SingleObj G) C","decl":"/-- Definition of a (Pre)Galois category. Lenstra, Def 3.1, (G1)-(G3) -/\nclass PreGaloisCategory (C : Type u₁) [Category.{u₂, u₁} C] : Prop where\n  /-- `C` has a terminal object (G1). -/\n  hasTerminal : HasTerminal C := by infer_instance\n  /-- `C` has pullbacks (G1). -/\n  hasPullbacks : HasPullbacks C := by infer_instance\n  /-- `C` has finite coproducts (G2). -/\n  hasFiniteCoproducts : HasFiniteCoproducts C := by infer_instance\n  /-- `C` has quotients by finite groups (G2). -/\n  hasQuotientsByFiniteGroups (G : Type u₂) [Group G] [Finite G] :\n    HasColimitsOfShape (SingleObj G) C := by infer_instance\n  /-- Every monomorphism in `C` induces an isomorphism on a direct summand (G3). -/\n  monoInducesIsoOnDirectSummand {X Y : C} (i : X ⟶ Y) [Mono i] : ∃ (Z : C) (u : Z ⟶ Y),\n    Nonempty (IsColimit (BinaryCofan.mk i u))\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.FiberFunctor.preservesQuotientsByFiniteGroups","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\ninst✝² : CategoryTheory.PreGaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nself : CategoryTheory.PreGaloisCategory.FiberFunctor F\nG : Type u₂\ninst✝¹ : Group G\ninst✝ : Finite G\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.SingleObj G) F","decl":"/-- Definition of a fiber functor from a Galois category. Lenstra, Def 3.1, (G4)-(G6) -/\nclass FiberFunctor {C : Type u₁} [Category.{u₂, u₁} C] [PreGaloisCategory C]\n    (F : C ⥤ FintypeCat.{w}) where\n  /-- `F` preserves terminal objects (G4). -/\n  preservesTerminalObjects : PreservesLimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) F := by\n    infer_instance\n  /-- `F` preserves pullbacks (G4). -/\n  preservesPullbacks : PreservesLimitsOfShape WalkingCospan F := by infer_instance\n  /-- `F` preserves finite coproducts (G5). -/\n  preservesFiniteCoproducts : PreservesFiniteCoproducts F := by infer_instance\n  /-- `F` preserves epimorphisms (G5). -/\n  preservesEpis : Functor.PreservesEpimorphisms F := by infer_instance\n  /-- `F` preserves quotients by finite groups (G5). -/\n  preservesQuotientsByFiniteGroups (G : Type u₂) [Group G] [Finite G] :\n    PreservesColimitsOfShape (SingleObj G) F := by infer_instance\n  /-- `F` reflects isomorphisms (G6). -/\n  reflectsIsos : F.ReflectsIsomorphisms := by infer_instance\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.FiberFunctor.preservesTerminalObjects","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.PreGaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nself : CategoryTheory.PreGaloisCategory.FiberFunctor F\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) F","decl":"/-- Definition of a fiber functor from a Galois category. Lenstra, Def 3.1, (G4)-(G6) -/\nclass FiberFunctor {C : Type u₁} [Category.{u₂, u₁} C] [PreGaloisCategory C]\n    (F : C ⥤ FintypeCat.{w}) where\n  /-- `F` preserves terminal objects (G4). -/\n  preservesTerminalObjects : PreservesLimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) F := by\n    infer_instance\n  /-- `F` preserves pullbacks (G4). -/\n  preservesPullbacks : PreservesLimitsOfShape WalkingCospan F := by infer_instance\n  /-- `F` preserves finite coproducts (G5). -/\n  preservesFiniteCoproducts : PreservesFiniteCoproducts F := by infer_instance\n  /-- `F` preserves epimorphisms (G5). -/\n  preservesEpis : Functor.PreservesEpimorphisms F := by infer_instance\n  /-- `F` preserves quotients by finite groups (G5). -/\n  preservesQuotientsByFiniteGroups (G : Type u₂) [Group G] [Finite G] :\n    PreservesColimitsOfShape (SingleObj G) F := by infer_instance\n  /-- `F` reflects isomorphisms (G6). -/\n  reflectsIsos : F.ReflectsIsomorphisms := by infer_instance\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.FiberFunctor.preservesPullbacks","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.PreGaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nself : CategoryTheory.PreGaloisCategory.FiberFunctor F\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingCospan F","decl":"/-- Definition of a fiber functor from a Galois category. Lenstra, Def 3.1, (G4)-(G6) -/\nclass FiberFunctor {C : Type u₁} [Category.{u₂, u₁} C] [PreGaloisCategory C]\n    (F : C ⥤ FintypeCat.{w}) where\n  /-- `F` preserves terminal objects (G4). -/\n  preservesTerminalObjects : PreservesLimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) F := by\n    infer_instance\n  /-- `F` preserves pullbacks (G4). -/\n  preservesPullbacks : PreservesLimitsOfShape WalkingCospan F := by infer_instance\n  /-- `F` preserves finite coproducts (G5). -/\n  preservesFiniteCoproducts : PreservesFiniteCoproducts F := by infer_instance\n  /-- `F` preserves epimorphisms (G5). -/\n  preservesEpis : Functor.PreservesEpimorphisms F := by infer_instance\n  /-- `F` preserves quotients by finite groups (G5). -/\n  preservesQuotientsByFiniteGroups (G : Type u₂) [Group G] [Finite G] :\n    PreservesColimitsOfShape (SingleObj G) F := by infer_instance\n  /-- `F` reflects isomorphisms (G6). -/\n  reflectsIsos : F.ReflectsIsomorphisms := by infer_instance\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.FiberFunctor.reflectsIsos","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.PreGaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nself : CategoryTheory.PreGaloisCategory.FiberFunctor F\n⊢ F.ReflectsIsomorphisms","decl":"/-- Definition of a fiber functor from a Galois category. Lenstra, Def 3.1, (G4)-(G6) -/\nclass FiberFunctor {C : Type u₁} [Category.{u₂, u₁} C] [PreGaloisCategory C]\n    (F : C ⥤ FintypeCat.{w}) where\n  /-- `F` preserves terminal objects (G4). -/\n  preservesTerminalObjects : PreservesLimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) F := by\n    infer_instance\n  /-- `F` preserves pullbacks (G4). -/\n  preservesPullbacks : PreservesLimitsOfShape WalkingCospan F := by infer_instance\n  /-- `F` preserves finite coproducts (G5). -/\n  preservesFiniteCoproducts : PreservesFiniteCoproducts F := by infer_instance\n  /-- `F` preserves epimorphisms (G5). -/\n  preservesEpis : Functor.PreservesEpimorphisms F := by infer_instance\n  /-- `F` preserves quotients by finite groups (G5). -/\n  preservesQuotientsByFiniteGroups (G : Type u₂) [Group G] [Finite G] :\n    PreservesColimitsOfShape (SingleObj G) F := by infer_instance\n  /-- `F` reflects isomorphisms (G6). -/\n  reflectsIsos : F.ReflectsIsomorphisms := by infer_instance\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.FiberFunctor.preservesEpis","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.PreGaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nself : CategoryTheory.PreGaloisCategory.FiberFunctor F\n⊢ F.PreservesEpimorphisms","decl":"/-- Definition of a fiber functor from a Galois category. Lenstra, Def 3.1, (G4)-(G6) -/\nclass FiberFunctor {C : Type u₁} [Category.{u₂, u₁} C] [PreGaloisCategory C]\n    (F : C ⥤ FintypeCat.{w}) where\n  /-- `F` preserves terminal objects (G4). -/\n  preservesTerminalObjects : PreservesLimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) F := by\n    infer_instance\n  /-- `F` preserves pullbacks (G4). -/\n  preservesPullbacks : PreservesLimitsOfShape WalkingCospan F := by infer_instance\n  /-- `F` preserves finite coproducts (G5). -/\n  preservesFiniteCoproducts : PreservesFiniteCoproducts F := by infer_instance\n  /-- `F` preserves epimorphisms (G5). -/\n  preservesEpis : Functor.PreservesEpimorphisms F := by infer_instance\n  /-- `F` preserves quotients by finite groups (G5). -/\n  preservesQuotientsByFiniteGroups (G : Type u₂) [Group G] [Finite G] :\n    PreservesColimitsOfShape (SingleObj G) F := by infer_instance\n  /-- `F` reflects isomorphisms (G6). -/\n  reflectsIsos : F.ReflectsIsomorphisms := by infer_instance\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.FiberFunctor.preservesFiniteCoproducts","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.PreGaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nself : CategoryTheory.PreGaloisCategory.FiberFunctor F\n⊢ CategoryTheory.Limits.PreservesFiniteCoproducts F","decl":"/-- Definition of a fiber functor from a Galois category. Lenstra, Def 3.1, (G4)-(G6) -/\nclass FiberFunctor {C : Type u₁} [Category.{u₂, u₁} C] [PreGaloisCategory C]\n    (F : C ⥤ FintypeCat.{w}) where\n  /-- `F` preserves terminal objects (G4). -/\n  preservesTerminalObjects : PreservesLimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) F := by\n    infer_instance\n  /-- `F` preserves pullbacks (G4). -/\n  preservesPullbacks : PreservesLimitsOfShape WalkingCospan F := by infer_instance\n  /-- `F` preserves finite coproducts (G5). -/\n  preservesFiniteCoproducts : PreservesFiniteCoproducts F := by infer_instance\n  /-- `F` preserves epimorphisms (G5). -/\n  preservesEpis : Functor.PreservesEpimorphisms F := by infer_instance\n  /-- `F` preserves quotients by finite groups (G5). -/\n  preservesQuotientsByFiniteGroups (G : Type u₂) [Group G] [Finite G] :\n    PreservesColimitsOfShape (SingleObj G) F := by infer_instance\n  /-- `F` reflects isomorphisms (G6). -/\n  reflectsIsos : F.ReflectsIsomorphisms := by infer_instance\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.IsConnected.noTrivialComponent","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\nX : C\nself : CategoryTheory.PreGaloisCategory.IsConnected X\nY : C\ni : Quiver.Hom Y X\ninst✝ : CategoryTheory.Mono i\na✝ : CategoryTheory.Limits.IsInitial Y → False\n⊢ CategoryTheory.IsIso i","decl":"/-- An object of a category `C` is connected if it is not initial\nand has no non-trivial subobjects. Lenstra, 3.12. -/\nclass IsConnected {C : Type u₁} [Category.{u₂, u₁} C] (X : C) : Prop where\n  /-- `X` is not an initial object. -/\n  notInitial : IsInitial X → False\n  /-- `X` has no non-trivial subobjects. -/\n  noTrivialComponent (Y : C) (i : Y ⟶ X) [Mono i] : (IsInitial Y → False) → IsIso i\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.IsConnected.notInitial","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nX : C\nself : CategoryTheory.PreGaloisCategory.IsConnected X\na✝ : CategoryTheory.Limits.IsInitial X\n⊢ False","decl":"/-- An object of a category `C` is connected if it is not initial\nand has no non-trivial subobjects. Lenstra, 3.12. -/\nclass IsConnected {C : Type u₁} [Category.{u₂, u₁} C] (X : C) : Prop where\n  /-- `X` is not an initial object. -/\n  notInitial : IsInitial X → False\n  /-- `X` has no non-trivial subobjects. -/\n  noTrivialComponent (Y : C) (i : Y ⟶ X) [Mono i] : (IsInitial Y → False) → IsIso i\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PreservesIsConnected.preserves","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nD : Type v₁\ninst✝¹ : CategoryTheory.Category.{v₂, v₁} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.PreGaloisCategory.PreservesIsConnected F\nX : C\ninst✝ : CategoryTheory.PreGaloisCategory.IsConnected X\n⊢ CategoryTheory.PreGaloisCategory.IsConnected (F.obj X)","decl":"/-- A functor is said to preserve connectedness if whenever `X : C` is connected,\nalso `F.obj X` is connected. -/\nclass PreservesIsConnected {C : Type u₁} [Category.{u₂, u₁} C] {D : Type v₁}\n    [Category.{v₂, v₁} D] (F : C ⥤ D) : Prop where\n  /-- `F.obj X` is connected if `X` is connected. -/\n  preserves : ∀ {X : C} [IsConnected X], IsConnected (F.obj X)\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.instHasFiniteLimits","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.PreGaloisCategory C\n⊢ CategoryTheory.Limits.HasFiniteLimits C","decl":"instance : HasFiniteLimits C := hasFiniteLimits_of_hasTerminal_and_pullbacks\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.instHasBinaryProducts","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.PreGaloisCategory C\n⊢ CategoryTheory.Limits.HasBinaryProducts C","decl":"instance : HasBinaryProducts C := hasBinaryProducts_of_hasTerminal_and_pullbacks C\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.instHasEqualizers","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.PreGaloisCategory C\n⊢ CategoryTheory.Limits.HasEqualizers C","decl":"instance : HasEqualizers C := hasEqualizers_of_hasPullbacks_and_binary_products\n\n-- A `PreGaloisCategory` has quotients by finite groups in arbitrary universes. -/\n"}
{"name":"CategoryTheory.PreGaloisCategory.instHasColimitsOfShapeSingleObjOfFinite","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nG : Type u_1\ninst✝¹ : Group G\ninst✝ : Finite G\n⊢ CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.SingleObj G) C","decl":"instance {G : Type*} [Group G] [Finite G] : HasColimitsOfShape (SingleObj G) C := by\n  obtain ⟨G', hg, hf, ⟨e⟩⟩ := Finite.exists_type_univ_nonempty_mulEquiv G\n  exact Limits.hasColimitsOfShape_of_equivalence e.toSingleObjEquiv.symm\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.FiberFunctor.instReflectsLimitsOfShapeFintypeCatDiscretePEmpty","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.PreGaloisCategory C\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\n⊢ CategoryTheory.Limits.ReflectsLimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) F","decl":"noncomputable instance : ReflectsLimitsOfShape (Discrete PEmpty.{1}) F :=\n  reflectsLimitsOfShape_of_reflectsIsomorphisms\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.FiberFunctor.instReflectsColimitsOfShapeFintypeCatDiscretePEmpty","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.PreGaloisCategory C\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\n⊢ CategoryTheory.Limits.ReflectsColimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) F","decl":"noncomputable instance : ReflectsColimitsOfShape (Discrete PEmpty.{1}) F :=\n  reflectsColimitsOfShape_of_reflectsIsomorphisms\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.FiberFunctor.instPreservesFiniteLimitsFintypeCat","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.PreGaloisCategory C\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\n⊢ CategoryTheory.Limits.PreservesFiniteLimits F","decl":"noncomputable instance : PreservesFiniteLimits F :=\n  preservesFiniteLimits_of_preservesTerminal_and_pullbacks F\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.FiberFunctor.instPreservesColimitsOfShapeFintypeCatSingleObjOfFinite","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\nG : Type u_1\ninst✝¹ : Group G\ninst✝ : Finite G\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.SingleObj G) F","decl":"/-- Fiber functors preserve quotients by finite groups in arbitrary universes. -/\ninstance {G : Type*} [Group G] [Finite G] :\n    PreservesColimitsOfShape (SingleObj G) F := by\n  choose G' hg hf he using Finite.exists_type_univ_nonempty_mulEquiv G\n  exact Limits.preservesColimitsOfShape_of_equiv he.some.toSingleObjEquiv.symm F\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.FiberFunctor.instReflectsMonomorphismsFintypeCat","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\n⊢ F.ReflectsMonomorphisms","decl":"/-- Fiber functors reflect monomorphisms. -/\ninstance : ReflectsMonomorphisms F := ReflectsMonomorphisms.mk <| by\n  intro X Y f _\n  haveI : IsIso (pullback.fst (F.map f) (F.map f)) :=\n    isIso_fst_of_mono (F.map f)\n  haveI : IsIso (F.map (pullback.fst f f)) := by\n    rw [← PreservesPullback.iso_hom_fst]\n    exact IsIso.comp_isIso\n  haveI : IsIso (pullback.fst f f) := isIso_of_reflects_iso (pullback.fst _ _) F\n  exact (pullback.diagonal_isKernelPair f).mono_of_isIso_fst\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.FiberFunctor.instFaithfulFintypeCat","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\n⊢ F.Faithful","decl":"/-- Fiber functors are faithful. -/\ninstance : F.Faithful where\n  map_injective {X Y} f g h := by\n    haveI : IsIso (equalizer.ι (F.map f) (F.map g)) := equalizer.ι_of_eq h\n    haveI : IsIso (F.map (equalizer.ι f g)) := by\n      rw [← equalizerComparison_comp_π f g F]\n      exact IsIso.comp_isIso\n    haveI : IsIso (equalizer.ι f g) := isIso_of_reflects_iso _ F\n    exact eq_of_epi_equalizer\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.FiberFunctor.comp_right","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝² : CategoryTheory.PreGaloisCategory C\ninst✝¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nE : CategoryTheory.Functor FintypeCat FintypeCat\ninst✝ : E.IsEquivalence\n⊢ CategoryTheory.PreGaloisCategory.FiberFunctor (F.comp E)","decl":"/-- If `F` is a fiber functor and `E` is an equivalence between categories of finite types,\nthen `F ⋙ E` is again a fiber functor. -/\nlemma comp_right (E : FintypeCat.{w} ⥤ FintypeCat.{t}) [E.IsEquivalence] :\n    FiberFunctor (F ⋙ E) where\n  preservesQuotientsByFiniteGroups _ := comp_preservesColimitsOfShape F E\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.mulAction_def","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\nX : C\nσ : CategoryTheory.Aut F\nx : ↑(F.obj X)\n⊢ Eq (HSMul.hSMul σ x) (σ.hom.app X x)","decl":"lemma mulAction_def {X : C} (σ : Aut F) (x : F.obj X) :\n    σ • x = σ.hom.app X x :=\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.mulAction_naturality","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\nX Y : C\nσ : CategoryTheory.Aut F\nf : Quiver.Hom X Y\nx : ↑(F.obj X)\n⊢ Eq (HSMul.hSMul σ (F.map f x)) (F.map f (HSMul.hSMul σ x))","decl":"lemma mulAction_naturality {X Y : C} (σ : Aut F) (f : X ⟶ Y) (x : F.obj X) :\n    σ • F.map f x = F.map f (σ • x) :=\n  FunctorToFintypeCat.naturality F F σ.hom f x\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.has_non_trivial_subobject_of_not_isConnected_of_not_initial","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nX : C\nhc : Not (CategoryTheory.PreGaloisCategory.IsConnected X)\nhi : CategoryTheory.Limits.IsInitial X → False\n⊢ Exists fun Y => Exists fun v => And (CategoryTheory.Limits.IsInitial Y → False) (And (CategoryTheory.Mono v) (Not (CategoryTheory.IsIso v)))","decl":"/-- An object that is neither initial or connected has a non-trivial subobject. -/\nlemma has_non_trivial_subobject_of_not_isConnected_of_not_initial (X : C) (hc : ¬ IsConnected X)\n    (hi : IsInitial X → False) :\n    ∃ (Y : C) (v : Y ⟶ X), (IsInitial Y → False) ∧ Mono v ∧ (¬ IsIso v) := by\n  contrapose! hc\n  exact ⟨hi, fun Y i hm hni ↦ hc Y i hni hm⟩\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.card_fiber_eq_of_iso","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\nX Y : C\ni : CategoryTheory.Iso X Y\n⊢ Eq (Nat.card ↑(F.obj X)) (Nat.card ↑(F.obj Y))","decl":"/-- The cardinality of the fiber is preserved under isomorphisms. -/\nlemma card_fiber_eq_of_iso {X Y : C} (i : X ≅ Y) : Nat.card (F.obj X) = Nat.card (F.obj Y) := by\n  have e : F.obj X ≃ F.obj Y := Iso.toEquiv (mapIso (F ⋙ FintypeCat.incl) i)\n  exact Nat.card_eq_of_bijective e (Equiv.bijective e)\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.initial_iff_fiber_empty","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.PreGaloisCategory C\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX : C\n⊢ Iff (Nonempty (CategoryTheory.Limits.IsInitial X)) (IsEmpty ↑(F.obj X))","decl":"/-- An object is initial if and only if its fiber is empty. -/\nlemma initial_iff_fiber_empty (X : C) : Nonempty (IsInitial X) ↔ IsEmpty (F.obj X) := by\n  rw [(IsInitial.isInitialIffObj F X).nonempty_congr]\n  haveI : PreservesFiniteColimits (forget FintypeCat) := by\n    show PreservesFiniteColimits FintypeCat.incl\n    infer_instance\n  haveI : ReflectsColimit (Functor.empty.{0} _) (forget FintypeCat) := by\n    show ReflectsColimit (Functor.empty.{0} _) FintypeCat.incl\n    infer_instance\n  exact Concrete.initial_iff_empty_of_preserves_of_reflects (F.obj X)\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.not_initial_iff_fiber_nonempty","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.PreGaloisCategory C\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX : C\n⊢ Iff (CategoryTheory.Limits.IsInitial X → False) (Nonempty ↑(F.obj X))","decl":"/-- An object is not initial if and only if its fiber is nonempty. -/\nlemma not_initial_iff_fiber_nonempty (X : C) : (IsInitial X → False) ↔ Nonempty (F.obj X) := by\n  rw [← not_isEmpty_iff]\n  refine ⟨fun h he ↦ ?_, fun h hin ↦ h <| (initial_iff_fiber_empty F X).mp ⟨hin⟩⟩\n  exact Nonempty.elim ((initial_iff_fiber_empty F X).mpr he) h\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.not_initial_of_inhabited","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.PreGaloisCategory C\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX : C\nx : ↑(F.obj X)\nh : CategoryTheory.Limits.IsInitial X\n⊢ False","decl":"/-- An object whose fiber is inhabited is not initial. -/\nlemma not_initial_of_inhabited {X : C} (x : F.obj X) (h : IsInitial X) : False :=\n  ((initial_iff_fiber_empty F X).mp ⟨h⟩).false x\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.nonempty_fiber_of_isConnected","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\nX : C\ninst✝ : CategoryTheory.PreGaloisCategory.IsConnected X\n⊢ Nonempty ↑(F.obj X)","decl":"/-- The fiber of a connected object is nonempty. -/\ninstance nonempty_fiber_of_isConnected (X : C) [IsConnected X] : Nonempty (F.obj X) := by\n  by_contra h\n  have ⟨hin⟩ : Nonempty (IsInitial X) := (initial_iff_fiber_empty F X).mpr (not_nonempty_iff.mp h)\n  exact IsConnected.notInitial hin\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.fiberEqualizerEquiv_symm_ι_apply","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.PreGaloisCategory C\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX Y : C\nf g : Quiver.Hom X Y\nx : ↑(F.obj X)\nh : Eq (F.map f x) (F.map g x)\n⊢ Eq (F.map (CategoryTheory.Limits.equalizer.ι f g) ((CategoryTheory.PreGaloisCategory.fiberEqualizerEquiv F f g).symm ⟨x, h⟩)) x","decl":"@[simp]\nlemma fiberEqualizerEquiv_symm_ι_apply {X Y : C} {f g : X ⟶ Y} (x : F.obj X)\n    (h : F.map f x = F.map g x) :\n    F.map (equalizer.ι f g) ((fiberEqualizerEquiv F f g).symm ⟨x, h⟩) = x := by\n  simp [fiberEqualizerEquiv]\n  change ((Types.equalizerIso _ _).inv ≫ _ ≫ (F ⋙ FintypeCat.incl).map (equalizer.ι f g)) _ = _\n  erw [PreservesEqualizer.iso_inv_ι, Types.equalizerIso_inv_comp_ι]\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.fiberPullbackEquiv_symm_fst_apply","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.PreGaloisCategory C\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX A B : C\nf : Quiver.Hom A X\ng : Quiver.Hom B X\na : ↑(F.obj A)\nb : ↑(F.obj B)\nh : Eq (F.map f a) (F.map g b)\n⊢ Eq (F.map (CategoryTheory.Limits.pullback.fst f g) ((CategoryTheory.PreGaloisCategory.fiberPullbackEquiv F f g).symm ⟨{ fst := a, snd := b }, h⟩)) a","decl":"@[simp]\nlemma fiberPullbackEquiv_symm_fst_apply {X A B : C} {f : A ⟶ X} {g : B ⟶ X}\n    (a : F.obj A) (b : F.obj B) (h : F.map f a = F.map g b) :\n    F.map (pullback.fst f g) ((fiberPullbackEquiv F f g).symm ⟨(a, b), h⟩) = a := by\n  simp [fiberPullbackEquiv]\n  change ((Types.pullbackIsoPullback _ _).inv ≫ _ ≫\n    (F ⋙ FintypeCat.incl).map (pullback.fst f g)) _ = _\n  erw [PreservesPullback.iso_inv_fst, Types.pullbackIsoPullback_inv_fst]\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.fiberPullbackEquiv_symm_snd_apply","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.PreGaloisCategory C\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX A B : C\nf : Quiver.Hom A X\ng : Quiver.Hom B X\na : ↑(F.obj A)\nb : ↑(F.obj B)\nh : Eq (F.map f a) (F.map g b)\n⊢ Eq (F.map (CategoryTheory.Limits.pullback.snd f g) ((CategoryTheory.PreGaloisCategory.fiberPullbackEquiv F f g).symm ⟨{ fst := a, snd := b }, h⟩)) b","decl":"@[simp]\nlemma fiberPullbackEquiv_symm_snd_apply {X A B : C} {f : A ⟶ X} {g : B ⟶ X}\n    (a : F.obj A) (b : F.obj B) (h : F.map f a = F.map g b) :\n    F.map (pullback.snd f g) ((fiberPullbackEquiv F f g).symm ⟨(a, b), h⟩) = b := by\n  simp [fiberPullbackEquiv]\n  change ((Types.pullbackIsoPullback _ _).inv ≫ _ ≫\n    (F ⋙ FintypeCat.incl).map (pullback.snd f g)) _ = _\n  erw [PreservesPullback.iso_inv_snd, Types.pullbackIsoPullback_inv_snd]\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.fiberBinaryProductEquiv_symm_fst_apply","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.PreGaloisCategory C\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX Y : C\nx : ↑(F.obj X)\ny : ↑(F.obj Y)\n⊢ Eq (F.map CategoryTheory.Limits.prod.fst ((CategoryTheory.PreGaloisCategory.fiberBinaryProductEquiv F X Y).symm { fst := x, snd := y })) x","decl":"@[simp]\nlemma fiberBinaryProductEquiv_symm_fst_apply {X Y : C} (x : F.obj X) (y : F.obj Y) :\n    F.map prod.fst ((fiberBinaryProductEquiv F X Y).symm (x, y)) = x := by\n  simp only [fiberBinaryProductEquiv, comp_obj, FintypeCat.incl_obj, Iso.toEquiv_comp,\n    Equiv.symm_trans_apply, Iso.toEquiv_symm_fun]\n  change ((Types.binaryProductIso _ _).inv ≫ _ ≫ (F ⋙ FintypeCat.incl).map prod.fst) _ = _\n  erw [PreservesLimitPair.iso_inv_fst, Types.binaryProductIso_inv_comp_fst]\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.fiberBinaryProductEquiv_symm_snd_apply","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.PreGaloisCategory C\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX Y : C\nx : ↑(F.obj X)\ny : ↑(F.obj Y)\n⊢ Eq (F.map CategoryTheory.Limits.prod.snd ((CategoryTheory.PreGaloisCategory.fiberBinaryProductEquiv F X Y).symm { fst := x, snd := y })) y","decl":"@[simp]\nlemma fiberBinaryProductEquiv_symm_snd_apply {X Y : C} (x : F.obj X) (y : F.obj Y) :\n    F.map prod.snd ((fiberBinaryProductEquiv F X Y).symm (x, y)) = y := by\n  simp only [fiberBinaryProductEquiv, comp_obj, FintypeCat.incl_obj, Iso.toEquiv_comp,\n    Equiv.symm_trans_apply, Iso.toEquiv_symm_fun]\n  change ((Types.binaryProductIso _ _).inv ≫ _ ≫ (F ⋙ FintypeCat.incl).map prod.snd) _ = _\n  erw [PreservesLimitPair.iso_inv_snd, Types.binaryProductIso_inv_comp_snd]\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.evaluation_injective_of_isConnected","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝² : CategoryTheory.PreGaloisCategory C\ninst✝¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nA X : C\ninst✝ : CategoryTheory.PreGaloisCategory.IsConnected A\na : ↑(F.obj A)\n⊢ Function.Injective fun f => F.map f a","decl":"/-- The evaluation map is injective for connected objects. -/\nlemma evaluation_injective_of_isConnected (A X : C) [IsConnected A] (a : F.obj A) :\n    Function.Injective (fun (f : A ⟶ X) ↦ F.map f a) := by\n  intro f g (h : F.map f a = F.map g a)\n  haveI : IsIso (equalizer.ι f g) := by\n    apply IsConnected.noTrivialComponent _ (equalizer.ι f g)\n    exact not_initial_of_inhabited F ((fiberEqualizerEquiv F f g).symm ⟨a, h⟩)\n  exact eq_of_epi_equalizer\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.evaluation_aut_injective_of_isConnected","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝² : CategoryTheory.PreGaloisCategory C\ninst✝¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nA : C\ninst✝ : CategoryTheory.PreGaloisCategory.IsConnected A\na : ↑(F.obj A)\n⊢ Function.Injective fun f => F.map f.hom a","decl":"/-- The evaluation map on automorphisms is injective for connected objects. -/\nlemma evaluation_aut_injective_of_isConnected (A : C) [IsConnected A] (a : F.obj A) :\n    Function.Injective (fun f : Aut A ↦ F.map (f.hom) a) := by\n  show Function.Injective ((fun f : A ⟶ A ↦ F.map f a) ∘ (fun f : Aut A ↦ f.hom))\n  apply Function.Injective.comp\n  · exact evaluation_injective_of_isConnected F A A a\n  · exact @Aut.ext _ _ A\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.epi_of_nonempty_of_isConnected","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝² : CategoryTheory.PreGaloisCategory C\ninst✝¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX A : C\ninst✝ : CategoryTheory.PreGaloisCategory.IsConnected A\nh : Nonempty ↑(F.obj X)\nf : Quiver.Hom X A\n⊢ CategoryTheory.Epi f","decl":"/-- A morphism from an object `X` with non-empty fiber to a connected object `A` is an\nepimorphism. -/\nlemma epi_of_nonempty_of_isConnected {X A : C} [IsConnected A] [h : Nonempty (F.obj X)]\n    (f : X ⟶ A) : Epi f := Epi.mk <| fun {Z} u v huv ↦ by\n  apply evaluation_injective_of_isConnected F A Z (F.map f (Classical.arbitrary _))\n  simpa using congr_fun (F.congr_map huv) _\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.surjective_on_fiber_of_epi","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝² : CategoryTheory.PreGaloisCategory C\ninst✝¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Epi f\n⊢ Function.Surjective (F.map f)","decl":"/-- An epimorphism induces a surjective map on fibers. -/\nlemma surjective_on_fiber_of_epi {X Y : C} (f : X ⟶ Y) [Epi f] : Function.Surjective (F.map f) :=\n  surjective_of_epi (FintypeCat.incl.map (F.map f))\n\n/- A morphism from an object with non-empty fiber to a connected object is surjective on fibers. -/\n"}
{"name":"CategoryTheory.PreGaloisCategory.surjective_of_nonempty_fiber_of_isConnected","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝³ : CategoryTheory.PreGaloisCategory C\ninst✝² : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX A : C\ninst✝¹ : Nonempty ↑(F.obj X)\ninst✝ : CategoryTheory.PreGaloisCategory.IsConnected A\nf : Quiver.Hom X A\n⊢ Function.Surjective (F.map f)","decl":"lemma surjective_of_nonempty_fiber_of_isConnected {X A : C} [Nonempty (F.obj X)]\n    [IsConnected A] (f : X ⟶ A) :\n    Function.Surjective (F.map f) := by\n  have : Epi f := epi_of_nonempty_of_isConnected F f\n  exact surjective_on_fiber_of_epi F f\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.nonempty_fiber_pi_of_nonempty_of_finite","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝² : CategoryTheory.PreGaloisCategory C\nι : Type u_1\ninst✝¹ : Finite ι\nX : ι → C\ninst✝ : ∀ (i : ι), Nonempty ↑(F.obj (X i))\n⊢ Nonempty ↑(F.obj (CategoryTheory.Limits.piObj X))","decl":"/-- If `X : ι → C` is a finite family of objects with non-empty fiber, then\nalso `∏ᶜ X` has non-empty fiber. -/\ninstance nonempty_fiber_pi_of_nonempty_of_finite {ι : Type*} [Finite ι] (X : ι → C)\n    [∀ i, Nonempty (F.obj (X i))] : Nonempty (F.obj (∏ᶜ X)) := by\n  cases nonempty_fintype ι\n  let f (i : ι) : FintypeCat.{w} := F.obj (X i)\n  let i : F.obj (∏ᶜ X) ≅ ∏ᶜ f := PreservesProduct.iso F _\n  exact Nonempty.elim inferInstance fun x : (∏ᶜ f : FintypeCat.{w}) ↦ ⟨i.inv x⟩\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.isIso_of_mono_of_eq_card_fiber","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝² : CategoryTheory.PreGaloisCategory C\ninst✝¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\nh : Eq (Nat.card ↑(F.obj X)) (Nat.card ↑(F.obj Y))\n⊢ CategoryTheory.IsIso f","decl":"/-- A mono between objects with equally sized fibers is an iso. -/\nlemma isIso_of_mono_of_eq_card_fiber {X Y : C} (f : X ⟶ Y) [Mono f]\n    (h : Nat.card (F.obj X) = Nat.card (F.obj Y)) : IsIso f := by\n  have : IsIso (F.map f) := by\n    apply (ConcreteCategory.isIso_iff_bijective (F.map f)).mpr\n    apply (Fintype.bijective_iff_injective_and_card (F.map f)).mpr\n    refine ⟨injective_of_mono_of_preservesPullback (F.map f), ?_⟩\n    simp only [← Nat.card_eq_fintype_card, h]\n  exact isIso_of_reflects_iso f F\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.lt_card_fiber_of_mono_of_notIso","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝² : CategoryTheory.PreGaloisCategory C\ninst✝¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\nh : Not (CategoryTheory.IsIso f)\n⊢ LT.lt (Nat.card ↑(F.obj X)) (Nat.card ↑(F.obj Y))","decl":"/-- Along a mono that is not an iso, the cardinality of the fiber strictly increases. -/\nlemma lt_card_fiber_of_mono_of_notIso {X Y : C} (f : X ⟶ Y) [Mono f]\n    (h : ¬ IsIso f) : Nat.card (F.obj X) < Nat.card (F.obj Y) := by\n  by_contra hlt\n  apply h\n  apply isIso_of_mono_of_eq_card_fiber F f\n  simp only [gt_iff_lt, not_lt] at hlt\n  exact Nat.le_antisymm\n    (Finite.card_le_of_injective (F.map f) (injective_of_mono_of_preservesPullback (F.map f))) hlt\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.non_zero_card_fiber_of_not_initial","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.PreGaloisCategory C\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX : C\nh : CategoryTheory.Limits.IsInitial X → False\n⊢ Ne (Nat.card ↑(F.obj X)) 0","decl":"/-- The cardinality of the fiber of a not-initial object is non-zero. -/\nlemma non_zero_card_fiber_of_not_initial (X : C) (h : IsInitial X → False) :\n    Nat.card (F.obj X) ≠ 0 := by\n  intro hzero\n  refine Nonempty.elim ?_ h\n  rw [initial_iff_fiber_empty F]\n  exact Finite.card_eq_zero_iff.mp hzero\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.card_fiber_coprod_eq_sum","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.PreGaloisCategory C\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX Y : C\n⊢ Eq (Nat.card ↑(F.obj (CategoryTheory.Limits.coprod X Y))) (HAdd.hAdd (Nat.card ↑(F.obj X)) (Nat.card ↑(F.obj Y)))","decl":"/-- The cardinality of the fiber of a coproduct is the sum of the cardinalities of the fibers. -/\nlemma card_fiber_coprod_eq_sum (X Y : C) :\n    Nat.card (F.obj (X ⨿ Y)) = Nat.card (F.obj X) + Nat.card (F.obj Y) := by\n  let e : F.obj (X ⨿ Y) ≃ F.obj X ⊕ F.obj Y := Iso.toEquiv\n    <| (PreservesColimitPair.iso (F ⋙ FintypeCat.incl) X Y).symm.trans\n    <| Types.binaryCoproductIso (FintypeCat.incl.obj (F.obj X)) (FintypeCat.incl.obj (F.obj Y))\n  rw [← Nat.card_sum]\n  exact Nat.card_eq_of_bijective e.toFun (Equiv.bijective e)\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.card_hom_le_card_fiber_of_connected","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝² : CategoryTheory.PreGaloisCategory C\ninst✝¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nA X : C\ninst✝ : CategoryTheory.PreGaloisCategory.IsConnected A\n⊢ LE.le (Nat.card (Quiver.Hom A X)) (Nat.card ↑(F.obj X))","decl":"/-- The cardinality of morphisms `A ⟶ X` is smaller than the cardinality of\nthe fiber of the target if the source is connected. -/\nlemma card_hom_le_card_fiber_of_connected (A X : C) [IsConnected A] :\n    Nat.card (A ⟶ X) ≤ Nat.card (F.obj X) := by\n  apply Nat.card_le_card_of_injective\n  exact evaluation_injective_of_isConnected F A X (Classical.arbitrary _)\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.card_aut_le_card_fiber_of_connected","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝² : CategoryTheory.PreGaloisCategory C\ninst✝¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nA : C\ninst✝ : CategoryTheory.PreGaloisCategory.IsConnected A\n⊢ LE.le (Nat.card (CategoryTheory.Aut A)) (Nat.card ↑(F.obj A))","decl":"/-- If `A` is connected, the cardinality of `Aut A` is smaller than the cardinality of the\nfiber of `A`. -/\nlemma card_aut_le_card_fiber_of_connected (A : C) [IsConnected A] :\n    Nat.card (Aut A) ≤ Nat.card (F.obj A) := by\n  have h : Nonempty (F.obj A) := inferInstance\n  obtain ⟨a⟩ := h\n  apply Nat.card_le_card_of_injective\n  exact evaluation_aut_injective_of_isConnected _ _ a\n\n"}
{"name":"CategoryTheory.GaloisCategory.toPreGaloisCategory","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nself : CategoryTheory.GaloisCategory C\n⊢ CategoryTheory.PreGaloisCategory C","decl":"/-- A `PreGaloisCategory` is a `GaloisCategory` if it admits a fiber functor. -/\nclass GaloisCategory (C : Type u₁) [Category.{u₂, u₁} C]\n    extends PreGaloisCategory C : Prop where\n  hasFiberFunctor : ∃ F : C ⥤ FintypeCat.{u₂}, Nonempty (PreGaloisCategory.FiberFunctor F)\n\n"}
{"name":"CategoryTheory.GaloisCategory.hasFiberFunctor","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nself : CategoryTheory.GaloisCategory C\n⊢ Exists fun F => Nonempty (CategoryTheory.PreGaloisCategory.FiberFunctor F)","decl":"/-- A `PreGaloisCategory` is a `GaloisCategory` if it admits a fiber functor. -/\nclass GaloisCategory (C : Type u₁) [Category.{u₂, u₁} C]\n    extends PreGaloisCategory C : Prop where\n  hasFiberFunctor : ∃ F : C ⥤ FintypeCat.{u₂}, Nonempty (PreGaloisCategory.FiberFunctor F)\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.instFiberFunctorGetFiberFunctor","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\n⊢ CategoryTheory.PreGaloisCategory.FiberFunctor (CategoryTheory.PreGaloisCategory.GaloisCategory.getFiberFunctor C)","decl":"/-- The arbitrarily chosen fiber functor `GaloisCategory.getFiberFunctor` is a fiber functor. -/\nnoncomputable instance : FiberFunctor (GaloisCategory.getFiberFunctor C) :=\n  Classical.choice <| Classical.choose_spec (@GaloisCategory.hasFiberFunctor C _ _)\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.instFiniteHomOfIsConnected","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\nA X : C\ninst✝ : CategoryTheory.PreGaloisCategory.IsConnected A\n⊢ Finite (Quiver.Hom A X)","decl":"/-- In a `GaloisCategory` the set of morphisms out of a connected object is finite. -/\ninstance (A X : C) [IsConnected A] : Finite (A ⟶ X) := by\n  let F := GaloisCategory.getFiberFunctor C\n  obtain ⟨a⟩ := nonempty_fiber_of_isConnected F A\n  apply Finite.of_injective (fun f ↦ F.map f a)\n  exact evaluation_injective_of_isConnected F A X a\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.instFiniteAutOfIsConnected","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\nA : C\ninst✝ : CategoryTheory.PreGaloisCategory.IsConnected A\n⊢ Finite (CategoryTheory.Aut A)","decl":"/-- In a `GaloisCategory` the set of automorphism of a connected object is finite. -/\ninstance (A : C) [IsConnected A] : Finite (Aut A) := by\n  let F := GaloisCategory.getFiberFunctor C\n  obtain ⟨a⟩ := nonempty_fiber_of_isConnected F A\n  apply Finite.of_injective (fun f ↦ F.map f.hom a)\n  exact evaluation_aut_injective_of_isConnected F A a\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.instMonoCoprod","module":"Mathlib.CategoryTheory.Galois.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\n⊢ CategoryTheory.Limits.MonoCoprod C","decl":"/-- Coproduct inclusions are monic in Galois categories. -/\ninstance : MonoCoprod C := by\n  let F := GaloisCategory.getFiberFunctor C\n  exact MonoCoprod.monoCoprod_of_preservesCoprod_of_reflectsMono F\n\n"}
