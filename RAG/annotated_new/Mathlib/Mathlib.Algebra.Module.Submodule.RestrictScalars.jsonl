{"name":"Submodule.coe_restrictScalars","module":"Mathlib.Algebra.Module.Submodule.RestrictScalars","initialProofState":"S : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Semiring S\ninst✝³ : Module S M\ninst✝² : Module R M\ninst✝¹ : SMul S R\ninst✝ : IsScalarTower S R M\nV : Submodule R M\n⊢ Eq ↑(Submodule.restrictScalars S V) ↑V","decl":"@[simp]\ntheorem coe_restrictScalars (V : Submodule R M) : (V.restrictScalars S : Set M) = V :=\n  rfl\n\n"}
{"name":"Submodule.toAddSubmonoid_restrictScalars","module":"Mathlib.Algebra.Module.Submodule.RestrictScalars","initialProofState":"S : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Semiring S\ninst✝³ : Module S M\ninst✝² : Module R M\ninst✝¹ : SMul S R\ninst✝ : IsScalarTower S R M\nV : Submodule R M\n⊢ Eq (Submodule.restrictScalars S V).toAddSubmonoid V.toAddSubmonoid","decl":"@[simp]\ntheorem toAddSubmonoid_restrictScalars (V : Submodule R M) :\n    (V.restrictScalars S).toAddSubmonoid = V.toAddSubmonoid :=\n  rfl\n\n"}
{"name":"Submodule.restrictScalars_mem","module":"Mathlib.Algebra.Module.Submodule.RestrictScalars","initialProofState":"S : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Semiring S\ninst✝³ : Module S M\ninst✝² : Module R M\ninst✝¹ : SMul S R\ninst✝ : IsScalarTower S R M\nV : Submodule R M\nm : M\n⊢ Iff (Membership.mem (Submodule.restrictScalars S V) m) (Membership.mem V m)","decl":"@[simp]\ntheorem restrictScalars_mem (V : Submodule R M) (m : M) : m ∈ V.restrictScalars S ↔ m ∈ V :=\n  Iff.refl _\n\n"}
{"name":"Submodule.restrictScalars_self","module":"Mathlib.Algebra.Module.Submodule.RestrictScalars","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nV : Submodule R M\n⊢ Eq (Submodule.restrictScalars R V) V","decl":"@[simp]\ntheorem restrictScalars_self (V : Submodule R M) : V.restrictScalars R = V :=\n  SetLike.coe_injective rfl\n\n"}
{"name":"Submodule.restrictScalars_injective","module":"Mathlib.Algebra.Module.Submodule.RestrictScalars","initialProofState":"S : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Semiring S\ninst✝³ : Module S M\ninst✝² : Module R M\ninst✝¹ : SMul S R\ninst✝ : IsScalarTower S R M\n⊢ Function.Injective (Submodule.restrictScalars S)","decl":"theorem restrictScalars_injective :\n    Function.Injective (restrictScalars S : Submodule R M → Submodule S M) := fun _ _ h =>\n  ext <| Set.ext_iff.1 (SetLike.ext'_iff.1 h :)\n\n"}
{"name":"Submodule.restrictScalars_inj","module":"Mathlib.Algebra.Module.Submodule.RestrictScalars","initialProofState":"S : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Semiring S\ninst✝³ : Module S M\ninst✝² : Module R M\ninst✝¹ : SMul S R\ninst✝ : IsScalarTower S R M\nV₁ V₂ : Submodule R M\n⊢ Iff (Eq (Submodule.restrictScalars S V₁) (Submodule.restrictScalars S V₂)) (Eq V₁ V₂)","decl":"@[simp]\ntheorem restrictScalars_inj {V₁ V₂ : Submodule R M} :\n    restrictScalars S V₁ = restrictScalars S V₂ ↔ V₁ = V₂ :=\n  (restrictScalars_injective S _ _).eq_iff\n\n"}
{"name":"Submodule.restrictScalars.isScalarTower","module":"Mathlib.Algebra.Module.Submodule.RestrictScalars","initialProofState":"S : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Semiring S\ninst✝³ : Module S M\ninst✝² : Module R M\ninst✝¹ : SMul S R\ninst✝ : IsScalarTower S R M\np : Submodule R M\n⊢ IsScalarTower S R (Subtype fun x => Membership.mem (Submodule.restrictScalars S p) x)","decl":"instance restrictScalars.isScalarTower (p : Submodule R M) :\n    IsScalarTower S R (p.restrictScalars S) where\n  smul_assoc r s x := Subtype.ext <| smul_assoc r s (x : M)\n\n"}
{"name":"Submodule.restrictScalarsEmbedding_apply","module":"Mathlib.Algebra.Module.Submodule.RestrictScalars","initialProofState":"S : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Semiring S\ninst✝³ : Module S M\ninst✝² : Module R M\ninst✝¹ : SMul S R\ninst✝ : IsScalarTower S R M\nV : Submodule R M\n⊢ Eq ((Submodule.restrictScalarsEmbedding S R M) V) (Submodule.restrictScalars S V)","decl":"/-- `restrictScalars S` is an embedding of the lattice of `R`-submodules into\nthe lattice of `S`-submodules. -/\n@[simps]\ndef restrictScalarsEmbedding : Submodule R M ↪o Submodule S M where\n  toFun := restrictScalars S\n  inj' := restrictScalars_injective S R M\n  map_rel_iff' := by simp [SetLike.le_def]\n\n"}
{"name":"Submodule.restrictScalarsEquiv_apply","module":"Mathlib.Algebra.Module.Submodule.RestrictScalars","initialProofState":"S : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Semiring S\ninst✝³ : Module S M\ninst✝² : Module R M\ninst✝¹ : SMul S R\ninst✝ : IsScalarTower S R M\np : Submodule R M\na✝ : Subtype fun x => Membership.mem p x\n⊢ Eq ((Submodule.restrictScalarsEquiv S R M p) a✝) a✝","decl":"/-- Turning `p : Submodule R M` into an `S`-submodule gives the same module structure\nas turning it into a type and adding a module structure. -/\n@[simps (config := { simpRhs := true })]\ndef restrictScalarsEquiv (p : Submodule R M) : p.restrictScalars S ≃ₗ[R] p :=\n  { AddEquiv.refl p with\n    map_smul' := fun _ _ => rfl }\n\n"}
{"name":"Submodule.restrictScalarsEquiv_symm_apply","module":"Mathlib.Algebra.Module.Submodule.RestrictScalars","initialProofState":"S : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Semiring S\ninst✝³ : Module S M\ninst✝² : Module R M\ninst✝¹ : SMul S R\ninst✝ : IsScalarTower S R M\np : Submodule R M\na✝ : Subtype fun x => Membership.mem p x\n⊢ Eq ((Submodule.restrictScalarsEquiv S R M p).symm a✝) a✝","decl":"/-- Turning `p : Submodule R M` into an `S`-submodule gives the same module structure\nas turning it into a type and adding a module structure. -/\n@[simps (config := { simpRhs := true })]\ndef restrictScalarsEquiv (p : Submodule R M) : p.restrictScalars S ≃ₗ[R] p :=\n  { AddEquiv.refl p with\n    map_smul' := fun _ _ => rfl }\n\n"}
{"name":"Submodule.restrictScalars_bot","module":"Mathlib.Algebra.Module.Submodule.RestrictScalars","initialProofState":"S : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Semiring S\ninst✝³ : Module S M\ninst✝² : Module R M\ninst✝¹ : SMul S R\ninst✝ : IsScalarTower S R M\n⊢ Eq (Submodule.restrictScalars S Bot.bot) Bot.bot","decl":"@[simp]\ntheorem restrictScalars_bot : restrictScalars S (⊥ : Submodule R M) = ⊥ :=\n  rfl\n\n"}
{"name":"Submodule.restrictScalars_eq_bot_iff","module":"Mathlib.Algebra.Module.Submodule.RestrictScalars","initialProofState":"S : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Semiring S\ninst✝³ : Module S M\ninst✝² : Module R M\ninst✝¹ : SMul S R\ninst✝ : IsScalarTower S R M\np : Submodule R M\n⊢ Iff (Eq (Submodule.restrictScalars S p) Bot.bot) (Eq p Bot.bot)","decl":"@[simp]\ntheorem restrictScalars_eq_bot_iff {p : Submodule R M} : restrictScalars S p = ⊥ ↔ p = ⊥ := by\n  simp [SetLike.ext_iff]\n\n"}
{"name":"Submodule.restrictScalars_top","module":"Mathlib.Algebra.Module.Submodule.RestrictScalars","initialProofState":"S : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Semiring S\ninst✝³ : Module S M\ninst✝² : Module R M\ninst✝¹ : SMul S R\ninst✝ : IsScalarTower S R M\n⊢ Eq (Submodule.restrictScalars S Top.top) Top.top","decl":"@[simp]\ntheorem restrictScalars_top : restrictScalars S (⊤ : Submodule R M) = ⊤ :=\n  rfl\n\n"}
{"name":"Submodule.restrictScalars_eq_top_iff","module":"Mathlib.Algebra.Module.Submodule.RestrictScalars","initialProofState":"S : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Semiring S\ninst✝³ : Module S M\ninst✝² : Module R M\ninst✝¹ : SMul S R\ninst✝ : IsScalarTower S R M\np : Submodule R M\n⊢ Iff (Eq (Submodule.restrictScalars S p) Top.top) (Eq p Top.top)","decl":"@[simp]\ntheorem restrictScalars_eq_top_iff {p : Submodule R M} : restrictScalars S p = ⊤ ↔ p = ⊤ := by\n  simp [SetLike.ext_iff]\n\n"}
