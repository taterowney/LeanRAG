{"name":"Module.free_of_isLocalizedModule","module":"Mathlib.RingTheory.LocalProperties.Projective","initialProofState":"R : Type u_1\nM : Type uM\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup M\ninst✝⁹ : Module R M\nRₛ : Type u_4\nMₛ : Type u_5\ninst✝⁸ : AddCommGroup Mₛ\ninst✝⁷ : Module R Mₛ\ninst✝⁶ : CommRing Rₛ\ninst✝⁵ : Algebra R Rₛ\ninst✝⁴ : Module Rₛ Mₛ\ninst✝³ : IsScalarTower R Rₛ Mₛ\nS : Submonoid R\nf : LinearMap (RingHom.id R) M Mₛ\ninst✝² : IsLocalization S Rₛ\ninst✝¹ : IsLocalizedModule S f\ninst✝ : Module.Free R M\n⊢ Module.Free Rₛ Mₛ","decl":"theorem Module.free_of_isLocalizedModule {Rₛ Mₛ} [AddCommGroup Mₛ] [Module R Mₛ]\n    [CommRing Rₛ] [Algebra R Rₛ] [Module Rₛ Mₛ] [IsScalarTower R Rₛ Mₛ]\n    (S) (f : M →ₗ[R] Mₛ) [IsLocalization S Rₛ] [IsLocalizedModule S f] [Module.Free R M] :\n    Module.Free Rₛ Mₛ :=\n    Free.of_equiv (IsLocalizedModule.isBaseChange S Rₛ f).equiv\n\n"}
{"name":"Module.lift_rank_of_isLocalizedModule_of_free","module":"Mathlib.RingTheory.LocalProperties.Projective","initialProofState":"R : Type u_1\nM : Type uM\ninst✝¹² : CommRing R\ninst✝¹¹ : AddCommGroup M\ninst✝¹⁰ : Module R M\nRₛ : Type uR'\nMₛ : Type uM'\ninst✝⁹ : AddCommGroup Mₛ\ninst✝⁸ : Module R Mₛ\ninst✝⁷ : CommRing Rₛ\ninst✝⁶ : Algebra R Rₛ\ninst✝⁵ : Module Rₛ Mₛ\ninst✝⁴ : IsScalarTower R Rₛ Mₛ\nS : Submonoid R\nf : LinearMap (RingHom.id R) M Mₛ\ninst✝³ : IsLocalization S Rₛ\ninst✝² : IsLocalizedModule S f\ninst✝¹ : Module.Free R M\ninst✝ : Nontrivial Rₛ\n⊢ Eq (Cardinal.lift.{uM, uM'} (Module.rank Rₛ Mₛ)) (Cardinal.lift.{uM', uM} (Module.rank R M))","decl":"universe uR' uM' in\n/--\nAlso see `IsLocalizedModule.lift_rank_eq` for a version for non-free modules,\nbut requires `S` to not contain any zero-divisors.\n-/\ntheorem Module.lift_rank_of_isLocalizedModule_of_free\n    (Rₛ : Type uR') {Mₛ : Type uM'} [AddCommGroup Mₛ] [Module R Mₛ]\n    [CommRing Rₛ] [Algebra R Rₛ] [Module Rₛ Mₛ] [IsScalarTower R Rₛ Mₛ] (S : Submonoid R)\n    (f : M →ₗ[R] Mₛ) [IsLocalization S Rₛ] [IsLocalizedModule S f] [Module.Free R M]\n    [Nontrivial Rₛ] :\n    Cardinal.lift.{uM} (Module.rank Rₛ Mₛ) = Cardinal.lift.{uM'} (Module.rank R M) := by\n  apply Cardinal.lift_injective.{max uM' uR'}\n  have := (algebraMap R Rₛ).domain_nontrivial\n  have := (IsLocalizedModule.isBaseChange S Rₛ f).equiv.lift_rank_eq.symm\n  simp only [rank_tensorProduct, rank_self,\n    Cardinal.lift_one, one_mul, Cardinal.lift_lift] at this ⊢\n  convert this\n  exact Cardinal.lift_umax\n\n"}
{"name":"Module.finrank_of_isLocalizedModule_of_free","module":"Mathlib.RingTheory.LocalProperties.Projective","initialProofState":"R : Type u_1\nM : Type uM\ninst✝¹² : CommRing R\ninst✝¹¹ : AddCommGroup M\ninst✝¹⁰ : Module R M\nRₛ : Type u_4\nMₛ : Type u_5\ninst✝⁹ : AddCommGroup Mₛ\ninst✝⁸ : Module R Mₛ\ninst✝⁷ : CommRing Rₛ\ninst✝⁶ : Algebra R Rₛ\ninst✝⁵ : Module Rₛ Mₛ\ninst✝⁴ : IsScalarTower R Rₛ Mₛ\nS : Submonoid R\nf : LinearMap (RingHom.id R) M Mₛ\ninst✝³ : IsLocalization S Rₛ\ninst✝² : IsLocalizedModule S f\ninst✝¹ : Module.Free R M\ninst✝ : Nontrivial Rₛ\n⊢ Eq (Module.finrank Rₛ Mₛ) (Module.finrank R M)","decl":"theorem Module.finrank_of_isLocalizedModule_of_free\n    (Rₛ : Type*) {Mₛ : Type*} [AddCommGroup Mₛ] [Module R Mₛ]\n    [CommRing Rₛ] [Algebra R Rₛ] [Module Rₛ Mₛ] [IsScalarTower R Rₛ Mₛ] (S : Submonoid R)\n    (f : M →ₗ[R] Mₛ) [IsLocalization S Rₛ] [IsLocalizedModule S f] [Module.Free R M]\n    [Nontrivial Rₛ] :\n    Module.finrank Rₛ Mₛ = Module.finrank R M := by\n  simpa using congr(Cardinal.toNat $(Module.lift_rank_of_isLocalizedModule_of_free Rₛ S f))\n\n"}
{"name":"Module.projective_of_isLocalizedModule","module":"Mathlib.RingTheory.LocalProperties.Projective","initialProofState":"R : Type u_1\nM : Type uM\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup M\ninst✝⁹ : Module R M\nRₛ : Type u_4\nMₛ : Type u_5\ninst✝⁸ : AddCommGroup Mₛ\ninst✝⁷ : Module R Mₛ\ninst✝⁶ : CommRing Rₛ\ninst✝⁵ : Algebra R Rₛ\ninst✝⁴ : Module Rₛ Mₛ\ninst✝³ : IsScalarTower R Rₛ Mₛ\nS : Submonoid R\nf : LinearMap (RingHom.id R) M Mₛ\ninst✝² : IsLocalization S Rₛ\ninst✝¹ : IsLocalizedModule S f\ninst✝ : Module.Projective R M\n⊢ Module.Projective Rₛ Mₛ","decl":"theorem Module.projective_of_isLocalizedModule {Rₛ Mₛ} [AddCommGroup Mₛ] [Module R Mₛ]\n    [CommRing Rₛ] [Algebra R Rₛ] [Module Rₛ Mₛ] [IsScalarTower R Rₛ Mₛ]\n    (S) (f : M →ₗ[R] Mₛ) [IsLocalization S Rₛ] [IsLocalizedModule S f] [Module.Projective R M] :\n    Module.Projective Rₛ Mₛ :=\n  Projective.of_equiv (IsLocalizedModule.isBaseChange S Rₛ f).equiv\n\n"}
{"name":"LinearMap.split_surjective_of_localization_maximal","module":"Mathlib.RingTheory.LocalProperties.Projective","initialProofState":"R : Type u_1\nN : Type u_2\nM : Type uM\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\nf : LinearMap (RingHom.id R) M N\ninst✝ : Module.FinitePresentation R N\nH : ∀ (I : Ideal R) (x : I.IsMaximal), Exists fun g => Eq (((LocalizedModule.map I.primeCompl) f).comp g) LinearMap.id\n⊢ Exists fun g => Eq (f.comp g) LinearMap.id","decl":"theorem LinearMap.split_surjective_of_localization_maximal\n    (f : M →ₗ[R] N) [Module.FinitePresentation R N]\n    (H : ∀ (I : Ideal R) (_ : I.IsMaximal),\n    ∃ (g : _ →ₗ[Localization.AtPrime I] _),\n      (LocalizedModule.map I.primeCompl f).comp g = LinearMap.id) :\n    ∃ (g : N →ₗ[R] M), f.comp g = LinearMap.id := by\n  show LinearMap.id ∈ LinearMap.range (LinearMap.llcomp R N M N f)\n  refine Submodule.mem_of_localization_maximal _ (fun P _ ↦ LocalizedModule.map P.primeCompl) _ _\n    fun I hI ↦ ?_\n  rw [LocalizedModule.map_id]\n  have : LinearMap.id ∈ LinearMap.range (LinearMap.llcomp _\n    (LocalizedModule I.primeCompl N) _ _ (LocalizedModule.map I.primeCompl f)) := H I hI\n  convert this\n  · ext f\n    constructor\n    · intro hf\n      obtain ⟨a, ha, c, rfl⟩ := hf\n      obtain ⟨g, rfl⟩ := ha\n      use IsLocalizedModule.mk' (LocalizedModule.map I.primeCompl) g c\n      apply ((Module.End_isUnit_iff _).mp <| IsLocalizedModule.map_units\n        (LocalizedModule.map I.primeCompl) c).injective\n      dsimp\n      conv_rhs => rw [← Submonoid.smul_def]\n      conv_lhs => rw [← LinearMap.map_smul_of_tower]\n      rw [← Submonoid.smul_def, IsLocalizedModule.mk'_cancel', IsLocalizedModule.mk'_cancel']\n      apply LinearMap.restrictScalars_injective R\n      apply IsLocalizedModule.ext I.primeCompl (LocalizedModule.mkLinearMap I.primeCompl N)\n      · exact IsLocalizedModule.map_units (LocalizedModule.mkLinearMap I.primeCompl N)\n      ext\n      simp only [LocalizedModule.map_mk, LinearMap.coe_comp, LinearMap.coe_restrictScalars,\n        Function.comp_apply, LocalizedModule.mkLinearMap_apply, LinearMap.llcomp_apply,\n        LocalizedModule.map_mk]\n    · rintro ⟨g, rfl⟩\n      obtain ⟨⟨g, s⟩, rfl⟩ :=\n        IsLocalizedModule.mk'_surjective I.primeCompl (LocalizedModule.map I.primeCompl) g\n      simp only [Function.uncurry_apply_pair, Submodule.restrictScalars_mem]\n      refine ⟨f.comp g, ⟨g, rfl⟩, s, ?_⟩\n      apply ((Module.End_isUnit_iff _).mp <| IsLocalizedModule.map_units\n         (LocalizedModule.map I.primeCompl) s).injective\n      simp only [Module.algebraMap_end_apply, ← Submonoid.smul_def, IsLocalizedModule.mk'_cancel',\n        ← LinearMap.map_smul_of_tower]\n      apply LinearMap.restrictScalars_injective R\n      apply IsLocalizedModule.ext I.primeCompl (LocalizedModule.mkLinearMap I.primeCompl N)\n      · exact IsLocalizedModule.map_units (LocalizedModule.mkLinearMap I.primeCompl N)\n      ext\n      simp only [coe_comp, coe_restrictScalars, Function.comp_apply,\n        LocalizedModule.mkLinearMap_apply, LocalizedModule.map_mk, llcomp_apply]\n\n"}
{"name":"Module.projective_of_localization_maximal","module":"Mathlib.RingTheory.LocalProperties.Projective","initialProofState":"R : Type u_1\nM : Type uM\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nH : ∀ (I : Ideal R) (x : I.IsMaximal), Module.Projective (Localization.AtPrime I) (LocalizedModule I.primeCompl M)\ninst✝ : Module.FinitePresentation R M\n⊢ Module.Projective R M","decl":"theorem Module.projective_of_localization_maximal (H : ∀ (I : Ideal R) (_ : I.IsMaximal),\n    Module.Projective (Localization.AtPrime I) (LocalizedModule I.primeCompl M))\n    [Module.FinitePresentation R M] : Module.Projective R M := by\n  have : Module.Finite R M := by infer_instance\n  have : (⊤ : Submodule R M).FG := this.fg_top\n  have : ∃ (s : Finset M), _ := this\n  obtain ⟨s, hs⟩ := this\n  let N := s →₀ R\n  let f : N →ₗ[R] M := Finsupp.linearCombination R (Subtype.val : s → M)\n  have hf : Function.Surjective f := by\n    rw [← LinearMap.range_eq_top, Finsupp.range_linearCombination, Subtype.range_val]\n    convert hs\n  have (I : Ideal R) (hI : I.IsMaximal) :=\n    letI := H I hI\n    Module.projective_lifting_property (LocalizedModule.map I.primeCompl f) LinearMap.id\n    (LocalizedModule.map_surjective _ _ hf)\n  obtain ⟨g, hg⟩ := LinearMap.split_surjective_of_localization_maximal _ this\n  exact Module.Projective.of_split _ _ hg\n\n"}
{"name":"Module.projective_of_localization_maximal'","module":"Mathlib.RingTheory.LocalProperties.Projective","initialProofState":"R : Type u_1\nM : Type uM\ninst✝¹⁰ : CommRing R\ninst✝⁹ : AddCommGroup M\ninst✝⁸ : Module R M\nRₚ : (P : Ideal R) → [inst : P.IsMaximal] → Type u_4\ninst✝⁷ : (P : Ideal R) → [inst : P.IsMaximal] → CommRing (Rₚ P)\ninst✝⁶ : (P : Ideal R) → [inst : P.IsMaximal] → Algebra R (Rₚ P)\ninst✝⁵ : ∀ (P : Ideal R) [inst : P.IsMaximal], IsLocalization.AtPrime (Rₚ P) P\nMₚ : (P : Ideal R) → [inst : P.IsMaximal] → Type u_5\ninst✝⁴ : (P : Ideal R) → [inst : P.IsMaximal] → AddCommGroup (Mₚ P)\ninst✝³ : (P : Ideal R) → [inst : P.IsMaximal] → Module R (Mₚ P)\ninst✝² : (P : Ideal R) → [inst : P.IsMaximal] → Module (Rₚ P) (Mₚ P)\ninst✝¹ : ∀ (P : Ideal R) [inst : P.IsMaximal], IsScalarTower R (Rₚ P) (Mₚ P)\nf : (P : Ideal R) → [inst : P.IsMaximal] → LinearMap (RingHom.id R) M (Mₚ P)\ninst : ∀ (P : Ideal R) [inst : P.IsMaximal], IsLocalizedModule P.primeCompl (f P)\nH : ∀ (I : Ideal R) (x : I.IsMaximal), Module.Projective (Rₚ I) (Mₚ I)\ninst✝ : Module.FinitePresentation R M\n⊢ Module.Projective R M","decl":"attribute [local instance] RingHomInvPair.of_ringEquiv in\ninclude f in\n/--\nA variant of `Module.projective_of_localization_maximal` that accepts `IsLocalizedModule`.\n-/\ntheorem Module.projective_of_localization_maximal'\n    (H : ∀ (I : Ideal R) (_ : I.IsMaximal), Module.Projective (Rₚ I) (Mₚ I))\n    [Module.FinitePresentation R M] : Module.Projective R M := by\n  apply Module.projective_of_localization_maximal\n  intros P hP\n  refine Module.Projective.of_ringEquiv (M := Mₚ P)\n    (IsLocalization.algEquiv P.primeCompl (Rₚ P) (Localization.AtPrime P)).toRingEquiv\n    { __ := IsLocalizedModule.linearEquiv P.primeCompl (f P)\n        (LocalizedModule.mkLinearMap P.primeCompl M)\n      map_smul' := ?_ }\n  · intros r m\n    obtain ⟨r, s, rfl⟩ := IsLocalization.mk'_surjective P.primeCompl r\n    apply ((Module.End_isUnit_iff _).mp\n      (IsLocalizedModule.map_units (LocalizedModule.mkLinearMap P.primeCompl M) s)).1\n    dsimp\n    simp only [← map_smul, ← smul_assoc, IsLocalization.smul_mk'_self, algebraMap_smul,\n      IsLocalization.map_id_mk']\n"}
