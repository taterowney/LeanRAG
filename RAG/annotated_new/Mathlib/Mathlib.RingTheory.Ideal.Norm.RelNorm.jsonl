{"name":"Ideal.spanNorm_bot","module":"Mathlib.RingTheory.Ideal.Norm.RelNorm","initialProofState":"R : Type u_1\ninst✝⁹ : CommRing R\ninst✝⁸ : IsDomain R\nS : Type u_3\ninst✝⁷ : CommRing S\ninst✝⁶ : IsDomain S\ninst✝⁵ : IsIntegrallyClosed R\ninst✝⁴ : IsIntegrallyClosed S\ninst✝³ : Algebra R S\ninst✝² : Module.Finite R S\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : Algebra.IsSeparable (FractionRing R) (FractionRing S)\n⊢ Eq (Ideal.spanNorm R Bot.bot) Bot.bot","decl":"@[simp]\ntheorem spanNorm_bot :\n    spanNorm R (⊥ : Ideal S) = ⊥ := span_eq_bot.mpr fun x hx => by simpa using hx\n\n"}
{"name":"Ideal.spanNorm_eq_bot_iff","module":"Mathlib.RingTheory.Ideal.Norm.RelNorm","initialProofState":"R : Type u_1\ninst✝⁹ : CommRing R\ninst✝⁸ : IsDomain R\nS : Type u_3\ninst✝⁷ : CommRing S\ninst✝⁶ : IsDomain S\ninst✝⁵ : IsIntegrallyClosed R\ninst✝⁴ : IsIntegrallyClosed S\ninst✝³ : Algebra R S\ninst✝² : Module.Finite R S\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : Algebra.IsSeparable (FractionRing R) (FractionRing S)\nI : Ideal S\n⊢ Iff (Eq (Ideal.spanNorm R I) Bot.bot) (Eq I Bot.bot)","decl":"@[simp]\ntheorem spanNorm_eq_bot_iff {I : Ideal S} : spanNorm R I = ⊥ ↔ I = ⊥ := by\n  simp only [spanNorm, span_eq_bot, Set.mem_image, SetLike.mem_coe, forall_exists_index, and_imp,\n    forall_apply_eq_imp_iff₂, Algebra.intNorm_eq_zero, @eq_bot_iff _ _ _ I, SetLike.le_def, map]\n  rfl\n\n"}
{"name":"Ideal.intNorm_mem_spanNorm","module":"Mathlib.RingTheory.Ideal.Norm.RelNorm","initialProofState":"R : Type u_1\ninst✝⁹ : CommRing R\ninst✝⁸ : IsDomain R\nS : Type u_3\ninst✝⁷ : CommRing S\ninst✝⁶ : IsDomain S\ninst✝⁵ : IsIntegrallyClosed R\ninst✝⁴ : IsIntegrallyClosed S\ninst✝³ : Algebra R S\ninst✝² : Module.Finite R S\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : Algebra.IsSeparable (FractionRing R) (FractionRing S)\nI : Ideal S\nx : S\nhx : Membership.mem I x\n⊢ Membership.mem (Ideal.spanNorm R I) ((Algebra.intNorm R S) x)","decl":"theorem intNorm_mem_spanNorm {I : Ideal S} {x : S} (hx : x ∈ I) :\n    Algebra.intNorm R S x ∈ I.spanNorm R :=\n  subset_span (Set.mem_image_of_mem _ hx)\n\n"}
{"name":"Ideal.norm_mem_spanNorm","module":"Mathlib.RingTheory.Ideal.Norm.RelNorm","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommRing R\ninst✝⁹ : IsDomain R\nS : Type u_3\ninst✝⁸ : CommRing S\ninst✝⁷ : IsDomain S\ninst✝⁶ : IsIntegrallyClosed R\ninst✝⁵ : IsIntegrallyClosed S\ninst✝⁴ : Algebra R S\ninst✝³ : Module.Finite R S\ninst✝² : NoZeroSMulDivisors R S\ninst✝¹ : Algebra.IsSeparable (FractionRing R) (FractionRing S)\ninst✝ : Module.Free R S\nI : Ideal S\nx : S\nhx : Membership.mem I x\n⊢ Membership.mem (Ideal.spanNorm R I) ((Algebra.norm R) x)","decl":"theorem norm_mem_spanNorm [Module.Free R S] {I : Ideal S} (x : S) (hx : x ∈ I) :\n    Algebra.norm R x ∈ I.spanNorm R := by\n  refine subset_span ⟨x, hx, ?_⟩\n  rw [Algebra.intNorm_eq_norm]\n\n"}
{"name":"Ideal.spanNorm_singleton","module":"Mathlib.RingTheory.Ideal.Norm.RelNorm","initialProofState":"R : Type u_1\ninst✝⁹ : CommRing R\ninst✝⁸ : IsDomain R\nS : Type u_3\ninst✝⁷ : CommRing S\ninst✝⁶ : IsDomain S\ninst✝⁵ : IsIntegrallyClosed R\ninst✝⁴ : IsIntegrallyClosed S\ninst✝³ : Algebra R S\ninst✝² : Module.Finite R S\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : Algebra.IsSeparable (FractionRing R) (FractionRing S)\nr : S\n⊢ Eq (Ideal.spanNorm R (Ideal.span (Singleton.singleton r))) (Ideal.span (Singleton.singleton ((Algebra.intNorm R S) r)))","decl":"@[simp]\ntheorem spanNorm_singleton {r : S} :\n    spanNorm R (span ({r} : Set S)) = span {Algebra.intNorm R S r} :=\n  le_antisymm\n    (span_le.mpr fun x hx =>\n      mem_span_singleton.mpr\n        (by\n          obtain ⟨x, hx', rfl⟩ := (Set.mem_image _ _ _).mp hx\n          exact map_dvd _ (mem_span_singleton.mp hx')))\n    ((span_singleton_le_iff_mem _).mpr (intNorm_mem_spanNorm _ (mem_span_singleton_self _)))\n\n"}
{"name":"Ideal.spanNorm_top","module":"Mathlib.RingTheory.Ideal.Norm.RelNorm","initialProofState":"R : Type u_1\ninst✝⁹ : CommRing R\ninst✝⁸ : IsDomain R\nS : Type u_3\ninst✝⁷ : CommRing S\ninst✝⁶ : IsDomain S\ninst✝⁵ : IsIntegrallyClosed R\ninst✝⁴ : IsIntegrallyClosed S\ninst✝³ : Algebra R S\ninst✝² : Module.Finite R S\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : Algebra.IsSeparable (FractionRing R) (FractionRing S)\n⊢ Eq (Ideal.spanNorm R Top.top) Top.top","decl":"@[simp]\ntheorem spanNorm_top : spanNorm R (⊤ : Ideal S) = ⊤ := by\n  simp [← Ideal.span_singleton_one]\n\n"}
{"name":"Ideal.map_spanIntNorm","module":"Mathlib.RingTheory.Ideal.Norm.RelNorm","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommRing R\ninst✝⁹ : IsDomain R\nS : Type u_3\ninst✝⁸ : CommRing S\ninst✝⁷ : IsDomain S\ninst✝⁶ : IsIntegrallyClosed R\ninst✝⁵ : IsIntegrallyClosed S\ninst✝⁴ : Algebra R S\ninst✝³ : Module.Finite R S\ninst✝² : NoZeroSMulDivisors R S\ninst✝¹ : Algebra.IsSeparable (FractionRing R) (FractionRing S)\nI : Ideal S\nT : Type u_4\ninst✝ : CommRing T\nf : RingHom R T\n⊢ Eq (Ideal.map f (Ideal.spanNorm R I)) (Ideal.span (Set.image (Function.comp ⇑f ⇑(Algebra.intNorm R S)) ↑I))","decl":"theorem map_spanIntNorm (I : Ideal S) {T : Type*} [CommRing T] (f : R →+* T) :\n    map f (spanNorm R I) = span (f ∘ Algebra.intNorm R S '' (I : Set S)) := by\n  rw [spanNorm]\n  nth_rw 2 [map]\n  simp [map_span, Set.image_image]\n\n"}
{"name":"Ideal.spanNorm_mono","module":"Mathlib.RingTheory.Ideal.Norm.RelNorm","initialProofState":"R : Type u_1\ninst✝⁹ : CommRing R\ninst✝⁸ : IsDomain R\nS : Type u_3\ninst✝⁷ : CommRing S\ninst✝⁶ : IsDomain S\ninst✝⁵ : IsIntegrallyClosed R\ninst✝⁴ : IsIntegrallyClosed S\ninst✝³ : Algebra R S\ninst✝² : Module.Finite R S\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : Algebra.IsSeparable (FractionRing R) (FractionRing S)\nI J : Ideal S\nh : LE.le I J\n⊢ LE.le (Ideal.spanNorm R I) (Ideal.spanNorm R J)","decl":"@[mono]\ntheorem spanNorm_mono {I J : Ideal S} (h : I ≤ J) : spanNorm R I ≤ spanNorm R J :=\n  Ideal.span_mono (Set.monotone_image h)\n\n"}
{"name":"Ideal.spanIntNorm_localization","module":"Mathlib.RingTheory.Ideal.Norm.RelNorm","initialProofState":"R : Type u_1\ninst✝²⁶ : CommRing R\ninst✝²⁵ : IsDomain R\nS : Type u_3\ninst✝²⁴ : CommRing S\ninst✝²³ : IsDomain S\ninst✝²² : IsIntegrallyClosed R\ninst✝²¹ : IsIntegrallyClosed S\ninst✝²⁰ : Algebra R S\ninst✝¹⁹ : Module.Finite R S\ninst✝¹⁸ : NoZeroSMulDivisors R S\ninst✝¹⁷ : Algebra.IsSeparable (FractionRing R) (FractionRing S)\nI : Ideal S\nM : Submonoid R\nhM : LE.le M (nonZeroDivisors R)\nRₘ : Type u_4\nSₘ : Type u_5\ninst✝¹⁶ : CommRing Rₘ\ninst✝¹⁵ : Algebra R Rₘ\ninst✝¹⁴ : CommRing Sₘ\ninst✝¹³ : Algebra S Sₘ\ninst✝¹² : Algebra Rₘ Sₘ\ninst✝¹¹ : Algebra R Sₘ\ninst✝¹⁰ : IsScalarTower R Rₘ Sₘ\ninst✝⁹ : IsScalarTower R S Sₘ\ninst✝⁸ : IsLocalization M Rₘ\ninst✝⁷ : IsLocalization (Algebra.algebraMapSubmonoid S M) Sₘ\ninst✝⁶ : IsIntegrallyClosed Rₘ\ninst✝⁵ : IsDomain Rₘ\ninst✝⁴ : IsDomain Sₘ\ninst✝³ : NoZeroSMulDivisors Rₘ Sₘ\ninst✝² : Module.Finite Rₘ Sₘ\ninst✝¹ : IsIntegrallyClosed Sₘ\ninst✝ : Algebra.IsSeparable (FractionRing Rₘ) (FractionRing Sₘ)\n⊢ Eq (Ideal.spanNorm Rₘ (Ideal.map (algebraMap S Sₘ) I)) (Ideal.map (algebraMap R Rₘ) (Ideal.spanNorm R I))","decl":"theorem spanIntNorm_localization (I : Ideal S) (M : Submonoid R) (hM : M ≤ R⁰)\n    {Rₘ : Type*} (Sₘ : Type*) [CommRing Rₘ] [Algebra R Rₘ] [CommRing Sₘ] [Algebra S Sₘ]\n    [Algebra Rₘ Sₘ] [Algebra R Sₘ] [IsScalarTower R Rₘ Sₘ] [IsScalarTower R S Sₘ]\n    [IsLocalization M Rₘ] [IsLocalization (Algebra.algebraMapSubmonoid S M) Sₘ]\n    [IsIntegrallyClosed Rₘ] [IsDomain Rₘ] [IsDomain Sₘ] [NoZeroSMulDivisors Rₘ Sₘ]\n    [Module.Finite Rₘ Sₘ] [IsIntegrallyClosed Sₘ]\n    [Algebra.IsSeparable (FractionRing Rₘ) (FractionRing Sₘ)] :\n    spanNorm Rₘ (I.map (algebraMap S Sₘ)) = (spanNorm R I).map (algebraMap R Rₘ) := by\n  let K := FractionRing R\n  let f : Rₘ →+* K := IsLocalization.map _ (T := R⁰) (RingHom.id R) hM\n  let L := FractionRing S\n  let g : Sₘ →+* L := IsLocalization.map _ (M := Algebra.algebraMapSubmonoid S M) (T := S⁰)\n      (RingHom.id S) (Submonoid.map_le_of_le_comap _ <| hM.trans\n      (nonZeroDivisors_le_comap_nonZeroDivisors_of_injective _\n        (NoZeroSMulDivisors.algebraMap_injective _ _)))\n  algebraize [f, g, (algebraMap K L).comp f]\n  have : IsScalarTower R Rₘ K := IsScalarTower.of_algebraMap_eq'\n    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, RingHomCompTriple.comp_eq])\n  let _ := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization M Rₘ K\n  have : IsScalarTower S Sₘ L := IsScalarTower.of_algebraMap_eq'\n    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, RingHomCompTriple.comp_eq])\n  have : IsScalarTower Rₘ Sₘ L := by\n    apply IsScalarTower.of_algebraMap_eq'\n    apply IsLocalization.ringHom_ext M\n    rw [RingHom.algebraMap_toAlgebra, RingHom.algebraMap_toAlgebra (R := Sₘ), RingHom.comp_assoc,\n      RingHom.comp_assoc, ← IsScalarTower.algebraMap_eq, IsScalarTower.algebraMap_eq R S Sₘ,\n      IsLocalization.map_comp, RingHom.comp_id, ← RingHom.comp_assoc, IsLocalization.map_comp,\n      RingHom.comp_id, ← IsScalarTower.algebraMap_eq, ← IsScalarTower.algebraMap_eq]\n  let _ := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization\n    (Algebra.algebraMapSubmonoid S M) Sₘ L\n  have : IsIntegralClosure Sₘ Rₘ L :=\n    IsIntegralClosure.of_isIntegrallyClosed _ _ _\n  rw [map_spanIntNorm]\n  refine span_eq_span (Set.image_subset_iff.mpr ?_) (Set.image_subset_iff.mpr ?_)\n  · intro a' ha'\n    simp only [Set.mem_preimage, submodule_span_eq, ← map_spanIntNorm, SetLike.mem_coe,\n      IsLocalization.mem_map_algebraMap_iff (Algebra.algebraMapSubmonoid S M) Sₘ,\n      IsLocalization.mem_map_algebraMap_iff M Rₘ, Prod.exists] at ha' ⊢\n    obtain ⟨⟨a, ha⟩, ⟨_, ⟨s, hs, rfl⟩⟩, has⟩ := ha'\n    refine ⟨⟨Algebra.intNorm R S a, intNorm_mem_spanNorm _ ha⟩,\n      ⟨s ^ Module.finrank K L, pow_mem hs _⟩, ?_⟩\n    simp only [Submodule.coe_mk, Subtype.coe_mk, map_pow] at has ⊢\n    apply_fun algebraMap _ L at has\n    apply_fun Algebra.norm K at has\n    simp only [_root_.map_mul, IsScalarTower.algebraMap_apply R Rₘ Sₘ] at has\n    rw [← IsScalarTower.algebraMap_apply, ← IsScalarTower.algebraMap_apply,\n      ← IsScalarTower.algebraMap_apply,\n      IsScalarTower.algebraMap_apply R K L,\n      Algebra.norm_algebraMap] at has\n    apply IsFractionRing.injective Rₘ K\n    simp only [_root_.map_mul, map_pow]\n    have : FiniteDimensional K L := Module.Finite_of_isLocalization R S _ _ R⁰\n    rwa [Algebra.algebraMap_intNorm (L := L), ← IsScalarTower.algebraMap_apply,\n      ← IsScalarTower.algebraMap_apply, Algebra.algebraMap_intNorm (L := L)]\n  · intro a ha\n    rw [Set.mem_preimage, Function.comp_apply, Algebra.intNorm_eq_of_isLocalization\n      (A := R) (B := S) M (Aₘ := Rₘ) (Bₘ := Sₘ)]\n    exact subset_span (Set.mem_image_of_mem _ (mem_map_of_mem _ ha))\n\n"}
{"name":"Ideal.spanNorm_mul_spanNorm_le","module":"Mathlib.RingTheory.Ideal.Norm.RelNorm","initialProofState":"R : Type u_1\ninst✝⁹ : CommRing R\ninst✝⁸ : IsDomain R\nS : Type u_3\ninst✝⁷ : CommRing S\ninst✝⁶ : IsDomain S\ninst✝⁵ : IsIntegrallyClosed R\ninst✝⁴ : IsIntegrallyClosed S\ninst✝³ : Algebra R S\ninst✝² : Module.Finite R S\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : Algebra.IsSeparable (FractionRing R) (FractionRing S)\nI J : Ideal S\n⊢ LE.le (HMul.hMul (Ideal.spanNorm R I) (Ideal.spanNorm R J)) (Ideal.spanNorm R (HMul.hMul I J))","decl":"theorem spanNorm_mul_spanNorm_le (I J : Ideal S) :\n    spanNorm R I * spanNorm R J ≤ spanNorm R (I * J) := by\n  rw [spanNorm, spanNorm, spanNorm]\n  nth_rw 1 [map]; nth_rw 1 [map]\n  rw [Ideal.span_mul_span', ← Set.image_mul]\n  refine Ideal.span_mono (Set.monotone_image ?_)\n  rintro _ ⟨x, hxI, y, hyJ, rfl⟩\n  exact Ideal.mul_mem_mul hxI hyJ\n\n"}
{"name":"Ideal.spanNorm_mul_of_bot_or_top","module":"Mathlib.RingTheory.Ideal.Norm.RelNorm","initialProofState":"R : Type u_1\ninst✝⁹ : CommRing R\ninst✝⁸ : IsDomain R\nS : Type u_3\ninst✝⁷ : CommRing S\ninst✝⁶ : IsDomain S\ninst✝⁵ : IsIntegrallyClosed R\ninst✝⁴ : IsIntegrallyClosed S\ninst✝³ : Algebra R S\ninst✝² : Module.Finite R S\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : Algebra.IsSeparable (FractionRing R) (FractionRing S)\neq_bot_or_top : ∀ (I : Ideal R), Or (Eq I Bot.bot) (Eq I Top.top)\nI J : Ideal S\n⊢ Eq (Ideal.spanNorm R (HMul.hMul I J)) (HMul.hMul (Ideal.spanNorm R I) (Ideal.spanNorm R J))","decl":"/-- This condition `eq_bot_or_top` is equivalent to being a field.\nHowever, `Ideal.spanNorm_mul_of_field` is harder to apply since we'd need to upgrade a `CommRing R`\ninstance to a `Field R` instance. -/\ntheorem spanNorm_mul_of_bot_or_top (eq_bot_or_top : ∀ I : Ideal R, I = ⊥ ∨ I = ⊤) (I J : Ideal S) :\n    spanNorm R (I * J) = spanNorm R I * spanNorm R J := by\n  refine le_antisymm ?_ (spanNorm_mul_spanNorm_le R _ _)\n  rcases eq_bot_or_top (spanNorm R I) with hI | hI\n  · rw [hI, spanNorm_eq_bot_iff.mp hI, bot_mul, spanNorm_bot]\n    exact bot_le\n  rw [hI, Ideal.top_mul]\n  rcases eq_bot_or_top (spanNorm R J) with hJ | hJ\n  · rw [hJ, spanNorm_eq_bot_iff.mp hJ, mul_bot, spanNorm_bot]\n  rw [hJ]\n  exact le_top\n\n"}
{"name":"Ideal.spanNorm_mul","module":"Mathlib.RingTheory.Ideal.Norm.RelNorm","initialProofState":"R : Type u_1\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : IsDomain R\nS : Type u_3\ninst✝⁹ : CommRing S\ninst✝⁸ : IsDomain S\ninst✝⁷ : IsIntegrallyClosed R\ninst✝⁶ : IsIntegrallyClosed S\ninst✝⁵ : Algebra R S\ninst✝⁴ : Module.Finite R S\ninst✝³ : NoZeroSMulDivisors R S\ninst✝² : Algebra.IsSeparable (FractionRing R) (FractionRing S)\ninst✝¹ : IsDedekindDomain R\ninst✝ : IsDedekindDomain S\nI J : Ideal S\n⊢ Eq (Ideal.spanNorm R (HMul.hMul I J)) (HMul.hMul (Ideal.spanNorm R I) (Ideal.spanNorm R J))","decl":"/-- Multiplicativity of `Ideal.spanNorm`. simp-normal form is `map_mul (Ideal.relNorm R)`. -/\ntheorem spanNorm_mul (I J : Ideal S) : spanNorm R (I * J) = spanNorm R I * spanNorm R J := by\n  nontriviality R\n  cases subsingleton_or_nontrivial S\n  · have : ∀ I : Ideal S, I = ⊤ := fun I ↦ Subsingleton.elim I ⊤\n    simp [this I, this J, this (I * J)]\n  refine eq_of_localization_maximal (fun P hP ↦ ?_)\n  by_cases hP0 : P = ⊥\n  · subst hP0\n    rw [spanNorm_mul_of_bot_or_top]\n    intro I\n    exact or_iff_not_imp_right.mpr fun hI ↦ (hP.eq_of_le hI bot_le).symm\n  let P' := Algebra.algebraMapSubmonoid S P.primeCompl\n  let Rₚ := Localization.AtPrime P\n  let Sₚ := Localization P'\n  let _ : Algebra Rₚ Sₚ := localizationAlgebra P.primeCompl S\n  have : IsScalarTower R Rₚ Sₚ :=\n    IsScalarTower.of_algebraMap_eq (fun x =>\n      (IsLocalization.map_eq (T := P') (Q := Localization P') P.primeCompl.le_comap_map x).symm)\n  have h : P' ≤ S⁰ :=\n    map_le_nonZeroDivisors_of_injective _ (NoZeroSMulDivisors.algebraMap_injective _ _)\n      P.primeCompl_le_nonZeroDivisors\n  have : IsDomain Sₚ := IsLocalization.isDomain_localization h\n  have : IsDedekindDomain Sₚ := IsLocalization.isDedekindDomain S h _\n  have : IsPrincipalIdealRing Sₚ :=\n    IsDedekindDomain.isPrincipalIdealRing_localization_over_prime S P hP0\n  have := NoZeroSMulDivisors_of_isLocalization R S Rₚ Sₚ P.primeCompl_le_nonZeroDivisors\n  have := Module.Finite_of_isLocalization R S Rₚ Sₚ P.primeCompl\n  let L := FractionRing S\n  let g : Sₚ →+* L := IsLocalization.map _ (M := P') (T := S⁰) (RingHom.id S) h\n  algebraize [g]\n  have : IsScalarTower S Sₚ (FractionRing S) := IsScalarTower.of_algebraMap_eq'\n    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, RingHom.comp_id])\n  have := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization P' Sₚ (FractionRing S)\n  have : Algebra.IsSeparable (FractionRing Rₚ) (FractionRing Sₚ) := by\n    apply Algebra.IsSeparable.of_equiv_equiv\n      (FractionRing.algEquiv Rₚ (FractionRing R)).symm.toRingEquiv\n      (FractionRing.algEquiv Sₚ (FractionRing S)).symm.toRingEquiv\n    apply IsLocalization.ringHom_ext R⁰\n    ext\n    simp only [AlgEquiv.toRingEquiv_eq_coe, RingHom.coe_comp,\n      RingHom.coe_coe, Function.comp_apply, ← IsScalarTower.algebraMap_apply]\n    rw [IsScalarTower.algebraMap_apply R Rₚ (FractionRing R), AlgEquiv.coe_ringEquiv,\n      AlgEquiv.commutes, IsScalarTower.algebraMap_apply R S L,\n      IsScalarTower.algebraMap_apply S Sₚ L, AlgEquiv.coe_ringEquiv, AlgEquiv.commutes]\n    simp only [← IsScalarTower.algebraMap_apply]\n    rw [IsScalarTower.algebraMap_apply R Rₚ (FractionRing Rₚ),\n      ← IsScalarTower.algebraMap_apply Rₚ, ← IsScalarTower.algebraMap_apply]\n  simp only [Ideal.map_mul, ← spanIntNorm_localization (R := R) (S := S)\n    (Rₘ := Localization.AtPrime P) (Sₘ := Localization P') _ _ P.primeCompl_le_nonZeroDivisors]\n  rw [← (I.map _).span_singleton_generator, ← (J.map _).span_singleton_generator,\n    span_singleton_mul_span_singleton, spanNorm_singleton, spanNorm_singleton,\n      spanNorm_singleton, span_singleton_mul_span_singleton, _root_.map_mul]\n\n"}
{"name":"Ideal.relNorm_apply","module":"Mathlib.RingTheory.Ideal.Norm.RelNorm","initialProofState":"R : Type u_1\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : IsDomain R\nS : Type u_3\ninst✝⁹ : CommRing S\ninst✝⁸ : IsDomain S\ninst✝⁷ : IsIntegrallyClosed R\ninst✝⁶ : IsIntegrallyClosed S\ninst✝⁵ : Algebra R S\ninst✝⁴ : Module.Finite R S\ninst✝³ : NoZeroSMulDivisors R S\ninst✝² : Algebra.IsSeparable (FractionRing R) (FractionRing S)\ninst✝¹ : IsDedekindDomain R\ninst✝ : IsDedekindDomain S\nI : Ideal S\n⊢ Eq ((Ideal.relNorm R) I) (Ideal.span (Set.image ⇑(Algebra.intNorm R S) ↑I))","decl":"theorem relNorm_apply (I : Ideal S) :\n    relNorm R I = span (Algebra.intNorm R S '' (I : Set S) : Set R) :=\n  rfl\n\n"}
{"name":"Ideal.spanNorm_eq","module":"Mathlib.RingTheory.Ideal.Norm.RelNorm","initialProofState":"R : Type u_1\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : IsDomain R\nS : Type u_3\ninst✝⁹ : CommRing S\ninst✝⁸ : IsDomain S\ninst✝⁷ : IsIntegrallyClosed R\ninst✝⁶ : IsIntegrallyClosed S\ninst✝⁵ : Algebra R S\ninst✝⁴ : Module.Finite R S\ninst✝³ : NoZeroSMulDivisors R S\ninst✝² : Algebra.IsSeparable (FractionRing R) (FractionRing S)\ninst✝¹ : IsDedekindDomain R\ninst✝ : IsDedekindDomain S\nI : Ideal S\n⊢ Eq (Ideal.spanNorm R I) ((Ideal.relNorm R) I)","decl":"@[simp]\ntheorem spanNorm_eq (I : Ideal S) : spanNorm R I = relNorm R I := rfl\n\n"}
{"name":"Ideal.relNorm_bot","module":"Mathlib.RingTheory.Ideal.Norm.RelNorm","initialProofState":"R : Type u_1\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : IsDomain R\nS : Type u_3\ninst✝⁹ : CommRing S\ninst✝⁸ : IsDomain S\ninst✝⁷ : IsIntegrallyClosed R\ninst✝⁶ : IsIntegrallyClosed S\ninst✝⁵ : Algebra R S\ninst✝⁴ : Module.Finite R S\ninst✝³ : NoZeroSMulDivisors R S\ninst✝² : Algebra.IsSeparable (FractionRing R) (FractionRing S)\ninst✝¹ : IsDedekindDomain R\ninst✝ : IsDedekindDomain S\n⊢ Eq ((Ideal.relNorm R) Bot.bot) Bot.bot","decl":"@[simp]\ntheorem relNorm_bot : relNorm R (⊥ : Ideal S) = ⊥ := by\n  simpa only [zero_eq_bot] using map_zero (relNorm R : Ideal S →*₀ _)\n\n"}
{"name":"Ideal.relNorm_top","module":"Mathlib.RingTheory.Ideal.Norm.RelNorm","initialProofState":"R : Type u_1\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : IsDomain R\nS : Type u_3\ninst✝⁹ : CommRing S\ninst✝⁸ : IsDomain S\ninst✝⁷ : IsIntegrallyClosed R\ninst✝⁶ : IsIntegrallyClosed S\ninst✝⁵ : Algebra R S\ninst✝⁴ : Module.Finite R S\ninst✝³ : NoZeroSMulDivisors R S\ninst✝² : Algebra.IsSeparable (FractionRing R) (FractionRing S)\ninst✝¹ : IsDedekindDomain R\ninst✝ : IsDedekindDomain S\n⊢ Eq ((Ideal.relNorm R) Top.top) Top.top","decl":"@[simp]\ntheorem relNorm_top : relNorm R (⊤ : Ideal S) = ⊤ := by\n  simpa only [one_eq_top] using map_one (relNorm R : Ideal S →*₀ _)\n\n"}
{"name":"Ideal.relNorm_eq_bot_iff","module":"Mathlib.RingTheory.Ideal.Norm.RelNorm","initialProofState":"R : Type u_1\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : IsDomain R\nS : Type u_3\ninst✝⁹ : CommRing S\ninst✝⁸ : IsDomain S\ninst✝⁷ : IsIntegrallyClosed R\ninst✝⁶ : IsIntegrallyClosed S\ninst✝⁵ : Algebra R S\ninst✝⁴ : Module.Finite R S\ninst✝³ : NoZeroSMulDivisors R S\ninst✝² : Algebra.IsSeparable (FractionRing R) (FractionRing S)\ninst✝¹ : IsDedekindDomain R\ninst✝ : IsDedekindDomain S\nI : Ideal S\n⊢ Iff (Eq ((Ideal.relNorm R) I) Bot.bot) (Eq I Bot.bot)","decl":"@[simp]\ntheorem relNorm_eq_bot_iff {I : Ideal S} : relNorm R I = ⊥ ↔ I = ⊥ :=\n  spanNorm_eq_bot_iff\n\n"}
{"name":"Ideal.norm_mem_relNorm","module":"Mathlib.RingTheory.Ideal.Norm.RelNorm","initialProofState":"R : Type u_1\ninst✝¹² : CommRing R\ninst✝¹¹ : IsDomain R\nS : Type u_3\ninst✝¹⁰ : CommRing S\ninst✝⁹ : IsDomain S\ninst✝⁸ : IsIntegrallyClosed R\ninst✝⁷ : IsIntegrallyClosed S\ninst✝⁶ : Algebra R S\ninst✝⁵ : Module.Finite R S\ninst✝⁴ : NoZeroSMulDivisors R S\ninst✝³ : Algebra.IsSeparable (FractionRing R) (FractionRing S)\ninst✝² : IsDedekindDomain R\ninst✝¹ : IsDedekindDomain S\ninst✝ : Module.Free R S\nI : Ideal S\nx : S\nhx : Membership.mem I x\n⊢ Membership.mem ((Ideal.relNorm R) I) ((Algebra.norm R) x)","decl":"theorem norm_mem_relNorm [Module.Free R S] (I : Ideal S) {x : S} (hx : x ∈ I) :\n    Algebra.norm R x ∈ relNorm R I :=\n  norm_mem_spanNorm R x hx\n\n"}
{"name":"Ideal.relNorm_singleton","module":"Mathlib.RingTheory.Ideal.Norm.RelNorm","initialProofState":"R : Type u_1\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : IsDomain R\nS : Type u_3\ninst✝⁹ : CommRing S\ninst✝⁸ : IsDomain S\ninst✝⁷ : IsIntegrallyClosed R\ninst✝⁶ : IsIntegrallyClosed S\ninst✝⁵ : Algebra R S\ninst✝⁴ : Module.Finite R S\ninst✝³ : NoZeroSMulDivisors R S\ninst✝² : Algebra.IsSeparable (FractionRing R) (FractionRing S)\ninst✝¹ : IsDedekindDomain R\ninst✝ : IsDedekindDomain S\nr : S\n⊢ Eq ((Ideal.relNorm R) (Ideal.span (Singleton.singleton r))) (Ideal.span (Singleton.singleton ((Algebra.intNorm R S) r)))","decl":"@[simp]\ntheorem relNorm_singleton (r : S) : relNorm R (span ({r} : Set S)) = span {Algebra.intNorm R S r} :=\n  spanNorm_singleton R\n\n"}
{"name":"Ideal.map_relNorm","module":"Mathlib.RingTheory.Ideal.Norm.RelNorm","initialProofState":"R : Type u_1\ninst✝¹² : CommRing R\ninst✝¹¹ : IsDomain R\nS : Type u_3\ninst✝¹⁰ : CommRing S\ninst✝⁹ : IsDomain S\ninst✝⁸ : IsIntegrallyClosed R\ninst✝⁷ : IsIntegrallyClosed S\ninst✝⁶ : Algebra R S\ninst✝⁵ : Module.Finite R S\ninst✝⁴ : NoZeroSMulDivisors R S\ninst✝³ : Algebra.IsSeparable (FractionRing R) (FractionRing S)\ninst✝² : IsDedekindDomain R\ninst✝¹ : IsDedekindDomain S\nI : Ideal S\nT : Type u_4\ninst✝ : CommRing T\nf : RingHom R T\n⊢ Eq (Ideal.map f ((Ideal.relNorm R) I)) (Ideal.span (Set.image (Function.comp ⇑f ⇑(Algebra.intNorm R S)) ↑I))","decl":"theorem map_relNorm (I : Ideal S) {T : Type*} [CommRing T] (f : R →+* T) :\n    map f (relNorm R I) = span (f ∘ Algebra.intNorm R S '' (I : Set S)) :=\n  map_spanIntNorm R I f\n\n"}
{"name":"Ideal.relNorm_mono","module":"Mathlib.RingTheory.Ideal.Norm.RelNorm","initialProofState":"R : Type u_1\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : IsDomain R\nS : Type u_3\ninst✝⁹ : CommRing S\ninst✝⁸ : IsDomain S\ninst✝⁷ : IsIntegrallyClosed R\ninst✝⁶ : IsIntegrallyClosed S\ninst✝⁵ : Algebra R S\ninst✝⁴ : Module.Finite R S\ninst✝³ : NoZeroSMulDivisors R S\ninst✝² : Algebra.IsSeparable (FractionRing R) (FractionRing S)\ninst✝¹ : IsDedekindDomain R\ninst✝ : IsDedekindDomain S\nI J : Ideal S\nh : LE.le I J\n⊢ LE.le ((Ideal.relNorm R) I) ((Ideal.relNorm R) J)","decl":"@[mono]\ntheorem relNorm_mono {I J : Ideal S} (h : I ≤ J) : relNorm R I ≤ relNorm R J :=\n  spanNorm_mono R h\n\n"}
