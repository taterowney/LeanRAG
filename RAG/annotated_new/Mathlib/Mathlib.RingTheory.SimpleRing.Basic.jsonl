{"name":"IsSimpleRing.instIsSimpleOrderTwoSidedIdeal","module":"Mathlib.RingTheory.SimpleRing.Basic","initialProofState":"R : Type u_1\ninst✝¹ : NonUnitalNonAssocRing R\ninst✝ : IsSimpleRing R\n⊢ IsSimpleOrder (TwoSidedIdeal R)","decl":"instance [IsSimpleRing R] : IsSimpleOrder (TwoSidedIdeal R) := IsSimpleRing.simple\n\n"}
{"name":"IsSimpleRing.instNontrivial","module":"Mathlib.RingTheory.SimpleRing.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nsimple : IsSimpleRing R\n⊢ Nontrivial R","decl":"instance [simple : IsSimpleRing R] : Nontrivial R := by\n  obtain ⟨x, hx⟩ := SetLike.exists_of_lt (bot_lt_top : (⊥ : TwoSidedIdeal R) < ⊤)\n  have h (hx : x = 0) : False := by simp_all [TwoSidedIdeal.zero_mem]\n  use x, 0, h\n\n"}
{"name":"IsSimpleRing.one_mem_of_ne_bot","module":"Mathlib.RingTheory.SimpleRing.Basic","initialProofState":"A : Type u_2\ninst✝¹ : NonAssocRing A\ninst✝ : IsSimpleRing A\nI : TwoSidedIdeal A\nhI : Ne I Bot.bot\n⊢ Membership.mem I 1","decl":"lemma one_mem_of_ne_bot {A : Type*} [NonAssocRing A] [IsSimpleRing A] (I : TwoSidedIdeal A)\n    (hI : I ≠ ⊥) : (1 : A) ∈ I :=\n  (eq_bot_or_eq_top I).resolve_left hI ▸ ⟨⟩\n\n"}
{"name":"IsSimpleRing.one_mem_of_ne_zero_mem","module":"Mathlib.RingTheory.SimpleRing.Basic","initialProofState":"A : Type u_2\ninst✝¹ : NonAssocRing A\ninst✝ : IsSimpleRing A\nI : TwoSidedIdeal A\nx : A\nhx : Ne x 0\nhxI : Membership.mem I x\n⊢ Membership.mem I 1","decl":"lemma one_mem_of_ne_zero_mem {A : Type*} [NonAssocRing A] [IsSimpleRing A] (I : TwoSidedIdeal A)\n    {x : A} (hx : x ≠ 0) (hxI : x ∈ I) : (1 : A) ∈ I :=\n  one_mem_of_ne_bot I (by rintro rfl; exact hx hxI)\n\n"}
{"name":"IsSimpleRing.of_eq_bot_or_eq_top","module":"Mathlib.RingTheory.SimpleRing.Basic","initialProofState":"R : Type u_1\ninst✝¹ : NonUnitalNonAssocRing R\ninst✝ : Nontrivial R\nh : ∀ (I : TwoSidedIdeal R), Or (Eq I Bot.bot) (Eq I Top.top)\n⊢ IsSimpleRing R","decl":"lemma of_eq_bot_or_eq_top [Nontrivial R] (h : ∀ I : TwoSidedIdeal R, I = ⊥ ∨ I = ⊤) :\n    IsSimpleRing R where\n  simple := { eq_bot_or_eq_top := h }\n\n"}
{"name":"DivisionRing.isSimpleRing","module":"Mathlib.RingTheory.SimpleRing.Basic","initialProofState":"A : Type u_2\ninst✝ : DivisionRing A\n⊢ IsSimpleRing A","decl":"instance _root_.DivisionRing.isSimpleRing (A : Type*) [DivisionRing A] : IsSimpleRing A :=\n  .of_eq_bot_or_eq_top <| fun I ↦ by\n    rw [or_iff_not_imp_left, ← I.one_mem_iff]\n    intro H\n    obtain ⟨x, hx1, hx2 : x ≠ 0⟩ := SetLike.exists_of_lt (bot_lt_iff_ne_bot.mpr H : ⊥ < I)\n    simpa [inv_mul_cancel₀ hx2] using I.mul_mem_left x⁻¹ _ hx1\n\n"}
{"name":"IsSimpleRing.injective_ringHom_or_subsingleton_codomain","module":"Mathlib.RingTheory.SimpleRing.Basic","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝² : NonAssocRing R\ninst✝¹ : IsSimpleRing R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\n⊢ Or (Function.Injective ⇑f) (Subsingleton S)","decl":"lemma injective_ringHom_or_subsingleton_codomain\n    {R S : Type*} [NonAssocRing R] [IsSimpleRing R] [NonAssocSemiring S]\n    (f : R →+* S) : Function.Injective f ∨ Subsingleton S :=\n  simple.eq_bot_or_eq_top (TwoSidedIdeal.ker f) |>.imp (TwoSidedIdeal.ker_eq_bot _ |>.1)\n    (fun h => subsingleton_iff_zero_eq_one.1 <| by\n      have mem : 1 ∈ TwoSidedIdeal.ker f := h.symm ▸ TwoSidedIdeal.mem_top _\n      rwa [TwoSidedIdeal.mem_ker, map_one, eq_comm] at mem)\n\n"}
{"name":"RingHom.injective","module":"Mathlib.RingTheory.SimpleRing.Basic","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝³ : NonAssocRing R\ninst✝² : IsSimpleRing R\ninst✝¹ : NonAssocSemiring S\ninst✝ : Nontrivial S\nf : RingHom R S\n⊢ Function.Injective ⇑f","decl":"protected theorem _root_.RingHom.injective\n    {R S : Type*} [NonAssocRing R] [IsSimpleRing R] [NonAssocSemiring S] [Nontrivial S]\n    (f : R →+* S) : Function.Injective f :=\n  injective_ringHom_or_subsingleton_codomain f |>.resolve_right fun r => not_subsingleton _ r\n\n"}
{"name":"IsSimpleRing.iff_injective_ringHom_or_subsingleton_codomain","module":"Mathlib.RingTheory.SimpleRing.Basic","initialProofState":"R : Type u\ninst✝¹ : NonAssocRing R\ninst✝ : Nontrivial R\n⊢ Iff (IsSimpleRing R) (∀ {S : Type u} [inst : NonAssocSemiring S] (f : RingHom R S), Or (Function.Injective ⇑f) (Subsingleton S))","decl":"universe u in\nlemma iff_injective_ringHom_or_subsingleton_codomain (R : Type u) [NonAssocRing R] [Nontrivial R] :\n    IsSimpleRing R ↔\n    ∀ {S : Type u} [NonAssocSemiring S] (f : R →+* S), Function.Injective f ∨ Subsingleton S where\n  mp _ _ _ := injective_ringHom_or_subsingleton_codomain\n  mpr H := of_eq_bot_or_eq_top fun I => H I.ringCon.mk' |>.imp\n    (fun h => le_antisymm\n      (fun _ hx => TwoSidedIdeal.ker_eq_bot _ |>.2 h ▸ I.ker_ringCon_mk'.symm ▸ hx) bot_le)\n    (fun h => le_antisymm le_top fun x _ => I.mem_iff _ |>.2 (Quotient.eq'.1 (h.elim x 0)))\n\n"}
{"name":"IsSimpleRing.iff_injective_ringHom","module":"Mathlib.RingTheory.SimpleRing.Basic","initialProofState":"R : Type u\ninst✝¹ : NonAssocRing R\ninst✝ : Nontrivial R\n⊢ Iff (IsSimpleRing R) (∀ {S : Type u} [inst : NonAssocSemiring S] [inst_1 : Nontrivial S] (f : RingHom R S), Function.Injective ⇑f)","decl":"universe u in\nlemma iff_injective_ringHom (R : Type u) [NonAssocRing R] [Nontrivial R] :\n    IsSimpleRing R ↔\n    ∀ {S : Type u} [NonAssocSemiring S] [Nontrivial S] (f : R →+* S), Function.Injective f :=\n  iff_injective_ringHom_or_subsingleton_codomain R |>.trans <|\n    ⟨fun H _ _ _ f => H f |>.resolve_right (by simpa [not_subsingleton_iff_nontrivial]),\n      fun H S _ f => subsingleton_or_nontrivial S |>.recOn Or.inr fun _ => Or.inl <| H f⟩\n\n"}
