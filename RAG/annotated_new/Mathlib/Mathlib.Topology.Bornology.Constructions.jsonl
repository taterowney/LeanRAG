{"name":"Bornology.cobounded_prod","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Bornology α\ninst✝ : Bornology β\n⊢ Eq (Bornology.cobounded (Prod α β)) ((Bornology.cobounded α).coprod (Bornology.cobounded β))","decl":"theorem cobounded_prod : cobounded (α × β) = (cobounded α).coprod (cobounded β) :=\n  rfl\n\n"}
{"name":"Bornology.isBounded_image_fst_and_snd","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Bornology α\ninst✝ : Bornology β\ns : Set (Prod α β)\n⊢ Iff (And (Bornology.IsBounded (Set.image Prod.fst s)) (Bornology.IsBounded (Set.image Prod.snd s))) (Bornology.IsBounded s)","decl":"theorem isBounded_image_fst_and_snd {s : Set (α × β)} :\n    IsBounded (Prod.fst '' s) ∧ IsBounded (Prod.snd '' s) ↔ IsBounded s :=\n  compl_mem_coprod.symm\n\n"}
{"name":"Bornology.IsBounded.image_fst","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Bornology α\ninst✝ : Bornology β\ns : Set (Prod α β)\nhs : Bornology.IsBounded s\n⊢ Bornology.IsBounded (Set.image Prod.fst s)","decl":"lemma IsBounded.image_fst {s : Set (α × β)} (hs : IsBounded s) : IsBounded (Prod.fst '' s) :=\n  (isBounded_image_fst_and_snd.2 hs).1\n\n"}
{"name":"Bornology.IsBounded.image_snd","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Bornology α\ninst✝ : Bornology β\ns : Set (Prod α β)\nhs : Bornology.IsBounded s\n⊢ Bornology.IsBounded (Set.image Prod.snd s)","decl":"lemma IsBounded.image_snd {s : Set (α × β)} (hs : IsBounded s) : IsBounded (Prod.snd '' s) :=\n  (isBounded_image_fst_and_snd.2 hs).2\n\n"}
{"name":"Bornology.IsBounded.fst_of_prod","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Bornology α\ninst✝ : Bornology β\ns : Set α\nt : Set β\nh : Bornology.IsBounded (SProd.sprod s t)\nht : t.Nonempty\n⊢ Bornology.IsBounded s","decl":"theorem IsBounded.fst_of_prod (h : IsBounded (s ×ˢ t)) (ht : t.Nonempty) : IsBounded s :=\n  fst_image_prod s ht ▸ h.image_fst\n\n"}
{"name":"Bornology.IsBounded.snd_of_prod","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Bornology α\ninst✝ : Bornology β\ns : Set α\nt : Set β\nh : Bornology.IsBounded (SProd.sprod s t)\nhs : s.Nonempty\n⊢ Bornology.IsBounded t","decl":"theorem IsBounded.snd_of_prod (h : IsBounded (s ×ˢ t)) (hs : s.Nonempty) : IsBounded t :=\n  snd_image_prod hs t ▸ h.image_snd\n\n"}
{"name":"Bornology.IsBounded.prod","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Bornology α\ninst✝ : Bornology β\ns : Set α\nt : Set β\nhs : Bornology.IsBounded s\nht : Bornology.IsBounded t\n⊢ Bornology.IsBounded (SProd.sprod s t)","decl":"theorem IsBounded.prod (hs : IsBounded s) (ht : IsBounded t) : IsBounded (s ×ˢ t) :=\n  isBounded_image_fst_and_snd.1\n    ⟨hs.subset <| fst_image_prod_subset _ _, ht.subset <| snd_image_prod_subset _ _⟩\n\n"}
{"name":"Bornology.isBounded_prod_of_nonempty","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Bornology α\ninst✝ : Bornology β\ns : Set α\nt : Set β\nhne : (SProd.sprod s t).Nonempty\n⊢ Iff (Bornology.IsBounded (SProd.sprod s t)) (And (Bornology.IsBounded s) (Bornology.IsBounded t))","decl":"theorem isBounded_prod_of_nonempty (hne : Set.Nonempty (s ×ˢ t)) :\n    IsBounded (s ×ˢ t) ↔ IsBounded s ∧ IsBounded t :=\n  ⟨fun h => ⟨h.fst_of_prod hne.snd, h.snd_of_prod hne.fst⟩, fun h => h.1.prod h.2⟩\n\n"}
{"name":"Bornology.isBounded_prod","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Bornology α\ninst✝ : Bornology β\ns : Set α\nt : Set β\n⊢ Iff (Bornology.IsBounded (SProd.sprod s t)) (Or (Eq s EmptyCollection.emptyCollection) (Or (Eq t EmptyCollection.emptyCollection) (And (Bornology.IsBounded s) (Bornology.IsBounded t))))","decl":"theorem isBounded_prod : IsBounded (s ×ˢ t) ↔ s = ∅ ∨ t = ∅ ∨ IsBounded s ∧ IsBounded t := by\n  rcases s.eq_empty_or_nonempty with (rfl | hs); · simp\n  rcases t.eq_empty_or_nonempty with (rfl | ht); · simp\n  simp only [hs.ne_empty, ht.ne_empty, isBounded_prod_of_nonempty (hs.prod ht), false_or]\n\n"}
{"name":"Bornology.isBounded_prod_self","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"α : Type u_1\ninst✝ : Bornology α\ns : Set α\n⊢ Iff (Bornology.IsBounded (SProd.sprod s s)) (Bornology.IsBounded s)","decl":"theorem isBounded_prod_self : IsBounded (s ×ˢ s) ↔ IsBounded s := by\n  rcases s.eq_empty_or_nonempty with (rfl | hs); · simp\n  exact (isBounded_prod_of_nonempty (hs.prod hs)).trans and_self_iff\n\n"}
{"name":"Bornology.cobounded_pi","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"ι : Type u_3\nπ : ι → Type u_4\ninst✝ : (i : ι) → Bornology (π i)\n⊢ Eq (Bornology.cobounded ((i : ι) → π i)) (Filter.coprodᵢ fun i => Bornology.cobounded (π i))","decl":"theorem cobounded_pi : cobounded (∀ i, π i) = Filter.coprodᵢ fun i => cobounded (π i) :=\n  rfl\n\n"}
{"name":"Bornology.forall_isBounded_image_eval_iff","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"ι : Type u_3\nπ : ι → Type u_4\ninst✝ : (i : ι) → Bornology (π i)\ns : Set ((i : ι) → π i)\n⊢ Iff (∀ (i : ι), Bornology.IsBounded (Set.image (Function.eval i) s)) (Bornology.IsBounded s)","decl":"theorem forall_isBounded_image_eval_iff {s : Set (∀ i, π i)} :\n    (∀ i, IsBounded (eval i '' s)) ↔ IsBounded s :=\n  compl_mem_coprodᵢ.symm\n\n"}
{"name":"Bornology.IsBounded.image_eval","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"ι : Type u_3\nπ : ι → Type u_4\ninst✝ : (i : ι) → Bornology (π i)\ns : Set ((i : ι) → π i)\nhs : Bornology.IsBounded s\ni : ι\n⊢ Bornology.IsBounded (Set.image (Function.eval i) s)","decl":"lemma IsBounded.image_eval {s : Set (∀ i, π i)} (hs : IsBounded s) (i : ι) :\n    IsBounded (eval i '' s) :=\n  forall_isBounded_image_eval_iff.2 hs i\n\n"}
{"name":"Bornology.IsBounded.pi","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"ι : Type u_3\nπ : ι → Type u_4\ninst✝ : (i : ι) → Bornology (π i)\nS : (i : ι) → Set (π i)\nh : ∀ (i : ι), Bornology.IsBounded (S i)\n⊢ Bornology.IsBounded (Set.univ.pi S)","decl":"theorem IsBounded.pi (h : ∀ i, IsBounded (S i)) : IsBounded (pi univ S) :=\n  forall_isBounded_image_eval_iff.1 fun i => (h i).subset eval_image_univ_pi_subset\n\n"}
{"name":"Bornology.isBounded_pi_of_nonempty","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"ι : Type u_3\nπ : ι → Type u_4\ninst✝ : (i : ι) → Bornology (π i)\nS : (i : ι) → Set (π i)\nhne : (Set.univ.pi S).Nonempty\n⊢ Iff (Bornology.IsBounded (Set.univ.pi S)) (∀ (i : ι), Bornology.IsBounded (S i))","decl":"theorem isBounded_pi_of_nonempty (hne : (pi univ S).Nonempty) :\n    IsBounded (pi univ S) ↔ ∀ i, IsBounded (S i) :=\n  ⟨fun H i => @eval_image_univ_pi _ _ _ i hne ▸ forall_isBounded_image_eval_iff.2 H i, IsBounded.pi⟩\n\n"}
{"name":"Bornology.isBounded_pi","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"ι : Type u_3\nπ : ι → Type u_4\ninst✝ : (i : ι) → Bornology (π i)\nS : (i : ι) → Set (π i)\n⊢ Iff (Bornology.IsBounded (Set.univ.pi S)) (Or (Exists fun i => Eq (S i) EmptyCollection.emptyCollection) (∀ (i : ι), Bornology.IsBounded (S i)))","decl":"theorem isBounded_pi : IsBounded (pi univ S) ↔ (∃ i, S i = ∅) ∨ ∀ i, IsBounded (S i) := by\n  by_cases hne : ∃ i, S i = ∅\n  · simp [hne, univ_pi_eq_empty_iff.2 hne]\n  · simp only [hne, false_or]\n    simp only [not_exists, ← Ne.eq_def, ← nonempty_iff_ne_empty, ← univ_pi_nonempty_iff] at hne\n    exact isBounded_pi_of_nonempty hne\n\n"}
{"name":"Bornology.isBounded_induced","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝ : Bornology β\nf : α → β\ns : Set α\n⊢ Iff (Bornology.IsBounded s) (Bornology.IsBounded (Set.image f s))","decl":"theorem isBounded_induced {α β : Type*} [Bornology β] {f : α → β} {s : Set α} :\n    @IsBounded α (Bornology.induced f) s ↔ IsBounded (f '' s) :=\n  compl_mem_comap\n\n"}
{"name":"Bornology.isBounded_image_subtype_val","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"α : Type u_1\ninst✝ : Bornology α\np : α → Prop\ns : Set (Subtype fun x => p x)\n⊢ Iff (Bornology.IsBounded (Set.image Subtype.val s)) (Bornology.IsBounded s)","decl":"theorem isBounded_image_subtype_val {p : α → Prop} {s : Set { x // p x }} :\n    IsBounded (Subtype.val '' s) ↔ IsBounded s :=\n  isBounded_induced.symm\n\n"}
{"name":"instBoundedSpaceProd","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Bornology α\ninst✝² : Bornology β\ninst✝¹ : BoundedSpace α\ninst✝ : BoundedSpace β\n⊢ BoundedSpace (Prod α β)","decl":"instance [BoundedSpace α] [BoundedSpace β] : BoundedSpace (α × β) := by\n  simp [← cobounded_eq_bot_iff, cobounded_prod]\n\n"}
{"name":"instBoundedSpaceForall","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"ι : Type u_3\nπ : ι → Type u_4\ninst✝¹ : (i : ι) → Bornology (π i)\ninst✝ : ∀ (i : ι), BoundedSpace (π i)\n⊢ BoundedSpace ((i : ι) → π i)","decl":"instance [∀ i, BoundedSpace (π i)] : BoundedSpace (∀ i, π i) := by\n  simp [← cobounded_eq_bot_iff, cobounded_pi]\n\n"}
{"name":"boundedSpace_induced_iff","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝ : Bornology β\nf : α → β\n⊢ Iff (BoundedSpace α) (Bornology.IsBounded (Set.range f))","decl":"theorem boundedSpace_induced_iff {α β : Type*} [Bornology β] {f : α → β} :\n    @BoundedSpace α (Bornology.induced f) ↔ IsBounded (range f) := by\n  rw [← @isBounded_univ _ (Bornology.induced f), isBounded_induced, image_univ]\n-- Porting note: had to explicitly provided the bornology to `isBounded_univ`.\n\n"}
{"name":"boundedSpace_subtype_iff","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"α : Type u_1\ninst✝ : Bornology α\np : α → Prop\n⊢ Iff (BoundedSpace (Subtype p)) (Bornology.IsBounded (setOf fun x => p x))","decl":"theorem boundedSpace_subtype_iff {p : α → Prop} :\n    BoundedSpace (Subtype p) ↔ IsBounded { x | p x } := by\n  rw [boundedSpace_induced_iff, Subtype.range_coe_subtype]\n\n"}
{"name":"boundedSpace_val_set_iff","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"α : Type u_1\ninst✝ : Bornology α\ns : Set α\n⊢ Iff (BoundedSpace ↑s) (Bornology.IsBounded s)","decl":"theorem boundedSpace_val_set_iff {s : Set α} : BoundedSpace s ↔ IsBounded s :=\n  boundedSpace_subtype_iff\n\n"}
{"name":"Bornology.IsBounded.boundedSpace_subtype","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"α : Type u_1\ninst✝ : Bornology α\np : α → Prop\na✝ : Bornology.IsBounded (setOf fun x => p x)\n⊢ BoundedSpace (Subtype p)","decl":"alias ⟨_, Bornology.IsBounded.boundedSpace_subtype⟩ := boundedSpace_subtype_iff\n\n"}
{"name":"Bornology.IsBounded.boundedSpace_val","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"α : Type u_1\ninst✝ : Bornology α\ns : Set α\na✝ : Bornology.IsBounded s\n⊢ BoundedSpace ↑s","decl":"alias ⟨_, Bornology.IsBounded.boundedSpace_val⟩ := boundedSpace_val_set_iff\n\n"}
{"name":"instBoundedSpaceSubtype","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"α : Type u_1\ninst✝¹ : Bornology α\ninst✝ : BoundedSpace α\np : α → Prop\n⊢ BoundedSpace (Subtype p)","decl":"instance [BoundedSpace α] {p : α → Prop} : BoundedSpace (Subtype p) :=\n  (IsBounded.all { x | p x }).boundedSpace_subtype\n\n"}
{"name":"instBoundedSpaceAdditive","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"α : Type u_1\ninst✝¹ : Bornology α\ninst✝ : BoundedSpace α\n⊢ BoundedSpace (Additive α)","decl":"instance [BoundedSpace α] : BoundedSpace (Additive α) :=\n  ‹BoundedSpace α›\n\n"}
{"name":"instBoundedSpaceMultiplicative","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"α : Type u_1\ninst✝¹ : Bornology α\ninst✝ : BoundedSpace α\n⊢ BoundedSpace (Multiplicative α)","decl":"instance [BoundedSpace α] : BoundedSpace (Multiplicative α) :=\n  ‹BoundedSpace α›\n\n"}
{"name":"instBoundedSpaceOrderDual","module":"Mathlib.Topology.Bornology.Constructions","initialProofState":"α : Type u_1\ninst✝¹ : Bornology α\ninst✝ : BoundedSpace α\n⊢ BoundedSpace (OrderDual α)","decl":"instance [BoundedSpace α] : BoundedSpace αᵒᵈ :=\n  ‹BoundedSpace α›\n"}
