{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functorObj_obj_X","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nA : Mon_ (CategoryTheory.Functor C D)\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functorObj A).obj X).X (A.X.obj X)","decl":"/-- A monoid object in a functor category induces a functor to the category of monoid objects. -/\n@[simps]\ndef functorObj (A : Mon_ (C ‚•§ D)) : C ‚•§ Mon_ D where\n  obj X :=\n  { X := A.X.obj X\n    one := A.one.app X\n    mul := A.mul.app X\n    one_mul := congr_app A.one_mul X\n    mul_one := congr_app A.mul_one X\n    mul_assoc := congr_app A.mul_assoc X }\n  map f :=\n  { hom := A.X.map f\n    one_hom := by rw [‚Üê A.one.naturality, tensorUnit_map]; dsimp; rw [Category.id_comp]\n    mul_hom := by dsimp; rw [‚Üê A.mul.naturality, tensorObj_map] }\n  map_id X := by ext; dsimp; rw [CategoryTheory.Functor.map_id]\n  map_comp f g := by ext; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functorObj_map_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nA : Mon_ (CategoryTheory.Functor C D)\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functorObj A).map f).hom (A.X.map f)","decl":"/-- A monoid object in a functor category induces a functor to the category of monoid objects. -/\n@[simps]\ndef functorObj (A : Mon_ (C ‚•§ D)) : C ‚•§ Mon_ D where\n  obj X :=\n  { X := A.X.obj X\n    one := A.one.app X\n    mul := A.mul.app X\n    one_mul := congr_app A.one_mul X\n    mul_one := congr_app A.mul_one X\n    mul_assoc := congr_app A.mul_assoc X }\n  map f :=\n  { hom := A.X.map f\n    one_hom := by rw [‚Üê A.one.naturality, tensorUnit_map]; dsimp; rw [Category.id_comp]\n    mul_hom := by dsimp; rw [‚Üê A.mul.naturality, tensorObj_map] }\n  map_id X := by ext; dsimp; rw [CategoryTheory.Functor.map_id]\n  map_comp f g := by ext; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functorObj_obj_one","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nA : Mon_ (CategoryTheory.Functor C D)\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functorObj A).obj X).one (A.one.app X)","decl":"/-- A monoid object in a functor category induces a functor to the category of monoid objects. -/\n@[simps]\ndef functorObj (A : Mon_ (C ‚•§ D)) : C ‚•§ Mon_ D where\n  obj X :=\n  { X := A.X.obj X\n    one := A.one.app X\n    mul := A.mul.app X\n    one_mul := congr_app A.one_mul X\n    mul_one := congr_app A.mul_one X\n    mul_assoc := congr_app A.mul_assoc X }\n  map f :=\n  { hom := A.X.map f\n    one_hom := by rw [‚Üê A.one.naturality, tensorUnit_map]; dsimp; rw [Category.id_comp]\n    mul_hom := by dsimp; rw [‚Üê A.mul.naturality, tensorObj_map] }\n  map_id X := by ext; dsimp; rw [CategoryTheory.Functor.map_id]\n  map_comp f g := by ext; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functorObj_obj_mul","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nA : Mon_ (CategoryTheory.Functor C D)\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functorObj A).obj X).mul (A.mul.app X)","decl":"/-- A monoid object in a functor category induces a functor to the category of monoid objects. -/\n@[simps]\ndef functorObj (A : Mon_ (C ‚•§ D)) : C ‚•§ Mon_ D where\n  obj X :=\n  { X := A.X.obj X\n    one := A.one.app X\n    mul := A.mul.app X\n    one_mul := congr_app A.one_mul X\n    mul_one := congr_app A.mul_one X\n    mul_assoc := congr_app A.mul_assoc X }\n  map f :=\n  { hom := A.X.map f\n    one_hom := by rw [‚Üê A.one.naturality, tensorUnit_map]; dsimp; rw [Category.id_comp]\n    mul_hom := by dsimp; rw [‚Üê A.mul.naturality, tensorObj_map] }\n  map_id X := by ext; dsimp; rw [CategoryTheory.Functor.map_id]\n  map_comp f g := by ext; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functor_map_app_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nX‚úù Y‚úù : Mon_ (CategoryTheory.Functor C D)\nf : Quiver.Hom X‚úù Y‚úù\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functor.map f).app X).hom (f.hom.app X)","decl":"/-- Functor translating a monoid object in a functor category\nto a functor into the category of monoid objects.\n-/\n@[simps]\ndef functor : Mon_ (C ‚•§ D) ‚•§ C ‚•§ Mon_ D where\n  obj := functorObj\n  map f :=\n  { app := fun X =>\n    { hom := f.hom.app X\n      one_hom := congr_app f.one_hom X\n      mul_hom := congr_app f.mul_hom X } }\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functor_obj","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nA : Mon_ (CategoryTheory.Functor C D)\n‚ä¢ Eq (CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functor.obj A) (CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functorObj A)","decl":"/-- Functor translating a monoid object in a functor category\nto a functor into the category of monoid objects.\n-/\n@[simps]\ndef functor : Mon_ (C ‚•§ D) ‚•§ C ‚•§ Mon_ D where\n  obj := functorObj\n  map f :=\n  { app := fun X =>\n    { hom := f.hom.app X\n      one_hom := congr_app f.one_hom X\n      mul_hom := congr_app f.mul_hom X } }\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverseObj_X","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C (Mon_ D)\n‚ä¢ Eq (CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverseObj F).X (F.comp (Mon_.forget D))","decl":"/-- A functor to the category of monoid objects can be translated as a monoid object\nin the functor category. -/\n@[simps]\ndef inverseObj (F : C ‚•§ Mon_ D) : Mon_ (C ‚•§ D) where\n  X := F ‚ãô Mon_.forget D\n  one := { app := fun X => (F.obj X).one }\n  mul := { app := fun X => (F.obj X).mul }\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverseObj_mul_app","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C (Mon_ D)\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverseObj F).mul.app X) (F.obj X).mul","decl":"/-- A functor to the category of monoid objects can be translated as a monoid object\nin the functor category. -/\n@[simps]\ndef inverseObj (F : C ‚•§ Mon_ D) : Mon_ (C ‚•§ D) where\n  X := F ‚ãô Mon_.forget D\n  one := { app := fun X => (F.obj X).one }\n  mul := { app := fun X => (F.obj X).mul }\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverseObj_one_app","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C (Mon_ D)\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverseObj F).one.app X) (F.obj X).one","decl":"/-- A functor to the category of monoid objects can be translated as a monoid object\nin the functor category. -/\n@[simps]\ndef inverseObj (F : C ‚•§ Mon_ D) : Mon_ (C ‚•§ D) where\n  X := F ‚ãô Mon_.forget D\n  one := { app := fun X => (F.obj X).one }\n  mul := { app := fun X => (F.obj X).mul }\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverse_obj","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C (Mon_ D)\n‚ä¢ Eq (CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverse.obj F) (CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverseObj F)","decl":"/-- Functor translating a functor into the category of monoid objects\nto a monoid object in the functor category\n-/\n@[simps]\ndef inverse : (C ‚•§ Mon_ D) ‚•§ Mon_ (C ‚•§ D) where\n  obj := inverseObj\n  map Œ± :=\n  { hom :=\n    { app := fun X => (Œ±.app X).hom\n      naturality := fun _ _ f => congr_arg Mon_.Hom.hom (Œ±.naturality f) } }\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverse_map_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nX‚úù Y‚úù : CategoryTheory.Functor C (Mon_ D)\nŒ± : Quiver.Hom X‚úù Y‚úù\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverse.map Œ±).hom.app X) (Œ±.app X).hom","decl":"/-- Functor translating a functor into the category of monoid objects\nto a monoid object in the functor category\n-/\n@[simps]\ndef inverse : (C ‚•§ Mon_ D) ‚•§ Mon_ (C ‚•§ D) where\n  obj := inverseObj\n  map Œ± :=\n  { hom :=\n    { app := fun X => (Œ±.app X).hom\n      naturality := fun _ _ f => congr_arg Mon_.Hom.hom (Œ±.naturality f) } }\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.unitIso_inv_app_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nX : Mon_ (CategoryTheory.Functor C D)\nx‚úù : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.unitIso.inv.app X).hom.app x‚úù) (CategoryTheory.CategoryStruct.id (X.X.obj x‚úù))","decl":"/-- The unit for the equivalence `Mon_ (C ‚•§ D) ‚âå C ‚•§ Mon_ D`.\n-/\n@[simps!]\ndef unitIso : ùü≠ (Mon_ (C ‚•§ D)) ‚âÖ functor ‚ãô inverse :=\n  NatIso.ofComponents (fun A =>\n  { hom := { hom := { app := fun _ => ùüô _ } }\n    inv := { hom := { app := fun _ => ùüô _ } } })\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.unitIso_hom_app_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nX : Mon_ (CategoryTheory.Functor C D)\nx‚úù : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.unitIso.hom.app X).hom.app x‚úù) (CategoryTheory.CategoryStruct.id (X.X.obj x‚úù))","decl":"/-- The unit for the equivalence `Mon_ (C ‚•§ D) ‚âå C ‚•§ Mon_ D`.\n-/\n@[simps!]\ndef unitIso : ùü≠ (Mon_ (C ‚•§ D)) ‚âÖ functor ‚ãô inverse :=\n  NatIso.ofComponents (fun A =>\n  { hom := { hom := { app := fun _ => ùüô _ } }\n    inv := { hom := { app := fun _ => ùüô _ } } })\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.counitIso_hom_app_app_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nX‚úù : CategoryTheory.Functor C (Mon_ D)\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.counitIso.hom.app X‚úù).app X).hom (CategoryTheory.CategoryStruct.id (X‚úù.obj X).X)","decl":"/-- The counit for the equivalence `Mon_ (C ‚•§ D) ‚âå C ‚•§ Mon_ D`.\n-/\n@[simps!]\ndef counitIso : inverse ‚ãô functor ‚âÖ ùü≠ (C ‚•§ Mon_ D) :=\n  NatIso.ofComponents (fun A =>\n    NatIso.ofComponents (fun X => { hom := { hom := ùüô _ }, inv := { hom := ùüô _ } }))\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.counitIso_inv_app_app_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nX‚úù : CategoryTheory.Functor C (Mon_ D)\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.counitIso.inv.app X‚úù).app X).hom (CategoryTheory.CategoryStruct.id (X‚úù.obj X).X)","decl":"/-- The counit for the equivalence `Mon_ (C ‚•§ D) ‚âå C ‚•§ Mon_ D`.\n-/\n@[simps!]\ndef counitIso : inverse ‚ãô functor ‚âÖ ùü≠ (C ‚•§ Mon_ D) :=\n  NatIso.ofComponents (fun A =>\n    NatIso.ofComponents (fun X => { hom := { hom := ùüô _ }, inv := { hom := ùüô _ } }))\n\n"}
{"name":"CategoryTheory.Monoidal.monFunctorCategoryEquivalence_functor","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\n‚ä¢ Eq (CategoryTheory.Monoidal.monFunctorCategoryEquivalence C D).functor CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functor","decl":"/-- When `D` is a monoidal category,\nmonoid objects in `C ‚•§ D` are the same thing\nas functors from `C` into the monoid objects of `D`.\n-/\n@[simps]\ndef monFunctorCategoryEquivalence : Mon_ (C ‚•§ D) ‚âå C ‚•§ Mon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"CategoryTheory.Monoidal.monFunctorCategoryEquivalence_counitIso","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\n‚ä¢ Eq (CategoryTheory.Monoidal.monFunctorCategoryEquivalence C D).counitIso CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.counitIso","decl":"/-- When `D` is a monoidal category,\nmonoid objects in `C ‚•§ D` are the same thing\nas functors from `C` into the monoid objects of `D`.\n-/\n@[simps]\ndef monFunctorCategoryEquivalence : Mon_ (C ‚•§ D) ‚âå C ‚•§ Mon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"CategoryTheory.Monoidal.monFunctorCategoryEquivalence_inverse","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\n‚ä¢ Eq (CategoryTheory.Monoidal.monFunctorCategoryEquivalence C D).inverse CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverse","decl":"/-- When `D` is a monoidal category,\nmonoid objects in `C ‚•§ D` are the same thing\nas functors from `C` into the monoid objects of `D`.\n-/\n@[simps]\ndef monFunctorCategoryEquivalence : Mon_ (C ‚•§ D) ‚âå C ‚•§ Mon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"CategoryTheory.Monoidal.monFunctorCategoryEquivalence_unitIso","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\n‚ä¢ Eq (CategoryTheory.Monoidal.monFunctorCategoryEquivalence C D).unitIso CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.unitIso","decl":"/-- When `D` is a monoidal category,\nmonoid objects in `C ‚•§ D` are the same thing\nas functors from `C` into the monoid objects of `D`.\n-/\n@[simps]\ndef monFunctorCategoryEquivalence : Mon_ (C ‚•§ D) ‚âå C ‚•§ Mon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functorObj_map_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nA : Comon_ (CategoryTheory.Functor C D)\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functorObj A).map f).hom (A.X.map f)","decl":"/--\nA comonoid object in a functor category induces a functor to the category of comonoid objects.\n-/\n@[simps]\ndef functorObj (A : Comon_ (C ‚•§ D)) : C ‚•§ Comon_ D where\n  obj X :=\n  { X := A.X.obj X\n    counit := A.counit.app X\n    comul := A.comul.app X\n    counit_comul := congr_app A.counit_comul X\n    comul_counit := congr_app A.comul_counit X\n    comul_assoc := congr_app A.comul_assoc X }\n  map f :=\n  { hom := A.X.map f\n    hom_counit := by dsimp; rw [A.counit.naturality, tensorUnit_map]; dsimp; rw [Category.comp_id]\n    hom_comul := by dsimp; rw [A.comul.naturality, tensorObj_map] }\n  map_id X := by ext; dsimp; rw [CategoryTheory.Functor.map_id]\n  map_comp f g := by ext; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functorObj_obj_counit","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nA : Comon_ (CategoryTheory.Functor C D)\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functorObj A).obj X).counit (A.counit.app X)","decl":"/--\nA comonoid object in a functor category induces a functor to the category of comonoid objects.\n-/\n@[simps]\ndef functorObj (A : Comon_ (C ‚•§ D)) : C ‚•§ Comon_ D where\n  obj X :=\n  { X := A.X.obj X\n    counit := A.counit.app X\n    comul := A.comul.app X\n    counit_comul := congr_app A.counit_comul X\n    comul_counit := congr_app A.comul_counit X\n    comul_assoc := congr_app A.comul_assoc X }\n  map f :=\n  { hom := A.X.map f\n    hom_counit := by dsimp; rw [A.counit.naturality, tensorUnit_map]; dsimp; rw [Category.comp_id]\n    hom_comul := by dsimp; rw [A.comul.naturality, tensorObj_map] }\n  map_id X := by ext; dsimp; rw [CategoryTheory.Functor.map_id]\n  map_comp f g := by ext; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functorObj_obj_comul","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nA : Comon_ (CategoryTheory.Functor C D)\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functorObj A).obj X).comul (A.comul.app X)","decl":"/--\nA comonoid object in a functor category induces a functor to the category of comonoid objects.\n-/\n@[simps]\ndef functorObj (A : Comon_ (C ‚•§ D)) : C ‚•§ Comon_ D where\n  obj X :=\n  { X := A.X.obj X\n    counit := A.counit.app X\n    comul := A.comul.app X\n    counit_comul := congr_app A.counit_comul X\n    comul_counit := congr_app A.comul_counit X\n    comul_assoc := congr_app A.comul_assoc X }\n  map f :=\n  { hom := A.X.map f\n    hom_counit := by dsimp; rw [A.counit.naturality, tensorUnit_map]; dsimp; rw [Category.comp_id]\n    hom_comul := by dsimp; rw [A.comul.naturality, tensorObj_map] }\n  map_id X := by ext; dsimp; rw [CategoryTheory.Functor.map_id]\n  map_comp f g := by ext; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functorObj_obj_X","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nA : Comon_ (CategoryTheory.Functor C D)\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functorObj A).obj X).X (A.X.obj X)","decl":"/--\nA comonoid object in a functor category induces a functor to the category of comonoid objects.\n-/\n@[simps]\ndef functorObj (A : Comon_ (C ‚•§ D)) : C ‚•§ Comon_ D where\n  obj X :=\n  { X := A.X.obj X\n    counit := A.counit.app X\n    comul := A.comul.app X\n    counit_comul := congr_app A.counit_comul X\n    comul_counit := congr_app A.comul_counit X\n    comul_assoc := congr_app A.comul_assoc X }\n  map f :=\n  { hom := A.X.map f\n    hom_counit := by dsimp; rw [A.counit.naturality, tensorUnit_map]; dsimp; rw [Category.comp_id]\n    hom_comul := by dsimp; rw [A.comul.naturality, tensorObj_map] }\n  map_id X := by ext; dsimp; rw [CategoryTheory.Functor.map_id]\n  map_comp f g := by ext; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functor_obj","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nA : Comon_ (CategoryTheory.Functor C D)\n‚ä¢ Eq (CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functor.obj A) (CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functorObj A)","decl":"/-- Functor translating a comonoid object in a functor category\nto a functor into the category of comonoid objects.\n-/\n@[simps]\ndef functor : Comon_ (C ‚•§ D) ‚•§ C ‚•§ Comon_ D where\n  obj := functorObj\n  map f :=\n  { app := fun X =>\n    { hom := f.hom.app X\n      hom_counit := congr_app f.hom_counit X\n      hom_comul := congr_app f.hom_comul X } }\n\n"}
{"name":"CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functor_map_app_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nX‚úù Y‚úù : Comon_ (CategoryTheory.Functor C D)\nf : Quiver.Hom X‚úù Y‚úù\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functor.map f).app X).hom (f.hom.app X)","decl":"/-- Functor translating a comonoid object in a functor category\nto a functor into the category of comonoid objects.\n-/\n@[simps]\ndef functor : Comon_ (C ‚•§ D) ‚•§ C ‚•§ Comon_ D where\n  obj := functorObj\n  map f :=\n  { app := fun X =>\n    { hom := f.hom.app X\n      hom_counit := congr_app f.hom_counit X\n      hom_comul := congr_app f.hom_comul X } }\n\n"}
{"name":"CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.inverseObj_comul_app","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C (Comon_ D)\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.inverseObj F).comul.app X) (F.obj X).comul","decl":"/-- A functor to the category of comonoid objects can be translated as a comonoid object\nin the functor category. -/\n@[simps]\ndef inverseObj (F : C ‚•§ Comon_ D) : Comon_ (C ‚•§ D) where\n  X := F ‚ãô Comon_.forget D\n  counit := { app := fun X => (F.obj X).counit }\n  comul := { app := fun X => (F.obj X).comul }\n\n"}
{"name":"CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.inverseObj_counit_app","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C (Comon_ D)\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.inverseObj F).counit.app X) (F.obj X).counit","decl":"/-- A functor to the category of comonoid objects can be translated as a comonoid object\nin the functor category. -/\n@[simps]\ndef inverseObj (F : C ‚•§ Comon_ D) : Comon_ (C ‚•§ D) where\n  X := F ‚ãô Comon_.forget D\n  counit := { app := fun X => (F.obj X).counit }\n  comul := { app := fun X => (F.obj X).comul }\n\n"}
{"name":"CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.inverseObj_X","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C (Comon_ D)\n‚ä¢ Eq (CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.inverseObj F).X (F.comp (Comon_.forget D))","decl":"/-- A functor to the category of comonoid objects can be translated as a comonoid object\nin the functor category. -/\n@[simps]\ndef inverseObj (F : C ‚•§ Comon_ D) : Comon_ (C ‚•§ D) where\n  X := F ‚ãô Comon_.forget D\n  counit := { app := fun X => (F.obj X).counit }\n  comul := { app := fun X => (F.obj X).comul }\n\n"}
{"name":"CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.counitIso_hom_app_app_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nX‚úù : CategoryTheory.Functor C (Comon_ D)\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.counitIso.hom.app X‚úù).app X).hom (CategoryTheory.CategoryStruct.id (X‚úù.obj X).X)","decl":"/-- The counit for the equivalence `Mon_ (C ‚•§ D) ‚âå C ‚•§ Mon_ D`.\n-/\n@[simps!]\ndef counitIso : inverse ‚ãô functor ‚âÖ ùü≠ (C ‚•§ Comon_ D) :=\n  NatIso.ofComponents (fun A =>\n    NatIso.ofComponents (fun X => { hom := { hom := ùüô _ }, inv := { hom := ùüô _ } }) )\n\n"}
{"name":"CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.counitIso_inv_app_app_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nX‚úù : CategoryTheory.Functor C (Comon_ D)\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.counitIso.inv.app X‚úù).app X).hom (CategoryTheory.CategoryStruct.id (X‚úù.obj X).X)","decl":"/-- The counit for the equivalence `Mon_ (C ‚•§ D) ‚âå C ‚•§ Mon_ D`.\n-/\n@[simps!]\ndef counitIso : inverse ‚ãô functor ‚âÖ ùü≠ (C ‚•§ Comon_ D) :=\n  NatIso.ofComponents (fun A =>\n    NatIso.ofComponents (fun X => { hom := { hom := ùüô _ }, inv := { hom := ùüô _ } }) )\n\n"}
{"name":"CategoryTheory.Monoidal.comonFunctorCategoryEquivalence_functor","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\n‚ä¢ Eq (CategoryTheory.Monoidal.comonFunctorCategoryEquivalence C D).functor CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functor","decl":"/-- When `D` is a monoidal category,\ncomonoid objects in `C ‚•§ D` are the same thing\nas functors from `C` into the comonoid objects of `D`.\n-/\n@[simps]\ndef comonFunctorCategoryEquivalence : Comon_ (C ‚•§ D) ‚âå C ‚•§ Comon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"CategoryTheory.Monoidal.comonFunctorCategoryEquivalence_counitIso","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\n‚ä¢ Eq (CategoryTheory.Monoidal.comonFunctorCategoryEquivalence C D).counitIso CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.counitIso","decl":"/-- When `D` is a monoidal category,\ncomonoid objects in `C ‚•§ D` are the same thing\nas functors from `C` into the comonoid objects of `D`.\n-/\n@[simps]\ndef comonFunctorCategoryEquivalence : Comon_ (C ‚•§ D) ‚âå C ‚•§ Comon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"CategoryTheory.Monoidal.comonFunctorCategoryEquivalence_inverse","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\n‚ä¢ Eq (CategoryTheory.Monoidal.comonFunctorCategoryEquivalence C D).inverse CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.inverse","decl":"/-- When `D` is a monoidal category,\ncomonoid objects in `C ‚•§ D` are the same thing\nas functors from `C` into the comonoid objects of `D`.\n-/\n@[simps]\ndef comonFunctorCategoryEquivalence : Comon_ (C ‚•§ D) ‚âå C ‚•§ Comon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"CategoryTheory.Monoidal.comonFunctorCategoryEquivalence_unitIso","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.MonoidalCategory D\n‚ä¢ Eq (CategoryTheory.Monoidal.comonFunctorCategoryEquivalence C D).unitIso CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.unitIso","decl":"/-- When `D` is a monoidal category,\ncomonoid objects in `C ‚•§ D` are the same thing\nas functors from `C` into the comonoid objects of `D`.\n-/\n@[simps]\ndef comonFunctorCategoryEquivalence : Comon_ (C ‚•§ D) ‚âå C ‚•§ Comon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor_obj_obj_mul","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\ninst‚úù : CategoryTheory.BraidedCategory D\nA : CommMon_ (CategoryTheory.Functor C D)\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor.obj A).obj X).mul (A.mul.app X)","decl":"/-- Functor translating a commutative monoid object in a functor category\nto a functor into the category of commutative monoid objects.\n-/\n@[simps!]\ndef functor : CommMon_ (C ‚•§ D) ‚•§ C ‚•§ CommMon_ D where\n  obj A :=\n    { (monFunctorCategoryEquivalence C D).functor.obj A.toMon_ with\n      obj := fun X =>\n        { ((monFunctorCategoryEquivalence C D).functor.obj A.toMon_).obj X with\n          mul_comm := congr_app A.mul_comm X } }\n  map f := { app := fun X => ((monFunctorCategoryEquivalence C D).functor.map f).app X }\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor_map_app_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\ninst‚úù : CategoryTheory.BraidedCategory D\nX‚úù Y‚úù : CommMon_ (CategoryTheory.Functor C D)\nf : Quiver.Hom X‚úù Y‚úù\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor.map f).app X).hom (f.hom.app X)","decl":"/-- Functor translating a commutative monoid object in a functor category\nto a functor into the category of commutative monoid objects.\n-/\n@[simps!]\ndef functor : CommMon_ (C ‚•§ D) ‚•§ C ‚•§ CommMon_ D where\n  obj A :=\n    { (monFunctorCategoryEquivalence C D).functor.obj A.toMon_ with\n      obj := fun X =>\n        { ((monFunctorCategoryEquivalence C D).functor.obj A.toMon_).obj X with\n          mul_comm := congr_app A.mul_comm X } }\n  map f := { app := fun X => ((monFunctorCategoryEquivalence C D).functor.map f).app X }\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor_obj_obj_X","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\ninst‚úù : CategoryTheory.BraidedCategory D\nA : CommMon_ (CategoryTheory.Functor C D)\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor.obj A).obj X).X (A.X.obj X)","decl":"/-- Functor translating a commutative monoid object in a functor category\nto a functor into the category of commutative monoid objects.\n-/\n@[simps!]\ndef functor : CommMon_ (C ‚•§ D) ‚•§ C ‚•§ CommMon_ D where\n  obj A :=\n    { (monFunctorCategoryEquivalence C D).functor.obj A.toMon_ with\n      obj := fun X =>\n        { ((monFunctorCategoryEquivalence C D).functor.obj A.toMon_).obj X with\n          mul_comm := congr_app A.mul_comm X } }\n  map f := { app := fun X => ((monFunctorCategoryEquivalence C D).functor.map f).app X }\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor_obj_obj_one","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\ninst‚úù : CategoryTheory.BraidedCategory D\nA : CommMon_ (CategoryTheory.Functor C D)\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor.obj A).obj X).one (A.one.app X)","decl":"/-- Functor translating a commutative monoid object in a functor category\nto a functor into the category of commutative monoid objects.\n-/\n@[simps!]\ndef functor : CommMon_ (C ‚•§ D) ‚•§ C ‚•§ CommMon_ D where\n  obj A :=\n    { (monFunctorCategoryEquivalence C D).functor.obj A.toMon_ with\n      obj := fun X =>\n        { ((monFunctorCategoryEquivalence C D).functor.obj A.toMon_).obj X with\n          mul_comm := congr_app A.mul_comm X } }\n  map f := { app := fun X => ((monFunctorCategoryEquivalence C D).functor.map f).app X }\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor_obj_map_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\ninst‚úù : CategoryTheory.BraidedCategory D\nA : CommMon_ (CategoryTheory.Functor C D)\nX Y : C\na‚úù : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor.obj A).map a‚úù).hom (A.X.map a‚úù)","decl":"/-- Functor translating a commutative monoid object in a functor category\nto a functor into the category of commutative monoid objects.\n-/\n@[simps!]\ndef functor : CommMon_ (C ‚•§ D) ‚•§ C ‚•§ CommMon_ D where\n  obj A :=\n    { (monFunctorCategoryEquivalence C D).functor.obj A.toMon_ with\n      obj := fun X =>\n        { ((monFunctorCategoryEquivalence C D).functor.obj A.toMon_).obj X with\n          mul_comm := congr_app A.mul_comm X } }\n  map f := { app := fun X => ((monFunctorCategoryEquivalence C D).functor.map f).app X }\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.inverse_obj_one_app","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\ninst‚úù : CategoryTheory.BraidedCategory D\nF : CategoryTheory.Functor C (CommMon_ D)\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.inverse.obj F).one.app X) (F.obj X).one","decl":"/-- Functor translating a functor into the category of commutative monoid objects\nto a commutative monoid object in the functor category\n-/\n@[simps!]\ndef inverse : (C ‚•§ CommMon_ D) ‚•§ CommMon_ (C ‚•§ D) where\n  obj F :=\n    { (monFunctorCategoryEquivalence C D).inverse.obj (F ‚ãô CommMon_.forget‚ÇÇMon_ D) with\n      mul_comm := by ext X; exact (F.obj X).mul_comm }\n  map Œ± := (monFunctorCategoryEquivalence C D).inverse.map (whiskerRight Œ± _)\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.inverse_obj_mul_app","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\ninst‚úù : CategoryTheory.BraidedCategory D\nF : CategoryTheory.Functor C (CommMon_ D)\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.inverse.obj F).mul.app X) (F.obj X).mul","decl":"/-- Functor translating a functor into the category of commutative monoid objects\nto a commutative monoid object in the functor category\n-/\n@[simps!]\ndef inverse : (C ‚•§ CommMon_ D) ‚•§ CommMon_ (C ‚•§ D) where\n  obj F :=\n    { (monFunctorCategoryEquivalence C D).inverse.obj (F ‚ãô CommMon_.forget‚ÇÇMon_ D) with\n      mul_comm := by ext X; exact (F.obj X).mul_comm }\n  map Œ± := (monFunctorCategoryEquivalence C D).inverse.map (whiskerRight Œ± _)\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.inverse_obj_X_map","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\ninst‚úù : CategoryTheory.BraidedCategory D\nF : CategoryTheory.Functor C (CommMon_ D)\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.inverse.obj F).X.map f) (F.map f).hom","decl":"/-- Functor translating a functor into the category of commutative monoid objects\nto a commutative monoid object in the functor category\n-/\n@[simps!]\ndef inverse : (C ‚•§ CommMon_ D) ‚•§ CommMon_ (C ‚•§ D) where\n  obj F :=\n    { (monFunctorCategoryEquivalence C D).inverse.obj (F ‚ãô CommMon_.forget‚ÇÇMon_ D) with\n      mul_comm := by ext X; exact (F.obj X).mul_comm }\n  map Œ± := (monFunctorCategoryEquivalence C D).inverse.map (whiskerRight Œ± _)\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.inverse_map_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\ninst‚úù : CategoryTheory.BraidedCategory D\nX‚úù Y‚úù : CategoryTheory.Functor C (CommMon_ D)\nŒ± : Quiver.Hom X‚úù Y‚úù\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.inverse.map Œ±).hom.app X) (Œ±.app X).hom","decl":"/-- Functor translating a functor into the category of commutative monoid objects\nto a commutative monoid object in the functor category\n-/\n@[simps!]\ndef inverse : (C ‚•§ CommMon_ D) ‚•§ CommMon_ (C ‚•§ D) where\n  obj F :=\n    { (monFunctorCategoryEquivalence C D).inverse.obj (F ‚ãô CommMon_.forget‚ÇÇMon_ D) with\n      mul_comm := by ext X; exact (F.obj X).mul_comm }\n  map Œ± := (monFunctorCategoryEquivalence C D).inverse.map (whiskerRight Œ± _)\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.inverse_obj_X_obj","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\ninst‚úù : CategoryTheory.BraidedCategory D\nF : CategoryTheory.Functor C (CommMon_ D)\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.inverse.obj F).X.obj X) ((CommMon_.forget‚ÇÇMon_ D).obj (F.obj X)).X","decl":"/-- Functor translating a functor into the category of commutative monoid objects\nto a commutative monoid object in the functor category\n-/\n@[simps!]\ndef inverse : (C ‚•§ CommMon_ D) ‚•§ CommMon_ (C ‚•§ D) where\n  obj F :=\n    { (monFunctorCategoryEquivalence C D).inverse.obj (F ‚ãô CommMon_.forget‚ÇÇMon_ D) with\n      mul_comm := by ext X; exact (F.obj X).mul_comm }\n  map Œ± := (monFunctorCategoryEquivalence C D).inverse.map (whiskerRight Œ± _)\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.unitIso_hom_app_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\ninst‚úù : CategoryTheory.BraidedCategory D\nX : CommMon_ (CategoryTheory.Functor C D)\nx‚úù : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.unitIso.hom.app X).hom.app x‚úù) (CategoryTheory.CategoryStruct.id (X.X.obj x‚úù))","decl":"/-- The unit for the equivalence `CommMon_ (C ‚•§ D) ‚âå C ‚•§ CommMon_ D`.\n-/\n@[simps!]\ndef unitIso : ùü≠ (CommMon_ (C ‚•§ D)) ‚âÖ functor ‚ãô inverse :=\n  NatIso.ofComponents (fun A =>\n  { hom := { hom := { app := fun _ => ùüô _ }  }\n    inv := { hom := { app := fun _ => ùüô _ }  } })\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.unitIso_inv_app_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\ninst‚úù : CategoryTheory.BraidedCategory D\nX : CommMon_ (CategoryTheory.Functor C D)\nx‚úù : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.unitIso.inv.app X).hom.app x‚úù) (CategoryTheory.CategoryStruct.id ((CommMon_.forget‚ÇÇMon_ D).obj ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor.obj X).obj x‚úù)).X)","decl":"/-- The unit for the equivalence `CommMon_ (C ‚•§ D) ‚âå C ‚•§ CommMon_ D`.\n-/\n@[simps!]\ndef unitIso : ùü≠ (CommMon_ (C ‚•§ D)) ‚âÖ functor ‚ãô inverse :=\n  NatIso.ofComponents (fun A =>\n  { hom := { hom := { app := fun _ => ùüô _ }  }\n    inv := { hom := { app := fun _ => ùüô _ }  } })\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.counitIso_inv_app_app_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\ninst‚úù : CategoryTheory.BraidedCategory D\nX‚úù : CategoryTheory.Functor C (CommMon_ D)\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.counitIso.inv.app X‚úù).app X).hom (CategoryTheory.CategoryStruct.id (X‚úù.obj X).X)","decl":"/-- The counit for the equivalence `CommMon_ (C ‚•§ D) ‚âå C ‚•§ CommMon_ D`.\n-/\n@[simps!]\ndef counitIso : inverse ‚ãô functor ‚âÖ ùü≠ (C ‚•§ CommMon_ D) :=\n  NatIso.ofComponents (fun A =>\n    NatIso.ofComponents (fun X => { hom := { hom := ùüô _ }, inv := { hom := ùüô _ } }) )\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.counitIso_hom_app_app_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\ninst‚úù : CategoryTheory.BraidedCategory D\nX‚úù : CategoryTheory.Functor C (CommMon_ D)\nX : C\n‚ä¢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.counitIso.hom.app X‚úù).app X).hom (CategoryTheory.CategoryStruct.id ((CommMon_.forget‚ÇÇMon_ D).obj (X‚úù.obj X)).X)","decl":"/-- The counit for the equivalence `CommMon_ (C ‚•§ D) ‚âå C ‚•§ CommMon_ D`.\n-/\n@[simps!]\ndef counitIso : inverse ‚ãô functor ‚âÖ ùü≠ (C ‚•§ CommMon_ D) :=\n  NatIso.ofComponents (fun A =>\n    NatIso.ofComponents (fun X => { hom := { hom := ùüô _ }, inv := { hom := ùüô _ } }) )\n\n"}
{"name":"CategoryTheory.Monoidal.commMonFunctorCategoryEquivalence_counitIso","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\ninst‚úù : CategoryTheory.BraidedCategory D\n‚ä¢ Eq (CategoryTheory.Monoidal.commMonFunctorCategoryEquivalence C D).counitIso CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.counitIso","decl":"/-- When `D` is a braided monoidal category,\ncommutative monoid objects in `C ‚•§ D` are the same thing\nas functors from `C` into the commutative monoid objects of `D`.\n-/\n@[simps]\ndef commMonFunctorCategoryEquivalence : CommMon_ (C ‚•§ D) ‚âå C ‚•§ CommMon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"CategoryTheory.Monoidal.commMonFunctorCategoryEquivalence_unitIso","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\ninst‚úù : CategoryTheory.BraidedCategory D\n‚ä¢ Eq (CategoryTheory.Monoidal.commMonFunctorCategoryEquivalence C D).unitIso CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.unitIso","decl":"/-- When `D` is a braided monoidal category,\ncommutative monoid objects in `C ‚•§ D` are the same thing\nas functors from `C` into the commutative monoid objects of `D`.\n-/\n@[simps]\ndef commMonFunctorCategoryEquivalence : CommMon_ (C ‚•§ D) ‚âå C ‚•§ CommMon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"CategoryTheory.Monoidal.commMonFunctorCategoryEquivalence_functor","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\ninst‚úù : CategoryTheory.BraidedCategory D\n‚ä¢ Eq (CategoryTheory.Monoidal.commMonFunctorCategoryEquivalence C D).functor CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor","decl":"/-- When `D` is a braided monoidal category,\ncommutative monoid objects in `C ‚•§ D` are the same thing\nas functors from `C` into the commutative monoid objects of `D`.\n-/\n@[simps]\ndef commMonFunctorCategoryEquivalence : CommMon_ (C ‚•§ D) ‚âå C ‚•§ CommMon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"CategoryTheory.Monoidal.commMonFunctorCategoryEquivalence_inverse","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\ninst‚úù : CategoryTheory.BraidedCategory D\n‚ä¢ Eq (CategoryTheory.Monoidal.commMonFunctorCategoryEquivalence C D).inverse CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.inverse","decl":"/-- When `D` is a braided monoidal category,\ncommutative monoid objects in `C ‚•§ D` are the same thing\nas functors from `C` into the commutative monoid objects of `D`.\n-/\n@[simps]\ndef commMonFunctorCategoryEquivalence : CommMon_ (C ‚•§ D) ‚âå C ‚•§ CommMon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
