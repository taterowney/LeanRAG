{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functorObj_obj_X","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nA : Mon_ (CategoryTheory.Functor C D)\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functorObj A).obj X).X (A.X.obj X)","decl":"/-- A monoid object in a functor category induces a functor to the category of monoid objects. -/\n@[simps]\ndef functorObj (A : Mon_ (C ⥤ D)) : C ⥤ Mon_ D where\n  obj X :=\n  { X := A.X.obj X\n    one := A.one.app X\n    mul := A.mul.app X\n    one_mul := congr_app A.one_mul X\n    mul_one := congr_app A.mul_one X\n    mul_assoc := congr_app A.mul_assoc X }\n  map f :=\n  { hom := A.X.map f\n    one_hom := by rw [← A.one.naturality, tensorUnit_map]; dsimp; rw [Category.id_comp]\n    mul_hom := by dsimp; rw [← A.mul.naturality, tensorObj_map] }\n  map_id X := by ext; dsimp; rw [CategoryTheory.Functor.map_id]\n  map_comp f g := by ext; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functorObj_map_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nA : Mon_ (CategoryTheory.Functor C D)\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functorObj A).map f).hom (A.X.map f)","decl":"/-- A monoid object in a functor category induces a functor to the category of monoid objects. -/\n@[simps]\ndef functorObj (A : Mon_ (C ⥤ D)) : C ⥤ Mon_ D where\n  obj X :=\n  { X := A.X.obj X\n    one := A.one.app X\n    mul := A.mul.app X\n    one_mul := congr_app A.one_mul X\n    mul_one := congr_app A.mul_one X\n    mul_assoc := congr_app A.mul_assoc X }\n  map f :=\n  { hom := A.X.map f\n    one_hom := by rw [← A.one.naturality, tensorUnit_map]; dsimp; rw [Category.id_comp]\n    mul_hom := by dsimp; rw [← A.mul.naturality, tensorObj_map] }\n  map_id X := by ext; dsimp; rw [CategoryTheory.Functor.map_id]\n  map_comp f g := by ext; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functorObj_obj_one","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nA : Mon_ (CategoryTheory.Functor C D)\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functorObj A).obj X).one (A.one.app X)","decl":"/-- A monoid object in a functor category induces a functor to the category of monoid objects. -/\n@[simps]\ndef functorObj (A : Mon_ (C ⥤ D)) : C ⥤ Mon_ D where\n  obj X :=\n  { X := A.X.obj X\n    one := A.one.app X\n    mul := A.mul.app X\n    one_mul := congr_app A.one_mul X\n    mul_one := congr_app A.mul_one X\n    mul_assoc := congr_app A.mul_assoc X }\n  map f :=\n  { hom := A.X.map f\n    one_hom := by rw [← A.one.naturality, tensorUnit_map]; dsimp; rw [Category.id_comp]\n    mul_hom := by dsimp; rw [← A.mul.naturality, tensorObj_map] }\n  map_id X := by ext; dsimp; rw [CategoryTheory.Functor.map_id]\n  map_comp f g := by ext; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functorObj_obj_mul","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nA : Mon_ (CategoryTheory.Functor C D)\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functorObj A).obj X).mul (A.mul.app X)","decl":"/-- A monoid object in a functor category induces a functor to the category of monoid objects. -/\n@[simps]\ndef functorObj (A : Mon_ (C ⥤ D)) : C ⥤ Mon_ D where\n  obj X :=\n  { X := A.X.obj X\n    one := A.one.app X\n    mul := A.mul.app X\n    one_mul := congr_app A.one_mul X\n    mul_one := congr_app A.mul_one X\n    mul_assoc := congr_app A.mul_assoc X }\n  map f :=\n  { hom := A.X.map f\n    one_hom := by rw [← A.one.naturality, tensorUnit_map]; dsimp; rw [Category.id_comp]\n    mul_hom := by dsimp; rw [← A.mul.naturality, tensorObj_map] }\n  map_id X := by ext; dsimp; rw [CategoryTheory.Functor.map_id]\n  map_comp f g := by ext; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functor_map_app_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nX✝ Y✝ : Mon_ (CategoryTheory.Functor C D)\nf : Quiver.Hom X✝ Y✝\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functor.map f).app X).hom (f.hom.app X)","decl":"/-- Functor translating a monoid object in a functor category\nto a functor into the category of monoid objects.\n-/\n@[simps]\ndef functor : Mon_ (C ⥤ D) ⥤ C ⥤ Mon_ D where\n  obj := functorObj\n  map f :=\n  { app := fun X =>\n    { hom := f.hom.app X\n      one_hom := congr_app f.one_hom X\n      mul_hom := congr_app f.mul_hom X } }\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functor_obj","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nA : Mon_ (CategoryTheory.Functor C D)\n⊢ Eq (CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functor.obj A) (CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functorObj A)","decl":"/-- Functor translating a monoid object in a functor category\nto a functor into the category of monoid objects.\n-/\n@[simps]\ndef functor : Mon_ (C ⥤ D) ⥤ C ⥤ Mon_ D where\n  obj := functorObj\n  map f :=\n  { app := fun X =>\n    { hom := f.hom.app X\n      one_hom := congr_app f.one_hom X\n      mul_hom := congr_app f.mul_hom X } }\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverseObj_X","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C (Mon_ D)\n⊢ Eq (CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverseObj F).X (F.comp (Mon_.forget D))","decl":"/-- A functor to the category of monoid objects can be translated as a monoid object\nin the functor category. -/\n@[simps]\ndef inverseObj (F : C ⥤ Mon_ D) : Mon_ (C ⥤ D) where\n  X := F ⋙ Mon_.forget D\n  one := { app := fun X => (F.obj X).one }\n  mul := { app := fun X => (F.obj X).mul }\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverseObj_mul_app","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C (Mon_ D)\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverseObj F).mul.app X) (F.obj X).mul","decl":"/-- A functor to the category of monoid objects can be translated as a monoid object\nin the functor category. -/\n@[simps]\ndef inverseObj (F : C ⥤ Mon_ D) : Mon_ (C ⥤ D) where\n  X := F ⋙ Mon_.forget D\n  one := { app := fun X => (F.obj X).one }\n  mul := { app := fun X => (F.obj X).mul }\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverseObj_one_app","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C (Mon_ D)\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverseObj F).one.app X) (F.obj X).one","decl":"/-- A functor to the category of monoid objects can be translated as a monoid object\nin the functor category. -/\n@[simps]\ndef inverseObj (F : C ⥤ Mon_ D) : Mon_ (C ⥤ D) where\n  X := F ⋙ Mon_.forget D\n  one := { app := fun X => (F.obj X).one }\n  mul := { app := fun X => (F.obj X).mul }\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverse_obj","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C (Mon_ D)\n⊢ Eq (CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverse.obj F) (CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverseObj F)","decl":"/-- Functor translating a functor into the category of monoid objects\nto a monoid object in the functor category\n-/\n@[simps]\ndef inverse : (C ⥤ Mon_ D) ⥤ Mon_ (C ⥤ D) where\n  obj := inverseObj\n  map α :=\n  { hom :=\n    { app := fun X => (α.app X).hom\n      naturality := fun _ _ f => congr_arg Mon_.Hom.hom (α.naturality f) } }\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverse_map_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nX✝ Y✝ : CategoryTheory.Functor C (Mon_ D)\nα : Quiver.Hom X✝ Y✝\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverse.map α).hom.app X) (α.app X).hom","decl":"/-- Functor translating a functor into the category of monoid objects\nto a monoid object in the functor category\n-/\n@[simps]\ndef inverse : (C ⥤ Mon_ D) ⥤ Mon_ (C ⥤ D) where\n  obj := inverseObj\n  map α :=\n  { hom :=\n    { app := fun X => (α.app X).hom\n      naturality := fun _ _ f => congr_arg Mon_.Hom.hom (α.naturality f) } }\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.unitIso_inv_app_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nX : Mon_ (CategoryTheory.Functor C D)\nx✝ : C\n⊢ Eq ((CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.unitIso.inv.app X).hom.app x✝) (CategoryTheory.CategoryStruct.id (X.X.obj x✝))","decl":"/-- The unit for the equivalence `Mon_ (C ⥤ D) ≌ C ⥤ Mon_ D`.\n-/\n@[simps!]\ndef unitIso : 𝟭 (Mon_ (C ⥤ D)) ≅ functor ⋙ inverse :=\n  NatIso.ofComponents (fun A =>\n  { hom := { hom := { app := fun _ => 𝟙 _ } }\n    inv := { hom := { app := fun _ => 𝟙 _ } } })\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.unitIso_hom_app_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nX : Mon_ (CategoryTheory.Functor C D)\nx✝ : C\n⊢ Eq ((CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.unitIso.hom.app X).hom.app x✝) (CategoryTheory.CategoryStruct.id (X.X.obj x✝))","decl":"/-- The unit for the equivalence `Mon_ (C ⥤ D) ≌ C ⥤ Mon_ D`.\n-/\n@[simps!]\ndef unitIso : 𝟭 (Mon_ (C ⥤ D)) ≅ functor ⋙ inverse :=\n  NatIso.ofComponents (fun A =>\n  { hom := { hom := { app := fun _ => 𝟙 _ } }\n    inv := { hom := { app := fun _ => 𝟙 _ } } })\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.counitIso_hom_app_app_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nX✝ : CategoryTheory.Functor C (Mon_ D)\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.counitIso.hom.app X✝).app X).hom (CategoryTheory.CategoryStruct.id (X✝.obj X).X)","decl":"/-- The counit for the equivalence `Mon_ (C ⥤ D) ≌ C ⥤ Mon_ D`.\n-/\n@[simps!]\ndef counitIso : inverse ⋙ functor ≅ 𝟭 (C ⥤ Mon_ D) :=\n  NatIso.ofComponents (fun A =>\n    NatIso.ofComponents (fun X => { hom := { hom := 𝟙 _ }, inv := { hom := 𝟙 _ } }))\n\n"}
{"name":"CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.counitIso_inv_app_app_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nX✝ : CategoryTheory.Functor C (Mon_ D)\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.counitIso.inv.app X✝).app X).hom (CategoryTheory.CategoryStruct.id (X✝.obj X).X)","decl":"/-- The counit for the equivalence `Mon_ (C ⥤ D) ≌ C ⥤ Mon_ D`.\n-/\n@[simps!]\ndef counitIso : inverse ⋙ functor ≅ 𝟭 (C ⥤ Mon_ D) :=\n  NatIso.ofComponents (fun A =>\n    NatIso.ofComponents (fun X => { hom := { hom := 𝟙 _ }, inv := { hom := 𝟙 _ } }))\n\n"}
{"name":"CategoryTheory.Monoidal.monFunctorCategoryEquivalence_functor","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\n⊢ Eq (CategoryTheory.Monoidal.monFunctorCategoryEquivalence C D).functor CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functor","decl":"/-- When `D` is a monoidal category,\nmonoid objects in `C ⥤ D` are the same thing\nas functors from `C` into the monoid objects of `D`.\n-/\n@[simps]\ndef monFunctorCategoryEquivalence : Mon_ (C ⥤ D) ≌ C ⥤ Mon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"CategoryTheory.Monoidal.monFunctorCategoryEquivalence_counitIso","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\n⊢ Eq (CategoryTheory.Monoidal.monFunctorCategoryEquivalence C D).counitIso CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.counitIso","decl":"/-- When `D` is a monoidal category,\nmonoid objects in `C ⥤ D` are the same thing\nas functors from `C` into the monoid objects of `D`.\n-/\n@[simps]\ndef monFunctorCategoryEquivalence : Mon_ (C ⥤ D) ≌ C ⥤ Mon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"CategoryTheory.Monoidal.monFunctorCategoryEquivalence_inverse","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\n⊢ Eq (CategoryTheory.Monoidal.monFunctorCategoryEquivalence C D).inverse CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverse","decl":"/-- When `D` is a monoidal category,\nmonoid objects in `C ⥤ D` are the same thing\nas functors from `C` into the monoid objects of `D`.\n-/\n@[simps]\ndef monFunctorCategoryEquivalence : Mon_ (C ⥤ D) ≌ C ⥤ Mon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"CategoryTheory.Monoidal.monFunctorCategoryEquivalence_unitIso","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\n⊢ Eq (CategoryTheory.Monoidal.monFunctorCategoryEquivalence C D).unitIso CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.unitIso","decl":"/-- When `D` is a monoidal category,\nmonoid objects in `C ⥤ D` are the same thing\nas functors from `C` into the monoid objects of `D`.\n-/\n@[simps]\ndef monFunctorCategoryEquivalence : Mon_ (C ⥤ D) ≌ C ⥤ Mon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functorObj_map_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nA : Comon_ (CategoryTheory.Functor C D)\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functorObj A).map f).hom (A.X.map f)","decl":"/--\nA comonoid object in a functor category induces a functor to the category of comonoid objects.\n-/\n@[simps]\ndef functorObj (A : Comon_ (C ⥤ D)) : C ⥤ Comon_ D where\n  obj X :=\n  { X := A.X.obj X\n    counit := A.counit.app X\n    comul := A.comul.app X\n    counit_comul := congr_app A.counit_comul X\n    comul_counit := congr_app A.comul_counit X\n    comul_assoc := congr_app A.comul_assoc X }\n  map f :=\n  { hom := A.X.map f\n    hom_counit := by dsimp; rw [A.counit.naturality, tensorUnit_map]; dsimp; rw [Category.comp_id]\n    hom_comul := by dsimp; rw [A.comul.naturality, tensorObj_map] }\n  map_id X := by ext; dsimp; rw [CategoryTheory.Functor.map_id]\n  map_comp f g := by ext; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functorObj_obj_counit","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nA : Comon_ (CategoryTheory.Functor C D)\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functorObj A).obj X).counit (A.counit.app X)","decl":"/--\nA comonoid object in a functor category induces a functor to the category of comonoid objects.\n-/\n@[simps]\ndef functorObj (A : Comon_ (C ⥤ D)) : C ⥤ Comon_ D where\n  obj X :=\n  { X := A.X.obj X\n    counit := A.counit.app X\n    comul := A.comul.app X\n    counit_comul := congr_app A.counit_comul X\n    comul_counit := congr_app A.comul_counit X\n    comul_assoc := congr_app A.comul_assoc X }\n  map f :=\n  { hom := A.X.map f\n    hom_counit := by dsimp; rw [A.counit.naturality, tensorUnit_map]; dsimp; rw [Category.comp_id]\n    hom_comul := by dsimp; rw [A.comul.naturality, tensorObj_map] }\n  map_id X := by ext; dsimp; rw [CategoryTheory.Functor.map_id]\n  map_comp f g := by ext; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functorObj_obj_comul","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nA : Comon_ (CategoryTheory.Functor C D)\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functorObj A).obj X).comul (A.comul.app X)","decl":"/--\nA comonoid object in a functor category induces a functor to the category of comonoid objects.\n-/\n@[simps]\ndef functorObj (A : Comon_ (C ⥤ D)) : C ⥤ Comon_ D where\n  obj X :=\n  { X := A.X.obj X\n    counit := A.counit.app X\n    comul := A.comul.app X\n    counit_comul := congr_app A.counit_comul X\n    comul_counit := congr_app A.comul_counit X\n    comul_assoc := congr_app A.comul_assoc X }\n  map f :=\n  { hom := A.X.map f\n    hom_counit := by dsimp; rw [A.counit.naturality, tensorUnit_map]; dsimp; rw [Category.comp_id]\n    hom_comul := by dsimp; rw [A.comul.naturality, tensorObj_map] }\n  map_id X := by ext; dsimp; rw [CategoryTheory.Functor.map_id]\n  map_comp f g := by ext; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functorObj_obj_X","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nA : Comon_ (CategoryTheory.Functor C D)\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functorObj A).obj X).X (A.X.obj X)","decl":"/--\nA comonoid object in a functor category induces a functor to the category of comonoid objects.\n-/\n@[simps]\ndef functorObj (A : Comon_ (C ⥤ D)) : C ⥤ Comon_ D where\n  obj X :=\n  { X := A.X.obj X\n    counit := A.counit.app X\n    comul := A.comul.app X\n    counit_comul := congr_app A.counit_comul X\n    comul_counit := congr_app A.comul_counit X\n    comul_assoc := congr_app A.comul_assoc X }\n  map f :=\n  { hom := A.X.map f\n    hom_counit := by dsimp; rw [A.counit.naturality, tensorUnit_map]; dsimp; rw [Category.comp_id]\n    hom_comul := by dsimp; rw [A.comul.naturality, tensorObj_map] }\n  map_id X := by ext; dsimp; rw [CategoryTheory.Functor.map_id]\n  map_comp f g := by ext; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functor_obj","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nA : Comon_ (CategoryTheory.Functor C D)\n⊢ Eq (CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functor.obj A) (CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functorObj A)","decl":"/-- Functor translating a comonoid object in a functor category\nto a functor into the category of comonoid objects.\n-/\n@[simps]\ndef functor : Comon_ (C ⥤ D) ⥤ C ⥤ Comon_ D where\n  obj := functorObj\n  map f :=\n  { app := fun X =>\n    { hom := f.hom.app X\n      hom_counit := congr_app f.hom_counit X\n      hom_comul := congr_app f.hom_comul X } }\n\n"}
{"name":"CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functor_map_app_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nX✝ Y✝ : Comon_ (CategoryTheory.Functor C D)\nf : Quiver.Hom X✝ Y✝\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functor.map f).app X).hom (f.hom.app X)","decl":"/-- Functor translating a comonoid object in a functor category\nto a functor into the category of comonoid objects.\n-/\n@[simps]\ndef functor : Comon_ (C ⥤ D) ⥤ C ⥤ Comon_ D where\n  obj := functorObj\n  map f :=\n  { app := fun X =>\n    { hom := f.hom.app X\n      hom_counit := congr_app f.hom_counit X\n      hom_comul := congr_app f.hom_comul X } }\n\n"}
{"name":"CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.inverseObj_comul_app","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C (Comon_ D)\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.inverseObj F).comul.app X) (F.obj X).comul","decl":"/-- A functor to the category of comonoid objects can be translated as a comonoid object\nin the functor category. -/\n@[simps]\ndef inverseObj (F : C ⥤ Comon_ D) : Comon_ (C ⥤ D) where\n  X := F ⋙ Comon_.forget D\n  counit := { app := fun X => (F.obj X).counit }\n  comul := { app := fun X => (F.obj X).comul }\n\n"}
{"name":"CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.inverseObj_counit_app","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C (Comon_ D)\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.inverseObj F).counit.app X) (F.obj X).counit","decl":"/-- A functor to the category of comonoid objects can be translated as a comonoid object\nin the functor category. -/\n@[simps]\ndef inverseObj (F : C ⥤ Comon_ D) : Comon_ (C ⥤ D) where\n  X := F ⋙ Comon_.forget D\n  counit := { app := fun X => (F.obj X).counit }\n  comul := { app := fun X => (F.obj X).comul }\n\n"}
{"name":"CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.inverseObj_X","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C (Comon_ D)\n⊢ Eq (CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.inverseObj F).X (F.comp (Comon_.forget D))","decl":"/-- A functor to the category of comonoid objects can be translated as a comonoid object\nin the functor category. -/\n@[simps]\ndef inverseObj (F : C ⥤ Comon_ D) : Comon_ (C ⥤ D) where\n  X := F ⋙ Comon_.forget D\n  counit := { app := fun X => (F.obj X).counit }\n  comul := { app := fun X => (F.obj X).comul }\n\n"}
{"name":"CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.counitIso_hom_app_app_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nX✝ : CategoryTheory.Functor C (Comon_ D)\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.counitIso.hom.app X✝).app X).hom (CategoryTheory.CategoryStruct.id (X✝.obj X).X)","decl":"/-- The counit for the equivalence `Mon_ (C ⥤ D) ≌ C ⥤ Mon_ D`.\n-/\n@[simps!]\ndef counitIso : inverse ⋙ functor ≅ 𝟭 (C ⥤ Comon_ D) :=\n  NatIso.ofComponents (fun A =>\n    NatIso.ofComponents (fun X => { hom := { hom := 𝟙 _ }, inv := { hom := 𝟙 _ } }) )\n\n"}
{"name":"CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.counitIso_inv_app_app_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nX✝ : CategoryTheory.Functor C (Comon_ D)\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.counitIso.inv.app X✝).app X).hom (CategoryTheory.CategoryStruct.id (X✝.obj X).X)","decl":"/-- The counit for the equivalence `Mon_ (C ⥤ D) ≌ C ⥤ Mon_ D`.\n-/\n@[simps!]\ndef counitIso : inverse ⋙ functor ≅ 𝟭 (C ⥤ Comon_ D) :=\n  NatIso.ofComponents (fun A =>\n    NatIso.ofComponents (fun X => { hom := { hom := 𝟙 _ }, inv := { hom := 𝟙 _ } }) )\n\n"}
{"name":"CategoryTheory.Monoidal.comonFunctorCategoryEquivalence_functor","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\n⊢ Eq (CategoryTheory.Monoidal.comonFunctorCategoryEquivalence C D).functor CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.functor","decl":"/-- When `D` is a monoidal category,\ncomonoid objects in `C ⥤ D` are the same thing\nas functors from `C` into the comonoid objects of `D`.\n-/\n@[simps]\ndef comonFunctorCategoryEquivalence : Comon_ (C ⥤ D) ≌ C ⥤ Comon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"CategoryTheory.Monoidal.comonFunctorCategoryEquivalence_counitIso","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\n⊢ Eq (CategoryTheory.Monoidal.comonFunctorCategoryEquivalence C D).counitIso CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.counitIso","decl":"/-- When `D` is a monoidal category,\ncomonoid objects in `C ⥤ D` are the same thing\nas functors from `C` into the comonoid objects of `D`.\n-/\n@[simps]\ndef comonFunctorCategoryEquivalence : Comon_ (C ⥤ D) ≌ C ⥤ Comon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"CategoryTheory.Monoidal.comonFunctorCategoryEquivalence_inverse","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\n⊢ Eq (CategoryTheory.Monoidal.comonFunctorCategoryEquivalence C D).inverse CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.inverse","decl":"/-- When `D` is a monoidal category,\ncomonoid objects in `C ⥤ D` are the same thing\nas functors from `C` into the comonoid objects of `D`.\n-/\n@[simps]\ndef comonFunctorCategoryEquivalence : Comon_ (C ⥤ D) ≌ C ⥤ Comon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"CategoryTheory.Monoidal.comonFunctorCategoryEquivalence_unitIso","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\n⊢ Eq (CategoryTheory.Monoidal.comonFunctorCategoryEquivalence C D).unitIso CategoryTheory.Monoidal.ComonFunctorCategoryEquivalence.unitIso","decl":"/-- When `D` is a monoidal category,\ncomonoid objects in `C ⥤ D` are the same thing\nas functors from `C` into the comonoid objects of `D`.\n-/\n@[simps]\ndef comonFunctorCategoryEquivalence : Comon_ (C ⥤ D) ≌ C ⥤ Comon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor_obj_obj_mul","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nA : CommMon_ (CategoryTheory.Functor C D)\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor.obj A).obj X).mul (A.mul.app X)","decl":"/-- Functor translating a commutative monoid object in a functor category\nto a functor into the category of commutative monoid objects.\n-/\n@[simps!]\ndef functor : CommMon_ (C ⥤ D) ⥤ C ⥤ CommMon_ D where\n  obj A :=\n    { (monFunctorCategoryEquivalence C D).functor.obj A.toMon_ with\n      obj := fun X =>\n        { ((monFunctorCategoryEquivalence C D).functor.obj A.toMon_).obj X with\n          mul_comm := congr_app A.mul_comm X } }\n  map f := { app := fun X => ((monFunctorCategoryEquivalence C D).functor.map f).app X }\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor_map_app_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nX✝ Y✝ : CommMon_ (CategoryTheory.Functor C D)\nf : Quiver.Hom X✝ Y✝\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor.map f).app X).hom (f.hom.app X)","decl":"/-- Functor translating a commutative monoid object in a functor category\nto a functor into the category of commutative monoid objects.\n-/\n@[simps!]\ndef functor : CommMon_ (C ⥤ D) ⥤ C ⥤ CommMon_ D where\n  obj A :=\n    { (monFunctorCategoryEquivalence C D).functor.obj A.toMon_ with\n      obj := fun X =>\n        { ((monFunctorCategoryEquivalence C D).functor.obj A.toMon_).obj X with\n          mul_comm := congr_app A.mul_comm X } }\n  map f := { app := fun X => ((monFunctorCategoryEquivalence C D).functor.map f).app X }\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor_obj_obj_X","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nA : CommMon_ (CategoryTheory.Functor C D)\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor.obj A).obj X).X (A.X.obj X)","decl":"/-- Functor translating a commutative monoid object in a functor category\nto a functor into the category of commutative monoid objects.\n-/\n@[simps!]\ndef functor : CommMon_ (C ⥤ D) ⥤ C ⥤ CommMon_ D where\n  obj A :=\n    { (monFunctorCategoryEquivalence C D).functor.obj A.toMon_ with\n      obj := fun X =>\n        { ((monFunctorCategoryEquivalence C D).functor.obj A.toMon_).obj X with\n          mul_comm := congr_app A.mul_comm X } }\n  map f := { app := fun X => ((monFunctorCategoryEquivalence C D).functor.map f).app X }\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor_obj_obj_one","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nA : CommMon_ (CategoryTheory.Functor C D)\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor.obj A).obj X).one (A.one.app X)","decl":"/-- Functor translating a commutative monoid object in a functor category\nto a functor into the category of commutative monoid objects.\n-/\n@[simps!]\ndef functor : CommMon_ (C ⥤ D) ⥤ C ⥤ CommMon_ D where\n  obj A :=\n    { (monFunctorCategoryEquivalence C D).functor.obj A.toMon_ with\n      obj := fun X =>\n        { ((monFunctorCategoryEquivalence C D).functor.obj A.toMon_).obj X with\n          mul_comm := congr_app A.mul_comm X } }\n  map f := { app := fun X => ((monFunctorCategoryEquivalence C D).functor.map f).app X }\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor_obj_map_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nA : CommMon_ (CategoryTheory.Functor C D)\nX Y : C\na✝ : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor.obj A).map a✝).hom (A.X.map a✝)","decl":"/-- Functor translating a commutative monoid object in a functor category\nto a functor into the category of commutative monoid objects.\n-/\n@[simps!]\ndef functor : CommMon_ (C ⥤ D) ⥤ C ⥤ CommMon_ D where\n  obj A :=\n    { (monFunctorCategoryEquivalence C D).functor.obj A.toMon_ with\n      obj := fun X =>\n        { ((monFunctorCategoryEquivalence C D).functor.obj A.toMon_).obj X with\n          mul_comm := congr_app A.mul_comm X } }\n  map f := { app := fun X => ((monFunctorCategoryEquivalence C D).functor.map f).app X }\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.inverse_obj_one_app","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nF : CategoryTheory.Functor C (CommMon_ D)\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.inverse.obj F).one.app X) (F.obj X).one","decl":"/-- Functor translating a functor into the category of commutative monoid objects\nto a commutative monoid object in the functor category\n-/\n@[simps!]\ndef inverse : (C ⥤ CommMon_ D) ⥤ CommMon_ (C ⥤ D) where\n  obj F :=\n    { (monFunctorCategoryEquivalence C D).inverse.obj (F ⋙ CommMon_.forget₂Mon_ D) with\n      mul_comm := by ext X; exact (F.obj X).mul_comm }\n  map α := (monFunctorCategoryEquivalence C D).inverse.map (whiskerRight α _)\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.inverse_obj_mul_app","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nF : CategoryTheory.Functor C (CommMon_ D)\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.inverse.obj F).mul.app X) (F.obj X).mul","decl":"/-- Functor translating a functor into the category of commutative monoid objects\nto a commutative monoid object in the functor category\n-/\n@[simps!]\ndef inverse : (C ⥤ CommMon_ D) ⥤ CommMon_ (C ⥤ D) where\n  obj F :=\n    { (monFunctorCategoryEquivalence C D).inverse.obj (F ⋙ CommMon_.forget₂Mon_ D) with\n      mul_comm := by ext X; exact (F.obj X).mul_comm }\n  map α := (monFunctorCategoryEquivalence C D).inverse.map (whiskerRight α _)\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.inverse_obj_X_map","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nF : CategoryTheory.Functor C (CommMon_ D)\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.inverse.obj F).X.map f) (F.map f).hom","decl":"/-- Functor translating a functor into the category of commutative monoid objects\nto a commutative monoid object in the functor category\n-/\n@[simps!]\ndef inverse : (C ⥤ CommMon_ D) ⥤ CommMon_ (C ⥤ D) where\n  obj F :=\n    { (monFunctorCategoryEquivalence C D).inverse.obj (F ⋙ CommMon_.forget₂Mon_ D) with\n      mul_comm := by ext X; exact (F.obj X).mul_comm }\n  map α := (monFunctorCategoryEquivalence C D).inverse.map (whiskerRight α _)\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.inverse_map_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nX✝ Y✝ : CategoryTheory.Functor C (CommMon_ D)\nα : Quiver.Hom X✝ Y✝\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.inverse.map α).hom.app X) (α.app X).hom","decl":"/-- Functor translating a functor into the category of commutative monoid objects\nto a commutative monoid object in the functor category\n-/\n@[simps!]\ndef inverse : (C ⥤ CommMon_ D) ⥤ CommMon_ (C ⥤ D) where\n  obj F :=\n    { (monFunctorCategoryEquivalence C D).inverse.obj (F ⋙ CommMon_.forget₂Mon_ D) with\n      mul_comm := by ext X; exact (F.obj X).mul_comm }\n  map α := (monFunctorCategoryEquivalence C D).inverse.map (whiskerRight α _)\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.inverse_obj_X_obj","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nF : CategoryTheory.Functor C (CommMon_ D)\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.inverse.obj F).X.obj X) ((CommMon_.forget₂Mon_ D).obj (F.obj X)).X","decl":"/-- Functor translating a functor into the category of commutative monoid objects\nto a commutative monoid object in the functor category\n-/\n@[simps!]\ndef inverse : (C ⥤ CommMon_ D) ⥤ CommMon_ (C ⥤ D) where\n  obj F :=\n    { (monFunctorCategoryEquivalence C D).inverse.obj (F ⋙ CommMon_.forget₂Mon_ D) with\n      mul_comm := by ext X; exact (F.obj X).mul_comm }\n  map α := (monFunctorCategoryEquivalence C D).inverse.map (whiskerRight α _)\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.unitIso_hom_app_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nX : CommMon_ (CategoryTheory.Functor C D)\nx✝ : C\n⊢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.unitIso.hom.app X).hom.app x✝) (CategoryTheory.CategoryStruct.id (X.X.obj x✝))","decl":"/-- The unit for the equivalence `CommMon_ (C ⥤ D) ≌ C ⥤ CommMon_ D`.\n-/\n@[simps!]\ndef unitIso : 𝟭 (CommMon_ (C ⥤ D)) ≅ functor ⋙ inverse :=\n  NatIso.ofComponents (fun A =>\n  { hom := { hom := { app := fun _ => 𝟙 _ }  }\n    inv := { hom := { app := fun _ => 𝟙 _ }  } })\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.unitIso_inv_app_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nX : CommMon_ (CategoryTheory.Functor C D)\nx✝ : C\n⊢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.unitIso.inv.app X).hom.app x✝) (CategoryTheory.CategoryStruct.id ((CommMon_.forget₂Mon_ D).obj ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor.obj X).obj x✝)).X)","decl":"/-- The unit for the equivalence `CommMon_ (C ⥤ D) ≌ C ⥤ CommMon_ D`.\n-/\n@[simps!]\ndef unitIso : 𝟭 (CommMon_ (C ⥤ D)) ≅ functor ⋙ inverse :=\n  NatIso.ofComponents (fun A =>\n  { hom := { hom := { app := fun _ => 𝟙 _ }  }\n    inv := { hom := { app := fun _ => 𝟙 _ }  } })\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.counitIso_inv_app_app_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nX✝ : CategoryTheory.Functor C (CommMon_ D)\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.counitIso.inv.app X✝).app X).hom (CategoryTheory.CategoryStruct.id (X✝.obj X).X)","decl":"/-- The counit for the equivalence `CommMon_ (C ⥤ D) ≌ C ⥤ CommMon_ D`.\n-/\n@[simps!]\ndef counitIso : inverse ⋙ functor ≅ 𝟭 (C ⥤ CommMon_ D) :=\n  NatIso.ofComponents (fun A =>\n    NatIso.ofComponents (fun X => { hom := { hom := 𝟙 _ }, inv := { hom := 𝟙 _ } }) )\n\n"}
{"name":"CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.counitIso_hom_app_app_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nX✝ : CategoryTheory.Functor C (CommMon_ D)\nX : C\n⊢ Eq ((CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.counitIso.hom.app X✝).app X).hom (CategoryTheory.CategoryStruct.id ((CommMon_.forget₂Mon_ D).obj (X✝.obj X)).X)","decl":"/-- The counit for the equivalence `CommMon_ (C ⥤ D) ≌ C ⥤ CommMon_ D`.\n-/\n@[simps!]\ndef counitIso : inverse ⋙ functor ≅ 𝟭 (C ⥤ CommMon_ D) :=\n  NatIso.ofComponents (fun A =>\n    NatIso.ofComponents (fun X => { hom := { hom := 𝟙 _ }, inv := { hom := 𝟙 _ } }) )\n\n"}
{"name":"CategoryTheory.Monoidal.commMonFunctorCategoryEquivalence_counitIso","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\n⊢ Eq (CategoryTheory.Monoidal.commMonFunctorCategoryEquivalence C D).counitIso CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.counitIso","decl":"/-- When `D` is a braided monoidal category,\ncommutative monoid objects in `C ⥤ D` are the same thing\nas functors from `C` into the commutative monoid objects of `D`.\n-/\n@[simps]\ndef commMonFunctorCategoryEquivalence : CommMon_ (C ⥤ D) ≌ C ⥤ CommMon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"CategoryTheory.Monoidal.commMonFunctorCategoryEquivalence_unitIso","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\n⊢ Eq (CategoryTheory.Monoidal.commMonFunctorCategoryEquivalence C D).unitIso CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.unitIso","decl":"/-- When `D` is a braided monoidal category,\ncommutative monoid objects in `C ⥤ D` are the same thing\nas functors from `C` into the commutative monoid objects of `D`.\n-/\n@[simps]\ndef commMonFunctorCategoryEquivalence : CommMon_ (C ⥤ D) ≌ C ⥤ CommMon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"CategoryTheory.Monoidal.commMonFunctorCategoryEquivalence_functor","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\n⊢ Eq (CategoryTheory.Monoidal.commMonFunctorCategoryEquivalence C D).functor CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor","decl":"/-- When `D` is a braided monoidal category,\ncommutative monoid objects in `C ⥤ D` are the same thing\nas functors from `C` into the commutative monoid objects of `D`.\n-/\n@[simps]\ndef commMonFunctorCategoryEquivalence : CommMon_ (C ⥤ D) ≌ C ⥤ CommMon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"CategoryTheory.Monoidal.commMonFunctorCategoryEquivalence_inverse","module":"Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\n⊢ Eq (CategoryTheory.Monoidal.commMonFunctorCategoryEquivalence C D).inverse CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.inverse","decl":"/-- When `D` is a braided monoidal category,\ncommutative monoid objects in `C ⥤ D` are the same thing\nas functors from `C` into the commutative monoid objects of `D`.\n-/\n@[simps]\ndef commMonFunctorCategoryEquivalence : CommMon_ (C ⥤ D) ≌ C ⥤ CommMon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
