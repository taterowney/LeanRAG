{"name":"T2Space.t2","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nself : T2Space X\nâŠ¢ Pairwise fun x y => Exists fun u => Exists fun v => And (IsOpen u) (And (IsOpen v) (And (Membership.mem u x) (And (Membership.mem v y) (Disjoint u v))))","decl":"/-- A Tâ‚‚ space, also known as a Hausdorff space, is one in which for every\n  `x â‰  y` there exists disjoint open sets around `x` and `y`. This is\n  the most widely used of the separation axioms. -/\n@[mk_iff]\nclass T2Space (X : Type u) [TopologicalSpace X] : Prop where\n  /-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\n  t2 : Pairwise fun x y => âˆƒ u v : Set X, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v\n\n"}
{"name":"t2Space_iff","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ Iff (T2Space X) (Pairwise fun x y => Exists fun u => Exists fun v => And (IsOpen u) (And (IsOpen v) (And (Membership.mem u x) (And (Membership.mem v y) (Disjoint u v)))))","decl":"/-- A Tâ‚‚ space, also known as a Hausdorff space, is one in which for every\n  `x â‰  y` there exists disjoint open sets around `x` and `y`. This is\n  the most widely used of the separation axioms. -/\n@[mk_iff]\nclass T2Space (X : Type u) [TopologicalSpace X] : Prop where\n  /-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\n  t2 : Pairwise fun x y => âˆƒ u v : Set X, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v\n\n"}
{"name":"t2_separation","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\nx y : X\nh : Ne x y\nâŠ¢ Exists fun u => Exists fun v => And (IsOpen u) (And (IsOpen v) (And (Membership.mem u x) (And (Membership.mem v y) (Disjoint u v))))","decl":"/-- Two different points can be separated by open sets. -/\ntheorem t2_separation [T2Space X] {x y : X} (h : x â‰  y) :\n    âˆƒ u v : Set X, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v :=\n  T2Space.t2 h\n\n-- todo: use this as a definition?\n"}
{"name":"t2Space_iff_disjoint_nhds","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nâŠ¢ Iff (T2Space X) (Pairwise fun x y => Disjoint (nhds x) (nhds y))","decl":"theorem t2Space_iff_disjoint_nhds : T2Space X â†” Pairwise fun x y : X => Disjoint (ğ“ x) (ğ“ y) := by\n  refine (t2Space_iff X).trans (forallâ‚ƒ_congr fun x y _ => ?_)\n  simp only [(nhds_basis_opens x).disjoint_iff (nhds_basis_opens y), exists_prop, â† exists_and_left,\n    and_assoc, and_comm, and_left_comm]\n\n"}
{"name":"disjoint_nhds_nhds","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\nx y : X\nâŠ¢ Iff (Disjoint (nhds x) (nhds y)) (Ne x y)","decl":"@[simp]\ntheorem disjoint_nhds_nhds [T2Space X] {x y : X} : Disjoint (ğ“ x) (ğ“ y) â†” x â‰  y :=\n  âŸ¨fun hd he => by simp [he, nhds_neBot.ne] at hd, (t2Space_iff_disjoint_nhds.mp â€¹_â€º Â·)âŸ©\n\n"}
{"name":"pairwise_disjoint_nhds","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\nâŠ¢ Pairwise (Function.onFun Disjoint nhds)","decl":"theorem pairwise_disjoint_nhds [T2Space X] : Pairwise (Disjoint on (ğ“ : X â†’ Filter X)) := fun _ _ =>\n  disjoint_nhds_nhds.2\n\n"}
{"name":"Set.pairwiseDisjoint_nhds","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\ns : Set X\nâŠ¢ s.PairwiseDisjoint nhds","decl":"protected theorem Set.pairwiseDisjoint_nhds [T2Space X] (s : Set X) : s.PairwiseDisjoint ğ“ :=\n  pairwise_disjoint_nhds.set_pairwise s\n\n"}
{"name":"Set.Finite.t2_separation","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\ns : Set X\nhs : s.Finite\nâŠ¢ Exists fun U => And (âˆ€ (x : X), And (Membership.mem (U x) x) (IsOpen (U x))) (s.PairwiseDisjoint U)","decl":"/-- Points of a finite set can be separated by open sets from each other. -/\ntheorem Set.Finite.t2_separation [T2Space X] {s : Set X} (hs : s.Finite) :\n    âˆƒ U : X â†’ Set X, (âˆ€ x, x âˆˆ U x âˆ§ IsOpen (U x)) âˆ§ s.PairwiseDisjoint U :=\n  s.pairwiseDisjoint_nhds.exists_mem_filter_basis hs nhds_basis_opens\n\n-- see Note [lower instance priority]\n"}
{"name":"T2Space.t1Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\nâŠ¢ T1Space X","decl":"instance (priority := 100) T2Space.t1Space [T2Space X] : T1Space X :=\n  t1Space_iff_disjoint_pure_nhds.mpr fun _ _ hne =>\n    (disjoint_nhds_nhds.2 hne).mono_left <| pure_le_nhds _\n\n-- see Note [lower instance priority]\n"}
{"name":"T2Space.r1Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\nâŠ¢ R1Space X","decl":"instance (priority := 100) T2Space.r1Space [T2Space X] : R1Space X :=\n  âŸ¨fun x y â†¦ (eq_or_ne x y).imp specializes_of_eq disjoint_nhds_nhds.2âŸ©\n\n"}
{"name":"SeparationQuotient.t2Space_iff","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nâŠ¢ Iff (T2Space (SeparationQuotient X)) (R1Space X)","decl":"theorem SeparationQuotient.t2Space_iff : T2Space (SeparationQuotient X) â†” R1Space X := by\n  simp only [t2Space_iff_disjoint_nhds, Pairwise, surjective_mk.forallâ‚‚, ne_eq, mk_eq_mk,\n    r1Space_iff_inseparable_or_disjoint_nhds, â† disjoint_comap_iff surjective_mk, comap_mk_nhds_mk,\n    â† or_iff_not_imp_left]\n\n"}
{"name":"SeparationQuotient.t2Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : R1Space X\nâŠ¢ T2Space (SeparationQuotient X)","decl":"instance SeparationQuotient.t2Space [R1Space X] : T2Space (SeparationQuotient X) :=\n  t2Space_iff.2 â€¹_â€º\n\n"}
{"name":"instT2SpaceOfR1SpaceOfT0Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : R1Space X\ninstâœ : T0Space X\nâŠ¢ T2Space X","decl":"instance (priority := 80) [R1Space X] [T0Space X] : T2Space X :=\n  t2Space_iff_disjoint_nhds.2 fun _x _y hne â†¦ disjoint_nhds_nhds_iff_not_inseparable.2 fun hxy â†¦\n    hne hxy.eq\n\n"}
{"name":"R1Space.t2Space_iff_t0Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : R1Space X\nâŠ¢ Iff (T2Space X) (T0Space X)","decl":"theorem R1Space.t2Space_iff_t0Space [R1Space X] : T2Space X â†” T0Space X := by\n  constructor <;> intro <;> infer_instance\n\n"}
{"name":"t2_iff_nhds","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nâŠ¢ Iff (T2Space X) (âˆ€ {x y : X}, (Min.min (nhds x) (nhds y)).NeBot â†’ Eq x y)","decl":"/-- A space is Tâ‚‚ iff the neighbourhoods of distinct points generate the bottom filter. -/\ntheorem t2_iff_nhds : T2Space X â†” âˆ€ {x y : X}, NeBot (ğ“ x âŠ“ ğ“ y) â†’ x = y := by\n  simp only [t2Space_iff_disjoint_nhds, disjoint_iff, neBot_iff, Ne, not_imp_comm, Pairwise]\n\n"}
{"name":"eq_of_nhds_neBot","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\nx y : X\nh : (Min.min (nhds x) (nhds y)).NeBot\nâŠ¢ Eq x y","decl":"theorem eq_of_nhds_neBot [T2Space X] {x y : X} (h : NeBot (ğ“ x âŠ“ ğ“ y)) : x = y :=\n  t2_iff_nhds.mp â€¹_â€º h\n\n"}
{"name":"t2Space_iff_nhds","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nâŠ¢ Iff (T2Space X) (Pairwise fun x y => Exists fun U => And (Membership.mem (nhds x) U) (Exists fun V => And (Membership.mem (nhds y) V) (Disjoint U V)))","decl":"theorem t2Space_iff_nhds :\n    T2Space X â†” Pairwise fun x y : X => âˆƒ U âˆˆ ğ“ x, âˆƒ V âˆˆ ğ“ y, Disjoint U V := by\n  simp only [t2Space_iff_disjoint_nhds, Filter.disjoint_iff, Pairwise]\n\n"}
{"name":"t2_separation_nhds","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\nx y : X\nh : Ne x y\nâŠ¢ Exists fun u => Exists fun v => And (Membership.mem (nhds x) u) (And (Membership.mem (nhds y) v) (Disjoint u v))","decl":"theorem t2_separation_nhds [T2Space X] {x y : X} (h : x â‰  y) :\n    âˆƒ u v, u âˆˆ ğ“ x âˆ§ v âˆˆ ğ“ y âˆ§ Disjoint u v :=\n  let âŸ¨u, v, open_u, open_v, x_in, y_in, huvâŸ© := t2_separation h\n  âŸ¨u, v, open_u.mem_nhds x_in, open_v.mem_nhds y_in, huvâŸ©\n\n"}
{"name":"t2_separation_compact_nhds","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : LocallyCompactSpace X\ninstâœ : T2Space X\nx y : X\nh : Ne x y\nâŠ¢ Exists fun u => Exists fun v => And (Membership.mem (nhds x) u) (And (Membership.mem (nhds y) v) (And (IsCompact u) (And (IsCompact v) (Disjoint u v))))","decl":"theorem t2_separation_compact_nhds [LocallyCompactSpace X] [T2Space X] {x y : X} (h : x â‰  y) :\n    âˆƒ u v, u âˆˆ ğ“ x âˆ§ v âˆˆ ğ“ y âˆ§ IsCompact u âˆ§ IsCompact v âˆ§ Disjoint u v := by\n  simpa only [exists_prop, â† exists_and_left, and_comm, and_assoc, and_left_comm] using\n    ((compact_basis_nhds x).disjoint_iff (compact_basis_nhds y)).1 (disjoint_nhds_nhds.2 h)\n\n"}
{"name":"t2_iff_ultrafilter","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nâŠ¢ Iff (T2Space X) (âˆ€ {x y : X} (f : Ultrafilter X), LE.le (â†‘f) (nhds x) â†’ LE.le (â†‘f) (nhds y) â†’ Eq x y)","decl":"theorem t2_iff_ultrafilter :\n    T2Space X â†” âˆ€ {x y : X} (f : Ultrafilter X), â†‘f â‰¤ ğ“ x â†’ â†‘f â‰¤ ğ“ y â†’ x = y :=\n  t2_iff_nhds.trans <| by simp only [â† exists_ultrafilter_iff, and_imp, le_inf_iff, exists_imp]\n\n"}
{"name":"t2_iff_isClosed_diagonal","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nâŠ¢ Iff (T2Space X) (IsClosed (Set.diagonal X))","decl":"theorem t2_iff_isClosed_diagonal : T2Space X â†” IsClosed (diagonal X) := by\n  simp only [t2Space_iff_disjoint_nhds, â† isOpen_compl_iff, isOpen_iff_mem_nhds, Prod.forall,\n    nhds_prod_eq, compl_diagonal_mem_prod, mem_compl_iff, mem_diagonal_iff, Pairwise]\n\n"}
{"name":"isClosed_diagonal","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\nâŠ¢ IsClosed (Set.diagonal X)","decl":"theorem isClosed_diagonal [T2Space X] : IsClosed (diagonal X) :=\n  t2_iff_isClosed_diagonal.mp â€¹_â€º\n\n-- Porting note: 2 lemmas moved below\n\n"}
{"name":"tendsto_nhds_unique","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : T2Space X\nf : Y â†’ X\nl : Filter Y\na b : X\ninstâœ : l.NeBot\nha : Filter.Tendsto f l (nhds a)\nhb : Filter.Tendsto f l (nhds b)\nâŠ¢ Eq a b","decl":"theorem tendsto_nhds_unique [T2Space X] {f : Y â†’ X} {l : Filter Y} {a b : X} [NeBot l]\n    (ha : Tendsto f l (ğ“ a)) (hb : Tendsto f l (ğ“ b)) : a = b :=\n  (tendsto_nhds_unique_inseparable ha hb).eq\n\n"}
{"name":"tendsto_nhds_unique'","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\nf : Y â†’ X\nl : Filter Y\na b : X\nxâœ : l.NeBot\nha : Filter.Tendsto f l (nhds a)\nhb : Filter.Tendsto f l (nhds b)\nâŠ¢ Eq a b","decl":"theorem tendsto_nhds_unique' [T2Space X] {f : Y â†’ X} {l : Filter Y} {a b : X} (_ : NeBot l)\n    (ha : Tendsto f l (ğ“ a)) (hb : Tendsto f l (ğ“ b)) : a = b :=\n  tendsto_nhds_unique ha hb\n\n"}
{"name":"tendsto_nhds_unique_of_eventuallyEq","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : T2Space X\nf g : Y â†’ X\nl : Filter Y\na b : X\ninstâœ : l.NeBot\nha : Filter.Tendsto f l (nhds a)\nhb : Filter.Tendsto g l (nhds b)\nhfg : l.EventuallyEq f g\nâŠ¢ Eq a b","decl":"theorem tendsto_nhds_unique_of_eventuallyEq [T2Space X] {f g : Y â†’ X} {l : Filter Y} {a b : X}\n    [NeBot l] (ha : Tendsto f l (ğ“ a)) (hb : Tendsto g l (ğ“ b)) (hfg : f =á¶ [l] g) : a = b :=\n  tendsto_nhds_unique (ha.congr' hfg) hb\n\n"}
{"name":"tendsto_nhds_unique_of_frequently_eq","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\nf g : Y â†’ X\nl : Filter Y\na b : X\nha : Filter.Tendsto f l (nhds a)\nhb : Filter.Tendsto g l (nhds b)\nhfg : Filter.Frequently (fun x => Eq (f x) (g x)) l\nâŠ¢ Eq a b","decl":"theorem tendsto_nhds_unique_of_frequently_eq [T2Space X] {f g : Y â†’ X} {l : Filter Y} {a b : X}\n    (ha : Tendsto f l (ğ“ a)) (hb : Tendsto g l (ğ“ b)) (hfg : âˆƒá¶  x in l, f x = g x) : a = b :=\n  have : âˆƒá¶  z : X Ã— X in ğ“ (a, b), z.1 = z.2 := (ha.prod_mk_nhds hb).frequently hfg\n  not_not.1 fun hne => this (isClosed_diagonal.isOpen_compl.mem_nhds hne)\n\n"}
{"name":"IsCompact.nhdsSet_inter_eq","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\ns t : Set X\nhs : IsCompact s\nht : IsCompact t\nâŠ¢ Eq (nhdsSet (Inter.inter s t)) (Min.min (nhdsSet s) (nhdsSet t))","decl":"/-- If `s` and `t` are compact sets in a Tâ‚‚ space, then the set neighborhoods filter of `s âˆ© t`\nis the infimum of set neighborhoods filters for `s` and `t`.\n\nFor general sets, only the `â‰¤` inequality holds, see `nhdsSet_inter_le`. -/\ntheorem IsCompact.nhdsSet_inter_eq [T2Space X] {s t : Set X} (hs : IsCompact s) (ht : IsCompact t) :\n    ğ“Ë¢ (s âˆ© t) = ğ“Ë¢ s âŠ“ ğ“Ë¢ t := by\n  refine le_antisymm (nhdsSet_inter_le _ _) ?_\n  simp_rw [hs.nhdsSet_inf_eq_biSup, ht.inf_nhdsSet_eq_biSup, nhdsSet, sSup_image]\n  refine iSupâ‚‚_le fun x hxs â†¦ iSupâ‚‚_le fun y hyt â†¦ ?_\n  rcases eq_or_ne x y with (rfl|hne)\n  Â· exact le_iSupâ‚‚_of_le x âŸ¨hxs, hytâŸ© (inf_idem _).le\n  Â· exact (disjoint_nhds_nhds.mpr hne).eq_bot â–¸ bot_le\n\n"}
{"name":"IsCompact.separation_of_not_mem","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\nx : X\nt : Set X\nH1 : IsCompact t\nH2 : Not (Membership.mem t x)\nâŠ¢ Exists fun U => Exists fun V => And (IsOpen U) (And (IsOpen V) (And (HasSubset.Subset t U) (And (Membership.mem V x) (Disjoint U V))))","decl":"/-- In a `T2Space X`, for a compact set `t` and a point `x` outside `t`, there are open sets `U`,\n`V` that separate `t` and `x`.-/\nlemma IsCompact.separation_of_not_mem {X : Type u_1} [TopologicalSpace X] [T2Space X] {x : X}\n    {t : Set X} (H1 : IsCompact t) (H2 : x âˆ‰ t) :\n    âˆƒ (U : Set X), âˆƒ (V : Set X), IsOpen U âˆ§ IsOpen V âˆ§ t âŠ† U âˆ§ x âˆˆ V âˆ§ Disjoint U V := by\n  simpa [SeparatedNhds] using SeparatedNhds.of_isCompact_isCompact_isClosed H1 isCompact_singleton\n    isClosed_singleton <| disjoint_singleton_right.mpr H2\n\n"}
{"name":"IsCompact.disjoint_nhdsSet_nhds","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\nx : X\nt : Set X\nH1 : IsCompact t\nH2 : Not (Membership.mem t x)\nâŠ¢ Disjoint (nhdsSet t) (nhds x)","decl":"/-- In a `T2Space X`, for a compact set `t` and a point `x` outside `t`, `ğ“Ë¢ t` and `ğ“ x` are\ndisjoint. -/\nlemma IsCompact.disjoint_nhdsSet_nhds {X : Type u_1} [TopologicalSpace X] [T2Space X] {x : X}\n    {t : Set X} (H1 : IsCompact t) (H2 : x âˆ‰ t) :\n    Disjoint (ğ“Ë¢ t) (ğ“ x) := by\n  simpa using SeparatedNhds.disjoint_nhdsSet <| .of_isCompact_isCompact_isClosed H1\n    isCompact_singleton isClosed_singleton <| disjoint_singleton_right.mpr H2\n\n"}
{"name":"Set.InjOn.exists_mem_nhdsSet","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_3\nY : Type u_4\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : T2Space Y\nf : X â†’ Y\ns : Set X\ninj : Set.InjOn f s\nsc : IsCompact s\nfc : âˆ€ (x : X), Membership.mem s x â†’ ContinuousAt f x\nloc : âˆ€ (x : X), Membership.mem s x â†’ Exists fun u => And (Membership.mem (nhds x) u) (Set.InjOn f u)\nâŠ¢ Exists fun t => And (Membership.mem (nhdsSet s) t) (Set.InjOn f t)","decl":"/-- If a function `f` is\n\n- injective on a compact set `s`;\n- continuous at every point of this set;\n- injective on a neighborhood of each point of this set,\n\nthen it is injective on a neighborhood of this set. -/\ntheorem Set.InjOn.exists_mem_nhdsSet {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    [T2Space Y] {f : X â†’ Y} {s : Set X} (inj : InjOn f s) (sc : IsCompact s)\n    (fc : âˆ€ x âˆˆ s, ContinuousAt f x) (loc : âˆ€ x âˆˆ s, âˆƒ u âˆˆ ğ“ x, InjOn f u) :\n    âˆƒ t âˆˆ ğ“Ë¢ s, InjOn f t := by\n  have : âˆ€ x âˆˆ s Ã—Ë¢ s, âˆ€á¶  y in ğ“ x, f y.1 = f y.2 â†’ y.1 = y.2 := fun (x, y) âŸ¨hx, hyâŸ© â†¦ by\n    rcases eq_or_ne x y with rfl | hne\n    Â· rcases loc x hx with âŸ¨u, hu, hfâŸ©\n      exact Filter.mem_of_superset (prod_mem_nhds hu hu) <| forall_prod_set.2 hf\n    Â· suffices âˆ€á¶  z in ğ“ (x, y), f z.1 â‰  f z.2 from this.mono fun _ hne h â†¦ absurd h hne\n      refine (fc x hx).prodMap' (fc y hy) <| isClosed_diagonal.isOpen_compl.mem_nhds ?_\n      exact inj.ne hx hy hne\n  rw [â† eventually_nhdsSet_iff_forall, sc.nhdsSet_prod_eq sc] at this\n  exact eventually_prod_self_iff.1 this\n\n"}
{"name":"Set.InjOn.exists_isOpen_superset","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_3\nY : Type u_4\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : T2Space Y\nf : X â†’ Y\ns : Set X\ninj : Set.InjOn f s\nsc : IsCompact s\nfc : âˆ€ (x : X), Membership.mem s x â†’ ContinuousAt f x\nloc : âˆ€ (x : X), Membership.mem s x â†’ Exists fun u => And (Membership.mem (nhds x) u) (Set.InjOn f u)\nâŠ¢ Exists fun t => And (IsOpen t) (And (HasSubset.Subset s t) (Set.InjOn f t))","decl":"/-- If a function `f` is\n\n- injective on a compact set `s`;\n- continuous at every point of this set;\n- injective on a neighborhood of each point of this set,\n\nthen it is injective on an open neighborhood of this set. -/\ntheorem Set.InjOn.exists_isOpen_superset {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    [T2Space Y] {f : X â†’ Y} {s : Set X} (inj : InjOn f s) (sc : IsCompact s)\n    (fc : âˆ€ x âˆˆ s, ContinuousAt f x) (loc : âˆ€ x âˆˆ s, âˆƒ u âˆˆ ğ“ x, InjOn f u) :\n    âˆƒ t, IsOpen t âˆ§ s âŠ† t âˆ§ InjOn f t :=\n  let âŸ¨_t, hst, htâŸ© := inj.exists_mem_nhdsSet sc fc loc\n  let âŸ¨u, huo, hsu, hutâŸ© := mem_nhdsSet_iff_exists.1 hst\n  âŸ¨u, huo, hsu, ht.mono hutâŸ©\n\n"}
{"name":"lim_eq","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : T2Space X\nf : Filter X\nx : X\ninstâœ : f.NeBot\nh : LE.le f (nhds x)\nâŠ¢ Eq (lim f) x","decl":"theorem lim_eq {x : X} [NeBot f] (h : f â‰¤ ğ“ x) : @lim _ _ âŸ¨xâŸ© f = x :=\n  tendsto_nhds_unique (le_nhds_lim âŸ¨x, hâŸ©) h\n\n"}
{"name":"lim_eq_iff","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : T2Space X\nf : Filter X\ninstâœ : f.NeBot\nh : Exists fun x => LE.le f (nhds x)\nx : X\nâŠ¢ Iff (Eq (lim f) x) (LE.le f (nhds x))","decl":"theorem lim_eq_iff [NeBot f] (h : âˆƒ x : X, f â‰¤ ğ“ x) {x} : @lim _ _ âŸ¨xâŸ© f = x â†” f â‰¤ ğ“ x :=\n  âŸ¨fun c => c â–¸ le_nhds_lim h, lim_eqâŸ©\n\n"}
{"name":"Ultrafilter.lim_eq_iff_le_nhds","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : T2Space X\ninstâœ : CompactSpace X\nx : X\nF : Ultrafilter X\nâŠ¢ Iff (Eq F.lim x) (LE.le (â†‘F) (nhds x))","decl":"theorem Ultrafilter.lim_eq_iff_le_nhds [CompactSpace X] {x : X} {F : Ultrafilter X} :\n    F.lim = x â†” â†‘F â‰¤ ğ“ x :=\n  âŸ¨fun h => h â–¸ F.le_nhds_lim, lim_eqâŸ©\n\n"}
{"name":"isOpen_iff_ultrafilter'","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : T2Space X\ninstâœ : CompactSpace X\nU : Set X\nâŠ¢ Iff (IsOpen U) (âˆ€ (F : Ultrafilter X), Membership.mem U F.lim â†’ Membership.mem (â†‘F) U)","decl":"theorem isOpen_iff_ultrafilter' [CompactSpace X] (U : Set X) :\n    IsOpen U â†” âˆ€ F : Ultrafilter X, F.lim âˆˆ U â†’ U âˆˆ F.1 := by\n  rw [isOpen_iff_ultrafilter]\n  refine âŸ¨fun h F hF => h F.lim hF F F.le_nhds_lim, ?_âŸ©\n  intro cond x hx f h\n  rw [â† Ultrafilter.lim_eq_iff_le_nhds.2 h] at hx\n  exact cond _ hx\n\n"}
{"name":"Filter.Tendsto.limUnder_eq","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : T2Space X\nx : X\nf : Filter Y\ninstâœ : f.NeBot\ng : Y â†’ X\nh : Filter.Tendsto g f (nhds x)\nâŠ¢ Eq (limUnder f g) x","decl":"theorem Filter.Tendsto.limUnder_eq {x : X} {f : Filter Y} [NeBot f] {g : Y â†’ X}\n    (h : Tendsto g f (ğ“ x)) : @limUnder _ _ _ âŸ¨xâŸ© f g = x :=\n  lim_eq h\n\n"}
{"name":"Filter.limUnder_eq_iff","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : T2Space X\nf : Filter Y\ninstâœ : f.NeBot\ng : Y â†’ X\nh : Exists fun x => Filter.Tendsto g f (nhds x)\nx : X\nâŠ¢ Iff (Eq (limUnder f g) x) (Filter.Tendsto g f (nhds x))","decl":"theorem Filter.limUnder_eq_iff {f : Filter Y} [NeBot f] {g : Y â†’ X} (h : âˆƒ x, Tendsto g f (ğ“ x))\n    {x} : @limUnder _ _ _ âŸ¨xâŸ© f g = x â†” Tendsto g f (ğ“ x) :=\n  âŸ¨fun c => c â–¸ tendsto_nhds_limUnder h, Filter.Tendsto.limUnder_eqâŸ©\n\n"}
{"name":"Continuous.limUnder_eq","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : T2Space X\ninstâœ : TopologicalSpace Y\nf : Y â†’ X\nh : Continuous f\ny : Y\nâŠ¢ Eq (limUnder (nhds y) f) (f y)","decl":"theorem Continuous.limUnder_eq [TopologicalSpace Y] {f : Y â†’ X} (h : Continuous f) (y : Y) :\n    @limUnder _ _ _ âŸ¨f yâŸ© (ğ“ y) f = f y :=\n  (h.tendsto y).limUnder_eq\n\n"}
{"name":"lim_nhds","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\nx : X\nâŠ¢ Eq (lim (nhds x)) x","decl":"@[simp]\ntheorem lim_nhds (x : X) : @lim _ _ âŸ¨xâŸ© (ğ“ x) = x :=\n  lim_eq le_rfl\n\n"}
{"name":"limUnder_nhds_id","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\nx : X\nâŠ¢ Eq (limUnder (nhds x) id) x","decl":"@[simp]\ntheorem limUnder_nhds_id (x : X) : @limUnder _ _ _ âŸ¨xâŸ© (ğ“ x) id = x :=\n  lim_nhds x\n\n"}
{"name":"lim_nhdsWithin","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\nx : X\ns : Set X\nh : Membership.mem (closure s) x\nâŠ¢ Eq (lim (nhdsWithin x s)) x","decl":"@[simp]\ntheorem lim_nhdsWithin {x : X} {s : Set X} (h : x âˆˆ closure s) : @lim _ _ âŸ¨xâŸ© (ğ“[s] x) = x :=\n  haveI : NeBot (ğ“[s] x) := mem_closure_iff_clusterPt.1 h\n  lim_eq inf_le_left\n\n"}
{"name":"limUnder_nhdsWithin_id","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\nx : X\ns : Set X\nh : Membership.mem (closure s) x\nâŠ¢ Eq (limUnder (nhdsWithin x s) id) x","decl":"@[simp]\ntheorem limUnder_nhdsWithin_id {x : X} {s : Set X} (h : x âˆˆ closure s) :\n    @limUnder _ _ _ âŸ¨xâŸ© (ğ“[s] x) id = x :=\n  lim_nhdsWithin h\n\n"}
{"name":"DiscreteTopology.toT2Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : DiscreteTopology X\nâŠ¢ T2Space X","decl":"instance (priority := 100) DiscreteTopology.toT2Space\n    [DiscreteTopology X] : T2Space X :=\n  âŸ¨fun x y h => âŸ¨{x}, {y}, isOpen_discrete _, isOpen_discrete _, rfl, rfl, disjoint_singleton.2 hâŸ©âŸ©\n\n"}
{"name":"separated_by_continuous","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : T2Space Y\nf : X â†’ Y\nhf : Continuous f\nx y : X\nh : Ne (f x) (f y)\nâŠ¢ Exists fun u => Exists fun v => And (IsOpen u) (And (IsOpen v) (And (Membership.mem u x) (And (Membership.mem v y) (Disjoint u v))))","decl":"theorem separated_by_continuous [TopologicalSpace Y] [T2Space Y]\n    {f : X â†’ Y} (hf : Continuous f) {x y : X} (h : f x â‰  f y) :\n    âˆƒ u v : Set X, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v :=\n  let âŸ¨u, v, uo, vo, xu, yv, uvâŸ© := t2_separation h\n  âŸ¨f â»Â¹' u, f â»Â¹' v, uo.preimage hf, vo.preimage hf, xu, yv, uv.preimage _âŸ©\n\n"}
{"name":"separated_by_isOpenEmbedding","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : T2Space X\nf : X â†’ Y\nhf : Topology.IsOpenEmbedding f\nx y : X\nh : Ne x y\nâŠ¢ Exists fun u => Exists fun v => And (IsOpen u) (And (IsOpen v) (And (Membership.mem u (f x)) (And (Membership.mem v (f y)) (Disjoint u v))))","decl":"theorem separated_by_isOpenEmbedding [TopologicalSpace Y] [T2Space X]\n    {f : X â†’ Y} (hf : IsOpenEmbedding f) {x y : X} (h : x â‰  y) :\n    âˆƒ u v : Set Y, IsOpen u âˆ§ IsOpen v âˆ§ f x âˆˆ u âˆ§ f y âˆˆ v âˆ§ Disjoint u v :=\n  let âŸ¨u, v, uo, vo, xu, yv, uvâŸ© := t2_separation h\n  âŸ¨f '' u, f '' v, hf.isOpenMap _ uo, hf.isOpenMap _ vo, mem_image_of_mem _ xu,\n    mem_image_of_mem _ yv, disjoint_image_of_injective hf.injective uvâŸ©\n\n"}
{"name":"separated_by_openEmbedding","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : T2Space X\nf : X â†’ Y\nhf : Topology.IsOpenEmbedding f\nx y : X\nh : Ne x y\nâŠ¢ Exists fun u => Exists fun v => And (IsOpen u) (And (IsOpen v) (And (Membership.mem u (f x)) (And (Membership.mem v (f y)) (Disjoint u v))))","decl":"@[deprecated (since := \"2024-10-18\")]\nalias separated_by_openEmbedding := separated_by_isOpenEmbedding\n\n"}
{"name":"instT2SpaceSubtype","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\np : X â†’ Prop\ninstâœ : T2Space X\nâŠ¢ T2Space (Subtype p)","decl":"instance {p : X â†’ Prop} [T2Space X] : T2Space (Subtype p) := inferInstance\n\n"}
{"name":"Prod.t2Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : T2Space X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : T2Space Y\nâŠ¢ T2Space (Prod X Y)","decl":"instance Prod.t2Space [T2Space X] [TopologicalSpace Y] [T2Space Y] : T2Space (X Ã— Y) :=\n  inferInstance\n\n"}
{"name":"T2Space.of_injective_continuous","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : T2Space Y\nf : X â†’ Y\nhinj : Function.Injective f\nhc : Continuous f\nâŠ¢ T2Space X","decl":"/-- If the codomain of an injective continuous function is a Hausdorff space, then so is its\ndomain. -/\ntheorem T2Space.of_injective_continuous [TopologicalSpace Y] [T2Space Y] {f : X â†’ Y}\n    (hinj : Injective f) (hc : Continuous f) : T2Space X :=\n  âŸ¨fun _ _ h => separated_by_continuous hc (hinj.ne h)âŸ©\n\n"}
{"name":"Topology.IsEmbedding.t2Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : T2Space Y\nf : X â†’ Y\nhf : Topology.IsEmbedding f\nâŠ¢ T2Space X","decl":"/-- If the codomain of a topological embedding is a Hausdorff space, then so is its domain.\nSee also `T2Space.of_continuous_injective`. -/\ntheorem Topology.IsEmbedding.t2Space [TopologicalSpace Y] [T2Space Y] {f : X â†’ Y}\n    (hf : IsEmbedding f) : T2Space X :=\n  .of_injective_continuous hf.injective hf.continuous\n\n"}
{"name":"Embedding.t2Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : T2Space Y\nf : X â†’ Y\nhf : Topology.IsEmbedding f\nâŠ¢ T2Space X","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.t2Space := IsEmbedding.t2Space\n\n"}
{"name":"ULift.instT2Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\nâŠ¢ T2Space (ULift.{u_3, u_1} X)","decl":"instance ULift.instT2Space [T2Space X] : T2Space (ULift X) :=\n  IsEmbedding.uliftDown.t2Space\n\n"}
{"name":"instT2SpaceSum","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : T2Space X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : T2Space Y\nâŠ¢ T2Space (Sum X Y)","decl":"instance [T2Space X] [TopologicalSpace Y] [T2Space Y] :\n    T2Space (X âŠ• Y) := by\n  constructor\n  rintro (x | x) (y | y) h\n  Â· exact separated_by_isOpenEmbedding .inl <| ne_of_apply_ne _ h\n  Â· exact separated_by_continuous continuous_isLeft <| by simp\n  Â· exact separated_by_continuous continuous_isLeft <| by simp\n  Â· exact separated_by_isOpenEmbedding .inr <| ne_of_apply_ne _ h\n\n"}
{"name":"Pi.t2Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : X â†’ Type v\ninstâœÂ¹ : (a : X) â†’ TopologicalSpace (Y a)\ninstâœ : âˆ€ (a : X), T2Space (Y a)\nâŠ¢ T2Space ((a : X) â†’ Y a)","decl":"instance Pi.t2Space {Y : X â†’ Type v} [âˆ€ a, TopologicalSpace (Y a)]\n    [âˆ€ a, T2Space (Y a)] : T2Space (âˆ€ a, Y a) :=\n  inferInstance\n\n"}
{"name":"Sigma.t2Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"Î¹ : Type u_4\nX : Î¹ â†’ Type u_3\ninstâœÂ¹ : (i : Î¹) â†’ TopologicalSpace (X i)\ninstâœ : âˆ€ (a : Î¹), T2Space (X a)\nâŠ¢ T2Space (Sigma fun i => X i)","decl":"instance Sigma.t2Space {Î¹} {X : Î¹ â†’ Type*} [âˆ€ i, TopologicalSpace (X i)] [âˆ€ a, T2Space (X a)] :\n    T2Space (Î£i, X i) := by\n  constructor\n  rintro âŸ¨i, xâŸ© âŸ¨j, yâŸ© neq\n  rcases eq_or_ne i j with (rfl | h)\n  Â· replace neq : x â‰  y := ne_of_apply_ne _ neq\n    exact separated_by_isOpenEmbedding .sigmaMk neq\n  Â· let _ := (âŠ¥ : TopologicalSpace Î¹); have : DiscreteTopology Î¹ := âŸ¨rflâŸ©\n    exact separated_by_continuous (continuous_def.2 fun u _ => isOpen_sigma_fst_preimage u) h\n\n"}
{"name":"t2Quotient.mk_eq","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nx y : X\nâŠ¢ Iff (Eq (t2Quotient.mk x) (t2Quotient.mk y)) (âˆ€ (s : Setoid X), T2Space (Quotient s) â†’ s x y)","decl":"lemma mk_eq {x y : X} : mk x = mk y â†” âˆ€ s : Setoid X, T2Space (Quotient s) â†’ s x y :=\n  Setoid.quotient_mk_sInf_eq\n\n"}
{"name":"t2Quotient.surjective_mk","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nâŠ¢ Function.Surjective t2Quotient.mk","decl":"lemma surjective_mk : Surjective (mk : X â†’ t2Quotient X) := Quotient.mk_surjective\n\n"}
{"name":"t2Quotient.continuous_mk","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nâŠ¢ Continuous t2Quotient.mk","decl":"lemma continuous_mk : Continuous (mk : X â†’ t2Quotient X) :=\n  continuous_quotient_mk'\n\n"}
{"name":"t2Quotient.inductionOn","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nmotive : t2Quotient X â†’ Prop\nq : t2Quotient X\nh : âˆ€ (x : X), motive (t2Quotient.mk x)\nâŠ¢ motive q","decl":"@[elab_as_elim]\nprotected lemma inductionOn {motive : t2Quotient X â†’ Prop} (q : t2Quotient X)\n    (h : âˆ€ x, motive (t2Quotient.mk x)) : motive q := Quotient.inductionOn q h\n\n"}
{"name":"t2Quotient.inductionOnâ‚‚","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nmotive : t2Quotient X â†’ t2Quotient Y â†’ Prop\nq : t2Quotient X\nq' : t2Quotient Y\nh : âˆ€ (x : X) (y : Y), motive (t2Quotient.mk x) (t2Quotient.mk y)\nâŠ¢ motive q q'","decl":"@[elab_as_elim]\nprotected lemma inductionOnâ‚‚ [TopologicalSpace Y] {motive : t2Quotient X â†’ t2Quotient Y â†’ Prop}\n    (q : t2Quotient X) (q' : t2Quotient Y) (h : âˆ€ x y, motive (mk x) (mk y)) : motive q q' :=\n  Quotient.inductionOnâ‚‚ q q' h\n\n"}
{"name":"t2Quotient.instT2Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nâŠ¢ T2Space (t2Quotient X)","decl":"/-- The largest T2 quotient of a topological space is indeed T2. -/\ninstance : T2Space (t2Quotient X) := by\n  rw [t2Space_iff]\n  rintro âŸ¨xâŸ© âŸ¨yâŸ© (h : Â¬ t2Quotient.mk x = t2Quotient.mk y)\n  obtain âŸ¨s, hs, hsxyâŸ© : âˆƒ s, T2Space (Quotient s) âˆ§ Quotient.mk s x â‰  Quotient.mk s y := by\n    simpa [t2Quotient.mk_eq] using h\n  exact separated_by_continuous (continuous_map_sInf (by exact hs)) hsxy\n\n"}
{"name":"t2Quotient.compatible","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_3\nY : Type u_4\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : T2Space Y\nf : X â†’ Y\nhf : Continuous f\na b : X\naâœ : HasEquiv.Equiv a b\nâŠ¢ Eq (f a) (f b)","decl":"lemma compatible {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] [T2Space Y]\n    {f : X â†’ Y} (hf : Continuous f) : letI _ := t2Setoid X\n    âˆ€ (a b : X), a â‰ˆ b â†’ f a = f b := by\n  change t2Setoid X â‰¤ Setoid.ker f\n  exact sInf_le <| .of_injective_continuous\n    (Setoid.ker_lift_injective _) (hf.quotient_lift fun _ _ â†¦ id)\n\n"}
{"name":"t2Quotient.continuous_lift","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_3\nY : Type u_4\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : T2Space Y\nf : X â†’ Y\nhf : Continuous f\nâŠ¢ Continuous (t2Quotient.lift hf)","decl":"lemma continuous_lift {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] [T2Space Y]\n    {f : X â†’ Y} (hf : Continuous f) : Continuous (t2Quotient.lift hf) :=\n  continuous_coinduced_dom.mpr hf\n\n"}
{"name":"t2Quotient.lift_mk","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_3\nY : Type u_4\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : T2Space Y\nf : X â†’ Y\nhf : Continuous f\nx : X\nâŠ¢ Eq (t2Quotient.lift hf (t2Quotient.mk x)) (f x)","decl":"@[simp]\nlemma lift_mk {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] [T2Space Y]\n    {f : X â†’ Y} (hf : Continuous f) (x : X) : lift hf (mk x) = f x :=\n  Quotient.lift_mk (s := t2Setoid X) f (t2Quotient.compatible hf) x\n\n"}
{"name":"t2Quotient.unique_lift","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_3\nY : Type u_4\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : T2Space Y\nf : X â†’ Y\nhf : Continuous f\ng : t2Quotient X â†’ Y\nhfg : Eq (Function.comp g t2Quotient.mk) f\nâŠ¢ Eq g (t2Quotient.lift hf)","decl":"lemma unique_lift {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] [T2Space Y]\n    {f : X â†’ Y} (hf : Continuous f) {g : t2Quotient X â†’ Y} (hfg : g âˆ˜ mk = f) :\n    g = lift hf := by\n  apply surjective_mk X |>.right_cancellable |>.mp <| funext _\n  simp [â† hfg]\n\n"}
{"name":"isClosed_eq","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : T2Space X\nf g : Y â†’ X\nhf : Continuous f\nhg : Continuous g\nâŠ¢ IsClosed (setOf fun y => Eq (f y) (g y))","decl":"theorem isClosed_eq [T2Space X] {f g : Y â†’ X} (hf : Continuous f) (hg : Continuous g) :\n    IsClosed { y : Y | f y = g y } :=\n  continuous_iff_isClosed.mp (hf.prod_mk hg) _ isClosed_diagonal\n\n"}
{"name":"IsClosed.isClosed_eq","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : T2Space Y\nf g : X â†’ Y\ns : Set X\nhs : IsClosed s\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nâŠ¢ IsClosed (setOf fun x => And (Membership.mem s x) (Eq (f x) (g x)))","decl":"/-- If functions `f` and `g` are continuous on a closed set `s`,\nthen the set of points `x âˆˆ s` such that `f x = g x` is a closed set. -/\nprotected theorem IsClosed.isClosed_eq [T2Space Y] {f g : X â†’ Y} {s : Set X} (hs : IsClosed s)\n    (hf : ContinuousOn f s) (hg : ContinuousOn g s) : IsClosed {x âˆˆ s | f x = g x} :=\n  (hf.prod hg).preimage_isClosed_of_isClosed hs isClosed_diagonal\n\n"}
{"name":"isOpen_ne_fun","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : T2Space X\nf g : Y â†’ X\nhf : Continuous f\nhg : Continuous g\nâŠ¢ IsOpen (setOf fun y => Ne (f y) (g y))","decl":"theorem isOpen_ne_fun [T2Space X] {f g : Y â†’ X} (hf : Continuous f) (hg : Continuous g) :\n    IsOpen { y : Y | f y â‰  g y } :=\n  isOpen_compl_iff.mpr <| isClosed_eq hf hg\n\n"}
{"name":"Set.EqOn.closure","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : T2Space X\ns : Set Y\nf g : Y â†’ X\nh : Set.EqOn f g s\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Set.EqOn f g (closure s)","decl":"/-- If two continuous maps are equal on `s`, then they are equal on the closure of `s`. See also\n`Set.EqOn.of_subset_closure` for a more general version. -/\nprotected theorem Set.EqOn.closure [T2Space X] {s : Set Y} {f g : Y â†’ X} (h : EqOn f g s)\n    (hf : Continuous f) (hg : Continuous g) : EqOn f g (closure s) :=\n  closure_minimal h (isClosed_eq hf hg)\n\n"}
{"name":"Continuous.ext_on","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : T2Space X\ns : Set Y\nhs : Dense s\nf g : Y â†’ X\nhf : Continuous f\nhg : Continuous g\nh : Set.EqOn f g s\nâŠ¢ Eq f g","decl":"/-- If two continuous functions are equal on a dense set, then they are equal. -/\ntheorem Continuous.ext_on [T2Space X] {s : Set Y} (hs : Dense s) {f g : Y â†’ X} (hf : Continuous f)\n    (hg : Continuous g) (h : EqOn f g s) : f = g :=\n  funext fun x => h.closure hf hg (hs x)\n\n"}
{"name":"eqOn_closureâ‚‚'","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ³ : TopologicalSpace X\nZ : Type u_3\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : T2Space Z\ns : Set X\nt : Set Y\nf g : X â†’ Y â†’ Z\nh : âˆ€ (x : X), Membership.mem s x â†’ âˆ€ (y : Y), Membership.mem t y â†’ Eq (f x y) (g x y)\nhfâ‚ : âˆ€ (x : X), Continuous (f x)\nhfâ‚‚ : âˆ€ (y : Y), Continuous fun x => f x y\nhgâ‚ : âˆ€ (x : X), Continuous (g x)\nhgâ‚‚ : âˆ€ (y : Y), Continuous fun x => g x y\nx : X\naâœÂ¹ : Membership.mem (closure s) x\ny : Y\naâœ : Membership.mem (closure t) y\nâŠ¢ Eq (f x y) (g x y)","decl":"theorem eqOn_closureâ‚‚' [T2Space Z] {s : Set X} {t : Set Y} {f g : X â†’ Y â†’ Z}\n    (h : âˆ€ x âˆˆ s, âˆ€ y âˆˆ t, f x y = g x y) (hfâ‚ : âˆ€ x, Continuous (f x))\n    (hfâ‚‚ : âˆ€ y, Continuous fun x => f x y) (hgâ‚ : âˆ€ x, Continuous (g x))\n    (hgâ‚‚ : âˆ€ y, Continuous fun x => g x y) : âˆ€ x âˆˆ closure s, âˆ€ y âˆˆ closure t, f x y = g x y :=\n  suffices closure s âŠ† â‹‚ y âˆˆ closure t, { x | f x y = g x y } by simpa only [subset_def, mem_iInter]\n  (closure_minimal fun x hx => mem_iInterâ‚‚.2 <| Set.EqOn.closure (h x hx) (hfâ‚ _) (hgâ‚ _)) <|\n    isClosed_biInter fun _ _ => isClosed_eq (hfâ‚‚ _) (hgâ‚‚ _)\n\n"}
{"name":"eqOn_closureâ‚‚","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ³ : TopologicalSpace X\nZ : Type u_3\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : T2Space Z\ns : Set X\nt : Set Y\nf g : X â†’ Y â†’ Z\nh : âˆ€ (x : X), Membership.mem s x â†’ âˆ€ (y : Y), Membership.mem t y â†’ Eq (f x y) (g x y)\nhf : Continuous (Function.uncurry f)\nhg : Continuous (Function.uncurry g)\nx : X\naâœÂ¹ : Membership.mem (closure s) x\ny : Y\naâœ : Membership.mem (closure t) y\nâŠ¢ Eq (f x y) (g x y)","decl":"theorem eqOn_closureâ‚‚ [T2Space Z] {s : Set X} {t : Set Y} {f g : X â†’ Y â†’ Z}\n    (h : âˆ€ x âˆˆ s, âˆ€ y âˆˆ t, f x y = g x y) (hf : Continuous (uncurry f))\n    (hg : Continuous (uncurry g)) : âˆ€ x âˆˆ closure s, âˆ€ y âˆˆ closure t, f x y = g x y :=\n  eqOn_closureâ‚‚' h hf.uncurry_left hf.uncurry_right hg.uncurry_left hg.uncurry_right\n\n"}
{"name":"Set.EqOn.of_subset_closure","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : T2Space Y\ns t : Set X\nf g : X â†’ Y\nh : Set.EqOn f g s\nhf : ContinuousOn f t\nhg : ContinuousOn g t\nhst : HasSubset.Subset s t\nhts : HasSubset.Subset t (closure s)\nâŠ¢ Set.EqOn f g t","decl":"/-- If `f x = g x` for all `x âˆˆ s` and `f`, `g` are continuous on `t`, `s âŠ† t âŠ† closure s`, then\n`f x = g x` for all `x âˆˆ t`. See also `Set.EqOn.closure`. -/\ntheorem Set.EqOn.of_subset_closure [T2Space Y] {s t : Set X} {f g : X â†’ Y} (h : EqOn f g s)\n    (hf : ContinuousOn f t) (hg : ContinuousOn g t) (hst : s âŠ† t) (hts : t âŠ† closure s) :\n    EqOn f g t := by\n  intro x hx\n  have : (ğ“[s] x).NeBot := mem_closure_iff_clusterPt.mp (hts hx)\n  exact\n    tendsto_nhds_unique_of_eventuallyEq ((hf x hx).mono_left <| nhdsWithin_mono _ hst)\n      ((hg x hx).mono_left <| nhdsWithin_mono _ hst) (h.eventuallyEq_of_mem self_mem_nhdsWithin)\n\n"}
{"name":"Function.LeftInverse.isClosed_range","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : T2Space X\nf : X â†’ Y\ng : Y â†’ X\nh : Function.LeftInverse f g\nhf : Continuous f\nhg : Continuous g\nâŠ¢ IsClosed (Set.range g)","decl":"theorem Function.LeftInverse.isClosed_range [T2Space X] {f : X â†’ Y} {g : Y â†’ X}\n    (h : Function.LeftInverse f g) (hf : Continuous f) (hg : Continuous g) : IsClosed (range g) :=\n  have : EqOn (g âˆ˜ f) id (closure <| range g) :=\n    h.rightInvOn_range.eqOn.closure (hg.comp hf) continuous_id\n  isClosed_of_closure_subset fun x hx => âŸ¨f x, this hxâŸ©\n\n"}
{"name":"Function.LeftInverse.isClosedEmbedding","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : T2Space X\nf : X â†’ Y\ng : Y â†’ X\nh : Function.LeftInverse f g\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Topology.IsClosedEmbedding g","decl":"theorem Function.LeftInverse.isClosedEmbedding [T2Space X] {f : X â†’ Y} {g : Y â†’ X}\n    (h : Function.LeftInverse f g) (hf : Continuous f) (hg : Continuous g) : IsClosedEmbedding g :=\n  âŸ¨.of_leftInverse h hf hg, h.isClosed_range hf hgâŸ©\n\n"}
{"name":"Function.LeftInverse.closedEmbedding","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : T2Space X\nf : X â†’ Y\ng : Y â†’ X\nh : Function.LeftInverse f g\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Topology.IsClosedEmbedding g","decl":"@[deprecated (since := \"2024-10-20\")]\nalias Function.LeftInverse.closedEmbedding := Function.LeftInverse.isClosedEmbedding\n\n"}
{"name":"SeparatedNhds.of_isCompact_isCompact","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\ns t : Set X\nhs : IsCompact s\nht : IsCompact t\nhst : Disjoint s t\nâŠ¢ SeparatedNhds s t","decl":"theorem SeparatedNhds.of_isCompact_isCompact [T2Space X] {s t : Set X} (hs : IsCompact s)\n    (ht : IsCompact t) (hst : Disjoint s t) : SeparatedNhds s t := by\n  simp only [SeparatedNhds, prod_subset_compl_diagonal_iff_disjoint.symm] at hst âŠ¢\n  exact generalized_tube_lemma hs ht isClosed_diagonal.isOpen_compl hst\n\n"}
{"name":"SeparatedNhds.of_isClosed_isCompact_closure_compl_isClosed","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\ns t : Set X\nH1 : IsClosed s\nH2 : IsCompact (closure (HasCompl.compl s))\nH3 : IsClosed t\nH4 : Disjoint s t\nâŠ¢ SeparatedNhds s t","decl":"/-- In a `T2Space X`, for disjoint closed sets `s t` such that `closure sá¶œ` is compact,\nthere are neighbourhoods that separate `s` and `t`.-/\nlemma SeparatedNhds.of_isClosed_isCompact_closure_compl_isClosed [T2Space X] {s : Set X}\n    {t : Set X} (H1 : IsClosed s) (H2 : IsCompact (closure sá¶œ)) (H3 : IsClosed t)\n    (H4 : Disjoint s t) : SeparatedNhds s t := by\n  -- Since `t` is a closed subset of the compact set `closure sá¶œ`, it is compact.\n  have ht : IsCompact t := .of_isClosed_subset H2 H3 <| H4.subset_compl_left.trans subset_closure\n  -- we split `s` into its frontier and its interior.\n  rw [â† diff_union_of_subset (interior_subset (s := s))]\n  -- since `t âŠ† sá¶œ`, which is open, and `interior s` is open, we have\n  -- `SeparatedNhds (interior s) t`, which leaves us only with the frontier.\n  refine .union_left ?_ âŸ¨interior s, sá¶œ, isOpen_interior, H1.isOpen_compl, le_rfl,\n    H4.subset_compl_left, disjoint_compl_right.mono_left interior_subsetâŸ©\n  -- Since the frontier of `s` is compact (as it is a subset of `closure sá¶œ`), we simply apply\n  -- `SeparatedNhds_of_isCompact_isCompact`.\n  rw [â† H1.frontier_eq, frontier_eq_closure_inter_closure, H1.closure_eq]\n  refine .of_isCompact_isCompact ?_ ht (disjoint_of_subset_left inter_subset_left H4)\n  exact H2.of_isClosed_subset (H1.inter isClosed_closure) inter_subset_right\n\n"}
{"name":"SeparatedNhds.of_finset_finset","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\ns t : Finset X\nh : Disjoint s t\nâŠ¢ SeparatedNhds â†‘s â†‘t","decl":"theorem SeparatedNhds.of_finset_finset [T2Space X] (s t : Finset X) (h : Disjoint s t) :\n    SeparatedNhds (s : Set X) t :=\n  .of_isCompact_isCompact s.finite_toSet.isCompact t.finite_toSet.isCompact <| mod_cast h\n\n"}
{"name":"SeparatedNhds.of_singleton_finset","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\nx : X\ns : Finset X\nh : Not (Membership.mem s x)\nâŠ¢ SeparatedNhds (Singleton.singleton x) â†‘s","decl":"theorem SeparatedNhds.of_singleton_finset [T2Space X] {x : X} {s : Finset X} (h : x âˆ‰ s) :\n    SeparatedNhds ({x} : Set X) s :=\n  mod_cast .of_finset_finset {x} s (Finset.disjoint_singleton_left.mpr h)\n\n"}
{"name":"IsCompact.isClosed","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\ns : Set X\nhs : IsCompact s\nâŠ¢ IsClosed s","decl":"/-- In a `T2Space`, every compact set is closed. -/\ntheorem IsCompact.isClosed [T2Space X] {s : Set X} (hs : IsCompact s) : IsClosed s :=\n  isOpen_compl_iff.1 <| isOpen_iff_forall_mem_open.mpr fun x hx =>\n    let âŸ¨u, v, _, vo, su, xv, uvâŸ© :=\n      SeparatedNhds.of_isCompact_isCompact hs isCompact_singleton (disjoint_singleton_right.2 hx)\n    âŸ¨v, (uv.mono_left <| show s â‰¤ u from su).subset_compl_left, vo, by simpa using xvâŸ©\n\n"}
{"name":"IsCompact.preimage_continuous","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : CompactSpace X\ninstâœ : T2Space Y\nf : X â†’ Y\ns : Set Y\nhs : IsCompact s\nhf : Continuous f\nâŠ¢ IsCompact (Set.preimage f s)","decl":"theorem IsCompact.preimage_continuous [CompactSpace X] [T2Space Y] {f : X â†’ Y} {s : Set Y}\n    (hs : IsCompact s) (hf : Continuous f) : IsCompact (f â»Â¹' s) :=\n  (hs.isClosed.preimage hf).isCompact\n\n"}
{"name":"Pi.isCompact_iff","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"Î¹ : Type u_4\nÏ€ : Î¹ â†’ Type u_5\ninstâœÂ¹ : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\ninstâœ : âˆ€ (i : Î¹), T2Space (Ï€ i)\ns : Set ((i : Î¹) â†’ Ï€ i)\nâŠ¢ Iff (IsCompact s) (And (IsClosed s) (âˆ€ (i : Î¹), IsCompact (Set.image (Function.eval i) s)))","decl":"lemma Pi.isCompact_iff {Î¹ : Type*} {Ï€ : Î¹ â†’ Type*} [âˆ€ i, TopologicalSpace (Ï€ i)]\n    [âˆ€ i, T2Space (Ï€ i)] {s : Set (Î  i, Ï€ i)} :\n    IsCompact s â†” IsClosed s âˆ§ âˆ€ i, IsCompact (eval i '' s) := by\n  constructor <;> intro H\n  Â· exact âŸ¨H.isClosed, fun i â†¦ H.image <| continuous_apply iâŸ©\n  Â· exact IsCompact.of_isClosed_subset (isCompact_univ_pi H.2) H.1 (subset_pi_eval_image univ s)\n\n"}
{"name":"Pi.isCompact_closure_iff","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"Î¹ : Type u_4\nÏ€ : Î¹ â†’ Type u_5\ninstâœÂ¹ : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\ninstâœ : âˆ€ (i : Î¹), T2Space (Ï€ i)\ns : Set ((i : Î¹) â†’ Ï€ i)\nâŠ¢ Iff (IsCompact (closure s)) (âˆ€ (i : Î¹), IsCompact (closure (Set.image (Function.eval i) s)))","decl":"lemma Pi.isCompact_closure_iff {Î¹ : Type*} {Ï€ : Î¹ â†’ Type*} [âˆ€ i, TopologicalSpace (Ï€ i)]\n    [âˆ€ i, T2Space (Ï€ i)] {s : Set (Î  i, Ï€ i)} :\n    IsCompact (closure s) â†” âˆ€ i, IsCompact (closure <| eval i '' s) := by\n  simp_rw [â† exists_isCompact_superset_iff, Pi.exists_compact_superset_iff, image_subset_iff]\n\n"}
{"name":"exists_subset_nhds_of_isCompact","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : T2Space X\nÎ¹ : Type u_4\ninstâœ : Nonempty Î¹\nV : Î¹ â†’ Set X\nhV : Directed (fun x1 x2 => Superset x1 x2) V\nhV_cpct : âˆ€ (i : Î¹), IsCompact (V i)\nU : Set X\nhU : âˆ€ (x : X), Membership.mem (Set.iInter fun i => V i) x â†’ Membership.mem (nhds x) U\nâŠ¢ Exists fun i => HasSubset.Subset (V i) U","decl":"/-- If `V : Î¹ â†’ Set X` is a decreasing family of compact sets then any neighborhood of\n`â‹‚ i, V i` contains some `V i`. This is a version of `exists_subset_nhds_of_isCompact'` where we\ndon't need to assume each `V i` closed because it follows from compactness since `X` is\nassumed to be Hausdorff. -/\ntheorem exists_subset_nhds_of_isCompact [T2Space X] {Î¹ : Type*} [Nonempty Î¹] {V : Î¹ â†’ Set X}\n    (hV : Directed (Â· âŠ‡ Â·) V) (hV_cpct : âˆ€ i, IsCompact (V i)) {U : Set X}\n    (hU : âˆ€ x âˆˆ â‹‚ i, V i, U âˆˆ ğ“ x) : âˆƒ i, V i âŠ† U :=\n  exists_subset_nhds_of_isCompact' hV hV_cpct (fun i => (hV_cpct i).isClosed) hU\n\n"}
{"name":"CompactExhaustion.isClosed","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\nK : CompactExhaustion X\nn : Nat\nâŠ¢ IsClosed (K n)","decl":"theorem CompactExhaustion.isClosed [T2Space X] (K : CompactExhaustion X) (n : â„•) : IsClosed (K n) :=\n  (K.isCompact n).isClosed\n\n"}
{"name":"IsCompact.inter","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\ns t : Set X\nhs : IsCompact s\nht : IsCompact t\nâŠ¢ IsCompact (Inter.inter s t)","decl":"theorem IsCompact.inter [T2Space X] {s t : Set X} (hs : IsCompact s) (ht : IsCompact t) :\n    IsCompact (s âˆ© t) :=\n  hs.inter_right <| ht.isClosed\n\n"}
{"name":"image_closure_of_isCompact","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : T2Space Y\ns : Set X\nhs : IsCompact (closure s)\nf : X â†’ Y\nhf : ContinuousOn f (closure s)\nâŠ¢ Eq (Set.image f (closure s)) (closure (Set.image f s))","decl":"theorem image_closure_of_isCompact [T2Space Y] {s : Set X} (hs : IsCompact (closure s)) {f : X â†’ Y}\n    (hf : ContinuousOn f (closure s)) : f '' closure s = closure (f '' s) :=\n  Subset.antisymm hf.image_closure <|\n    closure_minimal (image_subset f subset_closure) (hs.image_of_continuousOn hf).isClosed\n\n"}
{"name":"Continuous.isClosedMap","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : CompactSpace X\ninstâœ : T2Space Y\nf : X â†’ Y\nh : Continuous f\nâŠ¢ IsClosedMap f","decl":"/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\nprotected theorem Continuous.isClosedMap [CompactSpace X] [T2Space Y] {f : X â†’ Y}\n    (h : Continuous f) : IsClosedMap f := fun _s hs => (hs.isCompact.image h).isClosed\n\n"}
{"name":"Continuous.isClosedEmbedding","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : CompactSpace X\ninstâœ : T2Space Y\nf : X â†’ Y\nh : Continuous f\nhf : Function.Injective f\nâŠ¢ Topology.IsClosedEmbedding f","decl":"/-- A continuous injective map from a compact space to a Hausdorff space is a closed embedding. -/\ntheorem Continuous.isClosedEmbedding [CompactSpace X] [T2Space Y] {f : X â†’ Y} (h : Continuous f)\n    (hf : Function.Injective f) : IsClosedEmbedding f :=\n  .of_continuous_injective_isClosedMap h hf h.isClosedMap\n\n"}
{"name":"Continuous.closedEmbedding","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : CompactSpace X\ninstâœ : T2Space Y\nf : X â†’ Y\nh : Continuous f\nhf : Function.Injective f\nâŠ¢ Topology.IsClosedEmbedding f","decl":"@[deprecated (since := \"2024-10-20\")]\nalias Continuous.closedEmbedding := Continuous.isClosedEmbedding\n\n"}
{"name":"IsQuotientMap.of_surjective_continuous","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : CompactSpace X\ninstâœ : T2Space Y\nf : X â†’ Y\nhsurj : Function.Surjective f\nhcont : Continuous f\nâŠ¢ Topology.IsQuotientMap f","decl":"/-- A continuous surjective map from a compact space to a Hausdorff space is a quotient map. -/\ntheorem IsQuotientMap.of_surjective_continuous [CompactSpace X] [T2Space Y] {f : X â†’ Y}\n    (hsurj : Surjective f) (hcont : Continuous f) : IsQuotientMap f :=\n  hcont.isClosedMap.isQuotientMap hcont hsurj\n\n"}
{"name":"QuotientMap.of_surjective_continuous","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : CompactSpace X\ninstâœ : T2Space Y\nf : X â†’ Y\nhsurj : Function.Surjective f\nhcont : Continuous f\nâŠ¢ Topology.IsQuotientMap f","decl":"@[deprecated (since := \"2024-10-22\")]\nalias QuotientMap.of_surjective_continuous := IsQuotientMap.of_surjective_continuous\n\n"}
{"name":"isPreirreducible_iff_subsingleton","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\nS : Set X\nâŠ¢ Iff (IsPreirreducible S) S.Subsingleton","decl":"theorem isPreirreducible_iff_subsingleton [T2Space X] {S : Set X} :\n    IsPreirreducible S â†” S.Subsingleton := by\n  refine âŸ¨fun h x hx y hy => ?_, Set.Subsingleton.isPreirreducibleâŸ©\n  by_contra e\n  obtain âŸ¨U, V, hU, hV, hxU, hyV, h'âŸ© := t2_separation e\n  exact ((h U V hU hV âŸ¨x, hx, hxUâŸ© âŸ¨y, hy, hyVâŸ©).mono inter_subset_right).not_disjoint h'\n\n-- todo: use `alias` + `attribute [protected]` once we get `attribute [protected]`\n"}
{"name":"IsPreirreducible.subsingleton","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\nS : Set X\nh : IsPreirreducible S\nâŠ¢ S.Subsingleton","decl":"protected lemma IsPreirreducible.subsingleton [T2Space X] {S : Set X} (h : IsPreirreducible S) :\n    S.Subsingleton :=\n  isPreirreducible_iff_subsingleton.1 h\n\n"}
{"name":"isIrreducible_iff_singleton","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T2Space X\nS : Set X\nâŠ¢ Iff (IsIrreducible S) (Exists fun x => Eq S (Singleton.singleton x))","decl":"theorem isIrreducible_iff_singleton [T2Space X] {S : Set X} : IsIrreducible S â†” âˆƒ x, S = {x} := by\n  rw [IsIrreducible, isPreirreducible_iff_subsingleton,\n    exists_eq_singleton_iff_nonempty_subsingleton]\n\n"}
{"name":"not_preirreducible_nontrivial_t2","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_4\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : PreirreducibleSpace X\ninstâœÂ¹ : Nontrivial X\ninstâœ : T2Space X\nâŠ¢ False","decl":"/-- There does not exist a nontrivial preirreducible Tâ‚‚ space. -/\ntheorem not_preirreducible_nontrivial_t2 (X) [TopologicalSpace X] [PreirreducibleSpace X]\n    [Nontrivial X] [T2Space X] : False :=\n  (PreirreducibleSpace.isPreirreducible_univ (X := X)).subsingleton.not_nontrivial nontrivial_univ\n\n"}
{"name":"t2Space_antitone","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_4\nâŠ¢ Antitone (@T2Space X)","decl":"theorem t2Space_antitone {X : Type*} : Antitone (@T2Space X) :=\n  fun instâ‚ instâ‚‚ h_top h_t2 â†¦ @T2Space.of_injective_continuous _ _ instâ‚ instâ‚‚\n    h_t2 _ Function.injective_id <| continuous_id_of_le h_top\n\n"}
