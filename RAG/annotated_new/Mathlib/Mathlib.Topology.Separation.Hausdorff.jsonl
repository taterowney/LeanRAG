{"name":"T2Space.t2","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nself : T2Space X\n⊢ Pairwise fun x y => Exists fun u => Exists fun v => And (IsOpen u) (And (IsOpen v) (And (Membership.mem u x) (And (Membership.mem v y) (Disjoint u v))))","decl":"/-- A T₂ space, also known as a Hausdorff space, is one in which for every\n  `x ≠ y` there exists disjoint open sets around `x` and `y`. This is\n  the most widely used of the separation axioms. -/\n@[mk_iff]\nclass T2Space (X : Type u) [TopologicalSpace X] : Prop where\n  /-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\n  t2 : Pairwise fun x y => ∃ u v : Set X, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v\n\n"}
{"name":"t2Space_iff","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Iff (T2Space X) (Pairwise fun x y => Exists fun u => Exists fun v => And (IsOpen u) (And (IsOpen v) (And (Membership.mem u x) (And (Membership.mem v y) (Disjoint u v)))))","decl":"/-- A T₂ space, also known as a Hausdorff space, is one in which for every\n  `x ≠ y` there exists disjoint open sets around `x` and `y`. This is\n  the most widely used of the separation axioms. -/\n@[mk_iff]\nclass T2Space (X : Type u) [TopologicalSpace X] : Prop where\n  /-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\n  t2 : Pairwise fun x y => ∃ u v : Set X, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v\n\n"}
{"name":"t2_separation","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\nx y : X\nh : Ne x y\n⊢ Exists fun u => Exists fun v => And (IsOpen u) (And (IsOpen v) (And (Membership.mem u x) (And (Membership.mem v y) (Disjoint u v))))","decl":"/-- Two different points can be separated by open sets. -/\ntheorem t2_separation [T2Space X] {x y : X} (h : x ≠ y) :\n    ∃ u v : Set X, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v :=\n  T2Space.t2 h\n\n-- todo: use this as a definition?\n"}
{"name":"t2Space_iff_disjoint_nhds","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Iff (T2Space X) (Pairwise fun x y => Disjoint (nhds x) (nhds y))","decl":"theorem t2Space_iff_disjoint_nhds : T2Space X ↔ Pairwise fun x y : X => Disjoint (𝓝 x) (𝓝 y) := by\n  refine (t2Space_iff X).trans (forall₃_congr fun x y _ => ?_)\n  simp only [(nhds_basis_opens x).disjoint_iff (nhds_basis_opens y), exists_prop, ← exists_and_left,\n    and_assoc, and_comm, and_left_comm]\n\n"}
{"name":"disjoint_nhds_nhds","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\nx y : X\n⊢ Iff (Disjoint (nhds x) (nhds y)) (Ne x y)","decl":"@[simp]\ntheorem disjoint_nhds_nhds [T2Space X] {x y : X} : Disjoint (𝓝 x) (𝓝 y) ↔ x ≠ y :=\n  ⟨fun hd he => by simp [he, nhds_neBot.ne] at hd, (t2Space_iff_disjoint_nhds.mp ‹_› ·)⟩\n\n"}
{"name":"pairwise_disjoint_nhds","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\n⊢ Pairwise (Function.onFun Disjoint nhds)","decl":"theorem pairwise_disjoint_nhds [T2Space X] : Pairwise (Disjoint on (𝓝 : X → Filter X)) := fun _ _ =>\n  disjoint_nhds_nhds.2\n\n"}
{"name":"Set.pairwiseDisjoint_nhds","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\ns : Set X\n⊢ s.PairwiseDisjoint nhds","decl":"protected theorem Set.pairwiseDisjoint_nhds [T2Space X] (s : Set X) : s.PairwiseDisjoint 𝓝 :=\n  pairwise_disjoint_nhds.set_pairwise s\n\n"}
{"name":"Set.Finite.t2_separation","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\ns : Set X\nhs : s.Finite\n⊢ Exists fun U => And (∀ (x : X), And (Membership.mem (U x) x) (IsOpen (U x))) (s.PairwiseDisjoint U)","decl":"/-- Points of a finite set can be separated by open sets from each other. -/\ntheorem Set.Finite.t2_separation [T2Space X] {s : Set X} (hs : s.Finite) :\n    ∃ U : X → Set X, (∀ x, x ∈ U x ∧ IsOpen (U x)) ∧ s.PairwiseDisjoint U :=\n  s.pairwiseDisjoint_nhds.exists_mem_filter_basis hs nhds_basis_opens\n\n-- see Note [lower instance priority]\n"}
{"name":"T2Space.t1Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\n⊢ T1Space X","decl":"instance (priority := 100) T2Space.t1Space [T2Space X] : T1Space X :=\n  t1Space_iff_disjoint_pure_nhds.mpr fun _ _ hne =>\n    (disjoint_nhds_nhds.2 hne).mono_left <| pure_le_nhds _\n\n-- see Note [lower instance priority]\n"}
{"name":"T2Space.r1Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\n⊢ R1Space X","decl":"instance (priority := 100) T2Space.r1Space [T2Space X] : R1Space X :=\n  ⟨fun x y ↦ (eq_or_ne x y).imp specializes_of_eq disjoint_nhds_nhds.2⟩\n\n"}
{"name":"SeparationQuotient.t2Space_iff","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Iff (T2Space (SeparationQuotient X)) (R1Space X)","decl":"theorem SeparationQuotient.t2Space_iff : T2Space (SeparationQuotient X) ↔ R1Space X := by\n  simp only [t2Space_iff_disjoint_nhds, Pairwise, surjective_mk.forall₂, ne_eq, mk_eq_mk,\n    r1Space_iff_inseparable_or_disjoint_nhds, ← disjoint_comap_iff surjective_mk, comap_mk_nhds_mk,\n    ← or_iff_not_imp_left]\n\n"}
{"name":"SeparationQuotient.t2Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : R1Space X\n⊢ T2Space (SeparationQuotient X)","decl":"instance SeparationQuotient.t2Space [R1Space X] : T2Space (SeparationQuotient X) :=\n  t2Space_iff.2 ‹_›\n\n"}
{"name":"instT2SpaceOfR1SpaceOfT0Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : R1Space X\ninst✝ : T0Space X\n⊢ T2Space X","decl":"instance (priority := 80) [R1Space X] [T0Space X] : T2Space X :=\n  t2Space_iff_disjoint_nhds.2 fun _x _y hne ↦ disjoint_nhds_nhds_iff_not_inseparable.2 fun hxy ↦\n    hne hxy.eq\n\n"}
{"name":"R1Space.t2Space_iff_t0Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : R1Space X\n⊢ Iff (T2Space X) (T0Space X)","decl":"theorem R1Space.t2Space_iff_t0Space [R1Space X] : T2Space X ↔ T0Space X := by\n  constructor <;> intro <;> infer_instance\n\n"}
{"name":"t2_iff_nhds","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Iff (T2Space X) (∀ {x y : X}, (Min.min (nhds x) (nhds y)).NeBot → Eq x y)","decl":"/-- A space is T₂ iff the neighbourhoods of distinct points generate the bottom filter. -/\ntheorem t2_iff_nhds : T2Space X ↔ ∀ {x y : X}, NeBot (𝓝 x ⊓ 𝓝 y) → x = y := by\n  simp only [t2Space_iff_disjoint_nhds, disjoint_iff, neBot_iff, Ne, not_imp_comm, Pairwise]\n\n"}
{"name":"eq_of_nhds_neBot","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\nx y : X\nh : (Min.min (nhds x) (nhds y)).NeBot\n⊢ Eq x y","decl":"theorem eq_of_nhds_neBot [T2Space X] {x y : X} (h : NeBot (𝓝 x ⊓ 𝓝 y)) : x = y :=\n  t2_iff_nhds.mp ‹_› h\n\n"}
{"name":"t2Space_iff_nhds","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Iff (T2Space X) (Pairwise fun x y => Exists fun U => And (Membership.mem (nhds x) U) (Exists fun V => And (Membership.mem (nhds y) V) (Disjoint U V)))","decl":"theorem t2Space_iff_nhds :\n    T2Space X ↔ Pairwise fun x y : X => ∃ U ∈ 𝓝 x, ∃ V ∈ 𝓝 y, Disjoint U V := by\n  simp only [t2Space_iff_disjoint_nhds, Filter.disjoint_iff, Pairwise]\n\n"}
{"name":"t2_separation_nhds","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\nx y : X\nh : Ne x y\n⊢ Exists fun u => Exists fun v => And (Membership.mem (nhds x) u) (And (Membership.mem (nhds y) v) (Disjoint u v))","decl":"theorem t2_separation_nhds [T2Space X] {x y : X} (h : x ≠ y) :\n    ∃ u v, u ∈ 𝓝 x ∧ v ∈ 𝓝 y ∧ Disjoint u v :=\n  let ⟨u, v, open_u, open_v, x_in, y_in, huv⟩ := t2_separation h\n  ⟨u, v, open_u.mem_nhds x_in, open_v.mem_nhds y_in, huv⟩\n\n"}
{"name":"t2_separation_compact_nhds","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : LocallyCompactSpace X\ninst✝ : T2Space X\nx y : X\nh : Ne x y\n⊢ Exists fun u => Exists fun v => And (Membership.mem (nhds x) u) (And (Membership.mem (nhds y) v) (And (IsCompact u) (And (IsCompact v) (Disjoint u v))))","decl":"theorem t2_separation_compact_nhds [LocallyCompactSpace X] [T2Space X] {x y : X} (h : x ≠ y) :\n    ∃ u v, u ∈ 𝓝 x ∧ v ∈ 𝓝 y ∧ IsCompact u ∧ IsCompact v ∧ Disjoint u v := by\n  simpa only [exists_prop, ← exists_and_left, and_comm, and_assoc, and_left_comm] using\n    ((compact_basis_nhds x).disjoint_iff (compact_basis_nhds y)).1 (disjoint_nhds_nhds.2 h)\n\n"}
{"name":"t2_iff_ultrafilter","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Iff (T2Space X) (∀ {x y : X} (f : Ultrafilter X), LE.le (↑f) (nhds x) → LE.le (↑f) (nhds y) → Eq x y)","decl":"theorem t2_iff_ultrafilter :\n    T2Space X ↔ ∀ {x y : X} (f : Ultrafilter X), ↑f ≤ 𝓝 x → ↑f ≤ 𝓝 y → x = y :=\n  t2_iff_nhds.trans <| by simp only [← exists_ultrafilter_iff, and_imp, le_inf_iff, exists_imp]\n\n"}
{"name":"t2_iff_isClosed_diagonal","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Iff (T2Space X) (IsClosed (Set.diagonal X))","decl":"theorem t2_iff_isClosed_diagonal : T2Space X ↔ IsClosed (diagonal X) := by\n  simp only [t2Space_iff_disjoint_nhds, ← isOpen_compl_iff, isOpen_iff_mem_nhds, Prod.forall,\n    nhds_prod_eq, compl_diagonal_mem_prod, mem_compl_iff, mem_diagonal_iff, Pairwise]\n\n"}
{"name":"isClosed_diagonal","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\n⊢ IsClosed (Set.diagonal X)","decl":"theorem isClosed_diagonal [T2Space X] : IsClosed (diagonal X) :=\n  t2_iff_isClosed_diagonal.mp ‹_›\n\n-- Porting note: 2 lemmas moved below\n\n"}
{"name":"tendsto_nhds_unique","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : T2Space X\nf : Y → X\nl : Filter Y\na b : X\ninst✝ : l.NeBot\nha : Filter.Tendsto f l (nhds a)\nhb : Filter.Tendsto f l (nhds b)\n⊢ Eq a b","decl":"theorem tendsto_nhds_unique [T2Space X] {f : Y → X} {l : Filter Y} {a b : X} [NeBot l]\n    (ha : Tendsto f l (𝓝 a)) (hb : Tendsto f l (𝓝 b)) : a = b :=\n  (tendsto_nhds_unique_inseparable ha hb).eq\n\n"}
{"name":"tendsto_nhds_unique'","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\nf : Y → X\nl : Filter Y\na b : X\nx✝ : l.NeBot\nha : Filter.Tendsto f l (nhds a)\nhb : Filter.Tendsto f l (nhds b)\n⊢ Eq a b","decl":"theorem tendsto_nhds_unique' [T2Space X] {f : Y → X} {l : Filter Y} {a b : X} (_ : NeBot l)\n    (ha : Tendsto f l (𝓝 a)) (hb : Tendsto f l (𝓝 b)) : a = b :=\n  tendsto_nhds_unique ha hb\n\n"}
{"name":"tendsto_nhds_unique_of_eventuallyEq","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : T2Space X\nf g : Y → X\nl : Filter Y\na b : X\ninst✝ : l.NeBot\nha : Filter.Tendsto f l (nhds a)\nhb : Filter.Tendsto g l (nhds b)\nhfg : l.EventuallyEq f g\n⊢ Eq a b","decl":"theorem tendsto_nhds_unique_of_eventuallyEq [T2Space X] {f g : Y → X} {l : Filter Y} {a b : X}\n    [NeBot l] (ha : Tendsto f l (𝓝 a)) (hb : Tendsto g l (𝓝 b)) (hfg : f =ᶠ[l] g) : a = b :=\n  tendsto_nhds_unique (ha.congr' hfg) hb\n\n"}
{"name":"tendsto_nhds_unique_of_frequently_eq","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\nf g : Y → X\nl : Filter Y\na b : X\nha : Filter.Tendsto f l (nhds a)\nhb : Filter.Tendsto g l (nhds b)\nhfg : Filter.Frequently (fun x => Eq (f x) (g x)) l\n⊢ Eq a b","decl":"theorem tendsto_nhds_unique_of_frequently_eq [T2Space X] {f g : Y → X} {l : Filter Y} {a b : X}\n    (ha : Tendsto f l (𝓝 a)) (hb : Tendsto g l (𝓝 b)) (hfg : ∃ᶠ x in l, f x = g x) : a = b :=\n  have : ∃ᶠ z : X × X in 𝓝 (a, b), z.1 = z.2 := (ha.prod_mk_nhds hb).frequently hfg\n  not_not.1 fun hne => this (isClosed_diagonal.isOpen_compl.mem_nhds hne)\n\n"}
{"name":"IsCompact.nhdsSet_inter_eq","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\ns t : Set X\nhs : IsCompact s\nht : IsCompact t\n⊢ Eq (nhdsSet (Inter.inter s t)) (Min.min (nhdsSet s) (nhdsSet t))","decl":"/-- If `s` and `t` are compact sets in a T₂ space, then the set neighborhoods filter of `s ∩ t`\nis the infimum of set neighborhoods filters for `s` and `t`.\n\nFor general sets, only the `≤` inequality holds, see `nhdsSet_inter_le`. -/\ntheorem IsCompact.nhdsSet_inter_eq [T2Space X] {s t : Set X} (hs : IsCompact s) (ht : IsCompact t) :\n    𝓝ˢ (s ∩ t) = 𝓝ˢ s ⊓ 𝓝ˢ t := by\n  refine le_antisymm (nhdsSet_inter_le _ _) ?_\n  simp_rw [hs.nhdsSet_inf_eq_biSup, ht.inf_nhdsSet_eq_biSup, nhdsSet, sSup_image]\n  refine iSup₂_le fun x hxs ↦ iSup₂_le fun y hyt ↦ ?_\n  rcases eq_or_ne x y with (rfl|hne)\n  · exact le_iSup₂_of_le x ⟨hxs, hyt⟩ (inf_idem _).le\n  · exact (disjoint_nhds_nhds.mpr hne).eq_bot ▸ bot_le\n\n"}
{"name":"IsCompact.separation_of_not_mem","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\nx : X\nt : Set X\nH1 : IsCompact t\nH2 : Not (Membership.mem t x)\n⊢ Exists fun U => Exists fun V => And (IsOpen U) (And (IsOpen V) (And (HasSubset.Subset t U) (And (Membership.mem V x) (Disjoint U V))))","decl":"/-- In a `T2Space X`, for a compact set `t` and a point `x` outside `t`, there are open sets `U`,\n`V` that separate `t` and `x`.-/\nlemma IsCompact.separation_of_not_mem {X : Type u_1} [TopologicalSpace X] [T2Space X] {x : X}\n    {t : Set X} (H1 : IsCompact t) (H2 : x ∉ t) :\n    ∃ (U : Set X), ∃ (V : Set X), IsOpen U ∧ IsOpen V ∧ t ⊆ U ∧ x ∈ V ∧ Disjoint U V := by\n  simpa [SeparatedNhds] using SeparatedNhds.of_isCompact_isCompact_isClosed H1 isCompact_singleton\n    isClosed_singleton <| disjoint_singleton_right.mpr H2\n\n"}
{"name":"IsCompact.disjoint_nhdsSet_nhds","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\nx : X\nt : Set X\nH1 : IsCompact t\nH2 : Not (Membership.mem t x)\n⊢ Disjoint (nhdsSet t) (nhds x)","decl":"/-- In a `T2Space X`, for a compact set `t` and a point `x` outside `t`, `𝓝ˢ t` and `𝓝 x` are\ndisjoint. -/\nlemma IsCompact.disjoint_nhdsSet_nhds {X : Type u_1} [TopologicalSpace X] [T2Space X] {x : X}\n    {t : Set X} (H1 : IsCompact t) (H2 : x ∉ t) :\n    Disjoint (𝓝ˢ t) (𝓝 x) := by\n  simpa using SeparatedNhds.disjoint_nhdsSet <| .of_isCompact_isCompact_isClosed H1\n    isCompact_singleton isClosed_singleton <| disjoint_singleton_right.mpr H2\n\n"}
{"name":"Set.InjOn.exists_mem_nhdsSet","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_3\nY : Type u_4\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space Y\nf : X → Y\ns : Set X\ninj : Set.InjOn f s\nsc : IsCompact s\nfc : ∀ (x : X), Membership.mem s x → ContinuousAt f x\nloc : ∀ (x : X), Membership.mem s x → Exists fun u => And (Membership.mem (nhds x) u) (Set.InjOn f u)\n⊢ Exists fun t => And (Membership.mem (nhdsSet s) t) (Set.InjOn f t)","decl":"/-- If a function `f` is\n\n- injective on a compact set `s`;\n- continuous at every point of this set;\n- injective on a neighborhood of each point of this set,\n\nthen it is injective on a neighborhood of this set. -/\ntheorem Set.InjOn.exists_mem_nhdsSet {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    [T2Space Y] {f : X → Y} {s : Set X} (inj : InjOn f s) (sc : IsCompact s)\n    (fc : ∀ x ∈ s, ContinuousAt f x) (loc : ∀ x ∈ s, ∃ u ∈ 𝓝 x, InjOn f u) :\n    ∃ t ∈ 𝓝ˢ s, InjOn f t := by\n  have : ∀ x ∈ s ×ˢ s, ∀ᶠ y in 𝓝 x, f y.1 = f y.2 → y.1 = y.2 := fun (x, y) ⟨hx, hy⟩ ↦ by\n    rcases eq_or_ne x y with rfl | hne\n    · rcases loc x hx with ⟨u, hu, hf⟩\n      exact Filter.mem_of_superset (prod_mem_nhds hu hu) <| forall_prod_set.2 hf\n    · suffices ∀ᶠ z in 𝓝 (x, y), f z.1 ≠ f z.2 from this.mono fun _ hne h ↦ absurd h hne\n      refine (fc x hx).prodMap' (fc y hy) <| isClosed_diagonal.isOpen_compl.mem_nhds ?_\n      exact inj.ne hx hy hne\n  rw [← eventually_nhdsSet_iff_forall, sc.nhdsSet_prod_eq sc] at this\n  exact eventually_prod_self_iff.1 this\n\n"}
{"name":"Set.InjOn.exists_isOpen_superset","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_3\nY : Type u_4\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space Y\nf : X → Y\ns : Set X\ninj : Set.InjOn f s\nsc : IsCompact s\nfc : ∀ (x : X), Membership.mem s x → ContinuousAt f x\nloc : ∀ (x : X), Membership.mem s x → Exists fun u => And (Membership.mem (nhds x) u) (Set.InjOn f u)\n⊢ Exists fun t => And (IsOpen t) (And (HasSubset.Subset s t) (Set.InjOn f t))","decl":"/-- If a function `f` is\n\n- injective on a compact set `s`;\n- continuous at every point of this set;\n- injective on a neighborhood of each point of this set,\n\nthen it is injective on an open neighborhood of this set. -/\ntheorem Set.InjOn.exists_isOpen_superset {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    [T2Space Y] {f : X → Y} {s : Set X} (inj : InjOn f s) (sc : IsCompact s)\n    (fc : ∀ x ∈ s, ContinuousAt f x) (loc : ∀ x ∈ s, ∃ u ∈ 𝓝 x, InjOn f u) :\n    ∃ t, IsOpen t ∧ s ⊆ t ∧ InjOn f t :=\n  let ⟨_t, hst, ht⟩ := inj.exists_mem_nhdsSet sc fc loc\n  let ⟨u, huo, hsu, hut⟩ := mem_nhdsSet_iff_exists.1 hst\n  ⟨u, huo, hsu, ht.mono hut⟩\n\n"}
{"name":"lim_eq","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : T2Space X\nf : Filter X\nx : X\ninst✝ : f.NeBot\nh : LE.le f (nhds x)\n⊢ Eq (lim f) x","decl":"theorem lim_eq {x : X} [NeBot f] (h : f ≤ 𝓝 x) : @lim _ _ ⟨x⟩ f = x :=\n  tendsto_nhds_unique (le_nhds_lim ⟨x, h⟩) h\n\n"}
{"name":"lim_eq_iff","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : T2Space X\nf : Filter X\ninst✝ : f.NeBot\nh : Exists fun x => LE.le f (nhds x)\nx : X\n⊢ Iff (Eq (lim f) x) (LE.le f (nhds x))","decl":"theorem lim_eq_iff [NeBot f] (h : ∃ x : X, f ≤ 𝓝 x) {x} : @lim _ _ ⟨x⟩ f = x ↔ f ≤ 𝓝 x :=\n  ⟨fun c => c ▸ le_nhds_lim h, lim_eq⟩\n\n"}
{"name":"Ultrafilter.lim_eq_iff_le_nhds","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : T2Space X\ninst✝ : CompactSpace X\nx : X\nF : Ultrafilter X\n⊢ Iff (Eq F.lim x) (LE.le (↑F) (nhds x))","decl":"theorem Ultrafilter.lim_eq_iff_le_nhds [CompactSpace X] {x : X} {F : Ultrafilter X} :\n    F.lim = x ↔ ↑F ≤ 𝓝 x :=\n  ⟨fun h => h ▸ F.le_nhds_lim, lim_eq⟩\n\n"}
{"name":"isOpen_iff_ultrafilter'","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : T2Space X\ninst✝ : CompactSpace X\nU : Set X\n⊢ Iff (IsOpen U) (∀ (F : Ultrafilter X), Membership.mem U F.lim → Membership.mem (↑F) U)","decl":"theorem isOpen_iff_ultrafilter' [CompactSpace X] (U : Set X) :\n    IsOpen U ↔ ∀ F : Ultrafilter X, F.lim ∈ U → U ∈ F.1 := by\n  rw [isOpen_iff_ultrafilter]\n  refine ⟨fun h F hF => h F.lim hF F F.le_nhds_lim, ?_⟩\n  intro cond x hx f h\n  rw [← Ultrafilter.lim_eq_iff_le_nhds.2 h] at hx\n  exact cond _ hx\n\n"}
{"name":"Filter.Tendsto.limUnder_eq","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : T2Space X\nx : X\nf : Filter Y\ninst✝ : f.NeBot\ng : Y → X\nh : Filter.Tendsto g f (nhds x)\n⊢ Eq (limUnder f g) x","decl":"theorem Filter.Tendsto.limUnder_eq {x : X} {f : Filter Y} [NeBot f] {g : Y → X}\n    (h : Tendsto g f (𝓝 x)) : @limUnder _ _ _ ⟨x⟩ f g = x :=\n  lim_eq h\n\n"}
{"name":"Filter.limUnder_eq_iff","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : T2Space X\nf : Filter Y\ninst✝ : f.NeBot\ng : Y → X\nh : Exists fun x => Filter.Tendsto g f (nhds x)\nx : X\n⊢ Iff (Eq (limUnder f g) x) (Filter.Tendsto g f (nhds x))","decl":"theorem Filter.limUnder_eq_iff {f : Filter Y} [NeBot f] {g : Y → X} (h : ∃ x, Tendsto g f (𝓝 x))\n    {x} : @limUnder _ _ _ ⟨x⟩ f g = x ↔ Tendsto g f (𝓝 x) :=\n  ⟨fun c => c ▸ tendsto_nhds_limUnder h, Filter.Tendsto.limUnder_eq⟩\n\n"}
{"name":"Continuous.limUnder_eq","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : T2Space X\ninst✝ : TopologicalSpace Y\nf : Y → X\nh : Continuous f\ny : Y\n⊢ Eq (limUnder (nhds y) f) (f y)","decl":"theorem Continuous.limUnder_eq [TopologicalSpace Y] {f : Y → X} (h : Continuous f) (y : Y) :\n    @limUnder _ _ _ ⟨f y⟩ (𝓝 y) f = f y :=\n  (h.tendsto y).limUnder_eq\n\n"}
{"name":"lim_nhds","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\nx : X\n⊢ Eq (lim (nhds x)) x","decl":"@[simp]\ntheorem lim_nhds (x : X) : @lim _ _ ⟨x⟩ (𝓝 x) = x :=\n  lim_eq le_rfl\n\n"}
{"name":"limUnder_nhds_id","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\nx : X\n⊢ Eq (limUnder (nhds x) id) x","decl":"@[simp]\ntheorem limUnder_nhds_id (x : X) : @limUnder _ _ _ ⟨x⟩ (𝓝 x) id = x :=\n  lim_nhds x\n\n"}
{"name":"lim_nhdsWithin","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\nx : X\ns : Set X\nh : Membership.mem (closure s) x\n⊢ Eq (lim (nhdsWithin x s)) x","decl":"@[simp]\ntheorem lim_nhdsWithin {x : X} {s : Set X} (h : x ∈ closure s) : @lim _ _ ⟨x⟩ (𝓝[s] x) = x :=\n  haveI : NeBot (𝓝[s] x) := mem_closure_iff_clusterPt.1 h\n  lim_eq inf_le_left\n\n"}
{"name":"limUnder_nhdsWithin_id","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\nx : X\ns : Set X\nh : Membership.mem (closure s) x\n⊢ Eq (limUnder (nhdsWithin x s) id) x","decl":"@[simp]\ntheorem limUnder_nhdsWithin_id {x : X} {s : Set X} (h : x ∈ closure s) :\n    @limUnder _ _ _ ⟨x⟩ (𝓝[s] x) id = x :=\n  lim_nhdsWithin h\n\n"}
{"name":"DiscreteTopology.toT2Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : DiscreteTopology X\n⊢ T2Space X","decl":"instance (priority := 100) DiscreteTopology.toT2Space\n    [DiscreteTopology X] : T2Space X :=\n  ⟨fun x y h => ⟨{x}, {y}, isOpen_discrete _, isOpen_discrete _, rfl, rfl, disjoint_singleton.2 h⟩⟩\n\n"}
{"name":"separated_by_continuous","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space Y\nf : X → Y\nhf : Continuous f\nx y : X\nh : Ne (f x) (f y)\n⊢ Exists fun u => Exists fun v => And (IsOpen u) (And (IsOpen v) (And (Membership.mem u x) (And (Membership.mem v y) (Disjoint u v))))","decl":"theorem separated_by_continuous [TopologicalSpace Y] [T2Space Y]\n    {f : X → Y} (hf : Continuous f) {x y : X} (h : f x ≠ f y) :\n    ∃ u v : Set X, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v :=\n  let ⟨u, v, uo, vo, xu, yv, uv⟩ := t2_separation h\n  ⟨f ⁻¹' u, f ⁻¹' v, uo.preimage hf, vo.preimage hf, xu, yv, uv.preimage _⟩\n\n"}
{"name":"separated_by_isOpenEmbedding","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space X\nf : X → Y\nhf : Topology.IsOpenEmbedding f\nx y : X\nh : Ne x y\n⊢ Exists fun u => Exists fun v => And (IsOpen u) (And (IsOpen v) (And (Membership.mem u (f x)) (And (Membership.mem v (f y)) (Disjoint u v))))","decl":"theorem separated_by_isOpenEmbedding [TopologicalSpace Y] [T2Space X]\n    {f : X → Y} (hf : IsOpenEmbedding f) {x y : X} (h : x ≠ y) :\n    ∃ u v : Set Y, IsOpen u ∧ IsOpen v ∧ f x ∈ u ∧ f y ∈ v ∧ Disjoint u v :=\n  let ⟨u, v, uo, vo, xu, yv, uv⟩ := t2_separation h\n  ⟨f '' u, f '' v, hf.isOpenMap _ uo, hf.isOpenMap _ vo, mem_image_of_mem _ xu,\n    mem_image_of_mem _ yv, disjoint_image_of_injective hf.injective uv⟩\n\n"}
{"name":"separated_by_openEmbedding","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space X\nf : X → Y\nhf : Topology.IsOpenEmbedding f\nx y : X\nh : Ne x y\n⊢ Exists fun u => Exists fun v => And (IsOpen u) (And (IsOpen v) (And (Membership.mem u (f x)) (And (Membership.mem v (f y)) (Disjoint u v))))","decl":"@[deprecated (since := \"2024-10-18\")]\nalias separated_by_openEmbedding := separated_by_isOpenEmbedding\n\n"}
{"name":"instT2SpaceSubtype","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\np : X → Prop\ninst✝ : T2Space X\n⊢ T2Space (Subtype p)","decl":"instance {p : X → Prop} [T2Space X] : T2Space (Subtype p) := inferInstance\n\n"}
{"name":"Prod.t2Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : T2Space X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space Y\n⊢ T2Space (Prod X Y)","decl":"instance Prod.t2Space [T2Space X] [TopologicalSpace Y] [T2Space Y] : T2Space (X × Y) :=\n  inferInstance\n\n"}
{"name":"T2Space.of_injective_continuous","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space Y\nf : X → Y\nhinj : Function.Injective f\nhc : Continuous f\n⊢ T2Space X","decl":"/-- If the codomain of an injective continuous function is a Hausdorff space, then so is its\ndomain. -/\ntheorem T2Space.of_injective_continuous [TopologicalSpace Y] [T2Space Y] {f : X → Y}\n    (hinj : Injective f) (hc : Continuous f) : T2Space X :=\n  ⟨fun _ _ h => separated_by_continuous hc (hinj.ne h)⟩\n\n"}
{"name":"Topology.IsEmbedding.t2Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space Y\nf : X → Y\nhf : Topology.IsEmbedding f\n⊢ T2Space X","decl":"/-- If the codomain of a topological embedding is a Hausdorff space, then so is its domain.\nSee also `T2Space.of_continuous_injective`. -/\ntheorem Topology.IsEmbedding.t2Space [TopologicalSpace Y] [T2Space Y] {f : X → Y}\n    (hf : IsEmbedding f) : T2Space X :=\n  .of_injective_continuous hf.injective hf.continuous\n\n"}
{"name":"Embedding.t2Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space Y\nf : X → Y\nhf : Topology.IsEmbedding f\n⊢ T2Space X","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.t2Space := IsEmbedding.t2Space\n\n"}
{"name":"ULift.instT2Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\n⊢ T2Space (ULift.{u_3, u_1} X)","decl":"instance ULift.instT2Space [T2Space X] : T2Space (ULift X) :=\n  IsEmbedding.uliftDown.t2Space\n\n"}
{"name":"instT2SpaceSum","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : T2Space X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space Y\n⊢ T2Space (Sum X Y)","decl":"instance [T2Space X] [TopologicalSpace Y] [T2Space Y] :\n    T2Space (X ⊕ Y) := by\n  constructor\n  rintro (x | x) (y | y) h\n  · exact separated_by_isOpenEmbedding .inl <| ne_of_apply_ne _ h\n  · exact separated_by_continuous continuous_isLeft <| by simp\n  · exact separated_by_continuous continuous_isLeft <| by simp\n  · exact separated_by_isOpenEmbedding .inr <| ne_of_apply_ne _ h\n\n"}
{"name":"Pi.t2Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : X → Type v\ninst✝¹ : (a : X) → TopologicalSpace (Y a)\ninst✝ : ∀ (a : X), T2Space (Y a)\n⊢ T2Space ((a : X) → Y a)","decl":"instance Pi.t2Space {Y : X → Type v} [∀ a, TopologicalSpace (Y a)]\n    [∀ a, T2Space (Y a)] : T2Space (∀ a, Y a) :=\n  inferInstance\n\n"}
{"name":"Sigma.t2Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"ι : Type u_4\nX : ι → Type u_3\ninst✝¹ : (i : ι) → TopologicalSpace (X i)\ninst✝ : ∀ (a : ι), T2Space (X a)\n⊢ T2Space (Sigma fun i => X i)","decl":"instance Sigma.t2Space {ι} {X : ι → Type*} [∀ i, TopologicalSpace (X i)] [∀ a, T2Space (X a)] :\n    T2Space (Σi, X i) := by\n  constructor\n  rintro ⟨i, x⟩ ⟨j, y⟩ neq\n  rcases eq_or_ne i j with (rfl | h)\n  · replace neq : x ≠ y := ne_of_apply_ne _ neq\n    exact separated_by_isOpenEmbedding .sigmaMk neq\n  · let _ := (⊥ : TopologicalSpace ι); have : DiscreteTopology ι := ⟨rfl⟩\n    exact separated_by_continuous (continuous_def.2 fun u _ => isOpen_sigma_fst_preimage u) h\n\n"}
{"name":"t2Quotient.mk_eq","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (Eq (t2Quotient.mk x) (t2Quotient.mk y)) (∀ (s : Setoid X), T2Space (Quotient s) → s x y)","decl":"lemma mk_eq {x y : X} : mk x = mk y ↔ ∀ s : Setoid X, T2Space (Quotient s) → s x y :=\n  Setoid.quotient_mk_sInf_eq\n\n"}
{"name":"t2Quotient.surjective_mk","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Function.Surjective t2Quotient.mk","decl":"lemma surjective_mk : Surjective (mk : X → t2Quotient X) := Quotient.mk_surjective\n\n"}
{"name":"t2Quotient.continuous_mk","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Continuous t2Quotient.mk","decl":"lemma continuous_mk : Continuous (mk : X → t2Quotient X) :=\n  continuous_quotient_mk'\n\n"}
{"name":"t2Quotient.inductionOn","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nmotive : t2Quotient X → Prop\nq : t2Quotient X\nh : ∀ (x : X), motive (t2Quotient.mk x)\n⊢ motive q","decl":"@[elab_as_elim]\nprotected lemma inductionOn {motive : t2Quotient X → Prop} (q : t2Quotient X)\n    (h : ∀ x, motive (t2Quotient.mk x)) : motive q := Quotient.inductionOn q h\n\n"}
{"name":"t2Quotient.inductionOn₂","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nmotive : t2Quotient X → t2Quotient Y → Prop\nq : t2Quotient X\nq' : t2Quotient Y\nh : ∀ (x : X) (y : Y), motive (t2Quotient.mk x) (t2Quotient.mk y)\n⊢ motive q q'","decl":"@[elab_as_elim]\nprotected lemma inductionOn₂ [TopologicalSpace Y] {motive : t2Quotient X → t2Quotient Y → Prop}\n    (q : t2Quotient X) (q' : t2Quotient Y) (h : ∀ x y, motive (mk x) (mk y)) : motive q q' :=\n  Quotient.inductionOn₂ q q' h\n\n"}
{"name":"t2Quotient.instT2Space","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ T2Space (t2Quotient X)","decl":"/-- The largest T2 quotient of a topological space is indeed T2. -/\ninstance : T2Space (t2Quotient X) := by\n  rw [t2Space_iff]\n  rintro ⟨x⟩ ⟨y⟩ (h : ¬ t2Quotient.mk x = t2Quotient.mk y)\n  obtain ⟨s, hs, hsxy⟩ : ∃ s, T2Space (Quotient s) ∧ Quotient.mk s x ≠ Quotient.mk s y := by\n    simpa [t2Quotient.mk_eq] using h\n  exact separated_by_continuous (continuous_map_sInf (by exact hs)) hsxy\n\n"}
{"name":"t2Quotient.compatible","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_3\nY : Type u_4\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space Y\nf : X → Y\nhf : Continuous f\na b : X\na✝ : HasEquiv.Equiv a b\n⊢ Eq (f a) (f b)","decl":"lemma compatible {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] [T2Space Y]\n    {f : X → Y} (hf : Continuous f) : letI _ := t2Setoid X\n    ∀ (a b : X), a ≈ b → f a = f b := by\n  change t2Setoid X ≤ Setoid.ker f\n  exact sInf_le <| .of_injective_continuous\n    (Setoid.ker_lift_injective _) (hf.quotient_lift fun _ _ ↦ id)\n\n"}
{"name":"t2Quotient.continuous_lift","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_3\nY : Type u_4\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space Y\nf : X → Y\nhf : Continuous f\n⊢ Continuous (t2Quotient.lift hf)","decl":"lemma continuous_lift {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] [T2Space Y]\n    {f : X → Y} (hf : Continuous f) : Continuous (t2Quotient.lift hf) :=\n  continuous_coinduced_dom.mpr hf\n\n"}
{"name":"t2Quotient.lift_mk","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_3\nY : Type u_4\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space Y\nf : X → Y\nhf : Continuous f\nx : X\n⊢ Eq (t2Quotient.lift hf (t2Quotient.mk x)) (f x)","decl":"@[simp]\nlemma lift_mk {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] [T2Space Y]\n    {f : X → Y} (hf : Continuous f) (x : X) : lift hf (mk x) = f x :=\n  Quotient.lift_mk (s := t2Setoid X) f (t2Quotient.compatible hf) x\n\n"}
{"name":"t2Quotient.unique_lift","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_3\nY : Type u_4\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space Y\nf : X → Y\nhf : Continuous f\ng : t2Quotient X → Y\nhfg : Eq (Function.comp g t2Quotient.mk) f\n⊢ Eq g (t2Quotient.lift hf)","decl":"lemma unique_lift {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] [T2Space Y]\n    {f : X → Y} (hf : Continuous f) {g : t2Quotient X → Y} (hfg : g ∘ mk = f) :\n    g = lift hf := by\n  apply surjective_mk X |>.right_cancellable |>.mp <| funext _\n  simp [← hfg]\n\n"}
{"name":"isClosed_eq","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space X\nf g : Y → X\nhf : Continuous f\nhg : Continuous g\n⊢ IsClosed (setOf fun y => Eq (f y) (g y))","decl":"theorem isClosed_eq [T2Space X] {f g : Y → X} (hf : Continuous f) (hg : Continuous g) :\n    IsClosed { y : Y | f y = g y } :=\n  continuous_iff_isClosed.mp (hf.prod_mk hg) _ isClosed_diagonal\n\n"}
{"name":"IsClosed.isClosed_eq","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space Y\nf g : X → Y\ns : Set X\nhs : IsClosed s\nhf : ContinuousOn f s\nhg : ContinuousOn g s\n⊢ IsClosed (setOf fun x => And (Membership.mem s x) (Eq (f x) (g x)))","decl":"/-- If functions `f` and `g` are continuous on a closed set `s`,\nthen the set of points `x ∈ s` such that `f x = g x` is a closed set. -/\nprotected theorem IsClosed.isClosed_eq [T2Space Y] {f g : X → Y} {s : Set X} (hs : IsClosed s)\n    (hf : ContinuousOn f s) (hg : ContinuousOn g s) : IsClosed {x ∈ s | f x = g x} :=\n  (hf.prod hg).preimage_isClosed_of_isClosed hs isClosed_diagonal\n\n"}
{"name":"isOpen_ne_fun","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space X\nf g : Y → X\nhf : Continuous f\nhg : Continuous g\n⊢ IsOpen (setOf fun y => Ne (f y) (g y))","decl":"theorem isOpen_ne_fun [T2Space X] {f g : Y → X} (hf : Continuous f) (hg : Continuous g) :\n    IsOpen { y : Y | f y ≠ g y } :=\n  isOpen_compl_iff.mpr <| isClosed_eq hf hg\n\n"}
{"name":"Set.EqOn.closure","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space X\ns : Set Y\nf g : Y → X\nh : Set.EqOn f g s\nhf : Continuous f\nhg : Continuous g\n⊢ Set.EqOn f g (closure s)","decl":"/-- If two continuous maps are equal on `s`, then they are equal on the closure of `s`. See also\n`Set.EqOn.of_subset_closure` for a more general version. -/\nprotected theorem Set.EqOn.closure [T2Space X] {s : Set Y} {f g : Y → X} (h : EqOn f g s)\n    (hf : Continuous f) (hg : Continuous g) : EqOn f g (closure s) :=\n  closure_minimal h (isClosed_eq hf hg)\n\n"}
{"name":"Continuous.ext_on","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space X\ns : Set Y\nhs : Dense s\nf g : Y → X\nhf : Continuous f\nhg : Continuous g\nh : Set.EqOn f g s\n⊢ Eq f g","decl":"/-- If two continuous functions are equal on a dense set, then they are equal. -/\ntheorem Continuous.ext_on [T2Space X] {s : Set Y} (hs : Dense s) {f g : Y → X} (hf : Continuous f)\n    (hg : Continuous g) (h : EqOn f g s) : f = g :=\n  funext fun x => h.closure hf hg (hs x)\n\n"}
{"name":"eqOn_closure₂'","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : TopologicalSpace X\nZ : Type u_3\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : T2Space Z\ns : Set X\nt : Set Y\nf g : X → Y → Z\nh : ∀ (x : X), Membership.mem s x → ∀ (y : Y), Membership.mem t y → Eq (f x y) (g x y)\nhf₁ : ∀ (x : X), Continuous (f x)\nhf₂ : ∀ (y : Y), Continuous fun x => f x y\nhg₁ : ∀ (x : X), Continuous (g x)\nhg₂ : ∀ (y : Y), Continuous fun x => g x y\nx : X\na✝¹ : Membership.mem (closure s) x\ny : Y\na✝ : Membership.mem (closure t) y\n⊢ Eq (f x y) (g x y)","decl":"theorem eqOn_closure₂' [T2Space Z] {s : Set X} {t : Set Y} {f g : X → Y → Z}\n    (h : ∀ x ∈ s, ∀ y ∈ t, f x y = g x y) (hf₁ : ∀ x, Continuous (f x))\n    (hf₂ : ∀ y, Continuous fun x => f x y) (hg₁ : ∀ x, Continuous (g x))\n    (hg₂ : ∀ y, Continuous fun x => g x y) : ∀ x ∈ closure s, ∀ y ∈ closure t, f x y = g x y :=\n  suffices closure s ⊆ ⋂ y ∈ closure t, { x | f x y = g x y } by simpa only [subset_def, mem_iInter]\n  (closure_minimal fun x hx => mem_iInter₂.2 <| Set.EqOn.closure (h x hx) (hf₁ _) (hg₁ _)) <|\n    isClosed_biInter fun _ _ => isClosed_eq (hf₂ _) (hg₂ _)\n\n"}
{"name":"eqOn_closure₂","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : TopologicalSpace X\nZ : Type u_3\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : T2Space Z\ns : Set X\nt : Set Y\nf g : X → Y → Z\nh : ∀ (x : X), Membership.mem s x → ∀ (y : Y), Membership.mem t y → Eq (f x y) (g x y)\nhf : Continuous (Function.uncurry f)\nhg : Continuous (Function.uncurry g)\nx : X\na✝¹ : Membership.mem (closure s) x\ny : Y\na✝ : Membership.mem (closure t) y\n⊢ Eq (f x y) (g x y)","decl":"theorem eqOn_closure₂ [T2Space Z] {s : Set X} {t : Set Y} {f g : X → Y → Z}\n    (h : ∀ x ∈ s, ∀ y ∈ t, f x y = g x y) (hf : Continuous (uncurry f))\n    (hg : Continuous (uncurry g)) : ∀ x ∈ closure s, ∀ y ∈ closure t, f x y = g x y :=\n  eqOn_closure₂' h hf.uncurry_left hf.uncurry_right hg.uncurry_left hg.uncurry_right\n\n"}
{"name":"Set.EqOn.of_subset_closure","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space Y\ns t : Set X\nf g : X → Y\nh : Set.EqOn f g s\nhf : ContinuousOn f t\nhg : ContinuousOn g t\nhst : HasSubset.Subset s t\nhts : HasSubset.Subset t (closure s)\n⊢ Set.EqOn f g t","decl":"/-- If `f x = g x` for all `x ∈ s` and `f`, `g` are continuous on `t`, `s ⊆ t ⊆ closure s`, then\n`f x = g x` for all `x ∈ t`. See also `Set.EqOn.closure`. -/\ntheorem Set.EqOn.of_subset_closure [T2Space Y] {s t : Set X} {f g : X → Y} (h : EqOn f g s)\n    (hf : ContinuousOn f t) (hg : ContinuousOn g t) (hst : s ⊆ t) (hts : t ⊆ closure s) :\n    EqOn f g t := by\n  intro x hx\n  have : (𝓝[s] x).NeBot := mem_closure_iff_clusterPt.mp (hts hx)\n  exact\n    tendsto_nhds_unique_of_eventuallyEq ((hf x hx).mono_left <| nhdsWithin_mono _ hst)\n      ((hg x hx).mono_left <| nhdsWithin_mono _ hst) (h.eventuallyEq_of_mem self_mem_nhdsWithin)\n\n"}
{"name":"Function.LeftInverse.isClosed_range","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space X\nf : X → Y\ng : Y → X\nh : Function.LeftInverse f g\nhf : Continuous f\nhg : Continuous g\n⊢ IsClosed (Set.range g)","decl":"theorem Function.LeftInverse.isClosed_range [T2Space X] {f : X → Y} {g : Y → X}\n    (h : Function.LeftInverse f g) (hf : Continuous f) (hg : Continuous g) : IsClosed (range g) :=\n  have : EqOn (g ∘ f) id (closure <| range g) :=\n    h.rightInvOn_range.eqOn.closure (hg.comp hf) continuous_id\n  isClosed_of_closure_subset fun x hx => ⟨f x, this hx⟩\n\n"}
{"name":"Function.LeftInverse.isClosedEmbedding","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space X\nf : X → Y\ng : Y → X\nh : Function.LeftInverse f g\nhf : Continuous f\nhg : Continuous g\n⊢ Topology.IsClosedEmbedding g","decl":"theorem Function.LeftInverse.isClosedEmbedding [T2Space X] {f : X → Y} {g : Y → X}\n    (h : Function.LeftInverse f g) (hf : Continuous f) (hg : Continuous g) : IsClosedEmbedding g :=\n  ⟨.of_leftInverse h hf hg, h.isClosed_range hf hg⟩\n\n"}
{"name":"Function.LeftInverse.closedEmbedding","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space X\nf : X → Y\ng : Y → X\nh : Function.LeftInverse f g\nhf : Continuous f\nhg : Continuous g\n⊢ Topology.IsClosedEmbedding g","decl":"@[deprecated (since := \"2024-10-20\")]\nalias Function.LeftInverse.closedEmbedding := Function.LeftInverse.isClosedEmbedding\n\n"}
{"name":"SeparatedNhds.of_isCompact_isCompact","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\ns t : Set X\nhs : IsCompact s\nht : IsCompact t\nhst : Disjoint s t\n⊢ SeparatedNhds s t","decl":"theorem SeparatedNhds.of_isCompact_isCompact [T2Space X] {s t : Set X} (hs : IsCompact s)\n    (ht : IsCompact t) (hst : Disjoint s t) : SeparatedNhds s t := by\n  simp only [SeparatedNhds, prod_subset_compl_diagonal_iff_disjoint.symm] at hst ⊢\n  exact generalized_tube_lemma hs ht isClosed_diagonal.isOpen_compl hst\n\n"}
{"name":"SeparatedNhds.of_isClosed_isCompact_closure_compl_isClosed","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\ns t : Set X\nH1 : IsClosed s\nH2 : IsCompact (closure (HasCompl.compl s))\nH3 : IsClosed t\nH4 : Disjoint s t\n⊢ SeparatedNhds s t","decl":"/-- In a `T2Space X`, for disjoint closed sets `s t` such that `closure sᶜ` is compact,\nthere are neighbourhoods that separate `s` and `t`.-/\nlemma SeparatedNhds.of_isClosed_isCompact_closure_compl_isClosed [T2Space X] {s : Set X}\n    {t : Set X} (H1 : IsClosed s) (H2 : IsCompact (closure sᶜ)) (H3 : IsClosed t)\n    (H4 : Disjoint s t) : SeparatedNhds s t := by\n  -- Since `t` is a closed subset of the compact set `closure sᶜ`, it is compact.\n  have ht : IsCompact t := .of_isClosed_subset H2 H3 <| H4.subset_compl_left.trans subset_closure\n  -- we split `s` into its frontier and its interior.\n  rw [← diff_union_of_subset (interior_subset (s := s))]\n  -- since `t ⊆ sᶜ`, which is open, and `interior s` is open, we have\n  -- `SeparatedNhds (interior s) t`, which leaves us only with the frontier.\n  refine .union_left ?_ ⟨interior s, sᶜ, isOpen_interior, H1.isOpen_compl, le_rfl,\n    H4.subset_compl_left, disjoint_compl_right.mono_left interior_subset⟩\n  -- Since the frontier of `s` is compact (as it is a subset of `closure sᶜ`), we simply apply\n  -- `SeparatedNhds_of_isCompact_isCompact`.\n  rw [← H1.frontier_eq, frontier_eq_closure_inter_closure, H1.closure_eq]\n  refine .of_isCompact_isCompact ?_ ht (disjoint_of_subset_left inter_subset_left H4)\n  exact H2.of_isClosed_subset (H1.inter isClosed_closure) inter_subset_right\n\n"}
{"name":"SeparatedNhds.of_finset_finset","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\ns t : Finset X\nh : Disjoint s t\n⊢ SeparatedNhds ↑s ↑t","decl":"theorem SeparatedNhds.of_finset_finset [T2Space X] (s t : Finset X) (h : Disjoint s t) :\n    SeparatedNhds (s : Set X) t :=\n  .of_isCompact_isCompact s.finite_toSet.isCompact t.finite_toSet.isCompact <| mod_cast h\n\n"}
{"name":"SeparatedNhds.of_singleton_finset","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\nx : X\ns : Finset X\nh : Not (Membership.mem s x)\n⊢ SeparatedNhds (Singleton.singleton x) ↑s","decl":"theorem SeparatedNhds.of_singleton_finset [T2Space X] {x : X} {s : Finset X} (h : x ∉ s) :\n    SeparatedNhds ({x} : Set X) s :=\n  mod_cast .of_finset_finset {x} s (Finset.disjoint_singleton_left.mpr h)\n\n"}
{"name":"IsCompact.isClosed","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\ns : Set X\nhs : IsCompact s\n⊢ IsClosed s","decl":"/-- In a `T2Space`, every compact set is closed. -/\ntheorem IsCompact.isClosed [T2Space X] {s : Set X} (hs : IsCompact s) : IsClosed s :=\n  isOpen_compl_iff.1 <| isOpen_iff_forall_mem_open.mpr fun x hx =>\n    let ⟨u, v, _, vo, su, xv, uv⟩ :=\n      SeparatedNhds.of_isCompact_isCompact hs isCompact_singleton (disjoint_singleton_right.2 hx)\n    ⟨v, (uv.mono_left <| show s ≤ u from su).subset_compl_left, vo, by simpa using xv⟩\n\n"}
{"name":"IsCompact.preimage_continuous","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : CompactSpace X\ninst✝ : T2Space Y\nf : X → Y\ns : Set Y\nhs : IsCompact s\nhf : Continuous f\n⊢ IsCompact (Set.preimage f s)","decl":"theorem IsCompact.preimage_continuous [CompactSpace X] [T2Space Y] {f : X → Y} {s : Set Y}\n    (hs : IsCompact s) (hf : Continuous f) : IsCompact (f ⁻¹' s) :=\n  (hs.isClosed.preimage hf).isCompact\n\n"}
{"name":"Pi.isCompact_iff","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"ι : Type u_4\nπ : ι → Type u_5\ninst✝¹ : (i : ι) → TopologicalSpace (π i)\ninst✝ : ∀ (i : ι), T2Space (π i)\ns : Set ((i : ι) → π i)\n⊢ Iff (IsCompact s) (And (IsClosed s) (∀ (i : ι), IsCompact (Set.image (Function.eval i) s)))","decl":"lemma Pi.isCompact_iff {ι : Type*} {π : ι → Type*} [∀ i, TopologicalSpace (π i)]\n    [∀ i, T2Space (π i)] {s : Set (Π i, π i)} :\n    IsCompact s ↔ IsClosed s ∧ ∀ i, IsCompact (eval i '' s) := by\n  constructor <;> intro H\n  · exact ⟨H.isClosed, fun i ↦ H.image <| continuous_apply i⟩\n  · exact IsCompact.of_isClosed_subset (isCompact_univ_pi H.2) H.1 (subset_pi_eval_image univ s)\n\n"}
{"name":"Pi.isCompact_closure_iff","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"ι : Type u_4\nπ : ι → Type u_5\ninst✝¹ : (i : ι) → TopologicalSpace (π i)\ninst✝ : ∀ (i : ι), T2Space (π i)\ns : Set ((i : ι) → π i)\n⊢ Iff (IsCompact (closure s)) (∀ (i : ι), IsCompact (closure (Set.image (Function.eval i) s)))","decl":"lemma Pi.isCompact_closure_iff {ι : Type*} {π : ι → Type*} [∀ i, TopologicalSpace (π i)]\n    [∀ i, T2Space (π i)] {s : Set (Π i, π i)} :\n    IsCompact (closure s) ↔ ∀ i, IsCompact (closure <| eval i '' s) := by\n  simp_rw [← exists_isCompact_superset_iff, Pi.exists_compact_superset_iff, image_subset_iff]\n\n"}
{"name":"exists_subset_nhds_of_isCompact","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : T2Space X\nι : Type u_4\ninst✝ : Nonempty ι\nV : ι → Set X\nhV : Directed (fun x1 x2 => Superset x1 x2) V\nhV_cpct : ∀ (i : ι), IsCompact (V i)\nU : Set X\nhU : ∀ (x : X), Membership.mem (Set.iInter fun i => V i) x → Membership.mem (nhds x) U\n⊢ Exists fun i => HasSubset.Subset (V i) U","decl":"/-- If `V : ι → Set X` is a decreasing family of compact sets then any neighborhood of\n`⋂ i, V i` contains some `V i`. This is a version of `exists_subset_nhds_of_isCompact'` where we\ndon't need to assume each `V i` closed because it follows from compactness since `X` is\nassumed to be Hausdorff. -/\ntheorem exists_subset_nhds_of_isCompact [T2Space X] {ι : Type*} [Nonempty ι] {V : ι → Set X}\n    (hV : Directed (· ⊇ ·) V) (hV_cpct : ∀ i, IsCompact (V i)) {U : Set X}\n    (hU : ∀ x ∈ ⋂ i, V i, U ∈ 𝓝 x) : ∃ i, V i ⊆ U :=\n  exists_subset_nhds_of_isCompact' hV hV_cpct (fun i => (hV_cpct i).isClosed) hU\n\n"}
{"name":"CompactExhaustion.isClosed","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\nK : CompactExhaustion X\nn : Nat\n⊢ IsClosed (K n)","decl":"theorem CompactExhaustion.isClosed [T2Space X] (K : CompactExhaustion X) (n : ℕ) : IsClosed (K n) :=\n  (K.isCompact n).isClosed\n\n"}
{"name":"IsCompact.inter","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\ns t : Set X\nhs : IsCompact s\nht : IsCompact t\n⊢ IsCompact (Inter.inter s t)","decl":"theorem IsCompact.inter [T2Space X] {s t : Set X} (hs : IsCompact s) (ht : IsCompact t) :\n    IsCompact (s ∩ t) :=\n  hs.inter_right <| ht.isClosed\n\n"}
{"name":"image_closure_of_isCompact","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space Y\ns : Set X\nhs : IsCompact (closure s)\nf : X → Y\nhf : ContinuousOn f (closure s)\n⊢ Eq (Set.image f (closure s)) (closure (Set.image f s))","decl":"theorem image_closure_of_isCompact [T2Space Y] {s : Set X} (hs : IsCompact (closure s)) {f : X → Y}\n    (hf : ContinuousOn f (closure s)) : f '' closure s = closure (f '' s) :=\n  Subset.antisymm hf.image_closure <|\n    closure_minimal (image_subset f subset_closure) (hs.image_of_continuousOn hf).isClosed\n\n"}
{"name":"Continuous.isClosedMap","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : CompactSpace X\ninst✝ : T2Space Y\nf : X → Y\nh : Continuous f\n⊢ IsClosedMap f","decl":"/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\nprotected theorem Continuous.isClosedMap [CompactSpace X] [T2Space Y] {f : X → Y}\n    (h : Continuous f) : IsClosedMap f := fun _s hs => (hs.isCompact.image h).isClosed\n\n"}
{"name":"Continuous.isClosedEmbedding","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : CompactSpace X\ninst✝ : T2Space Y\nf : X → Y\nh : Continuous f\nhf : Function.Injective f\n⊢ Topology.IsClosedEmbedding f","decl":"/-- A continuous injective map from a compact space to a Hausdorff space is a closed embedding. -/\ntheorem Continuous.isClosedEmbedding [CompactSpace X] [T2Space Y] {f : X → Y} (h : Continuous f)\n    (hf : Function.Injective f) : IsClosedEmbedding f :=\n  .of_continuous_injective_isClosedMap h hf h.isClosedMap\n\n"}
{"name":"Continuous.closedEmbedding","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : CompactSpace X\ninst✝ : T2Space Y\nf : X → Y\nh : Continuous f\nhf : Function.Injective f\n⊢ Topology.IsClosedEmbedding f","decl":"@[deprecated (since := \"2024-10-20\")]\nalias Continuous.closedEmbedding := Continuous.isClosedEmbedding\n\n"}
{"name":"IsQuotientMap.of_surjective_continuous","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : CompactSpace X\ninst✝ : T2Space Y\nf : X → Y\nhsurj : Function.Surjective f\nhcont : Continuous f\n⊢ Topology.IsQuotientMap f","decl":"/-- A continuous surjective map from a compact space to a Hausdorff space is a quotient map. -/\ntheorem IsQuotientMap.of_surjective_continuous [CompactSpace X] [T2Space Y] {f : X → Y}\n    (hsurj : Surjective f) (hcont : Continuous f) : IsQuotientMap f :=\n  hcont.isClosedMap.isQuotientMap hcont hsurj\n\n"}
{"name":"QuotientMap.of_surjective_continuous","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : CompactSpace X\ninst✝ : T2Space Y\nf : X → Y\nhsurj : Function.Surjective f\nhcont : Continuous f\n⊢ Topology.IsQuotientMap f","decl":"@[deprecated (since := \"2024-10-22\")]\nalias QuotientMap.of_surjective_continuous := IsQuotientMap.of_surjective_continuous\n\n"}
{"name":"isPreirreducible_iff_subsingleton","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\nS : Set X\n⊢ Iff (IsPreirreducible S) S.Subsingleton","decl":"theorem isPreirreducible_iff_subsingleton [T2Space X] {S : Set X} :\n    IsPreirreducible S ↔ S.Subsingleton := by\n  refine ⟨fun h x hx y hy => ?_, Set.Subsingleton.isPreirreducible⟩\n  by_contra e\n  obtain ⟨U, V, hU, hV, hxU, hyV, h'⟩ := t2_separation e\n  exact ((h U V hU hV ⟨x, hx, hxU⟩ ⟨y, hy, hyV⟩).mono inter_subset_right).not_disjoint h'\n\n-- todo: use `alias` + `attribute [protected]` once we get `attribute [protected]`\n"}
{"name":"IsPreirreducible.subsingleton","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\nS : Set X\nh : IsPreirreducible S\n⊢ S.Subsingleton","decl":"protected lemma IsPreirreducible.subsingleton [T2Space X] {S : Set X} (h : IsPreirreducible S) :\n    S.Subsingleton :=\n  isPreirreducible_iff_subsingleton.1 h\n\n"}
{"name":"isIrreducible_iff_singleton","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\nS : Set X\n⊢ Iff (IsIrreducible S) (Exists fun x => Eq S (Singleton.singleton x))","decl":"theorem isIrreducible_iff_singleton [T2Space X] {S : Set X} : IsIrreducible S ↔ ∃ x, S = {x} := by\n  rw [IsIrreducible, isPreirreducible_iff_subsingleton,\n    exists_eq_singleton_iff_nonempty_subsingleton]\n\n"}
{"name":"not_preirreducible_nontrivial_t2","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_4\ninst✝³ : TopologicalSpace X\ninst✝² : PreirreducibleSpace X\ninst✝¹ : Nontrivial X\ninst✝ : T2Space X\n⊢ False","decl":"/-- There does not exist a nontrivial preirreducible T₂ space. -/\ntheorem not_preirreducible_nontrivial_t2 (X) [TopologicalSpace X] [PreirreducibleSpace X]\n    [Nontrivial X] [T2Space X] : False :=\n  (PreirreducibleSpace.isPreirreducible_univ (X := X)).subsingleton.not_nontrivial nontrivial_univ\n\n"}
{"name":"t2Space_antitone","module":"Mathlib.Topology.Separation.Hausdorff","initialProofState":"X : Type u_4\n⊢ Antitone (@T2Space X)","decl":"theorem t2Space_antitone {X : Type*} : Antitone (@T2Space X) :=\n  fun inst₁ inst₂ h_top h_t2 ↦ @T2Space.of_injective_continuous _ _ inst₁ inst₂\n    h_t2 _ Function.injective_id <| continuous_id_of_le h_top\n\n"}
