{"name":"CategoryTheory.Limits.PreservesLimitPair.of_iso_prod_comparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.BinaryProducts","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct X Y\ninst✝ : CategoryTheory.Limits.HasBinaryProduct (G.obj X) (G.obj Y)\ni : CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison G X Y)\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.pair X Y) G","decl":"/-- If the product comparison map for `G` at `(X,Y)` is an isomorphism, then `G` preserves the\npair of `(X,Y)`.\n-/\nlemma PreservesLimitPair.of_iso_prod_comparison [i : IsIso (prodComparison G X Y)] :\n    PreservesLimit (pair X Y) G := by\n  apply preservesLimit_of_preserves_limit_cone (prodIsProd X Y)\n  apply (isLimitMapConeBinaryFanEquiv _ _ _).symm _\n  refine @IsLimit.ofPointIso _ _ _ _ _ _ _ (limit.isLimit (pair (G.obj X) (G.obj Y))) ?_\n  apply i\n\n"}
{"name":"CategoryTheory.Limits.PreservesLimitPair.iso_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.BinaryProducts","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\ninst✝² : CategoryTheory.Limits.HasBinaryProduct X Y\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct (G.obj X) (G.obj Y)\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.pair X Y) G\n⊢ Eq (CategoryTheory.Limits.PreservesLimitPair.iso G X Y).hom (CategoryTheory.Limits.prodComparison G X Y)","decl":"@[simp]\ntheorem PreservesLimitPair.iso_hom : (PreservesLimitPair.iso G X Y).hom = prodComparison G X Y :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.PreservesLimitPair.iso_inv_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.BinaryProducts","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\ninst✝² : CategoryTheory.Limits.HasBinaryProduct X Y\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct (G.obj X) (G.obj Y)\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.pair X Y) G\nZ : D\nh : Quiver.Hom (G.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesLimitPair.iso G X Y).inv (CategoryTheory.CategoryStruct.comp (G.map CategoryTheory.Limits.prod.fst) h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst h)","decl":"@[simp, reassoc]\ntheorem PreservesLimitPair.iso_inv_fst :\n    (PreservesLimitPair.iso G X Y).inv ≫ G.map prod.fst = prod.fst := by\n  rw [← Iso.cancel_iso_hom_left (PreservesLimitPair.iso G X Y), ← Category.assoc, Iso.hom_inv_id]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.PreservesLimitPair.iso_inv_fst","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.BinaryProducts","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\ninst✝² : CategoryTheory.Limits.HasBinaryProduct X Y\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct (G.obj X) (G.obj Y)\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.pair X Y) G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesLimitPair.iso G X Y).inv (G.map CategoryTheory.Limits.prod.fst)) CategoryTheory.Limits.prod.fst","decl":"@[simp, reassoc]\ntheorem PreservesLimitPair.iso_inv_fst :\n    (PreservesLimitPair.iso G X Y).inv ≫ G.map prod.fst = prod.fst := by\n  rw [← Iso.cancel_iso_hom_left (PreservesLimitPair.iso G X Y), ← Category.assoc, Iso.hom_inv_id]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.PreservesLimitPair.iso_inv_snd","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.BinaryProducts","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\ninst✝² : CategoryTheory.Limits.HasBinaryProduct X Y\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct (G.obj X) (G.obj Y)\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.pair X Y) G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesLimitPair.iso G X Y).inv (G.map CategoryTheory.Limits.prod.snd)) CategoryTheory.Limits.prod.snd","decl":"@[simp, reassoc]\ntheorem PreservesLimitPair.iso_inv_snd :\n    (PreservesLimitPair.iso G X Y).inv ≫ G.map prod.snd = prod.snd := by\n  rw [← Iso.cancel_iso_hom_left (PreservesLimitPair.iso G X Y), ← Category.assoc, Iso.hom_inv_id]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.PreservesLimitPair.iso_inv_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.BinaryProducts","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\ninst✝² : CategoryTheory.Limits.HasBinaryProduct X Y\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct (G.obj X) (G.obj Y)\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.pair X Y) G\nZ : D\nh : Quiver.Hom (G.obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesLimitPair.iso G X Y).inv (CategoryTheory.CategoryStruct.comp (G.map CategoryTheory.Limits.prod.snd) h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd h)","decl":"@[simp, reassoc]\ntheorem PreservesLimitPair.iso_inv_snd :\n    (PreservesLimitPair.iso G X Y).inv ≫ G.map prod.snd = prod.snd := by\n  rw [← Iso.cancel_iso_hom_left (PreservesLimitPair.iso G X Y), ← Category.assoc, Iso.hom_inv_id]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.instIsIsoProdComparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.BinaryProducts","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct X Y\ninst✝ : CategoryTheory.Limits.HasBinaryProduct (G.obj X) (G.obj Y)\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison G X Y)","decl":"instance : IsIso (prodComparison G X Y) := by\n  rw [← PreservesLimitPair.iso_hom]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.PreservesColimitPair.of_iso_coprod_comparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.BinaryProducts","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct X Y\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct (G.obj X) (G.obj Y)\ni : CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison G X Y)\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.pair X Y) G","decl":"/-- If the coproduct comparison map for `G` at `(X,Y)` is an isomorphism, then `G` preserves the\npair of `(X,Y)`.\n-/\nlemma PreservesColimitPair.of_iso_coprod_comparison [i : IsIso (coprodComparison G X Y)] :\n    PreservesColimit (pair X Y) G := by\n  apply preservesColimit_of_preserves_colimit_cocone (coprodIsCoprod X Y)\n  apply (isColimitMapCoconeBinaryCofanEquiv _ _ _).symm _\n  refine @IsColimit.ofPointIso _ _ _ _ _ _ _ (colimit.isColimit (pair (G.obj X) (G.obj Y))) ?_\n  apply i\n\n"}
{"name":"CategoryTheory.Limits.PreservesColimitPair.iso_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.BinaryProducts","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\ninst✝² : CategoryTheory.Limits.HasBinaryCoproduct X Y\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct (G.obj X) (G.obj Y)\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.pair X Y) G\n⊢ Eq (CategoryTheory.Limits.PreservesColimitPair.iso G X Y).hom (CategoryTheory.Limits.coprodComparison G X Y)","decl":"@[simp]\ntheorem PreservesColimitPair.iso_hom :\n    (PreservesColimitPair.iso G X Y).hom = coprodComparison G X Y := rfl\n\n"}
{"name":"CategoryTheory.Limits.instIsIsoCoprodComparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.BinaryProducts","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct X Y\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct (G.obj X) (G.obj Y)\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison G X Y)","decl":"instance : IsIso (coprodComparison G X Y) := by\n  rw [← PreservesColimitPair.iso_hom]\n  infer_instance\n\n"}
