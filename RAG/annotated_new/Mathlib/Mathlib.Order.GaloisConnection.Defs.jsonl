{"name":"OrderIso.to_galoisConnection","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\noi : OrderIso α β\n⊢ GaloisConnection ⇑oi ⇑oi.symm","decl":"/-- Makes a Galois connection from an order-preserving bijection. -/\ntheorem OrderIso.to_galoisConnection [Preorder α] [Preorder β] (oi : α ≃o β) :\n    GaloisConnection oi oi.symm := fun _ _ => oi.rel_symm_apply.symm\n\n"}
{"name":"GaloisConnection.monotone_intro","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\nhu : Monotone u\nhl : Monotone l\nhul : ∀ (a : α), LE.le a (u (l a))\nhlu : ∀ (a : β), LE.le (l (u a)) a\n⊢ GaloisConnection l u","decl":"theorem monotone_intro (hu : Monotone u) (hl : Monotone l) (hul : ∀ a, a ≤ u (l a))\n    (hlu : ∀ a, l (u a) ≤ a) : GaloisConnection l u := fun _ _ =>\n  ⟨fun h => (hul _).trans (hu h), fun h => (hl h).trans (hlu _)⟩\n\n"}
{"name":"GaloisConnection.dual","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\n⊢ GaloisConnection (Function.comp (⇑OrderDual.toDual) (Function.comp u ⇑OrderDual.ofDual)) (Function.comp (⇑OrderDual.toDual) (Function.comp l ⇑OrderDual.ofDual))","decl":"protected theorem dual {l : α → β} {u : β → α} (gc : GaloisConnection l u) :\n    GaloisConnection (OrderDual.toDual ∘ u ∘ OrderDual.ofDual)\n      (OrderDual.toDual ∘ l ∘ OrderDual.ofDual) :=\n  fun a b => (gc b a).symm\n\n"}
{"name":"GaloisConnection.le_iff_le","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\na : α\nb : β\n⊢ Iff (LE.le (l a) b) (LE.le a (u b))","decl":"theorem le_iff_le {a : α} {b : β} : l a ≤ b ↔ a ≤ u b :=\n  gc _ _\n\n"}
{"name":"GaloisConnection.l_le","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\na : α\nb : β\na✝ : LE.le a (u b)\n⊢ LE.le (l a) b","decl":"theorem l_le {a : α} {b : β} : a ≤ u b → l a ≤ b :=\n  (gc _ _).mpr\n\n"}
{"name":"GaloisConnection.le_u","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\na : α\nb : β\na✝ : LE.le (l a) b\n⊢ LE.le a (u b)","decl":"theorem le_u {a : α} {b : β} : l a ≤ b → a ≤ u b :=\n  (gc _ _).mp\n\n"}
{"name":"GaloisConnection.le_u_l","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\na : α\n⊢ LE.le a (u (l a))","decl":"theorem le_u_l (a) : a ≤ u (l a) :=\n  gc.le_u <| le_rfl\n\n"}
{"name":"GaloisConnection.l_u_le","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\na : β\n⊢ LE.le (l (u a)) a","decl":"theorem l_u_le (a) : l (u a) ≤ a :=\n  gc.l_le <| le_rfl\n\n"}
{"name":"GaloisConnection.monotone_u","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\n⊢ Monotone u","decl":"theorem monotone_u : Monotone u := fun a _ H => gc.le_u ((gc.l_u_le a).trans H)\n\n"}
{"name":"GaloisConnection.monotone_l","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\n⊢ Monotone l","decl":"theorem monotone_l : Monotone l :=\n  gc.dual.monotone_u.dual\n\n"}
{"name":"GaloisConnection.le_u_l_trans","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\nx y z : α\nhxy : LE.le x (u (l y))\nhyz : LE.le y (u (l z))\n⊢ LE.le x (u (l z))","decl":"/-- If `(l, u)` is a Galois connection, then the relation `x ≤ u (l y)` is a transitive relation.\nIf `l` is a closure operator (`Submodule.span`, `Subgroup.closure`, ...) and `u` is the coercion to\n`Set`, this reads as \"if `U` is in the closure of `V` and `V` is in the closure of `W` then `U` is\nin the closure of `W`\". -/\ntheorem le_u_l_trans {x y z : α} (hxy : x ≤ u (l y)) (hyz : y ≤ u (l z)) : x ≤ u (l z) :=\n  hxy.trans (gc.monotone_u <| gc.l_le hyz)\n\n"}
{"name":"GaloisConnection.l_u_le_trans","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\nx y z : β\nhxy : LE.le (l (u x)) y\nhyz : LE.le (l (u y)) z\n⊢ LE.le (l (u x)) z","decl":"theorem l_u_le_trans {x y z : β} (hxy : l (u x) ≤ y) (hyz : l (u y) ≤ z) : l (u x) ≤ z :=\n  (gc.monotone_l <| gc.le_u hxy).trans hyz\n\n"}
{"name":"GaloisConnection.u_l_u_eq_u","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\nb : β\n⊢ Eq (u (l (u b))) (u b)","decl":"theorem u_l_u_eq_u (b : β) : u (l (u b)) = u b :=\n  (gc.monotone_u (gc.l_u_le _)).antisymm (gc.le_u_l _)\n\n"}
{"name":"GaloisConnection.u_l_u_eq_u'","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\n⊢ Eq (Function.comp u (Function.comp l u)) u","decl":"theorem u_l_u_eq_u' : u ∘ l ∘ u = u :=\n  funext gc.u_l_u_eq_u\n\n"}
{"name":"GaloisConnection.u_unique","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\nl' : α → β\nu' : β → α\ngc' : GaloisConnection l' u'\nhl : ∀ (a : α), Eq (l a) (l' a)\nb : β\n⊢ Eq (u b) (u' b)","decl":"theorem u_unique {l' : α → β} {u' : β → α} (gc' : GaloisConnection l' u') (hl : ∀ a, l a = l' a)\n    {b : β} : u b = u' b :=\n  le_antisymm (gc'.le_u <| hl (u b) ▸ gc.l_u_le _) (gc.le_u <| (hl (u' b)).symm ▸ gc'.l_u_le _)\n\n"}
{"name":"GaloisConnection.exists_eq_u","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\na : α\n⊢ Iff (Exists fun b => Eq a (u b)) (Eq a (u (l a)))","decl":"/-- If there exists a `b` such that `a = u a`, then `b = l a` is one such element. -/\ntheorem exists_eq_u (a : α) : (∃ b : β, a = u b) ↔ a = u (l a) :=\n  ⟨fun ⟨_, hS⟩ => hS.symm ▸ (gc.u_l_u_eq_u _).symm, fun HI => ⟨_, HI⟩⟩\n\n"}
{"name":"GaloisConnection.u_eq","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\nz : α\ny : β\n⊢ Iff (Eq (u y) z) (∀ (x : α), Iff (LE.le x z) (LE.le (l x) y))","decl":"theorem u_eq {z : α} {y : β} : u y = z ↔ ∀ x, x ≤ z ↔ l x ≤ y := by\n  constructor\n  · rintro rfl x\n    exact (gc x y).symm\n  · intro H\n    exact ((H <| u y).mpr (gc.l_u_le y)).antisymm ((gc _ _).mp <| (H z).mp le_rfl)\n\n"}
{"name":"GaloisConnection.l_u_l_eq_l","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : PartialOrder β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\na : α\n⊢ Eq (l (u (l a))) (l a)","decl":"theorem l_u_l_eq_l (a : α) : l (u (l a)) = l a := gc.dual.u_l_u_eq_u _\n\n"}
{"name":"GaloisConnection.l_u_l_eq_l'","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : PartialOrder β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\n⊢ Eq (Function.comp l (Function.comp u l)) l","decl":"theorem l_u_l_eq_l' : l ∘ u ∘ l = l := funext gc.l_u_l_eq_l\n\n"}
{"name":"GaloisConnection.l_unique","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : PartialOrder β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\nl' : α → β\nu' : β → α\ngc' : GaloisConnection l' u'\nhu : ∀ (b : β), Eq (u b) (u' b)\na : α\n⊢ Eq (l a) (l' a)","decl":"theorem l_unique {l' : α → β} {u' : β → α} (gc' : GaloisConnection l' u') (hu : ∀ b, u b = u' b)\n    {a : α} : l a = l' a :=\n  gc.dual.u_unique gc'.dual hu\n\n"}
{"name":"GaloisConnection.exists_eq_l","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : PartialOrder β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\nb : β\n⊢ Iff (Exists fun a => Eq b (l a)) (Eq b (l (u b)))","decl":"/-- If there exists an `a` such that `b = l a`, then `a = u b` is one such element. -/\ntheorem exists_eq_l (b : β) : (∃ a : α, b = l a) ↔ b = l (u b) := gc.dual.exists_eq_u _\n\n"}
{"name":"GaloisConnection.l_eq","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : PartialOrder β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\nx : α\nz : β\n⊢ Iff (Eq (l x) z) (∀ (y : β), Iff (LE.le z y) (LE.le x (u y)))","decl":"theorem l_eq {x : α} {z : β} : l x = z ↔ ∀ y, z ≤ y ↔ x ≤ u y := gc.dual.u_eq\n\n"}
{"name":"GaloisConnection.u_eq_top","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝² : PartialOrder α\ninst✝¹ : Preorder β\ninst✝ : OrderTop α\nl : α → β\nu : β → α\ngc : GaloisConnection l u\nx : β\n⊢ Iff (Eq (u x) Top.top) (LE.le (l Top.top) x)","decl":"theorem u_eq_top {l : α → β} {u : β → α} (gc : GaloisConnection l u) {x} : u x = ⊤ ↔ l ⊤ ≤ x :=\n  top_le_iff.symm.trans gc.le_iff_le.symm\n\n"}
{"name":"GaloisConnection.u_top","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : PartialOrder α\ninst✝² : Preorder β\ninst✝¹ : OrderTop α\ninst✝ : OrderTop β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\n⊢ Eq (u Top.top) Top.top","decl":"theorem u_top [OrderTop β] {l : α → β} {u : β → α} (gc : GaloisConnection l u) : u ⊤ = ⊤ :=\n  gc.u_eq_top.2 le_top\n\n"}
{"name":"GaloisConnection.u_l_top","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝² : PartialOrder α\ninst✝¹ : Preorder β\ninst✝ : OrderTop α\nl : α → β\nu : β → α\ngc : GaloisConnection l u\n⊢ Eq (u (l Top.top)) Top.top","decl":"theorem u_l_top {l : α → β} {u : β → α} (gc : GaloisConnection l u) : u (l ⊤) = ⊤ :=\n  gc.u_eq_top.mpr le_rfl\n\n"}
{"name":"GaloisConnection.l_eq_bot","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Preorder α\ninst✝¹ : PartialOrder β\ninst✝ : OrderBot β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\nx : α\n⊢ Iff (Eq (l x) Bot.bot) (LE.le x (u Bot.bot))","decl":"theorem l_eq_bot {l : α → β} {u : β → α} (gc : GaloisConnection l u) {x} : l x = ⊥ ↔ x ≤ u ⊥ :=\n  gc.dual.u_eq_top\n\n"}
{"name":"GaloisConnection.l_bot","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : Preorder α\ninst✝² : PartialOrder β\ninst✝¹ : OrderBot β\ninst✝ : OrderBot α\nl : α → β\nu : β → α\ngc : GaloisConnection l u\n⊢ Eq (l Bot.bot) Bot.bot","decl":"theorem l_bot [OrderBot α] {l : α → β} {u : β → α} (gc : GaloisConnection l u) : l ⊥ = ⊥ :=\n  gc.dual.u_top\n\n"}
{"name":"GaloisConnection.l_u_bot","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Preorder α\ninst✝¹ : PartialOrder β\ninst✝ : OrderBot β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\n⊢ Eq (l (u Bot.bot)) Bot.bot","decl":"theorem l_u_bot {l : α → β} {u : β → α} (gc : GaloisConnection l u) : l (u ⊥) = ⊥ :=\n  gc.l_eq_bot.mpr le_rfl\n\n"}
{"name":"GaloisConnection.lt_iff_lt","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\na : α\nb : β\n⊢ Iff (LT.lt b (l a)) (LT.lt (u b) a)","decl":"theorem lt_iff_lt (gc : GaloisConnection l u) {a : α} {b : β} : b < l a ↔ u b < a :=\n  lt_iff_lt_of_le_iff_le (gc a b)\n\n"}
{"name":"GaloisConnection.id","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\npα : Preorder α\n⊢ GaloisConnection id id","decl":"protected theorem id [pα : Preorder α] : @GaloisConnection α α pα pα id id := fun _ _ =>\n  Iff.intro (fun x => x) fun x => x\n\n"}
{"name":"GaloisConnection.compose","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nl1 : α → β\nu1 : β → α\nl2 : β → γ\nu2 : γ → β\ngc1 : GaloisConnection l1 u1\ngc2 : GaloisConnection l2 u2\n⊢ GaloisConnection (Function.comp l2 l1) (Function.comp u1 u2)","decl":"protected theorem compose [Preorder α] [Preorder β] [Preorder γ] {l1 : α → β} {u1 : β → α}\n    {l2 : β → γ} {u2 : γ → β} (gc1 : GaloisConnection l1 u1) (gc2 : GaloisConnection l2 u2) :\n    GaloisConnection (l2 ∘ l1) (u1 ∘ u2) := fun _ _ ↦ (gc2 _ _).trans (gc1 _ _)\n\n"}
{"name":"GaloisConnection.dfun","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"ι : Type u\nα : ι → Type v\nβ : ι → Type w\ninst✝¹ : (i : ι) → Preorder (α i)\ninst✝ : (i : ι) → Preorder (β i)\nl : (i : ι) → α i → β i\nu : (i : ι) → β i → α i\ngc : ∀ (i : ι), GaloisConnection (l i) (u i)\n⊢ GaloisConnection (fun a i => l i (a i)) fun b i => u i (b i)","decl":"protected theorem dfun {ι : Type u} {α : ι → Type v} {β : ι → Type w} [∀ i, Preorder (α i)]\n    [∀ i, Preorder (β i)] (l : ∀ i, α i → β i) (u : ∀ i, β i → α i)\n    (gc : ∀ i, GaloisConnection (l i) (u i)) :\n    GaloisConnection (fun (a : ∀ i, α i) i => l i (a i)) fun b i => u i (b i) := fun a b =>\n  forall_congr' fun i => gc i (a i) (b i)\n\n"}
{"name":"GaloisConnection.l_comm_of_u_comm","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"X : Type u_2\ninst✝³ : Preorder X\nY : Type u_3\ninst✝² : Preorder Y\nZ : Type u_4\ninst✝¹ : Preorder Z\nW : Type u_5\ninst✝ : PartialOrder W\nlYX : X → Y\nuXY : Y → X\nhXY : GaloisConnection lYX uXY\nlWZ : Z → W\nuZW : W → Z\nhZW : GaloisConnection lWZ uZW\nlWY : Y → W\nuYW : W → Y\nhWY : GaloisConnection lWY uYW\nlZX : X → Z\nuXZ : Z → X\nhXZ : GaloisConnection lZX uXZ\nh : ∀ (w : W), Eq (uXZ (uZW w)) (uXY (uYW w))\nx : X\n⊢ Eq (lWZ (lZX x)) (lWY (lYX x))","decl":"theorem l_comm_of_u_comm {X : Type*} [Preorder X] {Y : Type*} [Preorder Y] {Z : Type*}\n    [Preorder Z] {W : Type*} [PartialOrder W] {lYX : X → Y} {uXY : Y → X}\n    (hXY : GaloisConnection lYX uXY) {lWZ : Z → W} {uZW : W → Z} (hZW : GaloisConnection lWZ uZW)\n    {lWY : Y → W} {uYW : W → Y} (hWY : GaloisConnection lWY uYW) {lZX : X → Z} {uXZ : Z → X}\n    (hXZ : GaloisConnection lZX uXZ) (h : ∀ w, uXZ (uZW w) = uXY (uYW w)) {x : X} :\n    lWZ (lZX x) = lWY (lYX x) :=\n  (hXZ.compose hZW).l_unique (hXY.compose hWY) h\n\n"}
{"name":"GaloisConnection.u_comm_of_l_comm","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"X : Type u_2\ninst✝³ : PartialOrder X\nY : Type u_3\ninst✝² : Preorder Y\nZ : Type u_4\ninst✝¹ : Preorder Z\nW : Type u_5\ninst✝ : Preorder W\nlYX : X → Y\nuXY : Y → X\nhXY : GaloisConnection lYX uXY\nlWZ : Z → W\nuZW : W → Z\nhZW : GaloisConnection lWZ uZW\nlWY : Y → W\nuYW : W → Y\nhWY : GaloisConnection lWY uYW\nlZX : X → Z\nuXZ : Z → X\nhXZ : GaloisConnection lZX uXZ\nh : ∀ (x : X), Eq (lWZ (lZX x)) (lWY (lYX x))\nw : W\n⊢ Eq (uXZ (uZW w)) (uXY (uYW w))","decl":"theorem u_comm_of_l_comm {X : Type*} [PartialOrder X] {Y : Type*} [Preorder Y] {Z : Type*}\n    [Preorder Z] {W : Type*} [Preorder W] {lYX : X → Y} {uXY : Y → X}\n    (hXY : GaloisConnection lYX uXY) {lWZ : Z → W} {uZW : W → Z} (hZW : GaloisConnection lWZ uZW)\n    {lWY : Y → W} {uYW : W → Y} (hWY : GaloisConnection lWY uYW) {lZX : X → Z} {uXZ : Z → X}\n    (hXZ : GaloisConnection lZX uXZ) (h : ∀ x, lWZ (lZX x) = lWY (lYX x)) {w : W} :\n    uXZ (uZW w) = uXY (uYW w) :=\n  (hXZ.compose hZW).u_unique (hXY.compose hWY) h\n\n"}
{"name":"GaloisConnection.l_comm_iff_u_comm","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"X : Type u_2\ninst✝³ : PartialOrder X\nY : Type u_3\ninst✝² : Preorder Y\nZ : Type u_4\ninst✝¹ : Preorder Z\nW : Type u_5\ninst✝ : PartialOrder W\nlYX : X → Y\nuXY : Y → X\nhXY : GaloisConnection lYX uXY\nlWZ : Z → W\nuZW : W → Z\nhZW : GaloisConnection lWZ uZW\nlWY : Y → W\nuYW : W → Y\nhWY : GaloisConnection lWY uYW\nlZX : X → Z\nuXZ : Z → X\nhXZ : GaloisConnection lZX uXZ\n⊢ Iff (∀ (w : W), Eq (uXZ (uZW w)) (uXY (uYW w))) (∀ (x : X), Eq (lWZ (lZX x)) (lWY (lYX x)))","decl":"theorem l_comm_iff_u_comm {X : Type*} [PartialOrder X] {Y : Type*} [Preorder Y] {Z : Type*}\n    [Preorder Z] {W : Type*} [PartialOrder W] {lYX : X → Y} {uXY : Y → X}\n    (hXY : GaloisConnection lYX uXY) {lWZ : Z → W} {uZW : W → Z} (hZW : GaloisConnection lWZ uZW)\n    {lWY : Y → W} {uYW : W → Y} (hWY : GaloisConnection lWY uYW) {lZX : X → Z} {uXZ : Z → X}\n    (hXZ : GaloisConnection lZX uXZ) :\n    (∀ w : W, uXZ (uZW w) = uXY (uYW w)) ↔ ∀ x : X, lWZ (lZX x) = lWY (lYX x) :=\n  ⟨hXY.l_comm_of_u_comm hZW hWY hXZ, hXY.u_comm_of_l_comm hZW hWY hXZ⟩\n\n"}
{"name":"GaloisInsertion.mk.inj","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\nchoice✝ : (x : α) → LE.le (u (l x)) x → β\ngc✝ : GaloisConnection l u\nle_l_u✝ : ∀ (x : β), LE.le x (l (u x))\nchoice_eq✝ : ∀ (a : α) (h : LE.le (u (l a)) a), Eq (choice✝ a h) (l a)\nchoice : (x : α) → LE.le (u (l x)) x → β\ngc : GaloisConnection l u\nle_l_u : ∀ (x : β), LE.le x (l (u x))\nchoice_eq : ∀ (a : α) (h : LE.le (u (l a)) a), Eq (choice a h) (l a)\nx✝ : Eq { choice := choice✝, gc := gc✝, le_l_u := le_l_u✝, choice_eq := choice_eq✝ } { choice := choice, gc := gc, le_l_u := le_l_u, choice_eq := choice_eq }\n⊢ Eq choice✝ choice","decl":"/-- A Galois insertion is a Galois connection where `l ∘ u = id`. It also contains a constructive\nchoice function, to give better definitional equalities when lifting order structures. Dual\nto `GaloisCoinsertion` -/\nstructure GaloisInsertion {α β : Type*} [Preorder α] [Preorder β] (l : α → β) (u : β → α) where\n  /-- A contructive choice function for images of `l`. -/\n  choice : ∀ x : α, u (l x) ≤ x → β\n  /-- The Galois connection associated to a Galois insertion. -/\n  gc : GaloisConnection l u\n  /-- Main property of a Galois insertion. -/\n  le_l_u : ∀ x, x ≤ l (u x)\n  /-- Property of the choice function. -/\n  choice_eq : ∀ a h, choice a h = l a\n\n"}
{"name":"GaloisInsertion.choice_eq","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\nself : GaloisInsertion l u\na : α\nh : LE.le (u (l a)) a\n⊢ Eq (self.choice a h) (l a)","decl":"/-- A Galois insertion is a Galois connection where `l ∘ u = id`. It also contains a constructive\nchoice function, to give better definitional equalities when lifting order structures. Dual\nto `GaloisCoinsertion` -/\nstructure GaloisInsertion {α β : Type*} [Preorder α] [Preorder β] (l : α → β) (u : β → α) where\n  /-- A contructive choice function for images of `l`. -/\n  choice : ∀ x : α, u (l x) ≤ x → β\n  /-- The Galois connection associated to a Galois insertion. -/\n  gc : GaloisConnection l u\n  /-- Main property of a Galois insertion. -/\n  le_l_u : ∀ x, x ≤ l (u x)\n  /-- Property of the choice function. -/\n  choice_eq : ∀ a h, choice a h = l a\n\n"}
{"name":"GaloisInsertion.le_l_u","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\nself : GaloisInsertion l u\nx : β\n⊢ LE.le x (l (u x))","decl":"/-- A Galois insertion is a Galois connection where `l ∘ u = id`. It also contains a constructive\nchoice function, to give better definitional equalities when lifting order structures. Dual\nto `GaloisCoinsertion` -/\nstructure GaloisInsertion {α β : Type*} [Preorder α] [Preorder β] (l : α → β) (u : β → α) where\n  /-- A contructive choice function for images of `l`. -/\n  choice : ∀ x : α, u (l x) ≤ x → β\n  /-- The Galois connection associated to a Galois insertion. -/\n  gc : GaloisConnection l u\n  /-- Main property of a Galois insertion. -/\n  le_l_u : ∀ x, x ≤ l (u x)\n  /-- Property of the choice function. -/\n  choice_eq : ∀ a h, choice a h = l a\n\n"}
{"name":"GaloisInsertion.mk.sizeOf_spec","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\nl : α → β\nu : β → α\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\nchoice : (x : α) → LE.le (u (l x)) x → β\ngc : GaloisConnection l u\nle_l_u : ∀ (x : β), LE.le x (l (u x))\nchoice_eq : ∀ (a : α) (h : LE.le (u (l a)) a), Eq (choice a h) (l a)\n⊢ Eq (SizeOf.sizeOf { choice := choice, gc := gc, le_l_u := le_l_u, choice_eq := choice_eq }) 1","decl":"/-- A Galois insertion is a Galois connection where `l ∘ u = id`. It also contains a constructive\nchoice function, to give better definitional equalities when lifting order structures. Dual\nto `GaloisCoinsertion` -/\nstructure GaloisInsertion {α β : Type*} [Preorder α] [Preorder β] (l : α → β) (u : β → α) where\n  /-- A contructive choice function for images of `l`. -/\n  choice : ∀ x : α, u (l x) ≤ x → β\n  /-- The Galois connection associated to a Galois insertion. -/\n  gc : GaloisConnection l u\n  /-- Main property of a Galois insertion. -/\n  le_l_u : ∀ x, x ≤ l (u x)\n  /-- Property of the choice function. -/\n  choice_eq : ∀ a h, choice a h = l a\n\n"}
{"name":"GaloisInsertion.gc","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\nself : GaloisInsertion l u\n⊢ GaloisConnection l u","decl":"/-- A Galois insertion is a Galois connection where `l ∘ u = id`. It also contains a constructive\nchoice function, to give better definitional equalities when lifting order structures. Dual\nto `GaloisCoinsertion` -/\nstructure GaloisInsertion {α β : Type*} [Preorder α] [Preorder β] (l : α → β) (u : β → α) where\n  /-- A contructive choice function for images of `l`. -/\n  choice : ∀ x : α, u (l x) ≤ x → β\n  /-- The Galois connection associated to a Galois insertion. -/\n  gc : GaloisConnection l u\n  /-- Main property of a Galois insertion. -/\n  le_l_u : ∀ x, x ≤ l (u x)\n  /-- Property of the choice function. -/\n  choice_eq : ∀ a h, choice a h = l a\n\n"}
{"name":"GaloisInsertion.mk.injEq","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\nchoice✝ : (x : α) → LE.le (u (l x)) x → β\ngc✝ : GaloisConnection l u\nle_l_u✝ : ∀ (x : β), LE.le x (l (u x))\nchoice_eq✝ : ∀ (a : α) (h : LE.le (u (l a)) a), Eq (choice✝ a h) (l a)\nchoice : (x : α) → LE.le (u (l x)) x → β\ngc : GaloisConnection l u\nle_l_u : ∀ (x : β), LE.le x (l (u x))\nchoice_eq : ∀ (a : α) (h : LE.le (u (l a)) a), Eq (choice a h) (l a)\n⊢ Eq (Eq { choice := choice✝, gc := gc✝, le_l_u := le_l_u✝, choice_eq := choice_eq✝ } { choice := choice, gc := gc, le_l_u := le_l_u, choice_eq := choice_eq }) (Eq choice✝ choice)","decl":"/-- A Galois insertion is a Galois connection where `l ∘ u = id`. It also contains a constructive\nchoice function, to give better definitional equalities when lifting order structures. Dual\nto `GaloisCoinsertion` -/\nstructure GaloisInsertion {α β : Type*} [Preorder α] [Preorder β] (l : α → β) (u : β → α) where\n  /-- A contructive choice function for images of `l`. -/\n  choice : ∀ x : α, u (l x) ≤ x → β\n  /-- The Galois connection associated to a Galois insertion. -/\n  gc : GaloisConnection l u\n  /-- Main property of a Galois insertion. -/\n  le_l_u : ∀ x, x ≤ l (u x)\n  /-- Property of the choice function. -/\n  choice_eq : ∀ a h, choice a h = l a\n\n"}
{"name":"GaloisInsertion.l_u_eq","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\nl : α → β\nu : β → α\ninst✝¹ : Preorder α\ninst✝ : PartialOrder β\ngi : GaloisInsertion l u\nb : β\n⊢ Eq (l (u b)) b","decl":"theorem l_u_eq [Preorder α] [PartialOrder β] (gi : GaloisInsertion l u) (b : β) : l (u b) = b :=\n  (gi.gc.l_u_le _).antisymm (gi.le_l_u _)\n\n"}
{"name":"GaloisInsertion.leftInverse_l_u","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\nl : α → β\nu : β → α\ninst✝¹ : Preorder α\ninst✝ : PartialOrder β\ngi : GaloisInsertion l u\n⊢ Function.LeftInverse l u","decl":"theorem leftInverse_l_u [Preorder α] [PartialOrder β] (gi : GaloisInsertion l u) :\n    LeftInverse l u :=\n  gi.l_u_eq\n\n"}
{"name":"GaloisInsertion.l_top","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\nl : α → β\nu : β → α\ninst✝³ : Preorder α\ninst✝² : PartialOrder β\ninst✝¹ : OrderTop α\ninst✝ : OrderTop β\ngi : GaloisInsertion l u\n⊢ Eq (l Top.top) Top.top","decl":"theorem l_top [Preorder α] [PartialOrder β] [OrderTop α] [OrderTop β]\n    (gi : GaloisInsertion l u) : l ⊤ = ⊤ :=\n  top_unique <| (gi.le_l_u _).trans <| gi.gc.monotone_l le_top\n\n"}
{"name":"GaloisInsertion.l_surjective","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\nl : α → β\nu : β → α\ninst✝¹ : Preorder α\ninst✝ : PartialOrder β\ngi : GaloisInsertion l u\n⊢ Function.Surjective l","decl":"theorem l_surjective [Preorder α] [PartialOrder β] (gi : GaloisInsertion l u) : Surjective l :=\n  gi.leftInverse_l_u.surjective\n\n"}
{"name":"GaloisInsertion.u_injective","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\nl : α → β\nu : β → α\ninst✝¹ : Preorder α\ninst✝ : PartialOrder β\ngi : GaloisInsertion l u\n⊢ Function.Injective u","decl":"theorem u_injective [Preorder α] [PartialOrder β] (gi : GaloisInsertion l u) : Injective u :=\n  gi.leftInverse_l_u.injective\n\n"}
{"name":"GaloisInsertion.u_le_u_iff","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\nl : α → β\nu : β → α\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ngi : GaloisInsertion l u\na b : β\n⊢ Iff (LE.le (u a) (u b)) (LE.le a b)","decl":"theorem u_le_u_iff [Preorder α] [Preorder β] (gi : GaloisInsertion l u) {a b} : u a ≤ u b ↔ a ≤ b :=\n  ⟨fun h => (gi.le_l_u _).trans (gi.gc.l_le h), fun h => gi.gc.monotone_u h⟩\n\n"}
{"name":"GaloisInsertion.strictMono_u","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\nl : α → β\nu : β → α\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ngi : GaloisInsertion l u\n⊢ StrictMono u","decl":"theorem strictMono_u [Preorder α] [Preorder β] (gi : GaloisInsertion l u) : StrictMono u :=\n  strictMono_of_le_iff_le fun _ _ => gi.u_le_u_iff.symm\n\n"}
{"name":"GaloisCoinsertion.mk.inj","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\nchoice✝ : (x : β) → LE.le x (l (u x)) → α\ngc✝ : GaloisConnection l u\nu_l_le✝ : ∀ (x : α), LE.le (u (l x)) x\nchoice_eq✝ : ∀ (a : β) (h : LE.le a (l (u a))), Eq (choice✝ a h) (u a)\nchoice : (x : β) → LE.le x (l (u x)) → α\ngc : GaloisConnection l u\nu_l_le : ∀ (x : α), LE.le (u (l x)) x\nchoice_eq : ∀ (a : β) (h : LE.le a (l (u a))), Eq (choice a h) (u a)\nx✝ : Eq { choice := choice✝, gc := gc✝, u_l_le := u_l_le✝, choice_eq := choice_eq✝ } { choice := choice, gc := gc, u_l_le := u_l_le, choice_eq := choice_eq }\n⊢ Eq choice✝ choice","decl":"/-- A Galois coinsertion is a Galois connection where `u ∘ l = id`. It also contains a constructive\nchoice function, to give better definitional equalities when lifting order structures. Dual to\n`GaloisInsertion` -/\nstructure GaloisCoinsertion [Preorder α] [Preorder β] (l : α → β) (u : β → α) where\n  /-- A contructive choice function for images of `u`. -/\n  choice : ∀ x : β, x ≤ l (u x) → α\n  /-- The Galois connection associated to a Galois coinsertion. -/\n  gc : GaloisConnection l u\n  /-- Main property of a Galois coinsertion. -/\n  u_l_le : ∀ x, u (l x) ≤ x\n  /-- Property of the choice function. -/\n  choice_eq : ∀ a h, choice a h = u a\n\n"}
{"name":"GaloisCoinsertion.mk.sizeOf_spec","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : Preorder α\ninst✝² : Preorder β\nl : α → β\nu : β → α\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\nchoice : (x : β) → LE.le x (l (u x)) → α\ngc : GaloisConnection l u\nu_l_le : ∀ (x : α), LE.le (u (l x)) x\nchoice_eq : ∀ (a : β) (h : LE.le a (l (u a))), Eq (choice a h) (u a)\n⊢ Eq (SizeOf.sizeOf { choice := choice, gc := gc, u_l_le := u_l_le, choice_eq := choice_eq }) 1","decl":"/-- A Galois coinsertion is a Galois connection where `u ∘ l = id`. It also contains a constructive\nchoice function, to give better definitional equalities when lifting order structures. Dual to\n`GaloisInsertion` -/\nstructure GaloisCoinsertion [Preorder α] [Preorder β] (l : α → β) (u : β → α) where\n  /-- A contructive choice function for images of `u`. -/\n  choice : ∀ x : β, x ≤ l (u x) → α\n  /-- The Galois connection associated to a Galois coinsertion. -/\n  gc : GaloisConnection l u\n  /-- Main property of a Galois coinsertion. -/\n  u_l_le : ∀ x, u (l x) ≤ x\n  /-- Property of the choice function. -/\n  choice_eq : ∀ a h, choice a h = u a\n\n"}
{"name":"GaloisCoinsertion.mk.injEq","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\nchoice✝ : (x : β) → LE.le x (l (u x)) → α\ngc✝ : GaloisConnection l u\nu_l_le✝ : ∀ (x : α), LE.le (u (l x)) x\nchoice_eq✝ : ∀ (a : β) (h : LE.le a (l (u a))), Eq (choice✝ a h) (u a)\nchoice : (x : β) → LE.le x (l (u x)) → α\ngc : GaloisConnection l u\nu_l_le : ∀ (x : α), LE.le (u (l x)) x\nchoice_eq : ∀ (a : β) (h : LE.le a (l (u a))), Eq (choice a h) (u a)\n⊢ Eq (Eq { choice := choice✝, gc := gc✝, u_l_le := u_l_le✝, choice_eq := choice_eq✝ } { choice := choice, gc := gc, u_l_le := u_l_le, choice_eq := choice_eq }) (Eq choice✝ choice)","decl":"/-- A Galois coinsertion is a Galois connection where `u ∘ l = id`. It also contains a constructive\nchoice function, to give better definitional equalities when lifting order structures. Dual to\n`GaloisInsertion` -/\nstructure GaloisCoinsertion [Preorder α] [Preorder β] (l : α → β) (u : β → α) where\n  /-- A contructive choice function for images of `u`. -/\n  choice : ∀ x : β, x ≤ l (u x) → α\n  /-- The Galois connection associated to a Galois coinsertion. -/\n  gc : GaloisConnection l u\n  /-- Main property of a Galois coinsertion. -/\n  u_l_le : ∀ x, u (l x) ≤ x\n  /-- Property of the choice function. -/\n  choice_eq : ∀ a h, choice a h = u a\n\n"}
{"name":"GaloisCoinsertion.choice_eq","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\nself : GaloisCoinsertion l u\na : β\nh : LE.le a (l (u a))\n⊢ Eq (self.choice a h) (u a)","decl":"/-- A Galois coinsertion is a Galois connection where `u ∘ l = id`. It also contains a constructive\nchoice function, to give better definitional equalities when lifting order structures. Dual to\n`GaloisInsertion` -/\nstructure GaloisCoinsertion [Preorder α] [Preorder β] (l : α → β) (u : β → α) where\n  /-- A contructive choice function for images of `u`. -/\n  choice : ∀ x : β, x ≤ l (u x) → α\n  /-- The Galois connection associated to a Galois coinsertion. -/\n  gc : GaloisConnection l u\n  /-- Main property of a Galois coinsertion. -/\n  u_l_le : ∀ x, u (l x) ≤ x\n  /-- Property of the choice function. -/\n  choice_eq : ∀ a h, choice a h = u a\n\n"}
{"name":"GaloisCoinsertion.u_l_le","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\nself : GaloisCoinsertion l u\nx : α\n⊢ LE.le (u (l x)) x","decl":"/-- A Galois coinsertion is a Galois connection where `u ∘ l = id`. It also contains a constructive\nchoice function, to give better definitional equalities when lifting order structures. Dual to\n`GaloisInsertion` -/\nstructure GaloisCoinsertion [Preorder α] [Preorder β] (l : α → β) (u : β → α) where\n  /-- A contructive choice function for images of `u`. -/\n  choice : ∀ x : β, x ≤ l (u x) → α\n  /-- The Galois connection associated to a Galois coinsertion. -/\n  gc : GaloisConnection l u\n  /-- Main property of a Galois coinsertion. -/\n  u_l_le : ∀ x, u (l x) ≤ x\n  /-- Property of the choice function. -/\n  choice_eq : ∀ a h, choice a h = u a\n\n"}
{"name":"GaloisCoinsertion.gc","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\nself : GaloisCoinsertion l u\n⊢ GaloisConnection l u","decl":"/-- A Galois coinsertion is a Galois connection where `u ∘ l = id`. It also contains a constructive\nchoice function, to give better definitional equalities when lifting order structures. Dual to\n`GaloisInsertion` -/\nstructure GaloisCoinsertion [Preorder α] [Preorder β] (l : α → β) (u : β → α) where\n  /-- A contructive choice function for images of `u`. -/\n  choice : ∀ x : β, x ≤ l (u x) → α\n  /-- The Galois connection associated to a Galois coinsertion. -/\n  gc : GaloisConnection l u\n  /-- Main property of a Galois coinsertion. -/\n  u_l_le : ∀ x, u (l x) ≤ x\n  /-- Property of the choice function. -/\n  choice_eq : ∀ a h, choice a h = u a\n\n"}
{"name":"GaloisCoinsertion.u_l_eq","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\nl : α → β\nu : β → α\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\ngi : GaloisCoinsertion l u\na : α\n⊢ Eq (u (l a)) a","decl":"theorem u_l_eq [PartialOrder α] [Preorder β] (gi : GaloisCoinsertion l u) (a : α) : u (l a) = a :=\n  gi.dual.l_u_eq a\n\n"}
{"name":"GaloisCoinsertion.u_l_leftInverse","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\nl : α → β\nu : β → α\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\ngi : GaloisCoinsertion l u\n⊢ Function.LeftInverse u l","decl":"theorem u_l_leftInverse [PartialOrder α] [Preorder β] (gi : GaloisCoinsertion l u) :\n    LeftInverse u l :=\n  gi.u_l_eq\n\n"}
{"name":"GaloisCoinsertion.u_bot","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\nl : α → β\nu : β → α\ninst✝³ : PartialOrder α\ninst✝² : Preorder β\ninst✝¹ : OrderBot α\ninst✝ : OrderBot β\ngi : GaloisCoinsertion l u\n⊢ Eq (u Bot.bot) Bot.bot","decl":"theorem u_bot [PartialOrder α] [Preorder β] [OrderBot α] [OrderBot β] (gi : GaloisCoinsertion l u) :\n    u ⊥ = ⊥ :=\n  gi.dual.l_top\n\n"}
{"name":"GaloisCoinsertion.u_surjective","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\nl : α → β\nu : β → α\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\ngi : GaloisCoinsertion l u\n⊢ Function.Surjective u","decl":"theorem u_surjective [PartialOrder α] [Preorder β] (gi : GaloisCoinsertion l u) : Surjective u :=\n  gi.dual.l_surjective\n\n"}
{"name":"GaloisCoinsertion.l_injective","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\nl : α → β\nu : β → α\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\ngi : GaloisCoinsertion l u\n⊢ Function.Injective l","decl":"theorem l_injective [PartialOrder α] [Preorder β] (gi : GaloisCoinsertion l u) : Injective l :=\n  gi.dual.u_injective\n\n"}
{"name":"GaloisCoinsertion.l_le_l_iff","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\nl : α → β\nu : β → α\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ngi : GaloisCoinsertion l u\na b : α\n⊢ Iff (LE.le (l a) (l b)) (LE.le a b)","decl":"theorem l_le_l_iff [Preorder α] [Preorder β] (gi : GaloisCoinsertion l u) {a b} :\n    l a ≤ l b ↔ a ≤ b :=\n  gi.dual.u_le_u_iff\n\n"}
{"name":"GaloisCoinsertion.strictMono_l","module":"Mathlib.Order.GaloisConnection.Defs","initialProofState":"α : Type u\nβ : Type v\nl : α → β\nu : β → α\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ngi : GaloisCoinsertion l u\n⊢ StrictMono l","decl":"theorem strictMono_l [Preorder α] [Preorder β] (gi : GaloisCoinsertion l u) : StrictMono l :=\n  fun _ _ h => gi.dual.strictMono_u h\n\n"}
