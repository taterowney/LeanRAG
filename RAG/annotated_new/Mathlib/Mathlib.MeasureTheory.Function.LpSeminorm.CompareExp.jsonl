{"name":"MeasureTheory.eLpNorm'_le_eLpNorm'_mul_rpow_measure_univ","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí E\np q : Real\nhp0_lt : LT.lt 0 p\nhpq : LE.le p q\nhf : MeasureTheory.AEStronglyMeasurable f Œº\n‚ä¢ LE.le (MeasureTheory.eLpNorm' f p Œº) (HMul.hMul (MeasureTheory.eLpNorm' f q Œº) (HPow.hPow (Œº Set.univ) (HSub.hSub (HDiv.hDiv 1 p) (HDiv.hDiv 1 q))))","decl":"theorem eLpNorm'_le_eLpNorm'_mul_rpow_measure_univ {p q : ‚Ñù} (hp0_lt : 0 < p) (hpq : p ‚â§ q)\n    (hf : AEStronglyMeasurable f Œº) :\n    eLpNorm' f p Œº ‚â§ eLpNorm' f q Œº * Œº Set.univ ^ (1 / p - 1 / q) := by\n  have hq0_lt : 0 < q := lt_of_lt_of_le hp0_lt hpq\n  by_cases hpq_eq : p = q\n  ¬∑ rw [hpq_eq, sub_self, ENNReal.rpow_zero, mul_one]\n  have hpq : p < q := lt_of_le_of_ne hpq hpq_eq\n  let g := fun _ : Œ± => (1 : ‚Ñù‚â•0‚àû)\n  have h_rw : (‚à´‚Åª a, ‚Äñf a‚Äñ‚Çë ^ p ‚àÇŒº) = ‚à´‚Åª a, (‚Äñf a‚Äñ‚Çë * g a) ^ p ‚àÇŒº :=\n    lintegral_congr fun a => by simp [g]\n  repeat' rw [eLpNorm'_eq_lintegral_enorm]\n  rw [h_rw]\n  let r := p * q / (q - p)\n  have hpqr : 1 / p = 1 / q + 1 / r := by field_simp [r, hp0_lt.ne', hq0_lt.ne']\n  calc\n    (‚à´‚Åª a : Œ±, (‚Üë‚Äñf a‚Äñ‚Çä * g a) ^ p ‚àÇŒº) ^ (1 / p) ‚â§\n        (‚à´‚Åª a : Œ±, ‚Üë‚Äñf a‚Äñ‚Çä ^ q ‚àÇŒº) ^ (1 / q) * (‚à´‚Åª a : Œ±, g a ^ r ‚àÇŒº) ^ (1 / r) :=\n      ENNReal.lintegral_Lp_mul_le_Lq_mul_Lr hp0_lt hpq hpqr Œº hf.enorm aemeasurable_const\n    _ = (‚à´‚Åª a : Œ±, ‚Üë‚Äñf a‚Äñ‚Çä ^ q ‚àÇŒº) ^ (1 / q) * Œº Set.univ ^ (1 / p - 1 / q) := by\n      rw [hpqr]; simp [r, g]\n\n"}
{"name":"MeasureTheory.eLpNorm'_le_eLpNormEssSup_mul_rpow_measure_univ","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí E\nq : Real\nhq_pos : LT.lt 0 q\n‚ä¢ LE.le (MeasureTheory.eLpNorm' f q Œº) (HMul.hMul (MeasureTheory.eLpNormEssSup f Œº) (HPow.hPow (Œº Set.univ) (HDiv.hDiv 1 q)))","decl":"theorem eLpNorm'_le_eLpNormEssSup_mul_rpow_measure_univ {q : ‚Ñù} (hq_pos : 0 < q) :\n    eLpNorm' f q Œº ‚â§ eLpNormEssSup f Œº * Œº Set.univ ^ (1 / q) := by\n  have h_le : (‚à´‚Åª a : Œ±, ‚Äñf a‚Äñ‚Çë ^ q ‚àÇŒº) ‚â§ ‚à´‚Åª _ : Œ±, eLpNormEssSup f Œº ^ q ‚àÇŒº := by\n    refine lintegral_mono_ae ?_\n    have h_nnnorm_le_eLpNorm_ess_sup := coe_nnnorm_ae_le_eLpNormEssSup f Œº\n    exact h_nnnorm_le_eLpNorm_ess_sup.mono fun x hx => by gcongr\n  rw [eLpNorm', ‚Üê ENNReal.rpow_one (eLpNormEssSup f Œº)]\n  nth_rw 2 [‚Üê mul_inv_cancel‚ÇÄ (ne_of_lt hq_pos).symm]\n  rw [ENNReal.rpow_mul, one_div, ‚Üê ENNReal.mul_rpow_of_nonneg _ _ (by simp [hq_pos.le] : 0 ‚â§ q‚Åª¬π)]\n  gcongr\n  rwa [lintegral_const] at h_le\n\n"}
{"name":"MeasureTheory.eLpNorm_le_eLpNorm_mul_rpow_measure_univ","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí E\np q : ENNReal\nhpq : LE.le p q\nhf : MeasureTheory.AEStronglyMeasurable f Œº\n‚ä¢ LE.le (MeasureTheory.eLpNorm f p Œº) (HMul.hMul (MeasureTheory.eLpNorm f q Œº) (HPow.hPow (Œº Set.univ) (HSub.hSub (HDiv.hDiv 1 p.toReal) (HDiv.hDiv 1 q.toReal))))","decl":"theorem eLpNorm_le_eLpNorm_mul_rpow_measure_univ {p q : ‚Ñù‚â•0‚àû} (hpq : p ‚â§ q)\n    (hf : AEStronglyMeasurable f Œº) :\n    eLpNorm f p Œº ‚â§ eLpNorm f q Œº * Œº Set.univ ^ (1 / p.toReal - 1 / q.toReal) := by\n  by_cases hp0 : p = 0\n  ¬∑ simp [hp0, zero_le]\n  rw [‚Üê Ne] at hp0\n  have hp0_lt : 0 < p := lt_of_le_of_ne (zero_le _) hp0.symm\n  have hq0_lt : 0 < q := lt_of_lt_of_le hp0_lt hpq\n  by_cases hq_top : q = ‚àû\n  ¬∑ simp only [hq_top, _root_.div_zero, one_div, ENNReal.top_toReal, sub_zero, eLpNorm_exponent_top,\n      GroupWithZero.inv_zero]\n    by_cases hp_top : p = ‚àû\n    ¬∑ simp only [hp_top, ENNReal.rpow_zero, mul_one, ENNReal.top_toReal, sub_zero,\n        GroupWithZero.inv_zero, eLpNorm_exponent_top]\n      exact le_rfl\n    rw [eLpNorm_eq_eLpNorm' hp0 hp_top]\n    have hp_pos : 0 < p.toReal := ENNReal.toReal_pos hp0_lt.ne' hp_top\n    refine (eLpNorm'_le_eLpNormEssSup_mul_rpow_measure_univ hp_pos).trans (le_of_eq ?_)\n    congr\n    exact one_div _\n  have hp_lt_top : p < ‚àû := hpq.trans_lt (lt_top_iff_ne_top.mpr hq_top)\n  have hp_pos : 0 < p.toReal := ENNReal.toReal_pos hp0_lt.ne' hp_lt_top.ne\n  rw [eLpNorm_eq_eLpNorm' hp0_lt.ne.symm hp_lt_top.ne, eLpNorm_eq_eLpNorm' hq0_lt.ne.symm hq_top]\n  have hpq_real : p.toReal ‚â§ q.toReal := ENNReal.toReal_mono hq_top hpq\n  exact eLpNorm'_le_eLpNorm'_mul_rpow_measure_univ hp_pos hpq_real hf\n\n"}
{"name":"MeasureTheory.eLpNorm'_le_eLpNorm'_of_exponent_le","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù¬π : NormedAddCommGroup E\nf : Œ± ‚Üí E\np q : Real\nhp0_lt : LT.lt 0 p\nhpq : LE.le p q\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\nhf : MeasureTheory.AEStronglyMeasurable f Œº\n‚ä¢ LE.le (MeasureTheory.eLpNorm' f p Œº) (MeasureTheory.eLpNorm' f q Œº)","decl":"theorem eLpNorm'_le_eLpNorm'_of_exponent_le {p q : ‚Ñù} (hp0_lt : 0 < p)\n    (hpq : p ‚â§ q) (Œº : Measure Œ±) [IsProbabilityMeasure Œº] (hf : AEStronglyMeasurable f Œº) :\n    eLpNorm' f p Œº ‚â§ eLpNorm' f q Œº := by\n  have h_le_Œº := eLpNorm'_le_eLpNorm'_mul_rpow_measure_univ hp0_lt hpq hf\n  rwa [measure_univ, ENNReal.one_rpow, mul_one] at h_le_Œº\n\n"}
{"name":"MeasureTheory.eLpNorm'_le_eLpNormEssSup","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù¬π : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí E\nq : Real\nhq_pos : LT.lt 0 q\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\n‚ä¢ LE.le (MeasureTheory.eLpNorm' f q Œº) (MeasureTheory.eLpNormEssSup f Œº)","decl":"theorem eLpNorm'_le_eLpNormEssSup {q : ‚Ñù} (hq_pos : 0 < q) [IsProbabilityMeasure Œº] :\n    eLpNorm' f q Œº ‚â§ eLpNormEssSup f Œº :=\n  (eLpNorm'_le_eLpNormEssSup_mul_rpow_measure_univ hq_pos).trans_eq (by simp [measure_univ])\n\n"}
{"name":"MeasureTheory.eLpNorm_le_eLpNorm_of_exponent_le","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù¬π : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí E\np q : ENNReal\nhpq : LE.le p q\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\nhf : MeasureTheory.AEStronglyMeasurable f Œº\n‚ä¢ LE.le (MeasureTheory.eLpNorm f p Œº) (MeasureTheory.eLpNorm f q Œº)","decl":"theorem eLpNorm_le_eLpNorm_of_exponent_le {p q : ‚Ñù‚â•0‚àû} (hpq : p ‚â§ q) [IsProbabilityMeasure Œº]\n    (hf : AEStronglyMeasurable f Œº) : eLpNorm f p Œº ‚â§ eLpNorm f q Œº :=\n  (eLpNorm_le_eLpNorm_mul_rpow_measure_univ hpq hf).trans (le_of_eq (by simp [measure_univ]))\n\n"}
{"name":"MeasureTheory.eLpNorm'_lt_top_of_eLpNorm'_lt_top_of_exponent_le","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù¬π : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí E\np q : Real\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhf : MeasureTheory.AEStronglyMeasurable f Œº\nhfq_lt_top : LT.lt (MeasureTheory.eLpNorm' f q Œº) Top.top\nhp_nonneg : LE.le 0 p\nhpq : LE.le p q\n‚ä¢ LT.lt (MeasureTheory.eLpNorm' f p Œº) Top.top","decl":"theorem eLpNorm'_lt_top_of_eLpNorm'_lt_top_of_exponent_le {p q : ‚Ñù} [IsFiniteMeasure Œº]\n    (hf : AEStronglyMeasurable f Œº) (hfq_lt_top : eLpNorm' f q Œº < ‚àû) (hp_nonneg : 0 ‚â§ p)\n    (hpq : p ‚â§ q) : eLpNorm' f p Œº < ‚àû := by\n  rcases le_or_lt p 0 with hp_nonpos | hp_pos\n  ¬∑ rw [le_antisymm hp_nonpos hp_nonneg]\n    simp\n  have hq_pos : 0 < q := lt_of_lt_of_le hp_pos hpq\n  calc\n    eLpNorm' f p Œº ‚â§ eLpNorm' f q Œº * Œº Set.univ ^ (1 / p - 1 / q) :=\n      eLpNorm'_le_eLpNorm'_mul_rpow_measure_univ hp_pos hpq hf\n    _ < ‚àû := by\n      rw [ENNReal.mul_lt_top_iff]\n      refine Or.inl ‚ü®hfq_lt_top, ENNReal.rpow_lt_top_of_nonneg ?_ (measure_ne_top Œº Set.univ)‚ü©\n      rwa [le_sub_comm, sub_zero, one_div, one_div, inv_le_inv‚ÇÄ hq_pos hp_pos]\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.mono_exponent","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù¬π : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\np q : ENNReal\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nf : Œ± ‚Üí E\nhfq : MeasureTheory.Mem‚Ñíp f q Œº\nhpq : LE.le p q\n‚ä¢ MeasureTheory.Mem‚Ñíp f p Œº","decl":"theorem Mem‚Ñíp.mono_exponent {p q : ‚Ñù‚â•0‚àû} [IsFiniteMeasure Œº] {f : Œ± ‚Üí E} (hfq : Mem‚Ñíp f q Œº)\n    (hpq : p ‚â§ q) : Mem‚Ñíp f p Œº := by\n  cases' hfq with hfq_m hfq_lt_top\n  by_cases hp0 : p = 0\n  ¬∑ rwa [hp0, mem‚Ñíp_zero_iff_aestronglyMeasurable]\n  rw [‚Üê Ne] at hp0\n  refine ‚ü®hfq_m, ?_‚ü©\n  by_cases hp_top : p = ‚àû\n  ¬∑ have hq_top : q = ‚àû := by rwa [hp_top, top_le_iff] at hpq\n    rw [hp_top]\n    rwa [hq_top] at hfq_lt_top\n  have hp_pos : 0 < p.toReal := ENNReal.toReal_pos hp0 hp_top\n  by_cases hq_top : q = ‚àû\n  ¬∑ rw [eLpNorm_eq_eLpNorm' hp0 hp_top]\n    rw [hq_top, eLpNorm_exponent_top] at hfq_lt_top\n    refine lt_of_le_of_lt (eLpNorm'_le_eLpNormEssSup_mul_rpow_measure_univ hp_pos) ?_\n    refine ENNReal.mul_lt_top hfq_lt_top ?_\n    exact ENNReal.rpow_lt_top_of_nonneg (by simp [hp_pos.le]) (measure_ne_top Œº Set.univ)\n  have hq0 : q ‚â† 0 := by\n    by_contra hq_eq_zero\n    have hp_eq_zero : p = 0 := le_antisymm (by rwa [hq_eq_zero] at hpq) (zero_le _)\n    rw [hp_eq_zero, ENNReal.zero_toReal] at hp_pos\n    exact (lt_irrefl _) hp_pos\n  have hpq_real : p.toReal ‚â§ q.toReal := ENNReal.toReal_mono hq_top hpq\n  rw [eLpNorm_eq_eLpNorm' hp0 hp_top]\n  rw [eLpNorm_eq_eLpNorm' hq0 hq_top] at hfq_lt_top\n  exact eLpNorm'_lt_top_of_eLpNorm'_lt_top_of_exponent_le hfq_m hfq_lt_top hp_pos.le hpq_real\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.mem‚Ñíp_of_exponent_le","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù¬π : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\np q : ENNReal\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nf : Œ± ‚Üí E\nhfq : MeasureTheory.Mem‚Ñíp f q Œº\nhpq : LE.le p q\n‚ä¢ MeasureTheory.Mem‚Ñíp f p Œº","decl":"@[deprecated (since := \"2025-01-07\")] alias Mem‚Ñíp.mem‚Ñíp_of_exponent_le := Mem‚Ñíp.mono_exponent\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.mono_exponent_of_measure_support_ne_top","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\np q : ENNReal\nf : Œ± ‚Üí E\nhfq : MeasureTheory.Mem‚Ñíp f q Œº\ns : Set Œ±\nhf : ‚àÄ (x : Œ±), Not (Membership.mem s x) ‚Üí Eq (f x) 0\nhs : Ne (Œº s) Top.top\nhpq : LE.le p q\n‚ä¢ MeasureTheory.Mem‚Ñíp f p Œº","decl":"/-- If a function is supported on a finite-measure set and belongs to `‚Ñí^p`, then it belongs to\n`‚Ñí^q` for any `q ‚â§ p`. -/\nlemma Mem‚Ñíp.mono_exponent_of_measure_support_ne_top {p q : ‚Ñù‚â•0‚àû} {f : Œ± ‚Üí E} (hfq : Mem‚Ñíp f q Œº)\n    {s : Set Œ±} (hf : ‚àÄ x, x ‚àâ s ‚Üí f x = 0) (hs : Œº s ‚â† ‚àû) (hpq : p ‚â§ q) : Mem‚Ñíp f p Œº := by\n  have : (toMeasurable Œº s).indicator f = f := by\n    apply Set.indicator_eq_self.2\n    apply Function.support_subset_iff'.2 fun x hx ‚Ü¶ hf x ?_\n    contrapose! hx\n    exact subset_toMeasurable Œº s hx\n  rw [‚Üê this, mem‚Ñíp_indicator_iff_restrict (measurableSet_toMeasurable Œº s)] at hfq ‚ä¢\n  have : Fact (Œº (toMeasurable Œº s) < ‚àû) := ‚ü®by simpa [lt_top_iff_ne_top] using hs‚ü©\n  exact hfq.mono_exponent hpq\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.mem‚Ñíp_of_exponent_le_of_measure_support_ne_top","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\np q : ENNReal\nf : Œ± ‚Üí E\nhfq : MeasureTheory.Mem‚Ñíp f q Œº\ns : Set Œ±\nhf : ‚àÄ (x : Œ±), Not (Membership.mem s x) ‚Üí Eq (f x) 0\nhs : Ne (Œº s) Top.top\nhpq : LE.le p q\n‚ä¢ MeasureTheory.Mem‚Ñíp f p Œº","decl":"@[deprecated (since := \"2025-01-07\")]\nalias Mem‚Ñíp.mem‚Ñíp_of_exponent_le_of_measure_support_ne_top :=\n  Mem‚Ñíp.mono_exponent_of_measure_support_ne_top\n\n"}
{"name":"MeasureTheory.eLpNorm_le_eLpNorm_top_mul_eLpNorm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\nm : MeasurableSpace Œ±\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedAddCommGroup G\nŒº : MeasureTheory.Measure Œ±\np : ENNReal\nf : Œ± ‚Üí E\ng : Œ± ‚Üí F\nhg : MeasureTheory.AEStronglyMeasurable g Œº\nb : E ‚Üí F ‚Üí G\nh : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (b (f x) (g x))) (HMul.hMul (NNNorm.nnnorm (f x)) (NNNorm.nnnorm (g x)))) (MeasureTheory.ae Œº)\n‚ä¢ LE.le (MeasureTheory.eLpNorm (fun x => b (f x) (g x)) p Œº) (HMul.hMul (MeasureTheory.eLpNorm f Top.top Œº) (MeasureTheory.eLpNorm g p Œº))","decl":"theorem eLpNorm_le_eLpNorm_top_mul_eLpNorm (p : ‚Ñù‚â•0‚àû) (f : Œ± ‚Üí E) {g : Œ± ‚Üí F}\n    (hg : AEStronglyMeasurable g Œº) (b : E ‚Üí F ‚Üí G)\n    (h : ‚àÄ·µê x ‚àÇŒº, ‚Äñb (f x) (g x)‚Äñ‚Çä ‚â§ ‚Äñf x‚Äñ‚Çä * ‚Äñg x‚Äñ‚Çä) :\n    eLpNorm (fun x => b (f x) (g x)) p Œº ‚â§ eLpNorm f ‚àû Œº * eLpNorm g p Œº := by\n  by_cases hp_top : p = ‚àû\n  ¬∑ simp_rw [hp_top, eLpNorm_exponent_top]\n    refine le_trans (essSup_mono_ae <| h.mono fun a ha => ?_) (ENNReal.essSup_mul_le _ _)\n    simp_rw [Pi.mul_apply, enorm_eq_nnnorm, ‚Üê ENNReal.coe_mul, ENNReal.coe_le_coe]\n    exact ha\n  by_cases hp_zero : p = 0\n  ¬∑ simp only [hp_zero, eLpNorm_exponent_zero, mul_zero, le_zero_iff]\n  simp_rw [eLpNorm_eq_lintegral_rpow_enorm hp_zero hp_top, eLpNorm_exponent_top, eLpNormEssSup]\n  calc\n    (‚à´‚Åª x, (‚Äñb (f x) (g x)‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ^ p.toReal ‚àÇŒº) ^ (1 / p.toReal) ‚â§\n        (‚à´‚Åª x, (‚Äñf x‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ^ p.toReal * (‚Äñg x‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ^ p.toReal ‚àÇŒº) ^ (1 / p.toReal) := by\n      gcongr ?_ ^ _\n      refine lintegral_mono_ae (h.mono fun a ha => ?_)\n      rw [‚Üê ENNReal.mul_rpow_of_nonneg _ _ ENNReal.toReal_nonneg]\n      refine ENNReal.rpow_le_rpow ?_ ENNReal.toReal_nonneg\n      rw [‚Üê ENNReal.coe_mul, ENNReal.coe_le_coe]\n      exact ha\n    _ ‚â§\n        (‚à´‚Åª x, essSup (fun x => (‚Äñf x‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) Œº ^ p.toReal * (‚Äñg x‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ^ p.toReal ‚àÇŒº) ^\n          (1 / p.toReal) := by\n      gcongr ?_ ^ _\n      refine lintegral_mono_ae ?_\n      filter_upwards [@ENNReal.ae_le_essSup _ _ Œº fun x => (‚Äñf x‚Äñ‚Çä : ‚Ñù‚â•0‚àû)] with x hx\n      gcongr\n    _ = essSup (fun x => (‚Äñf x‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) Œº *\n        (‚à´‚Åª x, (‚Äñg x‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ^ p.toReal ‚àÇŒº) ^ (1 / p.toReal) := by\n      rw [lintegral_const_mul'']\n      swap; ¬∑ exact hg.nnnorm.aemeasurable.coe_nnreal_ennreal.pow aemeasurable_const\n      rw [ENNReal.mul_rpow_of_nonneg]\n      swap\n      ¬∑ rw [one_div_nonneg]\n        exact ENNReal.toReal_nonneg\n      rw [‚Üê ENNReal.rpow_mul, one_div, mul_inv_cancel‚ÇÄ, ENNReal.rpow_one]\n      rw [Ne, ENNReal.toReal_eq_zero_iff, not_or]\n      exact ‚ü®hp_zero, hp_top‚ü©\n\n"}
{"name":"MeasureTheory.eLpNorm_le_eLpNorm_mul_eLpNorm_top","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\nm : MeasurableSpace Œ±\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedAddCommGroup G\nŒº : MeasureTheory.Measure Œ±\np : ENNReal\nf : Œ± ‚Üí E\nhf : MeasureTheory.AEStronglyMeasurable f Œº\ng : Œ± ‚Üí F\nb : E ‚Üí F ‚Üí G\nh : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (b (f x) (g x))) (HMul.hMul (NNNorm.nnnorm (f x)) (NNNorm.nnnorm (g x)))) (MeasureTheory.ae Œº)\n‚ä¢ LE.le (MeasureTheory.eLpNorm (fun x => b (f x) (g x)) p Œº) (HMul.hMul (MeasureTheory.eLpNorm f p Œº) (MeasureTheory.eLpNorm g Top.top Œº))","decl":"theorem eLpNorm_le_eLpNorm_mul_eLpNorm_top (p : ‚Ñù‚â•0‚àû) {f : Œ± ‚Üí E} (hf : AEStronglyMeasurable f Œº)\n    (g : Œ± ‚Üí F) (b : E ‚Üí F ‚Üí G) (h : ‚àÄ·µê x ‚àÇŒº, ‚Äñb (f x) (g x)‚Äñ‚Çä ‚â§ ‚Äñf x‚Äñ‚Çä * ‚Äñg x‚Äñ‚Çä) :\n    eLpNorm (fun x => b (f x) (g x)) p Œº ‚â§ eLpNorm f p Œº * eLpNorm g ‚àû Œº :=\n  calc\n    eLpNorm (fun x ‚Ü¶ b (f x) (g x)) p Œº ‚â§ eLpNorm g ‚àû Œº * eLpNorm f p Œº :=\n      eLpNorm_le_eLpNorm_top_mul_eLpNorm p g hf (flip b) <| by simpa only [mul_comm] using h\n    _ = eLpNorm f p Œº * eLpNorm g ‚àû Œº := mul_comm _ _\n\n"}
{"name":"MeasureTheory.eLpNorm'_le_eLpNorm'_mul_eLpNorm'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\nm : MeasurableSpace Œ±\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedAddCommGroup G\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí E\ng : Œ± ‚Üí F\np q r : Real\nhf : MeasureTheory.AEStronglyMeasurable f Œº\nhg : MeasureTheory.AEStronglyMeasurable g Œº\nb : E ‚Üí F ‚Üí G\nh : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (b (f x) (g x))) (HMul.hMul (NNNorm.nnnorm (f x)) (NNNorm.nnnorm (g x)))) (MeasureTheory.ae Œº)\nhp0_lt : LT.lt 0 p\nhpq : LT.lt p q\nhpqr : Eq (HDiv.hDiv 1 p) (HAdd.hAdd (HDiv.hDiv 1 q) (HDiv.hDiv 1 r))\n‚ä¢ LE.le (MeasureTheory.eLpNorm' (fun x => b (f x) (g x)) p Œº) (HMul.hMul (MeasureTheory.eLpNorm' f q Œº) (MeasureTheory.eLpNorm' g r Œº))","decl":"theorem eLpNorm'_le_eLpNorm'_mul_eLpNorm' {p q r : ‚Ñù} (hf : AEStronglyMeasurable f Œº)\n    (hg : AEStronglyMeasurable g Œº) (b : E ‚Üí F ‚Üí G)\n    (h : ‚àÄ·µê x ‚àÇŒº, ‚Äñb (f x) (g x)‚Äñ‚Çä ‚â§ ‚Äñf x‚Äñ‚Çä * ‚Äñg x‚Äñ‚Çä) (hp0_lt : 0 < p) (hpq : p < q)\n    (hpqr : 1 / p = 1 / q + 1 / r) :\n    eLpNorm' (fun x => b (f x) (g x)) p Œº ‚â§ eLpNorm' f q Œº * eLpNorm' g r Œº := by\n  rw [eLpNorm']\n  calc\n    (‚à´‚Åª a : Œ±, ‚Üë‚Äñb (f a) (g a)‚Äñ‚Çä ^ p ‚àÇŒº) ^ (1 / p) ‚â§\n        (‚à´‚Åª a : Œ±, ‚Üë(‚Äñf a‚Äñ‚Çä * ‚Äñg a‚Äñ‚Çä) ^ p ‚àÇŒº) ^ (1 / p) :=\n      (ENNReal.rpow_le_rpow_iff <| one_div_pos.mpr hp0_lt).mpr <|\n        lintegral_mono_ae <|\n          h.mono fun a ha => (ENNReal.rpow_le_rpow_iff hp0_lt).mpr <| ENNReal.coe_le_coe.mpr <| ha\n    _ ‚â§ _ := ?_\n  simp_rw [eLpNorm', ENNReal.coe_mul]\n  exact ENNReal.lintegral_Lp_mul_le_Lq_mul_Lr hp0_lt hpq hpqr Œº hf.enorm hg.enorm\n\n"}
{"name":"MeasureTheory.eLpNorm_le_eLpNorm_mul_eLpNorm_of_nnnorm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\nm : MeasurableSpace Œ±\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedAddCommGroup G\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí E\ng : Œ± ‚Üí F\np q r : ENNReal\nhf : MeasureTheory.AEStronglyMeasurable f Œº\nhg : MeasureTheory.AEStronglyMeasurable g Œº\nb : E ‚Üí F ‚Üí G\nh : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (b (f x) (g x))) (HMul.hMul (NNNorm.nnnorm (f x)) (NNNorm.nnnorm (g x)))) (MeasureTheory.ae Œº)\nhpqr : Eq (HDiv.hDiv 1 p) (HAdd.hAdd (HDiv.hDiv 1 q) (HDiv.hDiv 1 r))\n‚ä¢ LE.le (MeasureTheory.eLpNorm (fun x => b (f x) (g x)) p Œº) (HMul.hMul (MeasureTheory.eLpNorm f q Œº) (MeasureTheory.eLpNorm g r Œº))","decl":"/-- H√∂lder's inequality, as an inequality on the `‚Ñíp` seminorm of an elementwise operation\n`fun x => b (f x) (g x)`. -/\ntheorem eLpNorm_le_eLpNorm_mul_eLpNorm_of_nnnorm {p q r : ‚Ñù‚â•0‚àû}\n    (hf : AEStronglyMeasurable f Œº) (hg : AEStronglyMeasurable g Œº) (b : E ‚Üí F ‚Üí G)\n    (h : ‚àÄ·µê x ‚àÇŒº, ‚Äñb (f x) (g x)‚Äñ‚Çä ‚â§ ‚Äñf x‚Äñ‚Çä * ‚Äñg x‚Äñ‚Çä) (hpqr : 1 / p = 1 / q + 1 / r) :\n    eLpNorm (fun x => b (f x) (g x)) p Œº ‚â§ eLpNorm f q Œº * eLpNorm g r Œº := by\n  by_cases hp_zero : p = 0\n  ¬∑ simp [hp_zero]\n  have hq_ne_zero : q ‚â† 0 := by\n    intro hq_zero\n    simp only [hq_zero, hp_zero, one_div, ENNReal.inv_zero, top_add, ENNReal.inv_eq_top] at hpqr\n  have hr_ne_zero : r ‚â† 0 := by\n    intro hr_zero\n    simp only [hr_zero, hp_zero, one_div, ENNReal.inv_zero, add_top, ENNReal.inv_eq_top] at hpqr\n  by_cases hq_top : q = ‚àû\n  ¬∑ have hpr : p = r := by\n      simpa only [hq_top, one_div, ENNReal.inv_top, zero_add, inv_inj] using hpqr\n    rw [‚Üê hpr, hq_top]\n    exact eLpNorm_le_eLpNorm_top_mul_eLpNorm p f hg b h\n  by_cases hr_top : r = ‚àû\n  ¬∑ have hpq : p = q := by\n      simpa only [hr_top, one_div, ENNReal.inv_top, add_zero, inv_inj] using hpqr\n    rw [‚Üê hpq, hr_top]\n    exact eLpNorm_le_eLpNorm_mul_eLpNorm_top p hf g b h\n  have hpq : p < q := by\n    suffices 1 / q < 1 / p by rwa [one_div, one_div, ENNReal.inv_lt_inv] at this\n    rw [hpqr]\n    refine ENNReal.lt_add_right ?_ ?_\n    ¬∑ simp only [hq_ne_zero, one_div, Ne, ENNReal.inv_eq_top, not_false_iff]\n    ¬∑ simp only [hr_top, one_div, Ne, ENNReal.inv_eq_zero, not_false_iff]\n  rw [eLpNorm_eq_eLpNorm' hp_zero (hpq.trans_le le_top).ne, eLpNorm_eq_eLpNorm' hq_ne_zero hq_top,\n    eLpNorm_eq_eLpNorm' hr_ne_zero hr_top]\n  refine eLpNorm'_le_eLpNorm'_mul_eLpNorm' hf hg _ h ?_ ?_ ?_\n  ¬∑ exact ENNReal.toReal_pos hp_zero (hpq.trans_le le_top).ne\n  ¬∑ exact ENNReal.toReal_strict_mono hq_top hpq\n  rw [‚Üê ENNReal.one_toReal, ‚Üê ENNReal.toReal_div, ‚Üê ENNReal.toReal_div, ‚Üê ENNReal.toReal_div, hpqr,\n    ENNReal.toReal_add]\n  ¬∑ simp only [hq_ne_zero, one_div, Ne, ENNReal.inv_eq_top, not_false_iff]\n  ¬∑ simp only [hr_ne_zero, one_div, Ne, ENNReal.inv_eq_top, not_false_iff]\n\n"}
{"name":"MeasureTheory.eLpNorm_le_eLpNorm_mul_eLpNorm'_of_norm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\nm : MeasurableSpace Œ±\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedAddCommGroup G\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí E\ng : Œ± ‚Üí F\np q r : ENNReal\nhf : MeasureTheory.AEStronglyMeasurable f Œº\nhg : MeasureTheory.AEStronglyMeasurable g Œº\nb : E ‚Üí F ‚Üí G\nh : Filter.Eventually (fun x => LE.le (Norm.norm (b (f x) (g x))) (HMul.hMul (Norm.norm (f x)) (Norm.norm (g x)))) (MeasureTheory.ae Œº)\nhpqr : Eq (HDiv.hDiv 1 p) (HAdd.hAdd (HDiv.hDiv 1 q) (HDiv.hDiv 1 r))\n‚ä¢ LE.le (MeasureTheory.eLpNorm (fun x => b (f x) (g x)) p Œº) (HMul.hMul (MeasureTheory.eLpNorm f q Œº) (MeasureTheory.eLpNorm g r Œº))","decl":"/-- H√∂lder's inequality, as an inequality on the `‚Ñíp` seminorm of an elementwise operation\n`fun x => b (f x) (g x)`. -/\ntheorem eLpNorm_le_eLpNorm_mul_eLpNorm'_of_norm {p q r : ‚Ñù‚â•0‚àû} (hf : AEStronglyMeasurable f Œº)\n    (hg : AEStronglyMeasurable g Œº) (b : E ‚Üí F ‚Üí G)\n    (h : ‚àÄ·µê x ‚àÇŒº, ‚Äñb (f x) (g x)‚Äñ ‚â§ ‚Äñf x‚Äñ * ‚Äñg x‚Äñ) (hpqr : 1 / p = 1 / q + 1 / r) :\n    eLpNorm (fun x => b (f x) (g x)) p Œº ‚â§ eLpNorm f q Œº * eLpNorm g r Œº :=\n  eLpNorm_le_eLpNorm_mul_eLpNorm_of_nnnorm hf hg b h hpqr\n\n"}
{"name":"MeasureTheory.eLpNorm_smul_le_eLpNorm_top_mul_eLpNorm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"ùïú : Type u_1\nŒ± : Type u_2\nE : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : NormedRing ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : MulActionWithZero ùïú E\ninst‚úù : BoundedSMul ùïú E\nf : Œ± ‚Üí E\np : ENNReal\nhf : MeasureTheory.AEStronglyMeasurable f Œº\nœÜ : Œ± ‚Üí ùïú\n‚ä¢ LE.le (MeasureTheory.eLpNorm (HSMul.hSMul œÜ f) p Œº) (HMul.hMul (MeasureTheory.eLpNorm œÜ Top.top Œº) (MeasureTheory.eLpNorm f p Œº))","decl":"theorem eLpNorm_smul_le_eLpNorm_top_mul_eLpNorm (p : ‚Ñù‚â•0‚àû) (hf : AEStronglyMeasurable f Œº)\n    (œÜ : Œ± ‚Üí ùïú) : eLpNorm (œÜ ‚Ä¢ f) p Œº ‚â§ eLpNorm œÜ ‚àû Œº * eLpNorm f p Œº :=\n  (eLpNorm_le_eLpNorm_top_mul_eLpNorm p œÜ hf (¬∑ ‚Ä¢ ¬∑)\n    (Eventually.of_forall fun _ => nnnorm_smul_le _ _) :)\n\n"}
{"name":"MeasureTheory.eLpNorm_smul_le_eLpNorm_mul_eLpNorm_top","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"ùïú : Type u_1\nŒ± : Type u_2\nE : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : NormedRing ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : MulActionWithZero ùïú E\ninst‚úù : BoundedSMul ùïú E\np : ENNReal\nf : Œ± ‚Üí E\nœÜ : Œ± ‚Üí ùïú\nhœÜ : MeasureTheory.AEStronglyMeasurable œÜ Œº\n‚ä¢ LE.le (MeasureTheory.eLpNorm (HSMul.hSMul œÜ f) p Œº) (HMul.hMul (MeasureTheory.eLpNorm œÜ p Œº) (MeasureTheory.eLpNorm f Top.top Œº))","decl":"theorem eLpNorm_smul_le_eLpNorm_mul_eLpNorm_top (p : ‚Ñù‚â•0‚àû) (f : Œ± ‚Üí E) {œÜ : Œ± ‚Üí ùïú}\n    (hœÜ : AEStronglyMeasurable œÜ Œº) : eLpNorm (œÜ ‚Ä¢ f) p Œº ‚â§ eLpNorm œÜ p Œº * eLpNorm f ‚àû Œº :=\n  (eLpNorm_le_eLpNorm_mul_eLpNorm_top p hœÜ f (¬∑ ‚Ä¢ ¬∑)\n    (Eventually.of_forall fun _ => nnnorm_smul_le _ _) :)\n\n"}
{"name":"MeasureTheory.eLpNorm'_smul_le_mul_eLpNorm'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"ùïú : Type u_1\nŒ± : Type u_2\nE : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : NormedRing ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : MulActionWithZero ùïú E\ninst‚úù : BoundedSMul ùïú E\np q r : Real\nf : Œ± ‚Üí E\nhf : MeasureTheory.AEStronglyMeasurable f Œº\nœÜ : Œ± ‚Üí ùïú\nhœÜ : MeasureTheory.AEStronglyMeasurable œÜ Œº\nhp0_lt : LT.lt 0 p\nhpq : LT.lt p q\nhpqr : Eq (HDiv.hDiv 1 p) (HAdd.hAdd (HDiv.hDiv 1 q) (HDiv.hDiv 1 r))\n‚ä¢ LE.le (MeasureTheory.eLpNorm' (HSMul.hSMul œÜ f) p Œº) (HMul.hMul (MeasureTheory.eLpNorm' œÜ q Œº) (MeasureTheory.eLpNorm' f r Œº))","decl":"theorem eLpNorm'_smul_le_mul_eLpNorm' {p q r : ‚Ñù} {f : Œ± ‚Üí E} (hf : AEStronglyMeasurable f Œº)\n    {œÜ : Œ± ‚Üí ùïú} (hœÜ : AEStronglyMeasurable œÜ Œº) (hp0_lt : 0 < p) (hpq : p < q)\n    (hpqr : 1 / p = 1 / q + 1 / r) : eLpNorm' (œÜ ‚Ä¢ f) p Œº ‚â§ eLpNorm' œÜ q Œº * eLpNorm' f r Œº :=\n  eLpNorm'_le_eLpNorm'_mul_eLpNorm' hœÜ hf (¬∑ ‚Ä¢ ¬∑) (Eventually.of_forall fun _ => nnnorm_smul_le _ _)\n    hp0_lt hpq hpqr\n\n"}
{"name":"MeasureTheory.eLpNorm_smul_le_mul_eLpNorm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"ùïú : Type u_1\nŒ± : Type u_2\nE : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : NormedRing ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : MulActionWithZero ùïú E\ninst‚úù : BoundedSMul ùïú E\np q r : ENNReal\nf : Œ± ‚Üí E\nhf : MeasureTheory.AEStronglyMeasurable f Œº\nœÜ : Œ± ‚Üí ùïú\nhœÜ : MeasureTheory.AEStronglyMeasurable œÜ Œº\nhpqr : Eq (HDiv.hDiv 1 p) (HAdd.hAdd (HDiv.hDiv 1 q) (HDiv.hDiv 1 r))\n‚ä¢ LE.le (MeasureTheory.eLpNorm (HSMul.hSMul œÜ f) p Œº) (HMul.hMul (MeasureTheory.eLpNorm œÜ q Œº) (MeasureTheory.eLpNorm f r Œº))","decl":"/-- H√∂lder's inequality, as an inequality on the `‚Ñíp` seminorm of a scalar product `œÜ ‚Ä¢ f`. -/\ntheorem eLpNorm_smul_le_mul_eLpNorm {p q r : ‚Ñù‚â•0‚àû} {f : Œ± ‚Üí E} (hf : AEStronglyMeasurable f Œº)\n    {œÜ : Œ± ‚Üí ùïú} (hœÜ : AEStronglyMeasurable œÜ Œº) (hpqr : 1 / p = 1 / q + 1 / r) :\n    eLpNorm (œÜ ‚Ä¢ f) p Œº ‚â§ eLpNorm œÜ q Œº * eLpNorm f r Œº :=\n  (eLpNorm_le_eLpNorm_mul_eLpNorm_of_nnnorm hœÜ hf (¬∑ ‚Ä¢ ¬∑)\n      (Eventually.of_forall fun _ => nnnorm_smul_le _ _) hpqr :\n    _)\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.smul","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"ùïú : Type u_1\nŒ± : Type u_2\nE : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : NormedRing ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : MulActionWithZero ùïú E\ninst‚úù : BoundedSMul ùïú E\np q r : ENNReal\nf : Œ± ‚Üí E\nœÜ : Œ± ‚Üí ùïú\nhf : MeasureTheory.Mem‚Ñíp f r Œº\nhœÜ : MeasureTheory.Mem‚Ñíp œÜ q Œº\nhpqr : Eq (HDiv.hDiv 1 p) (HAdd.hAdd (HDiv.hDiv 1 q) (HDiv.hDiv 1 r))\n‚ä¢ MeasureTheory.Mem‚Ñíp (HSMul.hSMul œÜ f) p Œº","decl":"theorem Mem‚Ñíp.smul {p q r : ‚Ñù‚â•0‚àû} {f : Œ± ‚Üí E} {œÜ : Œ± ‚Üí ùïú} (hf : Mem‚Ñíp f r Œº) (hœÜ : Mem‚Ñíp œÜ q Œº)\n    (hpqr : 1 / p = 1 / q + 1 / r) : Mem‚Ñíp (œÜ ‚Ä¢ f) p Œº :=\n  ‚ü®hœÜ.1.smul hf.1,\n    (eLpNorm_smul_le_mul_eLpNorm hf.1 hœÜ.1 hpqr).trans_lt\n      (ENNReal.mul_lt_top hœÜ.eLpNorm_lt_top hf.eLpNorm_lt_top)‚ü©\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.smul_of_top_right","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"ùïú : Type u_1\nŒ± : Type u_2\nE : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : NormedRing ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : MulActionWithZero ùïú E\ninst‚úù : BoundedSMul ùïú E\np : ENNReal\nf : Œ± ‚Üí E\nœÜ : Œ± ‚Üí ùïú\nhf : MeasureTheory.Mem‚Ñíp f p Œº\nhœÜ : MeasureTheory.Mem‚Ñíp œÜ Top.top Œº\n‚ä¢ MeasureTheory.Mem‚Ñíp (HSMul.hSMul œÜ f) p Œº","decl":"theorem Mem‚Ñíp.smul_of_top_right {p : ‚Ñù‚â•0‚àû} {f : Œ± ‚Üí E} {œÜ : Œ± ‚Üí ùïú} (hf : Mem‚Ñíp f p Œº)\n    (hœÜ : Mem‚Ñíp œÜ ‚àû Œº) : Mem‚Ñíp (œÜ ‚Ä¢ f) p Œº := by\n  apply hf.smul hœÜ\n  simp only [ENNReal.div_top, zero_add]\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.smul_of_top_left","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"ùïú : Type u_1\nŒ± : Type u_2\nE : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : NormedRing ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : MulActionWithZero ùïú E\ninst‚úù : BoundedSMul ùïú E\np : ENNReal\nf : Œ± ‚Üí E\nœÜ : Œ± ‚Üí ùïú\nhf : MeasureTheory.Mem‚Ñíp f Top.top Œº\nhœÜ : MeasureTheory.Mem‚Ñíp œÜ p Œº\n‚ä¢ MeasureTheory.Mem‚Ñíp (HSMul.hSMul œÜ f) p Œº","decl":"theorem Mem‚Ñíp.smul_of_top_left {p : ‚Ñù‚â•0‚àû} {f : Œ± ‚Üí E} {œÜ : Œ± ‚Üí ùïú} (hf : Mem‚Ñíp f ‚àû Œº)\n    (hœÜ : Mem‚Ñíp œÜ p Œº) : Mem‚Ñíp (œÜ ‚Ä¢ f) p Œº := by\n  apply hf.smul hœÜ\n  simp only [ENNReal.div_top, add_zero]\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.mul","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"Œ± : Type u_1\nx‚úù : MeasurableSpace Œ±\nùïú : Type u_2\ninst‚úù : NormedRing ùïú\nŒº : MeasureTheory.Measure Œ±\np q r : ENNReal\nf œÜ : Œ± ‚Üí ùïú\nhf : MeasureTheory.Mem‚Ñíp f r Œº\nhœÜ : MeasureTheory.Mem‚Ñíp œÜ q Œº\nhpqr : Eq (HDiv.hDiv 1 p) (HAdd.hAdd (HDiv.hDiv 1 q) (HDiv.hDiv 1 r))\n‚ä¢ MeasureTheory.Mem‚Ñíp (HMul.hMul œÜ f) p Œº","decl":"theorem Mem‚Ñíp.mul (hf : Mem‚Ñíp f r Œº) (hœÜ : Mem‚Ñíp œÜ q Œº) (hpqr : 1 / p = 1 / q + 1 / r) :\n    Mem‚Ñíp (œÜ * f) p Œº :=\n  Mem‚Ñíp.smul hf hœÜ hpqr\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.mul'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"Œ± : Type u_1\nx‚úù : MeasurableSpace Œ±\nùïú : Type u_2\ninst‚úù : NormedRing ùïú\nŒº : MeasureTheory.Measure Œ±\np q r : ENNReal\nf œÜ : Œ± ‚Üí ùïú\nhf : MeasureTheory.Mem‚Ñíp f r Œº\nhœÜ : MeasureTheory.Mem‚Ñíp œÜ q Œº\nhpqr : Eq (HDiv.hDiv 1 p) (HAdd.hAdd (HDiv.hDiv 1 q) (HDiv.hDiv 1 r))\n‚ä¢ MeasureTheory.Mem‚Ñíp (fun x => HMul.hMul (œÜ x) (f x)) p Œº","decl":"/-- Variant of `Mem‚Ñíp.mul` where the function is written as `fun x ‚Ü¶ œÜ x * f x`\ninstead of `œÜ * f`. -/\ntheorem Mem‚Ñíp.mul' (hf : Mem‚Ñíp f r Œº) (hœÜ : Mem‚Ñíp œÜ q Œº) (hpqr : 1 / p = 1 / q + 1 / r) :\n    Mem‚Ñíp (fun x ‚Ü¶ œÜ x * f x) p Œº :=\n  Mem‚Ñíp.smul hf hœÜ hpqr\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.mul_of_top_right","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"Œ± : Type u_1\nx‚úù : MeasurableSpace Œ±\nùïú : Type u_2\ninst‚úù : NormedRing ùïú\nŒº : MeasureTheory.Measure Œ±\np : ENNReal\nf œÜ : Œ± ‚Üí ùïú\nhf : MeasureTheory.Mem‚Ñíp f p Œº\nhœÜ : MeasureTheory.Mem‚Ñíp œÜ Top.top Œº\n‚ä¢ MeasureTheory.Mem‚Ñíp (HMul.hMul œÜ f) p Œº","decl":"theorem Mem‚Ñíp.mul_of_top_right (hf : Mem‚Ñíp f p Œº) (hœÜ : Mem‚Ñíp œÜ ‚àû Œº) : Mem‚Ñíp (œÜ * f) p Œº :=\n  Mem‚Ñíp.smul_of_top_right hf hœÜ\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.mul_of_top_right'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"Œ± : Type u_1\nx‚úù : MeasurableSpace Œ±\nùïú : Type u_2\ninst‚úù : NormedRing ùïú\nŒº : MeasureTheory.Measure Œ±\np : ENNReal\nf œÜ : Œ± ‚Üí ùïú\nhf : MeasureTheory.Mem‚Ñíp f p Œº\nhœÜ : MeasureTheory.Mem‚Ñíp œÜ Top.top Œº\n‚ä¢ MeasureTheory.Mem‚Ñíp (fun x => HMul.hMul (œÜ x) (f x)) p Œº","decl":"/-- Variant of `Mem‚Ñíp.mul_of_top_right` where the function is written as `fun x ‚Ü¶ œÜ x * f x`\ninstead of `œÜ * f`. -/\ntheorem Mem‚Ñíp.mul_of_top_right' (hf : Mem‚Ñíp f p Œº) (hœÜ : Mem‚Ñíp œÜ ‚àû Œº) :\n    Mem‚Ñíp (fun x ‚Ü¶ œÜ x * f x) p Œº :=\n  Mem‚Ñíp.smul_of_top_right hf hœÜ\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.mul_of_top_left","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"Œ± : Type u_1\nx‚úù : MeasurableSpace Œ±\nùïú : Type u_2\ninst‚úù : NormedRing ùïú\nŒº : MeasureTheory.Measure Œ±\np : ENNReal\nf œÜ : Œ± ‚Üí ùïú\nhf : MeasureTheory.Mem‚Ñíp f Top.top Œº\nhœÜ : MeasureTheory.Mem‚Ñíp œÜ p Œº\n‚ä¢ MeasureTheory.Mem‚Ñíp (HMul.hMul œÜ f) p Œº","decl":"theorem Mem‚Ñíp.mul_of_top_left (hf : Mem‚Ñíp f ‚àû Œº) (hœÜ : Mem‚Ñíp œÜ p Œº) : Mem‚Ñíp (œÜ * f) p Œº :=\n  Mem‚Ñíp.smul_of_top_left hf hœÜ\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.mul_of_top_left'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"Œ± : Type u_1\nx‚úù : MeasurableSpace Œ±\nùïú : Type u_2\ninst‚úù : NormedRing ùïú\nŒº : MeasureTheory.Measure Œ±\np : ENNReal\nf œÜ : Œ± ‚Üí ùïú\nhf : MeasureTheory.Mem‚Ñíp f Top.top Œº\nhœÜ : MeasureTheory.Mem‚Ñíp œÜ p Œº\n‚ä¢ MeasureTheory.Mem‚Ñíp (fun x => HMul.hMul (œÜ x) (f x)) p Œº","decl":"/-- Variant of `Mem‚Ñíp.mul_of_top_left` where the function is written as `fun x ‚Ü¶ œÜ x * f x`\ninstead of `œÜ * f`. -/\ntheorem Mem‚Ñíp.mul_of_top_left' (hf : Mem‚Ñíp f ‚àû Œº) (hœÜ : Mem‚Ñíp œÜ p Œº) :\n    Mem‚Ñíp (fun x ‚Ü¶ œÜ x * f x) p Œº :=\n  Mem‚Ñíp.smul_of_top_left hf hœÜ\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.prod","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"Œπ : Type u_1\nŒ± : Type u_2\nùïú : Type u_3\nx‚úù : MeasurableSpace Œ±\ninst‚úù : NormedCommRing ùïú\nŒº : MeasureTheory.Measure Œ±\nf : Œπ ‚Üí Œ± ‚Üí ùïú\np : Œπ ‚Üí ENNReal\ns : Finset Œπ\nhf : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí MeasureTheory.Mem‚Ñíp (f i) (p i) Œº\n‚ä¢ MeasureTheory.Mem‚Ñíp (s.prod fun i => f i) (Inv.inv (s.sum fun i => Inv.inv (p i))) Œº","decl":"open Finset in\n/-- See `Mem‚Ñíp.prod'` for the applied version. -/\nprotected lemma Mem‚Ñíp.prod (hf : ‚àÄ i ‚àà s, Mem‚Ñíp (f i) (p i) Œº) :\n    Mem‚Ñíp (‚àè i ‚àà s, f i) (‚àë i ‚àà s, (p i)‚Åª¬π)‚Åª¬π Œº := by\n  induction s using cons_induction with\n  | empty =>\n    by_cases hŒº : Œº = 0 <;>\n      simp [Mem‚Ñíp, eLpNormEssSup_const, hŒº, aestronglyMeasurable_const, Pi.one_def]\n  | cons i s hi ih =>\n    rw [prod_cons]\n    exact (ih <| forall_of_forall_cons hf).mul (hf i <| mem_cons_self ..) (by simp)\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.prod'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"Œπ : Type u_1\nŒ± : Type u_2\nùïú : Type u_3\nx‚úù : MeasurableSpace Œ±\ninst‚úù : NormedCommRing ùïú\nŒº : MeasureTheory.Measure Œ±\nf : Œπ ‚Üí Œ± ‚Üí ùïú\np : Œπ ‚Üí ENNReal\ns : Finset Œπ\nhf : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí MeasureTheory.Mem‚Ñíp (f i) (p i) Œº\n‚ä¢ MeasureTheory.Mem‚Ñíp (fun œâ => s.prod fun i => f i œâ) (Inv.inv (s.sum fun i => Inv.inv (p i))) Œº","decl":"/-- See `Mem‚Ñíp.prod` for the unapplied version. -/\nprotected lemma Mem‚Ñíp.prod' (hf : ‚àÄ i ‚àà s, Mem‚Ñíp (f i) (p i) Œº) :\n    Mem‚Ñíp (fun œâ ‚Ü¶ ‚àè i ‚àà s, f i œâ) (‚àë i ‚àà s, (p i)‚Åª¬π)‚Åª¬π Œº := by\n  simpa [Finset.prod_fn] using Mem‚Ñíp.prod hf\n\n"}
