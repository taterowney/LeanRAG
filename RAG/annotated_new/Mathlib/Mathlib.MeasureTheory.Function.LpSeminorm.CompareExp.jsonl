{"name":"MeasureTheory.eLpNorm'_le_eLpNorm'_mul_rpow_measure_univ","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"α : Type u_1\nE : Type u_2\nm : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\nf : α → E\np q : Real\nhp0_lt : LT.lt 0 p\nhpq : LE.le p q\nhf : MeasureTheory.AEStronglyMeasurable f μ\n⊢ LE.le (MeasureTheory.eLpNorm' f p μ) (HMul.hMul (MeasureTheory.eLpNorm' f q μ) (HPow.hPow (μ Set.univ) (HSub.hSub (HDiv.hDiv 1 p) (HDiv.hDiv 1 q))))","decl":"theorem eLpNorm'_le_eLpNorm'_mul_rpow_measure_univ {p q : ℝ} (hp0_lt : 0 < p) (hpq : p ≤ q)\n    (hf : AEStronglyMeasurable f μ) :\n    eLpNorm' f p μ ≤ eLpNorm' f q μ * μ Set.univ ^ (1 / p - 1 / q) := by\n  have hq0_lt : 0 < q := lt_of_lt_of_le hp0_lt hpq\n  by_cases hpq_eq : p = q\n  · rw [hpq_eq, sub_self, ENNReal.rpow_zero, mul_one]\n  have hpq : p < q := lt_of_le_of_ne hpq hpq_eq\n  let g := fun _ : α => (1 : ℝ≥0∞)\n  have h_rw : (∫⁻ a, ‖f a‖ₑ ^ p ∂μ) = ∫⁻ a, (‖f a‖ₑ * g a) ^ p ∂μ :=\n    lintegral_congr fun a => by simp [g]\n  repeat' rw [eLpNorm'_eq_lintegral_enorm]\n  rw [h_rw]\n  let r := p * q / (q - p)\n  have hpqr : 1 / p = 1 / q + 1 / r := by field_simp [r, hp0_lt.ne', hq0_lt.ne']\n  calc\n    (∫⁻ a : α, (↑‖f a‖₊ * g a) ^ p ∂μ) ^ (1 / p) ≤\n        (∫⁻ a : α, ↑‖f a‖₊ ^ q ∂μ) ^ (1 / q) * (∫⁻ a : α, g a ^ r ∂μ) ^ (1 / r) :=\n      ENNReal.lintegral_Lp_mul_le_Lq_mul_Lr hp0_lt hpq hpqr μ hf.enorm aemeasurable_const\n    _ = (∫⁻ a : α, ↑‖f a‖₊ ^ q ∂μ) ^ (1 / q) * μ Set.univ ^ (1 / p - 1 / q) := by\n      rw [hpqr]; simp [r, g]\n\n"}
{"name":"MeasureTheory.eLpNorm'_le_eLpNormEssSup_mul_rpow_measure_univ","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"α : Type u_1\nE : Type u_2\nm : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\nf : α → E\nq : Real\nhq_pos : LT.lt 0 q\n⊢ LE.le (MeasureTheory.eLpNorm' f q μ) (HMul.hMul (MeasureTheory.eLpNormEssSup f μ) (HPow.hPow (μ Set.univ) (HDiv.hDiv 1 q)))","decl":"theorem eLpNorm'_le_eLpNormEssSup_mul_rpow_measure_univ {q : ℝ} (hq_pos : 0 < q) :\n    eLpNorm' f q μ ≤ eLpNormEssSup f μ * μ Set.univ ^ (1 / q) := by\n  have h_le : (∫⁻ a : α, ‖f a‖ₑ ^ q ∂μ) ≤ ∫⁻ _ : α, eLpNormEssSup f μ ^ q ∂μ := by\n    refine lintegral_mono_ae ?_\n    have h_nnnorm_le_eLpNorm_ess_sup := coe_nnnorm_ae_le_eLpNormEssSup f μ\n    exact h_nnnorm_le_eLpNorm_ess_sup.mono fun x hx => by gcongr\n  rw [eLpNorm', ← ENNReal.rpow_one (eLpNormEssSup f μ)]\n  nth_rw 2 [← mul_inv_cancel₀ (ne_of_lt hq_pos).symm]\n  rw [ENNReal.rpow_mul, one_div, ← ENNReal.mul_rpow_of_nonneg _ _ (by simp [hq_pos.le] : 0 ≤ q⁻¹)]\n  gcongr\n  rwa [lintegral_const] at h_le\n\n"}
{"name":"MeasureTheory.eLpNorm_le_eLpNorm_mul_rpow_measure_univ","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"α : Type u_1\nE : Type u_2\nm : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\nf : α → E\np q : ENNReal\nhpq : LE.le p q\nhf : MeasureTheory.AEStronglyMeasurable f μ\n⊢ LE.le (MeasureTheory.eLpNorm f p μ) (HMul.hMul (MeasureTheory.eLpNorm f q μ) (HPow.hPow (μ Set.univ) (HSub.hSub (HDiv.hDiv 1 p.toReal) (HDiv.hDiv 1 q.toReal))))","decl":"theorem eLpNorm_le_eLpNorm_mul_rpow_measure_univ {p q : ℝ≥0∞} (hpq : p ≤ q)\n    (hf : AEStronglyMeasurable f μ) :\n    eLpNorm f p μ ≤ eLpNorm f q μ * μ Set.univ ^ (1 / p.toReal - 1 / q.toReal) := by\n  by_cases hp0 : p = 0\n  · simp [hp0, zero_le]\n  rw [← Ne] at hp0\n  have hp0_lt : 0 < p := lt_of_le_of_ne (zero_le _) hp0.symm\n  have hq0_lt : 0 < q := lt_of_lt_of_le hp0_lt hpq\n  by_cases hq_top : q = ∞\n  · simp only [hq_top, _root_.div_zero, one_div, ENNReal.top_toReal, sub_zero, eLpNorm_exponent_top,\n      GroupWithZero.inv_zero]\n    by_cases hp_top : p = ∞\n    · simp only [hp_top, ENNReal.rpow_zero, mul_one, ENNReal.top_toReal, sub_zero,\n        GroupWithZero.inv_zero, eLpNorm_exponent_top]\n      exact le_rfl\n    rw [eLpNorm_eq_eLpNorm' hp0 hp_top]\n    have hp_pos : 0 < p.toReal := ENNReal.toReal_pos hp0_lt.ne' hp_top\n    refine (eLpNorm'_le_eLpNormEssSup_mul_rpow_measure_univ hp_pos).trans (le_of_eq ?_)\n    congr\n    exact one_div _\n  have hp_lt_top : p < ∞ := hpq.trans_lt (lt_top_iff_ne_top.mpr hq_top)\n  have hp_pos : 0 < p.toReal := ENNReal.toReal_pos hp0_lt.ne' hp_lt_top.ne\n  rw [eLpNorm_eq_eLpNorm' hp0_lt.ne.symm hp_lt_top.ne, eLpNorm_eq_eLpNorm' hq0_lt.ne.symm hq_top]\n  have hpq_real : p.toReal ≤ q.toReal := ENNReal.toReal_mono hq_top hpq\n  exact eLpNorm'_le_eLpNorm'_mul_rpow_measure_univ hp_pos hpq_real hf\n\n"}
{"name":"MeasureTheory.eLpNorm'_le_eLpNorm'_of_exponent_le","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"α : Type u_1\nE : Type u_2\nm : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\nf : α → E\np q : Real\nhp0_lt : LT.lt 0 p\nhpq : LE.le p q\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhf : MeasureTheory.AEStronglyMeasurable f μ\n⊢ LE.le (MeasureTheory.eLpNorm' f p μ) (MeasureTheory.eLpNorm' f q μ)","decl":"theorem eLpNorm'_le_eLpNorm'_of_exponent_le {p q : ℝ} (hp0_lt : 0 < p)\n    (hpq : p ≤ q) (μ : Measure α) [IsProbabilityMeasure μ] (hf : AEStronglyMeasurable f μ) :\n    eLpNorm' f p μ ≤ eLpNorm' f q μ := by\n  have h_le_μ := eLpNorm'_le_eLpNorm'_mul_rpow_measure_univ hp0_lt hpq hf\n  rwa [measure_univ, ENNReal.one_rpow, mul_one] at h_le_μ\n\n"}
{"name":"MeasureTheory.eLpNorm'_le_eLpNormEssSup","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"α : Type u_1\nE : Type u_2\nm : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\nf : α → E\nq : Real\nhq_pos : LT.lt 0 q\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\n⊢ LE.le (MeasureTheory.eLpNorm' f q μ) (MeasureTheory.eLpNormEssSup f μ)","decl":"theorem eLpNorm'_le_eLpNormEssSup {q : ℝ} (hq_pos : 0 < q) [IsProbabilityMeasure μ] :\n    eLpNorm' f q μ ≤ eLpNormEssSup f μ :=\n  (eLpNorm'_le_eLpNormEssSup_mul_rpow_measure_univ hq_pos).trans_eq (by simp [measure_univ])\n\n"}
{"name":"MeasureTheory.eLpNorm_le_eLpNorm_of_exponent_le","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"α : Type u_1\nE : Type u_2\nm : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\nf : α → E\np q : ENNReal\nhpq : LE.le p q\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhf : MeasureTheory.AEStronglyMeasurable f μ\n⊢ LE.le (MeasureTheory.eLpNorm f p μ) (MeasureTheory.eLpNorm f q μ)","decl":"theorem eLpNorm_le_eLpNorm_of_exponent_le {p q : ℝ≥0∞} (hpq : p ≤ q) [IsProbabilityMeasure μ]\n    (hf : AEStronglyMeasurable f μ) : eLpNorm f p μ ≤ eLpNorm f q μ :=\n  (eLpNorm_le_eLpNorm_mul_rpow_measure_univ hpq hf).trans (le_of_eq (by simp [measure_univ]))\n\n"}
{"name":"MeasureTheory.eLpNorm'_lt_top_of_eLpNorm'_lt_top_of_exponent_le","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"α : Type u_1\nE : Type u_2\nm : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\nf : α → E\np q : Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.AEStronglyMeasurable f μ\nhfq_lt_top : LT.lt (MeasureTheory.eLpNorm' f q μ) Top.top\nhp_nonneg : LE.le 0 p\nhpq : LE.le p q\n⊢ LT.lt (MeasureTheory.eLpNorm' f p μ) Top.top","decl":"theorem eLpNorm'_lt_top_of_eLpNorm'_lt_top_of_exponent_le {p q : ℝ} [IsFiniteMeasure μ]\n    (hf : AEStronglyMeasurable f μ) (hfq_lt_top : eLpNorm' f q μ < ∞) (hp_nonneg : 0 ≤ p)\n    (hpq : p ≤ q) : eLpNorm' f p μ < ∞ := by\n  rcases le_or_lt p 0 with hp_nonpos | hp_pos\n  · rw [le_antisymm hp_nonpos hp_nonneg]\n    simp\n  have hq_pos : 0 < q := lt_of_lt_of_le hp_pos hpq\n  calc\n    eLpNorm' f p μ ≤ eLpNorm' f q μ * μ Set.univ ^ (1 / p - 1 / q) :=\n      eLpNorm'_le_eLpNorm'_mul_rpow_measure_univ hp_pos hpq hf\n    _ < ∞ := by\n      rw [ENNReal.mul_lt_top_iff]\n      refine Or.inl ⟨hfq_lt_top, ENNReal.rpow_lt_top_of_nonneg ?_ (measure_ne_top μ Set.univ)⟩\n      rwa [le_sub_comm, sub_zero, one_div, one_div, inv_le_inv₀ hq_pos hp_pos]\n\n"}
{"name":"MeasureTheory.Memℒp.mono_exponent","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"α : Type u_1\nE : Type u_2\nm : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\np q : ENNReal\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : α → E\nhfq : MeasureTheory.Memℒp f q μ\nhpq : LE.le p q\n⊢ MeasureTheory.Memℒp f p μ","decl":"theorem Memℒp.mono_exponent {p q : ℝ≥0∞} [IsFiniteMeasure μ] {f : α → E} (hfq : Memℒp f q μ)\n    (hpq : p ≤ q) : Memℒp f p μ := by\n  cases' hfq with hfq_m hfq_lt_top\n  by_cases hp0 : p = 0\n  · rwa [hp0, memℒp_zero_iff_aestronglyMeasurable]\n  rw [← Ne] at hp0\n  refine ⟨hfq_m, ?_⟩\n  by_cases hp_top : p = ∞\n  · have hq_top : q = ∞ := by rwa [hp_top, top_le_iff] at hpq\n    rw [hp_top]\n    rwa [hq_top] at hfq_lt_top\n  have hp_pos : 0 < p.toReal := ENNReal.toReal_pos hp0 hp_top\n  by_cases hq_top : q = ∞\n  · rw [eLpNorm_eq_eLpNorm' hp0 hp_top]\n    rw [hq_top, eLpNorm_exponent_top] at hfq_lt_top\n    refine lt_of_le_of_lt (eLpNorm'_le_eLpNormEssSup_mul_rpow_measure_univ hp_pos) ?_\n    refine ENNReal.mul_lt_top hfq_lt_top ?_\n    exact ENNReal.rpow_lt_top_of_nonneg (by simp [hp_pos.le]) (measure_ne_top μ Set.univ)\n  have hq0 : q ≠ 0 := by\n    by_contra hq_eq_zero\n    have hp_eq_zero : p = 0 := le_antisymm (by rwa [hq_eq_zero] at hpq) (zero_le _)\n    rw [hp_eq_zero, ENNReal.zero_toReal] at hp_pos\n    exact (lt_irrefl _) hp_pos\n  have hpq_real : p.toReal ≤ q.toReal := ENNReal.toReal_mono hq_top hpq\n  rw [eLpNorm_eq_eLpNorm' hp0 hp_top]\n  rw [eLpNorm_eq_eLpNorm' hq0 hq_top] at hfq_lt_top\n  exact eLpNorm'_lt_top_of_eLpNorm'_lt_top_of_exponent_le hfq_m hfq_lt_top hp_pos.le hpq_real\n\n"}
{"name":"MeasureTheory.Memℒp.memℒp_of_exponent_le","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"α : Type u_1\nE : Type u_2\nm : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\np q : ENNReal\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : α → E\nhfq : MeasureTheory.Memℒp f q μ\nhpq : LE.le p q\n⊢ MeasureTheory.Memℒp f p μ","decl":"@[deprecated (since := \"2025-01-07\")] alias Memℒp.memℒp_of_exponent_le := Memℒp.mono_exponent\n\n"}
{"name":"MeasureTheory.Memℒp.mono_exponent_of_measure_support_ne_top","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"α : Type u_1\nE : Type u_2\nm : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\np q : ENNReal\nf : α → E\nhfq : MeasureTheory.Memℒp f q μ\ns : Set α\nhf : ∀ (x : α), Not (Membership.mem s x) → Eq (f x) 0\nhs : Ne (μ s) Top.top\nhpq : LE.le p q\n⊢ MeasureTheory.Memℒp f p μ","decl":"/-- If a function is supported on a finite-measure set and belongs to `ℒ^p`, then it belongs to\n`ℒ^q` for any `q ≤ p`. -/\nlemma Memℒp.mono_exponent_of_measure_support_ne_top {p q : ℝ≥0∞} {f : α → E} (hfq : Memℒp f q μ)\n    {s : Set α} (hf : ∀ x, x ∉ s → f x = 0) (hs : μ s ≠ ∞) (hpq : p ≤ q) : Memℒp f p μ := by\n  have : (toMeasurable μ s).indicator f = f := by\n    apply Set.indicator_eq_self.2\n    apply Function.support_subset_iff'.2 fun x hx ↦ hf x ?_\n    contrapose! hx\n    exact subset_toMeasurable μ s hx\n  rw [← this, memℒp_indicator_iff_restrict (measurableSet_toMeasurable μ s)] at hfq ⊢\n  have : Fact (μ (toMeasurable μ s) < ∞) := ⟨by simpa [lt_top_iff_ne_top] using hs⟩\n  exact hfq.mono_exponent hpq\n\n"}
{"name":"MeasureTheory.Memℒp.memℒp_of_exponent_le_of_measure_support_ne_top","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"α : Type u_1\nE : Type u_2\nm : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\np q : ENNReal\nf : α → E\nhfq : MeasureTheory.Memℒp f q μ\ns : Set α\nhf : ∀ (x : α), Not (Membership.mem s x) → Eq (f x) 0\nhs : Ne (μ s) Top.top\nhpq : LE.le p q\n⊢ MeasureTheory.Memℒp f p μ","decl":"@[deprecated (since := \"2025-01-07\")]\nalias Memℒp.memℒp_of_exponent_le_of_measure_support_ne_top :=\n  Memℒp.mono_exponent_of_measure_support_ne_top\n\n"}
{"name":"MeasureTheory.eLpNorm_le_eLpNorm_top_mul_eLpNorm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\nm : MeasurableSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedAddCommGroup G\nμ : MeasureTheory.Measure α\np : ENNReal\nf : α → E\ng : α → F\nhg : MeasureTheory.AEStronglyMeasurable g μ\nb : E → F → G\nh : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (b (f x) (g x))) (HMul.hMul (NNNorm.nnnorm (f x)) (NNNorm.nnnorm (g x)))) (MeasureTheory.ae μ)\n⊢ LE.le (MeasureTheory.eLpNorm (fun x => b (f x) (g x)) p μ) (HMul.hMul (MeasureTheory.eLpNorm f Top.top μ) (MeasureTheory.eLpNorm g p μ))","decl":"theorem eLpNorm_le_eLpNorm_top_mul_eLpNorm (p : ℝ≥0∞) (f : α → E) {g : α → F}\n    (hg : AEStronglyMeasurable g μ) (b : E → F → G)\n    (h : ∀ᵐ x ∂μ, ‖b (f x) (g x)‖₊ ≤ ‖f x‖₊ * ‖g x‖₊) :\n    eLpNorm (fun x => b (f x) (g x)) p μ ≤ eLpNorm f ∞ μ * eLpNorm g p μ := by\n  by_cases hp_top : p = ∞\n  · simp_rw [hp_top, eLpNorm_exponent_top]\n    refine le_trans (essSup_mono_ae <| h.mono fun a ha => ?_) (ENNReal.essSup_mul_le _ _)\n    simp_rw [Pi.mul_apply, enorm_eq_nnnorm, ← ENNReal.coe_mul, ENNReal.coe_le_coe]\n    exact ha\n  by_cases hp_zero : p = 0\n  · simp only [hp_zero, eLpNorm_exponent_zero, mul_zero, le_zero_iff]\n  simp_rw [eLpNorm_eq_lintegral_rpow_enorm hp_zero hp_top, eLpNorm_exponent_top, eLpNormEssSup]\n  calc\n    (∫⁻ x, (‖b (f x) (g x)‖₊ : ℝ≥0∞) ^ p.toReal ∂μ) ^ (1 / p.toReal) ≤\n        (∫⁻ x, (‖f x‖₊ : ℝ≥0∞) ^ p.toReal * (‖g x‖₊ : ℝ≥0∞) ^ p.toReal ∂μ) ^ (1 / p.toReal) := by\n      gcongr ?_ ^ _\n      refine lintegral_mono_ae (h.mono fun a ha => ?_)\n      rw [← ENNReal.mul_rpow_of_nonneg _ _ ENNReal.toReal_nonneg]\n      refine ENNReal.rpow_le_rpow ?_ ENNReal.toReal_nonneg\n      rw [← ENNReal.coe_mul, ENNReal.coe_le_coe]\n      exact ha\n    _ ≤\n        (∫⁻ x, essSup (fun x => (‖f x‖₊ : ℝ≥0∞)) μ ^ p.toReal * (‖g x‖₊ : ℝ≥0∞) ^ p.toReal ∂μ) ^\n          (1 / p.toReal) := by\n      gcongr ?_ ^ _\n      refine lintegral_mono_ae ?_\n      filter_upwards [@ENNReal.ae_le_essSup _ _ μ fun x => (‖f x‖₊ : ℝ≥0∞)] with x hx\n      gcongr\n    _ = essSup (fun x => (‖f x‖₊ : ℝ≥0∞)) μ *\n        (∫⁻ x, (‖g x‖₊ : ℝ≥0∞) ^ p.toReal ∂μ) ^ (1 / p.toReal) := by\n      rw [lintegral_const_mul'']\n      swap; · exact hg.nnnorm.aemeasurable.coe_nnreal_ennreal.pow aemeasurable_const\n      rw [ENNReal.mul_rpow_of_nonneg]\n      swap\n      · rw [one_div_nonneg]\n        exact ENNReal.toReal_nonneg\n      rw [← ENNReal.rpow_mul, one_div, mul_inv_cancel₀, ENNReal.rpow_one]\n      rw [Ne, ENNReal.toReal_eq_zero_iff, not_or]\n      exact ⟨hp_zero, hp_top⟩\n\n"}
{"name":"MeasureTheory.eLpNorm_le_eLpNorm_mul_eLpNorm_top","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\nm : MeasurableSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedAddCommGroup G\nμ : MeasureTheory.Measure α\np : ENNReal\nf : α → E\nhf : MeasureTheory.AEStronglyMeasurable f μ\ng : α → F\nb : E → F → G\nh : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (b (f x) (g x))) (HMul.hMul (NNNorm.nnnorm (f x)) (NNNorm.nnnorm (g x)))) (MeasureTheory.ae μ)\n⊢ LE.le (MeasureTheory.eLpNorm (fun x => b (f x) (g x)) p μ) (HMul.hMul (MeasureTheory.eLpNorm f p μ) (MeasureTheory.eLpNorm g Top.top μ))","decl":"theorem eLpNorm_le_eLpNorm_mul_eLpNorm_top (p : ℝ≥0∞) {f : α → E} (hf : AEStronglyMeasurable f μ)\n    (g : α → F) (b : E → F → G) (h : ∀ᵐ x ∂μ, ‖b (f x) (g x)‖₊ ≤ ‖f x‖₊ * ‖g x‖₊) :\n    eLpNorm (fun x => b (f x) (g x)) p μ ≤ eLpNorm f p μ * eLpNorm g ∞ μ :=\n  calc\n    eLpNorm (fun x ↦ b (f x) (g x)) p μ ≤ eLpNorm g ∞ μ * eLpNorm f p μ :=\n      eLpNorm_le_eLpNorm_top_mul_eLpNorm p g hf (flip b) <| by simpa only [mul_comm] using h\n    _ = eLpNorm f p μ * eLpNorm g ∞ μ := mul_comm _ _\n\n"}
{"name":"MeasureTheory.eLpNorm'_le_eLpNorm'_mul_eLpNorm'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\nm : MeasurableSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedAddCommGroup G\nμ : MeasureTheory.Measure α\nf : α → E\ng : α → F\np q r : Real\nhf : MeasureTheory.AEStronglyMeasurable f μ\nhg : MeasureTheory.AEStronglyMeasurable g μ\nb : E → F → G\nh : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (b (f x) (g x))) (HMul.hMul (NNNorm.nnnorm (f x)) (NNNorm.nnnorm (g x)))) (MeasureTheory.ae μ)\nhp0_lt : LT.lt 0 p\nhpq : LT.lt p q\nhpqr : Eq (HDiv.hDiv 1 p) (HAdd.hAdd (HDiv.hDiv 1 q) (HDiv.hDiv 1 r))\n⊢ LE.le (MeasureTheory.eLpNorm' (fun x => b (f x) (g x)) p μ) (HMul.hMul (MeasureTheory.eLpNorm' f q μ) (MeasureTheory.eLpNorm' g r μ))","decl":"theorem eLpNorm'_le_eLpNorm'_mul_eLpNorm' {p q r : ℝ} (hf : AEStronglyMeasurable f μ)\n    (hg : AEStronglyMeasurable g μ) (b : E → F → G)\n    (h : ∀ᵐ x ∂μ, ‖b (f x) (g x)‖₊ ≤ ‖f x‖₊ * ‖g x‖₊) (hp0_lt : 0 < p) (hpq : p < q)\n    (hpqr : 1 / p = 1 / q + 1 / r) :\n    eLpNorm' (fun x => b (f x) (g x)) p μ ≤ eLpNorm' f q μ * eLpNorm' g r μ := by\n  rw [eLpNorm']\n  calc\n    (∫⁻ a : α, ↑‖b (f a) (g a)‖₊ ^ p ∂μ) ^ (1 / p) ≤\n        (∫⁻ a : α, ↑(‖f a‖₊ * ‖g a‖₊) ^ p ∂μ) ^ (1 / p) :=\n      (ENNReal.rpow_le_rpow_iff <| one_div_pos.mpr hp0_lt).mpr <|\n        lintegral_mono_ae <|\n          h.mono fun a ha => (ENNReal.rpow_le_rpow_iff hp0_lt).mpr <| ENNReal.coe_le_coe.mpr <| ha\n    _ ≤ _ := ?_\n  simp_rw [eLpNorm', ENNReal.coe_mul]\n  exact ENNReal.lintegral_Lp_mul_le_Lq_mul_Lr hp0_lt hpq hpqr μ hf.enorm hg.enorm\n\n"}
{"name":"MeasureTheory.eLpNorm_le_eLpNorm_mul_eLpNorm_of_nnnorm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\nm : MeasurableSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedAddCommGroup G\nμ : MeasureTheory.Measure α\nf : α → E\ng : α → F\np q r : ENNReal\nhf : MeasureTheory.AEStronglyMeasurable f μ\nhg : MeasureTheory.AEStronglyMeasurable g μ\nb : E → F → G\nh : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (b (f x) (g x))) (HMul.hMul (NNNorm.nnnorm (f x)) (NNNorm.nnnorm (g x)))) (MeasureTheory.ae μ)\nhpqr : Eq (HDiv.hDiv 1 p) (HAdd.hAdd (HDiv.hDiv 1 q) (HDiv.hDiv 1 r))\n⊢ LE.le (MeasureTheory.eLpNorm (fun x => b (f x) (g x)) p μ) (HMul.hMul (MeasureTheory.eLpNorm f q μ) (MeasureTheory.eLpNorm g r μ))","decl":"/-- Hölder's inequality, as an inequality on the `ℒp` seminorm of an elementwise operation\n`fun x => b (f x) (g x)`. -/\ntheorem eLpNorm_le_eLpNorm_mul_eLpNorm_of_nnnorm {p q r : ℝ≥0∞}\n    (hf : AEStronglyMeasurable f μ) (hg : AEStronglyMeasurable g μ) (b : E → F → G)\n    (h : ∀ᵐ x ∂μ, ‖b (f x) (g x)‖₊ ≤ ‖f x‖₊ * ‖g x‖₊) (hpqr : 1 / p = 1 / q + 1 / r) :\n    eLpNorm (fun x => b (f x) (g x)) p μ ≤ eLpNorm f q μ * eLpNorm g r μ := by\n  by_cases hp_zero : p = 0\n  · simp [hp_zero]\n  have hq_ne_zero : q ≠ 0 := by\n    intro hq_zero\n    simp only [hq_zero, hp_zero, one_div, ENNReal.inv_zero, top_add, ENNReal.inv_eq_top] at hpqr\n  have hr_ne_zero : r ≠ 0 := by\n    intro hr_zero\n    simp only [hr_zero, hp_zero, one_div, ENNReal.inv_zero, add_top, ENNReal.inv_eq_top] at hpqr\n  by_cases hq_top : q = ∞\n  · have hpr : p = r := by\n      simpa only [hq_top, one_div, ENNReal.inv_top, zero_add, inv_inj] using hpqr\n    rw [← hpr, hq_top]\n    exact eLpNorm_le_eLpNorm_top_mul_eLpNorm p f hg b h\n  by_cases hr_top : r = ∞\n  · have hpq : p = q := by\n      simpa only [hr_top, one_div, ENNReal.inv_top, add_zero, inv_inj] using hpqr\n    rw [← hpq, hr_top]\n    exact eLpNorm_le_eLpNorm_mul_eLpNorm_top p hf g b h\n  have hpq : p < q := by\n    suffices 1 / q < 1 / p by rwa [one_div, one_div, ENNReal.inv_lt_inv] at this\n    rw [hpqr]\n    refine ENNReal.lt_add_right ?_ ?_\n    · simp only [hq_ne_zero, one_div, Ne, ENNReal.inv_eq_top, not_false_iff]\n    · simp only [hr_top, one_div, Ne, ENNReal.inv_eq_zero, not_false_iff]\n  rw [eLpNorm_eq_eLpNorm' hp_zero (hpq.trans_le le_top).ne, eLpNorm_eq_eLpNorm' hq_ne_zero hq_top,\n    eLpNorm_eq_eLpNorm' hr_ne_zero hr_top]\n  refine eLpNorm'_le_eLpNorm'_mul_eLpNorm' hf hg _ h ?_ ?_ ?_\n  · exact ENNReal.toReal_pos hp_zero (hpq.trans_le le_top).ne\n  · exact ENNReal.toReal_strict_mono hq_top hpq\n  rw [← ENNReal.one_toReal, ← ENNReal.toReal_div, ← ENNReal.toReal_div, ← ENNReal.toReal_div, hpqr,\n    ENNReal.toReal_add]\n  · simp only [hq_ne_zero, one_div, Ne, ENNReal.inv_eq_top, not_false_iff]\n  · simp only [hr_ne_zero, one_div, Ne, ENNReal.inv_eq_top, not_false_iff]\n\n"}
{"name":"MeasureTheory.eLpNorm_le_eLpNorm_mul_eLpNorm'_of_norm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\nm : MeasurableSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedAddCommGroup G\nμ : MeasureTheory.Measure α\nf : α → E\ng : α → F\np q r : ENNReal\nhf : MeasureTheory.AEStronglyMeasurable f μ\nhg : MeasureTheory.AEStronglyMeasurable g μ\nb : E → F → G\nh : Filter.Eventually (fun x => LE.le (Norm.norm (b (f x) (g x))) (HMul.hMul (Norm.norm (f x)) (Norm.norm (g x)))) (MeasureTheory.ae μ)\nhpqr : Eq (HDiv.hDiv 1 p) (HAdd.hAdd (HDiv.hDiv 1 q) (HDiv.hDiv 1 r))\n⊢ LE.le (MeasureTheory.eLpNorm (fun x => b (f x) (g x)) p μ) (HMul.hMul (MeasureTheory.eLpNorm f q μ) (MeasureTheory.eLpNorm g r μ))","decl":"/-- Hölder's inequality, as an inequality on the `ℒp` seminorm of an elementwise operation\n`fun x => b (f x) (g x)`. -/\ntheorem eLpNorm_le_eLpNorm_mul_eLpNorm'_of_norm {p q r : ℝ≥0∞} (hf : AEStronglyMeasurable f μ)\n    (hg : AEStronglyMeasurable g μ) (b : E → F → G)\n    (h : ∀ᵐ x ∂μ, ‖b (f x) (g x)‖ ≤ ‖f x‖ * ‖g x‖) (hpqr : 1 / p = 1 / q + 1 / r) :\n    eLpNorm (fun x => b (f x) (g x)) p μ ≤ eLpNorm f q μ * eLpNorm g r μ :=\n  eLpNorm_le_eLpNorm_mul_eLpNorm_of_nnnorm hf hg b h hpqr\n\n"}
{"name":"MeasureTheory.eLpNorm_smul_le_eLpNorm_top_mul_eLpNorm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"𝕜 : Type u_1\nα : Type u_2\nE : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : NormedRing 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : MulActionWithZero 𝕜 E\ninst✝ : BoundedSMul 𝕜 E\nf : α → E\np : ENNReal\nhf : MeasureTheory.AEStronglyMeasurable f μ\nφ : α → 𝕜\n⊢ LE.le (MeasureTheory.eLpNorm (HSMul.hSMul φ f) p μ) (HMul.hMul (MeasureTheory.eLpNorm φ Top.top μ) (MeasureTheory.eLpNorm f p μ))","decl":"theorem eLpNorm_smul_le_eLpNorm_top_mul_eLpNorm (p : ℝ≥0∞) (hf : AEStronglyMeasurable f μ)\n    (φ : α → 𝕜) : eLpNorm (φ • f) p μ ≤ eLpNorm φ ∞ μ * eLpNorm f p μ :=\n  (eLpNorm_le_eLpNorm_top_mul_eLpNorm p φ hf (· • ·)\n    (Eventually.of_forall fun _ => nnnorm_smul_le _ _) :)\n\n"}
{"name":"MeasureTheory.eLpNorm_smul_le_eLpNorm_mul_eLpNorm_top","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"𝕜 : Type u_1\nα : Type u_2\nE : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : NormedRing 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : MulActionWithZero 𝕜 E\ninst✝ : BoundedSMul 𝕜 E\np : ENNReal\nf : α → E\nφ : α → 𝕜\nhφ : MeasureTheory.AEStronglyMeasurable φ μ\n⊢ LE.le (MeasureTheory.eLpNorm (HSMul.hSMul φ f) p μ) (HMul.hMul (MeasureTheory.eLpNorm φ p μ) (MeasureTheory.eLpNorm f Top.top μ))","decl":"theorem eLpNorm_smul_le_eLpNorm_mul_eLpNorm_top (p : ℝ≥0∞) (f : α → E) {φ : α → 𝕜}\n    (hφ : AEStronglyMeasurable φ μ) : eLpNorm (φ • f) p μ ≤ eLpNorm φ p μ * eLpNorm f ∞ μ :=\n  (eLpNorm_le_eLpNorm_mul_eLpNorm_top p hφ f (· • ·)\n    (Eventually.of_forall fun _ => nnnorm_smul_le _ _) :)\n\n"}
{"name":"MeasureTheory.eLpNorm'_smul_le_mul_eLpNorm'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"𝕜 : Type u_1\nα : Type u_2\nE : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : NormedRing 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : MulActionWithZero 𝕜 E\ninst✝ : BoundedSMul 𝕜 E\np q r : Real\nf : α → E\nhf : MeasureTheory.AEStronglyMeasurable f μ\nφ : α → 𝕜\nhφ : MeasureTheory.AEStronglyMeasurable φ μ\nhp0_lt : LT.lt 0 p\nhpq : LT.lt p q\nhpqr : Eq (HDiv.hDiv 1 p) (HAdd.hAdd (HDiv.hDiv 1 q) (HDiv.hDiv 1 r))\n⊢ LE.le (MeasureTheory.eLpNorm' (HSMul.hSMul φ f) p μ) (HMul.hMul (MeasureTheory.eLpNorm' φ q μ) (MeasureTheory.eLpNorm' f r μ))","decl":"theorem eLpNorm'_smul_le_mul_eLpNorm' {p q r : ℝ} {f : α → E} (hf : AEStronglyMeasurable f μ)\n    {φ : α → 𝕜} (hφ : AEStronglyMeasurable φ μ) (hp0_lt : 0 < p) (hpq : p < q)\n    (hpqr : 1 / p = 1 / q + 1 / r) : eLpNorm' (φ • f) p μ ≤ eLpNorm' φ q μ * eLpNorm' f r μ :=\n  eLpNorm'_le_eLpNorm'_mul_eLpNorm' hφ hf (· • ·) (Eventually.of_forall fun _ => nnnorm_smul_le _ _)\n    hp0_lt hpq hpqr\n\n"}
{"name":"MeasureTheory.eLpNorm_smul_le_mul_eLpNorm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"𝕜 : Type u_1\nα : Type u_2\nE : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : NormedRing 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : MulActionWithZero 𝕜 E\ninst✝ : BoundedSMul 𝕜 E\np q r : ENNReal\nf : α → E\nhf : MeasureTheory.AEStronglyMeasurable f μ\nφ : α → 𝕜\nhφ : MeasureTheory.AEStronglyMeasurable φ μ\nhpqr : Eq (HDiv.hDiv 1 p) (HAdd.hAdd (HDiv.hDiv 1 q) (HDiv.hDiv 1 r))\n⊢ LE.le (MeasureTheory.eLpNorm (HSMul.hSMul φ f) p μ) (HMul.hMul (MeasureTheory.eLpNorm φ q μ) (MeasureTheory.eLpNorm f r μ))","decl":"/-- Hölder's inequality, as an inequality on the `ℒp` seminorm of a scalar product `φ • f`. -/\ntheorem eLpNorm_smul_le_mul_eLpNorm {p q r : ℝ≥0∞} {f : α → E} (hf : AEStronglyMeasurable f μ)\n    {φ : α → 𝕜} (hφ : AEStronglyMeasurable φ μ) (hpqr : 1 / p = 1 / q + 1 / r) :\n    eLpNorm (φ • f) p μ ≤ eLpNorm φ q μ * eLpNorm f r μ :=\n  (eLpNorm_le_eLpNorm_mul_eLpNorm_of_nnnorm hφ hf (· • ·)\n      (Eventually.of_forall fun _ => nnnorm_smul_le _ _) hpqr :\n    _)\n\n"}
{"name":"MeasureTheory.Memℒp.smul","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"𝕜 : Type u_1\nα : Type u_2\nE : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : NormedRing 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : MulActionWithZero 𝕜 E\ninst✝ : BoundedSMul 𝕜 E\np q r : ENNReal\nf : α → E\nφ : α → 𝕜\nhf : MeasureTheory.Memℒp f r μ\nhφ : MeasureTheory.Memℒp φ q μ\nhpqr : Eq (HDiv.hDiv 1 p) (HAdd.hAdd (HDiv.hDiv 1 q) (HDiv.hDiv 1 r))\n⊢ MeasureTheory.Memℒp (HSMul.hSMul φ f) p μ","decl":"theorem Memℒp.smul {p q r : ℝ≥0∞} {f : α → E} {φ : α → 𝕜} (hf : Memℒp f r μ) (hφ : Memℒp φ q μ)\n    (hpqr : 1 / p = 1 / q + 1 / r) : Memℒp (φ • f) p μ :=\n  ⟨hφ.1.smul hf.1,\n    (eLpNorm_smul_le_mul_eLpNorm hf.1 hφ.1 hpqr).trans_lt\n      (ENNReal.mul_lt_top hφ.eLpNorm_lt_top hf.eLpNorm_lt_top)⟩\n\n"}
{"name":"MeasureTheory.Memℒp.smul_of_top_right","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"𝕜 : Type u_1\nα : Type u_2\nE : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : NormedRing 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : MulActionWithZero 𝕜 E\ninst✝ : BoundedSMul 𝕜 E\np : ENNReal\nf : α → E\nφ : α → 𝕜\nhf : MeasureTheory.Memℒp f p μ\nhφ : MeasureTheory.Memℒp φ Top.top μ\n⊢ MeasureTheory.Memℒp (HSMul.hSMul φ f) p μ","decl":"theorem Memℒp.smul_of_top_right {p : ℝ≥0∞} {f : α → E} {φ : α → 𝕜} (hf : Memℒp f p μ)\n    (hφ : Memℒp φ ∞ μ) : Memℒp (φ • f) p μ := by\n  apply hf.smul hφ\n  simp only [ENNReal.div_top, zero_add]\n\n"}
{"name":"MeasureTheory.Memℒp.smul_of_top_left","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"𝕜 : Type u_1\nα : Type u_2\nE : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : NormedRing 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : MulActionWithZero 𝕜 E\ninst✝ : BoundedSMul 𝕜 E\np : ENNReal\nf : α → E\nφ : α → 𝕜\nhf : MeasureTheory.Memℒp f Top.top μ\nhφ : MeasureTheory.Memℒp φ p μ\n⊢ MeasureTheory.Memℒp (HSMul.hSMul φ f) p μ","decl":"theorem Memℒp.smul_of_top_left {p : ℝ≥0∞} {f : α → E} {φ : α → 𝕜} (hf : Memℒp f ∞ μ)\n    (hφ : Memℒp φ p μ) : Memℒp (φ • f) p μ := by\n  apply hf.smul hφ\n  simp only [ENNReal.div_top, add_zero]\n\n"}
{"name":"MeasureTheory.Memℒp.mul","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"α : Type u_1\nx✝ : MeasurableSpace α\n𝕜 : Type u_2\ninst✝ : NormedRing 𝕜\nμ : MeasureTheory.Measure α\np q r : ENNReal\nf φ : α → 𝕜\nhf : MeasureTheory.Memℒp f r μ\nhφ : MeasureTheory.Memℒp φ q μ\nhpqr : Eq (HDiv.hDiv 1 p) (HAdd.hAdd (HDiv.hDiv 1 q) (HDiv.hDiv 1 r))\n⊢ MeasureTheory.Memℒp (HMul.hMul φ f) p μ","decl":"theorem Memℒp.mul (hf : Memℒp f r μ) (hφ : Memℒp φ q μ) (hpqr : 1 / p = 1 / q + 1 / r) :\n    Memℒp (φ * f) p μ :=\n  Memℒp.smul hf hφ hpqr\n\n"}
{"name":"MeasureTheory.Memℒp.mul'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"α : Type u_1\nx✝ : MeasurableSpace α\n𝕜 : Type u_2\ninst✝ : NormedRing 𝕜\nμ : MeasureTheory.Measure α\np q r : ENNReal\nf φ : α → 𝕜\nhf : MeasureTheory.Memℒp f r μ\nhφ : MeasureTheory.Memℒp φ q μ\nhpqr : Eq (HDiv.hDiv 1 p) (HAdd.hAdd (HDiv.hDiv 1 q) (HDiv.hDiv 1 r))\n⊢ MeasureTheory.Memℒp (fun x => HMul.hMul (φ x) (f x)) p μ","decl":"/-- Variant of `Memℒp.mul` where the function is written as `fun x ↦ φ x * f x`\ninstead of `φ * f`. -/\ntheorem Memℒp.mul' (hf : Memℒp f r μ) (hφ : Memℒp φ q μ) (hpqr : 1 / p = 1 / q + 1 / r) :\n    Memℒp (fun x ↦ φ x * f x) p μ :=\n  Memℒp.smul hf hφ hpqr\n\n"}
{"name":"MeasureTheory.Memℒp.mul_of_top_right","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"α : Type u_1\nx✝ : MeasurableSpace α\n𝕜 : Type u_2\ninst✝ : NormedRing 𝕜\nμ : MeasureTheory.Measure α\np : ENNReal\nf φ : α → 𝕜\nhf : MeasureTheory.Memℒp f p μ\nhφ : MeasureTheory.Memℒp φ Top.top μ\n⊢ MeasureTheory.Memℒp (HMul.hMul φ f) p μ","decl":"theorem Memℒp.mul_of_top_right (hf : Memℒp f p μ) (hφ : Memℒp φ ∞ μ) : Memℒp (φ * f) p μ :=\n  Memℒp.smul_of_top_right hf hφ\n\n"}
{"name":"MeasureTheory.Memℒp.mul_of_top_right'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"α : Type u_1\nx✝ : MeasurableSpace α\n𝕜 : Type u_2\ninst✝ : NormedRing 𝕜\nμ : MeasureTheory.Measure α\np : ENNReal\nf φ : α → 𝕜\nhf : MeasureTheory.Memℒp f p μ\nhφ : MeasureTheory.Memℒp φ Top.top μ\n⊢ MeasureTheory.Memℒp (fun x => HMul.hMul (φ x) (f x)) p μ","decl":"/-- Variant of `Memℒp.mul_of_top_right` where the function is written as `fun x ↦ φ x * f x`\ninstead of `φ * f`. -/\ntheorem Memℒp.mul_of_top_right' (hf : Memℒp f p μ) (hφ : Memℒp φ ∞ μ) :\n    Memℒp (fun x ↦ φ x * f x) p μ :=\n  Memℒp.smul_of_top_right hf hφ\n\n"}
{"name":"MeasureTheory.Memℒp.mul_of_top_left","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"α : Type u_1\nx✝ : MeasurableSpace α\n𝕜 : Type u_2\ninst✝ : NormedRing 𝕜\nμ : MeasureTheory.Measure α\np : ENNReal\nf φ : α → 𝕜\nhf : MeasureTheory.Memℒp f Top.top μ\nhφ : MeasureTheory.Memℒp φ p μ\n⊢ MeasureTheory.Memℒp (HMul.hMul φ f) p μ","decl":"theorem Memℒp.mul_of_top_left (hf : Memℒp f ∞ μ) (hφ : Memℒp φ p μ) : Memℒp (φ * f) p μ :=\n  Memℒp.smul_of_top_left hf hφ\n\n"}
{"name":"MeasureTheory.Memℒp.mul_of_top_left'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"α : Type u_1\nx✝ : MeasurableSpace α\n𝕜 : Type u_2\ninst✝ : NormedRing 𝕜\nμ : MeasureTheory.Measure α\np : ENNReal\nf φ : α → 𝕜\nhf : MeasureTheory.Memℒp f Top.top μ\nhφ : MeasureTheory.Memℒp φ p μ\n⊢ MeasureTheory.Memℒp (fun x => HMul.hMul (φ x) (f x)) p μ","decl":"/-- Variant of `Memℒp.mul_of_top_left` where the function is written as `fun x ↦ φ x * f x`\ninstead of `φ * f`. -/\ntheorem Memℒp.mul_of_top_left' (hf : Memℒp f ∞ μ) (hφ : Memℒp φ p μ) :\n    Memℒp (fun x ↦ φ x * f x) p μ :=\n  Memℒp.smul_of_top_left hf hφ\n\n"}
{"name":"MeasureTheory.Memℒp.prod","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"ι : Type u_1\nα : Type u_2\n𝕜 : Type u_3\nx✝ : MeasurableSpace α\ninst✝ : NormedCommRing 𝕜\nμ : MeasureTheory.Measure α\nf : ι → α → 𝕜\np : ι → ENNReal\ns : Finset ι\nhf : ∀ (i : ι), Membership.mem s i → MeasureTheory.Memℒp (f i) (p i) μ\n⊢ MeasureTheory.Memℒp (s.prod fun i => f i) (Inv.inv (s.sum fun i => Inv.inv (p i))) μ","decl":"open Finset in\n/-- See `Memℒp.prod'` for the applied version. -/\nprotected lemma Memℒp.prod (hf : ∀ i ∈ s, Memℒp (f i) (p i) μ) :\n    Memℒp (∏ i ∈ s, f i) (∑ i ∈ s, (p i)⁻¹)⁻¹ μ := by\n  induction s using cons_induction with\n  | empty =>\n    by_cases hμ : μ = 0 <;>\n      simp [Memℒp, eLpNormEssSup_const, hμ, aestronglyMeasurable_const, Pi.one_def]\n  | cons i s hi ih =>\n    rw [prod_cons]\n    exact (ih <| forall_of_forall_cons hf).mul (hf i <| mem_cons_self ..) (by simp)\n\n"}
{"name":"MeasureTheory.Memℒp.prod'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp","initialProofState":"ι : Type u_1\nα : Type u_2\n𝕜 : Type u_3\nx✝ : MeasurableSpace α\ninst✝ : NormedCommRing 𝕜\nμ : MeasureTheory.Measure α\nf : ι → α → 𝕜\np : ι → ENNReal\ns : Finset ι\nhf : ∀ (i : ι), Membership.mem s i → MeasureTheory.Memℒp (f i) (p i) μ\n⊢ MeasureTheory.Memℒp (fun ω => s.prod fun i => f i ω) (Inv.inv (s.sum fun i => Inv.inv (p i))) μ","decl":"/-- See `Memℒp.prod` for the unapplied version. -/\nprotected lemma Memℒp.prod' (hf : ∀ i ∈ s, Memℒp (f i) (p i) μ) :\n    Memℒp (fun ω ↦ ∏ i ∈ s, f i ω) (∑ i ∈ s, (p i)⁻¹)⁻¹ μ := by\n  simpa [Finset.prod_fn] using Memℒp.prod hf\n\n"}
