{"name":"CategoryTheory.GradedObject.mapBifunctorObjSingle‚ÇÄObjIso_inv","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_2} D\ninst‚úù¬≤ : Zero I\ninst‚úù¬π : DecidableEq I\ninst‚úù : CategoryTheory.Limits.HasInitial C\nF : CategoryTheory.Functor C (CategoryTheory.Functor D D)\nX : C\ne : CategoryTheory.Iso (F.obj X) (CategoryTheory.Functor.id D)\nY : CategoryTheory.GradedObject J D\na : Prod I J\nha : Eq a.1 0\n‚ä¢ Eq (CategoryTheory.GradedObject.mapBifunctorObjSingle‚ÇÄObjIso F X e Y a ha).inv (CategoryTheory.CategoryStruct.comp (e.inv.app (Y a.2)) ((F.map (CategoryTheory.GradedObject.singleObjApplyIsoOfEq 0 X a.1 ha).inv).app (Y a.2)))","decl":"/-- Given `F : C ‚•§ D ‚•§ D`, `X : C`, `e : F.obj X ‚âÖ ùü≠ D` and `Y : GradedObject J D`,\nthis is the isomorphism `((mapBifunctor F I J).obj ((single‚ÇÄ I).obj X)).obj Y a ‚âÖ Y a.2`\nwhen `a : I √ó J` is such that `a.1 = 0`. -/\n@[simps!]\nnoncomputable def mapBifunctorObjSingle‚ÇÄObjIso (a : I √ó J) (ha : a.1 = 0) :\n    ((mapBifunctor F I J).obj ((single‚ÇÄ I).obj X)).obj Y a ‚âÖ Y a.2 :=\n  (F.mapIso (singleObjApplyIsoOfEq _ X _ ha)).app _ ‚â™‚â´ e.app (Y a.2)\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorObjSingle‚ÇÄObjIso_hom","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_2} D\ninst‚úù¬≤ : Zero I\ninst‚úù¬π : DecidableEq I\ninst‚úù : CategoryTheory.Limits.HasInitial C\nF : CategoryTheory.Functor C (CategoryTheory.Functor D D)\nX : C\ne : CategoryTheory.Iso (F.obj X) (CategoryTheory.Functor.id D)\nY : CategoryTheory.GradedObject J D\na : Prod I J\nha : Eq a.1 0\n‚ä¢ Eq (CategoryTheory.GradedObject.mapBifunctorObjSingle‚ÇÄObjIso F X e Y a ha).hom (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.GradedObject.singleObjApplyIsoOfEq 0 X a.1 ha).hom).app (Y a.2)) (e.hom.app (Y a.2)))","decl":"/-- Given `F : C ‚•§ D ‚•§ D`, `X : C`, `e : F.obj X ‚âÖ ùü≠ D` and `Y : GradedObject J D`,\nthis is the isomorphism `((mapBifunctor F I J).obj ((single‚ÇÄ I).obj X)).obj Y a ‚âÖ Y a.2`\nwhen `a : I √ó J` is such that `a.1 = 0`. -/\n@[simps!]\nnoncomputable def mapBifunctorObjSingle‚ÇÄObjIso (a : I √ó J) (ha : a.1 = 0) :\n    ((mapBifunctor F I J).obj ((single‚ÇÄ I).obj X)).obj Y a ‚âÖ Y a.2 :=\n  (F.mapIso (singleObjApplyIsoOfEq _ X _ ha)).app _ ‚â™‚â´ e.app (Y a.2)\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorLeftUnitorCofan_inj","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst‚úù‚Åµ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬≥ : Zero I\ninst‚úù¬≤ : DecidableEq I\ninst‚úù¬π : CategoryTheory.Limits.HasInitial C\nF : CategoryTheory.Functor C (CategoryTheory.Functor D D)\nX : C\ne : CategoryTheory.Iso (F.obj X) (CategoryTheory.Functor.id D)\ninst‚úù : ‚àÄ (Y : D), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) (F.flip.obj Y)\np : Prod I J ‚Üí J\nhp : ‚àÄ (j : J), Eq (p { fst := 0, snd := j }) j\nY : CategoryTheory.GradedObject J D\nj : J\n‚ä¢ Eq (CategoryTheory.Limits.Cofan.inj (CategoryTheory.GradedObject.mapBifunctorLeftUnitorCofan F X e p hp Y j) ‚ü®{ fst := 0, snd := j }, ‚ãØ‚ü©) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.GradedObject.singleObjApplyIso 0 X).hom).app (Y j)) (e.hom.app (Y j)))","decl":"@[simp, reassoc]\nlemma mapBifunctorLeftUnitorCofan_inj (j : J) :\n    (mapBifunctorLeftUnitorCofan F X e p hp Y j).inj ‚ü®‚ü®0, j‚ü©, hp j‚ü© =\n      (F.map (singleObjApplyIso (0 : I) X).hom).app (Y j) ‚â´ e.hom.app (Y j) := by\n  simp [mapBifunctorLeftUnitorCofan]\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorLeftUnitorCofan_inj_assoc","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst‚úù‚Åµ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬≥ : Zero I\ninst‚úù¬≤ : DecidableEq I\ninst‚úù¬π : CategoryTheory.Limits.HasInitial C\nF : CategoryTheory.Functor C (CategoryTheory.Functor D D)\nX : C\ne : CategoryTheory.Iso (F.obj X) (CategoryTheory.Functor.id D)\ninst‚úù : ‚àÄ (Y : D), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) (F.flip.obj Y)\np : Prod I J ‚Üí J\nhp : ‚àÄ (j : J), Eq (p { fst := 0, snd := j }) j\nY : CategoryTheory.GradedObject J D\nj : J\nZ : D\nh : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorLeftUnitorCofan F X e p hp Y j).pt Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofan.inj (CategoryTheory.GradedObject.mapBifunctorLeftUnitorCofan F X e p hp Y j) ‚ü®{ fst := 0, snd := j }, ‚ãØ‚ü©) h) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.GradedObject.singleObjApplyIso 0 X).hom).app (Y j)) (CategoryTheory.CategoryStruct.comp (e.hom.app (Y j)) h))","decl":"@[simp, reassoc]\nlemma mapBifunctorLeftUnitorCofan_inj (j : J) :\n    (mapBifunctorLeftUnitorCofan F X e p hp Y j).inj ‚ü®‚ü®0, j‚ü©, hp j‚ü© =\n      (F.map (singleObjApplyIso (0 : I) X).hom).app (Y j) ‚â´ e.hom.app (Y j) := by\n  simp [mapBifunctorLeftUnitorCofan]\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorLeftUnitor_hasMap","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst‚úù‚Åµ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬≥ : Zero I\ninst‚úù¬≤ : DecidableEq I\ninst‚úù¬π : CategoryTheory.Limits.HasInitial C\nF : CategoryTheory.Functor C (CategoryTheory.Functor D D)\nX : C\ne : CategoryTheory.Iso (F.obj X) (CategoryTheory.Functor.id D)\ninst‚úù : ‚àÄ (Y : D), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) (F.flip.obj Y)\np : Prod I J ‚Üí J\nhp : ‚àÄ (j : J), Eq (p { fst := 0, snd := j }) j\nY : CategoryTheory.GradedObject J D\n‚ä¢ (((CategoryTheory.GradedObject.mapBifunctor F I J).obj ((CategoryTheory.GradedObject.single‚ÇÄ I).obj X)).obj Y).HasMap p","decl":"include e hp in\nlemma mapBifunctorLeftUnitor_hasMap :\n    HasMap (((mapBifunctor F I J).obj ((single‚ÇÄ I).obj X)).obj Y) p :=\n  CofanMapObjFun.hasMap _ _ _ (mapBifunctorLeftUnitorCofanIsColimit F X e p hp Y)\n\n"}
{"name":"CategoryTheory.GradedObject.Œπ_mapBifunctorLeftUnitor_hom_apply_assoc","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù‚Å¥ : Zero I\ninst‚úù¬≥ : DecidableEq I\ninst‚úù¬≤ : CategoryTheory.Limits.HasInitial C\nF : CategoryTheory.Functor C (CategoryTheory.Functor D D)\nX : C\ne : CategoryTheory.Iso (F.obj X) (CategoryTheory.Functor.id D)\ninst‚úù¬π : ‚àÄ (Y : D), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) (F.flip.obj Y)\np : Prod I J ‚Üí J\nhp : ‚àÄ (j : J), Eq (p { fst := 0, snd := j }) j\nY : CategoryTheory.GradedObject J D\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj ((CategoryTheory.GradedObject.single‚ÇÄ I).obj X)).obj Y).HasMap p\nj : J\nZ : D\nh : Quiver.Hom (Y j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctorMapObj F p ((CategoryTheory.GradedObject.single‚ÇÄ I).obj X) Y 0 j j ‚ãØ) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.GradedObject.mapBifunctorLeftUnitor F X e p hp Y).hom j) h)) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.GradedObject.singleObjApplyIso 0 X).hom).app (Y j)) (CategoryTheory.CategoryStruct.comp (e.hom.app (Y j)) h))","decl":"@[reassoc (attr := simp)]\nlemma Œπ_mapBifunctorLeftUnitor_hom_apply (j : J) :\n    ŒπMapBifunctorMapObj F p ((single‚ÇÄ I).obj X) Y 0 j j (hp j) ‚â´\n      (mapBifunctorLeftUnitor F X e p hp Y).hom j =\n      (F.map (singleObjApplyIso (0 : I) X).hom).app _ ‚â´ e.hom.app (Y j) := by\n  dsimp [mapBifunctorLeftUnitor]\n  erw [CofanMapObjFun.ŒπMapObj_iso_inv]\n  rw [mapBifunctorLeftUnitorCofan_inj]\n\n"}
{"name":"CategoryTheory.GradedObject.Œπ_mapBifunctorLeftUnitor_hom_apply","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù‚Å¥ : Zero I\ninst‚úù¬≥ : DecidableEq I\ninst‚úù¬≤ : CategoryTheory.Limits.HasInitial C\nF : CategoryTheory.Functor C (CategoryTheory.Functor D D)\nX : C\ne : CategoryTheory.Iso (F.obj X) (CategoryTheory.Functor.id D)\ninst‚úù¬π : ‚àÄ (Y : D), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) (F.flip.obj Y)\np : Prod I J ‚Üí J\nhp : ‚àÄ (j : J), Eq (p { fst := 0, snd := j }) j\nY : CategoryTheory.GradedObject J D\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj ((CategoryTheory.GradedObject.single‚ÇÄ I).obj X)).obj Y).HasMap p\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctorMapObj F p ((CategoryTheory.GradedObject.single‚ÇÄ I).obj X) Y 0 j j ‚ãØ) ((CategoryTheory.GradedObject.mapBifunctorLeftUnitor F X e p hp Y).hom j)) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.GradedObject.singleObjApplyIso 0 X).hom).app (Y j)) (e.hom.app (Y j)))","decl":"@[reassoc (attr := simp)]\nlemma Œπ_mapBifunctorLeftUnitor_hom_apply (j : J) :\n    ŒπMapBifunctorMapObj F p ((single‚ÇÄ I).obj X) Y 0 j j (hp j) ‚â´\n      (mapBifunctorLeftUnitor F X e p hp Y).hom j =\n      (F.map (singleObjApplyIso (0 : I) X).hom).app _ ‚â´ e.hom.app (Y j) := by\n  dsimp [mapBifunctorLeftUnitor]\n  erw [CofanMapObjFun.ŒπMapObj_iso_inv]\n  rw [mapBifunctorLeftUnitorCofan_inj]\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorLeftUnitor_inv_apply","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù‚Å¥ : Zero I\ninst‚úù¬≥ : DecidableEq I\ninst‚úù¬≤ : CategoryTheory.Limits.HasInitial C\nF : CategoryTheory.Functor C (CategoryTheory.Functor D D)\nX : C\ne : CategoryTheory.Iso (F.obj X) (CategoryTheory.Functor.id D)\ninst‚úù¬π : ‚àÄ (Y : D), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) (F.flip.obj Y)\np : Prod I J ‚Üí J\nhp : ‚àÄ (j : J), Eq (p { fst := 0, snd := j }) j\nY : CategoryTheory.GradedObject J D\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj ((CategoryTheory.GradedObject.single‚ÇÄ I).obj X)).obj Y).HasMap p\nj : J\n‚ä¢ Eq ((CategoryTheory.GradedObject.mapBifunctorLeftUnitor F X e p hp Y).inv j) (CategoryTheory.CategoryStruct.comp (e.inv.app (Y j)) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.GradedObject.singleObjApplyIso 0 X).inv).app (Y j)) (CategoryTheory.GradedObject.ŒπMapBifunctorMapObj F p ((CategoryTheory.GradedObject.single‚ÇÄ I).obj X) Y 0 j j ‚ãØ)))","decl":"lemma mapBifunctorLeftUnitor_inv_apply (j : J) :\n    (mapBifunctorLeftUnitor F X e p hp Y).inv j =\n      e.inv.app (Y j) ‚â´ (F.map (singleObjApplyIso (0 : I) X).inv).app (Y j) ‚â´\n      ŒπMapBifunctorMapObj F p ((single‚ÇÄ I).obj X) Y 0 j j (hp j) := rfl\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorLeftUnitor_inv_naturality","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù‚Åµ : Zero I\ninst‚úù‚Å¥ : DecidableEq I\ninst‚úù¬≥ : CategoryTheory.Limits.HasInitial C\nF : CategoryTheory.Functor C (CategoryTheory.Functor D D)\nX : C\ne : CategoryTheory.Iso (F.obj X) (CategoryTheory.Functor.id D)\ninst‚úù¬≤ : ‚àÄ (Y : D), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) (F.flip.obj Y)\np : Prod I J ‚Üí J\nhp : ‚àÄ (j : J), Eq (p { fst := 0, snd := j }) j\nY Y' : CategoryTheory.GradedObject J D\nœÜ : Quiver.Hom Y Y'\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj ((CategoryTheory.GradedObject.single‚ÇÄ I).obj X)).obj Y).HasMap p\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj ((CategoryTheory.GradedObject.single‚ÇÄ I).obj X)).obj Y').HasMap p\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp œÜ (CategoryTheory.GradedObject.mapBifunctorLeftUnitor F X e p hp Y').inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorLeftUnitor F X e p hp Y).inv (CategoryTheory.GradedObject.mapBifunctorMapMap F p (CategoryTheory.CategoryStruct.id ((CategoryTheory.GradedObject.single‚ÇÄ I).obj X)) œÜ))","decl":"@[reassoc]\nlemma mapBifunctorLeftUnitor_inv_naturality :\n    œÜ ‚â´ (mapBifunctorLeftUnitor F X e p hp Y').inv =\n      (mapBifunctorLeftUnitor F X e p hp Y).inv ‚â´ mapBifunctorMapMap F p (ùüô _) œÜ := by\n  ext j\n  dsimp\n  rw [mapBifunctorLeftUnitor_inv_apply, mapBifunctorLeftUnitor_inv_apply, assoc, assoc,\n    Œπ_mapBifunctorMapMap]\n  dsimp\n  rw [Functor.map_id, NatTrans.id_app, id_comp, ‚Üê NatTrans.naturality_assoc,\n    ‚Üê NatTrans.naturality_assoc]\n  rfl\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorLeftUnitor_inv_naturality_assoc","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù‚Åµ : Zero I\ninst‚úù‚Å¥ : DecidableEq I\ninst‚úù¬≥ : CategoryTheory.Limits.HasInitial C\nF : CategoryTheory.Functor C (CategoryTheory.Functor D D)\nX : C\ne : CategoryTheory.Iso (F.obj X) (CategoryTheory.Functor.id D)\ninst‚úù¬≤ : ‚àÄ (Y : D), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) (F.flip.obj Y)\np : Prod I J ‚Üí J\nhp : ‚àÄ (j : J), Eq (p { fst := 0, snd := j }) j\nY Y' : CategoryTheory.GradedObject J D\nœÜ : Quiver.Hom Y Y'\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj ((CategoryTheory.GradedObject.single‚ÇÄ I).obj X)).obj Y).HasMap p\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj ((CategoryTheory.GradedObject.single‚ÇÄ I).obj X)).obj Y').HasMap p\nZ : CategoryTheory.GradedObject J D\nh : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorMapObj F p ((CategoryTheory.GradedObject.single‚ÇÄ I).obj X) Y') Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp œÜ (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorLeftUnitor F X e p hp Y').inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorLeftUnitor F X e p hp Y).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorMapMap F p (CategoryTheory.CategoryStruct.id ((CategoryTheory.GradedObject.single‚ÇÄ I).obj X)) œÜ) h))","decl":"@[reassoc]\nlemma mapBifunctorLeftUnitor_inv_naturality :\n    œÜ ‚â´ (mapBifunctorLeftUnitor F X e p hp Y').inv =\n      (mapBifunctorLeftUnitor F X e p hp Y).inv ‚â´ mapBifunctorMapMap F p (ùüô _) œÜ := by\n  ext j\n  dsimp\n  rw [mapBifunctorLeftUnitor_inv_apply, mapBifunctorLeftUnitor_inv_apply, assoc, assoc,\n    Œπ_mapBifunctorMapMap]\n  dsimp\n  rw [Functor.map_id, NatTrans.id_app, id_comp, ‚Üê NatTrans.naturality_assoc,\n    ‚Üê NatTrans.naturality_assoc]\n  rfl\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorLeftUnitor_naturality","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù‚Åµ : Zero I\ninst‚úù‚Å¥ : DecidableEq I\ninst‚úù¬≥ : CategoryTheory.Limits.HasInitial C\nF : CategoryTheory.Functor C (CategoryTheory.Functor D D)\nX : C\ne : CategoryTheory.Iso (F.obj X) (CategoryTheory.Functor.id D)\ninst‚úù¬≤ : ‚àÄ (Y : D), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) (F.flip.obj Y)\np : Prod I J ‚Üí J\nhp : ‚àÄ (j : J), Eq (p { fst := 0, snd := j }) j\nY Y' : CategoryTheory.GradedObject J D\nœÜ : Quiver.Hom Y Y'\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj ((CategoryTheory.GradedObject.single‚ÇÄ I).obj X)).obj Y).HasMap p\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj ((CategoryTheory.GradedObject.single‚ÇÄ I).obj X)).obj Y').HasMap p\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorMapMap F p (CategoryTheory.CategoryStruct.id ((CategoryTheory.GradedObject.single‚ÇÄ I).obj X)) œÜ) (CategoryTheory.GradedObject.mapBifunctorLeftUnitor F X e p hp Y').hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorLeftUnitor F X e p hp Y).hom œÜ)","decl":"@[reassoc]\nlemma mapBifunctorLeftUnitor_naturality :\n    mapBifunctorMapMap F p (ùüô _) œÜ ‚â´ (mapBifunctorLeftUnitor F X e p hp Y').hom =\n      (mapBifunctorLeftUnitor F X e p hp Y).hom ‚â´ œÜ := by\n  rw [‚Üê cancel_mono (mapBifunctorLeftUnitor F X e p hp Y').inv, assoc, assoc, Iso.hom_inv_id,\n    comp_id, mapBifunctorLeftUnitor_inv_naturality, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorLeftUnitor_naturality_assoc","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù‚Åµ : Zero I\ninst‚úù‚Å¥ : DecidableEq I\ninst‚úù¬≥ : CategoryTheory.Limits.HasInitial C\nF : CategoryTheory.Functor C (CategoryTheory.Functor D D)\nX : C\ne : CategoryTheory.Iso (F.obj X) (CategoryTheory.Functor.id D)\ninst‚úù¬≤ : ‚àÄ (Y : D), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) (F.flip.obj Y)\np : Prod I J ‚Üí J\nhp : ‚àÄ (j : J), Eq (p { fst := 0, snd := j }) j\nY Y' : CategoryTheory.GradedObject J D\nœÜ : Quiver.Hom Y Y'\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj ((CategoryTheory.GradedObject.single‚ÇÄ I).obj X)).obj Y).HasMap p\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj ((CategoryTheory.GradedObject.single‚ÇÄ I).obj X)).obj Y').HasMap p\nZ : CategoryTheory.GradedObject J D\nh : Quiver.Hom Y' Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorMapMap F p (CategoryTheory.CategoryStruct.id ((CategoryTheory.GradedObject.single‚ÇÄ I).obj X)) œÜ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorLeftUnitor F X e p hp Y').hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorLeftUnitor F X e p hp Y).hom (CategoryTheory.CategoryStruct.comp œÜ h))","decl":"@[reassoc]\nlemma mapBifunctorLeftUnitor_naturality :\n    mapBifunctorMapMap F p (ùüô _) œÜ ‚â´ (mapBifunctorLeftUnitor F X e p hp Y').hom =\n      (mapBifunctorLeftUnitor F X e p hp Y).hom ‚â´ œÜ := by\n  rw [‚Üê cancel_mono (mapBifunctorLeftUnitor F X e p hp Y').inv, assoc, assoc, Iso.hom_inv_id,\n    comp_id, mapBifunctorLeftUnitor_inv_naturality, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorObjObjSingle‚ÇÄIso_hom","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_2} D\ninst‚úù¬≤ : Zero I\ninst‚úù¬π : DecidableEq I\ninst‚úù : CategoryTheory.Limits.HasInitial C\nF : CategoryTheory.Functor D (CategoryTheory.Functor C D)\nY : C\ne : CategoryTheory.Iso (F.flip.obj Y) (CategoryTheory.Functor.id D)\nX : CategoryTheory.GradedObject J D\na : Prod J I\nha : Eq a.2 0\n‚ä¢ Eq (CategoryTheory.GradedObject.mapBifunctorObjObjSingle‚ÇÄIso F Y e X a ha).hom (CategoryTheory.CategoryStruct.comp ((F.obj (X a.1)).map (CategoryTheory.GradedObject.singleObjApplyIsoOfEq 0 Y a.2 ha).hom) (e.hom.app (X a.1)))","decl":"/-- Given `F : D ‚•§ C ‚•§ D`, `Y : C`, `e : F.flip.obj X ‚âÖ ùü≠ D` and `X : GradedObject J D`,\nthis is the isomorphism `((mapBifunctor F J I).obj X).obj ((single‚ÇÄ I).obj Y) a ‚âÖ Y a.2`\nwhen `a : J √ó I` is such that `a.2 = 0`. -/\n@[simps!]\nnoncomputable def mapBifunctorObjObjSingle‚ÇÄIso (a : J √ó I) (ha : a.2 = 0) :\n    ((mapBifunctor F J I).obj X).obj ((single‚ÇÄ I).obj Y) a ‚âÖ X a.1 :=\n  Functor.mapIso _ (singleObjApplyIsoOfEq _ Y _ ha) ‚â™‚â´ e.app (X a.1)\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorObjObjSingle‚ÇÄIso_inv","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_2} D\ninst‚úù¬≤ : Zero I\ninst‚úù¬π : DecidableEq I\ninst‚úù : CategoryTheory.Limits.HasInitial C\nF : CategoryTheory.Functor D (CategoryTheory.Functor C D)\nY : C\ne : CategoryTheory.Iso (F.flip.obj Y) (CategoryTheory.Functor.id D)\nX : CategoryTheory.GradedObject J D\na : Prod J I\nha : Eq a.2 0\n‚ä¢ Eq (CategoryTheory.GradedObject.mapBifunctorObjObjSingle‚ÇÄIso F Y e X a ha).inv (CategoryTheory.CategoryStruct.comp (e.inv.app (X a.1)) ((F.obj (X a.1)).map (CategoryTheory.GradedObject.singleObjApplyIsoOfEq 0 Y a.2 ha).inv))","decl":"/-- Given `F : D ‚•§ C ‚•§ D`, `Y : C`, `e : F.flip.obj X ‚âÖ ùü≠ D` and `X : GradedObject J D`,\nthis is the isomorphism `((mapBifunctor F J I).obj X).obj ((single‚ÇÄ I).obj Y) a ‚âÖ Y a.2`\nwhen `a : J √ó I` is such that `a.2 = 0`. -/\n@[simps!]\nnoncomputable def mapBifunctorObjObjSingle‚ÇÄIso (a : J √ó I) (ha : a.2 = 0) :\n    ((mapBifunctor F J I).obj X).obj ((single‚ÇÄ I).obj Y) a ‚âÖ X a.1 :=\n  Functor.mapIso _ (singleObjApplyIsoOfEq _ Y _ ha) ‚â™‚â´ e.app (X a.1)\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorRightUnitorCofan_inj","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst‚úù‚Åµ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬≥ : Zero I\ninst‚úù¬≤ : DecidableEq I\ninst‚úù¬π : CategoryTheory.Limits.HasInitial C\nF : CategoryTheory.Functor D (CategoryTheory.Functor C D)\nY : C\ne : CategoryTheory.Iso (F.flip.obj Y) (CategoryTheory.Functor.id D)\ninst‚úù : ‚àÄ (X : D), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) (F.obj X)\np : Prod J I ‚Üí J\nhp : ‚àÄ (j : J), Eq (p { fst := j, snd := 0 }) j\nX : CategoryTheory.GradedObject J D\nj : J\n‚ä¢ Eq (CategoryTheory.Limits.Cofan.inj (CategoryTheory.GradedObject.mapBifunctorRightUnitorCofan F Y e p hp X j) ‚ü®{ fst := j, snd := 0 }, ‚ãØ‚ü©) (CategoryTheory.CategoryStruct.comp ((F.obj (X j)).map (CategoryTheory.GradedObject.singleObjApplyIso 0 Y).hom) (e.hom.app (X j)))","decl":"@[simp, reassoc]\nlemma mapBifunctorRightUnitorCofan_inj (j : J) :\n    (mapBifunctorRightUnitorCofan F Y e p hp X j).inj ‚ü®‚ü®j, 0‚ü©, hp j‚ü© =\n      (F.obj (X j)).map (singleObjApplyIso (0 : I) Y).hom ‚â´ e.hom.app (X j) := by\n  simp [mapBifunctorRightUnitorCofan]\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorRightUnitorCofan_inj_assoc","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst‚úù‚Åµ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬≥ : Zero I\ninst‚úù¬≤ : DecidableEq I\ninst‚úù¬π : CategoryTheory.Limits.HasInitial C\nF : CategoryTheory.Functor D (CategoryTheory.Functor C D)\nY : C\ne : CategoryTheory.Iso (F.flip.obj Y) (CategoryTheory.Functor.id D)\ninst‚úù : ‚àÄ (X : D), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) (F.obj X)\np : Prod J I ‚Üí J\nhp : ‚àÄ (j : J), Eq (p { fst := j, snd := 0 }) j\nX : CategoryTheory.GradedObject J D\nj : J\nZ : D\nh : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorRightUnitorCofan F Y e p hp X j).pt Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofan.inj (CategoryTheory.GradedObject.mapBifunctorRightUnitorCofan F Y e p hp X j) ‚ü®{ fst := j, snd := 0 }, ‚ãØ‚ü©) h) (CategoryTheory.CategoryStruct.comp ((F.obj (X j)).map (CategoryTheory.GradedObject.singleObjApplyIso 0 Y).hom) (CategoryTheory.CategoryStruct.comp (e.hom.app (X j)) h))","decl":"@[simp, reassoc]\nlemma mapBifunctorRightUnitorCofan_inj (j : J) :\n    (mapBifunctorRightUnitorCofan F Y e p hp X j).inj ‚ü®‚ü®j, 0‚ü©, hp j‚ü© =\n      (F.obj (X j)).map (singleObjApplyIso (0 : I) Y).hom ‚â´ e.hom.app (X j) := by\n  simp [mapBifunctorRightUnitorCofan]\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorRightUnitor_hasMap","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst‚úù‚Åµ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬≥ : Zero I\ninst‚úù¬≤ : DecidableEq I\ninst‚úù¬π : CategoryTheory.Limits.HasInitial C\nF : CategoryTheory.Functor D (CategoryTheory.Functor C D)\nY : C\ne : CategoryTheory.Iso (F.flip.obj Y) (CategoryTheory.Functor.id D)\ninst‚úù : ‚àÄ (X : D), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) (F.obj X)\np : Prod J I ‚Üí J\nhp : ‚àÄ (j : J), Eq (p { fst := j, snd := 0 }) j\nX : CategoryTheory.GradedObject J D\n‚ä¢ (((CategoryTheory.GradedObject.mapBifunctor F J I).obj X).obj ((CategoryTheory.GradedObject.single‚ÇÄ I).obj Y)).HasMap p","decl":"include e hp in\nlemma mapBifunctorRightUnitor_hasMap :\n    HasMap (((mapBifunctor F J I).obj X).obj ((single‚ÇÄ I).obj Y)) p :=\n  CofanMapObjFun.hasMap _ _ _ (mapBifunctorRightUnitorCofanIsColimit F Y e p hp X)\n\n"}
{"name":"CategoryTheory.GradedObject.Œπ_mapBifunctorRightUnitor_hom_apply","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù‚Å¥ : Zero I\ninst‚úù¬≥ : DecidableEq I\ninst‚úù¬≤ : CategoryTheory.Limits.HasInitial C\nF : CategoryTheory.Functor D (CategoryTheory.Functor C D)\nY : C\ne : CategoryTheory.Iso (F.flip.obj Y) (CategoryTheory.Functor.id D)\ninst‚úù¬π : ‚àÄ (X : D), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) (F.obj X)\np : Prod J I ‚Üí J\nhp : ‚àÄ (j : J), Eq (p { fst := j, snd := 0 }) j\nX : CategoryTheory.GradedObject J D\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor F J I).obj X).obj ((CategoryTheory.GradedObject.single‚ÇÄ I).obj Y)).HasMap p\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctorMapObj F p X ((CategoryTheory.GradedObject.single‚ÇÄ I).obj Y) j 0 j ‚ãØ) ((CategoryTheory.GradedObject.mapBifunctorRightUnitor F Y e p hp X).hom j)) (CategoryTheory.CategoryStruct.comp ((F.obj (X j)).map (CategoryTheory.GradedObject.singleObjApplyIso 0 Y).hom) (e.hom.app (X j)))","decl":"@[reassoc (attr := simp)]\nlemma Œπ_mapBifunctorRightUnitor_hom_apply (j : J) :\n    ŒπMapBifunctorMapObj F p X ((single‚ÇÄ I).obj Y) j 0 j (hp j) ‚â´\n        (mapBifunctorRightUnitor F Y e p hp X).hom j =\n      (F.obj (X j)).map (singleObjApplyIso (0 : I) Y).hom ‚â´ e.hom.app (X j) := by\n  dsimp [mapBifunctorRightUnitor]\n  erw [CofanMapObjFun.ŒπMapObj_iso_inv]\n  rw [mapBifunctorRightUnitorCofan_inj]\n\n"}
{"name":"CategoryTheory.GradedObject.Œπ_mapBifunctorRightUnitor_hom_apply_assoc","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù‚Å¥ : Zero I\ninst‚úù¬≥ : DecidableEq I\ninst‚úù¬≤ : CategoryTheory.Limits.HasInitial C\nF : CategoryTheory.Functor D (CategoryTheory.Functor C D)\nY : C\ne : CategoryTheory.Iso (F.flip.obj Y) (CategoryTheory.Functor.id D)\ninst‚úù¬π : ‚àÄ (X : D), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) (F.obj X)\np : Prod J I ‚Üí J\nhp : ‚àÄ (j : J), Eq (p { fst := j, snd := 0 }) j\nX : CategoryTheory.GradedObject J D\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor F J I).obj X).obj ((CategoryTheory.GradedObject.single‚ÇÄ I).obj Y)).HasMap p\nj : J\nZ : D\nh : Quiver.Hom (X j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctorMapObj F p X ((CategoryTheory.GradedObject.single‚ÇÄ I).obj Y) j 0 j ‚ãØ) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.GradedObject.mapBifunctorRightUnitor F Y e p hp X).hom j) h)) (CategoryTheory.CategoryStruct.comp ((F.obj (X j)).map (CategoryTheory.GradedObject.singleObjApplyIso 0 Y).hom) (CategoryTheory.CategoryStruct.comp (e.hom.app (X j)) h))","decl":"@[reassoc (attr := simp)]\nlemma Œπ_mapBifunctorRightUnitor_hom_apply (j : J) :\n    ŒπMapBifunctorMapObj F p X ((single‚ÇÄ I).obj Y) j 0 j (hp j) ‚â´\n        (mapBifunctorRightUnitor F Y e p hp X).hom j =\n      (F.obj (X j)).map (singleObjApplyIso (0 : I) Y).hom ‚â´ e.hom.app (X j) := by\n  dsimp [mapBifunctorRightUnitor]\n  erw [CofanMapObjFun.ŒπMapObj_iso_inv]\n  rw [mapBifunctorRightUnitorCofan_inj]\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorRightUnitor_inv_apply","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù‚Å¥ : Zero I\ninst‚úù¬≥ : DecidableEq I\ninst‚úù¬≤ : CategoryTheory.Limits.HasInitial C\nF : CategoryTheory.Functor D (CategoryTheory.Functor C D)\nY : C\ne : CategoryTheory.Iso (F.flip.obj Y) (CategoryTheory.Functor.id D)\ninst‚úù¬π : ‚àÄ (X : D), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) (F.obj X)\np : Prod J I ‚Üí J\nhp : ‚àÄ (j : J), Eq (p { fst := j, snd := 0 }) j\nX : CategoryTheory.GradedObject J D\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor F J I).obj X).obj ((CategoryTheory.GradedObject.single‚ÇÄ I).obj Y)).HasMap p\nj : J\n‚ä¢ Eq ((CategoryTheory.GradedObject.mapBifunctorRightUnitor F Y e p hp X).inv j) (CategoryTheory.CategoryStruct.comp (e.inv.app (X j)) (CategoryTheory.CategoryStruct.comp ((F.obj (X j)).map (CategoryTheory.GradedObject.singleObjApplyIso 0 Y).inv) (CategoryTheory.GradedObject.ŒπMapBifunctorMapObj F p X ((CategoryTheory.GradedObject.single‚ÇÄ I).obj Y) j 0 j ‚ãØ)))","decl":"lemma mapBifunctorRightUnitor_inv_apply (j : J) :\n    (mapBifunctorRightUnitor F Y e p hp X).inv j =\n      e.inv.app (X j) ‚â´ (F.obj (X j)).map (singleObjApplyIso (0 : I) Y).inv ‚â´\n        ŒπMapBifunctorMapObj F p X ((single‚ÇÄ I).obj Y) j 0 j (hp j) := rfl\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorRightUnitor_inv_naturality_assoc","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù‚Åµ : Zero I\ninst‚úù‚Å¥ : DecidableEq I\ninst‚úù¬≥ : CategoryTheory.Limits.HasInitial C\nF : CategoryTheory.Functor D (CategoryTheory.Functor C D)\nY : C\ne : CategoryTheory.Iso (F.flip.obj Y) (CategoryTheory.Functor.id D)\ninst‚úù¬≤ : ‚àÄ (X : D), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) (F.obj X)\np : Prod J I ‚Üí J\nhp : ‚àÄ (j : J), Eq (p { fst := j, snd := 0 }) j\nX X' : CategoryTheory.GradedObject J D\nœÜ : Quiver.Hom X X'\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor F J I).obj X).obj ((CategoryTheory.GradedObject.single‚ÇÄ I).obj Y)).HasMap p\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor F J I).obj X').obj ((CategoryTheory.GradedObject.single‚ÇÄ I).obj Y)).HasMap p\nZ : CategoryTheory.GradedObject J D\nh : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorMapObj F p X' ((CategoryTheory.GradedObject.single‚ÇÄ I).obj Y)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp œÜ (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorRightUnitor F Y e p hp X').inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorRightUnitor F Y e p hp X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorMapMap F p œÜ (CategoryTheory.CategoryStruct.id ((CategoryTheory.GradedObject.single‚ÇÄ I).obj Y))) h))","decl":"@[reassoc]\nlemma mapBifunctorRightUnitor_inv_naturality :\n    œÜ ‚â´ (mapBifunctorRightUnitor F Y e p hp X').inv =\n      (mapBifunctorRightUnitor F Y e p hp X).inv ‚â´ mapBifunctorMapMap F p œÜ (ùüô _) := by\n  ext j\n  dsimp\n  rw [mapBifunctorRightUnitor_inv_apply, mapBifunctorRightUnitor_inv_apply, assoc, assoc,\n    Œπ_mapBifunctorMapMap]\n  dsimp\n  rw [Functor.map_id, id_comp, NatTrans.naturality_assoc]\n  erw [‚Üê NatTrans.naturality_assoc e.inv]\n  rfl\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorRightUnitor_inv_naturality","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù‚Åµ : Zero I\ninst‚úù‚Å¥ : DecidableEq I\ninst‚úù¬≥ : CategoryTheory.Limits.HasInitial C\nF : CategoryTheory.Functor D (CategoryTheory.Functor C D)\nY : C\ne : CategoryTheory.Iso (F.flip.obj Y) (CategoryTheory.Functor.id D)\ninst‚úù¬≤ : ‚àÄ (X : D), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) (F.obj X)\np : Prod J I ‚Üí J\nhp : ‚àÄ (j : J), Eq (p { fst := j, snd := 0 }) j\nX X' : CategoryTheory.GradedObject J D\nœÜ : Quiver.Hom X X'\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor F J I).obj X).obj ((CategoryTheory.GradedObject.single‚ÇÄ I).obj Y)).HasMap p\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor F J I).obj X').obj ((CategoryTheory.GradedObject.single‚ÇÄ I).obj Y)).HasMap p\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp œÜ (CategoryTheory.GradedObject.mapBifunctorRightUnitor F Y e p hp X').inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorRightUnitor F Y e p hp X).inv (CategoryTheory.GradedObject.mapBifunctorMapMap F p œÜ (CategoryTheory.CategoryStruct.id ((CategoryTheory.GradedObject.single‚ÇÄ I).obj Y))))","decl":"@[reassoc]\nlemma mapBifunctorRightUnitor_inv_naturality :\n    œÜ ‚â´ (mapBifunctorRightUnitor F Y e p hp X').inv =\n      (mapBifunctorRightUnitor F Y e p hp X).inv ‚â´ mapBifunctorMapMap F p œÜ (ùüô _) := by\n  ext j\n  dsimp\n  rw [mapBifunctorRightUnitor_inv_apply, mapBifunctorRightUnitor_inv_apply, assoc, assoc,\n    Œπ_mapBifunctorMapMap]\n  dsimp\n  rw [Functor.map_id, id_comp, NatTrans.naturality_assoc]\n  erw [‚Üê NatTrans.naturality_assoc e.inv]\n  rfl\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorRightUnitor_naturality","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù‚Åµ : Zero I\ninst‚úù‚Å¥ : DecidableEq I\ninst‚úù¬≥ : CategoryTheory.Limits.HasInitial C\nF : CategoryTheory.Functor D (CategoryTheory.Functor C D)\nY : C\ne : CategoryTheory.Iso (F.flip.obj Y) (CategoryTheory.Functor.id D)\ninst‚úù¬≤ : ‚àÄ (X : D), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) (F.obj X)\np : Prod J I ‚Üí J\nhp : ‚àÄ (j : J), Eq (p { fst := j, snd := 0 }) j\nX X' : CategoryTheory.GradedObject J D\nœÜ : Quiver.Hom X X'\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor F J I).obj X).obj ((CategoryTheory.GradedObject.single‚ÇÄ I).obj Y)).HasMap p\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor F J I).obj X').obj ((CategoryTheory.GradedObject.single‚ÇÄ I).obj Y)).HasMap p\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorMapMap F p œÜ (CategoryTheory.CategoryStruct.id ((CategoryTheory.GradedObject.single‚ÇÄ I).obj Y))) (CategoryTheory.GradedObject.mapBifunctorRightUnitor F Y e p hp X').hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorRightUnitor F Y e p hp X).hom œÜ)","decl":"@[reassoc]\nlemma mapBifunctorRightUnitor_naturality :\n    mapBifunctorMapMap F p œÜ (ùüô _) ‚â´ (mapBifunctorRightUnitor F Y e p hp X').hom =\n      (mapBifunctorRightUnitor F Y e p hp X).hom ‚â´ œÜ := by\n  rw [‚Üê cancel_mono (mapBifunctorRightUnitor F Y e p hp X').inv, assoc, assoc, Iso.hom_inv_id,\n    comp_id, mapBifunctorRightUnitor_inv_naturality, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorRightUnitor_naturality_assoc","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù‚Åµ : Zero I\ninst‚úù‚Å¥ : DecidableEq I\ninst‚úù¬≥ : CategoryTheory.Limits.HasInitial C\nF : CategoryTheory.Functor D (CategoryTheory.Functor C D)\nY : C\ne : CategoryTheory.Iso (F.flip.obj Y) (CategoryTheory.Functor.id D)\ninst‚úù¬≤ : ‚àÄ (X : D), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) (F.obj X)\np : Prod J I ‚Üí J\nhp : ‚àÄ (j : J), Eq (p { fst := j, snd := 0 }) j\nX X' : CategoryTheory.GradedObject J D\nœÜ : Quiver.Hom X X'\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor F J I).obj X).obj ((CategoryTheory.GradedObject.single‚ÇÄ I).obj Y)).HasMap p\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor F J I).obj X').obj ((CategoryTheory.GradedObject.single‚ÇÄ I).obj Y)).HasMap p\nZ : CategoryTheory.GradedObject J D\nh : Quiver.Hom X' Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorMapMap F p œÜ (CategoryTheory.CategoryStruct.id ((CategoryTheory.GradedObject.single‚ÇÄ I).obj Y))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorRightUnitor F Y e p hp X').hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorRightUnitor F Y e p hp X).hom (CategoryTheory.CategoryStruct.comp œÜ h))","decl":"@[reassoc]\nlemma mapBifunctorRightUnitor_naturality :\n    mapBifunctorMapMap F p œÜ (ùüô _) ‚â´ (mapBifunctorRightUnitor F Y e p hp X').hom =\n      (mapBifunctorRightUnitor F Y e p hp X).hom ‚â´ œÜ := by\n  rw [‚Üê cancel_mono (mapBifunctorRightUnitor F Y e p hp X').inv, assoc, assoc, Iso.hom_inv_id,\n    comp_id, mapBifunctorRightUnitor_inv_naturality, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.GradedObject.TriangleIndexData.hp‚ÇÅ‚ÇÇ","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"I‚ÇÅ : Type u_1\nI‚ÇÇ : Type u_2\nI‚ÇÉ : Type u_3\nJ : Type u_4\ninst‚úù : Zero I‚ÇÇ\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÄ : Prod I‚ÇÅ I‚ÇÉ ‚Üí J\nself : CategoryTheory.GradedObject.TriangleIndexData r œÄ\ni : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)\n‚ä¢ Eq (œÄ { fst := self.p‚ÇÅ‚ÇÇ { fst := i.1, snd := i.2.1 }, snd := i.2.2 }) (r i)","decl":"/-- Given two maps `r : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J` and `œÄ : I‚ÇÅ √ó I‚ÇÉ ‚Üí J`, this structure is the\ninput in the formulation of the triangle equality `mapBifunctor_triangle` which\nrelates the left and right unitor and the associator for `GradedObject.mapBifunctor`. -/\nstructure TriangleIndexData (r : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J) (œÄ : I‚ÇÅ √ó I‚ÇÉ ‚Üí J) where\n  /-- a map `I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ` -/\n  p‚ÇÅ‚ÇÇ : I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ\n  hp‚ÇÅ‚ÇÇ (i : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) : œÄ ‚ü®p‚ÇÅ‚ÇÇ ‚ü®i.1, i.2.1‚ü©, i.2.2‚ü© = r i\n  /-- a map `I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÉ` -/\n  p‚ÇÇ‚ÇÉ : I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÉ\n  hp‚ÇÇ‚ÇÉ (i : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) : œÄ ‚ü®i.1, p‚ÇÇ‚ÇÉ i.2‚ü© = r i\n  h‚ÇÅ (i‚ÇÅ : I‚ÇÅ) : p‚ÇÅ‚ÇÇ (i‚ÇÅ, 0) = i‚ÇÅ\n  h‚ÇÉ (i‚ÇÉ : I‚ÇÉ) : p‚ÇÇ‚ÇÉ (0, i‚ÇÉ) = i‚ÇÉ\n\n"}
{"name":"CategoryTheory.GradedObject.TriangleIndexData.hp‚ÇÇ‚ÇÉ","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"I‚ÇÅ : Type u_1\nI‚ÇÇ : Type u_2\nI‚ÇÉ : Type u_3\nJ : Type u_4\ninst‚úù : Zero I‚ÇÇ\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÄ : Prod I‚ÇÅ I‚ÇÉ ‚Üí J\nself : CategoryTheory.GradedObject.TriangleIndexData r œÄ\ni : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)\n‚ä¢ Eq (œÄ { fst := i.1, snd := self.p‚ÇÇ‚ÇÉ i.2 }) (r i)","decl":"/-- Given two maps `r : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J` and `œÄ : I‚ÇÅ √ó I‚ÇÉ ‚Üí J`, this structure is the\ninput in the formulation of the triangle equality `mapBifunctor_triangle` which\nrelates the left and right unitor and the associator for `GradedObject.mapBifunctor`. -/\nstructure TriangleIndexData (r : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J) (œÄ : I‚ÇÅ √ó I‚ÇÉ ‚Üí J) where\n  /-- a map `I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ` -/\n  p‚ÇÅ‚ÇÇ : I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ\n  hp‚ÇÅ‚ÇÇ (i : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) : œÄ ‚ü®p‚ÇÅ‚ÇÇ ‚ü®i.1, i.2.1‚ü©, i.2.2‚ü© = r i\n  /-- a map `I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÉ` -/\n  p‚ÇÇ‚ÇÉ : I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÉ\n  hp‚ÇÇ‚ÇÉ (i : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) : œÄ ‚ü®i.1, p‚ÇÇ‚ÇÉ i.2‚ü© = r i\n  h‚ÇÅ (i‚ÇÅ : I‚ÇÅ) : p‚ÇÅ‚ÇÇ (i‚ÇÅ, 0) = i‚ÇÅ\n  h‚ÇÉ (i‚ÇÉ : I‚ÇÉ) : p‚ÇÇ‚ÇÉ (0, i‚ÇÉ) = i‚ÇÉ\n\n"}
{"name":"CategoryTheory.GradedObject.TriangleIndexData.h‚ÇÉ","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"I‚ÇÅ : Type u_1\nI‚ÇÇ : Type u_2\nI‚ÇÉ : Type u_3\nJ : Type u_4\ninst‚úù : Zero I‚ÇÇ\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÄ : Prod I‚ÇÅ I‚ÇÉ ‚Üí J\nself : CategoryTheory.GradedObject.TriangleIndexData r œÄ\ni‚ÇÉ : I‚ÇÉ\n‚ä¢ Eq (self.p‚ÇÇ‚ÇÉ { fst := 0, snd := i‚ÇÉ }) i‚ÇÉ","decl":"/-- Given two maps `r : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J` and `œÄ : I‚ÇÅ √ó I‚ÇÉ ‚Üí J`, this structure is the\ninput in the formulation of the triangle equality `mapBifunctor_triangle` which\nrelates the left and right unitor and the associator for `GradedObject.mapBifunctor`. -/\nstructure TriangleIndexData (r : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J) (œÄ : I‚ÇÅ √ó I‚ÇÉ ‚Üí J) where\n  /-- a map `I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ` -/\n  p‚ÇÅ‚ÇÇ : I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ\n  hp‚ÇÅ‚ÇÇ (i : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) : œÄ ‚ü®p‚ÇÅ‚ÇÇ ‚ü®i.1, i.2.1‚ü©, i.2.2‚ü© = r i\n  /-- a map `I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÉ` -/\n  p‚ÇÇ‚ÇÉ : I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÉ\n  hp‚ÇÇ‚ÇÉ (i : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) : œÄ ‚ü®i.1, p‚ÇÇ‚ÇÉ i.2‚ü© = r i\n  h‚ÇÅ (i‚ÇÅ : I‚ÇÅ) : p‚ÇÅ‚ÇÇ (i‚ÇÅ, 0) = i‚ÇÅ\n  h‚ÇÉ (i‚ÇÉ : I‚ÇÉ) : p‚ÇÇ‚ÇÉ (0, i‚ÇÉ) = i‚ÇÉ\n\n"}
{"name":"CategoryTheory.GradedObject.TriangleIndexData.h‚ÇÅ","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"I‚ÇÅ : Type u_1\nI‚ÇÇ : Type u_2\nI‚ÇÉ : Type u_3\nJ : Type u_4\ninst‚úù : Zero I‚ÇÇ\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÄ : Prod I‚ÇÅ I‚ÇÉ ‚Üí J\nself : CategoryTheory.GradedObject.TriangleIndexData r œÄ\ni‚ÇÅ : I‚ÇÅ\n‚ä¢ Eq (self.p‚ÇÅ‚ÇÇ { fst := i‚ÇÅ, snd := 0 }) i‚ÇÅ","decl":"/-- Given two maps `r : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J` and `œÄ : I‚ÇÅ √ó I‚ÇÉ ‚Üí J`, this structure is the\ninput in the formulation of the triangle equality `mapBifunctor_triangle` which\nrelates the left and right unitor and the associator for `GradedObject.mapBifunctor`. -/\nstructure TriangleIndexData (r : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J) (œÄ : I‚ÇÅ √ó I‚ÇÉ ‚Üí J) where\n  /-- a map `I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ` -/\n  p‚ÇÅ‚ÇÇ : I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ\n  hp‚ÇÅ‚ÇÇ (i : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) : œÄ ‚ü®p‚ÇÅ‚ÇÇ ‚ü®i.1, i.2.1‚ü©, i.2.2‚ü© = r i\n  /-- a map `I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÉ` -/\n  p‚ÇÇ‚ÇÉ : I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÉ\n  hp‚ÇÇ‚ÇÉ (i : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) : œÄ ‚ü®i.1, p‚ÇÇ‚ÇÉ i.2‚ü© = r i\n  h‚ÇÅ (i‚ÇÅ : I‚ÇÅ) : p‚ÇÅ‚ÇÇ (i‚ÇÅ, 0) = i‚ÇÅ\n  h‚ÇÉ (i‚ÇÉ : I‚ÇÉ) : p‚ÇÇ‚ÇÉ (0, i‚ÇÉ) = i‚ÇÉ\n\n"}
{"name":"CategoryTheory.GradedObject.TriangleIndexData.mk.inj","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"I‚ÇÅ : Type u_1\nI‚ÇÇ : Type u_2\nI‚ÇÉ : Type u_3\nJ : Type u_4\ninst‚úù : Zero I‚ÇÇ\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÄ : Prod I‚ÇÅ I‚ÇÉ ‚Üí J\np‚ÇÅ‚ÇÇ‚úù : Prod I‚ÇÅ I‚ÇÇ ‚Üí I‚ÇÅ\nhp‚ÇÅ‚ÇÇ‚úù : ‚àÄ (i : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)), Eq (œÄ { fst := p‚ÇÅ‚ÇÇ‚úù { fst := i.1, snd := i.2.1 }, snd := i.2.2 }) (r i)\np‚ÇÇ‚ÇÉ‚úù : Prod I‚ÇÇ I‚ÇÉ ‚Üí I‚ÇÉ\nhp‚ÇÇ‚ÇÉ‚úù : ‚àÄ (i : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)), Eq (œÄ { fst := i.1, snd := p‚ÇÇ‚ÇÉ‚úù i.2 }) (r i)\nh‚ÇÅ‚úù : ‚àÄ (i‚ÇÅ : I‚ÇÅ), Eq (p‚ÇÅ‚ÇÇ‚úù { fst := i‚ÇÅ, snd := 0 }) i‚ÇÅ\nh‚ÇÉ‚úù : ‚àÄ (i‚ÇÉ : I‚ÇÉ), Eq (p‚ÇÇ‚ÇÉ‚úù { fst := 0, snd := i‚ÇÉ }) i‚ÇÉ\np‚ÇÅ‚ÇÇ : Prod I‚ÇÅ I‚ÇÇ ‚Üí I‚ÇÅ\nhp‚ÇÅ‚ÇÇ : ‚àÄ (i : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)), Eq (œÄ { fst := p‚ÇÅ‚ÇÇ { fst := i.1, snd := i.2.1 }, snd := i.2.2 }) (r i)\np‚ÇÇ‚ÇÉ : Prod I‚ÇÇ I‚ÇÉ ‚Üí I‚ÇÉ\nhp‚ÇÇ‚ÇÉ : ‚àÄ (i : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)), Eq (œÄ { fst := i.1, snd := p‚ÇÇ‚ÇÉ i.2 }) (r i)\nh‚ÇÅ : ‚àÄ (i‚ÇÅ : I‚ÇÅ), Eq (p‚ÇÅ‚ÇÇ { fst := i‚ÇÅ, snd := 0 }) i‚ÇÅ\nh‚ÇÉ : ‚àÄ (i‚ÇÉ : I‚ÇÉ), Eq (p‚ÇÇ‚ÇÉ { fst := 0, snd := i‚ÇÉ }) i‚ÇÉ\nx‚úù : Eq { p‚ÇÅ‚ÇÇ := p‚ÇÅ‚ÇÇ‚úù, hp‚ÇÅ‚ÇÇ := hp‚ÇÅ‚ÇÇ‚úù, p‚ÇÇ‚ÇÉ := p‚ÇÇ‚ÇÉ‚úù, hp‚ÇÇ‚ÇÉ := hp‚ÇÇ‚ÇÉ‚úù, h‚ÇÅ := h‚ÇÅ‚úù, h‚ÇÉ := h‚ÇÉ‚úù } { p‚ÇÅ‚ÇÇ := p‚ÇÅ‚ÇÇ, hp‚ÇÅ‚ÇÇ := hp‚ÇÅ‚ÇÇ, p‚ÇÇ‚ÇÉ := p‚ÇÇ‚ÇÉ, hp‚ÇÇ‚ÇÉ := hp‚ÇÇ‚ÇÉ, h‚ÇÅ := h‚ÇÅ, h‚ÇÉ := h‚ÇÉ }\n‚ä¢ And (Eq p‚ÇÅ‚ÇÇ‚úù p‚ÇÅ‚ÇÇ) (Eq p‚ÇÇ‚ÇÉ‚úù p‚ÇÇ‚ÇÉ)","decl":"/-- Given two maps `r : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J` and `œÄ : I‚ÇÅ √ó I‚ÇÉ ‚Üí J`, this structure is the\ninput in the formulation of the triangle equality `mapBifunctor_triangle` which\nrelates the left and right unitor and the associator for `GradedObject.mapBifunctor`. -/\nstructure TriangleIndexData (r : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J) (œÄ : I‚ÇÅ √ó I‚ÇÉ ‚Üí J) where\n  /-- a map `I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ` -/\n  p‚ÇÅ‚ÇÇ : I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ\n  hp‚ÇÅ‚ÇÇ (i : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) : œÄ ‚ü®p‚ÇÅ‚ÇÇ ‚ü®i.1, i.2.1‚ü©, i.2.2‚ü© = r i\n  /-- a map `I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÉ` -/\n  p‚ÇÇ‚ÇÉ : I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÉ\n  hp‚ÇÇ‚ÇÉ (i : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) : œÄ ‚ü®i.1, p‚ÇÇ‚ÇÉ i.2‚ü© = r i\n  h‚ÇÅ (i‚ÇÅ : I‚ÇÅ) : p‚ÇÅ‚ÇÇ (i‚ÇÅ, 0) = i‚ÇÅ\n  h‚ÇÉ (i‚ÇÉ : I‚ÇÉ) : p‚ÇÇ‚ÇÉ (0, i‚ÇÉ) = i‚ÇÉ\n\n"}
{"name":"CategoryTheory.GradedObject.TriangleIndexData.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"I‚ÇÅ : Type u_1\nI‚ÇÇ : Type u_2\nI‚ÇÉ : Type u_3\nJ : Type u_4\ninst‚úù‚Å¥ : Zero I‚ÇÇ\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÄ : Prod I‚ÇÅ I‚ÇÉ ‚Üí J\ninst‚úù¬≥ : SizeOf I‚ÇÅ\ninst‚úù¬≤ : SizeOf I‚ÇÇ\ninst‚úù¬π : SizeOf I‚ÇÉ\ninst‚úù : SizeOf J\np‚ÇÅ‚ÇÇ : Prod I‚ÇÅ I‚ÇÇ ‚Üí I‚ÇÅ\nhp‚ÇÅ‚ÇÇ : ‚àÄ (i : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)), Eq (œÄ { fst := p‚ÇÅ‚ÇÇ { fst := i.1, snd := i.2.1 }, snd := i.2.2 }) (r i)\np‚ÇÇ‚ÇÉ : Prod I‚ÇÇ I‚ÇÉ ‚Üí I‚ÇÉ\nhp‚ÇÇ‚ÇÉ : ‚àÄ (i : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)), Eq (œÄ { fst := i.1, snd := p‚ÇÇ‚ÇÉ i.2 }) (r i)\nh‚ÇÅ : ‚àÄ (i‚ÇÅ : I‚ÇÅ), Eq (p‚ÇÅ‚ÇÇ { fst := i‚ÇÅ, snd := 0 }) i‚ÇÅ\nh‚ÇÉ : ‚àÄ (i‚ÇÉ : I‚ÇÉ), Eq (p‚ÇÇ‚ÇÉ { fst := 0, snd := i‚ÇÉ }) i‚ÇÉ\n‚ä¢ Eq (SizeOf.sizeOf { p‚ÇÅ‚ÇÇ := p‚ÇÅ‚ÇÇ, hp‚ÇÅ‚ÇÇ := hp‚ÇÅ‚ÇÇ, p‚ÇÇ‚ÇÉ := p‚ÇÇ‚ÇÉ, hp‚ÇÇ‚ÇÉ := hp‚ÇÇ‚ÇÉ, h‚ÇÅ := h‚ÇÅ, h‚ÇÉ := h‚ÇÉ }) 1","decl":"/-- Given two maps `r : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J` and `œÄ : I‚ÇÅ √ó I‚ÇÉ ‚Üí J`, this structure is the\ninput in the formulation of the triangle equality `mapBifunctor_triangle` which\nrelates the left and right unitor and the associator for `GradedObject.mapBifunctor`. -/\nstructure TriangleIndexData (r : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J) (œÄ : I‚ÇÅ √ó I‚ÇÉ ‚Üí J) where\n  /-- a map `I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ` -/\n  p‚ÇÅ‚ÇÇ : I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ\n  hp‚ÇÅ‚ÇÇ (i : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) : œÄ ‚ü®p‚ÇÅ‚ÇÇ ‚ü®i.1, i.2.1‚ü©, i.2.2‚ü© = r i\n  /-- a map `I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÉ` -/\n  p‚ÇÇ‚ÇÉ : I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÉ\n  hp‚ÇÇ‚ÇÉ (i : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) : œÄ ‚ü®i.1, p‚ÇÇ‚ÇÉ i.2‚ü© = r i\n  h‚ÇÅ (i‚ÇÅ : I‚ÇÅ) : p‚ÇÅ‚ÇÇ (i‚ÇÅ, 0) = i‚ÇÅ\n  h‚ÇÉ (i‚ÇÉ : I‚ÇÉ) : p‚ÇÇ‚ÇÉ (0, i‚ÇÉ) = i‚ÇÉ\n\n"}
{"name":"CategoryTheory.GradedObject.TriangleIndexData.mk.injEq","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"I‚ÇÅ : Type u_1\nI‚ÇÇ : Type u_2\nI‚ÇÉ : Type u_3\nJ : Type u_4\ninst‚úù : Zero I‚ÇÇ\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÄ : Prod I‚ÇÅ I‚ÇÉ ‚Üí J\np‚ÇÅ‚ÇÇ‚úù : Prod I‚ÇÅ I‚ÇÇ ‚Üí I‚ÇÅ\nhp‚ÇÅ‚ÇÇ‚úù : ‚àÄ (i : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)), Eq (œÄ { fst := p‚ÇÅ‚ÇÇ‚úù { fst := i.1, snd := i.2.1 }, snd := i.2.2 }) (r i)\np‚ÇÇ‚ÇÉ‚úù : Prod I‚ÇÇ I‚ÇÉ ‚Üí I‚ÇÉ\nhp‚ÇÇ‚ÇÉ‚úù : ‚àÄ (i : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)), Eq (œÄ { fst := i.1, snd := p‚ÇÇ‚ÇÉ‚úù i.2 }) (r i)\nh‚ÇÅ‚úù : ‚àÄ (i‚ÇÅ : I‚ÇÅ), Eq (p‚ÇÅ‚ÇÇ‚úù { fst := i‚ÇÅ, snd := 0 }) i‚ÇÅ\nh‚ÇÉ‚úù : ‚àÄ (i‚ÇÉ : I‚ÇÉ), Eq (p‚ÇÇ‚ÇÉ‚úù { fst := 0, snd := i‚ÇÉ }) i‚ÇÉ\np‚ÇÅ‚ÇÇ : Prod I‚ÇÅ I‚ÇÇ ‚Üí I‚ÇÅ\nhp‚ÇÅ‚ÇÇ : ‚àÄ (i : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)), Eq (œÄ { fst := p‚ÇÅ‚ÇÇ { fst := i.1, snd := i.2.1 }, snd := i.2.2 }) (r i)\np‚ÇÇ‚ÇÉ : Prod I‚ÇÇ I‚ÇÉ ‚Üí I‚ÇÉ\nhp‚ÇÇ‚ÇÉ : ‚àÄ (i : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)), Eq (œÄ { fst := i.1, snd := p‚ÇÇ‚ÇÉ i.2 }) (r i)\nh‚ÇÅ : ‚àÄ (i‚ÇÅ : I‚ÇÅ), Eq (p‚ÇÅ‚ÇÇ { fst := i‚ÇÅ, snd := 0 }) i‚ÇÅ\nh‚ÇÉ : ‚àÄ (i‚ÇÉ : I‚ÇÉ), Eq (p‚ÇÇ‚ÇÉ { fst := 0, snd := i‚ÇÉ }) i‚ÇÉ\n‚ä¢ Eq (Eq { p‚ÇÅ‚ÇÇ := p‚ÇÅ‚ÇÇ‚úù, hp‚ÇÅ‚ÇÇ := hp‚ÇÅ‚ÇÇ‚úù, p‚ÇÇ‚ÇÉ := p‚ÇÇ‚ÇÉ‚úù, hp‚ÇÇ‚ÇÉ := hp‚ÇÇ‚ÇÉ‚úù, h‚ÇÅ := h‚ÇÅ‚úù, h‚ÇÉ := h‚ÇÉ‚úù } { p‚ÇÅ‚ÇÇ := p‚ÇÅ‚ÇÇ, hp‚ÇÅ‚ÇÇ := hp‚ÇÅ‚ÇÇ, p‚ÇÇ‚ÇÉ := p‚ÇÇ‚ÇÉ, hp‚ÇÇ‚ÇÉ := hp‚ÇÇ‚ÇÉ, h‚ÇÅ := h‚ÇÅ, h‚ÇÉ := h‚ÇÉ }) (And (Eq p‚ÇÅ‚ÇÇ‚úù p‚ÇÅ‚ÇÇ) (Eq p‚ÇÇ‚ÇÉ‚úù p‚ÇÇ‚ÇÉ))","decl":"/-- Given two maps `r : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J` and `œÄ : I‚ÇÅ √ó I‚ÇÉ ‚Üí J`, this structure is the\ninput in the formulation of the triangle equality `mapBifunctor_triangle` which\nrelates the left and right unitor and the associator for `GradedObject.mapBifunctor`. -/\nstructure TriangleIndexData (r : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J) (œÄ : I‚ÇÅ √ó I‚ÇÉ ‚Üí J) where\n  /-- a map `I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ` -/\n  p‚ÇÅ‚ÇÇ : I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ\n  hp‚ÇÅ‚ÇÇ (i : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) : œÄ ‚ü®p‚ÇÅ‚ÇÇ ‚ü®i.1, i.2.1‚ü©, i.2.2‚ü© = r i\n  /-- a map `I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÉ` -/\n  p‚ÇÇ‚ÇÉ : I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÉ\n  hp‚ÇÇ‚ÇÉ (i : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) : œÄ ‚ü®i.1, p‚ÇÇ‚ÇÉ i.2‚ü© = r i\n  h‚ÇÅ (i‚ÇÅ : I‚ÇÅ) : p‚ÇÅ‚ÇÇ (i‚ÇÅ, 0) = i‚ÇÅ\n  h‚ÇÉ (i‚ÇÉ : I‚ÇÉ) : p‚ÇÇ‚ÇÉ (0, i‚ÇÉ) = i‚ÇÉ\n\n"}
{"name":"CategoryTheory.GradedObject.TriangleIndexData.r_zero","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"I‚ÇÅ : Type u_1\nI‚ÇÇ : Type u_2\nI‚ÇÉ : Type u_3\nJ : Type u_4\ninst‚úù : Zero I‚ÇÇ\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÄ : Prod I‚ÇÅ I‚ÇÉ ‚Üí J\nœÑ : CategoryTheory.GradedObject.TriangleIndexData r œÄ\ni‚ÇÅ : I‚ÇÅ\ni‚ÇÉ : I‚ÇÉ\n‚ä¢ Eq (r { fst := i‚ÇÅ, snd := { fst := 0, snd := i‚ÇÉ } }) (œÄ { fst := i‚ÇÅ, snd := i‚ÇÉ })","decl":"lemma r_zero (i‚ÇÅ : I‚ÇÅ) (i‚ÇÉ : I‚ÇÉ) : r ‚ü®i‚ÇÅ, 0, i‚ÇÉ‚ü© = œÄ ‚ü®i‚ÇÅ, i‚ÇÉ‚ü© := by\n  rw [‚Üê œÑ.hp‚ÇÇ‚ÇÉ, œÑ.h‚ÇÉ i‚ÇÉ]\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctor_triangle","module":"Mathlib.CategoryTheory.GradedObject.Unitor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nD : Type u_4\nI‚ÇÅ : Type u_5\nI‚ÇÇ : Type u_6\nI‚ÇÉ : Type u_7\nJ : Type u_8\ninst‚úù¬π‚Åµ : CategoryTheory.Category.{u_12, u_1} C‚ÇÅ\ninst‚úù¬π‚Å¥ : CategoryTheory.Category.{u_11, u_2} C‚ÇÇ\ninst‚úù¬π¬≥ : CategoryTheory.Category.{u_10, u_3} C‚ÇÉ\ninst‚úù¬π¬≤ : CategoryTheory.Category.{u_9, u_4} D\ninst‚úù¬π¬π : Zero I‚ÇÇ\ninst‚úù¬π‚Å∞ : DecidableEq I‚ÇÇ\ninst‚úù‚Åπ : CategoryTheory.Limits.HasInitial C‚ÇÇ\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ C‚ÇÅ)\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÉ)\nG : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÉ D)\nassociator : CategoryTheory.Iso (CategoryTheory.bifunctorComp‚ÇÅ‚ÇÇ F‚ÇÅ G) (CategoryTheory.bifunctorComp‚ÇÇ‚ÇÉ G F‚ÇÇ)\nX‚ÇÇ : C‚ÇÇ\ne‚ÇÅ : CategoryTheory.Iso (F‚ÇÅ.flip.obj X‚ÇÇ) (CategoryTheory.Functor.id C‚ÇÅ)\ne‚ÇÇ : CategoryTheory.Iso (F‚ÇÇ.obj X‚ÇÇ) (CategoryTheory.Functor.id C‚ÇÉ)\ninst‚úù‚Å∏ : ‚àÄ (X‚ÇÅ : C‚ÇÅ), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C‚ÇÇ) (F‚ÇÅ.obj X‚ÇÅ)\ninst‚úù‚Å∑ : ‚àÄ (X‚ÇÉ : C‚ÇÉ), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C‚ÇÇ) (F‚ÇÇ.flip.obj X‚ÇÉ)\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÄ : Prod I‚ÇÅ I‚ÇÉ ‚Üí J\nœÑ : CategoryTheory.GradedObject.TriangleIndexData r œÄ\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ninst‚úù‚Å∂ : (((CategoryTheory.GradedObject.mapBifunctor F‚ÇÅ I‚ÇÅ I‚ÇÇ).obj X‚ÇÅ).obj ((CategoryTheory.GradedObject.single‚ÇÄ I‚ÇÇ).obj X‚ÇÇ)).HasMap œÑ.p‚ÇÅ‚ÇÇ\ninst‚úù‚Åµ : (((CategoryTheory.GradedObject.mapBifunctor G I‚ÇÅ I‚ÇÉ).obj (CategoryTheory.GradedObject.mapBifunctorMapObj F‚ÇÅ œÑ.p‚ÇÅ‚ÇÇ X‚ÇÅ ((CategoryTheory.GradedObject.single‚ÇÄ I‚ÇÇ).obj X‚ÇÇ))).obj X‚ÇÉ).HasMap œÄ\ninst‚úù‚Å¥ : (((CategoryTheory.GradedObject.mapBifunctor F‚ÇÇ I‚ÇÇ I‚ÇÉ).obj ((CategoryTheory.GradedObject.single‚ÇÄ I‚ÇÇ).obj X‚ÇÇ)).obj X‚ÇÉ).HasMap œÑ.p‚ÇÇ‚ÇÉ\ninst‚úù¬≥ : (((CategoryTheory.GradedObject.mapBifunctor G I‚ÇÅ I‚ÇÉ).obj X‚ÇÅ).obj (CategoryTheory.GradedObject.mapBifunctorMapObj F‚ÇÇ œÑ.p‚ÇÇ‚ÇÉ ((CategoryTheory.GradedObject.single‚ÇÄ I‚ÇÇ).obj X‚ÇÇ) X‚ÇÉ)).HasMap œÄ\ninst‚úù¬≤ : CategoryTheory.GradedObject.HasGoodTrifunctor‚ÇÅ‚ÇÇObj F‚ÇÅ G œÑ.œÅ‚ÇÅ‚ÇÇ X‚ÇÅ ((CategoryTheory.GradedObject.single‚ÇÄ I‚ÇÇ).obj X‚ÇÇ) X‚ÇÉ\ninst‚úù¬π : CategoryTheory.GradedObject.HasGoodTrifunctor‚ÇÇ‚ÇÉObj G F‚ÇÇ œÑ.œÅ‚ÇÇ‚ÇÉ X‚ÇÅ ((CategoryTheory.GradedObject.single‚ÇÄ I‚ÇÇ).obj X‚ÇÇ) X‚ÇÉ\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor G I‚ÇÅ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÉ).HasMap œÄ\ntriangle : ‚àÄ (X‚ÇÅ : C‚ÇÅ) (X‚ÇÉ : C‚ÇÉ), Eq (CategoryTheory.CategoryStruct.comp (((associator.hom.app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ) ((G.obj X‚ÇÅ).map (e‚ÇÇ.hom.app X‚ÇÉ))) ((G.map (e‚ÇÅ.hom.app X‚ÇÅ)).app X‚ÇÉ)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorAssociator associator œÑ.œÅ‚ÇÅ‚ÇÇ œÑ.œÅ‚ÇÇ‚ÇÉ X‚ÇÅ ((CategoryTheory.GradedObject.single‚ÇÄ I‚ÇÇ).obj X‚ÇÇ) X‚ÇÉ).hom (CategoryTheory.GradedObject.mapBifunctorMapMap G œÄ (CategoryTheory.CategoryStruct.id X‚ÇÅ) (CategoryTheory.GradedObject.mapBifunctorLeftUnitor F‚ÇÇ X‚ÇÇ e‚ÇÇ œÑ.p‚ÇÇ‚ÇÉ ‚ãØ X‚ÇÉ).hom)) (CategoryTheory.GradedObject.mapBifunctorMapMap G œÄ (CategoryTheory.GradedObject.mapBifunctorRightUnitor F‚ÇÅ X‚ÇÇ e‚ÇÅ œÑ.p‚ÇÅ‚ÇÇ ‚ãØ X‚ÇÅ).hom (CategoryTheory.CategoryStruct.id X‚ÇÉ))","decl":"lemma mapBifunctor_triangle\n    (triangle : ‚àÄ (X‚ÇÅ : C‚ÇÅ) (X‚ÇÉ : C‚ÇÉ), ((associator.hom.app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ ‚â´\n    (G.obj X‚ÇÅ).map (e‚ÇÇ.hom.app X‚ÇÉ) = (G.map (e‚ÇÅ.hom.app X‚ÇÅ)).app X‚ÇÉ) :\n    (mapBifunctorAssociator associator œÑ.œÅ‚ÇÅ‚ÇÇ œÑ.œÅ‚ÇÇ‚ÇÉ X‚ÇÅ ((single‚ÇÄ I‚ÇÇ).obj X‚ÇÇ) X‚ÇÉ).hom ‚â´\n    mapBifunctorMapMap G œÄ (ùüô X‚ÇÅ) (mapBifunctorLeftUnitor F‚ÇÇ X‚ÇÇ e‚ÇÇ œÑ.p‚ÇÇ‚ÇÉ œÑ.h‚ÇÉ X‚ÇÉ).hom =\n      mapBifunctorMapMap G œÄ (mapBifunctorRightUnitor F‚ÇÅ X‚ÇÇ e‚ÇÅ œÑ.p‚ÇÅ‚ÇÇ œÑ.h‚ÇÅ X‚ÇÅ).hom (ùüô X‚ÇÉ) := by\n  rw [‚Üê cancel_epi ((mapBifunctorMapMap G œÄ\n    (mapBifunctorRightUnitor F‚ÇÅ X‚ÇÇ e‚ÇÅ œÑ.p‚ÇÅ‚ÇÇ œÑ.h‚ÇÅ X‚ÇÅ).inv (ùüô X‚ÇÉ)))]\n  ext j i‚ÇÅ i‚ÇÉ hj\n  simp only [categoryOfGradedObjects_comp, Œπ_mapBifunctorMapMap_assoc,\n    mapBifunctorRightUnitor_inv_apply, Functor.id_obj, Functor.flip_obj_obj, Functor.map_comp,\n    NatTrans.comp_app, categoryOfGradedObjects_id, Functor.map_id, id_comp, assoc,\n    Œπ_mapBifunctorMapMap]\n  congr 2\n  rw [‚Üê ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj_eq_assoc F‚ÇÅ G œÑ.œÅ‚ÇÅ‚ÇÇ _ _ _ i‚ÇÅ 0 i‚ÇÉ j\n    (by rw [œÑ.r_zero, hj]) i‚ÇÅ (by simp), Œπ_mapBifunctorAssociator_hom_assoc,\n    ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj_eq_assoc G F‚ÇÇ œÑ.œÅ‚ÇÇ‚ÇÉ _ _ _ i‚ÇÅ 0 i‚ÇÉ j\n    (by rw [œÑ.r_zero, hj]) i‚ÇÉ (by simp), Œπ_mapBifunctorMapMap]\n  dsimp\n  rw [Functor.map_id, NatTrans.id_app, id_comp,\n    ‚Üê Functor.map_comp_assoc, ‚Üê NatTrans.comp_app_assoc, ‚Üê Functor.map_comp,\n    Œπ_mapBifunctorLeftUnitor_hom_apply F‚ÇÇ X‚ÇÇ e‚ÇÇ œÑ.p‚ÇÇ‚ÇÉ œÑ.h‚ÇÉ X‚ÇÉ i‚ÇÉ,\n    Œπ_mapBifunctorRightUnitor_hom_apply F‚ÇÅ X‚ÇÇ e‚ÇÅ œÑ.p‚ÇÅ‚ÇÇ œÑ.h‚ÇÅ X‚ÇÅ i‚ÇÅ]\n  dsimp\n  simp only [Functor.map_comp, NatTrans.comp_app, ‚Üê triangle (X‚ÇÅ i‚ÇÅ) (X‚ÇÉ i‚ÇÉ), ‚Üê assoc]\n  congr 2\n  symm\n  apply NatTrans.naturality_app (associator.hom.app (X‚ÇÅ i‚ÇÅ))\n\n"}
