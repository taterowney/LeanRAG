{"name":"QuaternionAlgebra.Basis.mk.injEq","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nc₁ c₂ c₃ : R\ni✝ j✝ k✝ : A\ni_mul_i✝ : Eq (HMul.hMul i✝ i✝) (HAdd.hAdd (HSMul.hSMul c₁ 1) (HSMul.hSMul c₂ i✝))\nj_mul_j✝ : Eq (HMul.hMul j✝ j✝) (HSMul.hSMul c₃ 1)\ni_mul_j✝ : Eq (HMul.hMul i✝ j✝) k✝\nj_mul_i✝ : Eq (HMul.hMul j✝ i✝) (HSub.hSub (HSMul.hSMul c₂ j✝) k✝)\ni j k : A\ni_mul_i : Eq (HMul.hMul i i) (HAdd.hAdd (HSMul.hSMul c₁ 1) (HSMul.hSMul c₂ i))\nj_mul_j : Eq (HMul.hMul j j) (HSMul.hSMul c₃ 1)\ni_mul_j : Eq (HMul.hMul i j) k\nj_mul_i : Eq (HMul.hMul j i) (HSub.hSub (HSMul.hSMul c₂ j) k)\n⊢ Eq (Eq { i := i✝, j := j✝, k := k✝, i_mul_i := i_mul_i✝, j_mul_j := j_mul_j✝, i_mul_j := i_mul_j✝, j_mul_i := j_mul_i✝ } { i := i, j := j, k := k, i_mul_i := i_mul_i, j_mul_j := j_mul_j, i_mul_j := i_mul_j, j_mul_i := j_mul_i }) (And (Eq i✝ i) (And (Eq j✝ j) (Eq k✝ k)))","decl":"/-- A quaternion basis contains the information both sufficient and necessary to construct an\n`R`-algebra homomorphism from `ℍ[R,c₁,c₂,c₃]` to `A`; or equivalently, a surjective\n`R`-algebra homomorphism from `ℍ[R,c₁,c₂,c₃]` to an `R`-subalgebra of `A`.\n\nNote that for definitional convenience, `k` is provided as a field even though `i_mul_j` fully\ndetermines it. -/\nstructure Basis {R : Type*} (A : Type*) [CommRing R] [Ring A] [Algebra R A] (c₁ c₂ c₃ : R) where\n  (i j k : A)\n  i_mul_i : i * i = c₁ • (1 : A) + c₂ • i\n  j_mul_j : j * j = c₃ • (1 : A)\n  i_mul_j : i * j = k\n  j_mul_i : j * i = c₂ • j - k\n\n"}
{"name":"QuaternionAlgebra.Basis.i_mul_i","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nc₁ c₂ c₃ : R\nself : QuaternionAlgebra.Basis A c₁ c₂ c₃\n⊢ Eq (HMul.hMul self.i self.i) (HAdd.hAdd (HSMul.hSMul c₁ 1) (HSMul.hSMul c₂ self.i))","decl":"/-- A quaternion basis contains the information both sufficient and necessary to construct an\n`R`-algebra homomorphism from `ℍ[R,c₁,c₂,c₃]` to `A`; or equivalently, a surjective\n`R`-algebra homomorphism from `ℍ[R,c₁,c₂,c₃]` to an `R`-subalgebra of `A`.\n\nNote that for definitional convenience, `k` is provided as a field even though `i_mul_j` fully\ndetermines it. -/\nstructure Basis {R : Type*} (A : Type*) [CommRing R] [Ring A] [Algebra R A] (c₁ c₂ c₃ : R) where\n  (i j k : A)\n  i_mul_i : i * i = c₁ • (1 : A) + c₂ • i\n  j_mul_j : j * j = c₃ • (1 : A)\n  i_mul_j : i * j = k\n  j_mul_i : j * i = c₂ • j - k\n\n"}
{"name":"QuaternionAlgebra.Basis.mk.inj","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nc₁ c₂ c₃ : R\ni✝ j✝ k✝ : A\ni_mul_i✝ : Eq (HMul.hMul i✝ i✝) (HAdd.hAdd (HSMul.hSMul c₁ 1) (HSMul.hSMul c₂ i✝))\nj_mul_j✝ : Eq (HMul.hMul j✝ j✝) (HSMul.hSMul c₃ 1)\ni_mul_j✝ : Eq (HMul.hMul i✝ j✝) k✝\nj_mul_i✝ : Eq (HMul.hMul j✝ i✝) (HSub.hSub (HSMul.hSMul c₂ j✝) k✝)\ni j k : A\ni_mul_i : Eq (HMul.hMul i i) (HAdd.hAdd (HSMul.hSMul c₁ 1) (HSMul.hSMul c₂ i))\nj_mul_j : Eq (HMul.hMul j j) (HSMul.hSMul c₃ 1)\ni_mul_j : Eq (HMul.hMul i j) k\nj_mul_i : Eq (HMul.hMul j i) (HSub.hSub (HSMul.hSMul c₂ j) k)\nx✝ : Eq { i := i✝, j := j✝, k := k✝, i_mul_i := i_mul_i✝, j_mul_j := j_mul_j✝, i_mul_j := i_mul_j✝, j_mul_i := j_mul_i✝ } { i := i, j := j, k := k, i_mul_i := i_mul_i, j_mul_j := j_mul_j, i_mul_j := i_mul_j, j_mul_i := j_mul_i }\n⊢ And (Eq i✝ i) (And (Eq j✝ j) (Eq k✝ k))","decl":"/-- A quaternion basis contains the information both sufficient and necessary to construct an\n`R`-algebra homomorphism from `ℍ[R,c₁,c₂,c₃]` to `A`; or equivalently, a surjective\n`R`-algebra homomorphism from `ℍ[R,c₁,c₂,c₃]` to an `R`-subalgebra of `A`.\n\nNote that for definitional convenience, `k` is provided as a field even though `i_mul_j` fully\ndetermines it. -/\nstructure Basis {R : Type*} (A : Type*) [CommRing R] [Ring A] [Algebra R A] (c₁ c₂ c₃ : R) where\n  (i j k : A)\n  i_mul_i : i * i = c₁ • (1 : A) + c₂ • i\n  j_mul_j : j * j = c₃ • (1 : A)\n  i_mul_j : i * j = k\n  j_mul_i : j * i = c₂ • j - k\n\n"}
{"name":"QuaternionAlgebra.Basis.i_mul_j","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nc₁ c₂ c₃ : R\nself : QuaternionAlgebra.Basis A c₁ c₂ c₃\n⊢ Eq (HMul.hMul self.i self.j) self.k","decl":"/-- A quaternion basis contains the information both sufficient and necessary to construct an\n`R`-algebra homomorphism from `ℍ[R,c₁,c₂,c₃]` to `A`; or equivalently, a surjective\n`R`-algebra homomorphism from `ℍ[R,c₁,c₂,c₃]` to an `R`-subalgebra of `A`.\n\nNote that for definitional convenience, `k` is provided as a field even though `i_mul_j` fully\ndetermines it. -/\nstructure Basis {R : Type*} (A : Type*) [CommRing R] [Ring A] [Algebra R A] (c₁ c₂ c₃ : R) where\n  (i j k : A)\n  i_mul_i : i * i = c₁ • (1 : A) + c₂ • i\n  j_mul_j : j * j = c₃ • (1 : A)\n  i_mul_j : i * j = k\n  j_mul_i : j * i = c₂ • j - k\n\n"}
{"name":"QuaternionAlgebra.Basis.j_mul_j","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nc₁ c₂ c₃ : R\nself : QuaternionAlgebra.Basis A c₁ c₂ c₃\n⊢ Eq (HMul.hMul self.j self.j) (HSMul.hSMul c₃ 1)","decl":"/-- A quaternion basis contains the information both sufficient and necessary to construct an\n`R`-algebra homomorphism from `ℍ[R,c₁,c₂,c₃]` to `A`; or equivalently, a surjective\n`R`-algebra homomorphism from `ℍ[R,c₁,c₂,c₃]` to an `R`-subalgebra of `A`.\n\nNote that for definitional convenience, `k` is provided as a field even though `i_mul_j` fully\ndetermines it. -/\nstructure Basis {R : Type*} (A : Type*) [CommRing R] [Ring A] [Algebra R A] (c₁ c₂ c₃ : R) where\n  (i j k : A)\n  i_mul_i : i * i = c₁ • (1 : A) + c₂ • i\n  j_mul_j : j * j = c₃ • (1 : A)\n  i_mul_j : i * j = k\n  j_mul_i : j * i = c₂ • j - k\n\n"}
{"name":"QuaternionAlgebra.Basis.j_mul_i","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nc₁ c₂ c₃ : R\nself : QuaternionAlgebra.Basis A c₁ c₂ c₃\n⊢ Eq (HMul.hMul self.j self.i) (HSub.hSub (HSMul.hSMul c₂ self.j) self.k)","decl":"/-- A quaternion basis contains the information both sufficient and necessary to construct an\n`R`-algebra homomorphism from `ℍ[R,c₁,c₂,c₃]` to `A`; or equivalently, a surjective\n`R`-algebra homomorphism from `ℍ[R,c₁,c₂,c₃]` to an `R`-subalgebra of `A`.\n\nNote that for definitional convenience, `k` is provided as a field even though `i_mul_j` fully\ndetermines it. -/\nstructure Basis {R : Type*} (A : Type*) [CommRing R] [Ring A] [Algebra R A] (c₁ c₂ c₃ : R) where\n  (i j k : A)\n  i_mul_i : i * i = c₁ • (1 : A) + c₂ • i\n  j_mul_j : j * j = c₃ • (1 : A)\n  i_mul_j : i * j = k\n  j_mul_i : j * i = c₂ • j - k\n\n"}
{"name":"QuaternionAlgebra.Basis.mk.sizeOf_spec","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : Ring A\ninst✝² : Algebra R A\nc₁ c₂ c₃ : R\ninst✝¹ : SizeOf R\ninst✝ : SizeOf A\ni j k : A\ni_mul_i : Eq (HMul.hMul i i) (HAdd.hAdd (HSMul.hSMul c₁ 1) (HSMul.hSMul c₂ i))\nj_mul_j : Eq (HMul.hMul j j) (HSMul.hSMul c₃ 1)\ni_mul_j : Eq (HMul.hMul i j) k\nj_mul_i : Eq (HMul.hMul j i) (HSub.hSub (HSMul.hSMul c₂ j) k)\n⊢ Eq (SizeOf.sizeOf { i := i, j := j, k := k, i_mul_i := i_mul_i, j_mul_j := j_mul_j, i_mul_j := i_mul_j, j_mul_i := j_mul_i }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf i)) (SizeOf.sizeOf j)) (SizeOf.sizeOf k)) (SizeOf.sizeOf i_mul_i)) (SizeOf.sizeOf j_mul_j)) (SizeOf.sizeOf i_mul_j)) (SizeOf.sizeOf j_mul_i))","decl":"/-- A quaternion basis contains the information both sufficient and necessary to construct an\n`R`-algebra homomorphism from `ℍ[R,c₁,c₂,c₃]` to `A`; or equivalently, a surjective\n`R`-algebra homomorphism from `ℍ[R,c₁,c₂,c₃]` to an `R`-subalgebra of `A`.\n\nNote that for definitional convenience, `k` is provided as a field even though `i_mul_j` fully\ndetermines it. -/\nstructure Basis {R : Type*} (A : Type*) [CommRing R] [Ring A] [Algebra R A] (c₁ c₂ c₃ : R) where\n  (i j k : A)\n  i_mul_i : i * i = c₁ • (1 : A) + c₂ • i\n  j_mul_j : j * j = c₃ • (1 : A)\n  i_mul_j : i * j = k\n  j_mul_i : j * i = c₂ • j - k\n\n"}
{"name":"QuaternionAlgebra.Basis.ext","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nc₁ c₂ c₃ : R\nq₁ q₂ : QuaternionAlgebra.Basis A c₁ c₂ c₃\nhi : Eq q₁.i q₂.i\nhj : Eq q₁.j q₂.j\n⊢ Eq q₁ q₂","decl":"/-- Since `k` is redundant, it is not necessary to show `q₁.k = q₂.k` when showing `q₁ = q₂`. -/\n@[ext]\nprotected theorem ext ⦃q₁ q₂ : Basis A c₁ c₂ c₃⦄ (hi : q₁.i = q₂.i)\n    (hj : q₁.j = q₂.j) : q₁ = q₂ := by\n  cases q₁; rename_i q₁_i_mul_j _\n  cases q₂; rename_i q₂_i_mul_j _\n  congr\n  rw [← q₁_i_mul_j, ← q₂_i_mul_j]\n  congr\n\n"}
{"name":"QuaternionAlgebra.Basis.ext_iff","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nc₁ c₂ c₃ : R\nq₁ q₂ : QuaternionAlgebra.Basis A c₁ c₂ c₃\n⊢ Iff (Eq q₁ q₂) (And (Eq q₁.i q₂.i) (Eq q₁.j q₂.j))","decl":"/-- Since `k` is redundant, it is not necessary to show `q₁.k = q₂.k` when showing `q₁ = q₂`. -/\n@[ext]\nprotected theorem ext ⦃q₁ q₂ : Basis A c₁ c₂ c₃⦄ (hi : q₁.i = q₂.i)\n    (hj : q₁.j = q₂.j) : q₁ = q₂ := by\n  cases q₁; rename_i q₁_i_mul_j _\n  cases q₂; rename_i q₂_i_mul_j _\n  congr\n  rw [← q₁_i_mul_j, ← q₂_i_mul_j]\n  congr\n\n"}
{"name":"QuaternionAlgebra.Basis.self_j","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nc₁ c₂ c₃ : R\n⊢ Eq (QuaternionAlgebra.Basis.self R).j { re := 0, imI := 0, imJ := 1, imK := 0 }","decl":"/-- There is a natural quaternionic basis for the `QuaternionAlgebra`. -/\n@[simps i j k]\nprotected def self : Basis ℍ[R,c₁,c₂,c₃] c₁ c₂ c₃ where\n  i := ⟨0, 1, 0, 0⟩\n  i_mul_i := by ext <;> simp\n  j := ⟨0, 0, 1, 0⟩\n  j_mul_j := by ext <;> simp\n  k := ⟨0, 0, 0, 1⟩\n  i_mul_j := by ext <;> simp\n  j_mul_i := by ext <;> simp\n\n"}
{"name":"QuaternionAlgebra.Basis.self_i","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nc₁ c₂ c₃ : R\n⊢ Eq (QuaternionAlgebra.Basis.self R).i { re := 0, imI := 1, imJ := 0, imK := 0 }","decl":"/-- There is a natural quaternionic basis for the `QuaternionAlgebra`. -/\n@[simps i j k]\nprotected def self : Basis ℍ[R,c₁,c₂,c₃] c₁ c₂ c₃ where\n  i := ⟨0, 1, 0, 0⟩\n  i_mul_i := by ext <;> simp\n  j := ⟨0, 0, 1, 0⟩\n  j_mul_j := by ext <;> simp\n  k := ⟨0, 0, 0, 1⟩\n  i_mul_j := by ext <;> simp\n  j_mul_i := by ext <;> simp\n\n"}
{"name":"QuaternionAlgebra.Basis.self_k","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nc₁ c₂ c₃ : R\n⊢ Eq (QuaternionAlgebra.Basis.self R).k { re := 0, imI := 0, imJ := 0, imK := 1 }","decl":"/-- There is a natural quaternionic basis for the `QuaternionAlgebra`. -/\n@[simps i j k]\nprotected def self : Basis ℍ[R,c₁,c₂,c₃] c₁ c₂ c₃ where\n  i := ⟨0, 1, 0, 0⟩\n  i_mul_i := by ext <;> simp\n  j := ⟨0, 0, 1, 0⟩\n  j_mul_j := by ext <;> simp\n  k := ⟨0, 0, 0, 1⟩\n  i_mul_j := by ext <;> simp\n  j_mul_i := by ext <;> simp\n\n"}
{"name":"QuaternionAlgebra.Basis.i_mul_k","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nc₁ c₂ c₃ : R\nq : QuaternionAlgebra.Basis A c₁ c₂ c₃\n⊢ Eq (HMul.hMul q.i q.k) (HAdd.hAdd (HSMul.hSMul c₁ q.j) (HSMul.hSMul c₂ q.k))","decl":"@[simp]\ntheorem i_mul_k : q.i * q.k = c₁ • q.j + c₂ • q.k := by\n  rw [← i_mul_j, ← mul_assoc, i_mul_i, add_mul, smul_mul_assoc, one_mul, smul_mul_assoc]\n\n"}
{"name":"QuaternionAlgebra.Basis.k_mul_i","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nc₁ c₂ c₃ : R\nq : QuaternionAlgebra.Basis A c₁ c₂ c₃\n⊢ Eq (HMul.hMul q.k q.i) (HSMul.hSMul (Neg.neg c₁) q.j)","decl":"@[simp]\ntheorem k_mul_i : q.k * q.i = -c₁ • q.j := by\n  rw [← i_mul_j, mul_assoc, j_mul_i, mul_sub, i_mul_k, neg_smul, mul_smul_comm, i_mul_j]\n  linear_combination (norm := module)\n\n"}
{"name":"QuaternionAlgebra.Basis.k_mul_j","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nc₁ c₂ c₃ : R\nq : QuaternionAlgebra.Basis A c₁ c₂ c₃\n⊢ Eq (HMul.hMul q.k q.j) (HSMul.hSMul c₃ q.i)","decl":"@[simp]\ntheorem k_mul_j : q.k * q.j = c₃ • q.i := by\n  rw [← i_mul_j, mul_assoc, j_mul_j, mul_smul_comm, mul_one]\n\n"}
{"name":"QuaternionAlgebra.Basis.j_mul_k","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nc₁ c₂ c₃ : R\nq : QuaternionAlgebra.Basis A c₁ c₂ c₃\n⊢ Eq (HMul.hMul q.j q.k) (HSub.hSub (HSMul.hSMul (HMul.hMul c₂ c₃) 1) (HSMul.hSMul c₃ q.i))","decl":"@[simp]\ntheorem j_mul_k : q.j * q.k = (c₂ * c₃) • 1 - c₃ • q.i := by\n  rw [← i_mul_j, ← mul_assoc, j_mul_i, sub_mul, smul_mul_assoc, j_mul_j, ← smul_assoc, k_mul_j]\n  rfl\n\n"}
{"name":"QuaternionAlgebra.Basis.k_mul_k","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nc₁ c₂ c₃ : R\nq : QuaternionAlgebra.Basis A c₁ c₂ c₃\n⊢ Eq (HMul.hMul q.k q.k) (Neg.neg (HSMul.hSMul (HMul.hMul c₁ c₃) 1))","decl":"@[simp]\ntheorem k_mul_k : q.k * q.k = -((c₁ * c₃) • (1 : A)) := by\n  rw [← i_mul_j, mul_assoc, ← mul_assoc q.j _ _, j_mul_i, ← i_mul_j, ← mul_assoc, mul_sub, ←\n    mul_assoc, i_mul_i, add_mul, smul_mul_assoc, one_mul, sub_mul, smul_mul_assoc, mul_smul_comm,\n    smul_mul_assoc, mul_assoc, j_mul_j, add_mul, smul_mul_assoc, j_mul_j, smul_smul,\n    smul_mul_assoc, mul_assoc, j_mul_j]\n  linear_combination (norm := module)\n\n\n"}
{"name":"QuaternionAlgebra.Basis.lift_zero","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nc₁ c₂ c₃ : R\nq : QuaternionAlgebra.Basis A c₁ c₂ c₃\n⊢ Eq (q.lift 0) 0","decl":"theorem lift_zero : q.lift (0 : ℍ[R,c₁,c₂,c₃]) = 0 := by simp [lift]\n\n"}
{"name":"QuaternionAlgebra.Basis.lift_one","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nc₁ c₂ c₃ : R\nq : QuaternionAlgebra.Basis A c₁ c₂ c₃\n⊢ Eq (q.lift 1) 1","decl":"theorem lift_one : q.lift (1 : ℍ[R,c₁,c₂,c₃]) = 1 := by simp [lift]\n\n"}
{"name":"QuaternionAlgebra.Basis.lift_add","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nc₁ c₂ c₃ : R\nq : QuaternionAlgebra.Basis A c₁ c₂ c₃\nx y : QuaternionAlgebra R c₁ c₂ c₃\n⊢ Eq (q.lift (HAdd.hAdd x y)) (HAdd.hAdd (q.lift x) (q.lift y))","decl":"theorem lift_add (x y : ℍ[R,c₁,c₂,c₃]) : q.lift (x + y) = q.lift x + q.lift y := by\n  simp only [lift, add_re, map_add, add_imI, add_smul, add_imJ, add_imK]\n  abel\n\n"}
{"name":"QuaternionAlgebra.Basis.lift_mul","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nc₁ c₂ c₃ : R\nq : QuaternionAlgebra.Basis A c₁ c₂ c₃\nx y : QuaternionAlgebra R c₁ c₂ c₃\n⊢ Eq (q.lift (HMul.hMul x y)) (HMul.hMul (q.lift x) (q.lift y))","decl":"theorem lift_mul (x y : ℍ[R,c₁,c₂,c₃]) : q.lift (x * y) = q.lift x * q.lift y := by\n  simp only [lift, Algebra.algebraMap_eq_smul_one]\n  simp_rw [add_mul, mul_add, smul_mul_assoc, mul_smul_comm, one_mul, mul_one, smul_smul]\n  simp only [i_mul_i, j_mul_j, i_mul_j, j_mul_i, i_mul_k, k_mul_i, k_mul_j, j_mul_k, k_mul_k]\n  simp only [smul_smul, smul_neg, sub_eq_add_neg, add_smul, ← add_assoc, mul_neg, neg_smul]\n  simp only [mul_right_comm _ _ (c₁ * c₃), mul_comm _ (c₁ * c₃)]\n  simp only [mul_comm _ c₁, mul_right_comm _ _ c₁]\n  simp only [mul_comm _ c₂, mul_right_comm _ _ c₃]\n  simp only [← mul_comm c₁ c₂, ← mul_assoc]\n  simp only [mul_re, sub_eq_add_neg, add_smul, neg_smul, mul_imI, ← add_assoc, mul_imJ, mul_imK]\n  linear_combination (norm := module)\n\n"}
{"name":"QuaternionAlgebra.Basis.lift_smul","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nc₁ c₂ c₃ : R\nq : QuaternionAlgebra.Basis A c₁ c₂ c₃\nr : R\nx : QuaternionAlgebra R c₁ c₂ c₃\n⊢ Eq (q.lift (HSMul.hSMul r x)) (HSMul.hSMul r (q.lift x))","decl":"theorem lift_smul (r : R) (x : ℍ[R,c₁,c₂,c₃]) : q.lift (r • x) = r • q.lift x := by\n  simp [lift, mul_smul, ← Algebra.smul_def]\n\n"}
{"name":"QuaternionAlgebra.Basis.liftHom_apply","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nc₁ c₂ c₃ : R\nq : QuaternionAlgebra.Basis A c₁ c₂ c₃\na : QuaternionAlgebra R c₁ c₂ c₃\n⊢ Eq (q.liftHom a) (q.lift a)","decl":"/-- A `QuaternionAlgebra.Basis` implies an `AlgHom` from the quaternions. -/\n@[simps!]\ndef liftHom : ℍ[R,c₁,c₂,c₃] →ₐ[R] A :=\n  AlgHom.mk'\n    { toFun := q.lift\n      map_zero' := q.lift_zero\n      map_one' := q.lift_one\n      map_add' := q.lift_add\n      map_mul' := q.lift_mul } q.lift_smul\n\n"}
{"name":"QuaternionAlgebra.Basis.compHom_i","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : Ring A\ninst✝² : Ring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nc₁ c₂ c₃ : R\nq : QuaternionAlgebra.Basis A c₁ c₂ c₃\nF : AlgHom R A B\n⊢ Eq (q.compHom F).i (F q.i)","decl":"/-- Transform a `QuaternionAlgebra.Basis` through an `AlgHom`. -/\n@[simps i j k]\ndef compHom (F : A →ₐ[R] B) : Basis B c₁ c₂ c₃ where\n  i := F q.i\n  i_mul_i := by rw [← map_mul, q.i_mul_i, map_add, map_smul, map_smul, map_one]\n  j := F q.j\n  j_mul_j := by rw [← map_mul, q.j_mul_j, map_smul, map_one]\n  k := F q.k\n  i_mul_j := by rw [← map_mul, q.i_mul_j]\n  j_mul_i := by rw [← map_mul, q.j_mul_i, map_sub, map_smul]\n\n"}
{"name":"QuaternionAlgebra.Basis.compHom_j","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : Ring A\ninst✝² : Ring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nc₁ c₂ c₃ : R\nq : QuaternionAlgebra.Basis A c₁ c₂ c₃\nF : AlgHom R A B\n⊢ Eq (q.compHom F).j (F q.j)","decl":"/-- Transform a `QuaternionAlgebra.Basis` through an `AlgHom`. -/\n@[simps i j k]\ndef compHom (F : A →ₐ[R] B) : Basis B c₁ c₂ c₃ where\n  i := F q.i\n  i_mul_i := by rw [← map_mul, q.i_mul_i, map_add, map_smul, map_smul, map_one]\n  j := F q.j\n  j_mul_j := by rw [← map_mul, q.j_mul_j, map_smul, map_one]\n  k := F q.k\n  i_mul_j := by rw [← map_mul, q.i_mul_j]\n  j_mul_i := by rw [← map_mul, q.j_mul_i, map_sub, map_smul]\n\n"}
{"name":"QuaternionAlgebra.Basis.compHom_k","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : Ring A\ninst✝² : Ring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nc₁ c₂ c₃ : R\nq : QuaternionAlgebra.Basis A c₁ c₂ c₃\nF : AlgHom R A B\n⊢ Eq (q.compHom F).k (F q.k)","decl":"/-- Transform a `QuaternionAlgebra.Basis` through an `AlgHom`. -/\n@[simps i j k]\ndef compHom (F : A →ₐ[R] B) : Basis B c₁ c₂ c₃ where\n  i := F q.i\n  i_mul_i := by rw [← map_mul, q.i_mul_i, map_add, map_smul, map_smul, map_one]\n  j := F q.j\n  j_mul_j := by rw [← map_mul, q.j_mul_j, map_smul, map_one]\n  k := F q.k\n  i_mul_j := by rw [← map_mul, q.i_mul_j]\n  j_mul_i := by rw [← map_mul, q.j_mul_i, map_sub, map_smul]\n\n"}
{"name":"QuaternionAlgebra.lift_apply","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nc₁ c₂ c₃ : R\nq : QuaternionAlgebra.Basis A c₁ c₂ c₃\n⊢ Eq (QuaternionAlgebra.lift q) q.liftHom","decl":"/-- A quaternionic basis on `A` is equivalent to a map from the quaternion algebra to `A`. -/\n@[simps]\ndef lift : Basis A c₁ c₂ c₃ ≃ (ℍ[R,c₁,c₂,c₃] →ₐ[R] A) where\n  toFun := Basis.liftHom\n  invFun := (Basis.self R).compHom\n  left_inv q := by ext <;> simp [Basis.lift]\n  right_inv F := by\n    ext\n    dsimp [Basis.lift]\n    rw [← F.commutes]\n    simp only [← F.commutes, ← map_smul, ← map_add, mk_add_mk, smul_mk, smul_zero,\n      algebraMap_eq]\n    congr <;> simp\n\n"}
{"name":"QuaternionAlgebra.lift_symm_apply","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nc₁ c₂ c₃ : R\nF : AlgHom R (QuaternionAlgebra R c₁ c₂ c₃) A\n⊢ Eq (QuaternionAlgebra.lift.symm F) ((QuaternionAlgebra.Basis.self R).compHom F)","decl":"/-- A quaternionic basis on `A` is equivalent to a map from the quaternion algebra to `A`. -/\n@[simps]\ndef lift : Basis A c₁ c₂ c₃ ≃ (ℍ[R,c₁,c₂,c₃] →ₐ[R] A) where\n  toFun := Basis.liftHom\n  invFun := (Basis.self R).compHom\n  left_inv q := by ext <;> simp [Basis.lift]\n  right_inv F := by\n    ext\n    dsimp [Basis.lift]\n    rw [← F.commutes]\n    simp only [← F.commutes, ← map_smul, ← map_add, mk_add_mk, smul_mk, smul_zero,\n      algebraMap_eq]\n    congr <;> simp\n\n"}
{"name":"QuaternionAlgebra.hom_ext","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nc₁ c₂ c₃ : R\nf g : AlgHom R (QuaternionAlgebra R c₁ c₂ c₃) A\nhi : Eq (f (QuaternionAlgebra.Basis.self R).i) (g (QuaternionAlgebra.Basis.self R).i)\nhj : Eq (f (QuaternionAlgebra.Basis.self R).j) (g (QuaternionAlgebra.Basis.self R).j)\n⊢ Eq f g","decl":"/-- Two `R`-algebra morphisms from a quaternion algebra are equal if they agree on `i` and `j`. -/\n@[ext]\ntheorem hom_ext ⦃f g : ℍ[R,c₁,c₂,c₃] →ₐ[R] A⦄\n    (hi : f (Basis.self R).i = g (Basis.self R).i) (hj : f (Basis.self R).j = g (Basis.self R).j) :\n    f = g :=\n  lift.symm.injective <| Basis.ext hi hj\n\n"}
{"name":"QuaternionAlgebra.hom_ext_iff","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nc₁ c₂ c₃ : R\nf g : AlgHom R (QuaternionAlgebra R c₁ c₂ c₃) A\n⊢ Iff (Eq f g) (And (Eq (f (QuaternionAlgebra.Basis.self R).i) (g (QuaternionAlgebra.Basis.self R).i)) (Eq (f (QuaternionAlgebra.Basis.self R).j) (g (QuaternionAlgebra.Basis.self R).j)))","decl":"/-- Two `R`-algebra morphisms from a quaternion algebra are equal if they agree on `i` and `j`. -/\n@[ext]\ntheorem hom_ext ⦃f g : ℍ[R,c₁,c₂,c₃] →ₐ[R] A⦄\n    (hi : f (Basis.self R).i = g (Basis.self R).i) (hj : f (Basis.self R).j = g (Basis.self R).j) :\n    f = g :=\n  lift.symm.injective <| Basis.ext hi hj\n\n"}
{"name":"Quaternion.hom_ext_iff","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nf g : AlgHom R (Quaternion R) A\n⊢ Iff (Eq f g) (And (Eq (f (QuaternionAlgebra.Basis.self R).i) (g (QuaternionAlgebra.Basis.self R).i)) (Eq (f (QuaternionAlgebra.Basis.self R).j) (g (QuaternionAlgebra.Basis.self R).j)))","decl":"/-- Two `R`-algebra morphisms from the quaternions are equal if they agree on `i` and `j`. -/\n@[ext]\ntheorem hom_ext ⦃f g : ℍ[R] →ₐ[R] A⦄\n    (hi : f (Basis.self R).i = g (Basis.self R).i) (hj : f (Basis.self R).j = g (Basis.self R).j) :\n    f = g :=\n  QuaternionAlgebra.hom_ext hi hj\n\n"}
{"name":"Quaternion.hom_ext","module":"Mathlib.Algebra.QuaternionBasis","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nf g : AlgHom R (Quaternion R) A\nhi : Eq (f (QuaternionAlgebra.Basis.self R).i) (g (QuaternionAlgebra.Basis.self R).i)\nhj : Eq (f (QuaternionAlgebra.Basis.self R).j) (g (QuaternionAlgebra.Basis.self R).j)\n⊢ Eq f g","decl":"/-- Two `R`-algebra morphisms from the quaternions are equal if they agree on `i` and `j`. -/\n@[ext]\ntheorem hom_ext ⦃f g : ℍ[R] →ₐ[R] A⦄\n    (hi : f (Basis.self R).i = g (Basis.self R).i) (hj : f (Basis.self R).j = g (Basis.self R).j) :\n    f = g :=\n  QuaternionAlgebra.hom_ext hi hj\n\n"}
