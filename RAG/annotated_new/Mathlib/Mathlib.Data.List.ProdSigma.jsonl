{"name":"List.nil_product","module":"Mathlib.Data.List.ProdSigma","initialProofState":"α : Type u_1\nβ : Type u_2\nl : List β\n⊢ Eq (SProd.sprod List.nil l) List.nil","decl":"@[simp]\ntheorem nil_product (l : List β) : (@nil α) ×ˢ l = [] :=\n  rfl\n\n"}
{"name":"List.product_cons","module":"Mathlib.Data.List.ProdSigma","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\nl₁ : List α\nl₂ : List β\n⊢ Eq (SProd.sprod (List.cons a l₁) l₂) (HAppend.hAppend (List.map (fun b => { fst := a, snd := b }) l₂) (SProd.sprod l₁ l₂))","decl":"@[simp]\ntheorem product_cons (a : α) (l₁ : List α) (l₂ : List β) :\n    (a :: l₁) ×ˢ l₂ = map (fun b => (a, b)) l₂ ++ (l₁ ×ˢ l₂) :=\n  rfl\n\n"}
{"name":"List.product_nil","module":"Mathlib.Data.List.ProdSigma","initialProofState":"α : Type u_1\nβ : Type u_2\nl : List α\n⊢ Eq (SProd.sprod l List.nil) List.nil","decl":"@[simp]\ntheorem product_nil : ∀ l : List α, l ×ˢ (@nil β) = []\n  | [] => rfl\n  | _ :: l => by simp [product_cons, product_nil l]\n\n"}
{"name":"List.mem_product","module":"Mathlib.Data.List.ProdSigma","initialProofState":"α : Type u_1\nβ : Type u_2\nl₁ : List α\nl₂ : List β\na : α\nb : β\n⊢ Iff (Membership.mem (SProd.sprod l₁ l₂) { fst := a, snd := b }) (And (Membership.mem l₁ a) (Membership.mem l₂ b))","decl":"@[simp]\ntheorem mem_product {l₁ : List α} {l₂ : List β} {a : α} {b : β} :\n    (a, b) ∈ l₁ ×ˢ l₂ ↔ a ∈ l₁ ∧ b ∈ l₂ := by\n  simp_all [SProd.sprod, product, mem_flatMap, mem_map, Prod.ext_iff, exists_prop, and_left_comm,\n    exists_and_left, exists_eq_left, exists_eq_right]\n\n"}
{"name":"List.length_product","module":"Mathlib.Data.List.ProdSigma","initialProofState":"α : Type u_1\nβ : Type u_2\nl₁ : List α\nl₂ : List β\n⊢ Eq (SProd.sprod l₁ l₂).length (HMul.hMul l₁.length l₂.length)","decl":"theorem length_product (l₁ : List α) (l₂ : List β) :\n    length (l₁ ×ˢ l₂) = length l₁ * length l₂ := by\n  induction' l₁ with x l₁ IH\n  · exact (Nat.zero_mul _).symm\n  · simp only [length, product_cons, length_append, IH, Nat.add_mul, Nat.one_mul, length_map,\n      Nat.add_comm]\n\n"}
{"name":"List.nil_sigma","module":"Mathlib.Data.List.ProdSigma","initialProofState":"α : Type u_1\nσ : α → Type u_3\nl : (a : α) → List (σ a)\n⊢ Eq (List.nil.sigma l) List.nil","decl":"@[simp]\ntheorem nil_sigma (l : ∀ a, List (σ a)) : (@nil α).sigma l = [] :=\n  rfl\n\n"}
{"name":"List.sigma_cons","module":"Mathlib.Data.List.ProdSigma","initialProofState":"α : Type u_1\nσ : α → Type u_3\na : α\nl₁ : List α\nl₂ : (a : α) → List (σ a)\n⊢ Eq ((List.cons a l₁).sigma l₂) (HAppend.hAppend (List.map (Sigma.mk a) (l₂ a)) (l₁.sigma l₂))","decl":"@[simp]\ntheorem sigma_cons (a : α) (l₁ : List α) (l₂ : ∀ a, List (σ a)) :\n    (a :: l₁).sigma l₂ = map (Sigma.mk a) (l₂ a) ++ l₁.sigma l₂ :=\n  rfl\n\n"}
{"name":"List.sigma_nil","module":"Mathlib.Data.List.ProdSigma","initialProofState":"α : Type u_1\nσ : α → Type u_3\nl : List α\n⊢ Eq (l.sigma fun a => List.nil) List.nil","decl":"@[simp]\ntheorem sigma_nil : ∀ l : List α, (l.sigma fun a => @nil (σ a)) = []\n  | [] => rfl\n  | _ :: l => by simp [sigma_cons, sigma_nil l]\n\n"}
{"name":"List.mem_sigma","module":"Mathlib.Data.List.ProdSigma","initialProofState":"α : Type u_1\nσ : α → Type u_3\nl₁ : List α\nl₂ : (a : α) → List (σ a)\na : α\nb : σ a\n⊢ Iff (Membership.mem (l₁.sigma l₂) ⟨a, b⟩) (And (Membership.mem l₁ a) (Membership.mem (l₂ a) b))","decl":"@[simp]\ntheorem mem_sigma {l₁ : List α} {l₂ : ∀ a, List (σ a)} {a : α} {b : σ a} :\n    Sigma.mk a b ∈ l₁.sigma l₂ ↔ a ∈ l₁ ∧ b ∈ l₂ a := by\n  simp [List.sigma, mem_flatMap, mem_map, exists_prop, exists_and_left, and_left_comm,\n    exists_eq_left, heq_iff_eq, exists_eq_right]\n\n"}
{"name":"List.length_sigma'","module":"Mathlib.Data.List.ProdSigma","initialProofState":"α : Type u_1\nσ : α → Type u_3\nl₁ : List α\nl₂ : (a : α) → List (σ a)\n⊢ Eq (l₁.sigma l₂).length (Nat.sum (List.map (fun a => (l₂ a).length) l₁))","decl":"set_option linter.deprecated false in\n/-- See `List.length_sigma` for the corresponding statement using `List.sum`. -/\n@[deprecated \"Use `List.length_sigma`.\" (since := \"2024-10-17\")]\ntheorem length_sigma' (l₁ : List α) (l₂ : ∀ a, List (σ a)) :\n    length (l₁.sigma l₂) = Nat.sum (l₁.map fun a ↦ length (l₂ a)) := by\n  induction' l₁ with x l₁ IH\n  · rfl\n  · simp only [map, sigma_cons, length_append, length_map, IH, Nat.sum_cons]\n\n"}
{"name":"List.mem_map_swap","module":"Mathlib.Data.List.ProdSigma","initialProofState":"α : Type u_1\nβ : Type u_2\nx : α\ny : β\nxs : List (Prod α β)\n⊢ Iff (Membership.mem (List.map Prod.swap xs) { fst := y, snd := x }) (Membership.mem xs { fst := x, snd := y })","decl":"@[simp 1100]\ntheorem mem_map_swap (x : α) (y : β) (xs : List (α × β)) :\n    (y, x) ∈ map Prod.swap xs ↔ (x, y) ∈ xs := by\n  induction' xs with x xs xs_ih\n  · simp only [not_mem_nil, map_nil]\n  · cases' x with a b\n    simp only [mem_cons, Prod.mk.inj_iff, map, Prod.swap_prod_mk, Prod.exists, xs_ih, and_comm]\n\n"}
