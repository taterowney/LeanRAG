{"name":"WithCStarModule.inner_def","module":"Mathlib.Analysis.CStarAlgebra.Module.Constructions","initialProofState":"A : Type u_1\ninst✝² : NonUnitalCStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\nx y : A\n⊢ Eq (Inner.inner x y) (HMul.hMul (Star.star x) y)","decl":"open scoped InnerProductSpace in\nlemma inner_def (x y : A) : ⟪x, y⟫_A = star x * y := rfl\n\n"}
{"name":"WithCStarModule.prod_norm","module":"Mathlib.Analysis.CStarAlgebra.Module.Constructions","initialProofState":"A : Type u_1\ninst✝⁹ : NonUnitalCStarAlgebra A\ninst✝⁸ : PartialOrder A\nE : Type u_2\nF : Type u_3\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : Module Complex E\ninst✝⁵ : SMul (MulOpposite A) E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : Module Complex F\ninst✝² : SMul (MulOpposite A) F\ninst✝¹ : CStarModule A E\ninst✝ : CStarModule A F\nx : WithCStarModule (Prod E F)\n⊢ Eq (Norm.norm x) (Norm.norm (HAdd.hAdd (Inner.inner x.1 x.1) (Inner.inner x.2 x.2))).sqrt","decl":"lemma prod_norm (x : C⋆ᵐᵒᵈ (E × F)) : ‖x‖ = √‖⟪x.1, x.1⟫_A + ⟪x.2, x.2⟫_A‖ := rfl\n\n"}
{"name":"WithCStarModule.prod_norm_sq","module":"Mathlib.Analysis.CStarAlgebra.Module.Constructions","initialProofState":"A : Type u_1\ninst✝⁹ : NonUnitalCStarAlgebra A\ninst✝⁸ : PartialOrder A\nE : Type u_2\nF : Type u_3\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : Module Complex E\ninst✝⁵ : SMul (MulOpposite A) E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : Module Complex F\ninst✝² : SMul (MulOpposite A) F\ninst✝¹ : CStarModule A E\ninst✝ : CStarModule A F\nx : WithCStarModule (Prod E F)\n⊢ Eq (HPow.hPow (Norm.norm x) 2) (Norm.norm (HAdd.hAdd (Inner.inner x.1 x.1) (Inner.inner x.2 x.2)))","decl":"lemma prod_norm_sq (x : C⋆ᵐᵒᵈ (E × F)) : ‖x‖ ^ 2 = ‖⟪x.1, x.1⟫_A + ⟪x.2, x.2⟫_A‖ := by\n  simp [prod_norm]\n\n"}
{"name":"WithCStarModule.prod_norm_le_norm_add","module":"Mathlib.Analysis.CStarAlgebra.Module.Constructions","initialProofState":"A : Type u_1\ninst✝⁹ : NonUnitalCStarAlgebra A\ninst✝⁸ : PartialOrder A\nE : Type u_2\nF : Type u_3\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : Module Complex E\ninst✝⁵ : SMul (MulOpposite A) E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : Module Complex F\ninst✝² : SMul (MulOpposite A) F\ninst✝¹ : CStarModule A E\ninst✝ : CStarModule A F\nx : WithCStarModule (Prod E F)\n⊢ LE.le (Norm.norm x) (HAdd.hAdd (Norm.norm x.1) (Norm.norm x.2))","decl":"lemma prod_norm_le_norm_add (x : C⋆ᵐᵒᵈ (E × F)) : ‖x‖ ≤ ‖x.1‖ + ‖x.2‖ := by\n  refine abs_le_of_sq_le_sq' ?_ (by positivity) |>.2\n  calc ‖x‖ ^ 2 ≤ ‖⟪x.1, x.1⟫_A‖ + ‖⟪x.2, x.2⟫_A‖ := prod_norm_sq x ▸ norm_add_le _ _\n    _ = ‖x.1‖ ^ 2 + 0 + ‖x.2‖ ^ 2 := by simp [norm_sq_eq]\n    _ ≤ ‖x.1‖ ^ 2 + 2 * ‖x.1‖ * ‖x.2‖ + ‖x.2‖ ^ 2 := by gcongr; positivity\n    _ = (‖x.1‖ + ‖x.2‖) ^ 2 := by ring\n\n"}
{"name":"WithCStarModule.prod_inner","module":"Mathlib.Analysis.CStarAlgebra.Module.Constructions","initialProofState":"A : Type u_1\ninst✝¹⁰ : NonUnitalCStarAlgebra A\ninst✝⁹ : PartialOrder A\nE : Type u_2\nF : Type u_3\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : Module Complex E\ninst✝⁶ : SMul (MulOpposite A) E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : Module Complex F\ninst✝³ : SMul (MulOpposite A) F\ninst✝² : CStarModule A E\ninst✝¹ : CStarModule A F\ninst✝ : StarOrderedRing A\nx y : WithCStarModule (Prod E F)\n⊢ Eq (Inner.inner x y) (HAdd.hAdd (Inner.inner x.1 y.1) (Inner.inner x.2 y.2))","decl":"lemma prod_inner (x y : C⋆ᵐᵒᵈ (E × F)) : ⟪x, y⟫_A = ⟪x.1, y.1⟫_A + ⟪x.2, y.2⟫_A := rfl\n\n"}
{"name":"WithCStarModule.max_le_prod_norm","module":"Mathlib.Analysis.CStarAlgebra.Module.Constructions","initialProofState":"A : Type u_1\ninst✝¹⁰ : NonUnitalCStarAlgebra A\ninst✝⁹ : PartialOrder A\nE : Type u_2\nF : Type u_3\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : Module Complex E\ninst✝⁶ : SMul (MulOpposite A) E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : Module Complex F\ninst✝³ : SMul (MulOpposite A) F\ninst✝² : CStarModule A E\ninst✝¹ : CStarModule A F\ninst✝ : StarOrderedRing A\nx : WithCStarModule (Prod E F)\n⊢ LE.le (Max.max (Norm.norm x.1) (Norm.norm x.2)) (Norm.norm x)","decl":"lemma max_le_prod_norm (x : C⋆ᵐᵒᵈ (E × F)) : max ‖x.1‖ ‖x.2‖ ≤ ‖x‖ := by\n  rw [prod_norm]\n  simp only [equiv_fst, norm_eq_sqrt_norm_inner_self (E := E),\n    norm_eq_sqrt_norm_inner_self (E := F), equiv_snd, max_le_iff, norm_nonneg,\n    Real.sqrt_le_sqrt_iff]\n  constructor\n  all_goals\n    apply CStarAlgebra.norm_le_norm_of_nonneg_of_le\n    all_goals\n      aesop (add safe apply CStarModule.inner_self_nonneg)\n\n"}
{"name":"WithCStarModule.norm_equiv_le_norm_prod","module":"Mathlib.Analysis.CStarAlgebra.Module.Constructions","initialProofState":"A : Type u_1\ninst✝¹⁰ : NonUnitalCStarAlgebra A\ninst✝⁹ : PartialOrder A\nE : Type u_2\nF : Type u_3\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : Module Complex E\ninst✝⁶ : SMul (MulOpposite A) E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : Module Complex F\ninst✝³ : SMul (MulOpposite A) F\ninst✝² : CStarModule A E\ninst✝¹ : CStarModule A F\ninst✝ : StarOrderedRing A\nx : WithCStarModule (Prod E F)\n⊢ LE.le (Norm.norm ((WithCStarModule.equiv (Prod E F)) x)) (Norm.norm x)","decl":"lemma norm_equiv_le_norm_prod (x : C⋆ᵐᵒᵈ (E × F)) : ‖equiv (E × F) x‖ ≤ ‖x‖ :=\n  max_le_prod_norm x\n\n"}
{"name":"WithCStarModule.pi_norm","module":"Mathlib.Analysis.CStarAlgebra.Module.Constructions","initialProofState":"A : Type u_1\ninst✝⁶ : NonUnitalCStarAlgebra A\ninst✝⁵ : PartialOrder A\nι : Type u_2\nE : ι → Type u_3\ninst✝⁴ : Fintype ι\ninst✝³ : (i : ι) → NormedAddCommGroup (E i)\ninst✝² : (i : ι) → Module Complex (E i)\ninst✝¹ : (i : ι) → SMul (MulOpposite A) (E i)\ninst✝ : (i : ι) → CStarModule A (E i)\nx : WithCStarModule ((i : ι) → E i)\n⊢ Eq (Norm.norm x) (Norm.norm (Finset.univ.sum fun i => Inner.inner (x i) (x i))).sqrt","decl":"lemma pi_norm (x : C⋆ᵐᵒᵈ (Π i, E i)) : ‖x‖ = √‖∑ i, ⟪x i, x i⟫_A‖ := by\n  with_reducible_and_instances rfl\n\n"}
{"name":"WithCStarModule.pi_norm_sq","module":"Mathlib.Analysis.CStarAlgebra.Module.Constructions","initialProofState":"A : Type u_1\ninst✝⁶ : NonUnitalCStarAlgebra A\ninst✝⁵ : PartialOrder A\nι : Type u_2\nE : ι → Type u_3\ninst✝⁴ : Fintype ι\ninst✝³ : (i : ι) → NormedAddCommGroup (E i)\ninst✝² : (i : ι) → Module Complex (E i)\ninst✝¹ : (i : ι) → SMul (MulOpposite A) (E i)\ninst✝ : (i : ι) → CStarModule A (E i)\nx : WithCStarModule ((i : ι) → E i)\n⊢ Eq (HPow.hPow (Norm.norm x) 2) (Norm.norm (Finset.univ.sum fun i => Inner.inner (x i) (x i)))","decl":"lemma pi_norm_sq (x : C⋆ᵐᵒᵈ (Π i, E i)) : ‖x‖ ^ 2 = ‖∑ i, ⟪x i, x i⟫_A‖ := by\n  simp [pi_norm]\n\n"}
{"name":"WithCStarModule.pi_norm_le_sum_norm","module":"Mathlib.Analysis.CStarAlgebra.Module.Constructions","initialProofState":"A : Type u_1\ninst✝⁶ : NonUnitalCStarAlgebra A\ninst✝⁵ : PartialOrder A\nι : Type u_2\nE : ι → Type u_3\ninst✝⁴ : Fintype ι\ninst✝³ : (i : ι) → NormedAddCommGroup (E i)\ninst✝² : (i : ι) → Module Complex (E i)\ninst✝¹ : (i : ι) → SMul (MulOpposite A) (E i)\ninst✝ : (i : ι) → CStarModule A (E i)\nx : WithCStarModule ((i : ι) → E i)\n⊢ LE.le (Norm.norm x) (Finset.univ.sum fun i => Norm.norm (x i))","decl":"open Finset in\nlemma pi_norm_le_sum_norm (x : C⋆ᵐᵒᵈ (Π i, E i)) : ‖x‖ ≤ ∑ i, ‖x i‖ := by\n  refine abs_le_of_sq_le_sq' ?_ (by positivity) |>.2\n  calc ‖x‖ ^ 2 ≤ ∑ i, ‖⟪x i, x i⟫_A‖ := pi_norm_sq x ▸ norm_sum_le _ _\n    _ = ∑ i, ‖x i‖ ^ 2 := by simp only [norm_sq_eq]\n    _ ≤ (∑ i, ‖x i‖) ^ 2 := sum_sq_le_sq_sum_of_nonneg (fun _ _ ↦ norm_nonneg _)\n\n"}
{"name":"WithCStarModule.pi_inner","module":"Mathlib.Analysis.CStarAlgebra.Module.Constructions","initialProofState":"A : Type u_1\ninst✝⁷ : NonUnitalCStarAlgebra A\ninst✝⁶ : PartialOrder A\nι : Type u_2\nE : ι → Type u_3\ninst✝⁵ : Fintype ι\ninst✝⁴ : (i : ι) → NormedAddCommGroup (E i)\ninst✝³ : (i : ι) → Module Complex (E i)\ninst✝² : (i : ι) → SMul (MulOpposite A) (E i)\ninst✝¹ : (i : ι) → CStarModule A (E i)\ninst✝ : StarOrderedRing A\nx y : WithCStarModule ((i : ι) → E i)\n⊢ Eq (Inner.inner x y) (Finset.univ.sum fun i => Inner.inner (x i) (y i))","decl":"lemma pi_inner (x y : C⋆ᵐᵒᵈ (Π i, E i)) : ⟪x, y⟫_A = ∑ i, ⟪x i, y i⟫_A := rfl\n\n"}
{"name":"WithCStarModule.inner_single_left","module":"Mathlib.Analysis.CStarAlgebra.Module.Constructions","initialProofState":"A : Type u_1\ninst✝⁸ : NonUnitalCStarAlgebra A\ninst✝⁷ : PartialOrder A\nι : Type u_2\nE : ι → Type u_3\ninst✝⁶ : Fintype ι\ninst✝⁵ : (i : ι) → NormedAddCommGroup (E i)\ninst✝⁴ : (i : ι) → Module Complex (E i)\ninst✝³ : (i : ι) → SMul (MulOpposite A) (E i)\ninst✝² : (i : ι) → CStarModule A (E i)\ninst✝¹ : StarOrderedRing A\ninst✝ : DecidableEq ι\nx : WithCStarModule ((i : ι) → E i)\ni : ι\ny : E i\n⊢ Eq (Inner.inner ((WithCStarModule.equiv ((j : ι) → E j)).symm (Pi.single i y)) x) (Inner.inner y (x i))","decl":"@[simp]\nlemma inner_single_left [DecidableEq ι] (x : C⋆ᵐᵒᵈ (Π i, E i)) {i : ι} (y : E i) :\n    ⟪equiv _ |>.symm <| Pi.single i y, x⟫_A = ⟪y, x i⟫_A := by\n  simp only [pi_inner, equiv_symm_pi_apply]\n  rw [Finset.sum_eq_single i]\n  all_goals simp_all\n\n"}
{"name":"WithCStarModule.inner_single_right","module":"Mathlib.Analysis.CStarAlgebra.Module.Constructions","initialProofState":"A : Type u_1\ninst✝⁸ : NonUnitalCStarAlgebra A\ninst✝⁷ : PartialOrder A\nι : Type u_2\nE : ι → Type u_3\ninst✝⁶ : Fintype ι\ninst✝⁵ : (i : ι) → NormedAddCommGroup (E i)\ninst✝⁴ : (i : ι) → Module Complex (E i)\ninst✝³ : (i : ι) → SMul (MulOpposite A) (E i)\ninst✝² : (i : ι) → CStarModule A (E i)\ninst✝¹ : StarOrderedRing A\ninst✝ : DecidableEq ι\nx : WithCStarModule ((i : ι) → E i)\ni : ι\ny : E i\n⊢ Eq (Inner.inner x ((WithCStarModule.equiv ((i : ι) → E i)).symm (Pi.single i y))) (Inner.inner (x i) y)","decl":"@[simp]\nlemma inner_single_right [DecidableEq ι] (x : C⋆ᵐᵒᵈ (Π i, E i)) {i : ι} (y : E i) :\n    ⟪x, equiv _ |>.symm <| Pi.single i y⟫_A = ⟪x i, y⟫_A := by\n  simp only [pi_inner, equiv_symm_pi_apply]\n  rw [Finset.sum_eq_single i]\n  all_goals simp_all\n\n"}
{"name":"WithCStarModule.norm_single","module":"Mathlib.Analysis.CStarAlgebra.Module.Constructions","initialProofState":"A : Type u_1\ninst✝⁸ : NonUnitalCStarAlgebra A\ninst✝⁷ : PartialOrder A\nι : Type u_2\nE : ι → Type u_3\ninst✝⁶ : Fintype ι\ninst✝⁵ : (i : ι) → NormedAddCommGroup (E i)\ninst✝⁴ : (i : ι) → Module Complex (E i)\ninst✝³ : (i : ι) → SMul (MulOpposite A) (E i)\ninst✝² : (i : ι) → CStarModule A (E i)\ninst✝¹ : StarOrderedRing A\ninst✝ : DecidableEq ι\ni : ι\ny : E i\n⊢ Eq (Norm.norm ((WithCStarModule.equiv ((j : ι) → E j)).symm (Pi.single i y))) (Norm.norm y)","decl":"@[simp]\nlemma norm_single [DecidableEq ι] (i : ι) (y : E i) :\n    ‖equiv _ |>.symm <| Pi.single i y‖ = ‖y‖ := by\n  let _ : NormedAddCommGroup (C⋆ᵐᵒᵈ (Π i, E i)) := normedAddCommGroup\n  rw [← sq_eq_sq₀ (by positivity) (by positivity)]\n  simp [norm_sq_eq]\n\n"}
{"name":"WithCStarModule.norm_apply_le_norm","module":"Mathlib.Analysis.CStarAlgebra.Module.Constructions","initialProofState":"A : Type u_1\ninst✝⁷ : NonUnitalCStarAlgebra A\ninst✝⁶ : PartialOrder A\nι : Type u_2\nE : ι → Type u_3\ninst✝⁵ : Fintype ι\ninst✝⁴ : (i : ι) → NormedAddCommGroup (E i)\ninst✝³ : (i : ι) → Module Complex (E i)\ninst✝² : (i : ι) → SMul (MulOpposite A) (E i)\ninst✝¹ : (i : ι) → CStarModule A (E i)\ninst✝ : StarOrderedRing A\nx : WithCStarModule ((i : ι) → E i)\ni : ι\n⊢ LE.le (Norm.norm (x i)) (Norm.norm x)","decl":"lemma norm_apply_le_norm (x : C⋆ᵐᵒᵈ (Π i, E i)) (i : ι) : ‖x i‖ ≤ ‖x‖ := by\n  let _ : NormedAddCommGroup (C⋆ᵐᵒᵈ (Π i, E i)) := normedAddCommGroup\n  refine abs_le_of_sq_le_sq' ?_ (by positivity) |>.2\n  rw [pi_norm_sq, norm_sq_eq]\n  refine CStarAlgebra.norm_le_norm_of_nonneg_of_le inner_self_nonneg ?_\n  exact Finset.single_le_sum (fun j _ ↦ inner_self_nonneg (x := x j)) (Finset.mem_univ i)\n\n"}
{"name":"WithCStarModule.norm_equiv_le_norm_pi","module":"Mathlib.Analysis.CStarAlgebra.Module.Constructions","initialProofState":"A : Type u_1\ninst✝⁷ : NonUnitalCStarAlgebra A\ninst✝⁶ : PartialOrder A\nι : Type u_2\nE : ι → Type u_3\ninst✝⁵ : Fintype ι\ninst✝⁴ : (i : ι) → NormedAddCommGroup (E i)\ninst✝³ : (i : ι) → Module Complex (E i)\ninst✝² : (i : ι) → SMul (MulOpposite A) (E i)\ninst✝¹ : (i : ι) → CStarModule A (E i)\ninst✝ : StarOrderedRing A\nx : WithCStarModule ((i : ι) → E i)\n⊢ LE.le (Norm.norm ((WithCStarModule.equiv ((i : ι) → E i)) x)) (Norm.norm x)","decl":"open Finset in\nlemma norm_equiv_le_norm_pi (x : C⋆ᵐᵒᵈ (Π i, E i)) : ‖equiv _ x‖ ≤ ‖x‖ := by\n  let _ : NormedAddCommGroup (C⋆ᵐᵒᵈ (Π i, E i)) := normedAddCommGroup\n  rw [pi_norm_le_iff_of_nonneg (by positivity)]\n  simpa using norm_apply_le_norm x\n\n"}
