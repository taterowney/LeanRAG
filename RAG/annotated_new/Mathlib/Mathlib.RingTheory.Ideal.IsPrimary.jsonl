{"name":"Ideal.isPrimary_iff","module":"Mathlib.RingTheory.Ideal.IsPrimary","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\n⊢ Iff I.IsPrimary (And (Ne I Top.top) (∀ {x y : R}, Membership.mem I (HMul.hMul x y) → Or (Membership.mem I x) (Membership.mem I.radical y)))","decl":"/-- A proper ideal `I` is primary iff `xy ∈ I` implies `x ∈ I` or `y ∈ radical I`. -/\nlemma isPrimary_iff {I : Ideal R} :\n    I.IsPrimary ↔ I ≠ ⊤ ∧ ∀ {x y : R}, x * y ∈ I → x ∈ I ∨ y ∈ radical I := by\n  rw [IsPrimary, Submodule.IsPrimary, forall_comm]\n  simp only [mul_comm, mem_radical_iff, and_congr_right_iff,\n    ← Submodule.ideal_span_singleton_smul, smul_eq_mul, mul_top, span_singleton_le_iff_mem]\n\n"}
{"name":"Ideal.IsPrime.isPrimary","module":"Mathlib.RingTheory.Ideal.IsPrimary","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\nhi : I.IsPrime\n⊢ I.IsPrimary","decl":"theorem IsPrime.isPrimary {I : Ideal R} (hi : IsPrime I) : I.IsPrimary :=\n  isPrimary_iff.mpr\n  ⟨hi.1, fun {_ _} hxy => (hi.mem_or_mem hxy).imp id fun hyi => le_radical hyi⟩\n\n"}
{"name":"Ideal.isPrime_radical","module":"Mathlib.RingTheory.Ideal.IsPrimary","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\nhi : I.IsPrimary\n⊢ I.radical.IsPrime","decl":"theorem isPrime_radical {I : Ideal R} (hi : I.IsPrimary) : IsPrime (radical I) :=\n  ⟨mt radical_eq_top.1 hi.1,\n   fun {x y} ⟨m, hxy⟩ => by\n    rw [mul_pow] at hxy; cases' (isPrimary_iff.mp hi).2 hxy with h h\n    · exact Or.inl ⟨m, h⟩\n    · exact Or.inr (mem_radical_of_pow_mem h)⟩\n\n"}
{"name":"Ideal.isPrimary_inf","module":"Mathlib.RingTheory.Ideal.IsPrimary","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI J : Ideal R\nhi : I.IsPrimary\nhj : J.IsPrimary\nhij : Eq I.radical J.radical\n⊢ (Min.min I J).IsPrimary","decl":"theorem isPrimary_inf {I J : Ideal R} (hi : I.IsPrimary) (hj : J.IsPrimary)\n    (hij : radical I = radical J) : (I ⊓ J).IsPrimary :=\n  isPrimary_iff.mpr\n  ⟨ne_of_lt <| lt_of_le_of_lt inf_le_left (lt_top_iff_ne_top.2 hi.1),\n   fun {x y} ⟨hxyi, hxyj⟩ => by\n    rw [radical_inf, hij, inf_idem]\n    cases' (isPrimary_iff.mp hi).2 hxyi with hxi hyi\n    · cases' (isPrimary_iff.mp hj).2 hxyj with hxj hyj\n      · exact Or.inl ⟨hxi, hxj⟩\n      · exact Or.inr hyj\n    · rw [hij] at hyi\n      exact Or.inr hyi⟩\n\n"}
{"name":"Ideal.isPrimary_finset_inf","module":"Mathlib.RingTheory.Ideal.IsPrimary","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nι : Type u_2\ns : Finset ι\nf : ι → Ideal R\ni : ι\nhi : Membership.mem s i\nhs : ∀ ⦃y : ι⦄, Membership.mem s y → (f y).IsPrimary\nhs' : ∀ ⦃y : ι⦄, Membership.mem s y → Eq (f y).radical (f i).radical\n⊢ (s.inf f).IsPrimary","decl":"open Finset in\nlemma isPrimary_finset_inf {ι} {s : Finset ι} {f : ι → Ideal R} {i : ι} (hi : i ∈ s)\n    (hs : ∀ ⦃y⦄, y ∈ s → (f y).IsPrimary)\n    (hs' : ∀ ⦃y⦄, y ∈ s → (f y).radical = (f i).radical) :\n    IsPrimary (s.inf f) := by\n  classical\n  induction s using Finset.induction_on generalizing i with\n  | empty => simp at hi\n  | @insert a s ha IH =>\n    rcases s.eq_empty_or_nonempty with rfl|⟨y, hy⟩\n    · simp only [insert_emptyc_eq, mem_singleton] at hi\n      simpa [hi] using hs\n    simp only [inf_insert]\n    have H : ∀ ⦃x : ι⦄, x ∈ s → (f x).radical = (f y).radical := by\n      intro x hx\n      rw [hs' (mem_insert_of_mem hx), hs' (mem_insert_of_mem hy)]\n    refine isPrimary_inf (hs (by simp)) (IH hy ?_ H) ?_\n    · intro x hx\n      exact hs (by simp [hx])\n    · rw [radical_finset_inf hy H, hs' (mem_insert_self _ _), hs' (mem_insert_of_mem hy)]\n\n"}
