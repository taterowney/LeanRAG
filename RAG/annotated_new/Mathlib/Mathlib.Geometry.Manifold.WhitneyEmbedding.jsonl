{"name":"SmoothBumpCovering.embeddingPiTangent_coe","module":"Mathlib.Geometry.Manifold.WhitneyEmbedding","initialProofState":"ι : Type uι\nE : Type uE\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Real E\ninst✝⁶ : FiniteDimensional Real E\nH : Type uH\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\ninst✝² : IsManifold I (↑Top.top) M\ninst✝¹ : T2Space M\ninst✝ : Fintype ι\ns : Set M\nf : SmoothBumpCovering ι I M s\n⊢ Eq ⇑f.embeddingPiTangent fun x i => { fst := HSMul.hSMul (↑(f.toFun i) x) (↑(extChartAt I (f.c i)) x), snd := ↑(f.toFun i) x }","decl":"@[local simp]\ntheorem embeddingPiTangent_coe :\n    ⇑f.embeddingPiTangent = fun x i => (f i x • extChartAt I (f.c i) x, f i x) :=\n  rfl\n\n"}
{"name":"SmoothBumpCovering.embeddingPiTangent_injOn","module":"Mathlib.Geometry.Manifold.WhitneyEmbedding","initialProofState":"ι : Type uι\nE : Type uE\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Real E\ninst✝⁶ : FiniteDimensional Real E\nH : Type uH\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\ninst✝² : IsManifold I (↑Top.top) M\ninst✝¹ : T2Space M\ninst✝ : Fintype ι\ns : Set M\nf : SmoothBumpCovering ι I M s\n⊢ Set.InjOn (⇑f.embeddingPiTangent) s","decl":"theorem embeddingPiTangent_injOn : InjOn f.embeddingPiTangent s := by\n  intro x hx y _ h\n  simp only [embeddingPiTangent_coe, funext_iff] at h\n  obtain ⟨h₁, h₂⟩ := Prod.mk.inj_iff.1 (h (f.ind x hx))\n  rw [f.apply_ind x hx] at h₂\n  rw [← h₂, f.apply_ind x hx, one_smul, one_smul] at h₁\n  have := f.mem_extChartAt_source_of_eq_one h₂.symm\n  exact (extChartAt I (f.c _)).injOn (f.mem_extChartAt_ind_source x hx) this h₁\n\n"}
{"name":"SmoothBumpCovering.embeddingPiTangent_injective","module":"Mathlib.Geometry.Manifold.WhitneyEmbedding","initialProofState":"ι : Type uι\nE : Type uE\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Real E\ninst✝⁶ : FiniteDimensional Real E\nH : Type uH\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\ninst✝² : IsManifold I (↑Top.top) M\ninst✝¹ : T2Space M\ninst✝ : Fintype ι\nf : SmoothBumpCovering ι I M\n⊢ Function.Injective ⇑f.embeddingPiTangent","decl":"theorem embeddingPiTangent_injective (f : SmoothBumpCovering ι I M) :\n    Injective f.embeddingPiTangent :=\n  injective_iff_injOn_univ.2 f.embeddingPiTangent_injOn\n\n"}
{"name":"SmoothBumpCovering.comp_embeddingPiTangent_mfderiv","module":"Mathlib.Geometry.Manifold.WhitneyEmbedding","initialProofState":"ι : Type uι\nE : Type uE\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Real E\ninst✝⁶ : FiniteDimensional Real E\nH : Type uH\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\ninst✝² : IsManifold I (↑Top.top) M\ninst✝¹ : T2Space M\ninst✝ : Fintype ι\ns : Set M\nf : SmoothBumpCovering ι I M s\nx : M\nhx : Membership.mem s x\n⊢ Eq (((ContinuousLinearMap.fst Real E Real).comp (ContinuousLinearMap.proj (f.ind x hx))).comp (mfderiv I (modelWithCornersSelf Real (ι → Prod E Real)) (⇑f.embeddingPiTangent) x)) (mfderiv I I (↑(chartAt H (f.c (f.ind x hx)))) x)","decl":"theorem comp_embeddingPiTangent_mfderiv (x : M) (hx : x ∈ s) :\n    ((ContinuousLinearMap.fst ℝ E ℝ).comp\n            (@ContinuousLinearMap.proj ℝ _ ι (fun _ => E × ℝ) _ _ (fun _ => inferInstance)\n              (f.ind x hx))).comp\n        (mfderiv I 𝓘(ℝ, ι → E × ℝ) f.embeddingPiTangent x) =\n      mfderiv I I (chartAt H (f.c (f.ind x hx))) x := by\n  set L :=\n    (ContinuousLinearMap.fst ℝ E ℝ).comp\n      (@ContinuousLinearMap.proj ℝ _ ι (fun _ => E × ℝ) _ _ (fun _ => inferInstance) (f.ind x hx))\n  have := L.hasMFDerivAt.comp x\n    (f.embeddingPiTangent.contMDiff.mdifferentiableAt (mod_cast le_top)).hasMFDerivAt\n  convert hasMFDerivAt_unique this _\n  refine (hasMFDerivAt_extChartAt (f.mem_chartAt_ind_source x hx)).congr_of_eventuallyEq ?_\n  refine (f.eventuallyEq_one x hx).mono fun y hy => ?_\n  simp only [L, embeddingPiTangent_coe, ContinuousLinearMap.coe_comp', (· ∘ ·),\n    ContinuousLinearMap.coe_fst', ContinuousLinearMap.proj_apply]\n  rw [hy, Pi.one_apply, one_smul]\n\n"}
{"name":"SmoothBumpCovering.embeddingPiTangent_ker_mfderiv","module":"Mathlib.Geometry.Manifold.WhitneyEmbedding","initialProofState":"ι : Type uι\nE : Type uE\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Real E\ninst✝⁶ : FiniteDimensional Real E\nH : Type uH\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\ninst✝² : IsManifold I (↑Top.top) M\ninst✝¹ : T2Space M\ninst✝ : Fintype ι\ns : Set M\nf : SmoothBumpCovering ι I M s\nx : M\nhx : Membership.mem s x\n⊢ Eq (LinearMap.ker (mfderiv I (modelWithCornersSelf Real (ι → Prod E Real)) (⇑f.embeddingPiTangent) x)) Bot.bot","decl":"theorem embeddingPiTangent_ker_mfderiv (x : M) (hx : x ∈ s) :\n    LinearMap.ker (mfderiv I 𝓘(ℝ, ι → E × ℝ) f.embeddingPiTangent x) = ⊥ := by\n  apply bot_unique\n  rw [← (mdifferentiable_chart (f.c (f.ind x hx))).ker_mfderiv_eq_bot\n      (f.mem_chartAt_ind_source x hx),\n    ← comp_embeddingPiTangent_mfderiv]\n  exact LinearMap.ker_le_ker_comp _ _\n\n"}
{"name":"SmoothBumpCovering.embeddingPiTangent_injective_mfderiv","module":"Mathlib.Geometry.Manifold.WhitneyEmbedding","initialProofState":"ι : Type uι\nE : Type uE\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Real E\ninst✝⁶ : FiniteDimensional Real E\nH : Type uH\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\ninst✝² : IsManifold I (↑Top.top) M\ninst✝¹ : T2Space M\ninst✝ : Fintype ι\ns : Set M\nf : SmoothBumpCovering ι I M s\nx : M\nhx : Membership.mem s x\n⊢ Function.Injective ⇑(mfderiv I (modelWithCornersSelf Real (ι → Prod E Real)) (⇑f.embeddingPiTangent) x)","decl":"theorem embeddingPiTangent_injective_mfderiv (x : M) (hx : x ∈ s) :\n    Injective (mfderiv I 𝓘(ℝ, ι → E × ℝ) f.embeddingPiTangent x) :=\n  LinearMap.ker_eq_bot.1 (f.embeddingPiTangent_ker_mfderiv x hx)\n\n"}
{"name":"SmoothBumpCovering.exists_immersion_euclidean","module":"Mathlib.Geometry.Manifold.WhitneyEmbedding","initialProofState":"E : Type uE\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Real E\ninst✝⁶ : FiniteDimensional Real E\nH : Type uH\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\ninst✝² : IsManifold I (↑Top.top) M\ninst✝¹ : T2Space M\nι : Type u_1\ninst✝ : Finite ι\nf : SmoothBumpCovering ι I M\n⊢ Exists fun n => Exists fun e => And (ContMDiff I (modelWithCornersSelf Real (EuclideanSpace Real (Fin n))) (↑Top.top) e) (And (Function.Injective e) (∀ (x : M), Function.Injective ⇑(mfderiv I (modelWithCornersSelf Real (EuclideanSpace Real (Fin n))) e x)))","decl":"/-- Baby version of the **Whitney weak embedding theorem**: if `M` admits a finite covering by\nsupports of bump functions, then for some `n` it can be immersed into the `n`-dimensional\nEuclidean space. -/\ntheorem exists_immersion_euclidean {ι : Type*} [Finite ι] (f : SmoothBumpCovering ι I M) :\n    ∃ (n : ℕ) (e : M → EuclideanSpace ℝ (Fin n)),\n      ContMDiff I (𝓡 n) ∞ e ∧ Injective e ∧ ∀ x : M, Injective (mfderiv I (𝓡 n) e x) := by\n  cases nonempty_fintype ι\n  set F := EuclideanSpace ℝ (Fin <| finrank ℝ (ι → E × ℝ))\n  letI : IsNoetherian ℝ (E × ℝ) := IsNoetherian.iff_fg.2 inferInstance\n  letI : FiniteDimensional ℝ (ι → E × ℝ) := IsNoetherian.iff_fg.1 inferInstance\n  set eEF : (ι → E × ℝ) ≃L[ℝ] F :=\n    ContinuousLinearEquiv.ofFinrankEq finrank_euclideanSpace_fin.symm\n  refine ⟨_, eEF ∘ f.embeddingPiTangent,\n    eEF.toDiffeomorph.contMDiff.comp f.embeddingPiTangent.contMDiff,\n    eEF.injective.comp f.embeddingPiTangent_injective, fun x => ?_⟩\n  rw [mfderiv_comp _ eEF.differentiableAt.mdifferentiableAt\n      (f.embeddingPiTangent.contMDiff.mdifferentiableAt (mod_cast le_top)),\n    eEF.mfderiv_eq]\n  exact eEF.injective.comp (f.embeddingPiTangent_injective_mfderiv _ trivial)\n\n"}
{"name":"exists_embedding_euclidean_of_compact","module":"Mathlib.Geometry.Manifold.WhitneyEmbedding","initialProofState":"E : Type uE\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Real E\ninst✝⁶ : FiniteDimensional Real E\nH : Type uH\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\ninst✝² : IsManifold I (↑Top.top) M\ninst✝¹ : T2Space M\ninst✝ : CompactSpace M\n⊢ Exists fun n => Exists fun e => And (ContMDiff I (modelWithCornersSelf Real (EuclideanSpace Real (Fin n))) (↑Top.top) e) (And (Topology.IsClosedEmbedding e) (∀ (x : M), Function.Injective ⇑(mfderiv I (modelWithCornersSelf Real (EuclideanSpace Real (Fin n))) e x)))","decl":"/-- Baby version of the Whitney weak embedding theorem: if `M` admits a finite covering by\nsupports of bump functions, then for some `n` it can be embedded into the `n`-dimensional\nEuclidean space. -/\ntheorem exists_embedding_euclidean_of_compact [T2Space M] [CompactSpace M] :\n    ∃ (n : ℕ) (e : M → EuclideanSpace ℝ (Fin n)),\n      ContMDiff I (𝓡 n) ∞ e ∧ IsClosedEmbedding e ∧ ∀ x : M, Injective (mfderiv I (𝓡 n) e x) := by\n  rcases SmoothBumpCovering.exists_isSubordinate I isClosed_univ fun (x : M) _ => univ_mem with\n    ⟨ι, f, -⟩\n  haveI := f.fintype\n  rcases f.exists_immersion_euclidean with ⟨n, e, hsmooth, hinj, hinj_mfderiv⟩\n  exact ⟨n, e, hsmooth, hsmooth.continuous.isClosedEmbedding hinj, hinj_mfderiv⟩\n"}
