{"name":"CategoryTheory.ReflQuiver.homOfEq_id","module":"Mathlib.Combinatorics.Quiver.ReflQuiver","initialProofState":"V : Type u_1\ninst‚úù : CategoryTheory.ReflQuiver V\nX X' : V\nhX : Eq X X'\n‚ä¢ Eq (Quiver.homOfEq (CategoryTheory.ReflQuiver.id X) hX hX) (CategoryTheory.ReflQuiver.id X')","decl":"@[simp]\ntheorem ReflQuiver.homOfEq_id {V : Type*} [ReflQuiver V] {X X' : V} (hX : X = X') :\n    Quiver.homOfEq (ùüôrq X) hX hX = ùüôrq X' := by subst hX ; rfl\n\n"}
{"name":"CategoryTheory.ReflQuiver.id_eq_id","module":"Mathlib.Combinatorics.Quiver.ReflQuiver","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : C\n‚ä¢ Eq (CategoryTheory.ReflQuiver.id X) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp] theorem ReflQuiver.id_eq_id {C : Type*} [Category C] (X : C) : ùüôrq X = ùüô X := rfl\n\n"}
{"name":"CategoryTheory.ReflPrefunctor.mk.injEq","module":"Mathlib.Combinatorics.Quiver.ReflQuiver","initialProofState":"V : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.ReflQuiver V\nW : Type u‚ÇÇ\ninst‚úù : CategoryTheory.ReflQuiver W\ntoPrefunctor‚úù : Prefunctor V W\nmap_id‚úù : autoParam (‚àÄ (X : V), Eq (toPrefunctor‚úù.map (CategoryTheory.ReflQuiver.id X)) (CategoryTheory.ReflQuiver.id (toPrefunctor‚úù.obj X))) _auto‚úù\ntoPrefunctor : Prefunctor V W\nmap_id : autoParam (‚àÄ (X : V), Eq (toPrefunctor.map (CategoryTheory.ReflQuiver.id X)) (CategoryTheory.ReflQuiver.id (toPrefunctor.obj X))) _auto‚úù\n‚ä¢ Eq (Eq { toPrefunctor := toPrefunctor‚úù, map_id := map_id‚úù } { toPrefunctor := toPrefunctor, map_id := map_id }) (Eq toPrefunctor‚úù toPrefunctor)","decl":"/-- A morphism of reflexive quivers called a `ReflPrefunctor`. -/\nstructure ReflPrefunctor (V : Type u‚ÇÅ) [ReflQuiver.{v‚ÇÅ} V] (W : Type u‚ÇÇ) [ReflQuiver.{v‚ÇÇ} W]\n    extends Prefunctor V W where\n  /-- A functor preserves identity morphisms. -/\n  map_id : ‚àÄ X : V, map (ùüôrq X) = ùüôrq (obj X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ReflPrefunctor.mk.sizeOf_spec","module":"Mathlib.Combinatorics.Quiver.ReflQuiver","initialProofState":"V : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.ReflQuiver V\nW : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.ReflQuiver W\ninst‚úù¬π : SizeOf V\ninst‚úù : SizeOf W\ntoPrefunctor : Prefunctor V W\nmap_id : autoParam (‚àÄ (X : V), Eq (toPrefunctor.map (CategoryTheory.ReflQuiver.id X)) (CategoryTheory.ReflQuiver.id (toPrefunctor.obj X))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { toPrefunctor := toPrefunctor, map_id := map_id }) (HAdd.hAdd 1 (SizeOf.sizeOf toPrefunctor))","decl":"/-- A morphism of reflexive quivers called a `ReflPrefunctor`. -/\nstructure ReflPrefunctor (V : Type u‚ÇÅ) [ReflQuiver.{v‚ÇÅ} V] (W : Type u‚ÇÇ) [ReflQuiver.{v‚ÇÇ} W]\n    extends Prefunctor V W where\n  /-- A functor preserves identity morphisms. -/\n  map_id : ‚àÄ X : V, map (ùüôrq X) = ùüôrq (obj X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ReflPrefunctor.mk.inj","module":"Mathlib.Combinatorics.Quiver.ReflQuiver","initialProofState":"V : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.ReflQuiver V\nW : Type u‚ÇÇ\ninst‚úù : CategoryTheory.ReflQuiver W\ntoPrefunctor‚úù : Prefunctor V W\nmap_id‚úù : autoParam (‚àÄ (X : V), Eq (toPrefunctor‚úù.map (CategoryTheory.ReflQuiver.id X)) (CategoryTheory.ReflQuiver.id (toPrefunctor‚úù.obj X))) _auto‚úù\ntoPrefunctor : Prefunctor V W\nmap_id : autoParam (‚àÄ (X : V), Eq (toPrefunctor.map (CategoryTheory.ReflQuiver.id X)) (CategoryTheory.ReflQuiver.id (toPrefunctor.obj X))) _auto‚úù\nx‚úù : Eq { toPrefunctor := toPrefunctor‚úù, map_id := map_id‚úù } { toPrefunctor := toPrefunctor, map_id := map_id }\n‚ä¢ Eq toPrefunctor‚úù toPrefunctor","decl":"/-- A morphism of reflexive quivers called a `ReflPrefunctor`. -/\nstructure ReflPrefunctor (V : Type u‚ÇÅ) [ReflQuiver.{v‚ÇÅ} V] (W : Type u‚ÇÇ) [ReflQuiver.{v‚ÇÇ} W]\n    extends Prefunctor V W where\n  /-- A functor preserves identity morphisms. -/\n  map_id : ‚àÄ X : V, map (ùüôrq X) = ùüôrq (obj X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ReflPrefunctor.map_id","module":"Mathlib.Combinatorics.Quiver.ReflQuiver","initialProofState":"V : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.ReflQuiver V\nW : Type u‚ÇÇ\ninst‚úù : CategoryTheory.ReflQuiver W\nself : CategoryTheory.ReflPrefunctor V W\nX : V\n‚ä¢ Eq (self.map (CategoryTheory.ReflQuiver.id X)) (CategoryTheory.ReflQuiver.id (self.obj X))","decl":"/-- A morphism of reflexive quivers called a `ReflPrefunctor`. -/\nstructure ReflPrefunctor (V : Type u‚ÇÅ) [ReflQuiver.{v‚ÇÅ} V] (W : Type u‚ÇÇ) [ReflQuiver.{v‚ÇÇ} W]\n    extends Prefunctor V W where\n  /-- A functor preserves identity morphisms. -/\n  map_id : ‚àÄ X : V, map (ùüôrq X) = ùüôrq (obj X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ReflPrefunctor.mk_obj","module":"Mathlib.Combinatorics.Quiver.ReflQuiver","initialProofState":"V : Type u_1\nW : Type u_2\ninst‚úù¬π : CategoryTheory.ReflQuiver V\ninst‚úù : CategoryTheory.ReflQuiver W\nobj : V ‚Üí W\nmap : {X Y : V} ‚Üí Quiver.Hom X Y ‚Üí Quiver.Hom (obj X) (obj Y)\nX : V\n‚ä¢ Eq ({ obj := obj, map := map }.obj X) (obj X)","decl":"lemma mk_obj {V W : Type*} [ReflQuiver V] [ReflQuiver W] {obj : V ‚Üí W} {map} {X : V} :\n    (Prefunctor.mk obj map).obj X = obj X := rfl\n\n"}
{"name":"CategoryTheory.ReflPrefunctor.mk_map","module":"Mathlib.Combinatorics.Quiver.ReflQuiver","initialProofState":"V : Type u_1\nW : Type u_2\ninst‚úù¬π : CategoryTheory.ReflQuiver V\ninst‚úù : CategoryTheory.ReflQuiver W\nobj : V ‚Üí W\nmap : {X Y : V} ‚Üí Quiver.Hom X Y ‚Üí Quiver.Hom (obj X) (obj Y)\nX Y : V\nf : Quiver.Hom X Y\n‚ä¢ Eq ({ obj := obj, map := map }.map f) (map f)","decl":"lemma mk_map {V W : Type*} [ReflQuiver V] [ReflQuiver W] {obj : V ‚Üí W} {map} {X Y : V} {f : X ‚ü∂ Y} :\n    (Prefunctor.mk obj map).map f = map f := rfl\n\n"}
{"name":"CategoryTheory.ReflPrefunctor.ext","module":"Mathlib.Combinatorics.Quiver.ReflQuiver","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.ReflQuiver V\nW : Type u‚ÇÇ\ninst‚úù : CategoryTheory.ReflQuiver W\nF G : CategoryTheory.ReflPrefunctor V W\nh_obj : ‚àÄ (X : V), Eq (F.obj X) (G.obj X)\nh_map : ‚àÄ (X Y : V) (f : Quiver.Hom X Y), Eq (F.map f) (Eq.recOn ‚ãØ (Eq.recOn ‚ãØ (G.map f)))\n‚ä¢ Eq F G","decl":"/-- Proving equality between reflexive prefunctors. This isn't an extensionality lemma,\n  because usually you don't really want to do this. -/\ntheorem ext {V : Type u} [ReflQuiver.{v‚ÇÅ} V] {W : Type u‚ÇÇ} [ReflQuiver.{v‚ÇÇ} W]\n    {F G : ReflPrefunctor V W}\n    (h_obj : ‚àÄ X, F.obj X = G.obj X)\n    (h_map : ‚àÄ (X Y : V) (f : X ‚ü∂ Y),\n      F.map f = Eq.recOn (h_obj Y).symm (Eq.recOn (h_obj X).symm (G.map f))) : F = G := by\n  obtain ‚ü®‚ü®F_obj‚ü©‚ü© := F\n  obtain ‚ü®‚ü®G_obj‚ü©‚ü© := G\n  obtain rfl : F_obj = G_obj := (Set.eqOn_univ F_obj G_obj).mp fun _ _ ‚Ü¶ h_obj _\n  congr\n  funext X Y f\n  simpa using h_map X Y f\n\n"}
{"name":"CategoryTheory.ReflPrefunctor.ext'","module":"Mathlib.Combinatorics.Quiver.ReflQuiver","initialProofState":"V W : Type u\ninst‚úù¬π : CategoryTheory.ReflQuiver V\ninst‚úù : CategoryTheory.ReflQuiver W\nF G : CategoryTheory.ReflPrefunctor V W\nh_obj : ‚àÄ (X : V), Eq (F.obj X) (G.obj X)\nh_map : ‚àÄ (X Y : V) (f : Quiver.Hom X Y), Eq (F.map f) (Quiver.homOfEq (G.map f) ‚ãØ ‚ãØ)\n‚ä¢ Eq F G","decl":"/-- This may be a more useful form of `ReflPrefunctor.ext`. -/\ntheorem ext' {V W : Type u} [ReflQuiver.{v} V] [ReflQuiver.{v} W]\n    {F G : ReflPrefunctor V W}\n    (h_obj : ‚àÄ X, F.obj X = G.obj X)\n    (h_map : ‚àÄ (X Y : V) (f : X ‚ü∂ Y),\n      F.map f = Quiver.homOfEq (G.map f) (h_obj _).symm (h_obj _).symm) : F = G := by\n  obtain ‚ü®Fpre, Fid‚ü© := F\n  obtain ‚ü®Gpre, Gid‚ü© := G\n  simp at h_obj h_map\n  obtain rfl : Fpre = Gpre := Prefunctor.ext' (V := V) (W := W) h_obj h_map\n  rfl\n\n"}
{"name":"CategoryTheory.ReflPrefunctor.id_map","module":"Mathlib.Combinatorics.Quiver.ReflQuiver","initialProofState":"V : Type u_1\ninst‚úù : CategoryTheory.ReflQuiver V\nX‚úù Y‚úù : V\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.ReflPrefunctor.id V).map f) f","decl":"/-- The identity morphism between reflexive quivers. -/\n@[simps!]\ndef id (V : Type*) [ReflQuiver V] : ReflPrefunctor V V where\n  __ := Prefunctor.id _\n  map_id _ := rfl\n\n"}
{"name":"CategoryTheory.ReflPrefunctor.id_obj","module":"Mathlib.Combinatorics.Quiver.ReflQuiver","initialProofState":"V : Type u_1\ninst‚úù : CategoryTheory.ReflQuiver V\nX : V\n‚ä¢ Eq ((CategoryTheory.ReflPrefunctor.id V).obj X) X","decl":"/-- The identity morphism between reflexive quivers. -/\n@[simps!]\ndef id (V : Type*) [ReflQuiver V] : ReflPrefunctor V V where\n  __ := Prefunctor.id _\n  map_id _ := rfl\n\n"}
{"name":"CategoryTheory.ReflPrefunctor.comp_map","module":"Mathlib.Combinatorics.Quiver.ReflQuiver","initialProofState":"U : Type u_1\ninst‚úù¬≤ : CategoryTheory.ReflQuiver U\nV : Type u_2\ninst‚úù¬π : CategoryTheory.ReflQuiver V\nW : Type u_3\ninst‚úù : CategoryTheory.ReflQuiver W\nF : CategoryTheory.ReflPrefunctor U V\nG : CategoryTheory.ReflPrefunctor V W\nX‚úù Y‚úù : U\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((F.comp G).map f) (G.map (F.map f))","decl":"/-- Composition of morphisms between reflexive quivers. -/\n@[simps!]\ndef comp {U : Type*} [ReflQuiver U] {V : Type*} [ReflQuiver V] {W : Type*} [ReflQuiver W]\n    (F : ReflPrefunctor U V) (G : ReflPrefunctor V W) : ReflPrefunctor U W where\n  __ := F.toPrefunctor.comp G.toPrefunctor\n  map_id _ := by simp [F.map_id, G.map_id]\n\n"}
{"name":"CategoryTheory.ReflPrefunctor.comp_obj","module":"Mathlib.Combinatorics.Quiver.ReflQuiver","initialProofState":"U : Type u_1\ninst‚úù¬≤ : CategoryTheory.ReflQuiver U\nV : Type u_2\ninst‚úù¬π : CategoryTheory.ReflQuiver V\nW : Type u_3\ninst‚úù : CategoryTheory.ReflQuiver W\nF : CategoryTheory.ReflPrefunctor U V\nG : CategoryTheory.ReflPrefunctor V W\nX : U\n‚ä¢ Eq ((F.comp G).obj X) (G.obj (F.obj X))","decl":"/-- Composition of morphisms between reflexive quivers. -/\n@[simps!]\ndef comp {U : Type*} [ReflQuiver U] {V : Type*} [ReflQuiver V] {W : Type*} [ReflQuiver W]\n    (F : ReflPrefunctor U V) (G : ReflPrefunctor V W) : ReflPrefunctor U W where\n  __ := F.toPrefunctor.comp G.toPrefunctor\n  map_id _ := by simp [F.map_id, G.map_id]\n\n"}
{"name":"CategoryTheory.ReflPrefunctor.comp_id","module":"Mathlib.Combinatorics.Quiver.ReflQuiver","initialProofState":"U : Type u_1\nV : Type u_2\ninst‚úù¬π : CategoryTheory.ReflQuiver U\ninst‚úù : CategoryTheory.ReflQuiver V\nF : CategoryTheory.ReflPrefunctor U V\n‚ä¢ Eq (F.comp (CategoryTheory.ReflPrefunctor.id V)) F","decl":"@[simp]\ntheorem comp_id {U V : Type*} [ReflQuiver U] [ReflQuiver V] (F : ReflPrefunctor U V) :\n    F.comp (id _) = F := rfl\n\n"}
{"name":"CategoryTheory.ReflPrefunctor.id_comp","module":"Mathlib.Combinatorics.Quiver.ReflQuiver","initialProofState":"U : Type u_1\nV : Type u_2\ninst‚úù¬π : CategoryTheory.ReflQuiver U\ninst‚úù : CategoryTheory.ReflQuiver V\nF : CategoryTheory.ReflPrefunctor U V\n‚ä¢ Eq ((CategoryTheory.ReflPrefunctor.id U).comp F) F","decl":"@[simp]\ntheorem id_comp {U V : Type*} [ReflQuiver U] [ReflQuiver V] (F : ReflPrefunctor U V) :\n    (id _).comp F = F := rfl\n\n"}
{"name":"CategoryTheory.ReflPrefunctor.comp_assoc","module":"Mathlib.Combinatorics.Quiver.ReflQuiver","initialProofState":"U : Type u_1\nV : Type u_2\nW : Type u_3\nZ : Type u_4\ninst‚úù¬≥ : CategoryTheory.ReflQuiver U\ninst‚úù¬≤ : CategoryTheory.ReflQuiver V\ninst‚úù¬π : CategoryTheory.ReflQuiver W\ninst‚úù : CategoryTheory.ReflQuiver Z\nF : CategoryTheory.ReflPrefunctor U V\nG : CategoryTheory.ReflPrefunctor V W\nH : CategoryTheory.ReflPrefunctor W Z\n‚ä¢ Eq ((F.comp G).comp H) (F.comp (G.comp H))","decl":"@[simp]\ntheorem comp_assoc {U V W Z : Type*} [ReflQuiver U] [ReflQuiver V] [ReflQuiver W] [ReflQuiver Z]\n    (F : ReflPrefunctor U V) (G : ReflPrefunctor V W) (H : ReflPrefunctor W Z) :\n    (F.comp G).comp H = F.comp (G.comp H) := rfl\n\n"}
{"name":"CategoryTheory.ReflPrefunctor.congr_map","module":"Mathlib.Combinatorics.Quiver.ReflQuiver","initialProofState":"U : Type u_1\nV : Type u_2\ninst‚úù¬π : Quiver U\ninst‚úù : Quiver V\nF : Prefunctor U V\nX Y : U\nf g : Quiver.Hom X Y\nh : Eq f g\n‚ä¢ Eq (F.map f) (F.map g)","decl":"theorem congr_map {U V : Type*} [Quiver U] [Quiver V] (F : U ‚•§q V) {X Y : U} {f g : X ‚ü∂ Y}\n    (h : f = g) : F.map f = F.map g := congrArg F.map h\n\n"}
{"name":"CategoryTheory.Functor.toReflPrefunctor_toPrefunctor","module":"Mathlib.Combinatorics.Quiver.ReflQuiver","initialProofState":"C : CategoryTheory.Cat\nD : CategoryTheory.Cat\nF : CategoryTheory.Functor ‚ÜëC ‚ÜëD\n‚ä¢ Eq F.toReflPrefunctor.toPrefunctor F.toPrefunctor","decl":"@[simp]\ntheorem Functor.toReflPrefunctor_toPrefunctor {C D : Cat} (F : C ‚•§ D) :\n    (Functor.toReflPrefunctor F).toPrefunctor = F.toPrefunctor := rfl\n\n"}
