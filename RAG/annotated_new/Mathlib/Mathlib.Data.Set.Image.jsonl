{"name":"Set.preimage_empty","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (Set.preimage f EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem preimage_empty : f ⁻¹' ∅ = ∅ :=\n  rfl\n\n"}
{"name":"Set.preimage_congr","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\ns : Set β\nh : ∀ (x : α), Eq (f x) (g x)\n⊢ Eq (Set.preimage f s) (Set.preimage g s)","decl":"theorem preimage_congr {f g : α → β} {s : Set β} (h : ∀ x : α, f x = g x) : f ⁻¹' s = g ⁻¹' s := by\n  congr with x\n  simp [h]\n\n"}
{"name":"Set.preimage_mono","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns t : Set β\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset (Set.preimage f s) (Set.preimage f t)","decl":"@[gcongr]\ntheorem preimage_mono {s t : Set β} (h : s ⊆ t) : f ⁻¹' s ⊆ f ⁻¹' t := fun _ hx => h hx\n\n"}
{"name":"Set.preimage_univ","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (Set.preimage f Set.univ) Set.univ","decl":"@[simp, mfld_simps]\ntheorem preimage_univ : f ⁻¹' univ = univ :=\n  rfl\n\n"}
{"name":"Set.subset_preimage_univ","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\n⊢ HasSubset.Subset s (Set.preimage f Set.univ)","decl":"theorem subset_preimage_univ {s : Set α} : s ⊆ f ⁻¹' univ :=\n  subset_univ _\n\n"}
{"name":"Set.preimage_inter","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns t : Set β\n⊢ Eq (Set.preimage f (Inter.inter s t)) (Inter.inter (Set.preimage f s) (Set.preimage f t))","decl":"@[simp, mfld_simps]\ntheorem preimage_inter {s t : Set β} : f ⁻¹' (s ∩ t) = f ⁻¹' s ∩ f ⁻¹' t :=\n  rfl\n\n"}
{"name":"Set.preimage_union","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns t : Set β\n⊢ Eq (Set.preimage f (Union.union s t)) (Union.union (Set.preimage f s) (Set.preimage f t))","decl":"@[simp]\ntheorem preimage_union {s t : Set β} : f ⁻¹' (s ∪ t) = f ⁻¹' s ∪ f ⁻¹' t :=\n  rfl\n\n"}
{"name":"Set.preimage_compl","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\n⊢ Eq (Set.preimage f (HasCompl.compl s)) (HasCompl.compl (Set.preimage f s))","decl":"@[simp]\ntheorem preimage_compl {s : Set β} : f ⁻¹' sᶜ = (f ⁻¹' s)ᶜ :=\n  rfl\n\n"}
{"name":"Set.preimage_diff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns t : Set β\n⊢ Eq (Set.preimage f (SDiff.sdiff s t)) (SDiff.sdiff (Set.preimage f s) (Set.preimage f t))","decl":"@[simp]\ntheorem preimage_diff (f : α → β) (s t : Set β) : f ⁻¹' (s \\ t) = f ⁻¹' s \\ f ⁻¹' t :=\n  rfl\n\n"}
{"name":"Set.preimage_symmDiff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns t : Set β\n⊢ Eq (Set.preimage f (symmDiff s t)) (symmDiff (Set.preimage f s) (Set.preimage f t))","decl":"open scoped symmDiff in\n@[simp]\nlemma preimage_symmDiff {f : α → β} (s t : Set β) : f ⁻¹' (s ∆ t) = (f ⁻¹' s) ∆ (f ⁻¹' t) :=\n  rfl\n\n"}
{"name":"Set.preimage_ite","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns t₁ t₂ : Set β\n⊢ Eq (Set.preimage f (s.ite t₁ t₂)) ((Set.preimage f s).ite (Set.preimage f t₁) (Set.preimage f t₂))","decl":"@[simp]\ntheorem preimage_ite (f : α → β) (s t₁ t₂ : Set β) :\n    f ⁻¹' s.ite t₁ t₂ = (f ⁻¹' s).ite (f ⁻¹' t₁) (f ⁻¹' t₂) :=\n  rfl\n\n"}
{"name":"Set.preimage_setOf_eq","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\np : α → Prop\nf : β → α\n⊢ Eq (Set.preimage f (setOf fun a => p a)) (setOf fun a => p (f a))","decl":"@[simp]\ntheorem preimage_setOf_eq {p : α → Prop} {f : β → α} : f ⁻¹' { a | p a } = { a | p (f a) } :=\n  rfl\n\n"}
{"name":"Set.preimage_id_eq","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\n⊢ Eq (Set.preimage id) id","decl":"@[simp]\ntheorem preimage_id_eq : preimage (id : α → α) = id :=\n  rfl\n\n"}
{"name":"Set.preimage_id","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Set.preimage id s) s","decl":"@[mfld_simps]\ntheorem preimage_id {s : Set α} : id ⁻¹' s = s :=\n  rfl\n\n"}
{"name":"Set.preimage_id'","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Set.preimage (fun x => x) s) s","decl":"@[simp, mfld_simps]\ntheorem preimage_id' {s : Set α} : (fun x => x) ⁻¹' s = s :=\n  rfl\n\n"}
{"name":"Set.preimage_const_of_mem","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nb : β\ns : Set β\nh : Membership.mem s b\n⊢ Eq (Set.preimage (fun x => b) s) Set.univ","decl":"@[simp]\ntheorem preimage_const_of_mem {b : β} {s : Set β} (h : b ∈ s) : (fun _ : α => b) ⁻¹' s = univ :=\n  eq_univ_of_forall fun _ => h\n\n"}
{"name":"Set.preimage_const_of_not_mem","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nb : β\ns : Set β\nh : Not (Membership.mem s b)\n⊢ Eq (Set.preimage (fun x => b) s) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem preimage_const_of_not_mem {b : β} {s : Set β} (h : b ∉ s) : (fun _ : α => b) ⁻¹' s = ∅ :=\n  eq_empty_of_subset_empty fun _ hx => h hx\n\n"}
{"name":"Set.preimage_const","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nb : β\ns : Set β\ninst✝ : Decidable (Membership.mem s b)\n⊢ Eq (Set.preimage (fun x => b) s) (ite (Membership.mem s b) Set.univ EmptyCollection.emptyCollection)","decl":"theorem preimage_const (b : β) (s : Set β) [Decidable (b ∈ s)] :\n    (fun _ : α => b) ⁻¹' s = if b ∈ s then univ else ∅ := by\n  split_ifs with hb\n  exacts [preimage_const_of_mem hb, preimage_const_of_not_mem hb]\n\n"}
{"name":"Set.exists_eq_const_of_preimage_singleton","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Nonempty β\nf : α → β\nhf : ∀ (b : β), Or (Eq (Set.preimage f (Singleton.singleton b)) EmptyCollection.emptyCollection) (Eq (Set.preimage f (Singleton.singleton b)) Set.univ)\n⊢ Exists fun b => Eq f (Function.const α b)","decl":"/-- If preimage of each singleton under `f : α → β` is either empty or the whole type,\nthen `f` is a constant. -/\nlemma exists_eq_const_of_preimage_singleton [Nonempty β] {f : α → β}\n    (hf : ∀ b : β, f ⁻¹' {b} = ∅ ∨ f ⁻¹' {b} = univ) : ∃ b, f = const α b := by\n  rcases em (∃ b, f ⁻¹' {b} = univ) with ⟨b, hb⟩ | hf'\n  · exact ⟨b, funext fun x ↦ eq_univ_iff_forall.1 hb x⟩\n  · have : ∀ x b, f x ≠ b := fun x b ↦\n      eq_empty_iff_forall_not_mem.1 ((hf b).resolve_right fun h ↦ hf' ⟨b, h⟩) x\n    exact ⟨Classical.arbitrary β, funext fun x ↦ absurd rfl (this x _)⟩\n\n"}
{"name":"Set.preimage_comp","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\ng : β → γ\ns : Set γ\n⊢ Eq (Set.preimage (Function.comp g f) s) (Set.preimage f (Set.preimage g s))","decl":"theorem preimage_comp {s : Set γ} : g ∘ f ⁻¹' s = f ⁻¹' (g ⁻¹' s) :=\n  rfl\n\n"}
{"name":"Set.preimage_comp_eq","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\ng : β → γ\n⊢ Eq (Set.preimage (Function.comp g f)) (Function.comp (Set.preimage f) (Set.preimage g))","decl":"theorem preimage_comp_eq : preimage (g ∘ f) = preimage f ∘ preimage g :=\n  rfl\n\n"}
{"name":"Set.preimage_iterate_eq","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nf : α → α\nn : Nat\n⊢ Eq (Set.preimage (Nat.iterate f n)) (Nat.iterate (Set.preimage f) n)","decl":"theorem preimage_iterate_eq {f : α → α} {n : ℕ} : Set.preimage f^[n] = (Set.preimage f)^[n] := by\n  induction n with\n  | zero => simp\n  | succ n ih => rw [iterate_succ, iterate_succ', preimage_comp_eq, ih]\n\n"}
{"name":"Set.preimage_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ng : β → γ\nf : α → β\ns : Set γ\n⊢ Eq (Set.preimage f (Set.preimage g s)) (Set.preimage (fun x => g (f x)) s)","decl":"theorem preimage_preimage {g : β → γ} {f : α → β} {s : Set γ} :\n    f ⁻¹' (g ⁻¹' s) = (fun x => g (f x)) ⁻¹' s :=\n  preimage_comp.symm\n\n"}
{"name":"Set.eq_preimage_subtype_val_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\np : α → Prop\ns : Set (Subtype p)\nt : Set α\n⊢ Iff (Eq s (Set.preimage Subtype.val t)) (∀ (x : α) (h : p x), Iff (Membership.mem s ⟨x, h⟩) (Membership.mem t x))","decl":"theorem eq_preimage_subtype_val_iff {p : α → Prop} {s : Set (Subtype p)} {t : Set α} :\n    s = Subtype.val ⁻¹' t ↔ ∀ (x) (h : p x), (⟨x, h⟩ : Subtype p) ∈ s ↔ x ∈ t :=\n  ⟨fun s_eq x h => by\n    rw [s_eq]\n    simp, fun h => ext fun ⟨x, hx⟩ => by simp [h]⟩\n\n"}
{"name":"Set.nonempty_of_nonempty_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set β\nf : α → β\nhf : (Set.preimage f s).Nonempty\n⊢ s.Nonempty","decl":"theorem nonempty_of_nonempty_preimage {s : Set β} {f : α → β} (hf : (f ⁻¹' s).Nonempty) :\n    s.Nonempty :=\n  let ⟨x, hx⟩ := hf\n  ⟨f x, hx⟩\n\n"}
{"name":"Set.preimage_singleton_true","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\np : α → Prop\n⊢ Eq (Set.preimage p (Singleton.singleton True)) (setOf fun a => p a)","decl":"@[simp] theorem preimage_singleton_true (p : α → Prop) : p ⁻¹' {True} = {a | p a} := by ext; simp\n\n"}
{"name":"Set.preimage_singleton_false","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\np : α → Prop\n⊢ Eq (Set.preimage p (Singleton.singleton False)) (setOf fun a => Not (p a))","decl":"@[simp] theorem preimage_singleton_false (p : α → Prop) : p ⁻¹' {False} = {a | ¬p a} := by ext; simp\n\n"}
{"name":"Set.preimage_subtype_coe_eq_compl","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns u v : Set α\nhsuv : HasSubset.Subset s (Union.union u v)\nH : Eq (Inter.inter s (Inter.inter u v)) EmptyCollection.emptyCollection\n⊢ Eq (Set.preimage Subtype.val u) (HasCompl.compl (Set.preimage Subtype.val v))","decl":"theorem preimage_subtype_coe_eq_compl {s u v : Set α} (hsuv : s ⊆ u ∪ v)\n    (H : s ∩ (u ∩ v) = ∅) : ((↑) : s → α) ⁻¹' u = ((↑) ⁻¹' v)ᶜ := by\n  ext ⟨x, x_in_s⟩\n  constructor\n  · intro x_in_u x_in_v\n    exact eq_empty_iff_forall_not_mem.mp H x ⟨x_in_s, ⟨x_in_u, x_in_v⟩⟩\n  · intro hx\n    exact Or.elim (hsuv x_in_s) id fun hx' => hx.elim hx'\n\n"}
{"name":"Set.preimage_subset","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\nt : Set α\nhs : HasSubset.Subset s (Set.image f t)\nhf : Set.InjOn f (Set.preimage f s)\n⊢ HasSubset.Subset (Set.preimage f s) t","decl":"lemma preimage_subset {s t} (hs : s ⊆ f '' t) (hf : Set.InjOn f (f ⁻¹' s)) : f ⁻¹' s ⊆ t := by\n  rintro a ha\n  obtain ⟨b, hb, hba⟩ := hs ha\n  rwa [hf ha _ hba.symm]\n  simpa [hba]\n\n"}
{"name":"Set.image_eta","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\n⊢ Eq (Set.image f s) (Set.image (fun x => f x) s)","decl":"theorem image_eta (f : α → β) : f '' s = (fun x => f x) '' s :=\n  rfl\n\n"}
{"name":"Function.Injective.mem_set_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\ns : Set α\na : α\n⊢ Iff (Membership.mem (Set.image f s) (f a)) (Membership.mem s a)","decl":"theorem _root_.Function.Injective.mem_set_image {f : α → β} (hf : Injective f) {s : Set α} {a : α} :\n    f a ∈ f '' s ↔ a ∈ s :=\n  ⟨fun ⟨_, hb, Eq⟩ => hf Eq ▸ hb, mem_image_of_mem f⟩\n\n"}
{"name":"Set.preimage_subset_of_surjOn","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\nt : Set β\nhf : Function.Injective f\nh : Set.SurjOn f s t\n⊢ HasSubset.Subset (Set.preimage f t) s","decl":"lemma preimage_subset_of_surjOn {t : Set β} (hf : Injective f) (h : SurjOn f s t) :\n    f ⁻¹' t ⊆ s := fun _ hx ↦\n  hf.mem_set_image.1 <| h hx\n\n"}
{"name":"Set.forall_mem_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\np : β → Prop\n⊢ Iff (∀ (y : β), Membership.mem (Set.image f s) y → p y) (∀ ⦃x : α⦄, Membership.mem s x → p (f x))","decl":"theorem forall_mem_image {f : α → β} {s : Set α} {p : β → Prop} :\n    (∀ y ∈ f '' s, p y) ↔ ∀ ⦃x⦄, x ∈ s → p (f x) := by simp\n\n"}
{"name":"Set.exists_mem_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\np : β → Prop\n⊢ Iff (Exists fun y => And (Membership.mem (Set.image f s) y) (p y)) (Exists fun x => And (Membership.mem s x) (p (f x)))","decl":"theorem exists_mem_image {f : α → β} {s : Set α} {p : β → Prop} :\n    (∃ y ∈ f '' s, p y) ↔ ∃ x ∈ s, p (f x) := by simp\n\n-- Porting note: used to be `safe`\n"}
{"name":"Set.image_congr","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\ns : Set α\nh : ∀ (a : α), Membership.mem s a → Eq (f a) (g a)\n⊢ Eq (Set.image f s) (Set.image g s)","decl":"@[congr]\ntheorem image_congr {f g : α → β} {s : Set α} (h : ∀ a ∈ s, f a = g a) : f '' s = g '' s := by\n  ext x\n  exact exists_congr fun a ↦ and_congr_right fun ha ↦ by rw [h a ha]\n\n"}
{"name":"Set.image_congr'","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\ns : Set α\nh : ∀ (x : α), Eq (f x) (g x)\n⊢ Eq (Set.image f s) (Set.image g s)","decl":"/-- A common special case of `image_congr` -/\ntheorem image_congr' {f g : α → β} {s : Set α} (h : ∀ x : α, f x = g x) : f '' s = g '' s :=\n  image_congr fun x _ => h x\n\n"}
{"name":"Set.image_mono","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns t : Set α\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset (Set.image f s) (Set.image f t)","decl":"@[gcongr]\nlemma image_mono (h : s ⊆ t) : f '' s ⊆ f '' t := by\n  rintro - ⟨a, ha, rfl⟩; exact mem_image_of_mem f (h ha)\n\n"}
{"name":"Set.image_comp","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : β → γ\ng : α → β\na : Set α\n⊢ Eq (Set.image (Function.comp f g) a) (Set.image f (Set.image g a))","decl":"theorem image_comp (f : β → γ) (g : α → β) (a : Set α) : f ∘ g '' a = f '' (g '' a) := by aesop\n\n"}
{"name":"Set.image_comp_eq","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\ng : β → γ\n⊢ Eq (Set.image (Function.comp g f)) (Function.comp (Set.image g) (Set.image f))","decl":"theorem image_comp_eq {g : β → γ} : image (g ∘ f) = image g ∘ image f := by ext; simp\n\n"}
{"name":"Set.image_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ng : β → γ\nf : α → β\ns : Set α\n⊢ Eq (Set.image g (Set.image f s)) (Set.image (fun x => g (f x)) s)","decl":"/-- A variant of `image_comp`, useful for rewriting -/\ntheorem image_image (g : β → γ) (f : α → β) (s : Set α) : g '' (f '' s) = (fun x => g (f x)) '' s :=\n  (image_comp g f s).symm\n\n"}
{"name":"Set.image_comm","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nβ' : Type u_5\nf : β → γ\ng : α → β\nf' : α → β'\ng' : β' → γ\nh_comm : ∀ (a : α), Eq (f (g a)) (g' (f' a))\n⊢ Eq (Set.image f (Set.image g s)) (Set.image g' (Set.image f' s))","decl":"theorem image_comm {β'} {f : β → γ} {g : α → β} {f' : α → β'} {g' : β' → γ}\n    (h_comm : ∀ a, f (g a) = g' (f' a)) : (s.image g).image f = (s.image f').image g' := by\n  simp_rw [image_image, h_comm]\n\n"}
{"name":"Function.Semiconj.set_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nga : α → α\ngb : β → β\nh : Function.Semiconj f ga gb\n⊢ Function.Semiconj (Set.image f) (Set.image ga) (Set.image gb)","decl":"theorem _root_.Function.Semiconj.set_image {f : α → β} {ga : α → α} {gb : β → β}\n    (h : Function.Semiconj f ga gb) : Function.Semiconj (image f) (image ga) (image gb) := fun _ =>\n  image_comm h\n\n"}
{"name":"Function.Commute.set_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nf g : α → α\nh : Function.Commute f g\n⊢ Function.Commute (Set.image f) (Set.image g)","decl":"theorem _root_.Function.Commute.set_image {f g : α → α} (h : Function.Commute f g) :\n    Function.Commute (image f) (image g) :=\n  Function.Semiconj.set_image h\n\n"}
{"name":"Set.image_subset","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\na b : Set α\nf : α → β\nh : HasSubset.Subset a b\n⊢ HasSubset.Subset (Set.image f a) (Set.image f b)","decl":"/-- Image is monotone with respect to `⊆`. See `Set.monotone_image` for the statement in\nterms of `≤`. -/\n@[gcongr]\ntheorem image_subset {a b : Set α} (f : α → β) (h : a ⊆ b) : f '' a ⊆ f '' b := by\n  simp only [subset_def, mem_image]\n  exact fun x => fun ⟨w, h1, h2⟩ => ⟨w, h h1, h2⟩\n\n"}
{"name":"Set.monotone_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Monotone (Set.image f)","decl":"/-- `Set.image` is monotone. See `Set.image_subset` for the statement in terms of `⊆`. -/\nlemma monotone_image {f : α → β} : Monotone (image f) := fun _ _ => image_subset _\n\n"}
{"name":"Set.image_union","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns t : Set α\n⊢ Eq (Set.image f (Union.union s t)) (Union.union (Set.image f s) (Set.image f t))","decl":"theorem image_union (f : α → β) (s t : Set α) : f '' (s ∪ t) = f '' s ∪ f '' t :=\n  ext fun x =>\n    ⟨by rintro ⟨a, h | h, rfl⟩ <;> [left; right] <;> exact ⟨_, h, rfl⟩, by\n      rintro (⟨a, h, rfl⟩ | ⟨a, h, rfl⟩) <;> refine ⟨_, ?_, rfl⟩\n      · exact mem_union_left t h\n      · exact mem_union_right s h⟩\n\n"}
{"name":"Set.image_empty","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (Set.image f EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem image_empty (f : α → β) : f '' ∅ = ∅ := by\n  ext\n  simp\n\n"}
{"name":"Set.image_inter_subset","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns t : Set α\n⊢ HasSubset.Subset (Set.image f (Inter.inter s t)) (Inter.inter (Set.image f s) (Set.image f t))","decl":"theorem image_inter_subset (f : α → β) (s t : Set α) : f '' (s ∩ t) ⊆ f '' s ∩ f '' t :=\n  subset_inter (image_subset _ inter_subset_left) (image_subset _ inter_subset_right)\n\n"}
{"name":"Set.image_inter_on","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns t : Set α\nh : ∀ (x : α), Membership.mem t x → ∀ (y : α), Membership.mem s y → Eq (f x) (f y) → Eq x y\n⊢ Eq (Set.image f (Inter.inter s t)) (Inter.inter (Set.image f s) (Set.image f t))","decl":"theorem image_inter_on {f : α → β} {s t : Set α} (h : ∀ x ∈ t, ∀ y ∈ s, f x = f y → x = y) :\n    f '' (s ∩ t) = f '' s ∩ f '' t :=\n  (image_inter_subset _ _ _).antisymm\n    fun b ⟨⟨a₁, ha₁, h₁⟩, ⟨a₂, ha₂, h₂⟩⟩ ↦\n      have : a₂ = a₁ := h _ ha₂ _ ha₁ (by simp [*])\n      ⟨a₁, ⟨ha₁, this ▸ ha₂⟩, h₁⟩\n\n"}
{"name":"Set.image_inter","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns t : Set α\nH : Function.Injective f\n⊢ Eq (Set.image f (Inter.inter s t)) (Inter.inter (Set.image f s) (Set.image f t))","decl":"theorem image_inter {f : α → β} {s t : Set α} (H : Injective f) : f '' (s ∩ t) = f '' s ∩ f '' t :=\n  image_inter_on fun _ _ _ _ h => H h\n\n"}
{"name":"Set.image_univ_of_surjective","module":"Mathlib.Data.Set.Image","initialProofState":"β : Type u_2\nι : Type u_5\nf : ι → β\nH : Function.Surjective f\n⊢ Eq (Set.image f Set.univ) Set.univ","decl":"theorem image_univ_of_surjective {ι : Type*} {f : ι → β} (H : Surjective f) : f '' univ = univ :=\n  eq_univ_of_forall <| by simpa [image]\n\n"}
{"name":"Set.image_singleton","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na : α\n⊢ Eq (Set.image f (Singleton.singleton a)) (Singleton.singleton (f a))","decl":"@[simp]\ntheorem image_singleton {f : α → β} {a : α} : f '' {a} = {f a} := by\n  ext\n  simp [image, eq_comm]\n\n"}
{"name":"Set.Nonempty.image_const","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nhs : s.Nonempty\na : β\n⊢ Eq (Set.image (fun x => a) s) (Singleton.singleton a)","decl":"@[simp]\ntheorem Nonempty.image_const {s : Set α} (hs : s.Nonempty) (a : β) : (fun _ => a) '' s = {a} :=\n  ext fun _ =>\n    ⟨fun ⟨_, _, h⟩ => h ▸ mem_singleton _, fun h =>\n      (eq_of_mem_singleton h).symm ▸ hs.imp fun _ hy => ⟨hy, rfl⟩⟩\n\n"}
{"name":"Set.image_eq_empty","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_5\nβ : Type u_6\nf : α → β\ns : Set α\n⊢ Iff (Eq (Set.image f s) EmptyCollection.emptyCollection) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp, mfld_simps]\ntheorem image_eq_empty {α β} {f : α → β} {s : Set α} : f '' s = ∅ ↔ s = ∅ := by\n  simp only [eq_empty_iff_forall_not_mem]\n  exact ⟨fun H a ha => H _ ⟨_, ha, rfl⟩, fun H b ⟨_, ha, _⟩ => H _ ha⟩\n\n-- Porting note: `compl` is already defined in `Data.Set.Defs`\n"}
{"name":"Set.preimage_compl_eq_image_compl","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ninst✝ : BooleanAlgebra α\nS : Set α\n⊢ Eq (Set.preimage HasCompl.compl S) (Set.image HasCompl.compl S)","decl":"theorem preimage_compl_eq_image_compl [BooleanAlgebra α] (S : Set α) :\n    HasCompl.compl ⁻¹' S = HasCompl.compl '' S :=\n  Set.ext fun x =>\n    ⟨fun h => ⟨xᶜ, h, compl_compl x⟩, fun h =>\n      Exists.elim h fun _ hy => (compl_eq_comm.mp hy.2).symm.subst hy.1⟩\n\n"}
{"name":"Set.mem_compl_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ninst✝ : BooleanAlgebra α\nt : α\nS : Set α\n⊢ Iff (Membership.mem (Set.image HasCompl.compl S) t) (Membership.mem S (HasCompl.compl t))","decl":"theorem mem_compl_image [BooleanAlgebra α] (t : α) (S : Set α) :\n    t ∈ HasCompl.compl '' S ↔ tᶜ ∈ S := by\n  simp [← preimage_compl_eq_image_compl]\n\n"}
{"name":"Set.image_id_eq","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\n⊢ Eq (Set.image id) id","decl":"@[simp]\ntheorem image_id_eq : image (id : α → α) = id := by ext; simp\n\n"}
{"name":"Set.image_id'","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Set.image (fun x => x) s) s","decl":"/-- A variant of `image_id` -/\n@[simp]\ntheorem image_id' (s : Set α) : (fun x => x) '' s = s := by\n  ext\n  simp\n\n"}
{"name":"Set.image_id","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Set.image id s) s","decl":"theorem image_id (s : Set α) : id '' s = s := by simp\n\n"}
{"name":"Set.image_iterate_eq","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nf : α → α\nn : Nat\n⊢ Eq (Set.image (Nat.iterate f n)) (Nat.iterate (Set.image f) n)","decl":"lemma image_iterate_eq {f : α → α} {n : ℕ} : image (f^[n]) = (image f)^[n] := by\n  induction n with\n  | zero => simp\n  | succ n ih => rw [iterate_succ', iterate_succ', ← ih, image_comp_eq]\n\n"}
{"name":"Set.compl_compl_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ninst✝ : BooleanAlgebra α\nS : Set α\n⊢ Eq (Set.image HasCompl.compl (Set.image HasCompl.compl S)) S","decl":"theorem compl_compl_image [BooleanAlgebra α] (S : Set α) :\n    HasCompl.compl '' (HasCompl.compl '' S) = S := by\n  rw [← image_comp, compl_comp_compl, image_id]\n\n"}
{"name":"Set.image_insert_eq","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na : α\ns : Set α\n⊢ Eq (Set.image f (Insert.insert a s)) (Insert.insert (f a) (Set.image f s))","decl":"theorem image_insert_eq {f : α → β} {a : α} {s : Set α} :\n    f '' insert a s = insert (f a) (f '' s) := by\n  ext\n  simp [and_or_left, exists_or, eq_comm, or_comm, and_comm]\n\n"}
{"name":"Set.image_pair","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na b : α\n⊢ Eq (Set.image f (Insert.insert a (Singleton.singleton b))) (Insert.insert (f a) (Singleton.singleton (f b)))","decl":"theorem image_pair (f : α → β) (a b : α) : f '' {a, b} = {f a, f b} := by\n  simp only [image_insert_eq, image_singleton]\n\n"}
{"name":"Set.image_subset_preimage_of_inverse","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ng : β → α\nI : Function.LeftInverse g f\ns : Set α\n⊢ HasSubset.Subset (Set.image f s) (Set.preimage g s)","decl":"theorem image_subset_preimage_of_inverse {f : α → β} {g : β → α} (I : LeftInverse g f) (s : Set α) :\n    f '' s ⊆ g ⁻¹' s := fun _ ⟨a, h, e⟩ => e ▸ ((I a).symm ▸ h : g (f a) ∈ s)\n\n"}
{"name":"Set.preimage_subset_image_of_inverse","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ng : β → α\nI : Function.LeftInverse g f\ns : Set β\n⊢ HasSubset.Subset (Set.preimage f s) (Set.image g s)","decl":"theorem preimage_subset_image_of_inverse {f : α → β} {g : β → α} (I : LeftInverse g f) (s : Set β) :\n    f ⁻¹' s ⊆ g '' s := fun b h => ⟨f b, h, I b⟩\n\n"}
{"name":"Set.image_eq_preimage_of_inverse","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ng : β → α\nh₁ : Function.LeftInverse g f\nh₂ : Function.RightInverse g f\n⊢ Eq (Set.image f) (Set.preimage g)","decl":"theorem image_eq_preimage_of_inverse {f : α → β} {g : β → α} (h₁ : LeftInverse g f)\n    (h₂ : RightInverse g f) : image f = preimage g :=\n  funext fun s =>\n    Subset.antisymm (image_subset_preimage_of_inverse h₁ s) (preimage_subset_image_of_inverse h₂ s)\n\n"}
{"name":"Set.mem_image_iff_of_inverse","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ng : β → α\nb : β\ns : Set α\nh₁ : Function.LeftInverse g f\nh₂ : Function.RightInverse g f\n⊢ Iff (Membership.mem (Set.image f s) b) (Membership.mem s (g b))","decl":"theorem mem_image_iff_of_inverse {f : α → β} {g : β → α} {b : β} {s : Set α} (h₁ : LeftInverse g f)\n    (h₂ : RightInverse g f) : b ∈ f '' s ↔ g b ∈ s := by\n  rw [image_eq_preimage_of_inverse h₁ h₂]; rfl\n\n"}
{"name":"Set.image_compl_subset","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\nH : Function.Injective f\n⊢ HasSubset.Subset (Set.image f (HasCompl.compl s)) (HasCompl.compl (Set.image f s))","decl":"theorem image_compl_subset {f : α → β} {s : Set α} (H : Injective f) : f '' sᶜ ⊆ (f '' s)ᶜ :=\n  Disjoint.subset_compl_left <| by simp [disjoint_iff_inf_le, ← image_inter H]\n\n"}
{"name":"Set.subset_image_compl","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\nH : Function.Surjective f\n⊢ HasSubset.Subset (HasCompl.compl (Set.image f s)) (Set.image f (HasCompl.compl s))","decl":"theorem subset_image_compl {f : α → β} {s : Set α} (H : Surjective f) : (f '' s)ᶜ ⊆ f '' sᶜ :=\n  compl_subset_iff_union.2 <| by\n    rw [← image_union]\n    simp [image_univ_of_surjective H]\n\n"}
{"name":"Set.image_compl_eq","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\nH : Function.Bijective f\n⊢ Eq (Set.image f (HasCompl.compl s)) (HasCompl.compl (Set.image f s))","decl":"theorem image_compl_eq {f : α → β} {s : Set α} (H : Bijective f) : f '' sᶜ = (f '' s)ᶜ :=\n  Subset.antisymm (image_compl_subset H.1) (subset_image_compl H.2)\n\n"}
{"name":"Set.subset_image_diff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns t : Set α\n⊢ HasSubset.Subset (SDiff.sdiff (Set.image f s) (Set.image f t)) (Set.image f (SDiff.sdiff s t))","decl":"theorem subset_image_diff (f : α → β) (s t : Set α) : f '' s \\ f '' t ⊆ f '' (s \\ t) := by\n  rw [diff_subset_iff, ← image_union, union_diff_self]\n  exact image_subset f subset_union_right\n\n"}
{"name":"Set.subset_image_symmDiff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns t : Set α\n⊢ HasSubset.Subset (symmDiff (Set.image f s) (Set.image f t)) (Set.image f (symmDiff s t))","decl":"open scoped symmDiff in\ntheorem subset_image_symmDiff : (f '' s) ∆ (f '' t) ⊆ f '' s ∆ t :=\n  (union_subset_union (subset_image_diff _ _ _) <| subset_image_diff _ _ _).trans\n    (superset_of_eq (image_union _ _ _))\n\n"}
{"name":"Set.image_diff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\ns t : Set α\n⊢ Eq (Set.image f (SDiff.sdiff s t)) (SDiff.sdiff (Set.image f s) (Set.image f t))","decl":"theorem image_diff {f : α → β} (hf : Injective f) (s t : Set α) : f '' (s \\ t) = f '' s \\ f '' t :=\n  Subset.antisymm\n    (Subset.trans (image_inter_subset _ _ _) <| inter_subset_inter_right _ <| image_compl_subset hf)\n    (subset_image_diff f s t)\n\n"}
{"name":"Set.image_symmDiff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\ns t : Set α\n⊢ Eq (Set.image f (symmDiff s t)) (symmDiff (Set.image f s) (Set.image f t))","decl":"open scoped symmDiff in\ntheorem image_symmDiff (hf : Injective f) (s t : Set α) : f '' s ∆ t = (f '' s) ∆ (f '' t) := by\n  simp_rw [Set.symmDiff_def, image_union, image_diff hf]\n\n"}
{"name":"Set.Nonempty.image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\na✝ : s.Nonempty\n⊢ (Set.image f s).Nonempty","decl":"theorem Nonempty.image (f : α → β) {s : Set α} : s.Nonempty → (f '' s).Nonempty\n  | ⟨x, hx⟩ => ⟨f x, mem_image_of_mem f hx⟩\n\n"}
{"name":"Set.Nonempty.of_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\na✝ : (Set.image f s).Nonempty\n⊢ s.Nonempty","decl":"theorem Nonempty.of_image {f : α → β} {s : Set α} : (f '' s).Nonempty → s.Nonempty\n  | ⟨_, x, hx, _⟩ => ⟨x, hx⟩\n\n"}
{"name":"Set.image_nonempty","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\n⊢ Iff (Set.image f s).Nonempty s.Nonempty","decl":"@[simp]\ntheorem image_nonempty {f : α → β} {s : Set α} : (f '' s).Nonempty ↔ s.Nonempty :=\n  ⟨Nonempty.of_image, fun h => h.image f⟩\n\n"}
{"name":"Set.Nonempty.preimage","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set β\nhs : s.Nonempty\nf : α → β\nhf : Function.Surjective f\n⊢ (Set.preimage f s).Nonempty","decl":"theorem Nonempty.preimage {s : Set β} (hs : s.Nonempty) {f : α → β} (hf : Surjective f) :\n    (f ⁻¹' s).Nonempty :=\n  let ⟨y, hy⟩ := hs\n  let ⟨x, hx⟩ := hf y\n  ⟨x, mem_preimage.2 <| hx.symm ▸ hy⟩\n\n"}
{"name":"Set.instNonemptyElemImage","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\ninst✝ : Nonempty ↑s\n⊢ Nonempty ↑(Set.image f s)","decl":"instance (f : α → β) (s : Set α) [Nonempty s] : Nonempty (f '' s) :=\n  (Set.Nonempty.image f .of_subtype).to_subtype\n\n"}
{"name":"Set.image_subset_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\n⊢ Iff (HasSubset.Subset (Set.image f s) t) (HasSubset.Subset s (Set.preimage f t))","decl":"/-- image and preimage are a Galois connection -/\n@[simp]\ntheorem image_subset_iff {s : Set α} {t : Set β} {f : α → β} : f '' s ⊆ t ↔ s ⊆ f ⁻¹' t :=\n  forall_mem_image\n\n"}
{"name":"Set.image_preimage_subset","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\n⊢ HasSubset.Subset (Set.image f (Set.preimage f s)) s","decl":"theorem image_preimage_subset (f : α → β) (s : Set β) : f '' (f ⁻¹' s) ⊆ s :=\n  image_subset_iff.2 Subset.rfl\n\n"}
{"name":"Set.subset_preimage_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\n⊢ HasSubset.Subset s (Set.preimage f (Set.image f s))","decl":"theorem subset_preimage_image (f : α → β) (s : Set α) : s ⊆ f ⁻¹' (f '' s) := fun _ =>\n  mem_image_of_mem f\n\n"}
{"name":"Set.preimage_image_univ","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (Set.preimage f (Set.image f Set.univ)) Set.univ","decl":"theorem preimage_image_univ {f : α → β} : f ⁻¹' (f '' univ) = univ :=\n  Subset.antisymm (fun _ _ => trivial) (subset_preimage_image f univ)\n\n"}
{"name":"Set.preimage_image_eq","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\nh : Function.Injective f\n⊢ Eq (Set.preimage f (Set.image f s)) s","decl":"@[simp]\ntheorem preimage_image_eq {f : α → β} (s : Set α) (h : Injective f) : f ⁻¹' (f '' s) = s :=\n  Subset.antisymm (fun _ ⟨_, hy, e⟩ => h e ▸ hy) (subset_preimage_image f s)\n\n"}
{"name":"Set.image_preimage_eq","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\nh : Function.Surjective f\n⊢ Eq (Set.image f (Set.preimage f s)) s","decl":"@[simp]\ntheorem image_preimage_eq {f : α → β} (s : Set β) (h : Surjective f) : f '' (f ⁻¹' s) = s :=\n  Subset.antisymm (image_preimage_subset f s) fun x hx =>\n    let ⟨y, e⟩ := h x\n    ⟨y, (e.symm ▸ hx : f y ∈ s), e⟩\n\n"}
{"name":"Set.Nonempty.subset_preimage_const","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nhs : s.Nonempty\nt : Set β\na : β\n⊢ Iff (HasSubset.Subset s (Set.preimage (fun x => a) t)) (Membership.mem t a)","decl":"@[simp]\ntheorem Nonempty.subset_preimage_const {s : Set α} (hs : Set.Nonempty s) (t : Set β) (a : β) :\n    s ⊆ (fun _ => a) ⁻¹' t ↔ a ∈ t := by\n  rw [← image_subset_iff, hs.image_const, singleton_subset_iff]\n\n"}
{"name":"Set.preimage_eq_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns t : Set α\nf : β → α\nhf : Function.Surjective f\n⊢ Iff (Eq (Set.preimage f s) (Set.preimage f t)) (Eq s t)","decl":"@[simp]\ntheorem preimage_eq_preimage {f : β → α} (hf : Surjective f) : f ⁻¹' s = f ⁻¹' t ↔ s = t :=\n  Iff.intro\n    fun eq => by rw [← image_preimage_eq s hf, ← image_preimage_eq t hf, eq]\n    fun eq => eq ▸ rfl\n\n"}
{"name":"Set.image_inter_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\nt : Set β\n⊢ Eq (Set.image f (Inter.inter s (Set.preimage f t))) (Inter.inter (Set.image f s) t)","decl":"theorem image_inter_preimage (f : α → β) (s : Set α) (t : Set β) :\n    f '' (s ∩ f ⁻¹' t) = f '' s ∩ t := by\n  apply Subset.antisymm\n  · calc\n      f '' (s ∩ f ⁻¹' t) ⊆ f '' s ∩ f '' (f ⁻¹' t) := image_inter_subset _ _ _\n      _ ⊆ f '' s ∩ t := inter_subset_inter_right _ (image_preimage_subset f t)\n  · rintro _ ⟨⟨x, h', rfl⟩, h⟩\n    exact ⟨x, ⟨h', h⟩, rfl⟩\n\n"}
{"name":"Set.image_preimage_inter","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\nt : Set β\n⊢ Eq (Set.image f (Inter.inter (Set.preimage f t) s)) (Inter.inter t (Set.image f s))","decl":"theorem image_preimage_inter (f : α → β) (s : Set α) (t : Set β) :\n    f '' (f ⁻¹' t ∩ s) = t ∩ f '' s := by simp only [inter_comm, image_inter_preimage]\n\n"}
{"name":"Set.image_inter_nonempty_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\nt : Set β\n⊢ Iff (Inter.inter (Set.image f s) t).Nonempty (Inter.inter s (Set.preimage f t)).Nonempty","decl":"@[simp]\ntheorem image_inter_nonempty_iff {f : α → β} {s : Set α} {t : Set β} :\n    (f '' s ∩ t).Nonempty ↔ (s ∩ f ⁻¹' t).Nonempty := by\n  rw [← image_inter_preimage, image_nonempty]\n\n"}
{"name":"Set.image_diff_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\nt : Set β\n⊢ Eq (Set.image f (SDiff.sdiff s (Set.preimage f t))) (SDiff.sdiff (Set.image f s) t)","decl":"theorem image_diff_preimage {f : α → β} {s : Set α} {t : Set β} :\n    f '' (s \\ f ⁻¹' t) = f '' s \\ t := by simp_rw [diff_eq, ← preimage_compl, image_inter_preimage]\n\n"}
{"name":"Set.compl_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\n⊢ Eq (Set.image HasCompl.compl) (Set.preimage HasCompl.compl)","decl":"theorem compl_image : image (compl : Set α → Set α) = preimage compl :=\n  image_eq_preimage_of_inverse compl_compl compl_compl\n\n"}
{"name":"Set.compl_image_set_of","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\np : Set α → Prop\n⊢ Eq (Set.image HasCompl.compl (setOf fun s => p s)) (setOf fun s => p (HasCompl.compl s))","decl":"theorem compl_image_set_of {p : Set α → Prop} : compl '' { s | p s } = { s | p sᶜ } :=\n  congr_fun compl_image p\n\n"}
{"name":"Set.inter_preimage_subset","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\n⊢ HasSubset.Subset (Inter.inter s (Set.preimage f t)) (Set.preimage f (Inter.inter (Set.image f s) t))","decl":"theorem inter_preimage_subset (s : Set α) (t : Set β) (f : α → β) :\n    s ∩ f ⁻¹' t ⊆ f ⁻¹' (f '' s ∩ t) := fun _ h => ⟨mem_image_of_mem _ h.left, h.right⟩\n\n"}
{"name":"Set.union_preimage_subset","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\n⊢ HasSubset.Subset (Union.union s (Set.preimage f t)) (Set.preimage f (Union.union (Set.image f s) t))","decl":"theorem union_preimage_subset (s : Set α) (t : Set β) (f : α → β) :\n    s ∪ f ⁻¹' t ⊆ f ⁻¹' (f '' s ∪ t) := fun _ h =>\n  Or.elim h (fun l => Or.inl <| mem_image_of_mem _ l) fun r => Or.inr r\n\n"}
{"name":"Set.subset_image_union","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\nt : Set β\n⊢ HasSubset.Subset (Set.image f (Union.union s (Set.preimage f t))) (Union.union (Set.image f s) t)","decl":"theorem subset_image_union (f : α → β) (s : Set α) (t : Set β) : f '' (s ∪ f ⁻¹' t) ⊆ f '' s ∪ t :=\n  image_subset_iff.2 (union_preimage_subset _ _ _)\n\n"}
{"name":"Set.preimage_subset_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nA : Set α\nB : Set β\nf : α → β\n⊢ Iff (HasSubset.Subset (Set.preimage f B) A) (∀ (a : α), Membership.mem B (f a) → Membership.mem A a)","decl":"theorem preimage_subset_iff {A : Set α} {B : Set β} {f : α → β} :\n    f ⁻¹' B ⊆ A ↔ ∀ a : α, f a ∈ B → a ∈ A :=\n  Iff.rfl\n\n"}
{"name":"Set.image_eq_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns t : Set α\nf : α → β\nhf : Function.Injective f\n⊢ Iff (Eq (Set.image f s) (Set.image f t)) (Eq s t)","decl":"theorem image_eq_image {f : α → β} (hf : Injective f) : f '' s = f '' t ↔ s = t :=\n  Iff.symm <|\n    (Iff.intro fun eq => eq ▸ rfl) fun eq => by\n      rw [← preimage_image_eq s hf, ← preimage_image_eq t hf, eq]\n\n"}
{"name":"Set.subset_image_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\nt : Set β\n⊢ Iff (HasSubset.Subset t (Set.image f s)) (Exists fun u => And (HasSubset.Subset u s) (Eq (Set.image f u) t))","decl":"theorem subset_image_iff {t : Set β} :\n    t ⊆ f '' s ↔ ∃ u, u ⊆ s ∧ f '' u = t := by\n  refine ⟨fun h ↦ ⟨f ⁻¹' t ∩ s, inter_subset_right, ?_⟩,\n    fun ⟨u, hu, hu'⟩ ↦ hu'.symm ▸ image_mono hu⟩\n  rwa [image_preimage_inter, inter_eq_left]\n\n"}
{"name":"Set.exists_subset_image_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\np : Set β → Prop\n⊢ Iff (Exists fun t => And (HasSubset.Subset t (Set.image f s)) (p t)) (Exists fun t => And (HasSubset.Subset t s) (p (Set.image f t)))","decl":"@[simp]\nlemma exists_subset_image_iff {p : Set β → Prop} : (∃ t ⊆ f '' s, p t) ↔ ∃ t ⊆ s, p (f '' t) := by\n  simp [subset_image_iff]\n\n"}
{"name":"Set.forall_subset_image_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\np : Set β → Prop\n⊢ Iff (∀ (t : Set β), HasSubset.Subset t (Set.image f s) → p t) (∀ (t : Set α), HasSubset.Subset t s → p (Set.image f t))","decl":"@[simp]\nlemma forall_subset_image_iff {p : Set β → Prop} : (∀ t ⊆ f '' s, p t) ↔ ∀ t ⊆ s, p (f '' t) := by\n  simp [subset_image_iff]\n\n"}
{"name":"Set.image_subset_image_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns t : Set α\nf : α → β\nhf : Function.Injective f\n⊢ Iff (HasSubset.Subset (Set.image f s) (Set.image f t)) (HasSubset.Subset s t)","decl":"theorem image_subset_image_iff {f : α → β} (hf : Injective f) : f '' s ⊆ f '' t ↔ s ⊆ t := by\n  refine Iff.symm <| (Iff.intro (image_subset f)) fun h => ?_\n  rw [← preimage_image_eq s hf, ← preimage_image_eq t hf]\n  exact preimage_mono h\n\n"}
{"name":"Set.prod_quotient_preimage_eq_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Setoid α\ng : Quotient s → β\nh : α → β\nHh : Eq h (Function.comp g Quotient.mk'')\nr : Set (Prod β β)\n⊢ Eq (setOf fun x => Membership.mem r { fst := g x.1, snd := g x.2 }) (Set.image (fun a => { fst := Quotient.mk s a.1, snd := Quotient.mk s a.2 }) (Set.preimage (fun a => { fst := h a.1, snd := h a.2 }) r))","decl":"theorem prod_quotient_preimage_eq_image [s : Setoid α] (g : Quotient s → β) {h : α → β}\n    (Hh : h = g ∘ Quotient.mk'') (r : Set (β × β)) :\n    { x : Quotient s × Quotient s | (g x.1, g x.2) ∈ r } =\n      (fun a : α × α => (⟦a.1⟧, ⟦a.2⟧)) '' ((fun a : α × α => (h a.1, h a.2)) ⁻¹' r) :=\n  Hh.symm ▸\n    Set.ext fun ⟨a₁, a₂⟩ =>\n      ⟨Quot.induction_on₂ a₁ a₂ fun a₁ a₂ h => ⟨(a₁, a₂), h, rfl⟩, fun ⟨⟨b₁, b₂⟩, h₁, h₂⟩ =>\n        show (g a₁, g a₂) ∈ r from\n          have h₃ : ⟦b₁⟧ = a₁ ∧ ⟦b₂⟧ = a₂ := Prod.ext_iff.1 h₂\n          h₃.1 ▸ h₃.2 ▸ h₁⟩\n\n"}
{"name":"Set.exists_image_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx : Set α\nP : β → Prop\n⊢ Iff (Exists fun a => P ↑a) (Exists fun a => P (f ↑a))","decl":"theorem exists_image_iff (f : α → β) (x : Set α) (P : β → Prop) :\n    (∃ a : f '' x, P a) ↔ ∃ a : x, P (f a) :=\n  ⟨fun ⟨a, h⟩ => ⟨⟨_, a.prop.choose_spec.1⟩, a.prop.choose_spec.2.symm ▸ h⟩, fun ⟨a, h⟩ =>\n    ⟨⟨_, _, a.prop, rfl⟩, h⟩⟩\n\n"}
{"name":"Set.imageFactorization_eq","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\n⊢ Eq (Function.comp Subtype.val (Set.imageFactorization f s)) (Function.comp f Subtype.val)","decl":"theorem imageFactorization_eq {f : α → β} {s : Set α} :\n    Subtype.val ∘ imageFactorization f s = f ∘ Subtype.val :=\n  funext fun _ => rfl\n\n"}
{"name":"Set.surjective_onto_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\n⊢ Function.Surjective (Set.imageFactorization f s)","decl":"theorem surjective_onto_image {f : α → β} {s : Set α} : Surjective (imageFactorization f s) :=\n  fun ⟨_, ⟨a, ha, rfl⟩⟩ => ⟨⟨a, ha⟩, rfl⟩\n\n"}
{"name":"Set.image_perm","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns : Set α\nσ : Equiv.Perm α\nhs : HasSubset.Subset (setOf fun a => Ne (σ a) a) s\n⊢ Eq (Set.image (⇑σ) s) s","decl":"/-- If the only elements outside `s` are those left fixed by `σ`, then mapping by `σ` has no effect.\n-/\ntheorem image_perm {s : Set α} {σ : Equiv.Perm α} (hs : { a : α | σ a ≠ a } ⊆ s) : σ '' s = s := by\n  ext i\n  obtain hi | hi := eq_or_ne (σ i) i\n  · refine ⟨?_, fun h => ⟨i, h, hi⟩⟩\n    rintro ⟨j, hj, h⟩\n    rwa [σ.injective (hi.trans h.symm)]\n  · refine iff_of_true ⟨σ.symm i, hs fun h => hi ?_, σ.apply_symm_apply _⟩ (hs hi)\n    convert congr_arg σ h <;> exact (σ.apply_symm_apply _).symm\n\n"}
{"name":"Set.powerset_insert","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns : Set α\na : α\n⊢ Eq (Insert.insert a s).powerset (Union.union s.powerset (Set.image (Insert.insert a) s.powerset))","decl":"/-- The powerset of `{a} ∪ s` is `𝒫 s` together with `{a} ∪ t` for each `t ∈ 𝒫 s`. -/\ntheorem powerset_insert (s : Set α) (a : α) : 𝒫 insert a s = 𝒫 s ∪ insert a '' 𝒫 s := by\n  ext t\n  simp_rw [mem_union, mem_image, mem_powerset_iff]\n  constructor\n  · intro h\n    by_cases hs : a ∈ t\n    · right\n      refine ⟨t \\ {a}, ?_, ?_⟩\n      · rw [diff_singleton_subset_iff]\n        assumption\n      · rw [insert_diff_singleton, insert_eq_of_mem hs]\n    · left\n      exact (subset_insert_iff_of_not_mem hs).mp h\n  · rintro (h | ⟨s', h₁, rfl⟩)\n    · exact subset_trans h (subset_insert a s)\n    · exact insert_subset_insert h₁\n\n"}
{"name":"Set.forall_mem_range","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nι : Sort u_4\nf : ι → α\np : α → Prop\n⊢ Iff (∀ (a : α), Membership.mem (Set.range f) a → p a) (∀ (i : ι), p (f i))","decl":"theorem forall_mem_range {p : α → Prop} : (∀ a ∈ range f, p a) ↔ ∀ i, p (f i) := by simp\n\n\n"}
{"name":"Set.forall_subtype_range_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nι : Sort u_4\nf : ι → α\np : ↑(Set.range f) → Prop\n⊢ Iff (∀ (a : ↑(Set.range f)), p a) (∀ (i : ι), p ⟨f i, ⋯⟩)","decl":"theorem forall_subtype_range_iff {p : range f → Prop} :\n    (∀ a : range f, p a) ↔ ∀ i, p ⟨f i, mem_range_self _⟩ :=\n  ⟨fun H _ => H _, fun H ⟨y, i, hi⟩ => by\n    subst hi\n    apply H⟩\n\n"}
{"name":"Set.exists_range_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nι : Sort u_4\nf : ι → α\np : α → Prop\n⊢ Iff (Exists fun a => And (Membership.mem (Set.range f) a) (p a)) (Exists fun i => p (f i))","decl":"theorem exists_range_iff {p : α → Prop} : (∃ a ∈ range f, p a) ↔ ∃ i, p (f i) := by simp\n\n"}
{"name":"Set.exists_subtype_range_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nι : Sort u_4\nf : ι → α\np : ↑(Set.range f) → Prop\n⊢ Iff (Exists fun a => p a) (Exists fun i => p ⟨f i, ⋯⟩)","decl":"theorem exists_subtype_range_iff {p : range f → Prop} :\n    (∃ a : range f, p a) ↔ ∃ i, p ⟨f i, mem_range_self _⟩ :=\n  ⟨fun ⟨⟨a, i, hi⟩, ha⟩ => by\n    subst a\n    exact ⟨i, ha⟩,\n   fun ⟨_, hi⟩ => ⟨_, hi⟩⟩\n\n"}
{"name":"Set.range_eq_univ","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nι : Sort u_4\nf : ι → α\n⊢ Iff (Eq (Set.range f) Set.univ) (Function.Surjective f)","decl":"theorem range_eq_univ : range f = univ ↔ Surjective f :=\n  eq_univ_iff_forall\n\n"}
{"name":"Set.range_iff_surjective","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nι : Sort u_4\nf : ι → α\n⊢ Iff (Eq (Set.range f) Set.univ) (Function.Surjective f)","decl":"@[deprecated (since := \"2024-11-11\")] alias range_iff_surjective := range_eq_univ\n\n"}
{"name":"Function.Surjective.range_eq","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nι : Sort u_4\nf : ι → α\na✝ : Function.Surjective f\n⊢ Eq (Set.range f) Set.univ","decl":"alias ⟨_, _root_.Function.Surjective.range_eq⟩ := range_eq_univ\n\n"}
{"name":"Set.subset_range_of_surjective","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nh : Function.Surjective f\ns : Set β\n⊢ HasSubset.Subset s (Set.range f)","decl":"@[simp]\ntheorem subset_range_of_surjective {f : α → β} (h : Surjective f) (s : Set β) :\n    s ⊆ range f := Surjective.range_eq h ▸ subset_univ s\n\n"}
{"name":"Set.image_univ","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (Set.image f Set.univ) (Set.range f)","decl":"@[simp]\ntheorem image_univ {f : α → β} : f '' univ = range f := by\n  ext\n  simp [image, range]\n\n"}
{"name":"Set.image_compl_eq_range_diff_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\ns : Set α\n⊢ Eq (Set.image f (HasCompl.compl s)) (SDiff.sdiff (Set.range f) (Set.image f s))","decl":"lemma image_compl_eq_range_diff_image {f : α → β} (hf : Injective f) (s : Set α) :\n    f '' sᶜ = range f \\ f '' s := by rw [← image_univ, ← image_diff hf, compl_eq_univ_diff]\n\n"}
{"name":"Set.range_diff_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\ns : Set α\n⊢ Eq (SDiff.sdiff (Set.range f) (Set.image f s)) (Set.image f (HasCompl.compl s))","decl":"/-- Alias of `Set.image_compl_eq_range_sdiff_image`. -/\nlemma range_diff_image {f : α → β} (hf : Injective f) (s : Set α) : range f \\ f '' s = f '' sᶜ := by\n  rw [image_compl_eq_range_diff_image hf]\n\n"}
{"name":"Set.preimage_eq_univ_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\n⊢ Iff (Eq (Set.preimage f s) Set.univ) (HasSubset.Subset (Set.range f) s)","decl":"@[simp]\ntheorem preimage_eq_univ_iff {f : α → β} {s} : f ⁻¹' s = univ ↔ range f ⊆ s := by\n  rw [← univ_subset_iff, ← image_subset_iff, image_univ]\n\n"}
{"name":"Set.image_subset_range","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\n⊢ HasSubset.Subset (Set.image f s) (Set.range f)","decl":"theorem image_subset_range (f : α → β) (s) : f '' s ⊆ range f := by\n  rw [← image_univ]; exact image_subset _ (subset_univ _)\n\n"}
{"name":"Set.mem_range_of_mem_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\nx : β\nh : Membership.mem (Set.image f s) x\n⊢ Membership.mem (Set.range f) x","decl":"theorem mem_range_of_mem_image (f : α → β) (s) {x : β} (h : x ∈ f '' s) : x ∈ range f :=\n  image_subset_range f s h\n\n"}
{"name":"Nat.mem_range_succ","module":"Mathlib.Data.Set.Image","initialProofState":"i : Nat\n⊢ Iff (Membership.mem (Set.range Nat.succ) i) (LT.lt 0 i)","decl":"theorem _root_.Nat.mem_range_succ (i : ℕ) : i ∈ range Nat.succ ↔ 0 < i :=\n  ⟨by\n    rintro ⟨n, rfl⟩\n    exact Nat.succ_pos n, fun h => ⟨_, Nat.succ_pred_eq_of_pos h⟩⟩\n\n"}
{"name":"Set.Nonempty.preimage'","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set β\nhs : s.Nonempty\nf : α → β\nhf : HasSubset.Subset s (Set.range f)\n⊢ (Set.preimage f s).Nonempty","decl":"theorem Nonempty.preimage' {s : Set β} (hs : s.Nonempty) {f : α → β} (hf : s ⊆ range f) :\n    (f ⁻¹' s).Nonempty :=\n  let ⟨_, hy⟩ := hs\n  let ⟨x, hx⟩ := hf hy\n  ⟨x, Set.mem_preimage.2 <| hx.symm ▸ hy⟩\n\n"}
{"name":"Set.range_comp","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ng : α → β\nf : ι → α\n⊢ Eq (Set.range (Function.comp g f)) (Set.image g (Set.range f))","decl":"theorem range_comp (g : α → β) (f : ι → α) : range (g ∘ f) = g '' range f := by aesop\n\n"}
{"name":"Set.range_subset_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nι : Sort u_4\nf : ι → α\ns : Set α\n⊢ Iff (HasSubset.Subset (Set.range f) s) (∀ (y : ι), Membership.mem s (f y))","decl":"theorem range_subset_iff : range f ⊆ s ↔ ∀ y, f y ∈ s :=\n  forall_mem_range\n\n"}
{"name":"Set.range_subset_range_iff_exists_comp","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → γ\ng : β → γ\n⊢ Iff (HasSubset.Subset (Set.range f) (Set.range g)) (Exists fun h => Eq f (Function.comp g h))","decl":"theorem range_subset_range_iff_exists_comp {f : α → γ} {g : β → γ} :\n    range f ⊆ range g ↔ ∃ h : α → β, f = g ∘ h := by\n  simp only [range_subset_iff, mem_range, Classical.skolem, funext_iff, (· ∘ ·), eq_comm]\n\n"}
{"name":"Set.range_eq_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\n⊢ Iff (Eq (Set.range f) s) (And (∀ (a : α), Membership.mem s (f a)) (∀ (b : β), Membership.mem s b → Exists fun a => Eq (f a) b))","decl":"theorem range_eq_iff (f : α → β) (s : Set β) :\n    range f = s ↔ (∀ a, f a ∈ s) ∧ ∀ b ∈ s, ∃ a, f a = b := by\n  rw [← range_subset_iff]\n  exact le_antisymm_iff\n\n"}
{"name":"Set.range_comp_subset_range","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\ng : β → γ\n⊢ HasSubset.Subset (Set.range (Function.comp g f)) (Set.range g)","decl":"theorem range_comp_subset_range (f : α → β) (g : β → γ) : range (g ∘ f) ⊆ range g := by\n  rw [range_comp]; apply image_subset_range\n\n"}
{"name":"Set.range_nonempty_iff_nonempty","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nι : Sort u_4\nf : ι → α\n⊢ Iff (Set.range f).Nonempty (Nonempty ι)","decl":"theorem range_nonempty_iff_nonempty : (range f).Nonempty ↔ Nonempty ι :=\n  ⟨fun ⟨_, x, _⟩ => ⟨x⟩, fun ⟨x⟩ => ⟨f x, mem_range_self x⟩⟩\n\n"}
{"name":"Set.range_nonempty","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nι : Sort u_4\nh : Nonempty ι\nf : ι → α\n⊢ (Set.range f).Nonempty","decl":"theorem range_nonempty [h : Nonempty ι] (f : ι → α) : (range f).Nonempty :=\n  range_nonempty_iff_nonempty.2 h\n\n"}
{"name":"Set.range_eq_empty_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nι : Sort u_4\nf : ι → α\n⊢ Iff (Eq (Set.range f) EmptyCollection.emptyCollection) (IsEmpty ι)","decl":"@[simp]\ntheorem range_eq_empty_iff {f : ι → α} : range f = ∅ ↔ IsEmpty ι := by\n  rw [← not_nonempty_iff, ← range_nonempty_iff_nonempty, not_nonempty_iff_eq_empty]\n\n"}
{"name":"Set.range_eq_empty","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : IsEmpty ι\nf : ι → α\n⊢ Eq (Set.range f) EmptyCollection.emptyCollection","decl":"theorem range_eq_empty [IsEmpty ι] (f : ι → α) : range f = ∅ :=\n  range_eq_empty_iff.2 ‹_›\n\n"}
{"name":"Set.instNonemptyRange","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : Nonempty ι\nf : ι → α\n⊢ Nonempty ↑(Set.range f)","decl":"instance instNonemptyRange [Nonempty ι] (f : ι → α) : Nonempty (range f) :=\n  (range_nonempty f).to_subtype\n\n"}
{"name":"Set.image_union_image_compl_eq_range","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\n⊢ Eq (Union.union (Set.image f s) (Set.image f (HasCompl.compl s))) (Set.range f)","decl":"@[simp]\ntheorem image_union_image_compl_eq_range (f : α → β) : f '' s ∪ f '' sᶜ = range f := by\n  rw [← image_union, ← image_univ, ← union_compl_self]\n\n"}
{"name":"Set.insert_image_compl_eq_range","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx : α\n⊢ Eq (Insert.insert (f x) (Set.image f (HasCompl.compl (Singleton.singleton x)))) (Set.range f)","decl":"theorem insert_image_compl_eq_range (f : α → β) (x : α) : insert (f x) (f '' {x}ᶜ) = range f := by\n  rw [← image_insert_eq, insert_eq, union_compl_self, image_univ]\n\n"}
{"name":"Set.image_preimage_eq_range_inter","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nt : Set β\n⊢ Eq (Set.image f (Set.preimage f t)) (Inter.inter (Set.range f) t)","decl":"theorem image_preimage_eq_range_inter {f : α → β} {t : Set β} : f '' (f ⁻¹' t) = range f ∩ t :=\n  ext fun x =>\n    ⟨fun ⟨_, hx, HEq⟩ => HEq ▸ ⟨mem_range_self _, hx⟩, fun ⟨⟨y, h_eq⟩, hx⟩ =>\n      h_eq ▸ mem_image_of_mem f <| show y ∈ f ⁻¹' t by rw [preimage, mem_setOf, h_eq]; exact hx⟩\n\n"}
{"name":"Set.image_preimage_eq_inter_range","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nt : Set β\n⊢ Eq (Set.image f (Set.preimage f t)) (Inter.inter t (Set.range f))","decl":"theorem image_preimage_eq_inter_range {f : α → β} {t : Set β} : f '' (f ⁻¹' t) = t ∩ range f := by\n  rw [image_preimage_eq_range_inter, inter_comm]\n\n"}
{"name":"Set.image_preimage_eq_of_subset","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\nhs : HasSubset.Subset s (Set.range f)\n⊢ Eq (Set.image f (Set.preimage f s)) s","decl":"theorem image_preimage_eq_of_subset {f : α → β} {s : Set β} (hs : s ⊆ range f) :\n    f '' (f ⁻¹' s) = s := by rw [image_preimage_eq_range_inter, inter_eq_self_of_subset_right hs]\n\n"}
{"name":"Set.image_preimage_eq_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\n⊢ Iff (Eq (Set.image f (Set.preimage f s)) s) (HasSubset.Subset s (Set.range f))","decl":"theorem image_preimage_eq_iff {f : α → β} {s : Set β} : f '' (f ⁻¹' s) = s ↔ s ⊆ range f :=\n  ⟨by\n    intro h\n    rw [← h]\n    apply image_subset_range,\n   image_preimage_eq_of_subset⟩\n\n"}
{"name":"Set.subset_range_iff_exists_image_eq","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\n⊢ Iff (HasSubset.Subset s (Set.range f)) (Exists fun t => Eq (Set.image f t) s)","decl":"theorem subset_range_iff_exists_image_eq {f : α → β} {s : Set β} : s ⊆ range f ↔ ∃ t, f '' t = s :=\n  ⟨fun h => ⟨_, image_preimage_eq_iff.2 h⟩, fun ⟨_, ht⟩ => ht ▸ image_subset_range _ _⟩\n\n"}
{"name":"Set.range_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (Set.range (Set.image f)) (Set.range f).powerset","decl":"theorem range_image (f : α → β) : range (image f) = 𝒫 range f :=\n  ext fun _ => subset_range_iff_exists_image_eq.symm\n\n"}
{"name":"Set.exists_subset_range_and_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\np : Set β → Prop\n⊢ Iff (Exists fun s => And (HasSubset.Subset s (Set.range f)) (p s)) (Exists fun s => p (Set.image f s))","decl":"@[simp]\ntheorem exists_subset_range_and_iff {f : α → β} {p : Set β → Prop} :\n    (∃ s, s ⊆ range f ∧ p s) ↔ ∃ s, p (f '' s) := by\n  rw [← exists_range_iff, range_image]; rfl\n\n"}
{"name":"Set.forall_subset_range_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\np : Set β → Prop\n⊢ Iff (∀ (s : Set β), HasSubset.Subset s (Set.range f) → p s) (∀ (s : Set α), p (Set.image f s))","decl":"@[simp]\ntheorem forall_subset_range_iff {f : α → β} {p : Set β → Prop} :\n    (∀ s, s ⊆ range f → p s) ↔ ∀ s, p (f '' s) := by\n  rw [← forall_mem_range, range_image]; simp only [mem_powerset_iff]\n\n"}
{"name":"Set.preimage_subset_preimage_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns t : Set α\nf : β → α\nhs : HasSubset.Subset s (Set.range f)\n⊢ Iff (HasSubset.Subset (Set.preimage f s) (Set.preimage f t)) (HasSubset.Subset s t)","decl":"@[simp]\ntheorem preimage_subset_preimage_iff {s t : Set α} {f : β → α} (hs : s ⊆ range f) :\n    f ⁻¹' s ⊆ f ⁻¹' t ↔ s ⊆ t := by\n  constructor\n  · intro h x hx\n    rcases hs hx with ⟨y, rfl⟩\n    exact h hx\n  intro h x; apply h\n\n"}
{"name":"Set.preimage_eq_preimage'","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns t : Set α\nf : β → α\nhs : HasSubset.Subset s (Set.range f)\nht : HasSubset.Subset t (Set.range f)\n⊢ Iff (Eq (Set.preimage f s) (Set.preimage f t)) (Eq s t)","decl":"theorem preimage_eq_preimage' {s t : Set α} {f : β → α} (hs : s ⊆ range f) (ht : t ⊆ range f) :\n    f ⁻¹' s = f ⁻¹' t ↔ s = t := by\n  constructor\n  · intro h\n    apply Subset.antisymm\n    · rw [← preimage_subset_preimage_iff hs, h]\n    · rw [← preimage_subset_preimage_iff ht, h]\n  rintro rfl; rfl\n\n-- Porting note:\n-- @[simp] `simp` can prove this\n"}
{"name":"Set.preimage_inter_range","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\n⊢ Eq (Set.preimage f (Inter.inter s (Set.range f))) (Set.preimage f s)","decl":"theorem preimage_inter_range {f : α → β} {s : Set β} : f ⁻¹' (s ∩ range f) = f ⁻¹' s :=\n  Set.ext fun x => and_iff_left ⟨x, rfl⟩\n\n-- Porting note:\n-- @[simp] `simp` can prove this\n"}
{"name":"Set.preimage_range_inter","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\n⊢ Eq (Set.preimage f (Inter.inter (Set.range f) s)) (Set.preimage f s)","decl":"theorem preimage_range_inter {f : α → β} {s : Set β} : f ⁻¹' (range f ∩ s) = f ⁻¹' s := by\n  rw [inter_comm, preimage_inter_range]\n\n"}
{"name":"Set.preimage_image_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\n⊢ Eq (Set.preimage f (Set.image f (Set.preimage f s))) (Set.preimage f s)","decl":"theorem preimage_image_preimage {f : α → β} {s : Set β} : f ⁻¹' (f '' (f ⁻¹' s)) = f ⁻¹' s := by\n  rw [image_preimage_eq_range_inter, preimage_range_inter]\n\n"}
{"name":"Set.range_id","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\n⊢ Eq (Set.range id) Set.univ","decl":"@[simp, mfld_simps]\ntheorem range_id : range (@id α) = univ :=\n  range_eq_univ.2 surjective_id\n\n"}
{"name":"Set.range_id'","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\n⊢ Eq (Set.range fun x => x) Set.univ","decl":"@[simp, mfld_simps]\ntheorem range_id' : (range fun x : α => x) = univ :=\n  range_id\n\n"}
{"name":"Prod.range_fst","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Nonempty β\n⊢ Eq (Set.range Prod.fst) Set.univ","decl":"@[simp]\ntheorem _root_.Prod.range_fst [Nonempty β] : range (Prod.fst : α × β → α) = univ :=\n  Prod.fst_surjective.range_eq\n\n"}
{"name":"Prod.range_snd","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Nonempty α\n⊢ Eq (Set.range Prod.snd) Set.univ","decl":"@[simp]\ntheorem _root_.Prod.range_snd [Nonempty α] : range (Prod.snd : α × β → β) = univ :=\n  Prod.snd_surjective.range_eq\n\n"}
{"name":"Set.range_eval","module":"Mathlib.Data.Set.Image","initialProofState":"ι : Sort u_4\nα : ι → Type u_5\ninst✝ : ∀ (i : ι), Nonempty (α i)\ni : ι\n⊢ Eq (Set.range (Function.eval i)) Set.univ","decl":"@[simp]\ntheorem range_eval {α : ι → Sort _} [∀ i, Nonempty (α i)] (i : ι) :\n    range (eval i : (∀ i, α i) → α i) = univ :=\n  (surjective_eval i).range_eq\n\n"}
{"name":"Set.range_inl","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Eq (Set.range Sum.inl) (setOf fun x => Eq x.isLeft Bool.true)","decl":"theorem range_inl : range (@Sum.inl α β) = {x | Sum.isLeft x} := by ext (_|_) <;> simp\n"}
{"name":"Set.range_inr","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Eq (Set.range Sum.inr) (setOf fun x => Eq x.isRight Bool.true)","decl":"theorem range_inr : range (@Sum.inr α β) = {x | Sum.isRight x} := by ext (_|_) <;> simp\n\n"}
{"name":"Set.isCompl_range_inl_range_inr","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ IsCompl (Set.range Sum.inl) (Set.range Sum.inr)","decl":"theorem isCompl_range_inl_range_inr : IsCompl (range <| @Sum.inl α β) (range Sum.inr) :=\n  IsCompl.of_le\n    (by\n      rintro y ⟨⟨x₁, rfl⟩, ⟨x₂, h⟩⟩\n      exact Sum.noConfusion h)\n    (by rintro (x | y) - <;> [left; right] <;> exact mem_range_self _)\n\n"}
{"name":"Set.range_inl_union_range_inr","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Eq (Union.union (Set.range Sum.inl) (Set.range Sum.inr)) Set.univ","decl":"@[simp]\ntheorem range_inl_union_range_inr : range (Sum.inl : α → α ⊕ β) ∪ range Sum.inr = univ :=\n  isCompl_range_inl_range_inr.sup_eq_top\n\n"}
{"name":"Set.range_inl_inter_range_inr","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Eq (Inter.inter (Set.range Sum.inl) (Set.range Sum.inr)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem range_inl_inter_range_inr : range (Sum.inl : α → α ⊕ β) ∩ range Sum.inr = ∅ :=\n  isCompl_range_inl_range_inr.inf_eq_bot\n\n"}
{"name":"Set.range_inr_union_range_inl","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Eq (Union.union (Set.range Sum.inr) (Set.range Sum.inl)) Set.univ","decl":"@[simp]\ntheorem range_inr_union_range_inl : range (Sum.inr : β → α ⊕ β) ∪ range Sum.inl = univ :=\n  isCompl_range_inl_range_inr.symm.sup_eq_top\n\n"}
{"name":"Set.range_inr_inter_range_inl","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Eq (Inter.inter (Set.range Sum.inr) (Set.range Sum.inl)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem range_inr_inter_range_inl : range (Sum.inr : β → α ⊕ β) ∩ range Sum.inl = ∅ :=\n  isCompl_range_inl_range_inr.symm.inf_eq_bot\n\n"}
{"name":"Set.preimage_inl_image_inr","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set β\n⊢ Eq (Set.preimage Sum.inl (Set.image Sum.inr s)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem preimage_inl_image_inr (s : Set β) : Sum.inl ⁻¹' (@Sum.inr α β '' s) = ∅ := by\n  ext\n  simp\n\n"}
{"name":"Set.preimage_inr_image_inl","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\n⊢ Eq (Set.preimage Sum.inr (Set.image Sum.inl s)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem preimage_inr_image_inl (s : Set α) : Sum.inr ⁻¹' (@Sum.inl α β '' s) = ∅ := by\n  ext\n  simp\n\n"}
{"name":"Set.preimage_inl_range_inr","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Eq (Set.preimage Sum.inl (Set.range Sum.inr)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem preimage_inl_range_inr : Sum.inl ⁻¹' range (Sum.inr : β → α ⊕ β) = ∅ := by\n  rw [← image_univ, preimage_inl_image_inr]\n\n"}
{"name":"Set.preimage_inr_range_inl","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Eq (Set.preimage Sum.inr (Set.range Sum.inl)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem preimage_inr_range_inl : Sum.inr ⁻¹' range (Sum.inl : α → α ⊕ β) = ∅ := by\n  rw [← image_univ, preimage_inr_image_inl]\n\n"}
{"name":"Set.compl_range_inl","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Eq (HasCompl.compl (Set.range Sum.inl)) (Set.range Sum.inr)","decl":"@[simp]\ntheorem compl_range_inl : (range (Sum.inl : α → α ⊕ β))ᶜ = range (Sum.inr : β → α ⊕ β) :=\n  IsCompl.compl_eq isCompl_range_inl_range_inr\n\n"}
{"name":"Set.compl_range_inr","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Eq (HasCompl.compl (Set.range Sum.inr)) (Set.range Sum.inl)","decl":"@[simp]\ntheorem compl_range_inr : (range (Sum.inr : β → α ⊕ β))ᶜ = range (Sum.inl : α → α ⊕ β) :=\n  IsCompl.compl_eq isCompl_range_inl_range_inr.symm\n\n"}
{"name":"Set.image_preimage_inl_union_image_preimage_inr","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set (Sum α β)\n⊢ Eq (Union.union (Set.image Sum.inl (Set.preimage Sum.inl s)) (Set.image Sum.inr (Set.preimage Sum.inr s))) s","decl":"theorem image_preimage_inl_union_image_preimage_inr (s : Set (α ⊕ β)) :\n    Sum.inl '' (Sum.inl ⁻¹' s) ∪ Sum.inr '' (Sum.inr ⁻¹' s) = s := by\n  rw [image_preimage_eq_inter_range, image_preimage_eq_inter_range, ← inter_union_distrib_left,\n    range_inl_union_range_inr, inter_univ]\n\n"}
{"name":"Set.range_quot_mk","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Eq (Set.range (Quot.mk r)) Set.univ","decl":"@[simp]\ntheorem range_quot_mk (r : α → α → Prop) : range (Quot.mk r) = univ :=\n  Quot.mk_surjective.range_eq\n\n"}
{"name":"Set.range_quot_lift","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nι : Sort u_4\nf : ι → α\nr : ι → ι → Prop\nhf : ∀ (x y : ι), r x y → Eq (f x) (f y)\n⊢ Eq (Set.range (Quot.lift f hf)) (Set.range f)","decl":"@[simp]\ntheorem range_quot_lift {r : ι → ι → Prop} (hf : ∀ x y, r x y → f x = f y) :\n    range (Quot.lift f hf) = range f :=\n  ext fun _ => Quot.mk_surjective.exists\n\n"}
{"name":"Set.range_quotient_mk","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns : Setoid α\n⊢ Eq (Set.range (Quotient.mk s)) Set.univ","decl":"@[simp]\ntheorem range_quotient_mk {s : Setoid α} : range (Quotient.mk s) = univ :=\n  range_quot_mk _\n\n"}
{"name":"Set.range_quotient_lift","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nι : Sort u_4\nf : ι → α\ns : Setoid ι\nhf : ∀ (a b : ι), HasEquiv.Equiv a b → Eq (f a) (f b)\n⊢ Eq (Set.range (Quotient.lift f hf)) (Set.range f)","decl":"@[simp]\ntheorem range_quotient_lift [s : Setoid ι] (hf) :\n    range (Quotient.lift f hf : Quotient s → α) = range f :=\n  range_quot_lift _\n\n"}
{"name":"Set.range_quotient_mk'","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns : Setoid α\n⊢ Eq (Set.range Quotient.mk') Set.univ","decl":"@[simp]\ntheorem range_quotient_mk' {s : Setoid α} : range (Quotient.mk' : α → Quotient s) = univ :=\n  range_quot_mk _\n\n"}
{"name":"Set.Quotient.range_mk''","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nsa : Setoid α\n⊢ Eq (Set.range Quotient.mk'') Set.univ","decl":"lemma Quotient.range_mk'' {sa : Setoid α} : range (Quotient.mk'' (s₁ := sa)) = univ :=\n  range_quotient_mk\n\n"}
{"name":"Set.range_quotient_lift_on'","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nι : Sort u_4\nf : ι → α\ns : Setoid ι\nhf : ∀ (a b : ι), s a b → Eq (f a) (f b)\n⊢ Eq (Set.range fun x => x.liftOn' f hf) (Set.range f)","decl":"@[simp]\ntheorem range_quotient_lift_on' {s : Setoid ι} (hf) :\n    (range fun x : Quotient s => Quotient.liftOn' x f hf) = range f :=\n  range_quot_lift _\n\n"}
{"name":"Set.canLift","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nc : β → α\np : α → Prop\ninst✝ : CanLift α β c p\n⊢ CanLift (Set α) (Set β) (fun x => Set.image c x) fun s => ∀ (x : α), Membership.mem s x → p x","decl":"instance canLift (c) (p) [CanLift α β c p] :\n    CanLift (Set α) (Set β) (c '' ·) fun s => ∀ x ∈ s, p x where\n  prf _ hs := subset_range_iff_exists_image_eq.mp fun x hx => CanLift.prf _ (hs x hx)\n\n"}
{"name":"Set.range_const_subset","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nι : Sort u_4\nc : α\n⊢ HasSubset.Subset (Set.range fun x => c) (Singleton.singleton c)","decl":"theorem range_const_subset {c : α} : (range fun _ : ι => c) ⊆ {c} :=\n  range_subset_iff.2 fun _ => rfl\n\n"}
{"name":"Set.range_const","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : Nonempty ι\nc : α\n⊢ Eq (Set.range fun x => c) (Singleton.singleton c)","decl":"@[simp]\ntheorem range_const : ∀ [Nonempty ι] {c : α}, (range fun _ : ι => c) = {c}\n  | ⟨x⟩, _ =>\n    (Subset.antisymm range_const_subset) fun _ hy =>\n      (mem_singleton_iff.1 hy).symm ▸ mem_range_self x\n\n"}
{"name":"Set.range_subtype_map","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\np : α → Prop\nq : β → Prop\nf : α → β\nh : ∀ (x : α), p x → q (f x)\n⊢ Eq (Set.range (Subtype.map f h)) (Set.preimage Subtype.val (Set.image f (setOf fun x => p x)))","decl":"theorem range_subtype_map {p : α → Prop} {q : β → Prop} (f : α → β) (h : ∀ x, p x → q (f x)) :\n    range (Subtype.map f h) = (↑) ⁻¹' (f '' { x | p x }) := by\n  ext ⟨x, hx⟩\n  simp_rw [mem_preimage, mem_range, mem_image, Subtype.exists, Subtype.map]\n  simp only [Subtype.mk.injEq, exists_prop, mem_setOf_eq]\n\n"}
{"name":"Set.image_swap_eq_preimage_swap","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Eq (Set.image Prod.swap) (Set.preimage Prod.swap)","decl":"theorem image_swap_eq_preimage_swap : image (@Prod.swap α β) = preimage Prod.swap :=\n  image_eq_preimage_of_inverse Prod.swap_leftInverse Prod.swap_rightInverse\n\n"}
{"name":"Set.preimage_singleton_nonempty","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ny : β\n⊢ Iff (Set.preimage f (Singleton.singleton y)).Nonempty (Membership.mem (Set.range f) y)","decl":"theorem preimage_singleton_nonempty {f : α → β} {y : β} : (f ⁻¹' {y}).Nonempty ↔ y ∈ range f :=\n  Iff.rfl\n\n"}
{"name":"Set.preimage_singleton_eq_empty","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ny : β\n⊢ Iff (Eq (Set.preimage f (Singleton.singleton y)) EmptyCollection.emptyCollection) (Not (Membership.mem (Set.range f) y))","decl":"theorem preimage_singleton_eq_empty {f : α → β} {y : β} : f ⁻¹' {y} = ∅ ↔ y ∉ range f :=\n  not_nonempty_iff_eq_empty.symm.trans preimage_singleton_nonempty.not\n\n"}
{"name":"Set.range_subset_singleton","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nι : Sort u_4\nf : ι → α\nx : α\n⊢ Iff (HasSubset.Subset (Set.range f) (Singleton.singleton x)) (Eq f (Function.const ι x))","decl":"theorem range_subset_singleton {f : ι → α} {x : α} : range f ⊆ {x} ↔ f = const ι x := by\n  simp [range_subset_iff, funext_iff, mem_singleton]\n\n"}
{"name":"Set.image_compl_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\n⊢ Eq (Set.image f (HasCompl.compl (Set.preimage f s))) (SDiff.sdiff (Set.range f) s)","decl":"theorem image_compl_preimage {f : α → β} {s : Set β} : f '' (f ⁻¹' s)ᶜ = range f \\ s := by\n  rw [compl_eq_univ_diff, image_diff_preimage, image_univ]\n\n"}
{"name":"Set.rangeFactorization_eq","module":"Mathlib.Data.Set.Image","initialProofState":"β : Type u_2\nι : Sort u_4\nf : ι → β\n⊢ Eq (Function.comp Subtype.val (Set.rangeFactorization f)) f","decl":"theorem rangeFactorization_eq {f : ι → β} : Subtype.val ∘ rangeFactorization f = f :=\n  funext fun _ => rfl\n\n"}
{"name":"Set.rangeFactorization_coe","module":"Mathlib.Data.Set.Image","initialProofState":"β : Type u_2\nι : Sort u_4\nf : ι → β\na : ι\n⊢ Eq (↑(Set.rangeFactorization f a)) (f a)","decl":"@[simp]\ntheorem rangeFactorization_coe (f : ι → β) (a : ι) : (rangeFactorization f a : β) = f a :=\n  rfl\n\n"}
{"name":"Set.coe_comp_rangeFactorization","module":"Mathlib.Data.Set.Image","initialProofState":"β : Type u_2\nι : Sort u_4\nf : ι → β\n⊢ Eq (Function.comp Subtype.val (Set.rangeFactorization f)) f","decl":"@[simp]\ntheorem coe_comp_rangeFactorization (f : ι → β) : (↑) ∘ rangeFactorization f = f := rfl\n\n"}
{"name":"Set.surjective_onto_range","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nι : Sort u_4\nf : ι → α\n⊢ Function.Surjective (Set.rangeFactorization f)","decl":"theorem surjective_onto_range : Surjective (rangeFactorization f) := fun ⟨_, ⟨i, rfl⟩⟩ => ⟨i, rfl⟩\n\n"}
{"name":"Set.image_eq_range","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\n⊢ Eq (Set.image f s) (Set.range fun x => f ↑x)","decl":"theorem image_eq_range (f : α → β) (s : Set α) : f '' s = range fun x : s => f x := by\n  ext\n  constructor\n  · rintro ⟨x, h1, h2⟩\n    exact ⟨⟨x, h1⟩, h2⟩\n  · rintro ⟨⟨x, h1⟩, h2⟩\n    exact ⟨x, h1, h2⟩\n\n"}
{"name":"Sum.range_eq","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Sum α β → γ\n⊢ Eq (Set.range f) (Union.union (Set.range (Function.comp f Sum.inl)) (Set.range (Function.comp f Sum.inr)))","decl":"theorem _root_.Sum.range_eq (f : α ⊕ β → γ) :\n    range f = range (f ∘ Sum.inl) ∪ range (f ∘ Sum.inr) :=\n  ext fun _ => Sum.exists\n\n"}
{"name":"Set.Sum.elim_range","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → γ\ng : β → γ\n⊢ Eq (Set.range (Sum.elim f g)) (Union.union (Set.range f) (Set.range g))","decl":"@[simp]\ntheorem Sum.elim_range (f : α → γ) (g : β → γ) : range (Sum.elim f g) = range f ∪ range g :=\n  Sum.range_eq _\n\n"}
{"name":"Set.range_ite_subset'","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\np : Prop\ninst✝ : Decidable p\nf g : α → β\n⊢ HasSubset.Subset (Set.range (ite p f g)) (Union.union (Set.range f) (Set.range g))","decl":"theorem range_ite_subset' {p : Prop} [Decidable p] {f g : α → β} :\n    range (if p then f else g) ⊆ range f ∪ range g := by\n  by_cases h : p\n  · rw [if_pos h]\n    exact subset_union_left\n  · rw [if_neg h]\n    exact subset_union_right\n\n"}
{"name":"Set.range_ite_subset","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\np : α → Prop\ninst✝ : DecidablePred p\nf g : α → β\n⊢ HasSubset.Subset (Set.range fun x => ite (p x) (f x) (g x)) (Union.union (Set.range f) (Set.range g))","decl":"theorem range_ite_subset {p : α → Prop} [DecidablePred p] {f g : α → β} :\n    (range fun x => if p x then f x else g x) ⊆ range f ∪ range g := by\n  rw [range_subset_iff]; intro x; by_cases h : p x\n  · simp only [if_pos h, mem_union, mem_range, exists_apply_eq_apply, true_or]\n  · simp [if_neg h, mem_union, mem_range_self]\n\n"}
{"name":"Set.preimage_range","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (Set.preimage f (Set.range f)) Set.univ","decl":"@[simp]\ntheorem preimage_range (f : α → β) : f ⁻¹' range f = univ :=\n  eq_univ_of_forall mem_range_self\n\n"}
{"name":"Set.range_unique","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nι : Sort u_4\nf : ι → α\nh : Unique ι\n⊢ Eq (Set.range f) (Singleton.singleton (f Inhabited.default))","decl":"/-- The range of a function from a `Unique` type contains just the\nfunction applied to its single value. -/\ntheorem range_unique [h : Unique ι] : range f = {f default} := by\n  ext x\n  rw [mem_range]\n  constructor\n  · rintro ⟨i, hi⟩\n    rw [h.uniq i] at hi\n    exact hi ▸ mem_singleton _\n  · exact fun h => ⟨default, h.symm⟩\n\n"}
{"name":"Set.range_diff_image_subset","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\n⊢ HasSubset.Subset (SDiff.sdiff (Set.range f) (Set.image f s)) (Set.image f (HasCompl.compl s))","decl":"theorem range_diff_image_subset (f : α → β) (s : Set α) : range f \\ f '' s ⊆ f '' sᶜ :=\n  fun _ ⟨⟨x, h₁⟩, h₂⟩ => ⟨x, fun h => h₂ ⟨x, h, h₁⟩, h₁⟩\n\n"}
{"name":"Set.range_inclusion","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns t : Set α\nh : HasSubset.Subset s t\n⊢ Eq (Set.range (Set.inclusion h)) (setOf fun x => Membership.mem s ↑x)","decl":"@[simp]\ntheorem range_inclusion (h : s ⊆ t) : range (inclusion h) = { x : t | (x : α) ∈ s } := by\n  ext ⟨x, hx⟩\n  simp\n\n-- When `f` is injective, see also `Equiv.ofInjective`.\n"}
{"name":"Set.leftInverse_rangeSplitting","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Function.LeftInverse (Set.rangeFactorization f) (Set.rangeSplitting f)","decl":"theorem leftInverse_rangeSplitting (f : α → β) :\n    LeftInverse (rangeFactorization f) (rangeSplitting f) := fun x => by\n  ext\n  simp only [rangeFactorization_coe]\n  apply apply_rangeSplitting\n\n"}
{"name":"Set.rangeSplitting_injective","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Function.Injective (Set.rangeSplitting f)","decl":"theorem rangeSplitting_injective (f : α → β) : Injective (rangeSplitting f) :=\n  (leftInverse_rangeSplitting f).injective\n\n"}
{"name":"Set.rightInverse_rangeSplitting","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nh : Function.Injective f\n⊢ Function.RightInverse (Set.rangeFactorization f) (Set.rangeSplitting f)","decl":"theorem rightInverse_rangeSplitting {f : α → β} (h : Injective f) :\n    RightInverse (rangeFactorization f) (rangeSplitting f) :=\n  (leftInverse_rangeSplitting f).rightInverse_of_injective fun _ _ hxy =>\n    h <| Subtype.ext_iff.1 hxy\n\n"}
{"name":"Set.preimage_rangeSplitting","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\n⊢ Eq (Set.preimage (Set.rangeSplitting f)) (Set.image (Set.rangeFactorization f))","decl":"theorem preimage_rangeSplitting {f : α → β} (hf : Injective f) :\n    preimage (rangeSplitting f) = image (rangeFactorization f) :=\n  (image_eq_preimage_of_inverse (rightInverse_rangeSplitting hf)\n      (leftInverse_rangeSplitting f)).symm\n\n"}
{"name":"Set.isCompl_range_some_none","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_5\n⊢ IsCompl (Set.range Option.some) (Singleton.singleton Option.none)","decl":"theorem isCompl_range_some_none (α : Type*) : IsCompl (range (some : α → Option α)) {none} :=\n  IsCompl.of_le (fun _ ⟨⟨_, ha⟩, (hn : _ = none)⟩ => Option.some_ne_none _ (ha.trans hn))\n    fun x _ => Option.casesOn x (Or.inr rfl) fun _ => Or.inl <| mem_range_self _\n\n"}
{"name":"Set.compl_range_some","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_5\n⊢ Eq (HasCompl.compl (Set.range Option.some)) (Singleton.singleton Option.none)","decl":"@[simp]\ntheorem compl_range_some (α : Type*) : (range (some : α → Option α))ᶜ = {none} :=\n  (isCompl_range_some_none α).compl_eq\n\n"}
{"name":"Set.range_some_inter_none","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_5\n⊢ Eq (Inter.inter (Set.range Option.some) (Singleton.singleton Option.none)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem range_some_inter_none (α : Type*) : range (some : α → Option α) ∩ {none} = ∅ :=\n  (isCompl_range_some_none α).inf_eq_bot\n\n-- Porting note:\n-- @[simp] `simp` can prove this\n"}
{"name":"Set.range_some_union_none","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_5\n⊢ Eq (Union.union (Set.range Option.some) (Singleton.singleton Option.none)) Set.univ","decl":"theorem range_some_union_none (α : Type*) : range (some : α → Option α) ∪ {none} = univ :=\n  (isCompl_range_some_none α).sup_eq_top\n\n"}
{"name":"Set.insert_none_range_some","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_5\n⊢ Eq (Insert.insert Option.none (Set.range Option.some)) Set.univ","decl":"@[simp]\ntheorem insert_none_range_some (α : Type*) : insert none (range (some : α → Option α)) = univ :=\n  (isCompl_range_some_none α).symm.sup_eq_top\n\n"}
{"name":"Set.image_of_range_union_range_eq_univ","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_5\nβ : Type u_6\nγ : Type u_7\nγ' : Type u_8\nδ : Type u_9\nδ' : Type u_10\nh : β → α\nf : γ → β\nf₁ : γ' → α\nf₂ : γ → γ'\ng : δ → β\ng₁ : δ' → α\ng₂ : δ → δ'\nhf : Eq (Function.comp h f) (Function.comp f₁ f₂)\nhg : Eq (Function.comp h g) (Function.comp g₁ g₂)\nhfg : Eq (Union.union (Set.range f) (Set.range g)) Set.univ\ns : Set β\n⊢ Eq (Set.image h s) (Union.union (Set.image f₁ (Set.image f₂ (Set.preimage f s))) (Set.image g₁ (Set.image g₂ (Set.preimage g s))))","decl":"lemma image_of_range_union_range_eq_univ {α β γ γ' δ δ' : Type*}\n    {h : β → α} {f : γ → β} {f₁ : γ' → α} {f₂ : γ → γ'} {g : δ → β} {g₁ : δ' → α} {g₂ : δ → δ'}\n    (hf : h ∘ f = f₁ ∘ f₂) (hg : h ∘ g = g₁ ∘ g₂) (hfg : range f ∪ range g = univ) (s : Set β) :\n    h '' s = f₁ '' (f₂ '' (f ⁻¹' s)) ∪ g₁ '' (g₂ '' (g ⁻¹' s)) := by\n  rw [← image_comp, ← image_comp, ← hf, ← hg, image_comp, image_comp, image_preimage_eq_inter_range,\n    image_preimage_eq_inter_range, ← image_union, ← inter_union_distrib_left, hfg, inter_univ]\n\n"}
{"name":"Set.Subsingleton.image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nhs : s.Subsingleton\nf : α → β\n⊢ (Set.image f s).Subsingleton","decl":"/-- The image of a subsingleton is a subsingleton. -/\ntheorem Subsingleton.image (hs : s.Subsingleton) (f : α → β) : (f '' s).Subsingleton :=\n  fun _ ⟨_, hx, Hx⟩ _ ⟨_, hy, Hy⟩ => Hx ▸ Hy ▸ congr_arg f (hs hx hy)\n\n"}
{"name":"Set.Subsingleton.preimage","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\nhs : s.Subsingleton\nhf : Function.Injective f\n⊢ (Set.preimage f s).Subsingleton","decl":"/-- The preimage of a subsingleton under an injective map is a subsingleton. -/\ntheorem Subsingleton.preimage {s : Set β} (hs : s.Subsingleton)\n    (hf : Function.Injective f) : (f ⁻¹' s).Subsingleton := fun _ ha _ hb => hf <| hs ha hb\n\n"}
{"name":"Set.subsingleton_of_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\ns : Set α\nhs : (Set.image f s).Subsingleton\n⊢ s.Subsingleton","decl":"/-- If the image of a set under an injective map is a subsingleton, the set is a subsingleton. -/\ntheorem subsingleton_of_image (hf : Function.Injective f) (s : Set α)\n    (hs : (f '' s).Subsingleton) : s.Subsingleton :=\n  (hs.preimage hf).anti <| subset_preimage_image _ _\n\n"}
{"name":"Set.subsingleton_of_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Surjective f\ns : Set β\nhs : (Set.preimage f s).Subsingleton\n⊢ s.Subsingleton","decl":"/-- If the preimage of a set under a surjective map is a subsingleton,\nthe set is a subsingleton. -/\ntheorem subsingleton_of_preimage (hf : Function.Surjective f) (s : Set β)\n    (hs : (f ⁻¹' s).Subsingleton) : s.Subsingleton := fun fx hx fy hy => by\n  rcases hf fx, hf fy with ⟨⟨x, rfl⟩, ⟨y, rfl⟩⟩\n  exact congr_arg f (hs hx hy)\n\n"}
{"name":"Set.subsingleton_range","module":"Mathlib.Data.Set.Image","initialProofState":"β : Type u_2\nα : Sort u_5\ninst✝ : Subsingleton α\nf : α → β\n⊢ (Set.range f).Subsingleton","decl":"theorem subsingleton_range {α : Sort*} [Subsingleton α] (f : α → β) : (range f).Subsingleton :=\n  forall_mem_range.2 fun x => forall_mem_range.2 fun y => congr_arg f (Subsingleton.elim x y)\n\n"}
{"name":"Set.Nontrivial.preimage","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\nhs : s.Nontrivial\nhf : Function.Surjective f\n⊢ (Set.preimage f s).Nontrivial","decl":"/-- The preimage of a nontrivial set under a surjective map is nontrivial. -/\ntheorem Nontrivial.preimage {s : Set β} (hs : s.Nontrivial)\n    (hf : Function.Surjective f) : (f ⁻¹' s).Nontrivial := by\n  rcases hs with ⟨fx, hx, fy, hy, hxy⟩\n  rcases hf fx, hf fy with ⟨⟨x, rfl⟩, ⟨y, rfl⟩⟩\n  exact ⟨x, hx, y, hy, mt (congr_arg f) hxy⟩\n\n"}
{"name":"Set.Nontrivial.image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nhs : s.Nontrivial\nhf : Function.Injective f\n⊢ (Set.image f s).Nontrivial","decl":"/-- The image of a nontrivial set under an injective map is nontrivial. -/\ntheorem Nontrivial.image (hs : s.Nontrivial) (hf : Function.Injective f) :\n    (f '' s).Nontrivial :=\n  let ⟨x, hx, y, hy, hxy⟩ := hs\n  ⟨f x, mem_image_of_mem f hx, f y, mem_image_of_mem f hy, hf.ne hxy⟩\n\n"}
{"name":"Set.Nontrivial.image_of_injOn","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nhs : s.Nontrivial\nhf : Set.InjOn f s\n⊢ (Set.image f s).Nontrivial","decl":"theorem Nontrivial.image_of_injOn (hs : s.Nontrivial) (hf : s.InjOn f) :\n    (f '' s).Nontrivial := by\n  obtain ⟨x, hx, y, hy, hxy⟩ := hs\n  exact ⟨f x, mem_image_of_mem _ hx, f y, mem_image_of_mem _ hy, (hxy <| hf hx hy ·)⟩\n\n"}
{"name":"Set.nontrivial_of_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\nhs : (Set.image f s).Nontrivial\n⊢ s.Nontrivial","decl":"/-- If the image of a set is nontrivial, the set is nontrivial. -/\ntheorem nontrivial_of_image (f : α → β) (s : Set α) (hs : (f '' s).Nontrivial) : s.Nontrivial :=\n  let ⟨_, ⟨x, hx, rfl⟩, _, ⟨y, hy, rfl⟩, hxy⟩ := hs\n  ⟨x, hx, y, hy, mt (congr_arg f) hxy⟩\n\n"}
{"name":"Set.image_nontrivial","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nhf : Function.Injective f\n⊢ Iff (Set.image f s).Nontrivial s.Nontrivial","decl":"@[simp]\ntheorem image_nontrivial (hf : f.Injective) : (f '' s).Nontrivial ↔ s.Nontrivial :=\n  ⟨nontrivial_of_image f s, fun h ↦ h.image hf⟩\n\n"}
{"name":"Set.InjOn.image_nontrivial_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nhf : Set.InjOn f s\n⊢ Iff (Set.image f s).Nontrivial s.Nontrivial","decl":"@[simp]\ntheorem InjOn.image_nontrivial_iff (hf : s.InjOn f) :\n    (f '' s).Nontrivial ↔ s.Nontrivial :=\n  ⟨nontrivial_of_image f s, fun h ↦ h.image_of_injOn hf⟩\n\n"}
{"name":"Set.nontrivial_of_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\ns : Set β\nhs : (Set.preimage f s).Nontrivial\n⊢ s.Nontrivial","decl":"/-- If the preimage of a set under an injective map is nontrivial, the set is nontrivial. -/\ntheorem nontrivial_of_preimage (hf : Function.Injective f) (s : Set β)\n    (hs : (f ⁻¹' s).Nontrivial) : s.Nontrivial :=\n  (hs.image hf).mono <| image_preimage_subset _ _\n\n"}
{"name":"Function.Surjective.preimage_injective","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Surjective f\n⊢ Function.Injective (Set.preimage f)","decl":"theorem Surjective.preimage_injective (hf : Surjective f) : Injective (preimage f) := fun _ _ =>\n  (preimage_eq_preimage hf).1\n\n"}
{"name":"Function.Injective.preimage_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\ns : Set α\n⊢ Eq (Set.preimage f (Set.image f s)) s","decl":"theorem Injective.preimage_image (hf : Injective f) (s : Set α) : f ⁻¹' (f '' s) = s :=\n  preimage_image_eq s hf\n\n"}
{"name":"Function.Injective.preimage_surjective","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\n⊢ Function.Surjective (Set.preimage f)","decl":"theorem Injective.preimage_surjective (hf : Injective f) : Surjective (preimage f) := by\n  intro s\n  use f '' s\n  rw [hf.preimage_image]\n\n"}
{"name":"Function.Injective.subsingleton_image_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\ns : Set α\n⊢ Iff (Set.image f s).Subsingleton s.Subsingleton","decl":"theorem Injective.subsingleton_image_iff (hf : Injective f) {s : Set α} :\n    (f '' s).Subsingleton ↔ s.Subsingleton :=\n  ⟨subsingleton_of_image hf s, fun h => h.image f⟩\n\n"}
{"name":"Function.Surjective.image_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Surjective f\ns : Set β\n⊢ Eq (Set.image f (Set.preimage f s)) s","decl":"theorem Surjective.image_preimage (hf : Surjective f) (s : Set β) : f '' (f ⁻¹' s) = s :=\n  image_preimage_eq s hf\n\n"}
{"name":"Function.Surjective.image_surjective","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Surjective f\n⊢ Function.Surjective (Set.image f)","decl":"theorem Surjective.image_surjective (hf : Surjective f) : Surjective (image f) := by\n  intro s\n  use f ⁻¹' s\n  rw [hf.image_preimage]\n\n"}
{"name":"Function.Surjective.nonempty_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Surjective f\ns : Set β\n⊢ Iff (Set.preimage f s).Nonempty s.Nonempty","decl":"@[simp]\ntheorem Surjective.nonempty_preimage (hf : Surjective f) {s : Set β} :\n    (f ⁻¹' s).Nonempty ↔ s.Nonempty := by rw [← image_nonempty, hf.image_preimage]\n\n"}
{"name":"Function.Injective.image_injective","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\n⊢ Function.Injective (Set.image f)","decl":"theorem Injective.image_injective (hf : Injective f) : Injective (image f) := by\n  intro s t h\n  rw [← preimage_image_eq s hf, ← preimage_image_eq t hf, h]\n\n"}
{"name":"Function.Injective.image_strictMono","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ninj : Function.Injective f\n⊢ StrictMono (Set.image f)","decl":"lemma Injective.image_strictMono (inj : Function.Injective f) : StrictMono (image f) :=\n  monotone_image.strictMono_of_injective inj.image_injective\n\n"}
{"name":"Function.Surjective.preimage_subset_preimage_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns t : Set β\nhf : Function.Surjective f\n⊢ Iff (HasSubset.Subset (Set.preimage f s) (Set.preimage f t)) (HasSubset.Subset s t)","decl":"theorem Surjective.preimage_subset_preimage_iff {s t : Set β} (hf : Surjective f) :\n    f ⁻¹' s ⊆ f ⁻¹' t ↔ s ⊆ t := by\n  apply Set.preimage_subset_preimage_iff\n  rw [hf.range_eq]\n  apply subset_univ\n\n"}
{"name":"Function.Surjective.range_comp","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nι : Sort u_3\nι' : Sort u_4\nf : ι → ι'\nhf : Function.Surjective f\ng : ι' → α\n⊢ Eq (Set.range (Function.comp g f)) (Set.range g)","decl":"theorem Surjective.range_comp {ι' : Sort*} {f : ι → ι'} (hf : Surjective f) (g : ι' → α) :\n    range (g ∘ f) = range g :=\n  ext fun y => (@Surjective.exists _ _ _ hf fun x => g x = y).symm\n\n"}
{"name":"Function.Injective.mem_range_iff_existsUnique","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\nb : β\n⊢ Iff (Membership.mem (Set.range f) b) (ExistsUnique fun a => Eq (f a) b)","decl":"theorem Injective.mem_range_iff_existsUnique (hf : Injective f) {b : β} :\n    b ∈ range f ↔ ∃! a, f a = b :=\n  ⟨fun ⟨a, h⟩ => ⟨a, h, fun _ ha => hf (ha.trans h.symm)⟩, ExistsUnique.exists⟩\n\n"}
{"name":"Function.Injective.existsUnique_of_mem_range","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\nb : β\na✝ : Membership.mem (Set.range f) b\n⊢ ExistsUnique fun a => Eq (f a) b","decl":"alias ⟨Injective.existsUnique_of_mem_range, _⟩ := Injective.mem_range_iff_existsUnique\n\n"}
{"name":"Function.Injective.mem_range_iff_exists_unique","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\nb : β\n⊢ Iff (Membership.mem (Set.range f) b) (ExistsUnique fun a => Eq (f a) b)","decl":"@[deprecated (since := \"2024-09-25\")]\nalias Injective.mem_range_iff_exists_unique := Injective.mem_range_iff_existsUnique\n\n"}
{"name":"Function.Injective.exists_unique_of_mem_range","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\nb : β\na✝ : Membership.mem (Set.range f) b\n⊢ ExistsUnique fun a => Eq (f a) b","decl":"@[deprecated (since := \"2024-09-25\")]\nalias Injective.exists_unique_of_mem_range := Injective.existsUnique_of_mem_range\n\n"}
{"name":"Function.Injective.compl_image_eq","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\ns : Set α\n⊢ Eq (HasCompl.compl (Set.image f s)) (Union.union (Set.image f (HasCompl.compl s)) (HasCompl.compl (Set.range f)))","decl":"theorem Injective.compl_image_eq (hf : Injective f) (s : Set α) :\n    (f '' s)ᶜ = f '' sᶜ ∪ (range f)ᶜ := by\n  ext y\n  rcases em (y ∈ range f) with (⟨x, rfl⟩ | hx)\n  · simp [hf.eq_iff]\n  · rw [mem_range, not_exists] at hx\n    simp [hx]\n\n"}
{"name":"Function.LeftInverse.image_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ng : β → α\nh : Function.LeftInverse g f\ns : Set α\n⊢ Eq (Set.image g (Set.image f s)) s","decl":"theorem LeftInverse.image_image {g : β → α} (h : LeftInverse g f) (s : Set α) :\n    g '' (f '' s) = s := by rw [← image_comp, h.comp_eq_id, image_id]\n\n"}
{"name":"Function.LeftInverse.preimage_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ng : β → α\nh : Function.LeftInverse g f\ns : Set α\n⊢ Eq (Set.preimage f (Set.preimage g s)) s","decl":"theorem LeftInverse.preimage_preimage {g : β → α} (h : LeftInverse g f) (s : Set α) :\n    f ⁻¹' (g ⁻¹' s) = s := by rw [← preimage_comp, h.comp_eq_id, preimage_id]\n\n"}
{"name":"Function.Involutive.preimage","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nf : α → α\nhf : Function.Involutive f\n⊢ Function.Involutive (Set.preimage f)","decl":"protected theorem Involutive.preimage {f : α → α} (hf : Involutive f) : Involutive (preimage f) :=\n  hf.rightInverse.preimage_preimage\n\n"}
{"name":"EquivLike.range_comp","module":"Mathlib.Data.Set.Image","initialProofState":"ι : Sort u_1\nι' : Sort u_2\nE : Type u_3\ninst✝ : EquivLike E ι ι'\nα : Type u_4\nf : ι' → α\ne : E\n⊢ Eq (Set.range (Function.comp f ⇑e)) (Set.range f)","decl":"@[simp] lemma range_comp {α : Type*} (f : ι' → α) (e : E) : range (f ∘ e) = range f :=\n  (EquivLike.surjective _).range_comp _\n\n"}
{"name":"Subtype.coe_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\np : α → Prop\ns : Set (Subtype p)\n⊢ Eq (Set.image Subtype.val s) (setOf fun x => Exists fun h => Membership.mem s ⟨x, h⟩)","decl":"theorem coe_image {p : α → Prop} {s : Set (Subtype p)} :\n    (↑) '' s = { x | ∃ h : p x, (⟨x, h⟩ : Subtype p) ∈ s } :=\n  Set.ext fun a =>\n    ⟨fun ⟨⟨_, ha'⟩, in_s, h_eq⟩ => h_eq ▸ ⟨ha', in_s⟩, fun ⟨ha, in_s⟩ => ⟨⟨a, ha⟩, in_s, rfl⟩⟩\n\n"}
{"name":"Subtype.coe_image_of_subset","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns t : Set α\nh : HasSubset.Subset t s\n⊢ Eq (Set.image Subtype.val (setOf fun x => Membership.mem t ↑x)) t","decl":"@[simp]\ntheorem coe_image_of_subset {s t : Set α} (h : t ⊆ s) : (↑) '' { x : ↥s | ↑x ∈ t } = t := by\n  ext x\n  rw [mem_image]\n  exact ⟨fun ⟨_, hx', hx⟩ => hx ▸ hx', fun hx => ⟨⟨x, h hx⟩, hx, rfl⟩⟩\n\n"}
{"name":"Subtype.range_coe","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Set.range Subtype.val) s","decl":"theorem range_coe {s : Set α} : range ((↑) : s → α) = s := by\n  rw [← image_univ]\n  simp [-image_univ, coe_image]\n\n"}
{"name":"Subtype.range_val","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Set.range Subtype.val) s","decl":"/-- A variant of `range_coe`. Try to use `range_coe` if possible.\n  This version is useful when defining a new type that is defined as the subtype of something.\n  In that case, the coercion doesn't fire anymore. -/\ntheorem range_val {s : Set α} : range (Subtype.val : s → α) = s :=\n  range_coe\n\n"}
{"name":"Subtype.range_coe_subtype","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\np : α → Prop\n⊢ Eq (Set.range Subtype.val) (setOf fun x => p x)","decl":"/-- We make this the simp lemma instead of `range_coe`. The reason is that if we write\n  for `s : Set α` the function `(↑) : s → α`, then the inferred implicit arguments of `(↑)` are\n  `↑α (fun x ↦ x ∈ s)`. -/\n@[simp]\ntheorem range_coe_subtype {p : α → Prop} : range ((↑) : Subtype p → α) = { x | p x } :=\n  range_coe\n\n"}
{"name":"Subtype.coe_preimage_self","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Set.preimage Subtype.val s) Set.univ","decl":"@[simp]\ntheorem coe_preimage_self (s : Set α) : ((↑) : s → α) ⁻¹' s = univ := by\n  rw [← preimage_range, range_coe]\n\n"}
{"name":"Subtype.range_val_subtype","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\np : α → Prop\n⊢ Eq (Set.range Subtype.val) (setOf fun x => p x)","decl":"theorem range_val_subtype {p : α → Prop} : range (Subtype.val : Subtype p → α) = { x | p x } :=\n  range_coe\n\n"}
{"name":"Subtype.coe_image_subset","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns : Set α\nt : Set ↑s\n⊢ HasSubset.Subset (Set.image Subtype.val t) s","decl":"theorem coe_image_subset (s : Set α) (t : Set s) : ((↑) : s → α) '' t ⊆ s :=\n  fun x ⟨y, _, yvaleq⟩ => by\n  rw [← yvaleq]; exact y.property\n\n"}
{"name":"Subtype.coe_image_univ","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Set.image Subtype.val Set.univ) s","decl":"theorem coe_image_univ (s : Set α) : ((↑) : s → α) '' Set.univ = s :=\n  image_univ.trans range_coe\n\n"}
{"name":"Subtype.image_preimage_coe","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns t : Set α\n⊢ Eq (Set.image Subtype.val (Set.preimage Subtype.val t)) (Inter.inter s t)","decl":"@[simp]\ntheorem image_preimage_coe (s t : Set α) : ((↑) : s → α) '' (((↑) : s → α) ⁻¹' t) = s ∩ t :=\n  image_preimage_eq_range_inter.trans <| congr_arg (· ∩ t) range_coe\n\n"}
{"name":"Subtype.image_preimage_val","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns t : Set α\n⊢ Eq (Set.image Subtype.val (Set.preimage Subtype.val t)) (Inter.inter s t)","decl":"theorem image_preimage_val (s t : Set α) : (Subtype.val : s → α) '' (Subtype.val ⁻¹' t) = s ∩ t :=\n  image_preimage_coe s t\n\n"}
{"name":"Subtype.preimage_coe_eq_preimage_coe_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns t u : Set α\n⊢ Iff (Eq (Set.preimage Subtype.val t) (Set.preimage Subtype.val u)) (Eq (Inter.inter s t) (Inter.inter s u))","decl":"theorem preimage_coe_eq_preimage_coe_iff {s t u : Set α} :\n    ((↑) : s → α) ⁻¹' t = ((↑) : s → α) ⁻¹' u ↔ s ∩ t = s ∩ u := by\n  rw [← image_preimage_coe, ← image_preimage_coe, coe_injective.image_injective.eq_iff]\n\n"}
{"name":"Subtype.preimage_coe_self_inter","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns t : Set α\n⊢ Eq (Set.preimage Subtype.val (Inter.inter s t)) (Set.preimage Subtype.val t)","decl":"theorem preimage_coe_self_inter (s t : Set α) :\n    ((↑) : s → α) ⁻¹' (s ∩ t) = ((↑) : s → α) ⁻¹' t := by\n  rw [preimage_coe_eq_preimage_coe_iff, ← inter_assoc, inter_self]\n\n-- Porting note:\n-- @[simp] `simp` can prove this\n"}
{"name":"Subtype.preimage_coe_inter_self","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns t : Set α\n⊢ Eq (Set.preimage Subtype.val (Inter.inter t s)) (Set.preimage Subtype.val t)","decl":"theorem preimage_coe_inter_self (s t : Set α) :\n    ((↑) : s → α) ⁻¹' (t ∩ s) = ((↑) : s → α) ⁻¹' t := by\n  rw [inter_comm, preimage_coe_self_inter]\n\n"}
{"name":"Subtype.preimage_val_eq_preimage_val_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns t u : Set α\n⊢ Iff (Eq (Set.preimage Subtype.val t) (Set.preimage Subtype.val u)) (Eq (Inter.inter s t) (Inter.inter s u))","decl":"theorem preimage_val_eq_preimage_val_iff (s t u : Set α) :\n    (Subtype.val : s → α) ⁻¹' t = Subtype.val ⁻¹' u ↔ s ∩ t = s ∩ u :=\n  preimage_coe_eq_preimage_coe_iff\n\n"}
{"name":"Subtype.preimage_val_subset_preimage_val_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns t u : Set α\n⊢ Iff (HasSubset.Subset (Set.preimage Subtype.val t) (Set.preimage Subtype.val u)) (HasSubset.Subset (Inter.inter s t) (Inter.inter s u))","decl":"lemma preimage_val_subset_preimage_val_iff (s t u : Set α) :\n    (Subtype.val ⁻¹' t : Set s) ⊆ Subtype.val ⁻¹' u ↔ s ∩ t ⊆ s ∩ u := by\n  constructor\n  · rw [← image_preimage_coe, ← image_preimage_coe]\n    exact image_subset _\n  · intro h x a\n    exact (h ⟨x.2, a⟩).2\n\n"}
{"name":"Subtype.exists_set_subtype","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nt : Set α\np : Set α → Prop\n⊢ Iff (Exists fun s => p (Set.image Subtype.val s)) (Exists fun s => And (HasSubset.Subset s t) (p s))","decl":"theorem exists_set_subtype {t : Set α} (p : Set α → Prop) :\n    (∃ s : Set t, p (((↑) : t → α) '' s)) ↔ ∃ s : Set α, s ⊆ t ∧ p s := by\n  rw [← exists_subset_range_and_iff, range_coe]\n\n"}
{"name":"Subtype.forall_set_subtype","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nt : Set α\np : Set α → Prop\n⊢ Iff (∀ (s : Set ↑t), p (Set.image Subtype.val s)) (∀ (s : Set α), HasSubset.Subset s t → p s)","decl":"theorem forall_set_subtype {t : Set α} (p : Set α → Prop) :\n    (∀ s : Set t, p (((↑) : t → α) '' s)) ↔ ∀ s : Set α, s ⊆ t → p s := by\n  rw [← forall_subset_range_iff, range_coe]\n\n"}
{"name":"Subtype.preimage_coe_nonempty","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns t : Set α\n⊢ Iff (Set.preimage Subtype.val t).Nonempty (Inter.inter s t).Nonempty","decl":"theorem preimage_coe_nonempty {s t : Set α} :\n    (((↑) : s → α) ⁻¹' t).Nonempty ↔ (s ∩ t).Nonempty := by\n  rw [← image_preimage_coe, image_nonempty]\n\n"}
{"name":"Subtype.preimage_coe_eq_empty","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns t : Set α\n⊢ Iff (Eq (Set.preimage Subtype.val t) EmptyCollection.emptyCollection) (Eq (Inter.inter s t) EmptyCollection.emptyCollection)","decl":"theorem preimage_coe_eq_empty {s t : Set α} : ((↑) : s → α) ⁻¹' t = ∅ ↔ s ∩ t = ∅ := by\n  simp [← not_nonempty_iff_eq_empty, preimage_coe_nonempty]\n\n-- Porting note:\n-- @[simp] `simp` can prove this\n"}
{"name":"Subtype.preimage_coe_compl","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Set.preimage Subtype.val (HasCompl.compl s)) EmptyCollection.emptyCollection","decl":"theorem preimage_coe_compl (s : Set α) : ((↑) : s → α) ⁻¹' sᶜ = ∅ :=\n  preimage_coe_eq_empty.2 (inter_compl_self s)\n\n"}
{"name":"Subtype.preimage_coe_compl'","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Set.preimage (fun x => ↑x) s) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem preimage_coe_compl' (s : Set α) :\n    (fun x : (sᶜ : Set α) => (x : α)) ⁻¹' s = ∅ :=\n  preimage_coe_eq_empty.2 (compl_inter_self s)\n\n"}
{"name":"Option.injective_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Option α → β\n⊢ Iff (Function.Injective f) (And (Function.Injective (Function.comp f Option.some)) (Not (Membership.mem (Set.range (Function.comp f Option.some)) (f Option.none))))","decl":"theorem injective_iff {α β} {f : Option α → β} :\n    Injective f ↔ Injective (f ∘ some) ∧ f none ∉ range (f ∘ some) := by\n  simp only [mem_range, not_exists, (· ∘ ·)]\n  refine\n    ⟨fun hf => ⟨hf.comp (Option.some_injective _), fun x => hf.ne <| Option.some_ne_none _⟩, ?_⟩\n  rintro ⟨h_some, h_none⟩ (_ | a) (_ | b) hab\n  exacts [rfl, (h_none _ hab.symm).elim, (h_none _ hab).elim, congr_arg some (h_some hab)]\n\n"}
{"name":"Option.range_eq","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Option α → β\n⊢ Eq (Set.range f) (Insert.insert (f Option.none) (Set.range (Function.comp f Option.some)))","decl":"theorem range_eq {α β} (f : Option α → β) : range f = insert (f none) (range (f ∘ some)) :=\n  Set.ext fun _ => Option.exists.trans <| eq_comm.or Iff.rfl\n\n"}
{"name":"WithBot.range_eq","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : WithBot α → β\n⊢ Eq (Set.range f) (Insert.insert (f Bot.bot) (Set.range (Function.comp f WithBot.some)))","decl":"theorem WithBot.range_eq {α β} (f : WithBot α → β) :\n    range f = insert (f ⊥) (range (f ∘ WithBot.some : α → β)) :=\n  Option.range_eq f\n\n"}
{"name":"WithTop.range_eq","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : WithTop α → β\n⊢ Eq (Set.range f) (Insert.insert (f Top.top) (Set.range (Function.comp f WithBot.some)))","decl":"theorem WithTop.range_eq {α β} (f : WithTop α → β) :\n    range f = insert (f ⊤) (range (f ∘ WithBot.some : α → β)) :=\n  Option.range_eq f\n\n"}
{"name":"Set.preimage_injective","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u\nβ : Type v\nf : α → β\n⊢ Iff (Function.Injective (Set.preimage f)) (Function.Surjective f)","decl":"@[simp]\ntheorem preimage_injective : Injective (preimage f) ↔ Surjective f := by\n  refine ⟨fun h y => ?_, Surjective.preimage_injective⟩\n  obtain ⟨x, hx⟩ : (f ⁻¹' {y}).Nonempty := by\n    rw [h.nonempty_apply_iff preimage_empty]\n    apply singleton_nonempty\n  exact ⟨x, hx⟩\n\n"}
{"name":"Set.preimage_surjective","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u\nβ : Type v\nf : α → β\n⊢ Iff (Function.Surjective (Set.preimage f)) (Function.Injective f)","decl":"@[simp]\ntheorem preimage_surjective : Surjective (preimage f) ↔ Injective f := by\n  refine ⟨fun h x x' hx => ?_, Injective.preimage_surjective⟩\n  rcases h {x} with ⟨s, hs⟩; have := mem_singleton x\n  rwa [← hs, mem_preimage, hx, ← mem_preimage, hs, mem_singleton_iff, eq_comm] at this\n\n"}
{"name":"Set.image_surjective","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u\nβ : Type v\nf : α → β\n⊢ Iff (Function.Surjective (Set.image f)) (Function.Surjective f)","decl":"@[simp]\ntheorem image_surjective : Surjective (image f) ↔ Surjective f := by\n  refine ⟨fun h y => ?_, Surjective.image_surjective⟩\n  rcases h {y} with ⟨s, hs⟩\n  have := mem_singleton y; rw [← hs] at this; rcases this with ⟨x, _, hx⟩\n  exact ⟨x, hx⟩\n\n"}
{"name":"Set.image_injective","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u\nβ : Type v\nf : α → β\n⊢ Iff (Function.Injective (Set.image f)) (Function.Injective f)","decl":"@[simp]\ntheorem image_injective : Injective (image f) ↔ Injective f := by\n  refine ⟨fun h x x' hx => ?_, Injective.image_injective⟩\n  rw [← singleton_eq_singleton_iff]; apply h\n  rw [image_singleton, image_singleton, hx]\n\n"}
{"name":"Set.preimage_eq_iff_eq_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nhf : Function.Bijective f\ns : Set β\nt : Set α\n⊢ Iff (Eq (Set.preimage f s) t) (Eq s (Set.image f t))","decl":"theorem preimage_eq_iff_eq_image {f : α → β} (hf : Bijective f) {s t} :\n    f ⁻¹' s = t ↔ s = f '' t := by rw [← image_eq_image hf.1, hf.2.image_preimage]\n\n"}
{"name":"Set.eq_preimage_iff_image_eq","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nhf : Function.Bijective f\ns : Set α\nt : Set β\n⊢ Iff (Eq s (Set.preimage f t)) (Eq (Set.image f s) t)","decl":"theorem eq_preimage_iff_image_eq {f : α → β} (hf : Bijective f) {s t} :\n    s = f ⁻¹' t ↔ f '' s = t := by rw [← image_eq_image hf.1, hf.2.image_preimage]\n\n"}
{"name":"Disjoint.preimage","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns t : Set β\nh : Disjoint s t\n⊢ Disjoint (Set.preimage f s) (Set.preimage f t)","decl":"theorem Disjoint.preimage (f : α → β) {s t : Set β} (h : Disjoint s t) :\n    Disjoint (f ⁻¹' s) (f ⁻¹' t) :=\n  disjoint_iff_inf_le.mpr fun _ hx => h.le_bot hx\n\n"}
{"name":"Codisjoint.preimage","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns t : Set β\nh : Codisjoint s t\n⊢ Codisjoint (Set.preimage f s) (Set.preimage f t)","decl":"lemma Codisjoint.preimage (f : α → β) {s t : Set β} (h : Codisjoint s t) :\n    Codisjoint (f ⁻¹' s) (f ⁻¹' t) := by\n  simp only [codisjoint_iff_le_sup, Set.sup_eq_union, top_le_iff, ← Set.preimage_union] at h ⊢\n  rw [h]; rfl\n\n"}
{"name":"IsCompl.preimage","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns t : Set β\nh : IsCompl s t\n⊢ IsCompl (Set.preimage f s) (Set.preimage f t)","decl":"lemma IsCompl.preimage (f : α → β) {s t : Set β} (h : IsCompl s t) :\n    IsCompl (f ⁻¹' s) (f ⁻¹' t) :=\n  ⟨h.1.preimage f, h.2.preimage f⟩\n\n"}
{"name":"Set.disjoint_image_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : β → α\ng : γ → α\ns : Set β\nt : Set γ\nh : ∀ (b : β), Membership.mem s b → ∀ (c : γ), Membership.mem t c → Ne (f b) (g c)\n⊢ Disjoint (Set.image f s) (Set.image g t)","decl":"theorem disjoint_image_image {f : β → α} {g : γ → α} {s : Set β} {t : Set γ}\n    (h : ∀ b ∈ s, ∀ c ∈ t, f b ≠ g c) : Disjoint (f '' s) (g '' t) :=\n  disjoint_iff_inf_le.mpr <| by rintro a ⟨⟨b, hb, eq⟩, c, hc, rfl⟩; exact h b hb c hc eq\n\n"}
{"name":"Set.disjoint_image_of_injective","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\ns t : Set α\nhd : Disjoint s t\n⊢ Disjoint (Set.image f s) (Set.image f t)","decl":"theorem disjoint_image_of_injective (hf : Injective f) {s t : Set α} (hd : Disjoint s t) :\n    Disjoint (f '' s) (f '' t) :=\n  disjoint_image_image fun _ hx _ hy => hf.ne fun H => Set.disjoint_iff.1 hd ⟨hx, H.symm ▸ hy⟩\n\n"}
{"name":"Disjoint.of_image","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns t : Set α\nh : Disjoint (Set.image f s) (Set.image f t)\n⊢ Disjoint s t","decl":"theorem _root_.Disjoint.of_image (h : Disjoint (f '' s) (f '' t)) : Disjoint s t :=\n  disjoint_iff_inf_le.mpr fun _ hx =>\n    disjoint_left.1 h (mem_image_of_mem _ hx.1) (mem_image_of_mem _ hx.2)\n\n"}
{"name":"Set.disjoint_image_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns t : Set α\nhf : Function.Injective f\n⊢ Iff (Disjoint (Set.image f s) (Set.image f t)) (Disjoint s t)","decl":"@[simp]\ntheorem disjoint_image_iff (hf : Injective f) : Disjoint (f '' s) (f '' t) ↔ Disjoint s t :=\n  ⟨Disjoint.of_image, disjoint_image_of_injective hf⟩\n\n"}
{"name":"Disjoint.of_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Surjective f\ns t : Set β\nh : Disjoint (Set.preimage f s) (Set.preimage f t)\n⊢ Disjoint s t","decl":"theorem _root_.Disjoint.of_preimage (hf : Surjective f) {s t : Set β}\n    (h : Disjoint (f ⁻¹' s) (f ⁻¹' t)) : Disjoint s t := by\n  rw [disjoint_iff_inter_eq_empty, ← image_preimage_eq (_ ∩ _) hf, preimage_inter, h.inter_eq,\n    image_empty]\n\n"}
{"name":"Set.disjoint_preimage_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Surjective f\ns t : Set β\n⊢ Iff (Disjoint (Set.preimage f s) (Set.preimage f t)) (Disjoint s t)","decl":"@[simp]\ntheorem disjoint_preimage_iff (hf : Surjective f) {s t : Set β} :\n    Disjoint (f ⁻¹' s) (f ⁻¹' t) ↔ Disjoint s t :=\n  ⟨Disjoint.of_preimage hf, Disjoint.preimage _⟩\n\n"}
{"name":"Set.preimage_eq_empty","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\nh : Disjoint s (Set.range f)\n⊢ Eq (Set.preimage f s) EmptyCollection.emptyCollection","decl":"theorem preimage_eq_empty {s : Set β} (h : Disjoint s (range f)) :\n    f ⁻¹' s = ∅ := by\n  simpa using h.preimage f\n\n"}
{"name":"Set.preimage_eq_empty_iff","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\n⊢ Iff (Eq (Set.preimage f s) EmptyCollection.emptyCollection) (Disjoint s (Set.range f))","decl":"theorem preimage_eq_empty_iff {s : Set β} : f ⁻¹' s = ∅ ↔ Disjoint s (range f) :=\n  ⟨fun h => by\n    simp only [eq_empty_iff_forall_not_mem, disjoint_iff_inter_eq_empty, not_exists, mem_inter_iff,\n      not_and, mem_range, mem_preimage] at h ⊢\n    intro y hy x hx\n    rw [← hx] at hy\n    exact h x hy,\n  preimage_eq_empty⟩\n\n"}
{"name":"sigma_mk_preimage_image'","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : α → Type u_2\ni j : α\ns : Set (β i)\nh : Ne i j\n⊢ Eq (Set.preimage (Sigma.mk j) (Set.image (Sigma.mk i) s)) EmptyCollection.emptyCollection","decl":"lemma sigma_mk_preimage_image' (h : i ≠ j) : Sigma.mk j ⁻¹' (Sigma.mk i '' s) = ∅ := by\n  simp [image, h]\n\n"}
{"name":"sigma_mk_preimage_image_eq_self","module":"Mathlib.Data.Set.Image","initialProofState":"α : Type u_1\nβ : α → Type u_2\ni : α\ns : Set (β i)\n⊢ Eq (Set.preimage (Sigma.mk i) (Set.image (Sigma.mk i) s)) s","decl":"lemma sigma_mk_preimage_image_eq_self : Sigma.mk i ⁻¹' (Sigma.mk i '' s) = s := by\n  simp [image]\n\n"}
