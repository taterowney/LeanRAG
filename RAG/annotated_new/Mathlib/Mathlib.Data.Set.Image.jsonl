{"name":"Set.preimage_empty","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nâŠ¢ Eq (Set.preimage f EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem preimage_empty : f â»Â¹' âˆ… = âˆ… :=\n  rfl\n\n"}
{"name":"Set.preimage_congr","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf g : Î± â†’ Î²\ns : Set Î²\nh : âˆ€ (x : Î±), Eq (f x) (g x)\nâŠ¢ Eq (Set.preimage f s) (Set.preimage g s)","decl":"theorem preimage_congr {f g : Î± â†’ Î²} {s : Set Î²} (h : âˆ€ x : Î±, f x = g x) : f â»Â¹' s = g â»Â¹' s := by\n  congr with x\n  simp [h]\n\n"}
{"name":"Set.preimage_mono","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns t : Set Î²\nh : HasSubset.Subset s t\nâŠ¢ HasSubset.Subset (Set.preimage f s) (Set.preimage f t)","decl":"@[gcongr]\ntheorem preimage_mono {s t : Set Î²} (h : s âŠ† t) : f â»Â¹' s âŠ† f â»Â¹' t := fun _ hx => h hx\n\n"}
{"name":"Set.preimage_univ","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nâŠ¢ Eq (Set.preimage f Set.univ) Set.univ","decl":"@[simp, mfld_simps]\ntheorem preimage_univ : f â»Â¹' univ = univ :=\n  rfl\n\n"}
{"name":"Set.subset_preimage_univ","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\nâŠ¢ HasSubset.Subset s (Set.preimage f Set.univ)","decl":"theorem subset_preimage_univ {s : Set Î±} : s âŠ† f â»Â¹' univ :=\n  subset_univ _\n\n"}
{"name":"Set.preimage_inter","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns t : Set Î²\nâŠ¢ Eq (Set.preimage f (Inter.inter s t)) (Inter.inter (Set.preimage f s) (Set.preimage f t))","decl":"@[simp, mfld_simps]\ntheorem preimage_inter {s t : Set Î²} : f â»Â¹' (s âˆ© t) = f â»Â¹' s âˆ© f â»Â¹' t :=\n  rfl\n\n"}
{"name":"Set.preimage_union","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns t : Set Î²\nâŠ¢ Eq (Set.preimage f (Union.union s t)) (Union.union (Set.preimage f s) (Set.preimage f t))","decl":"@[simp]\ntheorem preimage_union {s t : Set Î²} : f â»Â¹' (s âˆª t) = f â»Â¹' s âˆª f â»Â¹' t :=\n  rfl\n\n"}
{"name":"Set.preimage_compl","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î²\nâŠ¢ Eq (Set.preimage f (HasCompl.compl s)) (HasCompl.compl (Set.preimage f s))","decl":"@[simp]\ntheorem preimage_compl {s : Set Î²} : f â»Â¹' sá¶œ = (f â»Â¹' s)á¶œ :=\n  rfl\n\n"}
{"name":"Set.preimage_diff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns t : Set Î²\nâŠ¢ Eq (Set.preimage f (SDiff.sdiff s t)) (SDiff.sdiff (Set.preimage f s) (Set.preimage f t))","decl":"@[simp]\ntheorem preimage_diff (f : Î± â†’ Î²) (s t : Set Î²) : f â»Â¹' (s \\ t) = f â»Â¹' s \\ f â»Â¹' t :=\n  rfl\n\n"}
{"name":"Set.preimage_symmDiff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns t : Set Î²\nâŠ¢ Eq (Set.preimage f (symmDiff s t)) (symmDiff (Set.preimage f s) (Set.preimage f t))","decl":"open scoped symmDiff in\n@[simp]\nlemma preimage_symmDiff {f : Î± â†’ Î²} (s t : Set Î²) : f â»Â¹' (s âˆ† t) = (f â»Â¹' s) âˆ† (f â»Â¹' t) :=\n  rfl\n\n"}
{"name":"Set.preimage_ite","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns tâ‚ tâ‚‚ : Set Î²\nâŠ¢ Eq (Set.preimage f (s.ite tâ‚ tâ‚‚)) ((Set.preimage f s).ite (Set.preimage f tâ‚) (Set.preimage f tâ‚‚))","decl":"@[simp]\ntheorem preimage_ite (f : Î± â†’ Î²) (s tâ‚ tâ‚‚ : Set Î²) :\n    f â»Â¹' s.ite tâ‚ tâ‚‚ = (f â»Â¹' s).ite (f â»Â¹' tâ‚) (f â»Â¹' tâ‚‚) :=\n  rfl\n\n"}
{"name":"Set.preimage_setOf_eq","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\np : Î± â†’ Prop\nf : Î² â†’ Î±\nâŠ¢ Eq (Set.preimage f (setOf fun a => p a)) (setOf fun a => p (f a))","decl":"@[simp]\ntheorem preimage_setOf_eq {p : Î± â†’ Prop} {f : Î² â†’ Î±} : f â»Â¹' { a | p a } = { a | p (f a) } :=\n  rfl\n\n"}
{"name":"Set.preimage_id_eq","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nâŠ¢ Eq (Set.preimage id) id","decl":"@[simp]\ntheorem preimage_id_eq : preimage (id : Î± â†’ Î±) = id :=\n  rfl\n\n"}
{"name":"Set.preimage_id","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns : Set Î±\nâŠ¢ Eq (Set.preimage id s) s","decl":"@[mfld_simps]\ntheorem preimage_id {s : Set Î±} : id â»Â¹' s = s :=\n  rfl\n\n"}
{"name":"Set.preimage_id'","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns : Set Î±\nâŠ¢ Eq (Set.preimage (fun x => x) s) s","decl":"@[simp, mfld_simps]\ntheorem preimage_id' {s : Set Î±} : (fun x => x) â»Â¹' s = s :=\n  rfl\n\n"}
{"name":"Set.preimage_const_of_mem","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nb : Î²\ns : Set Î²\nh : Membership.mem s b\nâŠ¢ Eq (Set.preimage (fun x => b) s) Set.univ","decl":"@[simp]\ntheorem preimage_const_of_mem {b : Î²} {s : Set Î²} (h : b âˆˆ s) : (fun _ : Î± => b) â»Â¹' s = univ :=\n  eq_univ_of_forall fun _ => h\n\n"}
{"name":"Set.preimage_const_of_not_mem","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nb : Î²\ns : Set Î²\nh : Not (Membership.mem s b)\nâŠ¢ Eq (Set.preimage (fun x => b) s) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem preimage_const_of_not_mem {b : Î²} {s : Set Î²} (h : b âˆ‰ s) : (fun _ : Î± => b) â»Â¹' s = âˆ… :=\n  eq_empty_of_subset_empty fun _ hx => h hx\n\n"}
{"name":"Set.preimage_const","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nb : Î²\ns : Set Î²\ninstâœ : Decidable (Membership.mem s b)\nâŠ¢ Eq (Set.preimage (fun x => b) s) (ite (Membership.mem s b) Set.univ EmptyCollection.emptyCollection)","decl":"theorem preimage_const (b : Î²) (s : Set Î²) [Decidable (b âˆˆ s)] :\n    (fun _ : Î± => b) â»Â¹' s = if b âˆˆ s then univ else âˆ… := by\n  split_ifs with hb\n  exacts [preimage_const_of_mem hb, preimage_const_of_not_mem hb]\n\n"}
{"name":"Set.exists_eq_const_of_preimage_singleton","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : Nonempty Î²\nf : Î± â†’ Î²\nhf : âˆ€ (b : Î²), Or (Eq (Set.preimage f (Singleton.singleton b)) EmptyCollection.emptyCollection) (Eq (Set.preimage f (Singleton.singleton b)) Set.univ)\nâŠ¢ Exists fun b => Eq f (Function.const Î± b)","decl":"/-- If preimage of each singleton under `f : Î± â†’ Î²` is either empty or the whole type,\nthen `f` is a constant. -/\nlemma exists_eq_const_of_preimage_singleton [Nonempty Î²] {f : Î± â†’ Î²}\n    (hf : âˆ€ b : Î², f â»Â¹' {b} = âˆ… âˆ¨ f â»Â¹' {b} = univ) : âˆƒ b, f = const Î± b := by\n  rcases em (âˆƒ b, f â»Â¹' {b} = univ) with âŸ¨b, hbâŸ© | hf'\n  Â· exact âŸ¨b, funext fun x â†¦ eq_univ_iff_forall.1 hb xâŸ©\n  Â· have : âˆ€ x b, f x â‰  b := fun x b â†¦\n      eq_empty_iff_forall_not_mem.1 ((hf b).resolve_right fun h â†¦ hf' âŸ¨b, hâŸ©) x\n    exact âŸ¨Classical.arbitrary Î², funext fun x â†¦ absurd rfl (this x _)âŸ©\n\n"}
{"name":"Set.preimage_comp","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Î± â†’ Î²\ng : Î² â†’ Î³\ns : Set Î³\nâŠ¢ Eq (Set.preimage (Function.comp g f) s) (Set.preimage f (Set.preimage g s))","decl":"theorem preimage_comp {s : Set Î³} : g âˆ˜ f â»Â¹' s = f â»Â¹' (g â»Â¹' s) :=\n  rfl\n\n"}
{"name":"Set.preimage_comp_eq","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Î± â†’ Î²\ng : Î² â†’ Î³\nâŠ¢ Eq (Set.preimage (Function.comp g f)) (Function.comp (Set.preimage f) (Set.preimage g))","decl":"theorem preimage_comp_eq : preimage (g âˆ˜ f) = preimage f âˆ˜ preimage g :=\n  rfl\n\n"}
{"name":"Set.preimage_iterate_eq","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nf : Î± â†’ Î±\nn : Nat\nâŠ¢ Eq (Set.preimage (Nat.iterate f n)) (Nat.iterate (Set.preimage f) n)","decl":"theorem preimage_iterate_eq {f : Î± â†’ Î±} {n : â„•} : Set.preimage f^[n] = (Set.preimage f)^[n] := by\n  induction n with\n  | zero => simp\n  | succ n ih => rw [iterate_succ, iterate_succ', preimage_comp_eq, ih]\n\n"}
{"name":"Set.preimage_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ng : Î² â†’ Î³\nf : Î± â†’ Î²\ns : Set Î³\nâŠ¢ Eq (Set.preimage f (Set.preimage g s)) (Set.preimage (fun x => g (f x)) s)","decl":"theorem preimage_preimage {g : Î² â†’ Î³} {f : Î± â†’ Î²} {s : Set Î³} :\n    f â»Â¹' (g â»Â¹' s) = (fun x => g (f x)) â»Â¹' s :=\n  preimage_comp.symm\n\n"}
{"name":"Set.eq_preimage_subtype_val_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\np : Î± â†’ Prop\ns : Set (Subtype p)\nt : Set Î±\nâŠ¢ Iff (Eq s (Set.preimage Subtype.val t)) (âˆ€ (x : Î±) (h : p x), Iff (Membership.mem s âŸ¨x, hâŸ©) (Membership.mem t x))","decl":"theorem eq_preimage_subtype_val_iff {p : Î± â†’ Prop} {s : Set (Subtype p)} {t : Set Î±} :\n    s = Subtype.val â»Â¹' t â†” âˆ€ (x) (h : p x), (âŸ¨x, hâŸ© : Subtype p) âˆˆ s â†” x âˆˆ t :=\n  âŸ¨fun s_eq x h => by\n    rw [s_eq]\n    simp, fun h => ext fun âŸ¨x, hxâŸ© => by simp [h]âŸ©\n\n"}
{"name":"Set.nonempty_of_nonempty_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î²\nf : Î± â†’ Î²\nhf : (Set.preimage f s).Nonempty\nâŠ¢ s.Nonempty","decl":"theorem nonempty_of_nonempty_preimage {s : Set Î²} {f : Î± â†’ Î²} (hf : (f â»Â¹' s).Nonempty) :\n    s.Nonempty :=\n  let âŸ¨x, hxâŸ© := hf\n  âŸ¨f x, hxâŸ©\n\n"}
{"name":"Set.preimage_singleton_true","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\np : Î± â†’ Prop\nâŠ¢ Eq (Set.preimage p (Singleton.singleton True)) (setOf fun a => p a)","decl":"@[simp] theorem preimage_singleton_true (p : Î± â†’ Prop) : p â»Â¹' {True} = {a | p a} := by ext; simp\n\n"}
{"name":"Set.preimage_singleton_false","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\np : Î± â†’ Prop\nâŠ¢ Eq (Set.preimage p (Singleton.singleton False)) (setOf fun a => Not (p a))","decl":"@[simp] theorem preimage_singleton_false (p : Î± â†’ Prop) : p â»Â¹' {False} = {a | Â¬p a} := by ext; simp\n\n"}
{"name":"Set.preimage_subtype_coe_eq_compl","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns u v : Set Î±\nhsuv : HasSubset.Subset s (Union.union u v)\nH : Eq (Inter.inter s (Inter.inter u v)) EmptyCollection.emptyCollection\nâŠ¢ Eq (Set.preimage Subtype.val u) (HasCompl.compl (Set.preimage Subtype.val v))","decl":"theorem preimage_subtype_coe_eq_compl {s u v : Set Î±} (hsuv : s âŠ† u âˆª v)\n    (H : s âˆ© (u âˆ© v) = âˆ…) : ((â†‘) : s â†’ Î±) â»Â¹' u = ((â†‘) â»Â¹' v)á¶œ := by\n  ext âŸ¨x, x_in_sâŸ©\n  constructor\n  Â· intro x_in_u x_in_v\n    exact eq_empty_iff_forall_not_mem.mp H x âŸ¨x_in_s, âŸ¨x_in_u, x_in_vâŸ©âŸ©\n  Â· intro hx\n    exact Or.elim (hsuv x_in_s) id fun hx' => hx.elim hx'\n\n"}
{"name":"Set.preimage_subset","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î²\nt : Set Î±\nhs : HasSubset.Subset s (Set.image f t)\nhf : Set.InjOn f (Set.preimage f s)\nâŠ¢ HasSubset.Subset (Set.preimage f s) t","decl":"lemma preimage_subset {s t} (hs : s âŠ† f '' t) (hf : Set.InjOn f (f â»Â¹' s)) : f â»Â¹' s âŠ† t := by\n  rintro a ha\n  obtain âŸ¨b, hb, hbaâŸ© := hs ha\n  rwa [hf ha _ hba.symm]\n  simpa [hba]\n\n"}
{"name":"Set.image_eta","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\nf : Î± â†’ Î²\nâŠ¢ Eq (Set.image f s) (Set.image (fun x => f x) s)","decl":"theorem image_eta (f : Î± â†’ Î²) : f '' s = (fun x => f x) '' s :=\n  rfl\n\n"}
{"name":"Function.Injective.mem_set_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Injective f\ns : Set Î±\na : Î±\nâŠ¢ Iff (Membership.mem (Set.image f s) (f a)) (Membership.mem s a)","decl":"theorem _root_.Function.Injective.mem_set_image {f : Î± â†’ Î²} (hf : Injective f) {s : Set Î±} {a : Î±} :\n    f a âˆˆ f '' s â†” a âˆˆ s :=\n  âŸ¨fun âŸ¨_, hb, EqâŸ© => hf Eq â–¸ hb, mem_image_of_mem fâŸ©\n\n"}
{"name":"Set.preimage_subset_of_surjOn","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\nt : Set Î²\nhf : Function.Injective f\nh : Set.SurjOn f s t\nâŠ¢ HasSubset.Subset (Set.preimage f t) s","decl":"lemma preimage_subset_of_surjOn {t : Set Î²} (hf : Injective f) (h : SurjOn f s t) :\n    f â»Â¹' t âŠ† s := fun _ hx â†¦\n  hf.mem_set_image.1 <| h hx\n\n"}
{"name":"Set.forall_mem_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\np : Î² â†’ Prop\nâŠ¢ Iff (âˆ€ (y : Î²), Membership.mem (Set.image f s) y â†’ p y) (âˆ€ â¦ƒx : Î±â¦„, Membership.mem s x â†’ p (f x))","decl":"theorem forall_mem_image {f : Î± â†’ Î²} {s : Set Î±} {p : Î² â†’ Prop} :\n    (âˆ€ y âˆˆ f '' s, p y) â†” âˆ€ â¦ƒxâ¦„, x âˆˆ s â†’ p (f x) := by simp\n\n"}
{"name":"Set.exists_mem_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\np : Î² â†’ Prop\nâŠ¢ Iff (Exists fun y => And (Membership.mem (Set.image f s) y) (p y)) (Exists fun x => And (Membership.mem s x) (p (f x)))","decl":"theorem exists_mem_image {f : Î± â†’ Î²} {s : Set Î±} {p : Î² â†’ Prop} :\n    (âˆƒ y âˆˆ f '' s, p y) â†” âˆƒ x âˆˆ s, p (f x) := by simp\n\n-- Porting note: used to be `safe`\n"}
{"name":"Set.image_congr","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf g : Î± â†’ Î²\ns : Set Î±\nh : âˆ€ (a : Î±), Membership.mem s a â†’ Eq (f a) (g a)\nâŠ¢ Eq (Set.image f s) (Set.image g s)","decl":"@[congr]\ntheorem image_congr {f g : Î± â†’ Î²} {s : Set Î±} (h : âˆ€ a âˆˆ s, f a = g a) : f '' s = g '' s := by\n  ext x\n  exact exists_congr fun a â†¦ and_congr_right fun ha â†¦ by rw [h a ha]\n\n"}
{"name":"Set.image_congr'","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf g : Î± â†’ Î²\ns : Set Î±\nh : âˆ€ (x : Î±), Eq (f x) (g x)\nâŠ¢ Eq (Set.image f s) (Set.image g s)","decl":"/-- A common special case of `image_congr` -/\ntheorem image_congr' {f g : Î± â†’ Î²} {s : Set Î±} (h : âˆ€ x : Î±, f x = g x) : f '' s = g '' s :=\n  image_congr fun x _ => h x\n\n"}
{"name":"Set.image_mono","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns t : Set Î±\nh : HasSubset.Subset s t\nâŠ¢ HasSubset.Subset (Set.image f s) (Set.image f t)","decl":"@[gcongr]\nlemma image_mono (h : s âŠ† t) : f '' s âŠ† f '' t := by\n  rintro - âŸ¨a, ha, rflâŸ©; exact mem_image_of_mem f (h ha)\n\n"}
{"name":"Set.image_comp","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Î² â†’ Î³\ng : Î± â†’ Î²\na : Set Î±\nâŠ¢ Eq (Set.image (Function.comp f g) a) (Set.image f (Set.image g a))","decl":"theorem image_comp (f : Î² â†’ Î³) (g : Î± â†’ Î²) (a : Set Î±) : f âˆ˜ g '' a = f '' (g '' a) := by aesop\n\n"}
{"name":"Set.image_comp_eq","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Î± â†’ Î²\ng : Î² â†’ Î³\nâŠ¢ Eq (Set.image (Function.comp g f)) (Function.comp (Set.image g) (Set.image f))","decl":"theorem image_comp_eq {g : Î² â†’ Î³} : image (g âˆ˜ f) = image g âˆ˜ image f := by ext; simp\n\n"}
{"name":"Set.image_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ng : Î² â†’ Î³\nf : Î± â†’ Î²\ns : Set Î±\nâŠ¢ Eq (Set.image g (Set.image f s)) (Set.image (fun x => g (f x)) s)","decl":"/-- A variant of `image_comp`, useful for rewriting -/\ntheorem image_image (g : Î² â†’ Î³) (f : Î± â†’ Î²) (s : Set Î±) : g '' (f '' s) = (fun x => g (f x)) '' s :=\n  (image_comp g f s).symm\n\n"}
{"name":"Set.image_comm","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ns : Set Î±\nÎ²' : Type u_5\nf : Î² â†’ Î³\ng : Î± â†’ Î²\nf' : Î± â†’ Î²'\ng' : Î²' â†’ Î³\nh_comm : âˆ€ (a : Î±), Eq (f (g a)) (g' (f' a))\nâŠ¢ Eq (Set.image f (Set.image g s)) (Set.image g' (Set.image f' s))","decl":"theorem image_comm {Î²'} {f : Î² â†’ Î³} {g : Î± â†’ Î²} {f' : Î± â†’ Î²'} {g' : Î²' â†’ Î³}\n    (h_comm : âˆ€ a, f (g a) = g' (f' a)) : (s.image g).image f = (s.image f').image g' := by\n  simp_rw [image_image, h_comm]\n\n"}
{"name":"Function.Semiconj.set_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nga : Î± â†’ Î±\ngb : Î² â†’ Î²\nh : Function.Semiconj f ga gb\nâŠ¢ Function.Semiconj (Set.image f) (Set.image ga) (Set.image gb)","decl":"theorem _root_.Function.Semiconj.set_image {f : Î± â†’ Î²} {ga : Î± â†’ Î±} {gb : Î² â†’ Î²}\n    (h : Function.Semiconj f ga gb) : Function.Semiconj (image f) (image ga) (image gb) := fun _ =>\n  image_comm h\n\n"}
{"name":"Function.Commute.set_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nf g : Î± â†’ Î±\nh : Function.Commute f g\nâŠ¢ Function.Commute (Set.image f) (Set.image g)","decl":"theorem _root_.Function.Commute.set_image {f g : Î± â†’ Î±} (h : Function.Commute f g) :\n    Function.Commute (image f) (image g) :=\n  Function.Semiconj.set_image h\n\n"}
{"name":"Set.image_subset","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\na b : Set Î±\nf : Î± â†’ Î²\nh : HasSubset.Subset a b\nâŠ¢ HasSubset.Subset (Set.image f a) (Set.image f b)","decl":"/-- Image is monotone with respect to `âŠ†`. See `Set.monotone_image` for the statement in\nterms of `â‰¤`. -/\n@[gcongr]\ntheorem image_subset {a b : Set Î±} (f : Î± â†’ Î²) (h : a âŠ† b) : f '' a âŠ† f '' b := by\n  simp only [subset_def, mem_image]\n  exact fun x => fun âŸ¨w, h1, h2âŸ© => âŸ¨w, h h1, h2âŸ©\n\n"}
{"name":"Set.monotone_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nâŠ¢ Monotone (Set.image f)","decl":"/-- `Set.image` is monotone. See `Set.image_subset` for the statement in terms of `âŠ†`. -/\nlemma monotone_image {f : Î± â†’ Î²} : Monotone (image f) := fun _ _ => image_subset _\n\n"}
{"name":"Set.image_union","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns t : Set Î±\nâŠ¢ Eq (Set.image f (Union.union s t)) (Union.union (Set.image f s) (Set.image f t))","decl":"theorem image_union (f : Î± â†’ Î²) (s t : Set Î±) : f '' (s âˆª t) = f '' s âˆª f '' t :=\n  ext fun x =>\n    âŸ¨by rintro âŸ¨a, h | h, rflâŸ© <;> [left; right] <;> exact âŸ¨_, h, rflâŸ©, by\n      rintro (âŸ¨a, h, rflâŸ© | âŸ¨a, h, rflâŸ©) <;> refine âŸ¨_, ?_, rflâŸ©\n      Â· exact mem_union_left t h\n      Â· exact mem_union_right s hâŸ©\n\n"}
{"name":"Set.image_empty","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nâŠ¢ Eq (Set.image f EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem image_empty (f : Î± â†’ Î²) : f '' âˆ… = âˆ… := by\n  ext\n  simp\n\n"}
{"name":"Set.image_inter_subset","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns t : Set Î±\nâŠ¢ HasSubset.Subset (Set.image f (Inter.inter s t)) (Inter.inter (Set.image f s) (Set.image f t))","decl":"theorem image_inter_subset (f : Î± â†’ Î²) (s t : Set Î±) : f '' (s âˆ© t) âŠ† f '' s âˆ© f '' t :=\n  subset_inter (image_subset _ inter_subset_left) (image_subset _ inter_subset_right)\n\n"}
{"name":"Set.image_inter_on","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns t : Set Î±\nh : âˆ€ (x : Î±), Membership.mem t x â†’ âˆ€ (y : Î±), Membership.mem s y â†’ Eq (f x) (f y) â†’ Eq x y\nâŠ¢ Eq (Set.image f (Inter.inter s t)) (Inter.inter (Set.image f s) (Set.image f t))","decl":"theorem image_inter_on {f : Î± â†’ Î²} {s t : Set Î±} (h : âˆ€ x âˆˆ t, âˆ€ y âˆˆ s, f x = f y â†’ x = y) :\n    f '' (s âˆ© t) = f '' s âˆ© f '' t :=\n  (image_inter_subset _ _ _).antisymm\n    fun b âŸ¨âŸ¨aâ‚, haâ‚, hâ‚âŸ©, âŸ¨aâ‚‚, haâ‚‚, hâ‚‚âŸ©âŸ© â†¦\n      have : aâ‚‚ = aâ‚ := h _ haâ‚‚ _ haâ‚ (by simp [*])\n      âŸ¨aâ‚, âŸ¨haâ‚, this â–¸ haâ‚‚âŸ©, hâ‚âŸ©\n\n"}
{"name":"Set.image_inter","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns t : Set Î±\nH : Function.Injective f\nâŠ¢ Eq (Set.image f (Inter.inter s t)) (Inter.inter (Set.image f s) (Set.image f t))","decl":"theorem image_inter {f : Î± â†’ Î²} {s t : Set Î±} (H : Injective f) : f '' (s âˆ© t) = f '' s âˆ© f '' t :=\n  image_inter_on fun _ _ _ _ h => H h\n\n"}
{"name":"Set.image_univ_of_surjective","module":"Mathlib.Data.Set.Image","initialProofState":"Î² : Type u_2\nÎ¹ : Type u_5\nf : Î¹ â†’ Î²\nH : Function.Surjective f\nâŠ¢ Eq (Set.image f Set.univ) Set.univ","decl":"theorem image_univ_of_surjective {Î¹ : Type*} {f : Î¹ â†’ Î²} (H : Surjective f) : f '' univ = univ :=\n  eq_univ_of_forall <| by simpa [image]\n\n"}
{"name":"Set.image_singleton","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\na : Î±\nâŠ¢ Eq (Set.image f (Singleton.singleton a)) (Singleton.singleton (f a))","decl":"@[simp]\ntheorem image_singleton {f : Î± â†’ Î²} {a : Î±} : f '' {a} = {f a} := by\n  ext\n  simp [image, eq_comm]\n\n"}
{"name":"Set.Nonempty.image_const","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\nhs : s.Nonempty\na : Î²\nâŠ¢ Eq (Set.image (fun x => a) s) (Singleton.singleton a)","decl":"@[simp]\ntheorem Nonempty.image_const {s : Set Î±} (hs : s.Nonempty) (a : Î²) : (fun _ => a) '' s = {a} :=\n  ext fun _ =>\n    âŸ¨fun âŸ¨_, _, hâŸ© => h â–¸ mem_singleton _, fun h =>\n      (eq_of_mem_singleton h).symm â–¸ hs.imp fun _ hy => âŸ¨hy, rflâŸ©âŸ©\n\n"}
{"name":"Set.image_eq_empty","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_5\nÎ² : Type u_6\nf : Î± â†’ Î²\ns : Set Î±\nâŠ¢ Iff (Eq (Set.image f s) EmptyCollection.emptyCollection) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp, mfld_simps]\ntheorem image_eq_empty {Î± Î²} {f : Î± â†’ Î²} {s : Set Î±} : f '' s = âˆ… â†” s = âˆ… := by\n  simp only [eq_empty_iff_forall_not_mem]\n  exact âŸ¨fun H a ha => H _ âŸ¨_, ha, rflâŸ©, fun H b âŸ¨_, ha, _âŸ© => H _ haâŸ©\n\n-- Porting note: `compl` is already defined in `Data.Set.Defs`\n"}
{"name":"Set.preimage_compl_eq_image_compl","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ninstâœ : BooleanAlgebra Î±\nS : Set Î±\nâŠ¢ Eq (Set.preimage HasCompl.compl S) (Set.image HasCompl.compl S)","decl":"theorem preimage_compl_eq_image_compl [BooleanAlgebra Î±] (S : Set Î±) :\n    HasCompl.compl â»Â¹' S = HasCompl.compl '' S :=\n  Set.ext fun x =>\n    âŸ¨fun h => âŸ¨xá¶œ, h, compl_compl xâŸ©, fun h =>\n      Exists.elim h fun _ hy => (compl_eq_comm.mp hy.2).symm.subst hy.1âŸ©\n\n"}
{"name":"Set.mem_compl_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ninstâœ : BooleanAlgebra Î±\nt : Î±\nS : Set Î±\nâŠ¢ Iff (Membership.mem (Set.image HasCompl.compl S) t) (Membership.mem S (HasCompl.compl t))","decl":"theorem mem_compl_image [BooleanAlgebra Î±] (t : Î±) (S : Set Î±) :\n    t âˆˆ HasCompl.compl '' S â†” tá¶œ âˆˆ S := by\n  simp [â† preimage_compl_eq_image_compl]\n\n"}
{"name":"Set.image_id_eq","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nâŠ¢ Eq (Set.image id) id","decl":"@[simp]\ntheorem image_id_eq : image (id : Î± â†’ Î±) = id := by ext; simp\n\n"}
{"name":"Set.image_id'","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns : Set Î±\nâŠ¢ Eq (Set.image (fun x => x) s) s","decl":"/-- A variant of `image_id` -/\n@[simp]\ntheorem image_id' (s : Set Î±) : (fun x => x) '' s = s := by\n  ext\n  simp\n\n"}
{"name":"Set.image_id","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns : Set Î±\nâŠ¢ Eq (Set.image id s) s","decl":"theorem image_id (s : Set Î±) : id '' s = s := by simp\n\n"}
{"name":"Set.image_iterate_eq","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nf : Î± â†’ Î±\nn : Nat\nâŠ¢ Eq (Set.image (Nat.iterate f n)) (Nat.iterate (Set.image f) n)","decl":"lemma image_iterate_eq {f : Î± â†’ Î±} {n : â„•} : image (f^[n]) = (image f)^[n] := by\n  induction n with\n  | zero => simp\n  | succ n ih => rw [iterate_succ', iterate_succ', â† ih, image_comp_eq]\n\n"}
{"name":"Set.compl_compl_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ninstâœ : BooleanAlgebra Î±\nS : Set Î±\nâŠ¢ Eq (Set.image HasCompl.compl (Set.image HasCompl.compl S)) S","decl":"theorem compl_compl_image [BooleanAlgebra Î±] (S : Set Î±) :\n    HasCompl.compl '' (HasCompl.compl '' S) = S := by\n  rw [â† image_comp, compl_comp_compl, image_id]\n\n"}
{"name":"Set.image_insert_eq","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\na : Î±\ns : Set Î±\nâŠ¢ Eq (Set.image f (Insert.insert a s)) (Insert.insert (f a) (Set.image f s))","decl":"theorem image_insert_eq {f : Î± â†’ Î²} {a : Î±} {s : Set Î±} :\n    f '' insert a s = insert (f a) (f '' s) := by\n  ext\n  simp [and_or_left, exists_or, eq_comm, or_comm, and_comm]\n\n"}
{"name":"Set.image_pair","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\na b : Î±\nâŠ¢ Eq (Set.image f (Insert.insert a (Singleton.singleton b))) (Insert.insert (f a) (Singleton.singleton (f b)))","decl":"theorem image_pair (f : Î± â†’ Î²) (a b : Î±) : f '' {a, b} = {f a, f b} := by\n  simp only [image_insert_eq, image_singleton]\n\n"}
{"name":"Set.image_subset_preimage_of_inverse","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ng : Î² â†’ Î±\nI : Function.LeftInverse g f\ns : Set Î±\nâŠ¢ HasSubset.Subset (Set.image f s) (Set.preimage g s)","decl":"theorem image_subset_preimage_of_inverse {f : Î± â†’ Î²} {g : Î² â†’ Î±} (I : LeftInverse g f) (s : Set Î±) :\n    f '' s âŠ† g â»Â¹' s := fun _ âŸ¨a, h, eâŸ© => e â–¸ ((I a).symm â–¸ h : g (f a) âˆˆ s)\n\n"}
{"name":"Set.preimage_subset_image_of_inverse","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ng : Î² â†’ Î±\nI : Function.LeftInverse g f\ns : Set Î²\nâŠ¢ HasSubset.Subset (Set.preimage f s) (Set.image g s)","decl":"theorem preimage_subset_image_of_inverse {f : Î± â†’ Î²} {g : Î² â†’ Î±} (I : LeftInverse g f) (s : Set Î²) :\n    f â»Â¹' s âŠ† g '' s := fun b h => âŸ¨f b, h, I bâŸ©\n\n"}
{"name":"Set.image_eq_preimage_of_inverse","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ng : Î² â†’ Î±\nhâ‚ : Function.LeftInverse g f\nhâ‚‚ : Function.RightInverse g f\nâŠ¢ Eq (Set.image f) (Set.preimage g)","decl":"theorem image_eq_preimage_of_inverse {f : Î± â†’ Î²} {g : Î² â†’ Î±} (hâ‚ : LeftInverse g f)\n    (hâ‚‚ : RightInverse g f) : image f = preimage g :=\n  funext fun s =>\n    Subset.antisymm (image_subset_preimage_of_inverse hâ‚ s) (preimage_subset_image_of_inverse hâ‚‚ s)\n\n"}
{"name":"Set.mem_image_iff_of_inverse","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ng : Î² â†’ Î±\nb : Î²\ns : Set Î±\nhâ‚ : Function.LeftInverse g f\nhâ‚‚ : Function.RightInverse g f\nâŠ¢ Iff (Membership.mem (Set.image f s) b) (Membership.mem s (g b))","decl":"theorem mem_image_iff_of_inverse {f : Î± â†’ Î²} {g : Î² â†’ Î±} {b : Î²} {s : Set Î±} (hâ‚ : LeftInverse g f)\n    (hâ‚‚ : RightInverse g f) : b âˆˆ f '' s â†” g b âˆˆ s := by\n  rw [image_eq_preimage_of_inverse hâ‚ hâ‚‚]; rfl\n\n"}
{"name":"Set.image_compl_subset","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\nH : Function.Injective f\nâŠ¢ HasSubset.Subset (Set.image f (HasCompl.compl s)) (HasCompl.compl (Set.image f s))","decl":"theorem image_compl_subset {f : Î± â†’ Î²} {s : Set Î±} (H : Injective f) : f '' sá¶œ âŠ† (f '' s)á¶œ :=\n  Disjoint.subset_compl_left <| by simp [disjoint_iff_inf_le, â† image_inter H]\n\n"}
{"name":"Set.subset_image_compl","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\nH : Function.Surjective f\nâŠ¢ HasSubset.Subset (HasCompl.compl (Set.image f s)) (Set.image f (HasCompl.compl s))","decl":"theorem subset_image_compl {f : Î± â†’ Î²} {s : Set Î±} (H : Surjective f) : (f '' s)á¶œ âŠ† f '' sá¶œ :=\n  compl_subset_iff_union.2 <| by\n    rw [â† image_union]\n    simp [image_univ_of_surjective H]\n\n"}
{"name":"Set.image_compl_eq","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\nH : Function.Bijective f\nâŠ¢ Eq (Set.image f (HasCompl.compl s)) (HasCompl.compl (Set.image f s))","decl":"theorem image_compl_eq {f : Î± â†’ Î²} {s : Set Î±} (H : Bijective f) : f '' sá¶œ = (f '' s)á¶œ :=\n  Subset.antisymm (image_compl_subset H.1) (subset_image_compl H.2)\n\n"}
{"name":"Set.subset_image_diff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns t : Set Î±\nâŠ¢ HasSubset.Subset (SDiff.sdiff (Set.image f s) (Set.image f t)) (Set.image f (SDiff.sdiff s t))","decl":"theorem subset_image_diff (f : Î± â†’ Î²) (s t : Set Î±) : f '' s \\ f '' t âŠ† f '' (s \\ t) := by\n  rw [diff_subset_iff, â† image_union, union_diff_self]\n  exact image_subset f subset_union_right\n\n"}
{"name":"Set.subset_image_symmDiff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns t : Set Î±\nâŠ¢ HasSubset.Subset (symmDiff (Set.image f s) (Set.image f t)) (Set.image f (symmDiff s t))","decl":"open scoped symmDiff in\ntheorem subset_image_symmDiff : (f '' s) âˆ† (f '' t) âŠ† f '' s âˆ† t :=\n  (union_subset_union (subset_image_diff _ _ _) <| subset_image_diff _ _ _).trans\n    (superset_of_eq (image_union _ _ _))\n\n"}
{"name":"Set.image_diff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Injective f\ns t : Set Î±\nâŠ¢ Eq (Set.image f (SDiff.sdiff s t)) (SDiff.sdiff (Set.image f s) (Set.image f t))","decl":"theorem image_diff {f : Î± â†’ Î²} (hf : Injective f) (s t : Set Î±) : f '' (s \\ t) = f '' s \\ f '' t :=\n  Subset.antisymm\n    (Subset.trans (image_inter_subset _ _ _) <| inter_subset_inter_right _ <| image_compl_subset hf)\n    (subset_image_diff f s t)\n\n"}
{"name":"Set.image_symmDiff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Injective f\ns t : Set Î±\nâŠ¢ Eq (Set.image f (symmDiff s t)) (symmDiff (Set.image f s) (Set.image f t))","decl":"open scoped symmDiff in\ntheorem image_symmDiff (hf : Injective f) (s t : Set Î±) : f '' s âˆ† t = (f '' s) âˆ† (f '' t) := by\n  simp_rw [Set.symmDiff_def, image_union, image_diff hf]\n\n"}
{"name":"Set.Nonempty.image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\naâœ : s.Nonempty\nâŠ¢ (Set.image f s).Nonempty","decl":"theorem Nonempty.image (f : Î± â†’ Î²) {s : Set Î±} : s.Nonempty â†’ (f '' s).Nonempty\n  | âŸ¨x, hxâŸ© => âŸ¨f x, mem_image_of_mem f hxâŸ©\n\n"}
{"name":"Set.Nonempty.of_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\naâœ : (Set.image f s).Nonempty\nâŠ¢ s.Nonempty","decl":"theorem Nonempty.of_image {f : Î± â†’ Î²} {s : Set Î±} : (f '' s).Nonempty â†’ s.Nonempty\n  | âŸ¨_, x, hx, _âŸ© => âŸ¨x, hxâŸ©\n\n"}
{"name":"Set.image_nonempty","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\nâŠ¢ Iff (Set.image f s).Nonempty s.Nonempty","decl":"@[simp]\ntheorem image_nonempty {f : Î± â†’ Î²} {s : Set Î±} : (f '' s).Nonempty â†” s.Nonempty :=\n  âŸ¨Nonempty.of_image, fun h => h.image fâŸ©\n\n"}
{"name":"Set.Nonempty.preimage","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î²\nhs : s.Nonempty\nf : Î± â†’ Î²\nhf : Function.Surjective f\nâŠ¢ (Set.preimage f s).Nonempty","decl":"theorem Nonempty.preimage {s : Set Î²} (hs : s.Nonempty) {f : Î± â†’ Î²} (hf : Surjective f) :\n    (f â»Â¹' s).Nonempty :=\n  let âŸ¨y, hyâŸ© := hs\n  let âŸ¨x, hxâŸ© := hf y\n  âŸ¨x, mem_preimage.2 <| hx.symm â–¸ hyâŸ©\n\n"}
{"name":"Set.instNonemptyElemImage","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\ninstâœ : Nonempty â†‘s\nâŠ¢ Nonempty â†‘(Set.image f s)","decl":"instance (f : Î± â†’ Î²) (s : Set Î±) [Nonempty s] : Nonempty (f '' s) :=\n  (Set.Nonempty.image f .of_subtype).to_subtype\n\n"}
{"name":"Set.image_subset_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\nt : Set Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (HasSubset.Subset (Set.image f s) t) (HasSubset.Subset s (Set.preimage f t))","decl":"/-- image and preimage are a Galois connection -/\n@[simp]\ntheorem image_subset_iff {s : Set Î±} {t : Set Î²} {f : Î± â†’ Î²} : f '' s âŠ† t â†” s âŠ† f â»Â¹' t :=\n  forall_mem_image\n\n"}
{"name":"Set.image_preimage_subset","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î²\nâŠ¢ HasSubset.Subset (Set.image f (Set.preimage f s)) s","decl":"theorem image_preimage_subset (f : Î± â†’ Î²) (s : Set Î²) : f '' (f â»Â¹' s) âŠ† s :=\n  image_subset_iff.2 Subset.rfl\n\n"}
{"name":"Set.subset_preimage_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\nâŠ¢ HasSubset.Subset s (Set.preimage f (Set.image f s))","decl":"theorem subset_preimage_image (f : Î± â†’ Î²) (s : Set Î±) : s âŠ† f â»Â¹' (f '' s) := fun _ =>\n  mem_image_of_mem f\n\n"}
{"name":"Set.preimage_image_univ","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nâŠ¢ Eq (Set.preimage f (Set.image f Set.univ)) Set.univ","decl":"theorem preimage_image_univ {f : Î± â†’ Î²} : f â»Â¹' (f '' univ) = univ :=\n  Subset.antisymm (fun _ _ => trivial) (subset_preimage_image f univ)\n\n"}
{"name":"Set.preimage_image_eq","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\nh : Function.Injective f\nâŠ¢ Eq (Set.preimage f (Set.image f s)) s","decl":"@[simp]\ntheorem preimage_image_eq {f : Î± â†’ Î²} (s : Set Î±) (h : Injective f) : f â»Â¹' (f '' s) = s :=\n  Subset.antisymm (fun _ âŸ¨_, hy, eâŸ© => h e â–¸ hy) (subset_preimage_image f s)\n\n"}
{"name":"Set.image_preimage_eq","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î²\nh : Function.Surjective f\nâŠ¢ Eq (Set.image f (Set.preimage f s)) s","decl":"@[simp]\ntheorem image_preimage_eq {f : Î± â†’ Î²} (s : Set Î²) (h : Surjective f) : f '' (f â»Â¹' s) = s :=\n  Subset.antisymm (image_preimage_subset f s) fun x hx =>\n    let âŸ¨y, eâŸ© := h x\n    âŸ¨y, (e.symm â–¸ hx : f y âˆˆ s), eâŸ©\n\n"}
{"name":"Set.Nonempty.subset_preimage_const","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\nhs : s.Nonempty\nt : Set Î²\na : Î²\nâŠ¢ Iff (HasSubset.Subset s (Set.preimage (fun x => a) t)) (Membership.mem t a)","decl":"@[simp]\ntheorem Nonempty.subset_preimage_const {s : Set Î±} (hs : Set.Nonempty s) (t : Set Î²) (a : Î²) :\n    s âŠ† (fun _ => a) â»Â¹' t â†” a âˆˆ t := by\n  rw [â† image_subset_iff, hs.image_const, singleton_subset_iff]\n\n"}
{"name":"Set.preimage_eq_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns t : Set Î±\nf : Î² â†’ Î±\nhf : Function.Surjective f\nâŠ¢ Iff (Eq (Set.preimage f s) (Set.preimage f t)) (Eq s t)","decl":"@[simp]\ntheorem preimage_eq_preimage {f : Î² â†’ Î±} (hf : Surjective f) : f â»Â¹' s = f â»Â¹' t â†” s = t :=\n  Iff.intro\n    fun eq => by rw [â† image_preimage_eq s hf, â† image_preimage_eq t hf, eq]\n    fun eq => eq â–¸ rfl\n\n"}
{"name":"Set.image_inter_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\nt : Set Î²\nâŠ¢ Eq (Set.image f (Inter.inter s (Set.preimage f t))) (Inter.inter (Set.image f s) t)","decl":"theorem image_inter_preimage (f : Î± â†’ Î²) (s : Set Î±) (t : Set Î²) :\n    f '' (s âˆ© f â»Â¹' t) = f '' s âˆ© t := by\n  apply Subset.antisymm\n  Â· calc\n      f '' (s âˆ© f â»Â¹' t) âŠ† f '' s âˆ© f '' (f â»Â¹' t) := image_inter_subset _ _ _\n      _ âŠ† f '' s âˆ© t := inter_subset_inter_right _ (image_preimage_subset f t)\n  Â· rintro _ âŸ¨âŸ¨x, h', rflâŸ©, hâŸ©\n    exact âŸ¨x, âŸ¨h', hâŸ©, rflâŸ©\n\n"}
{"name":"Set.image_preimage_inter","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\nt : Set Î²\nâŠ¢ Eq (Set.image f (Inter.inter (Set.preimage f t) s)) (Inter.inter t (Set.image f s))","decl":"theorem image_preimage_inter (f : Î± â†’ Î²) (s : Set Î±) (t : Set Î²) :\n    f '' (f â»Â¹' t âˆ© s) = t âˆ© f '' s := by simp only [inter_comm, image_inter_preimage]\n\n"}
{"name":"Set.image_inter_nonempty_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\nt : Set Î²\nâŠ¢ Iff (Inter.inter (Set.image f s) t).Nonempty (Inter.inter s (Set.preimage f t)).Nonempty","decl":"@[simp]\ntheorem image_inter_nonempty_iff {f : Î± â†’ Î²} {s : Set Î±} {t : Set Î²} :\n    (f '' s âˆ© t).Nonempty â†” (s âˆ© f â»Â¹' t).Nonempty := by\n  rw [â† image_inter_preimage, image_nonempty]\n\n"}
{"name":"Set.image_diff_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\nt : Set Î²\nâŠ¢ Eq (Set.image f (SDiff.sdiff s (Set.preimage f t))) (SDiff.sdiff (Set.image f s) t)","decl":"theorem image_diff_preimage {f : Î± â†’ Î²} {s : Set Î±} {t : Set Î²} :\n    f '' (s \\ f â»Â¹' t) = f '' s \\ t := by simp_rw [diff_eq, â† preimage_compl, image_inter_preimage]\n\n"}
{"name":"Set.compl_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nâŠ¢ Eq (Set.image HasCompl.compl) (Set.preimage HasCompl.compl)","decl":"theorem compl_image : image (compl : Set Î± â†’ Set Î±) = preimage compl :=\n  image_eq_preimage_of_inverse compl_compl compl_compl\n\n"}
{"name":"Set.compl_image_set_of","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\np : Set Î± â†’ Prop\nâŠ¢ Eq (Set.image HasCompl.compl (setOf fun s => p s)) (setOf fun s => p (HasCompl.compl s))","decl":"theorem compl_image_set_of {p : Set Î± â†’ Prop} : compl '' { s | p s } = { s | p sá¶œ } :=\n  congr_fun compl_image p\n\n"}
{"name":"Set.inter_preimage_subset","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\nt : Set Î²\nf : Î± â†’ Î²\nâŠ¢ HasSubset.Subset (Inter.inter s (Set.preimage f t)) (Set.preimage f (Inter.inter (Set.image f s) t))","decl":"theorem inter_preimage_subset (s : Set Î±) (t : Set Î²) (f : Î± â†’ Î²) :\n    s âˆ© f â»Â¹' t âŠ† f â»Â¹' (f '' s âˆ© t) := fun _ h => âŸ¨mem_image_of_mem _ h.left, h.rightâŸ©\n\n"}
{"name":"Set.union_preimage_subset","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\nt : Set Î²\nf : Î± â†’ Î²\nâŠ¢ HasSubset.Subset (Union.union s (Set.preimage f t)) (Set.preimage f (Union.union (Set.image f s) t))","decl":"theorem union_preimage_subset (s : Set Î±) (t : Set Î²) (f : Î± â†’ Î²) :\n    s âˆª f â»Â¹' t âŠ† f â»Â¹' (f '' s âˆª t) := fun _ h =>\n  Or.elim h (fun l => Or.inl <| mem_image_of_mem _ l) fun r => Or.inr r\n\n"}
{"name":"Set.subset_image_union","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\nt : Set Î²\nâŠ¢ HasSubset.Subset (Set.image f (Union.union s (Set.preimage f t))) (Union.union (Set.image f s) t)","decl":"theorem subset_image_union (f : Î± â†’ Î²) (s : Set Î±) (t : Set Î²) : f '' (s âˆª f â»Â¹' t) âŠ† f '' s âˆª t :=\n  image_subset_iff.2 (union_preimage_subset _ _ _)\n\n"}
{"name":"Set.preimage_subset_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nA : Set Î±\nB : Set Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (HasSubset.Subset (Set.preimage f B) A) (âˆ€ (a : Î±), Membership.mem B (f a) â†’ Membership.mem A a)","decl":"theorem preimage_subset_iff {A : Set Î±} {B : Set Î²} {f : Î± â†’ Î²} :\n    f â»Â¹' B âŠ† A â†” âˆ€ a : Î±, f a âˆˆ B â†’ a âˆˆ A :=\n  Iff.rfl\n\n"}
{"name":"Set.image_eq_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns t : Set Î±\nf : Î± â†’ Î²\nhf : Function.Injective f\nâŠ¢ Iff (Eq (Set.image f s) (Set.image f t)) (Eq s t)","decl":"theorem image_eq_image {f : Î± â†’ Î²} (hf : Injective f) : f '' s = f '' t â†” s = t :=\n  Iff.symm <|\n    (Iff.intro fun eq => eq â–¸ rfl) fun eq => by\n      rw [â† preimage_image_eq s hf, â† preimage_image_eq t hf, eq]\n\n"}
{"name":"Set.subset_image_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\nt : Set Î²\nâŠ¢ Iff (HasSubset.Subset t (Set.image f s)) (Exists fun u => And (HasSubset.Subset u s) (Eq (Set.image f u) t))","decl":"theorem subset_image_iff {t : Set Î²} :\n    t âŠ† f '' s â†” âˆƒ u, u âŠ† s âˆ§ f '' u = t := by\n  refine âŸ¨fun h â†¦ âŸ¨f â»Â¹' t âˆ© s, inter_subset_right, ?_âŸ©,\n    fun âŸ¨u, hu, hu'âŸ© â†¦ hu'.symm â–¸ image_mono huâŸ©\n  rwa [image_preimage_inter, inter_eq_left]\n\n"}
{"name":"Set.exists_subset_image_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\np : Set Î² â†’ Prop\nâŠ¢ Iff (Exists fun t => And (HasSubset.Subset t (Set.image f s)) (p t)) (Exists fun t => And (HasSubset.Subset t s) (p (Set.image f t)))","decl":"@[simp]\nlemma exists_subset_image_iff {p : Set Î² â†’ Prop} : (âˆƒ t âŠ† f '' s, p t) â†” âˆƒ t âŠ† s, p (f '' t) := by\n  simp [subset_image_iff]\n\n"}
{"name":"Set.forall_subset_image_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\np : Set Î² â†’ Prop\nâŠ¢ Iff (âˆ€ (t : Set Î²), HasSubset.Subset t (Set.image f s) â†’ p t) (âˆ€ (t : Set Î±), HasSubset.Subset t s â†’ p (Set.image f t))","decl":"@[simp]\nlemma forall_subset_image_iff {p : Set Î² â†’ Prop} : (âˆ€ t âŠ† f '' s, p t) â†” âˆ€ t âŠ† s, p (f '' t) := by\n  simp [subset_image_iff]\n\n"}
{"name":"Set.image_subset_image_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns t : Set Î±\nf : Î± â†’ Î²\nhf : Function.Injective f\nâŠ¢ Iff (HasSubset.Subset (Set.image f s) (Set.image f t)) (HasSubset.Subset s t)","decl":"theorem image_subset_image_iff {f : Î± â†’ Î²} (hf : Injective f) : f '' s âŠ† f '' t â†” s âŠ† t := by\n  refine Iff.symm <| (Iff.intro (image_subset f)) fun h => ?_\n  rw [â† preimage_image_eq s hf, â† preimage_image_eq t hf]\n  exact preimage_mono h\n\n"}
{"name":"Set.prod_quotient_preimage_eq_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Setoid Î±\ng : Quotient s â†’ Î²\nh : Î± â†’ Î²\nHh : Eq h (Function.comp g Quotient.mk'')\nr : Set (Prod Î² Î²)\nâŠ¢ Eq (setOf fun x => Membership.mem r { fst := g x.1, snd := g x.2 }) (Set.image (fun a => { fst := Quotient.mk s a.1, snd := Quotient.mk s a.2 }) (Set.preimage (fun a => { fst := h a.1, snd := h a.2 }) r))","decl":"theorem prod_quotient_preimage_eq_image [s : Setoid Î±] (g : Quotient s â†’ Î²) {h : Î± â†’ Î²}\n    (Hh : h = g âˆ˜ Quotient.mk'') (r : Set (Î² Ã— Î²)) :\n    { x : Quotient s Ã— Quotient s | (g x.1, g x.2) âˆˆ r } =\n      (fun a : Î± Ã— Î± => (âŸ¦a.1âŸ§, âŸ¦a.2âŸ§)) '' ((fun a : Î± Ã— Î± => (h a.1, h a.2)) â»Â¹' r) :=\n  Hh.symm â–¸\n    Set.ext fun âŸ¨aâ‚, aâ‚‚âŸ© =>\n      âŸ¨Quot.induction_onâ‚‚ aâ‚ aâ‚‚ fun aâ‚ aâ‚‚ h => âŸ¨(aâ‚, aâ‚‚), h, rflâŸ©, fun âŸ¨âŸ¨bâ‚, bâ‚‚âŸ©, hâ‚, hâ‚‚âŸ© =>\n        show (g aâ‚, g aâ‚‚) âˆˆ r from\n          have hâ‚ƒ : âŸ¦bâ‚âŸ§ = aâ‚ âˆ§ âŸ¦bâ‚‚âŸ§ = aâ‚‚ := Prod.ext_iff.1 hâ‚‚\n          hâ‚ƒ.1 â–¸ hâ‚ƒ.2 â–¸ hâ‚âŸ©\n\n"}
{"name":"Set.exists_image_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nx : Set Î±\nP : Î² â†’ Prop\nâŠ¢ Iff (Exists fun a => P â†‘a) (Exists fun a => P (f â†‘a))","decl":"theorem exists_image_iff (f : Î± â†’ Î²) (x : Set Î±) (P : Î² â†’ Prop) :\n    (âˆƒ a : f '' x, P a) â†” âˆƒ a : x, P (f a) :=\n  âŸ¨fun âŸ¨a, hâŸ© => âŸ¨âŸ¨_, a.prop.choose_spec.1âŸ©, a.prop.choose_spec.2.symm â–¸ hâŸ©, fun âŸ¨a, hâŸ© =>\n    âŸ¨âŸ¨_, _, a.prop, rflâŸ©, hâŸ©âŸ©\n\n"}
{"name":"Set.imageFactorization_eq","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\nâŠ¢ Eq (Function.comp Subtype.val (Set.imageFactorization f s)) (Function.comp f Subtype.val)","decl":"theorem imageFactorization_eq {f : Î± â†’ Î²} {s : Set Î±} :\n    Subtype.val âˆ˜ imageFactorization f s = f âˆ˜ Subtype.val :=\n  funext fun _ => rfl\n\n"}
{"name":"Set.surjective_onto_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\nâŠ¢ Function.Surjective (Set.imageFactorization f s)","decl":"theorem surjective_onto_image {f : Î± â†’ Î²} {s : Set Î±} : Surjective (imageFactorization f s) :=\n  fun âŸ¨_, âŸ¨a, ha, rflâŸ©âŸ© => âŸ¨âŸ¨a, haâŸ©, rflâŸ©\n\n"}
{"name":"Set.image_perm","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns : Set Î±\nÏƒ : Equiv.Perm Î±\nhs : HasSubset.Subset (setOf fun a => Ne (Ïƒ a) a) s\nâŠ¢ Eq (Set.image (â‡‘Ïƒ) s) s","decl":"/-- If the only elements outside `s` are those left fixed by `Ïƒ`, then mapping by `Ïƒ` has no effect.\n-/\ntheorem image_perm {s : Set Î±} {Ïƒ : Equiv.Perm Î±} (hs : { a : Î± | Ïƒ a â‰  a } âŠ† s) : Ïƒ '' s = s := by\n  ext i\n  obtain hi | hi := eq_or_ne (Ïƒ i) i\n  Â· refine âŸ¨?_, fun h => âŸ¨i, h, hiâŸ©âŸ©\n    rintro âŸ¨j, hj, hâŸ©\n    rwa [Ïƒ.injective (hi.trans h.symm)]\n  Â· refine iff_of_true âŸ¨Ïƒ.symm i, hs fun h => hi ?_, Ïƒ.apply_symm_apply _âŸ© (hs hi)\n    convert congr_arg Ïƒ h <;> exact (Ïƒ.apply_symm_apply _).symm\n\n"}
{"name":"Set.powerset_insert","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns : Set Î±\na : Î±\nâŠ¢ Eq (Insert.insert a s).powerset (Union.union s.powerset (Set.image (Insert.insert a) s.powerset))","decl":"/-- The powerset of `{a} âˆª s` is `ğ’« s` together with `{a} âˆª t` for each `t âˆˆ ğ’« s`. -/\ntheorem powerset_insert (s : Set Î±) (a : Î±) : ğ’« insert a s = ğ’« s âˆª insert a '' ğ’« s := by\n  ext t\n  simp_rw [mem_union, mem_image, mem_powerset_iff]\n  constructor\n  Â· intro h\n    by_cases hs : a âˆˆ t\n    Â· right\n      refine âŸ¨t \\ {a}, ?_, ?_âŸ©\n      Â· rw [diff_singleton_subset_iff]\n        assumption\n      Â· rw [insert_diff_singleton, insert_eq_of_mem hs]\n    Â· left\n      exact (subset_insert_iff_of_not_mem hs).mp h\n  Â· rintro (h | âŸ¨s', hâ‚, rflâŸ©)\n    Â· exact subset_trans h (subset_insert a s)\n    Â· exact insert_subset_insert hâ‚\n\n"}
{"name":"Set.forall_mem_range","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nf : Î¹ â†’ Î±\np : Î± â†’ Prop\nâŠ¢ Iff (âˆ€ (a : Î±), Membership.mem (Set.range f) a â†’ p a) (âˆ€ (i : Î¹), p (f i))","decl":"theorem forall_mem_range {p : Î± â†’ Prop} : (âˆ€ a âˆˆ range f, p a) â†” âˆ€ i, p (f i) := by simp\n\n\n"}
{"name":"Set.forall_subtype_range_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nf : Î¹ â†’ Î±\np : â†‘(Set.range f) â†’ Prop\nâŠ¢ Iff (âˆ€ (a : â†‘(Set.range f)), p a) (âˆ€ (i : Î¹), p âŸ¨f i, â‹¯âŸ©)","decl":"theorem forall_subtype_range_iff {p : range f â†’ Prop} :\n    (âˆ€ a : range f, p a) â†” âˆ€ i, p âŸ¨f i, mem_range_self _âŸ© :=\n  âŸ¨fun H _ => H _, fun H âŸ¨y, i, hiâŸ© => by\n    subst hi\n    apply HâŸ©\n\n"}
{"name":"Set.exists_range_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nf : Î¹ â†’ Î±\np : Î± â†’ Prop\nâŠ¢ Iff (Exists fun a => And (Membership.mem (Set.range f) a) (p a)) (Exists fun i => p (f i))","decl":"theorem exists_range_iff {p : Î± â†’ Prop} : (âˆƒ a âˆˆ range f, p a) â†” âˆƒ i, p (f i) := by simp\n\n"}
{"name":"Set.exists_subtype_range_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nf : Î¹ â†’ Î±\np : â†‘(Set.range f) â†’ Prop\nâŠ¢ Iff (Exists fun a => p a) (Exists fun i => p âŸ¨f i, â‹¯âŸ©)","decl":"theorem exists_subtype_range_iff {p : range f â†’ Prop} :\n    (âˆƒ a : range f, p a) â†” âˆƒ i, p âŸ¨f i, mem_range_self _âŸ© :=\n  âŸ¨fun âŸ¨âŸ¨a, i, hiâŸ©, haâŸ© => by\n    subst a\n    exact âŸ¨i, haâŸ©,\n   fun âŸ¨_, hiâŸ© => âŸ¨_, hiâŸ©âŸ©\n\n"}
{"name":"Set.range_eq_univ","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nf : Î¹ â†’ Î±\nâŠ¢ Iff (Eq (Set.range f) Set.univ) (Function.Surjective f)","decl":"theorem range_eq_univ : range f = univ â†” Surjective f :=\n  eq_univ_iff_forall\n\n"}
{"name":"Set.range_iff_surjective","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nf : Î¹ â†’ Î±\nâŠ¢ Iff (Eq (Set.range f) Set.univ) (Function.Surjective f)","decl":"@[deprecated (since := \"2024-11-11\")] alias range_iff_surjective := range_eq_univ\n\n"}
{"name":"Function.Surjective.range_eq","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nf : Î¹ â†’ Î±\naâœ : Function.Surjective f\nâŠ¢ Eq (Set.range f) Set.univ","decl":"alias âŸ¨_, _root_.Function.Surjective.range_eqâŸ© := range_eq_univ\n\n"}
{"name":"Set.subset_range_of_surjective","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nh : Function.Surjective f\ns : Set Î²\nâŠ¢ HasSubset.Subset s (Set.range f)","decl":"@[simp]\ntheorem subset_range_of_surjective {f : Î± â†’ Î²} (h : Surjective f) (s : Set Î²) :\n    s âŠ† range f := Surjective.range_eq h â–¸ subset_univ s\n\n"}
{"name":"Set.image_univ","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nâŠ¢ Eq (Set.image f Set.univ) (Set.range f)","decl":"@[simp]\ntheorem image_univ {f : Î± â†’ Î²} : f '' univ = range f := by\n  ext\n  simp [image, range]\n\n"}
{"name":"Set.image_compl_eq_range_diff_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Injective f\ns : Set Î±\nâŠ¢ Eq (Set.image f (HasCompl.compl s)) (SDiff.sdiff (Set.range f) (Set.image f s))","decl":"lemma image_compl_eq_range_diff_image {f : Î± â†’ Î²} (hf : Injective f) (s : Set Î±) :\n    f '' sá¶œ = range f \\ f '' s := by rw [â† image_univ, â† image_diff hf, compl_eq_univ_diff]\n\n"}
{"name":"Set.range_diff_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Injective f\ns : Set Î±\nâŠ¢ Eq (SDiff.sdiff (Set.range f) (Set.image f s)) (Set.image f (HasCompl.compl s))","decl":"/-- Alias of `Set.image_compl_eq_range_sdiff_image`. -/\nlemma range_diff_image {f : Î± â†’ Î²} (hf : Injective f) (s : Set Î±) : range f \\ f '' s = f '' sá¶œ := by\n  rw [image_compl_eq_range_diff_image hf]\n\n"}
{"name":"Set.preimage_eq_univ_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î²\nâŠ¢ Iff (Eq (Set.preimage f s) Set.univ) (HasSubset.Subset (Set.range f) s)","decl":"@[simp]\ntheorem preimage_eq_univ_iff {f : Î± â†’ Î²} {s} : f â»Â¹' s = univ â†” range f âŠ† s := by\n  rw [â† univ_subset_iff, â† image_subset_iff, image_univ]\n\n"}
{"name":"Set.image_subset_range","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\nâŠ¢ HasSubset.Subset (Set.image f s) (Set.range f)","decl":"theorem image_subset_range (f : Î± â†’ Î²) (s) : f '' s âŠ† range f := by\n  rw [â† image_univ]; exact image_subset _ (subset_univ _)\n\n"}
{"name":"Set.mem_range_of_mem_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\nx : Î²\nh : Membership.mem (Set.image f s) x\nâŠ¢ Membership.mem (Set.range f) x","decl":"theorem mem_range_of_mem_image (f : Î± â†’ Î²) (s) {x : Î²} (h : x âˆˆ f '' s) : x âˆˆ range f :=\n  image_subset_range f s h\n\n"}
{"name":"Nat.mem_range_succ","module":"Mathlib.Data.Set.Image","initialProofState":"i : Nat\nâŠ¢ Iff (Membership.mem (Set.range Nat.succ) i) (LT.lt 0 i)","decl":"theorem _root_.Nat.mem_range_succ (i : â„•) : i âˆˆ range Nat.succ â†” 0 < i :=\n  âŸ¨by\n    rintro âŸ¨n, rflâŸ©\n    exact Nat.succ_pos n, fun h => âŸ¨_, Nat.succ_pred_eq_of_pos hâŸ©âŸ©\n\n"}
{"name":"Set.Nonempty.preimage'","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î²\nhs : s.Nonempty\nf : Î± â†’ Î²\nhf : HasSubset.Subset s (Set.range f)\nâŠ¢ (Set.preimage f s).Nonempty","decl":"theorem Nonempty.preimage' {s : Set Î²} (hs : s.Nonempty) {f : Î± â†’ Î²} (hf : s âŠ† range f) :\n    (f â»Â¹' s).Nonempty :=\n  let âŸ¨_, hyâŸ© := hs\n  let âŸ¨x, hxâŸ© := hf hy\n  âŸ¨x, Set.mem_preimage.2 <| hx.symm â–¸ hyâŸ©\n\n"}
{"name":"Set.range_comp","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Sort u_4\ng : Î± â†’ Î²\nf : Î¹ â†’ Î±\nâŠ¢ Eq (Set.range (Function.comp g f)) (Set.image g (Set.range f))","decl":"theorem range_comp (g : Î± â†’ Î²) (f : Î¹ â†’ Î±) : range (g âˆ˜ f) = g '' range f := by aesop\n\n"}
{"name":"Set.range_subset_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nf : Î¹ â†’ Î±\ns : Set Î±\nâŠ¢ Iff (HasSubset.Subset (Set.range f) s) (âˆ€ (y : Î¹), Membership.mem s (f y))","decl":"theorem range_subset_iff : range f âŠ† s â†” âˆ€ y, f y âˆˆ s :=\n  forall_mem_range\n\n"}
{"name":"Set.range_subset_range_iff_exists_comp","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Î± â†’ Î³\ng : Î² â†’ Î³\nâŠ¢ Iff (HasSubset.Subset (Set.range f) (Set.range g)) (Exists fun h => Eq f (Function.comp g h))","decl":"theorem range_subset_range_iff_exists_comp {f : Î± â†’ Î³} {g : Î² â†’ Î³} :\n    range f âŠ† range g â†” âˆƒ h : Î± â†’ Î², f = g âˆ˜ h := by\n  simp only [range_subset_iff, mem_range, Classical.skolem, funext_iff, (Â· âˆ˜ Â·), eq_comm]\n\n"}
{"name":"Set.range_eq_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î²\nâŠ¢ Iff (Eq (Set.range f) s) (And (âˆ€ (a : Î±), Membership.mem s (f a)) (âˆ€ (b : Î²), Membership.mem s b â†’ Exists fun a => Eq (f a) b))","decl":"theorem range_eq_iff (f : Î± â†’ Î²) (s : Set Î²) :\n    range f = s â†” (âˆ€ a, f a âˆˆ s) âˆ§ âˆ€ b âˆˆ s, âˆƒ a, f a = b := by\n  rw [â† range_subset_iff]\n  exact le_antisymm_iff\n\n"}
{"name":"Set.range_comp_subset_range","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Î± â†’ Î²\ng : Î² â†’ Î³\nâŠ¢ HasSubset.Subset (Set.range (Function.comp g f)) (Set.range g)","decl":"theorem range_comp_subset_range (f : Î± â†’ Î²) (g : Î² â†’ Î³) : range (g âˆ˜ f) âŠ† range g := by\n  rw [range_comp]; apply image_subset_range\n\n"}
{"name":"Set.range_nonempty_iff_nonempty","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nf : Î¹ â†’ Î±\nâŠ¢ Iff (Set.range f).Nonempty (Nonempty Î¹)","decl":"theorem range_nonempty_iff_nonempty : (range f).Nonempty â†” Nonempty Î¹ :=\n  âŸ¨fun âŸ¨_, x, _âŸ© => âŸ¨xâŸ©, fun âŸ¨xâŸ© => âŸ¨f x, mem_range_self xâŸ©âŸ©\n\n"}
{"name":"Set.range_nonempty","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nh : Nonempty Î¹\nf : Î¹ â†’ Î±\nâŠ¢ (Set.range f).Nonempty","decl":"theorem range_nonempty [h : Nonempty Î¹] (f : Î¹ â†’ Î±) : (range f).Nonempty :=\n  range_nonempty_iff_nonempty.2 h\n\n"}
{"name":"Set.range_eq_empty_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nf : Î¹ â†’ Î±\nâŠ¢ Iff (Eq (Set.range f) EmptyCollection.emptyCollection) (IsEmpty Î¹)","decl":"@[simp]\ntheorem range_eq_empty_iff {f : Î¹ â†’ Î±} : range f = âˆ… â†” IsEmpty Î¹ := by\n  rw [â† not_nonempty_iff, â† range_nonempty_iff_nonempty, not_nonempty_iff_eq_empty]\n\n"}
{"name":"Set.range_eq_empty","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\ninstâœ : IsEmpty Î¹\nf : Î¹ â†’ Î±\nâŠ¢ Eq (Set.range f) EmptyCollection.emptyCollection","decl":"theorem range_eq_empty [IsEmpty Î¹] (f : Î¹ â†’ Î±) : range f = âˆ… :=\n  range_eq_empty_iff.2 â€¹_â€º\n\n"}
{"name":"Set.instNonemptyRange","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\ninstâœ : Nonempty Î¹\nf : Î¹ â†’ Î±\nâŠ¢ Nonempty â†‘(Set.range f)","decl":"instance instNonemptyRange [Nonempty Î¹] (f : Î¹ â†’ Î±) : Nonempty (range f) :=\n  (range_nonempty f).to_subtype\n\n"}
{"name":"Set.image_union_image_compl_eq_range","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\nf : Î± â†’ Î²\nâŠ¢ Eq (Union.union (Set.image f s) (Set.image f (HasCompl.compl s))) (Set.range f)","decl":"@[simp]\ntheorem image_union_image_compl_eq_range (f : Î± â†’ Î²) : f '' s âˆª f '' sá¶œ = range f := by\n  rw [â† image_union, â† image_univ, â† union_compl_self]\n\n"}
{"name":"Set.insert_image_compl_eq_range","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nx : Î±\nâŠ¢ Eq (Insert.insert (f x) (Set.image f (HasCompl.compl (Singleton.singleton x)))) (Set.range f)","decl":"theorem insert_image_compl_eq_range (f : Î± â†’ Î²) (x : Î±) : insert (f x) (f '' {x}á¶œ) = range f := by\n  rw [â† image_insert_eq, insert_eq, union_compl_self, image_univ]\n\n"}
{"name":"Set.image_preimage_eq_range_inter","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nt : Set Î²\nâŠ¢ Eq (Set.image f (Set.preimage f t)) (Inter.inter (Set.range f) t)","decl":"theorem image_preimage_eq_range_inter {f : Î± â†’ Î²} {t : Set Î²} : f '' (f â»Â¹' t) = range f âˆ© t :=\n  ext fun x =>\n    âŸ¨fun âŸ¨_, hx, HEqâŸ© => HEq â–¸ âŸ¨mem_range_self _, hxâŸ©, fun âŸ¨âŸ¨y, h_eqâŸ©, hxâŸ© =>\n      h_eq â–¸ mem_image_of_mem f <| show y âˆˆ f â»Â¹' t by rw [preimage, mem_setOf, h_eq]; exact hxâŸ©\n\n"}
{"name":"Set.image_preimage_eq_inter_range","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nt : Set Î²\nâŠ¢ Eq (Set.image f (Set.preimage f t)) (Inter.inter t (Set.range f))","decl":"theorem image_preimage_eq_inter_range {f : Î± â†’ Î²} {t : Set Î²} : f '' (f â»Â¹' t) = t âˆ© range f := by\n  rw [image_preimage_eq_range_inter, inter_comm]\n\n"}
{"name":"Set.image_preimage_eq_of_subset","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î²\nhs : HasSubset.Subset s (Set.range f)\nâŠ¢ Eq (Set.image f (Set.preimage f s)) s","decl":"theorem image_preimage_eq_of_subset {f : Î± â†’ Î²} {s : Set Î²} (hs : s âŠ† range f) :\n    f '' (f â»Â¹' s) = s := by rw [image_preimage_eq_range_inter, inter_eq_self_of_subset_right hs]\n\n"}
{"name":"Set.image_preimage_eq_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î²\nâŠ¢ Iff (Eq (Set.image f (Set.preimage f s)) s) (HasSubset.Subset s (Set.range f))","decl":"theorem image_preimage_eq_iff {f : Î± â†’ Î²} {s : Set Î²} : f '' (f â»Â¹' s) = s â†” s âŠ† range f :=\n  âŸ¨by\n    intro h\n    rw [â† h]\n    apply image_subset_range,\n   image_preimage_eq_of_subsetâŸ©\n\n"}
{"name":"Set.subset_range_iff_exists_image_eq","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î²\nâŠ¢ Iff (HasSubset.Subset s (Set.range f)) (Exists fun t => Eq (Set.image f t) s)","decl":"theorem subset_range_iff_exists_image_eq {f : Î± â†’ Î²} {s : Set Î²} : s âŠ† range f â†” âˆƒ t, f '' t = s :=\n  âŸ¨fun h => âŸ¨_, image_preimage_eq_iff.2 hâŸ©, fun âŸ¨_, htâŸ© => ht â–¸ image_subset_range _ _âŸ©\n\n"}
{"name":"Set.range_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nâŠ¢ Eq (Set.range (Set.image f)) (Set.range f).powerset","decl":"theorem range_image (f : Î± â†’ Î²) : range (image f) = ğ’« range f :=\n  ext fun _ => subset_range_iff_exists_image_eq.symm\n\n"}
{"name":"Set.exists_subset_range_and_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\np : Set Î² â†’ Prop\nâŠ¢ Iff (Exists fun s => And (HasSubset.Subset s (Set.range f)) (p s)) (Exists fun s => p (Set.image f s))","decl":"@[simp]\ntheorem exists_subset_range_and_iff {f : Î± â†’ Î²} {p : Set Î² â†’ Prop} :\n    (âˆƒ s, s âŠ† range f âˆ§ p s) â†” âˆƒ s, p (f '' s) := by\n  rw [â† exists_range_iff, range_image]; rfl\n\n"}
{"name":"Set.forall_subset_range_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\np : Set Î² â†’ Prop\nâŠ¢ Iff (âˆ€ (s : Set Î²), HasSubset.Subset s (Set.range f) â†’ p s) (âˆ€ (s : Set Î±), p (Set.image f s))","decl":"@[simp]\ntheorem forall_subset_range_iff {f : Î± â†’ Î²} {p : Set Î² â†’ Prop} :\n    (âˆ€ s, s âŠ† range f â†’ p s) â†” âˆ€ s, p (f '' s) := by\n  rw [â† forall_mem_range, range_image]; simp only [mem_powerset_iff]\n\n"}
{"name":"Set.preimage_subset_preimage_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns t : Set Î±\nf : Î² â†’ Î±\nhs : HasSubset.Subset s (Set.range f)\nâŠ¢ Iff (HasSubset.Subset (Set.preimage f s) (Set.preimage f t)) (HasSubset.Subset s t)","decl":"@[simp]\ntheorem preimage_subset_preimage_iff {s t : Set Î±} {f : Î² â†’ Î±} (hs : s âŠ† range f) :\n    f â»Â¹' s âŠ† f â»Â¹' t â†” s âŠ† t := by\n  constructor\n  Â· intro h x hx\n    rcases hs hx with âŸ¨y, rflâŸ©\n    exact h hx\n  intro h x; apply h\n\n"}
{"name":"Set.preimage_eq_preimage'","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns t : Set Î±\nf : Î² â†’ Î±\nhs : HasSubset.Subset s (Set.range f)\nht : HasSubset.Subset t (Set.range f)\nâŠ¢ Iff (Eq (Set.preimage f s) (Set.preimage f t)) (Eq s t)","decl":"theorem preimage_eq_preimage' {s t : Set Î±} {f : Î² â†’ Î±} (hs : s âŠ† range f) (ht : t âŠ† range f) :\n    f â»Â¹' s = f â»Â¹' t â†” s = t := by\n  constructor\n  Â· intro h\n    apply Subset.antisymm\n    Â· rw [â† preimage_subset_preimage_iff hs, h]\n    Â· rw [â† preimage_subset_preimage_iff ht, h]\n  rintro rfl; rfl\n\n-- Porting note:\n-- @[simp] `simp` can prove this\n"}
{"name":"Set.preimage_inter_range","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î²\nâŠ¢ Eq (Set.preimage f (Inter.inter s (Set.range f))) (Set.preimage f s)","decl":"theorem preimage_inter_range {f : Î± â†’ Î²} {s : Set Î²} : f â»Â¹' (s âˆ© range f) = f â»Â¹' s :=\n  Set.ext fun x => and_iff_left âŸ¨x, rflâŸ©\n\n-- Porting note:\n-- @[simp] `simp` can prove this\n"}
{"name":"Set.preimage_range_inter","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î²\nâŠ¢ Eq (Set.preimage f (Inter.inter (Set.range f) s)) (Set.preimage f s)","decl":"theorem preimage_range_inter {f : Î± â†’ Î²} {s : Set Î²} : f â»Â¹' (range f âˆ© s) = f â»Â¹' s := by\n  rw [inter_comm, preimage_inter_range]\n\n"}
{"name":"Set.preimage_image_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î²\nâŠ¢ Eq (Set.preimage f (Set.image f (Set.preimage f s))) (Set.preimage f s)","decl":"theorem preimage_image_preimage {f : Î± â†’ Î²} {s : Set Î²} : f â»Â¹' (f '' (f â»Â¹' s)) = f â»Â¹' s := by\n  rw [image_preimage_eq_range_inter, preimage_range_inter]\n\n"}
{"name":"Set.range_id","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nâŠ¢ Eq (Set.range id) Set.univ","decl":"@[simp, mfld_simps]\ntheorem range_id : range (@id Î±) = univ :=\n  range_eq_univ.2 surjective_id\n\n"}
{"name":"Set.range_id'","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nâŠ¢ Eq (Set.range fun x => x) Set.univ","decl":"@[simp, mfld_simps]\ntheorem range_id' : (range fun x : Î± => x) = univ :=\n  range_id\n\n"}
{"name":"Prod.range_fst","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : Nonempty Î²\nâŠ¢ Eq (Set.range Prod.fst) Set.univ","decl":"@[simp]\ntheorem _root_.Prod.range_fst [Nonempty Î²] : range (Prod.fst : Î± Ã— Î² â†’ Î±) = univ :=\n  Prod.fst_surjective.range_eq\n\n"}
{"name":"Prod.range_snd","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : Nonempty Î±\nâŠ¢ Eq (Set.range Prod.snd) Set.univ","decl":"@[simp]\ntheorem _root_.Prod.range_snd [Nonempty Î±] : range (Prod.snd : Î± Ã— Î² â†’ Î²) = univ :=\n  Prod.snd_surjective.range_eq\n\n"}
{"name":"Set.range_eval","module":"Mathlib.Data.Set.Image","initialProofState":"Î¹ : Sort u_4\nÎ± : Î¹ â†’ Type u_5\ninstâœ : âˆ€ (i : Î¹), Nonempty (Î± i)\ni : Î¹\nâŠ¢ Eq (Set.range (Function.eval i)) Set.univ","decl":"@[simp]\ntheorem range_eval {Î± : Î¹ â†’ Sort _} [âˆ€ i, Nonempty (Î± i)] (i : Î¹) :\n    range (eval i : (âˆ€ i, Î± i) â†’ Î± i) = univ :=\n  (surjective_eval i).range_eq\n\n"}
{"name":"Set.range_inl","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nâŠ¢ Eq (Set.range Sum.inl) (setOf fun x => Eq x.isLeft Bool.true)","decl":"theorem range_inl : range (@Sum.inl Î± Î²) = {x | Sum.isLeft x} := by ext (_|_) <;> simp\n"}
{"name":"Set.range_inr","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nâŠ¢ Eq (Set.range Sum.inr) (setOf fun x => Eq x.isRight Bool.true)","decl":"theorem range_inr : range (@Sum.inr Î± Î²) = {x | Sum.isRight x} := by ext (_|_) <;> simp\n\n"}
{"name":"Set.isCompl_range_inl_range_inr","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nâŠ¢ IsCompl (Set.range Sum.inl) (Set.range Sum.inr)","decl":"theorem isCompl_range_inl_range_inr : IsCompl (range <| @Sum.inl Î± Î²) (range Sum.inr) :=\n  IsCompl.of_le\n    (by\n      rintro y âŸ¨âŸ¨xâ‚, rflâŸ©, âŸ¨xâ‚‚, hâŸ©âŸ©\n      exact Sum.noConfusion h)\n    (by rintro (x | y) - <;> [left; right] <;> exact mem_range_self _)\n\n"}
{"name":"Set.range_inl_union_range_inr","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nâŠ¢ Eq (Union.union (Set.range Sum.inl) (Set.range Sum.inr)) Set.univ","decl":"@[simp]\ntheorem range_inl_union_range_inr : range (Sum.inl : Î± â†’ Î± âŠ• Î²) âˆª range Sum.inr = univ :=\n  isCompl_range_inl_range_inr.sup_eq_top\n\n"}
{"name":"Set.range_inl_inter_range_inr","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nâŠ¢ Eq (Inter.inter (Set.range Sum.inl) (Set.range Sum.inr)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem range_inl_inter_range_inr : range (Sum.inl : Î± â†’ Î± âŠ• Î²) âˆ© range Sum.inr = âˆ… :=\n  isCompl_range_inl_range_inr.inf_eq_bot\n\n"}
{"name":"Set.range_inr_union_range_inl","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nâŠ¢ Eq (Union.union (Set.range Sum.inr) (Set.range Sum.inl)) Set.univ","decl":"@[simp]\ntheorem range_inr_union_range_inl : range (Sum.inr : Î² â†’ Î± âŠ• Î²) âˆª range Sum.inl = univ :=\n  isCompl_range_inl_range_inr.symm.sup_eq_top\n\n"}
{"name":"Set.range_inr_inter_range_inl","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nâŠ¢ Eq (Inter.inter (Set.range Sum.inr) (Set.range Sum.inl)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem range_inr_inter_range_inl : range (Sum.inr : Î² â†’ Î± âŠ• Î²) âˆ© range Sum.inl = âˆ… :=\n  isCompl_range_inl_range_inr.symm.inf_eq_bot\n\n"}
{"name":"Set.preimage_inl_image_inr","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î²\nâŠ¢ Eq (Set.preimage Sum.inl (Set.image Sum.inr s)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem preimage_inl_image_inr (s : Set Î²) : Sum.inl â»Â¹' (@Sum.inr Î± Î² '' s) = âˆ… := by\n  ext\n  simp\n\n"}
{"name":"Set.preimage_inr_image_inl","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\nâŠ¢ Eq (Set.preimage Sum.inr (Set.image Sum.inl s)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem preimage_inr_image_inl (s : Set Î±) : Sum.inr â»Â¹' (@Sum.inl Î± Î² '' s) = âˆ… := by\n  ext\n  simp\n\n"}
{"name":"Set.preimage_inl_range_inr","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nâŠ¢ Eq (Set.preimage Sum.inl (Set.range Sum.inr)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem preimage_inl_range_inr : Sum.inl â»Â¹' range (Sum.inr : Î² â†’ Î± âŠ• Î²) = âˆ… := by\n  rw [â† image_univ, preimage_inl_image_inr]\n\n"}
{"name":"Set.preimage_inr_range_inl","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nâŠ¢ Eq (Set.preimage Sum.inr (Set.range Sum.inl)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem preimage_inr_range_inl : Sum.inr â»Â¹' range (Sum.inl : Î± â†’ Î± âŠ• Î²) = âˆ… := by\n  rw [â† image_univ, preimage_inr_image_inl]\n\n"}
{"name":"Set.compl_range_inl","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nâŠ¢ Eq (HasCompl.compl (Set.range Sum.inl)) (Set.range Sum.inr)","decl":"@[simp]\ntheorem compl_range_inl : (range (Sum.inl : Î± â†’ Î± âŠ• Î²))á¶œ = range (Sum.inr : Î² â†’ Î± âŠ• Î²) :=\n  IsCompl.compl_eq isCompl_range_inl_range_inr\n\n"}
{"name":"Set.compl_range_inr","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nâŠ¢ Eq (HasCompl.compl (Set.range Sum.inr)) (Set.range Sum.inl)","decl":"@[simp]\ntheorem compl_range_inr : (range (Sum.inr : Î² â†’ Î± âŠ• Î²))á¶œ = range (Sum.inl : Î± â†’ Î± âŠ• Î²) :=\n  IsCompl.compl_eq isCompl_range_inl_range_inr.symm\n\n"}
{"name":"Set.image_preimage_inl_union_image_preimage_inr","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set (Sum Î± Î²)\nâŠ¢ Eq (Union.union (Set.image Sum.inl (Set.preimage Sum.inl s)) (Set.image Sum.inr (Set.preimage Sum.inr s))) s","decl":"theorem image_preimage_inl_union_image_preimage_inr (s : Set (Î± âŠ• Î²)) :\n    Sum.inl '' (Sum.inl â»Â¹' s) âˆª Sum.inr '' (Sum.inr â»Â¹' s) = s := by\n  rw [image_preimage_eq_inter_range, image_preimage_eq_inter_range, â† inter_union_distrib_left,\n    range_inl_union_range_inr, inter_univ]\n\n"}
{"name":"Set.range_quot_mk","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nr : Î± â†’ Î± â†’ Prop\nâŠ¢ Eq (Set.range (Quot.mk r)) Set.univ","decl":"@[simp]\ntheorem range_quot_mk (r : Î± â†’ Î± â†’ Prop) : range (Quot.mk r) = univ :=\n  Quot.mk_surjective.range_eq\n\n"}
{"name":"Set.range_quot_lift","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nf : Î¹ â†’ Î±\nr : Î¹ â†’ Î¹ â†’ Prop\nhf : âˆ€ (x y : Î¹), r x y â†’ Eq (f x) (f y)\nâŠ¢ Eq (Set.range (Quot.lift f hf)) (Set.range f)","decl":"@[simp]\ntheorem range_quot_lift {r : Î¹ â†’ Î¹ â†’ Prop} (hf : âˆ€ x y, r x y â†’ f x = f y) :\n    range (Quot.lift f hf) = range f :=\n  ext fun _ => Quot.mk_surjective.exists\n\n"}
{"name":"Set.range_quotient_mk","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns : Setoid Î±\nâŠ¢ Eq (Set.range (Quotient.mk s)) Set.univ","decl":"@[simp]\ntheorem range_quotient_mk {s : Setoid Î±} : range (Quotient.mk s) = univ :=\n  range_quot_mk _\n\n"}
{"name":"Set.range_quotient_lift","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nf : Î¹ â†’ Î±\ns : Setoid Î¹\nhf : âˆ€ (a b : Î¹), HasEquiv.Equiv a b â†’ Eq (f a) (f b)\nâŠ¢ Eq (Set.range (Quotient.lift f hf)) (Set.range f)","decl":"@[simp]\ntheorem range_quotient_lift [s : Setoid Î¹] (hf) :\n    range (Quotient.lift f hf : Quotient s â†’ Î±) = range f :=\n  range_quot_lift _\n\n"}
{"name":"Set.range_quotient_mk'","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns : Setoid Î±\nâŠ¢ Eq (Set.range Quotient.mk') Set.univ","decl":"@[simp]\ntheorem range_quotient_mk' {s : Setoid Î±} : range (Quotient.mk' : Î± â†’ Quotient s) = univ :=\n  range_quot_mk _\n\n"}
{"name":"Set.Quotient.range_mk''","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nsa : Setoid Î±\nâŠ¢ Eq (Set.range Quotient.mk'') Set.univ","decl":"lemma Quotient.range_mk'' {sa : Setoid Î±} : range (Quotient.mk'' (sâ‚ := sa)) = univ :=\n  range_quotient_mk\n\n"}
{"name":"Set.range_quotient_lift_on'","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nf : Î¹ â†’ Î±\ns : Setoid Î¹\nhf : âˆ€ (a b : Î¹), s a b â†’ Eq (f a) (f b)\nâŠ¢ Eq (Set.range fun x => x.liftOn' f hf) (Set.range f)","decl":"@[simp]\ntheorem range_quotient_lift_on' {s : Setoid Î¹} (hf) :\n    (range fun x : Quotient s => Quotient.liftOn' x f hf) = range f :=\n  range_quot_lift _\n\n"}
{"name":"Set.canLift","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nc : Î² â†’ Î±\np : Î± â†’ Prop\ninstâœ : CanLift Î± Î² c p\nâŠ¢ CanLift (Set Î±) (Set Î²) (fun x => Set.image c x) fun s => âˆ€ (x : Î±), Membership.mem s x â†’ p x","decl":"instance canLift (c) (p) [CanLift Î± Î² c p] :\n    CanLift (Set Î±) (Set Î²) (c '' Â·) fun s => âˆ€ x âˆˆ s, p x where\n  prf _ hs := subset_range_iff_exists_image_eq.mp fun x hx => CanLift.prf _ (hs x hx)\n\n"}
{"name":"Set.range_const_subset","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nc : Î±\nâŠ¢ HasSubset.Subset (Set.range fun x => c) (Singleton.singleton c)","decl":"theorem range_const_subset {c : Î±} : (range fun _ : Î¹ => c) âŠ† {c} :=\n  range_subset_iff.2 fun _ => rfl\n\n"}
{"name":"Set.range_const","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\ninstâœ : Nonempty Î¹\nc : Î±\nâŠ¢ Eq (Set.range fun x => c) (Singleton.singleton c)","decl":"@[simp]\ntheorem range_const : âˆ€ [Nonempty Î¹] {c : Î±}, (range fun _ : Î¹ => c) = {c}\n  | âŸ¨xâŸ©, _ =>\n    (Subset.antisymm range_const_subset) fun _ hy =>\n      (mem_singleton_iff.1 hy).symm â–¸ mem_range_self x\n\n"}
{"name":"Set.range_subtype_map","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\np : Î± â†’ Prop\nq : Î² â†’ Prop\nf : Î± â†’ Î²\nh : âˆ€ (x : Î±), p x â†’ q (f x)\nâŠ¢ Eq (Set.range (Subtype.map f h)) (Set.preimage Subtype.val (Set.image f (setOf fun x => p x)))","decl":"theorem range_subtype_map {p : Î± â†’ Prop} {q : Î² â†’ Prop} (f : Î± â†’ Î²) (h : âˆ€ x, p x â†’ q (f x)) :\n    range (Subtype.map f h) = (â†‘) â»Â¹' (f '' { x | p x }) := by\n  ext âŸ¨x, hxâŸ©\n  simp_rw [mem_preimage, mem_range, mem_image, Subtype.exists, Subtype.map]\n  simp only [Subtype.mk.injEq, exists_prop, mem_setOf_eq]\n\n"}
{"name":"Set.image_swap_eq_preimage_swap","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nâŠ¢ Eq (Set.image Prod.swap) (Set.preimage Prod.swap)","decl":"theorem image_swap_eq_preimage_swap : image (@Prod.swap Î± Î²) = preimage Prod.swap :=\n  image_eq_preimage_of_inverse Prod.swap_leftInverse Prod.swap_rightInverse\n\n"}
{"name":"Set.preimage_singleton_nonempty","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ny : Î²\nâŠ¢ Iff (Set.preimage f (Singleton.singleton y)).Nonempty (Membership.mem (Set.range f) y)","decl":"theorem preimage_singleton_nonempty {f : Î± â†’ Î²} {y : Î²} : (f â»Â¹' {y}).Nonempty â†” y âˆˆ range f :=\n  Iff.rfl\n\n"}
{"name":"Set.preimage_singleton_eq_empty","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ny : Î²\nâŠ¢ Iff (Eq (Set.preimage f (Singleton.singleton y)) EmptyCollection.emptyCollection) (Not (Membership.mem (Set.range f) y))","decl":"theorem preimage_singleton_eq_empty {f : Î± â†’ Î²} {y : Î²} : f â»Â¹' {y} = âˆ… â†” y âˆ‰ range f :=\n  not_nonempty_iff_eq_empty.symm.trans preimage_singleton_nonempty.not\n\n"}
{"name":"Set.range_subset_singleton","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nf : Î¹ â†’ Î±\nx : Î±\nâŠ¢ Iff (HasSubset.Subset (Set.range f) (Singleton.singleton x)) (Eq f (Function.const Î¹ x))","decl":"theorem range_subset_singleton {f : Î¹ â†’ Î±} {x : Î±} : range f âŠ† {x} â†” f = const Î¹ x := by\n  simp [range_subset_iff, funext_iff, mem_singleton]\n\n"}
{"name":"Set.image_compl_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î²\nâŠ¢ Eq (Set.image f (HasCompl.compl (Set.preimage f s))) (SDiff.sdiff (Set.range f) s)","decl":"theorem image_compl_preimage {f : Î± â†’ Î²} {s : Set Î²} : f '' (f â»Â¹' s)á¶œ = range f \\ s := by\n  rw [compl_eq_univ_diff, image_diff_preimage, image_univ]\n\n"}
{"name":"Set.rangeFactorization_eq","module":"Mathlib.Data.Set.Image","initialProofState":"Î² : Type u_2\nÎ¹ : Sort u_4\nf : Î¹ â†’ Î²\nâŠ¢ Eq (Function.comp Subtype.val (Set.rangeFactorization f)) f","decl":"theorem rangeFactorization_eq {f : Î¹ â†’ Î²} : Subtype.val âˆ˜ rangeFactorization f = f :=\n  funext fun _ => rfl\n\n"}
{"name":"Set.rangeFactorization_coe","module":"Mathlib.Data.Set.Image","initialProofState":"Î² : Type u_2\nÎ¹ : Sort u_4\nf : Î¹ â†’ Î²\na : Î¹\nâŠ¢ Eq (â†‘(Set.rangeFactorization f a)) (f a)","decl":"@[simp]\ntheorem rangeFactorization_coe (f : Î¹ â†’ Î²) (a : Î¹) : (rangeFactorization f a : Î²) = f a :=\n  rfl\n\n"}
{"name":"Set.coe_comp_rangeFactorization","module":"Mathlib.Data.Set.Image","initialProofState":"Î² : Type u_2\nÎ¹ : Sort u_4\nf : Î¹ â†’ Î²\nâŠ¢ Eq (Function.comp Subtype.val (Set.rangeFactorization f)) f","decl":"@[simp]\ntheorem coe_comp_rangeFactorization (f : Î¹ â†’ Î²) : (â†‘) âˆ˜ rangeFactorization f = f := rfl\n\n"}
{"name":"Set.surjective_onto_range","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nf : Î¹ â†’ Î±\nâŠ¢ Function.Surjective (Set.rangeFactorization f)","decl":"theorem surjective_onto_range : Surjective (rangeFactorization f) := fun âŸ¨_, âŸ¨i, rflâŸ©âŸ© => âŸ¨i, rflâŸ©\n\n"}
{"name":"Set.image_eq_range","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\nâŠ¢ Eq (Set.image f s) (Set.range fun x => f â†‘x)","decl":"theorem image_eq_range (f : Î± â†’ Î²) (s : Set Î±) : f '' s = range fun x : s => f x := by\n  ext\n  constructor\n  Â· rintro âŸ¨x, h1, h2âŸ©\n    exact âŸ¨âŸ¨x, h1âŸ©, h2âŸ©\n  Â· rintro âŸ¨âŸ¨x, h1âŸ©, h2âŸ©\n    exact âŸ¨x, h1, h2âŸ©\n\n"}
{"name":"Sum.range_eq","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Sum Î± Î² â†’ Î³\nâŠ¢ Eq (Set.range f) (Union.union (Set.range (Function.comp f Sum.inl)) (Set.range (Function.comp f Sum.inr)))","decl":"theorem _root_.Sum.range_eq (f : Î± âŠ• Î² â†’ Î³) :\n    range f = range (f âˆ˜ Sum.inl) âˆª range (f âˆ˜ Sum.inr) :=\n  ext fun _ => Sum.exists\n\n"}
{"name":"Set.Sum.elim_range","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Î± â†’ Î³\ng : Î² â†’ Î³\nâŠ¢ Eq (Set.range (Sum.elim f g)) (Union.union (Set.range f) (Set.range g))","decl":"@[simp]\ntheorem Sum.elim_range (f : Î± â†’ Î³) (g : Î² â†’ Î³) : range (Sum.elim f g) = range f âˆª range g :=\n  Sum.range_eq _\n\n"}
{"name":"Set.range_ite_subset'","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\np : Prop\ninstâœ : Decidable p\nf g : Î± â†’ Î²\nâŠ¢ HasSubset.Subset (Set.range (ite p f g)) (Union.union (Set.range f) (Set.range g))","decl":"theorem range_ite_subset' {p : Prop} [Decidable p] {f g : Î± â†’ Î²} :\n    range (if p then f else g) âŠ† range f âˆª range g := by\n  by_cases h : p\n  Â· rw [if_pos h]\n    exact subset_union_left\n  Â· rw [if_neg h]\n    exact subset_union_right\n\n"}
{"name":"Set.range_ite_subset","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\np : Î± â†’ Prop\ninstâœ : DecidablePred p\nf g : Î± â†’ Î²\nâŠ¢ HasSubset.Subset (Set.range fun x => ite (p x) (f x) (g x)) (Union.union (Set.range f) (Set.range g))","decl":"theorem range_ite_subset {p : Î± â†’ Prop} [DecidablePred p] {f g : Î± â†’ Î²} :\n    (range fun x => if p x then f x else g x) âŠ† range f âˆª range g := by\n  rw [range_subset_iff]; intro x; by_cases h : p x\n  Â· simp only [if_pos h, mem_union, mem_range, exists_apply_eq_apply, true_or]\n  Â· simp [if_neg h, mem_union, mem_range_self]\n\n"}
{"name":"Set.preimage_range","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nâŠ¢ Eq (Set.preimage f (Set.range f)) Set.univ","decl":"@[simp]\ntheorem preimage_range (f : Î± â†’ Î²) : f â»Â¹' range f = univ :=\n  eq_univ_of_forall mem_range_self\n\n"}
{"name":"Set.range_unique","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nf : Î¹ â†’ Î±\nh : Unique Î¹\nâŠ¢ Eq (Set.range f) (Singleton.singleton (f Inhabited.default))","decl":"/-- The range of a function from a `Unique` type contains just the\nfunction applied to its single value. -/\ntheorem range_unique [h : Unique Î¹] : range f = {f default} := by\n  ext x\n  rw [mem_range]\n  constructor\n  Â· rintro âŸ¨i, hiâŸ©\n    rw [h.uniq i] at hi\n    exact hi â–¸ mem_singleton _\n  Â· exact fun h => âŸ¨default, h.symmâŸ©\n\n"}
{"name":"Set.range_diff_image_subset","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\nâŠ¢ HasSubset.Subset (SDiff.sdiff (Set.range f) (Set.image f s)) (Set.image f (HasCompl.compl s))","decl":"theorem range_diff_image_subset (f : Î± â†’ Î²) (s : Set Î±) : range f \\ f '' s âŠ† f '' sá¶œ :=\n  fun _ âŸ¨âŸ¨x, hâ‚âŸ©, hâ‚‚âŸ© => âŸ¨x, fun h => hâ‚‚ âŸ¨x, h, hâ‚âŸ©, hâ‚âŸ©\n\n"}
{"name":"Set.range_inclusion","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns t : Set Î±\nh : HasSubset.Subset s t\nâŠ¢ Eq (Set.range (Set.inclusion h)) (setOf fun x => Membership.mem s â†‘x)","decl":"@[simp]\ntheorem range_inclusion (h : s âŠ† t) : range (inclusion h) = { x : t | (x : Î±) âˆˆ s } := by\n  ext âŸ¨x, hxâŸ©\n  simp\n\n-- When `f` is injective, see also `Equiv.ofInjective`.\n"}
{"name":"Set.leftInverse_rangeSplitting","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nâŠ¢ Function.LeftInverse (Set.rangeFactorization f) (Set.rangeSplitting f)","decl":"theorem leftInverse_rangeSplitting (f : Î± â†’ Î²) :\n    LeftInverse (rangeFactorization f) (rangeSplitting f) := fun x => by\n  ext\n  simp only [rangeFactorization_coe]\n  apply apply_rangeSplitting\n\n"}
{"name":"Set.rangeSplitting_injective","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nâŠ¢ Function.Injective (Set.rangeSplitting f)","decl":"theorem rangeSplitting_injective (f : Î± â†’ Î²) : Injective (rangeSplitting f) :=\n  (leftInverse_rangeSplitting f).injective\n\n"}
{"name":"Set.rightInverse_rangeSplitting","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nh : Function.Injective f\nâŠ¢ Function.RightInverse (Set.rangeFactorization f) (Set.rangeSplitting f)","decl":"theorem rightInverse_rangeSplitting {f : Î± â†’ Î²} (h : Injective f) :\n    RightInverse (rangeFactorization f) (rangeSplitting f) :=\n  (leftInverse_rangeSplitting f).rightInverse_of_injective fun _ _ hxy =>\n    h <| Subtype.ext_iff.1 hxy\n\n"}
{"name":"Set.preimage_rangeSplitting","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Injective f\nâŠ¢ Eq (Set.preimage (Set.rangeSplitting f)) (Set.image (Set.rangeFactorization f))","decl":"theorem preimage_rangeSplitting {f : Î± â†’ Î²} (hf : Injective f) :\n    preimage (rangeSplitting f) = image (rangeFactorization f) :=\n  (image_eq_preimage_of_inverse (rightInverse_rangeSplitting hf)\n      (leftInverse_rangeSplitting f)).symm\n\n"}
{"name":"Set.isCompl_range_some_none","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_5\nâŠ¢ IsCompl (Set.range Option.some) (Singleton.singleton Option.none)","decl":"theorem isCompl_range_some_none (Î± : Type*) : IsCompl (range (some : Î± â†’ Option Î±)) {none} :=\n  IsCompl.of_le (fun _ âŸ¨âŸ¨_, haâŸ©, (hn : _ = none)âŸ© => Option.some_ne_none _ (ha.trans hn))\n    fun x _ => Option.casesOn x (Or.inr rfl) fun _ => Or.inl <| mem_range_self _\n\n"}
{"name":"Set.compl_range_some","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_5\nâŠ¢ Eq (HasCompl.compl (Set.range Option.some)) (Singleton.singleton Option.none)","decl":"@[simp]\ntheorem compl_range_some (Î± : Type*) : (range (some : Î± â†’ Option Î±))á¶œ = {none} :=\n  (isCompl_range_some_none Î±).compl_eq\n\n"}
{"name":"Set.range_some_inter_none","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_5\nâŠ¢ Eq (Inter.inter (Set.range Option.some) (Singleton.singleton Option.none)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem range_some_inter_none (Î± : Type*) : range (some : Î± â†’ Option Î±) âˆ© {none} = âˆ… :=\n  (isCompl_range_some_none Î±).inf_eq_bot\n\n-- Porting note:\n-- @[simp] `simp` can prove this\n"}
{"name":"Set.range_some_union_none","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_5\nâŠ¢ Eq (Union.union (Set.range Option.some) (Singleton.singleton Option.none)) Set.univ","decl":"theorem range_some_union_none (Î± : Type*) : range (some : Î± â†’ Option Î±) âˆª {none} = univ :=\n  (isCompl_range_some_none Î±).sup_eq_top\n\n"}
{"name":"Set.insert_none_range_some","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_5\nâŠ¢ Eq (Insert.insert Option.none (Set.range Option.some)) Set.univ","decl":"@[simp]\ntheorem insert_none_range_some (Î± : Type*) : insert none (range (some : Î± â†’ Option Î±)) = univ :=\n  (isCompl_range_some_none Î±).symm.sup_eq_top\n\n"}
{"name":"Set.image_of_range_union_range_eq_univ","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_5\nÎ² : Type u_6\nÎ³ : Type u_7\nÎ³' : Type u_8\nÎ´ : Type u_9\nÎ´' : Type u_10\nh : Î² â†’ Î±\nf : Î³ â†’ Î²\nfâ‚ : Î³' â†’ Î±\nfâ‚‚ : Î³ â†’ Î³'\ng : Î´ â†’ Î²\ngâ‚ : Î´' â†’ Î±\ngâ‚‚ : Î´ â†’ Î´'\nhf : Eq (Function.comp h f) (Function.comp fâ‚ fâ‚‚)\nhg : Eq (Function.comp h g) (Function.comp gâ‚ gâ‚‚)\nhfg : Eq (Union.union (Set.range f) (Set.range g)) Set.univ\ns : Set Î²\nâŠ¢ Eq (Set.image h s) (Union.union (Set.image fâ‚ (Set.image fâ‚‚ (Set.preimage f s))) (Set.image gâ‚ (Set.image gâ‚‚ (Set.preimage g s))))","decl":"lemma image_of_range_union_range_eq_univ {Î± Î² Î³ Î³' Î´ Î´' : Type*}\n    {h : Î² â†’ Î±} {f : Î³ â†’ Î²} {fâ‚ : Î³' â†’ Î±} {fâ‚‚ : Î³ â†’ Î³'} {g : Î´ â†’ Î²} {gâ‚ : Î´' â†’ Î±} {gâ‚‚ : Î´ â†’ Î´'}\n    (hf : h âˆ˜ f = fâ‚ âˆ˜ fâ‚‚) (hg : h âˆ˜ g = gâ‚ âˆ˜ gâ‚‚) (hfg : range f âˆª range g = univ) (s : Set Î²) :\n    h '' s = fâ‚ '' (fâ‚‚ '' (f â»Â¹' s)) âˆª gâ‚ '' (gâ‚‚ '' (g â»Â¹' s)) := by\n  rw [â† image_comp, â† image_comp, â† hf, â† hg, image_comp, image_comp, image_preimage_eq_inter_range,\n    image_preimage_eq_inter_range, â† image_union, â† inter_union_distrib_left, hfg, inter_univ]\n\n"}
{"name":"Set.Subsingleton.image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\nhs : s.Subsingleton\nf : Î± â†’ Î²\nâŠ¢ (Set.image f s).Subsingleton","decl":"/-- The image of a subsingleton is a subsingleton. -/\ntheorem Subsingleton.image (hs : s.Subsingleton) (f : Î± â†’ Î²) : (f '' s).Subsingleton :=\n  fun _ âŸ¨_, hx, HxâŸ© _ âŸ¨_, hy, HyâŸ© => Hx â–¸ Hy â–¸ congr_arg f (hs hx hy)\n\n"}
{"name":"Set.Subsingleton.preimage","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î²\nhs : s.Subsingleton\nhf : Function.Injective f\nâŠ¢ (Set.preimage f s).Subsingleton","decl":"/-- The preimage of a subsingleton under an injective map is a subsingleton. -/\ntheorem Subsingleton.preimage {s : Set Î²} (hs : s.Subsingleton)\n    (hf : Function.Injective f) : (f â»Â¹' s).Subsingleton := fun _ ha _ hb => hf <| hs ha hb\n\n"}
{"name":"Set.subsingleton_of_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Injective f\ns : Set Î±\nhs : (Set.image f s).Subsingleton\nâŠ¢ s.Subsingleton","decl":"/-- If the image of a set under an injective map is a subsingleton, the set is a subsingleton. -/\ntheorem subsingleton_of_image (hf : Function.Injective f) (s : Set Î±)\n    (hs : (f '' s).Subsingleton) : s.Subsingleton :=\n  (hs.preimage hf).anti <| subset_preimage_image _ _\n\n"}
{"name":"Set.subsingleton_of_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Surjective f\ns : Set Î²\nhs : (Set.preimage f s).Subsingleton\nâŠ¢ s.Subsingleton","decl":"/-- If the preimage of a set under a surjective map is a subsingleton,\nthe set is a subsingleton. -/\ntheorem subsingleton_of_preimage (hf : Function.Surjective f) (s : Set Î²)\n    (hs : (f â»Â¹' s).Subsingleton) : s.Subsingleton := fun fx hx fy hy => by\n  rcases hf fx, hf fy with âŸ¨âŸ¨x, rflâŸ©, âŸ¨y, rflâŸ©âŸ©\n  exact congr_arg f (hs hx hy)\n\n"}
{"name":"Set.subsingleton_range","module":"Mathlib.Data.Set.Image","initialProofState":"Î² : Type u_2\nÎ± : Sort u_5\ninstâœ : Subsingleton Î±\nf : Î± â†’ Î²\nâŠ¢ (Set.range f).Subsingleton","decl":"theorem subsingleton_range {Î± : Sort*} [Subsingleton Î±] (f : Î± â†’ Î²) : (range f).Subsingleton :=\n  forall_mem_range.2 fun x => forall_mem_range.2 fun y => congr_arg f (Subsingleton.elim x y)\n\n"}
{"name":"Set.Nontrivial.preimage","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î²\nhs : s.Nontrivial\nhf : Function.Surjective f\nâŠ¢ (Set.preimage f s).Nontrivial","decl":"/-- The preimage of a nontrivial set under a surjective map is nontrivial. -/\ntheorem Nontrivial.preimage {s : Set Î²} (hs : s.Nontrivial)\n    (hf : Function.Surjective f) : (f â»Â¹' s).Nontrivial := by\n  rcases hs with âŸ¨fx, hx, fy, hy, hxyâŸ©\n  rcases hf fx, hf fy with âŸ¨âŸ¨x, rflâŸ©, âŸ¨y, rflâŸ©âŸ©\n  exact âŸ¨x, hx, y, hy, mt (congr_arg f) hxyâŸ©\n\n"}
{"name":"Set.Nontrivial.image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\nf : Î± â†’ Î²\nhs : s.Nontrivial\nhf : Function.Injective f\nâŠ¢ (Set.image f s).Nontrivial","decl":"/-- The image of a nontrivial set under an injective map is nontrivial. -/\ntheorem Nontrivial.image (hs : s.Nontrivial) (hf : Function.Injective f) :\n    (f '' s).Nontrivial :=\n  let âŸ¨x, hx, y, hy, hxyâŸ© := hs\n  âŸ¨f x, mem_image_of_mem f hx, f y, mem_image_of_mem f hy, hf.ne hxyâŸ©\n\n"}
{"name":"Set.Nontrivial.image_of_injOn","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\nf : Î± â†’ Î²\nhs : s.Nontrivial\nhf : Set.InjOn f s\nâŠ¢ (Set.image f s).Nontrivial","decl":"theorem Nontrivial.image_of_injOn (hs : s.Nontrivial) (hf : s.InjOn f) :\n    (f '' s).Nontrivial := by\n  obtain âŸ¨x, hx, y, hy, hxyâŸ© := hs\n  exact âŸ¨f x, mem_image_of_mem _ hx, f y, mem_image_of_mem _ hy, (hxy <| hf hx hy Â·)âŸ©\n\n"}
{"name":"Set.nontrivial_of_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\nhs : (Set.image f s).Nontrivial\nâŠ¢ s.Nontrivial","decl":"/-- If the image of a set is nontrivial, the set is nontrivial. -/\ntheorem nontrivial_of_image (f : Î± â†’ Î²) (s : Set Î±) (hs : (f '' s).Nontrivial) : s.Nontrivial :=\n  let âŸ¨_, âŸ¨x, hx, rflâŸ©, _, âŸ¨y, hy, rflâŸ©, hxyâŸ© := hs\n  âŸ¨x, hx, y, hy, mt (congr_arg f) hxyâŸ©\n\n"}
{"name":"Set.image_nontrivial","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\nf : Î± â†’ Î²\nhf : Function.Injective f\nâŠ¢ Iff (Set.image f s).Nontrivial s.Nontrivial","decl":"@[simp]\ntheorem image_nontrivial (hf : f.Injective) : (f '' s).Nontrivial â†” s.Nontrivial :=\n  âŸ¨nontrivial_of_image f s, fun h â†¦ h.image hfâŸ©\n\n"}
{"name":"Set.InjOn.image_nontrivial_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\nf : Î± â†’ Î²\nhf : Set.InjOn f s\nâŠ¢ Iff (Set.image f s).Nontrivial s.Nontrivial","decl":"@[simp]\ntheorem InjOn.image_nontrivial_iff (hf : s.InjOn f) :\n    (f '' s).Nontrivial â†” s.Nontrivial :=\n  âŸ¨nontrivial_of_image f s, fun h â†¦ h.image_of_injOn hfâŸ©\n\n"}
{"name":"Set.nontrivial_of_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Injective f\ns : Set Î²\nhs : (Set.preimage f s).Nontrivial\nâŠ¢ s.Nontrivial","decl":"/-- If the preimage of a set under an injective map is nontrivial, the set is nontrivial. -/\ntheorem nontrivial_of_preimage (hf : Function.Injective f) (s : Set Î²)\n    (hs : (f â»Â¹' s).Nontrivial) : s.Nontrivial :=\n  (hs.image hf).mono <| image_preimage_subset _ _\n\n"}
{"name":"Function.Surjective.preimage_injective","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Surjective f\nâŠ¢ Function.Injective (Set.preimage f)","decl":"theorem Surjective.preimage_injective (hf : Surjective f) : Injective (preimage f) := fun _ _ =>\n  (preimage_eq_preimage hf).1\n\n"}
{"name":"Function.Injective.preimage_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Injective f\ns : Set Î±\nâŠ¢ Eq (Set.preimage f (Set.image f s)) s","decl":"theorem Injective.preimage_image (hf : Injective f) (s : Set Î±) : f â»Â¹' (f '' s) = s :=\n  preimage_image_eq s hf\n\n"}
{"name":"Function.Injective.preimage_surjective","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Injective f\nâŠ¢ Function.Surjective (Set.preimage f)","decl":"theorem Injective.preimage_surjective (hf : Injective f) : Surjective (preimage f) := by\n  intro s\n  use f '' s\n  rw [hf.preimage_image]\n\n"}
{"name":"Function.Injective.subsingleton_image_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Injective f\ns : Set Î±\nâŠ¢ Iff (Set.image f s).Subsingleton s.Subsingleton","decl":"theorem Injective.subsingleton_image_iff (hf : Injective f) {s : Set Î±} :\n    (f '' s).Subsingleton â†” s.Subsingleton :=\n  âŸ¨subsingleton_of_image hf s, fun h => h.image fâŸ©\n\n"}
{"name":"Function.Surjective.image_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Surjective f\ns : Set Î²\nâŠ¢ Eq (Set.image f (Set.preimage f s)) s","decl":"theorem Surjective.image_preimage (hf : Surjective f) (s : Set Î²) : f '' (f â»Â¹' s) = s :=\n  image_preimage_eq s hf\n\n"}
{"name":"Function.Surjective.image_surjective","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Surjective f\nâŠ¢ Function.Surjective (Set.image f)","decl":"theorem Surjective.image_surjective (hf : Surjective f) : Surjective (image f) := by\n  intro s\n  use f â»Â¹' s\n  rw [hf.image_preimage]\n\n"}
{"name":"Function.Surjective.nonempty_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Surjective f\ns : Set Î²\nâŠ¢ Iff (Set.preimage f s).Nonempty s.Nonempty","decl":"@[simp]\ntheorem Surjective.nonempty_preimage (hf : Surjective f) {s : Set Î²} :\n    (f â»Â¹' s).Nonempty â†” s.Nonempty := by rw [â† image_nonempty, hf.image_preimage]\n\n"}
{"name":"Function.Injective.image_injective","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Injective f\nâŠ¢ Function.Injective (Set.image f)","decl":"theorem Injective.image_injective (hf : Injective f) : Injective (image f) := by\n  intro s t h\n  rw [â† preimage_image_eq s hf, â† preimage_image_eq t hf, h]\n\n"}
{"name":"Function.Injective.image_strictMono","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ninj : Function.Injective f\nâŠ¢ StrictMono (Set.image f)","decl":"lemma Injective.image_strictMono (inj : Function.Injective f) : StrictMono (image f) :=\n  monotone_image.strictMono_of_injective inj.image_injective\n\n"}
{"name":"Function.Surjective.preimage_subset_preimage_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns t : Set Î²\nhf : Function.Surjective f\nâŠ¢ Iff (HasSubset.Subset (Set.preimage f s) (Set.preimage f t)) (HasSubset.Subset s t)","decl":"theorem Surjective.preimage_subset_preimage_iff {s t : Set Î²} (hf : Surjective f) :\n    f â»Â¹' s âŠ† f â»Â¹' t â†” s âŠ† t := by\n  apply Set.preimage_subset_preimage_iff\n  rw [hf.range_eq]\n  apply subset_univ\n\n"}
{"name":"Function.Surjective.range_comp","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_3\nÎ¹' : Sort u_4\nf : Î¹ â†’ Î¹'\nhf : Function.Surjective f\ng : Î¹' â†’ Î±\nâŠ¢ Eq (Set.range (Function.comp g f)) (Set.range g)","decl":"theorem Surjective.range_comp {Î¹' : Sort*} {f : Î¹ â†’ Î¹'} (hf : Surjective f) (g : Î¹' â†’ Î±) :\n    range (g âˆ˜ f) = range g :=\n  ext fun y => (@Surjective.exists _ _ _ hf fun x => g x = y).symm\n\n"}
{"name":"Function.Injective.mem_range_iff_existsUnique","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Injective f\nb : Î²\nâŠ¢ Iff (Membership.mem (Set.range f) b) (ExistsUnique fun a => Eq (f a) b)","decl":"theorem Injective.mem_range_iff_existsUnique (hf : Injective f) {b : Î²} :\n    b âˆˆ range f â†” âˆƒ! a, f a = b :=\n  âŸ¨fun âŸ¨a, hâŸ© => âŸ¨a, h, fun _ ha => hf (ha.trans h.symm)âŸ©, ExistsUnique.existsâŸ©\n\n"}
{"name":"Function.Injective.existsUnique_of_mem_range","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Injective f\nb : Î²\naâœ : Membership.mem (Set.range f) b\nâŠ¢ ExistsUnique fun a => Eq (f a) b","decl":"alias âŸ¨Injective.existsUnique_of_mem_range, _âŸ© := Injective.mem_range_iff_existsUnique\n\n"}
{"name":"Function.Injective.mem_range_iff_exists_unique","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Injective f\nb : Î²\nâŠ¢ Iff (Membership.mem (Set.range f) b) (ExistsUnique fun a => Eq (f a) b)","decl":"@[deprecated (since := \"2024-09-25\")]\nalias Injective.mem_range_iff_exists_unique := Injective.mem_range_iff_existsUnique\n\n"}
{"name":"Function.Injective.exists_unique_of_mem_range","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Injective f\nb : Î²\naâœ : Membership.mem (Set.range f) b\nâŠ¢ ExistsUnique fun a => Eq (f a) b","decl":"@[deprecated (since := \"2024-09-25\")]\nalias Injective.exists_unique_of_mem_range := Injective.existsUnique_of_mem_range\n\n"}
{"name":"Function.Injective.compl_image_eq","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Injective f\ns : Set Î±\nâŠ¢ Eq (HasCompl.compl (Set.image f s)) (Union.union (Set.image f (HasCompl.compl s)) (HasCompl.compl (Set.range f)))","decl":"theorem Injective.compl_image_eq (hf : Injective f) (s : Set Î±) :\n    (f '' s)á¶œ = f '' sá¶œ âˆª (range f)á¶œ := by\n  ext y\n  rcases em (y âˆˆ range f) with (âŸ¨x, rflâŸ© | hx)\n  Â· simp [hf.eq_iff]\n  Â· rw [mem_range, not_exists] at hx\n    simp [hx]\n\n"}
{"name":"Function.LeftInverse.image_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ng : Î² â†’ Î±\nh : Function.LeftInverse g f\ns : Set Î±\nâŠ¢ Eq (Set.image g (Set.image f s)) s","decl":"theorem LeftInverse.image_image {g : Î² â†’ Î±} (h : LeftInverse g f) (s : Set Î±) :\n    g '' (f '' s) = s := by rw [â† image_comp, h.comp_eq_id, image_id]\n\n"}
{"name":"Function.LeftInverse.preimage_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ng : Î² â†’ Î±\nh : Function.LeftInverse g f\ns : Set Î±\nâŠ¢ Eq (Set.preimage f (Set.preimage g s)) s","decl":"theorem LeftInverse.preimage_preimage {g : Î² â†’ Î±} (h : LeftInverse g f) (s : Set Î±) :\n    f â»Â¹' (g â»Â¹' s) = s := by rw [â† preimage_comp, h.comp_eq_id, preimage_id]\n\n"}
{"name":"Function.Involutive.preimage","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nf : Î± â†’ Î±\nhf : Function.Involutive f\nâŠ¢ Function.Involutive (Set.preimage f)","decl":"protected theorem Involutive.preimage {f : Î± â†’ Î±} (hf : Involutive f) : Involutive (preimage f) :=\n  hf.rightInverse.preimage_preimage\n\n"}
{"name":"EquivLike.range_comp","module":"Mathlib.Data.Set.Image","initialProofState":"Î¹ : Sort u_1\nÎ¹' : Sort u_2\nE : Type u_3\ninstâœ : EquivLike E Î¹ Î¹'\nÎ± : Type u_4\nf : Î¹' â†’ Î±\ne : E\nâŠ¢ Eq (Set.range (Function.comp f â‡‘e)) (Set.range f)","decl":"@[simp] lemma range_comp {Î± : Type*} (f : Î¹' â†’ Î±) (e : E) : range (f âˆ˜ e) = range f :=\n  (EquivLike.surjective _).range_comp _\n\n"}
{"name":"Subtype.coe_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\np : Î± â†’ Prop\ns : Set (Subtype p)\nâŠ¢ Eq (Set.image Subtype.val s) (setOf fun x => Exists fun h => Membership.mem s âŸ¨x, hâŸ©)","decl":"theorem coe_image {p : Î± â†’ Prop} {s : Set (Subtype p)} :\n    (â†‘) '' s = { x | âˆƒ h : p x, (âŸ¨x, hâŸ© : Subtype p) âˆˆ s } :=\n  Set.ext fun a =>\n    âŸ¨fun âŸ¨âŸ¨_, ha'âŸ©, in_s, h_eqâŸ© => h_eq â–¸ âŸ¨ha', in_sâŸ©, fun âŸ¨ha, in_sâŸ© => âŸ¨âŸ¨a, haâŸ©, in_s, rflâŸ©âŸ©\n\n"}
{"name":"Subtype.coe_image_of_subset","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns t : Set Î±\nh : HasSubset.Subset t s\nâŠ¢ Eq (Set.image Subtype.val (setOf fun x => Membership.mem t â†‘x)) t","decl":"@[simp]\ntheorem coe_image_of_subset {s t : Set Î±} (h : t âŠ† s) : (â†‘) '' { x : â†¥s | â†‘x âˆˆ t } = t := by\n  ext x\n  rw [mem_image]\n  exact âŸ¨fun âŸ¨_, hx', hxâŸ© => hx â–¸ hx', fun hx => âŸ¨âŸ¨x, h hxâŸ©, hx, rflâŸ©âŸ©\n\n"}
{"name":"Subtype.range_coe","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns : Set Î±\nâŠ¢ Eq (Set.range Subtype.val) s","decl":"theorem range_coe {s : Set Î±} : range ((â†‘) : s â†’ Î±) = s := by\n  rw [â† image_univ]\n  simp [-image_univ, coe_image]\n\n"}
{"name":"Subtype.range_val","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns : Set Î±\nâŠ¢ Eq (Set.range Subtype.val) s","decl":"/-- A variant of `range_coe`. Try to use `range_coe` if possible.\n  This version is useful when defining a new type that is defined as the subtype of something.\n  In that case, the coercion doesn't fire anymore. -/\ntheorem range_val {s : Set Î±} : range (Subtype.val : s â†’ Î±) = s :=\n  range_coe\n\n"}
{"name":"Subtype.range_coe_subtype","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\np : Î± â†’ Prop\nâŠ¢ Eq (Set.range Subtype.val) (setOf fun x => p x)","decl":"/-- We make this the simp lemma instead of `range_coe`. The reason is that if we write\n  for `s : Set Î±` the function `(â†‘) : s â†’ Î±`, then the inferred implicit arguments of `(â†‘)` are\n  `â†‘Î± (fun x â†¦ x âˆˆ s)`. -/\n@[simp]\ntheorem range_coe_subtype {p : Î± â†’ Prop} : range ((â†‘) : Subtype p â†’ Î±) = { x | p x } :=\n  range_coe\n\n"}
{"name":"Subtype.coe_preimage_self","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns : Set Î±\nâŠ¢ Eq (Set.preimage Subtype.val s) Set.univ","decl":"@[simp]\ntheorem coe_preimage_self (s : Set Î±) : ((â†‘) : s â†’ Î±) â»Â¹' s = univ := by\n  rw [â† preimage_range, range_coe]\n\n"}
{"name":"Subtype.range_val_subtype","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\np : Î± â†’ Prop\nâŠ¢ Eq (Set.range Subtype.val) (setOf fun x => p x)","decl":"theorem range_val_subtype {p : Î± â†’ Prop} : range (Subtype.val : Subtype p â†’ Î±) = { x | p x } :=\n  range_coe\n\n"}
{"name":"Subtype.coe_image_subset","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns : Set Î±\nt : Set â†‘s\nâŠ¢ HasSubset.Subset (Set.image Subtype.val t) s","decl":"theorem coe_image_subset (s : Set Î±) (t : Set s) : ((â†‘) : s â†’ Î±) '' t âŠ† s :=\n  fun x âŸ¨y, _, yvaleqâŸ© => by\n  rw [â† yvaleq]; exact y.property\n\n"}
{"name":"Subtype.coe_image_univ","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns : Set Î±\nâŠ¢ Eq (Set.image Subtype.val Set.univ) s","decl":"theorem coe_image_univ (s : Set Î±) : ((â†‘) : s â†’ Î±) '' Set.univ = s :=\n  image_univ.trans range_coe\n\n"}
{"name":"Subtype.image_preimage_coe","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns t : Set Î±\nâŠ¢ Eq (Set.image Subtype.val (Set.preimage Subtype.val t)) (Inter.inter s t)","decl":"@[simp]\ntheorem image_preimage_coe (s t : Set Î±) : ((â†‘) : s â†’ Î±) '' (((â†‘) : s â†’ Î±) â»Â¹' t) = s âˆ© t :=\n  image_preimage_eq_range_inter.trans <| congr_arg (Â· âˆ© t) range_coe\n\n"}
{"name":"Subtype.image_preimage_val","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns t : Set Î±\nâŠ¢ Eq (Set.image Subtype.val (Set.preimage Subtype.val t)) (Inter.inter s t)","decl":"theorem image_preimage_val (s t : Set Î±) : (Subtype.val : s â†’ Î±) '' (Subtype.val â»Â¹' t) = s âˆ© t :=\n  image_preimage_coe s t\n\n"}
{"name":"Subtype.preimage_coe_eq_preimage_coe_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns t u : Set Î±\nâŠ¢ Iff (Eq (Set.preimage Subtype.val t) (Set.preimage Subtype.val u)) (Eq (Inter.inter s t) (Inter.inter s u))","decl":"theorem preimage_coe_eq_preimage_coe_iff {s t u : Set Î±} :\n    ((â†‘) : s â†’ Î±) â»Â¹' t = ((â†‘) : s â†’ Î±) â»Â¹' u â†” s âˆ© t = s âˆ© u := by\n  rw [â† image_preimage_coe, â† image_preimage_coe, coe_injective.image_injective.eq_iff]\n\n"}
{"name":"Subtype.preimage_coe_self_inter","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns t : Set Î±\nâŠ¢ Eq (Set.preimage Subtype.val (Inter.inter s t)) (Set.preimage Subtype.val t)","decl":"theorem preimage_coe_self_inter (s t : Set Î±) :\n    ((â†‘) : s â†’ Î±) â»Â¹' (s âˆ© t) = ((â†‘) : s â†’ Î±) â»Â¹' t := by\n  rw [preimage_coe_eq_preimage_coe_iff, â† inter_assoc, inter_self]\n\n-- Porting note:\n-- @[simp] `simp` can prove this\n"}
{"name":"Subtype.preimage_coe_inter_self","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns t : Set Î±\nâŠ¢ Eq (Set.preimage Subtype.val (Inter.inter t s)) (Set.preimage Subtype.val t)","decl":"theorem preimage_coe_inter_self (s t : Set Î±) :\n    ((â†‘) : s â†’ Î±) â»Â¹' (t âˆ© s) = ((â†‘) : s â†’ Î±) â»Â¹' t := by\n  rw [inter_comm, preimage_coe_self_inter]\n\n"}
{"name":"Subtype.preimage_val_eq_preimage_val_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns t u : Set Î±\nâŠ¢ Iff (Eq (Set.preimage Subtype.val t) (Set.preimage Subtype.val u)) (Eq (Inter.inter s t) (Inter.inter s u))","decl":"theorem preimage_val_eq_preimage_val_iff (s t u : Set Î±) :\n    (Subtype.val : s â†’ Î±) â»Â¹' t = Subtype.val â»Â¹' u â†” s âˆ© t = s âˆ© u :=\n  preimage_coe_eq_preimage_coe_iff\n\n"}
{"name":"Subtype.preimage_val_subset_preimage_val_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns t u : Set Î±\nâŠ¢ Iff (HasSubset.Subset (Set.preimage Subtype.val t) (Set.preimage Subtype.val u)) (HasSubset.Subset (Inter.inter s t) (Inter.inter s u))","decl":"lemma preimage_val_subset_preimage_val_iff (s t u : Set Î±) :\n    (Subtype.val â»Â¹' t : Set s) âŠ† Subtype.val â»Â¹' u â†” s âˆ© t âŠ† s âˆ© u := by\n  constructor\n  Â· rw [â† image_preimage_coe, â† image_preimage_coe]\n    exact image_subset _\n  Â· intro h x a\n    exact (h âŸ¨x.2, aâŸ©).2\n\n"}
{"name":"Subtype.exists_set_subtype","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nt : Set Î±\np : Set Î± â†’ Prop\nâŠ¢ Iff (Exists fun s => p (Set.image Subtype.val s)) (Exists fun s => And (HasSubset.Subset s t) (p s))","decl":"theorem exists_set_subtype {t : Set Î±} (p : Set Î± â†’ Prop) :\n    (âˆƒ s : Set t, p (((â†‘) : t â†’ Î±) '' s)) â†” âˆƒ s : Set Î±, s âŠ† t âˆ§ p s := by\n  rw [â† exists_subset_range_and_iff, range_coe]\n\n"}
{"name":"Subtype.forall_set_subtype","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nt : Set Î±\np : Set Î± â†’ Prop\nâŠ¢ Iff (âˆ€ (s : Set â†‘t), p (Set.image Subtype.val s)) (âˆ€ (s : Set Î±), HasSubset.Subset s t â†’ p s)","decl":"theorem forall_set_subtype {t : Set Î±} (p : Set Î± â†’ Prop) :\n    (âˆ€ s : Set t, p (((â†‘) : t â†’ Î±) '' s)) â†” âˆ€ s : Set Î±, s âŠ† t â†’ p s := by\n  rw [â† forall_subset_range_iff, range_coe]\n\n"}
{"name":"Subtype.preimage_coe_nonempty","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns t : Set Î±\nâŠ¢ Iff (Set.preimage Subtype.val t).Nonempty (Inter.inter s t).Nonempty","decl":"theorem preimage_coe_nonempty {s t : Set Î±} :\n    (((â†‘) : s â†’ Î±) â»Â¹' t).Nonempty â†” (s âˆ© t).Nonempty := by\n  rw [â† image_preimage_coe, image_nonempty]\n\n"}
{"name":"Subtype.preimage_coe_eq_empty","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns t : Set Î±\nâŠ¢ Iff (Eq (Set.preimage Subtype.val t) EmptyCollection.emptyCollection) (Eq (Inter.inter s t) EmptyCollection.emptyCollection)","decl":"theorem preimage_coe_eq_empty {s t : Set Î±} : ((â†‘) : s â†’ Î±) â»Â¹' t = âˆ… â†” s âˆ© t = âˆ… := by\n  simp [â† not_nonempty_iff_eq_empty, preimage_coe_nonempty]\n\n-- Porting note:\n-- @[simp] `simp` can prove this\n"}
{"name":"Subtype.preimage_coe_compl","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns : Set Î±\nâŠ¢ Eq (Set.preimage Subtype.val (HasCompl.compl s)) EmptyCollection.emptyCollection","decl":"theorem preimage_coe_compl (s : Set Î±) : ((â†‘) : s â†’ Î±) â»Â¹' sá¶œ = âˆ… :=\n  preimage_coe_eq_empty.2 (inter_compl_self s)\n\n"}
{"name":"Subtype.preimage_coe_compl'","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\ns : Set Î±\nâŠ¢ Eq (Set.preimage (fun x => â†‘x) s) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem preimage_coe_compl' (s : Set Î±) :\n    (fun x : (sá¶œ : Set Î±) => (x : Î±)) â»Â¹' s = âˆ… :=\n  preimage_coe_eq_empty.2 (compl_inter_self s)\n\n"}
{"name":"Option.injective_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Option Î± â†’ Î²\nâŠ¢ Iff (Function.Injective f) (And (Function.Injective (Function.comp f Option.some)) (Not (Membership.mem (Set.range (Function.comp f Option.some)) (f Option.none))))","decl":"theorem injective_iff {Î± Î²} {f : Option Î± â†’ Î²} :\n    Injective f â†” Injective (f âˆ˜ some) âˆ§ f none âˆ‰ range (f âˆ˜ some) := by\n  simp only [mem_range, not_exists, (Â· âˆ˜ Â·)]\n  refine\n    âŸ¨fun hf => âŸ¨hf.comp (Option.some_injective _), fun x => hf.ne <| Option.some_ne_none _âŸ©, ?_âŸ©\n  rintro âŸ¨h_some, h_noneâŸ© (_ | a) (_ | b) hab\n  exacts [rfl, (h_none _ hab.symm).elim, (h_none _ hab).elim, congr_arg some (h_some hab)]\n\n"}
{"name":"Option.range_eq","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Option Î± â†’ Î²\nâŠ¢ Eq (Set.range f) (Insert.insert (f Option.none) (Set.range (Function.comp f Option.some)))","decl":"theorem range_eq {Î± Î²} (f : Option Î± â†’ Î²) : range f = insert (f none) (range (f âˆ˜ some)) :=\n  Set.ext fun _ => Option.exists.trans <| eq_comm.or Iff.rfl\n\n"}
{"name":"WithBot.range_eq","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : WithBot Î± â†’ Î²\nâŠ¢ Eq (Set.range f) (Insert.insert (f Bot.bot) (Set.range (Function.comp f WithBot.some)))","decl":"theorem WithBot.range_eq {Î± Î²} (f : WithBot Î± â†’ Î²) :\n    range f = insert (f âŠ¥) (range (f âˆ˜ WithBot.some : Î± â†’ Î²)) :=\n  Option.range_eq f\n\n"}
{"name":"WithTop.range_eq","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : WithTop Î± â†’ Î²\nâŠ¢ Eq (Set.range f) (Insert.insert (f Top.top) (Set.range (Function.comp f WithBot.some)))","decl":"theorem WithTop.range_eq {Î± Î²} (f : WithTop Î± â†’ Î²) :\n    range f = insert (f âŠ¤) (range (f âˆ˜ WithBot.some : Î± â†’ Î²)) :=\n  Option.range_eq f\n\n"}
{"name":"Set.preimage_injective","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nâŠ¢ Iff (Function.Injective (Set.preimage f)) (Function.Surjective f)","decl":"@[simp]\ntheorem preimage_injective : Injective (preimage f) â†” Surjective f := by\n  refine âŸ¨fun h y => ?_, Surjective.preimage_injectiveâŸ©\n  obtain âŸ¨x, hxâŸ© : (f â»Â¹' {y}).Nonempty := by\n    rw [h.nonempty_apply_iff preimage_empty]\n    apply singleton_nonempty\n  exact âŸ¨x, hxâŸ©\n\n"}
{"name":"Set.preimage_surjective","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nâŠ¢ Iff (Function.Surjective (Set.preimage f)) (Function.Injective f)","decl":"@[simp]\ntheorem preimage_surjective : Surjective (preimage f) â†” Injective f := by\n  refine âŸ¨fun h x x' hx => ?_, Injective.preimage_surjectiveâŸ©\n  rcases h {x} with âŸ¨s, hsâŸ©; have := mem_singleton x\n  rwa [â† hs, mem_preimage, hx, â† mem_preimage, hs, mem_singleton_iff, eq_comm] at this\n\n"}
{"name":"Set.image_surjective","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nâŠ¢ Iff (Function.Surjective (Set.image f)) (Function.Surjective f)","decl":"@[simp]\ntheorem image_surjective : Surjective (image f) â†” Surjective f := by\n  refine âŸ¨fun h y => ?_, Surjective.image_surjectiveâŸ©\n  rcases h {y} with âŸ¨s, hsâŸ©\n  have := mem_singleton y; rw [â† hs] at this; rcases this with âŸ¨x, _, hxâŸ©\n  exact âŸ¨x, hxâŸ©\n\n"}
{"name":"Set.image_injective","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nâŠ¢ Iff (Function.Injective (Set.image f)) (Function.Injective f)","decl":"@[simp]\ntheorem image_injective : Injective (image f) â†” Injective f := by\n  refine âŸ¨fun h x x' hx => ?_, Injective.image_injectiveâŸ©\n  rw [â† singleton_eq_singleton_iff]; apply h\n  rw [image_singleton, image_singleton, hx]\n\n"}
{"name":"Set.preimage_eq_iff_eq_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nhf : Function.Bijective f\ns : Set Î²\nt : Set Î±\nâŠ¢ Iff (Eq (Set.preimage f s) t) (Eq s (Set.image f t))","decl":"theorem preimage_eq_iff_eq_image {f : Î± â†’ Î²} (hf : Bijective f) {s t} :\n    f â»Â¹' s = t â†” s = f '' t := by rw [â† image_eq_image hf.1, hf.2.image_preimage]\n\n"}
{"name":"Set.eq_preimage_iff_image_eq","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nhf : Function.Bijective f\ns : Set Î±\nt : Set Î²\nâŠ¢ Iff (Eq s (Set.preimage f t)) (Eq (Set.image f s) t)","decl":"theorem eq_preimage_iff_image_eq {f : Î± â†’ Î²} (hf : Bijective f) {s t} :\n    s = f â»Â¹' t â†” f '' s = t := by rw [â† image_eq_image hf.1, hf.2.image_preimage]\n\n"}
{"name":"Disjoint.preimage","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns t : Set Î²\nh : Disjoint s t\nâŠ¢ Disjoint (Set.preimage f s) (Set.preimage f t)","decl":"theorem Disjoint.preimage (f : Î± â†’ Î²) {s t : Set Î²} (h : Disjoint s t) :\n    Disjoint (f â»Â¹' s) (f â»Â¹' t) :=\n  disjoint_iff_inf_le.mpr fun _ hx => h.le_bot hx\n\n"}
{"name":"Codisjoint.preimage","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns t : Set Î²\nh : Codisjoint s t\nâŠ¢ Codisjoint (Set.preimage f s) (Set.preimage f t)","decl":"lemma Codisjoint.preimage (f : Î± â†’ Î²) {s t : Set Î²} (h : Codisjoint s t) :\n    Codisjoint (f â»Â¹' s) (f â»Â¹' t) := by\n  simp only [codisjoint_iff_le_sup, Set.sup_eq_union, top_le_iff, â† Set.preimage_union] at h âŠ¢\n  rw [h]; rfl\n\n"}
{"name":"IsCompl.preimage","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns t : Set Î²\nh : IsCompl s t\nâŠ¢ IsCompl (Set.preimage f s) (Set.preimage f t)","decl":"lemma IsCompl.preimage (f : Î± â†’ Î²) {s t : Set Î²} (h : IsCompl s t) :\n    IsCompl (f â»Â¹' s) (f â»Â¹' t) :=\n  âŸ¨h.1.preimage f, h.2.preimage fâŸ©\n\n"}
{"name":"Set.disjoint_image_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Î² â†’ Î±\ng : Î³ â†’ Î±\ns : Set Î²\nt : Set Î³\nh : âˆ€ (b : Î²), Membership.mem s b â†’ âˆ€ (c : Î³), Membership.mem t c â†’ Ne (f b) (g c)\nâŠ¢ Disjoint (Set.image f s) (Set.image g t)","decl":"theorem disjoint_image_image {f : Î² â†’ Î±} {g : Î³ â†’ Î±} {s : Set Î²} {t : Set Î³}\n    (h : âˆ€ b âˆˆ s, âˆ€ c âˆˆ t, f b â‰  g c) : Disjoint (f '' s) (g '' t) :=\n  disjoint_iff_inf_le.mpr <| by rintro a âŸ¨âŸ¨b, hb, eqâŸ©, c, hc, rflâŸ©; exact h b hb c hc eq\n\n"}
{"name":"Set.disjoint_image_of_injective","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Injective f\ns t : Set Î±\nhd : Disjoint s t\nâŠ¢ Disjoint (Set.image f s) (Set.image f t)","decl":"theorem disjoint_image_of_injective (hf : Injective f) {s t : Set Î±} (hd : Disjoint s t) :\n    Disjoint (f '' s) (f '' t) :=\n  disjoint_image_image fun _ hx _ hy => hf.ne fun H => Set.disjoint_iff.1 hd âŸ¨hx, H.symm â–¸ hyâŸ©\n\n"}
{"name":"Disjoint.of_image","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns t : Set Î±\nh : Disjoint (Set.image f s) (Set.image f t)\nâŠ¢ Disjoint s t","decl":"theorem _root_.Disjoint.of_image (h : Disjoint (f '' s) (f '' t)) : Disjoint s t :=\n  disjoint_iff_inf_le.mpr fun _ hx =>\n    disjoint_left.1 h (mem_image_of_mem _ hx.1) (mem_image_of_mem _ hx.2)\n\n"}
{"name":"Set.disjoint_image_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns t : Set Î±\nhf : Function.Injective f\nâŠ¢ Iff (Disjoint (Set.image f s) (Set.image f t)) (Disjoint s t)","decl":"@[simp]\ntheorem disjoint_image_iff (hf : Injective f) : Disjoint (f '' s) (f '' t) â†” Disjoint s t :=\n  âŸ¨Disjoint.of_image, disjoint_image_of_injective hfâŸ©\n\n"}
{"name":"Disjoint.of_preimage","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Surjective f\ns t : Set Î²\nh : Disjoint (Set.preimage f s) (Set.preimage f t)\nâŠ¢ Disjoint s t","decl":"theorem _root_.Disjoint.of_preimage (hf : Surjective f) {s t : Set Î²}\n    (h : Disjoint (f â»Â¹' s) (f â»Â¹' t)) : Disjoint s t := by\n  rw [disjoint_iff_inter_eq_empty, â† image_preimage_eq (_ âˆ© _) hf, preimage_inter, h.inter_eq,\n    image_empty]\n\n"}
{"name":"Set.disjoint_preimage_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Surjective f\ns t : Set Î²\nâŠ¢ Iff (Disjoint (Set.preimage f s) (Set.preimage f t)) (Disjoint s t)","decl":"@[simp]\ntheorem disjoint_preimage_iff (hf : Surjective f) {s t : Set Î²} :\n    Disjoint (f â»Â¹' s) (f â»Â¹' t) â†” Disjoint s t :=\n  âŸ¨Disjoint.of_preimage hf, Disjoint.preimage _âŸ©\n\n"}
{"name":"Set.preimage_eq_empty","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î²\nh : Disjoint s (Set.range f)\nâŠ¢ Eq (Set.preimage f s) EmptyCollection.emptyCollection","decl":"theorem preimage_eq_empty {s : Set Î²} (h : Disjoint s (range f)) :\n    f â»Â¹' s = âˆ… := by\n  simpa using h.preimage f\n\n"}
{"name":"Set.preimage_eq_empty_iff","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î²\nâŠ¢ Iff (Eq (Set.preimage f s) EmptyCollection.emptyCollection) (Disjoint s (Set.range f))","decl":"theorem preimage_eq_empty_iff {s : Set Î²} : f â»Â¹' s = âˆ… â†” Disjoint s (range f) :=\n  âŸ¨fun h => by\n    simp only [eq_empty_iff_forall_not_mem, disjoint_iff_inter_eq_empty, not_exists, mem_inter_iff,\n      not_and, mem_range, mem_preimage] at h âŠ¢\n    intro y hy x hx\n    rw [â† hx] at hy\n    exact h x hy,\n  preimage_eq_emptyâŸ©\n\n"}
{"name":"sigma_mk_preimage_image'","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Î± â†’ Type u_2\ni j : Î±\ns : Set (Î² i)\nh : Ne i j\nâŠ¢ Eq (Set.preimage (Sigma.mk j) (Set.image (Sigma.mk i) s)) EmptyCollection.emptyCollection","decl":"lemma sigma_mk_preimage_image' (h : i â‰  j) : Sigma.mk j â»Â¹' (Sigma.mk i '' s) = âˆ… := by\n  simp [image, h]\n\n"}
{"name":"sigma_mk_preimage_image_eq_self","module":"Mathlib.Data.Set.Image","initialProofState":"Î± : Type u_1\nÎ² : Î± â†’ Type u_2\ni : Î±\ns : Set (Î² i)\nâŠ¢ Eq (Set.preimage (Sigma.mk i) (Set.image (Sigma.mk i) s)) s","decl":"lemma sigma_mk_preimage_image_eq_self : Sigma.mk i â»Â¹' (Sigma.mk i '' s) = s := by\n  simp [image]\n\n"}
