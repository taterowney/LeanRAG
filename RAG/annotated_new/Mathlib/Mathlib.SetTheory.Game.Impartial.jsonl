{"name":"SetTheory.PGame.impartialAux_def","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\n⊢ Iff G.ImpartialAux (And (HasEquiv.Equiv G (Neg.neg G)) (And (∀ (i : G.LeftMoves), (G.moveLeft i).ImpartialAux) (∀ (j : G.RightMoves), (G.moveRight j).ImpartialAux)))","decl":"theorem impartialAux_def {G : PGame} : G.ImpartialAux ↔\n    (G ≈ -G) ∧ (∀ i, ImpartialAux (G.moveLeft i)) ∧ ∀ j, ImpartialAux (G.moveRight j) := by\n  rw [ImpartialAux]\n\n"}
{"name":"SetTheory.PGame.Impartial.out","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\nself : G.Impartial\n⊢ G.ImpartialAux","decl":"/-- A typeclass on impartial games. -/\nclass Impartial (G : PGame) : Prop where\n  out : ImpartialAux G\n\n"}
{"name":"SetTheory.PGame.impartial_iff_aux","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\n⊢ Iff G.Impartial G.ImpartialAux","decl":"theorem impartial_iff_aux {G : PGame} : G.Impartial ↔ G.ImpartialAux :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n\n"}
{"name":"SetTheory.PGame.impartial_def","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\n⊢ Iff G.Impartial (And (HasEquiv.Equiv G (Neg.neg G)) (And (∀ (i : G.LeftMoves), (G.moveLeft i).Impartial) (∀ (j : G.RightMoves), (G.moveRight j).Impartial)))","decl":"theorem impartial_def {G : PGame} :\n    G.Impartial ↔ (G ≈ -G) ∧ (∀ i, Impartial (G.moveLeft i)) ∧ ∀ j, Impartial (G.moveRight j) := by\n  simpa only [impartial_iff_aux] using impartialAux_def\n\n"}
{"name":"SetTheory.PGame.Impartial.impartial_zero","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"⊢ SetTheory.PGame.Impartial 0","decl":"instance impartial_zero : Impartial 0 := by\n  rw [impartial_def]\n  simp\n\n"}
{"name":"SetTheory.PGame.Impartial.impartial_star","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"⊢ SetTheory.PGame.star.Impartial","decl":"instance impartial_star : Impartial star := by\n  rw [impartial_def]\n  simpa using Impartial.impartial_zero\n\n"}
{"name":"SetTheory.PGame.Impartial.neg_equiv_self","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\nh : G.Impartial\n⊢ HasEquiv.Equiv G (Neg.neg G)","decl":"theorem neg_equiv_self (G : PGame) [h : G.Impartial] : G ≈ -G :=\n  (impartial_def.1 h).1\n\n"}
{"name":"SetTheory.PGame.Impartial.mk'_neg_equiv_self","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\n⊢ Eq (Neg.neg (Quotient.mk SetTheory.PGame.setoid G)) (Quotient.mk SetTheory.PGame.setoid G)","decl":"@[simp]\ntheorem mk'_neg_equiv_self (G : PGame) [G.Impartial] : -(⟦G⟧ : Game) = ⟦G⟧ :=\n  game_eq (Equiv.symm (neg_equiv_self G))\n\n"}
{"name":"SetTheory.PGame.Impartial.moveLeft_impartial","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\nh : G.Impartial\ni : G.LeftMoves\n⊢ (G.moveLeft i).Impartial","decl":"instance moveLeft_impartial {G : PGame} [h : G.Impartial] (i : G.LeftMoves) :\n    (G.moveLeft i).Impartial :=\n  (impartial_def.1 h).2.1 i\n\n"}
{"name":"SetTheory.PGame.Impartial.moveRight_impartial","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\nh : G.Impartial\nj : G.RightMoves\n⊢ (G.moveRight j).Impartial","decl":"instance moveRight_impartial {G : PGame} [h : G.Impartial] (j : G.RightMoves) :\n    (G.moveRight j).Impartial :=\n  (impartial_def.1 h).2.2 j\n\n"}
{"name":"SetTheory.PGame.Impartial.impartial_congr","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G H : SetTheory.PGame\ne : G.Relabelling H\ninst✝ : G.Impartial\n⊢ H.Impartial","decl":"theorem impartial_congr {G H : PGame} (e : G ≡r H) [G.Impartial] : H.Impartial :=\n  impartial_def.2\n    ⟨Equiv.trans e.symm.equiv (Equiv.trans (neg_equiv_self G) (neg_equiv_neg_iff.2 e.equiv)),\n      fun i => impartial_congr (e.moveLeftSymm i), fun j => impartial_congr (e.moveRightSymm j)⟩\ntermination_by G\n\n"}
{"name":"SetTheory.PGame.Impartial.impartial_add","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G H : SetTheory.PGame\ninst✝¹ : G.Impartial\ninst✝ : H.Impartial\n⊢ (HAdd.hAdd G H).Impartial","decl":"instance impartial_add (G H : PGame) [G.Impartial] [H.Impartial] : (G + H).Impartial := by\n  rw [impartial_def]\n  refine ⟨Equiv.trans (add_congr (neg_equiv_self G) (neg_equiv_self _))\n      (Equiv.symm (negAddRelabelling _ _).equiv), fun k => ?_, fun k => ?_⟩\n  · apply leftMoves_add_cases k\n    all_goals\n      intro i; simp only [add_moveLeft_inl, add_moveLeft_inr]\n      apply impartial_add\n  · apply rightMoves_add_cases k\n    all_goals\n      intro i; simp only [add_moveRight_inl, add_moveRight_inr]\n      apply impartial_add\ntermination_by (G, H)\n\n"}
{"name":"SetTheory.PGame.Impartial.impartial_neg","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\n⊢ (Neg.neg G).Impartial","decl":"instance impartial_neg (G : PGame) [G.Impartial] : (-G).Impartial := by\n  rw [impartial_def]\n  refine ⟨?_, fun i => ?_, fun i => ?_⟩\n  · rw [neg_neg]\n    exact Equiv.symm (neg_equiv_self G)\n  · rw [moveLeft_neg]\n    exact impartial_neg _\n  · rw [moveRight_neg]\n    exact impartial_neg _\ntermination_by G\n\n"}
{"name":"SetTheory.PGame.Impartial.nonpos","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\n⊢ Not (LT.lt 0 G)","decl":"theorem nonpos : ¬0 < G := by\n  apply (lt_asymm · ?_)\n  rwa [← neg_lt_neg_iff, neg_zero, ← lt_congr_right (neg_equiv_self G)]\n\n"}
{"name":"SetTheory.PGame.Impartial.nonneg","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\n⊢ Not (LT.lt G 0)","decl":"theorem nonneg : ¬G < 0 := by\n  simpa using nonpos (-G)\n\n"}
{"name":"SetTheory.PGame.Impartial.equiv_or_fuzzy_zero","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\n⊢ Or (HasEquiv.Equiv G 0) (G.Fuzzy 0)","decl":"/-- In an impartial game, either the first player always wins, or the second player always wins. -/\ntheorem equiv_or_fuzzy_zero : (G ≈ 0) ∨ G ‖ 0 := by\n  rcases lt_or_equiv_or_gt_or_fuzzy G 0 with (h | h | h | h)\n  · exact ((nonneg G) h).elim\n  · exact Or.inl h\n  · exact ((nonpos G) h).elim\n  · exact Or.inr h\n\n"}
{"name":"SetTheory.PGame.Impartial.not_equiv_zero_iff","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\n⊢ Iff (Not (HasEquiv.Equiv G 0)) (G.Fuzzy 0)","decl":"@[simp]\ntheorem not_equiv_zero_iff : ¬(G ≈ 0) ↔ G ‖ 0 :=\n  ⟨(equiv_or_fuzzy_zero G).resolve_left, Fuzzy.not_equiv⟩\n\n"}
{"name":"SetTheory.PGame.Impartial.not_fuzzy_zero_iff","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\n⊢ Iff (Not (G.Fuzzy 0)) (HasEquiv.Equiv G 0)","decl":"@[simp]\ntheorem not_fuzzy_zero_iff : ¬G ‖ 0 ↔ (G ≈ 0) :=\n  ⟨(equiv_or_fuzzy_zero G).resolve_right, Equiv.not_fuzzy⟩\n\n"}
{"name":"SetTheory.PGame.Impartial.add_self","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\n⊢ HasEquiv.Equiv (HAdd.hAdd G G) 0","decl":"theorem add_self : G + G ≈ 0 :=\n  Equiv.trans (add_congr_left (neg_equiv_self G)) (neg_add_cancel_equiv G)\n\n"}
{"name":"SetTheory.PGame.Impartial.mk'_add_self","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\n⊢ Eq (HAdd.hAdd (Quotient.mk SetTheory.PGame.setoid G) (Quotient.mk SetTheory.PGame.setoid G)) 0","decl":"@[simp]\ntheorem mk'_add_self : (⟦G⟧ : Game) + ⟦G⟧ = 0 :=\n  game_eq (add_self G)\n\n"}
{"name":"SetTheory.PGame.Impartial.equiv_iff_add_equiv_zero","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\nH : SetTheory.PGame\n⊢ Iff (HasEquiv.Equiv H G) (HasEquiv.Equiv (HAdd.hAdd H G) 0)","decl":"/-- This lemma doesn't require `H` to be impartial. -/\ntheorem equiv_iff_add_equiv_zero (H : PGame) : (H ≈ G) ↔ (H + G ≈ 0) := by\n  rw [equiv_iff_game_eq, ← add_right_cancel_iff (a := ⟦G⟧), mk'_add_self, ← quot_add,\n    equiv_iff_game_eq, quot_zero]\n\n"}
{"name":"SetTheory.PGame.Impartial.equiv_iff_add_equiv_zero'","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\nH : SetTheory.PGame\n⊢ Iff (HasEquiv.Equiv G H) (HasEquiv.Equiv (HAdd.hAdd G H) 0)","decl":"/-- This lemma doesn't require `H` to be impartial. -/\ntheorem equiv_iff_add_equiv_zero' (H : PGame) : (G ≈ H) ↔ (G + H ≈ 0) := by\n  rw [equiv_iff_game_eq, ← add_left_cancel_iff, mk'_add_self, ← quot_add, equiv_iff_game_eq,\n    Eq.comm, quot_zero]\n\n"}
{"name":"SetTheory.PGame.Impartial.le_zero_iff","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\n⊢ Iff (LE.le G 0) (LE.le 0 G)","decl":"theorem le_zero_iff {G : PGame} [G.Impartial] : G ≤ 0 ↔ 0 ≤ G := by\n  rw [← zero_le_neg_iff, le_congr_right (neg_equiv_self G)]\n\n"}
{"name":"SetTheory.PGame.Impartial.lf_zero_iff","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\n⊢ Iff (G.LF 0) (SetTheory.PGame.LF 0 G)","decl":"theorem lf_zero_iff {G : PGame} [G.Impartial] : G ⧏ 0 ↔ 0 ⧏ G := by\n  rw [← zero_lf_neg_iff, lf_congr_right (neg_equiv_self G)]\n\n"}
{"name":"SetTheory.PGame.Impartial.equiv_zero_iff_le","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\n⊢ Iff (HasEquiv.Equiv G 0) (LE.le G 0)","decl":"theorem equiv_zero_iff_le : (G ≈ 0) ↔ G ≤ 0 :=\n  ⟨And.left, fun h => ⟨h, le_zero_iff.1 h⟩⟩\n\n"}
{"name":"SetTheory.PGame.Impartial.fuzzy_zero_iff_lf","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\n⊢ Iff (G.Fuzzy 0) (G.LF 0)","decl":"theorem fuzzy_zero_iff_lf : G ‖ 0 ↔ G ⧏ 0 :=\n  ⟨And.left, fun h => ⟨h, lf_zero_iff.1 h⟩⟩\n\n"}
{"name":"SetTheory.PGame.Impartial.equiv_zero_iff_ge","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\n⊢ Iff (HasEquiv.Equiv G 0) (LE.le 0 G)","decl":"theorem equiv_zero_iff_ge : (G ≈ 0) ↔ 0 ≤ G :=\n  ⟨And.right, fun h => ⟨le_zero_iff.2 h, h⟩⟩\n\n"}
{"name":"SetTheory.PGame.Impartial.fuzzy_zero_iff_gf","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\n⊢ Iff (G.Fuzzy 0) (SetTheory.PGame.LF 0 G)","decl":"theorem fuzzy_zero_iff_gf : G ‖ 0 ↔ 0 ⧏ G :=\n  ⟨And.right, fun h => ⟨lf_zero_iff.2 h, h⟩⟩\n\n"}
{"name":"SetTheory.PGame.Impartial.forall_leftMoves_fuzzy_iff_equiv_zero","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\n⊢ Iff (∀ (i : G.LeftMoves), (G.moveLeft i).Fuzzy 0) (HasEquiv.Equiv G 0)","decl":"theorem forall_leftMoves_fuzzy_iff_equiv_zero : (∀ i, G.moveLeft i ‖ 0) ↔ (G ≈ 0) := by\n  refine ⟨fun hb => ?_, fun hp i => ?_⟩\n  · rw [equiv_zero_iff_le G, le_zero_lf]\n    exact fun i => (hb i).1\n  · rw [fuzzy_zero_iff_lf]\n    exact hp.1.moveLeft_lf i\n\n"}
{"name":"SetTheory.PGame.Impartial.forall_rightMoves_fuzzy_iff_equiv_zero","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\n⊢ Iff (∀ (j : G.RightMoves), (G.moveRight j).Fuzzy 0) (HasEquiv.Equiv G 0)","decl":"theorem forall_rightMoves_fuzzy_iff_equiv_zero : (∀ j, G.moveRight j ‖ 0) ↔ (G ≈ 0) := by\n  refine ⟨fun hb => ?_, fun hp i => ?_⟩\n  · rw [equiv_zero_iff_ge G, zero_le_lf]\n    exact fun i => (hb i).2\n  · rw [fuzzy_zero_iff_gf]\n    exact hp.2.lf_moveRight i\n\n"}
{"name":"SetTheory.PGame.Impartial.exists_left_move_equiv_iff_fuzzy_zero","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\n⊢ Iff (Exists fun i => HasEquiv.Equiv (G.moveLeft i) 0) (G.Fuzzy 0)","decl":"theorem exists_left_move_equiv_iff_fuzzy_zero : (∃ i, G.moveLeft i ≈ 0) ↔ G ‖ 0 := by\n  refine ⟨fun ⟨i, hi⟩ => (fuzzy_zero_iff_gf G).2 (lf_of_le_moveLeft hi.2), fun hn => ?_⟩\n  rw [fuzzy_zero_iff_gf G, zero_lf_le] at hn\n  cases' hn with i hi\n  exact ⟨i, (equiv_zero_iff_ge _).2 hi⟩\n\n"}
{"name":"SetTheory.PGame.Impartial.exists_right_move_equiv_iff_fuzzy_zero","module":"Mathlib.SetTheory.Game.Impartial","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\n⊢ Iff (Exists fun j => HasEquiv.Equiv (G.moveRight j) 0) (G.Fuzzy 0)","decl":"theorem exists_right_move_equiv_iff_fuzzy_zero : (∃ j, G.moveRight j ≈ 0) ↔ G ‖ 0 := by\n  refine ⟨fun ⟨i, hi⟩ => (fuzzy_zero_iff_lf G).2 (lf_of_moveRight_le hi.1), fun hn => ?_⟩\n  rw [fuzzy_zero_iff_lf G, lf_zero_le] at hn\n  cases' hn with i hi\n  exact ⟨i, (equiv_zero_iff_le _).2 hi⟩\n\n"}
