{"name":"Matrix.dualNumberEquiv_symm_apply","module":"Mathlib.Data.Matrix.DualNumber","initialProofState":"R n : Type\ninst✝² : CommSemiring R\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nd : DualNumber (Matrix n n R)\n⊢ Eq (Matrix.dualNumberEquiv.symm d) (Matrix.of fun i j => { fst := TrivSqZeroExt.fst d i j, snd := TrivSqZeroExt.snd d i j })","decl":"/-- Matrices over dual numbers and dual numbers over matrices are isomorphic. -/\n@[simps]\ndef Matrix.dualNumberEquiv : Matrix n n (DualNumber R) ≃ₐ[R] DualNumber (Matrix n n R) where\n  toFun A := ⟨of fun i j => (A i j).fst, of fun i j => (A i j).snd⟩\n  invFun d := of fun i j => (d.fst i j, d.snd i j)\n  left_inv _ := Matrix.ext fun _ _ => TrivSqZeroExt.ext rfl rfl\n  right_inv _ := TrivSqZeroExt.ext (Matrix.ext fun _ _ => rfl) (Matrix.ext fun _ _ => rfl)\n  map_mul' A B := by\n    ext\n    · dsimp [mul_apply]\n      simp_rw [fst_sum]\n      rfl\n    · simp_rw [snd_mul, smul_eq_mul, op_smul_eq_mul]\n      simp only [mul_apply, snd_sum, DualNumber.snd_mul, snd_mk, of_apply, fst_mk, add_apply]\n      rw [← Finset.sum_add_distrib]\n  map_add' _ _ := TrivSqZeroExt.ext rfl rfl\n  commutes' r := by\n    simp_rw [algebraMap_eq_inl', algebraMap_eq_diagonal, Pi.algebraMap_def,\n      Algebra.id.map_eq_self, algebraMap_eq_inl, ← diagonal_map (inl_zero R), map_apply, fst_inl,\n      snd_inl]\n    rfl\n"}
{"name":"Matrix.dualNumberEquiv_apply","module":"Mathlib.Data.Matrix.DualNumber","initialProofState":"R n : Type\ninst✝² : CommSemiring R\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix n n (DualNumber R)\n⊢ Eq (Matrix.dualNumberEquiv A) { fst := Matrix.of fun i j => TrivSqZeroExt.fst (A i j), snd := Matrix.of fun i j => TrivSqZeroExt.snd (A i j) }","decl":"/-- Matrices over dual numbers and dual numbers over matrices are isomorphic. -/\n@[simps]\ndef Matrix.dualNumberEquiv : Matrix n n (DualNumber R) ≃ₐ[R] DualNumber (Matrix n n R) where\n  toFun A := ⟨of fun i j => (A i j).fst, of fun i j => (A i j).snd⟩\n  invFun d := of fun i j => (d.fst i j, d.snd i j)\n  left_inv _ := Matrix.ext fun _ _ => TrivSqZeroExt.ext rfl rfl\n  right_inv _ := TrivSqZeroExt.ext (Matrix.ext fun _ _ => rfl) (Matrix.ext fun _ _ => rfl)\n  map_mul' A B := by\n    ext\n    · dsimp [mul_apply]\n      simp_rw [fst_sum]\n      rfl\n    · simp_rw [snd_mul, smul_eq_mul, op_smul_eq_mul]\n      simp only [mul_apply, snd_sum, DualNumber.snd_mul, snd_mk, of_apply, fst_mk, add_apply]\n      rw [← Finset.sum_add_distrib]\n  map_add' _ _ := TrivSqZeroExt.ext rfl rfl\n  commutes' r := by\n    simp_rw [algebraMap_eq_inl', algebraMap_eq_diagonal, Pi.algebraMap_def,\n      Algebra.id.map_eq_self, algebraMap_eq_inl, ← diagonal_map (inl_zero R), map_apply, fst_inl,\n      snd_inl]\n    rfl\n"}
