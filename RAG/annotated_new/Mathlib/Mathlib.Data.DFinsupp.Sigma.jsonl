{"name":"DFinsupp.sigmaCurry_apply","module":"Mathlib.Data.DFinsupp.Sigma","initialProofState":"ι : Type u\nα : ι → Type u_2\nδ : (i : ι) → α i → Type v\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → (j : α i) → Zero (δ i j)\nf : DFinsupp fun i => δ i.fst i.snd\ni : ι\nj : α i\n⊢ Eq ((f.sigmaCurry i) j) (f ⟨i, j⟩)","decl":"@[simp]\ntheorem sigmaCurry_apply [∀ i j, Zero (δ i j)] (f : Π₀ (i : Σ _, _), δ i.1 i.2) (i : ι) (j : α i) :\n    sigmaCurry f i j = f ⟨i, j⟩ :=\n  rfl\n\n"}
{"name":"DFinsupp.sigmaCurry_zero","module":"Mathlib.Data.DFinsupp.Sigma","initialProofState":"ι : Type u\nα : ι → Type u_2\nδ : (i : ι) → α i → Type v\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → (j : α i) → Zero (δ i j)\n⊢ Eq (DFinsupp.sigmaCurry 0) 0","decl":"@[simp]\ntheorem sigmaCurry_zero [∀ i j, Zero (δ i j)] :\n    sigmaCurry (0 : Π₀ (i : Σ _, _), δ i.1 i.2) = 0 :=\n  rfl\n\n"}
{"name":"DFinsupp.sigmaCurry_add","module":"Mathlib.Data.DFinsupp.Sigma","initialProofState":"ι : Type u\nα : ι → Type u_2\nδ : (i : ι) → α i → Type v\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → (j : α i) → AddZeroClass (δ i j)\nf g : DFinsupp fun i => δ i.fst i.snd\n⊢ Eq (HAdd.hAdd f g).sigmaCurry (HAdd.hAdd f.sigmaCurry g.sigmaCurry)","decl":"@[simp]\ntheorem sigmaCurry_add [∀ i j, AddZeroClass (δ i j)] (f g : Π₀ (i : Σ _, _), δ i.1 i.2) :\n    #adaptation_note /-- https://github.com/leanprover/lean4/pull/6024\n    we needed to add the `(_ : Π₀ (i) (j), δ i j)` type annotation. -/\n    sigmaCurry (f + g) = (sigmaCurry f + sigmaCurry g : Π₀ (i) (j), δ i j) := by\n  ext (i j)\n  rfl\n\n"}
{"name":"DFinsupp.sigmaCurry_smul","module":"Mathlib.Data.DFinsupp.Sigma","initialProofState":"ι : Type u\nγ : Type w\nα : ι → Type u_2\nδ : (i : ι) → α i → Type v\ninst✝³ : DecidableEq ι\ninst✝² : Monoid γ\ninst✝¹ : (i : ι) → (j : α i) → AddMonoid (δ i j)\ninst✝ : (i : ι) → (j : α i) → DistribMulAction γ (δ i j)\nr : γ\nf : DFinsupp fun i => δ i.fst i.snd\n⊢ Eq (HSMul.hSMul r f).sigmaCurry (HSMul.hSMul r f.sigmaCurry)","decl":"@[simp]\ntheorem sigmaCurry_smul [Monoid γ] [∀ i j, AddMonoid (δ i j)] [∀ i j, DistribMulAction γ (δ i j)]\n    (r : γ) (f : Π₀ (i : Σ _, _), δ i.1 i.2) :\n    #adaptation_note /-- https://github.com/leanprover/lean4/pull/6024\n    we needed to add the `(_ : Π₀ (i) (j), δ i j)` type annotation. -/\n    sigmaCurry (r • f) = (r • sigmaCurry f : Π₀ (i) (j), δ i j) := by\n  ext (i j)\n  rfl\n\n"}
{"name":"DFinsupp.sigmaCurry_single","module":"Mathlib.Data.DFinsupp.Sigma","initialProofState":"ι : Type u\nα : ι → Type u_2\nδ : (i : ι) → α i → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → DecidableEq (α i)\ninst✝ : (i : ι) → (j : α i) → Zero (δ i j)\nij : Sigma fun i => α i\nx : δ ij.fst ij.snd\n⊢ Eq (DFinsupp.single ij x).sigmaCurry (DFinsupp.single ij.fst (DFinsupp.single ij.snd x))","decl":"@[simp]\ntheorem sigmaCurry_single [∀ i, DecidableEq (α i)] [∀ i j, Zero (δ i j)]\n    (ij : Σ i, α i) (x : δ ij.1 ij.2) :\n    sigmaCurry (single ij x) = single ij.1 (single ij.2 x : Π₀ j, δ ij.1 j) := by\n  obtain ⟨i, j⟩ := ij\n  ext i' j'\n  dsimp only\n  rw [sigmaCurry_apply]\n  obtain rfl | hi := eq_or_ne i i'\n  · rw [single_eq_same]\n    obtain rfl | hj := eq_or_ne j j'\n    · rw [single_eq_same, single_eq_same]\n    · rw [single_eq_of_ne, single_eq_of_ne hj]\n      simpa using hj\n  · rw [single_eq_of_ne, single_eq_of_ne hi, zero_apply]\n    simp [hi]\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"DFinsupp.sigmaUncurry_apply","module":"Mathlib.Data.DFinsupp.Sigma","initialProofState":"ι : Type u\nα : ι → Type u_2\nδ : (i : ι) → α i → Type v\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → (j : α i) → Zero (δ i j)\nf : DFinsupp fun i => DFinsupp fun j => δ i j\ni : ι\nj : α i\n⊢ Eq (f.sigmaUncurry ⟨i, j⟩) ((f i) j)","decl":"@[simp]\ntheorem sigmaUncurry_apply [∀ i j, Zero (δ i j)]\n    (f : Π₀ (i) (j), δ i j) (i : ι) (j : α i) :\n    sigmaUncurry f ⟨i, j⟩ = f i j :=\n  rfl\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"DFinsupp.sigmaUncurry_zero","module":"Mathlib.Data.DFinsupp.Sigma","initialProofState":"ι : Type u\nα : ι → Type u_2\nδ : (i : ι) → α i → Type v\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → (j : α i) → Zero (δ i j)\n⊢ Eq (DFinsupp.sigmaUncurry 0) 0","decl":"@[simp]\ntheorem sigmaUncurry_zero [∀ i j, Zero (δ i j)] :\n    sigmaUncurry (0 : Π₀ (i) (j), δ i j) = 0 :=\n  rfl\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"DFinsupp.sigmaUncurry_add","module":"Mathlib.Data.DFinsupp.Sigma","initialProofState":"ι : Type u\nα : ι → Type u_2\nδ : (i : ι) → α i → Type v\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → (j : α i) → AddZeroClass (δ i j)\nf g : DFinsupp fun i => DFinsupp fun j => δ i j\n⊢ Eq (HAdd.hAdd f g).sigmaUncurry (HAdd.hAdd f.sigmaUncurry g.sigmaUncurry)","decl":"@[simp]\ntheorem sigmaUncurry_add [∀ i j, AddZeroClass (δ i j)] (f g : Π₀ (i) (j), δ i j) :\n    sigmaUncurry (f + g) = sigmaUncurry f + sigmaUncurry g :=\n  DFunLike.coe_injective rfl\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"DFinsupp.sigmaUncurry_smul","module":"Mathlib.Data.DFinsupp.Sigma","initialProofState":"ι : Type u\nγ : Type w\nα : ι → Type u_2\nδ : (i : ι) → α i → Type v\ninst✝³ : DecidableEq ι\ninst✝² : Monoid γ\ninst✝¹ : (i : ι) → (j : α i) → AddMonoid (δ i j)\ninst✝ : (i : ι) → (j : α i) → DistribMulAction γ (δ i j)\nr : γ\nf : DFinsupp fun i => DFinsupp fun j => δ i j\n⊢ Eq (HSMul.hSMul r f).sigmaUncurry (HSMul.hSMul r f.sigmaUncurry)","decl":"@[simp]\ntheorem sigmaUncurry_smul [Monoid γ] [∀ i j, AddMonoid (δ i j)]\n    [∀ i j, DistribMulAction γ (δ i j)]\n    (r : γ) (f : Π₀ (i) (j), δ i j) : sigmaUncurry (r • f) = r • sigmaUncurry f :=\n  DFunLike.coe_injective rfl\n\n"}
{"name":"DFinsupp.sigmaUncurry_single","module":"Mathlib.Data.DFinsupp.Sigma","initialProofState":"ι : Type u\nα : ι → Type u_2\nδ : (i : ι) → α i → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → (j : α i) → Zero (δ i j)\ninst✝ : (i : ι) → DecidableEq (α i)\ni : ι\nj : α i\nx : δ i j\n⊢ Eq (DFinsupp.single i (DFinsupp.single j x)).sigmaUncurry (DFinsupp.single ⟨i, j⟩ x)","decl":"@[simp]\ntheorem sigmaUncurry_single [∀ i j, Zero (δ i j)] [∀ i, DecidableEq (α i)]\n    (i) (j : α i) (x : δ i j) :\n    sigmaUncurry (single i (single j x : Π₀ j : α i, δ i j)) = single ⟨i, j⟩ (by exact x) := by\n  ext ⟨i', j'⟩\n  dsimp only\n  rw [sigmaUncurry_apply]\n  obtain rfl | hi := eq_or_ne i i'\n  · rw [single_eq_same]\n    obtain rfl | hj := eq_or_ne j j'\n    · rw [single_eq_same, single_eq_same]\n    · rw [single_eq_of_ne hj, single_eq_of_ne]\n      simpa using hj\n  · rw [single_eq_of_ne hi, single_eq_of_ne, zero_apply]\n    simp [hi]\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
