{"name":"CategoryTheory.Iso.conj_apply","module":"Mathlib.CategoryTheory.Conj","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\nf : CategoryTheory.End X\n‚ä¢ Eq (Œ±.conj f) (CategoryTheory.CategoryStruct.comp Œ±.inv (CategoryTheory.CategoryStruct.comp f Œ±.hom))","decl":"theorem conj_apply (f : End X) : Œ±.conj f = Œ±.inv ‚â´ f ‚â´ Œ±.hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Iso.conj_comp","module":"Mathlib.CategoryTheory.Conj","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\nf g : CategoryTheory.End X\n‚ä¢ Eq (Œ±.conj (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (Œ±.conj f) (Œ±.conj g))","decl":"@[simp]\ntheorem conj_comp (f g : End X) : Œ±.conj (f ‚â´ g) = Œ±.conj f ‚â´ Œ±.conj g :=\n  map_mul Œ±.conj g f\n\n"}
{"name":"CategoryTheory.Iso.conj_id","module":"Mathlib.CategoryTheory.Conj","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\n‚ä¢ Eq (Œ±.conj (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.CategoryStruct.id Y)","decl":"@[simp]\ntheorem conj_id : Œ±.conj (ùüô X) = ùüô Y :=\n  map_one Œ±.conj\n\n"}
{"name":"CategoryTheory.Iso.refl_conj","module":"Mathlib.CategoryTheory.Conj","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nf : CategoryTheory.End X\n‚ä¢ Eq ((CategoryTheory.Iso.refl X).conj f) f","decl":"@[simp]\ntheorem refl_conj (f : End X) : (Iso.refl X).conj f = f := by\n  rw [conj_apply, Iso.refl_inv, Iso.refl_hom, Category.id_comp, Category.comp_id]\n\n"}
{"name":"CategoryTheory.Iso.trans_conj","module":"Mathlib.CategoryTheory.Conj","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\nZ : C\nŒ≤ : CategoryTheory.Iso Y Z\nf : CategoryTheory.End X\n‚ä¢ Eq ((Œ±.trans Œ≤).conj f) (Œ≤.conj (Œ±.conj f))","decl":"@[simp]\ntheorem trans_conj {Z : C} (Œ≤ : Y ‚âÖ Z) (f : End X) : (Œ± ‚â™‚â´ Œ≤).conj f = Œ≤.conj (Œ±.conj f) :=\n  homCongr_trans Œ± Œ± Œ≤ Œ≤ f\n\n"}
{"name":"CategoryTheory.Iso.symm_self_conj","module":"Mathlib.CategoryTheory.Conj","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\nf : CategoryTheory.End X\n‚ä¢ Eq (Œ±.symm.conj (Œ±.conj f)) f","decl":"@[simp]\ntheorem symm_self_conj (f : End X) : Œ±.symm.conj (Œ±.conj f) = f := by\n  rw [‚Üê trans_conj, Œ±.self_symm_id, refl_conj]\n\n"}
{"name":"CategoryTheory.Iso.self_symm_conj","module":"Mathlib.CategoryTheory.Conj","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\nf : CategoryTheory.End Y\n‚ä¢ Eq (Œ±.conj (Œ±.symm.conj f)) f","decl":"@[simp]\ntheorem self_symm_conj (f : End Y) : Œ±.conj (Œ±.symm.conj f) = f :=\n  Œ±.symm.symm_self_conj f\n\n"}
{"name":"CategoryTheory.Iso.conj_pow","module":"Mathlib.CategoryTheory.Conj","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\nf : CategoryTheory.End X\nn : Nat\n‚ä¢ Eq (Œ±.conj (HPow.hPow f n)) (HPow.hPow (Œ±.conj f) n)","decl":"@[simp]\ntheorem conj_pow (f : End X) (n : ‚Ñï) : Œ±.conj (f ^ n) = Œ±.conj f ^ n :=\n  Œ±.conj.toMonoidHom.map_pow f n\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: change definition so that `conjAut_apply` becomes a `rfl`?\n"}
{"name":"CategoryTheory.Iso.conjAut_apply","module":"Mathlib.CategoryTheory.Conj","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\nf : CategoryTheory.Aut X\n‚ä¢ Eq (Œ±.conjAut f) (Œ±.symm.trans (CategoryTheory.Iso.trans f Œ±))","decl":"theorem conjAut_apply (f : Aut X) : Œ±.conjAut f = Œ±.symm ‚â™‚â´ f ‚â™‚â´ Œ± := by aesop_cat\n\n"}
{"name":"CategoryTheory.Iso.conjAut_hom","module":"Mathlib.CategoryTheory.Conj","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\nf : CategoryTheory.Aut X\n‚ä¢ Eq (Œ±.conjAut f).hom (Œ±.conj f.hom)","decl":"@[simp]\ntheorem conjAut_hom (f : Aut X) : (Œ±.conjAut f).hom = Œ±.conj f.hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Iso.trans_conjAut","module":"Mathlib.CategoryTheory.Conj","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\nZ : C\nŒ≤ : CategoryTheory.Iso Y Z\nf : CategoryTheory.Aut X\n‚ä¢ Eq ((Œ±.trans Œ≤).conjAut f) (Œ≤.conjAut (Œ±.conjAut f))","decl":"@[simp]\ntheorem trans_conjAut {Z : C} (Œ≤ : Y ‚âÖ Z) (f : Aut X) :\n    (Œ± ‚â™‚â´ Œ≤).conjAut f = Œ≤.conjAut (Œ±.conjAut f) := by\n  simp only [conjAut_apply, Iso.trans_symm, Iso.trans_assoc]\n\n"}
{"name":"CategoryTheory.Iso.conjAut_mul","module":"Mathlib.CategoryTheory.Conj","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\nf g : CategoryTheory.Aut X\n‚ä¢ Eq (Œ±.conjAut (HMul.hMul f g)) (HMul.hMul (Œ±.conjAut f) (Œ±.conjAut g))","decl":"@[simp]\ntheorem conjAut_mul (f g : Aut X) : Œ±.conjAut (f * g) = Œ±.conjAut f * Œ±.conjAut g :=\n  map_mul Œ±.conjAut f g\n\n"}
{"name":"CategoryTheory.Iso.conjAut_trans","module":"Mathlib.CategoryTheory.Conj","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\nf g : CategoryTheory.Aut X\n‚ä¢ Eq (Œ±.conjAut (CategoryTheory.Iso.trans f g)) (CategoryTheory.Iso.trans (Œ±.conjAut f) (Œ±.conjAut g))","decl":"@[simp]\ntheorem conjAut_trans (f g : Aut X) : Œ±.conjAut (f ‚â™‚â´ g) = Œ±.conjAut f ‚â™‚â´ Œ±.conjAut g :=\n  conjAut_mul Œ± g f\n\n"}
{"name":"CategoryTheory.Iso.conjAut_pow","module":"Mathlib.CategoryTheory.Conj","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\nf : CategoryTheory.Aut X\nn : Nat\n‚ä¢ Eq (Œ±.conjAut (HPow.hPow f n)) (HPow.hPow (Œ±.conjAut f) n)","decl":"@[simp]\ntheorem conjAut_pow (f : Aut X) (n : ‚Ñï) : Œ±.conjAut (f ^ n) = Œ±.conjAut f ^ n :=\n  map_pow Œ±.conjAut f n\n\n"}
{"name":"CategoryTheory.Iso.conjAut_zpow","module":"Mathlib.CategoryTheory.Conj","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\nf : CategoryTheory.Aut X\nn : Int\n‚ä¢ Eq (Œ±.conjAut (HPow.hPow f n)) (HPow.hPow (Œ±.conjAut f) n)","decl":"@[simp]\ntheorem conjAut_zpow (f : Aut X) (n : ‚Ñ§) : Œ±.conjAut (f ^ n) = Œ±.conjAut f ^ n :=\n  map_zpow Œ±.conjAut f n\n\n"}
{"name":"CategoryTheory.Functor.map_conj","module":"Mathlib.CategoryTheory.Conj","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nF : CategoryTheory.Functor C D\nX Y : C\nŒ± : CategoryTheory.Iso X Y\nf : CategoryTheory.End X\n‚ä¢ Eq (F.map (Œ±.conj f)) ((F.mapIso Œ±).conj (F.map f))","decl":"theorem map_conj {X Y : C} (Œ± : X ‚âÖ Y) (f : End X) :\n    F.map (Œ±.conj f) = (F.mapIso Œ±).conj (F.map f) :=\n  map_homCongr F Œ± Œ± f\n\n"}
{"name":"CategoryTheory.Functor.map_conjAut","module":"Mathlib.CategoryTheory.Conj","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nF : CategoryTheory.Functor C D\nX Y : C\nŒ± : CategoryTheory.Iso X Y\nf : CategoryTheory.Aut X\n‚ä¢ Eq (F.mapIso (Œ±.conjAut f)) ((F.mapIso Œ±).conjAut (F.mapIso f))","decl":"theorem map_conjAut (F : C ‚•§ D) {X Y : C} (Œ± : X ‚âÖ Y) (f : Aut X) :\n    F.mapIso (Œ±.conjAut f) = (F.mapIso Œ±).conjAut (F.mapIso f) := by\n  ext; simp only [mapIso_hom, Iso.conjAut_hom, F.map_conj]\n\n-- alternative proof: by simp only [Iso.conjAut_apply, F.mapIso_trans, F.mapIso_symm]\n"}
