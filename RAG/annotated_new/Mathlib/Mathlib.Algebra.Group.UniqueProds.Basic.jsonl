{"name":"UniqueMul.of_subsingleton","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Mul G\nA B : Finset G\na0 b0 : G\ninst✝ : Subsingleton G\n⊢ UniqueMul A B a0 b0","decl":"@[to_additive (attr := nontriviality, simp)]\ntheorem of_subsingleton [Subsingleton G] : UniqueMul A B a0 b0 := by\n  simp [UniqueMul, eq_iff_true_of_subsingleton]\n\n"}
{"name":"UniqueAdd.of_subsingleton","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Add G\nA B : Finset G\na0 b0 : G\ninst✝ : Subsingleton G\n⊢ UniqueAdd A B a0 b0","decl":"@[to_additive (attr := nontriviality, simp)]\ntheorem of_subsingleton [Subsingleton G] : UniqueMul A B a0 b0 := by\n  simp [UniqueMul, eq_iff_true_of_subsingleton]\n\n"}
{"name":"UniqueAdd.of_card_le_one","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Add G\nA B : Finset G\nhA : A.Nonempty\nhB : B.Nonempty\nhA1 : LE.le A.card 1\nhB1 : LE.le B.card 1\n⊢ Exists fun a => And (Membership.mem A a) (Exists fun b => And (Membership.mem B b) (UniqueAdd A B a b))","decl":"@[to_additive of_card_le_one]\ntheorem of_card_le_one (hA : A.Nonempty) (hB : B.Nonempty) (hA1 : #A ≤ 1) (hB1 : #B ≤ 1) :\n    ∃ a ∈ A, ∃ b ∈ B, UniqueMul A B a b := by\n  rw [Finset.card_le_one_iff] at hA1 hB1\n  obtain ⟨a, ha⟩ := hA; obtain ⟨b, hb⟩ := hB\n  exact ⟨a, ha, b, hb, fun _ _ ha' hb' _ ↦ ⟨hA1 ha' ha, hB1 hb' hb⟩⟩\n\n"}
{"name":"UniqueMul.of_card_le_one","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Mul G\nA B : Finset G\nhA : A.Nonempty\nhB : B.Nonempty\nhA1 : LE.le A.card 1\nhB1 : LE.le B.card 1\n⊢ Exists fun a => And (Membership.mem A a) (Exists fun b => And (Membership.mem B b) (UniqueMul A B a b))","decl":"@[to_additive of_card_le_one]\ntheorem of_card_le_one (hA : A.Nonempty) (hB : B.Nonempty) (hA1 : #A ≤ 1) (hB1 : #B ≤ 1) :\n    ∃ a ∈ A, ∃ b ∈ B, UniqueMul A B a b := by\n  rw [Finset.card_le_one_iff] at hA1 hB1\n  obtain ⟨a, ha⟩ := hA; obtain ⟨b, hb⟩ := hB\n  exact ⟨a, ha, b, hb, fun _ _ ha' hb' _ ↦ ⟨hA1 ha' ha, hB1 hb' hb⟩⟩\n\n"}
{"name":"UniqueAdd.of_card_nonpos","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Add G\nA B : Finset G\nhA : A.Nonempty\nhB : B.Nonempty\nhA1 : LE.le A.card 1\nhB1 : LE.le B.card 1\n⊢ Exists fun a => And (Membership.mem A a) (Exists fun b => And (Membership.mem B b) (UniqueAdd A B a b))","decl":"@[deprecated (since := \"2024-09-23\")]\nalias _root_.UniqueAdd.of_card_nonpos := UniqueAdd.of_card_le_one\n\n"}
{"name":"UniqueAdd.mt","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Add G\nA B : Finset G\na0 b0 : G\nh : UniqueAdd A B a0 b0\na b : G\na✝² : Membership.mem A a\na✝¹ : Membership.mem B b\na✝ : Or (Ne a a0) (Ne b b0)\n⊢ Ne (HAdd.hAdd a b) (HAdd.hAdd a0 b0)","decl":"@[to_additive]\ntheorem mt (h : UniqueMul A B a0 b0) :\n    ∀ ⦃a b⦄, a ∈ A → b ∈ B → a ≠ a0 ∨ b ≠ b0 → a * b ≠ a0 * b0 := fun _ _ ha hb k ↦ by\n  contrapose! k\n  exact h ha hb k\n\n"}
{"name":"UniqueMul.mt","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Mul G\nA B : Finset G\na0 b0 : G\nh : UniqueMul A B a0 b0\na b : G\na✝² : Membership.mem A a\na✝¹ : Membership.mem B b\na✝ : Or (Ne a a0) (Ne b b0)\n⊢ Ne (HMul.hMul a b) (HMul.hMul a0 b0)","decl":"@[to_additive]\ntheorem mt (h : UniqueMul A B a0 b0) :\n    ∀ ⦃a b⦄, a ∈ A → b ∈ B → a ≠ a0 ∨ b ≠ b0 → a * b ≠ a0 * b0 := fun _ _ ha hb k ↦ by\n  contrapose! k\n  exact h ha hb k\n\n"}
{"name":"UniqueAdd.subsingleton","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Add G\nA B : Finset G\na0 b0 : G\nh : UniqueAdd A B a0 b0\n⊢ Subsingleton (Subtype fun ab => And (Membership.mem A ab.1) (And (Membership.mem B ab.2) (Eq (HAdd.hAdd ab.1 ab.2) (HAdd.hAdd a0 b0))))","decl":"@[to_additive]\ntheorem subsingleton (h : UniqueMul A B a0 b0) :\n    Subsingleton { ab : G × G // ab.1 ∈ A ∧ ab.2 ∈ B ∧ ab.1 * ab.2 = a0 * b0 } :=\n  ⟨fun ⟨⟨_a, _b⟩, ha, hb, ab⟩ ⟨⟨_a', _b'⟩, ha', hb', ab'⟩ ↦\n    Subtype.ext <|\n      Prod.ext ((h ha hb ab).1.trans (h ha' hb' ab').1.symm) <|\n        (h ha hb ab).2.trans (h ha' hb' ab').2.symm⟩\n\n"}
{"name":"UniqueMul.subsingleton","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Mul G\nA B : Finset G\na0 b0 : G\nh : UniqueMul A B a0 b0\n⊢ Subsingleton (Subtype fun ab => And (Membership.mem A ab.1) (And (Membership.mem B ab.2) (Eq (HMul.hMul ab.1 ab.2) (HMul.hMul a0 b0))))","decl":"@[to_additive]\ntheorem subsingleton (h : UniqueMul A B a0 b0) :\n    Subsingleton { ab : G × G // ab.1 ∈ A ∧ ab.2 ∈ B ∧ ab.1 * ab.2 = a0 * b0 } :=\n  ⟨fun ⟨⟨_a, _b⟩, ha, hb, ab⟩ ⟨⟨_a', _b'⟩, ha', hb', ab'⟩ ↦\n    Subtype.ext <|\n      Prod.ext ((h ha hb ab).1.trans (h ha' hb' ab').1.symm) <|\n        (h ha hb ab).2.trans (h ha' hb' ab').2.symm⟩\n\n"}
{"name":"UniqueMul.set_subsingleton","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Mul G\nA B : Finset G\na0 b0 : G\nh : UniqueMul A B a0 b0\n⊢ (setOf fun ab => And (Membership.mem A ab.1) (And (Membership.mem B ab.2) (Eq (HMul.hMul ab.1 ab.2) (HMul.hMul a0 b0)))).Subsingleton","decl":"@[to_additive]\ntheorem set_subsingleton (h : UniqueMul A B a0 b0) :\n    Set.Subsingleton { ab : G × G | ab.1 ∈ A ∧ ab.2 ∈ B ∧ ab.1 * ab.2 = a0 * b0 } := by\n  rintro ⟨x1, y1⟩ (hx : x1 ∈ A ∧ y1 ∈ B ∧ x1 * y1 = a0 * b0) ⟨x2, y2⟩\n    (hy : x2 ∈ A ∧ y2 ∈ B ∧ x2 * y2 = a0 * b0)\n  rcases h hx.1 hx.2.1 hx.2.2 with ⟨rfl, rfl⟩\n  rcases h hy.1 hy.2.1 hy.2.2 with ⟨rfl, rfl⟩\n  rfl\n\n-- Porting note: mathport warning: expanding binder collection\n--  (ab «expr ∈ » [finset.product/multiset.product/set.prod/list.product](A, B)) -/\n"}
{"name":"UniqueAdd.set_subsingleton","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Add G\nA B : Finset G\na0 b0 : G\nh : UniqueAdd A B a0 b0\n⊢ (setOf fun ab => And (Membership.mem A ab.1) (And (Membership.mem B ab.2) (Eq (HAdd.hAdd ab.1 ab.2) (HAdd.hAdd a0 b0)))).Subsingleton","decl":"@[to_additive]\ntheorem set_subsingleton (h : UniqueMul A B a0 b0) :\n    Set.Subsingleton { ab : G × G | ab.1 ∈ A ∧ ab.2 ∈ B ∧ ab.1 * ab.2 = a0 * b0 } := by\n  rintro ⟨x1, y1⟩ (hx : x1 ∈ A ∧ y1 ∈ B ∧ x1 * y1 = a0 * b0) ⟨x2, y2⟩\n    (hy : x2 ∈ A ∧ y2 ∈ B ∧ x2 * y2 = a0 * b0)\n  rcases h hx.1 hx.2.1 hx.2.2 with ⟨rfl, rfl⟩\n  rcases h hy.1 hy.2.1 hy.2.2 with ⟨rfl, rfl⟩\n  rfl\n\n-- Porting note: mathport warning: expanding binder collection\n--  (ab «expr ∈ » [finset.product/multiset.product/set.prod/list.product](A, B)) -/\n"}
{"name":"UniqueMul.iff_existsUnique","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Mul G\nA B : Finset G\na0 b0 : G\naA : Membership.mem A a0\nbB : Membership.mem B b0\n⊢ Iff (UniqueMul A B a0 b0) (ExistsUnique fun ab => And (Membership.mem (SProd.sprod A B) ab) (Eq (HMul.hMul ab.1 ab.2) (HMul.hMul a0 b0)))","decl":"@[to_additive]\ntheorem iff_existsUnique (aA : a0 ∈ A) (bB : b0 ∈ B) :\n    UniqueMul A B a0 b0 ↔ ∃! ab, ab ∈ A ×ˢ B ∧ ab.1 * ab.2 = a0 * b0 :=\n  ⟨fun _ ↦ ⟨(a0, b0), ⟨Finset.mk_mem_product aA bB, rfl⟩, by simpa⟩,\n    fun h ↦ h.elim\n      (by\n        rintro ⟨x1, x2⟩ _ J x y hx hy l\n        rcases Prod.mk.inj_iff.mp (J (a0, b0) ⟨Finset.mk_mem_product aA bB, rfl⟩) with ⟨rfl, rfl⟩\n        exact Prod.mk.inj_iff.mp (J (x, y) ⟨Finset.mk_mem_product hx hy, l⟩))⟩\n\n"}
{"name":"UniqueAdd.iff_existsUnique","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Add G\nA B : Finset G\na0 b0 : G\naA : Membership.mem A a0\nbB : Membership.mem B b0\n⊢ Iff (UniqueAdd A B a0 b0) (ExistsUnique fun ab => And (Membership.mem (SProd.sprod A B) ab) (Eq (HAdd.hAdd ab.1 ab.2) (HAdd.hAdd a0 b0)))","decl":"@[to_additive]\ntheorem iff_existsUnique (aA : a0 ∈ A) (bB : b0 ∈ B) :\n    UniqueMul A B a0 b0 ↔ ∃! ab, ab ∈ A ×ˢ B ∧ ab.1 * ab.2 = a0 * b0 :=\n  ⟨fun _ ↦ ⟨(a0, b0), ⟨Finset.mk_mem_product aA bB, rfl⟩, by simpa⟩,\n    fun h ↦ h.elim\n      (by\n        rintro ⟨x1, x2⟩ _ J x y hx hy l\n        rcases Prod.mk.inj_iff.mp (J (a0, b0) ⟨Finset.mk_mem_product aA bB, rfl⟩) with ⟨rfl, rfl⟩\n        exact Prod.mk.inj_iff.mp (J (x, y) ⟨Finset.mk_mem_product hx hy, l⟩))⟩\n\n"}
{"name":"UniqueMul.iff_card_le_one","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Mul G\nA B : Finset G\na0 b0 : G\ninst✝ : DecidableEq G\nha0 : Membership.mem A a0\nhb0 : Membership.mem B b0\n⊢ Iff (UniqueMul A B a0 b0) (LE.le (Finset.filter (fun p => Eq (HMul.hMul p.1 p.2) (HMul.hMul a0 b0)) (SProd.sprod A B)).card 1)","decl":"open Finset in\n@[to_additive iff_card_le_one]\ntheorem iff_card_le_one [DecidableEq G] (ha0 : a0 ∈ A) (hb0 : b0 ∈ B) :\n    UniqueMul A B a0 b0 ↔ #{p ∈ A ×ˢ B | p.1 * p.2 = a0 * b0} ≤ 1 := by\n  simp_rw [card_le_one_iff, mem_filter, mem_product]\n  refine ⟨fun h p1 p2 ⟨⟨ha1, hb1⟩, he1⟩ ⟨⟨ha2, hb2⟩, he2⟩ ↦ ?_, fun h a b ha hb he ↦ ?_⟩\n  · have h1 := h ha1 hb1 he1; have h2 := h ha2 hb2 he2\n    ext\n    · rw [h1.1, h2.1]\n    · rw [h1.2, h2.2]\n  · exact Prod.ext_iff.1 (@h (a, b) (a0, b0) ⟨⟨ha, hb⟩, he⟩ ⟨⟨ha0, hb0⟩, rfl⟩)\n\n"}
{"name":"UniqueAdd.iff_card_le_one","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Add G\nA B : Finset G\na0 b0 : G\ninst✝ : DecidableEq G\nha0 : Membership.mem A a0\nhb0 : Membership.mem B b0\n⊢ Iff (UniqueAdd A B a0 b0) (LE.le (Finset.filter (fun p => Eq (HAdd.hAdd p.1 p.2) (HAdd.hAdd a0 b0)) (SProd.sprod A B)).card 1)","decl":"open Finset in\n@[to_additive iff_card_le_one]\ntheorem iff_card_le_one [DecidableEq G] (ha0 : a0 ∈ A) (hb0 : b0 ∈ B) :\n    UniqueMul A B a0 b0 ↔ #{p ∈ A ×ˢ B | p.1 * p.2 = a0 * b0} ≤ 1 := by\n  simp_rw [card_le_one_iff, mem_filter, mem_product]\n  refine ⟨fun h p1 p2 ⟨⟨ha1, hb1⟩, he1⟩ ⟨⟨ha2, hb2⟩, he2⟩ ↦ ?_, fun h a b ha hb he ↦ ?_⟩\n  · have h1 := h ha1 hb1 he1; have h2 := h ha2 hb2 he2\n    ext\n    · rw [h1.1, h2.1]\n    · rw [h1.2, h2.2]\n  · exact Prod.ext_iff.1 (@h (a, b) (a0, b0) ⟨⟨ha, hb⟩, he⟩ ⟨⟨ha0, hb0⟩, rfl⟩)\n\n"}
{"name":"UniqueAdd.iff_card_nonpos","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Add G\nA B : Finset G\na0 b0 : G\ninst✝ : DecidableEq G\nha0 : Membership.mem A a0\nhb0 : Membership.mem B b0\n⊢ Iff (UniqueAdd A B a0 b0) (LE.le (Finset.filter (fun p => Eq (HAdd.hAdd p.1 p.2) (HAdd.hAdd a0 b0)) (SProd.sprod A B)).card 1)","decl":"@[deprecated (since := \"2024-09-23\")]\nalias _root_.UniqueAdd.iff_card_nonpos := UniqueAdd.iff_card_le_one\n\n-- Porting note: mathport warning: expanding binder collection\n--  (ab «expr ∈ » [finset.product/multiset.product/set.prod/list.product](A, B)) -/\n"}
{"name":"UniqueMul.exists_iff_exists_existsUnique","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Mul G\nA B : Finset G\n⊢ Iff (Exists fun a0 => Exists fun b0 => And (Membership.mem A a0) (And (Membership.mem B b0) (UniqueMul A B a0 b0))) (Exists fun g => ExistsUnique fun ab => And (Membership.mem (SProd.sprod A B) ab) (Eq (HMul.hMul ab.1 ab.2) g))","decl":"@[to_additive]\ntheorem exists_iff_exists_existsUnique :\n    (∃ a0 b0 : G, a0 ∈ A ∧ b0 ∈ B ∧ UniqueMul A B a0 b0) ↔\n      ∃ g : G, ∃! ab, ab ∈ A ×ˢ B ∧ ab.1 * ab.2 = g :=\n  ⟨fun ⟨_, _, hA, hB, h⟩ ↦ ⟨_, (iff_existsUnique hA hB).mp h⟩, fun ⟨g, h⟩ ↦ by\n    have h' := h\n    rcases h' with ⟨⟨a, b⟩, ⟨hab, rfl, -⟩, -⟩\n    cases' Finset.mem_product.mp hab with ha hb\n    exact ⟨a, b, ha, hb, (iff_existsUnique ha hb).mpr h⟩⟩\n\n"}
{"name":"UniqueAdd.exists_iff_exists_existsUnique","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Add G\nA B : Finset G\n⊢ Iff (Exists fun a0 => Exists fun b0 => And (Membership.mem A a0) (And (Membership.mem B b0) (UniqueAdd A B a0 b0))) (Exists fun g => ExistsUnique fun ab => And (Membership.mem (SProd.sprod A B) ab) (Eq (HAdd.hAdd ab.1 ab.2) g))","decl":"@[to_additive]\ntheorem exists_iff_exists_existsUnique :\n    (∃ a0 b0 : G, a0 ∈ A ∧ b0 ∈ B ∧ UniqueMul A B a0 b0) ↔\n      ∃ g : G, ∃! ab, ab ∈ A ×ˢ B ∧ ab.1 * ab.2 = g :=\n  ⟨fun ⟨_, _, hA, hB, h⟩ ↦ ⟨_, (iff_existsUnique hA hB).mp h⟩, fun ⟨g, h⟩ ↦ by\n    have h' := h\n    rcases h' with ⟨⟨a, b⟩, ⟨hab, rfl, -⟩, -⟩\n    cases' Finset.mem_product.mp hab with ha hb\n    exact ⟨a, b, ha, hb, (iff_existsUnique ha hb).mpr h⟩⟩\n\n"}
{"name":"UniqueAdd.addHom_preimage","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\nf : AddHom G H\nhf : Function.Injective ⇑f\na0 b0 : G\nA B : Finset H\nu : UniqueAdd A B (f a0) (f b0)\n⊢ UniqueAdd (A.preimage ⇑f ⋯) (B.preimage ⇑f ⋯) a0 b0","decl":"/-- `UniqueMul` is preserved by inverse images under injective, multiplicative maps. -/\n@[to_additive \"`UniqueAdd` is preserved by inverse images under injective, additive maps.\"]\ntheorem mulHom_preimage (f : G →ₙ* H) (hf : Function.Injective f) (a0 b0 : G) {A B : Finset H}\n    (u : UniqueMul A B (f a0) (f b0)) :\n    UniqueMul (A.preimage f hf.injOn) (B.preimage f hf.injOn) a0 b0 := by\n  intro a b ha hb ab\n  simp only [← hf.eq_iff, map_mul] at ab ⊢\n  exact u (Finset.mem_preimage.mp ha) (Finset.mem_preimage.mp hb) ab\n\n"}
{"name":"UniqueMul.mulHom_preimage","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Mul G\ninst✝ : Mul H\nf : MulHom G H\nhf : Function.Injective ⇑f\na0 b0 : G\nA B : Finset H\nu : UniqueMul A B (f a0) (f b0)\n⊢ UniqueMul (A.preimage ⇑f ⋯) (B.preimage ⇑f ⋯) a0 b0","decl":"/-- `UniqueMul` is preserved by inverse images under injective, multiplicative maps. -/\n@[to_additive \"`UniqueAdd` is preserved by inverse images under injective, additive maps.\"]\ntheorem mulHom_preimage (f : G →ₙ* H) (hf : Function.Injective f) (a0 b0 : G) {A B : Finset H}\n    (u : UniqueMul A B (f a0) (f b0)) :\n    UniqueMul (A.preimage f hf.injOn) (B.preimage f hf.injOn) a0 b0 := by\n  intro a b ha hb ab\n  simp only [← hf.eq_iff, map_mul] at ab ⊢\n  exact u (Finset.mem_preimage.mp ha) (Finset.mem_preimage.mp hb) ab\n\n"}
{"name":"UniqueMul.of_mulHom_image","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝² : Mul G\ninst✝¹ : Mul H\nA B : Finset G\na0 b0 : G\ninst✝ : DecidableEq H\nf : MulHom G H\nhf : ∀ ⦃a b c d : G⦄, Eq (HMul.hMul a b) (HMul.hMul c d) → And (Eq (f a) (f c)) (Eq (f b) (f d)) → And (Eq a c) (Eq b d)\nh : UniqueMul (Finset.image (⇑f) A) (Finset.image (⇑f) B) (f a0) (f b0)\n⊢ UniqueMul A B a0 b0","decl":"@[to_additive] theorem of_mulHom_image [DecidableEq H] (f : G →ₙ* H)\n    (hf : ∀ ⦃a b c d : G⦄, a * b = c * d → f a = f c ∧ f b = f d → a = c ∧ b = d)\n    (h : UniqueMul (A.image f) (B.image f) (f a0) (f b0)) : UniqueMul A B a0 b0 :=\n  fun a b ha hb ab ↦ hf ab\n    (h (Finset.mem_image_of_mem f ha) (Finset.mem_image_of_mem f hb) <| by simp_rw [← map_mul, ab])\n\n"}
{"name":"UniqueAdd.of_addHom_image","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝² : Add G\ninst✝¹ : Add H\nA B : Finset G\na0 b0 : G\ninst✝ : DecidableEq H\nf : AddHom G H\nhf : ∀ ⦃a b c d : G⦄, Eq (HAdd.hAdd a b) (HAdd.hAdd c d) → And (Eq (f a) (f c)) (Eq (f b) (f d)) → And (Eq a c) (Eq b d)\nh : UniqueAdd (Finset.image (⇑f) A) (Finset.image (⇑f) B) (f a0) (f b0)\n⊢ UniqueAdd A B a0 b0","decl":"@[to_additive] theorem of_mulHom_image [DecidableEq H] (f : G →ₙ* H)\n    (hf : ∀ ⦃a b c d : G⦄, a * b = c * d → f a = f c ∧ f b = f d → a = c ∧ b = d)\n    (h : UniqueMul (A.image f) (B.image f) (f a0) (f b0)) : UniqueMul A B a0 b0 :=\n  fun a b ha hb ab ↦ hf ab\n    (h (Finset.mem_image_of_mem f ha) (Finset.mem_image_of_mem f hb) <| by simp_rw [← map_mul, ab])\n\n"}
{"name":"UniqueAdd.addHom_image_iff","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝² : Add G\ninst✝¹ : Add H\nA B : Finset G\na0 b0 : G\ninst✝ : DecidableEq H\nf : AddHom G H\nhf : Function.Injective ⇑f\n⊢ Iff (UniqueAdd (Finset.image (⇑f) A) (Finset.image (⇑f) B) (f a0) (f b0)) (UniqueAdd A B a0 b0)","decl":"/-- `Unique_Mul` is preserved under multiplicative maps that are injective.\n\nSee `UniqueMul.mulHom_map_iff` for a version with swapped bundling. -/\n@[to_additive\n      \"`UniqueAdd` is preserved under additive maps that are injective.\n\nSee `UniqueAdd.addHom_map_iff` for a version with swapped bundling.\"]\ntheorem mulHom_image_iff [DecidableEq H] (f : G →ₙ* H) (hf : Function.Injective f) :\n    UniqueMul (A.image f) (B.image f) (f a0) (f b0) ↔ UniqueMul A B a0 b0 :=\n  ⟨of_mulHom_image f fun _ _ _ _ _ ↦ .imp (hf ·) (hf ·), fun h _ _ ↦ by\n    simp_rw [Finset.mem_image]\n    rintro ⟨a, aA, rfl⟩ ⟨b, bB, rfl⟩ ab\n    simp_rw [← map_mul, hf.eq_iff] at ab ⊢\n    exact h aA bB ab⟩\n\n"}
{"name":"UniqueMul.mulHom_image_iff","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝² : Mul G\ninst✝¹ : Mul H\nA B : Finset G\na0 b0 : G\ninst✝ : DecidableEq H\nf : MulHom G H\nhf : Function.Injective ⇑f\n⊢ Iff (UniqueMul (Finset.image (⇑f) A) (Finset.image (⇑f) B) (f a0) (f b0)) (UniqueMul A B a0 b0)","decl":"/-- `Unique_Mul` is preserved under multiplicative maps that are injective.\n\nSee `UniqueMul.mulHom_map_iff` for a version with swapped bundling. -/\n@[to_additive\n      \"`UniqueAdd` is preserved under additive maps that are injective.\n\nSee `UniqueAdd.addHom_map_iff` for a version with swapped bundling.\"]\ntheorem mulHom_image_iff [DecidableEq H] (f : G →ₙ* H) (hf : Function.Injective f) :\n    UniqueMul (A.image f) (B.image f) (f a0) (f b0) ↔ UniqueMul A B a0 b0 :=\n  ⟨of_mulHom_image f fun _ _ _ _ _ ↦ .imp (hf ·) (hf ·), fun h _ _ ↦ by\n    simp_rw [Finset.mem_image]\n    rintro ⟨a, aA, rfl⟩ ⟨b, bB, rfl⟩ ab\n    simp_rw [← map_mul, hf.eq_iff] at ab ⊢\n    exact h aA bB ab⟩\n\n"}
{"name":"UniqueMul.mulHom_map_iff","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Mul G\ninst✝ : Mul H\nA B : Finset G\na0 b0 : G\nf : Function.Embedding G H\nmul : ∀ (x y : G), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\n⊢ Iff (UniqueMul (Finset.map f A) (Finset.map f B) (f a0) (f b0)) (UniqueMul A B a0 b0)","decl":"/-- `UniqueMul` is preserved under embeddings that are multiplicative.\n\nSee `UniqueMul.mulHom_image_iff` for a version with swapped bundling. -/\n@[to_additive\n      \"`UniqueAdd` is preserved under embeddings that are additive.\n\nSee `UniqueAdd.addHom_image_iff` for a version with swapped bundling.\"]\ntheorem mulHom_map_iff (f : G ↪ H) (mul : ∀ x y, f (x * y) = f x * f y) :\n    UniqueMul (A.map f) (B.map f) (f a0) (f b0) ↔ UniqueMul A B a0 b0 := by\n  classical simp_rw [← mulHom_image_iff ⟨f, mul⟩ f.2, Finset.map_eq_image]; rfl\n\n"}
{"name":"UniqueAdd.addHom_map_iff","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\nA B : Finset G\na0 b0 : G\nf : Function.Embedding G H\nmul : ∀ (x y : G), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\n⊢ Iff (UniqueAdd (Finset.map f A) (Finset.map f B) (f a0) (f b0)) (UniqueAdd A B a0 b0)","decl":"/-- `UniqueMul` is preserved under embeddings that are multiplicative.\n\nSee `UniqueMul.mulHom_image_iff` for a version with swapped bundling. -/\n@[to_additive\n      \"`UniqueAdd` is preserved under embeddings that are additive.\n\nSee `UniqueAdd.addHom_image_iff` for a version with swapped bundling.\"]\ntheorem mulHom_map_iff (f : G ↪ H) (mul : ∀ x y, f (x * y) = f x * f y) :\n    UniqueMul (A.map f) (B.map f) (f a0) (f b0) ↔ UniqueMul A B a0 b0 := by\n  classical simp_rw [← mulHom_image_iff ⟨f, mul⟩ f.2, Finset.map_eq_image]; rfl\n\n"}
{"name":"UniqueMul.of_mulOpposite","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Mul G\nA B : Finset G\na0 b0 : G\nh : UniqueMul (Finset.map { toFun := MulOpposite.op, inj' := ⋯ } B) (Finset.map { toFun := MulOpposite.op, inj' := ⋯ } A) (MulOpposite.op b0) (MulOpposite.op a0)\n⊢ UniqueMul A B a0 b0","decl":"@[to_additive]\ntheorem of_mulOpposite\n    (h : UniqueMul (B.map ⟨_, op_injective⟩) (A.map ⟨_, op_injective⟩) (op b0) (op a0)) :\n    UniqueMul A B a0 b0 := fun a b aA bB ab ↦ by\n  simpa [and_comm] using h (mem_map_of_mem _ bB) (mem_map_of_mem _ aA) (congr_arg op ab)\n\n"}
{"name":"UniqueAdd.of_addOpposite","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Add G\nA B : Finset G\na0 b0 : G\nh : UniqueAdd (Finset.map { toFun := AddOpposite.op, inj' := ⋯ } B) (Finset.map { toFun := AddOpposite.op, inj' := ⋯ } A) (AddOpposite.op b0) (AddOpposite.op a0)\n⊢ UniqueAdd A B a0 b0","decl":"@[to_additive]\ntheorem of_mulOpposite\n    (h : UniqueMul (B.map ⟨_, op_injective⟩) (A.map ⟨_, op_injective⟩) (op b0) (op a0)) :\n    UniqueMul A B a0 b0 := fun a b aA bB ab ↦ by\n  simpa [and_comm] using h (mem_map_of_mem _ bB) (mem_map_of_mem _ aA) (congr_arg op ab)\n\n"}
{"name":"UniqueAdd.to_addOpposite","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Add G\nA B : Finset G\na0 b0 : G\nh : UniqueAdd A B a0 b0\n⊢ UniqueAdd (Finset.map { toFun := AddOpposite.op, inj' := ⋯ } B) (Finset.map { toFun := AddOpposite.op, inj' := ⋯ } A) (AddOpposite.op b0) (AddOpposite.op a0)","decl":"@[to_additive]\ntheorem to_mulOpposite (h : UniqueMul A B a0 b0) :\n    UniqueMul (B.map ⟨_, op_injective⟩) (A.map ⟨_, op_injective⟩) (op b0) (op a0) :=\n  of_mulOpposite (by simp_rw [map_map]; exact (mulHom_map_iff _ fun _ _ ↦ by rfl).mpr h)\n\n"}
{"name":"UniqueMul.to_mulOpposite","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Mul G\nA B : Finset G\na0 b0 : G\nh : UniqueMul A B a0 b0\n⊢ UniqueMul (Finset.map { toFun := MulOpposite.op, inj' := ⋯ } B) (Finset.map { toFun := MulOpposite.op, inj' := ⋯ } A) (MulOpposite.op b0) (MulOpposite.op a0)","decl":"@[to_additive]\ntheorem to_mulOpposite (h : UniqueMul A B a0 b0) :\n    UniqueMul (B.map ⟨_, op_injective⟩) (A.map ⟨_, op_injective⟩) (op b0) (op a0) :=\n  of_mulOpposite (by simp_rw [map_map]; exact (mulHom_map_iff _ fun _ _ ↦ by rfl).mpr h)\n\n"}
{"name":"UniqueAdd.iff_addOpposite","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Add G\nA B : Finset G\na0 b0 : G\n⊢ Iff (UniqueAdd (Finset.map { toFun := AddOpposite.op, inj' := ⋯ } B) (Finset.map { toFun := AddOpposite.op, inj' := ⋯ } A) (AddOpposite.op b0) (AddOpposite.op a0)) (UniqueAdd A B a0 b0)","decl":"@[to_additive]\ntheorem iff_mulOpposite :\n    UniqueMul (B.map ⟨_, op_injective⟩) (A.map ⟨_, op_injective⟩) (op b0) (op a0) ↔\n      UniqueMul A B a0 b0 :=\n  ⟨of_mulOpposite, to_mulOpposite⟩\n\n"}
{"name":"UniqueMul.iff_mulOpposite","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Mul G\nA B : Finset G\na0 b0 : G\n⊢ Iff (UniqueMul (Finset.map { toFun := MulOpposite.op, inj' := ⋯ } B) (Finset.map { toFun := MulOpposite.op, inj' := ⋯ } A) (MulOpposite.op b0) (MulOpposite.op a0)) (UniqueMul A B a0 b0)","decl":"@[to_additive]\ntheorem iff_mulOpposite :\n    UniqueMul (B.map ⟨_, op_injective⟩) (A.map ⟨_, op_injective⟩) (op b0) (op a0) ↔\n      UniqueMul A B a0 b0 :=\n  ⟨of_mulOpposite, to_mulOpposite⟩\n\n"}
{"name":"UniqueAdd.of_image_filter","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝² : Add G\ninst✝¹ : Add H\ninst✝ : DecidableEq H\nf : AddHom G H\nA B : Finset G\naG bG : G\naH bH : H\nhae : Eq (f aG) aH\nhbe : Eq (f bG) bH\nhuH : UniqueAdd (Finset.image (⇑f) A) (Finset.image (⇑f) B) aH bH\nhuG : UniqueAdd (Finset.filter (fun a => Eq (f a) aH) A) (Finset.filter (fun b => Eq (f b) bH) B) aG bG\n⊢ UniqueAdd A B aG bG","decl":"open Finset in\n@[to_additive]\ntheorem of_image_filter [DecidableEq H]\n    (f : G →ₙ* H) {A B : Finset G} {aG bG : G} {aH bH : H} (hae : f aG = aH) (hbe : f bG = bH)\n    (huH : UniqueMul (A.image f) (B.image f) aH bH)\n    (huG : UniqueMul {a ∈ A | f a = aH} {b ∈ B | f b = bH} aG bG) :\n    UniqueMul A B aG bG := fun a b ha hb he ↦ by\n  specialize huH (mem_image_of_mem _ ha) (mem_image_of_mem _ hb)\n  rw [← map_mul, he, map_mul, hae, hbe] at huH\n  refine huG ?_ ?_ he <;> rw [mem_filter]\n  exacts [⟨ha, (huH rfl).1⟩, ⟨hb, (huH rfl).2⟩]\n\n"}
{"name":"UniqueMul.of_image_filter","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝² : Mul G\ninst✝¹ : Mul H\ninst✝ : DecidableEq H\nf : MulHom G H\nA B : Finset G\naG bG : G\naH bH : H\nhae : Eq (f aG) aH\nhbe : Eq (f bG) bH\nhuH : UniqueMul (Finset.image (⇑f) A) (Finset.image (⇑f) B) aH bH\nhuG : UniqueMul (Finset.filter (fun a => Eq (f a) aH) A) (Finset.filter (fun b => Eq (f b) bH) B) aG bG\n⊢ UniqueMul A B aG bG","decl":"open Finset in\n@[to_additive]\ntheorem of_image_filter [DecidableEq H]\n    (f : G →ₙ* H) {A B : Finset G} {aG bG : G} {aH bH : H} (hae : f aG = aH) (hbe : f bG = bH)\n    (huH : UniqueMul (A.image f) (B.image f) aH bH)\n    (huG : UniqueMul {a ∈ A | f a = aH} {b ∈ B | f b = bH} aG bG) :\n    UniqueMul A B aG bG := fun a b ha hb he ↦ by\n  specialize huH (mem_image_of_mem _ ha) (mem_image_of_mem _ hb)\n  rw [← map_mul, he, map_mul, hae, hbe] at huH\n  refine huG ?_ ?_ he <;> rw [mem_filter]\n  exacts [⟨ha, (huH rfl).1⟩, ⟨hb, (huH rfl).2⟩]\n\n"}
{"name":"UniqueSums.uniqueAdd_of_nonempty","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Add G\nself : UniqueSums G\nA B : Finset G\na✝¹ : A.Nonempty\na✝ : B.Nonempty\n⊢ Exists fun a0 => And (Membership.mem A a0) (Exists fun b0 => And (Membership.mem B b0) (UniqueAdd A B a0 b0))","decl":"/-- Let `G` be a Type with addition.  `UniqueSums G` asserts that any two non-empty\nfinite subsets of `G` have the `UniqueAdd` property, with respect to some element of their\nsum `A + B`. -/\nclass UniqueSums (G) [Add G] : Prop where\n/-- For `A B` two nonempty finite sets, there always exist `a0 ∈ A, b0 ∈ B` such that\n`UniqueAdd A B a0 b0` -/\n  uniqueAdd_of_nonempty :\n    ∀ {A B : Finset G}, A.Nonempty → B.Nonempty → ∃ a0 ∈ A, ∃ b0 ∈ B, UniqueAdd A B a0 b0\n\n"}
{"name":"UniqueProds.uniqueMul_of_nonempty","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Mul G\nself : UniqueProds G\nA B : Finset G\na✝¹ : A.Nonempty\na✝ : B.Nonempty\n⊢ Exists fun a0 => And (Membership.mem A a0) (Exists fun b0 => And (Membership.mem B b0) (UniqueMul A B a0 b0))","decl":"/-- Let `G` be a Type with multiplication.  `UniqueProds G` asserts that any two non-empty\nfinite subsets of `G` have the `UniqueMul` property, with respect to some element of their\nproduct `A * B`. -/\nclass UniqueProds (G) [Mul G] : Prop where\n/-- For `A B` two nonempty finite sets, there always exist `a0 ∈ A, b0 ∈ B` such that\n`UniqueMul A B a0 b0` -/\n  uniqueMul_of_nonempty :\n    ∀ {A B : Finset G}, A.Nonempty → B.Nonempty → ∃ a0 ∈ A, ∃ b0 ∈ B, UniqueMul A B a0 b0\n\n"}
{"name":"TwoUniqueSums.uniqueAdd_of_one_lt_card","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Add G\nself : TwoUniqueSums G\nA B : Finset G\na✝ : LT.lt 1 (HMul.hMul A.card B.card)\n⊢ Exists fun p1 => And (Membership.mem (SProd.sprod A B) p1) (Exists fun p2 => And (Membership.mem (SProd.sprod A B) p2) (And (Ne p1 p2) (And (UniqueAdd A B p1.1 p1.2) (UniqueAdd A B p2.1 p2.2))))","decl":"/-- Let `G` be a Type with addition. `TwoUniqueSums G` asserts that any two non-empty\nfinite subsets of `G`, at least one of which is not a singleton, possesses at least two pairs\nof elements satisfying the `UniqueAdd` property. -/\nclass TwoUniqueSums (G) [Add G] : Prop where\n/-- For `A B` two finite sets whose product has cardinality at least 2,\n  we can find at least two unique pairs. -/\n  uniqueAdd_of_one_lt_card : ∀ {A B : Finset G}, 1 < #A * #B →\n    ∃ p1 ∈ A ×ˢ B, ∃ p2 ∈ A ×ˢ B, p1 ≠ p2 ∧ UniqueAdd A B p1.1 p1.2 ∧ UniqueAdd A B p2.1 p2.2\n\n"}
{"name":"TwoUniqueProds.uniqueMul_of_one_lt_card","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Mul G\nself : TwoUniqueProds G\nA B : Finset G\na✝ : LT.lt 1 (HMul.hMul A.card B.card)\n⊢ Exists fun p1 => And (Membership.mem (SProd.sprod A B) p1) (Exists fun p2 => And (Membership.mem (SProd.sprod A B) p2) (And (Ne p1 p2) (And (UniqueMul A B p1.1 p1.2) (UniqueMul A B p2.1 p2.2))))","decl":"/-- Let `G` be a Type with multiplication. `TwoUniqueProds G` asserts that any two non-empty\nfinite subsets of `G`, at least one of which is not a singleton, possesses at least two pairs\nof elements satisfying the `UniqueMul` property. -/\nclass TwoUniqueProds (G) [Mul G] : Prop where\n/-- For `A B` two finite sets whose product has cardinality at least 2,\n  we can find at least two unique pairs. -/\n  uniqueMul_of_one_lt_card : ∀ {A B : Finset G}, 1 < #A * #B →\n    ∃ p1 ∈ A ×ˢ B, ∃ p2 ∈ A ×ˢ B, p1 ≠ p2 ∧ UniqueMul A B p1.1 p1.2 ∧ UniqueMul A B p2.1 p2.2\n\n"}
{"name":"uniqueAdd_of_twoUniqueAdd","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Add G\nA B : Finset G\nh : LT.lt 1 (HMul.hMul A.card B.card) → Exists fun p1 => And (Membership.mem (SProd.sprod A B) p1) (Exists fun p2 => And (Membership.mem (SProd.sprod A B) p2) (And (Ne p1 p2) (And (UniqueAdd A B p1.1 p1.2) (UniqueAdd A B p2.1 p2.2))))\nhA : A.Nonempty\nhB : B.Nonempty\n⊢ Exists fun a => And (Membership.mem A a) (Exists fun b => And (Membership.mem B b) (UniqueAdd A B a b))","decl":"@[to_additive]\nlemma uniqueMul_of_twoUniqueMul {G} [Mul G] {A B : Finset G} (h : 1 < #A * #B →\n    ∃ p1 ∈ A ×ˢ B, ∃ p2 ∈ A ×ˢ B, p1 ≠ p2 ∧ UniqueMul A B p1.1 p1.2 ∧ UniqueMul A B p2.1 p2.2)\n    (hA : A.Nonempty) (hB : B.Nonempty) : ∃ a ∈ A, ∃ b ∈ B, UniqueMul A B a b := by\n  by_cases hc : #A ≤ 1 ∧ #B ≤ 1\n  · exact UniqueMul.of_card_le_one hA hB hc.1 hc.2\n  simp_rw [not_and_or, not_le] at hc\n  rw [← Finset.card_pos] at hA hB\n  obtain ⟨p, hp, _, _, _, hu, _⟩ := h (Nat.one_lt_mul_iff.mpr ⟨hA, hB, hc⟩)\n  rw [Finset.mem_product] at hp\n  exact ⟨p.1, hp.1, p.2, hp.2, hu⟩\n\n"}
{"name":"uniqueMul_of_twoUniqueMul","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝ : Mul G\nA B : Finset G\nh : LT.lt 1 (HMul.hMul A.card B.card) → Exists fun p1 => And (Membership.mem (SProd.sprod A B) p1) (Exists fun p2 => And (Membership.mem (SProd.sprod A B) p2) (And (Ne p1 p2) (And (UniqueMul A B p1.1 p1.2) (UniqueMul A B p2.1 p2.2))))\nhA : A.Nonempty\nhB : B.Nonempty\n⊢ Exists fun a => And (Membership.mem A a) (Exists fun b => And (Membership.mem B b) (UniqueMul A B a b))","decl":"@[to_additive]\nlemma uniqueMul_of_twoUniqueMul {G} [Mul G] {A B : Finset G} (h : 1 < #A * #B →\n    ∃ p1 ∈ A ×ˢ B, ∃ p2 ∈ A ×ˢ B, p1 ≠ p2 ∧ UniqueMul A B p1.1 p1.2 ∧ UniqueMul A B p2.1 p2.2)\n    (hA : A.Nonempty) (hB : B.Nonempty) : ∃ a ∈ A, ∃ b ∈ B, UniqueMul A B a b := by\n  by_cases hc : #A ≤ 1 ∧ #B ≤ 1\n  · exact UniqueMul.of_card_le_one hA hB hc.1 hc.2\n  simp_rw [not_and_or, not_le] at hc\n  rw [← Finset.card_pos] at hA hB\n  obtain ⟨p, hp, _, _, _, hu, _⟩ := h (Nat.one_lt_mul_iff.mpr ⟨hA, hB, hc⟩)\n  rw [Finset.mem_product] at hp\n  exact ⟨p.1, hp.1, p.2, hp.2, hu⟩\n\n"}
{"name":"TwoUniqueSums.toUniqueSums","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Add G\ninst✝ : TwoUniqueSums G\n⊢ UniqueSums G","decl":"@[to_additive] instance TwoUniqueProds.toUniqueProds (G) [Mul G] [TwoUniqueProds G] :\n    UniqueProds G where\n  uniqueMul_of_nonempty := uniqueMul_of_twoUniqueMul uniqueMul_of_one_lt_card\n\n"}
{"name":"TwoUniqueProds.toUniqueProds","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Mul G\ninst✝ : TwoUniqueProds G\n⊢ UniqueProds G","decl":"@[to_additive] instance TwoUniqueProds.toUniqueProds (G) [Mul G] [TwoUniqueProds G] :\n    UniqueProds G where\n  uniqueMul_of_nonempty := uniqueMul_of_twoUniqueMul uniqueMul_of_one_lt_card\n\n"}
{"name":"Multiplicative.instUniqueProdsOfUniqueSums","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"M : Type u_1\ninst✝¹ : Add M\ninst✝ : UniqueSums M\n⊢ UniqueProds (Multiplicative M)","decl":"instance {M} [Add M] [UniqueSums M] : UniqueProds (Multiplicative M) where\n  uniqueMul_of_nonempty := UniqueSums.uniqueAdd_of_nonempty (G := M)\n\n"}
{"name":"Multiplicative.instTwoUniqueProdsOfTwoUniqueSums","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"M : Type u_1\ninst✝¹ : Add M\ninst✝ : TwoUniqueSums M\n⊢ TwoUniqueProds (Multiplicative M)","decl":"instance {M} [Add M] [TwoUniqueSums M] : TwoUniqueProds (Multiplicative M) where\n  uniqueMul_of_one_lt_card := TwoUniqueSums.uniqueAdd_of_one_lt_card (G := M)\n\n"}
{"name":"Additive.instUniqueSumsOfUniqueProds","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"M : Type u_1\ninst✝¹ : Mul M\ninst✝ : UniqueProds M\n⊢ UniqueSums (Additive M)","decl":"instance {M} [Mul M] [UniqueProds M] : UniqueSums (Additive M) where\n  uniqueAdd_of_nonempty := UniqueProds.uniqueMul_of_nonempty (G := M)\n\n"}
{"name":"Additive.instTwoUniqueSumsOfTwoUniqueProds","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"M : Type u_1\ninst✝¹ : Mul M\ninst✝ : TwoUniqueProds M\n⊢ TwoUniqueSums (Additive M)","decl":"instance {M} [Mul M] [TwoUniqueProds M] : TwoUniqueSums (Additive M) where\n  uniqueAdd_of_one_lt_card := TwoUniqueProds.uniqueMul_of_one_lt_card (G := M)\n\n"}
{"name":"UniqueSums.of_addHom","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\nH : Type v\ninst✝² : Add G\ninst✝¹ : Add H\nf : AddHom H G\nhf : ∀ ⦃a b c d : H⦄, Eq (HAdd.hAdd a b) (HAdd.hAdd c d) → And (Eq (f a) (f c)) (Eq (f b) (f d)) → And (Eq a c) (Eq b d)\ninst✝ : UniqueSums G\n⊢ UniqueSums H","decl":"@[to_additive] theorem of_mulHom (f : H →ₙ* G)\n    (hf : ∀ ⦃a b c d : H⦄, a * b = c * d → f a = f c ∧ f b = f d → a = c ∧ b = d)\n    [UniqueProds G] : UniqueProds H where\n  uniqueMul_of_nonempty {A B} A0 B0 := by\n    classical\n    obtain ⟨a0, ha0, b0, hb0, h⟩ := uniqueMul_of_nonempty (A0.image f) (B0.image f)\n    obtain ⟨a', ha', rfl⟩ := mem_image.mp ha0\n    obtain ⟨b', hb', rfl⟩ := mem_image.mp hb0\n    exact ⟨a', ha', b', hb', UniqueMul.of_mulHom_image f hf h⟩\n\n"}
{"name":"UniqueProds.of_mulHom","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\nH : Type v\ninst✝² : Mul G\ninst✝¹ : Mul H\nf : MulHom H G\nhf : ∀ ⦃a b c d : H⦄, Eq (HMul.hMul a b) (HMul.hMul c d) → And (Eq (f a) (f c)) (Eq (f b) (f d)) → And (Eq a c) (Eq b d)\ninst✝ : UniqueProds G\n⊢ UniqueProds H","decl":"@[to_additive] theorem of_mulHom (f : H →ₙ* G)\n    (hf : ∀ ⦃a b c d : H⦄, a * b = c * d → f a = f c ∧ f b = f d → a = c ∧ b = d)\n    [UniqueProds G] : UniqueProds H where\n  uniqueMul_of_nonempty {A B} A0 B0 := by\n    classical\n    obtain ⟨a0, ha0, b0, hb0, h⟩ := uniqueMul_of_nonempty (A0.image f) (B0.image f)\n    obtain ⟨a', ha', rfl⟩ := mem_image.mp ha0\n    obtain ⟨b', hb', rfl⟩ := mem_image.mp hb0\n    exact ⟨a', ha', b', hb', UniqueMul.of_mulHom_image f hf h⟩\n\n"}
{"name":"UniqueSums.of_injective_addHom","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\nH : Type v\ninst✝¹ : Add G\ninst✝ : Add H\nf : AddHom H G\nhf : Function.Injective ⇑f\nx✝ : UniqueSums G\n⊢ UniqueSums H","decl":"@[to_additive]\ntheorem of_injective_mulHom (f : H →ₙ* G) (hf : Function.Injective f) (_ : UniqueProds G) :\n    UniqueProds H := of_mulHom f (fun _ _ _ _ _ ↦ .imp (hf ·) (hf ·))\n\n"}
{"name":"UniqueProds.of_injective_mulHom","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\nH : Type v\ninst✝¹ : Mul G\ninst✝ : Mul H\nf : MulHom H G\nhf : Function.Injective ⇑f\nx✝ : UniqueProds G\n⊢ UniqueProds H","decl":"@[to_additive]\ntheorem of_injective_mulHom (f : H →ₙ* G) (hf : Function.Injective f) (_ : UniqueProds G) :\n    UniqueProds H := of_mulHom f (fun _ _ _ _ _ ↦ .imp (hf ·) (hf ·))\n\n"}
{"name":"AddEquiv.uniqueSums_iff","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\nH : Type v\ninst✝¹ : Add G\ninst✝ : Add H\nf : AddEquiv G H\n⊢ Iff (UniqueSums G) (UniqueSums H)","decl":"/-- `UniqueProd` is preserved under multiplicative equivalences. -/\n@[to_additive \"`UniqueSums` is preserved under additive equivalences.\"]\ntheorem _root_.MulEquiv.uniqueProds_iff (f : G ≃* H) : UniqueProds G ↔ UniqueProds H :=\n  ⟨of_injective_mulHom f.symm f.symm.injective, of_injective_mulHom f f.injective⟩\n\n"}
{"name":"MulEquiv.uniqueProds_iff","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\nH : Type v\ninst✝¹ : Mul G\ninst✝ : Mul H\nf : MulEquiv G H\n⊢ Iff (UniqueProds G) (UniqueProds H)","decl":"/-- `UniqueProd` is preserved under multiplicative equivalences. -/\n@[to_additive \"`UniqueSums` is preserved under additive equivalences.\"]\ntheorem _root_.MulEquiv.uniqueProds_iff (f : G ≃* H) : UniqueProds G ↔ UniqueProds H :=\n  ⟨of_injective_mulHom f.symm f.symm.injective, of_injective_mulHom f f.injective⟩\n\n"}
{"name":"UniqueSums.of_addOpposite","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\ninst✝ : Add G\nh : UniqueSums (AddOpposite G)\n⊢ UniqueSums G","decl":"open Finset MulOpposite in\n@[to_additive]\ntheorem of_mulOpposite (h : UniqueProds Gᵐᵒᵖ) : UniqueProds G where\n  uniqueMul_of_nonempty hA hB :=\n    let f : G ↪ Gᵐᵒᵖ := ⟨op, op_injective⟩\n    let ⟨y, yB, x, xA, hxy⟩ := h.uniqueMul_of_nonempty (hB.map (f := f)) (hA.map (f := f))\n    ⟨unop x, (mem_map' _).mp xA, unop y, (mem_map' _).mp yB, hxy.of_mulOpposite⟩\n\n"}
{"name":"UniqueProds.of_mulOpposite","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\ninst✝ : Mul G\nh : UniqueProds (MulOpposite G)\n⊢ UniqueProds G","decl":"open Finset MulOpposite in\n@[to_additive]\ntheorem of_mulOpposite (h : UniqueProds Gᵐᵒᵖ) : UniqueProds G where\n  uniqueMul_of_nonempty hA hB :=\n    let f : G ↪ Gᵐᵒᵖ := ⟨op, op_injective⟩\n    let ⟨y, yB, x, xA, hxy⟩ := h.uniqueMul_of_nonempty (hB.map (f := f)) (hA.map (f := f))\n    ⟨unop x, (mem_map' _).mp xA, unop y, (mem_map' _).mp yB, hxy.of_mulOpposite⟩\n\n"}
{"name":"UniqueProds.instMulOpposite","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\ninst✝ : Mul G\nh : UniqueProds G\n⊢ UniqueProds (MulOpposite G)","decl":"@[to_additive] instance [h : UniqueProds G] : UniqueProds Gᵐᵒᵖ :=\n  of_mulOpposite <| (MulEquiv.opOp G).uniqueProds_iff.mp h\n\n"}
{"name":"UniqueSums.instAddOpposite","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\ninst✝ : Add G\nh : UniqueSums G\n⊢ UniqueSums (AddOpposite G)","decl":"@[to_additive] instance [h : UniqueProds G] : UniqueProds Gᵐᵒᵖ :=\n  of_mulOpposite <| (MulEquiv.opOp G).uniqueProds_iff.mp h\n\n"}
{"name":"UniqueSums.toIsAddCancel","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\ninst✝¹ : Add G\ninst✝ : UniqueSums G\n⊢ IsCancelAdd G","decl":"open MulOpposite in\n@[to_additive] theorem toIsCancelMul [UniqueProds G] : IsCancelMul G where\n  mul_left_cancel := toIsLeftCancelMul.mul_left_cancel\n  mul_right_cancel _ _ _ h :=\n    op_injective <| toIsLeftCancelMul.mul_left_cancel _ _ _ <| unop_injective h\n\n"}
{"name":"UniqueProds.toIsCancelMul","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\ninst✝¹ : Mul G\ninst✝ : UniqueProds G\n⊢ IsCancelMul G","decl":"open MulOpposite in\n@[to_additive] theorem toIsCancelMul [UniqueProds G] : IsCancelMul G where\n  mul_left_cancel := toIsLeftCancelMul.mul_left_cancel\n  mul_right_cancel _ _ _ h :=\n    op_injective <| toIsLeftCancelMul.mul_left_cancel _ _ _ <| unop_injective h\n\n"}
{"name":"UniqueSums.of_same","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddSemigroup G\ninst✝ : IsCancelAdd G\nh : ∀ {A : Finset G}, A.Nonempty → Exists fun a1 => And (Membership.mem A a1) (Exists fun a2 => And (Membership.mem A a2) (UniqueAdd A A a1 a2))\n⊢ UniqueSums G","decl":"/-- `UniqueProds G` says that for any two nonempty `Finset`s `A` and `B` in `G`, `A × B`\n  contains a unique pair with the `UniqueMul` property. Strojnowski showed that if `G` is\n  a group, then we only need to check this when `A = B`.\n  Here we generalize the result to cancellative semigroups.\n  Non-cancellative counterexample: the AddMonoid {0,1} with 1+1=1. -/\n@[to_additive] theorem of_same {G} [Semigroup G] [IsCancelMul G]\n    (h : ∀ {A : Finset G}, A.Nonempty → ∃ a1 ∈ A, ∃ a2 ∈ A, UniqueMul A A a1 a2) :\n    UniqueProds G where\n  uniqueMul_of_nonempty {A B} hA hB := by\n    classical\n    obtain ⟨g1, h1, g2, h2, hu⟩ := h (hB.mul hA)\n    obtain ⟨b1, hb1, a1, ha1, rfl⟩ := mem_mul.mp h1\n    obtain ⟨b2, hb2, a2, ha2, rfl⟩ := mem_mul.mp h2\n    refine ⟨a1, ha1, b2, hb2, fun a b ha hb he => ?_⟩\n    specialize hu (mul_mem_mul hb1 ha) (mul_mem_mul hb ha2) _\n    · rw [mul_assoc b1, ← mul_assoc a, he, mul_assoc a1, ← mul_assoc b1]\n    exact ⟨mul_left_cancel hu.1, mul_right_cancel hu.2⟩\n\n"}
{"name":"UniqueProds.of_same","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Semigroup G\ninst✝ : IsCancelMul G\nh : ∀ {A : Finset G}, A.Nonempty → Exists fun a1 => And (Membership.mem A a1) (Exists fun a2 => And (Membership.mem A a2) (UniqueMul A A a1 a2))\n⊢ UniqueProds G","decl":"/-- `UniqueProds G` says that for any two nonempty `Finset`s `A` and `B` in `G`, `A × B`\n  contains a unique pair with the `UniqueMul` property. Strojnowski showed that if `G` is\n  a group, then we only need to check this when `A = B`.\n  Here we generalize the result to cancellative semigroups.\n  Non-cancellative counterexample: the AddMonoid {0,1} with 1+1=1. -/\n@[to_additive] theorem of_same {G} [Semigroup G] [IsCancelMul G]\n    (h : ∀ {A : Finset G}, A.Nonempty → ∃ a1 ∈ A, ∃ a2 ∈ A, UniqueMul A A a1 a2) :\n    UniqueProds G where\n  uniqueMul_of_nonempty {A B} hA hB := by\n    classical\n    obtain ⟨g1, h1, g2, h2, hu⟩ := h (hB.mul hA)\n    obtain ⟨b1, hb1, a1, ha1, rfl⟩ := mem_mul.mp h1\n    obtain ⟨b2, hb2, a2, ha2, rfl⟩ := mem_mul.mp h2\n    refine ⟨a1, ha1, b2, hb2, fun a b ha hb he => ?_⟩\n    specialize hu (mul_mem_mul hb1 ha) (mul_mem_mul hb ha2) _\n    · rw [mul_assoc b1, ← mul_assoc a, he, mul_assoc a1, ← mul_assoc b1]\n    exact ⟨mul_left_cancel hu.1, mul_right_cancel hu.2⟩\n\n"}
{"name":"UniqueProds.toTwoUniqueProds_of_group","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : UniqueProds G\n⊢ TwoUniqueProds G","decl":"/-- If a group has `UniqueProds`, then it actually has `TwoUniqueProds`.\n  For an example of a semigroup `G` embeddable into a group that has `UniqueProds`\n  but not `TwoUniqueProds`, see Example 10.13 in\n  [J. Okniński, *Semigroup Algebras*][Okninski1991]. -/\n@[to_additive] theorem toTwoUniqueProds_of_group {G}\n    [Group G] [UniqueProds G] : TwoUniqueProds G where\n  uniqueMul_of_one_lt_card {A B} hc := by\n    simp_rw [Nat.one_lt_mul_iff, card_pos] at hc\n    obtain ⟨a, ha, b, hb, hu⟩ := uniqueMul_of_nonempty hc.1 hc.2.1\n    let C := A.map ⟨_, mul_right_injective a⁻¹⟩ -- C = a⁻¹A\n    let D := B.map ⟨_, mul_left_injective b⁻¹⟩  -- D = Bb⁻¹\n    have hcard : 1 < #C ∨ 1 < #D := by simp_rw [C, D, card_map]; exact hc.2.2\n    have hC : 1 ∈ C := mem_map.mpr ⟨a, ha, inv_mul_cancel a⟩\n    have hD : 1 ∈ D := mem_map.mpr ⟨b, hb, mul_inv_cancel b⟩\n    suffices ∃ c ∈ C, ∃ d ∈ D, (c ≠ 1 ∨ d ≠ 1) ∧ UniqueMul C D c d by\n      simp_rw [mem_product]\n      obtain ⟨c, hc, d, hd, hne, hu'⟩ := this\n      obtain ⟨a0, ha0, rfl⟩ := mem_map.mp hc\n      obtain ⟨b0, hb0, rfl⟩ := mem_map.mp hd\n      refine ⟨(_, _), ⟨ha0, hb0⟩, (a, b), ⟨ha, hb⟩, ?_, fun a' b' ha' hb' he => ?_, hu⟩\n      · simp_rw [Function.Embedding.coeFn_mk, Ne, inv_mul_eq_one, mul_inv_eq_one] at hne\n        rwa [Ne, Prod.mk.inj_iff, not_and_or, eq_comm]\n      specialize hu' (mem_map_of_mem _ ha') (mem_map_of_mem _ hb')\n      simp_rw [Function.Embedding.coeFn_mk, mul_left_cancel_iff, mul_right_cancel_iff] at hu'\n      rw [mul_assoc, ← mul_assoc a', he, mul_assoc, mul_assoc] at hu'\n      exact hu' rfl\n    classical\n    let _ := Finset.mul (α := G)              -- E = D⁻¹C, F = DC⁻¹\n    have := uniqueMul_of_nonempty (A := D.image (·⁻¹) * C) (B := D * C.image (·⁻¹)) ?_ ?_\n    · obtain ⟨e, he, f, hf, hu⟩ := this\n      clear_value C D\n      simp only [UniqueMul, mem_mul, mem_image] at he hf hu\n      obtain ⟨_, ⟨d1, hd1, rfl⟩, c1, hc1, rfl⟩ := he\n      obtain ⟨d2, hd2, _, ⟨c2, hc2, rfl⟩, rfl⟩ := hf\n      by_cases h12 : c1 ≠ 1 ∨ d2 ≠ 1\n      · refine ⟨c1, hc1, d2, hd2, h12, fun c3 d3 hc3 hd3 he => ?_⟩\n        specialize hu ⟨_, ⟨_, hd1, rfl⟩, _, hc3, rfl⟩ ⟨_, hd3, _, ⟨_, hc2, rfl⟩, rfl⟩\n        rw [mul_left_cancel_iff, mul_right_cancel_iff,\n            mul_assoc, ← mul_assoc c3, he, mul_assoc, mul_assoc] at hu; exact hu rfl\n      push_neg at h12; obtain ⟨rfl, rfl⟩ := h12\n      by_cases h21 : c2 ≠ 1 ∨ d1 ≠ 1\n      · refine ⟨c2, hc2, d1, hd1, h21, fun c4 d4 hc4 hd4 he => ?_⟩\n        specialize hu ⟨_, ⟨_, hd4, rfl⟩, _, hC, rfl⟩ ⟨_, hD, _, ⟨_, hc4, rfl⟩, rfl⟩\n        simpa only [mul_one, one_mul, ← mul_inv_rev, he, true_imp_iff, inv_inj, and_comm] using hu\n      push_neg at h21; obtain ⟨rfl, rfl⟩ := h21\n      rcases hcard with hC | hD\n      · obtain ⟨c, hc, hc1⟩ := exists_ne_of_one_lt_card hC 1\n        refine (hc1 ?_).elim\n        simpa using hu ⟨_, ⟨_, hD, rfl⟩, _, hc, rfl⟩ ⟨_, hD, _, ⟨_, hc, rfl⟩, rfl⟩\n      · obtain ⟨d, hd, hd1⟩ := exists_ne_of_one_lt_card hD 1\n        refine (hd1 ?_).elim\n        simpa using hu ⟨_, ⟨_, hd, rfl⟩, _, hC, rfl⟩ ⟨_, hd, _, ⟨_, hC, rfl⟩, rfl⟩\n    all_goals apply_rules [Nonempty.mul, Nonempty.image, Finset.Nonempty.map, hc.1, hc.2.1]\n\n"}
{"name":"UniqueSums.toTwoUniqueSums_of_addGroup","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : UniqueSums G\n⊢ TwoUniqueSums G","decl":"/-- If a group has `UniqueProds`, then it actually has `TwoUniqueProds`.\n  For an example of a semigroup `G` embeddable into a group that has `UniqueProds`\n  but not `TwoUniqueProds`, see Example 10.13 in\n  [J. Okniński, *Semigroup Algebras*][Okninski1991]. -/\n@[to_additive] theorem toTwoUniqueProds_of_group {G}\n    [Group G] [UniqueProds G] : TwoUniqueProds G where\n  uniqueMul_of_one_lt_card {A B} hc := by\n    simp_rw [Nat.one_lt_mul_iff, card_pos] at hc\n    obtain ⟨a, ha, b, hb, hu⟩ := uniqueMul_of_nonempty hc.1 hc.2.1\n    let C := A.map ⟨_, mul_right_injective a⁻¹⟩ -- C = a⁻¹A\n    let D := B.map ⟨_, mul_left_injective b⁻¹⟩  -- D = Bb⁻¹\n    have hcard : 1 < #C ∨ 1 < #D := by simp_rw [C, D, card_map]; exact hc.2.2\n    have hC : 1 ∈ C := mem_map.mpr ⟨a, ha, inv_mul_cancel a⟩\n    have hD : 1 ∈ D := mem_map.mpr ⟨b, hb, mul_inv_cancel b⟩\n    suffices ∃ c ∈ C, ∃ d ∈ D, (c ≠ 1 ∨ d ≠ 1) ∧ UniqueMul C D c d by\n      simp_rw [mem_product]\n      obtain ⟨c, hc, d, hd, hne, hu'⟩ := this\n      obtain ⟨a0, ha0, rfl⟩ := mem_map.mp hc\n      obtain ⟨b0, hb0, rfl⟩ := mem_map.mp hd\n      refine ⟨(_, _), ⟨ha0, hb0⟩, (a, b), ⟨ha, hb⟩, ?_, fun a' b' ha' hb' he => ?_, hu⟩\n      · simp_rw [Function.Embedding.coeFn_mk, Ne, inv_mul_eq_one, mul_inv_eq_one] at hne\n        rwa [Ne, Prod.mk.inj_iff, not_and_or, eq_comm]\n      specialize hu' (mem_map_of_mem _ ha') (mem_map_of_mem _ hb')\n      simp_rw [Function.Embedding.coeFn_mk, mul_left_cancel_iff, mul_right_cancel_iff] at hu'\n      rw [mul_assoc, ← mul_assoc a', he, mul_assoc, mul_assoc] at hu'\n      exact hu' rfl\n    classical\n    let _ := Finset.mul (α := G)              -- E = D⁻¹C, F = DC⁻¹\n    have := uniqueMul_of_nonempty (A := D.image (·⁻¹) * C) (B := D * C.image (·⁻¹)) ?_ ?_\n    · obtain ⟨e, he, f, hf, hu⟩ := this\n      clear_value C D\n      simp only [UniqueMul, mem_mul, mem_image] at he hf hu\n      obtain ⟨_, ⟨d1, hd1, rfl⟩, c1, hc1, rfl⟩ := he\n      obtain ⟨d2, hd2, _, ⟨c2, hc2, rfl⟩, rfl⟩ := hf\n      by_cases h12 : c1 ≠ 1 ∨ d2 ≠ 1\n      · refine ⟨c1, hc1, d2, hd2, h12, fun c3 d3 hc3 hd3 he => ?_⟩\n        specialize hu ⟨_, ⟨_, hd1, rfl⟩, _, hc3, rfl⟩ ⟨_, hd3, _, ⟨_, hc2, rfl⟩, rfl⟩\n        rw [mul_left_cancel_iff, mul_right_cancel_iff,\n            mul_assoc, ← mul_assoc c3, he, mul_assoc, mul_assoc] at hu; exact hu rfl\n      push_neg at h12; obtain ⟨rfl, rfl⟩ := h12\n      by_cases h21 : c2 ≠ 1 ∨ d1 ≠ 1\n      · refine ⟨c2, hc2, d1, hd1, h21, fun c4 d4 hc4 hd4 he => ?_⟩\n        specialize hu ⟨_, ⟨_, hd4, rfl⟩, _, hC, rfl⟩ ⟨_, hD, _, ⟨_, hc4, rfl⟩, rfl⟩\n        simpa only [mul_one, one_mul, ← mul_inv_rev, he, true_imp_iff, inv_inj, and_comm] using hu\n      push_neg at h21; obtain ⟨rfl, rfl⟩ := h21\n      rcases hcard with hC | hD\n      · obtain ⟨c, hc, hc1⟩ := exists_ne_of_one_lt_card hC 1\n        refine (hc1 ?_).elim\n        simpa using hu ⟨_, ⟨_, hD, rfl⟩, _, hc, rfl⟩ ⟨_, hD, _, ⟨_, hc, rfl⟩, rfl⟩\n      · obtain ⟨d, hd, hd1⟩ := exists_ne_of_one_lt_card hD 1\n        refine (hd1 ?_).elim\n        simpa using hu ⟨_, ⟨_, hd, rfl⟩, _, hC, rfl⟩ ⟨_, hd, _, ⟨_, hC, rfl⟩, rfl⟩\n    all_goals apply_rules [Nonempty.mul, Nonempty.image, Finset.Nonempty.map, hc.1, hc.2.1]\n\n"}
{"name":"UniqueProds.instForall","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"ι : Type u_2\nG : ι → Type u_1\ninst✝¹ : (i : ι) → Mul (G i)\ninst✝ : ∀ (i : ι), UniqueProds (G i)\n⊢ UniqueProds ((i : ι) → G i)","decl":"open UniqueMul in\n@[to_additive] instance instForall {ι} (G : ι → Type*) [∀ i, Mul (G i)] [∀ i, UniqueProds (G i)] :\n    UniqueProds (∀ i, G i) where\n  uniqueMul_of_nonempty {A} := by\n    classical\n    let _ := isWellFounded_ssubset (α := ∀ i, G i) -- why need this?\n    apply IsWellFounded.induction (· ⊂ ·) A; intro A ihA B hA\n    apply IsWellFounded.induction (· ⊂ ·) B; intro B ihB hB\n    by_cases hc : #A ≤ 1 ∧ #B ≤ 1\n    · exact of_card_le_one hA hB hc.1 hc.2\n    simp_rw [not_and_or, not_le] at hc\n    obtain ⟨i, hc⟩ := exists_or.mpr (hc.imp exists_of_one_lt_card_pi exists_of_one_lt_card_pi)\n    obtain ⟨ai, hA, bi, hB, hi⟩ := uniqueMul_of_nonempty (hA.image (· i)) (hB.image (· i))\n    rw [mem_image, ← filter_nonempty_iff] at hA hB\n    let A' := {a ∈ A | a i = ai}; let B' := {b ∈ B | b i = bi}\n    obtain ⟨a0, ha0, b0, hb0, hu⟩ : ∃ a0 ∈ A', ∃ b0 ∈ B', UniqueMul A' B' a0 b0 := by\n      rcases hc with hc | hc; · exact ihA A' (hc.2 ai) hA hB\n      by_cases hA' : A' = A\n      · rw [hA']\n        exact ihB B' (hc.2 bi) hB\n      · exact ihA A' ((A.filter_subset _).ssubset_of_ne hA') hA hB\n    rw [mem_filter] at ha0 hb0\n    exact ⟨a0, ha0.1, b0, hb0.1, of_image_filter (Pi.evalMulHom G i) ha0.2 hb0.2 hi hu⟩\n\n"}
{"name":"UniqueSums.instForall","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"ι : Type u_2\nG : ι → Type u_1\ninst✝¹ : (i : ι) → Add (G i)\ninst✝ : ∀ (i : ι), UniqueSums (G i)\n⊢ UniqueSums ((i : ι) → G i)","decl":"open UniqueMul in\n@[to_additive] instance instForall {ι} (G : ι → Type*) [∀ i, Mul (G i)] [∀ i, UniqueProds (G i)] :\n    UniqueProds (∀ i, G i) where\n  uniqueMul_of_nonempty {A} := by\n    classical\n    let _ := isWellFounded_ssubset (α := ∀ i, G i) -- why need this?\n    apply IsWellFounded.induction (· ⊂ ·) A; intro A ihA B hA\n    apply IsWellFounded.induction (· ⊂ ·) B; intro B ihB hB\n    by_cases hc : #A ≤ 1 ∧ #B ≤ 1\n    · exact of_card_le_one hA hB hc.1 hc.2\n    simp_rw [not_and_or, not_le] at hc\n    obtain ⟨i, hc⟩ := exists_or.mpr (hc.imp exists_of_one_lt_card_pi exists_of_one_lt_card_pi)\n    obtain ⟨ai, hA, bi, hB, hi⟩ := uniqueMul_of_nonempty (hA.image (· i)) (hB.image (· i))\n    rw [mem_image, ← filter_nonempty_iff] at hA hB\n    let A' := {a ∈ A | a i = ai}; let B' := {b ∈ B | b i = bi}\n    obtain ⟨a0, ha0, b0, hb0, hu⟩ : ∃ a0 ∈ A', ∃ b0 ∈ B', UniqueMul A' B' a0 b0 := by\n      rcases hc with hc | hc; · exact ihA A' (hc.2 ai) hA hB\n      by_cases hA' : A' = A\n      · rw [hA']\n        exact ihB B' (hc.2 bi) hB\n      · exact ihA A' ((A.filter_subset _).ssubset_of_ne hA') hA hB\n    rw [mem_filter] at ha0 hb0\n    exact ⟨a0, ha0.1, b0, hb0.1, of_image_filter (Pi.evalMulHom G i) ha0.2 hb0.2 hi hu⟩\n\n"}
{"name":"UniqueProds.instProd","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\nH : Type v\ninst✝³ : Mul G\ninst✝² : Mul H\ninst✝¹ : UniqueProds G\ninst✝ : UniqueProds H\n⊢ UniqueProds (Prod G H)","decl":"open ULift in\n@[to_additive] instance [UniqueProds G] [UniqueProds H] : UniqueProds (G × H) := by\n  have : ∀ b, UniqueProds (I G H b) := Bool.rec ?_ ?_\n  · exact of_injective_mulHom (downMulHom H) down_injective ‹_›\n  · refine of_injective_mulHom (Prod.upMulHom G H) (fun x y he => Prod.ext ?_ ?_)\n      (UniqueProds.instForall <| I G H) <;> apply up_injective\n    exacts [congr_fun he false, congr_fun he true]\n  · exact of_injective_mulHom (downMulHom G) down_injective ‹_›\n\n"}
{"name":"UniqueSums.instSum","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\nH : Type v\ninst✝³ : Add G\ninst✝² : Add H\ninst✝¹ : UniqueSums G\ninst✝ : UniqueSums H\n⊢ UniqueSums (Prod G H)","decl":"open ULift in\n@[to_additive] instance [UniqueProds G] [UniqueProds H] : UniqueProds (G × H) := by\n  have : ∀ b, UniqueProds (I G H b) := Bool.rec ?_ ?_\n  · exact of_injective_mulHom (downMulHom H) down_injective ‹_›\n  · refine of_injective_mulHom (Prod.upMulHom G H) (fun x y he => Prod.ext ?_ ?_)\n      (UniqueProds.instForall <| I G H) <;> apply up_injective\n    exacts [congr_fun he false, congr_fun he true]\n  · exact of_injective_mulHom (downMulHom G) down_injective ‹_›\n\n"}
{"name":"instUniqueSumsDFinsupp","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"ι : Type u_2\nG : ι → Type u_1\ninst✝¹ : (i : ι) → AddZeroClass (G i)\ninst✝ : ∀ (i : ι), UniqueSums (G i)\n⊢ UniqueSums (DFinsupp fun i => G i)","decl":"instance {ι} (G : ι → Type*) [∀ i, AddZeroClass (G i)] [∀ i, UniqueSums (G i)] :\n    UniqueSums (Π₀ i, G i) :=\n  UniqueSums.of_injective_addHom\n    DFinsupp.coeFnAddMonoidHom.toAddHom DFunLike.coe_injective inferInstance\n\n"}
{"name":"instUniqueSumsFinsupp","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"ι : Type u_1\nG : Type u_2\ninst✝¹ : AddZeroClass G\ninst✝ : UniqueSums G\n⊢ UniqueSums (Finsupp ι G)","decl":"instance {ι G} [AddZeroClass G] [UniqueSums G] : UniqueSums (ι →₀ G) :=\n  UniqueSums.of_injective_addHom\n    Finsupp.coeFnAddHom.toAddHom DFunLike.coe_injective inferInstance\n\n"}
{"name":"TwoUniqueSums.of_addHom","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\nH : Type v\ninst✝² : Add G\ninst✝¹ : Add H\nf : AddHom H G\nhf : ∀ ⦃a b c d : H⦄, Eq (HAdd.hAdd a b) (HAdd.hAdd c d) → And (Eq (f a) (f c)) (Eq (f b) (f d)) → And (Eq a c) (Eq b d)\ninst✝ : TwoUniqueSums G\n⊢ TwoUniqueSums H","decl":"@[to_additive] theorem of_mulHom (f : H →ₙ* G)\n    (hf : ∀ ⦃a b c d : H⦄, a * b = c * d → f a = f c ∧ f b = f d → a = c ∧ b = d)\n    [TwoUniqueProds G] : TwoUniqueProds H where\n  uniqueMul_of_one_lt_card {A B} hc := by\n    classical\n    obtain hc' | hc' := lt_or_le 1 (#(A.image f) * #(B.image f))\n    · obtain ⟨⟨a1, b1⟩, h1, ⟨a2, b2⟩, h2, hne, hu1, hu2⟩ := uniqueMul_of_one_lt_card hc'\n      simp_rw [mem_product, mem_image] at h1 h2 ⊢\n      obtain ⟨⟨a1, ha1, rfl⟩, b1, hb1, rfl⟩ := h1\n      obtain ⟨⟨a2, ha2, rfl⟩, b2, hb2, rfl⟩ := h2\n      exact ⟨(a1, b1), ⟨ha1, hb1⟩, (a2, b2), ⟨ha2, hb2⟩, mt (congr_arg (Prod.map f f)) hne,\n        UniqueMul.of_mulHom_image f hf hu1, UniqueMul.of_mulHom_image f hf hu2⟩\n    rw [← card_product] at hc hc'\n    obtain ⟨p1, h1, p2, h2, hne⟩ := one_lt_card_iff_nontrivial.mp hc\n    refine ⟨p1, h1, p2, h2, hne, ?_⟩\n    cases mem_product.mp h1; cases mem_product.mp h2\n    constructor <;> refine UniqueMul.of_mulHom_image f hf\n      ((UniqueMul.iff_card_le_one ?_ ?_).mpr <| (card_filter_le _ _).trans hc') <;>\n    apply mem_image_of_mem <;> assumption\n\n"}
{"name":"TwoUniqueProds.of_mulHom","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\nH : Type v\ninst✝² : Mul G\ninst✝¹ : Mul H\nf : MulHom H G\nhf : ∀ ⦃a b c d : H⦄, Eq (HMul.hMul a b) (HMul.hMul c d) → And (Eq (f a) (f c)) (Eq (f b) (f d)) → And (Eq a c) (Eq b d)\ninst✝ : TwoUniqueProds G\n⊢ TwoUniqueProds H","decl":"@[to_additive] theorem of_mulHom (f : H →ₙ* G)\n    (hf : ∀ ⦃a b c d : H⦄, a * b = c * d → f a = f c ∧ f b = f d → a = c ∧ b = d)\n    [TwoUniqueProds G] : TwoUniqueProds H where\n  uniqueMul_of_one_lt_card {A B} hc := by\n    classical\n    obtain hc' | hc' := lt_or_le 1 (#(A.image f) * #(B.image f))\n    · obtain ⟨⟨a1, b1⟩, h1, ⟨a2, b2⟩, h2, hne, hu1, hu2⟩ := uniqueMul_of_one_lt_card hc'\n      simp_rw [mem_product, mem_image] at h1 h2 ⊢\n      obtain ⟨⟨a1, ha1, rfl⟩, b1, hb1, rfl⟩ := h1\n      obtain ⟨⟨a2, ha2, rfl⟩, b2, hb2, rfl⟩ := h2\n      exact ⟨(a1, b1), ⟨ha1, hb1⟩, (a2, b2), ⟨ha2, hb2⟩, mt (congr_arg (Prod.map f f)) hne,\n        UniqueMul.of_mulHom_image f hf hu1, UniqueMul.of_mulHom_image f hf hu2⟩\n    rw [← card_product] at hc hc'\n    obtain ⟨p1, h1, p2, h2, hne⟩ := one_lt_card_iff_nontrivial.mp hc\n    refine ⟨p1, h1, p2, h2, hne, ?_⟩\n    cases mem_product.mp h1; cases mem_product.mp h2\n    constructor <;> refine UniqueMul.of_mulHom_image f hf\n      ((UniqueMul.iff_card_le_one ?_ ?_).mpr <| (card_filter_le _ _).trans hc') <;>\n    apply mem_image_of_mem <;> assumption\n\n"}
{"name":"TwoUniqueSums.of_injective_addHom","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\nH : Type v\ninst✝¹ : Add G\ninst✝ : Add H\nf : AddHom H G\nhf : Function.Injective ⇑f\nx✝ : TwoUniqueSums G\n⊢ TwoUniqueSums H","decl":"@[to_additive]\ntheorem of_injective_mulHom (f : H →ₙ* G) (hf : Function.Injective f)\n    (_ : TwoUniqueProds G) : TwoUniqueProds H :=\n  of_mulHom f (fun _ _ _ _ _ ↦ .imp (hf ·) (hf ·))\n\n"}
{"name":"TwoUniqueProds.of_injective_mulHom","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\nH : Type v\ninst✝¹ : Mul G\ninst✝ : Mul H\nf : MulHom H G\nhf : Function.Injective ⇑f\nx✝ : TwoUniqueProds G\n⊢ TwoUniqueProds H","decl":"@[to_additive]\ntheorem of_injective_mulHom (f : H →ₙ* G) (hf : Function.Injective f)\n    (_ : TwoUniqueProds G) : TwoUniqueProds H :=\n  of_mulHom f (fun _ _ _ _ _ ↦ .imp (hf ·) (hf ·))\n\n"}
{"name":"MulEquiv.twoUniqueProds_iff","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\nH : Type v\ninst✝¹ : Mul G\ninst✝ : Mul H\nf : MulEquiv G H\n⊢ Iff (TwoUniqueProds G) (TwoUniqueProds H)","decl":"/-- `TwoUniqueProd` is preserved under multiplicative equivalences. -/\n@[to_additive \"`TwoUniqueSums` is preserved under additive equivalences.\"]\ntheorem _root_.MulEquiv.twoUniqueProds_iff (f : G ≃* H) : TwoUniqueProds G ↔ TwoUniqueProds H :=\n  ⟨of_injective_mulHom f.symm f.symm.injective, of_injective_mulHom f f.injective⟩\n\n"}
{"name":"AddEquiv.twoUniqueSums_iff","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\nH : Type v\ninst✝¹ : Add G\ninst✝ : Add H\nf : AddEquiv G H\n⊢ Iff (TwoUniqueSums G) (TwoUniqueSums H)","decl":"/-- `TwoUniqueProd` is preserved under multiplicative equivalences. -/\n@[to_additive \"`TwoUniqueSums` is preserved under additive equivalences.\"]\ntheorem _root_.MulEquiv.twoUniqueProds_iff (f : G ≃* H) : TwoUniqueProds G ↔ TwoUniqueProds H :=\n  ⟨of_injective_mulHom f.symm f.symm.injective, of_injective_mulHom f f.injective⟩\n\n"}
{"name":"TwoUniqueSums.instForall","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"ι : Type u_2\nG : ι → Type u_1\ninst✝¹ : (i : ι) → Add (G i)\ninst✝ : ∀ (i : ι), TwoUniqueSums (G i)\n⊢ TwoUniqueSums ((i : ι) → G i)","decl":"@[to_additive]\ninstance instForall {ι} (G : ι → Type*) [∀ i, Mul (G i)] [∀ i, TwoUniqueProds (G i)] :\n    TwoUniqueProds (∀ i, G i) where\n  uniqueMul_of_one_lt_card {A} := by\n    classical\n    let _ := isWellFounded_ssubset (α := ∀ i, G i) -- why need this?\n    apply IsWellFounded.induction (· ⊂ ·) A; intro A ihA B\n    apply IsWellFounded.induction (· ⊂ ·) B; intro B ihB hc\n    obtain ⟨hA, hB, hc⟩ := Nat.one_lt_mul_iff.mp hc\n    rw [card_pos] at hA hB\n    obtain ⟨i, hc⟩ := exists_or.mpr (hc.imp exists_of_one_lt_card_pi exists_of_one_lt_card_pi)\n    obtain ⟨p1, h1, p2, h2, hne, hi1, hi2⟩ := uniqueMul_of_one_lt_card (Nat.one_lt_mul_iff.mpr\n      ⟨card_pos.2 (hA.image _), card_pos.2 (hB.image _), hc.imp And.left And.left⟩)\n    simp_rw [mem_product, mem_image, ← filter_nonempty_iff] at h1 h2\n    replace h1 := uniqueMul_of_twoUniqueMul ?_ h1.1 h1.2\n    on_goal 1 => replace h2 := uniqueMul_of_twoUniqueMul ?_ h2.1 h2.2\n\n    · obtain ⟨a1, ha1, b1, hb1, hu1⟩ := h1\n      obtain ⟨a2, ha2, b2, hb2, hu2⟩ := h2\n      rw [mem_filter] at ha1 hb1 ha2 hb2\n      simp_rw [mem_product]\n      refine ⟨(a1, b1), ⟨ha1.1, hb1.1⟩, (a2, b2), ⟨ha2.1, hb2.1⟩, ?_,\n        UniqueMul.of_image_filter (Pi.evalMulHom G i) ha1.2 hb1.2 hi1 hu1,\n        UniqueMul.of_image_filter (Pi.evalMulHom G i) ha2.2 hb2.2 hi2 hu2⟩\n      contrapose! hne; rw [Prod.mk.inj_iff] at hne ⊢\n      rw [← ha1.2, ← hb1.2, ← ha2.2, ← hb2.2, hne.1, hne.2]; exact ⟨rfl, rfl⟩\n    all_goals rcases hc with hc | hc; · exact ihA _ (hc.2 _)\n    · by_cases hA : {a ∈ A | a i = p2.1} = A\n      · rw [hA]\n        exact ihB _ (hc.2 _)\n      · exact ihA _ ((A.filter_subset _).ssubset_of_ne hA)\n    · by_cases hA : {a ∈ A | a i = p1.1} = A\n      · rw [hA]\n        exact ihB _ (hc.2 _)\n      · exact ihA _ ((A.filter_subset _).ssubset_of_ne hA)\n\n"}
{"name":"TwoUniqueProds.instForall","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"ι : Type u_2\nG : ι → Type u_1\ninst✝¹ : (i : ι) → Mul (G i)\ninst✝ : ∀ (i : ι), TwoUniqueProds (G i)\n⊢ TwoUniqueProds ((i : ι) → G i)","decl":"@[to_additive]\ninstance instForall {ι} (G : ι → Type*) [∀ i, Mul (G i)] [∀ i, TwoUniqueProds (G i)] :\n    TwoUniqueProds (∀ i, G i) where\n  uniqueMul_of_one_lt_card {A} := by\n    classical\n    let _ := isWellFounded_ssubset (α := ∀ i, G i) -- why need this?\n    apply IsWellFounded.induction (· ⊂ ·) A; intro A ihA B\n    apply IsWellFounded.induction (· ⊂ ·) B; intro B ihB hc\n    obtain ⟨hA, hB, hc⟩ := Nat.one_lt_mul_iff.mp hc\n    rw [card_pos] at hA hB\n    obtain ⟨i, hc⟩ := exists_or.mpr (hc.imp exists_of_one_lt_card_pi exists_of_one_lt_card_pi)\n    obtain ⟨p1, h1, p2, h2, hne, hi1, hi2⟩ := uniqueMul_of_one_lt_card (Nat.one_lt_mul_iff.mpr\n      ⟨card_pos.2 (hA.image _), card_pos.2 (hB.image _), hc.imp And.left And.left⟩)\n    simp_rw [mem_product, mem_image, ← filter_nonempty_iff] at h1 h2\n    replace h1 := uniqueMul_of_twoUniqueMul ?_ h1.1 h1.2\n    on_goal 1 => replace h2 := uniqueMul_of_twoUniqueMul ?_ h2.1 h2.2\n\n    · obtain ⟨a1, ha1, b1, hb1, hu1⟩ := h1\n      obtain ⟨a2, ha2, b2, hb2, hu2⟩ := h2\n      rw [mem_filter] at ha1 hb1 ha2 hb2\n      simp_rw [mem_product]\n      refine ⟨(a1, b1), ⟨ha1.1, hb1.1⟩, (a2, b2), ⟨ha2.1, hb2.1⟩, ?_,\n        UniqueMul.of_image_filter (Pi.evalMulHom G i) ha1.2 hb1.2 hi1 hu1,\n        UniqueMul.of_image_filter (Pi.evalMulHom G i) ha2.2 hb2.2 hi2 hu2⟩\n      contrapose! hne; rw [Prod.mk.inj_iff] at hne ⊢\n      rw [← ha1.2, ← hb1.2, ← ha2.2, ← hb2.2, hne.1, hne.2]; exact ⟨rfl, rfl⟩\n    all_goals rcases hc with hc | hc; · exact ihA _ (hc.2 _)\n    · by_cases hA : {a ∈ A | a i = p2.1} = A\n      · rw [hA]\n        exact ihB _ (hc.2 _)\n      · exact ihA _ ((A.filter_subset _).ssubset_of_ne hA)\n    · by_cases hA : {a ∈ A | a i = p1.1} = A\n      · rw [hA]\n        exact ihB _ (hc.2 _)\n      · exact ihA _ ((A.filter_subset _).ssubset_of_ne hA)\n\n"}
{"name":"TwoUniqueProds.instProd","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\nH : Type v\ninst✝³ : Mul G\ninst✝² : Mul H\ninst✝¹ : TwoUniqueProds G\ninst✝ : TwoUniqueProds H\n⊢ TwoUniqueProds (Prod G H)","decl":"open ULift in\n@[to_additive] instance [TwoUniqueProds G] [TwoUniqueProds H] : TwoUniqueProds (G × H) := by\n  have : ∀ b, TwoUniqueProds (I G H b) := Bool.rec ?_ ?_\n  · exact of_injective_mulHom (downMulHom H) down_injective ‹_›\n  · refine of_injective_mulHom (Prod.upMulHom G H) (fun x y he ↦ Prod.ext ?_ ?_)\n      (TwoUniqueProds.instForall <| I G H) <;> apply up_injective\n    exacts [congr_fun he false, congr_fun he true]\n  · exact of_injective_mulHom (downMulHom G) down_injective ‹_›\n\n"}
{"name":"TwoUniqueSums.instSum","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\nH : Type v\ninst✝³ : Add G\ninst✝² : Add H\ninst✝¹ : TwoUniqueSums G\ninst✝ : TwoUniqueSums H\n⊢ TwoUniqueSums (Prod G H)","decl":"open ULift in\n@[to_additive] instance [TwoUniqueProds G] [TwoUniqueProds H] : TwoUniqueProds (G × H) := by\n  have : ∀ b, TwoUniqueProds (I G H b) := Bool.rec ?_ ?_\n  · exact of_injective_mulHom (downMulHom H) down_injective ‹_›\n  · refine of_injective_mulHom (Prod.upMulHom G H) (fun x y he ↦ Prod.ext ?_ ?_)\n      (TwoUniqueProds.instForall <| I G H) <;> apply up_injective\n    exacts [congr_fun he false, congr_fun he true]\n  · exact of_injective_mulHom (downMulHom G) down_injective ‹_›\n\n"}
{"name":"TwoUniqueSums.of_addOpposite","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\ninst✝ : Add G\nh : TwoUniqueSums (AddOpposite G)\n⊢ TwoUniqueSums G","decl":"open MulOpposite in\n@[to_additive]\ntheorem of_mulOpposite (h : TwoUniqueProds Gᵐᵒᵖ) : TwoUniqueProds G where\n  uniqueMul_of_one_lt_card hc := by\n    let f : G ↪ Gᵐᵒᵖ := ⟨op, op_injective⟩\n    rw [← card_map f, ← card_map f, mul_comm] at hc\n    obtain ⟨p1, h1, p2, h2, hne, hu1, hu2⟩ := h.uniqueMul_of_one_lt_card hc\n    simp_rw [mem_product] at h1 h2 ⊢\n    refine ⟨(_, _), ⟨?_, ?_⟩, (_, _), ⟨?_, ?_⟩, ?_, hu1.of_mulOpposite, hu2.of_mulOpposite⟩\n    pick_goal 5\n    · contrapose! hne; rw [Prod.ext_iff] at hne ⊢\n      exact ⟨unop_injective hne.2, unop_injective hne.1⟩\n    all_goals apply (mem_map' f).mp\n    exacts [h1.2, h1.1, h2.2, h2.1]\n\n"}
{"name":"TwoUniqueProds.of_mulOpposite","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\ninst✝ : Mul G\nh : TwoUniqueProds (MulOpposite G)\n⊢ TwoUniqueProds G","decl":"open MulOpposite in\n@[to_additive]\ntheorem of_mulOpposite (h : TwoUniqueProds Gᵐᵒᵖ) : TwoUniqueProds G where\n  uniqueMul_of_one_lt_card hc := by\n    let f : G ↪ Gᵐᵒᵖ := ⟨op, op_injective⟩\n    rw [← card_map f, ← card_map f, mul_comm] at hc\n    obtain ⟨p1, h1, p2, h2, hne, hu1, hu2⟩ := h.uniqueMul_of_one_lt_card hc\n    simp_rw [mem_product] at h1 h2 ⊢\n    refine ⟨(_, _), ⟨?_, ?_⟩, (_, _), ⟨?_, ?_⟩, ?_, hu1.of_mulOpposite, hu2.of_mulOpposite⟩\n    pick_goal 5\n    · contrapose! hne; rw [Prod.ext_iff] at hne ⊢\n      exact ⟨unop_injective hne.2, unop_injective hne.1⟩\n    all_goals apply (mem_map' f).mp\n    exacts [h1.2, h1.1, h2.2, h2.1]\n\n"}
{"name":"TwoUniqueSums.instAddOpposite","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\ninst✝ : Add G\nh : TwoUniqueSums G\n⊢ TwoUniqueSums (AddOpposite G)","decl":"@[to_additive] instance [h : TwoUniqueProds G] : TwoUniqueProds Gᵐᵒᵖ :=\n  of_mulOpposite <| (MulEquiv.opOp G).twoUniqueProds_iff.mp h\n\n-- see Note [lower instance priority]\n"}
{"name":"TwoUniqueProds.instMulOpposite","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\ninst✝ : Mul G\nh : TwoUniqueProds G\n⊢ TwoUniqueProds (MulOpposite G)","decl":"@[to_additive] instance [h : TwoUniqueProds G] : TwoUniqueProds Gᵐᵒᵖ :=\n  of_mulOpposite <| (MulEquiv.opOp G).twoUniqueProds_iff.mp h\n\n-- see Note [lower instance priority]\n"}
{"name":"TwoUniqueSums.of_covariant_right","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\ninst✝³ : Add G\ninst✝² : IsRightCancelAdd G\ninst✝¹ : LinearOrder G\ninst✝ : AddLeftStrictMono G\n⊢ TwoUniqueSums G","decl":"/-- This instance asserts that if `G` has a right-cancellative multiplication, a linear order, and\n  multiplication is strictly monotone w.r.t. the second argument, then `G` has `TwoUniqueProds`. -/\n@[to_additive\n  \"This instance asserts that if `G` has a right-cancellative addition, a linear order,\n  and addition is strictly monotone w.r.t. the second argument, then `G` has `TwoUniqueSums`.\" ]\ninstance (priority := 100) of_covariant_right [IsRightCancelMul G]\n    [LinearOrder G] [MulLeftStrictMono G] :\n    TwoUniqueProds G where\n  uniqueMul_of_one_lt_card {A B} hc := by\n    obtain ⟨hA, hB, -⟩ := Nat.one_lt_mul_iff.mp hc\n    rw [card_pos] at hA hB\n    rw [← card_product] at hc\n    obtain ⟨a0, ha0, b0, hb0, he0⟩ := mem_mul.mp (max'_mem _ <| hA.mul hB)\n    obtain ⟨a1, ha1, b1, hb1, he1⟩ := mem_mul.mp (min'_mem _ <| hA.mul hB)\n    have : UniqueMul A B a0 b0 := by\n      intro a b ha hb he\n      obtain hl | rfl | hl := lt_trichotomy b b0\n      · exact ((he0 ▸ he ▸ mul_lt_mul_left' hl a).not_le <| le_max' _ _ <| mul_mem_mul ha hb0).elim\n      · exact ⟨mul_right_cancel he, rfl⟩\n      · exact ((he0 ▸ mul_lt_mul_left' hl a0).not_le <| le_max' _ _ <| mul_mem_mul ha0 hb).elim\n    refine ⟨_, mk_mem_product ha0 hb0, _, mk_mem_product ha1 hb1, fun he ↦ ?_, this, ?_⟩\n    · rw [Prod.mk.inj_iff] at he; rw [he.1, he.2, he1] at he0\n      obtain ⟨⟨a2, b2⟩, h2, hne⟩ := exists_ne_of_one_lt_card hc (a0, b0)\n      rw [mem_product] at h2\n      refine (min'_lt_max' _ (mul_mem_mul ha0 hb0) (mul_mem_mul h2.1 h2.2) fun he ↦ hne ?_).ne he0\n      exact Prod.ext_iff.mpr (this h2.1 h2.2 he.symm)\n    · intro a b ha hb he\n      obtain hl | rfl | hl := lt_trichotomy b b1\n      · exact ((he1 ▸ mul_lt_mul_left' hl a1).not_le <| min'_le _ _ <| mul_mem_mul ha1 hb).elim\n      · exact ⟨mul_right_cancel he, rfl⟩\n      · exact ((he1 ▸ he ▸ mul_lt_mul_left' hl a).not_le <| min'_le _ _ <| mul_mem_mul ha hb1).elim\n\n"}
{"name":"TwoUniqueProds.of_covariant_right","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\ninst✝³ : Mul G\ninst✝² : IsRightCancelMul G\ninst✝¹ : LinearOrder G\ninst✝ : MulLeftStrictMono G\n⊢ TwoUniqueProds G","decl":"/-- This instance asserts that if `G` has a right-cancellative multiplication, a linear order, and\n  multiplication is strictly monotone w.r.t. the second argument, then `G` has `TwoUniqueProds`. -/\n@[to_additive\n  \"This instance asserts that if `G` has a right-cancellative addition, a linear order,\n  and addition is strictly monotone w.r.t. the second argument, then `G` has `TwoUniqueSums`.\" ]\ninstance (priority := 100) of_covariant_right [IsRightCancelMul G]\n    [LinearOrder G] [MulLeftStrictMono G] :\n    TwoUniqueProds G where\n  uniqueMul_of_one_lt_card {A B} hc := by\n    obtain ⟨hA, hB, -⟩ := Nat.one_lt_mul_iff.mp hc\n    rw [card_pos] at hA hB\n    rw [← card_product] at hc\n    obtain ⟨a0, ha0, b0, hb0, he0⟩ := mem_mul.mp (max'_mem _ <| hA.mul hB)\n    obtain ⟨a1, ha1, b1, hb1, he1⟩ := mem_mul.mp (min'_mem _ <| hA.mul hB)\n    have : UniqueMul A B a0 b0 := by\n      intro a b ha hb he\n      obtain hl | rfl | hl := lt_trichotomy b b0\n      · exact ((he0 ▸ he ▸ mul_lt_mul_left' hl a).not_le <| le_max' _ _ <| mul_mem_mul ha hb0).elim\n      · exact ⟨mul_right_cancel he, rfl⟩\n      · exact ((he0 ▸ mul_lt_mul_left' hl a0).not_le <| le_max' _ _ <| mul_mem_mul ha0 hb).elim\n    refine ⟨_, mk_mem_product ha0 hb0, _, mk_mem_product ha1 hb1, fun he ↦ ?_, this, ?_⟩\n    · rw [Prod.mk.inj_iff] at he; rw [he.1, he.2, he1] at he0\n      obtain ⟨⟨a2, b2⟩, h2, hne⟩ := exists_ne_of_one_lt_card hc (a0, b0)\n      rw [mem_product] at h2\n      refine (min'_lt_max' _ (mul_mem_mul ha0 hb0) (mul_mem_mul h2.1 h2.2) fun he ↦ hne ?_).ne he0\n      exact Prod.ext_iff.mpr (this h2.1 h2.2 he.symm)\n    · intro a b ha hb he\n      obtain hl | rfl | hl := lt_trichotomy b b1\n      · exact ((he1 ▸ mul_lt_mul_left' hl a1).not_le <| min'_le _ _ <| mul_mem_mul ha1 hb).elim\n      · exact ⟨mul_right_cancel he, rfl⟩\n      · exact ((he1 ▸ he ▸ mul_lt_mul_left' hl a).not_le <| min'_le _ _ <| mul_mem_mul ha hb1).elim\n\n"}
{"name":"TwoUniqueProds.of_covariant_left","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\ninst✝³ : Mul G\ninst✝² : IsLeftCancelMul G\ninst✝¹ : LinearOrder G\ninst✝ : MulRightStrictMono G\n⊢ TwoUniqueProds G","decl":"open MulOpposite in\n-- see Note [lower instance priority]\n/-- This instance asserts that if `G` has a left-cancellative multiplication, a linear order, and\n  multiplication is strictly monotone w.r.t. the first argument, then `G` has `TwoUniqueProds`. -/\n@[to_additive\n  \"This instance asserts that if `G` has a left-cancellative addition, a linear order, and\n  addition is strictly monotone w.r.t. the first argument, then `G` has `TwoUniqueSums`.\" ]\ninstance (priority := 100) of_covariant_left [IsLeftCancelMul G]\n    [LinearOrder G] [MulRightStrictMono G] :\n    TwoUniqueProds G :=\n  let _ := LinearOrder.lift' (unop : Gᵐᵒᵖ → G) unop_injective\n  let _ : MulLeftStrictMono Gᵐᵒᵖ :=\n    { elim := fun _ _ _ bc ↦ mul_lt_mul_right' (α := G) bc (unop _) }\n  of_mulOpposite of_covariant_right\n\n"}
{"name":"TwoUniqueSums.of_covariant_left","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"G : Type u\ninst✝³ : Add G\ninst✝² : IsLeftCancelAdd G\ninst✝¹ : LinearOrder G\ninst✝ : AddRightStrictMono G\n⊢ TwoUniqueSums G","decl":"open MulOpposite in\n-- see Note [lower instance priority]\n/-- This instance asserts that if `G` has a left-cancellative multiplication, a linear order, and\n  multiplication is strictly monotone w.r.t. the first argument, then `G` has `TwoUniqueProds`. -/\n@[to_additive\n  \"This instance asserts that if `G` has a left-cancellative addition, a linear order, and\n  addition is strictly monotone w.r.t. the first argument, then `G` has `TwoUniqueSums`.\" ]\ninstance (priority := 100) of_covariant_left [IsLeftCancelMul G]\n    [LinearOrder G] [MulRightStrictMono G] :\n    TwoUniqueProds G :=\n  let _ := LinearOrder.lift' (unop : Gᵐᵒᵖ → G) unop_injective\n  let _ : MulLeftStrictMono Gᵐᵒᵖ :=\n    { elim := fun _ _ _ bc ↦ mul_lt_mul_right' (α := G) bc (unop _) }\n  of_mulOpposite of_covariant_right\n\n"}
{"name":"instTwoUniqueSumsDFinsupp","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"ι : Type u_2\nG : ι → Type u_1\ninst✝¹ : (i : ι) → AddZeroClass (G i)\ninst✝ : ∀ (i : ι), TwoUniqueSums (G i)\n⊢ TwoUniqueSums (DFinsupp fun i => G i)","decl":"instance {ι} (G : ι → Type*) [∀ i, AddZeroClass (G i)] [∀ i, TwoUniqueSums (G i)] :\n    TwoUniqueSums (Π₀ i, G i) :=\n  TwoUniqueSums.of_injective_addHom\n    DFinsupp.coeFnAddMonoidHom.toAddHom DFunLike.coe_injective inferInstance\n\n"}
{"name":"instTwoUniqueSumsFinsupp","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"ι : Type u_1\nG : Type u_2\ninst✝¹ : AddZeroClass G\ninst✝ : TwoUniqueSums G\n⊢ TwoUniqueSums (Finsupp ι G)","decl":"instance {ι G} [AddZeroClass G] [TwoUniqueSums G] : TwoUniqueSums (ι →₀ G) :=\n  TwoUniqueSums.of_injective_addHom\n    Finsupp.coeFnAddHom.toAddHom DFunLike.coe_injective inferInstance\n\n"}
{"name":"FreeMonoid.instTwoUniqueProds","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"κ : Type u_1\n⊢ TwoUniqueProds (FreeMonoid κ)","decl":"/-- Any `FreeMonoid` has the `TwoUniqueProds` property. -/\ninstance FreeMonoid.instTwoUniqueProds {κ : Type*} : TwoUniqueProds (FreeMonoid κ) :=\n  .of_mulHom ⟨Multiplicative.ofAdd ∘ List.length, fun _ _ ↦ congr_arg _ (List.length_append _ _)⟩\n    (fun _ _ _ _ h h' ↦ List.append_inj h <| Equiv.injective Multiplicative.ofAdd h'.1)\n\n"}
{"name":"FreeAddMonoid.instTwoUniqueSums","module":"Mathlib.Algebra.Group.UniqueProds.Basic","initialProofState":"κ : Type u_1\n⊢ TwoUniqueSums (FreeAddMonoid κ)","decl":"/-- Any `FreeAddMonoid` has the `TwoUniqueSums` property. -/\ninstance FreeAddMonoid.instTwoUniqueSums {κ : Type*} : TwoUniqueSums (FreeAddMonoid κ) :=\n  .of_addHom ⟨_, List.length_append⟩ (fun _ _ _ _ h h' ↦ List.append_inj h h'.1)\n"}
