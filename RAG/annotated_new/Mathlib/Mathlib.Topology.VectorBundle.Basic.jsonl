{"name":"Pretrivialization.IsLinear.linear","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁶ : Semiring R\ninst✝⁵ : TopologicalSpace F\ninst✝⁴ : TopologicalSpace B\ninst✝³ : AddCommMonoid F\ninst✝² : Module R F\ninst✝¹ : (x : B) → AddCommMonoid (E x)\ninst✝ : (x : B) → Module R (E x)\ne : Pretrivialization F Bundle.TotalSpace.proj\nself : Pretrivialization.IsLinear R e\nb : B\na✝ : Membership.mem e.baseSet b\n⊢ IsLinearMap R fun x => (↑e { proj := b, snd := x }).2","decl":"/-- A mixin class for `Pretrivialization`, stating that a pretrivialization is fiberwise linear with\nrespect to given module structures on its fibers and the model fiber. -/\nprotected class Pretrivialization.IsLinear [AddCommMonoid F] [Module R F] [∀ x, AddCommMonoid (E x)]\n  [∀ x, Module R (E x)] (e : Pretrivialization F (π F E)) : Prop where\n  linear : ∀ b ∈ e.baseSet, IsLinearMap R fun x : E b => (e ⟨b, x⟩).2\n\n"}
{"name":"Pretrivialization.linear","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁷ : Semiring R\ninst✝⁶ : TopologicalSpace F\ninst✝⁵ : TopologicalSpace B\ne : Pretrivialization F Bundle.TotalSpace.proj\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module R F\ninst✝² : (x : B) → AddCommMonoid (E x)\ninst✝¹ : (x : B) → Module R (E x)\ninst✝ : Pretrivialization.IsLinear R e\nb : B\nhb : Membership.mem e.baseSet b\n⊢ IsLinearMap R fun x => (↑e { proj := b, snd := x }).2","decl":"theorem linear [AddCommMonoid F] [Module R F] [∀ x, AddCommMonoid (E x)] [∀ x, Module R (E x)]\n    [e.IsLinear R] {b : B} (hb : b ∈ e.baseSet) :\n    IsLinearMap R fun x : E b => (e ⟨b, x⟩).2 :=\n  Pretrivialization.IsLinear.linear b hb\n\n"}
{"name":"Pretrivialization.symmₗ_apply","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁷ : Semiring R\ninst✝⁶ : TopologicalSpace F\ninst✝⁵ : TopologicalSpace B\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module R F\ninst✝² : (x : B) → AddCommMonoid (E x)\ninst✝¹ : (x : B) → Module R (E x)\ne : Pretrivialization F Bundle.TotalSpace.proj\ninst✝ : Pretrivialization.IsLinear R e\nb : B\ny : F\n⊢ Eq ((Pretrivialization.symmₗ R e b) y) (e.symm b y)","decl":"/-- A fiberwise linear inverse to `e`. -/\n@[simps!]\nprotected def symmₗ (e : Pretrivialization F (π F E)) [e.IsLinear R] (b : B) : F →ₗ[R] E b := by\n  refine IsLinearMap.mk' (e.symm b) ?_\n  by_cases hb : b ∈ e.baseSet\n  · exact (((e.linear R hb).mk' _).inverse (e.symm b) (e.symm_apply_apply_mk hb) fun v ↦\n      congr_arg Prod.snd <| e.apply_mk_symm hb v).isLinear\n  · rw [e.coe_symm_of_not_mem hb]\n    exact (0 : F →ₗ[R] E b).isLinear\n\n"}
{"name":"Pretrivialization.linearEquivAt_symm_apply","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁷ : Semiring R\ninst✝⁶ : TopologicalSpace F\ninst✝⁵ : TopologicalSpace B\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module R F\ninst✝² : (x : B) → AddCommMonoid (E x)\ninst✝¹ : (x : B) → Module R (E x)\ne : Pretrivialization F Bundle.TotalSpace.proj\ninst✝ : Pretrivialization.IsLinear R e\nb : B\nhb : Membership.mem e.baseSet b\n⊢ Eq (⇑(Pretrivialization.linearEquivAt R e b hb).symm) (e.symm b)","decl":"/-- A pretrivialization for a vector bundle defines linear equivalences between the\nfibers and the model space. -/\n@[simps (config := .asFn)]\ndef linearEquivAt (e : Pretrivialization F (π F E)) [e.IsLinear R] (b : B) (hb : b ∈ e.baseSet) :\n    E b ≃ₗ[R] F where\n  toFun y := (e ⟨b, y⟩).2\n  invFun := e.symm b\n  left_inv := e.symm_apply_apply_mk hb\n  right_inv v := by simp_rw [e.apply_mk_symm hb v]\n  map_add' v w := (e.linear R hb).map_add v w\n  map_smul' c v := (e.linear R hb).map_smul c v\n\n"}
{"name":"Pretrivialization.linearEquivAt_apply","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁷ : Semiring R\ninst✝⁶ : TopologicalSpace F\ninst✝⁵ : TopologicalSpace B\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module R F\ninst✝² : (x : B) → AddCommMonoid (E x)\ninst✝¹ : (x : B) → Module R (E x)\ne : Pretrivialization F Bundle.TotalSpace.proj\ninst✝ : Pretrivialization.IsLinear R e\nb : B\nhb : Membership.mem e.baseSet b\n⊢ Eq ⇑(Pretrivialization.linearEquivAt R e b hb) fun y => (↑e { proj := b, snd := y }).2","decl":"/-- A pretrivialization for a vector bundle defines linear equivalences between the\nfibers and the model space. -/\n@[simps (config := .asFn)]\ndef linearEquivAt (e : Pretrivialization F (π F E)) [e.IsLinear R] (b : B) (hb : b ∈ e.baseSet) :\n    E b ≃ₗ[R] F where\n  toFun y := (e ⟨b, y⟩).2\n  invFun := e.symm b\n  left_inv := e.symm_apply_apply_mk hb\n  right_inv v := by simp_rw [e.apply_mk_symm hb v]\n  map_add' v w := (e.linear R hb).map_add v w\n  map_smul' c v := (e.linear R hb).map_smul c v\n\n"}
{"name":"Pretrivialization.coe_linearMapAt","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁷ : Semiring R\ninst✝⁶ : TopologicalSpace F\ninst✝⁵ : TopologicalSpace B\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module R F\ninst✝² : (x : B) → AddCommMonoid (E x)\ninst✝¹ : (x : B) → Module R (E x)\ne : Pretrivialization F Bundle.TotalSpace.proj\ninst✝ : Pretrivialization.IsLinear R e\nb : B\n⊢ Eq ⇑(Pretrivialization.linearMapAt R e b) fun y => ite (Membership.mem e.baseSet b) (↑e { proj := b, snd := y }).2 0","decl":"open Classical in\ntheorem coe_linearMapAt (e : Pretrivialization F (π F E)) [e.IsLinear R] (b : B) :\n    ⇑(e.linearMapAt R b) = fun y => if b ∈ e.baseSet then (e ⟨b, y⟩).2 else 0 := by\n  rw [Pretrivialization.linearMapAt]\n  split_ifs <;> rfl\n\n"}
{"name":"Pretrivialization.coe_linearMapAt_of_mem","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁷ : Semiring R\ninst✝⁶ : TopologicalSpace F\ninst✝⁵ : TopologicalSpace B\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module R F\ninst✝² : (x : B) → AddCommMonoid (E x)\ninst✝¹ : (x : B) → Module R (E x)\ne : Pretrivialization F Bundle.TotalSpace.proj\ninst✝ : Pretrivialization.IsLinear R e\nb : B\nhb : Membership.mem e.baseSet b\n⊢ Eq ⇑(Pretrivialization.linearMapAt R e b) fun y => (↑e { proj := b, snd := y }).2","decl":"theorem coe_linearMapAt_of_mem (e : Pretrivialization F (π F E)) [e.IsLinear R] {b : B}\n    (hb : b ∈ e.baseSet) : ⇑(e.linearMapAt R b) = fun y => (e ⟨b, y⟩).2 := by\n  simp_rw [coe_linearMapAt, if_pos hb]\n\n"}
{"name":"Pretrivialization.linearMapAt_apply","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁷ : Semiring R\ninst✝⁶ : TopologicalSpace F\ninst✝⁵ : TopologicalSpace B\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module R F\ninst✝² : (x : B) → AddCommMonoid (E x)\ninst✝¹ : (x : B) → Module R (E x)\ne : Pretrivialization F Bundle.TotalSpace.proj\ninst✝ : Pretrivialization.IsLinear R e\nb : B\ny : E b\n⊢ Eq ((Pretrivialization.linearMapAt R e b) y) (ite (Membership.mem e.baseSet b) (↑e { proj := b, snd := y }).2 0)","decl":"open Classical in\ntheorem linearMapAt_apply (e : Pretrivialization F (π F E)) [e.IsLinear R] {b : B} (y : E b) :\n    e.linearMapAt R b y = if b ∈ e.baseSet then (e ⟨b, y⟩).2 else 0 := by\n  rw [coe_linearMapAt]\n\n"}
{"name":"Pretrivialization.linearMapAt_def_of_mem","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁷ : Semiring R\ninst✝⁶ : TopologicalSpace F\ninst✝⁵ : TopologicalSpace B\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module R F\ninst✝² : (x : B) → AddCommMonoid (E x)\ninst✝¹ : (x : B) → Module R (E x)\ne : Pretrivialization F Bundle.TotalSpace.proj\ninst✝ : Pretrivialization.IsLinear R e\nb : B\nhb : Membership.mem e.baseSet b\n⊢ Eq (Pretrivialization.linearMapAt R e b) ↑(Pretrivialization.linearEquivAt R e b hb)","decl":"theorem linearMapAt_def_of_mem (e : Pretrivialization F (π F E)) [e.IsLinear R] {b : B}\n    (hb : b ∈ e.baseSet) : e.linearMapAt R b = e.linearEquivAt R b hb :=\n  dif_pos hb\n\n"}
{"name":"Pretrivialization.linearMapAt_def_of_not_mem","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁷ : Semiring R\ninst✝⁶ : TopologicalSpace F\ninst✝⁵ : TopologicalSpace B\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module R F\ninst✝² : (x : B) → AddCommMonoid (E x)\ninst✝¹ : (x : B) → Module R (E x)\ne : Pretrivialization F Bundle.TotalSpace.proj\ninst✝ : Pretrivialization.IsLinear R e\nb : B\nhb : Not (Membership.mem e.baseSet b)\n⊢ Eq (Pretrivialization.linearMapAt R e b) 0","decl":"theorem linearMapAt_def_of_not_mem (e : Pretrivialization F (π F E)) [e.IsLinear R] {b : B}\n    (hb : b ∉ e.baseSet) : e.linearMapAt R b = 0 :=\n  dif_neg hb\n\n"}
{"name":"Pretrivialization.linearMapAt_eq_zero","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁷ : Semiring R\ninst✝⁶ : TopologicalSpace F\ninst✝⁵ : TopologicalSpace B\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module R F\ninst✝² : (x : B) → AddCommMonoid (E x)\ninst✝¹ : (x : B) → Module R (E x)\ne : Pretrivialization F Bundle.TotalSpace.proj\ninst✝ : Pretrivialization.IsLinear R e\nb : B\nhb : Not (Membership.mem e.baseSet b)\n⊢ Eq (Pretrivialization.linearMapAt R e b) 0","decl":"theorem linearMapAt_eq_zero (e : Pretrivialization F (π F E)) [e.IsLinear R] {b : B}\n    (hb : b ∉ e.baseSet) : e.linearMapAt R b = 0 :=\n  dif_neg hb\n\n"}
{"name":"Pretrivialization.symmₗ_linearMapAt","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁷ : Semiring R\ninst✝⁶ : TopologicalSpace F\ninst✝⁵ : TopologicalSpace B\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module R F\ninst✝² : (x : B) → AddCommMonoid (E x)\ninst✝¹ : (x : B) → Module R (E x)\ne : Pretrivialization F Bundle.TotalSpace.proj\ninst✝ : Pretrivialization.IsLinear R e\nb : B\nhb : Membership.mem e.baseSet b\ny : E b\n⊢ Eq ((Pretrivialization.symmₗ R e b) ((Pretrivialization.linearMapAt R e b) y)) y","decl":"theorem symmₗ_linearMapAt (e : Pretrivialization F (π F E)) [e.IsLinear R] {b : B}\n    (hb : b ∈ e.baseSet) (y : E b) : e.symmₗ R b (e.linearMapAt R b y) = y := by\n  rw [e.linearMapAt_def_of_mem hb]\n  exact (e.linearEquivAt R b hb).left_inv y\n\n"}
{"name":"Pretrivialization.linearMapAt_symmₗ","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁷ : Semiring R\ninst✝⁶ : TopologicalSpace F\ninst✝⁵ : TopologicalSpace B\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module R F\ninst✝² : (x : B) → AddCommMonoid (E x)\ninst✝¹ : (x : B) → Module R (E x)\ne : Pretrivialization F Bundle.TotalSpace.proj\ninst✝ : Pretrivialization.IsLinear R e\nb : B\nhb : Membership.mem e.baseSet b\ny : F\n⊢ Eq ((Pretrivialization.linearMapAt R e b) ((Pretrivialization.symmₗ R e b) y)) y","decl":"theorem linearMapAt_symmₗ (e : Pretrivialization F (π F E)) [e.IsLinear R] {b : B}\n    (hb : b ∈ e.baseSet) (y : F) : e.linearMapAt R b (e.symmₗ R b y) = y := by\n  rw [e.linearMapAt_def_of_mem hb]\n  exact (e.linearEquivAt R b hb).right_inv y\n\n"}
{"name":"Trivialization.IsLinear.linear","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁷ : Semiring R\ninst✝⁶ : TopologicalSpace F\ninst✝⁵ : TopologicalSpace B\ninst✝⁴ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝³ : AddCommMonoid F\ninst✝² : Module R F\ninst✝¹ : (x : B) → AddCommMonoid (E x)\ninst✝ : (x : B) → Module R (E x)\ne : Trivialization F Bundle.TotalSpace.proj\nself : Trivialization.IsLinear R e\nb : B\na✝ : Membership.mem e.baseSet b\n⊢ IsLinearMap R fun x => (↑e { proj := b, snd := x }).2","decl":"/-- A mixin class for `Trivialization`, stating that a trivialization is fiberwise linear with\nrespect to given module structures on its fibers and the model fiber. -/\nprotected class Trivialization.IsLinear [AddCommMonoid F] [Module R F] [∀ x, AddCommMonoid (E x)]\n  [∀ x, Module R (E x)] (e : Trivialization F (π F E)) : Prop where\n  linear : ∀ b ∈ e.baseSet, IsLinearMap R fun x : E b => (e ⟨b, x⟩).2\n\n"}
{"name":"Trivialization.linear","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁸ : Semiring R\ninst✝⁷ : TopologicalSpace F\ninst✝⁶ : TopologicalSpace B\ninst✝⁵ : TopologicalSpace (Bundle.TotalSpace F E)\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module R F\ninst✝² : (x : B) → AddCommMonoid (E x)\ninst✝¹ : (x : B) → Module R (E x)\ninst✝ : Trivialization.IsLinear R e\nb : B\nhb : Membership.mem e.baseSet b\n⊢ IsLinearMap R fun y => (↑e { proj := b, snd := y }).2","decl":"protected theorem linear [AddCommMonoid F] [Module R F] [∀ x, AddCommMonoid (E x)]\n    [∀ x, Module R (E x)] [e.IsLinear R] {b : B} (hb : b ∈ e.baseSet) :\n    IsLinearMap R fun y : E b => (e ⟨b, y⟩).2 :=\n  Trivialization.IsLinear.linear b hb\n\n"}
{"name":"Trivialization.toPretrivialization.isLinear","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁸ : Semiring R\ninst✝⁷ : TopologicalSpace F\ninst✝⁶ : TopologicalSpace B\ninst✝⁵ : TopologicalSpace (Bundle.TotalSpace F E)\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module R F\ninst✝² : (x : B) → AddCommMonoid (E x)\ninst✝¹ : (x : B) → Module R (E x)\ninst✝ : Trivialization.IsLinear R e\n⊢ Pretrivialization.IsLinear R e.toPretrivialization","decl":"instance toPretrivialization.isLinear [AddCommMonoid F] [Module R F] [∀ x, AddCommMonoid (E x)]\n    [∀ x, Module R (E x)] [e.IsLinear R] : e.toPretrivialization.IsLinear R :=\n  { (‹_› : e.IsLinear R) with }\n\n"}
{"name":"Trivialization.linearEquivAt_apply","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁸ : Semiring R\ninst✝⁷ : TopologicalSpace F\ninst✝⁶ : TopologicalSpace B\ninst✝⁵ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module R F\ninst✝² : (x : B) → AddCommMonoid (E x)\ninst✝¹ : (x : B) → Module R (E x)\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : Trivialization.IsLinear R e\nb : B\nhb : Membership.mem e.baseSet b\nv : E b\n⊢ Eq ((Trivialization.linearEquivAt R e b hb) v) (↑e { proj := b, snd := v }).2","decl":"@[simp]\ntheorem linearEquivAt_apply (e : Trivialization F (π F E)) [e.IsLinear R] (b : B)\n    (hb : b ∈ e.baseSet) (v : E b) : e.linearEquivAt R b hb v = (e ⟨b, v⟩).2 :=\n  rfl\n\n"}
{"name":"Trivialization.linearEquivAt_symm_apply","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁸ : Semiring R\ninst✝⁷ : TopologicalSpace F\ninst✝⁶ : TopologicalSpace B\ninst✝⁵ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module R F\ninst✝² : (x : B) → AddCommMonoid (E x)\ninst✝¹ : (x : B) → Module R (E x)\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : Trivialization.IsLinear R e\nb : B\nhb : Membership.mem e.baseSet b\nv : F\n⊢ Eq ((Trivialization.linearEquivAt R e b hb).symm v) (e.symm b v)","decl":"@[simp]\ntheorem linearEquivAt_symm_apply (e : Trivialization F (π F E)) [e.IsLinear R] (b : B)\n    (hb : b ∈ e.baseSet) (v : F) : (e.linearEquivAt R b hb).symm v = e.symm b v :=\n  rfl\n\n"}
{"name":"Trivialization.coe_symmₗ","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁸ : Semiring R\ninst✝⁷ : TopologicalSpace F\ninst✝⁶ : TopologicalSpace B\ninst✝⁵ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module R F\ninst✝² : (x : B) → AddCommMonoid (E x)\ninst✝¹ : (x : B) → Module R (E x)\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : Trivialization.IsLinear R e\nb : B\n⊢ Eq (⇑(Trivialization.symmₗ R e b)) (e.symm b)","decl":"theorem coe_symmₗ (e : Trivialization F (π F E)) [e.IsLinear R] (b : B) :\n    ⇑(e.symmₗ R b) = e.symm b :=\n  rfl\n\n"}
{"name":"Trivialization.coe_linearMapAt","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁸ : Semiring R\ninst✝⁷ : TopologicalSpace F\ninst✝⁶ : TopologicalSpace B\ninst✝⁵ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module R F\ninst✝² : (x : B) → AddCommMonoid (E x)\ninst✝¹ : (x : B) → Module R (E x)\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : Trivialization.IsLinear R e\nb : B\n⊢ Eq ⇑(Trivialization.linearMapAt R e b) fun y => ite (Membership.mem e.baseSet b) (↑e { proj := b, snd := y }).2 0","decl":"open Classical in\ntheorem coe_linearMapAt (e : Trivialization F (π F E)) [e.IsLinear R] (b : B) :\n    ⇑(e.linearMapAt R b) = fun y => if b ∈ e.baseSet then (e ⟨b, y⟩).2 else 0 :=\n  e.toPretrivialization.coe_linearMapAt b\n\n"}
{"name":"Trivialization.coe_linearMapAt_of_mem","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁸ : Semiring R\ninst✝⁷ : TopologicalSpace F\ninst✝⁶ : TopologicalSpace B\ninst✝⁵ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module R F\ninst✝² : (x : B) → AddCommMonoid (E x)\ninst✝¹ : (x : B) → Module R (E x)\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : Trivialization.IsLinear R e\nb : B\nhb : Membership.mem e.baseSet b\n⊢ Eq ⇑(Trivialization.linearMapAt R e b) fun y => (↑e { proj := b, snd := y }).2","decl":"theorem coe_linearMapAt_of_mem (e : Trivialization F (π F E)) [e.IsLinear R] {b : B}\n    (hb : b ∈ e.baseSet) : ⇑(e.linearMapAt R b) = fun y => (e ⟨b, y⟩).2 := by\n  simp_rw [coe_linearMapAt, if_pos hb]\n\n"}
{"name":"Trivialization.linearMapAt_apply","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁸ : Semiring R\ninst✝⁷ : TopologicalSpace F\ninst✝⁶ : TopologicalSpace B\ninst✝⁵ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module R F\ninst✝² : (x : B) → AddCommMonoid (E x)\ninst✝¹ : (x : B) → Module R (E x)\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : Trivialization.IsLinear R e\nb : B\ny : E b\n⊢ Eq ((Trivialization.linearMapAt R e b) y) (ite (Membership.mem e.baseSet b) (↑e { proj := b, snd := y }).2 0)","decl":"open Classical in\ntheorem linearMapAt_apply (e : Trivialization F (π F E)) [e.IsLinear R] {b : B} (y : E b) :\n    e.linearMapAt R b y = if b ∈ e.baseSet then (e ⟨b, y⟩).2 else 0 := by\n  rw [coe_linearMapAt]\n\n"}
{"name":"Trivialization.linearMapAt_def_of_mem","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁸ : Semiring R\ninst✝⁷ : TopologicalSpace F\ninst✝⁶ : TopologicalSpace B\ninst✝⁵ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module R F\ninst✝² : (x : B) → AddCommMonoid (E x)\ninst✝¹ : (x : B) → Module R (E x)\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : Trivialization.IsLinear R e\nb : B\nhb : Membership.mem e.baseSet b\n⊢ Eq (Trivialization.linearMapAt R e b) ↑(Trivialization.linearEquivAt R e b hb)","decl":"theorem linearMapAt_def_of_mem (e : Trivialization F (π F E)) [e.IsLinear R] {b : B}\n    (hb : b ∈ e.baseSet) : e.linearMapAt R b = e.linearEquivAt R b hb :=\n  dif_pos hb\n\n"}
{"name":"Trivialization.linearMapAt_def_of_not_mem","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁸ : Semiring R\ninst✝⁷ : TopologicalSpace F\ninst✝⁶ : TopologicalSpace B\ninst✝⁵ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module R F\ninst✝² : (x : B) → AddCommMonoid (E x)\ninst✝¹ : (x : B) → Module R (E x)\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : Trivialization.IsLinear R e\nb : B\nhb : Not (Membership.mem e.baseSet b)\n⊢ Eq (Trivialization.linearMapAt R e b) 0","decl":"theorem linearMapAt_def_of_not_mem (e : Trivialization F (π F E)) [e.IsLinear R] {b : B}\n    (hb : b ∉ e.baseSet) : e.linearMapAt R b = 0 :=\n  dif_neg hb\n\n"}
{"name":"Trivialization.symmₗ_linearMapAt","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁸ : Semiring R\ninst✝⁷ : TopologicalSpace F\ninst✝⁶ : TopologicalSpace B\ninst✝⁵ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module R F\ninst✝² : (x : B) → AddCommMonoid (E x)\ninst✝¹ : (x : B) → Module R (E x)\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : Trivialization.IsLinear R e\nb : B\nhb : Membership.mem e.baseSet b\ny : E b\n⊢ Eq ((Trivialization.symmₗ R e b) ((Trivialization.linearMapAt R e b) y)) y","decl":"theorem symmₗ_linearMapAt (e : Trivialization F (π F E)) [e.IsLinear R] {b : B} (hb : b ∈ e.baseSet)\n    (y : E b) : e.symmₗ R b (e.linearMapAt R b y) = y :=\n  e.toPretrivialization.symmₗ_linearMapAt hb y\n\n"}
{"name":"Trivialization.linearMapAt_symmₗ","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁸ : Semiring R\ninst✝⁷ : TopologicalSpace F\ninst✝⁶ : TopologicalSpace B\ninst✝⁵ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module R F\ninst✝² : (x : B) → AddCommMonoid (E x)\ninst✝¹ : (x : B) → Module R (E x)\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : Trivialization.IsLinear R e\nb : B\nhb : Membership.mem e.baseSet b\ny : F\n⊢ Eq ((Trivialization.linearMapAt R e b) ((Trivialization.symmₗ R e b) y)) y","decl":"theorem linearMapAt_symmₗ (e : Trivialization F (π F E)) [e.IsLinear R] {b : B} (hb : b ∈ e.baseSet)\n    (y : F) : e.linearMapAt R b (e.symmₗ R b y) = y :=\n  e.toPretrivialization.linearMapAt_symmₗ hb y\n\n"}
{"name":"Trivialization.coe_coordChangeL","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁹ : Semiring R\ninst✝⁸ : TopologicalSpace F\ninst✝⁷ : TopologicalSpace B\ninst✝⁶ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝⁵ : AddCommMonoid F\ninst✝⁴ : Module R F\ninst✝³ : (x : B) → AddCommMonoid (E x)\ninst✝² : (x : B) → Module R (E x)\ne e' : Trivialization F Bundle.TotalSpace.proj\ninst✝¹ : Trivialization.IsLinear R e\ninst✝ : Trivialization.IsLinear R e'\nb : B\nhb : Membership.mem (Inter.inter e.baseSet e'.baseSet) b\n⊢ Eq ⇑(Trivialization.coordChangeL R e e' b) ⇑((Trivialization.linearEquivAt R e b ⋯).symm.trans (Trivialization.linearEquivAt R e' b ⋯))","decl":"theorem coe_coordChangeL (e e' : Trivialization F (π F E)) [e.IsLinear R] [e'.IsLinear R] {b : B}\n    (hb : b ∈ e.baseSet ∩ e'.baseSet) :\n    ⇑(coordChangeL R e e' b) = (e.linearEquivAt R b hb.1).symm.trans (e'.linearEquivAt R b hb.2) :=\n  congr_arg (fun f : F ≃ₗ[R] F ↦ ⇑f) (dif_pos hb)\n\n"}
{"name":"Trivialization.coe_coordChangeL'","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁹ : Semiring R\ninst✝⁸ : TopologicalSpace F\ninst✝⁷ : TopologicalSpace B\ninst✝⁶ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝⁵ : AddCommMonoid F\ninst✝⁴ : Module R F\ninst✝³ : (x : B) → AddCommMonoid (E x)\ninst✝² : (x : B) → Module R (E x)\ne e' : Trivialization F Bundle.TotalSpace.proj\ninst✝¹ : Trivialization.IsLinear R e\ninst✝ : Trivialization.IsLinear R e'\nb : B\nhb : Membership.mem (Inter.inter e.baseSet e'.baseSet) b\n⊢ Eq (Trivialization.coordChangeL R e e' b).toLinearEquiv ((Trivialization.linearEquivAt R e b ⋯).symm.trans (Trivialization.linearEquivAt R e' b ⋯))","decl":"theorem coe_coordChangeL' (e e' : Trivialization F (π F E)) [e.IsLinear R] [e'.IsLinear R] {b : B}\n    (hb : b ∈ e.baseSet ∩ e'.baseSet) :\n    (coordChangeL R e e' b).toLinearEquiv =\n      (e.linearEquivAt R b hb.1).symm.trans (e'.linearEquivAt R b hb.2) :=\n  LinearEquiv.coe_injective (coe_coordChangeL _ _ hb)\n\n"}
{"name":"Trivialization.symm_coordChangeL","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁹ : Semiring R\ninst✝⁸ : TopologicalSpace F\ninst✝⁷ : TopologicalSpace B\ninst✝⁶ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝⁵ : AddCommMonoid F\ninst✝⁴ : Module R F\ninst✝³ : (x : B) → AddCommMonoid (E x)\ninst✝² : (x : B) → Module R (E x)\ne e' : Trivialization F Bundle.TotalSpace.proj\ninst✝¹ : Trivialization.IsLinear R e\ninst✝ : Trivialization.IsLinear R e'\nb : B\nhb : Membership.mem (Inter.inter e'.baseSet e.baseSet) b\n⊢ Eq (Trivialization.coordChangeL R e e' b).symm (Trivialization.coordChangeL R e' e b)","decl":"theorem symm_coordChangeL (e e' : Trivialization F (π F E)) [e.IsLinear R] [e'.IsLinear R] {b : B}\n    (hb : b ∈ e'.baseSet ∩ e.baseSet) : (e.coordChangeL R e' b).symm = e'.coordChangeL R e b := by\n  apply ContinuousLinearEquiv.toLinearEquiv_injective\n  rw [coe_coordChangeL' e' e hb, (coordChangeL R e e' b).symm_toLinearEquiv,\n    coe_coordChangeL' e e' hb.symm, LinearEquiv.trans_symm, LinearEquiv.symm_symm]\n\n"}
{"name":"Trivialization.coordChangeL_apply","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁹ : Semiring R\ninst✝⁸ : TopologicalSpace F\ninst✝⁷ : TopologicalSpace B\ninst✝⁶ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝⁵ : AddCommMonoid F\ninst✝⁴ : Module R F\ninst✝³ : (x : B) → AddCommMonoid (E x)\ninst✝² : (x : B) → Module R (E x)\ne e' : Trivialization F Bundle.TotalSpace.proj\ninst✝¹ : Trivialization.IsLinear R e\ninst✝ : Trivialization.IsLinear R e'\nb : B\nhb : Membership.mem (Inter.inter e.baseSet e'.baseSet) b\ny : F\n⊢ Eq ((Trivialization.coordChangeL R e e' b) y) (↑e' { proj := b, snd := e.symm b y }).2","decl":"theorem coordChangeL_apply (e e' : Trivialization F (π F E)) [e.IsLinear R] [e'.IsLinear R] {b : B}\n    (hb : b ∈ e.baseSet ∩ e'.baseSet) (y : F) :\n    coordChangeL R e e' b y = (e' ⟨b, e.symm b y⟩).2 :=\n  congr_fun (coe_coordChangeL e e' hb) y\n\n"}
{"name":"Trivialization.mk_coordChangeL","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁹ : Semiring R\ninst✝⁸ : TopologicalSpace F\ninst✝⁷ : TopologicalSpace B\ninst✝⁶ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝⁵ : AddCommMonoid F\ninst✝⁴ : Module R F\ninst✝³ : (x : B) → AddCommMonoid (E x)\ninst✝² : (x : B) → Module R (E x)\ne e' : Trivialization F Bundle.TotalSpace.proj\ninst✝¹ : Trivialization.IsLinear R e\ninst✝ : Trivialization.IsLinear R e'\nb : B\nhb : Membership.mem (Inter.inter e.baseSet e'.baseSet) b\ny : F\n⊢ Eq { fst := b, snd := (Trivialization.coordChangeL R e e' b) y } (↑e' { proj := b, snd := e.symm b y })","decl":"theorem mk_coordChangeL (e e' : Trivialization F (π F E)) [e.IsLinear R] [e'.IsLinear R] {b : B}\n    (hb : b ∈ e.baseSet ∩ e'.baseSet) (y : F) :\n    (b, coordChangeL R e e' b y) = e' ⟨b, e.symm b y⟩ := by\n  ext\n  · rw [e.mk_symm hb.1 y, e'.coe_fst', e.proj_symm_apply' hb.1]\n    rw [e.proj_symm_apply' hb.1]\n    exact hb.2\n  · exact e.coordChangeL_apply e' hb y\n\n"}
{"name":"Trivialization.apply_symm_apply_eq_coordChangeL","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁹ : Semiring R\ninst✝⁸ : TopologicalSpace F\ninst✝⁷ : TopologicalSpace B\ninst✝⁶ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝⁵ : AddCommMonoid F\ninst✝⁴ : Module R F\ninst✝³ : (x : B) → AddCommMonoid (E x)\ninst✝² : (x : B) → Module R (E x)\ne e' : Trivialization F Bundle.TotalSpace.proj\ninst✝¹ : Trivialization.IsLinear R e\ninst✝ : Trivialization.IsLinear R e'\nb : B\nhb : Membership.mem (Inter.inter e.baseSet e'.baseSet) b\nv : F\n⊢ Eq (↑e' (↑e.symm { fst := b, snd := v })) { fst := b, snd := (Trivialization.coordChangeL R e e' b) v }","decl":"theorem apply_symm_apply_eq_coordChangeL (e e' : Trivialization F (π F E)) [e.IsLinear R]\n    [e'.IsLinear R] {b : B} (hb : b ∈ e.baseSet ∩ e'.baseSet) (v : F) :\n    e' (e.toPartialHomeomorph.symm (b, v)) = (b, e.coordChangeL R e' b v) := by\n  rw [e.mk_coordChangeL e' hb, e.mk_symm hb.1]\n\n"}
{"name":"Trivialization.coordChangeL_apply'","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁹ : Semiring R\ninst✝⁸ : TopologicalSpace F\ninst✝⁷ : TopologicalSpace B\ninst✝⁶ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝⁵ : AddCommMonoid F\ninst✝⁴ : Module R F\ninst✝³ : (x : B) → AddCommMonoid (E x)\ninst✝² : (x : B) → Module R (E x)\ne e' : Trivialization F Bundle.TotalSpace.proj\ninst✝¹ : Trivialization.IsLinear R e\ninst✝ : Trivialization.IsLinear R e'\nb : B\nhb : Membership.mem (Inter.inter e.baseSet e'.baseSet) b\ny : F\n⊢ Eq ((Trivialization.coordChangeL R e e' b) y) (↑e' (↑e.symm { fst := b, snd := y })).2","decl":"/-- A version of `Trivialization.coordChangeL_apply` that fully unfolds `coordChange`. The\nright-hand side is ugly, but has good definitional properties for specifically defined\ntrivializations. -/\ntheorem coordChangeL_apply' (e e' : Trivialization F (π F E)) [e.IsLinear R] [e'.IsLinear R] {b : B}\n    (hb : b ∈ e.baseSet ∩ e'.baseSet) (y : F) :\n    coordChangeL R e e' b y = (e' (e.toPartialHomeomorph.symm (b, y))).2 := by\n  rw [e.coordChangeL_apply e' hb, e.mk_symm hb.1]\n\n"}
{"name":"Trivialization.coordChangeL_symm_apply","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁹ : Semiring R\ninst✝⁸ : TopologicalSpace F\ninst✝⁷ : TopologicalSpace B\ninst✝⁶ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝⁵ : AddCommMonoid F\ninst✝⁴ : Module R F\ninst✝³ : (x : B) → AddCommMonoid (E x)\ninst✝² : (x : B) → Module R (E x)\ne e' : Trivialization F Bundle.TotalSpace.proj\ninst✝¹ : Trivialization.IsLinear R e\ninst✝ : Trivialization.IsLinear R e'\nb : B\nhb : Membership.mem (Inter.inter e.baseSet e'.baseSet) b\n⊢ Eq ⇑(Trivialization.coordChangeL R e e' b).symm ⇑((Trivialization.linearEquivAt R e' b ⋯).symm.trans (Trivialization.linearEquivAt R e b ⋯))","decl":"theorem coordChangeL_symm_apply (e e' : Trivialization F (π F E)) [e.IsLinear R] [e'.IsLinear R]\n    {b : B} (hb : b ∈ e.baseSet ∩ e'.baseSet) :\n    ⇑(coordChangeL R e e' b).symm =\n      (e'.linearEquivAt R b hb.2).symm.trans (e.linearEquivAt R b hb.1) :=\n  congr_arg LinearEquiv.invFun (dif_pos hb)\n\n"}
{"name":"Bundle.zeroSection_proj","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝ : (x : B) → Zero (E x)\nx : B\n⊢ Eq (Bundle.zeroSection F E x).proj x","decl":"@[simp, mfld_simps]\ntheorem zeroSection_proj [∀ x, Zero (E x)] (x : B) : (zeroSection F E x).proj = x :=\n  rfl\n\n"}
{"name":"Bundle.zeroSection_snd","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝ : (x : B) → Zero (E x)\nx : B\n⊢ Eq (Bundle.zeroSection F E x).snd 0","decl":"@[simp, mfld_simps]\ntheorem zeroSection_snd [∀ x, Zero (E x)] (x : B) : (zeroSection F E x).2 = 0 :=\n  rfl\n\n"}
{"name":"VectorBundle.continuousOn_coordChange'","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝¹⁰ : NontriviallyNormedField R\ninst✝⁹ : (x : B) → AddCommMonoid (E x)\ninst✝⁸ : (x : B) → Module R (E x)\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace R F\ninst✝⁵ : TopologicalSpace B\ninst✝⁴ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝³ : (x : B) → TopologicalSpace (E x)\ninst✝² : FiberBundle F E\nself : VectorBundle R F E\ne e' : Trivialization F Bundle.TotalSpace.proj\ninst✝¹ : MemTrivializationAtlas e\ninst✝ : MemTrivializationAtlas e'\n⊢ ContinuousOn (fun b => ↑(Trivialization.coordChangeL R e e' b)) (Inter.inter e.baseSet e'.baseSet)","decl":"/-- The space `Bundle.TotalSpace F E` (for `E : B → Type*` such that each `E x` is a topological\nvector space) has a topological vector space structure with fiber `F` (denoted with\n`VectorBundle R F E`) if around every point there is a fiber bundle trivialization which is linear\nin the fibers. -/\nclass VectorBundle : Prop where\n  trivialization_linear' : ∀ (e : Trivialization F (π F E)) [MemTrivializationAtlas e], e.IsLinear R\n  continuousOn_coordChange' :\n    ∀ (e e' : Trivialization F (π F E)) [MemTrivializationAtlas e] [MemTrivializationAtlas e'],\n      ContinuousOn (fun b => Trivialization.coordChangeL R e e' b : B → F →L[R] F)\n        (e.baseSet ∩ e'.baseSet)\n\n"}
{"name":"VectorBundle.trivialization_linear'","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁹ : NontriviallyNormedField R\ninst✝⁸ : (x : B) → AddCommMonoid (E x)\ninst✝⁷ : (x : B) → Module R (E x)\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace R F\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝² : (x : B) → TopologicalSpace (E x)\ninst✝¹ : FiberBundle F E\nself : VectorBundle R F E\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : MemTrivializationAtlas e\n⊢ Trivialization.IsLinear R e","decl":"/-- The space `Bundle.TotalSpace F E` (for `E : B → Type*` such that each `E x` is a topological\nvector space) has a topological vector space structure with fiber `F` (denoted with\n`VectorBundle R F E`) if around every point there is a fiber bundle trivialization which is linear\nin the fibers. -/\nclass VectorBundle : Prop where\n  trivialization_linear' : ∀ (e : Trivialization F (π F E)) [MemTrivializationAtlas e], e.IsLinear R\n  continuousOn_coordChange' :\n    ∀ (e e' : Trivialization F (π F E)) [MemTrivializationAtlas e] [MemTrivializationAtlas e'],\n      ContinuousOn (fun b => Trivialization.coordChangeL R e e' b : B → F →L[R] F)\n        (e.baseSet ∩ e'.baseSet)\n\n"}
{"name":"trivialization_linear","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝¹⁰ : NontriviallyNormedField R\ninst✝⁹ : (x : B) → AddCommMonoid (E x)\ninst✝⁸ : (x : B) → Module R (E x)\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace R F\ninst✝⁵ : TopologicalSpace B\ninst✝⁴ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝³ : (x : B) → TopologicalSpace (E x)\ninst✝² : FiberBundle F E\ninst✝¹ : VectorBundle R F E\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : MemTrivializationAtlas e\n⊢ Trivialization.IsLinear R e","decl":"instance (priority := 100) trivialization_linear [VectorBundle R F E] (e : Trivialization F (π F E))\n    [MemTrivializationAtlas e] : e.IsLinear R :=\n  VectorBundle.trivialization_linear' e\n\n"}
{"name":"continuousOn_coordChange","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝¹¹ : NontriviallyNormedField R\ninst✝¹⁰ : (x : B) → AddCommMonoid (E x)\ninst✝⁹ : (x : B) → Module R (E x)\ninst✝⁸ : NormedAddCommGroup F\ninst✝⁷ : NormedSpace R F\ninst✝⁶ : TopologicalSpace B\ninst✝⁵ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝⁴ : (x : B) → TopologicalSpace (E x)\ninst✝³ : FiberBundle F E\ninst✝² : VectorBundle R F E\ne e' : Trivialization F Bundle.TotalSpace.proj\ninst✝¹ : MemTrivializationAtlas e\ninst✝ : MemTrivializationAtlas e'\n⊢ ContinuousOn (fun b => ↑(Trivialization.coordChangeL R e e' b)) (Inter.inter e.baseSet e'.baseSet)","decl":"theorem continuousOn_coordChange [VectorBundle R F E] (e e' : Trivialization F (π F E))\n    [MemTrivializationAtlas e] [MemTrivializationAtlas e'] :\n    ContinuousOn (fun b => Trivialization.coordChangeL R e e' b : B → F →L[R] F)\n      (e.baseSet ∩ e'.baseSet) :=\n  VectorBundle.continuousOn_coordChange' e e'\n\n"}
{"name":"Trivialization.continuousLinearMapAt_apply","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁸ : NontriviallyNormedField R\ninst✝⁷ : (x : B) → AddCommMonoid (E x)\ninst✝⁶ : (x : B) → Module R (E x)\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace R F\ninst✝³ : TopologicalSpace B\ninst✝² : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝¹ : (x : B) → TopologicalSpace (E x)\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : Trivialization.IsLinear R e\nb : B\n⊢ Eq ⇑(Trivialization.continuousLinearMapAt R e b) ⇑(Trivialization.linearMapAt R e b)","decl":"/-- Forward map of `Trivialization.continuousLinearEquivAt` (only propositionally equal),\n  defined everywhere (`0` outside domain). -/\n@[simps (config := .asFn) apply]\ndef continuousLinearMapAt (e : Trivialization F (π F E)) [e.IsLinear R] (b : B) : E b →L[R] F :=\n  { e.linearMapAt R b with\n    toFun := e.linearMapAt R b -- given explicitly to help `simps`\n    cont := by\n      dsimp\n      rw [e.coe_linearMapAt b]\n      classical\n      refine continuous_if_const _ (fun hb => ?_) fun _ => continuous_zero\n      exact (e.continuousOn.comp_continuous (FiberBundle.totalSpaceMk_isInducing F E b).continuous\n        fun x => e.mem_source.mpr hb).snd }\n\n"}
{"name":"Trivialization.symmL_apply","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁸ : NontriviallyNormedField R\ninst✝⁷ : (x : B) → AddCommMonoid (E x)\ninst✝⁶ : (x : B) → Module R (E x)\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace R F\ninst✝³ : TopologicalSpace B\ninst✝² : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝¹ : (x : B) → TopologicalSpace (E x)\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : Trivialization.IsLinear R e\nb : B\n⊢ Eq (⇑(Trivialization.symmL R e b)) (e.symm b)","decl":"/-- Backwards map of `Trivialization.continuousLinearEquivAt`, defined everywhere. -/\n@[simps (config := .asFn) apply]\ndef symmL (e : Trivialization F (π F E)) [e.IsLinear R] (b : B) : F →L[R] E b :=\n  { e.symmₗ R b with\n    toFun := e.symm b -- given explicitly to help `simps`\n    cont := by\n      by_cases hb : b ∈ e.baseSet\n      · rw [(FiberBundle.totalSpaceMk_isInducing F E b).continuous_iff]\n        exact e.continuousOn_symm.comp_continuous (continuous_const.prod_mk continuous_id) fun x ↦\n          mk_mem_prod hb (mem_univ x)\n      · refine continuous_zero.congr fun x => (e.symm_apply_of_not_mem hb x).symm }\n\n"}
{"name":"Trivialization.symmL_continuousLinearMapAt","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁹ : NontriviallyNormedField R\ninst✝⁸ : (x : B) → AddCommMonoid (E x)\ninst✝⁷ : (x : B) → Module R (E x)\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace R F\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝² : (x : B) → TopologicalSpace (E x)\ninst✝¹ : FiberBundle F E\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : Trivialization.IsLinear R e\nb : B\nhb : Membership.mem e.baseSet b\ny : E b\n⊢ Eq ((Trivialization.symmL R e b) ((Trivialization.continuousLinearMapAt R e b) y)) y","decl":"theorem symmL_continuousLinearMapAt (e : Trivialization F (π F E)) [e.IsLinear R] {b : B}\n    (hb : b ∈ e.baseSet) (y : E b) : e.symmL R b (e.continuousLinearMapAt R b y) = y :=\n  e.symmₗ_linearMapAt hb y\n\n"}
{"name":"Trivialization.continuousLinearMapAt_symmL","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁹ : NontriviallyNormedField R\ninst✝⁸ : (x : B) → AddCommMonoid (E x)\ninst✝⁷ : (x : B) → Module R (E x)\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace R F\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝² : (x : B) → TopologicalSpace (E x)\ninst✝¹ : FiberBundle F E\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : Trivialization.IsLinear R e\nb : B\nhb : Membership.mem e.baseSet b\ny : F\n⊢ Eq ((Trivialization.continuousLinearMapAt R e b) ((Trivialization.symmL R e b) y)) y","decl":"theorem continuousLinearMapAt_symmL (e : Trivialization F (π F E)) [e.IsLinear R] {b : B}\n    (hb : b ∈ e.baseSet) (y : F) : e.continuousLinearMapAt R b (e.symmL R b y) = y :=\n  e.linearMapAt_symmₗ hb y\n\n"}
{"name":"Trivialization.continuousLinearEquivAt_apply","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁹ : NontriviallyNormedField R\ninst✝⁸ : (x : B) → AddCommMonoid (E x)\ninst✝⁷ : (x : B) → Module R (E x)\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace R F\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝² : (x : B) → TopologicalSpace (E x)\ninst✝¹ : FiberBundle F E\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : Trivialization.IsLinear R e\nb : B\nhb : Membership.mem e.baseSet b\n⊢ Eq ⇑(Trivialization.continuousLinearEquivAt R e b hb) fun y => (↑e { proj := b, snd := y }).2","decl":"/-- In a vector bundle, a trivialization in the fiber (which is a priori only linear)\nis in fact a continuous linear equiv between the fibers and the model fiber. -/\n@[simps (config := .asFn) apply symm_apply]\ndef continuousLinearEquivAt (e : Trivialization F (π F E)) [e.IsLinear R] (b : B)\n    (hb : b ∈ e.baseSet) : E b ≃L[R] F :=\n  { e.toPretrivialization.linearEquivAt R b hb with\n    toFun := fun y => (e ⟨b, y⟩).2 -- given explicitly to help `simps`\n    invFun := e.symm b -- given explicitly to help `simps`\n    continuous_toFun := (e.continuousOn.comp_continuous\n      (FiberBundle.totalSpaceMk_isInducing F E b).continuous fun _ => e.mem_source.mpr hb).snd\n    continuous_invFun := (e.symmL R b).continuous }\n\n"}
{"name":"Trivialization.continuousLinearEquivAt_symm_apply","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁹ : NontriviallyNormedField R\ninst✝⁸ : (x : B) → AddCommMonoid (E x)\ninst✝⁷ : (x : B) → Module R (E x)\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace R F\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝² : (x : B) → TopologicalSpace (E x)\ninst✝¹ : FiberBundle F E\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : Trivialization.IsLinear R e\nb : B\nhb : Membership.mem e.baseSet b\n⊢ Eq (⇑(Trivialization.continuousLinearEquivAt R e b hb).symm) (e.symm b)","decl":"/-- In a vector bundle, a trivialization in the fiber (which is a priori only linear)\nis in fact a continuous linear equiv between the fibers and the model fiber. -/\n@[simps (config := .asFn) apply symm_apply]\ndef continuousLinearEquivAt (e : Trivialization F (π F E)) [e.IsLinear R] (b : B)\n    (hb : b ∈ e.baseSet) : E b ≃L[R] F :=\n  { e.toPretrivialization.linearEquivAt R b hb with\n    toFun := fun y => (e ⟨b, y⟩).2 -- given explicitly to help `simps`\n    invFun := e.symm b -- given explicitly to help `simps`\n    continuous_toFun := (e.continuousOn.comp_continuous\n      (FiberBundle.totalSpaceMk_isInducing F E b).continuous fun _ => e.mem_source.mpr hb).snd\n    continuous_invFun := (e.symmL R b).continuous }\n\n"}
{"name":"Trivialization.coe_continuousLinearEquivAt_eq","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁹ : NontriviallyNormedField R\ninst✝⁸ : (x : B) → AddCommMonoid (E x)\ninst✝⁷ : (x : B) → Module R (E x)\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace R F\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝² : (x : B) → TopologicalSpace (E x)\ninst✝¹ : FiberBundle F E\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : Trivialization.IsLinear R e\nb : B\nhb : Membership.mem e.baseSet b\n⊢ Eq ⇑(Trivialization.continuousLinearEquivAt R e b hb) ⇑(Trivialization.continuousLinearMapAt R e b)","decl":"theorem coe_continuousLinearEquivAt_eq (e : Trivialization F (π F E)) [e.IsLinear R] {b : B}\n    (hb : b ∈ e.baseSet) :\n    (e.continuousLinearEquivAt R b hb : E b → F) = e.continuousLinearMapAt R b :=\n  (e.coe_linearMapAt_of_mem hb).symm\n\n"}
{"name":"Trivialization.symm_continuousLinearEquivAt_eq","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁹ : NontriviallyNormedField R\ninst✝⁸ : (x : B) → AddCommMonoid (E x)\ninst✝⁷ : (x : B) → Module R (E x)\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace R F\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝² : (x : B) → TopologicalSpace (E x)\ninst✝¹ : FiberBundle F E\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : Trivialization.IsLinear R e\nb : B\nhb : Membership.mem e.baseSet b\n⊢ Eq ⇑(Trivialization.continuousLinearEquivAt R e b hb).symm ⇑(Trivialization.symmL R e b)","decl":"theorem symm_continuousLinearEquivAt_eq (e : Trivialization F (π F E)) [e.IsLinear R] {b : B}\n    (hb : b ∈ e.baseSet) : ((e.continuousLinearEquivAt R b hb).symm : F → E b) = e.symmL R b :=\n  rfl\n\n"}
{"name":"Trivialization.continuousLinearEquivAt_apply'","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁹ : NontriviallyNormedField R\ninst✝⁸ : (x : B) → AddCommMonoid (E x)\ninst✝⁷ : (x : B) → Module R (E x)\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace R F\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝² : (x : B) → TopologicalSpace (E x)\ninst✝¹ : FiberBundle F E\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : Trivialization.IsLinear R e\nx : Bundle.TotalSpace F E\nhx : Membership.mem e.source x\n⊢ Eq ((Trivialization.continuousLinearEquivAt R e x.proj ⋯) x.snd) (↑e x).2","decl":"@[simp]\ntheorem continuousLinearEquivAt_apply' (e : Trivialization F (π F E)) [e.IsLinear R]\n    (x : TotalSpace F E) (hx : x ∈ e.source) :\n    e.continuousLinearEquivAt R x.proj (e.mem_source.1 hx) x.2 = (e x).2 := rfl\n\n"}
{"name":"Trivialization.apply_eq_prod_continuousLinearEquivAt","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁹ : NontriviallyNormedField R\ninst✝⁸ : (x : B) → AddCommMonoid (E x)\ninst✝⁷ : (x : B) → Module R (E x)\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace R F\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝² : (x : B) → TopologicalSpace (E x)\ninst✝¹ : FiberBundle F E\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : Trivialization.IsLinear R e\nb : B\nhb : Membership.mem e.baseSet b\nz : E b\n⊢ Eq (↑e { proj := b, snd := z }) { fst := b, snd := (Trivialization.continuousLinearEquivAt R e b hb) z }","decl":"theorem apply_eq_prod_continuousLinearEquivAt (e : Trivialization F (π F E)) [e.IsLinear R] (b : B)\n    (hb : b ∈ e.baseSet) (z : E b) : e ⟨b, z⟩ = (b, e.continuousLinearEquivAt R b hb z) := by\n  ext\n  · refine e.coe_fst ?_\n    rw [e.source_eq]\n    exact hb\n  · simp only [coe_coe, continuousLinearEquivAt_apply]\n\n"}
{"name":"Trivialization.zeroSection","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁹ : NontriviallyNormedField R\ninst✝⁸ : (x : B) → AddCommMonoid (E x)\ninst✝⁷ : (x : B) → Module R (E x)\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace R F\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝² : (x : B) → TopologicalSpace (E x)\ninst✝¹ : FiberBundle F E\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : Trivialization.IsLinear R e\nx : B\nhx : Membership.mem e.baseSet x\n⊢ Eq (↑e (Bundle.zeroSection F E x)) { fst := x, snd := 0 }","decl":"protected theorem zeroSection (e : Trivialization F (π F E)) [e.IsLinear R] {x : B}\n    (hx : x ∈ e.baseSet) : e (zeroSection F E x) = (x, 0) := by\n  simp_rw [zeroSection, e.apply_eq_prod_continuousLinearEquivAt R x hx 0, map_zero]\n\n"}
{"name":"Trivialization.symm_apply_eq_mk_continuousLinearEquivAt_symm","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁹ : NontriviallyNormedField R\ninst✝⁸ : (x : B) → AddCommMonoid (E x)\ninst✝⁷ : (x : B) → Module R (E x)\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace R F\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝² : (x : B) → TopologicalSpace (E x)\ninst✝¹ : FiberBundle F E\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : Trivialization.IsLinear R e\nb : B\nhb : Membership.mem e.baseSet b\nz : F\n⊢ Eq (↑e.symm { fst := b, snd := z }) { proj := b, snd := (Trivialization.continuousLinearEquivAt R e b hb).symm z }","decl":"theorem symm_apply_eq_mk_continuousLinearEquivAt_symm (e : Trivialization F (π F E)) [e.IsLinear R]\n    (b : B) (hb : b ∈ e.baseSet) (z : F) :\n    e.toPartialHomeomorph.symm ⟨b, z⟩ = ⟨b, (e.continuousLinearEquivAt R b hb).symm z⟩ := by\n  have h : (b, z) ∈ e.target := by\n    rw [e.target_eq]\n    exact ⟨hb, mem_univ _⟩\n  apply e.injOn (e.map_target h)\n  · simpa only [e.source_eq, mem_preimage]\n  · simp_rw [e.right_inv h, coe_coe, e.apply_eq_prod_continuousLinearEquivAt R b hb,\n      ContinuousLinearEquiv.apply_symm_apply]\n\n"}
{"name":"Trivialization.comp_continuousLinearEquivAt_eq_coord_change","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝¹⁰ : NontriviallyNormedField R\ninst✝⁹ : (x : B) → AddCommMonoid (E x)\ninst✝⁸ : (x : B) → Module R (E x)\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace R F\ninst✝⁵ : TopologicalSpace B\ninst✝⁴ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝³ : (x : B) → TopologicalSpace (E x)\ninst✝² : FiberBundle F E\ne e' : Trivialization F Bundle.TotalSpace.proj\ninst✝¹ : Trivialization.IsLinear R e\ninst✝ : Trivialization.IsLinear R e'\nb : B\nhb : Membership.mem (Inter.inter e.baseSet e'.baseSet) b\n⊢ Eq ((Trivialization.continuousLinearEquivAt R e b ⋯).symm.trans (Trivialization.continuousLinearEquivAt R e' b ⋯)) (Trivialization.coordChangeL R e e' b)","decl":"theorem comp_continuousLinearEquivAt_eq_coord_change (e e' : Trivialization F (π F E))\n    [e.IsLinear R] [e'.IsLinear R] {b : B} (hb : b ∈ e.baseSet ∩ e'.baseSet) :\n    (e.continuousLinearEquivAt R b hb.1).symm.trans (e'.continuousLinearEquivAt R b hb.2) =\n      coordChangeL R e e' b := by\n  ext v\n  rw [coordChangeL_apply e e' hb]\n  rfl\n\n"}
{"name":"VectorBundleCore.mk.sizeOf_spec","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝⁷ : NontriviallyNormedField R\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace R F\ninst✝⁴ : TopologicalSpace B\nι : Type u_5\ninst✝³ : SizeOf R\ninst✝² : SizeOf B\ninst✝¹ : SizeOf F\ninst✝ : SizeOf ι\nbaseSet : ι → Set B\nisOpen_baseSet : ∀ (i : ι), IsOpen (baseSet i)\nindexAt : B → ι\nmem_baseSet_at : ∀ (x : B), Membership.mem (baseSet (indexAt x)) x\ncoordChange : ι → ι → B → ContinuousLinearMap (RingHom.id R) F F\ncoordChange_self : ∀ (i : ι) (x : B), Membership.mem (baseSet i) x → ∀ (v : F), Eq ((coordChange i i x) v) v\ncontinuousOn_coordChange : ∀ (i j : ι), ContinuousOn (coordChange i j) (Inter.inter (baseSet i) (baseSet j))\ncoordChange_comp : ∀ (i j k : ι) (x : B), Membership.mem (Inter.inter (Inter.inter (baseSet i) (baseSet j)) (baseSet k)) x → ∀ (v : F), Eq ((coordChange j k x) ((coordChange i j x) v)) ((coordChange i k x) v)\n⊢ Eq (SizeOf.sizeOf { baseSet := baseSet, isOpen_baseSet := isOpen_baseSet, indexAt := indexAt, mem_baseSet_at := mem_baseSet_at, coordChange := coordChange, coordChange_self := coordChange_self, continuousOn_coordChange := continuousOn_coordChange, coordChange_comp := coordChange_comp }) 1","decl":"/-- Analogous construction of `FiberBundleCore` for vector bundles. This\nconstruction gives a way to construct vector bundles from a structure registering how\ntrivialization changes act on fibers. -/\nstructure VectorBundleCore (ι : Type*) where\n  baseSet : ι → Set B\n  isOpen_baseSet : ∀ i, IsOpen (baseSet i)\n  indexAt : B → ι\n  mem_baseSet_at : ∀ x, x ∈ baseSet (indexAt x)\n  coordChange : ι → ι → B → F →L[R] F\n  coordChange_self : ∀ i, ∀ x ∈ baseSet i, ∀ v, coordChange i i x v = v\n  continuousOn_coordChange : ∀ i j, ContinuousOn (coordChange i j) (baseSet i ∩ baseSet j)\n  coordChange_comp : ∀ i j k, ∀ x ∈ baseSet i ∩ baseSet j ∩ baseSet k, ∀ v,\n    (coordChange j k x) (coordChange i j x v) = coordChange i k x v\n\n"}
{"name":"VectorBundleCore.isOpen_baseSet","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nself : VectorBundleCore R B F ι\ni : ι\n⊢ IsOpen (self.baseSet i)","decl":"/-- Analogous construction of `FiberBundleCore` for vector bundles. This\nconstruction gives a way to construct vector bundles from a structure registering how\ntrivialization changes act on fibers. -/\nstructure VectorBundleCore (ι : Type*) where\n  baseSet : ι → Set B\n  isOpen_baseSet : ∀ i, IsOpen (baseSet i)\n  indexAt : B → ι\n  mem_baseSet_at : ∀ x, x ∈ baseSet (indexAt x)\n  coordChange : ι → ι → B → F →L[R] F\n  coordChange_self : ∀ i, ∀ x ∈ baseSet i, ∀ v, coordChange i i x v = v\n  continuousOn_coordChange : ∀ i j, ContinuousOn (coordChange i j) (baseSet i ∩ baseSet j)\n  coordChange_comp : ∀ i j k, ∀ x ∈ baseSet i ∩ baseSet j ∩ baseSet k, ∀ v,\n    (coordChange j k x) (coordChange i j x v) = coordChange i k x v\n\n"}
{"name":"VectorBundleCore.mk.inj","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nbaseSet✝ : ι → Set B\nisOpen_baseSet✝ : ∀ (i : ι), IsOpen (baseSet✝ i)\nindexAt✝ : B → ι\nmem_baseSet_at✝ : ∀ (x : B), Membership.mem (baseSet✝ (indexAt✝ x)) x\ncoordChange✝ : ι → ι → B → ContinuousLinearMap (RingHom.id R) F F\ncoordChange_self✝ : ∀ (i : ι) (x : B), Membership.mem (baseSet✝ i) x → ∀ (v : F), Eq ((coordChange✝ i i x) v) v\ncontinuousOn_coordChange✝ : ∀ (i j : ι), ContinuousOn (coordChange✝ i j) (Inter.inter (baseSet✝ i) (baseSet✝ j))\ncoordChange_comp✝ : ∀ (i j k : ι) (x : B), Membership.mem (Inter.inter (Inter.inter (baseSet✝ i) (baseSet✝ j)) (baseSet✝ k)) x → ∀ (v : F), Eq ((coordChange✝ j k x) ((coordChange✝ i j x) v)) ((coordChange✝ i k x) v)\nbaseSet : ι → Set B\nisOpen_baseSet : ∀ (i : ι), IsOpen (baseSet i)\nindexAt : B → ι\nmem_baseSet_at : ∀ (x : B), Membership.mem (baseSet (indexAt x)) x\ncoordChange : ι → ι → B → ContinuousLinearMap (RingHom.id R) F F\ncoordChange_self : ∀ (i : ι) (x : B), Membership.mem (baseSet i) x → ∀ (v : F), Eq ((coordChange i i x) v) v\ncontinuousOn_coordChange : ∀ (i j : ι), ContinuousOn (coordChange i j) (Inter.inter (baseSet i) (baseSet j))\ncoordChange_comp : ∀ (i j k : ι) (x : B), Membership.mem (Inter.inter (Inter.inter (baseSet i) (baseSet j)) (baseSet k)) x → ∀ (v : F), Eq ((coordChange j k x) ((coordChange i j x) v)) ((coordChange i k x) v)\nx✝ : Eq { baseSet := baseSet✝, isOpen_baseSet := isOpen_baseSet✝, indexAt := indexAt✝, mem_baseSet_at := mem_baseSet_at✝, coordChange := coordChange✝, coordChange_self := coordChange_self✝, continuousOn_coordChange := continuousOn_coordChange✝, coordChange_comp := coordChange_comp✝ } { baseSet := baseSet, isOpen_baseSet := isOpen_baseSet, indexAt := indexAt, mem_baseSet_at := mem_baseSet_at, coordChange := coordChange, coordChange_self := coordChange_self, continuousOn_coordChange := continuousOn_coordChange, coordChange_comp := coordChange_comp }\n⊢ And (Eq baseSet✝ baseSet) (And (Eq indexAt✝ indexAt) (Eq coordChange✝ coordChange))","decl":"/-- Analogous construction of `FiberBundleCore` for vector bundles. This\nconstruction gives a way to construct vector bundles from a structure registering how\ntrivialization changes act on fibers. -/\nstructure VectorBundleCore (ι : Type*) where\n  baseSet : ι → Set B\n  isOpen_baseSet : ∀ i, IsOpen (baseSet i)\n  indexAt : B → ι\n  mem_baseSet_at : ∀ x, x ∈ baseSet (indexAt x)\n  coordChange : ι → ι → B → F →L[R] F\n  coordChange_self : ∀ i, ∀ x ∈ baseSet i, ∀ v, coordChange i i x v = v\n  continuousOn_coordChange : ∀ i j, ContinuousOn (coordChange i j) (baseSet i ∩ baseSet j)\n  coordChange_comp : ∀ i j k, ∀ x ∈ baseSet i ∩ baseSet j ∩ baseSet k, ∀ v,\n    (coordChange j k x) (coordChange i j x v) = coordChange i k x v\n\n"}
{"name":"VectorBundleCore.coordChange_comp","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nself : VectorBundleCore R B F ι\ni j k : ι\nx : B\na✝ : Membership.mem (Inter.inter (Inter.inter (self.baseSet i) (self.baseSet j)) (self.baseSet k)) x\nv : F\n⊢ Eq ((self.coordChange j k x) ((self.coordChange i j x) v)) ((self.coordChange i k x) v)","decl":"/-- Analogous construction of `FiberBundleCore` for vector bundles. This\nconstruction gives a way to construct vector bundles from a structure registering how\ntrivialization changes act on fibers. -/\nstructure VectorBundleCore (ι : Type*) where\n  baseSet : ι → Set B\n  isOpen_baseSet : ∀ i, IsOpen (baseSet i)\n  indexAt : B → ι\n  mem_baseSet_at : ∀ x, x ∈ baseSet (indexAt x)\n  coordChange : ι → ι → B → F →L[R] F\n  coordChange_self : ∀ i, ∀ x ∈ baseSet i, ∀ v, coordChange i i x v = v\n  continuousOn_coordChange : ∀ i j, ContinuousOn (coordChange i j) (baseSet i ∩ baseSet j)\n  coordChange_comp : ∀ i j k, ∀ x ∈ baseSet i ∩ baseSet j ∩ baseSet k, ∀ v,\n    (coordChange j k x) (coordChange i j x v) = coordChange i k x v\n\n"}
{"name":"VectorBundleCore.mk.injEq","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nbaseSet✝ : ι → Set B\nisOpen_baseSet✝ : ∀ (i : ι), IsOpen (baseSet✝ i)\nindexAt✝ : B → ι\nmem_baseSet_at✝ : ∀ (x : B), Membership.mem (baseSet✝ (indexAt✝ x)) x\ncoordChange✝ : ι → ι → B → ContinuousLinearMap (RingHom.id R) F F\ncoordChange_self✝ : ∀ (i : ι) (x : B), Membership.mem (baseSet✝ i) x → ∀ (v : F), Eq ((coordChange✝ i i x) v) v\ncontinuousOn_coordChange✝ : ∀ (i j : ι), ContinuousOn (coordChange✝ i j) (Inter.inter (baseSet✝ i) (baseSet✝ j))\ncoordChange_comp✝ : ∀ (i j k : ι) (x : B), Membership.mem (Inter.inter (Inter.inter (baseSet✝ i) (baseSet✝ j)) (baseSet✝ k)) x → ∀ (v : F), Eq ((coordChange✝ j k x) ((coordChange✝ i j x) v)) ((coordChange✝ i k x) v)\nbaseSet : ι → Set B\nisOpen_baseSet : ∀ (i : ι), IsOpen (baseSet i)\nindexAt : B → ι\nmem_baseSet_at : ∀ (x : B), Membership.mem (baseSet (indexAt x)) x\ncoordChange : ι → ι → B → ContinuousLinearMap (RingHom.id R) F F\ncoordChange_self : ∀ (i : ι) (x : B), Membership.mem (baseSet i) x → ∀ (v : F), Eq ((coordChange i i x) v) v\ncontinuousOn_coordChange : ∀ (i j : ι), ContinuousOn (coordChange i j) (Inter.inter (baseSet i) (baseSet j))\ncoordChange_comp : ∀ (i j k : ι) (x : B), Membership.mem (Inter.inter (Inter.inter (baseSet i) (baseSet j)) (baseSet k)) x → ∀ (v : F), Eq ((coordChange j k x) ((coordChange i j x) v)) ((coordChange i k x) v)\n⊢ Eq (Eq { baseSet := baseSet✝, isOpen_baseSet := isOpen_baseSet✝, indexAt := indexAt✝, mem_baseSet_at := mem_baseSet_at✝, coordChange := coordChange✝, coordChange_self := coordChange_self✝, continuousOn_coordChange := continuousOn_coordChange✝, coordChange_comp := coordChange_comp✝ } { baseSet := baseSet, isOpen_baseSet := isOpen_baseSet, indexAt := indexAt, mem_baseSet_at := mem_baseSet_at, coordChange := coordChange, coordChange_self := coordChange_self, continuousOn_coordChange := continuousOn_coordChange, coordChange_comp := coordChange_comp }) (And (Eq baseSet✝ baseSet) (And (Eq indexAt✝ indexAt) (Eq coordChange✝ coordChange)))","decl":"/-- Analogous construction of `FiberBundleCore` for vector bundles. This\nconstruction gives a way to construct vector bundles from a structure registering how\ntrivialization changes act on fibers. -/\nstructure VectorBundleCore (ι : Type*) where\n  baseSet : ι → Set B\n  isOpen_baseSet : ∀ i, IsOpen (baseSet i)\n  indexAt : B → ι\n  mem_baseSet_at : ∀ x, x ∈ baseSet (indexAt x)\n  coordChange : ι → ι → B → F →L[R] F\n  coordChange_self : ∀ i, ∀ x ∈ baseSet i, ∀ v, coordChange i i x v = v\n  continuousOn_coordChange : ∀ i j, ContinuousOn (coordChange i j) (baseSet i ∩ baseSet j)\n  coordChange_comp : ∀ i j k, ∀ x ∈ baseSet i ∩ baseSet j ∩ baseSet k, ∀ v,\n    (coordChange j k x) (coordChange i j x v) = coordChange i k x v\n\n"}
{"name":"VectorBundleCore.continuousOn_coordChange","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nself : VectorBundleCore R B F ι\ni j : ι\n⊢ ContinuousOn (self.coordChange i j) (Inter.inter (self.baseSet i) (self.baseSet j))","decl":"/-- Analogous construction of `FiberBundleCore` for vector bundles. This\nconstruction gives a way to construct vector bundles from a structure registering how\ntrivialization changes act on fibers. -/\nstructure VectorBundleCore (ι : Type*) where\n  baseSet : ι → Set B\n  isOpen_baseSet : ∀ i, IsOpen (baseSet i)\n  indexAt : B → ι\n  mem_baseSet_at : ∀ x, x ∈ baseSet (indexAt x)\n  coordChange : ι → ι → B → F →L[R] F\n  coordChange_self : ∀ i, ∀ x ∈ baseSet i, ∀ v, coordChange i i x v = v\n  continuousOn_coordChange : ∀ i j, ContinuousOn (coordChange i j) (baseSet i ∩ baseSet j)\n  coordChange_comp : ∀ i j k, ∀ x ∈ baseSet i ∩ baseSet j ∩ baseSet k, ∀ v,\n    (coordChange j k x) (coordChange i j x v) = coordChange i k x v\n\n"}
{"name":"VectorBundleCore.mem_baseSet_at","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nself : VectorBundleCore R B F ι\nx : B\n⊢ Membership.mem (self.baseSet (self.indexAt x)) x","decl":"/-- Analogous construction of `FiberBundleCore` for vector bundles. This\nconstruction gives a way to construct vector bundles from a structure registering how\ntrivialization changes act on fibers. -/\nstructure VectorBundleCore (ι : Type*) where\n  baseSet : ι → Set B\n  isOpen_baseSet : ∀ i, IsOpen (baseSet i)\n  indexAt : B → ι\n  mem_baseSet_at : ∀ x, x ∈ baseSet (indexAt x)\n  coordChange : ι → ι → B → F →L[R] F\n  coordChange_self : ∀ i, ∀ x ∈ baseSet i, ∀ v, coordChange i i x v = v\n  continuousOn_coordChange : ∀ i j, ContinuousOn (coordChange i j) (baseSet i ∩ baseSet j)\n  coordChange_comp : ∀ i j k, ∀ x ∈ baseSet i ∩ baseSet j ∩ baseSet k, ∀ v,\n    (coordChange j k x) (coordChange i j x v) = coordChange i k x v\n\n"}
{"name":"VectorBundleCore.coordChange_self","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nself : VectorBundleCore R B F ι\ni : ι\nx : B\na✝ : Membership.mem (self.baseSet i) x\nv : F\n⊢ Eq ((self.coordChange i i x) v) v","decl":"/-- Analogous construction of `FiberBundleCore` for vector bundles. This\nconstruction gives a way to construct vector bundles from a structure registering how\ntrivialization changes act on fibers. -/\nstructure VectorBundleCore (ι : Type*) where\n  baseSet : ι → Set B\n  isOpen_baseSet : ∀ i, IsOpen (baseSet i)\n  indexAt : B → ι\n  mem_baseSet_at : ∀ x, x ∈ baseSet (indexAt x)\n  coordChange : ι → ι → B → F →L[R] F\n  coordChange_self : ∀ i, ∀ x ∈ baseSet i, ∀ v, coordChange i i x v = v\n  continuousOn_coordChange : ∀ i j, ContinuousOn (coordChange i j) (baseSet i ∩ baseSet j)\n  coordChange_comp : ∀ i j k, ∀ x ∈ baseSet i ∩ baseSet j ∩ baseSet k, ∀ v,\n    (coordChange j k x) (coordChange i j x v) = coordChange i k x v\n\n"}
{"name":"VectorBundleCore.toFiberBundleCore_coordChange","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\n⊢ Eq Z.toFiberBundleCore.coordChange fun i j b => ⇑(Z.coordChange i j b)","decl":"/-- Natural identification to a `FiberBundleCore`. -/\n@[simps (config := mfld_cfg)]\ndef toFiberBundleCore : FiberBundleCore ι B F :=\n  { Z with\n    coordChange := fun i j b => Z.coordChange i j b\n    continuousOn_coordChange := fun i j =>\n      isBoundedBilinearMap_apply.continuous.comp_continuousOn\n        ((Z.continuousOn_coordChange i j).prod_map continuousOn_id) }\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: restore coercion\n-- instance toFiberBundleCoreCoe : Coe (VectorBundleCore R B F ι) (FiberBundleCore ι B F) :=\n--   ⟨toFiberBundleCore⟩\n\n"}
{"name":"VectorBundleCore.toFiberBundleCore_baseSet","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\n⊢ Eq Z.toFiberBundleCore.baseSet Z.baseSet","decl":"/-- Natural identification to a `FiberBundleCore`. -/\n@[simps (config := mfld_cfg)]\ndef toFiberBundleCore : FiberBundleCore ι B F :=\n  { Z with\n    coordChange := fun i j b => Z.coordChange i j b\n    continuousOn_coordChange := fun i j =>\n      isBoundedBilinearMap_apply.continuous.comp_continuousOn\n        ((Z.continuousOn_coordChange i j).prod_map continuousOn_id) }\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: restore coercion\n-- instance toFiberBundleCoreCoe : Coe (VectorBundleCore R B F ι) (FiberBundleCore ι B F) :=\n--   ⟨toFiberBundleCore⟩\n\n"}
{"name":"VectorBundleCore.toFiberBundleCore_indexAt","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\n⊢ Eq Z.toFiberBundleCore.indexAt Z.indexAt","decl":"/-- Natural identification to a `FiberBundleCore`. -/\n@[simps (config := mfld_cfg)]\ndef toFiberBundleCore : FiberBundleCore ι B F :=\n  { Z with\n    coordChange := fun i j b => Z.coordChange i j b\n    continuousOn_coordChange := fun i j =>\n      isBoundedBilinearMap_apply.continuous.comp_continuousOn\n        ((Z.continuousOn_coordChange i j).prod_map continuousOn_id) }\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: restore coercion\n-- instance toFiberBundleCoreCoe : Coe (VectorBundleCore R B F ι) (FiberBundleCore ι B F) :=\n--   ⟨toFiberBundleCore⟩\n\n"}
{"name":"VectorBundleCore.coordChange_linear_comp","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\ni j k : ι\nx : B\na✝ : Membership.mem (Inter.inter (Inter.inter (Z.baseSet i) (Z.baseSet j)) (Z.baseSet k)) x\n⊢ Eq ((Z.coordChange j k x).comp (Z.coordChange i j x)) (Z.coordChange i k x)","decl":"theorem coordChange_linear_comp (i j k : ι) :\n    ∀ x ∈ Z.baseSet i ∩ Z.baseSet j ∩ Z.baseSet k,\n      (Z.coordChange j k x).comp (Z.coordChange i j x) = Z.coordChange i k x :=\n  fun x hx => by\n  ext v\n  exact Z.coordChange_comp i j k x hx v\n\n"}
{"name":"VectorBundleCore.mem_trivChange_source","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\ni j : ι\np : Prod B F\n⊢ Iff (Membership.mem (Z.trivChange i j).source p) (Membership.mem (Inter.inter (Z.baseSet i) (Z.baseSet j)) p.1)","decl":"@[simp, mfld_simps]\ntheorem mem_trivChange_source (i j : ι) (p : B × F) :\n    p ∈ (Z.trivChange i j).source ↔ p.1 ∈ Z.baseSet i ∩ Z.baseSet j :=\n  Z.toFiberBundleCore.mem_trivChange_source i j p\n\n"}
{"name":"VectorBundleCore.coe_coordChange","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\nb : B\ni j : ι\n⊢ Eq (Z.toFiberBundleCore.coordChange i j b) ⇑(Z.coordChange i j b)","decl":"@[simp, mfld_simps]\ntheorem coe_coordChange (i j : ι) : Z.toFiberBundleCore.coordChange i j b = Z.coordChange i j b :=\n  rfl\n\n"}
{"name":"VectorBundleCore.localTriv_apply","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\ni : ι\np : Z.TotalSpace\n⊢ Eq (↑(Z.localTriv i) p) { fst := p.proj, snd := (Z.coordChange (Z.indexAt p.proj) i p.proj) p.snd }","decl":"@[simp, mfld_simps]\ntheorem localTriv_apply {i : ι} (p : Z.TotalSpace) :\n    (Z.localTriv i) p = ⟨p.1, Z.coordChange (Z.indexAt p.1) i p.1 p.2⟩ :=\n  rfl\n\n"}
{"name":"VectorBundleCore.localTriv.isLinear","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\ni : ι\n⊢ Trivialization.IsLinear R (Z.localTriv i)","decl":"/-- The standard local trivializations of a vector bundle constructed from core are linear. -/\ninstance localTriv.isLinear (i : ι) : (Z.localTriv i).IsLinear R where\n  linear x _ :=\n    { map_add := fun _ _ => by simp only [map_add, localTriv_apply, mfld_simps]\n      map_smul := fun _ _ => by simp only [map_smul, localTriv_apply, mfld_simps] }\n\n"}
{"name":"VectorBundleCore.mem_localTriv_source","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\ni : ι\np : Z.TotalSpace\n⊢ Iff (Membership.mem (Z.localTriv i).source p) (Membership.mem (Z.baseSet i) p.proj)","decl":"@[simp, mfld_simps]\ntheorem mem_localTriv_source (p : Z.TotalSpace) : p ∈ (Z.localTriv i).source ↔ p.1 ∈ Z.baseSet i :=\n  Iff.rfl\n\n"}
{"name":"VectorBundleCore.baseSet_at","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\ni : ι\n⊢ Eq (Z.baseSet i) (Z.localTriv i).baseSet","decl":"@[simp, mfld_simps]\ntheorem baseSet_at : Z.baseSet i = (Z.localTriv i).baseSet :=\n  rfl\n\n"}
{"name":"VectorBundleCore.mem_localTriv_target","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\ni : ι\np : Prod B F\n⊢ Iff (Membership.mem (Z.localTriv i).target p) (Membership.mem (Z.localTriv i).baseSet p.1)","decl":"@[simp, mfld_simps]\ntheorem mem_localTriv_target (p : B × F) :\n    p ∈ (Z.localTriv i).target ↔ p.1 ∈ (Z.localTriv i).baseSet :=\n  Z.toFiberBundleCore.mem_localTriv_target i p\n\n"}
{"name":"VectorBundleCore.localTriv_symm_fst","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\ni : ι\np : Prod B F\n⊢ Eq (↑(Z.localTriv i).symm p) { proj := p.1, snd := (Z.coordChange i (Z.indexAt p.1) p.1) p.2 }","decl":"@[simp, mfld_simps]\ntheorem localTriv_symm_fst (p : B × F) :\n    (Z.localTriv i).toPartialHomeomorph.symm p = ⟨p.1, Z.coordChange i (Z.indexAt p.1) p.1 p.2⟩ :=\n  rfl\n\n"}
{"name":"VectorBundleCore.localTriv_symm_apply","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\ni : ι\nb : B\nhb : Membership.mem (Z.baseSet i) b\nv : F\n⊢ Eq ((Z.localTriv i).symm b v) ((Z.coordChange i (Z.indexAt b) b) v)","decl":"@[simp, mfld_simps]\ntheorem localTriv_symm_apply {b : B} (hb : b ∈ Z.baseSet i) (v : F) :\n    (Z.localTriv i).symm b v = Z.coordChange i (Z.indexAt b) b v := by\n  apply (Z.localTriv i).symm_apply hb v\n\n"}
{"name":"VectorBundleCore.localTriv_coordChange_eq","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\ni j : ι\nb : B\nhb : Membership.mem (Inter.inter (Z.baseSet i) (Z.baseSet j)) b\nv : F\n⊢ Eq ((Trivialization.coordChangeL R (Z.localTriv i) (Z.localTriv j) b) v) ((Z.coordChange i j b) v)","decl":"@[simp, mfld_simps]\ntheorem localTriv_coordChange_eq {b : B} (hb : b ∈ Z.baseSet i ∩ Z.baseSet j) (v : F) :\n    (Z.localTriv i).coordChangeL R (Z.localTriv j) b v = Z.coordChange i j b v := by\n  rw [Trivialization.coordChangeL_apply', localTriv_symm_fst, localTriv_apply, coordChange_comp]\n  exacts [⟨⟨hb.1, Z.mem_baseSet_at b⟩, hb.2⟩, hb]\n\n"}
{"name":"VectorBundleCore.localTrivAt_def","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\nb : B\n⊢ Eq (Z.localTriv (Z.indexAt b)) (Z.localTrivAt b)","decl":"@[simp, mfld_simps]\ntheorem localTrivAt_def : Z.localTriv (Z.indexAt b) = Z.localTrivAt b :=\n  rfl\n\n"}
{"name":"VectorBundleCore.mem_source_at","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\nb : B\na : F\n⊢ Membership.mem (Z.localTrivAt b).source { proj := b, snd := a }","decl":"@[simp, mfld_simps]\ntheorem mem_source_at : (⟨b, a⟩ : Z.TotalSpace) ∈ (Z.localTrivAt b).source := by\n  rw [localTrivAt, mem_localTriv_source]\n  exact Z.mem_baseSet_at b\n\n"}
{"name":"VectorBundleCore.localTrivAt_apply","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\np : Z.TotalSpace\n⊢ Eq (↑(Z.localTrivAt p.proj) p) { fst := p.proj, snd := p.snd }","decl":"@[simp, mfld_simps]\ntheorem localTrivAt_apply (p : Z.TotalSpace) : Z.localTrivAt p.1 p = ⟨p.1, p.2⟩ :=\n  Z.toFiberBundleCore.localTrivAt_apply p\n\n"}
{"name":"VectorBundleCore.localTrivAt_apply_mk","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\nb : B\na : F\n⊢ Eq (↑(Z.localTrivAt b) { proj := b, snd := a }) { fst := b, snd := a }","decl":"@[simp, mfld_simps]\ntheorem localTrivAt_apply_mk (b : B) (a : F) : Z.localTrivAt b ⟨b, a⟩ = ⟨b, a⟩ :=\n  Z.localTrivAt_apply _\n\n"}
{"name":"VectorBundleCore.mem_localTrivAt_baseSet","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\nb : B\n⊢ Membership.mem (Z.localTrivAt b).baseSet b","decl":"@[simp, mfld_simps]\ntheorem mem_localTrivAt_baseSet : b ∈ (Z.localTrivAt b).baseSet :=\n  Z.toFiberBundleCore.mem_localTrivAt_baseSet b\n\n"}
{"name":"VectorBundleCore.vectorBundle","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\n⊢ VectorBundle R F Z.Fiber","decl":"instance vectorBundle : VectorBundle R F Z.Fiber where\n  trivialization_linear' := by\n    rintro _ ⟨i, rfl⟩\n    apply localTriv.isLinear\n  continuousOn_coordChange' := by\n    rintro _ _ ⟨i, rfl⟩ ⟨i', rfl⟩\n    refine (Z.continuousOn_coordChange i i').congr fun b hb => ?_\n    ext v\n    exact Z.localTriv_coordChange_eq i i' hb v\n\n"}
{"name":"VectorBundleCore.continuous_proj","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\n⊢ Continuous Z.proj","decl":"/-- The projection on the base of a vector bundle created from core is continuous -/\n@[continuity]\ntheorem continuous_proj : Continuous Z.proj :=\n  Z.toFiberBundleCore.continuous_proj\n\n"}
{"name":"VectorBundleCore.isOpenMap_proj","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\n⊢ IsOpenMap Z.proj","decl":"/-- The projection on the base of a vector bundle created from core is an open map -/\ntheorem isOpenMap_proj : IsOpenMap Z.proj :=\n  Z.toFiberBundleCore.isOpenMap_proj\n\n"}
{"name":"VectorBundleCore.localTriv_continuousLinearMapAt","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\ni : ι\nb : B\nhb : Membership.mem (Z.baseSet i) b\n⊢ Eq (Trivialization.continuousLinearMapAt R (Z.localTriv i) b) (Z.coordChange (Z.indexAt b) i b)","decl":"@[simp, mfld_simps]\ntheorem localTriv_continuousLinearMapAt {b : B} (hb : b ∈ Z.baseSet i) :\n    (Z.localTriv i).continuousLinearMapAt R b = Z.coordChange (Z.indexAt b) i b := by\n  ext1 v\n  rw [(Z.localTriv i).continuousLinearMapAt_apply R, (Z.localTriv i).coe_linearMapAt_of_mem]\n  exacts [rfl, hb]\n\n"}
{"name":"VectorBundleCore.trivializationAt_continuousLinearMapAt","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\nb₀ b : B\nhb : Membership.mem (FiberBundle.trivializationAt F Z.Fiber b₀).baseSet b\n⊢ Eq (Trivialization.continuousLinearMapAt R (FiberBundle.trivializationAt F Z.Fiber b₀) b) (Z.coordChange (Z.indexAt b) (Z.indexAt b₀) b)","decl":"@[simp, mfld_simps]\ntheorem trivializationAt_continuousLinearMapAt {b₀ b : B}\n    (hb : b ∈ (trivializationAt F Z.Fiber b₀).baseSet) :\n    (trivializationAt F Z.Fiber b₀).continuousLinearMapAt R b =\n      Z.coordChange (Z.indexAt b) (Z.indexAt b₀) b :=\n  Z.localTriv_continuousLinearMapAt hb\n\n"}
{"name":"VectorBundleCore.localTriv_symmL","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\ni : ι\nb : B\nhb : Membership.mem (Z.baseSet i) b\n⊢ Eq (Trivialization.symmL R (Z.localTriv i) b) (Z.coordChange i (Z.indexAt b) b)","decl":"@[simp, mfld_simps]\ntheorem localTriv_symmL {b : B} (hb : b ∈ Z.baseSet i) :\n    (Z.localTriv i).symmL R b = Z.coordChange i (Z.indexAt b) b := by\n  ext1 v\n  rw [(Z.localTriv i).symmL_apply R, (Z.localTriv i).symm_apply]\n  exacts [rfl, hb]\n\n"}
{"name":"VectorBundleCore.trivializationAt_symmL","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\nb₀ b : B\nhb : Membership.mem (FiberBundle.trivializationAt F Z.Fiber b₀).baseSet b\n⊢ Eq (Trivialization.symmL R (FiberBundle.trivializationAt F Z.Fiber b₀) b) (Z.coordChange (Z.indexAt b₀) (Z.indexAt b) b)","decl":"@[simp, mfld_simps]\ntheorem trivializationAt_symmL {b₀ b : B} (hb : b ∈ (trivializationAt F Z.Fiber b₀).baseSet) :\n    (trivializationAt F Z.Fiber b₀).symmL R b = Z.coordChange (Z.indexAt b₀) (Z.indexAt b) b :=\n  Z.localTriv_symmL hb\n\n"}
{"name":"VectorBundleCore.trivializationAt_coordChange_eq","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField R\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace R F\ninst✝ : TopologicalSpace B\nι : Type u_5\nZ : VectorBundleCore R B F ι\nb₀ b₁ b : B\nhb : Membership.mem (Inter.inter (FiberBundle.trivializationAt F Z.Fiber b₀).baseSet (FiberBundle.trivializationAt F Z.Fiber b₁).baseSet) b\nv : F\n⊢ Eq ((Trivialization.coordChangeL R (FiberBundle.trivializationAt F Z.Fiber b₀) (FiberBundle.trivializationAt F Z.Fiber b₁) b) v) ((Z.coordChange (Z.indexAt b₀) (Z.indexAt b₁) b) v)","decl":"@[simp, mfld_simps]\ntheorem trivializationAt_coordChange_eq {b₀ b₁ b : B}\n    (hb : b ∈ (trivializationAt F Z.Fiber b₀).baseSet ∩ (trivializationAt F Z.Fiber b₁).baseSet)\n    (v : F) :\n    (trivializationAt F Z.Fiber b₀).coordChangeL R (trivializationAt F Z.Fiber b₁) b v =\n      Z.coordChange (Z.indexAt b₀) (Z.indexAt b₁) b v :=\n  Z.localTriv_coordChange_eq _ _ hb v\n\n"}
{"name":"VectorPrebundle.totalSpaceMk_isInducing","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁶ : NontriviallyNormedField R\ninst✝⁵ : (x : B) → AddCommMonoid (E x)\ninst✝⁴ : (x : B) → Module R (E x)\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace R F\ninst✝¹ : TopologicalSpace B\ninst✝ : (x : B) → TopologicalSpace (E x)\nself : VectorPrebundle R F E\nb : B\n⊢ Topology.IsInducing (Function.comp (↑(self.pretrivializationAt b)) (Bundle.TotalSpace.mk b))","decl":"/-- This structure permits to define a vector bundle when trivializations are given as local\nequivalences but there is not yet a topology on the total space or the fibers.\nThe total space is hence given a topology in such a way that there is a fiber bundle structure for\nwhich the partial equivalences are also partial homeomorphisms and hence vector bundle\ntrivializations. The topology on the fibers is induced from the one on the total space.\n\nThe field `exists_coordChange` is stated as an existential statement (instead of 3 separate\nfields), since it depends on propositional information (namely `e e' ∈ pretrivializationAtlas`).\nThis makes it inconvenient to explicitly define a `coordChange` function when constructing a\n`VectorPrebundle`. -/\nstructure VectorPrebundle where\n  pretrivializationAtlas : Set (Pretrivialization F (π F E))\n  pretrivialization_linear' : ∀ e, e ∈ pretrivializationAtlas → e.IsLinear R\n  pretrivializationAt : B → Pretrivialization F (π F E)\n  mem_base_pretrivializationAt : ∀ x : B, x ∈ (pretrivializationAt x).baseSet\n  pretrivialization_mem_atlas : ∀ x : B, pretrivializationAt x ∈ pretrivializationAtlas\n  exists_coordChange : ∀ᵉ (e ∈ pretrivializationAtlas) (e' ∈ pretrivializationAtlas),\n    ∃ f : B → F →L[R] F, ContinuousOn f (e.baseSet ∩ e'.baseSet) ∧\n      ∀ᵉ (b ∈ e.baseSet ∩ e'.baseSet) (v : F), f b v = (e' ⟨b, e.symm b v⟩).2\n  totalSpaceMk_isInducing : ∀ b : B, IsInducing (pretrivializationAt b ∘ .mk b)\n\n"}
{"name":"VectorPrebundle.mk.injEq","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁶ : NontriviallyNormedField R\ninst✝⁵ : (x : B) → AddCommMonoid (E x)\ninst✝⁴ : (x : B) → Module R (E x)\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace R F\ninst✝¹ : TopologicalSpace B\ninst✝ : (x : B) → TopologicalSpace (E x)\npretrivializationAtlas✝ : Set (Pretrivialization F Bundle.TotalSpace.proj)\npretrivialization_linear'✝ : ∀ (e : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas✝ e → Pretrivialization.IsLinear R e\npretrivializationAt✝ : B → Pretrivialization F Bundle.TotalSpace.proj\nmem_base_pretrivializationAt✝ : ∀ (x : B), Membership.mem (pretrivializationAt✝ x).baseSet x\npretrivialization_mem_atlas✝ : ∀ (x : B), Membership.mem pretrivializationAtlas✝ (pretrivializationAt✝ x)\nexists_coordChange✝ : ∀ (e : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas✝ e → ∀ (e' : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas✝ e' → Exists fun f => And (ContinuousOn f (Inter.inter e.baseSet e'.baseSet)) (∀ (b : B), Membership.mem (Inter.inter e.baseSet e'.baseSet) b → ∀ (v : F), Eq ((f b) v) (↑e' { proj := b, snd := e.symm b v }).2)\ntotalSpaceMk_isInducing✝ : ∀ (b : B), Topology.IsInducing (Function.comp (↑(pretrivializationAt✝ b)) (Bundle.TotalSpace.mk b))\npretrivializationAtlas : Set (Pretrivialization F Bundle.TotalSpace.proj)\npretrivialization_linear' : ∀ (e : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas e → Pretrivialization.IsLinear R e\npretrivializationAt : B → Pretrivialization F Bundle.TotalSpace.proj\nmem_base_pretrivializationAt : ∀ (x : B), Membership.mem (pretrivializationAt x).baseSet x\npretrivialization_mem_atlas : ∀ (x : B), Membership.mem pretrivializationAtlas (pretrivializationAt x)\nexists_coordChange : ∀ (e : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas e → ∀ (e' : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas e' → Exists fun f => And (ContinuousOn f (Inter.inter e.baseSet e'.baseSet)) (∀ (b : B), Membership.mem (Inter.inter e.baseSet e'.baseSet) b → ∀ (v : F), Eq ((f b) v) (↑e' { proj := b, snd := e.symm b v }).2)\ntotalSpaceMk_isInducing : ∀ (b : B), Topology.IsInducing (Function.comp (↑(pretrivializationAt b)) (Bundle.TotalSpace.mk b))\n⊢ Eq (Eq { pretrivializationAtlas := pretrivializationAtlas✝, pretrivialization_linear' := pretrivialization_linear'✝, pretrivializationAt := pretrivializationAt✝, mem_base_pretrivializationAt := mem_base_pretrivializationAt✝, pretrivialization_mem_atlas := pretrivialization_mem_atlas✝, exists_coordChange := exists_coordChange✝, totalSpaceMk_isInducing := totalSpaceMk_isInducing✝ } { pretrivializationAtlas := pretrivializationAtlas, pretrivialization_linear' := pretrivialization_linear', pretrivializationAt := pretrivializationAt, mem_base_pretrivializationAt := mem_base_pretrivializationAt, pretrivialization_mem_atlas := pretrivialization_mem_atlas, exists_coordChange := exists_coordChange, totalSpaceMk_isInducing := totalSpaceMk_isInducing }) (And (Eq pretrivializationAtlas✝ pretrivializationAtlas) (Eq pretrivializationAt✝ pretrivializationAt))","decl":"/-- This structure permits to define a vector bundle when trivializations are given as local\nequivalences but there is not yet a topology on the total space or the fibers.\nThe total space is hence given a topology in such a way that there is a fiber bundle structure for\nwhich the partial equivalences are also partial homeomorphisms and hence vector bundle\ntrivializations. The topology on the fibers is induced from the one on the total space.\n\nThe field `exists_coordChange` is stated as an existential statement (instead of 3 separate\nfields), since it depends on propositional information (namely `e e' ∈ pretrivializationAtlas`).\nThis makes it inconvenient to explicitly define a `coordChange` function when constructing a\n`VectorPrebundle`. -/\nstructure VectorPrebundle where\n  pretrivializationAtlas : Set (Pretrivialization F (π F E))\n  pretrivialization_linear' : ∀ e, e ∈ pretrivializationAtlas → e.IsLinear R\n  pretrivializationAt : B → Pretrivialization F (π F E)\n  mem_base_pretrivializationAt : ∀ x : B, x ∈ (pretrivializationAt x).baseSet\n  pretrivialization_mem_atlas : ∀ x : B, pretrivializationAt x ∈ pretrivializationAtlas\n  exists_coordChange : ∀ᵉ (e ∈ pretrivializationAtlas) (e' ∈ pretrivializationAtlas),\n    ∃ f : B → F →L[R] F, ContinuousOn f (e.baseSet ∩ e'.baseSet) ∧\n      ∀ᵉ (b ∈ e.baseSet ∩ e'.baseSet) (v : F), f b v = (e' ⟨b, e.symm b v⟩).2\n  totalSpaceMk_isInducing : ∀ b : B, IsInducing (pretrivializationAt b ∘ .mk b)\n\n"}
{"name":"VectorPrebundle.mk.sizeOf_spec","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝¹⁰ : NontriviallyNormedField R\ninst✝⁹ : (x : B) → AddCommMonoid (E x)\ninst✝⁸ : (x : B) → Module R (E x)\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace R F\ninst✝⁵ : TopologicalSpace B\ninst✝⁴ : (x : B) → TopologicalSpace (E x)\ninst✝³ : SizeOf R\ninst✝² : SizeOf B\ninst✝¹ : SizeOf F\ninst✝ : (a : B) → SizeOf (E a)\npretrivializationAtlas : Set (Pretrivialization F Bundle.TotalSpace.proj)\npretrivialization_linear' : ∀ (e : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas e → Pretrivialization.IsLinear R e\npretrivializationAt : B → Pretrivialization F Bundle.TotalSpace.proj\nmem_base_pretrivializationAt : ∀ (x : B), Membership.mem (pretrivializationAt x).baseSet x\npretrivialization_mem_atlas : ∀ (x : B), Membership.mem pretrivializationAtlas (pretrivializationAt x)\nexists_coordChange : ∀ (e : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas e → ∀ (e' : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas e' → Exists fun f => And (ContinuousOn f (Inter.inter e.baseSet e'.baseSet)) (∀ (b : B), Membership.mem (Inter.inter e.baseSet e'.baseSet) b → ∀ (v : F), Eq ((f b) v) (↑e' { proj := b, snd := e.symm b v }).2)\ntotalSpaceMk_isInducing : ∀ (b : B), Topology.IsInducing (Function.comp (↑(pretrivializationAt b)) (Bundle.TotalSpace.mk b))\n⊢ Eq (SizeOf.sizeOf { pretrivializationAtlas := pretrivializationAtlas, pretrivialization_linear' := pretrivialization_linear', pretrivializationAt := pretrivializationAt, mem_base_pretrivializationAt := mem_base_pretrivializationAt, pretrivialization_mem_atlas := pretrivialization_mem_atlas, exists_coordChange := exists_coordChange, totalSpaceMk_isInducing := totalSpaceMk_isInducing }) 1","decl":"/-- This structure permits to define a vector bundle when trivializations are given as local\nequivalences but there is not yet a topology on the total space or the fibers.\nThe total space is hence given a topology in such a way that there is a fiber bundle structure for\nwhich the partial equivalences are also partial homeomorphisms and hence vector bundle\ntrivializations. The topology on the fibers is induced from the one on the total space.\n\nThe field `exists_coordChange` is stated as an existential statement (instead of 3 separate\nfields), since it depends on propositional information (namely `e e' ∈ pretrivializationAtlas`).\nThis makes it inconvenient to explicitly define a `coordChange` function when constructing a\n`VectorPrebundle`. -/\nstructure VectorPrebundle where\n  pretrivializationAtlas : Set (Pretrivialization F (π F E))\n  pretrivialization_linear' : ∀ e, e ∈ pretrivializationAtlas → e.IsLinear R\n  pretrivializationAt : B → Pretrivialization F (π F E)\n  mem_base_pretrivializationAt : ∀ x : B, x ∈ (pretrivializationAt x).baseSet\n  pretrivialization_mem_atlas : ∀ x : B, pretrivializationAt x ∈ pretrivializationAtlas\n  exists_coordChange : ∀ᵉ (e ∈ pretrivializationAtlas) (e' ∈ pretrivializationAtlas),\n    ∃ f : B → F →L[R] F, ContinuousOn f (e.baseSet ∩ e'.baseSet) ∧\n      ∀ᵉ (b ∈ e.baseSet ∩ e'.baseSet) (v : F), f b v = (e' ⟨b, e.symm b v⟩).2\n  totalSpaceMk_isInducing : ∀ b : B, IsInducing (pretrivializationAt b ∘ .mk b)\n\n"}
{"name":"VectorPrebundle.pretrivialization_mem_atlas","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁶ : NontriviallyNormedField R\ninst✝⁵ : (x : B) → AddCommMonoid (E x)\ninst✝⁴ : (x : B) → Module R (E x)\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace R F\ninst✝¹ : TopologicalSpace B\ninst✝ : (x : B) → TopologicalSpace (E x)\nself : VectorPrebundle R F E\nx : B\n⊢ Membership.mem self.pretrivializationAtlas (self.pretrivializationAt x)","decl":"/-- This structure permits to define a vector bundle when trivializations are given as local\nequivalences but there is not yet a topology on the total space or the fibers.\nThe total space is hence given a topology in such a way that there is a fiber bundle structure for\nwhich the partial equivalences are also partial homeomorphisms and hence vector bundle\ntrivializations. The topology on the fibers is induced from the one on the total space.\n\nThe field `exists_coordChange` is stated as an existential statement (instead of 3 separate\nfields), since it depends on propositional information (namely `e e' ∈ pretrivializationAtlas`).\nThis makes it inconvenient to explicitly define a `coordChange` function when constructing a\n`VectorPrebundle`. -/\nstructure VectorPrebundle where\n  pretrivializationAtlas : Set (Pretrivialization F (π F E))\n  pretrivialization_linear' : ∀ e, e ∈ pretrivializationAtlas → e.IsLinear R\n  pretrivializationAt : B → Pretrivialization F (π F E)\n  mem_base_pretrivializationAt : ∀ x : B, x ∈ (pretrivializationAt x).baseSet\n  pretrivialization_mem_atlas : ∀ x : B, pretrivializationAt x ∈ pretrivializationAtlas\n  exists_coordChange : ∀ᵉ (e ∈ pretrivializationAtlas) (e' ∈ pretrivializationAtlas),\n    ∃ f : B → F →L[R] F, ContinuousOn f (e.baseSet ∩ e'.baseSet) ∧\n      ∀ᵉ (b ∈ e.baseSet ∩ e'.baseSet) (v : F), f b v = (e' ⟨b, e.symm b v⟩).2\n  totalSpaceMk_isInducing : ∀ b : B, IsInducing (pretrivializationAt b ∘ .mk b)\n\n"}
{"name":"VectorPrebundle.mem_base_pretrivializationAt","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁶ : NontriviallyNormedField R\ninst✝⁵ : (x : B) → AddCommMonoid (E x)\ninst✝⁴ : (x : B) → Module R (E x)\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace R F\ninst✝¹ : TopologicalSpace B\ninst✝ : (x : B) → TopologicalSpace (E x)\nself : VectorPrebundle R F E\nx : B\n⊢ Membership.mem (self.pretrivializationAt x).baseSet x","decl":"/-- This structure permits to define a vector bundle when trivializations are given as local\nequivalences but there is not yet a topology on the total space or the fibers.\nThe total space is hence given a topology in such a way that there is a fiber bundle structure for\nwhich the partial equivalences are also partial homeomorphisms and hence vector bundle\ntrivializations. The topology on the fibers is induced from the one on the total space.\n\nThe field `exists_coordChange` is stated as an existential statement (instead of 3 separate\nfields), since it depends on propositional information (namely `e e' ∈ pretrivializationAtlas`).\nThis makes it inconvenient to explicitly define a `coordChange` function when constructing a\n`VectorPrebundle`. -/\nstructure VectorPrebundle where\n  pretrivializationAtlas : Set (Pretrivialization F (π F E))\n  pretrivialization_linear' : ∀ e, e ∈ pretrivializationAtlas → e.IsLinear R\n  pretrivializationAt : B → Pretrivialization F (π F E)\n  mem_base_pretrivializationAt : ∀ x : B, x ∈ (pretrivializationAt x).baseSet\n  pretrivialization_mem_atlas : ∀ x : B, pretrivializationAt x ∈ pretrivializationAtlas\n  exists_coordChange : ∀ᵉ (e ∈ pretrivializationAtlas) (e' ∈ pretrivializationAtlas),\n    ∃ f : B → F →L[R] F, ContinuousOn f (e.baseSet ∩ e'.baseSet) ∧\n      ∀ᵉ (b ∈ e.baseSet ∩ e'.baseSet) (v : F), f b v = (e' ⟨b, e.symm b v⟩).2\n  totalSpaceMk_isInducing : ∀ b : B, IsInducing (pretrivializationAt b ∘ .mk b)\n\n"}
{"name":"VectorPrebundle.pretrivialization_linear'","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁶ : NontriviallyNormedField R\ninst✝⁵ : (x : B) → AddCommMonoid (E x)\ninst✝⁴ : (x : B) → Module R (E x)\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace R F\ninst✝¹ : TopologicalSpace B\ninst✝ : (x : B) → TopologicalSpace (E x)\nself : VectorPrebundle R F E\ne : Pretrivialization F Bundle.TotalSpace.proj\na✝ : Membership.mem self.pretrivializationAtlas e\n⊢ Pretrivialization.IsLinear R e","decl":"/-- This structure permits to define a vector bundle when trivializations are given as local\nequivalences but there is not yet a topology on the total space or the fibers.\nThe total space is hence given a topology in such a way that there is a fiber bundle structure for\nwhich the partial equivalences are also partial homeomorphisms and hence vector bundle\ntrivializations. The topology on the fibers is induced from the one on the total space.\n\nThe field `exists_coordChange` is stated as an existential statement (instead of 3 separate\nfields), since it depends on propositional information (namely `e e' ∈ pretrivializationAtlas`).\nThis makes it inconvenient to explicitly define a `coordChange` function when constructing a\n`VectorPrebundle`. -/\nstructure VectorPrebundle where\n  pretrivializationAtlas : Set (Pretrivialization F (π F E))\n  pretrivialization_linear' : ∀ e, e ∈ pretrivializationAtlas → e.IsLinear R\n  pretrivializationAt : B → Pretrivialization F (π F E)\n  mem_base_pretrivializationAt : ∀ x : B, x ∈ (pretrivializationAt x).baseSet\n  pretrivialization_mem_atlas : ∀ x : B, pretrivializationAt x ∈ pretrivializationAtlas\n  exists_coordChange : ∀ᵉ (e ∈ pretrivializationAtlas) (e' ∈ pretrivializationAtlas),\n    ∃ f : B → F →L[R] F, ContinuousOn f (e.baseSet ∩ e'.baseSet) ∧\n      ∀ᵉ (b ∈ e.baseSet ∩ e'.baseSet) (v : F), f b v = (e' ⟨b, e.symm b v⟩).2\n  totalSpaceMk_isInducing : ∀ b : B, IsInducing (pretrivializationAt b ∘ .mk b)\n\n"}
{"name":"VectorPrebundle.mk.inj","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁶ : NontriviallyNormedField R\ninst✝⁵ : (x : B) → AddCommMonoid (E x)\ninst✝⁴ : (x : B) → Module R (E x)\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace R F\ninst✝¹ : TopologicalSpace B\ninst✝ : (x : B) → TopologicalSpace (E x)\npretrivializationAtlas✝ : Set (Pretrivialization F Bundle.TotalSpace.proj)\npretrivialization_linear'✝ : ∀ (e : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas✝ e → Pretrivialization.IsLinear R e\npretrivializationAt✝ : B → Pretrivialization F Bundle.TotalSpace.proj\nmem_base_pretrivializationAt✝ : ∀ (x : B), Membership.mem (pretrivializationAt✝ x).baseSet x\npretrivialization_mem_atlas✝ : ∀ (x : B), Membership.mem pretrivializationAtlas✝ (pretrivializationAt✝ x)\nexists_coordChange✝ : ∀ (e : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas✝ e → ∀ (e' : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas✝ e' → Exists fun f => And (ContinuousOn f (Inter.inter e.baseSet e'.baseSet)) (∀ (b : B), Membership.mem (Inter.inter e.baseSet e'.baseSet) b → ∀ (v : F), Eq ((f b) v) (↑e' { proj := b, snd := e.symm b v }).2)\ntotalSpaceMk_isInducing✝ : ∀ (b : B), Topology.IsInducing (Function.comp (↑(pretrivializationAt✝ b)) (Bundle.TotalSpace.mk b))\npretrivializationAtlas : Set (Pretrivialization F Bundle.TotalSpace.proj)\npretrivialization_linear' : ∀ (e : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas e → Pretrivialization.IsLinear R e\npretrivializationAt : B → Pretrivialization F Bundle.TotalSpace.proj\nmem_base_pretrivializationAt : ∀ (x : B), Membership.mem (pretrivializationAt x).baseSet x\npretrivialization_mem_atlas : ∀ (x : B), Membership.mem pretrivializationAtlas (pretrivializationAt x)\nexists_coordChange : ∀ (e : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas e → ∀ (e' : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas e' → Exists fun f => And (ContinuousOn f (Inter.inter e.baseSet e'.baseSet)) (∀ (b : B), Membership.mem (Inter.inter e.baseSet e'.baseSet) b → ∀ (v : F), Eq ((f b) v) (↑e' { proj := b, snd := e.symm b v }).2)\ntotalSpaceMk_isInducing : ∀ (b : B), Topology.IsInducing (Function.comp (↑(pretrivializationAt b)) (Bundle.TotalSpace.mk b))\nx✝ : Eq { pretrivializationAtlas := pretrivializationAtlas✝, pretrivialization_linear' := pretrivialization_linear'✝, pretrivializationAt := pretrivializationAt✝, mem_base_pretrivializationAt := mem_base_pretrivializationAt✝, pretrivialization_mem_atlas := pretrivialization_mem_atlas✝, exists_coordChange := exists_coordChange✝, totalSpaceMk_isInducing := totalSpaceMk_isInducing✝ } { pretrivializationAtlas := pretrivializationAtlas, pretrivialization_linear' := pretrivialization_linear', pretrivializationAt := pretrivializationAt, mem_base_pretrivializationAt := mem_base_pretrivializationAt, pretrivialization_mem_atlas := pretrivialization_mem_atlas, exists_coordChange := exists_coordChange, totalSpaceMk_isInducing := totalSpaceMk_isInducing }\n⊢ And (Eq pretrivializationAtlas✝ pretrivializationAtlas) (Eq pretrivializationAt✝ pretrivializationAt)","decl":"/-- This structure permits to define a vector bundle when trivializations are given as local\nequivalences but there is not yet a topology on the total space or the fibers.\nThe total space is hence given a topology in such a way that there is a fiber bundle structure for\nwhich the partial equivalences are also partial homeomorphisms and hence vector bundle\ntrivializations. The topology on the fibers is induced from the one on the total space.\n\nThe field `exists_coordChange` is stated as an existential statement (instead of 3 separate\nfields), since it depends on propositional information (namely `e e' ∈ pretrivializationAtlas`).\nThis makes it inconvenient to explicitly define a `coordChange` function when constructing a\n`VectorPrebundle`. -/\nstructure VectorPrebundle where\n  pretrivializationAtlas : Set (Pretrivialization F (π F E))\n  pretrivialization_linear' : ∀ e, e ∈ pretrivializationAtlas → e.IsLinear R\n  pretrivializationAt : B → Pretrivialization F (π F E)\n  mem_base_pretrivializationAt : ∀ x : B, x ∈ (pretrivializationAt x).baseSet\n  pretrivialization_mem_atlas : ∀ x : B, pretrivializationAt x ∈ pretrivializationAtlas\n  exists_coordChange : ∀ᵉ (e ∈ pretrivializationAtlas) (e' ∈ pretrivializationAtlas),\n    ∃ f : B → F →L[R] F, ContinuousOn f (e.baseSet ∩ e'.baseSet) ∧\n      ∀ᵉ (b ∈ e.baseSet ∩ e'.baseSet) (v : F), f b v = (e' ⟨b, e.symm b v⟩).2\n  totalSpaceMk_isInducing : ∀ b : B, IsInducing (pretrivializationAt b ∘ .mk b)\n\n"}
{"name":"VectorPrebundle.exists_coordChange","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁶ : NontriviallyNormedField R\ninst✝⁵ : (x : B) → AddCommMonoid (E x)\ninst✝⁴ : (x : B) → Module R (E x)\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace R F\ninst✝¹ : TopologicalSpace B\ninst✝ : (x : B) → TopologicalSpace (E x)\nself : VectorPrebundle R F E\ne : Pretrivialization F Bundle.TotalSpace.proj\na✝¹ : Membership.mem self.pretrivializationAtlas e\ne' : Pretrivialization F Bundle.TotalSpace.proj\na✝ : Membership.mem self.pretrivializationAtlas e'\n⊢ Exists fun f => And (ContinuousOn f (Inter.inter e.baseSet e'.baseSet)) (∀ (b : B), Membership.mem (Inter.inter e.baseSet e'.baseSet) b → ∀ (v : F), Eq ((f b) v) (↑e' { proj := b, snd := e.symm b v }).2)","decl":"/-- This structure permits to define a vector bundle when trivializations are given as local\nequivalences but there is not yet a topology on the total space or the fibers.\nThe total space is hence given a topology in such a way that there is a fiber bundle structure for\nwhich the partial equivalences are also partial homeomorphisms and hence vector bundle\ntrivializations. The topology on the fibers is induced from the one on the total space.\n\nThe field `exists_coordChange` is stated as an existential statement (instead of 3 separate\nfields), since it depends on propositional information (namely `e e' ∈ pretrivializationAtlas`).\nThis makes it inconvenient to explicitly define a `coordChange` function when constructing a\n`VectorPrebundle`. -/\nstructure VectorPrebundle where\n  pretrivializationAtlas : Set (Pretrivialization F (π F E))\n  pretrivialization_linear' : ∀ e, e ∈ pretrivializationAtlas → e.IsLinear R\n  pretrivializationAt : B → Pretrivialization F (π F E)\n  mem_base_pretrivializationAt : ∀ x : B, x ∈ (pretrivializationAt x).baseSet\n  pretrivialization_mem_atlas : ∀ x : B, pretrivializationAt x ∈ pretrivializationAtlas\n  exists_coordChange : ∀ᵉ (e ∈ pretrivializationAtlas) (e' ∈ pretrivializationAtlas),\n    ∃ f : B → F →L[R] F, ContinuousOn f (e.baseSet ∩ e'.baseSet) ∧\n      ∀ᵉ (b ∈ e.baseSet ∩ e'.baseSet) (v : F), f b v = (e' ⟨b, e.symm b v⟩).2\n  totalSpaceMk_isInducing : ∀ b : B, IsInducing (pretrivializationAt b ∘ .mk b)\n\n"}
{"name":"VectorPrebundle.continuousOn_coordChange","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁶ : NontriviallyNormedField R\ninst✝⁵ : (x : B) → AddCommMonoid (E x)\ninst✝⁴ : (x : B) → Module R (E x)\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace R F\ninst✝¹ : TopologicalSpace B\ninst✝ : (x : B) → TopologicalSpace (E x)\na : VectorPrebundle R F E\ne e' : Pretrivialization F Bundle.TotalSpace.proj\nhe : Membership.mem a.pretrivializationAtlas e\nhe' : Membership.mem a.pretrivializationAtlas e'\n⊢ ContinuousOn (a.coordChange he he') (Inter.inter e.baseSet e'.baseSet)","decl":"theorem continuousOn_coordChange (a : VectorPrebundle R F E) {e e' : Pretrivialization F (π F E)}\n    (he : e ∈ a.pretrivializationAtlas) (he' : e' ∈ a.pretrivializationAtlas) :\n    ContinuousOn (a.coordChange he he') (e.baseSet ∩ e'.baseSet) :=\n  (Classical.choose_spec (a.exists_coordChange e he e' he')).1\n\n"}
{"name":"VectorPrebundle.coordChange_apply","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁶ : NontriviallyNormedField R\ninst✝⁵ : (x : B) → AddCommMonoid (E x)\ninst✝⁴ : (x : B) → Module R (E x)\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace R F\ninst✝¹ : TopologicalSpace B\ninst✝ : (x : B) → TopologicalSpace (E x)\na : VectorPrebundle R F E\ne e' : Pretrivialization F Bundle.TotalSpace.proj\nhe : Membership.mem a.pretrivializationAtlas e\nhe' : Membership.mem a.pretrivializationAtlas e'\nb : B\nhb : Membership.mem (Inter.inter e.baseSet e'.baseSet) b\nv : F\n⊢ Eq ((a.coordChange he he' b) v) (↑e' { proj := b, snd := e.symm b v }).2","decl":"theorem coordChange_apply (a : VectorPrebundle R F E) {e e' : Pretrivialization F (π F E)}\n    (he : e ∈ a.pretrivializationAtlas) (he' : e' ∈ a.pretrivializationAtlas) {b : B}\n    (hb : b ∈ e.baseSet ∩ e'.baseSet) (v : F) :\n    a.coordChange he he' b v = (e' ⟨b, e.symm b v⟩).2 :=\n  (Classical.choose_spec (a.exists_coordChange e he e' he')).2 b hb v\n\n"}
{"name":"VectorPrebundle.mk_coordChange","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁶ : NontriviallyNormedField R\ninst✝⁵ : (x : B) → AddCommMonoid (E x)\ninst✝⁴ : (x : B) → Module R (E x)\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace R F\ninst✝¹ : TopologicalSpace B\ninst✝ : (x : B) → TopologicalSpace (E x)\na : VectorPrebundle R F E\ne e' : Pretrivialization F Bundle.TotalSpace.proj\nhe : Membership.mem a.pretrivializationAtlas e\nhe' : Membership.mem a.pretrivializationAtlas e'\nb : B\nhb : Membership.mem (Inter.inter e.baseSet e'.baseSet) b\nv : F\n⊢ Eq { fst := b, snd := (a.coordChange he he' b) v } (↑e' { proj := b, snd := e.symm b v })","decl":"theorem mk_coordChange (a : VectorPrebundle R F E) {e e' : Pretrivialization F (π F E)}\n    (he : e ∈ a.pretrivializationAtlas) (he' : e' ∈ a.pretrivializationAtlas) {b : B}\n    (hb : b ∈ e.baseSet ∩ e'.baseSet) (v : F) :\n    (b, a.coordChange he he' b v) = e' ⟨b, e.symm b v⟩ := by\n  ext\n  · rw [e.mk_symm hb.1 v, e'.coe_fst', e.proj_symm_apply' hb.1]\n    rw [e.proj_symm_apply' hb.1]\n    exact hb.2\n  · exact a.coordChange_apply he he' hb v\n\n"}
{"name":"VectorPrebundle.linear_trivializationOfMemPretrivializationAtlas","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁶ : NontriviallyNormedField R\ninst✝⁵ : (x : B) → AddCommMonoid (E x)\ninst✝⁴ : (x : B) → Module R (E x)\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace R F\ninst✝¹ : TopologicalSpace B\ninst✝ : (x : B) → TopologicalSpace (E x)\na : VectorPrebundle R F E\ne : Pretrivialization F Bundle.TotalSpace.proj\nhe : Membership.mem a.pretrivializationAtlas e\n⊢ Trivialization.IsLinear R (a.trivializationOfMemPretrivializationAtlas he)","decl":"theorem linear_trivializationOfMemPretrivializationAtlas (a : VectorPrebundle R F E)\n    {e : Pretrivialization F (π F E)} (he : e ∈ a.pretrivializationAtlas) :\n    letI := a.totalSpaceTopology\n    Trivialization.IsLinear R (trivializationOfMemPretrivializationAtlas a he) :=\n  letI := a.totalSpaceTopology\n  { linear := (a.pretrivialization_linear' e he).linear }\n\n"}
{"name":"VectorPrebundle.mem_trivialization_at_source","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁶ : NontriviallyNormedField R\ninst✝⁵ : (x : B) → AddCommMonoid (E x)\ninst✝⁴ : (x : B) → Module R (E x)\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace R F\ninst✝¹ : TopologicalSpace B\ninst✝ : (x : B) → TopologicalSpace (E x)\na : VectorPrebundle R F E\nb : B\nx : E b\n⊢ Membership.mem (a.pretrivializationAt b).source { proj := b, snd := x }","decl":"theorem mem_trivialization_at_source (b : B) (x : E b) :\n    ⟨b, x⟩ ∈ (a.pretrivializationAt b).source :=\n  a.toFiberPrebundle.mem_pretrivializationAt_source b x\n\n"}
{"name":"VectorPrebundle.totalSpaceMk_preimage_source","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁶ : NontriviallyNormedField R\ninst✝⁵ : (x : B) → AddCommMonoid (E x)\ninst✝⁴ : (x : B) → Module R (E x)\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace R F\ninst✝¹ : TopologicalSpace B\ninst✝ : (x : B) → TopologicalSpace (E x)\na : VectorPrebundle R F E\nb : B\n⊢ Eq (Set.preimage (Bundle.TotalSpace.mk b) (a.pretrivializationAt b).source) Set.univ","decl":"@[simp]\ntheorem totalSpaceMk_preimage_source (b : B) :\n    .mk b ⁻¹' (a.pretrivializationAt b).source = univ :=\n  a.toFiberPrebundle.totalSpaceMk_preimage_source b\n\n"}
{"name":"VectorPrebundle.continuous_totalSpaceMk","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁶ : NontriviallyNormedField R\ninst✝⁵ : (x : B) → AddCommMonoid (E x)\ninst✝⁴ : (x : B) → Module R (E x)\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace R F\ninst✝¹ : TopologicalSpace B\ninst✝ : (x : B) → TopologicalSpace (E x)\na : VectorPrebundle R F E\nb : B\n⊢ Continuous (Bundle.TotalSpace.mk b)","decl":"@[continuity]\ntheorem continuous_totalSpaceMk (b : B) :\n    Continuous[_, a.totalSpaceTopology] (.mk b) :=\n  a.toFiberPrebundle.continuous_totalSpaceMk b\n\n"}
{"name":"VectorPrebundle.toVectorBundle","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝⁶ : NontriviallyNormedField R\ninst✝⁵ : (x : B) → AddCommMonoid (E x)\ninst✝⁴ : (x : B) → Module R (E x)\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace R F\ninst✝¹ : TopologicalSpace B\ninst✝ : (x : B) → TopologicalSpace (E x)\na : VectorPrebundle R F E\n⊢ VectorBundle R F E","decl":"/-- Make a `VectorBundle` from a `VectorPrebundle`.  Concretely this means\nthat, given a `VectorPrebundle` structure for a sigma-type `E` -- which consists of a\nnumber of \"pretrivializations\" identifying parts of `E` with product spaces `U × F` -- one\nestablishes that for the topology constructed on the sigma-type using\n`VectorPrebundle.totalSpaceTopology`, these \"pretrivializations\" are actually\n\"trivializations\" (i.e., homeomorphisms with respect to the constructed topology). -/\ntheorem toVectorBundle : @VectorBundle R _ F E _ _ _ _ _ _ a.totalSpaceTopology _ a.toFiberBundle :=\n  letI := a.totalSpaceTopology; letI := a.toFiberBundle\n  { trivialization_linear' := by\n      rintro _ ⟨e, he, rfl⟩\n      apply linear_trivializationOfMemPretrivializationAtlas\n    continuousOn_coordChange' := by\n      rintro _ _ ⟨e, he, rfl⟩ ⟨e', he', rfl⟩\n      refine (a.continuousOn_coordChange he he').congr fun b hb ↦ ?_\n      ext v\n      -- Porting note: help `rw` find instances\n      haveI h₁ := a.linear_trivializationOfMemPretrivializationAtlas he\n      haveI h₂ := a.linear_trivializationOfMemPretrivializationAtlas he'\n      rw [trivializationOfMemPretrivializationAtlas] at h₁ h₂\n      rw [a.coordChange_apply he he' hb v, ContinuousLinearEquiv.coe_coe,\n        Trivialization.coordChangeL_apply]\n      exacts [rfl, hb] }\n\n"}
{"name":"ContinuousLinearMap.inCoordinates_eq","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\nE : B → Type u_4\ninst✝¹⁹ : (x : B) → AddCommMonoid (E x)\ninst✝¹⁸ : NormedAddCommGroup F\ninst✝¹⁷ : TopologicalSpace B\ninst✝¹⁶ : (x : B) → TopologicalSpace (E x)\n𝕜₁ : Type u_5\n𝕜₂ : Type u_6\ninst✝¹⁵ : NontriviallyNormedField 𝕜₁\ninst✝¹⁴ : NontriviallyNormedField 𝕜₂\nσ : RingHom 𝕜₁ 𝕜₂\nB' : Type u_7\ninst✝¹³ : TopologicalSpace B'\ninst✝¹² : NormedSpace 𝕜₁ F\ninst✝¹¹ : (x : B) → Module 𝕜₁ (E x)\ninst✝¹⁰ : TopologicalSpace (Bundle.TotalSpace F E)\nF' : Type u_8\ninst✝⁹ : NormedAddCommGroup F'\ninst✝⁸ : NormedSpace 𝕜₂ F'\nE' : B' → Type u_9\ninst✝⁷ : (x : B') → AddCommMonoid (E' x)\ninst✝⁶ : (x : B') → Module 𝕜₂ (E' x)\ninst✝⁵ : TopologicalSpace (Bundle.TotalSpace F' E')\ninst✝⁴ : FiberBundle F E\ninst✝³ : VectorBundle 𝕜₁ F E\ninst✝² : (x : B') → TopologicalSpace (E' x)\ninst✝¹ : FiberBundle F' E'\ninst✝ : VectorBundle 𝕜₂ F' E'\nx₀ x : B\ny₀ y : B'\nϕ : ContinuousLinearMap σ (E x) (E' y)\nhx : Membership.mem (FiberBundle.trivializationAt F E x₀).baseSet x\nhy : Membership.mem (FiberBundle.trivializationAt F' E' y₀).baseSet y\n⊢ Eq (ContinuousLinearMap.inCoordinates F E F' E' x₀ x y₀ y ϕ) ((↑(Trivialization.continuousLinearEquivAt 𝕜₂ (FiberBundle.trivializationAt F' E' y₀) y hy)).comp (ϕ.comp ↑(Trivialization.continuousLinearEquivAt 𝕜₁ (FiberBundle.trivializationAt F E x₀) x hx).symm))","decl":"/-- Rewrite `ContinuousLinearMap.inCoordinates` using continuous linear equivalences. -/\ntheorem inCoordinates_eq {x₀ x : B} {y₀ y : B'} {ϕ : E x →SL[σ] E' y}\n    (hx : x ∈ (trivializationAt F E x₀).baseSet) (hy : y ∈ (trivializationAt F' E' y₀).baseSet) :\n    inCoordinates F E F' E' x₀ x y₀ y ϕ =\n      ((trivializationAt F' E' y₀).continuousLinearEquivAt 𝕜₂ y hy : E' y →L[𝕜₂] F').comp\n        (ϕ.comp <|\n          (((trivializationAt F E x₀).continuousLinearEquivAt 𝕜₁ x hx).symm : F →L[𝕜₁] E x)) := by\n  ext\n  simp_rw [inCoordinates, ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe,\n    Trivialization.coe_continuousLinearEquivAt_eq, Trivialization.symm_continuousLinearEquivAt_eq]\n\n"}
{"name":"VectorBundleCore.inCoordinates_eq","module":"Mathlib.Topology.VectorBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : TopologicalSpace B\n𝕜₁ : Type u_5\n𝕜₂ : Type u_6\ninst✝⁵ : NontriviallyNormedField 𝕜₁\ninst✝⁴ : NontriviallyNormedField 𝕜₂\nσ : RingHom 𝕜₁ 𝕜₂\nB' : Type u_7\ninst✝³ : TopologicalSpace B'\ninst✝² : NormedSpace 𝕜₁ F\nF' : Type u_8\ninst✝¹ : NormedAddCommGroup F'\ninst✝ : NormedSpace 𝕜₂ F'\nι : Type u_10\nι' : Type u_11\nZ : VectorBundleCore 𝕜₁ B F ι\nZ' : VectorBundleCore 𝕜₂ B' F' ι'\nx₀ x : B\ny₀ y : B'\nϕ : ContinuousLinearMap σ F F'\nhx : Membership.mem (Z.baseSet (Z.indexAt x₀)) x\nhy : Membership.mem (Z'.baseSet (Z'.indexAt y₀)) y\n⊢ Eq (ContinuousLinearMap.inCoordinates F Z.Fiber F' Z'.Fiber x₀ x y₀ y ϕ) ((Z'.coordChange (Z'.indexAt y) (Z'.indexAt y₀) y).comp (ϕ.comp (Z.coordChange (Z.indexAt x₀) (Z.indexAt x) x)))","decl":"/-- Rewrite `ContinuousLinearMap.inCoordinates` in a `VectorBundleCore`. -/\nprotected theorem _root_.VectorBundleCore.inCoordinates_eq {ι ι'} (Z : VectorBundleCore 𝕜₁ B F ι)\n    (Z' : VectorBundleCore 𝕜₂ B' F' ι') {x₀ x : B} {y₀ y : B'} (ϕ : F →SL[σ] F')\n    (hx : x ∈ Z.baseSet (Z.indexAt x₀)) (hy : y ∈ Z'.baseSet (Z'.indexAt y₀)) :\n    inCoordinates F Z.Fiber F' Z'.Fiber x₀ x y₀ y ϕ =\n      (Z'.coordChange (Z'.indexAt y) (Z'.indexAt y₀) y).comp\n        (ϕ.comp <| Z.coordChange (Z.indexAt x₀) (Z.indexAt x) x) := by\n  simp_rw [inCoordinates, Z'.trivializationAt_continuousLinearMapAt hy,\n    Z.trivializationAt_symmL hx]\n\n"}
