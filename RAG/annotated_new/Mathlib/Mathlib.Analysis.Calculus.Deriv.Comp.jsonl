{"name":"HasDerivAtFilter.scomp","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : ğ•œ\nL : Filter ğ•œ\nğ•œ' : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nh : ğ•œ â†’ ğ•œ'\nh' : ğ•œ'\ngâ‚ : ğ•œ' â†’ F\ngâ‚' : F\nL' : Filter ğ•œ'\nhg : HasDerivAtFilter gâ‚ gâ‚' (h x) L'\nhh : HasDerivAtFilter h h' x L\nhL : Filter.Tendsto h L L'\nâŠ¢ HasDerivAtFilter (Function.comp gâ‚ h) (HSMul.hSMul h' gâ‚') x L","decl":"theorem HasDerivAtFilter.scomp (hg : HasDerivAtFilter gâ‚ gâ‚' (h x) L')\n    (hh : HasDerivAtFilter h h' x L) (hL : Tendsto h L L') :\n    HasDerivAtFilter (gâ‚ âˆ˜ h) (h' â€¢ gâ‚') x L := by\n  simpa using ((hg.restrictScalars ğ•œ).comp x hh hL).hasDerivAtFilter\n\n"}
{"name":"HasDerivAtFilter.scomp_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : ğ•œ\nL : Filter ğ•œ\nğ•œ' : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nh : ğ•œ â†’ ğ•œ'\nh' : ğ•œ'\ngâ‚ : ğ•œ' â†’ F\ngâ‚' : F\nL' : Filter ğ•œ'\ny : ğ•œ'\nhg : HasDerivAtFilter gâ‚ gâ‚' y L'\nhh : HasDerivAtFilter h h' x L\nhy : Eq y (h x)\nhL : Filter.Tendsto h L L'\nâŠ¢ HasDerivAtFilter (Function.comp gâ‚ h) (HSMul.hSMul h' gâ‚') x L","decl":"theorem HasDerivAtFilter.scomp_of_eq (hg : HasDerivAtFilter gâ‚ gâ‚' y L')\n    (hh : HasDerivAtFilter h h' x L) (hy : y = h x) (hL : Tendsto h L L') :\n    HasDerivAtFilter (gâ‚ âˆ˜ h) (h' â€¢ gâ‚') x L := by\n  rw [hy] at hg; exact hg.scomp x hh hL\n\n"}
{"name":"HasDerivWithinAt.scomp_hasDerivAt","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : ğ•œ\nğ•œ' : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\ns' : Set ğ•œ'\nh : ğ•œ â†’ ğ•œ'\nh' : ğ•œ'\ngâ‚ : ğ•œ' â†’ F\ngâ‚' : F\nhg : HasDerivWithinAt gâ‚ gâ‚' s' (h x)\nhh : HasDerivAt h h' x\nhs : âˆ€ (x : ğ•œ), Membership.mem s' (h x)\nâŠ¢ HasDerivAt (Function.comp gâ‚ h) (HSMul.hSMul h' gâ‚') x","decl":"theorem HasDerivWithinAt.scomp_hasDerivAt (hg : HasDerivWithinAt gâ‚ gâ‚' s' (h x))\n    (hh : HasDerivAt h h' x) (hs : âˆ€ x, h x âˆˆ s') : HasDerivAt (gâ‚ âˆ˜ h) (h' â€¢ gâ‚') x :=\n  hg.scomp x hh <| tendsto_inf.2 âŸ¨hh.continuousAt, tendsto_principal.2 <| Eventually.of_forall hsâŸ©\n\n"}
{"name":"HasDerivWithinAt.scomp_hasDerivAt_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : ğ•œ\nğ•œ' : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\ns' : Set ğ•œ'\nh : ğ•œ â†’ ğ•œ'\nh' : ğ•œ'\ngâ‚ : ğ•œ' â†’ F\ngâ‚' : F\ny : ğ•œ'\nhg : HasDerivWithinAt gâ‚ gâ‚' s' y\nhh : HasDerivAt h h' x\nhs : âˆ€ (x : ğ•œ), Membership.mem s' (h x)\nhy : Eq y (h x)\nâŠ¢ HasDerivAt (Function.comp gâ‚ h) (HSMul.hSMul h' gâ‚') x","decl":"theorem HasDerivWithinAt.scomp_hasDerivAt_of_eq (hg : HasDerivWithinAt gâ‚ gâ‚' s' y)\n    (hh : HasDerivAt h h' x) (hs : âˆ€ x, h x âˆˆ s') (hy : y = h x) :\n    HasDerivAt (gâ‚ âˆ˜ h) (h' â€¢ gâ‚') x := by\n  rw [hy] at hg; exact hg.scomp_hasDerivAt x hh hs\n\n"}
{"name":"HasDerivWithinAt.scomp","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nt' : Set ğ•œ'\nh : ğ•œ â†’ ğ•œ'\nh' : ğ•œ'\ngâ‚ : ğ•œ' â†’ F\ngâ‚' : F\nhg : HasDerivWithinAt gâ‚ gâ‚' t' (h x)\nhh : HasDerivWithinAt h h' s x\nhst : Set.MapsTo h s t'\nâŠ¢ HasDerivWithinAt (Function.comp gâ‚ h) (HSMul.hSMul h' gâ‚') s x","decl":"nonrec theorem HasDerivWithinAt.scomp (hg : HasDerivWithinAt gâ‚ gâ‚' t' (h x))\n    (hh : HasDerivWithinAt h h' s x) (hst : MapsTo h s t') :\n    HasDerivWithinAt (gâ‚ âˆ˜ h) (h' â€¢ gâ‚') s x :=\n  hg.scomp x hh <| hh.continuousWithinAt.tendsto_nhdsWithin hst\n\n"}
{"name":"HasDerivWithinAt.scomp_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nt' : Set ğ•œ'\nh : ğ•œ â†’ ğ•œ'\nh' : ğ•œ'\ngâ‚ : ğ•œ' â†’ F\ngâ‚' : F\ny : ğ•œ'\nhg : HasDerivWithinAt gâ‚ gâ‚' t' y\nhh : HasDerivWithinAt h h' s x\nhst : Set.MapsTo h s t'\nhy : Eq y (h x)\nâŠ¢ HasDerivWithinAt (Function.comp gâ‚ h) (HSMul.hSMul h' gâ‚') s x","decl":"theorem HasDerivWithinAt.scomp_of_eq (hg : HasDerivWithinAt gâ‚ gâ‚' t' y)\n    (hh : HasDerivWithinAt h h' s x) (hst : MapsTo h s t') (hy : y = h x) :\n    HasDerivWithinAt (gâ‚ âˆ˜ h) (h' â€¢ gâ‚') s x := by\n  rw [hy] at hg; exact hg.scomp x hh hst\n\n"}
{"name":"HasDerivAt.scomp","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : ğ•œ\nğ•œ' : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nh : ğ•œ â†’ ğ•œ'\nh' : ğ•œ'\ngâ‚ : ğ•œ' â†’ F\ngâ‚' : F\nhg : HasDerivAt gâ‚ gâ‚' (h x)\nhh : HasDerivAt h h' x\nâŠ¢ HasDerivAt (Function.comp gâ‚ h) (HSMul.hSMul h' gâ‚') x","decl":"/-- The chain rule. -/\nnonrec theorem HasDerivAt.scomp (hg : HasDerivAt gâ‚ gâ‚' (h x)) (hh : HasDerivAt h h' x) :\n    HasDerivAt (gâ‚ âˆ˜ h) (h' â€¢ gâ‚') x :=\n  hg.scomp x hh hh.continuousAt\n\n"}
{"name":"HasDerivAt.scomp_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : ğ•œ\nğ•œ' : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nh : ğ•œ â†’ ğ•œ'\nh' : ğ•œ'\ngâ‚ : ğ•œ' â†’ F\ngâ‚' : F\ny : ğ•œ'\nhg : HasDerivAt gâ‚ gâ‚' y\nhh : HasDerivAt h h' x\nhy : Eq y (h x)\nâŠ¢ HasDerivAt (Function.comp gâ‚ h) (HSMul.hSMul h' gâ‚') x","decl":"/-- The chain rule. -/\ntheorem HasDerivAt.scomp_of_eq\n    (hg : HasDerivAt gâ‚ gâ‚' y) (hh : HasDerivAt h h' x) (hy : y = h x) :\n    HasDerivAt (gâ‚ âˆ˜ h) (h' â€¢ gâ‚') x := by\n  rw [hy] at hg; exact hg.scomp x hh\n\n"}
{"name":"HasStrictDerivAt.scomp","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : ğ•œ\nğ•œ' : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nh : ğ•œ â†’ ğ•œ'\nh' : ğ•œ'\ngâ‚ : ğ•œ' â†’ F\ngâ‚' : F\nhg : HasStrictDerivAt gâ‚ gâ‚' (h x)\nhh : HasStrictDerivAt h h' x\nâŠ¢ HasStrictDerivAt (Function.comp gâ‚ h) (HSMul.hSMul h' gâ‚') x","decl":"theorem HasStrictDerivAt.scomp (hg : HasStrictDerivAt gâ‚ gâ‚' (h x)) (hh : HasStrictDerivAt h h' x) :\n    HasStrictDerivAt (gâ‚ âˆ˜ h) (h' â€¢ gâ‚') x := by\n  simpa using ((hg.restrictScalars ğ•œ).comp x hh).hasStrictDerivAt\n\n"}
{"name":"HasStrictDerivAt.scomp_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : ğ•œ\nğ•œ' : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nh : ğ•œ â†’ ğ•œ'\nh' : ğ•œ'\ngâ‚ : ğ•œ' â†’ F\ngâ‚' : F\ny : ğ•œ'\nhg : HasStrictDerivAt gâ‚ gâ‚' y\nhh : HasStrictDerivAt h h' x\nhy : Eq y (h x)\nâŠ¢ HasStrictDerivAt (Function.comp gâ‚ h) (HSMul.hSMul h' gâ‚') x","decl":"theorem HasStrictDerivAt.scomp_of_eq\n    (hg : HasStrictDerivAt gâ‚ gâ‚' y) (hh : HasStrictDerivAt h h' x) (hy : y = h x) :\n    HasStrictDerivAt (gâ‚ âˆ˜ h) (h' â€¢ gâ‚') x := by\n  rw [hy] at hg; exact hg.scomp x hh\n\n"}
{"name":"HasDerivAt.scomp_hasDerivWithinAt","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nh : ğ•œ â†’ ğ•œ'\nh' : ğ•œ'\ngâ‚ : ğ•œ' â†’ F\ngâ‚' : F\nhg : HasDerivAt gâ‚ gâ‚' (h x)\nhh : HasDerivWithinAt h h' s x\nâŠ¢ HasDerivWithinAt (Function.comp gâ‚ h) (HSMul.hSMul h' gâ‚') s x","decl":"theorem HasDerivAt.scomp_hasDerivWithinAt (hg : HasDerivAt gâ‚ gâ‚' (h x))\n    (hh : HasDerivWithinAt h h' s x) : HasDerivWithinAt (gâ‚ âˆ˜ h) (h' â€¢ gâ‚') s x :=\n  HasDerivWithinAt.scomp x hg.hasDerivWithinAt hh (mapsTo_univ _ _)\n\n"}
{"name":"HasDerivAt.scomp_hasDerivWithinAt_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nh : ğ•œ â†’ ğ•œ'\nh' : ğ•œ'\ngâ‚ : ğ•œ' â†’ F\ngâ‚' : F\ny : ğ•œ'\nhg : HasDerivAt gâ‚ gâ‚' y\nhh : HasDerivWithinAt h h' s x\nhy : Eq y (h x)\nâŠ¢ HasDerivWithinAt (Function.comp gâ‚ h) (HSMul.hSMul h' gâ‚') s x","decl":"theorem HasDerivAt.scomp_hasDerivWithinAt_of_eq (hg : HasDerivAt gâ‚ gâ‚' y)\n    (hh : HasDerivWithinAt h h' s x) (hy : y = h x) :\n    HasDerivWithinAt (gâ‚ âˆ˜ h) (h' â€¢ gâ‚') s x := by\n  rw [hy] at hg; exact hg.scomp_hasDerivWithinAt x hh\n\n"}
{"name":"derivWithin.scomp","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nt' : Set ğ•œ'\nh : ğ•œ â†’ ğ•œ'\ngâ‚ : ğ•œ' â†’ F\nhg : DifferentiableWithinAt ğ•œ' gâ‚ t' (h x)\nhh : DifferentiableWithinAt ğ•œ h s x\nhs : Set.MapsTo h s t'\nâŠ¢ Eq (derivWithin (Function.comp gâ‚ h) s x) (HSMul.hSMul (derivWithin h s x) (derivWithin gâ‚ t' (h x)))","decl":"theorem derivWithin.scomp (hg : DifferentiableWithinAt ğ•œ' gâ‚ t' (h x))\n    (hh : DifferentiableWithinAt ğ•œ h s x) (hs : MapsTo h s t') :\n    derivWithin (gâ‚ âˆ˜ h) s x = derivWithin h s x â€¢ derivWithin gâ‚ t' (h x) := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  Â· exact (HasDerivWithinAt.scomp x hg.hasDerivWithinAt hh.hasDerivWithinAt hs).derivWithin hxs\n  Â· simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"derivWithin.scomp_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nt' : Set ğ•œ'\nh : ğ•œ â†’ ğ•œ'\ngâ‚ : ğ•œ' â†’ F\ny : ğ•œ'\nhg : DifferentiableWithinAt ğ•œ' gâ‚ t' y\nhh : DifferentiableWithinAt ğ•œ h s x\nhs : Set.MapsTo h s t'\nhy : Eq y (h x)\nâŠ¢ Eq (derivWithin (Function.comp gâ‚ h) s x) (HSMul.hSMul (derivWithin h s x) (derivWithin gâ‚ t' (h x)))","decl":"theorem derivWithin.scomp_of_eq (hg : DifferentiableWithinAt ğ•œ' gâ‚ t' y)\n    (hh : DifferentiableWithinAt ğ•œ h s x) (hs : MapsTo h s t')\n    (hy : y = h x) :\n    derivWithin (gâ‚ âˆ˜ h) s x = derivWithin h s x â€¢ derivWithin gâ‚ t' (h x) := by\n  rw [hy] at hg; exact derivWithin.scomp x hg hh hs\n\n"}
{"name":"deriv.scomp","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : ğ•œ\nğ•œ' : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nh : ğ•œ â†’ ğ•œ'\ngâ‚ : ğ•œ' â†’ F\nhg : DifferentiableAt ğ•œ' gâ‚ (h x)\nhh : DifferentiableAt ğ•œ h x\nâŠ¢ Eq (deriv (Function.comp gâ‚ h) x) (HSMul.hSMul (deriv h x) (deriv gâ‚ (h x)))","decl":"theorem deriv.scomp (hg : DifferentiableAt ğ•œ' gâ‚ (h x)) (hh : DifferentiableAt ğ•œ h x) :\n    deriv (gâ‚ âˆ˜ h) x = deriv h x â€¢ deriv gâ‚ (h x) :=\n  (HasDerivAt.scomp x hg.hasDerivAt hh.hasDerivAt).deriv\n\n"}
{"name":"deriv.scomp_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : ğ•œ\nğ•œ' : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nh : ğ•œ â†’ ğ•œ'\ngâ‚ : ğ•œ' â†’ F\ny : ğ•œ'\nhg : DifferentiableAt ğ•œ' gâ‚ y\nhh : DifferentiableAt ğ•œ h x\nhy : Eq y (h x)\nâŠ¢ Eq (deriv (Function.comp gâ‚ h) x) (HSMul.hSMul (deriv h x) (deriv gâ‚ (h x)))","decl":"theorem deriv.scomp_of_eq\n    (hg : DifferentiableAt ğ•œ' gâ‚ y) (hh : DifferentiableAt ğ•œ h x) (hy : y = h x) :\n    deriv (gâ‚ âˆ˜ h) x = deriv h x â€¢ deriv gâ‚ (h x) := by\n  rw [hy] at hg; exact deriv.scomp x hg hh\n\n"}
{"name":"HasDerivAtFilter.comp_hasFDerivAtFilter","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\nhâ‚‚' : ğ•œ'\nL' : Filter ğ•œ'\nf : E â†’ ğ•œ'\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ•œ'\nx : E\nL'' : Filter E\nhhâ‚‚ : HasDerivAtFilter hâ‚‚ hâ‚‚' (f x) L'\nhf : HasFDerivAtFilter f f' x L''\nhL : Filter.Tendsto f L'' L'\nâŠ¢ HasFDerivAtFilter (Function.comp hâ‚‚ f) (HSMul.hSMul hâ‚‚' f') x L''","decl":"theorem HasDerivAtFilter.comp_hasFDerivAtFilter {f : E â†’ ğ•œ'} {f' : E â†’L[ğ•œ] ğ•œ'} (x) {L'' : Filter E}\n    (hhâ‚‚ : HasDerivAtFilter hâ‚‚ hâ‚‚' (f x) L') (hf : HasFDerivAtFilter f f' x L'')\n    (hL : Tendsto f L'' L') : HasFDerivAtFilter (hâ‚‚ âˆ˜ f) (hâ‚‚' â€¢ f') x L'' := by\n  convert (hhâ‚‚.restrictScalars ğ•œ).comp x hf hL\n  ext x\n  simp [mul_comm]\n\n"}
{"name":"HasDerivAtFilter.comp_hasFDerivAtFilter_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\nhâ‚‚' : ğ•œ'\nL' : Filter ğ•œ'\ny : ğ•œ'\nf : E â†’ ğ•œ'\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ•œ'\nx : E\nL'' : Filter E\nhhâ‚‚ : HasDerivAtFilter hâ‚‚ hâ‚‚' y L'\nhf : HasFDerivAtFilter f f' x L''\nhL : Filter.Tendsto f L'' L'\nhy : Eq y (f x)\nâŠ¢ HasFDerivAtFilter (Function.comp hâ‚‚ f) (HSMul.hSMul hâ‚‚' f') x L''","decl":"theorem HasDerivAtFilter.comp_hasFDerivAtFilter_of_eq\n    {f : E â†’ ğ•œ'} {f' : E â†’L[ğ•œ] ğ•œ'} (x) {L'' : Filter E}\n    (hhâ‚‚ : HasDerivAtFilter hâ‚‚ hâ‚‚' y L') (hf : HasFDerivAtFilter f f' x L'')\n    (hL : Tendsto f L'' L') (hy : y = f x) : HasFDerivAtFilter (hâ‚‚ âˆ˜ f) (hâ‚‚' â€¢ f') x L'' := by\n  rw [hy] at hhâ‚‚; exact hhâ‚‚.comp_hasFDerivAtFilter x hf hL\n\n"}
{"name":"HasStrictDerivAt.comp_hasStrictFDerivAt","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\nhâ‚‚' : ğ•œ'\nf : E â†’ ğ•œ'\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ•œ'\nx : E\nhh : HasStrictDerivAt hâ‚‚ hâ‚‚' (f x)\nhf : HasStrictFDerivAt f f' x\nâŠ¢ HasStrictFDerivAt (Function.comp hâ‚‚ f) (HSMul.hSMul hâ‚‚' f') x","decl":"theorem HasStrictDerivAt.comp_hasStrictFDerivAt {f : E â†’ ğ•œ'} {f' : E â†’L[ğ•œ] ğ•œ'} (x)\n    (hh : HasStrictDerivAt hâ‚‚ hâ‚‚' (f x)) (hf : HasStrictFDerivAt f f' x) :\n    HasStrictFDerivAt (hâ‚‚ âˆ˜ f) (hâ‚‚' â€¢ f') x := by\n  rw [HasStrictDerivAt] at hh\n  convert (hh.restrictScalars ğ•œ).comp x hf\n  ext x\n  simp [mul_comm]\n\n"}
{"name":"HasStrictDerivAt.comp_hasStrictFDerivAt_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\nhâ‚‚' y : ğ•œ'\nf : E â†’ ğ•œ'\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ•œ'\nx : E\nhh : HasStrictDerivAt hâ‚‚ hâ‚‚' y\nhf : HasStrictFDerivAt f f' x\nhy : Eq y (f x)\nâŠ¢ HasStrictFDerivAt (Function.comp hâ‚‚ f) (HSMul.hSMul hâ‚‚' f') x","decl":"theorem HasStrictDerivAt.comp_hasStrictFDerivAt_of_eq {f : E â†’ ğ•œ'} {f' : E â†’L[ğ•œ] ğ•œ'} (x)\n    (hh : HasStrictDerivAt hâ‚‚ hâ‚‚' y) (hf : HasStrictFDerivAt f f' x) (hy : y = f x) :\n    HasStrictFDerivAt (hâ‚‚ âˆ˜ f) (hâ‚‚' â€¢ f') x := by\n  rw [hy] at hh; exact hh.comp_hasStrictFDerivAt x hf\n\n"}
{"name":"HasDerivAt.comp_hasFDerivAt","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\nhâ‚‚' : ğ•œ'\nf : E â†’ ğ•œ'\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ•œ'\nx : E\nhh : HasDerivAt hâ‚‚ hâ‚‚' (f x)\nhf : HasFDerivAt f f' x\nâŠ¢ HasFDerivAt (Function.comp hâ‚‚ f) (HSMul.hSMul hâ‚‚' f') x","decl":"theorem HasDerivAt.comp_hasFDerivAt {f : E â†’ ğ•œ'} {f' : E â†’L[ğ•œ] ğ•œ'} (x)\n    (hh : HasDerivAt hâ‚‚ hâ‚‚' (f x)) (hf : HasFDerivAt f f' x) : HasFDerivAt (hâ‚‚ âˆ˜ f) (hâ‚‚' â€¢ f') x :=\n  hh.comp_hasFDerivAtFilter x hf hf.continuousAt\n\n"}
{"name":"HasDerivAt.comp_hasFDerivAt_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\nhâ‚‚' y : ğ•œ'\nf : E â†’ ğ•œ'\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ•œ'\nx : E\nhh : HasDerivAt hâ‚‚ hâ‚‚' y\nhf : HasFDerivAt f f' x\nhy : Eq y (f x)\nâŠ¢ HasFDerivAt (Function.comp hâ‚‚ f) (HSMul.hSMul hâ‚‚' f') x","decl":"theorem HasDerivAt.comp_hasFDerivAt_of_eq {f : E â†’ ğ•œ'} {f' : E â†’L[ğ•œ] ğ•œ'} (x)\n    (hh : HasDerivAt hâ‚‚ hâ‚‚' y) (hf : HasFDerivAt f f' x) (hy : y = f x) :\n    HasFDerivAt (hâ‚‚ âˆ˜ f) (hâ‚‚' â€¢ f') x := by\n  rw [hy] at hh; exact hh.comp_hasFDerivAt x hf\n\n"}
{"name":"HasDerivAt.comp_hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\nhâ‚‚' : ğ•œ'\nf : E â†’ ğ•œ'\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ•œ'\ns : Set E\nx : E\nhh : HasDerivAt hâ‚‚ hâ‚‚' (f x)\nhf : HasFDerivWithinAt f f' s x\nâŠ¢ HasFDerivWithinAt (Function.comp hâ‚‚ f) (HSMul.hSMul hâ‚‚' f') s x","decl":"theorem HasDerivAt.comp_hasFDerivWithinAt {f : E â†’ ğ•œ'} {f' : E â†’L[ğ•œ] ğ•œ'} {s} (x)\n    (hh : HasDerivAt hâ‚‚ hâ‚‚' (f x)) (hf : HasFDerivWithinAt f f' s x) :\n    HasFDerivWithinAt (hâ‚‚ âˆ˜ f) (hâ‚‚' â€¢ f') s x :=\n  hh.comp_hasFDerivAtFilter x hf hf.continuousWithinAt\n\n"}
{"name":"HasDerivAt.comp_hasFDerivWithinAt_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\nhâ‚‚' y : ğ•œ'\nf : E â†’ ğ•œ'\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ•œ'\ns : Set E\nx : E\nhh : HasDerivAt hâ‚‚ hâ‚‚' y\nhf : HasFDerivWithinAt f f' s x\nhy : Eq y (f x)\nâŠ¢ HasFDerivWithinAt (Function.comp hâ‚‚ f) (HSMul.hSMul hâ‚‚' f') s x","decl":"theorem HasDerivAt.comp_hasFDerivWithinAt_of_eq {f : E â†’ ğ•œ'} {f' : E â†’L[ğ•œ] ğ•œ'} {s} (x)\n    (hh : HasDerivAt hâ‚‚ hâ‚‚' y) (hf : HasFDerivWithinAt f f' s x) (hy : y = f x) :\n    HasFDerivWithinAt (hâ‚‚ âˆ˜ f) (hâ‚‚' â€¢ f') s x := by\n  rw [hy] at hh; exact hh.comp_hasFDerivWithinAt x hf\n\n"}
{"name":"HasDerivWithinAt.comp_hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\nhâ‚‚' : ğ•œ'\nf : E â†’ ğ•œ'\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ•œ'\ns : Set E\nt : Set ğ•œ'\nx : E\nhh : HasDerivWithinAt hâ‚‚ hâ‚‚' t (f x)\nhf : HasFDerivWithinAt f f' s x\nhst : Set.MapsTo f s t\nâŠ¢ HasFDerivWithinAt (Function.comp hâ‚‚ f) (HSMul.hSMul hâ‚‚' f') s x","decl":"theorem HasDerivWithinAt.comp_hasFDerivWithinAt {f : E â†’ ğ•œ'} {f' : E â†’L[ğ•œ] ğ•œ'} {s t} (x)\n    (hh : HasDerivWithinAt hâ‚‚ hâ‚‚' t (f x)) (hf : HasFDerivWithinAt f f' s x) (hst : MapsTo f s t) :\n    HasFDerivWithinAt (hâ‚‚ âˆ˜ f) (hâ‚‚' â€¢ f') s x :=\n  hh.comp_hasFDerivAtFilter x hf <| hf.continuousWithinAt.tendsto_nhdsWithin hst\n\n"}
{"name":"HasDerivWithinAt.comp_hasFDerivWithinAt_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\nhâ‚‚' y : ğ•œ'\nf : E â†’ ğ•œ'\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ•œ'\ns : Set E\nt : Set ğ•œ'\nx : E\nhh : HasDerivWithinAt hâ‚‚ hâ‚‚' t y\nhf : HasFDerivWithinAt f f' s x\nhst : Set.MapsTo f s t\nhy : Eq y (f x)\nâŠ¢ HasFDerivWithinAt (Function.comp hâ‚‚ f) (HSMul.hSMul hâ‚‚' f') s x","decl":"theorem HasDerivWithinAt.comp_hasFDerivWithinAt_of_eq {f : E â†’ ğ•œ'} {f' : E â†’L[ğ•œ] ğ•œ'} {s t} (x)\n    (hh : HasDerivWithinAt hâ‚‚ hâ‚‚' t y) (hf : HasFDerivWithinAt f f' s x) (hst : MapsTo f s t)\n    (hy : y = f x) :\n    HasFDerivWithinAt (hâ‚‚ âˆ˜ f) (hâ‚‚' â€¢ f') s x := by\n  rw [hy] at hh; exact hh.comp_hasFDerivWithinAt x hf hst\n\n"}
{"name":"HasDerivAtFilter.comp","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nL : Filter ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nh : ğ•œ â†’ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\nh' hâ‚‚' : ğ•œ'\nL' : Filter ğ•œ'\nhhâ‚‚ : HasDerivAtFilter hâ‚‚ hâ‚‚' (h x) L'\nhh : HasDerivAtFilter h h' x L\nhL : Filter.Tendsto h L L'\nâŠ¢ HasDerivAtFilter (Function.comp hâ‚‚ h) (HMul.hMul hâ‚‚' h') x L","decl":"theorem HasDerivAtFilter.comp (hhâ‚‚ : HasDerivAtFilter hâ‚‚ hâ‚‚' (h x) L')\n    (hh : HasDerivAtFilter h h' x L) (hL : Tendsto h L L') :\n    HasDerivAtFilter (hâ‚‚ âˆ˜ h) (hâ‚‚' * h') x L := by\n  rw [mul_comm]\n  exact hhâ‚‚.scomp x hh hL\n\n"}
{"name":"HasDerivAtFilter.comp_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nL : Filter ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nh : ğ•œ â†’ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\nh' hâ‚‚' : ğ•œ'\nL' : Filter ğ•œ'\ny : ğ•œ'\nhhâ‚‚ : HasDerivAtFilter hâ‚‚ hâ‚‚' y L'\nhh : HasDerivAtFilter h h' x L\nhL : Filter.Tendsto h L L'\nhy : Eq y (h x)\nâŠ¢ HasDerivAtFilter (Function.comp hâ‚‚ h) (HMul.hMul hâ‚‚' h') x L","decl":"theorem HasDerivAtFilter.comp_of_eq (hhâ‚‚ : HasDerivAtFilter hâ‚‚ hâ‚‚' y L')\n    (hh : HasDerivAtFilter h h' x L) (hL : Tendsto h L L') (hy : y = h x) :\n    HasDerivAtFilter (hâ‚‚ âˆ˜ h) (hâ‚‚' * h') x L := by\n  rw [hy] at hhâ‚‚; exact hhâ‚‚.comp x hh hL\n\n"}
{"name":"HasDerivWithinAt.comp","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\ns' : Set ğ•œ'\nh : ğ•œ â†’ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\nh' hâ‚‚' : ğ•œ'\nhhâ‚‚ : HasDerivWithinAt hâ‚‚ hâ‚‚' s' (h x)\nhh : HasDerivWithinAt h h' s x\nhst : Set.MapsTo h s s'\nâŠ¢ HasDerivWithinAt (Function.comp hâ‚‚ h) (HMul.hMul hâ‚‚' h') s x","decl":"theorem HasDerivWithinAt.comp (hhâ‚‚ : HasDerivWithinAt hâ‚‚ hâ‚‚' s' (h x))\n    (hh : HasDerivWithinAt h h' s x) (hst : MapsTo h s s') :\n    HasDerivWithinAt (hâ‚‚ âˆ˜ h) (hâ‚‚' * h') s x := by\n  rw [mul_comm]\n  exact hhâ‚‚.scomp x hh hst\n\n"}
{"name":"HasDerivWithinAt.comp_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\ns' : Set ğ•œ'\nh : ğ•œ â†’ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\nh' hâ‚‚' y : ğ•œ'\nhhâ‚‚ : HasDerivWithinAt hâ‚‚ hâ‚‚' s' y\nhh : HasDerivWithinAt h h' s x\nhst : Set.MapsTo h s s'\nhy : Eq y (h x)\nâŠ¢ HasDerivWithinAt (Function.comp hâ‚‚ h) (HMul.hMul hâ‚‚' h') s x","decl":"theorem HasDerivWithinAt.comp_of_eq (hhâ‚‚ : HasDerivWithinAt hâ‚‚ hâ‚‚' s' y)\n    (hh : HasDerivWithinAt h h' s x) (hst : MapsTo h s s') (hy : y = h x) :\n    HasDerivWithinAt (hâ‚‚ âˆ˜ h) (hâ‚‚' * h') s x := by\n  rw [hy] at hhâ‚‚; exact hhâ‚‚.comp x hh hst\n\n"}
{"name":"HasDerivAt.comp","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nh : ğ•œ â†’ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\nh' hâ‚‚' : ğ•œ'\nhhâ‚‚ : HasDerivAt hâ‚‚ hâ‚‚' (h x)\nhh : HasDerivAt h h' x\nâŠ¢ HasDerivAt (Function.comp hâ‚‚ h) (HMul.hMul hâ‚‚' h') x","decl":"/-- The chain rule.\n\nNote that the function `hâ‚‚` is a function on an algebra. If you are looking for the chain rule\nwith `hâ‚‚` taking values in a vector space, use `HasDerivAt.scomp`. -/\nnonrec theorem HasDerivAt.comp (hhâ‚‚ : HasDerivAt hâ‚‚ hâ‚‚' (h x)) (hh : HasDerivAt h h' x) :\n    HasDerivAt (hâ‚‚ âˆ˜ h) (hâ‚‚' * h') x :=\n  hhâ‚‚.comp x hh hh.continuousAt\n\n"}
{"name":"HasDerivAt.comp_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nh : ğ•œ â†’ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\nh' hâ‚‚' y : ğ•œ'\nhhâ‚‚ : HasDerivAt hâ‚‚ hâ‚‚' y\nhh : HasDerivAt h h' x\nhy : Eq y (h x)\nâŠ¢ HasDerivAt (Function.comp hâ‚‚ h) (HMul.hMul hâ‚‚' h') x","decl":"/-- The chain rule.\n\nNote that the function `hâ‚‚` is a function on an algebra. If you are looking for the chain rule\nwith `hâ‚‚` taking values in a vector space, use `HasDerivAt.scomp_of_eq`. -/\ntheorem HasDerivAt.comp_of_eq\n    (hhâ‚‚ : HasDerivAt hâ‚‚ hâ‚‚' y) (hh : HasDerivAt h h' x) (hy : y = h x) :\n    HasDerivAt (hâ‚‚ âˆ˜ h) (hâ‚‚' * h') x := by\n  rw [hy] at hhâ‚‚; exact hhâ‚‚.comp x hh\n\n"}
{"name":"HasStrictDerivAt.comp","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nh : ğ•œ â†’ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\nh' hâ‚‚' : ğ•œ'\nhhâ‚‚ : HasStrictDerivAt hâ‚‚ hâ‚‚' (h x)\nhh : HasStrictDerivAt h h' x\nâŠ¢ HasStrictDerivAt (Function.comp hâ‚‚ h) (HMul.hMul hâ‚‚' h') x","decl":"theorem HasStrictDerivAt.comp (hhâ‚‚ : HasStrictDerivAt hâ‚‚ hâ‚‚' (h x)) (hh : HasStrictDerivAt h h' x) :\n    HasStrictDerivAt (hâ‚‚ âˆ˜ h) (hâ‚‚' * h') x := by\n  rw [mul_comm]\n  exact hhâ‚‚.scomp x hh\n\n"}
{"name":"HasStrictDerivAt.comp_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nh : ğ•œ â†’ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\nh' hâ‚‚' y : ğ•œ'\nhhâ‚‚ : HasStrictDerivAt hâ‚‚ hâ‚‚' y\nhh : HasStrictDerivAt h h' x\nhy : Eq y (h x)\nâŠ¢ HasStrictDerivAt (Function.comp hâ‚‚ h) (HMul.hMul hâ‚‚' h') x","decl":"theorem HasStrictDerivAt.comp_of_eq\n    (hhâ‚‚ : HasStrictDerivAt hâ‚‚ hâ‚‚' y) (hh : HasStrictDerivAt h h' x) (hy : y = h x) :\n    HasStrictDerivAt (hâ‚‚ âˆ˜ h) (hâ‚‚' * h') x := by\n  rw [hy] at hhâ‚‚; exact hhâ‚‚.comp x hh\n\n"}
{"name":"HasDerivAt.comp_hasDerivWithinAt","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nh : ğ•œ â†’ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\nh' hâ‚‚' : ğ•œ'\nhhâ‚‚ : HasDerivAt hâ‚‚ hâ‚‚' (h x)\nhh : HasDerivWithinAt h h' s x\nâŠ¢ HasDerivWithinAt (Function.comp hâ‚‚ h) (HMul.hMul hâ‚‚' h') s x","decl":"theorem HasDerivAt.comp_hasDerivWithinAt (hhâ‚‚ : HasDerivAt hâ‚‚ hâ‚‚' (h x))\n    (hh : HasDerivWithinAt h h' s x) : HasDerivWithinAt (hâ‚‚ âˆ˜ h) (hâ‚‚' * h') s x :=\n  hhâ‚‚.hasDerivWithinAt.comp x hh (mapsTo_univ _ _)\n\n"}
{"name":"HasDerivAt.comp_hasDerivWithinAt_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nh : ğ•œ â†’ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\nh' hâ‚‚' y : ğ•œ'\nhhâ‚‚ : HasDerivAt hâ‚‚ hâ‚‚' y\nhh : HasDerivWithinAt h h' s x\nhy : Eq y (h x)\nâŠ¢ HasDerivWithinAt (Function.comp hâ‚‚ h) (HMul.hMul hâ‚‚' h') s x","decl":"theorem HasDerivAt.comp_hasDerivWithinAt_of_eq (hhâ‚‚ : HasDerivAt hâ‚‚ hâ‚‚' y)\n    (hh : HasDerivWithinAt h h' s x) (hy : y = h x) :\n    HasDerivWithinAt (hâ‚‚ âˆ˜ h) (hâ‚‚' * h') s x := by\n  rw [hy] at hhâ‚‚; exact hhâ‚‚.comp_hasDerivWithinAt x hh\n\n"}
{"name":"derivWithin_comp","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\ns' : Set ğ•œ'\nh : ğ•œ â†’ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\nhhâ‚‚ : DifferentiableWithinAt ğ•œ' hâ‚‚ s' (h x)\nhh : DifferentiableWithinAt ğ•œ h s x\nhs : Set.MapsTo h s s'\nâŠ¢ Eq (derivWithin (Function.comp hâ‚‚ h) s x) (HMul.hMul (derivWithin hâ‚‚ s' (h x)) (derivWithin h s x))","decl":"theorem derivWithin_comp (hhâ‚‚ : DifferentiableWithinAt ğ•œ' hâ‚‚ s' (h x))\n    (hh : DifferentiableWithinAt ğ•œ h s x) (hs : MapsTo h s s') :\n    derivWithin (hâ‚‚ âˆ˜ h) s x = derivWithin hâ‚‚ s' (h x) * derivWithin h s x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  Â· exact (hhâ‚‚.hasDerivWithinAt.comp x hh.hasDerivWithinAt hs).derivWithin hxs\n  Â· simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"derivWithin.comp","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\ns' : Set ğ•œ'\nh : ğ•œ â†’ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\nhhâ‚‚ : DifferentiableWithinAt ğ•œ' hâ‚‚ s' (h x)\nhh : DifferentiableWithinAt ğ•œ h s x\nhs : Set.MapsTo h s s'\nâŠ¢ Eq (derivWithin (Function.comp hâ‚‚ h) s x) (HMul.hMul (derivWithin hâ‚‚ s' (h x)) (derivWithin h s x))","decl":"@[deprecated (since := \"2024-10-31\")] alias derivWithin.comp := derivWithin_comp\n\n"}
{"name":"derivWithin_comp_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\ns' : Set ğ•œ'\nh : ğ•œ â†’ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\ny : ğ•œ'\nhhâ‚‚ : DifferentiableWithinAt ğ•œ' hâ‚‚ s' y\nhh : DifferentiableWithinAt ğ•œ h s x\nhs : Set.MapsTo h s s'\nhy : Eq (h x) y\nâŠ¢ Eq (derivWithin (Function.comp hâ‚‚ h) s x) (HMul.hMul (derivWithin hâ‚‚ s' (h x)) (derivWithin h s x))","decl":"theorem derivWithin_comp_of_eq (hhâ‚‚ : DifferentiableWithinAt ğ•œ' hâ‚‚ s' y)\n    (hh : DifferentiableWithinAt ğ•œ h s x) (hs : MapsTo h s s')\n    (hy : h x = y) :\n    derivWithin (hâ‚‚ âˆ˜ h) s x = derivWithin hâ‚‚ s' (h x) * derivWithin h s x := by\n  subst hy; exact derivWithin_comp x hhâ‚‚ hh hs\n\n"}
{"name":"derivWithin.comp_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\ns' : Set ğ•œ'\nh : ğ•œ â†’ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\ny : ğ•œ'\nhhâ‚‚ : DifferentiableWithinAt ğ•œ' hâ‚‚ s' y\nhh : DifferentiableWithinAt ğ•œ h s x\nhs : Set.MapsTo h s s'\nhy : Eq (h x) y\nâŠ¢ Eq (derivWithin (Function.comp hâ‚‚ h) s x) (HMul.hMul (derivWithin hâ‚‚ s' (h x)) (derivWithin h s x))","decl":"@[deprecated (since := \"2024-10-31\")] alias derivWithin.comp_of_eq := derivWithin_comp_of_eq\n\n"}
{"name":"deriv_comp","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nh : ğ•œ â†’ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\nhhâ‚‚ : DifferentiableAt ğ•œ' hâ‚‚ (h x)\nhh : DifferentiableAt ğ•œ h x\nâŠ¢ Eq (deriv (Function.comp hâ‚‚ h) x) (HMul.hMul (deriv hâ‚‚ (h x)) (deriv h x))","decl":"theorem deriv_comp (hhâ‚‚ : DifferentiableAt ğ•œ' hâ‚‚ (h x)) (hh : DifferentiableAt ğ•œ h x) :\n    deriv (hâ‚‚ âˆ˜ h) x = deriv hâ‚‚ (h x) * deriv h x :=\n  (hhâ‚‚.hasDerivAt.comp x hh.hasDerivAt).deriv\n\n"}
{"name":"deriv.comp","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nh : ğ•œ â†’ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\nhhâ‚‚ : DifferentiableAt ğ•œ' hâ‚‚ (h x)\nhh : DifferentiableAt ğ•œ h x\nâŠ¢ Eq (deriv (Function.comp hâ‚‚ h) x) (HMul.hMul (deriv hâ‚‚ (h x)) (deriv h x))","decl":"@[deprecated (since := \"2024-10-31\")] alias deriv.comp := deriv_comp\n\n"}
{"name":"deriv_comp_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nh : ğ•œ â†’ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\ny : ğ•œ'\nhhâ‚‚ : DifferentiableAt ğ•œ' hâ‚‚ y\nhh : DifferentiableAt ğ•œ h x\nhy : Eq (h x) y\nâŠ¢ Eq (deriv (Function.comp hâ‚‚ h) x) (HMul.hMul (deriv hâ‚‚ (h x)) (deriv h x))","decl":"theorem deriv_comp_of_eq (hhâ‚‚ : DifferentiableAt ğ•œ' hâ‚‚ y) (hh : DifferentiableAt ğ•œ h x)\n    (hy : h x = y) :\n    deriv (hâ‚‚ âˆ˜ h) x = deriv hâ‚‚ (h x) * deriv h x := by\n  subst hy; exact deriv_comp x hhâ‚‚ hh\n\n"}
{"name":"deriv.comp_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nh : ğ•œ â†’ ğ•œ'\nhâ‚‚ : ğ•œ' â†’ ğ•œ'\ny : ğ•œ'\nhhâ‚‚ : DifferentiableAt ğ•œ' hâ‚‚ y\nhh : DifferentiableAt ğ•œ h x\nhy : Eq (h x) y\nâŠ¢ Eq (deriv (Function.comp hâ‚‚ h) x) (HMul.hMul (deriv hâ‚‚ (h x)) (deriv h x))","decl":"@[deprecated (since := \"2024-10-31\")] alias deriv.comp_of_eq := deriv_comp_of_eq\n\n"}
{"name":"HasDerivAtFilter.iterate","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\nL : Filter ğ•œ\nf : ğ•œ â†’ ğ•œ\nf' : ğ•œ\nhf : HasDerivAtFilter f f' x L\nhL : Filter.Tendsto f L L\nhx : Eq (f x) x\nn : Nat\nâŠ¢ HasDerivAtFilter (Nat.iterate f n) (HPow.hPow f' n) x L","decl":"protected nonrec theorem HasDerivAtFilter.iterate {f : ğ•œ â†’ ğ•œ} {f' : ğ•œ}\n    (hf : HasDerivAtFilter f f' x L) (hL : Tendsto f L L) (hx : f x = x) (n : â„•) :\n    HasDerivAtFilter f^[n] (f' ^ n) x L := by\n  have := hf.iterate hL hx n\n  rwa [ContinuousLinearMap.smulRight_one_pow] at this\n\n"}
{"name":"HasDerivAt.iterate","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\nf : ğ•œ â†’ ğ•œ\nf' : ğ•œ\nhf : HasDerivAt f f' x\nhx : Eq (f x) x\nn : Nat\nâŠ¢ HasDerivAt (Nat.iterate f n) (HPow.hPow f' n) x","decl":"protected nonrec theorem HasDerivAt.iterate {f : ğ•œ â†’ ğ•œ} {f' : ğ•œ} (hf : HasDerivAt f f' x)\n    (hx : f x = x) (n : â„•) : HasDerivAt f^[n] (f' ^ n) x :=\n  hf.iterate _ (have := hf.tendsto_nhds le_rfl; by rwa [hx] at this) hx n\n\n"}
{"name":"HasDerivWithinAt.iterate","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nf : ğ•œ â†’ ğ•œ\nf' : ğ•œ\nhf : HasDerivWithinAt f f' s x\nhx : Eq (f x) x\nhs : Set.MapsTo f s s\nn : Nat\nâŠ¢ HasDerivWithinAt (Nat.iterate f n) (HPow.hPow f' n) s x","decl":"protected theorem HasDerivWithinAt.iterate {f : ğ•œ â†’ ğ•œ} {f' : ğ•œ} (hf : HasDerivWithinAt f f' s x)\n    (hx : f x = x) (hs : MapsTo f s s) (n : â„•) : HasDerivWithinAt f^[n] (f' ^ n) s x := by\n  have := HasFDerivWithinAt.iterate hf hx hs n\n  rwa [ContinuousLinearMap.smulRight_one_pow] at this\n\n"}
{"name":"HasStrictDerivAt.iterate","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\nf : ğ•œ â†’ ğ•œ\nf' : ğ•œ\nhf : HasStrictDerivAt f f' x\nhx : Eq (f x) x\nn : Nat\nâŠ¢ HasStrictDerivAt (Nat.iterate f n) (HPow.hPow f' n) x","decl":"protected nonrec theorem HasStrictDerivAt.iterate {f : ğ•œ â†’ ğ•œ} {f' : ğ•œ}\n    (hf : HasStrictDerivAt f f' x) (hx : f x = x) (n : â„•) :\n    HasStrictDerivAt f^[n] (f' ^ n) x := by\n  have := hf.iterate hx n\n  rwa [ContinuousLinearMap.smulRight_one_pow] at this\n\n"}
{"name":"HasFDerivWithinAt.comp_hasDerivWithinAt","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\ns : Set ğ•œ\nl : F â†’ E\nl' : ContinuousLinearMap (RingHom.id ğ•œ) F E\nt : Set F\nhl : HasFDerivWithinAt l l' t (f x)\nhf : HasDerivWithinAt f f' s x\nhst : Set.MapsTo f s t\nâŠ¢ HasDerivWithinAt (Function.comp l f) (l' f') s x","decl":"/-- The composition `l âˆ˜ f` where `l : F â†’ E` and `f : ğ•œ â†’ F`, has a derivative within a set\nequal to the FrÃ©chet derivative of `l` applied to the derivative of `f`. -/\ntheorem HasFDerivWithinAt.comp_hasDerivWithinAt {t : Set F} (hl : HasFDerivWithinAt l l' t (f x))\n    (hf : HasDerivWithinAt f f' s x) (hst : MapsTo f s t) :\n    HasDerivWithinAt (l âˆ˜ f) (l' f') s x := by\n  simpa only [one_apply, one_smul, smulRight_apply, coe_comp', (Â· âˆ˜ Â·)] using\n    (hl.comp x hf.hasFDerivWithinAt hst).hasDerivWithinAt\n\n"}
{"name":"HasFDerivWithinAt.comp_hasDerivWithinAt_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\ns : Set ğ•œ\nl : F â†’ E\nl' : ContinuousLinearMap (RingHom.id ğ•œ) F E\ny : F\nt : Set F\nhl : HasFDerivWithinAt l l' t y\nhf : HasDerivWithinAt f f' s x\nhst : Set.MapsTo f s t\nhy : Eq y (f x)\nâŠ¢ HasDerivWithinAt (Function.comp l f) (l' f') s x","decl":"/-- The composition `l âˆ˜ f` where `l : F â†’ E` and `f : ğ•œ â†’ F`, has a derivative within a set\nequal to the FrÃ©chet derivative of `l` applied to the derivative of `f`. -/\ntheorem HasFDerivWithinAt.comp_hasDerivWithinAt_of_eq {t : Set F}\n    (hl : HasFDerivWithinAt l l' t y)\n    (hf : HasDerivWithinAt f f' s x) (hst : MapsTo f s t) (hy : y = f x) :\n    HasDerivWithinAt (l âˆ˜ f) (l' f') s x := by\n  rw [hy] at hl; exact hl.comp_hasDerivWithinAt x hf hst\n\n"}
{"name":"HasFDerivAt.comp_hasDerivWithinAt","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\ns : Set ğ•œ\nl : F â†’ E\nl' : ContinuousLinearMap (RingHom.id ğ•œ) F E\nhl : HasFDerivAt l l' (f x)\nhf : HasDerivWithinAt f f' s x\nâŠ¢ HasDerivWithinAt (Function.comp l f) (l' f') s x","decl":"theorem HasFDerivAt.comp_hasDerivWithinAt (hl : HasFDerivAt l l' (f x))\n    (hf : HasDerivWithinAt f f' s x) : HasDerivWithinAt (l âˆ˜ f) (l' f') s x :=\n  hl.hasFDerivWithinAt.comp_hasDerivWithinAt x hf (mapsTo_univ _ _)\n\n"}
{"name":"HasFDerivAt.comp_hasDerivWithinAt_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\ns : Set ğ•œ\nl : F â†’ E\nl' : ContinuousLinearMap (RingHom.id ğ•œ) F E\ny : F\nhl : HasFDerivAt l l' y\nhf : HasDerivWithinAt f f' s x\nhy : Eq y (f x)\nâŠ¢ HasDerivWithinAt (Function.comp l f) (l' f') s x","decl":"theorem HasFDerivAt.comp_hasDerivWithinAt_of_eq (hl : HasFDerivAt l l' y)\n    (hf : HasDerivWithinAt f f' s x) (hy : y = f x) :\n    HasDerivWithinAt (l âˆ˜ f) (l' f') s x := by\n  rw [hy] at hl; exact hl.comp_hasDerivWithinAt x hf\n\n"}
{"name":"HasFDerivAt.comp_hasDerivAt","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\nl : F â†’ E\nl' : ContinuousLinearMap (RingHom.id ğ•œ) F E\nhl : HasFDerivAt l l' (f x)\nhf : HasDerivAt f f' x\nâŠ¢ HasDerivAt (Function.comp l f) (l' f') x","decl":"/-- The composition `l âˆ˜ f` where `l : F â†’ E` and `f : ğ•œ â†’ F`, has a derivative equal to the\nFrÃ©chet derivative of `l` applied to the derivative of `f`. -/\ntheorem HasFDerivAt.comp_hasDerivAt (hl : HasFDerivAt l l' (f x)) (hf : HasDerivAt f f' x) :\n    HasDerivAt (l âˆ˜ f) (l' f') x :=\n  hasDerivWithinAt_univ.mp <| hl.comp_hasDerivWithinAt x hf.hasDerivWithinAt\n\n"}
{"name":"HasFDerivAt.comp_hasDerivAt_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\nl : F â†’ E\nl' : ContinuousLinearMap (RingHom.id ğ•œ) F E\ny : F\nhl : HasFDerivAt l l' y\nhf : HasDerivAt f f' x\nhy : Eq y (f x)\nâŠ¢ HasDerivAt (Function.comp l f) (l' f') x","decl":"/-- The composition `l âˆ˜ f` where `l : F â†’ E` and `f : ğ•œ â†’ F`, has a derivative equal to the\nFrÃ©chet derivative of `l` applied to the derivative of `f`. -/\ntheorem HasFDerivAt.comp_hasDerivAt_of_eq\n    (hl : HasFDerivAt l l' y) (hf : HasDerivAt f f' x) (hy : y = f x) :\n    HasDerivAt (l âˆ˜ f) (l' f') x := by\n  rw [hy] at hl; exact hl.comp_hasDerivAt x hf\n\n"}
{"name":"HasStrictFDerivAt.comp_hasStrictDerivAt","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\nl : F â†’ E\nl' : ContinuousLinearMap (RingHom.id ğ•œ) F E\nhl : HasStrictFDerivAt l l' (f x)\nhf : HasStrictDerivAt f f' x\nâŠ¢ HasStrictDerivAt (Function.comp l f) (l' f') x","decl":"theorem HasStrictFDerivAt.comp_hasStrictDerivAt (hl : HasStrictFDerivAt l l' (f x))\n    (hf : HasStrictDerivAt f f' x) : HasStrictDerivAt (l âˆ˜ f) (l' f') x := by\n  simpa only [one_apply, one_smul, smulRight_apply, coe_comp', (Â· âˆ˜ Â·)] using\n    (hl.comp x hf.hasStrictFDerivAt).hasStrictDerivAt\n\n"}
{"name":"HasStrictFDerivAt.comp_hasStrictDerivAt_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\nl : F â†’ E\nl' : ContinuousLinearMap (RingHom.id ğ•œ) F E\ny : F\nhl : HasStrictFDerivAt l l' y\nhf : HasStrictDerivAt f f' x\nhy : Eq y (f x)\nâŠ¢ HasStrictDerivAt (Function.comp l f) (l' f') x","decl":"theorem HasStrictFDerivAt.comp_hasStrictDerivAt_of_eq (hl : HasStrictFDerivAt l l' y)\n    (hf : HasStrictDerivAt f f' x) (hy : y = f x) :\n    HasStrictDerivAt (l âˆ˜ f) (l' f') x := by\n  rw [hy] at hl; exact hl.comp_hasStrictDerivAt x hf\n\n"}
{"name":"fderivWithin_comp_derivWithin","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ F\nx : ğ•œ\ns : Set ğ•œ\nl : F â†’ E\nt : Set F\nhl : DifferentiableWithinAt ğ•œ l t (f x)\nhf : DifferentiableWithinAt ğ•œ f s x\nhs : Set.MapsTo f s t\nâŠ¢ Eq (derivWithin (Function.comp l f) s x) ((fderivWithin ğ•œ l t (f x)) (derivWithin f s x))","decl":"theorem fderivWithin_comp_derivWithin {t : Set F} (hl : DifferentiableWithinAt ğ•œ l t (f x))\n    (hf : DifferentiableWithinAt ğ•œ f s x) (hs : MapsTo f s t) :\n    derivWithin (l âˆ˜ f) s x = (fderivWithin ğ•œ l t (f x) : F â†’ E) (derivWithin f s x) := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  Â· exact (hl.hasFDerivWithinAt.comp_hasDerivWithinAt x hf.hasDerivWithinAt hs).derivWithin hxs\n  Â· simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"fderivWithin.comp_derivWithin","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ F\nx : ğ•œ\ns : Set ğ•œ\nl : F â†’ E\nt : Set F\nhl : DifferentiableWithinAt ğ•œ l t (f x)\nhf : DifferentiableWithinAt ğ•œ f s x\nhs : Set.MapsTo f s t\nâŠ¢ Eq (derivWithin (Function.comp l f) s x) ((fderivWithin ğ•œ l t (f x)) (derivWithin f s x))","decl":"@[deprecated (since := \"2024-10-31\")]\nalias fderivWithin.comp_derivWithin := fderivWithin_comp_derivWithin\n\n"}
{"name":"fderivWithin_comp_derivWithin_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ F\nx : ğ•œ\ns : Set ğ•œ\nl : F â†’ E\ny : F\nt : Set F\nhl : DifferentiableWithinAt ğ•œ l t y\nhf : DifferentiableWithinAt ğ•œ f s x\nhs : Set.MapsTo f s t\nhy : Eq y (f x)\nâŠ¢ Eq (derivWithin (Function.comp l f) s x) ((fderivWithin ğ•œ l t (f x)) (derivWithin f s x))","decl":"theorem fderivWithin_comp_derivWithin_of_eq {t : Set F} (hl : DifferentiableWithinAt ğ•œ l t y)\n    (hf : DifferentiableWithinAt ğ•œ f s x) (hs : MapsTo f s t) (hy : y = f x) :\n    derivWithin (l âˆ˜ f) s x = (fderivWithin ğ•œ l t (f x) : F â†’ E) (derivWithin f s x) := by\n  rw [hy] at hl; exact fderivWithin_comp_derivWithin x hl hf hs\n\n"}
{"name":"fderivWithin.comp_derivWithin_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ F\nx : ğ•œ\ns : Set ğ•œ\nl : F â†’ E\ny : F\nt : Set F\nhl : DifferentiableWithinAt ğ•œ l t y\nhf : DifferentiableWithinAt ğ•œ f s x\nhs : Set.MapsTo f s t\nhy : Eq y (f x)\nâŠ¢ Eq (derivWithin (Function.comp l f) s x) ((fderivWithin ğ•œ l t (f x)) (derivWithin f s x))","decl":"@[deprecated (since := \"2024-10-31\")]\nalias fderivWithin.comp_derivWithin_of_eq := fderivWithin_comp_derivWithin_of_eq\n\n"}
{"name":"fderiv_comp_deriv","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ F\nx : ğ•œ\nl : F â†’ E\nhl : DifferentiableAt ğ•œ l (f x)\nhf : DifferentiableAt ğ•œ f x\nâŠ¢ Eq (deriv (Function.comp l f) x) ((fderiv ğ•œ l (f x)) (deriv f x))","decl":"theorem fderiv_comp_deriv (hl : DifferentiableAt ğ•œ l (f x)) (hf : DifferentiableAt ğ•œ f x) :\n    deriv (l âˆ˜ f) x = (fderiv ğ•œ l (f x) : F â†’ E) (deriv f x) :=\n  (hl.hasFDerivAt.comp_hasDerivAt x hf.hasDerivAt).deriv\n\n"}
{"name":"fderiv.comp_deriv","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ F\nx : ğ•œ\nl : F â†’ E\nhl : DifferentiableAt ğ•œ l (f x)\nhf : DifferentiableAt ğ•œ f x\nâŠ¢ Eq (deriv (Function.comp l f) x) ((fderiv ğ•œ l (f x)) (deriv f x))","decl":"@[deprecated (since := \"2024-10-31\")]\nalias fderiv.comp_deriv := fderiv_comp_deriv\n\n"}
{"name":"fderiv_comp_deriv_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ F\nx : ğ•œ\nl : F â†’ E\ny : F\nhl : DifferentiableAt ğ•œ l y\nhf : DifferentiableAt ğ•œ f x\nhy : Eq y (f x)\nâŠ¢ Eq (deriv (Function.comp l f) x) ((fderiv ğ•œ l (f x)) (deriv f x))","decl":"theorem fderiv_comp_deriv_of_eq (hl : DifferentiableAt ğ•œ l y) (hf : DifferentiableAt ğ•œ f x)\n    (hy : y = f x) :\n    deriv (l âˆ˜ f) x = (fderiv ğ•œ l (f x) : F â†’ E) (deriv f x) := by\n  rw [hy] at hl; exact fderiv_comp_deriv x hl hf\n\n"}
{"name":"fderiv.comp_deriv_of_eq","module":"Mathlib.Analysis.Calculus.Deriv.Comp","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ F\nx : ğ•œ\nl : F â†’ E\ny : F\nhl : DifferentiableAt ğ•œ l y\nhf : DifferentiableAt ğ•œ f x\nhy : Eq y (f x)\nâŠ¢ Eq (deriv (Function.comp l f) x) ((fderiv ğ•œ l (f x)) (deriv f x))","decl":"@[deprecated (since := \"2024-10-31\")]\nalias fderiv.comp_deriv_of_eq := fderiv_comp_deriv_of_eq\n\n"}
