{"name":"Finsupp.prod_of_support_subset","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : CommMonoid N\nf : Finsupp α M\ns : Finset α\nhs : HasSubset.Subset f.support s\ng : α → M → N\nh : ∀ (i : α), Membership.mem s i → Eq (g i 0) 1\n⊢ Eq (f.prod g) (s.prod fun x => g x (f x))","decl":"@[to_additive]\ntheorem prod_of_support_subset (f : α →₀ M) {s : Finset α} (hs : f.support ⊆ s) (g : α → M → N)\n    (h : ∀ i ∈ s, g i 0 = 1) : f.prod g = ∏ x ∈ s, g x (f x) := by\n  refine Finset.prod_subset hs fun x hxs hx => h x hxs ▸ (congr_arg (g x) ?_)\n  exact not_mem_support_iff.1 hx\n\n"}
{"name":"Finsupp.sum_of_support_subset","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : AddCommMonoid N\nf : Finsupp α M\ns : Finset α\nhs : HasSubset.Subset f.support s\ng : α → M → N\nh : ∀ (i : α), Membership.mem s i → Eq (g i 0) 0\n⊢ Eq (f.sum g) (s.sum fun x => g x (f x))","decl":"@[to_additive]\ntheorem prod_of_support_subset (f : α →₀ M) {s : Finset α} (hs : f.support ⊆ s) (g : α → M → N)\n    (h : ∀ i ∈ s, g i 0 = 1) : f.prod g = ∏ x ∈ s, g x (f x) := by\n  refine Finset.prod_subset hs fun x hxs hx => h x hxs ▸ (congr_arg (g x) ?_)\n  exact not_mem_support_iff.1 hx\n\n"}
{"name":"Finsupp.prod_fintype","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝² : Zero M\ninst✝¹ : CommMonoid N\ninst✝ : Fintype α\nf : Finsupp α M\ng : α → M → N\nh : ∀ (i : α), Eq (g i 0) 1\n⊢ Eq (f.prod g) (Finset.univ.prod fun i => g i (f i))","decl":"@[to_additive]\ntheorem prod_fintype [Fintype α] (f : α →₀ M) (g : α → M → N) (h : ∀ i, g i 0 = 1) :\n    f.prod g = ∏ i, g i (f i) :=\n  f.prod_of_support_subset (subset_univ _) g fun x _ => h x\n\n"}
{"name":"Finsupp.sum_fintype","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝² : Zero M\ninst✝¹ : AddCommMonoid N\ninst✝ : Fintype α\nf : Finsupp α M\ng : α → M → N\nh : ∀ (i : α), Eq (g i 0) 0\n⊢ Eq (f.sum g) (Finset.univ.sum fun i => g i (f i))","decl":"@[to_additive]\ntheorem prod_fintype [Fintype α] (f : α →₀ M) (g : α → M → N) (h : ∀ i, g i 0 = 1) :\n    f.prod g = ∏ i, g i (f i) :=\n  f.prod_of_support_subset (subset_univ _) g fun x _ => h x\n\n"}
{"name":"Finsupp.sum_single_index","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : AddCommMonoid N\na : α\nb : M\nh : α → M → N\nh_zero : Eq (h a 0) 0\n⊢ Eq ((Finsupp.single a b).sum h) (h a b)","decl":"@[to_additive (attr := simp)]\ntheorem prod_single_index {a : α} {b : M} {h : α → M → N} (h_zero : h a 0 = 1) :\n    (single a b).prod h = h a b :=\n  calc\n    (single a b).prod h = ∏ x ∈ {a}, h x (single a b x) :=\n      prod_of_support_subset _ support_single_subset h fun _ hx =>\n        (mem_singleton.1 hx).symm ▸ h_zero\n    _ = h a b := by simp\n\n"}
{"name":"Finsupp.prod_single_index","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : CommMonoid N\na : α\nb : M\nh : α → M → N\nh_zero : Eq (h a 0) 1\n⊢ Eq ((Finsupp.single a b).prod h) (h a b)","decl":"@[to_additive (attr := simp)]\ntheorem prod_single_index {a : α} {b : M} {h : α → M → N} (h_zero : h a 0 = 1) :\n    (single a b).prod h = h a b :=\n  calc\n    (single a b).prod h = ∏ x ∈ {a}, h x (single a b x) :=\n      prod_of_support_subset _ support_single_subset h fun _ hx =>\n        (mem_singleton.1 hx).symm ▸ h_zero\n    _ = h a b := by simp\n\n"}
{"name":"Finsupp.prod_mapRange_index","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nM' : Type u_9\nN : Type u_10\ninst✝² : Zero M\ninst✝¹ : Zero M'\ninst✝ : CommMonoid N\nf : M → M'\nhf : Eq (f 0) 0\ng : Finsupp α M\nh : α → M' → N\nh0 : ∀ (a : α), Eq (h a 0) 1\n⊢ Eq ((Finsupp.mapRange f hf g).prod h) (g.prod fun a b => h a (f b))","decl":"@[to_additive]\ntheorem prod_mapRange_index {f : M → M'} {hf : f 0 = 0} {g : α →₀ M} {h : α → M' → N}\n    (h0 : ∀ a, h a 0 = 1) : (mapRange f hf g).prod h = g.prod fun a b => h a (f b) :=\n  Finset.prod_subset support_mapRange fun _ _ H => by rw [not_mem_support_iff.1 H, h0]\n\n"}
{"name":"Finsupp.sum_mapRange_index","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nM' : Type u_9\nN : Type u_10\ninst✝² : Zero M\ninst✝¹ : Zero M'\ninst✝ : AddCommMonoid N\nf : M → M'\nhf : Eq (f 0) 0\ng : Finsupp α M\nh : α → M' → N\nh0 : ∀ (a : α), Eq (h a 0) 0\n⊢ Eq ((Finsupp.mapRange f hf g).sum h) (g.sum fun a b => h a (f b))","decl":"@[to_additive]\ntheorem prod_mapRange_index {f : M → M'} {hf : f 0 = 0} {g : α →₀ M} {h : α → M' → N}\n    (h0 : ∀ a, h a 0 = 1) : (mapRange f hf g).prod h = g.prod fun a b => h a (f b) :=\n  Finset.prod_subset support_mapRange fun _ _ H => by rw [not_mem_support_iff.1 H, h0]\n\n"}
{"name":"Finsupp.prod_zero_index","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : CommMonoid N\nh : α → M → N\n⊢ Eq (Finsupp.prod 0 h) 1","decl":"@[to_additive (attr := simp)]\ntheorem prod_zero_index {h : α → M → N} : (0 : α →₀ M).prod h = 1 :=\n  rfl\n\n"}
{"name":"Finsupp.sum_zero_index","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : AddCommMonoid N\nh : α → M → N\n⊢ Eq (Finsupp.sum 0 h) 0","decl":"@[to_additive (attr := simp)]\ntheorem prod_zero_index {h : α → M → N} : (0 : α →₀ M).prod h = 1 :=\n  rfl\n\n"}
{"name":"Finsupp.prod_comm","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nβ : Type u_7\nM : Type u_8\nM' : Type u_9\nN : Type u_10\ninst✝² : Zero M\ninst✝¹ : Zero M'\ninst✝ : CommMonoid N\nf : Finsupp α M\ng : Finsupp β M'\nh : α → M → β → M' → N\n⊢ Eq (f.prod fun x v => g.prod fun x' v' => h x v x' v') (g.prod fun x' v' => f.prod fun x v => h x v x' v')","decl":"@[to_additive]\ntheorem prod_comm (f : α →₀ M) (g : β →₀ M') (h : α → M → β → M' → N) :\n    (f.prod fun x v => g.prod fun x' v' => h x v x' v') =\n      g.prod fun x' v' => f.prod fun x v => h x v x' v' :=\n  Finset.prod_comm\n\n"}
{"name":"Finsupp.sum_comm","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nβ : Type u_7\nM : Type u_8\nM' : Type u_9\nN : Type u_10\ninst✝² : Zero M\ninst✝¹ : Zero M'\ninst✝ : AddCommMonoid N\nf : Finsupp α M\ng : Finsupp β M'\nh : α → M → β → M' → N\n⊢ Eq (f.sum fun x v => g.sum fun x' v' => h x v x' v') (g.sum fun x' v' => f.sum fun x v => h x v x' v')","decl":"@[to_additive]\ntheorem prod_comm (f : α →₀ M) (g : β →₀ M') (h : α → M → β → M' → N) :\n    (f.prod fun x v => g.prod fun x' v' => h x v x' v') =\n      g.prod fun x' v' => f.prod fun x v => h x v x' v' :=\n  Finset.prod_comm\n\n"}
{"name":"Finsupp.sum_ite_eq","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝² : Zero M\ninst✝¹ : AddCommMonoid N\ninst✝ : DecidableEq α\nf : Finsupp α M\na : α\nb : α → M → N\n⊢ Eq (f.sum fun x v => ite (Eq a x) (b x v) 0) (ite (Membership.mem f.support a) (b a (f a)) 0)","decl":"@[to_additive (attr := simp)]\ntheorem prod_ite_eq [DecidableEq α] (f : α →₀ M) (a : α) (b : α → M → N) :\n    (f.prod fun x v => ite (a = x) (b x v) 1) = ite (a ∈ f.support) (b a (f a)) 1 := by\n  dsimp [Finsupp.prod]\n  rw [f.support.prod_ite_eq]\n\n"}
{"name":"Finsupp.prod_ite_eq","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝² : Zero M\ninst✝¹ : CommMonoid N\ninst✝ : DecidableEq α\nf : Finsupp α M\na : α\nb : α → M → N\n⊢ Eq (f.prod fun x v => ite (Eq a x) (b x v) 1) (ite (Membership.mem f.support a) (b a (f a)) 1)","decl":"@[to_additive (attr := simp)]\ntheorem prod_ite_eq [DecidableEq α] (f : α →₀ M) (a : α) (b : α → M → N) :\n    (f.prod fun x v => ite (a = x) (b x v) 1) = ite (a ∈ f.support) (b a (f a)) 1 := by\n  dsimp [Finsupp.prod]\n  rw [f.support.prod_ite_eq]\n\n"}
{"name":"Finsupp.sum_ite_self_eq","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\nN : Type u_16\ninst✝ : AddCommMonoid N\nf : Finsupp α N\na : α\n⊢ Eq (f.sum fun x v => ite (Eq a x) v 0) (f a)","decl":"theorem sum_ite_self_eq [DecidableEq α] {N : Type*} [AddCommMonoid N] (f : α →₀ N) (a : α) :\n    (f.sum fun x v => ite (a = x) v 0) = f a := by\n  classical\n    convert f.sum_ite_eq a fun _ => id\n    simp [ite_eq_right_iff.2 Eq.symm]\n\n"}
{"name":"Finsupp.if_mem_support","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\nN : Type u_16\ninst✝ : AddCommMonoid N\nf : Finsupp α N\na : α\n⊢ Eq (ite (Membership.mem f.support a) (f a) 0) (f a)","decl":"/--\nThe left hand side of `sum_ite_self_eq` simplifies; this is the variant that is useful for `simp`.\n-/\n@[simp]\ntheorem if_mem_support [DecidableEq α] {N : Type*} [AddCommMonoid N] (f : α →₀ N) (a : α) :\n    (if a ∈ f.support then f a else 0) = f a := by\n  simp only [mem_support_iff, ne_eq, ite_eq_left_iff, not_not]\n  exact fun h ↦ h.symm\n\n"}
{"name":"Finsupp.sum_ite_eq'","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝² : Zero M\ninst✝¹ : AddCommMonoid N\ninst✝ : DecidableEq α\nf : Finsupp α M\na : α\nb : α → M → N\n⊢ Eq (f.sum fun x v => ite (Eq x a) (b x v) 0) (ite (Membership.mem f.support a) (b a (f a)) 0)","decl":"/-- A restatement of `prod_ite_eq` with the equality test reversed. -/\n@[to_additive (attr := simp) \"A restatement of `sum_ite_eq` with the equality test reversed.\"]\ntheorem prod_ite_eq' [DecidableEq α] (f : α →₀ M) (a : α) (b : α → M → N) :\n    (f.prod fun x v => ite (x = a) (b x v) 1) = ite (a ∈ f.support) (b a (f a)) 1 := by\n  dsimp [Finsupp.prod]\n  rw [f.support.prod_ite_eq']\n\n"}
{"name":"Finsupp.prod_ite_eq'","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝² : Zero M\ninst✝¹ : CommMonoid N\ninst✝ : DecidableEq α\nf : Finsupp α M\na : α\nb : α → M → N\n⊢ Eq (f.prod fun x v => ite (Eq x a) (b x v) 1) (ite (Membership.mem f.support a) (b a (f a)) 1)","decl":"/-- A restatement of `prod_ite_eq` with the equality test reversed. -/\n@[to_additive (attr := simp) \"A restatement of `sum_ite_eq` with the equality test reversed.\"]\ntheorem prod_ite_eq' [DecidableEq α] (f : α →₀ M) (a : α) (b : α → M → N) :\n    (f.prod fun x v => ite (x = a) (b x v) 1) = ite (a ∈ f.support) (b a (f a)) 1 := by\n  dsimp [Finsupp.prod]\n  rw [f.support.prod_ite_eq']\n\n"}
{"name":"Finsupp.sum_ite_self_eq'","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\nN : Type u_16\ninst✝ : AddCommMonoid N\nf : Finsupp α N\na : α\n⊢ Eq (f.sum fun x v => ite (Eq x a) v 0) (f a)","decl":"/-- A restatement of `sum_ite_self_eq` with the equality test reversed. -/\ntheorem sum_ite_self_eq' [DecidableEq α] {N : Type*} [AddCommMonoid N] (f : α →₀ N) (a : α) :\n    (f.sum fun x v => ite (x = a) v 0) = f a := by\n  classical\n    convert f.sum_ite_eq' a fun _ => id\n    simp [ite_eq_right_iff.2 Eq.symm]\n\n"}
{"name":"Finsupp.prod_pow","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nN : Type u_10\ninst✝¹ : CommMonoid N\ninst✝ : Fintype α\nf : Finsupp α Nat\ng : α → N\n⊢ Eq (f.prod fun a b => HPow.hPow (g a) b) (Finset.univ.prod fun a => HPow.hPow (g a) (f a))","decl":"@[to_additive (attr := simp)]\ntheorem prod_pow [Fintype α] (f : α →₀ ℕ) (g : α → N) :\n    (f.prod fun a b => g a ^ b) = ∏ a, g a ^ f a :=\n  f.prod_fintype _ fun _ ↦ pow_zero _\n\n"}
{"name":"Finsupp.sum_nsmul","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nN : Type u_10\ninst✝¹ : AddCommMonoid N\ninst✝ : Fintype α\nf : Finsupp α Nat\ng : α → N\n⊢ Eq (f.sum fun a b => HSMul.hSMul b (g a)) (Finset.univ.sum fun a => HSMul.hSMul (f a) (g a))","decl":"@[to_additive (attr := simp)]\ntheorem prod_pow [Fintype α] (f : α →₀ ℕ) (g : α → N) :\n    (f.prod fun a b => g a ^ b) = ∏ a, g a ^ f a :=\n  f.prod_fintype _ fun _ ↦ pow_zero _\n\n"}
{"name":"Finsupp.prod_zpow","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nN : Type u_16\ninst✝¹ : CommGroup N\ninst✝ : Fintype α\nf : Finsupp α Int\ng : α → N\n⊢ Eq (f.prod fun a b => HPow.hPow (g a) b) (Finset.univ.prod fun a => HPow.hPow (g a) (f a))","decl":"@[to_additive (attr := simp)]\ntheorem prod_zpow {N} [CommGroup N] [Fintype α] (f : α →₀ ℤ) (g : α → N) :\n    (f.prod fun a b => g a ^ b) = ∏ a, g a ^ f a :=\n  f.prod_fintype _ fun _ ↦ zpow_zero _\n\n"}
{"name":"Finsupp.sum_zsmul","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nN : Type u_16\ninst✝¹ : AddCommGroup N\ninst✝ : Fintype α\nf : Finsupp α Int\ng : α → N\n⊢ Eq (f.sum fun a b => HSMul.hSMul b (g a)) (Finset.univ.sum fun a => HSMul.hSMul (f a) (g a))","decl":"@[to_additive (attr := simp)]\ntheorem prod_zpow {N} [CommGroup N] [Fintype α] (f : α →₀ ℤ) (g : α → N) :\n    (f.prod fun a b => g a ^ b) = ∏ a, g a ^ f a :=\n  f.prod_fintype _ fun _ ↦ zpow_zero _\n\n"}
{"name":"Finsupp.onFinset_prod","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : CommMonoid N\ns : Finset α\nf : α → M\ng : α → M → N\nhf : ∀ (a : α), Ne (f a) 0 → Membership.mem s a\nhg : ∀ (a : α), Eq (g a 0) 1\n⊢ Eq ((Finsupp.onFinset s f hf).prod g) (s.prod fun a => g a (f a))","decl":"/-- If `g` maps a second argument of 0 to 1, then multiplying it over the\nresult of `onFinset` is the same as multiplying it over the original `Finset`. -/\n@[to_additive\n      \"If `g` maps a second argument of 0 to 0, summing it over the\n      result of `onFinset` is the same as summing it over the original `Finset`.\"]\ntheorem onFinset_prod {s : Finset α} {f : α → M} {g : α → M → N} (hf : ∀ a, f a ≠ 0 → a ∈ s)\n    (hg : ∀ a, g a 0 = 1) : (onFinset s f hf).prod g = ∏ a ∈ s, g a (f a) :=\n  Finset.prod_subset support_onFinset_subset <| by simp +contextual [*]\n\n"}
{"name":"Finsupp.onFinset_sum","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : AddCommMonoid N\ns : Finset α\nf : α → M\ng : α → M → N\nhf : ∀ (a : α), Ne (f a) 0 → Membership.mem s a\nhg : ∀ (a : α), Eq (g a 0) 0\n⊢ Eq ((Finsupp.onFinset s f hf).sum g) (s.sum fun a => g a (f a))","decl":"/-- If `g` maps a second argument of 0 to 1, then multiplying it over the\nresult of `onFinset` is the same as multiplying it over the original `Finset`. -/\n@[to_additive\n      \"If `g` maps a second argument of 0 to 0, summing it over the\n      result of `onFinset` is the same as summing it over the original `Finset`.\"]\ntheorem onFinset_prod {s : Finset α} {f : α → M} {g : α → M → N} (hf : ∀ a, f a ≠ 0 → a ∈ s)\n    (hg : ∀ a, g a 0 = 1) : (onFinset s f hf).prod g = ∏ a ∈ s, g a (f a) :=\n  Finset.prod_subset support_onFinset_subset <| by simp +contextual [*]\n\n"}
{"name":"Finsupp.mul_prod_erase","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : CommMonoid N\nf : Finsupp α M\ny : α\ng : α → M → N\nhyf : Membership.mem f.support y\n⊢ Eq (HMul.hMul (g y (f y)) ((Finsupp.erase y f).prod g)) (f.prod g)","decl":"/-- Taking a product over `f : α →₀ M` is the same as multiplying the value on a single element\n`y ∈ f.support` by the product over `erase y f`. -/\n@[to_additive\n      \" Taking a sum over `f : α →₀ M` is the same as adding the value on a\n      single element `y ∈ f.support` to the sum over `erase y f`. \"]\ntheorem mul_prod_erase (f : α →₀ M) (y : α) (g : α → M → N) (hyf : y ∈ f.support) :\n    g y (f y) * (erase y f).prod g = f.prod g := by\n  classical\n    rw [Finsupp.prod, Finsupp.prod, ← Finset.mul_prod_erase _ _ hyf, Finsupp.support_erase,\n      Finset.prod_congr rfl]\n    intro h hx\n    rw [Finsupp.erase_ne (ne_of_mem_erase hx)]\n\n"}
{"name":"Finsupp.add_sum_erase","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : AddCommMonoid N\nf : Finsupp α M\ny : α\ng : α → M → N\nhyf : Membership.mem f.support y\n⊢ Eq (HAdd.hAdd (g y (f y)) ((Finsupp.erase y f).sum g)) (f.sum g)","decl":"/-- Taking a product over `f : α →₀ M` is the same as multiplying the value on a single element\n`y ∈ f.support` by the product over `erase y f`. -/\n@[to_additive\n      \" Taking a sum over `f : α →₀ M` is the same as adding the value on a\n      single element `y ∈ f.support` to the sum over `erase y f`. \"]\ntheorem mul_prod_erase (f : α →₀ M) (y : α) (g : α → M → N) (hyf : y ∈ f.support) :\n    g y (f y) * (erase y f).prod g = f.prod g := by\n  classical\n    rw [Finsupp.prod, Finsupp.prod, ← Finset.mul_prod_erase _ _ hyf, Finsupp.support_erase,\n      Finset.prod_congr rfl]\n    intro h hx\n    rw [Finsupp.erase_ne (ne_of_mem_erase hx)]\n\n"}
{"name":"Finsupp.mul_prod_erase'","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : CommMonoid N\nf : Finsupp α M\ny : α\ng : α → M → N\nhg : ∀ (i : α), Eq (g i 0) 1\n⊢ Eq (HMul.hMul (g y (f y)) ((Finsupp.erase y f).prod g)) (f.prod g)","decl":"/-- Generalization of `Finsupp.mul_prod_erase`: if `g` maps a second argument of 0 to 1,\nthen its product over `f : α →₀ M` is the same as multiplying the value on any element\n`y : α` by the product over `erase y f`. -/\n@[to_additive\n      \" Generalization of `Finsupp.add_sum_erase`: if `g` maps a second argument of 0\n      to 0, then its sum over `f : α →₀ M` is the same as adding the value on any element\n      `y : α` to the sum over `erase y f`. \"]\ntheorem mul_prod_erase' (f : α →₀ M) (y : α) (g : α → M → N) (hg : ∀ i : α, g i 0 = 1) :\n    g y (f y) * (erase y f).prod g = f.prod g := by\n  classical\n    by_cases hyf : y ∈ f.support\n    · exact Finsupp.mul_prod_erase f y g hyf\n    · rw [not_mem_support_iff.mp hyf, hg y, erase_of_not_mem_support hyf, one_mul]\n\n"}
{"name":"Finsupp.add_sum_erase'","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : AddCommMonoid N\nf : Finsupp α M\ny : α\ng : α → M → N\nhg : ∀ (i : α), Eq (g i 0) 0\n⊢ Eq (HAdd.hAdd (g y (f y)) ((Finsupp.erase y f).sum g)) (f.sum g)","decl":"/-- Generalization of `Finsupp.mul_prod_erase`: if `g` maps a second argument of 0 to 1,\nthen its product over `f : α →₀ M` is the same as multiplying the value on any element\n`y : α` by the product over `erase y f`. -/\n@[to_additive\n      \" Generalization of `Finsupp.add_sum_erase`: if `g` maps a second argument of 0\n      to 0, then its sum over `f : α →₀ M` is the same as adding the value on any element\n      `y : α` to the sum over `erase y f`. \"]\ntheorem mul_prod_erase' (f : α →₀ M) (y : α) (g : α → M → N) (hg : ∀ i : α, g i 0 = 1) :\n    g y (f y) * (erase y f).prod g = f.prod g := by\n  classical\n    by_cases hyf : y ∈ f.support\n    · exact Finsupp.mul_prod_erase f y g hyf\n    · rw [not_mem_support_iff.mp hyf, hg y, erase_of_not_mem_support hyf, one_mul]\n\n"}
{"name":"AddSubmonoidClass.finsupp_sum_mem","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝³ : Zero M\ninst✝² : AddCommMonoid N\nS : Type u_16\ninst✝¹ : SetLike S N\ninst✝ : AddSubmonoidClass S N\ns : S\nf : Finsupp α M\ng : α → M → N\nh : ∀ (c : α), Ne (f c) 0 → Membership.mem s (g c (f c))\n⊢ Membership.mem s (f.sum g)","decl":"@[to_additive]\ntheorem _root_.SubmonoidClass.finsupp_prod_mem {S : Type*} [SetLike S N] [SubmonoidClass S N]\n    (s : S) (f : α →₀ M) (g : α → M → N) (h : ∀ c, f c ≠ 0 → g c (f c) ∈ s) : f.prod g ∈ s :=\n  prod_mem fun _i hi => h _ (Finsupp.mem_support_iff.mp hi)\n\n"}
{"name":"SubmonoidClass.finsupp_prod_mem","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝³ : Zero M\ninst✝² : CommMonoid N\nS : Type u_16\ninst✝¹ : SetLike S N\ninst✝ : SubmonoidClass S N\ns : S\nf : Finsupp α M\ng : α → M → N\nh : ∀ (c : α), Ne (f c) 0 → Membership.mem s (g c (f c))\n⊢ Membership.mem s (f.prod g)","decl":"@[to_additive]\ntheorem _root_.SubmonoidClass.finsupp_prod_mem {S : Type*} [SetLike S N] [SubmonoidClass S N]\n    (s : S) (f : α →₀ M) (g : α → M → N) (h : ∀ c, f c ≠ 0 → g c (f c) ∈ s) : f.prod g ∈ s :=\n  prod_mem fun _i hi => h _ (Finsupp.mem_support_iff.mp hi)\n\n"}
{"name":"Finsupp.prod_congr","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : CommMonoid N\nf : Finsupp α M\ng1 g2 : α → M → N\nh : ∀ (x : α), Membership.mem f.support x → Eq (g1 x (f x)) (g2 x (f x))\n⊢ Eq (f.prod g1) (f.prod g2)","decl":"@[to_additive]\ntheorem prod_congr {f : α →₀ M} {g1 g2 : α → M → N} (h : ∀ x ∈ f.support, g1 x (f x) = g2 x (f x)) :\n    f.prod g1 = f.prod g2 :=\n  Finset.prod_congr rfl h\n\n"}
{"name":"Finsupp.sum_congr","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : AddCommMonoid N\nf : Finsupp α M\ng1 g2 : α → M → N\nh : ∀ (x : α), Membership.mem f.support x → Eq (g1 x (f x)) (g2 x (f x))\n⊢ Eq (f.sum g1) (f.sum g2)","decl":"@[to_additive]\ntheorem prod_congr {f : α →₀ M} {g1 g2 : α → M → N} (h : ∀ x ∈ f.support, g1 x (f x) = g2 x (f x)) :\n    f.prod g1 = f.prod g2 :=\n  Finset.prod_congr rfl h\n\n"}
{"name":"Finsupp.prod_eq_single","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : CommMonoid N\nf : Finsupp α M\na : α\ng : α → M → N\nh₀ : ∀ (b : α), Ne (f b) 0 → Ne b a → Eq (g b (f b)) 1\nh₁ : Eq (f a) 0 → Eq (g a 0) 1\n⊢ Eq (f.prod g) (g a (f a))","decl":"@[to_additive]\ntheorem prod_eq_single {f : α →₀ M} (a : α) {g : α → M → N}\n    (h₀ : ∀ b, f b ≠ 0 → b ≠ a → g b (f b) = 1) (h₁ : f a = 0 → g a 0 = 1) :\n    f.prod g = g a (f a) := by\n  refine Finset.prod_eq_single a (fun b hb₁ hb₂ => ?_) (fun h => ?_)\n  · exact h₀ b (mem_support_iff.mp hb₁) hb₂\n  · simp only [not_mem_support_iff] at h\n    rw [h]\n    exact h₁ h\n\n"}
{"name":"Finsupp.sum_eq_single","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : AddCommMonoid N\nf : Finsupp α M\na : α\ng : α → M → N\nh₀ : ∀ (b : α), Ne (f b) 0 → Ne b a → Eq (g b (f b)) 0\nh₁ : Eq (f a) 0 → Eq (g a 0) 0\n⊢ Eq (f.sum g) (g a (f a))","decl":"@[to_additive]\ntheorem prod_eq_single {f : α →₀ M} (a : α) {g : α → M → N}\n    (h₀ : ∀ b, f b ≠ 0 → b ≠ a → g b (f b) = 1) (h₁ : f a = 0 → g a 0 = 1) :\n    f.prod g = g a (f a) := by\n  refine Finset.prod_eq_single a (fun b hb₁ hb₂ => ?_) (fun h => ?_)\n  · exact h₀ b (mem_support_iff.mp hb₁) hb₂\n  · simp only [not_mem_support_iff] at h\n    rw [h]\n    exact h₁ h\n\n"}
{"name":"Finsupp.prod_eq_zero_iff","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nι : Type u_2\nβ : Type u_7\ninst✝³ : Zero α\ninst✝² : CommMonoidWithZero β\ninst✝¹ : Nontrivial β\ninst✝ : NoZeroDivisors β\nf : Finsupp ι α\ng : ι → α → β\n⊢ Iff (Eq (f.prod g) 0) (Exists fun i => And (Membership.mem f.support i) (Eq (g i (f i)) 0))","decl":"@[simp]\nlemma prod_eq_zero_iff : f.prod g = 0 ↔ ∃ i ∈ f.support, g i (f i) = 0 := Finset.prod_eq_zero_iff\n"}
{"name":"Finsupp.prod_ne_zero_iff","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nι : Type u_2\nβ : Type u_7\ninst✝³ : Zero α\ninst✝² : CommMonoidWithZero β\ninst✝¹ : Nontrivial β\ninst✝ : NoZeroDivisors β\nf : Finsupp ι α\ng : ι → α → β\n⊢ Iff (Ne (f.prod g) 0) (∀ (i : ι), Membership.mem f.support i → Ne (g i (f i)) 0)","decl":"lemma prod_ne_zero_iff : f.prod g ≠ 0 ↔ ∀ i ∈ f.support, g i (f i) ≠ 0 := Finset.prod_ne_zero_iff\n\n"}
{"name":"map_finsupp_sum","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\nP : Type u_11\ninst✝⁴ : Zero M\ninst✝³ : AddCommMonoid N\ninst✝² : AddCommMonoid P\nH : Type u_16\ninst✝¹ : FunLike H N P\ninst✝ : AddMonoidHomClass H N P\nh : H\nf : Finsupp α M\ng : α → M → N\n⊢ Eq (h (f.sum g)) (f.sum fun a b => h (g a b))","decl":"@[to_additive]\ntheorem map_finsupp_prod [Zero M] [CommMonoid N] [CommMonoid P] {H : Type*}\n    [FunLike H N P] [MonoidHomClass H N P]\n    (h : H) (f : α →₀ M) (g : α → M → N) : h (f.prod g) = f.prod fun a b => h (g a b) :=\n  map_prod h _ _\n\n-- Porting note: inserted ⇑ on the rhs\n"}
{"name":"map_finsupp_prod","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\nP : Type u_11\ninst✝⁴ : Zero M\ninst✝³ : CommMonoid N\ninst✝² : CommMonoid P\nH : Type u_16\ninst✝¹ : FunLike H N P\ninst✝ : MonoidHomClass H N P\nh : H\nf : Finsupp α M\ng : α → M → N\n⊢ Eq (h (f.prod g)) (f.prod fun a b => h (g a b))","decl":"@[to_additive]\ntheorem map_finsupp_prod [Zero M] [CommMonoid N] [CommMonoid P] {H : Type*}\n    [FunLike H N P] [MonoidHomClass H N P]\n    (h : H) (f : α →₀ M) (g : α → M → N) : h (f.prod g) = f.prod fun a b => h (g a b) :=\n  map_prod h _ _\n\n-- Porting note: inserted ⇑ on the rhs\n"}
{"name":"MonoidHom.coe_finsupp_prod","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nβ : Type u_7\nN : Type u_10\nP : Type u_11\ninst✝² : Zero β\ninst✝¹ : Monoid N\ninst✝ : CommMonoid P\nf : Finsupp α β\ng : α → β → MonoidHom N P\n⊢ Eq (⇑(f.prod g)) (f.prod fun i fi => ⇑(g i fi))","decl":"@[to_additive]\ntheorem MonoidHom.coe_finsupp_prod [Zero β] [Monoid N] [CommMonoid P] (f : α →₀ β)\n    (g : α → β → N →* P) : ⇑(f.prod g) = f.prod fun i fi => ⇑(g i fi) :=\n  MonoidHom.coe_finset_prod _ _\n\n"}
{"name":"AddMonoidHom.coe_finsupp_sum","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nβ : Type u_7\nN : Type u_10\nP : Type u_11\ninst✝² : Zero β\ninst✝¹ : AddMonoid N\ninst✝ : AddCommMonoid P\nf : Finsupp α β\ng : α → β → AddMonoidHom N P\n⊢ Eq (⇑(f.sum g)) (f.sum fun i fi => ⇑(g i fi))","decl":"@[to_additive]\ntheorem MonoidHom.coe_finsupp_prod [Zero β] [Monoid N] [CommMonoid P] (f : α →₀ β)\n    (g : α → β → N →* P) : ⇑(f.prod g) = f.prod fun i fi => ⇑(g i fi) :=\n  MonoidHom.coe_finset_prod _ _\n\n"}
{"name":"AddMonoidHom.finsupp_sum_apply","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nβ : Type u_7\nN : Type u_10\nP : Type u_11\ninst✝² : Zero β\ninst✝¹ : AddMonoid N\ninst✝ : AddCommMonoid P\nf : Finsupp α β\ng : α → β → AddMonoidHom N P\nx : N\n⊢ Eq ((f.sum g) x) (f.sum fun i fi => (g i fi) x)","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.finsupp_prod_apply [Zero β] [Monoid N] [CommMonoid P] (f : α →₀ β)\n    (g : α → β → N →* P) (x : N) : f.prod g x = f.prod fun i fi => g i fi x :=\n  MonoidHom.finset_prod_apply _ _ _\n\n"}
{"name":"MonoidHom.finsupp_prod_apply","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nβ : Type u_7\nN : Type u_10\nP : Type u_11\ninst✝² : Zero β\ninst✝¹ : Monoid N\ninst✝ : CommMonoid P\nf : Finsupp α β\ng : α → β → MonoidHom N P\nx : N\n⊢ Eq ((f.prod g) x) (f.prod fun i fi => (g i fi) x)","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.finsupp_prod_apply [Zero β] [Monoid N] [CommMonoid P] (f : α →₀ β)\n    (g : α → β → N →* P) (x : N) : f.prod g x = f.prod fun i fi => g i fi x :=\n  MonoidHom.finset_prod_apply _ _ _\n\n"}
{"name":"Finsupp.single_multiset_sum","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\ninst✝ : AddCommMonoid M\ns : Multiset M\na : α\n⊢ Eq (Finsupp.single a s.sum) (Multiset.map (Finsupp.single a) s).sum","decl":"theorem single_multiset_sum [AddCommMonoid M] (s : Multiset M) (a : α) :\n    single a s.sum = (s.map (single a)).sum :=\n  Multiset.induction_on s (single_zero _) fun a s ih => by\n    rw [Multiset.sum_cons, single_add, ih, Multiset.map_cons, Multiset.sum_cons]\n\n"}
{"name":"Finsupp.single_finset_sum","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nι : Type u_2\nM : Type u_8\ninst✝ : AddCommMonoid M\ns : Finset ι\nf : ι → M\na : α\n⊢ Eq (Finsupp.single a (s.sum fun b => f b)) (s.sum fun b => Finsupp.single a (f b))","decl":"theorem single_finset_sum [AddCommMonoid M] (s : Finset ι) (f : ι → M) (a : α) :\n    single a (∑ b ∈ s, f b) = ∑ b ∈ s, single a (f b) := by\n  trans\n  · apply single_multiset_sum\n  · rw [Multiset.map_map]\n    rfl\n\n"}
{"name":"Finsupp.single_sum","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nι : Type u_2\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : AddCommMonoid N\ns : Finsupp ι M\nf : ι → M → N\na : α\n⊢ Eq (Finsupp.single a (s.sum f)) (s.sum fun d c => Finsupp.single a (f d c))","decl":"theorem single_sum [Zero M] [AddCommMonoid N] (s : ι →₀ M) (f : ι → M → N) (a : α) :\n    single a (s.sum f) = s.sum fun d c => single a (f d c) :=\n  single_finset_sum _ _ _\n\n"}
{"name":"Finsupp.sum_neg_index","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nG : Type u_12\ninst✝¹ : AddGroup G\ninst✝ : AddCommMonoid M\ng : Finsupp α G\nh : α → G → M\nh0 : ∀ (a : α), Eq (h a 0) 0\n⊢ Eq ((Neg.neg g).sum h) (g.sum fun a b => h a (Neg.neg b))","decl":"@[to_additive]\ntheorem prod_neg_index [AddGroup G] [CommMonoid M] {g : α →₀ G} {h : α → G → M}\n    (h0 : ∀ a, h a 0 = 1) : (-g).prod h = g.prod fun a b => h a (-b) :=\n  prod_mapRange_index h0\n\n"}
{"name":"Finsupp.prod_neg_index","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nG : Type u_12\ninst✝¹ : AddGroup G\ninst✝ : CommMonoid M\ng : Finsupp α G\nh : α → G → M\nh0 : ∀ (a : α), Eq (h a 0) 1\n⊢ Eq ((Neg.neg g).prod h) (g.prod fun a b => h a (Neg.neg b))","decl":"@[to_additive]\ntheorem prod_neg_index [AddGroup G] [CommMonoid M] {g : α →₀ G} {h : α → G → M}\n    (h0 : ∀ a, h a 0 = 1) : (-g).prod h = g.prod fun a b => h a (-b) :=\n  prod_mapRange_index h0\n\n"}
{"name":"Finsupp.finset_sum_apply","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nι : Type u_2\nN : Type u_10\ninst✝ : AddCommMonoid N\nS : Finset ι\nf : ι → Finsupp α N\na : α\n⊢ Eq ((S.sum fun i => f i) a) (S.sum fun i => (f i) a)","decl":"theorem finset_sum_apply [AddCommMonoid N] (S : Finset ι) (f : ι → α →₀ N) (a : α) :\n    (∑ i ∈ S, f i) a = ∑ i ∈ S, f i a :=\n  map_sum (applyAddHom a) _ _\n\n"}
{"name":"Finsupp.sum_apply","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nβ : Type u_7\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : AddCommMonoid N\nf : Finsupp α M\ng : α → M → Finsupp β N\na₂ : β\n⊢ Eq ((f.sum g) a₂) (f.sum fun a₁ b => (g a₁ b) a₂)","decl":"@[simp]\ntheorem sum_apply [Zero M] [AddCommMonoid N] {f : α →₀ M} {g : α → M → β →₀ N} {a₂ : β} :\n    (f.sum g) a₂ = f.sum fun a₁ b => g a₁ b a₂ :=\n  finset_sum_apply _ _ _\n\n"}
{"name":"Finsupp.coe_finset_sum","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nι : Type u_2\nN : Type u_10\ninst✝ : AddCommMonoid N\nS : Finset ι\nf : ι → Finsupp α N\n⊢ Eq (⇑(S.sum fun i => f i)) (S.sum fun i => ⇑(f i))","decl":"@[simp, norm_cast] theorem coe_finset_sum [AddCommMonoid N] (S : Finset ι) (f : ι → α →₀ N) :\n    ⇑(∑ i ∈ S, f i) = ∑ i ∈ S, ⇑(f i) :=\n  map_sum (coeFnAddHom : (α →₀ N) →+ _) _ _\n\n"}
{"name":"Finsupp.coe_sum","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nβ : Type u_7\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : AddCommMonoid N\nf : Finsupp α M\ng : α → M → Finsupp β N\n⊢ Eq (⇑(f.sum g)) (f.sum fun a₁ b => ⇑(g a₁ b))","decl":"@[simp, norm_cast] theorem coe_sum [Zero M] [AddCommMonoid N] (f : α →₀ M) (g : α → M → β →₀ N) :\n    ⇑(f.sum g) = f.sum fun a₁ b => ⇑(g a₁ b) :=\n  coe_finset_sum _ _\n\n"}
{"name":"Finsupp.support_sum","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nβ : Type u_7\nM : Type u_8\nN : Type u_10\ninst✝² : DecidableEq β\ninst✝¹ : Zero M\ninst✝ : AddCommMonoid N\nf : Finsupp α M\ng : α → M → Finsupp β N\n⊢ HasSubset.Subset (f.sum g).support (f.support.biUnion fun a => (g a (f a)).support)","decl":"theorem support_sum [DecidableEq β] [Zero M] [AddCommMonoid N] {f : α →₀ M} {g : α → M → β →₀ N} :\n    (f.sum g).support ⊆ f.support.biUnion fun a => (g a (f a)).support := by\n  have : ∀ c, (f.sum fun a b => g a b c) ≠ 0 → ∃ a, f a ≠ 0 ∧ ¬(g a (f a)) c = 0 := fun a₁ h =>\n    let ⟨a, ha, ne⟩ := Finset.exists_ne_zero_of_sum_ne_zero h\n    ⟨a, mem_support_iff.mp ha, ne⟩\n  simpa only [Finset.subset_iff, mem_support_iff, Finset.mem_biUnion, sum_apply, exists_prop]\n\n"}
{"name":"Finsupp.support_finset_sum","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nβ : Type u_7\nM : Type u_8\ninst✝¹ : DecidableEq β\ninst✝ : AddCommMonoid M\ns : Finset α\nf : α → Finsupp β M\n⊢ HasSubset.Subset (s.sum f).support (s.biUnion fun x => (f x).support)","decl":"theorem support_finset_sum [DecidableEq β] [AddCommMonoid M] {s : Finset α} {f : α → β →₀ M} :\n    (Finset.sum s f).support ⊆ s.biUnion fun x => (f x).support := by\n  rw [← Finset.sup_eq_biUnion]\n  induction s using Finset.cons_induction_on with\n  | h₁ => rfl\n  | h₂ _ ih =>\n    rw [Finset.sum_cons, Finset.sup_cons]\n    exact support_add.trans (Finset.union_subset_union (Finset.Subset.refl _) ih)\n\n"}
{"name":"Finsupp.sum_zero","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : AddCommMonoid N\nf : Finsupp α M\n⊢ Eq (f.sum fun x x => 0) 0","decl":"@[simp]\ntheorem sum_zero [Zero M] [AddCommMonoid N] {f : α →₀ M} : (f.sum fun _ _ => (0 : N)) = 0 :=\n  Finset.sum_const_zero\n\n"}
{"name":"Finsupp.prod_mul","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : CommMonoid N\nf : Finsupp α M\nh₁ h₂ : α → M → N\n⊢ Eq (f.prod fun a b => HMul.hMul (h₁ a b) (h₂ a b)) (HMul.hMul (f.prod h₁) (f.prod h₂))","decl":"@[to_additive (attr := simp)]\ntheorem prod_mul [Zero M] [CommMonoid N] {f : α →₀ M} {h₁ h₂ : α → M → N} :\n    (f.prod fun a b => h₁ a b * h₂ a b) = f.prod h₁ * f.prod h₂ :=\n  Finset.prod_mul_distrib\n\n"}
{"name":"Finsupp.sum_add","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : AddCommMonoid N\nf : Finsupp α M\nh₁ h₂ : α → M → N\n⊢ Eq (f.sum fun a b => HAdd.hAdd (h₁ a b) (h₂ a b)) (HAdd.hAdd (f.sum h₁) (f.sum h₂))","decl":"@[to_additive (attr := simp)]\ntheorem prod_mul [Zero M] [CommMonoid N] {f : α →₀ M} {h₁ h₂ : α → M → N} :\n    (f.prod fun a b => h₁ a b * h₂ a b) = f.prod h₁ * f.prod h₂ :=\n  Finset.prod_mul_distrib\n\n"}
{"name":"Finsupp.sum_neg","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nG : Type u_12\ninst✝¹ : Zero M\ninst✝ : AddCommGroup G\nf : Finsupp α M\nh : α → M → G\n⊢ Eq (f.sum fun a b => Neg.neg (h a b)) (Neg.neg (f.sum h))","decl":"@[to_additive (attr := simp)]\ntheorem prod_inv [Zero M] [CommGroup G] {f : α →₀ M} {h : α → M → G} :\n    (f.prod fun a b => (h a b)⁻¹) = (f.prod h)⁻¹ :=\n  (map_prod (MonoidHom.id G)⁻¹ _ _).symm\n\n"}
{"name":"Finsupp.prod_inv","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nG : Type u_12\ninst✝¹ : Zero M\ninst✝ : CommGroup G\nf : Finsupp α M\nh : α → M → G\n⊢ Eq (f.prod fun a b => Inv.inv (h a b)) (Inv.inv (f.prod h))","decl":"@[to_additive (attr := simp)]\ntheorem prod_inv [Zero M] [CommGroup G] {f : α →₀ M} {h : α → M → G} :\n    (f.prod fun a b => (h a b)⁻¹) = (f.prod h)⁻¹ :=\n  (map_prod (MonoidHom.id G)⁻¹ _ _).symm\n\n"}
{"name":"Finsupp.sum_sub","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nG : Type u_12\ninst✝¹ : Zero M\ninst✝ : AddCommGroup G\nf : Finsupp α M\nh₁ h₂ : α → M → G\n⊢ Eq (f.sum fun a b => HSub.hSub (h₁ a b) (h₂ a b)) (HSub.hSub (f.sum h₁) (f.sum h₂))","decl":"@[simp]\ntheorem sum_sub [Zero M] [AddCommGroup G] {f : α →₀ M} {h₁ h₂ : α → M → G} :\n    (f.sum fun a b => h₁ a b - h₂ a b) = f.sum h₁ - f.sum h₂ :=\n  Finset.sum_sub_distrib\n\n"}
{"name":"Finsupp.prod_add_index","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝² : DecidableEq α\ninst✝¹ : AddZeroClass M\ninst✝ : CommMonoid N\nf g : Finsupp α M\nh : α → M → N\nh_zero : ∀ (a : α), Membership.mem (Union.union f.support g.support) a → Eq (h a 0) 1\nh_add : ∀ (a : α), Membership.mem (Union.union f.support g.support) a → ∀ (b₁ b₂ : M), Eq (h a (HAdd.hAdd b₁ b₂)) (HMul.hMul (h a b₁) (h a b₂))\n⊢ Eq ((HAdd.hAdd f g).prod h) (HMul.hMul (f.prod h) (g.prod h))","decl":"/-- Taking the product under `h` is an additive-to-multiplicative homomorphism of finsupps,\nif `h` is an additive-to-multiplicative homomorphism on the support.\nThis is a more general version of `Finsupp.prod_add_index'`; the latter has simpler hypotheses. -/\n@[to_additive\n      \"Taking the product under `h` is an additive homomorphism of finsupps,  if `h` is an\n      additive homomorphism on the support. This is a more general version of\n      `Finsupp.sum_add_index'`; the latter has simpler hypotheses.\"]\ntheorem prod_add_index [DecidableEq α] [AddZeroClass M] [CommMonoid N] {f g : α →₀ M}\n    {h : α → M → N} (h_zero : ∀ a ∈ f.support ∪ g.support, h a 0 = 1)\n    (h_add : ∀ a ∈ f.support ∪ g.support, ∀ (b₁ b₂), h a (b₁ + b₂) = h a b₁ * h a b₂) :\n    (f + g).prod h = f.prod h * g.prod h := by\n  rw [Finsupp.prod_of_support_subset f subset_union_left h h_zero,\n    Finsupp.prod_of_support_subset g subset_union_right h h_zero, ←\n    Finset.prod_mul_distrib, Finsupp.prod_of_support_subset (f + g) Finsupp.support_add h h_zero]\n  exact Finset.prod_congr rfl fun x hx => by apply h_add x hx\n\n"}
{"name":"Finsupp.sum_add_index","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝² : DecidableEq α\ninst✝¹ : AddZeroClass M\ninst✝ : AddCommMonoid N\nf g : Finsupp α M\nh : α → M → N\nh_zero : ∀ (a : α), Membership.mem (Union.union f.support g.support) a → Eq (h a 0) 0\nh_add : ∀ (a : α), Membership.mem (Union.union f.support g.support) a → ∀ (b₁ b₂ : M), Eq (h a (HAdd.hAdd b₁ b₂)) (HAdd.hAdd (h a b₁) (h a b₂))\n⊢ Eq ((HAdd.hAdd f g).sum h) (HAdd.hAdd (f.sum h) (g.sum h))","decl":"/-- Taking the product under `h` is an additive-to-multiplicative homomorphism of finsupps,\nif `h` is an additive-to-multiplicative homomorphism on the support.\nThis is a more general version of `Finsupp.prod_add_index'`; the latter has simpler hypotheses. -/\n@[to_additive\n      \"Taking the product under `h` is an additive homomorphism of finsupps,  if `h` is an\n      additive homomorphism on the support. This is a more general version of\n      `Finsupp.sum_add_index'`; the latter has simpler hypotheses.\"]\ntheorem prod_add_index [DecidableEq α] [AddZeroClass M] [CommMonoid N] {f g : α →₀ M}\n    {h : α → M → N} (h_zero : ∀ a ∈ f.support ∪ g.support, h a 0 = 1)\n    (h_add : ∀ a ∈ f.support ∪ g.support, ∀ (b₁ b₂), h a (b₁ + b₂) = h a b₁ * h a b₂) :\n    (f + g).prod h = f.prod h * g.prod h := by\n  rw [Finsupp.prod_of_support_subset f subset_union_left h h_zero,\n    Finsupp.prod_of_support_subset g subset_union_right h h_zero, ←\n    Finset.prod_mul_distrib, Finsupp.prod_of_support_subset (f + g) Finsupp.support_add h h_zero]\n  exact Finset.prod_congr rfl fun x hx => by apply h_add x hx\n\n"}
{"name":"Finsupp.sum_add_index'","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : AddZeroClass M\ninst✝ : AddCommMonoid N\nf g : Finsupp α M\nh : α → M → N\nh_zero : ∀ (a : α), Eq (h a 0) 0\nh_add : ∀ (a : α) (b₁ b₂ : M), Eq (h a (HAdd.hAdd b₁ b₂)) (HAdd.hAdd (h a b₁) (h a b₂))\n⊢ Eq ((HAdd.hAdd f g).sum h) (HAdd.hAdd (f.sum h) (g.sum h))","decl":"/-- Taking the product under `h` is an additive-to-multiplicative homomorphism of finsupps,\nif `h` is an additive-to-multiplicative homomorphism.\nThis is a more specialized version of `Finsupp.prod_add_index` with simpler hypotheses. -/\n@[to_additive\n      \"Taking the sum under `h` is an additive homomorphism of finsupps,if `h` is an additive\n      homomorphism. This is a more specific version of `Finsupp.sum_add_index` with simpler\n      hypotheses.\"]\ntheorem prod_add_index' [AddZeroClass M] [CommMonoid N] {f g : α →₀ M} {h : α → M → N}\n    (h_zero : ∀ a, h a 0 = 1) (h_add : ∀ a b₁ b₂, h a (b₁ + b₂) = h a b₁ * h a b₂) :\n    (f + g).prod h = f.prod h * g.prod h := by\n  classical exact prod_add_index (fun a _ => h_zero a) fun a _ => h_add a\n\n"}
{"name":"Finsupp.prod_add_index'","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : AddZeroClass M\ninst✝ : CommMonoid N\nf g : Finsupp α M\nh : α → M → N\nh_zero : ∀ (a : α), Eq (h a 0) 1\nh_add : ∀ (a : α) (b₁ b₂ : M), Eq (h a (HAdd.hAdd b₁ b₂)) (HMul.hMul (h a b₁) (h a b₂))\n⊢ Eq ((HAdd.hAdd f g).prod h) (HMul.hMul (f.prod h) (g.prod h))","decl":"/-- Taking the product under `h` is an additive-to-multiplicative homomorphism of finsupps,\nif `h` is an additive-to-multiplicative homomorphism.\nThis is a more specialized version of `Finsupp.prod_add_index` with simpler hypotheses. -/\n@[to_additive\n      \"Taking the sum under `h` is an additive homomorphism of finsupps,if `h` is an additive\n      homomorphism. This is a more specific version of `Finsupp.sum_add_index` with simpler\n      hypotheses.\"]\ntheorem prod_add_index' [AddZeroClass M] [CommMonoid N] {f g : α →₀ M} {h : α → M → N}\n    (h_zero : ∀ a, h a 0 = 1) (h_add : ∀ a b₁ b₂, h a (b₁ + b₂) = h a b₁ * h a b₂) :\n    (f + g).prod h = f.prod h * g.prod h := by\n  classical exact prod_add_index (fun a _ => h_zero a) fun a _ => h_add a\n\n"}
{"name":"Finsupp.sum_hom_add_index","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : AddZeroClass M\ninst✝ : AddCommMonoid N\nf g : Finsupp α M\nh : α → AddMonoidHom M N\n⊢ Eq ((HAdd.hAdd f g).sum fun x => ⇑(h x)) (HAdd.hAdd (f.sum fun x => ⇑(h x)) (g.sum fun x => ⇑(h x)))","decl":"@[simp]\ntheorem sum_hom_add_index [AddZeroClass M] [AddCommMonoid N] {f g : α →₀ M} (h : α → M →+ N) :\n    ((f + g).sum fun x => h x) = (f.sum fun x => h x) + g.sum fun x => h x :=\n  sum_add_index' (fun a => (h a).map_zero) fun a => (h a).map_add\n\n"}
{"name":"Finsupp.prod_hom_add_index","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : AddZeroClass M\ninst✝ : CommMonoid N\nf g : Finsupp α M\nh : α → MonoidHom (Multiplicative M) N\n⊢ Eq ((HAdd.hAdd f g).prod fun a b => (h a) (Multiplicative.ofAdd b)) (HMul.hMul (f.prod fun a b => (h a) (Multiplicative.ofAdd b)) (g.prod fun a b => (h a) (Multiplicative.ofAdd b)))","decl":"@[simp]\ntheorem prod_hom_add_index [AddZeroClass M] [CommMonoid N] {f g : α →₀ M}\n    (h : α → Multiplicative M →* N) :\n    ((f + g).prod fun a b => h a (Multiplicative.ofAdd b)) =\n      (f.prod fun a b => h a (Multiplicative.ofAdd b)) *\n        g.prod fun a b => h a (Multiplicative.ofAdd b) :=\n  prod_add_index' (fun a => (h a).map_one) fun a => (h a).map_mul\n\n"}
{"name":"Finsupp.liftAddHom_apply","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\nF : α → AddMonoidHom M N\nf : Finsupp α M\n⊢ Eq ((Finsupp.liftAddHom F) f) (f.sum fun x => ⇑(F x))","decl":"@[simp]\ntheorem liftAddHom_apply [AddCommMonoid M] [AddCommMonoid N] (F : α → M →+ N) (f : α →₀ M) :\n    (liftAddHom (α := α) (M := M) (N := N)) F f = f.sum fun x => F x :=\n  rfl\n\n"}
{"name":"Finsupp.liftAddHom_symm_apply","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\nF : AddMonoidHom (Finsupp α M) N\nx : α\n⊢ Eq (Finsupp.liftAddHom.symm F x) (F.comp (Finsupp.singleAddHom x))","decl":"@[simp]\ntheorem liftAddHom_symm_apply [AddCommMonoid M] [AddCommMonoid N] (F : (α →₀ M) →+ N) (x : α) :\n    (liftAddHom (α := α) (M := M) (N := N)).symm F x = F.comp (singleAddHom x) :=\n  rfl\n\n"}
{"name":"Finsupp.liftAddHom_symm_apply_apply","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\nF : AddMonoidHom (Finsupp α M) N\nx : α\ny : M\n⊢ Eq ((Finsupp.liftAddHom.symm F x) y) (F (Finsupp.single x y))","decl":"theorem liftAddHom_symm_apply_apply [AddCommMonoid M] [AddCommMonoid N] (F : (α →₀ M) →+ N) (x : α)\n    (y : M) : (liftAddHom (α := α) (M := M) (N := N)).symm F x y = F (single x y) :=\n  rfl\n\n"}
{"name":"Finsupp.liftAddHom_singleAddHom","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\ninst✝ : AddCommMonoid M\n⊢ Eq (Finsupp.liftAddHom Finsupp.singleAddHom) (AddMonoidHom.id (Finsupp α M))","decl":"@[simp]\ntheorem liftAddHom_singleAddHom [AddCommMonoid M] :\n    (liftAddHom (α := α) (M := M) (N := α →₀ M)) (singleAddHom : α → M →+ α →₀ M) =\n      AddMonoidHom.id _ :=\n  liftAddHom.toEquiv.apply_eq_iff_eq_symm_apply.2 rfl\n\n"}
{"name":"Finsupp.sum_single","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\ninst✝ : AddCommMonoid M\nf : Finsupp α M\n⊢ Eq (f.sum Finsupp.single) f","decl":"@[simp]\ntheorem sum_single [AddCommMonoid M] (f : α →₀ M) : f.sum single = f :=\n  DFunLike.congr_fun liftAddHom_singleAddHom f\n\n"}
{"name":"Finsupp.univ_sum_single","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\ninst✝¹ : Fintype α\ninst✝ : AddCommMonoid M\nf : Finsupp α M\n⊢ Eq (Finset.univ.sum fun a => Finsupp.single a (f a)) f","decl":"/-- The `Finsupp` version of `Finset.univ_sum_single` -/\n@[simp]\ntheorem univ_sum_single [Fintype α] [AddCommMonoid M] (f : α →₀ M) :\n    ∑ a : α, single a (f a) = f := by\n  classical\n  refine DFunLike.coe_injective ?_\n  simp_rw [coe_finset_sum, single_eq_pi_single, Finset.univ_sum_single]\n\n"}
{"name":"Finsupp.univ_sum_single_apply","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\ninst✝¹ : AddCommMonoid M\ninst✝ : Fintype α\ni : α\nm : M\n⊢ Eq (Finset.univ.sum fun j => (Finsupp.single i m) j) m","decl":"@[simp]\ntheorem univ_sum_single_apply [AddCommMonoid M] [Fintype α] (i : α) (m : M) :\n    ∑ j : α, single i m j = m := by\n  classical rw [single, coe_mk, Finset.sum_pi_single']\n  simp\n\n"}
{"name":"Finsupp.univ_sum_single_apply'","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\ninst✝¹ : AddCommMonoid M\ninst✝ : Fintype α\ni : α\nm : M\n⊢ Eq (Finset.univ.sum fun j => (Finsupp.single j m) i) m","decl":"@[simp]\ntheorem univ_sum_single_apply' [AddCommMonoid M] [Fintype α] (i : α) (m : M) :\n    ∑ j : α, single j m i = m := by\n  simp_rw [single, coe_mk]\n  classical rw [Finset.sum_pi_single]\n  simp\n\n\n"}
{"name":"Finsupp.equivFunOnFinite_symm_eq_sum","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\ninst✝¹ : Fintype α\ninst✝ : AddCommMonoid M\nf : α → M\n⊢ Eq (Finsupp.equivFunOnFinite.symm f) (Finset.univ.sum fun a => Finsupp.single a (f a))","decl":"theorem equivFunOnFinite_symm_eq_sum [Fintype α] [AddCommMonoid M] (f : α → M) :\n    equivFunOnFinite.symm f = ∑ a, Finsupp.single a (f a) := by\n  rw [← univ_sum_single (equivFunOnFinite.symm f)]\n  ext\n  simp\n\n"}
{"name":"Finsupp.liftAddHom_apply_single","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\nf : α → AddMonoidHom M N\na : α\nb : M\n⊢ Eq ((Finsupp.liftAddHom f) (Finsupp.single a b)) ((f a) b)","decl":"theorem liftAddHom_apply_single [AddCommMonoid M] [AddCommMonoid N] (f : α → M →+ N) (a : α)\n    (b : M) : (liftAddHom (α := α) (M := M) (N := N)) f (single a b) = f a b :=\n  sum_single_index (f a).map_zero\n\n"}
{"name":"Finsupp.liftAddHom_comp_single","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\nf : α → AddMonoidHom M N\na : α\n⊢ Eq ((Finsupp.liftAddHom f).comp (Finsupp.singleAddHom a)) (f a)","decl":"@[simp]\ntheorem liftAddHom_comp_single [AddCommMonoid M] [AddCommMonoid N] (f : α → M →+ N) (a : α) :\n    ((liftAddHom (α := α) (M := M) (N := N)) f).comp (singleAddHom a) = f a :=\n  AddMonoidHom.ext fun b => liftAddHom_apply_single f a b\n\n"}
{"name":"Finsupp.comp_liftAddHom","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\nP : Type u_11\ninst✝² : AddCommMonoid M\ninst✝¹ : AddCommMonoid N\ninst✝ : AddCommMonoid P\ng : AddMonoidHom N P\nf : α → AddMonoidHom M N\n⊢ Eq (g.comp (Finsupp.liftAddHom f)) (Finsupp.liftAddHom fun a => g.comp (f a))","decl":"theorem comp_liftAddHom [AddCommMonoid M] [AddCommMonoid N] [AddCommMonoid P] (g : N →+ P)\n    (f : α → M →+ N) :\n    g.comp ((liftAddHom (α := α) (M := M) (N := N)) f) =\n      (liftAddHom (α := α) (M := M) (N := P)) fun a => g.comp (f a) :=\n  liftAddHom.symm_apply_eq.1 <|\n    funext fun a => by\n      rw [liftAddHom_symm_apply, AddMonoidHom.comp_assoc, liftAddHom_comp_single]\n\n"}
{"name":"Finsupp.sum_sub_index","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nγ : Type u_3\nβ : Type u_7\ninst✝¹ : AddCommGroup β\ninst✝ : AddCommGroup γ\nf g : Finsupp α β\nh : α → β → γ\nh_sub : ∀ (a : α) (b₁ b₂ : β), Eq (h a (HSub.hSub b₁ b₂)) (HSub.hSub (h a b₁) (h a b₂))\n⊢ Eq ((HSub.hSub f g).sum h) (HSub.hSub (f.sum h) (g.sum h))","decl":"theorem sum_sub_index [AddCommGroup β] [AddCommGroup γ] {f g : α →₀ β} {h : α → β → γ}\n    (h_sub : ∀ a b₁ b₂, h a (b₁ - b₂) = h a b₁ - h a b₂) : (f - g).sum h = f.sum h - g.sum h :=\n  ((liftAddHom (α := α) (M := β) (N := γ)) fun a =>\n    AddMonoidHom.ofMapSub (h a) (h_sub a)).map_sub f g\n\n"}
{"name":"Finsupp.prod_embDomain","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nβ : Type u_7\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : CommMonoid N\nv : Finsupp α M\nf : Function.Embedding α β\ng : β → M → N\n⊢ Eq ((Finsupp.embDomain f v).prod g) (v.prod fun a b => g (f a) b)","decl":"@[to_additive]\ntheorem prod_embDomain [Zero M] [CommMonoid N] {v : α →₀ M} {f : α ↪ β} {g : β → M → N} :\n    (v.embDomain f).prod g = v.prod fun a b => g (f a) b := by\n  rw [prod, prod, support_embDomain, Finset.prod_map]\n  simp_rw [embDomain_apply]\n\n"}
{"name":"Finsupp.sum_embDomain","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nβ : Type u_7\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : AddCommMonoid N\nv : Finsupp α M\nf : Function.Embedding α β\ng : β → M → N\n⊢ Eq ((Finsupp.embDomain f v).sum g) (v.sum fun a b => g (f a) b)","decl":"@[to_additive]\ntheorem prod_embDomain [Zero M] [CommMonoid N] {v : α →₀ M} {f : α ↪ β} {g : β → M → N} :\n    (v.embDomain f).prod g = v.prod fun a b => g (f a) b := by\n  rw [prod, prod, support_embDomain, Finset.prod_map]\n  simp_rw [embDomain_apply]\n\n"}
{"name":"Finsupp.prod_finset_sum_index","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nι : Type u_2\nM : Type u_8\nN : Type u_10\ninst✝¹ : AddCommMonoid M\ninst✝ : CommMonoid N\ns : Finset ι\ng : ι → Finsupp α M\nh : α → M → N\nh_zero : ∀ (a : α), Eq (h a 0) 1\nh_add : ∀ (a : α) (b₁ b₂ : M), Eq (h a (HAdd.hAdd b₁ b₂)) (HMul.hMul (h a b₁) (h a b₂))\n⊢ Eq (s.prod fun i => (g i).prod h) ((s.sum fun i => g i).prod h)","decl":"@[to_additive]\ntheorem prod_finset_sum_index [AddCommMonoid M] [CommMonoid N] {s : Finset ι} {g : ι → α →₀ M}\n    {h : α → M → N} (h_zero : ∀ a, h a 0 = 1) (h_add : ∀ a b₁ b₂, h a (b₁ + b₂) = h a b₁ * h a b₂) :\n    (∏ i ∈ s, (g i).prod h) = (∑ i ∈ s, g i).prod h :=\n  Finset.cons_induction_on s rfl fun a s has ih => by\n    rw [prod_cons, ih, sum_cons, prod_add_index' h_zero h_add]\n\n"}
{"name":"Finsupp.sum_finset_sum_index","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nι : Type u_2\nM : Type u_8\nN : Type u_10\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\ns : Finset ι\ng : ι → Finsupp α M\nh : α → M → N\nh_zero : ∀ (a : α), Eq (h a 0) 0\nh_add : ∀ (a : α) (b₁ b₂ : M), Eq (h a (HAdd.hAdd b₁ b₂)) (HAdd.hAdd (h a b₁) (h a b₂))\n⊢ Eq (s.sum fun i => (g i).sum h) ((s.sum fun i => g i).sum h)","decl":"@[to_additive]\ntheorem prod_finset_sum_index [AddCommMonoid M] [CommMonoid N] {s : Finset ι} {g : ι → α →₀ M}\n    {h : α → M → N} (h_zero : ∀ a, h a 0 = 1) (h_add : ∀ a b₁ b₂, h a (b₁ + b₂) = h a b₁ * h a b₂) :\n    (∏ i ∈ s, (g i).prod h) = (∑ i ∈ s, g i).prod h :=\n  Finset.cons_induction_on s rfl fun a s has ih => by\n    rw [prod_cons, ih, sum_cons, prod_add_index' h_zero h_add]\n\n"}
{"name":"Finsupp.sum_sum_index","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nβ : Type u_7\nM : Type u_8\nN : Type u_10\nP : Type u_11\ninst✝² : AddCommMonoid M\ninst✝¹ : AddCommMonoid N\ninst✝ : AddCommMonoid P\nf : Finsupp α M\ng : α → M → Finsupp β N\nh : β → N → P\nh_zero : ∀ (a : β), Eq (h a 0) 0\nh_add : ∀ (a : β) (b₁ b₂ : N), Eq (h a (HAdd.hAdd b₁ b₂)) (HAdd.hAdd (h a b₁) (h a b₂))\n⊢ Eq ((f.sum g).sum h) (f.sum fun a b => (g a b).sum h)","decl":"@[to_additive]\ntheorem prod_sum_index [AddCommMonoid M] [AddCommMonoid N] [CommMonoid P] {f : α →₀ M}\n    {g : α → M → β →₀ N} {h : β → N → P} (h_zero : ∀ a, h a 0 = 1)\n    (h_add : ∀ a b₁ b₂, h a (b₁ + b₂) = h a b₁ * h a b₂) :\n    (f.sum g).prod h = f.prod fun a b => (g a b).prod h :=\n  (prod_finset_sum_index h_zero h_add).symm\n\n"}
{"name":"Finsupp.prod_sum_index","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nβ : Type u_7\nM : Type u_8\nN : Type u_10\nP : Type u_11\ninst✝² : AddCommMonoid M\ninst✝¹ : AddCommMonoid N\ninst✝ : CommMonoid P\nf : Finsupp α M\ng : α → M → Finsupp β N\nh : β → N → P\nh_zero : ∀ (a : β), Eq (h a 0) 1\nh_add : ∀ (a : β) (b₁ b₂ : N), Eq (h a (HAdd.hAdd b₁ b₂)) (HMul.hMul (h a b₁) (h a b₂))\n⊢ Eq ((f.sum g).prod h) (f.prod fun a b => (g a b).prod h)","decl":"@[to_additive]\ntheorem prod_sum_index [AddCommMonoid M] [AddCommMonoid N] [CommMonoid P] {f : α →₀ M}\n    {g : α → M → β →₀ N} {h : β → N → P} (h_zero : ∀ a, h a 0 = 1)\n    (h_add : ∀ a b₁ b₂, h a (b₁ + b₂) = h a b₁ * h a b₂) :\n    (f.sum g).prod h = f.prod fun a b => (g a b).prod h :=\n  (prod_finset_sum_index h_zero h_add).symm\n\n"}
{"name":"Finsupp.multiset_sum_sum_index","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\nf : Multiset (Finsupp α M)\nh : α → M → N\nh₀ : ∀ (a : α), Eq (h a 0) 0\nh₁ : ∀ (a : α) (b₁ b₂ : M), Eq (h a (HAdd.hAdd b₁ b₂)) (HAdd.hAdd (h a b₁) (h a b₂))\n⊢ Eq (f.sum.sum h) (Multiset.map (fun g => g.sum h) f).sum","decl":"theorem multiset_sum_sum_index [AddCommMonoid M] [AddCommMonoid N] (f : Multiset (α →₀ M))\n    (h : α → M → N) (h₀ : ∀ a, h a 0 = 0)\n    (h₁ : ∀ (a : α) (b₁ b₂ : M), h a (b₁ + b₂) = h a b₁ + h a b₂) :\n    f.sum.sum h = (f.map fun g : α →₀ M => g.sum h).sum :=\n  Multiset.induction_on f rfl fun a s ih => by\n    rw [Multiset.sum_cons, Multiset.map_cons, Multiset.sum_cons, sum_add_index' h₀ h₁, ih]\n\n"}
{"name":"Finsupp.support_sum_eq_biUnion","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_16\nι : Type u_17\nM : Type u_18\ninst✝¹ : DecidableEq α\ninst✝ : AddCommMonoid M\ng : ι → Finsupp α M\ns : Finset ι\nh : ∀ (i₁ i₂ : ι), Ne i₁ i₂ → Disjoint (g i₁).support (g i₂).support\n⊢ Eq (s.sum fun i => g i).support (s.biUnion fun i => (g i).support)","decl":"theorem support_sum_eq_biUnion {α : Type*} {ι : Type*} {M : Type*} [DecidableEq α]\n    [AddCommMonoid M] {g : ι → α →₀ M} (s : Finset ι)\n    (h : ∀ i₁ i₂, i₁ ≠ i₂ → Disjoint (g i₁).support (g i₂).support) :\n    (∑ i ∈ s, g i).support = s.biUnion fun i => (g i).support := by\n  classical\n  refine Finset.induction_on s ?_ ?_\n  · simp\n  · intro i s hi\n    simp only [hi, sum_insert, not_false_iff, biUnion_insert]\n    intro hs\n    rw [Finsupp.support_add_eq, hs]\n    rw [hs, Finset.disjoint_biUnion_right]\n    intro j hj\n    exact h _ _ (ne_of_mem_of_not_mem hj hi).symm\n\n"}
{"name":"Finsupp.multiset_map_sum","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nγ : Type u_3\nβ : Type u_7\nM : Type u_8\ninst✝ : Zero M\nf : Finsupp α M\nm : β → γ\nh : α → M → Multiset β\n⊢ Eq (Multiset.map m (f.sum h)) (f.sum fun a b => Multiset.map m (h a b))","decl":"theorem multiset_map_sum [Zero M] {f : α →₀ M} {m : β → γ} {h : α → M → Multiset β} :\n    Multiset.map m (f.sum h) = f.sum fun a b => (h a b).map m :=\n  map_sum (Multiset.mapAddMonoidHom m) _ f.support\n\n"}
{"name":"Finsupp.multiset_sum_sum","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : AddCommMonoid N\nf : Finsupp α M\nh : α → M → Multiset N\n⊢ Eq (f.sum h).sum (f.sum fun a b => (h a b).sum)","decl":"theorem multiset_sum_sum [Zero M] [AddCommMonoid N] {f : α →₀ M} {h : α → M → Multiset N} :\n    Multiset.sum (f.sum h) = f.sum fun a b => Multiset.sum (h a b) :=\n  map_sum Multiset.sumAddMonoidHom _ f.support\n\n"}
{"name":"Finsupp.prod_add_index_of_disjoint","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\ninst✝¹ : AddCommMonoid M\nf1 f2 : Finsupp α M\nhd : Disjoint f1.support f2.support\nβ : Type u_16\ninst✝ : CommMonoid β\ng : α → M → β\n⊢ Eq ((HAdd.hAdd f1 f2).prod g) (HMul.hMul (f1.prod g) (f2.prod g))","decl":"/-- For disjoint `f1` and `f2`, and function `g`, the product of the products of `g`\nover `f1` and `f2` equals the product of `g` over `f1 + f2` -/\n@[to_additive\n      \"For disjoint `f1` and `f2`, and function `g`, the sum of the sums of `g`\n      over `f1` and `f2` equals the sum of `g` over `f1 + f2`\"]\ntheorem prod_add_index_of_disjoint [AddCommMonoid M] {f1 f2 : α →₀ M}\n    (hd : Disjoint f1.support f2.support) {β : Type*} [CommMonoid β] (g : α → M → β) :\n    (f1 + f2).prod g = f1.prod g * f2.prod g := by\n  have :\n    ∀ {f1 f2 : α →₀ M},\n      Disjoint f1.support f2.support → (∏ x ∈ f1.support, g x (f1 x + f2 x)) = f1.prod g :=\n    fun hd =>\n    Finset.prod_congr rfl fun x hx => by\n      simp only [not_mem_support_iff.mp (disjoint_left.mp hd hx), add_zero]\n  classical simp_rw [← this hd, ← this hd.symm, add_comm (f2 _), Finsupp.prod, support_add_eq hd,\n      prod_union hd, add_apply]\n\n"}
{"name":"Finsupp.sum_add_index_of_disjoint","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\ninst✝¹ : AddCommMonoid M\nf1 f2 : Finsupp α M\nhd : Disjoint f1.support f2.support\nβ : Type u_16\ninst✝ : AddCommMonoid β\ng : α → M → β\n⊢ Eq ((HAdd.hAdd f1 f2).sum g) (HAdd.hAdd (f1.sum g) (f2.sum g))","decl":"/-- For disjoint `f1` and `f2`, and function `g`, the product of the products of `g`\nover `f1` and `f2` equals the product of `g` over `f1 + f2` -/\n@[to_additive\n      \"For disjoint `f1` and `f2`, and function `g`, the sum of the sums of `g`\n      over `f1` and `f2` equals the sum of `g` over `f1 + f2`\"]\ntheorem prod_add_index_of_disjoint [AddCommMonoid M] {f1 f2 : α →₀ M}\n    (hd : Disjoint f1.support f2.support) {β : Type*} [CommMonoid β] (g : α → M → β) :\n    (f1 + f2).prod g = f1.prod g * f2.prod g := by\n  have :\n    ∀ {f1 f2 : α →₀ M},\n      Disjoint f1.support f2.support → (∏ x ∈ f1.support, g x (f1 x + f2 x)) = f1.prod g :=\n    fun hd =>\n    Finset.prod_congr rfl fun x hx => by\n      simp only [not_mem_support_iff.mp (disjoint_left.mp hd hx), add_zero]\n  classical simp_rw [← this hd, ← this hd.symm, add_comm (f2 _), Finsupp.prod, support_add_eq hd,\n      prod_union hd, add_apply]\n\n"}
{"name":"Finsupp.prod_dvd_prod_of_subset_of_dvd","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : AddCommMonoid M\ninst✝ : CommMonoid N\nf1 f2 : Finsupp α M\ng1 g2 : α → M → N\nh1 : HasSubset.Subset f1.support f2.support\nh2 : ∀ (a : α), Membership.mem f1.support a → Dvd.dvd (g1 a (f1 a)) (g2 a (f2 a))\n⊢ Dvd.dvd (f1.prod g1) (f2.prod g2)","decl":"theorem prod_dvd_prod_of_subset_of_dvd [AddCommMonoid M] [CommMonoid N] {f1 f2 : α →₀ M}\n    {g1 g2 : α → M → N} (h1 : f1.support ⊆ f2.support)\n    (h2 : ∀ a : α, a ∈ f1.support → g1 a (f1 a) ∣ g2 a (f2 a)) : f1.prod g1 ∣ f2.prod g2 := by\n  classical\n    simp only [Finsupp.prod, Finsupp.prod_mul]\n    rw [← sdiff_union_of_subset h1, prod_union sdiff_disjoint]\n    apply dvd_mul_of_dvd_right\n    apply prod_dvd_prod_of_dvd\n    exact h2\n\n"}
{"name":"Finsupp.indicator_eq_sum_attach_single","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\ninst✝ : AddCommMonoid M\ns : Finset α\nf : (a : α) → Membership.mem s a → M\n⊢ Eq (Finsupp.indicator s f) (s.attach.sum fun x => Finsupp.single (↑x) (f ↑x ⋯))","decl":"lemma indicator_eq_sum_attach_single [AddCommMonoid M] {s : Finset α} (f : ∀ a ∈ s, M) :\n    indicator s f = ∑ x ∈ s.attach, single ↑x (f x x.2) := by\n  rw [← sum_single (indicator s f), sum, sum_subset (support_indicator_subset _ _), ← sum_attach]\n  · refine Finset.sum_congr rfl (fun _ _ => ?_)\n    rw [indicator_of_mem]\n  · intro i _ hi\n    rw [not_mem_support_iff.mp hi, single_zero]\n\n"}
{"name":"Finsupp.indicator_eq_sum_single","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\ninst✝ : AddCommMonoid M\ns : Finset α\nf : α → M\n⊢ Eq (Finsupp.indicator s fun x x_1 => f x) (s.sum fun x => Finsupp.single x (f x))","decl":"lemma indicator_eq_sum_single [AddCommMonoid M] (s : Finset α) (f : α → M) :\n    indicator s (fun x _ ↦ f x) = ∑ x ∈ s, single x (f x) :=\n  (indicator_eq_sum_attach_single _).trans <| sum_attach _ fun x ↦ single x (f x)\n\n"}
{"name":"Finsupp.prod_indicator_index_eq_prod_attach","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : CommMonoid N\ns : Finset α\nf : (a : α) → Membership.mem s a → M\nh : α → M → N\nh_zero : ∀ (a : α), Membership.mem s a → Eq (h a 0) 1\n⊢ Eq ((Finsupp.indicator s f).prod h) (s.attach.prod fun x => h (↑x) (f ↑x ⋯))","decl":"@[to_additive (attr := simp)]\nlemma prod_indicator_index_eq_prod_attach [Zero M] [CommMonoid N]\n    {s : Finset α} (f : ∀ a ∈ s, M) {h : α → M → N} (h_zero : ∀ a ∈ s, h a 0 = 1) :\n    (indicator s f).prod h = ∏ x ∈ s.attach, h ↑x (f x x.2) := by\n  rw [prod_of_support_subset _ (support_indicator_subset _ _) h h_zero, ← prod_attach]\n  refine Finset.prod_congr rfl (fun _ _ => ?_)\n  rw [indicator_of_mem]\n\n"}
{"name":"Finsupp.sum_indicator_index_eq_sum_attach","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : AddCommMonoid N\ns : Finset α\nf : (a : α) → Membership.mem s a → M\nh : α → M → N\nh_zero : ∀ (a : α), Membership.mem s a → Eq (h a 0) 0\n⊢ Eq ((Finsupp.indicator s f).sum h) (s.attach.sum fun x => h (↑x) (f ↑x ⋯))","decl":"@[to_additive (attr := simp)]\nlemma prod_indicator_index_eq_prod_attach [Zero M] [CommMonoid N]\n    {s : Finset α} (f : ∀ a ∈ s, M) {h : α → M → N} (h_zero : ∀ a ∈ s, h a 0 = 1) :\n    (indicator s f).prod h = ∏ x ∈ s.attach, h ↑x (f x x.2) := by\n  rw [prod_of_support_subset _ (support_indicator_subset _ _) h h_zero, ← prod_attach]\n  refine Finset.prod_congr rfl (fun _ _ => ?_)\n  rw [indicator_of_mem]\n\n"}
{"name":"Finsupp.prod_indicator_index","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : CommMonoid N\ns : Finset α\nf : α → M\nh : α → M → N\nh_zero : ∀ (a : α), Membership.mem s a → Eq (h a 0) 1\n⊢ Eq ((Finsupp.indicator s fun x x_1 => f x).prod h) (s.prod fun x => h x (f x))","decl":"@[to_additive (attr := simp)]\nlemma prod_indicator_index [Zero M] [CommMonoid N]\n    {s : Finset α} (f : α → M) {h : α → M → N} (h_zero : ∀ a ∈ s, h a 0 = 1) :\n    (indicator s (fun x _ ↦ f x)).prod h = ∏ x ∈ s, h x (f x) :=\n  (prod_indicator_index_eq_prod_attach _ h_zero).trans <| prod_attach _ fun x ↦ h x (f x)\n\n"}
{"name":"Finsupp.sum_indicator_index","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : AddCommMonoid N\ns : Finset α\nf : α → M\nh : α → M → N\nh_zero : ∀ (a : α), Membership.mem s a → Eq (h a 0) 0\n⊢ Eq ((Finsupp.indicator s fun x x_1 => f x).sum h) (s.sum fun x => h x (f x))","decl":"@[to_additive (attr := simp)]\nlemma prod_indicator_index [Zero M] [CommMonoid N]\n    {s : Finset α} (f : α → M) {h : α → M → N} (h_zero : ∀ a ∈ s, h a 0 = 1) :\n    (indicator s (fun x _ ↦ f x)).prod h = ∏ x ∈ s, h x (f x) :=\n  (prod_indicator_index_eq_prod_attach _ h_zero).trans <| prod_attach _ fun x ↦ h x (f x)\n\n"}
{"name":"Finsupp.sum_cons","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"M : Type u_8\ninst✝ : AddCommMonoid M\nn : Nat\nσ : Finsupp (Fin n) M\ni : M\n⊢ Eq ((Finsupp.cons i σ).sum fun x e => e) (HAdd.hAdd i (σ.sum fun x e => e))","decl":"lemma sum_cons [AddCommMonoid M] (n : ℕ) (σ : Fin n →₀ M) (i : M) :\n    (sum (cons i σ) fun _ e ↦ e) = i + sum σ (fun _ e ↦ e) := by\n  rw [sum_fintype _ _ (fun _ => rfl), sum_fintype _ _ (fun _ => rfl)]\n  exact Fin.sum_cons i σ\n\n"}
{"name":"Finsupp.sum_cons'","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"M : Type u_8\nN : Type u_10\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\nn : Nat\nσ : Finsupp (Fin n) M\ni : M\nf : Fin (HAdd.hAdd n 1) → M → N\nh : ∀ (x : Fin (HAdd.hAdd n 1)), Eq (f x 0) 0\n⊢ Eq ((Finsupp.cons i σ).sum f) (HAdd.hAdd (f 0 i) (σ.sum (Fin.tail f)))","decl":"lemma sum_cons' [AddCommMonoid M] [AddCommMonoid N] (n : ℕ) (σ : Fin n →₀ M) (i : M)\n    (f : Fin (n+1) → M → N) (h : ∀ x, f x 0 = 0) :\n    (sum (Finsupp.cons i σ) f) = f 0 i + sum σ (Fin.tail f) := by\n  rw [sum_fintype _ _ (fun _ => by apply h), sum_fintype _ _ (fun _ => by apply h)]\n  simp_rw [Fin.sum_univ_succ, cons_zero, cons_succ]\n  congr\n\n"}
{"name":"Finsupp.prod_mul_eq_prod_mul_of_exists","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : CommMonoid N\nf : Finsupp α M\ng : α → M → N\nn₁ n₂ : N\na : α\nha : Membership.mem f.support a\nh : Eq (HMul.hMul (g a (f a)) n₁) (HMul.hMul (g a (f a)) n₂)\n⊢ Eq (HMul.hMul (f.prod g) n₁) (HMul.hMul (f.prod g) n₂)","decl":"@[to_additive]\nlemma prod_mul_eq_prod_mul_of_exists [Zero M] [CommMonoid N]\n    {f : α →₀ M} {g : α → M → N} {n₁ n₂ : N}\n    (a : α) (ha : a ∈ f.support)\n    (h : g a (f a) * n₁ = g a (f a) * n₂) :\n    f.prod g * n₁ = f.prod g * n₂ := by\n  classical\n  exact Finset.prod_mul_eq_prod_mul_of_exists a ha h\n\n"}
{"name":"Finsupp.sum_add_eq_sum_add_of_exists","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nM : Type u_8\nN : Type u_10\ninst✝¹ : Zero M\ninst✝ : AddCommMonoid N\nf : Finsupp α M\ng : α → M → N\nn₁ n₂ : N\na : α\nha : Membership.mem f.support a\nh : Eq (HAdd.hAdd (g a (f a)) n₁) (HAdd.hAdd (g a (f a)) n₂)\n⊢ Eq (HAdd.hAdd (f.sum g) n₁) (HAdd.hAdd (f.sum g) n₂)","decl":"@[to_additive]\nlemma prod_mul_eq_prod_mul_of_exists [Zero M] [CommMonoid N]\n    {f : α →₀ M} {g : α → M → N} {n₁ n₂ : N}\n    (a : α) (ha : a ∈ f.support)\n    (h : g a (f a) * n₁ = g a (f a) * n₂) :\n    f.prod g * n₁ = f.prod g * n₂ := by\n  classical\n  exact Finset.prod_mul_eq_prod_mul_of_exists a ha h\n\n"}
{"name":"Finset.sum_apply'","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nι : Type u_2\nA : Type u_4\ninst✝ : AddCommMonoid A\ns : Finset α\nf : α → Finsupp ι A\ni : ι\n⊢ Eq ((s.sum fun k => f k) i) (s.sum fun k => (f k) i)","decl":"theorem Finset.sum_apply' : (∑ k ∈ s, f k) i = ∑ k ∈ s, f k i :=\n  map_sum (Finsupp.applyAddHom i) f s\n\n"}
{"name":"Finsupp.sum_apply'","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"ι : Type u_2\nγ : Type u_3\nA : Type u_4\nB : Type u_5\ninst✝¹ : AddCommMonoid A\ninst✝ : AddCommMonoid B\ng : Finsupp ι A\nk : ι → A → γ → B\nx : γ\n⊢ Eq (g.sum k x) (g.sum fun i b => k i b x)","decl":"theorem Finsupp.sum_apply' : g.sum k x = g.sum fun i b => k i b x :=\n  Finset.sum_apply _ _ _\n\n"}
{"name":"Finsupp.sum_sum_index'","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nι : Type u_2\nA : Type u_4\nC : Type u_6\ninst✝¹ : AddCommMonoid A\ninst✝ : AddCommMonoid C\nt : ι → A → C\ns : Finset α\nf : α → Finsupp ι A\nh0 : ∀ (i : ι), Eq (t i 0) 0\nh1 : ∀ (i : ι) (x y : A), Eq (t i (HAdd.hAdd x y)) (HAdd.hAdd (t i x) (t i y))\n⊢ Eq ((s.sum fun x => f x).sum t) (s.sum fun x => (f x).sum t)","decl":"theorem Finsupp.sum_sum_index' (h0 : ∀ i, t i 0 = 0) (h1 : ∀ i x y, t i (x + y) = t i x + t i y) :\n    (∑ x ∈ s, f x).sum t = ∑ x ∈ s, (f x).sum t := by\n  classical\n  exact Finset.induction_on s rfl fun a s has ih => by\n    simp_rw [Finset.sum_insert has, Finsupp.sum_add_index' h0 h1, ih]\n\n"}
{"name":"Finsupp.sum_mul","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nR : Type u_14\nS : Type u_15\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\nb : S\ns : Finsupp α R\nf : α → R → S\n⊢ Eq (HMul.hMul (s.sum f) b) (s.sum fun a c => HMul.hMul (f a c) b)","decl":"theorem Finsupp.sum_mul (b : S) (s : α →₀ R) {f : α → R → S} :\n    s.sum f * b = s.sum fun a c => f a c * b := by simp only [Finsupp.sum, Finset.sum_mul]\n\n"}
{"name":"Finsupp.mul_sum","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nR : Type u_14\nS : Type u_15\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\nb : S\ns : Finsupp α R\nf : α → R → S\n⊢ Eq (HMul.hMul b (s.sum f)) (s.sum fun a c => HMul.hMul b (f a c))","decl":"theorem Finsupp.mul_sum (b : S) (s : α →₀ R) {f : α → R → S} :\n    b * s.sum f = s.sum fun a c => b * f a c := by simp only [Finsupp.sum, Finset.mul_sum]\n\n"}
{"name":"Multiset.card_finsuppSum","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"α : Type u_1\nι : Type u_2\nM : Type u_8\ninst✝ : Zero M\nf : Finsupp ι M\ng : ι → M → Multiset α\n⊢ Eq (f.sum g).card (f.sum fun i m => (g i m).card)","decl":"@[simp] lemma Multiset.card_finsuppSum [Zero M] (f : ι →₀ M) (g : ι → M → Multiset α) :\n    card (f.sum g) = f.sum fun i m ↦ card (g i m) := map_finsupp_sum cardHom ..\n\n"}
{"name":"Nat.prod_pow_pos_of_zero_not_mem_support","module":"Mathlib.Algebra.BigOperators.Finsupp","initialProofState":"f : Finsupp Nat Nat\nnhf : Not (Membership.mem f.support 0)\n⊢ LT.lt 0 (f.prod fun x1 x2 => HPow.hPow x1 x2)","decl":"/-- If `0 : ℕ` is not in the support of `f : ℕ →₀ ℕ` then `0 < ∏ x ∈ f.support, x ^ (f x)`. -/\ntheorem prod_pow_pos_of_zero_not_mem_support {f : ℕ →₀ ℕ} (nhf : 0 ∉ f.support) :\n    0 < f.prod (· ^ ·) :=\n  Nat.pos_iff_ne_zero.mpr <| Finset.prod_ne_zero_iff.mpr fun _ hf =>\n    pow_ne_zero _ fun H => by subst H; exact nhf hf\n\n"}
