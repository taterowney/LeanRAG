{"name":"LinearMap.traceAux_def","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nM : Type v\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nι : Type w\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nb : Basis ι R M\nf : LinearMap (RingHom.id R) M M\n⊢ Eq ((LinearMap.traceAux R b) f) ((LinearMap.toMatrix b b) f).trace","decl":"theorem traceAux_def (b : Basis ι R M) (f : M →ₗ[R] M) :\n    traceAux R b f = Matrix.trace (LinearMap.toMatrix b b f) :=\n  rfl\n\n"}
{"name":"LinearMap.traceAux_eq","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u\ninst✝⁶ : CommSemiring R\nM : Type v\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nι : Type w\ninst✝³ : DecidableEq ι\ninst✝² : Fintype ι\nκ : Type u_1\ninst✝¹ : DecidableEq κ\ninst✝ : Fintype κ\nb : Basis ι R M\nc : Basis κ R M\n⊢ Eq (LinearMap.traceAux R b) (LinearMap.traceAux R c)","decl":"theorem traceAux_eq : traceAux R b = traceAux R c :=\n  LinearMap.ext fun f =>\n    calc\n      Matrix.trace (LinearMap.toMatrix b b f) =\n          Matrix.trace (LinearMap.toMatrix b b ((LinearMap.id.comp f).comp LinearMap.id)) := by\n        rw [LinearMap.id_comp, LinearMap.comp_id]\n      _ = Matrix.trace (LinearMap.toMatrix c b LinearMap.id * LinearMap.toMatrix c c f *\n          LinearMap.toMatrix b c LinearMap.id) := by\n        rw [LinearMap.toMatrix_comp _ c, LinearMap.toMatrix_comp _ c]\n      _ = Matrix.trace (LinearMap.toMatrix c c f * LinearMap.toMatrix b c LinearMap.id *\n          LinearMap.toMatrix c b LinearMap.id) := by\n        rw [Matrix.mul_assoc, Matrix.trace_mul_comm]\n      _ = Matrix.trace (LinearMap.toMatrix c c ((f.comp LinearMap.id).comp LinearMap.id)) := by\n        rw [LinearMap.toMatrix_comp _ b, LinearMap.toMatrix_comp _ c]\n      _ = Matrix.trace (LinearMap.toMatrix c c f) := by rw [LinearMap.comp_id, LinearMap.comp_id]\n\n"}
{"name":"LinearMap.trace_eq_matrix_trace_of_finset","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Finset M\nb : Basis (Subtype fun x => Membership.mem s x) R M\nf : LinearMap (RingHom.id R) M M\n⊢ Eq ((LinearMap.trace R M) f) ((LinearMap.toMatrix b b) f).trace","decl":"open Classical in\n/-- Auxiliary lemma for `trace_eq_matrix_trace`. -/\ntheorem trace_eq_matrix_trace_of_finset {s : Finset M} (b : Basis s R M) (f : M →ₗ[R] M) :\n    trace R M f = Matrix.trace (LinearMap.toMatrix b b f) := by\n  have : ∃ s : Finset M, Nonempty (Basis s R M) := ⟨s, ⟨b⟩⟩\n  rw [trace, dif_pos this, ← traceAux_def]\n  congr 1\n  apply traceAux_eq\n\n"}
{"name":"LinearMap.trace_eq_matrix_trace","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nM : Type v\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nι : Type w\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nb : Basis ι R M\nf : LinearMap (RingHom.id R) M M\n⊢ Eq ((LinearMap.trace R M) f) ((LinearMap.toMatrix b b) f).trace","decl":"theorem trace_eq_matrix_trace (f : M →ₗ[R] M) :\n    trace R M f = Matrix.trace (LinearMap.toMatrix b b f) := by\n  classical\n  rw [trace_eq_matrix_trace_of_finset R b.reindexFinsetRange, ← traceAux_def, ← traceAux_def,\n    traceAux_eq R b b.reindexFinsetRange]\n\n"}
{"name":"LinearMap.trace_mul_comm","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf g : LinearMap (RingHom.id R) M M\n⊢ Eq ((LinearMap.trace R M) (HMul.hMul f g)) ((LinearMap.trace R M) (HMul.hMul g f))","decl":"theorem trace_mul_comm (f g : M →ₗ[R] M) : trace R M (f * g) = trace R M (g * f) := by\n  classical\n  by_cases H : ∃ s : Finset M, Nonempty (Basis s R M)\n  · let ⟨s, ⟨b⟩⟩ := H\n    simp_rw [trace_eq_matrix_trace R b, LinearMap.toMatrix_mul]\n    apply Matrix.trace_mul_comm\n  · rw [trace, dif_neg H, LinearMap.zero_apply, LinearMap.zero_apply]\n\n"}
{"name":"LinearMap.trace_mul_cycle","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf g h : LinearMap (RingHom.id R) M M\n⊢ Eq ((LinearMap.trace R M) (HMul.hMul (HMul.hMul f g) h)) ((LinearMap.trace R M) (HMul.hMul (HMul.hMul h f) g))","decl":"lemma trace_mul_cycle (f g h : M →ₗ[R] M) :\n    trace R M (f * g * h) = trace R M (h * f * g) := by\n  rw [LinearMap.trace_mul_comm, ← mul_assoc]\n\n"}
{"name":"LinearMap.trace_mul_cycle'","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf g h : LinearMap (RingHom.id R) M M\n⊢ Eq ((LinearMap.trace R M) (HMul.hMul f (HMul.hMul g h))) ((LinearMap.trace R M) (HMul.hMul h (HMul.hMul f g)))","decl":"lemma trace_mul_cycle' (f g h : M →ₗ[R] M) :\n    trace R M (f * (g * h)) = trace R M (h * (f * g)) := by\n  rw [← mul_assoc, LinearMap.trace_mul_comm]\n\n"}
{"name":"LinearMap.trace_conj","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ng : LinearMap (RingHom.id R) M M\nf : Units (LinearMap (RingHom.id R) M M)\n⊢ Eq ((LinearMap.trace R M) (HMul.hMul (HMul.hMul (↑f) g) ↑(Inv.inv f))) ((LinearMap.trace R M) g)","decl":"/-- The trace of an endomorphism is invariant under conjugation -/\n@[simp]\ntheorem trace_conj (g : M →ₗ[R] M) (f : (M →ₗ[R] M)ˣ) :\n    trace R M (↑f * g * ↑f⁻¹) = trace R M g := by\n  rw [trace_mul_comm]\n  simp\n\n"}
{"name":"LinearMap.trace_lie","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf g : Module.End R M\n⊢ Eq ((LinearMap.trace R M) (Bracket.bracket f g)) 0","decl":"@[simp]\nlemma trace_lie {R M : Type*} [CommRing R] [AddCommGroup M] [Module R M] (f g : Module.End R M) :\n    trace R M ⁅f, g⁆ = 0 := by\n  rw [Ring.lie_def, map_sub, trace_mul_comm]\n  exact sub_self _\n\n"}
{"name":"LinearMap.trace_eq_contract_of_basis","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nι : Type u_5\ninst✝ : Finite ι\nb : Basis ι R M\n⊢ Eq ((LinearMap.trace R M).comp (dualTensorHom R M M)) (contractLeft R M)","decl":"/-- The trace of a linear map correspond to the contraction pairing under the isomorphism\n `End(M) ≃ M* ⊗ M`-/\ntheorem trace_eq_contract_of_basis [Finite ι] (b : Basis ι R M) :\n    LinearMap.trace R M ∘ₗ dualTensorHom R M M = contractLeft R M := by\n  classical\n    cases nonempty_fintype ι\n    apply Basis.ext (Basis.tensorProduct (Basis.dualBasis b) b)\n    rintro ⟨i, j⟩\n    simp only [Function.comp_apply, Basis.tensorProduct_apply, Basis.coe_dualBasis, coe_comp]\n    rw [trace_eq_matrix_trace R b, toMatrix_dualTensorHom]\n    by_cases hij : i = j\n    · rw [hij]\n      simp\n    rw [Matrix.StdBasisMatrix.trace_zero j i (1 : R) hij]\n    simp [Finsupp.single_eq_pi_single, hij]\n\n"}
{"name":"LinearMap.trace_eq_contract_of_basis'","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_5\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nb : Basis ι R M\n⊢ Eq (LinearMap.trace R M) ((contractLeft R M).comp ↑(dualTensorHomEquivOfBasis b).symm)","decl":"/-- The trace of a linear map correspond to the contraction pairing under the isomorphism\n `End(M) ≃ M* ⊗ M`-/\ntheorem trace_eq_contract_of_basis' [Fintype ι] [DecidableEq ι] (b : Basis ι R M) :\n    LinearMap.trace R M = contractLeft R M ∘ₗ (dualTensorHomEquivOfBasis b).symm.toLinearMap := by\n  simp [LinearEquiv.eq_comp_toLinearMap_symm, trace_eq_contract_of_basis b]\n\n"}
{"name":"LinearMap.trace_eq_contract","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\n⊢ Eq ((LinearMap.trace R M).comp (dualTensorHom R M M)) (contractLeft R M)","decl":"/-- When `M` is finite free, the trace of a linear map correspond to the contraction pairing under\nthe isomorphism `End(M) ≃ M* ⊗ M`-/\n@[simp]\ntheorem trace_eq_contract : LinearMap.trace R M ∘ₗ dualTensorHom R M M = contractLeft R M :=\n  trace_eq_contract_of_basis (Module.Free.chooseBasis R M)\n\n"}
{"name":"LinearMap.trace_eq_contract_apply","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\nx : TensorProduct R (Module.Dual R M) M\n⊢ Eq ((LinearMap.trace R M) ((dualTensorHom R M M) x)) ((contractLeft R M) x)","decl":"@[simp]\ntheorem trace_eq_contract_apply (x : Module.Dual R M ⊗[R] M) :\n    (LinearMap.trace R M) ((dualTensorHom R M M) x) = contractLeft R M x := by\n  rw [← comp_apply, trace_eq_contract]\n\n"}
{"name":"LinearMap.trace_eq_contract'","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\n⊢ Eq (LinearMap.trace R M) ((contractLeft R M).comp ↑(dualTensorHomEquiv R M M).symm)","decl":"/-- When `M` is finite free, the trace of a linear map correspond to the contraction pairing under\nthe isomorphism `End(M) ≃ M* ⊗ M`-/\ntheorem trace_eq_contract' :\n    LinearMap.trace R M = contractLeft R M ∘ₗ (dualTensorHomEquiv R M M).symm.toLinearMap :=\n  trace_eq_contract_of_basis' (Module.Free.chooseBasis R M)\n\n"}
{"name":"LinearMap.trace_one","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\n⊢ Eq ((LinearMap.trace R M) 1) ↑(Module.finrank R M)","decl":"/-- The trace of the identity endomorphism is the dimension of the free module -/\n@[simp]\ntheorem trace_one : trace R M 1 = (finrank R M : R) := by\n  cases subsingleton_or_nontrivial R\n  · simp [eq_iff_true_of_subsingleton]\n  have b := Module.Free.chooseBasis R M\n  rw [trace_eq_matrix_trace R b, toMatrix_one, finrank_eq_card_chooseBasisIndex]\n  simp\n\n"}
{"name":"LinearMap.trace_id","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\n⊢ Eq ((LinearMap.trace R M) LinearMap.id) ↑(Module.finrank R M)","decl":"/-- The trace of the identity endomorphism is the dimension of the free module -/\n@[simp]\ntheorem trace_id : trace R M id = (finrank R M : R) := by rw [← one_eq_id, trace_one]\n\n"}
{"name":"LinearMap.trace_transpose","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\n⊢ Eq ((LinearMap.trace R (Module.Dual R M)).comp Module.Dual.transpose) (LinearMap.trace R M)","decl":"@[simp]\ntheorem trace_transpose : trace R (Module.Dual R M) ∘ₗ Module.Dual.transpose = trace R M := by\n  let e := dualTensorHomEquiv R M M\n  have h : Function.Surjective e.toLinearMap := e.surjective\n  refine (cancel_right h).1 ?_\n  ext f m; simp [e]\n\n"}
{"name":"LinearMap.trace_prodMap","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u_1\ninst✝⁸ : CommRing R\nM : Type u_2\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nN : Type u_3\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\ninst✝³ : Module.Free R M\ninst✝² : Module.Finite R M\ninst✝¹ : Module.Free R N\ninst✝ : Module.Finite R N\n⊢ Eq ((LinearMap.trace R (Prod M N)).comp (LinearMap.prodMapLinear R M N M N R)) ((LinearMap.id.coprod LinearMap.id).comp ((LinearMap.trace R M).prodMap (LinearMap.trace R N)))","decl":"theorem trace_prodMap :\n    trace R (M × N) ∘ₗ prodMapLinear R M N M N R =\n      (coprod id id : R × R →ₗ[R] R) ∘ₗ prodMap (trace R M) (trace R N) := by\n  let e := (dualTensorHomEquiv R M M).prod (dualTensorHomEquiv R N N)\n  have h : Function.Surjective e.toLinearMap := e.surjective\n  refine (cancel_right h).1 ?_\n  ext\n  · simp only [e, dualTensorHomEquiv, LinearEquiv.coe_prod, dualTensorHomEquivOfBasis_toLinearMap,\n      AlgebraTensorModule.curry_apply, curry_apply, coe_restrictScalars, coe_comp, coe_inl,\n      Function.comp_apply, prodMap_apply, map_zero, prodMapLinear_apply, dualTensorHom_prodMap_zero,\n      trace_eq_contract_apply, contractLeft_apply, fst_apply, coprod_apply, id_coe, id_eq, add_zero]\n  · simp only [e, dualTensorHomEquiv, LinearEquiv.coe_prod, dualTensorHomEquivOfBasis_toLinearMap,\n      AlgebraTensorModule.curry_apply, curry_apply, coe_restrictScalars, coe_comp, coe_inr,\n      Function.comp_apply, prodMap_apply, map_zero, prodMapLinear_apply, zero_prodMap_dualTensorHom,\n      trace_eq_contract_apply, contractLeft_apply, snd_apply, coprod_apply, id_coe, id_eq, zero_add]\n\n"}
{"name":"LinearMap.trace_prodMap'","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u_1\ninst✝⁸ : CommRing R\nM : Type u_2\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nN : Type u_3\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\ninst✝³ : Module.Free R M\ninst✝² : Module.Finite R M\ninst✝¹ : Module.Free R N\ninst✝ : Module.Finite R N\nf : LinearMap (RingHom.id R) M M\ng : LinearMap (RingHom.id R) N N\n⊢ Eq ((LinearMap.trace R (Prod M N)) (f.prodMap g)) (HAdd.hAdd ((LinearMap.trace R M) f) ((LinearMap.trace R N) g))","decl":"theorem trace_prodMap' (f : M →ₗ[R] M) (g : N →ₗ[R] N) :\n    trace R (M × N) (prodMap f g) = trace R M f + trace R N g := by\n  have h := LinearMap.ext_iff.1 (trace_prodMap R M N) (f, g)\n  simp only [coe_comp, Function.comp_apply, prodMap_apply, coprod_apply, id_coe, id,\n    prodMapLinear_apply] at h\n  exact h\n\n"}
{"name":"LinearMap.trace_tensorProduct","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u_1\ninst✝⁸ : CommRing R\nM : Type u_2\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nN : Type u_3\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\ninst✝³ : Module.Free R M\ninst✝² : Module.Finite R M\ninst✝¹ : Module.Free R N\ninst✝ : Module.Finite R N\n⊢ Eq ((TensorProduct.mapBilinear R M N M N).compr₂ (LinearMap.trace R (TensorProduct R M N))) ((LinearMap.lsmul R R).compl₁₂ (LinearMap.trace R M) (LinearMap.trace R N))","decl":"theorem trace_tensorProduct : compr₂ (mapBilinear R M N M N) (trace R (M ⊗ N)) =\n    compl₁₂ (lsmul R R : R →ₗ[R] R →ₗ[R] R) (trace R M) (trace R N) := by\n  apply\n    (compl₁₂_inj (show Surjective (dualTensorHom R M M) from (dualTensorHomEquiv R M M).surjective)\n        (show Surjective (dualTensorHom R N N) from (dualTensorHomEquiv R N N).surjective)).1\n  ext f m g n\n  simp only [AlgebraTensorModule.curry_apply, toFun_eq_coe, TensorProduct.curry_apply,\n    coe_restrictScalars, compl₁₂_apply, compr₂_apply, mapBilinear_apply,\n    trace_eq_contract_apply, contractLeft_apply, lsmul_apply, Algebra.id.smul_eq_mul,\n    map_dualTensorHom, dualDistrib_apply]\n\n"}
{"name":"LinearMap.trace_comp_comm","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u_1\ninst✝⁸ : CommRing R\nM : Type u_2\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nN : Type u_3\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\ninst✝³ : Module.Free R M\ninst✝² : Module.Finite R M\ninst✝¹ : Module.Free R N\ninst✝ : Module.Finite R N\n⊢ Eq ((LinearMap.llcomp R M N M).compr₂ (LinearMap.trace R M)) ((LinearMap.llcomp R N M N).flip.compr₂ (LinearMap.trace R N))","decl":"theorem trace_comp_comm :\n    compr₂ (llcomp R M N M) (trace R M) = compr₂ (llcomp R N M N).flip (trace R N) := by\n  apply\n    (compl₁₂_inj (show Surjective (dualTensorHom R N M) from (dualTensorHomEquiv R N M).surjective)\n        (show Surjective (dualTensorHom R M N) from (dualTensorHomEquiv R M N).surjective)).1\n  ext g m f n\n  simp only [AlgebraTensorModule.curry_apply, TensorProduct.curry_apply,\n    coe_restrictScalars, compl₁₂_apply, compr₂_apply, flip_apply, llcomp_apply',\n    comp_dualTensorHom, LinearMapClass.map_smul, trace_eq_contract_apply,\n    contractLeft_apply, smul_eq_mul, mul_comm]\n\n"}
{"name":"LinearMap.trace_transpose'","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\nf : LinearMap (RingHom.id R) M M\n⊢ Eq ((LinearMap.trace R (Module.Dual R M)) (Module.Dual.transpose f)) ((LinearMap.trace R M) f)","decl":"@[simp]\ntheorem trace_transpose' (f : M →ₗ[R] M) :\n    trace R _ (Module.Dual.transpose (R := R) f) = trace R M f := by\n  rw [← comp_apply, trace_transpose]\n\n"}
{"name":"LinearMap.trace_tensorProduct'","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u_1\ninst✝⁸ : CommRing R\nM : Type u_2\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nN : Type u_3\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\ninst✝³ : Module.Free R M\ninst✝² : Module.Finite R M\ninst✝¹ : Module.Free R N\ninst✝ : Module.Finite R N\nf : LinearMap (RingHom.id R) M M\ng : LinearMap (RingHom.id R) N N\n⊢ Eq ((LinearMap.trace R (TensorProduct R M N)) (TensorProduct.map f g)) (HMul.hMul ((LinearMap.trace R M) f) ((LinearMap.trace R N) g))","decl":"theorem trace_tensorProduct' (f : M →ₗ[R] M) (g : N →ₗ[R] N) :\n    trace R (M ⊗ N) (map f g) = trace R M f * trace R N g := by\n  have h := LinearMap.ext_iff.1 (LinearMap.ext_iff.1 (trace_tensorProduct R M N) f) g\n  simp only [compr₂_apply, mapBilinear_apply, compl₁₂_apply, lsmul_apply,\n    Algebra.id.smul_eq_mul] at h\n  exact h\n\n"}
{"name":"LinearMap.trace_comp_comm'","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u_1\ninst✝⁸ : CommRing R\nM : Type u_2\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nN : Type u_3\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\ninst✝³ : Module.Free R M\ninst✝² : Module.Finite R M\ninst✝¹ : Module.Free R N\ninst✝ : Module.Finite R N\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N M\n⊢ Eq ((LinearMap.trace R M) (g.comp f)) ((LinearMap.trace R N) (f.comp g))","decl":"theorem trace_comp_comm' (f : M →ₗ[R] N) (g : N →ₗ[R] M) :\n    trace R M (g ∘ₗ f) = trace R N (f ∘ₗ g) := by\n  have h := LinearMap.ext_iff.1 (LinearMap.ext_iff.1 (trace_comp_comm R M N) g) f\n  simp only [llcomp_apply', compr₂_apply, flip_apply] at h\n  exact h\n\n"}
{"name":"LinearMap.trace_comp_cycle","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommRing R\nM : Type u_2\ninst✝⁹ : AddCommGroup M\ninst✝⁸ : Module R M\nN : Type u_3\nP : Type u_4\ninst✝⁷ : AddCommGroup N\ninst✝⁶ : Module R N\ninst✝⁵ : AddCommGroup P\ninst✝⁴ : Module R P\ninst✝³ : Module.Free R N\ninst✝² : Module.Finite R N\ninst✝¹ : Module.Free R P\ninst✝ : Module.Finite R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nh : LinearMap (RingHom.id R) P M\n⊢ Eq ((LinearMap.trace R P) (g.comp (f.comp h))) ((LinearMap.trace R N) (f.comp (h.comp g)))","decl":"variable [Module.Free R N] [Module.Finite R N] [Module.Free R P] [Module.Finite R P] in\nlemma trace_comp_cycle (f : M →ₗ[R] N) (g : N →ₗ[R] P) (h : P →ₗ[R] M) :\n    trace R P (g ∘ₗ f ∘ₗ h) = trace R N (f ∘ₗ h ∘ₗ g) := by\n  rw [trace_comp_comm', comp_assoc]\n\n"}
{"name":"LinearMap.trace_comp_cycle'","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommRing R\nM : Type u_2\ninst✝⁹ : AddCommGroup M\ninst✝⁸ : Module R M\nN : Type u_3\nP : Type u_4\ninst✝⁷ : AddCommGroup N\ninst✝⁶ : Module R N\ninst✝⁵ : AddCommGroup P\ninst✝⁴ : Module R P\ninst✝³ : Module.Free R M\ninst✝² : Module.Finite R M\ninst✝¹ : Module.Free R P\ninst✝ : Module.Finite R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nh : LinearMap (RingHom.id R) P M\n⊢ Eq ((LinearMap.trace R P) ((g.comp f).comp h)) ((LinearMap.trace R M) ((h.comp g).comp f))","decl":"variable [Module.Free R M] [Module.Finite R M] [Module.Free R P] [Module.Finite R P] in\nlemma trace_comp_cycle' (f : M →ₗ[R] N) (g : N →ₗ[R] P) (h : P →ₗ[R] M) :\n    trace R P ((g ∘ₗ f) ∘ₗ h) = trace R M ((h ∘ₗ g) ∘ₗ f) := by\n  rw [trace_comp_comm', ← comp_assoc]\n\n"}
{"name":"LinearMap.trace_conj'","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M M\ne : LinearEquiv (RingHom.id R) M N\n⊢ Eq ((LinearMap.trace R N) (e.conj f)) ((LinearMap.trace R M) f)","decl":"@[simp]\ntheorem trace_conj' (f : M →ₗ[R] M) (e : M ≃ₗ[R] N) : trace R N (e.conj f) = trace R M f := by\n  classical\n  by_cases hM : ∃ s : Finset M, Nonempty (Basis s R M)\n  · obtain ⟨s, ⟨b⟩⟩ := hM\n    haveI := Module.Finite.of_basis b\n    haveI := (Module.free_def R M).mpr ⟨_, ⟨b⟩⟩\n    haveI := Module.Finite.of_basis (b.map e)\n    haveI := (Module.free_def R N).mpr ⟨_, ⟨(b.map e).reindex (e.toEquiv.image _)⟩⟩\n    rw [e.conj_apply, trace_comp_comm', ← comp_assoc, LinearEquiv.comp_coe,\n      LinearEquiv.self_trans_symm, LinearEquiv.refl_toLinearMap, id_comp]\n  · rw [trace, trace, dif_neg hM, dif_neg ?_, zero_apply, zero_apply]\n    rintro ⟨s, ⟨b⟩⟩\n    exact hM ⟨s.image e.symm, ⟨(b.map e.symm).reindex\n      ((e.symm.toEquiv.image s).trans (Equiv.Set.ofEq Finset.coe_image.symm))⟩⟩\n\n"}
{"name":"LinearMap.IsProj.trace","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nM : Type u_2\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\np : Submodule R M\nf : LinearMap (RingHom.id R) M M\nh : LinearMap.IsProj p f\ninst✝³ : Module.Free R (Subtype fun x => Membership.mem p x)\ninst✝² : Module.Finite R (Subtype fun x => Membership.mem p x)\ninst✝¹ : Module.Free R (Subtype fun x => Membership.mem (LinearMap.ker f) x)\ninst✝ : Module.Finite R (Subtype fun x => Membership.mem (LinearMap.ker f) x)\n⊢ Eq ((LinearMap.trace R M) f) ↑(Module.finrank R (Subtype fun x => Membership.mem p x))","decl":"theorem IsProj.trace {p : Submodule R M} {f : M →ₗ[R] M} (h : IsProj p f) [Module.Free R p]\n    [Module.Finite R p] [Module.Free R (ker f)] [Module.Finite R (ker f)] :\n    trace R M f = (finrank R p : R) := by\n  rw [h.eq_conj_prodMap, trace_conj', trace_prodMap', trace_id, map_zero, add_zero]\n\n"}
{"name":"LinearMap.isNilpotent_trace_of_isNilpotent","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : LinearMap (RingHom.id R) M M\nhf : IsNilpotent f\n⊢ IsNilpotent ((LinearMap.trace R M) f)","decl":"lemma isNilpotent_trace_of_isNilpotent {f : M →ₗ[R] M} (hf : IsNilpotent f) :\n    IsNilpotent (trace R M f) := by\n  by_cases H : ∃ s : Finset M, Nonempty (Basis s R M)\n  swap\n  · rw [LinearMap.trace, dif_neg H]\n    exact IsNilpotent.zero\n  obtain ⟨s, ⟨b⟩⟩ := H\n  classical\n  rw [trace_eq_matrix_trace R b]\n  apply Matrix.isNilpotent_trace_of_isNilpotent\n  simpa\n\n"}
{"name":"LinearMap.trace_comp_eq_mul_of_commute_of_isNilpotent","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsReduced R\nf g : Module.End R M\nμ : R\nh_comm : Commute f g\nhg : IsNilpotent (HSub.hSub g ((algebraMap R (Module.End R M)) μ))\n⊢ Eq ((LinearMap.trace R M) (LinearMap.comp f g)) (HMul.hMul μ ((LinearMap.trace R M) f))","decl":"lemma trace_comp_eq_mul_of_commute_of_isNilpotent [IsReduced R] {f g : Module.End R M}\n    (μ : R) (h_comm : Commute f g) (hg : IsNilpotent (g - algebraMap R _ μ)) :\n    trace R M (f ∘ₗ g) = μ * trace R M f := by\n  set n := g - algebraMap R _ μ\n  replace hg : trace R M (f ∘ₗ n) = 0 := by\n    rw [← isNilpotent_iff_eq_zero, ← mul_eq_comp]\n    refine isNilpotent_trace_of_isNilpotent (Commute.isNilpotent_mul_right ?_ hg)\n    exact h_comm.sub_right (Algebra.commute_algebraMap_right μ f)\n  have hμ : g = algebraMap R _ μ + n := eq_add_of_sub_eq' rfl\n  have : f ∘ₗ algebraMap R _ μ = μ • f := by ext; simp -- TODO Surely exists?\n  rw [hμ, comp_add, map_add, hg, add_zero, this, LinearMap.map_smul, smul_eq_mul]\n\n-- This result requires `Mathlib.RingTheory.TensorProduct.Free`. Maybe it should move elsewhere?\n"}
{"name":"LinearMap.trace_baseChange","module":"Mathlib.LinearAlgebra.Trace","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nM : Type u_2\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : Module.Free R M\ninst✝² : Module.Finite R M\nf : LinearMap (RingHom.id R) M M\nA : Type u_6\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ Eq ((LinearMap.trace A (TensorProduct R A M)) (LinearMap.baseChange A f)) ((algebraMap R A) ((LinearMap.trace R M) f))","decl":"@[simp]\nlemma trace_baseChange [Module.Free R M] [Module.Finite R M]\n    (f : M →ₗ[R] M) (A : Type*) [CommRing A] [Algebra R A] :\n    trace A _ (f.baseChange A) = algebraMap R A (trace R _ f) := by\n  let b := Module.Free.chooseBasis R M\n  let b' := Algebra.TensorProduct.basis A b\n  change _ = (algebraMap R A : R →+ A) _\n  simp [b', trace_eq_matrix_trace R b, trace_eq_matrix_trace A b', AddMonoidHom.map_trace]\n\n"}
