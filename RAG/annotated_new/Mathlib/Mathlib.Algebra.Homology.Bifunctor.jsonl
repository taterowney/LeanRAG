{"name":"CategoryTheory.Functor.mapBifunctorHomologicalComplexObj_obj_X_d","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝⁴ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝³ : CategoryTheory.Category.{u_9, u_3} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\nI₁ : Type u_4\nI₂ : Type u_5\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\ni₁ : I₁\ni₂ i₂' : I₂\n⊢ Eq ((((F.mapBifunctorHomologicalComplexObj c₂ K₁).obj K₂).X i₁).d i₂ i₂') ((F.obj (K₁.X i₁)).map (K₂.d i₂ i₂'))","decl":"variable {c₁} in\n/-- Auxiliary definition for `mapBifunctorHomologicalComplex`. -/\n@[simps!]\ndef mapBifunctorHomologicalComplexObj (K₁ : HomologicalComplex C₁ c₁) :\n    HomologicalComplex C₂ c₂ ⥤ HomologicalComplex₂ D c₁ c₂ where\n  obj K₂ := HomologicalComplex₂.ofGradedObject c₁ c₂\n      (((GradedObject.mapBifunctor F I₁ I₂).obj K₁.X).obj K₂.X)\n      (fun i₁ i₁' i₂ => (F.map (K₁.d i₁ i₁')).app (K₂.X i₂))\n      (fun i₁ i₂ i₂' => (F.obj (K₁.X i₁)).map (K₂.d i₂ i₂'))\n      (fun i₁ i₁' h₁ i₂ => by\n        dsimp\n        rw [K₁.shape _ _ h₁, Functor.map_zero, zero_app])\n      (fun i₁ i₂ i₂' h₂ => by\n        dsimp\n        rw [K₂.shape _ _ h₂, Functor.map_zero])\n      (fun i₁ i₁' i₁'' i₂ => by\n        dsimp\n        rw [← NatTrans.comp_app, ← Functor.map_comp, HomologicalComplex.d_comp_d,\n          Functor.map_zero, zero_app])\n      (fun i₁ i₂ i₂' i₂'' => by\n        dsimp\n        rw [← Functor.map_comp, HomologicalComplex.d_comp_d, Functor.map_zero])\n      (fun i₁ i₁' i₂ i₂' => by\n        dsimp\n        rw [NatTrans.naturality])\n  map {K₂ K₂' φ} := HomologicalComplex₂.homMk\n      (((GradedObject.mapBifunctor F I₁ I₂).obj K₁.X).map φ.f)\n        (by dsimp; intros; rw [NatTrans.naturality]) (by\n          dsimp\n          intros\n          simp only [← Functor.map_comp, φ.comm])\n  map_id K₂ := by dsimp; ext; dsimp; rw [Functor.map_id]\n  map_comp f g := by dsimp; ext; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Functor.mapBifunctorHomologicalComplexObj_obj_X_X","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝⁴ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝³ : CategoryTheory.Category.{u_9, u_3} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\nI₁ : Type u_4\nI₂ : Type u_5\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\ni₁ : I₁\ni₂ : I₂\n⊢ Eq ((((F.mapBifunctorHomologicalComplexObj c₂ K₁).obj K₂).X i₁).X i₂) ((F.obj (K₁.X i₁)).obj (K₂.X i₂))","decl":"variable {c₁} in\n/-- Auxiliary definition for `mapBifunctorHomologicalComplex`. -/\n@[simps!]\ndef mapBifunctorHomologicalComplexObj (K₁ : HomologicalComplex C₁ c₁) :\n    HomologicalComplex C₂ c₂ ⥤ HomologicalComplex₂ D c₁ c₂ where\n  obj K₂ := HomologicalComplex₂.ofGradedObject c₁ c₂\n      (((GradedObject.mapBifunctor F I₁ I₂).obj K₁.X).obj K₂.X)\n      (fun i₁ i₁' i₂ => (F.map (K₁.d i₁ i₁')).app (K₂.X i₂))\n      (fun i₁ i₂ i₂' => (F.obj (K₁.X i₁)).map (K₂.d i₂ i₂'))\n      (fun i₁ i₁' h₁ i₂ => by\n        dsimp\n        rw [K₁.shape _ _ h₁, Functor.map_zero, zero_app])\n      (fun i₁ i₂ i₂' h₂ => by\n        dsimp\n        rw [K₂.shape _ _ h₂, Functor.map_zero])\n      (fun i₁ i₁' i₁'' i₂ => by\n        dsimp\n        rw [← NatTrans.comp_app, ← Functor.map_comp, HomologicalComplex.d_comp_d,\n          Functor.map_zero, zero_app])\n      (fun i₁ i₂ i₂' i₂'' => by\n        dsimp\n        rw [← Functor.map_comp, HomologicalComplex.d_comp_d, Functor.map_zero])\n      (fun i₁ i₁' i₂ i₂' => by\n        dsimp\n        rw [NatTrans.naturality])\n  map {K₂ K₂' φ} := HomologicalComplex₂.homMk\n      (((GradedObject.mapBifunctor F I₁ I₂).obj K₁.X).map φ.f)\n        (by dsimp; intros; rw [NatTrans.naturality]) (by\n          dsimp\n          intros\n          simp only [← Functor.map_comp, φ.comm])\n  map_id K₂ := by dsimp; ext; dsimp; rw [Functor.map_id]\n  map_comp f g := by dsimp; ext; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Functor.mapBifunctorHomologicalComplexObj_obj_d_f","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝⁴ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝³ : CategoryTheory.Category.{u_9, u_3} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\nI₁ : Type u_4\nI₂ : Type u_5\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\ni₁ i₁' : I₁\ni₂ : I₂\n⊢ Eq ((((F.mapBifunctorHomologicalComplexObj c₂ K₁).obj K₂).d i₁ i₁').f i₂) ((F.map (K₁.d i₁ i₁')).app (K₂.X i₂))","decl":"variable {c₁} in\n/-- Auxiliary definition for `mapBifunctorHomologicalComplex`. -/\n@[simps!]\ndef mapBifunctorHomologicalComplexObj (K₁ : HomologicalComplex C₁ c₁) :\n    HomologicalComplex C₂ c₂ ⥤ HomologicalComplex₂ D c₁ c₂ where\n  obj K₂ := HomologicalComplex₂.ofGradedObject c₁ c₂\n      (((GradedObject.mapBifunctor F I₁ I₂).obj K₁.X).obj K₂.X)\n      (fun i₁ i₁' i₂ => (F.map (K₁.d i₁ i₁')).app (K₂.X i₂))\n      (fun i₁ i₂ i₂' => (F.obj (K₁.X i₁)).map (K₂.d i₂ i₂'))\n      (fun i₁ i₁' h₁ i₂ => by\n        dsimp\n        rw [K₁.shape _ _ h₁, Functor.map_zero, zero_app])\n      (fun i₁ i₂ i₂' h₂ => by\n        dsimp\n        rw [K₂.shape _ _ h₂, Functor.map_zero])\n      (fun i₁ i₁' i₁'' i₂ => by\n        dsimp\n        rw [← NatTrans.comp_app, ← Functor.map_comp, HomologicalComplex.d_comp_d,\n          Functor.map_zero, zero_app])\n      (fun i₁ i₂ i₂' i₂'' => by\n        dsimp\n        rw [← Functor.map_comp, HomologicalComplex.d_comp_d, Functor.map_zero])\n      (fun i₁ i₁' i₂ i₂' => by\n        dsimp\n        rw [NatTrans.naturality])\n  map {K₂ K₂' φ} := HomologicalComplex₂.homMk\n      (((GradedObject.mapBifunctor F I₁ I₂).obj K₁.X).map φ.f)\n        (by dsimp; intros; rw [NatTrans.naturality]) (by\n          dsimp\n          intros\n          simp only [← Functor.map_comp, φ.comm])\n  map_id K₂ := by dsimp; ext; dsimp; rw [Functor.map_id]\n  map_comp f g := by dsimp; ext; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Functor.mapBifunctorHomologicalComplexObj_map_f_f","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝⁴ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝³ : CategoryTheory.Category.{u_9, u_3} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\nI₁ : Type u_4\nI₂ : Type u_5\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK₁ : HomologicalComplex C₁ c₁\nK₂ K₂' : HomologicalComplex C₂ c₂\nφ : Quiver.Hom K₂ K₂'\ni₁ : I₁\ni₂ : I₂\n⊢ Eq ((((F.mapBifunctorHomologicalComplexObj c₂ K₁).map φ).f i₁).f i₂) ((F.obj (K₁.X i₁)).map (φ.f i₂))","decl":"variable {c₁} in\n/-- Auxiliary definition for `mapBifunctorHomologicalComplex`. -/\n@[simps!]\ndef mapBifunctorHomologicalComplexObj (K₁ : HomologicalComplex C₁ c₁) :\n    HomologicalComplex C₂ c₂ ⥤ HomologicalComplex₂ D c₁ c₂ where\n  obj K₂ := HomologicalComplex₂.ofGradedObject c₁ c₂\n      (((GradedObject.mapBifunctor F I₁ I₂).obj K₁.X).obj K₂.X)\n      (fun i₁ i₁' i₂ => (F.map (K₁.d i₁ i₁')).app (K₂.X i₂))\n      (fun i₁ i₂ i₂' => (F.obj (K₁.X i₁)).map (K₂.d i₂ i₂'))\n      (fun i₁ i₁' h₁ i₂ => by\n        dsimp\n        rw [K₁.shape _ _ h₁, Functor.map_zero, zero_app])\n      (fun i₁ i₂ i₂' h₂ => by\n        dsimp\n        rw [K₂.shape _ _ h₂, Functor.map_zero])\n      (fun i₁ i₁' i₁'' i₂ => by\n        dsimp\n        rw [← NatTrans.comp_app, ← Functor.map_comp, HomologicalComplex.d_comp_d,\n          Functor.map_zero, zero_app])\n      (fun i₁ i₂ i₂' i₂'' => by\n        dsimp\n        rw [← Functor.map_comp, HomologicalComplex.d_comp_d, Functor.map_zero])\n      (fun i₁ i₁' i₂ i₂' => by\n        dsimp\n        rw [NatTrans.naturality])\n  map {K₂ K₂' φ} := HomologicalComplex₂.homMk\n      (((GradedObject.mapBifunctor F I₁ I₂).obj K₁.X).map φ.f)\n        (by dsimp; intros; rw [NatTrans.naturality]) (by\n          dsimp\n          intros\n          simp only [← Functor.map_comp, φ.comm])\n  map_id K₂ := by dsimp; ext; dsimp; rw [Functor.map_id]\n  map_comp f g := by dsimp; ext; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Functor.mapBifunctorHomologicalComplex_obj_obj_d_f","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝⁴ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝³ : CategoryTheory.Category.{u_9, u_3} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\nI₁ : Type u_4\nI₂ : Type u_5\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\ni₁ i₁' : I₁\ni₂ : I₂\n⊢ Eq (((((F.mapBifunctorHomologicalComplex c₁ c₂).obj K₁).obj K₂).d i₁ i₁').f i₂) ((F.map (K₁.d i₁ i₁')).app (K₂.X i₂))","decl":"/-- Given a functor `F : C₁ ⥤ C₂ ⥤ D`, this is the bifunctor which sends\n`K₁ : HomologicalComplex C₁ c₁` and `K₂ : HomologicalComplex C₂ c₂` to the bicomplex\nwhich is degree `(i₁, i₂)` consists of `(F.obj (K₁.X i₁)).obj (K₂.X i₂)`. -/\n@[simps! obj_obj_X_X obj_obj_X_d obj_obj_d_f obj_map_f_f map_app_f_f]\ndef mapBifunctorHomologicalComplex :\n    HomologicalComplex C₁ c₁ ⥤ HomologicalComplex C₂ c₂ ⥤ HomologicalComplex₂ D c₁ c₂ where\n  obj := mapBifunctorHomologicalComplexObj F c₂\n  map {K₁ K₁'} f :=\n    { app := fun K₂ => HomologicalComplex₂.homMk\n        (((GradedObject.mapBifunctor F I₁ I₂).map f.f).app K₂.X) (by\n          intros\n          dsimp\n          simp only [← NatTrans.comp_app, ← F.map_comp, f.comm]) (by simp) }\n\n"}
{"name":"CategoryTheory.Functor.mapBifunctorHomologicalComplex_obj_map_f_f","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝⁴ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝³ : CategoryTheory.Category.{u_9, u_3} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\nI₁ : Type u_4\nI₂ : Type u_5\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK₁ : HomologicalComplex C₁ c₁\nK₂ K₂' : HomologicalComplex C₂ c₂\nφ : Quiver.Hom K₂ K₂'\ni₁ : I₁\ni₂ : I₂\n⊢ Eq (((((F.mapBifunctorHomologicalComplex c₁ c₂).obj K₁).map φ).f i₁).f i₂) ((F.obj (K₁.X i₁)).map (φ.f i₂))","decl":"/-- Given a functor `F : C₁ ⥤ C₂ ⥤ D`, this is the bifunctor which sends\n`K₁ : HomologicalComplex C₁ c₁` and `K₂ : HomologicalComplex C₂ c₂` to the bicomplex\nwhich is degree `(i₁, i₂)` consists of `(F.obj (K₁.X i₁)).obj (K₂.X i₂)`. -/\n@[simps! obj_obj_X_X obj_obj_X_d obj_obj_d_f obj_map_f_f map_app_f_f]\ndef mapBifunctorHomologicalComplex :\n    HomologicalComplex C₁ c₁ ⥤ HomologicalComplex C₂ c₂ ⥤ HomologicalComplex₂ D c₁ c₂ where\n  obj := mapBifunctorHomologicalComplexObj F c₂\n  map {K₁ K₁'} f :=\n    { app := fun K₂ => HomologicalComplex₂.homMk\n        (((GradedObject.mapBifunctor F I₁ I₂).map f.f).app K₂.X) (by\n          intros\n          dsimp\n          simp only [← NatTrans.comp_app, ← F.map_comp, f.comm]) (by simp) }\n\n"}
{"name":"CategoryTheory.Functor.mapBifunctorHomologicalComplex_obj_obj_X_d","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝⁴ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝³ : CategoryTheory.Category.{u_9, u_3} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\nI₁ : Type u_4\nI₂ : Type u_5\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\ni₁ : I₁\ni₂ i₂' : I₂\n⊢ Eq (((((F.mapBifunctorHomologicalComplex c₁ c₂).obj K₁).obj K₂).X i₁).d i₂ i₂') ((F.obj (K₁.X i₁)).map (K₂.d i₂ i₂'))","decl":"/-- Given a functor `F : C₁ ⥤ C₂ ⥤ D`, this is the bifunctor which sends\n`K₁ : HomologicalComplex C₁ c₁` and `K₂ : HomologicalComplex C₂ c₂` to the bicomplex\nwhich is degree `(i₁, i₂)` consists of `(F.obj (K₁.X i₁)).obj (K₂.X i₂)`. -/\n@[simps! obj_obj_X_X obj_obj_X_d obj_obj_d_f obj_map_f_f map_app_f_f]\ndef mapBifunctorHomologicalComplex :\n    HomologicalComplex C₁ c₁ ⥤ HomologicalComplex C₂ c₂ ⥤ HomologicalComplex₂ D c₁ c₂ where\n  obj := mapBifunctorHomologicalComplexObj F c₂\n  map {K₁ K₁'} f :=\n    { app := fun K₂ => HomologicalComplex₂.homMk\n        (((GradedObject.mapBifunctor F I₁ I₂).map f.f).app K₂.X) (by\n          intros\n          dsimp\n          simp only [← NatTrans.comp_app, ← F.map_comp, f.comm]) (by simp) }\n\n"}
{"name":"CategoryTheory.Functor.mapBifunctorHomologicalComplex_obj_obj_X_X","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝⁴ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝³ : CategoryTheory.Category.{u_9, u_3} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\nI₁ : Type u_4\nI₂ : Type u_5\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\ni₁ : I₁\ni₂ : I₂\n⊢ Eq (((((F.mapBifunctorHomologicalComplex c₁ c₂).obj K₁).obj K₂).X i₁).X i₂) ((F.obj (K₁.X i₁)).obj (K₂.X i₂))","decl":"/-- Given a functor `F : C₁ ⥤ C₂ ⥤ D`, this is the bifunctor which sends\n`K₁ : HomologicalComplex C₁ c₁` and `K₂ : HomologicalComplex C₂ c₂` to the bicomplex\nwhich is degree `(i₁, i₂)` consists of `(F.obj (K₁.X i₁)).obj (K₂.X i₂)`. -/\n@[simps! obj_obj_X_X obj_obj_X_d obj_obj_d_f obj_map_f_f map_app_f_f]\ndef mapBifunctorHomologicalComplex :\n    HomologicalComplex C₁ c₁ ⥤ HomologicalComplex C₂ c₂ ⥤ HomologicalComplex₂ D c₁ c₂ where\n  obj := mapBifunctorHomologicalComplexObj F c₂\n  map {K₁ K₁'} f :=\n    { app := fun K₂ => HomologicalComplex₂.homMk\n        (((GradedObject.mapBifunctor F I₁ I₂).map f.f).app K₂.X) (by\n          intros\n          dsimp\n          simp only [← NatTrans.comp_app, ← F.map_comp, f.comm]) (by simp) }\n\n"}
{"name":"CategoryTheory.Functor.mapBifunctorHomologicalComplex_map_app_f_f","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝⁴ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝³ : CategoryTheory.Category.{u_9, u_3} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\nI₁ : Type u_4\nI₂ : Type u_5\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK₁ K₁' : HomologicalComplex C₁ c₁\nf : Quiver.Hom K₁ K₁'\nK₂ : HomologicalComplex C₂ c₂\ni₁ : I₁\ni₂ : I₂\n⊢ Eq (((((F.mapBifunctorHomologicalComplex c₁ c₂).map f).app K₂).f i₁).f i₂) ((F.map (f.f i₁)).app (K₂.X i₂))","decl":"/-- Given a functor `F : C₁ ⥤ C₂ ⥤ D`, this is the bifunctor which sends\n`K₁ : HomologicalComplex C₁ c₁` and `K₂ : HomologicalComplex C₂ c₂` to the bicomplex\nwhich is degree `(i₁, i₂)` consists of `(F.obj (K₁.X i₁)).obj (K₂.X i₂)`. -/\n@[simps! obj_obj_X_X obj_obj_X_d obj_obj_d_f obj_map_f_f map_app_f_f]\ndef mapBifunctorHomologicalComplex :\n    HomologicalComplex C₁ c₁ ⥤ HomologicalComplex C₂ c₂ ⥤ HomologicalComplex₂ D c₁ c₂ where\n  obj := mapBifunctorHomologicalComplexObj F c₂\n  map {K₁ K₁'} f :=\n    { app := fun K₂ => HomologicalComplex₂.homMk\n        (((GradedObject.mapBifunctor F I₁ I₂).map f.f).app K₂.X) (by\n          intros\n          dsimp\n          simp only [← NatTrans.comp_app, ← F.map_comp, f.comm]) (by simp) }\n\n"}
{"name":"CategoryTheory.Functor.mapBifunctorHomologicalComplex_obj_obj_toGradedObject","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝⁷ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝⁶ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁵ : CategoryTheory.Category.{u_9, u_3} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\nI₁ : Type u_4\nI₂ : Type u_5\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\n⊢ Eq (((F.mapBifunctorHomologicalComplex c₁ c₂).obj K₁).obj K₂).toGradedObject (((CategoryTheory.GradedObject.mapBifunctor F I₁ I₂).obj K₁.X).obj K₂.X)","decl":"@[simp]\nlemma mapBifunctorHomologicalComplex_obj_obj_toGradedObject\n    (K₁ : HomologicalComplex C₁ c₁) (K₂ : HomologicalComplex C₂ c₂) :\n    (((mapBifunctorHomologicalComplex F c₁ c₂).obj K₁).obj K₂).toGradedObject =\n      ((GradedObject.mapBifunctor F I₁ I₂).obj K₁.X).obj K₂.X := rfl\n\n"}
{"name":"HomologicalComplex.ιMapBifunctorOrZero_eq","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝¹⁰ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝⁹ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁸ : CategoryTheory.Category.{u_7, u_3} D\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝⁵ : CategoryTheory.Preadditive D\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nc : ComplexShape J\ninst✝² : TotalComplexShape c₁ c₂ c\ninst✝¹ : K₁.HasMapBifunctor K₂ F c\ninst✝ : DecidableEq J\ni₁ : I₁\ni₂ : I₂\nj : J\nh : Eq (c₁.π c₂ c { fst := i₁, snd := i₂ }) j\n⊢ Eq (K₁.ιMapBifunctorOrZero K₂ F c i₁ i₂ j) (K₁.ιMapBifunctor K₂ F c i₁ i₂ j h)","decl":"lemma ιMapBifunctorOrZero_eq (i₁ : I₁) (i₂ : I₂) (j : J)\n    (h : ComplexShape.π c₁ c₂ c (i₁, i₂) = j) :\n    ιMapBifunctorOrZero K₁ K₂ F c i₁ i₂ j = ιMapBifunctor K₁ K₂ F c i₁ i₂ j h := dif_pos h\n\n"}
{"name":"HomologicalComplex.ιMapBifunctorOrZero_eq_zero","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝¹⁰ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝⁹ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁸ : CategoryTheory.Category.{u_7, u_3} D\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝⁵ : CategoryTheory.Preadditive D\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nc : ComplexShape J\ninst✝² : TotalComplexShape c₁ c₂ c\ninst✝¹ : K₁.HasMapBifunctor K₂ F c\ninst✝ : DecidableEq J\ni₁ : I₁\ni₂ : I₂\nj : J\nh : Ne (c₁.π c₂ c { fst := i₁, snd := i₂ }) j\n⊢ Eq (K₁.ιMapBifunctorOrZero K₂ F c i₁ i₂ j) 0","decl":"lemma ιMapBifunctorOrZero_eq_zero (i₁ : I₁) (i₂ : I₂) (j : J)\n    (h : ComplexShape.π c₁ c₂ c (i₁, i₂) ≠ j) :\n    ιMapBifunctorOrZero K₁ K₂ F c i₁ i₂ j = 0 := dif_neg h\n\n"}
{"name":"HomologicalComplex.ι_mapBifunctorDesc_assoc","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝¹⁰ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝⁹ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁸ : CategoryTheory.Category.{u_7, u_3} D\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝⁵ : CategoryTheory.Preadditive D\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nc : ComplexShape J\ninst✝² : TotalComplexShape c₁ c₂ c\ninst✝¹ : K₁.HasMapBifunctor K₂ F c\ninst✝ : DecidableEq J\nA : D\nj : J\nf : (i₁ : I₁) → (i₂ : I₂) → Eq (c₁.π c₂ c { fst := i₁, snd := i₂ }) j → Quiver.Hom ((F.obj (K₁.X i₁)).obj (K₂.X i₂)) A\ni₁ : I₁\ni₂ : I₂\nh✝ : Eq (c₁.π c₂ c { fst := i₁, snd := i₂ }) j\nZ : D\nh : Quiver.Hom A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K₁.ιMapBifunctor K₂ F c i₁ i₂ j h✝) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.mapBifunctorDesc f) h)) (CategoryTheory.CategoryStruct.comp (f i₁ i₂ h✝) h)","decl":"@[reassoc (attr := simp)]\nlemma ι_mapBifunctorDesc (i₁ : I₁) (i₂ : I₂) (h : ComplexShape.π c₁ c₂ c ⟨i₁, i₂⟩ = j) :\n    ιMapBifunctor K₁ K₂ F c i₁ i₂ j h ≫ mapBifunctorDesc f = f i₁ i₂ h := by\n  apply HomologicalComplex₂.ι_totalDesc\n\n"}
{"name":"HomologicalComplex.ι_mapBifunctorDesc","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝¹⁰ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝⁹ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁸ : CategoryTheory.Category.{u_7, u_3} D\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝⁵ : CategoryTheory.Preadditive D\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nc : ComplexShape J\ninst✝² : TotalComplexShape c₁ c₂ c\ninst✝¹ : K₁.HasMapBifunctor K₂ F c\ninst✝ : DecidableEq J\nA : D\nj : J\nf : (i₁ : I₁) → (i₂ : I₂) → Eq (c₁.π c₂ c { fst := i₁, snd := i₂ }) j → Quiver.Hom ((F.obj (K₁.X i₁)).obj (K₂.X i₂)) A\ni₁ : I₁\ni₂ : I₂\nh : Eq (c₁.π c₂ c { fst := i₁, snd := i₂ }) j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K₁.ιMapBifunctor K₂ F c i₁ i₂ j h) (HomologicalComplex.mapBifunctorDesc f)) (f i₁ i₂ h)","decl":"@[reassoc (attr := simp)]\nlemma ι_mapBifunctorDesc (i₁ : I₁) (i₂ : I₂) (h : ComplexShape.π c₁ c₂ c ⟨i₁, i₂⟩ = j) :\n    ιMapBifunctor K₁ K₂ F c i₁ i₂ j h ≫ mapBifunctorDesc f = f i₁ i₂ h := by\n  apply HomologicalComplex₂.ι_totalDesc\n\n"}
{"name":"HomologicalComplex.mapBifunctor.hom_ext_iff","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝¹⁰ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁹ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁸ : CategoryTheory.Category.{u_7, u_3} D\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝⁵ : CategoryTheory.Preadditive D\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nc : ComplexShape J\ninst✝² : TotalComplexShape c₁ c₂ c\ninst✝¹ : K₁.HasMapBifunctor K₂ F c\ninst✝ : DecidableEq J\nY : D\nj : J\nf g : Quiver.Hom ((K₁.mapBifunctor K₂ F c).X j) Y\n⊢ Iff (Eq f g) (∀ (i₁ : I₁) (i₂ : I₂) (h : Eq (c₁.π c₂ c { fst := i₁, snd := i₂ }) j), Eq (CategoryTheory.CategoryStruct.comp (K₁.ιMapBifunctor K₂ F c i₁ i₂ j h) f) (CategoryTheory.CategoryStruct.comp (K₁.ιMapBifunctor K₂ F c i₁ i₂ j h) g))","decl":"variable {K₁ K₂ F c} in\n@[ext]\nlemma hom_ext {Y : D} {j : J} {f g : (mapBifunctor K₁ K₂ F c).X j ⟶ Y}\n    (h : ∀ (i₁ : I₁) (i₂ : I₂) (h : ComplexShape.π c₁ c₂ c ⟨i₁, i₂⟩ = j),\n      ιMapBifunctor K₁ K₂ F c i₁ i₂ j h ≫ f = ιMapBifunctor K₁ K₂ F c i₁ i₂ j h ≫ g) :\n    f = g :=\n  HomologicalComplex₂.total.hom_ext _ h\n\n"}
{"name":"HomologicalComplex.mapBifunctor.hom_ext","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝¹⁰ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁹ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁸ : CategoryTheory.Category.{u_7, u_3} D\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝⁵ : CategoryTheory.Preadditive D\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nc : ComplexShape J\ninst✝² : TotalComplexShape c₁ c₂ c\ninst✝¹ : K₁.HasMapBifunctor K₂ F c\ninst✝ : DecidableEq J\nY : D\nj : J\nf g : Quiver.Hom ((K₁.mapBifunctor K₂ F c).X j) Y\nh : ∀ (i₁ : I₁) (i₂ : I₂) (h : Eq (c₁.π c₂ c { fst := i₁, snd := i₂ }) j), Eq (CategoryTheory.CategoryStruct.comp (K₁.ιMapBifunctor K₂ F c i₁ i₂ j h) f) (CategoryTheory.CategoryStruct.comp (K₁.ιMapBifunctor K₂ F c i₁ i₂ j h) g)\n⊢ Eq f g","decl":"variable {K₁ K₂ F c} in\n@[ext]\nlemma hom_ext {Y : D} {j : J} {f g : (mapBifunctor K₁ K₂ F c).X j ⟶ Y}\n    (h : ∀ (i₁ : I₁) (i₂ : I₂) (h : ComplexShape.π c₁ c₂ c ⟨i₁, i₂⟩ = j),\n      ιMapBifunctor K₁ K₂ F c i₁ i₂ j h ≫ f = ιMapBifunctor K₁ K₂ F c i₁ i₂ j h ≫ g) :\n    f = g :=\n  HomologicalComplex₂.total.hom_ext _ h\n\n"}
{"name":"HomologicalComplex.mapBifunctor.d_eq","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝¹⁰ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁹ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁸ : CategoryTheory.Category.{u_7, u_3} D\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝⁵ : CategoryTheory.Preadditive D\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nc : ComplexShape J\ninst✝² : TotalComplexShape c₁ c₂ c\ninst✝¹ : K₁.HasMapBifunctor K₂ F c\ninst✝ : DecidableEq J\nj j' : J\n⊢ Eq ((K₁.mapBifunctor K₂ F c).d j j') (HAdd.hAdd (HomologicalComplex.mapBifunctor.D₁ K₁ K₂ F c j j') (HomologicalComplex.mapBifunctor.D₂ K₁ K₂ F c j j'))","decl":"lemma d_eq :\n    (mapBifunctor K₁ K₂ F c).d j j' = D₁ K₁ K₂ F c j j' + D₂ K₁ K₂ F c j j' := rfl\n\n"}
{"name":"HomologicalComplex.mapBifunctor.d₁_eq_zero","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝¹⁰ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝⁹ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁸ : CategoryTheory.Category.{u_7, u_3} D\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝⁵ : CategoryTheory.Preadditive D\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nc : ComplexShape J\ninst✝² : TotalComplexShape c₁ c₂ c\ninst✝¹ : K₁.HasMapBifunctor K₂ F c\ninst✝ : DecidableEq J\ni₁ : I₁\ni₂ : I₂\nj : J\nh : Not (c₁.Rel i₁ (c₁.next i₁))\n⊢ Eq (HomologicalComplex.mapBifunctor.d₁ K₁ K₂ F c i₁ i₂ j) 0","decl":"lemma d₁_eq_zero (h : ¬ c₁.Rel i₁ (c₁.next i₁)):\n    d₁ K₁ K₂ F c i₁ i₂ j = 0 :=\n  HomologicalComplex₂.d₁_eq_zero _ _ _ _ _ h\n\n"}
{"name":"HomologicalComplex.mapBifunctor.d₂_eq_zero","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝¹⁰ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝⁹ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁸ : CategoryTheory.Category.{u_7, u_3} D\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝⁵ : CategoryTheory.Preadditive D\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nc : ComplexShape J\ninst✝² : TotalComplexShape c₁ c₂ c\ninst✝¹ : K₁.HasMapBifunctor K₂ F c\ninst✝ : DecidableEq J\ni₁ : I₁\ni₂ : I₂\nj : J\nh : Not (c₂.Rel i₂ (c₂.next i₂))\n⊢ Eq (HomologicalComplex.mapBifunctor.d₂ K₁ K₂ F c i₁ i₂ j) 0","decl":"lemma d₂_eq_zero (h : ¬ c₂.Rel i₂ (c₂.next i₂)):\n    d₂ K₁ K₂ F c i₁ i₂ j = 0 :=\n  HomologicalComplex₂.d₂_eq_zero _ _ _ _ _ h\n\n"}
{"name":"HomologicalComplex.mapBifunctor.d₁_eq_zero'","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝¹⁰ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝⁹ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁸ : CategoryTheory.Category.{u_7, u_3} D\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝⁵ : CategoryTheory.Preadditive D\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nc : ComplexShape J\ninst✝² : TotalComplexShape c₁ c₂ c\ninst✝¹ : K₁.HasMapBifunctor K₂ F c\ninst✝ : DecidableEq J\ni₁ i₁' : I₁\nh : c₁.Rel i₁ i₁'\ni₂ : I₂\nj : J\nh' : Ne (c₁.π c₂ c { fst := i₁', snd := i₂ }) j\n⊢ Eq (HomologicalComplex.mapBifunctor.d₁ K₁ K₂ F c i₁ i₂ j) 0","decl":"lemma d₁_eq_zero' {i₁ i₁' : I₁} (h : c₁.Rel i₁ i₁') (i₂ : I₂) (j : J)\n    (h' : ComplexShape.π c₁ c₂ c ⟨i₁', i₂⟩ ≠ j) :\n    d₁ K₁ K₂ F c i₁ i₂ j = 0 :=\n  HomologicalComplex₂.d₁_eq_zero' _ _ h _ _ h'\n\n"}
{"name":"HomologicalComplex.mapBifunctor.d₂_eq_zero'","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝¹⁰ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝⁹ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁸ : CategoryTheory.Category.{u_7, u_3} D\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝⁵ : CategoryTheory.Preadditive D\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nc : ComplexShape J\ninst✝² : TotalComplexShape c₁ c₂ c\ninst✝¹ : K₁.HasMapBifunctor K₂ F c\ninst✝ : DecidableEq J\ni₁ : I₁\ni₂ i₂' : I₂\nh : c₂.Rel i₂ i₂'\nj : J\nh' : Ne (c₁.π c₂ c { fst := i₁, snd := i₂' }) j\n⊢ Eq (HomologicalComplex.mapBifunctor.d₂ K₁ K₂ F c i₁ i₂ j) 0","decl":"lemma d₂_eq_zero' (i₁ : I₁) {i₂ i₂' : I₂} (h : c₂.Rel i₂ i₂') (j : J)\n    (h' : ComplexShape.π c₁ c₂ c ⟨i₁, i₂'⟩ ≠ j) :\n    d₂ K₁ K₂ F c i₁ i₂ j = 0 :=\n  HomologicalComplex₂.d₂_eq_zero' _ _ _ h _ h'\n\n"}
{"name":"HomologicalComplex.mapBifunctor.d₁_eq'","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝¹⁰ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝⁹ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁸ : CategoryTheory.Category.{u_7, u_3} D\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝⁵ : CategoryTheory.Preadditive D\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nc : ComplexShape J\ninst✝² : TotalComplexShape c₁ c₂ c\ninst✝¹ : K₁.HasMapBifunctor K₂ F c\ninst✝ : DecidableEq J\ni₁ i₁' : I₁\nh : c₁.Rel i₁ i₁'\ni₂ : I₂\nj : J\n⊢ Eq (HomologicalComplex.mapBifunctor.d₁ K₁ K₂ F c i₁ i₂ j) (HSMul.hSMul (c₁.ε₁ c₂ c { fst := i₁, snd := i₂ }) (CategoryTheory.CategoryStruct.comp ((F.map (K₁.d i₁ i₁')).app (K₂.X i₂)) (K₁.ιMapBifunctorOrZero K₂ F c i₁' i₂ j)))","decl":"lemma d₁_eq' {i₁ i₁' : I₁} (h : c₁.Rel i₁ i₁') (i₂ : I₂) (j : J) :\n    d₁ K₁ K₂ F c i₁ i₂ j = ComplexShape.ε₁ c₁ c₂ c ⟨i₁, i₂⟩ •\n      ((F.map (K₁.d i₁ i₁')).app (K₂.X i₂) ≫ ιMapBifunctorOrZero K₁ K₂ F c i₁' i₂ j) :=\n  HomologicalComplex₂.d₁_eq' _ _ h _ _\n\n"}
{"name":"HomologicalComplex.mapBifunctor.d₂_eq'","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝¹⁰ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝⁹ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁸ : CategoryTheory.Category.{u_7, u_3} D\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝⁵ : CategoryTheory.Preadditive D\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nc : ComplexShape J\ninst✝² : TotalComplexShape c₁ c₂ c\ninst✝¹ : K₁.HasMapBifunctor K₂ F c\ninst✝ : DecidableEq J\ni₁ : I₁\ni₂ i₂' : I₂\nh : c₂.Rel i₂ i₂'\nj : J\n⊢ Eq (HomologicalComplex.mapBifunctor.d₂ K₁ K₂ F c i₁ i₂ j) (HSMul.hSMul (c₁.ε₂ c₂ c { fst := i₁, snd := i₂ }) (CategoryTheory.CategoryStruct.comp ((F.obj (K₁.X i₁)).map (K₂.d i₂ i₂')) (K₁.ιMapBifunctorOrZero K₂ F c i₁ i₂' j)))","decl":"lemma d₂_eq' (i₁ : I₁) {i₂ i₂' : I₂} (h : c₂.Rel i₂ i₂') (j : J) :\n    d₂ K₁ K₂ F c i₁ i₂ j = ComplexShape.ε₂ c₁ c₂ c ⟨i₁, i₂⟩ •\n      ((F.obj (K₁.X i₁)).map (K₂.d i₂ i₂') ≫ ιMapBifunctorOrZero K₁ K₂ F c i₁ i₂' j) :=\n  HomologicalComplex₂.d₂_eq' _ _ _ h _\n\n"}
{"name":"HomologicalComplex.mapBifunctor.d₁_eq","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝¹⁰ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝⁹ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁸ : CategoryTheory.Category.{u_7, u_3} D\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝⁵ : CategoryTheory.Preadditive D\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nc : ComplexShape J\ninst✝² : TotalComplexShape c₁ c₂ c\ninst✝¹ : K₁.HasMapBifunctor K₂ F c\ninst✝ : DecidableEq J\ni₁ i₁' : I₁\nh : c₁.Rel i₁ i₁'\ni₂ : I₂\nj : J\nh' : Eq (c₁.π c₂ c { fst := i₁', snd := i₂ }) j\n⊢ Eq (HomologicalComplex.mapBifunctor.d₁ K₁ K₂ F c i₁ i₂ j) (HSMul.hSMul (c₁.ε₁ c₂ c { fst := i₁, snd := i₂ }) (CategoryTheory.CategoryStruct.comp ((F.map (K₁.d i₁ i₁')).app (K₂.X i₂)) (K₁.ιMapBifunctor K₂ F c i₁' i₂ j h')))","decl":"lemma d₁_eq {i₁ i₁' : I₁} (h : c₁.Rel i₁ i₁') (i₂ : I₂) (j : J)\n    (h' : ComplexShape.π c₁ c₂ c ⟨i₁', i₂⟩ = j) :\n    d₁ K₁ K₂ F c i₁ i₂ j = ComplexShape.ε₁ c₁ c₂ c ⟨i₁, i₂⟩ •\n      ((F.map (K₁.d i₁ i₁')).app (K₂.X i₂) ≫ ιMapBifunctor K₁ K₂ F c i₁' i₂ j h') :=\n  HomologicalComplex₂.d₁_eq _ _ h _ _ h'\n\n"}
{"name":"HomologicalComplex.mapBifunctor.d₂_eq","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝¹⁰ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝⁹ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁸ : CategoryTheory.Category.{u_7, u_3} D\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝⁵ : CategoryTheory.Preadditive D\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nc : ComplexShape J\ninst✝² : TotalComplexShape c₁ c₂ c\ninst✝¹ : K₁.HasMapBifunctor K₂ F c\ninst✝ : DecidableEq J\ni₁ : I₁\ni₂ i₂' : I₂\nh : c₂.Rel i₂ i₂'\nj : J\nh' : Eq (c₁.π c₂ c { fst := i₁, snd := i₂' }) j\n⊢ Eq (HomologicalComplex.mapBifunctor.d₂ K₁ K₂ F c i₁ i₂ j) (HSMul.hSMul (c₁.ε₂ c₂ c { fst := i₁, snd := i₂ }) (CategoryTheory.CategoryStruct.comp ((F.obj (K₁.X i₁)).map (K₂.d i₂ i₂')) (K₁.ιMapBifunctor K₂ F c i₁ i₂' j h')))","decl":"lemma d₂_eq (i₁ : I₁) {i₂ i₂' : I₂} (h : c₂.Rel i₂ i₂') (j : J)\n    (h' : ComplexShape.π c₁ c₂ c ⟨i₁, i₂'⟩ = j) :\n    d₂ K₁ K₂ F c i₁ i₂ j = ComplexShape.ε₂ c₁ c₂ c ⟨i₁, i₂⟩ •\n      ((F.obj (K₁.X i₁)).map (K₂.d i₂ i₂') ≫ ιMapBifunctor K₁ K₂ F c i₁ i₂' j h') :=\n  HomologicalComplex₂.d₂_eq _ _ _ h _ h'\n\n"}
{"name":"HomologicalComplex.mapBifunctor.ι_D₁_assoc","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝¹⁰ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝⁹ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁸ : CategoryTheory.Category.{u_7, u_3} D\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝⁵ : CategoryTheory.Preadditive D\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nc : ComplexShape J\ninst✝² : TotalComplexShape c₁ c₂ c\ninst✝¹ : K₁.HasMapBifunctor K₂ F c\ninst✝ : DecidableEq J\nj j' : J\ni₁ : I₁\ni₂ : I₂\nh✝ : Eq (c₁.π c₂ c { fst := i₁, snd := i₂ }) j\nZ : D\nh : Quiver.Hom ((K₁.mapBifunctor K₂ F c).X j') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K₁.ιMapBifunctor K₂ F c i₁ i₂ j h✝) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.mapBifunctor.D₁ K₁ K₂ F c j j') h)) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.mapBifunctor.d₁ K₁ K₂ F c i₁ i₂ j') h)","decl":"@[reassoc (attr := simp)]\nlemma ι_D₁ :\n    ιMapBifunctor K₁ K₂ F c i₁ i₂ j h ≫ D₁ K₁ K₂ F c j j' = d₁ K₁ K₂ F c i₁ i₂ j' := by\n  apply HomologicalComplex₂.ι_D₁\n\n"}
{"name":"HomologicalComplex.mapBifunctor.ι_D₁","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝¹⁰ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝⁹ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁸ : CategoryTheory.Category.{u_7, u_3} D\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝⁵ : CategoryTheory.Preadditive D\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nc : ComplexShape J\ninst✝² : TotalComplexShape c₁ c₂ c\ninst✝¹ : K₁.HasMapBifunctor K₂ F c\ninst✝ : DecidableEq J\nj j' : J\ni₁ : I₁\ni₂ : I₂\nh : Eq (c₁.π c₂ c { fst := i₁, snd := i₂ }) j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K₁.ιMapBifunctor K₂ F c i₁ i₂ j h) (HomologicalComplex.mapBifunctor.D₁ K₁ K₂ F c j j')) (HomologicalComplex.mapBifunctor.d₁ K₁ K₂ F c i₁ i₂ j')","decl":"@[reassoc (attr := simp)]\nlemma ι_D₁ :\n    ιMapBifunctor K₁ K₂ F c i₁ i₂ j h ≫ D₁ K₁ K₂ F c j j' = d₁ K₁ K₂ F c i₁ i₂ j' := by\n  apply HomologicalComplex₂.ι_D₁\n\n"}
{"name":"HomologicalComplex.mapBifunctor.ι_D₂","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝¹⁰ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝⁹ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁸ : CategoryTheory.Category.{u_7, u_3} D\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝⁵ : CategoryTheory.Preadditive D\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nc : ComplexShape J\ninst✝² : TotalComplexShape c₁ c₂ c\ninst✝¹ : K₁.HasMapBifunctor K₂ F c\ninst✝ : DecidableEq J\nj j' : J\ni₁ : I₁\ni₂ : I₂\nh : Eq (c₁.π c₂ c { fst := i₁, snd := i₂ }) j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K₁.ιMapBifunctor K₂ F c i₁ i₂ j h) (HomologicalComplex.mapBifunctor.D₂ K₁ K₂ F c j j')) (HomologicalComplex.mapBifunctor.d₂ K₁ K₂ F c i₁ i₂ j')","decl":"@[reassoc (attr := simp)]\nlemma ι_D₂ :\n    ιMapBifunctor K₁ K₂ F c i₁ i₂ j h ≫ D₂ K₁ K₂ F c j j' = d₂ K₁ K₂ F c i₁ i₂ j' := by\n  apply HomologicalComplex₂.ι_D₂\n\n"}
{"name":"HomologicalComplex.mapBifunctor.ι_D₂_assoc","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝¹⁰ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝⁹ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁸ : CategoryTheory.Category.{u_7, u_3} D\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝⁵ : CategoryTheory.Preadditive D\nK₁ : HomologicalComplex C₁ c₁\nK₂ : HomologicalComplex C₂ c₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nc : ComplexShape J\ninst✝² : TotalComplexShape c₁ c₂ c\ninst✝¹ : K₁.HasMapBifunctor K₂ F c\ninst✝ : DecidableEq J\nj j' : J\ni₁ : I₁\ni₂ : I₂\nh✝ : Eq (c₁.π c₂ c { fst := i₁, snd := i₂ }) j\nZ : D\nh : Quiver.Hom ((K₁.mapBifunctor K₂ F c).X j') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K₁.ιMapBifunctor K₂ F c i₁ i₂ j h✝) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.mapBifunctor.D₂ K₁ K₂ F c j j') h)) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.mapBifunctor.d₂ K₁ K₂ F c i₁ i₂ j') h)","decl":"@[reassoc (attr := simp)]\nlemma ι_D₂ :\n    ιMapBifunctor K₁ K₂ F c i₁ i₂ j h ≫ D₂ K₁ K₂ F c j j' = d₂ K₁ K₂ F c i₁ i₂ j' := by\n  apply HomologicalComplex₂.ι_D₂\n\n"}
{"name":"HomologicalComplex.ι_mapBifunctorMap","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝¹¹ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝¹⁰ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁹ : CategoryTheory.Category.{u_7, u_3} D\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\ninst✝⁸ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝⁶ : CategoryTheory.Preadditive D\nK₁ L₁ : HomologicalComplex C₁ c₁\nK₂ L₂ : HomologicalComplex C₂ c₂\nf₁ : Quiver.Hom K₁ L₁\nf₂ : Quiver.Hom K₂ L₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁵ : F.PreservesZeroMorphisms\ninst✝⁴ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nc : ComplexShape J\ninst✝³ : TotalComplexShape c₁ c₂ c\ninst✝² : K₁.HasMapBifunctor K₂ F c\ninst✝¹ : L₁.HasMapBifunctor L₂ F c\ninst✝ : DecidableEq J\ni₁ : I₁\ni₂ : I₂\nj : J\nh : Eq (c₁.π c₂ c { fst := i₁, snd := i₂ }) j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K₁.ιMapBifunctor K₂ F c i₁ i₂ j h) ((HomologicalComplex.mapBifunctorMap f₁ f₂ F c).f j)) (CategoryTheory.CategoryStruct.comp ((F.map (f₁.f i₁)).app (K₂.X i₂)) (CategoryTheory.CategoryStruct.comp ((F.obj (L₁.X i₁)).map (f₂.f i₂)) (L₁.ιMapBifunctor L₂ F c i₁ i₂ j h)))","decl":"@[reassoc (attr := simp)]\nlemma ι_mapBifunctorMap (i₁ : I₁) (i₂ : I₂) (j : J)\n    (h : ComplexShape.π c₁ c₂ c (i₁, i₂) = j) :\n    ιMapBifunctor K₁ K₂ F c i₁ i₂ j h ≫ (mapBifunctorMap f₁ f₂ F c).f j =\n      (F.map (f₁.f i₁)).app (K₂.X i₂) ≫ (F.obj (L₁.X i₁)).map (f₂.f i₂) ≫\n        ιMapBifunctor L₁ L₂ F c i₁ i₂ j h := by\n  simp [mapBifunctorMap]\n\n"}
{"name":"HomologicalComplex.ι_mapBifunctorMap_assoc","module":"Mathlib.Algebra.Homology.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝¹¹ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝¹⁰ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁹ : CategoryTheory.Category.{u_7, u_3} D\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\ninst✝⁸ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝⁶ : CategoryTheory.Preadditive D\nK₁ L₁ : HomologicalComplex C₁ c₁\nK₂ L₂ : HomologicalComplex C₂ c₂\nf₁ : Quiver.Hom K₁ L₁\nf₂ : Quiver.Hom K₂ L₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁵ : F.PreservesZeroMorphisms\ninst✝⁴ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nc : ComplexShape J\ninst✝³ : TotalComplexShape c₁ c₂ c\ninst✝² : K₁.HasMapBifunctor K₂ F c\ninst✝¹ : L₁.HasMapBifunctor L₂ F c\ninst✝ : DecidableEq J\ni₁ : I₁\ni₂ : I₂\nj : J\nh✝ : Eq (c₁.π c₂ c { fst := i₁, snd := i₂ }) j\nZ : D\nh : Quiver.Hom ((L₁.mapBifunctor L₂ F c).X j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K₁.ιMapBifunctor K₂ F c i₁ i₂ j h✝) (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.mapBifunctorMap f₁ f₂ F c).f j) h)) (CategoryTheory.CategoryStruct.comp ((F.map (f₁.f i₁)).app (K₂.X i₂)) (CategoryTheory.CategoryStruct.comp ((F.obj (L₁.X i₁)).map (f₂.f i₂)) (CategoryTheory.CategoryStruct.comp (L₁.ιMapBifunctor L₂ F c i₁ i₂ j h✝) h)))","decl":"@[reassoc (attr := simp)]\nlemma ι_mapBifunctorMap (i₁ : I₁) (i₂ : I₂) (j : J)\n    (h : ComplexShape.π c₁ c₂ c (i₁, i₂) = j) :\n    ιMapBifunctor K₁ K₂ F c i₁ i₂ j h ≫ (mapBifunctorMap f₁ f₂ F c).f j =\n      (F.map (f₁.f i₁)).app (K₂.X i₂) ≫ (F.obj (L₁.X i₁)).map (f₂.f i₂) ≫\n        ιMapBifunctor L₁ L₂ F c i₁ i₂ j h := by\n  simp [mapBifunctorMap]\n\n"}
