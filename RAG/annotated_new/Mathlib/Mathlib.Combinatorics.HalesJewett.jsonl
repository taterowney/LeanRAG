{"name":"Combinatorics.Subspace.mk.sizeOf_spec","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"η : Type u_5\nα : Type u_6\nι : Type u_7\ninst✝² : SizeOf η\ninst✝¹ : SizeOf α\ninst✝ : SizeOf ι\nidxFun : ι → Sum α η\nproper : ∀ (e : η), Exists fun i => Eq (idxFun i) (Sum.inr e)\n⊢ Eq (SizeOf.sizeOf { idxFun := idxFun, proper := proper }) 1","decl":"/-- The type of combinatorial subspaces. A subspace `l : Subspace η α ι` in the hypercube `ι → α`\ndefines a function `(η → α) → ι → α` from `η → α` to the hypercube, such that for each coordinate\n`i : ι` and direction `e : η`, the function `fun x ↦ l x i` is either `fun x ↦ x e` for some\ndirection `e : η` or constant. We require subspaces to be non-degenerate in the sense that, for\nevery `e : η`, `fun x ↦ l x i` is `fun x ↦ x e` for at least one `i`.\n\nFormally, a subspace is represented by a word `l.idxFun : ι → α ⊕ η` which says whether\n`fun x ↦ l x i` is `fun x ↦ x e` (corresponding to `l.idxFun i = Sum.inr e`) or constantly `a`\n(corresponding to `l.idxFun i = Sum.inl a`).\n\nWhen `α` has size `1` there can be many elements of `Subspace η α ι` defining the same function. -/\n@[ext]\nstructure Subspace (η α ι : Type*) where\n  /-- The word representing a combinatorial subspace. `l.idxfun i = Sum.inr e` means that\n  `l x i = x e` for all `x` and `l.idxfun i = some a` means that `l x i = a` for all `x`. -/\n  idxFun : ι → α ⊕ η\n  /-- We require combinatorial subspaces to be nontrivial in the sense that `fun x ↦ l x i` is\n  `fun x ↦ x e` for at least one coordinate `i`. -/\n  proper : ∀ e, ∃ i, idxFun i = Sum.inr e\n\n"}
{"name":"Combinatorics.Subspace.ext_iff","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"η : Type u_5\nα : Type u_6\nι : Type u_7\nx y : Combinatorics.Subspace η α ι\n⊢ Iff (Eq x y) (Eq x.idxFun y.idxFun)","decl":"/-- The type of combinatorial subspaces. A subspace `l : Subspace η α ι` in the hypercube `ι → α`\ndefines a function `(η → α) → ι → α` from `η → α` to the hypercube, such that for each coordinate\n`i : ι` and direction `e : η`, the function `fun x ↦ l x i` is either `fun x ↦ x e` for some\ndirection `e : η` or constant. We require subspaces to be non-degenerate in the sense that, for\nevery `e : η`, `fun x ↦ l x i` is `fun x ↦ x e` for at least one `i`.\n\nFormally, a subspace is represented by a word `l.idxFun : ι → α ⊕ η` which says whether\n`fun x ↦ l x i` is `fun x ↦ x e` (corresponding to `l.idxFun i = Sum.inr e`) or constantly `a`\n(corresponding to `l.idxFun i = Sum.inl a`).\n\nWhen `α` has size `1` there can be many elements of `Subspace η α ι` defining the same function. -/\n@[ext]\nstructure Subspace (η α ι : Type*) where\n  /-- The word representing a combinatorial subspace. `l.idxfun i = Sum.inr e` means that\n  `l x i = x e` for all `x` and `l.idxfun i = some a` means that `l x i = a` for all `x`. -/\n  idxFun : ι → α ⊕ η\n  /-- We require combinatorial subspaces to be nontrivial in the sense that `fun x ↦ l x i` is\n  `fun x ↦ x e` for at least one coordinate `i`. -/\n  proper : ∀ e, ∃ i, idxFun i = Sum.inr e\n\n"}
{"name":"Combinatorics.Subspace.proper","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"η : Type u_5\nα : Type u_6\nι : Type u_7\nself : Combinatorics.Subspace η α ι\ne : η\n⊢ Exists fun i => Eq (self.idxFun i) (Sum.inr e)","decl":"/-- The type of combinatorial subspaces. A subspace `l : Subspace η α ι` in the hypercube `ι → α`\ndefines a function `(η → α) → ι → α` from `η → α` to the hypercube, such that for each coordinate\n`i : ι` and direction `e : η`, the function `fun x ↦ l x i` is either `fun x ↦ x e` for some\ndirection `e : η` or constant. We require subspaces to be non-degenerate in the sense that, for\nevery `e : η`, `fun x ↦ l x i` is `fun x ↦ x e` for at least one `i`.\n\nFormally, a subspace is represented by a word `l.idxFun : ι → α ⊕ η` which says whether\n`fun x ↦ l x i` is `fun x ↦ x e` (corresponding to `l.idxFun i = Sum.inr e`) or constantly `a`\n(corresponding to `l.idxFun i = Sum.inl a`).\n\nWhen `α` has size `1` there can be many elements of `Subspace η α ι` defining the same function. -/\n@[ext]\nstructure Subspace (η α ι : Type*) where\n  /-- The word representing a combinatorial subspace. `l.idxfun i = Sum.inr e` means that\n  `l x i = x e` for all `x` and `l.idxfun i = some a` means that `l x i = a` for all `x`. -/\n  idxFun : ι → α ⊕ η\n  /-- We require combinatorial subspaces to be nontrivial in the sense that `fun x ↦ l x i` is\n  `fun x ↦ x e` for at least one coordinate `i`. -/\n  proper : ∀ e, ∃ i, idxFun i = Sum.inr e\n\n"}
{"name":"Combinatorics.Subspace.mk.injEq","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"η : Type u_5\nα : Type u_6\nι : Type u_7\nidxFun✝ : ι → Sum α η\nproper✝ : ∀ (e : η), Exists fun i => Eq (idxFun✝ i) (Sum.inr e)\nidxFun : ι → Sum α η\nproper : ∀ (e : η), Exists fun i => Eq (idxFun i) (Sum.inr e)\n⊢ Eq (Eq { idxFun := idxFun✝, proper := proper✝ } { idxFun := idxFun, proper := proper }) (Eq idxFun✝ idxFun)","decl":"/-- The type of combinatorial subspaces. A subspace `l : Subspace η α ι` in the hypercube `ι → α`\ndefines a function `(η → α) → ι → α` from `η → α` to the hypercube, such that for each coordinate\n`i : ι` and direction `e : η`, the function `fun x ↦ l x i` is either `fun x ↦ x e` for some\ndirection `e : η` or constant. We require subspaces to be non-degenerate in the sense that, for\nevery `e : η`, `fun x ↦ l x i` is `fun x ↦ x e` for at least one `i`.\n\nFormally, a subspace is represented by a word `l.idxFun : ι → α ⊕ η` which says whether\n`fun x ↦ l x i` is `fun x ↦ x e` (corresponding to `l.idxFun i = Sum.inr e`) or constantly `a`\n(corresponding to `l.idxFun i = Sum.inl a`).\n\nWhen `α` has size `1` there can be many elements of `Subspace η α ι` defining the same function. -/\n@[ext]\nstructure Subspace (η α ι : Type*) where\n  /-- The word representing a combinatorial subspace. `l.idxfun i = Sum.inr e` means that\n  `l x i = x e` for all `x` and `l.idxfun i = some a` means that `l x i = a` for all `x`. -/\n  idxFun : ι → α ⊕ η\n  /-- We require combinatorial subspaces to be nontrivial in the sense that `fun x ↦ l x i` is\n  `fun x ↦ x e` for at least one coordinate `i`. -/\n  proper : ∀ e, ∃ i, idxFun i = Sum.inr e\n\n"}
{"name":"Combinatorics.Subspace.mk.inj","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"η : Type u_5\nα : Type u_6\nι : Type u_7\nidxFun✝ : ι → Sum α η\nproper✝ : ∀ (e : η), Exists fun i => Eq (idxFun✝ i) (Sum.inr e)\nidxFun : ι → Sum α η\nproper : ∀ (e : η), Exists fun i => Eq (idxFun i) (Sum.inr e)\nx✝ : Eq { idxFun := idxFun✝, proper := proper✝ } { idxFun := idxFun, proper := proper }\n⊢ Eq idxFun✝ idxFun","decl":"/-- The type of combinatorial subspaces. A subspace `l : Subspace η α ι` in the hypercube `ι → α`\ndefines a function `(η → α) → ι → α` from `η → α` to the hypercube, such that for each coordinate\n`i : ι` and direction `e : η`, the function `fun x ↦ l x i` is either `fun x ↦ x e` for some\ndirection `e : η` or constant. We require subspaces to be non-degenerate in the sense that, for\nevery `e : η`, `fun x ↦ l x i` is `fun x ↦ x e` for at least one `i`.\n\nFormally, a subspace is represented by a word `l.idxFun : ι → α ⊕ η` which says whether\n`fun x ↦ l x i` is `fun x ↦ x e` (corresponding to `l.idxFun i = Sum.inr e`) or constantly `a`\n(corresponding to `l.idxFun i = Sum.inl a`).\n\nWhen `α` has size `1` there can be many elements of `Subspace η α ι` defining the same function. -/\n@[ext]\nstructure Subspace (η α ι : Type*) where\n  /-- The word representing a combinatorial subspace. `l.idxfun i = Sum.inr e` means that\n  `l x i = x e` for all `x` and `l.idxfun i = some a` means that `l x i = a` for all `x`. -/\n  idxFun : ι → α ⊕ η\n  /-- We require combinatorial subspaces to be nontrivial in the sense that `fun x ↦ l x i` is\n  `fun x ↦ x e` for at least one coordinate `i`. -/\n  proper : ∀ e, ∃ i, idxFun i = Sum.inr e\n\n"}
{"name":"Combinatorics.Subspace.ext","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"η : Type u_5\nα : Type u_6\nι : Type u_7\nx y : Combinatorics.Subspace η α ι\nidxFun : Eq x.idxFun y.idxFun\n⊢ Eq x y","decl":"/-- The type of combinatorial subspaces. A subspace `l : Subspace η α ι` in the hypercube `ι → α`\ndefines a function `(η → α) → ι → α` from `η → α` to the hypercube, such that for each coordinate\n`i : ι` and direction `e : η`, the function `fun x ↦ l x i` is either `fun x ↦ x e` for some\ndirection `e : η` or constant. We require subspaces to be non-degenerate in the sense that, for\nevery `e : η`, `fun x ↦ l x i` is `fun x ↦ x e` for at least one `i`.\n\nFormally, a subspace is represented by a word `l.idxFun : ι → α ⊕ η` which says whether\n`fun x ↦ l x i` is `fun x ↦ x e` (corresponding to `l.idxFun i = Sum.inr e`) or constantly `a`\n(corresponding to `l.idxFun i = Sum.inl a`).\n\nWhen `α` has size `1` there can be many elements of `Subspace η α ι` defining the same function. -/\n@[ext]\nstructure Subspace (η α ι : Type*) where\n  /-- The word representing a combinatorial subspace. `l.idxfun i = Sum.inr e` means that\n  `l x i = x e` for all `x` and `l.idxfun i = some a` means that `l x i = a` for all `x`. -/\n  idxFun : ι → α ⊕ η\n  /-- We require combinatorial subspaces to be nontrivial in the sense that `fun x ↦ l x i` is\n  `fun x ↦ x e` for at least one coordinate `i`. -/\n  proper : ∀ e, ∃ i, idxFun i = Sum.inr e\n\n"}
{"name":"Combinatorics.Subspace.coe_apply","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"η : Type u_5\nα : Type u_6\nι : Type u_7\nl : Combinatorics.Subspace η α ι\nx : η → α\ni : ι\n⊢ Eq (↑l x i) (Sum.elim id x (l.idxFun i))","decl":"lemma coe_apply (l : Subspace η α ι) (x : η → α) (i : ι) : l x i = (l.idxFun i).elim id x := rfl\n\n-- Note: This is not made a `FunLike` instance to avoid having two syntactically different coercions\n"}
{"name":"Combinatorics.Subspace.coe_injective","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"η : Type u_5\nα : Type u_6\nι : Type u_7\ninst✝ : Nontrivial α\n⊢ Function.Injective Combinatorics.Subspace.toFun","decl":"lemma coe_injective [Nontrivial α] : Injective ((⇑) : Subspace η α ι → (η → α) → ι → α) := by\n  classical\n  rintro l m hlm\n  ext i\n  simp only [funext_iff] at hlm\n  cases hl : idxFun l i with\n  | inl a =>\n    obtain ⟨b, hba⟩ := exists_ne a\n    cases hm : idxFun m i <;> simpa [hl, hm, hba.symm, coe_apply] using hlm (const _ b) i\n  | inr e =>\n    cases hm : idxFun m i with\n    | inl a =>\n      obtain ⟨b, hba⟩ := exists_ne a\n      simpa [hl, hm, hba, coe_apply] using hlm (const _ b) i\n    | inr f =>\n      obtain ⟨a, b, hab⟩ := exists_pair_ne α\n      simp only [Sum.inr.injEq]\n      by_contra! hef\n      simpa [hl, hm, hef, hab, coe_apply] using hlm (Function.update (const _ a) f b) i\n\n"}
{"name":"Combinatorics.Subspace.apply_def","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"η : Type u_5\nα : Type u_6\nι : Type u_7\nl : Combinatorics.Subspace η α ι\nx : η → α\ni : ι\n⊢ Eq (↑l x i) (Sum.elim id x (l.idxFun i))","decl":"lemma apply_def (l : Subspace η α ι) (x : η → α) (i : ι) : l x i = (l.idxFun i).elim id x := rfl\n"}
{"name":"Combinatorics.Subspace.apply_inl","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"η : Type u_5\nα : Type u_6\nι : Type u_7\nl : Combinatorics.Subspace η α ι\nx : η → α\ni : ι\na : α\nh : Eq (l.idxFun i) (Sum.inl a)\n⊢ Eq (↑l x i) a","decl":"lemma apply_inl (h : l.idxFun i = Sum.inl a) : l x i = a := by simp [apply_def, h]\n"}
{"name":"Combinatorics.Subspace.apply_inr","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"η : Type u_5\nα : Type u_6\nι : Type u_7\nl : Combinatorics.Subspace η α ι\nx : η → α\ni : ι\ne : η\nh : Eq (l.idxFun i) (Sum.inr e)\n⊢ Eq (↑l x i) (x e)","decl":"lemma apply_inr (h : l.idxFun i = Sum.inr e) : l x i = x e := by simp [apply_def, h]\n\n"}
{"name":"Combinatorics.Subspace.reindex_apply","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"η : Type u_5\nα : Type u_6\nι : Type u_7\nη' : Type u_9\nα' : Type u_10\nι' : Type u_11\nl : Combinatorics.Subspace η α ι\neη : Equiv η η'\neα : Equiv α α'\neι : Equiv ι ι'\nx : η' → α'\ni : ι'\n⊢ Eq (↑(l.reindex eη eα eι) x i) (eα (↑l (Function.comp (⇑eα.symm) (Function.comp x ⇑eη)) (eι.symm i)))","decl":"@[simp] lemma reindex_apply (l : Subspace η α ι) (eη : η ≃ η') (eα : α ≃ α') (eι : ι ≃ ι') (x i) :\n    l.reindex eη eα eι x i = eα (l (eα.symm ∘ x ∘ eη) <| eι.symm i) := by\n  cases h : l.idxFun (eι.symm i) <;> simp [h, reindex, coe_apply]\n\n"}
{"name":"Combinatorics.Subspace.reindex_isMono","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"η : Type u_5\nα : Type u_6\nι : Type u_7\nκ : Type u_8\nl : Combinatorics.Subspace η α ι\nη' : Type u_9\nα' : Type u_10\nι' : Type u_11\neη : Equiv η η'\neα : Equiv α α'\neι : Equiv ι ι'\nC : (ι' → α') → κ\n⊢ Iff (Combinatorics.Subspace.IsMono C (l.reindex eη eα eι)) (Combinatorics.Subspace.IsMono (fun x => C (Function.comp (⇑eα) (Function.comp x ⇑eι.symm))) l)","decl":"@[simp] lemma reindex_isMono {eη : η ≃ η'} {eα : α ≃ α'} {eι : ι ≃ ι'} {C : (ι' → α') → κ} :\n    (l.reindex eη eα eι).IsMono C ↔ l.IsMono fun x ↦ C <| eα ∘ x ∘ eι.symm := by\n  simp only [IsMono, funext (reindex_apply _ _ _ _ _), coe_apply]\n  exact exists_congr fun c ↦ (eη.arrowCongr eα).symm.forall_congr <| by aesop\n\n"}
{"name":"Combinatorics.Subspace.IsMono.reindex","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"η : Type u_5\nα : Type u_6\nι : Type u_7\nκ : Type u_8\nl : Combinatorics.Subspace η α ι\nη' : Type u_9\nα' : Type u_10\nι' : Type u_11\neη : Equiv η η'\neα : Equiv α α'\neι : Equiv ι ι'\nC : (ι → α) → κ\nhl : Combinatorics.Subspace.IsMono C l\n⊢ Combinatorics.Subspace.IsMono (fun x => C (Function.comp (⇑eα.symm) (Function.comp x ⇑eι))) (l.reindex eη eα eι)","decl":"protected lemma IsMono.reindex {eη : η ≃ η'} {eα : α ≃ α'} {eι : ι ≃ ι'} {C : (ι → α) → κ}\n    (hl : l.IsMono C) : (l.reindex eη eα eι).IsMono fun x ↦ C <| eα.symm ∘ x ∘ eι := by\n  simp [reindex_isMono, Function.comp_assoc]; simpa [← Function.comp_assoc]\n\n"}
{"name":"Combinatorics.Line.ext_iff","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_5\nι : Type u_6\nx y : Combinatorics.Line α ι\n⊢ Iff (Eq x y) (Eq x.idxFun y.idxFun)","decl":"/-- The type of combinatorial lines. A line `l : Line α ι` in the hypercube `ι → α` defines a\nfunction `α → ι → α` from `α` to the hypercube, such that for each coordinate `i : ι`, the function\n`fun x ↦ l x i` is either `id` or constant. We require lines to be nontrivial in the sense that\n`fun x ↦ l x i` is `id` for at least one `i`.\n\nFormally, a line is represented by a word `l.idxFun : ι → Option α` which says whether\n`fun x ↦ l x i` is `id` (corresponding to `l.idxFun i = none`) or constantly `y` (corresponding to\n`l.idxFun i = some y`).\n\nWhen `α` has size `1` there can be many elements of `Line α ι` defining the same function. -/\n@[ext]\nstructure Line (α ι : Type*) where\n  /-- The word representing a combinatorial line. `l.idxfun i = none` means that\n  `l x i = x` for all `x` and `l.idxfun i = some y` means that `l x i = y`. -/\n  idxFun : ι → Option α\n  /-- We require combinatorial lines to be nontrivial in the sense that `fun x ↦ l x i` is `id` for\n  at least one coordinate `i`. -/\n  proper : ∃ i, idxFun i = none\n\n"}
{"name":"Combinatorics.Line.ext","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_5\nι : Type u_6\nx y : Combinatorics.Line α ι\nidxFun : Eq x.idxFun y.idxFun\n⊢ Eq x y","decl":"/-- The type of combinatorial lines. A line `l : Line α ι` in the hypercube `ι → α` defines a\nfunction `α → ι → α` from `α` to the hypercube, such that for each coordinate `i : ι`, the function\n`fun x ↦ l x i` is either `id` or constant. We require lines to be nontrivial in the sense that\n`fun x ↦ l x i` is `id` for at least one `i`.\n\nFormally, a line is represented by a word `l.idxFun : ι → Option α` which says whether\n`fun x ↦ l x i` is `id` (corresponding to `l.idxFun i = none`) or constantly `y` (corresponding to\n`l.idxFun i = some y`).\n\nWhen `α` has size `1` there can be many elements of `Line α ι` defining the same function. -/\n@[ext]\nstructure Line (α ι : Type*) where\n  /-- The word representing a combinatorial line. `l.idxfun i = none` means that\n  `l x i = x` for all `x` and `l.idxfun i = some y` means that `l x i = y`. -/\n  idxFun : ι → Option α\n  /-- We require combinatorial lines to be nontrivial in the sense that `fun x ↦ l x i` is `id` for\n  at least one coordinate `i`. -/\n  proper : ∃ i, idxFun i = none\n\n"}
{"name":"Combinatorics.Line.mk.injEq","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_5\nι : Type u_6\nidxFun✝ : ι → Option α\nproper✝ : Exists fun i => Eq (idxFun✝ i) Option.none\nidxFun : ι → Option α\nproper : Exists fun i => Eq (idxFun i) Option.none\n⊢ Eq (Eq { idxFun := idxFun✝, proper := proper✝ } { idxFun := idxFun, proper := proper }) (Eq idxFun✝ idxFun)","decl":"/-- The type of combinatorial lines. A line `l : Line α ι` in the hypercube `ι → α` defines a\nfunction `α → ι → α` from `α` to the hypercube, such that for each coordinate `i : ι`, the function\n`fun x ↦ l x i` is either `id` or constant. We require lines to be nontrivial in the sense that\n`fun x ↦ l x i` is `id` for at least one `i`.\n\nFormally, a line is represented by a word `l.idxFun : ι → Option α` which says whether\n`fun x ↦ l x i` is `id` (corresponding to `l.idxFun i = none`) or constantly `y` (corresponding to\n`l.idxFun i = some y`).\n\nWhen `α` has size `1` there can be many elements of `Line α ι` defining the same function. -/\n@[ext]\nstructure Line (α ι : Type*) where\n  /-- The word representing a combinatorial line. `l.idxfun i = none` means that\n  `l x i = x` for all `x` and `l.idxfun i = some y` means that `l x i = y`. -/\n  idxFun : ι → Option α\n  /-- We require combinatorial lines to be nontrivial in the sense that `fun x ↦ l x i` is `id` for\n  at least one coordinate `i`. -/\n  proper : ∃ i, idxFun i = none\n\n"}
{"name":"Combinatorics.Line.mk.sizeOf_spec","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_5\nι : Type u_6\ninst✝¹ : SizeOf α\ninst✝ : SizeOf ι\nidxFun : ι → Option α\nproper : Exists fun i => Eq (idxFun i) Option.none\n⊢ Eq (SizeOf.sizeOf { idxFun := idxFun, proper := proper }) (HAdd.hAdd 1 (SizeOf.sizeOf proper))","decl":"/-- The type of combinatorial lines. A line `l : Line α ι` in the hypercube `ι → α` defines a\nfunction `α → ι → α` from `α` to the hypercube, such that for each coordinate `i : ι`, the function\n`fun x ↦ l x i` is either `id` or constant. We require lines to be nontrivial in the sense that\n`fun x ↦ l x i` is `id` for at least one `i`.\n\nFormally, a line is represented by a word `l.idxFun : ι → Option α` which says whether\n`fun x ↦ l x i` is `id` (corresponding to `l.idxFun i = none`) or constantly `y` (corresponding to\n`l.idxFun i = some y`).\n\nWhen `α` has size `1` there can be many elements of `Line α ι` defining the same function. -/\n@[ext]\nstructure Line (α ι : Type*) where\n  /-- The word representing a combinatorial line. `l.idxfun i = none` means that\n  `l x i = x` for all `x` and `l.idxfun i = some y` means that `l x i = y`. -/\n  idxFun : ι → Option α\n  /-- We require combinatorial lines to be nontrivial in the sense that `fun x ↦ l x i` is `id` for\n  at least one coordinate `i`. -/\n  proper : ∃ i, idxFun i = none\n\n"}
{"name":"Combinatorics.Line.proper","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_5\nι : Type u_6\nself : Combinatorics.Line α ι\n⊢ Exists fun i => Eq (self.idxFun i) Option.none","decl":"/-- The type of combinatorial lines. A line `l : Line α ι` in the hypercube `ι → α` defines a\nfunction `α → ι → α` from `α` to the hypercube, such that for each coordinate `i : ι`, the function\n`fun x ↦ l x i` is either `id` or constant. We require lines to be nontrivial in the sense that\n`fun x ↦ l x i` is `id` for at least one `i`.\n\nFormally, a line is represented by a word `l.idxFun : ι → Option α` which says whether\n`fun x ↦ l x i` is `id` (corresponding to `l.idxFun i = none`) or constantly `y` (corresponding to\n`l.idxFun i = some y`).\n\nWhen `α` has size `1` there can be many elements of `Line α ι` defining the same function. -/\n@[ext]\nstructure Line (α ι : Type*) where\n  /-- The word representing a combinatorial line. `l.idxfun i = none` means that\n  `l x i = x` for all `x` and `l.idxfun i = some y` means that `l x i = y`. -/\n  idxFun : ι → Option α\n  /-- We require combinatorial lines to be nontrivial in the sense that `fun x ↦ l x i` is `id` for\n  at least one coordinate `i`. -/\n  proper : ∃ i, idxFun i = none\n\n"}
{"name":"Combinatorics.Line.mk.inj","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_5\nι : Type u_6\nidxFun✝ : ι → Option α\nproper✝ : Exists fun i => Eq (idxFun✝ i) Option.none\nidxFun : ι → Option α\nproper : Exists fun i => Eq (idxFun i) Option.none\nx✝ : Eq { idxFun := idxFun✝, proper := proper✝ } { idxFun := idxFun, proper := proper }\n⊢ Eq idxFun✝ idxFun","decl":"/-- The type of combinatorial lines. A line `l : Line α ι` in the hypercube `ι → α` defines a\nfunction `α → ι → α` from `α` to the hypercube, such that for each coordinate `i : ι`, the function\n`fun x ↦ l x i` is either `id` or constant. We require lines to be nontrivial in the sense that\n`fun x ↦ l x i` is `id` for at least one `i`.\n\nFormally, a line is represented by a word `l.idxFun : ι → Option α` which says whether\n`fun x ↦ l x i` is `id` (corresponding to `l.idxFun i = none`) or constantly `y` (corresponding to\n`l.idxFun i = some y`).\n\nWhen `α` has size `1` there can be many elements of `Line α ι` defining the same function. -/\n@[ext]\nstructure Line (α ι : Type*) where\n  /-- The word representing a combinatorial line. `l.idxfun i = none` means that\n  `l x i = x` for all `x` and `l.idxfun i = some y` means that `l x i = y`. -/\n  idxFun : ι → Option α\n  /-- We require combinatorial lines to be nontrivial in the sense that `fun x ↦ l x i` is `id` for\n  at least one coordinate `i`. -/\n  proper : ∃ i, idxFun i = none\n\n"}
{"name":"Combinatorics.Line.coe_apply","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_2\nι : Type u_3\nl : Combinatorics.Line α ι\nx : α\ni : ι\n⊢ Eq ((fun x i => (l.idxFun i).getD x) x i) ((l.idxFun i).getD x)","decl":"lemma coe_apply (l : Line α ι) (x : α) (i : ι) : l x i = (l.idxFun i).getD x := rfl\n\n-- Note: This is not made a `FunLike` instance to avoid having two syntactically different coercions\n"}
{"name":"Combinatorics.Line.coe_injective","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_2\nι : Type u_3\ninst✝ : Nontrivial α\n⊢ Function.Injective fun x x_1 i => (x.idxFun i).getD x_1","decl":"lemma coe_injective [Nontrivial α] : Injective ((⇑) : Line α ι → α → ι → α) := by\n  rintro l m hlm\n  ext i a\n  obtain ⟨b, hba⟩ := exists_ne a\n  simp only [Option.mem_def, funext_iff] at hlm ⊢\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · cases hi : idxFun m i <;> simpa [@eq_comm _ a, hi, h, hba] using hlm b i\n  · cases hi : idxFun l i <;> simpa [@eq_comm _ a, hi, h, hba] using hlm b i\n\n"}
{"name":"Combinatorics.Line.toSubspaceUnit_apply","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_2\nι : Type u_3\nl : Combinatorics.Line α ι\na : Unit → α\n⊢ Eq (↑l.toSubspaceUnit a) ((fun x i => (l.idxFun i).getD x) (a Unit.unit))","decl":"@[simp] lemma toSubspaceUnit_apply (l : Line α ι) (a) : ⇑l.toSubspaceUnit a = l (a ()) := by\n  ext i; cases h : l.idxFun i <;> simp [toSubspaceUnit, h, Subspace.coe_apply]\n\n"}
{"name":"Combinatorics.Line.toSubspaceUnit_isMono","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_2\nι : Type u_3\nκ : Type u_4\nl : Combinatorics.Line α ι\nC : (ι → α) → κ\n⊢ Iff (Combinatorics.Subspace.IsMono C l.toSubspaceUnit) (Combinatorics.Line.IsMono C l)","decl":"@[simp] lemma toSubspaceUnit_isMono {C : (ι → α) → κ} : l.toSubspaceUnit.IsMono C ↔ l.IsMono C := by\n  simp only [Subspace.IsMono, toSubspaceUnit_apply, IsMono]\n  exact exists_congr fun c ↦ ⟨fun h a ↦ h fun _ ↦ a, fun h a ↦ h _⟩\n\n"}
{"name":"Combinatorics.Line.IsMono.toSubspaceUnit","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_2\nι : Type u_3\nκ : Type u_4\nl : Combinatorics.Line α ι\nC : (ι → α) → κ\na✝ : Combinatorics.Line.IsMono C l\n⊢ Combinatorics.Subspace.IsMono C l.toSubspaceUnit","decl":"protected alias ⟨_, IsMono.toSubspaceUnit⟩ := toSubspaceUnit_isMono\n\n"}
{"name":"Combinatorics.Line.toSubspace_apply","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"η : Type u_1\nα : Type u_2\nι : Type u_3\nl : Combinatorics.Line (η → α) ι\na : η → α\nie : Prod ι η\n⊢ Eq (↑l.toSubspace a ie) ((fun x i => (l.idxFun i).getD x) a ie.1 ie.2)","decl":"@[simp] lemma toSubspace_apply (l : Line (η → α) ι) (a ie) :\n    ⇑l.toSubspace a ie = l a ie.1 ie.2 := by\n  cases h : l.idxFun ie.1 <;> simp [toSubspace, h, coe_apply, Subspace.coe_apply]\n\n"}
{"name":"Combinatorics.Line.toSubspace_isMono","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"η : Type u_1\nα : Type u_2\nι : Type u_3\nκ : Type u_4\nl : Combinatorics.Line (η → α) ι\nC : (Prod ι η → α) → κ\n⊢ Iff (Combinatorics.Subspace.IsMono C l.toSubspace) (Combinatorics.Line.IsMono (fun x => C fun x_1 => Combinatorics.Line.toSubspace_isMono.match_1 (fun x => α) x_1 fun i e => x i e) l)","decl":"@[simp] lemma toSubspace_isMono {l : Line (η → α) ι} {C : (ι × η → α) → κ} :\n    l.toSubspace.IsMono C ↔ l.IsMono fun x : ι → η → α  ↦ C fun (i, e) ↦ x i e := by\n  simp [Subspace.IsMono, IsMono, funext (toSubspace_apply _ _)]\n\n"}
{"name":"Combinatorics.Line.IsMono.toSubspace","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"η : Type u_1\nα : Type u_2\nι : Type u_3\nκ : Type u_4\nl : Combinatorics.Line (η → α) ι\nC : (Prod ι η → α) → κ\na✝ : Combinatorics.Line.IsMono (fun x => C fun x_1 => Combinatorics.Line.toSubspace_isMono.match_1 (fun x => α) x_1 fun i e => x i e) l\n⊢ Combinatorics.Subspace.IsMono C l.toSubspace","decl":"protected alias ⟨_, IsMono.toSubspace⟩ := toSubspace_isMono\n\n"}
{"name":"Combinatorics.Line.AlmostMono.has_color","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_5\nι : Type u_6\nκ : Type u_7\nC : (ι → Option α) → κ\nself : Combinatorics.Line.AlmostMono C\nx : α\n⊢ Eq (C ((fun x i => (self.line.idxFun i).getD x) (Option.some x))) self.color","decl":"/-- The type of lines that are only one color except possibly at their endpoints. -/\nstructure AlmostMono {α ι κ : Type*} (C : (ι → Option α) → κ) where\n  /-- The underlying line of an almost monochromatic line, where the coordinate dimension `α` is\n  extended by an additional symbol `none`, thought to be marking the endpoint of the line. -/\n  line : Line (Option α) ι\n  /-- The main color of an almost monochromatic line. -/\n  color : κ\n  /-- The proposition that the underlying line of an almost monochromatic line assumes its main\n  color except possibly at the endpoints. -/\n  has_color : ∀ x : α, C (line (some x)) = color\n\n"}
{"name":"Combinatorics.Line.AlmostMono.mk.inj","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_5\nι : Type u_6\nκ : Type u_7\nC : (ι → Option α) → κ\nline✝ : Combinatorics.Line (Option α) ι\ncolor✝ : κ\nhas_color✝ : ∀ (x : α), Eq (C ((fun x i => (line✝.idxFun i).getD x) (Option.some x))) color✝\nline : Combinatorics.Line (Option α) ι\ncolor : κ\nhas_color : ∀ (x : α), Eq (C ((fun x i => (line.idxFun i).getD x) (Option.some x))) color\nx✝ : Eq { line := line✝, color := color✝, has_color := has_color✝ } { line := line, color := color, has_color := has_color }\n⊢ And (Eq line✝ line) (Eq color✝ color)","decl":"/-- The type of lines that are only one color except possibly at their endpoints. -/\nstructure AlmostMono {α ι κ : Type*} (C : (ι → Option α) → κ) where\n  /-- The underlying line of an almost monochromatic line, where the coordinate dimension `α` is\n  extended by an additional symbol `none`, thought to be marking the endpoint of the line. -/\n  line : Line (Option α) ι\n  /-- The main color of an almost monochromatic line. -/\n  color : κ\n  /-- The proposition that the underlying line of an almost monochromatic line assumes its main\n  color except possibly at the endpoints. -/\n  has_color : ∀ x : α, C (line (some x)) = color\n\n"}
{"name":"Combinatorics.Line.AlmostMono.mk.injEq","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_5\nι : Type u_6\nκ : Type u_7\nC : (ι → Option α) → κ\nline✝ : Combinatorics.Line (Option α) ι\ncolor✝ : κ\nhas_color✝ : ∀ (x : α), Eq (C ((fun x i => (line✝.idxFun i).getD x) (Option.some x))) color✝\nline : Combinatorics.Line (Option α) ι\ncolor : κ\nhas_color : ∀ (x : α), Eq (C ((fun x i => (line.idxFun i).getD x) (Option.some x))) color\n⊢ Eq (Eq { line := line✝, color := color✝, has_color := has_color✝ } { line := line, color := color, has_color := has_color }) (And (Eq line✝ line) (Eq color✝ color))","decl":"/-- The type of lines that are only one color except possibly at their endpoints. -/\nstructure AlmostMono {α ι κ : Type*} (C : (ι → Option α) → κ) where\n  /-- The underlying line of an almost monochromatic line, where the coordinate dimension `α` is\n  extended by an additional symbol `none`, thought to be marking the endpoint of the line. -/\n  line : Line (Option α) ι\n  /-- The main color of an almost monochromatic line. -/\n  color : κ\n  /-- The proposition that the underlying line of an almost monochromatic line assumes its main\n  color except possibly at the endpoints. -/\n  has_color : ∀ x : α, C (line (some x)) = color\n\n"}
{"name":"Combinatorics.Line.AlmostMono.mk.sizeOf_spec","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_5\nι : Type u_6\nκ : Type u_7\nC : (ι → Option α) → κ\ninst✝² : SizeOf α\ninst✝¹ : SizeOf ι\ninst✝ : SizeOf κ\nline : Combinatorics.Line (Option α) ι\ncolor : κ\nhas_color : ∀ (x : α), Eq (C ((fun x i => (line.idxFun i).getD x) (Option.some x))) color\n⊢ Eq (SizeOf.sizeOf { line := line, color := color, has_color := has_color }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf line)) (SizeOf.sizeOf color))","decl":"/-- The type of lines that are only one color except possibly at their endpoints. -/\nstructure AlmostMono {α ι κ : Type*} (C : (ι → Option α) → κ) where\n  /-- The underlying line of an almost monochromatic line, where the coordinate dimension `α` is\n  extended by an additional symbol `none`, thought to be marking the endpoint of the line. -/\n  line : Line (Option α) ι\n  /-- The main color of an almost monochromatic line. -/\n  color : κ\n  /-- The proposition that the underlying line of an almost monochromatic line assumes its main\n  color except possibly at the endpoints. -/\n  has_color : ∀ x : α, C (line (some x)) = color\n\n"}
{"name":"Combinatorics.Line.ColorFocused.mk.sizeOf_spec","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_5\nι : Type u_6\nκ : Type u_7\nC : (ι → Option α) → κ\ninst✝² : SizeOf α\ninst✝¹ : SizeOf ι\ninst✝ : SizeOf κ\nlines : Multiset (Combinatorics.Line.AlmostMono C)\nfocus : ι → Option α\nis_focused : ∀ (p : Combinatorics.Line.AlmostMono C), Membership.mem lines p → Eq ((fun x i => (p.line.idxFun i).getD x) Option.none) focus\ndistinct_colors : (Multiset.map Combinatorics.Line.AlmostMono.color lines).Nodup\n⊢ Eq (SizeOf.sizeOf { lines := lines, focus := focus, is_focused := is_focused, distinct_colors := distinct_colors }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf lines)) (SizeOf.sizeOf distinct_colors))","decl":"/-- The type of collections of lines such that\n- each line is only one color except possibly at its endpoint\n- the lines all have the same endpoint\n- the colors of the lines are distinct.\nUsed in the proof `exists_mono_in_high_dimension`. -/\nstructure ColorFocused {α ι κ : Type*} (C : (ι → Option α) → κ) where\n  /-- The underlying multiset of almost monochromatic lines of a color-focused collection. -/\n  lines : Multiset (AlmostMono C)\n  /-- The common endpoint of the lines in the color-focused collection. -/\n  focus : ι → Option α\n  /-- The proposition that all lines in a color-focused collection have the same endpoint. -/\n  is_focused : ∀ p ∈ lines, p.line none = focus\n  /-- The proposition that all lines in a color-focused collection of lines have distinct colors. -/\n  distinct_colors : (lines.map AlmostMono.color).Nodup\n\n"}
{"name":"Combinatorics.Line.ColorFocused.mk.injEq","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_5\nι : Type u_6\nκ : Type u_7\nC : (ι → Option α) → κ\nlines✝ : Multiset (Combinatorics.Line.AlmostMono C)\nfocus✝ : ι → Option α\nis_focused✝ : ∀ (p : Combinatorics.Line.AlmostMono C), Membership.mem lines✝ p → Eq ((fun x i => (p.line.idxFun i).getD x) Option.none) focus✝\ndistinct_colors✝ : (Multiset.map Combinatorics.Line.AlmostMono.color lines✝).Nodup\nlines : Multiset (Combinatorics.Line.AlmostMono C)\nfocus : ι → Option α\nis_focused : ∀ (p : Combinatorics.Line.AlmostMono C), Membership.mem lines p → Eq ((fun x i => (p.line.idxFun i).getD x) Option.none) focus\ndistinct_colors : (Multiset.map Combinatorics.Line.AlmostMono.color lines).Nodup\n⊢ Eq (Eq { lines := lines✝, focus := focus✝, is_focused := is_focused✝, distinct_colors := distinct_colors✝ } { lines := lines, focus := focus, is_focused := is_focused, distinct_colors := distinct_colors }) (And (Eq lines✝ lines) (Eq focus✝ focus))","decl":"/-- The type of collections of lines such that\n- each line is only one color except possibly at its endpoint\n- the lines all have the same endpoint\n- the colors of the lines are distinct.\nUsed in the proof `exists_mono_in_high_dimension`. -/\nstructure ColorFocused {α ι κ : Type*} (C : (ι → Option α) → κ) where\n  /-- The underlying multiset of almost monochromatic lines of a color-focused collection. -/\n  lines : Multiset (AlmostMono C)\n  /-- The common endpoint of the lines in the color-focused collection. -/\n  focus : ι → Option α\n  /-- The proposition that all lines in a color-focused collection have the same endpoint. -/\n  is_focused : ∀ p ∈ lines, p.line none = focus\n  /-- The proposition that all lines in a color-focused collection of lines have distinct colors. -/\n  distinct_colors : (lines.map AlmostMono.color).Nodup\n\n"}
{"name":"Combinatorics.Line.ColorFocused.distinct_colors","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_5\nι : Type u_6\nκ : Type u_7\nC : (ι → Option α) → κ\nself : Combinatorics.Line.ColorFocused C\n⊢ (Multiset.map Combinatorics.Line.AlmostMono.color self.lines).Nodup","decl":"/-- The type of collections of lines such that\n- each line is only one color except possibly at its endpoint\n- the lines all have the same endpoint\n- the colors of the lines are distinct.\nUsed in the proof `exists_mono_in_high_dimension`. -/\nstructure ColorFocused {α ι κ : Type*} (C : (ι → Option α) → κ) where\n  /-- The underlying multiset of almost monochromatic lines of a color-focused collection. -/\n  lines : Multiset (AlmostMono C)\n  /-- The common endpoint of the lines in the color-focused collection. -/\n  focus : ι → Option α\n  /-- The proposition that all lines in a color-focused collection have the same endpoint. -/\n  is_focused : ∀ p ∈ lines, p.line none = focus\n  /-- The proposition that all lines in a color-focused collection of lines have distinct colors. -/\n  distinct_colors : (lines.map AlmostMono.color).Nodup\n\n"}
{"name":"Combinatorics.Line.ColorFocused.mk.inj","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_5\nι : Type u_6\nκ : Type u_7\nC : (ι → Option α) → κ\nlines✝ : Multiset (Combinatorics.Line.AlmostMono C)\nfocus✝ : ι → Option α\nis_focused✝ : ∀ (p : Combinatorics.Line.AlmostMono C), Membership.mem lines✝ p → Eq ((fun x i => (p.line.idxFun i).getD x) Option.none) focus✝\ndistinct_colors✝ : (Multiset.map Combinatorics.Line.AlmostMono.color lines✝).Nodup\nlines : Multiset (Combinatorics.Line.AlmostMono C)\nfocus : ι → Option α\nis_focused : ∀ (p : Combinatorics.Line.AlmostMono C), Membership.mem lines p → Eq ((fun x i => (p.line.idxFun i).getD x) Option.none) focus\ndistinct_colors : (Multiset.map Combinatorics.Line.AlmostMono.color lines).Nodup\nx✝ : Eq { lines := lines✝, focus := focus✝, is_focused := is_focused✝, distinct_colors := distinct_colors✝ } { lines := lines, focus := focus, is_focused := is_focused, distinct_colors := distinct_colors }\n⊢ And (Eq lines✝ lines) (Eq focus✝ focus)","decl":"/-- The type of collections of lines such that\n- each line is only one color except possibly at its endpoint\n- the lines all have the same endpoint\n- the colors of the lines are distinct.\nUsed in the proof `exists_mono_in_high_dimension`. -/\nstructure ColorFocused {α ι κ : Type*} (C : (ι → Option α) → κ) where\n  /-- The underlying multiset of almost monochromatic lines of a color-focused collection. -/\n  lines : Multiset (AlmostMono C)\n  /-- The common endpoint of the lines in the color-focused collection. -/\n  focus : ι → Option α\n  /-- The proposition that all lines in a color-focused collection have the same endpoint. -/\n  is_focused : ∀ p ∈ lines, p.line none = focus\n  /-- The proposition that all lines in a color-focused collection of lines have distinct colors. -/\n  distinct_colors : (lines.map AlmostMono.color).Nodup\n\n"}
{"name":"Combinatorics.Line.ColorFocused.is_focused","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_5\nι : Type u_6\nκ : Type u_7\nC : (ι → Option α) → κ\nself : Combinatorics.Line.ColorFocused C\np : Combinatorics.Line.AlmostMono C\na✝ : Membership.mem self.lines p\n⊢ Eq ((fun x i => (p.line.idxFun i).getD x) Option.none) self.focus","decl":"/-- The type of collections of lines such that\n- each line is only one color except possibly at its endpoint\n- the lines all have the same endpoint\n- the colors of the lines are distinct.\nUsed in the proof `exists_mono_in_high_dimension`. -/\nstructure ColorFocused {α ι κ : Type*} (C : (ι → Option α) → κ) where\n  /-- The underlying multiset of almost monochromatic lines of a color-focused collection. -/\n  lines : Multiset (AlmostMono C)\n  /-- The common endpoint of the lines in the color-focused collection. -/\n  focus : ι → Option α\n  /-- The proposition that all lines in a color-focused collection have the same endpoint. -/\n  is_focused : ∀ p ∈ lines, p.line none = focus\n  /-- The proposition that all lines in a color-focused collection of lines have distinct colors. -/\n  distinct_colors : (lines.map AlmostMono.color).Nodup\n\n"}
{"name":"Combinatorics.Line.apply_def","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_2\nι : Type u_3\nl : Combinatorics.Line α ι\nx : α\n⊢ Eq ((fun x i => (l.idxFun i).getD x) x) fun i => (l.idxFun i).getD x","decl":"theorem apply_def (l : Line α ι) (x : α) : l x = fun i => (l.idxFun i).getD x := rfl\n\n"}
{"name":"Combinatorics.Line.apply_none","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_5\nι : Type u_6\nl : Combinatorics.Line α ι\nx : α\ni : ι\nh : Eq (l.idxFun i) Option.none\n⊢ Eq ((fun x i => (l.idxFun i).getD x) x i) x","decl":"theorem apply_none {α ι} (l : Line α ι) (x : α) (i : ι) (h : l.idxFun i = none) : l x i = x := by\n  simp only [Option.getD_none, h, l.apply_def]\n\n"}
{"name":"Combinatorics.Line.apply_some","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_2\nι : Type u_3\nl : Combinatorics.Line α ι\ni : ι\na x : α\nh : Eq (l.idxFun i) (Option.some a)\n⊢ Eq ((fun x i => (l.idxFun i).getD x) x i) a","decl":"lemma apply_some (h : l.idxFun i = some a) : l x i = a := by simp [l.apply_def, h]\n\n"}
{"name":"Combinatorics.Line.map_apply","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_5\nα' : Type u_6\nι : Type u_7\nf : α → α'\nl : Combinatorics.Line α ι\nx : α\n⊢ Eq ((fun x i => ((Combinatorics.Line.map f l).idxFun i).getD x) (f x)) (Function.comp f ((fun x i => (l.idxFun i).getD x) x))","decl":"@[simp]\ntheorem map_apply {α α' ι} (f : α → α') (l : Line α ι) (x : α) : l.map f (f x) = f ∘ l x := by\n  simp only [Line.apply_def, Line.map, Option.getD_map, comp_def]\n\n"}
{"name":"Combinatorics.Line.vertical_apply","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_5\nι : Type u_6\nι' : Type u_7\nv : ι → α\nl : Combinatorics.Line α ι'\nx : α\n⊢ Eq ((fun x i => ((Combinatorics.Line.vertical v l).idxFun i).getD x) x) (Sum.elim v ((fun x i => (l.idxFun i).getD x) x))","decl":"@[simp]\ntheorem vertical_apply {α ι ι'} (v : ι → α) (l : Line α ι') (x : α) :\n    l.vertical v x = Sum.elim v (l x) := by\n  funext i\n  cases i <;> rfl\n\n"}
{"name":"Combinatorics.Line.horizontal_apply","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_5\nι : Type u_6\nι' : Type u_7\nl : Combinatorics.Line α ι\nv : ι' → α\nx : α\n⊢ Eq ((fun x i => ((l.horizontal v).idxFun i).getD x) x) (Sum.elim ((fun x i => (l.idxFun i).getD x) x) v)","decl":"@[simp]\ntheorem horizontal_apply {α ι ι'} (l : Line α ι) (v : ι' → α) (x : α) :\n    l.horizontal v x = Sum.elim (l x) v := by\n  funext i\n  cases i <;> rfl\n\n"}
{"name":"Combinatorics.Line.prod_apply","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_5\nι : Type u_6\nι' : Type u_7\nl : Combinatorics.Line α ι\nl' : Combinatorics.Line α ι'\nx : α\n⊢ Eq ((fun x i => ((l.prod l').idxFun i).getD x) x) (Sum.elim ((fun x i => (l.idxFun i).getD x) x) ((fun x i => (l'.idxFun i).getD x) x))","decl":"@[simp]\ntheorem prod_apply {α ι ι'} (l : Line α ι) (l' : Line α ι') (x : α) :\n    l.prod l' x = Sum.elim (l x) (l' x) := by\n  funext i\n  cases i <;> rfl\n\n"}
{"name":"Combinatorics.Line.diagonal_apply","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_5\nι : Type u_6\ninst✝ : Nonempty ι\nx : α\n⊢ Eq ((fun x i => ((Combinatorics.Line.diagonal α ι).idxFun i).getD x) x) fun x_1 => x","decl":"@[simp]\ntheorem diagonal_apply {α ι} [Nonempty ι] (x : α) : Line.diagonal α ι x = fun _ => x := by\n  simp_rw [Line.diagonal, Option.getD_none]\n\n"}
{"name":"Combinatorics.Line.exists_mono_in_high_dimension","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u\ninst✝¹ : Finite α\nκ : Type v\ninst✝ : Finite κ\n⊢ Exists fun ι => Exists fun x => ∀ (C : (ι → α) → κ), Exists fun l => Combinatorics.Line.IsMono C l","decl":"/-- The **Hales-Jewett theorem**: For any finite types `α` and `κ`, there exists a finite type `ι`\nsuch that whenever the hypercube `ι → α` is `κ`-colored, there is a monochromatic combinatorial\nline. -/\ntheorem exists_mono_in_high_dimension (α : Type u) [Finite α] (κ : Type v) [Finite κ] :\n    ∃ (ι : Type) (_ : Fintype ι), ∀ C : (ι → α) → κ, ∃ l : Line α ι, l.IsMono C :=\n  let ⟨ι, ιfin, hι⟩ := exists_mono_in_high_dimension'.{u,v} α (ULift.{u,v} κ)\n  ⟨ι, ιfin, fun C =>\n    let ⟨l, c, hc⟩ := hι (ULift.up ∘ C)\n    ⟨l, c.down, fun x => by rw [← hc x, Function.comp_apply]⟩⟩\n\n"}
{"name":"Combinatorics.exists_mono_homothetic_copy","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"M : Type u_5\nκ : Type u_6\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\n⊢ Exists fun a => And (GT.gt a 0) (Exists fun b => Exists fun c => ∀ (s : M), Membership.mem S s → Eq (C (HAdd.hAdd (HSMul.hSMul a s) b)) c)","decl":"/-- A generalization of Van der Waerden's theorem: if `M` is a finitely colored commutative\nmonoid, and `S` is a finite subset, then there exists a monochromatic homothetic copy of `S`. -/\ntheorem exists_mono_homothetic_copy {M κ : Type*} [AddCommMonoid M] (S : Finset M) [Finite κ]\n    (C : M → κ) : ∃ a > 0, ∃ (b : M) (c : κ), ∀ s ∈ S, C (a • s + b) = c := by\n  classical\n  obtain ⟨ι, _inst, hι⟩ := Line.exists_mono_in_high_dimension S κ\n  specialize hι fun v => C <| ∑ i, v i\n  obtain ⟨l, c, hl⟩ := hι\n  set s : Finset ι := Finset.univ.filter (fun i => l.idxFun i = none) with hs\n  refine\n    ⟨s.card, Finset.card_pos.mpr ⟨l.proper.choose, ?_⟩, ∑ i ∈ sᶜ, ((l.idxFun i).map ?_).getD 0,\n      c, ?_⟩\n  · rw [hs, Finset.mem_filter]\n    exact ⟨Finset.mem_univ _, l.proper.choose_spec⟩\n  · exact fun m => m\n  intro x xs\n  rw [← hl ⟨x, xs⟩]\n  clear hl; congr\n  rw [← Finset.sum_add_sum_compl s]\n  congr 1\n  · rw [← Finset.sum_const]\n    apply Finset.sum_congr rfl\n    intro i hi\n    rw [hs, Finset.mem_filter] at hi\n    rw [l.apply_none _ _ hi.right, Subtype.coe_mk]\n  · apply Finset.sum_congr rfl\n    intro i hi\n    rw [hs, Finset.compl_filter, Finset.mem_filter] at hi\n    obtain ⟨y, hy⟩ := Option.ne_none_iff_exists.mp hi.right\n    simp_rw [← hy, Option.map_some', Option.getD]\n\n"}
{"name":"Combinatorics.Subspace.exists_mono_in_high_dimension","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_5\nκ : Type u_6\nη : Type u_7\ninst✝² : Finite α\ninst✝¹ : Finite κ\ninst✝ : Finite η\n⊢ Exists fun ι => Exists fun x => ∀ (C : (ι → α) → κ), Exists fun l => Combinatorics.Subspace.IsMono C l","decl":"/-- The **multidimensional Hales-Jewett theorem**, aka **extended Hales-Jewett theorem**: For any\nfinite types `η`, `α` and `κ`, there exists a finite type `ι` such that whenever the hypercube\n`ι → α` is `κ`-colored, there is a monochromatic combinatorial subspace of dimension `η`. -/\ntheorem exists_mono_in_high_dimension (α κ η) [Finite α] [Finite κ] [Finite η] :\n    ∃ (ι : Type) (_ : Fintype ι), ∀ C : (ι → α) → κ, ∃ l : Subspace η α ι, l.IsMono C := by\n  cases nonempty_fintype η\n  obtain ⟨ι, _, hι⟩ := Line.exists_mono_in_high_dimension (Shrink.{0} η → α) κ\n  refine ⟨ι × Shrink η, inferInstance, fun C ↦ ?_⟩\n  obtain ⟨l, hl⟩ := hι fun x ↦ C fun (i, e) ↦ x i e\n  refine ⟨l.toSubspace.reindex (equivShrink.{0} η).symm (Equiv.refl _) (Equiv.refl _), ?_⟩\n  convert hl.toSubspace.reindex\n  simp\n\n"}
{"name":"Combinatorics.Subspace.exists_mono_in_high_dimension_fin","module":"Mathlib.Combinatorics.HalesJewett","initialProofState":"α : Type u_5\nκ : Type u_6\nη : Type u_7\ninst✝² : Finite α\ninst✝¹ : Finite κ\ninst✝ : Finite η\n⊢ Exists fun n => ∀ (C : (Fin n → α) → κ), Exists fun l => Combinatorics.Subspace.IsMono C l","decl":"/-- A variant of the **extended Hales-Jewett theorem** `exists_mono_in_high_dimension` where the\nreturned type is some `Fin n` instead of a general fintype. -/\ntheorem exists_mono_in_high_dimension_fin (α κ η) [Finite α] [Finite κ] [Finite η] :\n    ∃ n, ∀ C : (Fin n → α) → κ, ∃ l : Subspace η α (Fin n), l.IsMono C := by\n  obtain ⟨ι, ιfin, hι⟩ := exists_mono_in_high_dimension α κ η\n  refine ⟨Fintype.card ι, fun C ↦ ?_⟩\n  obtain ⟨l, c, cl⟩ := hι fun v ↦ C (v ∘ (Fintype.equivFin _).symm)\n  refine ⟨⟨l.idxFun ∘ (Fintype.equivFin _).symm, fun e ↦ ?_⟩, c, cl⟩\n  obtain ⟨i, hi⟩ := l.proper e\n  use Fintype.equivFin _ i\n  simpa using hi\n\n"}
