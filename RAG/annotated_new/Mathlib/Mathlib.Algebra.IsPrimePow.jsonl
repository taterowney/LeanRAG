{"name":"isPrimePow_def","module":"Mathlib.Algebra.IsPrimePow","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : R\n⊢ Iff (IsPrimePow n) (Exists fun p => Exists fun k => And (Prime p) (And (LT.lt 0 k) (Eq (HPow.hPow p k) n)))","decl":"theorem isPrimePow_def : IsPrimePow n ↔ ∃ (p : R) (k : ℕ), Prime p ∧ 0 < k ∧ p ^ k = n :=\n  Iff.rfl\n\n"}
{"name":"isPrimePow_iff_pow_succ","module":"Mathlib.Algebra.IsPrimePow","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : R\n⊢ Iff (IsPrimePow n) (Exists fun p => Exists fun k => And (Prime p) (Eq (HPow.hPow p (HAdd.hAdd k 1)) n))","decl":"/-- An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a\nnatural `k` such that `n` can be written as `p^(k+1)`. -/\ntheorem isPrimePow_iff_pow_succ : IsPrimePow n ↔ ∃ (p : R) (k : ℕ), Prime p ∧ p ^ (k + 1) = n :=\n  (isPrimePow_def _).trans\n    ⟨fun ⟨p, k, hp, hk, hn⟩ => ⟨p, k - 1, hp, by rwa [Nat.sub_add_cancel hk]⟩, fun ⟨_, _, hp, hn⟩ =>\n      ⟨_, _, hp, Nat.succ_pos', hn⟩⟩\n\n"}
{"name":"not_isPrimePow_zero","module":"Mathlib.Algebra.IsPrimePow","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoidWithZero R\ninst✝ : NoZeroDivisors R\n⊢ Not (IsPrimePow 0)","decl":"theorem not_isPrimePow_zero [NoZeroDivisors R] : ¬IsPrimePow (0 : R) := by\n  simp only [isPrimePow_def, not_exists, not_and', and_imp]\n  intro x n _hn hx\n  rw [pow_eq_zero hx]\n  simp\n\n"}
{"name":"IsPrimePow.not_unit","module":"Mathlib.Algebra.IsPrimePow","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : R\nh : IsPrimePow n\n⊢ Not (IsUnit n)","decl":"theorem IsPrimePow.not_unit {n : R} (h : IsPrimePow n) : ¬IsUnit n :=\n  let ⟨_p, _k, hp, hk, hn⟩ := h\n  hn ▸ (isUnit_pow_iff hk.ne').not.mpr hp.not_unit\n\n"}
{"name":"IsUnit.not_isPrimePow","module":"Mathlib.Algebra.IsPrimePow","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : R\nh : IsUnit n\n⊢ Not (IsPrimePow n)","decl":"theorem IsUnit.not_isPrimePow {n : R} (h : IsUnit n) : ¬IsPrimePow n := fun h' => h'.not_unit h\n\n"}
{"name":"not_isPrimePow_one","module":"Mathlib.Algebra.IsPrimePow","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\n⊢ Not (IsPrimePow 1)","decl":"theorem not_isPrimePow_one : ¬IsPrimePow (1 : R) :=\n  isUnit_one.not_isPrimePow\n\n"}
{"name":"Prime.isPrimePow","module":"Mathlib.Algebra.IsPrimePow","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\np : R\nhp : Prime p\n⊢ IsPrimePow p","decl":"theorem Prime.isPrimePow {p : R} (hp : Prime p) : IsPrimePow p :=\n  ⟨p, 1, hp, zero_lt_one, by simp⟩\n\n"}
{"name":"IsPrimePow.pow","module":"Mathlib.Algebra.IsPrimePow","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : R\nhn : IsPrimePow n\nk : Nat\nhk : Ne k 0\n⊢ IsPrimePow (HPow.hPow n k)","decl":"theorem IsPrimePow.pow {n : R} (hn : IsPrimePow n) {k : ℕ} (hk : k ≠ 0) : IsPrimePow (n ^ k) :=\n  let ⟨p, k', hp, hk', hn⟩ := hn\n  ⟨p, k * k', hp, mul_pos hk.bot_lt hk', by rw [pow_mul', hn]⟩\n\n"}
{"name":"IsPrimePow.ne_zero","module":"Mathlib.Algebra.IsPrimePow","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoidWithZero R\ninst✝ : NoZeroDivisors R\nn : R\nh : IsPrimePow n\n⊢ Ne n 0","decl":"theorem IsPrimePow.ne_zero [NoZeroDivisors R] {n : R} (h : IsPrimePow n) : n ≠ 0 := fun t =>\n  not_isPrimePow_zero (t ▸ h)\n\n"}
{"name":"IsPrimePow.ne_one","module":"Mathlib.Algebra.IsPrimePow","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : R\nh : IsPrimePow n\n⊢ Ne n 1","decl":"theorem IsPrimePow.ne_one {n : R} (h : IsPrimePow n) : n ≠ 1 := fun t =>\n  not_isPrimePow_one (t ▸ h)\n\n"}
{"name":"isPrimePow_nat_iff","module":"Mathlib.Algebra.IsPrimePow","initialProofState":"n : Nat\n⊢ Iff (IsPrimePow n) (Exists fun p => Exists fun k => And (Nat.Prime p) (And (LT.lt 0 k) (Eq (HPow.hPow p k) n)))","decl":"theorem isPrimePow_nat_iff (n : ℕ) : IsPrimePow n ↔ ∃ p k : ℕ, Nat.Prime p ∧ 0 < k ∧ p ^ k = n := by\n  simp only [isPrimePow_def, Nat.prime_iff]\n\n"}
{"name":"Nat.Prime.isPrimePow","module":"Mathlib.Algebra.IsPrimePow","initialProofState":"p : Nat\nhp : Nat.Prime p\n⊢ IsPrimePow p","decl":"theorem Nat.Prime.isPrimePow {p : ℕ} (hp : p.Prime) : IsPrimePow p :=\n  _root_.Prime.isPrimePow (prime_iff.mp hp)\n\n"}
{"name":"isPrimePow_nat_iff_bounded","module":"Mathlib.Algebra.IsPrimePow","initialProofState":"n : Nat\n⊢ Iff (IsPrimePow n) (Exists fun p => And (LE.le p n) (Exists fun k => And (LE.le k n) (And (Nat.Prime p) (And (LT.lt 0 k) (Eq (HPow.hPow p k) n)))))","decl":"theorem isPrimePow_nat_iff_bounded (n : ℕ) :\n    IsPrimePow n ↔ ∃ p : ℕ, p ≤ n ∧ ∃ k : ℕ, k ≤ n ∧ p.Prime ∧ 0 < k ∧ p ^ k = n := by\n  rw [isPrimePow_nat_iff]\n  refine Iff.symm ⟨fun ⟨p, _, k, _, hp, hk, hn⟩ => ⟨p, k, hp, hk, hn⟩, ?_⟩\n  rintro ⟨p, k, hp, hk, rfl⟩\n  refine ⟨p, ?_, k, (Nat.lt_pow_self hp.one_lt).le, hp, hk, rfl⟩\n  conv => { lhs; rw [← (pow_one p)] }\n  exact Nat.pow_le_pow_right hp.one_lt.le hk\n\n"}
{"name":"IsPrimePow.dvd","module":"Mathlib.Algebra.IsPrimePow","initialProofState":"n m : Nat\nhn : IsPrimePow n\nhm : Dvd.dvd m n\nhm₁ : Ne m 1\n⊢ IsPrimePow m","decl":"theorem IsPrimePow.dvd {n m : ℕ} (hn : IsPrimePow n) (hm : m ∣ n) (hm₁ : m ≠ 1) : IsPrimePow m := by\n  rw [isPrimePow_nat_iff] at hn ⊢\n  rcases hn with ⟨p, k, hp, _hk, rfl⟩\n  obtain ⟨i, hik, rfl⟩ := (Nat.dvd_prime_pow hp).1 hm\n  refine ⟨p, i, hp, ?_, rfl⟩\n  apply Nat.pos_of_ne_zero\n  rintro rfl\n  simp only [pow_zero, ne_eq, not_true_eq_false] at hm₁\n\n"}
{"name":"IsPrimePow.two_le","module":"Mathlib.Algebra.IsPrimePow","initialProofState":"n : Nat\na✝ : IsPrimePow n\n⊢ LE.le 2 n","decl":"theorem IsPrimePow.two_le : ∀ {n : ℕ}, IsPrimePow n → 2 ≤ n\n  | 0, h => (not_isPrimePow_zero h).elim\n  | 1, h => (not_isPrimePow_one h).elim\n  | _n + 2, _ => le_add_self\n\n"}
{"name":"IsPrimePow.pos","module":"Mathlib.Algebra.IsPrimePow","initialProofState":"n : Nat\nhn : IsPrimePow n\n⊢ LT.lt 0 n","decl":"theorem IsPrimePow.pos {n : ℕ} (hn : IsPrimePow n) : 0 < n :=\n  pos_of_gt hn.two_le\n\n"}
{"name":"IsPrimePow.one_lt","module":"Mathlib.Algebra.IsPrimePow","initialProofState":"n : Nat\nh : IsPrimePow n\n⊢ LT.lt 1 n","decl":"theorem IsPrimePow.one_lt {n : ℕ} (h : IsPrimePow n) : 1 < n :=\n  h.two_le\n\n"}
