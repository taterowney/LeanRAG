{"name":"CategoryTheory.Abelian.app_hom","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP Q : C\nf : Quiver.Hom P Q\na : CategoryTheory.Over P\n‚ä¢ Eq (CategoryTheory.Abelian.app f a).hom (CategoryTheory.CategoryStruct.comp a.hom f)","decl":"@[simp]\ntheorem app_hom {P Q : C} (f : P ‚ü∂ Q) (a : Over P) : (app f a).hom = a.hom ‚â´ f := rfl\n\n"}
{"name":"CategoryTheory.Abelian.pseudoEqual_refl","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : C\n‚ä¢ Reflexive (CategoryTheory.Abelian.PseudoEqual P)","decl":"theorem pseudoEqual_refl {P : C} : Reflexive (PseudoEqual P) :=\n  fun f => ‚ü®f.1, ùüô f.1, ùüô f.1, inferInstance, inferInstance, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Abelian.pseudoEqual_symm","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : C\n‚ä¢ Symmetric (CategoryTheory.Abelian.PseudoEqual P)","decl":"theorem pseudoEqual_symm {P : C} : Symmetric (PseudoEqual P) :=\n  fun _ _ ‚ü®R, p, q, ep, Eq, comm‚ü© => ‚ü®R, q, p, Eq, ep, comm.symm‚ü©\n\n"}
{"name":"CategoryTheory.Abelian.pseudoEqual_trans","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nP : C\n‚ä¢ Transitive (CategoryTheory.Abelian.PseudoEqual P)","decl":"/-- Pseudoequality is transitive: Just take the pullback. The pullback morphisms will\n    be epimorphisms since in an abelian category, pullbacks of epimorphisms are epimorphisms. -/\ntheorem pseudoEqual_trans {P : C} : Transitive (PseudoEqual P) := by\n  intro f g h ‚ü®R, p, q, ep, Eq, comm‚ü© ‚ü®R', p', q', ep', eq', comm'‚ü©\n  refine ‚ü®pullback q p', pullback.fst _ _ ‚â´ p, pullback.snd _ _ ‚â´ q',\n    epi_comp _ _, epi_comp _ _, ?_‚ü©\n  rw [Category.assoc, comm, ‚Üê Category.assoc, pullback.condition, Category.assoc, comm',\n    Category.assoc]\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.over_coe_def","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nP Q : C\na : Quiver.Hom Q P\n‚ä¢ Eq (Quot.mk (CategoryTheory.Abelian.PseudoEqual P) (CategoryTheory.Over.mk a)) (Quotient.mk (CategoryTheory.Abelian.Pseudoelement.setoid P) (CategoryTheory.Over.mk a))","decl":"theorem over_coe_def {P Q : C} (a : Q ‚ü∂ P) : (a : Pseudoelement P) = ‚ü¶‚Üëa‚üß := rfl\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.pseudoApply_aux","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\na b : CategoryTheory.Over P\na‚úù : HasEquiv.Equiv a b\n‚ä¢ HasEquiv.Equiv (CategoryTheory.Abelian.app f a) (CategoryTheory.Abelian.app f b)","decl":"/-- If two elements are pseudo-equal, then their composition with a morphism is, too. -/\ntheorem pseudoApply_aux {P Q : C} (f : P ‚ü∂ Q) (a b : Over P) : a ‚âà b ‚Üí app f a ‚âà app f b :=\n  fun ‚ü®R, p, q, ep, Eq, comm‚ü© =>\n  ‚ü®R, p, q, ep, Eq, show p ‚â´ a.hom ‚â´ f = q ‚â´ b.hom ‚â´ f by rw [reassoc_of% comm]‚ü©\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.pseudoApply_mk'","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\na : CategoryTheory.Over P\n‚ä¢ Eq (CategoryTheory.Abelian.Pseudoelement.pseudoApply f (Quotient.mk (CategoryTheory.Abelian.Pseudoelement.setoid P) a)) (Quotient.mk (CategoryTheory.Abelian.Pseudoelement.setoid Q) (CategoryTheory.Over.mk (CategoryTheory.CategoryStruct.comp a.hom f)))","decl":"theorem pseudoApply_mk' {P Q : C} (f : P ‚ü∂ Q) (a : Over P) : f ‚ü¶a‚üß = ‚ü¶‚Üë(a.hom ‚â´ f)‚üß := rfl\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.comp_apply","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nP Q R : C\nf : Quiver.Hom P Q\ng : Quiver.Hom Q R\na : CategoryTheory.Abelian.Pseudoelement P\n‚ä¢ Eq (CategoryTheory.Abelian.Pseudoelement.pseudoApply (CategoryTheory.CategoryStruct.comp f g) a) (CategoryTheory.Abelian.Pseudoelement.pseudoApply g (CategoryTheory.Abelian.Pseudoelement.pseudoApply f a))","decl":"/-- Applying a pseudoelement to a composition of morphisms is the same as composing\n    with each morphism. Sadly, this is not a definitional equality, but at least it is\n    true. -/\ntheorem comp_apply {P Q R : C} (f : P ‚ü∂ Q) (g : Q ‚ü∂ R) (a : P) : (f ‚â´ g) a = g (f a) :=\n  Quotient.inductionOn a fun x =>\n    Quotient.sound <| by\n      simp only [app]\n      rw [‚Üê Category.assoc, Over.coe_hom]\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.comp_comp","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nP Q R : C\nf : Quiver.Hom P Q\ng : Quiver.Hom Q R\n‚ä¢ Eq (Function.comp (CategoryTheory.Abelian.Pseudoelement.pseudoApply g) (CategoryTheory.Abelian.Pseudoelement.pseudoApply f)) (CategoryTheory.Abelian.Pseudoelement.pseudoApply (CategoryTheory.CategoryStruct.comp f g))","decl":"/-- Composition of functions on pseudoelements is composition of morphisms. -/\ntheorem comp_comp {P Q R : C} (f : P ‚ü∂ Q) (g : Q ‚ü∂ R) : g ‚àò f = f ‚â´ g :=\n  funext fun _ => (comp_apply _ _ _).symm\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.pseudoZero_aux","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nP Q : C\nf : CategoryTheory.Over P\n‚ä¢ Iff (HasEquiv.Equiv f (CategoryTheory.Over.mk 0)) (Eq f.hom 0)","decl":"/-- The arrows pseudo-equal to a zero morphism are precisely the zero morphisms. -/\ntheorem pseudoZero_aux {P : C} (Q : C) (f : Over P) : f ‚âà (0 : Q ‚ü∂ P) ‚Üî f.hom = 0 :=\n  ‚ü®fun ‚ü®R, p, q, _, _, comm‚ü© => zero_of_epi_comp p (by simp [comm]), fun hf =>\n    ‚ü®biprod f.1 Q, biprod.fst, biprod.snd, inferInstance, inferInstance, by\n      rw [hf, Over.coe_hom, HasZeroMorphisms.comp_zero, HasZeroMorphisms.comp_zero]‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.zero_eq_zero'","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nP Q R : C\n‚ä¢ Eq (Quotient.mk (CategoryTheory.Abelian.Pseudoelement.setoid P) (CategoryTheory.Over.mk 0)) (Quotient.mk (CategoryTheory.Abelian.Pseudoelement.setoid P) (CategoryTheory.Over.mk 0))","decl":"theorem zero_eq_zero' {P Q R : C} :\n    (‚ü¶((0 : Q ‚ü∂ P) : Over P)‚üß : Pseudoelement P) = ‚ü¶((0 : R ‚ü∂ P) : Over P)‚üß :=\n  Quotient.sound <| (pseudoZero_aux R _).2 rfl\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.pseudoZero_def","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nP : C\n‚ä¢ Eq 0 (Quotient.mk (CategoryTheory.Abelian.Pseudoelement.setoid P) (CategoryTheory.Over.mk 0))","decl":"theorem pseudoZero_def {P : C} : (0 : Pseudoelement P) = ‚ü¶‚Üë(0 : P ‚ü∂ P)‚üß := rfl\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.zero_eq_zero","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nP Q : C\n‚ä¢ Eq (Quotient.mk (CategoryTheory.Abelian.Pseudoelement.setoid P) (CategoryTheory.Over.mk 0)) 0","decl":"@[simp]\ntheorem zero_eq_zero {P Q : C} : ‚ü¶((0 : Q ‚ü∂ P) : Over P)‚üß = (0 : Pseudoelement P) :=\n  zero_eq_zero'\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.pseudoZero_iff","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nP : C\na : CategoryTheory.Over P\n‚ä¢ Iff (Eq (Quot.mk (CategoryTheory.Abelian.PseudoEqual P) a) 0) (Eq a.hom 0)","decl":"/-- The pseudoelement induced by an arrow is zero precisely when that arrow is zero. -/\ntheorem pseudoZero_iff {P : C} (a : Over P) : a = (0 : P) ‚Üî a.hom = 0 := by\n  rw [‚Üê pseudoZero_aux P a]\n  exact Quotient.eq'\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.apply_zero","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\n‚ä¢ Eq (CategoryTheory.Abelian.Pseudoelement.pseudoApply f 0) 0","decl":"/-- Morphisms map the zero pseudoelement to the zero pseudoelement. -/\n@[simp]\ntheorem apply_zero {P Q : C} (f : P ‚ü∂ Q) : f 0 = 0 := by\n  rw [pseudoZero_def, pseudoApply_mk']\n  simp\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.zero_apply","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nP Q : C\na : CategoryTheory.Abelian.Pseudoelement P\n‚ä¢ Eq (CategoryTheory.Abelian.Pseudoelement.pseudoApply 0 a) 0","decl":"/-- The zero morphism maps every pseudoelement to 0. -/\n@[simp]\ntheorem zero_apply {P : C} (Q : C) (a : P) : (0 : P ‚ü∂ Q) a = 0 :=\n  Quotient.inductionOn a fun a' => by\n    rw [pseudoZero_def, pseudoApply_mk']\n    simp\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.zero_morphism_ext","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\na‚úù : ‚àÄ (a : CategoryTheory.Abelian.Pseudoelement P), Eq (CategoryTheory.Abelian.Pseudoelement.pseudoApply f a) 0\n‚ä¢ Eq f 0","decl":"/-- An extensionality lemma for being the zero arrow. -/\ntheorem zero_morphism_ext {P Q : C} (f : P ‚ü∂ Q) : (‚àÄ a, f a = 0) ‚Üí f = 0 := fun h => by\n  rw [‚Üê Category.id_comp f]\n  exact (pseudoZero_iff (ùüô P ‚â´ f : Over Q)).1 (h (ùüô P))\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.zero_morphism_ext'","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\na‚úù : ‚àÄ (a : CategoryTheory.Abelian.Pseudoelement P), Eq (CategoryTheory.Abelian.Pseudoelement.pseudoApply f a) 0\n‚ä¢ Eq 0 f","decl":"theorem zero_morphism_ext' {P Q : C} (f : P ‚ü∂ Q) : (‚àÄ a, f a = 0) ‚Üí 0 = f :=\n  Eq.symm ‚àò zero_morphism_ext f\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.eq_zero_iff","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\n‚ä¢ Iff (Eq f 0) (‚àÄ (a : CategoryTheory.Abelian.Pseudoelement P), Eq (CategoryTheory.Abelian.Pseudoelement.pseudoApply f a) 0)","decl":"theorem eq_zero_iff {P Q : C} (f : P ‚ü∂ Q) : f = 0 ‚Üî ‚àÄ a, f a = 0 :=\n  ‚ü®fun h a => by simp [h], zero_morphism_ext _‚ü©\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.pseudo_injective_of_mono","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ Function.Injective (CategoryTheory.Abelian.Pseudoelement.pseudoApply f)","decl":"/-- A monomorphism is injective on pseudoelements. -/\ntheorem pseudo_injective_of_mono {P Q : C} (f : P ‚ü∂ Q) [Mono f] : Function.Injective f := by\n  intro abar abar'\n  refine Quotient.inductionOn‚ÇÇ abar abar' fun a a' ha => ?_\n  apply Quotient.sound\n  have : (‚ü¶(a.hom ‚â´ f : Over Q)‚üß : Quotient (setoid Q)) = ‚ü¶‚Üë(a'.hom ‚â´ f)‚üß := by convert ha\n  have ‚ü®R, p, q, ep, Eq, comm‚ü© := Quotient.exact this\n  exact ‚ü®R, p, q, ep, Eq, (cancel_mono f).1 <| by\n    simp only [Category.assoc]\n    exact comm‚ü©\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.zero_of_map_zero","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\na‚úù¬π : Function.Injective (CategoryTheory.Abelian.Pseudoelement.pseudoApply f)\na : CategoryTheory.Abelian.Pseudoelement P\na‚úù : Eq (CategoryTheory.Abelian.Pseudoelement.pseudoApply f a) 0\n‚ä¢ Eq a 0","decl":"/-- A morphism that is injective on pseudoelements only maps the zero element to zero. -/\ntheorem zero_of_map_zero {P Q : C} (f : P ‚ü∂ Q) : Function.Injective f ‚Üí ‚àÄ a, f a = 0 ‚Üí a = 0 :=\n  fun h a ha => by\n  rw [‚Üê apply_zero f] at ha\n  exact h ha\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.mono_of_zero_of_map_zero","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\na‚úù : ‚àÄ (a : CategoryTheory.Abelian.Pseudoelement P), Eq (CategoryTheory.Abelian.Pseudoelement.pseudoApply f a) 0 ‚Üí Eq a 0\n‚ä¢ CategoryTheory.Mono f","decl":"/-- A morphism that only maps the zero pseudoelement to zero is a monomorphism. -/\ntheorem mono_of_zero_of_map_zero {P Q : C} (f : P ‚ü∂ Q) : (‚àÄ a, f a = 0 ‚Üí a = 0) ‚Üí Mono f :=\n  fun h => (mono_iff_cancel_zero _).2 fun _ g hg =>\n    (pseudoZero_iff (g : Over P)).1 <|\n      h _ <| show f g = 0 from (pseudoZero_iff (g ‚â´ f : Over Q)).2 hg\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.pseudo_surjective_of_epi","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\ninst‚úù : CategoryTheory.Epi f\n‚ä¢ Function.Surjective (CategoryTheory.Abelian.Pseudoelement.pseudoApply f)","decl":"/-- An epimorphism is surjective on pseudoelements. -/\ntheorem pseudo_surjective_of_epi {P Q : C} (f : P ‚ü∂ Q) [Epi f] : Function.Surjective f :=\n  fun qbar =>\n  Quotient.inductionOn qbar fun q =>\n    ‚ü®(pullback.fst f q.hom : Over P),\n      Quotient.sound <|\n        ‚ü®pullback f q.hom, ùüô (pullback f q.hom), pullback.snd _ _, inferInstance, inferInstance, by\n          rw [Category.id_comp, ‚Üê pullback.condition, app_hom, Over.coe_hom]‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.epi_of_pseudo_surjective","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\na‚úù : Function.Surjective (CategoryTheory.Abelian.Pseudoelement.pseudoApply f)\n‚ä¢ CategoryTheory.Epi f","decl":"/-- A morphism that is surjective on pseudoelements is an epimorphism. -/\ntheorem epi_of_pseudo_surjective {P Q : C} (f : P ‚ü∂ Q) : Function.Surjective f ‚Üí Epi f := by\n  intro h\n  have ‚ü®pbar, hpbar‚ü© := h (ùüô Q)\n  have ‚ü®p, hp‚ü© := Quotient.exists_rep pbar\n  have : (‚ü¶(p.hom ‚â´ f : Over Q)‚üß : Quotient (setoid Q)) = ‚ü¶‚Üë(ùüô Q)‚üß := by\n    rw [‚Üê hp] at hpbar\n    exact hpbar\n  have ‚ü®R, x, y, _, ey, comm‚ü© := Quotient.exact this\n  apply @epi_of_epi_fac _ _ _ _ _ (x ‚â´ p.hom) f y ey\n  dsimp at comm\n  rw [Category.assoc, comm]\n  apply Category.comp_id\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.pseudo_exact_of_exact","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\nb : CategoryTheory.Abelian.Pseudoelement S.X‚ÇÇ\na‚úù : Eq (CategoryTheory.Abelian.Pseudoelement.pseudoApply S.g b) 0\n‚ä¢ Exists fun a => Eq (CategoryTheory.Abelian.Pseudoelement.pseudoApply S.f a) b","decl":"/-- Two morphisms in an exact sequence are exact on pseudoelements. -/\ntheorem pseudo_exact_of_exact {S : ShortComplex C} (hS : S.Exact) :\n    ‚àÄ b, S.g b = 0 ‚Üí ‚àÉ a, S.f a = b :=\n  fun b' =>\n    Quotient.inductionOn b' fun b hb => by\n      have hb' : b.hom ‚â´ S.g = 0 := (pseudoZero_iff _).1 hb\n      -- By exactness, `b` factors through `im f = ker g` via some `c`.\n      obtain ‚ü®c, hc‚ü© := KernelFork.IsLimit.lift' hS.isLimitImage _ hb'\n      -- We compute the pullback of the map into the image and `c`.\n      -- The pseudoelement induced by the first pullback map will be our preimage.\n      use pullback.fst (Abelian.factorThruImage S.f) c\n      -- It remains to show that the image of this element under `f` is pseudo-equal to `b`.\n      apply Quotient.sound\n      refine ‚ü®pullback (Abelian.factorThruImage S.f) c, ùüô _,\n              pullback.snd _ _, inferInstance, inferInstance, ?_‚ü©\n      -- Now we can verify that the diagram commutes.\n      calc\n        ùüô (pullback (Abelian.factorThruImage S.f) c) ‚â´ pullback.fst _ _ ‚â´ S.f =\n          pullback.fst _ _ ‚â´ S.f :=\n          Category.id_comp _\n        _ = pullback.fst _ _ ‚â´ Abelian.factorThruImage S.f ‚â´ kernel.Œπ (cokernel.œÄ S.f) := by\n          rw [Abelian.image.fac]\n        _ = (pullback.snd _ _ ‚â´ c) ‚â´ kernel.Œπ (cokernel.œÄ S.f) := by\n          rw [‚Üê Category.assoc, pullback.condition]\n        _ = pullback.snd _ _ ‚â´ b.hom := by\n          rw [Category.assoc]\n          congr\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.apply_eq_zero_of_comp_eq_zero","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nP Q R : C\nf : Quiver.Hom Q R\na : Quiver.Hom P Q\na‚úù : Eq (CategoryTheory.CategoryStruct.comp a f) 0\n‚ä¢ Eq (CategoryTheory.Abelian.Pseudoelement.pseudoApply f (Quot.mk (CategoryTheory.Abelian.PseudoEqual Q) (CategoryTheory.Over.mk a))) 0","decl":"theorem apply_eq_zero_of_comp_eq_zero {P Q R : C} (f : Q ‚ü∂ R) (a : P ‚ü∂ Q) : a ‚â´ f = 0 ‚Üí f a = 0 :=\n  fun h => by simp [over_coe_def, pseudoApply_mk', Over.coe_hom, h]\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.exact_of_pseudo_exact","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\nhS : ‚àÄ (b : CategoryTheory.Abelian.Pseudoelement S.X‚ÇÇ), Eq (CategoryTheory.Abelian.Pseudoelement.pseudoApply S.g b) 0 ‚Üí Exists fun a => Eq (CategoryTheory.Abelian.Pseudoelement.pseudoApply S.f a) b\n‚ä¢ S.Exact","decl":"/-- If two morphisms are exact on pseudoelements, they are exact. -/\ntheorem exact_of_pseudo_exact (S : ShortComplex C)\n    (hS : ‚àÄ b, S.g b = 0 ‚Üí ‚àÉ a, S.f a = b) : S.Exact :=\n  (S.exact_iff_kernel_Œπ_comp_cokernel_œÄ_zero).2 (by\n      -- If we apply `g` to the pseudoelement induced by its kernel, we get 0 (of course!).\n      have : S.g (kernel.Œπ S.g) = 0 := apply_eq_zero_of_comp_eq_zero _ _ (kernel.condition _)\n      -- By pseudo-exactness, we get a preimage.\n      obtain ‚ü®a', ha‚ü© := hS _ this\n      obtain ‚ü®a, ha'‚ü© := Quotient.exists_rep a'\n      rw [‚Üê ha'] at ha\n      obtain ‚ü®Z, r, q, _, eq, comm‚ü© := Quotient.exact ha\n      -- Consider the pullback of `kernel.Œπ (cokernel.œÄ f)` and `kernel.Œπ g`.\n      -- The commutative diagram given by the pseudo-equality `f a = b` induces\n      -- a cone over this pullback, so we get a factorization `z`.\n      obtain ‚ü®z, _, hz‚ÇÇ‚ü© := @pullback.lift' _ _ _ _ _ _ (kernel.Œπ (cokernel.œÄ S.f))\n        (kernel.Œπ S.g) _ (r ‚â´ a.hom ‚â´ Abelian.factorThruImage S.f) q (by\n          simp only [Category.assoc, Abelian.image.fac]\n          exact comm)\n      -- Let's give a name to the second pullback morphism.\n      let j : pullback (kernel.Œπ (cokernel.œÄ S.f)) (kernel.Œπ S.g) ‚ü∂ kernel S.g := pullback.snd _ _\n      -- Since `q` is an epimorphism, in particular this means that `j` is an epimorphism.\n      haveI pe : Epi j := epi_of_epi_fac hz‚ÇÇ\n      -- But it is also a monomorphism, because `kernel.Œπ (cokernel.œÄ f)` is: A kernel is\n      -- always a monomorphism and the pullback of a monomorphism is a monomorphism.\n      -- But mono + epi = iso, so `j` is an isomorphism.\n      haveI : IsIso j := isIso_of_mono_of_epi _\n      -- But then `kernel.Œπ g` can be expressed using all of the maps of the pullback square, and we\n      -- are done.\n      rw [(Iso.eq_inv_comp (asIso j)).2 pullback.condition.symm]\n      simp only [Category.assoc, kernel.condition, HasZeroMorphisms.comp_zero])\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.sub_of_eq_image","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\nx y : CategoryTheory.Abelian.Pseudoelement P\na‚úù : Eq (CategoryTheory.Abelian.Pseudoelement.pseudoApply f x) (CategoryTheory.Abelian.Pseudoelement.pseudoApply f y)\n‚ä¢ Exists fun z => And (Eq (CategoryTheory.Abelian.Pseudoelement.pseudoApply f z) 0) (‚àÄ (R : C) (g : Quiver.Hom P R), Eq (CategoryTheory.Abelian.Pseudoelement.pseudoApply g y) 0 ‚Üí Eq (CategoryTheory.Abelian.Pseudoelement.pseudoApply g z) (CategoryTheory.Abelian.Pseudoelement.pseudoApply g x))","decl":"/-- If two pseudoelements `x` and `y` have the same image under some morphism `f`, then we can form\n    their \"difference\" `z`. This pseudoelement has the properties that `f z = 0` and for all\n    morphisms `g`, if `g y = 0` then `g z = g x`. -/\ntheorem sub_of_eq_image {P Q : C} (f : P ‚ü∂ Q) (x y : P) :\n    f x = f y ‚Üí ‚àÉ z, f z = 0 ‚àß ‚àÄ (R : C) (g : P ‚ü∂ R), (g : P ‚ü∂ R) y = 0 ‚Üí g z = g x :=\n  Quotient.inductionOn‚ÇÇ x y fun a a' h =>\n    match Quotient.exact h with\n    | ‚ü®R, p, q, ep, _, comm‚ü© =>\n      let a'' : R ‚ü∂ P := (p ‚â´ a.hom : R ‚ü∂ P) - (q ‚â´ a'.hom : R ‚ü∂ P)\n      ‚ü®a'',\n        ‚ü®show ‚ü¶(a'' ‚â´ f : Over Q)‚üß = ‚ü¶‚Üë(0 : Q ‚ü∂ Q)‚üß by\n            dsimp at comm\n            simp [a'', sub_eq_zero.2 comm],\n          fun Z g hh => by\n          obtain ‚ü®X, p', q', ep', _, comm'‚ü© := Quotient.exact hh\n          have : a'.hom ‚â´ g = 0 := by\n            apply (epi_iff_cancel_zero _).1 ep' _ (a'.hom ‚â´ g)\n            simpa using comm'\n          apply Quotient.sound\n          -- Can we prevent quotient.sound from giving us this weird `coe_b` thingy?\n          change app g (a'' : Over P) ‚âà app g a\n          exact ‚ü®R, ùüô R, p, inferInstance, ep, by simp [a'', sub_eq_add_neg, this]‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.pseudo_pullback","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nP Q R : C\nf : Quiver.Hom P R\ng : Quiver.Hom Q R\np : CategoryTheory.Abelian.Pseudoelement P\nq : CategoryTheory.Abelian.Pseudoelement Q\na‚úù : Eq (CategoryTheory.Abelian.Pseudoelement.pseudoApply f p) (CategoryTheory.Abelian.Pseudoelement.pseudoApply g q)\n‚ä¢ Exists fun s => And (Eq (CategoryTheory.Abelian.Pseudoelement.pseudoApply (CategoryTheory.Limits.pullback.fst f g) s) p) (Eq (CategoryTheory.Abelian.Pseudoelement.pseudoApply (CategoryTheory.Limits.pullback.snd f g) s) q)","decl":"/-- If `f : P ‚ü∂ R` and `g : Q ‚ü∂ R` are morphisms and `p : P` and `q : Q` are pseudoelements such\n    that `f p = g q`, then there is some `s : pullback f g` such that `fst s = p` and `snd s = q`.\n\n    Remark: Borceux claims that `s` is unique, but this is false. See\n    `Counterexamples/Pseudoelement.lean` for details. -/\ntheorem pseudo_pullback {P Q R : C} {f : P ‚ü∂ R} {g : Q ‚ü∂ R} {p : P} {q : Q} :\n    f p = g q ‚Üí\n      ‚àÉ s, pullback.fst f g s = p ‚àß pullback.snd f g s = q :=\n  Quotient.inductionOn‚ÇÇ p q fun x y h => by\n    obtain ‚ü®Z, a, b, ea, eb, comm‚ü© := Quotient.exact h\n    obtain ‚ü®l, hl‚ÇÅ, hl‚ÇÇ‚ü© := @pullback.lift' _ _ _ _ _ _ f g _ (a ‚â´ x.hom) (b ‚â´ y.hom) (by\n      simp only [Category.assoc]\n      exact comm)\n    exact ‚ü®l, ‚ü®Quotient.sound ‚ü®Z, ùüô Z, a, inferInstance, ea, by rwa [Category.id_comp]‚ü©,\n      Quotient.sound ‚ü®Z, ùüô Z, b, inferInstance, eb, by rwa [Category.id_comp]‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Abelian.Pseudoelement.ModuleCat.eq_range_of_pseudoequal","module":"Mathlib.CategoryTheory.Abelian.Pseudoelements","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nG : ModuleCat R\nx y : CategoryTheory.Over G\nh : CategoryTheory.Abelian.PseudoEqual G x y\n‚ä¢ Eq (LinearMap.range (ModuleCat.Hom.hom x.hom)) (LinearMap.range (ModuleCat.Hom.hom y.hom))","decl":"/-- In the category `Module R`, if `x` and `y` are pseudoequal, then the range of the associated\nmorphisms is the same. -/\ntheorem ModuleCat.eq_range_of_pseudoequal {R : Type*} [CommRing R] {G : ModuleCat R} {x y : Over G}\n    (h : PseudoEqual G x y) : LinearMap.range x.hom.hom = LinearMap.range y.hom.hom := by\n  obtain ‚ü®P, p, q, hp, hq, H‚ü© := h\n  refine Submodule.ext fun a => ‚ü®fun ha => ?_, fun ha => ?_‚ü©\n  ¬∑ obtain ‚ü®a', ha'‚ü© := ha\n    obtain ‚ü®a'', ha''‚ü© := (ModuleCat.epi_iff_surjective p).1 hp a'\n    refine ‚ü®q a'', ?_‚ü©\n    dsimp at ha' ‚ä¢\n    rw [‚Üê LinearMap.comp_apply, ‚Üê ModuleCat.hom_comp, ‚Üê H,\n      ModuleCat.hom_comp, LinearMap.comp_apply, ha'', ha']\n  ¬∑ obtain ‚ü®a', ha'‚ü© := ha\n    obtain ‚ü®a'', ha''‚ü© := (ModuleCat.epi_iff_surjective q).1 hq a'\n    refine ‚ü®p a'', ?_‚ü©\n    dsimp at ha' ‚ä¢\n    rw [‚Üê LinearMap.comp_apply, ‚Üê ModuleCat.hom_comp, H, ModuleCat.hom_comp, LinearMap.comp_apply,\n      ha'', ha']\n\n"}
