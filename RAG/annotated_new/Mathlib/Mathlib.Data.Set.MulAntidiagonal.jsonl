{"name":"Set.mem_mulAntidiagonal","module":"Mathlib.Data.Set.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : Mul α\ns t : Set α\na : α\nx : Prod α α\n⊢ Iff (Membership.mem (s.mulAntidiagonal t a) x) (And (Membership.mem s x.1) (And (Membership.mem t x.2) (Eq (HMul.hMul x.1 x.2) a)))","decl":"@[to_additive (attr := simp)]\ntheorem mem_mulAntidiagonal : x ∈ mulAntidiagonal s t a ↔ x.1 ∈ s ∧ x.2 ∈ t ∧ x.1 * x.2 = a :=\n  Iff.rfl\n\n"}
{"name":"Set.mem_addAntidiagonal","module":"Mathlib.Data.Set.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : Add α\ns t : Set α\na : α\nx : Prod α α\n⊢ Iff (Membership.mem (s.addAntidiagonal t a) x) (And (Membership.mem s x.1) (And (Membership.mem t x.2) (Eq (HAdd.hAdd x.1 x.2) a)))","decl":"@[to_additive (attr := simp)]\ntheorem mem_mulAntidiagonal : x ∈ mulAntidiagonal s t a ↔ x.1 ∈ s ∧ x.2 ∈ t ∧ x.1 * x.2 = a :=\n  Iff.rfl\n\n"}
{"name":"Set.mulAntidiagonal_mono_left","module":"Mathlib.Data.Set.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : Mul α\ns₁ s₂ t : Set α\na : α\nh : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (s₁.mulAntidiagonal t a) (s₂.mulAntidiagonal t a)","decl":"@[to_additive]\ntheorem mulAntidiagonal_mono_left (h : s₁ ⊆ s₂) : mulAntidiagonal s₁ t a ⊆ mulAntidiagonal s₂ t a :=\n  fun _ hx => ⟨h hx.1, hx.2.1, hx.2.2⟩\n\n"}
{"name":"Set.addAntidiagonal_mono_left","module":"Mathlib.Data.Set.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : Add α\ns₁ s₂ t : Set α\na : α\nh : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (s₁.addAntidiagonal t a) (s₂.addAntidiagonal t a)","decl":"@[to_additive]\ntheorem mulAntidiagonal_mono_left (h : s₁ ⊆ s₂) : mulAntidiagonal s₁ t a ⊆ mulAntidiagonal s₂ t a :=\n  fun _ hx => ⟨h hx.1, hx.2.1, hx.2.2⟩\n\n"}
{"name":"Set.addAntidiagonal_mono_right","module":"Mathlib.Data.Set.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : Add α\ns t₁ t₂ : Set α\na : α\nh : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (s.addAntidiagonal t₁ a) (s.addAntidiagonal t₂ a)","decl":"@[to_additive]\ntheorem mulAntidiagonal_mono_right (h : t₁ ⊆ t₂) :\n    mulAntidiagonal s t₁ a ⊆ mulAntidiagonal s t₂ a := fun _ hx => ⟨hx.1, h hx.2.1, hx.2.2⟩\n\n"}
{"name":"Set.mulAntidiagonal_mono_right","module":"Mathlib.Data.Set.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : Mul α\ns t₁ t₂ : Set α\na : α\nh : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (s.mulAntidiagonal t₁ a) (s.mulAntidiagonal t₂ a)","decl":"@[to_additive]\ntheorem mulAntidiagonal_mono_right (h : t₁ ⊆ t₂) :\n    mulAntidiagonal s t₁ a ⊆ mulAntidiagonal s t₂ a := fun _ hx => ⟨hx.1, h hx.2.1, hx.2.2⟩\n\n"}
{"name":"Set.swap_mem_mulAntidiagonal","module":"Mathlib.Data.Set.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : CommSemigroup α\ns t : Set α\na : α\nx : Prod α α\n⊢ Iff (Membership.mem (s.mulAntidiagonal t a) x.swap) (Membership.mem (t.mulAntidiagonal s a) x)","decl":"@[to_additive]\ntheorem swap_mem_mulAntidiagonal [CommSemigroup α] {s t : Set α} {a : α} {x : α × α} :\n    x.swap ∈ Set.mulAntidiagonal s t a ↔ x ∈ Set.mulAntidiagonal t s a := by\n  simp [mul_comm, and_left_comm]\n\n"}
{"name":"Set.swap_mem_addAntidiagonal","module":"Mathlib.Data.Set.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : AddCommSemigroup α\ns t : Set α\na : α\nx : Prod α α\n⊢ Iff (Membership.mem (s.addAntidiagonal t a) x.swap) (Membership.mem (t.addAntidiagonal s a) x)","decl":"@[to_additive]\ntheorem swap_mem_mulAntidiagonal [CommSemigroup α] {s t : Set α} {a : α} {x : α × α} :\n    x.swap ∈ Set.mulAntidiagonal s t a ↔ x ∈ Set.mulAntidiagonal t s a := by\n  simp [mul_comm, and_left_comm]\n\n"}
{"name":"Set.swap_mem_mulAntidiagonal_aux","module":"Mathlib.Data.Set.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : CommSemigroup α\ns t : Set α\na : α\nx : Prod α α\n⊢ Iff (And (Membership.mem s x.2) (And (Membership.mem t x.1) (Eq (HMul.hMul x.2 x.1) a))) (Membership.mem (t.mulAntidiagonal s a) x)","decl":"@[to_additive (attr := simp)]\ntheorem swap_mem_mulAntidiagonal_aux [CommSemigroup α] {s t : Set α} {a : α} {x : α × α} :\n    x.snd ∈ s ∧ x.fst ∈ t ∧ x.snd * x.fst = a\n      ↔ x ∈ Set.mulAntidiagonal t s a := by\n  simp [mul_comm, and_left_comm]\n\n\n"}
{"name":"Set.swap_mem_addAntidiagonal_aux","module":"Mathlib.Data.Set.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : AddCommSemigroup α\ns t : Set α\na : α\nx : Prod α α\n⊢ Iff (And (Membership.mem s x.2) (And (Membership.mem t x.1) (Eq (HAdd.hAdd x.2 x.1) a))) (Membership.mem (t.addAntidiagonal s a) x)","decl":"@[to_additive (attr := simp)]\ntheorem swap_mem_mulAntidiagonal_aux [CommSemigroup α] {s t : Set α} {a : α} {x : α × α} :\n    x.snd ∈ s ∧ x.fst ∈ t ∧ x.snd * x.fst = a\n      ↔ x ∈ Set.mulAntidiagonal t s a := by\n  simp [mul_comm, and_left_comm]\n\n\n"}
{"name":"Set.MulAntidiagonal.fst_eq_fst_iff_snd_eq_snd","module":"Mathlib.Data.Set.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoid α\ns t : Set α\na : α\nx y : ↑(s.mulAntidiagonal t a)\n⊢ Iff (Eq (↑x).1 (↑y).1) (Eq (↑x).2 (↑y).2)","decl":"@[to_additive Set.AddAntidiagonal.fst_eq_fst_iff_snd_eq_snd]\ntheorem fst_eq_fst_iff_snd_eq_snd : (x : α × α).1 = (y : α × α).1 ↔ (x : α × α).2 = (y : α × α).2 :=\n  ⟨fun h =>\n    mul_left_cancel\n      (y.2.2.2.trans <| by\n          rw [← h]\n          exact x.2.2.2.symm).symm,\n    fun h =>\n    mul_right_cancel\n      (y.2.2.2.trans <| by\n          rw [← h]\n          exact x.2.2.2.symm).symm⟩\n\n"}
{"name":"Set.AddAntidiagonal.fst_eq_fst_iff_snd_eq_snd","module":"Mathlib.Data.Set.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : AddCancelCommMonoid α\ns t : Set α\na : α\nx y : ↑(s.addAntidiagonal t a)\n⊢ Iff (Eq (↑x).1 (↑y).1) (Eq (↑x).2 (↑y).2)","decl":"@[to_additive Set.AddAntidiagonal.fst_eq_fst_iff_snd_eq_snd]\ntheorem fst_eq_fst_iff_snd_eq_snd : (x : α × α).1 = (y : α × α).1 ↔ (x : α × α).2 = (y : α × α).2 :=\n  ⟨fun h =>\n    mul_left_cancel\n      (y.2.2.2.trans <| by\n          rw [← h]\n          exact x.2.2.2.symm).symm,\n    fun h =>\n    mul_right_cancel\n      (y.2.2.2.trans <| by\n          rw [← h]\n          exact x.2.2.2.symm).symm⟩\n\n"}
{"name":"Set.MulAntidiagonal.eq_of_fst_eq_fst","module":"Mathlib.Data.Set.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoid α\ns t : Set α\na : α\nx y : ↑(s.mulAntidiagonal t a)\nh : Eq (↑x).1 (↑y).1\n⊢ Eq x y","decl":"@[to_additive Set.AddAntidiagonal.eq_of_fst_eq_fst]\ntheorem eq_of_fst_eq_fst (h : (x : α × α).fst = (y : α × α).fst) : x = y :=\n  Subtype.ext <| Prod.ext h <| fst_eq_fst_iff_snd_eq_snd.1 h\n\n"}
{"name":"Set.AddAntidiagonal.eq_of_fst_eq_fst","module":"Mathlib.Data.Set.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : AddCancelCommMonoid α\ns t : Set α\na : α\nx y : ↑(s.addAntidiagonal t a)\nh : Eq (↑x).1 (↑y).1\n⊢ Eq x y","decl":"@[to_additive Set.AddAntidiagonal.eq_of_fst_eq_fst]\ntheorem eq_of_fst_eq_fst (h : (x : α × α).fst = (y : α × α).fst) : x = y :=\n  Subtype.ext <| Prod.ext h <| fst_eq_fst_iff_snd_eq_snd.1 h\n\n"}
{"name":"Set.MulAntidiagonal.eq_of_snd_eq_snd","module":"Mathlib.Data.Set.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoid α\ns t : Set α\na : α\nx y : ↑(s.mulAntidiagonal t a)\nh : Eq (↑x).2 (↑y).2\n⊢ Eq x y","decl":"@[to_additive Set.AddAntidiagonal.eq_of_snd_eq_snd]\ntheorem eq_of_snd_eq_snd (h : (x : α × α).snd = (y : α × α).snd) : x = y :=\n  Subtype.ext <| Prod.ext (fst_eq_fst_iff_snd_eq_snd.2 h) h\n\n"}
{"name":"Set.AddAntidiagonal.eq_of_snd_eq_snd","module":"Mathlib.Data.Set.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : AddCancelCommMonoid α\ns t : Set α\na : α\nx y : ↑(s.addAntidiagonal t a)\nh : Eq (↑x).2 (↑y).2\n⊢ Eq x y","decl":"@[to_additive Set.AddAntidiagonal.eq_of_snd_eq_snd]\ntheorem eq_of_snd_eq_snd (h : (x : α × α).snd = (y : α × α).snd) : x = y :=\n  Subtype.ext <| Prod.ext (fst_eq_fst_iff_snd_eq_snd.2 h) h\n\n"}
{"name":"Set.MulAntidiagonal.eq_of_fst_le_fst_of_snd_le_snd","module":"Mathlib.Data.Set.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝³ : CancelCommMonoid α\ninst✝² : PartialOrder α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightStrictMono α\ns t : Set α\na : α\nx y : ↑(s.mulAntidiagonal t a)\nh₁ : LE.le (↑x).1 (↑y).1\nh₂ : LE.le (↑x).2 (↑y).2\n⊢ Eq x y","decl":"@[to_additive Set.AddAntidiagonal.eq_of_fst_le_fst_of_snd_le_snd]\ntheorem eq_of_fst_le_fst_of_snd_le_snd (h₁ : (x : α × α).1 ≤ (y : α × α).1)\n    (h₂ : (x : α × α).2 ≤ (y : α × α).2) : x = y :=\n  eq_of_fst_eq_fst <|\n    h₁.eq_of_not_lt fun hlt =>\n      (mul_lt_mul_of_lt_of_le hlt h₂).ne <|\n        (mem_mulAntidiagonal.1 x.2).2.2.trans (mem_mulAntidiagonal.1 y.2).2.2.symm\n\n"}
{"name":"Set.AddAntidiagonal.eq_of_fst_le_fst_of_snd_le_snd","module":"Mathlib.Data.Set.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝³ : AddCancelCommMonoid α\ninst✝² : PartialOrder α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightStrictMono α\ns t : Set α\na : α\nx y : ↑(s.addAntidiagonal t a)\nh₁ : LE.le (↑x).1 (↑y).1\nh₂ : LE.le (↑x).2 (↑y).2\n⊢ Eq x y","decl":"@[to_additive Set.AddAntidiagonal.eq_of_fst_le_fst_of_snd_le_snd]\ntheorem eq_of_fst_le_fst_of_snd_le_snd (h₁ : (x : α × α).1 ≤ (y : α × α).1)\n    (h₂ : (x : α × α).2 ≤ (y : α × α).2) : x = y :=\n  eq_of_fst_eq_fst <|\n    h₁.eq_of_not_lt fun hlt =>\n      (mul_lt_mul_of_lt_of_le hlt h₂).ne <|\n        (mem_mulAntidiagonal.1 x.2).2.2.trans (mem_mulAntidiagonal.1 y.2).2.2.symm\n\n"}
{"name":"Set.MulAntidiagonal.finite_of_isPWO","module":"Mathlib.Data.Set.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝³ : CancelCommMonoid α\ninst✝² : PartialOrder α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightStrictMono α\ns t : Set α\nhs : s.IsPWO\nht : t.IsPWO\na : α\n⊢ (s.mulAntidiagonal t a).Finite","decl":"@[to_additive Set.AddAntidiagonal.finite_of_isPWO]\ntheorem finite_of_isPWO (hs : s.IsPWO) (ht : t.IsPWO) (a) : (mulAntidiagonal s t a).Finite := by\n  refine not_infinite.1 fun h => ?_\n  have h1 : (mulAntidiagonal s t a).PartiallyWellOrderedOn (Prod.fst ⁻¹'o (· ≤ ·)) := fun f hf =>\n    hs (Prod.fst ∘ f) fun n => (mem_mulAntidiagonal.1 (hf n)).1\n  have h2 : (mulAntidiagonal s t a).PartiallyWellOrderedOn (Prod.snd ⁻¹'o (· ≤ ·)) := fun f hf =>\n    ht (Prod.snd ∘ f) fun n => (mem_mulAntidiagonal.1 (hf n)).2.1\n  obtain ⟨g, hg⟩ :=\n    h1.exists_monotone_subseq (fun n => h.natEmbedding _ n) fun n => (h.natEmbedding _ n).2\n  obtain ⟨m, n, mn, h2'⟩ := h2 (fun x => (h.natEmbedding _) (g x)) fun n => (h.natEmbedding _ _).2\n  refine mn.ne (g.injective <| (h.natEmbedding _).injective ?_)\n  exact eq_of_fst_le_fst_of_snd_le_snd _ _ _ (hg _ _ mn.le) h2'\n\n"}
{"name":"Set.AddAntidiagonal.finite_of_isPWO","module":"Mathlib.Data.Set.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝³ : AddCancelCommMonoid α\ninst✝² : PartialOrder α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightStrictMono α\ns t : Set α\nhs : s.IsPWO\nht : t.IsPWO\na : α\n⊢ (s.addAntidiagonal t a).Finite","decl":"@[to_additive Set.AddAntidiagonal.finite_of_isPWO]\ntheorem finite_of_isPWO (hs : s.IsPWO) (ht : t.IsPWO) (a) : (mulAntidiagonal s t a).Finite := by\n  refine not_infinite.1 fun h => ?_\n  have h1 : (mulAntidiagonal s t a).PartiallyWellOrderedOn (Prod.fst ⁻¹'o (· ≤ ·)) := fun f hf =>\n    hs (Prod.fst ∘ f) fun n => (mem_mulAntidiagonal.1 (hf n)).1\n  have h2 : (mulAntidiagonal s t a).PartiallyWellOrderedOn (Prod.snd ⁻¹'o (· ≤ ·)) := fun f hf =>\n    ht (Prod.snd ∘ f) fun n => (mem_mulAntidiagonal.1 (hf n)).2.1\n  obtain ⟨g, hg⟩ :=\n    h1.exists_monotone_subseq (fun n => h.natEmbedding _ n) fun n => (h.natEmbedding _ n).2\n  obtain ⟨m, n, mn, h2'⟩ := h2 (fun x => (h.natEmbedding _) (g x)) fun n => (h.natEmbedding _ _).2\n  refine mn.ne (g.injective <| (h.natEmbedding _).injective ?_)\n  exact eq_of_fst_le_fst_of_snd_le_snd _ _ _ (hg _ _ mn.le) h2'\n\n"}
{"name":"Set.MulAntidiagonal.finite_of_isWF","module":"Mathlib.Data.Set.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝³ : CancelCommMonoid α\ninst✝² : LinearOrder α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightStrictMono α\ns t : Set α\nhs : s.IsWF\nht : t.IsWF\na : α\n⊢ (s.mulAntidiagonal t a).Finite","decl":"@[to_additive Set.AddAntidiagonal.finite_of_isWF]\ntheorem finite_of_isWF {s t : Set α} (hs : s.IsWF) (ht : t.IsWF)\n    (a) : (mulAntidiagonal s t a).Finite :=\n  finite_of_isPWO hs.isPWO ht.isPWO a\n\n"}
{"name":"Set.AddAntidiagonal.finite_of_isWF","module":"Mathlib.Data.Set.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝³ : AddCancelCommMonoid α\ninst✝² : LinearOrder α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightStrictMono α\ns t : Set α\nhs : s.IsWF\nht : t.IsWF\na : α\n⊢ (s.addAntidiagonal t a).Finite","decl":"@[to_additive Set.AddAntidiagonal.finite_of_isWF]\ntheorem finite_of_isWF {s t : Set α} (hs : s.IsWF) (ht : t.IsWF)\n    (a) : (mulAntidiagonal s t a).Finite :=\n  finite_of_isPWO hs.isPWO ht.isPWO a\n\n"}
