{"name":"DFinsupp.mk'.sizeOf_spec","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : (i : ι) → Zero (β i)\ninst✝¹ : SizeOf ι\ninst✝ : (a : ι) → SizeOf (β a)\ntoFun : (i : ι) → β i\nsupport' : Trunc (Subtype fun s => ∀ (i : ι), Or (Membership.mem s i) (Eq (toFun i) 0))\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, support' := support' }) (HAdd.hAdd 1 (SizeOf.sizeOf support'))","decl":"/-- A dependent function `Π i, β i` with finite support, with notation `Π₀ i, β i`.\n\nNote that `DFinsupp.support` is the preferred API for accessing the support of the function,\n`DFinsupp.support'` is an implementation detail that aids computability; see the implementation\nnotes in this file for more information. -/\nstructure DFinsupp [∀ i, Zero (β i)] : Type max u v where mk' ::\n  /-- The underlying function of a dependent function with finite support (aka `DFinsupp`). -/\n  toFun : ∀ i, β i\n  /-- The support of a dependent function with finite support (aka `DFinsupp`). -/\n  support' : Trunc { s : Multiset ι // ∀ i, i ∈ s ∨ toFun i = 0 }\n\n"}
{"name":"DFinsupp.mk'.inj","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝ : (i : ι) → Zero (β i)\ntoFun✝ : (i : ι) → β i\nsupport'✝ : Trunc (Subtype fun s => ∀ (i : ι), Or (Membership.mem s i) (Eq (toFun✝ i) 0))\ntoFun : (i : ι) → β i\nsupport' : Trunc (Subtype fun s => ∀ (i : ι), Or (Membership.mem s i) (Eq (toFun i) 0))\nx✝ : Eq { toFun := toFun✝, support' := support'✝ } { toFun := toFun, support' := support' }\n⊢ And (Eq toFun✝ toFun) (HEq support'✝ support')","decl":"/-- A dependent function `Π i, β i` with finite support, with notation `Π₀ i, β i`.\n\nNote that `DFinsupp.support` is the preferred API for accessing the support of the function,\n`DFinsupp.support'` is an implementation detail that aids computability; see the implementation\nnotes in this file for more information. -/\nstructure DFinsupp [∀ i, Zero (β i)] : Type max u v where mk' ::\n  /-- The underlying function of a dependent function with finite support (aka `DFinsupp`). -/\n  toFun : ∀ i, β i\n  /-- The support of a dependent function with finite support (aka `DFinsupp`). -/\n  support' : Trunc { s : Multiset ι // ∀ i, i ∈ s ∨ toFun i = 0 }\n\n"}
{"name":"DFinsupp.mk'.injEq","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝ : (i : ι) → Zero (β i)\ntoFun✝ : (i : ι) → β i\nsupport'✝ : Trunc (Subtype fun s => ∀ (i : ι), Or (Membership.mem s i) (Eq (toFun✝ i) 0))\ntoFun : (i : ι) → β i\nsupport' : Trunc (Subtype fun s => ∀ (i : ι), Or (Membership.mem s i) (Eq (toFun i) 0))\n⊢ Eq (Eq { toFun := toFun✝, support' := support'✝ } { toFun := toFun, support' := support' }) (And (Eq toFun✝ toFun) (HEq support'✝ support'))","decl":"/-- A dependent function `Π i, β i` with finite support, with notation `Π₀ i, β i`.\n\nNote that `DFinsupp.support` is the preferred API for accessing the support of the function,\n`DFinsupp.support'` is an implementation detail that aids computability; see the implementation\nnotes in this file for more information. -/\nstructure DFinsupp [∀ i, Zero (β i)] : Type max u v where mk' ::\n  /-- The underlying function of a dependent function with finite support (aka `DFinsupp`). -/\n  toFun : ∀ i, β i\n  /-- The support of a dependent function with finite support (aka `DFinsupp`). -/\n  support' : Trunc { s : Multiset ι // ∀ i, i ∈ s ∨ toFun i = 0 }\n\n"}
{"name":"DFinsupp.toFun_eq_coe","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝ : (i : ι) → Zero (β i)\nf : DFinsupp fun i => β i\n⊢ Eq f.toFun ⇑f","decl":"@[simp]\ntheorem toFun_eq_coe (f : Π₀ i, β i) : f.toFun = f :=\n  rfl\n\n"}
{"name":"DFinsupp.ext_iff","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝ : (i : ι) → Zero (β i)\nf g : DFinsupp fun i => β i\n⊢ Iff (Eq f g) (∀ (i : ι), Eq (f i) (g i))","decl":"@[ext]\ntheorem ext {f g : Π₀ i, β i} (h : ∀ i, f i = g i) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"DFinsupp.ext","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝ : (i : ι) → Zero (β i)\nf g : DFinsupp fun i => β i\nh : ∀ (i : ι), Eq (f i) (g i)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : Π₀ i, β i} (h : ∀ i, f i = g i) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"DFinsupp.ne_iff","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝ : (i : ι) → Zero (β i)\nf g : DFinsupp fun i => β i\n⊢ Iff (Ne f g) (Exists fun i => Ne (f i) (g i))","decl":"lemma ne_iff {f g : Π₀ i, β i} : f ≠ g ↔ ∃ i, f i ≠ g i := DFunLike.ne_iff\n\n"}
{"name":"DFinsupp.coe_mk'","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝ : (i : ι) → Zero (β i)\nf : (i : ι) → β i\ns : Trunc (Subtype fun s => ∀ (i : ι), Or (Membership.mem s i) (Eq (f i) 0))\n⊢ Eq (⇑{ toFun := f, support' := s }) f","decl":"@[simp, norm_cast] lemma coe_mk' (f : ∀ i, β i) (s) : ⇑(⟨f, s⟩ : Π₀ i, β i) = f := rfl\n\n"}
{"name":"DFinsupp.coe_zero","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝ : (i : ι) → Zero (β i)\n⊢ Eq (⇑0) 0","decl":"@[simp, norm_cast] lemma coe_zero : ⇑(0 : Π₀ i, β i) = 0 := rfl\n\n"}
{"name":"DFinsupp.zero_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝ : (i : ι) → Zero (β i)\ni : ι\n⊢ Eq (0 i) 0","decl":"theorem zero_apply (i : ι) : (0 : Π₀ i, β i) i = 0 :=\n  rfl\n\n"}
{"name":"DFinsupp.mapRange_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ₁ : ι → Type v₁\nβ₂ : ι → Type v₂\ninst✝¹ : (i : ι) → Zero (β₁ i)\ninst✝ : (i : ι) → Zero (β₂ i)\nf : (i : ι) → β₁ i → β₂ i\nhf : ∀ (i : ι), Eq (f i 0) 0\ng : DFinsupp fun i => β₁ i\ni : ι\n⊢ Eq ((DFinsupp.mapRange f hf g) i) (f i (g i))","decl":"@[simp]\ntheorem mapRange_apply (f : ∀ i, β₁ i → β₂ i) (hf : ∀ i, f i 0 = 0) (g : Π₀ i, β₁ i) (i : ι) :\n    mapRange f hf g i = f i (g i) :=\n  rfl\n\n"}
{"name":"DFinsupp.mapRange_id","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ₁ : ι → Type v₁\ninst✝ : (i : ι) → Zero (β₁ i)\nh : optParam (∀ (i : ι), Eq (id 0) 0) ⋯\ng : DFinsupp fun i => β₁ i\n⊢ Eq (DFinsupp.mapRange (fun i => id) h g) g","decl":"@[simp]\ntheorem mapRange_id (h : ∀ i, id (0 : β₁ i) = 0 := fun _ => rfl) (g : Π₀ i : ι, β₁ i) :\n    mapRange (fun i => (id : β₁ i → β₁ i)) h g = g := by\n  ext\n  rfl\n\n"}
{"name":"DFinsupp.mapRange_comp","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\nβ₁ : ι → Type v₁\nβ₂ : ι → Type v₂\ninst✝² : (i : ι) → Zero (β i)\ninst✝¹ : (i : ι) → Zero (β₁ i)\ninst✝ : (i : ι) → Zero (β₂ i)\nf : (i : ι) → β₁ i → β₂ i\nf₂ : (i : ι) → β i → β₁ i\nhf : ∀ (i : ι), Eq (f i 0) 0\nhf₂ : ∀ (i : ι), Eq (f₂ i 0) 0\nh : ∀ (i : ι), Eq (Function.comp (f i) (f₂ i) 0) 0\ng : DFinsupp fun i => β i\n⊢ Eq (DFinsupp.mapRange (fun i => Function.comp (f i) (f₂ i)) h g) (DFinsupp.mapRange f hf (DFinsupp.mapRange f₂ hf₂ g))","decl":"theorem mapRange_comp (f : ∀ i, β₁ i → β₂ i) (f₂ : ∀ i, β i → β₁ i) (hf : ∀ i, f i 0 = 0)\n    (hf₂ : ∀ i, f₂ i 0 = 0) (h : ∀ i, (f i ∘ f₂ i) 0 = 0) (g : Π₀ i : ι, β i) :\n    mapRange (fun i => f i ∘ f₂ i) h g = mapRange f hf (mapRange f₂ hf₂ g) := by\n  ext\n  simp only [mapRange_apply]; rfl\n\n"}
{"name":"DFinsupp.mapRange_zero","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ₁ : ι → Type v₁\nβ₂ : ι → Type v₂\ninst✝¹ : (i : ι) → Zero (β₁ i)\ninst✝ : (i : ι) → Zero (β₂ i)\nf : (i : ι) → β₁ i → β₂ i\nhf : ∀ (i : ι), Eq (f i 0) 0\n⊢ Eq (DFinsupp.mapRange f hf 0) 0","decl":"@[simp]\ntheorem mapRange_zero (f : ∀ i, β₁ i → β₂ i) (hf : ∀ i, f i 0 = 0) :\n    mapRange f hf (0 : Π₀ i, β₁ i) = 0 := by\n  ext\n  simp only [mapRange_apply, coe_zero, Pi.zero_apply, hf]\n\n"}
{"name":"DFinsupp.zipWith_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\nβ₁ : ι → Type v₁\nβ₂ : ι → Type v₂\ninst✝² : (i : ι) → Zero (β i)\ninst✝¹ : (i : ι) → Zero (β₁ i)\ninst✝ : (i : ι) → Zero (β₂ i)\nf : (i : ι) → β₁ i → β₂ i → β i\nhf : ∀ (i : ι), Eq (f i 0 0) 0\ng₁ : DFinsupp fun i => β₁ i\ng₂ : DFinsupp fun i => β₂ i\ni : ι\n⊢ Eq ((DFinsupp.zipWith f hf g₁ g₂) i) (f i (g₁ i) (g₂ i))","decl":"@[simp]\ntheorem zipWith_apply (f : ∀ i, β₁ i → β₂ i → β i) (hf : ∀ i, f i 0 0 = 0) (g₁ : Π₀ i, β₁ i)\n    (g₂ : Π₀ i, β₂ i) (i : ι) : zipWith f hf g₁ g₂ i = f i (g₁ i) (g₂ i) :=\n  rfl\n\n"}
{"name":"DFinsupp.piecewise_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\nx y : DFinsupp fun i => β i\ns : Set ι\ninst✝ : (i : ι) → Decidable (Membership.mem s i)\ni : ι\n⊢ Eq ((x.piecewise y s) i) (ite (Membership.mem s i) (x i) (y i))","decl":"theorem piecewise_apply (i : ι) : x.piecewise y s i = if i ∈ s then x i else y i :=\n  zipWith_apply _ _ x y i\n\n"}
{"name":"DFinsupp.coe_piecewise","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\nx y : DFinsupp fun i => β i\ns : Set ι\ninst✝ : (i : ι) → Decidable (Membership.mem s i)\n⊢ Eq (⇑(x.piecewise y s)) (s.piecewise ⇑x ⇑y)","decl":"@[simp, norm_cast]\ntheorem coe_piecewise : ⇑(x.piecewise y s) = s.piecewise x y := by\n  ext\n  apply piecewise_apply\n\n"}
{"name":"DFinsupp.add_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝ : (i : ι) → AddZeroClass (β i)\ng₁ g₂ : DFinsupp fun i => β i\ni : ι\n⊢ Eq ((HAdd.hAdd g₁ g₂) i) (HAdd.hAdd (g₁ i) (g₂ i))","decl":"theorem add_apply [∀ i, AddZeroClass (β i)] (g₁ g₂ : Π₀ i, β i) (i : ι) :\n    (g₁ + g₂) i = g₁ i + g₂ i :=\n  rfl\n\n"}
{"name":"DFinsupp.coe_add","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝ : (i : ι) → AddZeroClass (β i)\ng₁ g₂ : DFinsupp fun i => β i\n⊢ Eq (⇑(HAdd.hAdd g₁ g₂)) (HAdd.hAdd ⇑g₁ ⇑g₂)","decl":"@[simp, norm_cast]\ntheorem coe_add [∀ i, AddZeroClass (β i)] (g₁ g₂ : Π₀ i, β i) : ⇑(g₁ + g₂) = g₁ + g₂ :=\n  rfl\n\n"}
{"name":"DFinsupp.instIsLeftCancelAdd","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → AddZeroClass (β i)\ninst✝ : ∀ (i : ι), IsLeftCancelAdd (β i)\n⊢ IsLeftCancelAdd (DFinsupp fun i => β i)","decl":"instance instIsLeftCancelAdd [∀ i, AddZeroClass (β i)] [∀ i, IsLeftCancelAdd (β i)] :\n    IsLeftCancelAdd (Π₀ i, β i) where\n  add_left_cancel _ _ _ h := ext fun x => add_left_cancel <| DFunLike.congr_fun h x\n\n"}
{"name":"DFinsupp.instIsRightCancelAdd","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → AddZeroClass (β i)\ninst✝ : ∀ (i : ι), IsRightCancelAdd (β i)\n⊢ IsRightCancelAdd (DFinsupp fun i => β i)","decl":"instance instIsRightCancelAdd [∀ i, AddZeroClass (β i)] [∀ i, IsRightCancelAdd (β i)] :\n    IsRightCancelAdd (Π₀ i, β i) where\n  add_right_cancel _ _ _ h := ext fun x => add_right_cancel <| DFunLike.congr_fun h x\n\n"}
{"name":"DFinsupp.instIsCancelAdd","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → AddZeroClass (β i)\ninst✝ : ∀ (i : ι), IsCancelAdd (β i)\n⊢ IsCancelAdd (DFinsupp fun i => β i)","decl":"instance instIsCancelAdd [∀ i, AddZeroClass (β i)] [∀ i, IsCancelAdd (β i)] :\n    IsCancelAdd (Π₀ i, β i) where\n\n"}
{"name":"DFinsupp.nsmul_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝ : (i : ι) → AddMonoid (β i)\nb : Nat\nv : DFinsupp fun i => β i\ni : ι\n⊢ Eq ((HSMul.hSMul b v) i) (HSMul.hSMul b (v i))","decl":"theorem nsmul_apply [∀ i, AddMonoid (β i)] (b : ℕ) (v : Π₀ i, β i) (i : ι) : (b • v) i = b • v i :=\n  rfl\n\n"}
{"name":"DFinsupp.coe_nsmul","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝ : (i : ι) → AddMonoid (β i)\nb : Nat\nv : DFinsupp fun i => β i\n⊢ Eq (⇑(HSMul.hSMul b v)) (HSMul.hSMul b ⇑v)","decl":"@[simp, norm_cast]\ntheorem coe_nsmul [∀ i, AddMonoid (β i)] (b : ℕ) (v : Π₀ i, β i) : ⇑(b • v) = b • ⇑v :=\n  rfl\n\n"}
{"name":"DFinsupp.neg_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝ : (i : ι) → AddGroup (β i)\ng : DFinsupp fun i => β i\ni : ι\n⊢ Eq ((Neg.neg g) i) (Neg.neg (g i))","decl":"theorem neg_apply [∀ i, AddGroup (β i)] (g : Π₀ i, β i) (i : ι) : (-g) i = -g i :=\n  rfl\n\n"}
{"name":"DFinsupp.coe_neg","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝ : (i : ι) → AddGroup (β i)\ng : DFinsupp fun i => β i\n⊢ Eq (⇑(Neg.neg g)) (Neg.neg ⇑g)","decl":"@[simp, norm_cast] lemma coe_neg [∀ i, AddGroup (β i)] (g : Π₀ i, β i) : ⇑(-g) = -g := rfl\n\n"}
{"name":"DFinsupp.sub_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝ : (i : ι) → AddGroup (β i)\ng₁ g₂ : DFinsupp fun i => β i\ni : ι\n⊢ Eq ((HSub.hSub g₁ g₂) i) (HSub.hSub (g₁ i) (g₂ i))","decl":"theorem sub_apply [∀ i, AddGroup (β i)] (g₁ g₂ : Π₀ i, β i) (i : ι) : (g₁ - g₂) i = g₁ i - g₂ i :=\n  rfl\n\n"}
{"name":"DFinsupp.coe_sub","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝ : (i : ι) → AddGroup (β i)\ng₁ g₂ : DFinsupp fun i => β i\n⊢ Eq (⇑(HSub.hSub g₁ g₂)) (HSub.hSub ⇑g₁ ⇑g₂)","decl":"@[simp, norm_cast]\ntheorem coe_sub [∀ i, AddGroup (β i)] (g₁ g₂ : Π₀ i, β i) : ⇑(g₁ - g₂) = g₁ - g₂ :=\n  rfl\n\n"}
{"name":"DFinsupp.zsmul_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝ : (i : ι) → AddGroup (β i)\nb : Int\nv : DFinsupp fun i => β i\ni : ι\n⊢ Eq ((HSMul.hSMul b v) i) (HSMul.hSMul b (v i))","decl":"theorem zsmul_apply [∀ i, AddGroup (β i)] (b : ℤ) (v : Π₀ i, β i) (i : ι) : (b • v) i = b • v i :=\n  rfl\n\n"}
{"name":"DFinsupp.coe_zsmul","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝ : (i : ι) → AddGroup (β i)\nb : Int\nv : DFinsupp fun i => β i\n⊢ Eq (⇑(HSMul.hSMul b v)) (HSMul.hSMul b ⇑v)","decl":"@[simp, norm_cast]\ntheorem coe_zsmul [∀ i, AddGroup (β i)] (b : ℤ) (v : Π₀ i, β i) : ⇑(b • v) = b • ⇑v :=\n  rfl\n\n"}
{"name":"DFinsupp.filter_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\np : ι → Prop\ninst✝ : DecidablePred p\ni : ι\nf : DFinsupp fun i => β i\n⊢ Eq ((DFinsupp.filter p f) i) (ite (p i) (f i) 0)","decl":"@[simp]\ntheorem filter_apply [∀ i, Zero (β i)] (p : ι → Prop) [DecidablePred p] (i : ι) (f : Π₀ i, β i) :\n    f.filter p i = if p i then f i else 0 :=\n  rfl\n\n"}
{"name":"DFinsupp.filter_apply_pos","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\np : ι → Prop\ninst✝ : DecidablePred p\nf : DFinsupp fun i => β i\ni : ι\nh : p i\n⊢ Eq ((DFinsupp.filter p f) i) (f i)","decl":"theorem filter_apply_pos [∀ i, Zero (β i)] {p : ι → Prop} [DecidablePred p] (f : Π₀ i, β i) {i : ι}\n    (h : p i) : f.filter p i = f i := by simp only [filter_apply, if_pos h]\n\n"}
{"name":"DFinsupp.filter_apply_neg","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\np : ι → Prop\ninst✝ : DecidablePred p\nf : DFinsupp fun i => β i\ni : ι\nh : Not (p i)\n⊢ Eq ((DFinsupp.filter p f) i) 0","decl":"theorem filter_apply_neg [∀ i, Zero (β i)] {p : ι → Prop} [DecidablePred p] (f : Π₀ i, β i) {i : ι}\n    (h : ¬p i) : f.filter p i = 0 := by simp only [filter_apply, if_neg h]\n\n"}
{"name":"DFinsupp.filter_pos_add_filter_neg","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → AddZeroClass (β i)\nf : DFinsupp fun i => β i\np : ι → Prop\ninst✝ : DecidablePred p\n⊢ Eq (HAdd.hAdd (DFinsupp.filter p f) (DFinsupp.filter (fun i => Not (p i)) f)) f","decl":"theorem filter_pos_add_filter_neg [∀ i, AddZeroClass (β i)] (f : Π₀ i, β i) (p : ι → Prop)\n    [DecidablePred p] : (f.filter p + f.filter fun i => ¬p i) = f :=\n  ext fun i => by\n    simp only [add_apply, filter_apply]; split_ifs <;> simp only [add_zero, zero_add]\n\n"}
{"name":"DFinsupp.filter_zero","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\np : ι → Prop\ninst✝ : DecidablePred p\n⊢ Eq (DFinsupp.filter p 0) 0","decl":"@[simp]\ntheorem filter_zero [∀ i, Zero (β i)] (p : ι → Prop) [DecidablePred p] :\n    (0 : Π₀ i, β i).filter p = 0 := by\n  ext\n  simp\n\n"}
{"name":"DFinsupp.filter_add","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → AddZeroClass (β i)\np : ι → Prop\ninst✝ : DecidablePred p\nf g : DFinsupp fun i => β i\n⊢ Eq (DFinsupp.filter p (HAdd.hAdd f g)) (HAdd.hAdd (DFinsupp.filter p f) (DFinsupp.filter p g))","decl":"@[simp]\ntheorem filter_add [∀ i, AddZeroClass (β i)] (p : ι → Prop) [DecidablePred p] (f g : Π₀ i, β i) :\n    (f + g).filter p = f.filter p + g.filter p := by\n  ext\n  simp [ite_add_zero]\n\n"}
{"name":"DFinsupp.filterAddMonoidHom_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → AddZeroClass (β i)\np : ι → Prop\ninst✝ : DecidablePred p\nx : DFinsupp fun i => β i\n⊢ Eq ((DFinsupp.filterAddMonoidHom β p) x) (DFinsupp.filter p x)","decl":"/-- `DFinsupp.filter` as an `AddMonoidHom`. -/\n@[simps]\ndef filterAddMonoidHom [∀ i, AddZeroClass (β i)] (p : ι → Prop) [DecidablePred p] :\n    (Π₀ i, β i) →+ Π₀ i, β i where\n  toFun := filter p\n  map_zero' := filter_zero p\n  map_add' := filter_add p\n\n"}
{"name":"DFinsupp.filter_neg","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → AddGroup (β i)\np : ι → Prop\ninst✝ : DecidablePred p\nf : DFinsupp fun i => β i\n⊢ Eq (DFinsupp.filter p (Neg.neg f)) (Neg.neg (DFinsupp.filter p f))","decl":"@[simp]\ntheorem filter_neg [∀ i, AddGroup (β i)] (p : ι → Prop) [DecidablePred p] (f : Π₀ i, β i) :\n    (-f).filter p = -f.filter p :=\n  (filterAddMonoidHom β p).map_neg f\n\n"}
{"name":"DFinsupp.filter_sub","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → AddGroup (β i)\np : ι → Prop\ninst✝ : DecidablePred p\nf g : DFinsupp fun i => β i\n⊢ Eq (DFinsupp.filter p (HSub.hSub f g)) (HSub.hSub (DFinsupp.filter p f) (DFinsupp.filter p g))","decl":"@[simp]\ntheorem filter_sub [∀ i, AddGroup (β i)] (p : ι → Prop) [DecidablePred p] (f g : Π₀ i, β i) :\n    (f - g).filter p = f.filter p - g.filter p :=\n  (filterAddMonoidHom β p).map_sub f g\n\n"}
{"name":"DFinsupp.subtypeDomain_zero","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\np : ι → Prop\ninst✝ : DecidablePred p\n⊢ Eq (DFinsupp.subtypeDomain p 0) 0","decl":"@[simp]\ntheorem subtypeDomain_zero [∀ i, Zero (β i)] {p : ι → Prop} [DecidablePred p] :\n    subtypeDomain p (0 : Π₀ i, β i) = 0 :=\n  rfl\n\n"}
{"name":"DFinsupp.subtypeDomain_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\np : ι → Prop\ninst✝ : DecidablePred p\ni : Subtype p\nv : DFinsupp fun i => β i\n⊢ Eq ((DFinsupp.subtypeDomain p v) i) (v ↑i)","decl":"@[simp]\ntheorem subtypeDomain_apply [∀ i, Zero (β i)] {p : ι → Prop} [DecidablePred p] {i : Subtype p}\n    {v : Π₀ i, β i} : (subtypeDomain p v) i = v i :=\n  rfl\n\n"}
{"name":"DFinsupp.subtypeDomain_add","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → AddZeroClass (β i)\np : ι → Prop\ninst✝ : DecidablePred p\nv v' : DFinsupp fun i => β i\n⊢ Eq (DFinsupp.subtypeDomain p (HAdd.hAdd v v')) (HAdd.hAdd (DFinsupp.subtypeDomain p v) (DFinsupp.subtypeDomain p v'))","decl":"@[simp]\ntheorem subtypeDomain_add [∀ i, AddZeroClass (β i)] {p : ι → Prop} [DecidablePred p]\n    (v v' : Π₀ i, β i) : (v + v').subtypeDomain p = v.subtypeDomain p + v'.subtypeDomain p :=\n  DFunLike.coe_injective rfl\n\n"}
{"name":"DFinsupp.subtypeDomainAddMonoidHom_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → AddZeroClass (β i)\np : ι → Prop\ninst✝ : DecidablePred p\nx : DFinsupp fun i => β i\n⊢ Eq ((DFinsupp.subtypeDomainAddMonoidHom β p) x) (DFinsupp.subtypeDomain p x)","decl":"/-- `subtypeDomain` but as an `AddMonoidHom`. -/\n@[simps]\ndef subtypeDomainAddMonoidHom [∀ i, AddZeroClass (β i)] (p : ι → Prop) [DecidablePred p] :\n    (Π₀ i : ι, β i) →+ Π₀ i : Subtype p, β i where\n  toFun := subtypeDomain p\n  map_zero' := subtypeDomain_zero\n  map_add' := subtypeDomain_add\n\n"}
{"name":"DFinsupp.subtypeDomain_neg","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → AddGroup (β i)\np : ι → Prop\ninst✝ : DecidablePred p\nv : DFinsupp fun i => β i\n⊢ Eq (DFinsupp.subtypeDomain p (Neg.neg v)) (Neg.neg (DFinsupp.subtypeDomain p v))","decl":"@[simp]\ntheorem subtypeDomain_neg [∀ i, AddGroup (β i)] {p : ι → Prop} [DecidablePred p] {v : Π₀ i, β i} :\n    (-v).subtypeDomain p = -v.subtypeDomain p :=\n  DFunLike.coe_injective rfl\n\n"}
{"name":"DFinsupp.subtypeDomain_sub","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → AddGroup (β i)\np : ι → Prop\ninst✝ : DecidablePred p\nv v' : DFinsupp fun i => β i\n⊢ Eq (DFinsupp.subtypeDomain p (HSub.hSub v v')) (HSub.hSub (DFinsupp.subtypeDomain p v) (DFinsupp.subtypeDomain p v'))","decl":"@[simp]\ntheorem subtypeDomain_sub [∀ i, AddGroup (β i)] {p : ι → Prop} [DecidablePred p]\n    {v v' : Π₀ i, β i} : (v - v').subtypeDomain p = v.subtypeDomain p - v'.subtypeDomain p :=\n  DFunLike.coe_injective rfl\n\n"}
{"name":"DFinsupp.finite_support","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝ : (i : ι) → Zero (β i)\nf : DFinsupp fun i => β i\n⊢ (setOf fun i => Ne (f i) 0).Finite","decl":"theorem finite_support (f : Π₀ i, β i) : Set.Finite { i | f i ≠ 0 } :=\n  Trunc.induction_on f.support' fun xs ↦\n    xs.1.finite_toSet.subset fun i H ↦ ((xs.prop i).resolve_right H)\n\n"}
{"name":"DFinsupp.mk_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\ns : Finset ι\nx : (i : ↑↑s) → β ↑i\ni : ι\n⊢ Eq ((DFinsupp.mk s x) i) (dite (Membership.mem s i) (fun H => x ⟨i, H⟩) fun H => 0)","decl":"@[simp]\ntheorem mk_apply : (mk s x : ∀ i, β i) i = if H : i ∈ s then x ⟨i, H⟩ else 0 :=\n  rfl\n\n"}
{"name":"DFinsupp.mk_of_mem","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\ns : Finset ι\nx : (i : ↑↑s) → β ↑i\ni : ι\nhi : Membership.mem s i\n⊢ Eq ((DFinsupp.mk s x) i) (x ⟨i, hi⟩)","decl":"theorem mk_of_mem (hi : i ∈ s) : (mk s x : ∀ i, β i) i = x ⟨i, hi⟩ :=\n  dif_pos hi\n\n"}
{"name":"DFinsupp.mk_of_not_mem","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\ns : Finset ι\nx : (i : ↑↑s) → β ↑i\ni : ι\nhi : Not (Membership.mem s i)\n⊢ Eq ((DFinsupp.mk s x) i) 0","decl":"theorem mk_of_not_mem (hi : i ∉ s) : (mk s x : ∀ i, β i) i = 0 :=\n  dif_neg hi\n\n"}
{"name":"DFinsupp.mk_injective","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\ns : Finset ι\n⊢ Function.Injective (DFinsupp.mk s)","decl":"theorem mk_injective (s : Finset ι) : Function.Injective (@mk ι β _ _ s) := by\n  intro x y H\n  ext i\n  have h1 : (mk s x : ∀ i, β i) i = (mk s y : ∀ i, β i) i := by rw [H]\n  obtain ⟨i, hi : i ∈ s⟩ := i\n  dsimp only [mk_apply, Subtype.coe_mk] at h1\n  simpa only [dif_pos hi] using h1\n\n"}
{"name":"DFinsupp.equivFunOnFintype_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : Fintype ι\na✝ : DFinsupp fun i => β i\na : ι\n⊢ Eq (DFinsupp.equivFunOnFintype a✝ a) (a✝ a)","decl":"/-- Given `Fintype ι`, `equivFunOnFintype` is the `Equiv` between `Π₀ i, β i` and `Π i, β i`.\n  (All dependent functions on a finite type are finitely supported.) -/\n@[simps apply]\ndef equivFunOnFintype [Fintype ι] : (Π₀ i, β i) ≃ ∀ i, β i where\n  toFun := (⇑)\n  invFun f := ⟨f, Trunc.mk ⟨Finset.univ.1, fun _ => Or.inl <| Finset.mem_univ_val _⟩⟩\n  left_inv _ := DFunLike.coe_injective rfl\n  right_inv _ := rfl\n\n"}
{"name":"DFinsupp.equivFunOnFintype_symm_coe","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : Fintype ι\nf : DFinsupp fun i => β i\n⊢ Eq (DFinsupp.equivFunOnFintype.symm ⇑f) f","decl":"@[simp]\ntheorem equivFunOnFintype_symm_coe [Fintype ι] (f : Π₀ i, β i) : equivFunOnFintype.symm f = f :=\n  Equiv.symm_apply_apply _ _\n\n"}
{"name":"DFinsupp.single_eq_pi_single","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\ni : ι\nb : β i\n⊢ Eq (⇑(DFinsupp.single i b)) (Pi.single i b)","decl":"theorem single_eq_pi_single {i b} : ⇑(single i b : Π₀ i, β i) = Pi.single i b :=\n  rfl\n\n"}
{"name":"DFinsupp.single_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\ni i' : ι\nb : β i\n⊢ Eq ((DFinsupp.single i b) i') (dite (Eq i i') (fun h => Eq.recOn h b) fun h => 0)","decl":"@[simp]\ntheorem single_apply {i i' b} :\n    (single i b : Π₀ i, β i) i' = if h : i = i' then Eq.recOn h b else 0 := by\n  rw [single_eq_pi_single, Pi.single, Function.update]\n  simp [@eq_comm _ i i']\n\n"}
{"name":"DFinsupp.single_zero","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\ni : ι\n⊢ Eq (DFinsupp.single i 0) 0","decl":"@[simp]\ntheorem single_zero (i) : (single i 0 : Π₀ i, β i) = 0 :=\n  DFunLike.coe_injective <| Pi.single_zero _\n\n"}
{"name":"DFinsupp.single_eq_same","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\ni : ι\nb : β i\n⊢ Eq ((DFinsupp.single i b) i) b","decl":"theorem single_eq_same {i b} : (single i b : Π₀ i, β i) i = b := by\n  simp only [single_apply, dite_eq_ite, ite_true]\n\n"}
{"name":"DFinsupp.single_eq_of_ne","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\ni i' : ι\nb : β i\nh : Ne i i'\n⊢ Eq ((DFinsupp.single i b) i') 0","decl":"theorem single_eq_of_ne {i i' b} (h : i ≠ i') : (single i b : Π₀ i, β i) i' = 0 := by\n  simp only [single_apply, dif_neg h]\n\n"}
{"name":"DFinsupp.single_injective","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\ni : ι\n⊢ Function.Injective (DFinsupp.single i)","decl":"theorem single_injective {i} : Function.Injective (single i : β i → Π₀ i, β i) := fun _ _ H =>\n  Pi.single_injective β i <| DFunLike.coe_injective.eq_iff.mpr H\n\n"}
{"name":"DFinsupp.single_eq_single_iff","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\ni j : ι\nxi : β i\nxj : β j\n⊢ Iff (Eq (DFinsupp.single i xi) (DFinsupp.single j xj)) (Or (And (Eq i j) (HEq xi xj)) (And (Eq xi 0) (Eq xj 0)))","decl":"/-- Like `Finsupp.single_eq_single_iff`, but with a `HEq` due to dependent types -/\ntheorem single_eq_single_iff (i j : ι) (xi : β i) (xj : β j) :\n    DFinsupp.single i xi = DFinsupp.single j xj ↔ i = j ∧ HEq xi xj ∨ xi = 0 ∧ xj = 0 := by\n  constructor\n  · intro h\n    by_cases hij : i = j\n    · subst hij\n      exact Or.inl ⟨rfl, heq_of_eq (DFinsupp.single_injective h)⟩\n    · have h_coe : ⇑(DFinsupp.single i xi) = DFinsupp.single j xj := congr_arg (⇑) h\n      have hci := congr_fun h_coe i\n      have hcj := congr_fun h_coe j\n      rw [DFinsupp.single_eq_same] at hci hcj\n      rw [DFinsupp.single_eq_of_ne (Ne.symm hij)] at hci\n      rw [DFinsupp.single_eq_of_ne hij] at hcj\n      exact Or.inr ⟨hci, hcj.symm⟩\n  · rintro (⟨rfl, hxi⟩ | ⟨hi, hj⟩)\n    · rw [eq_of_heq hxi]\n    · rw [hi, hj, DFinsupp.single_zero, DFinsupp.single_zero]\n\n"}
{"name":"DFinsupp.single_left_injective","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\nb : (i : ι) → β i\nh : ∀ (i : ι), Ne (b i) 0\n⊢ Function.Injective fun i => DFinsupp.single i (b i)","decl":"/-- `DFinsupp.single a b` is injective in `a`. For the statement that it is injective in `b`, see\n`DFinsupp.single_injective` -/\ntheorem single_left_injective {b : ∀ i : ι, β i} (h : ∀ i, b i ≠ 0) :\n    Function.Injective (fun i => single i (b i) : ι → Π₀ i, β i) := fun _ _ H =>\n  (((single_eq_single_iff _ _ _ _).mp H).resolve_right fun hb => h _ hb.1).left\n\n"}
{"name":"DFinsupp.single_eq_zero","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\ni : ι\nxi : β i\n⊢ Iff (Eq (DFinsupp.single i xi) 0) (Eq xi 0)","decl":"@[simp]\ntheorem single_eq_zero {i : ι} {xi : β i} : single i xi = 0 ↔ xi = 0 := by\n  rw [← single_zero i, single_eq_single_iff]\n  simp\n\n"}
{"name":"DFinsupp.filter_single","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : (i : ι) → Zero (β i)\ninst✝¹ : DecidableEq ι\np : ι → Prop\ninst✝ : DecidablePred p\ni : ι\nx : β i\n⊢ Eq (DFinsupp.filter p (DFinsupp.single i x)) (ite (p i) (DFinsupp.single i x) 0)","decl":"theorem filter_single (p : ι → Prop) [DecidablePred p] (i : ι) (x : β i) :\n    (single i x).filter p = if p i then single i x else 0 := by\n  ext j\n  have := apply_ite (fun x : Π₀ i, β i => x j) (p i) (single i x) 0\n  dsimp at this\n  rw [filter_apply, this]\n  obtain rfl | hij := Decidable.eq_or_ne i j\n  · rfl\n  · rw [single_eq_of_ne hij, ite_self, ite_self]\n\n"}
{"name":"DFinsupp.filter_single_pos","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : (i : ι) → Zero (β i)\ninst✝¹ : DecidableEq ι\np : ι → Prop\ninst✝ : DecidablePred p\ni : ι\nx : β i\nh : p i\n⊢ Eq (DFinsupp.filter p (DFinsupp.single i x)) (DFinsupp.single i x)","decl":"@[simp]\ntheorem filter_single_pos {p : ι → Prop} [DecidablePred p] (i : ι) (x : β i) (h : p i) :\n    (single i x).filter p = single i x := by rw [filter_single, if_pos h]\n\n"}
{"name":"DFinsupp.filter_single_neg","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : (i : ι) → Zero (β i)\ninst✝¹ : DecidableEq ι\np : ι → Prop\ninst✝ : DecidablePred p\ni : ι\nx : β i\nh : Not (p i)\n⊢ Eq (DFinsupp.filter p (DFinsupp.single i x)) 0","decl":"@[simp]\ntheorem filter_single_neg {p : ι → Prop} [DecidablePred p] (i : ι) (x : β i) (h : ¬p i) :\n    (single i x).filter p = 0 := by rw [filter_single, if_neg h]\n\n"}
{"name":"DFinsupp.single_eq_of_sigma_eq","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\ni j : ι\nxi : β i\nxj : β j\nh : Eq ⟨i, xi⟩ ⟨j, xj⟩\n⊢ Eq (DFinsupp.single i xi) (DFinsupp.single j xj)","decl":"/-- Equality of sigma types is sufficient (but not necessary) to show equality of `DFinsupp`s. -/\ntheorem single_eq_of_sigma_eq {i j} {xi : β i} {xj : β j} (h : (⟨i, xi⟩ : Sigma β) = ⟨j, xj⟩) :\n    DFinsupp.single i xi = DFinsupp.single j xj := by\n  cases h\n  rfl\n\n"}
{"name":"DFinsupp.equivFunOnFintype_single","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : (i : ι) → Zero (β i)\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\ni : ι\nm : β i\n⊢ Eq (DFinsupp.equivFunOnFintype (DFinsupp.single i m)) (Pi.single i m)","decl":"@[simp]\ntheorem equivFunOnFintype_single [Fintype ι] (i : ι) (m : β i) :\n    (@DFinsupp.equivFunOnFintype ι β _ _) (DFinsupp.single i m) = Pi.single i m := by\n  ext x\n  dsimp [Pi.single, Function.update]\n  simp [DFinsupp.single_eq_pi_single, @eq_comm _ i]\n\n"}
{"name":"DFinsupp.equivFunOnFintype_symm_single","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : (i : ι) → Zero (β i)\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\ni : ι\nm : β i\n⊢ Eq (DFinsupp.equivFunOnFintype.symm (Pi.single i m)) (DFinsupp.single i m)","decl":"@[simp]\ntheorem equivFunOnFintype_symm_single [Fintype ι] (i : ι) (m : β i) :\n    (@DFinsupp.equivFunOnFintype ι β _ _).symm (Pi.single i m) = DFinsupp.single i m := by\n  ext i'\n  simp only [← single_eq_pi_single, equivFunOnFintype_symm_coe]\n\n"}
{"name":"DFinsupp.zipWith_single_single","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\nβ₁ : ι → Type v₁\nβ₂ : ι → Type v₂\ninst✝³ : (i : ι) → Zero (β i)\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (β₁ i)\ninst✝ : (i : ι) → Zero (β₂ i)\nf : (i : ι) → β₁ i → β₂ i → β i\nhf : ∀ (i : ι), Eq (f i 0 0) 0\ni : ι\nb₁ : β₁ i\nb₂ : β₂ i\n⊢ Eq (DFinsupp.zipWith f hf (DFinsupp.single i b₁) (DFinsupp.single i b₂)) (DFinsupp.single i (f i b₁ b₂))","decl":"@[simp]\ntheorem zipWith_single_single (f : ∀ i, β₁ i → β₂ i → β i) (hf : ∀ i, f i 0 0 = 0)\n    {i} (b₁ : β₁ i) (b₂ : β₂ i) :\n    zipWith f hf (single i b₁) (single i b₂) = single i (f i b₁ b₂) := by\n  ext j\n  rw [zipWith_apply]\n  obtain rfl | hij := Decidable.eq_or_ne i j\n  · rw [single_eq_same, single_eq_same, single_eq_same]\n  · rw [single_eq_of_ne hij, single_eq_of_ne hij, single_eq_of_ne hij, hf]\n\n"}
{"name":"DFinsupp.erase_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\ni j : ι\nf : DFinsupp fun i => β i\n⊢ Eq ((DFinsupp.erase i f) j) (ite (Eq j i) 0 (f j))","decl":"@[simp]\ntheorem erase_apply {i j : ι} {f : Π₀ i, β i} : (f.erase i) j = if j = i then 0 else f j :=\n  rfl\n\n"}
{"name":"DFinsupp.erase_same","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\ni : ι\nf : DFinsupp fun i => β i\n⊢ Eq ((DFinsupp.erase i f) i) 0","decl":"theorem erase_same {i : ι} {f : Π₀ i, β i} : (f.erase i) i = 0 := by simp\n\n"}
{"name":"DFinsupp.erase_ne","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\ni i' : ι\nf : DFinsupp fun i => β i\nh : Ne i' i\n⊢ Eq ((DFinsupp.erase i f) i') (f i')","decl":"theorem erase_ne {i i' : ι} {f : Π₀ i, β i} (h : i' ≠ i) : (f.erase i) i' = f i' := by simp [h]\n\n"}
{"name":"DFinsupp.piecewise_single_erase","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : (i : ι) → Zero (β i)\ninst✝¹ : DecidableEq ι\nx : DFinsupp fun i => β i\ni : ι\ninst✝ : (i' : ι) → Decidable (Membership.mem (Singleton.singleton i) i')\n⊢ Eq ((DFinsupp.single i (x i)).piecewise (DFinsupp.erase i x) (Singleton.singleton i)) x","decl":"theorem piecewise_single_erase (x : Π₀ i, β i) (i : ι)\n    [∀ i' : ι, Decidable <| (i' ∈ ({i} : Set ι))] : -- Porting note: added Decidable hypothesis\n    (single i (x i)).piecewise (x.erase i) {i} = x := by\n  ext j; rw [piecewise_apply]; split_ifs with h\n  · rw [(id h : j = i), single_eq_same]\n  · exact erase_ne h\n\n"}
{"name":"DFinsupp.erase_eq_sub_single","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\ninst✝¹ : DecidableEq ι\nβ : ι → Type u_1\ninst✝ : (i : ι) → AddGroup (β i)\nf : DFinsupp fun i => β i\ni : ι\n⊢ Eq (DFinsupp.erase i f) (HSub.hSub f (DFinsupp.single i (f i)))","decl":"theorem erase_eq_sub_single {β : ι → Type*} [∀ i, AddGroup (β i)] (f : Π₀ i, β i) (i : ι) :\n    f.erase i = f - single i (f i) := by\n  ext j\n  rcases eq_or_ne i j with (rfl | h)\n  · simp\n  · simp [erase_ne h.symm, single_eq_of_ne h, @eq_comm _ j, h]\n\n"}
{"name":"DFinsupp.erase_zero","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\ni : ι\n⊢ Eq (DFinsupp.erase i 0) 0","decl":"@[simp]\ntheorem erase_zero (i : ι) : erase i (0 : Π₀ i, β i) = 0 :=\n  ext fun _ => ite_self _\n\n"}
{"name":"DFinsupp.filter_ne_eq_erase","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\nf : DFinsupp fun i => β i\ni : ι\n⊢ Eq (DFinsupp.filter (fun x => Ne x i) f) (DFinsupp.erase i f)","decl":"@[simp]\ntheorem filter_ne_eq_erase (f : Π₀ i, β i) (i : ι) : f.filter (· ≠ i) = f.erase i := by\n  ext1 j\n  simp only [DFinsupp.filter_apply, DFinsupp.erase_apply, ite_not]\n\n"}
{"name":"DFinsupp.filter_ne_eq_erase'","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\nf : DFinsupp fun i => β i\ni : ι\n⊢ Eq (DFinsupp.filter (fun x => Ne i x) f) (DFinsupp.erase i f)","decl":"@[simp]\ntheorem filter_ne_eq_erase' (f : Π₀ i, β i) (i : ι) : f.filter (i ≠ ·) = f.erase i := by\n  rw [← filter_ne_eq_erase f i]\n  congr with j\n  exact ne_comm\n\n"}
{"name":"DFinsupp.erase_single","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\nj i : ι\nx : β i\n⊢ Eq (DFinsupp.erase j (DFinsupp.single i x)) (ite (Eq i j) 0 (DFinsupp.single i x))","decl":"theorem erase_single (j : ι) (i : ι) (x : β i) :\n    (single i x).erase j = if i = j then 0 else single i x := by\n  rw [← filter_ne_eq_erase, filter_single, ite_not]\n\n"}
{"name":"DFinsupp.erase_single_same","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\ni : ι\nx : β i\n⊢ Eq (DFinsupp.erase i (DFinsupp.single i x)) 0","decl":"@[simp]\ntheorem erase_single_same (i : ι) (x : β i) : (single i x).erase i = 0 := by\n  rw [erase_single, if_pos rfl]\n\n"}
{"name":"DFinsupp.erase_single_ne","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\ni j : ι\nx : β i\nh : Ne i j\n⊢ Eq (DFinsupp.erase j (DFinsupp.single i x)) (DFinsupp.single i x)","decl":"@[simp]\ntheorem erase_single_ne {i j : ι} (x : β i) (h : i ≠ j) : (single i x).erase j = single i x := by\n  rw [erase_single, if_neg h]\n\n"}
{"name":"DFinsupp.coe_update","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\nf : DFinsupp fun i => β i\ni : ι\nb : β i\n⊢ Eq (⇑(f.update i b)) (Function.update (⇑f) i b)","decl":"@[simp, norm_cast] lemma coe_update : (f.update i b : ∀ i : ι, β i) = Function.update f i b := rfl\n\n"}
{"name":"DFinsupp.update_self","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\nf : DFinsupp fun i => β i\ni : ι\n⊢ Eq (f.update i (f i)) f","decl":"@[simp]\ntheorem update_self : f.update i (f i) = f := by\n  ext\n  simp\n\n"}
{"name":"DFinsupp.update_eq_erase","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : DecidableEq ι\nf : DFinsupp fun i => β i\ni : ι\n⊢ Eq (f.update i 0) (DFinsupp.erase i f)","decl":"@[simp]\ntheorem update_eq_erase : f.update i 0 = f.erase i := by\n  ext j\n  rcases eq_or_ne i j with (rfl | hi)\n  · simp\n  · simp [hi.symm]\n\n"}
{"name":"DFinsupp.update_eq_single_add_erase","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\ninst✝¹ : DecidableEq ι\nβ : ι → Type u_1\ninst✝ : (i : ι) → AddZeroClass (β i)\nf : DFinsupp fun i => β i\ni : ι\nb : β i\n⊢ Eq (f.update i b) (HAdd.hAdd (DFinsupp.single i b) (DFinsupp.erase i f))","decl":"theorem update_eq_single_add_erase {β : ι → Type*} [∀ i, AddZeroClass (β i)] (f : Π₀ i, β i)\n    (i : ι) (b : β i) : f.update i b = single i b + f.erase i := by\n  ext j\n  rcases eq_or_ne i j with (rfl | h)\n  · simp\n  · simp [Function.update_of_ne h.symm, h, erase_ne, h.symm]\n\n"}
{"name":"DFinsupp.update_eq_erase_add_single","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\ninst✝¹ : DecidableEq ι\nβ : ι → Type u_1\ninst✝ : (i : ι) → AddZeroClass (β i)\nf : DFinsupp fun i => β i\ni : ι\nb : β i\n⊢ Eq (f.update i b) (HAdd.hAdd (DFinsupp.erase i f) (DFinsupp.single i b))","decl":"theorem update_eq_erase_add_single {β : ι → Type*} [∀ i, AddZeroClass (β i)] (f : Π₀ i, β i)\n    (i : ι) (b : β i) : f.update i b = f.erase i + single i b := by\n  ext j\n  rcases eq_or_ne i j with (rfl | h)\n  · simp\n  · simp [Function.update_of_ne h.symm, h, erase_ne, h.symm]\n\n"}
{"name":"DFinsupp.update_eq_sub_add_single","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\ninst✝¹ : DecidableEq ι\nβ : ι → Type u_1\ninst✝ : (i : ι) → AddGroup (β i)\nf : DFinsupp fun i => β i\ni : ι\nb : β i\n⊢ Eq (f.update i b) (HAdd.hAdd (HSub.hSub f (DFinsupp.single i (f i))) (DFinsupp.single i b))","decl":"theorem update_eq_sub_add_single {β : ι → Type*} [∀ i, AddGroup (β i)] (f : Π₀ i, β i) (i : ι)\n    (b : β i) : f.update i b = f - single i (f i) + single i b := by\n  rw [update_eq_erase_add_single f i b, erase_eq_sub_single f i]\n\n"}
{"name":"DFinsupp.single_add","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → AddZeroClass (β i)\ni : ι\nb₁ b₂ : β i\n⊢ Eq (DFinsupp.single i (HAdd.hAdd b₁ b₂)) (HAdd.hAdd (DFinsupp.single i b₁) (DFinsupp.single i b₂))","decl":"@[simp]\ntheorem single_add (i : ι) (b₁ b₂ : β i) : single i (b₁ + b₂) = single i b₁ + single i b₂ :=\n  (zipWith_single_single (fun _ => (· + ·)) _ b₁ b₂).symm\n\n"}
{"name":"DFinsupp.erase_add","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → AddZeroClass (β i)\ni : ι\nf₁ f₂ : DFinsupp fun i => β i\n⊢ Eq (DFinsupp.erase i (HAdd.hAdd f₁ f₂)) (HAdd.hAdd (DFinsupp.erase i f₁) (DFinsupp.erase i f₂))","decl":"@[simp]\ntheorem erase_add (i : ι) (f₁ f₂ : Π₀ i, β i) : erase i (f₁ + f₂) = erase i f₁ + erase i f₂ :=\n  ext fun _ => by simp [ite_zero_add]\n\n"}
{"name":"DFinsupp.singleAddHom_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → AddZeroClass (β i)\ni : ι\nb : β i\n⊢ Eq ((DFinsupp.singleAddHom β i) b) (DFinsupp.single i b)","decl":"/-- `DFinsupp.single` as an `AddMonoidHom`. -/\n@[simps]\ndef singleAddHom (i : ι) : β i →+ Π₀ i, β i where\n  toFun := single i\n  map_zero' := single_zero i\n  map_add' := single_add i\n\n"}
{"name":"DFinsupp.eraseAddHom_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → AddZeroClass (β i)\ni : ι\nx : DFinsupp fun i => β i\n⊢ Eq ((DFinsupp.eraseAddHom β i) x) (DFinsupp.erase i x)","decl":"/-- `DFinsupp.erase` as an `AddMonoidHom`. -/\n@[simps]\ndef eraseAddHom (i : ι) : (Π₀ i, β i) →+ Π₀ i, β i where\n  toFun := erase i\n  map_zero' := erase_zero i\n  map_add' := erase_add i\n\n"}
{"name":"DFinsupp.single_neg","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\ninst✝¹ : DecidableEq ι\nβ : ι → Type v\ninst✝ : (i : ι) → AddGroup (β i)\ni : ι\nx : β i\n⊢ Eq (DFinsupp.single i (Neg.neg x)) (Neg.neg (DFinsupp.single i x))","decl":"@[simp]\ntheorem single_neg {β : ι → Type v} [∀ i, AddGroup (β i)] (i : ι) (x : β i) :\n    single i (-x) = -single i x :=\n  (singleAddHom β i).map_neg x\n\n"}
{"name":"DFinsupp.single_sub","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\ninst✝¹ : DecidableEq ι\nβ : ι → Type v\ninst✝ : (i : ι) → AddGroup (β i)\ni : ι\nx y : β i\n⊢ Eq (DFinsupp.single i (HSub.hSub x y)) (HSub.hSub (DFinsupp.single i x) (DFinsupp.single i y))","decl":"@[simp]\ntheorem single_sub {β : ι → Type v} [∀ i, AddGroup (β i)] (i : ι) (x y : β i) :\n    single i (x - y) = single i x - single i y :=\n  (singleAddHom β i).map_sub x y\n\n"}
{"name":"DFinsupp.erase_neg","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\ninst✝¹ : DecidableEq ι\nβ : ι → Type v\ninst✝ : (i : ι) → AddGroup (β i)\ni : ι\nf : DFinsupp fun i => β i\n⊢ Eq (DFinsupp.erase i (Neg.neg f)) (Neg.neg (DFinsupp.erase i f))","decl":"@[simp]\ntheorem erase_neg {β : ι → Type v} [∀ i, AddGroup (β i)] (i : ι) (f : Π₀ i, β i) :\n    (-f).erase i = -f.erase i :=\n  (eraseAddHom β i).map_neg f\n\n"}
{"name":"DFinsupp.erase_sub","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\ninst✝¹ : DecidableEq ι\nβ : ι → Type v\ninst✝ : (i : ι) → AddGroup (β i)\ni : ι\nf g : DFinsupp fun i => β i\n⊢ Eq (DFinsupp.erase i (HSub.hSub f g)) (HSub.hSub (DFinsupp.erase i f) (DFinsupp.erase i g))","decl":"@[simp]\ntheorem erase_sub {β : ι → Type v} [∀ i, AddGroup (β i)] (i : ι) (f g : Π₀ i, β i) :\n    (f - g).erase i = f.erase i - g.erase i :=\n  (eraseAddHom β i).map_sub f g\n\n"}
{"name":"DFinsupp.single_add_erase","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → AddZeroClass (β i)\ni : ι\nf : DFinsupp fun i => β i\n⊢ Eq (HAdd.hAdd (DFinsupp.single i (f i)) (DFinsupp.erase i f)) f","decl":"theorem single_add_erase (i : ι) (f : Π₀ i, β i) : single i (f i) + f.erase i = f :=\n  ext fun i' =>\n    if h : i = i' then by\n      subst h; simp only [add_apply, single_apply, erase_apply, add_zero, dite_eq_ite, if_true]\n    else by\n      simp only [add_apply, single_apply, erase_apply, dif_neg h, if_neg (Ne.symm h), zero_add]\n\n"}
{"name":"DFinsupp.erase_add_single","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → AddZeroClass (β i)\ni : ι\nf : DFinsupp fun i => β i\n⊢ Eq (HAdd.hAdd (DFinsupp.erase i f) (DFinsupp.single i (f i))) f","decl":"theorem erase_add_single (i : ι) (f : Π₀ i, β i) : f.erase i + single i (f i) = f :=\n  ext fun i' =>\n    if h : i = i' then by\n      subst h; simp only [add_apply, single_apply, erase_apply, zero_add, dite_eq_ite, if_true]\n    else by\n      simp only [add_apply, single_apply, erase_apply, dif_neg h, if_neg (Ne.symm h), add_zero]\n\n"}
{"name":"DFinsupp.induction","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → AddZeroClass (β i)\np : (DFinsupp fun i => β i) → Prop\nf : DFinsupp fun i => β i\nh0 : p 0\nha : ∀ (i : ι) (b : β i) (f : DFinsupp fun i => β i), Eq (f i) 0 → Ne b 0 → p f → p (HAdd.hAdd (DFinsupp.single i b) f)\n⊢ p f","decl":"protected theorem induction {p : (Π₀ i, β i) → Prop} (f : Π₀ i, β i) (h0 : p 0)\n    (ha : ∀ (i b) (f : Π₀ i, β i), f i = 0 → b ≠ 0 → p f → p (single i b + f)) : p f := by\n  cases' f with f s\n  induction' s using Trunc.induction_on with s\n  cases' s with s H\n  induction' s using Multiset.induction_on with i s ih generalizing f\n  · have : f = 0 := funext fun i => (H i).resolve_left (Multiset.not_mem_zero _)\n    subst this\n    exact h0\n  have H2 : p (erase i ⟨f, Trunc.mk ⟨i ::ₘ s, H⟩⟩) := by\n    dsimp only [erase, Trunc.map, Trunc.bind, Trunc.liftOn, Trunc.lift_mk,\n      Function.comp, Subtype.coe_mk]\n    have H2 : ∀ j, j ∈ s ∨ ite (j = i) 0 (f j) = 0 := by\n      intro j\n      cases' H j with H2 H2\n      · cases' Multiset.mem_cons.1 H2 with H3 H3\n        · right; exact if_pos H3\n        · left; exact H3\n      right\n      split_ifs <;> [rfl; exact H2]\n    have H3 : ∀ aux, (⟨fun j : ι => ite (j = i) 0 (f j), Trunc.mk ⟨i ::ₘ s, aux⟩⟩ : Π₀ i, β i) =\n        ⟨fun j : ι => ite (j = i) 0 (f j), Trunc.mk ⟨s, H2⟩⟩ :=\n      fun _ ↦ ext fun _ => rfl\n    rw [H3]\n    apply ih\n  have H3 : single i _ + _ = (⟨f, Trunc.mk ⟨i ::ₘ s, H⟩⟩ : Π₀ i, β i) := single_add_erase _ _\n  rw [← H3]\n  change p (single i (f i) + _)\n  cases' Classical.em (f i = 0) with h h\n  · rw [h, single_zero, zero_add]\n    exact H2\n  refine ha _ _ _ ?_ h H2\n  rw [erase_same]\n\n"}
{"name":"DFinsupp.induction₂","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → AddZeroClass (β i)\np : (DFinsupp fun i => β i) → Prop\nf : DFinsupp fun i => β i\nh0 : p 0\nha : ∀ (i : ι) (b : β i) (f : DFinsupp fun i => β i), Eq (f i) 0 → Ne b 0 → p f → p (HAdd.hAdd f (DFinsupp.single i b))\n⊢ p f","decl":"theorem induction₂ {p : (Π₀ i, β i) → Prop} (f : Π₀ i, β i) (h0 : p 0)\n    (ha : ∀ (i b) (f : Π₀ i, β i), f i = 0 → b ≠ 0 → p f → p (f + single i b)) : p f :=\n  DFinsupp.induction f h0 fun i b f h1 h2 h3 =>\n    have h4 : f + single i b = single i b + f := by\n      ext j; by_cases H : i = j\n      · subst H\n        simp [h1]\n      · simp [H]\n    Eq.recOn h4 <| ha i b f h1 h2 h3\n\n"}
{"name":"DFinsupp.mk_add","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → AddZeroClass (β i)\ns : Finset ι\nx y : (i : ↑↑s) → β ↑i\n⊢ Eq (DFinsupp.mk s (HAdd.hAdd x y)) (HAdd.hAdd (DFinsupp.mk s x) (DFinsupp.mk s y))","decl":"@[simp]\ntheorem mk_add [∀ i, AddZeroClass (β i)] {s : Finset ι} {x y : ∀ i : (↑s : Set ι), β i} :\n    mk s (x + y) = mk s x + mk s y :=\n  ext fun i => by simp only [add_apply, mk_apply]; split_ifs <;> [rfl; rw [zero_add]]\n\n"}
{"name":"DFinsupp.mk_zero","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → Zero (β i)\ns : Finset ι\n⊢ Eq (DFinsupp.mk s 0) 0","decl":"@[simp]\ntheorem mk_zero [∀ i, Zero (β i)] {s : Finset ι} : mk s (0 : ∀ i : (↑s : Set ι), β i.1) = 0 :=\n  ext fun i => by simp only [mk_apply]; split_ifs <;> rfl\n\n"}
{"name":"DFinsupp.mk_neg","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → AddGroup (β i)\ns : Finset ι\nx : (i : ↑↑s) → β ↑i\n⊢ Eq (DFinsupp.mk s (Neg.neg x)) (Neg.neg (DFinsupp.mk s x))","decl":"@[simp]\ntheorem mk_neg [∀ i, AddGroup (β i)] {s : Finset ι} {x : ∀ i : (↑s : Set ι), β i.1} :\n    mk s (-x) = -mk s x :=\n  ext fun i => by simp only [neg_apply, mk_apply]; split_ifs <;> [rfl; rw [neg_zero]]\n\n"}
{"name":"DFinsupp.mk_sub","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → AddGroup (β i)\ns : Finset ι\nx y : (i : ↑↑s) → β ↑i\n⊢ Eq (DFinsupp.mk s (HSub.hSub x y)) (HSub.hSub (DFinsupp.mk s x) (DFinsupp.mk s y))","decl":"@[simp]\ntheorem mk_sub [∀ i, AddGroup (β i)] {s : Finset ι} {x y : ∀ i : (↑s : Set ι), β i.1} :\n    mk s (x - y) = mk s x - mk s y :=\n  ext fun i => by simp only [sub_apply, mk_apply]; split_ifs <;> [rfl; rw [sub_zero]]\n\n"}
{"name":"DFinsupp.support_mk_subset","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ns : Finset ι\nx : (i : ↑↑s) → β ↑i\n⊢ HasSubset.Subset (DFinsupp.mk s x).support s","decl":"@[simp]\ntheorem support_mk_subset {s : Finset ι} {x : ∀ i : (↑s : Set ι), β i.1} : (mk s x).support ⊆ s :=\n  fun _ H => Multiset.mem_toFinset.1 (Finset.mem_filter.1 H).1\n\n"}
{"name":"DFinsupp.support_mk'_subset","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\nf : (i : ι) → β i\ns : Multiset ι\nh : ∀ (i : ι), Or (Membership.mem s i) (Eq (f i) 0)\n⊢ HasSubset.Subset { toFun := f, support' := Trunc.mk ⟨s, h⟩ }.support s.toFinset","decl":"@[simp]\ntheorem support_mk'_subset {f : ∀ i, β i} {s : Multiset ι} {h} :\n    (mk' f <| Trunc.mk ⟨s, h⟩).support ⊆ s.toFinset := fun i H =>\n  Multiset.mem_toFinset.1 <| by simpa using (Finset.mem_filter.1 H).1\n\n"}
{"name":"DFinsupp.mem_support_toFun","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\nf : DFinsupp fun i => β i\ni : ι\n⊢ Iff (Membership.mem f.support i) (Ne (f i) 0)","decl":"@[simp]\ntheorem mem_support_toFun (f : Π₀ i, β i) (i) : i ∈ f.support ↔ f i ≠ 0 := by\n  cases' f with f s\n  induction' s using Trunc.induction_on with s\n  dsimp only [support, Trunc.lift_mk]\n  rw [Finset.mem_filter, Multiset.mem_toFinset, coe_mk']\n  exact and_iff_right_of_imp (s.prop i).resolve_right\n\n"}
{"name":"DFinsupp.eq_mk_support","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\nf : DFinsupp fun i => β i\n⊢ Eq f (DFinsupp.mk f.support fun i => f ↑i)","decl":"theorem eq_mk_support (f : Π₀ i, β i) : f = mk f.support fun i => f i := by aesop\n\n"}
{"name":"DFinsupp.subtypeSupportEqEquiv_symm_apply_coe","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ns : Finset ι\nf : (i : Subtype fun x => Membership.mem s x) → Subtype fun x => Ne x 0\n⊢ Eq (↑((DFinsupp.subtypeSupportEqEquiv s).symm f)) (DFinsupp.mk s fun i => ↑(f i))","decl":"/-- Equivalence between dependent functions with finite support `s : Finset ι` and functions\n`∀ i, {x : β i // x ≠ 0}`. -/\n@[simps]\ndef subtypeSupportEqEquiv (s : Finset ι) :\n    {f : Π₀ i, β i // f.support = s} ≃ ∀ i : s, {x : β i // x ≠ 0} where\n  toFun | ⟨f, hf⟩ => fun ⟨i, hi⟩ ↦ ⟨f i, (f.mem_support_toFun i).1 <| hf.symm ▸ hi⟩\n  invFun f := ⟨mk s fun i ↦ (f i).1, Finset.ext fun i ↦ by\n    -- TODO: `simp` fails to use `(f _).2` inside `∃ _, _`\n    calc\n      i ∈ support (mk s fun i ↦ (f i).1) ↔ ∃ h : i ∈ s, (f ⟨i, h⟩).1 ≠ 0 := by simp\n      _ ↔ ∃ _ : i ∈ s, True := exists_congr fun h ↦ (iff_true _).mpr (f _).2\n      _ ↔ i ∈ s := by simp⟩\n  left_inv := by\n    rintro ⟨f, rfl⟩\n    ext i\n    simpa using Eq.symm\n  right_inv f := by\n    ext1\n    simp [Subtype.eta]; rfl\n\n"}
{"name":"DFinsupp.subtypeSupportEqEquiv_apply_coe","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ns : Finset ι\nx✝ : Subtype fun f => Eq f.support s\ni : Subtype fun x => Membership.mem s x\n⊢ Eq (↑((DFinsupp.subtypeSupportEqEquiv s) x✝ i)) (↑x✝ ↑i)","decl":"/-- Equivalence between dependent functions with finite support `s : Finset ι` and functions\n`∀ i, {x : β i // x ≠ 0}`. -/\n@[simps]\ndef subtypeSupportEqEquiv (s : Finset ι) :\n    {f : Π₀ i, β i // f.support = s} ≃ ∀ i : s, {x : β i // x ≠ 0} where\n  toFun | ⟨f, hf⟩ => fun ⟨i, hi⟩ ↦ ⟨f i, (f.mem_support_toFun i).1 <| hf.symm ▸ hi⟩\n  invFun f := ⟨mk s fun i ↦ (f i).1, Finset.ext fun i ↦ by\n    -- TODO: `simp` fails to use `(f _).2` inside `∃ _, _`\n    calc\n      i ∈ support (mk s fun i ↦ (f i).1) ↔ ∃ h : i ∈ s, (f ⟨i, h⟩).1 ≠ 0 := by simp\n      _ ↔ ∃ _ : i ∈ s, True := exists_congr fun h ↦ (iff_true _).mpr (f _).2\n      _ ↔ i ∈ s := by simp⟩\n  left_inv := by\n    rintro ⟨f, rfl⟩\n    ext i\n    simpa using Eq.symm\n  right_inv f := by\n    ext1\n    simp [Subtype.eta]; rfl\n\n"}
{"name":"DFinsupp.sigmaFinsetFunEquiv_apply_fst","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\na✝ : DFinsupp fun i => β i\n⊢ Eq (DFinsupp.sigmaFinsetFunEquiv a✝).fst a✝.support","decl":"/-- Equivalence between all dependent finitely supported functions `f : Π₀ i, β i` and type\nof pairs `⟨s : Finset ι, f : ∀ i : s, {x : β i // x ≠ 0}⟩`. -/\n@[simps! apply_fst apply_snd_coe]\ndef sigmaFinsetFunEquiv : (Π₀ i, β i) ≃ Σ s : Finset ι, ∀ i : s, {x : β i // x ≠ 0} :=\n  (Equiv.sigmaFiberEquiv DFinsupp.support).symm.trans (.sigmaCongrRight subtypeSupportEqEquiv)\n\n"}
{"name":"DFinsupp.sigmaFinsetFunEquiv_apply_snd_coe","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\na✝ : DFinsupp fun i => β i\ni : Subtype fun x => Membership.mem ((Equiv.sigmaFiberEquiv DFinsupp.support).symm a✝).fst x\n⊢ Eq (↑((DFinsupp.sigmaFinsetFunEquiv a✝).snd i)) (a✝ ↑i)","decl":"/-- Equivalence between all dependent finitely supported functions `f : Π₀ i, β i` and type\nof pairs `⟨s : Finset ι, f : ∀ i : s, {x : β i // x ≠ 0}⟩`. -/\n@[simps! apply_fst apply_snd_coe]\ndef sigmaFinsetFunEquiv : (Π₀ i, β i) ≃ Σ s : Finset ι, ∀ i : s, {x : β i // x ≠ 0} :=\n  (Equiv.sigmaFiberEquiv DFinsupp.support).symm.trans (.sigmaCongrRight subtypeSupportEqEquiv)\n\n"}
{"name":"DFinsupp.support_zero","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\n⊢ Eq (DFinsupp.support 0) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem support_zero : (0 : Π₀ i, β i).support = ∅ :=\n  rfl\n\n"}
{"name":"DFinsupp.mem_support_iff","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\nf : DFinsupp fun i => β i\ni : ι\n⊢ Iff (Membership.mem f.support i) (Ne (f i) 0)","decl":"theorem mem_support_iff {f : Π₀ i, β i} {i : ι} : i ∈ f.support ↔ f i ≠ 0 :=\n  f.mem_support_toFun _\n\n"}
{"name":"DFinsupp.not_mem_support_iff","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\nf : DFinsupp fun i => β i\ni : ι\n⊢ Iff (Not (Membership.mem f.support i)) (Eq (f i) 0)","decl":"theorem not_mem_support_iff {f : Π₀ i, β i} {i : ι} : i ∉ f.support ↔ f i = 0 :=\n  not_iff_comm.1 mem_support_iff.symm\n\n"}
{"name":"DFinsupp.support_eq_empty","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\nf : DFinsupp fun i => β i\n⊢ Iff (Eq f.support EmptyCollection.emptyCollection) (Eq f 0)","decl":"@[simp]\ntheorem support_eq_empty {f : Π₀ i, β i} : f.support = ∅ ↔ f = 0 :=\n  ⟨fun H => ext <| by simpa [Finset.ext_iff] using H, by simp +contextual⟩\n\n"}
{"name":"DFinsupp.support_subset_iff","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ns : Set ι\nf : DFinsupp fun i => β i\n⊢ Iff (HasSubset.Subset (↑f.support) s) (∀ (i : ι), Not (Membership.mem s i) → Eq (f i) 0)","decl":"theorem support_subset_iff {s : Set ι} {f : Π₀ i, β i} : ↑f.support ⊆ s ↔ ∀ i ∉ s, f i = 0 := by\n  simpa [Set.subset_def] using forall_congr' fun i => not_imp_comm\n\n"}
{"name":"DFinsupp.support_single_ne_zero","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ni : ι\nb : β i\nhb : Ne b 0\n⊢ Eq (DFinsupp.single i b).support (Singleton.singleton i)","decl":"theorem support_single_ne_zero {i : ι} {b : β i} (hb : b ≠ 0) : (single i b).support = {i} := by\n  ext j; by_cases h : i = j\n  · subst h\n    simp [hb]\n  simp [Ne.symm h, h]\n\n"}
{"name":"DFinsupp.support_single_subset","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ni : ι\nb : β i\n⊢ HasSubset.Subset (DFinsupp.single i b).support (Singleton.singleton i)","decl":"theorem support_single_subset {i : ι} {b : β i} : (single i b).support ⊆ {i} :=\n  support_mk'_subset\n\n"}
{"name":"DFinsupp.mapRange_def","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ₁ : ι → Type v₁\nβ₂ : ι → Type v₂\ninst✝³ : DecidableEq ι\ninst✝² : (i : ι) → Zero (β₁ i)\ninst✝¹ : (i : ι) → Zero (β₂ i)\ninst✝ : (i : ι) → (x : β₁ i) → Decidable (Ne x 0)\nf : (i : ι) → β₁ i → β₂ i\nhf : ∀ (i : ι), Eq (f i 0) 0\ng : DFinsupp fun i => β₁ i\n⊢ Eq (DFinsupp.mapRange f hf g) (DFinsupp.mk g.support fun i => f (↑i) (g ↑i))","decl":"theorem mapRange_def [∀ (i) (x : β₁ i), Decidable (x ≠ 0)] {f : ∀ i, β₁ i → β₂ i}\n    {hf : ∀ i, f i 0 = 0} {g : Π₀ i, β₁ i} :\n    mapRange f hf g = mk g.support fun i => f i.1 (g i.1) := by\n  ext i\n  by_cases h : g i ≠ 0 <;> simp at h <;> simp [h, hf]\n\n"}
{"name":"DFinsupp.mapRange_single","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ₁ : ι → Type v₁\nβ₂ : ι → Type v₂\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (β₁ i)\ninst✝ : (i : ι) → Zero (β₂ i)\nf : (i : ι) → β₁ i → β₂ i\nhf : ∀ (i : ι), Eq (f i 0) 0\ni : ι\nb : β₁ i\n⊢ Eq (DFinsupp.mapRange f hf (DFinsupp.single i b)) (DFinsupp.single i (f i b))","decl":"@[simp]\ntheorem mapRange_single {f : ∀ i, β₁ i → β₂ i} {hf : ∀ i, f i 0 = 0} {i : ι} {b : β₁ i} :\n    mapRange f hf (single i b) = single i (f i b) :=\n  DFinsupp.ext fun i' => by\n    by_cases h : i = i'\n    · subst i'\n      simp\n    · simp [h, hf]\n\n"}
{"name":"DFinsupp.mapRange_injective","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ₁ : ι → Type v₁\nβ₂ : ι → Type v₂\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (β₁ i)\ninst✝ : (i : ι) → Zero (β₂ i)\nf : (i : ι) → β₁ i → β₂ i\nhf : ∀ (i : ι), Eq (f i 0) 0\n⊢ Iff (Function.Injective (DFinsupp.mapRange f hf)) (∀ (i : ι), Function.Injective (f i))","decl":"theorem mapRange_injective (f : ∀ i, β₁ i → β₂ i) (hf : ∀ i, f i 0 = 0) :\n    Function.Injective (mapRange f hf) ↔ ∀ i, Function.Injective (f i) :=\n  ⟨fun h i x y eq ↦ single_injective (@h (single i x) (single i y) <| by\n    simpa using congr_arg _ eq), fun h _ _ eq ↦ DFinsupp.ext fun i ↦ h i congr($eq i)⟩\n\n"}
{"name":"DFinsupp.support_mapRange","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ₁ : ι → Type v₁\nβ₂ : ι → Type v₂\ninst✝⁴ : DecidableEq ι\ninst✝³ : (i : ι) → Zero (β₁ i)\ninst✝² : (i : ι) → Zero (β₂ i)\ninst✝¹ : (i : ι) → (x : β₁ i) → Decidable (Ne x 0)\ninst✝ : (i : ι) → (x : β₂ i) → Decidable (Ne x 0)\nf : (i : ι) → β₁ i → β₂ i\nhf : ∀ (i : ι), Eq (f i 0) 0\ng : DFinsupp fun i => β₁ i\n⊢ HasSubset.Subset (DFinsupp.mapRange f hf g).support g.support","decl":"theorem support_mapRange {f : ∀ i, β₁ i → β₂ i} {hf : ∀ i, f i 0 = 0} {g : Π₀ i, β₁ i} :\n    (mapRange f hf g).support ⊆ g.support := by simp [mapRange_def]\n\n"}
{"name":"DFinsupp.zipWith_def","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\nβ₁ : ι → Type v₁\nβ₂ : ι → Type v₂\ndec : DecidableEq ι\ninst✝⁴ : (i : ι) → Zero (β i)\ninst✝³ : (i : ι) → Zero (β₁ i)\ninst✝² : (i : ι) → Zero (β₂ i)\ninst✝¹ : (i : ι) → (x : β₁ i) → Decidable (Ne x 0)\ninst✝ : (i : ι) → (x : β₂ i) → Decidable (Ne x 0)\nf : (i : ι) → β₁ i → β₂ i → β i\nhf : ∀ (i : ι), Eq (f i 0 0) 0\ng₁ : DFinsupp fun i => β₁ i\ng₂ : DFinsupp fun i => β₂ i\n⊢ Eq (DFinsupp.zipWith f hf g₁ g₂) (DFinsupp.mk (Union.union g₁.support g₂.support) fun i => f (↑i) (g₁ ↑i) (g₂ ↑i))","decl":"theorem zipWith_def {ι : Type u} {β : ι → Type v} {β₁ : ι → Type v₁} {β₂ : ι → Type v₂}\n    [dec : DecidableEq ι] [∀ i : ι, Zero (β i)] [∀ i : ι, Zero (β₁ i)] [∀ i : ι, Zero (β₂ i)]\n    [∀ (i : ι) (x : β₁ i), Decidable (x ≠ 0)] [∀ (i : ι) (x : β₂ i), Decidable (x ≠ 0)]\n    {f : ∀ i, β₁ i → β₂ i → β i} {hf : ∀ i, f i 0 0 = 0} {g₁ : Π₀ i, β₁ i} {g₂ : Π₀ i, β₂ i} :\n    zipWith f hf g₁ g₂ = mk (g₁.support ∪ g₂.support) fun i => f i.1 (g₁ i.1) (g₂ i.1) := by\n  ext i\n  by_cases h1 : g₁ i ≠ 0 <;> by_cases h2 : g₂ i ≠ 0 <;> simp only [not_not, Ne] at h1 h2 <;>\n    simp [h1, h2, hf]\n\n"}
{"name":"DFinsupp.support_zipWith","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\nβ₁ : ι → Type v₁\nβ₂ : ι → Type v₂\ninst✝⁶ : DecidableEq ι\ninst✝⁵ : (i : ι) → Zero (β i)\ninst✝⁴ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝³ : (i : ι) → Zero (β₁ i)\ninst✝² : (i : ι) → Zero (β₂ i)\ninst✝¹ : (i : ι) → (x : β₁ i) → Decidable (Ne x 0)\ninst✝ : (i : ι) → (x : β₂ i) → Decidable (Ne x 0)\nf : (i : ι) → β₁ i → β₂ i → β i\nhf : ∀ (i : ι), Eq (f i 0 0) 0\ng₁ : DFinsupp fun i => β₁ i\ng₂ : DFinsupp fun i => β₂ i\n⊢ HasSubset.Subset (DFinsupp.zipWith f hf g₁ g₂).support (Union.union g₁.support g₂.support)","decl":"theorem support_zipWith {f : ∀ i, β₁ i → β₂ i → β i} {hf : ∀ i, f i 0 0 = 0} {g₁ : Π₀ i, β₁ i}\n    {g₂ : Π₀ i, β₂ i} : (zipWith f hf g₁ g₂).support ⊆ g₁.support ∪ g₂.support := by\n  simp [zipWith_def]\n\n"}
{"name":"DFinsupp.erase_def","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ni : ι\nf : DFinsupp fun i => β i\n⊢ Eq (DFinsupp.erase i f) (DFinsupp.mk (f.support.erase i) fun j => f ↑j)","decl":"theorem erase_def (i : ι) (f : Π₀ i, β i) : f.erase i = mk (f.support.erase i) fun j => f j.1 := by\n  ext j\n  by_cases h1 : j = i <;> by_cases h2 : f j ≠ 0 <;> simp at h2 <;> simp [h1, h2]\n\n"}
{"name":"DFinsupp.support_erase","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ni : ι\nf : DFinsupp fun i => β i\n⊢ Eq (DFinsupp.erase i f).support (f.support.erase i)","decl":"@[simp]\ntheorem support_erase (i : ι) (f : Π₀ i, β i) : (f.erase i).support = f.support.erase i := by\n  ext j\n  by_cases h1 : j = i\n  · simp only [h1, mem_support_toFun, erase_apply, ite_true, ne_eq, not_true, not_not,\n      Finset.mem_erase, false_and]\n  by_cases h2 : f j ≠ 0 <;> simp at h2 <;> simp [h1, h2]\n\n"}
{"name":"DFinsupp.support_update_ne_zero","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\nf : DFinsupp fun i => β i\ni : ι\nb : β i\nh : Ne b 0\n⊢ Eq (f.update i b).support (Insert.insert i f.support)","decl":"theorem support_update_ne_zero (f : Π₀ i, β i) (i : ι) {b : β i} (h : b ≠ 0) :\n    support (f.update i b) = insert i f.support := by\n  ext j\n  rcases eq_or_ne i j with (rfl | hi)\n  · simp [h]\n  · simp [hi.symm]\n\n"}
{"name":"DFinsupp.support_update","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : (i : ι) → Zero (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\nf : DFinsupp fun i => β i\ni : ι\nb : β i\ninst✝ : Decidable (Eq b 0)\n⊢ Eq (f.update i b).support (ite (Eq b 0) (DFinsupp.erase i f).support (Insert.insert i f.support))","decl":"theorem support_update (f : Π₀ i, β i) (i : ι) (b : β i) [Decidable (b = 0)] :\n    support (f.update i b) = if b = 0 then support (f.erase i) else insert i f.support := by\n  ext j\n  split_ifs with hb\n  · subst hb\n    simp [update_eq_erase, support_erase]\n  · rw [support_update_ne_zero f _ hb]\n\n"}
{"name":"DFinsupp.filter_def","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : (i : ι) → Zero (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\np : ι → Prop\ninst✝ : DecidablePred p\nf : DFinsupp fun i => β i\n⊢ Eq (DFinsupp.filter p f) (DFinsupp.mk (Finset.filter p f.support) fun i => f ↑i)","decl":"theorem filter_def (f : Π₀ i, β i) : f.filter p = mk (f.support.filter p) fun i => f i.1 := by\n  ext i; by_cases h1 : p i <;> by_cases h2 : f i ≠ 0 <;> simp at h2 <;> simp [h1, h2]\n\n"}
{"name":"DFinsupp.support_filter","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : (i : ι) → Zero (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\np : ι → Prop\ninst✝ : DecidablePred p\nf : DFinsupp fun i => β i\n⊢ Eq (DFinsupp.filter p f).support (Finset.filter (fun x => p x) f.support)","decl":"@[simp]\ntheorem support_filter (f : Π₀ i, β i) : (f.filter p).support = {x ∈ f.support | p x} := by\n  ext i; by_cases h : p i <;> simp [h]\n\n"}
{"name":"DFinsupp.subtypeDomain_def","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : (i : ι) → Zero (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\np : ι → Prop\ninst✝ : DecidablePred p\nf : DFinsupp fun i => β i\n⊢ Eq (DFinsupp.subtypeDomain p f) (DFinsupp.mk (Finset.subtype p f.support) fun i => f ↑↑i)","decl":"theorem subtypeDomain_def (f : Π₀ i, β i) :\n    f.subtypeDomain p = mk (f.support.subtype p) fun i => f i := by\n  ext i; by_cases h2 : f i ≠ 0 <;> try simp at h2; dsimp; simp [h2]\n\n"}
{"name":"DFinsupp.support_subtypeDomain","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : (i : ι) → Zero (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\np : ι → Prop\ninst✝ : DecidablePred p\nf : DFinsupp fun i => β i\n⊢ Eq (DFinsupp.subtypeDomain p f).support (Finset.subtype p f.support)","decl":"@[simp]\ntheorem support_subtypeDomain {f : Π₀ i, β i} :\n    (subtypeDomain p f).support = f.support.subtype p := by\n  ext i\n  simp\n\n"}
{"name":"DFinsupp.support_add","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → AddZeroClass (β i)\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ng₁ g₂ : DFinsupp fun i => β i\n⊢ HasSubset.Subset (HAdd.hAdd g₁ g₂).support (Union.union g₁.support g₂.support)","decl":"theorem support_add [∀ i, AddZeroClass (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]\n    {g₁ g₂ : Π₀ i, β i} : (g₁ + g₂).support ⊆ g₁.support ∪ g₂.support :=\n  support_zipWith\n\n"}
{"name":"DFinsupp.support_neg","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → AddGroup (β i)\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\nf : DFinsupp fun i => β i\n⊢ Eq (Neg.neg f).support f.support","decl":"@[simp]\ntheorem support_neg [∀ i, AddGroup (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] {f : Π₀ i, β i} :\n    support (-f) = support f := by ext i; simp\n\n"}
{"name":"DFinsupp.comapDomain_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\nκ : Type u_1\ninst✝ : (i : ι) → Zero (β i)\nh : κ → ι\nhh : Function.Injective h\nf : DFinsupp fun i => β i\nk : κ\n⊢ Eq ((DFinsupp.comapDomain h hh f) k) (f (h k))","decl":"@[simp]\ntheorem comapDomain_apply [∀ i, Zero (β i)] (h : κ → ι) (hh : Function.Injective h) (f : Π₀ i, β i)\n    (k : κ) : comapDomain h hh f k = f (h k) :=\n  rfl\n\n"}
{"name":"DFinsupp.comapDomain_zero","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\nκ : Type u_1\ninst✝ : (i : ι) → Zero (β i)\nh : κ → ι\nhh : Function.Injective h\n⊢ Eq (DFinsupp.comapDomain h hh 0) 0","decl":"@[simp]\ntheorem comapDomain_zero [∀ i, Zero (β i)] (h : κ → ι) (hh : Function.Injective h) :\n    comapDomain h hh (0 : Π₀ i, β i) = 0 := by\n  ext\n  rw [zero_apply, comapDomain_apply, zero_apply]\n\n"}
{"name":"DFinsupp.comapDomain_add","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\nκ : Type u_1\ninst✝ : (i : ι) → AddZeroClass (β i)\nh : κ → ι\nhh : Function.Injective h\nf g : DFinsupp fun i => β i\n⊢ Eq (DFinsupp.comapDomain h hh (HAdd.hAdd f g)) (HAdd.hAdd (DFinsupp.comapDomain h hh f) (DFinsupp.comapDomain h hh g))","decl":"@[simp]\ntheorem comapDomain_add [∀ i, AddZeroClass (β i)] (h : κ → ι) (hh : Function.Injective h)\n    (f g : Π₀ i, β i) : comapDomain h hh (f + g) = comapDomain h hh f + comapDomain h hh g := by\n  ext\n  rw [add_apply, comapDomain_apply, comapDomain_apply, comapDomain_apply, add_apply]\n\n"}
{"name":"DFinsupp.comapDomain_single","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\nκ : Type u_1\ninst✝² : DecidableEq ι\ninst✝¹ : DecidableEq κ\ninst✝ : (i : ι) → Zero (β i)\nh : κ → ι\nhh : Function.Injective h\nk : κ\nx : β (h k)\n⊢ Eq (DFinsupp.comapDomain h hh (DFinsupp.single (h k) x)) (DFinsupp.single k x)","decl":"@[simp]\ntheorem comapDomain_single [DecidableEq ι] [DecidableEq κ] [∀ i, Zero (β i)] (h : κ → ι)\n    (hh : Function.Injective h) (k : κ) (x : β (h k)) :\n    comapDomain h hh (single (h k) x) = single k x := by\n  ext i\n  rw [comapDomain_apply]\n  obtain rfl | hik := Decidable.eq_or_ne i k\n  · rw [single_eq_same, single_eq_same]\n  · rw [single_eq_of_ne hik.symm, single_eq_of_ne (hh.ne hik.symm)]\n\n"}
{"name":"DFinsupp.comapDomain'_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\nκ : Type u_1\ninst✝ : (i : ι) → Zero (β i)\nh : κ → ι\nh' : ι → κ\nhh' : Function.LeftInverse h' h\nf : DFinsupp fun i => β i\nk : κ\n⊢ Eq ((DFinsupp.comapDomain' h hh' f) k) (f (h k))","decl":"@[simp]\ntheorem comapDomain'_apply [∀ i, Zero (β i)] (h : κ → ι) {h' : ι → κ}\n    (hh' : Function.LeftInverse h' h) (f : Π₀ i, β i) (k : κ) : comapDomain' h hh' f k = f (h k) :=\n  rfl\n\n"}
{"name":"DFinsupp.comapDomain'_zero","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\nκ : Type u_1\ninst✝ : (i : ι) → Zero (β i)\nh : κ → ι\nh' : ι → κ\nhh' : Function.LeftInverse h' h\n⊢ Eq (DFinsupp.comapDomain' h hh' 0) 0","decl":"@[simp]\ntheorem comapDomain'_zero [∀ i, Zero (β i)] (h : κ → ι) {h' : ι → κ}\n    (hh' : Function.LeftInverse h' h) : comapDomain' h hh' (0 : Π₀ i, β i) = 0 := by\n  ext\n  rw [zero_apply, comapDomain'_apply, zero_apply]\n\n"}
{"name":"DFinsupp.comapDomain'_add","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\nκ : Type u_1\ninst✝ : (i : ι) → AddZeroClass (β i)\nh : κ → ι\nh' : ι → κ\nhh' : Function.LeftInverse h' h\nf g : DFinsupp fun i => β i\n⊢ Eq (DFinsupp.comapDomain' h hh' (HAdd.hAdd f g)) (HAdd.hAdd (DFinsupp.comapDomain' h hh' f) (DFinsupp.comapDomain' h hh' g))","decl":"@[simp]\ntheorem comapDomain'_add [∀ i, AddZeroClass (β i)] (h : κ → ι) {h' : ι → κ}\n    (hh' : Function.LeftInverse h' h) (f g : Π₀ i, β i) :\n    comapDomain' h hh' (f + g) = comapDomain' h hh' f + comapDomain' h hh' g := by\n  ext\n  rw [add_apply, comapDomain'_apply, comapDomain'_apply, comapDomain'_apply, add_apply]\n\n"}
{"name":"DFinsupp.comapDomain'_single","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\nκ : Type u_1\ninst✝² : DecidableEq ι\ninst✝¹ : DecidableEq κ\ninst✝ : (i : ι) → Zero (β i)\nh : κ → ι\nh' : ι → κ\nhh' : Function.LeftInverse h' h\nk : κ\nx : β (h k)\n⊢ Eq (DFinsupp.comapDomain' h hh' (DFinsupp.single (h k) x)) (DFinsupp.single k x)","decl":"@[simp]\ntheorem comapDomain'_single [DecidableEq ι] [DecidableEq κ] [∀ i, Zero (β i)] (h : κ → ι)\n    {h' : ι → κ} (hh' : Function.LeftInverse h' h) (k : κ) (x : β (h k)) :\n    comapDomain' h hh' (single (h k) x) = single k x := by\n  ext i\n  rw [comapDomain'_apply]\n  obtain rfl | hik := Decidable.eq_or_ne i k\n  · rw [single_eq_same, single_eq_same]\n  · rw [single_eq_of_ne hik.symm, single_eq_of_ne (hh'.injective.ne hik.symm)]\n\n"}
{"name":"DFinsupp.equivCongrLeft_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\nκ : Type u_1\ninst✝ : (i : ι) → Zero (β i)\nh : Equiv ι κ\nf : DFinsupp fun i => β i\n⊢ Eq ((DFinsupp.equivCongrLeft h) f) (DFinsupp.comapDomain' ⇑h.symm ⋯ f)","decl":"/-- Reindexing terms of a dfinsupp.\n\nThis is the dfinsupp version of `Equiv.piCongrLeft'`. -/\n@[simps apply]\ndef equivCongrLeft [∀ i, Zero (β i)] (h : ι ≃ κ) : (Π₀ i, β i) ≃ Π₀ k, β (h.symm k) where\n  toFun := comapDomain' h.symm h.right_inv\n  invFun f :=\n    mapRange (fun i => Equiv.cast <| congr_arg β <| h.symm_apply_apply i)\n      (fun i => (Equiv.cast_eq_iff_heq _).mpr <| by rw [Equiv.symm_apply_apply])\n      (@comapDomain' _ _ _ _ h _ h.left_inv f)\n  left_inv f := by\n    ext i\n    rw [mapRange_apply, comapDomain'_apply, comapDomain'_apply, Equiv.cast_eq_iff_heq,\n      h.symm_apply_apply]\n  right_inv f := by\n    ext k\n    rw [comapDomain'_apply, mapRange_apply, comapDomain'_apply, Equiv.cast_eq_iff_heq,\n      h.apply_symm_apply]\n\n"}
{"name":"DFinsupp.extendWith_none","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nα : Option ι → Type v\ninst✝ : (i : Option ι) → Zero (α i)\nf : DFinsupp fun i => α (Option.some i)\na : α Option.none\n⊢ Eq ((DFinsupp.extendWith a f) Option.none) a","decl":"@[simp]\ntheorem extendWith_none [∀ i, Zero (α i)] (f : Π₀ i, α (some i)) (a : α none) :\n    f.extendWith a none = a :=\n  rfl\n\n"}
{"name":"DFinsupp.extendWith_some","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nα : Option ι → Type v\ninst✝ : (i : Option ι) → Zero (α i)\nf : DFinsupp fun i => α (Option.some i)\na : α Option.none\ni : ι\n⊢ Eq ((DFinsupp.extendWith a f) (Option.some i)) (f i)","decl":"@[simp]\ntheorem extendWith_some [∀ i, Zero (α i)] (f : Π₀ i, α (some i)) (a : α none) (i : ι) :\n    f.extendWith a (some i) = f i :=\n  rfl\n\n"}
{"name":"DFinsupp.extendWith_single_zero","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nα : Option ι → Type v\ninst✝¹ : DecidableEq ι\ninst✝ : (i : Option ι) → Zero (α i)\ni : ι\nx : α (Option.some i)\n⊢ Eq (DFinsupp.extendWith 0 (DFinsupp.single i x)) (DFinsupp.single (Option.some i) x)","decl":"@[simp]\ntheorem extendWith_single_zero [DecidableEq ι] [∀ i, Zero (α i)] (i : ι) (x : α (some i)) :\n    (single i x).extendWith 0 = single (some i) x := by\n  ext (_ | j)\n  · rw [extendWith_none, single_eq_of_ne (Option.some_ne_none _)]\n  · rw [extendWith_some]\n    obtain rfl | hij := Decidable.eq_or_ne i j\n    · rw [single_eq_same, single_eq_same]\n    · rw [single_eq_of_ne hij, single_eq_of_ne ((Option.some_injective _).ne hij)]\n\n"}
{"name":"DFinsupp.extendWith_zero","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nα : Option ι → Type v\ninst✝¹ : DecidableEq ι\ninst✝ : (i : Option ι) → Zero (α i)\nx : α Option.none\n⊢ Eq (DFinsupp.extendWith x 0) (DFinsupp.single Option.none x)","decl":"@[simp]\ntheorem extendWith_zero [DecidableEq ι] [∀ i, Zero (α i)] (x : α none) :\n    (0 : Π₀ i, α (some i)).extendWith x = single none x := by\n  ext (_ | j)\n  · rw [extendWith_none, single_eq_same]\n  · rw [extendWith_some, single_eq_of_ne (Option.some_ne_none _).symm, zero_apply]\n\n"}
{"name":"DFinsupp.equivProdDFinsupp_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nα : Option ι → Type v\ninst✝ : (i : Option ι) → Zero (α i)\nf : DFinsupp fun i => α i\n⊢ Eq (DFinsupp.equivProdDFinsupp f) { fst := f Option.none, snd := DFinsupp.comapDomain Option.some ⋯ f }","decl":"/-- Bijection obtained by separating the term of index `none` of a dfinsupp over `Option ι`.\n\nThis is the dfinsupp version of `Equiv.piOptionEquivProd`. -/\n@[simps]\nnoncomputable def equivProdDFinsupp [∀ i, Zero (α i)] :\n    (Π₀ i, α i) ≃ α none × Π₀ i, α (some i) where\n  toFun f := (f none, comapDomain some (Option.some_injective _) f)\n  invFun f := f.2.extendWith f.1\n  left_inv f := by\n    ext i; cases' i with i\n    · rw [extendWith_none]\n    · rw [extendWith_some, comapDomain_apply]\n  right_inv x := by\n    dsimp only\n    ext\n    · exact extendWith_none x.snd _\n    · rw [comapDomain_apply, extendWith_some]\n\n"}
{"name":"DFinsupp.equivProdDFinsupp_symm_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nα : Option ι → Type v\ninst✝ : (i : Option ι) → Zero (α i)\nf : Prod (α Option.none) (DFinsupp fun i => α (Option.some i))\n⊢ Eq (DFinsupp.equivProdDFinsupp.symm f) (DFinsupp.extendWith f.1 f.2)","decl":"/-- Bijection obtained by separating the term of index `none` of a dfinsupp over `Option ι`.\n\nThis is the dfinsupp version of `Equiv.piOptionEquivProd`. -/\n@[simps]\nnoncomputable def equivProdDFinsupp [∀ i, Zero (α i)] :\n    (Π₀ i, α i) ≃ α none × Π₀ i, α (some i) where\n  toFun f := (f none, comapDomain some (Option.some_injective _) f)\n  invFun f := f.2.extendWith f.1\n  left_inv f := by\n    ext i; cases' i with i\n    · rw [extendWith_none]\n    · rw [extendWith_some, comapDomain_apply]\n  right_inv x := by\n    dsimp only\n    ext\n    · exact extendWith_none x.snd _\n    · rw [comapDomain_apply, extendWith_some]\n\n"}
{"name":"DFinsupp.equivProdDFinsupp_add","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nα : Option ι → Type v\ninst✝ : (i : Option ι) → AddZeroClass (α i)\nf g : DFinsupp fun i => α i\n⊢ Eq (DFinsupp.equivProdDFinsupp (HAdd.hAdd f g)) (HAdd.hAdd (DFinsupp.equivProdDFinsupp f) (DFinsupp.equivProdDFinsupp g))","decl":"theorem equivProdDFinsupp_add [∀ i, AddZeroClass (α i)] (f g : Π₀ i, α i) :\n    equivProdDFinsupp (f + g) = equivProdDFinsupp f + equivProdDFinsupp g :=\n  Prod.ext (add_apply _ _ _) (comapDomain_add _ (Option.some_injective _) _ _)\n\n"}
{"name":"DFinsupp.mapRange_add","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ₁ : ι → Type v₁\nβ₂ : ι → Type v₂\ninst✝¹ : (i : ι) → AddZeroClass (β₁ i)\ninst✝ : (i : ι) → AddZeroClass (β₂ i)\nf : (i : ι) → β₁ i → β₂ i\nhf : ∀ (i : ι), Eq (f i 0) 0\nhf' : ∀ (i : ι) (x y : β₁ i), Eq (f i (HAdd.hAdd x y)) (HAdd.hAdd (f i x) (f i y))\ng₁ g₂ : DFinsupp fun i => β₁ i\n⊢ Eq (DFinsupp.mapRange f hf (HAdd.hAdd g₁ g₂)) (HAdd.hAdd (DFinsupp.mapRange f hf g₁) (DFinsupp.mapRange f hf g₂))","decl":"theorem mapRange_add (f : ∀ i, β₁ i → β₂ i) (hf : ∀ i, f i 0 = 0)\n    (hf' : ∀ i x y, f i (x + y) = f i x + f i y) (g₁ g₂ : Π₀ i, β₁ i) :\n    mapRange f hf (g₁ + g₂) = mapRange f hf g₁ + mapRange f hf g₂ := by\n  ext\n  simp only [mapRange_apply f, coe_add, Pi.add_apply, hf']\n\n"}
{"name":"DFinsupp.mapRange.addMonoidHom_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ₁ : ι → Type v₁\nβ₂ : ι → Type v₂\ninst✝¹ : (i : ι) → AddZeroClass (β₁ i)\ninst✝ : (i : ι) → AddZeroClass (β₂ i)\nf : (i : ι) → AddMonoidHom (β₁ i) (β₂ i)\nx : DFinsupp fun i => β₁ i\n⊢ Eq ((DFinsupp.mapRange.addMonoidHom f) x) (DFinsupp.mapRange (fun i x => (f i) x) ⋯ x)","decl":"/-- `DFinsupp.mapRange` as an `AddMonoidHom`. -/\n@[simps apply]\ndef mapRange.addMonoidHom (f : ∀ i, β₁ i →+ β₂ i) : (Π₀ i, β₁ i) →+ Π₀ i, β₂ i where\n  toFun := mapRange (fun i x => f i x) fun i => (f i).map_zero\n  map_zero' := mapRange_zero _ _\n  map_add' := mapRange_add _ (fun i => (f i).map_zero) fun i => (f i).map_add\n\n"}
{"name":"DFinsupp.mapRange.addMonoidHom_id","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ₂ : ι → Type v₂\ninst✝ : (i : ι) → AddZeroClass (β₂ i)\n⊢ Eq (DFinsupp.mapRange.addMonoidHom fun i => AddMonoidHom.id (β₂ i)) (AddMonoidHom.id (DFinsupp fun i => β₂ i))","decl":"@[simp]\ntheorem mapRange.addMonoidHom_id :\n    (mapRange.addMonoidHom fun i => AddMonoidHom.id (β₂ i)) = AddMonoidHom.id _ :=\n  AddMonoidHom.ext mapRange_id\n\n"}
{"name":"DFinsupp.mapRange.addMonoidHom_comp","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\nβ₁ : ι → Type v₁\nβ₂ : ι → Type v₂\ninst✝² : (i : ι) → AddZeroClass (β i)\ninst✝¹ : (i : ι) → AddZeroClass (β₁ i)\ninst✝ : (i : ι) → AddZeroClass (β₂ i)\nf : (i : ι) → AddMonoidHom (β₁ i) (β₂ i)\nf₂ : (i : ι) → AddMonoidHom (β i) (β₁ i)\n⊢ Eq (DFinsupp.mapRange.addMonoidHom fun i => (f i).comp (f₂ i)) ((DFinsupp.mapRange.addMonoidHom f).comp (DFinsupp.mapRange.addMonoidHom f₂))","decl":"theorem mapRange.addMonoidHom_comp (f : ∀ i, β₁ i →+ β₂ i) (f₂ : ∀ i, β i →+ β₁ i) :\n    (mapRange.addMonoidHom fun i => (f i).comp (f₂ i)) =\n      (mapRange.addMonoidHom f).comp (mapRange.addMonoidHom f₂) := by\n  refine AddMonoidHom.ext <| mapRange_comp (fun i x => f i x) (fun i x => f₂ i x) ?_ ?_ ?_\n  · intros; apply map_zero\n  · intros; apply map_zero\n  · intros; dsimp; simp only [map_zero]\n\n"}
{"name":"DFinsupp.mapRange.addEquiv_apply","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ₁ : ι → Type v₁\nβ₂ : ι → Type v₂\ninst✝¹ : (i : ι) → AddZeroClass (β₁ i)\ninst✝ : (i : ι) → AddZeroClass (β₂ i)\ne : (i : ι) → AddEquiv (β₁ i) (β₂ i)\nx : DFinsupp fun i => β₁ i\n⊢ Eq ((DFinsupp.mapRange.addEquiv e) x) (DFinsupp.mapRange (fun i x => (e i) x) ⋯ x)","decl":"/-- `DFinsupp.mapRange.addMonoidHom` as an `AddEquiv`. -/\n@[simps apply]\ndef mapRange.addEquiv (e : ∀ i, β₁ i ≃+ β₂ i) : (Π₀ i, β₁ i) ≃+ Π₀ i, β₂ i :=\n  { mapRange.addMonoidHom fun i =>\n      (e i).toAddMonoidHom with\n    toFun := mapRange (fun i x => e i x) fun i => (e i).map_zero\n    invFun := mapRange (fun i x => (e i).symm x) fun i => (e i).symm.map_zero\n    left_inv := fun x => by\n      rw [← mapRange_comp] <;>\n        · simp_rw [AddEquiv.symm_comp_self]\n          simp\n    right_inv := fun x => by\n      rw [← mapRange_comp] <;>\n        · simp_rw [AddEquiv.self_comp_symm]\n          simp }\n\n"}
{"name":"DFinsupp.mapRange.addEquiv_refl","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ₁ : ι → Type v₁\ninst✝ : (i : ι) → AddZeroClass (β₁ i)\n⊢ Eq (DFinsupp.mapRange.addEquiv fun i => AddEquiv.refl (β₁ i)) (AddEquiv.refl (DFinsupp fun i => β₁ i))","decl":"@[simp]\ntheorem mapRange.addEquiv_refl :\n    (mapRange.addEquiv fun i => AddEquiv.refl (β₁ i)) = AddEquiv.refl _ :=\n  AddEquiv.ext mapRange_id\n\n"}
{"name":"DFinsupp.mapRange.addEquiv_trans","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ : ι → Type v\nβ₁ : ι → Type v₁\nβ₂ : ι → Type v₂\ninst✝² : (i : ι) → AddZeroClass (β i)\ninst✝¹ : (i : ι) → AddZeroClass (β₁ i)\ninst✝ : (i : ι) → AddZeroClass (β₂ i)\nf : (i : ι) → AddEquiv (β i) (β₁ i)\nf₂ : (i : ι) → AddEquiv (β₁ i) (β₂ i)\n⊢ Eq (DFinsupp.mapRange.addEquiv fun i => (f i).trans (f₂ i)) ((DFinsupp.mapRange.addEquiv f).trans (DFinsupp.mapRange.addEquiv f₂))","decl":"theorem mapRange.addEquiv_trans (f : ∀ i, β i ≃+ β₁ i) (f₂ : ∀ i, β₁ i ≃+ β₂ i) :\n    (mapRange.addEquiv fun i => (f i).trans (f₂ i)) =\n      (mapRange.addEquiv f).trans (mapRange.addEquiv f₂) := by\n  refine AddEquiv.ext <| mapRange_comp (fun i x => f₂ i x) (fun i x => f i x) ?_ ?_ ?_\n  · intros; apply map_zero\n  · intros; apply map_zero\n  · intros; dsimp; simp only [map_zero]\n\n"}
{"name":"DFinsupp.mapRange.addEquiv_symm","module":"Mathlib.Data.DFinsupp.Defs","initialProofState":"ι : Type u\nβ₁ : ι → Type v₁\nβ₂ : ι → Type v₂\ninst✝¹ : (i : ι) → AddZeroClass (β₁ i)\ninst✝ : (i : ι) → AddZeroClass (β₂ i)\ne : (i : ι) → AddEquiv (β₁ i) (β₂ i)\n⊢ Eq (DFinsupp.mapRange.addEquiv e).symm (DFinsupp.mapRange.addEquiv fun i => (e i).symm)","decl":"@[simp]\ntheorem mapRange.addEquiv_symm (e : ∀ i, β₁ i ≃+ β₂ i) :\n    (mapRange.addEquiv e).symm = mapRange.addEquiv fun i => (e i).symm :=\n  rfl\n\n"}
