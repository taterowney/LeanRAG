{"name":"CompHaus.projective_ultrafilter","module":"Mathlib.Topology.Category.CompHaus.Projective","initialProofState":"X : Type u_1\n⊢ CategoryTheory.Projective (CompHaus.of (Ultrafilter X))","decl":"instance projective_ultrafilter (X : Type*) : Projective (of <| Ultrafilter X) where\n  factors {Y Z} f g hg := by\n    rw [epi_iff_surjective] at hg\n    obtain ⟨g', hg'⟩ := hg.hasRightInverse\n    let t : X → Y := g' ∘ f ∘ (pure : X → Ultrafilter X)\n    let h : Ultrafilter X → Y := Ultrafilter.extend t\n    have hh : Continuous h := continuous_ultrafilter_extend _\n    use ⟨h, hh⟩\n    apply (forget CompHaus).map_injective\n    simp only [Functor.map_comp, ContinuousMap.coe_mk, coe_comp]\n    convert denseRange_pure.equalizer (g.continuous.comp hh) f.continuous _\n    -- Porting note: We need to get the coercions to functions under control.\n    -- The next two lines should not be needed.\n    let g'' : ContinuousMap Y Z := g\n    have : g'' ∘ g' = id := hg'.comp_eq_id\n    -- This used to be `rw`, but we need `rw; rfl` after https://github.com/leanprover/lean4/pull/2644\n    rw [comp_assoc, ultrafilter_extend_extends, ← comp_assoc, this, id_comp]\n    rfl\n\n"}
{"name":"CompHaus.instEnoughProjectives","module":"Mathlib.Topology.Category.CompHaus.Projective","initialProofState":"⊢ CategoryTheory.EnoughProjectives CompHaus","decl":"instance : EnoughProjectives CompHaus where presentation X := ⟨projectivePresentation X⟩\n\n"}
