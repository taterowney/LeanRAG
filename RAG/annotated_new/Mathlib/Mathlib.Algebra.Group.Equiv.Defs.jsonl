{"name":"EmbeddingLike.map_eq_zero_iff","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"F : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝⁴ : Zero M\ninst✝³ : Zero N\ninst✝² : FunLike F M N\ninst✝¹ : EmbeddingLike F M N\ninst✝ : ZeroHomClass F M N\nf : F\nx : M\n⊢ Iff (Eq (f x) 0) (Eq x 0)","decl":"@[to_additive (attr := simp)]\ntheorem map_eq_one_iff {f : F} {x : M} :\n    f x = 1 ↔ x = 1 :=\n  _root_.map_eq_one_iff f (EmbeddingLike.injective f)\n\n"}
{"name":"EmbeddingLike.map_eq_one_iff","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"F : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝⁴ : One M\ninst✝³ : One N\ninst✝² : FunLike F M N\ninst✝¹ : EmbeddingLike F M N\ninst✝ : OneHomClass F M N\nf : F\nx : M\n⊢ Iff (Eq (f x) 1) (Eq x 1)","decl":"@[to_additive (attr := simp)]\ntheorem map_eq_one_iff {f : F} {x : M} :\n    f x = 1 ↔ x = 1 :=\n  _root_.map_eq_one_iff f (EmbeddingLike.injective f)\n\n"}
{"name":"EmbeddingLike.map_ne_zero_iff","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"F : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝⁴ : Zero M\ninst✝³ : Zero N\ninst✝² : FunLike F M N\ninst✝¹ : EmbeddingLike F M N\ninst✝ : ZeroHomClass F M N\nf : F\nx : M\n⊢ Iff (Ne (f x) 0) (Ne x 0)","decl":"@[to_additive]\ntheorem map_ne_one_iff {f : F} {x : M} :\n    f x ≠ 1 ↔ x ≠ 1 :=\n  map_eq_one_iff.not\n\n"}
{"name":"EmbeddingLike.map_ne_one_iff","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"F : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝⁴ : One M\ninst✝³ : One N\ninst✝² : FunLike F M N\ninst✝¹ : EmbeddingLike F M N\ninst✝ : OneHomClass F M N\nf : F\nx : M\n⊢ Iff (Ne (f x) 1) (Ne x 1)","decl":"@[to_additive]\ntheorem map_ne_one_iff {f : F} {x : M} :\n    f x ≠ 1 ↔ x ≠ 1 :=\n  map_eq_one_iff.not\n\n"}
{"name":"AddEquiv.mk.inj","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"A : Type u_9\nB : Type u_10\ninst✝¹ : Add A\ninst✝ : Add B\ntoEquiv✝ : Equiv A B\nmap_add'✝ : ∀ (x y : A), Eq (toEquiv✝.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toEquiv✝.toFun x) (toEquiv✝.toFun y))\ntoEquiv : Equiv A B\nmap_add' : ∀ (x y : A), Eq (toEquiv.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toEquiv.toFun x) (toEquiv.toFun y))\nx✝ : Eq { toEquiv := toEquiv✝, map_add' := map_add'✝ } { toEquiv := toEquiv, map_add' := map_add' }\n⊢ Eq toEquiv✝ toEquiv","decl":"/-- `AddEquiv α β` is the type of an equiv `α ≃ β` which preserves addition. -/\nstructure AddEquiv (A B : Type*) [Add A] [Add B] extends A ≃ B, AddHom A B\n\n"}
{"name":"AddEquiv.mk.sizeOf_spec","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"A : Type u_9\nB : Type u_10\ninst✝³ : Add A\ninst✝² : Add B\ninst✝¹ : SizeOf A\ninst✝ : SizeOf B\ntoEquiv : Equiv A B\nmap_add' : ∀ (x y : A), Eq (toEquiv.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toEquiv.toFun x) (toEquiv.toFun y))\n⊢ Eq (SizeOf.sizeOf { toEquiv := toEquiv, map_add' := map_add' }) (HAdd.hAdd 1 (SizeOf.sizeOf toEquiv))","decl":"/-- `AddEquiv α β` is the type of an equiv `α ≃ β` which preserves addition. -/\nstructure AddEquiv (A B : Type*) [Add A] [Add B] extends A ≃ B, AddHom A B\n\n"}
{"name":"AddEquiv.mk.injEq","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"A : Type u_9\nB : Type u_10\ninst✝¹ : Add A\ninst✝ : Add B\ntoEquiv✝ : Equiv A B\nmap_add'✝ : ∀ (x y : A), Eq (toEquiv✝.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toEquiv✝.toFun x) (toEquiv✝.toFun y))\ntoEquiv : Equiv A B\nmap_add' : ∀ (x y : A), Eq (toEquiv.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toEquiv.toFun x) (toEquiv.toFun y))\n⊢ Eq (Eq { toEquiv := toEquiv✝, map_add' := map_add'✝ } { toEquiv := toEquiv, map_add' := map_add' }) (Eq toEquiv✝ toEquiv)","decl":"/-- `AddEquiv α β` is the type of an equiv `α ≃ β` which preserves addition. -/\nstructure AddEquiv (A B : Type*) [Add A] [Add B] extends A ≃ B, AddHom A B\n\n"}
{"name":"AddEquiv.map_add'","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"A : Type u_9\nB : Type u_10\ninst✝¹ : Add A\ninst✝ : Add B\nself : AddEquiv A B\nx y : A\n⊢ Eq (self.toFun (HAdd.hAdd x y)) (HAdd.hAdd (self.toFun x) (self.toFun y))","decl":"/-- `AddEquiv α β` is the type of an equiv `α ≃ β` which preserves addition. -/\nstructure AddEquiv (A B : Type*) [Add A] [Add B] extends A ≃ B, AddHom A B\n\n"}
{"name":"AddEquivClass.map_add","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"F : Type u_9\nA : outParam (Type u_10)\nB : outParam (Type u_11)\ninst✝² : Add A\ninst✝¹ : Add B\ninst✝ : EquivLike F A B\nself : AddEquivClass F A B\nf : F\na b : A\n⊢ Eq (f (HAdd.hAdd a b)) (HAdd.hAdd (f a) (f b))","decl":"/-- `AddEquivClass F A B` states that `F` is a type of addition-preserving morphisms.\nYou should extend this class when you extend `AddEquiv`. -/\nclass AddEquivClass (F : Type*) (A B : outParam Type*) [Add A] [Add B] [EquivLike F A B] :\n    Prop where\n  /-- Preserves addition. -/\n  map_add : ∀ (f : F) (a b), f (a + b) = f a + f b\n\n"}
{"name":"MulEquiv.mk.inj","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_9\nN : Type u_10\ninst✝¹ : Mul M\ninst✝ : Mul N\ntoEquiv✝ : Equiv M N\nmap_mul'✝ : ∀ (x y : M), Eq (toEquiv✝.toFun (HMul.hMul x y)) (HMul.hMul (toEquiv✝.toFun x) (toEquiv✝.toFun y))\ntoEquiv : Equiv M N\nmap_mul' : ∀ (x y : M), Eq (toEquiv.toFun (HMul.hMul x y)) (HMul.hMul (toEquiv.toFun x) (toEquiv.toFun y))\nx✝ : Eq { toEquiv := toEquiv✝, map_mul' := map_mul'✝ } { toEquiv := toEquiv, map_mul' := map_mul' }\n⊢ Eq toEquiv✝ toEquiv","decl":"/-- `MulEquiv α β` is the type of an equiv `α ≃ β` which preserves multiplication. -/\n@[to_additive]\nstructure MulEquiv (M N : Type*) [Mul M] [Mul N] extends M ≃ N, M →ₙ* N\n\n"}
{"name":"MulEquiv.mk.injEq","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_9\nN : Type u_10\ninst✝¹ : Mul M\ninst✝ : Mul N\ntoEquiv✝ : Equiv M N\nmap_mul'✝ : ∀ (x y : M), Eq (toEquiv✝.toFun (HMul.hMul x y)) (HMul.hMul (toEquiv✝.toFun x) (toEquiv✝.toFun y))\ntoEquiv : Equiv M N\nmap_mul' : ∀ (x y : M), Eq (toEquiv.toFun (HMul.hMul x y)) (HMul.hMul (toEquiv.toFun x) (toEquiv.toFun y))\n⊢ Eq (Eq { toEquiv := toEquiv✝, map_mul' := map_mul'✝ } { toEquiv := toEquiv, map_mul' := map_mul' }) (Eq toEquiv✝ toEquiv)","decl":"/-- `MulEquiv α β` is the type of an equiv `α ≃ β` which preserves multiplication. -/\n@[to_additive]\nstructure MulEquiv (M N : Type*) [Mul M] [Mul N] extends M ≃ N, M →ₙ* N\n\n"}
{"name":"MulEquiv.mk.sizeOf_spec","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_9\nN : Type u_10\ninst✝³ : Mul M\ninst✝² : Mul N\ninst✝¹ : SizeOf M\ninst✝ : SizeOf N\ntoEquiv : Equiv M N\nmap_mul' : ∀ (x y : M), Eq (toEquiv.toFun (HMul.hMul x y)) (HMul.hMul (toEquiv.toFun x) (toEquiv.toFun y))\n⊢ Eq (SizeOf.sizeOf { toEquiv := toEquiv, map_mul' := map_mul' }) (HAdd.hAdd 1 (SizeOf.sizeOf toEquiv))","decl":"/-- `MulEquiv α β` is the type of an equiv `α ≃ β` which preserves multiplication. -/\n@[to_additive]\nstructure MulEquiv (M N : Type*) [Mul M] [Mul N] extends M ≃ N, M →ₙ* N\n\n"}
{"name":"MulEquiv.map_mul'","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_9\nN : Type u_10\ninst✝¹ : Mul M\ninst✝ : Mul N\nself : MulEquiv M N\nx y : M\n⊢ Eq (self.toFun (HMul.hMul x y)) (HMul.hMul (self.toFun x) (self.toFun y))","decl":"/-- `MulEquiv α β` is the type of an equiv `α ≃ β` which preserves multiplication. -/\n@[to_additive]\nstructure MulEquiv (M N : Type*) [Mul M] [Mul N] extends M ≃ N, M →ₙ* N\n\n"}
{"name":"MulEquiv.toEquiv_injective","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝¹ : Mul α\ninst✝ : Mul β\n⊢ Function.Injective MulEquiv.toEquiv","decl":"@[to_additive]\nlemma MulEquiv.toEquiv_injective {α β : Type*} [Mul α] [Mul β] :\n    Function.Injective (toEquiv : (α ≃* β) → (α ≃ β))\n  | ⟨_, _⟩, ⟨_, _⟩, rfl => rfl\n\n"}
{"name":"AddEquiv.toEquiv_injective","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝¹ : Add α\ninst✝ : Add β\n⊢ Function.Injective AddEquiv.toEquiv","decl":"@[to_additive]\nlemma MulEquiv.toEquiv_injective {α β : Type*} [Mul α] [Mul β] :\n    Function.Injective (toEquiv : (α ≃* β) → (α ≃ β))\n  | ⟨_, _⟩, ⟨_, _⟩, rfl => rfl\n\n"}
{"name":"MulEquivClass.map_mul","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"F : Type u_9\nA : outParam (Type u_10)\nB : outParam (Type u_11)\ninst✝² : Mul A\ninst✝¹ : Mul B\ninst✝ : EquivLike F A B\nself : MulEquivClass F A B\nf : F\na b : A\n⊢ Eq (f (HMul.hMul a b)) (HMul.hMul (f a) (f b))","decl":"/-- `MulEquivClass F A B` states that `F` is a type of multiplication-preserving morphisms.\nYou should extend this class when you extend `MulEquiv`. -/\n-- TODO: make this a synonym for MulHomClass?\n@[to_additive]\nclass MulEquivClass (F : Type*) (A B : outParam Type*) [Mul A] [Mul B] [EquivLike F A B] :\n    Prop where\n  /-- Preserves multiplication. -/\n  map_mul : ∀ (f : F) (a b), f (a * b) = f a * f b\n\n"}
{"name":"MulEquivClass.map_eq_one_iff","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"F : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝⁴ : One M\ninst✝³ : One N\ninst✝² : FunLike F M N\ninst✝¹ : EmbeddingLike F M N\ninst✝ : OneHomClass F M N\nf : F\nx : M\n⊢ Iff (Eq (f x) 1) (Eq x 1)","decl":"@[to_additive]\nalias MulEquivClass.map_eq_one_iff := EmbeddingLike.map_eq_one_iff\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"AddEquivClass.map_eq_zero_iff","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"F : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝⁴ : Zero M\ninst✝³ : Zero N\ninst✝² : FunLike F M N\ninst✝¹ : EmbeddingLike F M N\ninst✝ : ZeroHomClass F M N\nf : F\nx : M\n⊢ Iff (Eq (f x) 0) (Eq x 0)","decl":"@[to_additive]\nalias MulEquivClass.map_eq_one_iff := EmbeddingLike.map_eq_one_iff\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"AddEquivClass.map_ne_zero_iff","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"F : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝⁴ : Zero M\ninst✝³ : Zero N\ninst✝² : FunLike F M N\ninst✝¹ : EmbeddingLike F M N\ninst✝ : ZeroHomClass F M N\nf : F\nx : M\n⊢ Iff (Ne (f x) 0) (Ne x 0)","decl":"@[to_additive]\nalias MulEquivClass.map_ne_one_iff := EmbeddingLike.map_ne_one_iff\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"MulEquivClass.map_ne_one_iff","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"F : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝⁴ : One M\ninst✝³ : One N\ninst✝² : FunLike F M N\ninst✝¹ : EmbeddingLike F M N\ninst✝ : OneHomClass F M N\nf : F\nx : M\n⊢ Iff (Ne (f x) 1) (Ne x 1)","decl":"@[to_additive]\nalias MulEquivClass.map_ne_one_iff := EmbeddingLike.map_ne_one_iff\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"AddEquivClass.instAddHomClass","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝² : Add M\ninst✝¹ : Add N\ninst✝ : EquivLike F M N\nh : AddEquivClass F M N\n⊢ AddHomClass F M N","decl":"@[to_additive]\ninstance (priority := 100) instMulHomClass (F : Type*)\n    [Mul M] [Mul N] [EquivLike F M N] [h : MulEquivClass F M N] : MulHomClass F M N :=\n  { h with }\n\n-- See note [lower instance priority]\n"}
{"name":"MulEquivClass.instMulHomClass","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝² : Mul M\ninst✝¹ : Mul N\ninst✝ : EquivLike F M N\nh : MulEquivClass F M N\n⊢ MulHomClass F M N","decl":"@[to_additive]\ninstance (priority := 100) instMulHomClass (F : Type*)\n    [Mul M] [Mul N] [EquivLike F M N] [h : MulEquivClass F M N] : MulHomClass F M N :=\n  { h with }\n\n-- See note [lower instance priority]\n"}
{"name":"AddEquivClass.instAddMonoidHomClass","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"F : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝³ : EquivLike F M N\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddEquivClass F M N\n⊢ AddMonoidHomClass F M N","decl":"@[to_additive]\ninstance (priority := 100) instMonoidHomClass\n    [MulOneClass M] [MulOneClass N] [MulEquivClass F M N] :\n    MonoidHomClass F M N :=\n  { MulEquivClass.instMulHomClass F with\n    map_one := fun e =>\n      calc\n        e 1 = e 1 * 1 := (mul_one _).symm\n        _ = e 1 * e (EquivLike.inv e (1 : N) : M) :=\n          congr_arg _ (EquivLike.right_inv e 1).symm\n        _ = e (EquivLike.inv e (1 : N)) := by rw [← map_mul, one_mul]\n        _ = 1 := EquivLike.right_inv e 1 }\n\n"}
{"name":"MulEquivClass.instMonoidHomClass","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"F : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝³ : EquivLike F M N\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulEquivClass F M N\n⊢ MonoidHomClass F M N","decl":"@[to_additive]\ninstance (priority := 100) instMonoidHomClass\n    [MulOneClass M] [MulOneClass N] [MulEquivClass F M N] :\n    MonoidHomClass F M N :=\n  { MulEquivClass.instMulHomClass F with\n    map_one := fun e =>\n      calc\n        e 1 = e 1 * 1 := (mul_one _).symm\n        _ = e 1 * e (EquivLike.inv e (1 : N) : M) :=\n          congr_arg _ (EquivLike.right_inv e 1).symm\n        _ = e (EquivLike.inv e (1 : N)) := by rw [← map_mul, one_mul]\n        _ = 1 := EquivLike.right_inv e 1 }\n\n"}
{"name":"AddEquiv.instAddEquivClass","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\n⊢ AddEquivClass (AddEquiv M N) M N","decl":"@[to_additive]\ninstance : MulEquivClass (M ≃* N) M N where\n  map_mul f := f.map_mul'\n\n"}
{"name":"MulEquiv.instMulEquivClass","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\n⊢ MulEquivClass (MulEquiv M N) M N","decl":"@[to_additive]\ninstance : MulEquivClass (M ≃* N) M N where\n  map_mul f := f.map_mul'\n\n"}
{"name":"AddEquiv.ext","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf g : AddEquiv M N\nh : ∀ (x : M), Eq (f x) (g x)\n⊢ Eq f g","decl":"/-- Two multiplicative isomorphisms agree if they are defined by the\nsame underlying function. -/\n@[to_additive (attr := ext)\n  \"Two additive isomorphisms agree if they are defined by the same underlying function.\"]\ntheorem ext {f g : MulEquiv M N} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"AddEquiv.ext_iff","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf g : AddEquiv M N\n⊢ Iff (Eq f g) (∀ (x : M), Eq (f x) (g x))","decl":"/-- Two multiplicative isomorphisms agree if they are defined by the\nsame underlying function. -/\n@[to_additive (attr := ext)\n  \"Two additive isomorphisms agree if they are defined by the same underlying function.\"]\ntheorem ext {f g : MulEquiv M N} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"MulEquiv.ext","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf g : MulEquiv M N\nh : ∀ (x : M), Eq (f x) (g x)\n⊢ Eq f g","decl":"/-- Two multiplicative isomorphisms agree if they are defined by the\nsame underlying function. -/\n@[to_additive (attr := ext)\n  \"Two additive isomorphisms agree if they are defined by the same underlying function.\"]\ntheorem ext {f g : MulEquiv M N} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"MulEquiv.ext_iff","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf g : MulEquiv M N\n⊢ Iff (Eq f g) (∀ (x : M), Eq (f x) (g x))","decl":"/-- Two multiplicative isomorphisms agree if they are defined by the\nsame underlying function. -/\n@[to_additive (attr := ext)\n  \"Two additive isomorphisms agree if they are defined by the same underlying function.\"]\ntheorem ext {f g : MulEquiv M N} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"MulEquiv.congr_arg","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulEquiv M N\nx x' : M\na✝ : Eq x x'\n⊢ Eq (f x) (f x')","decl":"@[to_additive]\nprotected theorem congr_arg {f : MulEquiv M N} {x x' : M} : x = x' → f x = f x' :=\n  DFunLike.congr_arg f\n\n"}
{"name":"AddEquiv.congr_arg","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddEquiv M N\nx x' : M\na✝ : Eq x x'\n⊢ Eq (f x) (f x')","decl":"@[to_additive]\nprotected theorem congr_arg {f : MulEquiv M N} {x x' : M} : x = x' → f x = f x' :=\n  DFunLike.congr_arg f\n\n"}
{"name":"AddEquiv.congr_fun","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf g : AddEquiv M N\nh : Eq f g\nx : M\n⊢ Eq (f x) (g x)","decl":"@[to_additive]\nprotected theorem congr_fun {f g : MulEquiv M N} (h : f = g) (x : M) : f x = g x :=\n  DFunLike.congr_fun h x\n\n"}
{"name":"MulEquiv.congr_fun","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf g : MulEquiv M N\nh : Eq f g\nx : M\n⊢ Eq (f x) (g x)","decl":"@[to_additive]\nprotected theorem congr_fun {f g : MulEquiv M N} (h : f = g) (x : M) : f x = g x :=\n  DFunLike.congr_fun h x\n\n"}
{"name":"AddEquiv.coe_mk","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : Equiv M N\nhf : ∀ (x y : M), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\n⊢ Eq ⇑{ toEquiv := f, map_add' := hf } ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem coe_mk (f : M ≃ N) (hf : ∀ x y, f (x * y) = f x * f y) : (mk f hf : M → N) = f := rfl\n\n"}
{"name":"MulEquiv.coe_mk","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : Equiv M N\nhf : ∀ (x y : M), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\n⊢ Eq ⇑{ toEquiv := f, map_mul' := hf } ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem coe_mk (f : M ≃ N) (hf : ∀ x y, f (x * y) = f x * f y) : (mk f hf : M → N) = f := rfl\n\n"}
{"name":"AddEquiv.mk_coe","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\ne : AddEquiv M N\ne' : N → M\nh₁ : Function.LeftInverse e' ⇑e\nh₂ : Function.RightInverse e' ⇑e\nh₃ : ∀ (x y : M), Eq ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂ }.toFun (HAdd.hAdd x y)) (HAdd.hAdd ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂ }.toFun x) ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂ }.toFun y))\n⊢ Eq { toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂, map_add' := h₃ } e","decl":"@[to_additive (attr := simp)]\ntheorem mk_coe (e : M ≃* N) (e' h₁ h₂ h₃) : (⟨⟨e, e', h₁, h₂⟩, h₃⟩ : M ≃* N) = e :=\n  ext fun _ => rfl\n\n"}
{"name":"MulEquiv.mk_coe","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : MulEquiv M N\ne' : N → M\nh₁ : Function.LeftInverse e' ⇑e\nh₂ : Function.RightInverse e' ⇑e\nh₃ : ∀ (x y : M), Eq ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂ }.toFun (HMul.hMul x y)) (HMul.hMul ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂ }.toFun x) ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂ }.toFun y))\n⊢ Eq { toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂, map_mul' := h₃ } e","decl":"@[to_additive (attr := simp)]\ntheorem mk_coe (e : M ≃* N) (e' h₁ h₂ h₃) : (⟨⟨e, e', h₁, h₂⟩, h₃⟩ : M ≃* N) = e :=\n  ext fun _ => rfl\n\n"}
{"name":"AddEquiv.toEquiv_eq_coe","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddEquiv M N\n⊢ Eq f.toEquiv ↑f","decl":"@[to_additive (attr := simp)]\ntheorem toEquiv_eq_coe (f : M ≃* N) : f.toEquiv = f :=\n  rfl\n\n"}
{"name":"MulEquiv.toEquiv_eq_coe","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulEquiv M N\n⊢ Eq f.toEquiv ↑f","decl":"@[to_additive (attr := simp)]\ntheorem toEquiv_eq_coe (f : M ≃* N) : f.toEquiv = f :=\n  rfl\n\n"}
{"name":"AddEquiv.toAddHom_eq_coe","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddEquiv M N\n⊢ Eq f.toAddHom ↑f","decl":"/-- The `simp`-normal form to turn something into a `MulHom` is via `MulHomClass.toMulHom`. -/\n@[to_additive (attr := simp)]\ntheorem toMulHom_eq_coe (f : M ≃* N) : f.toMulHom = ↑f :=\n  rfl\n\n"}
{"name":"MulEquiv.toMulHom_eq_coe","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulEquiv M N\n⊢ Eq f.toMulHom ↑f","decl":"/-- The `simp`-normal form to turn something into a `MulHom` is via `MulHomClass.toMulHom`. -/\n@[to_additive (attr := simp)]\ntheorem toMulHom_eq_coe (f : M ≃* N) : f.toMulHom = ↑f :=\n  rfl\n\n"}
{"name":"MulEquiv.toFun_eq_coe","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulEquiv M N\n⊢ Eq f.toFun ⇑f","decl":"@[to_additive]\ntheorem toFun_eq_coe (f : M ≃* N) : f.toFun = f := rfl\n\n"}
{"name":"AddEquiv.toFun_eq_coe","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddEquiv M N\n⊢ Eq f.toFun ⇑f","decl":"@[to_additive]\ntheorem toFun_eq_coe (f : M ≃* N) : f.toFun = f := rfl\n\n"}
{"name":"AddEquiv.coe_toEquiv","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddEquiv M N\n⊢ Eq ⇑↑f ⇑f","decl":"/-- `simp`-normal form of `toFun_eq_coe`. -/\n@[to_additive (attr := simp)]\ntheorem coe_toEquiv (f : M ≃* N) : ⇑(f : M ≃ N) = f := rfl\n\n"}
{"name":"MulEquiv.coe_toEquiv","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulEquiv M N\n⊢ Eq ⇑↑f ⇑f","decl":"/-- `simp`-normal form of `toFun_eq_coe`. -/\n@[to_additive (attr := simp)]\ntheorem coe_toEquiv (f : M ≃* N) : ⇑(f : M ≃ N) = f := rfl\n\n"}
{"name":"MulEquiv.coe_toMulHom","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulEquiv M N\n⊢ Eq ⇑f.toMulHom ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem coe_toMulHom {f : M ≃* N} : (f.toMulHom : M → N) = f := rfl\n\n"}
{"name":"AddEquiv.coe_toAddHom","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddEquiv M N\n⊢ Eq ⇑f.toAddHom ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem coe_toMulHom {f : M ≃* N} : (f.toMulHom : M → N) = f := rfl\n\n"}
{"name":"MulEquiv.map_mul","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulEquiv M N\nx y : M\n⊢ Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))","decl":"/-- A multiplicative isomorphism preserves multiplication. -/\n@[to_additive \"An additive isomorphism preserves addition.\"]\nprotected theorem map_mul (f : M ≃* N) : ∀ x y, f (x * y) = f x * f y :=\n  map_mul f\n\n"}
{"name":"AddEquiv.map_add","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddEquiv M N\nx y : M\n⊢ Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))","decl":"/-- A multiplicative isomorphism preserves multiplication. -/\n@[to_additive \"An additive isomorphism preserves addition.\"]\nprotected theorem map_mul (f : M ≃* N) : ∀ x y, f (x * y) = f x * f y :=\n  map_mul f\n\n"}
{"name":"AddEquiv.bijective","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\ne : AddEquiv M N\n⊢ Function.Bijective ⇑e","decl":"@[to_additive]\nprotected theorem bijective (e : M ≃* N) : Function.Bijective e :=\n  EquivLike.bijective e\n\n"}
{"name":"MulEquiv.bijective","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : MulEquiv M N\n⊢ Function.Bijective ⇑e","decl":"@[to_additive]\nprotected theorem bijective (e : M ≃* N) : Function.Bijective e :=\n  EquivLike.bijective e\n\n"}
{"name":"MulEquiv.injective","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : MulEquiv M N\n⊢ Function.Injective ⇑e","decl":"@[to_additive]\nprotected theorem injective (e : M ≃* N) : Function.Injective e :=\n  EquivLike.injective e\n\n"}
{"name":"AddEquiv.injective","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\ne : AddEquiv M N\n⊢ Function.Injective ⇑e","decl":"@[to_additive]\nprotected theorem injective (e : M ≃* N) : Function.Injective e :=\n  EquivLike.injective e\n\n"}
{"name":"AddEquiv.surjective","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\ne : AddEquiv M N\n⊢ Function.Surjective ⇑e","decl":"@[to_additive]\nprotected theorem surjective (e : M ≃* N) : Function.Surjective e :=\n  EquivLike.surjective e\n\n"}
{"name":"MulEquiv.surjective","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : MulEquiv M N\n⊢ Function.Surjective ⇑e","decl":"@[to_additive]\nprotected theorem surjective (e : M ≃* N) : Function.Surjective e :=\n  EquivLike.surjective e\n\n"}
{"name":"AddEquiv.apply_eq_iff_eq","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\ne : AddEquiv M N\nx y : M\n⊢ Iff (Eq (e x) (e y)) (Eq x y)","decl":"@[to_additive]\ntheorem apply_eq_iff_eq (e : M ≃* N) {x y : M} : e x = e y ↔ x = y :=\n  e.injective.eq_iff\n\n"}
{"name":"MulEquiv.apply_eq_iff_eq","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : MulEquiv M N\nx y : M\n⊢ Iff (Eq (e x) (e y)) (Eq x y)","decl":"@[to_additive]\ntheorem apply_eq_iff_eq (e : M ≃* N) {x y : M} : e x = e y ↔ x = y :=\n  e.injective.eq_iff\n\n"}
{"name":"AddEquiv.coe_refl","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\ninst✝ : Add M\n⊢ Eq (⇑(AddEquiv.refl M)) id","decl":"@[to_additive (attr := simp)]\ntheorem coe_refl : ↑(refl M) = id := rfl\n\n"}
{"name":"MulEquiv.coe_refl","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\ninst✝ : Mul M\n⊢ Eq (⇑(MulEquiv.refl M)) id","decl":"@[to_additive (attr := simp)]\ntheorem coe_refl : ↑(refl M) = id := rfl\n\n"}
{"name":"MulEquiv.refl_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\ninst✝ : Mul M\nm : M\n⊢ Eq ((MulEquiv.refl M) m) m","decl":"@[to_additive (attr := simp)]\ntheorem refl_apply (m : M) : refl M m = m := rfl\n\n"}
{"name":"AddEquiv.refl_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\ninst✝ : Add M\nm : M\n⊢ Eq ((AddEquiv.refl M) m) m","decl":"@[to_additive (attr := simp)]\ntheorem refl_apply (m : M) : refl M m = m := rfl\n\n"}
{"name":"AddEquiv.symm_map_add","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_9\nN : Type u_10\ninst✝¹ : Add M\ninst✝ : Add N\nh : AddEquiv M N\nx y : N\n⊢ Eq (h.symm (HAdd.hAdd x y)) (HAdd.hAdd (h.symm x) (h.symm y))","decl":"/-- An alias for `h.symm.map_mul`. Introduced to fix the issue in\nhttps://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/!4.234183.20.60simps.60.20maximum.20recursion.20depth\n-/\n@[to_additive]\nlemma symm_map_mul {M N : Type*} [Mul M] [Mul N] (h : M ≃* N) (x y : N) :\n    h.symm (x * y) = h.symm x * h.symm y :=\n  map_mul (h.toMulHom.inverse h.toEquiv.symm h.left_inv h.right_inv) x y\n\n"}
{"name":"MulEquiv.symm_map_mul","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_9\nN : Type u_10\ninst✝¹ : Mul M\ninst✝ : Mul N\nh : MulEquiv M N\nx y : N\n⊢ Eq (h.symm (HMul.hMul x y)) (HMul.hMul (h.symm x) (h.symm y))","decl":"/-- An alias for `h.symm.map_mul`. Introduced to fix the issue in\nhttps://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/!4.234183.20.60simps.60.20maximum.20recursion.20depth\n-/\n@[to_additive]\nlemma symm_map_mul {M N : Type*} [Mul M] [Mul N] (h : M ≃* N) (x y : N) :\n    h.symm (x * y) = h.symm x * h.symm y :=\n  map_mul (h.toMulHom.inverse h.toEquiv.symm h.left_inv h.right_inv) x y\n\n"}
{"name":"MulEquiv.invFun_eq_symm","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulEquiv M N\n⊢ Eq f.invFun ⇑f.symm","decl":"@[to_additive]\ntheorem invFun_eq_symm {f : M ≃* N} : f.invFun = f.symm := rfl\n\n"}
{"name":"AddEquiv.invFun_eq_symm","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddEquiv M N\n⊢ Eq f.invFun ⇑f.symm","decl":"@[to_additive]\ntheorem invFun_eq_symm {f : M ≃* N} : f.invFun = f.symm := rfl\n\n"}
{"name":"MulEquiv.coe_toEquiv_symm","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulEquiv M N\n⊢ Eq ⇑(↑f).symm ⇑f.symm","decl":"/-- `simp`-normal form of `invFun_eq_symm`. -/\n@[to_additive (attr := simp)]\ntheorem coe_toEquiv_symm (f : M ≃* N) : ((f : M ≃ N).symm : N → M) = f.symm := rfl\n\n"}
{"name":"AddEquiv.coe_toEquiv_symm","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddEquiv M N\n⊢ Eq ⇑(↑f).symm ⇑f.symm","decl":"/-- `simp`-normal form of `invFun_eq_symm`. -/\n@[to_additive (attr := simp)]\ntheorem coe_toEquiv_symm (f : M ≃* N) : ((f : M ≃ N).symm : N → M) = f.symm := rfl\n\n"}
{"name":"MulEquiv.equivLike_inv_eq_symm","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulEquiv M N\n⊢ Eq (EquivLike.inv f) ⇑f.symm","decl":"@[to_additive (attr := simp)]\ntheorem equivLike_inv_eq_symm (f : M ≃* N) : EquivLike.inv f = f.symm := rfl\n\n"}
{"name":"AddEquiv.equivLike_neg_eq_symm","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddEquiv M N\n⊢ Eq (EquivLike.inv f) ⇑f.symm","decl":"@[to_additive (attr := simp)]\ntheorem equivLike_inv_eq_symm (f : M ≃* N) : EquivLike.inv f = f.symm := rfl\n\n"}
{"name":"MulEquiv.toEquiv_symm","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulEquiv M N\n⊢ Eq (↑f.symm) (↑f).symm","decl":"@[to_additive (attr := simp)]\ntheorem toEquiv_symm (f : M ≃* N) : (f.symm : N ≃ M) = (f : M ≃ N).symm := rfl\n\n"}
{"name":"AddEquiv.toEquiv_symm","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddEquiv M N\n⊢ Eq (↑f.symm) (↑f).symm","decl":"@[to_additive (attr := simp)]\ntheorem toEquiv_symm (f : M ≃* N) : (f.symm : N ≃ M) = (f : M ≃ N).symm := rfl\n\n"}
{"name":"MulEquiv.symm_symm","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulEquiv M N\n⊢ Eq f.symm.symm f","decl":"@[to_additive (attr := simp)]\ntheorem symm_symm (f : M ≃* N) : f.symm.symm = f := rfl\n\n"}
{"name":"AddEquiv.symm_symm","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddEquiv M N\n⊢ Eq f.symm.symm f","decl":"@[to_additive (attr := simp)]\ntheorem symm_symm (f : M ≃* N) : f.symm.symm = f := rfl\n\n"}
{"name":"MulEquiv.symm_bijective","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\n⊢ Function.Bijective MulEquiv.symm","decl":"@[to_additive]\ntheorem symm_bijective : Function.Bijective (symm : (M ≃* N) → N ≃* M) :=\n  Function.bijective_iff_has_inverse.mpr ⟨_, symm_symm, symm_symm⟩\n\n"}
{"name":"AddEquiv.symm_bijective","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\n⊢ Function.Bijective AddEquiv.symm","decl":"@[to_additive]\ntheorem symm_bijective : Function.Bijective (symm : (M ≃* N) → N ≃* M) :=\n  Function.bijective_iff_has_inverse.mpr ⟨_, symm_symm, symm_symm⟩\n\n"}
{"name":"MulEquiv.mk_coe'","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : MulEquiv M N\nf : N → M\nh₁ : Function.LeftInverse (⇑e) f\nh₂ : Function.RightInverse (⇑e) f\nh₃ : ∀ (x y : N), Eq ({ toFun := f, invFun := ⇑e, left_inv := h₁, right_inv := h₂ }.toFun (HMul.hMul x y)) (HMul.hMul ({ toFun := f, invFun := ⇑e, left_inv := h₁, right_inv := h₂ }.toFun x) ({ toFun := f, invFun := ⇑e, left_inv := h₁, right_inv := h₂ }.toFun y))\n⊢ Eq { toFun := f, invFun := ⇑e, left_inv := h₁, right_inv := h₂, map_mul' := h₃ } e.symm","decl":"@[to_additive (attr := simp)]\ntheorem mk_coe' (e : M ≃* N) (f h₁ h₂ h₃) : (MulEquiv.mk ⟨f, e, h₁, h₂⟩ h₃ : N ≃* M) = e.symm :=\n  symm_bijective.injective <| ext fun _ => rfl\n\n"}
{"name":"AddEquiv.mk_coe'","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\ne : AddEquiv M N\nf : N → M\nh₁ : Function.LeftInverse (⇑e) f\nh₂ : Function.RightInverse (⇑e) f\nh₃ : ∀ (x y : N), Eq ({ toFun := f, invFun := ⇑e, left_inv := h₁, right_inv := h₂ }.toFun (HAdd.hAdd x y)) (HAdd.hAdd ({ toFun := f, invFun := ⇑e, left_inv := h₁, right_inv := h₂ }.toFun x) ({ toFun := f, invFun := ⇑e, left_inv := h₁, right_inv := h₂ }.toFun y))\n⊢ Eq { toFun := f, invFun := ⇑e, left_inv := h₁, right_inv := h₂, map_add' := h₃ } e.symm","decl":"@[to_additive (attr := simp)]\ntheorem mk_coe' (e : M ≃* N) (f h₁ h₂ h₃) : (MulEquiv.mk ⟨f, e, h₁, h₂⟩ h₃ : N ≃* M) = e.symm :=\n  symm_bijective.injective <| ext fun _ => rfl\n\n"}
{"name":"MulEquiv.symm_mk","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : Equiv M N\nh : ∀ (x y : M), Eq (f.toFun (HMul.hMul x y)) (HMul.hMul (f.toFun x) (f.toFun y))\n⊢ Eq { toEquiv := f, map_mul' := h }.symm { toEquiv := f.symm, map_mul' := ⋯ }","decl":"@[to_additive (attr := simp)]\ntheorem symm_mk (f : M ≃ N) (h) :\n    (MulEquiv.mk f h).symm = ⟨f.symm, (MulEquiv.mk f h).symm_map_mul⟩ := rfl\n\n"}
{"name":"AddEquiv.symm_mk","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : Equiv M N\nh : ∀ (x y : M), Eq (f.toFun (HAdd.hAdd x y)) (HAdd.hAdd (f.toFun x) (f.toFun y))\n⊢ Eq { toEquiv := f, map_add' := h }.symm { toEquiv := f.symm, map_add' := ⋯ }","decl":"@[to_additive (attr := simp)]\ntheorem symm_mk (f : M ≃ N) (h) :\n    (MulEquiv.mk f h).symm = ⟨f.symm, (MulEquiv.mk f h).symm_map_mul⟩ := rfl\n\n"}
{"name":"AddEquiv.refl_symm","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\ninst✝ : Add M\n⊢ Eq (AddEquiv.refl M).symm (AddEquiv.refl M)","decl":"@[to_additive (attr := simp)]\ntheorem refl_symm : (refl M).symm = refl M := rfl\n\n"}
{"name":"MulEquiv.refl_symm","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\ninst✝ : Mul M\n⊢ Eq (MulEquiv.refl M).symm (MulEquiv.refl M)","decl":"@[to_additive (attr := simp)]\ntheorem refl_symm : (refl M).symm = refl M := rfl\n\n"}
{"name":"AddEquiv.apply_symm_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\ne : AddEquiv M N\ny : N\n⊢ Eq (e (e.symm y)) y","decl":"/-- `e.symm` is a right inverse of `e`, written as `e (e.symm y) = y`. -/\n@[to_additive (attr := simp) \"`e.symm` is a right inverse of `e`, written as `e (e.symm y) = y`.\"]\ntheorem apply_symm_apply (e : M ≃* N) (y : N) : e (e.symm y) = y :=\n  e.toEquiv.apply_symm_apply y\n\n"}
{"name":"MulEquiv.apply_symm_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : MulEquiv M N\ny : N\n⊢ Eq (e (e.symm y)) y","decl":"/-- `e.symm` is a right inverse of `e`, written as `e (e.symm y) = y`. -/\n@[to_additive (attr := simp) \"`e.symm` is a right inverse of `e`, written as `e (e.symm y) = y`.\"]\ntheorem apply_symm_apply (e : M ≃* N) (y : N) : e (e.symm y) = y :=\n  e.toEquiv.apply_symm_apply y\n\n"}
{"name":"AddEquiv.symm_apply_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\ne : AddEquiv M N\nx : M\n⊢ Eq (e.symm (e x)) x","decl":"/-- `e.symm` is a left inverse of `e`, written as `e.symm (e y) = y`. -/\n@[to_additive (attr := simp) \"`e.symm` is a left inverse of `e`, written as `e.symm (e y) = y`.\"]\ntheorem symm_apply_apply (e : M ≃* N) (x : M) : e.symm (e x) = x :=\n  e.toEquiv.symm_apply_apply x\n\n"}
{"name":"MulEquiv.symm_apply_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : MulEquiv M N\nx : M\n⊢ Eq (e.symm (e x)) x","decl":"/-- `e.symm` is a left inverse of `e`, written as `e.symm (e y) = y`. -/\n@[to_additive (attr := simp) \"`e.symm` is a left inverse of `e`, written as `e.symm (e y) = y`.\"]\ntheorem symm_apply_apply (e : M ≃* N) (x : M) : e.symm (e x) = x :=\n  e.toEquiv.symm_apply_apply x\n\n"}
{"name":"AddEquiv.symm_comp_self","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\ne : AddEquiv M N\n⊢ Eq (Function.comp ⇑e.symm ⇑e) id","decl":"@[to_additive (attr := simp)]\ntheorem symm_comp_self (e : M ≃* N) : e.symm ∘ e = id :=\n  funext e.symm_apply_apply\n\n"}
{"name":"MulEquiv.symm_comp_self","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : MulEquiv M N\n⊢ Eq (Function.comp ⇑e.symm ⇑e) id","decl":"@[to_additive (attr := simp)]\ntheorem symm_comp_self (e : M ≃* N) : e.symm ∘ e = id :=\n  funext e.symm_apply_apply\n\n"}
{"name":"AddEquiv.self_comp_symm","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\ne : AddEquiv M N\n⊢ Eq (Function.comp ⇑e ⇑e.symm) id","decl":"@[to_additive (attr := simp)]\ntheorem self_comp_symm (e : M ≃* N) : e ∘ e.symm = id :=\n  funext e.apply_symm_apply\n\n"}
{"name":"MulEquiv.self_comp_symm","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : MulEquiv M N\n⊢ Eq (Function.comp ⇑e ⇑e.symm) id","decl":"@[to_additive (attr := simp)]\ntheorem self_comp_symm (e : M ≃* N) : e ∘ e.symm = id :=\n  funext e.apply_symm_apply\n\n"}
{"name":"AddEquiv.apply_eq_iff_symm_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\ne : AddEquiv M N\nx : M\ny : N\n⊢ Iff (Eq (e x) y) (Eq x (e.symm y))","decl":"@[to_additive]\ntheorem apply_eq_iff_symm_apply (e : M ≃* N) {x : M} {y : N} : e x = y ↔ x = e.symm y :=\n  e.toEquiv.apply_eq_iff_eq_symm_apply\n\n"}
{"name":"MulEquiv.apply_eq_iff_symm_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : MulEquiv M N\nx : M\ny : N\n⊢ Iff (Eq (e x) y) (Eq x (e.symm y))","decl":"@[to_additive]\ntheorem apply_eq_iff_symm_apply (e : M ≃* N) {x : M} {y : N} : e x = y ↔ x = e.symm y :=\n  e.toEquiv.apply_eq_iff_eq_symm_apply\n\n"}
{"name":"MulEquiv.symm_apply_eq","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : MulEquiv M N\nx : N\ny : M\n⊢ Iff (Eq (e.symm x) y) (Eq x (e y))","decl":"@[to_additive]\ntheorem symm_apply_eq (e : M ≃* N) {x y} : e.symm x = y ↔ x = e y :=\n  e.toEquiv.symm_apply_eq\n\n"}
{"name":"AddEquiv.symm_apply_eq","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\ne : AddEquiv M N\nx : N\ny : M\n⊢ Iff (Eq (e.symm x) y) (Eq x (e y))","decl":"@[to_additive]\ntheorem symm_apply_eq (e : M ≃* N) {x y} : e.symm x = y ↔ x = e y :=\n  e.toEquiv.symm_apply_eq\n\n"}
{"name":"AddEquiv.eq_symm_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\ne : AddEquiv M N\nx : N\ny : M\n⊢ Iff (Eq y (e.symm x)) (Eq (e y) x)","decl":"@[to_additive]\ntheorem eq_symm_apply (e : M ≃* N) {x y} : y = e.symm x ↔ e y = x :=\n  e.toEquiv.eq_symm_apply\n\n"}
{"name":"MulEquiv.eq_symm_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : MulEquiv M N\nx : N\ny : M\n⊢ Iff (Eq y (e.symm x)) (Eq (e y) x)","decl":"@[to_additive]\ntheorem eq_symm_apply (e : M ≃* N) {x y} : y = e.symm x ↔ e y = x :=\n  e.toEquiv.eq_symm_apply\n\n"}
{"name":"AddEquiv.eq_comp_symm","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nα : Type u_9\ne : AddEquiv M N\nf : N → α\ng : M → α\n⊢ Iff (Eq f (Function.comp g ⇑e.symm)) (Eq (Function.comp f ⇑e) g)","decl":"@[to_additive]\ntheorem eq_comp_symm {α : Type*} (e : M ≃* N) (f : N → α) (g : M → α) :\n    f = g ∘ e.symm ↔ f ∘ e = g :=\n  e.toEquiv.eq_comp_symm f g\n\n"}
{"name":"MulEquiv.eq_comp_symm","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nα : Type u_9\ne : MulEquiv M N\nf : N → α\ng : M → α\n⊢ Iff (Eq f (Function.comp g ⇑e.symm)) (Eq (Function.comp f ⇑e) g)","decl":"@[to_additive]\ntheorem eq_comp_symm {α : Type*} (e : M ≃* N) (f : N → α) (g : M → α) :\n    f = g ∘ e.symm ↔ f ∘ e = g :=\n  e.toEquiv.eq_comp_symm f g\n\n"}
{"name":"AddEquiv.comp_symm_eq","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nα : Type u_9\ne : AddEquiv M N\nf : N → α\ng : M → α\n⊢ Iff (Eq (Function.comp g ⇑e.symm) f) (Eq g (Function.comp f ⇑e))","decl":"@[to_additive]\ntheorem comp_symm_eq {α : Type*} (e : M ≃* N) (f : N → α) (g : M → α) :\n    g ∘ e.symm = f ↔ g = f ∘ e :=\n  e.toEquiv.comp_symm_eq f g\n\n"}
{"name":"MulEquiv.comp_symm_eq","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nα : Type u_9\ne : MulEquiv M N\nf : N → α\ng : M → α\n⊢ Iff (Eq (Function.comp g ⇑e.symm) f) (Eq g (Function.comp f ⇑e))","decl":"@[to_additive]\ntheorem comp_symm_eq {α : Type*} (e : M ≃* N) (f : N → α) (g : M → α) :\n    g ∘ e.symm = f ↔ g = f ∘ e :=\n  e.toEquiv.comp_symm_eq f g\n\n"}
{"name":"MulEquiv.eq_symm_comp","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nα : Type u_9\ne : MulEquiv M N\nf : α → M\ng : α → N\n⊢ Iff (Eq f (Function.comp (⇑e.symm) g)) (Eq (Function.comp (⇑e) f) g)","decl":"@[to_additive]\ntheorem eq_symm_comp {α : Type*} (e : M ≃* N) (f : α → M) (g : α → N) :\n    f = e.symm ∘ g ↔ e ∘ f = g :=\n  e.toEquiv.eq_symm_comp f g\n\n"}
{"name":"AddEquiv.eq_symm_comp","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nα : Type u_9\ne : AddEquiv M N\nf : α → M\ng : α → N\n⊢ Iff (Eq f (Function.comp (⇑e.symm) g)) (Eq (Function.comp (⇑e) f) g)","decl":"@[to_additive]\ntheorem eq_symm_comp {α : Type*} (e : M ≃* N) (f : α → M) (g : α → N) :\n    f = e.symm ∘ g ↔ e ∘ f = g :=\n  e.toEquiv.eq_symm_comp f g\n\n"}
{"name":"AddEquiv.symm_comp_eq","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nα : Type u_9\ne : AddEquiv M N\nf : α → M\ng : α → N\n⊢ Iff (Eq (Function.comp (⇑e.symm) g) f) (Eq g (Function.comp (⇑e) f))","decl":"@[to_additive]\ntheorem symm_comp_eq {α : Type*} (e : M ≃* N) (f : α → M) (g : α → N) :\n    e.symm ∘ g = f ↔ g = e ∘ f :=\n  e.toEquiv.symm_comp_eq f g\n\n"}
{"name":"MulEquiv.symm_comp_eq","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nα : Type u_9\ne : MulEquiv M N\nf : α → M\ng : α → N\n⊢ Iff (Eq (Function.comp (⇑e.symm) g) f) (Eq g (Function.comp (⇑e) f))","decl":"@[to_additive]\ntheorem symm_comp_eq {α : Type*} (e : M ≃* N) (f : α → M) (g : α → N) :\n    e.symm ∘ g = f ↔ g = e ∘ f :=\n  e.toEquiv.symm_comp_eq f g\n\n"}
{"name":"MulEquivClass.apply_coe_symm_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝³ : Mul α\ninst✝² : Mul β\nF : Type u_11\ninst✝¹ : EquivLike F α β\ninst✝ : MulEquivClass F α β\ne : F\nx : β\n⊢ Eq (e ((↑e).symm x)) x","decl":"@[to_additive (attr := simp)]\ntheorem _root_.MulEquivClass.apply_coe_symm_apply {α β} [Mul α] [Mul β] {F} [EquivLike F α β]\n    [MulEquivClass F α β] (e : F) (x : β) :\n    e ((e : α ≃* β).symm x) = x :=\n  (e : α ≃* β).right_inv x\n\n"}
{"name":"AddEquivClass.apply_coe_symm_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝³ : Add α\ninst✝² : Add β\nF : Type u_11\ninst✝¹ : EquivLike F α β\ninst✝ : AddEquivClass F α β\ne : F\nx : β\n⊢ Eq (e ((↑e).symm x)) x","decl":"@[to_additive (attr := simp)]\ntheorem _root_.MulEquivClass.apply_coe_symm_apply {α β} [Mul α] [Mul β] {F} [EquivLike F α β]\n    [MulEquivClass F α β] (e : F) (x : β) :\n    e ((e : α ≃* β).symm x) = x :=\n  (e : α ≃* β).right_inv x\n\n"}
{"name":"MulEquivClass.coe_symm_apply_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝³ : Mul α\ninst✝² : Mul β\nF : Type u_11\ninst✝¹ : EquivLike F α β\ninst✝ : MulEquivClass F α β\ne : F\nx : α\n⊢ Eq ((↑e).symm (e x)) x","decl":"@[to_additive (attr := simp)]\ntheorem _root_.MulEquivClass.coe_symm_apply_apply {α β} [Mul α] [Mul β] {F} [EquivLike F α β]\n    [MulEquivClass F α β] (e : F) (x : α) :\n    (e : α ≃* β).symm (e x) = x :=\n  (e : α ≃* β).left_inv x\n\n"}
{"name":"AddEquivClass.coe_symm_apply_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝³ : Add α\ninst✝² : Add β\nF : Type u_11\ninst✝¹ : EquivLike F α β\ninst✝ : AddEquivClass F α β\ne : F\nx : α\n⊢ Eq ((↑e).symm (e x)) x","decl":"@[to_additive (attr := simp)]\ntheorem _root_.MulEquivClass.coe_symm_apply_apply {α β} [Mul α] [Mul β] {F} [EquivLike F α β]\n    [MulEquivClass F α β] (e : F) (x : α) :\n    (e : α ≃* β).symm (e x) = x :=\n  (e : α ≃* β).left_inv x\n\n"}
{"name":"AddEquiv.coe_trans","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : Add M\ninst✝¹ : Add N\ninst✝ : Add P\ne₁ : AddEquiv M N\ne₂ : AddEquiv N P\n⊢ Eq (⇑(e₁.trans e₂)) (Function.comp ⇑e₂ ⇑e₁)","decl":"@[to_additive (attr := simp)]\ntheorem coe_trans (e₁ : M ≃* N) (e₂ : N ≃* P) : ↑(e₁.trans e₂) = e₂ ∘ e₁ := rfl\n\n"}
{"name":"MulEquiv.coe_trans","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : Mul M\ninst✝¹ : Mul N\ninst✝ : Mul P\ne₁ : MulEquiv M N\ne₂ : MulEquiv N P\n⊢ Eq (⇑(e₁.trans e₂)) (Function.comp ⇑e₂ ⇑e₁)","decl":"@[to_additive (attr := simp)]\ntheorem coe_trans (e₁ : M ≃* N) (e₂ : N ≃* P) : ↑(e₁.trans e₂) = e₂ ∘ e₁ := rfl\n\n"}
{"name":"AddEquiv.trans_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : Add M\ninst✝¹ : Add N\ninst✝ : Add P\ne₁ : AddEquiv M N\ne₂ : AddEquiv N P\nm : M\n⊢ Eq ((e₁.trans e₂) m) (e₂ (e₁ m))","decl":"@[to_additive (attr := simp)]\ntheorem trans_apply (e₁ : M ≃* N) (e₂ : N ≃* P) (m : M) : e₁.trans e₂ m = e₂ (e₁ m) := rfl\n\n"}
{"name":"MulEquiv.trans_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : Mul M\ninst✝¹ : Mul N\ninst✝ : Mul P\ne₁ : MulEquiv M N\ne₂ : MulEquiv N P\nm : M\n⊢ Eq ((e₁.trans e₂) m) (e₂ (e₁ m))","decl":"@[to_additive (attr := simp)]\ntheorem trans_apply (e₁ : M ≃* N) (e₂ : N ≃* P) (m : M) : e₁.trans e₂ m = e₂ (e₁ m) := rfl\n\n"}
{"name":"AddEquiv.symm_trans_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : Add M\ninst✝¹ : Add N\ninst✝ : Add P\ne₁ : AddEquiv M N\ne₂ : AddEquiv N P\np : P\n⊢ Eq ((e₁.trans e₂).symm p) (e₁.symm (e₂.symm p))","decl":"@[to_additive (attr := simp)]\ntheorem symm_trans_apply (e₁ : M ≃* N) (e₂ : N ≃* P) (p : P) :\n    (e₁.trans e₂).symm p = e₁.symm (e₂.symm p) := rfl\n\n"}
{"name":"MulEquiv.symm_trans_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : Mul M\ninst✝¹ : Mul N\ninst✝ : Mul P\ne₁ : MulEquiv M N\ne₂ : MulEquiv N P\np : P\n⊢ Eq ((e₁.trans e₂).symm p) (e₁.symm (e₂.symm p))","decl":"@[to_additive (attr := simp)]\ntheorem symm_trans_apply (e₁ : M ≃* N) (e₂ : N ≃* P) (p : P) :\n    (e₁.trans e₂).symm p = e₁.symm (e₂.symm p) := rfl\n\n"}
{"name":"AddEquiv.symm_trans_self","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\ne : AddEquiv M N\n⊢ Eq (e.symm.trans e) (AddEquiv.refl N)","decl":"@[to_additive (attr := simp)]\ntheorem symm_trans_self (e : M ≃* N) : e.symm.trans e = refl N :=\n  DFunLike.ext _ _ e.apply_symm_apply\n\n"}
{"name":"MulEquiv.symm_trans_self","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : MulEquiv M N\n⊢ Eq (e.symm.trans e) (MulEquiv.refl N)","decl":"@[to_additive (attr := simp)]\ntheorem symm_trans_self (e : M ≃* N) : e.symm.trans e = refl N :=\n  DFunLike.ext _ _ e.apply_symm_apply\n\n"}
{"name":"AddEquiv.self_trans_symm","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\ne : AddEquiv M N\n⊢ Eq (e.trans e.symm) (AddEquiv.refl M)","decl":"@[to_additive (attr := simp)]\ntheorem self_trans_symm (e : M ≃* N) : e.trans e.symm = refl M :=\n  DFunLike.ext _ _ e.symm_apply_apply\n\n"}
{"name":"MulEquiv.self_trans_symm","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : MulEquiv M N\n⊢ Eq (e.trans e.symm) (MulEquiv.refl M)","decl":"@[to_additive (attr := simp)]\ntheorem self_trans_symm (e : M ≃* N) : e.trans e.symm = refl M :=\n  DFunLike.ext _ _ e.symm_apply_apply\n\n"}
{"name":"MulEquiv.coe_monoidHom_refl","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\ninst✝ : MulOneClass M\n⊢ Eq (↑(MulEquiv.refl M)) (MonoidHom.id M)","decl":"@[to_additive]\ntheorem coe_monoidHom_refl : (refl M : M →* M) = MonoidHom.id M := rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10618): `simp` can prove this but it is a valid `dsimp` lemma.\n-- However, we would need to redesign the the `dsimp` set to make this `@[simp]`.\n"}
{"name":"AddEquiv.coe_addMonoidHom_refl","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\ninst✝ : AddZeroClass M\n⊢ Eq (↑(AddEquiv.refl M)) (AddMonoidHom.id M)","decl":"@[to_additive]\ntheorem coe_monoidHom_refl : (refl M : M →* M) = MonoidHom.id M := rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10618): `simp` can prove this but it is a valid `dsimp` lemma.\n-- However, we would need to redesign the the `dsimp` set to make this `@[simp]`.\n"}
{"name":"MulEquiv.coe_monoidHom_trans","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\ne₁ : MulEquiv M N\ne₂ : MulEquiv N P\n⊢ Eq (↑(e₁.trans e₂)) ((↑e₂).comp ↑e₁)","decl":"@[to_additive]\nlemma coe_monoidHom_trans (e₁ : M ≃* N) (e₂ : N ≃* P) :\n    (e₁.trans e₂ : M →* P) = (e₂ : N →* P).comp ↑e₁ := rfl\n\n"}
{"name":"AddEquiv.coe_addMonoidHom_trans","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\ne₁ : AddEquiv M N\ne₂ : AddEquiv N P\n⊢ Eq (↑(e₁.trans e₂)) ((↑e₂).comp ↑e₁)","decl":"@[to_additive]\nlemma coe_monoidHom_trans (e₁ : M ≃* N) (e₂ : N ≃* P) :\n    (e₁.trans e₂ : M →* P) = (e₂ : N →* P).comp ↑e₁ := rfl\n\n"}
{"name":"MulEquiv.coe_monoidHom_comp_coe_monoidHom_symm","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\ne : MulEquiv M N\n⊢ Eq ((↑e).comp ↑e.symm) (MonoidHom.id N)","decl":"@[to_additive (attr := simp)]\nlemma coe_monoidHom_comp_coe_monoidHom_symm (e : M ≃* N) :\n    (e : M →* N).comp e.symm = MonoidHom.id _ := by ext; simp\n\n"}
{"name":"AddEquiv.coe_addMonoidHom_comp_coe_addMonoidHom_symm","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\ne : AddEquiv M N\n⊢ Eq ((↑e).comp ↑e.symm) (AddMonoidHom.id N)","decl":"@[to_additive (attr := simp)]\nlemma coe_monoidHom_comp_coe_monoidHom_symm (e : M ≃* N) :\n    (e : M →* N).comp e.symm = MonoidHom.id _ := by ext; simp\n\n"}
{"name":"AddEquiv.coe_addMonoidHom_symm_comp_coe_addMonoidHom","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\ne : AddEquiv M N\n⊢ Eq ((↑e.symm).comp ↑e) (AddMonoidHom.id M)","decl":"@[to_additive (attr := simp)]\nlemma coe_monoidHom_symm_comp_coe_monoidHom (e : M ≃* N) :\n    (e.symm : N →* M).comp e = MonoidHom.id _ := by ext; simp\n\n"}
{"name":"MulEquiv.coe_monoidHom_symm_comp_coe_monoidHom","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\ne : MulEquiv M N\n⊢ Eq ((↑e.symm).comp ↑e) (MonoidHom.id M)","decl":"@[to_additive (attr := simp)]\nlemma coe_monoidHom_symm_comp_coe_monoidHom (e : M ≃* N) :\n    (e.symm : N →* M).comp e = MonoidHom.id _ := by ext; simp\n\n"}
{"name":"MulEquiv.comp_left_injective","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\ne : MulEquiv M N\n⊢ Function.Injective fun f => f.comp ↑e","decl":"@[to_additive]\nlemma comp_left_injective (e : M ≃* N) : Injective fun f : N →* P ↦ f.comp (e : M →* N) :=\n  LeftInverse.injective (g := fun f ↦ f.comp e.symm) fun f ↦ by simp [MonoidHom.comp_assoc]\n\n"}
{"name":"AddEquiv.comp_left_injective","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\ne : AddEquiv M N\n⊢ Function.Injective fun f => f.comp ↑e","decl":"@[to_additive]\nlemma comp_left_injective (e : M ≃* N) : Injective fun f : N →* P ↦ f.comp (e : M →* N) :=\n  LeftInverse.injective (g := fun f ↦ f.comp e.symm) fun f ↦ by simp [MonoidHom.comp_assoc]\n\n"}
{"name":"AddEquiv.comp_right_injective","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\ne : AddEquiv M N\n⊢ Function.Injective fun f => (↑e).comp f","decl":"@[to_additive]\nlemma comp_right_injective (e : M ≃* N) : Injective fun f : P →* M ↦ (e : M →* N).comp f :=\n  LeftInverse.injective (g := (e.symm : N →* M).comp) fun f ↦ by simp [← MonoidHom.comp_assoc]\n\n"}
{"name":"MulEquiv.comp_right_injective","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\ne : MulEquiv M N\n⊢ Function.Injective fun f => (↑e).comp f","decl":"@[to_additive]\nlemma comp_right_injective (e : M ≃* N) : Injective fun f : P →* M ↦ (e : M →* N).comp f :=\n  LeftInverse.injective (g := (e.symm : N →* M).comp) fun f ↦ by simp [← MonoidHom.comp_assoc]\n\n"}
{"name":"AddEquiv.map_zero","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nh : AddEquiv M N\n⊢ Eq (h 0) 0","decl":"/-- A multiplicative isomorphism of monoids sends `1` to `1` (and is hence a monoid isomorphism). -/\n@[to_additive\n  \"An additive isomorphism of additive monoids sends `0` to `0`\n  (and is hence an additive monoid isomorphism).\"]\nprotected theorem map_one (h : M ≃* N) : h 1 = 1 := map_one h\n\n"}
{"name":"MulEquiv.map_one","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nh : MulEquiv M N\n⊢ Eq (h 1) 1","decl":"/-- A multiplicative isomorphism of monoids sends `1` to `1` (and is hence a monoid isomorphism). -/\n@[to_additive\n  \"An additive isomorphism of additive monoids sends `0` to `0`\n  (and is hence an additive monoid isomorphism).\"]\nprotected theorem map_one (h : M ≃* N) : h 1 = 1 := map_one h\n\n"}
{"name":"MulEquiv.map_eq_one_iff","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nh : MulEquiv M N\nx : M\n⊢ Iff (Eq (h x) 1) (Eq x 1)","decl":"@[to_additive]\nprotected theorem map_eq_one_iff (h : M ≃* N) {x : M} : h x = 1 ↔ x = 1 :=\n  EmbeddingLike.map_eq_one_iff\n\n"}
{"name":"AddEquiv.map_eq_zero_iff","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nh : AddEquiv M N\nx : M\n⊢ Iff (Eq (h x) 0) (Eq x 0)","decl":"@[to_additive]\nprotected theorem map_eq_one_iff (h : M ≃* N) {x : M} : h x = 1 ↔ x = 1 :=\n  EmbeddingLike.map_eq_one_iff\n\n"}
{"name":"AddEquiv.map_ne_zero_iff","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nh : AddEquiv M N\nx : M\n⊢ Iff (Ne (h x) 0) (Ne x 0)","decl":"@[to_additive]\ntheorem map_ne_one_iff (h : M ≃* N) {x : M} : h x ≠ 1 ↔ x ≠ 1 :=\n  EmbeddingLike.map_ne_one_iff\n\n"}
{"name":"MulEquiv.map_ne_one_iff","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nh : MulEquiv M N\nx : M\n⊢ Iff (Ne (h x) 1) (Ne x 1)","decl":"@[to_additive]\ntheorem map_ne_one_iff (h : M ≃* N) {x : M} : h x ≠ 1 ↔ x ≠ 1 :=\n  EmbeddingLike.map_ne_one_iff\n\n"}
{"name":"AddEquiv.ofBijective_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_9\nN : Type u_10\nF : Type u_11\ninst✝³ : Add M\ninst✝² : Add N\ninst✝¹ : FunLike F M N\ninst✝ : AddHomClass F M N\nf : F\nhf : Function.Bijective ⇑f\na : M\n⊢ Eq ((AddEquiv.ofBijective f hf) a) (f a)","decl":"/-- A bijective `Semigroup` homomorphism is an isomorphism -/\n@[to_additive (attr := simps! apply) \"A bijective `AddSemigroup` homomorphism is an isomorphism\"]\nnoncomputable def ofBijective {M N F} [Mul M] [Mul N] [FunLike F M N] [MulHomClass F M N]\n    (f : F) (hf : Bijective f) : M ≃* N :=\n  { Equiv.ofBijective f hf with map_mul' := map_mul f }\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: simplify `symm_apply` to `surjInv`?\n"}
{"name":"MulEquiv.ofBijective_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_9\nN : Type u_10\nF : Type u_11\ninst✝³ : Mul M\ninst✝² : Mul N\ninst✝¹ : FunLike F M N\ninst✝ : MulHomClass F M N\nf : F\nhf : Function.Bijective ⇑f\na : M\n⊢ Eq ((MulEquiv.ofBijective f hf) a) (f a)","decl":"/-- A bijective `Semigroup` homomorphism is an isomorphism -/\n@[to_additive (attr := simps! apply) \"A bijective `AddSemigroup` homomorphism is an isomorphism\"]\nnoncomputable def ofBijective {M N F} [Mul M] [Mul N] [FunLike F M N] [MulHomClass F M N]\n    (f : F) (hf : Bijective f) : M ≃* N :=\n  { Equiv.ofBijective f hf with map_mul' := map_mul f }\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: simplify `symm_apply` to `surjInv`?\n"}
{"name":"AddEquiv.ofBijective_apply_symm_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nn : N\nf : AddMonoidHom M N\nhf : Function.Bijective ⇑f\n⊢ Eq (f ((AddEquiv.ofBijective f hf).symm n)) n","decl":"@[to_additive (attr := simp)]\ntheorem ofBijective_apply_symm_apply {n : N} (f : M →* N) (hf : Bijective f) :\n    f ((ofBijective f hf).symm n) = n := (ofBijective f hf).apply_symm_apply n\n\n"}
{"name":"MulEquiv.ofBijective_apply_symm_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nn : N\nf : MonoidHom M N\nhf : Function.Bijective ⇑f\n⊢ Eq (f ((MulEquiv.ofBijective f hf).symm n)) n","decl":"@[to_additive (attr := simp)]\ntheorem ofBijective_apply_symm_apply {n : N} (f : M →* N) (hf : Bijective f) :\n    f ((ofBijective f hf).symm n) = n := (ofBijective f hf).apply_symm_apply n\n\n"}
{"name":"MulEquiv.coe_toMonoidHom","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\ne : MulEquiv M N\n⊢ Eq ⇑e.toMonoidHom ⇑e","decl":"@[to_additive (attr := simp)]\ntheorem coe_toMonoidHom (e : M ≃* N) : ⇑e.toMonoidHom = e := rfl\n\n"}
{"name":"AddEquiv.coe_toAddMonoidHom","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\ne : AddEquiv M N\n⊢ Eq ⇑e.toAddMonoidHom ⇑e","decl":"@[to_additive (attr := simp)]\ntheorem coe_toMonoidHom (e : M ≃* N) : ⇑e.toMonoidHom = e := rfl\n\n"}
{"name":"AddEquiv.toAddMonoidHom_eq_coe","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddEquiv M N\n⊢ Eq f.toAddMonoidHom ↑f","decl":"@[to_additive (attr := simp)]\ntheorem toMonoidHom_eq_coe (f : M ≃* N) : f.toMonoidHom = (f : M →* N) :=\n  rfl\n\n"}
{"name":"MulEquiv.toMonoidHom_eq_coe","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MulEquiv M N\n⊢ Eq f.toMonoidHom ↑f","decl":"@[to_additive (attr := simp)]\ntheorem toMonoidHom_eq_coe (f : M ≃* N) : f.toMonoidHom = (f : M →* N) :=\n  rfl\n\n"}
{"name":"MulEquiv.toMonoidHom_injective","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Function.Injective MulEquiv.toMonoidHom","decl":"@[to_additive]\ntheorem toMonoidHom_injective : Injective (toMonoidHom : M ≃* N → M →* N) :=\n  Injective.of_comp (f := DFunLike.coe) DFunLike.coe_injective\n\n"}
{"name":"AddEquiv.toAddMonoidHom_injective","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Function.Injective AddEquiv.toAddMonoidHom","decl":"@[to_additive]\ntheorem toMonoidHom_injective : Injective (toMonoidHom : M ≃* N → M →* N) :=\n  Injective.of_comp (f := DFunLike.coe) DFunLike.coe_injective\n\n"}
{"name":"MulEquiv.map_inv","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"G : Type u_7\nH : Type u_8\ninst✝¹ : Group G\ninst✝ : DivisionMonoid H\nh : MulEquiv G H\nx : G\n⊢ Eq (h (Inv.inv x)) (Inv.inv (h x))","decl":"/-- A multiplicative equivalence of groups preserves inversion. -/\n@[to_additive \"An additive equivalence of additive groups preserves negation.\"]\nprotected theorem map_inv [Group G] [DivisionMonoid H] (h : G ≃* H) (x : G) :\n    h x⁻¹ = (h x)⁻¹ :=\n  map_inv h x\n\n"}
{"name":"AddEquiv.map_neg","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"G : Type u_7\nH : Type u_8\ninst✝¹ : AddGroup G\ninst✝ : SubtractionMonoid H\nh : AddEquiv G H\nx : G\n⊢ Eq (h (Neg.neg x)) (Neg.neg (h x))","decl":"/-- A multiplicative equivalence of groups preserves inversion. -/\n@[to_additive \"An additive equivalence of additive groups preserves negation.\"]\nprotected theorem map_inv [Group G] [DivisionMonoid H] (h : G ≃* H) (x : G) :\n    h x⁻¹ = (h x)⁻¹ :=\n  map_inv h x\n\n"}
{"name":"AddEquiv.map_sub","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"G : Type u_7\nH : Type u_8\ninst✝¹ : AddGroup G\ninst✝ : SubtractionMonoid H\nh : AddEquiv G H\nx y : G\n⊢ Eq (h (HSub.hSub x y)) (HSub.hSub (h x) (h y))","decl":"/-- A multiplicative equivalence of groups preserves division. -/\n@[to_additive \"An additive equivalence of additive groups preserves subtractions.\"]\nprotected theorem map_div [Group G] [DivisionMonoid H] (h : G ≃* H) (x y : G) :\n    h (x / y) = h x / h y :=\n  map_div h x y\n\n"}
{"name":"MulEquiv.map_div","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"G : Type u_7\nH : Type u_8\ninst✝¹ : Group G\ninst✝ : DivisionMonoid H\nh : MulEquiv G H\nx y : G\n⊢ Eq (h (HDiv.hDiv x y)) (HDiv.hDiv (h x) (h y))","decl":"/-- A multiplicative equivalence of groups preserves division. -/\n@[to_additive \"An additive equivalence of additive groups preserves subtractions.\"]\nprotected theorem map_div [Group G] [DivisionMonoid H] (h : G ≃* H) (x y : G) :\n    h (x / y) = h x / h y :=\n  map_div h x y\n\n"}
{"name":"AddHom.toAddEquiv_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\ng : AddHom N M\nh₁ : Eq (g.comp f) (AddHom.id M)\nh₂ : Eq (f.comp g) (AddHom.id N)\n⊢ Eq ⇑(f.toAddEquiv g h₁ h₂) ⇑f","decl":"/-- Given a pair of multiplicative homomorphisms `f`, `g` such that `g.comp f = id` and\n`f.comp g = id`, returns a multiplicative equivalence with `toFun = f` and `invFun = g`. This\nconstructor is useful if the underlying type(s) have specialized `ext` lemmas for multiplicative\nhomomorphisms. -/\n@[to_additive (attr := simps (config := .asFn))\n  \"Given a pair of additive homomorphisms `f`, `g` such that `g.comp f = id` and\n  `f.comp g = id`, returns an additive equivalence with `toFun = f` and `invFun = g`. This\n  constructor is useful if the underlying type(s) have specialized `ext` lemmas for additive\n  homomorphisms.\"]\ndef MulHom.toMulEquiv [Mul M] [Mul N] (f : M →ₙ* N) (g : N →ₙ* M) (h₁ : g.comp f = MulHom.id _)\n    (h₂ : f.comp g = MulHom.id _) : M ≃* N where\n  toFun := f\n  invFun := g\n  left_inv := DFunLike.congr_fun h₁\n  right_inv := DFunLike.congr_fun h₂\n  map_mul' := f.map_mul\n\n"}
{"name":"MulHom.toMulEquiv_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\ng : MulHom N M\nh₁ : Eq (g.comp f) (MulHom.id M)\nh₂ : Eq (f.comp g) (MulHom.id N)\n⊢ Eq ⇑(f.toMulEquiv g h₁ h₂) ⇑f","decl":"/-- Given a pair of multiplicative homomorphisms `f`, `g` such that `g.comp f = id` and\n`f.comp g = id`, returns a multiplicative equivalence with `toFun = f` and `invFun = g`. This\nconstructor is useful if the underlying type(s) have specialized `ext` lemmas for multiplicative\nhomomorphisms. -/\n@[to_additive (attr := simps (config := .asFn))\n  \"Given a pair of additive homomorphisms `f`, `g` such that `g.comp f = id` and\n  `f.comp g = id`, returns an additive equivalence with `toFun = f` and `invFun = g`. This\n  constructor is useful if the underlying type(s) have specialized `ext` lemmas for additive\n  homomorphisms.\"]\ndef MulHom.toMulEquiv [Mul M] [Mul N] (f : M →ₙ* N) (g : N →ₙ* M) (h₁ : g.comp f = MulHom.id _)\n    (h₂ : f.comp g = MulHom.id _) : M ≃* N where\n  toFun := f\n  invFun := g\n  left_inv := DFunLike.congr_fun h₁\n  right_inv := DFunLike.congr_fun h₂\n  map_mul' := f.map_mul\n\n"}
{"name":"AddHom.toAddEquiv_symm_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\ng : AddHom N M\nh₁ : Eq (g.comp f) (AddHom.id M)\nh₂ : Eq (f.comp g) (AddHom.id N)\n⊢ Eq ⇑(f.toAddEquiv g h₁ h₂).symm ⇑g","decl":"/-- Given a pair of multiplicative homomorphisms `f`, `g` such that `g.comp f = id` and\n`f.comp g = id`, returns a multiplicative equivalence with `toFun = f` and `invFun = g`. This\nconstructor is useful if the underlying type(s) have specialized `ext` lemmas for multiplicative\nhomomorphisms. -/\n@[to_additive (attr := simps (config := .asFn))\n  \"Given a pair of additive homomorphisms `f`, `g` such that `g.comp f = id` and\n  `f.comp g = id`, returns an additive equivalence with `toFun = f` and `invFun = g`. This\n  constructor is useful if the underlying type(s) have specialized `ext` lemmas for additive\n  homomorphisms.\"]\ndef MulHom.toMulEquiv [Mul M] [Mul N] (f : M →ₙ* N) (g : N →ₙ* M) (h₁ : g.comp f = MulHom.id _)\n    (h₂ : f.comp g = MulHom.id _) : M ≃* N where\n  toFun := f\n  invFun := g\n  left_inv := DFunLike.congr_fun h₁\n  right_inv := DFunLike.congr_fun h₂\n  map_mul' := f.map_mul\n\n"}
{"name":"MulHom.toMulEquiv_symm_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\ng : MulHom N M\nh₁ : Eq (g.comp f) (MulHom.id M)\nh₂ : Eq (f.comp g) (MulHom.id N)\n⊢ Eq ⇑(f.toMulEquiv g h₁ h₂).symm ⇑g","decl":"/-- Given a pair of multiplicative homomorphisms `f`, `g` such that `g.comp f = id` and\n`f.comp g = id`, returns a multiplicative equivalence with `toFun = f` and `invFun = g`. This\nconstructor is useful if the underlying type(s) have specialized `ext` lemmas for multiplicative\nhomomorphisms. -/\n@[to_additive (attr := simps (config := .asFn))\n  \"Given a pair of additive homomorphisms `f`, `g` such that `g.comp f = id` and\n  `f.comp g = id`, returns an additive equivalence with `toFun = f` and `invFun = g`. This\n  constructor is useful if the underlying type(s) have specialized `ext` lemmas for additive\n  homomorphisms.\"]\ndef MulHom.toMulEquiv [Mul M] [Mul N] (f : M →ₙ* N) (g : N →ₙ* M) (h₁ : g.comp f = MulHom.id _)\n    (h₂ : f.comp g = MulHom.id _) : M ≃* N where\n  toFun := f\n  invFun := g\n  left_inv := DFunLike.congr_fun h₁\n  right_inv := DFunLike.congr_fun h₂\n  map_mul' := f.map_mul\n\n"}
{"name":"AddMonoidHom.toAddEquiv_symm_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\ng : AddMonoidHom N M\nh₁ : Eq (g.comp f) (AddMonoidHom.id M)\nh₂ : Eq (f.comp g) (AddMonoidHom.id N)\n⊢ Eq ⇑(f.toAddEquiv g h₁ h₂).symm ⇑g","decl":"/-- Given a pair of monoid homomorphisms `f`, `g` such that `g.comp f = id` and `f.comp g = id`,\nreturns a multiplicative equivalence with `toFun = f` and `invFun = g`.  This constructor is\nuseful if the underlying type(s) have specialized `ext` lemmas for monoid homomorphisms. -/\n@[to_additive (attr := simps (config := .asFn))\n  \"Given a pair of additive monoid homomorphisms `f`, `g` such that `g.comp f = id`\n  and `f.comp g = id`, returns an additive equivalence with `toFun = f` and `invFun = g`.  This\n  constructor is useful if the underlying type(s) have specialized `ext` lemmas for additive\n  monoid homomorphisms.\"]\ndef MonoidHom.toMulEquiv [MulOneClass M] [MulOneClass N] (f : M →* N) (g : N →* M)\n    (h₁ : g.comp f = MonoidHom.id _) (h₂ : f.comp g = MonoidHom.id _) : M ≃* N where\n  toFun := f\n  invFun := g\n  left_inv := DFunLike.congr_fun h₁\n  right_inv := DFunLike.congr_fun h₂\n  map_mul' := f.map_mul\n\n"}
{"name":"MonoidHom.toMulEquiv_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MonoidHom M N\ng : MonoidHom N M\nh₁ : Eq (g.comp f) (MonoidHom.id M)\nh₂ : Eq (f.comp g) (MonoidHom.id N)\n⊢ Eq ⇑(f.toMulEquiv g h₁ h₂) ⇑f","decl":"/-- Given a pair of monoid homomorphisms `f`, `g` such that `g.comp f = id` and `f.comp g = id`,\nreturns a multiplicative equivalence with `toFun = f` and `invFun = g`.  This constructor is\nuseful if the underlying type(s) have specialized `ext` lemmas for monoid homomorphisms. -/\n@[to_additive (attr := simps (config := .asFn))\n  \"Given a pair of additive monoid homomorphisms `f`, `g` such that `g.comp f = id`\n  and `f.comp g = id`, returns an additive equivalence with `toFun = f` and `invFun = g`.  This\n  constructor is useful if the underlying type(s) have specialized `ext` lemmas for additive\n  monoid homomorphisms.\"]\ndef MonoidHom.toMulEquiv [MulOneClass M] [MulOneClass N] (f : M →* N) (g : N →* M)\n    (h₁ : g.comp f = MonoidHom.id _) (h₂ : f.comp g = MonoidHom.id _) : M ≃* N where\n  toFun := f\n  invFun := g\n  left_inv := DFunLike.congr_fun h₁\n  right_inv := DFunLike.congr_fun h₂\n  map_mul' := f.map_mul\n\n"}
{"name":"AddMonoidHom.toAddEquiv_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\ng : AddMonoidHom N M\nh₁ : Eq (g.comp f) (AddMonoidHom.id M)\nh₂ : Eq (f.comp g) (AddMonoidHom.id N)\n⊢ Eq ⇑(f.toAddEquiv g h₁ h₂) ⇑f","decl":"/-- Given a pair of monoid homomorphisms `f`, `g` such that `g.comp f = id` and `f.comp g = id`,\nreturns a multiplicative equivalence with `toFun = f` and `invFun = g`.  This constructor is\nuseful if the underlying type(s) have specialized `ext` lemmas for monoid homomorphisms. -/\n@[to_additive (attr := simps (config := .asFn))\n  \"Given a pair of additive monoid homomorphisms `f`, `g` such that `g.comp f = id`\n  and `f.comp g = id`, returns an additive equivalence with `toFun = f` and `invFun = g`.  This\n  constructor is useful if the underlying type(s) have specialized `ext` lemmas for additive\n  monoid homomorphisms.\"]\ndef MonoidHom.toMulEquiv [MulOneClass M] [MulOneClass N] (f : M →* N) (g : N →* M)\n    (h₁ : g.comp f = MonoidHom.id _) (h₂ : f.comp g = MonoidHom.id _) : M ≃* N where\n  toFun := f\n  invFun := g\n  left_inv := DFunLike.congr_fun h₁\n  right_inv := DFunLike.congr_fun h₂\n  map_mul' := f.map_mul\n\n"}
{"name":"MonoidHom.toMulEquiv_symm_apply","module":"Mathlib.Algebra.Group.Equiv.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MonoidHom M N\ng : MonoidHom N M\nh₁ : Eq (g.comp f) (MonoidHom.id M)\nh₂ : Eq (f.comp g) (MonoidHom.id N)\n⊢ Eq ⇑(f.toMulEquiv g h₁ h₂).symm ⇑g","decl":"/-- Given a pair of monoid homomorphisms `f`, `g` such that `g.comp f = id` and `f.comp g = id`,\nreturns a multiplicative equivalence with `toFun = f` and `invFun = g`.  This constructor is\nuseful if the underlying type(s) have specialized `ext` lemmas for monoid homomorphisms. -/\n@[to_additive (attr := simps (config := .asFn))\n  \"Given a pair of additive monoid homomorphisms `f`, `g` such that `g.comp f = id`\n  and `f.comp g = id`, returns an additive equivalence with `toFun = f` and `invFun = g`.  This\n  constructor is useful if the underlying type(s) have specialized `ext` lemmas for additive\n  monoid homomorphisms.\"]\ndef MonoidHom.toMulEquiv [MulOneClass M] [MulOneClass N] (f : M →* N) (g : N →* M)\n    (h₁ : g.comp f = MonoidHom.id _) (h₂ : f.comp g = MonoidHom.id _) : M ≃* N where\n  toFun := f\n  invFun := g\n  left_inv := DFunLike.congr_fun h₁\n  right_inv := DFunLike.congr_fun h₂\n  map_mul' := f.map_mul\n\n"}
