{"name":"CategoryTheory.ChosenFiniteProducts.toUnit_unique","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX : C\nf g : Quiver.Hom X CategoryTheory.MonoidalCategoryStruct.tensorUnit\n‚ä¢ Eq f g","decl":"/--\nThis lemma follows from the preexisting `Unique` instance, but\nit is often convenient to use it directly as `apply toUnit_unique` forcing\nlean to do the necessary elaboration.\n-/\nlemma toUnit_unique {X : C} (f g : X ‚ü∂ ùüô_ _) : f = g :=\n  Subsingleton.elim _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.lift_fst","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nT X Y : C\nf : Quiver.Hom T X\ng : Quiver.Hom T Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.lift f g) (CategoryTheory.ChosenFiniteProducts.fst X Y)) f","decl":"@[reassoc (attr := simp)]\nlemma lift_fst {T X Y : C} (f : T ‚ü∂ X) (g : T ‚ü∂ Y) : lift f g ‚â´ fst _ _ = f := by\n  simp [lift, fst]\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.lift_fst_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nT X Y : C\nf : Quiver.Hom T X\ng : Quiver.Hom T Y\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.lift f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst X Y) h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc (attr := simp)]\nlemma lift_fst {T X Y : C} (f : T ‚ü∂ X) (g : T ‚ü∂ Y) : lift f g ‚â´ fst _ _ = f := by\n  simp [lift, fst]\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.lift_snd","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nT X Y : C\nf : Quiver.Hom T X\ng : Quiver.Hom T Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.lift f g) (CategoryTheory.ChosenFiniteProducts.snd X Y)) g","decl":"@[reassoc (attr := simp)]\nlemma lift_snd {T X Y : C} (f : T ‚ü∂ X) (g : T ‚ü∂ Y) : lift f g ‚â´ snd _ _ = g := by\n  simp [lift, snd]\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.lift_snd_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nT X Y : C\nf : Quiver.Hom T X\ng : Quiver.Hom T Y\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.lift f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd X Y) h)) (CategoryTheory.CategoryStruct.comp g h)","decl":"@[reassoc (attr := simp)]\nlemma lift_snd {T X Y : C} (f : T ‚ü∂ X) (g : T ‚ü∂ Y) : lift f g ‚â´ snd _ _ = g := by\n  simp [lift, snd]\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.mono_lift_of_mono_left","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts C\nW X Y : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ CategoryTheory.Mono (CategoryTheory.ChosenFiniteProducts.lift f g)","decl":"instance mono_lift_of_mono_left {W X Y : C} (f : W ‚ü∂ X) (g : W ‚ü∂ Y)\n    [Mono f] : Mono (lift f g) :=\n  mono_of_mono_fac <| lift_fst _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.mono_lift_of_mono_right","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts C\nW X Y : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\ninst‚úù : CategoryTheory.Mono g\n‚ä¢ CategoryTheory.Mono (CategoryTheory.ChosenFiniteProducts.lift f g)","decl":"instance mono_lift_of_mono_right {W X Y : C} (f : W ‚ü∂ X) (g : W ‚ü∂ Y)\n    [Mono g] : Mono (lift f g) :=\n  mono_of_mono_fac <| lift_snd _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.hom_ext_iff","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nT X Y : C\nf g : Quiver.Hom T (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)\n‚ä¢ Iff (Eq f g) (And (Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.ChosenFiniteProducts.fst X Y)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.ChosenFiniteProducts.fst X Y))) (Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.ChosenFiniteProducts.snd X Y)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.ChosenFiniteProducts.snd X Y))))","decl":"@[ext 1050]\nlemma hom_ext {T X Y : C} (f g : T ‚ü∂ X ‚äó Y)\n    (h_fst : f ‚â´ fst _ _ = g ‚â´ fst _ _)\n    (h_snd : f ‚â´ snd _ _ = g ‚â´ snd _ _) :\n    f = g :=\n  (product X Y).isLimit.hom_ext fun ‚ü®j‚ü© => j.recOn h_fst h_snd\n\n-- Similarly to `CategoryTheory.Limits.prod.comp_lift`, we do not make the `assoc` version a simp\n-- lemma\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.hom_ext","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nT X Y : C\nf g : Quiver.Hom T (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)\nh_fst : Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.ChosenFiniteProducts.fst X Y)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.ChosenFiniteProducts.fst X Y))\nh_snd : Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.ChosenFiniteProducts.snd X Y)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.ChosenFiniteProducts.snd X Y))\n‚ä¢ Eq f g","decl":"@[ext 1050]\nlemma hom_ext {T X Y : C} (f g : T ‚ü∂ X ‚äó Y)\n    (h_fst : f ‚â´ fst _ _ = g ‚â´ fst _ _)\n    (h_snd : f ‚â´ snd _ _ = g ‚â´ snd _ _) :\n    f = g :=\n  (product X Y).isLimit.hom_ext fun ‚ü®j‚ü© => j.recOn h_fst h_snd\n\n-- Similarly to `CategoryTheory.Limits.prod.comp_lift`, we do not make the `assoc` version a simp\n-- lemma\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.comp_lift","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nV W X Y : C\nf : Quiver.Hom V W\ng : Quiver.Hom W X\nh : Quiver.Hom W Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.ChosenFiniteProducts.lift g h)) (CategoryTheory.ChosenFiniteProducts.lift (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc, simp]\nlemma comp_lift {V W X Y : C} (f : V ‚ü∂ W) (g : W ‚ü∂ X) (h : W ‚ü∂ Y) :\n    f ‚â´ lift g h = lift (f ‚â´ g) (f ‚â´ h) := by ext <;> simp\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.comp_lift_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nV W X Y : C\nf : Quiver.Hom V W\ng : Quiver.Hom W X\nh‚úù : Quiver.Hom W Y\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.lift g h‚úù) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.lift (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f h‚úù)) h)","decl":"@[reassoc, simp]\nlemma comp_lift {V W X Y : C} (f : V ‚ü∂ W) (g : W ‚ü∂ X) (h : W ‚ü∂ Y) :\n    f ‚â´ lift g h = lift (f ‚â´ g) (f ‚â´ h) := by ext <;> simp\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.lift_fst_snd","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX Y : C\n‚ä¢ Eq (CategoryTheory.ChosenFiniteProducts.lift (CategoryTheory.ChosenFiniteProducts.fst X Y) (CategoryTheory.ChosenFiniteProducts.snd X Y)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))","decl":"@[simp]\nlemma lift_fst_snd {X Y : C} : lift (fst X Y) (snd X Y) = ùüô (X ‚äó Y) := by ext <;> simp\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.tensorHom_fst","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ : C\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom Y‚ÇÅ Y‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) (CategoryTheory.ChosenFiniteProducts.fst X‚ÇÇ Y‚ÇÇ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst X‚ÇÅ Y‚ÇÅ) f)","decl":"@[reassoc (attr := simp)]\nlemma tensorHom_fst {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ : C} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) (g : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) :\n    (f ‚äó g) ‚â´ fst _ _ = fst _ _ ‚â´ f := lift_fst _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.tensorHom_fst_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ : C\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom Y‚ÇÅ Y‚ÇÇ\nZ : C\nh : Quiver.Hom X‚ÇÇ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst X‚ÇÇ Y‚ÇÇ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst X‚ÇÅ Y‚ÇÅ) (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc (attr := simp)]\nlemma tensorHom_fst {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ : C} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) (g : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) :\n    (f ‚äó g) ‚â´ fst _ _ = fst _ _ ‚â´ f := lift_fst _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.tensorHom_snd","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ : C\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom Y‚ÇÅ Y‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) (CategoryTheory.ChosenFiniteProducts.snd X‚ÇÇ Y‚ÇÇ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd X‚ÇÅ Y‚ÇÅ) g)","decl":"@[reassoc (attr := simp)]\nlemma tensorHom_snd {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ : C} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) (g : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) :\n    (f ‚äó g) ‚â´ snd _ _ = snd _ _ ‚â´ g := lift_snd _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.tensorHom_snd_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ : C\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom Y‚ÇÅ Y‚ÇÇ\nZ : C\nh : Quiver.Hom Y‚ÇÇ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd X‚ÇÇ Y‚ÇÇ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd X‚ÇÅ Y‚ÇÅ) (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc (attr := simp)]\nlemma tensorHom_snd {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ : C} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) (g : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) :\n    (f ‚äó g) ‚â´ snd _ _ = snd _ _ ‚â´ g := lift_snd _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.lift_map_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nV W X Y Z‚úù : C\nf : Quiver.Hom V W\ng : Quiver.Hom V X\nh‚úù : Quiver.Hom W Y\nk : Quiver.Hom X Z‚úù\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z‚úù) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.lift f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom h‚úù k) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.lift (CategoryTheory.CategoryStruct.comp f h‚úù) (CategoryTheory.CategoryStruct.comp g k)) h)","decl":"@[reassoc (attr := simp)]\nlemma lift_map {V W X Y Z : C} (f : V ‚ü∂ W) (g : V ‚ü∂ X) (h : W ‚ü∂ Y) (k : X ‚ü∂ Z) :\n    lift f g ‚â´ (h ‚äó k) = lift (f ‚â´ h) (g ‚â´ k) := by ext <;> simp\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.lift_map","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nV W X Y Z : C\nf : Quiver.Hom V W\ng : Quiver.Hom V X\nh : Quiver.Hom W Y\nk : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.lift f g) (CategoryTheory.MonoidalCategoryStruct.tensorHom h k)) (CategoryTheory.ChosenFiniteProducts.lift (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g k))","decl":"@[reassoc (attr := simp)]\nlemma lift_map {V W X Y Z : C} (f : V ‚ü∂ W) (g : V ‚ü∂ X) (h : W ‚ü∂ Y) (k : X ‚ü∂ Z) :\n    lift f g ‚â´ (h ‚äó k) = lift (f ‚â´ h) (g ‚â´ k) := by ext <;> simp\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.lift_fst_comp_snd_comp","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nW X Y Z : C\ng : Quiver.Hom W X\ng' : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.ChosenFiniteProducts.lift (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst W Y) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd W Y) g')) (CategoryTheory.MonoidalCategoryStruct.tensorHom g g')","decl":"@[simp]\nlemma lift_fst_comp_snd_comp {W X Y Z : C} (g : W ‚ü∂ X) (g' : Y ‚ü∂ Z) :\n    lift (fst _ _ ‚â´ g) (snd _ _ ‚â´ g') = g ‚äó g' := by ext <;> simp\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.whiskerLeft_fst_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX Y‚ÇÅ Y‚ÇÇ : C\ng : Quiver.Hom Y‚ÇÅ Y‚ÇÇ\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst X Y‚ÇÇ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst X Y‚ÇÅ) h)","decl":"@[reassoc (attr := simp)]\nlemma whiskerLeft_fst (X : C) {Y‚ÇÅ Y‚ÇÇ : C} (g : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) :\n    (X ‚óÅ g) ‚â´ fst _ _ = fst _ _ :=\n  (tensorHom_fst _ _).trans (by simp)\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.whiskerLeft_fst","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX Y‚ÇÅ Y‚ÇÇ : C\ng : Quiver.Hom Y‚ÇÅ Y‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X g) (CategoryTheory.ChosenFiniteProducts.fst X Y‚ÇÇ)) (CategoryTheory.ChosenFiniteProducts.fst X Y‚ÇÅ)","decl":"@[reassoc (attr := simp)]\nlemma whiskerLeft_fst (X : C) {Y‚ÇÅ Y‚ÇÇ : C} (g : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) :\n    (X ‚óÅ g) ‚â´ fst _ _ = fst _ _ :=\n  (tensorHom_fst _ _).trans (by simp)\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.whiskerLeft_snd","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX Y‚ÇÅ Y‚ÇÇ : C\ng : Quiver.Hom Y‚ÇÅ Y‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X g) (CategoryTheory.ChosenFiniteProducts.snd X Y‚ÇÇ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd X Y‚ÇÅ) g)","decl":"@[reassoc (attr := simp)]\nlemma whiskerLeft_snd (X : C) {Y‚ÇÅ Y‚ÇÇ : C} (g : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) :\n    (X ‚óÅ g) ‚â´ snd _ _ = snd _ _ ‚â´ g :=\n  tensorHom_snd _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.whiskerLeft_snd_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX Y‚ÇÅ Y‚ÇÇ : C\ng : Quiver.Hom Y‚ÇÅ Y‚ÇÇ\nZ : C\nh : Quiver.Hom Y‚ÇÇ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd X Y‚ÇÇ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd X Y‚ÇÅ) (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc (attr := simp)]\nlemma whiskerLeft_snd (X : C) {Y‚ÇÅ Y‚ÇÇ : C} (g : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) :\n    (X ‚óÅ g) ‚â´ snd _ _ = snd _ _ ‚â´ g :=\n  tensorHom_snd _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.whiskerRight_fst","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX‚ÇÅ X‚ÇÇ : C\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\nY : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y) (CategoryTheory.ChosenFiniteProducts.fst X‚ÇÇ Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst X‚ÇÅ Y) f)","decl":"@[reassoc (attr := simp)]\nlemma whiskerRight_fst {X‚ÇÅ X‚ÇÇ : C} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) (Y : C) :\n    (f ‚ñ∑ Y) ‚â´ fst _ _ = fst _ _ ‚â´ f :=\n  tensorHom_fst _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.whiskerRight_fst_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX‚ÇÅ X‚ÇÇ : C\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\nY Z : C\nh : Quiver.Hom X‚ÇÇ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst X‚ÇÇ Y) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst X‚ÇÅ Y) (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc (attr := simp)]\nlemma whiskerRight_fst {X‚ÇÅ X‚ÇÇ : C} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) (Y : C) :\n    (f ‚ñ∑ Y) ‚â´ fst _ _ = fst _ _ ‚â´ f :=\n  tensorHom_fst _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.whiskerRight_snd","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX‚ÇÅ X‚ÇÇ : C\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\nY : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y) (CategoryTheory.ChosenFiniteProducts.snd X‚ÇÇ Y)) (CategoryTheory.ChosenFiniteProducts.snd X‚ÇÅ Y)","decl":"@[reassoc (attr := simp)]\nlemma whiskerRight_snd {X‚ÇÅ X‚ÇÇ : C} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) (Y : C) :\n    (f ‚ñ∑ Y) ‚â´ snd _ _ = snd _ _ :=\n  (tensorHom_snd _ _).trans (by simp)\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.whiskerRight_snd_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX‚ÇÅ X‚ÇÇ : C\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\nY Z : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd X‚ÇÇ Y) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd X‚ÇÅ Y) h)","decl":"@[reassoc (attr := simp)]\nlemma whiskerRight_snd {X‚ÇÅ X‚ÇÇ : C} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) (Y : C) :\n    (f ‚ñ∑ Y) ‚â´ snd _ _ = snd _ _ :=\n  (tensorHom_snd _ _).trans (by simp)\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.associator_hom_fst","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX Y Z : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom (CategoryTheory.ChosenFiniteProducts.fst X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z) (CategoryTheory.ChosenFiniteProducts.fst X Y))","decl":"@[reassoc (attr := simp)]\nlemma associator_hom_fst (X Y Z : C) :\n    (Œ±_ X Y Z).hom ‚â´ fst _ _ = fst _ _ ‚â´ fst _ _ := lift_fst _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.associator_hom_fst_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX Y Z‚úù Z : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z‚úù).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z‚úù)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z‚úù) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst X Y) h))","decl":"@[reassoc (attr := simp)]\nlemma associator_hom_fst (X Y Z : C) :\n    (Œ±_ X Y Z).hom ‚â´ fst _ _ = fst _ _ ‚â´ fst _ _ := lift_fst _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.associator_hom_snd_fst","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX Y Z : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)) (CategoryTheory.ChosenFiniteProducts.fst Y Z))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z) (CategoryTheory.ChosenFiniteProducts.snd X Y))","decl":"@[reassoc (attr := simp)]\nlemma associator_hom_snd_fst (X Y Z : C) :\n    (Œ±_ X Y Z).hom ‚â´ snd _ _ ‚â´ fst _ _ = fst _ _ ‚â´ snd _ _  := by\n  erw [lift_snd_assoc, lift_fst]\n  rfl\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.associator_hom_snd_fst_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX Y Z‚úù Z : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z‚úù).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z‚úù)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst Y Z‚úù) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z‚úù) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd X Y) h))","decl":"@[reassoc (attr := simp)]\nlemma associator_hom_snd_fst (X Y Z : C) :\n    (Œ±_ X Y Z).hom ‚â´ snd _ _ ‚â´ fst _ _ = fst _ _ ‚â´ snd _ _  := by\n  erw [lift_snd_assoc, lift_fst]\n  rfl\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.associator_hom_snd_snd","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX Y Z : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)) (CategoryTheory.ChosenFiniteProducts.snd Y Z))) (CategoryTheory.ChosenFiniteProducts.snd (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z)","decl":"@[reassoc (attr := simp)]\nlemma associator_hom_snd_snd (X Y Z : C) :\n    (Œ±_ X Y Z).hom ‚â´ snd _ _ ‚â´ snd _ _ = snd _ _  := by\n  erw [lift_snd_assoc, lift_snd]\n  rfl\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.associator_hom_snd_snd_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX Y Z‚úù Z : C\nh : Quiver.Hom Z‚úù Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z‚úù).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z‚úù)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd Y Z‚úù) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z‚úù) h)","decl":"@[reassoc (attr := simp)]\nlemma associator_hom_snd_snd (X Y Z : C) :\n    (Œ±_ X Y Z).hom ‚â´ snd _ _ ‚â´ snd _ _ = snd _ _  := by\n  erw [lift_snd_assoc, lift_snd]\n  rfl\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.associator_inv_fst","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX Y Z : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z) (CategoryTheory.ChosenFiniteProducts.fst X Y))) (CategoryTheory.ChosenFiniteProducts.fst X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z))","decl":"@[reassoc (attr := simp)]\nlemma associator_inv_fst (X Y Z : C) :\n    (Œ±_ X Y Z).inv ‚â´ fst _ _ ‚â´ fst _ _ = fst _ _ := by\n  erw [lift_fst_assoc, lift_fst]\n  rfl\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.associator_inv_fst_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX Y Z‚úù Z : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z‚úù).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z‚úù) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst X Y) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z‚úù)) h)","decl":"@[reassoc (attr := simp)]\nlemma associator_inv_fst (X Y Z : C) :\n    (Œ±_ X Y Z).inv ‚â´ fst _ _ ‚â´ fst _ _ = fst _ _ := by\n  erw [lift_fst_assoc, lift_fst]\n  rfl\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.associator_inv_fst_snd_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX Y Z‚úù Z : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z‚úù).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z‚úù) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd X Y) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z‚úù)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst Y Z‚úù) h))","decl":"@[reassoc (attr := simp)]\nlemma associator_inv_fst_snd (X Y Z : C) :\n    (Œ±_ X Y Z).inv ‚â´ fst _ _ ‚â´ snd _ _ = snd _ _ ‚â´ fst _ _ := by\n  erw [lift_fst_assoc, lift_snd]\n  rfl\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.associator_inv_fst_snd","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX Y Z : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z) (CategoryTheory.ChosenFiniteProducts.snd X Y))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)) (CategoryTheory.ChosenFiniteProducts.fst Y Z))","decl":"@[reassoc (attr := simp)]\nlemma associator_inv_fst_snd (X Y Z : C) :\n    (Œ±_ X Y Z).inv ‚â´ fst _ _ ‚â´ snd _ _ = snd _ _ ‚â´ fst _ _ := by\n  erw [lift_fst_assoc, lift_snd]\n  rfl\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.associator_inv_snd_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX Y Z‚úù Z : C\nh : Quiver.Hom Z‚úù Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z‚úù).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z‚úù) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z‚úù)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd Y Z‚úù) h))","decl":"@[reassoc (attr := simp)]\nlemma associator_inv_snd (X Y Z : C) :\n    (Œ±_ X Y Z).inv ‚â´ snd _ _ = snd _ _ ‚â´ snd _ _ := lift_snd _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.associator_inv_snd","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX Y Z : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv (CategoryTheory.ChosenFiniteProducts.snd (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)) (CategoryTheory.ChosenFiniteProducts.snd Y Z))","decl":"@[reassoc (attr := simp)]\nlemma associator_inv_snd (X Y Z : C) :\n    (Œ±_ X Y Z).inv ‚â´ snd _ _ = snd _ _ ‚â´ snd _ _ := lift_snd _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.leftUnitor_inv_fst_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX Z : C\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst CategoryTheory.MonoidalCategoryStruct.tensorUnit X) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.toUnit X) h)","decl":"@[reassoc (attr := simp)]\nlemma leftUnitor_inv_fst (X : C) :\n    (Œª_ X).inv ‚â´ fst _ _ = toUnit _ := toUnit_unique _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.leftUnitor_inv_fst","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv (CategoryTheory.ChosenFiniteProducts.fst CategoryTheory.MonoidalCategoryStruct.tensorUnit X)) (CategoryTheory.ChosenFiniteProducts.toUnit X)","decl":"@[reassoc (attr := simp)]\nlemma leftUnitor_inv_fst (X : C) :\n    (Œª_ X).inv ‚â´ fst _ _ = toUnit _ := toUnit_unique _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.leftUnitor_inv_snd_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX Z : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd CategoryTheory.MonoidalCategoryStruct.tensorUnit X) h)) h","decl":"@[reassoc (attr := simp)]\nlemma leftUnitor_inv_snd (X : C) :\n    (Œª_ X).inv ‚â´ snd _ _ = ùüô X := lift_snd _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.leftUnitor_inv_snd","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv (CategoryTheory.ChosenFiniteProducts.snd CategoryTheory.MonoidalCategoryStruct.tensorUnit X)) (CategoryTheory.CategoryStruct.id X)","decl":"@[reassoc (attr := simp)]\nlemma leftUnitor_inv_snd (X : C) :\n    (Œª_ X).inv ‚â´ snd _ _ = ùüô X := lift_snd _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.rightUnitor_inv_fst_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX Z : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst X CategoryTheory.MonoidalCategoryStruct.tensorUnit) h)) h","decl":"@[reassoc (attr := simp)]\nlemma rightUnitor_inv_fst (X : C) :\n    (œÅ_ X).inv ‚â´ fst _ _ = ùüô X := lift_fst _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.rightUnitor_inv_fst","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv (CategoryTheory.ChosenFiniteProducts.fst X CategoryTheory.MonoidalCategoryStruct.tensorUnit)) (CategoryTheory.CategoryStruct.id X)","decl":"@[reassoc (attr := simp)]\nlemma rightUnitor_inv_fst (X : C) :\n    (œÅ_ X).inv ‚â´ fst _ _ = ùüô X := lift_fst _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.rightUnitor_inv_snd","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv (CategoryTheory.ChosenFiniteProducts.snd X CategoryTheory.MonoidalCategoryStruct.tensorUnit)) (CategoryTheory.ChosenFiniteProducts.toUnit X)","decl":"@[reassoc (attr := simp)]\nlemma rightUnitor_inv_snd (X : C) :\n    (œÅ_ X).inv ‚â´ snd _ _ = toUnit _ := toUnit_unique _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.rightUnitor_inv_snd_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nX Z : C\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd X CategoryTheory.MonoidalCategoryStruct.tensorUnit) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.toUnit X) h)","decl":"@[reassoc (attr := simp)]\nlemma rightUnitor_inv_snd (X : C) :\n    (œÅ_ X).inv ‚â´ snd _ _ = toUnit _ := toUnit_unique _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.instHasFiniteProducts","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\n‚ä¢ CategoryTheory.Limits.HasFiniteProducts C","decl":"instance (priority := 100) : Limits.HasFiniteProducts C :=\n  letI : ‚àÄ (X Y : C), Limits.HasLimit (Limits.pair X Y) := fun _ _ =>\n    .mk <| ChosenFiniteProducts.product _ _\n  letI : Limits.HasBinaryProducts C := Limits.hasBinaryProducts_of_hasLimit_pair _\n  letI : Limits.HasTerminal C := Limits.hasTerminal_of_unique (ùüô_ C)\n  hasFiniteProducts_of_has_binary_and_terminal\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.map_toUnit_comp_terminalCompariso_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA : C\nZ : D\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.ChosenFiniteProducts.toUnit A)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.terminalComparison F) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.toUnit (F.obj A)) h)","decl":"@[reassoc (attr := simp)]\nlemma map_toUnit_comp_terminalCompariso (A : C) :\n    F.map (toUnit A) ‚â´ terminalComparison F = toUnit _ := toUnit_unique _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.map_toUnit_comp_terminalCompariso","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.ChosenFiniteProducts.toUnit A)) (CategoryTheory.ChosenFiniteProducts.terminalComparison F)) (CategoryTheory.ChosenFiniteProducts.toUnit (F.obj A))","decl":"@[reassoc (attr := simp)]\nlemma map_toUnit_comp_terminalCompariso (A : C) :\n    F.map (toUnit A) ‚â´ terminalComparison F = toUnit _ := toUnit_unique _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.preservesLimit_empty_of_isIso_terminalComparison","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.terminalComparison F)\n‚ä¢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Functor.empty C) F","decl":"/-- If `terminalComparison F` is an Iso, then `F` preserves terminal objects. -/\nlemma preservesLimit_empty_of_isIso_terminalComparison [IsIso (terminalComparison F)] :\n    PreservesLimit (Functor.empty.{0} C) F := by\n  apply preservesLimit_of_preserves_limit_cone terminal.isLimit\n  apply isLimitChangeEmptyCone D terminal.isLimit\n  exact asIso (terminalComparison F)|>.symm\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.preservesTerminalIso_hom","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Functor.empty C) F\n‚ä¢ Eq (CategoryTheory.ChosenFiniteProducts.preservesTerminalIso F).hom (CategoryTheory.ChosenFiniteProducts.terminalComparison F)","decl":"@[simp]\nlemma preservesTerminalIso_hom [PreservesLimit (Functor.empty.{0} C) F] :\n    (preservesTerminalIso F).hom = terminalComparison F := toUnit_unique _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.terminalComparison_isIso_of_preservesLimits","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Functor.empty C) F\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.terminalComparison F)","decl":"instance terminalComparison_isIso_of_preservesLimits [PreservesLimit (Functor.empty.{0} C) F] :\n    IsIso (terminalComparison F) := by\n  rw [‚Üê preservesTerminalIso_hom]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparison_fst","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.prodComparison F A B) (CategoryTheory.ChosenFiniteProducts.fst (F.obj A) (F.obj B))) (F.map (CategoryTheory.ChosenFiniteProducts.fst A B))","decl":"@[reassoc (attr := simp)]\ntheorem prodComparison_fst : prodComparison F A B ‚â´ fst _ _ = F.map (fst A B) :=\n  lift_fst _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparison_fst_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B : C\nZ : D\nh : Quiver.Hom (F.obj A) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.prodComparison F A B) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst (F.obj A) (F.obj B)) h)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.ChosenFiniteProducts.fst A B)) h)","decl":"@[reassoc (attr := simp)]\ntheorem prodComparison_fst : prodComparison F A B ‚â´ fst _ _ = F.map (fst A B) :=\n  lift_fst _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparison_snd_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B : C\nZ : D\nh : Quiver.Hom (F.obj B) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.prodComparison F A B) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd (F.obj A) (F.obj B)) h)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.ChosenFiniteProducts.snd A B)) h)","decl":"@[reassoc (attr := simp)]\ntheorem prodComparison_snd : prodComparison F A B ‚â´ snd _ _ = F.map (snd A B) :=\n  lift_snd _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparison_snd","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.prodComparison F A B) (CategoryTheory.ChosenFiniteProducts.snd (F.obj A) (F.obj B))) (F.map (CategoryTheory.ChosenFiniteProducts.snd A B))","decl":"@[reassoc (attr := simp)]\ntheorem prodComparison_snd : prodComparison F A B ‚â´ snd _ _ = F.map (snd A B) :=\n  lift_snd _ _\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.inv_prodComparison_map_fst_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B : C\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)\nZ : D\nh : Quiver.Hom (F.obj A) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.ChosenFiniteProducts.fst A B)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst (F.obj A) (F.obj B)) h)","decl":"@[reassoc (attr := simp)]\ntheorem inv_prodComparison_map_fst [IsIso (prodComparison F A B)] :\n    inv (prodComparison F A B) ‚â´ F.map (fst _ _) = fst _ _ := by simp [IsIso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.inv_prodComparison_map_fst","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B : C\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)) (F.map (CategoryTheory.ChosenFiniteProducts.fst A B))) (CategoryTheory.ChosenFiniteProducts.fst (F.obj A) (F.obj B))","decl":"@[reassoc (attr := simp)]\ntheorem inv_prodComparison_map_fst [IsIso (prodComparison F A B)] :\n    inv (prodComparison F A B) ‚â´ F.map (fst _ _) = fst _ _ := by simp [IsIso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.inv_prodComparison_map_snd_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B : C\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)\nZ : D\nh : Quiver.Hom (F.obj B) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.ChosenFiniteProducts.snd A B)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd (F.obj A) (F.obj B)) h)","decl":"@[reassoc (attr := simp)]\ntheorem inv_prodComparison_map_snd [IsIso (prodComparison F A B)] :\n    inv (prodComparison F A B) ‚â´ F.map (snd _ _) = snd _ _ := by simp [IsIso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.inv_prodComparison_map_snd","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B : C\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)) (F.map (CategoryTheory.ChosenFiniteProducts.snd A B))) (CategoryTheory.ChosenFiniteProducts.snd (F.obj A) (F.obj B))","decl":"@[reassoc (attr := simp)]\ntheorem inv_prodComparison_map_snd [IsIso (prodComparison F A B)] :\n    inv (prodComparison F A B) ‚â´ F.map (snd _ _) = snd _ _ := by simp [IsIso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparison_natural_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B A' B' : C\nf : Quiver.Hom A A'\ng : Quiver.Hom B B'\nZ : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj A') (F.obj B')) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.prodComparison F A' B') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.prodComparison F A B) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) h))","decl":"/-- Naturality of the `prodComparison` morphism in both arguments. -/\n@[reassoc]\ntheorem prodComparison_natural (f : A ‚ü∂ A') (g : B ‚ü∂ B') :\n    F.map (f ‚äó g) ‚â´ prodComparison F A' B' =\n      prodComparison F A B ‚â´ (F.map f ‚äó F.map g) := by\n  apply hom_ext <;>\n  simp only [Category.assoc, prodComparison_fst, tensorHom_fst, prodComparison_fst_assoc,\n    prodComparison_snd, tensorHom_snd, prodComparison_snd_assoc, ‚Üê F.map_comp]\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparison_natural","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B A' B' : C\nf : Quiver.Hom A A'\ng : Quiver.Hom B B'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) (CategoryTheory.ChosenFiniteProducts.prodComparison F A' B')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.prodComparison F A B) (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)))","decl":"/-- Naturality of the `prodComparison` morphism in both arguments. -/\n@[reassoc]\ntheorem prodComparison_natural (f : A ‚ü∂ A') (g : B ‚ü∂ B') :\n    F.map (f ‚äó g) ‚â´ prodComparison F A' B' =\n      prodComparison F A B ‚â´ (F.map f ‚äó F.map g) := by\n  apply hom_ext <;>\n  simp only [Category.assoc, prodComparison_fst, tensorHom_fst, prodComparison_fst_assoc,\n    prodComparison_snd, tensorHom_snd, prodComparison_snd_assoc, ‚Üê F.map_comp]\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparison_natural_whiskerLeft","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B B' : C\ng : Quiver.Hom B B'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A g)) (CategoryTheory.ChosenFiniteProducts.prodComparison F A B')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.prodComparison F A B) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj A) (F.map g)))","decl":"/-- Naturality of the `prodComparison` morphism in the right argument. -/\n@[reassoc]\ntheorem prodComparison_natural_whiskerLeft (g : B ‚ü∂ B') :\n    F.map (A ‚óÅ g) ‚â´ prodComparison F A B' =\n      prodComparison F A B ‚â´ (F.obj A ‚óÅ F.map g) := by\n  rw [‚Üê id_tensorHom, prodComparison_natural, Functor.map_id]\n  rfl\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparison_natural_whiskerLeft_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B B' : C\ng : Quiver.Hom B B'\nZ : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj A) (F.obj B')) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.prodComparison F A B') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.prodComparison F A B) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj A) (F.map g)) h))","decl":"/-- Naturality of the `prodComparison` morphism in the right argument. -/\n@[reassoc]\ntheorem prodComparison_natural_whiskerLeft (g : B ‚ü∂ B') :\n    F.map (A ‚óÅ g) ‚â´ prodComparison F A B' =\n      prodComparison F A B ‚â´ (F.obj A ‚óÅ F.map g) := by\n  rw [‚Üê id_tensorHom, prodComparison_natural, Functor.map_id]\n  rfl\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparison_natural_whiskerRight","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B A' : C\nf : Quiver.Hom A A'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f B)) (CategoryTheory.ChosenFiniteProducts.prodComparison F A' B)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.prodComparison F A B) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj B)))","decl":"/-- Naturality of the `prodComparison` morphism in the left argument. -/\n@[reassoc]\ntheorem prodComparison_natural_whiskerRight (f : A ‚ü∂ A') :\n    F.map (f ‚ñ∑ B) ‚â´ prodComparison F A' B =\n      prodComparison F A B ‚â´ (F.map f ‚ñ∑ F.obj B) := by\n  rw [‚Üê tensorHom_id, prodComparison_natural, Functor.map_id]\n  rfl\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparison_natural_whiskerRight_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B A' : C\nf : Quiver.Hom A A'\nZ : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj A') (F.obj B)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f B)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.prodComparison F A' B) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.prodComparison F A B) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj B)) h))","decl":"/-- Naturality of the `prodComparison` morphism in the left argument. -/\n@[reassoc]\ntheorem prodComparison_natural_whiskerRight (f : A ‚ü∂ A') :\n    F.map (f ‚ñ∑ B) ‚â´ prodComparison F A' B =\n      prodComparison F A B ‚â´ (F.map f ‚ñ∑ F.obj B) := by\n  rw [‚Üê tensorHom_id, prodComparison_natural, Functor.map_id]\n  rfl\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparison_inv_natural","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Å¥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B A' B' : C\ninst‚úù¬π : CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)\nf : Quiver.Hom A A'\ng : Quiver.Hom B B'\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.prodComparison F A' B')\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)) (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) (CategoryTheory.inv (CategoryTheory.ChosenFiniteProducts.prodComparison F A' B')))","decl":"/-- If the product comparison morphism is an iso, its inverse is natural in both argument. -/\n@[reassoc]\ntheorem prodComparison_inv_natural (f : A ‚ü∂ A') (g : B ‚ü∂ B') [IsIso (prodComparison F A' B')] :\n    inv (prodComparison F A B) ‚â´ F.map (f ‚äó g) =\n      (F.map f ‚äó F.map g) ‚â´ inv (prodComparison F A' B') := by\n  rw [IsIso.eq_comp_inv, Category.assoc, IsIso.inv_comp_eq, prodComparison_natural]\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparison_inv_natural_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Å¥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B A' B' : C\ninst‚úù¬π : CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)\nf : Quiver.Hom A A'\ng : Quiver.Hom B B'\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.prodComparison F A' B')\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj A' B')) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.ChosenFiniteProducts.prodComparison F A' B')) h))","decl":"/-- If the product comparison morphism is an iso, its inverse is natural in both argument. -/\n@[reassoc]\ntheorem prodComparison_inv_natural (f : A ‚ü∂ A') (g : B ‚ü∂ B') [IsIso (prodComparison F A' B')] :\n    inv (prodComparison F A B) ‚â´ F.map (f ‚äó g) =\n      (F.map f ‚äó F.map g) ‚â´ inv (prodComparison F A' B') := by\n  rw [IsIso.eq_comp_inv, Category.assoc, IsIso.inv_comp_eq, prodComparison_natural]\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparison_inv_natural_whiskerLeft","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Å¥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B B' : C\ninst‚úù¬π : CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)\ng : Quiver.Hom B B'\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.prodComparison F A B')\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)) (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj A) (F.map g)) (CategoryTheory.inv (CategoryTheory.ChosenFiniteProducts.prodComparison F A B')))","decl":"/-- If the product comparison morphism is an iso, its inverse is natural in the right argument. -/\n@[reassoc]\ntheorem prodComparison_inv_natural_whiskerLeft (g : B ‚ü∂ B') [IsIso (prodComparison F A B')] :\n    inv (prodComparison F A B) ‚â´ F.map (A ‚óÅ g) =\n      (F.obj A ‚óÅ F.map g) ‚â´ inv (prodComparison F A B') := by\n  rw [IsIso.eq_comp_inv, Category.assoc, IsIso.inv_comp_eq, prodComparison_natural_whiskerLeft]\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparison_inv_natural_whiskerLeft_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Å¥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B B' : C\ninst‚úù¬π : CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)\ng : Quiver.Hom B B'\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.prodComparison F A B')\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj A B')) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A g)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj A) (F.map g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.ChosenFiniteProducts.prodComparison F A B')) h))","decl":"/-- If the product comparison morphism is an iso, its inverse is natural in the right argument. -/\n@[reassoc]\ntheorem prodComparison_inv_natural_whiskerLeft (g : B ‚ü∂ B') [IsIso (prodComparison F A B')] :\n    inv (prodComparison F A B) ‚â´ F.map (A ‚óÅ g) =\n      (F.obj A ‚óÅ F.map g) ‚â´ inv (prodComparison F A B') := by\n  rw [IsIso.eq_comp_inv, Category.assoc, IsIso.inv_comp_eq, prodComparison_natural_whiskerLeft]\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparison_inv_natural_whiskerRight_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Å¥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B A' : C\ninst‚úù¬π : CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)\nf : Quiver.Hom A A'\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.prodComparison F A' B)\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj A' B)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f B)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj B)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.ChosenFiniteProducts.prodComparison F A' B)) h))","decl":"/-- If the product comparison morphism is an iso, its inverse is natural in the left argument. -/\n@[reassoc]\ntheorem prodComparison_inv_natural_whiskerRight (f : A ‚ü∂ A') [IsIso (prodComparison F A' B)] :\n    inv (prodComparison F A B) ‚â´ F.map (f ‚ñ∑ B) =\n      (F.map f ‚ñ∑ F.obj B) ‚â´ inv (prodComparison F A' B) := by\n  rw [IsIso.eq_comp_inv, Category.assoc, IsIso.inv_comp_eq, prodComparison_natural_whiskerRight]\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparison_inv_natural_whiskerRight","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Å¥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B A' : C\ninst‚úù¬π : CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)\nf : Quiver.Hom A A'\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.prodComparison F A' B)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)) (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f B))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj B)) (CategoryTheory.inv (CategoryTheory.ChosenFiniteProducts.prodComparison F A' B)))","decl":"/-- If the product comparison morphism is an iso, its inverse is natural in the left argument. -/\n@[reassoc]\ntheorem prodComparison_inv_natural_whiskerRight (f : A ‚ü∂ A') [IsIso (prodComparison F A' B)] :\n    inv (prodComparison F A B) ‚â´ F.map (f ‚ñ∑ B) =\n      (F.map f ‚ñ∑ F.obj B) ‚â´ inv (prodComparison F A' B) := by\n  rw [IsIso.eq_comp_inv, Category.assoc, IsIso.inv_comp_eq, prodComparison_natural_whiskerRight]\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparison_comp","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Å¥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B : C\nE : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} E\ninst‚úù : CategoryTheory.ChosenFiniteProducts E\nG : CategoryTheory.Functor D E\n‚ä¢ Eq (CategoryTheory.ChosenFiniteProducts.prodComparison (F.comp G) A B) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)) (CategoryTheory.ChosenFiniteProducts.prodComparison G (F.obj A) (F.obj B)))","decl":"theorem prodComparison_comp {E : Type u‚ÇÇ} [Category.{v‚ÇÇ} E] [ChosenFiniteProducts E] (G : D ‚•§ E) :\n    prodComparison (F ‚ãô G) A B =\n      G.map (prodComparison F A B) ‚â´ prodComparison G (F.obj A) (F.obj B) := by\n  unfold prodComparison\n  ext <;> simp [‚Üê G.map_comp]\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparison_id","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nA B : C\n‚ä¢ Eq (CategoryTheory.ChosenFiniteProducts.prodComparison (CategoryTheory.Functor.id C) A B) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj A B))","decl":"@[simp]\nlemma prodComparison_id :\n    prodComparison (ùü≠ C) A B = ùüô (A ‚äó B) := lift_fst_snd\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparisonNatTrans_app","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B : C\n‚ä¢ Eq ((CategoryTheory.ChosenFiniteProducts.prodComparisonNatTrans F A).app B) (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)","decl":"/-- The product comparison morphism from `F(A ‚äó -)` to `FA ‚äó F-`, whose components are given by\n`prodComparison`. -/\n@[simps]\ndef prodComparisonNatTrans (A : C) :\n    (curriedTensor C).obj A ‚ãô F ‚ü∂ F ‚ãô (curriedTensor D).obj (F.obj A) where\n  app B := prodComparison F A B\n  naturality x y f := by\n    apply hom_ext <;>\n    simp only [Functor.comp_obj, curriedTensor_obj_obj,\n      Functor.comp_map, curriedTensor_obj_map, Category.assoc, prodComparison_fst, whiskerLeft_fst,\n      prodComparison_snd, prodComparison_snd_assoc, whiskerLeft_snd, ‚Üê F.map_comp]\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparisonNatTrans_comp","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Å¥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA : C\nE : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} E\ninst‚úù : CategoryTheory.ChosenFiniteProducts E\nG : CategoryTheory.Functor D E\n‚ä¢ Eq (CategoryTheory.ChosenFiniteProducts.prodComparisonNatTrans (F.comp G) A) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.ChosenFiniteProducts.prodComparisonNatTrans F A) G) (CategoryTheory.whiskerLeft F (CategoryTheory.ChosenFiniteProducts.prodComparisonNatTrans G (F.obj A))))","decl":"theorem prodComparisonNatTrans_comp {E : Type u‚ÇÇ} [Category.{v‚ÇÇ} E] [ChosenFiniteProducts E]\n    (G : D ‚•§ E) : prodComparisonNatTrans (F ‚ãô G) A =\n      whiskerRight (prodComparisonNatTrans F A) G ‚â´\n        whiskerLeft F (prodComparisonNatTrans G (F.obj A)) := by ext; simp [prodComparison_comp]\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparisonNatTrans_id","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.ChosenFiniteProducts C\nA : C\n‚ä¢ Eq (CategoryTheory.ChosenFiniteProducts.prodComparisonNatTrans (CategoryTheory.Functor.id C) A) (CategoryTheory.CategoryStruct.id (((CategoryTheory.MonoidalCategory.curriedTensor C).obj A).comp (CategoryTheory.Functor.id C)))","decl":"@[simp]\nlemma prodComparisonNatTrans_id :\n    prodComparisonNatTrans (ùü≠ C) A = ùüô _ := by ext; simp\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparisonBifunctorNatTrans_app","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA : C\n‚ä¢ Eq ((CategoryTheory.ChosenFiniteProducts.prodComparisonBifunctorNatTrans F).app A) (CategoryTheory.ChosenFiniteProducts.prodComparisonNatTrans F A)","decl":"/-- The product comparison morphism from `F(- ‚äó -)` to `F- ‚äó F-`, whose components are given by\n`prodComparison`. -/\n@[simps]\ndef prodComparisonBifunctorNatTrans :\n    curriedTensor C ‚ãô (whiskeringRight _ _ _).obj F ‚ü∂\n      F ‚ãô curriedTensor D ‚ãô (whiskeringLeft _ _ _).obj F where\n  app A := prodComparisonNatTrans F A\n  naturality x y f := by\n    ext z\n    apply hom_ext <;> simp [‚Üê Functor.map_comp]\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparisonBifunctorNatTrans_comp","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Å¥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nE : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} E\ninst‚úù : CategoryTheory.ChosenFiniteProducts E\nG : CategoryTheory.Functor D E\n‚ä¢ Eq (CategoryTheory.ChosenFiniteProducts.prodComparisonBifunctorNatTrans (F.comp G)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.ChosenFiniteProducts.prodComparisonBifunctorNatTrans F) ((CategoryTheory.whiskeringRight C D E).obj G)) (CategoryTheory.whiskerLeft F (CategoryTheory.whiskerRight (CategoryTheory.ChosenFiniteProducts.prodComparisonBifunctorNatTrans G) ((CategoryTheory.whiskeringLeft C D E).obj F))))","decl":"theorem prodComparisonBifunctorNatTrans_comp {E : Type u‚ÇÇ} [Category.{v‚ÇÇ} E]\n    [ChosenFiniteProducts E] (G : D ‚•§ E) : prodComparisonBifunctorNatTrans (F ‚ãô G) =\n      whiskerRight (prodComparisonBifunctorNatTrans F) ((whiskeringRight _ _ _).obj G) ‚â´\n        whiskerLeft F (whiskerRight (prodComparisonBifunctorNatTrans G)\n          ((whiskeringLeft _ _ _).obj F)) := by ext; simp [prodComparison_comp]\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.instIsIsoFunctorProdComparisonNatTransOfProdComparison","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA : C\ninst‚úù : ‚àÄ (B : C), CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.prodComparisonNatTrans F A)","decl":"instance (A : C) [‚àÄ B, IsIso (prodComparison F A B)] : IsIso (prodComparisonNatTrans F A) := by\n  letI : ‚àÄ X, IsIso ((prodComparisonNatTrans F A).app X) := by assumption\n  apply NatIso.isIso_of_isIso_app\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.instIsIsoFunctorProdComparisonBifunctorNatTransOfProdComparison","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\ninst‚úù : ‚àÄ (A B : C), CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.prodComparisonBifunctorNatTrans F)","decl":"instance [‚àÄ A B, IsIso (prodComparison F A B)] : IsIso (prodComparisonBifunctorNatTrans F) := by\n  letI : ‚àÄ X, IsIso ((prodComparisonBifunctorNatTrans F).app X) :=\n    fun _ ‚Ü¶ by dsimp; apply NatIso.isIso_of_isIso_app\n  apply NatIso.isIso_of_isIso_app\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparisonIso_hom","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B : C\ninst‚úù : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.pair A B) F\n‚ä¢ Eq (CategoryTheory.ChosenFiniteProducts.prodComparisonIso F A B).hom (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)","decl":"@[simp]\nlemma prodComparisonIso_hom : (prodComparisonIso F A B).hom = prodComparison F A B := by\n  rfl\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.isIso_prodComparison_of_preservesLimit_pair","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B : C\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)","decl":"instance isIso_prodComparison_of_preservesLimit_pair : IsIso (prodComparison F A B) := by\n  rw [‚Üê prodComparisonIso_hom]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparisonNatIso_inv","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA : C\ninst‚úù : ‚àÄ (B : C), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.pair A B) F\n‚ä¢ Eq (CategoryTheory.ChosenFiniteProducts.prodComparisonNatIso F A).inv (CategoryTheory.inv (CategoryTheory.ChosenFiniteProducts.prodComparisonNatTrans F A))","decl":"/-- The natural isomorphism `F(A ‚äó -) ‚âÖ FA ‚äó F-`, provided each `prodComparison F A B` is an\nisomorphism (as `B` changes). -/\n@[simps! hom inv]\nnoncomputable def prodComparisonNatIso (A : C) [‚àÄ B, PreservesLimit (pair A B) F] :\n    (curriedTensor C).obj A ‚ãô F ‚âÖ F ‚ãô (curriedTensor D).obj (F.obj A) :=\n  asIso (prodComparisonNatTrans F A)\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparisonNatIso_hom","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA : C\ninst‚úù : ‚àÄ (B : C), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.pair A B) F\n‚ä¢ Eq (CategoryTheory.ChosenFiniteProducts.prodComparisonNatIso F A).hom (CategoryTheory.ChosenFiniteProducts.prodComparisonNatTrans F A)","decl":"/-- The natural isomorphism `F(A ‚äó -) ‚âÖ FA ‚äó F-`, provided each `prodComparison F A B` is an\nisomorphism (as `B` changes). -/\n@[simps! hom inv]\nnoncomputable def prodComparisonNatIso (A : C) [‚àÄ B, PreservesLimit (pair A B) F] :\n    (curriedTensor C).obj A ‚ãô F ‚âÖ F ‚ãô (curriedTensor D).obj (F.obj A) :=\n  asIso (prodComparisonNatTrans F A)\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparisonBifunctorNatIso_hom","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\ninst‚úù : ‚àÄ (A B : C), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.pair A B) F\n‚ä¢ Eq (CategoryTheory.ChosenFiniteProducts.prodComparisonBifunctorNatIso F).hom (CategoryTheory.ChosenFiniteProducts.prodComparisonBifunctorNatTrans F)","decl":"/-- The natural isomorphism of bifunctors `F(- ‚äó -) ‚âÖ F- ‚äó F-`, provided each\n`prodComparison F A B` is an isomorphism. -/\n@[simps! hom inv]\nnoncomputable def prodComparisonBifunctorNatIso [‚àÄ A B, PreservesLimit (pair A B) F] :\n    curriedTensor C ‚ãô (whiskeringRight _ _ _).obj F ‚âÖ\n      F ‚ãô curriedTensor D ‚ãô (whiskeringLeft _ _ _).obj F :=\n  asIso (prodComparisonBifunctorNatTrans F)\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.prodComparisonBifunctorNatIso_inv","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\ninst‚úù : ‚àÄ (A B : C), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.pair A B) F\n‚ä¢ Eq (CategoryTheory.ChosenFiniteProducts.prodComparisonBifunctorNatIso F).inv (CategoryTheory.inv (CategoryTheory.ChosenFiniteProducts.prodComparisonBifunctorNatTrans F))","decl":"/-- The natural isomorphism of bifunctors `F(- ‚äó -) ‚âÖ F- ‚äó F-`, provided each\n`prodComparison F A B` is an isomorphism. -/\n@[simps! hom inv]\nnoncomputable def prodComparisonBifunctorNatIso [‚àÄ A B, PreservesLimit (pair A B) F] :\n    curriedTensor C ‚ãô (whiskeringRight _ _ _).obj F ‚âÖ\n      F ‚ãô curriedTensor D ‚ãô (whiskeringLeft _ _ _).obj F :=\n  asIso (prodComparisonBifunctorNatTrans F)\n\n"}
{"name":"CategoryTheory.ChosenFiniteProducts.preservesLimit_pair_of_isIso_prodComparison","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B : C\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)\n‚ä¢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.pair A B) F","decl":"/-- If `prodComparison F A B` is an isomorphism, then `F` preserves the limit of `pair A B`. -/\nlemma preservesLimit_pair_of_isIso_prodComparison (A B : C)\n    [IsIso (prodComparison F A B)] :\n    PreservesLimit (pair A B) F := by\n apply preservesLimit_of_preserves_limit_cone (product A B).isLimit\n refine IsLimit.equivOfNatIsoOfIso (pairComp A B F) _\n    ((product (F.obj A) (F.obj B)).cone.extend (prodComparison F A B))\n      (BinaryFan.ext (by exact Iso.refl _) ?_ ?_) |>.invFun\n      (IsLimit.extendIso _ (product (F.obj A) (F.obj B)).isLimit)\n ¬∑ dsimp only [BinaryFan.fst]\n   simp [pairComp, prodComparison, lift, fst]\n ¬∑ dsimp only [BinaryFan.snd]\n   simp [pairComp, prodComparison, lift, snd]\n\n  "}
{"name":"CategoryTheory.ChosenFiniteProducts.preservesLimitsOfShape_discrete_walkingPair_of_isIso_prodComparison","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\ninst‚úù : ‚àÄ (A B : C), CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.prodComparison F A B)\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F","decl":"/-- If `prodComparison F A B` is an isomorphism for all `A B` then `F` preserves limits of shape\n`Discrete (WalkingPair)`. -/\nlemma preservesLimitsOfShape_discrete_walkingPair_of_isIso_prodComparison\n    [‚àÄ A B, IsIso (prodComparison F A B)] : PreservesLimitsOfShape (Discrete WalkingPair) F := by\n  constructor\n  intro K\n  refine @preservesLimit_of_iso_diagram _ _ _ _ _ _ _ _ _ (diagramIsoPair K).symm ?_\n  apply preservesLimit_pair_of_isIso_prodComparison\n\n"}
{"name":"CategoryTheory.Functor.Œ∑_of_chosenFiniteProducts","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Œ∑ F) (CategoryTheory.ChosenFiniteProducts.terminalComparison F)","decl":"lemma Œ∑_of_chosenFiniteProducts : Œ∑ F = terminalComparison F := rfl\n\n"}
{"name":"CategoryTheory.Functor.Œ¥_of_chosenFiniteProducts","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nX Y : C\n‚ä¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Œ¥ F X Y) (CategoryTheory.ChosenFiniteProducts.prodComparison F X Y)","decl":"lemma Œ¥_of_chosenFiniteProducts (X Y : C) : Œ¥ F X Y = prodComparison F X Y := rfl\n\n"}
{"name":"CategoryTheory.Functor.instIsIsoŒ∑","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Functor.empty C) F\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Functor.OplaxMonoidal.Œ∑ F)","decl":"instance : IsIso (Œ∑ F) :=\n  terminalComparison_isIso_of_preservesLimits F\n\n"}
{"name":"CategoryTheory.Functor.instIsIsoŒ¥","module":"Mathlib.CategoryTheory.ChosenFiniteProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nA B : C\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Functor.OplaxMonoidal.Œ¥ F A B)","decl":"instance (A B : C) : IsIso (Œ¥ F A B) :=\n  isIso_prodComparison_of_preservesLimit_pair F A B\n\n"}
