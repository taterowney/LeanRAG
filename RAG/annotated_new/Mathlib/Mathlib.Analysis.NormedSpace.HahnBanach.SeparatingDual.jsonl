{"name":"separatingDual_def","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"R : Type u_1\nV : Type u_2\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup V\ninst✝² : TopologicalSpace V\ninst✝¹ : TopologicalSpace R\ninst✝ : Module R V\n⊢ Iff (SeparatingDual R V) (∀ (x : V), Ne x 0 → Exists fun f => Ne (f x) 0)","decl":"/-- When `E` is a topological module over a topological ring `R`, the class `SeparatingDual R E`\nregisters that continuous linear forms on `E` separate points of `E`. -/\n@[mk_iff separatingDual_def]\nclass SeparatingDual (R V : Type*) [Ring R] [AddCommGroup V] [TopologicalSpace V]\n    [TopologicalSpace R] [Module R V] : Prop where\n  /-- Any nonzero vector can be mapped by a continuous linear map to a nonzero scalar. -/\n  exists_ne_zero' : ∀ (x : V), x ≠ 0 → ∃ f : V →L[R] R, f x ≠ 0\n\n"}
{"name":"SeparatingDual.exists_ne_zero'","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"R : Type u_1\nV : Type u_2\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup V\ninst✝² : TopologicalSpace V\ninst✝¹ : TopologicalSpace R\ninst✝ : Module R V\nself : SeparatingDual R V\nx : V\na✝ : Ne x 0\n⊢ Exists fun f => Ne (f x) 0","decl":"/-- When `E` is a topological module over a topological ring `R`, the class `SeparatingDual R E`\nregisters that continuous linear forms on `E` separate points of `E`. -/\n@[mk_iff separatingDual_def]\nclass SeparatingDual (R V : Type*) [Ring R] [AddCommGroup V] [TopologicalSpace V]\n    [TopologicalSpace R] [Module R V] : Prop where\n  /-- Any nonzero vector can be mapped by a continuous linear map to a nonzero scalar. -/\n  exists_ne_zero' : ∀ (x : V), x ≠ 0 → ∃ f : V →L[R] R, f x ≠ 0\n\n"}
{"name":"instSeparatingDualRealOfTopologicalAddGroupOfContinuousSMulOfLocallyConvexSpaceOfT1Space","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"E : Type u_1\ninst✝⁶ : TopologicalSpace E\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : TopologicalAddGroup E\ninst✝³ : Module Real E\ninst✝² : ContinuousSMul Real E\ninst✝¹ : LocallyConvexSpace Real E\ninst✝ : T1Space E\n⊢ SeparatingDual Real E","decl":"instance {E : Type*} [TopologicalSpace E] [AddCommGroup E] [TopologicalAddGroup E]\n    [Module ℝ E] [ContinuousSMul ℝ E] [LocallyConvexSpace ℝ E] [T1Space E] : SeparatingDual ℝ E :=\n  ⟨fun x hx ↦ by\n    rcases geometric_hahn_banach_point_point hx.symm with ⟨f, hf⟩\n    simp only [map_zero] at hf\n    exact ⟨f, hf.ne'⟩⟩\n\n"}
{"name":"instSeparatingDual","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"E : Type u_1\n𝕜 : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\n⊢ SeparatingDual 𝕜 E","decl":"instance {E 𝕜 : Type*} [RCLike 𝕜] [NormedAddCommGroup E] [NormedSpace 𝕜 E] : SeparatingDual 𝕜 E :=\n  ⟨fun x hx ↦ by\n    rcases exists_dual_vector 𝕜 x hx with ⟨f, -, hf⟩\n    refine ⟨f, ?_⟩\n    simpa [hf] using hx⟩\n\n"}
{"name":"SeparatingDual.exists_ne_zero","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"R : Type u_1\nV : Type u_2\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup V\ninst✝³ : TopologicalSpace V\ninst✝² : TopologicalSpace R\ninst✝¹ : Module R V\ninst✝ : SeparatingDual R V\nx : V\nhx : Ne x 0\n⊢ Exists fun f => Ne (f x) 0","decl":"lemma exists_ne_zero {x : V} (hx : x ≠ 0) :\n    ∃ f : V →L[R] R, f x ≠ 0 :=\n  exists_ne_zero' x hx\n\n"}
{"name":"SeparatingDual.exists_separating_of_ne","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"R : Type u_1\nV : Type u_2\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup V\ninst✝³ : TopologicalSpace V\ninst✝² : TopologicalSpace R\ninst✝¹ : Module R V\ninst✝ : SeparatingDual R V\nx y : V\nh : Ne x y\n⊢ Exists fun f => Ne (f x) (f y)","decl":"theorem exists_separating_of_ne {x y : V} (h : x ≠ y) :\n    ∃ f : V →L[R] R, f x ≠ f y := by\n  rcases exists_ne_zero (R := R) (sub_ne_zero_of_ne h) with ⟨f, hf⟩\n  exact ⟨f, by simpa [sub_ne_zero] using hf⟩\n\n"}
{"name":"SeparatingDual.t1Space","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"R : Type u_1\nV : Type u_2\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : TopologicalSpace V\ninst✝³ : TopologicalSpace R\ninst✝² : Module R V\ninst✝¹ : SeparatingDual R V\ninst✝ : T1Space R\n⊢ T1Space V","decl":"protected theorem t1Space [T1Space R] : T1Space V := by\n  apply t1Space_iff_exists_open.2 (fun x y hxy ↦ ?_)\n  rcases exists_separating_of_ne (R := R) hxy with ⟨f, hf⟩\n  exact ⟨f ⁻¹' {f y}ᶜ, isOpen_compl_singleton.preimage f.continuous, hf, by simp⟩\n\n"}
{"name":"SeparatingDual.t2Space","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"R : Type u_1\nV : Type u_2\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : TopologicalSpace V\ninst✝³ : TopologicalSpace R\ninst✝² : Module R V\ninst✝¹ : SeparatingDual R V\ninst✝ : T2Space R\n⊢ T2Space V","decl":"protected theorem t2Space [T2Space R] : T2Space V := by\n  apply (t2Space_iff _).2 (fun {x} {y} hxy ↦ ?_)\n  rcases exists_separating_of_ne (R := R) hxy with ⟨f, hf⟩\n  exact separated_by_continuous f.continuous hf\n\n"}
{"name":"separatingDual_iff_injective","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"R : Type u_1\nV : Type u_2\ninst✝⁵ : Field R\ninst✝⁴ : AddCommGroup V\ninst✝³ : TopologicalSpace R\ninst✝² : TopologicalSpace V\ninst✝¹ : TopologicalRing R\ninst✝ : Module R V\n⊢ Iff (SeparatingDual R V) (Function.Injective ⇑(ContinuousLinearMap.coeLM R).flip)","decl":"theorem _root_.separatingDual_iff_injective : SeparatingDual R V ↔\n    Function.Injective (ContinuousLinearMap.coeLM (R := R) R (M := V) (N₃ := R)).flip := by\n  simp_rw [separatingDual_def, Ne, injective_iff_map_eq_zero]\n  congrm ∀ v, ?_\n  rw [not_imp_comm, LinearMap.ext_iff]\n  push_neg; rfl\n\n"}
{"name":"SeparatingDual.dualMap_surjective_iff","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"R : Type u_1\nV : Type u_2\ninst✝⁹ : Field R\ninst✝⁸ : AddCommGroup V\ninst✝⁷ : TopologicalSpace R\ninst✝⁶ : TopologicalSpace V\ninst✝⁵ : TopologicalRing R\ninst✝⁴ : Module R V\ninst✝³ : SeparatingDual R V\nW : Type u_3\ninst✝² : AddCommGroup W\ninst✝¹ : Module R W\ninst✝ : FiniteDimensional R W\nf : LinearMap (RingHom.id R) W V\n⊢ Iff (Function.Surjective (Function.comp (⇑f.dualMap) ContinuousLinearMap.toLinearMap)) (Function.Injective ⇑f)","decl":"open Function in\n/-- Given a finite-dimensional subspace `W` of a space `V` with separating dual, any\n  linear functional on `W` extends to a continuous linear functional on `V`.\n  This is stated more generally for an injective linear map from `W` to `V`. -/\ntheorem dualMap_surjective_iff {W} [AddCommGroup W] [Module R W] [FiniteDimensional R W]\n    {f : W →ₗ[R] V} : Surjective (f.dualMap ∘ ContinuousLinearMap.toLinearMap) ↔ Injective f := by\n  constructor <;> intro hf\n  · exact LinearMap.dualMap_surjective_iff.mp hf.of_comp\n  have := (separatingDual_iff_injective.mp ‹_›).comp hf\n  rw [← LinearMap.coe_comp] at this\n  exact LinearMap.flip_surjective_iff₁.mpr this\n\n"}
{"name":"SeparatingDual.exists_eq_one","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"R : Type u_1\nV : Type u_2\ninst✝⁶ : Field R\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : TopologicalSpace R\ninst✝³ : TopologicalSpace V\ninst✝² : TopologicalRing R\ninst✝¹ : Module R V\ninst✝ : SeparatingDual R V\nx : V\nhx : Ne x 0\n⊢ Exists fun f => Eq (f x) 1","decl":"lemma exists_eq_one {x : V} (hx : x ≠ 0) :\n    ∃ f : V →L[R] R, f x = 1 := by\n  rcases exists_ne_zero (R := R) hx with ⟨f, hf⟩\n  exact ⟨(f x)⁻¹ • f, inv_mul_cancel₀ hf⟩\n\n"}
{"name":"SeparatingDual.exists_eq_one_ne_zero_of_ne_zero_pair","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"R : Type u_1\nV : Type u_2\ninst✝⁶ : Field R\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : TopologicalSpace R\ninst✝³ : TopologicalSpace V\ninst✝² : TopologicalRing R\ninst✝¹ : Module R V\ninst✝ : SeparatingDual R V\nx y : V\nhx : Ne x 0\nhy : Ne y 0\n⊢ Exists fun f => And (Eq (f x) 1) (Ne (f y) 0)","decl":"theorem exists_eq_one_ne_zero_of_ne_zero_pair {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) :\n    ∃ f : V →L[R] R, f x = 1 ∧ f y ≠ 0 := by\n  obtain ⟨u, ux⟩ : ∃ u : V →L[R] R, u x = 1 := exists_eq_one hx\n  rcases ne_or_eq (u y) 0 with uy|uy\n  · exact ⟨u, ux, uy⟩\n  obtain ⟨v, vy⟩ : ∃ v : V →L[R] R, v y = 1 := exists_eq_one hy\n  rcases ne_or_eq (v x) 0 with vx|vx\n  · exact ⟨(v x)⁻¹ • v, inv_mul_cancel₀ vx, show (v x)⁻¹ * v y ≠ 0 by simp [vx, vy]⟩\n  · exact ⟨u + v, by simp [ux, vx], by simp [uy, vy]⟩\n\n"}
{"name":"SeparatingDual.exists_continuousLinearEquiv_apply_eq","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"R : Type u_1\nV : Type u_2\ninst✝⁸ : Field R\ninst✝⁷ : AddCommGroup V\ninst✝⁶ : TopologicalSpace R\ninst✝⁵ : TopologicalSpace V\ninst✝⁴ : TopologicalRing R\ninst✝³ : Module R V\ninst✝² : SeparatingDual R V\ninst✝¹ : TopologicalAddGroup V\ninst✝ : ContinuousSMul R V\nx y : V\nhx : Ne x 0\nhy : Ne y 0\n⊢ Exists fun A => Eq (A x) y","decl":"/-- In a topological vector space with separating dual, the group of continuous linear equivalences\nacts transitively on the set of nonzero vectors: given two nonzero vectors `x` and `y`, there\nexists `A : V ≃L[R] V` mapping `x` to `y`. -/\ntheorem exists_continuousLinearEquiv_apply_eq [ContinuousSMul R V]\n    {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) :\n    ∃ A : V ≃L[R] V, A x = y := by\n  obtain ⟨G, Gx, Gy⟩ : ∃ G : V →L[R] R, G x = 1 ∧ G y ≠ 0 :=\n    exists_eq_one_ne_zero_of_ne_zero_pair hx hy\n  let A : V ≃L[R] V :=\n  { toFun := fun z ↦ z + G z • (y - x)\n    invFun := fun z ↦ z + ((G y) ⁻¹ * G z) • (x - y)\n    map_add' := fun a b ↦ by simp [add_smul]; abel\n    map_smul' := by simp [smul_smul]\n    left_inv := fun z ↦ by\n      simp only [id_eq, eq_mpr_eq_cast, RingHom.id_apply, smul_eq_mul, AddHom.toFun_eq_coe,\n        -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to change `map_smulₛₗ` into `map_smulₛₗ _`\n        AddHom.coe_mk, map_add, map_smulₛₗ _, map_sub, Gx, mul_sub, mul_one, add_sub_cancel]\n      rw [mul_comm (G z), ← mul_assoc, inv_mul_cancel₀ Gy]\n      simp only [smul_sub, one_mul]\n      abel\n    right_inv := fun z ↦ by\n        -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to change `map_smulₛₗ` into `map_smulₛₗ _`\n      simp only [map_add, map_smulₛₗ _, map_mul, map_inv₀, RingHom.id_apply, map_sub, Gx,\n        smul_eq_mul, mul_sub, mul_one]\n      rw [mul_comm _ (G y), ← mul_assoc, mul_inv_cancel₀ Gy]\n      simp only [smul_sub, one_mul, add_sub_cancel]\n      abel\n    continuous_toFun := continuous_id.add (G.continuous.smul continuous_const)\n    continuous_invFun :=\n      continuous_id.add ((continuous_const.mul G.continuous).smul continuous_const) }\n  exact ⟨A, show x + G x • (y - x) = y by simp [Gx]⟩\n\n"}
{"name":"SeparatingDual.completeSpace_of_completeSpace_continuousLinearMap","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"𝕜 : Type u_3\nE : Type u_4\nF : Type u_5\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace 𝕜 E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\ninst✝² : SeparatingDual 𝕜 E\ninst✝¹ : Nontrivial E\ninst✝ : CompleteSpace (ContinuousLinearMap (RingHom.id 𝕜) E F)\n⊢ CompleteSpace F","decl":"/-- If a space of linear maps from `E` to `F` is complete, and `E` is nontrivial, then `F` is\ncomplete. -/\nlemma completeSpace_of_completeSpace_continuousLinearMap [CompleteSpace (E →L[𝕜] F)] :\n    CompleteSpace F := by\n  refine Metric.complete_of_cauchySeq_tendsto fun f hf => ?_\n  obtain ⟨v, hv⟩ : ∃ (v : E), v ≠ 0 := exists_ne 0\n  obtain ⟨φ, hφ⟩ : ∃ φ : E →L[𝕜] 𝕜, φ v = 1 := exists_eq_one hv\n  let g : ℕ → (E →L[𝕜] F) := fun n ↦ ContinuousLinearMap.smulRightL 𝕜 E F φ (f n)\n  have : CauchySeq g := (ContinuousLinearMap.smulRightL 𝕜 E F φ).lipschitz.cauchySeq_comp hf\n  obtain ⟨a, ha⟩ : ∃ a, Tendsto g atTop (𝓝 a) := cauchy_iff_exists_le_nhds.mp this\n  refine ⟨a v, ?_⟩\n  have : Tendsto (fun n ↦ g n v) atTop (𝓝 (a v)) := by\n    have : Continuous (fun (i : E →L[𝕜] F) ↦ i v) := by fun_prop\n    exact (this.tendsto _).comp ha\n  simpa [g, ContinuousLinearMap.smulRightL, hφ]\n\n"}
{"name":"SeparatingDual.completeSpace_continuousLinearMap_iff","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"𝕜 : Type u_3\nE : Type u_4\nF : Type u_5\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : SeparatingDual 𝕜 E\ninst✝ : Nontrivial E\n⊢ Iff (CompleteSpace (ContinuousLinearMap (RingHom.id 𝕜) E F)) (CompleteSpace F)","decl":"lemma completeSpace_continuousLinearMap_iff :\n    CompleteSpace (E →L[𝕜] F) ↔ CompleteSpace F :=\n  ⟨fun _h ↦ completeSpace_of_completeSpace_continuousLinearMap 𝕜 E F, fun _h ↦ inferInstance⟩\n\n"}
{"name":"SeparatingDual.completeSpace_of_completeSpace_continuousMultilinearMap","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"𝕜 : Type u_3\nF : Type u_5\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace 𝕜 F\nι : Type u_6\ninst✝⁴ : Finite ι\nM : ι → Type u_7\ninst✝³ : (i : ι) → NormedAddCommGroup (M i)\ninst✝² : (i : ι) → NormedSpace 𝕜 (M i)\ninst✝¹ : ∀ (i : ι), SeparatingDual 𝕜 (M i)\ninst✝ : CompleteSpace (ContinuousMultilinearMap 𝕜 M F)\nm : (i : ι) → M i\nhm : ∀ (i : ι), Ne (m i) 0\n⊢ CompleteSpace F","decl":"/-- If a space of multilinear maps from `Π i, E i` to `F` is complete, and each `E i` has a nonzero\nelement, then `F` is complete. -/\nlemma completeSpace_of_completeSpace_continuousMultilinearMap\n    [CompleteSpace (ContinuousMultilinearMap 𝕜 M F)]\n    {m : ∀ i, M i} (hm : ∀ i, m i ≠ 0) : CompleteSpace F := by\n  refine Metric.complete_of_cauchySeq_tendsto fun f hf => ?_\n  have : ∀ i, ∃ φ : M i →L[𝕜] 𝕜, φ (m i) = 1 := fun i ↦ exists_eq_one (hm i)\n  choose φ hφ using this\n  cases nonempty_fintype ι\n  let g : ℕ → (ContinuousMultilinearMap 𝕜 M F) := fun n ↦\n    compContinuousLinearMapL φ\n    (ContinuousMultilinearMap.smulRightL 𝕜 _ F ((ContinuousMultilinearMap.mkPiAlgebra 𝕜 ι 𝕜)) (f n))\n  have : CauchySeq g := by\n    refine (ContinuousLinearMap.lipschitz _).cauchySeq_comp ?_\n    exact (ContinuousLinearMap.lipschitz _).cauchySeq_comp hf\n  obtain ⟨a, ha⟩ : ∃ a, Tendsto g atTop (𝓝 a) := cauchy_iff_exists_le_nhds.mp this\n  refine ⟨a m, ?_⟩\n  have : Tendsto (fun n ↦ g n m) atTop (𝓝 (a m)) := ((continuous_eval_const _).tendsto _).comp ha\n  simpa [g, hφ]\n\n"}
{"name":"SeparatingDual.completeSpace_continuousMultilinearMap_iff","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"𝕜 : Type u_3\nF : Type u_5\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nι : Type u_6\ninst✝³ : Finite ι\nM : ι → Type u_7\ninst✝² : (i : ι) → NormedAddCommGroup (M i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (M i)\ninst✝ : ∀ (i : ι), SeparatingDual 𝕜 (M i)\nm : (i : ι) → M i\nhm : ∀ (i : ι), Ne (m i) 0\n⊢ Iff (CompleteSpace (ContinuousMultilinearMap 𝕜 M F)) (CompleteSpace F)","decl":"lemma completeSpace_continuousMultilinearMap_iff {m : ∀ i, M i} (hm : ∀ i, m i ≠ 0) :\n    CompleteSpace (ContinuousMultilinearMap 𝕜 M F) ↔ CompleteSpace F :=\n  ⟨fun _h ↦ completeSpace_of_completeSpace_continuousMultilinearMap 𝕜 F hm, fun _h ↦ inferInstance⟩\n\n"}
