{"name":"separatingDual_def","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"R : Type u_1\nV : Type u_2\ninstâœâ´ : Ring R\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : TopologicalSpace V\ninstâœÂ¹ : TopologicalSpace R\ninstâœ : Module R V\nâŠ¢ Iff (SeparatingDual R V) (âˆ€ (x : V), Ne x 0 â†’ Exists fun f => Ne (f x) 0)","decl":"/-- When `E` is a topological module over a topological ring `R`, the class `SeparatingDual R E`\nregisters that continuous linear forms on `E` separate points of `E`. -/\n@[mk_iff separatingDual_def]\nclass SeparatingDual (R V : Type*) [Ring R] [AddCommGroup V] [TopologicalSpace V]\n    [TopologicalSpace R] [Module R V] : Prop where\n  /-- Any nonzero vector can be mapped by a continuous linear map to a nonzero scalar. -/\n  exists_ne_zero' : âˆ€ (x : V), x â‰  0 â†’ âˆƒ f : V â†’L[R] R, f x â‰  0\n\n"}
{"name":"SeparatingDual.exists_ne_zero'","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"R : Type u_1\nV : Type u_2\ninstâœâ´ : Ring R\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : TopologicalSpace V\ninstâœÂ¹ : TopologicalSpace R\ninstâœ : Module R V\nself : SeparatingDual R V\nx : V\naâœ : Ne x 0\nâŠ¢ Exists fun f => Ne (f x) 0","decl":"/-- When `E` is a topological module over a topological ring `R`, the class `SeparatingDual R E`\nregisters that continuous linear forms on `E` separate points of `E`. -/\n@[mk_iff separatingDual_def]\nclass SeparatingDual (R V : Type*) [Ring R] [AddCommGroup V] [TopologicalSpace V]\n    [TopologicalSpace R] [Module R V] : Prop where\n  /-- Any nonzero vector can be mapped by a continuous linear map to a nonzero scalar. -/\n  exists_ne_zero' : âˆ€ (x : V), x â‰  0 â†’ âˆƒ f : V â†’L[R] R, f x â‰  0\n\n"}
{"name":"instSeparatingDualRealOfTopologicalAddGroupOfContinuousSMulOfLocallyConvexSpaceOfT1Space","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"E : Type u_1\ninstâœâ¶ : TopologicalSpace E\ninstâœâµ : AddCommGroup E\ninstâœâ´ : TopologicalAddGroup E\ninstâœÂ³ : Module Real E\ninstâœÂ² : ContinuousSMul Real E\ninstâœÂ¹ : LocallyConvexSpace Real E\ninstâœ : T1Space E\nâŠ¢ SeparatingDual Real E","decl":"instance {E : Type*} [TopologicalSpace E] [AddCommGroup E] [TopologicalAddGroup E]\n    [Module â„ E] [ContinuousSMul â„ E] [LocallyConvexSpace â„ E] [T1Space E] : SeparatingDual â„ E :=\n  âŸ¨fun x hx â†¦ by\n    rcases geometric_hahn_banach_point_point hx.symm with âŸ¨f, hfâŸ©\n    simp only [map_zero] at hf\n    exact âŸ¨f, hf.ne'âŸ©âŸ©\n\n"}
{"name":"instSeparatingDual","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"E : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nâŠ¢ SeparatingDual ğ•œ E","decl":"instance {E ğ•œ : Type*} [RCLike ğ•œ] [NormedAddCommGroup E] [NormedSpace ğ•œ E] : SeparatingDual ğ•œ E :=\n  âŸ¨fun x hx â†¦ by\n    rcases exists_dual_vector ğ•œ x hx with âŸ¨f, -, hfâŸ©\n    refine âŸ¨f, ?_âŸ©\n    simpa [hf] using hxâŸ©\n\n"}
{"name":"SeparatingDual.exists_ne_zero","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"R : Type u_1\nV : Type u_2\ninstâœâµ : Ring R\ninstâœâ´ : AddCommGroup V\ninstâœÂ³ : TopologicalSpace V\ninstâœÂ² : TopologicalSpace R\ninstâœÂ¹ : Module R V\ninstâœ : SeparatingDual R V\nx : V\nhx : Ne x 0\nâŠ¢ Exists fun f => Ne (f x) 0","decl":"lemma exists_ne_zero {x : V} (hx : x â‰  0) :\n    âˆƒ f : V â†’L[R] R, f x â‰  0 :=\n  exists_ne_zero' x hx\n\n"}
{"name":"SeparatingDual.exists_separating_of_ne","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"R : Type u_1\nV : Type u_2\ninstâœâµ : Ring R\ninstâœâ´ : AddCommGroup V\ninstâœÂ³ : TopologicalSpace V\ninstâœÂ² : TopologicalSpace R\ninstâœÂ¹ : Module R V\ninstâœ : SeparatingDual R V\nx y : V\nh : Ne x y\nâŠ¢ Exists fun f => Ne (f x) (f y)","decl":"theorem exists_separating_of_ne {x y : V} (h : x â‰  y) :\n    âˆƒ f : V â†’L[R] R, f x â‰  f y := by\n  rcases exists_ne_zero (R := R) (sub_ne_zero_of_ne h) with âŸ¨f, hfâŸ©\n  exact âŸ¨f, by simpa [sub_ne_zero] using hfâŸ©\n\n"}
{"name":"SeparatingDual.t1Space","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"R : Type u_1\nV : Type u_2\ninstâœâ¶ : Ring R\ninstâœâµ : AddCommGroup V\ninstâœâ´ : TopologicalSpace V\ninstâœÂ³ : TopologicalSpace R\ninstâœÂ² : Module R V\ninstâœÂ¹ : SeparatingDual R V\ninstâœ : T1Space R\nâŠ¢ T1Space V","decl":"protected theorem t1Space [T1Space R] : T1Space V := by\n  apply t1Space_iff_exists_open.2 (fun x y hxy â†¦ ?_)\n  rcases exists_separating_of_ne (R := R) hxy with âŸ¨f, hfâŸ©\n  exact âŸ¨f â»Â¹' {f y}á¶œ, isOpen_compl_singleton.preimage f.continuous, hf, by simpâŸ©\n\n"}
{"name":"SeparatingDual.t2Space","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"R : Type u_1\nV : Type u_2\ninstâœâ¶ : Ring R\ninstâœâµ : AddCommGroup V\ninstâœâ´ : TopologicalSpace V\ninstâœÂ³ : TopologicalSpace R\ninstâœÂ² : Module R V\ninstâœÂ¹ : SeparatingDual R V\ninstâœ : T2Space R\nâŠ¢ T2Space V","decl":"protected theorem t2Space [T2Space R] : T2Space V := by\n  apply (t2Space_iff _).2 (fun {x} {y} hxy â†¦ ?_)\n  rcases exists_separating_of_ne (R := R) hxy with âŸ¨f, hfâŸ©\n  exact separated_by_continuous f.continuous hf\n\n"}
{"name":"separatingDual_iff_injective","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"R : Type u_1\nV : Type u_2\ninstâœâµ : Field R\ninstâœâ´ : AddCommGroup V\ninstâœÂ³ : TopologicalSpace R\ninstâœÂ² : TopologicalSpace V\ninstâœÂ¹ : TopologicalRing R\ninstâœ : Module R V\nâŠ¢ Iff (SeparatingDual R V) (Function.Injective â‡‘(ContinuousLinearMap.coeLM R).flip)","decl":"theorem _root_.separatingDual_iff_injective : SeparatingDual R V â†”\n    Function.Injective (ContinuousLinearMap.coeLM (R := R) R (M := V) (Nâ‚ƒ := R)).flip := by\n  simp_rw [separatingDual_def, Ne, injective_iff_map_eq_zero]\n  congrm âˆ€ v, ?_\n  rw [not_imp_comm, LinearMap.ext_iff]\n  push_neg; rfl\n\n"}
{"name":"SeparatingDual.dualMap_surjective_iff","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"R : Type u_1\nV : Type u_2\ninstâœâ¹ : Field R\ninstâœâ¸ : AddCommGroup V\ninstâœâ· : TopologicalSpace R\ninstâœâ¶ : TopologicalSpace V\ninstâœâµ : TopologicalRing R\ninstâœâ´ : Module R V\ninstâœÂ³ : SeparatingDual R V\nW : Type u_3\ninstâœÂ² : AddCommGroup W\ninstâœÂ¹ : Module R W\ninstâœ : FiniteDimensional R W\nf : LinearMap (RingHom.id R) W V\nâŠ¢ Iff (Function.Surjective (Function.comp (â‡‘f.dualMap) ContinuousLinearMap.toLinearMap)) (Function.Injective â‡‘f)","decl":"open Function in\n/-- Given a finite-dimensional subspace `W` of a space `V` with separating dual, any\n  linear functional on `W` extends to a continuous linear functional on `V`.\n  This is stated more generally for an injective linear map from `W` to `V`. -/\ntheorem dualMap_surjective_iff {W} [AddCommGroup W] [Module R W] [FiniteDimensional R W]\n    {f : W â†’â‚—[R] V} : Surjective (f.dualMap âˆ˜ ContinuousLinearMap.toLinearMap) â†” Injective f := by\n  constructor <;> intro hf\n  Â· exact LinearMap.dualMap_surjective_iff.mp hf.of_comp\n  have := (separatingDual_iff_injective.mp â€¹_â€º).comp hf\n  rw [â† LinearMap.coe_comp] at this\n  exact LinearMap.flip_surjective_iffâ‚.mpr this\n\n"}
{"name":"SeparatingDual.exists_eq_one","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"R : Type u_1\nV : Type u_2\ninstâœâ¶ : Field R\ninstâœâµ : AddCommGroup V\ninstâœâ´ : TopologicalSpace R\ninstâœÂ³ : TopologicalSpace V\ninstâœÂ² : TopologicalRing R\ninstâœÂ¹ : Module R V\ninstâœ : SeparatingDual R V\nx : V\nhx : Ne x 0\nâŠ¢ Exists fun f => Eq (f x) 1","decl":"lemma exists_eq_one {x : V} (hx : x â‰  0) :\n    âˆƒ f : V â†’L[R] R, f x = 1 := by\n  rcases exists_ne_zero (R := R) hx with âŸ¨f, hfâŸ©\n  exact âŸ¨(f x)â»Â¹ â€¢ f, inv_mul_cancelâ‚€ hfâŸ©\n\n"}
{"name":"SeparatingDual.exists_eq_one_ne_zero_of_ne_zero_pair","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"R : Type u_1\nV : Type u_2\ninstâœâ¶ : Field R\ninstâœâµ : AddCommGroup V\ninstâœâ´ : TopologicalSpace R\ninstâœÂ³ : TopologicalSpace V\ninstâœÂ² : TopologicalRing R\ninstâœÂ¹ : Module R V\ninstâœ : SeparatingDual R V\nx y : V\nhx : Ne x 0\nhy : Ne y 0\nâŠ¢ Exists fun f => And (Eq (f x) 1) (Ne (f y) 0)","decl":"theorem exists_eq_one_ne_zero_of_ne_zero_pair {x y : V} (hx : x â‰  0) (hy : y â‰  0) :\n    âˆƒ f : V â†’L[R] R, f x = 1 âˆ§ f y â‰  0 := by\n  obtain âŸ¨u, uxâŸ© : âˆƒ u : V â†’L[R] R, u x = 1 := exists_eq_one hx\n  rcases ne_or_eq (u y) 0 with uy|uy\n  Â· exact âŸ¨u, ux, uyâŸ©\n  obtain âŸ¨v, vyâŸ© : âˆƒ v : V â†’L[R] R, v y = 1 := exists_eq_one hy\n  rcases ne_or_eq (v x) 0 with vx|vx\n  Â· exact âŸ¨(v x)â»Â¹ â€¢ v, inv_mul_cancelâ‚€ vx, show (v x)â»Â¹ * v y â‰  0 by simp [vx, vy]âŸ©\n  Â· exact âŸ¨u + v, by simp [ux, vx], by simp [uy, vy]âŸ©\n\n"}
{"name":"SeparatingDual.exists_continuousLinearEquiv_apply_eq","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"R : Type u_1\nV : Type u_2\ninstâœâ¸ : Field R\ninstâœâ· : AddCommGroup V\ninstâœâ¶ : TopologicalSpace R\ninstâœâµ : TopologicalSpace V\ninstâœâ´ : TopologicalRing R\ninstâœÂ³ : Module R V\ninstâœÂ² : SeparatingDual R V\ninstâœÂ¹ : TopologicalAddGroup V\ninstâœ : ContinuousSMul R V\nx y : V\nhx : Ne x 0\nhy : Ne y 0\nâŠ¢ Exists fun A => Eq (A x) y","decl":"/-- In a topological vector space with separating dual, the group of continuous linear equivalences\nacts transitively on the set of nonzero vectors: given two nonzero vectors `x` and `y`, there\nexists `A : V â‰ƒL[R] V` mapping `x` to `y`. -/\ntheorem exists_continuousLinearEquiv_apply_eq [ContinuousSMul R V]\n    {x y : V} (hx : x â‰  0) (hy : y â‰  0) :\n    âˆƒ A : V â‰ƒL[R] V, A x = y := by\n  obtain âŸ¨G, Gx, GyâŸ© : âˆƒ G : V â†’L[R] R, G x = 1 âˆ§ G y â‰  0 :=\n    exists_eq_one_ne_zero_of_ne_zero_pair hx hy\n  let A : V â‰ƒL[R] V :=\n  { toFun := fun z â†¦ z + G z â€¢ (y - x)\n    invFun := fun z â†¦ z + ((G y) â»Â¹ * G z) â€¢ (x - y)\n    map_add' := fun a b â†¦ by simp [add_smul]; abel\n    map_smul' := by simp [smul_smul]\n    left_inv := fun z â†¦ by\n      simp only [id_eq, eq_mpr_eq_cast, RingHom.id_apply, smul_eq_mul, AddHom.toFun_eq_coe,\n        -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to change `map_smulâ‚›â‚—` into `map_smulâ‚›â‚— _`\n        AddHom.coe_mk, map_add, map_smulâ‚›â‚— _, map_sub, Gx, mul_sub, mul_one, add_sub_cancel]\n      rw [mul_comm (G z), â† mul_assoc, inv_mul_cancelâ‚€ Gy]\n      simp only [smul_sub, one_mul]\n      abel\n    right_inv := fun z â†¦ by\n        -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to change `map_smulâ‚›â‚—` into `map_smulâ‚›â‚— _`\n      simp only [map_add, map_smulâ‚›â‚— _, map_mul, map_invâ‚€, RingHom.id_apply, map_sub, Gx,\n        smul_eq_mul, mul_sub, mul_one]\n      rw [mul_comm _ (G y), â† mul_assoc, mul_inv_cancelâ‚€ Gy]\n      simp only [smul_sub, one_mul, add_sub_cancel]\n      abel\n    continuous_toFun := continuous_id.add (G.continuous.smul continuous_const)\n    continuous_invFun :=\n      continuous_id.add ((continuous_const.mul G.continuous).smul continuous_const) }\n  exact âŸ¨A, show x + G x â€¢ (y - x) = y by simp [Gx]âŸ©\n\n"}
{"name":"SeparatingDual.completeSpace_of_completeSpace_continuousLinearMap","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"ğ•œ : Type u_3\nE : Type u_4\nF : Type u_5\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\ninstâœÂ² : SeparatingDual ğ•œ E\ninstâœÂ¹ : Nontrivial E\ninstâœ : CompleteSpace (ContinuousLinearMap (RingHom.id ğ•œ) E F)\nâŠ¢ CompleteSpace F","decl":"/-- If a space of linear maps from `E` to `F` is complete, and `E` is nontrivial, then `F` is\ncomplete. -/\nlemma completeSpace_of_completeSpace_continuousLinearMap [CompleteSpace (E â†’L[ğ•œ] F)] :\n    CompleteSpace F := by\n  refine Metric.complete_of_cauchySeq_tendsto fun f hf => ?_\n  obtain âŸ¨v, hvâŸ© : âˆƒ (v : E), v â‰  0 := exists_ne 0\n  obtain âŸ¨Ï†, hÏ†âŸ© : âˆƒ Ï† : E â†’L[ğ•œ] ğ•œ, Ï† v = 1 := exists_eq_one hv\n  let g : â„• â†’ (E â†’L[ğ•œ] F) := fun n â†¦ ContinuousLinearMap.smulRightL ğ•œ E F Ï† (f n)\n  have : CauchySeq g := (ContinuousLinearMap.smulRightL ğ•œ E F Ï†).lipschitz.cauchySeq_comp hf\n  obtain âŸ¨a, haâŸ© : âˆƒ a, Tendsto g atTop (ğ“ a) := cauchy_iff_exists_le_nhds.mp this\n  refine âŸ¨a v, ?_âŸ©\n  have : Tendsto (fun n â†¦ g n v) atTop (ğ“ (a v)) := by\n    have : Continuous (fun (i : E â†’L[ğ•œ] F) â†¦ i v) := by fun_prop\n    exact (this.tendsto _).comp ha\n  simpa [g, ContinuousLinearMap.smulRightL, hÏ†]\n\n"}
{"name":"SeparatingDual.completeSpace_continuousLinearMap_iff","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"ğ•œ : Type u_3\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : SeparatingDual ğ•œ E\ninstâœ : Nontrivial E\nâŠ¢ Iff (CompleteSpace (ContinuousLinearMap (RingHom.id ğ•œ) E F)) (CompleteSpace F)","decl":"lemma completeSpace_continuousLinearMap_iff :\n    CompleteSpace (E â†’L[ğ•œ] F) â†” CompleteSpace F :=\n  âŸ¨fun _h â†¦ completeSpace_of_completeSpace_continuousLinearMap ğ•œ E F, fun _h â†¦ inferInstanceâŸ©\n\n"}
{"name":"SeparatingDual.completeSpace_of_completeSpace_continuousMultilinearMap","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"ğ•œ : Type u_3\nF : Type u_5\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ F\nÎ¹ : Type u_6\ninstâœâ´ : Finite Î¹\nM : Î¹ â†’ Type u_7\ninstâœÂ³ : (i : Î¹) â†’ NormedAddCommGroup (M i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (M i)\ninstâœÂ¹ : âˆ€ (i : Î¹), SeparatingDual ğ•œ (M i)\ninstâœ : CompleteSpace (ContinuousMultilinearMap ğ•œ M F)\nm : (i : Î¹) â†’ M i\nhm : âˆ€ (i : Î¹), Ne (m i) 0\nâŠ¢ CompleteSpace F","decl":"/-- If a space of multilinear maps from `Î  i, E i` to `F` is complete, and each `E i` has a nonzero\nelement, then `F` is complete. -/\nlemma completeSpace_of_completeSpace_continuousMultilinearMap\n    [CompleteSpace (ContinuousMultilinearMap ğ•œ M F)]\n    {m : âˆ€ i, M i} (hm : âˆ€ i, m i â‰  0) : CompleteSpace F := by\n  refine Metric.complete_of_cauchySeq_tendsto fun f hf => ?_\n  have : âˆ€ i, âˆƒ Ï† : M i â†’L[ğ•œ] ğ•œ, Ï† (m i) = 1 := fun i â†¦ exists_eq_one (hm i)\n  choose Ï† hÏ† using this\n  cases nonempty_fintype Î¹\n  let g : â„• â†’ (ContinuousMultilinearMap ğ•œ M F) := fun n â†¦\n    compContinuousLinearMapL Ï†\n    (ContinuousMultilinearMap.smulRightL ğ•œ _ F ((ContinuousMultilinearMap.mkPiAlgebra ğ•œ Î¹ ğ•œ)) (f n))\n  have : CauchySeq g := by\n    refine (ContinuousLinearMap.lipschitz _).cauchySeq_comp ?_\n    exact (ContinuousLinearMap.lipschitz _).cauchySeq_comp hf\n  obtain âŸ¨a, haâŸ© : âˆƒ a, Tendsto g atTop (ğ“ a) := cauchy_iff_exists_le_nhds.mp this\n  refine âŸ¨a m, ?_âŸ©\n  have : Tendsto (fun n â†¦ g n m) atTop (ğ“ (a m)) := ((continuous_eval_const _).tendsto _).comp ha\n  simpa [g, hÏ†]\n\n"}
{"name":"SeparatingDual.completeSpace_continuousMultilinearMap_iff","module":"Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual","initialProofState":"ğ•œ : Type u_3\nF : Type u_5\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nÎ¹ : Type u_6\ninstâœÂ³ : Finite Î¹\nM : Î¹ â†’ Type u_7\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (M i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (M i)\ninstâœ : âˆ€ (i : Î¹), SeparatingDual ğ•œ (M i)\nm : (i : Î¹) â†’ M i\nhm : âˆ€ (i : Î¹), Ne (m i) 0\nâŠ¢ Iff (CompleteSpace (ContinuousMultilinearMap ğ•œ M F)) (CompleteSpace F)","decl":"lemma completeSpace_continuousMultilinearMap_iff {m : âˆ€ i, M i} (hm : âˆ€ i, m i â‰  0) :\n    CompleteSpace (ContinuousMultilinearMap ğ•œ M F) â†” CompleteSpace F :=\n  âŸ¨fun _h â†¦ completeSpace_of_completeSpace_continuousMultilinearMap ğ•œ F hm, fun _h â†¦ inferInstanceâŸ©\n\n"}
