{"name":"ProbabilityTheory.moment_zero","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\np : Nat\nμ : MeasureTheory.Measure Ω\nhp : Ne p 0\n⊢ Eq (ProbabilityTheory.moment 0 p μ) 0","decl":"@[simp]\ntheorem moment_zero (hp : p ≠ 0) : moment 0 p μ = 0 := by\n  simp only [moment, hp, zero_pow, Ne, not_false_iff, Pi.zero_apply, integral_const,\n    smul_eq_mul, mul_zero, integral_zero]\n\n"}
{"name":"ProbabilityTheory.moment_zero_measure","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\np : Nat\n⊢ Eq (ProbabilityTheory.moment X p 0) 0","decl":"@[simp]\nlemma moment_zero_measure : moment X p (0 : Measure Ω) = 0 := by simp [moment]\n\n"}
{"name":"ProbabilityTheory.centralMoment_zero","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\np : Nat\nμ : MeasureTheory.Measure Ω\nhp : Ne p 0\n⊢ Eq (ProbabilityTheory.centralMoment 0 p μ) 0","decl":"@[simp]\ntheorem centralMoment_zero (hp : p ≠ 0) : centralMoment 0 p μ = 0 := by\n  simp only [centralMoment, hp, Pi.zero_apply, integral_const, smul_eq_mul,\n    mul_zero, zero_sub, Pi.pow_apply, Pi.neg_apply, neg_zero, zero_pow, Ne, not_false_iff]\n\n"}
{"name":"ProbabilityTheory.centralMoment_zero_measure","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\np : Nat\n⊢ Eq (ProbabilityTheory.centralMoment X p 0) 0","decl":"@[simp]\nlemma centralMoment_zero_measure : centralMoment X p (0 : Measure Ω) = 0 := by\n  simp [centralMoment]\n\n"}
{"name":"ProbabilityTheory.centralMoment_one'","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nh_int : MeasureTheory.Integrable X μ\n⊢ Eq (ProbabilityTheory.centralMoment X 1 μ) (HMul.hMul (HSub.hSub 1 (μ Set.univ).toReal) (MeasureTheory.integral μ fun x => X x))","decl":"theorem centralMoment_one' [IsFiniteMeasure μ] (h_int : Integrable X μ) :\n    centralMoment X 1 μ = (1 - (μ Set.univ).toReal) * μ[X] := by\n  simp only [centralMoment, Pi.sub_apply, pow_one]\n  rw [integral_sub h_int (integrable_const _)]\n  simp only [sub_mul, integral_const, smul_eq_mul, one_mul]\n\n"}
{"name":"ProbabilityTheory.centralMoment_one","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsZeroOrProbabilityMeasure μ\n⊢ Eq (ProbabilityTheory.centralMoment X 1 μ) 0","decl":"@[simp]\ntheorem centralMoment_one [IsZeroOrProbabilityMeasure μ] : centralMoment X 1 μ = 0 := by\n  rcases eq_zero_or_isProbabilityMeasure μ with rfl | h\n  · simp [centralMoment]\n  by_cases h_int : Integrable X μ\n  · rw [centralMoment_one' h_int]\n    simp only [measure_univ, ENNReal.one_toReal, sub_self, zero_mul]\n  · simp only [centralMoment, Pi.sub_apply, pow_one]\n    have : ¬Integrable (fun x => X x - integral μ X) μ := by\n      refine fun h_sub => h_int ?_\n      have h_add : X = (fun x => X x - integral μ X) + fun _ => integral μ X := by ext1 x; simp\n      rw [h_add]\n      fun_prop\n    rw [integral_undef this]\n\n"}
{"name":"ProbabilityTheory.centralMoment_two_eq_variance","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nhX : AEMeasurable X μ\n⊢ Eq (ProbabilityTheory.centralMoment X 2 μ) (ProbabilityTheory.variance X μ)","decl":"lemma centralMoment_two_eq_variance (hX : AEMeasurable X μ) : centralMoment X 2 μ = variance X μ :=\n  (variance_eq_integral hX).symm\n\n"}
{"name":"ProbabilityTheory.mgf_zero_fun","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nt : Real\n⊢ Eq (ProbabilityTheory.mgf 0 μ t) (μ Set.univ).toReal","decl":"@[simp]\ntheorem mgf_zero_fun : mgf 0 μ t = (μ Set.univ).toReal := by\n  simp only [mgf, Pi.zero_apply, mul_zero, exp_zero, integral_const, smul_eq_mul, mul_one]\n\n"}
{"name":"ProbabilityTheory.cgf_zero_fun","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nt : Real\n⊢ Eq (ProbabilityTheory.cgf 0 μ t) (Real.log (μ Set.univ).toReal)","decl":"@[simp]\ntheorem cgf_zero_fun : cgf 0 μ t = log (μ Set.univ).toReal := by simp only [cgf, mgf_zero_fun]\n\n"}
{"name":"ProbabilityTheory.mgf_zero_measure","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nt : Real\n⊢ Eq (ProbabilityTheory.mgf X 0 t) 0","decl":"@[simp]\ntheorem mgf_zero_measure : mgf X (0 : Measure Ω) t = 0 := by simp only [mgf, integral_zero_measure]\n\n"}
{"name":"ProbabilityTheory.cgf_zero_measure","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nt : Real\n⊢ Eq (ProbabilityTheory.cgf X 0 t) 0","decl":"@[simp]\ntheorem cgf_zero_measure : cgf X (0 : Measure Ω) t = 0 := by\n  simp only [cgf, log_zero, mgf_zero_measure]\n\n"}
{"name":"ProbabilityTheory.mgf_const'","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nt c : Real\n⊢ Eq (ProbabilityTheory.mgf (fun x => c) μ t) (HMul.hMul (μ Set.univ).toReal (Real.exp (HMul.hMul t c)))","decl":"@[simp]\ntheorem mgf_const' (c : ℝ) : mgf (fun _ => c) μ t = (μ Set.univ).toReal * exp (t * c) := by\n  simp only [mgf, integral_const, smul_eq_mul]\n\n"}
{"name":"ProbabilityTheory.mgf_const","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nt c : Real\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\n⊢ Eq (ProbabilityTheory.mgf (fun x => c) μ t) (Real.exp (HMul.hMul t c))","decl":"theorem mgf_const (c : ℝ) [IsProbabilityMeasure μ] : mgf (fun _ => c) μ t = exp (t * c) := by\n  simp only [mgf_const', measure_univ, ENNReal.one_toReal, one_mul]\n\n"}
{"name":"ProbabilityTheory.cgf_const'","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nt : Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhμ : Ne μ 0\nc : Real\n⊢ Eq (ProbabilityTheory.cgf (fun x => c) μ t) (HAdd.hAdd (Real.log (μ Set.univ).toReal) (HMul.hMul t c))","decl":"@[simp]\ntheorem cgf_const' [IsFiniteMeasure μ] (hμ : μ ≠ 0) (c : ℝ) :\n    cgf (fun _ => c) μ t = log (μ Set.univ).toReal + t * c := by\n  simp only [cgf, mgf_const']\n  rw [log_mul _ (exp_pos _).ne']\n  · rw [log_exp _]\n  · rw [Ne, ENNReal.toReal_eq_zero_iff, Measure.measure_univ_eq_zero]\n    simp only [hμ, measure_ne_top μ Set.univ, or_self_iff, not_false_iff]\n\n"}
{"name":"ProbabilityTheory.cgf_const","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nt : Real\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nc : Real\n⊢ Eq (ProbabilityTheory.cgf (fun x => c) μ t) (HMul.hMul t c)","decl":"@[simp]\ntheorem cgf_const [IsProbabilityMeasure μ] (c : ℝ) : cgf (fun _ => c) μ t = t * c := by\n  simp only [cgf, mgf_const, log_exp]\n\n"}
{"name":"ProbabilityTheory.mgf_zero'","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\n⊢ Eq (ProbabilityTheory.mgf X μ 0) (μ Set.univ).toReal","decl":"@[simp]\ntheorem mgf_zero' : mgf X μ 0 = (μ Set.univ).toReal := by\n  simp only [mgf, zero_mul, exp_zero, integral_const, smul_eq_mul, mul_one]\n\n"}
{"name":"ProbabilityTheory.mgf_zero","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\n⊢ Eq (ProbabilityTheory.mgf X μ 0) 1","decl":"theorem mgf_zero [IsProbabilityMeasure μ] : mgf X μ 0 = 1 := by\n  simp only [mgf_zero', measure_univ, ENNReal.one_toReal]\n\n"}
{"name":"ProbabilityTheory.cgf_zero'","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\n⊢ Eq (ProbabilityTheory.cgf X μ 0) (Real.log (μ Set.univ).toReal)","decl":"theorem cgf_zero' : cgf X μ 0 = log (μ Set.univ).toReal := by simp only [cgf, mgf_zero']\n\n"}
{"name":"ProbabilityTheory.cgf_zero","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsZeroOrProbabilityMeasure μ\n⊢ Eq (ProbabilityTheory.cgf X μ 0) 0","decl":"@[simp]\ntheorem cgf_zero [IsZeroOrProbabilityMeasure μ] : cgf X μ 0 = 0 := by\n  rcases eq_zero_or_isProbabilityMeasure μ with rfl | h <;> simp [cgf_zero']\n\n"}
{"name":"ProbabilityTheory.mgf_undef","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nt : Real\nhX : Not (MeasureTheory.Integrable (fun ω => Real.exp (HMul.hMul t (X ω))) μ)\n⊢ Eq (ProbabilityTheory.mgf X μ t) 0","decl":"theorem mgf_undef (hX : ¬Integrable (fun ω => exp (t * X ω)) μ) : mgf X μ t = 0 := by\n  simp only [mgf, integral_undef hX]\n\n"}
{"name":"ProbabilityTheory.cgf_undef","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nt : Real\nhX : Not (MeasureTheory.Integrable (fun ω => Real.exp (HMul.hMul t (X ω))) μ)\n⊢ Eq (ProbabilityTheory.cgf X μ t) 0","decl":"theorem cgf_undef (hX : ¬Integrable (fun ω => exp (t * X ω)) μ) : cgf X μ t = 0 := by\n  simp only [cgf, mgf_undef hX, log_zero]\n\n"}
{"name":"ProbabilityTheory.mgf_nonneg","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nt : Real\n⊢ LE.le 0 (ProbabilityTheory.mgf X μ t)","decl":"theorem mgf_nonneg : 0 ≤ mgf X μ t := by\n  unfold mgf; positivity\n\n"}
{"name":"ProbabilityTheory.mgf_pos'","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nt : Real\nhμ : Ne μ 0\nh_int_X : MeasureTheory.Integrable (fun ω => Real.exp (HMul.hMul t (X ω))) μ\n⊢ LT.lt 0 (ProbabilityTheory.mgf X μ t)","decl":"theorem mgf_pos' (hμ : μ ≠ 0) (h_int_X : Integrable (fun ω => exp (t * X ω)) μ) :\n    0 < mgf X μ t := by\n  simp_rw [mgf]\n  have : ∫ x : Ω, exp (t * X x) ∂μ = ∫ x : Ω in Set.univ, exp (t * X x) ∂μ := by\n    simp only [Measure.restrict_univ]\n  rw [this, setIntegral_pos_iff_support_of_nonneg_ae _ _]\n  · have h_eq_univ : (Function.support fun x : Ω => exp (t * X x)) = Set.univ := by\n      ext1 x\n      simp only [Function.mem_support, Set.mem_univ, iff_true]\n      exact (exp_pos _).ne'\n    rw [h_eq_univ, Set.inter_univ _]\n    refine Ne.bot_lt ?_\n    simp only [hμ, ENNReal.bot_eq_zero, Ne, Measure.measure_univ_eq_zero, not_false_iff]\n  · filter_upwards with x\n    rw [Pi.zero_apply]\n    exact (exp_pos _).le\n  · rwa [integrableOn_univ]\n\n"}
{"name":"ProbabilityTheory.mgf_pos","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nt : Real\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nh_int_X : MeasureTheory.Integrable (fun ω => Real.exp (HMul.hMul t (X ω))) μ\n⊢ LT.lt 0 (ProbabilityTheory.mgf X μ t)","decl":"theorem mgf_pos [IsProbabilityMeasure μ] (h_int_X : Integrable (fun ω => exp (t * X ω)) μ) :\n    0 < mgf X μ t :=\n  mgf_pos' (IsProbabilityMeasure.ne_zero μ) h_int_X\n\n"}
{"name":"ProbabilityTheory.mgf_pos_iff","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nt : Real\nhμ : NeZero μ\n⊢ Iff (LT.lt 0 (ProbabilityTheory.mgf X μ t)) (MeasureTheory.Integrable (fun ω => Real.exp (HMul.hMul t (X ω))) μ)","decl":"lemma mgf_pos_iff [hμ : NeZero μ] :\n    0 < mgf X μ t ↔ Integrable (fun ω ↦ exp (t * X ω)) μ := by\n  refine ⟨fun h ↦ ?_, fun h ↦ mgf_pos' hμ.out h⟩\n  contrapose! h with h\n  simp [mgf_undef h]\n\n"}
{"name":"ProbabilityTheory.exp_cgf_of_neZero","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nt : Real\nhμ : NeZero μ\nhX : MeasureTheory.Integrable (fun ω => Real.exp (HMul.hMul t (X ω))) μ\n⊢ Eq (Real.exp (ProbabilityTheory.cgf X μ t)) (ProbabilityTheory.mgf X μ t)","decl":"lemma exp_cgf_of_neZero [hμ : NeZero μ] (hX : Integrable (fun ω ↦ exp (t * X ω)) μ) :\n    exp (cgf X μ t) = mgf X μ t := by rw [cgf, exp_log (mgf_pos' hμ.out hX)]\n\n"}
{"name":"ProbabilityTheory.exp_cgf","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nt : Real\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhX : MeasureTheory.Integrable (fun ω => Real.exp (HMul.hMul t (X ω))) μ\n⊢ Eq (Real.exp (ProbabilityTheory.cgf X μ t)) (ProbabilityTheory.mgf X μ t)","decl":"lemma exp_cgf [IsProbabilityMeasure μ] (hX : Integrable (fun ω ↦ exp (t * X ω)) μ) :\n    exp (cgf X μ t) = mgf X μ t := by rw [cgf, exp_log (mgf_pos hX)]\n\n"}
{"name":"ProbabilityTheory.mgf_id_map","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nhX : AEMeasurable X μ\n⊢ Eq (ProbabilityTheory.mgf id (MeasureTheory.Measure.map X μ)) (ProbabilityTheory.mgf X μ)","decl":"lemma mgf_id_map (hX : AEMeasurable X μ) : mgf id (μ.map X) = mgf X μ := by\n  ext t\n  rw [mgf, integral_map hX]\n  · rfl\n  · exact (measurable_const_mul _).exp.aestronglyMeasurable\n\n"}
{"name":"ProbabilityTheory.mgf_congr_identDistrib","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nΩ' : Type u_3\nmΩ' : MeasurableSpace Ω'\nμ' : MeasureTheory.Measure Ω'\nY : Ω' → Real\nh : ProbabilityTheory.IdentDistrib X Y μ μ'\n⊢ Eq (ProbabilityTheory.mgf X μ) (ProbabilityTheory.mgf Y μ')","decl":"lemma mgf_congr_identDistrib {Ω' : Type*} {mΩ' : MeasurableSpace Ω'} {μ' : Measure Ω'}\n    {Y : Ω' → ℝ} (h : IdentDistrib X Y μ μ') :\n    mgf X μ = mgf Y μ' := by\n  rw [← mgf_id_map h.aemeasurable_fst, ← mgf_id_map h.aemeasurable_snd, h.map_eq]\n\n"}
{"name":"ProbabilityTheory.mgf_neg","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nt : Real\n⊢ Eq (ProbabilityTheory.mgf (Neg.neg X) μ t) (ProbabilityTheory.mgf X μ (Neg.neg t))","decl":"theorem mgf_neg : mgf (-X) μ t = mgf X μ (-t) := by simp_rw [mgf, Pi.neg_apply, mul_neg, neg_mul]\n\n"}
{"name":"ProbabilityTheory.cgf_neg","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nt : Real\n⊢ Eq (ProbabilityTheory.cgf (Neg.neg X) μ t) (ProbabilityTheory.cgf X μ (Neg.neg t))","decl":"theorem cgf_neg : cgf (-X) μ t = cgf X μ (-t) := by simp_rw [cgf, mgf_neg]\n\n"}
{"name":"ProbabilityTheory.mgf_smul_left","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nt α : Real\n⊢ Eq (ProbabilityTheory.mgf (HSMul.hSMul α X) μ t) (ProbabilityTheory.mgf X μ (HMul.hMul α t))","decl":"theorem mgf_smul_left (α : ℝ) : mgf (α • X) μ t = mgf X μ (α * t) := by\n  simp_rw [mgf, Pi.smul_apply, smul_eq_mul, mul_comm α t, mul_assoc]\n\n"}
{"name":"ProbabilityTheory.mgf_const_add","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nt α : Real\n⊢ Eq (ProbabilityTheory.mgf (fun ω => HAdd.hAdd α (X ω)) μ t) (HMul.hMul (Real.exp (HMul.hMul t α)) (ProbabilityTheory.mgf X μ t))","decl":"theorem mgf_const_add (α : ℝ) : mgf (fun ω => α + X ω) μ t = exp (t * α) * mgf X μ t := by\n  rw [mgf, mgf, ← integral_mul_left]\n  congr with x\n  dsimp\n  rw [mul_add, exp_add]\n\n"}
{"name":"ProbabilityTheory.mgf_add_const","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nt α : Real\n⊢ Eq (ProbabilityTheory.mgf (fun ω => HAdd.hAdd (X ω) α) μ t) (HMul.hMul (ProbabilityTheory.mgf X μ t) (Real.exp (HMul.hMul t α)))","decl":"theorem mgf_add_const (α : ℝ) : mgf (fun ω => X ω + α) μ t = mgf X μ t *  exp (t * α) := by\n  simp only [add_comm, mgf_const_add, mul_comm]\n\n"}
{"name":"ProbabilityTheory.mgf_mono_of_nonneg","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nt : Real\nY : Ω → Real\nhXY : (MeasureTheory.ae μ).EventuallyLE X Y\nht : LE.le 0 t\nhtY : MeasureTheory.Integrable (fun ω => Real.exp (HMul.hMul t (Y ω))) μ\n⊢ LE.le (ProbabilityTheory.mgf X μ t) (ProbabilityTheory.mgf Y μ t)","decl":"/-- The moment generating function is monotone in the random variable for `t ≥ 0`. -/\nlemma mgf_mono_of_nonneg {Y : Ω → ℝ} (hXY : X ≤ᵐ[μ] Y) (ht : 0 ≤ t)\n    (htY : Integrable (fun ω ↦ exp (t * Y ω)) μ) :\n    mgf X μ t ≤ mgf Y μ t := by\n  by_cases htX : Integrable (fun ω ↦ exp (t * X ω)) μ\n  · refine integral_mono_ae htX htY ?_\n    filter_upwards [hXY] with ω hω using by gcongr\n  · rw [mgf_undef htX]\n    exact mgf_nonneg\n\n"}
{"name":"ProbabilityTheory.mgf_anti_of_nonpos","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nt : Real\nY : Ω → Real\nhXY : (MeasureTheory.ae μ).EventuallyLE X Y\nht : LE.le t 0\nhtX : MeasureTheory.Integrable (fun ω => Real.exp (HMul.hMul t (X ω))) μ\n⊢ LE.le (ProbabilityTheory.mgf Y μ t) (ProbabilityTheory.mgf X μ t)","decl":"/-- The moment generating function is antitone in the random variable for `t ≤ 0`. -/\nlemma mgf_anti_of_nonpos {Y : Ω → ℝ} (hXY : X ≤ᵐ[μ] Y) (ht : t ≤ 0)\n    (htX : Integrable (fun ω ↦ exp (t * X ω)) μ) :\n    mgf Y μ t ≤ mgf X μ t := by\n  by_cases htY : Integrable (fun ω ↦ exp (t * Y ω)) μ\n  · refine integral_mono_ae htY htX ?_\n    filter_upwards [hXY] with ω hω using exp_monotone <| mul_le_mul_of_nonpos_left hω ht\n  · rw [mgf_undef htY]\n    exact mgf_nonneg\n\n"}
{"name":"ProbabilityTheory.IndepFun.exp_mul","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nX Y : Ω → Real\nh_indep : ProbabilityTheory.IndepFun X Y μ\ns t : Real\n⊢ ProbabilityTheory.IndepFun (fun ω => Real.exp (HMul.hMul s (X ω))) (fun ω => Real.exp (HMul.hMul t (Y ω))) μ","decl":"/-- This is a trivial application of `IndepFun.comp` but it will come up frequently. -/\ntheorem IndepFun.exp_mul {X Y : Ω → ℝ} (h_indep : IndepFun X Y μ) (s t : ℝ) :\n    IndepFun (fun ω => exp (s * X ω)) (fun ω => exp (t * Y ω)) μ := by\n  have h_meas : ∀ t, Measurable fun x => exp (t * x) := fun t => (measurable_id'.const_mul t).exp\n  change IndepFun ((fun x => exp (s * x)) ∘ X) ((fun x => exp (t * x)) ∘ Y) μ\n  exact IndepFun.comp h_indep (h_meas s) (h_meas t)\n\n"}
{"name":"ProbabilityTheory.IndepFun.mgf_add","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nt : Real\nX Y : Ω → Real\nh_indep : ProbabilityTheory.IndepFun X Y μ\nhX : MeasureTheory.AEStronglyMeasurable (fun ω => Real.exp (HMul.hMul t (X ω))) μ\nhY : MeasureTheory.AEStronglyMeasurable (fun ω => Real.exp (HMul.hMul t (Y ω))) μ\n⊢ Eq (ProbabilityTheory.mgf (HAdd.hAdd X Y) μ t) (HMul.hMul (ProbabilityTheory.mgf X μ t) (ProbabilityTheory.mgf Y μ t))","decl":"theorem IndepFun.mgf_add {X Y : Ω → ℝ} (h_indep : IndepFun X Y μ)\n    (hX : AEStronglyMeasurable (fun ω => exp (t * X ω)) μ)\n    (hY : AEStronglyMeasurable (fun ω => exp (t * Y ω)) μ) :\n    mgf (X + Y) μ t = mgf X μ t * mgf Y μ t := by\n  simp_rw [mgf, Pi.add_apply, mul_add, exp_add]\n  exact (h_indep.exp_mul t t).integral_mul hX hY\n\n"}
{"name":"ProbabilityTheory.IndepFun.mgf_add'","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nt : Real\nX Y : Ω → Real\nh_indep : ProbabilityTheory.IndepFun X Y μ\nhX : MeasureTheory.AEStronglyMeasurable X μ\nhY : MeasureTheory.AEStronglyMeasurable Y μ\n⊢ Eq (ProbabilityTheory.mgf (HAdd.hAdd X Y) μ t) (HMul.hMul (ProbabilityTheory.mgf X μ t) (ProbabilityTheory.mgf Y μ t))","decl":"theorem IndepFun.mgf_add' {X Y : Ω → ℝ} (h_indep : IndepFun X Y μ) (hX : AEStronglyMeasurable X μ)\n    (hY : AEStronglyMeasurable Y μ) : mgf (X + Y) μ t = mgf X μ t * mgf Y μ t := by\n  have A : Continuous fun x : ℝ => exp (t * x) := by fun_prop\n  have h'X : AEStronglyMeasurable (fun ω => exp (t * X ω)) μ :=\n    A.aestronglyMeasurable.comp_aemeasurable hX.aemeasurable\n  have h'Y : AEStronglyMeasurable (fun ω => exp (t * Y ω)) μ :=\n    A.aestronglyMeasurable.comp_aemeasurable hY.aemeasurable\n  exact h_indep.mgf_add h'X h'Y\n\n"}
{"name":"ProbabilityTheory.IndepFun.cgf_add","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nt : Real\nX Y : Ω → Real\nh_indep : ProbabilityTheory.IndepFun X Y μ\nh_int_X : MeasureTheory.Integrable (fun ω => Real.exp (HMul.hMul t (X ω))) μ\nh_int_Y : MeasureTheory.Integrable (fun ω => Real.exp (HMul.hMul t (Y ω))) μ\n⊢ Eq (ProbabilityTheory.cgf (HAdd.hAdd X Y) μ t) (HAdd.hAdd (ProbabilityTheory.cgf X μ t) (ProbabilityTheory.cgf Y μ t))","decl":"theorem IndepFun.cgf_add {X Y : Ω → ℝ} (h_indep : IndepFun X Y μ)\n    (h_int_X : Integrable (fun ω => exp (t * X ω)) μ)\n    (h_int_Y : Integrable (fun ω => exp (t * Y ω)) μ) :\n    cgf (X + Y) μ t = cgf X μ t + cgf Y μ t := by\n  by_cases hμ : μ = 0\n  · simp [hμ]\n  simp only [cgf, h_indep.mgf_add h_int_X.aestronglyMeasurable h_int_Y.aestronglyMeasurable]\n  exact log_mul (mgf_pos' hμ h_int_X).ne' (mgf_pos' hμ h_int_Y).ne'\n\n"}
{"name":"ProbabilityTheory.aestronglyMeasurable_exp_mul_add","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nt : Real\nX Y : Ω → Real\nh_int_X : MeasureTheory.AEStronglyMeasurable (fun ω => Real.exp (HMul.hMul t (X ω))) μ\nh_int_Y : MeasureTheory.AEStronglyMeasurable (fun ω => Real.exp (HMul.hMul t (Y ω))) μ\n⊢ MeasureTheory.AEStronglyMeasurable (fun ω => Real.exp (HMul.hMul t (HAdd.hAdd X Y ω))) μ","decl":"theorem aestronglyMeasurable_exp_mul_add {X Y : Ω → ℝ}\n    (h_int_X : AEStronglyMeasurable (fun ω => exp (t * X ω)) μ)\n    (h_int_Y : AEStronglyMeasurable (fun ω => exp (t * Y ω)) μ) :\n    AEStronglyMeasurable (fun ω => exp (t * (X + Y) ω)) μ := by\n  simp_rw [Pi.add_apply, mul_add, exp_add]\n  exact AEStronglyMeasurable.mul h_int_X h_int_Y\n\n"}
{"name":"ProbabilityTheory.aestronglyMeasurable_exp_mul_sum","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nι : Type u_2\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nt : Real\nX : ι → Ω → Real\ns : Finset ι\nh_int : ∀ (i : ι), Membership.mem s i → MeasureTheory.AEStronglyMeasurable (fun ω => Real.exp (HMul.hMul t (X i ω))) μ\n⊢ MeasureTheory.AEStronglyMeasurable (fun ω => Real.exp (HMul.hMul t (s.sum (fun i => X i) ω))) μ","decl":"theorem aestronglyMeasurable_exp_mul_sum {X : ι → Ω → ℝ} {s : Finset ι}\n    (h_int : ∀ i ∈ s, AEStronglyMeasurable (fun ω => exp (t * X i ω)) μ) :\n    AEStronglyMeasurable (fun ω => exp (t * (∑ i ∈ s, X i) ω)) μ := by\n  classical\n  induction' s using Finset.induction_on with i s hi_notin_s h_rec h_int\n  · simp only [Pi.zero_apply, sum_apply, sum_empty, mul_zero, exp_zero]\n    exact aestronglyMeasurable_const\n  · have : ∀ i : ι, i ∈ s → AEStronglyMeasurable (fun ω : Ω => exp (t * X i ω)) μ := fun i hi =>\n      h_int i (mem_insert_of_mem hi)\n    specialize h_rec this\n    rw [sum_insert hi_notin_s]\n    apply aestronglyMeasurable_exp_mul_add (h_int i (mem_insert_self _ _)) h_rec\n\n"}
{"name":"ProbabilityTheory.IndepFun.integrable_exp_mul_add","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nt : Real\nX Y : Ω → Real\nh_indep : ProbabilityTheory.IndepFun X Y μ\nh_int_X : MeasureTheory.Integrable (fun ω => Real.exp (HMul.hMul t (X ω))) μ\nh_int_Y : MeasureTheory.Integrable (fun ω => Real.exp (HMul.hMul t (Y ω))) μ\n⊢ MeasureTheory.Integrable (fun ω => Real.exp (HMul.hMul t (HAdd.hAdd X Y ω))) μ","decl":"theorem IndepFun.integrable_exp_mul_add {X Y : Ω → ℝ} (h_indep : IndepFun X Y μ)\n    (h_int_X : Integrable (fun ω => exp (t * X ω)) μ)\n    (h_int_Y : Integrable (fun ω => exp (t * Y ω)) μ) :\n    Integrable (fun ω => exp (t * (X + Y) ω)) μ := by\n  simp_rw [Pi.add_apply, mul_add, exp_add]\n  exact (h_indep.exp_mul t t).integrable_mul h_int_X h_int_Y\n\n"}
{"name":"ProbabilityTheory.iIndepFun.integrable_exp_mul_sum","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nι : Type u_2\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nt : Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nX : ι → Ω → Real\nh_indep : ProbabilityTheory.iIndepFun (fun x => inferInstance) X μ\nh_meas : ∀ (i : ι), Measurable (X i)\ns : Finset ι\nh_int : ∀ (i : ι), Membership.mem s i → MeasureTheory.Integrable (fun ω => Real.exp (HMul.hMul t (X i ω))) μ\n⊢ MeasureTheory.Integrable (fun ω => Real.exp (HMul.hMul t (s.sum (fun i => X i) ω))) μ","decl":"theorem iIndepFun.integrable_exp_mul_sum [IsFiniteMeasure μ] {X : ι → Ω → ℝ}\n    (h_indep : iIndepFun (fun _ => inferInstance) X μ) (h_meas : ∀ i, Measurable (X i))\n    {s : Finset ι} (h_int : ∀ i ∈ s, Integrable (fun ω => exp (t * X i ω)) μ) :\n    Integrable (fun ω => exp (t * (∑ i ∈ s, X i) ω)) μ := by\n  classical\n  induction' s using Finset.induction_on with i s hi_notin_s h_rec h_int\n  · simp only [Pi.zero_apply, sum_apply, sum_empty, mul_zero, exp_zero]\n    exact integrable_const _\n  · have : ∀ i : ι, i ∈ s → Integrable (fun ω : Ω => exp (t * X i ω)) μ := fun i hi =>\n      h_int i (mem_insert_of_mem hi)\n    specialize h_rec this\n    rw [sum_insert hi_notin_s]\n    refine IndepFun.integrable_exp_mul_add ?_ (h_int i (mem_insert_self _ _)) h_rec\n    exact (h_indep.indepFun_finset_sum_of_not_mem h_meas hi_notin_s).symm\n\n-- TODO(vilin97): weaken `h_meas` to `AEMeasurable (X i)` or `AEStronglyMeasurable (X i)` throughout\n-- https://github.com/leanprover-community/mathlib4/issues/20367\n"}
{"name":"ProbabilityTheory.iIndepFun.mgf_sum","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nι : Type u_2\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nt : Real\nX : ι → Ω → Real\nh_indep : ProbabilityTheory.iIndepFun (fun x => inferInstance) X μ\nh_meas : ∀ (i : ι), Measurable (X i)\ns : Finset ι\n⊢ Eq (ProbabilityTheory.mgf (s.sum fun i => X i) μ t) (s.prod fun i => ProbabilityTheory.mgf (X i) μ t)","decl":"theorem iIndepFun.mgf_sum {X : ι → Ω → ℝ}\n    (h_indep : iIndepFun (fun _ => inferInstance) X μ) (h_meas : ∀ i, Measurable (X i))\n    (s : Finset ι) : mgf (∑ i ∈ s, X i) μ t = ∏ i ∈ s, mgf (X i) μ t := by\n  have : IsProbabilityMeasure μ := h_indep.isProbabilityMeasure\n  classical\n  induction' s using Finset.induction_on with i s hi_notin_s h_rec h_int\n  · simp only [sum_empty, mgf_zero_fun, measure_univ, ENNReal.one_toReal, prod_empty]\n  · have h_int' : ∀ i : ι, AEStronglyMeasurable (fun ω : Ω => exp (t * X i ω)) μ := fun i =>\n      ((h_meas i).const_mul t).exp.aestronglyMeasurable\n    rw [sum_insert hi_notin_s,\n      IndepFun.mgf_add (h_indep.indepFun_finset_sum_of_not_mem h_meas hi_notin_s).symm (h_int' i)\n        (aestronglyMeasurable_exp_mul_sum fun i _ => h_int' i),\n      h_rec, prod_insert hi_notin_s]\n\n"}
{"name":"ProbabilityTheory.iIndepFun.cgf_sum","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nι : Type u_2\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nt : Real\nX : ι → Ω → Real\nh_indep : ProbabilityTheory.iIndepFun (fun x => inferInstance) X μ\nh_meas : ∀ (i : ι), Measurable (X i)\ns : Finset ι\nh_int : ∀ (i : ι), Membership.mem s i → MeasureTheory.Integrable (fun ω => Real.exp (HMul.hMul t (X i ω))) μ\n⊢ Eq (ProbabilityTheory.cgf (s.sum fun i => X i) μ t) (s.sum fun i => ProbabilityTheory.cgf (X i) μ t)","decl":"theorem iIndepFun.cgf_sum {X : ι → Ω → ℝ}\n    (h_indep : iIndepFun (fun _ => inferInstance) X μ) (h_meas : ∀ i, Measurable (X i))\n    {s : Finset ι} (h_int : ∀ i ∈ s, Integrable (fun ω => exp (t * X i ω)) μ) :\n    cgf (∑ i ∈ s, X i) μ t = ∑ i ∈ s, cgf (X i) μ t := by\n  have : IsProbabilityMeasure μ := h_indep.isProbabilityMeasure\n  simp_rw [cgf]\n  rw [← log_prod _ _ fun j hj => ?_]\n  · rw [h_indep.mgf_sum h_meas]\n  · exact (mgf_pos (h_int j hj)).ne'\n\n"}
{"name":"ProbabilityTheory.mgf_congr_of_identDistrib","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nX : Ω → Real\nΩ' : Type u_3\nm' : MeasurableSpace Ω'\nμ' : MeasureTheory.Measure Ω'\nX' : Ω' → Real\nhident : ProbabilityTheory.IdentDistrib X X' μ μ'\nt : Real\n⊢ Eq (ProbabilityTheory.mgf X μ t) (ProbabilityTheory.mgf X' μ' t)","decl":"theorem mgf_congr_of_identDistrib\n    (X : Ω → ℝ) {Ω' : Type*} {m' : MeasurableSpace Ω'} {μ' : Measure Ω'} (X' : Ω' → ℝ)\n    (hident : IdentDistrib X X' μ μ') (t : ℝ) :\n    mgf X μ t = mgf X' μ' t := hident.comp (measurable_const_mul t).exp |>.integral_eq\n\n"}
{"name":"ProbabilityTheory.mgf_sum_of_identDistrib","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nι : Type u_2\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nX : ι → Ω → Real\ns : Finset ι\nj : ι\nh_meas : ∀ (i : ι), Measurable (X i)\nh_indep : ProbabilityTheory.iIndepFun (fun x => inferInstance) X μ\nhident : ∀ (i : ι), Membership.mem s i → ∀ (j : ι), Membership.mem s j → ProbabilityTheory.IdentDistrib (X i) (X j) μ μ\nhj : Membership.mem s j\nt : Real\n⊢ Eq (ProbabilityTheory.mgf (s.sum fun i => X i) μ t) (HPow.hPow (ProbabilityTheory.mgf (X j) μ t) s.card)","decl":"theorem mgf_sum_of_identDistrib\n    {X : ι → Ω → ℝ}\n    {s : Finset ι} {j : ι}\n    (h_meas : ∀ i, Measurable (X i))\n    (h_indep : iIndepFun (fun _ => inferInstance) X μ)\n    (hident : ∀ i ∈ s, ∀ j ∈ s, IdentDistrib (X i) (X j) μ μ)\n    (hj : j ∈ s) (t : ℝ) : mgf (∑ i ∈ s, X i) μ t = mgf (X j) μ t ^ #s := by\n  rw [h_indep.mgf_sum h_meas]\n  exact Finset.prod_eq_pow_card fun i hi =>\n    mgf_congr_of_identDistrib (X i) (X j) (hident i hi j hj) t\n\n"}
{"name":"ProbabilityTheory.measure_ge_le_exp_mul_mgf","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nt : Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nε : Real\nht : LE.le 0 t\nh_int : MeasureTheory.Integrable (fun ω => Real.exp (HMul.hMul t (X ω))) μ\n⊢ LE.le (μ (setOf fun ω => LE.le ε (X ω))).toReal (HMul.hMul (Real.exp (HMul.hMul (Neg.neg t) ε)) (ProbabilityTheory.mgf X μ t))","decl":"/-- **Chernoff bound** on the upper tail of a real random variable. -/\ntheorem measure_ge_le_exp_mul_mgf [IsFiniteMeasure μ] (ε : ℝ) (ht : 0 ≤ t)\n    (h_int : Integrable (fun ω => exp (t * X ω)) μ) :\n    (μ {ω | ε ≤ X ω}).toReal ≤ exp (-t * ε) * mgf X μ t := by\n  rcases ht.eq_or_lt with ht_zero_eq | ht_pos\n  · rw [ht_zero_eq.symm]\n    simp only [neg_zero, zero_mul, exp_zero, mgf_zero', one_mul]\n    gcongr\n    exacts [measure_ne_top _ _, Set.subset_univ _]\n  calc\n    (μ {ω | ε ≤ X ω}).toReal = (μ {ω | exp (t * ε) ≤ exp (t * X ω)}).toReal := by\n      congr with ω\n      simp only [Set.mem_setOf_eq, exp_le_exp, gt_iff_lt]\n      exact ⟨fun h => mul_le_mul_of_nonneg_left h ht_pos.le,\n        fun h => le_of_mul_le_mul_left h ht_pos⟩\n    _ ≤ (exp (t * ε))⁻¹ * μ[fun ω => exp (t * X ω)] := by\n      have : exp (t * ε) * (μ {ω | exp (t * ε) ≤ exp (t * X ω)}).toReal ≤\n          μ[fun ω => exp (t * X ω)] :=\n        mul_meas_ge_le_integral_of_nonneg (ae_of_all _ fun x => (exp_pos _).le) h_int _\n      rwa [mul_comm (exp (t * ε))⁻¹, ← div_eq_mul_inv, le_div_iff₀' (exp_pos _)]\n    _ = exp (-t * ε) * mgf X μ t := by rw [neg_mul, exp_neg]; rfl\n\n"}
{"name":"ProbabilityTheory.measure_le_le_exp_mul_mgf","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nt : Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nε : Real\nht : LE.le t 0\nh_int : MeasureTheory.Integrable (fun ω => Real.exp (HMul.hMul t (X ω))) μ\n⊢ LE.le (μ (setOf fun ω => LE.le (X ω) ε)).toReal (HMul.hMul (Real.exp (HMul.hMul (Neg.neg t) ε)) (ProbabilityTheory.mgf X μ t))","decl":"/-- **Chernoff bound** on the lower tail of a real random variable. -/\ntheorem measure_le_le_exp_mul_mgf [IsFiniteMeasure μ] (ε : ℝ) (ht : t ≤ 0)\n    (h_int : Integrable (fun ω => exp (t * X ω)) μ) :\n    (μ {ω | X ω ≤ ε}).toReal ≤ exp (-t * ε) * mgf X μ t := by\n  rw [← neg_neg t, ← mgf_neg, neg_neg, ← neg_mul_neg (-t)]\n  refine Eq.trans_le ?_ (measure_ge_le_exp_mul_mgf (-ε) (neg_nonneg.mpr ht) ?_)\n  · congr with ω\n    simp only [Pi.neg_apply, neg_le_neg_iff]\n  · simp_rw [Pi.neg_apply, neg_mul_neg]\n    exact h_int\n\n"}
{"name":"ProbabilityTheory.measure_ge_le_exp_cgf","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nt : Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nε : Real\nht : LE.le 0 t\nh_int : MeasureTheory.Integrable (fun ω => Real.exp (HMul.hMul t (X ω))) μ\n⊢ LE.le (μ (setOf fun ω => LE.le ε (X ω))).toReal (Real.exp (HAdd.hAdd (HMul.hMul (Neg.neg t) ε) (ProbabilityTheory.cgf X μ t)))","decl":"/-- **Chernoff bound** on the upper tail of a real random variable. -/\ntheorem measure_ge_le_exp_cgf [IsFiniteMeasure μ] (ε : ℝ) (ht : 0 ≤ t)\n    (h_int : Integrable (fun ω => exp (t * X ω)) μ) :\n    (μ {ω | ε ≤ X ω}).toReal ≤ exp (-t * ε + cgf X μ t) := by\n  refine (measure_ge_le_exp_mul_mgf ε ht h_int).trans ?_\n  rw [exp_add]\n  exact mul_le_mul le_rfl (le_exp_log _) mgf_nonneg (exp_pos _).le\n\n"}
{"name":"ProbabilityTheory.measure_le_le_exp_cgf","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nt : Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nε : Real\nht : LE.le t 0\nh_int : MeasureTheory.Integrable (fun ω => Real.exp (HMul.hMul t (X ω))) μ\n⊢ LE.le (μ (setOf fun ω => LE.le (X ω) ε)).toReal (Real.exp (HAdd.hAdd (HMul.hMul (Neg.neg t) ε) (ProbabilityTheory.cgf X μ t)))","decl":"/-- **Chernoff bound** on the lower tail of a real random variable. -/\ntheorem measure_le_le_exp_cgf [IsFiniteMeasure μ] (ε : ℝ) (ht : t ≤ 0)\n    (h_int : Integrable (fun ω => exp (t * X ω)) μ) :\n    (μ {ω | X ω ≤ ε}).toReal ≤ exp (-t * ε + cgf X μ t) := by\n  refine (measure_le_le_exp_mul_mgf ε ht h_int).trans ?_\n  rw [exp_add]\n  exact mul_le_mul le_rfl (le_exp_log _) mgf_nonneg (exp_pos _).le\n\n"}
{"name":"ProbabilityTheory.mgf_dirac","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nx : Real\nhX : Eq (MeasureTheory.Measure.map X μ) (MeasureTheory.Measure.dirac x)\nt : Real\n⊢ Eq (ProbabilityTheory.mgf X μ t) (Real.exp (HMul.hMul x t))","decl":"lemma mgf_dirac {x : ℝ} (hX : μ.map X = .dirac x) (t : ℝ) : mgf X μ t = exp (x * t) := by\n  have : IsProbabilityMeasure (μ.map X) := by rw [hX]; infer_instance\n  rw [← mgf_id_map (.of_map_ne_zero <| IsProbabilityMeasure.ne_zero _), mgf, hX, integral_dirac,\n    mul_comm, id_def]\n\n"}
{"name":"ProbabilityTheory.aemeasurable_exp_mul","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nX : Ω → Real\nt : Real\nhX : AEMeasurable X μ\n⊢ MeasureTheory.AEStronglyMeasurable (fun ω => Real.exp (HMul.hMul t (X ω))) μ","decl":"lemma aemeasurable_exp_mul {X : Ω → ℝ} (t : ℝ) (hX : AEMeasurable X μ) :\n    AEStronglyMeasurable (fun ω ↦ rexp (t * X ω)) μ :=\n  (measurable_exp.comp_aemeasurable (hX.const_mul t)).aestronglyMeasurable\n\n"}
{"name":"ProbabilityTheory.integrable_exp_mul_of_le","module":"Mathlib.Probability.Moments.Basic","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nX : Ω → Real\nt b : Real\nht : LE.le 0 t\nhX : AEMeasurable X μ\nhb : Filter.Eventually (fun ω => LE.le (X ω) b) (MeasureTheory.ae μ)\n⊢ MeasureTheory.Integrable (fun ω => Real.exp (HMul.hMul t (X ω))) μ","decl":"lemma integrable_exp_mul_of_le [IsFiniteMeasure μ] {X : Ω → ℝ} (t b : ℝ) (ht : 0 ≤ t)\n    (hX : AEMeasurable X μ) (hb : ∀ᵐ ω ∂μ, X ω ≤ b) :\n    Integrable (fun ω ↦ exp (t * X ω)) μ := by\n  refine .of_mem_Icc 0 (rexp (t * b)) (measurable_exp.comp_aemeasurable (hX.const_mul t)) ?_\n  filter_upwards [hb] with ω hb\n  exact ⟨by positivity, by gcongr⟩\n\n"}
