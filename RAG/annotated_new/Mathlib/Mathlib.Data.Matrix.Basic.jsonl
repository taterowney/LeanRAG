{"name":"Matrix.instFinite","module":"Mathlib.Data.Matrix.Basic","initialProofState":"n : Type u_10\nm : Type u_11\ninst✝² : Finite m\ninst✝¹ : Finite n\nα : Type u_12\ninst✝ : Finite α\n⊢ Finite (Matrix m n α)","decl":"instance {n m} [Finite m] [Finite n] (α) [Finite α] :\n    Finite (Matrix m n α) := inferInstanceAs (Finite (m → n → α))\n\n"}
{"name":"Matrix.coe_ofLinearEquiv","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid α\ninst✝ : Module R α\n⊢ Eq ⇑(Matrix.ofLinearEquiv R) ⇑Matrix.of","decl":"@[simp] lemma coe_ofLinearEquiv [Semiring R] [AddCommMonoid α] [Module R α] :\n    ⇑(ofLinearEquiv _ : (m → n → α) ≃ₗ[R] Matrix m n α) = of := rfl\n"}
{"name":"Matrix.coe_ofLinearEquiv_symm","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid α\ninst✝ : Module R α\n⊢ Eq ⇑(Matrix.ofLinearEquiv R).symm ⇑Matrix.of.symm","decl":"@[simp] lemma coe_ofLinearEquiv_symm [Semiring R] [AddCommMonoid α] [Module R α] :\n    ⇑((ofLinearEquiv _).symm : Matrix m n α ≃ₗ[R] (m → n → α)) = of.symm := rfl\n\n"}
{"name":"Matrix.sum_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nβ : Type w\ninst✝ : AddCommMonoid α\ni : m\nj : n\ns : Finset β\ng : β → Matrix m n α\n⊢ Eq (s.sum (fun c => g c) i j) (s.sum fun c => g c i j)","decl":"theorem sum_apply [AddCommMonoid α] (i : m) (j : n) (s : Finset β) (g : β → Matrix m n α) :\n    (∑ c ∈ s, g c) i j = ∑ c ∈ s, g c i j :=\n  (congr_fun (s.sum_apply i g) j).trans (s.sum_apply j _)\n\n"}
{"name":"Matrix.diagonalAddMonoidHom_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : DecidableEq n\ninst✝ : AddZeroClass α\nd : n → α\n⊢ Eq ((Matrix.diagonalAddMonoidHom n α) d) (Matrix.diagonal d)","decl":"/-- `Matrix.diagonal` as an `AddMonoidHom`. -/\n@[simps]\ndef diagonalAddMonoidHom [AddZeroClass α] : (n → α) →+ Matrix n n α where\n  toFun := diagonal\n  map_zero' := diagonal_zero\n  map_add' x y := (diagonal_add x y).symm\n\n"}
{"name":"Matrix.diagonalLinearMap_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"n : Type u_3\nR : Type u_7\nα : Type v\ninst✝³ : DecidableEq n\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid α\ninst✝ : Module R α\na✝ : n → α\n⊢ Eq ((Matrix.diagonalLinearMap n R α) a✝) ((↑(Matrix.diagonalAddMonoidHom n α)).toFun a✝)","decl":"/-- `Matrix.diagonal` as a `LinearMap`. -/\n@[simps]\ndef diagonalLinearMap [Semiring R] [AddCommMonoid α] [Module R α] : (n → α) →ₗ[R] Matrix n n α :=\n  { diagonalAddMonoidHom n α with map_smul' := diagonal_smul }\n\n"}
{"name":"Matrix.zero_le_one_elem","module":"Mathlib.Data.Matrix.Basic","initialProofState":"n : Type u_3\nα : Type v\ninst✝⁴ : DecidableEq n\ninst✝³ : Zero α\ninst✝² : One α\ninst✝¹ : Preorder α\ninst✝ : ZeroLEOneClass α\ni j : n\n⊢ LE.le 0 (1 i j)","decl":"lemma zero_le_one_elem [Preorder α] [ZeroLEOneClass α] (i j : n) :\n    0 ≤ (1 : Matrix n n α) i j := by\n  by_cases hi : i = j\n  · subst hi\n    simp\n  · simp [hi]\n\n"}
{"name":"Matrix.zero_le_one_row","module":"Mathlib.Data.Matrix.Basic","initialProofState":"n : Type u_3\nα : Type v\ninst✝⁴ : DecidableEq n\ninst✝³ : Zero α\ninst✝² : One α\ninst✝¹ : Preorder α\ninst✝ : ZeroLEOneClass α\ni : n\n⊢ LE.le 0 (1 i)","decl":"lemma zero_le_one_row [Preorder α] [ZeroLEOneClass α] (i : n) :\n    0 ≤ (1 : Matrix n n α) i :=\n  zero_le_one_elem i\n\n"}
{"name":"Matrix.diagAddMonoidHom_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"n : Type u_3\nα : Type v\ninst✝ : AddZeroClass α\nA : Matrix n n α\ni : n\n⊢ Eq ((Matrix.diagAddMonoidHom n α) A i) (A.diag i)","decl":"/-- `Matrix.diag` as an `AddMonoidHom`. -/\n@[simps]\ndef diagAddMonoidHom [AddZeroClass α] : Matrix n n α →+ n → α where\n  toFun := diag\n  map_zero' := diag_zero\n  map_add' := diag_add\n\n"}
{"name":"Matrix.diagLinearMap_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"n : Type u_3\nR : Type u_7\nα : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid α\ninst✝ : Module R α\na✝¹ : Matrix n n α\na✝ : n\n⊢ Eq ((Matrix.diagLinearMap n R α) a✝¹ a✝) ((↑(Matrix.diagAddMonoidHom n α)).toFun a✝¹ a✝)","decl":"/-- `Matrix.diag` as a `LinearMap`. -/\n@[simps]\ndef diagLinearMap [Semiring R] [AddCommMonoid α] [Module R α] : Matrix n n α →ₗ[R] n → α :=\n  { diagAddMonoidHom n α with map_smul' := diag_smul }\n\n"}
{"name":"Matrix.diag_list_sum","module":"Mathlib.Data.Matrix.Basic","initialProofState":"n : Type u_3\nα : Type v\ninst✝ : AddMonoid α\nl : List (Matrix n n α)\n⊢ Eq l.sum.diag (List.map Matrix.diag l).sum","decl":"@[simp]\ntheorem diag_list_sum [AddMonoid α] (l : List (Matrix n n α)) : diag l.sum = (l.map diag).sum :=\n  map_list_sum (diagAddMonoidHom n α) l\n\n"}
{"name":"Matrix.diag_multiset_sum","module":"Mathlib.Data.Matrix.Basic","initialProofState":"n : Type u_3\nα : Type v\ninst✝ : AddCommMonoid α\ns : Multiset (Matrix n n α)\n⊢ Eq s.sum.diag (Multiset.map Matrix.diag s).sum","decl":"@[simp]\ntheorem diag_multiset_sum [AddCommMonoid α] (s : Multiset (Matrix n n α)) :\n    diag s.sum = (s.map diag).sum :=\n  map_multiset_sum (diagAddMonoidHom n α) s\n\n"}
{"name":"Matrix.diag_sum","module":"Mathlib.Data.Matrix.Basic","initialProofState":"n : Type u_3\nα : Type v\nι : Type u_10\ninst✝ : AddCommMonoid α\ns : Finset ι\nf : ι → Matrix n n α\n⊢ Eq (s.sum fun i => f i).diag (s.sum fun i => (f i).diag)","decl":"@[simp]\ntheorem diag_sum {ι} [AddCommMonoid α] (s : Finset ι) (f : ι → Matrix n n α) :\n    diag (∑ i ∈ s, f i) = ∑ i ∈ s, diag (f i) :=\n  map_sum (diagAddMonoidHom n α) f s\n\n"}
{"name":"Matrix.diagonalRingHom_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : NonAssocSemiring α\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nd : n → α\n⊢ Eq ((Matrix.diagonalRingHom n α) d) (Matrix.diagonal d)","decl":"/-- `Matrix.diagonal` as a `RingHom`. -/\n@[simps]\ndef diagonalRingHom [Fintype n] [DecidableEq n] : (n → α) →+* Matrix n n α :=\n  { diagonalAddMonoidHom n α with\n    toFun := diagonal\n    map_one' := diagonal_one\n    map_mul' := fun _ _ => (diagonal_mul_diagonal' _ _).symm }\n\n"}
{"name":"Matrix.diagonal_pow","module":"Mathlib.Data.Matrix.Basic","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : Semiring α\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nv : n → α\nk : Nat\n⊢ Eq (HPow.hPow (Matrix.diagonal v) k) (Matrix.diagonal (HPow.hPow v k))","decl":"theorem diagonal_pow [Fintype n] [DecidableEq n] (v : n → α) (k : ℕ) :\n    diagonal v ^ k = diagonal (v ^ k) :=\n  (map_pow (diagonalRingHom n α) v k).symm\n\n"}
{"name":"Matrix.scalar_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : Semiring α\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\na : α\n⊢ Eq ((Matrix.scalar n) a) (Matrix.diagonal fun x => a)","decl":"@[simp]\ntheorem scalar_apply (a : α) : scalar n a = diagonal fun _ => a :=\n  rfl\n\n"}
{"name":"Matrix.scalar_inj","module":"Mathlib.Data.Matrix.Basic","initialProofState":"n : Type u_3\nα : Type v\ninst✝³ : Semiring α\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : Nonempty n\nr s : α\n⊢ Iff (Eq ((Matrix.scalar n) r) ((Matrix.scalar n) s)) (Eq r s)","decl":"theorem scalar_inj [Nonempty n] {r s : α} : scalar n r = scalar n s ↔ r = s :=\n  (diagonal_injective.comp Function.const_injective).eq_iff\n\n"}
{"name":"Matrix.scalar_commute_iff","module":"Mathlib.Data.Matrix.Basic","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : Semiring α\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nr : α\nM : Matrix n n α\n⊢ Iff (Commute ((Matrix.scalar n) r) M) (Eq (HSMul.hSMul r M) (HSMul.hSMul (MulOpposite.op r) M))","decl":"theorem scalar_commute_iff {r : α} {M : Matrix n n α} :\n    Commute (scalar n r) M ↔ r • M = MulOpposite.op r • M := by\n  simp_rw [Commute, SemiconjBy, scalar_apply, ← smul_eq_diagonal_mul, ← op_smul_eq_mul_diagonal]\n\n"}
{"name":"Matrix.scalar_commute","module":"Mathlib.Data.Matrix.Basic","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : Semiring α\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nr : α\nhr : ∀ (r' : α), Commute r r'\nM : Matrix n n α\n⊢ Commute ((Matrix.scalar n) r) M","decl":"theorem scalar_commute (r : α) (hr : ∀ r', Commute r r') (M : Matrix n n α) :\n    Commute (scalar n r) M := scalar_commute_iff.2 <| ext fun _ _ => hr _\n\n"}
{"name":"Matrix.algebraMap_matrix_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"n : Type u_3\nR : Type u_7\nα : Type v\ninst✝⁴ : Fintype n\ninst✝³ : DecidableEq n\ninst✝² : CommSemiring R\ninst✝¹ : Semiring α\ninst✝ : Algebra R α\nr : R\ni j : n\n⊢ Eq ((algebraMap R (Matrix n n α)) r i j) (ite (Eq i j) ((algebraMap R α) r) 0)","decl":"theorem algebraMap_matrix_apply {r : R} {i j : n} :\n    algebraMap R (Matrix n n α) r i j = if i = j then algebraMap R α r else 0 := by\n  dsimp [algebraMap, Algebra.algebraMap, Matrix.scalar]\n  split_ifs with h <;> simp [h, Matrix.one_apply_ne]\n\n"}
{"name":"Matrix.algebraMap_eq_diagonal","module":"Mathlib.Data.Matrix.Basic","initialProofState":"n : Type u_3\nR : Type u_7\nα : Type v\ninst✝⁴ : Fintype n\ninst✝³ : DecidableEq n\ninst✝² : CommSemiring R\ninst✝¹ : Semiring α\ninst✝ : Algebra R α\nr : R\n⊢ Eq ((algebraMap R (Matrix n n α)) r) (Matrix.diagonal ((algebraMap R (n → α)) r))","decl":"theorem algebraMap_eq_diagonal (r : R) :\n    algebraMap R (Matrix n n α) r = diagonal (algebraMap R (n → α) r) := rfl\n\n"}
{"name":"Matrix.algebraMap_eq_diagonalRingHom","module":"Mathlib.Data.Matrix.Basic","initialProofState":"n : Type u_3\nR : Type u_7\nα : Type v\ninst✝⁴ : Fintype n\ninst✝³ : DecidableEq n\ninst✝² : CommSemiring R\ninst✝¹ : Semiring α\ninst✝ : Algebra R α\n⊢ Eq (algebraMap R (Matrix n n α)) ((Matrix.diagonalRingHom n α).comp (algebraMap R (n → α)))","decl":"theorem algebraMap_eq_diagonalRingHom :\n    algebraMap R (Matrix n n α) = (diagonalRingHom n α).comp (algebraMap R _) := rfl\n\n"}
{"name":"Matrix.map_algebraMap","module":"Mathlib.Data.Matrix.Basic","initialProofState":"n : Type u_3\nR : Type u_7\nα : Type v\nβ : Type w\ninst✝⁶ : Fintype n\ninst✝⁵ : DecidableEq n\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring α\ninst✝² : Semiring β\ninst✝¹ : Algebra R α\ninst✝ : Algebra R β\nr : R\nf : α → β\nhf : Eq (f 0) 0\nhf₂ : Eq (f ((algebraMap R α) r)) ((algebraMap R β) r)\n⊢ Eq (((algebraMap R (Matrix n n α)) r).map f) ((algebraMap R (Matrix n n β)) r)","decl":"@[simp]\ntheorem map_algebraMap (r : R) (f : α → β) (hf : f 0 = 0)\n    (hf₂ : f (algebraMap R α r) = algebraMap R β r) :\n    (algebraMap R (Matrix n n α) r).map f = algebraMap R (Matrix n n β) r := by\n  rw [algebraMap_eq_diagonal, algebraMap_eq_diagonal, diagonal_map hf]\n  -- Porting note: (congr) the remaining proof was\n  -- ```\n  -- congr 1\n  -- simp only [hf₂, Pi.algebraMap_apply]\n  -- ```\n  -- But some `congr 1` doesn't quite work.\n  simp only [Pi.algebraMap_apply, diagonal_eq_diagonal_iff]\n  intro\n  rw [hf₂]\n\n"}
{"name":"Matrix.diagonalAlgHom_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"n : Type u_3\nR : Type u_7\nα : Type v\ninst✝⁴ : Fintype n\ninst✝³ : DecidableEq n\ninst✝² : CommSemiring R\ninst✝¹ : Semiring α\ninst✝ : Algebra R α\nd : n → α\n⊢ Eq ((Matrix.diagonalAlgHom R) d) (Matrix.diagonal d)","decl":"/-- `Matrix.diagonal` as an `AlgHom`. -/\n@[simps]\ndef diagonalAlgHom : (n → α) →ₐ[R] Matrix n n α :=\n  { diagonalRingHom n α with\n    toFun := diagonal\n    commutes' := fun r => (algebraMap_eq_diagonal r).symm }\n\n"}
{"name":"Matrix.entryAddHom_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : Add α\ni : m\nj : n\nM : Matrix m n α\n⊢ Eq ((Matrix.entryAddHom α i j) M) (M i j)","decl":"variable (R α) in\n/-- Extracting entries from a matrix as an additive homomorphism.  -/\n@[simps]\ndef entryAddHom (i : m) (j : n) : AddHom (Matrix m n α) α where\n  toFun M := M i j\n  map_add' _ _ := rfl\n\n-- It is necessary to spell out the name of the coercion explicitly on the RHS\n-- for unification to succeed\n"}
{"name":"Matrix.entryAddHom_eq_comp","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : Add α\ni : m\nj : n\n⊢ Eq (Matrix.entryAddHom α i j) (((Pi.evalAddHom (fun x => α) j).comp (Pi.evalAddHom (fun i => n → α) i)).comp ↑Matrix.ofAddEquiv.symm)","decl":"lemma entryAddHom_eq_comp {i : m} {j : n} :\n    entryAddHom α i j =\n      ((Pi.evalAddHom (fun _ => α) j).comp (Pi.evalAddHom _ i)).comp\n        (AddHomClass.toAddHom ofAddEquiv.symm) :=\n  rfl\n\n"}
{"name":"Matrix.entryAddMonoidHom_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : AddZeroClass α\ni : m\nj : n\nM : Matrix m n α\n⊢ Eq ((Matrix.entryAddMonoidHom α i j) M) (M i j)","decl":"variable (R α) in\n/--\nExtracting entries from a matrix as an additive monoid homomorphism. Note this cannot be upgraded to\na ring homomorphism, as it does not respect multiplication.\n-/\n@[simps]\ndef entryAddMonoidHom (i : m) (j : n) : Matrix m n α →+ α where\n  toFun M := M i j\n  map_add' _ _ := rfl\n  map_zero' := rfl\n\n-- It is necessary to spell out the name of the coercion explicitly on the RHS\n-- for unification to succeed\n"}
{"name":"Matrix.entryAddMonoidHom_eq_comp","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : AddZeroClass α\ni : m\nj : n\n⊢ Eq (Matrix.entryAddMonoidHom α i j) (((Pi.evalAddMonoidHom (fun x => α) j).comp (Pi.evalAddMonoidHom (fun i => n → α) i)).comp ↑Matrix.ofAddEquiv.symm)","decl":"lemma entryAddMonoidHom_eq_comp {i : m} {j : n} :\n    entryAddMonoidHom α i j =\n      ((Pi.evalAddMonoidHom (fun _ => α) j).comp (Pi.evalAddMonoidHom _ i)).comp\n        (AddMonoidHomClass.toAddMonoidHom ofAddEquiv.symm) := by\n  rfl\n\n"}
{"name":"Matrix.evalAddMonoidHom_comp_diagAddMonoidHom","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nα : Type v\ninst✝ : AddZeroClass α\ni : m\n⊢ Eq ((Pi.evalAddMonoidHom (fun i => α) i).comp (Matrix.diagAddMonoidHom m α)) (Matrix.entryAddMonoidHom α i i)","decl":"@[simp] lemma evalAddMonoidHom_comp_diagAddMonoidHom (i : m) :\n    (Pi.evalAddMonoidHom _ i).comp (diagAddMonoidHom m α) = entryAddMonoidHom α i i := by\n  simp [AddMonoidHom.ext_iff]\n\n"}
{"name":"Matrix.entryAddMonoidHom_toAddHom","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : AddZeroClass α\ni : m\nj : n\n⊢ Eq (↑(Matrix.entryAddMonoidHom α i j)) (Matrix.entryAddHom α i j)","decl":"@[simp] lemma entryAddMonoidHom_toAddHom {i : m} {j : n} :\n  (entryAddMonoidHom α i j : AddHom _ _) = entryAddHom α i j := rfl\n\n"}
{"name":"Matrix.entryLinearMap_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid α\ninst✝ : Module R α\ni : m\nj : n\nM : Matrix m n α\n⊢ Eq ((Matrix.entryLinearMap R α i j) M) (M i j)","decl":"variable (R α) in\n/--\nExtracting entries from a matrix as a linear map. Note this cannot be upgraded to an algebra\nhomomorphism, as it does not respect multiplication.\n-/\n@[simps]\ndef entryLinearMap (i : m) (j : n) :\n    Matrix m n α →ₗ[R] α where\n  toFun M := M i j\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\n-- It is necessary to spell out the name of the coercion explicitly on the RHS\n-- for unification to succeed\n"}
{"name":"Matrix.entryLinearMap_eq_comp","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid α\ninst✝ : Module R α\ni : m\nj : n\n⊢ Eq (Matrix.entryLinearMap R α i j) ((LinearMap.proj j).comp ((LinearMap.proj i).comp ↑(Matrix.ofLinearEquiv R).symm))","decl":"lemma entryLinearMap_eq_comp {i : m} {j : n} :\n    entryLinearMap R α i j =\n      LinearMap.proj j ∘ₗ LinearMap.proj i ∘ₗ (ofLinearEquiv R).symm.toLinearMap := by\n  rfl\n\n"}
{"name":"Matrix.proj_comp_diagLinearMap","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nR : Type u_7\nα : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid α\ninst✝ : Module R α\ni : m\n⊢ Eq ((LinearMap.proj i).comp (Matrix.diagLinearMap m R α)) (Matrix.entryLinearMap R α i i)","decl":"@[simp] lemma proj_comp_diagLinearMap (i : m) :\n    LinearMap.proj i ∘ₗ diagLinearMap m R α = entryLinearMap R α i i := by\n  simp [LinearMap.ext_iff]\n\n"}
{"name":"Matrix.entryLinearMap_toAddMonoidHom","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid α\ninst✝ : Module R α\ni : m\nj : n\n⊢ Eq (↑(Matrix.entryLinearMap R α i j)) (Matrix.entryAddMonoidHom α i j)","decl":"@[simp] lemma entryLinearMap_toAddMonoidHom {i : m} {j : n} :\n    (entryLinearMap R α i j : _ →+ _) = entryAddMonoidHom α i j := rfl\n\n"}
{"name":"Matrix.entryLinearMap_toAddHom","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid α\ninst✝ : Module R α\ni : m\nj : n\n⊢ Eq (↑(Matrix.entryLinearMap R α i j)) (Matrix.entryAddHom α i j)","decl":"@[simp] lemma entryLinearMap_toAddHom {i : m} {j : n} :\n    (entryLinearMap R α i j : AddHom _ _) = entryAddHom α i j := rfl\n\n"}
{"name":"Equiv.mapMatrix_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nβ : Type w\nf : Equiv α β\nM : Matrix m n α\n⊢ Eq (f.mapMatrix M) (M.map ⇑f)","decl":"/-- The `Equiv` between spaces of matrices induced by an `Equiv` between their\ncoefficients. This is `Matrix.map` as an `Equiv`. -/\n@[simps apply]\ndef mapMatrix (f : α ≃ β) : Matrix m n α ≃ Matrix m n β where\n  toFun M := M.map f\n  invFun M := M.map f.symm\n  left_inv _ := Matrix.ext fun _ _ => f.symm_apply_apply _\n  right_inv _ := Matrix.ext fun _ _ => f.apply_symm_apply _\n\n"}
{"name":"Equiv.mapMatrix_refl","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\n⊢ Eq (Equiv.refl α).mapMatrix (Equiv.refl (Matrix m n α))","decl":"@[simp]\ntheorem mapMatrix_refl : (Equiv.refl α).mapMatrix = Equiv.refl (Matrix m n α) :=\n  rfl\n\n"}
{"name":"Equiv.mapMatrix_symm","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nβ : Type w\nf : Equiv α β\n⊢ Eq f.mapMatrix.symm f.symm.mapMatrix","decl":"@[simp]\ntheorem mapMatrix_symm (f : α ≃ β) : f.mapMatrix.symm = (f.symm.mapMatrix : Matrix m n β ≃ _) :=\n  rfl\n\n"}
{"name":"Equiv.mapMatrix_trans","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nβ : Type w\nγ : Type u_9\nf : Equiv α β\ng : Equiv β γ\n⊢ Eq (f.mapMatrix.trans g.mapMatrix) (f.trans g).mapMatrix","decl":"@[simp]\ntheorem mapMatrix_trans (f : α ≃ β) (g : β ≃ γ) :\n    f.mapMatrix.trans g.mapMatrix = ((f.trans g).mapMatrix : Matrix m n α ≃ _) :=\n  rfl\n\n"}
{"name":"AddMonoidHom.mapMatrix_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nβ : Type w\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\nf : AddMonoidHom α β\nM : Matrix m n α\n⊢ Eq (f.mapMatrix M) (M.map ⇑f)","decl":"/-- The `AddMonoidHom` between spaces of matrices induced by an `AddMonoidHom` between their\ncoefficients. This is `Matrix.map` as an `AddMonoidHom`. -/\n@[simps]\ndef mapMatrix (f : α →+ β) : Matrix m n α →+ Matrix m n β where\n  toFun M := M.map f\n  map_zero' := Matrix.map_zero f f.map_zero\n  map_add' := Matrix.map_add f f.map_add\n\n"}
{"name":"AddMonoidHom.mapMatrix_id","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : AddZeroClass α\n⊢ Eq (AddMonoidHom.id α).mapMatrix (AddMonoidHom.id (Matrix m n α))","decl":"@[simp]\ntheorem mapMatrix_id : (AddMonoidHom.id α).mapMatrix = AddMonoidHom.id (Matrix m n α) :=\n  rfl\n\n"}
{"name":"AddMonoidHom.mapMatrix_comp","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nβ : Type w\nγ : Type u_9\ninst✝² : AddZeroClass α\ninst✝¹ : AddZeroClass β\ninst✝ : AddZeroClass γ\nf : AddMonoidHom β γ\ng : AddMonoidHom α β\n⊢ Eq (f.mapMatrix.comp g.mapMatrix) (f.comp g).mapMatrix","decl":"@[simp]\ntheorem mapMatrix_comp (f : β →+ γ) (g : α →+ β) :\n    f.mapMatrix.comp g.mapMatrix = ((f.comp g).mapMatrix : Matrix m n α →+ _) :=\n  rfl\n\n"}
{"name":"AddMonoidHom.entryAddMonoidHom_comp_mapMatrix","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nβ : Type w\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\nf : AddMonoidHom α β\ni : m\nj : n\n⊢ Eq ((Matrix.entryAddMonoidHom β i j).comp f.mapMatrix) (f.comp (Matrix.entryAddMonoidHom α i j))","decl":"@[simp] lemma entryAddMonoidHom_comp_mapMatrix (f : α →+ β) (i : m) (j : n) :\n    (entryAddMonoidHom β i j).comp f.mapMatrix = f.comp (entryAddMonoidHom α i j) := rfl\n\n"}
{"name":"AddEquiv.mapMatrix_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nβ : Type w\ninst✝¹ : Add α\ninst✝ : Add β\nf : AddEquiv α β\nM : Matrix m n α\n⊢ Eq (f.mapMatrix M) (M.map ⇑f)","decl":"/-- The `AddEquiv` between spaces of matrices induced by an `AddEquiv` between their\ncoefficients. This is `Matrix.map` as an `AddEquiv`. -/\n@[simps apply]\ndef mapMatrix (f : α ≃+ β) : Matrix m n α ≃+ Matrix m n β :=\n  { f.toEquiv.mapMatrix with\n    toFun := fun M => M.map f\n    invFun := fun M => M.map f.symm\n    map_add' := Matrix.map_add f (map_add f) }\n\n"}
{"name":"AddEquiv.mapMatrix_refl","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : Add α\n⊢ Eq (AddEquiv.refl α).mapMatrix (AddEquiv.refl (Matrix m n α))","decl":"@[simp]\ntheorem mapMatrix_refl : (AddEquiv.refl α).mapMatrix = AddEquiv.refl (Matrix m n α) :=\n  rfl\n\n"}
{"name":"AddEquiv.mapMatrix_symm","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nβ : Type w\ninst✝¹ : Add α\ninst✝ : Add β\nf : AddEquiv α β\n⊢ Eq f.mapMatrix.symm f.symm.mapMatrix","decl":"@[simp]\ntheorem mapMatrix_symm (f : α ≃+ β) : f.mapMatrix.symm = (f.symm.mapMatrix : Matrix m n β ≃+ _) :=\n  rfl\n\n"}
{"name":"AddEquiv.mapMatrix_trans","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nβ : Type w\nγ : Type u_9\ninst✝² : Add α\ninst✝¹ : Add β\ninst✝ : Add γ\nf : AddEquiv α β\ng : AddEquiv β γ\n⊢ Eq (f.mapMatrix.trans g.mapMatrix) (f.trans g).mapMatrix","decl":"@[simp]\ntheorem mapMatrix_trans (f : α ≃+ β) (g : β ≃+ γ) :\n    f.mapMatrix.trans g.mapMatrix = ((f.trans g).mapMatrix : Matrix m n α ≃+ _) :=\n  rfl\n\n"}
{"name":"AddEquiv.entryAddHom_comp_mapMatrix","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nβ : Type w\ninst✝¹ : Add α\ninst✝ : Add β\nf : AddEquiv α β\ni : m\nj : n\n⊢ Eq ((Matrix.entryAddHom β i j).comp ↑f.mapMatrix) ((↑f).comp (Matrix.entryAddHom α i j))","decl":"@[simp] lemma entryAddHom_comp_mapMatrix (f : α ≃+ β) (i : m) (j : n) :\n    (entryAddHom β i j).comp (AddHomClass.toAddHom f.mapMatrix) =\n      (f : AddHom α β).comp (entryAddHom _ i j) := rfl\n\n"}
{"name":"LinearMap.mapMatrix_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\nβ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid α\ninst✝² : AddCommMonoid β\ninst✝¹ : Module R α\ninst✝ : Module R β\nf : LinearMap (RingHom.id R) α β\nM : Matrix m n α\n⊢ Eq (f.mapMatrix M) (M.map ⇑f)","decl":"/-- The `LinearMap` between spaces of matrices induced by a `LinearMap` between their\ncoefficients. This is `Matrix.map` as a `LinearMap`. -/\n@[simps]\ndef mapMatrix (f : α →ₗ[R] β) : Matrix m n α →ₗ[R] Matrix m n β where\n  toFun M := M.map f\n  map_add' := Matrix.map_add f f.map_add\n  map_smul' r := Matrix.map_smul f r (f.map_smul r)\n\n"}
{"name":"LinearMap.mapMatrix_id","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid α\ninst✝ : Module R α\n⊢ Eq LinearMap.id.mapMatrix LinearMap.id","decl":"@[simp]\ntheorem mapMatrix_id : LinearMap.id.mapMatrix = (LinearMap.id : Matrix m n α →ₗ[R] _) :=\n  rfl\n\n"}
{"name":"LinearMap.mapMatrix_comp","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\nβ : Type w\nγ : Type u_9\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid α\ninst✝⁴ : AddCommMonoid β\ninst✝³ : AddCommMonoid γ\ninst✝² : Module R α\ninst✝¹ : Module R β\ninst✝ : Module R γ\nf : LinearMap (RingHom.id R) β γ\ng : LinearMap (RingHom.id R) α β\n⊢ Eq (f.mapMatrix.comp g.mapMatrix) (f.comp g).mapMatrix","decl":"@[simp]\ntheorem mapMatrix_comp (f : β →ₗ[R] γ) (g : α →ₗ[R] β) :\n    f.mapMatrix.comp g.mapMatrix = ((f.comp g).mapMatrix : Matrix m n α →ₗ[R] _) :=\n  rfl\n\n"}
{"name":"LinearMap.entryLinearMap_comp_mapMatrix","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\nβ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid α\ninst✝² : AddCommMonoid β\ninst✝¹ : Module R α\ninst✝ : Module R β\nf : LinearMap (RingHom.id R) α β\ni : m\nj : n\n⊢ Eq ((Matrix.entryLinearMap R β i j).comp f.mapMatrix) (f.comp (Matrix.entryLinearMap R α i j))","decl":"@[simp] lemma entryLinearMap_comp_mapMatrix (f : α →ₗ[R] β) (i : m) (j : n) :\n    entryLinearMap R _ i j ∘ₗ f.mapMatrix = f ∘ₗ entryLinearMap R _ i j := rfl\n\n"}
{"name":"LinearEquiv.mapMatrix_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\nβ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid α\ninst✝² : AddCommMonoid β\ninst✝¹ : Module R α\ninst✝ : Module R β\nf : LinearEquiv (RingHom.id R) α β\nM : Matrix m n α\n⊢ Eq (f.mapMatrix M) (M.map ⇑f)","decl":"/-- The `LinearEquiv` between spaces of matrices induced by a `LinearEquiv` between their\ncoefficients. This is `Matrix.map` as a `LinearEquiv`. -/\n@[simps apply]\ndef mapMatrix (f : α ≃ₗ[R] β) : Matrix m n α ≃ₗ[R] Matrix m n β :=\n  { f.toEquiv.mapMatrix,\n    f.toLinearMap.mapMatrix with\n    toFun := fun M => M.map f\n    invFun := fun M => M.map f.symm }\n\n"}
{"name":"LinearEquiv.mapMatrix_refl","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid α\ninst✝ : Module R α\n⊢ Eq (LinearEquiv.refl R α).mapMatrix (LinearEquiv.refl R (Matrix m n α))","decl":"@[simp]\ntheorem mapMatrix_refl : (LinearEquiv.refl R α).mapMatrix = LinearEquiv.refl R (Matrix m n α) :=\n  rfl\n\n"}
{"name":"LinearEquiv.mapMatrix_symm","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\nβ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid α\ninst✝² : AddCommMonoid β\ninst✝¹ : Module R α\ninst✝ : Module R β\nf : LinearEquiv (RingHom.id R) α β\n⊢ Eq f.mapMatrix.symm f.symm.mapMatrix","decl":"@[simp]\ntheorem mapMatrix_symm (f : α ≃ₗ[R] β) :\n    f.mapMatrix.symm = (f.symm.mapMatrix : Matrix m n β ≃ₗ[R] _) :=\n  rfl\n\n"}
{"name":"LinearEquiv.mapMatrix_trans","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\nβ : Type w\nγ : Type u_9\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid α\ninst✝⁴ : AddCommMonoid β\ninst✝³ : AddCommMonoid γ\ninst✝² : Module R α\ninst✝¹ : Module R β\ninst✝ : Module R γ\nf : LinearEquiv (RingHom.id R) α β\ng : LinearEquiv (RingHom.id R) β γ\n⊢ Eq (f.mapMatrix.trans g.mapMatrix) (f.trans g).mapMatrix","decl":"@[simp]\ntheorem mapMatrix_trans (f : α ≃ₗ[R] β) (g : β ≃ₗ[R] γ) :\n    f.mapMatrix.trans g.mapMatrix = ((f.trans g).mapMatrix : Matrix m n α ≃ₗ[R] _) :=\n  rfl\n\n"}
{"name":"LinearEquiv.mapMatrix_toLinearMap","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\nβ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid α\ninst✝² : AddCommMonoid β\ninst✝¹ : Module R α\ninst✝ : Module R β\nf : LinearEquiv (RingHom.id R) α β\n⊢ Eq (↑f.mapMatrix) (↑f).mapMatrix","decl":"@[simp] lemma mapMatrix_toLinearMap (f : α ≃ₗ[R] β) :\n    (f.mapMatrix : _ ≃ₗ[R] Matrix m n β).toLinearMap = f.toLinearMap.mapMatrix := by\n  rfl\n\n"}
{"name":"LinearEquiv.entryLinearMap_comp_mapMatrix","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\nβ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid α\ninst✝² : AddCommMonoid β\ninst✝¹ : Module R α\ninst✝ : Module R β\nf : LinearEquiv (RingHom.id R) α β\ni : m\nj : n\n⊢ Eq ((Matrix.entryLinearMap R β i j).comp ↑f.mapMatrix) ((↑f).comp (Matrix.entryLinearMap R α i j))","decl":"@[simp] lemma entryLinearMap_comp_mapMatrix (f : α ≃ₗ[R] β) (i : m) (j : n) :\n    entryLinearMap R _ i j ∘ₗ f.mapMatrix.toLinearMap =\n      f.toLinearMap ∘ₗ entryLinearMap R _ i j := by\n  simp only [mapMatrix_toLinearMap, LinearMap.entryLinearMap_comp_mapMatrix]\n\n"}
{"name":"RingHom.mapMatrix_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nα : Type v\nβ : Type w\ninst✝³ : Fintype m\ninst✝² : DecidableEq m\ninst✝¹ : NonAssocSemiring α\ninst✝ : NonAssocSemiring β\nf : RingHom α β\nM : Matrix m m α\n⊢ Eq (f.mapMatrix M) (M.map ⇑f)","decl":"/-- The `RingHom` between spaces of square matrices induced by a `RingHom` between their\ncoefficients. This is `Matrix.map` as a `RingHom`. -/\n@[simps]\ndef mapMatrix (f : α →+* β) : Matrix m m α →+* Matrix m m β :=\n  { f.toAddMonoidHom.mapMatrix with\n    toFun := fun M => M.map f\n    map_one' := by simp\n    map_mul' := fun _ _ => Matrix.map_mul }\n\n"}
{"name":"RingHom.mapMatrix_id","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : NonAssocSemiring α\n⊢ Eq (RingHom.id α).mapMatrix (RingHom.id (Matrix m m α))","decl":"@[simp]\ntheorem mapMatrix_id : (RingHom.id α).mapMatrix = RingHom.id (Matrix m m α) :=\n  rfl\n\n"}
{"name":"RingHom.mapMatrix_comp","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nα : Type v\nβ : Type w\nγ : Type u_9\ninst✝⁴ : Fintype m\ninst✝³ : DecidableEq m\ninst✝² : NonAssocSemiring α\ninst✝¹ : NonAssocSemiring β\ninst✝ : NonAssocSemiring γ\nf : RingHom β γ\ng : RingHom α β\n⊢ Eq (f.mapMatrix.comp g.mapMatrix) (f.comp g).mapMatrix","decl":"@[simp]\ntheorem mapMatrix_comp (f : β →+* γ) (g : α →+* β) :\n    f.mapMatrix.comp g.mapMatrix = ((f.comp g).mapMatrix : Matrix m m α →+* _) :=\n  rfl\n\n"}
{"name":"RingEquiv.mapMatrix_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nα : Type v\nβ : Type w\ninst✝³ : Fintype m\ninst✝² : DecidableEq m\ninst✝¹ : NonAssocSemiring α\ninst✝ : NonAssocSemiring β\nf : RingEquiv α β\nM : Matrix m m α\n⊢ Eq (f.mapMatrix M) (M.map ⇑f)","decl":"/-- The `RingEquiv` between spaces of square matrices induced by a `RingEquiv` between their\ncoefficients. This is `Matrix.map` as a `RingEquiv`. -/\n@[simps apply]\ndef mapMatrix (f : α ≃+* β) : Matrix m m α ≃+* Matrix m m β :=\n  { f.toRingHom.mapMatrix,\n    f.toAddEquiv.mapMatrix with\n    toFun := fun M => M.map f\n    invFun := fun M => M.map f.symm }\n\n"}
{"name":"RingEquiv.mapMatrix_refl","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : NonAssocSemiring α\n⊢ Eq (RingEquiv.refl α).mapMatrix (RingEquiv.refl (Matrix m m α))","decl":"@[simp]\ntheorem mapMatrix_refl : (RingEquiv.refl α).mapMatrix = RingEquiv.refl (Matrix m m α) :=\n  rfl\n\n"}
{"name":"RingEquiv.mapMatrix_symm","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nα : Type v\nβ : Type w\ninst✝³ : Fintype m\ninst✝² : DecidableEq m\ninst✝¹ : NonAssocSemiring α\ninst✝ : NonAssocSemiring β\nf : RingEquiv α β\n⊢ Eq f.mapMatrix.symm f.symm.mapMatrix","decl":"@[simp]\ntheorem mapMatrix_symm (f : α ≃+* β) : f.mapMatrix.symm = (f.symm.mapMatrix : Matrix m m β ≃+* _) :=\n  rfl\n\n"}
{"name":"RingEquiv.mapMatrix_trans","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nα : Type v\nβ : Type w\nγ : Type u_9\ninst✝⁴ : Fintype m\ninst✝³ : DecidableEq m\ninst✝² : NonAssocSemiring α\ninst✝¹ : NonAssocSemiring β\ninst✝ : NonAssocSemiring γ\nf : RingEquiv α β\ng : RingEquiv β γ\n⊢ Eq (f.mapMatrix.trans g.mapMatrix) (f.trans g).mapMatrix","decl":"@[simp]\ntheorem mapMatrix_trans (f : α ≃+* β) (g : β ≃+* γ) :\n    f.mapMatrix.trans g.mapMatrix = ((f.trans g).mapMatrix : Matrix m m α ≃+* _) :=\n  rfl\n\n"}
{"name":"RingEquiv.mopMatrix_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : Fintype m\ninst✝ : NonAssocSemiring α\nM : Matrix m m (MulOpposite α)\n⊢ Eq (RingEquiv.mopMatrix M) (MulOpposite.op (M.transpose.map MulOpposite.unop))","decl":"open MulOpposite in\n/--\nFor any ring `R`, we have ring isomorphism `Matₙₓₙ(Rᵒᵖ) ≅ (Matₙₓₙ(R))ᵒᵖ` given by transpose.\n-/\n@[simps apply symm_apply]\ndef mopMatrix : Matrix m m αᵐᵒᵖ ≃+* (Matrix m m α)ᵐᵒᵖ where\n  toFun M := op (M.transpose.map unop)\n  invFun M := M.unop.transpose.map op\n  left_inv _ := by aesop\n  right_inv _ := by aesop\n  map_mul' _ _ := unop_injective <| by ext; simp [transpose, mul_apply]\n  map_add' _ _ := by aesop\n\n"}
{"name":"RingEquiv.mopMatrix_symm_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : Fintype m\ninst✝ : NonAssocSemiring α\nM : MulOpposite (Matrix m m α)\n⊢ Eq (RingEquiv.mopMatrix.symm M) ((MulOpposite.unop M).transpose.map MulOpposite.op)","decl":"open MulOpposite in\n/--\nFor any ring `R`, we have ring isomorphism `Matₙₓₙ(Rᵒᵖ) ≅ (Matₙₓₙ(R))ᵒᵖ` given by transpose.\n-/\n@[simps apply symm_apply]\ndef mopMatrix : Matrix m m αᵐᵒᵖ ≃+* (Matrix m m α)ᵐᵒᵖ where\n  toFun M := op (M.transpose.map unop)\n  invFun M := M.unop.transpose.map op\n  left_inv _ := by aesop\n  right_inv _ := by aesop\n  map_mul' _ _ := unop_injective <| by ext; simp [transpose, mul_apply]\n  map_add' _ _ := by aesop\n\n"}
{"name":"AlgHom.mapMatrix_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nR : Type u_7\nα : Type v\nβ : Type w\ninst✝⁶ : Fintype m\ninst✝⁵ : DecidableEq m\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring α\ninst✝² : Semiring β\ninst✝¹ : Algebra R α\ninst✝ : Algebra R β\nf : AlgHom R α β\nM : Matrix m m α\n⊢ Eq (f.mapMatrix M) (M.map ⇑f)","decl":"/-- The `AlgHom` between spaces of square matrices induced by an `AlgHom` between their\ncoefficients. This is `Matrix.map` as an `AlgHom`. -/\n@[simps]\ndef mapMatrix (f : α →ₐ[R] β) : Matrix m m α →ₐ[R] Matrix m m β :=\n  { f.toRingHom.mapMatrix with\n    toFun := fun M => M.map f\n    commutes' := fun r => Matrix.map_algebraMap r f (map_zero _) (f.commutes r) }\n\n"}
{"name":"AlgHom.mapMatrix_id","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nR : Type u_7\nα : Type v\ninst✝⁴ : Fintype m\ninst✝³ : DecidableEq m\ninst✝² : CommSemiring R\ninst✝¹ : Semiring α\ninst✝ : Algebra R α\n⊢ Eq (AlgHom.id R α).mapMatrix (AlgHom.id R (Matrix m m α))","decl":"@[simp]\ntheorem mapMatrix_id : (AlgHom.id R α).mapMatrix = AlgHom.id R (Matrix m m α) :=\n  rfl\n\n"}
{"name":"AlgHom.mapMatrix_comp","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nR : Type u_7\nα : Type v\nβ : Type w\nγ : Type u_9\ninst✝⁸ : Fintype m\ninst✝⁷ : DecidableEq m\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring α\ninst✝⁴ : Semiring β\ninst✝³ : Semiring γ\ninst✝² : Algebra R α\ninst✝¹ : Algebra R β\ninst✝ : Algebra R γ\nf : AlgHom R β γ\ng : AlgHom R α β\n⊢ Eq (f.mapMatrix.comp g.mapMatrix) (f.comp g).mapMatrix","decl":"@[simp]\ntheorem mapMatrix_comp (f : β →ₐ[R] γ) (g : α →ₐ[R] β) :\n    f.mapMatrix.comp g.mapMatrix = ((f.comp g).mapMatrix : Matrix m m α →ₐ[R] _) :=\n  rfl\n\n"}
{"name":"AlgEquiv.mapMatrix_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nR : Type u_7\nα : Type v\nβ : Type w\ninst✝⁶ : Fintype m\ninst✝⁵ : DecidableEq m\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring α\ninst✝² : Semiring β\ninst✝¹ : Algebra R α\ninst✝ : Algebra R β\nf : AlgEquiv R α β\nM : Matrix m m α\n⊢ Eq (f.mapMatrix M) (M.map ⇑f)","decl":"/-- The `AlgEquiv` between spaces of square matrices induced by an `AlgEquiv` between their\ncoefficients. This is `Matrix.map` as an `AlgEquiv`. -/\n@[simps apply]\ndef mapMatrix (f : α ≃ₐ[R] β) : Matrix m m α ≃ₐ[R] Matrix m m β :=\n  { f.toAlgHom.mapMatrix,\n    f.toRingEquiv.mapMatrix with\n    toFun := fun M => M.map f\n    invFun := fun M => M.map f.symm }\n\n"}
{"name":"AlgEquiv.mapMatrix_refl","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nR : Type u_7\nα : Type v\ninst✝⁴ : Fintype m\ninst✝³ : DecidableEq m\ninst✝² : CommSemiring R\ninst✝¹ : Semiring α\ninst✝ : Algebra R α\n⊢ Eq AlgEquiv.refl.mapMatrix AlgEquiv.refl","decl":"@[simp]\ntheorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl : Matrix m m α ≃ₐ[R] _) :=\n  rfl\n\n"}
{"name":"AlgEquiv.mapMatrix_symm","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nR : Type u_7\nα : Type v\nβ : Type w\ninst✝⁶ : Fintype m\ninst✝⁵ : DecidableEq m\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring α\ninst✝² : Semiring β\ninst✝¹ : Algebra R α\ninst✝ : Algebra R β\nf : AlgEquiv R α β\n⊢ Eq f.mapMatrix.symm f.symm.mapMatrix","decl":"@[simp]\ntheorem mapMatrix_symm (f : α ≃ₐ[R] β) :\n    f.mapMatrix.symm = (f.symm.mapMatrix : Matrix m m β ≃ₐ[R] _) :=\n  rfl\n\n"}
{"name":"AlgEquiv.mapMatrix_trans","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nR : Type u_7\nα : Type v\nβ : Type w\nγ : Type u_9\ninst✝⁸ : Fintype m\ninst✝⁷ : DecidableEq m\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring α\ninst✝⁴ : Semiring β\ninst✝³ : Semiring γ\ninst✝² : Algebra R α\ninst✝¹ : Algebra R β\ninst✝ : Algebra R γ\nf : AlgEquiv R α β\ng : AlgEquiv R β γ\n⊢ Eq (f.mapMatrix.trans g.mapMatrix) (f.trans g).mapMatrix","decl":"@[simp]\ntheorem mapMatrix_trans (f : α ≃ₐ[R] β) (g : β ≃ₐ[R] γ) :\n    f.mapMatrix.trans g.mapMatrix = ((f.trans g).mapMatrix : Matrix m m α ≃ₐ[R] _) :=\n  rfl\n\n"}
{"name":"Matrix.transposeAddEquiv_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : Add α\nM : Matrix m n α\n⊢ Eq ((Matrix.transposeAddEquiv m n α) M) M.transpose","decl":"/-- `Matrix.transpose` as an `AddEquiv` -/\n@[simps apply]\ndef transposeAddEquiv [Add α] : Matrix m n α ≃+ Matrix n m α where\n  toFun := transpose\n  invFun := transpose\n  left_inv := transpose_transpose\n  right_inv := transpose_transpose\n  map_add' := transpose_add\n\n"}
{"name":"Matrix.transposeAddEquiv_symm","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : Add α\n⊢ Eq (Matrix.transposeAddEquiv m n α).symm (Matrix.transposeAddEquiv n m α)","decl":"@[simp]\ntheorem transposeAddEquiv_symm [Add α] : (transposeAddEquiv m n α).symm = transposeAddEquiv n m α :=\n  rfl\n\n"}
{"name":"Matrix.transpose_list_sum","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : AddMonoid α\nl : List (Matrix m n α)\n⊢ Eq l.sum.transpose (List.map Matrix.transpose l).sum","decl":"theorem transpose_list_sum [AddMonoid α] (l : List (Matrix m n α)) :\n    l.sumᵀ = (l.map transpose).sum :=\n  map_list_sum (transposeAddEquiv m n α) l\n\n"}
{"name":"Matrix.transpose_multiset_sum","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : AddCommMonoid α\ns : Multiset (Matrix m n α)\n⊢ Eq s.sum.transpose (Multiset.map Matrix.transpose s).sum","decl":"theorem transpose_multiset_sum [AddCommMonoid α] (s : Multiset (Matrix m n α)) :\n    s.sumᵀ = (s.map transpose).sum :=\n  (transposeAddEquiv m n α).toAddMonoidHom.map_multiset_sum s\n\n"}
{"name":"Matrix.transpose_sum","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : AddCommMonoid α\nι : Type u_10\ns : Finset ι\nM : ι → Matrix m n α\n⊢ Eq (s.sum fun i => M i).transpose (s.sum fun i => (M i).transpose)","decl":"theorem transpose_sum [AddCommMonoid α] {ι : Type*} (s : Finset ι) (M : ι → Matrix m n α) :\n    (∑ i ∈ s, M i)ᵀ = ∑ i ∈ s, (M i)ᵀ :=\n  map_sum (transposeAddEquiv m n α) _ s\n\n"}
{"name":"Matrix.transposeLinearEquiv_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid α\ninst✝ : Module R α\na✝ : Matrix m n α\n⊢ Eq ((Matrix.transposeLinearEquiv m n R α) a✝) ((Matrix.transposeAddEquiv m n α).toFun a✝)","decl":"/-- `Matrix.transpose` as a `LinearMap` -/\n@[simps apply]\ndef transposeLinearEquiv [Semiring R] [AddCommMonoid α] [Module R α] :\n    Matrix m n α ≃ₗ[R] Matrix n m α :=\n  { transposeAddEquiv m n α with map_smul' := transpose_smul }\n\n"}
{"name":"Matrix.transposeLinearEquiv_symm","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid α\ninst✝ : Module R α\n⊢ Eq (Matrix.transposeLinearEquiv m n R α).symm (Matrix.transposeLinearEquiv n m R α)","decl":"@[simp]\ntheorem transposeLinearEquiv_symm [Semiring R] [AddCommMonoid α] [Module R α] :\n    (transposeLinearEquiv m n R α).symm = transposeLinearEquiv n m R α :=\n  rfl\n\n"}
{"name":"Matrix.transposeRingEquiv_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : AddCommMonoid α\ninst✝¹ : CommSemigroup α\ninst✝ : Fintype m\nM : Matrix m m α\n⊢ Eq ((Matrix.transposeRingEquiv m α) M) (MulOpposite.op M.transpose)","decl":"/-- `Matrix.transpose` as a `RingEquiv` to the opposite ring -/\n@[simps]\ndef transposeRingEquiv [AddCommMonoid α] [CommSemigroup α] [Fintype m] :\n    Matrix m m α ≃+* (Matrix m m α)ᵐᵒᵖ :=\n  { (transposeAddEquiv m m α).trans MulOpposite.opAddEquiv with\n    toFun := fun M => MulOpposite.op Mᵀ\n    invFun := fun M => M.unopᵀ\n    map_mul' := fun M N =>\n      (congr_arg MulOpposite.op (transpose_mul M N)).trans (MulOpposite.op_mul _ _)\n    left_inv := fun M => transpose_transpose M\n    right_inv := fun M => MulOpposite.unop_injective <| transpose_transpose M.unop }\n\n"}
{"name":"Matrix.transposeRingEquiv_symm_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : AddCommMonoid α\ninst✝¹ : CommSemigroup α\ninst✝ : Fintype m\nM : MulOpposite (Matrix m m α)\n⊢ Eq ((Matrix.transposeRingEquiv m α).symm M) (MulOpposite.unop M).transpose","decl":"/-- `Matrix.transpose` as a `RingEquiv` to the opposite ring -/\n@[simps]\ndef transposeRingEquiv [AddCommMonoid α] [CommSemigroup α] [Fintype m] :\n    Matrix m m α ≃+* (Matrix m m α)ᵐᵒᵖ :=\n  { (transposeAddEquiv m m α).trans MulOpposite.opAddEquiv with\n    toFun := fun M => MulOpposite.op Mᵀ\n    invFun := fun M => M.unopᵀ\n    map_mul' := fun M N =>\n      (congr_arg MulOpposite.op (transpose_mul M N)).trans (MulOpposite.op_mul _ _)\n    left_inv := fun M => transpose_transpose M\n    right_inv := fun M => MulOpposite.unop_injective <| transpose_transpose M.unop }\n\n"}
{"name":"Matrix.transpose_pow","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : CommSemiring α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nM : Matrix m m α\nk : Nat\n⊢ Eq (HPow.hPow M k).transpose (HPow.hPow M.transpose k)","decl":"@[simp]\ntheorem transpose_pow [CommSemiring α] [Fintype m] [DecidableEq m] (M : Matrix m m α) (k : ℕ) :\n    (M ^ k)ᵀ = Mᵀ ^ k :=\n  MulOpposite.op_injective <| map_pow (transposeRingEquiv m α) M k\n\n"}
{"name":"Matrix.transpose_list_prod","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : CommSemiring α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nl : List (Matrix m m α)\n⊢ Eq l.prod.transpose (List.map Matrix.transpose l).reverse.prod","decl":"theorem transpose_list_prod [CommSemiring α] [Fintype m] [DecidableEq m] (l : List (Matrix m m α)) :\n    l.prodᵀ = (l.map transpose).reverse.prod :=\n  (transposeRingEquiv m α).unop_map_list_prod l\n\n"}
{"name":"Matrix.transposeAlgEquiv_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nR : Type u_7\nα : Type v\ninst✝⁴ : CommSemiring R\ninst✝³ : CommSemiring α\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : Algebra R α\nM : Matrix m m α\n⊢ Eq ((Matrix.transposeAlgEquiv m R α) M) (MulOpposite.op M.transpose)","decl":"/-- `Matrix.transpose` as an `AlgEquiv` to the opposite ring -/\n@[simps]\ndef transposeAlgEquiv [CommSemiring R] [CommSemiring α] [Fintype m] [DecidableEq m] [Algebra R α] :\n    Matrix m m α ≃ₐ[R] (Matrix m m α)ᵐᵒᵖ :=\n  { (transposeAddEquiv m m α).trans MulOpposite.opAddEquiv,\n    transposeRingEquiv m α with\n    toFun := fun M => MulOpposite.op Mᵀ\n    commutes' := fun r => by\n      simp only [algebraMap_eq_diagonal, diagonal_transpose, MulOpposite.algebraMap_apply] }\n\n"}
{"name":"Matrix.transposeAlgEquiv_symm_apply","module":"Mathlib.Data.Matrix.Basic","initialProofState":"m : Type u_2\nR : Type u_7\nα : Type v\ninst✝⁴ : CommSemiring R\ninst✝³ : CommSemiring α\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : Algebra R α\na✝ : MulOpposite (Matrix m m α)\n⊢ Eq ((Matrix.transposeAlgEquiv m R α).symm a✝) (((Matrix.transposeAddEquiv m m α).trans MulOpposite.opAddEquiv).invFun a✝)","decl":"/-- `Matrix.transpose` as an `AlgEquiv` to the opposite ring -/\n@[simps]\ndef transposeAlgEquiv [CommSemiring R] [CommSemiring α] [Fintype m] [DecidableEq m] [Algebra R α] :\n    Matrix m m α ≃ₐ[R] (Matrix m m α)ᵐᵒᵖ :=\n  { (transposeAddEquiv m m α).trans MulOpposite.opAddEquiv,\n    transposeRingEquiv m α with\n    toFun := fun M => MulOpposite.op Mᵀ\n    commutes' := fun r => by\n      simp only [algebraMap_eq_diagonal, diagonal_transpose, MulOpposite.algebraMap_apply] }\n\n"}
