{"name":"CliffordAlgebra.one_le_evenOdd_zero","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Grading","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ LE.le 1 (CliffordAlgebra.evenOdd Q 0)","decl":"theorem one_le_evenOdd_zero : 1 ≤ evenOdd Q 0 := by\n  refine le_trans ?_ (le_iSup _ ⟨0, Nat.cast_zero⟩)\n  exact (pow_zero _).ge\n\n"}
{"name":"CliffordAlgebra.range_ι_le_evenOdd_one","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Grading","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ LE.le (LinearMap.range (CliffordAlgebra.ι Q)) (CliffordAlgebra.evenOdd Q 1)","decl":"theorem range_ι_le_evenOdd_one : LinearMap.range (ι Q) ≤ evenOdd Q 1 := by\n  refine le_trans ?_ (le_iSup _ ⟨1, Nat.cast_one⟩)\n  exact (pow_one _).ge\n\n"}
{"name":"CliffordAlgebra.ι_mem_evenOdd_one","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Grading","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nm : M\n⊢ Membership.mem (CliffordAlgebra.evenOdd Q 1) ((CliffordAlgebra.ι Q) m)","decl":"theorem ι_mem_evenOdd_one (m : M) : ι Q m ∈ evenOdd Q 1 :=\n  range_ι_le_evenOdd_one Q <| LinearMap.mem_range_self _ m\n\n"}
{"name":"CliffordAlgebra.ι_mul_ι_mem_evenOdd_zero","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Grading","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nm₁ m₂ : M\n⊢ Membership.mem (CliffordAlgebra.evenOdd Q 0) (HMul.hMul ((CliffordAlgebra.ι Q) m₁) ((CliffordAlgebra.ι Q) m₂))","decl":"theorem ι_mul_ι_mem_evenOdd_zero (m₁ m₂ : M) : ι Q m₁ * ι Q m₂ ∈ evenOdd Q 0 :=\n  Submodule.mem_iSup_of_mem ⟨2, rfl⟩\n    (by\n      rw [Subtype.coe_mk, pow_two]\n      exact\n        Submodule.mul_mem_mul (LinearMap.mem_range_self (ι Q) m₁)\n          (LinearMap.mem_range_self (ι Q) m₂))\n\n"}
{"name":"CliffordAlgebra.evenOdd_mul_le","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Grading","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\ni j : ZMod 2\n⊢ LE.le (HMul.hMul (CliffordAlgebra.evenOdd Q i) (CliffordAlgebra.evenOdd Q j)) (CliffordAlgebra.evenOdd Q (HAdd.hAdd i j))","decl":"theorem evenOdd_mul_le (i j : ZMod 2) : evenOdd Q i * evenOdd Q j ≤ evenOdd Q (i + j) := by\n  simp_rw [evenOdd, Submodule.iSup_eq_span, Submodule.span_mul_span]\n  apply Submodule.span_mono\n  simp_rw [Set.iUnion_mul, Set.mul_iUnion, Set.iUnion_subset_iff, Set.mul_subset_iff]\n  rintro ⟨xi, rfl⟩ ⟨yi, rfl⟩ x hx y hy\n  refine Set.mem_iUnion.mpr ⟨⟨xi + yi, Nat.cast_add _ _⟩, ?_⟩\n  simp only [Subtype.coe_mk, Nat.cast_add, pow_add]\n  exact Submodule.mul_mem_mul hx hy\n\n"}
{"name":"CliffordAlgebra.evenOdd.gradedMonoid","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Grading","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ SetLike.GradedMonoid (CliffordAlgebra.evenOdd Q)","decl":"instance evenOdd.gradedMonoid : SetLike.GradedMonoid (evenOdd Q) where\n  one_mem := Submodule.one_le.mp (one_le_evenOdd_zero Q)\n  mul_mem _i _j _p _q hp hq := Submodule.mul_le.mp (evenOdd_mul_le Q _ _) _ hp _ hq\n\n"}
{"name":"CliffordAlgebra.GradedAlgebra.ι_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Grading","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nm : M\n⊢ Eq ((CliffordAlgebra.GradedAlgebra.ι Q) m) ((DirectSum.of (fun i => Subtype fun x => Membership.mem (CliffordAlgebra.evenOdd Q i) x) 1) ⟨(CliffordAlgebra.ι Q) m, ⋯⟩)","decl":"theorem GradedAlgebra.ι_apply (m : M) :\n    GradedAlgebra.ι Q m = DirectSum.of (fun i => ↥(evenOdd Q i)) 1 ⟨ι Q m, ι_mem_evenOdd_one Q m⟩ :=\n  rfl\n\n"}
{"name":"CliffordAlgebra.GradedAlgebra.ι_sq_scalar","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Grading","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nm : M\n⊢ Eq (HMul.hMul ((CliffordAlgebra.GradedAlgebra.ι Q) m) ((CliffordAlgebra.GradedAlgebra.ι Q) m)) ((algebraMap R (DirectSum (ZMod 2) fun i => Subtype fun x => Membership.mem (CliffordAlgebra.evenOdd Q i) x)) (Q m))","decl":"nonrec theorem GradedAlgebra.ι_sq_scalar (m : M) :\n    GradedAlgebra.ι Q m * GradedAlgebra.ι Q m = algebraMap R _ (Q m) := by\n  rw [GradedAlgebra.ι_apply Q, DirectSum.of_mul_of, DirectSum.algebraMap_apply]\n  exact DirectSum.of_eq_of_gradedMonoid_eq (Sigma.subtype_ext rfl <| ι_sq_scalar _ _)\n\n"}
{"name":"CliffordAlgebra.GradedAlgebra.lift_ι_eq","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Grading","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\ni' : ZMod 2\nx' : Subtype fun x => Membership.mem (CliffordAlgebra.evenOdd Q i') x\n⊢ Eq (((CliffordAlgebra.lift Q) ⟨CliffordAlgebra.GradedAlgebra.ι Q, ⋯⟩) ↑x') ((DirectSum.of (fun i => Subtype fun x => Membership.mem (CliffordAlgebra.evenOdd Q i) x) i') x')","decl":"theorem GradedAlgebra.lift_ι_eq (i' : ZMod 2) (x' : evenOdd Q i') :\n    -- Porting note: added a second `by apply`\n    lift Q ⟨by apply GradedAlgebra.ι Q, by apply GradedAlgebra.ι_sq_scalar Q⟩ x' =\n      DirectSum.of (fun i => evenOdd Q i) i' x' := by\n  cases' x' with x' hx'\n  dsimp only [Subtype.coe_mk, DirectSum.lof_eq_of]\n  induction hx' using Submodule.iSup_induction' with\n  | mem i x hx =>\n    obtain ⟨i, rfl⟩ := i\n    dsimp only [Subtype.coe_mk] at hx\n    induction hx using Submodule.pow_induction_on_left' with\n    | algebraMap r =>\n      rw [AlgHom.commutes, DirectSum.algebraMap_apply]; rfl\n    | add x y i hx hy ihx ihy =>\n      rw [map_add, ihx, ihy, ← AddMonoidHom.map_add]\n      rfl\n    | mem_mul m hm i x hx ih =>\n      obtain ⟨_, rfl⟩ := hm\n      rw [map_mul, ih, lift_ι_apply, GradedAlgebra.ι_apply Q, DirectSum.of_mul_of]\n      refine DirectSum.of_eq_of_gradedMonoid_eq (Sigma.subtype_ext ?_ ?_) <;>\n        dsimp only [GradedMonoid.mk, Subtype.coe_mk]\n      · rw [Nat.succ_eq_add_one, add_comm, Nat.cast_add, Nat.cast_one]\n      rfl\n  | zero =>\n    rw [map_zero]\n    apply Eq.symm\n    apply DFinsupp.single_eq_zero.mpr; rfl\n  | add x y hx hy ihx ihy =>\n    rw [map_add, ihx, ihy, ← AddMonoidHom.map_add]; rfl\n\n"}
{"name":"CliffordAlgebra.iSup_ι_range_eq_top","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Grading","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Eq (iSup fun i => HPow.hPow (LinearMap.range (CliffordAlgebra.ι Q)) i) Top.top","decl":"theorem iSup_ι_range_eq_top : ⨆ i : ℕ, LinearMap.range (ι Q) ^ i = ⊤ := by\n  rw [← (DirectSum.Decomposition.isInternal (evenOdd Q)).submodule_iSup_eq_top, eq_comm]\n  calc\n    -- Porting note: needs extra annotations, no longer unifies against the goal in the face of\n    -- ambiguity\n    ⨆ (i : ZMod 2) (j : { n : ℕ // ↑n = i }), LinearMap.range (ι Q) ^ (j : ℕ) =\n        ⨆ i : Σ i : ZMod 2, { n : ℕ // ↑n = i }, LinearMap.range (ι Q) ^ (i.2 : ℕ) := by\n      rw [iSup_sigma]\n    _ = ⨆ i : ℕ, LinearMap.range (ι Q) ^ i :=\n      Function.Surjective.iSup_congr (fun i => i.2) (fun i => ⟨⟨_, i, rfl⟩, rfl⟩) fun _ => rfl\n\n"}
{"name":"CliffordAlgebra.evenOdd_isCompl","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Grading","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ IsCompl (CliffordAlgebra.evenOdd Q 0) (CliffordAlgebra.evenOdd Q 1)","decl":"theorem evenOdd_isCompl : IsCompl (evenOdd Q 0) (evenOdd Q 1) :=\n  (DirectSum.Decomposition.isInternal (evenOdd Q)).isCompl zero_ne_one <| by\n    have : (Finset.univ : Finset (ZMod 2)) = {0, 1} := rfl\n    simpa using congr_arg ((↑) : Finset (ZMod 2) → Set (ZMod 2)) this\n\n"}
{"name":"CliffordAlgebra.evenOdd_induction","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Grading","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nn : ZMod 2\nmotive : (x : CliffordAlgebra Q) → Membership.mem (CliffordAlgebra.evenOdd Q n) x → Prop\nrange_ι_pow : ∀ (v : CliffordAlgebra Q) (h : Membership.mem (HPow.hPow (LinearMap.range (CliffordAlgebra.ι Q)) n.val) v), motive v ⋯\nadd : ∀ (x y : CliffordAlgebra Q) (hx : Membership.mem (CliffordAlgebra.evenOdd Q n) x) (hy : Membership.mem (CliffordAlgebra.evenOdd Q n) y), motive x hx → motive y hy → motive (HAdd.hAdd x y) ⋯\nι_mul_ι_mul : ∀ (m₁ m₂ : M) (x : CliffordAlgebra Q) (hx : Membership.mem (CliffordAlgebra.evenOdd Q n) x), motive x hx → motive (HMul.hMul (HMul.hMul ((CliffordAlgebra.ι Q) m₁) ((CliffordAlgebra.ι Q) m₂)) x) ⋯\nx : CliffordAlgebra Q\nhx : Membership.mem (CliffordAlgebra.evenOdd Q n) x\n⊢ motive x hx","decl":"/-- To show a property is true on the even or odd part, it suffices to show it is true on the\nscalars or vectors (respectively), closed under addition, and under left-multiplication by a pair\nof vectors. -/\n@[elab_as_elim]\ntheorem evenOdd_induction (n : ZMod 2) {motive : ∀ x, x ∈ evenOdd Q n → Prop}\n    (range_ι_pow : ∀ (v) (h : v ∈ LinearMap.range (ι Q) ^ n.val),\n        motive v (Submodule.mem_iSup_of_mem ⟨n.val, n.natCast_zmod_val⟩ h))\n    (add : ∀ x y hx hy, motive x hx → motive y hy → motive (x + y) (Submodule.add_mem _ hx hy))\n    (ι_mul_ι_mul :\n      ∀ m₁ m₂ x hx,\n        motive x hx →\n          motive (ι Q m₁ * ι Q m₂ * x)\n            (zero_add n ▸ SetLike.mul_mem_graded (ι_mul_ι_mem_evenOdd_zero Q m₁ m₂) hx))\n    (x : CliffordAlgebra Q) (hx : x ∈ evenOdd Q n) : motive x hx := by\n  apply Submodule.iSup_induction' (C := motive) _ _ (range_ι_pow 0 (Submodule.zero_mem _)) add\n  refine Subtype.rec ?_\n  simp_rw [ZMod.natCast_eq_iff, add_comm n.val]\n  rintro n' ⟨k, rfl⟩ xv\n  simp_rw [pow_add, pow_mul]\n  intro hxv\n  induction hxv using Submodule.mul_induction_on' with\n  | mem_mul_mem a ha b hb =>\n    induction ha using Submodule.pow_induction_on_left' with\n    | algebraMap r =>\n      simp_rw [← Algebra.smul_def]\n      exact range_ι_pow _ (Submodule.smul_mem _ _ hb)\n    | add x y n hx hy ihx ihy =>\n      simp_rw [add_mul]\n      apply add _ _ _ _ ihx ihy\n    | mem_mul x hx n'' y hy ihy =>\n      revert hx\n      simp_rw [pow_two]\n      intro hx2\n      induction hx2 using Submodule.mul_induction_on' with\n      | mem_mul_mem m hm n hn =>\n        simp_rw [LinearMap.mem_range] at hm hn\n        obtain ⟨m₁, rfl⟩ := hm; obtain ⟨m₂, rfl⟩ := hn\n        simp_rw [mul_assoc _ y b]\n        exact ι_mul_ι_mul _ _ _ _ ihy\n      | add x hx y hy ihx ihy =>\n        simp_rw [add_mul]\n        apply add _ _ _ _ ihx ihy\n  | add x y hx hy ihx ihy =>\n    apply add _ _ _ _ ihx ihy\n\n"}
{"name":"CliffordAlgebra.even_induction","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Grading","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nmotive : (x : CliffordAlgebra Q) → Membership.mem (CliffordAlgebra.evenOdd Q 0) x → Prop\nalgebraMap : ∀ (r : R), motive ((_root_.algebraMap R (CliffordAlgebra Q)) r) ⋯\nadd : ∀ (x y : CliffordAlgebra Q) (hx : Membership.mem (CliffordAlgebra.evenOdd Q 0) x) (hy : Membership.mem (CliffordAlgebra.evenOdd Q 0) y), motive x hx → motive y hy → motive (HAdd.hAdd x y) ⋯\nι_mul_ι_mul : ∀ (m₁ m₂ : M) (x : CliffordAlgebra Q) (hx : Membership.mem (CliffordAlgebra.evenOdd Q 0) x), motive x hx → motive (HMul.hMul (HMul.hMul ((CliffordAlgebra.ι Q) m₁) ((CliffordAlgebra.ι Q) m₂)) x) ⋯\nx : CliffordAlgebra Q\nhx : Membership.mem (CliffordAlgebra.evenOdd Q 0) x\n⊢ motive x hx","decl":"/-- To show a property is true on the even parts, it suffices to show it is true on the\nscalars, closed under addition, and under left-multiplication by a pair of vectors. -/\n@[elab_as_elim]\ntheorem even_induction {motive : ∀ x, x ∈ evenOdd Q 0 → Prop}\n    (algebraMap : ∀ r : R, motive (algebraMap _ _ r) (SetLike.algebraMap_mem_graded _ _))\n    (add : ∀ x y hx hy, motive x hx → motive y hy → motive (x + y) (Submodule.add_mem _ hx hy))\n    (ι_mul_ι_mul :\n      ∀ m₁ m₂ x hx,\n        motive x hx →\n          motive (ι Q m₁ * ι Q m₂ * x)\n            (zero_add (0 : ZMod 2) ▸ SetLike.mul_mem_graded (ι_mul_ι_mem_evenOdd_zero Q m₁ m₂) hx))\n    (x : CliffordAlgebra Q) (hx : x ∈ evenOdd Q 0) : motive x hx := by\n  refine evenOdd_induction _ _ (motive := motive) (fun rx h => ?_) add ι_mul_ι_mul x hx\n  obtain ⟨r, rfl⟩ := Submodule.mem_one.mp h\n  exact algebraMap r\n\n"}
{"name":"CliffordAlgebra.odd_induction","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Grading","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nP : (x : CliffordAlgebra Q) → Membership.mem (CliffordAlgebra.evenOdd Q 1) x → Prop\nι : ∀ (v : M), P ((CliffordAlgebra.ι Q) v) ⋯\nadd : ∀ (x y : CliffordAlgebra Q) (hx : Membership.mem (CliffordAlgebra.evenOdd Q 1) x) (hy : Membership.mem (CliffordAlgebra.evenOdd Q 1) y), P x hx → P y hy → P (HAdd.hAdd x y) ⋯\nι_mul_ι_mul : ∀ (m₁ m₂ : M) (x : CliffordAlgebra Q) (hx : Membership.mem (CliffordAlgebra.evenOdd Q 1) x), P x hx → P (HMul.hMul (HMul.hMul ((CliffordAlgebra.ι Q) m₁) ((CliffordAlgebra.ι Q) m₂)) x) ⋯\nx : CliffordAlgebra Q\nhx : Membership.mem (CliffordAlgebra.evenOdd Q 1) x\n⊢ P x hx","decl":"/-- To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. -/\n@[elab_as_elim]\ntheorem odd_induction {P : ∀ x, x ∈ evenOdd Q 1 → Prop}\n    (ι : ∀ v, P (ι Q v) (ι_mem_evenOdd_one _ _))\n    (add : ∀ x y hx hy, P x hx → P y hy → P (x + y) (Submodule.add_mem _ hx hy))\n    (ι_mul_ι_mul :\n      ∀ m₁ m₂ x hx,\n        P x hx →\n          P (CliffordAlgebra.ι Q m₁ * CliffordAlgebra.ι Q m₂ * x)\n            (zero_add (1 : ZMod 2) ▸ SetLike.mul_mem_graded (ι_mul_ι_mem_evenOdd_zero Q m₁ m₂) hx))\n    (x : CliffordAlgebra Q) (hx : x ∈ evenOdd Q 1) : P x hx := by\n  refine evenOdd_induction _ _ (motive := P) (fun ιv => ?_) add ι_mul_ι_mul x hx\n  simp_rw [ZMod.val_one, pow_one]\n  rintro ⟨v, rfl⟩\n  exact ι v\n\n"}
