{"name":"Complex.integral_boundary_rect_of_hasFDerivAt_real_off_countable","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf : Complex → E\nf' : Complex → ContinuousLinearMap (RingHom.id Real) Complex E\nz w : Complex\ns : Set Complex\nhs : s.Countable\nHc : ContinuousOn f (Complex.reProdIm (Set.uIcc z.re w.re) (Set.uIcc z.im w.im))\nHd : ∀ (x : Complex), Membership.mem (SDiff.sdiff (Complex.reProdIm (Set.Ioo (Min.min z.re w.re) (Max.max z.re w.re)) (Set.Ioo (Min.min z.im w.im) (Max.max z.im w.im))) s) x → HasFDerivAt f (f' x) x\nHi : MeasureTheory.IntegrableOn (fun z => HSub.hSub (HSMul.hSMul Complex.I ((f' z) 1)) ((f' z) Complex.I)) (Complex.reProdIm (Set.uIcc z.re w.re) (Set.uIcc z.im w.im)) MeasureTheory.MeasureSpace.volume\n⊢ Eq (HSub.hSub (HAdd.hAdd (HSub.hSub (intervalIntegral (fun x => f (HAdd.hAdd (↑x) (HMul.hMul (↑z.im) Complex.I))) z.re w.re MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => f (HAdd.hAdd (↑x) (HMul.hMul (↑w.im) Complex.I))) z.re w.re MeasureTheory.MeasureSpace.volume)) (HSMul.hSMul Complex.I (intervalIntegral (fun y => f (HAdd.hAdd (↑w.re) (HMul.hMul (↑y) Complex.I))) z.im w.im MeasureTheory.MeasureSpace.volume))) (HSMul.hSMul Complex.I (intervalIntegral (fun y => f (HAdd.hAdd (↑z.re) (HMul.hMul (↑y) Complex.I))) z.im w.im MeasureTheory.MeasureSpace.volume))) (intervalIntegral (fun x => intervalIntegral (fun y => HSub.hSub (HSMul.hSMul Complex.I ((f' (HAdd.hAdd (↑x) (HMul.hMul (↑y) Complex.I))) 1)) ((f' (HAdd.hAdd (↑x) (HMul.hMul (↑y) Complex.I))) Complex.I)) z.im w.im MeasureTheory.MeasureSpace.volume) z.re w.re MeasureTheory.MeasureSpace.volume)","decl":"/-- Suppose that a function `f : ℂ → E` is continuous on a closed rectangle with opposite corners at\n`z w : ℂ`, is *real* differentiable at all but countably many points of the corresponding open\nrectangle, and $\\frac{\\partial f}{\\partial \\bar z}$ is integrable on this rectangle. Then the\nintegral of `f` over the boundary of the rectangle is equal to the integral of\n$2i\\frac{\\partial f}{\\partial \\bar z}=i\\frac{\\partial f}{\\partial x}-\\frac{\\partial f}{\\partial y}$\nover the rectangle. -/\ntheorem integral_boundary_rect_of_hasFDerivAt_real_off_countable (f : ℂ → E) (f' : ℂ → ℂ →L[ℝ] E)\n    (z w : ℂ) (s : Set ℂ) (hs : s.Countable)\n    (Hc : ContinuousOn f ([[z.re, w.re]] ×ℂ [[z.im, w.im]]))\n    (Hd : ∀ x ∈ Ioo (min z.re w.re) (max z.re w.re) ×ℂ Ioo (min z.im w.im) (max z.im w.im) \\ s,\n      HasFDerivAt f (f' x) x)\n    (Hi : IntegrableOn (fun z => I • f' z 1 - f' z I) ([[z.re, w.re]] ×ℂ [[z.im, w.im]])) :\n    (∫ x : ℝ in z.re..w.re, f (x + z.im * I)) - (∫ x : ℝ in z.re..w.re, f (x + w.im * I)) +\n      I • (∫ y : ℝ in z.im..w.im, f (re w + y * I)) -\n      I • ∫ y : ℝ in z.im..w.im, f (re z + y * I) =\n      ∫ x : ℝ in z.re..w.re, ∫ y : ℝ in z.im..w.im, I • f' (x + y * I) 1 - f' (x + y * I) I := by\n  set e : (ℝ × ℝ) ≃L[ℝ] ℂ := equivRealProdCLM.symm\n  have he : ∀ x y : ℝ, ↑x + ↑y * I = e (x, y) := fun x y => (mk_eq_add_mul_I x y).symm\n  have he₁ : e (1, 0) = 1 := rfl; have he₂ : e (0, 1) = I := rfl\n  simp only [he] at *\n  set F : ℝ × ℝ → E := f ∘ e\n  set F' : ℝ × ℝ → ℝ × ℝ →L[ℝ] E := fun p => (f' (e p)).comp (e : ℝ × ℝ →L[ℝ] ℂ)\n  have hF' : ∀ p : ℝ × ℝ, (-(I • F' p)) (1, 0) + F' p (0, 1) = -(I • f' (e p) 1 - f' (e p) I) := by\n    rintro ⟨x, y⟩\n    simp only [F', ContinuousLinearMap.neg_apply, ContinuousLinearMap.smul_apply,\n      ContinuousLinearMap.comp_apply, ContinuousLinearEquiv.coe_coe, he₁, he₂, neg_add_eq_sub,\n      neg_sub]\n  set R : Set (ℝ × ℝ) := [[z.re, w.re]] ×ˢ [[w.im, z.im]]\n  set t : Set (ℝ × ℝ) := e ⁻¹' s\n  rw [uIcc_comm z.im] at Hc Hi; rw [min_comm z.im, max_comm z.im] at Hd\n  have hR : e ⁻¹' ([[z.re, w.re]] ×ℂ [[w.im, z.im]]) = R := rfl\n  have htc : ContinuousOn F R := Hc.comp e.continuousOn hR.ge\n  have htd :\n    ∀ p ∈ Ioo (min z.re w.re) (max z.re w.re) ×ˢ Ioo (min w.im z.im) (max w.im z.im) \\ t,\n      HasFDerivAt F (F' p) p :=\n    fun p hp => (Hd (e p) hp).comp p e.hasFDerivAt\n  simp_rw [← intervalIntegral.integral_smul, intervalIntegral.integral_symm w.im z.im, ←\n    intervalIntegral.integral_neg, ← hF']\n  refine (integral2_divergence_prod_of_hasFDerivWithinAt_off_countable (fun p => -(I • F p)) F\n    (fun p => -(I • F' p)) F' z.re w.im w.re z.im t (hs.preimage e.injective)\n    (htc.const_smul _).neg htc (fun p hp => ((htd p hp).const_smul I).neg) htd ?_).symm\n  rw [← (volume_preserving_equiv_real_prod.symm _).integrableOn_comp_preimage\n    (MeasurableEquiv.measurableEmbedding _)] at Hi\n  simpa only [hF'] using Hi.neg\n\n"}
{"name":"Complex.integral_boundary_rect_of_continuousOn_of_hasFDerivAt_real","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf : Complex → E\nf' : Complex → ContinuousLinearMap (RingHom.id Real) Complex E\nz w : Complex\nHc : ContinuousOn f (Complex.reProdIm (Set.uIcc z.re w.re) (Set.uIcc z.im w.im))\nHd : ∀ (x : Complex), Membership.mem (Complex.reProdIm (Set.Ioo (Min.min z.re w.re) (Max.max z.re w.re)) (Set.Ioo (Min.min z.im w.im) (Max.max z.im w.im))) x → HasFDerivAt f (f' x) x\nHi : MeasureTheory.IntegrableOn (fun z => HSub.hSub (HSMul.hSMul Complex.I ((f' z) 1)) ((f' z) Complex.I)) (Complex.reProdIm (Set.uIcc z.re w.re) (Set.uIcc z.im w.im)) MeasureTheory.MeasureSpace.volume\n⊢ Eq (HSub.hSub (HAdd.hAdd (HSub.hSub (intervalIntegral (fun x => f (HAdd.hAdd (↑x) (HMul.hMul (↑z.im) Complex.I))) z.re w.re MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => f (HAdd.hAdd (↑x) (HMul.hMul (↑w.im) Complex.I))) z.re w.re MeasureTheory.MeasureSpace.volume)) (HSMul.hSMul Complex.I (intervalIntegral (fun y => f (HAdd.hAdd (↑w.re) (HMul.hMul (↑y) Complex.I))) z.im w.im MeasureTheory.MeasureSpace.volume))) (HSMul.hSMul Complex.I (intervalIntegral (fun y => f (HAdd.hAdd (↑z.re) (HMul.hMul (↑y) Complex.I))) z.im w.im MeasureTheory.MeasureSpace.volume))) (intervalIntegral (fun x => intervalIntegral (fun y => HSub.hSub (HSMul.hSMul Complex.I ((f' (HAdd.hAdd (↑x) (HMul.hMul (↑y) Complex.I))) 1)) ((f' (HAdd.hAdd (↑x) (HMul.hMul (↑y) Complex.I))) Complex.I)) z.im w.im MeasureTheory.MeasureSpace.volume) z.re w.re MeasureTheory.MeasureSpace.volume)","decl":"/-- Suppose that a function `f : ℂ → E` is continuous on a closed rectangle with opposite corners at\n`z w : ℂ`, is *real* differentiable on the corresponding open rectangle, and\n$\\frac{\\partial f}{\\partial \\bar z}$ is integrable on this rectangle. Then the integral of `f` over\nthe boundary of the rectangle is equal to the integral of\n$2i\\frac{\\partial f}{\\partial \\bar z}=i\\frac{\\partial f}{\\partial x}-\\frac{\\partial f}{\\partial y}$\nover the rectangle. -/\ntheorem integral_boundary_rect_of_continuousOn_of_hasFDerivAt_real (f : ℂ → E) (f' : ℂ → ℂ →L[ℝ] E)\n    (z w : ℂ) (Hc : ContinuousOn f ([[z.re, w.re]] ×ℂ [[z.im, w.im]]))\n    (Hd : ∀ x ∈ Ioo (min z.re w.re) (max z.re w.re) ×ℂ Ioo (min z.im w.im) (max z.im w.im),\n      HasFDerivAt f (f' x) x)\n    (Hi : IntegrableOn (fun z => I • f' z 1 - f' z I) ([[z.re, w.re]] ×ℂ [[z.im, w.im]])) :\n    (∫ x : ℝ in z.re..w.re, f (x + z.im * I)) - (∫ x : ℝ in z.re..w.re, f (x + w.im * I)) +\n      I • (∫ y : ℝ in z.im..w.im, f (re w + y * I)) -\n      I • (∫ y : ℝ in z.im..w.im, f (re z + y * I)) =\n      ∫ x : ℝ in z.re..w.re, ∫ y : ℝ in z.im..w.im, I • f' (x + y * I) 1 - f' (x + y * I) I :=\n  integral_boundary_rect_of_hasFDerivAt_real_off_countable f f' z w ∅ countable_empty Hc\n    (fun x hx => Hd x hx.1) Hi\n\n"}
{"name":"Complex.integral_boundary_rect_of_differentiableOn_real","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf : Complex → E\nz w : Complex\nHd : DifferentiableOn Real f (Complex.reProdIm (Set.uIcc z.re w.re) (Set.uIcc z.im w.im))\nHi : MeasureTheory.IntegrableOn (fun z => HSub.hSub (HSMul.hSMul Complex.I ((fderiv Real f z) 1)) ((fderiv Real f z) Complex.I)) (Complex.reProdIm (Set.uIcc z.re w.re) (Set.uIcc z.im w.im)) MeasureTheory.MeasureSpace.volume\n⊢ Eq (HSub.hSub (HAdd.hAdd (HSub.hSub (intervalIntegral (fun x => f (HAdd.hAdd (↑x) (HMul.hMul (↑z.im) Complex.I))) z.re w.re MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => f (HAdd.hAdd (↑x) (HMul.hMul (↑w.im) Complex.I))) z.re w.re MeasureTheory.MeasureSpace.volume)) (HSMul.hSMul Complex.I (intervalIntegral (fun y => f (HAdd.hAdd (↑w.re) (HMul.hMul (↑y) Complex.I))) z.im w.im MeasureTheory.MeasureSpace.volume))) (HSMul.hSMul Complex.I (intervalIntegral (fun y => f (HAdd.hAdd (↑z.re) (HMul.hMul (↑y) Complex.I))) z.im w.im MeasureTheory.MeasureSpace.volume))) (intervalIntegral (fun x => intervalIntegral (fun y => HSub.hSub (HSMul.hSMul Complex.I ((fderiv Real f (HAdd.hAdd (↑x) (HMul.hMul (↑y) Complex.I))) 1)) ((fderiv Real f (HAdd.hAdd (↑x) (HMul.hMul (↑y) Complex.I))) Complex.I)) z.im w.im MeasureTheory.MeasureSpace.volume) z.re w.re MeasureTheory.MeasureSpace.volume)","decl":"/-- Suppose that a function `f : ℂ → E` is *real* differentiable on a closed rectangle with opposite\ncorners at `z w : ℂ` and $\\frac{\\partial f}{\\partial \\bar z}$ is integrable on this rectangle. Then\nthe integral of `f` over the boundary of the rectangle is equal to the integral of\n$2i\\frac{\\partial f}{\\partial \\bar z}=i\\frac{\\partial f}{\\partial x}-\\frac{\\partial f}{\\partial y}$\nover the rectangle. -/\ntheorem integral_boundary_rect_of_differentiableOn_real (f : ℂ → E) (z w : ℂ)\n    (Hd : DifferentiableOn ℝ f ([[z.re, w.re]] ×ℂ [[z.im, w.im]]))\n    (Hi : IntegrableOn (fun z => I • fderiv ℝ f z 1 - fderiv ℝ f z I)\n      ([[z.re, w.re]] ×ℂ [[z.im, w.im]])) :\n    (∫ x : ℝ in z.re..w.re, f (x + z.im * I)) - (∫ x : ℝ in z.re..w.re, f (x + w.im * I)) +\n      I • (∫ y : ℝ in z.im..w.im, f (re w + y * I)) -\n      I • (∫ y : ℝ in z.im..w.im, f (re z + y * I)) =\n      ∫ x : ℝ in z.re..w.re, ∫ y : ℝ in z.im..w.im,\n        I • fderiv ℝ f (x + y * I) 1 - fderiv ℝ f (x + y * I) I :=\n  integral_boundary_rect_of_hasFDerivAt_real_off_countable f (fderiv ℝ f) z w ∅ countable_empty\n    Hd.continuousOn\n    (fun x hx => Hd.hasFDerivAt <| by\n      simpa only [← mem_interior_iff_mem_nhds, interior_reProdIm, uIcc, interior_Icc] using hx.1)\n    Hi\n\n"}
{"name":"Complex.integral_boundary_rect_eq_zero_of_differentiable_on_off_countable","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf : Complex → E\nz w : Complex\ns : Set Complex\nhs : s.Countable\nHc : ContinuousOn f (Complex.reProdIm (Set.uIcc z.re w.re) (Set.uIcc z.im w.im))\nHd : ∀ (x : Complex), Membership.mem (SDiff.sdiff (Complex.reProdIm (Set.Ioo (Min.min z.re w.re) (Max.max z.re w.re)) (Set.Ioo (Min.min z.im w.im) (Max.max z.im w.im))) s) x → DifferentiableAt Complex f x\n⊢ Eq (HSub.hSub (HAdd.hAdd (HSub.hSub (intervalIntegral (fun x => f (HAdd.hAdd (↑x) (HMul.hMul (↑z.im) Complex.I))) z.re w.re MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => f (HAdd.hAdd (↑x) (HMul.hMul (↑w.im) Complex.I))) z.re w.re MeasureTheory.MeasureSpace.volume)) (HSMul.hSMul Complex.I (intervalIntegral (fun y => f (HAdd.hAdd (↑w.re) (HMul.hMul (↑y) Complex.I))) z.im w.im MeasureTheory.MeasureSpace.volume))) (HSMul.hSMul Complex.I (intervalIntegral (fun y => f (HAdd.hAdd (↑z.re) (HMul.hMul (↑y) Complex.I))) z.im w.im MeasureTheory.MeasureSpace.volume))) 0","decl":"/-- **Cauchy-Goursat theorem** for a rectangle: the integral of a complex differentiable function\nover the boundary of a rectangle equals zero. More precisely, if `f` is continuous on a closed\nrectangle and is complex differentiable at all but countably many points of the corresponding open\nrectangle, then its integral over the boundary of the rectangle equals zero. -/\ntheorem integral_boundary_rect_eq_zero_of_differentiable_on_off_countable (f : ℂ → E) (z w : ℂ)\n    (s : Set ℂ) (hs : s.Countable) (Hc : ContinuousOn f ([[z.re, w.re]] ×ℂ [[z.im, w.im]]))\n    (Hd : ∀ x ∈ Ioo (min z.re w.re) (max z.re w.re) ×ℂ Ioo (min z.im w.im) (max z.im w.im) \\ s,\n      DifferentiableAt ℂ f x) :\n    (∫ x : ℝ in z.re..w.re, f (x + z.im * I)) - (∫ x : ℝ in z.re..w.re, f (x + w.im * I)) +\n      I • (∫ y : ℝ in z.im..w.im, f (re w + y * I)) -\n      I • (∫ y : ℝ in z.im..w.im, f (re z + y * I)) = 0 := by\n  refine (integral_boundary_rect_of_hasFDerivAt_real_off_countable f\n    (fun z => (fderiv ℂ f z).restrictScalars ℝ) z w s hs Hc\n    (fun x hx => (Hd x hx).hasFDerivAt.restrictScalars ℝ) ?_).trans ?_ <;>\n      simp [← ContinuousLinearMap.map_smul]\n\n"}
{"name":"Complex.integral_boundary_rect_eq_zero_of_continuousOn_of_differentiableOn","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf : Complex → E\nz w : Complex\nHc : ContinuousOn f (Complex.reProdIm (Set.uIcc z.re w.re) (Set.uIcc z.im w.im))\nHd : DifferentiableOn Complex f (Complex.reProdIm (Set.Ioo (Min.min z.re w.re) (Max.max z.re w.re)) (Set.Ioo (Min.min z.im w.im) (Max.max z.im w.im)))\n⊢ Eq (HSub.hSub (HAdd.hAdd (HSub.hSub (intervalIntegral (fun x => f (HAdd.hAdd (↑x) (HMul.hMul (↑z.im) Complex.I))) z.re w.re MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => f (HAdd.hAdd (↑x) (HMul.hMul (↑w.im) Complex.I))) z.re w.re MeasureTheory.MeasureSpace.volume)) (HSMul.hSMul Complex.I (intervalIntegral (fun y => f (HAdd.hAdd (↑w.re) (HMul.hMul (↑y) Complex.I))) z.im w.im MeasureTheory.MeasureSpace.volume))) (HSMul.hSMul Complex.I (intervalIntegral (fun y => f (HAdd.hAdd (↑z.re) (HMul.hMul (↑y) Complex.I))) z.im w.im MeasureTheory.MeasureSpace.volume))) 0","decl":"/-- **Cauchy-Goursat theorem for a rectangle**: the integral of a complex differentiable function\nover the boundary of a rectangle equals zero. More precisely, if `f` is continuous on a closed\nrectangle and is complex differentiable on the corresponding open rectangle, then its integral over\nthe boundary of the rectangle equals zero. -/\ntheorem integral_boundary_rect_eq_zero_of_continuousOn_of_differentiableOn (f : ℂ → E) (z w : ℂ)\n    (Hc : ContinuousOn f ([[z.re, w.re]] ×ℂ [[z.im, w.im]]))\n    (Hd : DifferentiableOn ℂ f\n      (Ioo (min z.re w.re) (max z.re w.re) ×ℂ Ioo (min z.im w.im) (max z.im w.im))) :\n    (∫ x : ℝ in z.re..w.re, f (x + z.im * I)) - (∫ x : ℝ in z.re..w.re, f (x + w.im * I)) +\n      I • (∫ y : ℝ in z.im..w.im, f (re w + y * I)) -\n      I • (∫ y : ℝ in z.im..w.im, f (re z + y * I)) = 0 :=\n  integral_boundary_rect_eq_zero_of_differentiable_on_off_countable f z w ∅ countable_empty Hc\n    fun _x hx => Hd.differentiableAt <| (isOpen_Ioo.reProdIm isOpen_Ioo).mem_nhds hx.1\n\n"}
{"name":"Complex.integral_boundary_rect_eq_zero_of_differentiableOn","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf : Complex → E\nz w : Complex\nH : DifferentiableOn Complex f (Complex.reProdIm (Set.uIcc z.re w.re) (Set.uIcc z.im w.im))\n⊢ Eq (HSub.hSub (HAdd.hAdd (HSub.hSub (intervalIntegral (fun x => f (HAdd.hAdd (↑x) (HMul.hMul (↑z.im) Complex.I))) z.re w.re MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => f (HAdd.hAdd (↑x) (HMul.hMul (↑w.im) Complex.I))) z.re w.re MeasureTheory.MeasureSpace.volume)) (HSMul.hSMul Complex.I (intervalIntegral (fun y => f (HAdd.hAdd (↑w.re) (HMul.hMul (↑y) Complex.I))) z.im w.im MeasureTheory.MeasureSpace.volume))) (HSMul.hSMul Complex.I (intervalIntegral (fun y => f (HAdd.hAdd (↑z.re) (HMul.hMul (↑y) Complex.I))) z.im w.im MeasureTheory.MeasureSpace.volume))) 0","decl":"/-- **Cauchy-Goursat theorem** for a rectangle: the integral of a complex differentiable function\nover the boundary of a rectangle equals zero. More precisely, if `f` is complex differentiable on a\nclosed rectangle, then its integral over the boundary of the rectangle equals zero. -/\ntheorem integral_boundary_rect_eq_zero_of_differentiableOn (f : ℂ → E) (z w : ℂ)\n    (H : DifferentiableOn ℂ f ([[z.re, w.re]] ×ℂ [[z.im, w.im]])) :\n    (∫ x : ℝ in z.re..w.re, f (x + z.im * I)) - (∫ x : ℝ in z.re..w.re, f (x + w.im * I)) +\n      I • (∫ y : ℝ in z.im..w.im, f (re w + y * I)) -\n      I • (∫ y : ℝ in z.im..w.im, f (re z + y * I)) = 0 :=\n  integral_boundary_rect_eq_zero_of_continuousOn_of_differentiableOn f z w H.continuousOn <|\n    H.mono <|\n      inter_subset_inter (preimage_mono Ioo_subset_Icc_self) (preimage_mono Ioo_subset_Icc_self)\n\n"}
{"name":"Complex.circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nc : Complex\nr R : Real\nh0 : LT.lt 0 r\nhle : LE.le r R\nf : Complex → E\ns : Set Complex\nhs : s.Countable\nhc : ContinuousOn f (SDiff.sdiff (Metric.closedBall c R) (Metric.ball c r))\nhd : ∀ (z : Complex), Membership.mem (SDiff.sdiff (SDiff.sdiff (Metric.ball c R) (Metric.closedBall c r)) s) z → DifferentiableAt Complex f z\n⊢ Eq (circleIntegral (fun z => HSMul.hSMul (Inv.inv (HSub.hSub z c)) (f z)) c R) (circleIntegral (fun z => HSMul.hSMul (Inv.inv (HSub.hSub z c)) (f z)) c r)","decl":"/-- If `f : ℂ → E` is continuous on the closed annulus `r ≤ ‖z - c‖ ≤ R`, `0 < r ≤ R`,\nand is complex differentiable at all but countably many points of its interior,\nthen the integrals of `f z / (z - c)` (formally, `(z - c)⁻¹ • f z`)\nover the circles `‖z - c‖ = r` and `‖z - c‖ = R` are equal to each other. -/\ntheorem circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable {c : ℂ}\n    {r R : ℝ} (h0 : 0 < r) (hle : r ≤ R) {f : ℂ → E} {s : Set ℂ} (hs : s.Countable)\n    (hc : ContinuousOn f (closedBall c R \\ ball c r))\n    (hd : ∀ z ∈ (ball c R \\ closedBall c r) \\ s, DifferentiableAt ℂ f z) :\n    (∮ z in C(c, R), (z - c)⁻¹ • f z) = ∮ z in C(c, r), (z - c)⁻¹ • f z := by\n  /- We apply the previous lemma to `fun z ↦ f (c + exp z)` on the rectangle\n    `[log r, log R] × [0, 2 * π]`. -/\n  set A := closedBall c R \\ ball c r\n  obtain ⟨a, rfl⟩ : ∃ a, Real.exp a = r := ⟨Real.log r, Real.exp_log h0⟩\n  obtain ⟨b, rfl⟩ : ∃ b, Real.exp b = R := ⟨Real.log R, Real.exp_log (h0.trans_le hle)⟩\n  rw [Real.exp_le_exp] at hle\n  -- Unfold definition of `circleIntegral` and cancel some terms.\n  suffices\n    (∫ θ in (0)..2 * π, I • f (circleMap c (Real.exp b) θ)) =\n      ∫ θ in (0)..2 * π, I • f (circleMap c (Real.exp a) θ) by\n    simpa only [circleIntegral, add_sub_cancel_left, ofReal_exp, ← exp_add, smul_smul, ←\n      div_eq_mul_inv, mul_div_cancel_left₀ _ (circleMap_ne_center (Real.exp_pos _).ne'),\n      circleMap_sub_center, deriv_circleMap]\n  set R := [[a, b]] ×ℂ [[0, 2 * π]]\n  set g : ℂ → ℂ := (c + exp ·)\n  have hdg : Differentiable ℂ g := differentiable_exp.const_add _\n  replace hs : (g ⁻¹' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp\n  have h_maps : MapsTo g R A := by rintro z ⟨h, -⟩; simpa [g, A, dist_eq, abs_exp, hle] using h.symm\n  replace hc : ContinuousOn (f ∘ g) R := hc.comp hdg.continuous.continuousOn h_maps\n  replace hd : ∀ z ∈ Ioo (min a b) (max a b) ×ℂ Ioo (min 0 (2 * π)) (max 0 (2 * π)) \\ g ⁻¹' s,\n      DifferentiableAt ℂ (f ∘ g) z := by\n    refine fun z hz => (hd (g z) ⟨?_, hz.2⟩).comp z (hdg _)\n    simpa [g, dist_eq, abs_exp, hle, and_comm] using hz.1.1\n  simpa [g, circleMap, exp_periodic _, sub_eq_zero, ← exp_add] using\n    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ ⟨a, 0⟩ ⟨b, 2 * π⟩ _ hs hc hd\n\n"}
{"name":"Complex.circleIntegral_eq_of_differentiable_on_annulus_off_countable","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nc : Complex\nr R : Real\nh0 : LT.lt 0 r\nhle : LE.le r R\nf : Complex → E\ns : Set Complex\nhs : s.Countable\nhc : ContinuousOn f (SDiff.sdiff (Metric.closedBall c R) (Metric.ball c r))\nhd : ∀ (z : Complex), Membership.mem (SDiff.sdiff (SDiff.sdiff (Metric.ball c R) (Metric.closedBall c r)) s) z → DifferentiableAt Complex f z\n⊢ Eq (circleIntegral (fun z => f z) c R) (circleIntegral (fun z => f z) c r)","decl":"/-- **Cauchy-Goursat theorem** for an annulus. If `f : ℂ → E` is continuous on the closed annulus\n`r ≤ ‖z - c‖ ≤ R`, `0 < r ≤ R`, and is complex differentiable at all but countably many points of\nits interior, then the integrals of `f` over the circles `‖z - c‖ = r` and `‖z - c‖ = R` are equal\nto each other. -/\ntheorem circleIntegral_eq_of_differentiable_on_annulus_off_countable {c : ℂ} {r R : ℝ} (h0 : 0 < r)\n    (hle : r ≤ R) {f : ℂ → E} {s : Set ℂ} (hs : s.Countable)\n    (hc : ContinuousOn f (closedBall c R \\ ball c r))\n    (hd : ∀ z ∈ (ball c R \\ closedBall c r) \\ s, DifferentiableAt ℂ f z) :\n    (∮ z in C(c, R), f z) = ∮ z in C(c, r), f z :=\n  calc\n    (∮ z in C(c, R), f z) = ∮ z in C(c, R), (z - c)⁻¹ • (z - c) • f z :=\n      (circleIntegral.integral_sub_inv_smul_sub_smul _ _ _ _).symm\n    _ = ∮ z in C(c, r), (z - c)⁻¹ • (z - c) • f z :=\n      (circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable h0 hle hs\n        ((continuousOn_id.sub continuousOn_const).smul hc) fun z hz =>\n        (differentiableAt_id.sub_const _).smul (hd z hz))\n    _ = ∮ z in C(c, r), f z := circleIntegral.integral_sub_inv_smul_sub_smul _ _ _ _\n\n"}
{"name":"Complex.circleIntegral_sub_center_inv_smul_of_differentiable_on_off_countable_of_tendsto","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nc : Complex\nR : Real\nh0 : LT.lt 0 R\nf : Complex → E\ny : E\ns : Set Complex\nhs : s.Countable\nhc : ContinuousOn f (SDiff.sdiff (Metric.closedBall c R) (Singleton.singleton c))\nhd : ∀ (z : Complex), Membership.mem (SDiff.sdiff (SDiff.sdiff (Metric.ball c R) (Singleton.singleton c)) s) z → DifferentiableAt Complex f z\nhy : Filter.Tendsto f (nhdsWithin c (HasCompl.compl (Singleton.singleton c))) (nhds y)\n⊢ Eq (circleIntegral (fun z => HSMul.hSMul (Inv.inv (HSub.hSub z c)) (f z)) c R) (HSMul.hSMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) y)","decl":"/-- **Cauchy integral formula** for the value at the center of a disc. If `f` is continuous on a\npunctured closed disc of radius `R`, is differentiable at all but countably many points of the\ninterior of this disc, and has a limit `y` at the center of the disc, then the integral\n$\\oint_{‖z-c‖=R} \\frac{f(z)}{z-c}\\,dz$ is equal to `2πiy`. -/\ntheorem circleIntegral_sub_center_inv_smul_of_differentiable_on_off_countable_of_tendsto {c : ℂ}\n    {R : ℝ} (h0 : 0 < R) {f : ℂ → E} {y : E} {s : Set ℂ} (hs : s.Countable)\n    (hc : ContinuousOn f (closedBall c R \\ {c}))\n    (hd : ∀ z ∈ (ball c R \\ {c}) \\ s, DifferentiableAt ℂ f z) (hy : Tendsto f (𝓝[{c}ᶜ] c) (𝓝 y)) :\n    (∮ z in C(c, R), (z - c)⁻¹ • f z) = (2 * π * I : ℂ) • y := by\n  rw [← sub_eq_zero, ← norm_le_zero_iff]\n  refine le_of_forall_gt_imp_ge_of_dense fun ε ε0 => ?_\n  obtain ⟨δ, δ0, hδ⟩ : ∃ δ > (0 : ℝ), ∀ z ∈ closedBall c δ \\ {c}, dist (f z) y < ε / (2 * π) :=\n    ((nhdsWithin_hasBasis nhds_basis_closedBall _).tendsto_iff nhds_basis_ball).1 hy _\n      (div_pos ε0 Real.two_pi_pos)\n  obtain ⟨r, hr0, hrδ, hrR⟩ : ∃ r, 0 < r ∧ r ≤ δ ∧ r ≤ R :=\n    ⟨min δ R, lt_min δ0 h0, min_le_left _ _, min_le_right _ _⟩\n  have hsub : closedBall c R \\ ball c r ⊆ closedBall c R \\ {c} :=\n    diff_subset_diff_right (singleton_subset_iff.2 <| mem_ball_self hr0)\n  have hsub' : ball c R \\ closedBall c r ⊆ ball c R \\ {c} :=\n    diff_subset_diff_right (singleton_subset_iff.2 <| mem_closedBall_self hr0.le)\n  have hzne : ∀ z ∈ sphere c r, z ≠ c := fun z hz =>\n    ne_of_mem_of_not_mem hz fun h => hr0.ne' <| dist_self c ▸ Eq.symm h\n  /- The integral `∮ z in C(c, r), f z / (z - c)` does not depend on `0 < r ≤ R` and tends to\n    `2πIy` as `r → 0`. -/\n  calc\n    ‖(∮ z in C(c, R), (z - c)⁻¹ • f z) - (2 * ↑π * I) • y‖ =\n        ‖(∮ z in C(c, r), (z - c)⁻¹ • f z) - ∮ z in C(c, r), (z - c)⁻¹ • y‖ := by\n      congr 2\n      · exact circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable hr0\n          hrR hs (hc.mono hsub) fun z hz => hd z ⟨hsub' hz.1, hz.2⟩\n      · simp [hr0.ne']\n    _ = ‖∮ z in C(c, r), (z - c)⁻¹ • (f z - y)‖ := by\n      simp only [smul_sub]\n      have hc' : ContinuousOn (fun z => (z - c)⁻¹) (sphere c r) :=\n        (continuousOn_id.sub continuousOn_const).inv₀ fun z hz => sub_ne_zero.2 <| hzne _ hz\n      rw [circleIntegral.integral_sub] <;> refine (hc'.smul ?_).circleIntegrable hr0.le\n      · exact hc.mono <| subset_inter\n          (sphere_subset_closedBall.trans <| closedBall_subset_closedBall hrR) hzne\n      · exact continuousOn_const\n    _ ≤ 2 * π * r * (r⁻¹ * (ε / (2 * π))) := by\n      refine circleIntegral.norm_integral_le_of_norm_le_const hr0.le fun z hz => ?_\n      specialize hzne z hz\n      rw [mem_sphere, dist_eq_norm] at hz\n      rw [norm_smul, norm_inv, hz, ← dist_eq_norm]\n      refine mul_le_mul_of_nonneg_left (hδ _ ⟨?_, hzne⟩).le (inv_nonneg.2 hr0.le)\n      rwa [mem_closedBall_iff_norm, hz]\n    _ = ε := by field_simp [hr0.ne', Real.two_pi_pos.ne']; ac_rfl\n\n"}
{"name":"Complex.circleIntegral_sub_center_inv_smul_of_differentiable_on_off_countable","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nR : Real\nh0 : LT.lt 0 R\nf : Complex → E\nc : Complex\ns : Set Complex\nhs : s.Countable\nhc : ContinuousOn f (Metric.closedBall c R)\nhd : ∀ (z : Complex), Membership.mem (SDiff.sdiff (Metric.ball c R) s) z → DifferentiableAt Complex f z\n⊢ Eq (circleIntegral (fun z => HSMul.hSMul (Inv.inv (HSub.hSub z c)) (f z)) c R) (HSMul.hSMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) (f c))","decl":"/-- **Cauchy integral formula** for the value at the center of a disc. If `f : ℂ → E` is continuous\non a closed disc of radius `R` and is complex differentiable at all but countably many points of its\ninterior, then the integral $\\oint_{|z-c|=R} \\frac{f(z)}{z-c}\\,dz$ is equal to `2πiy`. -/\ntheorem circleIntegral_sub_center_inv_smul_of_differentiable_on_off_countable {R : ℝ} (h0 : 0 < R)\n    {f : ℂ → E} {c : ℂ} {s : Set ℂ} (hs : s.Countable) (hc : ContinuousOn f (closedBall c R))\n    (hd : ∀ z ∈ ball c R \\ s, DifferentiableAt ℂ f z) :\n    (∮ z in C(c, R), (z - c)⁻¹ • f z) = (2 * π * I : ℂ) • f c :=\n  circleIntegral_sub_center_inv_smul_of_differentiable_on_off_countable_of_tendsto h0 hs\n    (hc.mono diff_subset) (fun z hz => hd z ⟨hz.1.1, hz.2⟩)\n    (hc.continuousAt <| closedBall_mem_nhds _ h0).continuousWithinAt\n\n"}
{"name":"Complex.circleIntegral_eq_zero_of_differentiable_on_off_countable","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nR : Real\nh0 : LE.le 0 R\nf : Complex → E\nc : Complex\ns : Set Complex\nhs : s.Countable\nhc : ContinuousOn f (Metric.closedBall c R)\nhd : ∀ (z : Complex), Membership.mem (SDiff.sdiff (Metric.ball c R) s) z → DifferentiableAt Complex f z\n⊢ Eq (circleIntegral (fun z => f z) c R) 0","decl":"/-- **Cauchy-Goursat theorem** for a disk: if `f : ℂ → E` is continuous on a closed disk\n`{z | ‖z - c‖ ≤ R}` and is complex differentiable at all but countably many points of its interior,\nthen the integral $\\oint_{|z-c|=R}f(z)\\,dz$ equals zero. -/\ntheorem circleIntegral_eq_zero_of_differentiable_on_off_countable {R : ℝ} (h0 : 0 ≤ R) {f : ℂ → E}\n    {c : ℂ} {s : Set ℂ} (hs : s.Countable) (hc : ContinuousOn f (closedBall c R))\n    (hd : ∀ z ∈ ball c R \\ s, DifferentiableAt ℂ f z) : (∮ z in C(c, R), f z) = 0 := by\n  rcases h0.eq_or_lt with (rfl | h0); · apply circleIntegral.integral_radius_zero\n  calc\n    (∮ z in C(c, R), f z) = ∮ z in C(c, R), (z - c)⁻¹ • (z - c) • f z :=\n      (circleIntegral.integral_sub_inv_smul_sub_smul _ _ _ _).symm\n    _ = (2 * ↑π * I : ℂ) • (c - c) • f c :=\n      (circleIntegral_sub_center_inv_smul_of_differentiable_on_off_countable h0 hs\n        ((continuousOn_id.sub continuousOn_const).smul hc) fun z hz =>\n        (differentiableAt_id.sub_const _).smul (hd z hz))\n    _ = 0 := by rw [sub_self, zero_smul, smul_zero]\n\n"}
{"name":"Complex.circleIntegral_sub_inv_smul_of_differentiable_on_off_countable_aux","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nR : Real\nc w : Complex\nf : Complex → E\ns : Set Complex\nhs : s.Countable\nhw : Membership.mem (SDiff.sdiff (Metric.ball c R) s) w\nhc : ContinuousOn f (Metric.closedBall c R)\nhd : ∀ (x : Complex), Membership.mem (SDiff.sdiff (Metric.ball c R) s) x → DifferentiableAt Complex f x\n⊢ Eq (circleIntegral (fun z => HSMul.hSMul (Inv.inv (HSub.hSub z w)) (f z)) c R) (HSMul.hSMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) (f w))","decl":"/-- An auxiliary lemma for\n`Complex.circleIntegral_sub_inv_smul_of_differentiable_on_off_countable`. This lemma assumes\n`w ∉ s` while the main lemma drops this assumption. -/\ntheorem circleIntegral_sub_inv_smul_of_differentiable_on_off_countable_aux {R : ℝ} {c w : ℂ}\n    {f : ℂ → E} {s : Set ℂ} (hs : s.Countable) (hw : w ∈ ball c R \\ s)\n    (hc : ContinuousOn f (closedBall c R)) (hd : ∀ x ∈ ball c R \\ s, DifferentiableAt ℂ f x) :\n    (∮ z in C(c, R), (z - w)⁻¹ • f z) = (2 * π * I : ℂ) • f w := by\n  have hR : 0 < R := dist_nonneg.trans_lt hw.1\n  set F : ℂ → E := dslope f w\n  have hws : (insert w s).Countable := hs.insert w\n  have hcF : ContinuousOn F (closedBall c R) :=\n    (continuousOn_dslope <| closedBall_mem_nhds_of_mem hw.1).2 ⟨hc, hd _ hw⟩\n  have hdF : ∀ z ∈ ball (c : ℂ) R \\ insert w s, DifferentiableAt ℂ F z := fun z hz =>\n    (differentiableAt_dslope_of_ne (ne_of_mem_of_not_mem (mem_insert _ _) hz.2).symm).2\n      (hd _ (diff_subset_diff_right (subset_insert _ _) hz))\n  have HI := circleIntegral_eq_zero_of_differentiable_on_off_countable hR.le hws hcF hdF\n  have hne : ∀ z ∈ sphere c R, z ≠ w := fun z hz => ne_of_mem_of_not_mem hz (ne_of_lt hw.1)\n  have hFeq : EqOn F (fun z => (z - w)⁻¹ • f z - (z - w)⁻¹ • f w) (sphere c R) := fun z hz ↦\n    calc\n      F z = (z - w)⁻¹ • (f z - f w) := update_of_ne (hne z hz) ..\n      _ = (z - w)⁻¹ • f z - (z - w)⁻¹ • f w := smul_sub _ _ _\n  have hc' : ContinuousOn (fun z => (z - w)⁻¹) (sphere c R) :=\n    (continuousOn_id.sub continuousOn_const).inv₀ fun z hz => sub_ne_zero.2 <| hne z hz\n  rw [← circleIntegral.integral_sub_inv_of_mem_ball hw.1, ← circleIntegral.integral_smul_const, ←\n    sub_eq_zero, ← circleIntegral.integral_sub, ← circleIntegral.integral_congr hR.le hFeq, HI]\n  exacts [(hc'.smul (hc.mono sphere_subset_closedBall)).circleIntegrable hR.le,\n    (hc'.smul continuousOn_const).circleIntegrable hR.le]\n\n"}
{"name":"Complex.two_pi_I_inv_smul_circleIntegral_sub_inv_smul_of_differentiable_on_off_countable","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nR : Real\nc w : Complex\nf : Complex → E\ns : Set Complex\nhs : s.Countable\nhw : Membership.mem (Metric.ball c R) w\nhc : ContinuousOn f (Metric.closedBall c R)\nhd : ∀ (x : Complex), Membership.mem (SDiff.sdiff (Metric.ball c R) s) x → DifferentiableAt Complex f x\n⊢ Eq (HSMul.hSMul (Inv.inv (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I)) (circleIntegral (fun z => HSMul.hSMul (Inv.inv (HSub.hSub z w)) (f z)) c R)) (f w)","decl":"/-- **Cauchy integral formula**: if `f : ℂ → E` is continuous on a closed disc of radius `R` and is\ncomplex differentiable at all but countably many points of its interior, then for any `w` in this\ninterior we have $\\frac{1}{2πi}\\oint_{|z-c|=R}(z-w)^{-1}f(z)\\,dz=f(w)$.\n-/\ntheorem two_pi_I_inv_smul_circleIntegral_sub_inv_smul_of_differentiable_on_off_countable {R : ℝ}\n    {c w : ℂ} {f : ℂ → E} {s : Set ℂ} (hs : s.Countable) (hw : w ∈ ball c R)\n    (hc : ContinuousOn f (closedBall c R)) (hd : ∀ x ∈ ball c R \\ s, DifferentiableAt ℂ f x) :\n    ((2 * π * I : ℂ)⁻¹ • ∮ z in C(c, R), (z - w)⁻¹ • f z) = f w := by\n  have hR : 0 < R := dist_nonneg.trans_lt hw\n  suffices w ∈ closure (ball c R \\ s) by\n    lift R to ℝ≥0 using hR.le\n    have A : ContinuousAt (fun w => (2 * π * I : ℂ)⁻¹ • ∮ z in C(c, R), (z - w)⁻¹ • f z) w := by\n      have := hasFPowerSeriesOn_cauchy_integral\n        ((hc.mono sphere_subset_closedBall).circleIntegrable R.coe_nonneg) hR\n      refine this.continuousOn.continuousAt (EMetric.isOpen_ball.mem_nhds ?_)\n      rwa [Metric.emetric_ball_nnreal]\n    have B : ContinuousAt f w := hc.continuousAt (closedBall_mem_nhds_of_mem hw)\n    refine tendsto_nhds_unique_of_frequently_eq A B ((mem_closure_iff_frequently.1 this).mono ?_)\n    intro z hz\n    rw [circleIntegral_sub_inv_smul_of_differentiable_on_off_countable_aux hs hz hc hd,\n      inv_smul_smul₀]\n    simp [Real.pi_ne_zero, I_ne_zero]\n  refine mem_closure_iff_nhds.2 fun t ht => ?_\n  -- TODO: generalize to any vector space over `ℝ`\n  set g : ℝ → ℂ := fun x => w + ofReal x\n  have : Tendsto g (𝓝 0) (𝓝 w) :=\n    (continuous_const.add continuous_ofReal).tendsto' 0 w (add_zero _)\n  rcases mem_nhds_iff_exists_Ioo_subset.1 (this <| inter_mem ht <| isOpen_ball.mem_nhds hw) with\n    ⟨l, u, hlu₀, hlu_sub⟩\n  obtain ⟨x, hx⟩ : (Ioo l u \\ g ⁻¹' s).Nonempty := by\n    refine diff_nonempty.2 fun hsub => ?_\n    have : (Ioo l u).Countable :=\n      (hs.preimage ((add_right_injective w).comp ofReal_injective)).mono hsub\n    rw [← Cardinal.le_aleph0_iff_set_countable, Cardinal.mk_Ioo_real (hlu₀.1.trans hlu₀.2)] at this\n    exact this.not_lt Cardinal.aleph0_lt_continuum\n  exact ⟨g x, (hlu_sub hx.1).1, (hlu_sub hx.1).2, hx.2⟩\n\n"}
{"name":"Complex.circleIntegral_sub_inv_smul_of_differentiable_on_off_countable","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nR : Real\nc w : Complex\nf : Complex → E\ns : Set Complex\nhs : s.Countable\nhw : Membership.mem (Metric.ball c R) w\nhc : ContinuousOn f (Metric.closedBall c R)\nhd : ∀ (x : Complex), Membership.mem (SDiff.sdiff (Metric.ball c R) s) x → DifferentiableAt Complex f x\n⊢ Eq (circleIntegral (fun z => HSMul.hSMul (Inv.inv (HSub.hSub z w)) (f z)) c R) (HSMul.hSMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) (f w))","decl":"/-- **Cauchy integral formula**: if `f : ℂ → E` is continuous on a closed disc of radius `R` and is\ncomplex differentiable at all but countably many points of its interior, then for any `w` in this\ninterior we have $\\oint_{|z-c|=R}(z-w)^{-1}f(z)\\,dz=2πif(w)$.\n-/\ntheorem circleIntegral_sub_inv_smul_of_differentiable_on_off_countable {R : ℝ} {c w : ℂ} {f : ℂ → E}\n    {s : Set ℂ} (hs : s.Countable) (hw : w ∈ ball c R) (hc : ContinuousOn f (closedBall c R))\n    (hd : ∀ x ∈ ball c R \\ s, DifferentiableAt ℂ f x) :\n    (∮ z in C(c, R), (z - w)⁻¹ • f z) = (2 * π * I : ℂ) • f w := by\n  rw [← two_pi_I_inv_smul_circleIntegral_sub_inv_smul_of_differentiable_on_off_countable\n    hs hw hc hd, smul_inv_smul₀]\n  simp [Real.pi_ne_zero, I_ne_zero]\n\n"}
{"name":"DiffContOnCl.circleIntegral_sub_inv_smul","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nR : Real\nc w : Complex\nf : Complex → E\nh : DiffContOnCl Complex f (Metric.ball c R)\nhw : Membership.mem (Metric.ball c R) w\n⊢ Eq (circleIntegral (fun z => HSMul.hSMul (Inv.inv (HSub.hSub z w)) (f z)) c R) (HSMul.hSMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) (f w))","decl":"/-- **Cauchy integral formula**: if `f : ℂ → E` is complex differentiable on an open disc and is\ncontinuous on its closure, then for any `w` in this open ball we have\n$\\oint_{|z-c|=R}(z-w)^{-1}f(z)\\,dz=2πif(w)$. -/\ntheorem _root_.DiffContOnCl.circleIntegral_sub_inv_smul {R : ℝ} {c w : ℂ} {f : ℂ → E}\n    (h : DiffContOnCl ℂ f (ball c R)) (hw : w ∈ ball c R) :\n    (∮ z in C(c, R), (z - w)⁻¹ • f z) = (2 * π * I : ℂ) • f w :=\n  circleIntegral_sub_inv_smul_of_differentiable_on_off_countable countable_empty hw\n    h.continuousOn_ball fun _x hx => h.differentiableAt isOpen_ball hx.1\n\n"}
{"name":"DiffContOnCl.two_pi_i_inv_smul_circleIntegral_sub_inv_smul","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nR : Real\nc w : Complex\nf : Complex → E\nhf : DiffContOnCl Complex f (Metric.ball c R)\nhw : Membership.mem (Metric.ball c R) w\n⊢ Eq (HSMul.hSMul (Inv.inv (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I)) (circleIntegral (fun z => HSMul.hSMul (Inv.inv (HSub.hSub z w)) (f z)) c R)) (f w)","decl":"/-- **Cauchy integral formula**: if `f : ℂ → E` is complex differentiable on an open disc and is\ncontinuous on its closure, then for any `w` in this open ball we have\n$\\frac{1}{2πi}\\oint_{|z-c|=R}(z-w)^{-1}f(z)\\,dz=f(w)$. -/\ntheorem _root_.DiffContOnCl.two_pi_i_inv_smul_circleIntegral_sub_inv_smul {R : ℝ} {c w : ℂ}\n    {f : ℂ → E} (hf : DiffContOnCl ℂ f (ball c R)) (hw : w ∈ ball c R) :\n    ((2 * π * I : ℂ)⁻¹ • ∮ z in C(c, R), (z - w)⁻¹ • f z) = f w := by\n  have hR : 0 < R := not_le.mp (ball_eq_empty.not.mp (Set.nonempty_of_mem hw).ne_empty)\n  refine two_pi_I_inv_smul_circleIntegral_sub_inv_smul_of_differentiable_on_off_countable\n    countable_empty hw ?_ ?_\n  · simpa only [closure_ball c hR.ne.symm] using hf.continuousOn\n  · simpa only [diff_empty] using fun z hz => hf.differentiableAt isOpen_ball hz\n\n"}
{"name":"DifferentiableOn.circleIntegral_sub_inv_smul","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nR : Real\nc w : Complex\nf : Complex → E\nhd : DifferentiableOn Complex f (Metric.closedBall c R)\nhw : Membership.mem (Metric.ball c R) w\n⊢ Eq (circleIntegral (fun z => HSMul.hSMul (Inv.inv (HSub.hSub z w)) (f z)) c R) (HSMul.hSMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) (f w))","decl":"/-- **Cauchy integral formula**: if `f : ℂ → E` is complex differentiable on a closed disc of radius\n`R`, then for any `w` in its interior we have $\\oint_{|z-c|=R}(z-w)^{-1}f(z)\\,dz=2πif(w)$. -/\ntheorem _root_.DifferentiableOn.circleIntegral_sub_inv_smul {R : ℝ} {c w : ℂ} {f : ℂ → E}\n    (hd : DifferentiableOn ℂ f (closedBall c R)) (hw : w ∈ ball c R) :\n    (∮ z in C(c, R), (z - w)⁻¹ • f z) = (2 * π * I : ℂ) • f w :=\n  (hd.mono closure_ball_subset_closedBall).diffContOnCl.circleIntegral_sub_inv_smul hw\n\n"}
{"name":"Complex.circleIntegral_div_sub_of_differentiable_on_off_countable","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"R : Real\nc w : Complex\ns : Set Complex\nhs : s.Countable\nhw : Membership.mem (Metric.ball c R) w\nf : Complex → Complex\nhc : ContinuousOn f (Metric.closedBall c R)\nhd : ∀ (z : Complex), Membership.mem (SDiff.sdiff (Metric.ball c R) s) z → DifferentiableAt Complex f z\n⊢ Eq (circleIntegral (fun z => HDiv.hDiv (f z) (HSub.hSub z w)) c R) (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) (f w))","decl":"/-- **Cauchy integral formula**: if `f : ℂ → ℂ` is continuous on a closed disc of radius `R` and is\ncomplex differentiable at all but countably many points of its interior, then for any `w` in this\ninterior we have $\\oint_{|z-c|=R}\\frac{f(z)}{z-w}dz=2\\pi i\\,f(w)$.\n-/\ntheorem circleIntegral_div_sub_of_differentiable_on_off_countable {R : ℝ} {c w : ℂ} {s : Set ℂ}\n    (hs : s.Countable) (hw : w ∈ ball c R) {f : ℂ → ℂ} (hc : ContinuousOn f (closedBall c R))\n    (hd : ∀ z ∈ ball c R \\ s, DifferentiableAt ℂ f z) :\n    (∮ z in C(c, R), f z / (z - w)) = 2 * π * I * f w := by\n  simpa only [smul_eq_mul, div_eq_inv_mul] using\n    circleIntegral_sub_inv_smul_of_differentiable_on_off_countable hs hw hc hd\n\n"}
{"name":"Complex.hasFPowerSeriesOnBall_of_differentiable_off_countable","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nR : NNReal\nc : Complex\nf : Complex → E\ns : Set Complex\nhs : s.Countable\nhc : ContinuousOn f (Metric.closedBall c ↑R)\nhd : ∀ (z : Complex), Membership.mem (SDiff.sdiff (Metric.ball c ↑R) s) z → DifferentiableAt Complex f z\nhR : LT.lt 0 R\n⊢ HasFPowerSeriesOnBall f (cauchyPowerSeries f c ↑R) c ↑R","decl":"/-- If `f : ℂ → E` is continuous on a closed ball of positive radius and is differentiable at all\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\ncoefficients of the power series given by Cauchy integral formulas. -/\ntheorem hasFPowerSeriesOnBall_of_differentiable_off_countable {R : ℝ≥0} {c : ℂ} {f : ℂ → E}\n    {s : Set ℂ} (hs : s.Countable) (hc : ContinuousOn f (closedBall c R))\n    (hd : ∀ z ∈ ball c R \\ s, DifferentiableAt ℂ f z) (hR : 0 < R) :\n    HasFPowerSeriesOnBall f (cauchyPowerSeries f c R) c R where\n  r_le := le_radius_cauchyPowerSeries _ _ _\n  r_pos := ENNReal.coe_pos.2 hR\n  hasSum := fun {w} hw => by\n    have hw' : c + w ∈ ball c R := by\n      simpa only [add_mem_ball_iff_norm, ← coe_nnnorm, mem_emetric_ball_zero_iff,\n        NNReal.coe_lt_coe, enorm_lt_coe] using hw\n    rw [← two_pi_I_inv_smul_circleIntegral_sub_inv_smul_of_differentiable_on_off_countable\n      hs hw' hc hd]\n    exact (hasFPowerSeriesOn_cauchy_integral\n      ((hc.mono sphere_subset_closedBall).circleIntegrable R.2) hR).hasSum hw\n\n"}
{"name":"DiffContOnCl.hasFPowerSeriesOnBall","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nR : NNReal\nc : Complex\nf : Complex → E\nhf : DiffContOnCl Complex f (Metric.ball c ↑R)\nhR : LT.lt 0 R\n⊢ HasFPowerSeriesOnBall f (cauchyPowerSeries f c ↑R) c ↑R","decl":"/-- If `f : ℂ → E` is complex differentiable on an open disc of positive radius and is continuous\non its closure, then it is analytic on the open disc with coefficients of the power series given by\nCauchy integral formulas. -/\ntheorem _root_.DiffContOnCl.hasFPowerSeriesOnBall {R : ℝ≥0} {c : ℂ} {f : ℂ → E}\n    (hf : DiffContOnCl ℂ f (ball c R)) (hR : 0 < R) :\n    HasFPowerSeriesOnBall f (cauchyPowerSeries f c R) c R :=\n  hasFPowerSeriesOnBall_of_differentiable_off_countable countable_empty hf.continuousOn_ball\n    (fun _z hz => hf.differentiableAt isOpen_ball hz.1) hR\n\n"}
{"name":"DifferentiableOn.hasFPowerSeriesOnBall","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nR : NNReal\nc : Complex\nf : Complex → E\nhd : DifferentiableOn Complex f (Metric.closedBall c ↑R)\nhR : LT.lt 0 R\n⊢ HasFPowerSeriesOnBall f (cauchyPowerSeries f c ↑R) c ↑R","decl":"/-- If `f : ℂ → E` is complex differentiable on a closed disc of positive radius, then it is\nanalytic on the corresponding open disc, and the coefficients of the power series are given by\nCauchy integral formulas. See also\n`Complex.hasFPowerSeriesOnBall_of_differentiable_off_countable` for a version of this lemma with\nweaker assumptions. -/\nprotected theorem _root_.DifferentiableOn.hasFPowerSeriesOnBall {R : ℝ≥0} {c : ℂ} {f : ℂ → E}\n    (hd : DifferentiableOn ℂ f (closedBall c R)) (hR : 0 < R) :\n    HasFPowerSeriesOnBall f (cauchyPowerSeries f c R) c R :=\n  (hd.mono closure_ball_subset_closedBall).diffContOnCl.hasFPowerSeriesOnBall hR\n\n"}
{"name":"DifferentiableOn.analyticAt","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\ns : Set Complex\nf : Complex → E\nz : Complex\nhd : DifferentiableOn Complex f s\nhz : Membership.mem (nhds z) s\n⊢ AnalyticAt Complex f z","decl":"/-- If `f : ℂ → E` is complex differentiable on some set `s`, then it is analytic at any point `z`\nsuch that `s ∈ 𝓝 z` (equivalently, `z ∈ interior s`). -/\nprotected theorem _root_.DifferentiableOn.analyticAt {s : Set ℂ} {f : ℂ → E} {z : ℂ}\n    (hd : DifferentiableOn ℂ f s) (hz : s ∈ 𝓝 z) : AnalyticAt ℂ f z := by\n  rcases nhds_basis_closedBall.mem_iff.1 hz with ⟨R, hR0, hRs⟩\n  lift R to ℝ≥0 using hR0.le\n  exact ((hd.mono hRs).hasFPowerSeriesOnBall hR0).analyticAt\n\n"}
{"name":"DifferentiableOn.analyticOnNhd","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\ns : Set Complex\nf : Complex → E\nhd : DifferentiableOn Complex f s\nhs : IsOpen s\n⊢ AnalyticOnNhd Complex f s","decl":"theorem _root_.DifferentiableOn.analyticOnNhd {s : Set ℂ} {f : ℂ → E} (hd : DifferentiableOn ℂ f s)\n    (hs : IsOpen s) : AnalyticOnNhd ℂ f s := fun _z hz => hd.analyticAt (hs.mem_nhds hz)\n\n"}
{"name":"DifferentiableOn.analyticOn","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\ns : Set Complex\nf : Complex → E\nhd : DifferentiableOn Complex f s\nhs : IsOpen s\n⊢ AnalyticOn Complex f s","decl":"theorem _root_.DifferentiableOn.analyticOn {s : Set ℂ} {f : ℂ → E} (hd : DifferentiableOn ℂ f s)\n    (hs : IsOpen s) : AnalyticOn ℂ f s :=\n  (hd.analyticOnNhd hs).analyticOn\n\n"}
{"name":"DifferentiableOn.contDiffOn","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\ns : Set Complex\nf : Complex → E\nn : WithTop ENat\nhd : DifferentiableOn Complex f s\nhs : IsOpen s\n⊢ ContDiffOn Complex n f s","decl":"/-- If `f : ℂ → E` is complex differentiable on some open set `s`, then it is continuously\ndifferentiable on `s`. -/\nprotected theorem _root_.DifferentiableOn.contDiffOn {s : Set ℂ} {f : ℂ → E} {n : WithTop ℕ∞}\n    (hd : DifferentiableOn ℂ f s) (hs : IsOpen s) : ContDiffOn ℂ n f s :=\n  (hd.analyticOnNhd hs).contDiffOn_of_completeSpace\n\n"}
{"name":"Differentiable.analyticAt","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf : Complex → E\nhf : Differentiable Complex f\nz : Complex\n⊢ AnalyticAt Complex f z","decl":"/-- A complex differentiable function `f : ℂ → E` is analytic at every point. -/\nprotected theorem _root_.Differentiable.analyticAt {f : ℂ → E} (hf : Differentiable ℂ f) (z : ℂ) :\n    AnalyticAt ℂ f z :=\n  hf.differentiableOn.analyticAt univ_mem\n\n"}
{"name":"Differentiable.contDiff","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf : Complex → E\nhf : Differentiable Complex f\nn : WithTop ENat\n⊢ ContDiff Complex n f","decl":"/-- A complex differentiable function `f : ℂ → E` is continuously differentiable at every point. -/\nprotected theorem _root_.Differentiable.contDiff\n    {f : ℂ → E} (hf : Differentiable ℂ f) {n : WithTop ℕ∞} :\n    ContDiff ℂ n f :=\n  contDiff_iff_contDiffAt.mpr fun z ↦ (hf.analyticAt z).contDiffAt\n\n"}
{"name":"Differentiable.hasFPowerSeriesOnBall","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf : Complex → E\nh : Differentiable Complex f\nz : Complex\nR : NNReal\nhR : LT.lt 0 R\n⊢ HasFPowerSeriesOnBall f (cauchyPowerSeries f z ↑R) z Top.top","decl":"/-- When `f : ℂ → E` is differentiable, the `cauchyPowerSeries f z R` represents `f` as a power\nseries centered at `z` in the entirety of `ℂ`, regardless of `R : ℝ≥0`, with `0 < R`. -/\nprotected theorem _root_.Differentiable.hasFPowerSeriesOnBall {f : ℂ → E} (h : Differentiable ℂ f)\n    (z : ℂ) {R : ℝ≥0} (hR : 0 < R) : HasFPowerSeriesOnBall f (cauchyPowerSeries f z R) z ∞ :=\n  (h.differentiableOn.hasFPowerSeriesOnBall hR).r_eq_top_of_exists fun _r hr =>\n    ⟨_, h.differentiableOn.hasFPowerSeriesOnBall hr⟩\n\n"}
{"name":"Complex.analyticOnNhd_iff_differentiableOn","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf : Complex → E\ns : Set Complex\no : IsOpen s\n⊢ Iff (AnalyticOnNhd Complex f s) (DifferentiableOn Complex f s)","decl":"/-- On an open set, `f : ℂ → E` is analytic iff it is differentiable -/\ntheorem analyticOnNhd_iff_differentiableOn {f : ℂ → E} {s : Set ℂ} (o : IsOpen s) :\n    AnalyticOnNhd ℂ f s ↔ DifferentiableOn ℂ f s :=\n  ⟨AnalyticOnNhd.differentiableOn, fun d _ zs ↦ d.analyticAt (o.mem_nhds zs)⟩\n\n"}
{"name":"Complex.analyticOn_iff_differentiableOn","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf : Complex → E\ns : Set Complex\no : IsOpen s\n⊢ Iff (AnalyticOn Complex f s) (DifferentiableOn Complex f s)","decl":"/-- On an open set, `f : ℂ → E` is analytic iff it is differentiable -/\ntheorem analyticOn_iff_differentiableOn {f : ℂ → E} {s : Set ℂ} (o : IsOpen s) :\n    AnalyticOn ℂ f s ↔ DifferentiableOn ℂ f s := by\n  rw [o.analyticOn_iff_analyticOnNhd]\n  exact analyticOnNhd_iff_differentiableOn o\n\n"}
{"name":"Complex.analyticOnNhd_univ_iff_differentiable","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf : Complex → E\n⊢ Iff (AnalyticOnNhd Complex f Set.univ) (Differentiable Complex f)","decl":"/-- `f : ℂ → E` is entire iff it's differentiable -/\ntheorem analyticOnNhd_univ_iff_differentiable {f : ℂ → E} :\n    AnalyticOnNhd ℂ f univ ↔ Differentiable ℂ f := by\n  simp only [← differentiableOn_univ]\n  exact analyticOnNhd_iff_differentiableOn isOpen_univ\n\n"}
{"name":"Complex.analyticOn_univ_iff_differentiable","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf : Complex → E\n⊢ Iff (AnalyticOn Complex f Set.univ) (Differentiable Complex f)","decl":"theorem analyticOn_univ_iff_differentiable {f : ℂ → E} :\n    AnalyticOn ℂ f univ ↔ Differentiable ℂ f := by\n  rw [analyticOn_univ]\n  exact analyticOnNhd_univ_iff_differentiable\n\n"}
{"name":"Complex.analyticAt_iff_eventually_differentiableAt","module":"Mathlib.Analysis.Complex.CauchyIntegral","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf : Complex → E\nc : Complex\n⊢ Iff (AnalyticAt Complex f c) (Filter.Eventually (fun z => DifferentiableAt Complex f z) (nhds c))","decl":"/-- `f : ℂ → E` is analytic at `z` iff it's differentiable near `z` -/\ntheorem analyticAt_iff_eventually_differentiableAt {f : ℂ → E} {c : ℂ} :\n    AnalyticAt ℂ f c ↔ ∀ᶠ z in 𝓝 c, DifferentiableAt ℂ f z := by\n  constructor\n  · intro fa\n    filter_upwards [fa.eventually_analyticAt]\n    apply AnalyticAt.differentiableAt\n  · intro d\n    rcases _root_.eventually_nhds_iff.mp d with ⟨s, d, o, m⟩\n    have h : AnalyticOnNhd ℂ f s := by\n      refine DifferentiableOn.analyticOnNhd ?_ o\n      intro z m\n      exact (d z m).differentiableWithinAt\n    exact h _ m\n\n"}
