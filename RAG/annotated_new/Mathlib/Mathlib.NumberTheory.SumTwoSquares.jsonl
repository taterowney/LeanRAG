{"name":"Nat.Prime.sq_add_sq","module":"Mathlib.NumberTheory.SumTwoSquares","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nhp : Ne (HMod.hMod p 4) 3\n⊢ Exists fun a => Exists fun b => Eq (HAdd.hAdd (HPow.hPow a 2) (HPow.hPow b 2)) p","decl":"/-- **Fermat's theorem on the sum of two squares**. Every prime not congruent to 3 mod 4 is the sum\nof two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem Nat.Prime.sq_add_sq {p : ℕ} [Fact p.Prime] (hp : p % 4 ≠ 3) :\n    ∃ a b : ℕ, a ^ 2 + b ^ 2 = p := by\n  apply sq_add_sq_of_nat_prime_of_not_irreducible p\n  rwa [_root_.irreducible_iff_prime, prime_iff_mod_four_eq_three_of_nat_prime p]\n\n"}
{"name":"sq_add_sq_mul","module":"Mathlib.NumberTheory.SumTwoSquares","initialProofState":"R : Type u_1\ninst✝ : CommRing R\na b x y u v : R\nha : Eq a (HAdd.hAdd (HPow.hPow x 2) (HPow.hPow y 2))\nhb : Eq b (HAdd.hAdd (HPow.hPow u 2) (HPow.hPow v 2))\n⊢ Exists fun r => Exists fun s => Eq (HMul.hMul a b) (HAdd.hAdd (HPow.hPow r 2) (HPow.hPow s 2))","decl":"/-- The set of sums of two squares is closed under multiplication in any commutative ring.\nSee also `sq_add_sq_mul_sq_add_sq`. -/\ntheorem sq_add_sq_mul {R} [CommRing R] {a b x y u v : R} (ha : a = x ^ 2 + y ^ 2)\n    (hb : b = u ^ 2 + v ^ 2) : ∃ r s : R, a * b = r ^ 2 + s ^ 2 :=\n  ⟨x * u - y * v, x * v + y * u, by rw [ha, hb]; ring⟩\n\n"}
{"name":"Nat.sq_add_sq_mul","module":"Mathlib.NumberTheory.SumTwoSquares","initialProofState":"a b x y u v : Nat\nha : Eq a (HAdd.hAdd (HPow.hPow x 2) (HPow.hPow y 2))\nhb : Eq b (HAdd.hAdd (HPow.hPow u 2) (HPow.hPow v 2))\n⊢ Exists fun r => Exists fun s => Eq (HMul.hMul a b) (HAdd.hAdd (HPow.hPow r 2) (HPow.hPow s 2))","decl":"/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem Nat.sq_add_sq_mul {a b x y u v : ℕ} (ha : a = x ^ 2 + y ^ 2) (hb : b = u ^ 2 + v ^ 2) :\n    ∃ r s : ℕ, a * b = r ^ 2 + s ^ 2 := by\n  zify at ha hb ⊢\n  obtain ⟨r, s, h⟩ := _root_.sq_add_sq_mul ha hb\n  refine ⟨r.natAbs, s.natAbs, ?_⟩\n  simpa only [Int.natCast_natAbs, sq_abs]\n\n"}
{"name":"ZMod.isSquare_neg_one_of_dvd","module":"Mathlib.NumberTheory.SumTwoSquares","initialProofState":"m n : Nat\nhd : Dvd.dvd m n\nhs : IsSquare (-1)\n⊢ IsSquare (-1)","decl":"/-- If `-1` is a square modulo `n` and `m` divides `n`, then `-1` is also a square modulo `m`. -/\ntheorem ZMod.isSquare_neg_one_of_dvd {m n : ℕ} (hd : m ∣ n) (hs : IsSquare (-1 : ZMod n)) :\n    IsSquare (-1 : ZMod m) := by\n  let f : ZMod n →+* ZMod m := ZMod.castHom hd _\n  rw [← RingHom.map_one f, ← RingHom.map_neg]\n  exact hs.map f\n\n"}
{"name":"ZMod.isSquare_neg_one_mul","module":"Mathlib.NumberTheory.SumTwoSquares","initialProofState":"m n : Nat\nhc : m.Coprime n\nhm : IsSquare (-1)\nhn : IsSquare (-1)\n⊢ IsSquare (-1)","decl":"/-- If `-1` is a square modulo coprime natural numbers `m` and `n`, then `-1` is also\na square modulo `m*n`. -/\ntheorem ZMod.isSquare_neg_one_mul {m n : ℕ} (hc : m.Coprime n) (hm : IsSquare (-1 : ZMod m))\n    (hn : IsSquare (-1 : ZMod n)) : IsSquare (-1 : ZMod (m * n)) := by\n  have : IsSquare (-1 : ZMod m × ZMod n) := by\n    rw [show (-1 : ZMod m × ZMod n) = ((-1 : ZMod m), (-1 : ZMod n)) from rfl]\n    obtain ⟨x, hx⟩ := hm\n    obtain ⟨y, hy⟩ := hn\n    rw [hx, hy]\n    exact ⟨(x, y), rfl⟩\n  simpa only [RingEquiv.map_neg_one] using this.map (ZMod.chineseRemainder hc).symm\n\n"}
{"name":"Nat.Prime.mod_four_ne_three_of_dvd_isSquare_neg_one","module":"Mathlib.NumberTheory.SumTwoSquares","initialProofState":"p n : Nat\nhpp : Nat.Prime p\nhp : Dvd.dvd p n\nhs : IsSquare (-1)\n⊢ Ne (HMod.hMod p 4) 3","decl":"/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. -/\ntheorem Nat.Prime.mod_four_ne_three_of_dvd_isSquare_neg_one {p n : ℕ} (hpp : p.Prime) (hp : p ∣ n)\n    (hs : IsSquare (-1 : ZMod n)) : p % 4 ≠ 3 := by\n  obtain ⟨y, h⟩ := ZMod.isSquare_neg_one_of_dvd hp hs\n  rw [← sq, eq_comm, show (-1 : ZMod p) = -1 ^ 2 by ring] at h\n  haveI : Fact p.Prime := ⟨hpp⟩\n  exact ZMod.mod_four_ne_three_of_sq_eq_neg_sq' one_ne_zero h\n\n"}
{"name":"ZMod.isSquare_neg_one_iff","module":"Mathlib.NumberTheory.SumTwoSquares","initialProofState":"n : Nat\nhn : Squarefree n\n⊢ Iff (IsSquare (-1)) (∀ {q : Nat}, Nat.Prime q → Dvd.dvd q n → Ne (HMod.hMod q 4) 3)","decl":"/-- If `n` is a squarefree natural number, then `-1` is a square modulo `n` if and only if\n`n` is not divisible by a prime `q` such that `q % 4 = 3`. -/\ntheorem ZMod.isSquare_neg_one_iff {n : ℕ} (hn : Squarefree n) :\n    IsSquare (-1 : ZMod n) ↔ ∀ {q : ℕ}, q.Prime → q ∣ n → q % 4 ≠ 3 := by\n  refine ⟨fun H q hqp hqd => hqp.mod_four_ne_three_of_dvd_isSquare_neg_one hqd H, fun H => ?_⟩\n  induction' n using induction_on_primes with p n hpp ih\n  · exact False.elim (hn.ne_zero rfl)\n  · exact ⟨0, by simp only [mul_zero, eq_iff_true_of_subsingleton]⟩\n  · haveI : Fact p.Prime := ⟨hpp⟩\n    have hcp : p.Coprime n := by\n      by_contra hc\n      exact hpp.not_unit (hn p <| mul_dvd_mul_left p <| hpp.dvd_iff_not_coprime.mpr hc)\n    have hp₁ := ZMod.exists_sq_eq_neg_one_iff.mpr (H hpp (dvd_mul_right p n))\n    exact ZMod.isSquare_neg_one_mul hcp hp₁\n      (ih hn.of_mul_right fun hqp hqd => H hqp <| dvd_mul_of_dvd_right hqd _)\n\n"}
{"name":"ZMod.isSquare_neg_one_iff'","module":"Mathlib.NumberTheory.SumTwoSquares","initialProofState":"n : Nat\nhn : Squarefree n\n⊢ Iff (IsSquare (-1)) (∀ {q : Nat}, Dvd.dvd q n → Ne (HMod.hMod q 4) 3)","decl":"/-- If `n` is a squarefree natural number, then `-1` is a square modulo `n` if and only if\n`n` has no divisor `q` that is `≡ 3 mod 4`. -/\ntheorem ZMod.isSquare_neg_one_iff' {n : ℕ} (hn : Squarefree n) :\n    IsSquare (-1 : ZMod n) ↔ ∀ {q : ℕ}, q ∣ n → q % 4 ≠ 3 := by\n  have help : ∀ a b : ZMod 4, a ≠ 3 → b ≠ 3 → a * b ≠ 3 := by decide\n  rw [ZMod.isSquare_neg_one_iff hn]\n  refine ⟨?_, fun H q _ => H⟩\n  intro H\n  refine @induction_on_primes _ ?_ ?_ (fun p q hp hq hpq => ?_)\n  · exact fun _ => by norm_num\n  · exact fun _ => by norm_num\n  · replace hp := H hp (dvd_of_mul_right_dvd hpq)\n    replace hq := hq (dvd_of_mul_left_dvd hpq)\n    rw [show 3 = 3 % 4 by norm_num, Ne, ← ZMod.natCast_eq_natCast_iff'] at hp hq ⊢\n    rw [Nat.cast_mul]\n    exact help p q hp hq\n\n"}
{"name":"Nat.eq_sq_add_sq_of_isSquare_mod_neg_one","module":"Mathlib.NumberTheory.SumTwoSquares","initialProofState":"n : Nat\nh : IsSquare (-1)\n⊢ Exists fun x => Exists fun y => Eq n (HAdd.hAdd (HPow.hPow x 2) (HPow.hPow y 2))","decl":"/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem Nat.eq_sq_add_sq_of_isSquare_mod_neg_one {n : ℕ} (h : IsSquare (-1 : ZMod n)) :\n    ∃ x y : ℕ, n = x ^ 2 + y ^ 2 := by\n  induction' n using induction_on_primes with p n hpp ih\n  · exact ⟨0, 0, rfl⟩\n  · exact ⟨0, 1, rfl⟩\n  · haveI : Fact p.Prime := ⟨hpp⟩\n    have hp : IsSquare (-1 : ZMod p) := ZMod.isSquare_neg_one_of_dvd ⟨n, rfl⟩ h\n    obtain ⟨u, v, huv⟩ := Nat.Prime.sq_add_sq (ZMod.exists_sq_eq_neg_one_iff.mp hp)\n    obtain ⟨x, y, hxy⟩ := ih (ZMod.isSquare_neg_one_of_dvd ⟨p, mul_comm _ _⟩ h)\n    exact Nat.sq_add_sq_mul huv.symm hxy\n\n"}
{"name":"ZMod.isSquare_neg_one_of_eq_sq_add_sq_of_isCoprime","module":"Mathlib.NumberTheory.SumTwoSquares","initialProofState":"n x y : Int\nh : Eq n (HAdd.hAdd (HPow.hPow x 2) (HPow.hPow y 2))\nhc : IsCoprime x y\n⊢ IsSquare (-1)","decl":"/-- If the integer `n` is a sum of two squares of coprime integers,\nthen `-1` is a square modulo `n`. -/\ntheorem ZMod.isSquare_neg_one_of_eq_sq_add_sq_of_isCoprime {n x y : ℤ} (h : n = x ^ 2 + y ^ 2)\n    (hc : IsCoprime x y) : IsSquare (-1 : ZMod n.natAbs) := by\n  obtain ⟨u, v, huv⟩ : IsCoprime x n := by\n    have hc2 : IsCoprime (x ^ 2) (y ^ 2) := hc.pow\n    rw [show y ^ 2 = n + -1 * x ^ 2 by omega] at hc2\n    exact (IsCoprime.pow_left_iff zero_lt_two).mp hc2.of_add_mul_right_right\n  have H : u * y * (u * y) - -1 = n * (-v ^ 2 * n + u ^ 2 + 2 * v) := by\n    linear_combination -u ^ 2 * h + (n * v - u * x - 1) * huv\n  refine ⟨u * y, ?_⟩\n  conv_rhs => tactic => norm_cast\n  rw [(by norm_cast : (-1 : ZMod n.natAbs) = (-1 : ℤ))]\n  exact (ZMod.intCast_eq_intCast_iff_dvd_sub _ _ _).mpr (Int.natAbs_dvd.mpr ⟨_, H⟩)\n\n"}
{"name":"ZMod.isSquare_neg_one_of_eq_sq_add_sq_of_coprime","module":"Mathlib.NumberTheory.SumTwoSquares","initialProofState":"n x y : Nat\nh : Eq n (HAdd.hAdd (HPow.hPow x 2) (HPow.hPow y 2))\nhc : x.Coprime y\n⊢ IsSquare (-1)","decl":"/-- If the natural number `n` is a sum of two squares of coprime natural numbers, then\n`-1` is a square modulo `n`. -/\ntheorem ZMod.isSquare_neg_one_of_eq_sq_add_sq_of_coprime {n x y : ℕ} (h : n = x ^ 2 + y ^ 2)\n    (hc : x.Coprime y) : IsSquare (-1 : ZMod n) := by\n  zify at h\n  exact ZMod.isSquare_neg_one_of_eq_sq_add_sq_of_isCoprime h hc.isCoprime\n\n"}
{"name":"Nat.eq_sq_add_sq_iff_eq_sq_mul","module":"Mathlib.NumberTheory.SumTwoSquares","initialProofState":"n : Nat\n⊢ Iff (Exists fun x => Exists fun y => Eq n (HAdd.hAdd (HPow.hPow x 2) (HPow.hPow y 2))) (Exists fun a => Exists fun b => And (Eq n (HMul.hMul (HPow.hPow a 2) b)) (IsSquare (-1)))","decl":"/-- A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\nnumbers `a` and `b` such that `-1` is a square modulo `b`. -/\ntheorem Nat.eq_sq_add_sq_iff_eq_sq_mul {n : ℕ} :\n    (∃ x y : ℕ, n = x ^ 2 + y ^ 2) ↔ ∃ a b : ℕ, n = a ^ 2 * b ∧ IsSquare (-1 : ZMod b) := by\n  constructor\n  · rintro ⟨x, y, h⟩\n    by_cases hxy : x = 0 ∧ y = 0\n    · exact ⟨0, 1, by rw [h, hxy.1, hxy.2, zero_pow two_ne_zero, add_zero, zero_mul],\n        ⟨0, by rw [zero_mul, neg_eq_zero, Fin.one_eq_zero_iff]⟩⟩\n    · have hg := Nat.pos_of_ne_zero (mt Nat.gcd_eq_zero_iff.mp hxy)\n      obtain ⟨g, x₁, y₁, _, h₂, h₃, h₄⟩ := Nat.exists_coprime' hg\n      exact ⟨g, x₁ ^ 2 + y₁ ^ 2, by rw [h, h₃, h₄]; ring,\n        ZMod.isSquare_neg_one_of_eq_sq_add_sq_of_coprime rfl h₂⟩\n  · rintro ⟨a, b, h₁, h₂⟩\n    obtain ⟨x', y', h⟩ := Nat.eq_sq_add_sq_of_isSquare_mod_neg_one h₂\n    exact ⟨a * x', a * y', by rw [h₁, h]; ring⟩\n\n"}
{"name":"Nat.eq_sq_add_sq_iff","module":"Mathlib.NumberTheory.SumTwoSquares","initialProofState":"n : Nat\n⊢ Iff (Exists fun x => Exists fun y => Eq n (HAdd.hAdd (HPow.hPow x 2) (HPow.hPow y 2))) (∀ {q : Nat}, Nat.Prime q → Eq (HMod.hMod q 4) 3 → Even (padicValNat q n))","decl":"/-- A (positive) natural number `n` is a sum of two squares if and only if the exponent of\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) -/\ntheorem Nat.eq_sq_add_sq_iff {n : ℕ} :\n    (∃ x y : ℕ, n = x ^ 2 + y ^ 2) ↔ ∀ {q : ℕ}, q.Prime → q % 4 = 3 → Even (padicValNat q n) := by\n  rcases n.eq_zero_or_pos with (rfl | hn₀)\n  · exact ⟨fun _ q _ _ => (@padicValNat.zero q).symm ▸ Even.zero, fun _ => ⟨0, 0, rfl⟩⟩\n  -- now `0 < n`\n  rw [Nat.eq_sq_add_sq_iff_eq_sq_mul]\n  refine ⟨fun H q hq h => ?_, fun H => ?_⟩\n  · obtain ⟨a, b, h₁, h₂⟩ := H\n    have hqb := padicValNat.eq_zero_of_not_dvd fun hf =>\n      (hq.mod_four_ne_three_of_dvd_isSquare_neg_one hf h₂) h\n    have hab : a ^ 2 * b ≠ 0 := h₁ ▸ hn₀.ne'\n    have ha₂ := left_ne_zero_of_mul hab\n    have ha := mt sq_eq_zero_iff.mpr ha₂\n    have hb := right_ne_zero_of_mul hab\n    haveI hqi : Fact q.Prime := ⟨hq⟩\n    simp_rw [h₁, padicValNat.mul ha₂ hb, padicValNat.pow 2 ha, hqb, add_zero]\n    exact even_two_mul _\n  · obtain ⟨b, a, hb₀, ha₀, hab, hb⟩ := Nat.sq_mul_squarefree_of_pos hn₀\n    refine ⟨a, b, hab.symm, (ZMod.isSquare_neg_one_iff hb).mpr fun {q} hqp hqb hq4 => ?_⟩\n    refine Nat.not_even_iff_odd.2 ?_ (H hqp hq4)\n    have hqb' : padicValNat q b = 1 :=\n      b.factorization_def hqp ▸ le_antisymm (hb.natFactorization_le_one _)\n        ((hqp.dvd_iff_one_le_factorization hb₀.ne').mp hqb)\n    haveI hqi : Fact q.Prime := ⟨hqp⟩\n    simp_rw [← hab, padicValNat.mul (pow_ne_zero 2 ha₀.ne') hb₀.ne', hqb',\n      padicValNat.pow 2 ha₀.ne']\n    exact odd_two_mul_add_one _\n\n"}
