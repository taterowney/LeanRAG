{"name":"comap_norm_atTop'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst‚úù : SeminormedGroup E\n‚ä¢ Eq (Filter.comap Norm.norm Filter.atTop) (Bornology.cobounded E)","decl":"@[to_additive (attr := simp) comap_norm_atTop]\nlemma comap_norm_atTop' : comap norm atTop = cobounded E := by\n  simpa only [dist_one_right] using comap_dist_right_atTop (1 : E)\n\n"}
{"name":"comap_norm_atTop","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst‚úù : SeminormedAddGroup E\n‚ä¢ Eq (Filter.comap Norm.norm Filter.atTop) (Bornology.cobounded E)","decl":"@[to_additive (attr := simp) comap_norm_atTop]\nlemma comap_norm_atTop' : comap norm atTop = cobounded E := by\n  simpa only [dist_one_right] using comap_dist_right_atTop (1 : E)\n\n"}
{"name":"Filter.HasBasis.cobounded_of_norm","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst‚úù : SeminormedAddGroup E\nŒπ : Sort u_5\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set Real\nh : Filter.atTop.HasBasis p s\n‚ä¢ (Bornology.cobounded E).HasBasis p fun i => Set.preimage Norm.norm (s i)","decl":"@[to_additive Filter.HasBasis.cobounded_of_norm]\nlemma Filter.HasBasis.cobounded_of_norm' {Œπ : Sort*} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set ‚Ñù}\n    (h : HasBasis atTop p s) : HasBasis (cobounded E) p fun i ‚Ü¶ norm ‚Åª¬π' s i :=\n  comap_norm_atTop' (E := E) ‚ñ∏ h.comap _\n\n"}
{"name":"Filter.HasBasis.cobounded_of_norm'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst‚úù : SeminormedGroup E\nŒπ : Sort u_5\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set Real\nh : Filter.atTop.HasBasis p s\n‚ä¢ (Bornology.cobounded E).HasBasis p fun i => Set.preimage Norm.norm (s i)","decl":"@[to_additive Filter.HasBasis.cobounded_of_norm]\nlemma Filter.HasBasis.cobounded_of_norm' {Œπ : Sort*} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set ‚Ñù}\n    (h : HasBasis atTop p s) : HasBasis (cobounded E) p fun i ‚Ü¶ norm ‚Åª¬π' s i :=\n  comap_norm_atTop' (E := E) ‚ñ∏ h.comap _\n\n"}
{"name":"Filter.hasBasis_cobounded_norm","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst‚úù : SeminormedAddGroup E\n‚ä¢ (Bornology.cobounded E).HasBasis (fun x => True) fun x => setOf fun x_1 => LE.le x (Norm.norm x_1)","decl":"@[to_additive Filter.hasBasis_cobounded_norm]\nlemma Filter.hasBasis_cobounded_norm' : HasBasis (cobounded E) (fun _ ‚Ü¶ True) ({x | ¬∑ ‚â§ ‚Äñx‚Äñ}) :=\n  atTop_basis.cobounded_of_norm'\n\n"}
{"name":"Filter.hasBasis_cobounded_norm'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst‚úù : SeminormedGroup E\n‚ä¢ (Bornology.cobounded E).HasBasis (fun x => True) fun x => setOf fun x_1 => LE.le x (Norm.norm x_1)","decl":"@[to_additive Filter.hasBasis_cobounded_norm]\nlemma Filter.hasBasis_cobounded_norm' : HasBasis (cobounded E) (fun _ ‚Ü¶ True) ({x | ¬∑ ‚â§ ‚Äñx‚Äñ}) :=\n  atTop_basis.cobounded_of_norm'\n\n"}
{"name":"tendsto_norm_atTop_iff_cobounded'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù : SeminormedGroup E\nf : Œ± ‚Üí E\nl : Filter Œ±\n‚ä¢ Iff (Filter.Tendsto (fun x => Norm.norm (f x)) l Filter.atTop) (Filter.Tendsto f l (Bornology.cobounded E))","decl":"@[to_additive (attr := simp) tendsto_norm_atTop_iff_cobounded]\nlemma tendsto_norm_atTop_iff_cobounded' {f : Œ± ‚Üí E} {l : Filter Œ±} :\n    Tendsto (‚Äñf ¬∑‚Äñ) l atTop ‚Üî Tendsto f l (cobounded E) := by\n  rw [‚Üê comap_norm_atTop', tendsto_comap_iff]; rfl\n\n"}
{"name":"tendsto_norm_atTop_iff_cobounded","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù : SeminormedAddGroup E\nf : Œ± ‚Üí E\nl : Filter Œ±\n‚ä¢ Iff (Filter.Tendsto (fun x => Norm.norm (f x)) l Filter.atTop) (Filter.Tendsto f l (Bornology.cobounded E))","decl":"@[to_additive (attr := simp) tendsto_norm_atTop_iff_cobounded]\nlemma tendsto_norm_atTop_iff_cobounded' {f : Œ± ‚Üí E} {l : Filter Œ±} :\n    Tendsto (‚Äñf ¬∑‚Äñ) l atTop ‚Üî Tendsto f l (cobounded E) := by\n  rw [‚Üê comap_norm_atTop', tendsto_comap_iff]; rfl\n\n"}
{"name":"tendsto_norm_cobounded_atTop'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst‚úù : SeminormedGroup E\n‚ä¢ Filter.Tendsto Norm.norm (Bornology.cobounded E) Filter.atTop","decl":"@[to_additive tendsto_norm_cobounded_atTop]\nlemma tendsto_norm_cobounded_atTop' : Tendsto norm (cobounded E) atTop :=\n  tendsto_norm_atTop_iff_cobounded'.2 tendsto_id\n\n"}
{"name":"tendsto_norm_cobounded_atTop","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst‚úù : SeminormedAddGroup E\n‚ä¢ Filter.Tendsto Norm.norm (Bornology.cobounded E) Filter.atTop","decl":"@[to_additive tendsto_norm_cobounded_atTop]\nlemma tendsto_norm_cobounded_atTop' : Tendsto norm (cobounded E) atTop :=\n  tendsto_norm_atTop_iff_cobounded'.2 tendsto_id\n\n"}
{"name":"eventually_cobounded_le_norm'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst‚úù : SeminormedGroup E\na : Real\n‚ä¢ Filter.Eventually (fun x => LE.le a (Norm.norm x)) (Bornology.cobounded E)","decl":"@[to_additive eventually_cobounded_le_norm]\nlemma eventually_cobounded_le_norm' (a : ‚Ñù) : ‚àÄ·∂† x in cobounded E, a ‚â§ ‚Äñx‚Äñ :=\n  tendsto_norm_cobounded_atTop'.eventually_ge_atTop a\n\n"}
{"name":"eventually_cobounded_le_norm","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst‚úù : SeminormedAddGroup E\na : Real\n‚ä¢ Filter.Eventually (fun x => LE.le a (Norm.norm x)) (Bornology.cobounded E)","decl":"@[to_additive eventually_cobounded_le_norm]\nlemma eventually_cobounded_le_norm' (a : ‚Ñù) : ‚àÄ·∂† x in cobounded E, a ‚â§ ‚Äñx‚Äñ :=\n  tendsto_norm_cobounded_atTop'.eventually_ge_atTop a\n\n"}
{"name":"tendsto_norm_cocompact_atTop'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst‚úù¬π : SeminormedGroup E\ninst‚úù : ProperSpace E\n‚ä¢ Filter.Tendsto Norm.norm (Filter.cocompact E) Filter.atTop","decl":"@[to_additive tendsto_norm_cocompact_atTop]\nlemma tendsto_norm_cocompact_atTop' [ProperSpace E] : Tendsto norm (cocompact E) atTop :=\n  cobounded_eq_cocompact (Œ± := E) ‚ñ∏ tendsto_norm_cobounded_atTop'\n\n"}
{"name":"tendsto_norm_cocompact_atTop","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst‚úù¬π : SeminormedAddGroup E\ninst‚úù : ProperSpace E\n‚ä¢ Filter.Tendsto Norm.norm (Filter.cocompact E) Filter.atTop","decl":"@[to_additive tendsto_norm_cocompact_atTop]\nlemma tendsto_norm_cocompact_atTop' [ProperSpace E] : Tendsto norm (cocompact E) atTop :=\n  cobounded_eq_cocompact (Œ± := E) ‚ñ∏ tendsto_norm_cobounded_atTop'\n\n"}
{"name":"Filter.inv_cobounded","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst‚úù : SeminormedGroup E\n‚ä¢ Eq (Inv.inv (Bornology.cobounded E)) (Bornology.cobounded E)","decl":"@[to_additive (attr := simp)]\nlemma Filter.inv_cobounded : (cobounded E)‚Åª¬π = cobounded E := by\n  simp only [‚Üê comap_norm_atTop', ‚Üê Filter.comap_inv, comap_comap, Function.comp_def, norm_inv']\n\n"}
{"name":"Filter.neg_cobounded","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst‚úù : SeminormedAddGroup E\n‚ä¢ Eq (Neg.neg (Bornology.cobounded E)) (Bornology.cobounded E)","decl":"@[to_additive (attr := simp)]\nlemma Filter.inv_cobounded : (cobounded E)‚Åª¬π = cobounded E := by\n  simp only [‚Üê comap_norm_atTop', ‚Üê Filter.comap_inv, comap_comap, Function.comp_def, norm_inv']\n\n"}
{"name":"Filter.tendsto_inv_cobounded","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst‚úù : SeminormedGroup E\n‚ä¢ Filter.Tendsto Inv.inv (Bornology.cobounded E) (Bornology.cobounded E)","decl":"/-- In a (semi)normed group, inversion `x ‚Ü¶ x‚Åª¬π` tends to infinity at infinity. -/\n@[to_additive \"In a (semi)normed group, negation `x ‚Ü¶ -x` tends to infinity at infinity.\"]\ntheorem Filter.tendsto_inv_cobounded : Tendsto Inv.inv (cobounded E) (cobounded E) :=\n  inv_cobounded.le\n\n"}
{"name":"Filter.tendsto_neg_cobounded","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst‚úù : SeminormedAddGroup E\n‚ä¢ Filter.Tendsto Neg.neg (Bornology.cobounded E) (Bornology.cobounded E)","decl":"/-- In a (semi)normed group, inversion `x ‚Ü¶ x‚Åª¬π` tends to infinity at infinity. -/\n@[to_additive \"In a (semi)normed group, negation `x ‚Ü¶ -x` tends to infinity at infinity.\"]\ntheorem Filter.tendsto_inv_cobounded : Tendsto Inv.inv (cobounded E) (cobounded E) :=\n  inv_cobounded.le\n\n"}
{"name":"isBounded_iff_forall_norm_le'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst‚úù : SeminormedGroup E\ns : Set E\n‚ä¢ Iff (Bornology.IsBounded s) (Exists fun C => ‚àÄ (x : E), Membership.mem s x ‚Üí LE.le (Norm.norm x) C)","decl":"@[to_additive isBounded_iff_forall_norm_le]\nlemma isBounded_iff_forall_norm_le' : Bornology.IsBounded s ‚Üî ‚àÉ C, ‚àÄ x ‚àà s, ‚Äñx‚Äñ ‚â§ C := by\n  simpa only [Set.subset_def, mem_closedBall_one_iff] using isBounded_iff_subset_closedBall (1 : E)\n\n"}
{"name":"isBounded_iff_forall_norm_le","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst‚úù : SeminormedAddGroup E\ns : Set E\n‚ä¢ Iff (Bornology.IsBounded s) (Exists fun C => ‚àÄ (x : E), Membership.mem s x ‚Üí LE.le (Norm.norm x) C)","decl":"@[to_additive isBounded_iff_forall_norm_le]\nlemma isBounded_iff_forall_norm_le' : Bornology.IsBounded s ‚Üî ‚àÉ C, ‚àÄ x ‚àà s, ‚Äñx‚Äñ ‚â§ C := by\n  simpa only [Set.subset_def, mem_closedBall_one_iff] using isBounded_iff_subset_closedBall (1 : E)\n\n"}
{"name":"Bornology.IsBounded.exists_norm_le'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst‚úù : SeminormedGroup E\ns : Set E\na‚úù : Bornology.IsBounded s\n‚ä¢ Exists fun C => ‚àÄ (x : E), Membership.mem s x ‚Üí LE.le (Norm.norm x) C","decl":"alias ‚ü®Bornology.IsBounded.exists_norm_le', _‚ü© := isBounded_iff_forall_norm_le'\n\n"}
{"name":"Bornology.IsBounded.exists_norm_le","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst‚úù : SeminormedAddGroup E\ns : Set E\na‚úù : Bornology.IsBounded s\n‚ä¢ Exists fun C => ‚àÄ (x : E), Membership.mem s x ‚Üí LE.le (Norm.norm x) C","decl":"alias ‚ü®Bornology.IsBounded.exists_norm_le, _‚ü© := isBounded_iff_forall_norm_le\n\n"}
{"name":"Bornology.IsBounded.exists_pos_norm_le","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst‚úù : SeminormedAddGroup E\ns : Set E\nhs : Bornology.IsBounded s\n‚ä¢ Exists fun R => And (GT.gt R 0) (‚àÄ (x : E), Membership.mem s x ‚Üí LE.le (Norm.norm x) R)","decl":"@[to_additive exists_pos_norm_le]\nlemma Bornology.IsBounded.exists_pos_norm_le' (hs : IsBounded s) : ‚àÉ R > 0, ‚àÄ x ‚àà s, ‚Äñx‚Äñ ‚â§ R :=\n  let ‚ü®R‚ÇÄ, hR‚ÇÄ‚ü© := hs.exists_norm_le'\n  ‚ü®max R‚ÇÄ 1, by positivity, fun x hx => (hR‚ÇÄ x hx).trans <| le_max_left _ _‚ü©\n\n"}
{"name":"Bornology.IsBounded.exists_pos_norm_le'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst‚úù : SeminormedGroup E\ns : Set E\nhs : Bornology.IsBounded s\n‚ä¢ Exists fun R => And (GT.gt R 0) (‚àÄ (x : E), Membership.mem s x ‚Üí LE.le (Norm.norm x) R)","decl":"@[to_additive exists_pos_norm_le]\nlemma Bornology.IsBounded.exists_pos_norm_le' (hs : IsBounded s) : ‚àÉ R > 0, ‚àÄ x ‚àà s, ‚Äñx‚Äñ ‚â§ R :=\n  let ‚ü®R‚ÇÄ, hR‚ÇÄ‚ü© := hs.exists_norm_le'\n  ‚ü®max R‚ÇÄ 1, by positivity, fun x hx => (hR‚ÇÄ x hx).trans <| le_max_left _ _‚ü©\n\n"}
{"name":"Bornology.IsBounded.exists_pos_norm_lt","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst‚úù : SeminormedAddGroup E\ns : Set E\nhs : Bornology.IsBounded s\n‚ä¢ Exists fun R => And (GT.gt R 0) (‚àÄ (x : E), Membership.mem s x ‚Üí LT.lt (Norm.norm x) R)","decl":"@[to_additive Bornology.IsBounded.exists_pos_norm_lt]\nlemma Bornology.IsBounded.exists_pos_norm_lt' (hs : IsBounded s) : ‚àÉ R > 0, ‚àÄ x ‚àà s, ‚Äñx‚Äñ < R :=\n  let ‚ü®R, hR‚ÇÄ, hR‚ü© := hs.exists_pos_norm_le'\n  ‚ü®R + 1, by positivity, fun x hx ‚Ü¶ (hR x hx).trans_lt (lt_add_one _)‚ü©\n\n"}
{"name":"Bornology.IsBounded.exists_pos_norm_lt'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst‚úù : SeminormedGroup E\ns : Set E\nhs : Bornology.IsBounded s\n‚ä¢ Exists fun R => And (GT.gt R 0) (‚àÄ (x : E), Membership.mem s x ‚Üí LT.lt (Norm.norm x) R)","decl":"@[to_additive Bornology.IsBounded.exists_pos_norm_lt]\nlemma Bornology.IsBounded.exists_pos_norm_lt' (hs : IsBounded s) : ‚àÉ R > 0, ‚àÄ x ‚àà s, ‚Äñx‚Äñ < R :=\n  let ‚ü®R, hR‚ÇÄ, hR‚ü© := hs.exists_pos_norm_le'\n  ‚ü®R + 1, by positivity, fun x hx ‚Ü¶ (hR x hx).trans_lt (lt_add_one _)‚ü©\n\n"}
{"name":"NormedAddCommGroup.cauchySeq_iff","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≤ : SeminormedAddGroup E\ninst‚úù¬π : Nonempty Œ±\ninst‚úù : SemilatticeSup Œ±\nu : Œ± ‚Üí E\n‚ä¢ Iff (CauchySeq u) (‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun N => ‚àÄ (m : Œ±), LE.le N m ‚Üí ‚àÄ (n : Œ±), LE.le N n ‚Üí LT.lt (Norm.norm (HSub.hSub (u m) (u n))) Œµ)","decl":"@[to_additive]\nlemma NormedCommGroup.cauchySeq_iff [Nonempty Œ±] [SemilatticeSup Œ±] {u : Œ± ‚Üí E} :\n    CauchySeq u ‚Üî ‚àÄ Œµ > 0, ‚àÉ N, ‚àÄ m, N ‚â§ m ‚Üí ‚àÄ n, N ‚â§ n ‚Üí ‚Äñu m / u n‚Äñ < Œµ := by\n  simp [Metric.cauchySeq_iff, dist_eq_norm_div]\n\n"}
{"name":"NormedCommGroup.cauchySeq_iff","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≤ : SeminormedGroup E\ninst‚úù¬π : Nonempty Œ±\ninst‚úù : SemilatticeSup Œ±\nu : Œ± ‚Üí E\n‚ä¢ Iff (CauchySeq u) (‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun N => ‚àÄ (m : Œ±), LE.le N m ‚Üí ‚àÄ (n : Œ±), LE.le N n ‚Üí LT.lt (Norm.norm (HDiv.hDiv (u m) (u n))) Œµ)","decl":"@[to_additive]\nlemma NormedCommGroup.cauchySeq_iff [Nonempty Œ±] [SemilatticeSup Œ±] {u : Œ± ‚Üí E} :\n    CauchySeq u ‚Üî ‚àÄ Œµ > 0, ‚àÉ N, ‚àÄ m, N ‚â§ m ‚Üí ‚àÄ n, N ‚â§ n ‚Üí ‚Äñu m / u n‚Äñ < Œµ := by\n  simp [Metric.cauchySeq_iff, dist_eq_norm_div]\n\n"}
{"name":"IsCompact.exists_bound_of_continuousOn'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : SeminormedGroup E\ninst‚úù : TopologicalSpace Œ±\ns : Set Œ±\nhs : IsCompact s\nf : Œ± ‚Üí E\nhf : ContinuousOn f s\n‚ä¢ Exists fun C => ‚àÄ (x : Œ±), Membership.mem s x ‚Üí LE.le (Norm.norm (f x)) C","decl":"@[to_additive IsCompact.exists_bound_of_continuousOn]\nlemma IsCompact.exists_bound_of_continuousOn' [TopologicalSpace Œ±] {s : Set Œ±} (hs : IsCompact s)\n    {f : Œ± ‚Üí E} (hf : ContinuousOn f s) : ‚àÉ C, ‚àÄ x ‚àà s, ‚Äñf x‚Äñ ‚â§ C :=\n  (isBounded_iff_forall_norm_le'.1 (hs.image_of_continuousOn hf).isBounded).imp fun _C hC _x hx =>\n    hC _ <| Set.mem_image_of_mem _ hx\n\n"}
{"name":"IsCompact.exists_bound_of_continuousOn","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : SeminormedAddGroup E\ninst‚úù : TopologicalSpace Œ±\ns : Set Œ±\nhs : IsCompact s\nf : Œ± ‚Üí E\nhf : ContinuousOn f s\n‚ä¢ Exists fun C => ‚àÄ (x : Œ±), Membership.mem s x ‚Üí LE.le (Norm.norm (f x)) C","decl":"@[to_additive IsCompact.exists_bound_of_continuousOn]\nlemma IsCompact.exists_bound_of_continuousOn' [TopologicalSpace Œ±] {s : Set Œ±} (hs : IsCompact s)\n    {f : Œ± ‚Üí E} (hf : ContinuousOn f s) : ‚àÉ C, ‚àÄ x ‚àà s, ‚Äñf x‚Äñ ‚â§ C :=\n  (isBounded_iff_forall_norm_le'.1 (hs.image_of_continuousOn hf).isBounded).imp fun _C hC _x hx =>\n    hC _ <| Set.mem_image_of_mem _ hx\n\n"}
{"name":"HasCompactMulSupport.exists_bound_of_continuous","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : SeminormedGroup E\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí E\nhf : HasCompactMulSupport f\nh'f : Continuous f\n‚ä¢ Exists fun C => ‚àÄ (x : Œ±), LE.le (Norm.norm (f x)) C","decl":"@[to_additive]\nlemma HasCompactMulSupport.exists_bound_of_continuous [TopologicalSpace Œ±]\n    {f : Œ± ‚Üí E} (hf : HasCompactMulSupport f) (h'f : Continuous f) : ‚àÉ C, ‚àÄ x, ‚Äñf x‚Äñ ‚â§ C := by\n  simpa using (hf.isCompact_range h'f).isBounded.exists_norm_le'\n\n"}
{"name":"HasCompactSupport.exists_bound_of_continuous","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : SeminormedAddGroup E\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí E\nhf : HasCompactSupport f\nh'f : Continuous f\n‚ä¢ Exists fun C => ‚àÄ (x : Œ±), LE.le (Norm.norm (f x)) C","decl":"@[to_additive]\nlemma HasCompactMulSupport.exists_bound_of_continuous [TopologicalSpace Œ±]\n    {f : Œ± ‚Üí E} (hf : HasCompactMulSupport f) (h'f : Continuous f) : ‚àÉ C, ‚àÄ x, ‚Äñf x‚Äñ ‚â§ C := by\n  simpa using (hf.isCompact_range h'f).isBounded.exists_norm_le'\n\n"}
{"name":"Filter.Tendsto.op_one_isBoundedUnder_le'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst‚úù¬≤ : SeminormedGroup E\ninst‚úù¬π : SeminormedGroup F\ninst‚úù : SeminormedGroup G\nf : Œ± ‚Üí E\ng : Œ± ‚Üí F\nl : Filter Œ±\nhf : Filter.Tendsto f l (nhds 1)\nhg : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp Norm.norm g)\nop : E ‚Üí F ‚Üí G\nh_op : Exists fun A => ‚àÄ (x : E) (y : F), LE.le (Norm.norm (op x y)) (HMul.hMul (HMul.hMul A (Norm.norm x)) (Norm.norm y))\n‚ä¢ Filter.Tendsto (fun x => op (f x) (g x)) l (nhds 1)","decl":"/-- A helper lemma used to prove that the (scalar or usual) product of a function that tends to one\nand a bounded function tends to one. This lemma is formulated for any binary operation\n`op : E ‚Üí F ‚Üí G` with an estimate `‚Äñop x y‚Äñ ‚â§ A * ‚Äñx‚Äñ * ‚Äñy‚Äñ` for some constant A instead of\nmultiplication so that it can be applied to `(*)`, `flip (*)`, `(‚Ä¢)`, and `flip (‚Ä¢)`. -/\n@[to_additive \"A helper lemma used to prove that the (scalar or usual) product of a function that\ntends to zero and a bounded function tends to zero. This lemma is formulated for any binary\noperation `op : E ‚Üí F ‚Üí G` with an estimate `‚Äñop x y‚Äñ ‚â§ A * ‚Äñx‚Äñ * ‚Äñy‚Äñ` for some constant A instead\nof multiplication so that it can be applied to `(*)`, `flip (*)`, `(‚Ä¢)`, and `flip (‚Ä¢)`.\"]\nlemma Filter.Tendsto.op_one_isBoundedUnder_le' {f : Œ± ‚Üí E} {g : Œ± ‚Üí F} {l : Filter Œ±}\n    (hf : Tendsto f l (ùìù 1)) (hg : IsBoundedUnder (¬∑ ‚â§ ¬∑) l (Norm.norm ‚àò g)) (op : E ‚Üí F ‚Üí G)\n    (h_op : ‚àÉ A, ‚àÄ x y, ‚Äñop x y‚Äñ ‚â§ A * ‚Äñx‚Äñ * ‚Äñy‚Äñ) : Tendsto (fun x => op (f x) (g x)) l (ùìù 1) := by\n  cases' h_op with A h_op\n  rcases hg with ‚ü®C, hC‚ü©; rw [eventually_map] at hC\n  rw [NormedCommGroup.tendsto_nhds_one] at hf ‚ä¢\n  intro Œµ Œµ‚ÇÄ\n  rcases exists_pos_mul_lt Œµ‚ÇÄ (A * C) with ‚ü®Œ¥, Œ¥‚ÇÄ, hŒ¥‚ü©\n  filter_upwards [hf Œ¥ Œ¥‚ÇÄ, hC] with i hf hg\n  refine (h_op _ _).trans_lt ?_\n  rcases le_total A 0 with hA | hA\n  ¬∑ exact (mul_nonpos_of_nonpos_of_nonneg (mul_nonpos_of_nonpos_of_nonneg hA <| norm_nonneg' _) <|\n      norm_nonneg' _).trans_lt Œµ‚ÇÄ\n  calc\n    A * ‚Äñf i‚Äñ * ‚Äñg i‚Äñ ‚â§ A * Œ¥ * C := by gcongr; exact hg\n    _ = A * C * Œ¥ := mul_right_comm _ _ _\n    _ < Œµ := hŒ¥\n\n"}
{"name":"Filter.Tendsto.op_zero_isBoundedUnder_le'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst‚úù¬≤ : SeminormedAddGroup E\ninst‚úù¬π : SeminormedAddGroup F\ninst‚úù : SeminormedAddGroup G\nf : Œ± ‚Üí E\ng : Œ± ‚Üí F\nl : Filter Œ±\nhf : Filter.Tendsto f l (nhds 0)\nhg : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp Norm.norm g)\nop : E ‚Üí F ‚Üí G\nh_op : Exists fun A => ‚àÄ (x : E) (y : F), LE.le (Norm.norm (op x y)) (HMul.hMul (HMul.hMul A (Norm.norm x)) (Norm.norm y))\n‚ä¢ Filter.Tendsto (fun x => op (f x) (g x)) l (nhds 0)","decl":"/-- A helper lemma used to prove that the (scalar or usual) product of a function that tends to one\nand a bounded function tends to one. This lemma is formulated for any binary operation\n`op : E ‚Üí F ‚Üí G` with an estimate `‚Äñop x y‚Äñ ‚â§ A * ‚Äñx‚Äñ * ‚Äñy‚Äñ` for some constant A instead of\nmultiplication so that it can be applied to `(*)`, `flip (*)`, `(‚Ä¢)`, and `flip (‚Ä¢)`. -/\n@[to_additive \"A helper lemma used to prove that the (scalar or usual) product of a function that\ntends to zero and a bounded function tends to zero. This lemma is formulated for any binary\noperation `op : E ‚Üí F ‚Üí G` with an estimate `‚Äñop x y‚Äñ ‚â§ A * ‚Äñx‚Äñ * ‚Äñy‚Äñ` for some constant A instead\nof multiplication so that it can be applied to `(*)`, `flip (*)`, `(‚Ä¢)`, and `flip (‚Ä¢)`.\"]\nlemma Filter.Tendsto.op_one_isBoundedUnder_le' {f : Œ± ‚Üí E} {g : Œ± ‚Üí F} {l : Filter Œ±}\n    (hf : Tendsto f l (ùìù 1)) (hg : IsBoundedUnder (¬∑ ‚â§ ¬∑) l (Norm.norm ‚àò g)) (op : E ‚Üí F ‚Üí G)\n    (h_op : ‚àÉ A, ‚àÄ x y, ‚Äñop x y‚Äñ ‚â§ A * ‚Äñx‚Äñ * ‚Äñy‚Äñ) : Tendsto (fun x => op (f x) (g x)) l (ùìù 1) := by\n  cases' h_op with A h_op\n  rcases hg with ‚ü®C, hC‚ü©; rw [eventually_map] at hC\n  rw [NormedCommGroup.tendsto_nhds_one] at hf ‚ä¢\n  intro Œµ Œµ‚ÇÄ\n  rcases exists_pos_mul_lt Œµ‚ÇÄ (A * C) with ‚ü®Œ¥, Œ¥‚ÇÄ, hŒ¥‚ü©\n  filter_upwards [hf Œ¥ Œ¥‚ÇÄ, hC] with i hf hg\n  refine (h_op _ _).trans_lt ?_\n  rcases le_total A 0 with hA | hA\n  ¬∑ exact (mul_nonpos_of_nonpos_of_nonneg (mul_nonpos_of_nonpos_of_nonneg hA <| norm_nonneg' _) <|\n      norm_nonneg' _).trans_lt Œµ‚ÇÄ\n  calc\n    A * ‚Äñf i‚Äñ * ‚Äñg i‚Äñ ‚â§ A * Œ¥ * C := by gcongr; exact hg\n    _ = A * C * Œ¥ := mul_right_comm _ _ _\n    _ < Œµ := hŒ¥\n\n"}
{"name":"Filter.Tendsto.op_one_isBoundedUnder_le","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst‚úù¬≤ : SeminormedGroup E\ninst‚úù¬π : SeminormedGroup F\ninst‚úù : SeminormedGroup G\nf : Œ± ‚Üí E\ng : Œ± ‚Üí F\nl : Filter Œ±\nhf : Filter.Tendsto f l (nhds 1)\nhg : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp Norm.norm g)\nop : E ‚Üí F ‚Üí G\nh_op : ‚àÄ (x : E) (y : F), LE.le (Norm.norm (op x y)) (HMul.hMul (Norm.norm x) (Norm.norm y))\n‚ä¢ Filter.Tendsto (fun x => op (f x) (g x)) l (nhds 1)","decl":"/-- A helper lemma used to prove that the (scalar or usual) product of a function that tends to one\nand a bounded function tends to one. This lemma is formulated for any binary operation\n`op : E ‚Üí F ‚Üí G` with an estimate `‚Äñop x y‚Äñ ‚â§ ‚Äñx‚Äñ * ‚Äñy‚Äñ` instead of multiplication so that it\ncan be applied to `(*)`, `flip (*)`, `(‚Ä¢)`, and `flip (‚Ä¢)`. -/\n@[to_additive \"A helper lemma used to prove that the (scalar or usual) product of a function that\ntends to zero and a bounded function tends to zero. This lemma is formulated for any binary\noperation `op : E ‚Üí F ‚Üí G` with an estimate `‚Äñop x y‚Äñ ‚â§ ‚Äñx‚Äñ * ‚Äñy‚Äñ` instead of multiplication so\nthat it can be applied to `(*)`, `flip (*)`, `(‚Ä¢)`, and `flip (‚Ä¢)`.\"]\ntheorem Filter.Tendsto.op_one_isBoundedUnder_le {f : Œ± ‚Üí E} {g : Œ± ‚Üí F} {l : Filter Œ±}\n    (hf : Tendsto f l (ùìù 1)) (hg : IsBoundedUnder (¬∑ ‚â§ ¬∑) l (Norm.norm ‚àò g)) (op : E ‚Üí F ‚Üí G)\n    (h_op : ‚àÄ x y, ‚Äñop x y‚Äñ ‚â§ ‚Äñx‚Äñ * ‚Äñy‚Äñ) : Tendsto (fun x => op (f x) (g x)) l (ùìù 1) :=\n  hf.op_one_isBoundedUnder_le' hg op ‚ü®1, fun x y => (one_mul ‚Äñx‚Äñ).symm ‚ñ∏ h_op x y‚ü©\n\n"}
{"name":"Filter.Tendsto.op_zero_isBoundedUnder_le","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst‚úù¬≤ : SeminormedAddGroup E\ninst‚úù¬π : SeminormedAddGroup F\ninst‚úù : SeminormedAddGroup G\nf : Œ± ‚Üí E\ng : Œ± ‚Üí F\nl : Filter Œ±\nhf : Filter.Tendsto f l (nhds 0)\nhg : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp Norm.norm g)\nop : E ‚Üí F ‚Üí G\nh_op : ‚àÄ (x : E) (y : F), LE.le (Norm.norm (op x y)) (HMul.hMul (Norm.norm x) (Norm.norm y))\n‚ä¢ Filter.Tendsto (fun x => op (f x) (g x)) l (nhds 0)","decl":"/-- A helper lemma used to prove that the (scalar or usual) product of a function that tends to one\nand a bounded function tends to one. This lemma is formulated for any binary operation\n`op : E ‚Üí F ‚Üí G` with an estimate `‚Äñop x y‚Äñ ‚â§ ‚Äñx‚Äñ * ‚Äñy‚Äñ` instead of multiplication so that it\ncan be applied to `(*)`, `flip (*)`, `(‚Ä¢)`, and `flip (‚Ä¢)`. -/\n@[to_additive \"A helper lemma used to prove that the (scalar or usual) product of a function that\ntends to zero and a bounded function tends to zero. This lemma is formulated for any binary\noperation `op : E ‚Üí F ‚Üí G` with an estimate `‚Äñop x y‚Äñ ‚â§ ‚Äñx‚Äñ * ‚Äñy‚Äñ` instead of multiplication so\nthat it can be applied to `(*)`, `flip (*)`, `(‚Ä¢)`, and `flip (‚Ä¢)`.\"]\ntheorem Filter.Tendsto.op_one_isBoundedUnder_le {f : Œ± ‚Üí E} {g : Œ± ‚Üí F} {l : Filter Œ±}\n    (hf : Tendsto f l (ùìù 1)) (hg : IsBoundedUnder (¬∑ ‚â§ ¬∑) l (Norm.norm ‚àò g)) (op : E ‚Üí F ‚Üí G)\n    (h_op : ‚àÄ x y, ‚Äñop x y‚Äñ ‚â§ ‚Äñx‚Äñ * ‚Äñy‚Äñ) : Tendsto (fun x => op (f x) (g x)) l (ùìù 1) :=\n  hf.op_one_isBoundedUnder_le' hg op ‚ü®1, fun x y => (one_mul ‚Äñx‚Äñ).symm ‚ñ∏ h_op x y‚ü©\n\n"}
{"name":"Continuous.bounded_above_of_compact_support","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : NormedAddGroup E\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí E\nhf : Continuous f\nh : HasCompactSupport f\n‚ä¢ Exists fun C => ‚àÄ (x : Œ±), LE.le (Norm.norm (f x)) C","decl":"lemma Continuous.bounded_above_of_compact_support (hf : Continuous f) (h : HasCompactSupport f) :\n    ‚àÉ C, ‚àÄ x, ‚Äñf x‚Äñ ‚â§ C := by\n  simpa [bddAbove_def] using hf.norm.bddAbove_range_of_hasCompactSupport h.norm\n\n"}
{"name":"HasCompactMulSupport.exists_pos_le_norm","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : NormedAddGroup Œ±\nf : Œ± ‚Üí E\ninst‚úù : One E\nhf : HasCompactMulSupport f\n‚ä¢ Exists fun R => And (LT.lt 0 R) (‚àÄ (x : Œ±), LE.le R (Norm.norm x) ‚Üí Eq (f x) 1)","decl":"@[to_additive]\nlemma HasCompactMulSupport.exists_pos_le_norm [One E] (hf : HasCompactMulSupport f) :\n    ‚àÉ R : ‚Ñù, 0 < R ‚àß ‚àÄ x : Œ±, R ‚â§ ‚Äñx‚Äñ ‚Üí f x = 1 := by\n  obtain ‚ü®K, ‚ü®hK1, hK2‚ü©‚ü© := exists_compact_iff_hasCompactMulSupport.mpr hf\n  obtain ‚ü®S, hS, hS'‚ü© := hK1.isBounded.exists_pos_norm_le\n  refine ‚ü®S + 1, by positivity, fun x hx => hK2 x ((mt <| hS' x) ?_)‚ü©\n  contrapose! hx\n  exact lt_add_of_le_of_pos hx zero_lt_one\n\n"}
{"name":"HasCompactSupport.exists_pos_le_norm","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : NormedAddGroup Œ±\nf : Œ± ‚Üí E\ninst‚úù : Zero E\nhf : HasCompactSupport f\n‚ä¢ Exists fun R => And (LT.lt 0 R) (‚àÄ (x : Œ±), LE.le R (Norm.norm x) ‚Üí Eq (f x) 0)","decl":"@[to_additive]\nlemma HasCompactMulSupport.exists_pos_le_norm [One E] (hf : HasCompactMulSupport f) :\n    ‚àÉ R : ‚Ñù, 0 < R ‚àß ‚àÄ x : Œ±, R ‚â§ ‚Äñx‚Äñ ‚Üí f x = 1 := by\n  obtain ‚ü®K, ‚ü®hK1, hK2‚ü©‚ü© := exists_compact_iff_hasCompactMulSupport.mpr hf\n  obtain ‚ü®S, hS, hS'‚ü© := hK1.isBounded.exists_pos_norm_le\n  refine ‚ü®S + 1, by positivity, fun x hx => hK2 x ((mt <| hS' x) ?_)‚ü©\n  contrapose! hx\n  exact lt_add_of_le_of_pos hx zero_lt_one\n\n"}
