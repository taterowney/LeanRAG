{"name":"comap_norm_atTop'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst✝ : SeminormedGroup E\n⊢ Eq (Filter.comap Norm.norm Filter.atTop) (Bornology.cobounded E)","decl":"@[to_additive (attr := simp) comap_norm_atTop]\nlemma comap_norm_atTop' : comap norm atTop = cobounded E := by\n  simpa only [dist_one_right] using comap_dist_right_atTop (1 : E)\n\n"}
{"name":"comap_norm_atTop","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst✝ : SeminormedAddGroup E\n⊢ Eq (Filter.comap Norm.norm Filter.atTop) (Bornology.cobounded E)","decl":"@[to_additive (attr := simp) comap_norm_atTop]\nlemma comap_norm_atTop' : comap norm atTop = cobounded E := by\n  simpa only [dist_one_right] using comap_dist_right_atTop (1 : E)\n\n"}
{"name":"Filter.HasBasis.cobounded_of_norm","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst✝ : SeminormedAddGroup E\nι : Sort u_5\np : ι → Prop\ns : ι → Set Real\nh : Filter.atTop.HasBasis p s\n⊢ (Bornology.cobounded E).HasBasis p fun i => Set.preimage Norm.norm (s i)","decl":"@[to_additive Filter.HasBasis.cobounded_of_norm]\nlemma Filter.HasBasis.cobounded_of_norm' {ι : Sort*} {p : ι → Prop} {s : ι → Set ℝ}\n    (h : HasBasis atTop p s) : HasBasis (cobounded E) p fun i ↦ norm ⁻¹' s i :=\n  comap_norm_atTop' (E := E) ▸ h.comap _\n\n"}
{"name":"Filter.HasBasis.cobounded_of_norm'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst✝ : SeminormedGroup E\nι : Sort u_5\np : ι → Prop\ns : ι → Set Real\nh : Filter.atTop.HasBasis p s\n⊢ (Bornology.cobounded E).HasBasis p fun i => Set.preimage Norm.norm (s i)","decl":"@[to_additive Filter.HasBasis.cobounded_of_norm]\nlemma Filter.HasBasis.cobounded_of_norm' {ι : Sort*} {p : ι → Prop} {s : ι → Set ℝ}\n    (h : HasBasis atTop p s) : HasBasis (cobounded E) p fun i ↦ norm ⁻¹' s i :=\n  comap_norm_atTop' (E := E) ▸ h.comap _\n\n"}
{"name":"Filter.hasBasis_cobounded_norm","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst✝ : SeminormedAddGroup E\n⊢ (Bornology.cobounded E).HasBasis (fun x => True) fun x => setOf fun x_1 => LE.le x (Norm.norm x_1)","decl":"@[to_additive Filter.hasBasis_cobounded_norm]\nlemma Filter.hasBasis_cobounded_norm' : HasBasis (cobounded E) (fun _ ↦ True) ({x | · ≤ ‖x‖}) :=\n  atTop_basis.cobounded_of_norm'\n\n"}
{"name":"Filter.hasBasis_cobounded_norm'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst✝ : SeminormedGroup E\n⊢ (Bornology.cobounded E).HasBasis (fun x => True) fun x => setOf fun x_1 => LE.le x (Norm.norm x_1)","decl":"@[to_additive Filter.hasBasis_cobounded_norm]\nlemma Filter.hasBasis_cobounded_norm' : HasBasis (cobounded E) (fun _ ↦ True) ({x | · ≤ ‖x‖}) :=\n  atTop_basis.cobounded_of_norm'\n\n"}
{"name":"tendsto_norm_atTop_iff_cobounded'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"α : Type u_1\nE : Type u_2\ninst✝ : SeminormedGroup E\nf : α → E\nl : Filter α\n⊢ Iff (Filter.Tendsto (fun x => Norm.norm (f x)) l Filter.atTop) (Filter.Tendsto f l (Bornology.cobounded E))","decl":"@[to_additive (attr := simp) tendsto_norm_atTop_iff_cobounded]\nlemma tendsto_norm_atTop_iff_cobounded' {f : α → E} {l : Filter α} :\n    Tendsto (‖f ·‖) l atTop ↔ Tendsto f l (cobounded E) := by\n  rw [← comap_norm_atTop', tendsto_comap_iff]; rfl\n\n"}
{"name":"tendsto_norm_atTop_iff_cobounded","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"α : Type u_1\nE : Type u_2\ninst✝ : SeminormedAddGroup E\nf : α → E\nl : Filter α\n⊢ Iff (Filter.Tendsto (fun x => Norm.norm (f x)) l Filter.atTop) (Filter.Tendsto f l (Bornology.cobounded E))","decl":"@[to_additive (attr := simp) tendsto_norm_atTop_iff_cobounded]\nlemma tendsto_norm_atTop_iff_cobounded' {f : α → E} {l : Filter α} :\n    Tendsto (‖f ·‖) l atTop ↔ Tendsto f l (cobounded E) := by\n  rw [← comap_norm_atTop', tendsto_comap_iff]; rfl\n\n"}
{"name":"tendsto_norm_cobounded_atTop'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst✝ : SeminormedGroup E\n⊢ Filter.Tendsto Norm.norm (Bornology.cobounded E) Filter.atTop","decl":"@[to_additive tendsto_norm_cobounded_atTop]\nlemma tendsto_norm_cobounded_atTop' : Tendsto norm (cobounded E) atTop :=\n  tendsto_norm_atTop_iff_cobounded'.2 tendsto_id\n\n"}
{"name":"tendsto_norm_cobounded_atTop","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst✝ : SeminormedAddGroup E\n⊢ Filter.Tendsto Norm.norm (Bornology.cobounded E) Filter.atTop","decl":"@[to_additive tendsto_norm_cobounded_atTop]\nlemma tendsto_norm_cobounded_atTop' : Tendsto norm (cobounded E) atTop :=\n  tendsto_norm_atTop_iff_cobounded'.2 tendsto_id\n\n"}
{"name":"eventually_cobounded_le_norm'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst✝ : SeminormedGroup E\na : Real\n⊢ Filter.Eventually (fun x => LE.le a (Norm.norm x)) (Bornology.cobounded E)","decl":"@[to_additive eventually_cobounded_le_norm]\nlemma eventually_cobounded_le_norm' (a : ℝ) : ∀ᶠ x in cobounded E, a ≤ ‖x‖ :=\n  tendsto_norm_cobounded_atTop'.eventually_ge_atTop a\n\n"}
{"name":"eventually_cobounded_le_norm","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst✝ : SeminormedAddGroup E\na : Real\n⊢ Filter.Eventually (fun x => LE.le a (Norm.norm x)) (Bornology.cobounded E)","decl":"@[to_additive eventually_cobounded_le_norm]\nlemma eventually_cobounded_le_norm' (a : ℝ) : ∀ᶠ x in cobounded E, a ≤ ‖x‖ :=\n  tendsto_norm_cobounded_atTop'.eventually_ge_atTop a\n\n"}
{"name":"tendsto_norm_cocompact_atTop'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst✝¹ : SeminormedGroup E\ninst✝ : ProperSpace E\n⊢ Filter.Tendsto Norm.norm (Filter.cocompact E) Filter.atTop","decl":"@[to_additive tendsto_norm_cocompact_atTop]\nlemma tendsto_norm_cocompact_atTop' [ProperSpace E] : Tendsto norm (cocompact E) atTop :=\n  cobounded_eq_cocompact (α := E) ▸ tendsto_norm_cobounded_atTop'\n\n"}
{"name":"tendsto_norm_cocompact_atTop","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst✝¹ : SeminormedAddGroup E\ninst✝ : ProperSpace E\n⊢ Filter.Tendsto Norm.norm (Filter.cocompact E) Filter.atTop","decl":"@[to_additive tendsto_norm_cocompact_atTop]\nlemma tendsto_norm_cocompact_atTop' [ProperSpace E] : Tendsto norm (cocompact E) atTop :=\n  cobounded_eq_cocompact (α := E) ▸ tendsto_norm_cobounded_atTop'\n\n"}
{"name":"Filter.inv_cobounded","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst✝ : SeminormedGroup E\n⊢ Eq (Inv.inv (Bornology.cobounded E)) (Bornology.cobounded E)","decl":"@[to_additive (attr := simp)]\nlemma Filter.inv_cobounded : (cobounded E)⁻¹ = cobounded E := by\n  simp only [← comap_norm_atTop', ← Filter.comap_inv, comap_comap, Function.comp_def, norm_inv']\n\n"}
{"name":"Filter.neg_cobounded","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst✝ : SeminormedAddGroup E\n⊢ Eq (Neg.neg (Bornology.cobounded E)) (Bornology.cobounded E)","decl":"@[to_additive (attr := simp)]\nlemma Filter.inv_cobounded : (cobounded E)⁻¹ = cobounded E := by\n  simp only [← comap_norm_atTop', ← Filter.comap_inv, comap_comap, Function.comp_def, norm_inv']\n\n"}
{"name":"Filter.tendsto_inv_cobounded","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst✝ : SeminormedGroup E\n⊢ Filter.Tendsto Inv.inv (Bornology.cobounded E) (Bornology.cobounded E)","decl":"/-- In a (semi)normed group, inversion `x ↦ x⁻¹` tends to infinity at infinity. -/\n@[to_additive \"In a (semi)normed group, negation `x ↦ -x` tends to infinity at infinity.\"]\ntheorem Filter.tendsto_inv_cobounded : Tendsto Inv.inv (cobounded E) (cobounded E) :=\n  inv_cobounded.le\n\n"}
{"name":"Filter.tendsto_neg_cobounded","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst✝ : SeminormedAddGroup E\n⊢ Filter.Tendsto Neg.neg (Bornology.cobounded E) (Bornology.cobounded E)","decl":"/-- In a (semi)normed group, inversion `x ↦ x⁻¹` tends to infinity at infinity. -/\n@[to_additive \"In a (semi)normed group, negation `x ↦ -x` tends to infinity at infinity.\"]\ntheorem Filter.tendsto_inv_cobounded : Tendsto Inv.inv (cobounded E) (cobounded E) :=\n  inv_cobounded.le\n\n"}
{"name":"isBounded_iff_forall_norm_le'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst✝ : SeminormedGroup E\ns : Set E\n⊢ Iff (Bornology.IsBounded s) (Exists fun C => ∀ (x : E), Membership.mem s x → LE.le (Norm.norm x) C)","decl":"@[to_additive isBounded_iff_forall_norm_le]\nlemma isBounded_iff_forall_norm_le' : Bornology.IsBounded s ↔ ∃ C, ∀ x ∈ s, ‖x‖ ≤ C := by\n  simpa only [Set.subset_def, mem_closedBall_one_iff] using isBounded_iff_subset_closedBall (1 : E)\n\n"}
{"name":"isBounded_iff_forall_norm_le","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst✝ : SeminormedAddGroup E\ns : Set E\n⊢ Iff (Bornology.IsBounded s) (Exists fun C => ∀ (x : E), Membership.mem s x → LE.le (Norm.norm x) C)","decl":"@[to_additive isBounded_iff_forall_norm_le]\nlemma isBounded_iff_forall_norm_le' : Bornology.IsBounded s ↔ ∃ C, ∀ x ∈ s, ‖x‖ ≤ C := by\n  simpa only [Set.subset_def, mem_closedBall_one_iff] using isBounded_iff_subset_closedBall (1 : E)\n\n"}
{"name":"Bornology.IsBounded.exists_norm_le'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst✝ : SeminormedGroup E\ns : Set E\na✝ : Bornology.IsBounded s\n⊢ Exists fun C => ∀ (x : E), Membership.mem s x → LE.le (Norm.norm x) C","decl":"alias ⟨Bornology.IsBounded.exists_norm_le', _⟩ := isBounded_iff_forall_norm_le'\n\n"}
{"name":"Bornology.IsBounded.exists_norm_le","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst✝ : SeminormedAddGroup E\ns : Set E\na✝ : Bornology.IsBounded s\n⊢ Exists fun C => ∀ (x : E), Membership.mem s x → LE.le (Norm.norm x) C","decl":"alias ⟨Bornology.IsBounded.exists_norm_le, _⟩ := isBounded_iff_forall_norm_le\n\n"}
{"name":"Bornology.IsBounded.exists_pos_norm_le","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst✝ : SeminormedAddGroup E\ns : Set E\nhs : Bornology.IsBounded s\n⊢ Exists fun R => And (GT.gt R 0) (∀ (x : E), Membership.mem s x → LE.le (Norm.norm x) R)","decl":"@[to_additive exists_pos_norm_le]\nlemma Bornology.IsBounded.exists_pos_norm_le' (hs : IsBounded s) : ∃ R > 0, ∀ x ∈ s, ‖x‖ ≤ R :=\n  let ⟨R₀, hR₀⟩ := hs.exists_norm_le'\n  ⟨max R₀ 1, by positivity, fun x hx => (hR₀ x hx).trans <| le_max_left _ _⟩\n\n"}
{"name":"Bornology.IsBounded.exists_pos_norm_le'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst✝ : SeminormedGroup E\ns : Set E\nhs : Bornology.IsBounded s\n⊢ Exists fun R => And (GT.gt R 0) (∀ (x : E), Membership.mem s x → LE.le (Norm.norm x) R)","decl":"@[to_additive exists_pos_norm_le]\nlemma Bornology.IsBounded.exists_pos_norm_le' (hs : IsBounded s) : ∃ R > 0, ∀ x ∈ s, ‖x‖ ≤ R :=\n  let ⟨R₀, hR₀⟩ := hs.exists_norm_le'\n  ⟨max R₀ 1, by positivity, fun x hx => (hR₀ x hx).trans <| le_max_left _ _⟩\n\n"}
{"name":"Bornology.IsBounded.exists_pos_norm_lt","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst✝ : SeminormedAddGroup E\ns : Set E\nhs : Bornology.IsBounded s\n⊢ Exists fun R => And (GT.gt R 0) (∀ (x : E), Membership.mem s x → LT.lt (Norm.norm x) R)","decl":"@[to_additive Bornology.IsBounded.exists_pos_norm_lt]\nlemma Bornology.IsBounded.exists_pos_norm_lt' (hs : IsBounded s) : ∃ R > 0, ∀ x ∈ s, ‖x‖ < R :=\n  let ⟨R, hR₀, hR⟩ := hs.exists_pos_norm_le'\n  ⟨R + 1, by positivity, fun x hx ↦ (hR x hx).trans_lt (lt_add_one _)⟩\n\n"}
{"name":"Bornology.IsBounded.exists_pos_norm_lt'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"E : Type u_2\ninst✝ : SeminormedGroup E\ns : Set E\nhs : Bornology.IsBounded s\n⊢ Exists fun R => And (GT.gt R 0) (∀ (x : E), Membership.mem s x → LT.lt (Norm.norm x) R)","decl":"@[to_additive Bornology.IsBounded.exists_pos_norm_lt]\nlemma Bornology.IsBounded.exists_pos_norm_lt' (hs : IsBounded s) : ∃ R > 0, ∀ x ∈ s, ‖x‖ < R :=\n  let ⟨R, hR₀, hR⟩ := hs.exists_pos_norm_le'\n  ⟨R + 1, by positivity, fun x hx ↦ (hR x hx).trans_lt (lt_add_one _)⟩\n\n"}
{"name":"NormedAddCommGroup.cauchySeq_iff","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"α : Type u_1\nE : Type u_2\ninst✝² : SeminormedAddGroup E\ninst✝¹ : Nonempty α\ninst✝ : SemilatticeSup α\nu : α → E\n⊢ Iff (CauchySeq u) (∀ (ε : Real), GT.gt ε 0 → Exists fun N => ∀ (m : α), LE.le N m → ∀ (n : α), LE.le N n → LT.lt (Norm.norm (HSub.hSub (u m) (u n))) ε)","decl":"@[to_additive]\nlemma NormedCommGroup.cauchySeq_iff [Nonempty α] [SemilatticeSup α] {u : α → E} :\n    CauchySeq u ↔ ∀ ε > 0, ∃ N, ∀ m, N ≤ m → ∀ n, N ≤ n → ‖u m / u n‖ < ε := by\n  simp [Metric.cauchySeq_iff, dist_eq_norm_div]\n\n"}
{"name":"NormedCommGroup.cauchySeq_iff","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"α : Type u_1\nE : Type u_2\ninst✝² : SeminormedGroup E\ninst✝¹ : Nonempty α\ninst✝ : SemilatticeSup α\nu : α → E\n⊢ Iff (CauchySeq u) (∀ (ε : Real), GT.gt ε 0 → Exists fun N => ∀ (m : α), LE.le N m → ∀ (n : α), LE.le N n → LT.lt (Norm.norm (HDiv.hDiv (u m) (u n))) ε)","decl":"@[to_additive]\nlemma NormedCommGroup.cauchySeq_iff [Nonempty α] [SemilatticeSup α] {u : α → E} :\n    CauchySeq u ↔ ∀ ε > 0, ∃ N, ∀ m, N ≤ m → ∀ n, N ≤ n → ‖u m / u n‖ < ε := by\n  simp [Metric.cauchySeq_iff, dist_eq_norm_div]\n\n"}
{"name":"IsCompact.exists_bound_of_continuousOn'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"α : Type u_1\nE : Type u_2\ninst✝¹ : SeminormedGroup E\ninst✝ : TopologicalSpace α\ns : Set α\nhs : IsCompact s\nf : α → E\nhf : ContinuousOn f s\n⊢ Exists fun C => ∀ (x : α), Membership.mem s x → LE.le (Norm.norm (f x)) C","decl":"@[to_additive IsCompact.exists_bound_of_continuousOn]\nlemma IsCompact.exists_bound_of_continuousOn' [TopologicalSpace α] {s : Set α} (hs : IsCompact s)\n    {f : α → E} (hf : ContinuousOn f s) : ∃ C, ∀ x ∈ s, ‖f x‖ ≤ C :=\n  (isBounded_iff_forall_norm_le'.1 (hs.image_of_continuousOn hf).isBounded).imp fun _C hC _x hx =>\n    hC _ <| Set.mem_image_of_mem _ hx\n\n"}
{"name":"IsCompact.exists_bound_of_continuousOn","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"α : Type u_1\nE : Type u_2\ninst✝¹ : SeminormedAddGroup E\ninst✝ : TopologicalSpace α\ns : Set α\nhs : IsCompact s\nf : α → E\nhf : ContinuousOn f s\n⊢ Exists fun C => ∀ (x : α), Membership.mem s x → LE.le (Norm.norm (f x)) C","decl":"@[to_additive IsCompact.exists_bound_of_continuousOn]\nlemma IsCompact.exists_bound_of_continuousOn' [TopologicalSpace α] {s : Set α} (hs : IsCompact s)\n    {f : α → E} (hf : ContinuousOn f s) : ∃ C, ∀ x ∈ s, ‖f x‖ ≤ C :=\n  (isBounded_iff_forall_norm_le'.1 (hs.image_of_continuousOn hf).isBounded).imp fun _C hC _x hx =>\n    hC _ <| Set.mem_image_of_mem _ hx\n\n"}
{"name":"HasCompactMulSupport.exists_bound_of_continuous","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"α : Type u_1\nE : Type u_2\ninst✝¹ : SeminormedGroup E\ninst✝ : TopologicalSpace α\nf : α → E\nhf : HasCompactMulSupport f\nh'f : Continuous f\n⊢ Exists fun C => ∀ (x : α), LE.le (Norm.norm (f x)) C","decl":"@[to_additive]\nlemma HasCompactMulSupport.exists_bound_of_continuous [TopologicalSpace α]\n    {f : α → E} (hf : HasCompactMulSupport f) (h'f : Continuous f) : ∃ C, ∀ x, ‖f x‖ ≤ C := by\n  simpa using (hf.isCompact_range h'f).isBounded.exists_norm_le'\n\n"}
{"name":"HasCompactSupport.exists_bound_of_continuous","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"α : Type u_1\nE : Type u_2\ninst✝¹ : SeminormedAddGroup E\ninst✝ : TopologicalSpace α\nf : α → E\nhf : HasCompactSupport f\nh'f : Continuous f\n⊢ Exists fun C => ∀ (x : α), LE.le (Norm.norm (f x)) C","decl":"@[to_additive]\nlemma HasCompactMulSupport.exists_bound_of_continuous [TopologicalSpace α]\n    {f : α → E} (hf : HasCompactMulSupport f) (h'f : Continuous f) : ∃ C, ∀ x, ‖f x‖ ≤ C := by\n  simpa using (hf.isCompact_range h'f).isBounded.exists_norm_le'\n\n"}
{"name":"Filter.Tendsto.op_one_isBoundedUnder_le'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝² : SeminormedGroup E\ninst✝¹ : SeminormedGroup F\ninst✝ : SeminormedGroup G\nf : α → E\ng : α → F\nl : Filter α\nhf : Filter.Tendsto f l (nhds 1)\nhg : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp Norm.norm g)\nop : E → F → G\nh_op : Exists fun A => ∀ (x : E) (y : F), LE.le (Norm.norm (op x y)) (HMul.hMul (HMul.hMul A (Norm.norm x)) (Norm.norm y))\n⊢ Filter.Tendsto (fun x => op (f x) (g x)) l (nhds 1)","decl":"/-- A helper lemma used to prove that the (scalar or usual) product of a function that tends to one\nand a bounded function tends to one. This lemma is formulated for any binary operation\n`op : E → F → G` with an estimate `‖op x y‖ ≤ A * ‖x‖ * ‖y‖` for some constant A instead of\nmultiplication so that it can be applied to `(*)`, `flip (*)`, `(•)`, and `flip (•)`. -/\n@[to_additive \"A helper lemma used to prove that the (scalar or usual) product of a function that\ntends to zero and a bounded function tends to zero. This lemma is formulated for any binary\noperation `op : E → F → G` with an estimate `‖op x y‖ ≤ A * ‖x‖ * ‖y‖` for some constant A instead\nof multiplication so that it can be applied to `(*)`, `flip (*)`, `(•)`, and `flip (•)`.\"]\nlemma Filter.Tendsto.op_one_isBoundedUnder_le' {f : α → E} {g : α → F} {l : Filter α}\n    (hf : Tendsto f l (𝓝 1)) (hg : IsBoundedUnder (· ≤ ·) l (Norm.norm ∘ g)) (op : E → F → G)\n    (h_op : ∃ A, ∀ x y, ‖op x y‖ ≤ A * ‖x‖ * ‖y‖) : Tendsto (fun x => op (f x) (g x)) l (𝓝 1) := by\n  cases' h_op with A h_op\n  rcases hg with ⟨C, hC⟩; rw [eventually_map] at hC\n  rw [NormedCommGroup.tendsto_nhds_one] at hf ⊢\n  intro ε ε₀\n  rcases exists_pos_mul_lt ε₀ (A * C) with ⟨δ, δ₀, hδ⟩\n  filter_upwards [hf δ δ₀, hC] with i hf hg\n  refine (h_op _ _).trans_lt ?_\n  rcases le_total A 0 with hA | hA\n  · exact (mul_nonpos_of_nonpos_of_nonneg (mul_nonpos_of_nonpos_of_nonneg hA <| norm_nonneg' _) <|\n      norm_nonneg' _).trans_lt ε₀\n  calc\n    A * ‖f i‖ * ‖g i‖ ≤ A * δ * C := by gcongr; exact hg\n    _ = A * C * δ := mul_right_comm _ _ _\n    _ < ε := hδ\n\n"}
{"name":"Filter.Tendsto.op_zero_isBoundedUnder_le'","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝² : SeminormedAddGroup E\ninst✝¹ : SeminormedAddGroup F\ninst✝ : SeminormedAddGroup G\nf : α → E\ng : α → F\nl : Filter α\nhf : Filter.Tendsto f l (nhds 0)\nhg : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp Norm.norm g)\nop : E → F → G\nh_op : Exists fun A => ∀ (x : E) (y : F), LE.le (Norm.norm (op x y)) (HMul.hMul (HMul.hMul A (Norm.norm x)) (Norm.norm y))\n⊢ Filter.Tendsto (fun x => op (f x) (g x)) l (nhds 0)","decl":"/-- A helper lemma used to prove that the (scalar or usual) product of a function that tends to one\nand a bounded function tends to one. This lemma is formulated for any binary operation\n`op : E → F → G` with an estimate `‖op x y‖ ≤ A * ‖x‖ * ‖y‖` for some constant A instead of\nmultiplication so that it can be applied to `(*)`, `flip (*)`, `(•)`, and `flip (•)`. -/\n@[to_additive \"A helper lemma used to prove that the (scalar or usual) product of a function that\ntends to zero and a bounded function tends to zero. This lemma is formulated for any binary\noperation `op : E → F → G` with an estimate `‖op x y‖ ≤ A * ‖x‖ * ‖y‖` for some constant A instead\nof multiplication so that it can be applied to `(*)`, `flip (*)`, `(•)`, and `flip (•)`.\"]\nlemma Filter.Tendsto.op_one_isBoundedUnder_le' {f : α → E} {g : α → F} {l : Filter α}\n    (hf : Tendsto f l (𝓝 1)) (hg : IsBoundedUnder (· ≤ ·) l (Norm.norm ∘ g)) (op : E → F → G)\n    (h_op : ∃ A, ∀ x y, ‖op x y‖ ≤ A * ‖x‖ * ‖y‖) : Tendsto (fun x => op (f x) (g x)) l (𝓝 1) := by\n  cases' h_op with A h_op\n  rcases hg with ⟨C, hC⟩; rw [eventually_map] at hC\n  rw [NormedCommGroup.tendsto_nhds_one] at hf ⊢\n  intro ε ε₀\n  rcases exists_pos_mul_lt ε₀ (A * C) with ⟨δ, δ₀, hδ⟩\n  filter_upwards [hf δ δ₀, hC] with i hf hg\n  refine (h_op _ _).trans_lt ?_\n  rcases le_total A 0 with hA | hA\n  · exact (mul_nonpos_of_nonpos_of_nonneg (mul_nonpos_of_nonpos_of_nonneg hA <| norm_nonneg' _) <|\n      norm_nonneg' _).trans_lt ε₀\n  calc\n    A * ‖f i‖ * ‖g i‖ ≤ A * δ * C := by gcongr; exact hg\n    _ = A * C * δ := mul_right_comm _ _ _\n    _ < ε := hδ\n\n"}
{"name":"Filter.Tendsto.op_one_isBoundedUnder_le","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝² : SeminormedGroup E\ninst✝¹ : SeminormedGroup F\ninst✝ : SeminormedGroup G\nf : α → E\ng : α → F\nl : Filter α\nhf : Filter.Tendsto f l (nhds 1)\nhg : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp Norm.norm g)\nop : E → F → G\nh_op : ∀ (x : E) (y : F), LE.le (Norm.norm (op x y)) (HMul.hMul (Norm.norm x) (Norm.norm y))\n⊢ Filter.Tendsto (fun x => op (f x) (g x)) l (nhds 1)","decl":"/-- A helper lemma used to prove that the (scalar or usual) product of a function that tends to one\nand a bounded function tends to one. This lemma is formulated for any binary operation\n`op : E → F → G` with an estimate `‖op x y‖ ≤ ‖x‖ * ‖y‖` instead of multiplication so that it\ncan be applied to `(*)`, `flip (*)`, `(•)`, and `flip (•)`. -/\n@[to_additive \"A helper lemma used to prove that the (scalar or usual) product of a function that\ntends to zero and a bounded function tends to zero. This lemma is formulated for any binary\noperation `op : E → F → G` with an estimate `‖op x y‖ ≤ ‖x‖ * ‖y‖` instead of multiplication so\nthat it can be applied to `(*)`, `flip (*)`, `(•)`, and `flip (•)`.\"]\ntheorem Filter.Tendsto.op_one_isBoundedUnder_le {f : α → E} {g : α → F} {l : Filter α}\n    (hf : Tendsto f l (𝓝 1)) (hg : IsBoundedUnder (· ≤ ·) l (Norm.norm ∘ g)) (op : E → F → G)\n    (h_op : ∀ x y, ‖op x y‖ ≤ ‖x‖ * ‖y‖) : Tendsto (fun x => op (f x) (g x)) l (𝓝 1) :=\n  hf.op_one_isBoundedUnder_le' hg op ⟨1, fun x y => (one_mul ‖x‖).symm ▸ h_op x y⟩\n\n"}
{"name":"Filter.Tendsto.op_zero_isBoundedUnder_le","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝² : SeminormedAddGroup E\ninst✝¹ : SeminormedAddGroup F\ninst✝ : SeminormedAddGroup G\nf : α → E\ng : α → F\nl : Filter α\nhf : Filter.Tendsto f l (nhds 0)\nhg : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp Norm.norm g)\nop : E → F → G\nh_op : ∀ (x : E) (y : F), LE.le (Norm.norm (op x y)) (HMul.hMul (Norm.norm x) (Norm.norm y))\n⊢ Filter.Tendsto (fun x => op (f x) (g x)) l (nhds 0)","decl":"/-- A helper lemma used to prove that the (scalar or usual) product of a function that tends to one\nand a bounded function tends to one. This lemma is formulated for any binary operation\n`op : E → F → G` with an estimate `‖op x y‖ ≤ ‖x‖ * ‖y‖` instead of multiplication so that it\ncan be applied to `(*)`, `flip (*)`, `(•)`, and `flip (•)`. -/\n@[to_additive \"A helper lemma used to prove that the (scalar or usual) product of a function that\ntends to zero and a bounded function tends to zero. This lemma is formulated for any binary\noperation `op : E → F → G` with an estimate `‖op x y‖ ≤ ‖x‖ * ‖y‖` instead of multiplication so\nthat it can be applied to `(*)`, `flip (*)`, `(•)`, and `flip (•)`.\"]\ntheorem Filter.Tendsto.op_one_isBoundedUnder_le {f : α → E} {g : α → F} {l : Filter α}\n    (hf : Tendsto f l (𝓝 1)) (hg : IsBoundedUnder (· ≤ ·) l (Norm.norm ∘ g)) (op : E → F → G)\n    (h_op : ∀ x y, ‖op x y‖ ≤ ‖x‖ * ‖y‖) : Tendsto (fun x => op (f x) (g x)) l (𝓝 1) :=\n  hf.op_one_isBoundedUnder_le' hg op ⟨1, fun x y => (one_mul ‖x‖).symm ▸ h_op x y⟩\n\n"}
{"name":"Continuous.bounded_above_of_compact_support","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"α : Type u_1\nE : Type u_2\ninst✝¹ : NormedAddGroup E\ninst✝ : TopologicalSpace α\nf : α → E\nhf : Continuous f\nh : HasCompactSupport f\n⊢ Exists fun C => ∀ (x : α), LE.le (Norm.norm (f x)) C","decl":"lemma Continuous.bounded_above_of_compact_support (hf : Continuous f) (h : HasCompactSupport f) :\n    ∃ C, ∀ x, ‖f x‖ ≤ C := by\n  simpa [bddAbove_def] using hf.norm.bddAbove_range_of_hasCompactSupport h.norm\n\n"}
{"name":"HasCompactMulSupport.exists_pos_le_norm","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"α : Type u_1\nE : Type u_2\ninst✝¹ : NormedAddGroup α\nf : α → E\ninst✝ : One E\nhf : HasCompactMulSupport f\n⊢ Exists fun R => And (LT.lt 0 R) (∀ (x : α), LE.le R (Norm.norm x) → Eq (f x) 1)","decl":"@[to_additive]\nlemma HasCompactMulSupport.exists_pos_le_norm [One E] (hf : HasCompactMulSupport f) :\n    ∃ R : ℝ, 0 < R ∧ ∀ x : α, R ≤ ‖x‖ → f x = 1 := by\n  obtain ⟨K, ⟨hK1, hK2⟩⟩ := exists_compact_iff_hasCompactMulSupport.mpr hf\n  obtain ⟨S, hS, hS'⟩ := hK1.isBounded.exists_pos_norm_le\n  refine ⟨S + 1, by positivity, fun x hx => hK2 x ((mt <| hS' x) ?_)⟩\n  contrapose! hx\n  exact lt_add_of_le_of_pos hx zero_lt_one\n\n"}
{"name":"HasCompactSupport.exists_pos_le_norm","module":"Mathlib.Analysis.Normed.Group.Bounded","initialProofState":"α : Type u_1\nE : Type u_2\ninst✝¹ : NormedAddGroup α\nf : α → E\ninst✝ : Zero E\nhf : HasCompactSupport f\n⊢ Exists fun R => And (LT.lt 0 R) (∀ (x : α), LE.le R (Norm.norm x) → Eq (f x) 0)","decl":"@[to_additive]\nlemma HasCompactMulSupport.exists_pos_le_norm [One E] (hf : HasCompactMulSupport f) :\n    ∃ R : ℝ, 0 < R ∧ ∀ x : α, R ≤ ‖x‖ → f x = 1 := by\n  obtain ⟨K, ⟨hK1, hK2⟩⟩ := exists_compact_iff_hasCompactMulSupport.mpr hf\n  obtain ⟨S, hS, hS'⟩ := hK1.isBounded.exists_pos_norm_le\n  refine ⟨S + 1, by positivity, fun x hx => hK2 x ((mt <| hS' x) ?_)⟩\n  contrapose! hx\n  exact lt_add_of_le_of_pos hx zero_lt_one\n\n"}
