{"name":"ModelWithCorners.isInteriorPoint_iff","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ Iff (I.IsInteriorPoint x) (Membership.mem (interior (extChartAt I x).target) (â†‘(extChartAt I x) x))","decl":"lemma isInteriorPoint_iff {x : M} :\n    I.IsInteriorPoint x â†” extChartAt I x x âˆˆ interior (extChartAt I x).target :=\n  âŸ¨fun h â†¦ (chartAt H x).mem_interior_extend_target (mem_chart_target H x) h,\n    fun h â†¦ PartialHomeomorph.interior_extend_target_subset_interior_range _ hâŸ©\n\n"}
{"name":"ModelWithCorners.isBoundaryPoint_iff","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ Iff (I.IsBoundaryPoint x) (Membership.mem (frontier (Set.range â†‘I)) (â†‘(extChartAt I x) x))","decl":"lemma isBoundaryPoint_iff {x : M} : I.IsBoundaryPoint x â†” extChartAt I x x âˆˆ frontier (range I) :=\n  Iff.rfl\n\n"}
{"name":"ModelWithCorners.isInteriorPoint_or_isBoundaryPoint","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ Or (I.IsInteriorPoint x) (I.IsBoundaryPoint x)","decl":"/-- Every point is either an interior or a boundary point. -/\nlemma isInteriorPoint_or_isBoundaryPoint (x : M) : I.IsInteriorPoint x âˆ¨ I.IsBoundaryPoint x := by\n  rw [IsInteriorPoint, or_iff_not_imp_left, I.isBoundaryPoint_iff, â† closure_diff_interior,\n    I.isClosed_range.closure_eq, mem_diff]\n  exact fun h â†¦ âŸ¨mem_range_self _, hâŸ©\n\n"}
{"name":"ModelWithCorners.interior_union_boundary_eq_univ","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\nâŠ¢ Eq (Union.union (ModelWithCorners.interior M) (ModelWithCorners.boundary M)) Set.univ","decl":"/-- A manifold decomposes into interior and boundary. -/\nlemma interior_union_boundary_eq_univ : (I.interior M) âˆª (I.boundary M) = (univ : Set M) :=\n  eq_univ_of_forall fun x => (mem_union _ _ _).mpr (I.isInteriorPoint_or_isBoundaryPoint x)\n\n"}
{"name":"ModelWithCorners.disjoint_interior_boundary","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\nâŠ¢ Disjoint (ModelWithCorners.interior M) (ModelWithCorners.boundary M)","decl":"/-- The interior and boundary of a manifold `M` are disjoint. -/\nlemma disjoint_interior_boundary : Disjoint (I.interior M) (I.boundary M) := by\n  by_contra h\n  -- Choose some x in the intersection of interior and boundary.\n  obtain âŸ¨x, h1, h2âŸ© := not_disjoint_iff.mp h\n  rw [â† mem_empty_iff_false (extChartAt I x x),\n    â† disjoint_iff_inter_eq_empty.mp disjoint_interior_frontier, mem_inter_iff]\n  exact âŸ¨h1, h2âŸ©\n\n"}
{"name":"ModelWithCorners.isInteriorPoint_iff_not_isBoundaryPoint","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ Iff (I.IsInteriorPoint x) (Not (I.IsBoundaryPoint x))","decl":"lemma isInteriorPoint_iff_not_isBoundaryPoint (x : M) :\n    I.IsInteriorPoint x â†” Â¬I.IsBoundaryPoint x := by\n  refine âŸ¨?_,\n    by simpa only [or_iff_not_imp_right] using isInteriorPoint_or_isBoundaryPoint x (I := I)âŸ©\n  by_contra! h\n  rw [â† mem_empty_iff_false (extChartAt I x x),\n    â† disjoint_iff_inter_eq_empty.mp disjoint_interior_frontier, mem_inter_iff]\n  exact h\n\n"}
{"name":"ModelWithCorners.compl_interior","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\nâŠ¢ Eq (HasCompl.compl (ModelWithCorners.interior M)) (ModelWithCorners.boundary M)","decl":"/-- The boundary is the complement of the interior. -/\nlemma compl_interior : (I.interior M)á¶œ = I.boundary M:= by\n  apply compl_unique ?_ I.interior_union_boundary_eq_univ\n  exact disjoint_iff_inter_eq_empty.mp I.disjoint_interior_boundary\n\n"}
{"name":"ModelWithCorners.compl_boundary","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\nâŠ¢ Eq (HasCompl.compl (ModelWithCorners.boundary M)) (ModelWithCorners.interior M)","decl":"/-- The interior is the complement of the boundary. -/\nlemma compl_boundary : (I.boundary M)á¶œ = I.interior M:= by\n  rw [â† compl_interior, compl_compl]\n\n"}
{"name":"range_mem_nhds_isInteriorPoint","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\nx : M\nh : I.IsInteriorPoint x\nâŠ¢ Membership.mem (nhds (â†‘(extChartAt I x) x)) (Set.range â†‘I)","decl":"lemma _root_.range_mem_nhds_isInteriorPoint {x : M} (h : I.IsInteriorPoint x) :\n    range I âˆˆ ğ“ (extChartAt I x x) := by\n  rw [mem_nhds_iff]\n  exact âŸ¨interior (range I), interior_subset, isOpen_interior, hâŸ©\n\n"}
{"name":"BoundarylessManifold.isInteriorPoint'","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_5\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_6\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nH : Type u_7\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_8\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\nself : BoundarylessManifold I M\nx : M\nâŠ¢ I.IsInteriorPoint x","decl":"/-- Type class for manifold without boundary. This differs from `ModelWithCorners.Boundaryless`,\n  which states that the `ModelWithCorners` maps to the whole model vector space. -/\nclass _root_.BoundarylessManifold {ğ•œ : Type*} [NontriviallyNormedField ğ•œ]\n    {E : Type*} [NormedAddCommGroup E] [NormedSpace ğ•œ E]\n    {H : Type*} [TopologicalSpace H] (I : ModelWithCorners ğ•œ E H)\n    (M : Type*) [TopologicalSpace M] [ChartedSpace H M] : Prop where\n  isInteriorPoint' : âˆ€ x : M, IsInteriorPoint I x\n\n"}
{"name":"ModelWithCorners.instBoundarylessManifold","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\nâŠ¢ BoundarylessManifold I M","decl":"/-- Boundaryless `ModelWithCorners` implies boundaryless manifold. -/\ninstance : BoundarylessManifold I M where\n  isInteriorPoint' x := by\n    let r := ((chartAt H x).isOpen_extend_target (I := I)).interior_eq\n    have : extChartAt I x = (chartAt H x).extend I := rfl\n    rw [â† this] at r\n    rw [isInteriorPoint_iff, r]\n    exact PartialEquiv.map_source _ (mem_extChartAt_source _)\n\n"}
{"name":"ModelWithCorners.BoundarylessManifold.of_empty","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : IsEmpty M\nâŠ¢ BoundarylessManifold I M","decl":"/-- The empty manifold is boundaryless. -/\ninstance BoundarylessManifold.of_empty [IsEmpty M] : BoundarylessManifold I M where\n  isInteriorPoint' x := (IsEmpty.false x).elim\n\n"}
{"name":"BoundarylessManifold.isInteriorPoint","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\nx : M\ninstâœ : BoundarylessManifold I M\nâŠ¢ I.IsInteriorPoint x","decl":"lemma _root_.BoundarylessManifold.isInteriorPoint {x : M} [BoundarylessManifold I M] :\n    IsInteriorPoint I x := BoundarylessManifold.isInteriorPoint' x\n\n"}
{"name":"ModelWithCorners.interior_eq_univ","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : BoundarylessManifold I M\nâŠ¢ Eq (ModelWithCorners.interior M) Set.univ","decl":"/-- If `I` is boundaryless, `M` has full interior. -/\nlemma interior_eq_univ [BoundarylessManifold I M] : I.interior M = univ :=\n  eq_univ_of_forall fun _ => BoundarylessManifold.isInteriorPoint\n\n"}
{"name":"ModelWithCorners.Boundaryless.boundary_eq_empty","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : BoundarylessManifold I M\nâŠ¢ Eq (ModelWithCorners.boundary M) EmptyCollection.emptyCollection","decl":"/-- Boundaryless manifolds have empty boundary. -/\nlemma Boundaryless.boundary_eq_empty [BoundarylessManifold I M] : I.boundary M = âˆ… := by\n  rw [â† I.compl_interior, I.interior_eq_univ, compl_empty_iff]\n\n"}
{"name":"ModelWithCorners.instIsEmptyElemBoundaryOfBoundarylessManifold","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : BoundarylessManifold I M\nâŠ¢ IsEmpty â†‘(ModelWithCorners.boundary M)","decl":"instance [BoundarylessManifold I M] : IsEmpty (I.boundary M) :=\n  isEmpty_coe_sort.mpr Boundaryless.boundary_eq_empty\n\n"}
{"name":"ModelWithCorners.Boundaryless.iff_boundary_eq_empty","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\nâŠ¢ Iff (Eq (ModelWithCorners.boundary M) EmptyCollection.emptyCollection) (BoundarylessManifold I M)","decl":"/-- `M` is boundaryless iff its boundary is empty. -/\nlemma Boundaryless.iff_boundary_eq_empty : I.boundary M = âˆ… â†” BoundarylessManifold I M := by\n  refine âŸ¨fun h â†¦ { isInteriorPoint' := ?_ }, fun a â†¦ boundary_eq_emptyâŸ©\n  intro x\n  show x âˆˆ I.interior M\n  rw [â† compl_interior, compl_empty_iff] at h\n  rw [h]\n  trivial\n\n"}
{"name":"ModelWithCorners.Boundaryless.of_boundary_eq_empty","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\nh : Eq (ModelWithCorners.boundary M) EmptyCollection.emptyCollection\nâŠ¢ BoundarylessManifold I M","decl":"/-- Manifolds with empty boundary are boundaryless. -/\nlemma Boundaryless.of_boundary_eq_empty (h : I.boundary M = âˆ…) : BoundarylessManifold I M :=\n  (Boundaryless.iff_boundary_eq_empty (I := I)).mp h\n\n"}
{"name":"ModelWithCorners.interior_prod","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâ· : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nE' : Type u_5\ninstâœâ´ : NormedAddCommGroup E'\ninstâœÂ³ : NormedSpace ğ•œ E'\nH' : Type u_6\ninstâœÂ² : TopologicalSpace H'\nN : Type u_7\ninstâœÂ¹ : TopologicalSpace N\ninstâœ : ChartedSpace H' N\nJ : ModelWithCorners ğ•œ E' H'\nâŠ¢ Eq (ModelWithCorners.interior (Prod M N)) (SProd.sprod (ModelWithCorners.interior M) (ModelWithCorners.interior N))","decl":"/-- The interior of `M Ã— N` is the product of the interiors of `M` and `N`. -/\nlemma interior_prod :\n    (I.prod J).interior (M Ã— N) = (I.interior M) Ã—Ë¢ (J.interior N) := by\n  ext p\n  have aux : (interior (range â†‘I)) Ã—Ë¢ (interior (range J)) = interior (range (I.prod J)) := by\n    rw [â† interior_prod_eq, â† Set.range_prod_map, modelWithCorners_prod_coe]\n  constructor <;> intro hp\n  Â· replace hp : (I.prod J).IsInteriorPoint p := hp\n    rw [IsInteriorPoint, â† aux] at hp\n    exact hp\n  Â· show (I.prod J).IsInteriorPoint p\n    rw [IsInteriorPoint, â† aux, mem_prod]\n    obtain h := Set.mem_prod.mp hp\n    rw [ModelWithCorners.interior] at h\n    exact h\n\n"}
{"name":"ModelWithCorners.boundary_prod","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâ· : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nE' : Type u_5\ninstâœâ´ : NormedAddCommGroup E'\ninstâœÂ³ : NormedSpace ğ•œ E'\nH' : Type u_6\ninstâœÂ² : TopologicalSpace H'\nN : Type u_7\ninstâœÂ¹ : TopologicalSpace N\ninstâœ : ChartedSpace H' N\nJ : ModelWithCorners ğ•œ E' H'\nâŠ¢ Eq (ModelWithCorners.boundary (Prod M N)) (Union.union (Set.univ.prod (ModelWithCorners.boundary N)) ((ModelWithCorners.boundary M).prod Set.univ))","decl":"/-- The boundary of `M Ã— N` is `âˆ‚M Ã— N âˆª (M Ã— âˆ‚N)`. -/\nlemma boundary_prod :\n    (I.prod J).boundary (M Ã— N) = Set.prod univ (J.boundary N) âˆª Set.prod (I.boundary M) univ := by\n  let h := calc (I.prod J).boundary (M Ã— N)\n    _ = ((I.prod J).interior (M Ã— N))á¶œ := compl_interior.symm\n    _ = ((I.interior M) Ã—Ë¢ (J.interior N))á¶œ := by rw [interior_prod]\n    _ = (I.interior M)á¶œ Ã—Ë¢ univ âˆª univ Ã—Ë¢ (J.interior N)á¶œ := by rw [compl_prod_eq_union]\n  rw [h, I.compl_interior, J.compl_interior, union_comm]\n  rfl\n\n"}
{"name":"ModelWithCorners.boundary_of_boundaryless_left","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹â° : NormedAddCommGroup E\ninstâœâ¹ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâ¸ : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ· : TopologicalSpace M\ninstâœâ¶ : ChartedSpace H M\nE' : Type u_5\ninstâœâµ : NormedAddCommGroup E'\ninstâœâ´ : NormedSpace ğ•œ E'\nH' : Type u_6\ninstâœÂ³ : TopologicalSpace H'\nN : Type u_7\ninstâœÂ² : TopologicalSpace N\ninstâœÂ¹ : ChartedSpace H' N\nJ : ModelWithCorners ğ•œ E' H'\ninstâœ : BoundarylessManifold I M\nâŠ¢ Eq (ModelWithCorners.boundary (Prod M N)) (Set.univ.prod (ModelWithCorners.boundary N))","decl":"/-- If `M` is boundaryless, `âˆ‚(MÃ—N) = M Ã— âˆ‚N`. -/\nlemma boundary_of_boundaryless_left [BoundarylessManifold I M] :\n    (I.prod J).boundary (M Ã— N) = Set.prod (univ : Set M) (J.boundary N) := by\n  rw [boundary_prod, Boundaryless.boundary_eq_empty (I := I)]\n  have : Set.prod (âˆ… : Set M) (univ : Set N) = âˆ… := Set.empty_prod\n  rw [this, union_empty]\n\n"}
{"name":"ModelWithCorners.boundary_of_boundaryless_right","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹â° : NormedAddCommGroup E\ninstâœâ¹ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâ¸ : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ· : TopologicalSpace M\ninstâœâ¶ : ChartedSpace H M\nE' : Type u_5\ninstâœâµ : NormedAddCommGroup E'\ninstâœâ´ : NormedSpace ğ•œ E'\nH' : Type u_6\ninstâœÂ³ : TopologicalSpace H'\nN : Type u_7\ninstâœÂ² : TopologicalSpace N\ninstâœÂ¹ : ChartedSpace H' N\nJ : ModelWithCorners ğ•œ E' H'\ninstâœ : BoundarylessManifold J N\nâŠ¢ Eq (ModelWithCorners.boundary (Prod M N)) ((ModelWithCorners.boundary M).prod Set.univ)","decl":"/-- If `N` is boundaryless, `âˆ‚(MÃ—N) = âˆ‚M Ã— N`. -/\nlemma boundary_of_boundaryless_right [BoundarylessManifold J N] :\n    (I.prod J).boundary (M Ã— N) = Set.prod (I.boundary M) (univ : Set N) := by\n  rw [boundary_prod, Boundaryless.boundary_eq_empty (I := J)]\n  have : Set.prod (univ : Set M) (âˆ… : Set N) = âˆ… := Set.prod_empty\n  rw [this, empty_union]\n\n"}
{"name":"ModelWithCorners.BoundarylessManifold.prod","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹Â² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâ¹ : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ¸ : TopologicalSpace M\ninstâœâ· : ChartedSpace H M\nE' : Type u_5\ninstâœâ¶ : NormedAddCommGroup E'\ninstâœâµ : NormedSpace ğ•œ E'\nH' : Type u_6\ninstâœâ´ : TopologicalSpace H'\nN : Type u_7\ninstâœÂ³ : TopologicalSpace N\ninstâœÂ² : ChartedSpace H' N\nJ : ModelWithCorners ğ•œ E' H'\ninstâœÂ¹ : BoundarylessManifold I M\ninstâœ : BoundarylessManifold J N\nâŠ¢ BoundarylessManifold (I.prod J) (Prod M N)","decl":"/-- The product of two boundaryless manifolds is boundaryless. -/\ninstance BoundarylessManifold.prod [BoundarylessManifold I M] [BoundarylessManifold J N] :\n    BoundarylessManifold (I.prod J) (M Ã— N) := by\n  apply Boundaryless.of_boundary_eq_empty\n  simp only [boundary_prod, Boundaryless.boundary_eq_empty, union_empty_iff]\n  -- These are simp lemmas, but `simp` does not apply them on its own:\n  -- presumably because of the distinction between `Prod` and `ModelProd`\n  exact âŸ¨Set.prod_empty, Set.empty_prodâŸ©\n\n"}
{"name":"ModelWithCorners.interiorPoint_inl","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâµ : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : ChartedSpace H M\nM' : Type u_5\ninstâœÂ² : TopologicalSpace M'\ninstâœÂ¹ : ChartedSpace H M'\ninstâœ : Nonempty H\nx : M\nhx : I.IsInteriorPoint x\nâŠ¢ I.IsInteriorPoint (Sum.inl x)","decl":"lemma interiorPoint_inl (x : M) (hx : I.IsInteriorPoint x) :\n    I.IsInteriorPoint (.inl x: M âŠ• M') := by\n  rw [I.isInteriorPoint_iff, extChartAt, ChartedSpace.sum_chartAt_inl]\n  dsimp only [PartialHomeomorph.extend.eq_1, PartialEquiv.trans_target, toPartialEquiv_coe_symm,\n    PartialHomeomorph.lift_openEmbedding_target, PartialEquiv.coe_trans, toPartialEquiv_coe,\n    PartialHomeomorph.toFun_eq_coe, PartialHomeomorph.lift_openEmbedding_toFun, Function.comp_apply]\n  rw [Sum.inl_injective.extend_apply (chartAt H x)]\n  simpa [I.isInteriorPoint_iff, extChartAt] using hx\n\n"}
{"name":"ModelWithCorners.boundaryPoint_inl","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâµ : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : ChartedSpace H M\nM' : Type u_5\ninstâœÂ² : TopologicalSpace M'\ninstâœÂ¹ : ChartedSpace H M'\ninstâœ : Nonempty H\nx : M\nhx : I.IsBoundaryPoint x\nâŠ¢ I.IsBoundaryPoint (Sum.inl x)","decl":"lemma boundaryPoint_inl (x : M) (hx : I.IsBoundaryPoint x) :\n    I.IsBoundaryPoint (.inl x: M âŠ• M') := by\n  rw [I.isBoundaryPoint_iff, extChartAt, ChartedSpace.sum_chartAt_inl]\n  dsimp\n  rw [Sum.inl_injective.extend_apply (chartAt H x)]\n  simpa [I.isBoundaryPoint_iff, extChartAt] using hx\n\n"}
{"name":"ModelWithCorners.interiorPoint_inr","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâµ : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : ChartedSpace H M\nM' : Type u_5\ninstâœÂ² : TopologicalSpace M'\ninstâœÂ¹ : ChartedSpace H M'\ninstâœ : Nonempty H\nx : M'\nhx : I.IsInteriorPoint x\nâŠ¢ I.IsInteriorPoint (Sum.inr x)","decl":"lemma interiorPoint_inr (x : M') (hx : I.IsInteriorPoint x) :\n    I.IsInteriorPoint (.inr x : M âŠ• M') := by\n  rw [I.isInteriorPoint_iff, extChartAt, ChartedSpace.sum_chartAt_inr]\n  dsimp\n  rw [Sum.inr_injective.extend_apply (chartAt H x)]\n  simpa [I.isInteriorPoint_iff, extChartAt] using hx\n\n"}
{"name":"ModelWithCorners.boundaryPoint_inr","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâµ : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : ChartedSpace H M\nM' : Type u_5\ninstâœÂ² : TopologicalSpace M'\ninstâœÂ¹ : ChartedSpace H M'\ninstâœ : Nonempty H\nx : M'\nhx : I.IsBoundaryPoint x\nâŠ¢ I.IsBoundaryPoint (Sum.inr x)","decl":"lemma boundaryPoint_inr (x : M') (hx : I.IsBoundaryPoint x) :\n    I.IsBoundaryPoint (.inr x : M âŠ• M') := by\n  rw [I.isBoundaryPoint_iff, extChartAt, ChartedSpace.sum_chartAt_inr]\n  dsimp\n  rw [Sum.inr_injective.extend_apply (chartAt H x)]\n  simpa [I.isBoundaryPoint_iff, extChartAt] using hx\n\n-- Converse to the previous direction: if `x` were not an interior point,\n-- it had to be a boundary point, hence `p` were a boundary point also, contradiction.\n"}
{"name":"ModelWithCorners.isInteriorPoint_disjointUnion_left","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâµ : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : ChartedSpace H M\nM' : Type u_5\ninstâœÂ² : TopologicalSpace M'\ninstâœÂ¹ : ChartedSpace H M'\ninstâœ : Nonempty H\np : Sum M M'\nhp : I.IsInteriorPoint p\nhleft : Eq p.isLeft Bool.true\nâŠ¢ I.IsInteriorPoint (p.getLeft hleft)","decl":"lemma isInteriorPoint_disjointUnion_left {p : M âŠ• M'} (hp : I.IsInteriorPoint p)\n    (hleft : Sum.isLeft p) : I.IsInteriorPoint (Sum.getLeft p hleft) := by\n  by_contra h\n  set x := Sum.getLeft p hleft\n  rw [isInteriorPoint_iff_not_isBoundaryPoint x, not_not] at h\n  rw [isInteriorPoint_iff_not_isBoundaryPoint p] at hp\n  have := boundaryPoint_inl (M' := M') x (by tauto)\n  rw [â† Sum.eq_left_getLeft_of_isLeft hleft] at this\n  exact hp this\n\n"}
{"name":"ModelWithCorners.isInteriorPoint_disjointUnion_right","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâµ : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : ChartedSpace H M\nM' : Type u_5\ninstâœÂ² : TopologicalSpace M'\ninstâœÂ¹ : ChartedSpace H M'\ninstâœ : Nonempty H\np : Sum M M'\nhp : I.IsInteriorPoint p\nhright : Eq p.isRight Bool.true\nâŠ¢ I.IsInteriorPoint (p.getRight hright)","decl":"lemma isInteriorPoint_disjointUnion_right {p : M âŠ• M'} (hp : I.IsInteriorPoint p)\n    (hright : Sum.isRight p) : I.IsInteriorPoint (Sum.getRight p hright) := by\n  by_contra h\n  set x := Sum.getRight p hright\n  rw [â† mem_empty_iff_false p, â† (disjoint_interior_boundary (I := I)).inter_eq]\n  constructor\n  Â· rw [ModelWithCorners.interior, mem_setOf]; exact hp\n  Â· rw [ModelWithCorners.boundary, mem_setOf, Sum.eq_right_getRight_of_isRight hright]\n    have := isInteriorPoint_or_isBoundaryPoint (I := I) x\n    exact boundaryPoint_inr (M' := M') x (by tauto)\n\n"}
{"name":"ModelWithCorners.interior_disjointUnion","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâµ : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : ChartedSpace H M\nM' : Type u_5\ninstâœÂ² : TopologicalSpace M'\ninstâœÂ¹ : ChartedSpace H M'\ninstâœ : Nonempty H\nâŠ¢ Eq (ModelWithCorners.interior (Sum M M')) (Union.union (Set.image Sum.inl (ModelWithCorners.interior M)) (Set.image Sum.inr (ModelWithCorners.interior M')))","decl":"lemma interior_disjointUnion :\n    ModelWithCorners.interior (I := I) (M âŠ• M') =\n      Sum.inl '' (ModelWithCorners.interior (I := I) M)\n      âˆª Sum.inr '' (ModelWithCorners.interior (I := I) M') := by\n  ext p\n  constructor\n  Â· intro hp\n    by_cases h : Sum.isLeft p\n    Â· left\n      exact âŸ¨Sum.getLeft p h, isInteriorPoint_disjointUnion_left hp h, Sum.inl_getLeft p hâŸ©\n    Â· replace h := Sum.not_isLeft.mp h\n      right\n      exact âŸ¨Sum.getRight p h, isInteriorPoint_disjointUnion_right hp h, Sum.inr_getRight p hâŸ©\n  Â· intro hp\n    by_cases h : Sum.isLeft p\n    Â· set x := Sum.getLeft p h with x_eq\n      rw [Sum.eq_left_getLeft_of_isLeft h]\n      apply interiorPoint_inl x\n      have hp : p âˆˆ Sum.inl '' (ModelWithCorners.interior (I := I) M) := by\n        obtain (good | âŸ¨y, hy, hxyâŸ©) := hp\n        exacts [good, (not_isLeft_and_isRight âŸ¨h, by rw [â† hxy]; exact rflâŸ©).elim]\n      obtain âŸ¨x', hx', hx'pâŸ© := hp\n      simpa [x_eq, â† hx'p, Sum.getLeft_inl]\n    Â· set x := Sum.getRight p (Sum.not_isLeft.mp h) with x_eq\n      rw [Sum.eq_right_getRight_of_isRight (Sum.not_isLeft.mp h)]\n      apply interiorPoint_inr x\n      have hp : p âˆˆ Sum.inr '' (ModelWithCorners.interior (I := I) M') := by\n        obtain (âŸ¨y, hy, hxyâŸ© | good) := hp\n        exacts [(not_isLeft_and_isRight âŸ¨by rw [â† hxy]; exact rfl, Sum.not_isLeft.mp hâŸ©).elim, good]\n      obtain âŸ¨x', hx', hx'pâŸ© := hp\n      simpa [x_eq, â† hx'p, Sum.getRight_inr]\n\n"}
{"name":"ModelWithCorners.boundary_disjointUnion","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâµ : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : ChartedSpace H M\nM' : Type u_5\ninstâœÂ² : TopologicalSpace M'\ninstâœÂ¹ : ChartedSpace H M'\ninstâœ : Nonempty H\nâŠ¢ Eq (ModelWithCorners.boundary (Sum M M')) (Union.union (Set.image Sum.inl (ModelWithCorners.boundary M)) (Set.image Sum.inr (ModelWithCorners.boundary M')))","decl":"lemma boundary_disjointUnion : ModelWithCorners.boundary (I := I) (M âŠ• M') =\n      Sum.inl '' (ModelWithCorners.boundary (I := I) M)\n      âˆª Sum.inr '' (ModelWithCorners.boundary (I := I) M') := by\n  simp only [â† ModelWithCorners.compl_interior, interior_disjointUnion, inl_compl_union_inr_compl]\n\n"}
{"name":"ModelWithCorners.boundaryless_disjointUnion","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâµ : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : ChartedSpace H M\nM' : Type u_5\ninstâœÂ² : TopologicalSpace M'\ninstâœÂ¹ : ChartedSpace H M'\ninstâœ : Nonempty H\nhM : BoundarylessManifold I M\nhM' : BoundarylessManifold I M'\nâŠ¢ BoundarylessManifold I (Sum M M')","decl":"/-- If `M` and `M'` are boundaryless, so is their disjoint union `M âŠ” M'`. -/\ninstance boundaryless_disjointUnion\n    [hM: BoundarylessManifold I M] [hM': BoundarylessManifold I M'] :\n    BoundarylessManifold I (M âŠ• M') := by\n  rw [â† Boundaryless.iff_boundary_eq_empty] at hM hM' âŠ¢\n  simp [boundary_disjointUnion, hM, hM']\n\n"}
