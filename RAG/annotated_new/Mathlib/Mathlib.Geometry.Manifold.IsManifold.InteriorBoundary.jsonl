{"name":"ModelWithCorners.isInteriorPoint_iff","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nx : M\n⊢ Iff (I.IsInteriorPoint x) (Membership.mem (interior (extChartAt I x).target) (↑(extChartAt I x) x))","decl":"lemma isInteriorPoint_iff {x : M} :\n    I.IsInteriorPoint x ↔ extChartAt I x x ∈ interior (extChartAt I x).target :=\n  ⟨fun h ↦ (chartAt H x).mem_interior_extend_target (mem_chart_target H x) h,\n    fun h ↦ PartialHomeomorph.interior_extend_target_subset_interior_range _ h⟩\n\n"}
{"name":"ModelWithCorners.isBoundaryPoint_iff","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nx : M\n⊢ Iff (I.IsBoundaryPoint x) (Membership.mem (frontier (Set.range ↑I)) (↑(extChartAt I x) x))","decl":"lemma isBoundaryPoint_iff {x : M} : I.IsBoundaryPoint x ↔ extChartAt I x x ∈ frontier (range I) :=\n  Iff.rfl\n\n"}
{"name":"ModelWithCorners.isInteriorPoint_or_isBoundaryPoint","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nx : M\n⊢ Or (I.IsInteriorPoint x) (I.IsBoundaryPoint x)","decl":"/-- Every point is either an interior or a boundary point. -/\nlemma isInteriorPoint_or_isBoundaryPoint (x : M) : I.IsInteriorPoint x ∨ I.IsBoundaryPoint x := by\n  rw [IsInteriorPoint, or_iff_not_imp_left, I.isBoundaryPoint_iff, ← closure_diff_interior,\n    I.isClosed_range.closure_eq, mem_diff]\n  exact fun h ↦ ⟨mem_range_self _, h⟩\n\n"}
{"name":"ModelWithCorners.interior_union_boundary_eq_univ","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\n⊢ Eq (Union.union (ModelWithCorners.interior M) (ModelWithCorners.boundary M)) Set.univ","decl":"/-- A manifold decomposes into interior and boundary. -/\nlemma interior_union_boundary_eq_univ : (I.interior M) ∪ (I.boundary M) = (univ : Set M) :=\n  eq_univ_of_forall fun x => (mem_union _ _ _).mpr (I.isInteriorPoint_or_isBoundaryPoint x)\n\n"}
{"name":"ModelWithCorners.disjoint_interior_boundary","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\n⊢ Disjoint (ModelWithCorners.interior M) (ModelWithCorners.boundary M)","decl":"/-- The interior and boundary of a manifold `M` are disjoint. -/\nlemma disjoint_interior_boundary : Disjoint (I.interior M) (I.boundary M) := by\n  by_contra h\n  -- Choose some x in the intersection of interior and boundary.\n  obtain ⟨x, h1, h2⟩ := not_disjoint_iff.mp h\n  rw [← mem_empty_iff_false (extChartAt I x x),\n    ← disjoint_iff_inter_eq_empty.mp disjoint_interior_frontier, mem_inter_iff]\n  exact ⟨h1, h2⟩\n\n"}
{"name":"ModelWithCorners.isInteriorPoint_iff_not_isBoundaryPoint","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nx : M\n⊢ Iff (I.IsInteriorPoint x) (Not (I.IsBoundaryPoint x))","decl":"lemma isInteriorPoint_iff_not_isBoundaryPoint (x : M) :\n    I.IsInteriorPoint x ↔ ¬I.IsBoundaryPoint x := by\n  refine ⟨?_,\n    by simpa only [or_iff_not_imp_right] using isInteriorPoint_or_isBoundaryPoint x (I := I)⟩\n  by_contra! h\n  rw [← mem_empty_iff_false (extChartAt I x x),\n    ← disjoint_iff_inter_eq_empty.mp disjoint_interior_frontier, mem_inter_iff]\n  exact h\n\n"}
{"name":"ModelWithCorners.compl_interior","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\n⊢ Eq (HasCompl.compl (ModelWithCorners.interior M)) (ModelWithCorners.boundary M)","decl":"/-- The boundary is the complement of the interior. -/\nlemma compl_interior : (I.interior M)ᶜ = I.boundary M:= by\n  apply compl_unique ?_ I.interior_union_boundary_eq_univ\n  exact disjoint_iff_inter_eq_empty.mp I.disjoint_interior_boundary\n\n"}
{"name":"ModelWithCorners.compl_boundary","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\n⊢ Eq (HasCompl.compl (ModelWithCorners.boundary M)) (ModelWithCorners.interior M)","decl":"/-- The interior is the complement of the boundary. -/\nlemma compl_boundary : (I.boundary M)ᶜ = I.interior M:= by\n  rw [← compl_interior, compl_compl]\n\n"}
{"name":"range_mem_nhds_isInteriorPoint","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nx : M\nh : I.IsInteriorPoint x\n⊢ Membership.mem (nhds (↑(extChartAt I x) x)) (Set.range ↑I)","decl":"lemma _root_.range_mem_nhds_isInteriorPoint {x : M} (h : I.IsInteriorPoint x) :\n    range I ∈ 𝓝 (extChartAt I x x) := by\n  rw [mem_nhds_iff]\n  exact ⟨interior (range I), interior_subset, isOpen_interior, h⟩\n\n"}
{"name":"BoundarylessManifold.isInteriorPoint'","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_5\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_6\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nH : Type u_7\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_8\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nself : BoundarylessManifold I M\nx : M\n⊢ I.IsInteriorPoint x","decl":"/-- Type class for manifold without boundary. This differs from `ModelWithCorners.Boundaryless`,\n  which states that the `ModelWithCorners` maps to the whole model vector space. -/\nclass _root_.BoundarylessManifold {𝕜 : Type*} [NontriviallyNormedField 𝕜]\n    {E : Type*} [NormedAddCommGroup E] [NormedSpace 𝕜 E]\n    {H : Type*} [TopologicalSpace H] (I : ModelWithCorners 𝕜 E H)\n    (M : Type*) [TopologicalSpace M] [ChartedSpace H M] : Prop where\n  isInteriorPoint' : ∀ x : M, IsInteriorPoint I x\n\n"}
{"name":"ModelWithCorners.instBoundarylessManifold","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\n⊢ BoundarylessManifold I M","decl":"/-- Boundaryless `ModelWithCorners` implies boundaryless manifold. -/\ninstance : BoundarylessManifold I M where\n  isInteriorPoint' x := by\n    let r := ((chartAt H x).isOpen_extend_target (I := I)).interior_eq\n    have : extChartAt I x = (chartAt H x).extend I := rfl\n    rw [← this] at r\n    rw [isInteriorPoint_iff, r]\n    exact PartialEquiv.map_source _ (mem_extChartAt_source _)\n\n"}
{"name":"ModelWithCorners.BoundarylessManifold.of_empty","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝³ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝² : TopologicalSpace M\ninst✝¹ : ChartedSpace H M\ninst✝ : IsEmpty M\n⊢ BoundarylessManifold I M","decl":"/-- The empty manifold is boundaryless. -/\ninstance BoundarylessManifold.of_empty [IsEmpty M] : BoundarylessManifold I M where\n  isInteriorPoint' x := (IsEmpty.false x).elim\n\n"}
{"name":"BoundarylessManifold.isInteriorPoint","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝³ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝² : TopologicalSpace M\ninst✝¹ : ChartedSpace H M\nx : M\ninst✝ : BoundarylessManifold I M\n⊢ I.IsInteriorPoint x","decl":"lemma _root_.BoundarylessManifold.isInteriorPoint {x : M} [BoundarylessManifold I M] :\n    IsInteriorPoint I x := BoundarylessManifold.isInteriorPoint' x\n\n"}
{"name":"ModelWithCorners.interior_eq_univ","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝³ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝² : TopologicalSpace M\ninst✝¹ : ChartedSpace H M\ninst✝ : BoundarylessManifold I M\n⊢ Eq (ModelWithCorners.interior M) Set.univ","decl":"/-- If `I` is boundaryless, `M` has full interior. -/\nlemma interior_eq_univ [BoundarylessManifold I M] : I.interior M = univ :=\n  eq_univ_of_forall fun _ => BoundarylessManifold.isInteriorPoint\n\n"}
{"name":"ModelWithCorners.Boundaryless.boundary_eq_empty","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝³ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝² : TopologicalSpace M\ninst✝¹ : ChartedSpace H M\ninst✝ : BoundarylessManifold I M\n⊢ Eq (ModelWithCorners.boundary M) EmptyCollection.emptyCollection","decl":"/-- Boundaryless manifolds have empty boundary. -/\nlemma Boundaryless.boundary_eq_empty [BoundarylessManifold I M] : I.boundary M = ∅ := by\n  rw [← I.compl_interior, I.interior_eq_univ, compl_empty_iff]\n\n"}
{"name":"ModelWithCorners.instIsEmptyElemBoundaryOfBoundarylessManifold","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝³ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝² : TopologicalSpace M\ninst✝¹ : ChartedSpace H M\ninst✝ : BoundarylessManifold I M\n⊢ IsEmpty ↑(ModelWithCorners.boundary M)","decl":"instance [BoundarylessManifold I M] : IsEmpty (I.boundary M) :=\n  isEmpty_coe_sort.mpr Boundaryless.boundary_eq_empty\n\n"}
{"name":"ModelWithCorners.Boundaryless.iff_boundary_eq_empty","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\n⊢ Iff (Eq (ModelWithCorners.boundary M) EmptyCollection.emptyCollection) (BoundarylessManifold I M)","decl":"/-- `M` is boundaryless iff its boundary is empty. -/\nlemma Boundaryless.iff_boundary_eq_empty : I.boundary M = ∅ ↔ BoundarylessManifold I M := by\n  refine ⟨fun h ↦ { isInteriorPoint' := ?_ }, fun a ↦ boundary_eq_empty⟩\n  intro x\n  show x ∈ I.interior M\n  rw [← compl_interior, compl_empty_iff] at h\n  rw [h]\n  trivial\n\n"}
{"name":"ModelWithCorners.Boundaryless.of_boundary_eq_empty","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nh : Eq (ModelWithCorners.boundary M) EmptyCollection.emptyCollection\n⊢ BoundarylessManifold I M","decl":"/-- Manifolds with empty boundary are boundaryless. -/\nlemma Boundaryless.of_boundary_eq_empty (h : I.boundary M = ∅) : BoundarylessManifold I M :=\n  (Boundaryless.iff_boundary_eq_empty (I := I)).mp h\n\n"}
{"name":"ModelWithCorners.interior_prod","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁷ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : ChartedSpace H M\nE' : Type u_5\ninst✝⁴ : NormedAddCommGroup E'\ninst✝³ : NormedSpace 𝕜 E'\nH' : Type u_6\ninst✝² : TopologicalSpace H'\nN : Type u_7\ninst✝¹ : TopologicalSpace N\ninst✝ : ChartedSpace H' N\nJ : ModelWithCorners 𝕜 E' H'\n⊢ Eq (ModelWithCorners.interior (Prod M N)) (SProd.sprod (ModelWithCorners.interior M) (ModelWithCorners.interior N))","decl":"/-- The interior of `M × N` is the product of the interiors of `M` and `N`. -/\nlemma interior_prod :\n    (I.prod J).interior (M × N) = (I.interior M) ×ˢ (J.interior N) := by\n  ext p\n  have aux : (interior (range ↑I)) ×ˢ (interior (range J)) = interior (range (I.prod J)) := by\n    rw [← interior_prod_eq, ← Set.range_prod_map, modelWithCorners_prod_coe]\n  constructor <;> intro hp\n  · replace hp : (I.prod J).IsInteriorPoint p := hp\n    rw [IsInteriorPoint, ← aux] at hp\n    exact hp\n  · show (I.prod J).IsInteriorPoint p\n    rw [IsInteriorPoint, ← aux, mem_prod]\n    obtain h := Set.mem_prod.mp hp\n    rw [ModelWithCorners.interior] at h\n    exact h\n\n"}
{"name":"ModelWithCorners.boundary_prod","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁷ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : ChartedSpace H M\nE' : Type u_5\ninst✝⁴ : NormedAddCommGroup E'\ninst✝³ : NormedSpace 𝕜 E'\nH' : Type u_6\ninst✝² : TopologicalSpace H'\nN : Type u_7\ninst✝¹ : TopologicalSpace N\ninst✝ : ChartedSpace H' N\nJ : ModelWithCorners 𝕜 E' H'\n⊢ Eq (ModelWithCorners.boundary (Prod M N)) (Union.union (Set.univ.prod (ModelWithCorners.boundary N)) ((ModelWithCorners.boundary M).prod Set.univ))","decl":"/-- The boundary of `M × N` is `∂M × N ∪ (M × ∂N)`. -/\nlemma boundary_prod :\n    (I.prod J).boundary (M × N) = Set.prod univ (J.boundary N) ∪ Set.prod (I.boundary M) univ := by\n  let h := calc (I.prod J).boundary (M × N)\n    _ = ((I.prod J).interior (M × N))ᶜ := compl_interior.symm\n    _ = ((I.interior M) ×ˢ (J.interior N))ᶜ := by rw [interior_prod]\n    _ = (I.interior M)ᶜ ×ˢ univ ∪ univ ×ˢ (J.interior N)ᶜ := by rw [compl_prod_eq_union]\n  rw [h, I.compl_interior, J.compl_interior, union_comm]\n  rfl\n\n"}
{"name":"ModelWithCorners.boundary_of_boundaryless_left","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝¹¹ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹⁰ : NormedAddCommGroup E\ninst✝⁹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁸ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁷ : TopologicalSpace M\ninst✝⁶ : ChartedSpace H M\nE' : Type u_5\ninst✝⁵ : NormedAddCommGroup E'\ninst✝⁴ : NormedSpace 𝕜 E'\nH' : Type u_6\ninst✝³ : TopologicalSpace H'\nN : Type u_7\ninst✝² : TopologicalSpace N\ninst✝¹ : ChartedSpace H' N\nJ : ModelWithCorners 𝕜 E' H'\ninst✝ : BoundarylessManifold I M\n⊢ Eq (ModelWithCorners.boundary (Prod M N)) (Set.univ.prod (ModelWithCorners.boundary N))","decl":"/-- If `M` is boundaryless, `∂(M×N) = M × ∂N`. -/\nlemma boundary_of_boundaryless_left [BoundarylessManifold I M] :\n    (I.prod J).boundary (M × N) = Set.prod (univ : Set M) (J.boundary N) := by\n  rw [boundary_prod, Boundaryless.boundary_eq_empty (I := I)]\n  have : Set.prod (∅ : Set M) (univ : Set N) = ∅ := Set.empty_prod\n  rw [this, union_empty]\n\n"}
{"name":"ModelWithCorners.boundary_of_boundaryless_right","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝¹¹ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹⁰ : NormedAddCommGroup E\ninst✝⁹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁸ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁷ : TopologicalSpace M\ninst✝⁶ : ChartedSpace H M\nE' : Type u_5\ninst✝⁵ : NormedAddCommGroup E'\ninst✝⁴ : NormedSpace 𝕜 E'\nH' : Type u_6\ninst✝³ : TopologicalSpace H'\nN : Type u_7\ninst✝² : TopologicalSpace N\ninst✝¹ : ChartedSpace H' N\nJ : ModelWithCorners 𝕜 E' H'\ninst✝ : BoundarylessManifold J N\n⊢ Eq (ModelWithCorners.boundary (Prod M N)) ((ModelWithCorners.boundary M).prod Set.univ)","decl":"/-- If `N` is boundaryless, `∂(M×N) = ∂M × N`. -/\nlemma boundary_of_boundaryless_right [BoundarylessManifold J N] :\n    (I.prod J).boundary (M × N) = Set.prod (I.boundary M) (univ : Set N) := by\n  rw [boundary_prod, Boundaryless.boundary_eq_empty (I := J)]\n  have : Set.prod (univ : Set M) (∅ : Set N) = ∅ := Set.prod_empty\n  rw [this, empty_union]\n\n"}
{"name":"ModelWithCorners.BoundarylessManifold.prod","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝¹² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹¹ : NormedAddCommGroup E\ninst✝¹⁰ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁹ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁸ : TopologicalSpace M\ninst✝⁷ : ChartedSpace H M\nE' : Type u_5\ninst✝⁶ : NormedAddCommGroup E'\ninst✝⁵ : NormedSpace 𝕜 E'\nH' : Type u_6\ninst✝⁴ : TopologicalSpace H'\nN : Type u_7\ninst✝³ : TopologicalSpace N\ninst✝² : ChartedSpace H' N\nJ : ModelWithCorners 𝕜 E' H'\ninst✝¹ : BoundarylessManifold I M\ninst✝ : BoundarylessManifold J N\n⊢ BoundarylessManifold (I.prod J) (Prod M N)","decl":"/-- The product of two boundaryless manifolds is boundaryless. -/\ninstance BoundarylessManifold.prod [BoundarylessManifold I M] [BoundarylessManifold J N] :\n    BoundarylessManifold (I.prod J) (M × N) := by\n  apply Boundaryless.of_boundary_eq_empty\n  simp only [boundary_prod, Boundaryless.boundary_eq_empty, union_empty_iff]\n  -- These are simp lemmas, but `simp` does not apply them on its own:\n  -- presumably because of the distinction between `Prod` and `ModelProd`\n  exact ⟨Set.prod_empty, Set.empty_prod⟩\n\n"}
{"name":"ModelWithCorners.interiorPoint_inl","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\nM' : Type u_5\ninst✝² : TopologicalSpace M'\ninst✝¹ : ChartedSpace H M'\ninst✝ : Nonempty H\nx : M\nhx : I.IsInteriorPoint x\n⊢ I.IsInteriorPoint (Sum.inl x)","decl":"lemma interiorPoint_inl (x : M) (hx : I.IsInteriorPoint x) :\n    I.IsInteriorPoint (.inl x: M ⊕ M') := by\n  rw [I.isInteriorPoint_iff, extChartAt, ChartedSpace.sum_chartAt_inl]\n  dsimp only [PartialHomeomorph.extend.eq_1, PartialEquiv.trans_target, toPartialEquiv_coe_symm,\n    PartialHomeomorph.lift_openEmbedding_target, PartialEquiv.coe_trans, toPartialEquiv_coe,\n    PartialHomeomorph.toFun_eq_coe, PartialHomeomorph.lift_openEmbedding_toFun, Function.comp_apply]\n  rw [Sum.inl_injective.extend_apply (chartAt H x)]\n  simpa [I.isInteriorPoint_iff, extChartAt] using hx\n\n"}
{"name":"ModelWithCorners.boundaryPoint_inl","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\nM' : Type u_5\ninst✝² : TopologicalSpace M'\ninst✝¹ : ChartedSpace H M'\ninst✝ : Nonempty H\nx : M\nhx : I.IsBoundaryPoint x\n⊢ I.IsBoundaryPoint (Sum.inl x)","decl":"lemma boundaryPoint_inl (x : M) (hx : I.IsBoundaryPoint x) :\n    I.IsBoundaryPoint (.inl x: M ⊕ M') := by\n  rw [I.isBoundaryPoint_iff, extChartAt, ChartedSpace.sum_chartAt_inl]\n  dsimp\n  rw [Sum.inl_injective.extend_apply (chartAt H x)]\n  simpa [I.isBoundaryPoint_iff, extChartAt] using hx\n\n"}
{"name":"ModelWithCorners.interiorPoint_inr","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\nM' : Type u_5\ninst✝² : TopologicalSpace M'\ninst✝¹ : ChartedSpace H M'\ninst✝ : Nonempty H\nx : M'\nhx : I.IsInteriorPoint x\n⊢ I.IsInteriorPoint (Sum.inr x)","decl":"lemma interiorPoint_inr (x : M') (hx : I.IsInteriorPoint x) :\n    I.IsInteriorPoint (.inr x : M ⊕ M') := by\n  rw [I.isInteriorPoint_iff, extChartAt, ChartedSpace.sum_chartAt_inr]\n  dsimp\n  rw [Sum.inr_injective.extend_apply (chartAt H x)]\n  simpa [I.isInteriorPoint_iff, extChartAt] using hx\n\n"}
{"name":"ModelWithCorners.boundaryPoint_inr","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\nM' : Type u_5\ninst✝² : TopologicalSpace M'\ninst✝¹ : ChartedSpace H M'\ninst✝ : Nonempty H\nx : M'\nhx : I.IsBoundaryPoint x\n⊢ I.IsBoundaryPoint (Sum.inr x)","decl":"lemma boundaryPoint_inr (x : M') (hx : I.IsBoundaryPoint x) :\n    I.IsBoundaryPoint (.inr x : M ⊕ M') := by\n  rw [I.isBoundaryPoint_iff, extChartAt, ChartedSpace.sum_chartAt_inr]\n  dsimp\n  rw [Sum.inr_injective.extend_apply (chartAt H x)]\n  simpa [I.isBoundaryPoint_iff, extChartAt] using hx\n\n-- Converse to the previous direction: if `x` were not an interior point,\n-- it had to be a boundary point, hence `p` were a boundary point also, contradiction.\n"}
{"name":"ModelWithCorners.isInteriorPoint_disjointUnion_left","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\nM' : Type u_5\ninst✝² : TopologicalSpace M'\ninst✝¹ : ChartedSpace H M'\ninst✝ : Nonempty H\np : Sum M M'\nhp : I.IsInteriorPoint p\nhleft : Eq p.isLeft Bool.true\n⊢ I.IsInteriorPoint (p.getLeft hleft)","decl":"lemma isInteriorPoint_disjointUnion_left {p : M ⊕ M'} (hp : I.IsInteriorPoint p)\n    (hleft : Sum.isLeft p) : I.IsInteriorPoint (Sum.getLeft p hleft) := by\n  by_contra h\n  set x := Sum.getLeft p hleft\n  rw [isInteriorPoint_iff_not_isBoundaryPoint x, not_not] at h\n  rw [isInteriorPoint_iff_not_isBoundaryPoint p] at hp\n  have := boundaryPoint_inl (M' := M') x (by tauto)\n  rw [← Sum.eq_left_getLeft_of_isLeft hleft] at this\n  exact hp this\n\n"}
{"name":"ModelWithCorners.isInteriorPoint_disjointUnion_right","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\nM' : Type u_5\ninst✝² : TopologicalSpace M'\ninst✝¹ : ChartedSpace H M'\ninst✝ : Nonempty H\np : Sum M M'\nhp : I.IsInteriorPoint p\nhright : Eq p.isRight Bool.true\n⊢ I.IsInteriorPoint (p.getRight hright)","decl":"lemma isInteriorPoint_disjointUnion_right {p : M ⊕ M'} (hp : I.IsInteriorPoint p)\n    (hright : Sum.isRight p) : I.IsInteriorPoint (Sum.getRight p hright) := by\n  by_contra h\n  set x := Sum.getRight p hright\n  rw [← mem_empty_iff_false p, ← (disjoint_interior_boundary (I := I)).inter_eq]\n  constructor\n  · rw [ModelWithCorners.interior, mem_setOf]; exact hp\n  · rw [ModelWithCorners.boundary, mem_setOf, Sum.eq_right_getRight_of_isRight hright]\n    have := isInteriorPoint_or_isBoundaryPoint (I := I) x\n    exact boundaryPoint_inr (M' := M') x (by tauto)\n\n"}
{"name":"ModelWithCorners.interior_disjointUnion","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\nM' : Type u_5\ninst✝² : TopologicalSpace M'\ninst✝¹ : ChartedSpace H M'\ninst✝ : Nonempty H\n⊢ Eq (ModelWithCorners.interior (Sum M M')) (Union.union (Set.image Sum.inl (ModelWithCorners.interior M)) (Set.image Sum.inr (ModelWithCorners.interior M')))","decl":"lemma interior_disjointUnion :\n    ModelWithCorners.interior (I := I) (M ⊕ M') =\n      Sum.inl '' (ModelWithCorners.interior (I := I) M)\n      ∪ Sum.inr '' (ModelWithCorners.interior (I := I) M') := by\n  ext p\n  constructor\n  · intro hp\n    by_cases h : Sum.isLeft p\n    · left\n      exact ⟨Sum.getLeft p h, isInteriorPoint_disjointUnion_left hp h, Sum.inl_getLeft p h⟩\n    · replace h := Sum.not_isLeft.mp h\n      right\n      exact ⟨Sum.getRight p h, isInteriorPoint_disjointUnion_right hp h, Sum.inr_getRight p h⟩\n  · intro hp\n    by_cases h : Sum.isLeft p\n    · set x := Sum.getLeft p h with x_eq\n      rw [Sum.eq_left_getLeft_of_isLeft h]\n      apply interiorPoint_inl x\n      have hp : p ∈ Sum.inl '' (ModelWithCorners.interior (I := I) M) := by\n        obtain (good | ⟨y, hy, hxy⟩) := hp\n        exacts [good, (not_isLeft_and_isRight ⟨h, by rw [← hxy]; exact rfl⟩).elim]\n      obtain ⟨x', hx', hx'p⟩ := hp\n      simpa [x_eq, ← hx'p, Sum.getLeft_inl]\n    · set x := Sum.getRight p (Sum.not_isLeft.mp h) with x_eq\n      rw [Sum.eq_right_getRight_of_isRight (Sum.not_isLeft.mp h)]\n      apply interiorPoint_inr x\n      have hp : p ∈ Sum.inr '' (ModelWithCorners.interior (I := I) M') := by\n        obtain (⟨y, hy, hxy⟩ | good) := hp\n        exacts [(not_isLeft_and_isRight ⟨by rw [← hxy]; exact rfl, Sum.not_isLeft.mp h⟩).elim, good]\n      obtain ⟨x', hx', hx'p⟩ := hp\n      simpa [x_eq, ← hx'p, Sum.getRight_inr]\n\n"}
{"name":"ModelWithCorners.boundary_disjointUnion","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\nM' : Type u_5\ninst✝² : TopologicalSpace M'\ninst✝¹ : ChartedSpace H M'\ninst✝ : Nonempty H\n⊢ Eq (ModelWithCorners.boundary (Sum M M')) (Union.union (Set.image Sum.inl (ModelWithCorners.boundary M)) (Set.image Sum.inr (ModelWithCorners.boundary M')))","decl":"lemma boundary_disjointUnion : ModelWithCorners.boundary (I := I) (M ⊕ M') =\n      Sum.inl '' (ModelWithCorners.boundary (I := I) M)\n      ∪ Sum.inr '' (ModelWithCorners.boundary (I := I) M') := by\n  simp only [← ModelWithCorners.compl_interior, interior_disjointUnion, inl_compl_union_inr_compl]\n\n"}
{"name":"ModelWithCorners.boundaryless_disjointUnion","module":"Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\nM' : Type u_5\ninst✝² : TopologicalSpace M'\ninst✝¹ : ChartedSpace H M'\ninst✝ : Nonempty H\nhM : BoundarylessManifold I M\nhM' : BoundarylessManifold I M'\n⊢ BoundarylessManifold I (Sum M M')","decl":"/-- If `M` and `M'` are boundaryless, so is their disjoint union `M ⊔ M'`. -/\ninstance boundaryless_disjointUnion\n    [hM: BoundarylessManifold I M] [hM': BoundarylessManifold I M'] :\n    BoundarylessManifold I (M ⊕ M') := by\n  rw [← Boundaryless.iff_boundary_eq_empty] at hM hM' ⊢\n  simp [boundary_disjointUnion, hM, hM']\n\n"}
