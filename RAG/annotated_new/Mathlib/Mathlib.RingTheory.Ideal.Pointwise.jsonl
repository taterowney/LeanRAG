{"name":"Ideal.pointwise_smul_def","module":"Mathlib.RingTheory.Ideal.Pointwise","initialProofState":"M : Type u_1\nR : Type u_2\ninst✝² : Monoid M\ninst✝¹ : Semiring R\ninst✝ : MulSemiringAction M R\na : M\nS : Ideal R\n⊢ Eq (HSMul.hSMul a S) (Ideal.map (MulSemiringAction.toRingHom M R a) S)","decl":"theorem pointwise_smul_def {a : M} (S : Ideal R) :\n    a • S = S.map (MulSemiringAction.toRingHom _ _ a) :=\n  rfl\n\n-- note: unlike with `Subring`, `pointwise_smul_toAddSubgroup` wouldn't be true\n\n"}
{"name":"Ideal.smul_mem_pointwise_smul","module":"Mathlib.RingTheory.Ideal.Pointwise","initialProofState":"M : Type u_1\nR : Type u_2\ninst✝² : Monoid M\ninst✝¹ : Semiring R\ninst✝ : MulSemiringAction M R\nm : M\nr : R\nS : Ideal R\na✝ : Membership.mem S r\n⊢ Membership.mem (HSMul.hSMul m S) (HSMul.hSMul m r)","decl":"theorem smul_mem_pointwise_smul (m : M) (r : R) (S : Ideal R) : r ∈ S → m • r ∈ m • S :=\n  fun h => subset_span <| Set.smul_mem_smul_set h\n\n"}
{"name":"Ideal.instCovariantClassHSMulLe","module":"Mathlib.RingTheory.Ideal.Pointwise","initialProofState":"M : Type u_1\nR : Type u_2\ninst✝² : Monoid M\ninst✝¹ : Semiring R\ninst✝ : MulSemiringAction M R\n⊢ CovariantClass M (Ideal R) HSMul.hSMul LE.le","decl":"instance : CovariantClass M (Ideal R) HSMul.hSMul LE.le :=\n  ⟨fun _ _ => map_mono⟩\n\n-- note: unlike with `Subring`, `mem_smul_pointwise_iff_exists` wouldn't be true\n\n"}
{"name":"Ideal.smul_bot","module":"Mathlib.RingTheory.Ideal.Pointwise","initialProofState":"M : Type u_1\nR : Type u_2\ninst✝² : Monoid M\ninst✝¹ : Semiring R\ninst✝ : MulSemiringAction M R\na : M\n⊢ Eq (HSMul.hSMul a Bot.bot) Bot.bot","decl":"@[simp]\ntheorem smul_bot (a : M) : a • (⊥ : Ideal R) = ⊥ :=\n  map_bot\n\n"}
{"name":"Ideal.smul_sup","module":"Mathlib.RingTheory.Ideal.Pointwise","initialProofState":"M : Type u_1\nR : Type u_2\ninst✝² : Monoid M\ninst✝¹ : Semiring R\ninst✝ : MulSemiringAction M R\na : M\nS T : Ideal R\n⊢ Eq (HSMul.hSMul a (Max.max S T)) (Max.max (HSMul.hSMul a S) (HSMul.hSMul a T))","decl":"theorem smul_sup (a : M) (S T : Ideal R) : a • (S ⊔ T) = a • S ⊔ a • T :=\n  map_sup _ _ _\n\n"}
{"name":"Ideal.smul_closure","module":"Mathlib.RingTheory.Ideal.Pointwise","initialProofState":"M : Type u_1\nR : Type u_2\ninst✝² : Monoid M\ninst✝¹ : Semiring R\ninst✝ : MulSemiringAction M R\na : M\ns : Set R\n⊢ Eq (HSMul.hSMul a (Ideal.span s)) (Ideal.span (HSMul.hSMul a s))","decl":"theorem smul_closure (a : M) (s : Set R) : a • span s = span (a • s) :=\n  Ideal.map_span _ _\n\n"}
{"name":"Ideal.pointwise_central_scalar","module":"Mathlib.RingTheory.Ideal.Pointwise","initialProofState":"M : Type u_1\nR : Type u_2\ninst✝⁴ : Monoid M\ninst✝³ : Semiring R\ninst✝² : MulSemiringAction M R\ninst✝¹ : MulSemiringAction (MulOpposite M) R\ninst✝ : IsCentralScalar M R\n⊢ IsCentralScalar M (Ideal R)","decl":"instance pointwise_central_scalar [MulSemiringAction Mᵐᵒᵖ R] [IsCentralScalar M R] :\n    IsCentralScalar M (Ideal R) :=\n  ⟨fun _ S => (congr_arg fun f => S.map f) <| RingHom.ext <| op_smul_eq_smul _⟩\n\n"}
{"name":"Ideal.pointwise_smul_toAddSubmonoid","module":"Mathlib.RingTheory.Ideal.Pointwise","initialProofState":"M : Type u_1\nR : Type u_2\ninst✝² : Monoid M\ninst✝¹ : Semiring R\ninst✝ : MulSemiringAction M R\na : M\nS : Ideal R\nha : Function.Surjective fun r => HSMul.hSMul a r\n⊢ Eq (HSMul.hSMul a S).toAddSubmonoid (HSMul.hSMul a S.toAddSubmonoid)","decl":"@[simp]\ntheorem pointwise_smul_toAddSubmonoid (a : M) (S : Ideal R)\n    (ha : Function.Surjective fun r : R => a • r) :\n    (a • S).toAddSubmonoid = a • S.toAddSubmonoid := by\n  ext\n  exact Ideal.mem_map_iff_of_surjective _ <| by exact ha\n\n"}
{"name":"Ideal.pointwise_smul_toAddSubGroup","module":"Mathlib.RingTheory.Ideal.Pointwise","initialProofState":"M : Type u_1\ninst✝² : Monoid M\nR : Type u_3\ninst✝¹ : Ring R\ninst✝ : MulSemiringAction M R\na : M\nS : Ideal R\nha : Function.Surjective fun r => HSMul.hSMul a r\n⊢ Eq (Submodule.toAddSubgroup (HSMul.hSMul a S)) (HSMul.hSMul a (Submodule.toAddSubgroup S))","decl":"@[simp]\ntheorem pointwise_smul_toAddSubGroup {R : Type*} [Ring R] [MulSemiringAction M R]\n    (a : M) (S : Ideal R) (ha : Function.Surjective fun r : R => a • r)  :\n    (a • S).toAddSubgroup = a • S.toAddSubgroup := by\n  ext\n  exact Ideal.mem_map_iff_of_surjective _ <| by exact ha\n\n"}
{"name":"Ideal.pointwise_smul_eq_comap","module":"Mathlib.RingTheory.Ideal.Pointwise","initialProofState":"M : Type u_1\nR : Type u_2\ninst✝² : Group M\ninst✝¹ : Semiring R\ninst✝ : MulSemiringAction M R\na : M\nS : Ideal R\n⊢ Eq (HSMul.hSMul a S) (Ideal.comap (RingEquiv.symm ((MulSemiringAction.toRingAut M R) a)) S)","decl":"theorem pointwise_smul_eq_comap {a : M} (S : Ideal R) :\n    a • S = S.comap (MulSemiringAction.toRingAut _ _ a).symm := by\n  ext\n  simp [pointwise_smul_def]\n  rfl\n\n"}
{"name":"Ideal.smul_mem_pointwise_smul_iff","module":"Mathlib.RingTheory.Ideal.Pointwise","initialProofState":"M : Type u_1\nR : Type u_2\ninst✝² : Group M\ninst✝¹ : Semiring R\ninst✝ : MulSemiringAction M R\na : M\nS : Ideal R\nx : R\n⊢ Iff (Membership.mem (HSMul.hSMul a S) (HSMul.hSMul a x)) (Membership.mem S x)","decl":"@[simp]\ntheorem smul_mem_pointwise_smul_iff {a : M} {S : Ideal R} {x : R} : a • x ∈ a • S ↔ x ∈ S :=\n  ⟨fun h => by simpa using smul_mem_pointwise_smul a⁻¹ _ _ h, smul_mem_pointwise_smul _ _ _⟩\n\n"}
{"name":"Ideal.mem_pointwise_smul_iff_inv_smul_mem","module":"Mathlib.RingTheory.Ideal.Pointwise","initialProofState":"M : Type u_1\nR : Type u_2\ninst✝² : Group M\ninst✝¹ : Semiring R\ninst✝ : MulSemiringAction M R\na : M\nS : Ideal R\nx : R\n⊢ Iff (Membership.mem (HSMul.hSMul a S) x) (Membership.mem S (HSMul.hSMul (Inv.inv a) x))","decl":"theorem mem_pointwise_smul_iff_inv_smul_mem {a : M} {S : Ideal R} {x : R} :\n    x ∈ a • S ↔ a⁻¹ • x ∈ S :=\n  ⟨fun h => by simpa using smul_mem_pointwise_smul a⁻¹ _ _ h,\n    fun h => by simpa using smul_mem_pointwise_smul a _ _ h⟩\n\n"}
{"name":"Ideal.mem_inv_pointwise_smul_iff","module":"Mathlib.RingTheory.Ideal.Pointwise","initialProofState":"M : Type u_1\nR : Type u_2\ninst✝² : Group M\ninst✝¹ : Semiring R\ninst✝ : MulSemiringAction M R\na : M\nS : Ideal R\nx : R\n⊢ Iff (Membership.mem (HSMul.hSMul (Inv.inv a) S) x) (Membership.mem S (HSMul.hSMul a x))","decl":"theorem mem_inv_pointwise_smul_iff {a : M} {S : Ideal R} {x : R} : x ∈ a⁻¹ • S ↔ a • x ∈ S := by\n  rw [mem_pointwise_smul_iff_inv_smul_mem, inv_inv]\n\n"}
{"name":"Ideal.pointwise_smul_le_pointwise_smul_iff","module":"Mathlib.RingTheory.Ideal.Pointwise","initialProofState":"M : Type u_1\nR : Type u_2\ninst✝² : Group M\ninst✝¹ : Semiring R\ninst✝ : MulSemiringAction M R\na : M\nS T : Ideal R\n⊢ Iff (LE.le (HSMul.hSMul a S) (HSMul.hSMul a T)) (LE.le S T)","decl":"@[simp]\ntheorem pointwise_smul_le_pointwise_smul_iff {a : M} {S T : Ideal R} : a • S ≤ a • T ↔ S ≤ T :=\n  ⟨fun h => by simpa using smul_mono_right a⁻¹ h, fun h => smul_mono_right a h⟩\n\n"}
{"name":"Ideal.pointwise_smul_subset_iff","module":"Mathlib.RingTheory.Ideal.Pointwise","initialProofState":"M : Type u_1\nR : Type u_2\ninst✝² : Group M\ninst✝¹ : Semiring R\ninst✝ : MulSemiringAction M R\na : M\nS T : Ideal R\n⊢ Iff (LE.le (HSMul.hSMul a S) T) (LE.le S (HSMul.hSMul (Inv.inv a) T))","decl":"theorem pointwise_smul_subset_iff {a : M} {S T : Ideal R} : a • S ≤ T ↔ S ≤ a⁻¹ • T := by\n  rw [← pointwise_smul_le_pointwise_smul_iff (a := a⁻¹), inv_smul_smul]\n\n"}
{"name":"Ideal.subset_pointwise_smul_iff","module":"Mathlib.RingTheory.Ideal.Pointwise","initialProofState":"M : Type u_1\nR : Type u_2\ninst✝² : Group M\ninst✝¹ : Semiring R\ninst✝ : MulSemiringAction M R\na : M\nS T : Ideal R\n⊢ Iff (LE.le S (HSMul.hSMul a T)) (LE.le (HSMul.hSMul (Inv.inv a) S) T)","decl":"theorem subset_pointwise_smul_iff {a : M} {S T : Ideal R} : S ≤ a • T ↔ a⁻¹ • S ≤ T := by\n  rw [← pointwise_smul_le_pointwise_smul_iff (a := a⁻¹), inv_smul_smul]\n\n"}
{"name":"Ideal.IsPrime.smul","module":"Mathlib.RingTheory.Ideal.Pointwise","initialProofState":"M : Type u_1\nR : Type u_2\ninst✝² : Group M\ninst✝¹ : Semiring R\ninst✝ : MulSemiringAction M R\nI : Ideal R\nH : I.IsPrime\ng : M\n⊢ (HSMul.hSMul g I).IsPrime","decl":"instance IsPrime.smul {I : Ideal R} [H : I.IsPrime] (g : M) : (g • I).IsPrime := by\n  rw [I.pointwise_smul_eq_comap]\n  apply H.comap\n\n"}
{"name":"Ideal.IsPrime.smul_iff","module":"Mathlib.RingTheory.Ideal.Pointwise","initialProofState":"M : Type u_1\nR : Type u_2\ninst✝² : Group M\ninst✝¹ : Semiring R\ninst✝ : MulSemiringAction M R\nI : Ideal R\ng : M\n⊢ Iff (HSMul.hSMul g I).IsPrime I.IsPrime","decl":"@[simp]\ntheorem IsPrime.smul_iff {I : Ideal R} (g : M) : (g • I).IsPrime ↔ I.IsPrime :=\n  ⟨fun H ↦ inv_smul_smul g I ▸ H.smul g⁻¹, fun H ↦ H.smul g⟩\n\n"}
