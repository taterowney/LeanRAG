{"name":"not_isLeft_and_isRight","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nx : Sum α β\n⊢ Not (And (Eq x.isLeft Bool.true) (Eq x.isRight Bool.true))","decl":"lemma not_isLeft_and_isRight {x : α ⊕ β} : ¬(x.isLeft ∧ x.isRight) := by simp\n\n"}
{"name":"Sum.exists_sum","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Sum α β → Sort u_3\np : ((ab : Sum α β) → γ ab) → Prop\n⊢ Iff (Exists fun fab => p fab) (Exists fun fa => Exists fun fb => p fun t => Sum.rec fa fb t)","decl":"theorem exists_sum {γ : α ⊕ β → Sort*} (p : (∀ ab, γ ab) → Prop) :\n    (∃ fab, p fab) ↔ (∃ fa fb, p (Sum.rec fa fb)) := by\n  rw [← not_forall_not, forall_sum]\n  simp\n\n"}
{"name":"Sum.inl_injective","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\n⊢ Function.Injective Sum.inl","decl":"theorem inl_injective : Function.Injective (inl : α → α ⊕ β) := fun _ _ ↦ inl.inj\n\n"}
{"name":"Sum.inr_injective","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\n⊢ Function.Injective Sum.inr","decl":"theorem inr_injective : Function.Injective (inr : β → α ⊕ β) := fun _ _ ↦ inr.inj\n\n"}
{"name":"Sum.sum_rec_congr","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nP : Sum α β → Sort u_3\nf : (i : α) → P (Sum.inl i)\ng : (i : β) → P (Sum.inr i)\nx y : Sum α β\nh : Eq x y\n⊢ Eq (Sum.rec f g x) (cast ⋯ (Sum.rec f g y))","decl":"theorem sum_rec_congr (P : α ⊕ β → Sort*) (f : ∀ i, P (inl i)) (g : ∀ i, P (inr i))\n    {x y : α ⊕ β} (h : x = y) :\n    @Sum.rec _ _ _ f g x = cast (congr_arg P h.symm) (@Sum.rec _ _ _ f g y) := by cases h; rfl\n\n"}
{"name":"Sum.eq_left_iff_getLeft_eq","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nx : Sum α β\na : α\n⊢ Iff (Eq x (Sum.inl a)) (Exists fun h => Eq (x.getLeft h) a)","decl":"theorem eq_left_iff_getLeft_eq {a : α} : x = inl a ↔ ∃ h, x.getLeft h = a := by\n  cases x <;> simp\n\n"}
{"name":"Sum.eq_right_iff_getRight_eq","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nx : Sum α β\nb : β\n⊢ Iff (Eq x (Sum.inr b)) (Exists fun h => Eq (x.getRight h) b)","decl":"theorem eq_right_iff_getRight_eq {b : β} : x = inr b ↔ ∃ h, x.getRight h = b := by\n  cases x <;> simp\n\n"}
{"name":"Sum.getLeft_eq_getLeft?","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nx : Sum α β\nh₁ : Eq x.isLeft Bool.true\nh₂ : Eq x.getLeft?.isSome Bool.true\n⊢ Eq (x.getLeft h₁) (x.getLeft?.get h₂)","decl":"theorem getLeft_eq_getLeft? (h₁ : x.isLeft) (h₂ : x.getLeft?.isSome) :\n    x.getLeft h₁ = x.getLeft?.get h₂ := by simp [← getLeft?_eq_some_iff]\n\n"}
{"name":"Sum.getRight_eq_getRight?","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nx : Sum α β\nh₁ : Eq x.isRight Bool.true\nh₂ : Eq x.getRight?.isSome Bool.true\n⊢ Eq (x.getRight h₁) (x.getRight?.get h₂)","decl":"theorem getRight_eq_getRight? (h₁ : x.isRight) (h₂ : x.getRight?.isSome) :\n    x.getRight h₁ = x.getRight?.get h₂ := by simp [← getRight?_eq_some_iff]\n\n"}
{"name":"Sum.isSome_getLeft?_iff_isLeft","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nx : Sum α β\n⊢ Iff (Eq x.getLeft?.isSome Bool.true) (Eq x.isLeft Bool.true)","decl":"@[simp] theorem isSome_getLeft?_iff_isLeft : x.getLeft?.isSome ↔ x.isLeft := by\n  rw [isLeft_iff, Option.isSome_iff_exists]; simp\n\n"}
{"name":"Sum.isSome_getRight?_iff_isRight","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nx : Sum α β\n⊢ Iff (Eq x.getRight?.isSome Bool.true) (Eq x.isRight Bool.true)","decl":"@[simp] theorem isSome_getRight?_iff_isRight : x.getRight?.isSome ↔ x.isRight := by\n  rw [isRight_iff, Option.isSome_iff_exists]; simp\n\n"}
{"name":"Sum.update_elim_inl","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq (Sum α β)\nf : α → γ\ng : β → γ\ni : α\nx : γ\n⊢ Eq (Function.update (Sum.elim f g) (Sum.inl i) x) (Sum.elim (Function.update f i x) g)","decl":"@[simp]\ntheorem update_elim_inl [DecidableEq α] [DecidableEq (α ⊕ β)] {f : α → γ} {g : β → γ} {i : α}\n    {x : γ} : update (Sum.elim f g) (inl i) x = Sum.elim (update f i x) g :=\n  update_eq_iff.2 ⟨by simp, by simp +contextual⟩\n\n"}
{"name":"Sum.update_elim_inr","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq (Sum α β)\nf : α → γ\ng : β → γ\ni : β\nx : γ\n⊢ Eq (Function.update (Sum.elim f g) (Sum.inr i) x) (Sum.elim f (Function.update g i x))","decl":"@[simp]\ntheorem update_elim_inr [DecidableEq β] [DecidableEq (α ⊕ β)] {f : α → γ} {g : β → γ} {i : β}\n    {x : γ} : update (Sum.elim f g) (inr i) x = Sum.elim f (update g i x) :=\n  update_eq_iff.2 ⟨by simp, by simp +contextual⟩\n\n"}
{"name":"Sum.update_inl_comp_inl","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq (Sum α β)\nf : Sum α β → γ\ni : α\nx : γ\n⊢ Eq (Function.comp (Function.update f (Sum.inl i) x) Sum.inl) (Function.update (Function.comp f Sum.inl) i x)","decl":"@[simp]\ntheorem update_inl_comp_inl [DecidableEq α] [DecidableEq (α ⊕ β)] {f : α ⊕ β → γ} {i : α}\n    {x : γ} : update f (inl i) x ∘ inl = update (f ∘ inl) i x :=\n  update_comp_eq_of_injective _ inl_injective _ _\n\n"}
{"name":"Sum.update_inl_apply_inl","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq (Sum α β)\nf : Sum α β → γ\ni j : α\nx : γ\n⊢ Eq (Function.update f (Sum.inl i) x (Sum.inl j)) (Function.update (Function.comp f Sum.inl) i x j)","decl":"@[simp]\ntheorem update_inl_apply_inl [DecidableEq α] [DecidableEq (α ⊕ β)] {f : α ⊕ β → γ} {i j : α}\n    {x : γ} : update f (inl i) x (inl j) = update (f ∘ inl) i x j := by\n  rw [← update_inl_comp_inl, Function.comp_apply]\n\n"}
{"name":"Sum.update_inl_comp_inr","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\ninst✝ : DecidableEq (Sum α β)\nf : Sum α β → γ\ni : α\nx : γ\n⊢ Eq (Function.comp (Function.update f (Sum.inl i) x) Sum.inr) (Function.comp f Sum.inr)","decl":"@[simp]\ntheorem update_inl_comp_inr [DecidableEq (α ⊕ β)] {f : α ⊕ β → γ} {i : α} {x : γ} :\n    update f (inl i) x ∘ inr = f ∘ inr :=\n  (update_comp_eq_of_forall_ne _ _) fun _ ↦ inr_ne_inl\n\n"}
{"name":"Sum.update_inl_apply_inr","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\ninst✝ : DecidableEq (Sum α β)\nf : Sum α β → γ\ni : α\nj : β\nx : γ\n⊢ Eq (Function.update f (Sum.inl i) x (Sum.inr j)) (f (Sum.inr j))","decl":"theorem update_inl_apply_inr [DecidableEq (α ⊕ β)] {f : α ⊕ β → γ} {i : α} {j : β} {x : γ} :\n    update f (inl i) x (inr j) = f (inr j) :=\n  Function.update_of_ne inr_ne_inl ..\n\n"}
{"name":"Sum.update_inr_comp_inl","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\ninst✝ : DecidableEq (Sum α β)\nf : Sum α β → γ\ni : β\nx : γ\n⊢ Eq (Function.comp (Function.update f (Sum.inr i) x) Sum.inl) (Function.comp f Sum.inl)","decl":"@[simp]\ntheorem update_inr_comp_inl [DecidableEq (α ⊕ β)] {f : α ⊕ β → γ} {i : β} {x : γ} :\n    update f (inr i) x ∘ inl = f ∘ inl :=\n  (update_comp_eq_of_forall_ne _ _) fun _ ↦ inl_ne_inr\n\n"}
{"name":"Sum.update_inr_apply_inl","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\ninst✝ : DecidableEq (Sum α β)\nf : Sum α β → γ\ni : α\nj : β\nx : γ\n⊢ Eq (Function.update f (Sum.inr j) x (Sum.inl i)) (f (Sum.inl i))","decl":"theorem update_inr_apply_inl [DecidableEq (α ⊕ β)] {f : α ⊕ β → γ} {i : α} {j : β} {x : γ} :\n    update f (inr j) x (inl i) = f (inl i) :=\n  Function.update_of_ne inl_ne_inr ..\n\n"}
{"name":"Sum.update_inr_comp_inr","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq (Sum α β)\nf : Sum α β → γ\ni : β\nx : γ\n⊢ Eq (Function.comp (Function.update f (Sum.inr i) x) Sum.inr) (Function.update (Function.comp f Sum.inr) i x)","decl":"@[simp]\ntheorem update_inr_comp_inr [DecidableEq β] [DecidableEq (α ⊕ β)] {f : α ⊕ β → γ} {i : β}\n    {x : γ} : update f (inr i) x ∘ inr = update (f ∘ inr) i x :=\n  update_comp_eq_of_injective _ inr_injective _ _\n\n"}
{"name":"Sum.update_inr_apply_inr","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq (Sum α β)\nf : Sum α β → γ\ni j : β\nx : γ\n⊢ Eq (Function.update f (Sum.inr i) x (Sum.inr j)) (Function.update (Function.comp f Sum.inr) i x j)","decl":"@[simp]\ntheorem update_inr_apply_inr [DecidableEq β] [DecidableEq (α ⊕ β)] {f : α ⊕ β → γ} {i j : β}\n    {x : γ} : update f (inr i) x (inr j) = update (f ∘ inr) i x j := by\n  rw [← update_inr_comp_inr, Function.comp_apply]\n\n"}
{"name":"Sum.swap_leftInverse","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\n⊢ Function.LeftInverse Sum.swap Sum.swap","decl":"@[simp]\ntheorem swap_leftInverse : Function.LeftInverse (@swap α β) swap :=\n  swap_swap\n\n"}
{"name":"Sum.swap_rightInverse","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\n⊢ Function.RightInverse Sum.swap Sum.swap","decl":"@[simp]\ntheorem swap_rightInverse : Function.RightInverse (@swap α β) swap :=\n  swap_swap\n\n"}
{"name":"Sum.liftRel_iff","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u_1\nγ : Type u_2\nβ : Type u_3\nδ : Type u_4\nr : α → γ → Prop\ns : β → δ → Prop\na✝¹ : Sum α β\na✝ : Sum γ δ\n⊢ Iff (Sum.LiftRel r s a✝¹ a✝) (Or (Exists fun a => Exists fun c => And (r a c) (And (Eq a✝¹ (Sum.inl a)) (Eq a✝ (Sum.inl c)))) (Exists fun b => Exists fun d => And (s b d) (And (Eq a✝¹ (Sum.inr b)) (Eq a✝ (Sum.inr d)))))","decl":"mk_iff_of_inductive_prop Sum.LiftRel Sum.liftRel_iff\n\n"}
{"name":"Sum.LiftRel.isLeft_congr","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\nδ : Type u_2\nr : α → γ → Prop\ns : β → δ → Prop\nx : Sum α β\ny : Sum γ δ\nh : Sum.LiftRel r s x y\n⊢ Iff (Eq x.isLeft Bool.true) (Eq y.isLeft Bool.true)","decl":"theorem isLeft_congr (h : LiftRel r s x y) : x.isLeft ↔ y.isLeft := by cases h <;> rfl\n"}
{"name":"Sum.LiftRel.isRight_congr","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\nδ : Type u_2\nr : α → γ → Prop\ns : β → δ → Prop\nx : Sum α β\ny : Sum γ δ\nh : Sum.LiftRel r s x y\n⊢ Iff (Eq x.isRight Bool.true) (Eq y.isRight Bool.true)","decl":"theorem isRight_congr (h : LiftRel r s x y) : x.isRight ↔ y.isRight := by cases h <;> rfl\n\n"}
{"name":"Sum.LiftRel.isLeft_left","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\nδ : Type u_2\nr : α → γ → Prop\ns : β → δ → Prop\nx : Sum α β\nc : γ\nh : Sum.LiftRel r s x (Sum.inl c)\n⊢ Eq x.isLeft Bool.true","decl":"theorem isLeft_left (h : LiftRel r s x (inl c)) : x.isLeft := by cases h; rfl\n"}
{"name":"Sum.LiftRel.isLeft_right","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\nδ : Type u_2\nr : α → γ → Prop\ns : β → δ → Prop\ny : Sum γ δ\na : α\nh : Sum.LiftRel r s (Sum.inl a) y\n⊢ Eq y.isLeft Bool.true","decl":"theorem isLeft_right (h : LiftRel r s (inl a) y) : y.isLeft := by cases h; rfl\n"}
{"name":"Sum.LiftRel.isRight_left","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\nδ : Type u_2\nr : α → γ → Prop\ns : β → δ → Prop\nx : Sum α β\nd : δ\nh : Sum.LiftRel r s x (Sum.inr d)\n⊢ Eq x.isRight Bool.true","decl":"theorem isRight_left (h : LiftRel r s x (inr d)) : x.isRight := by cases h; rfl\n"}
{"name":"Sum.LiftRel.isRight_right","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\nδ : Type u_2\nr : α → γ → Prop\ns : β → δ → Prop\ny : Sum γ δ\nb : β\nh : Sum.LiftRel r s (Sum.inr b) y\n⊢ Eq y.isRight Bool.true","decl":"theorem isRight_right (h : LiftRel r s (inr b) y) : y.isRight := by cases h; rfl\n\n"}
{"name":"Sum.LiftRel.exists_of_isLeft_left","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\nδ : Type u_2\nr : α → γ → Prop\ns : β → δ → Prop\nx : Sum α β\ny : Sum γ δ\nh₁ : Sum.LiftRel r s x y\nh₂ : Eq x.isLeft Bool.true\n⊢ Exists fun a => Exists fun c => And (r a c) (And (Eq x (Sum.inl a)) (Eq y (Sum.inl c)))","decl":"theorem exists_of_isLeft_left (h₁ : LiftRel r s x y) (h₂ : x.isLeft) :\n    ∃ a c, r a c ∧ x = inl a ∧ y = inl c := by\n  rcases isLeft_iff.mp h₂ with ⟨_, rfl⟩\n  simp only [liftRel_iff, false_and, and_false, exists_false, or_false, reduceCtorEq] at h₁\n  exact h₁\n\n"}
{"name":"Sum.LiftRel.exists_of_isLeft_right","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\nδ : Type u_2\nr : α → γ → Prop\ns : β → δ → Prop\nx : Sum α β\ny : Sum γ δ\nh₁ : Sum.LiftRel r s x y\nh₂ : Eq y.isLeft Bool.true\n⊢ Exists fun a => Exists fun c => And (r a c) (And (Eq x (Sum.inl a)) (Eq y (Sum.inl c)))","decl":"theorem exists_of_isLeft_right (h₁ : LiftRel r s x y) (h₂ : y.isLeft) :\n    ∃ a c, r a c ∧ x = inl a ∧ y = inl c := exists_of_isLeft_left h₁ ((isLeft_congr h₁).mpr h₂)\n\n"}
{"name":"Sum.LiftRel.exists_of_isRight_left","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\nδ : Type u_2\nr : α → γ → Prop\ns : β → δ → Prop\nx : Sum α β\ny : Sum γ δ\nh₁ : Sum.LiftRel r s x y\nh₂ : Eq x.isRight Bool.true\n⊢ Exists fun b => Exists fun d => And (s b d) (And (Eq x (Sum.inr b)) (Eq y (Sum.inr d)))","decl":"theorem exists_of_isRight_left (h₁ : LiftRel r s x y) (h₂ : x.isRight) :\n    ∃ b d, s b d ∧ x = inr b ∧ y = inr d := by\n  rcases isRight_iff.mp h₂ with ⟨_, rfl⟩\n  simp only [liftRel_iff, false_and, and_false, exists_false, false_or, reduceCtorEq] at h₁\n  exact h₁\n\n"}
{"name":"Sum.LiftRel.exists_of_isRight_right","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\nδ : Type u_2\nr : α → γ → Prop\ns : β → δ → Prop\nx : Sum α β\ny : Sum γ δ\nh₁ : Sum.LiftRel r s x y\nh₂ : Eq y.isRight Bool.true\n⊢ Exists fun b => Exists fun d => And (s b d) (And (Eq x (Sum.inr b)) (Eq y (Sum.inr d)))","decl":"theorem exists_of_isRight_right (h₁ : LiftRel r s x y) (h₂ : y.isRight) :\n    ∃ b d, s b d ∧ x = inr b ∧ y = inr d :=\n  exists_of_isRight_left h₁ ((isRight_congr h₁).mpr h₂)\n\n"}
{"name":"Function.Injective.sum_elim","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\nf : α → γ\ng : β → γ\nhf : Function.Injective f\nhg : Function.Injective g\nhfg : ∀ (a : α) (b : β), Ne (f a) (g b)\n⊢ Function.Injective (Sum.elim f g)","decl":"theorem Injective.sum_elim {f : α → γ} {g : β → γ} (hf : Injective f) (hg : Injective g)\n    (hfg : ∀ a b, f a ≠ g b) : Injective (Sum.elim f g)\n  | inl _, inl _, h => congr_arg inl <| hf h\n  | inl _, inr _, h => (hfg _ _ h).elim\n  | inr _, inl _, h => (hfg _ _ h.symm).elim\n  | inr _, inr _, h => congr_arg inr <| hg h\n\n"}
{"name":"Function.Injective.sum_map","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nα' : Type w\nβ : Type v\nβ' : Type x\nf : α → β\ng : α' → β'\nhf : Function.Injective f\nhg : Function.Injective g\n⊢ Function.Injective (Sum.map f g)","decl":"theorem Injective.sum_map {f : α → β} {g : α' → β'} (hf : Injective f) (hg : Injective g) :\n    Injective (Sum.map f g)\n  | inl _, inl _, h => congr_arg inl <| hf <| inl.inj h\n  | inr _, inr _, h => congr_arg inr <| hg <| inr.inj h\n\n"}
{"name":"Function.Surjective.sum_map","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nα' : Type w\nβ : Type v\nβ' : Type x\nf : α → β\ng : α' → β'\nhf : Function.Surjective f\nhg : Function.Surjective g\n⊢ Function.Surjective (Sum.map f g)","decl":"theorem Surjective.sum_map {f : α → β} {g : α' → β'} (hf : Surjective f) (hg : Surjective g) :\n    Surjective (Sum.map f g)\n  | inl y =>\n    let ⟨x, hx⟩ := hf y\n    ⟨inl x, congr_arg inl hx⟩\n  | inr y =>\n    let ⟨x, hx⟩ := hg y\n    ⟨inr x, congr_arg inr hx⟩\n\n"}
{"name":"Function.Bijective.sum_map","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nα' : Type w\nβ : Type v\nβ' : Type x\nf : α → β\ng : α' → β'\nhf : Function.Bijective f\nhg : Function.Bijective g\n⊢ Function.Bijective (Sum.map f g)","decl":"theorem Bijective.sum_map {f : α → β} {g : α' → β'} (hf : Bijective f) (hg : Bijective g) :\n    Bijective (Sum.map f g) :=\n  ⟨hf.injective.sum_map hg.injective, hf.surjective.sum_map hg.surjective⟩\n\n"}
{"name":"Sum.map_injective","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\nδ : Type u_2\nf : α → γ\ng : β → δ\n⊢ Iff (Function.Injective (Sum.map f g)) (And (Function.Injective f) (Function.Injective g))","decl":"@[simp]\ntheorem map_injective {f : α → γ} {g : β → δ} :\n    Injective (Sum.map f g) ↔ Injective f ∧ Injective g :=\n  ⟨fun h =>\n    ⟨fun a₁ a₂ ha => inl_injective <| @h (inl a₁) (inl a₂) (congr_arg inl ha :), fun b₁ b₂ hb =>\n      inr_injective <| @h (inr b₁) (inr b₂) (congr_arg inr hb :)⟩,\n    fun h => h.1.sum_map h.2⟩\n\n"}
{"name":"Sum.map_surjective","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\nδ : Type u_2\nf : α → γ\ng : β → δ\n⊢ Iff (Function.Surjective (Sum.map f g)) (And (Function.Surjective f) (Function.Surjective g))","decl":"@[simp]\ntheorem map_surjective {f : α → γ} {g : β → δ} :\n    Surjective (Sum.map f g) ↔ Surjective f ∧ Surjective g :=\n  ⟨ fun h => ⟨\n      (fun c => by\n        obtain ⟨a | b, h⟩ := h (inl c)\n        · exact ⟨a, inl_injective h⟩\n        · cases h),\n      (fun d => by\n        obtain ⟨a | b, h⟩ := h (inr d)\n        · cases h\n        · exact ⟨b, inr_injective h⟩)⟩,\n    fun h => h.1.sum_map h.2⟩\n\n"}
{"name":"Sum.map_bijective","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\nδ : Type u_2\nf : α → γ\ng : β → δ\n⊢ Iff (Function.Bijective (Sum.map f g)) (And (Function.Bijective f) (Function.Bijective g))","decl":"@[simp]\ntheorem map_bijective {f : α → γ} {g : β → δ} :\n    Bijective (Sum.map f g) ↔ Bijective f ∧ Bijective g :=\n  (map_injective.and map_surjective).trans <| and_and_and_comm\n\n"}
{"name":"Sum.elim_update_left","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nf : α → γ\ng : β → γ\ni : α\nc : γ\n⊢ Eq (Sum.elim (Function.update f i c) g) (Function.update (Sum.elim f g) (Sum.inl i) c)","decl":"theorem elim_update_left [DecidableEq α] [DecidableEq β] (f : α → γ) (g : β → γ) (i : α) (c : γ) :\n    Sum.elim (Function.update f i c) g = Function.update (Sum.elim f g) (inl i) c := by\n  ext x\n  rcases x with x | x\n  · by_cases h : x = i\n    · subst h\n      simp\n    · simp [h]\n  · simp\n\n"}
{"name":"Sum.elim_update_right","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nf : α → γ\ng : β → γ\ni : β\nc : γ\n⊢ Eq (Sum.elim f (Function.update g i c)) (Function.update (Sum.elim f g) (Sum.inr i) c)","decl":"theorem elim_update_right [DecidableEq α] [DecidableEq β] (f : α → γ) (g : β → γ) (i : β) (c : γ) :\n    Sum.elim f (Function.update g i c) = Function.update (Sum.elim f g) (inr i) c := by\n  ext x\n  rcases x with x | x\n  · simp\n  · by_cases h : x = i\n    · subst h\n      simp\n    · simp [h]\n\n"}
{"name":"PSum.inl_injective","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Sort u_3\nβ : Sort u_4\n⊢ Function.Injective PSum.inl","decl":"theorem inl_injective : Function.Injective (PSum.inl : α → α ⊕' β) := fun _ _ ↦ inl.inj\n\n"}
{"name":"PSum.inr_injective","module":"Mathlib.Data.Sum.Basic","initialProofState":"α : Sort u_3\nβ : Sort u_4\n⊢ Function.Injective PSum.inr","decl":"theorem inr_injective : Function.Injective (PSum.inr : β → α ⊕' β) := fun _ _ ↦ inr.inj\n\n"}
