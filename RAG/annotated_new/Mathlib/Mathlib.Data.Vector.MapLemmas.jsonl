{"name":"List.Vector.mapAccumr_mapAccumr","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ₁ : Type u_6\nσ₂ : Type u_7\nn : Nat\ns₁ : σ₁\ns₂ : σ₂\nxs : List.Vector α n\nf₁ : β → σ₁ → Prod σ₁ γ\nf₂ : α → σ₂ → Prod σ₂ β\n⊢ Eq (List.Vector.mapAccumr f₁ (List.Vector.mapAccumr f₂ xs s₂).2 s₁)\n    (let m :=\n      List.Vector.mapAccumr\n        (fun x s =>\n          let r₂ := f₂ x s.2;\n          let r₁ := f₁ r₂.2 s.1;\n          { fst := { fst := r₁.1, snd := r₂.1 }, snd := r₁.2 })\n        xs { fst := s₁, snd := s₂ };\n    { fst := m.1.1, snd := m.2 })","decl":"@[simp]\ntheorem mapAccumr_mapAccumr :\n    mapAccumr f₁ (mapAccumr f₂ xs s₂).snd s₁\n    = let m := (mapAccumr (fun x s =>\n        let r₂ := f₂ x s.snd\n        let r₁ := f₁ r₂.snd s.fst\n        ((r₁.fst, r₂.fst), r₁.snd)\n      ) xs (s₁, s₂))\n      (m.fst.fst, m.snd) := by\n  induction xs using Vector.revInductionOn generalizing s₁ s₂ <;> simp_all\n\n"}
{"name":"List.Vector.mapAccumr_map","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ₁ : Type u_6\nn : Nat\nxs : List.Vector α n\nf₁ : β → σ₁ → Prod σ₁ γ\ns : σ₁\nf₂ : α → β\n⊢ Eq (List.Vector.mapAccumr f₁ (List.Vector.map f₂ xs) s) (List.Vector.mapAccumr (fun x s => f₁ (f₂ x) s) xs s)","decl":"@[simp]\ntheorem mapAccumr_map {s : σ₁} (f₂ : α → β) :\n    (mapAccumr f₁ (map f₂ xs) s) = (mapAccumr (fun x s => f₁ (f₂ x) s) xs s) := by\n  induction xs using Vector.revInductionOn generalizing s <;> simp_all\n\n"}
{"name":"List.Vector.map_mapAccumr","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ₂ : Type u_7\nn : Nat\nxs : List.Vector α n\nf₂ : α → σ₂ → Prod σ₂ β\ns : σ₂\nf₁ : β → γ\n⊢ Eq (List.Vector.map f₁ (List.Vector.mapAccumr f₂ xs s).2)\n    (List.Vector.mapAccumr\n        (fun x s =>\n          let r := f₂ x s;\n          { fst := r.1, snd := f₁ r.2 })\n        xs s).2","decl":"@[simp]\ntheorem map_mapAccumr {s : σ₂} (f₁ : β → γ) :\n    (map f₁ (mapAccumr f₂ xs s).snd) = (mapAccumr (fun x s =>\n        let r := (f₂ x s); (r.fst, f₁ r.snd)\n      ) xs s).snd := by\n  induction xs using Vector.revInductionOn generalizing s <;> simp_all\n\n"}
{"name":"List.Vector.map_map","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nn : Nat\nxs : List.Vector α n\nf₁ : β → γ\nf₂ : α → β\n⊢ Eq (List.Vector.map f₁ (List.Vector.map f₂ xs)) (List.Vector.map (fun x => f₁ (f₂ x)) xs)","decl":"@[simp]\ntheorem map_map (f₁ : β → γ) (f₂ : α → β) :\n    map f₁ (map f₂ xs) = map (fun x => f₁ <| f₂ x) xs := by\n  induction xs <;> simp_all\n\n"}
{"name":"List.Vector.map_pmap","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nn : Nat\nxs : List.Vector α n\np : α → Prop\nf₁ : β → γ\nf₂ : (a : α) → p a → β\nH : ∀ (x : α), Membership.mem xs.toList x → p x\n⊢ Eq (List.Vector.map f₁ (List.Vector.pmap f₂ xs H)) (List.Vector.pmap (fun x hx => f₁ (f₂ x hx)) xs H)","decl":"theorem map_pmap {p : α → Prop} (f₁ : β → γ) (f₂ : (a : α) → p a → β) (H : ∀ x ∈ xs.toList, p x):\n    map f₁ (pmap f₂ xs H) = pmap (fun x hx => f₁ <| f₂ x hx) xs H := by\n  induction xs <;> simp_all\n\n"}
{"name":"List.Vector.pmap_map","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nn : Nat\nxs : List.Vector α n\np : β → Prop\nf₁ : (b : β) → p b → γ\nf₂ : α → β\nH : ∀ (x : β), Membership.mem (List.Vector.map f₂ xs).toList x → p x\n⊢ Eq (List.Vector.pmap f₁ (List.Vector.map f₂ xs) H) (List.Vector.pmap (fun x hx => f₁ (f₂ x) hx) xs ⋯)","decl":"theorem pmap_map {p : β → Prop} (f₁ : (b : β) → p b → γ) (f₂ : α → β)\n    (H : ∀ x ∈ (xs.map f₂).toList, p x):\n    pmap f₁ (map f₂ xs) H = pmap (fun x hx => f₁ (f₂ x) hx) xs (by simpa using H) := by\n  induction xs <;> simp_all\n\n"}
{"name":"List.Vector.mapAccumr₂_mapAccumr_left","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nζ : Type u_4\nσ₁ : Type u_6\nσ₂ : Type u_7\nn : Nat\ns₁ : σ₁\ns₂ : σ₂\nxs : List.Vector α n\nys : List.Vector β n\nf₁ : γ → β → σ₁ → Prod σ₁ ζ\nf₂ : α → σ₂ → Prod σ₂ γ\n⊢ Eq (List.Vector.mapAccumr₂ f₁ (List.Vector.mapAccumr f₂ xs s₂).2 ys s₁)\n    (let m :=\n      List.Vector.mapAccumr₂\n        (fun x y s =>\n          let r₂ := f₂ x s.2;\n          let r₁ := f₁ r₂.2 y s.1;\n          { fst := { fst := r₁.1, snd := r₂.1 }, snd := r₁.2 })\n        xs ys { fst := s₁, snd := s₂ };\n    { fst := m.1.1, snd := m.2 })","decl":"@[simp]\ntheorem mapAccumr₂_mapAccumr_left (f₁ : γ → β → σ₁ → σ₁ × ζ) (f₂ : α → σ₂ → σ₂ × γ) :\n    (mapAccumr₂ f₁ (mapAccumr f₂ xs s₂).snd ys s₁)\n    = let m := (mapAccumr₂ (fun x y s =>\n          let r₂ := f₂ x s.snd\n          let r₁ := f₁ r₂.snd y s.fst\n          ((r₁.fst, r₂.fst), r₁.snd)\n        ) xs ys (s₁, s₂))\n      (m.fst.fst, m.snd) := by\n  induction xs, ys using Vector.revInductionOn₂ generalizing s₁ s₂ <;> simp_all\n\n"}
{"name":"List.Vector.map₂_map_left","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nζ : Type u_4\nn : Nat\nxs : List.Vector α n\nys : List.Vector β n\nf₁ : γ → β → ζ\nf₂ : α → γ\n⊢ Eq (List.Vector.map₂ f₁ (List.Vector.map f₂ xs) ys) (List.Vector.map₂ (fun x y => f₁ (f₂ x) y) xs ys)","decl":"@[simp]\ntheorem map₂_map_left (f₁ : γ → β → ζ) (f₂ : α → γ) :\n    map₂ f₁ (map f₂ xs) ys = map₂ (fun x y => f₁ (f₂ x) y) xs ys := by\n  induction xs, ys using Vector.revInductionOn₂ <;> simp_all\n\n"}
{"name":"List.Vector.mapAccumr₂_mapAccumr_right","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nζ : Type u_4\nσ₁ : Type u_6\nσ₂ : Type u_7\nn : Nat\ns₁ : σ₁\ns₂ : σ₂\nxs : List.Vector α n\nys : List.Vector β n\nf₁ : α → γ → σ₁ → Prod σ₁ ζ\nf₂ : β → σ₂ → Prod σ₂ γ\n⊢ Eq (List.Vector.mapAccumr₂ f₁ xs (List.Vector.mapAccumr f₂ ys s₂).2 s₁)\n    (let m :=\n      List.Vector.mapAccumr₂\n        (fun x y s =>\n          let r₂ := f₂ y s.2;\n          let r₁ := f₁ x r₂.2 s.1;\n          { fst := { fst := r₁.1, snd := r₂.1 }, snd := r₁.2 })\n        xs ys { fst := s₁, snd := s₂ };\n    { fst := m.1.1, snd := m.2 })","decl":"@[simp]\ntheorem mapAccumr₂_mapAccumr_right (f₁ : α → γ → σ₁ → σ₁ × ζ) (f₂ : β → σ₂ → σ₂ × γ) :\n    (mapAccumr₂ f₁ xs (mapAccumr f₂ ys s₂).snd s₁)\n    = let m := (mapAccumr₂ (fun x y s =>\n          let r₂ := f₂ y s.snd\n          let r₁ := f₁ x r₂.snd s.fst\n          ((r₁.fst, r₂.fst), r₁.snd)\n        ) xs ys (s₁, s₂))\n      (m.fst.fst, m.snd) := by\n  induction xs, ys using Vector.revInductionOn₂ generalizing s₁ s₂ <;> simp_all\n\n"}
{"name":"List.Vector.map₂_map_right","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nζ : Type u_4\nn : Nat\nxs : List.Vector α n\nys : List.Vector β n\nf₁ : α → γ → ζ\nf₂ : β → γ\n⊢ Eq (List.Vector.map₂ f₁ xs (List.Vector.map f₂ ys)) (List.Vector.map₂ (fun x y => f₁ x (f₂ y)) xs ys)","decl":"@[simp]\ntheorem map₂_map_right (f₁ : α → γ → ζ) (f₂ : β → γ) :\n    map₂ f₁ xs (map f₂ ys) = map₂ (fun x y => f₁ x (f₂ y)) xs ys := by\n  induction xs, ys using Vector.revInductionOn₂ <;> simp_all\n\n"}
{"name":"List.Vector.mapAccumr_mapAccumr₂","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nζ : Type u_4\nσ₁ : Type u_6\nσ₂ : Type u_7\nn : Nat\ns₁ : σ₁\ns₂ : σ₂\nxs : List.Vector α n\nys : List.Vector β n\nf₁ : γ → σ₁ → Prod σ₁ ζ\nf₂ : α → β → σ₂ → Prod σ₂ γ\n⊢ Eq (List.Vector.mapAccumr f₁ (List.Vector.mapAccumr₂ f₂ xs ys s₂).2 s₁)\n    (let m :=\n      List.Vector.mapAccumr₂\n        (fun x y s =>\n          let r₂ := f₂ x y s.2;\n          let r₁ := f₁ r₂.2 s.1;\n          { fst := { fst := r₁.1, snd := r₂.1 }, snd := r₁.2 })\n        xs ys { fst := s₁, snd := s₂ };\n    { fst := m.1.1, snd := m.2 })","decl":"@[simp]\ntheorem mapAccumr_mapAccumr₂ (f₁ : γ → σ₁ → σ₁ × ζ) (f₂ : α → β → σ₂ → σ₂ × γ) :\n    (mapAccumr f₁ (mapAccumr₂ f₂ xs ys s₂).snd s₁)\n    = let m := mapAccumr₂ (fun x y s =>\n          let r₂ := f₂ x y s.snd\n          let r₁ := f₁ r₂.snd s.fst\n          ((r₁.fst, r₂.fst), r₁.snd)\n        ) xs ys (s₁, s₂)\n      (m.fst.fst, m.snd) := by\n  induction xs, ys using Vector.revInductionOn₂ generalizing s₁ s₂ <;> simp_all\n\n"}
{"name":"List.Vector.map_map₂","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nζ : Type u_4\nn : Nat\nxs : List.Vector α n\nys : List.Vector β n\nf₁ : γ → ζ\nf₂ : α → β → γ\n⊢ Eq (List.Vector.map f₁ (List.Vector.map₂ f₂ xs ys)) (List.Vector.map₂ (fun x y => f₁ (f₂ x y)) xs ys)","decl":"@[simp]\ntheorem map_map₂ (f₁ : γ → ζ) (f₂ : α → β → γ) :\n    map f₁ (map₂ f₂ xs ys) = map₂ (fun x y => f₁ <| f₂ x y) xs ys := by\n  induction xs, ys using Vector.revInductionOn₂ <;> simp_all\n\n"}
{"name":"List.Vector.mapAccumr₂_mapAccumr₂_left_left","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ₁ : Type u_6\nσ₂ : Type u_7\nφ : Type u_8\nn : Nat\ns₁ : σ₁\ns₂ : σ₂\nxs : List.Vector α n\nys : List.Vector β n\nf₁ : γ → α → σ₁ → Prod σ₁ φ\nf₂ : α → β → σ₂ → Prod σ₂ γ\n⊢ Eq (List.Vector.mapAccumr₂ f₁ (List.Vector.mapAccumr₂ f₂ xs ys s₂).2 xs s₁)\n    (let m :=\n      List.Vector.mapAccumr₂\n        (fun x y x_1 =>\n          List.Vector.mapAccumr₂_mapAccumr₂_left_left.match_1 (fun x => Prod (Prod σ₁ σ₂) φ) x_1 fun s₁ s₂ =>\n            let r₂ := f₂ x y s₂;\n            let r₁ := f₁ r₂.2 x s₁;\n            { fst := { fst := r₁.1, snd := r₂.1 }, snd := r₁.2 })\n        xs ys { fst := s₁, snd := s₂ };\n    { fst := m.1.1, snd := m.2 })","decl":"@[simp]\ntheorem mapAccumr₂_mapAccumr₂_left_left (f₁ : γ → α → σ₁ → σ₁ × φ) (f₂ : α → β → σ₂ → σ₂ × γ) :\n    (mapAccumr₂ f₁ (mapAccumr₂ f₂ xs ys s₂).snd xs s₁)\n    = let m := mapAccumr₂ (fun x y (s₁, s₂) =>\n                let r₂ := f₂ x y s₂\n                let r₁ := f₁ r₂.snd x s₁\n                ((r₁.fst, r₂.fst), r₁.snd)\n              )\n            xs ys (s₁, s₂)\n    (m.fst.fst, m.snd) := by\n  induction xs, ys using Vector.revInductionOn₂ generalizing s₁ s₂ <;> simp_all\n\n"}
{"name":"List.Vector.mapAccumr₂_mapAccumr₂_left_right","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ₁ : Type u_6\nσ₂ : Type u_7\nφ : Type u_8\nn : Nat\ns₁ : σ₁\ns₂ : σ₂\nxs : List.Vector α n\nys : List.Vector β n\nf₁ : γ → β → σ₁ → Prod σ₁ φ\nf₂ : α → β → σ₂ → Prod σ₂ γ\n⊢ Eq (List.Vector.mapAccumr₂ f₁ (List.Vector.mapAccumr₂ f₂ xs ys s₂).2 ys s₁)\n    (let m :=\n      List.Vector.mapAccumr₂\n        (fun x y x_1 =>\n          List.Vector.mapAccumr₂_mapAccumr₂_left_left.match_1 (fun x => Prod (Prod σ₁ σ₂) φ) x_1 fun s₁ s₂ =>\n            let r₂ := f₂ x y s₂;\n            let r₁ := f₁ r₂.2 y s₁;\n            { fst := { fst := r₁.1, snd := r₂.1 }, snd := r₁.2 })\n        xs ys { fst := s₁, snd := s₂ };\n    { fst := m.1.1, snd := m.2 })","decl":"@[simp]\ntheorem mapAccumr₂_mapAccumr₂_left_right\n    (f₁ : γ → β → σ₁ → σ₁ × φ) (f₂ : α → β → σ₂ → σ₂ × γ) :\n    (mapAccumr₂ f₁ (mapAccumr₂ f₂ xs ys s₂).snd ys s₁)\n    = let m := mapAccumr₂ (fun x y (s₁, s₂) =>\n                let r₂ := f₂ x y s₂\n                let r₁ := f₁ r₂.snd y s₁\n                ((r₁.fst, r₂.fst), r₁.snd)\n              )\n            xs ys (s₁, s₂)\n    (m.fst.fst, m.snd) := by\n  induction xs, ys using Vector.revInductionOn₂ generalizing s₁ s₂ <;> simp_all\n\n"}
{"name":"List.Vector.mapAccumr₂_mapAccumr₂_right_left","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ₁ : Type u_6\nσ₂ : Type u_7\nφ : Type u_8\nn : Nat\ns₁ : σ₁\ns₂ : σ₂\nxs : List.Vector α n\nys : List.Vector β n\nf₁ : α → γ → σ₁ → Prod σ₁ φ\nf₂ : α → β → σ₂ → Prod σ₂ γ\n⊢ Eq (List.Vector.mapAccumr₂ f₁ xs (List.Vector.mapAccumr₂ f₂ xs ys s₂).2 s₁)\n    (let m :=\n      List.Vector.mapAccumr₂\n        (fun x y x_1 =>\n          List.Vector.mapAccumr₂_mapAccumr₂_left_left.match_1 (fun x => Prod (Prod σ₁ σ₂) φ) x_1 fun s₁ s₂ =>\n            let r₂ := f₂ x y s₂;\n            let r₁ := f₁ x r₂.2 s₁;\n            { fst := { fst := r₁.1, snd := r₂.1 }, snd := r₁.2 })\n        xs ys { fst := s₁, snd := s₂ };\n    { fst := m.1.1, snd := m.2 })","decl":"@[simp]\ntheorem mapAccumr₂_mapAccumr₂_right_left (f₁ : α → γ → σ₁ → σ₁ × φ) (f₂ : α → β → σ₂ → σ₂ × γ) :\n    (mapAccumr₂ f₁ xs (mapAccumr₂ f₂ xs ys s₂).snd s₁)\n    = let m := mapAccumr₂ (fun x y (s₁, s₂) =>\n                let r₂ := f₂ x y s₂\n                let r₁ := f₁ x r₂.snd s₁\n                ((r₁.fst, r₂.fst), r₁.snd)\n              )\n            xs ys (s₁, s₂)\n    (m.fst.fst, m.snd) := by\n  induction xs, ys using Vector.revInductionOn₂ generalizing s₁ s₂ <;> simp_all\n\n"}
{"name":"List.Vector.mapAccumr₂_mapAccumr₂_right_right","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ₁ : Type u_6\nσ₂ : Type u_7\nφ : Type u_8\nn : Nat\ns₁ : σ₁\ns₂ : σ₂\nxs : List.Vector α n\nys : List.Vector β n\nf₁ : β → γ → σ₁ → Prod σ₁ φ\nf₂ : α → β → σ₂ → Prod σ₂ γ\n⊢ Eq (List.Vector.mapAccumr₂ f₁ ys (List.Vector.mapAccumr₂ f₂ xs ys s₂).2 s₁)\n    (let m :=\n      List.Vector.mapAccumr₂\n        (fun x y x_1 =>\n          List.Vector.mapAccumr₂_mapAccumr₂_left_left.match_1 (fun x => Prod (Prod σ₁ σ₂) φ) x_1 fun s₁ s₂ =>\n            let r₂ := f₂ x y s₂;\n            let r₁ := f₁ y r₂.2 s₁;\n            { fst := { fst := r₁.1, snd := r₂.1 }, snd := r₁.2 })\n        xs ys { fst := s₁, snd := s₂ };\n    { fst := m.1.1, snd := m.2 })","decl":"@[simp]\ntheorem mapAccumr₂_mapAccumr₂_right_right (f₁ : β → γ → σ₁ → σ₁ × φ) (f₂ : α → β → σ₂ → σ₂ × γ) :\n    (mapAccumr₂ f₁ ys (mapAccumr₂ f₂ xs ys s₂).snd s₁)\n    = let m := mapAccumr₂ (fun x y (s₁, s₂) =>\n                let r₂ := f₂ x y s₂\n                let r₁ := f₁ y r₂.snd s₁\n                ((r₁.fst, r₂.fst), r₁.snd)\n              )\n            xs ys (s₁, s₂)\n    (m.fst.fst, m.snd) := by\n  induction xs, ys using Vector.revInductionOn₂ generalizing s₁ s₂ <;> simp_all\n\n"}
{"name":"List.Vector.mapAccumr_bisim","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nσ₁ : Type u_6\nσ₂ : Type u_7\nn : Nat\nxs : List.Vector α n\nf₁ : α → σ₁ → Prod σ₁ β\nf₂ : α → σ₂ → Prod σ₂ β\ns₁ : σ₁\ns₂ : σ₂\nR : σ₁ → σ₂ → Prop\nh₀ : R s₁ s₂\nhR : ∀ {s : σ₁} {q : σ₂} (a : α), R s q → And (R (f₁ a s).1 (f₂ a q).1) (Eq (f₁ a s).2 (f₂ a q).2)\n⊢ And (R (List.Vector.mapAccumr f₁ xs s₁).1 (List.Vector.mapAccumr f₂ xs s₂).1) (Eq (List.Vector.mapAccumr f₁ xs s₁).2 (List.Vector.mapAccumr f₂ xs s₂).2)","decl":"theorem mapAccumr_bisim {f₁ : α → σ₁ → σ₁ × β} {f₂ : α → σ₂ → σ₂ × β} {s₁ : σ₁} {s₂ : σ₂}\n    (R : σ₁ → σ₂ → Prop) (h₀ : R s₁ s₂)\n    (hR : ∀ {s q} a, R s q → R (f₁ a s).1 (f₂ a q).1 ∧ (f₁ a s).2 = (f₂ a q).2) :\n    R (mapAccumr f₁ xs s₁).fst (mapAccumr f₂ xs s₂).fst\n    ∧ (mapAccumr f₁ xs s₁).snd = (mapAccumr f₂ xs s₂).snd := by\n  induction xs using Vector.revInductionOn generalizing s₁ s₂\n  next => exact ⟨h₀, rfl⟩\n  next xs x ih =>\n    rcases (hR x h₀) with ⟨hR, _⟩\n    simp only [mapAccumr_snoc, ih hR, true_and]\n    congr 1\n\n"}
{"name":"List.Vector.mapAccumr_bisim_tail","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nσ₁ : Type u_6\nσ₂ : Type u_7\nn : Nat\nxs : List.Vector α n\nf₁ : α → σ₁ → Prod σ₁ β\nf₂ : α → σ₂ → Prod σ₂ β\ns₁ : σ₁\ns₂ : σ₂\nh : Exists fun R => And (R s₁ s₂) (∀ {s : σ₁} {q : σ₂} (a : α), R s q → And (R (f₁ a s).1 (f₂ a q).1) (Eq (f₁ a s).2 (f₂ a q).2))\n⊢ Eq (List.Vector.mapAccumr f₁ xs s₁).2 (List.Vector.mapAccumr f₂ xs s₂).2","decl":"theorem mapAccumr_bisim_tail {f₁ : α → σ₁ → σ₁ × β} {f₂ : α → σ₂ → σ₂ × β} {s₁ : σ₁} {s₂ : σ₂}\n    (h : ∃ R : σ₁ → σ₂ → Prop, R s₁ s₂ ∧\n      ∀ {s q} a, R s q → R (f₁ a s).1 (f₂ a q).1 ∧ (f₁ a s).2 = (f₂ a q).2) :\n    (mapAccumr f₁ xs s₁).snd = (mapAccumr f₂ xs s₂).snd := by\n  rcases h with ⟨R, h₀, hR⟩\n  exact (mapAccumr_bisim R h₀ hR).2\n\n"}
{"name":"List.Vector.mapAccumr₂_bisim","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ₁ : Type u_6\nσ₂ : Type u_7\nn : Nat\nxs : List.Vector α n\nys : List.Vector β n\nf₁ : α → β → σ₁ → Prod σ₁ γ\nf₂ : α → β → σ₂ → Prod σ₂ γ\ns₁ : σ₁\ns₂ : σ₂\nR : σ₁ → σ₂ → Prop\nh₀ : R s₁ s₂\nhR : ∀ {s : σ₁} {q : σ₂} (a : α) (b : β), R s q → And (R (f₁ a b s).1 (f₂ a b q).1) (Eq (f₁ a b s).2 (f₂ a b q).2)\n⊢ And (R (List.Vector.mapAccumr₂ f₁ xs ys s₁).1 (List.Vector.mapAccumr₂ f₂ xs ys s₂).1) (Eq (List.Vector.mapAccumr₂ f₁ xs ys s₁).2 (List.Vector.mapAccumr₂ f₂ xs ys s₂).2)","decl":"theorem mapAccumr₂_bisim {ys : Vector β n} {f₁ : α → β → σ₁ → σ₁ × γ}\n    {f₂ : α → β → σ₂ → σ₂ × γ} {s₁ : σ₁} {s₂ : σ₂}\n    (R : σ₁ → σ₂ → Prop) (h₀ : R s₁ s₂)\n    (hR :  ∀ {s q} a b, R s q → R (f₁ a b s).1 (f₂ a b q).1 ∧ (f₁ a b s).2 = (f₂ a b q).2) :\n    R (mapAccumr₂ f₁ xs ys s₁).1 (mapAccumr₂ f₂ xs ys s₂).1\n    ∧ (mapAccumr₂ f₁ xs ys s₁).2 = (mapAccumr₂ f₂ xs ys s₂).2 := by\n  induction xs, ys using Vector.revInductionOn₂ generalizing s₁ s₂\n  next => exact ⟨h₀, rfl⟩\n  next xs ys x y ih =>\n    rcases (hR x y h₀) with ⟨hR, _⟩\n    simp only [mapAccumr₂_snoc, ih hR, true_and]\n    congr 1\n\n"}
{"name":"List.Vector.mapAccumr₂_bisim_tail","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ₁ : Type u_6\nσ₂ : Type u_7\nn : Nat\nxs : List.Vector α n\nys : List.Vector β n\nf₁ : α → β → σ₁ → Prod σ₁ γ\nf₂ : α → β → σ₂ → Prod σ₂ γ\ns₁ : σ₁\ns₂ : σ₂\nh : Exists fun R => And (R s₁ s₂) (∀ {s : σ₁} {q : σ₂} (a : α) (b : β), R s q → And (R (f₁ a b s).1 (f₂ a b q).1) (Eq (f₁ a b s).2 (f₂ a b q).2))\n⊢ Eq (List.Vector.mapAccumr₂ f₁ xs ys s₁).2 (List.Vector.mapAccumr₂ f₂ xs ys s₂).2","decl":"theorem mapAccumr₂_bisim_tail {ys : Vector β n} {f₁ : α → β → σ₁ → σ₁ × γ}\n    {f₂ : α → β → σ₂ → σ₂ × γ} {s₁ : σ₁} {s₂ : σ₂}\n    (h : ∃ R : σ₁ → σ₂ → Prop, R s₁ s₂ ∧\n      ∀ {s q} a b, R s q → R (f₁ a b s).1 (f₂ a b q).1 ∧ (f₁ a b s).2 = (f₂ a b q).2) :\n    (mapAccumr₂ f₁ xs ys s₁).2 = (mapAccumr₂ f₂ xs ys s₂).2 := by\n  rcases h with ⟨R, h₀, hR⟩\n  exact (mapAccumr₂_bisim R h₀ hR).2\n\n"}
{"name":"List.Vector.map_eq_mapAccumr","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Nat\nxs : List.Vector α n\nf : α → β\n⊢ Eq (List.Vector.map f xs) (List.Vector.mapAccumr (fun x x_1 => { fst := Unit.unit, snd := f x }) xs Unit.unit).2","decl":"protected theorem map_eq_mapAccumr {f : α → β} :\n    map f xs = (mapAccumr (fun x (_ : Unit) ↦ ((), f x)) xs ()).snd := by\n  induction xs using Vector.revInductionOn <;> simp_all\n\n"}
{"name":"List.Vector.mapAccumr_eq_map","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_5\nn : Nat\nxs : List.Vector α n\nf : α → σ → Prod σ β\ns₀ : σ\nS : Set σ\nh₀ : Membership.mem S s₀\nclosure : ∀ (a : α) (s : σ), Membership.mem S s → Membership.mem S (f a s).1\nout : ∀ (a : α) (s s' : σ), Membership.mem S s → Membership.mem S s' → Eq (f a s).2 (f a s').2\n⊢ Eq (List.Vector.mapAccumr f xs s₀).2 (List.Vector.map (fun x => (f x s₀).2) xs)","decl":"/--\n  If there is a set of states that is closed under `f`, and such that `f` produces that same output\n  for all states in this set, then the state is not actually needed.\n  Hence, then we can rewrite `mapAccumr` into just `map`\n-/\ntheorem mapAccumr_eq_map {f : α → σ → σ × β} {s₀ : σ} (S : Set σ) (h₀ : s₀ ∈ S)\n    (closure : ∀ a s, s ∈ S → (f a s).1 ∈ S)\n    (out : ∀ a s s', s ∈ S → s' ∈ S → (f a s).2 = (f a s').2) :\n    (mapAccumr f xs s₀).snd = map (f · s₀ |>.snd) xs := by\n  rw [Vector.map_eq_mapAccumr]\n  apply mapAccumr_bisim_tail\n  use fun s _ => s ∈ S, h₀\n  exact @fun s _q a h => ⟨closure a s h, out a s s₀ h h₀⟩\n\n"}
{"name":"List.Vector.map₂_eq_mapAccumr₂","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nn : Nat\nxs : List.Vector α n\nys : List.Vector β n\nf : α → β → γ\n⊢ Eq (List.Vector.map₂ f xs ys) (List.Vector.mapAccumr₂ (fun x y x_1 => { fst := Unit.unit, snd := f x y }) xs ys Unit.unit).2","decl":"protected theorem map₂_eq_mapAccumr₂ {f : α → β → γ} :\n    map₂ f xs ys = (mapAccumr₂ (fun x y (_ : Unit) ↦ ((), f x y)) xs ys ()).snd := by\n  induction xs, ys using Vector.revInductionOn₂ <;> simp_all\n\n"}
{"name":"List.Vector.mapAccumr₂_eq_map₂","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ : Type u_5\nn : Nat\nxs : List.Vector α n\nys : List.Vector β n\nf : α → β → σ → Prod σ γ\ns₀ : σ\nS : Set σ\nh₀ : Membership.mem S s₀\nclosure : ∀ (a : α) (b : β) (s : σ), Membership.mem S s → Membership.mem S (f a b s).1\nout : ∀ (a : α) (b : β) (s s' : σ), Membership.mem S s → Membership.mem S s' → Eq (f a b s).2 (f a b s').2\n⊢ Eq (List.Vector.mapAccumr₂ f xs ys s₀).2 (List.Vector.map₂ (fun x1 x2 => (f x1 x2 s₀).2) xs ys)","decl":"/--\n  If there is a set of states that is closed under `f`, and such that `f` produces that same output\n  for all states in this set, then the state is not actually needed.\n  Hence, then we can rewrite `mapAccumr₂` into just `map₂`\n-/\ntheorem mapAccumr₂_eq_map₂ {f : α → β → σ → σ × γ} {s₀ : σ} (S : Set σ) (h₀ : s₀ ∈ S)\n    (closure : ∀ a b s, s ∈ S → (f a b s).1 ∈ S)\n    (out : ∀ a b s s', s ∈ S → s' ∈ S → (f a b s).2 = (f a b s').2) :\n    (mapAccumr₂ f xs ys s₀).snd = map₂ (f · · s₀ |>.snd) xs ys := by\n  rw [Vector.map₂_eq_mapAccumr₂]\n  apply mapAccumr₂_bisim_tail\n  use fun s _ => s ∈ S, h₀\n  exact @fun s _q a b h => ⟨closure a b s h, out a b s s₀ h h₀⟩\n\n"}
{"name":"List.Vector.mapAccumr_eq_map_of_constant_state","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_5\nn : Nat\nxs : List.Vector α n\nf : α → σ → Prod σ β\ns : σ\nh : ∀ (a : α), Eq (f a s).1 s\n⊢ Eq (List.Vector.mapAccumr f xs s) { fst := s, snd := List.Vector.map (fun x => (f x s).2) xs }","decl":"/--\n  If an accumulation function `f`, given an initial state `s`, produces `s` as its output state\n  for all possible input bits, then the state is redundant and can be optimized out\n-/\n@[simp]\ntheorem mapAccumr_eq_map_of_constant_state (f : α → σ → σ × β) (s : σ) (h : ∀ a, (f a s).fst = s) :\n    mapAccumr f xs s = (s, (map (fun x => (f x s).snd) xs)) := by\n  induction xs using revInductionOn <;> simp_all\n\n"}
{"name":"List.Vector.mapAccumr₂_eq_map₂_of_constant_state","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ : Type u_5\nn : Nat\nxs : List.Vector α n\nys : List.Vector β n\nf : α → β → σ → Prod σ γ\ns : σ\nh : ∀ (a : α) (b : β), Eq (f a b s).1 s\n⊢ Eq (List.Vector.mapAccumr₂ f xs ys s) { fst := s, snd := List.Vector.map₂ (fun x y => (f x y s).2) xs ys }","decl":"/--\n  If an accumulation function `f`, given an initial state `s`, produces `s` as its output state\n  for all possible input bits, then the state is redundant and can be optimized out\n-/\n@[simp]\ntheorem mapAccumr₂_eq_map₂_of_constant_state (f : α → β → σ → σ × γ) (s : σ)\n    (h : ∀ a b, (f a b s).fst = s) :\n    mapAccumr₂ f xs ys s = (s, (map₂ (fun x y => (f x y s).snd) xs ys)) := by\n  induction xs, ys using revInductionOn₂ <;> simp_all\n\n"}
{"name":"List.Vector.mapAccumr_eq_map_of_unused_state","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_5\nn : Nat\nxs : List.Vector α n\nf : α → σ → Prod σ β\ns : σ\nh : ∀ (a : α) (s s' : σ), Eq (f a s).2 (f a s').2\n⊢ Eq (List.Vector.mapAccumr f xs s).2 (List.Vector.map (fun x => (f x s).2) xs)","decl":"/--\n  If an accumulation function `f`, produces the same output bits regardless of accumulation state,\n  then the state is redundant and can be optimized out\n-/\n@[simp]\ntheorem mapAccumr_eq_map_of_unused_state (f : α → σ → σ × β) (s : σ)\n    (h : ∀ a s s', (f a s).snd = (f a s').snd) :\n    (mapAccumr f xs s).snd = (map (fun x => (f x s).snd) xs) :=\n  mapAccumr_eq_map (fun _ => true) rfl (fun _ _ _ => rfl) (fun a s s' _ _ => h a s s')\n\n\n"}
{"name":"List.Vector.mapAccumr₂_eq_map₂_of_unused_state","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ : Type u_5\nn : Nat\nxs : List.Vector α n\nys : List.Vector β n\nf : α → β → σ → Prod σ γ\ns : σ\nh : ∀ (a : α) (b : β) (s s' : σ), Eq (f a b s).2 (f a b s').2\n⊢ Eq (List.Vector.mapAccumr₂ f xs ys s).2 (List.Vector.map₂ (fun x y => (f x y s).2) xs ys)","decl":"/--\n  If an accumulation function `f`, produces the same output bits regardless of accumulation state,\n  then the state is redundant and can be optimized out\n-/\n@[simp]\ntheorem mapAccumr₂_eq_map₂_of_unused_state (f : α → β → σ → σ × γ) (s : σ)\n    (h : ∀ a b s s', (f a b s).snd = (f a b s').snd) :\n    (mapAccumr₂ f xs ys s).snd = (map₂ (fun x y => (f x y s).snd) xs ys) :=\n  mapAccumr₂_eq_map₂ (fun _ => true) rfl (fun _ _ _ _ => rfl) (fun a b s s' _ _ => h a b s s')\n\n\n"}
{"name":"List.Vector.mapAccumr_redundant_pair","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_5\nn : Nat\ns : σ\nxs : List.Vector α n\nf : α → Prod σ σ → Prod (Prod σ σ) β\nh : ∀ (x : α) (s : σ), Eq (f x { fst := s, snd := s }).1.1 (f x { fst := s, snd := s }).1.2\n⊢ Eq (List.Vector.mapAccumr f xs { fst := s, snd := s }).2 (List.Vector.mapAccumr (fun x s => { fst := (f x { fst := s, snd := s }).1.1, snd := (f x { fst := s, snd := s }).2 }) xs s).2","decl":"/-- If `f` takes a pair of states, but always returns the same value for both elements of the\n    pair, then we can simplify to just a single element of state\n  -/\n@[simp]\ntheorem mapAccumr_redundant_pair (f : α → (σ × σ) → (σ × σ) × β)\n    (h : ∀ x s, (f x (s, s)).fst.fst = (f x (s, s)).fst.snd) :\n    (mapAccumr f xs (s, s)).snd = (mapAccumr (fun x (s : σ) =>\n      (f x (s, s) |>.fst.fst, f x (s, s) |>.snd)\n    ) xs s).snd :=\n  mapAccumr_bisim_tail <| by\n    use fun (s₁, s₂) s => s₂ = s ∧ s₁ = s\n    simp_all\n\n"}
{"name":"List.Vector.mapAccumr₂_redundant_pair","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ : Type u_5\nn : Nat\ns : σ\nxs : List.Vector α n\nys : List.Vector β n\nf : α → β → Prod σ σ → Prod (Prod σ σ) γ\nh :\n  ∀ (x : α) (y : β) (s : σ),\n    let s' := (f x y { fst := s, snd := s }).1;\n    Eq s'.1 s'.2\n⊢ Eq (List.Vector.mapAccumr₂ f xs ys { fst := s, snd := s }).2 (List.Vector.mapAccumr₂ (fun x y s => { fst := (f x y { fst := s, snd := s }).1.1, snd := (f x y { fst := s, snd := s }).2 }) xs ys s).2","decl":"/-- If `f` takes a pair of states, but always returns the same value for both elements of the\n    pair, then we can simplify to just a single element of state\n  -/\n@[simp]\ntheorem mapAccumr₂_redundant_pair (f : α → β → (σ × σ) → (σ × σ) × γ)\n    (h : ∀ x y s, let s' := (f x y (s, s)).fst; s'.fst = s'.snd) :\n    (mapAccumr₂ f xs ys (s, s)).snd = (mapAccumr₂ (fun x y (s : σ) =>\n      (f x y (s, s) |>.fst.fst, f x y (s, s) |>.snd)\n    ) xs ys s).snd :=\n  mapAccumr₂_bisim_tail <| by\n    use fun (s₁, s₂) s => s₂ = s ∧ s₁ = s\n    simp_all\n\n"}
{"name":"List.Vector.mapAccumr₂_unused_input_left","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ : Type u_5\nn : Nat\ns : σ\nxs : List.Vector α n\nys : List.Vector β n\ninst✝ : Inhabited α\nf : α → β → σ → Prod σ γ\nh : ∀ (a : α) (b : β) (s : σ), Eq (f Inhabited.default b s) (f a b s)\n⊢ Eq (List.Vector.mapAccumr₂ f xs ys s) (List.Vector.mapAccumr (fun b s => f Inhabited.default b s) ys s)","decl":"/--\n  If `f` returns the same output and next state for every value of it's first argument, then\n  `xs : Vector` is ignored, and we can rewrite `mapAccumr₂` into `map`\n-/\n@[simp]\ntheorem mapAccumr₂_unused_input_left [Inhabited α] (f : α → β → σ → σ × γ)\n    (h : ∀ a b s, f default b s = f a b s) :\n    mapAccumr₂ f xs ys s = mapAccumr (fun b s => f default b s) ys s := by\n  induction xs, ys using Vector.revInductionOn₂ generalizing s with\n  | nil => rfl\n  | snoc xs ys x y ih => simp [h x y s, ih]\n\n"}
{"name":"List.Vector.mapAccumr₂_unused_input_right","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ : Type u_5\nn : Nat\ns : σ\nxs : List.Vector α n\nys : List.Vector β n\ninst✝ : Inhabited β\nf : α → β → σ → Prod σ γ\nh : ∀ (a : α) (b : β) (s : σ), Eq (f a Inhabited.default s) (f a b s)\n⊢ Eq (List.Vector.mapAccumr₂ f xs ys s) (List.Vector.mapAccumr (fun a s => f a Inhabited.default s) xs s)","decl":"/--\n  If `f` returns the same output and next state for every value of it's second argument, then\n  `ys : Vector` is ignored, and we can rewrite `mapAccumr₂` into `map`\n-/\n@[simp]\ntheorem mapAccumr₂_unused_input_right [Inhabited β] (f : α → β → σ → σ × γ)\n    (h : ∀ a b s, f a default s = f a b s) :\n    mapAccumr₂ f xs ys s = mapAccumr (fun a s => f a default s) xs s := by\n  induction xs, ys using Vector.revInductionOn₂ generalizing s with\n  | nil => rfl\n  | snoc xs ys x y ih => simp [h x y s, ih]\n\n"}
{"name":"List.Vector.map₂_comm","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Nat\nxs ys : List.Vector α n\nf : α → α → β\ncomm : ∀ (a₁ a₂ : α), Eq (f a₁ a₂) (f a₂ a₁)\n⊢ Eq (List.Vector.map₂ f xs ys) (List.Vector.map₂ f ys xs)","decl":"theorem map₂_comm (f : α → α → β) (comm : ∀ a₁ a₂, f a₁ a₂ = f a₂ a₁) :\n    map₂ f xs ys = map₂ f ys xs := by\n  induction xs, ys using Vector.inductionOn₂ <;> simp_all\n\n"}
{"name":"List.Vector.mapAccumr₂_comm","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nγ : Type u_3\nσ : Type u_5\nn : Nat\ns : σ\nxs ys : List.Vector α n\nf : α → α → σ → Prod σ γ\ncomm : ∀ (a₁ a₂ : α) (s : σ), Eq (f a₁ a₂ s) (f a₂ a₁ s)\n⊢ Eq (List.Vector.mapAccumr₂ f xs ys s) (List.Vector.mapAccumr₂ f ys xs s)","decl":"theorem mapAccumr₂_comm (f : α → α → σ → σ × γ) (comm : ∀ a₁ a₂ s, f a₁ a₂ s = f a₂ a₁ s) :\n    mapAccumr₂ f xs ys s = mapAccumr₂ f ys xs s := by\n  induction xs, ys using Vector.inductionOn₂ generalizing s <;> simp_all\n\n"}
{"name":"List.Vector.map₂_flip","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nn : Nat\nxs : List.Vector α n\nys : List.Vector β n\nf : α → β → γ\n⊢ Eq (List.Vector.map₂ f xs ys) (List.Vector.map₂ (flip f) ys xs)","decl":"theorem map₂_flip (f : α → β → γ) :\n    map₂ f xs ys = map₂ (flip f) ys xs := by\n  induction xs, ys using Vector.inductionOn₂ <;> simp_all[flip]\n\n"}
{"name":"List.Vector.mapAccumr₂_flip","module":"Mathlib.Data.Vector.MapLemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ : Type u_5\nn : Nat\ns : σ\nxs : List.Vector α n\nys : List.Vector β n\nf : α → β → σ → Prod σ γ\n⊢ Eq (List.Vector.mapAccumr₂ f xs ys s) (List.Vector.mapAccumr₂ (flip f) ys xs s)","decl":"theorem mapAccumr₂_flip (f : α → β → σ → σ × γ) :\n    mapAccumr₂ f xs ys s = mapAccumr₂ (flip f) ys xs s := by\n  induction xs, ys using Vector.inductionOn₂ <;> simp_all[flip]\n\n"}
