{"name":"FirstOrder.Language.ElementaryEmbedding.map_formula'","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nself : L.ElementaryEmbedding M N\nn : Nat\nφ : L.Formula (Fin n)\nx : Fin n → M\n⊢ Iff (φ.Realize (Function.comp self.toFun x)) (φ.Realize x)","decl":"/-- An elementary embedding of first-order structures is an embedding that commutes with the\n  realizations of formulas. -/\nstructure ElementaryEmbedding where\n  toFun : M → N\n  -- Porting note:\n  -- The autoparam here used to be `obviously`. We would like to replace it with `aesop`\n  -- but that isn't currently sufficient.\n  -- See https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Aesop.20and.20cases\n  -- If that can be improved, we should change this to `by aesop` and remove the proofs below.\n  map_formula' :\n    ∀ ⦃n⦄ (φ : L.Formula (Fin n)) (x : Fin n → M), φ.Realize (toFun ∘ x) ↔ φ.Realize x := by\n    intros; trivial\n\n"}
{"name":"FirstOrder.Language.ElementaryEmbedding.mk.injEq","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\ntoFun✝ : M → N\nmap_formula'✝ : autoParam (∀ ⦃n : Nat⦄ (φ : L.Formula (Fin n)) (x : Fin n → M), Iff (φ.Realize (Function.comp toFun✝ x)) (φ.Realize x)) _auto✝\ntoFun : M → N\nmap_formula' : autoParam (∀ ⦃n : Nat⦄ (φ : L.Formula (Fin n)) (x : Fin n → M), Iff (φ.Realize (Function.comp toFun x)) (φ.Realize x)) _auto✝\n⊢ Eq (Eq { toFun := toFun✝, map_formula' := map_formula'✝ } { toFun := toFun, map_formula' := map_formula' }) (Eq toFun✝ toFun)","decl":"/-- An elementary embedding of first-order structures is an embedding that commutes with the\n  realizations of formulas. -/\nstructure ElementaryEmbedding where\n  toFun : M → N\n  -- Porting note:\n  -- The autoparam here used to be `obviously`. We would like to replace it with `aesop`\n  -- but that isn't currently sufficient.\n  -- See https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Aesop.20and.20cases\n  -- If that can be improved, we should change this to `by aesop` and remove the proofs below.\n  map_formula' :\n    ∀ ⦃n⦄ (φ : L.Formula (Fin n)) (x : Fin n → M), φ.Realize (toFun ∘ x) ↔ φ.Realize x := by\n    intros; trivial\n\n"}
{"name":"FirstOrder.Language.ElementaryEmbedding.mk.sizeOf_spec","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝³ : L.Structure M\ninst✝² : L.Structure N\ninst✝¹ : SizeOf M\ninst✝ : SizeOf N\ntoFun : M → N\nmap_formula' : autoParam (∀ ⦃n : Nat⦄ (φ : L.Formula (Fin n)) (x : Fin n → M), Iff (φ.Realize (Function.comp toFun x)) (φ.Realize x)) _auto✝\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, map_formula' := map_formula' }) 1","decl":"/-- An elementary embedding of first-order structures is an embedding that commutes with the\n  realizations of formulas. -/\nstructure ElementaryEmbedding where\n  toFun : M → N\n  -- Porting note:\n  -- The autoparam here used to be `obviously`. We would like to replace it with `aesop`\n  -- but that isn't currently sufficient.\n  -- See https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Aesop.20and.20cases\n  -- If that can be improved, we should change this to `by aesop` and remove the proofs below.\n  map_formula' :\n    ∀ ⦃n⦄ (φ : L.Formula (Fin n)) (x : Fin n → M), φ.Realize (toFun ∘ x) ↔ φ.Realize x := by\n    intros; trivial\n\n"}
{"name":"FirstOrder.Language.ElementaryEmbedding.mk.inj","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\ntoFun✝ : M → N\nmap_formula'✝ : autoParam (∀ ⦃n : Nat⦄ (φ : L.Formula (Fin n)) (x : Fin n → M), Iff (φ.Realize (Function.comp toFun✝ x)) (φ.Realize x)) _auto✝\ntoFun : M → N\nmap_formula' : autoParam (∀ ⦃n : Nat⦄ (φ : L.Formula (Fin n)) (x : Fin n → M), Iff (φ.Realize (Function.comp toFun x)) (φ.Realize x)) _auto✝\nx✝ : Eq { toFun := toFun✝, map_formula' := map_formula'✝ } { toFun := toFun, map_formula' := map_formula' }\n⊢ Eq toFun✝ toFun","decl":"/-- An elementary embedding of first-order structures is an embedding that commutes with the\n  realizations of formulas. -/\nstructure ElementaryEmbedding where\n  toFun : M → N\n  -- Porting note:\n  -- The autoparam here used to be `obviously`. We would like to replace it with `aesop`\n  -- but that isn't currently sufficient.\n  -- See https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Aesop.20and.20cases\n  -- If that can be improved, we should change this to `by aesop` and remove the proofs below.\n  map_formula' :\n    ∀ ⦃n⦄ (φ : L.Formula (Fin n)) (x : Fin n → M), φ.Realize (toFun ∘ x) ↔ φ.Realize x := by\n    intros; trivial\n\n"}
{"name":"FirstOrder.Language.ElementaryEmbedding.map_boundedFormula","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.ElementaryEmbedding M N\nα : Type u_5\nn : Nat\nφ : L.BoundedFormula α n\nv : α → M\nxs : Fin n → M\n⊢ Iff (φ.Realize (Function.comp (⇑f) v) (Function.comp (⇑f) xs)) (φ.Realize v xs)","decl":"@[simp]\ntheorem map_boundedFormula (f : M ↪ₑ[L] N) {α : Type*} {n : ℕ} (φ : L.BoundedFormula α n)\n    (v : α → M) (xs : Fin n → M) : φ.Realize (f ∘ v) (f ∘ xs) ↔ φ.Realize v xs := by\n  classical\n    rw [← BoundedFormula.realize_restrictFreeVar' Set.Subset.rfl, Set.inclusion_eq_id, iff_eq_eq]\n    have h :=\n      f.map_formula' ((φ.restrictFreeVar id).toFormula.relabel (Fintype.equivFin _))\n        (Sum.elim (v ∘ (↑)) xs ∘ (Fintype.equivFin _).symm)\n    simp only [Formula.realize_relabel, BoundedFormula.realize_toFormula, iff_eq_eq] at h\n    rw [← Function.comp_assoc _ _ (Fintype.equivFin _).symm,\n      Function.comp_assoc _ (Fintype.equivFin _).symm (Fintype.equivFin _),\n      _root_.Equiv.symm_comp_self, Function.comp_id, Function.comp_assoc, Sum.elim_comp_inl,\n      Function.comp_assoc _ _ Sum.inr, Sum.elim_comp_inr, ← Function.comp_assoc] at h\n    refine h.trans ?_\n    erw [Function.comp_assoc _ _ (Fintype.equivFin _), _root_.Equiv.symm_comp_self,\n      Function.comp_id, Sum.elim_comp_inl, Sum.elim_comp_inr (v ∘ Subtype.val) xs,\n      ← Set.inclusion_eq_id (s := (BoundedFormula.freeVarFinset φ : Set α)) Set.Subset.rfl,\n      BoundedFormula.realize_restrictFreeVar' Set.Subset.rfl]\n\n"}
{"name":"FirstOrder.Language.ElementaryEmbedding.map_formula","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.ElementaryEmbedding M N\nα : Type u_5\nφ : L.Formula α\nx : α → M\n⊢ Iff (φ.Realize (Function.comp (⇑f) x)) (φ.Realize x)","decl":"@[simp]\ntheorem map_formula (f : M ↪ₑ[L] N) {α : Type*} (φ : L.Formula α) (x : α → M) :\n    φ.Realize (f ∘ x) ↔ φ.Realize x := by\n  rw [Formula.Realize, Formula.Realize, ← f.map_boundedFormula, Unique.eq_default (f ∘ default)]\n\n"}
{"name":"FirstOrder.Language.ElementaryEmbedding.map_sentence","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.ElementaryEmbedding M N\nφ : L.Sentence\n⊢ Iff (FirstOrder.Language.Sentence.Realize M φ) (FirstOrder.Language.Sentence.Realize N φ)","decl":"theorem map_sentence (f : M ↪ₑ[L] N) (φ : L.Sentence) : M ⊨ φ ↔ N ⊨ φ := by\n  rw [Sentence.Realize, Sentence.Realize, ← f.map_formula, Unique.eq_default (f ∘ default)]\n\n"}
{"name":"FirstOrder.Language.ElementaryEmbedding.theory_model_iff","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.ElementaryEmbedding M N\nT : L.Theory\n⊢ Iff (FirstOrder.Language.Theory.Model M T) (FirstOrder.Language.Theory.Model N T)","decl":"theorem theory_model_iff (f : M ↪ₑ[L] N) (T : L.Theory) : M ⊨ T ↔ N ⊨ T := by\n  simp only [Theory.model_iff, f.map_sentence]\n\n"}
{"name":"FirstOrder.Language.ElementaryEmbedding.elementarilyEquivalent","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.ElementaryEmbedding M N\n⊢ L.ElementarilyEquivalent M N","decl":"theorem elementarilyEquivalent (f : M ↪ₑ[L] N) : M ≅[L] N :=\n  elementarilyEquivalent_iff.2 f.map_sentence\n\n"}
{"name":"FirstOrder.Language.ElementaryEmbedding.injective","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nφ : L.ElementaryEmbedding M N\n⊢ Function.Injective ⇑φ","decl":"@[simp]\ntheorem injective (φ : M ↪ₑ[L] N) : Function.Injective φ := by\n  intro x y\n  have h :=\n    φ.map_formula ((var 0).equal (var 1) : L.Formula (Fin 2)) fun i => if i = 0 then x else y\n  rw [Formula.realize_equal, Formula.realize_equal] at h\n  simp only [Nat.one_ne_zero, Term.realize, Fin.one_eq_zero_iff, if_true, eq_self_iff_true,\n    Function.comp_apply, if_false] at h\n  exact h.1\n\n"}
{"name":"FirstOrder.Language.ElementaryEmbedding.embeddingLike","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\n⊢ EmbeddingLike (L.ElementaryEmbedding M N) M N","decl":"instance embeddingLike : EmbeddingLike (M ↪ₑ[L] N) M N :=\n  { show FunLike (M ↪ₑ[L] N) M N from inferInstance with injective' := injective }\n\n"}
{"name":"FirstOrder.Language.ElementaryEmbedding.map_fun","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nφ : L.ElementaryEmbedding M N\nn : Nat\nf : L.Functions n\nx : Fin n → M\n⊢ Eq (φ (FirstOrder.Language.Structure.funMap f x)) (FirstOrder.Language.Structure.funMap f (Function.comp (⇑φ) x))","decl":"@[simp]\ntheorem map_fun (φ : M ↪ₑ[L] N) {n : ℕ} (f : L.Functions n) (x : Fin n → M) :\n    φ (funMap f x) = funMap f (φ ∘ x) := by\n  have h := φ.map_formula (Formula.graph f) (Fin.cons (funMap f x) x)\n  rw [Formula.realize_graph, Fin.comp_cons, Formula.realize_graph] at h\n  rw [eq_comm, h]\n\n"}
{"name":"FirstOrder.Language.ElementaryEmbedding.map_rel","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nφ : L.ElementaryEmbedding M N\nn : Nat\nr : L.Relations n\nx : Fin n → M\n⊢ Iff (FirstOrder.Language.Structure.RelMap r (Function.comp (⇑φ) x)) (FirstOrder.Language.Structure.RelMap r x)","decl":"@[simp]\ntheorem map_rel (φ : M ↪ₑ[L] N) {n : ℕ} (r : L.Relations n) (x : Fin n → M) :\n    RelMap r (φ ∘ x) ↔ RelMap r x :=\n  haveI h := φ.map_formula (r.formula var) x\n  h\n\n"}
{"name":"FirstOrder.Language.ElementaryEmbedding.strongHomClass","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\n⊢ L.StrongHomClass (L.ElementaryEmbedding M N) M N","decl":"instance strongHomClass : StrongHomClass L (M ↪ₑ[L] N) M N where\n  map_fun := map_fun\n  map_rel := map_rel\n\n"}
{"name":"FirstOrder.Language.ElementaryEmbedding.map_constants","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nφ : L.ElementaryEmbedding M N\nc : L.Constants\n⊢ Eq (φ ↑c) ↑c","decl":"@[simp]\ntheorem map_constants (φ : M ↪ₑ[L] N) (c : L.Constants) : φ c = c :=\n  HomClass.map_constants φ c\n\n"}
{"name":"FirstOrder.Language.ElementaryEmbedding.toEmbedding_toHom","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.ElementaryEmbedding M N\n⊢ Eq f.toEmbedding.toHom f.toHom","decl":"@[simp]\ntheorem toEmbedding_toHom (f : M ↪ₑ[L] N) : f.toEmbedding.toHom = f.toHom :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.ElementaryEmbedding.coe_toHom","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.ElementaryEmbedding M N\n⊢ Eq ⇑f.toHom ⇑f","decl":"@[simp]\ntheorem coe_toHom {f : M ↪ₑ[L] N} : (f.toHom : M → N) = (f : M → N) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.ElementaryEmbedding.coe_toEmbedding","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.ElementaryEmbedding M N\n⊢ Eq ⇑f.toEmbedding ⇑f","decl":"@[simp]\ntheorem coe_toEmbedding (f : M ↪ₑ[L] N) : (f.toEmbedding : M → N) = (f : M → N) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.ElementaryEmbedding.coe_injective","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\n⊢ Function.Injective DFunLike.coe","decl":"theorem coe_injective : @Function.Injective (M ↪ₑ[L] N) (M → N) (↑) :=\n  DFunLike.coe_injective\n\n"}
{"name":"FirstOrder.Language.ElementaryEmbedding.ext_iff","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf g : L.ElementaryEmbedding M N\n⊢ Iff (Eq f g) (∀ (x : M), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext ⦃f g : M ↪ₑ[L] N⦄ (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"FirstOrder.Language.ElementaryEmbedding.ext","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf g : L.ElementaryEmbedding M N\nh : ∀ (x : M), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext ⦃f g : M ↪ₑ[L] N⦄ (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"FirstOrder.Language.ElementaryEmbedding.refl_apply","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nx : M\n⊢ Eq ((FirstOrder.Language.ElementaryEmbedding.refl L M) x) x","decl":"@[simp]\ntheorem refl_apply (x : M) : refl L M x = x :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.ElementaryEmbedding.comp_apply","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\ninst✝ : L.Structure P\ng : L.ElementaryEmbedding N P\nf : L.ElementaryEmbedding M N\nx : M\n⊢ Eq ((g.comp f) x) (g (f x))","decl":"@[simp]\ntheorem comp_apply (g : N ↪ₑ[L] P) (f : M ↪ₑ[L] N) (x : M) : g.comp f x = g (f x) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.ElementaryEmbedding.comp_assoc","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\nP : Type u_3\nQ : Type u_4\ninst✝³ : L.Structure M\ninst✝² : L.Structure N\ninst✝¹ : L.Structure P\ninst✝ : L.Structure Q\nf : L.ElementaryEmbedding M N\ng : L.ElementaryEmbedding N P\nh : L.ElementaryEmbedding P Q\n⊢ Eq ((h.comp g).comp f) (h.comp (g.comp f))","decl":"/-- Composition of elementary embeddings is associative. -/\ntheorem comp_assoc (f : M ↪ₑ[L] N) (g : N ↪ₑ[L] P) (h : P ↪ₑ[L] Q) :\n    (h.comp g).comp f = h.comp (g.comp f) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.ElementaryEmbedding.ofModelsElementaryDiagram_toFun","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝⁴ : L.Structure M\nN : Type u_5\ninst✝³ : L.Structure N\ninst✝² : (L.withConstants M).Structure N\ninst✝¹ : (L.lhomWithConstants M).IsExpansionOn N\ninst✝ : FirstOrder.Language.Theory.Model N (L.elementaryDiagram M)\na✝ : M\n⊢ Eq ((FirstOrder.Language.ElementaryEmbedding.ofModelsElementaryDiagram L M N) a✝) (Function.comp FirstOrder.Language.constantMap Sum.inr a✝)","decl":"/-- The canonical elementary embedding of an `L`-structure into any model of its elementary diagram\n-/\n@[simps]\ndef ElementaryEmbedding.ofModelsElementaryDiagram (N : Type*) [L.Structure N] [L[[M]].Structure N]\n    [(lhomWithConstants L M).IsExpansionOn N] [N ⊨ L.elementaryDiagram M] : M ↪ₑ[L] N :=\n  ⟨((↑) : L[[M]].Constants → N) ∘ Sum.inr, fun n φ x => by\n    refine\n      _root_.trans ?_\n        ((realize_iff_of_model_completeTheory M N\n              (((L.lhomWithConstants M).onBoundedFormula φ).subst\n                  (Constants.term ∘ Sum.inr ∘ x)).alls).trans\n          ?_)\n    · simp_rw [Sentence.Realize, BoundedFormula.realize_alls, BoundedFormula.realize_subst,\n        LHom.realize_onBoundedFormula, Formula.Realize, Unique.forall_iff, Function.comp_def,\n        Term.realize_constants]\n    · simp_rw [Sentence.Realize, BoundedFormula.realize_alls, BoundedFormula.realize_subst,\n        LHom.realize_onBoundedFormula, Formula.Realize, Unique.forall_iff]\n      rfl⟩\n\n"}
{"name":"FirstOrder.Language.Embedding.isElementary_of_exists","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Embedding M N\nhtv : ∀ (n : Nat) (φ : L.BoundedFormula Empty (HAdd.hAdd n 1)) (x : Fin n → M) (a : N), φ.Realize Inhabited.default (Fin.snoc (Function.comp (⇑f) x) a) → Exists fun b => φ.Realize Inhabited.default (Fin.snoc (Function.comp (⇑f) x) (f b))\nn : Nat\nφ : L.Formula (Fin n)\nx : Fin n → M\n⊢ Iff (φ.Realize (Function.comp (⇑f) x)) (φ.Realize x)","decl":"/-- The **Tarski-Vaught test** for elementarity of an embedding. -/\ntheorem isElementary_of_exists (f : M ↪[L] N)\n    (htv :\n      ∀ (n : ℕ) (φ : L.BoundedFormula Empty (n + 1)) (x : Fin n → M) (a : N),\n        φ.Realize default (Fin.snoc (f ∘ x) a : _ → N) →\n          ∃ b : M, φ.Realize default (Fin.snoc (f ∘ x) (f b) : _ → N)) :\n    ∀ {n} (φ : L.Formula (Fin n)) (x : Fin n → M), φ.Realize (f ∘ x) ↔ φ.Realize x := by\n  suffices h : ∀ (n : ℕ) (φ : L.BoundedFormula Empty n) (xs : Fin n → M),\n      φ.Realize (f ∘ default) (f ∘ xs) ↔ φ.Realize default xs by\n    intro n φ x\n    exact φ.realize_relabel_sum_inr.symm.trans (_root_.trans (h n _ _) φ.realize_relabel_sum_inr)\n  refine fun n φ => φ.recOn ?_ ?_ ?_ ?_ ?_\n  · exact fun {_} _ => Iff.rfl\n  · intros\n    simp [BoundedFormula.Realize, ← Sum.comp_elim, HomClass.realize_term]\n  · intros\n    simp only [BoundedFormula.Realize, ← Sum.comp_elim, HomClass.realize_term]\n    erw [map_rel f]\n  · intro _ _ _ ih1 ih2 _\n    simp [ih1, ih2]\n  · intro n φ ih xs\n    simp only [BoundedFormula.realize_all]\n    refine ⟨fun h a => ?_, ?_⟩\n    · rw [← ih, Fin.comp_snoc]\n      exact h (f a)\n    · contrapose!\n      rintro ⟨a, ha⟩\n      obtain ⟨b, hb⟩ := htv n φ.not xs a (by\n          rw [BoundedFormula.realize_not, ← Unique.eq_default (f ∘ default)]\n          exact ha)\n      refine ⟨b, fun h => hb (Eq.mp ?_ ((ih _).2 h))⟩\n      rw [Unique.eq_default (f ∘ default), Fin.comp_snoc]\n\n"}
{"name":"FirstOrder.Language.Embedding.toElementaryEmbedding_toFun","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Embedding M N\nhtv : ∀ (n : Nat) (φ : L.BoundedFormula Empty (HAdd.hAdd n 1)) (x : Fin n → M) (a : N), φ.Realize Inhabited.default (Fin.snoc (Function.comp (⇑f) x) a) → Exists fun b => φ.Realize Inhabited.default (Fin.snoc (Function.comp (⇑f) x) (f b))\na : M\n⊢ Eq ((f.toElementaryEmbedding htv) a) (f a)","decl":"/-- Bundles an embedding satisfying the Tarski-Vaught test as an elementary embedding. -/\n@[simps]\ndef toElementaryEmbedding (f : M ↪[L] N)\n    (htv :\n      ∀ (n : ℕ) (φ : L.BoundedFormula Empty (n + 1)) (x : Fin n → M) (a : N),\n        φ.Realize default (Fin.snoc (f ∘ x) a : _ → N) →\n          ∃ b : M, φ.Realize default (Fin.snoc (f ∘ x) (f b) : _ → N)) :\n    M ↪ₑ[L] N :=\n  ⟨f, fun _ => f.isElementary_of_exists htv⟩\n\n"}
{"name":"FirstOrder.Language.Equiv.toElementaryEmbedding_toEmbedding","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Equiv M N\n⊢ Eq f.toElementaryEmbedding.toEmbedding f.toEmbedding","decl":"@[simp]\ntheorem toElementaryEmbedding_toEmbedding (f : M ≃[L] N) :\n    f.toElementaryEmbedding.toEmbedding = f.toEmbedding :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Equiv.coe_toElementaryEmbedding","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Equiv M N\n⊢ Eq ⇑f.toElementaryEmbedding ⇑f","decl":"@[simp]\ntheorem coe_toElementaryEmbedding (f : M ≃[L] N) :\n    (f.toElementaryEmbedding : M → N) = (f : M → N) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.realize_term_substructure","module":"Mathlib.ModelTheory.ElementaryMaps","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nα : Type u_5\nS : L.Substructure M\nv : α → Subtype fun x => Membership.mem S x\nt : L.Term α\n⊢ Eq (FirstOrder.Language.Term.realize (Function.comp Subtype.val v) t) ↑(FirstOrder.Language.Term.realize v t)","decl":"@[simp]\ntheorem realize_term_substructure {α : Type*} {S : L.Substructure M} (v : α → S) (t : L.Term α) :\n    t.realize ((↑) ∘ v) = (↑(t.realize v) : M) :=\n  HomClass.realize_term S.subtype\n\n"}
