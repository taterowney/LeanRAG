{"name":"PSet.rank_congr","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"x y : PSet.{u_1}\na✝ : x.Equiv y\n⊢ Eq x.rank y.rank","decl":"theorem rank_congr : ∀ {x y : PSet}, Equiv x y → rank x = rank y\n  | ⟨_, _⟩, ⟨_, _⟩, ⟨αβ, βα⟩ => by\n    apply congr_arg sSup\n    ext\n    constructor <;> simp <;> intro a h\n    · obtain ⟨b, h'⟩ := αβ a\n      exists b\n      rw [← h, rank_congr h']\n    · obtain ⟨b, h'⟩ := βα a\n      exists b\n      rw [← h, rank_congr h']\n\n"}
{"name":"PSet.rank_lt_of_mem","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"x y : PSet.{u_1}\na✝ : Membership.mem x y\n⊢ LT.lt y.rank x.rank","decl":"theorem rank_lt_of_mem : ∀ {x y : PSet}, y ∈ x → rank y < rank x\n  | ⟨_, _⟩, _, ⟨_, h⟩ => by\n    rw [rank_congr h, ← succ_le_iff]\n    apply Ordinal.le_iSup\n\n"}
{"name":"PSet.rank_le_iff","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"o : Ordinal.{u_1}\nx : PSet.{u_1}\n⊢ Iff (LE.le x.rank o) (∀ ⦃y : PSet.{u_1}⦄, Membership.mem x y → LT.lt y.rank o)","decl":"theorem rank_le_iff {o : Ordinal} : ∀ {x : PSet}, rank x ≤ o ↔ ∀ ⦃y⦄, y ∈ x → rank y < o\n  | ⟨_, A⟩ => by\n    refine ⟨fun h _ h' => (rank_lt_of_mem h').trans_le h, fun h ↦ Ordinal.iSup_le fun a ↦ ?_⟩\n    rw [succ_le_iff]\n    exact h (Mem.mk A a)\n\n"}
{"name":"PSet.lt_rank_iff","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"o : Ordinal.{u_1}\nx : PSet.{u_1}\n⊢ Iff (LT.lt o x.rank) (Exists fun y => And (Membership.mem x y) (LE.le o y.rank))","decl":"theorem lt_rank_iff {o : Ordinal} {x : PSet} : o < rank x ↔ ∃ y ∈ x, o ≤ rank y := by\n  rw [← not_iff_not, not_lt, rank_le_iff]\n  simp\n\n"}
{"name":"PSet.rank_mono","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"x y : PSet.{u}\nh : HasSubset.Subset x y\n⊢ LE.le x.rank y.rank","decl":"@[gcongr] theorem rank_mono (h : x ⊆ y) : rank x ≤ rank y :=\n  rank_le_iff.2 fun _ h₁ => rank_lt_of_mem (mem_of_subset h h₁)\n\n"}
{"name":"PSet.rank_empty","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"⊢ Eq EmptyCollection.emptyCollection.rank 0","decl":"@[simp]\ntheorem rank_empty : rank ∅ = 0 := by simp [empty_def, rank]\n\n"}
{"name":"PSet.rank_insert","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"x y : PSet.{u_1}\n⊢ Eq (Insert.insert x y).rank (Max.max (Order.succ x.rank) y.rank)","decl":"@[simp]\ntheorem rank_insert (x y : PSet) : rank (insert x y) = max (succ (rank x)) (rank y) := by\n  apply le_antisymm\n  · simp_rw [rank_le_iff, mem_insert_iff]\n    rintro _ (h | h)\n    · simp [rank_congr h]\n    · simp [rank_lt_of_mem h]\n  · apply max_le\n    · exact (rank_lt_of_mem (mem_insert x y)).succ_le\n    · exact rank_mono (subset_iff.2 fun z => mem_insert_of_mem x)\n\n"}
{"name":"PSet.rank_singleton","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"x : PSet.{u_1}\n⊢ Eq (Singleton.singleton x).rank (Order.succ x.rank)","decl":"@[simp]\ntheorem rank_singleton (x : PSet) : rank {x} = succ (rank x) :=\n  (rank_insert _ _).trans (by simp)\n\n"}
{"name":"PSet.rank_pair","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"x y : PSet.{u_1}\n⊢ Eq (Insert.insert x (Singleton.singleton y)).rank (Max.max (Order.succ x.rank) (Order.succ y.rank))","decl":"theorem rank_pair (x y : PSet) : rank {x, y} = max (succ (rank x)) (succ (rank y)) := by\n  simp\n\n"}
{"name":"PSet.rank_powerset","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"x : PSet.{u_1}\n⊢ Eq x.powerset.rank (Order.succ x.rank)","decl":"@[simp]\ntheorem rank_powerset (x : PSet) : rank (powerset x) = succ (rank x) := by\n  apply le_antisymm\n  · simp_rw [rank_le_iff, mem_powerset, lt_succ_iff]\n    intro\n    exact rank_mono\n  · rw [succ_le_iff]\n    apply rank_lt_of_mem\n    simp\n\n"}
{"name":"PSet.rank_sUnion_le","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"x : PSet.{u_1}\n⊢ LE.le x.sUnion.rank x.rank","decl":"/-- For the rank of `⋃₀ x`, we only have `rank (⋃₀ x) ≤ rank x ≤ rank (⋃₀ x) + 1`.\n\nThis inequality is split into `rank_sUnion_le` and `le_succ_rank_sUnion`. -/\ntheorem rank_sUnion_le (x : PSet) : rank (⋃₀ x) ≤ rank x := by\n  simp_rw [rank_le_iff, mem_sUnion]\n  intro _ ⟨_, _, _⟩\n  trans <;> apply rank_lt_of_mem <;> assumption\n\n"}
{"name":"PSet.le_succ_rank_sUnion","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"x : PSet.{u_1}\n⊢ LE.le x.rank (Order.succ x.sUnion.rank)","decl":"theorem le_succ_rank_sUnion (x : PSet) : rank x ≤ succ (rank (⋃₀ x)) := by\n  rw [← rank_powerset]\n  apply rank_mono\n  rw [subset_iff]\n  intro z _\n  rw [mem_powerset, subset_iff]\n  intro _ _\n  rw [mem_sUnion]\n  exists z\n\n"}
{"name":"PSet.rank_eq_wfRank","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"x : PSet.{u}\n⊢ Eq (Ordinal.lift.{u + 1, u} x.rank) (IsWellFounded.rank (fun x1 x2 => Membership.mem x2 x1) x)","decl":"/-- `PSet.rank` is equal to the `IsWellFounded.rank` over `∈`. -/\ntheorem rank_eq_wfRank : lift.{u + 1, u} (rank x) = IsWellFounded.rank (α := PSet) (· ∈ ·) x := by\n  induction' x using mem_wf.induction with x ih\n  rw [IsWellFounded.rank_eq]\n  simp_rw [← fun y : { y // y ∈ x } => ih y y.2]\n  apply (le_of_forall_lt _).antisymm (Ordinal.iSup_le _) <;> intro h\n  · rw [lt_lift_iff]\n    rintro ⟨o, h, rfl⟩\n    simpa [Ordinal.lt_iSup_iff] using lt_rank_iff.1 h\n  · simpa using rank_lt_of_mem h.2\n\n"}
{"name":"ZFSet.rank_lt_of_mem","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"x y : ZFSet.{u}\na✝ : Membership.mem x y\n⊢ LT.lt y.rank x.rank","decl":"theorem rank_lt_of_mem : y ∈ x → rank y < rank x :=\n  Quotient.inductionOn₂ x y fun _ _ => PSet.rank_lt_of_mem\n\n"}
{"name":"ZFSet.rank_le_iff","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"x : ZFSet.{u}\no : Ordinal.{u}\n⊢ Iff (LE.le x.rank o) (∀ ⦃y : ZFSet.{u}⦄, Membership.mem x y → LT.lt y.rank o)","decl":"theorem rank_le_iff {o : Ordinal} : rank x ≤ o ↔ ∀ ⦃y⦄, y ∈ x → rank y < o :=\n  ⟨fun h _ h' => (rank_lt_of_mem h').trans_le h,\n    Quotient.inductionOn x fun _ h =>\n      PSet.rank_le_iff.2 fun y h' => @h ⟦y⟧ h'⟩\n\n"}
{"name":"ZFSet.lt_rank_iff","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"x : ZFSet.{u}\no : Ordinal.{u}\n⊢ Iff (LT.lt o x.rank) (Exists fun y => And (Membership.mem x y) (LE.le o y.rank))","decl":"theorem lt_rank_iff {o : Ordinal} : o < rank x ↔ ∃ y ∈ x, o ≤ rank y := by\n  rw [← not_iff_not, not_lt, rank_le_iff]\n  simp\n\n"}
{"name":"ZFSet.rank_mono","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"x y : ZFSet.{u}\nh : HasSubset.Subset x y\n⊢ LE.le x.rank y.rank","decl":"@[gcongr] theorem rank_mono (h : x ⊆ y) : rank x ≤ rank y :=\n  rank_le_iff.2 fun _ h₁ => rank_lt_of_mem (h h₁)\n\n"}
{"name":"ZFSet.rank_empty","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"⊢ Eq EmptyCollection.emptyCollection.rank 0","decl":"@[simp]\ntheorem rank_empty : rank ∅ = 0 := PSet.rank_empty\n\n"}
{"name":"ZFSet.rank_insert","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"x y : ZFSet.{u_1}\n⊢ Eq (Insert.insert x y).rank (Max.max (Order.succ x.rank) y.rank)","decl":"@[simp]\ntheorem rank_insert (x y : ZFSet) : rank (insert x y) = max (succ (rank x)) (rank y) :=\n  Quotient.inductionOn₂ x y PSet.rank_insert\n\n"}
{"name":"ZFSet.rank_singleton","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"x : ZFSet.{u_1}\n⊢ Eq (Singleton.singleton x).rank (Order.succ x.rank)","decl":"@[simp]\ntheorem rank_singleton (x : ZFSet) : rank {x} = succ (rank x) :=\n  (rank_insert _ _).trans (by simp)\n\n"}
{"name":"ZFSet.rank_pair","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"x y : ZFSet.{u_1}\n⊢ Eq (Insert.insert x (Singleton.singleton y)).rank (Max.max (Order.succ x.rank) (Order.succ y.rank))","decl":"theorem rank_pair (x y : ZFSet) : rank {x, y} = max (succ (rank x)) (succ (rank y)) := by\n  simp\n\n"}
{"name":"ZFSet.rank_union","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"x y : ZFSet.{u_1}\n⊢ Eq (Union.union x y).rank (Max.max x.rank y.rank)","decl":"@[simp]\ntheorem rank_union (x y : ZFSet) : rank (x ∪ y) = max (rank x) (rank y) := by\n  apply le_antisymm\n  · simp_rw [rank_le_iff, mem_union, lt_max_iff]\n    intro\n    apply Or.imp <;> apply rank_lt_of_mem\n  · apply max_le <;> apply rank_mono <;> intro _ h <;> simp [h]\n\n"}
{"name":"ZFSet.rank_powerset","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"x : ZFSet.{u_1}\n⊢ Eq x.powerset.rank (Order.succ x.rank)","decl":"@[simp]\ntheorem rank_powerset (x : ZFSet) : rank (powerset x) = succ (rank x) :=\n  Quotient.inductionOn x PSet.rank_powerset\n\n"}
{"name":"ZFSet.rank_sUnion_le","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"x : ZFSet.{u_1}\n⊢ LE.le x.sUnion.rank x.rank","decl":"/-- For the rank of `⋃₀ x`, we only have `rank (⋃₀ x) ≤ rank x ≤ rank (⋃₀ x) + 1`.\n\nThis inequality is split into `rank_sUnion_le` and `le_succ_rank_sUnion`. -/\ntheorem rank_sUnion_le (x : ZFSet) : rank (⋃₀ x) ≤ rank x := by\n  simp_rw [rank_le_iff, mem_sUnion]\n  intro _ ⟨_, _, _⟩\n  trans <;> apply rank_lt_of_mem <;> assumption\n\n"}
{"name":"ZFSet.le_succ_rank_sUnion","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"x : ZFSet.{u_1}\n⊢ LE.le x.rank (Order.succ x.sUnion.rank)","decl":"theorem le_succ_rank_sUnion (x : ZFSet) : rank x ≤ succ (rank (⋃₀ x)) := by\n  rw [← rank_powerset]\n  apply rank_mono\n  intro z _\n  rw [mem_powerset]\n  intro _ _\n  rw [mem_sUnion]\n  exists z\n\n"}
{"name":"ZFSet.rank_range","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"α : Type u_1\ninst✝ : Small.{u, u_1} α\nf : α → ZFSet.{u}\n⊢ Eq (ZFSet.range f).rank (iSup fun i => Order.succ (f i).rank)","decl":"@[simp]\ntheorem rank_range {α : Type*} [Small.{u} α] (f : α → ZFSet.{u}) :\n    rank (range f) = ⨆ i, succ (rank (f i)) := by\n  apply (Ordinal.iSup_le _).antisymm'\n  · simpa [rank_le_iff, ← succ_le_iff] using Ordinal.le_iSup _\n  · simp [rank_lt_of_mem]\n\n"}
{"name":"ZFSet.rank_eq_wfRank","module":"Mathlib.SetTheory.ZFC.Rank","initialProofState":"x : ZFSet.{u}\n⊢ Eq (Ordinal.lift.{u + 1, u} x.rank) (IsWellFounded.rank (fun x1 x2 => Membership.mem x2 x1) x)","decl":"/-- `ZFSet.rank` is equal to the `IsWellFounded.rank` over `∈`. -/\ntheorem rank_eq_wfRank : lift.{u + 1, u} (rank x) = IsWellFounded.rank (α := ZFSet) (· ∈ ·) x := by\n  induction' x using inductionOn with x ih\n  rw [IsWellFounded.rank_eq]\n  simp_rw [← fun y : { y // y ∈ x } => ih y y.2]\n  apply (le_of_forall_lt _).antisymm (Ordinal.iSup_le _) <;> intro h\n  · rw [lt_lift_iff]\n    rintro ⟨o, h, rfl⟩\n    simpa [Ordinal.lt_iSup_iff] using lt_rank_iff.1 h\n  · simpa using rank_lt_of_mem h.2\n\n"}
