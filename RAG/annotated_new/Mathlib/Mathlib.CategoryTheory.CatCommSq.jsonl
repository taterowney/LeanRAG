{"name":"CategoryTheory.CatCommSq.ext","module":"Mathlib.CategoryTheory.CatCommSq","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝ : CategoryTheory.Category.{u_10, u_4} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nx y : CategoryTheory.CatCommSq T L R B\niso' : Eq CategoryTheory.CatCommSq.iso' CategoryTheory.CatCommSq.iso'\n⊢ Eq x y","decl":"/-- `CatCommSq T L R B` expresses that there is a 2-commutative square of functors, where\nthe functors `T`, `L`, `R` and `B` are respectively the left, top, right and bottom functors\nof the square. -/\n@[ext]\nclass CatCommSq where\n  /-- the isomorphism corresponding to a 2-commutative diagram -/\n  iso' : T ⋙ R ≅ L ⋙ B\n\n"}
{"name":"CategoryTheory.CatCommSq.ext_iff","module":"Mathlib.CategoryTheory.CatCommSq","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝ : CategoryTheory.Category.{u_10, u_4} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nx y : CategoryTheory.CatCommSq T L R B\n⊢ Iff (Eq x y) (Eq CategoryTheory.CatCommSq.iso' CategoryTheory.CatCommSq.iso')","decl":"/-- `CatCommSq T L R B` expresses that there is a 2-commutative square of functors, where\nthe functors `T`, `L`, `R` and `B` are respectively the left, top, right and bottom functors\nof the square. -/\n@[ext]\nclass CatCommSq where\n  /-- the isomorphism corresponding to a 2-commutative diagram -/\n  iso' : T ⋙ R ≅ L ⋙ B\n\n"}
{"name":"CategoryTheory.CatCommSq.hComp_iso'_hom_app","module":"Mathlib.CategoryTheory.CatCommSq","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₅ : Type u_5\nC₆ : Type u_6\ninst✝⁷ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝⁶ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁵ : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝⁴ : CategoryTheory.Category.{u_10, u_4} C₄\ninst✝³ : CategoryTheory.Category.{u_11, u_5} C₅\ninst✝² : CategoryTheory.Category.{u_12, u_6} C₆\nT₁ : CategoryTheory.Functor C₁ C₂\nT₂ : CategoryTheory.Functor C₂ C₃\nV₁ : CategoryTheory.Functor C₁ C₄\nV₂ : CategoryTheory.Functor C₂ C₅\nV₃ : CategoryTheory.Functor C₃ C₆\nB₁ : CategoryTheory.Functor C₄ C₅\nB₂ : CategoryTheory.Functor C₅ C₆\ninst✝¹ : CategoryTheory.CatCommSq T₁ V₁ V₂ B₁\ninst✝ : CategoryTheory.CatCommSq T₂ V₂ V₃ B₂\nX : C₁\n⊢ Eq (CategoryTheory.CatCommSq.iso'.hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CatCommSq.iso T₂ V₂ V₃ B₂).hom.app (T₁.obj X)) (B₂.map ((CategoryTheory.CatCommSq.iso T₁ V₁ V₂ B₁).hom.app X)))","decl":"/-- Horizontal composition of 2-commutative squares -/\n@[simps! iso'_hom_app iso'_inv_app]\ndef hComp (T₁ : C₁ ⥤ C₂) (T₂ : C₂ ⥤ C₃) (V₁ : C₁ ⥤ C₄) (V₂ : C₂ ⥤ C₅) (V₃ : C₃ ⥤ C₆)\n    (B₁ : C₄ ⥤ C₅) (B₂ : C₅ ⥤ C₆) [CatCommSq T₁ V₁ V₂ B₁] [CatCommSq T₂ V₂ V₃ B₂] :\n    CatCommSq (T₁ ⋙ T₂) V₁ V₃ (B₁ ⋙ B₂) where\n  iso' := Functor.associator _ _ _ ≪≫ isoWhiskerLeft T₁ (iso T₂ V₂ V₃ B₂) ≪≫\n    (Functor.associator _ _ _).symm ≪≫ isoWhiskerRight (iso T₁ V₁ V₂ B₁) B₂ ≪≫\n    Functor.associator _ _ _\n\n"}
{"name":"CategoryTheory.CatCommSq.hComp_iso'_inv_app","module":"Mathlib.CategoryTheory.CatCommSq","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₅ : Type u_5\nC₆ : Type u_6\ninst✝⁷ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝⁶ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁵ : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝⁴ : CategoryTheory.Category.{u_10, u_4} C₄\ninst✝³ : CategoryTheory.Category.{u_11, u_5} C₅\ninst✝² : CategoryTheory.Category.{u_12, u_6} C₆\nT₁ : CategoryTheory.Functor C₁ C₂\nT₂ : CategoryTheory.Functor C₂ C₃\nV₁ : CategoryTheory.Functor C₁ C₄\nV₂ : CategoryTheory.Functor C₂ C₅\nV₃ : CategoryTheory.Functor C₃ C₆\nB₁ : CategoryTheory.Functor C₄ C₅\nB₂ : CategoryTheory.Functor C₅ C₆\ninst✝¹ : CategoryTheory.CatCommSq T₁ V₁ V₂ B₁\ninst✝ : CategoryTheory.CatCommSq T₂ V₂ V₃ B₂\nX : C₁\n⊢ Eq (CategoryTheory.CatCommSq.iso'.inv.app X) (CategoryTheory.CategoryStruct.comp (B₂.map ((CategoryTheory.CatCommSq.iso T₁ V₁ V₂ B₁).inv.app X)) ((CategoryTheory.CatCommSq.iso T₂ V₂ V₃ B₂).inv.app (T₁.obj X)))","decl":"/-- Horizontal composition of 2-commutative squares -/\n@[simps! iso'_hom_app iso'_inv_app]\ndef hComp (T₁ : C₁ ⥤ C₂) (T₂ : C₂ ⥤ C₃) (V₁ : C₁ ⥤ C₄) (V₂ : C₂ ⥤ C₅) (V₃ : C₃ ⥤ C₆)\n    (B₁ : C₄ ⥤ C₅) (B₂ : C₅ ⥤ C₆) [CatCommSq T₁ V₁ V₂ B₁] [CatCommSq T₂ V₂ V₃ B₂] :\n    CatCommSq (T₁ ⋙ T₂) V₁ V₃ (B₁ ⋙ B₂) where\n  iso' := Functor.associator _ _ _ ≪≫ isoWhiskerLeft T₁ (iso T₂ V₂ V₃ B₂) ≪≫\n    (Functor.associator _ _ _).symm ≪≫ isoWhiskerRight (iso T₁ V₁ V₂ B₁) B₂ ≪≫\n    Functor.associator _ _ _\n\n"}
{"name":"CategoryTheory.CatCommSq.vComp_iso'_hom_app","module":"Mathlib.CategoryTheory.CatCommSq","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₅ : Type u_5\nC₆ : Type u_6\ninst✝⁷ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝⁶ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁵ : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝⁴ : CategoryTheory.Category.{u_10, u_4} C₄\ninst✝³ : CategoryTheory.Category.{u_11, u_5} C₅\ninst✝² : CategoryTheory.Category.{u_12, u_6} C₆\nL₁ : CategoryTheory.Functor C₁ C₂\nL₂ : CategoryTheory.Functor C₂ C₃\nH₁ : CategoryTheory.Functor C₁ C₄\nH₂ : CategoryTheory.Functor C₂ C₅\nH₃ : CategoryTheory.Functor C₃ C₆\nR₁ : CategoryTheory.Functor C₄ C₅\nR₂ : CategoryTheory.Functor C₅ C₆\ninst✝¹ : CategoryTheory.CatCommSq H₁ L₁ R₁ H₂\ninst✝ : CategoryTheory.CatCommSq H₂ L₂ R₂ H₃\nX : C₁\n⊢ Eq (CategoryTheory.CatCommSq.iso'.hom.app X) (CategoryTheory.CategoryStruct.comp (R₂.map ((CategoryTheory.CatCommSq.iso H₁ L₁ R₁ H₂).hom.app X)) ((CategoryTheory.CatCommSq.iso H₂ L₂ R₂ H₃).hom.app (L₁.obj X)))","decl":"/-- Vertical composition of 2-commutative squares -/\n@[simps! iso'_hom_app iso'_inv_app]\ndef vComp (L₁ : C₁ ⥤ C₂) (L₂ : C₂ ⥤ C₃) (H₁ : C₁ ⥤ C₄) (H₂ : C₂ ⥤ C₅) (H₃ : C₃ ⥤ C₆)\n    (R₁ : C₄ ⥤ C₅) (R₂ : C₅ ⥤ C₆) [CatCommSq H₁ L₁ R₁ H₂] [CatCommSq H₂ L₂ R₂ H₃] :\n    CatCommSq H₁ (L₁ ⋙ L₂) (R₁ ⋙ R₂) H₃ where\n  iso' := (Functor.associator _ _ _).symm ≪≫ isoWhiskerRight (iso H₁ L₁ R₁ H₂) R₂ ≪≫\n      Functor.associator _ _ _ ≪≫ isoWhiskerLeft L₁ (iso H₂ L₂ R₂ H₃) ≪≫\n      (Functor.associator _ _ _).symm\n\n"}
{"name":"CategoryTheory.CatCommSq.vComp_iso'_inv_app","module":"Mathlib.CategoryTheory.CatCommSq","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₅ : Type u_5\nC₆ : Type u_6\ninst✝⁷ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝⁶ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁵ : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝⁴ : CategoryTheory.Category.{u_10, u_4} C₄\ninst✝³ : CategoryTheory.Category.{u_11, u_5} C₅\ninst✝² : CategoryTheory.Category.{u_12, u_6} C₆\nL₁ : CategoryTheory.Functor C₁ C₂\nL₂ : CategoryTheory.Functor C₂ C₃\nH₁ : CategoryTheory.Functor C₁ C₄\nH₂ : CategoryTheory.Functor C₂ C₅\nH₃ : CategoryTheory.Functor C₃ C₆\nR₁ : CategoryTheory.Functor C₄ C₅\nR₂ : CategoryTheory.Functor C₅ C₆\ninst✝¹ : CategoryTheory.CatCommSq H₁ L₁ R₁ H₂\ninst✝ : CategoryTheory.CatCommSq H₂ L₂ R₂ H₃\nX : C₁\n⊢ Eq (CategoryTheory.CatCommSq.iso'.inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CatCommSq.iso H₂ L₂ R₂ H₃).inv.app (L₁.obj X)) (R₂.map ((CategoryTheory.CatCommSq.iso H₁ L₁ R₁ H₂).inv.app X)))","decl":"/-- Vertical composition of 2-commutative squares -/\n@[simps! iso'_hom_app iso'_inv_app]\ndef vComp (L₁ : C₁ ⥤ C₂) (L₂ : C₂ ⥤ C₃) (H₁ : C₁ ⥤ C₄) (H₂ : C₂ ⥤ C₅) (H₃ : C₃ ⥤ C₆)\n    (R₁ : C₄ ⥤ C₅) (R₂ : C₅ ⥤ C₆) [CatCommSq H₁ L₁ R₁ H₂] [CatCommSq H₂ L₂ R₂ H₃] :\n    CatCommSq H₁ (L₁ ⋙ L₂) (R₁ ⋙ R₂) H₃ where\n  iso' := (Functor.associator _ _ _).symm ≪≫ isoWhiskerRight (iso H₁ L₁ R₁ H₂) R₂ ≪≫\n      Functor.associator _ _ _ ≪≫ isoWhiskerLeft L₁ (iso H₂ L₂ R₂ H₃) ≪≫\n      (Functor.associator _ _ _).symm\n\n"}
{"name":"CategoryTheory.CatCommSq.hInv_iso'_hom_app","module":"Mathlib.CategoryTheory.CatCommSq","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝ : CategoryTheory.Category.{u_10, u_4} C₄\nT : CategoryTheory.Equivalence C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Equivalence C₃ C₄\nx✝ : CategoryTheory.CatCommSq T.functor L R B.functor\nX : C₂\n⊢ Eq (CategoryTheory.CatCommSq.iso'.hom.app X) (CategoryTheory.CategoryStruct.comp (B.unitIso.hom.app (L.obj (T.inverse.obj X))) (CategoryTheory.CategoryStruct.comp (B.inverse.map ((CategoryTheory.CatCommSq.iso T.functor L R B.functor).inv.app (T.inverse.obj X))) (B.inverse.map (R.map (T.counitIso.hom.app X)))))","decl":"/-- Horizontal inverse of a 2-commutative square -/\n@[simps! iso'_hom_app iso'_inv_app]\ndef hInv (_ : CatCommSq T.functor L R B.functor) : CatCommSq T.inverse R L B.inverse where\n  iso' := isoWhiskerLeft _ (L.rightUnitor.symm ≪≫ isoWhiskerLeft L B.unitIso ≪≫\n      (Functor.associator _ _ _).symm ≪≫\n      isoWhiskerRight (iso T.functor L R B.functor).symm B.inverse ≪≫\n      Functor.associator _ _ _  ) ≪≫ (Functor.associator _ _ _).symm ≪≫\n      isoWhiskerRight T.counitIso _ ≪≫ Functor.leftUnitor _\n\n"}
{"name":"CategoryTheory.CatCommSq.hInv_iso'_inv_app","module":"Mathlib.CategoryTheory.CatCommSq","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝ : CategoryTheory.Category.{u_10, u_4} C₄\nT : CategoryTheory.Equivalence C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Equivalence C₃ C₄\nx✝ : CategoryTheory.CatCommSq T.functor L R B.functor\nX : C₂\n⊢ Eq (CategoryTheory.CatCommSq.iso'.inv.app X) (CategoryTheory.CategoryStruct.comp (B.inverse.map (R.map (T.counitIso.inv.app X))) (CategoryTheory.CategoryStruct.comp (B.inverse.map ((CategoryTheory.CatCommSq.iso T.functor L R B.functor).hom.app (T.inverse.obj X))) (B.unitIso.inv.app (L.obj (T.inverse.obj X)))))","decl":"/-- Horizontal inverse of a 2-commutative square -/\n@[simps! iso'_hom_app iso'_inv_app]\ndef hInv (_ : CatCommSq T.functor L R B.functor) : CatCommSq T.inverse R L B.inverse where\n  iso' := isoWhiskerLeft _ (L.rightUnitor.symm ≪≫ isoWhiskerLeft L B.unitIso ≪≫\n      (Functor.associator _ _ _).symm ≪≫\n      isoWhiskerRight (iso T.functor L R B.functor).symm B.inverse ≪≫\n      Functor.associator _ _ _  ) ≪≫ (Functor.associator _ _ _).symm ≪≫\n      isoWhiskerRight T.counitIso _ ≪≫ Functor.leftUnitor _\n\n"}
{"name":"CategoryTheory.CatCommSq.hInv_hInv","module":"Mathlib.CategoryTheory.CatCommSq","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_10, u_3} C₃\ninst✝ : CategoryTheory.Category.{u_7, u_4} C₄\nT : CategoryTheory.Equivalence C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Equivalence C₃ C₄\nh : CategoryTheory.CatCommSq T.functor L R B.functor\n⊢ Eq (CategoryTheory.CatCommSq.hInv T.symm R L B.symm (CategoryTheory.CatCommSq.hInv T L R B h)) h","decl":"lemma hInv_hInv (h : CatCommSq T.functor L R B.functor) :\n    hInv T.symm R L B.symm (hInv T L R B h) = h := by\n  ext X\n  erw [← cancel_mono (B.functor.map (L.map (T.unitIso.hom.app X))),\n    ← h.iso'.hom.naturality (T.unitIso.hom.app X), hInv_iso'_hom_app, hInv_iso'_inv_app]\n  dsimp\n  simp only [Functor.comp_obj, assoc, ← Functor.map_comp, Iso.inv_hom_id_app,\n    Equivalence.counitInv_app_functor, Functor.map_id]\n  simp only [Functor.map_comp, Equivalence.fun_inv_map, assoc,\n    Equivalence.counitInv_functor_comp, comp_id, Iso.inv_hom_id_app_assoc]\n  rfl\n\n"}
{"name":"CategoryTheory.CatCommSq.vInv_iso'_inv_app","module":"Mathlib.CategoryTheory.CatCommSq","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝ : CategoryTheory.Category.{u_10, u_4} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Equivalence C₁ C₃\nR : CategoryTheory.Equivalence C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nx✝ : CategoryTheory.CatCommSq T L.functor R.functor B\nX : C₃\n⊢ Eq (CategoryTheory.CatCommSq.iso'.inv.app X) (CategoryTheory.CategoryStruct.comp (R.unitIso.hom.app (T.obj (L.inverse.obj X))) (CategoryTheory.CategoryStruct.comp (R.inverse.map ((CategoryTheory.CatCommSq.iso T L.functor R.functor B).hom.app (L.inverse.obj X))) (R.inverse.map (B.map (L.counitIso.hom.app X)))))","decl":"/-- Vertical inverse of a 2-commutative square -/\n@[simps! iso'_hom_app iso'_inv_app]\ndef vInv (_ : CatCommSq T L.functor R.functor B) : CatCommSq B L.inverse R.inverse T where\n  iso' := isoWhiskerRight (B.leftUnitor.symm ≪≫ isoWhiskerRight L.counitIso.symm B ≪≫\n      Functor.associator _ _ _ ≪≫\n      isoWhiskerLeft L.inverse (iso T L.functor R.functor B).symm) R.inverse ≪≫\n      Functor.associator _ _ _ ≪≫ isoWhiskerLeft _ (Functor.associator _ _ _) ≪≫\n      (Functor.associator _ _ _ ).symm ≪≫ isoWhiskerLeft _ R.unitIso.symm ≪≫\n      Functor.rightUnitor _\n\n"}
{"name":"CategoryTheory.CatCommSq.vInv_iso'_hom_app","module":"Mathlib.CategoryTheory.CatCommSq","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝ : CategoryTheory.Category.{u_10, u_4} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Equivalence C₁ C₃\nR : CategoryTheory.Equivalence C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nx✝ : CategoryTheory.CatCommSq T L.functor R.functor B\nX : C₃\n⊢ Eq (CategoryTheory.CatCommSq.iso'.hom.app X) (CategoryTheory.CategoryStruct.comp (R.inverse.map (B.map (L.counitIso.inv.app X))) (CategoryTheory.CategoryStruct.comp (R.inverse.map ((CategoryTheory.CatCommSq.iso T L.functor R.functor B).inv.app (L.inverse.obj X))) (R.unitIso.inv.app (T.obj (L.inverse.obj X)))))","decl":"/-- Vertical inverse of a 2-commutative square -/\n@[simps! iso'_hom_app iso'_inv_app]\ndef vInv (_ : CatCommSq T L.functor R.functor B) : CatCommSq B L.inverse R.inverse T where\n  iso' := isoWhiskerRight (B.leftUnitor.symm ≪≫ isoWhiskerRight L.counitIso.symm B ≪≫\n      Functor.associator _ _ _ ≪≫\n      isoWhiskerLeft L.inverse (iso T L.functor R.functor B).symm) R.inverse ≪≫\n      Functor.associator _ _ _ ≪≫ isoWhiskerLeft _ (Functor.associator _ _ _) ≪≫\n      (Functor.associator _ _ _ ).symm ≪≫ isoWhiskerLeft _ R.unitIso.symm ≪≫\n      Functor.rightUnitor _\n\n"}
{"name":"CategoryTheory.CatCommSq.vInv_vInv","module":"Mathlib.CategoryTheory.CatCommSq","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_10, u_3} C₃\ninst✝ : CategoryTheory.Category.{u_7, u_4} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Equivalence C₁ C₃\nR : CategoryTheory.Equivalence C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nh : CategoryTheory.CatCommSq T L.functor R.functor B\n⊢ Eq (CategoryTheory.CatCommSq.vInv B L.symm R.symm T (CategoryTheory.CatCommSq.vInv T L R B h)) h","decl":"lemma vInv_vInv (h : CatCommSq T L.functor R.functor B) :\n    vInv B L.symm R.symm T (vInv T L R B h) = h := by\n  ext X\n  erw [vInv_iso'_hom_app, vInv_iso'_inv_app]\n  dsimp\n  rw [← cancel_mono (B.map (L.functor.map (NatTrans.app L.unitIso.hom X)))]\n  erw [← (iso T L.functor R.functor B).hom.naturality (L.unitIso.hom.app X)]\n  dsimp\n  simp only [Functor.map_comp, Equivalence.fun_inv_map, Functor.comp_obj,\n    Functor.id_obj, assoc, Iso.inv_hom_id_app_assoc, Iso.inv_hom_id_app, comp_id]\n  erw [← B.map_comp, L.counit_app_functor, ← L.functor.map_comp, ← NatTrans.comp_app,\n    Iso.inv_hom_id, NatTrans.id_app, L.functor.map_id, B.map_id, comp_id, R.counit_app_functor,\n    ← R.functor.map_comp_assoc, ← R.functor.map_comp_assoc, assoc, ← NatTrans.comp_app,\n    Iso.hom_inv_id, NatTrans.id_app, comp_id]\n\n"}
