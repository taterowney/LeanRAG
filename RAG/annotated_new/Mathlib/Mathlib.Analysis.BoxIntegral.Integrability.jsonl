{"name":"BoxIntegral.hasIntegralIndicatorConst","module":"Mathlib.Analysis.BoxIntegral.Integrability","initialProofState":"Î¹ : Type u\nE : Type v\ninstâœÂ³ : Fintype Î¹\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nl : BoxIntegral.IntegrationParams\nhl : Eq l.bRiemann Bool.false\ns : Set (Î¹ â†’ Real)\nhs : MeasurableSet s\nI : BoxIntegral.Box Î¹\ny : E\nÎ¼ : MeasureTheory.Measure (Î¹ â†’ Real)\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nâŠ¢ BoxIntegral.HasIntegral I l (s.indicator fun x => y) Î¼.toBoxAdditive.toSMul (HSMul.hSMul (Î¼ (Inter.inter s â†‘I)).toReal y)","decl":"/-- The indicator function of a measurable set is McShane integrable with respect to any\nlocally-finite measure. -/\ntheorem hasIntegralIndicatorConst (l : IntegrationParams) (hl : l.bRiemann = false)\n    {s : Set (Î¹ â†’ â„)} (hs : MeasurableSet s) (I : Box Î¹) (y : E) (Î¼ : Measure (Î¹ â†’ â„))\n    [IsLocallyFiniteMeasure Î¼] :\n    HasIntegral.{u, v, v} I l (s.indicator fun _ => y) Î¼.toBoxAdditive.toSMul\n      ((Î¼ (s âˆ© I)).toReal â€¢ y) := by\n  refine HasIntegral.of_mul â€–yâ€– fun Îµ Îµ0 => ?_\n  lift Îµ to â„â‰¥0 using Îµ0.le; rw [NNReal.coe_pos] at Îµ0\n  /- First we choose a closed set `F âŠ† s âˆ© I.Icc` and an open set `U âŠ‡ s` such that\n    both `(s âˆ© I.Icc) \\ F` and `U \\ s` have measure less than `Îµ`. -/\n  have A : Î¼ (s âˆ© Box.Icc I) â‰  âˆ :=\n    ((measure_mono Set.inter_subset_right).trans_lt (I.measure_Icc_lt_top Î¼)).ne\n  have B : Î¼ (s âˆ© I) â‰  âˆ :=\n    ((measure_mono Set.inter_subset_right).trans_lt (I.measure_coe_lt_top Î¼)).ne\n  obtain âŸ¨F, hFs, hFc, hÎ¼FâŸ© : âˆƒ F, F âŠ† s âˆ© Box.Icc I âˆ§ IsClosed F âˆ§ Î¼ ((s âˆ© Box.Icc I) \\ F) < Îµ :=\n    (hs.inter I.measurableSet_Icc).exists_isClosed_diff_lt A (ENNReal.coe_pos.2 Îµ0).ne'\n  obtain âŸ¨U, hsU, hUo, hUt, hÎ¼UâŸ© :\n      âˆƒ U, s âˆ© Box.Icc I âŠ† U âˆ§ IsOpen U âˆ§ Î¼ U < âˆ âˆ§ Î¼ (U \\ (s âˆ© Box.Icc I)) < Îµ :=\n    (hs.inter I.measurableSet_Icc).exists_isOpen_diff_lt A (ENNReal.coe_pos.2 Îµ0).ne'\n  /- Then we choose `r` so that `closed_ball x (r x) âŠ† U` whenever `x âˆˆ s âˆ© I.Icc` and\n    `closed_ball x (r x)` is disjoint with `F` otherwise. -/\n  have : âˆ€ x âˆˆ s âˆ© Box.Icc I, âˆƒ r : Ioi (0 : â„), closedBall x r âŠ† U := fun x hx => by\n    rcases nhds_basis_closedBall.mem_iff.1 (hUo.mem_nhds <| hsU hx) with âŸ¨r, hrâ‚€, hrâŸ©\n    exact âŸ¨âŸ¨r, hrâ‚€âŸ©, hrâŸ©\n  choose! rs hrsU using this\n  have : âˆ€ x âˆˆ Box.Icc I \\ s, âˆƒ r : Ioi (0 : â„), closedBall x r âŠ† Fá¶œ := fun x hx => by\n    obtain âŸ¨r, hrâ‚€, hrâŸ© :=\n      nhds_basis_closedBall.mem_iff.1 (hFc.isOpen_compl.mem_nhds fun hx' => hx.2 (hFs hx').1)\n    exact âŸ¨âŸ¨r, hrâ‚€âŸ©, hrâŸ©\n  choose! rs' hrs'F using this\n  classical\n  set r : (Î¹ â†’ â„) â†’ Ioi (0 : â„) := s.piecewise rs rs'\n  refine âŸ¨fun _ => r, fun c => l.rCond_of_bRiemann_eq_false hl, fun c Ï€ hÏ€ hÏ€p => ?_âŸ©; rw [mul_comm]\n  /- Then the union of boxes `J âˆˆ Ï€` such that `Ï€.tag âˆˆ s` includes `F` and is included by `U`,\n    hence its measure is `Îµ`-close to the measure of `s`. -/\n  dsimp [integralSum]\n  simp only [mem_closedBall, dist_eq_norm, â† indicator_const_smul_apply,\n    sum_indicator_eq_sum_filter, â† sum_smul, â† sub_smul, norm_smul, Real.norm_eq_abs, â†\n    Prepartition.filter_boxes, â† Prepartition.measure_iUnion_toReal]\n  gcongr\n  set t := (Ï€.filter (Ï€.tag Â· âˆˆ s)).iUnion\n  change abs ((Î¼ t).toReal - (Î¼ (s âˆ© I)).toReal) â‰¤ Îµ\n  have htU : t âŠ† U âˆ© I := by\n    simp only [t, TaggedPrepartition.iUnion_def, iUnion_subset_iff, TaggedPrepartition.mem_filter,\n      and_imp]\n    refine fun J hJ hJs x hx => âŸ¨hrsU _ âŸ¨hJs, Ï€.tag_mem_Icc JâŸ© ?_, Ï€.le_of_mem' J hJ hxâŸ©\n    simpa only [r, s.piecewise_eq_of_mem _ _ hJs] using hÏ€.1 J hJ (Box.coe_subset_Icc hx)\n  refine abs_sub_le_iff.2 âŸ¨?_, ?_âŸ©\n  Â· refine (ENNReal.le_toReal_sub B).trans (ENNReal.toReal_le_coe_of_le_coe ?_)\n    refine (tsub_le_tsub (measure_mono htU) le_rfl).trans (le_measure_diff.trans ?_)\n    refine (measure_mono fun x hx => ?_).trans hÎ¼U.le\n    exact âŸ¨hx.1.1, fun hx' => hx.2 âŸ¨hx'.1, hx.1.2âŸ©âŸ©\n  Â· have hÎ¼t : Î¼ t â‰  âˆ := ((measure_mono (htU.trans inter_subset_left)).trans_lt hUt).ne\n    refine (ENNReal.le_toReal_sub hÎ¼t).trans (ENNReal.toReal_le_coe_of_le_coe ?_)\n    refine le_measure_diff.trans ((measure_mono ?_).trans hÎ¼F.le)\n    rintro x âŸ¨âŸ¨hxs, hxIâŸ©, hxtâŸ©\n    refine âŸ¨âŸ¨hxs, Box.coe_subset_Icc hxIâŸ©, fun hxF => hxt ?_âŸ©\n    simp only [t, TaggedPrepartition.iUnion_def, TaggedPrepartition.mem_filter, Set.mem_iUnion]\n    rcases hÏ€p x hxI with âŸ¨J, hJÏ€, hxJâŸ©\n    refine âŸ¨J, âŸ¨hJÏ€, ?_âŸ©, hxJâŸ©\n    contrapose hxF\n    refine hrs'F _ âŸ¨Ï€.tag_mem_Icc J, hxFâŸ© ?_\n    simpa only [r, s.piecewise_eq_of_not_mem _ _ hxF] using hÏ€.1 J hJÏ€ (Box.coe_subset_Icc hxJ)\n\n"}
{"name":"BoxIntegral.HasIntegral.of_aeEq_zero","module":"Mathlib.Analysis.BoxIntegral.Integrability","initialProofState":"Î¹ : Type u\nE : Type v\ninstâœÂ³ : Fintype Î¹\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box Î¹\nf : (Î¹ â†’ Real) â†’ E\nÎ¼ : MeasureTheory.Measure (Î¹ â†’ Real)\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nhf : (MeasureTheory.ae (Î¼.restrict â†‘I)).EventuallyEq f 0\nhl : Eq l.bRiemann Bool.false\nâŠ¢ BoxIntegral.HasIntegral I l f Î¼.toBoxAdditive.toSMul 0","decl":"/-- If `f` is a.e. equal to zero on a rectangular box, then it has McShane integral zero on this\nbox. -/\ntheorem HasIntegral.of_aeEq_zero {l : IntegrationParams} {I : Box Î¹} {f : (Î¹ â†’ â„) â†’ E}\n    {Î¼ : Measure (Î¹ â†’ â„)} [IsLocallyFiniteMeasure Î¼] (hf : f =áµ[Î¼.restrict I] 0)\n    (hl : l.bRiemann = false) : HasIntegral.{u, v, v} I l f Î¼.toBoxAdditive.toSMul 0 := by\n  /- Each set `{x | n < â€–f xâ€– â‰¤ n + 1}`, `n : â„•`, has measure zero. We cover it by an open set of\n    measure less than `Îµ / 2 ^ n / (n + 1)`. Then the norm of the integral sum is less than `Îµ`. -/\n  refine hasIntegral_iff.2 fun Îµ Îµ0 => ?_\n  lift Îµ to â„â‰¥0 using Îµ0.lt.le; rw [gt_iff_lt, NNReal.coe_pos] at Îµ0\n  rcases NNReal.exists_pos_sum_of_countable Îµ0.ne' â„• with âŸ¨Î´, Î´0, c, hÎ´c, hcÎµâŸ©\n  haveI := Fact.mk (I.measure_coe_lt_top Î¼)\n  change Î¼.restrict I {x | f x â‰  0} = 0 at hf\n  set N : (Î¹ â†’ â„) â†’ â„• := fun x => âŒˆâ€–f xâ€–âŒ‰â‚Š\n  have N0 : âˆ€ {x}, N x = 0 â†” f x = 0 := by simp [N]\n  have : âˆ€ n, âˆƒ U, N â»Â¹' {n} âŠ† U âˆ§ IsOpen U âˆ§ Î¼.restrict I U < Î´ n / n := fun n â†¦ by\n    refine (N â»Â¹' {n}).exists_isOpen_lt_of_lt _ ?_\n    cases' n with n\n    Â· simp [ENNReal.div_zero (ENNReal.coe_pos.2 (Î´0 _)).ne']\n    Â· refine (measure_mono_null ?_ hf).le.trans_lt ?_\n      Â· exact fun x hxN hxf => n.succ_ne_zero ((Eq.symm hxN).trans <| N0.2 hxf)\n      Â· simp [(Î´0 _).ne']\n  choose U hNU hUo hÎ¼U using this\n  have : âˆ€ x, âˆƒ r : Ioi (0 : â„), closedBall x r âŠ† U (N x) := fun x => by\n    obtain âŸ¨r, hrâ‚€, hrâŸ© := nhds_basis_closedBall.mem_iff.1 ((hUo _).mem_nhds (hNU _ rfl))\n    exact âŸ¨âŸ¨r, hrâ‚€âŸ©, hrâŸ©\n  choose r hrU using this\n  refine âŸ¨fun _ => r, fun c => l.rCond_of_bRiemann_eq_false hl, fun c Ï€ hÏ€ _ => ?_âŸ©\n  rw [dist_eq_norm, sub_zero, â† integralSum_fiberwise fun J => N (Ï€.tag J)]\n  refine le_trans ?_ (NNReal.coe_lt_coe.2 hcÎµ).le\n  refine (norm_sum_le_of_le _ ?_).trans\n    (sum_le_hasSum _ (fun n _ => (Î´ n).2) (NNReal.hasSum_coe.2 hÎ´c))\n  rintro n -\n  dsimp [integralSum]\n  have : âˆ€ J âˆˆ Ï€.filter fun J => N (Ï€.tag J) = n,\n      â€–(Î¼ â†‘J).toReal â€¢ f (Ï€.tag J)â€– â‰¤ (Î¼ J).toReal * n := fun J hJ â†¦ by\n    rw [TaggedPrepartition.mem_filter] at hJ\n    rw [norm_smul, Real.norm_eq_abs, abs_of_nonneg ENNReal.toReal_nonneg]\n    gcongr\n    exact hJ.2 â–¸ Nat.le_ceil _\n  refine (norm_sum_le_of_le _ this).trans ?_; clear this\n  rw [â† sum_mul, â† Prepartition.measure_iUnion_toReal]\n  let m := Î¼ (Ï€.filter fun J => N (Ï€.tag J) = n).iUnion\n  show m.toReal * â†‘n â‰¤ â†‘(Î´ n)\n  have : m < Î´ n / n := by\n    simp only [Measure.restrict_apply (hUo _).measurableSet] at hÎ¼U\n    refine (measure_mono ?_).trans_lt (hÎ¼U _)\n    simp only [Set.subset_def, TaggedPrepartition.mem_iUnion, TaggedPrepartition.mem_filter]\n    rintro x âŸ¨J, âŸ¨hJ, rflâŸ©, hxâŸ©\n    exact âŸ¨hrU _ (hÏ€.1 _ hJ (Box.coe_subset_Icc hx)), Ï€.le_of_mem' J hJ hxâŸ©\n  clear_value m\n  lift m to â„â‰¥0 using ne_top_of_lt this\n  rw [ENNReal.coe_toReal, â† NNReal.coe_natCast, â† NNReal.coe_mul, NNReal.coe_le_coe, â†\n    ENNReal.coe_le_coe, ENNReal.coe_mul, ENNReal.coe_natCast, mul_comm]\n  exact (mul_le_mul_left' this.le _).trans ENNReal.mul_div_le\n\n"}
{"name":"BoxIntegral.HasIntegral.congr_ae","module":"Mathlib.Analysis.BoxIntegral.Integrability","initialProofState":"Î¹ : Type u\nE : Type v\ninstâœÂ³ : Fintype Î¹\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box Î¹\ny : E\nf g : (Î¹ â†’ Real) â†’ E\nÎ¼ : MeasureTheory.Measure (Î¹ â†’ Real)\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nhf : BoxIntegral.HasIntegral I l f Î¼.toBoxAdditive.toSMul y\nhfg : (MeasureTheory.ae (Î¼.restrict â†‘I)).EventuallyEq f g\nhl : Eq l.bRiemann Bool.false\nâŠ¢ BoxIntegral.HasIntegral I l g Î¼.toBoxAdditive.toSMul y","decl":"/-- If `f` has integral `y` on a box `I` with respect to a locally finite measure `Î¼` and `g` is\na.e. equal to `f` on `I`, then `g` has the same integral on `I`. -/\ntheorem HasIntegral.congr_ae {l : IntegrationParams} {I : Box Î¹} {y : E} {f g : (Î¹ â†’ â„) â†’ E}\n    {Î¼ : Measure (Î¹ â†’ â„)} [IsLocallyFiniteMeasure Î¼]\n    (hf : HasIntegral.{u, v, v} I l f Î¼.toBoxAdditive.toSMul y) (hfg : f =áµ[Î¼.restrict I] g)\n    (hl : l.bRiemann = false) : HasIntegral.{u, v, v} I l g Î¼.toBoxAdditive.toSMul y := by\n  have : g - f =áµ[Î¼.restrict I] 0 := hfg.mono fun x hx => sub_eq_zero.2 hx.symm\n  simpa using hf.add (HasIntegral.of_aeEq_zero this hl)\n\n"}
{"name":"MeasureTheory.SimpleFunc.hasBoxIntegral","module":"Mathlib.Analysis.BoxIntegral.Integrability","initialProofState":"Î¹ : Type u\nE : Type v\ninstâœÂ³ : Fintype Î¹\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nf : MeasureTheory.SimpleFunc (Î¹ â†’ Real) E\nÎ¼ : MeasureTheory.Measure (Î¹ â†’ Real)\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nI : BoxIntegral.Box Î¹\nl : BoxIntegral.IntegrationParams\nhl : Eq l.bRiemann Bool.false\nâŠ¢ BoxIntegral.HasIntegral I l (â‡‘f) Î¼.toBoxAdditive.toSMul (MeasureTheory.SimpleFunc.integral (Î¼.restrict â†‘I) f)","decl":"/-- A simple function is McShane integrable w.r.t. any locally finite measure. -/\ntheorem hasBoxIntegral (f : SimpleFunc (Î¹ â†’ â„) E) (Î¼ : Measure (Î¹ â†’ â„)) [IsLocallyFiniteMeasure Î¼]\n    (I : Box Î¹) (l : IntegrationParams) (hl : l.bRiemann = false) :\n    HasIntegral.{u, v, v} I l f Î¼.toBoxAdditive.toSMul (f.integral (Î¼.restrict I)) := by\n  induction' f using MeasureTheory.SimpleFunc.induction with y s hs f g _ hfi hgi\n  Â· simpa only [Measure.restrict_apply hs, const_zero, integral_piecewise_zero, integral_const,\n      Measure.restrict_apply, MeasurableSet.univ, Set.univ_inter] using\n      BoxIntegral.hasIntegralIndicatorConst l hl hs I y Î¼\n  Â· borelize E; haveI := Fact.mk (I.measure_coe_lt_top Î¼)\n    rw [integral_add]\n    exacts [hfi.add hgi, integrable_iff.2 fun _ _ => measure_lt_top _ _,\n      integrable_iff.2 fun _ _ => measure_lt_top _ _]\n\n"}
{"name":"MeasureTheory.SimpleFunc.box_integral_eq_integral","module":"Mathlib.Analysis.BoxIntegral.Integrability","initialProofState":"Î¹ : Type u\nE : Type v\ninstâœÂ³ : Fintype Î¹\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nf : MeasureTheory.SimpleFunc (Î¹ â†’ Real) E\nÎ¼ : MeasureTheory.Measure (Î¹ â†’ Real)\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nI : BoxIntegral.Box Î¹\nl : BoxIntegral.IntegrationParams\nhl : Eq l.bRiemann Bool.false\nâŠ¢ Eq (BoxIntegral.integral I l (â‡‘f) Î¼.toBoxAdditive.toSMul) (MeasureTheory.SimpleFunc.integral (Î¼.restrict â†‘I) f)","decl":"/-- For a simple function, its McShane (or Henstock, or `âŠ¥`) box integral is equal to its\nintegral in the sense of `MeasureTheory.SimpleFunc.integral`. -/\ntheorem box_integral_eq_integral (f : SimpleFunc (Î¹ â†’ â„) E) (Î¼ : Measure (Î¹ â†’ â„))\n    [IsLocallyFiniteMeasure Î¼] (I : Box Î¹) (l : IntegrationParams) (hl : l.bRiemann = false) :\n    BoxIntegral.integral.{u, v, v} I l f Î¼.toBoxAdditive.toSMul = f.integral (Î¼.restrict I) :=\n  (f.hasBoxIntegral Î¼ I l hl).integral_eq\n\n"}
{"name":"MeasureTheory.IntegrableOn.hasBoxIntegral","module":"Mathlib.Analysis.BoxIntegral.Integrability","initialProofState":"Î¹ : Type u\nE : Type v\ninstâœâ´ : Fintype Î¹\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\nf : (Î¹ â†’ Real) â†’ E\nÎ¼ : MeasureTheory.Measure (Î¹ â†’ Real)\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nI : BoxIntegral.Box Î¹\nhf : MeasureTheory.IntegrableOn f (â†‘I) Î¼\nl : BoxIntegral.IntegrationParams\nhl : Eq l.bRiemann Bool.false\nâŠ¢ BoxIntegral.HasIntegral I l f Î¼.toBoxAdditive.toSMul (MeasureTheory.integral (Î¼.restrict â†‘I) fun x => f x)","decl":"/-- If `f : â„â¿ â†’ E` is Bochner integrable w.r.t. a locally finite measure `Î¼` on a rectangular box\n`I`, then it is McShane integrable on `I` with the same integral. -/\ntheorem IntegrableOn.hasBoxIntegral [CompleteSpace E] {f : (Î¹ â†’ â„) â†’ E} {Î¼ : Measure (Î¹ â†’ â„)}\n    [IsLocallyFiniteMeasure Î¼] {I : Box Î¹} (hf : IntegrableOn f I Î¼) (l : IntegrationParams)\n    (hl : l.bRiemann = false) :\n    HasIntegral.{u, v, v} I l f Î¼.toBoxAdditive.toSMul (âˆ« x in I, f x âˆ‚Î¼) := by\n  borelize E\n  -- First we replace an `ae_strongly_measurable` function by a measurable one.\n  rcases hf.aestronglyMeasurable with âŸ¨g, hg, hfgâŸ©\n  haveI : SeparableSpace (range g âˆª {0} : Set E) := hg.separableSpace_range_union_singleton\n  rw [integral_congr_ae hfg]; have hgi : IntegrableOn g I Î¼ := (integrable_congr hfg).1 hf\n  refine BoxIntegral.HasIntegral.congr_ae ?_ hfg.symm hl\n  clear! f\n  /- Now consider the sequence of simple functions\n    `SimpleFunc.approxOn g hg.measurable (range g âˆª {0}) 0 (by simp)`\n    approximating `g`. Recall some properties of this sequence. -/\n  set f : â„• â†’ SimpleFunc (Î¹ â†’ â„) E :=\n    SimpleFunc.approxOn g hg.measurable (range g âˆª {0}) 0 (by simp)\n  have hfi : âˆ€ n, IntegrableOn (f n) I Î¼ :=\n    SimpleFunc.integrable_approxOn_range hg.measurable hgi\n  have hfi' := fun n => ((f n).hasBoxIntegral Î¼ I l hl).integrable\n  have hfg_mono : âˆ€ (x) {m n}, m â‰¤ n â†’ â€–f n x - g xâ€– â‰¤ â€–f m x - g xâ€– := by\n    intro x m n hmn\n    rw [â† dist_eq_norm, â† dist_eq_norm, dist_nndist, dist_nndist, NNReal.coe_le_coe, â†\n      ENNReal.coe_le_coe, â† edist_nndist, â† edist_nndist]\n    exact SimpleFunc.edist_approxOn_mono hg.measurable _ x hmn\n  /- Now consider `Îµ > 0`. We need to find `r` such that for any tagged partition subordinate\n    to `r`, the integral sum is `(Î¼ I + 1 + 1) * Îµ`-close to the Bochner integral. -/\n  refine HasIntegral.of_mul ((Î¼ I).toReal + 1 + 1) fun Îµ Îµ0 => ?_\n  lift Îµ to â„â‰¥0 using Îµ0.le; rw [NNReal.coe_pos] at Îµ0; have Îµ0' := ENNReal.coe_pos.2 Îµ0\n  -- Choose `N` such that the integral of `â€–f N x - g xâ€–` is less than or equal to `Îµ`.\n  obtain âŸ¨Nâ‚€, hNâ‚€âŸ© : âˆƒ N : â„•, âˆ« x in I, â€–f N x - g xâ€– âˆ‚Î¼ â‰¤ Îµ := by\n    have : Tendsto (fun n => âˆ«â» x in I, â€–f n x - g xâ€–â‚Š âˆ‚Î¼) atTop (ğ“ 0) :=\n      SimpleFunc.tendsto_approxOn_range_L1_enorm hg.measurable hgi\n    refine (this.eventually (ge_mem_nhds Îµ0')).exists.imp fun N hN => ?_\n    exact integral_coe_le_of_lintegral_coe_le hN\n  -- For each `x`, we choose `Nx x â‰¥ Nâ‚€` such that `dist (f Nx x) (g x) â‰¤ Îµ`.\n  have : âˆ€ x, âˆƒ Nâ‚, Nâ‚€ â‰¤ Nâ‚ âˆ§ dist (f Nâ‚ x) (g x) â‰¤ Îµ := fun x â†¦ by\n    have : Tendsto (f Â· x) atTop (ğ“ <| g x) :=\n      SimpleFunc.tendsto_approxOn hg.measurable _ (subset_closure (by simp))\n    exact ((eventually_ge_atTop Nâ‚€).and <| this <| closedBall_mem_nhds _ Îµ0).exists\n  choose Nx hNx hNxÎµ using this\n  -- We also choose a convergent series with `âˆ‘' i : â„•, Î´ i < Îµ`.\n  rcases NNReal.exists_pos_sum_of_countable Îµ0.ne' â„• with âŸ¨Î´, Î´0, c, hÎ´c, hcÎµâŸ©\n  /- Since each simple function `fáµ¢` is integrable, there exists `ráµ¢ : â„â¿ â†’ (0, âˆ)` such that\n    the integral sum of `f` over any tagged prepartition is `Î´áµ¢`-close to the sum of integrals\n    of `fáµ¢` over the boxes of this prepartition. For each `x`, we choose `r (Nx x)` as the radius\n    at `x`. -/\n  set r : â„â‰¥0 â†’ (Î¹ â†’ â„) â†’ Ioi (0 : â„) := fun c x => (hfi' <| Nx x).convergenceR (Î´ <| Nx x) c x\n  refine âŸ¨r, fun c => l.rCond_of_bRiemann_eq_false hl, fun c Ï€ hÏ€ hÏ€p => ?_âŸ©\n  /- Now we prove the estimate in 3 \"jumps\": first we replace `g x` in the formula for the\n    integral sum by `f (Nx x)`; then we replace each `Î¼ J â€¢ f (Nx (Ï€.tag J)) (Ï€.tag J)`\n    by the Bochner integral of `f (Nx (Ï€.tag J)) x` over `J`, then we jump to the Bochner\n    integral of `g`. -/\n  refine (dist_triangle4 _ (âˆ‘ J âˆˆ Ï€.boxes, (Î¼ J).toReal â€¢ f (Nx <| Ï€.tag J) (Ï€.tag J))\n    (âˆ‘ J âˆˆ Ï€.boxes, âˆ« x in J, f (Nx <| Ï€.tag J) x âˆ‚Î¼) _).trans ?_\n  rw [add_mul, add_mul, one_mul]\n  refine add_le_add_three ?_ ?_ ?_\n  Â· /- Since each `f (Nx <| Ï€.tag J)` is `Îµ`-close to `g (Ï€.tag J)`, replacing the latter with\n        the former in the formula for the integral sum changes the sum at most by `Î¼ I * Îµ`. -/\n    rw [â† hÏ€p.iUnion_eq, Ï€.measure_iUnion_toReal, sum_mul, integralSum]\n    refine dist_sum_sum_le_of_le _ fun J _ => ?_; dsimp\n    rw [dist_eq_norm, â† smul_sub, norm_smul, Real.norm_eq_abs, abs_of_nonneg ENNReal.toReal_nonneg]\n    gcongr\n    rw [â† dist_eq_norm']; exact hNxÎµ _\n  Â· /- We group the terms of both sums by the values of `Nx (Ï€.tag J)`.\n        For each `N`, the sum of Bochner integrals over the boxes is equal\n        to the sum of box integrals, and the sum of box integrals is `Î´áµ¢`-close\n        to the corresponding integral sum due to the Henstock-Sacks inequality. -/\n    rw [â† Ï€.sum_fiberwise fun J => Nx (Ï€.tag J), â† Ï€.sum_fiberwise fun J => Nx (Ï€.tag J)]\n    refine le_trans ?_ (NNReal.coe_lt_coe.2 hcÎµ).le\n    refine\n      (dist_sum_sum_le_of_le _ fun n hn => ?_).trans\n        (sum_le_hasSum _ (fun n _ => (Î´ n).2) (NNReal.hasSum_coe.2 hÎ´c))\n    have hNxn : âˆ€ J âˆˆ Ï€.filter fun J => Nx (Ï€.tag J) = n, Nx (Ï€.tag J) = n := fun J hJ =>\n      (Ï€.mem_filter.1 hJ).2\n    have hrn : âˆ€ J âˆˆ Ï€.filter fun J => Nx (Ï€.tag J) = n,\n        r c (Ï€.tag J) = (hfi' n).convergenceR (Î´ n) c (Ï€.tag J) := fun J hJ â†¦ by\n      obtain rfl := hNxn J hJ\n      rfl\n    have :\n        l.MemBaseSet I c ((hfi' n).convergenceR (Î´ n) c) (Ï€.filter fun J => Nx (Ï€.tag J) = n) :=\n      (hÏ€.filter _).mono' _ le_rfl le_rfl fun J hJ => (hrn J hJ).le\n    convert (hfi' n).dist_integralSum_sum_integral_le_of_memBaseSet (Î´0 _) this using 2\n    Â· refine sum_congr rfl fun J hJ => ?_\n      simp [hNxn J hJ]\n    Â· refine sum_congr rfl fun J hJ => ?_\n      rw [â† SimpleFunc.integral_eq_integral, SimpleFunc.box_integral_eq_integral _ _ _ _ hl,\n        hNxn J hJ]\n      exact (hfi _).mono_set (Prepartition.le_of_mem _ hJ)\n  Â· /-  For the last jump, we use the fact that the distance between `f (Nx x) x` and `g x` is less\n        than or equal to the distance between `f Nâ‚€ x` and `g x` and the integral of\n        `â€–f Nâ‚€ x - g xâ€–` is less than or equal to `Îµ`. -/\n    refine le_trans ?_ hNâ‚€\n    have hfi : âˆ€ (n), âˆ€ J âˆˆ Ï€, IntegrableOn (f n) (â†‘J) Î¼ := fun n J hJ =>\n      (hfi n).mono_set (Ï€.le_of_mem' J hJ)\n    have hgi : âˆ€ J âˆˆ Ï€, IntegrableOn g (â†‘J) Î¼ := fun J hJ => hgi.mono_set (Ï€.le_of_mem' J hJ)\n    have hfgi : âˆ€ (n), âˆ€ J âˆˆ Ï€, IntegrableOn (fun x => â€–f n x - g xâ€–) J Î¼ := fun n J hJ =>\n      ((hfi n J hJ).sub (hgi J hJ)).norm\n    rw [â† hÏ€p.iUnion_eq, Prepartition.iUnion_def',\n      integral_finset_biUnion Ï€.boxes (fun J _ => J.measurableSet_coe) Ï€.pairwiseDisjoint hgi,\n      integral_finset_biUnion Ï€.boxes (fun J _ => J.measurableSet_coe) Ï€.pairwiseDisjoint (hfgi _)]\n    refine dist_sum_sum_le_of_le _ fun J hJ => ?_\n    rw [dist_eq_norm, â† integral_sub (hfi _ J hJ) (hgi J hJ)]\n    refine norm_integral_le_of_norm_le (hfgi _ J hJ) (Eventually.of_forall fun x => ?_)\n    exact hfg_mono x (hNx (Ï€.tag J))\n\n"}
{"name":"MeasureTheory.ContinuousOn.hasBoxIntegral","module":"Mathlib.Analysis.BoxIntegral.Integrability","initialProofState":"Î¹ : Type u\nE : Type v\ninstâœâ´ : Fintype Î¹\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\nf : (Î¹ â†’ Real) â†’ E\nÎ¼ : MeasureTheory.Measure (Î¹ â†’ Real)\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nI : BoxIntegral.Box Î¹\nhc : ContinuousOn f (BoxIntegral.Box.Icc I)\nl : BoxIntegral.IntegrationParams\nâŠ¢ BoxIntegral.HasIntegral I l f Î¼.toBoxAdditive.toSMul (MeasureTheory.integral (Î¼.restrict â†‘I) fun x => f x)","decl":"/-- If `f : â„â¿ â†’ E` is continuous on a rectangular box `I`, then it is Box integrable on `I`\nw.r.t. a locally finite measure `Î¼` with the same integral. -/\ntheorem ContinuousOn.hasBoxIntegral [CompleteSpace E] {f : (Î¹ â†’ â„) â†’ E} (Î¼ : Measure (Î¹ â†’ â„))\n    [IsLocallyFiniteMeasure Î¼] {I : Box Î¹} (hc : ContinuousOn f (Box.Icc I))\n    (l : IntegrationParams) :\n    HasIntegral.{u, v, v} I l f Î¼.toBoxAdditive.toSMul (âˆ« x in I, f x âˆ‚Î¼) := by\n  obtain âŸ¨y, hyâŸ© := BoxIntegral.integrable_of_continuousOn l hc Î¼\n  convert hy\n  have : IntegrableOn f I Î¼ :=\n    IntegrableOn.mono_set (hc.integrableOn_compact I.isCompact_Icc) Box.coe_subset_Icc\n  exact HasIntegral.unique (IntegrableOn.hasBoxIntegral this âŠ¥ rfl) (HasIntegral.mono hy bot_le)\n\n"}
{"name":"MeasureTheory.AEContinuous.hasBoxIntegral","module":"Mathlib.Analysis.BoxIntegral.Integrability","initialProofState":"Î¹ : Type u\nE : Type v\ninstâœâ´ : Fintype Î¹\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\nf : (Î¹ â†’ Real) â†’ E\nÎ¼ : MeasureTheory.Measure (Î¹ â†’ Real)\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nI : BoxIntegral.Box Î¹\nhb : Exists fun C => âˆ€ (x : Î¹ â†’ Real), Membership.mem (BoxIntegral.Box.Icc I) x â†’ LE.le (Norm.norm (f x)) C\nhc : Filter.Eventually (fun x => ContinuousAt f x) (MeasureTheory.ae Î¼)\nl : BoxIntegral.IntegrationParams\nâŠ¢ BoxIntegral.HasIntegral I l f Î¼.toBoxAdditive.toSMul (MeasureTheory.integral (Î¼.restrict â†‘I) fun x => f x)","decl":"/-- If `f : â„â¿ â†’ E` is a.e. continuous and bounded on a rectangular box `I`, then it is Box\n    integrable on `I` w.r.t. a locally finite measure `Î¼` with the same integral. -/\ntheorem AEContinuous.hasBoxIntegral [CompleteSpace E] {f : (Î¹ â†’ â„) â†’ E} (Î¼ : Measure (Î¹ â†’ â„))\n    [IsLocallyFiniteMeasure Î¼] {I : Box Î¹} (hb : âˆƒ C : â„, âˆ€ x âˆˆ Box.Icc I, â€–f xâ€– â‰¤ C)\n    (hc : âˆ€áµ x âˆ‚Î¼, ContinuousAt f x) (l : IntegrationParams) :\n    HasIntegral.{u, v, v} I l f Î¼.toBoxAdditive.toSMul (âˆ« x in I, f x âˆ‚Î¼) := by\n  obtain âŸ¨y, hyâŸ© := integrable_of_bounded_and_ae_continuous l hb Î¼ hc\n  convert hy\n  refine HasIntegral.unique (IntegrableOn.hasBoxIntegral ?_ âŠ¥ rfl) (HasIntegral.mono hy bot_le)\n  constructor\n  Â· let v := {x : (Î¹ â†’ â„) | ContinuousAt f x}\n    have : AEStronglyMeasurable f (Î¼.restrict v) :=\n      (continuousOn_of_forall_continuousAt fun _ h â†¦ h).aestronglyMeasurable\n      (measurableSet_of_continuousAt f)\n    refine this.mono_measure (Measure.le_iff.2 fun s hs â†¦ ?_)\n    repeat rw [Î¼.restrict_apply hs]\n    apply le_of_le_of_eq <| Î¼.mono s.inter_subset_left\n    refine measure_eq_measure_of_null_diff s.inter_subset_left ?_ |>.symm\n    rw [diff_self_inter, Set.diff_eq]\n    refine (le_antisymm (zero_le (Î¼ (s âˆ© vá¶œ))) ?_).symm\n    exact le_trans (Î¼.mono s.inter_subset_right) (nonpos_iff_eq_zero.2 hc)\n  Â· have : IsFiniteMeasure (Î¼.restrict (Box.Icc I)) :=\n      { measure_univ_lt_top := by simp [I.isCompact_Icc.measure_lt_top (Î¼ := Î¼)] }\n    have : IsFiniteMeasure (Î¼.restrict I) :=\n      isFiniteMeasure_of_le (Î¼.restrict (Box.Icc I))\n                            (Î¼.restrict_mono Box.coe_subset_Icc (le_refl Î¼))\n    obtain âŸ¨C, hCâŸ© := hb\n    refine hasFiniteIntegral_of_bounded (C := C) (Filter.eventually_iff_exists_mem.2 ?_)\n    use I, self_mem_ae_restrict I.measurableSet_coe, fun y hy â†¦ hC y (I.coe_subset_Icc hy)\n\n"}
