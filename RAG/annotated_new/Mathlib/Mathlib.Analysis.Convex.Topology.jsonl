{"name":"Real.closedBall_eq_segment","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"r Œµ : Real\nhŒµ : LE.le 0 Œµ\n‚ä¢ Eq (Metric.closedBall r Œµ) (segment Real (HSub.hSub r Œµ) (HAdd.hAdd r Œµ))","decl":"lemma closedBall_eq_segment (hŒµ : 0 ‚â§ Œµ) : closedBall r Œµ = segment ‚Ñù (r - Œµ) (r + Œµ) := by\n  rw [closedBall_eq_Icc, segment_eq_Icc ((sub_le_self _ hŒµ).trans <| le_add_of_nonneg_right hŒµ)]\n\n"}
{"name":"Real.ball_eq_openSegment","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"r Œµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Eq (Metric.ball r Œµ) (openSegment Real (HSub.hSub r Œµ) (HAdd.hAdd r Œµ))","decl":"lemma ball_eq_openSegment (hŒµ : 0 < Œµ) : ball r Œµ = openSegment ‚Ñù (r - Œµ) (r + Œµ) := by\n  rw [ball_eq_Ioo, openSegment_eq_Ioo ((sub_lt_self _ hŒµ).trans <| lt_add_of_pos_right _ hŒµ)]\n\n"}
{"name":"Real.convex_iff_isPreconnected","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"s : Set Real\n‚ä¢ Iff (Convex Real s) (IsPreconnected s)","decl":"theorem convex_iff_isPreconnected : Convex ‚Ñù s ‚Üî IsPreconnected s :=\n  convex_iff_ordConnected.trans isPreconnected_iff_ordConnected.symm\n\n"}
{"name":"IsPreconnected.convex","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"s : Set Real\na‚úù : IsPreconnected s\n‚ä¢ Convex Real s","decl":"alias ‚ü®_, IsPreconnected.convex‚ü© := Real.convex_iff_isPreconnected\n\n"}
{"name":"stdSimplex_subset_closedBall","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\n‚ä¢ HasSubset.Subset (stdSimplex Real Œπ) (Metric.closedBall 0 1)","decl":"/-- Every vector in `stdSimplex ùïú Œπ` has `max`-norm at most `1`. -/\ntheorem stdSimplex_subset_closedBall : stdSimplex ‚Ñù Œπ ‚äÜ Metric.closedBall 0 1 := fun f hf ‚Ü¶ by\n  rw [Metric.mem_closedBall, dist_pi_le_iff zero_le_one]\n  intro x\n  rw [Pi.zero_apply, Real.dist_0_eq_abs, abs_of_nonneg <| hf.1 x]\n  exact (mem_Icc_of_mem_stdSimplex hf x).2\n\n"}
{"name":"bounded_stdSimplex","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\n‚ä¢ Bornology.IsBounded (stdSimplex Real Œπ)","decl":"/-- `stdSimplex ‚Ñù Œπ` is bounded. -/\ntheorem bounded_stdSimplex : IsBounded (stdSimplex ‚Ñù Œπ) :=\n  (Metric.isBounded_iff_subset_closedBall 0).2 ‚ü®1, stdSimplex_subset_closedBall‚ü©\n\n"}
{"name":"isClosed_stdSimplex","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\n‚ä¢ IsClosed (stdSimplex Real Œπ)","decl":"/-- `stdSimplex ‚Ñù Œπ` is closed. -/\ntheorem isClosed_stdSimplex : IsClosed (stdSimplex ‚Ñù Œπ) :=\n  (stdSimplex_eq_inter ‚Ñù Œπ).symm ‚ñ∏\n    IsClosed.inter (isClosed_iInter fun i => isClosed_le continuous_const (continuous_apply i))\n      (isClosed_eq (continuous_finset_sum _ fun x _ => continuous_apply x) continuous_const)\n\n"}
{"name":"isCompact_stdSimplex","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\n‚ä¢ IsCompact (stdSimplex Real Œπ)","decl":"/-- `stdSimplex ‚Ñù Œπ` is compact. -/\ntheorem isCompact_stdSimplex : IsCompact (stdSimplex ‚Ñù Œπ) :=\n  Metric.isCompact_iff_isClosed_bounded.2 ‚ü®isClosed_stdSimplex Œπ, bounded_stdSimplex Œπ‚ü©\n\n"}
{"name":"stdSimplex.instCompactSpace_coe","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\n‚ä¢ CompactSpace ‚Üë(stdSimplex Real Œπ)","decl":"instance stdSimplex.instCompactSpace_coe : CompactSpace ‚Ü•(stdSimplex ‚Ñù Œπ) :=\n  isCompact_iff_compactSpace.mp <| isCompact_stdSimplex _\n\n"}
{"name":"stdSimplexHomeomorphUnitInterval_apply_coe","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"f : ‚Üë(stdSimplex Real (Fin 2))\n‚ä¢ Eq (‚Üë(stdSimplexHomeomorphUnitInterval f)) (‚Üëf 0)","decl":"/-- The standard one-dimensional simplex in `‚Ñù¬≤ = Fin 2 ‚Üí ‚Ñù`\nis homeomorphic to the unit interval. -/\n@[simps! (config := .asFn)]\ndef stdSimplexHomeomorphUnitInterval : stdSimplex ‚Ñù (Fin 2) ‚âÉ‚Çú unitInterval where\n  toEquiv := stdSimplexEquivIcc ‚Ñù\n  continuous_toFun := .subtype_mk ((continuous_apply 0).comp continuous_subtype_val) _\n  continuous_invFun := by\n    apply Continuous.subtype_mk\n    exact (continuous_pi <| Fin.forall_fin_two.2\n      ‚ü®continuous_subtype_val, continuous_const.sub continuous_subtype_val‚ü©)\n\n"}
{"name":"stdSimplexHomeomorphUnitInterval_symm_apply_coe","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"x : ‚Üë(Set.Icc 0 1)\n‚ä¢ Eq (‚Üë(stdSimplexHomeomorphUnitInterval.symm x)) (Matrix.vecCons (‚Üëx) (Matrix.vecCons (HSub.hSub 1 ‚Üëx) Matrix.vecEmpty))","decl":"/-- The standard one-dimensional simplex in `‚Ñù¬≤ = Fin 2 ‚Üí ‚Ñù`\nis homeomorphic to the unit interval. -/\n@[simps! (config := .asFn)]\ndef stdSimplexHomeomorphUnitInterval : stdSimplex ‚Ñù (Fin 2) ‚âÉ‚Çú unitInterval where\n  toEquiv := stdSimplexEquivIcc ‚Ñù\n  continuous_toFun := .subtype_mk ((continuous_apply 0).comp continuous_subtype_val) _\n  continuous_invFun := by\n    apply Continuous.subtype_mk\n    exact (continuous_pi <| Fin.forall_fin_two.2\n      ‚ü®continuous_subtype_val, continuous_const.sub continuous_subtype_val‚ü©)\n\n"}
{"name":"segment_subset_closure_openSegment","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù‚Å∏ : LinearOrderedRing ùïú\ninst‚úù‚Å∑ : DenselyOrdered ùïú\ninst‚úù‚Å∂ : TopologicalSpace ùïú\ninst‚úù‚Åµ : OrderTopology ùïú\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : TopologicalSpace E\ninst‚úù¬≤ : ContinuousAdd E\ninst‚úù¬π : Module ùïú E\ninst‚úù : ContinuousSMul ùïú E\nx y : E\n‚ä¢ HasSubset.Subset (segment ùïú x y) (closure (openSegment ùïú x y))","decl":"theorem segment_subset_closure_openSegment : [x -[ùïú] y] ‚äÜ closure (openSegment ùïú x y) := by\n  rw [segment_eq_image, openSegment_eq_image, ‚Üê closure_Ioo (zero_ne_one' ùïú)]\n  exact image_closure_subset_closure_image (by fun_prop)\n\n"}
{"name":"closure_openSegment","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù¬π¬π : LinearOrderedRing ùïú\ninst‚úù¬π‚Å∞ : DenselyOrdered ùïú\ninst‚úù‚Åπ : PseudoMetricSpace ùïú\ninst‚úù‚Å∏ : OrderTopology ùïú\ninst‚úù‚Å∑ : ProperSpace ùïú\ninst‚úù‚Å∂ : CompactIccSpace ùïú\ninst‚úù‚Åµ : AddCommGroup E\ninst‚úù‚Å¥ : TopologicalSpace E\ninst‚úù¬≥ : T2Space E\ninst‚úù¬≤ : ContinuousAdd E\ninst‚úù¬π : Module ùïú E\ninst‚úù : ContinuousSMul ùïú E\nx y : E\n‚ä¢ Eq (closure (openSegment ùïú x y)) (segment ùïú x y)","decl":"@[simp]\ntheorem closure_openSegment (x y : E) : closure (openSegment ùïú x y) = [x -[ùïú] y] := by\n  rw [segment_eq_image, openSegment_eq_image, ‚Üê closure_Ioo (zero_ne_one' ùïú)]\n  exact (image_closure_of_isCompact (isBounded_Ioo _ _).isCompact_closure <|\n    Continuous.continuousOn <| by fun_prop).symm\n\n"}
{"name":"Convex.combo_interior_closure_subset_interior","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù‚Åµ : LinearOrderedField ùïú\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module ùïú E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousConstSMul ùïú E\ns : Set E\nhs : Convex ùïú s\na b : ùïú\nha : LT.lt 0 a\nhb : LE.le 0 b\nhab : Eq (HAdd.hAdd a b) 1\n‚ä¢ HasSubset.Subset (HAdd.hAdd (HSMul.hSMul a (interior s)) (HSMul.hSMul b (closure s))) (interior s)","decl":"/-- If `s` is a convex set, then `a ‚Ä¢ interior s + b ‚Ä¢ closure s ‚äÜ interior s` for all `0 < a`,\n`0 ‚â§ b`, `a + b = 1`. See also `Convex.combo_interior_self_subset_interior` for a weaker version. -/\ntheorem Convex.combo_interior_closure_subset_interior {s : Set E} (hs : Convex ùïú s) {a b : ùïú}\n    (ha : 0 < a) (hb : 0 ‚â§ b) (hab : a + b = 1) : a ‚Ä¢ interior s + b ‚Ä¢ closure s ‚äÜ interior s :=\n  interior_smul‚ÇÄ ha.ne' s ‚ñ∏\n    calc\n      interior (a ‚Ä¢ s) + b ‚Ä¢ closure s ‚äÜ interior (a ‚Ä¢ s) + closure (b ‚Ä¢ s) :=\n        add_subset_add Subset.rfl (smul_closure_subset b s)\n      _ = interior (a ‚Ä¢ s) + b ‚Ä¢ s := by rw [isOpen_interior.add_closure (b ‚Ä¢ s)]\n      _ ‚äÜ interior (a ‚Ä¢ s + b ‚Ä¢ s) := subset_interior_add_left\n      _ ‚äÜ interior s := interior_mono <| hs.set_combo_subset ha.le hb hab\n\n"}
{"name":"Convex.combo_interior_self_subset_interior","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù‚Åµ : LinearOrderedField ùïú\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module ùïú E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousConstSMul ùïú E\ns : Set E\nhs : Convex ùïú s\na b : ùïú\nha : LT.lt 0 a\nhb : LE.le 0 b\nhab : Eq (HAdd.hAdd a b) 1\n‚ä¢ HasSubset.Subset (HAdd.hAdd (HSMul.hSMul a (interior s)) (HSMul.hSMul b s)) (interior s)","decl":"/-- If `s` is a convex set, then `a ‚Ä¢ interior s + b ‚Ä¢ s ‚äÜ interior s` for all `0 < a`, `0 ‚â§ b`,\n`a + b = 1`. See also `Convex.combo_interior_closure_subset_interior` for a stronger version. -/\ntheorem Convex.combo_interior_self_subset_interior {s : Set E} (hs : Convex ùïú s) {a b : ùïú}\n    (ha : 0 < a) (hb : 0 ‚â§ b) (hab : a + b = 1) : a ‚Ä¢ interior s + b ‚Ä¢ s ‚äÜ interior s :=\n  calc\n    a ‚Ä¢ interior s + b ‚Ä¢ s ‚äÜ a ‚Ä¢ interior s + b ‚Ä¢ closure s :=\n      add_subset_add Subset.rfl <| image_subset _ subset_closure\n    _ ‚äÜ interior s := hs.combo_interior_closure_subset_interior ha hb hab\n\n"}
{"name":"Convex.combo_closure_interior_subset_interior","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù‚Åµ : LinearOrderedField ùïú\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module ùïú E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousConstSMul ùïú E\ns : Set E\nhs : Convex ùïú s\na b : ùïú\nha : LE.le 0 a\nhb : LT.lt 0 b\nhab : Eq (HAdd.hAdd a b) 1\n‚ä¢ HasSubset.Subset (HAdd.hAdd (HSMul.hSMul a (closure s)) (HSMul.hSMul b (interior s))) (interior s)","decl":"/-- If `s` is a convex set, then `a ‚Ä¢ closure s + b ‚Ä¢ interior s ‚äÜ interior s` for all `0 ‚â§ a`,\n`0 < b`, `a + b = 1`. See also `Convex.combo_self_interior_subset_interior` for a weaker version. -/\ntheorem Convex.combo_closure_interior_subset_interior {s : Set E} (hs : Convex ùïú s) {a b : ùïú}\n    (ha : 0 ‚â§ a) (hb : 0 < b) (hab : a + b = 1) : a ‚Ä¢ closure s + b ‚Ä¢ interior s ‚äÜ interior s := by\n  rw [add_comm]\n  exact hs.combo_interior_closure_subset_interior hb ha (add_comm a b ‚ñ∏ hab)\n\n"}
{"name":"Convex.combo_self_interior_subset_interior","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù‚Åµ : LinearOrderedField ùïú\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module ùïú E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousConstSMul ùïú E\ns : Set E\nhs : Convex ùïú s\na b : ùïú\nha : LE.le 0 a\nhb : LT.lt 0 b\nhab : Eq (HAdd.hAdd a b) 1\n‚ä¢ HasSubset.Subset (HAdd.hAdd (HSMul.hSMul a s) (HSMul.hSMul b (interior s))) (interior s)","decl":"/-- If `s` is a convex set, then `a ‚Ä¢ s + b ‚Ä¢ interior s ‚äÜ interior s` for all `0 ‚â§ a`, `0 < b`,\n`a + b = 1`. See also `Convex.combo_closure_interior_subset_interior` for a stronger version. -/\ntheorem Convex.combo_self_interior_subset_interior {s : Set E} (hs : Convex ùïú s) {a b : ùïú}\n    (ha : 0 ‚â§ a) (hb : 0 < b) (hab : a + b = 1) : a ‚Ä¢ s + b ‚Ä¢ interior s ‚äÜ interior s := by\n  rw [add_comm]\n  exact hs.combo_interior_self_subset_interior hb ha (add_comm a b ‚ñ∏ hab)\n\n"}
{"name":"Convex.combo_interior_closure_mem_interior","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù‚Åµ : LinearOrderedField ùïú\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module ùïú E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousConstSMul ùïú E\ns : Set E\nhs : Convex ùïú s\nx y : E\nhx : Membership.mem (interior s) x\nhy : Membership.mem (closure s) y\na b : ùïú\nha : LT.lt 0 a\nhb : LE.le 0 b\nhab : Eq (HAdd.hAdd a b) 1\n‚ä¢ Membership.mem (interior s) (HAdd.hAdd (HSMul.hSMul a x) (HSMul.hSMul b y))","decl":"theorem Convex.combo_interior_closure_mem_interior {s : Set E} (hs : Convex ùïú s) {x y : E}\n    (hx : x ‚àà interior s) (hy : y ‚àà closure s) {a b : ùïú} (ha : 0 < a) (hb : 0 ‚â§ b)\n    (hab : a + b = 1) : a ‚Ä¢ x + b ‚Ä¢ y ‚àà interior s :=\n  hs.combo_interior_closure_subset_interior ha hb hab <|\n    add_mem_add (smul_mem_smul_set hx) (smul_mem_smul_set hy)\n\n"}
{"name":"Convex.combo_interior_self_mem_interior","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù‚Åµ : LinearOrderedField ùïú\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module ùïú E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousConstSMul ùïú E\ns : Set E\nhs : Convex ùïú s\nx y : E\nhx : Membership.mem (interior s) x\nhy : Membership.mem s y\na b : ùïú\nha : LT.lt 0 a\nhb : LE.le 0 b\nhab : Eq (HAdd.hAdd a b) 1\n‚ä¢ Membership.mem (interior s) (HAdd.hAdd (HSMul.hSMul a x) (HSMul.hSMul b y))","decl":"theorem Convex.combo_interior_self_mem_interior {s : Set E} (hs : Convex ùïú s) {x y : E}\n    (hx : x ‚àà interior s) (hy : y ‚àà s) {a b : ùïú} (ha : 0 < a) (hb : 0 ‚â§ b) (hab : a + b = 1) :\n    a ‚Ä¢ x + b ‚Ä¢ y ‚àà interior s :=\n  hs.combo_interior_closure_mem_interior hx (subset_closure hy) ha hb hab\n\n"}
{"name":"Convex.combo_closure_interior_mem_interior","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù‚Åµ : LinearOrderedField ùïú\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module ùïú E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousConstSMul ùïú E\ns : Set E\nhs : Convex ùïú s\nx y : E\nhx : Membership.mem (closure s) x\nhy : Membership.mem (interior s) y\na b : ùïú\nha : LE.le 0 a\nhb : LT.lt 0 b\nhab : Eq (HAdd.hAdd a b) 1\n‚ä¢ Membership.mem (interior s) (HAdd.hAdd (HSMul.hSMul a x) (HSMul.hSMul b y))","decl":"theorem Convex.combo_closure_interior_mem_interior {s : Set E} (hs : Convex ùïú s) {x y : E}\n    (hx : x ‚àà closure s) (hy : y ‚àà interior s) {a b : ùïú} (ha : 0 ‚â§ a) (hb : 0 < b)\n    (hab : a + b = 1) : a ‚Ä¢ x + b ‚Ä¢ y ‚àà interior s :=\n  hs.combo_closure_interior_subset_interior ha hb hab <|\n    add_mem_add (smul_mem_smul_set hx) (smul_mem_smul_set hy)\n\n"}
{"name":"Convex.combo_self_interior_mem_interior","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù‚Åµ : LinearOrderedField ùïú\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module ùïú E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousConstSMul ùïú E\ns : Set E\nhs : Convex ùïú s\nx y : E\nhx : Membership.mem s x\nhy : Membership.mem (interior s) y\na b : ùïú\nha : LE.le 0 a\nhb : LT.lt 0 b\nhab : Eq (HAdd.hAdd a b) 1\n‚ä¢ Membership.mem (interior s) (HAdd.hAdd (HSMul.hSMul a x) (HSMul.hSMul b y))","decl":"theorem Convex.combo_self_interior_mem_interior {s : Set E} (hs : Convex ùïú s) {x y : E} (hx : x ‚àà s)\n    (hy : y ‚àà interior s) {a b : ùïú} (ha : 0 ‚â§ a) (hb : 0 < b) (hab : a + b = 1) :\n    a ‚Ä¢ x + b ‚Ä¢ y ‚àà interior s :=\n  hs.combo_closure_interior_mem_interior (subset_closure hx) hy ha hb hab\n\n"}
{"name":"Convex.openSegment_interior_closure_subset_interior","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù‚Åµ : LinearOrderedField ùïú\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module ùïú E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousConstSMul ùïú E\ns : Set E\nhs : Convex ùïú s\nx y : E\nhx : Membership.mem (interior s) x\nhy : Membership.mem (closure s) y\n‚ä¢ HasSubset.Subset (openSegment ùïú x y) (interior s)","decl":"theorem Convex.openSegment_interior_closure_subset_interior {s : Set E} (hs : Convex ùïú s) {x y : E}\n    (hx : x ‚àà interior s) (hy : y ‚àà closure s) : openSegment ùïú x y ‚äÜ interior s := by\n  rintro _ ‚ü®a, b, ha, hb, hab, rfl‚ü©\n  exact hs.combo_interior_closure_mem_interior hx hy ha hb.le hab\n\n"}
{"name":"Convex.openSegment_interior_self_subset_interior","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù‚Åµ : LinearOrderedField ùïú\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module ùïú E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousConstSMul ùïú E\ns : Set E\nhs : Convex ùïú s\nx y : E\nhx : Membership.mem (interior s) x\nhy : Membership.mem s y\n‚ä¢ HasSubset.Subset (openSegment ùïú x y) (interior s)","decl":"theorem Convex.openSegment_interior_self_subset_interior {s : Set E} (hs : Convex ùïú s) {x y : E}\n    (hx : x ‚àà interior s) (hy : y ‚àà s) : openSegment ùïú x y ‚äÜ interior s :=\n  hs.openSegment_interior_closure_subset_interior hx (subset_closure hy)\n\n"}
{"name":"Convex.openSegment_closure_interior_subset_interior","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù‚Åµ : LinearOrderedField ùïú\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module ùïú E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousConstSMul ùïú E\ns : Set E\nhs : Convex ùïú s\nx y : E\nhx : Membership.mem (closure s) x\nhy : Membership.mem (interior s) y\n‚ä¢ HasSubset.Subset (openSegment ùïú x y) (interior s)","decl":"theorem Convex.openSegment_closure_interior_subset_interior {s : Set E} (hs : Convex ùïú s) {x y : E}\n    (hx : x ‚àà closure s) (hy : y ‚àà interior s) : openSegment ùïú x y ‚äÜ interior s := by\n  rintro _ ‚ü®a, b, ha, hb, hab, rfl‚ü©\n  exact hs.combo_closure_interior_mem_interior hx hy ha.le hb hab\n\n"}
{"name":"Convex.openSegment_self_interior_subset_interior","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù‚Åµ : LinearOrderedField ùïú\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module ùïú E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousConstSMul ùïú E\ns : Set E\nhs : Convex ùïú s\nx y : E\nhx : Membership.mem s x\nhy : Membership.mem (interior s) y\n‚ä¢ HasSubset.Subset (openSegment ùïú x y) (interior s)","decl":"theorem Convex.openSegment_self_interior_subset_interior {s : Set E} (hs : Convex ùïú s) {x y : E}\n    (hx : x ‚àà s) (hy : y ‚àà interior s) : openSegment ùïú x y ‚äÜ interior s :=\n  hs.openSegment_closure_interior_subset_interior (subset_closure hx) hy\n\n"}
{"name":"Convex.add_smul_sub_mem_interior'","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù‚Åµ : LinearOrderedField ùïú\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module ùïú E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousConstSMul ùïú E\ns : Set E\nhs : Convex ùïú s\nx y : E\nhx : Membership.mem (closure s) x\nhy : Membership.mem (interior s) y\nt : ùïú\nht : Membership.mem (Set.Ioc 0 1) t\n‚ä¢ Membership.mem (interior s) (HAdd.hAdd x (HSMul.hSMul t (HSub.hSub y x)))","decl":"/-- If `x ‚àà closure s` and `y ‚àà interior s`, then the segment `(x, y]` is included in `interior s`.\n-/\ntheorem Convex.add_smul_sub_mem_interior' {s : Set E} (hs : Convex ùïú s) {x y : E}\n    (hx : x ‚àà closure s) (hy : y ‚àà interior s) {t : ùïú} (ht : t ‚àà Ioc (0 : ùïú) 1) :\n    x + t ‚Ä¢ (y - x) ‚àà interior s := by\n  simpa only [sub_smul, smul_sub, one_smul, add_sub, add_comm] using\n    hs.combo_interior_closure_mem_interior hy hx ht.1 (sub_nonneg.mpr ht.2)\n      (add_sub_cancel _ _)\n\n"}
{"name":"Convex.add_smul_sub_mem_interior","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù‚Åµ : LinearOrderedField ùïú\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module ùïú E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousConstSMul ùïú E\ns : Set E\nhs : Convex ùïú s\nx y : E\nhx : Membership.mem s x\nhy : Membership.mem (interior s) y\nt : ùïú\nht : Membership.mem (Set.Ioc 0 1) t\n‚ä¢ Membership.mem (interior s) (HAdd.hAdd x (HSMul.hSMul t (HSub.hSub y x)))","decl":"/-- If `x ‚àà s` and `y ‚àà interior s`, then the segment `(x, y]` is included in `interior s`. -/\ntheorem Convex.add_smul_sub_mem_interior {s : Set E} (hs : Convex ùïú s) {x y : E} (hx : x ‚àà s)\n    (hy : y ‚àà interior s) {t : ùïú} (ht : t ‚àà Ioc (0 : ùïú) 1) : x + t ‚Ä¢ (y - x) ‚àà interior s :=\n  hs.add_smul_sub_mem_interior' (subset_closure hx) hy ht\n\n"}
{"name":"Convex.add_smul_mem_interior'","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù‚Åµ : LinearOrderedField ùïú\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module ùïú E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousConstSMul ùïú E\ns : Set E\nhs : Convex ùïú s\nx y : E\nhx : Membership.mem (closure s) x\nhy : Membership.mem (interior s) (HAdd.hAdd x y)\nt : ùïú\nht : Membership.mem (Set.Ioc 0 1) t\n‚ä¢ Membership.mem (interior s) (HAdd.hAdd x (HSMul.hSMul t y))","decl":"/-- If `x ‚àà closure s` and `x + y ‚àà interior s`, then `x + t y ‚àà interior s` for `t ‚àà (0, 1]`. -/\ntheorem Convex.add_smul_mem_interior' {s : Set E} (hs : Convex ùïú s) {x y : E} (hx : x ‚àà closure s)\n    (hy : x + y ‚àà interior s) {t : ùïú} (ht : t ‚àà Ioc (0 : ùïú) 1) : x + t ‚Ä¢ y ‚àà interior s := by\n  simpa only [add_sub_cancel_left] using hs.add_smul_sub_mem_interior' hx hy ht\n\n"}
{"name":"Convex.add_smul_mem_interior","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù‚Åµ : LinearOrderedField ùïú\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module ùïú E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousConstSMul ùïú E\ns : Set E\nhs : Convex ùïú s\nx y : E\nhx : Membership.mem s x\nhy : Membership.mem (interior s) (HAdd.hAdd x y)\nt : ùïú\nht : Membership.mem (Set.Ioc 0 1) t\n‚ä¢ Membership.mem (interior s) (HAdd.hAdd x (HSMul.hSMul t y))","decl":"/-- If `x ‚àà s` and `x + y ‚àà interior s`, then `x + t y ‚àà interior s` for `t ‚àà (0, 1]`. -/\ntheorem Convex.add_smul_mem_interior {s : Set E} (hs : Convex ùïú s) {x y : E} (hx : x ‚àà s)\n    (hy : x + y ‚àà interior s) {t : ùïú} (ht : t ‚àà Ioc (0 : ùïú) 1) : x + t ‚Ä¢ y ‚àà interior s :=\n  hs.add_smul_mem_interior' (subset_closure hx) hy ht\n\n"}
{"name":"Convex.interior","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù‚Åµ : LinearOrderedField ùïú\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module ùïú E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousConstSMul ùïú E\ns : Set E\nhs : Convex ùïú s\n‚ä¢ Convex ùïú (interior s)","decl":"/-- In a topological vector space, the interior of a convex set is convex. -/\nprotected theorem Convex.interior {s : Set E} (hs : Convex ùïú s) : Convex ùïú (interior s) :=\n  convex_iff_openSegment_subset.mpr fun _ hx _ hy =>\n    hs.openSegment_closure_interior_subset_interior (interior_subset_closure hx) hy\n\n"}
{"name":"Convex.closure","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù‚Åµ : LinearOrderedField ùïú\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module ùïú E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousConstSMul ùïú E\ns : Set E\nhs : Convex ùïú s\n‚ä¢ Convex ùïú (closure s)","decl":"/-- In a topological vector space, the closure of a convex set is convex. -/\nprotected theorem Convex.closure {s : Set E} (hs : Convex ùïú s) : Convex ùïú (closure s) :=\n  fun x hx y hy a b ha hb hab =>\n  let f : E ‚Üí E ‚Üí E := fun x' y' => a ‚Ä¢ x' + b ‚Ä¢ y'\n  have hf : Continuous (Function.uncurry f) :=\n    (continuous_fst.const_smul _).add (continuous_snd.const_smul _)\n  show f x y ‚àà closure s from map_mem_closure‚ÇÇ hf hx hy fun _ hx' _ hy' => hs hx' hy' ha hb hab\n\n"}
{"name":"Convex.strictConvex'","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù‚Åµ : LinearOrderedField ùïú\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module ùïú E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousConstSMul ùïú E\ns : Set E\nhs : Convex ùïú s\nh : (SDiff.sdiff s (interior s)).Pairwise fun x y => Exists fun c => Membership.mem (interior s) ((AffineMap.lineMap x y) c)\n‚ä¢ StrictConvex ùïú s","decl":"/-- A convex set `s` is strictly convex provided that for any two distinct points of\n`s \\ interior s`, the line passing through these points has nonempty intersection with\n`interior s`. -/\nprotected theorem Convex.strictConvex' {s : Set E} (hs : Convex ùïú s)\n    (h : (s \\ interior s).Pairwise fun x y => ‚àÉ c : ùïú, lineMap x y c ‚àà interior s) :\n    StrictConvex ùïú s := by\n  refine strictConvex_iff_openSegment_subset.2 ?_\n  intro x hx y hy hne\n  by_cases hx' : x ‚àà interior s\n  ¬∑ exact hs.openSegment_interior_self_subset_interior hx' hy\n  by_cases hy' : y ‚àà interior s\n  ¬∑ exact hs.openSegment_self_interior_subset_interior hx hy'\n  rcases h ‚ü®hx, hx'‚ü© ‚ü®hy, hy'‚ü© hne with ‚ü®c, hc‚ü©\n  refine (openSegment_subset_union x y ‚ü®c, rfl‚ü©).trans\n    (insert_subset_iff.2 ‚ü®hc, union_subset ?_ ?_‚ü©)\n  exacts [hs.openSegment_self_interior_subset_interior hx hc,\n    hs.openSegment_interior_self_subset_interior hc hy]\n\n"}
{"name":"Convex.strictConvex","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù‚Åµ : LinearOrderedField ùïú\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module ùïú E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousConstSMul ùïú E\ns : Set E\nhs : Convex ùïú s\nh : (SDiff.sdiff s (interior s)).Pairwise fun x y => (SDiff.sdiff (segment ùïú x y) (frontier s)).Nonempty\n‚ä¢ StrictConvex ùïú s","decl":"/-- A convex set `s` is strictly convex provided that for any two distinct points `x`, `y` of\n`s \\ interior s`, the segment with endpoints `x`, `y` has nonempty intersection with\n`interior s`. -/\nprotected theorem Convex.strictConvex {s : Set E} (hs : Convex ùïú s)\n    (h : (s \\ interior s).Pairwise fun x y => ([x -[ùïú] y] \\ frontier s).Nonempty) :\n    StrictConvex ùïú s := by\n  refine hs.strictConvex' <| h.imp_on fun x hx y hy _ => ?_\n  simp only [segment_eq_image_lineMap, ‚Üê self_diff_frontier]\n  rintro ‚ü®_, ‚ü®‚ü®c, hc, rfl‚ü©, hcs‚ü©‚ü©\n  refine ‚ü®c, hs.segment_subset hx.1 hy.1 ?_, hcs‚ü©\n  exact (segment_eq_image_lineMap ùïú x y).symm ‚ñ∏ mem_image_of_mem _ hc\n\n"}
{"name":"Convex.closure_interior_eq_closure_of_nonempty_interior","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù‚Å∑ : LinearOrderedField ùïú\ninst‚úù‚Å∂ : AddCommGroup E\ninst‚úù‚Åµ : Module ùïú E\ninst‚úù‚Å¥ : TopologicalSpace E\ninst‚úù¬≥ : TopologicalAddGroup E\ninst‚úù¬≤ : TopologicalSpace ùïú\ninst‚úù¬π : OrderTopology ùïú\ninst‚úù : ContinuousSMul ùïú E\ns : Set E\nhs : Convex ùïú s\nhs' : (interior s).Nonempty\n‚ä¢ Eq (closure (interior s)) (closure s)","decl":"theorem Convex.closure_interior_eq_closure_of_nonempty_interior {s : Set E} (hs : Convex ùïú s)\n    (hs' : (interior s).Nonempty) : closure (interior s) = closure s :=\n  subset_antisymm (closure_mono interior_subset)\n    fun _ h ‚Ü¶ closure_mono (hs.openSegment_interior_closure_subset_interior hs'.choose_spec h)\n      (segment_subset_closure_openSegment (right_mem_segment ..))\n\n"}
{"name":"Convex.interior_closure_eq_interior_of_nonempty_interior","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù‚Å∑ : LinearOrderedField ùïú\ninst‚úù‚Å∂ : AddCommGroup E\ninst‚úù‚Åµ : Module ùïú E\ninst‚úù‚Å¥ : TopologicalSpace E\ninst‚úù¬≥ : TopologicalAddGroup E\ninst‚úù¬≤ : TopologicalSpace ùïú\ninst‚úù¬π : OrderTopology ùïú\ninst‚úù : ContinuousSMul ùïú E\ns : Set E\nhs : Convex ùïú s\nhs' : (interior s).Nonempty\n‚ä¢ Eq (interior (closure s)) (interior s)","decl":"theorem Convex.interior_closure_eq_interior_of_nonempty_interior {s : Set E} (hs : Convex ùïú s)\n    (hs' : (interior s).Nonempty) : interior (closure s) = interior s := by\n  refine subset_antisymm ?_ (interior_mono subset_closure)\n  intro y hy\n  rcases hs' with ‚ü®x, hx‚ü©\n  have h := AffineMap.lineMap_apply_one (k := ùïú) x y\n  obtain ‚ü®t, ht1, ht‚ü© := AffineMap.lineMap_continuous.tendsto' _ _ h |>.eventually_mem\n    (mem_interior_iff_mem_nhds.1 hy) |>.exists_gt\n  apply hs.openSegment_interior_closure_subset_interior hx ht\n  nth_rw 1 [‚Üê AffineMap.lineMap_apply_zero (k := ùïú) x y, ‚Üê image_openSegment]\n  exact ‚ü®1, Ioo_subset_openSegment ‚ü®zero_lt_one, ht1‚ü©, h‚ü©\n\n"}
{"name":"convex_closed_sInter","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù¬≥ : OrderedSemiring ùïú\ninst‚úù¬≤ : AddCommGroup E\ninst‚úù¬π : Module ùïú E\ninst‚úù : TopologicalSpace E\nS : Set (Set E)\nh : ‚àÄ (s : Set E), Membership.mem S s ‚Üí And (Convex ùïú s) (IsClosed s)\n‚ä¢ And (Convex ùïú S.sInter) (IsClosed S.sInter)","decl":"theorem convex_closed_sInter {S : Set (Set E)} (h : ‚àÄ s ‚àà S, Convex ùïú s ‚àß IsClosed s) :\n    Convex ùïú (‚ãÇ‚ÇÄ S) ‚àß IsClosed (‚ãÇ‚ÇÄ S) :=\n  ‚ü®fun _ hx => starConvex_sInter fun _ hs => (h _ hs).1 <| hx _ hs,\n    isClosed_sInter fun _ hs => (h _ hs).2‚ü©\n\n"}
{"name":"closedConvexHull_isClosed","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù¬≥ : OrderedSemiring ùïú\ninst‚úù¬≤ : AddCommGroup E\ninst‚úù¬π : Module ùïú E\ninst‚úù : TopologicalSpace E\ns : Set E\n‚ä¢ Eq ((closedConvexHull ùïú).IsClosed s) (And (Convex ùïú s) (IsClosed s))","decl":"/-- The convex closed hull of a set `s` is the minimal convex closed set that includes `s`. -/\n@[simps! isClosed]\ndef closedConvexHull : ClosureOperator (Set E) := .ofCompletePred (fun s => Convex ùïú s ‚àß IsClosed s)\n  fun _ ‚Ü¶ convex_closed_sInter\n\n"}
{"name":"convex_closedConvexHull","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù¬≥ : OrderedSemiring ùïú\ninst‚úù¬≤ : AddCommGroup E\ninst‚úù¬π : Module ùïú E\ninst‚úù : TopologicalSpace E\ns : Set E\n‚ä¢ Convex ùïú ((closedConvexHull ùïú) s)","decl":"theorem convex_closedConvexHull {s : Set E} :\n    Convex ùïú (closedConvexHull ùïú s) := ((closedConvexHull ùïú).isClosed_closure s).1\n\n"}
{"name":"isClosed_closedConvexHull","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù¬≥ : OrderedSemiring ùïú\ninst‚úù¬≤ : AddCommGroup E\ninst‚úù¬π : Module ùïú E\ninst‚úù : TopologicalSpace E\ns : Set E\n‚ä¢ IsClosed ((closedConvexHull ùïú) s)","decl":"theorem isClosed_closedConvexHull {s : Set E} :\n    IsClosed (closedConvexHull ùïú s) := ((closedConvexHull ùïú).isClosed_closure s).2\n\n"}
{"name":"subset_closedConvexHull","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù¬≥ : OrderedSemiring ùïú\ninst‚úù¬≤ : AddCommGroup E\ninst‚úù¬π : Module ùïú E\ninst‚úù : TopologicalSpace E\ns : Set E\n‚ä¢ HasSubset.Subset s ((closedConvexHull ùïú) s)","decl":"theorem subset_closedConvexHull {s : Set E} : s ‚äÜ closedConvexHull ùïú s :=\n  (closedConvexHull ùïú).le_closure s\n\n"}
{"name":"closure_subset_closedConvexHull","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù¬≥ : OrderedSemiring ùïú\ninst‚úù¬≤ : AddCommGroup E\ninst‚úù¬π : Module ùïú E\ninst‚úù : TopologicalSpace E\ns : Set E\n‚ä¢ HasSubset.Subset (closure s) ((closedConvexHull ùïú) s)","decl":"theorem closure_subset_closedConvexHull {s : Set E} : closure s ‚äÜ closedConvexHull ùïú s :=\n  closure_minimal subset_closedConvexHull isClosed_closedConvexHull\n\n"}
{"name":"closedConvexHull_min","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù¬≥ : OrderedSemiring ùïú\ninst‚úù¬≤ : AddCommGroup E\ninst‚úù¬π : Module ùïú E\ninst‚úù : TopologicalSpace E\ns t : Set E\nhst : HasSubset.Subset s t\nh_conv : Convex ùïú t\nh_closed : IsClosed t\n‚ä¢ HasSubset.Subset ((closedConvexHull ùïú) s) t","decl":"theorem closedConvexHull_min {s t : Set E} (hst : s ‚äÜ t) (h_conv : Convex ùïú t)\n    (h_closed : IsClosed t) : closedConvexHull ùïú s ‚äÜ t :=\n  (closedConvexHull ùïú).closure_min hst ‚ü®h_conv, h_closed‚ü©\n\n"}
{"name":"convexHull_subset_closedConvexHull","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù¬≥ : OrderedSemiring ùïú\ninst‚úù¬≤ : AddCommGroup E\ninst‚úù¬π : Module ùïú E\ninst‚úù : TopologicalSpace E\ns : Set E\n‚ä¢ HasSubset.Subset ((convexHull ùïú) s) ((closedConvexHull ùïú) s)","decl":"theorem convexHull_subset_closedConvexHull {s : Set E} :\n    (convexHull ùïú) s ‚äÜ (closedConvexHull ùïú) s :=\n  convexHull_min subset_closedConvexHull convex_closedConvexHull\n\n"}
{"name":"closedConvexHull_closure_eq_closedConvexHull","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù¬≥ : OrderedSemiring ùïú\ninst‚úù¬≤ : AddCommGroup E\ninst‚úù¬π : Module ùïú E\ninst‚úù : TopologicalSpace E\ns : Set E\n‚ä¢ Eq ((closedConvexHull ùïú) (closure s)) ((closedConvexHull ùïú) s)","decl":"@[simp]\ntheorem closedConvexHull_closure_eq_closedConvexHull {s : Set E} :\n    closedConvexHull ùïú (closure s) = closedConvexHull ùïú s :=\n  subset_antisymm (by\n    simpa using ((closedConvexHull ùïú).monotone (closure_subset_closedConvexHull (ùïú := ùïú) (E := E))))\n    ((closedConvexHull ùïú).monotone subset_closure)\n\n"}
{"name":"closedConvexHull_eq_closure_convexHull","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"ùïú : Type u_2\nE : Type u_3\ninst‚úù‚Åµ : LinearOrderedField ùïú\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module ùïú E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousConstSMul ùïú E\ns : Set E\n‚ä¢ Eq ((closedConvexHull ùïú) s) (closure ((convexHull ùïú) s))","decl":"theorem closedConvexHull_eq_closure_convexHull {s : Set E} :\n    closedConvexHull ùïú s = closure (convexHull ùïú s) := subset_antisymm\n  (closedConvexHull_min (subset_trans (subset_convexHull ùïú s) subset_closure)\n    (Convex.closure (convex_convexHull ùïú s)) isClosed_closure)\n  (closure_minimal convexHull_subset_closedConvexHull isClosed_closedConvexHull)\n\n"}
{"name":"Set.Finite.isCompact_convexHull","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"E : Type u_3\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module Real E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousSMul Real E\ns : Set E\nhs : s.Finite\n‚ä¢ IsCompact ((convexHull Real) s)","decl":"/-- Convex hull of a finite set is compact. -/\ntheorem Set.Finite.isCompact_convexHull {s : Set E} (hs : s.Finite) :\n    IsCompact (convexHull ‚Ñù s) := by\n  rw [hs.convexHull_eq_image]\n  apply (@isCompact_stdSimplex _ hs.fintype).image\n  haveI := hs.fintype\n  apply LinearMap.continuous_on_pi\n\n"}
{"name":"Set.Finite.isClosed_convexHull","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"E : Type u_3\ninst‚úù‚Åµ : AddCommGroup E\ninst‚úù‚Å¥ : Module Real E\ninst‚úù¬≥ : TopologicalSpace E\ninst‚úù¬≤ : TopologicalAddGroup E\ninst‚úù¬π : ContinuousSMul Real E\ninst‚úù : T2Space E\ns : Set E\nhs : s.Finite\n‚ä¢ IsClosed ((convexHull Real) s)","decl":"/-- Convex hull of a finite set is closed. -/\ntheorem Set.Finite.isClosed_convexHull [T2Space E] {s : Set E} (hs : s.Finite) :\n    IsClosed (convexHull ‚Ñù s) :=\n  hs.isCompact_convexHull.isClosed\n\n"}
{"name":"Convex.closure_subset_image_homothety_interior_of_one_lt","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"E : Type u_3\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module Real E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousSMul Real E\ns : Set E\nhs : Convex Real s\nx : E\nhx : Membership.mem (interior s) x\nt : Real\nht : LT.lt 1 t\n‚ä¢ HasSubset.Subset (closure s) (Set.image (‚áë(AffineMap.homothety x t)) (interior s))","decl":"/-- If we dilate the interior of a convex set about a point in its interior by a scale `t > 1`,\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. -/\ntheorem Convex.closure_subset_image_homothety_interior_of_one_lt {s : Set E} (hs : Convex ‚Ñù s)\n    {x : E} (hx : x ‚àà interior s) (t : ‚Ñù) (ht : 1 < t) :\n    closure s ‚äÜ homothety x t '' interior s := by\n  intro y hy\n  have hne : t ‚â† 0 := (one_pos.trans ht).ne'\n  refine\n    ‚ü®homothety x t‚Åª¬π y, hs.openSegment_interior_closure_subset_interior hx hy ?_,\n      (AffineEquiv.homothetyUnitsMulHom x (Units.mk0 t hne)).apply_symm_apply y‚ü©\n  rw [openSegment_eq_image_lineMap, ‚Üê inv_one, ‚Üê inv_Ioi‚ÇÄ (zero_lt_one' ‚Ñù), ‚Üê image_inv_eq_inv,\n    image_image, homothety_eq_lineMap]\n  exact mem_image_of_mem _ ht\n\n"}
{"name":"Convex.closure_subset_interior_image_homothety_of_one_lt","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"E : Type u_3\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module Real E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousSMul Real E\ns : Set E\nhs : Convex Real s\nx : E\nhx : Membership.mem (interior s) x\nt : Real\nht : LT.lt 1 t\n‚ä¢ HasSubset.Subset (closure s) (interior (Set.image (‚áë(AffineMap.homothety x t)) s))","decl":"/-- If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. -/\ntheorem Convex.closure_subset_interior_image_homothety_of_one_lt {s : Set E} (hs : Convex ‚Ñù s)\n    {x : E} (hx : x ‚àà interior s) (t : ‚Ñù) (ht : 1 < t) :\n    closure s ‚äÜ interior (homothety x t '' s) :=\n  (hs.closure_subset_image_homothety_interior_of_one_lt hx t ht).trans <|\n    (homothety_isOpenMap x t (one_pos.trans ht).ne').image_interior_subset _\n\n"}
{"name":"Convex.subset_interior_image_homothety_of_one_lt","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"E : Type u_3\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module Real E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousSMul Real E\ns : Set E\nhs : Convex Real s\nx : E\nhx : Membership.mem (interior s) x\nt : Real\nht : LT.lt 1 t\n‚ä¢ HasSubset.Subset s (interior (Set.image (‚áë(AffineMap.homothety x t)) s))","decl":"/-- If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. -/\ntheorem Convex.subset_interior_image_homothety_of_one_lt {s : Set E} (hs : Convex ‚Ñù s) {x : E}\n    (hx : x ‚àà interior s) (t : ‚Ñù) (ht : 1 < t) : s ‚äÜ interior (homothety x t '' s) :=\n  subset_closure.trans <| hs.closure_subset_interior_image_homothety_of_one_lt hx t ht\n\n"}
{"name":"JoinedIn.of_segment_subset","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"E : Type u_4\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module Real E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : ContinuousAdd E\ninst‚úù : ContinuousSMul Real E\nx y : E\ns : Set E\nh : HasSubset.Subset (segment Real x y) s\n‚ä¢ JoinedIn s x y","decl":"theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]\n    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]\n    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by\n  have A : Continuous (fun t ‚Ü¶ (1 - t) ‚Ä¢ x + t ‚Ä¢ y : ‚Ñù ‚Üí E) := by fun_prop\n  apply JoinedIn.ofLine A.continuousOn (by simp) (by simp)\n  convert h\n  rw [segment_eq_image ‚Ñù x y]\n\n"}
{"name":"Convex.isPathConnected","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"E : Type u_3\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module Real E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousSMul Real E\ns : Set E\nhconv : Convex Real s\nhne : s.Nonempty\n‚ä¢ IsPathConnected s","decl":"/-- A nonempty convex set is path connected. -/\nprotected theorem Convex.isPathConnected {s : Set E} (hconv : Convex ‚Ñù s) (hne : s.Nonempty) :\n    IsPathConnected s := by\n  refine isPathConnected_iff.mpr ‚ü®hne, ?_‚ü©\n  intro x x_in y y_in\n  exact JoinedIn.of_segment_subset ((segment_subset_iff ‚Ñù).2 (hconv x_in y_in))\n\n"}
{"name":"Convex.isConnected","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"E : Type u_3\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module Real E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousSMul Real E\ns : Set E\nh : Convex Real s\nhne : s.Nonempty\n‚ä¢ IsConnected s","decl":"/-- A nonempty convex set is connected. -/\nprotected theorem Convex.isConnected {s : Set E} (h : Convex ‚Ñù s) (hne : s.Nonempty) :\n    IsConnected s :=\n  (h.isPathConnected hne).isConnected\n\n"}
{"name":"Convex.isPreconnected","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"E : Type u_3\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module Real E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousSMul Real E\ns : Set E\nh : Convex Real s\n‚ä¢ IsPreconnected s","decl":"/-- A convex set is preconnected. -/\nprotected theorem Convex.isPreconnected {s : Set E} (h : Convex ‚Ñù s) : IsPreconnected s :=\n  s.eq_empty_or_nonempty.elim (fun h => h.symm ‚ñ∏ isPreconnected_empty) fun hne =>\n    (h.isConnected hne).isPreconnected\n\n"}
{"name":"TopologicalAddGroup.pathConnectedSpace","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"E : Type u_3\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module Real E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousSMul Real E\n‚ä¢ PathConnectedSpace E","decl":"/-- Every topological vector space over ‚Ñù is path connected.\n\nNot an instance, because it creates enormous TC subproblems (turn on `pp.all`).\n-/\nprotected theorem TopologicalAddGroup.pathConnectedSpace : PathConnectedSpace E :=\n  pathConnectedSpace_iff_univ.mpr <| convex_univ.isPathConnected ‚ü®(0 : E), trivial‚ü©\n\n"}
{"name":"isPathConnected_compl_of_isPathConnected_compl_zero","module":"Mathlib.Analysis.Convex.Topology","initialProofState":"E : Type u_4\ninst‚úù‚Å¥ : AddCommGroup E\ninst‚úù¬≥ : Module Real E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalAddGroup E\ninst‚úù : ContinuousSMul Real E\np q : Submodule Real E\nhpq : IsCompl p q\nhpc : IsPathConnected (HasCompl.compl (Singleton.singleton 0))\n‚ä¢ IsPathConnected (HasCompl.compl ‚Üëq)","decl":"/-- Given two complementary subspaces `p` and `q` in `E`, if the complement of `{0}`\nis path connected in `p` then the complement of `q` is path connected in `E`. -/\ntheorem isPathConnected_compl_of_isPathConnected_compl_zero [ContinuousSMul ‚Ñù E]\n    {p q : Submodule ‚Ñù E} (hpq : IsCompl p q) (hpc : IsPathConnected ({0}·∂ú : Set p)) :\n    IsPathConnected (q·∂ú : Set E) := by\n  rw [isPathConnected_iff] at hpc ‚ä¢\n  constructor\n  ¬∑ rcases hpc.1 with ‚ü®a, ha‚ü©\n    exact ‚ü®a, mt (Submodule.eq_zero_of_coe_mem_of_disjoint hpq.disjoint) ha‚ü©\n  ¬∑ intro x hx y hy\n    have : œÄ hpq x ‚â† 0 ‚àß œÄ hpq y ‚â† 0 := by\n      constructor <;> intro h <;> rw [Submodule.linearProjOfIsCompl_apply_eq_zero_iff hpq] at h <;>\n        [exact hx h; exact hy h]\n    rcases hpc.2 (œÄ hpq x) this.1 (œÄ hpq y) this.2 with ‚ü®Œ≥‚ÇÅ, hŒ≥‚ÇÅ‚ü©\n    let Œ≥‚ÇÇ := PathConnectedSpace.somePath (œÄ hpq.symm x) (œÄ hpq.symm y)\n    let Œ≥‚ÇÅ' : Path (_ : E) _ := Œ≥‚ÇÅ.map continuous_subtype_val\n    let Œ≥‚ÇÇ' : Path (_ : E) _ := Œ≥‚ÇÇ.map continuous_subtype_val\n    refine ‚ü®(Œ≥‚ÇÅ'.add Œ≥‚ÇÇ').cast (Submodule.linear_proj_add_linearProjOfIsCompl_eq_self hpq x).symm\n      (Submodule.linear_proj_add_linearProjOfIsCompl_eq_self hpq y).symm, fun t ‚Ü¶ ?_‚ü©\n    rw [Path.cast_coe, Path.add_apply]\n    change Œ≥‚ÇÅ t + (Œ≥‚ÇÇ t : E) ‚àâ q\n    rw [‚Üê Submodule.linearProjOfIsCompl_apply_eq_zero_iff hpq, LinearMap.map_add,\n      Submodule.linearProjOfIsCompl_apply_right, add_zero,\n      Submodule.linearProjOfIsCompl_apply_eq_zero_iff]\n    exact mt (Submodule.eq_zero_of_coe_mem_of_disjoint hpq.disjoint) (hŒ≥‚ÇÅ t)\n\n"}
