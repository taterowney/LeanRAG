{"name":"MvPolynomial.faithfulSMul","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝² : CommSemiring S₁\ninst✝¹ : SMulZeroClass R S₁\ninst✝ : FaithfulSMul R S₁\n⊢ FaithfulSMul R (MvPolynomial σ S₁)","decl":"instance faithfulSMul [CommSemiring S₁] [SMulZeroClass R S₁] [FaithfulSMul R S₁] :\n    FaithfulSMul R (MvPolynomial σ S₁) :=\n  AddMonoidAlgebra.faithfulSMul\n\n"}
{"name":"MvPolynomial.isScalarTower","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\nσ : Type u_1\ninst✝⁴ : CommSemiring S₂\ninst✝³ : SMul R S₁\ninst✝² : SMulZeroClass R S₂\ninst✝¹ : SMulZeroClass S₁ S₂\ninst✝ : IsScalarTower R S₁ S₂\n⊢ IsScalarTower R S₁ (MvPolynomial σ S₂)","decl":"instance isScalarTower [CommSemiring S₂] [SMul R S₁] [SMulZeroClass R S₂] [SMulZeroClass S₁ S₂]\n    [IsScalarTower R S₁ S₂] : IsScalarTower R S₁ (MvPolynomial σ S₂) :=\n  AddMonoidAlgebra.isScalarTower\n\n"}
{"name":"MvPolynomial.smulCommClass","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\nσ : Type u_1\ninst✝³ : CommSemiring S₂\ninst✝² : SMulZeroClass R S₂\ninst✝¹ : SMulZeroClass S₁ S₂\ninst✝ : SMulCommClass R S₁ S₂\n⊢ SMulCommClass R S₁ (MvPolynomial σ S₂)","decl":"instance smulCommClass [CommSemiring S₂] [SMulZeroClass R S₂] [SMulZeroClass S₁ S₂]\n    [SMulCommClass R S₁ S₂] : SMulCommClass R S₁ (MvPolynomial σ S₂) :=\n  AddMonoidAlgebra.smulCommClass\n\n"}
{"name":"MvPolynomial.isCentralScalar","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝³ : CommSemiring S₁\ninst✝² : SMulZeroClass R S₁\ninst✝¹ : SMulZeroClass (MulOpposite R) S₁\ninst✝ : IsCentralScalar R S₁\n⊢ IsCentralScalar R (MvPolynomial σ S₁)","decl":"instance isCentralScalar [CommSemiring S₁] [SMulZeroClass R S₁] [SMulZeroClass Rᵐᵒᵖ S₁]\n    [IsCentralScalar R S₁] : IsCentralScalar R (MvPolynomial σ S₁) :=\n  AddMonoidAlgebra.isCentralScalar\n\n"}
{"name":"MvPolynomial.isScalarTower_right","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝² : CommSemiring S₁\ninst✝¹ : DistribSMul R S₁\ninst✝ : IsScalarTower R S₁ S₁\n⊢ IsScalarTower R (MvPolynomial σ S₁) (MvPolynomial σ S₁)","decl":"instance isScalarTower_right [CommSemiring S₁] [DistribSMul R S₁] [IsScalarTower R S₁ S₁] :\n    IsScalarTower R (MvPolynomial σ S₁) (MvPolynomial σ S₁) :=\n  AddMonoidAlgebra.isScalarTower_self _\n\n"}
{"name":"MvPolynomial.smulCommClass_right","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝² : CommSemiring S₁\ninst✝¹ : DistribSMul R S₁\ninst✝ : SMulCommClass R S₁ S₁\n⊢ SMulCommClass R (MvPolynomial σ S₁) (MvPolynomial σ S₁)","decl":"instance smulCommClass_right [CommSemiring S₁] [DistribSMul R S₁] [SMulCommClass R S₁ S₁] :\n    SMulCommClass R (MvPolynomial σ S₁) (MvPolynomial σ S₁) :=\n  AddMonoidAlgebra.smulCommClass_self _\n\n"}
{"name":"MvPolynomial.single_eq_monomial","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ns : Finsupp σ Nat\na : R\n⊢ Eq (Finsupp.single s a) ((MvPolynomial.monomial s) a)","decl":"theorem single_eq_monomial (s : σ →₀ ℕ) (a : R) : Finsupp.single s a = monomial s a :=\n  rfl\n\n"}
{"name":"MvPolynomial.mul_def","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np q : MvPolynomial σ R\n⊢ Eq (HMul.hMul p q) (Finsupp.sum p fun m a => Finsupp.sum q fun n b => (MvPolynomial.monomial (HAdd.hAdd m n)) (HMul.hMul a b))","decl":"theorem mul_def : p * q = p.sum fun m a => q.sum fun n b => monomial (m + n) (a * b) :=\n  AddMonoidAlgebra.mul_def\n\n"}
{"name":"MvPolynomial.algebraMap_eq","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (algebraMap R (MvPolynomial σ R)) MvPolynomial.C","decl":"@[simp]\ntheorem algebraMap_eq : algebraMap R (MvPolynomial σ R) = C :=\n  rfl\n\n"}
{"name":"MvPolynomial.monomial_left_injective","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nr : R\nhr : Ne r 0\n⊢ Function.Injective fun s => (MvPolynomial.monomial s) r","decl":"theorem monomial_left_injective {r : R} (hr : r ≠ 0) :\n    Function.Injective fun s : σ →₀ ℕ => monomial s r :=\n  Finsupp.single_left_injective hr\n\n"}
{"name":"MvPolynomial.monomial_left_inj","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ns t : Finsupp σ Nat\nr : R\nhr : Ne r 0\n⊢ Iff (Eq ((MvPolynomial.monomial s) r) ((MvPolynomial.monomial t) r)) (Eq s t)","decl":"@[simp]\ntheorem monomial_left_inj {s t : σ →₀ ℕ} {r : R} (hr : r ≠ 0) :\n    monomial s r = monomial t r ↔ s = t :=\n  Finsupp.single_left_inj hr\n\n"}
{"name":"MvPolynomial.C_apply","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\na : R\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.C a) ((MvPolynomial.monomial 0) a)","decl":"theorem C_apply : (C a : MvPolynomial σ R) = monomial 0 a :=\n  rfl\n\n"}
{"name":"MvPolynomial.C_0","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.C 0) 0","decl":"@[simp]\ntheorem C_0 : C 0 = (0 : MvPolynomial σ R) := map_zero _\n\n"}
{"name":"MvPolynomial.C_1","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.C 1) 1","decl":"@[simp]\ntheorem C_1 : C 1 = (1 : MvPolynomial σ R) :=\n  rfl\n\n"}
{"name":"MvPolynomial.C_mul_monomial","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\na a' : R\ns : Finsupp σ Nat\ninst✝ : CommSemiring R\n⊢ Eq (HMul.hMul (MvPolynomial.C a) ((MvPolynomial.monomial s) a')) ((MvPolynomial.monomial s) (HMul.hMul a a'))","decl":"theorem C_mul_monomial : C a * monomial s a' = monomial s (a * a') := by\n  -- Porting note: this `show` feels like defeq abuse, but I can't find the appropriate lemmas\n  show AddMonoidAlgebra.single _ _ * AddMonoidAlgebra.single _ _ = AddMonoidAlgebra.single _ _\n  simp [C_apply, single_mul_single]\n\n"}
{"name":"MvPolynomial.C_add","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\na a' : R\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.C (HAdd.hAdd a a')) (HAdd.hAdd (MvPolynomial.C a) (MvPolynomial.C a'))","decl":"@[simp]\ntheorem C_add : (C (a + a') : MvPolynomial σ R) = C a + C a' :=\n  Finsupp.single_add _ _ _\n\n"}
{"name":"MvPolynomial.C_mul","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\na a' : R\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.C (HMul.hMul a a')) (HMul.hMul (MvPolynomial.C a) (MvPolynomial.C a'))","decl":"@[simp]\ntheorem C_mul : (C (a * a') : MvPolynomial σ R) = C a * C a' :=\n  C_mul_monomial.symm\n\n"}
{"name":"MvPolynomial.C_pow","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\na : R\nn : Nat\n⊢ Eq (MvPolynomial.C (HPow.hPow a n)) (HPow.hPow (MvPolynomial.C a) n)","decl":"@[simp]\ntheorem C_pow (a : R) (n : ℕ) : (C (a ^ n) : MvPolynomial σ R) = C a ^ n :=\n  map_pow _ _ _\n\n"}
{"name":"MvPolynomial.C_injective","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"σ : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\n⊢ Function.Injective ⇑MvPolynomial.C","decl":"theorem C_injective (σ : Type*) (R : Type*) [CommSemiring R] :\n    Function.Injective (C : R → MvPolynomial σ R) :=\n  Finsupp.single_injective _\n\n"}
{"name":"MvPolynomial.C_surjective","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u_2\ninst✝¹ : CommSemiring R\nσ : Type u_3\ninst✝ : IsEmpty σ\n⊢ Function.Surjective ⇑MvPolynomial.C","decl":"theorem C_surjective {R : Type*} [CommSemiring R] (σ : Type*) [IsEmpty σ] :\n    Function.Surjective (C : R → MvPolynomial σ R) := by\n  refine fun p => ⟨p.toFun 0, Finsupp.ext fun a => ?_⟩\n  simp only [C_apply, ← single_eq_monomial, (Finsupp.ext isEmptyElim (α := σ) : a = 0),\n    single_eq_same]\n  rfl\n\n"}
{"name":"MvPolynomial.C_inj","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"σ : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\nr s : R\n⊢ Iff (Eq (MvPolynomial.C r) (MvPolynomial.C s)) (Eq r s)","decl":"@[simp]\ntheorem C_inj {σ : Type*} (R : Type*) [CommSemiring R] (r s : R) :\n    (C r : MvPolynomial σ R) = C s ↔ r = s :=\n  (C_injective σ R).eq_iff\n\n"}
{"name":"MvPolynomial.C_eq_zero","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\na : R\ninst✝ : CommSemiring R\n⊢ Iff (Eq (MvPolynomial.C a) 0) (Eq a 0)","decl":"@[simp] lemma C_eq_zero : (C a : MvPolynomial σ R) = 0 ↔ a = 0 := by rw [← map_zero C, C_inj]\n\n"}
{"name":"MvPolynomial.C_ne_zero","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\na : R\ninst✝ : CommSemiring R\n⊢ Iff (Ne (MvPolynomial.C a) 0) (Ne a 0)","decl":"lemma C_ne_zero : (C a : MvPolynomial σ R) ≠ 0 ↔ a ≠ 0 :=\n  C_eq_zero.ne\n\n"}
{"name":"MvPolynomial.nontrivial_of_nontrivial","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"σ : Type u_2\nR : Type u_3\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\n⊢ Nontrivial (MvPolynomial σ R)","decl":"instance nontrivial_of_nontrivial (σ : Type*) (R : Type*) [CommSemiring R] [Nontrivial R] :\n    Nontrivial (MvPolynomial σ R) :=\n  inferInstanceAs (Nontrivial <| AddMonoidAlgebra R (σ →₀ ℕ))\n\n"}
{"name":"MvPolynomial.infinite_of_infinite","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"σ : Type u_2\nR : Type u_3\ninst✝¹ : CommSemiring R\ninst✝ : Infinite R\n⊢ Infinite (MvPolynomial σ R)","decl":"instance infinite_of_infinite (σ : Type*) (R : Type*) [CommSemiring R] [Infinite R] :\n    Infinite (MvPolynomial σ R) :=\n  Infinite.of_injective C (C_injective _ _)\n\n"}
{"name":"MvPolynomial.infinite_of_nonempty","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"σ : Type u_2\nR : Type u_3\ninst✝² : Nonempty σ\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\n⊢ Infinite (MvPolynomial σ R)","decl":"instance infinite_of_nonempty (σ : Type*) (R : Type*) [Nonempty σ] [CommSemiring R]\n    [Nontrivial R] : Infinite (MvPolynomial σ R) :=\n  Infinite.of_injective ((fun s : σ →₀ ℕ => monomial s 1) ∘ Finsupp.single (Classical.arbitrary σ))\n    <| (monomial_left_injective one_ne_zero).comp (Finsupp.single_injective _)\n\n"}
{"name":"MvPolynomial.C_eq_coe_nat","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nn : Nat\n⊢ Eq (MvPolynomial.C ↑n) ↑n","decl":"theorem C_eq_coe_nat (n : ℕ) : (C ↑n : MvPolynomial σ R) = n := by\n  induction n <;> simp [*]\n\n"}
{"name":"MvPolynomial.C_mul'","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\na : R\ninst✝ : CommSemiring R\np : MvPolynomial σ R\n⊢ Eq (HMul.hMul (MvPolynomial.C a) p) (HSMul.hSMul a p)","decl":"theorem C_mul' : MvPolynomial.C a * p = a • p :=\n  (Algebra.smul_def a p).symm\n\n"}
{"name":"MvPolynomial.smul_eq_C_mul","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\na : R\n⊢ Eq (HSMul.hSMul a p) (HMul.hMul (MvPolynomial.C a) p)","decl":"theorem smul_eq_C_mul (p : MvPolynomial σ R) (a : R) : a • p = C a * p :=\n  C_mul'.symm\n\n"}
{"name":"MvPolynomial.C_eq_smul_one","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\na : R\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.C a) (HSMul.hSMul a 1)","decl":"theorem C_eq_smul_one : (C a : MvPolynomial σ R) = a • (1 : MvPolynomial σ R) := by\n  rw [← C_mul', mul_one]\n\n"}
{"name":"MvPolynomial.smul_monomial","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\na : R\ns : Finsupp σ Nat\ninst✝¹ : CommSemiring R\nS₁ : Type u_2\ninst✝ : SMulZeroClass S₁ R\nr : S₁\n⊢ Eq (HSMul.hSMul r ((MvPolynomial.monomial s) a)) ((MvPolynomial.monomial s) (HSMul.hSMul r a))","decl":"theorem smul_monomial {S₁ : Type*} [SMulZeroClass S₁ R] (r : S₁) :\n    r • monomial s a = monomial s (r • a) :=\n  Finsupp.smul_single _ _ _\n\n"}
{"name":"MvPolynomial.X_injective","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\n⊢ Function.Injective MvPolynomial.X","decl":"theorem X_injective [Nontrivial R] : Function.Injective (X : σ → MvPolynomial σ R) :=\n  (monomial_left_injective one_ne_zero).comp (Finsupp.single_left_injective one_ne_zero)\n\n"}
{"name":"MvPolynomial.X_inj","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\nm n : σ\n⊢ Iff (Eq (MvPolynomial.X m) (MvPolynomial.X n)) (Eq m n)","decl":"@[simp]\ntheorem X_inj [Nontrivial R] (m n : σ) : X m = (X n : MvPolynomial σ R) ↔ m = n :=\n  X_injective.eq_iff\n\n"}
{"name":"MvPolynomial.monomial_pow","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\na : R\ne : Nat\ns : Finsupp σ Nat\ninst✝ : CommSemiring R\n⊢ Eq (HPow.hPow ((MvPolynomial.monomial s) a) e) ((MvPolynomial.monomial (HSMul.hSMul e s)) (HPow.hPow a e))","decl":"theorem monomial_pow : monomial s a ^ e = monomial (e • s) (a ^ e) :=\n  AddMonoidAlgebra.single_pow e\n\n"}
{"name":"MvPolynomial.monomial_mul","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ns s' : Finsupp σ Nat\na b : R\n⊢ Eq (HMul.hMul ((MvPolynomial.monomial s) a) ((MvPolynomial.monomial s') b)) ((MvPolynomial.monomial (HAdd.hAdd s s')) (HMul.hMul a b))","decl":"@[simp]\ntheorem monomial_mul {s s' : σ →₀ ℕ} {a b : R} :\n    monomial s a * monomial s' b = monomial (s + s') (a * b) :=\n  AddMonoidAlgebra.single_mul_single\n\n"}
{"name":"MvPolynomial.monomialOneHom_apply","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ns : Finsupp σ Nat\ninst✝ : CommSemiring R\n⊢ Eq ((MvPolynomial.monomialOneHom R σ) s) ((MvPolynomial.monomial s) 1)","decl":"@[simp]\ntheorem monomialOneHom_apply : monomialOneHom R σ s = (monomial s 1 : MvPolynomial σ R) :=\n  rfl\n\n"}
{"name":"MvPolynomial.X_pow_eq_monomial","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ne : Nat\nn : σ\ninst✝ : CommSemiring R\n⊢ Eq (HPow.hPow (MvPolynomial.X n) e) ((MvPolynomial.monomial (Finsupp.single n e)) 1)","decl":"theorem X_pow_eq_monomial : X n ^ e = monomial (Finsupp.single n e) (1 : R) := by\n  simp [X, monomial_pow]\n\n"}
{"name":"MvPolynomial.monomial_add_single","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\na : R\ne : Nat\nn : σ\ns : Finsupp σ Nat\ninst✝ : CommSemiring R\n⊢ Eq ((MvPolynomial.monomial (HAdd.hAdd s (Finsupp.single n e))) a) (HMul.hMul ((MvPolynomial.monomial s) a) (HPow.hPow (MvPolynomial.X n) e))","decl":"theorem monomial_add_single : monomial (s + Finsupp.single n e) a = monomial s a * X n ^ e := by\n  rw [X_pow_eq_monomial, monomial_mul, mul_one]\n\n"}
{"name":"MvPolynomial.monomial_single_add","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\na : R\ne : Nat\nn : σ\ns : Finsupp σ Nat\ninst✝ : CommSemiring R\n⊢ Eq ((MvPolynomial.monomial (HAdd.hAdd (Finsupp.single n e) s)) a) (HMul.hMul (HPow.hPow (MvPolynomial.X n) e) ((MvPolynomial.monomial s) a))","decl":"theorem monomial_single_add : monomial (Finsupp.single n e + s) a = X n ^ e * monomial s a := by\n  rw [X_pow_eq_monomial, monomial_mul, one_mul]\n\n"}
{"name":"MvPolynomial.C_mul_X_pow_eq_monomial","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ns : σ\na : R\nn : Nat\n⊢ Eq (HMul.hMul (MvPolynomial.C a) (HPow.hPow (MvPolynomial.X s) n)) ((MvPolynomial.monomial (Finsupp.single s n)) a)","decl":"theorem C_mul_X_pow_eq_monomial {s : σ} {a : R} {n : ℕ} :\n    C a * X s ^ n = monomial (Finsupp.single s n) a := by\n  rw [← zero_add (Finsupp.single s n), monomial_add_single, C_apply]\n\n"}
{"name":"MvPolynomial.C_mul_X_eq_monomial","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ns : σ\na : R\n⊢ Eq (HMul.hMul (MvPolynomial.C a) (MvPolynomial.X s)) ((MvPolynomial.monomial (Finsupp.single s 1)) a)","decl":"theorem C_mul_X_eq_monomial {s : σ} {a : R} : C a * X s = monomial (Finsupp.single s 1) a := by\n  rw [← C_mul_X_pow_eq_monomial, pow_one]\n\n"}
{"name":"MvPolynomial.monomial_zero","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ns : Finsupp σ Nat\n⊢ Eq ((MvPolynomial.monomial s) 0) 0","decl":"@[simp]\ntheorem monomial_zero {s : σ →₀ ℕ} : monomial s (0 : R) = 0 :=\n  Finsupp.single_zero _\n\n"}
{"name":"MvPolynomial.monomial_zero'","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq ⇑(MvPolynomial.monomial 0) ⇑MvPolynomial.C","decl":"@[simp]\ntheorem monomial_zero' : (monomial (0 : σ →₀ ℕ) : R → MvPolynomial σ R) = C :=\n  rfl\n\n"}
{"name":"MvPolynomial.monomial_eq_zero","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ns : Finsupp σ Nat\nb : R\n⊢ Iff (Eq ((MvPolynomial.monomial s) b) 0) (Eq b 0)","decl":"@[simp]\ntheorem monomial_eq_zero {s : σ →₀ ℕ} {b : R} : monomial s b = 0 ↔ b = 0 :=\n  Finsupp.single_eq_zero\n\n"}
{"name":"MvPolynomial.sum_monomial_eq","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\nA : Type u_2\ninst✝ : AddCommMonoid A\nu : Finsupp σ Nat\nr : R\nb : Finsupp σ Nat → R → A\nw : Eq (b u 0) 0\n⊢ Eq (Finsupp.sum ((MvPolynomial.monomial u) r) b) (b u r)","decl":"@[simp]\ntheorem sum_monomial_eq {A : Type*} [AddCommMonoid A] {u : σ →₀ ℕ} {r : R} {b : (σ →₀ ℕ) → R → A}\n    (w : b u 0 = 0) : sum (monomial u r) b = b u r :=\n  Finsupp.sum_single_index w\n\n"}
{"name":"MvPolynomial.sum_C","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\na : R\ninst✝¹ : CommSemiring R\nA : Type u_2\ninst✝ : AddCommMonoid A\nb : Finsupp σ Nat → R → A\nw : Eq (b 0 0) 0\n⊢ Eq (Finsupp.sum (MvPolynomial.C a) b) (b 0 a)","decl":"@[simp]\ntheorem sum_C {A : Type*} [AddCommMonoid A] {b : (σ →₀ ℕ) → R → A} (w : b 0 0 = 0) :\n    sum (C a) b = b 0 a :=\n  sum_monomial_eq w\n\n"}
{"name":"MvPolynomial.monomial_sum_one","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nα : Type u_2\ns : Finset α\nf : α → Finsupp σ Nat\n⊢ Eq ((MvPolynomial.monomial (s.sum fun i => f i)) 1) (s.prod fun i => (MvPolynomial.monomial (f i)) 1)","decl":"theorem monomial_sum_one {α : Type*} (s : Finset α) (f : α → σ →₀ ℕ) :\n    (monomial (∑ i ∈ s, f i) 1 : MvPolynomial σ R) = ∏ i ∈ s, monomial (f i) 1 :=\n  map_prod (monomialOneHom R σ) (fun i => Multiplicative.ofAdd (f i)) s\n\n"}
{"name":"MvPolynomial.monomial_sum_index","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nα : Type u_2\ns : Finset α\nf : α → Finsupp σ Nat\na : R\n⊢ Eq ((MvPolynomial.monomial (s.sum fun i => f i)) a) (HMul.hMul (MvPolynomial.C a) (s.prod fun i => (MvPolynomial.monomial (f i)) 1))","decl":"theorem monomial_sum_index {α : Type*} (s : Finset α) (f : α → σ →₀ ℕ) (a : R) :\n    monomial (∑ i ∈ s, f i) a = C a * ∏ i ∈ s, monomial (f i) 1 := by\n  rw [← monomial_sum_one, C_mul', ← (monomial _).map_smul, smul_eq_mul, mul_one]\n\n"}
{"name":"MvPolynomial.monomial_finsupp_sum_index","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\nα : Type u_2\nβ : Type u_3\ninst✝ : Zero β\nf : Finsupp α β\ng : α → β → Finsupp σ Nat\na : R\n⊢ Eq ((MvPolynomial.monomial (f.sum g)) a) (HMul.hMul (MvPolynomial.C a) (f.prod fun a b => (MvPolynomial.monomial (g a b)) 1))","decl":"theorem monomial_finsupp_sum_index {α β : Type*} [Zero β] (f : α →₀ β) (g : α → β → σ →₀ ℕ)\n    (a : R) : monomial (f.sum g) a = C a * f.prod fun a b => monomial (g a b) 1 :=\n  monomial_sum_index _ _ _\n\n"}
{"name":"MvPolynomial.monomial_eq_monomial_iff","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nα : Type u_2\na₁ a₂ : Finsupp α Nat\nb₁ b₂ : R\n⊢ Iff (Eq ((MvPolynomial.monomial a₁) b₁) ((MvPolynomial.monomial a₂) b₂)) (Or (And (Eq a₁ a₂) (Eq b₁ b₂)) (And (Eq b₁ 0) (Eq b₂ 0)))","decl":"theorem monomial_eq_monomial_iff {α : Type*} (a₁ a₂ : α →₀ ℕ) (b₁ b₂ : R) :\n    monomial a₁ b₁ = monomial a₂ b₂ ↔ a₁ = a₂ ∧ b₁ = b₂ ∨ b₁ = 0 ∧ b₂ = 0 :=\n  Finsupp.single_eq_single_iff _ _ _ _\n\n"}
{"name":"MvPolynomial.monomial_eq","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\na : R\ns : Finsupp σ Nat\ninst✝ : CommSemiring R\n⊢ Eq ((MvPolynomial.monomial s) a) (HMul.hMul (MvPolynomial.C a) (s.prod fun n e => HPow.hPow (MvPolynomial.X n) e))","decl":"theorem monomial_eq : monomial s a = C a * (s.prod fun n e => X n ^ e : MvPolynomial σ R) := by\n  simp only [X_pow_eq_monomial, ← monomial_finsupp_sum_index, Finsupp.sum_single]\n\n"}
{"name":"MvPolynomial.prod_X_pow_eq_monomial","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ns : Finsupp σ Nat\ninst✝ : CommSemiring R\n⊢ Eq (s.support.prod fun x => HPow.hPow (MvPolynomial.X x) (s x)) ((MvPolynomial.monomial s) 1)","decl":"@[simp]\nlemma prod_X_pow_eq_monomial : ∏ x ∈ s.support, X x ^ s x = monomial s (1 : R) := by\n  simp only [monomial_eq, map_one, one_mul, Finsupp.prod]\n\n"}
{"name":"MvPolynomial.induction_on_monomial","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nM : MvPolynomial σ R → Prop\nh_C : ∀ (a : R), M (MvPolynomial.C a)\nh_X : ∀ (p : MvPolynomial σ R) (n : σ), M p → M (HMul.hMul p (MvPolynomial.X n))\ns : Finsupp σ Nat\na : R\n⊢ M ((MvPolynomial.monomial s) a)","decl":"theorem induction_on_monomial {M : MvPolynomial σ R → Prop} (h_C : ∀ a, M (C a))\n    (h_X : ∀ p n, M p → M (p * X n)) : ∀ s a, M (monomial s a) := by\n  intro s a\n  apply @Finsupp.induction σ ℕ _ _ s\n  · show M (monomial 0 a)\n    exact h_C a\n  · intro n e p _hpn _he ih\n    have : ∀ e : ℕ, M (monomial p a * X n ^ e) := by\n      intro e\n      induction e with\n      | zero => simp [ih]\n      | succ e e_ih => simp [ih, pow_succ, (mul_assoc _ _ _).symm, h_X, e_ih]\n    simp [add_comm, monomial_add_single, this]\n\n"}
{"name":"MvPolynomial.induction_on'","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nP : MvPolynomial σ R → Prop\np : MvPolynomial σ R\nh1 : ∀ (u : Finsupp σ Nat) (a : R), P ((MvPolynomial.monomial u) a)\nh2 : ∀ (p q : MvPolynomial σ R), P p → P q → P (HAdd.hAdd p q)\n⊢ P p","decl":"/-- Analog of `Polynomial.induction_on'`.\nTo prove something about mv_polynomials,\nit suffices to show the condition is closed under taking sums,\nand it holds for monomials. -/\n@[elab_as_elim]\ntheorem induction_on' {P : MvPolynomial σ R → Prop} (p : MvPolynomial σ R)\n    (h1 : ∀ (u : σ →₀ ℕ) (a : R), P (monomial u a))\n    (h2 : ∀ p q : MvPolynomial σ R, P p → P q → P (p + q)) : P p :=\n  Finsupp.induction p\n    (suffices P (monomial 0 0) by rwa [monomial_zero] at this\n    show P (monomial 0 0) from h1 0 0)\n    fun _ _ _ _ha _hb hPf => h2 _ _ (h1 _ _) hPf\n\n"}
{"name":"MvPolynomial.induction_on'''","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nM : MvPolynomial σ R → Prop\np : MvPolynomial σ R\nh_C : ∀ (a : R), M (MvPolynomial.C a)\nh_add_weak : ∀ (a : Finsupp σ Nat) (b : R) (f : Finsupp (Finsupp σ Nat) R), Not (Membership.mem f.support a) → Ne b 0 → M f → M (HAdd.hAdd (letFun ((MvPolynomial.monomial a) b) fun this => this) f)\n⊢ M p","decl":"/-- Similar to `MvPolynomial.induction_on` but only a weak form of `h_add` is required. -/\ntheorem induction_on''' {M : MvPolynomial σ R → Prop} (p : MvPolynomial σ R) (h_C : ∀ a, M (C a))\n    (h_add_weak :\n      ∀ (a : σ →₀ ℕ) (b : R) (f : (σ →₀ ℕ) →₀ R),\n        a ∉ f.support → b ≠ 0 → M f → M ((show (σ →₀ ℕ) →₀ R from monomial a b) + f)) :\n    M p :=\n    -- Porting note: I had to add the `show ... from ...` above, a type ascription was insufficient.\n  Finsupp.induction p (C_0.rec <| h_C 0) h_add_weak\n\n"}
{"name":"MvPolynomial.induction_on''","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nM : MvPolynomial σ R → Prop\np : MvPolynomial σ R\nh_C : ∀ (a : R), M (MvPolynomial.C a)\nh_add_weak : ∀ (a : Finsupp σ Nat) (b : R) (f : Finsupp (Finsupp σ Nat) R), Not (Membership.mem f.support a) → Ne b 0 → M f → M ((MvPolynomial.monomial a) b) → M (HAdd.hAdd (letFun ((MvPolynomial.monomial a) b) fun this => this) f)\nh_X : ∀ (p : MvPolynomial σ R) (n : σ), M p → M (HMul.hMul p (MvPolynomial.X n))\n⊢ M p","decl":"/-- Similar to `MvPolynomial.induction_on` but only a yet weaker form of `h_add` is required. -/\ntheorem induction_on'' {M : MvPolynomial σ R → Prop} (p : MvPolynomial σ R) (h_C : ∀ a, M (C a))\n    (h_add_weak :\n      ∀ (a : σ →₀ ℕ) (b : R) (f : (σ →₀ ℕ) →₀ R),\n        a ∉ f.support → b ≠ 0 → M f → M (monomial a b) →\n          M ((show (σ →₀ ℕ) →₀ R from monomial a b) + f))\n    (h_X : ∀ (p : MvPolynomial σ R) (n : σ), M p → M (p * MvPolynomial.X n)) : M p :=\n    -- Porting note: I had to add the `show ... from ...` above, a type ascription was insufficient.\n  induction_on''' p h_C fun a b f ha hb hf =>\n    h_add_weak a b f ha hb hf <| induction_on_monomial h_C h_X a b\n\n"}
{"name":"MvPolynomial.induction_on","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nM : MvPolynomial σ R → Prop\np : MvPolynomial σ R\nh_C : ∀ (a : R), M (MvPolynomial.C a)\nh_add : ∀ (p q : MvPolynomial σ R), M p → M q → M (HAdd.hAdd p q)\nh_X : ∀ (p : MvPolynomial σ R) (n : σ), M p → M (HMul.hMul p (MvPolynomial.X n))\n⊢ M p","decl":"/-- Analog of `Polynomial.induction_on`. -/\n@[recursor 5]\ntheorem induction_on {M : MvPolynomial σ R → Prop} (p : MvPolynomial σ R) (h_C : ∀ a, M (C a))\n    (h_add : ∀ p q, M p → M q → M (p + q)) (h_X : ∀ p n, M p → M (p * X n)) : M p :=\n  induction_on'' p h_C (fun a b f _ha _hb hf hm => h_add (monomial a b) f hm hf) h_X\n\n"}
{"name":"MvPolynomial.ringHom_ext","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\nA : Type u_2\ninst✝ : Semiring A\nf g : RingHom (MvPolynomial σ R) A\nhC : ∀ (r : R), Eq (f (MvPolynomial.C r)) (g (MvPolynomial.C r))\nhX : ∀ (i : σ), Eq (f (MvPolynomial.X i)) (g (MvPolynomial.X i))\n⊢ Eq f g","decl":"theorem ringHom_ext {A : Type*} [Semiring A] {f g : MvPolynomial σ R →+* A}\n    (hC : ∀ r, f (C r) = g (C r)) (hX : ∀ i, f (X i) = g (X i)) : f = g := by\n  refine AddMonoidAlgebra.ringHom_ext' ?_ ?_\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): this has high priority, but Lean still chooses `RingHom.ext`, why?\n  -- probably because of the type synonym\n  · ext x\n    exact hC _\n  · apply Finsupp.mulHom_ext'; intros x\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `Finsupp.mulHom_ext'` needs to have increased priority\n    apply MonoidHom.ext_mnat\n    exact hX _\n\n"}
{"name":"MvPolynomial.ringHom_ext'_iff","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\nA : Type u_2\ninst✝ : Semiring A\nf g : RingHom (MvPolynomial σ R) A\n⊢ Iff (Eq f g) (And (Eq (f.comp MvPolynomial.C) (g.comp MvPolynomial.C)) (∀ (i : σ), Eq (f (MvPolynomial.X i)) (g (MvPolynomial.X i))))","decl":"/-- See note [partially-applied ext lemmas]. -/\n@[ext 1100]\ntheorem ringHom_ext' {A : Type*} [Semiring A] {f g : MvPolynomial σ R →+* A}\n    (hC : f.comp C = g.comp C) (hX : ∀ i, f (X i) = g (X i)) : f = g :=\n  ringHom_ext (RingHom.ext_iff.1 hC) hX\n\n"}
{"name":"MvPolynomial.ringHom_ext'","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\nA : Type u_2\ninst✝ : Semiring A\nf g : RingHom (MvPolynomial σ R) A\nhC : Eq (f.comp MvPolynomial.C) (g.comp MvPolynomial.C)\nhX : ∀ (i : σ), Eq (f (MvPolynomial.X i)) (g (MvPolynomial.X i))\n⊢ Eq f g","decl":"/-- See note [partially-applied ext lemmas]. -/\n@[ext 1100]\ntheorem ringHom_ext' {A : Type*} [Semiring A] {f g : MvPolynomial σ R →+* A}\n    (hC : f.comp C = g.comp C) (hX : ∀ i, f (X i) = g (X i)) : f = g :=\n  ringHom_ext (RingHom.ext_iff.1 hC) hX\n\n"}
{"name":"MvPolynomial.hom_eq_hom","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nS₂ : Type w\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : Semiring S₂\nf g : RingHom (MvPolynomial σ R) S₂\nhC : Eq (f.comp MvPolynomial.C) (g.comp MvPolynomial.C)\nhX : ∀ (n : σ), Eq (f (MvPolynomial.X n)) (g (MvPolynomial.X n))\np : MvPolynomial σ R\n⊢ Eq (f p) (g p)","decl":"theorem hom_eq_hom [Semiring S₂] (f g : MvPolynomial σ R →+* S₂) (hC : f.comp C = g.comp C)\n    (hX : ∀ n : σ, f (X n) = g (X n)) (p : MvPolynomial σ R) : f p = g p :=\n  RingHom.congr_fun (ringHom_ext' hC hX) p\n\n"}
{"name":"MvPolynomial.is_id","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nf : RingHom (MvPolynomial σ R) (MvPolynomial σ R)\nhC : Eq (f.comp MvPolynomial.C) MvPolynomial.C\nhX : ∀ (n : σ), Eq (f (MvPolynomial.X n)) (MvPolynomial.X n)\np : MvPolynomial σ R\n⊢ Eq (f p) p","decl":"theorem is_id (f : MvPolynomial σ R →+* MvPolynomial σ R) (hC : f.comp C = C)\n    (hX : ∀ n : σ, f (X n) = X n) (p : MvPolynomial σ R) : f p = p :=\n  hom_eq_hom f (RingHom.id _) hC hX p\n\n"}
{"name":"MvPolynomial.algHom_ext'_iff","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝⁴ : CommSemiring R\nA : Type u_2\nB : Type u_3\ninst✝³ : CommSemiring A\ninst✝² : CommSemiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf g : AlgHom R (MvPolynomial σ A) B\n⊢ Iff (Eq f g) (And (Eq (f.comp (IsScalarTower.toAlgHom R A (MvPolynomial σ A))) (g.comp (IsScalarTower.toAlgHom R A (MvPolynomial σ A)))) (∀ (i : σ), Eq (f (MvPolynomial.X i)) (g (MvPolynomial.X i))))","decl":"@[ext 1100]\ntheorem algHom_ext' {A B : Type*} [CommSemiring A] [CommSemiring B] [Algebra R A] [Algebra R B]\n    {f g : MvPolynomial σ A →ₐ[R] B}\n    (h₁ :\n      f.comp (IsScalarTower.toAlgHom R A (MvPolynomial σ A)) =\n        g.comp (IsScalarTower.toAlgHom R A (MvPolynomial σ A)))\n    (h₂ : ∀ i, f (X i) = g (X i)) : f = g :=\n  AlgHom.coe_ringHom_injective (MvPolynomial.ringHom_ext' (congr_arg AlgHom.toRingHom h₁) h₂)\n\n"}
{"name":"MvPolynomial.algHom_ext'","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝⁴ : CommSemiring R\nA : Type u_2\nB : Type u_3\ninst✝³ : CommSemiring A\ninst✝² : CommSemiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf g : AlgHom R (MvPolynomial σ A) B\nh₁ : Eq (f.comp (IsScalarTower.toAlgHom R A (MvPolynomial σ A))) (g.comp (IsScalarTower.toAlgHom R A (MvPolynomial σ A)))\nh₂ : ∀ (i : σ), Eq (f (MvPolynomial.X i)) (g (MvPolynomial.X i))\n⊢ Eq f g","decl":"@[ext 1100]\ntheorem algHom_ext' {A B : Type*} [CommSemiring A] [CommSemiring B] [Algebra R A] [Algebra R B]\n    {f g : MvPolynomial σ A →ₐ[R] B}\n    (h₁ :\n      f.comp (IsScalarTower.toAlgHom R A (MvPolynomial σ A)) =\n        g.comp (IsScalarTower.toAlgHom R A (MvPolynomial σ A)))\n    (h₂ : ∀ i, f (X i) = g (X i)) : f = g :=\n  AlgHom.coe_ringHom_injective (MvPolynomial.ringHom_ext' (congr_arg AlgHom.toRingHom h₁) h₂)\n\n"}
{"name":"MvPolynomial.algHom_ext_iff","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝² : CommSemiring R\nA : Type u_2\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf g : AlgHom R (MvPolynomial σ R) A\n⊢ Iff (Eq f g) (∀ (i : σ), Eq (f (MvPolynomial.X i)) (g (MvPolynomial.X i)))","decl":"@[ext 1200]\ntheorem algHom_ext {A : Type*} [Semiring A] [Algebra R A] {f g : MvPolynomial σ R →ₐ[R] A}\n    (hf : ∀ i : σ, f (X i) = g (X i)) : f = g :=\n  AddMonoidAlgebra.algHom_ext' (mulHom_ext' fun X : σ => MonoidHom.ext_mnat (hf X))\n\n"}
{"name":"MvPolynomial.algHom_ext","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝² : CommSemiring R\nA : Type u_2\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf g : AlgHom R (MvPolynomial σ R) A\nhf : ∀ (i : σ), Eq (f (MvPolynomial.X i)) (g (MvPolynomial.X i))\n⊢ Eq f g","decl":"@[ext 1200]\ntheorem algHom_ext {A : Type*} [Semiring A] [Algebra R A] {f g : MvPolynomial σ R →ₐ[R] A}\n    (hf : ∀ i : σ, f (X i) = g (X i)) : f = g :=\n  AddMonoidAlgebra.algHom_ext' (mulHom_ext' fun X : σ => MonoidHom.ext_mnat (hf X))\n\n"}
{"name":"MvPolynomial.algHom_C","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝² : CommSemiring R\nA : Type u_2\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf : AlgHom R (MvPolynomial σ R) A\nr : R\n⊢ Eq (f (MvPolynomial.C r)) ((algebraMap R A) r)","decl":"@[simp]\ntheorem algHom_C {A : Type*} [Semiring A] [Algebra R A] (f : MvPolynomial σ R →ₐ[R] A) (r : R) :\n    f (C r) = algebraMap R A r :=\n  f.commutes r\n\n"}
{"name":"MvPolynomial.adjoin_range_X","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (Algebra.adjoin R (Set.range MvPolynomial.X)) Top.top","decl":"@[simp]\ntheorem adjoin_range_X : Algebra.adjoin R (range (X : σ → MvPolynomial σ R)) = ⊤ := by\n  set S := Algebra.adjoin R (range (X : σ → MvPolynomial σ R))\n  refine top_unique fun p hp => ?_; clear hp\n  induction p using MvPolynomial.induction_on with\n  | h_C => exact S.algebraMap_mem _\n  | h_add p q hp hq => exact S.add_mem hp hq\n  | h_X p i hp => exact S.mul_mem hp (Algebra.subset_adjoin <| mem_range_self _)\n\n"}
{"name":"MvPolynomial.linearMap_ext","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝² : CommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf g : LinearMap (RingHom.id R) (MvPolynomial σ R) M\nh : ∀ (s : Finsupp σ Nat), Eq (f.comp (MvPolynomial.monomial s)) (g.comp (MvPolynomial.monomial s))\n⊢ Eq f g","decl":"@[ext]\ntheorem linearMap_ext {M : Type*} [AddCommMonoid M] [Module R M] {f g : MvPolynomial σ R →ₗ[R] M}\n    (h : ∀ s, f ∘ₗ monomial s = g ∘ₗ monomial s) : f = g :=\n  Finsupp.lhom_ext' h\n\n"}
{"name":"MvPolynomial.linearMap_ext_iff","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝² : CommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf g : LinearMap (RingHom.id R) (MvPolynomial σ R) M\n⊢ Iff (Eq f g) (∀ (s : Finsupp σ Nat), Eq (f.comp (MvPolynomial.monomial s)) (g.comp (MvPolynomial.monomial s)))","decl":"@[ext]\ntheorem linearMap_ext {M : Type*} [AddCommMonoid M] [Module R M] {f g : MvPolynomial σ R →ₗ[R] M}\n    (h : ∀ s, f ∘ₗ monomial s = g ∘ₗ monomial s) : f = g :=\n  Finsupp.lhom_ext' h\n\n"}
{"name":"MvPolynomial.finsupp_support_eq_support","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\n⊢ Eq p.support p.support","decl":"theorem finsupp_support_eq_support (p : MvPolynomial σ R) : Finsupp.support p = p.support :=\n  rfl\n\n"}
{"name":"MvPolynomial.support_monomial","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\na : R\ns : Finsupp σ Nat\ninst✝ : CommSemiring R\nh : Decidable (Eq a 0)\n⊢ Eq ((MvPolynomial.monomial s) a).support (ite (Eq a 0) EmptyCollection.emptyCollection (Singleton.singleton s))","decl":"theorem support_monomial [h : Decidable (a = 0)] :\n    (monomial s a).support = if a = 0 then ∅ else {s} := by\n  rw [← Subsingleton.elim (Classical.decEq R a 0) h]\n  rfl\n  -- Porting note: the proof in Lean 3 wasn't fundamentally better and needed `by convert rfl`\n  -- the issue is the different decidability instances in the `ite` expressions\n\n"}
{"name":"MvPolynomial.support_monomial_subset","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\na : R\ns : Finsupp σ Nat\ninst✝ : CommSemiring R\n⊢ HasSubset.Subset ((MvPolynomial.monomial s) a).support (Singleton.singleton s)","decl":"theorem support_monomial_subset : (monomial s a).support ⊆ {s} :=\n  support_single_subset\n\n"}
{"name":"MvPolynomial.support_add","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\np q : MvPolynomial σ R\ninst✝ : DecidableEq σ\n⊢ HasSubset.Subset (HAdd.hAdd p q).support (Union.union p.support q.support)","decl":"theorem support_add [DecidableEq σ] : (p + q).support ⊆ p.support ∪ q.support :=\n  Finsupp.support_add\n\n"}
{"name":"MvPolynomial.support_X","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\nn : σ\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\n⊢ Eq (MvPolynomial.X n).support (Singleton.singleton (Finsupp.single n 1))","decl":"theorem support_X [Nontrivial R] : (X n : MvPolynomial σ R).support = {Finsupp.single n 1} := by\n  classical rw [X, support_monomial, if_neg]; exact one_ne_zero\n\n"}
{"name":"MvPolynomial.support_X_pow","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\ns : σ\nn : Nat\n⊢ Eq (HPow.hPow (MvPolynomial.X s) n).support (Singleton.singleton (Finsupp.single s n))","decl":"theorem support_X_pow [Nontrivial R] (s : σ) (n : ℕ) :\n    (X s ^ n : MvPolynomial σ R).support = {Finsupp.single s n} := by\n  classical\n    rw [X_pow_eq_monomial, support_monomial, if_neg (one_ne_zero' R)]\n\n"}
{"name":"MvPolynomial.support_zero","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.support 0) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem support_zero : (0 : MvPolynomial σ R).support = ∅ :=\n  rfl\n\n"}
{"name":"MvPolynomial.support_smul","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\nS₁ : Type u_2\ninst✝ : SMulZeroClass S₁ R\na : S₁\nf : MvPolynomial σ R\n⊢ HasSubset.Subset (HSMul.hSMul a f).support f.support","decl":"theorem support_smul {S₁ : Type*} [SMulZeroClass S₁ R] {a : S₁} {f : MvPolynomial σ R} :\n    (a • f).support ⊆ f.support :=\n  Finsupp.support_smul\n\n"}
{"name":"MvPolynomial.support_sum","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\nα : Type u_2\ninst✝ : DecidableEq σ\ns : Finset α\nf : α → MvPolynomial σ R\n⊢ HasSubset.Subset (s.sum fun x => f x).support (s.biUnion fun x => (f x).support)","decl":"theorem support_sum {α : Type*} [DecidableEq σ] {s : Finset α} {f : α → MvPolynomial σ R} :\n    (∑ x ∈ s, f x).support ⊆ s.biUnion fun x => (f x).support :=\n  Finsupp.support_finset_sum\n\n"}
{"name":"MvPolynomial.mem_support_iff","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\nm : Finsupp σ Nat\n⊢ Iff (Membership.mem p.support m) (Ne (MvPolynomial.coeff m p) 0)","decl":"@[simp]\ntheorem mem_support_iff {p : MvPolynomial σ R} {m : σ →₀ ℕ} : m ∈ p.support ↔ p.coeff m ≠ 0 := by\n  simp [support, coeff]\n\n"}
{"name":"MvPolynomial.not_mem_support_iff","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\nm : Finsupp σ Nat\n⊢ Iff (Not (Membership.mem p.support m)) (Eq (MvPolynomial.coeff m p) 0)","decl":"theorem not_mem_support_iff {p : MvPolynomial σ R} {m : σ →₀ ℕ} : m ∉ p.support ↔ p.coeff m = 0 :=\n  by simp\n\n"}
{"name":"MvPolynomial.sum_def","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\nA : Type u_2\ninst✝ : AddCommMonoid A\np : MvPolynomial σ R\nb : Finsupp σ Nat → R → A\n⊢ Eq (Finsupp.sum p b) (p.support.sum fun m => b m (MvPolynomial.coeff m p))","decl":"theorem sum_def {A} [AddCommMonoid A] {p : MvPolynomial σ R} {b : (σ →₀ ℕ) → R → A} :\n    p.sum b = ∑ m ∈ p.support, b m (p.coeff m) := by simp [support, Finsupp.sum, coeff]\n\n"}
{"name":"MvPolynomial.support_mul","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\np q : MvPolynomial σ R\n⊢ HasSubset.Subset (HMul.hMul p q).support (HAdd.hAdd p.support q.support)","decl":"theorem support_mul [DecidableEq σ] (p q : MvPolynomial σ R) :\n    (p * q).support ⊆ p.support + q.support :=\n  AddMonoidAlgebra.support_mul p q\n\n"}
{"name":"MvPolynomial.ext_iff","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np q : MvPolynomial σ R\n⊢ Iff (Eq p q) (∀ (m : Finsupp σ Nat), Eq (MvPolynomial.coeff m p) (MvPolynomial.coeff m q))","decl":"@[ext]\ntheorem ext (p q : MvPolynomial σ R) : (∀ m, coeff m p = coeff m q) → p = q :=\n  Finsupp.ext\n\n"}
{"name":"MvPolynomial.ext","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np q : MvPolynomial σ R\na✝ : ∀ (m : Finsupp σ Nat), Eq (MvPolynomial.coeff m p) (MvPolynomial.coeff m q)\n⊢ Eq p q","decl":"@[ext]\ntheorem ext (p q : MvPolynomial σ R) : (∀ m, coeff m p = coeff m q) → p = q :=\n  Finsupp.ext\n\n"}
{"name":"MvPolynomial.coeff_add","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nm : Finsupp σ Nat\np q : MvPolynomial σ R\n⊢ Eq (MvPolynomial.coeff m (HAdd.hAdd p q)) (HAdd.hAdd (MvPolynomial.coeff m p) (MvPolynomial.coeff m q))","decl":"@[simp]\ntheorem coeff_add (m : σ →₀ ℕ) (p q : MvPolynomial σ R) : coeff m (p + q) = coeff m p + coeff m q :=\n  add_apply p q m\n\n"}
{"name":"MvPolynomial.coeff_smul","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\nS₁ : Type u_2\ninst✝ : SMulZeroClass S₁ R\nm : Finsupp σ Nat\nC : S₁\np : MvPolynomial σ R\n⊢ Eq (MvPolynomial.coeff m (HSMul.hSMul C p)) (HSMul.hSMul C (MvPolynomial.coeff m p))","decl":"@[simp]\ntheorem coeff_smul {S₁ : Type*} [SMulZeroClass S₁ R] (m : σ →₀ ℕ) (C : S₁) (p : MvPolynomial σ R) :\n    coeff m (C • p) = C • coeff m p :=\n  smul_apply C p m\n\n"}
{"name":"MvPolynomial.coeff_zero","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nm : Finsupp σ Nat\n⊢ Eq (MvPolynomial.coeff m 0) 0","decl":"@[simp]\ntheorem coeff_zero (m : σ →₀ ℕ) : coeff m (0 : MvPolynomial σ R) = 0 :=\n  rfl\n\n"}
{"name":"MvPolynomial.coeff_zero_X","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ni : σ\n⊢ Eq (MvPolynomial.coeff 0 (MvPolynomial.X i)) 0","decl":"@[simp]\ntheorem coeff_zero_X (i : σ) : coeff 0 (X i : MvPolynomial σ R) = 0 :=\n  single_eq_of_ne fun h => by cases Finsupp.single_eq_zero.1 h\n\n"}
{"name":"MvPolynomial.coeffAddMonoidHom_apply","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nm : Finsupp σ Nat\np : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.coeffAddMonoidHom m) p) (MvPolynomial.coeff m p)","decl":"/-- `MvPolynomial.coeff m` but promoted to an `AddMonoidHom`. -/\n@[simps]\ndef coeffAddMonoidHom (m : σ →₀ ℕ) : MvPolynomial σ R →+ R where\n  toFun := coeff m\n  map_zero' := coeff_zero m\n  map_add' := coeff_add m\n\n"}
{"name":"MvPolynomial.lcoeff_apply","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nm : Finsupp σ Nat\np : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.lcoeff R m) p) (MvPolynomial.coeff m p)","decl":"variable (R) in\n/-- `MvPolynomial.coeff m` but promoted to a `LinearMap`. -/\n@[simps]\ndef lcoeff (m : σ →₀ ℕ) : MvPolynomial σ R →ₗ[R] R where\n  toFun := coeff m\n  map_add' := coeff_add m\n  map_smul' := coeff_smul m\n\n"}
{"name":"MvPolynomial.coeff_sum","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nX : Type u_2\ns : Finset X\nf : X → MvPolynomial σ R\nm : Finsupp σ Nat\n⊢ Eq (MvPolynomial.coeff m (s.sum fun x => f x)) (s.sum fun x => MvPolynomial.coeff m (f x))","decl":"theorem coeff_sum {X : Type*} (s : Finset X) (f : X → MvPolynomial σ R) (m : σ →₀ ℕ) :\n    coeff m (∑ x ∈ s, f x) = ∑ x ∈ s, coeff m (f x) :=\n  map_sum (@coeffAddMonoidHom R σ _ _) _ s\n\n"}
{"name":"MvPolynomial.monic_monomial_eq","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nm : Finsupp σ Nat\n⊢ Eq ((MvPolynomial.monomial m) 1) (m.prod fun n e => HPow.hPow (MvPolynomial.X n) e)","decl":"theorem monic_monomial_eq (m) :\n    monomial m (1 : R) = (m.prod fun n e => X n ^ e : MvPolynomial σ R) := by simp [monomial_eq]\n\n"}
{"name":"MvPolynomial.coeff_monomial","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\nm n : Finsupp σ Nat\na : R\n⊢ Eq (MvPolynomial.coeff m ((MvPolynomial.monomial n) a)) (ite (Eq n m) a 0)","decl":"@[simp]\ntheorem coeff_monomial [DecidableEq σ] (m n) (a) :\n    coeff m (monomial n a : MvPolynomial σ R) = if n = m then a else 0 :=\n  Finsupp.single_apply\n\n"}
{"name":"MvPolynomial.coeff_C","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\nm : Finsupp σ Nat\na : R\n⊢ Eq (MvPolynomial.coeff m (MvPolynomial.C a)) (ite (Eq 0 m) a 0)","decl":"@[simp]\ntheorem coeff_C [DecidableEq σ] (m) (a) :\n    coeff m (C a : MvPolynomial σ R) = if 0 = m then a else 0 :=\n  Finsupp.single_apply\n\n"}
{"name":"MvPolynomial.eq_C_of_isEmpty","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : IsEmpty σ\np : MvPolynomial σ R\n⊢ Eq p (MvPolynomial.C (MvPolynomial.coeff 0 p))","decl":"lemma eq_C_of_isEmpty [IsEmpty σ] (p : MvPolynomial σ R) :\n    p = C (p.coeff 0) := by\n  obtain ⟨x, rfl⟩ := C_surjective σ p\n  simp\n\n"}
{"name":"MvPolynomial.coeff_one","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\nm : Finsupp σ Nat\n⊢ Eq (MvPolynomial.coeff m 1) (ite (Eq 0 m) 1 0)","decl":"theorem coeff_one [DecidableEq σ] (m) : coeff m (1 : MvPolynomial σ R) = if 0 = m then 1 else 0 :=\n  coeff_C m 1\n\n"}
{"name":"MvPolynomial.coeff_zero_C","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\na : R\n⊢ Eq (MvPolynomial.coeff 0 (MvPolynomial.C a)) a","decl":"@[simp]\ntheorem coeff_zero_C (a) : coeff 0 (C a : MvPolynomial σ R) = a :=\n  single_eq_same\n\n"}
{"name":"MvPolynomial.coeff_zero_one","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.coeff 0 1) 1","decl":"@[simp]\ntheorem coeff_zero_one : coeff 0 (1 : MvPolynomial σ R) = 1 :=\n  coeff_zero_C 1\n\n"}
{"name":"MvPolynomial.coeff_X_pow","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\ni : σ\nm : Finsupp σ Nat\nk : Nat\n⊢ Eq (MvPolynomial.coeff m (HPow.hPow (MvPolynomial.X i) k)) (ite (Eq (Finsupp.single i k) m) 1 0)","decl":"theorem coeff_X_pow [DecidableEq σ] (i : σ) (m) (k : ℕ) :\n    coeff m (X i ^ k : MvPolynomial σ R) = if Finsupp.single i k = m then 1 else 0 := by\n  have := coeff_monomial m (Finsupp.single i k) (1 : R)\n  rwa [@monomial_eq _ _ (1 : R) (Finsupp.single i k) _, C_1, one_mul, Finsupp.prod_single_index]\n    at this\n  exact pow_zero _\n\n"}
{"name":"MvPolynomial.coeff_X'","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\ni : σ\nm : Finsupp σ Nat\n⊢ Eq (MvPolynomial.coeff m (MvPolynomial.X i)) (ite (Eq (Finsupp.single i 1) m) 1 0)","decl":"theorem coeff_X' [DecidableEq σ] (i : σ) (m) :\n    coeff m (X i : MvPolynomial σ R) = if Finsupp.single i 1 = m then 1 else 0 := by\n  rw [← coeff_X_pow, pow_one]\n\n"}
{"name":"MvPolynomial.coeff_X","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ni : σ\n⊢ Eq (MvPolynomial.coeff (Finsupp.single i 1) (MvPolynomial.X i)) 1","decl":"@[simp]\ntheorem coeff_X (i : σ) : coeff (Finsupp.single i 1) (X i : MvPolynomial σ R) = 1 := by\n  classical rw [coeff_X', if_pos rfl]\n\n"}
{"name":"MvPolynomial.coeff_C_mul","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nm : Finsupp σ Nat\na : R\np : MvPolynomial σ R\n⊢ Eq (MvPolynomial.coeff m (HMul.hMul (MvPolynomial.C a) p)) (HMul.hMul a (MvPolynomial.coeff m p))","decl":"@[simp]\ntheorem coeff_C_mul (m) (a : R) (p : MvPolynomial σ R) : coeff m (C a * p) = a * coeff m p := by\n  classical\n  rw [mul_def, sum_C]\n  · simp +contextual [sum_def, coeff_sum]\n  simp\n\n"}
{"name":"MvPolynomial.coeff_mul","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\np q : MvPolynomial σ R\nn : Finsupp σ Nat\n⊢ Eq (MvPolynomial.coeff n (HMul.hMul p q)) ((Finset.HasAntidiagonal.antidiagonal n).sum fun x => HMul.hMul (MvPolynomial.coeff x.1 p) (MvPolynomial.coeff x.2 q))","decl":"theorem coeff_mul [DecidableEq σ] (p q : MvPolynomial σ R) (n : σ →₀ ℕ) :\n    coeff n (p * q) = ∑ x ∈ Finset.antidiagonal n, coeff x.1 p * coeff x.2 q :=\n  AddMonoidAlgebra.mul_apply_antidiagonal p q _ _ Finset.mem_antidiagonal\n\n"}
{"name":"MvPolynomial.coeff_mul_monomial","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nm s : Finsupp σ Nat\nr : R\np : MvPolynomial σ R\n⊢ Eq (MvPolynomial.coeff (HAdd.hAdd m s) (HMul.hMul p ((MvPolynomial.monomial s) r))) (HMul.hMul (MvPolynomial.coeff m p) r)","decl":"@[simp]\ntheorem coeff_mul_monomial (m) (s : σ →₀ ℕ) (r : R) (p : MvPolynomial σ R) :\n    coeff (m + s) (p * monomial s r) = coeff m p * r :=\n  AddMonoidAlgebra.mul_single_apply_aux p _ _ _ _ fun _a _ => add_left_inj _\n\n"}
{"name":"MvPolynomial.coeff_monomial_mul","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nm s : Finsupp σ Nat\nr : R\np : MvPolynomial σ R\n⊢ Eq (MvPolynomial.coeff (HAdd.hAdd s m) (HMul.hMul ((MvPolynomial.monomial s) r) p)) (HMul.hMul r (MvPolynomial.coeff m p))","decl":"@[simp]\ntheorem coeff_monomial_mul (m) (s : σ →₀ ℕ) (r : R) (p : MvPolynomial σ R) :\n    coeff (s + m) (monomial s r * p) = r * coeff m p :=\n  AddMonoidAlgebra.single_mul_apply_aux p _ _ _ _ fun _a _ => add_right_inj _\n\n"}
{"name":"MvPolynomial.coeff_mul_X","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nm : Finsupp σ Nat\ns : σ\np : MvPolynomial σ R\n⊢ Eq (MvPolynomial.coeff (HAdd.hAdd m (Finsupp.single s 1)) (HMul.hMul p (MvPolynomial.X s))) (MvPolynomial.coeff m p)","decl":"@[simp]\ntheorem coeff_mul_X (m) (s : σ) (p : MvPolynomial σ R) :\n    coeff (m + Finsupp.single s 1) (p * X s) = coeff m p :=\n  (coeff_mul_monomial _ _ _ _).trans (mul_one _)\n\n"}
{"name":"MvPolynomial.coeff_X_mul","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nm : Finsupp σ Nat\ns : σ\np : MvPolynomial σ R\n⊢ Eq (MvPolynomial.coeff (HAdd.hAdd (Finsupp.single s 1) m) (HMul.hMul (MvPolynomial.X s) p)) (MvPolynomial.coeff m p)","decl":"@[simp]\ntheorem coeff_X_mul (m) (s : σ) (p : MvPolynomial σ R) :\n    coeff (Finsupp.single s 1 + m) (X s * p) = coeff m p :=\n  (coeff_monomial_mul _ _ _ _).trans (one_mul _)\n\n"}
{"name":"MvPolynomial.coeff_single_X_pow","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\ns s' : σ\nn n' : Nat\n⊢ Eq (MvPolynomial.coeff (Finsupp.single s' n') (HPow.hPow (MvPolynomial.X s) n)) (ite (Or (And (Eq s s') (Eq n n')) (And (Eq n 0) (Eq n' 0))) 1 0)","decl":"lemma coeff_single_X_pow [DecidableEq σ] (s s' : σ) (n n' : ℕ) :\n    (X (R := R) s ^ n).coeff (Finsupp.single s' n')\n    = if s = s' ∧ n = n' ∨ n = 0 ∧ n' = 0 then 1 else 0 := by\n  simp only [coeff_X_pow, single_eq_single_iff]\n\n"}
{"name":"MvPolynomial.coeff_single_X","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\ns s' : σ\nn : Nat\n⊢ Eq (MvPolynomial.coeff (Finsupp.single s' n) (MvPolynomial.X s)) (ite (And (Eq n 1) (Eq s s')) 1 0)","decl":"@[simp]\nlemma coeff_single_X [DecidableEq σ] (s s' : σ) (n : ℕ) :\n    (X s).coeff (R := R) (Finsupp.single s' n) = if n = 1 ∧ s = s' then 1 else 0 := by\n  simpa [eq_comm, and_comm] using coeff_single_X_pow s s' 1 n\n\n"}
{"name":"MvPolynomial.support_mul_X","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ns : σ\np : MvPolynomial σ R\n⊢ Eq (HMul.hMul p (MvPolynomial.X s)).support (Finset.map (addRightEmbedding (Finsupp.single s 1)) p.support)","decl":"@[simp]\ntheorem support_mul_X (s : σ) (p : MvPolynomial σ R) :\n    (p * X s).support = p.support.map (addRightEmbedding (Finsupp.single s 1)) :=\n  AddMonoidAlgebra.support_mul_single p _ (by simp) _\n\n"}
{"name":"MvPolynomial.support_X_mul","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ns : σ\np : MvPolynomial σ R\n⊢ Eq (HMul.hMul (MvPolynomial.X s) p).support (Finset.map (addLeftEmbedding (Finsupp.single s 1)) p.support)","decl":"@[simp]\ntheorem support_X_mul (s : σ) (p : MvPolynomial σ R) :\n    (X s * p).support = p.support.map (addLeftEmbedding (Finsupp.single s 1)) :=\n  AddMonoidAlgebra.support_single_mul p _ (by simp) _\n\n"}
{"name":"MvPolynomial.support_smul_eq","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝³ : CommSemiring R\nS₁ : Type u_2\ninst✝² : Semiring S₁\ninst✝¹ : Module S₁ R\ninst✝ : NoZeroSMulDivisors S₁ R\na : S₁\nh : Ne a 0\np : MvPolynomial σ R\n⊢ Eq (HSMul.hSMul a p).support p.support","decl":"@[simp]\ntheorem support_smul_eq {S₁ : Type*} [Semiring S₁] [Module S₁ R] [NoZeroSMulDivisors S₁ R] {a : S₁}\n    (h : a ≠ 0) (p : MvPolynomial σ R) : (a • p).support = p.support :=\n  Finsupp.support_smul_eq h\n\n"}
{"name":"MvPolynomial.support_sdiff_support_subset_support_add","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\np q : MvPolynomial σ R\n⊢ HasSubset.Subset (SDiff.sdiff p.support q.support) (HAdd.hAdd p q).support","decl":"theorem support_sdiff_support_subset_support_add [DecidableEq σ] (p q : MvPolynomial σ R) :\n    p.support \\ q.support ⊆ (p + q).support := by\n  intro m hm\n  simp only [Classical.not_not, mem_support_iff, Finset.mem_sdiff, Ne] at hm\n  simp [hm.2, hm.1]\n\n"}
{"name":"MvPolynomial.support_symmDiff_support_subset_support_add","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\np q : MvPolynomial σ R\n⊢ HasSubset.Subset (symmDiff p.support q.support) (HAdd.hAdd p q).support","decl":"open scoped symmDiff in\ntheorem support_symmDiff_support_subset_support_add [DecidableEq σ] (p q : MvPolynomial σ R) :\n    p.support ∆ q.support ⊆ (p + q).support := by\n  rw [symmDiff_def, Finset.sup_eq_union]\n  apply Finset.union_subset\n  · exact support_sdiff_support_subset_support_add p q\n  · rw [add_comm]\n    exact support_sdiff_support_subset_support_add q p\n\n"}
{"name":"MvPolynomial.coeff_mul_monomial'","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nm s : Finsupp σ Nat\nr : R\np : MvPolynomial σ R\n⊢ Eq (MvPolynomial.coeff m (HMul.hMul p ((MvPolynomial.monomial s) r))) (ite (LE.le s m) (HMul.hMul (MvPolynomial.coeff (HSub.hSub m s) p) r) 0)","decl":"theorem coeff_mul_monomial' (m) (s : σ →₀ ℕ) (r : R) (p : MvPolynomial σ R) :\n    coeff m (p * monomial s r) = if s ≤ m then coeff (m - s) p * r else 0 := by\n  classical\n  split_ifs with h\n  · conv_rhs => rw [← coeff_mul_monomial _ s]\n    congr with t\n    rw [tsub_add_cancel_of_le h]\n  · contrapose! h\n    rw [← mem_support_iff] at h\n    obtain ⟨j, -, rfl⟩ : ∃ j ∈ support p, j + s = m := by\n      simpa [Finset.mem_add]\n        using Finset.add_subset_add_left support_monomial_subset <| support_mul _ _ h\n    exact le_add_left le_rfl\n\n"}
{"name":"MvPolynomial.coeff_monomial_mul'","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nm s : Finsupp σ Nat\nr : R\np : MvPolynomial σ R\n⊢ Eq (MvPolynomial.coeff m (HMul.hMul ((MvPolynomial.monomial s) r) p)) (ite (LE.le s m) (HMul.hMul r (MvPolynomial.coeff (HSub.hSub m s) p)) 0)","decl":"theorem coeff_monomial_mul' (m) (s : σ →₀ ℕ) (r : R) (p : MvPolynomial σ R) :\n    coeff m (monomial s r * p) = if s ≤ m then r * coeff (m - s) p else 0 := by\n  -- note that if we allow `R` to be non-commutative we will have to duplicate the proof above.\n  rw [mul_comm, mul_comm r]\n  exact coeff_mul_monomial' _ _ _ _\n\n"}
{"name":"MvPolynomial.coeff_mul_X'","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\nm : Finsupp σ Nat\ns : σ\np : MvPolynomial σ R\n⊢ Eq (MvPolynomial.coeff m (HMul.hMul p (MvPolynomial.X s))) (ite (Membership.mem m.support s) (MvPolynomial.coeff (HSub.hSub m (Finsupp.single s 1)) p) 0)","decl":"theorem coeff_mul_X' [DecidableEq σ] (m) (s : σ) (p : MvPolynomial σ R) :\n    coeff m (p * X s) = if s ∈ m.support then coeff (m - Finsupp.single s 1) p else 0 := by\n  refine (coeff_mul_monomial' _ _ _ _).trans ?_\n  simp_rw [Finsupp.single_le_iff, Finsupp.mem_support_iff, Nat.succ_le_iff, pos_iff_ne_zero,\n    mul_one]\n\n"}
{"name":"MvPolynomial.coeff_X_mul'","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\nm : Finsupp σ Nat\ns : σ\np : MvPolynomial σ R\n⊢ Eq (MvPolynomial.coeff m (HMul.hMul (MvPolynomial.X s) p)) (ite (Membership.mem m.support s) (MvPolynomial.coeff (HSub.hSub m (Finsupp.single s 1)) p) 0)","decl":"theorem coeff_X_mul' [DecidableEq σ] (m) (s : σ) (p : MvPolynomial σ R) :\n    coeff m (X s * p) = if s ∈ m.support then coeff (m - Finsupp.single s 1) p else 0 := by\n  refine (coeff_monomial_mul' _ _ _ _).trans ?_\n  simp_rw [Finsupp.single_le_iff, Finsupp.mem_support_iff, Nat.succ_le_iff, pos_iff_ne_zero,\n    one_mul]\n\n"}
{"name":"MvPolynomial.eq_zero_iff","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\n⊢ Iff (Eq p 0) (∀ (d : Finsupp σ Nat), Eq (MvPolynomial.coeff d p) 0)","decl":"theorem eq_zero_iff {p : MvPolynomial σ R} : p = 0 ↔ ∀ d, coeff d p = 0 := by\n  rw [MvPolynomial.ext_iff]\n  simp only [coeff_zero]\n\n"}
{"name":"MvPolynomial.ne_zero_iff","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\n⊢ Iff (Ne p 0) (Exists fun d => Ne (MvPolynomial.coeff d p) 0)","decl":"theorem ne_zero_iff {p : MvPolynomial σ R} : p ≠ 0 ↔ ∃ d, coeff d p ≠ 0 := by\n  rw [Ne, eq_zero_iff]\n  push_neg\n  rfl\n\n"}
{"name":"MvPolynomial.X_ne_zero","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\ns : σ\n⊢ Ne (MvPolynomial.X s) 0","decl":"@[simp]\ntheorem X_ne_zero [Nontrivial R] (s : σ) :\n    X (R := R) s ≠ 0 := by\n  rw [ne_zero_iff]\n  use Finsupp.single s 1\n  simp only [coeff_X, ne_eq, one_ne_zero, not_false_eq_true]\n\n"}
{"name":"MvPolynomial.support_eq_empty","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\n⊢ Iff (Eq p.support EmptyCollection.emptyCollection) (Eq p 0)","decl":"@[simp]\ntheorem support_eq_empty {p : MvPolynomial σ R} : p.support = ∅ ↔ p = 0 :=\n  Finsupp.support_eq_empty\n\n"}
{"name":"MvPolynomial.support_nonempty","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\n⊢ Iff p.support.Nonempty (Ne p 0)","decl":"@[simp]\nlemma support_nonempty {p : MvPolynomial σ R} : p.support.Nonempty ↔ p ≠ 0 := by\n  rw [Finset.nonempty_iff_ne_empty, ne_eq, support_eq_empty]\n\n"}
{"name":"MvPolynomial.exists_coeff_ne_zero","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\nh : Ne p 0\n⊢ Exists fun d => Ne (MvPolynomial.coeff d p) 0","decl":"theorem exists_coeff_ne_zero {p : MvPolynomial σ R} (h : p ≠ 0) : ∃ d, coeff d p ≠ 0 :=\n  ne_zero_iff.mp h\n\n"}
{"name":"MvPolynomial.C_dvd_iff_dvd_coeff","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nr : R\nφ : MvPolynomial σ R\n⊢ Iff (Dvd.dvd (MvPolynomial.C r) φ) (∀ (i : Finsupp σ Nat), Dvd.dvd r (MvPolynomial.coeff i φ))","decl":"theorem C_dvd_iff_dvd_coeff (r : R) (φ : MvPolynomial σ R) : C r ∣ φ ↔ ∀ i, r ∣ φ.coeff i := by\n  constructor\n  · rintro ⟨φ, rfl⟩ c\n    rw [coeff_C_mul]\n    apply dvd_mul_right\n  · intro h\n    choose C hc using h\n    classical\n      let c' : (σ →₀ ℕ) → R := fun i => if i ∈ φ.support then C i else 0\n      let ψ : MvPolynomial σ R := ∑ i ∈ φ.support, monomial i (c' i)\n      use ψ\n      apply MvPolynomial.ext\n      intro i\n      simp only [ψ, c', coeff_C_mul, coeff_sum, coeff_monomial, Finset.sum_ite_eq']\n      split_ifs with hi\n      · rw [hc]\n      · rw [not_mem_support_iff] at hi\n        rwa [mul_zero]\n\n"}
{"name":"MvPolynomial.isRegular_X","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\nn : σ\ninst✝ : CommSemiring R\n⊢ IsRegular (MvPolynomial.X n)","decl":"@[simp] lemma isRegular_X : IsRegular (X n : MvPolynomial σ R) := by\n  suffices IsLeftRegular (X n : MvPolynomial σ R) from\n    ⟨this, this.right_of_commute <| Commute.all _⟩\n  intro P Q (hPQ : (X n) * P = (X n) * Q)\n  ext i\n  rw [← coeff_X_mul i n P, hPQ, coeff_X_mul i n Q]\n\n"}
{"name":"MvPolynomial.isRegular_X_pow","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\nn : σ\ninst✝ : CommSemiring R\nk : Nat\n⊢ IsRegular (HPow.hPow (MvPolynomial.X n) k)","decl":"@[simp] lemma isRegular_X_pow (k : ℕ) : IsRegular (X n ^ k : MvPolynomial σ R) := isRegular_X.pow k\n\n"}
{"name":"MvPolynomial.isRegular_prod_X","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ns : Finset σ\n⊢ IsRegular (s.prod fun n => MvPolynomial.X n)","decl":"@[simp] lemma isRegular_prod_X (s : Finset σ) :\n    IsRegular (∏ n ∈ s, X n : MvPolynomial σ R) :=\n  IsRegular.prod fun _ _ ↦ isRegular_X\n\n"}
{"name":"MvPolynomial.coeffs_zero","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.coeffs 0) EmptyCollection.emptyCollection","decl":"@[simp]\nlemma coeffs_zero : coeffs (0 : MvPolynomial σ R) = ∅ :=\n  rfl\n\n"}
{"name":"MvPolynomial.coeffs_one","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\n⊢ HasSubset.Subset (MvPolynomial.coeffs 1) (Singleton.singleton 1)","decl":"lemma coeffs_one : coeffs (1 : MvPolynomial σ R) ⊆ {1} := by\n  classical\n    rw [coeffs, Finset.image_subset_iff]\n    simp_all [coeff_one]\n\n"}
{"name":"MvPolynomial.coeffs_eq_empty_of_subsingleton","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : Subsingleton R\np : MvPolynomial σ R\n⊢ Eq p.coeffs EmptyCollection.emptyCollection","decl":"@[nontriviality]\nlemma coeffs_eq_empty_of_subsingleton [Subsingleton R] (p : MvPolynomial σ R) : p.coeffs = ∅ := by\n  simpa [coeffs] using Subsingleton.eq_zero p\n\n"}
{"name":"MvPolynomial.coeffs_one_of_nontrivial","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\n⊢ Eq (MvPolynomial.coeffs 1) (Singleton.singleton 1)","decl":"@[simp]\nlemma coeffs_one_of_nontrivial [Nontrivial R] : coeffs (1 : MvPolynomial σ R) = {1} := by\n  apply Finset.Subset.antisymm coeffs_one\n  simp only [coeffs, Finset.singleton_subset_iff, Finset.mem_image]\n  exact ⟨0, by simp⟩\n\n"}
{"name":"MvPolynomial.mem_coeffs_iff","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\nc : R\n⊢ Iff (Membership.mem p.coeffs c) (Exists fun n => And (Membership.mem p.support n) (Eq c (MvPolynomial.coeff n p)))","decl":"lemma mem_coeffs_iff {p : MvPolynomial σ R} {c : R} :\n    c ∈ p.coeffs ↔ ∃ n ∈ p.support, c = p.coeff n := by\n  simp [coeffs, eq_comm, (Finset.mem_image)]\n\n"}
{"name":"MvPolynomial.coeff_mem_coeffs","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\nm : Finsupp σ Nat\nh : Ne (MvPolynomial.coeff m p) 0\n⊢ Membership.mem p.coeffs (MvPolynomial.coeff m p)","decl":"lemma coeff_mem_coeffs {p : MvPolynomial σ R} (m : σ →₀ ℕ)\n    (h : p.coeff m ≠ 0) : p.coeff m ∈ p.coeffs :=\n  letI := Classical.decEq R\n  Finset.mem_image_of_mem p.coeff (mem_support_iff.mpr h)\n\n"}
{"name":"MvPolynomial.zero_not_mem_coeffs","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\n⊢ Not (Membership.mem p.coeffs 0)","decl":"lemma zero_not_mem_coeffs (p : MvPolynomial σ R) : 0 ∉ p.coeffs := by\n  intro hz\n  obtain ⟨n, hnsupp, hn⟩ := mem_coeffs_iff.mp hz\n  exact (mem_support_iff.mp hnsupp) hn.symm\n\n"}
{"name":"MvPolynomial.constantCoeff_eq","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (⇑MvPolynomial.constantCoeff) (MvPolynomial.coeff 0)","decl":"theorem constantCoeff_eq : (constantCoeff : MvPolynomial σ R → R) = coeff 0 :=\n  rfl\n\n"}
{"name":"MvPolynomial.constantCoeff_C","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nr : R\n⊢ Eq (MvPolynomial.constantCoeff (MvPolynomial.C r)) r","decl":"@[simp]\ntheorem constantCoeff_C (r : R) : constantCoeff (C r : MvPolynomial σ R) = r := by\n  classical simp [constantCoeff_eq]\n\n"}
{"name":"MvPolynomial.constantCoeff_X","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ni : σ\n⊢ Eq (MvPolynomial.constantCoeff (MvPolynomial.X i)) 0","decl":"@[simp]\ntheorem constantCoeff_X (i : σ) : constantCoeff (X i : MvPolynomial σ R) = 0 := by\n  simp [constantCoeff_eq]\n\n"}
{"name":"MvPolynomial.constantCoeff_smul","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"S₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring S₁\nR : Type u_2\ninst✝ : SMulZeroClass R S₁\na : R\nf : MvPolynomial σ S₁\n⊢ Eq (MvPolynomial.constantCoeff (HSMul.hSMul a f)) (HSMul.hSMul a (MvPolynomial.constantCoeff f))","decl":"@[simp]\ntheorem constantCoeff_smul {R : Type*} [SMulZeroClass R S₁] (a : R) (f : MvPolynomial σ S₁) :\n    constantCoeff (a • f) = a • constantCoeff f :=\n  rfl\n\n"}
{"name":"MvPolynomial.constantCoeff_monomial","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\nd : Finsupp σ Nat\nr : R\n⊢ Eq (MvPolynomial.constantCoeff ((MvPolynomial.monomial d) r)) (ite (Eq d 0) r 0)","decl":"theorem constantCoeff_monomial [DecidableEq σ] (d : σ →₀ ℕ) (r : R) :\n    constantCoeff (monomial d r) = if d = 0 then r else 0 := by\n  rw [constantCoeff_eq, coeff_monomial]\n\n"}
{"name":"MvPolynomial.constantCoeff_comp_C","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.constantCoeff.comp MvPolynomial.C) (RingHom.id R)","decl":"@[simp]\ntheorem constantCoeff_comp_C : constantCoeff.comp (C : R →+* MvPolynomial σ R) = RingHom.id R := by\n  ext x\n  exact constantCoeff_C σ x\n\n"}
{"name":"MvPolynomial.constantCoeff_comp_algebraMap","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.constantCoeff.comp (algebraMap R (MvPolynomial σ R))) (RingHom.id R)","decl":"theorem constantCoeff_comp_algebraMap :\n    constantCoeff.comp (algebraMap R (MvPolynomial σ R)) = RingHom.id R :=\n  constantCoeff_comp_C _ _\n\n"}
{"name":"MvPolynomial.support_sum_monomial_coeff","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\n⊢ Eq (p.support.sum fun v => (MvPolynomial.monomial v) (MvPolynomial.coeff v p)) p","decl":"@[simp]\ntheorem support_sum_monomial_coeff (p : MvPolynomial σ R) :\n    (∑ v ∈ p.support, monomial v (coeff v p)) = p :=\n  Finsupp.sum_single p\n\n"}
{"name":"MvPolynomial.as_sum","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\n⊢ Eq p (p.support.sum fun v => (MvPolynomial.monomial v) (MvPolynomial.coeff v p))","decl":"theorem as_sum (p : MvPolynomial σ R) : p = ∑ v ∈ p.support, monomial v (coeff v p) :=\n  (support_sum_monomial_coeff p).symm\n\n"}
{"name":"MvPolynomial.coe_coeffsIn","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u_2\nS : Type u_3\nσ : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Module R S\nM : Submodule R S\n⊢ Eq (↑(MvPolynomial.coeffsIn σ M)) (setOf fun p => ∀ (i : Finsupp σ Nat), Membership.mem M (MvPolynomial.coeff i p))","decl":"variable (σ M) in\n/-- The `R`-submodule of multivariate polynomials whose coefficients lie in a `R`-submodule `M`. -/\n@[simps]\ndef coeffsIn : Submodule R (MvPolynomial σ S) where\n  carrier := {p | ∀ i, p.coeff i ∈ M}\n  add_mem' := by simp+contextual [add_mem]\n  zero_mem' := by simp\n  smul_mem' := by simp+contextual [Submodule.smul_mem]\n\n"}
{"name":"MvPolynomial.mem_coeffsIn","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u_2\nS : Type u_3\nσ : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Module R S\nM : Submodule R S\np : MvPolynomial σ S\n⊢ Iff (Membership.mem (MvPolynomial.coeffsIn σ M) p) (∀ (i : Finsupp σ Nat), Membership.mem M (MvPolynomial.coeff i p))","decl":"lemma mem_coeffsIn : p ∈ coeffsIn σ M ↔ ∀ i, p.coeff i ∈ M := .rfl\n\n"}
{"name":"MvPolynomial.monomial_mem_coeffsIn","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u_2\nS : Type u_3\nσ : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Module R S\nM : Submodule R S\ni : Finsupp σ Nat\nx : S\n⊢ Iff (Membership.mem (MvPolynomial.coeffsIn σ M) ((MvPolynomial.monomial i) x)) (Membership.mem M x)","decl":"@[simp]\nlemma monomial_mem_coeffsIn : monomial i x ∈ coeffsIn σ M ↔ x ∈ M := by\n  classical\n  simp only [mem_coeffsIn, coeff_monomial]\n  exact ⟨fun h ↦ by simpa using h i, fun hs j ↦ by split <;> simp [hs]⟩\n\n"}
{"name":"MvPolynomial.C_mem_coeffsIn","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u_2\nS : Type u_3\nσ : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Module R S\nM : Submodule R S\nx : S\n⊢ Iff (Membership.mem (MvPolynomial.coeffsIn σ M) (MvPolynomial.C x)) (Membership.mem M x)","decl":"@[simp]\nlemma C_mem_coeffsIn : C x ∈ coeffsIn σ M ↔ x ∈ M := by simpa using monomial_mem_coeffsIn (i := 0)\n\n"}
{"name":"MvPolynomial.one_coeffsIn","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u_2\nS : Type u_3\nσ : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Module R S\nM : Submodule R S\n⊢ Iff (Membership.mem (MvPolynomial.coeffsIn σ M) 1) (Membership.mem M 1)","decl":"@[simp]\nlemma one_coeffsIn : 1 ∈ coeffsIn σ M ↔ 1 ∈ M := by simpa using C_mem_coeffsIn (x := (1 : S))\n\n"}
{"name":"MvPolynomial.mul_monomial_mem_coeffsIn","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u_2\nS : Type u_3\nσ : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Module R S\nM : Submodule R S\np : MvPolynomial σ S\ni : Finsupp σ Nat\n⊢ Iff (Membership.mem (MvPolynomial.coeffsIn σ M) (HMul.hMul p ((MvPolynomial.monomial i) 1))) (Membership.mem (MvPolynomial.coeffsIn σ M) p)","decl":"@[simp]\nlemma mul_monomial_mem_coeffsIn : p * monomial i 1 ∈ coeffsIn σ M ↔ p ∈ coeffsIn σ M := by\n  classical\n  simp only [mem_coeffsIn, coeff_mul_monomial', Finsupp.mem_support_iff]\n  constructor\n  · rintro hp j\n    simpa using hp (j + i)\n  · rintro hp i\n    split <;> simp [hp]\n\n"}
{"name":"MvPolynomial.monomial_mul_mem_coeffsIn","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u_2\nS : Type u_3\nσ : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Module R S\nM : Submodule R S\np : MvPolynomial σ S\ni : Finsupp σ Nat\n⊢ Iff (Membership.mem (MvPolynomial.coeffsIn σ M) (HMul.hMul ((MvPolynomial.monomial i) 1) p)) (Membership.mem (MvPolynomial.coeffsIn σ M) p)","decl":"@[simp]\nlemma monomial_mul_mem_coeffsIn : monomial i 1 * p ∈ coeffsIn σ M ↔ p ∈ coeffsIn σ M := by\n  simp [mul_comm]\n\n"}
{"name":"MvPolynomial.mul_X_mem_coeffsIn","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u_2\nS : Type u_3\nσ : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Module R S\nM : Submodule R S\np : MvPolynomial σ S\ns : σ\n⊢ Iff (Membership.mem (MvPolynomial.coeffsIn σ M) (HMul.hMul p (MvPolynomial.X s))) (Membership.mem (MvPolynomial.coeffsIn σ M) p)","decl":"@[simp]\nlemma mul_X_mem_coeffsIn : p * X s ∈ coeffsIn σ M ↔ p ∈ coeffsIn σ M := by\n  simpa [-mul_monomial_mem_coeffsIn] using mul_monomial_mem_coeffsIn (i := .single s 1)\n\n"}
{"name":"MvPolynomial.X_mul_mem_coeffsIn","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u_2\nS : Type u_3\nσ : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Module R S\nM : Submodule R S\np : MvPolynomial σ S\ns : σ\n⊢ Iff (Membership.mem (MvPolynomial.coeffsIn σ M) (HMul.hMul (MvPolynomial.X s) p)) (Membership.mem (MvPolynomial.coeffsIn σ M) p)","decl":"@[simp]\nlemma X_mul_mem_coeffsIn : X s * p ∈ coeffsIn σ M ↔ p ∈ coeffsIn σ M := by simp [mul_comm]\n\n"}
{"name":"MvPolynomial.coeffsIn_eq_span_monomial","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u_2\nS : Type u_3\nσ : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Module R S\nM : Submodule R S\n⊢ Eq (MvPolynomial.coeffsIn σ M) (Submodule.span R (setOf fun x => Exists fun m => And (Membership.mem M m) (Exists fun i => Eq ((MvPolynomial.monomial i) m) x)))","decl":"variable (M) in\nlemma coeffsIn_eq_span_monomial : coeffsIn σ M = .span R {monomial i m | (m ∈ M) (i : σ →₀ ℕ)} := by\n  classical\n  refine le_antisymm ?_ <| Submodule.span_le.2 ?_\n  · rintro p hp\n    rw [p.as_sum]\n    exact sum_mem fun i hi ↦ Submodule.subset_span ⟨_, hp i, _, rfl⟩\n  · rintro _ ⟨m, hm, s, n, rfl⟩ i\n    simp [coeff_X_pow]\n    split <;> simp [hm]\n\n"}
{"name":"MvPolynomial.coeffsIn_le","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u_2\nS : Type u_3\nσ : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Module R S\nM : Submodule R S\nN : Submodule R (MvPolynomial σ S)\n⊢ Iff (LE.le (MvPolynomial.coeffsIn σ M) N) (∀ (m : S), Membership.mem M m → ∀ (i : Finsupp σ Nat), Membership.mem N ((MvPolynomial.monomial i) m))","decl":"lemma coeffsIn_le {N : Submodule R (MvPolynomial σ S)} :\n    coeffsIn σ M ≤ N ↔ ∀ m ∈ M, ∀ i, monomial i m ∈ N := by\n  simp [coeffsIn_eq_span_monomial, Submodule.span_le, Set.subset_def,\n    forall_swap (α := MvPolynomial σ S)]\n\n"}
{"name":"MvPolynomial.coeffsIn_mul","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u_2\nS : Type u_3\nσ : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nM N : Submodule R S\n⊢ Eq (MvPolynomial.coeffsIn σ (HMul.hMul M N)) (HMul.hMul (MvPolynomial.coeffsIn σ M) (MvPolynomial.coeffsIn σ N))","decl":"lemma coeffsIn_mul (M N : Submodule R S) : coeffsIn σ (M * N) = coeffsIn σ M * coeffsIn σ N := by\n  classical\n  refine le_antisymm (coeffsIn_le.2 ?_) ?_\n  · intros r hr s\n    induction hr using Submodule.mul_induction_on' with\n    | mem_mul_mem m hm n hn =>\n      rw [← add_zero s, ← monomial_mul]\n      apply Submodule.mul_mem_mul <;> simpa\n    | add x _ y _ hx hy =>\n      simpa [map_add] using add_mem hx hy\n  · rw [Submodule.mul_le]\n    intros x hx y hy k\n    rw [MvPolynomial.coeff_mul]\n    exact sum_mem fun c hc ↦ Submodule.mul_mem_mul (hx _) (hy _)\n\n"}
{"name":"MvPolynomial.coeffsIn_pow","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u_2\nS : Type u_3\nσ : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nn : Nat\na✝ : Ne n 0\nM : Submodule R S\n⊢ Eq (MvPolynomial.coeffsIn σ (HPow.hPow M n)) (HPow.hPow (MvPolynomial.coeffsIn σ M) n)","decl":"lemma coeffsIn_pow : ∀ {n}, n ≠ 0 → ∀ M : Submodule R S, coeffsIn σ (M ^ n) = coeffsIn σ M ^ n\n  | 1, _, M => by simp\n  | n + 2, _, M => by rw [pow_succ, coeffsIn_mul, coeffsIn_pow, ← pow_succ]; exact n.succ_ne_zero\n\n"}
{"name":"MvPolynomial.le_coeffsIn_pow","module":"Mathlib.Algebra.MvPolynomial.Basic","initialProofState":"R : Type u_2\nS : Type u_3\nσ : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nM : Submodule R S\nn : Nat\n⊢ LE.le (HPow.hPow (MvPolynomial.coeffsIn σ M) n) (MvPolynomial.coeffsIn σ (HPow.hPow M n))","decl":"lemma le_coeffsIn_pow : ∀ {n}, coeffsIn σ M ^ n ≤ coeffsIn σ (M ^ n)\n  | 0 => by simpa using ⟨1, map_one _⟩\n  | n + 1 => (coeffsIn_pow n.succ_ne_zero _).ge\n\n"}
