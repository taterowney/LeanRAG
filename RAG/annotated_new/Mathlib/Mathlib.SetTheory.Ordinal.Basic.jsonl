{"name":"WellOrder.mk.injEq","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α✝ : Type u\nr✝ : α✝ → α✝ → Prop\nwo✝ : IsWellOrder α✝ r✝\nα : Type u\nr : α → α → Prop\nwo : IsWellOrder α r\n⊢ Eq (Eq { α := α✝, r := r✝, wo := wo✝ } { α := α, r := r, wo := wo }) (And (Eq α✝ α) (HEq r✝ r))","decl":"/-- Bundled structure registering a well order on a type. Ordinals will be defined as a quotient\nof this type. -/\nstructure WellOrder : Type (u + 1) where\n  /-- The underlying type of the order. -/\n  α : Type u\n  /-- The underlying relation of the order. -/\n  r : α → α → Prop\n  /-- The proposition that `r` is a well-ordering for `α`. -/\n  wo : IsWellOrder α r\n\n"}
{"name":"WellOrder.mk.inj","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α✝ : Type u\nr✝ : α✝ → α✝ → Prop\nwo✝ : IsWellOrder α✝ r✝\nα : Type u\nr : α → α → Prop\nwo : IsWellOrder α r\nx✝ : Eq { α := α✝, r := r✝, wo := wo✝ } { α := α, r := r, wo := wo }\n⊢ And (Eq α✝ α) (HEq r✝ r)","decl":"/-- Bundled structure registering a well order on a type. Ordinals will be defined as a quotient\nof this type. -/\nstructure WellOrder : Type (u + 1) where\n  /-- The underlying type of the order. -/\n  α : Type u\n  /-- The underlying relation of the order. -/\n  r : α → α → Prop\n  /-- The proposition that `r` is a well-ordering for `α`. -/\n  wo : IsWellOrder α r\n\n"}
{"name":"WellOrder.mk.sizeOf_spec","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\nwo : IsWellOrder α r\n⊢ Eq (SizeOf.sizeOf { α := α, r := r, wo := wo }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf α)) (SizeOf.sizeOf wo))","decl":"/-- Bundled structure registering a well order on a type. Ordinals will be defined as a quotient\nof this type. -/\nstructure WellOrder : Type (u + 1) where\n  /-- The underlying type of the order. -/\n  α : Type u\n  /-- The underlying relation of the order. -/\n  r : α → α → Prop\n  /-- The proposition that `r` is a well-ordering for `α`. -/\n  wo : IsWellOrder α r\n\n"}
{"name":"WellOrder.wo","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"self : WellOrder\n⊢ IsWellOrder self.α self.r","decl":"/-- Bundled structure registering a well order on a type. Ordinals will be defined as a quotient\nof this type. -/\nstructure WellOrder : Type (u + 1) where\n  /-- The underlying type of the order. -/\n  α : Type u\n  /-- The underlying relation of the order. -/\n  r : α → α → Prop\n  /-- The proposition that `r` is a well-ordering for `α`. -/\n  wo : IsWellOrder α r\n\n"}
{"name":"WellOrder.eta","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : WellOrder\n⊢ Eq { α := o.α, r := o.r, wo := ⋯ } o","decl":"@[deprecated \"No deprecation message was provided.\" (since := \"2024-10-24\")]\ntheorem eta (o : WellOrder) : mk o.α o.r o.wo = o := rfl\n\n"}
{"name":"wellFoundedLT_toType_lt","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ WellFoundedLT o.toType","decl":"instance wellFoundedLT_toType_lt (o : Ordinal) : WellFoundedLT o.toType :=\n  o.out.wo.toIsWellFounded\n\n"}
{"name":"Ordinal.type_def'","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"w : WellOrder\n⊢ Eq (Quotient.mk Ordinal.isEquivalent w) (Ordinal.type w.r)","decl":"@[deprecated \"Avoid using `Quotient.mk` to construct an `Ordinal` directly.\"\n  (since := \"2024-10-24\")]\ntheorem type_def' (w : WellOrder) : ⟦w⟧ = type w.r := rfl\n\n\n"}
{"name":"Ordinal.type_def","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\nwo : IsWellOrder α r\n⊢ Eq (Quotient.mk Ordinal.isEquivalent { α := α, r := r, wo := wo }) (Ordinal.type r)","decl":"@[deprecated \"Avoid using `Quotient.mk` to construct an `Ordinal` directly.\"\n  (since := \"2024-10-24\")]\ntheorem type_def (r) [wo : IsWellOrder α r] : (⟦⟨α, r, wo⟩⟧ : Ordinal) = type r := rfl\n\n"}
{"name":"Ordinal.type_toType","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Ordinal.type fun x1 x2 => LT.lt x1 x2) o","decl":"@[simp]\ntheorem type_toType (o : Ordinal) : typeLT o.toType = o :=\n  o.out_eq\n\n"}
{"name":"Ordinal.type_lt","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Ordinal.type fun x1 x2 => LT.lt x1 x2) o","decl":"@[deprecated type_toType (since := \"2024-10-22\")]\ntheorem type_lt (o : Ordinal) : typeLT o.toType = o :=\n  o.out_eq\n\n"}
{"name":"Ordinal.type_out","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Ordinal.type (Quotient.out o).r) o","decl":"@[deprecated type_toType (since := \"2024-08-26\")]\ntheorem type_out (o : Ordinal) : Ordinal.type o.out.r = o :=\n  type_toType o\n\n"}
{"name":"Ordinal.type_eq","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α β : Type u_1\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : IsWellOrder β s\n⊢ Iff (Eq (Ordinal.type r) (Ordinal.type s)) (Nonempty (RelIso r s))","decl":"theorem type_eq {α β} {r : α → α → Prop} {s : β → β → Prop} [IsWellOrder α r] [IsWellOrder β s] :\n    type r = type s ↔ Nonempty (r ≃r s) :=\n  Quotient.eq'\n\n"}
{"name":"RelIso.ordinal_type_eq","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α β : Type u_1\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : IsWellOrder β s\nh : RelIso r s\n⊢ Eq (Ordinal.type r) (Ordinal.type s)","decl":"theorem _root_.RelIso.ordinal_type_eq {α β} {r : α → α → Prop} {s : β → β → Prop} [IsWellOrder α r]\n    [IsWellOrder β s] (h : r ≃r s) : type r = type s :=\n  type_eq.2 ⟨h⟩\n\n"}
{"name":"Ordinal.type_eq_zero_of_empty","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : IsEmpty α\n⊢ Eq (Ordinal.type r) 0","decl":"theorem type_eq_zero_of_empty (r) [IsWellOrder α r] [IsEmpty α] : type r = 0 :=\n  (RelIso.relIsoOfIsEmpty r _).ordinal_type_eq\n\n"}
{"name":"Ordinal.type_eq_zero_iff_isEmpty","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\n⊢ Iff (Eq (Ordinal.type r) 0) (IsEmpty α)","decl":"@[simp]\ntheorem type_eq_zero_iff_isEmpty [IsWellOrder α r] : type r = 0 ↔ IsEmpty α :=\n  ⟨fun h =>\n    let ⟨s⟩ := type_eq.1 h\n    s.toEquiv.isEmpty,\n    @type_eq_zero_of_empty α r _⟩\n\n"}
{"name":"Ordinal.type_ne_zero_iff_nonempty","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\n⊢ Iff (Ne (Ordinal.type r) 0) (Nonempty α)","decl":"theorem type_ne_zero_iff_nonempty [IsWellOrder α r] : type r ≠ 0 ↔ Nonempty α := by simp\n\n"}
{"name":"Ordinal.type_ne_zero_of_nonempty","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\nh : Nonempty α\n⊢ Ne (Ordinal.type r) 0","decl":"theorem type_ne_zero_of_nonempty (r) [IsWellOrder α r] [h : Nonempty α] : type r ≠ 0 :=\n  type_ne_zero_iff_nonempty.2 h\n\n"}
{"name":"Ordinal.type_pEmpty","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq (Ordinal.type EmptyRelation) 0","decl":"theorem type_pEmpty : type (@EmptyRelation PEmpty) = 0 :=\n  rfl\n\n"}
{"name":"Ordinal.type_empty","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq (Ordinal.type EmptyRelation) 0","decl":"theorem type_empty : type (@EmptyRelation Empty) = 0 :=\n  type_eq_zero_of_empty _\n\n"}
{"name":"Ordinal.type_eq_one_of_unique","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝² : IsWellOrder α r\ninst✝¹ : Nonempty α\ninst✝ : Subsingleton α\n⊢ Eq (Ordinal.type r) 1","decl":"theorem type_eq_one_of_unique (r) [IsWellOrder α r] [Nonempty α] [Subsingleton α] : type r = 1 := by\n  cases nonempty_unique α\n  exact (RelIso.ofUniqueOfIrrefl r _).ordinal_type_eq\n\n"}
{"name":"Ordinal.type_eq_one_iff_unique","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\n⊢ Iff (Eq (Ordinal.type r) 1) (Nonempty (Unique α))","decl":"@[simp]\ntheorem type_eq_one_iff_unique [IsWellOrder α r] : type r = 1 ↔ Nonempty (Unique α) :=\n  ⟨fun h ↦ let ⟨s⟩ := type_eq.1 h; ⟨s.toEquiv.unique⟩,\n    fun ⟨_⟩ ↦ type_eq_one_of_unique r⟩\n\n"}
{"name":"Ordinal.type_pUnit","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq (Ordinal.type EmptyRelation) 1","decl":"theorem type_pUnit : type (@EmptyRelation PUnit) = 1 :=\n  rfl\n\n"}
{"name":"Ordinal.type_unit","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq (Ordinal.type EmptyRelation) 1","decl":"theorem type_unit : type (@EmptyRelation Unit) = 1 :=\n  rfl\n\n"}
{"name":"Ordinal.toType_empty_iff_eq_zero","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (IsEmpty o.toType) (Eq o 0)","decl":"@[simp]\ntheorem toType_empty_iff_eq_zero {o : Ordinal} : IsEmpty o.toType ↔ o = 0 := by\n  rw [← @type_eq_zero_iff_isEmpty o.toType (· < ·), type_toType]\n\n"}
{"name":"Ordinal.out_empty_iff_eq_zero","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (IsEmpty o.toType) (Eq o 0)","decl":"@[deprecated toType_empty_iff_eq_zero (since := \"2024-08-26\")]\nalias out_empty_iff_eq_zero := toType_empty_iff_eq_zero\n\n"}
{"name":"Ordinal.eq_zero_of_out_empty","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\nh : IsEmpty o.toType\n⊢ Eq o 0","decl":"@[deprecated toType_empty_iff_eq_zero (since := \"2024-08-26\")]\ntheorem eq_zero_of_out_empty (o : Ordinal) [h : IsEmpty o.toType] : o = 0 :=\n  toType_empty_iff_eq_zero.1 h\n\n"}
{"name":"Ordinal.isEmpty_toType_zero","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ IsEmpty (Ordinal.toType 0)","decl":"instance isEmpty_toType_zero : IsEmpty (toType 0) :=\n  toType_empty_iff_eq_zero.2 rfl\n\n"}
{"name":"Ordinal.toType_nonempty_iff_ne_zero","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (Nonempty o.toType) (Ne o 0)","decl":"@[simp]\ntheorem toType_nonempty_iff_ne_zero {o : Ordinal} : Nonempty o.toType ↔ o ≠ 0 := by\n  rw [← @type_ne_zero_iff_nonempty o.toType (· < ·), type_toType]\n\n"}
{"name":"Ordinal.out_nonempty_iff_ne_zero","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (Nonempty o.toType) (Ne o 0)","decl":"@[deprecated toType_nonempty_iff_ne_zero (since := \"2024-08-26\")]\nalias out_nonempty_iff_ne_zero := toType_nonempty_iff_ne_zero\n\n"}
{"name":"Ordinal.ne_zero_of_out_nonempty","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\nh : Nonempty o.toType\n⊢ Ne o 0","decl":"@[deprecated toType_nonempty_iff_ne_zero (since := \"2024-08-26\")]\ntheorem ne_zero_of_out_nonempty (o : Ordinal) [h : Nonempty o.toType] : o ≠ 0 :=\n  toType_nonempty_iff_ne_zero.1 h\n\n"}
{"name":"Ordinal.one_ne_zero","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Ne 1 0","decl":"protected theorem one_ne_zero : (1 : Ordinal) ≠ 0 :=\n  type_ne_zero_of_nonempty _\n\n"}
{"name":"Ordinal.nontrivial","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Nontrivial Ordinal.{u}","decl":"instance nontrivial : Nontrivial Ordinal.{u} :=\n  ⟨⟨1, 0, Ordinal.one_ne_zero⟩⟩\n\n"}
{"name":"Ordinal.inductionOn","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"C : Ordinal.{u_1} → Prop\no : Ordinal.{u_1}\nH : ∀ (α : Type u_1) (r : α → α → Prop) [inst : IsWellOrder α r], C (Ordinal.type r)\n⊢ C o","decl":"/-- `Quotient.inductionOn` specialized to ordinals.\n\nNot to be confused with well-founded recursion `Ordinal.induction`. -/\n@[elab_as_elim]\ntheorem inductionOn {C : Ordinal → Prop} (o : Ordinal)\n    (H : ∀ (α r) [IsWellOrder α r], C (type r)) : C o :=\n  Quot.inductionOn o fun ⟨α, r, wo⟩ => @H α r wo\n\n"}
{"name":"Ordinal.inductionOn₂","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"C : Ordinal.{u_1} → Ordinal.{u_2} → Prop\no₁ : Ordinal.{u_1}\no₂ : Ordinal.{u_2}\nH : ∀ (α : Type u_1) (r : α → α → Prop) [inst : IsWellOrder α r] (β : Type u_2) (s : β → β → Prop) [inst_1 : IsWellOrder β s], C (Ordinal.type r) (Ordinal.type s)\n⊢ C o₁ o₂","decl":"/-- `Quotient.inductionOn₂` specialized to ordinals.\n\nNot to be confused with well-founded recursion `Ordinal.induction`. -/\n@[elab_as_elim]\ntheorem inductionOn₂ {C : Ordinal → Ordinal → Prop} (o₁ o₂ : Ordinal)\n    (H : ∀ (α r) [IsWellOrder α r] (β s) [IsWellOrder β s], C (type r) (type s)) : C o₁ o₂ :=\n  Quotient.inductionOn₂ o₁ o₂ fun ⟨α, r, wo₁⟩ ⟨β, s, wo₂⟩ => @H α r wo₁ β s wo₂\n\n"}
{"name":"Ordinal.inductionOn₃","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"C : Ordinal.{u_1} → Ordinal.{u_2} → Ordinal.{u_3} → Prop\no₁ : Ordinal.{u_1}\no₂ : Ordinal.{u_2}\no₃ : Ordinal.{u_3}\nH : ∀ (α : Type u_1) (r : α → α → Prop) [inst : IsWellOrder α r] (β : Type u_2) (s : β → β → Prop) [inst_1 : IsWellOrder β s] (γ : Type u_3) (t : γ → γ → Prop) [inst_2 : IsWellOrder γ t], C (Ordinal.type r) (Ordinal.type s) (Ordinal.type t)\n⊢ C o₁ o₂ o₃","decl":"/-- `Quotient.inductionOn₃` specialized to ordinals.\n\nNot to be confused with well-founded recursion `Ordinal.induction`. -/\n@[elab_as_elim]\ntheorem inductionOn₃ {C : Ordinal → Ordinal → Ordinal → Prop} (o₁ o₂ o₃ : Ordinal)\n    (H : ∀ (α r) [IsWellOrder α r] (β s) [IsWellOrder β s] (γ t) [IsWellOrder γ t],\n      C (type r) (type s) (type t)) : C o₁ o₂ o₃ :=\n  Quotient.inductionOn₃ o₁ o₂ o₃ fun ⟨α, r, wo₁⟩ ⟨β, s, wo₂⟩ ⟨γ, t, wo₃⟩ =>\n    @H α r wo₁ β s wo₂ γ t wo₃\n\n"}
{"name":"Ordinal.inductionOnWellOrder","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"C : Ordinal.{u_1} → Prop\no : Ordinal.{u_1}\nH : ∀ (α : Type u_1) [inst : LinearOrder α] [inst_1 : WellFoundedLT α], C (Ordinal.type fun x1 x2 => LT.lt x1 x2)\n⊢ C o","decl":"open Classical in\n/-- To prove a result on ordinals, it suffices to prove it for order types of well-orders. -/\n@[elab_as_elim]\ntheorem inductionOnWellOrder {C : Ordinal → Prop} (o : Ordinal)\n    (H : ∀ (α) [LinearOrder α] [WellFoundedLT α], C (typeLT α)) : C o :=\n  inductionOn o fun α r wo ↦ @H α (linearOrderOfSTO r) wo.toIsWellFounded\n\n"}
{"name":"Ordinal.liftOnWellOrder_type","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"δ : Sort v\nf : (α : Type u_1) → [inst : LinearOrder α] → [inst : WellFoundedLT α] → δ\nc : ∀ (α : Type u_1) [inst : LinearOrder α] [inst_1 : WellFoundedLT α] (β : Type u_1) [inst_2 : LinearOrder β] [inst_3 : WellFoundedLT β], Eq (Ordinal.type fun x1 x2 => LT.lt x1 x2) (Ordinal.type fun x1 x2 => LT.lt x1 x2) → Eq (f α) (f β)\nγ : Type u_1\ninst✝¹ : LinearOrder γ\ninst✝ : WellFoundedLT γ\n⊢ Eq ((Ordinal.type fun x1 x2 => LT.lt x1 x2).liftOnWellOrder f c) (f γ)","decl":"@[simp]\ntheorem liftOnWellOrder_type {δ : Sort v} (f : ∀ (α) [LinearOrder α] [WellFoundedLT α], δ)\n    (c : ∀ (α) [LinearOrder α] [WellFoundedLT α] (β) [LinearOrder β] [WellFoundedLT β],\n      typeLT α = typeLT β → f α = f β) {γ} [LinearOrder γ] [WellFoundedLT γ] :\n    liftOnWellOrder (typeLT γ) f c = f γ := by\n  change Quotient.liftOn' ⟦_⟧ _ _ = _\n  rw [Quotient.liftOn'_mk]\n  congr\n  exact LinearOrder.ext_lt fun _ _ ↦ Iff.rfl\n\n"}
{"name":"InitialSeg.ordinal_type_le","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α β : Type u_1\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : IsWellOrder β s\nh : InitialSeg r s\n⊢ LE.le (Ordinal.type r) (Ordinal.type s)","decl":"theorem _root_.InitialSeg.ordinal_type_le {α β} {r : α → α → Prop} {s : β → β → Prop}\n    [IsWellOrder α r] [IsWellOrder β s] (h : r ≼i s) : type r ≤ type s :=\n  ⟨h⟩\n\n"}
{"name":"RelEmbedding.ordinal_type_le","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α β : Type u_1\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : IsWellOrder β s\nh : RelEmbedding r s\n⊢ LE.le (Ordinal.type r) (Ordinal.type s)","decl":"theorem _root_.RelEmbedding.ordinal_type_le {α β} {r : α → α → Prop} {s : β → β → Prop}\n    [IsWellOrder α r] [IsWellOrder β s] (h : r ↪r s) : type r ≤ type s :=\n  ⟨h.collapse⟩\n\n"}
{"name":"PrincipalSeg.ordinal_type_lt","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α β : Type u_1\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : IsWellOrder β s\nh : PrincipalSeg r s\n⊢ LT.lt (Ordinal.type r) (Ordinal.type s)","decl":"theorem _root_.PrincipalSeg.ordinal_type_lt {α β} {r : α → α → Prop} {s : β → β → Prop}\n    [IsWellOrder α r] [IsWellOrder β s] (h : r ≺i s) : type r < type s :=\n  ⟨h⟩\n\n"}
{"name":"Ordinal.zero_le","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ LE.le 0 o","decl":"@[simp]\nprotected theorem zero_le (o : Ordinal) : 0 ≤ o :=\n  inductionOn o fun _ r _ => (InitialSeg.ofIsEmpty _ r).ordinal_type_le\n\n"}
{"name":"Ordinal.bot_eq_zero","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq Bot.bot 0","decl":"@[simp]\ntheorem bot_eq_zero : (⊥ : Ordinal) = 0 :=\n  rfl\n\n"}
{"name":"Ordinal.instIsEmptyIioZero","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ IsEmpty ↑(Set.Iio 0)","decl":"instance instIsEmptyIioZero : IsEmpty (Iio (0 : Ordinal)) := by\n  simp [← bot_eq_zero]\n\n"}
{"name":"Ordinal.le_zero","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (LE.le o 0) (Eq o 0)","decl":"@[simp]\nprotected theorem le_zero {o : Ordinal} : o ≤ 0 ↔ o = 0 :=\n  le_bot_iff\n\n"}
{"name":"Ordinal.pos_iff_ne_zero","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (LT.lt 0 o) (Ne o 0)","decl":"protected theorem pos_iff_ne_zero {o : Ordinal} : 0 < o ↔ o ≠ 0 :=\n  bot_lt_iff_ne_bot\n\n"}
{"name":"Ordinal.not_lt_zero","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Not (LT.lt o 0)","decl":"protected theorem not_lt_zero (o : Ordinal) : ¬o < 0 :=\n  not_lt_bot\n\n"}
{"name":"Ordinal.eq_zero_or_pos","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a : Ordinal.{u_1}\n⊢ Or (Eq a 0) (LT.lt 0 a)","decl":"theorem eq_zero_or_pos : ∀ a : Ordinal, a = 0 ∨ 0 < a :=\n  eq_bot_or_bot_lt\n\n"}
{"name":"Ordinal.instZeroLEOneClass","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ ZeroLEOneClass Ordinal.{u_1}","decl":"instance : ZeroLEOneClass Ordinal :=\n  ⟨Ordinal.zero_le _⟩\n\n"}
{"name":"Ordinal.instNeZeroOne","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ NeZero 1","decl":"instance instNeZeroOne : NeZero (1 : Ordinal) :=\n  ⟨Ordinal.one_ne_zero⟩\n\n"}
{"name":"Ordinal.type_le_iff","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α β : Type u_1\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : IsWellOrder β s\n⊢ Iff (LE.le (Ordinal.type r) (Ordinal.type s)) (Nonempty (InitialSeg r s))","decl":"theorem type_le_iff {α β} {r : α → α → Prop} {s : β → β → Prop} [IsWellOrder α r]\n    [IsWellOrder β s] : type r ≤ type s ↔ Nonempty (r ≼i s) :=\n  Iff.rfl\n\n"}
{"name":"Ordinal.type_le_iff'","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α β : Type u_1\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : IsWellOrder β s\n⊢ Iff (LE.le (Ordinal.type r) (Ordinal.type s)) (Nonempty (RelEmbedding r s))","decl":"theorem type_le_iff' {α β} {r : α → α → Prop} {s : β → β → Prop} [IsWellOrder α r]\n    [IsWellOrder β s] : type r ≤ type s ↔ Nonempty (r ↪r s) :=\n  ⟨fun ⟨f⟩ => ⟨f⟩, fun ⟨f⟩ => ⟨f.collapse⟩⟩\n\n"}
{"name":"Ordinal.type_lt_iff","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α β : Type u_1\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : IsWellOrder β s\n⊢ Iff (LT.lt (Ordinal.type r) (Ordinal.type s)) (Nonempty (PrincipalSeg r s))","decl":"theorem type_lt_iff {α β} {r : α → α → Prop} {s : β → β → Prop} [IsWellOrder α r]\n    [IsWellOrder β s] : type r < type s ↔ Nonempty (r ≺i s) :=\n  Iff.rfl\n\n"}
{"name":"Ordinal.typein.principalSeg_coe","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\n⊢ Eq ⇑(Ordinal.typein.principalSeg r).toRelEmbedding ⇑(Ordinal.typein r).toRelEmbedding","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-09\")]\ntheorem typein.principalSeg_coe (r : α → α → Prop) [IsWellOrder α r] :\n    (typein.principalSeg r : α → Ordinal) = typein r :=\n  rfl\n\n"}
{"name":"Ordinal.type_subrel","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\na : α\n⊢ Eq (Ordinal.type (Subrel r fun x => r x a)) ((Ordinal.typein r).toRelEmbedding a)","decl":"@[simp]\ntheorem type_subrel (r : α → α → Prop) [IsWellOrder α r] (a : α) :\n    type (Subrel r (r · a)) = typein r a :=\n  rfl\n\n"}
{"name":"Ordinal.top_typein","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\n⊢ Eq (Ordinal.typein r).top (Ordinal.type r)","decl":"@[simp]\ntheorem top_typein (r : α → α → Prop) [IsWellOrder α r] : (typein r).top = type r :=\n  rfl\n\n"}
{"name":"Ordinal.typein_lt_type","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\na : α\n⊢ LT.lt ((Ordinal.typein r).toRelEmbedding a) (Ordinal.type r)","decl":"theorem typein_lt_type (r : α → α → Prop) [IsWellOrder α r] (a : α) : typein r a < type r :=\n  (typein r).lt_top a\n\n"}
{"name":"Ordinal.typein_lt_self","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\ni : o.toType\n⊢ LT.lt ((Ordinal.typein fun x1 x2 => LT.lt x1 x2).toRelEmbedding i) o","decl":"theorem typein_lt_self {o : Ordinal} (i : o.toType) : typein (α := o.toType) (· < ·) i < o := by\n  simp_rw [← type_toType o]\n  apply typein_lt_type\n\n"}
{"name":"Ordinal.typein_top","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α β : Type u_1\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : IsWellOrder β s\nf : PrincipalSeg r s\n⊢ Eq ((Ordinal.typein s).toRelEmbedding f.top) (Ordinal.type r)","decl":"@[simp]\ntheorem typein_top {α β} {r : α → α → Prop} {s : β → β → Prop}\n    [IsWellOrder α r] [IsWellOrder β s] (f : r ≺i s) : typein s f.top = type r :=\n  f.subrelIso.ordinal_type_eq\n\n"}
{"name":"Ordinal.typein_lt_typein","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\na b : α\n⊢ Iff (LT.lt ((Ordinal.typein r).toRelEmbedding a) ((Ordinal.typein r).toRelEmbedding b)) (r a b)","decl":"@[simp]\ntheorem typein_lt_typein (r : α → α → Prop) [IsWellOrder α r] {a b : α} :\n    typein r a < typein r b ↔ r a b :=\n  (typein r).map_rel_iff\n\n"}
{"name":"Ordinal.typein_le_typein","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\na b : α\n⊢ Iff (LE.le ((Ordinal.typein r).toRelEmbedding a) ((Ordinal.typein r).toRelEmbedding b)) (Not (r b a))","decl":"@[simp]\ntheorem typein_le_typein (r : α → α → Prop) [IsWellOrder α r] {a b : α} :\n    typein r a ≤ typein r b ↔ ¬r b a := by\n  rw [← not_lt, typein_lt_typein]\n\n"}
{"name":"Ordinal.typein_injective","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\n⊢ Function.Injective ⇑(Ordinal.typein r).toRelEmbedding","decl":"theorem typein_injective (r : α → α → Prop) [IsWellOrder α r] : Injective (typein r) :=\n  (typein r).injective\n\n"}
{"name":"Ordinal.typein_inj","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\na b : α\n⊢ Iff (Eq ((Ordinal.typein r).toRelEmbedding a) ((Ordinal.typein r).toRelEmbedding b)) (Eq a b)","decl":"theorem typein_inj (r : α → α → Prop) [IsWellOrder α r] {a b} : typein r a = typein r b ↔ a = b :=\n  (typein_injective r).eq_iff\n\n"}
{"name":"Ordinal.mem_range_typein_iff","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\no : Ordinal.{u}\n⊢ Iff (Membership.mem (Set.range ⇑(Ordinal.typein r).toRelEmbedding) o) (LT.lt o (Ordinal.type r))","decl":"theorem mem_range_typein_iff (r : α → α → Prop) [IsWellOrder α r] {o} :\n    o ∈ Set.range (typein r) ↔ o < type r :=\n  (typein r).mem_range_iff_rel\n\n"}
{"name":"Ordinal.typein_surj","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\no : Ordinal.{u}\nh : LT.lt o (Ordinal.type r)\n⊢ Membership.mem (Set.range ⇑(Ordinal.typein r).toRelEmbedding) o","decl":"theorem typein_surj (r : α → α → Prop) [IsWellOrder α r] {o} (h : o < type r) :\n    o ∈ Set.range (typein r) :=\n  (typein r).mem_range_of_rel_top h\n\n"}
{"name":"Ordinal.typein_surjOn","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\n⊢ Set.SurjOn (⇑(Ordinal.typein r).toRelEmbedding) Set.univ (Set.Iio (Ordinal.type r))","decl":"theorem typein_surjOn (r : α → α → Prop) [IsWellOrder α r] :\n    Set.SurjOn (typein r) Set.univ (Set.Iio (type r)) :=\n  (typein r).surjOn\n\n"}
{"name":"Ordinal.enum_symm_apply_coe","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\na✝ : α\n⊢ Eq (↑((Ordinal.enum r).symm a✝)) ((Ordinal.typein r).toRelEmbedding a✝)","decl":"/-- A well order `r` is order-isomorphic to the set of ordinals smaller than `type r`.\n`enum r ⟨o, h⟩` is the `o`-th element of `α` ordered by `r`.\n\nThat is, `enum` maps an initial segment of the ordinals, those less than the order type of `r`, to\nthe elements of `α`. -/\n@[simps! symm_apply_coe]\ndef enum (r : α → α → Prop) [IsWellOrder α r] : (· < · : Iio (type r) → Iio (type r) → Prop) ≃r r :=\n  (typein r).subrelIso\n\n"}
{"name":"Ordinal.typein_enum","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\no : Ordinal.{u}\nh : LT.lt o (Ordinal.type r)\n⊢ Eq ((Ordinal.typein r).toRelEmbedding ((Ordinal.enum r) ⟨o, h⟩)) o","decl":"@[simp]\ntheorem typein_enum (r : α → α → Prop) [IsWellOrder α r] {o} (h : o < type r) :\n    typein r (enum r ⟨o, h⟩) = o :=\n  (typein r).apply_subrelIso _\n\n"}
{"name":"Ordinal.enum_type","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α β : Type u_1\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : IsWellOrder β s\nf : PrincipalSeg s r\nh : LT.lt (Ordinal.type s) (Ordinal.type r)\n⊢ Eq ((Ordinal.enum r) ⟨Ordinal.type s, h⟩) f.top","decl":"theorem enum_type {α β} {r : α → α → Prop} {s : β → β → Prop} [IsWellOrder α r] [IsWellOrder β s]\n    (f : s ≺i r) {h : type s < type r} : enum r ⟨type s, h⟩ = f.top :=\n  (typein r).injective <| (typein_enum _ _).trans (typein_top _).symm\n\n"}
{"name":"Ordinal.enum_typein","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\na : α\n⊢ Eq ((Ordinal.enum r) ⟨(Ordinal.typein r).toRelEmbedding a, ⋯⟩) a","decl":"@[simp]\ntheorem enum_typein (r : α → α → Prop) [IsWellOrder α r] (a : α) :\n    enum r ⟨typein r a, typein_lt_type r a⟩ = a :=\n  enum_type (PrincipalSeg.ofElement r a)\n\n"}
{"name":"Ordinal.enum_lt_enum","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\no₁ o₂ : ↑(Set.Iio (Ordinal.type r))\n⊢ Iff (r ((Ordinal.enum r) o₁) ((Ordinal.enum r) o₂)) (LT.lt o₁ o₂)","decl":"theorem enum_lt_enum {r : α → α → Prop} [IsWellOrder α r] {o₁ o₂ : Iio (type r)} :\n    r (enum r o₁) (enum r o₂) ↔ o₁ < o₂ :=\n  (enum _).map_rel_iff\n\n"}
{"name":"Ordinal.enum_le_enum","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\no₁ o₂ : ↑(Set.Iio (Ordinal.type r))\n⊢ Iff (Not (r ((Ordinal.enum r) o₁) ((Ordinal.enum r) o₂))) (LE.le o₂ o₁)","decl":"theorem enum_le_enum (r : α → α → Prop) [IsWellOrder α r] {o₁ o₂ : Iio (type r)} :\n    ¬r (enum r o₁) (enum r o₂) ↔ o₂ ≤ o₁ := by\n  rw [enum_lt_enum (r := r), not_lt]\n\n-- TODO: generalize to other well-orders\n"}
{"name":"Ordinal.enum_le_enum'","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a : Ordinal.{u_1}\no₁ o₂ : ↑(Set.Iio (Ordinal.type fun x1 x2 => LT.lt x1 x2))\n⊢ Iff (LE.le ((Ordinal.enum fun x1 x2 => LT.lt x1 x2) o₁) ((Ordinal.enum fun x1 x2 => LT.lt x1 x2) o₂)) (LE.le o₁ o₂)","decl":"@[simp]\ntheorem enum_le_enum' (a : Ordinal) {o₁ o₂ : Iio (type (· < ·))} :\n    enum (· < ·) o₁ ≤ enum (α := a.toType) (· < ·) o₂ ↔ o₁ ≤ o₂ := by\n  rw [← enum_le_enum, not_lt]\n\n"}
{"name":"Ordinal.enum_inj","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\no₁ o₂ : ↑(Set.Iio (Ordinal.type r))\n⊢ Iff (Eq ((Ordinal.enum r) o₁) ((Ordinal.enum r) o₂)) (Eq o₁ o₂)","decl":"theorem enum_inj {r : α → α → Prop} [IsWellOrder α r] {o₁ o₂ : Iio (type r)} :\n    enum r o₁ = enum r o₂ ↔ o₁ = o₂ :=\n  EmbeddingLike.apply_eq_iff_eq _\n\n"}
{"name":"Ordinal.enum_zero_le","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\nh0 : LT.lt 0 (Ordinal.type r)\na : α\n⊢ Not (r a ((Ordinal.enum r) ⟨0, h0⟩))","decl":"theorem enum_zero_le {r : α → α → Prop} [IsWellOrder α r] (h0 : 0 < type r) (a : α) :\n    ¬r a (enum r ⟨0, h0⟩) := by\n  rw [← enum_typein r a, enum_le_enum r]\n  apply Ordinal.zero_le\n\n"}
{"name":"Ordinal.enum_zero_le'","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\nh0 : LT.lt 0 o\na : o.toType\n⊢ LE.le ((Ordinal.enum fun x1 x2 => LT.lt x1 x2) ⟨0, ⋯⟩) a","decl":"theorem enum_zero_le' {o : Ordinal} (h0 : 0 < o) (a : o.toType) :\n    enum (α := o.toType) (· < ·) ⟨0, type_toType _ ▸ h0⟩ ≤ a := by\n  rw [← not_lt]\n  apply enum_zero_le\n\n"}
{"name":"Ordinal.relIso_enum'","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α β : Type u\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : IsWellOrder β s\nf : RelIso r s\no : Ordinal.{u}\nhr : LT.lt o (Ordinal.type r)\nhs : LT.lt o (Ordinal.type s)\n⊢ Eq (f ((Ordinal.enum r) ⟨o, hr⟩)) ((Ordinal.enum s) ⟨o, hs⟩)","decl":"theorem relIso_enum' {α β : Type u} {r : α → α → Prop} {s : β → β → Prop} [IsWellOrder α r]\n    [IsWellOrder β s] (f : r ≃r s) (o : Ordinal) :\n    ∀ (hr : o < type r) (hs : o < type s), f (enum r ⟨o, hr⟩) = enum s ⟨o, hs⟩ := by\n  refine inductionOn o ?_; rintro γ t wo ⟨g⟩ ⟨h⟩\n  rw [enum_type g, enum_type (g.transRelIso f)]; rfl\n\n"}
{"name":"Ordinal.relIso_enum","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α β : Type u\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : IsWellOrder β s\nf : RelIso r s\no : Ordinal.{u}\nhr : LT.lt o (Ordinal.type r)\n⊢ Eq (f ((Ordinal.enum r) ⟨o, hr⟩)) ((Ordinal.enum s) ⟨o, ⋯⟩)","decl":"theorem relIso_enum {α β : Type u} {r : α → α → Prop} {s : β → β → Prop} [IsWellOrder α r]\n    [IsWellOrder β s] (f : r ≃r s) (o : Ordinal) (hr : o < type r) :\n    f (enum r ⟨o, hr⟩) = enum s ⟨o, hr.trans_eq (Quotient.sound ⟨f⟩)⟩ :=\n  relIso_enum' _ _ _ _\n\n"}
{"name":"Ordinal.enumIsoToType_apply","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\nx : ↑(Set.Iio o)\n⊢ Eq (o.enumIsoToType x) ((Ordinal.enum fun x1 x2 => LT.lt x1 x2) ⟨↑x, ⋯⟩)","decl":"/-- The order isomorphism between ordinals less than `o` and `o.toType`. -/\n@[simps! (config := .lemmasOnly)]\nnoncomputable def enumIsoToType (o : Ordinal) : Set.Iio o ≃o o.toType where\n  toFun x := enum (α := o.toType) (· < ·) ⟨x.1, type_toType _ ▸ x.2⟩\n  invFun x := ⟨typein (α := o.toType) (· < ·) x, typein_lt_self x⟩\n  left_inv _ := Subtype.ext_val (typein_enum _ _)\n  right_inv _ := enum_typein _ _\n  map_rel_iff' := enum_le_enum' _\n\n"}
{"name":"Ordinal.enumIsoToType_symm_apply_coe","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\nx : o.toType\n⊢ Eq (↑((RelIso.symm o.enumIsoToType) x)) ((Ordinal.typein fun x1 x2 => LT.lt x1 x2).toRelEmbedding x)","decl":"/-- The order isomorphism between ordinals less than `o` and `o.toType`. -/\n@[simps! (config := .lemmasOnly)]\nnoncomputable def enumIsoToType (o : Ordinal) : Set.Iio o ≃o o.toType where\n  toFun x := enum (α := o.toType) (· < ·) ⟨x.1, type_toType _ ▸ x.2⟩\n  invFun x := ⟨typein (α := o.toType) (· < ·) x, typein_lt_self x⟩\n  left_inv _ := Subtype.ext_val (typein_enum _ _)\n  right_inv _ := enum_typein _ _\n  map_rel_iff' := enum_le_enum' _\n\n"}
{"name":"Ordinal.small_Iio","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u}\n⊢ Small.{u, u + 1} ↑(Set.Iio o)","decl":"instance small_Iio (o : Ordinal.{u}) : Small.{u} (Iio o) :=\n  ⟨_, ⟨(enumIsoToType _).toEquiv⟩⟩\n\n"}
{"name":"Ordinal.small_Iic","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u}\n⊢ Small.{u, u + 1} ↑(Set.Iic o)","decl":"instance small_Iic (o : Ordinal.{u}) : Small.{u} (Iic o) := by\n  rw [← Iio_union_right]\n  infer_instance\n\n"}
{"name":"Ordinal.small_Ico","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a b : Ordinal.{u}\n⊢ Small.{u, u + 1} ↑(Set.Ico a b)","decl":"instance small_Ico (a b : Ordinal.{u}) : Small.{u} (Ico a b) := small_subset Ico_subset_Iio_self\n"}
{"name":"Ordinal.small_Icc","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a b : Ordinal.{u}\n⊢ Small.{u, u + 1} ↑(Set.Icc a b)","decl":"instance small_Icc (a b : Ordinal.{u}) : Small.{u} (Icc a b) := small_subset Icc_subset_Iic_self\n"}
{"name":"Ordinal.small_Ioo","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a b : Ordinal.{u}\n⊢ Small.{u, u + 1} ↑(Set.Ioo a b)","decl":"instance small_Ioo (a b : Ordinal.{u}) : Small.{u} (Ioo a b) := small_subset Ioo_subset_Iio_self\n"}
{"name":"Ordinal.small_Ioc","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a b : Ordinal.{u}\n⊢ Small.{u, u + 1} ↑(Set.Ioc a b)","decl":"instance small_Ioc (a b : Ordinal.{u}) : Small.{u} (Ioc a b) := small_subset Ioc_subset_Iic_self\n\n"}
{"name":"Ordinal.enum_zero_eq_bot","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\nho : LT.lt 0 o\n⊢ Eq ((Ordinal.enum fun x1 x2 => LT.lt x1 x2) ⟨0, ⋯⟩) (letFun (Ordinal.toTypeOrderBotOfPos ho) fun H => Bot.bot)","decl":"theorem enum_zero_eq_bot {o : Ordinal} (ho : 0 < o) :\n    enum (α := o.toType) (· < ·) ⟨0, by rwa [type_toType]⟩ =\n      have H := toTypeOrderBotOfPos ho\n      (⊥ : o.toType) :=\n  rfl\n\n"}
{"name":"Ordinal.lt_wf","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ WellFounded fun x1 x2 => LT.lt x1 x2","decl":"theorem lt_wf : @WellFounded Ordinal (· < ·) :=\n  wellFounded_iff_wellFounded_subrel.mpr (·.induction_on fun ⟨_, _, wo⟩ ↦\n    RelHomClass.wellFounded (enum _) wo.wf)\n\n"}
{"name":"Ordinal.wellFoundedLT","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ WellFoundedLT Ordinal.{u_1}","decl":"instance wellFoundedLT : WellFoundedLT Ordinal :=\n  ⟨lt_wf⟩\n\n"}
{"name":"Ordinal.induction","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"p : Ordinal.{u} → Prop\ni : Ordinal.{u}\nh : ∀ (j : Ordinal.{u}), (∀ (k : Ordinal.{u}), LT.lt k j → p k) → p j\n⊢ p i","decl":"/-- Reformulation of well founded induction on ordinals as a lemma that works with the\n`induction` tactic, as in `induction i using Ordinal.induction with | h i IH => ?_`. -/\ntheorem induction {p : Ordinal.{u} → Prop} (i : Ordinal.{u}) (h : ∀ j, (∀ k, k < j → p k) → p j) :\n    p i :=\n  lt_wf.induction i h\n\n"}
{"name":"Ordinal.typein_apply","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α β : Type u_1\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : IsWellOrder β s\nf : InitialSeg r s\na : α\n⊢ Eq ((Ordinal.typein s).toRelEmbedding (f a)) ((Ordinal.typein r).toRelEmbedding a)","decl":"theorem typein_apply {α β} {r : α → α → Prop} {s : β → β → Prop} [IsWellOrder α r] [IsWellOrder β s]\n    (f : r ≼i s) (a : α) : typein s (f a) = typein r a := by\n  rw [← f.transPrincipal_apply _ a, (f.transPrincipal _).eq]\n\n"}
{"name":"Ordinal.card_type","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\n⊢ Eq (Ordinal.type r).card (Cardinal.mk α)","decl":"@[simp]\ntheorem card_type (r : α → α → Prop) [IsWellOrder α r] : card (type r) = #α :=\n  rfl\n\n"}
{"name":"Ordinal.card_typein","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\nx : α\n⊢ Eq (Cardinal.mk (Subtype fun y => r y x)) ((Ordinal.typein r).toRelEmbedding x).card","decl":"@[simp]\ntheorem card_typein {r : α → α → Prop} [IsWellOrder α r] (x : α) :\n    #{ y // r y x } = (typein r x).card :=\n  rfl\n\n"}
{"name":"Ordinal.card_le_card","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o₁ o₂ : Ordinal.{u_1}\na✝ : LE.le o₁ o₂\n⊢ LE.le o₁.card o₂.card","decl":"theorem card_le_card {o₁ o₂ : Ordinal} : o₁ ≤ o₂ → card o₁ ≤ card o₂ :=\n  inductionOn o₁ fun _ _ _ => inductionOn o₂ fun _ _ _ ⟨⟨⟨f, _⟩, _⟩⟩ => ⟨f⟩\n\n"}
{"name":"Ordinal.card_zero","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq (Ordinal.card 0) 0","decl":"@[simp]\ntheorem card_zero : card 0 = 0 := mk_eq_zero _\n\n"}
{"name":"Ordinal.card_one","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq (Ordinal.card 1) 1","decl":"@[simp]\ntheorem card_one : card 1 = 1 := mk_eq_one _\n\n"}
{"name":"Ordinal.type_uLift","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\n⊢ Eq (Ordinal.type (Order.Preimage ULift.down r)) (Ordinal.lift.{v, u} (Ordinal.type r))","decl":"@[simp]\ntheorem type_uLift (r : α → α → Prop) [IsWellOrder α r] :\n    type (ULift.down ⁻¹'o r) = lift.{v} (type r) :=\n  rfl\n\n"}
{"name":"RelIso.ordinal_lift_type_eq","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nβ : Type v\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : IsWellOrder β s\nf : RelIso r s\n⊢ Eq (Ordinal.lift.{v, u} (Ordinal.type r)) (Ordinal.lift.{u, v} (Ordinal.type s))","decl":"theorem _root_.RelIso.ordinal_lift_type_eq {r : α → α → Prop} {s : β → β → Prop}\n    [IsWellOrder α r] [IsWellOrder β s] (f : r ≃r s) : lift.{v} (type r) = lift.{u} (type s) :=\n  ((RelIso.preimage Equiv.ulift r).trans <|\n      f.trans (RelIso.preimage Equiv.ulift s).symm).ordinal_type_eq\n\n"}
{"name":"Ordinal.type_preimage","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α β : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\nf : Equiv β α\n⊢ Eq (Ordinal.type (Order.Preimage (⇑f) r)) (Ordinal.type r)","decl":"@[simp]\ntheorem type_preimage {α β : Type u} (r : α → α → Prop) [IsWellOrder α r] (f : β ≃ α) :\n    type (f ⁻¹'o r) = type r :=\n  (RelIso.preimage f r).ordinal_type_eq\n\n"}
{"name":"Ordinal.type_lift_preimage","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nβ : Type v\nr : α → α → Prop\ninst✝ : IsWellOrder α r\nf : Equiv β α\n⊢ Eq (Ordinal.lift.{u, v} (Ordinal.type (Order.Preimage (⇑f) r))) (Ordinal.lift.{v, u} (Ordinal.type r))","decl":"@[simp]\ntheorem type_lift_preimage (r : α → α → Prop) [IsWellOrder α r]\n    (f : β ≃ α) : lift.{u} (type (f ⁻¹'o r)) = lift.{v} (type r) :=\n  (RelIso.preimage f r).ordinal_lift_type_eq\n\n"}
{"name":"Ordinal.type_lift_preimage_aux","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nβ : Type v\nr : α → α → Prop\ninst✝ : IsWellOrder α r\nf : Equiv β α\n⊢ Eq (Ordinal.lift.{u, v} (Ordinal.type fun x y => r (f x) (f y))) (Ordinal.lift.{v, u} (Ordinal.type r))","decl":"@[deprecated type_lift_preimage_aux (since := \"2024-10-22\")]\ntheorem type_lift_preimage_aux (r : α → α → Prop) [IsWellOrder α r] (f : β ≃ α) :\n    lift.{u} (@type _ (fun x y => r (f x) (f y))\n      (inferInstanceAs (IsWellOrder β (f ⁻¹'o r)))) = lift.{v} (type r) :=\n  type_lift_preimage r f\n\n"}
{"name":"Ordinal.lift_umax","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq Ordinal.lift.{max u v, u} Ordinal.lift.{v, u}","decl":"/-- `lift.{max u v, u}` equals `lift.{v, u}`.\n\nUnfortunately, the simp lemma doesn't seem to work. -/\ntheorem lift_umax : lift.{max u v, u} = lift.{v, u} :=\n  funext fun a =>\n    inductionOn a fun _ r _ =>\n      Quotient.sound ⟨(RelIso.preimage Equiv.ulift r).trans (RelIso.preimage Equiv.ulift r).symm⟩\n\n"}
{"name":"Ordinal.lift_umax'","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq Ordinal.lift.{max v u, u} Ordinal.lift.{v, u}","decl":"/-- `lift.{max v u, u}` equals `lift.{v, u}`.\n\nUnfortunately, the simp lemma doesn't seem to work. -/\n@[deprecated lift_umax (since := \"2024-10-24\")]\ntheorem lift_umax' : lift.{max v u, u} = lift.{v, u} :=\n  lift_umax\n\n"}
{"name":"Ordinal.lift_id'","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a : Ordinal.{max u_1 u_2}\n⊢ Eq (Ordinal.lift.{u_1, max u_1 u_2} a) a","decl":"/-- An ordinal lifted to a lower or equal universe equals itself.\n\nUnfortunately, the simp lemma doesn't work. -/\ntheorem lift_id' (a : Ordinal) : lift a = a :=\n  inductionOn a fun _ r _ => Quotient.sound ⟨RelIso.preimage Equiv.ulift r⟩\n\n"}
{"name":"Ordinal.lift_id","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a : Ordinal.{u}\n⊢ Eq (Ordinal.lift.{u, u} a) a","decl":"/-- An ordinal lifted to the same universe equals itself. -/\n@[simp]\ntheorem lift_id : ∀ a, lift.{u, u} a = a :=\n  lift_id'.{u, u}\n\n"}
{"name":"Ordinal.lift_uzero","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a : Ordinal.{u}\n⊢ Eq (Ordinal.lift.{0, u} a) a","decl":"/-- An ordinal lifted to the zero universe equals itself. -/\n@[simp]\ntheorem lift_uzero (a : Ordinal.{u}) : lift.{0} a = a :=\n  lift_id' a\n\n"}
{"name":"Ordinal.lift_type_le","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nβ : Type v\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : IsWellOrder β s\n⊢ Iff (LE.le (Ordinal.lift.{max v w, u} (Ordinal.type r)) (Ordinal.lift.{max u w, v} (Ordinal.type s))) (Nonempty (InitialSeg r s))","decl":"theorem lift_type_le {α : Type u} {β : Type v} {r s} [IsWellOrder α r] [IsWellOrder β s] :\n    lift.{max v w} (type r) ≤ lift.{max u w} (type s) ↔ Nonempty (r ≼i s) := by\n  constructor <;> refine fun ⟨f⟩ ↦ ⟨?_⟩\n  · exact (RelIso.preimage Equiv.ulift r).symm.toInitialSeg.trans\n      (f.trans (RelIso.preimage Equiv.ulift s).toInitialSeg)\n  · exact (RelIso.preimage Equiv.ulift r).toInitialSeg.trans\n      (f.trans (RelIso.preimage Equiv.ulift s).symm.toInitialSeg)\n\n"}
{"name":"Ordinal.lift_type_eq","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nβ : Type v\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : IsWellOrder β s\n⊢ Iff (Eq (Ordinal.lift.{max v w, u} (Ordinal.type r)) (Ordinal.lift.{max u w, v} (Ordinal.type s))) (Nonempty (RelIso r s))","decl":"theorem lift_type_eq {α : Type u} {β : Type v} {r s} [IsWellOrder α r] [IsWellOrder β s] :\n    lift.{max v w} (type r) = lift.{max u w} (type s) ↔ Nonempty (r ≃r s) := by\n  refine Quotient.eq'.trans ⟨?_, ?_⟩ <;> refine fun ⟨f⟩ ↦ ⟨?_⟩\n  · exact (RelIso.preimage Equiv.ulift r).symm.trans <| f.trans (RelIso.preimage Equiv.ulift s)\n  · exact (RelIso.preimage Equiv.ulift r).trans <| f.trans (RelIso.preimage Equiv.ulift s).symm\n\n"}
{"name":"Ordinal.lift_type_lt","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nβ : Type v\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : IsWellOrder β s\n⊢ Iff (LT.lt (Ordinal.lift.{max v w, u} (Ordinal.type r)) (Ordinal.lift.{max u w, v} (Ordinal.type s))) (Nonempty (PrincipalSeg r s))","decl":"theorem lift_type_lt {α : Type u} {β : Type v} {r s} [IsWellOrder α r] [IsWellOrder β s] :\n    lift.{max v w} (type r) < lift.{max u w} (type s) ↔ Nonempty (r ≺i s) := by\n  constructor <;> refine fun ⟨f⟩ ↦ ⟨?_⟩\n  · exact (f.relIsoTrans (RelIso.preimage Equiv.ulift r).symm).transInitial\n      (RelIso.preimage Equiv.ulift s).toInitialSeg\n  · exact (f.relIsoTrans (RelIso.preimage Equiv.ulift r)).transInitial\n      (RelIso.preimage Equiv.ulift s).symm.toInitialSeg\n\n"}
{"name":"Ordinal.lift_le","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a b : Ordinal.{v}\n⊢ Iff (LE.le (Ordinal.lift.{u, v} a) (Ordinal.lift.{u, v} b)) (LE.le a b)","decl":"@[simp]\ntheorem lift_le {a b : Ordinal} : lift.{u, v} a ≤ lift.{u, v} b ↔ a ≤ b :=\n  inductionOn₂ a b fun α r _ β s _ => by\n    rw [← lift_umax]\n    exact lift_type_le.{_,_,u}\n\n"}
{"name":"Ordinal.lift_inj","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a b : Ordinal.{v}\n⊢ Iff (Eq (Ordinal.lift.{u, v} a) (Ordinal.lift.{u, v} b)) (Eq a b)","decl":"@[simp]\ntheorem lift_inj {a b : Ordinal} : lift.{u, v} a = lift.{u, v} b ↔ a = b := by\n  simp_rw [le_antisymm_iff, lift_le]\n\n"}
{"name":"Ordinal.lift_lt","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a b : Ordinal.{v}\n⊢ Iff (LT.lt (Ordinal.lift.{u, v} a) (Ordinal.lift.{u, v} b)) (LT.lt a b)","decl":"@[simp]\ntheorem lift_lt {a b : Ordinal} : lift.{u, v} a < lift.{u, v} b ↔ a < b := by\n  simp_rw [lt_iff_le_not_le, lift_le]\n\n"}
{"name":"Ordinal.lift_typein_top","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nβ : Type v\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : IsWellOrder β s\nf : PrincipalSeg r s\n⊢ Eq (Ordinal.lift.{u, v} ((Ordinal.typein s).toRelEmbedding f.top)) (Ordinal.lift.{v, u} (Ordinal.type r))","decl":"@[simp]\ntheorem lift_typein_top {r : α → α → Prop} {s : β → β → Prop}\n    [IsWellOrder α r] [IsWellOrder β s] (f : r ≺i s) : lift.{u} (typein s f.top) = lift (type r) :=\n  f.subrelIso.ordinal_lift_type_eq\n\n"}
{"name":"Ordinal.liftInitialSeg_coe","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq (⇑Ordinal.liftInitialSeg) Ordinal.lift.{v, u}","decl":"@[simp]\ntheorem liftInitialSeg_coe : (liftInitialSeg.{v, u} : Ordinal → Ordinal) = lift.{v, u} :=\n  rfl\n\n"}
{"name":"Ordinal.lift.initialSeg_coe","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq (⇑Ordinal.lift.initialSeg) Ordinal.lift.{v, u}","decl":"set_option linter.deprecated false in\n@[deprecated liftInitialSeg_coe (since := \"2024-09-21\")]\ntheorem lift.initialSeg_coe : (lift.initialSeg.{v, u} : Ordinal → Ordinal) = lift.{v, u} :=\n  rfl\n\n"}
{"name":"Ordinal.lift_lift","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a : Ordinal.{u}\n⊢ Eq (Ordinal.lift.{w, max v u} (Ordinal.lift.{v, u} a)) (Ordinal.lift.{max v w, u} a)","decl":"@[simp]\ntheorem lift_lift (a : Ordinal.{u}) : lift.{w} (lift.{v} a) = lift.{max v w} a :=\n  (liftInitialSeg.trans liftInitialSeg).eq liftInitialSeg a\n\n"}
{"name":"Ordinal.lift_zero","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq (Ordinal.lift.{u_2, u_1} 0) 0","decl":"@[simp]\ntheorem lift_zero : lift 0 = 0 :=\n  type_eq_zero_of_empty _\n\n"}
{"name":"Ordinal.lift_one","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq (Ordinal.lift.{u_2, u_1} 1) 1","decl":"@[simp]\ntheorem lift_one : lift 1 = 1 :=\n  type_eq_one_of_unique _\n\n"}
{"name":"Ordinal.lift_card","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a : Ordinal.{v}\n⊢ Eq (Cardinal.lift.{u, v} a.card) (Ordinal.lift.{u, v} a).card","decl":"@[simp]\ntheorem lift_card (a) : Cardinal.lift.{u, v} (card a) = card (lift.{u} a) :=\n  inductionOn a fun _ _ _ => rfl\n\n"}
{"name":"Ordinal.mem_range_lift_of_le","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a : Ordinal.{u}\nb : Ordinal.{max u v}\nh : LE.le b (Ordinal.lift.{v, u} a)\n⊢ Membership.mem (Set.range Ordinal.lift.{v, u}) b","decl":"theorem mem_range_lift_of_le {a : Ordinal.{u}} {b : Ordinal.{max u v}} (h : b ≤ lift.{v} a) :\n    b ∈ Set.range lift.{v} :=\n  liftInitialSeg.mem_range_of_le h\n\n"}
{"name":"Ordinal.lift_down","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a : Ordinal.{u}\nb : Ordinal.{max u v}\nh : LE.le b (Ordinal.lift.{v, u} a)\n⊢ Exists fun a' => Eq (Ordinal.lift.{v, u} a') b","decl":"@[deprecated mem_range_lift_of_le (since := \"2024-10-07\")]\ntheorem lift_down {a : Ordinal.{u}} {b : Ordinal.{max u v}} (h : b ≤ lift.{v,u} a) :\n    ∃ a', lift.{v,u} a' = b :=\n  mem_range_lift_of_le h\n\n"}
{"name":"Ordinal.le_lift_iff","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a : Ordinal.{u}\nb : Ordinal.{max u v}\n⊢ Iff (LE.le b (Ordinal.lift.{v, u} a)) (Exists fun a' => And (LE.le a' a) (Eq (Ordinal.lift.{v, u} a') b))","decl":"theorem le_lift_iff {a : Ordinal.{u}} {b : Ordinal.{max u v}} :\n    b ≤ lift.{v} a ↔ ∃ a' ≤ a, lift.{v} a' = b :=\n  liftInitialSeg.le_apply_iff\n\n"}
{"name":"Ordinal.lt_lift_iff","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a : Ordinal.{u}\nb : Ordinal.{max u v}\n⊢ Iff (LT.lt b (Ordinal.lift.{v, u} a)) (Exists fun a' => And (LT.lt a' a) (Eq (Ordinal.lift.{v, u} a') b))","decl":"theorem lt_lift_iff {a : Ordinal.{u}} {b : Ordinal.{max u v}} :\n    b < lift.{v} a ↔ ∃ a' < a, lift.{v} a' = b :=\n  liftInitialSeg.lt_apply_iff\n\n"}
{"name":"Ordinal.type_nat_lt","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq (Ordinal.type fun x1 x2 => LT.lt x1 x2) Ordinal.omega0","decl":"/-- Note that the presence of this lemma makes `simp [omega0]` form a loop. -/\n@[simp]\ntheorem type_nat_lt : typeLT ℕ = ω :=\n  (lift_id _).symm\n\n"}
{"name":"Ordinal.card_omega0","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq Ordinal.omega0.card Cardinal.aleph0","decl":"@[simp]\ntheorem card_omega0 : card ω = ℵ₀ :=\n  rfl\n\n"}
{"name":"Ordinal.lift_omega0","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq (Ordinal.lift.{u_1, u_2} Ordinal.omega0) Ordinal.omega0","decl":"@[simp]\ntheorem lift_omega0 : lift ω = ω :=\n  lift_lift _\n\n"}
{"name":"Ordinal.card_add","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Eq (HAdd.hAdd o₁ o₂).card (HAdd.hAdd o₁.card o₂.card)","decl":"@[simp]\ntheorem card_add (o₁ o₂ : Ordinal) : card (o₁ + o₂) = card o₁ + card o₂ :=\n  inductionOn o₁ fun _ __ => inductionOn o₂ fun _ _ _ => rfl\n\n"}
{"name":"Ordinal.type_sum_lex","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α β : Type u\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : IsWellOrder β s\n⊢ Eq (Ordinal.type (Sum.Lex r s)) (HAdd.hAdd (Ordinal.type r) (Ordinal.type s))","decl":"@[simp]\ntheorem type_sum_lex {α β : Type u} (r : α → α → Prop) (s : β → β → Prop) [IsWellOrder α r]\n    [IsWellOrder β s] : type (Sum.Lex r s) = type r + type s :=\n  rfl\n\n"}
{"name":"Ordinal.card_nat","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"n : Nat\n⊢ Eq (↑n).card ↑n","decl":"@[simp]\ntheorem card_nat (n : ℕ) : card.{u} n = n := by\n  induction n <;> [simp; simp only [card_add, card_one, Nat.cast_succ, *]]\n\n"}
{"name":"Ordinal.card_ofNat","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n).card (OfNat.ofNat n)","decl":"@[simp]\ntheorem card_ofNat (n : ℕ) [n.AtLeastTwo] :\n    card.{u} ofNat(n) = OfNat.ofNat n :=\n  card_nat n\n\n"}
{"name":"Ordinal.instAddLeftMono","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ AddLeftMono Ordinal.{u}","decl":"instance instAddLeftMono : AddLeftMono Ordinal.{u} where\n  elim c a b := by\n    refine inductionOn₃ a b c fun α r _ β s _ γ t _ ⟨f⟩ ↦\n      (RelEmbedding.ofMonotone (Sum.recOn · Sum.inl (Sum.inr ∘ f)) ?_).ordinal_type_le\n    simp [f.map_rel_iff]\n\n"}
{"name":"Ordinal.instAddRightMono","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ AddRightMono Ordinal.{u}","decl":"instance instAddRightMono : AddRightMono Ordinal.{u} where\n  elim c a b := by\n    refine inductionOn₃ a b c fun α r _ β s _ γ t _  ⟨f⟩ ↦\n      (RelEmbedding.ofMonotone (Sum.recOn · (Sum.inl ∘ f) Sum.inr) ?_).ordinal_type_le\n    simp [f.map_rel_iff]\n\n"}
{"name":"Ordinal.le_add_right","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a b : Ordinal.{u_1}\n⊢ LE.le a (HAdd.hAdd a b)","decl":"theorem le_add_right (a b : Ordinal) : a ≤ a + b := by\n  simpa only [add_zero] using add_le_add_left (Ordinal.zero_le b) a\n\n"}
{"name":"Ordinal.le_add_left","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a b : Ordinal.{u_1}\n⊢ LE.le a (HAdd.hAdd b a)","decl":"theorem le_add_left (a b : Ordinal) : a ≤ b + a := by\n  simpa only [zero_add] using add_le_add_right (Ordinal.zero_le b) a\n\n"}
{"name":"Ordinal.max_zero_left","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a : Ordinal.{u_1}\n⊢ Eq (Max.max 0 a) a","decl":"theorem max_zero_left : ∀ a : Ordinal, max 0 a = a :=\n  max_bot_left\n\n"}
{"name":"Ordinal.max_zero_right","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a : Ordinal.{u_1}\n⊢ Eq (Max.max a 0) a","decl":"theorem max_zero_right : ∀ a : Ordinal, max a 0 = a :=\n  max_bot_right\n\n"}
{"name":"Ordinal.max_eq_zero","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a b : Ordinal.{u_1}\n⊢ Iff (Eq (Max.max a b) 0) (And (Eq a 0) (Eq b 0))","decl":"@[simp]\ntheorem max_eq_zero {a b : Ordinal} : max a b = 0 ↔ a = 0 ∧ b = 0 :=\n  max_eq_bot\n\n"}
{"name":"Ordinal.sInf_empty","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq (InfSet.sInf EmptyCollection.emptyCollection) 0","decl":"@[simp]\ntheorem sInf_empty : sInf (∅ : Set Ordinal) = 0 :=\n  dif_neg Set.not_nonempty_empty\n\n"}
{"name":"Ordinal.instNoMaxOrder","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ NoMaxOrder Ordinal.{u_1}","decl":"instance : NoMaxOrder Ordinal :=\n  ⟨fun _ => ⟨_, succ_le_iff'.1 le_rfl⟩⟩\n\n"}
{"name":"Ordinal.add_one_eq_succ","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (HAdd.hAdd o 1) (Order.succ o)","decl":"@[simp]\ntheorem add_one_eq_succ (o : Ordinal) : o + 1 = succ o :=\n  rfl\n\n"}
{"name":"Ordinal.succ_zero","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq (Order.succ 0) 1","decl":"@[simp]\ntheorem succ_zero : succ (0 : Ordinal) = 1 :=\n  zero_add 1\n\n-- Porting note: Proof used to be rfl\n"}
{"name":"Ordinal.succ_one","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq (Order.succ 1) 2","decl":"@[simp]\ntheorem succ_one : succ (1 : Ordinal) = 2 := by congr; simp only [Nat.unaryCast, zero_add]\n\n"}
{"name":"Ordinal.add_succ","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Eq (HAdd.hAdd o₁ (Order.succ o₂)) (Order.succ (HAdd.hAdd o₁ o₂))","decl":"theorem add_succ (o₁ o₂ : Ordinal) : o₁ + succ o₂ = succ (o₁ + o₂) :=\n  (add_assoc _ _ _).symm\n\n"}
{"name":"Ordinal.one_le_iff_pos","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (LE.le 1 o) (LT.lt 0 o)","decl":"@[deprecated Order.one_le_iff_pos (since := \"2024-09-04\")]\nprotected theorem one_le_iff_pos {o : Ordinal} : 1 ≤ o ↔ 0 < o :=\n  Order.one_le_iff_pos\n\n"}
{"name":"Ordinal.one_le_iff_ne_zero","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (LE.le 1 o) (Ne o 0)","decl":"theorem one_le_iff_ne_zero {o : Ordinal} : 1 ≤ o ↔ o ≠ 0 := by\n  rw [Order.one_le_iff_pos, Ordinal.pos_iff_ne_zero]\n\n"}
{"name":"Ordinal.succ_pos","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ LT.lt 0 (Order.succ o)","decl":"theorem succ_pos (o : Ordinal) : 0 < succ o :=\n  bot_lt_succ o\n\n"}
{"name":"Ordinal.succ_ne_zero","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Ne (Order.succ o) 0","decl":"theorem succ_ne_zero (o : Ordinal) : succ o ≠ 0 :=\n  ne_of_gt <| succ_pos o\n\n"}
{"name":"Ordinal.lt_one_iff_zero","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a : Ordinal.{u_1}\n⊢ Iff (LT.lt a 1) (Eq a 0)","decl":"@[simp]\ntheorem lt_one_iff_zero {a : Ordinal} : a < 1 ↔ a = 0 := by\n  simpa using @lt_succ_bot_iff _ _ _ a _ _\n\n"}
{"name":"Ordinal.le_one_iff","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a : Ordinal.{u_1}\n⊢ Iff (LE.le a 1) (Or (Eq a 0) (Eq a 1))","decl":"theorem le_one_iff {a : Ordinal} : a ≤ 1 ↔ a = 0 ∨ a = 1 := by\n  simpa using @le_succ_bot_iff _ _ _ a _\n\n"}
{"name":"Ordinal.card_succ","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Order.succ o).card (HAdd.hAdd o.card 1)","decl":"@[simp]\ntheorem card_succ (o : Ordinal) : card (succ o) = card o + 1 := by\n  simp only [← add_one_eq_succ, card_add, card_one]\n\n"}
{"name":"Ordinal.natCast_succ","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"n : Nat\n⊢ Eq (↑n.succ) (Order.succ ↑n)","decl":"theorem natCast_succ (n : ℕ) : ↑n.succ = succ (n : Ordinal) :=\n  rfl\n\n"}
{"name":"Ordinal.Iio_one_default_eq","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq Inhabited.default ⟨0, ⋯⟩","decl":"@[simp]\ntheorem Iio_one_default_eq : (default : Iio (1 : Ordinal)) = ⟨0, zero_lt_one' Ordinal⟩ :=\n  rfl\n\n"}
{"name":"Ordinal.one_toType_eq","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"x : Ordinal.toType 1\n⊢ Eq x ((Ordinal.enum fun x1 x2 => LT.lt x1 x2) ⟨0, ⋯⟩)","decl":"theorem one_toType_eq (x : toType 1) : x = enum (· < ·) ⟨0, by simp⟩ :=\n  Unique.eq_default x\n\n"}
{"name":"Ordinal.one_out_eq","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"x : Ordinal.toType 1\n⊢ Eq x ((Ordinal.enum fun x1 x2 => LT.lt x1 x2) ⟨0, ⋯⟩)","decl":"@[deprecated one_toType_eq (since := \"2024-08-26\")]\nalias one_out_eq := one_toType_eq\n\n"}
{"name":"Ordinal.typein_one_toType","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"x : Ordinal.toType 1\n⊢ Eq ((Ordinal.typein fun x1 x2 => LT.lt x1 x2).toRelEmbedding x) 0","decl":"@[simp]\ntheorem typein_one_toType (x : toType 1) : typein (α := toType 1) (· < ·) x = 0 := by\n  rw [one_toType_eq x, typein_enum]\n\n"}
{"name":"Ordinal.typein_one_out","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"x : Ordinal.toType 1\n⊢ Eq ((Ordinal.typein fun x1 x2 => LT.lt x1 x2).toRelEmbedding x) 0","decl":"@[deprecated typein_one_toType (since := \"2024-08-26\")]\nalias typein_one_out := typein_one_toType\n\n"}
{"name":"Ordinal.typein_le_typein'","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\nx y : o.toType\n⊢ Iff (LE.le ((Ordinal.typein fun x1 x2 => LT.lt x1 x2).toRelEmbedding x) ((Ordinal.typein fun x1 x2 => LT.lt x1 x2).toRelEmbedding y)) (LE.le x y)","decl":"theorem typein_le_typein' (o : Ordinal) {x y : o.toType} :\n    typein (α := o.toType) (· < ·) x ≤ typein (α := o.toType) (· < ·) y ↔ x ≤ y := by\n  simp\n\n"}
{"name":"Ordinal.le_enum_succ","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\na : (Order.succ o).toType\n⊢ LE.le a ((Ordinal.enum fun x1 x2 => LT.lt x1 x2) ⟨o, ⋯⟩)","decl":"theorem le_enum_succ {o : Ordinal} (a : (succ o).toType) :\n    a ≤ enum (α := (succ o).toType) (· < ·) ⟨o, (type_toType _ ▸ lt_succ o)⟩ := by\n  rw [← enum_typein (α := (succ o).toType) (· < ·) a, enum_le_enum', Subtype.mk_le_mk,\n    ← lt_succ_iff]\n  apply typein_lt_self\n\n"}
{"name":"Ordinal.univ_id","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq Ordinal.univ.{u, u + 1} (Ordinal.type fun x1 x2 => LT.lt x1 x2)","decl":"theorem univ_id : univ.{u, u + 1} = typeLT Ordinal :=\n  lift_id _\n\n"}
{"name":"Ordinal.lift_univ","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq (Ordinal.lift.{w, max (u + 1) v} Ordinal.univ.{u, v}) Ordinal.univ.{u, max v w}","decl":"@[simp]\ntheorem lift_univ : lift.{w} univ.{u, v} = univ.{u, max v w} :=\n  lift_lift _\n\n"}
{"name":"Ordinal.univ_umax","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq Ordinal.univ.{u, max (u + 1) v} Ordinal.univ.{u, v}","decl":"theorem univ_umax : univ.{u, max (u + 1) v} = univ.{u, v} :=\n  congr_fun lift_umax _\n\n"}
{"name":"Ordinal.liftPrincipalSeg_coe","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq (⇑Ordinal.liftPrincipalSeg.toRelEmbedding) Ordinal.lift.{max (u + 1) v, u}","decl":"@[simp]\ntheorem liftPrincipalSeg_coe :\n    (liftPrincipalSeg.{u, v} : Ordinal → Ordinal) = lift.{max (u + 1) v} :=\n  rfl\n\n"}
{"name":"Ordinal.lift.principalSeg_coe","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq (⇑Ordinal.lift.principalSeg.toRelEmbedding) Ordinal.lift.{max (u + 1) v, u}","decl":"set_option linter.deprecated false in\n@[deprecated liftPrincipalSeg_coe (since := \"2024-09-21\")]\ntheorem lift.principalSeg_coe :\n    (lift.principalSeg.{u, v} : Ordinal → Ordinal) = lift.{max (u + 1) v} :=\n  rfl\n\n"}
{"name":"Ordinal.liftPrincipalSeg_top","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq Ordinal.liftPrincipalSeg.top Ordinal.univ.{u, v}","decl":"@[simp]\ntheorem liftPrincipalSeg_top : (liftPrincipalSeg.{u, v}).top = univ.{u, v} :=\n  rfl\n\n"}
{"name":"Ordinal.lift.principalSeg_top","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq Ordinal.lift.principalSeg.top Ordinal.univ.{u, v}","decl":"set_option linter.deprecated false in\n@[deprecated liftPrincipalSeg_top (since := \"2024-09-21\")]\ntheorem lift.principalSeg_top : (lift.principalSeg.{u, v}).top = univ.{u, v} :=\n  rfl\n\n"}
{"name":"Ordinal.liftPrincipalSeg_top'","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq Ordinal.liftPrincipalSeg.top (Ordinal.type fun x1 x2 => LT.lt x1 x2)","decl":"theorem liftPrincipalSeg_top' : liftPrincipalSeg.{u, u + 1}.top = typeLT Ordinal := by\n  simp only [liftPrincipalSeg_top, univ_id]\n\n"}
{"name":"Ordinal.lift.principalSeg_top'","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq Ordinal.lift.principalSeg.top (Ordinal.type fun x1 x2 => LT.lt x1 x2)","decl":"set_option linter.deprecated false in\n@[deprecated liftPrincipalSeg_top (since := \"2024-09-21\")]\ntheorem lift.principalSeg_top' : lift.principalSeg.{u, u + 1}.top = typeLT Ordinal := by\n  simp only [lift.principalSeg_top, univ_id]\n\n"}
{"name":"Cardinal.mk_toType","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Cardinal.mk o.toType) o.card","decl":"@[simp]\ntheorem mk_toType (o : Ordinal) : #o.toType = o.card :=\n  (Ordinal.card_type _).symm.trans <| by rw [Ordinal.type_toType]\n\n"}
{"name":"Cardinal.mk_ordinal_out","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Cardinal.mk o.toType) o.card","decl":"@[deprecated mk_toType (since := \"2024-08-26\")]\nalias mk_ordinal_out := mk_toType\n\n"}
{"name":"Cardinal.ord_eq_Inf","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\n⊢ Eq (Cardinal.mk α).ord (iInf fun r => Ordinal.type ↑r)","decl":"theorem ord_eq_Inf (α : Type u) : ord #α = ⨅ r : { r // IsWellOrder α r }, @type α r.1 r.2 :=\n  rfl\n\n"}
{"name":"Cardinal.ord_eq","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u_1\n⊢ Exists fun r => Exists fun wo => Eq (Cardinal.mk α).ord (Ordinal.type r)","decl":"theorem ord_eq (α) : ∃ (r : α → α → Prop) (wo : IsWellOrder α r), ord #α = @type α r wo :=\n  let ⟨r, wo⟩ := ciInf_mem fun r : { r // IsWellOrder α r } => @type α r.1 r.2\n  ⟨r.1, r.2, wo.symm⟩\n\n"}
{"name":"Cardinal.ord_le_type","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\nh : IsWellOrder α r\n⊢ LE.le (Cardinal.mk α).ord (Ordinal.type r)","decl":"theorem ord_le_type (r : α → α → Prop) [h : IsWellOrder α r] : ord #α ≤ type r :=\n  ciInf_le' _ (Subtype.mk r h)\n\n"}
{"name":"Cardinal.ord_le","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"c : Cardinal.{u_1}\no : Ordinal.{u_1}\n⊢ Iff (LE.le c.ord o) (LE.le c o.card)","decl":"theorem ord_le {c o} : ord c ≤ o ↔ c ≤ o.card :=\n  inductionOn c fun α =>\n    Ordinal.inductionOn o fun β s _ => by\n      let ⟨r, _, e⟩ := ord_eq α\n      simp only [card_type]; constructor <;> intro h\n      · rw [e] at h\n        exact\n          let ⟨f⟩ := h\n          ⟨f.toEmbedding⟩\n      · cases' h with f\n        have g := RelEmbedding.preimage f s\n        haveI := RelEmbedding.isWellOrder g\n        exact le_trans (ord_le_type _) g.ordinal_type_le\n\n"}
{"name":"Cardinal.gc_ord_card","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ GaloisConnection Cardinal.ord Ordinal.card","decl":"theorem gc_ord_card : GaloisConnection ord card := fun _ _ => ord_le\n\n"}
{"name":"Cardinal.lt_ord","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"c : Cardinal.{u_1}\no : Ordinal.{u_1}\n⊢ Iff (LT.lt o c.ord) (LT.lt o.card c)","decl":"theorem lt_ord {c o} : o < ord c ↔ o.card < c :=\n  gc_ord_card.lt_iff_lt\n\n"}
{"name":"Cardinal.card_ord","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"c : Cardinal.{u_1}\n⊢ Eq c.ord.card c","decl":"@[simp]\ntheorem card_ord (c) : (ord c).card = c :=\n  c.inductionOn fun α ↦ let ⟨r, _, e⟩ := ord_eq α; e ▸ card_type r\n\n"}
{"name":"Cardinal.card_surjective","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Function.Surjective Ordinal.card","decl":"theorem card_surjective : Function.Surjective card :=\n  fun c ↦ ⟨_, card_ord c⟩\n\n"}
{"name":"Cardinal.ord_card_le","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ LE.le o.card.ord o","decl":"theorem ord_card_le (o : Ordinal) : o.card.ord ≤ o :=\n  gc_ord_card.l_u_le _\n\n"}
{"name":"Cardinal.lt_ord_succ_card","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ LT.lt o (Order.succ o.card).ord","decl":"theorem lt_ord_succ_card (o : Ordinal) : o < (succ o.card).ord :=\n  lt_ord.2 <| lt_succ _\n\n"}
{"name":"Cardinal.card_le_iff","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\nc : Cardinal.{u_1}\n⊢ Iff (LE.le o.card c) (LT.lt o (Order.succ c).ord)","decl":"theorem card_le_iff {o : Ordinal} {c : Cardinal} : o.card ≤ c ↔ o < (succ c).ord := by\n  rw [lt_ord, lt_succ_iff]\n\n"}
{"name":"Cardinal.card_le_of_le_ord","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\nc : Cardinal.{u_1}\nho : LE.le o c.ord\n⊢ LE.le o.card c","decl":"/--\nA variation on `Cardinal.lt_ord` using `≤`: If `o` is no greater than the\ninitial ordinal of cardinality `c`, then its cardinal is no greater than `c`.\n\nThe converse, however, is false (for instance, `o = ω+1` and `c = ℵ₀`).\n-/\nlemma card_le_of_le_ord {o : Ordinal} {c : Cardinal} (ho : o ≤ c.ord) :\n    o.card ≤ c := by\n  rw [← card_ord c]; exact Ordinal.card_le_card ho\n\n"}
{"name":"Cardinal.ord_strictMono","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ StrictMono Cardinal.ord","decl":"@[mono]\ntheorem ord_strictMono : StrictMono ord :=\n  gciOrdCard.strictMono_l\n\n"}
{"name":"Cardinal.ord_mono","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Monotone Cardinal.ord","decl":"@[mono]\ntheorem ord_mono : Monotone ord :=\n  gc_ord_card.monotone_l\n\n"}
{"name":"Cardinal.ord_le_ord","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"c₁ c₂ : Cardinal.{u_1}\n⊢ Iff (LE.le c₁.ord c₂.ord) (LE.le c₁ c₂)","decl":"@[simp]\ntheorem ord_le_ord {c₁ c₂} : ord c₁ ≤ ord c₂ ↔ c₁ ≤ c₂ :=\n  gciOrdCard.l_le_l_iff\n\n"}
{"name":"Cardinal.ord_lt_ord","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"c₁ c₂ : Cardinal.{u_1}\n⊢ Iff (LT.lt c₁.ord c₂.ord) (LT.lt c₁ c₂)","decl":"@[simp]\ntheorem ord_lt_ord {c₁ c₂} : ord c₁ < ord c₂ ↔ c₁ < c₂ :=\n  ord_strictMono.lt_iff_lt\n\n"}
{"name":"Cardinal.ord_zero","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq (Cardinal.ord 0) 0","decl":"@[simp]\ntheorem ord_zero : ord 0 = 0 :=\n  gc_ord_card.l_bot\n\n"}
{"name":"Cardinal.ord_nat","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"n : Nat\n⊢ Eq (↑n).ord ↑n","decl":"@[simp]\ntheorem ord_nat (n : ℕ) : ord n = n :=\n  (ord_le.2 (card_nat n).ge).antisymm\n    (by\n      induction' n with n IH\n      · apply Ordinal.zero_le\n      · exact succ_le_of_lt (IH.trans_lt <| ord_lt_ord.2 <| Nat.cast_lt.2 (Nat.lt_succ_self n)))\n\n"}
{"name":"Cardinal.ord_one","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq (Cardinal.ord 1) 1","decl":"@[simp]\ntheorem ord_one : ord 1 = 1 := by simpa using ord_nat 1\n\n"}
{"name":"Cardinal.ord_ofNat","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n).ord (OfNat.ofNat n)","decl":"@[simp]\ntheorem ord_ofNat (n : ℕ) [n.AtLeastTwo] : ord ofNat(n) = OfNat.ofNat n :=\n  ord_nat n\n\n"}
{"name":"Cardinal.ord_aleph0","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq Cardinal.aleph0.ord Ordinal.omega0","decl":"@[simp]\ntheorem ord_aleph0 : ord.{u} ℵ₀ = ω :=\n  le_antisymm (ord_le.2 le_rfl) <|\n    le_of_forall_lt fun o h => by\n      rcases Ordinal.lt_lift_iff.1 h with ⟨o, h', rfl⟩\n      rw [lt_ord, ← lift_card, lift_lt_aleph0, ← typein_enum (· < ·) h']\n      exact lt_aleph0_iff_fintype.2 ⟨Set.fintypeLTNat _⟩\n\n"}
{"name":"Cardinal.lift_ord","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"c : Cardinal.{v}\n⊢ Eq (Ordinal.lift.{u, v} c.ord) (Cardinal.lift.{u, v} c).ord","decl":"@[simp]\ntheorem lift_ord (c) : Ordinal.lift.{u,v} (ord c) = ord (lift.{u,v} c) := by\n  refine le_antisymm (le_of_forall_lt fun a ha => ?_) ?_\n  · rcases Ordinal.lt_lift_iff.1 ha with ⟨a, _, rfl⟩\n    rwa [lt_ord, ← lift_card, lift_lt, ← lt_ord, ← Ordinal.lift_lt]\n  · rw [ord_le, ← lift_card, card_ord]\n\n"}
{"name":"Cardinal.mk_ord_toType","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"c : Cardinal.{u_1}\n⊢ Eq (Cardinal.mk c.ord.toType) c","decl":"theorem mk_ord_toType (c : Cardinal) : #c.ord.toType = c := by simp\n\n"}
{"name":"Cardinal.mk_ord_out","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"c : Cardinal.{u_1}\n⊢ Eq (Cardinal.mk c.ord.toType) c","decl":"@[deprecated mk_ord_toType (since := \"2024-08-26\")]\nalias mk_ord_out := mk_ord_toType\n\n"}
{"name":"Cardinal.card_typein_lt","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\nx : α\nh : Eq (Cardinal.mk α).ord (Ordinal.type r)\n⊢ LT.lt ((Ordinal.typein r).toRelEmbedding x).card (Cardinal.mk α)","decl":"theorem card_typein_lt (r : α → α → Prop) [IsWellOrder α r] (x : α) (h : ord #α = type r) :\n    card (typein r x) < #α := by\n  rw [← lt_ord, h]\n  apply typein_lt_type\n\n"}
{"name":"Cardinal.card_typein_toType_lt","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"c : Cardinal.{u_1}\nx : c.ord.toType\n⊢ LT.lt ((Ordinal.typein fun x1 x2 => LT.lt x1 x2).toRelEmbedding x).card c","decl":"theorem card_typein_toType_lt (c : Cardinal) (x : c.ord.toType) :\n    card (typein (α := c.ord.toType) (· < ·) x) < c := by\n  rw [← lt_ord]\n  apply typein_lt_self\n\n"}
{"name":"Cardinal.card_typein_out_lt","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"c : Cardinal.{u_1}\nx : c.ord.toType\n⊢ LT.lt ((Ordinal.typein fun x1 x2 => LT.lt x1 x2).toRelEmbedding x).card c","decl":"@[deprecated card_typein_toType_lt (since := \"2024-08-26\")]\nalias card_typein_out_lt := card_typein_toType_lt\n\n"}
{"name":"Cardinal.mk_Iio_ord_toType","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"c : Cardinal.{u_1}\ni : c.ord.toType\n⊢ LT.lt (Cardinal.mk ↑(Set.Iio i)) c","decl":"theorem mk_Iio_ord_toType {c : Cardinal} (i : c.ord.toType) : #(Iio i) < c :=\n  card_typein_toType_lt c i\n\n"}
{"name":"Cardinal.mk_Iio_ord_out_α","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"c : Cardinal.{u_1}\ni : c.ord.toType\n⊢ LT.lt (Cardinal.mk ↑(Set.Iio i)) c","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-08-26\")]\nalias mk_Iio_ord_out_α := mk_Iio_ord_toType\n\n"}
{"name":"Cardinal.ord_injective","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Function.Injective Cardinal.ord","decl":"theorem ord_injective : Injective ord := by\n  intro c c' h\n  rw [← card_ord c, ← card_ord c', h]\n\n"}
{"name":"Cardinal.ord_inj","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a b : Cardinal.{u_1}\n⊢ Iff (Eq a.ord b.ord) (Eq a b)","decl":"@[simp]\ntheorem ord_inj {a b : Cardinal} : a.ord = b.ord ↔ a = b :=\n  ord_injective.eq_iff\n\n"}
{"name":"Cardinal.ord_eq_zero","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a : Cardinal.{u_1}\n⊢ Iff (Eq a.ord 0) (Eq a 0)","decl":"@[simp]\ntheorem ord_eq_zero {a : Cardinal} : a.ord = 0 ↔ a = 0 :=\n  ord_injective.eq_iff' ord_zero\n\n"}
{"name":"Cardinal.ord_eq_one","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a : Cardinal.{u_1}\n⊢ Iff (Eq a.ord 1) (Eq a 1)","decl":"@[simp]\ntheorem ord_eq_one {a : Cardinal} : a.ord = 1 ↔ a = 1 :=\n  ord_injective.eq_iff' ord_one\n\n"}
{"name":"Cardinal.omega0_le_ord","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a : Cardinal.{u_1}\n⊢ Iff (LE.le Ordinal.omega0 a.ord) (LE.le Cardinal.aleph0 a)","decl":"@[simp]\ntheorem omega0_le_ord {a : Cardinal} : ω ≤ a.ord ↔ ℵ₀ ≤ a := by\n  rw [← ord_aleph0, ord_le_ord]\n\n"}
{"name":"Cardinal.ord_le_omega0","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a : Cardinal.{u_1}\n⊢ Iff (LE.le a.ord Ordinal.omega0) (LE.le a Cardinal.aleph0)","decl":"@[simp]\ntheorem ord_le_omega0 {a : Cardinal} : a.ord ≤ ω ↔ a ≤ ℵ₀ := by\n  rw [← ord_aleph0, ord_le_ord]\n\n"}
{"name":"Cardinal.ord_lt_omega0","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a : Cardinal.{u_1}\n⊢ Iff (LT.lt a.ord Ordinal.omega0) (LT.lt a Cardinal.aleph0)","decl":"@[simp]\ntheorem ord_lt_omega0 {a : Cardinal} : a.ord < ω ↔ a < ℵ₀ :=\n  le_iff_le_iff_lt_iff_lt.1 omega0_le_ord\n\n"}
{"name":"Cardinal.omega0_lt_ord","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a : Cardinal.{u_1}\n⊢ Iff (LT.lt Ordinal.omega0 a.ord) (LT.lt Cardinal.aleph0 a)","decl":"@[simp]\ntheorem omega0_lt_ord {a : Cardinal} : ω < a.ord ↔ ℵ₀ < a :=\n  le_iff_le_iff_lt_iff_lt.1 ord_le_omega0\n\n"}
{"name":"Cardinal.ord_eq_omega0","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a : Cardinal.{u_1}\n⊢ Iff (Eq a.ord Ordinal.omega0) (Eq a Cardinal.aleph0)","decl":"@[simp]\ntheorem ord_eq_omega0 {a : Cardinal} : a.ord = ω ↔ a = ℵ₀ :=\n  ord_injective.eq_iff' ord_aleph0\n\n"}
{"name":"Cardinal.ord.orderEmbedding_coe","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq (⇑Cardinal.ord.orderEmbedding) Cardinal.ord","decl":"@[simp]\ntheorem ord.orderEmbedding_coe : (ord.orderEmbedding : Cardinal → Ordinal) = ord :=\n  rfl\n\n-- intended to be used with explicit universe parameters\n"}
{"name":"Cardinal.univ_id","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq Cardinal.univ.{u, u + 1} (Cardinal.mk Ordinal.{u})","decl":"theorem univ_id : univ.{u, u + 1} = #Ordinal :=\n  lift_id _\n\n"}
{"name":"Cardinal.lift_univ","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq (Cardinal.lift.{w, max (u + 1) v} Cardinal.univ.{u, v}) Cardinal.univ.{u, max v w}","decl":"@[simp]\ntheorem lift_univ : lift.{w} univ.{u, v} = univ.{u, max v w} :=\n  lift_lift _\n\n"}
{"name":"Cardinal.univ_umax","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq Cardinal.univ.{u, max (u + 1) v} Cardinal.univ.{u, v}","decl":"theorem univ_umax : univ.{u, max (u + 1) v} = univ.{u, v} :=\n  congr_fun lift_umax _\n\n"}
{"name":"Cardinal.lift_lt_univ","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"c : Cardinal.{u}\n⊢ LT.lt (Cardinal.lift.{u + 1, u} c) Cardinal.univ.{u, u + 1}","decl":"theorem lift_lt_univ (c : Cardinal) : lift.{u + 1, u} c < univ.{u, u + 1} := by\n  simpa only [liftPrincipalSeg_coe, lift_ord, lift_succ, ord_le, succ_le_iff] using\n    le_of_lt (liftPrincipalSeg.{u, u + 1}.lt_top (succ c).ord)\n\n"}
{"name":"Cardinal.lift_lt_univ'","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"c : Cardinal.{u}\n⊢ LT.lt (Cardinal.lift.{max (u + 1) v, u} c) Cardinal.univ.{u, v}","decl":"theorem lift_lt_univ' (c : Cardinal) : lift.{max (u + 1) v, u} c < univ.{u, v} := by\n  have := lift_lt.{_, max (u+1) v}.2 (lift_lt_univ c)\n  rw [lift_lift, lift_univ, univ_umax.{u,v}] at this\n  exact this\n\n"}
{"name":"Cardinal.ord_univ","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq Cardinal.univ.{u, v}.ord Ordinal.univ.{u, v}","decl":"@[simp]\ntheorem ord_univ : ord univ.{u, v} = Ordinal.univ.{u, v} := by\n  refine le_antisymm (ord_card_le _) <| le_of_forall_lt fun o h => lt_ord.2 ?_\n  have := liftPrincipalSeg.mem_range_of_rel_top (by simpa only [liftPrincipalSeg_coe] using h)\n  rcases this with ⟨o, h'⟩\n  rw [← h', liftPrincipalSeg_coe, ← lift_card]\n  apply lift_lt_univ'\n\n"}
{"name":"Cardinal.lt_univ","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"c : Cardinal.{u + 1}\n⊢ Iff (LT.lt c Cardinal.univ.{u, u + 1}) (Exists fun c' => Eq c (Cardinal.lift.{u + 1, u} c'))","decl":"theorem lt_univ {c} : c < univ.{u, u + 1} ↔ ∃ c', c = lift.{u + 1, u} c' :=\n  ⟨fun h => by\n    have := ord_lt_ord.2 h\n    rw [ord_univ] at this\n    cases' liftPrincipalSeg.mem_range_of_rel_top (by simpa only [liftPrincipalSeg_top]) with o e\n    have := card_ord c\n    rw [← e, liftPrincipalSeg_coe, ← lift_card] at this\n    exact ⟨_, this.symm⟩, fun ⟨_, e⟩ => e.symm ▸ lift_lt_univ _⟩\n\n"}
{"name":"Cardinal.lt_univ'","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"c : Cardinal.{max (u + 1) v}\n⊢ Iff (LT.lt c Cardinal.univ.{u, v}) (Exists fun c' => Eq c (Cardinal.lift.{max (u + 1) v, u} c'))","decl":"theorem lt_univ' {c} : c < univ.{u, v} ↔ ∃ c', c = lift.{max (u + 1) v, u} c' :=\n  ⟨fun h => by\n    let ⟨a, h', e⟩ := lt_lift_iff.1 h\n    rw [← univ_id] at h'\n    rcases lt_univ.{u}.1 h' with ⟨c', rfl⟩\n    exact ⟨c', by simp only [e.symm, lift_lift]⟩, fun ⟨_, e⟩ => e.symm ▸ lift_lt_univ' _⟩\n\n"}
{"name":"Cardinal.small_iff_lift_mk_lt_univ","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\n⊢ Iff (Small.{v, u} α) (LT.lt (Cardinal.lift.{v + 1, u} (Cardinal.mk α)) Cardinal.univ.{v, max u (v + 1)})","decl":"theorem small_iff_lift_mk_lt_univ {α : Type u} :\n    Small.{v} α ↔ Cardinal.lift.{v+1,_} #α < univ.{v, max u (v + 1)} := by\n  rw [lt_univ']\n  constructor\n  · rintro ⟨β, e⟩\n    exact ⟨#β, lift_mk_eq.{u, _, v + 1}.2 e⟩\n  · rintro ⟨c, hc⟩\n    exact ⟨⟨c.out, lift_mk_eq.{u, _, v + 1}.1 (hc.trans (congr rfl c.mk_out.symm))⟩⟩\n\n"}
{"name":"Ordinal.card_univ","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"⊢ Eq Ordinal.univ.{u, v}.card Cardinal.univ.{u, v}","decl":"@[simp]\ntheorem card_univ : card univ.{u,v} = Cardinal.univ.{u,v} :=\n  rfl\n\n"}
{"name":"Ordinal.nat_le_card","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\nn : Nat\n⊢ Iff (LE.le (↑n) o.card) (LE.le (↑n) o)","decl":"@[simp]\ntheorem nat_le_card {o} {n : ℕ} : (n : Cardinal) ≤ card o ↔ (n : Ordinal) ≤ o := by\n  rw [← Cardinal.ord_le, Cardinal.ord_nat]\n\n"}
{"name":"Ordinal.one_le_card","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (LE.le 1 o.card) (LE.le 1 o)","decl":"@[simp]\ntheorem one_le_card {o} : 1 ≤ card o ↔ 1 ≤ o := by\n  simpa using nat_le_card (n := 1)\n\n"}
{"name":"Ordinal.ofNat_le_card","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (LE.le (OfNat.ofNat n) o.card) (LE.le (OfNat.ofNat n) o)","decl":"@[simp]\ntheorem ofNat_le_card {o} {n : ℕ} [n.AtLeastTwo] :\n    (ofNat(n) : Cardinal) ≤ card o ↔ (OfNat.ofNat n : Ordinal) ≤ o :=\n  nat_le_card\n\n"}
{"name":"Ordinal.aleph0_le_card","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (LE.le Cardinal.aleph0 o.card) (LE.le Ordinal.omega0 o)","decl":"@[simp]\ntheorem aleph0_le_card {o} : ℵ₀ ≤ card o ↔ ω ≤ o := by\n  rw [← ord_le, ord_aleph0]\n\n"}
{"name":"Ordinal.card_lt_aleph0","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (LT.lt o.card Cardinal.aleph0) (LT.lt o Ordinal.omega0)","decl":"@[simp]\ntheorem card_lt_aleph0 {o} : card o < ℵ₀ ↔ o < ω :=\n  le_iff_le_iff_lt_iff_lt.1 aleph0_le_card\n\n"}
{"name":"Ordinal.nat_lt_card","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\nn : Nat\n⊢ Iff (LT.lt (↑n) o.card) (LT.lt (↑n) o)","decl":"@[simp]\ntheorem nat_lt_card {o} {n : ℕ} : (n : Cardinal) < card o ↔ (n : Ordinal) < o := by\n  rw [← succ_le_iff, ← succ_le_iff, ← nat_succ, nat_le_card]\n  rfl\n\n"}
{"name":"Ordinal.zero_lt_card","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (LT.lt 0 o.card) (LT.lt 0 o)","decl":"@[simp]\ntheorem zero_lt_card {o} : 0 < card o ↔ 0 < o := by\n  simpa using nat_lt_card (n := 0)\n\n"}
{"name":"Ordinal.one_lt_card","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (LT.lt 1 o.card) (LT.lt 1 o)","decl":"@[simp]\ntheorem one_lt_card {o} : 1 < card o ↔ 1 < o := by\n  simpa using nat_lt_card (n := 1)\n\n"}
{"name":"Ordinal.ofNat_lt_card","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (LT.lt (OfNat.ofNat n) o.card) (LT.lt (OfNat.ofNat n) o)","decl":"@[simp]\ntheorem ofNat_lt_card {o} {n : ℕ} [n.AtLeastTwo] :\n    (ofNat(n) : Cardinal) < card o ↔ (OfNat.ofNat n : Ordinal) < o :=\n  nat_lt_card\n\n"}
{"name":"Ordinal.card_lt_nat","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\nn : Nat\n⊢ Iff (LT.lt o.card ↑n) (LT.lt o ↑n)","decl":"@[simp]\ntheorem card_lt_nat {o} {n : ℕ} : card o < n ↔ o < n :=\n  lt_iff_lt_of_le_iff_le nat_le_card\n\n"}
{"name":"Ordinal.card_lt_ofNat","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (LT.lt o.card (OfNat.ofNat n)) (LT.lt o (OfNat.ofNat n))","decl":"@[simp]\ntheorem card_lt_ofNat {o} {n : ℕ} [n.AtLeastTwo] :\n    card o < ofNat(n) ↔ o < OfNat.ofNat n :=\n  card_lt_nat\n\n"}
{"name":"Ordinal.card_le_nat","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\nn : Nat\n⊢ Iff (LE.le o.card ↑n) (LE.le o ↑n)","decl":"@[simp]\ntheorem card_le_nat {o} {n : ℕ} : card o ≤ n ↔ o ≤ n :=\n  le_iff_le_iff_lt_iff_lt.2 nat_lt_card\n\n"}
{"name":"Ordinal.card_le_one","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (LE.le o.card 1) (LE.le o 1)","decl":"@[simp]\ntheorem card_le_one {o} : card o ≤ 1 ↔ o ≤ 1 := by\n  simpa using card_le_nat (n := 1)\n\n"}
{"name":"Ordinal.card_le_ofNat","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (LE.le o.card (OfNat.ofNat n)) (LE.le o (OfNat.ofNat n))","decl":"@[simp]\ntheorem card_le_ofNat {o} {n : ℕ} [n.AtLeastTwo] :\n    card o ≤ ofNat(n) ↔ o ≤ OfNat.ofNat n :=\n  card_le_nat\n\n"}
{"name":"Ordinal.card_eq_nat","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\nn : Nat\n⊢ Iff (Eq o.card ↑n) (Eq o ↑n)","decl":"@[simp]\ntheorem card_eq_nat {o} {n : ℕ} : card o = n ↔ o = n := by\n  simp only [le_antisymm_iff, card_le_nat, nat_le_card]\n\n"}
{"name":"Ordinal.card_eq_zero","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (Eq o.card 0) (Eq o 0)","decl":"@[simp]\ntheorem card_eq_zero {o} : card o = 0 ↔ o = 0 := by\n  simpa using card_eq_nat (n := 0)\n\n"}
{"name":"Ordinal.card_eq_one","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (Eq o.card 1) (Eq o 1)","decl":"@[simp]\ntheorem card_eq_one {o} : card o = 1 ↔ o = 1 := by\n  simpa using card_eq_nat (n := 1)\n\n"}
{"name":"Ordinal.mem_range_lift_of_card_le","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a : Cardinal.{u}\nb : Ordinal.{max u v}\nh : LE.le b.card (Cardinal.lift.{v, u} a)\n⊢ Membership.mem (Set.range Ordinal.lift.{v, u}) b","decl":"theorem mem_range_lift_of_card_le {a : Cardinal.{u}} {b : Ordinal.{max u v}}\n    (h : card b ≤ Cardinal.lift.{v, u} a) : b ∈ Set.range lift.{v, u} := by\n  rw [card_le_iff, ← lift_succ, ← lift_ord] at h\n  exact mem_range_lift_of_le h.le\n\n"}
{"name":"Ordinal.lift_down'","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"a : Cardinal.{u}\nb : Ordinal.{max u v}\nh : LE.le b.card (Cardinal.lift.{v, u} a)\n⊢ Exists fun a' => Eq (Ordinal.lift.{v, u} a') b","decl":"@[deprecated mem_range_lift_of_card_le (since := \"2024-10-07\")]\ntheorem lift_down' {a : Cardinal.{u}} {b : Ordinal.{max u v}}\n    (h : card.{max u v} b ≤ Cardinal.lift.{v, u} a) : ∃ a', lift.{v, u} a' = b :=\n  mem_range_lift_of_card_le h\n\n"}
{"name":"Ordinal.card_eq_ofNat","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"o : Ordinal.{u_1}\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (Eq o.card (OfNat.ofNat n)) (Eq o (OfNat.ofNat n))","decl":"@[simp]\ntheorem card_eq_ofNat {o} {n : ℕ} [n.AtLeastTwo] :\n    card o = ofNat(n) ↔ o = OfNat.ofNat n :=\n  card_eq_nat\n\n"}
{"name":"Ordinal.type_fintype","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : Fintype α\n⊢ Eq (Ordinal.type r) ↑(Fintype.card α)","decl":"@[simp]\ntheorem type_fintype (r : α → α → Prop) [IsWellOrder α r] [Fintype α] :\n    type r = Fintype.card α := by rw [← card_eq_nat, card_type, mk_fintype]\n\n"}
{"name":"Ordinal.type_fin","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"n : Nat\n⊢ Eq (Ordinal.type fun x1 x2 => LT.lt x1 x2) ↑n","decl":"theorem type_fin (n : ℕ) : typeLT (Fin n) = n := by simp\n\n"}
{"name":"List.Sorted.lt_ord_of_lt","module":"Mathlib.SetTheory.Ordinal.Basic","initialProofState":"α : Type u\ninst✝¹ : LinearOrder α\ninst✝ : WellFoundedLT α\nl m : List α\no : Ordinal.{u}\nhl : List.Sorted (fun x1 x2 => GT.gt x1 x2) l\nhm : List.Sorted (fun x1 x2 => GT.gt x1 x2) m\nhmltl : LT.lt m l\nhlt : ∀ (i : α), Membership.mem l i → LT.lt ((Ordinal.typein fun x1 x2 => LT.lt x1 x2).toRelEmbedding i) o\ni : α\na✝ : Membership.mem m i\n⊢ LT.lt ((Ordinal.typein fun x1 x2 => LT.lt x1 x2).toRelEmbedding i) o","decl":"theorem List.Sorted.lt_ord_of_lt [LinearOrder α] [WellFoundedLT α] {l m : List α}\n    {o : Ordinal} (hl : l.Sorted (· > ·)) (hm : m.Sorted (· > ·)) (hmltl : m < l)\n    (hlt : ∀ i ∈ l, Ordinal.typein (α := α) (· < ·) i < o) :\n      ∀ i ∈ m, Ordinal.typein (α := α) (· < ·) i < o := by\n  replace hmltl : List.Lex (· < ·) m l := hmltl\n  cases l with\n  | nil => simp at hmltl\n  | cons a as =>\n    cases m with\n    | nil => intro i hi; simp at hi\n    | cons b bs =>\n      intro i hi\n      suffices h : i ≤ a by refine lt_of_le_of_lt ?_ (hlt a (mem_cons_self a as)); simpa\n      cases hi with\n      | head as => exact List.head_le_of_lt hmltl\n      | tail b hi => exact le_of_lt (lt_of_lt_of_le (List.rel_of_sorted_cons hm _ hi)\n          (List.head_le_of_lt hmltl))\n"}
