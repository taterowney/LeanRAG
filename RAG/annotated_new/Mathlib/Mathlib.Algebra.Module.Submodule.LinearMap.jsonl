{"name":"SMulMemClass.coeSubtype","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nA : Type u_1\ninst✝² : SetLike A M\ninst✝¹ : AddSubmonoidClass A M\ninst✝ : SMulMemClass A R M\nS' : A\n⊢ Eq (⇑(SMulMemClass.subtype S')) Subtype.val","decl":"@[simp]\nprotected theorem coeSubtype : (SMulMemClass.subtype S' : S' → M) = Subtype.val :=\n  rfl\n\n"}
{"name":"Submodule.subtype_apply","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\nx : Subtype fun x => Membership.mem p x\n⊢ Eq (p.subtype x) ↑x","decl":"theorem subtype_apply (x : p) : p.subtype x = x :=\n  rfl\n\n"}
{"name":"Submodule.coe_subtype","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\n⊢ Eq (⇑p.subtype) Subtype.val","decl":"@[simp]\ntheorem coe_subtype : (Submodule.subtype p : p → M) = Subtype.val :=\n  rfl\n\n"}
{"name":"Submodule.coeSubtype","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\n⊢ Eq (⇑p.subtype) Subtype.val","decl":"@[deprecated (since := \"2024-09-27\")] alias coeSubtype := coe_subtype\n\n"}
{"name":"Submodule.injective_subtype","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\n⊢ Function.Injective ⇑p.subtype","decl":"theorem injective_subtype : Injective p.subtype :=\n  Subtype.coe_injective\n\n"}
{"name":"Submodule.coe_sum","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u\nM : Type v\nι : Type w\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\nx : ι → Subtype fun x => Membership.mem p x\ns : Finset ι\n⊢ Eq (↑(s.sum fun i => x i)) (s.sum fun i => ↑(x i))","decl":"/-- Note the `AddSubmonoid` version of this lemma is called `AddSubmonoid.coe_finset_sum`. -/\n-- Porting note: removing the `@[simp]` attribute since it's literally `AddSubmonoid.coe_finset_sum`\ntheorem coe_sum (x : ι → p) (s : Finset ι) : ↑(∑ i ∈ s, x i) = ∑ i ∈ s, (x i : M) :=\n  map_sum p.subtype _ _\n\n"}
{"name":"LinearMap.domRestrict_apply","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nf : LinearMap σ₁₂ M M₂\np : Submodule R M\nx : Subtype fun x => Membership.mem p x\n⊢ Eq ((f.domRestrict p) x) (f ↑x)","decl":"@[simp]\ntheorem domRestrict_apply (f : M →ₛₗ[σ₁₂] M₂) (p : Submodule R M) (x : p) :\n    f.domRestrict p x = f x :=\n  rfl\n\n"}
{"name":"LinearMap.codRestrict_apply","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\np : Submodule R₂ M₂\nf : LinearMap σ₁₂ M M₂\nh : ∀ (c : M), Membership.mem p (f c)\nx : M\n⊢ Eq (↑((LinearMap.codRestrict p f h) x)) (f x)","decl":"@[simp]\ntheorem codRestrict_apply (p : Submodule R₂ M₂) (f : M →ₛₗ[σ₁₂] M₂) {h} (x : M) :\n    (codRestrict p f h x : M₂) = f x :=\n  rfl\n\n"}
{"name":"LinearMap.comp_codRestrict","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u_1\nR₂ : Type u_3\nR₃ : Type u_4\nM : Type u_5\nM₂ : Type u_7\nM₃ : Type u_8\ninst✝⁹ : Semiring R\ninst✝⁸ : Semiring R₂\ninst✝⁷ : Semiring R₃\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\ninst✝¹ : Module R₃ M₃\nσ₁₂ : RingHom R R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R R₃\ninst✝ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\nf : LinearMap σ₁₂ M M₂\ng : LinearMap σ₂₃ M₂ M₃\np : Submodule R₃ M₃\nh : ∀ (b : M₂), Membership.mem p (g b)\n⊢ Eq ((LinearMap.codRestrict p g h).comp f) (LinearMap.codRestrict p (g.comp f) ⋯)","decl":"@[simp]\ntheorem comp_codRestrict (p : Submodule R₃ M₃) (h : ∀ b, g b ∈ p) :\n    ((codRestrict p g h).comp f : M →ₛₗ[σ₁₃] p) = codRestrict p (g.comp f) fun _ => h _ :=\n  ext fun _ => rfl\n\n"}
{"name":"LinearMap.subtype_comp_codRestrict","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nf : LinearMap σ₁₂ M M₂\np : Submodule R₂ M₂\nh : ∀ (b : M), Membership.mem p (f b)\n⊢ Eq (p.subtype.comp (LinearMap.codRestrict p f h)) f","decl":"@[simp]\ntheorem subtype_comp_codRestrict (p : Submodule R₂ M₂) (h : ∀ b, f b ∈ p) :\n    p.subtype.comp (codRestrict p f h) = f :=\n  ext fun _ => rfl\n\n"}
{"name":"LinearMap.restrict_coe_apply","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₁\ninst✝¹ : Module R M\ninst✝ : Module R M₁\nf : LinearMap (RingHom.id R) M M₁\np : Submodule R M\nq : Submodule R M₁\nhf : ∀ (x : M), Membership.mem p x → Membership.mem q (f x)\nx : Subtype fun x => Membership.mem p x\n⊢ Eq (↑((f.restrict hf) x)) (f ↑x)","decl":"@[simp]\ntheorem restrict_coe_apply (f : M →ₗ[R] M₁) {p : Submodule R M} {q : Submodule R M₁}\n    (hf : ∀ x ∈ p, f x ∈ q) (x : p) : ↑(f.restrict hf x) = f x :=\n  rfl\n\n"}
{"name":"LinearMap.restrict_apply","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₁\ninst✝¹ : Module R M\ninst✝ : Module R M₁\nf : LinearMap (RingHom.id R) M M₁\np : Submodule R M\nq : Submodule R M₁\nhf : ∀ (x : M), Membership.mem p x → Membership.mem q (f x)\nx : Subtype fun x => Membership.mem p x\n⊢ Eq ((f.restrict hf) x) ⟨f ↑x, ⋯⟩","decl":"theorem restrict_apply {f : M →ₗ[R] M₁} {p : Submodule R M} {q : Submodule R M₁}\n    (hf : ∀ x ∈ p, f x ∈ q) (x : p) : f.restrict hf x = ⟨f x, hf x.1 x.2⟩ :=\n  rfl\n\n"}
{"name":"LinearMap.restrict_sub","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u_10\nM : Type u_11\nM₁ : Type u_12\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup M₁\ninst✝¹ : Module R M\ninst✝ : Module R M₁\np : Submodule R M\nq : Submodule R M₁\nf g : LinearMap (RingHom.id R) M M₁\nhf : Set.MapsTo ⇑f ↑p ↑q\nhg : Set.MapsTo ⇑g ↑p ↑q\nhfg : optParam (Set.MapsTo ⇑(HSub.hSub f g) ↑p ↑q) ⋯\n⊢ Eq (HSub.hSub (f.restrict hf) (g.restrict hg)) ((HSub.hSub f g).restrict hfg)","decl":"lemma restrict_sub {R M M₁ : Type*}\n    [Ring R] [AddCommGroup M] [AddCommGroup M₁] [Module R M] [Module R M₁]\n    {p : Submodule R M} {q : Submodule R M₁} {f g : M →ₗ[R] M₁}\n    (hf : MapsTo f p q) (hg : MapsTo g p q)\n    (hfg : MapsTo (f - g) p q := fun _ hx ↦ q.sub_mem (hf hx) (hg hx)) :\n    f.restrict hf - g.restrict hg = (f - g).restrict hfg := by\n  ext; simp\n\n"}
{"name":"LinearMap.restrict_comp","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nM₂ : Type u_10\nM₃ : Type u_11\ninst✝³ : AddCommMonoid M₂\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\np : Submodule R M\np₂ : Submodule R M₂\np₃ : Submodule R M₃\nf : LinearMap (RingHom.id R) M M₂\ng : LinearMap (RingHom.id R) M₂ M₃\nhf : Set.MapsTo ⇑f ↑p ↑p₂\nhg : Set.MapsTo ⇑g ↑p₂ ↑p₃\nhfg : optParam (Set.MapsTo ⇑(g.comp f) ↑p ↑p₃) ⋯\n⊢ Eq ((g.comp f).restrict hfg) ((g.restrict hg).comp (f.restrict hf))","decl":"lemma restrict_comp\n    {M₂ M₃ : Type*} [AddCommMonoid M₂] [AddCommMonoid M₃] [Module R M₂] [Module R M₃]\n    {p : Submodule R M} {p₂ : Submodule R M₂} {p₃ : Submodule R M₃}\n    {f : M →ₗ[R] M₂} {g : M₂ →ₗ[R] M₃}\n    (hf : MapsTo f p p₂) (hg : MapsTo g p₂ p₃) (hfg : MapsTo (g ∘ₗ f) p p₃ := hg.comp hf) :\n    (g ∘ₗ f).restrict hfg = (g.restrict hg) ∘ₗ (f.restrict hf) :=\n  rfl\n\n-- TODO Consider defining `Algebra R (p.compatibleMaps p)`, `AlgHom` version of `LinearMap.restrict`\n"}
{"name":"LinearMap.restrict_smul_one","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u_10\nM : Type u_11\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\nμ : R\nh : optParam (∀ (x : M), Membership.mem p x → Membership.mem p ((HSMul.hSMul μ 1) x)) ⋯\n⊢ Eq (LinearMap.restrict (HSMul.hSMul μ 1) h) (HSMul.hSMul μ 1)","decl":"lemma restrict_smul_one\n    {R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M] {p : Submodule R M}\n    (μ : R) (h : ∀ x ∈ p, (μ • (1 : Module.End R M)) x ∈ p := fun _ ↦ p.smul_mem μ) :\n    (μ • 1 : Module.End R M).restrict h = μ • (1 : Module.End R p) :=\n  rfl\n\n"}
{"name":"LinearMap.restrict_commute","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf g : LinearMap (RingHom.id R) M M\nh : Commute f g\np : Submodule R M\nhf : Set.MapsTo ⇑f ↑p ↑p\nhg : Set.MapsTo ⇑g ↑p ↑p\n⊢ Commute (f.restrict hf) (g.restrict hg)","decl":"lemma restrict_commute {f g : M →ₗ[R] M} (h : Commute f g) {p : Submodule R M}\n    (hf : MapsTo f p p) (hg : MapsTo g p p) :\n    Commute (f.restrict hf) (g.restrict hg) := by\n  change _ * _ = _ * _\n  conv_lhs => rw [mul_eq_comp, ← restrict_comp]; congr; rw [← mul_eq_comp, h.eq]\n  rfl\n\n"}
{"name":"LinearMap.subtype_comp_restrict","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₁\ninst✝¹ : Module R M\ninst✝ : Module R M₁\nf : LinearMap (RingHom.id R) M M₁\np : Submodule R M\nq : Submodule R M₁\nhf : ∀ (x : M), Membership.mem p x → Membership.mem q (f x)\n⊢ Eq (q.subtype.comp (f.restrict hf)) (f.domRestrict p)","decl":"theorem subtype_comp_restrict {f : M →ₗ[R] M₁} {p : Submodule R M} {q : Submodule R M₁}\n    (hf : ∀ x ∈ p, f x ∈ q) : q.subtype.comp (f.restrict hf) = f.domRestrict p :=\n  rfl\n\n"}
{"name":"LinearMap.restrict_eq_codRestrict_domRestrict","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₁\ninst✝¹ : Module R M\ninst✝ : Module R M₁\nf : LinearMap (RingHom.id R) M M₁\np : Submodule R M\nq : Submodule R M₁\nhf : ∀ (x : M), Membership.mem p x → Membership.mem q (f x)\n⊢ Eq (f.restrict hf) (LinearMap.codRestrict q (f.domRestrict p) ⋯)","decl":"theorem restrict_eq_codRestrict_domRestrict {f : M →ₗ[R] M₁} {p : Submodule R M}\n    {q : Submodule R M₁} (hf : ∀ x ∈ p, f x ∈ q) :\n    f.restrict hf = (f.domRestrict p).codRestrict q fun x => hf x.1 x.2 :=\n  rfl\n\n"}
{"name":"LinearMap.restrict_eq_domRestrict_codRestrict","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₁\ninst✝¹ : Module R M\ninst✝ : Module R M₁\nf : LinearMap (RingHom.id R) M M₁\np : Submodule R M\nq : Submodule R M₁\nhf : ∀ (x : M), Membership.mem q (f x)\n⊢ Eq (f.restrict ⋯) ((LinearMap.codRestrict q f hf).domRestrict p)","decl":"theorem restrict_eq_domRestrict_codRestrict {f : M →ₗ[R] M₁} {p : Submodule R M}\n    {q : Submodule R M₁} (hf : ∀ x, f x ∈ q) :\n    (f.restrict fun x _ => hf x) = (f.codRestrict q hf).domRestrict p :=\n  rfl\n\n"}
{"name":"LinearMap.sum_apply","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\nι : Type u_9\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nt : Finset ι\nf : ι → LinearMap σ₁₂ M M₂\nb : M\n⊢ Eq ((t.sum fun d => f d) b) (t.sum fun d => (f d) b)","decl":"theorem sum_apply (t : Finset ι) (f : ι → M →ₛₗ[σ₁₂] M₂) (b : M) :\n    (∑ d ∈ t, f d) b = ∑ d ∈ t, f d b :=\n  _root_.map_sum ((AddMonoidHom.eval b).comp toAddMonoidHom') f _\n\n"}
{"name":"LinearMap.coeFn_sum","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nι : Type u_10\nt : Finset ι\nf : ι → LinearMap σ₁₂ M M₂\n⊢ Eq (⇑(t.sum fun i => f i)) (t.sum fun i => ⇑(f i))","decl":"@[simp, norm_cast]\ntheorem coeFn_sum {ι : Type*} (t : Finset ι) (f : ι → M →ₛₗ[σ₁₂] M₂) :\n    ⇑(∑ i ∈ t, f i) = ∑ i ∈ t, (f i : M → M₂) :=\n  _root_.map_sum\n    (show AddMonoidHom (M →ₛₗ[σ₁₂] M₂) (M → M₂)\n      from { toFun := DFunLike.coe,\n             map_zero' := rfl\n             map_add' := fun _ _ => rfl }) _ _\n\n"}
{"name":"LinearMap.submodule_pow_eq_zero_of_pow_eq_zero","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nN : Submodule R M\ng : Module.End R (Subtype fun x => Membership.mem N x)\nG : Module.End R M\nh : Eq (LinearMap.comp G N.subtype) (N.subtype.comp g)\nk : Nat\nhG : Eq (HPow.hPow G k) 0\n⊢ Eq (HPow.hPow g k) 0","decl":"theorem submodule_pow_eq_zero_of_pow_eq_zero {N : Submodule R M} {g : Module.End R N}\n    {G : Module.End R M} (h : G.comp N.subtype = N.subtype.comp g) {k : ℕ} (hG : G ^ k = 0) :\n    g ^ k = 0 := by\n  ext m\n  have hg : N.subtype.comp (g ^ k) m = 0 := by\n    rw [← commute_pow_left_of_commute h, hG, zero_comp, zero_apply]\n  simpa using hg\n\n"}
{"name":"LinearMap.pow_apply_mem_of_forall_mem","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf' : LinearMap (RingHom.id R) M M\np : Submodule R M\nn : Nat\nh : ∀ (x : M), Membership.mem p x → Membership.mem p (f' x)\nx : M\nhx : Membership.mem p x\n⊢ Membership.mem p ((HPow.hPow f' n) x)","decl":"theorem pow_apply_mem_of_forall_mem {p : Submodule R M} (n : ℕ) (h : ∀ x ∈ p, f' x ∈ p) (x : M)\n    (hx : x ∈ p) : (f' ^ n) x ∈ p := by\n  induction n generalizing x with\n  | zero => simpa\n  | succ n ih =>\n    simpa only [iterate_succ, coe_comp, Function.comp_apply, restrict_apply] using ih _ (h _ hx)\n\n"}
{"name":"LinearMap.pow_restrict","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf' : LinearMap (RingHom.id R) M M\np : Submodule R M\nn : Nat\nh : ∀ (x : M), Membership.mem p x → Membership.mem p (f' x)\nh' : optParam (∀ (x : M), Membership.mem p x → Membership.mem p ((HPow.hPow f' n) x)) ⋯\n⊢ Eq (HPow.hPow (f'.restrict h) n) ((HPow.hPow f' n).restrict h')","decl":"theorem pow_restrict {p : Submodule R M} (n : ℕ) (h : ∀ x ∈ p, f' x ∈ p)\n    (h' := pow_apply_mem_of_forall_mem n h) :\n    (f'.restrict h) ^ n = (f' ^ n).restrict h' := by\n  ext x\n  have : Semiconj (↑) (f'.restrict h) f' := fun _ ↦ restrict_coe_apply _ _ _\n  simp [coe_pow, this.iterate_right _ _]\n\n"}
{"name":"LinearMap.domRestrict'_apply","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u_1\nM : Type u_5\nM₂ : Type u_7\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nf : LinearMap (RingHom.id R) M M₂\np : Submodule R M\nx : Subtype fun x => Membership.mem p x\n⊢ Eq (((LinearMap.domRestrict' p) f) x) (f ↑x)","decl":"@[simp]\ntheorem domRestrict'_apply (f : M →ₗ[R] M₂) (p : Submodule R M) (x : p) :\n    domRestrict' p f x = f x :=\n  rfl\n\n"}
{"name":"Submodule.coe_inclusion","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np p' : Submodule R M\nh : LE.le p p'\nx : Subtype fun x => Membership.mem p x\n⊢ Eq ↑((Submodule.inclusion h) x) ↑x","decl":"@[simp]\ntheorem coe_inclusion (h : p ≤ p') (x : p) : (inclusion h x : M) = x :=\n  rfl\n\n"}
{"name":"Submodule.inclusion_apply","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np p' : Submodule R M\nh : LE.le p p'\nx : Subtype fun x => Membership.mem p x\n⊢ Eq ((Submodule.inclusion h) x) ⟨↑x, ⋯⟩","decl":"theorem inclusion_apply (h : p ≤ p') (x : p) : inclusion h x = ⟨x, h x.2⟩ :=\n  rfl\n\n"}
{"name":"Submodule.inclusion_injective","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np p' : Submodule R M\nh : LE.le p p'\n⊢ Function.Injective ⇑(Submodule.inclusion h)","decl":"theorem inclusion_injective (h : p ≤ p') : Function.Injective (inclusion h) := fun _ _ h =>\n  Subtype.val_injective (Subtype.mk.inj h)\n\n"}
{"name":"Submodule.subtype_comp_inclusion","module":"Mathlib.Algebra.Module.Submodule.LinearMap","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np q : Submodule R M\nh : LE.le p q\n⊢ Eq (q.subtype.comp (Submodule.inclusion h)) p.subtype","decl":"theorem subtype_comp_inclusion (p q : Submodule R M) (h : p ≤ q) :\n    q.subtype.comp (inclusion h) = p.subtype := by\n  ext ⟨b, hb⟩\n  rfl\n\n"}
