{"name":"Nat.card_eq","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_4\n⊢ Eq (Nat.card α) (dite (Finite α) (fun x => Fintype.card α) fun x => 0)","decl":"open scoped Classical in\ntheorem Nat.card_eq (α : Type*) :\n    Nat.card α = if _ : Finite α then @Fintype.card α (Fintype.ofFinite α) else 0 := by\n  cases finite_or_infinite α\n  · letI := Fintype.ofFinite α\n    simp only [this, *, Nat.card_eq_fintype_card, dif_pos]\n  · simp only [*, card_eq_zero_of_infinite, not_finite_iff_infinite.mpr, dite_false]\n\n"}
{"name":"Finite.card_pos_iff","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\ninst✝ : Finite α\n⊢ Iff (LT.lt 0 (Nat.card α)) (Nonempty α)","decl":"theorem Finite.card_pos_iff [Finite α] : 0 < Nat.card α ↔ Nonempty α := by\n  haveI := Fintype.ofFinite α\n  rw [Nat.card_eq_fintype_card, Fintype.card_pos_iff]\n\n"}
{"name":"Finite.card_pos","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\ninst✝ : Finite α\nh : Nonempty α\n⊢ LT.lt 0 (Nat.card α)","decl":"theorem Finite.card_pos [Finite α] [h : Nonempty α] : 0 < Nat.card α :=\n  Finite.card_pos_iff.mpr h\n\n"}
{"name":"Finite.cast_card_eq_mk","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_4\ninst✝ : Finite α\n⊢ Eq (↑(Nat.card α)) (Cardinal.mk α)","decl":"theorem cast_card_eq_mk {α : Type*} [Finite α] : ↑(Nat.card α) = Cardinal.mk α :=\n  Cardinal.cast_toNat_of_lt_aleph0 (Cardinal.lt_aleph0_of_finite α)\n\n"}
{"name":"Finite.card_eq","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Finite α\ninst✝ : Finite β\n⊢ Iff (Eq (Nat.card α) (Nat.card β)) (Nonempty (Equiv α β))","decl":"theorem card_eq [Finite α] [Finite β] : Nat.card α = Nat.card β ↔ Nonempty (α ≃ β) := by\n  haveI := Fintype.ofFinite α\n  haveI := Fintype.ofFinite β\n  simp only [Nat.card_eq_fintype_card, Fintype.card_eq]\n\n"}
{"name":"Finite.card_le_one_iff_subsingleton","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\ninst✝ : Finite α\n⊢ Iff (LE.le (Nat.card α) 1) (Subsingleton α)","decl":"theorem card_le_one_iff_subsingleton [Finite α] : Nat.card α ≤ 1 ↔ Subsingleton α := by\n  haveI := Fintype.ofFinite α\n  simp only [Nat.card_eq_fintype_card, Fintype.card_le_one_iff_subsingleton]\n\n"}
{"name":"Finite.one_lt_card_iff_nontrivial","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\ninst✝ : Finite α\n⊢ Iff (LT.lt 1 (Nat.card α)) (Nontrivial α)","decl":"theorem one_lt_card_iff_nontrivial [Finite α] : 1 < Nat.card α ↔ Nontrivial α := by\n  haveI := Fintype.ofFinite α\n  simp only [Nat.card_eq_fintype_card, Fintype.one_lt_card_iff_nontrivial]\n\n"}
{"name":"Finite.one_lt_card","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\ninst✝ : Finite α\nh : Nontrivial α\n⊢ LT.lt 1 (Nat.card α)","decl":"theorem one_lt_card [Finite α] [h : Nontrivial α] : 1 < Nat.card α :=\n  one_lt_card_iff_nontrivial.mpr h\n\n"}
{"name":"Finite.card_option","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\ninst✝ : Finite α\n⊢ Eq (Nat.card (Option α)) (HAdd.hAdd (Nat.card α) 1)","decl":"@[simp]\ntheorem card_option [Finite α] : Nat.card (Option α) = Nat.card α + 1 := by\n  haveI := Fintype.ofFinite α\n  simp only [Nat.card_eq_fintype_card, Fintype.card_option]\n\n"}
{"name":"Finite.card_le_of_injective","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Finite β\nf : α → β\nhf : Function.Injective f\n⊢ LE.le (Nat.card α) (Nat.card β)","decl":"theorem card_le_of_injective [Finite β] (f : α → β) (hf : Function.Injective f) :\n    Nat.card α ≤ Nat.card β := by\n  haveI := Fintype.ofFinite β\n  haveI := Fintype.ofInjective f hf\n  simpa only [Nat.card_eq_fintype_card] using Fintype.card_le_of_injective f hf\n\n"}
{"name":"Finite.card_le_of_embedding","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Finite β\nf : Function.Embedding α β\n⊢ LE.le (Nat.card α) (Nat.card β)","decl":"theorem card_le_of_embedding [Finite β] (f : α ↪ β) : Nat.card α ≤ Nat.card β :=\n  card_le_of_injective _ f.injective\n\n"}
{"name":"Finite.card_le_of_surjective","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Finite α\nf : α → β\nhf : Function.Surjective f\n⊢ LE.le (Nat.card β) (Nat.card α)","decl":"theorem card_le_of_surjective [Finite α] (f : α → β) (hf : Function.Surjective f) :\n    Nat.card β ≤ Nat.card α := by\n  classical\n  haveI := Fintype.ofFinite α\n  haveI := Fintype.ofSurjective f hf\n  simpa only [Nat.card_eq_fintype_card] using Fintype.card_le_of_surjective f hf\n\n"}
{"name":"Finite.card_eq_zero_iff","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\ninst✝ : Finite α\n⊢ Iff (Eq (Nat.card α) 0) (IsEmpty α)","decl":"theorem card_eq_zero_iff [Finite α] : Nat.card α = 0 ↔ IsEmpty α := by\n  haveI := Fintype.ofFinite α\n  simp only [Nat.card_eq_fintype_card, Fintype.card_eq_zero_iff]\n\n"}
{"name":"Finite.card_le_of_injective'","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\nh : Eq (Nat.card β) 0 → Eq (Nat.card α) 0\n⊢ LE.le (Nat.card α) (Nat.card β)","decl":"/-- If `f` is injective, then `Nat.card α ≤ Nat.card β`. We must also assume\n  `Nat.card β = 0 → Nat.card α = 0` since `Nat.card` is defined to be `0` for infinite types. -/\ntheorem card_le_of_injective' {f : α → β} (hf : Function.Injective f)\n    (h : Nat.card β = 0 → Nat.card α = 0) : Nat.card α ≤ Nat.card β :=\n  (or_not_of_imp h).casesOn (fun h => le_of_eq_of_le h (Nat.zero_le _)) fun h =>\n    @card_le_of_injective α β (Nat.finite_of_card_ne_zero h) f hf\n\n"}
{"name":"Finite.card_le_of_embedding'","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\nh : Eq (Nat.card β) 0 → Eq (Nat.card α) 0\n⊢ LE.le (Nat.card α) (Nat.card β)","decl":"/-- If `f` is an embedding, then `Nat.card α ≤ Nat.card β`. We must also assume\n  `Nat.card β = 0 → Nat.card α = 0` since `Nat.card` is defined to be `0` for infinite types. -/\ntheorem card_le_of_embedding' (f : α ↪ β) (h : Nat.card β = 0 → Nat.card α = 0) :\n    Nat.card α ≤ Nat.card β :=\n  card_le_of_injective' f.2 h\n\n"}
{"name":"Finite.card_le_of_surjective'","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Surjective f\nh : Eq (Nat.card α) 0 → Eq (Nat.card β) 0\n⊢ LE.le (Nat.card β) (Nat.card α)","decl":"/-- If `f` is surjective, then `Nat.card β ≤ Nat.card α`. We must also assume\n  `Nat.card α = 0 → Nat.card β = 0` since `Nat.card` is defined to be `0` for infinite types. -/\ntheorem card_le_of_surjective' {f : α → β} (hf : Function.Surjective f)\n    (h : Nat.card α = 0 → Nat.card β = 0) : Nat.card β ≤ Nat.card α :=\n  (or_not_of_imp h).casesOn (fun h => le_of_eq_of_le h (Nat.zero_le _)) fun h =>\n    @card_le_of_surjective α β (Nat.finite_of_card_ne_zero h) f hf\n\n"}
{"name":"Finite.card_eq_zero_of_surjective","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Surjective f\nh : Eq (Nat.card β) 0\n⊢ Eq (Nat.card α) 0","decl":"/-- NB: `Nat.card` is defined to be `0` for infinite types. -/\ntheorem card_eq_zero_of_surjective {f : α → β} (hf : Function.Surjective f) (h : Nat.card β = 0) :\n    Nat.card α = 0 := by\n  cases finite_or_infinite β\n  · haveI := card_eq_zero_iff.mp h\n    haveI := Function.isEmpty f\n    exact Nat.card_of_isEmpty\n  · haveI := Infinite.of_surjective f hf\n    exact Nat.card_eq_zero_of_infinite\n\n"}
{"name":"Finite.card_eq_zero_of_injective","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Nonempty α\nf : α → β\nhf : Function.Injective f\nh : Eq (Nat.card α) 0\n⊢ Eq (Nat.card β) 0","decl":"/-- NB: `Nat.card` is defined to be `0` for infinite types. -/\ntheorem card_eq_zero_of_injective [Nonempty α] {f : α → β} (hf : Function.Injective f)\n    (h : Nat.card α = 0) : Nat.card β = 0 :=\n  card_eq_zero_of_surjective (Function.invFun_surjective hf) h\n\n"}
{"name":"Finite.card_eq_zero_of_embedding","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Nonempty α\nf : Function.Embedding α β\nh : Eq (Nat.card α) 0\n⊢ Eq (Nat.card β) 0","decl":"/-- NB: `Nat.card` is defined to be `0` for infinite types. -/\ntheorem card_eq_zero_of_embedding [Nonempty α] (f : α ↪ β) (h : Nat.card α = 0) : Nat.card β = 0 :=\n  card_eq_zero_of_injective f.2 h\n\n"}
{"name":"Finite.card_sum","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Finite α\ninst✝ : Finite β\n⊢ Eq (Nat.card (Sum α β)) (HAdd.hAdd (Nat.card α) (Nat.card β))","decl":"theorem card_sum [Finite α] [Finite β] : Nat.card (α ⊕ β) = Nat.card α + Nat.card β := by\n  haveI := Fintype.ofFinite α\n  haveI := Fintype.ofFinite β\n  simp only [Nat.card_eq_fintype_card, Fintype.card_sum]\n\n"}
{"name":"Finite.card_image_le","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\ninst✝ : Finite ↑s\nf : α → β\n⊢ LE.le (Nat.card ↑(Set.image f s)) (Nat.card ↑s)","decl":"theorem card_image_le {s : Set α} [Finite s] (f : α → β) : Nat.card (f '' s) ≤ Nat.card s :=\n  card_le_of_surjective _ Set.surjective_onto_image\n\n"}
{"name":"Finite.card_range_le","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Finite α\nf : α → β\n⊢ LE.le (Nat.card ↑(Set.range f)) (Nat.card α)","decl":"theorem card_range_le [Finite α] (f : α → β) : Nat.card (Set.range f) ≤ Nat.card α :=\n  card_le_of_surjective _ Set.surjective_onto_range\n\n"}
{"name":"Finite.card_subtype_le","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\ninst✝ : Finite α\np : α → Prop\n⊢ LE.le (Nat.card (Subtype fun x => p x)) (Nat.card α)","decl":"theorem card_subtype_le [Finite α] (p : α → Prop) : Nat.card { x // p x } ≤ Nat.card α := by\n  classical\n  haveI := Fintype.ofFinite α\n  simpa only [Nat.card_eq_fintype_card] using Fintype.card_subtype_le p\n\n"}
{"name":"Finite.card_subtype_lt","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\ninst✝ : Finite α\np : α → Prop\nx : α\nhx : Not (p x)\n⊢ LT.lt (Nat.card (Subtype fun x => p x)) (Nat.card α)","decl":"theorem card_subtype_lt [Finite α] {p : α → Prop} {x : α} (hx : ¬p x) :\n    Nat.card { x // p x } < Nat.card α := by\n  classical\n  haveI := Fintype.ofFinite α\n  simpa only [Nat.card_eq_fintype_card, gt_iff_lt] using Fintype.card_subtype_lt hx\n\n"}
{"name":"ENat.card_eq_coe_natCard","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_4\ninst✝ : Finite α\n⊢ Eq (ENat.card α) ↑(Nat.card α)","decl":"theorem card_eq_coe_natCard (α : Type*) [Finite α] : card α = Nat.card α := by\n  unfold ENat.card\n  apply symm\n  rw [Cardinal.natCast_eq_toENat_iff]\n  exact Finite.cast_card_eq_mk\n\n"}
{"name":"Set.card_union_le","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\ns t : Set α\n⊢ LE.le (Nat.card ↑(Union.union s t)) (HAdd.hAdd (Nat.card ↑s) (Nat.card ↑t))","decl":"theorem card_union_le (s t : Set α) : Nat.card (↥(s ∪ t)) ≤ Nat.card s + Nat.card t := by\n  cases' _root_.finite_or_infinite (↥(s ∪ t)) with h h\n  · rw [finite_coe_iff, finite_union, ← finite_coe_iff, ← finite_coe_iff] at h\n    cases h\n    rw [← @Nat.cast_le Cardinal, Nat.cast_add, Finite.cast_card_eq_mk, Finite.cast_card_eq_mk,\n      Finite.cast_card_eq_mk]\n    exact Cardinal.mk_union_le s t\n  · exact Nat.card_eq_zero_of_infinite.trans_le (zero_le _)\n\n"}
{"name":"Set.Finite.card_lt_card","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\ns t : Set α\nht : t.Finite\nhsub : HasSSubset.SSubset s t\n⊢ LT.lt (Nat.card ↑s) (Nat.card ↑t)","decl":"theorem card_lt_card (ht : t.Finite) (hsub : s ⊂ t) : Nat.card s < Nat.card t := by\n  have : Fintype t := Finite.fintype ht\n  have : Fintype s := Finite.fintype (subset ht (subset_of_ssubset hsub))\n  simp only [Nat.card_eq_fintype_card]\n  exact Set.card_lt_card hsub\n\n"}
{"name":"Set.Finite.eq_of_subset_of_card_le","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\ns t : Set α\nht : t.Finite\nhsub : HasSubset.Subset s t\nhcard : LE.le (Nat.card ↑t) (Nat.card ↑s)\n⊢ Eq s t","decl":"theorem eq_of_subset_of_card_le (ht : t.Finite) (hsub : s ⊆ t) (hcard : Nat.card t ≤ Nat.card s) :\n    s = t :=\n  (eq_or_ssubset_of_subset hsub).elim id fun h ↦ absurd hcard <| not_le_of_lt <| ht.card_lt_card h\n\n"}
{"name":"Set.Finite.equiv_image_eq_iff_subset","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\ns : Set α\ne : Equiv α α\nhs : s.Finite\n⊢ Iff (Eq (Set.image (⇑e) s) s) (HasSubset.Subset (Set.image (⇑e) s) s)","decl":"theorem equiv_image_eq_iff_subset (e : α ≃ α) (hs : s.Finite) : e '' s = s ↔ e '' s ⊆ s :=\n  ⟨fun h ↦ by rw [h], fun h ↦ hs.eq_of_subset_of_card_le h <|\n    ge_of_eq (Nat.card_congr (e.image s).symm)⟩\n\n"}
{"name":"Set.eq_top_of_card_le_of_finite","module":"Mathlib.Data.Finite.Card","initialProofState":"α : Type u_1\ninst✝ : Finite α\ns : Set α\nh : LE.le (Nat.card α) (Nat.card ↑s)\n⊢ Eq s Top.top","decl":"theorem eq_top_of_card_le_of_finite [Finite α] {s : Set α} (h : Nat.card α ≤ Nat.card s) : s = ⊤ :=\n  Set.Finite.eq_of_subset_of_card_le univ.toFinite (subset_univ s) <|\n    Nat.card_congr (Equiv.Set.univ α) ▸ h\n\n"}
