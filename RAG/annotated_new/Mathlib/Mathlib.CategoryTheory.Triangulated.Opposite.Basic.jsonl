{"name":"CategoryTheory.Pretriangulated.Opposite.instAdditiveOppositeShiftFunctorInt","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.HasShift C Int\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : ‚àÄ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nn : Int\n‚ä¢ (CategoryTheory.shiftFunctor (Opposite C) n).Additive","decl":"instance [Preadditive C] [‚àÄ (n : ‚Ñ§), (shiftFunctor C n).Additive] (n : ‚Ñ§) :\n    (shiftFunctor C·µí·µñ n).Additive :=\n  (inferInstance : (shiftFunctor (OppositeShiftAux C) n).Additive)\n\n"}
{"name":"CategoryTheory.Pretriangulated.shiftFunctorZero_op_hom_app","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nX : Opposite C\n‚ä¢ Eq ((CategoryTheory.shiftFunctorZero (Opposite C) Int).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.shiftFunctorOpIso C 0 0 ‚ãØ).hom.app X) ((CategoryTheory.shiftFunctorZero C Int).inv.app (Opposite.unop X)).op)","decl":"lemma shiftFunctorZero_op_hom_app (X : C·µí·µñ) :\n    (shiftFunctorZero C·µí·µñ ‚Ñ§).hom.app X = (shiftFunctorOpIso C 0 0 (zero_add 0)).hom.app X ‚â´\n      ((shiftFunctorZero C ‚Ñ§).inv.app X.unop).op := by\n  erw [@pullbackShiftFunctorZero_hom_app (OppositeShift C ‚Ñ§), oppositeShiftFunctorZero_hom_app]\n  rfl\n\n"}
{"name":"CategoryTheory.Pretriangulated.shiftFunctorZero_op_inv_app","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nX : Opposite C\n‚ä¢ Eq ((CategoryTheory.shiftFunctorZero (Opposite C) Int).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorZero C Int).hom.app (Opposite.unop X)).op ((CategoryTheory.Pretriangulated.shiftFunctorOpIso C 0 0 ‚ãØ).inv.app X))","decl":"lemma shiftFunctorZero_op_inv_app (X : C·µí·µñ) :\n    (shiftFunctorZero C·µí·µñ ‚Ñ§).inv.app X =\n      ((shiftFunctorZero C ‚Ñ§).hom.app X.unop).op ‚â´\n      (shiftFunctorOpIso C 0 0 (zero_add 0)).inv.app X := by\n  rw [‚Üê cancel_epi ((shiftFunctorZero C·µí·µñ ‚Ñ§).hom.app X), Iso.hom_inv_id_app,\n    shiftFunctorZero_op_hom_app, assoc, ‚Üê op_comp_assoc, Iso.hom_inv_id_app, op_id,\n    id_comp, Iso.hom_inv_id_app]\n\n"}
{"name":"CategoryTheory.Pretriangulated.shiftFunctorAdd'_op_hom_app","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nX : Opposite C\na‚ÇÅ a‚ÇÇ a‚ÇÉ : Int\nh : Eq (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÉ\nb‚ÇÅ b‚ÇÇ b‚ÇÉ : Int\nh‚ÇÅ : Eq (HAdd.hAdd a‚ÇÅ b‚ÇÅ) 0\nh‚ÇÇ : Eq (HAdd.hAdd a‚ÇÇ b‚ÇÇ) 0\nh‚ÇÉ : Eq (HAdd.hAdd a‚ÇÉ b‚ÇÉ) 0\n‚ä¢ Eq ((CategoryTheory.shiftFunctorAdd' (Opposite C) a‚ÇÅ a‚ÇÇ a‚ÇÉ h).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.shiftFunctorOpIso C a‚ÇÉ b‚ÇÉ h‚ÇÉ).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C b‚ÇÅ b‚ÇÇ b‚ÇÉ ‚ãØ).inv.app (Opposite.unop X)).op (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.shiftFunctorOpIso C a‚ÇÇ b‚ÇÇ h‚ÇÇ).inv.app { unop := (CategoryTheory.shiftFunctor C b‚ÇÅ).toPrefunctor.1 (Opposite.unop X) }) ((CategoryTheory.shiftFunctor (Opposite C) a‚ÇÇ).map ((CategoryTheory.Pretriangulated.shiftFunctorOpIso C a‚ÇÅ b‚ÇÅ h‚ÇÅ).inv.app X)))))","decl":"lemma shiftFunctorAdd'_op_hom_app (X : C·µí·µñ) (a‚ÇÅ a‚ÇÇ a‚ÇÉ : ‚Ñ§) (h : a‚ÇÅ + a‚ÇÇ = a‚ÇÉ)\n    (b‚ÇÅ b‚ÇÇ b‚ÇÉ : ‚Ñ§) (h‚ÇÅ : a‚ÇÅ + b‚ÇÅ = 0) (h‚ÇÇ : a‚ÇÇ + b‚ÇÇ = 0) (h‚ÇÉ : a‚ÇÉ + b‚ÇÉ = 0) :\n    (shiftFunctorAdd' C·µí·µñ a‚ÇÅ a‚ÇÇ a‚ÇÉ h).hom.app X =\n      (shiftFunctorOpIso C _ _ h‚ÇÉ).hom.app X ‚â´\n        ((shiftFunctorAdd' C b‚ÇÅ b‚ÇÇ b‚ÇÉ (by omega)).inv.app X.unop).op ‚â´\n        (shiftFunctorOpIso C _ _ h‚ÇÇ).inv.app _ ‚â´\n        (shiftFunctor C·µí·µñ a‚ÇÇ).map ((shiftFunctorOpIso C _ _ h‚ÇÅ).inv.app X) := by\n  erw [@pullbackShiftFunctorAdd'_hom_app (OppositeShift C ‚Ñ§) _ _ _ _ _ _ _ X\n    a‚ÇÅ a‚ÇÇ a‚ÇÉ h b‚ÇÅ b‚ÇÇ b‚ÇÉ (by dsimp; omega) (by dsimp; omega) (by dsimp; omega)]\n  rw [oppositeShiftFunctorAdd'_hom_app]\n  rfl\n\n"}
{"name":"CategoryTheory.Pretriangulated.shiftFunctorAdd'_op_inv_app","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nX : Opposite C\na‚ÇÅ a‚ÇÇ a‚ÇÉ : Int\nh : Eq (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÉ\nb‚ÇÅ b‚ÇÇ b‚ÇÉ : Int\nh‚ÇÅ : Eq (HAdd.hAdd a‚ÇÅ b‚ÇÅ) 0\nh‚ÇÇ : Eq (HAdd.hAdd a‚ÇÇ b‚ÇÇ) 0\nh‚ÇÉ : Eq (HAdd.hAdd a‚ÇÉ b‚ÇÉ) 0\n‚ä¢ Eq ((CategoryTheory.shiftFunctorAdd' (Opposite C) a‚ÇÅ a‚ÇÇ a‚ÇÉ h).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (Opposite C) a‚ÇÇ).map ((CategoryTheory.Pretriangulated.shiftFunctorOpIso C a‚ÇÅ b‚ÇÅ h‚ÇÅ).hom.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.shiftFunctorOpIso C a‚ÇÇ b‚ÇÇ h‚ÇÇ).hom.app ((CategoryTheory.shiftFunctor C b‚ÇÅ).op.obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C b‚ÇÅ b‚ÇÇ b‚ÇÉ ‚ãØ).hom.app (Opposite.unop X)).op ((CategoryTheory.Pretriangulated.shiftFunctorOpIso C a‚ÇÉ b‚ÇÉ h‚ÇÉ).inv.app X))))","decl":"lemma shiftFunctorAdd'_op_inv_app (X : C·µí·µñ) (a‚ÇÅ a‚ÇÇ a‚ÇÉ : ‚Ñ§) (h : a‚ÇÅ + a‚ÇÇ = a‚ÇÉ)\n    (b‚ÇÅ b‚ÇÇ b‚ÇÉ : ‚Ñ§) (h‚ÇÅ : a‚ÇÅ + b‚ÇÅ = 0) (h‚ÇÇ : a‚ÇÇ + b‚ÇÇ = 0) (h‚ÇÉ : a‚ÇÉ + b‚ÇÉ = 0) :\n    (shiftFunctorAdd' C·µí·µñ a‚ÇÅ a‚ÇÇ a‚ÇÉ h).inv.app X =\n      (shiftFunctor C·µí·µñ a‚ÇÇ).map ((shiftFunctorOpIso C _ _ h‚ÇÅ).hom.app X) ‚â´\n      (shiftFunctorOpIso C _ _ h‚ÇÇ).hom.app _ ‚â´\n      ((shiftFunctorAdd' C b‚ÇÅ b‚ÇÇ b‚ÇÉ (by omega)).hom.app X.unop).op ‚â´\n      (shiftFunctorOpIso C _ _ h‚ÇÉ).inv.app X := by\n  rw [‚Üê cancel_epi ((shiftFunctorAdd' C·µí·µñ a‚ÇÅ a‚ÇÇ a‚ÇÉ h).hom.app X), Iso.hom_inv_id_app,\n    shiftFunctorAdd'_op_hom_app X a‚ÇÅ a‚ÇÇ a‚ÇÉ h b‚ÇÅ b‚ÇÇ b‚ÇÉ h‚ÇÅ h‚ÇÇ h‚ÇÉ,\n    assoc, assoc, assoc, ‚Üê Functor.map_comp_assoc, Iso.inv_hom_id_app]\n  erw [Functor.map_id, id_comp, Iso.inv_hom_id_app_assoc]\n  rw [‚Üê op_comp_assoc, Iso.hom_inv_id_app, op_id, id_comp, Iso.hom_inv_id_app]\n\n"}
{"name":"CategoryTheory.Pretriangulated.shiftFunctor_op_map","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nn m : Int\nhnm : Eq (HAdd.hAdd n m) 0\nK L : Opposite C\nœÜ : Quiver.Hom K L\n‚ä¢ Eq ((CategoryTheory.shiftFunctor (Opposite C) n).map œÜ) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.shiftFunctorOpIso C n m hnm).hom.app K) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C m).map œÜ.unop).op ((CategoryTheory.Pretriangulated.shiftFunctorOpIso C n m hnm).inv.app L)))","decl":"lemma shiftFunctor_op_map (n m : ‚Ñ§) (hnm : n + m = 0) {K L : C·µí·µñ} (œÜ : K ‚ü∂ L) :\n    (shiftFunctor C·µí·µñ n).map œÜ =\n      (shiftFunctorOpIso C n m hnm).hom.app K ‚â´ ((shiftFunctor C m).map œÜ.unop).op ‚â´\n        (shiftFunctorOpIso C n m hnm).inv.app L :=\n  (NatIso.naturality_2 (shiftFunctorOpIso C n m hnm) œÜ).symm\n\n"}
{"name":"CategoryTheory.Pretriangulated.opShiftFunctorEquivalence_functor","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nn : Int\n‚ä¢ Eq (CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).functor (CategoryTheory.shiftFunctor (Opposite C) n)","decl":"variable (C) in\n/-- The autoequivalence `C·µí·µñ ‚âå C·µí·µñ` whose functor is `shiftFunctor C·µí·µñ n` and whose inverse\nfunctor is `(shiftFunctor C n).op`. Do not unfold the definitions of the unit and counit\nisomorphisms: the compatibilities they satisfy are stated as separate lemmas. -/\n@[simps functor inverse]\nnoncomputable def opShiftFunctorEquivalence (n : ‚Ñ§) : C·µí·µñ ‚âå C·µí·µñ where\n  functor := shiftFunctor C·µí·µñ n\n  inverse := (shiftFunctor C n).op\n  unitIso := NatIso.op (shiftFunctorCompIsoId C (-n) n n.add_left_neg) ‚â™‚â´\n    isoWhiskerRight (shiftFunctorOpIso C n (-n) n.add_right_neg).symm (shiftFunctor C n).op\n  counitIso := isoWhiskerLeft _ (shiftFunctorOpIso C n (-n) n.add_right_neg) ‚â™‚â´\n    NatIso.op (shiftFunctorCompIsoId C n (-n) n.add_right_neg).symm\n  functor_unitIso_comp X := Quiver.Hom.unop_inj (by\n    dsimp [shiftFunctorOpIso]\n    erw [comp_id, Functor.map_id, comp_id]\n    change (shiftFunctorCompIsoId C n (-n) (add_neg_cancel n)).inv.app (X.unop‚ü¶-n‚üß) ‚â´\n      ((shiftFunctorCompIsoId C (-n) n (neg_add_cancel n)).hom.app X.unop)‚ü¶-n‚üß' = ùüô _\n    rw [shift_shiftFunctorCompIsoId_neg_add_cancel_hom_app n X.unop, Iso.inv_hom_id_app])\n\n"}
{"name":"CategoryTheory.Pretriangulated.opShiftFunctorEquivalence_inverse","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nn : Int\n‚ä¢ Eq (CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).inverse (CategoryTheory.shiftFunctor C n).op","decl":"variable (C) in\n/-- The autoequivalence `C·µí·µñ ‚âå C·µí·µñ` whose functor is `shiftFunctor C·µí·µñ n` and whose inverse\nfunctor is `(shiftFunctor C n).op`. Do not unfold the definitions of the unit and counit\nisomorphisms: the compatibilities they satisfy are stated as separate lemmas. -/\n@[simps functor inverse]\nnoncomputable def opShiftFunctorEquivalence (n : ‚Ñ§) : C·µí·µñ ‚âå C·µí·µñ where\n  functor := shiftFunctor C·µí·µñ n\n  inverse := (shiftFunctor C n).op\n  unitIso := NatIso.op (shiftFunctorCompIsoId C (-n) n n.add_left_neg) ‚â™‚â´\n    isoWhiskerRight (shiftFunctorOpIso C n (-n) n.add_right_neg).symm (shiftFunctor C n).op\n  counitIso := isoWhiskerLeft _ (shiftFunctorOpIso C n (-n) n.add_right_neg) ‚â™‚â´\n    NatIso.op (shiftFunctorCompIsoId C n (-n) n.add_right_neg).symm\n  functor_unitIso_comp X := Quiver.Hom.unop_inj (by\n    dsimp [shiftFunctorOpIso]\n    erw [comp_id, Functor.map_id, comp_id]\n    change (shiftFunctorCompIsoId C n (-n) (add_neg_cancel n)).inv.app (X.unop‚ü¶-n‚üß) ‚â´\n      ((shiftFunctorCompIsoId C (-n) n (neg_add_cancel n)).hom.app X.unop)‚ü¶-n‚üß' = ùüô _\n    rw [shift_shiftFunctorCompIsoId_neg_add_cancel_hom_app n X.unop, Iso.inv_hom_id_app])\n\n"}
{"name":"CategoryTheory.Pretriangulated.opShiftFunctorEquivalence_unitIso_hom_naturality_assoc","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nn : Int\nX Y : Opposite C\nf : Quiver.Hom X Y\nZ : Opposite C\nh : Quiver.Hom ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).inverse.obj ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).functor.obj Y)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).unitIso.hom.app Y) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).unitIso.hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C n).map ((CategoryTheory.shiftFunctor (Opposite C) n).map f).unop).op h))","decl":"@[reassoc (attr := simp)]\nlemma opShiftFunctorEquivalence_unitIso_hom_naturality (n : ‚Ñ§) {X Y : C·µí·µñ} (f : X ‚ü∂ Y) :\n    f ‚â´ (opShiftFunctorEquivalence C n).unitIso.hom.app Y =\n      (opShiftFunctorEquivalence C n).unitIso.hom.app X ‚â´ (f‚ü¶n‚üß').unop‚ü¶n‚üß'.op :=\n  (opShiftFunctorEquivalence C n).unitIso.hom.naturality f\n\n"}
{"name":"CategoryTheory.Pretriangulated.opShiftFunctorEquivalence_unitIso_hom_naturality","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nn : Int\nX Y : Opposite C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).unitIso.hom.app Y)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).unitIso.hom.app X) ((CategoryTheory.shiftFunctor C n).map ((CategoryTheory.shiftFunctor (Opposite C) n).map f).unop).op)","decl":"@[reassoc (attr := simp)]\nlemma opShiftFunctorEquivalence_unitIso_hom_naturality (n : ‚Ñ§) {X Y : C·µí·µñ} (f : X ‚ü∂ Y) :\n    f ‚â´ (opShiftFunctorEquivalence C n).unitIso.hom.app Y =\n      (opShiftFunctorEquivalence C n).unitIso.hom.app X ‚â´ (f‚ü¶n‚üß').unop‚ü¶n‚üß'.op :=\n  (opShiftFunctorEquivalence C n).unitIso.hom.naturality f\n\n"}
{"name":"CategoryTheory.Pretriangulated.opShiftFunctorEquivalence_unitIso_inv_naturality","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nn : Int\nX Y : Opposite C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C n).map ((CategoryTheory.shiftFunctor (Opposite C) n).map f).unop).op ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).unitIso.inv.app Y)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).unitIso.inv.app X) f)","decl":"@[reassoc (attr := simp)]\nlemma opShiftFunctorEquivalence_unitIso_inv_naturality (n : ‚Ñ§) {X Y : C·µí·µñ} (f : X ‚ü∂ Y) :\n    (f‚ü¶n‚üß').unop‚ü¶n‚üß'.op ‚â´ (opShiftFunctorEquivalence C n).unitIso.inv.app Y =\n      (opShiftFunctorEquivalence C n).unitIso.inv.app X ‚â´ f :=\n  (opShiftFunctorEquivalence C n).unitIso.inv.naturality f\n\n"}
{"name":"CategoryTheory.Pretriangulated.opShiftFunctorEquivalence_unitIso_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nn : Int\nX Y : Opposite C\nf : Quiver.Hom X Y\nZ : Opposite C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C n).map ((CategoryTheory.shiftFunctor (Opposite C) n).map f).unop).op (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).unitIso.inv.app Y) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).unitIso.inv.app X) (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc (attr := simp)]\nlemma opShiftFunctorEquivalence_unitIso_inv_naturality (n : ‚Ñ§) {X Y : C·µí·µñ} (f : X ‚ü∂ Y) :\n    (f‚ü¶n‚üß').unop‚ü¶n‚üß'.op ‚â´ (opShiftFunctorEquivalence C n).unitIso.inv.app Y =\n      (opShiftFunctorEquivalence C n).unitIso.inv.app X ‚â´ f :=\n  (opShiftFunctorEquivalence C n).unitIso.inv.naturality f\n\n"}
{"name":"CategoryTheory.Pretriangulated.opShiftFunctorEquivalence_counitIso_hom_naturality","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nn : Int\nX Y : Opposite C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (Opposite C) n).map ((CategoryTheory.shiftFunctor C n).map f.unop).op) ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).counitIso.hom.app Y)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).counitIso.hom.app X) f)","decl":"@[reassoc (attr := simp)]\nlemma opShiftFunctorEquivalence_counitIso_hom_naturality (n : ‚Ñ§) {X Y : C·µí·µñ} (f : X ‚ü∂ Y) :\n    f.unop‚ü¶n‚üß'.op‚ü¶n‚üß' ‚â´ (opShiftFunctorEquivalence C n).counitIso.hom.app Y =\n      (opShiftFunctorEquivalence C n).counitIso.hom.app X ‚â´ f :=\n  (opShiftFunctorEquivalence C n).counitIso.hom.naturality f\n\n"}
{"name":"CategoryTheory.Pretriangulated.opShiftFunctorEquivalence_counitIso_hom_naturality_assoc","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nn : Int\nX Y : Opposite C\nf : Quiver.Hom X Y\nZ : Opposite C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (Opposite C) n).map ((CategoryTheory.shiftFunctor C n).map f.unop).op) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).counitIso.hom.app Y) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).counitIso.hom.app X) (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc (attr := simp)]\nlemma opShiftFunctorEquivalence_counitIso_hom_naturality (n : ‚Ñ§) {X Y : C·µí·µñ} (f : X ‚ü∂ Y) :\n    f.unop‚ü¶n‚üß'.op‚ü¶n‚üß' ‚â´ (opShiftFunctorEquivalence C n).counitIso.hom.app Y =\n      (opShiftFunctorEquivalence C n).counitIso.hom.app X ‚â´ f :=\n  (opShiftFunctorEquivalence C n).counitIso.hom.naturality f\n\n"}
{"name":"CategoryTheory.Pretriangulated.opShiftFunctorEquivalence_counitIso_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nn : Int\nX Y : Opposite C\nf : Quiver.Hom X Y\nZ : Opposite C\nh : Quiver.Hom ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).functor.obj ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).inverse.obj Y)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).counitIso.inv.app Y) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).counitIso.inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (Opposite C) n).map ((CategoryTheory.shiftFunctor C n).map f.unop).op) h))","decl":"@[reassoc (attr := simp)]\nlemma opShiftFunctorEquivalence_counitIso_inv_naturality (n : ‚Ñ§) {X Y : C·µí·µñ} (f : X ‚ü∂ Y) :\n    f ‚â´ (opShiftFunctorEquivalence C n).counitIso.inv.app Y =\n      (opShiftFunctorEquivalence C n).counitIso.inv.app X ‚â´ f.unop‚ü¶n‚üß'.op‚ü¶n‚üß' :=\n  (opShiftFunctorEquivalence C n).counitIso.inv.naturality f\n\n"}
{"name":"CategoryTheory.Pretriangulated.opShiftFunctorEquivalence_counitIso_inv_naturality","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nn : Int\nX Y : Opposite C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).counitIso.inv.app Y)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).counitIso.inv.app X) ((CategoryTheory.shiftFunctor (Opposite C) n).map ((CategoryTheory.shiftFunctor C n).map f.unop).op))","decl":"@[reassoc (attr := simp)]\nlemma opShiftFunctorEquivalence_counitIso_inv_naturality (n : ‚Ñ§) {X Y : C·µí·µñ} (f : X ‚ü∂ Y) :\n    f ‚â´ (opShiftFunctorEquivalence C n).counitIso.inv.app Y =\n      (opShiftFunctorEquivalence C n).counitIso.inv.app X ‚â´ f.unop‚ü¶n‚üß'.op‚ü¶n‚üß' :=\n  (opShiftFunctorEquivalence C n).counitIso.inv.naturality f\n\n"}
{"name":"CategoryTheory.Pretriangulated.opShiftFunctorEquivalence_zero_unitIso_hom_app","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nX : Opposite C\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C 0).unitIso.hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorZero C Int).hom.app (Opposite.unop X)).op ((CategoryTheory.shiftFunctor C 0).map ((CategoryTheory.shiftFunctorZero (Opposite C) Int).inv.app X).unop).op)","decl":"lemma opShiftFunctorEquivalence_zero_unitIso_hom_app (X : C·µí·µñ) :\n    (opShiftFunctorEquivalence C 0).unitIso.hom.app X =\n      ((shiftFunctorZero C ‚Ñ§).hom.app X.unop).op ‚â´\n      (((shiftFunctorZero C·µí·µñ ‚Ñ§).inv.app X).unop‚ü¶(0 : ‚Ñ§)‚üß').op := by\n  apply Quiver.Hom.unop_inj\n  dsimp [opShiftFunctorEquivalence]\n  rw [shiftFunctorZero_op_inv_app, unop_comp, Quiver.Hom.unop_op, Functor.map_comp,\n    shiftFunctorCompIsoId_zero_zero_hom_app, assoc]\n\n"}
{"name":"CategoryTheory.Pretriangulated.opShiftFunctorEquivalence_zero_unitIso_inv_app","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nX : Opposite C\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C 0).unitIso.inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C 0).map ((CategoryTheory.shiftFunctorZero (Opposite C) Int).hom.app X).unop).op ((CategoryTheory.shiftFunctorZero C Int).inv.app (Opposite.unop X)).op)","decl":"lemma opShiftFunctorEquivalence_zero_unitIso_inv_app (X : C·µí·µñ) :\n    (opShiftFunctorEquivalence C 0).unitIso.inv.app X =\n      (((shiftFunctorZero C·µí·µñ ‚Ñ§).hom.app X).unop‚ü¶(0 : ‚Ñ§)‚üß').op ‚â´\n        ((shiftFunctorZero C ‚Ñ§).inv.app X.unop).op := by\n  apply Quiver.Hom.unop_inj\n  dsimp [opShiftFunctorEquivalence]\n  rw [shiftFunctorZero_op_hom_app, unop_comp, Quiver.Hom.unop_op, Functor.map_comp,\n    shiftFunctorCompIsoId_zero_zero_inv_app, assoc]\n\n"}
{"name":"CategoryTheory.Pretriangulated.opShiftFunctorEquivalence_unitIso_hom_app_eq","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nX : Opposite C\nm n p : Int\nh : Eq (HAdd.hAdd m n) p\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C p).unitIso.hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).unitIso.hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C n).map ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C m).unitIso.hom.app ((CategoryTheory.shiftFunctor (Opposite C) n).obj X)).unop).op (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C m n p h).hom.app (Opposite.unop ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C m).functor.obj ((CategoryTheory.shiftFunctor (Opposite C) n).obj X)))).op ((CategoryTheory.shiftFunctor C p).map ((CategoryTheory.shiftFunctorAdd' (Opposite C) n m p ‚ãØ).inv.app X).unop).op)))","decl":"lemma opShiftFunctorEquivalence_unitIso_hom_app_eq (X : C·µí·µñ) (m n p : ‚Ñ§) (h : m + n = p) :\n    (opShiftFunctorEquivalence C p).unitIso.hom.app X =\n      (opShiftFunctorEquivalence C n).unitIso.hom.app X ‚â´\n      (((opShiftFunctorEquivalence C m).unitIso.hom.app (X‚ü¶n‚üß)).unop‚ü¶n‚üß').op ‚â´\n      ((shiftFunctorAdd' C m n p h).hom.app _).op ‚â´\n      (((shiftFunctorAdd' C·µí·µñ n m p (by omega)).inv.app X).unop‚ü¶p‚üß').op := by\n  dsimp [opShiftFunctorEquivalence]\n  simp only [shiftFunctorAdd'_op_inv_app _ n m p (by omega) _ _ _ (add_neg_cancel n)\n    (add_neg_cancel m) (add_neg_cancel p), shiftFunctor_op_map _ _ (add_neg_cancel m),\n    Category.assoc, Iso.inv_hom_id_app_assoc]\n  erw [Functor.map_id, Functor.map_id, Functor.map_id, Functor.map_id,\n    id_comp, id_comp, id_comp, comp_id, comp_id]\n  dsimp\n  rw [comp_id, shiftFunctorCompIsoId_add'_hom_app _ _ _ _ _ _\n    (neg_add_cancel m) (neg_add_cancel n) (neg_add_cancel p) h]\n  dsimp\n  rw [Category.assoc, Category.assoc]\n  rfl\n\n"}
{"name":"CategoryTheory.Pretriangulated.opShiftFunctorEquivalence_unitIso_inv_app_eq","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nX : Opposite C\nm n p : Int\nh : Eq (HAdd.hAdd m n) p\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C p).unitIso.inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C p).map ((CategoryTheory.shiftFunctorAdd' (Opposite C) n m p ‚ãØ).hom.app X).unop).op (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C m n p h).inv.app (Opposite.unop (((CategoryTheory.shiftFunctor (Opposite C) n).comp (CategoryTheory.shiftFunctor (Opposite C) m)).obj X))).op (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C n).map ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C m).unitIso.inv.app ((CategoryTheory.shiftFunctor (Opposite C) n).obj X)).unop).op ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).unitIso.inv.app X))))","decl":"lemma opShiftFunctorEquivalence_unitIso_inv_app_eq (X : C·µí·µñ) (m n p : ‚Ñ§) (h : m + n = p) :\n    (opShiftFunctorEquivalence C p).unitIso.inv.app X =\n      (((shiftFunctorAdd' C·µí·µñ n m p (by omega)).hom.app X).unop‚ü¶p‚üß').op ‚â´\n      ((shiftFunctorAdd' C m n p h).inv.app _).op ‚â´\n      (((opShiftFunctorEquivalence C m).unitIso.inv.app (X‚ü¶n‚üß)).unop‚ü¶n‚üß').op ‚â´\n      (opShiftFunctorEquivalence C n).unitIso.inv.app X := by\n  rw [‚Üê cancel_mono ((opShiftFunctorEquivalence C p).unitIso.hom.app X), Iso.inv_hom_id_app,\n    opShiftFunctorEquivalence_unitIso_hom_app_eq _ _ _ _ h,\n    Category.assoc, Category.assoc, Category.assoc, Iso.inv_hom_id_app_assoc]\n  apply Quiver.Hom.unop_inj\n  dsimp\n  simp only [Category.assoc, ‚Üê Functor.map_comp_assoc, Iso.hom_inv_id_app_assoc,\n    ‚Üê unop_comp, Iso.inv_hom_id_app, Functor.comp_obj, Functor.op_obj, unop_id,\n    Functor.map_id, id_comp, ‚Üê Functor.map_comp, Iso.hom_inv_id_app]\n\n"}
{"name":"CategoryTheory.Pretriangulated.shift_unop_opShiftFunctorEquivalence_counitIso_inv_app","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nX : Opposite C\nn : Int\n‚ä¢ Eq ((CategoryTheory.shiftFunctor C n).map ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).counitIso.inv.app X).unop) ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).unitIso.hom.app { unop := (CategoryTheory.shiftFunctor C n).obj (Opposite.unop X) }).unop","decl":"lemma shift_unop_opShiftFunctorEquivalence_counitIso_inv_app (X : C·µí·µñ) (n : ‚Ñ§) :\n    ((opShiftFunctorEquivalence C n).counitIso.inv.app X).unop‚ü¶n‚üß' =\n      ((opShiftFunctorEquivalence C n).unitIso.hom.app ((Opposite.op ((X.unop)‚ü¶n‚üß)))).unop :=\n  Quiver.Hom.op_inj ((opShiftFunctorEquivalence C n).unit_app_inverse X).symm\n\n"}
{"name":"CategoryTheory.Pretriangulated.shift_unop_opShiftFunctorEquivalence_counitIso_hom_app","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nX : Opposite C\nn : Int\n‚ä¢ Eq ((CategoryTheory.shiftFunctor C n).map ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).counitIso.hom.app X).unop) ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).unitIso.inv.app { unop := (CategoryTheory.shiftFunctor C n).obj (Opposite.unop X) }).unop","decl":"lemma shift_unop_opShiftFunctorEquivalence_counitIso_hom_app (X : C·µí·µñ) (n : ‚Ñ§) :\n    ((opShiftFunctorEquivalence C n).counitIso.hom.app X).unop‚ü¶n‚üß' =\n      ((opShiftFunctorEquivalence C n).unitIso.inv.app ((Opposite.op (X.unop‚ü¶n‚üß)))).unop :=\n  Quiver.Hom.op_inj ((opShiftFunctorEquivalence C n).unitInv_app_inverse X).symm\n\n"}
{"name":"CategoryTheory.Pretriangulated.opShiftFunctorEquivalence_counitIso_inv_app_shift","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nX : Opposite C\nn : Int\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).counitIso.inv.app ((CategoryTheory.shiftFunctor (Opposite C) n).obj X)) ((CategoryTheory.shiftFunctor (Opposite C) n).map ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).unitIso.hom.app X))","decl":"lemma opShiftFunctorEquivalence_counitIso_inv_app_shift (X : C·µí·µñ) (n : ‚Ñ§) :\n    (opShiftFunctorEquivalence C n).counitIso.inv.app (X‚ü¶n‚üß) =\n      ((opShiftFunctorEquivalence C n).unitIso.hom.app X)‚ü¶n‚üß' :=\n  (opShiftFunctorEquivalence C n).counitInv_app_functor X\n\n"}
{"name":"CategoryTheory.Pretriangulated.opShiftFunctorEquivalence_counitIso_hom_app_shift","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nX : Opposite C\nn : Int\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).counitIso.hom.app ((CategoryTheory.shiftFunctor (Opposite C) n).obj X)) ((CategoryTheory.shiftFunctor (Opposite C) n).map ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).unitIso.inv.app X))","decl":"lemma opShiftFunctorEquivalence_counitIso_hom_app_shift (X : C·µí·µñ) (n : ‚Ñ§) :\n    (opShiftFunctorEquivalence C n).counitIso.hom.app (X‚ü¶n‚üß) =\n      ((opShiftFunctorEquivalence C n).unitIso.inv.app X)‚ü¶n‚üß' :=\n  (opShiftFunctorEquivalence C n).counit_app_functor X\n\n"}
