{"name":"Finset.expect_eq_zero_iff_of_nonneg","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : OrderedAddCommMonoid α\ninst✝ : Module NNRat α\ns : Finset ι\nf : ι → α\nhs : s.Nonempty\nhf : ∀ (i : ι), Membership.mem s i → LE.le 0 (f i)\n⊢ Iff (Eq (s.expect fun i => f i) 0) (∀ (i : ι), Membership.mem s i → Eq (f i) 0)","decl":"lemma expect_eq_zero_iff_of_nonneg (hs : s.Nonempty) (hf : ∀ i ∈ s, 0 ≤ f i) :\n    𝔼 i ∈ s, f i = 0 ↔ ∀ i ∈ s, f i = 0 := by\n  simp [expect, sum_eq_zero_iff_of_nonneg hf, hs.ne_empty]\n\n"}
{"name":"Finset.expect_eq_zero_iff_of_nonpos","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : OrderedAddCommMonoid α\ninst✝ : Module NNRat α\ns : Finset ι\nf : ι → α\nhs : s.Nonempty\nhf : ∀ (i : ι), Membership.mem s i → LE.le (f i) 0\n⊢ Iff (Eq (s.expect fun i => f i) 0) (∀ (i : ι), Membership.mem s i → Eq (f i) 0)","decl":"lemma expect_eq_zero_iff_of_nonpos (hs : s.Nonempty) (hf : ∀ i ∈ s, f i ≤ 0) :\n    𝔼 i ∈ s, f i = 0 ↔ ∀ i ∈ s, f i = 0 := by\n  simp [expect, sum_eq_zero_iff_of_nonpos hf, hs.ne_empty]\n\n"}
{"name":"Finset.expect_le_expect","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : OrderedAddCommMonoid α\ninst✝¹ : Module NNRat α\ns : Finset ι\nf g : ι → α\ninst✝ : PosSMulMono NNRat α\nhfg : ∀ (i : ι), Membership.mem s i → LE.le (f i) (g i)\n⊢ LE.le (s.expect fun i => f i) (s.expect fun i => g i)","decl":"lemma expect_le_expect (hfg : ∀ i ∈ s, f i ≤ g i) : 𝔼 i ∈ s, f i ≤ 𝔼 i ∈ s, g i :=\n  smul_le_smul_of_nonneg_left (sum_le_sum hfg) <| by positivity\n\n"}
{"name":"GCongr.expect_le_expect","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : OrderedAddCommMonoid α\ninst✝¹ : Module NNRat α\ns : Finset ι\nf g : ι → α\ninst✝ : PosSMulMono NNRat α\nh : ∀ (i : ι), Membership.mem s i → LE.le (f i) (g i)\n⊢ LE.le (s.expect f) (s.expect g)","decl":"/-- This is a (beta-reduced) version of the standard lemma `Finset.expect_le_expect`,\nconvenient for the `gcongr` tactic. -/\n@[gcongr]\nlemma _root_.GCongr.expect_le_expect (h : ∀ i ∈ s, f i ≤ g i) : s.expect f ≤ s.expect g :=\n  Finset.expect_le_expect h\n\n"}
{"name":"Finset.expect_le","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : OrderedAddCommMonoid α\ninst✝¹ : Module NNRat α\ns : Finset ι\nf : ι → α\ninst✝ : PosSMulMono NNRat α\na : α\nhs : s.Nonempty\nh : ∀ (x : ι), Membership.mem s x → LE.le (f x) a\n⊢ LE.le (s.expect fun i => f i) a","decl":"lemma expect_le (hs : s.Nonempty) (h : ∀ x ∈ s, f x ≤ a) : 𝔼 i ∈ s, f i ≤ a :=\n  (inv_smul_le_iff_of_pos <| mod_cast hs.card_pos).2 <| by\n    rw [Nat.cast_smul_eq_nsmul]; exact sum_le_card_nsmul _ _ _ h\n\n"}
{"name":"Finset.le_expect","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : OrderedAddCommMonoid α\ninst✝¹ : Module NNRat α\ns : Finset ι\nf : ι → α\ninst✝ : PosSMulMono NNRat α\na : α\nhs : s.Nonempty\nh : ∀ (x : ι), Membership.mem s x → LE.le a (f x)\n⊢ LE.le a (s.expect fun i => f i)","decl":"lemma le_expect (hs : s.Nonempty) (h : ∀ x ∈ s, a ≤ f x) : a ≤ 𝔼 i ∈ s, f i :=\n  (le_inv_smul_iff_of_pos <| mod_cast hs.card_pos).2 <| by\n    rw [Nat.cast_smul_eq_nsmul]; exact card_nsmul_le_sum _ _ _ h\n\n"}
{"name":"Finset.expect_nonneg","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : OrderedAddCommMonoid α\ninst✝¹ : Module NNRat α\ns : Finset ι\nf : ι → α\ninst✝ : PosSMulMono NNRat α\nhf : ∀ (i : ι), Membership.mem s i → LE.le 0 (f i)\n⊢ LE.le 0 (s.expect fun i => f i)","decl":"lemma expect_nonneg (hf : ∀ i ∈ s, 0 ≤ f i) : 0 ≤ 𝔼 i ∈ s, f i :=\n  smul_nonneg (by positivity) <| sum_nonneg hf\n\n"}
{"name":"Finset.le_expect_nonempty_of_subadditive_on_pred","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module NNRat M\ninst✝² : OrderedAddCommMonoid N\ninst✝¹ : Module NNRat N\ninst✝ : PosSMulMono NNRat N\nm : M → N\np : M → Prop\nf : ι → M\ns : Finset ι\nh_add : ∀ (a b : M), p a → p b → LE.le (m (HAdd.hAdd a b)) (HAdd.hAdd (m a) (m b))\nhp_add : ∀ (a b : M), p a → p b → p (HAdd.hAdd a b)\nh_div : ∀ (n : Nat) (a : M), p a → Eq (m (HSMul.hSMul (Inv.inv ↑n) a)) (HSMul.hSMul (Inv.inv ↑n) (m a))\nhs_nonempty : s.Nonempty\nhs : ∀ (i : ι), Membership.mem s i → p (f i)\n⊢ LE.le (m (s.expect fun i => f i)) (s.expect fun i => m (f i))","decl":"/-- Let `{a | p a}` be an additive subsemigroup of an additive commutative monoid `M`. If `m` is a\nsubadditive function (`m (a + b) ≤ m a + m b`) preserved under division by a natural, `f` is a\nfunction valued in that subsemigroup and `s` is a nonempty set, then\n`m (𝔼 i ∈ s, f i) ≤ 𝔼 i ∈ s, m (f i)`. -/\nlemma le_expect_nonempty_of_subadditive_on_pred (h_add : ∀ a b, p a → p b → m (a + b) ≤ m a + m b)\n    (hp_add : ∀ a b, p a → p b → p (a + b)) (h_div : ∀ (n : ℕ) a, p a → m (a /ℚ n) = m a /ℚ n)\n    (hs_nonempty : s.Nonempty) (hs : ∀ i ∈ s, p (f i)) :\n    m (𝔼 i ∈ s, f i) ≤ 𝔼 i ∈ s, m (f i) := by\n  simp only [expect, h_div _ _ (sum_induction_nonempty _ _ hp_add hs_nonempty hs)]\n  exact smul_le_smul_of_nonneg_left\n    (le_sum_nonempty_of_subadditive_on_pred _ _ h_add hp_add _ _ hs_nonempty hs) <| by positivity\n\n"}
{"name":"Finset.le_expect_nonempty_of_subadditive","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module NNRat M\ninst✝² : OrderedAddCommMonoid N\ninst✝¹ : Module NNRat N\ninst✝ : PosSMulMono NNRat N\nf : ι → M\ns : Finset ι\nm : M → N\nh_mul : ∀ (a b : M), LE.le (m (HAdd.hAdd a b)) (HAdd.hAdd (m a) (m b))\nh_div : ∀ (n : Nat) (a : M), Eq (m (HSMul.hSMul (Inv.inv ↑n) a)) (HSMul.hSMul (Inv.inv ↑n) (m a))\nhs : s.Nonempty\n⊢ LE.le (m (s.expect fun i => f i)) (s.expect fun i => m (f i))","decl":"/-- If `m : M → N` is a subadditive function (`m (a + b) ≤ m a + m b`) and `s` is a nonempty set,\nthen `m (𝔼 i ∈ s, f i) ≤ 𝔼 i ∈ s, m (f i)`. -/\nlemma le_expect_nonempty_of_subadditive (m : M → N) (h_mul : ∀ a b, m (a + b) ≤ m a + m b)\n    (h_div : ∀ (n : ℕ) a, m (a /ℚ n) = m a /ℚ n) (hs : s.Nonempty) :\n    m (𝔼 i ∈ s, f i) ≤ 𝔼 i ∈ s, m (f i) :=\n  le_expect_nonempty_of_subadditive_on_pred (p := fun _ ↦ True) (by simpa) (by simp) (by simpa) hs\n    (by simp)\n\n"}
{"name":"Finset.le_expect_of_subadditive_on_pred","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module NNRat M\ninst✝² : OrderedAddCommMonoid N\ninst✝¹ : Module NNRat N\ninst✝ : PosSMulMono NNRat N\nm : M → N\np : M → Prop\nf : ι → M\ns : Finset ι\nh_zero : Eq (m 0) 0\nh_add : ∀ (a b : M), p a → p b → LE.le (m (HAdd.hAdd a b)) (HAdd.hAdd (m a) (m b))\nhp_add : ∀ (a b : M), p a → p b → p (HAdd.hAdd a b)\nh_div : ∀ (n : Nat) (a : M), p a → Eq (m (HSMul.hSMul (Inv.inv ↑n) a)) (HSMul.hSMul (Inv.inv ↑n) (m a))\nhs : ∀ (i : ι), Membership.mem s i → p (f i)\n⊢ LE.le (m (s.expect fun i => f i)) (s.expect fun i => m (f i))","decl":"/-- Let `{a | p a}` be a subsemigroup of a commutative monoid `M`. If `m` is a subadditive function\n(`m (x + y) ≤ m x + m y`, `m 0 = 0`) preserved under division by a natural and `f` is a function\nvalued in that subsemigroup, then `m (𝔼 i ∈ s, f i) ≤ 𝔼 i ∈ s, m (f i)`. -/\nlemma le_expect_of_subadditive_on_pred (h_zero : m 0 = 0)\n    (h_add : ∀ a b, p a → p b → m (a + b) ≤ m a + m b) (hp_add : ∀ a b, p a → p b → p (a + b))\n    (h_div : ∀ (n : ℕ) a, p a → m (a /ℚ n) = m a /ℚ n)\n    (hs : ∀ i ∈ s, p (f i)) : m (𝔼 i ∈ s, f i) ≤ 𝔼 i ∈ s, m (f i) := by\n  obtain rfl | hs_nonempty := s.eq_empty_or_nonempty\n  · simp [h_zero]\n  · exact le_expect_nonempty_of_subadditive_on_pred h_add hp_add h_div hs_nonempty hs\n\n-- TODO: Contribute back better docstring to `le_prod_of_submultiplicative`\n"}
{"name":"Finset.le_expect_of_subadditive","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module NNRat M\ninst✝² : OrderedAddCommMonoid N\ninst✝¹ : Module NNRat N\ninst✝ : PosSMulMono NNRat N\nm : M → N\nf : ι → M\ns : Finset ι\nh_zero : Eq (m 0) 0\nh_add : ∀ (a b : M), LE.le (m (HAdd.hAdd a b)) (HAdd.hAdd (m a) (m b))\nh_div : ∀ (n : Nat) (a : M), Eq (m (HSMul.hSMul (Inv.inv ↑n) a)) (HSMul.hSMul (Inv.inv ↑n) (m a))\n⊢ LE.le (m (s.expect fun i => f i)) (s.expect fun i => m (f i))","decl":"/-- If `m` is a subadditive function (`m (x + y) ≤ m x + m y`, `m 0 = 0`) preserved under division\nby a natural, then `m (𝔼 i ∈ s, f i) ≤ 𝔼 i ∈ s, m (f i)`. -/\nlemma le_expect_of_subadditive (h_zero : m 0 = 0) (h_add : ∀ a b, m (a + b) ≤ m a + m b)\n    (h_div : ∀ (n : ℕ) a, m (a /ℚ n) = m a /ℚ n) : m (𝔼 i ∈ s, f i) ≤ 𝔼 i ∈ s, m (f i) :=\n  le_expect_of_subadditive_on_pred (p := fun _ ↦ True) h_zero (by simpa) (by simp) (by simpa)\n    (by simp)\n\n"}
{"name":"Finset.expect_pos","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : OrderedCancelAddCommMonoid α\ninst✝¹ : Module NNRat α\ns : Finset ι\nf : ι → α\ninst✝ : PosSMulStrictMono NNRat α\nhf : ∀ (i : ι), Membership.mem s i → LT.lt 0 (f i)\nhs : s.Nonempty\n⊢ LT.lt 0 (s.expect fun i => f i)","decl":"lemma expect_pos (hf : ∀ i ∈ s, 0 < f i) (hs : s.Nonempty) : 0 < 𝔼 i ∈ s, f i :=\n  smul_pos (inv_pos.2 <| mod_cast hs.card_pos) <| sum_pos hf hs\n\n"}
{"name":"Finset.exists_lt_of_lt_expect","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedAddCommMonoid α\ninst✝¹ : Module NNRat α\ninst✝ : PosSMulMono NNRat α\ns : Finset ι\nf : ι → α\na : α\nhs : s.Nonempty\nh : LT.lt a (s.expect fun i => f i)\n⊢ Exists fun x => And (Membership.mem s x) (LT.lt a (f x))","decl":"lemma exists_lt_of_lt_expect (hs : s.Nonempty) (h : a < 𝔼 i ∈ s, f i) : ∃ x ∈ s, a < f x := by\n  contrapose! h; exact expect_le hs h\n\n"}
{"name":"Finset.exists_lt_of_expect_lt","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedAddCommMonoid α\ninst✝¹ : Module NNRat α\ninst✝ : PosSMulMono NNRat α\ns : Finset ι\nf : ι → α\na : α\nhs : s.Nonempty\nh : LT.lt (s.expect fun i => f i) a\n⊢ Exists fun x => And (Membership.mem s x) (LT.lt (f x) a)","decl":"lemma exists_lt_of_expect_lt (hs : s.Nonempty) (h : 𝔼 i ∈ s, f i < a) : ∃ x ∈ s, f x < a := by\n  contrapose! h; exact le_expect hs h\n\n"}
{"name":"Finset.abs_expect_le","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedAddCommGroup α\ninst✝¹ : Module NNRat α\ninst✝ : PosSMulMono NNRat α\ns : Finset ι\nf : ι → α\n⊢ LE.le (abs (s.expect fun i => f i)) (s.expect fun i => abs (f i))","decl":"lemma abs_expect_le (s : Finset ι) (f : ι → α) : |𝔼 i ∈ s, f i| ≤ 𝔼 i ∈ s, |f i| :=\n  le_expect_of_subadditive abs_zero abs_add (fun _ ↦ abs_nnqsmul _)\n\n"}
{"name":"Finset.expect_mul_sq_le_sq_mul_sq","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"ι : Type u_1\nR : Type u_3\ninst✝³ : LinearOrderedCommSemiring R\ninst✝² : ExistsAddOfLE R\ninst✝¹ : Module NNRat R\ninst✝ : PosSMulMono NNRat R\ns : Finset ι\nf g : ι → R\n⊢ LE.le (HPow.hPow (s.expect fun i => HMul.hMul (f i) (g i)) 2) (HMul.hMul (s.expect fun i => HPow.hPow (f i) 2) (s.expect fun i => HPow.hPow (g i) 2))","decl":"/-- **Cauchy-Schwarz inequality** in terms of `Finset.expect`. -/\nlemma expect_mul_sq_le_sq_mul_sq (s : Finset ι) (f g : ι → R) :\n    (𝔼 i ∈ s, f i * g i) ^ 2 ≤ (𝔼 i ∈ s, f i ^ 2) * 𝔼 i ∈ s, g i ^ 2 := by\n  simp only [expect, smul_pow, inv_pow, smul_mul_smul_comm, ← sq]\n  gcongr\n  exact sum_mul_sq_le_sq_mul_sq ..\n\n"}
{"name":"Fintype.expect_eq_zero_iff_of_nonneg","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝³ : Fintype ι\ninst✝² : OrderedAddCommMonoid α\ninst✝¹ : Module NNRat α\nf : ι → α\ninst✝ : Nonempty ι\nhf : LE.le 0 f\n⊢ Iff (Eq (Finset.univ.expect fun i => f i) 0) (Eq f 0)","decl":"lemma expect_eq_zero_iff_of_nonneg [Nonempty ι] (hf : 0 ≤ f) : 𝔼 i, f i = 0 ↔ f = 0 := by\n  simp [expect, sum_eq_zero_iff_of_nonneg hf, univ_nonempty.ne_empty]\n\n"}
{"name":"Fintype.expect_eq_zero_iff_of_nonpos","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝³ : Fintype ι\ninst✝² : OrderedAddCommMonoid α\ninst✝¹ : Module NNRat α\nf : ι → α\ninst✝ : Nonempty ι\nhf : LE.le f 0\n⊢ Iff (Eq (Finset.univ.expect fun i => f i) 0) (Eq f 0)","decl":"lemma expect_eq_zero_iff_of_nonpos [Nonempty ι] (hf : f ≤ 0) : 𝔼 i, f i = 0 ↔ f = 0 := by\n  simp [expect, sum_eq_zero_iff_of_nonpos hf, univ_nonempty.ne_empty]\n\n"}
