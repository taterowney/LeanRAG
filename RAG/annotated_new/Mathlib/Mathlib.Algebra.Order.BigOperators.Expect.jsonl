{"name":"Finset.expect_eq_zero_iff_of_nonneg","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ¹ : OrderedAddCommMonoid Î±\ninstâœ : Module NNRat Î±\ns : Finset Î¹\nf : Î¹ â†’ Î±\nhs : s.Nonempty\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ LE.le 0 (f i)\nâŠ¢ Iff (Eq (s.expect fun i => f i) 0) (âˆ€ (i : Î¹), Membership.mem s i â†’ Eq (f i) 0)","decl":"lemma expect_eq_zero_iff_of_nonneg (hs : s.Nonempty) (hf : âˆ€ i âˆˆ s, 0 â‰¤ f i) :\n    ğ”¼ i âˆˆ s, f i = 0 â†” âˆ€ i âˆˆ s, f i = 0 := by\n  simp [expect, sum_eq_zero_iff_of_nonneg hf, hs.ne_empty]\n\n"}
{"name":"Finset.expect_eq_zero_iff_of_nonpos","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ¹ : OrderedAddCommMonoid Î±\ninstâœ : Module NNRat Î±\ns : Finset Î¹\nf : Î¹ â†’ Î±\nhs : s.Nonempty\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ LE.le (f i) 0\nâŠ¢ Iff (Eq (s.expect fun i => f i) 0) (âˆ€ (i : Î¹), Membership.mem s i â†’ Eq (f i) 0)","decl":"lemma expect_eq_zero_iff_of_nonpos (hs : s.Nonempty) (hf : âˆ€ i âˆˆ s, f i â‰¤ 0) :\n    ğ”¼ i âˆˆ s, f i = 0 â†” âˆ€ i âˆˆ s, f i = 0 := by\n  simp [expect, sum_eq_zero_iff_of_nonpos hf, hs.ne_empty]\n\n"}
{"name":"Finset.expect_le_expect","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ² : OrderedAddCommMonoid Î±\ninstâœÂ¹ : Module NNRat Î±\ns : Finset Î¹\nf g : Î¹ â†’ Î±\ninstâœ : PosSMulMono NNRat Î±\nhfg : âˆ€ (i : Î¹), Membership.mem s i â†’ LE.le (f i) (g i)\nâŠ¢ LE.le (s.expect fun i => f i) (s.expect fun i => g i)","decl":"lemma expect_le_expect (hfg : âˆ€ i âˆˆ s, f i â‰¤ g i) : ğ”¼ i âˆˆ s, f i â‰¤ ğ”¼ i âˆˆ s, g i :=\n  smul_le_smul_of_nonneg_left (sum_le_sum hfg) <| by positivity\n\n"}
{"name":"GCongr.expect_le_expect","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ² : OrderedAddCommMonoid Î±\ninstâœÂ¹ : Module NNRat Î±\ns : Finset Î¹\nf g : Î¹ â†’ Î±\ninstâœ : PosSMulMono NNRat Î±\nh : âˆ€ (i : Î¹), Membership.mem s i â†’ LE.le (f i) (g i)\nâŠ¢ LE.le (s.expect f) (s.expect g)","decl":"/-- This is a (beta-reduced) version of the standard lemma `Finset.expect_le_expect`,\nconvenient for the `gcongr` tactic. -/\n@[gcongr]\nlemma _root_.GCongr.expect_le_expect (h : âˆ€ i âˆˆ s, f i â‰¤ g i) : s.expect f â‰¤ s.expect g :=\n  Finset.expect_le_expect h\n\n"}
{"name":"Finset.expect_le","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ² : OrderedAddCommMonoid Î±\ninstâœÂ¹ : Module NNRat Î±\ns : Finset Î¹\nf : Î¹ â†’ Î±\ninstâœ : PosSMulMono NNRat Î±\na : Î±\nhs : s.Nonempty\nh : âˆ€ (x : Î¹), Membership.mem s x â†’ LE.le (f x) a\nâŠ¢ LE.le (s.expect fun i => f i) a","decl":"lemma expect_le (hs : s.Nonempty) (h : âˆ€ x âˆˆ s, f x â‰¤ a) : ğ”¼ i âˆˆ s, f i â‰¤ a :=\n  (inv_smul_le_iff_of_pos <| mod_cast hs.card_pos).2 <| by\n    rw [Nat.cast_smul_eq_nsmul]; exact sum_le_card_nsmul _ _ _ h\n\n"}
{"name":"Finset.le_expect","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ² : OrderedAddCommMonoid Î±\ninstâœÂ¹ : Module NNRat Î±\ns : Finset Î¹\nf : Î¹ â†’ Î±\ninstâœ : PosSMulMono NNRat Î±\na : Î±\nhs : s.Nonempty\nh : âˆ€ (x : Î¹), Membership.mem s x â†’ LE.le a (f x)\nâŠ¢ LE.le a (s.expect fun i => f i)","decl":"lemma le_expect (hs : s.Nonempty) (h : âˆ€ x âˆˆ s, a â‰¤ f x) : a â‰¤ ğ”¼ i âˆˆ s, f i :=\n  (le_inv_smul_iff_of_pos <| mod_cast hs.card_pos).2 <| by\n    rw [Nat.cast_smul_eq_nsmul]; exact card_nsmul_le_sum _ _ _ h\n\n"}
{"name":"Finset.expect_nonneg","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ² : OrderedAddCommMonoid Î±\ninstâœÂ¹ : Module NNRat Î±\ns : Finset Î¹\nf : Î¹ â†’ Î±\ninstâœ : PosSMulMono NNRat Î±\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ LE.le 0 (f i)\nâŠ¢ LE.le 0 (s.expect fun i => f i)","decl":"lemma expect_nonneg (hf : âˆ€ i âˆˆ s, 0 â‰¤ f i) : 0 â‰¤ ğ”¼ i âˆˆ s, f i :=\n  smul_nonneg (by positivity) <| sum_nonneg hf\n\n"}
{"name":"Finset.le_expect_nonempty_of_subadditive_on_pred","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_4\nN : Type u_5\ninstâœâ´ : AddCommMonoid M\ninstâœÂ³ : Module NNRat M\ninstâœÂ² : OrderedAddCommMonoid N\ninstâœÂ¹ : Module NNRat N\ninstâœ : PosSMulMono NNRat N\nm : M â†’ N\np : M â†’ Prop\nf : Î¹ â†’ M\ns : Finset Î¹\nh_add : âˆ€ (a b : M), p a â†’ p b â†’ LE.le (m (HAdd.hAdd a b)) (HAdd.hAdd (m a) (m b))\nhp_add : âˆ€ (a b : M), p a â†’ p b â†’ p (HAdd.hAdd a b)\nh_div : âˆ€ (n : Nat) (a : M), p a â†’ Eq (m (HSMul.hSMul (Inv.inv â†‘n) a)) (HSMul.hSMul (Inv.inv â†‘n) (m a))\nhs_nonempty : s.Nonempty\nhs : âˆ€ (i : Î¹), Membership.mem s i â†’ p (f i)\nâŠ¢ LE.le (m (s.expect fun i => f i)) (s.expect fun i => m (f i))","decl":"/-- Let `{a | p a}` be an additive subsemigroup of an additive commutative monoid `M`. If `m` is a\nsubadditive function (`m (a + b) â‰¤ m a + m b`) preserved under division by a natural, `f` is a\nfunction valued in that subsemigroup and `s` is a nonempty set, then\n`m (ğ”¼ i âˆˆ s, f i) â‰¤ ğ”¼ i âˆˆ s, m (f i)`. -/\nlemma le_expect_nonempty_of_subadditive_on_pred (h_add : âˆ€ a b, p a â†’ p b â†’ m (a + b) â‰¤ m a + m b)\n    (hp_add : âˆ€ a b, p a â†’ p b â†’ p (a + b)) (h_div : âˆ€ (n : â„•) a, p a â†’ m (a /â„š n) = m a /â„š n)\n    (hs_nonempty : s.Nonempty) (hs : âˆ€ i âˆˆ s, p (f i)) :\n    m (ğ”¼ i âˆˆ s, f i) â‰¤ ğ”¼ i âˆˆ s, m (f i) := by\n  simp only [expect, h_div _ _ (sum_induction_nonempty _ _ hp_add hs_nonempty hs)]\n  exact smul_le_smul_of_nonneg_left\n    (le_sum_nonempty_of_subadditive_on_pred _ _ h_add hp_add _ _ hs_nonempty hs) <| by positivity\n\n"}
{"name":"Finset.le_expect_nonempty_of_subadditive","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_4\nN : Type u_5\ninstâœâ´ : AddCommMonoid M\ninstâœÂ³ : Module NNRat M\ninstâœÂ² : OrderedAddCommMonoid N\ninstâœÂ¹ : Module NNRat N\ninstâœ : PosSMulMono NNRat N\nf : Î¹ â†’ M\ns : Finset Î¹\nm : M â†’ N\nh_mul : âˆ€ (a b : M), LE.le (m (HAdd.hAdd a b)) (HAdd.hAdd (m a) (m b))\nh_div : âˆ€ (n : Nat) (a : M), Eq (m (HSMul.hSMul (Inv.inv â†‘n) a)) (HSMul.hSMul (Inv.inv â†‘n) (m a))\nhs : s.Nonempty\nâŠ¢ LE.le (m (s.expect fun i => f i)) (s.expect fun i => m (f i))","decl":"/-- If `m : M â†’ N` is a subadditive function (`m (a + b) â‰¤ m a + m b`) and `s` is a nonempty set,\nthen `m (ğ”¼ i âˆˆ s, f i) â‰¤ ğ”¼ i âˆˆ s, m (f i)`. -/\nlemma le_expect_nonempty_of_subadditive (m : M â†’ N) (h_mul : âˆ€ a b, m (a + b) â‰¤ m a + m b)\n    (h_div : âˆ€ (n : â„•) a, m (a /â„š n) = m a /â„š n) (hs : s.Nonempty) :\n    m (ğ”¼ i âˆˆ s, f i) â‰¤ ğ”¼ i âˆˆ s, m (f i) :=\n  le_expect_nonempty_of_subadditive_on_pred (p := fun _ â†¦ True) (by simpa) (by simp) (by simpa) hs\n    (by simp)\n\n"}
{"name":"Finset.le_expect_of_subadditive_on_pred","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_4\nN : Type u_5\ninstâœâ´ : AddCommMonoid M\ninstâœÂ³ : Module NNRat M\ninstâœÂ² : OrderedAddCommMonoid N\ninstâœÂ¹ : Module NNRat N\ninstâœ : PosSMulMono NNRat N\nm : M â†’ N\np : M â†’ Prop\nf : Î¹ â†’ M\ns : Finset Î¹\nh_zero : Eq (m 0) 0\nh_add : âˆ€ (a b : M), p a â†’ p b â†’ LE.le (m (HAdd.hAdd a b)) (HAdd.hAdd (m a) (m b))\nhp_add : âˆ€ (a b : M), p a â†’ p b â†’ p (HAdd.hAdd a b)\nh_div : âˆ€ (n : Nat) (a : M), p a â†’ Eq (m (HSMul.hSMul (Inv.inv â†‘n) a)) (HSMul.hSMul (Inv.inv â†‘n) (m a))\nhs : âˆ€ (i : Î¹), Membership.mem s i â†’ p (f i)\nâŠ¢ LE.le (m (s.expect fun i => f i)) (s.expect fun i => m (f i))","decl":"/-- Let `{a | p a}` be a subsemigroup of a commutative monoid `M`. If `m` is a subadditive function\n(`m (x + y) â‰¤ m x + m y`, `m 0 = 0`) preserved under division by a natural and `f` is a function\nvalued in that subsemigroup, then `m (ğ”¼ i âˆˆ s, f i) â‰¤ ğ”¼ i âˆˆ s, m (f i)`. -/\nlemma le_expect_of_subadditive_on_pred (h_zero : m 0 = 0)\n    (h_add : âˆ€ a b, p a â†’ p b â†’ m (a + b) â‰¤ m a + m b) (hp_add : âˆ€ a b, p a â†’ p b â†’ p (a + b))\n    (h_div : âˆ€ (n : â„•) a, p a â†’ m (a /â„š n) = m a /â„š n)\n    (hs : âˆ€ i âˆˆ s, p (f i)) : m (ğ”¼ i âˆˆ s, f i) â‰¤ ğ”¼ i âˆˆ s, m (f i) := by\n  obtain rfl | hs_nonempty := s.eq_empty_or_nonempty\n  Â· simp [h_zero]\n  Â· exact le_expect_nonempty_of_subadditive_on_pred h_add hp_add h_div hs_nonempty hs\n\n-- TODO: Contribute back better docstring to `le_prod_of_submultiplicative`\n"}
{"name":"Finset.le_expect_of_subadditive","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_4\nN : Type u_5\ninstâœâ´ : AddCommMonoid M\ninstâœÂ³ : Module NNRat M\ninstâœÂ² : OrderedAddCommMonoid N\ninstâœÂ¹ : Module NNRat N\ninstâœ : PosSMulMono NNRat N\nm : M â†’ N\nf : Î¹ â†’ M\ns : Finset Î¹\nh_zero : Eq (m 0) 0\nh_add : âˆ€ (a b : M), LE.le (m (HAdd.hAdd a b)) (HAdd.hAdd (m a) (m b))\nh_div : âˆ€ (n : Nat) (a : M), Eq (m (HSMul.hSMul (Inv.inv â†‘n) a)) (HSMul.hSMul (Inv.inv â†‘n) (m a))\nâŠ¢ LE.le (m (s.expect fun i => f i)) (s.expect fun i => m (f i))","decl":"/-- If `m` is a subadditive function (`m (x + y) â‰¤ m x + m y`, `m 0 = 0`) preserved under division\nby a natural, then `m (ğ”¼ i âˆˆ s, f i) â‰¤ ğ”¼ i âˆˆ s, m (f i)`. -/\nlemma le_expect_of_subadditive (h_zero : m 0 = 0) (h_add : âˆ€ a b, m (a + b) â‰¤ m a + m b)\n    (h_div : âˆ€ (n : â„•) a, m (a /â„š n) = m a /â„š n) : m (ğ”¼ i âˆˆ s, f i) â‰¤ ğ”¼ i âˆˆ s, m (f i) :=\n  le_expect_of_subadditive_on_pred (p := fun _ â†¦ True) h_zero (by simpa) (by simp) (by simpa)\n    (by simp)\n\n"}
{"name":"Finset.expect_pos","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ² : OrderedCancelAddCommMonoid Î±\ninstâœÂ¹ : Module NNRat Î±\ns : Finset Î¹\nf : Î¹ â†’ Î±\ninstâœ : PosSMulStrictMono NNRat Î±\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ LT.lt 0 (f i)\nhs : s.Nonempty\nâŠ¢ LT.lt 0 (s.expect fun i => f i)","decl":"lemma expect_pos (hf : âˆ€ i âˆˆ s, 0 < f i) (hs : s.Nonempty) : 0 < ğ”¼ i âˆˆ s, f i :=\n  smul_pos (inv_pos.2 <| mod_cast hs.card_pos) <| sum_pos hf hs\n\n"}
{"name":"Finset.exists_lt_of_lt_expect","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ² : LinearOrderedAddCommMonoid Î±\ninstâœÂ¹ : Module NNRat Î±\ninstâœ : PosSMulMono NNRat Î±\ns : Finset Î¹\nf : Î¹ â†’ Î±\na : Î±\nhs : s.Nonempty\nh : LT.lt a (s.expect fun i => f i)\nâŠ¢ Exists fun x => And (Membership.mem s x) (LT.lt a (f x))","decl":"lemma exists_lt_of_lt_expect (hs : s.Nonempty) (h : a < ğ”¼ i âˆˆ s, f i) : âˆƒ x âˆˆ s, a < f x := by\n  contrapose! h; exact expect_le hs h\n\n"}
{"name":"Finset.exists_lt_of_expect_lt","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ² : LinearOrderedAddCommMonoid Î±\ninstâœÂ¹ : Module NNRat Î±\ninstâœ : PosSMulMono NNRat Î±\ns : Finset Î¹\nf : Î¹ â†’ Î±\na : Î±\nhs : s.Nonempty\nh : LT.lt (s.expect fun i => f i) a\nâŠ¢ Exists fun x => And (Membership.mem s x) (LT.lt (f x) a)","decl":"lemma exists_lt_of_expect_lt (hs : s.Nonempty) (h : ğ”¼ i âˆˆ s, f i < a) : âˆƒ x âˆˆ s, f x < a := by\n  contrapose! h; exact le_expect hs h\n\n"}
{"name":"Finset.abs_expect_le","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ² : LinearOrderedAddCommGroup Î±\ninstâœÂ¹ : Module NNRat Î±\ninstâœ : PosSMulMono NNRat Î±\ns : Finset Î¹\nf : Î¹ â†’ Î±\nâŠ¢ LE.le (abs (s.expect fun i => f i)) (s.expect fun i => abs (f i))","decl":"lemma abs_expect_le (s : Finset Î¹) (f : Î¹ â†’ Î±) : |ğ”¼ i âˆˆ s, f i| â‰¤ ğ”¼ i âˆˆ s, |f i| :=\n  le_expect_of_subadditive abs_zero abs_add (fun _ â†¦ abs_nnqsmul _)\n\n"}
{"name":"Finset.expect_mul_sq_le_sq_mul_sq","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nR : Type u_3\ninstâœÂ³ : LinearOrderedCommSemiring R\ninstâœÂ² : ExistsAddOfLE R\ninstâœÂ¹ : Module NNRat R\ninstâœ : PosSMulMono NNRat R\ns : Finset Î¹\nf g : Î¹ â†’ R\nâŠ¢ LE.le (HPow.hPow (s.expect fun i => HMul.hMul (f i) (g i)) 2) (HMul.hMul (s.expect fun i => HPow.hPow (f i) 2) (s.expect fun i => HPow.hPow (g i) 2))","decl":"/-- **Cauchy-Schwarz inequality** in terms of `Finset.expect`. -/\nlemma expect_mul_sq_le_sq_mul_sq (s : Finset Î¹) (f g : Î¹ â†’ R) :\n    (ğ”¼ i âˆˆ s, f i * g i) ^ 2 â‰¤ (ğ”¼ i âˆˆ s, f i ^ 2) * ğ”¼ i âˆˆ s, g i ^ 2 := by\n  simp only [expect, smul_pow, inv_pow, smul_mul_smul_comm, â† sq]\n  gcongr\n  exact sum_mul_sq_le_sq_mul_sq ..\n\n"}
{"name":"Fintype.expect_eq_zero_iff_of_nonneg","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ³ : Fintype Î¹\ninstâœÂ² : OrderedAddCommMonoid Î±\ninstâœÂ¹ : Module NNRat Î±\nf : Î¹ â†’ Î±\ninstâœ : Nonempty Î¹\nhf : LE.le 0 f\nâŠ¢ Iff (Eq (Finset.univ.expect fun i => f i) 0) (Eq f 0)","decl":"lemma expect_eq_zero_iff_of_nonneg [Nonempty Î¹] (hf : 0 â‰¤ f) : ğ”¼ i, f i = 0 â†” f = 0 := by\n  simp [expect, sum_eq_zero_iff_of_nonneg hf, univ_nonempty.ne_empty]\n\n"}
{"name":"Fintype.expect_eq_zero_iff_of_nonpos","module":"Mathlib.Algebra.Order.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ³ : Fintype Î¹\ninstâœÂ² : OrderedAddCommMonoid Î±\ninstâœÂ¹ : Module NNRat Î±\nf : Î¹ â†’ Î±\ninstâœ : Nonempty Î¹\nhf : LE.le f 0\nâŠ¢ Iff (Eq (Finset.univ.expect fun i => f i) 0) (Eq f 0)","decl":"lemma expect_eq_zero_iff_of_nonpos [Nonempty Î¹] (hf : f â‰¤ 0) : ğ”¼ i, f i = 0 â†” f = 0 := by\n  simp [expect, sum_eq_zero_iff_of_nonpos hf, univ_nonempty.ne_empty]\n\n"}
