{"name":"List.rdrop_nil","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\nn : Nat\n⊢ Eq (List.nil.rdrop n) List.nil","decl":"@[simp]\ntheorem rdrop_nil : rdrop ([] : List α) n = [] := by simp [rdrop]\n\n"}
{"name":"List.rdrop_zero","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (l.rdrop 0) l","decl":"@[simp]\ntheorem rdrop_zero : rdrop l 0 = l := by simp [rdrop]\n\n"}
{"name":"List.rdrop_eq_reverse_drop_reverse","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\nl : List α\nn : Nat\n⊢ Eq (l.rdrop n) (List.drop n l.reverse).reverse","decl":"theorem rdrop_eq_reverse_drop_reverse : l.rdrop n = reverse (l.reverse.drop n) := by\n  rw [rdrop]\n  induction' l using List.reverseRecOn with xs x IH generalizing n\n  · simp\n  · cases n\n    · simp [take_append]\n    · simp [take_append_eq_append_take, IH]\n\n"}
{"name":"List.rdrop_concat_succ","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\nl : List α\nn : Nat\nx : α\n⊢ Eq ((HAppend.hAppend l (List.cons x List.nil)).rdrop (HAdd.hAdd n 1)) (l.rdrop n)","decl":"@[simp]\ntheorem rdrop_concat_succ (x : α) : rdrop (l ++ [x]) (n + 1) = rdrop l n := by\n  simp [rdrop_eq_reverse_drop_reverse]\n\n"}
{"name":"List.rtake_nil","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\nn : Nat\n⊢ Eq (List.nil.rtake n) List.nil","decl":"@[simp]\ntheorem rtake_nil : rtake ([] : List α) n = [] := by simp [rtake]\n\n"}
{"name":"List.rtake_zero","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (l.rtake 0) List.nil","decl":"@[simp]\ntheorem rtake_zero : rtake l 0 = [] := by simp [rtake]\n\n"}
{"name":"List.rtake_eq_reverse_take_reverse","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\nl : List α\nn : Nat\n⊢ Eq (l.rtake n) (List.take n l.reverse).reverse","decl":"theorem rtake_eq_reverse_take_reverse : l.rtake n = reverse (l.reverse.take n) := by\n  rw [rtake]\n  induction' l using List.reverseRecOn with xs x IH generalizing n\n  · simp\n  · cases n\n    · exact drop_length _\n    · simp [drop_append_eq_append_drop, IH]\n\n"}
{"name":"List.rtake_concat_succ","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\nl : List α\nn : Nat\nx : α\n⊢ Eq ((HAppend.hAppend l (List.cons x List.nil)).rtake (HAdd.hAdd n 1)) (HAppend.hAppend (l.rtake n) (List.cons x List.nil))","decl":"@[simp]\ntheorem rtake_concat_succ (x : α) : rtake (l ++ [x]) (n + 1) = rtake l n ++ [x] := by\n  simp [rtake_eq_reverse_take_reverse]\n\n"}
{"name":"List.rdropWhile_nil","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\np : α → Bool\n⊢ Eq (List.rdropWhile p List.nil) List.nil","decl":"@[simp]\ntheorem rdropWhile_nil : rdropWhile p ([] : List α) = [] := by simp [rdropWhile, dropWhile]\n\n"}
{"name":"List.rdropWhile_concat","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\np : α → Bool\nl : List α\nx : α\n⊢ Eq (List.rdropWhile p (HAppend.hAppend l (List.cons x List.nil))) (ite (Eq (p x) Bool.true) (List.rdropWhile p l) (HAppend.hAppend l (List.cons x List.nil)))","decl":"theorem rdropWhile_concat (x : α) :\n    rdropWhile p (l ++ [x]) = if p x then rdropWhile p l else l ++ [x] := by\n  simp only [rdropWhile, dropWhile, reverse_append, reverse_singleton, singleton_append]\n  split_ifs with h <;> simp [h]\n\n"}
{"name":"List.rdropWhile_concat_pos","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\np : α → Bool\nl : List α\nx : α\nh : Eq (p x) Bool.true\n⊢ Eq (List.rdropWhile p (HAppend.hAppend l (List.cons x List.nil))) (List.rdropWhile p l)","decl":"@[simp]\ntheorem rdropWhile_concat_pos (x : α) (h : p x) : rdropWhile p (l ++ [x]) = rdropWhile p l := by\n  rw [rdropWhile_concat, if_pos h]\n\n"}
{"name":"List.rdropWhile_concat_neg","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\np : α → Bool\nl : List α\nx : α\nh : Not (Eq (p x) Bool.true)\n⊢ Eq (List.rdropWhile p (HAppend.hAppend l (List.cons x List.nil))) (HAppend.hAppend l (List.cons x List.nil))","decl":"@[simp]\ntheorem rdropWhile_concat_neg (x : α) (h : ¬p x) : rdropWhile p (l ++ [x]) = l ++ [x] := by\n  rw [rdropWhile_concat, if_neg h]\n\n"}
{"name":"List.rdropWhile_singleton","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\np : α → Bool\nx : α\n⊢ Eq (List.rdropWhile p (List.cons x List.nil)) (ite (Eq (p x) Bool.true) List.nil (List.cons x List.nil))","decl":"theorem rdropWhile_singleton (x : α) : rdropWhile p [x] = if p x then [] else [x] := by\n  rw [← nil_append [x], rdropWhile_concat, rdropWhile_nil]\n\n"}
{"name":"List.rdropWhile_last_not","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\np : α → Bool\nl : List α\nhl : Ne (List.rdropWhile p l) List.nil\n⊢ Not (Eq (p ((List.rdropWhile p l).getLast hl)) Bool.true)","decl":"theorem rdropWhile_last_not (hl : l.rdropWhile p ≠ []) : ¬p ((rdropWhile p l).getLast hl) := by\n  simp_rw [rdropWhile]\n  rw [getLast_reverse, head_dropWhile_not p]\n  simp\n\n"}
{"name":"List.rdropWhile_prefix","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\np : α → Bool\nl : List α\n⊢ (List.rdropWhile p l).IsPrefix l","decl":"theorem rdropWhile_prefix : l.rdropWhile p <+: l := by\n  rw [← reverse_suffix, rdropWhile, reverse_reverse]\n  exact dropWhile_suffix _\n\n"}
{"name":"List.rdropWhile_eq_nil_iff","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\np : α → Bool\nl : List α\n⊢ Iff (Eq (List.rdropWhile p l) List.nil) (∀ (x : α), Membership.mem l x → Eq (p x) Bool.true)","decl":"@[simp]\ntheorem rdropWhile_eq_nil_iff : rdropWhile p l = [] ↔ ∀ x ∈ l, p x := by simp [rdropWhile]\n\n-- it is in this file because it requires `List.Infix`\n"}
{"name":"List.dropWhile_eq_self_iff","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\np : α → Bool\nl : List α\n⊢ Iff (Eq (List.dropWhile p l) l) (∀ (hl : LT.lt 0 l.length), Not (Eq (p (l.get ⟨0, hl⟩)) Bool.true))","decl":"@[simp]\ntheorem dropWhile_eq_self_iff : dropWhile p l = l ↔ ∀ hl : 0 < l.length, ¬p (l.get ⟨0, hl⟩) := by\n  cases' l with hd tl\n  · simp only [dropWhile, true_iff]\n    intro h\n    by_contra\n    rwa [length_nil, lt_self_iff_false] at h\n  · rw [dropWhile]\n    refine ⟨fun h => ?_, fun h => ?_⟩\n    · intro _ H\n      rw [get] at H\n      refine (cons_ne_self hd tl) (Sublist.antisymm ?_ (sublist_cons_self _ _))\n      rw [← h]\n      simp only [H]\n      exact List.IsSuffix.sublist (dropWhile_suffix p)\n    · have := h (by simp only [length, Nat.succ_pos])\n      rw [get] at this\n      simp_rw [this]\n\n"}
{"name":"List.rdropWhile_eq_self_iff","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\np : α → Bool\nl : List α\n⊢ Iff (Eq (List.rdropWhile p l) l) (∀ (hl : Ne l List.nil), Not (Eq (p (l.getLast hl)) Bool.true))","decl":"@[simp]\ntheorem rdropWhile_eq_self_iff : rdropWhile p l = l ↔ ∀ hl : l ≠ [], ¬p (l.getLast hl) := by\n  simp [rdropWhile, reverse_eq_iff, getLast_eq_getElem, Nat.pos_iff_ne_zero]\n\n"}
{"name":"List.dropWhile_idempotent","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\np : α → Bool\nl : List α\n⊢ Eq (List.dropWhile p (List.dropWhile p l)) (List.dropWhile p l)","decl":"theorem dropWhile_idempotent : dropWhile p (dropWhile p l) = dropWhile p l := by\n  simp only [dropWhile_eq_self_iff]\n  exact fun h => dropWhile_get_zero_not p l h\n\n"}
{"name":"List.rdropWhile_idempotent","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\np : α → Bool\nl : List α\n⊢ Eq (List.rdropWhile p (List.rdropWhile p l)) (List.rdropWhile p l)","decl":"theorem rdropWhile_idempotent : rdropWhile p (rdropWhile p l) = rdropWhile p l :=\n  rdropWhile_eq_self_iff.mpr (rdropWhile_last_not _ _)\n\n"}
{"name":"List.rtakeWhile_nil","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\np : α → Bool\n⊢ Eq (List.rtakeWhile p List.nil) List.nil","decl":"@[simp]\ntheorem rtakeWhile_nil : rtakeWhile p ([] : List α) = [] := by simp [rtakeWhile, takeWhile]\n\n"}
{"name":"List.rtakeWhile_concat","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\np : α → Bool\nl : List α\nx : α\n⊢ Eq (List.rtakeWhile p (HAppend.hAppend l (List.cons x List.nil))) (ite (Eq (p x) Bool.true) (HAppend.hAppend (List.rtakeWhile p l) (List.cons x List.nil)) List.nil)","decl":"theorem rtakeWhile_concat (x : α) :\n    rtakeWhile p (l ++ [x]) = if p x then rtakeWhile p l ++ [x] else [] := by\n  simp only [rtakeWhile, takeWhile, reverse_append, reverse_singleton, singleton_append]\n  split_ifs with h <;> simp [h]\n\n"}
{"name":"List.rtakeWhile_concat_pos","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\np : α → Bool\nl : List α\nx : α\nh : Eq (p x) Bool.true\n⊢ Eq (List.rtakeWhile p (HAppend.hAppend l (List.cons x List.nil))) (HAppend.hAppend (List.rtakeWhile p l) (List.cons x List.nil))","decl":"@[simp]\ntheorem rtakeWhile_concat_pos (x : α) (h : p x) :\n    rtakeWhile p (l ++ [x]) = rtakeWhile p l ++ [x] := by rw [rtakeWhile_concat, if_pos h]\n\n"}
{"name":"List.rtakeWhile_concat_neg","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\np : α → Bool\nl : List α\nx : α\nh : Not (Eq (p x) Bool.true)\n⊢ Eq (List.rtakeWhile p (HAppend.hAppend l (List.cons x List.nil))) List.nil","decl":"@[simp]\ntheorem rtakeWhile_concat_neg (x : α) (h : ¬p x) : rtakeWhile p (l ++ [x]) = [] := by\n  rw [rtakeWhile_concat, if_neg h]\n\n"}
{"name":"List.rtakeWhile_suffix","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\np : α → Bool\nl : List α\n⊢ (List.rtakeWhile p l).IsSuffix l","decl":"theorem rtakeWhile_suffix : l.rtakeWhile p <:+ l := by\n  rw [← reverse_prefix, rtakeWhile, reverse_reverse]\n  exact takeWhile_prefix _\n\n"}
{"name":"List.rtakeWhile_eq_self_iff","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\np : α → Bool\nl : List α\n⊢ Iff (Eq (List.rtakeWhile p l) l) (∀ (x : α), Membership.mem l x → Eq (p x) Bool.true)","decl":"@[simp]\ntheorem rtakeWhile_eq_self_iff : rtakeWhile p l = l ↔ ∀ x ∈ l, p x := by\n  simp [rtakeWhile, reverse_eq_iff]\n\n-- Porting note: This needed a lot of rewriting.\n"}
{"name":"List.rtakeWhile_eq_nil_iff","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\np : α → Bool\nl : List α\n⊢ Iff (Eq (List.rtakeWhile p l) List.nil) (∀ (hl : Ne l List.nil), Not (Eq (p (l.getLast hl)) Bool.true))","decl":"@[simp]\ntheorem rtakeWhile_eq_nil_iff : rtakeWhile p l = [] ↔ ∀ hl : l ≠ [], ¬p (l.getLast hl) := by\n  induction' l using List.reverseRecOn with l a\n  · simp only [rtakeWhile, takeWhile, reverse_nil, true_iff]\n    intro f; contradiction\n  · simp only [rtakeWhile, reverse_append, reverse_cons, reverse_nil, nil_append, singleton_append,\n      takeWhile, ne_eq, cons_ne_self, not_false_eq_true, getLast_append_of_ne_nil,\n      getLast_singleton]\n    refine ⟨fun h => ?_ , fun h => ?_⟩\n    · split at h <;> simp_all\n    · simp [h]\n\n"}
{"name":"List.mem_rtakeWhile_imp","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\np : α → Bool\nl : List α\nx : α\nhx : Membership.mem (List.rtakeWhile p l) x\n⊢ Eq (p x) Bool.true","decl":"theorem mem_rtakeWhile_imp {x : α} (hx : x ∈ rtakeWhile p l) : p x := by\n  rw [rtakeWhile, mem_reverse] at hx\n  exact mem_takeWhile_imp hx\n\n"}
{"name":"List.rtakeWhile_idempotent","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\np : α → Bool\nl : List α\n⊢ Eq (List.rtakeWhile p (List.rtakeWhile p l)) (List.rtakeWhile p l)","decl":"theorem rtakeWhile_idempotent (p : α → Bool) (l : List α) :\n    rtakeWhile p (rtakeWhile p l) = rtakeWhile p l :=\n  rtakeWhile_eq_self_iff.mpr fun _ => mem_rtakeWhile_imp\n\n"}
{"name":"List.rdrop_add","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\nl : List α\ni j : Nat\n⊢ Eq ((l.rdrop i).rdrop j) (l.rdrop (HAdd.hAdd i j))","decl":"lemma rdrop_add (i j : ℕ) : (l.rdrop i).rdrop j = l.rdrop (i + j) := by\n  simp_rw [rdrop_eq_reverse_drop_reverse, reverse_reverse, drop_drop]\n\n"}
{"name":"List.rdrop_append_length","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\nl₁ l₂ : List α\n⊢ Eq ((HAppend.hAppend l₁ l₂).rdrop l₂.length) l₁","decl":"@[simp]\nlemma rdrop_append_length {l₁ l₂ : List α} :\n    List.rdrop (l₁ ++ l₂) (List.length l₂) = l₁ := by\n  rw [rdrop_eq_reverse_drop_reverse, ← length_reverse l₂,\n      reverse_append, drop_left, reverse_reverse]\n\n"}
{"name":"List.rdrop_append_of_le_length","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\nl₁ l₂ : List α\nk : Nat\na✝ : LE.le k l₂.length\n⊢ Eq ((HAppend.hAppend l₁ l₂).rdrop k) (HAppend.hAppend l₁ (l₂.rdrop k))","decl":"lemma rdrop_append_of_le_length {l₁ l₂ : List α} (k : ℕ) :\n    k ≤ length l₂ → List.rdrop (l₁ ++ l₂) k = l₁ ++ List.rdrop l₂ k := by\n  intro hk\n  rw [← length_reverse] at hk\n  rw [rdrop_eq_reverse_drop_reverse, reverse_append, drop_append_of_le_length hk,\n    reverse_append, reverse_reverse, ← rdrop_eq_reverse_drop_reverse]\n\n"}
{"name":"List.rdrop_append_length_add","module":"Mathlib.Data.List.DropRight","initialProofState":"α : Type u_1\nl₁ l₂ : List α\nk : Nat\n⊢ Eq ((HAppend.hAppend l₁ l₂).rdrop (HAdd.hAdd l₂.length k)) (l₁.rdrop k)","decl":"@[simp]\nlemma rdrop_append_length_add {l₁ l₂ : List α} (k : ℕ) :\n    List.rdrop (l₁ ++ l₂) (length l₂ + k) = List.rdrop l₁ k := by\n  rw [← rdrop_add, rdrop_append_length]\n\n"}
