{"name":"ProbabilityTheory.instIsZeroOrProbabilityMeasureUniformOn","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\ns : Set Ω\n⊢ MeasureTheory.IsZeroOrProbabilityMeasure (ProbabilityTheory.uniformOn s)","decl":"instance {s : Set Ω} : IsZeroOrProbabilityMeasure (uniformOn s) := by\n  unfold uniformOn; infer_instance\n\n"}
{"name":"ProbabilityTheory.uniformOn_empty_meas","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\n⊢ Eq (ProbabilityTheory.uniformOn EmptyCollection.emptyCollection) 0","decl":"@[simp]\ntheorem uniformOn_empty_meas : (uniformOn ∅ : Measure Ω) = 0 := by simp [uniformOn]\n\n"}
{"name":"ProbabilityTheory.condCount_empty_meas","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\n⊢ Eq (ProbabilityTheory.uniformOn EmptyCollection.emptyCollection) 0","decl":"@[deprecated (since := \"2024-10-09\")]\nalias condCount_empty_meas := uniformOn_empty_meas\n\n"}
{"name":"ProbabilityTheory.uniformOn_empty","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\ns : Set Ω\n⊢ Eq ((ProbabilityTheory.uniformOn s) EmptyCollection.emptyCollection) 0","decl":"theorem uniformOn_empty {s : Set Ω} : uniformOn s ∅ = 0 := by simp\n\n"}
{"name":"ProbabilityTheory.condCount_empty","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\ns : Set Ω\n⊢ Eq ((ProbabilityTheory.uniformOn s) EmptyCollection.emptyCollection) 0","decl":"@[deprecated (since := \"2024-10-09\")]\nalias condCount_empty := uniformOn_empty\n\n"}
{"name":"ProbabilityTheory.uniformOn_eq_zero'","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\ns : Set Ω\nhs : MeasurableSet s\n⊢ Iff (Eq (ProbabilityTheory.uniformOn s) 0) (Or s.Infinite (Eq s EmptyCollection.emptyCollection))","decl":"/-- See `uniformOn_eq_zero` for a version assuming `MeasurableSingletonClass Ω` instead of\n`MeasurableSet s`. -/\n@[simp] lemma uniformOn_eq_zero' (hs : MeasurableSet s) : uniformOn s = 0 ↔ s.Infinite ∨ s = ∅ := by\n  simp [uniformOn, hs]\n\n"}
{"name":"ProbabilityTheory.uniformOn_eq_zero","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ns : Set Ω\ninst✝ : MeasurableSingletonClass Ω\n⊢ Iff (Eq (ProbabilityTheory.uniformOn s) 0) (Or s.Infinite (Eq s EmptyCollection.emptyCollection))","decl":"/-- See `uniformOn_eq_zero'` for a version assuming `MeasurableSet s` instead of\n`MeasurableSingletonClass Ω`. -/\n@[simp] lemma uniformOn_eq_zero [MeasurableSingletonClass Ω] :\n    uniformOn s = 0 ↔ s.Infinite ∨ s = ∅ := by simp [uniformOn]\n\n"}
{"name":"ProbabilityTheory.finite_of_uniformOn_ne_zero","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\ns t : Set Ω\nh : Ne ((ProbabilityTheory.uniformOn s) t) 0\n⊢ s.Finite","decl":"theorem finite_of_uniformOn_ne_zero {s t : Set Ω} (h : uniformOn s t ≠ 0) : s.Finite := by\n  by_contra hs'\n  simp [uniformOn, cond, Measure.count_apply_infinite hs'] at h\n\n"}
{"name":"ProbabilityTheory.finite_of_condCount_ne_zero","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\ns t : Set Ω\nh : Ne ((ProbabilityTheory.uniformOn s) t) 0\n⊢ s.Finite","decl":"@[deprecated (since := \"2024-10-09\")]\nalias finite_of_condCount_ne_zero := finite_of_uniformOn_ne_zero\n\n"}
{"name":"ProbabilityTheory.uniformOn_univ","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : Fintype Ω\ns : Set Ω\n⊢ Eq ((ProbabilityTheory.uniformOn Set.univ) s) (HDiv.hDiv (MeasureTheory.Measure.count s) ↑(Fintype.card Ω))","decl":"theorem uniformOn_univ [Fintype Ω] {s : Set Ω} :\n    uniformOn Set.univ s = Measure.count s / Fintype.card Ω := by\n  rw [uniformOn, cond_apply MeasurableSet.univ, ← ENNReal.div_eq_inv_mul, Set.univ_inter]\n  congr\n  rw [← Finset.coe_univ, Measure.count_apply, Finset.univ.tsum_subtype' fun _ => (1 : ENNReal)]\n  · simp [Finset.card_univ]\n  · exact (@Finset.coe_univ Ω _).symm ▸ MeasurableSet.univ\n\n"}
{"name":"ProbabilityTheory.condCount_univ","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : Fintype Ω\ns : Set Ω\n⊢ Eq ((ProbabilityTheory.uniformOn Set.univ) s) (HDiv.hDiv (MeasureTheory.Measure.count s) ↑(Fintype.card Ω))","decl":"@[deprecated (since := \"2024-10-09\")]\nalias condCount_univ := uniformOn_univ\n\n"}
{"name":"ProbabilityTheory.uniformOn_isProbabilityMeasure","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns : Set Ω\nhs : s.Finite\nhs' : s.Nonempty\n⊢ MeasureTheory.IsProbabilityMeasure (ProbabilityTheory.uniformOn s)","decl":"theorem uniformOn_isProbabilityMeasure {s : Set Ω} (hs : s.Finite) (hs' : s.Nonempty) :\n    IsProbabilityMeasure (uniformOn s) := by\n  apply cond_isProbabilityMeasure_of_finite\n  · rwa [Measure.count_ne_zero_iff]\n  · exact (Measure.count_apply_lt_top.2 hs).ne\n\n"}
{"name":"ProbabilityTheory.condCount_isProbabilityMeasure","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns : Set Ω\nhs : s.Finite\nhs' : s.Nonempty\n⊢ MeasureTheory.IsProbabilityMeasure (ProbabilityTheory.uniformOn s)","decl":"@[deprecated (since := \"2024-10-09\")]\nalias condCount_isProbabilityMeasure := uniformOn_isProbabilityMeasure\n\n"}
{"name":"ProbabilityTheory.uniformOn_singleton","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\ninst✝¹ : MeasurableSingletonClass Ω\nω : Ω\nt : Set Ω\ninst✝ : Decidable (Membership.mem t ω)\n⊢ Eq ((ProbabilityTheory.uniformOn (Singleton.singleton ω)) t) (ite (Membership.mem t ω) 1 0)","decl":"theorem uniformOn_singleton (ω : Ω) (t : Set Ω) [Decidable (ω ∈ t)] :\n    uniformOn {ω} t = if ω ∈ t then 1 else 0 := by\n  rw [uniformOn, cond_apply (measurableSet_singleton ω), Measure.count_singleton, inv_one,\n    one_mul]\n  split_ifs\n  · rw [(by simpa : ({ω} : Set Ω) ∩ t = {ω}), Measure.count_singleton]\n  · rw [(by simpa : ({ω} : Set Ω) ∩ t = ∅), Measure.count_empty]\n\n"}
{"name":"ProbabilityTheory.condCount_singleton","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\ninst✝¹ : MeasurableSingletonClass Ω\nω : Ω\nt : Set Ω\ninst✝ : Decidable (Membership.mem t ω)\n⊢ Eq ((ProbabilityTheory.uniformOn (Singleton.singleton ω)) t) (ite (Membership.mem t ω) 1 0)","decl":"@[deprecated (since := \"2024-10-09\")]\nalias condCount_singleton := uniformOn_singleton\n\n"}
{"name":"ProbabilityTheory.uniformOn_inter_self","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns t : Set Ω\nhs : s.Finite\n⊢ Eq ((ProbabilityTheory.uniformOn s) (Inter.inter s t)) ((ProbabilityTheory.uniformOn s) t)","decl":"theorem uniformOn_inter_self (hs : s.Finite) : uniformOn s (s ∩ t) = uniformOn s t := by\n  rw [uniformOn, cond_inter_self hs.measurableSet]\n\n"}
{"name":"ProbabilityTheory.condCount_inter_self","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns t : Set Ω\nhs : s.Finite\n⊢ Eq ((ProbabilityTheory.uniformOn s) (Inter.inter s t)) ((ProbabilityTheory.uniformOn s) t)","decl":"@[deprecated (since := \"2024-10-09\")]\nalias condCount_inter_self := uniformOn_inter_self\n\n"}
{"name":"ProbabilityTheory.uniformOn_self","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns : Set Ω\nhs : s.Finite\nhs' : s.Nonempty\n⊢ Eq ((ProbabilityTheory.uniformOn s) s) 1","decl":"theorem uniformOn_self (hs : s.Finite) (hs' : s.Nonempty) : uniformOn s s = 1 := by\n  rw [uniformOn, cond_apply hs.measurableSet, Set.inter_self, ENNReal.inv_mul_cancel]\n  · rwa [Measure.count_ne_zero_iff]\n  · exact (Measure.count_apply_lt_top.2 hs).ne\n\n"}
{"name":"ProbabilityTheory.condCount_self","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns : Set Ω\nhs : s.Finite\nhs' : s.Nonempty\n⊢ Eq ((ProbabilityTheory.uniformOn s) s) 1","decl":"@[deprecated (since := \"2024-10-09\")]\nalias condCount_self := uniformOn_self\n\n"}
{"name":"ProbabilityTheory.uniformOn_eq_one_of","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns t : Set Ω\nhs : s.Finite\nhs' : s.Nonempty\nht : HasSubset.Subset s t\n⊢ Eq ((ProbabilityTheory.uniformOn s) t) 1","decl":"theorem uniformOn_eq_one_of (hs : s.Finite) (hs' : s.Nonempty) (ht : s ⊆ t) :\n    uniformOn s t = 1 := by\n  haveI := uniformOn_isProbabilityMeasure hs hs'\n  refine eq_of_le_of_not_lt prob_le_one ?_\n  rw [not_lt, ← uniformOn_self hs hs']\n  exact measure_mono ht\n\n"}
{"name":"ProbabilityTheory.condCount_eq_one_of","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns t : Set Ω\nhs : s.Finite\nhs' : s.Nonempty\nht : HasSubset.Subset s t\n⊢ Eq ((ProbabilityTheory.uniformOn s) t) 1","decl":"@[deprecated (since := \"2024-10-09\")]\nalias condCount_eq_one_of := uniformOn_eq_one_of\n\n"}
{"name":"ProbabilityTheory.pred_true_of_uniformOn_eq_one","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns t : Set Ω\nh : Eq ((ProbabilityTheory.uniformOn s) t) 1\n⊢ HasSubset.Subset s t","decl":"theorem pred_true_of_uniformOn_eq_one (h : uniformOn s t = 1) : s ⊆ t := by\n  have hsf := finite_of_uniformOn_ne_zero (by rw [h]; exact one_ne_zero)\n  rw [uniformOn, cond_apply hsf.measurableSet, mul_comm] at h\n  replace h := ENNReal.eq_inv_of_mul_eq_one_left h\n  rw [inv_inv, Measure.count_apply_finite _ hsf, Measure.count_apply_finite _ (hsf.inter_of_left _),\n    Nat.cast_inj] at h\n  suffices s ∩ t = s by exact this ▸ fun x hx => hx.2\n  rw [← @Set.Finite.toFinset_inj _ _ _ (hsf.inter_of_left _) hsf]\n  exact Finset.eq_of_subset_of_card_le (Set.Finite.toFinset_mono s.inter_subset_left) h.ge\n\n"}
{"name":"ProbabilityTheory.pred_true_of_condCount_eq_one","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns t : Set Ω\nh : Eq ((ProbabilityTheory.uniformOn s) t) 1\n⊢ HasSubset.Subset s t","decl":"@[deprecated (since := \"2024-10-09\")]\nalias pred_true_of_condCount_eq_one := pred_true_of_uniformOn_eq_one\n\n"}
{"name":"ProbabilityTheory.uniformOn_eq_zero_iff","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns t : Set Ω\nhs : s.Finite\n⊢ Iff (Eq ((ProbabilityTheory.uniformOn s) t) 0) (Eq (Inter.inter s t) EmptyCollection.emptyCollection)","decl":"theorem uniformOn_eq_zero_iff (hs : s.Finite) : uniformOn s t = 0 ↔ s ∩ t = ∅ := by\n  simp [uniformOn, cond_apply hs.measurableSet, Measure.count_apply_eq_top, Set.not_infinite.2 hs,\n    Measure.count_apply_finite _ (hs.inter_of_left _)]\n\n"}
{"name":"ProbabilityTheory.condCount_eq_zero_iff","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns t : Set Ω\nhs : s.Finite\n⊢ Iff (Eq ((ProbabilityTheory.uniformOn s) t) 0) (Eq (Inter.inter s t) EmptyCollection.emptyCollection)","decl":"@[deprecated (since := \"2024-10-09\")]\nalias condCount_eq_zero_iff := uniformOn_eq_zero_iff\n\n"}
{"name":"ProbabilityTheory.uniformOn_of_univ","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns : Set Ω\nhs : s.Finite\nhs' : s.Nonempty\n⊢ Eq ((ProbabilityTheory.uniformOn s) Set.univ) 1","decl":"theorem uniformOn_of_univ (hs : s.Finite) (hs' : s.Nonempty) : uniformOn s Set.univ = 1 :=\n  uniformOn_eq_one_of hs hs' s.subset_univ\n\n"}
{"name":"ProbabilityTheory.condCount_of_univ","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns : Set Ω\nhs : s.Finite\nhs' : s.Nonempty\n⊢ Eq ((ProbabilityTheory.uniformOn s) Set.univ) 1","decl":"@[deprecated (since := \"2024-10-09\")]\nalias condCount_of_univ := uniformOn_of_univ\n\n"}
{"name":"ProbabilityTheory.uniformOn_inter","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns t u : Set Ω\nhs : s.Finite\n⊢ Eq ((ProbabilityTheory.uniformOn s) (Inter.inter t u)) (HMul.hMul ((ProbabilityTheory.uniformOn (Inter.inter s t)) u) ((ProbabilityTheory.uniformOn s) t))","decl":"theorem uniformOn_inter (hs : s.Finite) :\n    uniformOn s (t ∩ u) = uniformOn (s ∩ t) u * uniformOn s t := by\n  by_cases hst : s ∩ t = ∅\n  · rw [hst, uniformOn_empty_meas, Measure.coe_zero, Pi.zero_apply, zero_mul,\n      uniformOn_eq_zero_iff hs, ← Set.inter_assoc, hst, Set.empty_inter]\n  rw [uniformOn, uniformOn, cond_apply hs.measurableSet, cond_apply hs.measurableSet,\n    cond_apply (hs.inter_of_left _).measurableSet, mul_comm _ (Measure.count (s ∩ t)),\n    ← mul_assoc, mul_comm _ (Measure.count (s ∩ t)), ← mul_assoc, ENNReal.mul_inv_cancel, one_mul,\n    mul_comm, Set.inter_assoc]\n  · rwa [← Measure.count_eq_zero_iff] at hst\n  · exact (Measure.count_apply_lt_top.2 <| hs.inter_of_left _).ne\n\n"}
{"name":"ProbabilityTheory.condCount_inter","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns t u : Set Ω\nhs : s.Finite\n⊢ Eq ((ProbabilityTheory.uniformOn s) (Inter.inter t u)) (HMul.hMul ((ProbabilityTheory.uniformOn (Inter.inter s t)) u) ((ProbabilityTheory.uniformOn s) t))","decl":"@[deprecated (since := \"2024-10-09\")]\nalias condCount_inter := uniformOn_inter\n\n"}
{"name":"ProbabilityTheory.uniformOn_inter'","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns t u : Set Ω\nhs : s.Finite\n⊢ Eq ((ProbabilityTheory.uniformOn s) (Inter.inter t u)) (HMul.hMul ((ProbabilityTheory.uniformOn (Inter.inter s u)) t) ((ProbabilityTheory.uniformOn s) u))","decl":"theorem uniformOn_inter' (hs : s.Finite) :\n    uniformOn s (t ∩ u) = uniformOn (s ∩ u) t * uniformOn s u := by\n  rw [← Set.inter_comm]\n  exact uniformOn_inter hs\n\n"}
{"name":"ProbabilityTheory.condCount_inter'","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns t u : Set Ω\nhs : s.Finite\n⊢ Eq ((ProbabilityTheory.uniformOn s) (Inter.inter t u)) (HMul.hMul ((ProbabilityTheory.uniformOn (Inter.inter s u)) t) ((ProbabilityTheory.uniformOn s) u))","decl":"@[deprecated (since := \"2024-10-09\")]\nalias condCount_inter' := uniformOn_inter'\n\n"}
{"name":"ProbabilityTheory.uniformOn_union","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns t u : Set Ω\nhs : s.Finite\nhtu : Disjoint t u\n⊢ Eq ((ProbabilityTheory.uniformOn s) (Union.union t u)) (HAdd.hAdd ((ProbabilityTheory.uniformOn s) t) ((ProbabilityTheory.uniformOn s) u))","decl":"theorem uniformOn_union (hs : s.Finite) (htu : Disjoint t u) :\n    uniformOn s (t ∪ u) = uniformOn s t + uniformOn s u := by\n  rw [uniformOn, cond_apply hs.measurableSet, cond_apply hs.measurableSet,\n    cond_apply hs.measurableSet, Set.inter_union_distrib_left, measure_union, mul_add]\n  exacts [htu.mono inf_le_right inf_le_right, (hs.inter_of_left _).measurableSet]\n\n"}
{"name":"ProbabilityTheory.condCount_union","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns t u : Set Ω\nhs : s.Finite\nhtu : Disjoint t u\n⊢ Eq ((ProbabilityTheory.uniformOn s) (Union.union t u)) (HAdd.hAdd ((ProbabilityTheory.uniformOn s) t) ((ProbabilityTheory.uniformOn s) u))","decl":"@[deprecated (since := \"2024-10-09\")]\nalias condCount_union := uniformOn_union\n\n"}
{"name":"ProbabilityTheory.uniformOn_compl","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns t : Set Ω\nhs : s.Finite\nhs' : s.Nonempty\n⊢ Eq (HAdd.hAdd ((ProbabilityTheory.uniformOn s) t) ((ProbabilityTheory.uniformOn s) (HasCompl.compl t))) 1","decl":"theorem uniformOn_compl (t : Set Ω) (hs : s.Finite) (hs' : s.Nonempty) :\n    uniformOn s t + uniformOn s tᶜ = 1 := by\n  rw [← uniformOn_union hs disjoint_compl_right, Set.union_compl_self,\n    (uniformOn_isProbabilityMeasure hs hs').measure_univ]\n\n"}
{"name":"ProbabilityTheory.condCount_compl","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns t : Set Ω\nhs : s.Finite\nhs' : s.Nonempty\n⊢ Eq (HAdd.hAdd ((ProbabilityTheory.uniformOn s) t) ((ProbabilityTheory.uniformOn s) (HasCompl.compl t))) 1","decl":"@[deprecated (since := \"2024-10-09\")]\nalias condCount_compl := uniformOn_compl\n\n"}
{"name":"ProbabilityTheory.uniformOn_disjoint_union","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns t u : Set Ω\nhs : s.Finite\nht : t.Finite\nhst : Disjoint s t\n⊢ Eq (HAdd.hAdd (HMul.hMul ((ProbabilityTheory.uniformOn s) u) ((ProbabilityTheory.uniformOn (Union.union s t)) s)) (HMul.hMul ((ProbabilityTheory.uniformOn t) u) ((ProbabilityTheory.uniformOn (Union.union s t)) t))) ((ProbabilityTheory.uniformOn (Union.union s t)) u)","decl":"theorem uniformOn_disjoint_union (hs : s.Finite) (ht : t.Finite) (hst : Disjoint s t) :\n    uniformOn s u * uniformOn (s ∪ t) s + uniformOn t u * uniformOn (s ∪ t) t =\n      uniformOn (s ∪ t) u := by\n  rcases s.eq_empty_or_nonempty with (rfl | hs') <;> rcases t.eq_empty_or_nonempty with (rfl | ht')\n  · simp\n  · simp [uniformOn_self ht ht']\n  · simp [uniformOn_self hs hs']\n  rw [uniformOn, uniformOn, uniformOn, cond_apply hs.measurableSet,\n    cond_apply ht.measurableSet, cond_apply (hs.union ht).measurableSet,\n    cond_apply (hs.union ht).measurableSet, cond_apply (hs.union ht).measurableSet]\n  conv_lhs =>\n    rw [Set.union_inter_cancel_left, Set.union_inter_cancel_right,\n      mul_comm (Measure.count (s ∪ t))⁻¹, mul_comm (Measure.count (s ∪ t))⁻¹, ← mul_assoc,\n      ← mul_assoc, mul_comm _ (Measure.count s), mul_comm _ (Measure.count t), ← mul_assoc,\n      ← mul_assoc]\n  rw [ENNReal.mul_inv_cancel, ENNReal.mul_inv_cancel, one_mul, one_mul, ← add_mul, ← measure_union,\n    Set.union_inter_distrib_right, mul_comm]\n  exacts [hst.mono inf_le_left inf_le_left, (ht.inter_of_left _).measurableSet,\n    Measure.count_ne_zero ht', (Measure.count_apply_lt_top.2 ht).ne, Measure.count_ne_zero hs',\n    (Measure.count_apply_lt_top.2 hs).ne]\n\n"}
{"name":"ProbabilityTheory.condCount_disjoint_union","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns t u : Set Ω\nhs : s.Finite\nht : t.Finite\nhst : Disjoint s t\n⊢ Eq (HAdd.hAdd (HMul.hMul ((ProbabilityTheory.uniformOn s) u) ((ProbabilityTheory.uniformOn (Union.union s t)) s)) (HMul.hMul ((ProbabilityTheory.uniformOn t) u) ((ProbabilityTheory.uniformOn (Union.union s t)) t))) ((ProbabilityTheory.uniformOn (Union.union s t)) u)","decl":"@[deprecated (since := \"2024-10-09\")]\nalias condCount_disjoint_union := uniformOn_disjoint_union\n\n"}
{"name":"ProbabilityTheory.uniformOn_add_compl_eq","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns u t : Set Ω\nhs : s.Finite\n⊢ Eq (HAdd.hAdd (HMul.hMul ((ProbabilityTheory.uniformOn (Inter.inter s u)) t) ((ProbabilityTheory.uniformOn s) u)) (HMul.hMul ((ProbabilityTheory.uniformOn (Inter.inter s (HasCompl.compl u))) t) ((ProbabilityTheory.uniformOn s) (HasCompl.compl u)))) ((ProbabilityTheory.uniformOn s) t)","decl":"/-- A version of the law of total probability for counting probabilities. -/\ntheorem uniformOn_add_compl_eq (u t : Set Ω) (hs : s.Finite) :\n    uniformOn (s ∩ u) t * uniformOn s u + uniformOn (s ∩ uᶜ) t * uniformOn s uᶜ =\n      uniformOn s t := by\n  -- Porting note: The original proof used `conv_rhs`. However, that tactic timed out.\n  have : uniformOn s t = (uniformOn (s ∩ u) t * uniformOn (s ∩ u ∪ s ∩ uᶜ) (s ∩ u) +\n      uniformOn (s ∩ uᶜ) t * uniformOn (s ∩ u ∪ s ∩ uᶜ) (s ∩ uᶜ)) := by\n    rw [uniformOn_disjoint_union (hs.inter_of_left _) (hs.inter_of_left _)\n      (disjoint_compl_right.mono inf_le_right inf_le_right), Set.inter_union_compl]\n  rw [this]\n  simp [uniformOn_inter_self hs]\n\n"}
{"name":"ProbabilityTheory.condCount_add_compl_eq","module":"Mathlib.Probability.UniformOn","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSingletonClass Ω\ns u t : Set Ω\nhs : s.Finite\n⊢ Eq (HAdd.hAdd (HMul.hMul ((ProbabilityTheory.uniformOn (Inter.inter s u)) t) ((ProbabilityTheory.uniformOn s) u)) (HMul.hMul ((ProbabilityTheory.uniformOn (Inter.inter s (HasCompl.compl u))) t) ((ProbabilityTheory.uniformOn s) (HasCompl.compl u)))) ((ProbabilityTheory.uniformOn s) t)","decl":"@[deprecated (since := \"2024-10-09\")]\nalias condCount_add_compl_eq := uniformOn_add_compl_eq\n\n"}
