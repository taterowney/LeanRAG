{"name":"IsFreeGroupoid.unique_lift","module":"Mathlib.GroupTheory.FreeGroup.NielsenSchreier","initialProofState":"G : Type u_1\ninst‚úù¬π : CategoryTheory.Groupoid G\nself : IsFreeGroupoid G\nX : Type v\ninst‚úù : Group X\nf : Quiver.Labelling (IsFreeGroupoid.Generators G) X\n‚ä¢ ExistsUnique fun F => ‚àÄ (a b : IsFreeGroupoid.Generators G) (g : Quiver.Hom a b), Eq (F.map (IsFreeGroupoid.of g)) (f g)","decl":"/-- A groupoid `G` is free when we have the following data:\n - a quiver on `IsFreeGroupoid.Generators G` (a type synonym for `G`)\n - a function `of` taking a generating arrow to a morphism in `G`\n - such that a functor from `G` to any group `X` is uniquely determined\n   by assigning labels in `X` to the generating arrows.\n\n   This definition is nonstandard. Normally one would require that functors `G ‚•§ X`\n   to any _groupoid_ `X` are given by graph homomorphisms from `generators`. -/\nclass IsFreeGroupoid (G) [Groupoid.{v} G] where\n  quiverGenerators : Quiver.{v + 1} (IsFreeGroupoid.Generators G)\n  of : ‚àÄ {a b : IsFreeGroupoid.Generators G}, (a ‚ü∂ b) ‚Üí ((show G from a) ‚ü∂ b)\n  unique_lift :\n    ‚àÄ {X : Type v} [Group X] (f : Labelling (IsFreeGroupoid.Generators G) X),\n      ‚àÉ! F : G ‚•§ CategoryTheory.SingleObj X, ‚àÄ (a b) (g : a ‚ü∂ b), F.map (of g) = f g\n\n"}
{"name":"IsFreeGroupoid.ext_functor_iff","module":"Mathlib.GroupTheory.FreeGroup.NielsenSchreier","initialProofState":"G : Type u_1\ninst‚úù¬≤ : CategoryTheory.Groupoid G\ninst‚úù¬π : IsFreeGroupoid G\nX : Type v\ninst‚úù : Group X\nf g : CategoryTheory.Functor G (CategoryTheory.SingleObj X)\n‚ä¢ Iff (Eq f g) (‚àÄ (a b : IsFreeGroupoid.Generators G) (e : Quiver.Hom a b), Eq (f.map (IsFreeGroupoid.of e)) (g.map (IsFreeGroupoid.of e)))","decl":"/-- Two functors from a free groupoid to a group are equal when they agree on the generating\nquiver. -/\n@[ext]\ntheorem ext_functor {G} [Groupoid.{v} G] [IsFreeGroupoid G] {X : Type v} [Group X]\n    (f g : G ‚•§ CategoryTheory.SingleObj X) (h : ‚àÄ (a b) (e : a ‚ü∂ b), f.map (of e) = g.map (of e)) :\n    f = g :=\n  let ‚ü®_, _, u‚ü© := @unique_lift G _ _ X _ fun (a b : Generators G) (e : a ‚ü∂ b) => g.map (of e)\n  _root_.trans (u _ h) (u _ fun _ _ _ => rfl).symm\n\n"}
{"name":"IsFreeGroupoid.ext_functor","module":"Mathlib.GroupTheory.FreeGroup.NielsenSchreier","initialProofState":"G : Type u_1\ninst‚úù¬≤ : CategoryTheory.Groupoid G\ninst‚úù¬π : IsFreeGroupoid G\nX : Type v\ninst‚úù : Group X\nf g : CategoryTheory.Functor G (CategoryTheory.SingleObj X)\nh : ‚àÄ (a b : IsFreeGroupoid.Generators G) (e : Quiver.Hom a b), Eq (f.map (IsFreeGroupoid.of e)) (g.map (IsFreeGroupoid.of e))\n‚ä¢ Eq f g","decl":"/-- Two functors from a free groupoid to a group are equal when they agree on the generating\nquiver. -/\n@[ext]\ntheorem ext_functor {G} [Groupoid.{v} G] [IsFreeGroupoid G] {X : Type v} [Group X]\n    (f g : G ‚•§ CategoryTheory.SingleObj X) (h : ‚àÄ (a b) (e : a ‚ü∂ b), f.map (of e) = g.map (of e)) :\n    f = g :=\n  let ‚ü®_, _, u‚ü© := @unique_lift G _ _ X _ fun (a b : Generators G) (e : a ‚ü∂ b) => g.map (of e)\n  _root_.trans (u _ h) (u _ fun _ _ _ => rfl).symm\n\n"}
{"name":"IsFreeGroupoid.SpanningTree.treeHom_eq","module":"Mathlib.GroupTheory.FreeGroup.NielsenSchreier","initialProofState":"G : Type u\ninst‚úù¬≤ : CategoryTheory.Groupoid G\ninst‚úù¬π : IsFreeGroupoid G\nT : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G))\ninst‚úù : Quiver.Arborescence (WideSubquiver.toType (Quiver.Symmetrify (IsFreeGroupoid.Generators G)) T)\na : G\np : Quiver.Path (Quiver.root (WideSubquiver.toType (Quiver.Symmetrify (IsFreeGroupoid.Generators G)) T)) a\n‚ä¢ Eq (IsFreeGroupoid.SpanningTree.treeHom T a) (IsFreeGroupoid.SpanningTree.homOfPath T p)","decl":"/-- Any path to `a` gives `treeHom T a`, since paths in the tree are unique. -/\ntheorem treeHom_eq {a : G} (p : Path (root T) a) : treeHom T a = homOfPath T p := by\n  rw [treeHom, Unique.default_eq]\n\n"}
{"name":"IsFreeGroupoid.SpanningTree.treeHom_root","module":"Mathlib.GroupTheory.FreeGroup.NielsenSchreier","initialProofState":"G : Type u\ninst‚úù¬≤ : CategoryTheory.Groupoid G\ninst‚úù¬π : IsFreeGroupoid G\nT : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G))\ninst‚úù : Quiver.Arborescence (WideSubquiver.toType (Quiver.Symmetrify (IsFreeGroupoid.Generators G)) T)\n‚ä¢ Eq (IsFreeGroupoid.SpanningTree.treeHom T (IsFreeGroupoid.SpanningTree.root' T)) (CategoryTheory.CategoryStruct.id (IsFreeGroupoid.SpanningTree.root' T))","decl":"@[simp]\ntheorem treeHom_root : treeHom T (root' T) = ùüô _ :=\n  -- this should just be `treeHom_eq T Path.nil`, but Lean treats `homOfPath` with suspicion.\n    _root_.trans\n    (treeHom_eq T Path.nil) rfl\n\n"}
{"name":"IsFreeGroupoid.SpanningTree.loopOfHom_eq_id","module":"Mathlib.GroupTheory.FreeGroup.NielsenSchreier","initialProofState":"G : Type u\ninst‚úù¬≤ : CategoryTheory.Groupoid G\ninst‚úù¬π : IsFreeGroupoid G\nT : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G))\ninst‚úù : Quiver.Arborescence (WideSubquiver.toType (Quiver.Symmetrify (IsFreeGroupoid.Generators G)) T)\na b : IsFreeGroupoid.Generators G\ne : Quiver.Hom a b\nH : Membership.mem (Quiver.wideSubquiverSymmetrify T a b) e\n‚ä¢ Eq (IsFreeGroupoid.SpanningTree.loopOfHom T (IsFreeGroupoid.of e)) (CategoryTheory.CategoryStruct.id (IsFreeGroupoid.SpanningTree.root' T))","decl":"/-- Turning an edge in the spanning tree into a loop gives the identity loop. -/\ntheorem loopOfHom_eq_id {a b : Generators G} (e) (H : e ‚àà wideSubquiverSymmetrify T a b) :\n    loopOfHom T (of e) = ùüô (root' T) := by\n  rw [loopOfHom, ‚Üê Category.assoc, IsIso.comp_inv_eq, Category.id_comp]\n  cases' H with H H\n  ¬∑ rw [treeHom_eq T (Path.cons default ‚ü®Sum.inl e, H‚ü©), homOfPath]\n    rfl\n  ¬∑ rw [treeHom_eq T (Path.cons default ‚ü®Sum.inr e, H‚ü©), homOfPath]\n    simp only [IsIso.inv_hom_id, Category.comp_id, Category.assoc, treeHom]\n\n"}
{"name":"IsFreeGroupoid.SpanningTree.functorOfMonoidHom_map","module":"Mathlib.GroupTheory.FreeGroup.NielsenSchreier","initialProofState":"G : Type u\ninst‚úù¬≥ : CategoryTheory.Groupoid G\ninst‚úù¬≤ : IsFreeGroupoid G\nT : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G))\ninst‚úù¬π : Quiver.Arborescence (WideSubquiver.toType (Quiver.Symmetrify (IsFreeGroupoid.Generators G)) T)\nX : Type u_1\ninst‚úù : Monoid X\nf : MonoidHom (CategoryTheory.End (IsFreeGroupoid.SpanningTree.root' T)) X\nX‚úù Y‚úù : G\np : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((IsFreeGroupoid.SpanningTree.functorOfMonoidHom T f).map p) (f (IsFreeGroupoid.SpanningTree.loopOfHom T p))","decl":"/-- Since a hom gives a loop, any homomorphism from the vertex group at the root\n    extends to a functor on the whole groupoid. -/\n@[simps]\ndef functorOfMonoidHom {X} [Monoid X] (f : End (root' T) ‚Üí* X) :\n    G ‚•§ CategoryTheory.SingleObj X where\n  obj _ := ()\n  map p := f (loopOfHom T p)\n  map_id := by\n    intro a\n    dsimp only [loopOfHom]\n    rw [Category.id_comp, IsIso.hom_inv_id, ‚Üê End.one_def, f.map_one, id_as_one]\n  map_comp := by\n    intros\n    rw [comp_as_mul, ‚Üê f.map_mul]\n    simp only [IsIso.inv_hom_id_assoc, loopOfHom, End.mul_def, Category.assoc]\n\n"}
{"name":"IsFreeGroupoid.SpanningTree.functorOfMonoidHom_obj","module":"Mathlib.GroupTheory.FreeGroup.NielsenSchreier","initialProofState":"G : Type u\ninst‚úù¬≥ : CategoryTheory.Groupoid G\ninst‚úù¬≤ : IsFreeGroupoid G\nT : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G))\ninst‚úù¬π : Quiver.Arborescence (WideSubquiver.toType (Quiver.Symmetrify (IsFreeGroupoid.Generators G)) T)\nX : Type u_1\ninst‚úù : Monoid X\nf : MonoidHom (CategoryTheory.End (IsFreeGroupoid.SpanningTree.root' T)) X\nx‚úù : G\n‚ä¢ Eq ((IsFreeGroupoid.SpanningTree.functorOfMonoidHom T f).obj x‚úù) Unit.unit","decl":"/-- Since a hom gives a loop, any homomorphism from the vertex group at the root\n    extends to a functor on the whole groupoid. -/\n@[simps]\ndef functorOfMonoidHom {X} [Monoid X] (f : End (root' T) ‚Üí* X) :\n    G ‚•§ CategoryTheory.SingleObj X where\n  obj _ := ()\n  map p := f (loopOfHom T p)\n  map_id := by\n    intro a\n    dsimp only [loopOfHom]\n    rw [Category.id_comp, IsIso.hom_inv_id, ‚Üê End.one_def, f.map_one, id_as_one]\n  map_comp := by\n    intros\n    rw [comp_as_mul, ‚Üê f.map_mul]\n    simp only [IsIso.inv_hom_id_assoc, loopOfHom, End.mul_def, Category.assoc]\n\n"}
{"name":"IsFreeGroupoid.SpanningTree.endIsFree","module":"Mathlib.GroupTheory.FreeGroup.NielsenSchreier","initialProofState":"G : Type u\ninst‚úù¬≤ : CategoryTheory.Groupoid G\ninst‚úù¬π : IsFreeGroupoid G\nT : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G))\ninst‚úù : Quiver.Arborescence (WideSubquiver.toType (Quiver.Symmetrify (IsFreeGroupoid.Generators G)) T)\n‚ä¢ IsFreeGroup (CategoryTheory.End (IsFreeGroupoid.SpanningTree.root' T))","decl":"open scoped Classical in\n/-- Given a free groupoid and an arborescence of its generating quiver, the vertex\n    group at the root is freely generated by loops coming from generating arrows\n    in the complement of the tree. -/\nlemma endIsFree : IsFreeGroup (End (root' T)) :=\n  IsFreeGroup.ofUniqueLift ((wideSubquiverEquivSetTotal <| wideSubquiverSymmetrify T)·∂ú : Set _)\n    (fun e => loopOfHom T (of e.val.hom))\n    (by\n      intro X _ f\n      let f' : Labelling (Generators G) X := fun a b e =>\n        if h : e ‚àà wideSubquiverSymmetrify T a b then 1 else f ‚ü®‚ü®a, b, e‚ü©, h‚ü©\n      rcases unique_lift f' with ‚ü®F', hF', uF'‚ü©\n      refine ‚ü®F'.mapEnd _, ?_, ?_‚ü©\n      ¬∑ suffices ‚àÄ {x y} (q : x ‚ü∂ y), F'.map (loopOfHom T q) = (F'.map q : X) by\n          rintro ‚ü®‚ü®a, b, e‚ü©, h‚ü©\n          erw [Functor.mapEnd_apply, this, hF']\n          exact dif_neg h\n        intros x y q\n        suffices ‚àÄ {a} (p : Path (root T) a), F'.map (homOfPath T p) = 1 by\n          simp only [this, treeHom, comp_as_mul, inv_as_inv, loopOfHom, inv_one, mul_one,\n            one_mul, Functor.map_inv, Functor.map_comp]\n        intro a p\n        induction' p with b c p e ih\n        ¬∑ rw [homOfPath, F'.map_id, id_as_one]\n        rw [homOfPath, F'.map_comp, comp_as_mul, ih, mul_one]\n        rcases e with ‚ü®e | e, eT‚ü©\n        ¬∑ rw [hF']\n          exact dif_pos (Or.inl eT)\n        ¬∑ rw [F'.map_inv, inv_as_inv, inv_eq_one, hF']\n          exact dif_pos (Or.inr eT)\n      ¬∑ intro E hE\n        ext x\n        suffices (functorOfMonoidHom T E).map x = F'.map x by\n          simpa only [loopOfHom, functorOfMonoidHom, IsIso.inv_id, treeHom_root,\n            Category.id_comp, Category.comp_id] using this\n        congr\n        apply uF'\n        intro a b e\n        change E (loopOfHom T _) = dite _ _ _\n        split_ifs with h\n        ¬∑ rw [loopOfHom_eq_id T e h, ‚Üê End.one_def, E.map_one]\n        ¬∑ exact hE ‚ü®‚ü®a, b, e‚ü©, h‚ü©)\n\n"}
{"name":"IsFreeGroupoid.path_nonempty_of_hom","module":"Mathlib.GroupTheory.FreeGroup.NielsenSchreier","initialProofState":"G : Type u\ninst‚úù¬π : CategoryTheory.Groupoid G\ninst‚úù : IsFreeGroupoid G\na b : G\na‚úù : Nonempty (Quiver.Hom a b)\n‚ä¢ Nonempty (Quiver.Path (IsFreeGroupoid.symgen a) (IsFreeGroupoid.symgen b))","decl":"/-- If there exists a morphism `a ‚Üí b` in a free groupoid, then there also exists a zigzag\nfrom `a` to `b` in the generating quiver. -/\ntheorem path_nonempty_of_hom {G} [Groupoid.{u, u} G] [IsFreeGroupoid G] {a b : G} :\n    Nonempty (a ‚ü∂ b) ‚Üí Nonempty (Path (symgen a) (symgen b)) := by\n  rintro ‚ü®p‚ü©\n  rw [‚Üê @WeaklyConnectedComponent.eq (Generators G), eq_comm, ‚Üê FreeGroup.of_injective.eq_iff, ‚Üê\n    mul_inv_eq_one]\n  let X := FreeGroup (WeaklyConnectedComponent <| Generators G)\n  let f : G ‚Üí X := fun g => FreeGroup.of (WeaklyConnectedComponent.mk g)\n  let F : G ‚•§ CategoryTheory.SingleObj.{u} (X : Type u) := SingleObj.differenceFunctor f\n  change (F.map p) = ((@CategoryTheory.Functor.const G _ _ (SingleObj.category X)).obj ()).map p\n  congr; ext\n  rw [Functor.const_obj_map, id_as_one, differenceFunctor_map, @mul_inv_eq_one _ _ (f _)]\n  apply congr_arg FreeGroup.of\n  apply (WeaklyConnectedComponent.eq _ _).mpr\n  exact ‚ü®Hom.toPath (Sum.inr (by assumption))‚ü©\n\n"}
{"name":"IsFreeGroupoid.generators_connected","module":"Mathlib.GroupTheory.FreeGroup.NielsenSchreier","initialProofState":"G : Type u\ninst‚úù¬≤ : CategoryTheory.Groupoid G\ninst‚úù¬π : CategoryTheory.IsConnected G\ninst‚úù : IsFreeGroupoid G\nr : G\n‚ä¢ Quiver.RootedConnected (IsFreeGroupoid.symgen r)","decl":"/-- Given a connected free groupoid, its generating quiver is rooted-connected. -/\ninstance generators_connected (G) [Groupoid.{u, u} G] [IsConnected G] [IsFreeGroupoid G] (r : G) :\n    RootedConnected (symgen r) :=\n  ‚ü®fun b => path_nonempty_of_hom (CategoryTheory.nonempty_hom_of_preconnected_groupoid r b)‚ü©\n\n"}
{"name":"IsFreeGroupoid.endIsFreeOfConnectedFree","module":"Mathlib.GroupTheory.FreeGroup.NielsenSchreier","initialProofState":"G : Type u\ninst‚úù¬≤ : CategoryTheory.Groupoid G\ninst‚úù¬π : CategoryTheory.IsConnected G\ninst‚úù : IsFreeGroupoid G\nr : G\n‚ä¢ IsFreeGroup (CategoryTheory.End r)","decl":"/-- A vertex group in a free connected groupoid is free. With some work one could drop the\nconnectedness assumption, by looking at connected components. -/\ninstance endIsFreeOfConnectedFree\n    {G : Type u} [Groupoid G] [IsConnected G] [IsFreeGroupoid G] (r : G) :\n    IsFreeGroup.{u} (End r) :=\n  SpanningTree.endIsFree <| geodesicSubtree (symgen r)\n\n"}
{"name":"subgroupIsFreeOfIsFree","module":"Mathlib.GroupTheory.FreeGroup.NielsenSchreier","initialProofState":"G : Type u\ninst‚úù¬π : Group G\ninst‚úù : IsFreeGroup G\nH : Subgroup G\n‚ä¢ IsFreeGroup (Subtype fun x => Membership.mem H x)","decl":"/-- The Nielsen-Schreier theorem: a subgroup of a free group is free. -/\ninstance subgroupIsFreeOfIsFree {G : Type u} [Group G] [IsFreeGroup G] (H : Subgroup G) :\n    IsFreeGroup H :=\n  IsFreeGroup.ofMulEquiv (endMulEquivSubgroup H)\n"}
