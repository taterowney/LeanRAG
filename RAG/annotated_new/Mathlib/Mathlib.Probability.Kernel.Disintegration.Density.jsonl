{"name":"ProbabilityTheory.Kernel.densityProcess_def","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nn : Nat\na : Î±\ns : Set Î²\nâŠ¢ Eq (fun t => Îº.densityProcess Î½ n a t s) fun t => (HDiv.hDiv ((Îº a) (SProd.sprod (MeasurableSpace.countablePartitionSet n t) s)) ((Î½ a) (MeasurableSpace.countablePartitionSet n t))).toReal","decl":"lemma densityProcess_def (Îº : Kernel Î± (Î³ Ã— Î²)) (Î½ : Kernel Î± Î³) (n : â„•) (a : Î±) (s : Set Î²) :\n    (fun t â†¦ densityProcess Îº Î½ n a t s)\n      = fun t â†¦ (Îº a (countablePartitionSet n t Ã—Ë¢ s) / Î½ a (countablePartitionSet n t)).toReal :=\n  rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.measurable_densityProcess_countableFiltration_aux","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nn : Nat\ns : Set Î²\nhs : MeasurableSet s\nâŠ¢ Measurable fun p => HDiv.hDiv ((Îº p.1) (SProd.sprod (MeasurableSpace.countablePartitionSet n p.2) s)) ((Î½ p.1) (MeasurableSpace.countablePartitionSet n p.2))","decl":"lemma measurable_densityProcess_countableFiltration_aux (Îº : Kernel Î± (Î³ Ã— Î²)) (Î½ : Kernel Î± Î³)\n    (n : â„•) {s : Set Î²} (hs : MeasurableSet s) :\n    Measurable[mÎ±.prod (countableFiltration Î³ n)] (fun (p : Î± Ã— Î³) â†¦\n      Îº p.1 (countablePartitionSet n p.2 Ã—Ë¢ s) / Î½ p.1 (countablePartitionSet n p.2)) := by\n  change Measurable[mÎ±.prod (countableFiltration Î³ n)]\n      ((fun (p : Î± Ã— countablePartition Î³ n) â†¦ Îº p.1 (â†‘p.2 Ã—Ë¢ s) / Î½ p.1 p.2)\n        âˆ˜ (fun (p : Î± Ã— Î³) â†¦ (p.1, âŸ¨countablePartitionSet n p.2, countablePartitionSet_mem n p.2âŸ©)))\n  have h1 : @Measurable _ _ (mÎ±.prod âŠ¤) _\n      (fun p : Î± Ã— countablePartition Î³ n â†¦ Îº p.1 (â†‘p.2 Ã—Ë¢ s) / Î½ p.1 p.2) := by\n    refine Measurable.div ?_ ?_\n    Â· refine measurable_from_prod_countable (fun t â†¦ ?_)\n      exact Kernel.measurable_coe _ ((measurableSet_countablePartition _ t.prop).prod hs)\n    Â· refine measurable_from_prod_countable ?_\n      rintro âŸ¨t, htâŸ©\n      exact Kernel.measurable_coe _ (measurableSet_countablePartition _ ht)\n  refine h1.comp (measurable_fst.prod_mk ?_)\n  change @Measurable (Î± Ã— Î³) (countablePartition Î³ n) (mÎ±.prod (countableFiltration Î³ n)) âŠ¤\n    ((fun c â†¦ âŸ¨countablePartitionSet n c, countablePartitionSet_mem n câŸ©) âˆ˜ (fun p : Î± Ã— Î³ â†¦ p.2))\n  exact (measurable_countablePartitionSet_subtype n âŠ¤).comp measurable_snd\n\n"}
{"name":"ProbabilityTheory.Kernel.measurable_densityProcess_aux","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nn : Nat\ns : Set Î²\nhs : MeasurableSet s\nâŠ¢ Measurable fun p => HDiv.hDiv ((Îº p.1) (SProd.sprod (MeasurableSpace.countablePartitionSet n p.2) s)) ((Î½ p.1) (MeasurableSpace.countablePartitionSet n p.2))","decl":"lemma measurable_densityProcess_aux (Îº : Kernel Î± (Î³ Ã— Î²)) (Î½ : Kernel Î± Î³) (n : â„•)\n    {s : Set Î²} (hs : MeasurableSet s) :\n    Measurable (fun (p : Î± Ã— Î³) â†¦\n      Îº p.1 (countablePartitionSet n p.2 Ã—Ë¢ s) / Î½ p.1 (countablePartitionSet n p.2)) := by\n  refine Measurable.mono (measurable_densityProcess_countableFiltration_aux Îº Î½ n hs) ?_ le_rfl\n  exact sup_le_sup le_rfl (comap_mono ((countableFiltration Î³).le _))\n\n"}
{"name":"ProbabilityTheory.Kernel.measurable_densityProcess","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nn : Nat\ns : Set Î²\nhs : MeasurableSet s\nâŠ¢ Measurable fun p => Îº.densityProcess Î½ n p.1 p.2 s","decl":"lemma measurable_densityProcess (Îº : Kernel Î± (Î³ Ã— Î²)) (Î½ : Kernel Î± Î³) (n : â„•)\n    {s : Set Î²} (hs : MeasurableSet s) :\n    Measurable (fun (p : Î± Ã— Î³) â†¦ densityProcess Îº Î½ n p.1 p.2 s) :=\n  (measurable_densityProcess_aux Îº Î½ n hs).ennreal_toReal\n\n-- The following two lemmas also work without the `( :)`, but they are slow.\n"}
{"name":"ProbabilityTheory.Kernel.measurable_densityProcess_left","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nn : Nat\nx : Î³\ns : Set Î²\nhs : MeasurableSet s\nâŠ¢ Measurable fun a => Îº.densityProcess Î½ n a x s","decl":"lemma measurable_densityProcess_left (Îº : Kernel Î± (Î³ Ã— Î²)) (Î½ : Kernel Î± Î³) (n : â„•)\n    (x : Î³) {s : Set Î²} (hs : MeasurableSet s) :\n    Measurable (fun a â†¦ densityProcess Îº Î½ n a x s) :=\n  ((measurable_densityProcess Îº Î½ n hs).comp (measurable_id.prod_mk measurable_const):)\n\n"}
{"name":"ProbabilityTheory.Kernel.measurable_densityProcess_right","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nn : Nat\ns : Set Î²\na : Î±\nhs : MeasurableSet s\nâŠ¢ Measurable fun x => Îº.densityProcess Î½ n a x s","decl":"lemma measurable_densityProcess_right (Îº : Kernel Î± (Î³ Ã— Î²)) (Î½ : Kernel Î± Î³) (n : â„•)\n    {s : Set Î²} (a : Î±) (hs : MeasurableSet s) :\n    Measurable (fun x â†¦ densityProcess Îº Î½ n a x s) :=\n  ((measurable_densityProcess Îº Î½ n hs).comp (measurable_const.prod_mk measurable_id):)\n\n"}
{"name":"ProbabilityTheory.Kernel.measurable_countableFiltration_densityProcess","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nn : Nat\na : Î±\ns : Set Î²\nhs : MeasurableSet s\nâŠ¢ Measurable fun x => Îº.densityProcess Î½ n a x s","decl":"lemma measurable_countableFiltration_densityProcess (Îº : Kernel Î± (Î³ Ã— Î²)) (Î½ : Kernel Î± Î³) (n : â„•)\n    (a : Î±) {s : Set Î²} (hs : MeasurableSet s) :\n    Measurable[countableFiltration Î³ n] (fun x â†¦ densityProcess Îº Î½ n a x s) := by\n  refine @Measurable.ennreal_toReal _ (countableFiltration Î³ n) _ ?_\n  exact (measurable_densityProcess_countableFiltration_aux Îº Î½ n hs).comp measurable_prod_mk_left\n\n"}
{"name":"ProbabilityTheory.Kernel.stronglyMeasurable_countableFiltration_densityProcess","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nn : Nat\na : Î±\ns : Set Î²\nhs : MeasurableSet s\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => Îº.densityProcess Î½ n a x s","decl":"lemma stronglyMeasurable_countableFiltration_densityProcess (Îº : Kernel Î± (Î³ Ã— Î²)) (Î½ : Kernel Î± Î³)\n    (n : â„•) (a : Î±) {s : Set Î²} (hs : MeasurableSet s) :\n    StronglyMeasurable[countableFiltration Î³ n] (fun x â†¦ densityProcess Îº Î½ n a x s) :=\n  (measurable_countableFiltration_densityProcess Îº Î½ n a hs).stronglyMeasurable\n\n"}
{"name":"ProbabilityTheory.Kernel.adapted_densityProcess","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\na : Î±\ns : Set Î²\nhs : MeasurableSet s\nâŠ¢ MeasureTheory.Adapted (ProbabilityTheory.countableFiltration Î³) fun n x => Îº.densityProcess Î½ n a x s","decl":"lemma adapted_densityProcess (Îº : Kernel Î± (Î³ Ã— Î²)) (Î½ : Kernel Î± Î³) (a : Î±)\n    {s : Set Î²} (hs : MeasurableSet s) :\n    Adapted (countableFiltration Î³) (fun n x â†¦ densityProcess Îº Î½ n a x s) :=\n  fun n â†¦ stronglyMeasurable_countableFiltration_densityProcess Îº Î½ n a hs\n\n"}
{"name":"ProbabilityTheory.Kernel.densityProcess_nonneg","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nn : Nat\na : Î±\nx : Î³\ns : Set Î²\nâŠ¢ LE.le 0 (Îº.densityProcess Î½ n a x s)","decl":"lemma densityProcess_nonneg (Îº : Kernel Î± (Î³ Ã— Î²)) (Î½ : Kernel Î± Î³) (n : â„•)\n    (a : Î±) (x : Î³) (s : Set Î²) :\n    0 â‰¤ densityProcess Îº Î½ n a x s :=\n  ENNReal.toReal_nonneg\n\n"}
{"name":"ProbabilityTheory.Kernel.meas_countablePartitionSet_le_of_fst_le","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\nn : Nat\na : Î±\nx : Î³\ns : Set Î²\nâŠ¢ LE.le ((Îº a) (SProd.sprod (MeasurableSpace.countablePartitionSet n x) s)) ((Î½ a) (MeasurableSpace.countablePartitionSet n x))","decl":"lemma meas_countablePartitionSet_le_of_fst_le (hÎºÎ½ : fst Îº â‰¤ Î½) (n : â„•) (a : Î±) (x : Î³)\n    (s : Set Î²) :\n    Îº a (countablePartitionSet n x Ã—Ë¢ s) â‰¤ Î½ a (countablePartitionSet n x) := by\n  calc Îº a (countablePartitionSet n x Ã—Ë¢ s)\n    â‰¤ fst Îº a (countablePartitionSet n x) := by\n        rw [fst_apply' _ _ (measurableSet_countablePartitionSet _ _)]\n        refine measure_mono (fun x â†¦ ?_)\n        simp only [mem_prod, mem_setOf_eq, and_imp]\n        exact fun h _ â†¦ h\n  _ â‰¤ Î½ a (countablePartitionSet n x) := hÎºÎ½ a _\n\n"}
{"name":"ProbabilityTheory.Kernel.densityProcess_le_one","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\nn : Nat\na : Î±\nx : Î³\ns : Set Î²\nâŠ¢ LE.le (Îº.densityProcess Î½ n a x s) 1","decl":"lemma densityProcess_le_one (hÎºÎ½ : fst Îº â‰¤ Î½) (n : â„•) (a : Î±) (x : Î³) (s : Set Î²) :\n    densityProcess Îº Î½ n a x s â‰¤ 1 := by\n  refine ENNReal.toReal_le_of_le_ofReal zero_le_one (ENNReal.div_le_of_le_mul ?_)\n  rw [ENNReal.ofReal_one, one_mul]\n  exact meas_countablePartitionSet_le_of_fst_le hÎºÎ½ n a x s\n\n"}
{"name":"ProbabilityTheory.Kernel.eLpNorm_densityProcess_le","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\nn : Nat\na : Î±\ns : Set Î²\nâŠ¢ LE.le (MeasureTheory.eLpNorm (fun x => Îº.densityProcess Î½ n a x s) 1 (Î½ a)) ((Î½ a) Set.univ)","decl":"lemma eLpNorm_densityProcess_le (hÎºÎ½ : fst Îº â‰¤ Î½) (n : â„•) (a : Î±) (s : Set Î²) :\n    eLpNorm (fun x â†¦ densityProcess Îº Î½ n a x s) 1 (Î½ a) â‰¤ Î½ a univ := by\n  refine (eLpNorm_le_of_ae_bound (C := 1) (ae_of_all _ (fun x â†¦ ?_))).trans ?_\n  Â· simp only [Real.norm_eq_abs, abs_of_nonneg (densityProcess_nonneg Îº Î½ n a x s),\n      densityProcess_le_one hÎºÎ½ n a x s]\n  Â· simp\n\n"}
{"name":"ProbabilityTheory.Kernel.integrable_densityProcess","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\ninstâœ : ProbabilityTheory.IsFiniteKernel Î½\nn : Nat\na : Î±\ns : Set Î²\nhs : MeasurableSet s\nâŠ¢ MeasureTheory.Integrable (fun x => Îº.densityProcess Î½ n a x s) (Î½ a)","decl":"lemma integrable_densityProcess (hÎºÎ½ : fst Îº â‰¤ Î½) [IsFiniteKernel Î½] (n : â„•)\n    (a : Î±) {s : Set Î²} (hs : MeasurableSet s) :\n    Integrable (fun x â†¦ densityProcess Îº Î½ n a x s) (Î½ a) := by\n  rw [â† memâ„’p_one_iff_integrable]\n  refine âŸ¨Measurable.aestronglyMeasurable ?_, ?_âŸ©\n  Â· exact measurable_densityProcess_right Îº Î½ n a hs\n  Â· exact (eLpNorm_densityProcess_le hÎºÎ½ n a s).trans_lt (measure_lt_top _ _)\n\n"}
{"name":"ProbabilityTheory.Kernel.setIntegral_densityProcess_of_mem","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\nhÎ½ : ProbabilityTheory.IsFiniteKernel Î½\nn : Nat\na : Î±\ns : Set Î²\nhs : MeasurableSet s\nu : Set Î³\nhu : Membership.mem (MeasurableSpace.countablePartition Î³ n) u\nâŠ¢ Eq (MeasureTheory.integral ((Î½ a).restrict u) fun x => Îº.densityProcess Î½ n a x s) ((Îº a) (SProd.sprod u s)).toReal","decl":"lemma setIntegral_densityProcess_of_mem (hÎºÎ½ : fst Îº â‰¤ Î½) [hÎ½ : IsFiniteKernel Î½]\n    (n : â„•) (a : Î±) {s : Set Î²} (hs : MeasurableSet s) {u : Set Î³}\n    (hu : u âˆˆ countablePartition Î³ n) :\n    âˆ« x in u, densityProcess Îº Î½ n a x s âˆ‚(Î½ a) = (Îº a (u Ã—Ë¢ s)).toReal := by\n  have : IsFiniteKernel Îº := isFiniteKernel_of_isFiniteKernel_fst (h := isFiniteKernel_of_le hÎºÎ½)\n  have hu_meas : MeasurableSet u := measurableSet_countablePartition n hu\n  simp_rw [densityProcess]\n  rw [integral_toReal]\n  rotate_left\n  Â· refine Measurable.aemeasurable ?_\n    change Measurable ((fun (p : Î± Ã— _) â†¦ Îº p.1 (countablePartitionSet n p.2 Ã—Ë¢ s)\n      / Î½ p.1 (countablePartitionSet n p.2)) âˆ˜ (fun x â†¦ (a, x)))\n    exact (measurable_densityProcess_aux Îº Î½ n hs).comp measurable_prod_mk_left\n  Â· refine ae_of_all _ (fun x â†¦ ?_)\n    by_cases h0 : Î½ a (countablePartitionSet n x) = 0\n    Â· suffices Îº a (countablePartitionSet n x Ã—Ë¢ s) = 0 by simp [h0, this]\n      have h0' : fst Îº a (countablePartitionSet n x) = 0 :=\n        le_antisymm ((hÎºÎ½ a _).trans h0.le) zero_le'\n      rw [fst_apply' _ _ (measurableSet_countablePartitionSet _ _)] at h0'\n      refine measure_mono_null (fun x â†¦ ?_) h0'\n      simp only [mem_prod, mem_setOf_eq, and_imp]\n      exact fun h _ â†¦ h\n    Â· exact ENNReal.div_lt_top (measure_ne_top _ _) h0\n  congr\n  have : âˆ«â» x in u, Îº a (countablePartitionSet n x Ã—Ë¢ s) / Î½ a (countablePartitionSet n x) âˆ‚(Î½ a)\n      = âˆ«â» _ in u, Îº a (u Ã—Ë¢ s) / Î½ a u âˆ‚(Î½ a) := by\n    refine setLIntegral_congr_fun hu_meas (ae_of_all _ (fun t ht â†¦ ?_))\n    rw [countablePartitionSet_of_mem hu ht]\n  rw [this]\n  simp only [MeasureTheory.lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]\n  by_cases h0 : Î½ a u = 0\n  Â· simp only [h0, mul_zero]\n    have h0' : fst Îº a u = 0 := le_antisymm ((hÎºÎ½ a _).trans h0.le) zero_le'\n    rw [fst_apply' _ _ hu_meas] at h0'\n    refine (measure_mono_null ?_ h0').symm\n    intro p\n    simp only [mem_prod, mem_setOf_eq, and_imp]\n    exact fun h _ â†¦ h\n  rw [div_eq_mul_inv, mul_assoc, ENNReal.inv_mul_cancel h0, mul_one]\n  exact measure_ne_top _ _\n\n"}
{"name":"ProbabilityTheory.Kernel.setIntegral_densityProcess","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\ninstâœ : ProbabilityTheory.IsFiniteKernel Î½\nn : Nat\na : Î±\ns : Set Î²\nhs : MeasurableSet s\nA : Set Î³\nhA : MeasurableSet A\nâŠ¢ Eq (MeasureTheory.integral ((Î½ a).restrict A) fun x => Îº.densityProcess Î½ n a x s) ((Îº a) (SProd.sprod A s)).toReal","decl":"open scoped Function in -- required for scoped `on` notation\nlemma setIntegral_densityProcess (hÎºÎ½ : fst Îº â‰¤ Î½) [IsFiniteKernel Î½]\n    (n : â„•) (a : Î±) {s : Set Î²} (hs : MeasurableSet s) {A : Set Î³}\n    (hA : MeasurableSet[countableFiltration Î³ n] A) :\n    âˆ« x in A, densityProcess Îº Î½ n a x s âˆ‚(Î½ a) = (Îº a (A Ã—Ë¢ s)).toReal := by\n  have : IsFiniteKernel Îº := isFiniteKernel_of_isFiniteKernel_fst (h := isFiniteKernel_of_le hÎºÎ½)\n  obtain âŸ¨S, hS_subset, rflâŸ© := (measurableSet_generateFrom_countablePartition_iff _ _).mp hA\n  simp_rw [sUnion_eq_iUnion]\n  have h_disj : Pairwise (Disjoint on fun i : S â†¦ (i : Set Î³)) := by\n    intro u v huv\n    #adaptation_note /-- nightly-2024-03-16\n    Previously `Function.onFun` unfolded in the following `simp only`,\n    but now needs a `rw`.\n    This may be a bug: a no import minimization may be required.\n    simp only [Finset.coe_sort_coe, Function.onFun] -/\n    rw [Function.onFun]\n    refine disjoint_countablePartition (hS_subset (by simp)) (hS_subset (by simp)) ?_\n    rwa [ne_eq, â† Subtype.ext_iff]\n  rw [integral_iUnion, iUnion_prod_const, measure_iUnion,\n      ENNReal.tsum_toReal_eq (fun _ â†¦ measure_ne_top _ _)]\n  Â· congr with u\n    rw [setIntegral_densityProcess_of_mem hÎºÎ½ _ _ hs (hS_subset (by simp))]\n  Â· intro u v huv\n    simp only [Finset.coe_sort_coe, Set.disjoint_prod, disjoint_self, bot_eq_empty]\n    exact Or.inl (h_disj huv)\n  Â· exact fun _ â†¦ (measurableSet_countablePartition n (hS_subset (by simp))).prod hs\n  Â· exact fun _ â†¦ measurableSet_countablePartition n (hS_subset (by simp))\n  Â· exact h_disj\n  Â· exact (integrable_densityProcess hÎºÎ½ _ _ hs).integrableOn\n\n"}
{"name":"ProbabilityTheory.Kernel.integral_densityProcess","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\ninstâœ : ProbabilityTheory.IsFiniteKernel Î½\nn : Nat\na : Î±\ns : Set Î²\nhs : MeasurableSet s\nâŠ¢ Eq (MeasureTheory.integral (Î½ a) fun x => Îº.densityProcess Î½ n a x s) ((Îº a) (SProd.sprod Set.univ s)).toReal","decl":"lemma integral_densityProcess (hÎºÎ½ : fst Îº â‰¤ Î½) [IsFiniteKernel Î½]\n    (n : â„•) (a : Î±) {s : Set Î²} (hs : MeasurableSet s) :\n    âˆ« x, densityProcess Îº Î½ n a x s âˆ‚(Î½ a) = (Îº a (univ Ã—Ë¢ s)).toReal := by\n  rw [â† setIntegral_univ, setIntegral_densityProcess hÎºÎ½ _ _ hs MeasurableSet.univ]\n\n"}
{"name":"ProbabilityTheory.Kernel.setIntegral_densityProcess_of_le","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\ninstâœ : ProbabilityTheory.IsFiniteKernel Î½\nn m : Nat\nhnm : LE.le n m\na : Î±\ns : Set Î²\nhs : MeasurableSet s\nA : Set Î³\nhA : MeasurableSet A\nâŠ¢ Eq (MeasureTheory.integral ((Î½ a).restrict A) fun x => Îº.densityProcess Î½ m a x s) ((Îº a) (SProd.sprod A s)).toReal","decl":"lemma setIntegral_densityProcess_of_le (hÎºÎ½ : fst Îº â‰¤ Î½)\n    [IsFiniteKernel Î½] {n m : â„•} (hnm : n â‰¤ m) (a : Î±) {s : Set Î²} (hs : MeasurableSet s)\n    {A : Set Î³} (hA : MeasurableSet[countableFiltration Î³ n] A) :\n    âˆ« x in A, densityProcess Îº Î½ m a x s âˆ‚(Î½ a) = (Îº a (A Ã—Ë¢ s)).toReal :=\n  setIntegral_densityProcess hÎºÎ½ m a hs ((countableFiltration Î³).mono hnm A hA)\n\n"}
{"name":"ProbabilityTheory.Kernel.condExp_densityProcess","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\ninstâœ : ProbabilityTheory.IsFiniteKernel Î½\ni j : Nat\nhij : LE.le i j\na : Î±\ns : Set Î²\nhs : MeasurableSet s\nâŠ¢ (MeasureTheory.ae (Î½ a)).EventuallyEq (MeasureTheory.condExp (â†‘(ProbabilityTheory.countableFiltration Î³) i) (Î½ a) fun x => Îº.densityProcess Î½ j a x s) fun x => Îº.densityProcess Î½ i a x s","decl":"lemma condExp_densityProcess (hÎºÎ½ : fst Îº â‰¤ Î½) [IsFiniteKernel Î½]\n    {i j : â„•} (hij : i â‰¤ j) (a : Î±) {s : Set Î²} (hs : MeasurableSet s) :\n    (Î½ a)[fun x â†¦ densityProcess Îº Î½ j a x s | countableFiltration Î³ i]\n      =áµ[Î½ a] fun x â†¦ densityProcess Îº Î½ i a x s := by\n  refine (ae_eq_condExp_of_forall_setIntegral_eq ?_ ?_ ?_ ?_ ?_).symm\n  Â· exact integrable_densityProcess hÎºÎ½ j a hs\n  Â· exact fun _ _ _ â†¦ (integrable_densityProcess hÎºÎ½ _ _ hs).integrableOn\n  Â· intro x hx _\n    rw [setIntegral_densityProcess hÎºÎ½ i a hs hx,\n      setIntegral_densityProcess_of_le hÎºÎ½ hij a hs hx]\n  Â· exact StronglyMeasurable.aestronglyMeasurable\n      (stronglyMeasurable_countableFiltration_densityProcess Îº Î½ i a hs)\n\n"}
{"name":"ProbabilityTheory.Kernel.condexp_densityProcess","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\ninstâœ : ProbabilityTheory.IsFiniteKernel Î½\ni j : Nat\nhij : LE.le i j\na : Î±\ns : Set Î²\nhs : MeasurableSet s\nâŠ¢ (MeasureTheory.ae (Î½ a)).EventuallyEq (MeasureTheory.condExp (â†‘(ProbabilityTheory.countableFiltration Î³) i) (Î½ a) fun x => Îº.densityProcess Î½ j a x s) fun x => Îº.densityProcess Î½ i a x s","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_densityProcess := condExp_densityProcess\n\n"}
{"name":"ProbabilityTheory.Kernel.martingale_densityProcess","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\ninstâœ : ProbabilityTheory.IsFiniteKernel Î½\na : Î±\ns : Set Î²\nhs : MeasurableSet s\nâŠ¢ MeasureTheory.Martingale (fun n x => Îº.densityProcess Î½ n a x s) (ProbabilityTheory.countableFiltration Î³) (Î½ a)","decl":"lemma martingale_densityProcess (hÎºÎ½ : fst Îº â‰¤ Î½) [IsFiniteKernel Î½]\n    (a : Î±) {s : Set Î²} (hs : MeasurableSet s) :\n    Martingale (fun n x â†¦ densityProcess Îº Î½ n a x s) (countableFiltration Î³) (Î½ a) :=\n  âŸ¨adapted_densityProcess Îº Î½ a hs, fun _ _ h â†¦ condExp_densityProcess hÎºÎ½ h a hsâŸ©\n\n"}
{"name":"ProbabilityTheory.Kernel.densityProcess_mono_set","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\nn : Nat\na : Î±\nx : Î³\ns s' : Set Î²\nh : HasSubset.Subset s s'\nâŠ¢ LE.le (Îº.densityProcess Î½ n a x s) (Îº.densityProcess Î½ n a x s')","decl":"lemma densityProcess_mono_set (hÎºÎ½ : fst Îº â‰¤ Î½) (n : â„•) (a : Î±) (x : Î³)\n    {s s' : Set Î²} (h : s âŠ† s') :\n    densityProcess Îº Î½ n a x s â‰¤ densityProcess Îº Î½ n a x s' := by\n  unfold densityProcess\n  obtain hâ‚€ | hâ‚€ := eq_or_ne (Î½ a (countablePartitionSet n x)) 0\n  Â· simp [hâ‚€]\n  Â· gcongr\n    simp only [ne_eq, ENNReal.div_eq_top, hâ‚€, and_false, false_or, not_and, not_not]\n    exact eq_top_mono (meas_countablePartitionSet_le_of_fst_le hÎºÎ½ n a x s')\n\n"}
{"name":"ProbabilityTheory.Kernel.densityProcess_mono_kernel_left","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nÎº' : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nhÎºÎº' : LE.le Îº Îº'\nhÎº'Î½ : LE.le Îº'.fst Î½\nn : Nat\na : Î±\nx : Î³\ns : Set Î²\nâŠ¢ LE.le (Îº.densityProcess Î½ n a x s) (Îº'.densityProcess Î½ n a x s)","decl":"lemma densityProcess_mono_kernel_left {Îº' : Kernel Î± (Î³ Ã— Î²)} (hÎºÎº' : Îº â‰¤ Îº')\n    (hÎº'Î½ : fst Îº' â‰¤ Î½) (n : â„•) (a : Î±) (x : Î³) (s : Set Î²) :\n    densityProcess Îº Î½ n a x s â‰¤ densityProcess Îº' Î½ n a x s := by\n  unfold densityProcess\n  by_cases h0 : Î½ a (countablePartitionSet n x) = 0\n  Â· rw [h0, ENNReal.toReal_div, ENNReal.toReal_div]\n    simp\n  have h_le : Îº' a (countablePartitionSet n x Ã—Ë¢ s) â‰¤ Î½ a (countablePartitionSet n x) :=\n    meas_countablePartitionSet_le_of_fst_le hÎº'Î½ n a x s\n  gcongr\n  Â· simp only [ne_eq, ENNReal.div_eq_top, h0, and_false, false_or, not_and, not_not]\n    exact fun h_top â†¦ eq_top_mono h_le h_top\n  Â· apply hÎºÎº'\n\n"}
{"name":"ProbabilityTheory.Kernel.densityProcess_antitone_kernel_right","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ Î½' : ProbabilityTheory.Kernel Î± Î³\nhÎ½Î½' : LE.le Î½ Î½'\nhÎºÎ½ : LE.le Îº.fst Î½\nn : Nat\na : Î±\nx : Î³\ns : Set Î²\nâŠ¢ LE.le (Îº.densityProcess Î½' n a x s) (Îº.densityProcess Î½ n a x s)","decl":"lemma densityProcess_antitone_kernel_right {Î½' : Kernel Î± Î³}\n    (hÎ½Î½' : Î½ â‰¤ Î½') (hÎºÎ½ : fst Îº â‰¤ Î½) (n : â„•) (a : Î±) (x : Î³) (s : Set Î²) :\n    densityProcess Îº Î½' n a x s â‰¤ densityProcess Îº Î½ n a x s := by\n  unfold densityProcess\n  have h_le : Îº a (countablePartitionSet n x Ã—Ë¢ s) â‰¤ Î½ a (countablePartitionSet n x) :=\n    meas_countablePartitionSet_le_of_fst_le hÎºÎ½ n a x s\n  by_cases h0 : Î½ a (countablePartitionSet n x) = 0\n  Â· simp [le_antisymm (h_le.trans h0.le) zero_le', h0]\n  gcongr\n  Â· simp only [ne_eq, ENNReal.div_eq_top, h0, and_false, false_or, not_and, not_not]\n    exact fun h_top â†¦ eq_top_mono h_le h_top\n  Â· apply hÎ½Î½'\n\n"}
{"name":"ProbabilityTheory.Kernel.densityProcess_empty","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nn : Nat\na : Î±\nx : Î³\nâŠ¢ Eq (Îº.densityProcess Î½ n a x EmptyCollection.emptyCollection) 0","decl":"@[simp]\nlemma densityProcess_empty (Îº : Kernel Î± (Î³ Ã— Î²)) (Î½ : Kernel Î± Î³) (n : â„•) (a : Î±) (x : Î³) :\n    densityProcess Îº Î½ n a x âˆ… = 0 := by\n  simp [densityProcess]\n\n"}
{"name":"ProbabilityTheory.Kernel.tendsto_densityProcess_atTop_empty_of_antitone","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\ninstâœ : ProbabilityTheory.IsFiniteKernel Îº\nn : Nat\na : Î±\nx : Î³\nseq : Nat â†’ Set Î²\nhseq : Antitone seq\nhseq_iInter : Eq (Set.iInter fun i => seq i) EmptyCollection.emptyCollection\nhseq_meas : âˆ€ (m : Nat), MeasurableSet (seq m)\nâŠ¢ Filter.Tendsto (fun m => Îº.densityProcess Î½ n a x (seq m)) Filter.atTop (nhds (Îº.densityProcess Î½ n a x EmptyCollection.emptyCollection))","decl":"lemma tendsto_densityProcess_atTop_empty_of_antitone (Îº : Kernel Î± (Î³ Ã— Î²)) (Î½ : Kernel Î± Î³)\n    [IsFiniteKernel Îº] (n : â„•) (a : Î±) (x : Î³)\n    (seq : â„• â†’ Set Î²) (hseq : Antitone seq) (hseq_iInter : â‹‚ i, seq i = âˆ…)\n    (hseq_meas : âˆ€ m, MeasurableSet (seq m)) :\n    Tendsto (fun m â†¦ densityProcess Îº Î½ n a x (seq m)) atTop\n      (ğ“ (densityProcess Îº Î½ n a x âˆ…)) := by\n  simp_rw [densityProcess]\n  by_cases h0 : Î½ a (countablePartitionSet n x) = 0\n  Â· simp_rw [h0, ENNReal.toReal_div]\n    simp\n  refine (ENNReal.tendsto_toReal ?_).comp ?_\n  Â· rw [ne_eq, ENNReal.div_eq_top]\n    push_neg\n    simp\n  refine ENNReal.Tendsto.div_const ?_ (.inr h0)\n  have : Tendsto (fun m â†¦ Îº a (countablePartitionSet n x Ã—Ë¢ seq m)) atTop\n      (ğ“ ((Îº a) (â‹‚ n_1, countablePartitionSet n x Ã—Ë¢ seq n_1))) := by\n    apply tendsto_measure_iInter_atTop\n    Â· measurability\n    Â· exact fun _ _ h â†¦ prod_mono_right <| hseq h\n    Â· exact âŸ¨0, measure_ne_top _ _âŸ©\n  simpa only [â† prod_iInter, hseq_iInter] using this\n\n"}
{"name":"ProbabilityTheory.Kernel.tendsto_densityProcess_atTop_of_antitone","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\ninstâœ : ProbabilityTheory.IsFiniteKernel Îº\nn : Nat\na : Î±\nx : Î³\nseq : Nat â†’ Set Î²\nhseq : Antitone seq\nhseq_iInter : Eq (Set.iInter fun i => seq i) EmptyCollection.emptyCollection\nhseq_meas : âˆ€ (m : Nat), MeasurableSet (seq m)\nâŠ¢ Filter.Tendsto (fun m => Îº.densityProcess Î½ n a x (seq m)) Filter.atTop (nhds 0)","decl":"lemma tendsto_densityProcess_atTop_of_antitone (Îº : Kernel Î± (Î³ Ã— Î²)) (Î½ : Kernel Î± Î³)\n    [IsFiniteKernel Îº] (n : â„•) (a : Î±) (x : Î³)\n    (seq : â„• â†’ Set Î²) (hseq : Antitone seq) (hseq_iInter : â‹‚ i, seq i = âˆ…)\n    (hseq_meas : âˆ€ m, MeasurableSet (seq m)) :\n    Tendsto (fun m â†¦ densityProcess Îº Î½ n a x (seq m)) atTop (ğ“ 0) := by\n  rw [â† densityProcess_empty Îº Î½ n a x]\n  exact tendsto_densityProcess_atTop_empty_of_antitone Îº Î½ n a x seq hseq hseq_iInter hseq_meas\n\n"}
{"name":"ProbabilityTheory.Kernel.tendsto_densityProcess_limitProcess","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\ninstâœ : ProbabilityTheory.IsFiniteKernel Î½\na : Î±\ns : Set Î²\nhs : MeasurableSet s\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun n => Îº.densityProcess Î½ n a x s) Filter.atTop (nhds (MeasureTheory.Filtration.limitProcess (fun n x => Îº.densityProcess Î½ n a x s) (ProbabilityTheory.countableFiltration Î³) (Î½ a) x))) (MeasureTheory.ae (Î½ a))","decl":"lemma tendsto_densityProcess_limitProcess (hÎºÎ½ : fst Îº â‰¤ Î½)\n    [IsFiniteKernel Î½] (a : Î±) {s : Set Î²} (hs : MeasurableSet s) :\n    âˆ€áµ x âˆ‚(Î½ a), Tendsto (fun n â†¦ densityProcess Îº Î½ n a x s) atTop\n      (ğ“ ((countableFiltration Î³).limitProcess\n      (fun n x â†¦ densityProcess Îº Î½ n a x s) (Î½ a) x)) := by\n  refine Submartingale.ae_tendsto_limitProcess (martingale_densityProcess hÎºÎ½ a hs).submartingale\n    (R := (Î½ a univ).toNNReal) (fun n â†¦ ?_)\n  refine (eLpNorm_densityProcess_le hÎºÎ½ n a s).trans_eq ?_\n  rw [ENNReal.coe_toNNReal]\n  exact measure_ne_top _ _\n\n"}
{"name":"ProbabilityTheory.Kernel.memL1_limitProcess_densityProcess","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\ninstâœ : ProbabilityTheory.IsFiniteKernel Î½\na : Î±\ns : Set Î²\nhs : MeasurableSet s\nâŠ¢ MeasureTheory.Memâ„’p (MeasureTheory.Filtration.limitProcess (fun n x => Îº.densityProcess Î½ n a x s) (ProbabilityTheory.countableFiltration Î³) (Î½ a)) 1 (Î½ a)","decl":"lemma memL1_limitProcess_densityProcess (hÎºÎ½ : fst Îº â‰¤ Î½) [IsFiniteKernel Î½]\n    (a : Î±) {s : Set Î²} (hs : MeasurableSet s) :\n    Memâ„’p ((countableFiltration Î³).limitProcess\n      (fun n x â†¦ densityProcess Îº Î½ n a x s) (Î½ a)) 1 (Î½ a) := by\n  refine Submartingale.memâ„’p_limitProcess (martingale_densityProcess hÎºÎ½ a hs).submartingale\n    (R := (Î½ a univ).toNNReal) (fun n â†¦ ?_)\n  refine (eLpNorm_densityProcess_le hÎºÎ½ n a s).trans_eq ?_\n  rw [ENNReal.coe_toNNReal]\n  exact measure_ne_top _ _\n\n"}
{"name":"ProbabilityTheory.Kernel.tendsto_eLpNorm_one_densityProcess_limitProcess","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\ninstâœ : ProbabilityTheory.IsFiniteKernel Î½\na : Î±\ns : Set Î²\nhs : MeasurableSet s\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (fun x => Îº.densityProcess Î½ n a x s) (MeasureTheory.Filtration.limitProcess (fun n x => Îº.densityProcess Î½ n a x s) (ProbabilityTheory.countableFiltration Î³) (Î½ a))) 1 (Î½ a)) Filter.atTop (nhds 0)","decl":"lemma tendsto_eLpNorm_one_densityProcess_limitProcess (hÎºÎ½ : fst Îº â‰¤ Î½) [IsFiniteKernel Î½]\n    (a : Î±) {s : Set Î²} (hs : MeasurableSet s) :\n    Tendsto (fun n â†¦ eLpNorm ((fun x â†¦ densityProcess Îº Î½ n a x s)\n      - (countableFiltration Î³).limitProcess (fun n x â†¦ densityProcess Îº Î½ n a x s) (Î½ a))\n      1 (Î½ a)) atTop (ğ“ 0) := by\n  refine Submartingale.tendsto_eLpNorm_one_limitProcess ?_ ?_\n  Â· exact (martingale_densityProcess hÎºÎ½ a hs).submartingale\n  Â· refine uniformIntegrable_of le_rfl ENNReal.one_ne_top ?_ ?_\n    Â· exact fun n â†¦ (measurable_densityProcess_right Îº Î½ n a hs).aestronglyMeasurable\n    Â· refine fun Îµ _ â†¦ âŸ¨2, fun n â†¦ le_of_eq_of_le ?_ (?_ : 0 â‰¤ ENNReal.ofReal Îµ)âŸ©\n      Â· suffices {x | 2 â‰¤ â€–densityProcess Îº Î½ n a x sâ€–â‚Š} = âˆ… by simp [this]\n        ext x\n        simp only [mem_setOf_eq, mem_empty_iff_false, iff_false, not_le]\n        refine (?_ : _ â‰¤ (1 : â„â‰¥0)).trans_lt one_lt_two\n        rw [Real.nnnorm_of_nonneg (densityProcess_nonneg _ _ _ _ _ _)]\n        exact mod_cast (densityProcess_le_one hÎºÎ½ _ _ _ _)\n      Â· simp\n\n"}
{"name":"ProbabilityTheory.Kernel.tendsto_eLpNorm_one_restrict_densityProcess_limitProcess","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\ninstâœ : ProbabilityTheory.IsFiniteKernel Î½\nhÎºÎ½ : LE.le Îº.fst Î½\na : Î±\ns : Set Î²\nhs : MeasurableSet s\nA : Set Î³\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (fun x => Îº.densityProcess Î½ n a x s) (MeasureTheory.Filtration.limitProcess (fun n x => Îº.densityProcess Î½ n a x s) (ProbabilityTheory.countableFiltration Î³) (Î½ a))) 1 ((Î½ a).restrict A)) Filter.atTop (nhds 0)","decl":"lemma tendsto_eLpNorm_one_restrict_densityProcess_limitProcess [IsFiniteKernel Î½]\n    (hÎºÎ½ : fst Îº â‰¤ Î½) (a : Î±) {s : Set Î²} (hs : MeasurableSet s) (A : Set Î³) :\n    Tendsto (fun n â†¦ eLpNorm ((fun x â†¦ densityProcess Îº Î½ n a x s)\n      - (countableFiltration Î³).limitProcess (fun n x â†¦ densityProcess Îº Î½ n a x s) (Î½ a))\n      1 ((Î½ a).restrict A)) atTop (ğ“ 0) :=\n  tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds\n    (tendsto_eLpNorm_one_densityProcess_limitProcess hÎºÎ½ a hs) (fun _ â†¦ zero_le')\n    (fun _ â†¦ eLpNorm_restrict_le _ _ _ _)\n\n"}
{"name":"ProbabilityTheory.Kernel.density_ae_eq_limitProcess","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\ninstâœ : ProbabilityTheory.IsFiniteKernel Î½\na : Î±\ns : Set Î²\nhs : MeasurableSet s\nâŠ¢ (MeasureTheory.ae (Î½ a)).EventuallyEq (fun x => Îº.density Î½ a x s) (MeasureTheory.Filtration.limitProcess (fun n x => Îº.densityProcess Î½ n a x s) (ProbabilityTheory.countableFiltration Î³) (Î½ a))","decl":"lemma density_ae_eq_limitProcess (hÎºÎ½ : fst Îº â‰¤ Î½) [IsFiniteKernel Î½]\n    (a : Î±) {s : Set Î²} (hs : MeasurableSet s) :\n    (fun x â†¦ density Îº Î½ a x s)\n      =áµ[Î½ a] (countableFiltration Î³).limitProcess\n        (fun n x â†¦ densityProcess Îº Î½ n a x s) (Î½ a) := by\n  filter_upwards [tendsto_densityProcess_limitProcess hÎºÎ½ a hs] with t ht using ht.limsup_eq\n\n"}
{"name":"ProbabilityTheory.Kernel.tendsto_m_density","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\na : Î±\ninstâœ : ProbabilityTheory.IsFiniteKernel Î½\ns : Set Î²\nhs : MeasurableSet s\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun n => Îº.densityProcess Î½ n a x s) Filter.atTop (nhds (Îº.density Î½ a x s))) (MeasureTheory.ae (Î½ a))","decl":"lemma tendsto_m_density (hÎºÎ½ : fst Îº â‰¤ Î½) (a : Î±) [IsFiniteKernel Î½]\n    {s : Set Î²} (hs : MeasurableSet s) :\n    âˆ€áµ x âˆ‚(Î½ a),\n      Tendsto (fun n â†¦ densityProcess Îº Î½ n a x s) atTop (ğ“ (density Îº Î½ a x s)) := by\n  filter_upwards [tendsto_densityProcess_limitProcess hÎºÎ½ a hs, density_ae_eq_limitProcess hÎºÎ½ a hs]\n    with t h1 h2 using h2 â–¸ h1\n\n"}
{"name":"ProbabilityTheory.Kernel.measurable_density","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\ns : Set Î²\nhs : MeasurableSet s\nâŠ¢ Measurable fun p => Îº.density Î½ p.1 p.2 s","decl":"lemma measurable_density (Îº : Kernel Î± (Î³ Ã— Î²)) (Î½ : Kernel Î± Î³)\n    {s : Set Î²} (hs : MeasurableSet s) :\n    Measurable (fun (p : Î± Ã— Î³) â†¦ density Îº Î½ p.1 p.2 s) :=\n  .limsup (fun n â†¦ measurable_densityProcess Îº Î½ n hs)\n\n"}
{"name":"ProbabilityTheory.Kernel.measurable_density_left","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nx : Î³\ns : Set Î²\nhs : MeasurableSet s\nâŠ¢ Measurable fun a => Îº.density Î½ a x s","decl":"lemma measurable_density_left (Îº : Kernel Î± (Î³ Ã— Î²)) (Î½ : Kernel Î± Î³) (x : Î³)\n    {s : Set Î²} (hs : MeasurableSet s) :\n    Measurable (fun a â†¦ density Îº Î½ a x s) := by\n  change Measurable ((fun (p : Î± Ã— Î³) â†¦ density Îº Î½ p.1 p.2 s) âˆ˜ (fun a â†¦ (a, x)))\n  exact (measurable_density Îº Î½ hs).comp measurable_prod_mk_right\n\n"}
{"name":"ProbabilityTheory.Kernel.measurable_density_right","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\ns : Set Î²\nhs : MeasurableSet s\na : Î±\nâŠ¢ Measurable fun x => Îº.density Î½ a x s","decl":"lemma measurable_density_right (Îº : Kernel Î± (Î³ Ã— Î²)) (Î½ : Kernel Î± Î³)\n    {s : Set Î²} (hs : MeasurableSet s) (a : Î±) :\n    Measurable (fun x â†¦ density Îº Î½ a x s) := by\n  change Measurable ((fun (p : Î± Ã— Î³) â†¦ density Îº Î½ p.1 p.2 s) âˆ˜ (fun x â†¦ (a, x)))\n  exact (measurable_density Îº Î½ hs).comp measurable_prod_mk_left\n\n"}
{"name":"ProbabilityTheory.Kernel.density_mono_set","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\na : Î±\nx : Î³\ns s' : Set Î²\nh : HasSubset.Subset s s'\nâŠ¢ LE.le (Îº.density Î½ a x s) (Îº.density Î½ a x s')","decl":"lemma density_mono_set (hÎºÎ½ : fst Îº â‰¤ Î½) (a : Î±) (x : Î³) {s s' : Set Î²} (h : s âŠ† s') :\n    density Îº Î½ a x s â‰¤ density Îº Î½ a x s' := by\n  refine limsup_le_limsup ?_ ?_ ?_\n  Â· exact Eventually.of_forall (fun n â†¦ densityProcess_mono_set hÎºÎ½ n a x h)\n  Â· exact isCoboundedUnder_le_of_le atTop (fun i â†¦ densityProcess_nonneg _ _ _ _ _ _)\n  Â· exact isBoundedUnder_of âŸ¨1, fun n â†¦ densityProcess_le_one hÎºÎ½ _ _ _ _âŸ©\n\n"}
{"name":"ProbabilityTheory.Kernel.density_nonneg","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\na : Î±\nx : Î³\ns : Set Î²\nâŠ¢ LE.le 0 (Îº.density Î½ a x s)","decl":"lemma density_nonneg (hÎºÎ½ : fst Îº â‰¤ Î½) (a : Î±) (x : Î³) (s : Set Î²) :\n    0 â‰¤ density Îº Î½ a x s := by\n  refine le_limsup_of_frequently_le ?_ ?_\n  Â· exact Frequently.of_forall (fun n â†¦ densityProcess_nonneg _ _ _ _ _ _)\n  Â· exact isBoundedUnder_of âŸ¨1, fun n â†¦ densityProcess_le_one hÎºÎ½ _ _ _ _âŸ©\n\n"}
{"name":"ProbabilityTheory.Kernel.density_le_one","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\na : Î±\nx : Î³\ns : Set Î²\nâŠ¢ LE.le (Îº.density Î½ a x s) 1","decl":"lemma density_le_one (hÎºÎ½ : fst Îº â‰¤ Î½) (a : Î±) (x : Î³) (s : Set Î²) :\n    density Îº Î½ a x s â‰¤ 1 := by\n  refine limsup_le_of_le ?_ ?_\n  Â· exact isCoboundedUnder_le_of_le atTop (fun i â†¦ densityProcess_nonneg _ _ _ _ _ _)\n  Â· exact Eventually.of_forall (fun n â†¦ densityProcess_le_one hÎºÎ½ _ _ _ _)\n\n"}
{"name":"ProbabilityTheory.Kernel.eLpNorm_density_le","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\na : Î±\ns : Set Î²\nâŠ¢ LE.le (MeasureTheory.eLpNorm (fun x => Îº.density Î½ a x s) 1 (Î½ a)) ((Î½ a) Set.univ)","decl":"lemma eLpNorm_density_le (hÎºÎ½ : fst Îº â‰¤ Î½) (a : Î±) (s : Set Î²) :\n    eLpNorm (fun x â†¦ density Îº Î½ a x s) 1 (Î½ a) â‰¤ Î½ a univ := by\n  refine (eLpNorm_le_of_ae_bound (C := 1) (ae_of_all _ (fun t â†¦ ?_))).trans ?_\n  Â· simp only [Real.norm_eq_abs, abs_of_nonneg (density_nonneg hÎºÎ½ a t s),\n      density_le_one hÎºÎ½ a t s]\n  Â· simp\n\n"}
{"name":"ProbabilityTheory.Kernel.integrable_density","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\ninstâœ : ProbabilityTheory.IsFiniteKernel Î½\na : Î±\ns : Set Î²\nhs : MeasurableSet s\nâŠ¢ MeasureTheory.Integrable (fun x => Îº.density Î½ a x s) (Î½ a)","decl":"lemma integrable_density (hÎºÎ½ : fst Îº â‰¤ Î½) [IsFiniteKernel Î½]\n    (a : Î±) {s : Set Î²} (hs : MeasurableSet s) :\n    Integrable (fun x â†¦ density Îº Î½ a x s) (Î½ a) := by\n  rw [â† memâ„’p_one_iff_integrable]\n  refine âŸ¨Measurable.aestronglyMeasurable ?_, ?_âŸ©\n  Â· exact measurable_density_right Îº Î½ hs a\n  Â· exact (eLpNorm_density_le hÎºÎ½ a s).trans_lt (measure_lt_top _ _)\n\n"}
{"name":"ProbabilityTheory.Kernel.tendsto_setIntegral_densityProcess","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\ninstâœ : ProbabilityTheory.IsFiniteKernel Î½\na : Î±\ns : Set Î²\nhs : MeasurableSet s\nA : Set Î³\nâŠ¢ Filter.Tendsto (fun i => MeasureTheory.integral ((Î½ a).restrict A) fun x => Îº.densityProcess Î½ i a x s) Filter.atTop (nhds (MeasureTheory.integral ((Î½ a).restrict A) fun x => Îº.density Î½ a x s))","decl":"lemma tendsto_setIntegral_densityProcess (hÎºÎ½ : fst Îº â‰¤ Î½)\n    [IsFiniteKernel Î½] (a : Î±) {s : Set Î²} (hs : MeasurableSet s) (A : Set Î³) :\n    Tendsto (fun i â†¦ âˆ« x in A, densityProcess Îº Î½ i a x s âˆ‚(Î½ a)) atTop\n      (ğ“ (âˆ« x in A, density Îº Î½ a x s âˆ‚(Î½ a))) := by\n  refine tendsto_setIntegral_of_L1' (Î¼ := Î½ a) (fun x â†¦ density Îº Î½ a x s)\n    (integrable_density hÎºÎ½ a hs) (F := fun i x â†¦ densityProcess Îº Î½ i a x s) (l := atTop)\n    (Eventually.of_forall (fun n â†¦ integrable_densityProcess hÎºÎ½ _ _ hs)) ?_ A\n  refine (tendsto_congr fun n â†¦ ?_).mp (tendsto_eLpNorm_one_densityProcess_limitProcess hÎºÎ½ a hs)\n  refine eLpNorm_congr_ae ?_\n  exact EventuallyEq.rfl.sub (density_ae_eq_limitProcess hÎºÎ½ a hs).symm\n\n"}
{"name":"ProbabilityTheory.Kernel.setIntegral_density_of_measurableSet","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\ninstâœ : ProbabilityTheory.IsFiniteKernel Î½\nn : Nat\na : Î±\ns : Set Î²\nhs : MeasurableSet s\nA : Set Î³\nhA : MeasurableSet A\nâŠ¢ Eq (MeasureTheory.integral ((Î½ a).restrict A) fun x => Îº.density Î½ a x s) ((Îº a) (SProd.sprod A s)).toReal","decl":"/-- Auxiliary lemma for `setIntegral_density`. -/\nlemma setIntegral_density_of_measurableSet (hÎºÎ½ : fst Îº â‰¤ Î½)\n    [IsFiniteKernel Î½] (n : â„•) (a : Î±) {s : Set Î²} (hs : MeasurableSet s) {A : Set Î³}\n    (hA : MeasurableSet[countableFiltration Î³ n] A) :\n    âˆ« x in A, density Îº Î½ a x s âˆ‚(Î½ a) = (Îº a (A Ã—Ë¢ s)).toReal := by\n  suffices âˆ« x in A, density Îº Î½ a x s âˆ‚(Î½ a) = âˆ« x in A, densityProcess Îº Î½ n a x s âˆ‚(Î½ a) by\n    exact this â–¸ setIntegral_densityProcess hÎºÎ½ _ _ hs hA\n  suffices âˆ« x in A, density Îº Î½ a x s âˆ‚(Î½ a)\n      = limsup (fun i â†¦ âˆ« x in A, densityProcess Îº Î½ i a x s âˆ‚(Î½ a)) atTop by\n    rw [this, â† limsup_const (Î± := â„•) (f := atTop) (âˆ« x in A, densityProcess Îº Î½ n a x s âˆ‚(Î½ a)),\n      limsup_congr]\n    simp only [eventually_atTop]\n    refine âŸ¨n, fun m hnm â†¦ ?_âŸ©\n    rw [setIntegral_densityProcess_of_le hÎºÎ½ hnm _ hs hA,\n      setIntegral_densityProcess hÎºÎ½ _ _ hs hA]\n  -- use L1 convergence\n  have h := tendsto_setIntegral_densityProcess hÎºÎ½ a hs A\n  rw [h.limsup_eq]\n\n"}
{"name":"ProbabilityTheory.Kernel.integral_density","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\ninstâœ : ProbabilityTheory.IsFiniteKernel Î½\na : Î±\ns : Set Î²\nhs : MeasurableSet s\nâŠ¢ Eq (MeasureTheory.integral (Î½ a) fun x => Îº.density Î½ a x s) ((Îº a) (SProd.sprod Set.univ s)).toReal","decl":"lemma integral_density (hÎºÎ½ : fst Îº â‰¤ Î½) [IsFiniteKernel Î½]\n    (a : Î±) {s : Set Î²} (hs : MeasurableSet s) :\n    âˆ« x, density Îº Î½ a x s âˆ‚(Î½ a) = (Îº a (univ Ã—Ë¢ s)).toReal := by\n  rw [â† setIntegral_univ, setIntegral_density_of_measurableSet hÎºÎ½ 0 a hs MeasurableSet.univ]\n\n"}
{"name":"ProbabilityTheory.Kernel.setIntegral_density","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\ninstâœ : ProbabilityTheory.IsFiniteKernel Î½\na : Î±\ns : Set Î²\nhs : MeasurableSet s\nA : Set Î³\nhA : MeasurableSet A\nâŠ¢ Eq (MeasureTheory.integral ((Î½ a).restrict A) fun x => Îº.density Î½ a x s) ((Îº a) (SProd.sprod A s)).toReal","decl":"lemma setIntegral_density (hÎºÎ½ : fst Îº â‰¤ Î½) [IsFiniteKernel Î½]\n    (a : Î±) {s : Set Î²} (hs : MeasurableSet s) {A : Set Î³} (hA : MeasurableSet A) :\n    âˆ« x in A, density Îº Î½ a x s âˆ‚(Î½ a) = (Îº a (A Ã—Ë¢ s)).toReal := by\n  have : IsFiniteKernel Îº := isFiniteKernel_of_isFiniteKernel_fst (h := isFiniteKernel_of_le hÎºÎ½)\n  have hgen : â€¹MeasurableSpace Î³â€º =\n      .generateFrom {s | âˆƒ n, MeasurableSet[countableFiltration Î³ n] s} := by\n    rw [setOf_exists, generateFrom_iUnion_measurableSet (countableFiltration Î³),\n      iSup_countableFiltration]\n  have hpi : IsPiSystem {s | âˆƒ n, MeasurableSet[countableFiltration Î³ n] s} := by\n    rw [setOf_exists]\n    exact isPiSystem_iUnion_of_monotone _\n      (fun n â†¦ @isPiSystem_measurableSet _ (countableFiltration Î³ n))\n      fun _ _ â†¦ (countableFiltration Î³).mono\n  induction A, hA using induction_on_inter hgen hpi with\n  | empty => simp\n  | basic s hs =>\n    rcases hs with âŸ¨n, hnâŸ©\n    exact setIntegral_density_of_measurableSet hÎºÎ½ n a hs hn\n  | compl A hA hA_eq =>\n    have h := integral_add_compl hA (integrable_density hÎºÎ½ a hs)\n    rw [hA_eq, integral_density hÎºÎ½ a hs] at h\n    have : Aá¶œ Ã—Ë¢ s = univ Ã—Ë¢ s \\ A Ã—Ë¢ s := by\n      rw [prod_diff_prod, compl_eq_univ_diff]\n      simp\n    rw [this, measure_diff (by intro; simp) (hA.prod hs).nullMeasurableSet (measure_ne_top (Îº a) _),\n      ENNReal.toReal_sub_of_le (measure_mono (by intro x; simp)) (measure_ne_top _ _)]\n    rw [eq_tsub_iff_add_eq_of_le, add_comm]\n    Â· exact h\n    Â· gcongr <;> simp\n  | iUnion f hf_disj hf h_eq =>\n    rw [integral_iUnion hf hf_disj (integrable_density hÎºÎ½ _ hs).integrableOn]\n    simp_rw [h_eq]\n    rw [â† ENNReal.tsum_toReal_eq (fun _ â†¦ measure_ne_top _ _)]\n    congr\n    rw [iUnion_prod_const, measure_iUnion]\n    Â· exact hf_disj.mono fun _ _ h â†¦ h.set_prod_left _ _\n    Â· exact fun i â†¦ (hf i).prod hs\n\n"}
{"name":"ProbabilityTheory.Kernel.setLIntegral_density","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\ninstâœ : ProbabilityTheory.IsFiniteKernel Î½\na : Î±\ns : Set Î²\nhs : MeasurableSet s\nA : Set Î³\nhA : MeasurableSet A\nâŠ¢ Eq (MeasureTheory.lintegral ((Î½ a).restrict A) fun x => ENNReal.ofReal (Îº.density Î½ a x s)) ((Îº a) (SProd.sprod A s))","decl":"lemma setLIntegral_density (hÎºÎ½ : fst Îº â‰¤ Î½) [IsFiniteKernel Î½]\n    (a : Î±) {s : Set Î²} (hs : MeasurableSet s) {A : Set Î³} (hA : MeasurableSet A) :\n    âˆ«â» x in A, ENNReal.ofReal (density Îº Î½ a x s) âˆ‚(Î½ a) = Îº a (A Ã—Ë¢ s) := by\n  have : IsFiniteKernel Îº := isFiniteKernel_of_isFiniteKernel_fst (h := isFiniteKernel_of_le hÎºÎ½)\n  rw [â† ofReal_integral_eq_lintegral_ofReal]\n  Â· rw [setIntegral_density hÎºÎ½ a hs hA,\n      ENNReal.ofReal_toReal (measure_ne_top _ _)]\n  Â· exact (integrable_density hÎºÎ½ a hs).restrict\n  Â· exact ae_of_all _ (fun _ â†¦ density_nonneg hÎºÎ½ _ _ _)\n\n"}
{"name":"ProbabilityTheory.Kernel.lintegral_density","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\ninstâœ : ProbabilityTheory.IsFiniteKernel Î½\na : Î±\ns : Set Î²\nhs : MeasurableSet s\nâŠ¢ Eq (MeasureTheory.lintegral (Î½ a) fun x => ENNReal.ofReal (Îº.density Î½ a x s)) ((Îº a) (SProd.sprod Set.univ s))","decl":"lemma lintegral_density (hÎºÎ½ : fst Îº â‰¤ Î½) [IsFiniteKernel Î½]\n    (a : Î±) {s : Set Î²} (hs : MeasurableSet s) :\n    âˆ«â» x, ENNReal.ofReal (density Îº Î½ a x s) âˆ‚(Î½ a) = Îº a (univ Ã—Ë¢ s) := by\n  rw [â† setLIntegral_univ]\n  exact setLIntegral_density hÎºÎ½ a hs MeasurableSet.univ\n\n"}
{"name":"ProbabilityTheory.Kernel.tendsto_integral_density_of_monotone","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\ninstâœ : ProbabilityTheory.IsFiniteKernel Î½\na : Î±\nseq : Nat â†’ Set Î²\nhseq : Monotone seq\nhseq_iUnion : Eq (Set.iUnion fun i => seq i) Set.univ\nhseq_meas : âˆ€ (m : Nat), MeasurableSet (seq m)\nâŠ¢ Filter.Tendsto (fun m => MeasureTheory.integral (Î½ a) fun x => Îº.density Î½ a x (seq m)) Filter.atTop (nhds ((Îº a) Set.univ).toReal)","decl":"lemma tendsto_integral_density_of_monotone (hÎºÎ½ : fst Îº â‰¤ Î½) [IsFiniteKernel Î½]\n    (a : Î±) (seq : â„• â†’ Set Î²) (hseq : Monotone seq) (hseq_iUnion : â‹ƒ i, seq i = univ)\n    (hseq_meas : âˆ€ m, MeasurableSet (seq m)) :\n    Tendsto (fun m â†¦ âˆ« x, density Îº Î½ a x (seq m) âˆ‚(Î½ a)) atTop (ğ“ (Îº a univ).toReal) := by\n  have : IsFiniteKernel Îº := isFiniteKernel_of_isFiniteKernel_fst (h := isFiniteKernel_of_le hÎºÎ½)\n  simp_rw [integral_density hÎºÎ½ a (hseq_meas _)]\n  have h_cont := ENNReal.continuousOn_toReal.continuousAt (x := Îº a univ) ?_\n  swap\n  Â· rw [mem_nhds_iff]\n    refine âŸ¨Iio (Îº a univ + 1), fun x hx â†¦ ne_top_of_lt (?_ : x < Îº a univ + 1), isOpen_Iio, ?_âŸ©\n    Â· simpa using hx\n    Â· simp only [mem_Iio]\n      exact ENNReal.lt_add_right (measure_ne_top _ _) one_ne_zero\n  refine h_cont.tendsto.comp ?_\n  convert tendsto_measure_iUnion_atTop (monotone_const.set_prod hseq)\n  rw [â† prod_iUnion, hseq_iUnion, univ_prod_univ]\n\n"}
{"name":"ProbabilityTheory.Kernel.tendsto_integral_density_of_antitone","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\ninstâœ : ProbabilityTheory.IsFiniteKernel Î½\na : Î±\nseq : Nat â†’ Set Î²\nhseq : Antitone seq\nhseq_iInter : Eq (Set.iInter fun i => seq i) EmptyCollection.emptyCollection\nhseq_meas : âˆ€ (m : Nat), MeasurableSet (seq m)\nâŠ¢ Filter.Tendsto (fun m => MeasureTheory.integral (Î½ a) fun x => Îº.density Î½ a x (seq m)) Filter.atTop (nhds 0)","decl":"lemma tendsto_integral_density_of_antitone (hÎºÎ½ : fst Îº â‰¤ Î½) [IsFiniteKernel Î½] (a : Î±)\n    (seq : â„• â†’ Set Î²) (hseq : Antitone seq) (hseq_iInter : â‹‚ i, seq i = âˆ…)\n    (hseq_meas : âˆ€ m, MeasurableSet (seq m)) :\n    Tendsto (fun m â†¦ âˆ« x, density Îº Î½ a x (seq m) âˆ‚(Î½ a)) atTop (ğ“ 0) := by\n  have : IsFiniteKernel Îº := isFiniteKernel_of_isFiniteKernel_fst (h := isFiniteKernel_of_le hÎºÎ½)\n  simp_rw [integral_density hÎºÎ½ a (hseq_meas _)]\n  rw [â† ENNReal.zero_toReal]\n  have h_cont := ENNReal.continuousAt_toReal ENNReal.zero_ne_top\n  refine h_cont.tendsto.comp ?_\n  have h : Tendsto (fun m â†¦ Îº a (univ Ã—Ë¢ seq m)) atTop\n      (ğ“ ((Îº a) (â‹‚ n, (fun m â†¦ univ Ã—Ë¢ seq m) n))) := by\n    apply tendsto_measure_iInter_atTop\n    Â· measurability\n    Â· exact antitone_const.set_prod hseq\n    Â· exact âŸ¨0, measure_ne_top _ _âŸ©\n  simpa [â† prod_iInter, hseq_iInter] using h\n\n"}
{"name":"ProbabilityTheory.Kernel.tendsto_density_atTop_ae_of_antitone","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nÎ½ : ProbabilityTheory.Kernel Î± Î³\nhÎºÎ½ : LE.le Îº.fst Î½\ninstâœ : ProbabilityTheory.IsFiniteKernel Î½\na : Î±\nseq : Nat â†’ Set Î²\nhseq : Antitone seq\nhseq_iInter : Eq (Set.iInter fun i => seq i) EmptyCollection.emptyCollection\nhseq_meas : âˆ€ (m : Nat), MeasurableSet (seq m)\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun m => Îº.density Î½ a x (seq m)) Filter.atTop (nhds 0)) (MeasureTheory.ae (Î½ a))","decl":"lemma tendsto_density_atTop_ae_of_antitone (hÎºÎ½ : fst Îº â‰¤ Î½) [IsFiniteKernel Î½] (a : Î±)\n    (seq : â„• â†’ Set Î²) (hseq : Antitone seq) (hseq_iInter : â‹‚ i, seq i = âˆ…)\n    (hseq_meas : âˆ€ m, MeasurableSet (seq m)) :\n    âˆ€áµ x âˆ‚(Î½ a), Tendsto (fun m â†¦ density Îº Î½ a x (seq m)) atTop (ğ“ 0) := by\n  refine tendsto_of_integral_tendsto_of_antitone ?_ (integrable_const _) ?_ ?_ ?_\n  Â· exact fun m â†¦ integrable_density hÎºÎ½ _ (hseq_meas m)\n  Â· rw [integral_zero]\n    exact tendsto_integral_density_of_antitone hÎºÎ½ a seq hseq hseq_iInter hseq_meas\n  Â· exact ae_of_all _ (fun c n m hnm â†¦ density_mono_set hÎºÎ½ a c (hseq hnm))\n  Â· exact ae_of_all _ (fun x m â†¦ density_nonneg hÎºÎ½ a x (seq m))\n\n"}
{"name":"ProbabilityTheory.Kernel.densityProcess_fst_univ","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\ninstâœ : ProbabilityTheory.IsFiniteKernel Îº\nn : Nat\na : Î±\nx : Î³\nâŠ¢ Eq (Îº.densityProcess Îº.fst n a x Set.univ) (ite (Eq ((Îº.fst a) (MeasurableSpace.countablePartitionSet n x)) 0) 0 1)","decl":"lemma densityProcess_fst_univ [IsFiniteKernel Îº] (n : â„•) (a : Î±) (x : Î³) :\n    densityProcess Îº (fst Îº) n a x univ\n      = if fst Îº a (countablePartitionSet n x) = 0 then 0 else 1 := by\n  rw [densityProcess]\n  split_ifs with h\n  Â· simp only [h]\n    by_cases h' : Îº a (countablePartitionSet n x Ã—Ë¢ univ) = 0\n    Â· simp [h']\n    Â· rw [ENNReal.div_zero h']\n      simp\n  Â· rw [fst_apply' _ _ (measurableSet_countablePartitionSet _ _)]\n    have : countablePartitionSet n x Ã—Ë¢ univ = {p : Î³ Ã— Î² | p.1 âˆˆ countablePartitionSet n x} := by\n      ext x\n      simp\n    rw [this, ENNReal.div_self]\n    Â· simp\n    Â· rwa [fst_apply' _ _ (measurableSet_countablePartitionSet _ _)] at h\n    Â· exact measure_ne_top _ _\n\n"}
{"name":"ProbabilityTheory.Kernel.densityProcess_fst_univ_ae","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\ninstâœ : ProbabilityTheory.IsFiniteKernel Îº\nn : Nat\na : Î±\nâŠ¢ Filter.Eventually (fun x => Eq (Îº.densityProcess Îº.fst n a x Set.univ) 1) (MeasureTheory.ae (Îº.fst a))","decl":"lemma densityProcess_fst_univ_ae (Îº : Kernel Î± (Î³ Ã— Î²)) [IsFiniteKernel Îº] (n : â„•) (a : Î±) :\n    âˆ€áµ x âˆ‚(fst Îº a), densityProcess Îº (fst Îº) n a x univ = 1 := by\n  rw [ae_iff]\n  have : {x | Â¬ densityProcess Îº (fst Îº) n a x univ = 1}\n      âŠ† {x | fst Îº a (countablePartitionSet n x) = 0} := by\n    intro x hx\n    simp only [mem_setOf_eq] at hx âŠ¢\n    rw [densityProcess_fst_univ] at hx\n    simpa using hx\n  refine measure_mono_null this ?_\n  have : {x | fst Îº a (countablePartitionSet n x) = 0}\n      âŠ† â‹ƒ (u) (_ : u âˆˆ countablePartition Î³ n) (_ : fst Îº a u = 0), u := by\n    intro t ht\n    simp only [mem_setOf_eq, mem_iUnion, exists_prop] at ht âŠ¢\n    exact âŸ¨countablePartitionSet n t, countablePartitionSet_mem _ _, ht,\n      mem_countablePartitionSet _ _âŸ©\n  refine measure_mono_null this ?_\n  rw [measure_biUnion]\n  Â· simp\n  Â· exact (finite_countablePartition _ _).countable\n  Â· intro s hs t ht hst\n    simp only [disjoint_iUnion_right, disjoint_iUnion_left]\n    exact fun _ _ â†¦ disjoint_countablePartition hs ht hst\n  Â· intro s hs\n    by_cases h : fst Îº a s = 0\n    Â· simp [h, measurableSet_countablePartition n hs]\n    Â· simp [h]\n\n"}
{"name":"ProbabilityTheory.Kernel.tendsto_densityProcess_fst_atTop_univ_of_monotone","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\nn : Nat\na : Î±\nx : Î³\nseq : Nat â†’ Set Î²\nhseq : Monotone seq\nhseq_iUnion : Eq (Set.iUnion fun i => seq i) Set.univ\nâŠ¢ Filter.Tendsto (fun m => Îº.densityProcess Îº.fst n a x (seq m)) Filter.atTop (nhds (Îº.densityProcess Îº.fst n a x Set.univ))","decl":"lemma tendsto_densityProcess_fst_atTop_univ_of_monotone (Îº : Kernel Î± (Î³ Ã— Î²)) (n : â„•) (a : Î±)\n    (x : Î³) (seq : â„• â†’ Set Î²) (hseq : Monotone seq) (hseq_iUnion : â‹ƒ i, seq i = univ) :\n    Tendsto (fun m â†¦ densityProcess Îº (fst Îº) n a x (seq m)) atTop\n      (ğ“ (densityProcess Îº (fst Îº) n a x univ)) := by\n  simp_rw [densityProcess]\n  refine (ENNReal.tendsto_toReal ?_).comp ?_\n  Â· rw [ne_eq, ENNReal.div_eq_top]\n    push_neg\n    simp_rw [fst_apply' _ _ (measurableSet_countablePartitionSet _ _)]\n    constructor\n    Â· refine fun h h0 â†¦ h (measure_mono_null (fun x â†¦ ?_) h0)\n      simp only [mem_prod, mem_setOf_eq, and_imp]\n      exact fun h _ â†¦ h\n    Â· refine fun h_top â†¦ eq_top_mono (measure_mono (fun x â†¦ ?_)) h_top\n      simp only [mem_prod, mem_setOf_eq, and_imp]\n      exact fun h _ â†¦ h\n  by_cases h0 : fst Îº a (countablePartitionSet n x) = 0\n  Â· rw [fst_apply' _ _ (measurableSet_countablePartitionSet _ _)] at h0 âŠ¢\n    suffices âˆ€ m, Îº a (countablePartitionSet n x Ã—Ë¢ seq m) = 0 by\n      simp only [this, h0, ENNReal.zero_div, tendsto_const_nhds_iff]\n      suffices Îº a (countablePartitionSet n x Ã—Ë¢ univ) = 0 by\n        simp only [this, ENNReal.zero_div]\n      convert h0\n      ext x\n      simp only [mem_prod, mem_univ, and_true, mem_setOf_eq]\n    refine fun m â†¦ measure_mono_null (fun x â†¦ ?_) h0\n    simp only [mem_prod, mem_setOf_eq, and_imp]\n    exact fun h _ â†¦ h\n  refine ENNReal.Tendsto.div_const ?_ ?_\n  Â· convert tendsto_measure_iUnion_atTop (monotone_const.set_prod hseq)\n    rw [â† prod_iUnion, hseq_iUnion]\n  Â· exact Or.inr h0\n\n"}
{"name":"ProbabilityTheory.Kernel.tendsto_densityProcess_fst_atTop_ae_of_monotone","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\ninstâœ : ProbabilityTheory.IsFiniteKernel Îº\nn : Nat\na : Î±\nseq : Nat â†’ Set Î²\nhseq : Monotone seq\nhseq_iUnion : Eq (Set.iUnion fun i => seq i) Set.univ\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun m => Îº.densityProcess Îº.fst n a x (seq m)) Filter.atTop (nhds 1)) (MeasureTheory.ae (Îº.fst a))","decl":"lemma tendsto_densityProcess_fst_atTop_ae_of_monotone (Îº : Kernel Î± (Î³ Ã— Î²)) [IsFiniteKernel Îº]\n    (n : â„•) (a : Î±) (seq : â„• â†’ Set Î²) (hseq : Monotone seq) (hseq_iUnion : â‹ƒ i, seq i = univ) :\n    âˆ€áµ x âˆ‚(fst Îº a), Tendsto (fun m â†¦ densityProcess Îº (fst Îº) n a x (seq m)) atTop (ğ“ 1) := by\n  filter_upwards [densityProcess_fst_univ_ae Îº n a] with x hx\n  rw [â† hx]\n  exact tendsto_densityProcess_fst_atTop_univ_of_monotone Îº n a x seq hseq hseq_iUnion\n\n"}
{"name":"ProbabilityTheory.Kernel.density_fst_univ","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\ninstâœ : ProbabilityTheory.IsFiniteKernel Îº\na : Î±\nâŠ¢ Filter.Eventually (fun x => Eq (Îº.density Îº.fst a x Set.univ) 1) (MeasureTheory.ae (Îº.fst a))","decl":"lemma density_fst_univ (Îº : Kernel Î± (Î³ Ã— Î²)) [IsFiniteKernel Îº] (a : Î±) :\n    âˆ€áµ x âˆ‚(fst Îº a), density Îº (fst Îº) a x univ = 1 := by\n  have h := fun n â†¦ densityProcess_fst_univ_ae Îº n a\n  rw [â† ae_all_iff] at h\n  filter_upwards [h] with x hx\n  simp [density, hx]\n\n"}
{"name":"ProbabilityTheory.Kernel.tendsto_density_fst_atTop_ae_of_monotone","module":"Mathlib.Probability.Kernel.Disintegration.Density","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated Î³\nÎº : ProbabilityTheory.Kernel Î± (Prod Î³ Î²)\ninstâœ : ProbabilityTheory.IsFiniteKernel Îº\na : Î±\nseq : Nat â†’ Set Î²\nhseq : Monotone seq\nhseq_iUnion : Eq (Set.iUnion fun i => seq i) Set.univ\nhseq_meas : âˆ€ (m : Nat), MeasurableSet (seq m)\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun m => Îº.density Îº.fst a x (seq m)) Filter.atTop (nhds 1)) (MeasureTheory.ae (Îº.fst a))","decl":"lemma tendsto_density_fst_atTop_ae_of_monotone [IsFiniteKernel Îº]\n    (a : Î±) (seq : â„• â†’ Set Î²) (hseq : Monotone seq) (hseq_iUnion : â‹ƒ i, seq i = univ)\n    (hseq_meas : âˆ€ m, MeasurableSet (seq m)) :\n    âˆ€áµ x âˆ‚(fst Îº a), Tendsto (fun m â†¦ density Îº (fst Îº) a x (seq m)) atTop (ğ“ 1) := by\n  refine tendsto_of_integral_tendsto_of_monotone ?_ (integrable_const _) ?_ ?_ ?_\n  Â· exact fun m â†¦ integrable_density le_rfl _ (hseq_meas m)\n  Â· rw [MeasureTheory.integral_const, smul_eq_mul, mul_one]\n    convert tendsto_integral_density_of_monotone (Îº := Îº) le_rfl a seq hseq hseq_iUnion hseq_meas\n    rw [fst_apply' _ _ MeasurableSet.univ]\n    simp only [mem_univ, setOf_true]\n  Â· exact ae_of_all _ (fun c n m hnm â†¦ density_mono_set le_rfl a c (hseq hnm))\n  Â· exact ae_of_all _ (fun x m â†¦ density_le_one le_rfl a x (seq m))\n\n"}
