{"name":"IsIdempotentElem.one_sub","module":"Mathlib.Algebra.Ring.Idempotent","initialProofState":"R : Type u_1\ninst✝ : NonAssocRing R\na : R\nh : IsIdempotentElem a\n⊢ IsIdempotentElem (HSub.hSub 1 a)","decl":"lemma one_sub (h : IsIdempotentElem a) : IsIdempotentElem (1 - a) := by\n  rw [IsIdempotentElem, mul_sub, mul_one, sub_mul, one_mul, h.eq, sub_self, sub_zero]\n\n"}
{"name":"IsIdempotentElem.one_sub_iff","module":"Mathlib.Algebra.Ring.Idempotent","initialProofState":"R : Type u_1\ninst✝ : NonAssocRing R\na : R\n⊢ Iff (IsIdempotentElem (HSub.hSub 1 a)) (IsIdempotentElem a)","decl":"@[simp]\nlemma one_sub_iff : IsIdempotentElem (1 - a) ↔ IsIdempotentElem a :=\n  ⟨fun h => sub_sub_cancel 1 a ▸ h.one_sub, IsIdempotentElem.one_sub⟩\n\n"}
{"name":"IsIdempotentElem.mul_one_sub_self","module":"Mathlib.Algebra.Ring.Idempotent","initialProofState":"R : Type u_1\ninst✝ : NonAssocRing R\na : R\nh : IsIdempotentElem a\n⊢ Eq (HMul.hMul a (HSub.hSub 1 a)) 0","decl":"@[simp]\nlemma mul_one_sub_self (h : IsIdempotentElem a) : a * (1 - a) = 0 := by\n  rw [mul_sub, mul_one, h.eq, sub_self]\n\n"}
{"name":"IsIdempotentElem.one_sub_mul_self","module":"Mathlib.Algebra.Ring.Idempotent","initialProofState":"R : Type u_1\ninst✝ : NonAssocRing R\na : R\nh : IsIdempotentElem a\n⊢ Eq (HMul.hMul (HSub.hSub 1 a) a) 0","decl":"@[simp]\nlemma one_sub_mul_self (h : IsIdempotentElem a) : (1 - a) * a = 0 := by\n  rw [sub_mul, one_mul, h.eq, sub_self]\n\n"}
{"name":"IsIdempotentElem.coe_compl","module":"Mathlib.Algebra.Ring.Idempotent","initialProofState":"R : Type u_1\ninst✝ : NonAssocRing R\na : Subtype fun a => IsIdempotentElem a\n⊢ Eq (↑(HasCompl.compl a)) (HSub.hSub 1 ↑a)","decl":"@[simp] lemma coe_compl (a : {a : R // IsIdempotentElem a}) : ↑aᶜ = (1 : R) - ↑a := rfl\n\n"}
{"name":"IsIdempotentElem.compl_compl","module":"Mathlib.Algebra.Ring.Idempotent","initialProofState":"R : Type u_1\ninst✝ : NonAssocRing R\na : Subtype fun a => IsIdempotentElem a\n⊢ Eq (HasCompl.compl (HasCompl.compl a)) a","decl":"@[simp] lemma compl_compl (a : {a : R // IsIdempotentElem a}) : aᶜᶜ = a := by ext; simp\n"}
{"name":"IsIdempotentElem.zero_compl","module":"Mathlib.Algebra.Ring.Idempotent","initialProofState":"R : Type u_1\ninst✝ : NonAssocRing R\n⊢ Eq (HasCompl.compl 0) 1","decl":"@[simp] lemma zero_compl : (0 : {a : R // IsIdempotentElem a})ᶜ = 1 := by ext; simp\n"}
{"name":"IsIdempotentElem.one_compl","module":"Mathlib.Algebra.Ring.Idempotent","initialProofState":"R : Type u_1\ninst✝ : NonAssocRing R\n⊢ Eq (HasCompl.compl 1) 0","decl":"@[simp] lemma one_compl : (1 : {a : R // IsIdempotentElem a})ᶜ = 0 := by ext; simp\n\n"}
{"name":"IsIdempotentElem.of_mul_add","module":"Mathlib.Algebra.Ring.Idempotent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\na b : R\nmul : Eq (HMul.hMul a b) 0\nadd : Eq (HAdd.hAdd a b) 1\n⊢ And (IsIdempotentElem a) (IsIdempotentElem b)","decl":"lemma of_mul_add (mul : a * b = 0) (add : a + b = 1) : IsIdempotentElem a ∧ IsIdempotentElem b := by\n  simp_rw [IsIdempotentElem]; constructor\n  · conv_rhs => rw [← mul_one a, ← add, mul_add, mul, add_zero]\n  · conv_rhs => rw [← one_mul b, ← add, add_mul, mul, zero_add]\n\n"}
{"name":"IsIdempotentElem.add_sub_mul_of_commute","module":"Mathlib.Algebra.Ring.Idempotent","initialProofState":"R : Type u_1\ninst✝ : Ring R\na b : R\nh : Commute a b\nhp : IsIdempotentElem a\nhq : IsIdempotentElem b\n⊢ IsIdempotentElem (HSub.hSub (HAdd.hAdd a b) (HMul.hMul a b))","decl":"lemma add_sub_mul_of_commute (h : Commute a b) (hp : IsIdempotentElem a) (hq : IsIdempotentElem b) :\n    IsIdempotentElem (a + b - a * b) := by\n  convert (hp.one_sub.mul_of_commute ?_ hq.one_sub).one_sub using 1\n  · simp_rw [sub_mul, mul_sub, one_mul, mul_one, sub_sub, sub_sub_cancel, add_sub, add_comm]\n  · simp_rw [commute_iff_eq, sub_mul, mul_sub, one_mul, mul_one, sub_sub, add_sub, add_comm, h.eq]\n\n"}
{"name":"IsIdempotentElem.add_sub_mul","module":"Mathlib.Algebra.Ring.Idempotent","initialProofState":"R : Type u_1\ninst✝ : CommRing R\na b : R\nhp : IsIdempotentElem a\nhq : IsIdempotentElem b\n⊢ IsIdempotentElem (HSub.hSub (HAdd.hAdd a b) (HMul.hMul a b))","decl":"lemma add_sub_mul (hp : IsIdempotentElem a) (hq : IsIdempotentElem b) :\n    IsIdempotentElem (a + b - a * b) := add_sub_mul_of_commute (.all ..) hp hq\n\n"}
