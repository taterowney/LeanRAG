{"name":"ModuleCat.instSmallSubtypeForallCarrierObjMemSubmoduleSectionsSubmodule","module":"Mathlib.Algebra.Category.ModuleCat.Limits","initialProofState":"R : Type u\ninst✝² : Ring R\nJ : Type v\ninst✝¹ : CategoryTheory.Category.{t, v} J\nF : CategoryTheory.Functor J (ModuleCat R)\ninst✝ : Small.{w, max v w} ↑(F.comp (CategoryTheory.forget (ModuleCat R))).sections\n⊢ Small.{w, max v w} (Subtype fun x => Membership.mem (ModuleCat.sectionsSubmodule F) x)","decl":"instance : Small.{w} (sectionsSubmodule F) :=\n  inferInstanceAs <| Small.{w} (Functor.sections (F ⋙ forget (ModuleCat R)))\n\n-- Adding the following instance speeds up `limitModule` noticeably,\n-- by preventing a bad unfold of `limitAddCommGroup`.\n"}
{"name":"ModuleCat.hasLimit","module":"Mathlib.Algebra.Category.ModuleCat.Limits","initialProofState":"R : Type u\ninst✝² : Ring R\nJ : Type v\ninst✝¹ : CategoryTheory.Category.{t, v} J\nF : CategoryTheory.Functor J (ModuleCat R)\ninst✝ : Small.{w, max v w} ↑(F.comp (CategoryTheory.forget (ModuleCat R))).sections\n⊢ CategoryTheory.Limits.HasLimit F","decl":"/-- If `(F ⋙ forget (ModuleCat R)).sections` is `u`-small, `F` has a limit. -/\ninstance hasLimit : HasLimit F := HasLimit.mk {\n    cone := limitCone F\n    isLimit := limitConeIsLimit F\n  }\n\n"}
{"name":"ModuleCat.hasLimitsOfShape","module":"Mathlib.Algebra.Category.ModuleCat.Limits","initialProofState":"R : Type u\ninst✝² : Ring R\nJ : Type v\ninst✝¹ : CategoryTheory.Category.{t, v} J\ninst✝ : Small.{w, v} J\n⊢ CategoryTheory.Limits.HasLimitsOfShape J (ModuleCat R)","decl":"/-- If `J` is `u`-small, the category of `R`-modules has limits of shape `J`. -/\nlemma hasLimitsOfShape [Small.{w} J] : HasLimitsOfShape J (ModuleCat.{w} R) where\n\n-- Porting note: mathport translated this as `irreducible_def`, but as `HasLimitsOfSize`\n-- is a `Prop`, declaring this as `irreducible` should presumably have no effect\n"}
{"name":"ModuleCat.hasLimitsOfSize","module":"Mathlib.Algebra.Category.ModuleCat.Limits","initialProofState":"R : Type u\ninst✝¹ : Ring R\ninst✝ : UnivLE.{v, w}\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{t, v, w, max (w + 1) u} (ModuleCat R)","decl":"/-- The category of R-modules has all limits. -/\nlemma hasLimitsOfSize [UnivLE.{v, w}] : HasLimitsOfSize.{t, v} (ModuleCat.{w} R) where\n  has_limits_of_shape _ := hasLimitsOfShape\n\n"}
{"name":"ModuleCat.hasLimits","module":"Mathlib.Algebra.Category.ModuleCat.Limits","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ CategoryTheory.Limits.HasLimits (ModuleCat R)","decl":"instance hasLimits : HasLimits (ModuleCat.{w} R) :=\n  ModuleCat.hasLimitsOfSize.{w, w, w, u}\n\n"}
{"name":"ModuleCat.hasLimits'","module":"Mathlib.Algebra.Category.ModuleCat.Limits","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ CategoryTheory.Limits.HasLimits (ModuleCat R)","decl":"instance (priority := high) hasLimits' : HasLimits (ModuleCat.{u} R) :=\n  ModuleCat.hasLimitsOfSize.{u, u, u}\n\n"}
{"name":"ModuleCat.forget₂AddCommGroup_preservesLimit","module":"Mathlib.Algebra.Category.ModuleCat.Limits","initialProofState":"R : Type u\ninst✝² : Ring R\nJ : Type v\ninst✝¹ : CategoryTheory.Category.{t, v} J\nF : CategoryTheory.Functor J (ModuleCat R)\ninst✝ : Small.{w, max v w} ↑(F.comp (CategoryTheory.forget (ModuleCat R))).sections\n⊢ CategoryTheory.Limits.PreservesLimit F (CategoryTheory.forget₂ (ModuleCat R) AddCommGrp)","decl":"/-- The forgetful functor from R-modules to abelian groups preserves all limits. -/\ninstance forget₂AddCommGroup_preservesLimit :\n    PreservesLimit F (forget₂ (ModuleCat R) AddCommGrp) :=\n  preservesLimit_of_preserves_limit_cone (limitConeIsLimit F)\n    (forget₂AddCommGroup_preservesLimitsAux F)\n\n"}
{"name":"ModuleCat.forget₂AddCommGroup_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.ModuleCat.Limits","initialProofState":"R : Type u\ninst✝¹ : Ring R\ninst✝ : UnivLE.{v, w}\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{t, v, w, w, max u (w + 1), w + 1} (CategoryTheory.forget₂ (ModuleCat R) AddCommGrp)","decl":"/-- The forgetful functor from R-modules to abelian groups preserves all limits.\n-/\ninstance forget₂AddCommGroup_preservesLimitsOfSize [UnivLE.{v, w}] :\n    PreservesLimitsOfSize.{t, v}\n      (forget₂ (ModuleCat.{w} R) AddCommGrp.{w}) where\n  preservesLimitsOfShape := { preservesLimit := inferInstance }\n\n"}
{"name":"ModuleCat.forget₂AddCommGroup_preservesLimits","module":"Mathlib.Algebra.Category.ModuleCat.Limits","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget₂ (ModuleCat R) AddCommGrp)","decl":"instance forget₂AddCommGroup_preservesLimits :\n    PreservesLimits (forget₂ (ModuleCat R) AddCommGrp.{w}) :=\n  ModuleCat.forget₂AddCommGroup_preservesLimitsOfSize.{w, w}\n\n"}
{"name":"ModuleCat.forget_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.ModuleCat.Limits","initialProofState":"R : Type u\ninst✝¹ : Ring R\ninst✝ : UnivLE.{v, w}\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{t, v, w, w, max u (w + 1), w + 1} (CategoryTheory.forget (ModuleCat R))","decl":"/-- The forgetful functor from R-modules to types preserves all limits.\n-/\ninstance forget_preservesLimitsOfSize [UnivLE.{v, w}] :\n    PreservesLimitsOfSize.{t, v} (forget (ModuleCat.{w} R)) where\n  preservesLimitsOfShape :=\n    { preservesLimit := fun {K} ↦ preservesLimit_of_preserves_limit_cone (limitConeIsLimit K)\n        (Types.Small.limitConeIsLimit.{v} (_ ⋙ forget _)) }\n\n"}
{"name":"ModuleCat.forget_preservesLimits","module":"Mathlib.Algebra.Category.ModuleCat.Limits","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget (ModuleCat R))","decl":"instance forget_preservesLimits : PreservesLimits (forget (ModuleCat.{w} R)) :=\n  ModuleCat.forget_preservesLimitsOfSize.{w, w}\n\n"}
{"name":"ModuleCat.forget₂AddCommGroup_reflectsLimit","module":"Mathlib.Algebra.Category.ModuleCat.Limits","initialProofState":"R : Type u\ninst✝¹ : Ring R\nJ : Type v\ninst✝ : CategoryTheory.Category.{t, v} J\nF : CategoryTheory.Functor J (ModuleCat R)\n⊢ CategoryTheory.Limits.ReflectsLimit F (CategoryTheory.forget₂ (ModuleCat R) AddCommGrp)","decl":"instance forget₂AddCommGroup_reflectsLimit :\n    ReflectsLimit F (forget₂ (ModuleCat.{w} R) AddCommGrp) where\n  reflects {c} hc := ⟨by\n    have : HasLimit (F ⋙ forget₂ (ModuleCat R) AddCommGrp) := ⟨_, hc⟩\n    have : Small.{w} (Functor.sections (F ⋙ forget (ModuleCat R))) := by\n      simpa only [AddCommGrp.hasLimit_iff_small_sections] using this\n    have := reflectsLimit_of_reflectsIsomorphisms F (forget₂ (ModuleCat R) AddCommGrp)\n    exact isLimitOfReflects _ hc⟩\n\n"}
{"name":"ModuleCat.forget₂AddCommGroup_reflectsLimitOfShape","module":"Mathlib.Algebra.Category.ModuleCat.Limits","initialProofState":"R : Type u\ninst✝¹ : Ring R\nJ : Type v\ninst✝ : CategoryTheory.Category.{t, v} J\n⊢ CategoryTheory.Limits.ReflectsLimitsOfShape J (CategoryTheory.forget₂ (ModuleCat R) AddCommGrp)","decl":"instance forget₂AddCommGroup_reflectsLimitOfShape :\n    ReflectsLimitsOfShape J (forget₂ (ModuleCat.{w} R) AddCommGrp) where\n\n"}
{"name":"ModuleCat.forget₂AddCommGroup_reflectsLimitOfSize","module":"Mathlib.Algebra.Category.ModuleCat.Limits","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ CategoryTheory.Limits.ReflectsLimitsOfSize.{t, v, w, w, max u (w + 1), w + 1} (CategoryTheory.forget₂ (ModuleCat R) AddCommGrp)","decl":"instance forget₂AddCommGroup_reflectsLimitOfSize :\n    ReflectsLimitsOfSize.{t, v} (forget₂ (ModuleCat.{w} R) AddCommGrp) where\n\n"}
{"name":"ModuleCat.directLimitDiagram_obj_carrier","module":"Mathlib.Algebra.Category.ModuleCat.Limits","initialProofState":"R : Type u\ninst✝³ : Ring R\nι : Type v\ninst✝² : Preorder ι\nG : ι → Type v\ninst✝¹ : (i : ι) → AddCommGroup (G i)\ninst✝ : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\ni : ι\n⊢ Eq (↑((ModuleCat.directLimitDiagram G f).obj i)) (G i)","decl":"/-- The diagram (in the sense of `CategoryTheory`)\n of an unbundled `directLimit` of modules. -/\n@[simps]\ndef directLimitDiagram : ι ⥤ ModuleCat R where\n  obj i := ModuleCat.of R (G i)\n  map hij := ofHom (f _ _ hij.le)\n  map_id i := by\n    ext\n    apply Module.DirectedSystem.map_self\n  map_comp hij hjk := by\n    ext\n    symm\n    apply Module.DirectedSystem.map_map f\n\n"}
{"name":"ModuleCat.directLimitDiagram_obj_isAddCommGroup","module":"Mathlib.Algebra.Category.ModuleCat.Limits","initialProofState":"R : Type u\ninst✝³ : Ring R\nι : Type v\ninst✝² : Preorder ι\nG : ι → Type v\ninst✝¹ : (i : ι) → AddCommGroup (G i)\ninst✝ : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\ni : ι\n⊢ Eq ((ModuleCat.directLimitDiagram G f).obj i).isAddCommGroup (inst✝¹ i)","decl":"/-- The diagram (in the sense of `CategoryTheory`)\n of an unbundled `directLimit` of modules. -/\n@[simps]\ndef directLimitDiagram : ι ⥤ ModuleCat R where\n  obj i := ModuleCat.of R (G i)\n  map hij := ofHom (f _ _ hij.le)\n  map_id i := by\n    ext\n    apply Module.DirectedSystem.map_self\n  map_comp hij hjk := by\n    ext\n    symm\n    apply Module.DirectedSystem.map_map f\n\n"}
{"name":"ModuleCat.directLimitDiagram_map","module":"Mathlib.Algebra.Category.ModuleCat.Limits","initialProofState":"R : Type u\ninst✝³ : Ring R\nι : Type v\ninst✝² : Preorder ι\nG : ι → Type v\ninst✝¹ : (i : ι) → AddCommGroup (G i)\ninst✝ : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\nX✝ Y✝ : ι\nhij : Quiver.Hom X✝ Y✝\n⊢ Eq ((ModuleCat.directLimitDiagram G f).map hij) (ModuleCat.ofHom (f X✝ Y✝ ⋯))","decl":"/-- The diagram (in the sense of `CategoryTheory`)\n of an unbundled `directLimit` of modules. -/\n@[simps]\ndef directLimitDiagram : ι ⥤ ModuleCat R where\n  obj i := ModuleCat.of R (G i)\n  map hij := ofHom (f _ _ hij.le)\n  map_id i := by\n    ext\n    apply Module.DirectedSystem.map_self\n  map_comp hij hjk := by\n    ext\n    symm\n    apply Module.DirectedSystem.map_map f\n\n"}
{"name":"ModuleCat.directLimitDiagram_obj_isModule","module":"Mathlib.Algebra.Category.ModuleCat.Limits","initialProofState":"R : Type u\ninst✝³ : Ring R\nι : Type v\ninst✝² : Preorder ι\nG : ι → Type v\ninst✝¹ : (i : ι) → AddCommGroup (G i)\ninst✝ : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\ni : ι\n⊢ Eq ((ModuleCat.directLimitDiagram G f).obj i).isModule (inst✝ i)","decl":"/-- The diagram (in the sense of `CategoryTheory`)\n of an unbundled `directLimit` of modules. -/\n@[simps]\ndef directLimitDiagram : ι ⥤ ModuleCat R where\n  obj i := ModuleCat.of R (G i)\n  map hij := ofHom (f _ _ hij.le)\n  map_id i := by\n    ext\n    apply Module.DirectedSystem.map_self\n  map_comp hij hjk := by\n    ext\n    symm\n    apply Module.DirectedSystem.map_map f\n\n"}
{"name":"ModuleCat.directLimitCocone_ι_app","module":"Mathlib.Algebra.Category.ModuleCat.Limits","initialProofState":"R : Type u\ninst✝⁴ : Ring R\nι : Type v\ninst✝³ : Preorder ι\nG : ι → Type v\ninst✝² : (i : ι) → AddCommGroup (G i)\ninst✝¹ : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\ninst✝ : DecidableEq ι\nx : ι\n⊢ Eq ((ModuleCat.directLimitCocone G f).ι.app x) (ModuleCat.ofHom (Module.DirectLimit.of R ι G f x))","decl":"/-- The `Cocone` on `directLimitDiagram` corresponding to\nthe unbundled `directLimit` of modules.\n\nIn `directLimitIsColimit` we show that it is a colimit cocone. -/\n@[simps]\ndef directLimitCocone : Cocone (directLimitDiagram G f) where\n  pt := ModuleCat.of R <| DirectLimit G f\n  ι :=\n    { app := fun x => ofHom (Module.DirectLimit.of R ι G f x)\n      naturality := fun _ _ hij => by\n        ext\n        exact DirectLimit.of_f }\n\n"}
{"name":"ModuleCat.directLimitCocone_pt_isAddCommGroup","module":"Mathlib.Algebra.Category.ModuleCat.Limits","initialProofState":"R : Type u\ninst✝⁴ : Ring R\nι : Type v\ninst✝³ : Preorder ι\nG : ι → Type v\ninst✝² : (i : ι) → AddCommGroup (G i)\ninst✝¹ : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\ninst✝ : DecidableEq ι\n⊢ Eq (ModuleCat.directLimitCocone G f).pt.isAddCommGroup (Module.DirectLimit.addCommGroup G f)","decl":"/-- The `Cocone` on `directLimitDiagram` corresponding to\nthe unbundled `directLimit` of modules.\n\nIn `directLimitIsColimit` we show that it is a colimit cocone. -/\n@[simps]\ndef directLimitCocone : Cocone (directLimitDiagram G f) where\n  pt := ModuleCat.of R <| DirectLimit G f\n  ι :=\n    { app := fun x => ofHom (Module.DirectLimit.of R ι G f x)\n      naturality := fun _ _ hij => by\n        ext\n        exact DirectLimit.of_f }\n\n"}
{"name":"ModuleCat.directLimitCocone_pt_isModule","module":"Mathlib.Algebra.Category.ModuleCat.Limits","initialProofState":"R : Type u\ninst✝⁴ : Ring R\nι : Type v\ninst✝³ : Preorder ι\nG : ι → Type v\ninst✝² : (i : ι) → AddCommGroup (G i)\ninst✝¹ : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\ninst✝ : DecidableEq ι\n⊢ Eq (ModuleCat.directLimitCocone G f).pt.isModule (Module.DirectLimit.module G f)","decl":"/-- The `Cocone` on `directLimitDiagram` corresponding to\nthe unbundled `directLimit` of modules.\n\nIn `directLimitIsColimit` we show that it is a colimit cocone. -/\n@[simps]\ndef directLimitCocone : Cocone (directLimitDiagram G f) where\n  pt := ModuleCat.of R <| DirectLimit G f\n  ι :=\n    { app := fun x => ofHom (Module.DirectLimit.of R ι G f x)\n      naturality := fun _ _ hij => by\n        ext\n        exact DirectLimit.of_f }\n\n"}
{"name":"ModuleCat.directLimitCocone_pt_carrier","module":"Mathlib.Algebra.Category.ModuleCat.Limits","initialProofState":"R : Type u\ninst✝⁴ : Ring R\nι : Type v\ninst✝³ : Preorder ι\nG : ι → Type v\ninst✝² : (i : ι) → AddCommGroup (G i)\ninst✝¹ : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\ninst✝ : DecidableEq ι\n⊢ Eq (↑(ModuleCat.directLimitCocone G f).pt) (Module.DirectLimit G f)","decl":"/-- The `Cocone` on `directLimitDiagram` corresponding to\nthe unbundled `directLimit` of modules.\n\nIn `directLimitIsColimit` we show that it is a colimit cocone. -/\n@[simps]\ndef directLimitCocone : Cocone (directLimitDiagram G f) where\n  pt := ModuleCat.of R <| DirectLimit G f\n  ι :=\n    { app := fun x => ofHom (Module.DirectLimit.of R ι G f x)\n      naturality := fun _ _ hij => by\n        ext\n        exact DirectLimit.of_f }\n\n"}
{"name":"ModuleCat.directLimitIsColimit_desc","module":"Mathlib.Algebra.Category.ModuleCat.Limits","initialProofState":"R : Type u\ninst✝⁴ : Ring R\nι : Type v\ninst✝³ : Preorder ι\nG : ι → Type v\ninst✝² : (i : ι) → AddCommGroup (G i)\ninst✝¹ : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\ninst✝ : DecidableEq ι\ns : CategoryTheory.Limits.Cocone (ModuleCat.directLimitDiagram G f)\n⊢ Eq ((ModuleCat.directLimitIsColimit G f).desc s) (ModuleCat.ofHom (Module.DirectLimit.lift R ι G f (fun i => ModuleCat.Hom.hom (s.ι.app i)) ⋯))","decl":"/-- The unbundled `directLimit` of modules is a colimit\nin the sense of `CategoryTheory`. -/\n@[simps]\ndef directLimitIsColimit : IsColimit (directLimitCocone G f) where\n  desc s := ofHom <|\n    Module.DirectLimit.lift R ι G f (fun i => (s.ι.app i).hom) fun i j h x => by\n      simp only [Functor.const_obj_obj]\n      rw [← s.w (homOfLE h)]\n      rfl\n  fac s i := by\n    ext\n    dsimp only [hom_comp, directLimitCocone, hom_ofHom, LinearMap.comp_apply]\n    apply DirectLimit.lift_of\n  uniq s m h := by\n    have :\n      s.ι.app = fun i =>\n        (ofHom (DirectLimit.of R ι (fun i => G i) (fun i j H => f i j H) i)) ≫ m := by\n      funext i\n      rw [← h]\n      rfl\n    ext\n    simp only [this]\n    apply Module.DirectLimit.lift_unique\n\n"}
