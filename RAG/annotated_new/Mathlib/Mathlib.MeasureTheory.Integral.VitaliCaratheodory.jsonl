{"name":"MeasureTheory.SimpleFunc.exists_le_lowerSemicontinuous_lintegral_ge","module":"Mathlib.MeasureTheory.Integral.VitaliCaratheodory","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\ninst✝² : MeasurableSpace α\ninst✝¹ : BorelSpace α\nμ : MeasureTheory.Measure α\ninst✝ : μ.WeaklyRegular\nf : MeasureTheory.SimpleFunc α NNReal\nε : ENNReal\nε0 : Ne ε 0\n⊢ Exists fun g => And (∀ (x : α), LE.le (f x) (g x)) (And (LowerSemicontinuous g) (LE.le (MeasureTheory.lintegral μ fun x => ↑(g x)) (HAdd.hAdd (MeasureTheory.lintegral μ fun x => ↑(f x)) ε)))","decl":"/-- Given a simple function `f` with values in `ℝ≥0`, there exists a lower semicontinuous\nfunction `g ≥ f` with integral arbitrarily close to that of `f`. Formulation in terms of\n`lintegral`.\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem SimpleFunc.exists_le_lowerSemicontinuous_lintegral_ge (f : α →ₛ ℝ≥0) {ε : ℝ≥0∞}\n    (ε0 : ε ≠ 0) :\n    ∃ g : α → ℝ≥0, (∀ x, f x ≤ g x) ∧ LowerSemicontinuous g ∧\n      (∫⁻ x, g x ∂μ) ≤ (∫⁻ x, f x ∂μ) + ε := by\n  induction' f using MeasureTheory.SimpleFunc.induction with c s hs f₁ f₂ _ h₁ h₂ generalizing ε\n  · let f := SimpleFunc.piecewise s hs (SimpleFunc.const α c) (SimpleFunc.const α 0)\n    by_cases h : ∫⁻ x, f x ∂μ = ⊤\n    · refine\n        ⟨fun _ => c, fun x => ?_, lowerSemicontinuous_const, by\n          simp only [f, _root_.top_add, le_top, h]⟩\n      simp only [SimpleFunc.coe_const, SimpleFunc.const_zero, SimpleFunc.coe_zero,\n        Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise]\n      exact Set.indicator_le_self _ _ _\n    by_cases hc : c = 0\n    · refine ⟨fun _ => 0, ?_, lowerSemicontinuous_const, ?_⟩\n      · classical\n        simp only [hc, Set.indicator_zero', Pi.zero_apply, SimpleFunc.const_zero, imp_true_iff,\n          eq_self_iff_true, SimpleFunc.coe_zero, Set.piecewise_eq_indicator,\n          SimpleFunc.coe_piecewise, le_zero_iff]\n      · simp only [lintegral_const, zero_mul, zero_le, ENNReal.coe_zero]\n    have ne_top : μ s ≠ ⊤ := by\n      classical\n      simpa [f, hs, hc, lt_top_iff_ne_top, SimpleFunc.coe_const,\n        Function.const_apply, lintegral_const, ENNReal.coe_indicator, Set.univ_inter,\n        ENNReal.coe_ne_top, MeasurableSet.univ, ENNReal.mul_eq_top, SimpleFunc.const_zero,\n        lintegral_indicator, ENNReal.coe_eq_zero, Ne, not_false_iff,\n        SimpleFunc.coe_zero, Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise,\n        restrict_apply] using h\n    have : μ s < μ s + ε / c := by\n      have : (0 : ℝ≥0∞) < ε / c := ENNReal.div_pos_iff.2 ⟨ε0, ENNReal.coe_ne_top⟩\n      simpa using ENNReal.add_lt_add_left ne_top this\n    obtain ⟨u, su, u_open, μu⟩ : ∃ (u : _), u ⊇ s ∧ IsOpen u ∧ μ u < μ s + ε / c :=\n      s.exists_isOpen_lt_of_lt _ this\n    refine ⟨Set.indicator u fun _ => c,\n            fun x => ?_, u_open.lowerSemicontinuous_indicator (zero_le _), ?_⟩\n    · simp only [SimpleFunc.coe_const, SimpleFunc.const_zero, SimpleFunc.coe_zero,\n        Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise]\n      exact Set.indicator_le_indicator_of_subset su (fun x => zero_le _) _\n    · suffices (c : ℝ≥0∞) * μ u ≤ c * μ s + ε by\n        classical\n        simpa only [ENNReal.coe_indicator, u_open.measurableSet, lintegral_indicator,\n          lintegral_const, MeasurableSet.univ, Measure.restrict_apply, Set.univ_inter, const_zero,\n          coe_piecewise, coe_const, coe_zero, Set.piecewise_eq_indicator, Function.const_apply, hs]\n      calc\n        (c : ℝ≥0∞) * μ u ≤ c * (μ s + ε / c) := mul_le_mul_left' μu.le _\n        _ = c * μ s + ε := by\n          simp_rw [mul_add]\n          rw [ENNReal.mul_div_cancel _ ENNReal.coe_ne_top]\n          simpa using hc\n\n  · rcases h₁ (ENNReal.half_pos ε0).ne' with ⟨g₁, f₁_le_g₁, g₁cont, g₁int⟩\n    rcases h₂ (ENNReal.half_pos ε0).ne' with ⟨g₂, f₂_le_g₂, g₂cont, g₂int⟩\n    refine\n      ⟨fun x => g₁ x + g₂ x, fun x => add_le_add (f₁_le_g₁ x) (f₂_le_g₂ x), g₁cont.add g₂cont, ?_⟩\n    simp only [SimpleFunc.coe_add, ENNReal.coe_add, Pi.add_apply]\n    rw [lintegral_add_left f₁.measurable.coe_nnreal_ennreal,\n      lintegral_add_left g₁cont.measurable.coe_nnreal_ennreal]\n    convert add_le_add g₁int g₂int using 1\n    conv_lhs => rw [← ENNReal.add_halves ε]\n    abel\n\n-- Porting note: errors with\n-- `ambiguous identifier 'eapproxDiff', possible interpretations:`\n-- `[SimpleFunc.eapproxDiff, SimpleFunc.eapproxDiff]`\n-- open SimpleFunc (eapproxDiff tsum_eapproxDiff)\n\n"}
{"name":"MeasureTheory.exists_le_lowerSemicontinuous_lintegral_ge","module":"Mathlib.MeasureTheory.Integral.VitaliCaratheodory","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\ninst✝² : MeasurableSpace α\ninst✝¹ : BorelSpace α\nμ : MeasureTheory.Measure α\ninst✝ : μ.WeaklyRegular\nf : α → ENNReal\nhf : Measurable f\nε : ENNReal\nεpos : Ne ε 0\n⊢ Exists fun g => And (∀ (x : α), LE.le (f x) (g x)) (And (LowerSemicontinuous g) (LE.le (MeasureTheory.lintegral μ fun x => g x) (HAdd.hAdd (MeasureTheory.lintegral μ fun x => f x) ε)))","decl":"/-- Given a measurable function `f` with values in `ℝ≥0`, there exists a lower semicontinuous\nfunction `g ≥ f` with integral arbitrarily close to that of `f`. Formulation in terms of\n`lintegral`.\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem exists_le_lowerSemicontinuous_lintegral_ge (f : α → ℝ≥0∞) (hf : Measurable f) {ε : ℝ≥0∞}\n    (εpos : ε ≠ 0) :\n    ∃ g : α → ℝ≥0∞,\n      (∀ x, f x ≤ g x) ∧ LowerSemicontinuous g ∧ (∫⁻ x, g x ∂μ) ≤ (∫⁻ x, f x ∂μ) + ε := by\n  rcases ENNReal.exists_pos_sum_of_countable' εpos ℕ with ⟨δ, δpos, hδ⟩\n  have :\n    ∀ n,\n      ∃ g : α → ℝ≥0,\n        (∀ x, SimpleFunc.eapproxDiff f n x ≤ g x) ∧\n          LowerSemicontinuous g ∧\n            (∫⁻ x, g x ∂μ) ≤ (∫⁻ x, SimpleFunc.eapproxDiff f n x ∂μ) + δ n :=\n    fun n =>\n    SimpleFunc.exists_le_lowerSemicontinuous_lintegral_ge μ (SimpleFunc.eapproxDiff f n)\n      (δpos n).ne'\n  choose g f_le_g gcont hg using this\n  refine ⟨fun x => ∑' n, g n x, fun x => ?_, ?_, ?_⟩\n  · rw [← SimpleFunc.tsum_eapproxDiff f hf]\n    exact ENNReal.tsum_le_tsum fun n => ENNReal.coe_le_coe.2 (f_le_g n x)\n  · refine lowerSemicontinuous_tsum fun n => ?_\n    exact\n      ENNReal.continuous_coe.comp_lowerSemicontinuous (gcont n) fun x y hxy =>\n        ENNReal.coe_le_coe.2 hxy\n  · calc\n      ∫⁻ x, ∑' n : ℕ, g n x ∂μ = ∑' n, ∫⁻ x, g n x ∂μ := by\n        rw [lintegral_tsum fun n => (gcont n).measurable.coe_nnreal_ennreal.aemeasurable]\n      _ ≤ ∑' n, ((∫⁻ x, SimpleFunc.eapproxDiff f n x ∂μ) + δ n) := ENNReal.tsum_le_tsum hg\n      _ = ∑' n, ∫⁻ x, SimpleFunc.eapproxDiff f n x ∂μ + ∑' n, δ n := ENNReal.tsum_add\n      _ ≤ (∫⁻ x : α, f x ∂μ) + ε := by\n        refine add_le_add ?_ hδ.le\n        rw [← lintegral_tsum]\n        · simp_rw [SimpleFunc.tsum_eapproxDiff f hf, le_refl]\n        · intro n; exact (SimpleFunc.measurable _).coe_nnreal_ennreal.aemeasurable\n\n"}
{"name":"MeasureTheory.exists_lt_lowerSemicontinuous_lintegral_ge","module":"Mathlib.MeasureTheory.Integral.VitaliCaratheodory","initialProofState":"α : Type u_1\ninst✝⁴ : TopologicalSpace α\ninst✝³ : MeasurableSpace α\ninst✝² : BorelSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : μ.WeaklyRegular\ninst✝ : MeasureTheory.SigmaFinite μ\nf : α → NNReal\nfmeas : Measurable f\nε : ENNReal\nε0 : Ne ε 0\n⊢ Exists fun g => And (∀ (x : α), LT.lt (↑(f x)) (g x)) (And (LowerSemicontinuous g) (LE.le (MeasureTheory.lintegral μ fun x => g x) (HAdd.hAdd (MeasureTheory.lintegral μ fun x => ↑(f x)) ε)))","decl":"/-- Given a measurable function `f` with values in `ℝ≥0` in a sigma-finite space, there exists a\nlower semicontinuous function `g > f` with integral arbitrarily close to that of `f`.\nFormulation in terms of `lintegral`.\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem exists_lt_lowerSemicontinuous_lintegral_ge [SigmaFinite μ] (f : α → ℝ≥0)\n    (fmeas : Measurable f) {ε : ℝ≥0∞} (ε0 : ε ≠ 0) :\n    ∃ g : α → ℝ≥0∞,\n      (∀ x, (f x : ℝ≥0∞) < g x) ∧ LowerSemicontinuous g ∧ (∫⁻ x, g x ∂μ) ≤ (∫⁻ x, f x ∂μ) + ε := by\n  have : ε / 2 ≠ 0 := (ENNReal.half_pos ε0).ne'\n  rcases exists_pos_lintegral_lt_of_sigmaFinite μ this with ⟨w, wpos, wmeas, wint⟩\n  let f' x := ((f x + w x : ℝ≥0) : ℝ≥0∞)\n  rcases exists_le_lowerSemicontinuous_lintegral_ge μ f' (fmeas.add wmeas).coe_nnreal_ennreal\n      this with\n    ⟨g, le_g, gcont, gint⟩\n  refine ⟨g, fun x => ?_, gcont, ?_⟩\n  · calc\n      (f x : ℝ≥0∞) < f' x := by\n        simpa only [← ENNReal.coe_lt_coe, add_zero] using add_lt_add_left (wpos x) (f x)\n      _ ≤ g x := le_g x\n  · calc\n      (∫⁻ x : α, g x ∂μ) ≤ (∫⁻ x : α, f x + w x ∂μ) + ε / 2 := gint\n      _ = ((∫⁻ x : α, f x ∂μ) + ∫⁻ x : α, w x ∂μ) + ε / 2 := by\n        rw [lintegral_add_right _ wmeas.coe_nnreal_ennreal]\n      _ ≤ (∫⁻ x : α, f x ∂μ) + ε / 2 + ε / 2 := add_le_add_right (add_le_add_left wint.le _) _\n      _ = (∫⁻ x : α, f x ∂μ) + ε := by rw [add_assoc, ENNReal.add_halves]\n\n"}
{"name":"MeasureTheory.exists_lt_lowerSemicontinuous_lintegral_ge_of_aemeasurable","module":"Mathlib.MeasureTheory.Integral.VitaliCaratheodory","initialProofState":"α : Type u_1\ninst✝⁴ : TopologicalSpace α\ninst✝³ : MeasurableSpace α\ninst✝² : BorelSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : μ.WeaklyRegular\ninst✝ : MeasureTheory.SigmaFinite μ\nf : α → NNReal\nfmeas : AEMeasurable f μ\nε : ENNReal\nε0 : Ne ε 0\n⊢ Exists fun g => And (∀ (x : α), LT.lt (↑(f x)) (g x)) (And (LowerSemicontinuous g) (LE.le (MeasureTheory.lintegral μ fun x => g x) (HAdd.hAdd (MeasureTheory.lintegral μ fun x => ↑(f x)) ε)))","decl":"/-- Given an almost everywhere measurable function `f` with values in `ℝ≥0` in a sigma-finite space,\nthere exists a lower semicontinuous function `g > f` with integral arbitrarily close to that of `f`.\nFormulation in terms of `lintegral`.\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem exists_lt_lowerSemicontinuous_lintegral_ge_of_aemeasurable [SigmaFinite μ] (f : α → ℝ≥0)\n    (fmeas : AEMeasurable f μ) {ε : ℝ≥0∞} (ε0 : ε ≠ 0) :\n    ∃ g : α → ℝ≥0∞,\n      (∀ x, (f x : ℝ≥0∞) < g x) ∧ LowerSemicontinuous g ∧ (∫⁻ x, g x ∂μ) ≤ (∫⁻ x, f x ∂μ) + ε := by\n  have : ε / 2 ≠ 0 := (ENNReal.half_pos ε0).ne'\n  rcases exists_lt_lowerSemicontinuous_lintegral_ge μ (fmeas.mk f) fmeas.measurable_mk this with\n    ⟨g0, f_lt_g0, g0_cont, g0_int⟩\n  rcases exists_measurable_superset_of_null fmeas.ae_eq_mk with ⟨s, hs, smeas, μs⟩\n  rcases exists_le_lowerSemicontinuous_lintegral_ge μ (s.indicator fun _x => ∞)\n      (measurable_const.indicator smeas) this with\n    ⟨g1, le_g1, g1_cont, g1_int⟩\n  refine ⟨fun x => g0 x + g1 x, fun x => ?_, g0_cont.add g1_cont, ?_⟩\n  · by_cases h : x ∈ s\n    · have := le_g1 x\n      simp only [h, Set.indicator_of_mem, top_le_iff] at this\n      simp [this]\n    · have : f x = fmeas.mk f x := by rw [Set.compl_subset_comm] at hs; exact hs h\n      rw [this]\n      exact (f_lt_g0 x).trans_le le_self_add\n  · calc\n      ∫⁻ x, g0 x + g1 x ∂μ = (∫⁻ x, g0 x ∂μ) + ∫⁻ x, g1 x ∂μ :=\n        lintegral_add_left g0_cont.measurable _\n      _ ≤ (∫⁻ x, f x ∂μ) + ε / 2 + (0 + ε / 2) := by\n        refine add_le_add ?_ ?_\n        · convert g0_int using 2\n          exact lintegral_congr_ae (fmeas.ae_eq_mk.fun_comp _)\n        · convert g1_int\n          simp only [smeas, μs, lintegral_const, Set.univ_inter, MeasurableSet.univ,\n            lintegral_indicator, mul_zero, restrict_apply]\n      _ = (∫⁻ x, f x ∂μ) + ε := by simp only [add_assoc, ENNReal.add_halves, zero_add]\n\n"}
{"name":"MeasureTheory.exists_lt_lowerSemicontinuous_integral_gt_nnreal","module":"Mathlib.MeasureTheory.Integral.VitaliCaratheodory","initialProofState":"α : Type u_1\ninst✝⁴ : TopologicalSpace α\ninst✝³ : MeasurableSpace α\ninst✝² : BorelSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : μ.WeaklyRegular\ninst✝ : MeasureTheory.SigmaFinite μ\nf : α → NNReal\nfint : MeasureTheory.Integrable (fun x => ↑(f x)) μ\nε : Real\nεpos : LT.lt 0 ε\n⊢ Exists fun g => And (∀ (x : α), LT.lt (↑(f x)) (g x)) (And (LowerSemicontinuous g) (And (Filter.Eventually (fun x => LT.lt (g x) Top.top) (MeasureTheory.ae μ)) (And (MeasureTheory.Integrable (fun x => (g x).toReal) μ) (LT.lt (MeasureTheory.integral μ fun x => (g x).toReal) (HAdd.hAdd (MeasureTheory.integral μ fun x => ↑(f x)) ε)))))","decl":"/-- Given an integrable function `f` with values in `ℝ≥0` in a sigma-finite space, there exists a\nlower semicontinuous function `g > f` with integral arbitrarily close to that of `f`.\nFormulation in terms of `integral`.\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem exists_lt_lowerSemicontinuous_integral_gt_nnreal [SigmaFinite μ] (f : α → ℝ≥0)\n    (fint : Integrable (fun x => (f x : ℝ)) μ) {ε : ℝ} (εpos : 0 < ε) :\n    ∃ g : α → ℝ≥0∞,\n      (∀ x, (f x : ℝ≥0∞) < g x) ∧\n      LowerSemicontinuous g ∧\n      (∀ᵐ x ∂μ, g x < ⊤) ∧\n      Integrable (fun x => (g x).toReal) μ ∧ (∫ x, (g x).toReal ∂μ) < (∫ x, ↑(f x) ∂μ) + ε := by\n  have fmeas : AEMeasurable f μ := by\n    convert fint.aestronglyMeasurable.real_toNNReal.aemeasurable\n    simp only [Real.toNNReal_coe]\n  lift ε to ℝ≥0 using εpos.le\n  obtain ⟨δ, δpos, hδε⟩ : ∃ δ : ℝ≥0, 0 < δ ∧ δ < ε := exists_between εpos\n  have int_f_ne_top : (∫⁻ a : α, f a ∂μ) ≠ ∞ :=\n    (hasFiniteIntegral_iff_ofNNReal.1 fint.hasFiniteIntegral).ne\n  rcases exists_lt_lowerSemicontinuous_lintegral_ge_of_aemeasurable μ f fmeas\n      (ENNReal.coe_ne_zero.2 δpos.ne') with\n    ⟨g, f_lt_g, gcont, gint⟩\n  have gint_ne : (∫⁻ x : α, g x ∂μ) ≠ ∞ := ne_top_of_le_ne_top (by simpa) gint\n  have g_lt_top : ∀ᵐ x : α ∂μ, g x < ∞ := ae_lt_top gcont.measurable gint_ne\n  have Ig : (∫⁻ a : α, ENNReal.ofReal (g a).toReal ∂μ) = ∫⁻ a : α, g a ∂μ := by\n    apply lintegral_congr_ae\n    filter_upwards [g_lt_top] with _ hx\n    simp only [hx.ne, ENNReal.ofReal_toReal, Ne, not_false_iff]\n  refine ⟨g, f_lt_g, gcont, g_lt_top, ?_, ?_⟩\n  · refine ⟨gcont.measurable.ennreal_toReal.aemeasurable.aestronglyMeasurable, ?_⟩\n    simp only [hasFiniteIntegral_iff_norm, Real.norm_eq_abs, abs_of_nonneg ENNReal.toReal_nonneg]\n    convert gint_ne.lt_top using 1\n  · rw [integral_eq_lintegral_of_nonneg_ae, integral_eq_lintegral_of_nonneg_ae]\n    · calc\n        ENNReal.toReal (∫⁻ a : α, ENNReal.ofReal (g a).toReal ∂μ) =\n            ENNReal.toReal (∫⁻ a : α, g a ∂μ) := by congr 1\n        _ ≤ ENNReal.toReal ((∫⁻ a : α, f a ∂μ) + δ) := by\n          apply ENNReal.toReal_mono _ gint\n          simpa using int_f_ne_top\n        _ = ENNReal.toReal (∫⁻ a : α, f a ∂μ) + δ := by\n          rw [ENNReal.toReal_add int_f_ne_top ENNReal.coe_ne_top, ENNReal.coe_toReal]\n        _ < ENNReal.toReal (∫⁻ a : α, f a ∂μ) + ε := add_lt_add_left hδε _\n        _ = (∫⁻ a : α, ENNReal.ofReal ↑(f a) ∂μ).toReal + ε := by simp\n\n    · apply Filter.Eventually.of_forall fun x => _; simp\n    · exact fmeas.coe_nnreal_real.aestronglyMeasurable\n    · apply Filter.Eventually.of_forall fun x => _; simp\n    · apply gcont.measurable.ennreal_toReal.aemeasurable.aestronglyMeasurable\n\n"}
{"name":"MeasureTheory.SimpleFunc.exists_upperSemicontinuous_le_lintegral_le","module":"Mathlib.MeasureTheory.Integral.VitaliCaratheodory","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\ninst✝² : MeasurableSpace α\ninst✝¹ : BorelSpace α\nμ : MeasureTheory.Measure α\ninst✝ : μ.WeaklyRegular\nf : MeasureTheory.SimpleFunc α NNReal\nint_f : Ne (MeasureTheory.lintegral μ fun x => ↑(f x)) Top.top\nε : ENNReal\nε0 : Ne ε 0\n⊢ Exists fun g => And (∀ (x : α), LE.le (g x) (f x)) (And (UpperSemicontinuous g) (LE.le (MeasureTheory.lintegral μ fun x => ↑(f x)) (HAdd.hAdd (MeasureTheory.lintegral μ fun x => ↑(g x)) ε)))","decl":"/-- Given a simple function `f` with values in `ℝ≥0`, there exists an upper semicontinuous\nfunction `g ≤ f` with integral arbitrarily close to that of `f`. Formulation in terms of\n`lintegral`.\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem SimpleFunc.exists_upperSemicontinuous_le_lintegral_le (f : α →ₛ ℝ≥0)\n    (int_f : (∫⁻ x, f x ∂μ) ≠ ∞) {ε : ℝ≥0∞} (ε0 : ε ≠ 0) :\n    ∃ g : α → ℝ≥0, (∀ x, g x ≤ f x) ∧ UpperSemicontinuous g ∧\n      (∫⁻ x, f x ∂μ) ≤ (∫⁻ x, g x ∂μ) + ε := by\n  induction' f using MeasureTheory.SimpleFunc.induction with c s hs f₁ f₂ _ h₁ h₂ generalizing ε\n  · by_cases hc : c = 0\n    · refine ⟨fun _ => 0, ?_, upperSemicontinuous_const, ?_⟩\n      · classical\n        simp only [hc, Set.indicator_zero', Pi.zero_apply, SimpleFunc.const_zero, imp_true_iff,\n          eq_self_iff_true, SimpleFunc.coe_zero, Set.piecewise_eq_indicator,\n          SimpleFunc.coe_piecewise, le_zero_iff]\n      · classical\n        simp only [hc, Set.indicator_zero', lintegral_const, zero_mul, Pi.zero_apply,\n          SimpleFunc.const_zero, zero_add, zero_le', SimpleFunc.coe_zero,\n          Set.piecewise_eq_indicator, ENNReal.coe_zero, SimpleFunc.coe_piecewise, zero_le]\n    have μs_lt_top : μ s < ∞ := by\n      classical\n      simpa only [hs, hc, lt_top_iff_ne_top, true_and, SimpleFunc.coe_const, or_false,\n        lintegral_const, ENNReal.coe_indicator, Set.univ_inter, ENNReal.coe_ne_top,\n        Measure.restrict_apply MeasurableSet.univ, ENNReal.mul_eq_top, SimpleFunc.const_zero,\n        Function.const_apply, lintegral_indicator, ENNReal.coe_eq_zero, Ne, not_false_iff,\n        SimpleFunc.coe_zero, Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise,\n        false_and] using int_f\n    have : (0 : ℝ≥0∞) < ε / c := ENNReal.div_pos_iff.2 ⟨ε0, ENNReal.coe_ne_top⟩\n    obtain ⟨F, Fs, F_closed, μF⟩ : ∃ (F : _), F ⊆ s ∧ IsClosed F ∧ μ s < μ F + ε / c :=\n      hs.exists_isClosed_lt_add μs_lt_top.ne this.ne'\n    refine\n      ⟨Set.indicator F fun _ => c, fun x => ?_, F_closed.upperSemicontinuous_indicator (zero_le _),\n        ?_⟩\n    · simp only [SimpleFunc.coe_const, SimpleFunc.const_zero, SimpleFunc.coe_zero,\n        Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise]\n      exact Set.indicator_le_indicator_of_subset Fs (fun x => zero_le _) _\n    · suffices (c : ℝ≥0∞) * μ s ≤ c * μ F + ε by\n        classical\n        simpa only [hs, F_closed.measurableSet, SimpleFunc.coe_const, Function.const_apply,\n          lintegral_const, ENNReal.coe_indicator, Set.univ_inter, MeasurableSet.univ,\n          SimpleFunc.const_zero, lintegral_indicator, SimpleFunc.coe_zero,\n          Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise, Measure.restrict_apply]\n      calc\n        (c : ℝ≥0∞) * μ s ≤ c * (μ F + ε / c) := mul_le_mul_left' μF.le _\n        _ = c * μ F + ε := by\n          simp_rw [mul_add]\n          rw [ENNReal.mul_div_cancel _ ENNReal.coe_ne_top]\n          simpa using hc\n  · have A : ((∫⁻ x : α, f₁ x ∂μ) + ∫⁻ x : α, f₂ x ∂μ) ≠ ⊤ := by\n      rwa [← lintegral_add_left f₁.measurable.coe_nnreal_ennreal]\n    rcases h₁ (ENNReal.add_ne_top.1 A).1 (ENNReal.half_pos ε0).ne' with\n      ⟨g₁, f₁_le_g₁, g₁cont, g₁int⟩\n    rcases h₂ (ENNReal.add_ne_top.1 A).2 (ENNReal.half_pos ε0).ne' with\n      ⟨g₂, f₂_le_g₂, g₂cont, g₂int⟩\n    refine\n      ⟨fun x => g₁ x + g₂ x, fun x => add_le_add (f₁_le_g₁ x) (f₂_le_g₂ x), g₁cont.add g₂cont, ?_⟩\n    simp only [SimpleFunc.coe_add, ENNReal.coe_add, Pi.add_apply]\n    rw [lintegral_add_left f₁.measurable.coe_nnreal_ennreal,\n      lintegral_add_left g₁cont.measurable.coe_nnreal_ennreal]\n    convert add_le_add g₁int g₂int using 1\n    conv_lhs => rw [← ENNReal.add_halves ε]\n    abel\n\n"}
{"name":"MeasureTheory.exists_upperSemicontinuous_le_lintegral_le","module":"Mathlib.MeasureTheory.Integral.VitaliCaratheodory","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\ninst✝² : MeasurableSpace α\ninst✝¹ : BorelSpace α\nμ : MeasureTheory.Measure α\ninst✝ : μ.WeaklyRegular\nf : α → NNReal\nint_f : Ne (MeasureTheory.lintegral μ fun x => ↑(f x)) Top.top\nε : ENNReal\nε0 : Ne ε 0\n⊢ Exists fun g => And (∀ (x : α), LE.le (g x) (f x)) (And (UpperSemicontinuous g) (LE.le (MeasureTheory.lintegral μ fun x => ↑(f x)) (HAdd.hAdd (MeasureTheory.lintegral μ fun x => ↑(g x)) ε)))","decl":"/-- Given an integrable function `f` with values in `ℝ≥0`, there exists an upper semicontinuous\nfunction `g ≤ f` with integral arbitrarily close to that of `f`. Formulation in terms of\n`lintegral`.\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem exists_upperSemicontinuous_le_lintegral_le (f : α → ℝ≥0) (int_f : (∫⁻ x, f x ∂μ) ≠ ∞)\n    {ε : ℝ≥0∞} (ε0 : ε ≠ 0) :\n    ∃ g : α → ℝ≥0, (∀ x, g x ≤ f x) ∧ UpperSemicontinuous g ∧\n      (∫⁻ x, f x ∂μ) ≤ (∫⁻ x, g x ∂μ) + ε := by\n  obtain ⟨fs, fs_le_f, int_fs⟩ :\n    ∃ fs : α →ₛ ℝ≥0, (∀ x, fs x ≤ f x) ∧ (∫⁻ x, f x ∂μ) ≤ (∫⁻ x, fs x ∂μ) + ε / 2 := by\n    -- Porting note: need to name identifier (not `this`), because `conv_rhs at this` errors\n    have aux := ENNReal.lt_add_right int_f (ENNReal.half_pos ε0).ne'\n    conv_rhs at aux => rw [lintegral_eq_nnreal (fun x => (f x : ℝ≥0∞)) μ]\n    erw [ENNReal.biSup_add] at aux <;> [skip; exact ⟨0, fun x => by simp⟩]\n    simp only [lt_iSup_iff] at aux\n    rcases aux with ⟨fs, fs_le_f, int_fs⟩\n    refine ⟨fs, fun x => by simpa only [ENNReal.coe_le_coe] using fs_le_f x, ?_⟩\n    convert int_fs.le\n    rw [← SimpleFunc.lintegral_eq_lintegral]\n    simp only [SimpleFunc.coe_map, Function.comp_apply]\n  have int_fs_lt_top : (∫⁻ x, fs x ∂μ) ≠ ∞ := by\n    refine ne_top_of_le_ne_top int_f (lintegral_mono fun x => ?_)\n    simpa only [ENNReal.coe_le_coe] using fs_le_f x\n  obtain ⟨g, g_le_fs, gcont, gint⟩ :\n    ∃ g : α → ℝ≥0,\n      (∀ x, g x ≤ fs x) ∧ UpperSemicontinuous g ∧ (∫⁻ x, fs x ∂μ) ≤ (∫⁻ x, g x ∂μ) + ε / 2 :=\n    fs.exists_upperSemicontinuous_le_lintegral_le int_fs_lt_top (ENNReal.half_pos ε0).ne'\n  refine ⟨g, fun x => (g_le_fs x).trans (fs_le_f x), gcont, ?_⟩\n  calc\n    (∫⁻ x, f x ∂μ) ≤ (∫⁻ x, fs x ∂μ) + ε / 2 := int_fs\n    _ ≤ (∫⁻ x, g x ∂μ) + ε / 2 + ε / 2 := add_le_add gint le_rfl\n    _ = (∫⁻ x, g x ∂μ) + ε := by rw [add_assoc, ENNReal.add_halves]\n\n"}
{"name":"MeasureTheory.exists_upperSemicontinuous_le_integral_le","module":"Mathlib.MeasureTheory.Integral.VitaliCaratheodory","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\ninst✝² : MeasurableSpace α\ninst✝¹ : BorelSpace α\nμ : MeasureTheory.Measure α\ninst✝ : μ.WeaklyRegular\nf : α → NNReal\nfint : MeasureTheory.Integrable (fun x => ↑(f x)) μ\nε : Real\nεpos : LT.lt 0 ε\n⊢ Exists fun g => And (∀ (x : α), LE.le (g x) (f x)) (And (UpperSemicontinuous g) (And (MeasureTheory.Integrable (fun x => ↑(g x)) μ) (LE.le (HSub.hSub (MeasureTheory.integral μ fun x => ↑(f x)) ε) (MeasureTheory.integral μ fun x => ↑(g x)))))","decl":"/-- Given an integrable function `f` with values in `ℝ≥0`, there exists an upper semicontinuous\nfunction `g ≤ f` with integral arbitrarily close to that of `f`. Formulation in terms of\n`integral`.\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem exists_upperSemicontinuous_le_integral_le (f : α → ℝ≥0)\n    (fint : Integrable (fun x => (f x : ℝ)) μ) {ε : ℝ} (εpos : 0 < ε) :\n    ∃ g : α → ℝ≥0,\n      (∀ x, g x ≤ f x) ∧\n      UpperSemicontinuous g ∧\n      Integrable (fun x => (g x : ℝ)) μ ∧ (∫ x, (f x : ℝ) ∂μ) - ε ≤ ∫ x, ↑(g x) ∂μ := by\n  lift ε to ℝ≥0 using εpos.le\n  rw [NNReal.coe_pos, ← ENNReal.coe_pos] at εpos\n  have If : (∫⁻ x, f x ∂μ) < ∞ := hasFiniteIntegral_iff_ofNNReal.1 fint.hasFiniteIntegral\n  rcases exists_upperSemicontinuous_le_lintegral_le f If.ne εpos.ne' with ⟨g, gf, gcont, gint⟩\n  have Ig : (∫⁻ x, g x ∂μ) < ∞ := by\n    refine lt_of_le_of_lt (lintegral_mono fun x => ?_) If\n    simpa using gf x\n  refine ⟨g, gf, gcont, ?_, ?_⟩\n  · refine\n      Integrable.mono fint gcont.measurable.coe_nnreal_real.aemeasurable.aestronglyMeasurable ?_\n    exact Filter.Eventually.of_forall fun x => by simp [gf x]\n  · rw [integral_eq_lintegral_of_nonneg_ae, integral_eq_lintegral_of_nonneg_ae]\n    · rw [sub_le_iff_le_add]\n      convert ENNReal.toReal_mono _ gint\n      · simp\n      · rw [ENNReal.toReal_add Ig.ne ENNReal.coe_ne_top]; simp\n      · simpa using Ig.ne\n    · apply Filter.Eventually.of_forall; simp\n    · exact gcont.measurable.coe_nnreal_real.aemeasurable.aestronglyMeasurable\n    · apply Filter.Eventually.of_forall; simp\n    · exact fint.aestronglyMeasurable\n\n"}
{"name":"MeasureTheory.exists_lt_lowerSemicontinuous_integral_lt","module":"Mathlib.MeasureTheory.Integral.VitaliCaratheodory","initialProofState":"α : Type u_1\ninst✝⁴ : TopologicalSpace α\ninst✝³ : MeasurableSpace α\ninst✝² : BorelSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : μ.WeaklyRegular\ninst✝ : MeasureTheory.SigmaFinite μ\nf : α → Real\nhf : MeasureTheory.Integrable f μ\nε : Real\nεpos : LT.lt 0 ε\n⊢ Exists fun g => And (∀ (x : α), LT.lt (↑(f x)) (g x)) (And (LowerSemicontinuous g) (And (MeasureTheory.Integrable (fun x => (g x).toReal) μ) (And (Filter.Eventually (fun x => LT.lt (g x) Top.top) (MeasureTheory.ae μ)) (LT.lt (MeasureTheory.integral μ fun x => (g x).toReal) (HAdd.hAdd (MeasureTheory.integral μ fun x => f x) ε)))))","decl":"/-- **Vitali-Carathéodory Theorem**: given an integrable real function `f`, there exists an\nintegrable function `g > f` which is lower semicontinuous, with integral arbitrarily close\nto that of `f`. This function has to be `EReal`-valued in general. -/\ntheorem exists_lt_lowerSemicontinuous_integral_lt [SigmaFinite μ] (f : α → ℝ) (hf : Integrable f μ)\n    {ε : ℝ} (εpos : 0 < ε) :\n    ∃ g : α → EReal,\n      (∀ x, (f x : EReal) < g x) ∧\n      LowerSemicontinuous g ∧\n      Integrable (fun x => EReal.toReal (g x)) μ ∧\n      (∀ᵐ x ∂μ, g x < ⊤) ∧ (∫ x, EReal.toReal (g x) ∂μ) < (∫ x, f x ∂μ) + ε := by\n  let δ : ℝ≥0 := ⟨ε / 2, (half_pos εpos).le⟩\n  have δpos : 0 < δ := half_pos εpos\n  let fp : α → ℝ≥0 := fun x => Real.toNNReal (f x)\n  have int_fp : Integrable (fun x => (fp x : ℝ)) μ := hf.real_toNNReal\n  rcases exists_lt_lowerSemicontinuous_integral_gt_nnreal fp int_fp δpos with\n    ⟨gp, fp_lt_gp, gpcont, gp_lt_top, gp_integrable, gpint⟩\n  let fm : α → ℝ≥0 := fun x => Real.toNNReal (-f x)\n  have int_fm : Integrable (fun x => (fm x : ℝ)) μ := hf.neg.real_toNNReal\n  rcases exists_upperSemicontinuous_le_integral_le fm int_fm δpos with\n    ⟨gm, gm_le_fm, gmcont, gm_integrable, gmint⟩\n  let g : α → EReal := fun x => (gp x : EReal) - gm x\n  have ae_g : ∀ᵐ x ∂μ, (g x).toReal = (gp x : EReal).toReal - (gm x : EReal).toReal := by\n    filter_upwards [gp_lt_top] with _ hx\n    rw [EReal.toReal_sub] <;> simp [hx.ne]\n  refine ⟨g, ?lt, ?lsc, ?int, ?aelt, ?intlt⟩\n  case int =>\n    show Integrable (fun x => EReal.toReal (g x)) μ\n    rw [integrable_congr ae_g]\n    convert gp_integrable.sub gm_integrable\n    simp\n  case intlt =>\n    show (∫ x : α, (g x).toReal ∂μ) < (∫ x : α, f x ∂μ) + ε\n    exact\n      calc\n        (∫ x : α, (g x).toReal ∂μ) = ∫ x : α, EReal.toReal (gp x) - EReal.toReal (gm x) ∂μ :=\n          integral_congr_ae ae_g\n        _ = (∫ x : α, EReal.toReal (gp x) ∂μ) - ∫ x : α, ↑(gm x) ∂μ := by\n          simp only [EReal.toReal_coe_ennreal, ENNReal.coe_toReal]\n          exact integral_sub gp_integrable gm_integrable\n        _ < (∫ x : α, ↑(fp x) ∂μ) + ↑δ - ∫ x : α, ↑(gm x) ∂μ := by\n          apply sub_lt_sub_right\n          convert gpint\n          simp only [EReal.toReal_coe_ennreal]\n        _ ≤ (∫ x : α, ↑(fp x) ∂μ) + ↑δ - ((∫ x : α, ↑(fm x) ∂μ) - δ) := sub_le_sub_left gmint _\n        _ = (∫ x : α, f x ∂μ) + 2 * δ := by\n          simp_rw [integral_eq_integral_pos_part_sub_integral_neg_part hf]; ring\n        _ = (∫ x : α, f x ∂μ) + ε := by congr 1; field_simp [δ, mul_comm]\n  case aelt =>\n    show ∀ᵐ x : α ∂μ, g x < ⊤\n    filter_upwards [gp_lt_top] with ?_ hx\n    simp only [g, sub_eq_add_neg, Ne, (EReal.add_lt_top _ _).ne, lt_top_iff_ne_top,\n      lt_top_iff_ne_top.1 hx, EReal.coe_ennreal_eq_top_iff, not_false_iff, EReal.neg_eq_top_iff,\n      EReal.coe_ennreal_ne_bot]\n  case lt =>\n    show ∀ x, (f x : EReal) < g x\n    intro x\n    rw [EReal.coe_real_ereal_eq_coe_toNNReal_sub_coe_toNNReal (f x)]\n    refine EReal.sub_lt_sub_of_lt_of_le ?_ ?_ ?_ ?_\n    · simp only [EReal.coe_ennreal_lt_coe_ennreal_iff]; exact fp_lt_gp x\n    · simp only [ENNReal.coe_le_coe, EReal.coe_ennreal_le_coe_ennreal_iff]\n      exact gm_le_fm x\n    · simp only [EReal.coe_ennreal_ne_bot, Ne, not_false_iff]\n    · simp only [EReal.coe_nnreal_ne_top, Ne, not_false_iff]\n  case lsc =>\n    show LowerSemicontinuous g\n    apply LowerSemicontinuous.add'\n    · exact continuous_coe_ennreal_ereal.comp_lowerSemicontinuous gpcont fun x y hxy =>\n          EReal.coe_ennreal_le_coe_ennreal_iff.2 hxy\n    · apply continuous_neg.comp_upperSemicontinuous_antitone _ fun x y hxy =>\n          EReal.neg_le_neg_iff.2 hxy\n      dsimp\n      apply continuous_coe_ennreal_ereal.comp_upperSemicontinuous _ fun x y hxy =>\n          EReal.coe_ennreal_le_coe_ennreal_iff.2 hxy\n      exact ENNReal.continuous_coe.comp_upperSemicontinuous gmcont fun x y hxy =>\n          ENNReal.coe_le_coe.2 hxy\n    · intro x\n      exact EReal.continuousAt_add (by simp) (by simp)\n\n"}
{"name":"MeasureTheory.exists_upperSemicontinuous_lt_integral_gt","module":"Mathlib.MeasureTheory.Integral.VitaliCaratheodory","initialProofState":"α : Type u_1\ninst✝⁴ : TopologicalSpace α\ninst✝³ : MeasurableSpace α\ninst✝² : BorelSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : μ.WeaklyRegular\ninst✝ : MeasureTheory.SigmaFinite μ\nf : α → Real\nhf : MeasureTheory.Integrable f μ\nε : Real\nεpos : LT.lt 0 ε\n⊢ Exists fun g => And (∀ (x : α), LT.lt (g x) ↑(f x)) (And (UpperSemicontinuous g) (And (MeasureTheory.Integrable (fun x => (g x).toReal) μ) (And (Filter.Eventually (fun x => LT.lt Bot.bot (g x)) (MeasureTheory.ae μ)) (LT.lt (MeasureTheory.integral μ fun x => f x) (HAdd.hAdd (MeasureTheory.integral μ fun x => (g x).toReal) ε)))))","decl":"/-- **Vitali-Carathéodory Theorem**: given an integrable real function `f`, there exists an\nintegrable function `g < f` which is upper semicontinuous, with integral arbitrarily close to that\nof `f`. This function has to be `EReal`-valued in general. -/\ntheorem exists_upperSemicontinuous_lt_integral_gt [SigmaFinite μ] (f : α → ℝ) (hf : Integrable f μ)\n    {ε : ℝ} (εpos : 0 < ε) :\n    ∃ g : α → EReal,\n      (∀ x, (g x : EReal) < f x) ∧\n      UpperSemicontinuous g ∧\n      Integrable (fun x => EReal.toReal (g x)) μ ∧\n      (∀ᵐ x ∂μ, ⊥ < g x) ∧ (∫ x, f x ∂μ) < (∫ x, EReal.toReal (g x) ∂μ) + ε := by\n  rcases exists_lt_lowerSemicontinuous_integral_lt (fun x => -f x) hf.neg εpos with\n    ⟨g, g_lt_f, gcont, g_integrable, g_lt_top, gint⟩\n  refine ⟨fun x => -g x, ?_, ?_, ?_, ?_, ?_⟩\n  · exact fun x => EReal.neg_lt_comm.1 (by simpa only [EReal.coe_neg] using g_lt_f x)\n  · exact\n      continuous_neg.comp_lowerSemicontinuous_antitone gcont fun x y hxy =>\n        EReal.neg_le_neg_iff.2 hxy\n  · convert g_integrable.neg\n    simp\n  · simpa [bot_lt_iff_ne_bot, lt_top_iff_ne_top] using g_lt_top\n  · simp_rw [integral_neg, lt_neg_add_iff_add_lt] at gint\n    rw [add_comm] at gint\n    simpa [integral_neg] using gint\n\n"}
