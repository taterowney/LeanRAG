{"name":"integral_rpow_mul_exp_neg_rpow","module":"Mathlib.MeasureTheory.Integral.Gamma","initialProofState":"p q : Real\nhp : LT.lt 0 p\nhq : LT.lt (-1) q\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun x => HMul.hMul (HPow.hPow x q) (Real.exp (Neg.neg (HPow.hPow x p)))) (HMul.hMul (HDiv.hDiv 1 p) (Real.Gamma (HDiv.hDiv (HAdd.hAdd q 1) p)))","decl":"theorem integral_rpow_mul_exp_neg_rpow {p q : ℝ} (hp : 0 < p) (hq : - 1 < q) :\n    ∫ x in Ioi (0 : ℝ), x ^ q * exp (- x ^ p) = (1 / p) * Gamma ((q + 1) / p) := by\n  calc\n    _ = ∫ (x : ℝ) in Ioi 0, (1 / p * x ^ (1 / p - 1)) • ((x ^ (1 / p)) ^ q * exp (-x)) := by\n      rw [← integral_comp_rpow_Ioi _ (one_div_ne_zero (ne_of_gt hp)),\n        abs_eq_self.mpr (le_of_lt (one_div_pos.mpr hp))]\n      refine setIntegral_congr_fun measurableSet_Ioi (fun _ hx => ?_)\n      rw [← rpow_mul (le_of_lt hx) _ p, one_div_mul_cancel (ne_of_gt hp), rpow_one]\n    _ = ∫ (x : ℝ) in Ioi 0, 1 / p * exp (-x) * x ^ (1 / p - 1 + q / p) := by\n      simp_rw [smul_eq_mul, mul_assoc]\n      refine setIntegral_congr_fun measurableSet_Ioi (fun _ hx => ?_)\n      rw [← rpow_mul (le_of_lt hx), div_mul_eq_mul_div, one_mul, rpow_add hx]\n      ring_nf\n    _ = (1 / p) * Gamma ((q + 1) / p) := by\n      rw [Gamma_eq_integral (div_pos (neg_lt_iff_pos_add.mp hq) hp)]\n      simp_rw [show 1 / p - 1 + q / p = (q + 1) / p - 1 by field_simp; ring, ← integral_mul_left,\n        ← mul_assoc]\n\n"}
{"name":"integral_rpow_mul_exp_neg_mul_rpow","module":"Mathlib.MeasureTheory.Integral.Gamma","initialProofState":"p q b : Real\nhp : LT.lt 0 p\nhq : LT.lt (-1) q\nhb : LT.lt 0 b\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun x => HMul.hMul (HPow.hPow x q) (Real.exp (HMul.hMul (Neg.neg b) (HPow.hPow x p)))) (HMul.hMul (HMul.hMul (HPow.hPow b (HDiv.hDiv (Neg.neg (HAdd.hAdd q 1)) p)) (HDiv.hDiv 1 p)) (Real.Gamma (HDiv.hDiv (HAdd.hAdd q 1) p)))","decl":"theorem integral_rpow_mul_exp_neg_mul_rpow {p q b : ℝ} (hp : 0 < p) (hq : - 1 < q) (hb : 0 < b) :\n    ∫ x in Ioi (0 : ℝ), x ^ q * exp (- b * x ^ p) =\n      b ^ (-(q + 1) / p) * (1 / p) * Gamma ((q + 1) / p) := by\n  calc\n    _ = ∫ x in Ioi (0 : ℝ), b ^ (-p⁻¹ * q) * ((b ^ p⁻¹ * x) ^ q * rexp (-(b ^ p⁻¹ * x) ^ p)) := by\n      refine setIntegral_congr_fun measurableSet_Ioi (fun _ hx => ?_)\n      rw [mul_rpow _ (le_of_lt hx), mul_rpow _ (le_of_lt hx), ← rpow_mul, ← rpow_mul,\n        inv_mul_cancel₀, rpow_one, mul_assoc, ← mul_assoc, ← rpow_add, neg_mul p⁻¹, neg_add_cancel,\n        rpow_zero, one_mul, neg_mul]\n      all_goals positivity\n    _ = (b ^ p⁻¹)⁻¹ * ∫ x in Ioi (0 : ℝ), b ^ (-p⁻¹ * q) * (x ^ q * rexp (-x ^ p)) := by\n      rw [integral_comp_mul_left_Ioi (fun x => b ^ (-p⁻¹ * q) * (x ^ q * exp (- x ^ p))) 0,\n        mul_zero, smul_eq_mul]\n      all_goals positivity\n    _ = b ^ (-(q + 1) / p) * (1 / p) * Gamma ((q + 1) / p) := by\n      rw [integral_mul_left, integral_rpow_mul_exp_neg_rpow _ hq, mul_assoc, ← mul_assoc,\n        ← rpow_neg_one, ← rpow_mul, ← rpow_add]\n      · congr; ring\n      all_goals positivity\n\n"}
{"name":"integral_exp_neg_rpow","module":"Mathlib.MeasureTheory.Integral.Gamma","initialProofState":"p : Real\nhp : LT.lt 0 p\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun x => Real.exp (Neg.neg (HPow.hPow x p))) (Real.Gamma (HAdd.hAdd (HDiv.hDiv 1 p) 1))","decl":"theorem integral_exp_neg_rpow {p : ℝ} (hp : 0 < p) :\n    ∫ x in Ioi (0 : ℝ), exp (- x ^ p) = Gamma (1 / p + 1) := by\n  convert (integral_rpow_mul_exp_neg_rpow hp neg_one_lt_zero) using 1\n  · simp_rw [rpow_zero, one_mul]\n  · rw [zero_add, Gamma_add_one (one_div_ne_zero (ne_of_gt hp))]\n\n"}
{"name":"integral_exp_neg_mul_rpow","module":"Mathlib.MeasureTheory.Integral.Gamma","initialProofState":"p b : Real\nhp : LT.lt 0 p\nhb : LT.lt 0 b\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun x => Real.exp (HMul.hMul (Neg.neg b) (HPow.hPow x p))) (HMul.hMul (HPow.hPow b (HDiv.hDiv (-1) p)) (Real.Gamma (HAdd.hAdd (HDiv.hDiv 1 p) 1)))","decl":"theorem integral_exp_neg_mul_rpow {p b : ℝ} (hp : 0 < p) (hb : 0 < b) :\n    ∫ x in Ioi (0 : ℝ), exp (- b * x ^ p) = b ^ (- 1 / p) * Gamma (1 / p + 1) := by\n  convert (integral_rpow_mul_exp_neg_mul_rpow hp neg_one_lt_zero hb) using 1\n  · simp_rw [rpow_zero, one_mul]\n  · rw [zero_add, Gamma_add_one (one_div_ne_zero (ne_of_gt hp)), mul_assoc]\n\n"}
{"name":"Complex.integral_rpow_mul_exp_neg_rpow","module":"Mathlib.MeasureTheory.Integral.Gamma","initialProofState":"p q : Real\nhp : LE.le 1 p\nhq : LT.lt (-2) q\n⊢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => HMul.hMul (HPow.hPow (Norm.norm x) q) (Real.exp (Neg.neg (HPow.hPow (Norm.norm x) p)))) (HMul.hMul (HDiv.hDiv (HMul.hMul 2 Real.pi) p) (Real.Gamma (HDiv.hDiv (HAdd.hAdd q 2) p)))","decl":"theorem Complex.integral_rpow_mul_exp_neg_rpow {p q : ℝ} (hp : 1 ≤ p) (hq : - 2 < q) :\n    ∫ x : ℂ, ‖x‖ ^ q * rexp (- ‖x‖ ^ p) = (2 * π / p) * Real.Gamma ((q + 2) / p) := by\n  calc\n    _ = ∫ x in Ioi (0 : ℝ) ×ˢ Ioo (-π) π, x.1 * (|x.1| ^ q * rexp (-|x.1| ^ p)) := by\n      rw [← Complex.integral_comp_polarCoord_symm, polarCoord_target]\n      simp_rw [Complex.norm_eq_abs, Complex.polarCoord_symm_abs, smul_eq_mul]\n    _ = (∫ x in Ioi (0 : ℝ), x * |x| ^ q * rexp (-|x| ^ p)) * ∫ _ in Ioo (-π) π, 1 := by\n      rw [← setIntegral_prod_mul, volume_eq_prod]\n      simp_rw [mul_one]\n      congr! 2; ring\n    _ = 2 * π * ∫ x in Ioi (0 : ℝ), x * |x| ^ q * rexp (-|x| ^ p) := by\n      simp_rw [integral_const, Measure.restrict_apply MeasurableSet.univ, Set.univ_inter,\n        volume_Ioo, sub_neg_eq_add, ← two_mul, ENNReal.toReal_ofReal (by positivity : 0 ≤ 2 * π),\n        smul_eq_mul, mul_one, mul_comm]\n    _ = 2 * π * ∫ x in Ioi (0 : ℝ), x ^ (q + 1) * rexp (-x ^ p) := by\n      congr 1\n      refine setIntegral_congr_fun measurableSet_Ioi (fun x hx => ?_)\n      rw [mem_Ioi] at hx\n      rw [abs_eq_self.mpr hx.le, rpow_add hx, rpow_one]\n      ring\n    _ = (2 * Real.pi / p) * Real.Gamma ((q + 2) / p) := by\n      rw [_root_.integral_rpow_mul_exp_neg_rpow (by linarith) (by linarith), add_assoc,\n        one_add_one_eq_two]\n      ring\n\n"}
{"name":"Complex.integral_rpow_mul_exp_neg_mul_rpow","module":"Mathlib.MeasureTheory.Integral.Gamma","initialProofState":"p q b : Real\nhp : LE.le 1 p\nhq : LT.lt (-2) q\nhb : LT.lt 0 b\n⊢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => HMul.hMul (HPow.hPow (Norm.norm x) q) (Real.exp (HMul.hMul (Neg.neg b) (HPow.hPow (Norm.norm x) p)))) (HMul.hMul (HMul.hMul (HDiv.hDiv (HMul.hMul 2 Real.pi) p) (HPow.hPow b (HDiv.hDiv (Neg.neg (HAdd.hAdd q 2)) p))) (Real.Gamma (HDiv.hDiv (HAdd.hAdd q 2) p)))","decl":"theorem Complex.integral_rpow_mul_exp_neg_mul_rpow {p q b : ℝ} (hp : 1 ≤ p) (hq : - 2 < q)\n    (hb : 0 < b) :\n    ∫ x : ℂ, ‖x‖ ^ q * rexp (- b * ‖x‖ ^ p) = (2 * π / p) *\n      b ^ (-(q + 2) / p) * Real.Gamma ((q + 2) / p) := by\n  calc\n    _ = ∫ x in Ioi (0 : ℝ) ×ˢ Ioo (-π) π, x.1 * (|x.1| ^ q * rexp (- b * |x.1| ^ p)) := by\n      rw [← Complex.integral_comp_polarCoord_symm, polarCoord_target]\n      simp_rw [Complex.norm_eq_abs, Complex.polarCoord_symm_abs, smul_eq_mul]\n    _ = (∫ x in Ioi (0 : ℝ), x * |x| ^ q * rexp (- b * |x| ^ p)) * ∫ _ in Ioo (-π) π, 1 := by\n      rw [← setIntegral_prod_mul, volume_eq_prod]\n      simp_rw [mul_one]\n      congr! 2; ring\n    _ = 2 * π * ∫ x in Ioi (0 : ℝ), x * |x| ^ q * rexp (- b * |x| ^ p) := by\n      simp_rw [integral_const, Measure.restrict_apply MeasurableSet.univ, Set.univ_inter,\n        volume_Ioo, sub_neg_eq_add, ← two_mul, ENNReal.toReal_ofReal (by positivity : 0 ≤ 2 * π),\n        smul_eq_mul, mul_one, mul_comm]\n    _ = 2 * π * ∫ x in Ioi (0 : ℝ), x ^ (q + 1) * rexp (-b * x ^ p) := by\n      congr 1\n      refine setIntegral_congr_fun measurableSet_Ioi (fun x hx => ?_)\n      rw [mem_Ioi] at hx\n      rw [abs_eq_self.mpr hx.le, rpow_add hx, rpow_one]\n      ring\n    _ = (2 * π / p) * b ^ (-(q + 2) / p) * Real.Gamma ((q + 2) / p) := by\n      rw [_root_.integral_rpow_mul_exp_neg_mul_rpow (by linarith) (by linarith) hb, add_assoc,\n        one_add_one_eq_two]\n      ring\n\n"}
{"name":"Complex.integral_exp_neg_rpow","module":"Mathlib.MeasureTheory.Integral.Gamma","initialProofState":"p : Real\nhp : LE.le 1 p\n⊢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => Real.exp (Neg.neg (HPow.hPow (Norm.norm x) p))) (HMul.hMul Real.pi (Real.Gamma (HAdd.hAdd (HDiv.hDiv 2 p) 1)))","decl":"theorem Complex.integral_exp_neg_rpow {p : ℝ} (hp : 1 ≤ p) :\n    ∫ x : ℂ, rexp (- ‖x‖ ^ p) = π * Real.Gamma (2 / p + 1) := by\n  convert (integral_rpow_mul_exp_neg_rpow hp (by linarith : (-2 : ℝ) < 0)) using 1\n  · simp_rw [norm_eq_abs, rpow_zero, one_mul]\n  · rw [zero_add, Real.Gamma_add_one (div_ne_zero two_ne_zero (by linarith))]\n    ring\n\n"}
{"name":"Complex.integral_exp_neg_mul_rpow","module":"Mathlib.MeasureTheory.Integral.Gamma","initialProofState":"p b : Real\nhp : LE.le 1 p\nhb : LT.lt 0 b\n⊢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => Real.exp (HMul.hMul (Neg.neg b) (HPow.hPow (Norm.norm x) p))) (HMul.hMul (HMul.hMul Real.pi (HPow.hPow b (HDiv.hDiv (-2) p))) (Real.Gamma (HAdd.hAdd (HDiv.hDiv 2 p) 1)))","decl":"theorem Complex.integral_exp_neg_mul_rpow {p b : ℝ} (hp : 1 ≤ p) (hb : 0 < b) :\n    ∫ x : ℂ, rexp (- b * ‖x‖ ^ p) = π * b ^ (-2 / p) * Real.Gamma (2 / p + 1) := by\n  convert (integral_rpow_mul_exp_neg_mul_rpow hp (by linarith : (-2 : ℝ) < 0)) hb using 1\n  · simp_rw [norm_eq_abs, rpow_zero, one_mul]\n  · rw [zero_add, Real.Gamma_add_one (div_ne_zero two_ne_zero (by linarith))]\n    ring\n\n"}
