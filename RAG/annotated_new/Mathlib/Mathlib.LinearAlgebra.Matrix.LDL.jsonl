{"name":"LDL.lowerInv_eq_gramSchmidtBasis","module":"Mathlib.LinearAlgebra.Matrix.LDL","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : RCLike ğ•œ\nn : Type u_2\ninstâœÂ³ : LinearOrder n\ninstâœÂ² : WellFoundedLT n\ninstâœÂ¹ : LocallyFiniteOrderBot n\nS : Matrix n n ğ•œ\ninstâœ : Fintype n\nhS : S.PosDef\nâŠ¢ Eq (LDL.lowerInv hS) ((Pi.basisFun ğ•œ n).toMatrix â‡‘(gramSchmidtBasis (Pi.basisFun ğ•œ n))).transpose","decl":"theorem LDL.lowerInv_eq_gramSchmidtBasis :\n    LDL.lowerInv hS =\n      ((Pi.basisFun ğ•œ n).toMatrix\n          (@gramSchmidtBasis ğ•œ (n â†’ ğ•œ) _ (_ :) (InnerProductSpace.ofMatrix hS.transpose) n _ _ _\n            (Pi.basisFun ğ•œ n)))áµ€ := by\n  letI := NormedAddCommGroup.ofMatrix hS.transpose\n  letI := InnerProductSpace.ofMatrix hS.transpose\n  ext i j\n  rw [LDL.lowerInv, Basis.coePiBasisFun.toMatrix_eq_transpose, coe_gramSchmidtBasis]\n  rfl\n\n"}
{"name":"LDL.lowerInv_orthogonal","module":"Mathlib.LinearAlgebra.Matrix.LDL","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : RCLike ğ•œ\nn : Type u_2\ninstâœÂ³ : LinearOrder n\ninstâœÂ² : WellFoundedLT n\ninstâœÂ¹ : LocallyFiniteOrderBot n\nS : Matrix n n ğ•œ\ninstâœ : Fintype n\nhS : S.PosDef\ni j : n\nhâ‚€ : Ne i j\nâŠ¢ Eq (Inner.inner ((WithLp.equiv 2 (n â†’ ğ•œ)).symm (LDL.lowerInv hS i)) ((WithLp.equiv 2 (n â†’ ğ•œ)).symm (S.transpose.mulVec (LDL.lowerInv hS j)))) 0","decl":"theorem LDL.lowerInv_orthogonal {i j : n} (hâ‚€ : i â‰  j) :\n    âŸªLDL.lowerInv hS i, Sáµ€ *áµ¥ LDL.lowerInv hS jâŸ«â‚‘ = 0 :=\n  @gramSchmidt_orthogonal ğ•œ _ _ (_ :) (InnerProductSpace.ofMatrix hS.transpose) _ _ _ _ _ _ _ hâ‚€\n\n"}
{"name":"LDL.lowerInv_triangular","module":"Mathlib.LinearAlgebra.Matrix.LDL","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : RCLike ğ•œ\nn : Type u_2\ninstâœÂ³ : LinearOrder n\ninstâœÂ² : WellFoundedLT n\ninstâœÂ¹ : LocallyFiniteOrderBot n\nS : Matrix n n ğ•œ\ninstâœ : Fintype n\nhS : S.PosDef\ni j : n\nhij : LT.lt i j\nâŠ¢ Eq (LDL.lowerInv hS i j) 0","decl":"theorem LDL.lowerInv_triangular {i j : n} (hij : i < j) : LDL.lowerInv hS i j = 0 := by\n  rw [â†\n    @gramSchmidt_triangular ğ•œ (n â†’ ğ•œ) _ (_ :) (InnerProductSpace.ofMatrix hS.transpose) n _ _ _\n      i j hij (Pi.basisFun ğ•œ n),\n    Pi.basisFun_repr, LDL.lowerInv]\n\n"}
{"name":"LDL.diag_eq_lowerInv_conj","module":"Mathlib.LinearAlgebra.Matrix.LDL","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : RCLike ğ•œ\nn : Type u_2\ninstâœÂ³ : LinearOrder n\ninstâœÂ² : WellFoundedLT n\ninstâœÂ¹ : LocallyFiniteOrderBot n\nS : Matrix n n ğ•œ\ninstâœ : Fintype n\nhS : S.PosDef\nâŠ¢ Eq (LDL.diag hS) (HMul.hMul (HMul.hMul (LDL.lowerInv hS) S) (LDL.lowerInv hS).conjTranspose)","decl":"/-- Inverse statement of **LDL decomposition**: we can conjugate a positive definite matrix\nby some lower triangular matrix and get a diagonal matrix. -/\ntheorem LDL.diag_eq_lowerInv_conj : LDL.diag hS = LDL.lowerInv hS * S * (LDL.lowerInv hS)á´´ := by\n  ext i j\n  by_cases hij : i = j\n  Â· simp only [diag, diagEntries, EuclideanSpace.inner_piLp_equiv_symm, star_star, hij,\n    diagonal_apply_eq, Matrix.mul_assoc]\n    rfl\n  Â· simp only [LDL.diag, hij, diagonal_apply_ne, Ne, not_false_iff, mul_mul_apply]\n    rw [conjTranspose, transpose_map, transpose_transpose, dotProduct_mulVec,\n      (LDL.lowerInv_orthogonal hS fun h : j = i => hij h.symm).symm, â† inner_conj_symm,\n      mulVec_transpose, EuclideanSpace.inner_piLp_equiv_symm, â† RCLike.star_def, â†\n      star_dotProduct_star, dotProduct_comm, star_star]\n    rfl\n\n"}
{"name":"LDL.lower_conj_diag","module":"Mathlib.LinearAlgebra.Matrix.LDL","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : RCLike ğ•œ\nn : Type u_2\ninstâœÂ³ : LinearOrder n\ninstâœÂ² : WellFoundedLT n\ninstâœÂ¹ : LocallyFiniteOrderBot n\nS : Matrix n n ğ•œ\ninstâœ : Fintype n\nhS : S.PosDef\nâŠ¢ Eq (HMul.hMul (HMul.hMul (LDL.lower hS) (LDL.diag hS)) (LDL.lower hS).conjTranspose) S","decl":"/-- **LDL decomposition**: any positive definite matrix `S` can be\ndecomposed as `S = LDLá´´` where `L` is a lower-triangular matrix and `D` is a diagonal matrix. -/\ntheorem LDL.lower_conj_diag : LDL.lower hS * LDL.diag hS * (LDL.lower hS)á´´ = S := by\n  rw [LDL.lower, conjTranspose_nonsing_inv, Matrix.mul_assoc,\n    Matrix.inv_mul_eq_iff_eq_mul_of_invertible (LDL.lowerInv hS),\n    Matrix.mul_inv_eq_iff_eq_mul_of_invertible]\n  exact LDL.diag_eq_lowerInv_conj hS\n\n"}
