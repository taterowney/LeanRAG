{"name":"CategoryTheory.Limits.pointwiseProduct_map","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesProduct","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nα : Type w\nI : α → Type u₁\ninst✝¹ : (i : α) → CategoryTheory.Category.{v₁, u₁} (I i)\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete α) C\nF : (i : α) → CategoryTheory.Functor (I i) C\nX✝ Y✝ : (i : α) → I i\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Limits.pointwiseProduct F).map f) (CategoryTheory.Limits.Pi.map fun s => (F s).map (f s))","decl":"/-- Given a family of functors `I i ⥤ C` for `i : α`, we obtain a functor `(∀ i, I i) ⥤ C` which\nmaps `k : ∀ i, I i` to `∏ᶜ fun (s : α) => (F s).obj (k s)`. -/\n@[simps]\nnoncomputable def pointwiseProduct : (∀ i, I i) ⥤ C where\n  obj k := ∏ᶜ fun (s : α) => (F s).obj (k s)\n  map f := Pi.map (fun s => (F s).map (f s))\n\n"}
{"name":"CategoryTheory.Limits.pointwiseProduct_obj","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesProduct","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nα : Type w\nI : α → Type u₁\ninst✝¹ : (i : α) → CategoryTheory.Category.{v₁, u₁} (I i)\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete α) C\nF : (i : α) → CategoryTheory.Functor (I i) C\nk : (i : α) → I i\n⊢ Eq ((CategoryTheory.Limits.pointwiseProduct F).obj k) (CategoryTheory.Limits.piObj fun s => (F s).obj (k s))","decl":"/-- Given a family of functors `I i ⥤ C` for `i : α`, we obtain a functor `(∀ i, I i) ⥤ C` which\nmaps `k : ∀ i, I i` to `∏ᶜ fun (s : α) => (F s).obj (k s)`. -/\n@[simps]\nnoncomputable def pointwiseProduct : (∀ i, I i) ⥤ C where\n  obj k := ∏ᶜ fun (s : α) => (F s).obj (k s)\n  map f := Pi.map (fun s => (F s).map (f s))\n\n"}
{"name":"CategoryTheory.Limits.coconePointwiseProduct_ι_app","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesProduct","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nα : Type w\nI : α → Type u₁\ninst✝² : (i : α) → CategoryTheory.Category.{v₁, u₁} (I i)\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete α) C\nF : (i : α) → CategoryTheory.Functor (I i) C\ninst✝ : ∀ (i : α), CategoryTheory.Limits.HasColimitsOfShape (I i) C\nk : (i : α) → I i\n⊢ Eq ((CategoryTheory.Limits.coconePointwiseProduct F).ι.app k) (CategoryTheory.Limits.Pi.map fun s => CategoryTheory.Limits.colimit.ι (F s) (k s))","decl":"/-- The inclusions `(F s).obj (k s) ⟶ colimit (F s)` induce a cocone on `pointwiseProduct F` with\ncone point `∏ᶜ (fun s : α) => colimit (F s)`. -/\n@[simps]\nnoncomputable def coconePointwiseProduct : Cocone (pointwiseProduct F) where\n  pt := ∏ᶜ fun (s : α) => colimit (F s)\n  ι := { app := fun k => Pi.map fun s => colimit.ι _ _ }\n\n"}
{"name":"CategoryTheory.Limits.coconePointwiseProduct_pt","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesProduct","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nα : Type w\nI : α → Type u₁\ninst✝² : (i : α) → CategoryTheory.Category.{v₁, u₁} (I i)\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete α) C\nF : (i : α) → CategoryTheory.Functor (I i) C\ninst✝ : ∀ (i : α), CategoryTheory.Limits.HasColimitsOfShape (I i) C\n⊢ Eq (CategoryTheory.Limits.coconePointwiseProduct F).pt (CategoryTheory.Limits.piObj fun s => CategoryTheory.Limits.colimit (F s))","decl":"/-- The inclusions `(F s).obj (k s) ⟶ colimit (F s)` induce a cocone on `pointwiseProduct F` with\ncone point `∏ᶜ (fun s : α) => colimit (F s)`. -/\n@[simps]\nnoncomputable def coconePointwiseProduct : Cocone (pointwiseProduct F) where\n  pt := ∏ᶜ fun (s : α) => colimit (F s)\n  ι := { app := fun k => Pi.map fun s => colimit.ι _ _ }\n\n"}
{"name":"CategoryTheory.Limits.ι_colimitPointwiseProductToProductColimit_π_assoc","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesProduct","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nα : Type w\nI : α → Type u₁\ninst✝³ : (i : α) → CategoryTheory.Category.{v₁, u₁} (I i)\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete α) C\nF : (i : α) → CategoryTheory.Functor (I i) C\ninst✝¹ : ∀ (i : α), CategoryTheory.Limits.HasColimitsOfShape (I i) C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape ((i : α) → I i) C\nk : (i : α) → I i\ns : α\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit (F s)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (CategoryTheory.Limits.pointwiseProduct F) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitPointwiseProductToProductColimit F) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π (fun s => CategoryTheory.Limits.colimit (F s)) s) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π (fun s => (F s).obj (k s)) s) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F s) (k s)) h))","decl":"@[reassoc (attr := simp)]\ntheorem ι_colimitPointwiseProductToProductColimit_π (k : ∀ i, I i) (s : α) :\n    colimit.ι (pointwiseProduct F) k ≫ colimitPointwiseProductToProductColimit F ≫ Pi.π _ s =\n      Pi.π _ s ≫ colimit.ι (F s) (k s) := by\n  simp [colimitPointwiseProductToProductColimit]\n\n"}
{"name":"CategoryTheory.Limits.ι_colimitPointwiseProductToProductColimit_π","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesProduct","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nα : Type w\nI : α → Type u₁\ninst✝³ : (i : α) → CategoryTheory.Category.{v₁, u₁} (I i)\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete α) C\nF : (i : α) → CategoryTheory.Functor (I i) C\ninst✝¹ : ∀ (i : α), CategoryTheory.Limits.HasColimitsOfShape (I i) C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape ((i : α) → I i) C\nk : (i : α) → I i\ns : α\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (CategoryTheory.Limits.pointwiseProduct F) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitPointwiseProductToProductColimit F) (CategoryTheory.Limits.Pi.π (fun s => CategoryTheory.Limits.colimit (F s)) s))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π (fun s => (F s).obj (k s)) s) (CategoryTheory.Limits.colimit.ι (F s) (k s)))","decl":"@[reassoc (attr := simp)]\ntheorem ι_colimitPointwiseProductToProductColimit_π (k : ∀ i, I i) (s : α) :\n    colimit.ι (pointwiseProduct F) k ≫ colimitPointwiseProductToProductColimit F ≫ Pi.π _ s =\n      Pi.π _ s ≫ colimit.ι (F s) (k s) := by\n  simp [colimitPointwiseProductToProductColimit]\n\n"}
{"name":"CategoryTheory.Limits.pointwiseProductCompEvaluation_hom_app","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesProduct","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} D\nα : Type w\nI : α → Type u₂\ninst✝¹ : (i : α) → CategoryTheory.Category.{w, u₂} (I i)\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete α) C\nF : (i : α) → CategoryTheory.Functor (I i) (CategoryTheory.Functor D C)\nd : D\nX : (i : α) → I i\n⊢ Eq ((CategoryTheory.Limits.pointwiseProductCompEvaluation F d).hom.app X) (CategoryTheory.Limits.piObjIso (fun s => (F s).obj (X s)) d).hom","decl":"/-- Evaluating the pointwise product `k ↦ ∏ᶜ fun (s : α) => (F s).obj (k s)` at `d` is the same as\ntaking the pointwise product `k ↦ ∏ᶜ fun (s : α) => ((F s).obj (k s)).obj d`. -/\n@[simps!]\nnoncomputable def pointwiseProductCompEvaluation (d : D) :\n    pointwiseProduct F ⋙ (evaluation D C).obj d ≅\n      pointwiseProduct (fun s => F s ⋙ (evaluation _ _).obj d) :=\n  NatIso.ofComponents (fun k => piObjIso _ _)\n    (fun f => Pi.hom_ext _ _ (by simp [← NatTrans.comp_app]))\n\n"}
{"name":"CategoryTheory.Limits.pointwiseProductCompEvaluation_inv_app","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesProduct","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} D\nα : Type w\nI : α → Type u₂\ninst✝¹ : (i : α) → CategoryTheory.Category.{w, u₂} (I i)\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete α) C\nF : (i : α) → CategoryTheory.Functor (I i) (CategoryTheory.Functor D C)\nd : D\nX : (i : α) → I i\n⊢ Eq ((CategoryTheory.Limits.pointwiseProductCompEvaluation F d).inv.app X) (CategoryTheory.Limits.piObjIso (fun s => (F s).obj (X s)) d).inv","decl":"/-- Evaluating the pointwise product `k ↦ ∏ᶜ fun (s : α) => (F s).obj (k s)` at `d` is the same as\ntaking the pointwise product `k ↦ ∏ᶜ fun (s : α) => ((F s).obj (k s)).obj d`. -/\n@[simps!]\nnoncomputable def pointwiseProductCompEvaluation (d : D) :\n    pointwiseProduct F ⋙ (evaluation D C).obj d ≅\n      pointwiseProduct (fun s => F s ⋙ (evaluation _ _).obj d) :=\n  NatIso.ofComponents (fun k => piObjIso _ _)\n    (fun f => Pi.hom_ext _ _ (by simp [← NatTrans.comp_app]))\n\n"}
{"name":"CategoryTheory.Limits.colimitPointwiseProductToProductColimit_app","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesProduct","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} D\nα : Type w\nI : α → Type u₂\ninst✝³ : (i : α) → CategoryTheory.Category.{w, u₂} (I i)\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete α) C\nF : (i : α) → CategoryTheory.Functor (I i) (CategoryTheory.Functor D C)\ninst✝¹ : ∀ (i : α), CategoryTheory.Limits.HasColimitsOfShape (I i) C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape ((i : α) → I i) C\nd : D\n⊢ Eq ((CategoryTheory.Limits.colimitPointwiseProductToProductColimit F).app d) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation (CategoryTheory.Limits.pointwiseProduct F) d).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasColimit.isoOfNatIso (CategoryTheory.Limits.pointwiseProductCompEvaluation F d)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitPointwiseProductToProductColimit fun s => (F s).comp ((CategoryTheory.evaluation D C).obj d)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.mapIso fun x => (CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation (F x) d).symm).hom (CategoryTheory.Limits.piObjIso (fun x => CategoryTheory.Limits.colimit (F x)) d).inv))))","decl":"theorem colimitPointwiseProductToProductColimit_app (d : D) :\n    (colimitPointwiseProductToProductColimit F).app d =\n      (colimitObjIsoColimitCompEvaluation _ _).hom ≫\n        (HasColimit.isoOfNatIso (pointwiseProductCompEvaluation F d)).hom ≫\n          colimitPointwiseProductToProductColimit _ ≫\n            (Pi.mapIso fun _ => (colimitObjIsoColimitCompEvaluation _ _).symm).hom ≫\n              (piObjIso _ _).inv := by\n  rw [← Iso.inv_comp_eq]\n  simp only [← Category.assoc]\n  rw [Iso.eq_comp_inv]\n  refine Pi.hom_ext _ _ (fun s => colimit.hom_ext (fun k => ?_))\n  simp [← NatTrans.comp_app]\n\n"}
{"name":"CategoryTheory.Limits.IsIPC.isIso","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesProduct","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasProducts C\ninst✝² : CategoryTheory.Limits.HasFilteredColimitsOfSize.{w, w, v, u} C\nself : CategoryTheory.Limits.IsIPC C\nα : Type w\nI : α → Type w\ninst✝¹ : (i : α) → CategoryTheory.SmallCategory (I i)\ninst✝ : ∀ (i : α), CategoryTheory.IsFiltered (I i)\nF : (i : α) → CategoryTheory.Functor (I i) C\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.colimitPointwiseProductToProductColimit F)","decl":"/-- A category `C` has the `w`-IPC property if the natural morphism\n`colim_k (∏ᶜ s ↦ (F s).obj (k s)) ⟶ ∏ᶜ s ↦ colim_k (F s).obj (k s)` is an isomorphism for any\nfamily of functors `F i : I i ⥤ C` with `I i` `w`-small and filtered for all `i`. -/\nclass IsIPC [HasProducts.{w} C] [HasFilteredColimitsOfSize.{w} C] : Prop where\n  /-- `colimitPointwiseProductToProductColimit F` is always an isomorphism. -/\n  isIso : ∀ (α : Type w) (I : α → Type w) [∀ i, SmallCategory (I i)] [∀ i, IsFiltered (I i)]\n    (F : ∀ i, I i ⥤ C), IsIso (colimitPointwiseProductToProductColimit F)\n\n"}
{"name":"CategoryTheory.Limits.Types.isIso_colimitPointwiseProductToProductColimit","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesProduct","initialProofState":"α : Type u\nI : α → Type u\ninst✝¹ : (i : α) → CategoryTheory.SmallCategory (I i)\ninst✝ : ∀ (i : α), CategoryTheory.IsFiltered (I i)\nF : (i : α) → CategoryTheory.Functor (I i) (Type u)\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.colimitPointwiseProductToProductColimit F)","decl":"theorem Types.isIso_colimitPointwiseProductToProductColimit (F : ∀ i, I i ⥤ Type u) :\n    IsIso (colimitPointwiseProductToProductColimit F) := by\n  -- We follow the proof in [Kashiwara2006], Prop. 3.1.11(ii)\n  refine (isIso_iff_bijective _).2 ⟨fun y y' hy => ?_, fun x => ?_⟩\n  · obtain ⟨ky, yk₀, hyk₀⟩ := Types.jointly_surjective' y\n    obtain ⟨ky', yk₀', hyk₀'⟩ := Types.jointly_surjective' y'\n    let k := IsFiltered.max ky ky'\n    let yk : (pointwiseProduct F).obj k :=\n      (pointwiseProduct F).map (IsFiltered.leftToMax ky ky') yk₀\n    let yk' : (pointwiseProduct F).obj k :=\n      (pointwiseProduct F).map (IsFiltered.rightToMax ky ky') yk₀'\n    obtain rfl : y = colimit.ι (pointwiseProduct F) k yk := by\n      simp only [k, yk, Types.Colimit.w_apply', hyk₀]\n    obtain rfl : y' = colimit.ι (pointwiseProduct F) k yk' := by\n      simp only [k, yk', Types.Colimit.w_apply', hyk₀']\n    dsimp only [pointwiseProduct_obj] at yk yk'\n    have hch : ∀ (s : α), ∃ (i' : I s) (hi' : k s ⟶ i'),\n        (F s).map hi' (Pi.π (fun s => (F s).obj (k s)) s yk) =\n          (F s).map hi' (Pi.π (fun s => (F s).obj (k s)) s yk') := by\n      intro s\n      have hy₁ := congrFun (ι_colimitPointwiseProductToProductColimit_π F k s) yk\n      have hy₂ := congrFun (ι_colimitPointwiseProductToProductColimit_π F k s) yk'\n      dsimp only [pointwiseProduct_obj, types_comp_apply] at hy₁ hy₂\n      rw [← hy, hy₁, Types.FilteredColimit.colimit_eq_iff] at hy₂\n      obtain ⟨i₀, f₀, g₀, h₀⟩ := hy₂\n      refine ⟨IsFiltered.coeq f₀ g₀, f₀ ≫ IsFiltered.coeqHom f₀ g₀, ?_⟩\n      conv_rhs => rw [IsFiltered.coeq_condition]\n      simp [h₀]\n    choose k' f hk' using hch\n    apply Types.colimit_sound' f f\n    exact Types.limit_ext' _ _ _ (fun ⟨s⟩ => by simpa using hk' _)\n  · have hch : ∀ (s : α), ∃ (i : I s) (xi : (F s).obj i), colimit.ι (F s) i xi =\n        Pi.π (fun s => colimit (F s)) s x := fun s => Types.jointly_surjective' _\n    choose k p hk using hch\n    refine ⟨colimit.ι (pointwiseProduct F) k ((Types.productIso _).inv p), ?_⟩\n    refine Types.limit_ext' _ _ _ (fun ⟨s⟩ => ?_)\n    have := congrFun (ι_colimitPointwiseProductToProductColimit_π F k s)\n      ((Types.productIso _).inv p)\n    exact this.trans (by simpa using hk _)\n\n"}
{"name":"CategoryTheory.Limits.instIsIPCType","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesProduct","initialProofState":"⊢ CategoryTheory.Limits.IsIPC (Type u)","decl":"instance : IsIPC.{u} (Type u) where\n  isIso _ _ := Types.isIso_colimitPointwiseProductToProductColimit\n\n"}
{"name":"CategoryTheory.Limits.instIsIPCFunctor","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesProduct","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasProducts C\ninst✝² : CategoryTheory.Limits.HasFilteredColimitsOfSize.{w, w, v, u} C\ninst✝¹ : CategoryTheory.Limits.IsIPC C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\n⊢ CategoryTheory.Limits.IsIPC (CategoryTheory.Functor D C)","decl":"instance [HasProducts.{w} C] [HasFilteredColimitsOfSize.{w, w} C] [IsIPC.{w} C] {D : Type u₁}\n    [Category.{v₁} D] : IsIPC.{w} (D ⥤ C) := by\n  refine ⟨fun β I _ _ F => ?_⟩\n  suffices ∀ d, IsIso ((colimitPointwiseProductToProductColimit F).app d) from\n    NatIso.isIso_of_isIso_app _\n  exact fun d => colimitPointwiseProductToProductColimit_app F d ▸ inferInstance\n\n"}
