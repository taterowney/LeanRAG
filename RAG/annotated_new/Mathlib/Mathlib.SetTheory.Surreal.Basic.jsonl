{"name":"SetTheory.PGame.numeric_def","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x : SetTheory.PGame\n⊢ Iff x.Numeric (And (∀ (i : x.LeftMoves) (j : x.RightMoves), LT.lt (x.moveLeft i) (x.moveRight j)) (And (∀ (i : x.LeftMoves), (x.moveLeft i).Numeric) (∀ (j : x.RightMoves), (x.moveRight j).Numeric)))","decl":"theorem numeric_def {x : PGame} :\n    Numeric x ↔\n      (∀ i j, x.moveLeft i < x.moveRight j) ∧\n        (∀ i, Numeric (x.moveLeft i)) ∧ ∀ j, Numeric (x.moveRight j) := by\n  cases x; rfl\n\n"}
{"name":"SetTheory.PGame.Numeric.mk","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x : SetTheory.PGame\nh₁ : ∀ (i : x.LeftMoves) (j : x.RightMoves), LT.lt (x.moveLeft i) (x.moveRight j)\nh₂ : ∀ (i : x.LeftMoves), (x.moveLeft i).Numeric\nh₃ : ∀ (j : x.RightMoves), (x.moveRight j).Numeric\n⊢ x.Numeric","decl":"theorem mk {x : PGame} (h₁ : ∀ i j, x.moveLeft i < x.moveRight j) (h₂ : ∀ i, Numeric (x.moveLeft i))\n    (h₃ : ∀ j, Numeric (x.moveRight j)) : Numeric x :=\n  numeric_def.2 ⟨h₁, h₂, h₃⟩\n\n"}
{"name":"SetTheory.PGame.Numeric.left_lt_right","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x : SetTheory.PGame\no : x.Numeric\ni : x.LeftMoves\nj : x.RightMoves\n⊢ LT.lt (x.moveLeft i) (x.moveRight j)","decl":"theorem left_lt_right {x : PGame} (o : Numeric x) (i : x.LeftMoves) (j : x.RightMoves) :\n    x.moveLeft i < x.moveRight j := by cases x; exact o.1 i j\n\n"}
{"name":"SetTheory.PGame.Numeric.moveLeft","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x : SetTheory.PGame\no : x.Numeric\ni : x.LeftMoves\n⊢ (x.moveLeft i).Numeric","decl":"theorem moveLeft {x : PGame} (o : Numeric x) (i : x.LeftMoves) : Numeric (x.moveLeft i) := by\n  cases x; exact o.2.1 i\n\n"}
{"name":"SetTheory.PGame.Numeric.moveRight","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x : SetTheory.PGame\no : x.Numeric\nj : x.RightMoves\n⊢ (x.moveRight j).Numeric","decl":"theorem moveRight {x : PGame} (o : Numeric x) (j : x.RightMoves) : Numeric (x.moveRight j) := by\n  cases x; exact o.2.2 j\n\n"}
{"name":"SetTheory.PGame.Numeric.isOption","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x' x : SetTheory.PGame\nh : x'.IsOption x\nhx : x.Numeric\n⊢ x'.Numeric","decl":"lemma isOption {x' x} (h : IsOption x' x) (hx : Numeric x) : Numeric x' := by\n  cases h\n  · apply hx.moveLeft\n  · apply hx.moveRight\n\n"}
{"name":"SetTheory.PGame.numeric_rec","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"C : SetTheory.PGame → Prop\nH : ∀ (l r : Type u_1) (L : l → SetTheory.PGame) (R : r → SetTheory.PGame), (∀ (i : l) (j : r), LT.lt (L i) (R j)) → (∀ (i : l), (L i).Numeric) → (∀ (i : r), (R i).Numeric) → (∀ (i : l), C (L i)) → (∀ (i : r), C (R i)) → C (SetTheory.PGame.mk l r L R)\nx : SetTheory.PGame\na✝ : x.Numeric\n⊢ C x","decl":"@[elab_as_elim]\ntheorem numeric_rec {C : PGame → Prop}\n    (H : ∀ (l r) (L : l → PGame) (R : r → PGame), (∀ i j, L i < R j) →\n      (∀ i, Numeric (L i)) → (∀ i, Numeric (R i)) → (∀ i, C (L i)) → (∀ i, C (R i)) →\n      C ⟨l, r, L, R⟩) :\n    ∀ x, Numeric x → C x\n  | ⟨_, _, _, _⟩, ⟨h, hl, hr⟩ =>\n    H _ _ _ _ h hl hr (fun i => numeric_rec H _ (hl i)) fun i => numeric_rec H _ (hr i)\n\n"}
{"name":"SetTheory.PGame.Relabelling.numeric_imp","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x y : SetTheory.PGame\nr : x.Relabelling y\nox : x.Numeric\n⊢ y.Numeric","decl":"theorem Relabelling.numeric_imp {x y : PGame} (r : x ≡r y) (ox : Numeric x) : Numeric y := by\n  induction' x using PGame.moveRecOn with x IHl IHr generalizing y\n  apply Numeric.mk (fun i j => ?_) (fun i => ?_) fun j => ?_\n  · rw [← lt_congr (r.moveLeftSymm i).equiv (r.moveRightSymm j).equiv]\n    apply ox.left_lt_right\n  · exact IHl _ (r.moveLeftSymm i) (ox.moveLeft _)\n  · exact IHr _ (r.moveRightSymm j) (ox.moveRight _)\n\n"}
{"name":"SetTheory.PGame.Relabelling.numeric_congr","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x y : SetTheory.PGame\nr : x.Relabelling y\n⊢ Iff x.Numeric y.Numeric","decl":"/-- Relabellings preserve being numeric. -/\ntheorem Relabelling.numeric_congr {x y : PGame} (r : x ≡r y) : Numeric x ↔ Numeric y :=\n  ⟨r.numeric_imp, r.symm.numeric_imp⟩\n\n"}
{"name":"SetTheory.PGame.lf_asymm","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x y : SetTheory.PGame\nox : x.Numeric\noy : y.Numeric\na✝ : x.LF y\n⊢ Not (y.LF x)","decl":"theorem lf_asymm {x y : PGame} (ox : Numeric x) (oy : Numeric y) : x ⧏ y → ¬y ⧏ x := by\n  refine numeric_rec (C := fun x => ∀ z (_oz : Numeric z), x ⧏ z → ¬z ⧏ x)\n    (fun xl xr xL xR hx _oxl _oxr IHxl IHxr => ?_) x ox y oy\n  refine numeric_rec fun yl yr yL yR hy oyl oyr _IHyl _IHyr => ?_\n  rw [mk_lf_mk, mk_lf_mk]; rintro (⟨i, h₁⟩ | ⟨j, h₁⟩) (⟨i, h₂⟩ | ⟨j, h₂⟩)\n  · exact IHxl _ _ (oyl _) (h₁.moveLeft_lf _) (h₂.moveLeft_lf _)\n  · exact (le_trans h₂ h₁).not_gf (lf_of_lt (hy _ _))\n  · exact (le_trans h₁ h₂).not_gf (lf_of_lt (hx _ _))\n  · exact IHxr _ _ (oyr _) (h₁.lf_moveRight _) (h₂.lf_moveRight _)\n\n"}
{"name":"SetTheory.PGame.le_of_lf","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x y : SetTheory.PGame\nh : x.LF y\nox : x.Numeric\noy : y.Numeric\n⊢ LE.le x y","decl":"theorem le_of_lf {x y : PGame} (h : x ⧏ y) (ox : Numeric x) (oy : Numeric y) : x ≤ y :=\n  not_lf.1 (lf_asymm ox oy h)\n\n"}
{"name":"SetTheory.PGame.LF.le","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x y : SetTheory.PGame\nh : x.LF y\nox : x.Numeric\noy : y.Numeric\n⊢ LE.le x y","decl":"alias LF.le := le_of_lf\n\n"}
{"name":"SetTheory.PGame.lt_of_lf","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x y : SetTheory.PGame\nh : x.LF y\nox : x.Numeric\noy : y.Numeric\n⊢ LT.lt x y","decl":"theorem lt_of_lf {x y : PGame} (h : x ⧏ y) (ox : Numeric x) (oy : Numeric y) : x < y :=\n  (lt_or_fuzzy_of_lf h).resolve_right (not_fuzzy_of_le (h.le ox oy))\n\n"}
{"name":"SetTheory.PGame.LF.lt","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x y : SetTheory.PGame\nh : x.LF y\nox : x.Numeric\noy : y.Numeric\n⊢ LT.lt x y","decl":"alias LF.lt := lt_of_lf\n\n"}
{"name":"SetTheory.PGame.lf_iff_lt","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x y : SetTheory.PGame\nox : x.Numeric\noy : y.Numeric\n⊢ Iff (x.LF y) (LT.lt x y)","decl":"theorem lf_iff_lt {x y : PGame} (ox : Numeric x) (oy : Numeric y) : x ⧏ y ↔ x < y :=\n  ⟨fun h => h.lt ox oy, lf_of_lt⟩\n\n"}
{"name":"SetTheory.PGame.le_iff_forall_lt","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x y : SetTheory.PGame\nox : x.Numeric\noy : y.Numeric\n⊢ Iff (LE.le x y) (And (∀ (i : x.LeftMoves), LT.lt (x.moveLeft i) y) (∀ (j : y.RightMoves), LT.lt x (y.moveRight j)))","decl":"/-- Definition of `x ≤ y` on numeric pre-games, in terms of `<` -/\ntheorem le_iff_forall_lt {x y : PGame} (ox : x.Numeric) (oy : y.Numeric) :\n    x ≤ y ↔ (∀ i, x.moveLeft i < y) ∧ ∀ j, x < y.moveRight j := by\n  refine le_iff_forall_lf.trans (and_congr ?_ ?_) <;>\n      refine forall_congr' fun i => lf_iff_lt ?_ ?_ <;>\n    apply_rules [Numeric.moveLeft, Numeric.moveRight]\n\n"}
{"name":"SetTheory.PGame.lt_iff_exists_le","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x y : SetTheory.PGame\nox : x.Numeric\noy : y.Numeric\n⊢ Iff (LT.lt x y) (Or (Exists fun i => LE.le x (y.moveLeft i)) (Exists fun j => LE.le (x.moveRight j) y))","decl":"/-- Definition of `x < y` on numeric pre-games, in terms of `≤` -/\ntheorem lt_iff_exists_le {x y : PGame} (ox : x.Numeric) (oy : y.Numeric) :\n    x < y ↔ (∃ i, x ≤ y.moveLeft i) ∨ ∃ j, x.moveRight j ≤ y := by\n  rw [← lf_iff_lt ox oy, lf_iff_exists_le]\n\n"}
{"name":"SetTheory.PGame.lt_of_exists_le","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x y : SetTheory.PGame\nox : x.Numeric\noy : y.Numeric\na✝ : Or (Exists fun i => LE.le x (y.moveLeft i)) (Exists fun j => LE.le (x.moveRight j) y)\n⊢ LT.lt x y","decl":"theorem lt_of_exists_le {x y : PGame} (ox : x.Numeric) (oy : y.Numeric) :\n    ((∃ i, x ≤ y.moveLeft i) ∨ ∃ j, x.moveRight j ≤ y) → x < y :=\n  (lt_iff_exists_le ox oy).2\n\n"}
{"name":"SetTheory.PGame.lt_def","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x y : SetTheory.PGame\nox : x.Numeric\noy : y.Numeric\n⊢ Iff (LT.lt x y) (Or (Exists fun i => And (∀ (i' : x.LeftMoves), LT.lt (x.moveLeft i') (y.moveLeft i)) (∀ (j : (y.moveLeft i).RightMoves), LT.lt x ((y.moveLeft i).moveRight j))) (Exists fun j => And (∀ (i : (x.moveRight j).LeftMoves), LT.lt ((x.moveRight j).moveLeft i) y) (∀ (j' : y.RightMoves), LT.lt (x.moveRight j) (y.moveRight j'))))","decl":"/-- The definition of `x < y` on numeric pre-games, in terms of `<` two moves later. -/\ntheorem lt_def {x y : PGame} (ox : x.Numeric) (oy : y.Numeric) :\n    x < y ↔\n      (∃ i, (∀ i', x.moveLeft i' < y.moveLeft i) ∧ ∀ j, x < (y.moveLeft i).moveRight j) ∨\n        ∃ j, (∀ i, (x.moveRight j).moveLeft i < y) ∧ ∀ j', x.moveRight j < y.moveRight j' := by\n  rw [← lf_iff_lt ox oy, lf_def]\n  refine or_congr ?_ ?_ <;> refine exists_congr fun x_1 => ?_ <;> refine and_congr ?_ ?_ <;>\n      refine forall_congr' fun i => lf_iff_lt ?_ ?_ <;>\n    apply_rules [Numeric.moveLeft, Numeric.moveRight]\n\n"}
{"name":"SetTheory.PGame.not_fuzzy","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x y : SetTheory.PGame\nox : x.Numeric\noy : y.Numeric\n⊢ Not (x.Fuzzy y)","decl":"theorem not_fuzzy {x y : PGame} (ox : Numeric x) (oy : Numeric y) : ¬Fuzzy x y :=\n  fun h => not_lf.2 ((lf_of_fuzzy h).le ox oy) h.2\n\n"}
{"name":"SetTheory.PGame.lt_or_equiv_or_gt","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x y : SetTheory.PGame\nox : x.Numeric\noy : y.Numeric\n⊢ Or (LT.lt x y) (Or (HasEquiv.Equiv x y) (LT.lt y x))","decl":"theorem lt_or_equiv_or_gt {x y : PGame} (ox : Numeric x) (oy : Numeric y) :\n    x < y ∨ (x ≈ y) ∨ y < x :=\n  ((lf_or_equiv_or_gf x y).imp fun h => h.lt ox oy) <| Or.imp_right fun h => h.lt oy ox\n\n"}
{"name":"SetTheory.PGame.numeric_of_isEmpty","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x : SetTheory.PGame\ninst✝¹ : IsEmpty x.LeftMoves\ninst✝ : IsEmpty x.RightMoves\n⊢ x.Numeric","decl":"theorem numeric_of_isEmpty (x : PGame) [IsEmpty x.LeftMoves] [IsEmpty x.RightMoves] : Numeric x :=\n  Numeric.mk isEmptyElim isEmptyElim isEmptyElim\n\n"}
{"name":"SetTheory.PGame.numeric_of_isEmpty_leftMoves","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x : SetTheory.PGame\ninst✝ : IsEmpty x.LeftMoves\na✝ : ∀ (j : x.RightMoves), (x.moveRight j).Numeric\n⊢ x.Numeric","decl":"theorem numeric_of_isEmpty_leftMoves (x : PGame) [IsEmpty x.LeftMoves] :\n    (∀ j, Numeric (x.moveRight j)) → Numeric x :=\n  Numeric.mk isEmptyElim isEmptyElim\n\n"}
{"name":"SetTheory.PGame.numeric_of_isEmpty_rightMoves","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x : SetTheory.PGame\ninst✝ : IsEmpty x.RightMoves\nH : ∀ (i : x.LeftMoves), (x.moveLeft i).Numeric\n⊢ x.Numeric","decl":"theorem numeric_of_isEmpty_rightMoves (x : PGame) [IsEmpty x.RightMoves]\n    (H : ∀ i, Numeric (x.moveLeft i)) : Numeric x :=\n  Numeric.mk (fun _ => isEmptyElim) H isEmptyElim\n\n"}
{"name":"SetTheory.PGame.numeric_zero","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"⊢ SetTheory.PGame.Numeric 0","decl":"theorem numeric_zero : Numeric 0 :=\n  numeric_of_isEmpty 0\n\n"}
{"name":"SetTheory.PGame.numeric_one","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"⊢ SetTheory.PGame.Numeric 1","decl":"theorem numeric_one : Numeric 1 :=\n  numeric_of_isEmpty_rightMoves 1 fun _ => numeric_zero\n\n"}
{"name":"SetTheory.PGame.Numeric.neg","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x : SetTheory.PGame\nx✝ : x.Numeric\n⊢ (Neg.neg x).Numeric","decl":"theorem Numeric.neg : ∀ {x : PGame} (_ : Numeric x), Numeric (-x)\n  | ⟨_, _, _, _⟩, o =>\n    ⟨fun j i => neg_lt_neg_iff.2 (o.1 i j), fun j => (o.2.2 j).neg, fun i => (o.2.1 i).neg⟩\n\n"}
{"name":"SetTheory.PGame.insertLeft_numeric","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x x' : SetTheory.PGame\nx_num : x.Numeric\nx'_num : x'.Numeric\nh : LE.le x' x\n⊢ (x.insertLeft x').Numeric","decl":"/-- Inserting a smaller numeric left option into a numeric game results in a numeric game. -/\ntheorem insertLeft_numeric {x x' : PGame} (x_num : x.Numeric) (x'_num : x'.Numeric)\n    (h : x' ≤ x) : (insertLeft x x').Numeric := by\n  rw [le_iff_forall_lt x'_num x_num] at h\n  unfold Numeric at x_num ⊢\n  rcases x with ⟨xl, xr, xL, xR⟩\n  simp only [insertLeft, Sum.forall, forall_const, Sum.elim_inl, Sum.elim_inr] at x_num ⊢\n  constructor\n  · simp only [x_num.1, implies_true, true_and]\n    simp only [rightMoves_mk, moveRight_mk] at h\n    exact h.2\n  · simp only [x_num, implies_true, x'_num, and_self]\n\n"}
{"name":"SetTheory.PGame.insertRight_numeric","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x x' : SetTheory.PGame\nx_num : x.Numeric\nx'_num : x'.Numeric\nh : LE.le x x'\n⊢ (x.insertRight x').Numeric","decl":"/-- Inserting a larger numeric right option into a numeric game results in a numeric game. -/\ntheorem insertRight_numeric {x x' : PGame} (x_num : x.Numeric) (x'_num : x'.Numeric)\n    (h : x ≤ x') : (insertRight x x').Numeric := by\n  rw [← neg_neg (x.insertRight x'), ← neg_insertLeft_neg]\n  apply Numeric.neg\n  exact insertLeft_numeric (Numeric.neg x_num) (Numeric.neg x'_num) (neg_le_neg_iff.mpr h)\n\n"}
{"name":"SetTheory.PGame.Numeric.moveLeft_lt","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x : SetTheory.PGame\no : x.Numeric\ni : x.LeftMoves\n⊢ LT.lt (x.moveLeft i) x","decl":"theorem moveLeft_lt {x : PGame} (o : Numeric x) (i) : x.moveLeft i < x :=\n  (moveLeft_lf i).lt (o.moveLeft i) o\n\n"}
{"name":"SetTheory.PGame.Numeric.moveLeft_le","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x : SetTheory.PGame\no : x.Numeric\ni : x.LeftMoves\n⊢ LE.le (x.moveLeft i) x","decl":"theorem moveLeft_le {x : PGame} (o : Numeric x) (i) : x.moveLeft i ≤ x :=\n  (o.moveLeft_lt i).le\n\n"}
{"name":"SetTheory.PGame.Numeric.lt_moveRight","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x : SetTheory.PGame\no : x.Numeric\nj : x.RightMoves\n⊢ LT.lt x (x.moveRight j)","decl":"theorem lt_moveRight {x : PGame} (o : Numeric x) (j) : x < x.moveRight j :=\n  (lf_moveRight j).lt o (o.moveRight j)\n\n"}
{"name":"SetTheory.PGame.Numeric.le_moveRight","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x : SetTheory.PGame\no : x.Numeric\nj : x.RightMoves\n⊢ LE.le x (x.moveRight j)","decl":"theorem le_moveRight {x : PGame} (o : Numeric x) (j) : x ≤ x.moveRight j :=\n  (o.lt_moveRight j).le\n\n"}
{"name":"SetTheory.PGame.Numeric.add","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x y : SetTheory.PGame\nx✝¹ : x.Numeric\nx✝ : y.Numeric\n⊢ (HAdd.hAdd x y).Numeric","decl":"theorem add : ∀ {x y : PGame} (_ : Numeric x) (_ : Numeric y), Numeric (x + y)\n  | ⟨xl, xr, xL, xR⟩, ⟨yl, yr, yL, yR⟩, ox, oy =>\n    ⟨by\n      rintro (ix | iy) (jx | jy)\n      · exact add_lt_add_right (ox.1 ix jx) _\n      · exact (add_lf_add_of_lf_of_le (lf_mk _ _ ix) (oy.le_moveRight jy)).lt\n          ((ox.moveLeft ix).add oy) (ox.add (oy.moveRight jy))\n      · exact (add_lf_add_of_lf_of_le (mk_lf _ _ jx) (oy.moveLeft_le iy)).lt\n          (ox.add (oy.moveLeft iy)) ((ox.moveRight jx).add oy)\n      · exact add_lt_add_left (oy.1 iy jy) ⟨xl, xr, xL, xR⟩, by\n      constructor\n      · rintro (ix | iy)\n        · exact (ox.moveLeft ix).add oy\n        · exact ox.add (oy.moveLeft iy)\n      · rintro (jx | jy)\n        · apply (ox.moveRight jx).add oy\n        · apply ox.add (oy.moveRight jy)⟩\ntermination_by x y => (x, y) -- Porting note: Added `termination_by`\n\n"}
{"name":"SetTheory.PGame.Numeric.sub","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x y : SetTheory.PGame\nox : x.Numeric\noy : y.Numeric\n⊢ (HSub.hSub x y).Numeric","decl":"theorem sub {x y : PGame} (ox : Numeric x) (oy : Numeric y) : Numeric (x - y) :=\n  ox.add oy.neg\n\n"}
{"name":"SetTheory.PGame.numeric_nat","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"n : Nat\n⊢ (↑n).Numeric","decl":"/-- Pre-games defined by natural numbers are numeric. -/\ntheorem numeric_nat : ∀ n : ℕ, Numeric n\n  | 0 => numeric_zero\n  | n + 1 => (numeric_nat n).add numeric_one\n\n"}
{"name":"SetTheory.PGame.numeric_toPGame","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"o : Ordinal.{u_1}\n⊢ o.toPGame.Numeric","decl":"/-- Ordinal games are numeric. -/\ntheorem numeric_toPGame (o : Ordinal) : o.toPGame.Numeric := by\n  induction' o using Ordinal.induction with o IH\n  apply numeric_of_isEmpty_rightMoves\n  simpa using fun i => IH _ (Ordinal.toLeftMovesToPGame_symm_lt i)\n\n"}
{"name":"Surreal.mk_eq_mk","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x y : SetTheory.PGame\nhx : x.Numeric\nhy : y.Numeric\n⊢ Iff (Eq (Surreal.mk x hx) (Surreal.mk y hy)) (HasEquiv.Equiv x y)","decl":"lemma mk_eq_mk {x y : PGame.{u}} {hx hy} : mk x hx = mk y hy ↔ x ≈ y := Quotient.eq\n\n"}
{"name":"Surreal.mk_eq_zero","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x : SetTheory.PGame\nhx : x.Numeric\n⊢ Iff (Eq (Surreal.mk x hx) 0) (HasEquiv.Equiv x 0)","decl":"lemma mk_eq_zero {x : PGame.{u}} {hx} : mk x hx = 0 ↔ x ≈ 0 := Quotient.eq\n\n"}
{"name":"Surreal.mk_le_mk","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x y : SetTheory.PGame\nhx : x.Numeric\nhy : y.Numeric\n⊢ Iff (LE.le (Surreal.mk x hx) (Surreal.mk y hy)) (LE.le x y)","decl":"@[simp]\nlemma mk_le_mk {x y : PGame.{u}} {hx hy} : mk x hx ≤ mk y hy ↔ x ≤ y := Iff.rfl\n\n"}
{"name":"Surreal.zero_le_mk","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x : SetTheory.PGame\nhx : x.Numeric\n⊢ Iff (LE.le 0 (Surreal.mk x hx)) (LE.le 0 x)","decl":"lemma zero_le_mk {x : PGame.{u}} {hx} : 0 ≤ mk x hx ↔ 0 ≤ x := Iff.rfl\n\n"}
{"name":"Surreal.mk_lt_mk","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x y : SetTheory.PGame\nhx : x.Numeric\nhy : y.Numeric\n⊢ Iff (LT.lt (Surreal.mk x hx) (Surreal.mk y hy)) (LT.lt x y)","decl":"lemma mk_lt_mk {x y : PGame.{u}} {hx hy} : mk x hx < mk y hy ↔ x < y := Iff.rfl\n\n"}
{"name":"Surreal.zero_lt_mk","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x : SetTheory.PGame\nhx : x.Numeric\n⊢ Iff (LT.lt 0 (Surreal.mk x hx)) (LT.lt 0 x)","decl":"lemma zero_lt_mk {x : PGame.{u}} {hx} : 0 < mk x hx ↔ 0 < x := Iff.rfl\n\n"}
{"name":"Surreal.mk_moveLeft_lt_mk","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x : SetTheory.PGame\no : x.Numeric\ni : x.LeftMoves\n⊢ LT.lt (Surreal.mk (x.moveLeft i) ⋯) (Surreal.mk x o)","decl":"/-- Same as `moveLeft_lt`, but for `Surreal` instead of `PGame` -/\ntheorem mk_moveLeft_lt_mk {x : PGame} (o : Numeric x) (i) :\n    Surreal.mk (x.moveLeft i) (Numeric.moveLeft o i) < Surreal.mk x o := Numeric.moveLeft_lt o i\n\n"}
{"name":"Surreal.mk_lt_mk_moveRight","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x : SetTheory.PGame\no : x.Numeric\nj : x.RightMoves\n⊢ LT.lt (Surreal.mk x o) (Surreal.mk (x.moveRight j) ⋯)","decl":"/-- Same as `lt_moveRight`, but for `Surreal` instead of `PGame` -/\ntheorem mk_lt_mk_moveRight {x : PGame} (o : Numeric x) (j) :\n    Surreal.mk x o < Surreal.mk (x.moveRight j) (Numeric.moveRight o j) := Numeric.lt_moveRight o j\n\n"}
{"name":"Surreal.mk_add","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x y : SetTheory.PGame\nhx : x.Numeric\nhy : y.Numeric\n⊢ Eq (Surreal.mk (HAdd.hAdd x y) ⋯) (HAdd.hAdd (Surreal.mk x hx) (Surreal.mk y hy))","decl":"lemma mk_add {x y : PGame} (hx : x.Numeric) (hy : y.Numeric) :\n    Surreal.mk (x + y) (hx.add hy) = Surreal.mk x hx + Surreal.mk y hy := by rfl\n\n"}
{"name":"Surreal.mk_sub","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"x y : SetTheory.PGame\nhx : x.Numeric\nhy : y.Numeric\n⊢ Eq (Surreal.mk (HSub.hSub x y) ⋯) (HSub.hSub (Surreal.mk x hx) (Surreal.mk y hy))","decl":"lemma mk_sub {x y : PGame} (hx : x.Numeric) (hy : y.Numeric) :\n    Surreal.mk (x - y) (hx.sub hy) = Surreal.mk x hx - Surreal.mk y hy := by rfl\n\n"}
{"name":"Surreal.zero_def","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"⊢ Eq 0 (Surreal.mk 0 SetTheory.PGame.numeric_zero)","decl":"lemma zero_def : 0 = mk 0 numeric_zero := by rfl\n\n"}
{"name":"Surreal.zero_toGame","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"⊢ Eq (Surreal.toGame 0) 0","decl":"@[simp]\ntheorem zero_toGame : toGame 0 = 0 :=\n  rfl\n\n"}
{"name":"Surreal.one_toGame","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"⊢ Eq (Surreal.toGame 1) 1","decl":"@[simp]\ntheorem one_toGame : toGame 1 = 1 :=\n  rfl\n\n"}
{"name":"Surreal.nat_toGame","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"n : Nat\n⊢ Eq (Surreal.toGame ↑n) ↑n","decl":"@[simp]\ntheorem nat_toGame : ∀ n : ℕ, toGame n = n :=\n  map_natCast' _ one_toGame\n\n"}
{"name":"Surreal.bddAbove_range_of_small","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"ι : Type u_1\ninst✝ : Small.{u, u_1} ι\nf : ι → Surreal\n⊢ BddAbove (Set.range f)","decl":"/-- A small family of surreals is bounded above. -/\nlemma bddAbove_range_of_small {ι : Type*} [Small.{u} ι] (f : ι → Surreal.{u}) :\n    BddAbove (Set.range f) := by\n  induction' f using Quotient.induction_on_pi with f\n  let g : ι → PGame.{u} := Subtype.val ∘ f\n  have hg (i) : (g i).Numeric := Subtype.prop _\n  conv in (⟦f _⟧) =>\n    change mk (g i) (hg i)\n  clear_value g\n  clear f\n  let x : PGame.{u} := ⟨Σ i, (g <| (equivShrink.{u} ι).symm i).LeftMoves, PEmpty,\n    fun x ↦ moveLeft _ x.2, PEmpty.elim⟩\n  refine ⟨mk x (.mk (by simp [x]) (fun _ ↦ (hg _).moveLeft _) (by simp [x])),\n    Set.forall_mem_range.2 fun i ↦ ?_⟩\n  rw [mk_le_mk, ← (equivShrink ι).symm_apply_apply i, le_iff_forall_lf]\n  simpa [x] using fun j ↦ @moveLeft_lf x ⟨equivShrink ι i, j⟩\n\n"}
{"name":"Surreal.bddAbove_of_small","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"s : Set Surreal\ninst✝ : Small.{u, u + 1} ↑s\n⊢ BddAbove s","decl":"/-- A small set of surreals is bounded above. -/\nlemma bddAbove_of_small (s : Set Surreal.{u}) [Small.{u} s] : BddAbove s := by\n  simpa using bddAbove_range_of_small (Subtype.val : s → Surreal.{u})\n\n"}
{"name":"Surreal.bddBelow_range_of_small","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"ι : Type u_1\ninst✝ : Small.{u, u_1} ι\nf : ι → Surreal\n⊢ BddBelow (Set.range f)","decl":"/-- A small family of surreals is bounded below. -/\nlemma bddBelow_range_of_small {ι : Type*} [Small.{u} ι] (f : ι → Surreal.{u}) :\n    BddBelow (Set.range f) := by\n  induction' f using Quotient.induction_on_pi with f\n  let g : ι → PGame.{u} := Subtype.val ∘ f\n  have hg (i) : (g i).Numeric := Subtype.prop _\n  conv in (⟦f _⟧) =>\n    change mk (g i) (hg i)\n  clear_value g\n  clear f\n  let x : PGame.{u} := ⟨PEmpty, Σ i, (g <| (equivShrink.{u} ι).symm i).RightMoves,\n    PEmpty.elim, fun x ↦ moveRight _ x.2⟩\n  refine ⟨mk x (.mk (by simp [x]) (by simp [x]) (fun _ ↦ (hg _).moveRight _) ),\n    Set.forall_mem_range.2 fun i ↦ ?_⟩\n  rw [mk_le_mk, ← (equivShrink ι).symm_apply_apply i, le_iff_forall_lf]\n  simpa [x] using fun j ↦ @lf_moveRight x ⟨equivShrink ι i, j⟩\n\n"}
{"name":"Surreal.bddBelow_of_small","module":"Mathlib.SetTheory.Surreal.Basic","initialProofState":"s : Set Surreal\ninst✝ : Small.{u, u + 1} ↑s\n⊢ BddBelow s","decl":"/-- A small set of surreals is bounded below. -/\nlemma bddBelow_of_small (s : Set Surreal.{u}) [Small.{u} s] : BddBelow s := by\n  simpa using bddBelow_range_of_small (Subtype.val : s → Surreal.{u})\n\n"}
