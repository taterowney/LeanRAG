{"name":"ConvexOn.lipschitzOnWith_of_abs_le","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nx₀ : E\nε r M : Real\nhf : ConvexOn Real (Metric.ball x₀ r) f\nhε : LT.lt 0 ε\nhM : ∀ (a : E), LT.lt (Dist.dist a x₀) r → LE.le (abs (f a)) M\n⊢ LipschitzOnWith (HDiv.hDiv (HMul.hMul 2 M) ε).toNNReal f (Metric.ball x₀ (HSub.hSub r ε))","decl":"lemma ConvexOn.lipschitzOnWith_of_abs_le (hf : ConvexOn ℝ (ball x₀ r) f) (hε : 0 < ε)\n    (hM : ∀ a, dist a x₀ < r → |f a| ≤ M) :\n    LipschitzOnWith (2 * M / ε).toNNReal f (ball x₀ (r - ε)) := by\n  set K := 2 * M / ε with hK\n  have oneside {x y : E} (hx : x ∈ ball x₀ (r - ε)) (hy : y ∈ ball x₀ (r - ε)) :\n      f x - f y ≤ K * ‖x - y‖ := by\n    obtain rfl | hxy := eq_or_ne x y\n    · simp\n    have hx₀r : ball x₀ (r - ε) ⊆ ball x₀ r := ball_subset_ball <| by linarith\n    have hx' : x ∈ ball x₀ r := hx₀r hx\n    have hy' : y ∈ ball x₀ r := hx₀r hy\n    let z := x + (ε / ‖x - y‖) • (x - y)\n    replace hxy : 0 < ‖x - y‖ := by rwa [norm_sub_pos_iff]\n    have hz : z ∈ ball x₀ r := mem_ball_iff_norm.2 <| by\n      calc\n        _ = ‖(x - x₀) + (ε / ‖x - y‖) • (x - y)‖ := by simp only [z, add_sub_right_comm]\n        _ ≤ ‖x - x₀‖ + ‖(ε / ‖x - y‖) • (x - y)‖ := norm_add_le ..\n        _ < r - ε + ε :=\n          add_lt_add_of_lt_of_le (mem_ball_iff_norm.1 hx) <| by\n            simp [norm_smul, abs_of_nonneg, hε.le, hxy.ne']\n        _ = r := by simp\n    let a := ε / (ε + ‖x - y‖)\n    let b := ‖x - y‖ / (ε + ‖x - y‖)\n    have hab : a + b = 1 := by field_simp [a, b]\n    have hxyz : x = a • y + b • z := by\n      calc\n        x = a • x + b • x := by rw [Convex.combo_self hab]\n        _ = a • y + b • z := by simp [z, a, b, smul_smul, hxy.ne', smul_sub]; abel\n    rw [hK, mul_comm, ← mul_div_assoc, le_div_iff₀' hε]\n    calc\n      ε * (f x - f y) ≤ ‖x - y‖ * (f z - f x) := by\n        rw [mul_sub, mul_sub, sub_le_sub_iff, ← add_mul]\n        have h := hf.2 hy' hz (by positivity) (by positivity) hab\n        rw [← hxyz] at h\n        field_simp [a, b, ← mul_div_right_comm] at h\n        rwa [← le_div_iff₀' (by positivity), add_comm (_ * _)]\n      _ ≤ _ := by\n        rw [sub_eq_add_neg (f _), two_mul]\n        gcongr\n        · exact (le_abs_self _).trans <| hM _ hz\n        · exact (neg_le_abs _).trans <| hM _ hx'\n  refine .of_dist_le' fun x hx y hy ↦ ?_\n  simp_rw [dist_eq_norm_sub, Real.norm_eq_abs, abs_sub_le_iff]\n  exact ⟨oneside hx hy, norm_sub_rev x _ ▸ oneside hy hx⟩\n\n"}
{"name":"ConcaveOn.lipschitzOnWith_of_abs_le","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nx₀ : E\nε r M : Real\nhf : ConcaveOn Real (Metric.ball x₀ r) f\nhε : LT.lt 0 ε\nhM : ∀ (a : E), LT.lt (Dist.dist a x₀) r → LE.le (abs (f a)) M\n⊢ LipschitzOnWith (HDiv.hDiv (HMul.hMul 2 M) ε).toNNReal f (Metric.ball x₀ (HSub.hSub r ε))","decl":"lemma ConcaveOn.lipschitzOnWith_of_abs_le (hf : ConcaveOn ℝ (ball x₀ r) f) (hε : 0 < ε)\n    (hM : ∀ a, dist a x₀ < r → |f a| ≤ M) :\n    LipschitzOnWith (2 * M / ε).toNNReal f (ball x₀ (r - ε)) := by\n  simpa using hf.neg.lipschitzOnWith_of_abs_le hε <| by simpa using hM\n\n"}
{"name":"ConvexOn.exists_lipschitzOnWith_of_isBounded","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nx₀ : E\nr r' : Real\nhf : ConvexOn Real (Metric.ball x₀ r) f\nhr : LT.lt r' r\nhf' : Bornology.IsBounded (Set.image f (Metric.ball x₀ r))\n⊢ Exists fun K => LipschitzOnWith K f (Metric.ball x₀ r')","decl":"lemma ConvexOn.exists_lipschitzOnWith_of_isBounded (hf : ConvexOn ℝ (ball x₀ r) f) (hr : r' < r)\n    (hf' : IsBounded (f '' ball x₀ r)) : ∃ K, LipschitzOnWith K f (ball x₀ r') := by\n  rw [isBounded_iff_subset_ball 0] at hf'\n  simp only [Set.subset_def, mem_image, mem_ball, dist_zero_right, Real.norm_eq_abs,\n    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂] at hf'\n  obtain ⟨M, hM⟩ := hf'\n  rw [← sub_sub_cancel r r']\n  exact ⟨_, hf.lipschitzOnWith_of_abs_le (sub_pos.2 hr) fun a ha ↦ (hM a ha).le⟩\n\n"}
{"name":"ConcaveOn.exists_lipschitzOnWith_of_isBounded","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nx₀ : E\nr r' : Real\nhf : ConcaveOn Real (Metric.ball x₀ r) f\nhr : LT.lt r' r\nhf' : Bornology.IsBounded (Set.image f (Metric.ball x₀ r))\n⊢ Exists fun K => LipschitzOnWith K f (Metric.ball x₀ r')","decl":"lemma ConcaveOn.exists_lipschitzOnWith_of_isBounded (hf : ConcaveOn ℝ (ball x₀ r) f) (hr : r' < r)\n    (hf' : IsBounded (f '' ball x₀ r)) : ∃ K, LipschitzOnWith K f (ball x₀ r') := by\n  replace hf' : IsBounded ((-f) '' ball x₀ r) := by convert hf'.neg; ext; simp [neg_eq_iff_eq_neg]\n  simpa using hf.neg.exists_lipschitzOnWith_of_isBounded hr hf'\n\n"}
{"name":"ConvexOn.isBoundedUnder_abs","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nC : Set E\nf : E → Real\nhf : ConvexOn Real C f\nx₀ : E\nhC : Membership.mem (nhds x₀) C\n⊢ Iff (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) (nhds x₀) (abs f)) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) (nhds x₀) f)","decl":"lemma ConvexOn.isBoundedUnder_abs (hf : ConvexOn ℝ C f) {x₀ : E} (hC : C ∈ 𝓝 x₀) :\n    (𝓝 x₀).IsBoundedUnder (· ≤ ·) |f| ↔ (𝓝 x₀).IsBoundedUnder (· ≤ ·) f := by\n  refine ⟨fun h ↦ h.mono_le <| .of_forall fun x ↦ le_abs_self _, ?_⟩\n  rintro ⟨r, hr⟩\n  refine ⟨|r| + 2 * |f x₀|, ?_⟩\n  have : (𝓝 x₀).Tendsto (fun y => 2 • x₀ - y) (𝓝 x₀) :=\n    tendsto_nhds_nhds.2 (⟨·, ·, by simp [two_nsmul, dist_comm]⟩)\n  simp only [Filter.eventually_map, Pi.abs_apply, abs_le'] at hr ⊢\n  filter_upwards [this.eventually_mem hC, hC, hr, this.eventually hr] with y hx hx' hfr hfr'\n  refine ⟨hfr.trans <| (le_abs_self _).trans <| by simp, ?_⟩\n  rw [← sub_le_iff_le_add, neg_sub_comm, sub_le_iff_le_add', ← abs_two, ← abs_mul]\n  calc\n    -|2 * f x₀| ≤ 2 * f x₀ := neg_abs_le _\n    _ ≤ f y + f (2 • x₀ - y) := by\n      have := hf.2 hx' hx (by positivity) (by positivity) (add_halves _)\n      simp only [one_div, ← Nat.cast_smul_eq_nsmul ℝ, Nat.cast_ofNat, smul_sub, ne_eq,\n        OfNat.ofNat_ne_zero, not_false_eq_true, inv_smul_smul₀, add_sub_cancel, smul_eq_mul] at this\n      cancel_denoms at this\n      rwa [← Nat.cast_two, Nat.cast_smul_eq_nsmul] at this\n    _ ≤ f y + |r| := by gcongr; exact hfr'.trans (le_abs_self _)\n\n"}
{"name":"ConcaveOn.isBoundedUnder_abs","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nC : Set E\nf : E → Real\nhf : ConcaveOn Real C f\nx₀ : E\nhC : Membership.mem (nhds x₀) C\n⊢ Iff (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) (nhds x₀) (abs f)) (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) (nhds x₀) f)","decl":"lemma ConcaveOn.isBoundedUnder_abs (hf : ConcaveOn ℝ C f) {x₀ : E} (hC : C ∈ 𝓝 x₀) :\n    (𝓝 x₀).IsBoundedUnder (· ≤ ·) |f| ↔ (𝓝 x₀).IsBoundedUnder (· ≥ ·) f := by\n  simpa [Pi.neg_def, Pi.abs_def] using hf.neg.isBoundedUnder_abs hC\n\n"}
{"name":"ConvexOn.continuousOn_tfae","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nC : Set E\nf : E → Real\nhC : IsOpen C\nhC' : C.Nonempty\nhf : ConvexOn Real C f\n⊢ (List.cons (LocallyLipschitzOn C f) (List.cons (ContinuousOn f C) (List.cons (Exists fun x₀ => And (Membership.mem C x₀) (ContinuousAt f x₀)) (List.cons (Exists fun x₀ => And (Membership.mem C x₀) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) (nhds x₀) f)) (List.cons (∀ ⦃x₀ : E⦄, Membership.mem C x₀ → Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) (nhds x₀) f) (List.cons (∀ ⦃x₀ : E⦄, Membership.mem C x₀ → Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) (nhds x₀) (abs f)) List.nil)))))).TFAE","decl":"lemma ConvexOn.continuousOn_tfae (hC : IsOpen C) (hC' : C.Nonempty) (hf : ConvexOn ℝ C f) : TFAE [\n    LocallyLipschitzOn C f,\n    ContinuousOn f C,\n    ∃ x₀ ∈ C, ContinuousAt f x₀,\n    ∃ x₀ ∈ C, (𝓝 x₀).IsBoundedUnder (· ≤ ·) f,\n    ∀ ⦃x₀⦄, x₀ ∈ C → (𝓝 x₀).IsBoundedUnder (· ≤ ·) f,\n    ∀ ⦃x₀⦄, x₀ ∈ C → (𝓝 x₀).IsBoundedUnder (· ≤ ·) |f|] := by\n  tfae_have 1 → 2 := LocallyLipschitzOn.continuousOn\n  tfae_have 2 → 3 := by\n    obtain ⟨x₀, hx₀⟩ := hC'\n    exact fun h ↦ ⟨x₀, hx₀, h.continuousAt <| hC.mem_nhds hx₀⟩\n  tfae_have 3 → 4\n  | ⟨x₀, hx₀, h⟩ =>\n    ⟨x₀, hx₀, f x₀ + 1, by simpa using h.eventually (eventually_le_nhds (by simp))⟩\n  tfae_have 4 → 5\n  | ⟨x₀, hx₀, r, hr⟩, x, hx => by\n    have : ∀ᶠ δ in 𝓝 (0 : ℝ), (1 - δ)⁻¹ • x - (δ / (1 - δ)) • x₀ ∈ C := by\n      have h : ContinuousAt (fun δ : ℝ ↦ (1 - δ)⁻¹ • x - (δ / (1 - δ)) • x₀) 0 := by\n        fun_prop (disch := norm_num)\n      exact h (by simpa using hC.mem_nhds hx)\n    obtain ⟨δ, hδ₀, hy, hδ₁⟩ := (this.and <| eventually_lt_nhds zero_lt_one).exists_gt\n    set y := (1 - δ)⁻¹ • x - (δ / (1 - δ)) • x₀\n    refine ⟨max r (f y), ?_⟩\n    simp only [Filter.eventually_map, Pi.abs_apply] at hr ⊢\n    obtain ⟨ε, hε, hr⟩ := Metric.eventually_nhds_iff.1 <| hr.and (hC.eventually_mem hx₀)\n    refine Metric.eventually_nhds_iff.2 ⟨ε * δ, by positivity, fun z hz ↦ ?_⟩\n    have hx₀' : δ⁻¹ • (x - y) + y = x₀ := MulAction.injective₀ (sub_ne_zero.2 hδ₁.ne') <| by\n      simp [y, smul_sub, smul_smul, hδ₀.ne', div_eq_mul_inv, sub_ne_zero.2 hδ₁.ne', mul_left_comm,\n        sub_mul, sub_smul]\n    let w := δ⁻¹ • (z - y) + y\n    have hwyz : δ • w + (1 - δ) • y = z := by simp [w, hδ₀.ne', sub_smul]\n    have hw : dist w x₀ < ε := by\n      simpa [w, ← hx₀', dist_smul₀, abs_of_nonneg, hδ₀.le, inv_mul_lt_iff₀', hδ₀]\n    calc\n      f z ≤ max (f w) (f y) :=\n        hf.le_max_of_mem_segment (hr hw).2 hy ⟨_, _, hδ₀.le, sub_nonneg.2 hδ₁.le, by simp, hwyz⟩\n      _ ≤ max r (f y) := by gcongr; exact (hr hw).1\n  tfae_have 6 ↔ 5 := forall₂_congr fun x₀ hx₀ ↦ hf.isBoundedUnder_abs (hC.mem_nhds hx₀)\n  tfae_have 6 → 1\n  | h, x, hx => by\n    obtain ⟨r, hr⟩ := h hx\n    obtain ⟨ε, hε, hεD⟩ := Metric.mem_nhds_iff.1 <| Filter.inter_mem (hC.mem_nhds hx) hr\n    simp only [preimage_setOf_eq, Pi.abs_apply, subset_inter_iff, hC.nhdsWithin_eq hx] at hεD ⊢\n    obtain ⟨K, hK⟩ := exists_lipschitzOnWith_of_isBounded (hf.subset hεD.1 (convex_ball ..))\n      (half_lt_self hε) <| isBounded_iff_forall_norm_le.2 ⟨r, by simpa using hεD.2⟩\n    exact ⟨K, _, ball_mem_nhds _ (by simpa), hK⟩\n  tfae_finish\n\n"}
{"name":"ConcaveOn.continuousOn_tfae","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nC : Set E\nf : E → Real\nhC : IsOpen C\nhC' : C.Nonempty\nhf : ConcaveOn Real C f\n⊢ (List.cons (LocallyLipschitzOn C f) (List.cons (ContinuousOn f C) (List.cons (Exists fun x₀ => And (Membership.mem C x₀) (ContinuousAt f x₀)) (List.cons (Exists fun x₀ => And (Membership.mem C x₀) (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) (nhds x₀) f)) (List.cons (∀ ⦃x₀ : E⦄, Membership.mem C x₀ → Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) (nhds x₀) f) (List.cons (∀ ⦃x₀ : E⦄, Membership.mem C x₀ → Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) (nhds x₀) (abs f)) List.nil)))))).TFAE","decl":"lemma ConcaveOn.continuousOn_tfae (hC : IsOpen C) (hC' : C.Nonempty) (hf : ConcaveOn ℝ C f) : TFAE [\n    LocallyLipschitzOn C f,\n    ContinuousOn f C,\n    ∃ x₀ ∈ C, ContinuousAt f x₀,\n    ∃ x₀ ∈ C, (𝓝 x₀).IsBoundedUnder (· ≥ ·) f,\n    ∀ ⦃x₀⦄, x₀ ∈ C → (𝓝 x₀).IsBoundedUnder (· ≥ ·) f,\n    ∀ ⦃x₀⦄, x₀ ∈ C → (𝓝 x₀).IsBoundedUnder (· ≤ ·) |f|] := by\n  have := hf.neg.continuousOn_tfae hC hC'\n  simp only [locallyLipschitzOn_neg_iff, continuousOn_neg_iff, continuousAt_neg_iff, abs_neg]\n    at this\n  convert this using 8 <;> exact (Equiv.neg ℝ).exists_congr (by simp)\n\n"}
{"name":"ConvexOn.locallyLipschitzOn_iff_continuousOn","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nC : Set E\nf : E → Real\nhC : IsOpen C\nhf : ConvexOn Real C f\n⊢ Iff (LocallyLipschitzOn C f) (ContinuousOn f C)","decl":"lemma ConvexOn.locallyLipschitzOn_iff_continuousOn (hC : IsOpen C) (hf : ConvexOn ℝ C f) :\n    LocallyLipschitzOn C f ↔ ContinuousOn f C := by\n  obtain rfl | hC' := C.eq_empty_or_nonempty\n  · simp\n  · exact (hf.continuousOn_tfae hC hC').out 0 1\n\n"}
{"name":"ConcaveOn.locallyLipschitzOn_iff_continuousOn","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nC : Set E\nf : E → Real\nhC : IsOpen C\nhf : ConcaveOn Real C f\n⊢ Iff (LocallyLipschitzOn C f) (ContinuousOn f C)","decl":"lemma ConcaveOn.locallyLipschitzOn_iff_continuousOn (hC : IsOpen C) (hf : ConcaveOn ℝ C f) :\n    LocallyLipschitzOn C f ↔ ContinuousOn f C := by\n  simpa using hf.neg.locallyLipschitzOn_iff_continuousOn hC\n\n"}
{"name":"ConvexOn.locallyLipschitzOn","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nC : Set E\nf : E → Real\ninst✝ : FiniteDimensional Real E\nhC : IsOpen C\nhf : ConvexOn Real C f\n⊢ LocallyLipschitzOn C f","decl":"protected lemma ConvexOn.locallyLipschitzOn (hC : IsOpen C) (hf : ConvexOn ℝ C f) :\n    LocallyLipschitzOn C f := by\n  obtain rfl | ⟨x₀, hx₀⟩ := C.eq_empty_or_nonempty\n  · simp\n  · obtain ⟨b, hx₀b, hbC⟩ := exists_mem_interior_convexHull_affineBasis (hC.mem_nhds hx₀)\n    refine ((hf.continuousOn_tfae hC ⟨x₀, hx₀⟩).out 3 0).mp ?_\n    refine ⟨x₀, hx₀, BddAbove.isBoundedUnder (IsOpen.mem_nhds isOpen_interior hx₀b) ?_⟩\n    exact (hf.bddAbove_convexHull ((subset_convexHull ..).trans hbC)\n      ((finite_range _).image _).bddAbove).mono (by gcongr; exact interior_subset)\n\n"}
{"name":"ConcaveOn.locallyLipschitzOn","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nC : Set E\nf : E → Real\ninst✝ : FiniteDimensional Real E\nhC : IsOpen C\nhf : ConcaveOn Real C f\n⊢ LocallyLipschitzOn C f","decl":"protected lemma ConcaveOn.locallyLipschitzOn (hC : IsOpen C) (hf : ConcaveOn ℝ C f) :\n    LocallyLipschitzOn C f := by simpa using hf.neg.locallyLipschitzOn hC\n\n"}
{"name":"ConvexOn.continuousOn","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nC : Set E\nf : E → Real\ninst✝ : FiniteDimensional Real E\nhC : IsOpen C\nhf : ConvexOn Real C f\n⊢ ContinuousOn f C","decl":"protected lemma ConvexOn.continuousOn (hC : IsOpen C) (hf : ConvexOn ℝ C f) :\n    ContinuousOn f C := (hf.locallyLipschitzOn hC).continuousOn\n\n"}
{"name":"ConcaveOn.continuousOn","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nC : Set E\nf : E → Real\ninst✝ : FiniteDimensional Real E\nhC : IsOpen C\nhf : ConcaveOn Real C f\n⊢ ContinuousOn f C","decl":"protected lemma ConcaveOn.continuousOn (hC : IsOpen C) (hf : ConcaveOn ℝ C f) :\n    ContinuousOn f C := (hf.locallyLipschitzOn hC).continuousOn\n\n"}
{"name":"ConvexOn.locallyLipschitzOn_interior","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nC : Set E\nf : E → Real\ninst✝ : FiniteDimensional Real E\nhf : ConvexOn Real C f\n⊢ LocallyLipschitzOn (interior C) f","decl":"lemma ConvexOn.locallyLipschitzOn_interior (hf : ConvexOn ℝ C f) :\n    LocallyLipschitzOn (interior C) f :=\n  (hf.subset interior_subset hf.1.interior).locallyLipschitzOn isOpen_interior\n\n"}
{"name":"ConcaveOn.locallyLipschitzOn_interior","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nC : Set E\nf : E → Real\ninst✝ : FiniteDimensional Real E\nhf : ConcaveOn Real C f\n⊢ LocallyLipschitzOn (interior C) f","decl":"lemma ConcaveOn.locallyLipschitzOn_interior (hf : ConcaveOn ℝ C f) :\n    LocallyLipschitzOn (interior C) f :=\n  (hf.subset interior_subset hf.1.interior).locallyLipschitzOn isOpen_interior\n\n"}
{"name":"ConvexOn.continuousOn_interior","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nC : Set E\nf : E → Real\ninst✝ : FiniteDimensional Real E\nhf : ConvexOn Real C f\n⊢ ContinuousOn f (interior C)","decl":"lemma ConvexOn.continuousOn_interior (hf : ConvexOn ℝ C f) : ContinuousOn f (interior C) :=\n  hf.locallyLipschitzOn_interior.continuousOn\n\n"}
{"name":"ConcaveOn.continuousOn_interior","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nC : Set E\nf : E → Real\ninst✝ : FiniteDimensional Real E\nhf : ConcaveOn Real C f\n⊢ ContinuousOn f (interior C)","decl":"lemma ConcaveOn.continuousOn_interior (hf : ConcaveOn ℝ C f) : ContinuousOn f (interior C) :=\n  hf.locallyLipschitzOn_interior.continuousOn\n\n"}
{"name":"ConvexOn.locallyLipschitz","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nf : E → Real\ninst✝ : FiniteDimensional Real E\nhf : ConvexOn Real Set.univ f\n⊢ LocallyLipschitz f","decl":"protected lemma ConvexOn.locallyLipschitz (hf : ConvexOn ℝ univ f) : LocallyLipschitz f := by\n  simpa using hf.locallyLipschitzOn_interior\n\n"}
{"name":"ConcaveOn.locallyLipschitz","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nf : E → Real\ninst✝ : FiniteDimensional Real E\nhf : ConcaveOn Real Set.univ f\n⊢ LocallyLipschitz f","decl":"protected lemma ConcaveOn.locallyLipschitz (hf : ConcaveOn ℝ univ f) : LocallyLipschitz f := by\n  simpa using hf.locallyLipschitzOn_interior\n\n-- Commented out since `intrinsicInterior` is not imported (but should be once these are proved)\n-- proof_wanted ConvexOn.locallyLipschitzOn_intrinsicInterior (hf : ConvexOn ℝ C f) :\n--     ContinuousOn f (intrinsicInterior ℝ C)\n\n-- proof_wanted ConcaveOn.locallyLipschitzOn_intrinsicInterior (hf : ConcaveOn ℝ C f) :\n--     ContinuousOn f (intrinsicInterior ℝ C)\n\n-- proof_wanted ConvexOn.continuousOn_intrinsicInterior (hf : ConvexOn ℝ C f) :\n--     ContinuousOn f (intrinsicInterior ℝ C)\n\n-- proof_wanted ConcaveOn.continuousOn_intrinsicInterior (hf : ConcaveOn ℝ C f) :\n--     ContinuousOn f (intrinsicInterior ℝ C)\n"}
