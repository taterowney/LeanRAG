{"name":"ConvexOn.lipschitzOnWith_of_abs_le","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : E â†’ Real\nxâ‚€ : E\nÎµ r M : Real\nhf : ConvexOn Real (Metric.ball xâ‚€ r) f\nhÎµ : LT.lt 0 Îµ\nhM : âˆ€ (a : E), LT.lt (Dist.dist a xâ‚€) r â†’ LE.le (abs (f a)) M\nâŠ¢ LipschitzOnWith (HDiv.hDiv (HMul.hMul 2 M) Îµ).toNNReal f (Metric.ball xâ‚€ (HSub.hSub r Îµ))","decl":"lemma ConvexOn.lipschitzOnWith_of_abs_le (hf : ConvexOn â„ (ball xâ‚€ r) f) (hÎµ : 0 < Îµ)\n    (hM : âˆ€ a, dist a xâ‚€ < r â†’ |f a| â‰¤ M) :\n    LipschitzOnWith (2 * M / Îµ).toNNReal f (ball xâ‚€ (r - Îµ)) := by\n  set K := 2 * M / Îµ with hK\n  have oneside {x y : E} (hx : x âˆˆ ball xâ‚€ (r - Îµ)) (hy : y âˆˆ ball xâ‚€ (r - Îµ)) :\n      f x - f y â‰¤ K * â€–x - yâ€– := by\n    obtain rfl | hxy := eq_or_ne x y\n    Â· simp\n    have hxâ‚€r : ball xâ‚€ (r - Îµ) âŠ† ball xâ‚€ r := ball_subset_ball <| by linarith\n    have hx' : x âˆˆ ball xâ‚€ r := hxâ‚€r hx\n    have hy' : y âˆˆ ball xâ‚€ r := hxâ‚€r hy\n    let z := x + (Îµ / â€–x - yâ€–) â€¢ (x - y)\n    replace hxy : 0 < â€–x - yâ€– := by rwa [norm_sub_pos_iff]\n    have hz : z âˆˆ ball xâ‚€ r := mem_ball_iff_norm.2 <| by\n      calc\n        _ = â€–(x - xâ‚€) + (Îµ / â€–x - yâ€–) â€¢ (x - y)â€– := by simp only [z, add_sub_right_comm]\n        _ â‰¤ â€–x - xâ‚€â€– + â€–(Îµ / â€–x - yâ€–) â€¢ (x - y)â€– := norm_add_le ..\n        _ < r - Îµ + Îµ :=\n          add_lt_add_of_lt_of_le (mem_ball_iff_norm.1 hx) <| by\n            simp [norm_smul, abs_of_nonneg, hÎµ.le, hxy.ne']\n        _ = r := by simp\n    let a := Îµ / (Îµ + â€–x - yâ€–)\n    let b := â€–x - yâ€– / (Îµ + â€–x - yâ€–)\n    have hab : a + b = 1 := by field_simp [a, b]\n    have hxyz : x = a â€¢ y + b â€¢ z := by\n      calc\n        x = a â€¢ x + b â€¢ x := by rw [Convex.combo_self hab]\n        _ = a â€¢ y + b â€¢ z := by simp [z, a, b, smul_smul, hxy.ne', smul_sub]; abel\n    rw [hK, mul_comm, â† mul_div_assoc, le_div_iffâ‚€' hÎµ]\n    calc\n      Îµ * (f x - f y) â‰¤ â€–x - yâ€– * (f z - f x) := by\n        rw [mul_sub, mul_sub, sub_le_sub_iff, â† add_mul]\n        have h := hf.2 hy' hz (by positivity) (by positivity) hab\n        rw [â† hxyz] at h\n        field_simp [a, b, â† mul_div_right_comm] at h\n        rwa [â† le_div_iffâ‚€' (by positivity), add_comm (_ * _)]\n      _ â‰¤ _ := by\n        rw [sub_eq_add_neg (f _), two_mul]\n        gcongr\n        Â· exact (le_abs_self _).trans <| hM _ hz\n        Â· exact (neg_le_abs _).trans <| hM _ hx'\n  refine .of_dist_le' fun x hx y hy â†¦ ?_\n  simp_rw [dist_eq_norm_sub, Real.norm_eq_abs, abs_sub_le_iff]\n  exact âŸ¨oneside hx hy, norm_sub_rev x _ â–¸ oneside hy hxâŸ©\n\n"}
{"name":"ConcaveOn.lipschitzOnWith_of_abs_le","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : E â†’ Real\nxâ‚€ : E\nÎµ r M : Real\nhf : ConcaveOn Real (Metric.ball xâ‚€ r) f\nhÎµ : LT.lt 0 Îµ\nhM : âˆ€ (a : E), LT.lt (Dist.dist a xâ‚€) r â†’ LE.le (abs (f a)) M\nâŠ¢ LipschitzOnWith (HDiv.hDiv (HMul.hMul 2 M) Îµ).toNNReal f (Metric.ball xâ‚€ (HSub.hSub r Îµ))","decl":"lemma ConcaveOn.lipschitzOnWith_of_abs_le (hf : ConcaveOn â„ (ball xâ‚€ r) f) (hÎµ : 0 < Îµ)\n    (hM : âˆ€ a, dist a xâ‚€ < r â†’ |f a| â‰¤ M) :\n    LipschitzOnWith (2 * M / Îµ).toNNReal f (ball xâ‚€ (r - Îµ)) := by\n  simpa using hf.neg.lipschitzOnWith_of_abs_le hÎµ <| by simpa using hM\n\n"}
{"name":"ConvexOn.exists_lipschitzOnWith_of_isBounded","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : E â†’ Real\nxâ‚€ : E\nr r' : Real\nhf : ConvexOn Real (Metric.ball xâ‚€ r) f\nhr : LT.lt r' r\nhf' : Bornology.IsBounded (Set.image f (Metric.ball xâ‚€ r))\nâŠ¢ Exists fun K => LipschitzOnWith K f (Metric.ball xâ‚€ r')","decl":"lemma ConvexOn.exists_lipschitzOnWith_of_isBounded (hf : ConvexOn â„ (ball xâ‚€ r) f) (hr : r' < r)\n    (hf' : IsBounded (f '' ball xâ‚€ r)) : âˆƒ K, LipschitzOnWith K f (ball xâ‚€ r') := by\n  rw [isBounded_iff_subset_ball 0] at hf'\n  simp only [Set.subset_def, mem_image, mem_ball, dist_zero_right, Real.norm_eq_abs,\n    forall_exists_index, and_imp, forall_apply_eq_imp_iffâ‚‚] at hf'\n  obtain âŸ¨M, hMâŸ© := hf'\n  rw [â† sub_sub_cancel r r']\n  exact âŸ¨_, hf.lipschitzOnWith_of_abs_le (sub_pos.2 hr) fun a ha â†¦ (hM a ha).leâŸ©\n\n"}
{"name":"ConcaveOn.exists_lipschitzOnWith_of_isBounded","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : E â†’ Real\nxâ‚€ : E\nr r' : Real\nhf : ConcaveOn Real (Metric.ball xâ‚€ r) f\nhr : LT.lt r' r\nhf' : Bornology.IsBounded (Set.image f (Metric.ball xâ‚€ r))\nâŠ¢ Exists fun K => LipschitzOnWith K f (Metric.ball xâ‚€ r')","decl":"lemma ConcaveOn.exists_lipschitzOnWith_of_isBounded (hf : ConcaveOn â„ (ball xâ‚€ r) f) (hr : r' < r)\n    (hf' : IsBounded (f '' ball xâ‚€ r)) : âˆƒ K, LipschitzOnWith K f (ball xâ‚€ r') := by\n  replace hf' : IsBounded ((-f) '' ball xâ‚€ r) := by convert hf'.neg; ext; simp [neg_eq_iff_eq_neg]\n  simpa using hf.neg.exists_lipschitzOnWith_of_isBounded hr hf'\n\n"}
{"name":"ConvexOn.isBoundedUnder_abs","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nC : Set E\nf : E â†’ Real\nhf : ConvexOn Real C f\nxâ‚€ : E\nhC : Membership.mem (nhds xâ‚€) C\nâŠ¢ Iff (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) (nhds xâ‚€) (abs f)) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) (nhds xâ‚€) f)","decl":"lemma ConvexOn.isBoundedUnder_abs (hf : ConvexOn â„ C f) {xâ‚€ : E} (hC : C âˆˆ ğ“ xâ‚€) :\n    (ğ“ xâ‚€).IsBoundedUnder (Â· â‰¤ Â·) |f| â†” (ğ“ xâ‚€).IsBoundedUnder (Â· â‰¤ Â·) f := by\n  refine âŸ¨fun h â†¦ h.mono_le <| .of_forall fun x â†¦ le_abs_self _, ?_âŸ©\n  rintro âŸ¨r, hrâŸ©\n  refine âŸ¨|r| + 2 * |f xâ‚€|, ?_âŸ©\n  have : (ğ“ xâ‚€).Tendsto (fun y => 2 â€¢ xâ‚€ - y) (ğ“ xâ‚€) :=\n    tendsto_nhds_nhds.2 (âŸ¨Â·, Â·, by simp [two_nsmul, dist_comm]âŸ©)\n  simp only [Filter.eventually_map, Pi.abs_apply, abs_le'] at hr âŠ¢\n  filter_upwards [this.eventually_mem hC, hC, hr, this.eventually hr] with y hx hx' hfr hfr'\n  refine âŸ¨hfr.trans <| (le_abs_self _).trans <| by simp, ?_âŸ©\n  rw [â† sub_le_iff_le_add, neg_sub_comm, sub_le_iff_le_add', â† abs_two, â† abs_mul]\n  calc\n    -|2 * f xâ‚€| â‰¤ 2 * f xâ‚€ := neg_abs_le _\n    _ â‰¤ f y + f (2 â€¢ xâ‚€ - y) := by\n      have := hf.2 hx' hx (by positivity) (by positivity) (add_halves _)\n      simp only [one_div, â† Nat.cast_smul_eq_nsmul â„, Nat.cast_ofNat, smul_sub, ne_eq,\n        OfNat.ofNat_ne_zero, not_false_eq_true, inv_smul_smulâ‚€, add_sub_cancel, smul_eq_mul] at this\n      cancel_denoms at this\n      rwa [â† Nat.cast_two, Nat.cast_smul_eq_nsmul] at this\n    _ â‰¤ f y + |r| := by gcongr; exact hfr'.trans (le_abs_self _)\n\n"}
{"name":"ConcaveOn.isBoundedUnder_abs","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nC : Set E\nf : E â†’ Real\nhf : ConcaveOn Real C f\nxâ‚€ : E\nhC : Membership.mem (nhds xâ‚€) C\nâŠ¢ Iff (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) (nhds xâ‚€) (abs f)) (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) (nhds xâ‚€) f)","decl":"lemma ConcaveOn.isBoundedUnder_abs (hf : ConcaveOn â„ C f) {xâ‚€ : E} (hC : C âˆˆ ğ“ xâ‚€) :\n    (ğ“ xâ‚€).IsBoundedUnder (Â· â‰¤ Â·) |f| â†” (ğ“ xâ‚€).IsBoundedUnder (Â· â‰¥ Â·) f := by\n  simpa [Pi.neg_def, Pi.abs_def] using hf.neg.isBoundedUnder_abs hC\n\n"}
{"name":"ConvexOn.continuousOn_tfae","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nC : Set E\nf : E â†’ Real\nhC : IsOpen C\nhC' : C.Nonempty\nhf : ConvexOn Real C f\nâŠ¢ (List.cons (LocallyLipschitzOn C f) (List.cons (ContinuousOn f C) (List.cons (Exists fun xâ‚€ => And (Membership.mem C xâ‚€) (ContinuousAt f xâ‚€)) (List.cons (Exists fun xâ‚€ => And (Membership.mem C xâ‚€) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) (nhds xâ‚€) f)) (List.cons (âˆ€ â¦ƒxâ‚€ : Eâ¦„, Membership.mem C xâ‚€ â†’ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) (nhds xâ‚€) f) (List.cons (âˆ€ â¦ƒxâ‚€ : Eâ¦„, Membership.mem C xâ‚€ â†’ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) (nhds xâ‚€) (abs f)) List.nil)))))).TFAE","decl":"lemma ConvexOn.continuousOn_tfae (hC : IsOpen C) (hC' : C.Nonempty) (hf : ConvexOn â„ C f) : TFAE [\n    LocallyLipschitzOn C f,\n    ContinuousOn f C,\n    âˆƒ xâ‚€ âˆˆ C, ContinuousAt f xâ‚€,\n    âˆƒ xâ‚€ âˆˆ C, (ğ“ xâ‚€).IsBoundedUnder (Â· â‰¤ Â·) f,\n    âˆ€ â¦ƒxâ‚€â¦„, xâ‚€ âˆˆ C â†’ (ğ“ xâ‚€).IsBoundedUnder (Â· â‰¤ Â·) f,\n    âˆ€ â¦ƒxâ‚€â¦„, xâ‚€ âˆˆ C â†’ (ğ“ xâ‚€).IsBoundedUnder (Â· â‰¤ Â·) |f|] := by\n  tfae_have 1 â†’ 2 := LocallyLipschitzOn.continuousOn\n  tfae_have 2 â†’ 3 := by\n    obtain âŸ¨xâ‚€, hxâ‚€âŸ© := hC'\n    exact fun h â†¦ âŸ¨xâ‚€, hxâ‚€, h.continuousAt <| hC.mem_nhds hxâ‚€âŸ©\n  tfae_have 3 â†’ 4\n  | âŸ¨xâ‚€, hxâ‚€, hâŸ© =>\n    âŸ¨xâ‚€, hxâ‚€, f xâ‚€ + 1, by simpa using h.eventually (eventually_le_nhds (by simp))âŸ©\n  tfae_have 4 â†’ 5\n  | âŸ¨xâ‚€, hxâ‚€, r, hrâŸ©, x, hx => by\n    have : âˆ€á¶  Î´ in ğ“ (0 : â„), (1 - Î´)â»Â¹ â€¢ x - (Î´ / (1 - Î´)) â€¢ xâ‚€ âˆˆ C := by\n      have h : ContinuousAt (fun Î´ : â„ â†¦ (1 - Î´)â»Â¹ â€¢ x - (Î´ / (1 - Î´)) â€¢ xâ‚€) 0 := by\n        fun_prop (disch := norm_num)\n      exact h (by simpa using hC.mem_nhds hx)\n    obtain âŸ¨Î´, hÎ´â‚€, hy, hÎ´â‚âŸ© := (this.and <| eventually_lt_nhds zero_lt_one).exists_gt\n    set y := (1 - Î´)â»Â¹ â€¢ x - (Î´ / (1 - Î´)) â€¢ xâ‚€\n    refine âŸ¨max r (f y), ?_âŸ©\n    simp only [Filter.eventually_map, Pi.abs_apply] at hr âŠ¢\n    obtain âŸ¨Îµ, hÎµ, hrâŸ© := Metric.eventually_nhds_iff.1 <| hr.and (hC.eventually_mem hxâ‚€)\n    refine Metric.eventually_nhds_iff.2 âŸ¨Îµ * Î´, by positivity, fun z hz â†¦ ?_âŸ©\n    have hxâ‚€' : Î´â»Â¹ â€¢ (x - y) + y = xâ‚€ := MulAction.injectiveâ‚€ (sub_ne_zero.2 hÎ´â‚.ne') <| by\n      simp [y, smul_sub, smul_smul, hÎ´â‚€.ne', div_eq_mul_inv, sub_ne_zero.2 hÎ´â‚.ne', mul_left_comm,\n        sub_mul, sub_smul]\n    let w := Î´â»Â¹ â€¢ (z - y) + y\n    have hwyz : Î´ â€¢ w + (1 - Î´) â€¢ y = z := by simp [w, hÎ´â‚€.ne', sub_smul]\n    have hw : dist w xâ‚€ < Îµ := by\n      simpa [w, â† hxâ‚€', dist_smulâ‚€, abs_of_nonneg, hÎ´â‚€.le, inv_mul_lt_iffâ‚€', hÎ´â‚€]\n    calc\n      f z â‰¤ max (f w) (f y) :=\n        hf.le_max_of_mem_segment (hr hw).2 hy âŸ¨_, _, hÎ´â‚€.le, sub_nonneg.2 hÎ´â‚.le, by simp, hwyzâŸ©\n      _ â‰¤ max r (f y) := by gcongr; exact (hr hw).1\n  tfae_have 6 â†” 5 := forallâ‚‚_congr fun xâ‚€ hxâ‚€ â†¦ hf.isBoundedUnder_abs (hC.mem_nhds hxâ‚€)\n  tfae_have 6 â†’ 1\n  | h, x, hx => by\n    obtain âŸ¨r, hrâŸ© := h hx\n    obtain âŸ¨Îµ, hÎµ, hÎµDâŸ© := Metric.mem_nhds_iff.1 <| Filter.inter_mem (hC.mem_nhds hx) hr\n    simp only [preimage_setOf_eq, Pi.abs_apply, subset_inter_iff, hC.nhdsWithin_eq hx] at hÎµD âŠ¢\n    obtain âŸ¨K, hKâŸ© := exists_lipschitzOnWith_of_isBounded (hf.subset hÎµD.1 (convex_ball ..))\n      (half_lt_self hÎµ) <| isBounded_iff_forall_norm_le.2 âŸ¨r, by simpa using hÎµD.2âŸ©\n    exact âŸ¨K, _, ball_mem_nhds _ (by simpa), hKâŸ©\n  tfae_finish\n\n"}
{"name":"ConcaveOn.continuousOn_tfae","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nC : Set E\nf : E â†’ Real\nhC : IsOpen C\nhC' : C.Nonempty\nhf : ConcaveOn Real C f\nâŠ¢ (List.cons (LocallyLipschitzOn C f) (List.cons (ContinuousOn f C) (List.cons (Exists fun xâ‚€ => And (Membership.mem C xâ‚€) (ContinuousAt f xâ‚€)) (List.cons (Exists fun xâ‚€ => And (Membership.mem C xâ‚€) (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) (nhds xâ‚€) f)) (List.cons (âˆ€ â¦ƒxâ‚€ : Eâ¦„, Membership.mem C xâ‚€ â†’ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) (nhds xâ‚€) f) (List.cons (âˆ€ â¦ƒxâ‚€ : Eâ¦„, Membership.mem C xâ‚€ â†’ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) (nhds xâ‚€) (abs f)) List.nil)))))).TFAE","decl":"lemma ConcaveOn.continuousOn_tfae (hC : IsOpen C) (hC' : C.Nonempty) (hf : ConcaveOn â„ C f) : TFAE [\n    LocallyLipschitzOn C f,\n    ContinuousOn f C,\n    âˆƒ xâ‚€ âˆˆ C, ContinuousAt f xâ‚€,\n    âˆƒ xâ‚€ âˆˆ C, (ğ“ xâ‚€).IsBoundedUnder (Â· â‰¥ Â·) f,\n    âˆ€ â¦ƒxâ‚€â¦„, xâ‚€ âˆˆ C â†’ (ğ“ xâ‚€).IsBoundedUnder (Â· â‰¥ Â·) f,\n    âˆ€ â¦ƒxâ‚€â¦„, xâ‚€ âˆˆ C â†’ (ğ“ xâ‚€).IsBoundedUnder (Â· â‰¤ Â·) |f|] := by\n  have := hf.neg.continuousOn_tfae hC hC'\n  simp only [locallyLipschitzOn_neg_iff, continuousOn_neg_iff, continuousAt_neg_iff, abs_neg]\n    at this\n  convert this using 8 <;> exact (Equiv.neg â„).exists_congr (by simp)\n\n"}
{"name":"ConvexOn.locallyLipschitzOn_iff_continuousOn","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nC : Set E\nf : E â†’ Real\nhC : IsOpen C\nhf : ConvexOn Real C f\nâŠ¢ Iff (LocallyLipschitzOn C f) (ContinuousOn f C)","decl":"lemma ConvexOn.locallyLipschitzOn_iff_continuousOn (hC : IsOpen C) (hf : ConvexOn â„ C f) :\n    LocallyLipschitzOn C f â†” ContinuousOn f C := by\n  obtain rfl | hC' := C.eq_empty_or_nonempty\n  Â· simp\n  Â· exact (hf.continuousOn_tfae hC hC').out 0 1\n\n"}
{"name":"ConcaveOn.locallyLipschitzOn_iff_continuousOn","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nC : Set E\nf : E â†’ Real\nhC : IsOpen C\nhf : ConcaveOn Real C f\nâŠ¢ Iff (LocallyLipschitzOn C f) (ContinuousOn f C)","decl":"lemma ConcaveOn.locallyLipschitzOn_iff_continuousOn (hC : IsOpen C) (hf : ConcaveOn â„ C f) :\n    LocallyLipschitzOn C f â†” ContinuousOn f C := by\n  simpa using hf.neg.locallyLipschitzOn_iff_continuousOn hC\n\n"}
{"name":"ConvexOn.locallyLipschitzOn","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nC : Set E\nf : E â†’ Real\ninstâœ : FiniteDimensional Real E\nhC : IsOpen C\nhf : ConvexOn Real C f\nâŠ¢ LocallyLipschitzOn C f","decl":"protected lemma ConvexOn.locallyLipschitzOn (hC : IsOpen C) (hf : ConvexOn â„ C f) :\n    LocallyLipschitzOn C f := by\n  obtain rfl | âŸ¨xâ‚€, hxâ‚€âŸ© := C.eq_empty_or_nonempty\n  Â· simp\n  Â· obtain âŸ¨b, hxâ‚€b, hbCâŸ© := exists_mem_interior_convexHull_affineBasis (hC.mem_nhds hxâ‚€)\n    refine ((hf.continuousOn_tfae hC âŸ¨xâ‚€, hxâ‚€âŸ©).out 3 0).mp ?_\n    refine âŸ¨xâ‚€, hxâ‚€, BddAbove.isBoundedUnder (IsOpen.mem_nhds isOpen_interior hxâ‚€b) ?_âŸ©\n    exact (hf.bddAbove_convexHull ((subset_convexHull ..).trans hbC)\n      ((finite_range _).image _).bddAbove).mono (by gcongr; exact interior_subset)\n\n"}
{"name":"ConcaveOn.locallyLipschitzOn","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nC : Set E\nf : E â†’ Real\ninstâœ : FiniteDimensional Real E\nhC : IsOpen C\nhf : ConcaveOn Real C f\nâŠ¢ LocallyLipschitzOn C f","decl":"protected lemma ConcaveOn.locallyLipschitzOn (hC : IsOpen C) (hf : ConcaveOn â„ C f) :\n    LocallyLipschitzOn C f := by simpa using hf.neg.locallyLipschitzOn hC\n\n"}
{"name":"ConvexOn.continuousOn","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nC : Set E\nf : E â†’ Real\ninstâœ : FiniteDimensional Real E\nhC : IsOpen C\nhf : ConvexOn Real C f\nâŠ¢ ContinuousOn f C","decl":"protected lemma ConvexOn.continuousOn (hC : IsOpen C) (hf : ConvexOn â„ C f) :\n    ContinuousOn f C := (hf.locallyLipschitzOn hC).continuousOn\n\n"}
{"name":"ConcaveOn.continuousOn","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nC : Set E\nf : E â†’ Real\ninstâœ : FiniteDimensional Real E\nhC : IsOpen C\nhf : ConcaveOn Real C f\nâŠ¢ ContinuousOn f C","decl":"protected lemma ConcaveOn.continuousOn (hC : IsOpen C) (hf : ConcaveOn â„ C f) :\n    ContinuousOn f C := (hf.locallyLipschitzOn hC).continuousOn\n\n"}
{"name":"ConvexOn.locallyLipschitzOn_interior","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nC : Set E\nf : E â†’ Real\ninstâœ : FiniteDimensional Real E\nhf : ConvexOn Real C f\nâŠ¢ LocallyLipschitzOn (interior C) f","decl":"lemma ConvexOn.locallyLipschitzOn_interior (hf : ConvexOn â„ C f) :\n    LocallyLipschitzOn (interior C) f :=\n  (hf.subset interior_subset hf.1.interior).locallyLipschitzOn isOpen_interior\n\n"}
{"name":"ConcaveOn.locallyLipschitzOn_interior","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nC : Set E\nf : E â†’ Real\ninstâœ : FiniteDimensional Real E\nhf : ConcaveOn Real C f\nâŠ¢ LocallyLipschitzOn (interior C) f","decl":"lemma ConcaveOn.locallyLipschitzOn_interior (hf : ConcaveOn â„ C f) :\n    LocallyLipschitzOn (interior C) f :=\n  (hf.subset interior_subset hf.1.interior).locallyLipschitzOn isOpen_interior\n\n"}
{"name":"ConvexOn.continuousOn_interior","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nC : Set E\nf : E â†’ Real\ninstâœ : FiniteDimensional Real E\nhf : ConvexOn Real C f\nâŠ¢ ContinuousOn f (interior C)","decl":"lemma ConvexOn.continuousOn_interior (hf : ConvexOn â„ C f) : ContinuousOn f (interior C) :=\n  hf.locallyLipschitzOn_interior.continuousOn\n\n"}
{"name":"ConcaveOn.continuousOn_interior","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nC : Set E\nf : E â†’ Real\ninstâœ : FiniteDimensional Real E\nhf : ConcaveOn Real C f\nâŠ¢ ContinuousOn f (interior C)","decl":"lemma ConcaveOn.continuousOn_interior (hf : ConcaveOn â„ C f) : ContinuousOn f (interior C) :=\n  hf.locallyLipschitzOn_interior.continuousOn\n\n"}
{"name":"ConvexOn.locallyLipschitz","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nf : E â†’ Real\ninstâœ : FiniteDimensional Real E\nhf : ConvexOn Real Set.univ f\nâŠ¢ LocallyLipschitz f","decl":"protected lemma ConvexOn.locallyLipschitz (hf : ConvexOn â„ univ f) : LocallyLipschitz f := by\n  simpa using hf.locallyLipschitzOn_interior\n\n"}
{"name":"ConcaveOn.locallyLipschitz","module":"Mathlib.Analysis.Convex.Continuous","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nf : E â†’ Real\ninstâœ : FiniteDimensional Real E\nhf : ConcaveOn Real Set.univ f\nâŠ¢ LocallyLipschitz f","decl":"protected lemma ConcaveOn.locallyLipschitz (hf : ConcaveOn â„ univ f) : LocallyLipschitz f := by\n  simpa using hf.locallyLipschitzOn_interior\n\n-- Commented out since `intrinsicInterior` is not imported (but should be once these are proved)\n-- proof_wanted ConvexOn.locallyLipschitzOn_intrinsicInterior (hf : ConvexOn â„ C f) :\n--     ContinuousOn f (intrinsicInterior â„ C)\n\n-- proof_wanted ConcaveOn.locallyLipschitzOn_intrinsicInterior (hf : ConcaveOn â„ C f) :\n--     ContinuousOn f (intrinsicInterior â„ C)\n\n-- proof_wanted ConvexOn.continuousOn_intrinsicInterior (hf : ConvexOn â„ C f) :\n--     ContinuousOn f (intrinsicInterior â„ C)\n\n-- proof_wanted ConcaveOn.continuousOn_intrinsicInterior (hf : ConcaveOn â„ C f) :\n--     ContinuousOn f (intrinsicInterior â„ C)\n"}
