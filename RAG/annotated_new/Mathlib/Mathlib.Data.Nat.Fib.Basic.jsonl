{"name":"Nat.fib_zero","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"⊢ Eq (Nat.fib 0) 0","decl":"@[simp]\ntheorem fib_zero : fib 0 = 0 :=\n  rfl\n\n"}
{"name":"Nat.fib_one","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"⊢ Eq (Nat.fib 1) 1","decl":"@[simp]\ntheorem fib_one : fib 1 = 1 :=\n  rfl\n\n"}
{"name":"Nat.fib_two","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"⊢ Eq (Nat.fib 2) 1","decl":"@[simp]\ntheorem fib_two : fib 2 = 1 :=\n  rfl\n\n"}
{"name":"Nat.fib_add_two","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"n : Nat\n⊢ Eq (Nat.fib (HAdd.hAdd n 2)) (HAdd.hAdd (Nat.fib n) (Nat.fib (HAdd.hAdd n 1)))","decl":"/-- Shows that `fib` indeed satisfies the Fibonacci recurrence `Fₙ₊₂ = Fₙ + Fₙ₊₁.` -/\ntheorem fib_add_two {n : ℕ} : fib (n + 2) = fib n + fib (n + 1) := by\n  simp [fib, Function.iterate_succ_apply']\n\n"}
{"name":"Nat.fib_add_one","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"n : Nat\na✝ : Ne n 0\n⊢ Eq (Nat.fib (HAdd.hAdd n 1)) (HAdd.hAdd (Nat.fib (HSub.hSub n 1)) (Nat.fib n))","decl":"lemma fib_add_one : ∀ {n}, n ≠ 0 → fib (n + 1) = fib (n - 1) + fib n\n  | _n + 1, _ => fib_add_two\n\n"}
{"name":"Nat.fib_le_fib_succ","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"n : Nat\n⊢ LE.le (Nat.fib n) (Nat.fib (HAdd.hAdd n 1))","decl":"theorem fib_le_fib_succ {n : ℕ} : fib n ≤ fib (n + 1) := by cases n <;> simp [fib_add_two]\n\n"}
{"name":"Nat.fib_mono","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"⊢ Monotone Nat.fib","decl":"@[mono]\ntheorem fib_mono : Monotone fib :=\n  monotone_nat_of_le_succ fun _ => fib_le_fib_succ\n\n"}
{"name":"Nat.fib_eq_zero","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"n : Nat\n⊢ Iff (Eq (Nat.fib n) 0) (Eq n 0)","decl":"@[simp] lemma fib_eq_zero : ∀ {n}, fib n = 0 ↔ n = 0\n| 0 => Iff.rfl\n| 1 => Iff.rfl\n| n + 2 => by simp [fib_add_two, fib_eq_zero]\n\n"}
{"name":"Nat.fib_pos","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"n : Nat\n⊢ Iff (LT.lt 0 (Nat.fib n)) (LT.lt 0 n)","decl":"@[simp] lemma fib_pos {n : ℕ} : 0 < fib n ↔ 0 < n := by simp [pos_iff_ne_zero]\n\n"}
{"name":"Nat.fib_add_two_sub_fib_add_one","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"n : Nat\n⊢ Eq (HSub.hSub (Nat.fib (HAdd.hAdd n 2)) (Nat.fib (HAdd.hAdd n 1))) (Nat.fib n)","decl":"theorem fib_add_two_sub_fib_add_one {n : ℕ} : fib (n + 2) - fib (n + 1) = fib n := by\n  rw [fib_add_two, add_tsub_cancel_right]\n\n"}
{"name":"Nat.fib_lt_fib_succ","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"n : Nat\nhn : LE.le 2 n\n⊢ LT.lt (Nat.fib n) (Nat.fib (HAdd.hAdd n 1))","decl":"theorem fib_lt_fib_succ {n : ℕ} (hn : 2 ≤ n) : fib n < fib (n + 1) := by\n  rcases exists_add_of_le hn with ⟨n, rfl⟩\n  rw [← tsub_pos_iff_lt, add_comm 2, add_right_comm, fib_add_two, add_tsub_cancel_right, fib_pos]\n  exact succ_pos n\n\n"}
{"name":"Nat.fib_add_two_strictMono","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"⊢ StrictMono fun n => Nat.fib (HAdd.hAdd n 2)","decl":"/-- `fib (n + 2)` is strictly monotone. -/\ntheorem fib_add_two_strictMono : StrictMono fun n => fib (n + 2) := by\n  refine strictMono_nat_of_lt_succ fun n => ?_\n  rw [add_right_comm]\n  exact fib_lt_fib_succ (self_le_add_left _ _)\n\n"}
{"name":"Nat.fib_strictMonoOn","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"⊢ StrictMonoOn Nat.fib (Set.Ici 2)","decl":"lemma fib_strictMonoOn : StrictMonoOn fib (Set.Ici 2)\n  | _m + 2, _, _n + 2, _, hmn => fib_add_two_strictMono <| lt_of_add_lt_add_right hmn\n\n"}
{"name":"Nat.fib_lt_fib","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"m : Nat\nhm : LE.le 2 m\nn : Nat\n⊢ Iff (LT.lt (Nat.fib m) (Nat.fib n)) (LT.lt m n)","decl":"lemma fib_lt_fib {m : ℕ} (hm : 2 ≤ m) : ∀ {n}, fib m < fib n ↔ m < n\n  | 0 => by simp [hm]\n  | 1 => by simp [hm]\n  | n + 2 => fib_strictMonoOn.lt_iff_lt hm <| by simp\n\n"}
{"name":"Nat.le_fib_self","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"n : Nat\nfive_le_n : LE.le 5 n\n⊢ LE.le n (Nat.fib n)","decl":"theorem le_fib_self {n : ℕ} (five_le_n : 5 ≤ n) : n ≤ fib n := by\n  induction' five_le_n with n five_le_n IH\n  · -- 5 ≤ fib 5\n    rfl\n  · -- n + 1 ≤ fib (n + 1) for 5 ≤ n\n    rw [succ_le_iff]\n    calc\n      n ≤ fib n := IH\n      _ < fib (n + 1) := fib_lt_fib_succ (le_trans (by decide) five_le_n)\n\n"}
{"name":"Nat.le_fib_add_one","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"n : Nat\n⊢ LE.le n (HAdd.hAdd (Nat.fib n) 1)","decl":"lemma le_fib_add_one : ∀ n, n ≤ fib n + 1\n  | 0 => zero_le_one\n  | 1 => one_le_two\n  | 2 => le_rfl\n  | 3 => le_rfl\n  | 4 => le_rfl\n  | _n + 5 => (le_fib_self le_add_self).trans <| le_succ _\n\n"}
{"name":"Nat.fib_coprime_fib_succ","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"n : Nat\n⊢ (Nat.fib n).Coprime (Nat.fib (HAdd.hAdd n 1))","decl":"/-- Subsequent Fibonacci numbers are coprime,\n  see https://proofwiki.org/wiki/Consecutive_Fibonacci_Numbers_are_Coprime -/\ntheorem fib_coprime_fib_succ (n : ℕ) : Nat.Coprime (fib n) (fib (n + 1)) := by\n  induction' n with n ih\n  · simp\n  · simp only [fib_add_two, coprime_add_self_right, Coprime, ih.symm]\n\n"}
{"name":"Nat.fib_add","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"m n : Nat\n⊢ Eq (Nat.fib (HAdd.hAdd (HAdd.hAdd m n) 1)) (HAdd.hAdd (HMul.hMul (Nat.fib m) (Nat.fib n)) (HMul.hMul (Nat.fib (HAdd.hAdd m 1)) (Nat.fib (HAdd.hAdd n 1))))","decl":"/-- See https://proofwiki.org/wiki/Fibonacci_Number_in_terms_of_Smaller_Fibonacci_Numbers -/\ntheorem fib_add (m n : ℕ) : fib (m + n + 1) = fib m * fib n + fib (m + 1) * fib (n + 1) := by\n  induction' n with n ih generalizing m\n  · simp\n  · specialize ih (m + 1)\n    rw [add_assoc m 1 n, add_comm 1 n] at ih\n    simp only [fib_add_two, succ_eq_add_one, ih]\n    ring\n\n"}
{"name":"Nat.fib_two_mul","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"n : Nat\n⊢ Eq (Nat.fib (HMul.hMul 2 n)) (HMul.hMul (Nat.fib n) (HSub.hSub (HMul.hMul 2 (Nat.fib (HAdd.hAdd n 1))) (Nat.fib n)))","decl":"theorem fib_two_mul (n : ℕ) : fib (2 * n) = fib n * (2 * fib (n + 1) - fib n) := by\n  cases n\n  · simp\n  · rw [two_mul, ← add_assoc, fib_add, fib_add_two, two_mul]\n    simp only [← add_assoc, add_tsub_cancel_right]\n    ring\n\n"}
{"name":"Nat.fib_two_mul_add_one","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"n : Nat\n⊢ Eq (Nat.fib (HAdd.hAdd (HMul.hMul 2 n) 1)) (HAdd.hAdd (HPow.hPow (Nat.fib (HAdd.hAdd n 1)) 2) (HPow.hPow (Nat.fib n) 2))","decl":"theorem fib_two_mul_add_one (n : ℕ) : fib (2 * n + 1) = fib (n + 1) ^ 2 + fib n ^ 2 := by\n  rw [two_mul, fib_add]\n  ring\n\n"}
{"name":"Nat.fib_two_mul_add_two","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"n : Nat\n⊢ Eq (Nat.fib (HAdd.hAdd (HMul.hMul 2 n) 2)) (HMul.hMul (Nat.fib (HAdd.hAdd n 1)) (HAdd.hAdd (HMul.hMul 2 (Nat.fib n)) (Nat.fib (HAdd.hAdd n 1))))","decl":"theorem fib_two_mul_add_two (n : ℕ) :\n    fib (2 * n + 2) = fib (n + 1) * (2 * fib n + fib (n + 1)) := by\n  rw [fib_add_two, fib_two_mul, fib_two_mul_add_one]\n  -- Porting note: A bunch of issues similar to [this zulip thread](https://github.com/leanprover-community/mathlib4/pull/1576) with `zify`\n  have : fib n ≤ 2 * fib (n + 1) :=\n    le_trans fib_le_fib_succ (mul_comm 2 _ ▸ Nat.le_mul_of_pos_right _ two_pos)\n  zify [this]\n  ring\n\n"}
{"name":"Nat.fast_fib_aux_bit_ff","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"n : Nat\n⊢ Eq (Nat.bit Bool.false n).fastFibAux\n    (let p := n.fastFibAux;\n    { fst := HMul.hMul p.1 (HSub.hSub (HMul.hMul 2 p.2) p.1), snd := HAdd.hAdd (HPow.hPow p.2 2) (HPow.hPow p.1 2) })","decl":"theorem fast_fib_aux_bit_ff (n : ℕ) :\n    fastFibAux (bit false n) =\n      let p := fastFibAux n\n      (p.1 * (2 * p.2 - p.1), p.2 ^ 2 + p.1 ^ 2) := by\n  rw [fastFibAux, binaryRec_eq]\n  · rfl\n  · simp\n\n"}
{"name":"Nat.fast_fib_aux_bit_tt","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"n : Nat\n⊢ Eq (Nat.bit Bool.true n).fastFibAux\n    (let p := n.fastFibAux;\n    { fst := HAdd.hAdd (HPow.hPow p.2 2) (HPow.hPow p.1 2), snd := HMul.hMul p.2 (HAdd.hAdd (HMul.hMul 2 p.1) p.2) })","decl":"theorem fast_fib_aux_bit_tt (n : ℕ) :\n    fastFibAux (bit true n) =\n      let p := fastFibAux n\n      (p.2 ^ 2 + p.1 ^ 2, p.2 * (2 * p.1 + p.2)) := by\n  rw [fastFibAux, binaryRec_eq]\n  · rfl\n  · simp\n\n"}
{"name":"Nat.fast_fib_aux_eq","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"n : Nat\n⊢ Eq n.fastFibAux { fst := Nat.fib n, snd := Nat.fib (HAdd.hAdd n 1) }","decl":"theorem fast_fib_aux_eq (n : ℕ) : fastFibAux n = (fib n, fib (n + 1)) := by\n  refine Nat.binaryRec ?_ ?_ n\n  · simp [fastFibAux]\n  · rintro (_|_) n' ih <;>\n      simp only [fast_fib_aux_bit_ff, fast_fib_aux_bit_tt, congr_arg Prod.fst ih,\n        congr_arg Prod.snd ih, Prod.mk.inj_iff] <;>\n      simp [bit, fib_two_mul, fib_two_mul_add_one, fib_two_mul_add_two]\n\n"}
{"name":"Nat.fast_fib_eq","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"n : Nat\n⊢ Eq n.fastFib (Nat.fib n)","decl":"theorem fast_fib_eq (n : ℕ) : fastFib n = fib n := by rw [fastFib, fast_fib_aux_eq]\n\n"}
{"name":"Nat.gcd_fib_add_self","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"m n : Nat\n⊢ Eq ((Nat.fib m).gcd (Nat.fib (HAdd.hAdd n m))) ((Nat.fib m).gcd (Nat.fib n))","decl":"theorem gcd_fib_add_self (m n : ℕ) : gcd (fib m) (fib (n + m)) = gcd (fib m) (fib n) := by\n  rcases Nat.eq_zero_or_pos n with rfl | h\n  · simp\n  replace h := Nat.succ_pred_eq_of_pos h; rw [← h, succ_eq_add_one]\n  calc\n    gcd (fib m) (fib (n.pred + 1 + m)) =\n        gcd (fib m) (fib n.pred * fib m + fib (n.pred + 1) * fib (m + 1)) := by\n        rw [← fib_add n.pred _]\n        ring_nf\n    _ = gcd (fib m) (fib (n.pred + 1) * fib (m + 1)) := by\n        rw [add_comm, gcd_add_mul_right_right (fib m) _ (fib n.pred)]\n    _ = gcd (fib m) (fib (n.pred + 1)) :=\n      Coprime.gcd_mul_right_cancel_right (fib (n.pred + 1)) (Coprime.symm (fib_coprime_fib_succ m))\n\n"}
{"name":"Nat.gcd_fib_add_mul_self","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"m n k : Nat\n⊢ Eq ((Nat.fib m).gcd (Nat.fib (HAdd.hAdd n (HMul.hMul k m)))) ((Nat.fib m).gcd (Nat.fib n))","decl":"theorem gcd_fib_add_mul_self (m n : ℕ) : ∀ k, gcd (fib m) (fib (n + k * m)) = gcd (fib m) (fib n)\n  | 0 => by simp\n  | k + 1 => by\n    rw [← gcd_fib_add_mul_self m n k, add_mul, ← add_assoc, one_mul, gcd_fib_add_self _ _]\n\n"}
{"name":"Nat.fib_gcd","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"m n : Nat\n⊢ Eq (Nat.fib (m.gcd n)) ((Nat.fib m).gcd (Nat.fib n))","decl":"/-- `fib n` is a strong divisibility sequence,\n  see https://proofwiki.org/wiki/GCD_of_Fibonacci_Numbers -/\ntheorem fib_gcd (m n : ℕ) : fib (gcd m n) = gcd (fib m) (fib n) := by\n  induction m, n using Nat.gcd.induction with\n  | H0 => simp\n  | H1 m n _ h' =>\n    rw [← gcd_rec m n] at h'\n    conv_rhs => rw [← mod_add_div' n m]\n    rwa [gcd_fib_add_mul_self m (n % m) (n / m), gcd_comm (fib m) _]\n\n"}
{"name":"Nat.fib_dvd","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"m n : Nat\nh : Dvd.dvd m n\n⊢ Dvd.dvd (Nat.fib m) (Nat.fib n)","decl":"theorem fib_dvd (m n : ℕ) (h : m ∣ n) : fib m ∣ fib n := by\n  rwa [gcd_eq_left_iff_dvd, ← fib_gcd, gcd_eq_left_iff_dvd.mp]\n\n"}
{"name":"Nat.fib_succ_eq_sum_choose","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"n : Nat\n⊢ Eq (Nat.fib (HAdd.hAdd n 1)) ((Finset.HasAntidiagonal.antidiagonal n).sum fun p => p.1.choose p.2)","decl":"theorem fib_succ_eq_sum_choose :\n    ∀ n : ℕ, fib (n + 1) = ∑ p ∈ Finset.antidiagonal n, choose p.1 p.2 :=\n  twoStepInduction rfl rfl fun n h1 h2 => by\n    rw [fib_add_two, h1, h2, Finset.Nat.antidiagonal_succ_succ', Finset.Nat.antidiagonal_succ']\n    simp [choose_succ_succ, Finset.sum_add_distrib, add_left_comm]\n\n"}
{"name":"Nat.fib_succ_eq_succ_sum","module":"Mathlib.Data.Nat.Fib.Basic","initialProofState":"n : Nat\n⊢ Eq (Nat.fib (HAdd.hAdd n 1)) (HAdd.hAdd ((Finset.range n).sum fun k => Nat.fib k) 1)","decl":"theorem fib_succ_eq_succ_sum (n : ℕ) : fib (n + 1) = (∑ k ∈ Finset.range n, fib k) + 1 := by\n  induction' n with n ih\n  · simp\n  · calc\n      fib (n + 2) = fib n + fib (n + 1) := fib_add_two\n      _ = (fib n + ∑ k ∈ Finset.range n, fib k) + 1 := by rw [ih, add_assoc]\n      _ = (∑ k ∈ Finset.range (n + 1), fib k) + 1 := by simp [Finset.range_add_one]\n\n"}
