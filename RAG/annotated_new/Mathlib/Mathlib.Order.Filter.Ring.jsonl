{"name":"Filter.EventuallyLE.mul_le_mul","module":"Mathlib.Order.Filter.Ring","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : MulZeroClass β\ninst✝² : PartialOrder β\ninst✝¹ : PosMulMono β\ninst✝ : MulPosMono β\nl : Filter α\nf₁ f₂ g₁ g₂ : α → β\nhf : l.EventuallyLE f₁ f₂\nhg : l.EventuallyLE g₁ g₂\nhg₀ : l.EventuallyLE 0 g₁\nhf₀ : l.EventuallyLE 0 f₂\n⊢ l.EventuallyLE (HMul.hMul f₁ g₁) (HMul.hMul f₂ g₂)","decl":"theorem EventuallyLE.mul_le_mul [MulZeroClass β] [PartialOrder β] [PosMulMono β] [MulPosMono β]\n    {l : Filter α} {f₁ f₂ g₁ g₂ : α → β} (hf : f₁ ≤ᶠ[l] f₂) (hg : g₁ ≤ᶠ[l] g₂) (hg₀ : 0 ≤ᶠ[l] g₁)\n    (hf₀ : 0 ≤ᶠ[l] f₂) : f₁ * g₁ ≤ᶠ[l] f₂ * g₂ := by\n  filter_upwards [hf, hg, hg₀, hf₀] with x using _root_.mul_le_mul\n\n"}
{"name":"Filter.EventuallyLE.add_le_add","module":"Mathlib.Order.Filter.Ring","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : Add β\ninst✝² : Preorder β\ninst✝¹ : AddLeftMono β\ninst✝ : AddRightMono β\nl : Filter α\nf₁ f₂ g₁ g₂ : α → β\nhf : l.EventuallyLE f₁ f₂\nhg : l.EventuallyLE g₁ g₂\n⊢ l.EventuallyLE (HAdd.hAdd f₁ g₁) (HAdd.hAdd f₂ g₂)","decl":"@[to_additive EventuallyLE.add_le_add]\ntheorem EventuallyLE.mul_le_mul' [Mul β] [Preorder β] [MulLeftMono β]\n    [MulRightMono β] {l : Filter α} {f₁ f₂ g₁ g₂ : α → β}\n    (hf : f₁ ≤ᶠ[l] f₂) (hg : g₁ ≤ᶠ[l] g₂) : f₁ * g₁ ≤ᶠ[l] f₂ * g₂ := by\n  filter_upwards [hf, hg] with x hfx hgx using _root_.mul_le_mul' hfx hgx\n\n"}
{"name":"Filter.EventuallyLE.mul_le_mul'","module":"Mathlib.Order.Filter.Ring","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : Mul β\ninst✝² : Preorder β\ninst✝¹ : MulLeftMono β\ninst✝ : MulRightMono β\nl : Filter α\nf₁ f₂ g₁ g₂ : α → β\nhf : l.EventuallyLE f₁ f₂\nhg : l.EventuallyLE g₁ g₂\n⊢ l.EventuallyLE (HMul.hMul f₁ g₁) (HMul.hMul f₂ g₂)","decl":"@[to_additive EventuallyLE.add_le_add]\ntheorem EventuallyLE.mul_le_mul' [Mul β] [Preorder β] [MulLeftMono β]\n    [MulRightMono β] {l : Filter α} {f₁ f₂ g₁ g₂ : α → β}\n    (hf : f₁ ≤ᶠ[l] f₂) (hg : g₁ ≤ᶠ[l] g₂) : f₁ * g₁ ≤ᶠ[l] f₂ * g₂ := by\n  filter_upwards [hf, hg] with x hfx hgx using _root_.mul_le_mul' hfx hgx\n\n"}
{"name":"Filter.EventuallyLE.mul_nonneg","module":"Mathlib.Order.Filter.Ring","initialProofState":"α : Type u\nβ : Type v\ninst✝ : OrderedSemiring β\nl : Filter α\nf g : α → β\nhf : l.EventuallyLE 0 f\nhg : l.EventuallyLE 0 g\n⊢ l.EventuallyLE 0 (HMul.hMul f g)","decl":"theorem EventuallyLE.mul_nonneg [OrderedSemiring β] {l : Filter α} {f g : α → β} (hf : 0 ≤ᶠ[l] f)\n    (hg : 0 ≤ᶠ[l] g) : 0 ≤ᶠ[l] f * g := by filter_upwards [hf, hg] with x using _root_.mul_nonneg\n\n"}
{"name":"Filter.eventually_sub_nonneg","module":"Mathlib.Order.Filter.Ring","initialProofState":"α : Type u\nβ : Type v\ninst✝ : OrderedRing β\nl : Filter α\nf g : α → β\n⊢ Iff (l.EventuallyLE 0 (HSub.hSub g f)) (l.EventuallyLE f g)","decl":"theorem eventually_sub_nonneg [OrderedRing β] {l : Filter α} {f g : α → β} :\n    0 ≤ᶠ[l] g - f ↔ f ≤ᶠ[l] g :=\n  eventually_congr <| Eventually.of_forall fun _ => sub_nonneg\n\n"}
