{"name":"LightCondensed.ofSheafLightProfinite_val","module":"Mathlib.Condensed.Light.Explicit","initialProofState":"A : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} A\nF : CategoryTheory.Functor (Opposite LightProfinite) A\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts F\nhF : CategoryTheory.regularTopology.EqualizerCondition F\n⊢ Eq (LightCondensed.ofSheafLightProfinite F hF).val F","decl":"/--\nThe light condensed object associated to a presheaf on `LightProfinite` which preserves finite\nproducts and satisfies the equalizer condition.\n-/\n@[simps]\nnoncomputable def ofSheafLightProfinite (F : LightProfinite.{u}ᵒᵖ ⥤ A) [PreservesFiniteProducts F]\n    (hF : EqualizerCondition F) : LightCondensed A where\n  val := F\n  cond := by\n    rw [isSheaf_iff_preservesFiniteProducts_and_equalizerCondition F]\n    exact ⟨⟨fun _ _ ↦ inferInstance⟩, hF⟩\n\n"}
{"name":"LightCondensed.ofSheafForgetLightProfinite_val","module":"Mathlib.Condensed.Light.Explicit","initialProofState":"A : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} A\ninst✝² : CategoryTheory.HasForget A\ninst✝¹ : CategoryTheory.Limits.ReflectsFiniteLimits (CategoryTheory.forget A)\nF : CategoryTheory.Functor (Opposite LightProfinite) A\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts (F.comp (CategoryTheory.forget A))\nhF : CategoryTheory.regularTopology.EqualizerCondition (F.comp (CategoryTheory.forget A))\n⊢ Eq (LightCondensed.ofSheafForgetLightProfinite F hF).val F","decl":"/--\nThe light condensed object associated to a presheaf on `LightProfinite` whose postcomposition with\nthe forgetful functor preserves finite products and satisfies the equalizer condition.\n-/\n@[simps]\nnoncomputable def ofSheafForgetLightProfinite\n    [HasForget A] [ReflectsFiniteLimits (CategoryTheory.forget A)]\n    (F : LightProfinite.{u}ᵒᵖ ⥤ A) [PreservesFiniteProducts (F ⋙ CategoryTheory.forget A)]\n    (hF : EqualizerCondition (F ⋙ CategoryTheory.forget A)) : LightCondensed A where\n  val := F\n  cond := by\n    apply isSheaf_coherent_of_hasPullbacks_of_comp F (CategoryTheory.forget A)\n    rw [isSheaf_iff_preservesFiniteProducts_and_equalizerCondition]\n    exact ⟨⟨fun _ _ ↦ inferInstance⟩, hF⟩\n\n"}
{"name":"LightCondensed.equalizerCondition","module":"Mathlib.Condensed.Light.Explicit","initialProofState":"A : Type u_1\ninst✝ : CategoryTheory.Category.{u_3, u_1} A\nX : LightCondensed A\n⊢ CategoryTheory.regularTopology.EqualizerCondition X.val","decl":"/-- A light condensed object satisfies the equalizer condition. -/\ntheorem equalizerCondition (X : LightCondensed A) : EqualizerCondition X.val :=\n  isSheaf_iff_preservesFiniteProducts_and_equalizerCondition X.val |>.mp X.cond |>.2\n\n"}
{"name":"LightCondensed.instPreservesFiniteProductsOppositeLightProfiniteVal","module":"Mathlib.Condensed.Light.Explicit","initialProofState":"A : Type u_1\ninst✝ : CategoryTheory.Category.{u_3, u_1} A\nX : LightCondensed A\n⊢ CategoryTheory.Limits.PreservesFiniteProducts X.val","decl":"/-- A light condensed object preserves finite products. -/\nnoncomputable instance (X : LightCondensed A) : PreservesFiniteProducts X.val :=\n  isSheaf_iff_preservesFiniteProducts_and_equalizerCondition X.val |>.mp X.cond |>.1\n\n"}
