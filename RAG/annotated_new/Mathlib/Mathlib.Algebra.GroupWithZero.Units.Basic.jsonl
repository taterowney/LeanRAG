{"name":"Units.ne_zero","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"M₀ : Type u_2\ninst✝¹ : MonoidWithZero M₀\ninst✝ : Nontrivial M₀\nu : Units M₀\n⊢ Ne (↑u) 0","decl":"/-- An element of the unit group of a nonzero monoid with zero represented as an element\n    of the monoid is nonzero. -/\n@[simp]\ntheorem ne_zero [Nontrivial M₀] (u : M₀ˣ) : (u : M₀) ≠ 0 :=\n  left_ne_zero_of_mul_eq_one u.mul_inv\n\n-- We can't use `mul_eq_zero` + `Units.ne_zero` in the next two lemmas because we don't assume\n-- `Nonzero M₀`.\n"}
{"name":"Units.mul_left_eq_zero","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"M₀ : Type u_2\ninst✝ : MonoidWithZero M₀\nu : Units M₀\na : M₀\n⊢ Iff (Eq (HMul.hMul a ↑u) 0) (Eq a 0)","decl":"@[simp]\ntheorem mul_left_eq_zero (u : M₀ˣ) {a : M₀} : a * u = 0 ↔ a = 0 :=\n  ⟨fun h => by simpa using mul_eq_zero_of_left h ↑u⁻¹, fun h => mul_eq_zero_of_left h u⟩\n\n"}
{"name":"Units.mul_right_eq_zero","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"M₀ : Type u_2\ninst✝ : MonoidWithZero M₀\nu : Units M₀\na : M₀\n⊢ Iff (Eq (HMul.hMul (↑u) a) 0) (Eq a 0)","decl":"@[simp]\ntheorem mul_right_eq_zero (u : M₀ˣ) {a : M₀} : ↑u * a = 0 ↔ a = 0 :=\n  ⟨fun h => by simpa using mul_eq_zero_of_right (↑u⁻¹) h, mul_eq_zero_of_right (u : M₀)⟩\n\n"}
{"name":"IsUnit.ne_zero","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"M₀ : Type u_2\ninst✝¹ : MonoidWithZero M₀\ninst✝ : Nontrivial M₀\na : M₀\nha : IsUnit a\n⊢ Ne a 0","decl":"theorem ne_zero [Nontrivial M₀] {a : M₀} (ha : IsUnit a) : a ≠ 0 :=\n  let ⟨u, hu⟩ := ha\n  hu ▸ u.ne_zero\n\n"}
{"name":"IsUnit.mul_right_eq_zero","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"M₀ : Type u_2\ninst✝ : MonoidWithZero M₀\na b : M₀\nha : IsUnit a\n⊢ Iff (Eq (HMul.hMul a b) 0) (Eq b 0)","decl":"theorem mul_right_eq_zero {a b : M₀} (ha : IsUnit a) : a * b = 0 ↔ b = 0 :=\n  let ⟨u, hu⟩ := ha\n  hu ▸ u.mul_right_eq_zero\n\n"}
{"name":"IsUnit.mul_left_eq_zero","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"M₀ : Type u_2\ninst✝ : MonoidWithZero M₀\na b : M₀\nhb : IsUnit b\n⊢ Iff (Eq (HMul.hMul a b) 0) (Eq a 0)","decl":"theorem mul_left_eq_zero {a b : M₀} (hb : IsUnit b) : a * b = 0 ↔ a = 0 :=\n  let ⟨u, hu⟩ := hb\n  hu ▸ u.mul_left_eq_zero\n\n"}
{"name":"isUnit_zero_iff","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"M₀ : Type u_2\ninst✝ : MonoidWithZero M₀\n⊢ Iff (IsUnit 0) (Eq 0 1)","decl":"@[simp]\ntheorem isUnit_zero_iff : IsUnit (0 : M₀) ↔ (0 : M₀) = 1 :=\n  ⟨fun ⟨⟨_, a, (a0 : 0 * a = 1), _⟩, rfl⟩ => by rwa [zero_mul] at a0, fun h =>\n    @isUnit_of_subsingleton _ _ (subsingleton_of_zero_eq_one h) 0⟩\n\n"}
{"name":"not_isUnit_zero","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"M₀ : Type u_2\ninst✝¹ : MonoidWithZero M₀\ninst✝ : Nontrivial M₀\n⊢ Not (IsUnit 0)","decl":"theorem not_isUnit_zero [Nontrivial M₀] : ¬IsUnit (0 : M₀) :=\n  mt isUnit_zero_iff.1 zero_ne_one\n\n"}
{"name":"Ring.inverse_unit","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"M₀ : Type u_2\ninst✝ : MonoidWithZero M₀\nu : Units M₀\n⊢ Eq (Ring.inverse ↑u) ↑(Inv.inv u)","decl":"/-- By definition, if `x` is invertible then `inverse x = x⁻¹`. -/\n@[simp]\ntheorem inverse_unit (u : M₀ˣ) : inverse (u : M₀) = (u⁻¹ : M₀ˣ) := by\n  rw [inverse, dif_pos u.isUnit, IsUnit.unit_of_val_units]\n\n"}
{"name":"Ring.IsUnit.ringInverse","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"M₀ : Type u_2\ninst✝ : MonoidWithZero M₀\nx : M₀\nh : IsUnit x\n⊢ IsUnit (Ring.inverse x)","decl":"theorem IsUnit.ringInverse {x : M₀} (h : IsUnit x) : IsUnit (inverse x) :=\n  match h with\n  | ⟨u, hu⟩ => hu ▸ ⟨u⁻¹, (inverse_unit u).symm⟩\n\n"}
{"name":"Ring.inverse_of_isUnit","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"M₀ : Type u_2\ninst✝ : MonoidWithZero M₀\nx : M₀\nh : IsUnit x\n⊢ Eq (Ring.inverse x) ↑(Inv.inv h.unit)","decl":"theorem inverse_of_isUnit {x : M₀} (h : IsUnit x) : inverse x = ((h.unit⁻¹ : M₀ˣ) : M₀) := dif_pos h\n\n"}
{"name":"Ring.inverse_non_unit","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"M₀ : Type u_2\ninst✝ : MonoidWithZero M₀\nx : M₀\nh : Not (IsUnit x)\n⊢ Eq (Ring.inverse x) 0","decl":"/-- By definition, if `x` is not invertible then `inverse x = 0`. -/\n@[simp]\ntheorem inverse_non_unit (x : M₀) (h : ¬IsUnit x) : inverse x = 0 :=\n  dif_neg h\n\n"}
{"name":"Ring.mul_inverse_cancel","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"M₀ : Type u_2\ninst✝ : MonoidWithZero M₀\nx : M₀\nh : IsUnit x\n⊢ Eq (HMul.hMul x (Ring.inverse x)) 1","decl":"theorem mul_inverse_cancel (x : M₀) (h : IsUnit x) : x * inverse x = 1 := by\n  rcases h with ⟨u, rfl⟩\n  rw [inverse_unit, Units.mul_inv]\n\n"}
{"name":"Ring.inverse_mul_cancel","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"M₀ : Type u_2\ninst✝ : MonoidWithZero M₀\nx : M₀\nh : IsUnit x\n⊢ Eq (HMul.hMul (Ring.inverse x) x) 1","decl":"theorem inverse_mul_cancel (x : M₀) (h : IsUnit x) : inverse x * x = 1 := by\n  rcases h with ⟨u, rfl⟩\n  rw [inverse_unit, Units.inv_mul]\n\n"}
{"name":"Ring.mul_inverse_cancel_right","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"M₀ : Type u_2\ninst✝ : MonoidWithZero M₀\nx y : M₀\nh : IsUnit x\n⊢ Eq (HMul.hMul (HMul.hMul y x) (Ring.inverse x)) y","decl":"theorem mul_inverse_cancel_right (x y : M₀) (h : IsUnit x) : y * x * inverse x = y := by\n  rw [mul_assoc, mul_inverse_cancel x h, mul_one]\n\n"}
{"name":"Ring.inverse_mul_cancel_right","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"M₀ : Type u_2\ninst✝ : MonoidWithZero M₀\nx y : M₀\nh : IsUnit x\n⊢ Eq (HMul.hMul (HMul.hMul y (Ring.inverse x)) x) y","decl":"theorem inverse_mul_cancel_right (x y : M₀) (h : IsUnit x) : y * inverse x * x = y := by\n  rw [mul_assoc, inverse_mul_cancel x h, mul_one]\n\n"}
{"name":"Ring.mul_inverse_cancel_left","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"M₀ : Type u_2\ninst✝ : MonoidWithZero M₀\nx y : M₀\nh : IsUnit x\n⊢ Eq (HMul.hMul x (HMul.hMul (Ring.inverse x) y)) y","decl":"theorem mul_inverse_cancel_left (x y : M₀) (h : IsUnit x) : x * (inverse x * y) = y := by\n  rw [← mul_assoc, mul_inverse_cancel x h, one_mul]\n\n"}
{"name":"Ring.inverse_mul_cancel_left","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"M₀ : Type u_2\ninst✝ : MonoidWithZero M₀\nx y : M₀\nh : IsUnit x\n⊢ Eq (HMul.hMul (Ring.inverse x) (HMul.hMul x y)) y","decl":"theorem inverse_mul_cancel_left (x y : M₀) (h : IsUnit x) : inverse x * (x * y) = y := by\n  rw [← mul_assoc, inverse_mul_cancel x h, one_mul]\n\n"}
{"name":"Ring.inverse_mul_eq_iff_eq_mul","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"M₀ : Type u_2\ninst✝ : MonoidWithZero M₀\nx y z : M₀\nh : IsUnit x\n⊢ Iff (Eq (HMul.hMul (Ring.inverse x) y) z) (Eq y (HMul.hMul x z))","decl":"theorem inverse_mul_eq_iff_eq_mul (x y z : M₀) (h : IsUnit x) : inverse x * y = z ↔ y = x * z :=\n  ⟨fun h1 => by rw [← h1, mul_inverse_cancel_left _ _ h],\n  fun h1 => by rw [h1, inverse_mul_cancel_left _ _ h]⟩\n\n"}
{"name":"Ring.eq_mul_inverse_iff_mul_eq","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"M₀ : Type u_2\ninst✝ : MonoidWithZero M₀\nx y z : M₀\nh : IsUnit z\n⊢ Iff (Eq x (HMul.hMul y (Ring.inverse z))) (Eq (HMul.hMul x z) y)","decl":"theorem eq_mul_inverse_iff_mul_eq (x y z : M₀) (h : IsUnit z) : x = y * inverse z ↔ x * z = y :=\n  ⟨fun h1 => by rw [h1, inverse_mul_cancel_right _ _ h],\n  fun h1 => by rw [← h1, mul_inverse_cancel_right _ _ h]⟩\n\n"}
{"name":"Ring.inverse_one","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"M₀ : Type u_2\ninst✝ : MonoidWithZero M₀\n⊢ Eq (Ring.inverse 1) 1","decl":"@[simp]\ntheorem inverse_one : inverse (1 : M₀) = 1 :=\n  inverse_unit 1\n\n"}
{"name":"Ring.inverse_zero","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"M₀ : Type u_2\ninst✝ : MonoidWithZero M₀\n⊢ Eq (Ring.inverse 0) 0","decl":"@[simp]\ntheorem inverse_zero : inverse (0 : M₀) = 0 := by\n  nontriviality\n  exact inverse_non_unit _ not_isUnit_zero\n\n"}
{"name":"IsUnit.ring_inverse","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"M₀ : Type u_2\ninst✝ : MonoidWithZero M₀\na : M₀\na✝ : IsUnit a\n⊢ IsUnit (Ring.inverse a)","decl":"theorem IsUnit.ring_inverse {a : M₀} : IsUnit a → IsUnit (Ring.inverse a)\n  | ⟨u, hu⟩ => hu ▸ ⟨u⁻¹, (Ring.inverse_unit u).symm⟩\n\n"}
{"name":"isUnit_ring_inverse","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"M₀ : Type u_2\ninst✝ : MonoidWithZero M₀\na : M₀\n⊢ Iff (IsUnit (Ring.inverse a)) (IsUnit a)","decl":"@[simp]\ntheorem isUnit_ring_inverse {a : M₀} : IsUnit (Ring.inverse a) ↔ IsUnit a :=\n  ⟨fun h => by\n    cases subsingleton_or_nontrivial M₀\n    · convert h\n    · contrapose h\n      rw [Ring.inverse_non_unit _ h]\n      exact not_isUnit_zero\n      ,\n    IsUnit.ring_inverse⟩\n\n"}
{"name":"Units.mk0_one","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\nh : optParam (Ne 1 0) ⋯\n⊢ Eq (Units.mk0 1 h) 1","decl":"@[simp]\ntheorem mk0_one (h := one_ne_zero) : mk0 (1 : G₀) h = 1 := by\n  ext\n  rfl\n\n"}
{"name":"Units.val_mk0","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na : G₀\nh : Ne a 0\n⊢ Eq (↑(Units.mk0 a h)) a","decl":"@[simp]\ntheorem val_mk0 {a : G₀} (h : a ≠ 0) : (mk0 a h : G₀) = a :=\n  rfl\n\n"}
{"name":"Units.mk0_val","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\nu : Units G₀\nh : Ne (↑u) 0\n⊢ Eq (Units.mk0 (↑u) h) u","decl":"@[simp]\ntheorem mk0_val (u : G₀ˣ) (h : (u : G₀) ≠ 0) : mk0 (u : G₀) h = u :=\n  Units.ext rfl\n\n"}
{"name":"Units.mul_inv'","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\nu : Units G₀\n⊢ Eq (HMul.hMul (↑u) (Inv.inv ↑u)) 1","decl":"theorem mul_inv' (u : G₀ˣ) : u * (u : G₀)⁻¹ = 1 :=\n  mul_inv_cancel₀ u.ne_zero\n\n"}
{"name":"Units.inv_mul'","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\nu : Units G₀\n⊢ Eq (HMul.hMul (Inv.inv ↑u) ↑u) 1","decl":"theorem inv_mul' (u : G₀ˣ) : (u⁻¹ : G₀) * u = 1 :=\n  inv_mul_cancel₀ u.ne_zero\n\n"}
{"name":"Units.mk0_inj","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b : G₀\nha : Ne a 0\nhb : Ne b 0\n⊢ Iff (Eq (Units.mk0 a ha) (Units.mk0 b hb)) (Eq a b)","decl":"@[simp]\ntheorem mk0_inj {a b : G₀} (ha : a ≠ 0) (hb : b ≠ 0) : Units.mk0 a ha = Units.mk0 b hb ↔ a = b :=\n  ⟨fun h => by injection h, fun h => Units.ext h⟩\n\n"}
{"name":"Units.exists0","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\np : Units G₀ → Prop\n⊢ Iff (Exists fun g => p g) (Exists fun g => Exists fun hg => p (Units.mk0 g hg))","decl":"/-- In a group with zero, an existential over a unit can be rewritten in terms of `Units.mk0`. -/\ntheorem exists0 {p : G₀ˣ → Prop} : (∃ g : G₀ˣ, p g) ↔ ∃ (g : G₀) (hg : g ≠ 0), p (Units.mk0 g hg) :=\n  ⟨fun ⟨g, pg⟩ => ⟨g, g.ne_zero, (g.mk0_val g.ne_zero).symm ▸ pg⟩,\n  fun ⟨g, hg, pg⟩ => ⟨Units.mk0 g hg, pg⟩⟩\n\n"}
{"name":"Units.exists0'","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\np : (g : G₀) → Ne g 0 → Prop\n⊢ Iff (Exists fun g => Exists fun hg => p g hg) (Exists fun g => p ↑g ⋯)","decl":"/-- An alternative version of `Units.exists0`. This one is useful if Lean cannot\nfigure out `p` when using `Units.exists0` from right to left. -/\ntheorem exists0' {p : ∀ g : G₀, g ≠ 0 → Prop} :\n    (∃ (g : G₀) (hg : g ≠ 0), p g hg) ↔ ∃ g : G₀ˣ, p g g.ne_zero :=\n  Iff.trans (by simp_rw [val_mk0]) exists0.symm\n\n"}
{"name":"Units.exists_iff_ne_zero","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\np : G₀ → Prop\n⊢ Iff (Exists fun u => p ↑u) (Exists fun x => And (Ne x 0) (p x))","decl":"@[simp]\ntheorem exists_iff_ne_zero {p : G₀ → Prop} : (∃ u : G₀ˣ, p u) ↔ ∃ x ≠ 0, p x := by\n  simp [exists0]\n\n"}
{"name":"GroupWithZero.eq_zero_or_unit","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na : G₀\n⊢ Or (Eq a 0) (Exists fun u => Eq a ↑u)","decl":"theorem _root_.GroupWithZero.eq_zero_or_unit (a : G₀) : a = 0 ∨ ∃ u : G₀ˣ, a = u := by\n  simpa using em _\n\n"}
{"name":"IsUnit.mk0","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\nx : G₀\nhx : Ne x 0\n⊢ IsUnit x","decl":"theorem IsUnit.mk0 (x : G₀) (hx : x ≠ 0) : IsUnit x :=\n  (Units.mk0 x hx).isUnit\n\n"}
{"name":"isUnit_iff_ne_zero","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na : G₀\n⊢ Iff (IsUnit a) (Ne a 0)","decl":"@[simp]\ntheorem isUnit_iff_ne_zero : IsUnit a ↔ a ≠ 0 :=\n  (Units.exists_iff_ne_zero (p := (· = a))).trans (by simp)\n\n"}
{"name":"Ne.isUnit","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na : G₀\na✝ : Ne a 0\n⊢ IsUnit a","decl":"alias ⟨_, Ne.isUnit⟩ := isUnit_iff_ne_zero\n\n-- Porting note: can't add this attribute?\n-- https://github.com/leanprover-community/mathlib4/issues/740\n-- attribute [protected] Ne.is_unit\n\n-- see Note [lower instance priority]\n"}
{"name":"GroupWithZero.noZeroDivisors","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\n⊢ NoZeroDivisors G₀","decl":"instance (priority := 10) GroupWithZero.noZeroDivisors : NoZeroDivisors G₀ :=\n  { (‹_› : GroupWithZero G₀) with\n    eq_zero_or_eq_zero_of_mul_eq_zero := @fun a b h => by\n      contrapose! h\n      exact (Units.mk0 a h.1 * Units.mk0 b h.2).ne_zero }\n\n-- Can't be put next to the other `mk0` lemmas because it depends on the\n-- `NoZeroDivisors` instance, which depends on `mk0`.\n"}
{"name":"Units.mk0_mul","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\nx y : G₀\nhxy : Ne (HMul.hMul x y) 0\n⊢ Eq (Units.mk0 (HMul.hMul x y) hxy) (HMul.hMul (Units.mk0 x ⋯) (Units.mk0 y ⋯))","decl":"@[simp]\ntheorem Units.mk0_mul (x y : G₀) (hxy) :\n    Units.mk0 (x * y) hxy =\n      Units.mk0 x (mul_ne_zero_iff.mp hxy).1 * Units.mk0 y (mul_ne_zero_iff.mp hxy).2 := by\n  ext; rfl\n\n"}
{"name":"div_ne_zero","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b : G₀\nha : Ne a 0\nhb : Ne b 0\n⊢ Ne (HDiv.hDiv a b) 0","decl":"theorem div_ne_zero (ha : a ≠ 0) (hb : b ≠ 0) : a / b ≠ 0 := by\n  rw [div_eq_mul_inv]\n  exact mul_ne_zero ha (inv_ne_zero hb)\n\n"}
{"name":"div_eq_zero_iff","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b : G₀\n⊢ Iff (Eq (HDiv.hDiv a b) 0) (Or (Eq a 0) (Eq b 0))","decl":"@[simp]\ntheorem div_eq_zero_iff : a / b = 0 ↔ a = 0 ∨ b = 0 := by simp [div_eq_mul_inv]\n\n"}
{"name":"div_ne_zero_iff","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b : G₀\n⊢ Iff (Ne (HDiv.hDiv a b) 0) (And (Ne a 0) (Ne b 0))","decl":"theorem div_ne_zero_iff : a / b ≠ 0 ↔ a ≠ 0 ∧ b ≠ 0 :=\n  div_eq_zero_iff.not.trans not_or\n\n"}
{"name":"div_self","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na : G₀\nh : Ne a 0\n⊢ Eq (HDiv.hDiv a a) 1","decl":"@[simp] lemma div_self (h : a ≠ 0) : a / a = 1 := h.isUnit.div_self\n\n"}
{"name":"eq_mul_inv_iff_mul_eq₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b c : G₀\nhc : Ne c 0\n⊢ Iff (Eq a (HMul.hMul b (Inv.inv c))) (Eq (HMul.hMul a c) b)","decl":"lemma eq_mul_inv_iff_mul_eq₀ (hc : c ≠ 0) : a = b * c⁻¹ ↔ a * c = b :=\n  hc.isUnit.eq_mul_inv_iff_mul_eq\n\n"}
{"name":"eq_inv_mul_iff_mul_eq₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b c : G₀\nhb : Ne b 0\n⊢ Iff (Eq a (HMul.hMul (Inv.inv b) c)) (Eq (HMul.hMul b a) c)","decl":"lemma eq_inv_mul_iff_mul_eq₀ (hb : b ≠ 0) : a = b⁻¹ * c ↔ b * a = c :=\n  hb.isUnit.eq_inv_mul_iff_mul_eq\n\n"}
{"name":"inv_mul_eq_iff_eq_mul₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b c : G₀\nha : Ne a 0\n⊢ Iff (Eq (HMul.hMul (Inv.inv a) b) c) (Eq b (HMul.hMul a c))","decl":"lemma inv_mul_eq_iff_eq_mul₀ (ha : a ≠ 0) : a⁻¹ * b = c ↔ b = a * c :=\n  ha.isUnit.inv_mul_eq_iff_eq_mul\n\n"}
{"name":"mul_inv_eq_iff_eq_mul₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b c : G₀\nhb : Ne b 0\n⊢ Iff (Eq (HMul.hMul a (Inv.inv b)) c) (Eq a (HMul.hMul c b))","decl":"lemma mul_inv_eq_iff_eq_mul₀ (hb : b ≠ 0) : a * b⁻¹ = c ↔ a = c * b :=\n  hb.isUnit.mul_inv_eq_iff_eq_mul\n\n"}
{"name":"mul_inv_eq_one₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b : G₀\nhb : Ne b 0\n⊢ Iff (Eq (HMul.hMul a (Inv.inv b)) 1) (Eq a b)","decl":"lemma mul_inv_eq_one₀ (hb : b ≠ 0) : a * b⁻¹ = 1 ↔ a = b := hb.isUnit.mul_inv_eq_one\n\n"}
{"name":"inv_mul_eq_one₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b : G₀\nha : Ne a 0\n⊢ Iff (Eq (HMul.hMul (Inv.inv a) b) 1) (Eq a b)","decl":"lemma inv_mul_eq_one₀ (ha : a ≠ 0) : a⁻¹ * b = 1 ↔ a = b := ha.isUnit.inv_mul_eq_one\n\n"}
{"name":"mul_eq_one_iff_eq_inv₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b : G₀\nhb : Ne b 0\n⊢ Iff (Eq (HMul.hMul a b) 1) (Eq a (Inv.inv b))","decl":"lemma mul_eq_one_iff_eq_inv₀ (hb : b ≠ 0) : a * b = 1 ↔ a = b⁻¹ := hb.isUnit.mul_eq_one_iff_eq_inv\n\n"}
{"name":"mul_eq_one_iff_inv_eq₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b : G₀\nha : Ne a 0\n⊢ Iff (Eq (HMul.hMul a b) 1) (Eq (Inv.inv a) b)","decl":"lemma mul_eq_one_iff_inv_eq₀ (ha : a ≠ 0) : a * b = 1 ↔ a⁻¹ = b := ha.isUnit.mul_eq_one_iff_inv_eq\n\n"}
{"name":"mul_eq_of_eq_mul_inv₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b c : G₀\nha : Ne a 0\nh : Eq a (HMul.hMul c (Inv.inv b))\n⊢ Eq (HMul.hMul a b) c","decl":"/-- A variant of `eq_mul_inv_iff_mul_eq₀` that moves the nonzero hypothesis to another variable. -/\nlemma mul_eq_of_eq_mul_inv₀ (ha : a ≠ 0) (h : a = c * b⁻¹) : a * b = c := by\n  rwa [← eq_mul_inv_iff_mul_eq₀]; rintro rfl; simp [ha] at h\n\n"}
{"name":"mul_eq_of_eq_inv_mul₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b c : G₀\nhb : Ne b 0\nh : Eq b (HMul.hMul (Inv.inv a) c)\n⊢ Eq (HMul.hMul a b) c","decl":"/-- A variant of `eq_inv_mul_iff_mul_eq₀` that moves the nonzero hypothesis to another variable. -/\nlemma mul_eq_of_eq_inv_mul₀ (hb : b ≠ 0) (h : b = a⁻¹ * c) : a * b = c := by\n  rwa [← eq_inv_mul_iff_mul_eq₀]; rintro rfl; simp [hb] at h\n\n"}
{"name":"eq_mul_of_inv_mul_eq₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b c : G₀\nhc : Ne c 0\nh : Eq (HMul.hMul (Inv.inv b) a) c\n⊢ Eq a (HMul.hMul b c)","decl":"/-- A variant of `inv_mul_eq_iff_eq_mul₀` that moves the nonzero hypothesis to another variable. -/\nlemma eq_mul_of_inv_mul_eq₀ (hc : c ≠ 0) (h : b⁻¹ * a = c) : a = b * c := by\n  rwa [← inv_mul_eq_iff_eq_mul₀]; rintro rfl; simp [hc.symm] at h\n\n"}
{"name":"eq_mul_of_mul_inv_eq₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b c : G₀\nhb : Ne b 0\nh : Eq (HMul.hMul a (Inv.inv c)) b\n⊢ Eq a (HMul.hMul b c)","decl":"/-- A variant of `mul_inv_eq_iff_eq_mul₀` that moves the nonzero hypothesis to another variable. -/\nlemma eq_mul_of_mul_inv_eq₀ (hb : b ≠ 0) (h : a * c⁻¹ = b) : a = b * c := by\n  rwa [← mul_inv_eq_iff_eq_mul₀]; rintro rfl; simp [hb.symm] at h\n\n"}
{"name":"div_mul_cancel₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\nb a : G₀\nh : Ne b 0\n⊢ Eq (HMul.hMul (HDiv.hDiv a b) b) a","decl":"@[simp] lemma div_mul_cancel₀ (a : G₀) (h : b ≠ 0) : a / b * b = a := h.isUnit.div_mul_cancel _\n\n"}
{"name":"mul_one_div_cancel","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na : G₀\nh : Ne a 0\n⊢ Eq (HMul.hMul a (HDiv.hDiv 1 a)) 1","decl":"lemma mul_one_div_cancel (h : a ≠ 0) : a * (1 / a) = 1 := h.isUnit.mul_one_div_cancel\n\n"}
{"name":"one_div_mul_cancel","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na : G₀\nh : Ne a 0\n⊢ Eq (HMul.hMul (HDiv.hDiv 1 a) a) 1","decl":"lemma one_div_mul_cancel (h : a ≠ 0) : 1 / a * a = 1 := h.isUnit.one_div_mul_cancel\n\n"}
{"name":"div_left_inj'","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b c : G₀\nhc : Ne c 0\n⊢ Iff (Eq (HDiv.hDiv a c) (HDiv.hDiv b c)) (Eq a b)","decl":"lemma div_left_inj' (hc : c ≠ 0) : a / c = b / c ↔ a = b := hc.isUnit.div_left_inj\n\n"}
{"name":"div_eq_iff","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b c : G₀\nhb : Ne b 0\n⊢ Iff (Eq (HDiv.hDiv a b) c) (Eq a (HMul.hMul c b))","decl":"@[field_simps] lemma div_eq_iff (hb : b ≠ 0) : a / b = c ↔ a = c * b := hb.isUnit.div_eq_iff\n\n"}
{"name":"eq_div_iff","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b c : G₀\nhb : Ne b 0\n⊢ Iff (Eq c (HDiv.hDiv a b)) (Eq (HMul.hMul c b) a)","decl":"@[field_simps] lemma eq_div_iff (hb : b ≠ 0) : c = a / b ↔ c * b = a := hb.isUnit.eq_div_iff\n\n-- TODO: Swap RHS around\n"}
{"name":"div_eq_iff_mul_eq","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b c : G₀\nhb : Ne b 0\n⊢ Iff (Eq (HDiv.hDiv a b) c) (Eq (HMul.hMul c b) a)","decl":"lemma div_eq_iff_mul_eq (hb : b ≠ 0) : a / b = c ↔ c * b = a := hb.isUnit.div_eq_iff.trans eq_comm\n\n"}
{"name":"eq_div_iff_mul_eq","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b c : G₀\nhc : Ne c 0\n⊢ Iff (Eq a (HDiv.hDiv b c)) (Eq (HMul.hMul a c) b)","decl":"lemma eq_div_iff_mul_eq (hc : c ≠ 0) : a = b / c ↔ a * c = b := hc.isUnit.eq_div_iff\n\n"}
{"name":"div_eq_of_eq_mul","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b c : G₀\nhb : Ne b 0\na✝ : Eq a (HMul.hMul c b)\n⊢ Eq (HDiv.hDiv a b) c","decl":"lemma div_eq_of_eq_mul (hb : b ≠ 0) : a = c * b → a / b = c := hb.isUnit.div_eq_of_eq_mul\n\n"}
{"name":"eq_div_of_mul_eq","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b c : G₀\nhc : Ne c 0\na✝ : Eq (HMul.hMul a c) b\n⊢ Eq a (HDiv.hDiv b c)","decl":"lemma eq_div_of_mul_eq (hc : c ≠ 0) : a * c = b → a = b / c := hc.isUnit.eq_div_of_mul_eq\n\n"}
{"name":"div_eq_one_iff_eq","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b : G₀\nhb : Ne b 0\n⊢ Iff (Eq (HDiv.hDiv a b) 1) (Eq a b)","decl":"lemma div_eq_one_iff_eq (hb : b ≠ 0) : a / b = 1 ↔ a = b := hb.isUnit.div_eq_one_iff_eq\n\n"}
{"name":"div_mul_cancel_right₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\nb : G₀\nhb : Ne b 0\na : G₀\n⊢ Eq (HDiv.hDiv b (HMul.hMul a b)) (Inv.inv a)","decl":"lemma div_mul_cancel_right₀ (hb : b ≠ 0) (a : G₀) : b / (a * b) = a⁻¹ :=\n  hb.isUnit.div_mul_cancel_right _\n\n"}
{"name":"mul_div_mul_right","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\nc a b : G₀\nhc : Ne c 0\n⊢ Eq (HDiv.hDiv (HMul.hMul a c) (HMul.hMul b c)) (HDiv.hDiv a b)","decl":"lemma mul_div_mul_right (a b : G₀) (hc : c ≠ 0) : a * c / (b * c) = a / b :=\n  hc.isUnit.mul_div_mul_right _ _\n\n-- TODO: Duplicate of `mul_inv_cancel_right₀`\n"}
{"name":"mul_mul_div","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\nb a : G₀\nhb : Ne b 0\n⊢ Eq a (HMul.hMul (HMul.hMul a b) (HDiv.hDiv 1 b))","decl":"lemma mul_mul_div (a : G₀) (hb : b ≠ 0) : a = a * b * (1 / b) := (hb.isUnit.mul_mul_div _).symm\n\n"}
{"name":"div_div_div_cancel_right₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\nc : G₀\nhc : Ne c 0\na b : G₀\n⊢ Eq (HDiv.hDiv (HDiv.hDiv a c) (HDiv.hDiv b c)) (HDiv.hDiv a b)","decl":"lemma div_div_div_cancel_right₀ (hc : c ≠ 0) (a b : G₀) : a / c / (b / c) = a / b := by\n  rw [div_div_eq_mul_div, div_mul_cancel₀ _ hc]\n\n"}
{"name":"div_mul_div_cancel₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b c : G₀\nhb : Ne b 0\n⊢ Eq (HMul.hMul (HDiv.hDiv a b) (HDiv.hDiv b c)) (HDiv.hDiv a c)","decl":"lemma div_mul_div_cancel₀ (hb : b ≠ 0) : a / b * (b / c) = a / c := by\n  rw [← mul_div_assoc, div_mul_cancel₀ _ hb]\n\n"}
{"name":"div_mul_cancel_of_imp","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b : G₀\nh : Eq b 0 → Eq a 0\n⊢ Eq (HMul.hMul (HDiv.hDiv a b) b) a","decl":"lemma div_mul_cancel_of_imp (h : b = 0 → a = 0) : a / b * b = a := by\n  obtain rfl | hb := eq_or_ne b 0 <;>  simp [*]\n\n"}
{"name":"mul_div_cancel_of_imp","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na b : G₀\nh : Eq b 0 → Eq a 0\n⊢ Eq (HDiv.hDiv (HMul.hMul a b) b) a","decl":"lemma mul_div_cancel_of_imp (h : b = 0 → a = 0) : a * b / b = a := by\n  obtain rfl | hb := eq_or_ne b 0 <;>  simp [*]\n\n"}
{"name":"divp_mk0","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\nb a : G₀\nhb : Ne b 0\n⊢ Eq (divp a (Units.mk0 b hb)) (HDiv.hDiv a b)","decl":"@[simp] lemma divp_mk0 (a : G₀) (hb : b ≠ 0) : a /ₚ Units.mk0 b hb = a / b := divp_eq_div _ _\n\n"}
{"name":"pow_sub₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\nm n : Nat\na : G₀\nha : Ne a 0\nh : LE.le n m\n⊢ Eq (HPow.hPow a (HSub.hSub m n)) (HMul.hMul (HPow.hPow a m) (Inv.inv (HPow.hPow a n)))","decl":"lemma pow_sub₀ (a : G₀) (ha : a ≠ 0) (h : n ≤ m) : a ^ (m - n) = a ^ m * (a ^ n)⁻¹ := by\n  have h1 : m - n + n = m := Nat.sub_add_cancel h\n  have h2 : a ^ (m - n) * a ^ n = a ^ m := by rw [← pow_add, h1]\n  simpa only [div_eq_mul_inv] using eq_div_of_mul_eq (pow_ne_zero _ ha) h2\n\n"}
{"name":"pow_sub_of_lt","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\nm n : Nat\na : G₀\nh : LT.lt n m\n⊢ Eq (HPow.hPow a (HSub.hSub m n)) (HMul.hMul (HPow.hPow a m) (Inv.inv (HPow.hPow a n)))","decl":"lemma pow_sub_of_lt (a : G₀) (h : n < m) : a ^ (m - n) = a ^ m * (a ^ n)⁻¹ := by\n  obtain rfl | ha := eq_or_ne a 0\n  · rw [zero_pow (Nat.ne_of_gt <| Nat.sub_pos_of_lt h), zero_pow (by omega), zero_mul]\n  · exact pow_sub₀ _ ha <| Nat.le_of_lt h\n\n"}
{"name":"inv_pow_sub₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na : G₀\nm n : Nat\nha : Ne a 0\nh : LE.le n m\n⊢ Eq (HPow.hPow (Inv.inv a) (HSub.hSub m n)) (HMul.hMul (Inv.inv (HPow.hPow a m)) (HPow.hPow a n))","decl":"lemma inv_pow_sub₀ (ha : a ≠ 0) (h : n ≤ m) : a⁻¹ ^ (m - n) = (a ^ m)⁻¹ * a ^ n := by\n  rw [pow_sub₀ _ (inv_ne_zero ha) h, inv_pow, inv_pow, inv_inv]\n\n"}
{"name":"inv_pow_sub_of_lt","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\nm n : Nat\na : G₀\nh : LT.lt n m\n⊢ Eq (HPow.hPow (Inv.inv a) (HSub.hSub m n)) (HMul.hMul (Inv.inv (HPow.hPow a m)) (HPow.hPow a n))","decl":"lemma inv_pow_sub_of_lt (a : G₀) (h : n < m) : a⁻¹ ^ (m - n) = (a ^ m)⁻¹ * a ^ n := by\n  rw [pow_sub_of_lt a⁻¹ h, inv_pow, inv_pow, inv_inv]\n\n"}
{"name":"zpow_sub₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na : G₀\nha : Ne a 0\nm n : Int\n⊢ Eq (HPow.hPow a (HSub.hSub m n)) (HDiv.hDiv (HPow.hPow a m) (HPow.hPow a n))","decl":"lemma zpow_sub₀ (ha : a ≠ 0) (m n : ℤ) : a ^ (m - n) = a ^ m / a ^ n := by\n  rw [Int.sub_eq_add_neg, zpow_add₀ ha, zpow_neg, div_eq_mul_inv]\n\n"}
{"name":"zpow_natCast_sub_natCast₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na : G₀\nha : Ne a 0\nm n : Nat\n⊢ Eq (HPow.hPow a (HSub.hSub ↑m ↑n)) (HDiv.hDiv (HPow.hPow a m) (HPow.hPow a n))","decl":"lemma zpow_natCast_sub_natCast₀ (ha : a ≠ 0) (m n : ℕ) : a ^ (m - n : ℤ) = a ^ m / a ^ n := by\n  simpa using zpow_sub₀ ha m n\n\n"}
{"name":"zpow_natCast_sub_one₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na : G₀\nha : Ne a 0\nn : Nat\n⊢ Eq (HPow.hPow a (HSub.hSub (↑n) 1)) (HDiv.hDiv (HPow.hPow a n) a)","decl":"lemma zpow_natCast_sub_one₀ (ha : a ≠ 0) (n : ℕ) : a ^ (n - 1 : ℤ) = a ^ n / a := by\n  simpa using zpow_sub₀ ha n 1\n\n"}
{"name":"zpow_one_sub_natCast₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na : G₀\nha : Ne a 0\nn : Nat\n⊢ Eq (HPow.hPow a (HSub.hSub 1 ↑n)) (HDiv.hDiv a (HPow.hPow a n))","decl":"lemma zpow_one_sub_natCast₀ (ha : a ≠ 0) (n : ℕ) : a ^ (1 - n : ℤ) = a / a ^ n := by\n  simpa using zpow_sub₀ ha 1 n\n\n"}
{"name":"zpow_ne_zero","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na : G₀\nn : Int\na✝ : Ne a 0\n⊢ Ne (HPow.hPow a n) 0","decl":"lemma zpow_ne_zero {a : G₀} : ∀ n : ℤ, a ≠ 0 → a ^ n ≠ 0\n  | (_ : ℕ) => by rw [zpow_natCast]; exact pow_ne_zero _\n  | .negSucc n => fun ha ↦ by rw [zpow_negSucc]; exact inv_ne_zero (pow_ne_zero _ ha)\n\n"}
{"name":"eq_zero_of_zpow_eq_zero","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na : G₀\nn : Int\na✝ : Eq (HPow.hPow a n) 0\n⊢ Eq a 0","decl":"lemma eq_zero_of_zpow_eq_zero {n : ℤ} : a ^ n = 0 → a = 0 := not_imp_not.1 (zpow_ne_zero _)\n\n"}
{"name":"zpow_eq_zero_iff","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na : G₀\nn : Int\nhn : Ne n 0\n⊢ Iff (Eq (HPow.hPow a n) 0) (Eq a 0)","decl":"lemma zpow_eq_zero_iff {n : ℤ} (hn : n ≠ 0) : a ^ n = 0 ↔ a = 0 :=\n  ⟨eq_zero_of_zpow_eq_zero, fun ha => ha.symm ▸ zero_zpow _ hn⟩\n\n"}
{"name":"zpow_ne_zero_iff","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na : G₀\nn : Int\nhn : Ne n 0\n⊢ Iff (Ne (HPow.hPow a n) 0) (Ne a 0)","decl":"lemma zpow_ne_zero_iff {n : ℤ} (hn : n ≠ 0) : a ^ n ≠ 0 ↔ a ≠ 0 := (zpow_eq_zero_iff hn).ne\n\n"}
{"name":"zpow_neg_mul_zpow_self","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na : G₀\nn : Int\nha : Ne a 0\n⊢ Eq (HMul.hMul (HPow.hPow a (Neg.neg n)) (HPow.hPow a n)) 1","decl":"lemma zpow_neg_mul_zpow_self (n : ℤ) (ha : a ≠ 0) : a ^ (-n) * a ^ n = 1 := by\n  rw [zpow_neg]; exact inv_mul_cancel₀ (zpow_ne_zero n ha)\n\n"}
{"name":"Ring.inverse_eq_inv","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\na : G₀\n⊢ Eq (Ring.inverse a) (Inv.inv a)","decl":"theorem Ring.inverse_eq_inv (a : G₀) : Ring.inverse a = a⁻¹ := by\n  obtain rfl | ha := eq_or_ne a 0\n  · simp\n  · exact Ring.inverse_unit (Units.mk0 a ha)\n\n"}
{"name":"Ring.inverse_eq_inv'","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : GroupWithZero G₀\n⊢ Eq Ring.inverse Inv.inv","decl":"@[simp]\ntheorem Ring.inverse_eq_inv' : (Ring.inverse : G₀ → G₀) = Inv.inv :=\n  funext Ring.inverse_eq_inv\n\n"}
{"name":"div_mul_cancel_left₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : CommGroupWithZero G₀\na : G₀\nha : Ne a 0\nb : G₀\n⊢ Eq (HDiv.hDiv a (HMul.hMul a b)) (Inv.inv b)","decl":"lemma div_mul_cancel_left₀ (ha : a ≠ 0) (b : G₀) : a / (a * b) = b⁻¹ :=\n  ha.isUnit.div_mul_cancel_left _\n\n"}
{"name":"mul_div_cancel_left_of_imp","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : CommGroupWithZero G₀\na b : G₀\nh : Eq a 0 → Eq b 0\n⊢ Eq (HDiv.hDiv (HMul.hMul a b) a) b","decl":"lemma mul_div_cancel_left_of_imp (h : a = 0 → b = 0) : a * b / a = b := by\n  rw [mul_comm, mul_div_cancel_of_imp h]\n\n"}
{"name":"mul_div_cancel_of_imp'","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : CommGroupWithZero G₀\na b : G₀\nh : Eq b 0 → Eq a 0\n⊢ Eq (HMul.hMul b (HDiv.hDiv a b)) a","decl":"lemma mul_div_cancel_of_imp' (h : b = 0 → a = 0) : b * (a / b) = a := by\n  rw [mul_comm, div_mul_cancel_of_imp h]\n\n"}
{"name":"mul_div_cancel₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : CommGroupWithZero G₀\nb a : G₀\nhb : Ne b 0\n⊢ Eq (HMul.hMul b (HDiv.hDiv a b)) a","decl":"lemma mul_div_cancel₀ (a : G₀) (hb : b ≠ 0) : b * (a / b) = a :=\n  hb.isUnit.mul_div_cancel _\n\n"}
{"name":"mul_div_mul_left","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : CommGroupWithZero G₀\nc a b : G₀\nhc : Ne c 0\n⊢ Eq (HDiv.hDiv (HMul.hMul c a) (HMul.hMul c b)) (HDiv.hDiv a b)","decl":"lemma mul_div_mul_left (a b : G₀) (hc : c ≠ 0) : c * a / (c * b) = a / b :=\n  hc.isUnit.mul_div_mul_left _ _\n\n"}
{"name":"mul_eq_mul_of_div_eq_div","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : CommGroupWithZero G₀\nb d a c : G₀\nhb : Ne b 0\nhd : Ne d 0\nh : Eq (HDiv.hDiv a b) (HDiv.hDiv c d)\n⊢ Eq (HMul.hMul a d) (HMul.hMul c b)","decl":"lemma mul_eq_mul_of_div_eq_div (a c : G₀) (hb : b ≠ 0) (hd : d ≠ 0)\n    (h : a / b = c / d) : a * d = c * b := by\n  rw [← mul_one a, ← div_self hb, ← mul_comm_div, h, div_mul_eq_mul_div, div_mul_cancel₀ _ hd]\n\n"}
{"name":"div_eq_div_iff","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : CommGroupWithZero G₀\na b c d : G₀\nhb : Ne b 0\nhd : Ne d 0\n⊢ Iff (Eq (HDiv.hDiv a b) (HDiv.hDiv c d)) (Eq (HMul.hMul a d) (HMul.hMul c b))","decl":"@[field_simps] lemma div_eq_div_iff (hb : b ≠ 0) (hd : d ≠ 0) : a / b = c / d ↔ a * d = c * b :=\n  hb.isUnit.div_eq_div_iff hd.isUnit\n\n"}
{"name":"div_eq_div_iff_div_eq_div'","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : CommGroupWithZero G₀\na b c d : G₀\nhb : Ne b 0\nhc : Ne c 0\n⊢ Iff (Eq (HDiv.hDiv a b) (HDiv.hDiv c d)) (Eq (HDiv.hDiv a c) (HDiv.hDiv b d))","decl":"/-- The `CommGroupWithZero` version of `div_eq_div_iff_div_eq_div`. -/\nlemma div_eq_div_iff_div_eq_div' (hb : b ≠ 0) (hc : c ≠ 0) : a / b = c / d ↔ a / c = b / d := by\n  conv_lhs => rw [← mul_left_inj' hb, div_mul_cancel₀ _ hb]\n  conv_rhs => rw [← mul_left_inj' hc, div_mul_cancel₀ _ hc]\n  rw [mul_comm _ c, div_mul_eq_mul_div, mul_div_assoc]\n\n"}
{"name":"div_div_cancel₀","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : CommGroupWithZero G₀\na b : G₀\nha : Ne a 0\n⊢ Eq (HDiv.hDiv a (HDiv.hDiv a b)) b","decl":"@[simp] lemma div_div_cancel₀ (ha : a ≠ 0) : a / (a / b) = b := ha.isUnit.div_div_cancel\n\n"}
{"name":"div_div_cancel'","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : CommGroupWithZero G₀\na b : G₀\nha : Ne a 0\n⊢ Eq (HDiv.hDiv a (HDiv.hDiv a b)) b","decl":"@[deprecated (since := \"2024-11-25\")] alias div_div_cancel' := div_div_cancel₀\n\n"}
{"name":"div_div_cancel_left'","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : CommGroupWithZero G₀\na b : G₀\nha : Ne a 0\n⊢ Eq (HDiv.hDiv (HDiv.hDiv a b) a) (Inv.inv b)","decl":"lemma div_div_cancel_left' (ha : a ≠ 0) : a / b / a = b⁻¹ := ha.isUnit.div_div_cancel_left\n\n"}
{"name":"div_helper","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : CommGroupWithZero G₀\na b : G₀\nh : Ne a 0\n⊢ Eq (HMul.hMul (HDiv.hDiv 1 (HMul.hMul a b)) a) (HDiv.hDiv 1 b)","decl":"lemma div_helper (b : G₀) (h : a ≠ 0) : 1 / (a * b) * a = 1 / b := by\n  rw [div_mul_eq_mul_div, one_mul, div_mul_cancel_left₀ h, one_div]\n\n"}
{"name":"div_div_div_cancel_left'","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : CommGroupWithZero G₀\nc a b : G₀\nhc : Ne c 0\n⊢ Eq (HDiv.hDiv (HDiv.hDiv c a) (HDiv.hDiv c b)) (HDiv.hDiv b a)","decl":"lemma div_div_div_cancel_left' (a b : G₀) (hc : c ≠ 0) : c / a / (c / b) = b / a := by\n  rw [div_div_div_eq, mul_comm, mul_div_mul_right _ _ hc]\n\n"}
{"name":"div_mul_div_cancel₀'","module":"Mathlib.Algebra.GroupWithZero.Units.Basic","initialProofState":"G₀ : Type u_3\ninst✝ : CommGroupWithZero G₀\na : G₀\nha : Ne a 0\nb c : G₀\n⊢ Eq (HMul.hMul (HDiv.hDiv a b) (HDiv.hDiv c a)) (HDiv.hDiv c b)","decl":"@[simp] lemma div_mul_div_cancel₀' (ha : a ≠ 0) (b c : G₀) : a / b * (c / a) = c / b := by\n  rw [mul_comm, div_mul_div_cancel₀ ha]\n\n"}
