{"name":"IsIntegralClosure.isLocalization","module":"Mathlib.RingTheory.DedekindDomain.IntegralClosure","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝¹⁴ : CommRing A\ninst✝¹³ : Field K\ninst✝¹² : Algebra A K\ninst✝¹¹ : IsFractionRing A K\nL : Type u_3\ninst✝¹⁰ : Field L\nC : Type u_4\ninst✝⁹ : CommRing C\ninst✝⁸ : Algebra K L\ninst✝⁷ : Algebra A L\ninst✝⁶ : IsScalarTower A K L\ninst✝⁵ : Algebra C L\ninst✝⁴ : IsIntegralClosure C A L\ninst✝³ : Algebra A C\ninst✝² : IsScalarTower A C L\ninst✝¹ : IsDomain A\ninst✝ : Algebra.IsAlgebraic K L\n⊢ IsLocalization (Algebra.algebraMapSubmonoid C (nonZeroDivisors A)) L","decl":"/-- If `L` is an algebraic extension of `K = Frac(A)` and `L` has no zero smul divisors by `A`,\nthen `L` is the localization of the integral closure `C` of `A` in `L` at `A⁰`. -/\ntheorem IsIntegralClosure.isLocalization [IsDomain A] [Algebra.IsAlgebraic K L] :\n    IsLocalization (Algebra.algebraMapSubmonoid C A⁰) L := by\n  haveI : IsDomain C :=\n    (IsIntegralClosure.equiv A C L (integralClosure A L)).toMulEquiv.isDomain (integralClosure A L)\n  haveI : NoZeroSMulDivisors A L := NoZeroSMulDivisors.trans A K L\n  haveI : NoZeroSMulDivisors A C := IsIntegralClosure.noZeroSMulDivisors A L\n  refine ⟨?_, fun z => ?_, fun {x y} h => ⟨1, ?_⟩⟩\n  · rintro ⟨_, x, hx, rfl⟩\n    rw [isUnit_iff_ne_zero, map_ne_zero_iff _ (IsIntegralClosure.algebraMap_injective C A L),\n      Subtype.coe_mk, map_ne_zero_iff _ (NoZeroSMulDivisors.algebraMap_injective A C)]\n    exact mem_nonZeroDivisors_iff_ne_zero.mp hx\n  · obtain ⟨m, hm⟩ :=\n      IsIntegral.exists_multiple_integral_of_isLocalization A⁰ z\n        (Algebra.IsIntegral.isIntegral (R := K) z)\n    obtain ⟨x, hx⟩ : ∃ x, algebraMap C L x = m • z := IsIntegralClosure.isIntegral_iff.mp hm\n    refine ⟨⟨x, algebraMap A C m, m, SetLike.coe_mem m, rfl⟩, ?_⟩\n    rw [Subtype.coe_mk, ← IsScalarTower.algebraMap_apply, hx, mul_comm, Submonoid.smul_def,\n      smul_def]\n  · simp only [IsIntegralClosure.algebraMap_injective C A L h]\n\n"}
{"name":"IsIntegralClosure.isLocalization_of_isSeparable","module":"Mathlib.RingTheory.DedekindDomain.IntegralClosure","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝¹⁴ : CommRing A\ninst✝¹³ : Field K\ninst✝¹² : Algebra A K\ninst✝¹¹ : IsFractionRing A K\nL : Type u_3\ninst✝¹⁰ : Field L\nC : Type u_4\ninst✝⁹ : CommRing C\ninst✝⁸ : Algebra K L\ninst✝⁷ : Algebra A L\ninst✝⁶ : IsScalarTower A K L\ninst✝⁵ : Algebra C L\ninst✝⁴ : IsIntegralClosure C A L\ninst✝³ : Algebra A C\ninst✝² : IsScalarTower A C L\ninst✝¹ : IsDomain A\ninst✝ : Algebra.IsSeparable K L\n⊢ IsLocalization (Algebra.algebraMapSubmonoid C (nonZeroDivisors A)) L","decl":"theorem IsIntegralClosure.isLocalization_of_isSeparable [IsDomain A] [Algebra.IsSeparable K L] :\n    IsLocalization (Algebra.algebraMapSubmonoid C A⁰) L :=\n  IsIntegralClosure.isLocalization A K L C\n\n"}
{"name":"IsIntegralClosure.range_le_span_dualBasis","module":"Mathlib.RingTheory.DedekindDomain.IntegralClosure","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝¹⁷ : CommRing A\ninst✝¹⁶ : Field K\ninst✝¹⁵ : Algebra A K\ninst✝¹⁴ : IsFractionRing A K\nL : Type u_3\ninst✝¹³ : Field L\nC : Type u_4\ninst✝¹² : CommRing C\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : Algebra C L\ninst✝⁷ : IsIntegralClosure C A L\ninst✝⁶ : Algebra A C\ninst✝⁵ : IsScalarTower A C L\ninst✝⁴ : FiniteDimensional K L\ninst✝³ : Algebra.IsSeparable K L\nι : Type u_5\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\nb : Basis ι K L\nhb_int : ∀ (i : ι), IsIntegral A (b i)\ninst✝ : IsIntegrallyClosed A\n⊢ LE.le (LinearMap.range (↑A (Algebra.linearMap C L))) (Submodule.span A (Set.range ⇑((Algebra.traceForm K L).dualBasis ⋯ b)))","decl":"theorem IsIntegralClosure.range_le_span_dualBasis [Algebra.IsSeparable K L] {ι : Type*} [Fintype ι]\n    [DecidableEq ι] (b : Basis ι K L) (hb_int : ∀ i, IsIntegral A (b i)) [IsIntegrallyClosed A] :\n    LinearMap.range ((Algebra.linearMap C L).restrictScalars A) ≤\n    Submodule.span A (Set.range <| (traceForm K L).dualBasis (traceForm_nondegenerate K L) b) := by\n  rw [← LinearMap.BilinForm.dualSubmodule_span_of_basis,\n    ← LinearMap.BilinForm.le_flip_dualSubmodule, Submodule.span_le]\n  rintro _ ⟨i, rfl⟩ _ ⟨y, rfl⟩\n  simp only [LinearMap.coe_restrictScalars, linearMap_apply, LinearMap.BilinForm.flip_apply,\n    traceForm_apply]\n  refine Submodule.mem_one.mpr <| IsIntegrallyClosed.isIntegral_iff.mp ?_\n  exact isIntegral_trace ((IsIntegralClosure.isIntegral A L y).algebraMap.mul (hb_int i))\n\n"}
{"name":"integralClosure_le_span_dualBasis","module":"Mathlib.RingTheory.DedekindDomain.IntegralClosure","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝¹² : CommRing A\ninst✝¹¹ : Field K\ninst✝¹⁰ : Algebra A K\ninst✝⁹ : IsFractionRing A K\nL : Type u_3\ninst✝⁸ : Field L\ninst✝⁷ : Algebra K L\ninst✝⁶ : Algebra A L\ninst✝⁵ : IsScalarTower A K L\ninst✝⁴ : FiniteDimensional K L\ninst✝³ : Algebra.IsSeparable K L\nι : Type u_5\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\nb : Basis ι K L\nhb_int : ∀ (i : ι), IsIntegral A (b i)\ninst✝ : IsIntegrallyClosed A\n⊢ LE.le (Subalgebra.toSubmodule (integralClosure A L)) (Submodule.span A (Set.range ⇑((Algebra.traceForm K L).dualBasis ⋯ b)))","decl":"theorem integralClosure_le_span_dualBasis [Algebra.IsSeparable K L] {ι : Type*} [Fintype ι]\n    [DecidableEq ι] (b : Basis ι K L) (hb_int : ∀ i, IsIntegral A (b i)) [IsIntegrallyClosed A] :\n    Subalgebra.toSubmodule (integralClosure A L) ≤\n    Submodule.span A (Set.range <| (traceForm K L).dualBasis (traceForm_nondegenerate K L) b) := by\n  refine le_trans ?_ (IsIntegralClosure.range_le_span_dualBasis (integralClosure A L) b hb_int)\n  intro x hx\n  exact ⟨⟨x, hx⟩, rfl⟩\n\n"}
{"name":"exists_integral_multiples","module":"Mathlib.RingTheory.DedekindDomain.IntegralClosure","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝⁹ : CommRing A\ninst✝⁸ : Field K\ninst✝⁷ : Algebra A K\ninst✝⁶ : IsFractionRing A K\nL : Type u_3\ninst✝⁵ : Field L\ninst✝⁴ : Algebra K L\ninst✝³ : Algebra A L\ninst✝² : IsScalarTower A K L\ninst✝¹ : FiniteDimensional K L\ninst✝ : IsDomain A\ns : Finset L\n⊢ Exists fun y => And (Ne y 0) (∀ (x : L), Membership.mem s x → IsIntegral A (HSMul.hSMul y x))","decl":"/-- Send a set of `x`s in a finite extension `L` of the fraction field of `R`\nto `(y : R) • x ∈ integralClosure R L`. -/\ntheorem exists_integral_multiples (s : Finset L) :\n    ∃ y ≠ (0 : A), ∀ x ∈ s, IsIntegral A (y • x) :=\n  have := IsLocalization.isAlgebraic K (nonZeroDivisors A)\n  have := Algebra.IsAlgebraic.trans' A (algebraMap K L).injective\n  Algebra.IsAlgebraic.exists_integral_multiples (IsScalarTower.algebraMap_eq A K L ▸\n    (algebraMap K L).injective.comp (IsFractionRing.injective _ _)) _\n\n"}
{"name":"FiniteDimensional.exists_is_basis_integral","module":"Mathlib.RingTheory.DedekindDomain.IntegralClosure","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝⁹ : CommRing A\ninst✝⁸ : Field K\ninst✝⁷ : Algebra A K\ninst✝⁶ : IsFractionRing A K\nL : Type u_3\ninst✝⁵ : Field L\ninst✝⁴ : Algebra K L\ninst✝³ : Algebra A L\ninst✝² : IsScalarTower A K L\ninst✝¹ : FiniteDimensional K L\ninst✝ : IsDomain A\n⊢ Exists fun s => Exists fun b => ∀ (x : Subtype fun x => Membership.mem s x), IsIntegral A (b x)","decl":"/-- If `L` is a finite extension of `K = Frac(A)`,\nthen `L` has a basis over `A` consisting of integral elements. -/\ntheorem FiniteDimensional.exists_is_basis_integral :\n    ∃ (s : Finset L) (b : Basis s K L), ∀ x, IsIntegral A (b x) := by\n  letI := Classical.decEq L\n  letI : IsNoetherian K L := IsNoetherian.iff_fg.2 inferInstance\n  let s' := IsNoetherian.finsetBasisIndex K L\n  let bs' := IsNoetherian.finsetBasis K L\n  obtain ⟨y, hy, his'⟩ := exists_integral_multiples A K (Finset.univ.image bs')\n  have hy' : algebraMap A L y ≠ 0 := by\n    refine mt ((injective_iff_map_eq_zero (algebraMap A L)).mp ?_ _) hy\n    rw [IsScalarTower.algebraMap_eq A K L]\n    exact (algebraMap K L).injective.comp (IsFractionRing.injective A K)\n  refine ⟨s', bs'.map {Algebra.lmul _ _ (algebraMap A L y) with\n    toFun := fun x => algebraMap A L y * x\n    invFun := fun x => (algebraMap A L y)⁻¹ * x\n    left_inv := ?_\n    right_inv := ?_}, ?_⟩\n  · intro x; simp only [inv_mul_cancel_left₀ hy']\n  · intro x; simp only [mul_inv_cancel_left₀ hy']\n  · rintro ⟨x', hx'⟩\n    simp only [Algebra.smul_def, Finset.mem_image, exists_prop, Finset.mem_univ,\n      true_and] at his'\n    simp only [Basis.map_apply, LinearEquiv.coe_mk]\n    exact his' _ ⟨_, rfl⟩\n\n"}
{"name":"IsIntegralClosure.isNoetherian","module":"Mathlib.RingTheory.DedekindDomain.IntegralClosure","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝¹⁷ : CommRing A\ninst✝¹⁶ : Field K\ninst✝¹⁵ : Algebra A K\ninst✝¹⁴ : IsFractionRing A K\nL : Type u_3\ninst✝¹³ : Field L\nC : Type u_4\ninst✝¹² : CommRing C\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : Algebra C L\ninst✝⁷ : IsIntegralClosure C A L\ninst✝⁶ : Algebra A C\ninst✝⁵ : IsScalarTower A C L\ninst✝⁴ : FiniteDimensional K L\ninst✝³ : IsDomain A\ninst✝² : Algebra.IsSeparable K L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsNoetherianRing A\n⊢ IsNoetherian A C","decl":"/-- If `L` is a finite separable extension of `K = Frac(A)`, where `A` is\nintegrally closed and Noetherian, the integral closure `C` of `A` in `L` is\nNoetherian over `A`. -/\ntheorem IsIntegralClosure.isNoetherian [IsIntegrallyClosed A] [IsNoetherianRing A] :\n    IsNoetherian A C := by\n  haveI := Classical.decEq L\n  obtain ⟨s, b, hb_int⟩ := FiniteDimensional.exists_is_basis_integral A K L\n  let b' := (traceForm K L).dualBasis (traceForm_nondegenerate K L) b\n  letI := isNoetherian_span_of_finite A (Set.finite_range b')\n  let f : C →ₗ[A] Submodule.span A (Set.range b') :=\n    (Submodule.inclusion (IsIntegralClosure.range_le_span_dualBasis C b hb_int)).comp\n      ((Algebra.linearMap C L).restrictScalars A).rangeRestrict\n  refine isNoetherian_of_ker_bot f ?_\n  rw [LinearMap.ker_comp, Submodule.ker_inclusion, Submodule.comap_bot, LinearMap.ker_codRestrict]\n  exact LinearMap.ker_eq_bot_of_injective (IsIntegralClosure.algebraMap_injective C A L)\n\n"}
{"name":"IsIntegralClosure.isNoetherianRing","module":"Mathlib.RingTheory.DedekindDomain.IntegralClosure","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝¹⁷ : CommRing A\ninst✝¹⁶ : Field K\ninst✝¹⁵ : Algebra A K\ninst✝¹⁴ : IsFractionRing A K\nL : Type u_3\ninst✝¹³ : Field L\nC : Type u_4\ninst✝¹² : CommRing C\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : Algebra C L\ninst✝⁷ : IsIntegralClosure C A L\ninst✝⁶ : Algebra A C\ninst✝⁵ : IsScalarTower A C L\ninst✝⁴ : FiniteDimensional K L\ninst✝³ : IsDomain A\ninst✝² : Algebra.IsSeparable K L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsNoetherianRing A\n⊢ IsNoetherianRing C","decl":"/-- If `L` is a finite separable extension of `K = Frac(A)`, where `A` is\nintegrally closed and Noetherian, the integral closure `C` of `A` in `L` is\nNoetherian. -/\ntheorem IsIntegralClosure.isNoetherianRing [IsIntegrallyClosed A] [IsNoetherianRing A] :\n    IsNoetherianRing C :=\n  isNoetherianRing_iff.mpr <| isNoetherian_of_tower A (IsIntegralClosure.isNoetherian A K L C)\n\n"}
{"name":"IsIntegralClosure.finite","module":"Mathlib.RingTheory.DedekindDomain.IntegralClosure","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝¹⁷ : CommRing A\ninst✝¹⁶ : Field K\ninst✝¹⁵ : Algebra A K\ninst✝¹⁴ : IsFractionRing A K\nL : Type u_3\ninst✝¹³ : Field L\nC : Type u_4\ninst✝¹² : CommRing C\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : Algebra C L\ninst✝⁷ : IsIntegralClosure C A L\ninst✝⁶ : Algebra A C\ninst✝⁵ : IsScalarTower A C L\ninst✝⁴ : FiniteDimensional K L\ninst✝³ : IsDomain A\ninst✝² : Algebra.IsSeparable K L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsNoetherianRing A\n⊢ Module.Finite A C","decl":"/-- If `L` is a finite separable extension of `K = Frac(A)`, where `A` is\nintegrally closed and Noetherian, the integral closure `C` of `A` in `L` is\nfinite over `A`. -/\ntheorem IsIntegralClosure.finite [IsIntegrallyClosed A] [IsNoetherianRing A] :\n    Module.Finite A C := by\n  haveI := IsIntegralClosure.isNoetherian A K L C\n  exact Module.IsNoetherian.finite A C\n\n"}
{"name":"IsIntegralClosure.module_free","module":"Mathlib.RingTheory.DedekindDomain.IntegralClosure","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝¹⁷ : CommRing A\ninst✝¹⁶ : Field K\ninst✝¹⁵ : Algebra A K\ninst✝¹⁴ : IsFractionRing A K\nL : Type u_3\ninst✝¹³ : Field L\nC : Type u_4\ninst✝¹² : CommRing C\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : Algebra C L\ninst✝⁷ : IsIntegralClosure C A L\ninst✝⁶ : Algebra A C\ninst✝⁵ : IsScalarTower A C L\ninst✝⁴ : FiniteDimensional K L\ninst✝³ : IsDomain A\ninst✝² : Algebra.IsSeparable K L\ninst✝¹ : NoZeroSMulDivisors A L\ninst✝ : IsPrincipalIdealRing A\n⊢ Module.Free A C","decl":"/-- If `L` is a finite separable extension of `K = Frac(A)`, where `A` is a principal ring\nand `L` has no zero smul divisors by `A`, the integral closure `C` of `A` in `L` is\na free `A`-module. -/\ntheorem IsIntegralClosure.module_free [NoZeroSMulDivisors A L] [IsPrincipalIdealRing A] :\n    Module.Free A C :=\n  haveI : NoZeroSMulDivisors A C := IsIntegralClosure.noZeroSMulDivisors A L\n  haveI : IsNoetherian A C := IsIntegralClosure.isNoetherian A K L _\n  inferInstance\n\n"}
{"name":"IsIntegralClosure.rank","module":"Mathlib.RingTheory.DedekindDomain.IntegralClosure","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝¹⁷ : CommRing A\ninst✝¹⁶ : Field K\ninst✝¹⁵ : Algebra A K\ninst✝¹⁴ : IsFractionRing A K\nL : Type u_3\ninst✝¹³ : Field L\nC : Type u_4\ninst✝¹² : CommRing C\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : Algebra C L\ninst✝⁷ : IsIntegralClosure C A L\ninst✝⁶ : Algebra A C\ninst✝⁵ : IsScalarTower A C L\ninst✝⁴ : FiniteDimensional K L\ninst✝³ : IsDomain A\ninst✝² : Algebra.IsSeparable K L\ninst✝¹ : IsPrincipalIdealRing A\ninst✝ : NoZeroSMulDivisors A L\n⊢ Eq (Module.finrank A C) (Module.finrank K L)","decl":"/-- If `L` is a finite separable extension of `K = Frac(A)`, where `A` is a principal ring\nand `L` has no zero smul divisors by `A`, the `A`-rank of the integral closure `C` of `A` in `L`\nis equal to the `K`-rank of `L`. -/\ntheorem IsIntegralClosure.rank [IsPrincipalIdealRing A] [NoZeroSMulDivisors A L] :\n    Module.finrank A C = Module.finrank K L := by\n  haveI : Module.Free A C := IsIntegralClosure.module_free A K L C\n  haveI : IsNoetherian A C := IsIntegralClosure.isNoetherian A K L C\n  haveI : IsLocalization (Algebra.algebraMapSubmonoid C A⁰) L :=\n    IsIntegralClosure.isLocalization A K L C\n  let b := Basis.localizationLocalization K A⁰ L (Module.Free.chooseBasis A C)\n  rw [Module.finrank_eq_card_chooseBasisIndex, Module.finrank_eq_card_basis b]\n\n"}
{"name":"integralClosure.isNoetherianRing","module":"Mathlib.RingTheory.DedekindDomain.IntegralClosure","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝¹² : CommRing A\ninst✝¹¹ : Field K\ninst✝¹⁰ : Algebra A K\ninst✝⁹ : IsFractionRing A K\nL : Type u_3\ninst✝⁸ : Field L\ninst✝⁷ : Algebra K L\ninst✝⁶ : Algebra A L\ninst✝⁵ : IsScalarTower A K L\ninst✝⁴ : FiniteDimensional K L\ninst✝³ : IsDomain A\ninst✝² : Algebra.IsSeparable K L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsNoetherianRing A\n⊢ IsNoetherianRing (Subtype fun x => Membership.mem (integralClosure A L) x)","decl":"/-- If `L` is a finite separable extension of `K = Frac(A)`, where `A` is\nintegrally closed and Noetherian, the integral closure of `A` in `L` is\nNoetherian. -/\ntheorem integralClosure.isNoetherianRing [IsIntegrallyClosed A] [IsNoetherianRing A] :\n    IsNoetherianRing (integralClosure A L) :=\n  IsIntegralClosure.isNoetherianRing A K L (integralClosure A L)\n\n"}
{"name":"IsIntegralClosure.isDedekindDomain","module":"Mathlib.RingTheory.DedekindDomain.IntegralClosure","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝¹⁷ : CommRing A\ninst✝¹⁶ : Field K\ninst✝¹⁵ : Algebra A K\ninst✝¹⁴ : IsFractionRing A K\nL : Type u_3\ninst✝¹³ : Field L\nC : Type u_4\ninst✝¹² : CommRing C\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : Algebra C L\ninst✝⁷ : IsIntegralClosure C A L\ninst✝⁶ : Algebra A C\ninst✝⁵ : IsScalarTower A C L\ninst✝⁴ : FiniteDimensional K L\ninst✝³ : IsDomain A\ninst✝² : Algebra.IsSeparable K L\ninst✝¹ : IsDomain C\ninst✝ : IsDedekindDomain A\n⊢ IsDedekindDomain C","decl":"/-- If `L` is a finite separable extension of `K = Frac(A)`, where `A` is a Dedekind domain,\nthe integral closure `C` of `A` in `L` is a Dedekind domain.\n\nThis cannot be an instance since `A`, `K` or `L` can't be inferred. See also the instance\n`integralClosure.isDedekindDomain_fractionRing` where `K := FractionRing A`\nand `C := integralClosure A L`. -/\ntheorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=\n  have : IsFractionRing C L := IsIntegralClosure.isFractionRing_of_finite_extension A K L C\n  have : Algebra.IsIntegral A C := IsIntegralClosure.isIntegral_algebra A L\n  { IsIntegralClosure.isNoetherianRing A K L C,\n    Ring.DimensionLEOne.isIntegralClosure A L C,\n    (isIntegrallyClosed_iff L).mpr fun {x} hx =>\n      ⟨IsIntegralClosure.mk' C x (isIntegral_trans (R := A) _ hx),\n        IsIntegralClosure.algebraMap_mk' _ _ _⟩ with : IsDedekindDomain C }\n\n"}
{"name":"integralClosure.isDedekindDomain","module":"Mathlib.RingTheory.DedekindDomain.IntegralClosure","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝¹¹ : CommRing A\ninst✝¹⁰ : Field K\ninst✝⁹ : Algebra A K\ninst✝⁸ : IsFractionRing A K\nL : Type u_3\ninst✝⁷ : Field L\ninst✝⁶ : Algebra K L\ninst✝⁵ : Algebra A L\ninst✝⁴ : IsScalarTower A K L\ninst✝³ : FiniteDimensional K L\ninst✝² : IsDomain A\ninst✝¹ : Algebra.IsSeparable K L\ninst✝ : IsDedekindDomain A\n⊢ IsDedekindDomain (Subtype fun x => Membership.mem (integralClosure A L) x)","decl":"/-- If `L` is a finite separable extension of `K = Frac(A)`, where `A` is a Dedekind domain,\nthe integral closure of `A` in `L` is a Dedekind domain.\n\nThis cannot be an instance since `K` can't be inferred. See also the instance\n`integralClosure.isDedekindDomain_fractionRing` where `K := FractionRing A`. -/\ntheorem integralClosure.isDedekindDomain [IsDedekindDomain A] :\n    IsDedekindDomain (integralClosure A L) :=\n  IsIntegralClosure.isDedekindDomain A K L (integralClosure A L)\n\n"}
{"name":"integralClosure.isDedekindDomain_fractionRing","module":"Mathlib.RingTheory.DedekindDomain.IntegralClosure","initialProofState":"A : Type u_1\ninst✝⁸ : CommRing A\nL : Type u_3\ninst✝⁷ : Field L\ninst✝⁶ : Algebra A L\ninst✝⁵ : IsDomain A\ninst✝⁴ : Algebra (FractionRing A) L\ninst✝³ : IsScalarTower A (FractionRing A) L\ninst✝² : FiniteDimensional (FractionRing A) L\ninst✝¹ : Algebra.IsSeparable (FractionRing A) L\ninst✝ : IsDedekindDomain A\n⊢ IsDedekindDomain (Subtype fun x => Membership.mem (integralClosure A L) x)","decl":"/-- If `L` is a finite separable extension of `Frac(A)`, where `A` is a Dedekind domain,\nthe integral closure of `A` in `L` is a Dedekind domain.\n\nSee also the lemma `integralClosure.isDedekindDomain` where you can choose\nthe field of fractions yourself. -/\ninstance integralClosure.isDedekindDomain_fractionRing [IsDedekindDomain A] :\n    IsDedekindDomain (integralClosure A L) :=\n  integralClosure.isDedekindDomain A (FractionRing A) L\n\n"}
{"name":"instIsLocalizationAlgebraMapSubmonoidNonZeroDivisorsFractionRingOfNoZeroSMulDivisorsOfFiniteOfIsIntegrallyClosed","module":"Mathlib.RingTheory.DedekindDomain.IntegralClosure","initialProofState":"A : Type u_1\ninst✝⁷ : CommRing A\nC : Type u_4\ninst✝⁶ : CommRing C\ninst✝⁵ : Algebra A C\ninst✝⁴ : IsDomain A\ninst✝³ : IsDomain C\ninst✝² : NoZeroSMulDivisors A C\ninst✝¹ : Module.Finite A C\ninst✝ : IsIntegrallyClosed C\n⊢ IsLocalization (Algebra.algebraMapSubmonoid C (nonZeroDivisors A)) (FractionRing C)","decl":"attribute [local instance] FractionRing.liftAlgebra in\ninstance [NoZeroSMulDivisors A C] [Module.Finite A C] [IsIntegrallyClosed C] :\n    IsLocalization (Algebra.algebraMapSubmonoid C A⁰) (FractionRing C) :=\n  IsIntegralClosure.isLocalization _ (FractionRing A) _ _\n\n"}
