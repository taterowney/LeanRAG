{"name":"LinearMap.range_coe","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_10\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F τ₁₂ M M₂\ninst✝ : RingHomSurjective τ₁₂\nf : F\n⊢ Eq (↑(LinearMap.range f)) (Set.range ⇑f)","decl":"theorem range_coe [RingHomSurjective τ₁₂] (f : F) : (range f : Set M₂) = Set.range f :=\n  rfl\n\n"}
{"name":"LinearMap.range_toAddSubmonoid","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M\ninst✝¹ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝ : RingHomSurjective τ₁₂\nf : LinearMap τ₁₂ M M₂\n⊢ Eq (LinearMap.range f).toAddSubmonoid (AddMonoidHom.mrange f)","decl":"theorem range_toAddSubmonoid [RingHomSurjective τ₁₂] (f : M →ₛₗ[τ₁₂] M₂) :\n    f.range.toAddSubmonoid = AddMonoidHom.mrange f :=\n  rfl\n\n"}
{"name":"LinearMap.mem_range","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_10\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F τ₁₂ M M₂\ninst✝ : RingHomSurjective τ₁₂\nf : F\nx : M₂\n⊢ Iff (Membership.mem (LinearMap.range f) x) (Exists fun y => Eq (f y) x)","decl":"@[simp]\ntheorem mem_range [RingHomSurjective τ₁₂] {f : F} {x} : x ∈ range f ↔ ∃ y, f y = x :=\n  Iff.rfl\n\n"}
{"name":"LinearMap.range_eq_map","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_10\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F τ₁₂ M M₂\ninst✝ : RingHomSurjective τ₁₂\nf : F\n⊢ Eq (LinearMap.range f) (Submodule.map f Top.top)","decl":"theorem range_eq_map [RingHomSurjective τ₁₂] (f : F) : range f = map f ⊤ := by\n  ext\n  simp\n\n"}
{"name":"LinearMap.mem_range_self","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_10\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F τ₁₂ M M₂\ninst✝ : RingHomSurjective τ₁₂\nf : F\nx : M\n⊢ Membership.mem (LinearMap.range f) (f x)","decl":"theorem mem_range_self [RingHomSurjective τ₁₂] (f : F) (x : M) : f x ∈ range f :=\n  ⟨x, rfl⟩\n\n"}
{"name":"LinearMap.range_id","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (LinearMap.range LinearMap.id) Top.top","decl":"@[simp]\ntheorem range_id : range (LinearMap.id : M →ₗ[R] M) = ⊤ :=\n  SetLike.coe_injective Set.range_id\n\n"}
{"name":"LinearMap.range_comp","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nR₃ : Type u_3\nM : Type u_5\nM₂ : Type u_6\nM₃ : Type u_7\ninst✝¹² : Semiring R\ninst✝¹¹ : Semiring R₂\ninst✝¹⁰ : Semiring R₃\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid M₂\ninst✝⁷ : AddCommMonoid M₃\ninst✝⁶ : Module R M\ninst✝⁵ : Module R₂ M₂\ninst✝⁴ : Module R₃ M₃\nτ₁₂ : RingHom R R₂\nτ₂₃ : RingHom R₂ R₃\nτ₁₃ : RingHom R R₃\ninst✝³ : RingHomCompTriple τ₁₂ τ₂₃ τ₁₃\ninst✝² : RingHomSurjective τ₁₂\ninst✝¹ : RingHomSurjective τ₂₃\ninst✝ : RingHomSurjective τ₁₃\nf : LinearMap τ₁₂ M M₂\ng : LinearMap τ₂₃ M₂ M₃\n⊢ Eq (LinearMap.range (g.comp f)) (Submodule.map g (LinearMap.range f))","decl":"theorem range_comp [RingHomSurjective τ₁₂] [RingHomSurjective τ₂₃] [RingHomSurjective τ₁₃]\n    (f : M →ₛₗ[τ₁₂] M₂) (g : M₂ →ₛₗ[τ₂₃] M₃) : range (g.comp f : M →ₛₗ[τ₁₃] M₃) = map g (range f) :=\n  SetLike.coe_injective (Set.range_comp g f)\n\n"}
{"name":"LinearMap.range_comp_le_range","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nR₃ : Type u_3\nM : Type u_5\nM₂ : Type u_6\nM₃ : Type u_7\ninst✝¹¹ : Semiring R\ninst✝¹⁰ : Semiring R₂\ninst✝⁹ : Semiring R₃\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : AddCommMonoid M₃\ninst✝⁵ : Module R M\ninst✝⁴ : Module R₂ M₂\ninst✝³ : Module R₃ M₃\nτ₁₂ : RingHom R R₂\nτ₂₃ : RingHom R₂ R₃\nτ₁₃ : RingHom R R₃\ninst✝² : RingHomCompTriple τ₁₂ τ₂₃ τ₁₃\ninst✝¹ : RingHomSurjective τ₂₃\ninst✝ : RingHomSurjective τ₁₃\nf : LinearMap τ₁₂ M M₂\ng : LinearMap τ₂₃ M₂ M₃\n⊢ LE.le (LinearMap.range (g.comp f)) (LinearMap.range g)","decl":"theorem range_comp_le_range [RingHomSurjective τ₂₃] [RingHomSurjective τ₁₃] (f : M →ₛₗ[τ₁₂] M₂)\n    (g : M₂ →ₛₗ[τ₂₃] M₃) : range (g.comp f : M →ₛₗ[τ₁₃] M₃) ≤ range g :=\n  SetLike.coe_mono (Set.range_comp_subset_range f g)\n\n"}
{"name":"LinearMap.range_eq_top","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_10\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F τ₁₂ M M₂\ninst✝ : RingHomSurjective τ₁₂\nf : F\n⊢ Iff (Eq (LinearMap.range f) Top.top) (Function.Surjective ⇑f)","decl":"theorem range_eq_top [RingHomSurjective τ₁₂] {f : F} :\n    range f = ⊤ ↔ Surjective f := by\n  rw [SetLike.ext'_iff, range_coe, top_coe, Set.range_eq_univ]\n\n"}
{"name":"LinearMap.range_eq_top_of_surjective","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_10\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F τ₁₂ M M₂\ninst✝ : RingHomSurjective τ₁₂\nf : F\nhf : Function.Surjective ⇑f\n⊢ Eq (LinearMap.range f) Top.top","decl":"theorem range_eq_top_of_surjective [RingHomSurjective τ₁₂] (f : F) (hf : Surjective f) :\n    range f = ⊤ := range_eq_top.2 hf\n\n"}
{"name":"LinearMap.range_le_iff_comap","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_10\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F τ₁₂ M M₂\ninst✝ : RingHomSurjective τ₁₂\nf : F\np : Submodule R₂ M₂\n⊢ Iff (LE.le (LinearMap.range f) p) (Eq (Submodule.comap f p) Top.top)","decl":"theorem range_le_iff_comap [RingHomSurjective τ₁₂] {f : F} {p : Submodule R₂ M₂} :\n    range f ≤ p ↔ comap f p = ⊤ := by rw [range_eq_map, map_le_iff_le_comap, eq_top_iff]\n\n"}
{"name":"LinearMap.map_le_range","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_10\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F τ₁₂ M M₂\ninst✝ : RingHomSurjective τ₁₂\nf : F\np : Submodule R M\n⊢ LE.le (Submodule.map f p) (LinearMap.range f)","decl":"theorem map_le_range [RingHomSurjective τ₁₂] {f : F} {p : Submodule R M} : map f p ≤ range f :=\n  SetLike.coe_mono (Set.image_subset_range f p)\n\n"}
{"name":"LinearMap.range_neg","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_11\nR₂ : Type u_12\nM : Type u_13\nM₂ : Type u_14\ninst✝⁶ : Semiring R\ninst✝⁵ : Ring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M\ninst✝¹ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝ : RingHomSurjective τ₁₂\nf : LinearMap τ₁₂ M M₂\n⊢ Eq (LinearMap.range (Neg.neg f)) (LinearMap.range f)","decl":"@[simp]\ntheorem range_neg {R : Type*} {R₂ : Type*} {M : Type*} {M₂ : Type*} [Semiring R] [Ring R₂]\n    [AddCommMonoid M] [AddCommGroup M₂] [Module R M] [Module R₂ M₂] {τ₁₂ : R →+* R₂}\n    [RingHomSurjective τ₁₂] (f : M →ₛₗ[τ₁₂] M₂) : LinearMap.range (-f) = LinearMap.range f := by\n  change range ((-LinearMap.id : M₂ →ₗ[R₂] M₂).comp f) = _\n  rw [range_comp, Submodule.map_neg, Submodule.map_id]\n\n"}
{"name":"LinearMap.range_domRestrict","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nM : Type u_5\nM₂ : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nK : Submodule R M\nf : LinearMap (RingHom.id R) M M₂\n⊢ Eq (LinearMap.range (f.domRestrict K)) (Submodule.map f K)","decl":"@[simp] lemma range_domRestrict [Module R M₂] (K : Submodule R M) (f : M →ₗ[R] M₂) :\n    range (domRestrict f K) = K.map f := by ext; simp\n\n"}
{"name":"LinearMap.range_domRestrict_le_range","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M\ninst✝¹ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝ : RingHomSurjective τ₁₂\nf : LinearMap τ₁₂ M M₂\nS : Submodule R M\n⊢ LE.le (LinearMap.range (f.domRestrict S)) (LinearMap.range f)","decl":"lemma range_domRestrict_le_range [RingHomSurjective τ₁₂] (f : M →ₛₗ[τ₁₂] M₂) (S : Submodule R M) :\n    LinearMap.range (f.domRestrict S) ≤ LinearMap.range f := by\n  rintro x ⟨⟨y, hy⟩, rfl⟩\n  exact LinearMap.mem_range_self f y\n\n"}
{"name":"AddMonoidHom.coe_toIntLinearMap_range","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"M : Type u_11\nM₂ : Type u_12\ninst✝¹ : AddCommGroup M\ninst✝ : AddCommGroup M₂\nf : AddMonoidHom M M₂\n⊢ Eq (LinearMap.range f.toIntLinearMap) (AddSubgroup.toIntSubmodule f.range)","decl":"@[simp]\ntheorem _root_.AddMonoidHom.coe_toIntLinearMap_range {M M₂ : Type*} [AddCommGroup M]\n    [AddCommGroup M₂] (f : M →+ M₂) :\n    LinearMap.range f.toIntLinearMap = AddSubgroup.toIntSubmodule f.range := rfl\n\n"}
{"name":"Submodule.map_comap_eq_of_le","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_10\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F τ₁₂ M M₂\ninst✝ : RingHomSurjective τ₁₂\nf : F\np : Submodule R₂ M₂\nh : LE.le p (LinearMap.range f)\n⊢ Eq (Submodule.map f (Submodule.comap f p)) p","decl":"lemma _root_.Submodule.map_comap_eq_of_le [RingHomSurjective τ₁₂] {f : F} {p : Submodule R₂ M₂}\n    (h : p ≤ LinearMap.range f) : (p.comap f).map f = p :=\n  SetLike.coe_injective <| Set.image_preimage_eq_of_subset h\n\n"}
{"name":"LinearMap.iterateRange_coe","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : LinearMap (RingHom.id R) M M\nn : Nat\n⊢ Eq (f.iterateRange n) (LinearMap.range (HPow.hPow f n))","decl":"/-- The decreasing sequence of submodules consisting of the ranges of the iterates of a linear map.\n-/\n@[simps]\ndef iterateRange (f : M →ₗ[R] M) : ℕ →o (Submodule R M)ᵒᵈ where\n  toFun n := LinearMap.range (f ^ n)\n  monotone' n m w x h := by\n    obtain ⟨c, rfl⟩ := Nat.exists_eq_add_of_le  w\n    rw [LinearMap.mem_range] at h\n    obtain ⟨m, rfl⟩ := h\n    rw [LinearMap.mem_range]\n    use (f ^ c) m\n    rw [pow_add, LinearMap.mul_apply]\n\n"}
{"name":"LinearMap.range_codRestrict","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M\ninst✝¹ : Module R₂ M₂\nτ₂₁ : RingHom R₂ R\ninst✝ : RingHomSurjective τ₂₁\np : Submodule R M\nf : LinearMap τ₂₁ M₂ M\nhf : ∀ (c : M₂), Membership.mem p (f c)\n⊢ Eq (LinearMap.range (LinearMap.codRestrict p f hf)) (Submodule.comap p.subtype (LinearMap.range f))","decl":"theorem range_codRestrict {τ₂₁ : R₂ →+* R} [RingHomSurjective τ₂₁] (p : Submodule R M)\n    (f : M₂ →ₛₗ[τ₂₁] M) (hf) :\n    range (codRestrict p f hf) = comap p.subtype (LinearMap.range f) := by\n  simpa only [range_eq_map] using map_codRestrict _ _ _ _\n\n"}
{"name":"Submodule.map_comap_eq","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_10\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F τ₁₂ M M₂\ninst✝ : RingHomSurjective τ₁₂\nf : F\nq : Submodule R₂ M₂\n⊢ Eq (Submodule.map f (Submodule.comap f q)) (Min.min (LinearMap.range f) q)","decl":"theorem _root_.Submodule.map_comap_eq [RingHomSurjective τ₁₂] (f : F) (q : Submodule R₂ M₂) :\n    map f (comap f q) = range f ⊓ q :=\n  le_antisymm (le_inf map_le_range (map_comap_le _ _)) <| by\n    rintro _ ⟨⟨x, _, rfl⟩, hx⟩; exact ⟨x, hx, rfl⟩\n\n"}
{"name":"Submodule.map_comap_eq_self","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_10\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F τ₁₂ M M₂\ninst✝ : RingHomSurjective τ₁₂\nf : F\nq : Submodule R₂ M₂\nh : LE.le q (LinearMap.range f)\n⊢ Eq (Submodule.map f (Submodule.comap f q)) q","decl":"theorem _root_.Submodule.map_comap_eq_self [RingHomSurjective τ₁₂] {f : F} {q : Submodule R₂ M₂}\n    (h : q ≤ range f) : map f (comap f q) = q := by rwa [Submodule.map_comap_eq, inf_eq_right]\n\n"}
{"name":"LinearMap.range_zero","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M\ninst✝¹ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝ : RingHomSurjective τ₁₂\n⊢ Eq (LinearMap.range 0) Bot.bot","decl":"@[simp]\ntheorem range_zero [RingHomSurjective τ₁₂] : range (0 : M →ₛₗ[τ₁₂] M₂) = ⊥ := by\n  simpa only [range_eq_map] using Submodule.map_zero _\n\n"}
{"name":"LinearMap.range_le_bot_iff","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M\ninst✝¹ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝ : RingHomSurjective τ₁₂\nf : LinearMap τ₁₂ M M₂\n⊢ Iff (LE.le (LinearMap.range f) Bot.bot) (Eq f 0)","decl":"theorem range_le_bot_iff (f : M →ₛₗ[τ₁₂] M₂) : range f ≤ ⊥ ↔ f = 0 := by\n  rw [range_le_iff_comap]; exact ker_eq_top\n\n"}
{"name":"LinearMap.range_eq_bot","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M\ninst✝¹ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝ : RingHomSurjective τ₁₂\nf : LinearMap τ₁₂ M M₂\n⊢ Iff (Eq (LinearMap.range f) Bot.bot) (Eq f 0)","decl":"theorem range_eq_bot {f : M →ₛₗ[τ₁₂] M₂} : range f = ⊥ ↔ f = 0 := by\n  rw [← range_le_bot_iff, le_bot_iff]\n\n"}
{"name":"LinearMap.range_le_ker_iff","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nR₃ : Type u_3\nM : Type u_5\nM₂ : Type u_6\nM₃ : Type u_7\ninst✝¹⁰ : Semiring R\ninst✝⁹ : Semiring R₂\ninst✝⁸ : Semiring R₃\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : AddCommMonoid M₃\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\ninst✝² : Module R₃ M₃\nτ₁₂ : RingHom R R₂\nτ₂₃ : RingHom R₂ R₃\nτ₁₃ : RingHom R R₃\ninst✝¹ : RingHomCompTriple τ₁₂ τ₂₃ τ₁₃\ninst✝ : RingHomSurjective τ₁₂\nf : LinearMap τ₁₂ M M₂\ng : LinearMap τ₂₃ M₂ M₃\n⊢ Iff (LE.le (LinearMap.range f) (LinearMap.ker g)) (Eq (g.comp f) 0)","decl":"theorem range_le_ker_iff {f : M →ₛₗ[τ₁₂] M₂} {g : M₂ →ₛₗ[τ₂₃] M₃} :\n    range f ≤ ker g ↔ (g.comp f : M →ₛₗ[τ₁₃] M₃) = 0 :=\n  ⟨fun h => ker_eq_top.1 <| eq_top_iff'.2 fun _ => h <| ⟨_, rfl⟩, fun h x hx =>\n    mem_ker.2 <| Exists.elim hx fun y hy => by rw [← hy, ← comp_apply, h, zero_apply]⟩\n\n"}
{"name":"LinearMap.comap_le_comap_iff","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_10\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F τ₁₂ M M₂\ninst✝ : RingHomSurjective τ₁₂\nf : F\nhf : Eq (LinearMap.range f) Top.top\np p' : Submodule R₂ M₂\n⊢ Iff (LE.le (Submodule.comap f p) (Submodule.comap f p')) (LE.le p p')","decl":"theorem comap_le_comap_iff {f : F} (hf : range f = ⊤) {p p'} : comap f p ≤ comap f p' ↔ p ≤ p' :=\n  ⟨fun H ↦ by rwa [SetLike.le_def, (range_eq_top.1 hf).forall], comap_mono⟩\n\n"}
{"name":"LinearMap.comap_injective","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_10\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F τ₁₂ M M₂\ninst✝ : RingHomSurjective τ₁₂\nf : F\nhf : Eq (LinearMap.range f) Top.top\n⊢ Function.Injective (Submodule.comap f)","decl":"theorem comap_injective {f : F} (hf : range f = ⊤) : Injective (comap f) := fun _ _ h =>\n  le_antisymm ((comap_le_comap_iff hf).1 (le_of_eq h)) ((comap_le_comap_iff hf).1 (ge_of_eq h))\n\n-- TODO (?): generalize to semilinear maps with `f ∘ₗ g` bijective.\n"}
{"name":"LinearMap.ker_eq_range_of_comp_eq_id","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_11\nP : Type u_12\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup P\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M P\ng : LinearMap (RingHom.id R) P M\nh : Eq (f.comp g) LinearMap.id\n⊢ Eq (LinearMap.ker f) (LinearMap.range (HSub.hSub LinearMap.id (g.comp f)))","decl":"theorem ker_eq_range_of_comp_eq_id {M P} [AddCommGroup M] [Module R M]\n    [AddCommGroup P] [Module R P] {f : M →ₗ[R] P} {g : P →ₗ[R] M} (h : f ∘ₗ g = .id) :\n    ker f = range (LinearMap.id - g ∘ₗ f) :=\n  le_antisymm (fun x hx ↦ ⟨x, show x - g (f x) = x by rw [hx, map_zero, sub_zero]⟩) <|\n    range_le_ker_iff.mpr <| by rw [comp_sub, comp_id, ← comp_assoc, h, id_comp, sub_self]\n\n"}
{"name":"LinearMap.range_toAddSubgroup","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁶ : Ring R\ninst✝⁵ : Ring R₂\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M\ninst✝¹ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝ : RingHomSurjective τ₁₂\nf : LinearMap τ₁₂ M M₂\n⊢ Eq (LinearMap.range f).toAddSubgroup f.toAddMonoidHom.range","decl":"theorem range_toAddSubgroup [RingHomSurjective τ₁₂] (f : M →ₛₗ[τ₁₂] M₂) :\n    (range f).toAddSubgroup = f.toAddMonoidHom.range :=\n  rfl\n\n"}
{"name":"LinearMap.ker_le_iff","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁸ : Ring R\ninst✝⁷ : Ring R₂\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : AddCommGroup M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_10\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F τ₁₂ M M₂\nf : F\ninst✝ : RingHomSurjective τ₁₂\np : Submodule R M\n⊢ Iff (LE.le (LinearMap.ker f) p) (Exists fun y => And (Membership.mem (LinearMap.range f) y) (HasSubset.Subset (Set.preimage (⇑f) (Singleton.singleton y)) ↑p))","decl":"theorem ker_le_iff [RingHomSurjective τ₁₂] {p : Submodule R M} :\n    ker f ≤ p ↔ ∃ y ∈ range f, f ⁻¹' {y} ⊆ p := by\n  constructor\n  · intro h\n    use 0\n    rw [← SetLike.mem_coe, range_coe]\n    exact ⟨⟨0, map_zero f⟩, h⟩\n  · rintro ⟨y, h₁, h₂⟩\n    rw [SetLike.le_def]\n    intro z hz\n    simp only [mem_ker, SetLike.mem_coe] at hz\n    rw [← SetLike.mem_coe, range_coe, Set.mem_range] at h₁\n    obtain ⟨x, hx⟩ := h₁\n    have hx' : x ∈ p := h₂ hx\n    have hxz : z + x ∈ p := by\n      apply h₂\n      simp [hx, hz]\n    suffices z + x - x ∈ p by simpa only [this, add_sub_cancel_right]\n    exact p.sub_mem hxz hx'\n\n"}
{"name":"LinearMap.range_smul","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"K : Type u_4\nV : Type u_8\nV₂ : Type u_9\ninst✝⁴ : Semifield K\ninst✝³ : AddCommMonoid V\ninst✝² : Module K V\ninst✝¹ : AddCommMonoid V₂\ninst✝ : Module K V₂\nf : LinearMap (RingHom.id K) V V₂\na : K\nh : Ne a 0\n⊢ Eq (LinearMap.range (HSMul.hSMul a f)) (LinearMap.range f)","decl":"theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by\n  simpa only [range_eq_map] using Submodule.map_smul f _ a h\n\n"}
{"name":"LinearMap.range_smul'","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"K : Type u_4\nV : Type u_8\nV₂ : Type u_9\ninst✝⁴ : Semifield K\ninst✝³ : AddCommMonoid V\ninst✝² : Module K V\ninst✝¹ : AddCommMonoid V₂\ninst✝ : Module K V₂\nf : LinearMap (RingHom.id K) V V₂\na : K\n⊢ Eq (LinearMap.range (HSMul.hSMul a f)) (iSup fun x => LinearMap.range f)","decl":"theorem range_smul' (f : V →ₗ[K] V₂) (a : K) :\n    range (a • f) = ⨆ _ : a ≠ 0, range f := by\n  simpa only [range_eq_map] using Submodule.map_smul' f _ a\n\n"}
{"name":"Submodule.map_top","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_10\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F τ₁₂ M M₂\ninst✝ : RingHomSurjective τ₁₂\nf : F\n⊢ Eq (Submodule.map f Top.top) (LinearMap.range f)","decl":"@[simp]\ntheorem map_top [RingHomSurjective τ₁₂] (f : F) : map f ⊤ = range f :=\n  (range_eq_map f).symm\n"}
{"name":"Submodule.range_subtype","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\n⊢ Eq (LinearMap.range p.subtype) p","decl":"@[simp]\ntheorem range_subtype : range p.subtype = p := by simpa using map_comap_subtype p ⊤\n\n"}
{"name":"Submodule.map_subtype_le","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\np' : Submodule R (Subtype fun x => Membership.mem p x)\n⊢ LE.le (Submodule.map p.subtype p') p","decl":"theorem map_subtype_le (p' : Submodule R p) : map p.subtype p' ≤ p := by\n  simpa using (map_le_range : map p.subtype p' ≤ range p.subtype)\n\n"}
{"name":"Submodule.map_subtype_top","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\n⊢ Eq (Submodule.map p.subtype Top.top) p","decl":"/-- Under the canonical linear map from a submodule `p` to the ambient space `M`, the image of the\nmaximal submodule of `p` is just `p`. -/\ntheorem map_subtype_top : map p.subtype (⊤ : Submodule R p) = p := by simp\n\n"}
{"name":"Submodule.comap_subtype_eq_top","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np p' : Submodule R M\n⊢ Iff (Eq (Submodule.comap p.subtype p') Top.top) (LE.le p p')","decl":"@[simp]\ntheorem comap_subtype_eq_top {p p' : Submodule R M} : comap p.subtype p' = ⊤ ↔ p ≤ p' :=\n  eq_top_iff.trans <| map_le_iff_le_comap.symm.trans <| by rw [map_subtype_top]\n\n"}
{"name":"Submodule.comap_subtype_self","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\n⊢ Eq (Submodule.comap p.subtype p) Top.top","decl":"@[simp]\ntheorem comap_subtype_self : comap p.subtype p = ⊤ :=\n  comap_subtype_eq_top.2 le_rfl\n\n"}
{"name":"Submodule.comap_subtype_le_iff","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np q r : Submodule R M\n⊢ Iff (LE.le (Submodule.comap p.subtype q) (Submodule.comap p.subtype r)) (LE.le (Min.min p q) (Min.min p r))","decl":"@[simp]\nlemma comap_subtype_le_iff {p q r : Submodule R M} :\n    q.comap p.subtype ≤ r.comap p.subtype ↔ p ⊓ q ≤ p ⊓ r :=\n  ⟨fun h ↦ by simpa using map_mono (f := p.subtype) h,\n   fun h ↦ by simpa using comap_mono (f := p.subtype) h⟩\n\n"}
{"name":"Submodule.range_inclusion","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np q : Submodule R M\nh : LE.le p q\n⊢ Eq (LinearMap.range (Submodule.inclusion h)) (Submodule.comap q.subtype p)","decl":"theorem range_inclusion (p q : Submodule R M) (h : p ≤ q) :\n    range (inclusion h) = comap q.subtype p := by\n  rw [← map_top, inclusion, LinearMap.map_codRestrict, map_top, range_subtype]\n\n"}
{"name":"Submodule.map_subtype_range_inclusion","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np p' : Submodule R M\nh : LE.le p p'\n⊢ Eq (Submodule.map p'.subtype (LinearMap.range (Submodule.inclusion h))) p","decl":"@[simp]\ntheorem map_subtype_range_inclusion {p p' : Submodule R M} (h : p ≤ p') :\n    map p'.subtype (range <| inclusion h) = p := by simp [range_inclusion, map_comap_eq, h]\n\n"}
{"name":"Submodule.map_subtype_embedding_eq","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\np' : Submodule R (Subtype fun x => Membership.mem p x)\n⊢ Eq ((Submodule.MapSubtype.orderEmbedding p) p') (Submodule.map p.subtype p')","decl":"@[simp]\ntheorem map_subtype_embedding_eq (p' : Submodule R p) :\n    MapSubtype.orderEmbedding p p' = map p.subtype p' :=\n  rfl\n\n"}
{"name":"Submodule.coe_mapIic_apply","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\nq : Submodule R (Subtype fun x => Membership.mem p x)\n⊢ Eq (↑(p.mapIic q)) (Submodule.map p.subtype q)","decl":"@[simp] lemma coe_mapIic_apply\n    (p : Submodule R M) (q : Submodule R p) :\n    (p.mapIic q : Submodule R M) = q.map p.subtype :=\n  rfl\n\n"}
{"name":"LinearMap.ker_eq_bot_of_cancel","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nf : LinearMap τ₁₂ M M₂\nh : ∀ (u v : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem (LinearMap.ker f) x) M), Eq (f.comp u) (f.comp v) → Eq u v\n⊢ Eq (LinearMap.ker f) Bot.bot","decl":"/-- A monomorphism is injective. -/\ntheorem ker_eq_bot_of_cancel {f : M →ₛₗ[τ₁₂] M₂}\n    (h : ∀ u v : ker f →ₗ[R] M, f.comp u = f.comp v → u = v) : ker f = ⊥ := by\n  have h₁ : f.comp (0 : ker f →ₗ[R] M) = 0 := comp_zero _\n  rw [← Submodule.range_subtype (ker f),\n    ← h 0 f.ker.subtype (Eq.trans h₁ (comp_ker_subtype f).symm)]\n  exact range_zero\n\n"}
{"name":"LinearMap.range_comp_of_range_eq_top","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nR₃ : Type u_3\nM : Type u_5\nM₂ : Type u_6\nM₃ : Type u_7\ninst✝¹² : Semiring R\ninst✝¹¹ : Semiring R₂\ninst✝¹⁰ : Semiring R₃\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid M₂\ninst✝⁷ : AddCommMonoid M₃\ninst✝⁶ : Module R M\ninst✝⁵ : Module R₂ M₂\ninst✝⁴ : Module R₃ M₃\nτ₁₂ : RingHom R R₂\nτ₂₃ : RingHom R₂ R₃\nτ₁₃ : RingHom R R₃\ninst✝³ : RingHomCompTriple τ₁₂ τ₂₃ τ₁₃\ninst✝² : RingHomSurjective τ₁₂\ninst✝¹ : RingHomSurjective τ₂₃\ninst✝ : RingHomSurjective τ₁₃\nf : LinearMap τ₁₂ M M₂\ng : LinearMap τ₂₃ M₂ M₃\nhf : Eq (LinearMap.range f) Top.top\n⊢ Eq (LinearMap.range (g.comp f)) (LinearMap.range g)","decl":"theorem range_comp_of_range_eq_top [RingHomSurjective τ₁₂] [RingHomSurjective τ₂₃]\n    [RingHomSurjective τ₁₃] {f : M →ₛₗ[τ₁₂] M₂} (g : M₂ →ₛₗ[τ₂₃] M₃) (hf : range f = ⊤) :\n    range (g.comp f : M →ₛₗ[τ₁₃] M₃) = range g := by rw [range_comp, hf, Submodule.map_top]\n\n"}
{"name":"LinearMap.mem_submoduleImage","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nM' : Type u_10\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nO : Submodule R M\nϕ : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem O x) M'\nN : Submodule R M\nx : M'\n⊢ Iff (Membership.mem (ϕ.submoduleImage N) x) (Exists fun y => Exists fun yO => And (Membership.mem N y) (Eq (ϕ ⟨y, yO⟩) x))","decl":"@[simp]\ntheorem mem_submoduleImage {M' : Type*} [AddCommMonoid M'] [Module R M'] {O : Submodule R M}\n    {ϕ : O →ₗ[R] M'} {N : Submodule R M} {x : M'} :\n    x ∈ ϕ.submoduleImage N ↔ ∃ (y : _) (yO : y ∈ O), y ∈ N ∧ ϕ ⟨y, yO⟩ = x := by\n  refine Submodule.mem_map.trans ⟨?_, ?_⟩ <;> simp_rw [Submodule.mem_comap]\n  · rintro ⟨⟨y, yO⟩, yN : y ∈ N, h⟩\n    exact ⟨y, yO, yN, h⟩\n  · rintro ⟨y, yO, yN, h⟩\n    exact ⟨⟨y, yO⟩, yN, h⟩\n\n"}
{"name":"LinearMap.mem_submoduleImage_of_le","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nM' : Type u_10\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nO : Submodule R M\nϕ : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem O x) M'\nN : Submodule R M\nhNO : LE.le N O\nx : M'\n⊢ Iff (Membership.mem (ϕ.submoduleImage N) x) (Exists fun y => Exists fun yN => Eq (ϕ ⟨y, ⋯⟩) x)","decl":"theorem mem_submoduleImage_of_le {M' : Type*} [AddCommMonoid M'] [Module R M'] {O : Submodule R M}\n    {ϕ : O →ₗ[R] M'} {N : Submodule R M} (hNO : N ≤ O) {x : M'} :\n    x ∈ ϕ.submoduleImage N ↔ ∃ (y : _) (yN : y ∈ N), ϕ ⟨y, hNO yN⟩ = x := by\n  refine mem_submoduleImage.trans ⟨?_, ?_⟩\n  · rintro ⟨y, yO, yN, h⟩\n    exact ⟨y, yN, h⟩\n  · rintro ⟨y, yN, h⟩\n    exact ⟨y, hNO yN, yN, h⟩\n\n"}
{"name":"LinearMap.submoduleImage_apply_of_le","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nM' : Type u_10\ninst✝¹ : AddCommGroup M'\ninst✝ : Module R M'\nO : Submodule R M\nϕ : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem O x) M'\nN : Submodule R M\nhNO : LE.le N O\n⊢ Eq (ϕ.submoduleImage N) (LinearMap.range (ϕ.comp (Submodule.inclusion hNO)))","decl":"theorem submoduleImage_apply_of_le {M' : Type*} [AddCommGroup M'] [Module R M']\n    {O : Submodule R M} (ϕ : O →ₗ[R] M') (N : Submodule R M) (hNO : N ≤ O) :\n    ϕ.submoduleImage N = range (ϕ.comp (Submodule.inclusion hNO)) := by\n  rw [submoduleImage, range_comp, Submodule.range_inclusion]\n\n"}
{"name":"LinearMap.range_rangeRestrict","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M\ninst✝¹ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝ : RingHomSurjective τ₁₂\nf : LinearMap τ₁₂ M M₂\n⊢ Eq (LinearMap.range f.rangeRestrict) Top.top","decl":"@[simp] theorem range_rangeRestrict : range f.rangeRestrict = ⊤ := by simp [f.range_codRestrict _]\n\n"}
{"name":"LinearMap.surjective_rangeRestrict","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M\ninst✝¹ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝ : RingHomSurjective τ₁₂\nf : LinearMap τ₁₂ M M₂\n⊢ Function.Surjective ⇑f.rangeRestrict","decl":"theorem surjective_rangeRestrict : Surjective f.rangeRestrict := by\n  rw [← range_eq_top, range_rangeRestrict]\n\n"}
{"name":"LinearMap.ker_rangeRestrict","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M\ninst✝¹ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝ : RingHomSurjective τ₁₂\nf : LinearMap τ₁₂ M M₂\n⊢ Eq (LinearMap.ker f.rangeRestrict) (LinearMap.ker f)","decl":"@[simp] theorem ker_rangeRestrict : ker f.rangeRestrict = ker f := LinearMap.ker_codRestrict _ _ _\n\n"}
{"name":"LinearMap.injective_rangeRestrict_iff","module":"Mathlib.Algebra.Module.Submodule.Range","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M\ninst✝¹ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝ : RingHomSurjective τ₁₂\nf : LinearMap τ₁₂ M M₂\n⊢ Iff (Function.Injective ⇑f.rangeRestrict) (Function.Injective ⇑f)","decl":"@[simp] theorem injective_rangeRestrict_iff : Injective f.rangeRestrict ↔ Injective f :=\n  Set.injective_codRestrict _\n\n"}
