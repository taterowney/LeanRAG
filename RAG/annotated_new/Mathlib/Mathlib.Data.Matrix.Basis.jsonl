{"name":"Matrix.stdBasisMatrix_eq_of_single_single","module":"Mathlib.Data.Matrix.Basis","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_5\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : Zero α\ni : m\nj : n\na : α\n⊢ Eq (Matrix.stdBasisMatrix i j a) (Matrix.of (Pi.single i (Pi.single j a)))","decl":"theorem stdBasisMatrix_eq_of_single_single (i : m) (j : n) (a : α) :\n    stdBasisMatrix i j a = Matrix.of (Pi.single i (Pi.single j a)) := by\n  ext a b\n  unfold stdBasisMatrix\n  by_cases hi : i = a <;> by_cases hj : j = b <;> simp [*]\n\n"}
{"name":"Matrix.smul_stdBasisMatrix","module":"Mathlib.Data.Matrix.Basis","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_4\nα : Type u_5\ninst✝³ : DecidableEq m\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : SMulZeroClass R α\nr : R\ni : m\nj : n\na : α\n⊢ Eq (HSMul.hSMul r (Matrix.stdBasisMatrix i j a)) (Matrix.stdBasisMatrix i j (HSMul.hSMul r a))","decl":"@[simp]\ntheorem smul_stdBasisMatrix [SMulZeroClass R α] (r : R) (i : m) (j : n) (a : α) :\n    r • stdBasisMatrix i j a = stdBasisMatrix i j (r • a) := by\n  unfold stdBasisMatrix\n  ext\n  simp [smul_ite]\n\n"}
{"name":"Matrix.stdBasisMatrix_zero","module":"Mathlib.Data.Matrix.Basis","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_5\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : Zero α\ni : m\nj : n\n⊢ Eq (Matrix.stdBasisMatrix i j 0) 0","decl":"@[simp]\ntheorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (0 : α) = 0 := by\n  unfold stdBasisMatrix\n  ext\n  simp\n\n"}
{"name":"Matrix.transpose_stdBasisMatrix","module":"Mathlib.Data.Matrix.Basis","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_5\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : Zero α\ni : m\nj : n\na : α\n⊢ Eq (Matrix.stdBasisMatrix i j a).transpose (Matrix.stdBasisMatrix j i a)","decl":"@[simp]\nlemma transpose_stdBasisMatrix (i : m) (j : n) (a : α) :\n    (stdBasisMatrix i j a)ᵀ = stdBasisMatrix j i a := by\n  aesop (add unsafe unfold stdBasisMatrix)\n\n"}
{"name":"Matrix.map_stdBasisMatrix","module":"Mathlib.Data.Matrix.Basis","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_5\ninst✝⁵ : DecidableEq m\ninst✝⁴ : DecidableEq n\ninst✝³ : Zero α\ni : m\nj : n\na : α\nβ : Type u_7\ninst✝² : Zero β\nF : Type u_8\ninst✝¹ : FunLike F α β\ninst✝ : ZeroHomClass F α β\nf : F\n⊢ Eq ((Matrix.stdBasisMatrix i j a).map ⇑f) (Matrix.stdBasisMatrix i j (f a))","decl":"@[simp]\nlemma map_stdBasisMatrix (i : m) (j : n) (a : α) {β : Type*} [Zero β]\n    {F : Type*} [FunLike F α β] [ZeroHomClass F α β] (f : F) :\n    (stdBasisMatrix i j a).map f = stdBasisMatrix i j (f a) := by\n  aesop (add unsafe unfold stdBasisMatrix)\n\n"}
{"name":"Matrix.stdBasisMatrix_add","module":"Mathlib.Data.Matrix.Basis","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_5\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : AddZeroClass α\ni : m\nj : n\na b : α\n⊢ Eq (Matrix.stdBasisMatrix i j (HAdd.hAdd a b)) (HAdd.hAdd (Matrix.stdBasisMatrix i j a) (Matrix.stdBasisMatrix i j b))","decl":"theorem stdBasisMatrix_add [AddZeroClass α] (i : m) (j : n) (a b : α) :\n    stdBasisMatrix i j (a + b) = stdBasisMatrix i j a + stdBasisMatrix i j b := by\n  ext\n  simp only [stdBasisMatrix, of_apply]\n  split_ifs with h <;> simp [h]\n\n"}
{"name":"Matrix.mulVec_stdBasisMatrix","module":"Mathlib.Data.Matrix.Basis","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_5\ninst✝³ : DecidableEq m\ninst✝² : DecidableEq n\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype m\ni : n\nj : m\nc : α\nx : m → α\n⊢ Eq ((Matrix.stdBasisMatrix i j c).mulVec x) (Function.update 0 i (HMul.hMul c (x j)))","decl":"theorem mulVec_stdBasisMatrix [NonUnitalNonAssocSemiring α] [Fintype m]\n    (i : n) (j : m) (c : α) (x : m → α) :\n    mulVec (stdBasisMatrix i j c) x = Function.update (0 : n → α) i (c * x j) := by\n  ext i'\n  simp [stdBasisMatrix, mulVec, dotProduct]\n  rcases eq_or_ne i i' with rfl|h\n  · simp\n  simp [h, h.symm]\n\n"}
{"name":"Matrix.matrix_eq_sum_stdBasisMatrix","module":"Mathlib.Data.Matrix.Basis","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_5\ninst✝⁴ : DecidableEq m\ninst✝³ : DecidableEq n\ninst✝² : AddCommMonoid α\ninst✝¹ : Fintype m\ninst✝ : Fintype n\nx : Matrix m n α\n⊢ Eq x (Finset.univ.sum fun i => Finset.univ.sum fun j => Matrix.stdBasisMatrix i j (x i j))","decl":"theorem matrix_eq_sum_stdBasisMatrix [AddCommMonoid α] [Fintype m] [Fintype n] (x : Matrix m n α) :\n    x = ∑ i : m, ∑ j : n, stdBasisMatrix i j (x i j) := by\n  ext i j\n  rw [← Fintype.sum_prod_type']\n  simp [stdBasisMatrix, Matrix.sum_apply, Matrix.of_apply, ← Prod.mk.inj_iff]\n\n"}
{"name":"Matrix.matrix_eq_sum_std_basis","module":"Mathlib.Data.Matrix.Basis","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_5\ninst✝⁴ : DecidableEq m\ninst✝³ : DecidableEq n\ninst✝² : AddCommMonoid α\ninst✝¹ : Fintype m\ninst✝ : Fintype n\nx : Matrix m n α\n⊢ Eq x (Finset.univ.sum fun i => Finset.univ.sum fun j => Matrix.stdBasisMatrix i j (x i j))","decl":"@[deprecated (since := \"2024-08-11\")] alias matrix_eq_sum_std_basis := matrix_eq_sum_stdBasisMatrix\n\n"}
{"name":"Matrix.stdBasisMatrix_eq_single_vecMulVec_single","module":"Mathlib.Data.Matrix.Basis","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_5\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : MulZeroOneClass α\ni : m\nj : n\n⊢ Eq (Matrix.stdBasisMatrix i j 1) (Matrix.vecMulVec (Pi.single i 1) (Pi.single j 1))","decl":"theorem stdBasisMatrix_eq_single_vecMulVec_single [MulZeroOneClass α] (i : m) (j : n) :\n    stdBasisMatrix i j (1 : α) = vecMulVec (Pi.single i 1) (Pi.single j 1) := by\n  ext i' j'\n  -- Porting note: lean3 didn't apply `mul_ite`.\n  simp [-mul_ite, stdBasisMatrix, vecMulVec, ite_and, Pi.single_apply, eq_comm]\n\n-- TODO: tie this up with the `Basis` machinery of linear algebra\n-- this is not completely trivial because we are indexing by two types, instead of one\n"}
{"name":"Matrix.std_basis_eq_basis_mul_basis","module":"Mathlib.Data.Matrix.Basis","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_5\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : MulZeroOneClass α\ni : m\nj : n\n⊢ Eq (Matrix.stdBasisMatrix i j 1) (Matrix.vecMulVec (fun i' => ite (Eq i i') 1 0) fun j' => ite (Eq j j') 1 0)","decl":"@[deprecated stdBasisMatrix_eq_single_vecMulVec_single (since := \"2024-08-11\")]\ntheorem std_basis_eq_basis_mul_basis [MulZeroOneClass α] (i : m) (j : n) :\n    stdBasisMatrix i j (1 : α) =\n      vecMulVec (fun i' => ite (i = i') 1 0) fun j' => ite (j = j') 1 0 := by\n  rw [stdBasisMatrix_eq_single_vecMulVec_single]\n  congr! with i <;> simp only [Pi.single_apply, eq_comm]\n\n-- todo: the old proof used fintypes, I don't know `Finsupp` but this feels generalizable\n"}
{"name":"Matrix.induction_on'","module":"Mathlib.Data.Matrix.Basis","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_5\ninst✝⁴ : DecidableEq m\ninst✝³ : DecidableEq n\ninst✝² : AddCommMonoid α\ninst✝¹ : Finite m\ninst✝ : Finite n\nP : Matrix m n α → Prop\nM : Matrix m n α\nh_zero : P 0\nh_add : ∀ (p q : Matrix m n α), P p → P q → P (HAdd.hAdd p q)\nh_std_basis : ∀ (i : m) (j : n) (x : α), P (Matrix.stdBasisMatrix i j x)\n⊢ P M","decl":"@[elab_as_elim]\nprotected theorem induction_on'\n    [AddCommMonoid α] [Finite m] [Finite n] {P : Matrix m n α → Prop} (M : Matrix m n α)\n    (h_zero : P 0) (h_add : ∀ p q, P p → P q → P (p + q))\n    (h_std_basis : ∀ (i : m) (j : n) (x : α), P (stdBasisMatrix i j x)) : P M := by\n  cases nonempty_fintype m; cases nonempty_fintype n\n  rw [matrix_eq_sum_stdBasisMatrix M, ← Finset.sum_product']\n  apply Finset.sum_induction _ _ h_add h_zero\n  · intros\n    apply h_std_basis\n\n"}
{"name":"Matrix.induction_on","module":"Mathlib.Data.Matrix.Basis","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_5\ninst✝⁶ : DecidableEq m\ninst✝⁵ : DecidableEq n\ninst✝⁴ : AddCommMonoid α\ninst✝³ : Finite m\ninst✝² : Finite n\ninst✝¹ : Nonempty m\ninst✝ : Nonempty n\nP : Matrix m n α → Prop\nM : Matrix m n α\nh_add : ∀ (p q : Matrix m n α), P p → P q → P (HAdd.hAdd p q)\nh_std_basis : ∀ (i : m) (j : n) (x : α), P (Matrix.stdBasisMatrix i j x)\n⊢ P M","decl":"@[elab_as_elim]\nprotected theorem induction_on\n    [AddCommMonoid α] [Finite m] [Finite n] [Nonempty m] [Nonempty n]\n    {P : Matrix m n α → Prop} (M : Matrix m n α) (h_add : ∀ p q, P p → P q → P (p + q))\n    (h_std_basis : ∀ i j x, P (stdBasisMatrix i j x)) : P M :=\n  Matrix.induction_on' M\n    (by\n      inhabit m\n      inhabit n\n      simpa using h_std_basis default default 0)\n    h_add h_std_basis\n\n"}
{"name":"Matrix.stdBasisMatrixAddMonoidHom_apply","module":"Mathlib.Data.Matrix.Basis","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_5\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : AddCommMonoid α\ni : m\nj : n\na : α\n⊢ Eq ((Matrix.stdBasisMatrixAddMonoidHom i j) a) (Matrix.stdBasisMatrix i j a)","decl":"/-- `Matrix.stdBasisMatrix` as a bundled additive map. -/\n@[simps]\ndef stdBasisMatrixAddMonoidHom [AddCommMonoid α] (i : m) (j : n) : α →+ Matrix m n α where\n  toFun := stdBasisMatrix i j\n  map_zero' := stdBasisMatrix_zero _ _\n  map_add' _ _ := stdBasisMatrix_add _ _ _ _\n\n"}
{"name":"Matrix.stdBasisMatrixLinearMap_apply","module":"Mathlib.Data.Matrix.Basis","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_4\nα : Type u_5\ninst✝⁴ : DecidableEq m\ninst✝³ : DecidableEq n\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid α\ninst✝ : Module R α\ni : m\nj : n\na✝ : α\n⊢ Eq ((Matrix.stdBasisMatrixLinearMap R i j) a✝) (Matrix.stdBasisMatrix i j a✝)","decl":"/-- `Matrix.stdBasisMatrix` as a bundled linear map. -/\n@[simps!]\ndef stdBasisMatrixLinearMap [Semiring R] [AddCommMonoid α] [Module R α] (i : m) (j : n) :\n    α →ₗ[R] Matrix m n α where\n  __ := stdBasisMatrixAddMonoidHom i j\n  map_smul' _ _:= smul_stdBasisMatrix _ _ _ _ |>.symm\n\n"}
{"name":"Matrix.ext_addMonoidHom","module":"Mathlib.Data.Matrix.Basis","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_5\nβ : Type u_6\ninst✝⁵ : DecidableEq m\ninst✝⁴ : DecidableEq n\ninst✝³ : Finite m\ninst✝² : Finite n\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nf g : AddMonoidHom (Matrix m n α) β\nh : ∀ (i : m) (j : n), Eq (f.comp (Matrix.stdBasisMatrixAddMonoidHom i j)) (g.comp (Matrix.stdBasisMatrixAddMonoidHom i j))\n⊢ Eq f g","decl":"/-- Additive maps from finite matrices are equal if they agree on the standard basis.\n\nSee note [partially-applied ext lemmas]. -/\n@[local ext]\ntheorem ext_addMonoidHom\n    [Finite m] [Finite n] [AddCommMonoid α] [AddCommMonoid β] ⦃f g : Matrix m n α →+ β⦄\n    (h : ∀ i j, f.comp (stdBasisMatrixAddMonoidHom i j) = g.comp (stdBasisMatrixAddMonoidHom i j)) :\n    f = g := by\n  cases nonempty_fintype m\n  cases nonempty_fintype n\n  ext x\n  rw [matrix_eq_sum_stdBasisMatrix x]\n  simp_rw [map_sum]\n  congr! 2\n  exact DFunLike.congr_fun (h _ _) _\n\n"}
{"name":"Matrix.ext_addMonoidHom_iff","module":"Mathlib.Data.Matrix.Basis","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_5\nβ : Type u_6\ninst✝⁵ : DecidableEq m\ninst✝⁴ : DecidableEq n\ninst✝³ : Finite m\ninst✝² : Finite n\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nf g : AddMonoidHom (Matrix m n α) β\n⊢ Iff (Eq f g) (∀ (i : m) (j : n), Eq (f.comp (Matrix.stdBasisMatrixAddMonoidHom i j)) (g.comp (Matrix.stdBasisMatrixAddMonoidHom i j)))","decl":"/-- Additive maps from finite matrices are equal if they agree on the standard basis.\n\nSee note [partially-applied ext lemmas]. -/\n@[local ext]\ntheorem ext_addMonoidHom\n    [Finite m] [Finite n] [AddCommMonoid α] [AddCommMonoid β] ⦃f g : Matrix m n α →+ β⦄\n    (h : ∀ i j, f.comp (stdBasisMatrixAddMonoidHom i j) = g.comp (stdBasisMatrixAddMonoidHom i j)) :\n    f = g := by\n  cases nonempty_fintype m\n  cases nonempty_fintype n\n  ext x\n  rw [matrix_eq_sum_stdBasisMatrix x]\n  simp_rw [map_sum]\n  congr! 2\n  exact DFunLike.congr_fun (h _ _) _\n\n"}
{"name":"Matrix.ext_linearMap","module":"Mathlib.Data.Matrix.Basis","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_4\nα : Type u_5\nβ : Type u_6\ninst✝⁸ : DecidableEq m\ninst✝⁷ : DecidableEq n\ninst✝⁶ : Finite m\ninst✝⁵ : Finite n\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid α\ninst✝² : AddCommMonoid β\ninst✝¹ : Module R α\ninst✝ : Module R β\nf g : LinearMap (RingHom.id R) (Matrix m n α) β\nh : ∀ (i : m) (j : n), Eq (f.comp (Matrix.stdBasisMatrixLinearMap R i j)) (g.comp (Matrix.stdBasisMatrixLinearMap R i j))\n⊢ Eq f g","decl":"/-- Linear maps from finite matrices are equal if they agree on the standard basis.\n\nSee note [partially-applied ext lemmas]. -/\n@[local ext]\ntheorem ext_linearMap\n    [Finite m] [Finite n][Semiring R] [AddCommMonoid α] [AddCommMonoid β] [Module R α] [Module R β]\n    ⦃f g : Matrix m n α →ₗ[R] β⦄\n    (h : ∀ i j, f ∘ₗ stdBasisMatrixLinearMap R i j = g ∘ₗ stdBasisMatrixLinearMap R i j) :\n    f = g :=\n  LinearMap.toAddMonoidHom_injective <| ext_addMonoidHom fun i j =>\n    congrArg LinearMap.toAddMonoidHom <| h i j\n\n"}
{"name":"Matrix.ext_linearMap_iff","module":"Mathlib.Data.Matrix.Basis","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_4\nα : Type u_5\nβ : Type u_6\ninst✝⁸ : DecidableEq m\ninst✝⁷ : DecidableEq n\ninst✝⁶ : Finite m\ninst✝⁵ : Finite n\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid α\ninst✝² : AddCommMonoid β\ninst✝¹ : Module R α\ninst✝ : Module R β\nf g : LinearMap (RingHom.id R) (Matrix m n α) β\n⊢ Iff (Eq f g) (∀ (i : m) (j : n), Eq (f.comp (Matrix.stdBasisMatrixLinearMap R i j)) (g.comp (Matrix.stdBasisMatrixLinearMap R i j)))","decl":"/-- Linear maps from finite matrices are equal if they agree on the standard basis.\n\nSee note [partially-applied ext lemmas]. -/\n@[local ext]\ntheorem ext_linearMap\n    [Finite m] [Finite n][Semiring R] [AddCommMonoid α] [AddCommMonoid β] [Module R α] [Module R β]\n    ⦃f g : Matrix m n α →ₗ[R] β⦄\n    (h : ∀ i j, f ∘ₗ stdBasisMatrixLinearMap R i j = g ∘ₗ stdBasisMatrixLinearMap R i j) :\n    f = g :=\n  LinearMap.toAddMonoidHom_injective <| ext_addMonoidHom fun i j =>\n    congrArg LinearMap.toAddMonoidHom <| h i j\n\n"}
{"name":"Matrix.StdBasisMatrix.apply_same","module":"Mathlib.Data.Matrix.Basis","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_5\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : Zero α\ni : m\nj : n\nc : α\n⊢ Eq (Matrix.stdBasisMatrix i j c i j) c","decl":"@[simp]\ntheorem apply_same : stdBasisMatrix i j c i j = c :=\n  if_pos (And.intro rfl rfl)\n\n"}
{"name":"Matrix.StdBasisMatrix.apply_of_ne","module":"Mathlib.Data.Matrix.Basis","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_5\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : Zero α\ni : m\nj : n\nc : α\ni' : m\nj' : n\nh : Not (And (Eq i i') (Eq j j'))\n⊢ Eq (Matrix.stdBasisMatrix i j c i' j') 0","decl":"@[simp]\ntheorem apply_of_ne (h : ¬(i = i' ∧ j = j')) : stdBasisMatrix i j c i' j' = 0 := by\n  simp only [stdBasisMatrix, and_imp, ite_eq_right_iff, of_apply]\n  tauto\n\n"}
{"name":"Matrix.StdBasisMatrix.apply_of_row_ne","module":"Mathlib.Data.Matrix.Basis","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_5\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : Zero α\ni i' : m\nhi : Ne i i'\nj j' : n\na : α\n⊢ Eq (Matrix.stdBasisMatrix i j a i' j') 0","decl":"@[simp]\ntheorem apply_of_row_ne {i i' : m} (hi : i ≠ i') (j j' : n) (a : α) :\n    stdBasisMatrix i j a i' j' = 0 := by simp [hi]\n\n"}
{"name":"Matrix.StdBasisMatrix.apply_of_col_ne","module":"Mathlib.Data.Matrix.Basis","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_5\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : Zero α\ni i' : m\nj j' : n\nhj : Ne j j'\na : α\n⊢ Eq (Matrix.stdBasisMatrix i j a i' j') 0","decl":"@[simp]\ntheorem apply_of_col_ne (i i' : m) {j j' : n} (hj : j ≠ j') (a : α) :\n    stdBasisMatrix i j a i' j' = 0 := by simp [hj]\n\n"}
{"name":"Matrix.StdBasisMatrix.diag_zero","module":"Mathlib.Data.Matrix.Basis","initialProofState":"n : Type u_3\nα : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Zero α\ni j : n\nc : α\nh : Ne j i\n⊢ Eq (Matrix.stdBasisMatrix i j c).diag 0","decl":"@[simp]\ntheorem diag_zero (h : j ≠ i) : diag (stdBasisMatrix i j c) = 0 :=\n  funext fun _ => if_neg fun ⟨e₁, e₂⟩ => h (e₂.trans e₁.symm)\n\n"}
{"name":"Matrix.StdBasisMatrix.diag_same","module":"Mathlib.Data.Matrix.Basis","initialProofState":"n : Type u_3\nα : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Zero α\ni : n\nc : α\n⊢ Eq (Matrix.stdBasisMatrix i i c).diag (Pi.single i c)","decl":"@[simp]\ntheorem diag_same : diag (stdBasisMatrix i i c) = Pi.single i c := by\n  ext j\n  by_cases hij : i = j <;> (try rw [hij]) <;> simp [hij]\n\n"}
{"name":"Matrix.StdBasisMatrix.mul_left_apply_same","module":"Mathlib.Data.Matrix.Basis","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nα : Type u_5\ninst✝³ : DecidableEq l\ninst✝² : DecidableEq m\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nc : α\ni : l\nj : m\nb : n\nM : Matrix m n α\n⊢ Eq (HMul.hMul (Matrix.stdBasisMatrix i j c) M i b) (HMul.hMul c (M j b))","decl":"omit [DecidableEq n] in\n@[simp]\ntheorem mul_left_apply_same (i : l) (j : m) (b : n) (M : Matrix m n α) :\n    (stdBasisMatrix i j c * M) i b = c * M j b := by simp [mul_apply, stdBasisMatrix]\n\n"}
{"name":"Matrix.StdBasisMatrix.mul_right_apply_same","module":"Mathlib.Data.Matrix.Basis","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nα : Type u_5\ninst✝³ : DecidableEq m\ninst✝² : DecidableEq n\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nc : α\ni : m\nj : n\na : l\nM : Matrix l m α\n⊢ Eq (HMul.hMul M (Matrix.stdBasisMatrix i j c) a j) (HMul.hMul (M a i) c)","decl":"omit [DecidableEq l] in\n@[simp]\ntheorem mul_right_apply_same (i : m) (j : n) (a : l) (M : Matrix l m α) :\n    (M * stdBasisMatrix i j c) a j = M a i * c := by simp [mul_apply, stdBasisMatrix, mul_comm]\n\n"}
{"name":"Matrix.StdBasisMatrix.mul_left_apply_of_ne","module":"Mathlib.Data.Matrix.Basis","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nα : Type u_5\ninst✝³ : DecidableEq l\ninst✝² : DecidableEq m\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nc : α\ni : l\nj : m\na : l\nb : n\nh : Ne a i\nM : Matrix m n α\n⊢ Eq (HMul.hMul (Matrix.stdBasisMatrix i j c) M a b) 0","decl":"omit [DecidableEq n] in\n@[simp]\ntheorem mul_left_apply_of_ne (i : l) (j : m) (a : l) (b : n) (h : a ≠ i) (M : Matrix m n α) :\n    (stdBasisMatrix i j c * M) a b = 0 := by simp [mul_apply, h.symm]\n\n"}
{"name":"Matrix.StdBasisMatrix.mul_right_apply_of_ne","module":"Mathlib.Data.Matrix.Basis","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nα : Type u_5\ninst✝³ : DecidableEq m\ninst✝² : DecidableEq n\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nc : α\ni : m\nj : n\na : l\nb : n\nhbj : Ne b j\nM : Matrix l m α\n⊢ Eq (HMul.hMul M (Matrix.stdBasisMatrix i j c) a b) 0","decl":"omit [DecidableEq l] in\n@[simp]\ntheorem mul_right_apply_of_ne (i : m) (j : n) (a : l) (b : n) (hbj : b ≠ j) (M : Matrix l m α) :\n    (M * stdBasisMatrix i j c) a b = 0 := by simp [mul_apply, hbj.symm]\n\n"}
{"name":"Matrix.StdBasisMatrix.mul_same","module":"Mathlib.Data.Matrix.Basis","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nα : Type u_5\ninst✝⁴ : DecidableEq l\ninst✝³ : DecidableEq m\ninst✝² : DecidableEq n\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nc : α\ni : l\nj : m\nk : n\nd : α\n⊢ Eq (HMul.hMul (Matrix.stdBasisMatrix i j c) (Matrix.stdBasisMatrix j k d)) (Matrix.stdBasisMatrix i k (HMul.hMul c d))","decl":"@[simp]\ntheorem mul_same (i : l) (j : m) (k : n) (d : α) :\n    stdBasisMatrix i j c * stdBasisMatrix j k d = stdBasisMatrix i k (c * d) := by\n  ext a b\n  simp only [mul_apply, stdBasisMatrix, boole_mul]\n  by_cases h₁ : i = a <;> by_cases h₂ : k = b <;> simp [h₁, h₂]\n\n"}
{"name":"Matrix.StdBasisMatrix.mul_of_ne","module":"Mathlib.Data.Matrix.Basis","initialProofState":"l✝ : Type u_1\nm : Type u_2\nn : Type u_3\nα : Type u_5\ninst✝⁴ : DecidableEq l✝\ninst✝³ : DecidableEq m\ninst✝² : DecidableEq n\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nc : α\ni : l✝\nj k : m\nl : n\nh : Ne j k\nd : α\n⊢ Eq (HMul.hMul (Matrix.stdBasisMatrix i j c) (Matrix.stdBasisMatrix k l d)) 0","decl":"@[simp]\ntheorem mul_of_ne (i : l) (j k : m) {l : n} (h : j ≠ k) (d : α) :\n    stdBasisMatrix i j c * stdBasisMatrix k l d = 0 := by\n  ext a b\n  simp only [mul_apply, boole_mul, stdBasisMatrix, of_apply]\n  by_cases h₁ : i = a\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10745): was `simp [h₁, h, h.symm]`\n  · simp only [h₁, true_and, mul_ite, ite_mul, zero_mul, mul_zero, ← ite_and, zero_apply]\n    refine Finset.sum_eq_zero (fun x _ => ?_)\n    apply if_neg\n    rintro ⟨⟨rfl, rfl⟩, h⟩\n    contradiction\n  · simp only [h₁, false_and, ite_false, mul_ite, zero_mul, mul_zero, ite_self,\n      Finset.sum_const_zero, zero_apply]\n\n"}
{"name":"Matrix.row_eq_zero_of_commute_stdBasisMatrix","module":"Mathlib.Data.Matrix.Basis","initialProofState":"n : Type u_3\nα : Type u_5\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : Semiring α\ni j k : n\nM : Matrix n n α\nhM : Commute (Matrix.stdBasisMatrix i j 1) M\nhkj : Ne k j\n⊢ Eq (M j k) 0","decl":"theorem row_eq_zero_of_commute_stdBasisMatrix {i j k : n} {M : Matrix n n α}\n    (hM : Commute (stdBasisMatrix i j 1) M) (hkj : k ≠ j) : M j k = 0 := by\n  have := ext_iff.mpr hM i k\n  aesop\n\n"}
{"name":"Matrix.col_eq_zero_of_commute_stdBasisMatrix","module":"Mathlib.Data.Matrix.Basis","initialProofState":"n : Type u_3\nα : Type u_5\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : Semiring α\ni j k : n\nM : Matrix n n α\nhM : Commute (Matrix.stdBasisMatrix i j 1) M\nhki : Ne k i\n⊢ Eq (M k i) 0","decl":"theorem col_eq_zero_of_commute_stdBasisMatrix {i j k : n} {M : Matrix n n α}\n    (hM : Commute (stdBasisMatrix i j 1) M) (hki : k ≠ i) : M k i = 0 := by\n  have := ext_iff.mpr hM k j\n  aesop\n\n"}
{"name":"Matrix.diag_eq_of_commute_stdBasisMatrix","module":"Mathlib.Data.Matrix.Basis","initialProofState":"n : Type u_3\nα : Type u_5\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : Semiring α\ni j : n\nM : Matrix n n α\nhM : Commute (Matrix.stdBasisMatrix i j 1) M\n⊢ Eq (M i i) (M j j)","decl":"theorem diag_eq_of_commute_stdBasisMatrix {i j : n} {M : Matrix n n α}\n    (hM : Commute (stdBasisMatrix i j 1) M) : M i i = M j j := by\n  have := ext_iff.mpr hM i j\n  aesop\n\n"}
{"name":"Matrix.mem_range_scalar_of_commute_stdBasisMatrix","module":"Mathlib.Data.Matrix.Basis","initialProofState":"n : Type u_3\nα : Type u_5\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : Semiring α\nM : Matrix n n α\nhM : Pairwise fun i j => Commute (Matrix.stdBasisMatrix i j 1) M\n⊢ Membership.mem (Set.range ⇑(Matrix.scalar n)) M","decl":"/-- `M` is a scalar matrix if it commutes with every non-diagonal `stdBasisMatrix`. -/\ntheorem mem_range_scalar_of_commute_stdBasisMatrix {M : Matrix n n α}\n    (hM : Pairwise fun i j => Commute (stdBasisMatrix i j 1) M) :\n    M ∈ Set.range (Matrix.scalar n) := by\n  cases isEmpty_or_nonempty n\n  · exact ⟨0, Subsingleton.elim _ _⟩\n  obtain ⟨i⟩ := ‹Nonempty n›\n  refine ⟨M i i, Matrix.ext fun j k => ?_⟩\n  simp only [scalar_apply]\n  obtain rfl | hkl := Decidable.eq_or_ne j k\n  · rw [diagonal_apply_eq]\n    obtain rfl | hij := Decidable.eq_or_ne i j\n    · rfl\n    · exact diag_eq_of_commute_stdBasisMatrix (hM hij)\n  · rw [diagonal_apply_ne _ hkl]\n    obtain rfl | hij := Decidable.eq_or_ne i j\n    · rw [col_eq_zero_of_commute_stdBasisMatrix (hM hkl.symm) hkl]\n    · rw [row_eq_zero_of_commute_stdBasisMatrix (hM hij) hkl.symm]\n\n"}
{"name":"Matrix.mem_range_scalar_iff_commute_stdBasisMatrix","module":"Mathlib.Data.Matrix.Basis","initialProofState":"n : Type u_3\nα : Type u_5\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : Semiring α\nM : Matrix n n α\n⊢ Iff (Membership.mem (Set.range ⇑(Matrix.scalar n)) M) (∀ (i j : n), Ne i j → Commute (Matrix.stdBasisMatrix i j 1) M)","decl":"theorem mem_range_scalar_iff_commute_stdBasisMatrix {M : Matrix n n α} :\n    M ∈ Set.range (Matrix.scalar n) ↔ ∀ (i j : n), i ≠ j → Commute (stdBasisMatrix i j 1) M := by\n  refine ⟨fun ⟨r, hr⟩ i j _ => hr ▸ Commute.symm ?_, mem_range_scalar_of_commute_stdBasisMatrix⟩\n  rw [scalar_commute_iff]\n  simp\n\n"}
{"name":"Matrix.mem_range_scalar_iff_commute_stdBasisMatrix'","module":"Mathlib.Data.Matrix.Basis","initialProofState":"n : Type u_3\nα : Type u_5\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : Semiring α\nM : Matrix n n α\n⊢ Iff (Membership.mem (Set.range ⇑(Matrix.scalar n)) M) (∀ (i j : n), Commute (Matrix.stdBasisMatrix i j 1) M)","decl":"/-- `M` is a scalar matrix if and only if it commutes with every `stdBasisMatrix`. -/\ntheorem mem_range_scalar_iff_commute_stdBasisMatrix' {M : Matrix n n α} :\n    M ∈ Set.range (Matrix.scalar n) ↔ ∀ (i j : n), Commute (stdBasisMatrix i j 1) M := by\n  refine ⟨fun ⟨r, hr⟩ i j => hr ▸ Commute.symm ?_,\n    fun hM => mem_range_scalar_iff_commute_stdBasisMatrix.mpr <| fun i j _ => hM i j⟩\n  rw [scalar_commute_iff]\n  simp\n\n"}
