{"name":"List.isSuffix.reverse","module":"Mathlib.Data.List.Infix","initialProofState":"α✝ : Type u_1\nl₁ l₂ : List α✝\na✝ : l₁.IsSuffix l₂\n⊢ l₁.reverse.IsPrefix l₂.reverse","decl":"@[deprecated IsSuffix.reverse (since := \"2024-08-12\")] alias isSuffix.reverse := IsSuffix.reverse\n"}
{"name":"List.isPrefix.reverse","module":"Mathlib.Data.List.Infix","initialProofState":"α✝ : Type u_1\nl₁ l₂ : List α✝\na✝ : l₁.IsPrefix l₂\n⊢ l₁.reverse.IsSuffix l₂.reverse","decl":"@[deprecated IsPrefix.reverse (since := \"2024-08-12\")] alias isPrefix.reverse := IsPrefix.reverse\n"}
{"name":"List.isInfix.reverse","module":"Mathlib.Data.List.Infix","initialProofState":"α✝ : Type u_1\nl₁ l₂ : List α✝\na✝ : l₁.IsInfix l₂\n⊢ l₁.reverse.IsInfix l₂.reverse","decl":"@[deprecated IsInfix.reverse (since := \"2024-08-12\")] alias isInfix.reverse := IsInfix.reverse\n\n"}
{"name":"List.eq_of_infix_of_length_eq","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl₁ l₂ : List α\nh : l₁.IsInfix l₂\na✝ : Eq l₁.length l₂.length\n⊢ Eq l₁ l₂","decl":"@[deprecated IsInfix.eq_of_length (since := \"2024-08-12\")]\ntheorem eq_of_infix_of_length_eq (h : l₁ <:+: l₂) : l₁.length = l₂.length → l₁ = l₂ :=\n  h.eq_of_length\n\n"}
{"name":"List.eq_of_prefix_of_length_eq","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl₁ l₂ : List α\nh : l₁.IsPrefix l₂\na✝ : Eq l₁.length l₂.length\n⊢ Eq l₁ l₂","decl":"@[deprecated IsPrefix.eq_of_length (since := \"2024-08-12\")]\ntheorem eq_of_prefix_of_length_eq (h : l₁ <+: l₂) : l₁.length = l₂.length → l₁ = l₂ :=\n  h.eq_of_length\n\n"}
{"name":"List.eq_of_suffix_of_length_eq","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl₁ l₂ : List α\nh : l₁.IsSuffix l₂\na✝ : Eq l₁.length l₂.length\n⊢ Eq l₁ l₂","decl":"@[deprecated IsSuffix.eq_of_length (since := \"2024-08-12\")]\ntheorem eq_of_suffix_of_length_eq (h : l₁ <:+ l₂) : l₁.length = l₂.length → l₁ = l₂ :=\n  h.eq_of_length\n\n"}
{"name":"List.IsPrefix.take","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl₁ l₂ : List α\nh : l₁.IsPrefix l₂\nn : Nat\n⊢ (List.take n l₁).IsPrefix (List.take n l₂)","decl":"@[gcongr] lemma IsPrefix.take (h : l₁ <+: l₂) (n : ℕ) : l₁.take n <+: l₂.take n := by\n  simpa [prefix_take_iff, Nat.min_le_left] using (take_prefix n l₁).trans h\n\n"}
{"name":"List.IsPrefix.drop","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl₁ l₂ : List α\nh : l₁.IsPrefix l₂\nn : Nat\n⊢ (List.drop n l₁).IsPrefix (List.drop n l₂)","decl":"@[gcongr] lemma IsPrefix.drop (h : l₁ <+: l₂) (n : ℕ) : l₁.drop n <+: l₂.drop n := by\n  rw [prefix_iff_eq_take.mp h, drop_take]; apply take_prefix\n\n"}
{"name":"List.isPrefix_append_of_length","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl₁ l₂ l₃ : List α\nh : LE.le l₁.length l₂.length\n⊢ Iff (l₁.IsPrefix (HAppend.hAppend l₂ l₃)) (l₁.IsPrefix l₂)","decl":"lemma isPrefix_append_of_length (h : l₁.length ≤ l₂.length) : l₁ <+: l₂ ++ l₃ ↔ l₁ <+: l₂ :=\n  ⟨fun h ↦ by rw [prefix_iff_eq_take] at *; nth_rw 1 [h, take_eq_left_iff]; tauto,\n   fun h ↦ h.trans <| l₂.prefix_append l₃⟩\n\n"}
{"name":"List.take_isPrefix_take","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl : List α\nm n : Nat\n⊢ Iff ((List.take m l).IsPrefix (List.take n l)) (Or (LE.le m n) (LE.le l.length n))","decl":"@[simp] lemma take_isPrefix_take {m n : ℕ} : l.take m <+: l.take n ↔ m ≤ n ∨ l.length ≤ n := by\n  simp [prefix_take_iff, take_prefix]; omega\n\n"}
{"name":"List.dropSlice_sublist","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nn m : Nat\nl : List α\n⊢ (List.dropSlice n m l).Sublist l","decl":"lemma dropSlice_sublist (n m : ℕ) (l : List α) : l.dropSlice n m <+ l :=\n  calc\n    l.dropSlice n m = take n l ++ drop m (drop n l) := by rw [dropSlice_eq, drop_drop, Nat.add_comm]\n  _ <+ take n l ++ drop n l := (Sublist.refl _).append (drop_sublist _ _)\n  _ = _ := take_append_drop _ _\n\n"}
{"name":"List.dropSlice_subset","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nn m : Nat\nl : List α\n⊢ HasSubset.Subset (List.dropSlice n m l) l","decl":"lemma dropSlice_subset (n m : ℕ) (l : List α) : l.dropSlice n m ⊆ l :=\n  (dropSlice_sublist n m l).subset\n\n"}
{"name":"List.mem_of_mem_dropSlice","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nn m : Nat\nl : List α\na : α\nh : Membership.mem (List.dropSlice n m l) a\n⊢ Membership.mem l a","decl":"lemma mem_of_mem_dropSlice {n m : ℕ} {l : List α} {a : α} (h : a ∈ l.dropSlice n m) : a ∈ l :=\n  dropSlice_subset n m l h\n\n"}
{"name":"List.tail_subset","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl : List α\n⊢ HasSubset.Subset l.tail l","decl":"theorem tail_subset (l : List α) : tail l ⊆ l :=\n  (tail_sublist l).subset\n\n"}
{"name":"List.mem_of_mem_dropLast","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl : List α\na : α\nh : Membership.mem l.dropLast a\n⊢ Membership.mem l a","decl":"theorem mem_of_mem_dropLast (h : a ∈ l.dropLast) : a ∈ l :=\n  dropLast_subset l h\n\n"}
{"name":"List.concat_get_prefix","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nx y : List α\nh : x.IsPrefix y\nhl : LT.lt x.length y.length\n⊢ (HAppend.hAppend x (List.cons (y.get ⟨x.length, hl⟩) List.nil)).IsPrefix y","decl":"theorem concat_get_prefix {x y : List α} (h : x <+: y) (hl : x.length < y.length) :\n    x ++ [y.get ⟨x.length, hl⟩] <+: y := by\n  use y.drop (x.length + 1)\n  nth_rw 1 [List.prefix_iff_eq_take.mp h]\n  convert List.take_append_drop (x.length + 1) y using 2\n  rw [← List.take_concat_get, List.concat_eq_append]; rfl\n\n"}
{"name":"List.cons_prefix_iff","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl₁ l₂ : List α\na b : α\n⊢ Iff ((List.cons a l₁).IsPrefix (List.cons b l₂)) (And (Eq a b) (l₁.IsPrefix l₂))","decl":"@[deprecated cons_prefix_cons (since := \"2024-08-14\")]\ntheorem cons_prefix_iff : a :: l₁ <+: b :: l₂ ↔ a = b ∧ l₁ <+: l₂ := by\n  simp\n\n\n"}
{"name":"List.IsPrefix.reduceOption","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl₁ l₂ : List (Option α)\nh : l₁.IsPrefix l₂\n⊢ l₁.reduceOption.IsPrefix l₂.reduceOption","decl":"protected theorem IsPrefix.reduceOption {l₁ l₂ : List (Option α)} (h : l₁ <+: l₂) :\n    l₁.reduceOption <+: l₂.reduceOption :=\n  h.filterMap id\n\n"}
{"name":"List.instIsPartialOrderIsPrefix","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\n⊢ IsPartialOrder (List α) fun x1 x2 => x1.IsPrefix x2","decl":"instance : IsPartialOrder (List α) (· <+: ·) where\n  refl _ := prefix_rfl\n  trans _ _ _ := IsPrefix.trans\n  antisymm _ _ h₁ h₂ := h₁.eq_of_length <| h₁.length_le.antisymm h₂.length_le\n\n"}
{"name":"List.instIsPartialOrderIsSuffix","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\n⊢ IsPartialOrder (List α) fun x1 x2 => x1.IsSuffix x2","decl":"instance : IsPartialOrder (List α) (· <:+ ·) where\n  refl _ := suffix_rfl\n  trans _ _ _ := IsSuffix.trans\n  antisymm _ _ h₁ h₂ := h₁.eq_of_length <| h₁.length_le.antisymm h₂.length_le\n\n"}
{"name":"List.instIsPartialOrderIsInfix","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\n⊢ IsPartialOrder (List α) fun x1 x2 => x1.IsInfix x2","decl":"instance : IsPartialOrder (List α) (· <:+: ·) where\n  refl _ := infix_rfl\n  trans _ _ _ := IsInfix.trans\n  antisymm _ _ h₁ h₂ := h₁.eq_of_length <| h₁.length_le.antisymm h₂.length_le\n\n"}
{"name":"List.mem_inits","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\ns t : List α\n⊢ Iff (Membership.mem t.inits s) (s.IsPrefix t)","decl":"@[simp]\ntheorem mem_inits : ∀ s t : List α, s ∈ inits t ↔ s <+: t\n  | s, [] =>\n    suffices s = nil ↔ s <+: nil by simpa only [inits, mem_singleton]\n    ⟨fun h => h.symm ▸ prefix_rfl, eq_nil_of_prefix_nil⟩\n  | s, a :: t =>\n    suffices (s = nil ∨ ∃ l ∈ inits t, a :: l = s) ↔ s <+: a :: t by simpa\n    ⟨fun o =>\n      match s, o with\n      | _, Or.inl rfl => ⟨_, rfl⟩\n      | s, Or.inr ⟨r, hr, hs⟩ => by\n        let ⟨s, ht⟩ := (mem_inits _ _).1 hr\n        rw [← hs, ← ht]; exact ⟨s, rfl⟩,\n      fun mi =>\n      match s, mi with\n      | [], ⟨_, rfl⟩ => Or.inl rfl\n      | b :: s, ⟨r, hr⟩ =>\n        (List.noConfusion hr) fun ba (st : s ++ r = t) =>\n          Or.inr <| by rw [ba]; exact ⟨_, (mem_inits _ _).2 ⟨_, st⟩, rfl⟩⟩\n\n"}
{"name":"List.mem_tails","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\ns t : List α\n⊢ Iff (Membership.mem t.tails s) (s.IsSuffix t)","decl":"@[simp]\ntheorem mem_tails : ∀ s t : List α, s ∈ tails t ↔ s <:+ t\n  | s, [] => by\n    simp only [tails, mem_singleton, suffix_nil]\n  | s, a :: t => by\n    simp only [tails, mem_cons, mem_tails s t]\n    exact\n      show s = a :: t ∨ s <:+ t ↔ s <:+ a :: t from\n        ⟨fun o =>\n          match s, t, o with\n          | _, t, Or.inl rfl => suffix_rfl\n          | s, _, Or.inr ⟨l, rfl⟩ => ⟨a :: l, rfl⟩,\n          fun e =>\n          match s, t, e with\n          | _, t, ⟨[], rfl⟩ => Or.inl rfl\n          | s, t, ⟨b :: l, he⟩ => List.noConfusion he fun _ lt => Or.inr ⟨l, lt⟩⟩\n\n"}
{"name":"List.inits_cons","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\na : α\nl : List α\n⊢ Eq (List.cons a l).inits (List.cons List.nil (List.map (fun t => List.cons a t) l.inits))","decl":"theorem inits_cons (a : α) (l : List α) : inits (a :: l) = [] :: l.inits.map fun t => a :: t := by\n  simp\n\n"}
{"name":"List.tails_cons","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\na : α\nl : List α\n⊢ Eq (List.cons a l).tails (List.cons (List.cons a l) l.tails)","decl":"theorem tails_cons (a : α) (l : List α) : tails (a :: l) = (a :: l) :: l.tails := by simp\n\n"}
{"name":"List.inits_append","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\ns t : List α\n⊢ Eq (HAppend.hAppend s t).inits (HAppend.hAppend s.inits (List.map (fun l => HAppend.hAppend s l) t.inits.tail))","decl":"@[simp]\ntheorem inits_append : ∀ s t : List α, inits (s ++ t) = s.inits ++ t.inits.tail.map fun l => s ++ l\n  | [], [] => by simp\n  | [], a :: t => by simp\n  | a :: s, t => by simp [inits_append s t, Function.comp_def]\n\n"}
{"name":"List.tails_append","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\ns t : List α\n⊢ Eq (HAppend.hAppend s t).tails (HAppend.hAppend (List.map (fun l => HAppend.hAppend l t) s.tails) t.tails.tail)","decl":"@[simp]\ntheorem tails_append :\n    ∀ s t : List α, tails (s ++ t) = (s.tails.map fun l => l ++ t) ++ t.tails.tail\n  | [], [] => by simp\n  | [], a :: t => by simp\n  | a :: s, t => by simp [tails_append s t]\n\n-- the lemma names `inits_eq_tails` and `tails_eq_inits` are like `sublists_eq_sublists'`\n"}
{"name":"List.inits_eq_tails","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq l.inits (List.map List.reverse l.reverse.tails).reverse","decl":"theorem inits_eq_tails : ∀ l : List α, l.inits = (reverse <| map reverse <| tails <| reverse l)\n  | [] => by simp\n  | a :: l => by simp [inits_eq_tails l, map_inj_left, ← map_reverse]\n\n"}
{"name":"List.tails_eq_inits","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq l.tails (List.map List.reverse l.reverse.inits).reverse","decl":"theorem tails_eq_inits : ∀ l : List α, l.tails = (reverse <| map reverse <| inits <| reverse l)\n  | [] => by simp\n  | a :: l => by simp [tails_eq_inits l, append_left_inj]\n\n"}
{"name":"List.inits_reverse","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq l.reverse.inits (List.map List.reverse l.tails).reverse","decl":"theorem inits_reverse (l : List α) : inits (reverse l) = reverse (map reverse l.tails) := by\n  rw [tails_eq_inits l]\n  simp [reverse_involutive.comp_self, ← map_reverse]\n\n"}
{"name":"List.tails_reverse","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq l.reverse.tails (List.map List.reverse l.inits).reverse","decl":"theorem tails_reverse (l : List α) : tails (reverse l) = reverse (map reverse l.inits) := by\n  rw [inits_eq_tails l]\n  simp [reverse_involutive.comp_self, ← map_reverse]\n\n"}
{"name":"List.map_reverse_inits","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (List.map List.reverse l.inits) l.reverse.tails.reverse","decl":"theorem map_reverse_inits (l : List α) : map reverse l.inits = (reverse <| tails <| reverse l) := by\n  rw [inits_eq_tails l]\n  simp [reverse_involutive.comp_self, ← map_reverse]\n\n"}
{"name":"List.map_reverse_tails","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (List.map List.reverse l.tails) l.reverse.inits.reverse","decl":"theorem map_reverse_tails (l : List α) : map reverse l.tails = (reverse <| inits <| reverse l) := by\n  rw [tails_eq_inits l]\n  simp [reverse_involutive.comp_self, ← map_reverse]\n\n"}
{"name":"List.length_tails","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq l.tails.length (HAdd.hAdd l.length 1)","decl":"@[simp]\ntheorem length_tails (l : List α) : length (tails l) = length l + 1 := by\n  induction' l with x l IH\n  · simp\n  · simpa using IH\n\n"}
{"name":"List.length_inits","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq l.inits.length (HAdd.hAdd l.length 1)","decl":"@[simp]\ntheorem length_inits (l : List α) : length (inits l) = length l + 1 := by simp [inits_eq_tails]\n\n"}
{"name":"List.getElem_tails","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl : List α\nn : Nat\nh : LT.lt n l.tails.length\n⊢ Eq (GetElem.getElem l.tails n ⋯) (List.drop n l)","decl":"@[simp]\ntheorem getElem_tails (l : List α) (n : Nat) (h : n < (tails l).length) :\n    (tails l)[n] = l.drop n := by\n  induction l generalizing n with\n  | nil => simp\n  | cons a l ihl =>\n    cases n with\n    | zero => simp\n    | succ n => simp [ihl]\n\n"}
{"name":"List.get_tails","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl : List α\nn : Fin l.tails.length\n⊢ Eq (l.tails.get n) (List.drop (↑n) l)","decl":"theorem get_tails (l : List α) (n : Fin (length (tails l))) : (tails l).get n = l.drop n := by\n  simp\n\n"}
{"name":"List.getElem_inits","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl : List α\nn : Nat\nh : LT.lt n l.inits.length\n⊢ Eq (GetElem.getElem l.inits n ⋯) (List.take n l)","decl":"@[simp]\ntheorem getElem_inits (l : List α) (n : Nat) (h : n < length (inits l)) :\n    (inits l)[n] = l.take n := by\n  induction l generalizing n with\n  | nil => simp\n  | cons a l ihl =>\n    cases n with\n    | zero => simp\n    | succ n => simp [ihl]\n\n"}
{"name":"List.get_inits","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl : List α\nn : Fin l.inits.length\n⊢ Eq (l.inits.get n) (List.take (↑n) l)","decl":"theorem get_inits (l : List α) (n : Fin (length (inits l))) : (inits l).get n = l.take n := by\n  simp\n\n"}
{"name":"List.map_inits","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl : List α\nβ : Type u_2\ng : α → β\n⊢ Eq (List.map g l).inits (List.map (List.map g) l.inits)","decl":"lemma map_inits {β : Type*} (g : α → β) : (l.map g).inits = l.inits.map (map g) := by\n  induction' l using reverseRecOn <;> simp [*]\n\n"}
{"name":"List.map_tails","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl : List α\nβ : Type u_2\ng : α → β\n⊢ Eq (List.map g l).tails (List.map (List.map g) l.tails)","decl":"lemma map_tails {β : Type*} (g : α → β) : (l.map g).tails = l.tails.map (map g) := by\n  induction' l using reverseRecOn <;> simp [*]\n\n"}
{"name":"List.take_inits","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nl : List α\nn : Nat\n⊢ Eq (List.take n l).inits (List.take (HAdd.hAdd n 1) l.inits)","decl":"lemma take_inits {n} : (l.take n).inits = l.inits.take (n + 1) := by\n  apply ext_getElem <;> (simp [take_take]; omega)\n\n"}
{"name":"List.insert_eq_ite","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nl : List α\n⊢ Eq (Insert.insert a l) (ite (Membership.mem l a) l (List.cons a l))","decl":"theorem insert_eq_ite (a : α) (l : List α) : insert a l = if a ∈ l then l else a :: l := by\n  simp only [← elem_iff]\n  rfl\n\n"}
{"name":"List.suffix_insert","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nl : List α\n⊢ l.IsSuffix (List.insert a l)","decl":"@[simp]\ntheorem suffix_insert (a : α) (l : List α) : l <:+ l.insert a := by\n  by_cases h : a ∈ l\n  · simp only [insert_of_mem h, insert, suffix_refl]\n  · simp only [insert_of_not_mem h, suffix_cons, insert]\n\n"}
{"name":"List.infix_insert","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nl : List α\n⊢ l.IsInfix (List.insert a l)","decl":"theorem infix_insert (a : α) (l : List α) : l <:+: l.insert a :=\n  (suffix_insert a l).isInfix\n\n"}
{"name":"List.sublist_insert","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nl : List α\n⊢ l.Sublist (List.insert a l)","decl":"theorem sublist_insert (a : α) (l : List α) : l <+ l.insert a :=\n  (suffix_insert a l).sublist\n\n"}
{"name":"List.subset_insert","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nl : List α\n⊢ HasSubset.Subset l (List.insert a l)","decl":"theorem subset_insert (a : α) (l : List α) : l ⊆ l.insert a :=\n  (sublist_insert a l).subset\n\n"}
{"name":"List.mem_of_mem_suffix","module":"Mathlib.Data.List.Infix","initialProofState":"α✝ : Type u_1\nl₁ : List α✝\na : α✝\nl₂ : List α✝\nhx : Membership.mem l₁ a\nhl : l₁.IsSuffix l₂\n⊢ Membership.mem l₂ a","decl":"@[deprecated (since := \"2024-08-15\")] alias mem_of_mem_suffix := IsSuffix.mem\n\n"}
{"name":"List.IsPrefix.get_eq","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nx y : List α\nh : x.IsPrefix y\nn : Nat\nhn : LT.lt n x.length\n⊢ Eq (x.get ⟨n, hn⟩) (y.get ⟨n, ⋯⟩)","decl":"@[deprecated IsPrefix.getElem (since := \"2024-08-15\")]\ntheorem IsPrefix.get_eq {x y : List α} (h : x <+: y) {n} (hn : n < x.length) :\n    x.get ⟨n, hn⟩ = y.get ⟨n, hn.trans_le h.length_le⟩ := by\n  simp only [get_eq_getElem, IsPrefix.getElem h hn]\n\n"}
{"name":"List.IsPrefix.head_eq","module":"Mathlib.Data.List.Infix","initialProofState":"α : Type u_1\nx y : List α\nh : x.IsPrefix y\nhx : Ne x List.nil\n⊢ Eq (x.head hx) (y.head ⋯)","decl":"@[deprecated (since := \"2024-08-15\")] alias IsPrefix.head_eq := IsPrefix.head\n\n"}
