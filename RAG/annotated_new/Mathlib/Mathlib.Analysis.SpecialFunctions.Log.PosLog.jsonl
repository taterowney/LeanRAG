{"name":"Real.posLog_def","module":"Mathlib.Analysis.SpecialFunctions.Log.PosLog","initialProofState":"r : Real\n⊢ Eq r.posLog (Max.max 0 (Real.log r))","decl":"/-- Definition of the positive part of the logarithm, formulated as a theorem. -/\ntheorem posLog_def {r : ℝ} : log⁺ r = max 0 (log r) := rfl\n\n"}
{"name":"Real.posLog_sub_posLog_inv","module":"Mathlib.Analysis.SpecialFunctions.Log.PosLog","initialProofState":"r : Real\n⊢ Eq (HSub.hSub r.posLog (Inv.inv r).posLog) (Real.log r)","decl":"/-- Presentation of `log` in terms of its positive part. -/\ntheorem posLog_sub_posLog_inv {r : ℝ} : log⁺ r - log⁺ r⁻¹ = log r := by\n  rw [posLog_def, posLog_def, log_inv]\n  by_cases h : 0 ≤ log r\n  · simp [h]\n  · rw [not_le] at h\n    simp [neg_nonneg.1 (Left.nonneg_neg_iff.2 h.le)]\n\n"}
{"name":"Real.half_mul_log_add_log_abs","module":"Mathlib.Analysis.SpecialFunctions.Log.PosLog","initialProofState":"r : Real\n⊢ Eq (HMul.hMul (Inv.inv 2) (HAdd.hAdd (Real.log r) (abs (Real.log r)))) r.posLog","decl":"/-- Presentation of `log⁺` in terms of `log`. -/\ntheorem half_mul_log_add_log_abs {r : ℝ} : 2⁻¹ * (log r + |log r|) = log⁺ r := by\n  by_cases hr : 0 ≤ log r\n  · simp [posLog, hr, abs_of_nonneg]\n    ring\n  · simp [posLog, le_of_not_ge hr, abs_of_nonpos]\n\n"}
{"name":"Real.posLog_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Log.PosLog","initialProofState":"x : Real\n⊢ LE.le 0 x.posLog","decl":"/-- The positive part of `log` is never negative. -/\ntheorem posLog_nonneg {x : ℝ} : 0 ≤ log⁺ x := by simp [posLog]\n\n"}
{"name":"Real.posLog_neg","module":"Mathlib.Analysis.SpecialFunctions.Log.PosLog","initialProofState":"x : Real\n⊢ Eq (Neg.neg x).posLog x.posLog","decl":"/-- The function `log⁺` is even. -/\n@[simp] theorem posLog_neg (x : ℝ) : log⁺ (-x) = log⁺ x := by simp [posLog]\n\n"}
{"name":"Real.posLog_abs","module":"Mathlib.Analysis.SpecialFunctions.Log.PosLog","initialProofState":"x : Real\n⊢ Eq (abs x).posLog x.posLog","decl":"/-- The function `log⁺` is even. -/\n@[simp] theorem posLog_abs (x : ℝ) : log⁺ |x| = log⁺ x := by simp [posLog]\n\n"}
{"name":"Real.posLog_eq_zero_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.PosLog","initialProofState":"x : Real\n⊢ Iff (Eq x.posLog 0) (LE.le (abs x) 1)","decl":"/-- The function `log⁺` is zero in the interval [-1,1]. -/\ntheorem posLog_eq_zero_iff (x : ℝ) : log⁺ x = 0 ↔ |x| ≤ 1 := by\n  rw [← posLog_abs, ← log_nonpos_iff (abs_nonneg x)]\n  simp [posLog]\n\n"}
{"name":"Real.posLog_eq_log","module":"Mathlib.Analysis.SpecialFunctions.Log.PosLog","initialProofState":"x : Real\nhx : LE.le 1 (abs x)\n⊢ Eq x.posLog (Real.log x)","decl":"/-- The function `log⁺` equals `log` outside of the interval (-1,1). -/\ntheorem posLog_eq_log {x : ℝ} (hx : 1 ≤ |x|) : log⁺ x = log x := by\n  simp only [posLog, sup_eq_right]\n  rw [← log_abs]\n  apply log_nonneg hx\n\n"}
{"name":"Real.log_of_nat_eq_posLog","module":"Mathlib.Analysis.SpecialFunctions.Log.PosLog","initialProofState":"n : Nat\n⊢ Eq (↑n).posLog (Real.log ↑n)","decl":"/-- The function `log⁺` equals `log` for all natural numbers. -/\ntheorem log_of_nat_eq_posLog {n : ℕ} : log⁺ n = log n := by\n  by_cases hn : n = 0\n  · simp [hn, posLog]\n  · simp [posLog_eq_log, Nat.one_le_iff_ne_zero.2 hn]\n\n"}
{"name":"Real.monotoneOn_posLog","module":"Mathlib.Analysis.SpecialFunctions.Log.PosLog","initialProofState":"⊢ MonotoneOn Real.posLog (Set.Ici 0)","decl":"/-- The function `log⁺` is monotone on the positive axis. -/\ntheorem monotoneOn_posLog : MonotoneOn log⁺ (Set.Ici 0) := by\n  intro x hx y hy hxy\n  simp only [posLog, le_sup_iff, sup_le_iff, le_refl, true_and]\n  by_cases h : log x ≤ 0\n  · tauto\n  · right\n    have := log_le_log (lt_trans Real.zero_lt_one ((log_pos_iff hx).1 (not_le.1 h))) hxy\n    simp only [this, and_true, ge_iff_le]\n    linarith\n\n"}
{"name":"Real.posLog_mul","module":"Mathlib.Analysis.SpecialFunctions.Log.PosLog","initialProofState":"a b : Real\n⊢ LE.le (HMul.hMul a b).posLog (HAdd.hAdd a.posLog b.posLog)","decl":"/-- Estimate for `log⁺` of a product. See `Real.posLog_prod` for a variant involving\nmultiple factors. -/\ntheorem posLog_mul {a b : ℝ} :\n    log⁺ (a * b) ≤ log⁺ a + log⁺ b := by\n  by_cases ha : a = 0\n  · simp [ha, posLog]\n  by_cases hb : b = 0\n  · simp [hb, posLog]\n  unfold posLog\n  nth_rw 1 [← add_zero 0, log_mul ha hb]\n  exact max_add_add_le_max_add_max\n\n"}
{"name":"Real.posLog_nat_mul","module":"Mathlib.Analysis.SpecialFunctions.Log.PosLog","initialProofState":"n : Nat\na : Real\n⊢ LE.le (HMul.hMul (↑n) a).posLog (HAdd.hAdd (Real.log ↑n) a.posLog)","decl":"/-- Estimate for `log⁺` of a product. Special case of `Real.posLog_mul` where one of\nthe factors is a natural number. -/\ntheorem posLog_nat_mul {n : ℕ} {a : ℝ} :\n    log⁺ (n * a) ≤ log n + log⁺ a := by\n  rw [← log_of_nat_eq_posLog]\n  exact posLog_mul\n\n"}
{"name":"Real.posLog_prod","module":"Mathlib.Analysis.SpecialFunctions.Log.PosLog","initialProofState":"α : Type u_1\ns : Finset α\nf : α → Real\n⊢ LE.le (s.prod fun t => f t).posLog (s.sum fun t => (f t).posLog)","decl":"/-- Estimate for `log⁺` of a product. See `Real.posLog_mul` for a variant with\nonly two factors. -/\ntheorem posLog_prod {α : Type*} (s : Finset α) (f : α → ℝ) :\n    log⁺ (∏ t ∈ s, f t) ≤ ∑ t ∈ s, log⁺ (f t) := by\n  classical\n  apply Finset.induction (p := fun (S : Finset α) ↦ (log⁺ (∏ t ∈ S, f t) ≤ ∑ t ∈ S, log⁺ (f t)))\n  · -- Empty set\n    simp [posLog]\n  · -- Non empty set\n    intro a s ha hs\n    calc log⁺ (∏ t ∈ insert a s, f t)\n    _ = log⁺ (f a * ∏ t ∈ s, f t) := by rw [Finset.prod_insert ha]\n    _ ≤ log⁺ (f a) + log⁺ (∏ t ∈ s, f t) := posLog_mul\n    _ ≤ log⁺ (f a) + ∑ t ∈ s, log⁺ (f t) := add_le_add (by rfl) hs\n    _ = ∑ t ∈ insert a s, log⁺ (f t) := by rw [Finset.sum_insert ha]\n\n"}
{"name":"Real.posLog_sum","module":"Mathlib.Analysis.SpecialFunctions.Log.PosLog","initialProofState":"α : Type u_1\ns : Finset α\nf : α → Real\n⊢ LE.le (s.sum fun t => f t).posLog (HAdd.hAdd (Real.log ↑s.card) (s.sum fun t => (f t).posLog))","decl":"/-- Estimate for `log⁺` of a sum. See `Real.posLog_add` for a variant involving\njust two summands. -/\ntheorem posLog_sum {α : Type*} (s : Finset α) (f : α → ℝ) :\n    log⁺ (∑ t ∈ s, f t) ≤ log (s.card) + ∑ t ∈ s, log⁺ (f t) := by\n  -- Trivial case: empty sum\n  by_cases hs : s = ∅\n  · simp [hs, posLog]\n  -- Nontrivial case: Obtain maximal element…\n  obtain ⟨t_max, ht_max⟩ := s.exists_max_image (fun t ↦ |f t|)\n    (Finset.nonempty_iff_ne_empty.mpr hs)\n  -- …then calculate\n  calc log⁺ (∑ t ∈ s, f t)\n  _ = log⁺ |∑ t ∈ s, f t| := by\n    rw [Real.posLog_abs]\n  _ ≤ log⁺ (∑ t ∈ s, |f t|) := by\n    apply monotoneOn_posLog (by simp) (by simp [Finset.sum_nonneg])\n    simp [Finset.abs_sum_le_sum_abs]\n  _ ≤ log⁺ (∑ t ∈ s, |f t_max|) := by\n    apply monotoneOn_posLog (by simp [Finset.sum_nonneg]) (by simp [Finset.sum_nonneg]; positivity)\n    apply Finset.sum_le_sum (fun i ih ↦ ht_max.2 i ih)\n  _ = log⁺ (s.card * |f t_max|) := by\n    simp [Finset.sum_const]\n  _ ≤ log s.card + log⁺ |f t_max| := posLog_nat_mul\n  _ ≤ log s.card + ∑ t ∈ s, log⁺ (f t) := by\n    gcongr\n    rw [posLog_abs]\n    apply Finset.single_le_sum (fun _ _ ↦ posLog_nonneg) ht_max.1\n\n"}
{"name":"Real.posLog_add","module":"Mathlib.Analysis.SpecialFunctions.Log.PosLog","initialProofState":"a b : Real\n⊢ LE.le (HAdd.hAdd a b).posLog (HAdd.hAdd (HAdd.hAdd (Real.log 2) a.posLog) b.posLog)","decl":"/-- Estimate for `log⁺` of a sum. See `Real.posLog_sum` for a variant involving\nmultiple summands. -/\ntheorem posLog_add {a b : ℝ} : log⁺ (a + b) ≤ log 2 + log⁺ a + log⁺ b := by\n  convert posLog_sum Finset.univ ![a, b] using 1 <;> simp [add_assoc]\n\n"}
