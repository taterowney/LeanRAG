{"name":"Nat.support_factorization","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"n : Nat\n⊢ Eq n.factorization.support n.primeFactors","decl":"/-- The support of `n.factorization` is exactly `n.primeFactors`. -/\n@[simp] lemma support_factorization (n : ℕ) : (factorization n).support = n.primeFactors := rfl\n\n"}
{"name":"Nat.factorization_def","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"n p : Nat\npp : Nat.Prime p\n⊢ Eq (n.factorization p) (padicValNat p n)","decl":"theorem factorization_def (n : ℕ) {p : ℕ} (pp : p.Prime) : n.factorization p = padicValNat p n := by\n  simpa [factorization] using absurd pp\n\n"}
{"name":"Nat.primeFactorsList_count_eq","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"n p : Nat\n⊢ Eq (List.count p n.primeFactorsList) (n.factorization p)","decl":"/-- We can write both `n.factorization p` and `n.factors.count p` to represent the power\nof `p` in the factorization of `n`: we declare the former to be the simp-normal form. -/\n@[simp]\ntheorem primeFactorsList_count_eq {n p : ℕ} : n.primeFactorsList.count p = n.factorization p := by\n  rcases n.eq_zero_or_pos with (rfl | hn0)\n  · simp [factorization, count]\n  if pp : p.Prime then ?_ else\n    rw [count_eq_zero_of_not_mem (mt prime_of_mem_primeFactorsList pp)]\n    simp [factorization, pp]\n  simp only [factorization_def _ pp]\n  apply _root_.le_antisymm\n  · rw [le_padicValNat_iff_replicate_subperm_primeFactorsList pp hn0.ne']\n    exact List.le_count_iff_replicate_sublist.mp le_rfl |>.subperm\n  · rw [← Nat.lt_add_one_iff, lt_iff_not_ge, ge_iff_le,\n      le_padicValNat_iff_replicate_subperm_primeFactorsList pp hn0.ne']\n    intro h\n    have := h.count_le p\n    simp at this\n\n"}
{"name":"Nat.factorization_eq_primeFactorsList_multiset","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"n : Nat\n⊢ Eq n.factorization (Multiset.toFinsupp ↑n.primeFactorsList)","decl":"theorem factorization_eq_primeFactorsList_multiset (n : ℕ) :\n    n.factorization = Multiset.toFinsupp (n.primeFactorsList : Multiset ℕ) := by\n  ext p\n  simp\n\n"}
{"name":"Nat.Prime.factorization_pos_of_dvd","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"n p : Nat\nhp : Nat.Prime p\nhn : Ne n 0\nh : Dvd.dvd p n\n⊢ LT.lt 0 (n.factorization p)","decl":"theorem Prime.factorization_pos_of_dvd {n p : ℕ} (hp : p.Prime) (hn : n ≠ 0) (h : p ∣ n) :\n    0 < n.factorization p := by\n    rwa [← primeFactorsList_count_eq, count_pos_iff, mem_primeFactorsList_iff_dvd hn hp]\n\n"}
{"name":"Nat.multiplicity_eq_factorization","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"n p : Nat\npp : Nat.Prime p\nhn : Ne n 0\n⊢ Eq (multiplicity p n) (n.factorization p)","decl":"theorem multiplicity_eq_factorization {n p : ℕ} (pp : p.Prime) (hn : n ≠ 0) :\n    multiplicity p n = n.factorization p := by\n  simp [factorization, pp, padicValNat_def' pp.ne_one hn.bot_lt]\n\n"}
{"name":"Nat.factorization_prod_pow_eq_self","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"n : Nat\nhn : Ne n 0\n⊢ Eq (n.factorization.prod fun x1 x2 => HPow.hPow x1 x2) n","decl":"@[simp]\ntheorem factorization_prod_pow_eq_self {n : ℕ} (hn : n ≠ 0) : n.factorization.prod (· ^ ·) = n := by\n  rw [factorization_eq_primeFactorsList_multiset n]\n  simp only [← prod_toMultiset, factorization, Multiset.prod_coe, Multiset.toFinsupp_toMultiset]\n  exact prod_primeFactorsList hn\n\n"}
{"name":"Nat.eq_of_factorization_eq","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"a b : Nat\nha : Ne a 0\nhb : Ne b 0\nh : ∀ (p : Nat), Eq (a.factorization p) (b.factorization p)\n⊢ Eq a b","decl":"theorem eq_of_factorization_eq {a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0)\n    (h : ∀ p : ℕ, a.factorization p = b.factorization p) : a = b :=\n  eq_of_perm_primeFactorsList ha hb\n    (by simpa only [List.perm_iff_count, primeFactorsList_count_eq] using h)\n\n\n"}
{"name":"Nat.factorization_inj","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"⊢ Set.InjOn Nat.factorization (setOf fun x => Ne x 0)","decl":"/-- Every nonzero natural number has a unique prime factorization -/\ntheorem factorization_inj : Set.InjOn factorization { x : ℕ | x ≠ 0 } := fun a ha b hb h =>\n  eq_of_factorization_eq ha hb fun p => by simp [h]\n\n"}
{"name":"Nat.factorization_zero","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"⊢ Eq (Nat.factorization 0) 0","decl":"@[simp]\ntheorem factorization_zero : factorization 0 = 0 := by ext; simp [factorization]\n\n"}
{"name":"Nat.factorization_one","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"⊢ Eq (Nat.factorization 1) 0","decl":"@[simp]\ntheorem factorization_one : factorization 1 = 0 := by ext; simp [factorization]\n\n"}
{"name":"Nat.factorization_eq_zero_iff","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"n p : Nat\n⊢ Iff (Eq (n.factorization p) 0) (Or (Not (Nat.Prime p)) (Or (Not (Dvd.dvd p n)) (Eq n 0)))","decl":"theorem factorization_eq_zero_iff (n p : ℕ) :\n    n.factorization p = 0 ↔ ¬p.Prime ∨ ¬p ∣ n ∨ n = 0 := by\n  simp_rw [← not_mem_support_iff, support_factorization, mem_primeFactors, not_and_or, not_ne_iff]\n\n"}
{"name":"Nat.factorization_eq_zero_of_non_prime","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"n p : Nat\nhp : Not (Nat.Prime p)\n⊢ Eq (n.factorization p) 0","decl":"@[simp]\ntheorem factorization_eq_zero_of_non_prime (n : ℕ) {p : ℕ} (hp : ¬p.Prime) :\n    n.factorization p = 0 := by simp [factorization_eq_zero_iff, hp]\n\n"}
{"name":"Nat.factorization_zero_right","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"n : Nat\n⊢ Eq (n.factorization 0) 0","decl":"@[simp]\ntheorem factorization_zero_right (n : ℕ) : n.factorization 0 = 0 :=\n  factorization_eq_zero_of_non_prime _ not_prime_zero\n\n"}
{"name":"Nat.factorization_eq_zero_of_not_dvd","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"n p : Nat\nh : Not (Dvd.dvd p n)\n⊢ Eq (n.factorization p) 0","decl":"theorem factorization_eq_zero_of_not_dvd {n p : ℕ} (h : ¬p ∣ n) : n.factorization p = 0 := by\n  simp [factorization_eq_zero_iff, h]\n\n"}
{"name":"Nat.factorization_eq_zero_of_remainder","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"p r i : Nat\nhr : Not (Dvd.dvd p r)\n⊢ Eq ((HAdd.hAdd (HMul.hMul p i) r).factorization p) 0","decl":"theorem factorization_eq_zero_of_remainder {p r : ℕ} (i : ℕ) (hr : ¬p ∣ r) :\n    (p * i + r).factorization p = 0 := by\n  apply factorization_eq_zero_of_not_dvd\n  rwa [← Nat.dvd_add_iff_right (Dvd.intro i rfl)]\n\n"}
{"name":"Nat.factorization_mul","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"a b : Nat\nha : Ne a 0\nhb : Ne b 0\n⊢ Eq (HMul.hMul a b).factorization (HAdd.hAdd a.factorization b.factorization)","decl":"/-- For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b` -/\n@[simp]\ntheorem factorization_mul {a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0) :\n    (a * b).factorization = a.factorization + b.factorization := by\n  ext p\n  simp only [add_apply, ← primeFactorsList_count_eq,\n    perm_iff_count.mp (perm_primeFactorsList_mul ha hb) p, count_append]\n\n"}
{"name":"Nat.factorization_le_iff_dvd","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"d n : Nat\nhd : Ne d 0\nhn : Ne n 0\n⊢ Iff (LE.le d.factorization n.factorization) (Dvd.dvd d n)","decl":"theorem factorization_le_iff_dvd {d n : ℕ} (hd : d ≠ 0) (hn : n ≠ 0) :\n    d.factorization ≤ n.factorization ↔ d ∣ n := by\n  constructor\n  · intro hdn\n    set K := n.factorization - d.factorization with hK\n    use K.prod (· ^ ·)\n    rw [← factorization_prod_pow_eq_self hn, ← factorization_prod_pow_eq_self hd,\n        ← Finsupp.prod_add_index' pow_zero pow_add, hK, add_tsub_cancel_of_le hdn]\n  · rintro ⟨c, rfl⟩\n    rw [factorization_mul hd (right_ne_zero_of_mul hn)]\n    simp\n\n"}
{"name":"Nat.factorization_prod","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"α : Type u_1\nS : Finset α\ng : α → Nat\nhS : ∀ (x : α), Membership.mem S x → Ne (g x) 0\n⊢ Eq (S.prod g).factorization (S.sum fun x => (g x).factorization)","decl":"/-- For any `p : ℕ` and any function `g : α → ℕ` that's non-zero on `S : Finset α`,\nthe power of `p` in `S.prod g` equals the sum over `x ∈ S` of the powers of `p` in `g x`.\nGeneralises `factorization_mul`, which is the special case where `#S = 2` and `g = id`. -/\ntheorem factorization_prod {α : Type*} {S : Finset α} {g : α → ℕ} (hS : ∀ x ∈ S, g x ≠ 0) :\n    (S.prod g).factorization = S.sum fun x => (g x).factorization := by\n  classical\n    ext p\n    refine Finset.induction_on' S ?_ ?_\n    · simp\n    · intro x T hxS hTS hxT IH\n      have hT : T.prod g ≠ 0 := prod_ne_zero_iff.mpr fun x hx => hS x (hTS hx)\n      simp [prod_insert hxT, sum_insert hxT, IH, factorization_mul (hS x hxS) hT]\n\n"}
{"name":"Nat.factorization_pow","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"n k : Nat\n⊢ Eq (HPow.hPow n k).factorization (HSMul.hSMul k n.factorization)","decl":"/-- For any `p`, the power of `p` in `n^k` is `k` times the power in `n` -/\n@[simp]\ntheorem factorization_pow (n k : ℕ) : factorization (n ^ k) = k • n.factorization := by\n  induction' k with k ih; · simp\n  rcases eq_or_ne n 0 with (rfl | hn)\n  · simp\n  rw [Nat.pow_succ, mul_comm, factorization_mul hn (pow_ne_zero _ hn), ih,\n    add_smul, one_smul, add_comm]\n\n"}
{"name":"Nat.Prime.factorization","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"p : Nat\nhp : Nat.Prime p\n⊢ Eq p.factorization (Finsupp.single p 1)","decl":"/-- The only prime factor of prime `p` is `p` itself, with multiplicity `1` -/\n@[simp]\nprotected theorem Prime.factorization {p : ℕ} (hp : Prime p) : p.factorization = single p 1 := by\n  ext q\n  rw [← primeFactorsList_count_eq, primeFactorsList_prime hp, single_apply, count_singleton',\n    if_congr eq_comm] <;> rfl\n\n"}
{"name":"Nat.Prime.factorization_pow","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"p k : Nat\nhp : Nat.Prime p\n⊢ Eq (HPow.hPow p k).factorization (Finsupp.single p k)","decl":"/-- For prime `p` the only prime factor of `p^k` is `p` with multiplicity `k` -/\ntheorem Prime.factorization_pow {p k : ℕ} (hp : Prime p) : (p ^ k).factorization = single p k := by\n  simp [hp]\n\n"}
{"name":"Nat.pow_succ_factorization_not_dvd","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"n p : Nat\nhn : Ne n 0\nhp : Nat.Prime p\n⊢ Not (Dvd.dvd (HPow.hPow p (HAdd.hAdd (n.factorization p) 1)) n)","decl":"theorem pow_succ_factorization_not_dvd {n p : ℕ} (hn : n ≠ 0) (hp : p.Prime) :\n    ¬p ^ (n.factorization p + 1) ∣ n := by\n  intro h\n  rw [← factorization_le_iff_dvd (pow_pos hp.pos _).ne' hn] at h\n  simpa [hp.factorization] using h p\n\n"}
{"name":"Nat.prod_pow_factorization_eq_self","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"f : Finsupp Nat Nat\nhf : ∀ (p : Nat), Membership.mem f.support p → Nat.Prime p\n⊢ Eq (f.prod fun x1 x2 => HPow.hPow x1 x2).factorization f","decl":"/-- Any Finsupp `f : ℕ →₀ ℕ` whose support is in the primes is equal to the factorization of\nthe product `∏ (a : ℕ) ∈ f.support, a ^ f a`. -/\ntheorem prod_pow_factorization_eq_self {f : ℕ →₀ ℕ} (hf : ∀ p : ℕ, p ∈ f.support → Prime p) :\n    (f.prod (· ^ ·)).factorization = f := by\n  have h : ∀ x : ℕ, x ∈ f.support → x ^ f x ≠ 0 := fun p hp =>\n    pow_ne_zero _ (Prime.ne_zero (hf p hp))\n  simp only [Finsupp.prod, factorization_prod h]\n  conv =>\n    rhs\n    rw [(sum_single f).symm]\n  exact sum_congr rfl fun p hp => Prime.factorization_pow (hf p hp)\n\n"}
{"name":"Nat.factorization_mul_apply_of_coprime","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"p a b : Nat\nhab : a.Coprime b\n⊢ Eq ((HMul.hMul a b).factorization p) (HAdd.hAdd (a.factorization p) (b.factorization p))","decl":"/-- For coprime `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b` -/\ntheorem factorization_mul_apply_of_coprime {p a b : ℕ} (hab : Coprime a b) :\n    (a * b).factorization p = a.factorization p + b.factorization p := by\n  simp only [← primeFactorsList_count_eq,\n    perm_iff_count.mp (perm_primeFactorsList_mul_of_coprime hab), count_append]\n\n"}
{"name":"Nat.factorization_mul_of_coprime","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"a b : Nat\nhab : a.Coprime b\n⊢ Eq (HMul.hMul a b).factorization (HAdd.hAdd a.factorization b.factorization)","decl":"/-- For coprime `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b` -/\ntheorem factorization_mul_of_coprime {a b : ℕ} (hab : Coprime a b) :\n    (a * b).factorization = a.factorization + b.factorization := by\n  ext q\n  rw [Finsupp.add_apply, factorization_mul_apply_of_coprime hab]\n\n"}
{"name":"Nat.ordProj_dvd","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"n p : Nat\n⊢ Dvd.dvd (HPow.hPow p (n.factorization p)) n","decl":"theorem ordProj_dvd (n p : ℕ) : ordProj[p] n ∣ n := by\n  if hp : p.Prime then ?_ else simp [hp]\n  rw [← primeFactorsList_count_eq]\n  apply dvd_of_primeFactorsList_subperm (pow_ne_zero _ hp.ne_zero)\n  rw [hp.primeFactorsList_pow, List.subperm_ext_iff]\n  intro q hq\n  simp [List.eq_of_mem_replicate hq]\n\n"}
{"name":"Nat.ord_proj_dvd","module":"Mathlib.Data.Nat.Factorization.Defs","initialProofState":"n p : Nat\n⊢ Dvd.dvd (HPow.hPow p (n.factorization p)) n","decl":"@[deprecated (since := \"2024-10-24\")] alias ord_proj_dvd := ordProj_dvd\n\n"}
