{"name":"AdjoinRoot.nontrivial","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nf : Polynomial R\ninst✝ : IsDomain R\nh : Ne f.degree 0\n⊢ Nontrivial (AdjoinRoot f)","decl":"protected theorem nontrivial [IsDomain R] (h : degree f ≠ 0) : Nontrivial (AdjoinRoot f) :=\n  Ideal.Quotient.nontrivial\n    (by\n      simp_rw [Ne, span_singleton_eq_top, Polynomial.isUnit_iff, not_exists, not_and]\n      rintro x hx rfl\n      exact h (degree_C hx.ne_zero))\n\n"}
{"name":"AdjoinRoot.induction_on","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf : Polynomial R\nC : AdjoinRoot f → Prop\nx : AdjoinRoot f\nih : ∀ (p : Polynomial R), C ((AdjoinRoot.mk f) p)\n⊢ C x","decl":"@[elab_as_elim]\ntheorem induction_on {C : AdjoinRoot f → Prop} (x : AdjoinRoot f) (ih : ∀ p : R[X], C (mk f p)) :\n    C x :=\n  Quotient.inductionOn' x ih\n\n"}
{"name":"AdjoinRoot.smul_mk","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\nf : Polynomial R\ninst✝¹ : DistribSMul S R\ninst✝ : IsScalarTower S R R\na : S\nx : Polynomial R\n⊢ Eq (HSMul.hSMul a ((AdjoinRoot.mk f) x)) ((AdjoinRoot.mk f) (HSMul.hSMul a x))","decl":"@[simp]\ntheorem smul_mk [DistribSMul S R] [IsScalarTower S R R] (a : S) (x : R[X]) :\n    a • mk f x = mk f (a • x) :=\n  rfl\n\n"}
{"name":"AdjoinRoot.smul_of","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\nf : Polynomial R\ninst✝¹ : DistribSMul S R\ninst✝ : IsScalarTower S R R\na : S\nx : R\n⊢ Eq (HSMul.hSMul a ((AdjoinRoot.of f) x)) ((AdjoinRoot.of f) (HSMul.hSMul a x))","decl":"theorem smul_of [DistribSMul S R] [IsScalarTower S R R] (a : S) (x : R) :\n    a • of f x = of f (a • x) := by rw [of, RingHom.comp_apply, RingHom.comp_apply, smul_mk, smul_C]\n\n"}
{"name":"AdjoinRoot.instIsScalarTower","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝⁶ : CommRing R\nR₁ : Type u_1\nR₂ : Type u_2\ninst✝⁵ : SMul R₁ R₂\ninst✝⁴ : DistribSMul R₁ R\ninst✝³ : DistribSMul R₂ R\ninst✝² : IsScalarTower R₁ R R\ninst✝¹ : IsScalarTower R₂ R R\ninst✝ : IsScalarTower R₁ R₂ R\nf : Polynomial R\n⊢ IsScalarTower R₁ R₂ (AdjoinRoot f)","decl":"instance (R₁ R₂ : Type*) [SMul R₁ R₂] [DistribSMul R₁ R] [DistribSMul R₂ R] [IsScalarTower R₁ R R]\n    [IsScalarTower R₂ R R] [IsScalarTower R₁ R₂ R] (f : R[X]) :\n    IsScalarTower R₁ R₂ (AdjoinRoot f) :=\n  Submodule.Quotient.isScalarTower _ _\n\n"}
{"name":"AdjoinRoot.instSMulCommClass","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝⁵ : CommRing R\nR₁ : Type u_1\nR₂ : Type u_2\ninst✝⁴ : DistribSMul R₁ R\ninst✝³ : DistribSMul R₂ R\ninst✝² : IsScalarTower R₁ R R\ninst✝¹ : IsScalarTower R₂ R R\ninst✝ : SMulCommClass R₁ R₂ R\nf : Polynomial R\n⊢ SMulCommClass R₁ R₂ (AdjoinRoot f)","decl":"instance (R₁ R₂ : Type*) [DistribSMul R₁ R] [DistribSMul R₂ R] [IsScalarTower R₁ R R]\n    [IsScalarTower R₂ R R] [SMulCommClass R₁ R₂ R] (f : R[X]) :\n    SMulCommClass R₁ R₂ (AdjoinRoot f) :=\n  Submodule.Quotient.smulCommClass _ _\n\n"}
{"name":"AdjoinRoot.isScalarTower_right","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\nf : Polynomial R\ninst✝¹ : DistribSMul S R\ninst✝ : IsScalarTower S R R\n⊢ IsScalarTower S (AdjoinRoot f) (AdjoinRoot f)","decl":"instance isScalarTower_right [DistribSMul S R] [IsScalarTower S R R] :\n    IsScalarTower S (AdjoinRoot f) (AdjoinRoot f) :=\n  Ideal.Quotient.isScalarTower_right\n\n"}
{"name":"AdjoinRoot.algebraMap_eq","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf : Polynomial R\n⊢ Eq (algebraMap R (AdjoinRoot f)) (AdjoinRoot.of f)","decl":"@[simp]\ntheorem algebraMap_eq : algebraMap R (AdjoinRoot f) = of f :=\n  rfl\n\n"}
{"name":"AdjoinRoot.algebraMap_eq'","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\nf : Polynomial R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra S R\n⊢ Eq (algebraMap S (AdjoinRoot f)) ((AdjoinRoot.of f).comp (algebraMap S R))","decl":"theorem algebraMap_eq' [CommSemiring S] [Algebra S R] :\n    algebraMap S (AdjoinRoot f) = (of f).comp (algebraMap S R) :=\n  rfl\n\n"}
{"name":"AdjoinRoot.finiteType","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf : Polynomial R\n⊢ Algebra.FiniteType R (AdjoinRoot f)","decl":"theorem finiteType : Algebra.FiniteType R (AdjoinRoot f) :=\n  (Algebra.FiniteType.polynomial R).of_surjective _ (Ideal.Quotient.mkₐ_surjective R _)\n\n"}
{"name":"AdjoinRoot.finitePresentation","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf : Polynomial R\n⊢ Algebra.FinitePresentation R (AdjoinRoot f)","decl":"theorem finitePresentation : Algebra.FinitePresentation R (AdjoinRoot f) :=\n  (Algebra.FinitePresentation.polynomial R).quotient (Submodule.fg_span_singleton f)\n\n"}
{"name":"AdjoinRoot.algHom_ext_iff","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\nf : Polynomial R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\ng₁ g₂ : AlgHom R (AdjoinRoot f) S\n⊢ Iff (Eq g₁ g₂) (Eq (g₁ (AdjoinRoot.root f)) (g₂ (AdjoinRoot.root f)))","decl":"/-- Two `R`-`AlgHom` from `AdjoinRoot f` to the same `R`-algebra are the same iff\n    they agree on `root f`. -/\n@[ext]\ntheorem algHom_ext [Semiring S] [Algebra R S] {g₁ g₂ : AdjoinRoot f →ₐ[R] S}\n    (h : g₁ (root f) = g₂ (root f)) : g₁ = g₂ :=\n  Ideal.Quotient.algHom_ext R <| Polynomial.algHom_ext h\n\n"}
{"name":"AdjoinRoot.algHom_ext","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\nf : Polynomial R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\ng₁ g₂ : AlgHom R (AdjoinRoot f) S\nh : Eq (g₁ (AdjoinRoot.root f)) (g₂ (AdjoinRoot.root f))\n⊢ Eq g₁ g₂","decl":"/-- Two `R`-`AlgHom` from `AdjoinRoot f` to the same `R`-algebra are the same iff\n    they agree on `root f`. -/\n@[ext]\ntheorem algHom_ext [Semiring S] [Algebra R S] {g₁ g₂ : AdjoinRoot f →ₐ[R] S}\n    (h : g₁ (root f) = g₂ (root f)) : g₁ = g₂ :=\n  Ideal.Quotient.algHom_ext R <| Polynomial.algHom_ext h\n\n"}
{"name":"AdjoinRoot.mk_eq_mk","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf g h : Polynomial R\n⊢ Iff (Eq ((AdjoinRoot.mk f) g) ((AdjoinRoot.mk f) h)) (Dvd.dvd f (HSub.hSub g h))","decl":"@[simp]\ntheorem mk_eq_mk {g h : R[X]} : mk f g = mk f h ↔ f ∣ g - h :=\n  Ideal.Quotient.eq.trans Ideal.mem_span_singleton\n\n"}
{"name":"AdjoinRoot.mk_eq_zero","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf g : Polynomial R\n⊢ Iff (Eq ((AdjoinRoot.mk f) g) 0) (Dvd.dvd f g)","decl":"@[simp]\ntheorem mk_eq_zero {g : R[X]} : mk f g = 0 ↔ f ∣ g :=\n  mk_eq_mk.trans <| by rw [sub_zero]\n\n"}
{"name":"AdjoinRoot.mk_self","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf : Polynomial R\n⊢ Eq ((AdjoinRoot.mk f) f) 0","decl":"@[simp]\ntheorem mk_self : mk f f = 0 :=\n  Quotient.sound' <| QuotientAddGroup.leftRel_apply.mpr (mem_span_singleton.2 <| by simp)\n\n"}
{"name":"AdjoinRoot.mk_C","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf : Polynomial R\nx : R\n⊢ Eq ((AdjoinRoot.mk f) (Polynomial.C x)) ((AdjoinRoot.of f) x)","decl":"@[simp]\ntheorem mk_C (x : R) : mk f (C x) = x :=\n  rfl\n\n"}
{"name":"AdjoinRoot.mk_X","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf : Polynomial R\n⊢ Eq ((AdjoinRoot.mk f) Polynomial.X) (AdjoinRoot.root f)","decl":"@[simp]\ntheorem mk_X : mk f X = root f :=\n  rfl\n\n"}
{"name":"AdjoinRoot.mk_ne_zero_of_degree_lt","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf : Polynomial R\nhf : f.Monic\ng : Polynomial R\nh0 : Ne g 0\nhd : LT.lt g.degree f.degree\n⊢ Ne ((AdjoinRoot.mk f) g) 0","decl":"theorem mk_ne_zero_of_degree_lt (hf : Monic f) {g : R[X]} (h0 : g ≠ 0) (hd : degree g < degree f) :\n    mk f g ≠ 0 :=\n  mk_eq_zero.not.2 <| hf.not_dvd_of_degree_lt h0 hd\n\n"}
{"name":"AdjoinRoot.mk_ne_zero_of_natDegree_lt","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf : Polynomial R\nhf : f.Monic\ng : Polynomial R\nh0 : Ne g 0\nhd : LT.lt g.natDegree f.natDegree\n⊢ Ne ((AdjoinRoot.mk f) g) 0","decl":"theorem mk_ne_zero_of_natDegree_lt (hf : Monic f) {g : R[X]} (h0 : g ≠ 0)\n    (hd : natDegree g < natDegree f) : mk f g ≠ 0 :=\n  mk_eq_zero.not.2 <| hf.not_dvd_of_natDegree_lt h0 hd\n\n"}
{"name":"AdjoinRoot.aeval_eq","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf p : Polynomial R\n⊢ Eq ((Polynomial.aeval (AdjoinRoot.root f)) p) ((AdjoinRoot.mk f) p)","decl":"@[simp]\ntheorem aeval_eq (p : R[X]) : aeval (root f) p = mk f p :=\n  Polynomial.induction_on p\n    (fun x => by\n      rw [aeval_C]\n      rfl)\n    (fun p q ihp ihq => by rw [map_add, RingHom.map_add, ihp, ihq]) fun n x _ => by\n    rw [_root_.map_mul, aeval_C, map_pow, aeval_X, RingHom.map_mul, mk_C, RingHom.map_pow, mk_X]\n    rfl\n\n"}
{"name":"AdjoinRoot.adjoinRoot_eq_top","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf : Polynomial R\n⊢ Eq (Algebra.adjoin R (Singleton.singleton (AdjoinRoot.root f))) Top.top","decl":"theorem adjoinRoot_eq_top : Algebra.adjoin R ({root f} : Set (AdjoinRoot f)) = ⊤ := by\n  refine Algebra.eq_top_iff.2 fun x => ?_\n  induction x using AdjoinRoot.induction_on with\n    | ih p => exact (Algebra.adjoin_singleton_eq_range_aeval R (root f)).symm ▸ ⟨p, aeval_eq p⟩\n\n"}
{"name":"AdjoinRoot.eval₂_root","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf : Polynomial R\n⊢ Eq (Polynomial.eval₂ (AdjoinRoot.of f) (AdjoinRoot.root f) f) 0","decl":"@[simp]\ntheorem eval₂_root (f : R[X]) : f.eval₂ (of f) (root f) = 0 := by\n  rw [← algebraMap_eq, ← aeval_def, aeval_eq, mk_self]\n\n"}
{"name":"AdjoinRoot.isRoot_root","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf : Polynomial R\n⊢ (Polynomial.map (AdjoinRoot.of f) f).IsRoot (AdjoinRoot.root f)","decl":"theorem isRoot_root (f : R[X]) : IsRoot (f.map (of f)) (root f) := by\n  rw [IsRoot, eval_map, eval₂_root]\n\n"}
{"name":"AdjoinRoot.isAlgebraic_root","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf : Polynomial R\nhf : Ne f 0\n⊢ IsAlgebraic R (AdjoinRoot.root f)","decl":"theorem isAlgebraic_root (hf : f ≠ 0) : IsAlgebraic R (root f) :=\n  ⟨f, hf, eval₂_root f⟩\n\n"}
{"name":"AdjoinRoot.of.injective_of_degree_ne_zero","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nf : Polynomial R\ninst✝ : IsDomain R\nhf : Ne f.degree 0\n⊢ Function.Injective ⇑(AdjoinRoot.of f)","decl":"theorem of.injective_of_degree_ne_zero [IsDomain R] (hf : f.degree ≠ 0) :\n    Function.Injective (AdjoinRoot.of f) := by\n  rw [injective_iff_map_eq_zero]\n  intro p hp\n  rw [AdjoinRoot.of, RingHom.comp_apply, AdjoinRoot.mk_eq_zero] at hp\n  by_cases h : f = 0\n  · exact C_eq_zero.mp (eq_zero_of_zero_dvd (by rwa [h] at hp))\n  · contrapose! hf with h_contra\n    rw [← degree_C h_contra]\n    apply le_antisymm (degree_le_of_dvd hp (by rwa [Ne, C_eq_zero])) _\n    rwa [degree_C h_contra, zero_le_degree_iff]\n\n"}
{"name":"AdjoinRoot.lift_mk","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\nf : Polynomial R\ninst✝ : CommRing S\ni : RingHom R S\na : S\nh : Eq (Polynomial.eval₂ i a f) 0\ng : Polynomial R\n⊢ Eq ((AdjoinRoot.lift i a h) ((AdjoinRoot.mk f) g)) (Polynomial.eval₂ i a g)","decl":"@[simp]\ntheorem lift_mk (g : R[X]) : lift i a h (mk f g) = g.eval₂ i a :=\n  Ideal.Quotient.lift_mk _ _ _\n\n"}
{"name":"AdjoinRoot.lift_root","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\nf : Polynomial R\ninst✝ : CommRing S\ni : RingHom R S\na : S\nh : Eq (Polynomial.eval₂ i a f) 0\n⊢ Eq ((AdjoinRoot.lift i a h) (AdjoinRoot.root f)) a","decl":"@[simp]\ntheorem lift_root : lift i a h (root f) = a := by rw [root, lift_mk, eval₂_X]\n\n"}
{"name":"AdjoinRoot.lift_of","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\nf : Polynomial R\ninst✝ : CommRing S\ni : RingHom R S\na : S\nh : Eq (Polynomial.eval₂ i a f) 0\nx : R\n⊢ Eq ((AdjoinRoot.lift i a h) ((AdjoinRoot.of f) x)) (i x)","decl":"@[simp]\ntheorem lift_of {x : R} : lift i a h x = i x := by rw [← mk_C x, lift_mk, eval₂_C]\n\n"}
{"name":"AdjoinRoot.lift_comp_of","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\nf : Polynomial R\ninst✝ : CommRing S\ni : RingHom R S\na : S\nh : Eq (Polynomial.eval₂ i a f) 0\n⊢ Eq ((AdjoinRoot.lift i a h).comp (AdjoinRoot.of f)) i","decl":"@[simp]\ntheorem lift_comp_of : (lift i a h).comp (of f) = i :=\n  RingHom.ext fun _ => @lift_of _ _ _ _ _ _ _ h _\n\n"}
{"name":"AdjoinRoot.coe_liftHom","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\nf : Polynomial R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\nhfx : Eq ((Polynomial.aeval x) f) 0\n⊢ Eq (↑(AdjoinRoot.liftHom f x hfx)) (AdjoinRoot.lift (algebraMap R S) x hfx)","decl":"@[simp]\ntheorem coe_liftHom (x : S) (hfx : aeval x f = 0) :\n    (liftHom f x hfx : AdjoinRoot f →+* S) = lift (algebraMap R S) x hfx :=\n  rfl\n\n"}
{"name":"AdjoinRoot.aeval_algHom_eq_zero","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\nf : Polynomial R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nϕ : AlgHom R (AdjoinRoot f) S\n⊢ Eq ((Polynomial.aeval (ϕ (AdjoinRoot.root f))) f) 0","decl":"@[simp]\ntheorem aeval_algHom_eq_zero (ϕ : AdjoinRoot f →ₐ[R] S) : aeval (ϕ (root f)) f = 0 := by\n  have h : ϕ.toRingHom.comp (of f) = algebraMap R S := RingHom.ext_iff.mpr ϕ.commutes\n  rw [aeval_def, ← h, ← RingHom.map_zero ϕ.toRingHom, ← eval₂_root f, hom_eval₂]\n  rfl\n\n"}
{"name":"AdjoinRoot.liftHom_eq_algHom","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nf : Polynomial R\nϕ : AlgHom R (AdjoinRoot f) S\n⊢ Eq (AdjoinRoot.liftHom f (ϕ (AdjoinRoot.root f)) ⋯) ϕ","decl":"@[simp]\ntheorem liftHom_eq_algHom (f : R[X]) (ϕ : AdjoinRoot f →ₐ[R] S) :\n    liftHom f (ϕ (root f)) (aeval_algHom_eq_zero f ϕ) = ϕ := by\n  suffices AlgHom.equalizer ϕ (liftHom f (ϕ (root f)) (aeval_algHom_eq_zero f ϕ)) = ⊤ by\n    exact (AlgHom.ext fun x => (SetLike.ext_iff.mp this x).mpr Algebra.mem_top).symm\n  rw [eq_top_iff, ← adjoinRoot_eq_top, Algebra.adjoin_le_iff, Set.singleton_subset_iff]\n  exact (@lift_root _ _ _ _ _ _ _ (aeval_algHom_eq_zero f ϕ)).symm\n\n"}
{"name":"AdjoinRoot.liftHom_mk","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\nf : Polynomial R\ninst✝¹ : CommRing S\na : S\ninst✝ : Algebra R S\nhfx : Eq ((Polynomial.aeval a) f) 0\ng : Polynomial R\n⊢ Eq ((AdjoinRoot.liftHom f a hfx) ((AdjoinRoot.mk f) g)) ((Polynomial.aeval a) g)","decl":"@[simp]\ntheorem liftHom_mk {g : R[X]} : liftHom f a hfx (mk f g) = aeval a g :=\n  lift_mk hfx g\n\n"}
{"name":"AdjoinRoot.liftHom_root","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\nf : Polynomial R\ninst✝¹ : CommRing S\na : S\ninst✝ : Algebra R S\nhfx : Eq ((Polynomial.aeval a) f) 0\n⊢ Eq ((AdjoinRoot.liftHom f a hfx) (AdjoinRoot.root f)) a","decl":"@[simp]\ntheorem liftHom_root : liftHom f a hfx (root f) = a :=\n  lift_root hfx\n\n"}
{"name":"AdjoinRoot.liftHom_of","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\nf : Polynomial R\ninst✝¹ : CommRing S\na : S\ninst✝ : Algebra R S\nhfx : Eq ((Polynomial.aeval a) f) 0\nx : R\n⊢ Eq ((AdjoinRoot.liftHom f a hfx) ((AdjoinRoot.of f) x)) ((algebraMap R S) x)","decl":"@[simp]\ntheorem liftHom_of {x : R} : liftHom f a hfx (of f x) = algebraMap _ _ x :=\n  lift_of hfx\n\n"}
{"name":"AdjoinRoot.root_isInv","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nr : R\n⊢ Eq (HMul.hMul ((AdjoinRoot.of (HSub.hSub (HMul.hMul (Polynomial.C r) Polynomial.X) 1)) r) (AdjoinRoot.root (HSub.hSub (HMul.hMul (Polynomial.C r) Polynomial.X) 1))) 1","decl":"@[simp]\ntheorem root_isInv (r : R) : of _ r * root (C r * X - 1) = 1 := by\n  convert sub_eq_zero.1 ((eval₂_sub _).symm.trans <| eval₂_root <| C r * X - 1) <;>\n    simp only [eval₂_mul, eval₂_C, eval₂_X, eval₂_one]\n\n"}
{"name":"AdjoinRoot.algHom_subsingleton","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝² : CommRing R\nS : Type u_1\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nr : R\n⊢ Subsingleton (AlgHom R (AdjoinRoot (HSub.hSub (HMul.hMul (Polynomial.C r) Polynomial.X) 1)) S)","decl":"theorem algHom_subsingleton {S : Type*} [CommRing S] [Algebra R S] {r : R} :\n    Subsingleton (AdjoinRoot (C r * X - 1) →ₐ[R] S) :=\n  ⟨fun f g =>\n    algHom_ext\n      (@inv_unique _ _ (algebraMap R S r) _ _\n        (by rw [← f.commutes, ← _root_.map_mul, algebraMap_eq, root_isInv, map_one])\n        (by rw [← g.commutes, ← _root_.map_mul, algebraMap_eq, root_isInv, map_one]))⟩\n\n"}
{"name":"AdjoinRoot.isDomain_of_prime","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf : Polynomial R\nhf : Prime f\n⊢ IsDomain (AdjoinRoot f)","decl":"theorem isDomain_of_prime (hf : Prime f) : IsDomain (AdjoinRoot f) :=\n  (Ideal.Quotient.isDomain_iff_prime (span {f} : Ideal R[X])).mpr <|\n    (Ideal.span_singleton_prime hf.ne_zero).mpr hf\n\n"}
{"name":"AdjoinRoot.noZeroSMulDivisors_of_prime_of_degree_ne_zero","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nf : Polynomial R\ninst✝ : IsDomain R\nhf : Prime f\nhf' : Ne f.degree 0\n⊢ NoZeroSMulDivisors R (AdjoinRoot f)","decl":"theorem noZeroSMulDivisors_of_prime_of_degree_ne_zero [IsDomain R] (hf : Prime f)\n    (hf' : f.degree ≠ 0) : NoZeroSMulDivisors R (AdjoinRoot f) :=\n  haveI := isDomain_of_prime hf\n  NoZeroSMulDivisors.iff_algebraMap_injective.mpr (of.injective_of_degree_ne_zero hf')\n\n"}
{"name":"AdjoinRoot.span_maximal_of_irreducible","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"K : Type w\ninst✝¹ : Field K\nf : Polynomial K\ninst✝ : Fact (Irreducible f)\n⊢ (Ideal.span (Singleton.singleton f)).IsMaximal","decl":"instance span_maximal_of_irreducible [Fact (Irreducible f)] : (span {f}).IsMaximal :=\n  PrincipalIdealRing.isMaximal_of_irreducible <| Fact.out\n\n"}
{"name":"AdjoinRoot.coe_injective","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"K : Type w\ninst✝ : Field K\nf : Polynomial K\nh : Ne f.degree 0\n⊢ Function.Injective ⇑(AdjoinRoot.of f)","decl":"theorem coe_injective (h : degree f ≠ 0) : Function.Injective ((↑) : K → AdjoinRoot f) :=\n  have := AdjoinRoot.nontrivial f h\n  (of f).injective\n\n"}
{"name":"AdjoinRoot.coe_injective'","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"K : Type w\ninst✝¹ : Field K\nf : Polynomial K\ninst✝ : Fact (Irreducible f)\n⊢ Function.Injective ⇑(AdjoinRoot.of f)","decl":"theorem coe_injective' [Fact (Irreducible f)] : Function.Injective ((↑) : K → AdjoinRoot f) :=\n  (of f).injective\n\n"}
{"name":"AdjoinRoot.mul_div_root_cancel","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"K : Type w\ninst✝¹ : Field K\nf : Polynomial K\ninst✝ : Fact (Irreducible f)\n⊢ Eq (HMul.hMul (HSub.hSub Polynomial.X (Polynomial.C (AdjoinRoot.root f))) (HDiv.hDiv (Polynomial.map (AdjoinRoot.of f) f) (HSub.hSub Polynomial.X (Polynomial.C (AdjoinRoot.root f))))) (Polynomial.map (AdjoinRoot.of f) f)","decl":"theorem mul_div_root_cancel [Fact (Irreducible f)] :\n    (X - C (root f)) * ((f.map (of f)) / (X - C (root f))) = f.map (of f) :=\n  mul_div_eq_iff_isRoot.2 <| isRoot_root _\n\n"}
{"name":"AdjoinRoot.instIsNoetherianRing","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsNoetherianRing R\nf : Polynomial R\n⊢ IsNoetherianRing (AdjoinRoot f)","decl":"instance [CommRing R] [IsNoetherianRing R] {f : R[X]} : IsNoetherianRing (AdjoinRoot f) :=\n  Ideal.Quotient.isNoetherianRing _\n\n"}
{"name":"AdjoinRoot.isIntegral_root'","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\ng : Polynomial R\nhg : g.Monic\n⊢ IsIntegral R (AdjoinRoot.root g)","decl":"theorem isIntegral_root' (hg : g.Monic) : IsIntegral R (root g) :=\n  ⟨g, hg, eval₂_root g⟩\n\n"}
{"name":"AdjoinRoot.modByMonicHom_mk","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\ng : Polynomial R\nhg : g.Monic\nf : Polynomial R\n⊢ Eq ((AdjoinRoot.modByMonicHom hg) ((AdjoinRoot.mk g) f)) (f.modByMonic g)","decl":"@[simp]\ntheorem modByMonicHom_mk (hg : g.Monic) (f : R[X]) : modByMonicHom hg (mk g f) = f %ₘ g :=\n  rfl\n\n"}
{"name":"AdjoinRoot.mk_leftInverse","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\ng : Polynomial R\nhg : g.Monic\n⊢ Function.LeftInverse ⇑(AdjoinRoot.mk g) ⇑(AdjoinRoot.modByMonicHom hg)","decl":"theorem mk_leftInverse (hg : g.Monic) : Function.LeftInverse (mk g) (modByMonicHom hg) := by\n  intro f\n  induction f using AdjoinRoot.induction_on\n  rw [modByMonicHom_mk hg, mk_eq_mk, modByMonic_eq_sub_mul_div _ hg, sub_sub_cancel_left,\n    dvd_neg]\n  apply dvd_mul_right\n\n"}
{"name":"AdjoinRoot.mk_surjective","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\ng : Polynomial R\n⊢ Function.Surjective ⇑(AdjoinRoot.mk g)","decl":"theorem mk_surjective : Function.Surjective (mk g) :=\n  Ideal.Quotient.mk_surjective\n\n"}
{"name":"AdjoinRoot.powerBasisAux'_repr_symm_apply","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\ng : Polynomial R\nhg : g.Monic\nc : Finsupp (Fin g.natDegree) R\n⊢ Eq ((AdjoinRoot.powerBasisAux' hg).repr.symm c) ((AdjoinRoot.mk g) (Finset.univ.sum fun i => (Polynomial.monomial ↑i) (c i)))","decl":"theorem powerBasisAux'_repr_symm_apply (hg : g.Monic) (c : Fin g.natDegree →₀ R) :\n    (powerBasisAux' hg).repr.symm c = mk g (∑ i : Fin _, monomial i (c i)) :=\n  rfl\n\n-- This lemma could be autogenerated by `@[simps]` but unfortunately that would require\n-- unfolding that causes a timeout.\n"}
{"name":"AdjoinRoot.powerBasisAux'_repr_apply_to_fun","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\ng : Polynomial R\nhg : g.Monic\nf : AdjoinRoot g\ni : Fin g.natDegree\n⊢ Eq (((AdjoinRoot.powerBasisAux' hg).repr f) i) (((AdjoinRoot.modByMonicHom hg) f).coeff ↑i)","decl":"@[simp]\ntheorem powerBasisAux'_repr_apply_to_fun (hg : g.Monic) (f : AdjoinRoot g) (i : Fin g.natDegree) :\n    (powerBasisAux' hg).repr f i = (modByMonicHom hg f).coeff ↑i :=\n  rfl\n\n"}
{"name":"AdjoinRoot.powerBasis'_dim","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\ng : Polynomial R\nhg : g.Monic\n⊢ Eq (AdjoinRoot.powerBasis' hg).dim g.natDegree","decl":"/-- The power basis `1, root g, ..., root g ^ (d - 1)` for `AdjoinRoot g`,\nwhere `g` is a monic polynomial of degree `d`. -/\n@[simps]\ndef powerBasis' (hg : g.Monic) : PowerBasis R (AdjoinRoot g) where\n  gen := root g\n  dim := g.natDegree\n  basis := powerBasisAux' hg\n  basis_eq_pow i := by\n    simp only [powerBasisAux', Basis.coe_ofEquivFun, LinearEquiv.coe_symm_mk]\n    rw [Finset.sum_eq_single i]\n    · rw [Pi.single_eq_same, monomial_one_right_eq_X_pow, (mk g).map_pow, mk_X]\n    · intro j _ hj\n      rw [← monomial_zero_right _, Pi.single_eq_of_ne hj]\n    -- Fix `DecidableEq` mismatch\n    · intros\n      have := Finset.mem_univ i\n      contradiction\n\n"}
{"name":"AdjoinRoot.powerBasis'_gen","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\ng : Polynomial R\nhg : g.Monic\n⊢ Eq (AdjoinRoot.powerBasis' hg).gen (AdjoinRoot.root g)","decl":"/-- The power basis `1, root g, ..., root g ^ (d - 1)` for `AdjoinRoot g`,\nwhere `g` is a monic polynomial of degree `d`. -/\n@[simps]\ndef powerBasis' (hg : g.Monic) : PowerBasis R (AdjoinRoot g) where\n  gen := root g\n  dim := g.natDegree\n  basis := powerBasisAux' hg\n  basis_eq_pow i := by\n    simp only [powerBasisAux', Basis.coe_ofEquivFun, LinearEquiv.coe_symm_mk]\n    rw [Finset.sum_eq_single i]\n    · rw [Pi.single_eq_same, monomial_one_right_eq_X_pow, (mk g).map_pow, mk_X]\n    · intro j _ hj\n      rw [← monomial_zero_right _, Pi.single_eq_of_ne hj]\n    -- Fix `DecidableEq` mismatch\n    · intros\n      have := Finset.mem_univ i\n      contradiction\n\n"}
{"name":"AdjoinRoot.isIntegral_root","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"K : Type w\ninst✝ : Field K\nf : Polynomial K\nhf : Ne f 0\n⊢ IsIntegral K (AdjoinRoot.root f)","decl":"theorem isIntegral_root (hf : f ≠ 0) : IsIntegral K (root f) :=\n  (isAlgebraic_root hf).isIntegral\n\n"}
{"name":"AdjoinRoot.minpoly_root","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"K : Type w\ninst✝ : Field K\nf : Polynomial K\nhf : Ne f 0\n⊢ Eq (minpoly K (AdjoinRoot.root f)) (HMul.hMul f (Polynomial.C (Inv.inv f.leadingCoeff)))","decl":"theorem minpoly_root (hf : f ≠ 0) : minpoly K (root f) = f * C f.leadingCoeff⁻¹ := by\n  have f'_monic : Monic _ := monic_mul_leadingCoeff_inv hf\n  refine (minpoly.unique K _ f'_monic ?_ ?_).symm\n  · rw [_root_.map_mul, aeval_eq, mk_self, zero_mul]\n  intro q q_monic q_aeval\n  have commutes : (lift (algebraMap K (AdjoinRoot f)) (root f) q_aeval).comp (mk q) = mk f := by\n    ext\n    · simp only [RingHom.comp_apply, mk_C, lift_of]\n      rfl\n    · simp only [RingHom.comp_apply, mk_X, lift_root]\n  rw [degree_eq_natDegree f'_monic.ne_zero, degree_eq_natDegree q_monic.ne_zero,\n    Nat.cast_le, natDegree_mul hf, natDegree_C, add_zero]\n  · apply natDegree_le_of_dvd\n    · have : mk f q = 0 := by rw [← commutes, RingHom.comp_apply, mk_self, RingHom.map_zero]\n      exact mk_eq_zero.1 this\n    · exact q_monic.ne_zero\n  · rwa [Ne, C_eq_zero, inv_eq_zero, leadingCoeff_eq_zero]\n\n"}
{"name":"AdjoinRoot.powerBasis_dim","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"K : Type w\ninst✝ : Field K\nf : Polynomial K\nhf : Ne f 0\n⊢ Eq (AdjoinRoot.powerBasis hf).dim f.natDegree","decl":"/-- The power basis `1, root f, ..., root f ^ (d - 1)` for `AdjoinRoot f`,\nwhere `f` is an irreducible polynomial over a field of degree `d`. -/\n@[simps!]\ndef powerBasis (hf : f ≠ 0) : PowerBasis K (AdjoinRoot f) where\n  gen := root f\n  dim := f.natDegree\n  basis := powerBasisAux hf\n  basis_eq_pow := by simp [powerBasisAux]\n\n"}
{"name":"AdjoinRoot.powerBasis_gen","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"K : Type w\ninst✝ : Field K\nf : Polynomial K\nhf : Ne f 0\n⊢ Eq (AdjoinRoot.powerBasis hf).gen (AdjoinRoot.root f)","decl":"/-- The power basis `1, root f, ..., root f ^ (d - 1)` for `AdjoinRoot f`,\nwhere `f` is an irreducible polynomial over a field of degree `d`. -/\n@[simps!]\ndef powerBasis (hf : f ≠ 0) : PowerBasis K (AdjoinRoot f) where\n  gen := root f\n  dim := f.natDegree\n  basis := powerBasisAux hf\n  basis_eq_pow := by simp [powerBasisAux]\n\n"}
{"name":"AdjoinRoot.minpoly_powerBasis_gen","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"K : Type w\ninst✝ : Field K\nf : Polynomial K\nhf : Ne f 0\n⊢ Eq (minpoly K (AdjoinRoot.powerBasis hf).gen) (HMul.hMul f (Polynomial.C (Inv.inv f.leadingCoeff)))","decl":"theorem minpoly_powerBasis_gen (hf : f ≠ 0) :\n    minpoly K (powerBasis hf).gen = f * C f.leadingCoeff⁻¹ := by\n  rw [powerBasis_gen, minpoly_root hf]\n\n"}
{"name":"AdjoinRoot.minpoly_powerBasis_gen_of_monic","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"K : Type w\ninst✝ : Field K\nf : Polynomial K\nhf : f.Monic\nhf' : optParam (Ne f 0) ⋯\n⊢ Eq (minpoly K (AdjoinRoot.powerBasis hf').gen) f","decl":"theorem minpoly_powerBasis_gen_of_monic (hf : f.Monic) (hf' : f ≠ 0 := hf.ne_zero) :\n    minpoly K (powerBasis hf').gen = f := by\n  rw [minpoly_powerBasis_gen hf', hf.leadingCoeff, inv_one, C.map_one, mul_one]\n\n"}
{"name":"AdjoinRoot.Minpoly.toAdjoin_apply","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\na✝ : HasQuotient.Quotient (Polynomial R) (Submodule.toAddSubgroup (Ideal.span (Singleton.singleton (minpoly R x))))\n⊢ Eq ((AdjoinRoot.Minpoly.toAdjoin R x) a✝) ((QuotientAddGroup.lift (Submodule.toAddSubgroup (Ideal.span (Singleton.singleton (minpoly R x)))) ↑(Polynomial.eval₂RingHom (algebraMap R (Subtype fun x_1 => Membership.mem (Algebra.adjoin R (Singleton.singleton x)) x_1)) ⟨x, ⋯⟩) ⋯) a✝)","decl":"/-- The surjective algebra morphism `R[X]/(minpoly R x) → R[x]`.\nIf `R` is a integrally closed domain and `x` is integral, this is an isomorphism,\nsee `minpoly.equivAdjoin`. -/\n@[simps!]\ndef Minpoly.toAdjoin : AdjoinRoot (minpoly R x) →ₐ[R] adjoin R ({x} : Set S) :=\n  liftHom _ ⟨x, self_mem_adjoin_singleton R x⟩\n    (by simp [← Subalgebra.coe_eq_zero, aeval_subalgebra_coe])\n\n"}
{"name":"AdjoinRoot.Minpoly.toAdjoin_apply'","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\na : AdjoinRoot (minpoly R x)\n⊢ Eq ((AdjoinRoot.Minpoly.toAdjoin R x) a) ((AdjoinRoot.liftHom (minpoly R x) ⟨x, ⋯⟩ ⋯) a)","decl":"theorem Minpoly.toAdjoin_apply' (a : AdjoinRoot (minpoly R x)) :\n    Minpoly.toAdjoin R x a =\n      liftHom (minpoly R x) (⟨x, self_mem_adjoin_singleton R x⟩ : adjoin R ({x} : Set S))\n        (by simp [← Subalgebra.coe_eq_zero, aeval_subalgebra_coe]) a :=\n  rfl\n\n"}
{"name":"AdjoinRoot.Minpoly.toAdjoin.apply_X","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\n⊢ Eq ((AdjoinRoot.Minpoly.toAdjoin R x) ((AdjoinRoot.mk (minpoly R x)) Polynomial.X)) ⟨x, ⋯⟩","decl":"theorem Minpoly.toAdjoin.apply_X :\n    Minpoly.toAdjoin R x (mk (minpoly R x) X) = ⟨x, self_mem_adjoin_singleton R x⟩ := by\n  simp [toAdjoin]\n\n"}
{"name":"AdjoinRoot.Minpoly.toAdjoin.surjective","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\n⊢ Function.Surjective ⇑(AdjoinRoot.Minpoly.toAdjoin R x)","decl":"theorem Minpoly.toAdjoin.surjective : Function.Surjective (Minpoly.toAdjoin R x) := by\n  rw [← AlgHom.range_eq_top, _root_.eq_top_iff, ← adjoin_adjoin_coe_preimage]\n  exact adjoin_le fun ⟨y₁, y₂⟩ h ↦ ⟨mk (minpoly R x) X, by simpa [toAdjoin] using h.symm⟩\n\n"}
{"name":"AdjoinRoot.equiv'_apply","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\ng : Polynomial R\npb : PowerBasis R S\nh₁ : Eq ((Polynomial.aeval (AdjoinRoot.root g)) (minpoly R pb.gen)) 0\nh₂ : Eq ((Polynomial.aeval pb.gen) g) 0\n⊢ Eq ⇑(AdjoinRoot.equiv' g pb h₁ h₂) ⇑(AdjoinRoot.liftHom g pb.gen h₂)","decl":"/-- If `S` is an extension of `R` with power basis `pb` and `g` is a monic polynomial over `R`\nsuch that `pb.gen` has a minimal polynomial `g`, then `S` is isomorphic to `AdjoinRoot g`.\n\nCompare `PowerBasis.equivOfRoot`, which would require\n`h₂ : aeval pb.gen (minpoly R (root g)) = 0`; that minimal polynomial is not\nguaranteed to be identical to `g`. -/\n@[simps (config := .asFn)]\ndef equiv' (h₁ : aeval (root g) (minpoly R pb.gen) = 0) (h₂ : aeval pb.gen g = 0) :\n    AdjoinRoot g ≃ₐ[R] S :=\n  { AdjoinRoot.liftHom g pb.gen h₂ with\n    toFun := AdjoinRoot.liftHom g pb.gen h₂\n    invFun := pb.lift (root g) h₁\n    -- Porting note: another term-mode proof converted to tactic-mode.\n    left_inv := fun x => by\n      induction x using AdjoinRoot.induction_on\n      rw [liftHom_mk, pb.lift_aeval, aeval_eq]\n    right_inv := fun x => by\n      nontriviality S\n      obtain ⟨f, _hf, rfl⟩ := pb.exists_eq_aeval x\n      rw [pb.lift_aeval, aeval_eq, liftHom_mk] }\n\n-- This lemma should have the simp tag but this causes a lint issue.\n"}
{"name":"AdjoinRoot.equiv'_symm_apply","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\ng : Polynomial R\npb : PowerBasis R S\nh₁ : Eq ((Polynomial.aeval (AdjoinRoot.root g)) (minpoly R pb.gen)) 0\nh₂ : Eq ((Polynomial.aeval pb.gen) g) 0\n⊢ Eq ⇑(AdjoinRoot.equiv' g pb h₁ h₂).symm ⇑(pb.lift (AdjoinRoot.root g) h₁)","decl":"/-- If `S` is an extension of `R` with power basis `pb` and `g` is a monic polynomial over `R`\nsuch that `pb.gen` has a minimal polynomial `g`, then `S` is isomorphic to `AdjoinRoot g`.\n\nCompare `PowerBasis.equivOfRoot`, which would require\n`h₂ : aeval pb.gen (minpoly R (root g)) = 0`; that minimal polynomial is not\nguaranteed to be identical to `g`. -/\n@[simps (config := .asFn)]\ndef equiv' (h₁ : aeval (root g) (minpoly R pb.gen) = 0) (h₂ : aeval pb.gen g = 0) :\n    AdjoinRoot g ≃ₐ[R] S :=\n  { AdjoinRoot.liftHom g pb.gen h₂ with\n    toFun := AdjoinRoot.liftHom g pb.gen h₂\n    invFun := pb.lift (root g) h₁\n    -- Porting note: another term-mode proof converted to tactic-mode.\n    left_inv := fun x => by\n      induction x using AdjoinRoot.induction_on\n      rw [liftHom_mk, pb.lift_aeval, aeval_eq]\n    right_inv := fun x => by\n      nontriviality S\n      obtain ⟨f, _hf, rfl⟩ := pb.exists_eq_aeval x\n      rw [pb.lift_aeval, aeval_eq, liftHom_mk] }\n\n-- This lemma should have the simp tag but this causes a lint issue.\n"}
{"name":"AdjoinRoot.equiv'_toAlgHom","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\ng : Polynomial R\npb : PowerBasis R S\nh₁ : Eq ((Polynomial.aeval (AdjoinRoot.root g)) (minpoly R pb.gen)) 0\nh₂ : Eq ((Polynomial.aeval pb.gen) g) 0\n⊢ Eq (↑(AdjoinRoot.equiv' g pb h₁ h₂)) (AdjoinRoot.liftHom g pb.gen h₂)","decl":"theorem equiv'_toAlgHom (h₁ : aeval (root g) (minpoly R pb.gen) = 0) (h₂ : aeval pb.gen g = 0) :\n    (equiv' g pb h₁ h₂).toAlgHom = AdjoinRoot.liftHom g pb.gen h₂ :=\n  rfl\n\n-- This lemma should have the simp tag but this causes a lint issue.\n"}
{"name":"AdjoinRoot.equiv'_symm_toAlgHom","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\ng : Polynomial R\npb : PowerBasis R S\nh₁ : Eq ((Polynomial.aeval (AdjoinRoot.root g)) (minpoly R pb.gen)) 0\nh₂ : Eq ((Polynomial.aeval pb.gen) g) 0\n⊢ Eq (↑(AdjoinRoot.equiv' g pb h₁ h₂).symm) (pb.lift (AdjoinRoot.root g) h₁)","decl":"theorem equiv'_symm_toAlgHom (h₁ : aeval (root g) (minpoly R pb.gen) = 0)\n    (h₂ : aeval pb.gen g = 0) : (equiv' g pb h₁ h₂).symm.toAlgHom = pb.lift (root g) h₁ :=\n  rfl\n\n"}
{"name":"AdjoinRoot.quotMapOfEquivQuotMapCMapSpanMk_mk","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nf : Polynomial R\nx : AdjoinRoot f\n⊢ Eq ((AdjoinRoot.quotMapOfEquivQuotMapCMapSpanMk I f) ((Ideal.Quotient.mk (Ideal.map (AdjoinRoot.of f) I)) x)) ((Ideal.Quotient.mk (Ideal.map (Ideal.Quotient.mk (Ideal.span (Singleton.singleton f))) (Ideal.map Polynomial.C I))) x)","decl":"@[simp]\ntheorem quotMapOfEquivQuotMapCMapSpanMk_mk (x : AdjoinRoot f) :\n    quotMapOfEquivQuotMapCMapSpanMk I f (Ideal.Quotient.mk (I.map (of f)) x) =\n      Ideal.Quotient.mk (Ideal.map (Ideal.Quotient.mk (span {f})) (I.map (C : R →+* R[X]))) x := rfl\n\n--this lemma should have the simp tag but this causes a lint issue\n"}
{"name":"AdjoinRoot.quotMapOfEquivQuotMapCMapSpanMk_symm_mk","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nf : Polynomial R\nx : AdjoinRoot f\n⊢ Eq ((AdjoinRoot.quotMapOfEquivQuotMapCMapSpanMk I f).symm ((Ideal.Quotient.mk (Ideal.map (Ideal.Quotient.mk (Ideal.span (Singleton.singleton f))) (Ideal.map Polynomial.C I))) x)) ((Ideal.Quotient.mk (Ideal.map (AdjoinRoot.of f) I)) x)","decl":"theorem quotMapOfEquivQuotMapCMapSpanMk_symm_mk (x : AdjoinRoot f) :\n    (quotMapOfEquivQuotMapCMapSpanMk I f).symm\n        (Ideal.Quotient.mk ((I.map (C : R →+* R[X])).map (Ideal.Quotient.mk (span {f}))) x) =\n      Ideal.Quotient.mk (I.map (of f)) x := by\n  rw [quotMapOfEquivQuotMapCMapSpanMk, Ideal.quotEquivOfEq_symm]\n  exact Ideal.quotEquivOfEq_mk _ _\n\n"}
{"name":"AdjoinRoot.quotMapCMapSpanMkEquivQuotMapCQuotMapSpanMk_mk","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nf p : Polynomial R\n⊢ Eq ((AdjoinRoot.quotMapCMapSpanMkEquivQuotMapCQuotMapSpanMk I f) ((Ideal.Quotient.mk (Ideal.map (Ideal.Quotient.mk (Ideal.span (Singleton.singleton f))) (Ideal.map Polynomial.C I))) ((AdjoinRoot.mk f) p))) ((DoubleQuot.quotQuotMk (Ideal.map Polynomial.C I) (Ideal.span (Singleton.singleton f))) p)","decl":"theorem quotMapCMapSpanMkEquivQuotMapCQuotMapSpanMk_mk (p : R[X]) :\n    quotMapCMapSpanMkEquivQuotMapCQuotMapSpanMk I f (Ideal.Quotient.mk _ (mk f p)) =\n      quotQuotMk (I.map C) (span {f}) p :=\n  rfl\n\n"}
{"name":"AdjoinRoot.quotMapCMapSpanMkEquivQuotMapCQuotMapSpanMk_symm_quotQuotMk","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nf p : Polynomial R\n⊢ Eq ((AdjoinRoot.quotMapCMapSpanMkEquivQuotMapCQuotMapSpanMk I f).symm ((DoubleQuot.quotQuotMk (Ideal.map Polynomial.C I) (Ideal.span (Singleton.singleton f))) p)) ((Ideal.Quotient.mk (Ideal.map (Ideal.Quotient.mk (Ideal.span (Singleton.singleton f))) (Ideal.map Polynomial.C I))) ((AdjoinRoot.mk f) p))","decl":"@[simp]\ntheorem quotMapCMapSpanMkEquivQuotMapCQuotMapSpanMk_symm_quotQuotMk (p : R[X]) :\n    (quotMapCMapSpanMkEquivQuotMapCQuotMapSpanMk I f).symm (quotQuotMk (I.map C) (span {f}) p) =\n      Ideal.Quotient.mk (Ideal.map (Ideal.Quotient.mk (span {f})) (I.map (C : R →+* R[X])))\n        (mk f p) :=\n  rfl\n\n"}
{"name":"AdjoinRoot.Polynomial.quotQuotEquivComm_mk","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nf p : Polynomial R\n⊢ Eq ((AdjoinRoot.Polynomial.quotQuotEquivComm I f) ((Ideal.Quotient.mk (Ideal.span (Singleton.singleton (Polynomial.map (Ideal.Quotient.mk I) f)))) (Polynomial.map (Ideal.Quotient.mk I) p))) ((Ideal.Quotient.mk (Ideal.span (Singleton.singleton ((Ideal.Quotient.mk (Ideal.map Polynomial.C I)) f)))) ((Ideal.Quotient.mk (Ideal.map Polynomial.C I)) p))","decl":"@[simp]\ntheorem Polynomial.quotQuotEquivComm_mk (p : R[X]) :\n    (Polynomial.quotQuotEquivComm I f) (Ideal.Quotient.mk _ (p.map (Ideal.Quotient.mk I))) =\n      Ideal.Quotient.mk (span ({(Ideal.Quotient.mk (I.map C)) f} : Set (R[X] ⧸ (I.map C))))\n      (Ideal.Quotient.mk (I.map C) p) := by\n  simp only [Polynomial.quotQuotEquivComm, quotientEquiv_mk,\n    polynomialQuotientEquivQuotientPolynomial_map_mk]\n\n"}
{"name":"AdjoinRoot.Polynomial.quotQuotEquivComm_symm_mk_mk","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nf p : Polynomial R\n⊢ Eq ((AdjoinRoot.Polynomial.quotQuotEquivComm I f).symm ((Ideal.Quotient.mk (Ideal.span (Singleton.singleton ((Ideal.Quotient.mk (Ideal.map Polynomial.C I)) f)))) ((Ideal.Quotient.mk (Ideal.map Polynomial.C I)) p))) ((Ideal.Quotient.mk (Ideal.span (Singleton.singleton (Polynomial.map (Ideal.Quotient.mk I) f)))) (Polynomial.map (Ideal.Quotient.mk I) p))","decl":"@[simp]\ntheorem Polynomial.quotQuotEquivComm_symm_mk_mk (p : R[X]) :\n    (Polynomial.quotQuotEquivComm I f).symm (Ideal.Quotient.mk (span\n    ({(Ideal.Quotient.mk (I.map C)) f} : Set (R[X] ⧸ (I.map C)))) (Ideal.Quotient.mk (I.map C) p)) =\n      Ideal.Quotient.mk (span {f.map (Ideal.Quotient.mk I)}) (p.map (Ideal.Quotient.mk I)) := by\n  simp only [Polynomial.quotQuotEquivComm, quotientEquiv_symm_mk,\n    polynomialQuotientEquivQuotientPolynomial_symm_mk]\n\n"}
{"name":"AdjoinRoot.quotAdjoinRootEquivQuotPolynomialQuot_mk_of","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nf p : Polynomial R\n⊢ Eq ((AdjoinRoot.quotAdjoinRootEquivQuotPolynomialQuot I f) ((Ideal.Quotient.mk (Ideal.map (AdjoinRoot.of f) I)) ((AdjoinRoot.mk f) p))) ((Ideal.Quotient.mk (Ideal.span (Singleton.singleton (Polynomial.map (Ideal.Quotient.mk I) f)))) (Polynomial.map (Ideal.Quotient.mk I) p))","decl":"@[simp]\ntheorem quotAdjoinRootEquivQuotPolynomialQuot_mk_of (p : R[X]) :\n    quotAdjoinRootEquivQuotPolynomialQuot I f (Ideal.Quotient.mk (I.map (of f)) (mk f p)) =\n      Ideal.Quotient.mk (span ({f.map (Ideal.Quotient.mk I)} : Set (R ⧸ I)[X]))\n      (p.map (Ideal.Quotient.mk I)) := rfl\n\n"}
{"name":"AdjoinRoot.quotAdjoinRootEquivQuotPolynomialQuot_symm_mk_mk","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nf p : Polynomial R\n⊢ Eq ((AdjoinRoot.quotAdjoinRootEquivQuotPolynomialQuot I f).symm ((Ideal.Quotient.mk (Ideal.span (Singleton.singleton (Polynomial.map (Ideal.Quotient.mk I) f)))) (Polynomial.map (Ideal.Quotient.mk I) p))) ((Ideal.Quotient.mk (Ideal.map (AdjoinRoot.of f) I)) ((AdjoinRoot.mk f) p))","decl":"@[simp]\ntheorem quotAdjoinRootEquivQuotPolynomialQuot_symm_mk_mk (p : R[X]) :\n    (quotAdjoinRootEquivQuotPolynomialQuot I f).symm\n        (Ideal.Quotient.mk (span ({f.map (Ideal.Quotient.mk I)} : Set (R ⧸ I)[X]))\n        (p.map (Ideal.Quotient.mk I))) =\n      Ideal.Quotient.mk (I.map (of f)) (mk f p) := by\n  rw [quotAdjoinRootEquivQuotPolynomialQuot, RingEquiv.symm_trans_apply,\n    RingEquiv.symm_trans_apply, RingEquiv.symm_trans_apply, RingEquiv.symm_symm,\n    Polynomial.quotQuotEquivComm_mk, Ideal.quotEquivOfEq_symm, Ideal.quotEquivOfEq_mk, ←\n    RingHom.comp_apply, ← DoubleQuot.quotQuotMk,\n    quotMapCMapSpanMkEquivQuotMapCQuotMapSpanMk_symm_quotQuotMk,\n    quotMapOfEquivQuotMapCMapSpanMk_symm_mk]\n\n"}
{"name":"AdjoinRoot.quotEquivQuotMap_apply","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf : Polynomial R\nI : Ideal R\na : HasQuotient.Quotient (AdjoinRoot f) (Ideal.map (AdjoinRoot.of f) I)\n⊢ Eq ((AdjoinRoot.quotEquivQuotMap f I) a) ((AdjoinRoot.quotAdjoinRootEquivQuotPolynomialQuot I f) a)","decl":"/-- Promote `AdjoinRoot.quotAdjoinRootEquivQuotPolynomialQuot` to an alg_equiv. -/\n@[simps!]\nnoncomputable def quotEquivQuotMap (f : R[X]) (I : Ideal R) :\n    (AdjoinRoot f ⧸ Ideal.map (of f) I) ≃ₐ[R]\n      (R ⧸ I)[X] ⧸ Ideal.span ({Polynomial.map (Ideal.Quotient.mk I) f} : Set (R ⧸ I)[X]) :=\n  AlgEquiv.ofRingEquiv\n    (show ∀ x, (quotAdjoinRootEquivQuotPolynomialQuot I f) (algebraMap R _ x) = algebraMap R _ x\n      from fun x => by\n      have :\n        algebraMap R (AdjoinRoot f ⧸ Ideal.map (of f) I) x =\n          Ideal.Quotient.mk (Ideal.map (AdjoinRoot.of f) I) ((mk f) (C x)) :=\n        rfl\n      rw [this, quotAdjoinRootEquivQuotPolynomialQuot_mk_of, map_C]\n      -- Porting note: the following `rfl` was not needed\n      rfl)\n\n"}
{"name":"AdjoinRoot.quotEquivQuotMap_symm_apply","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf : Polynomial R\nI : Ideal R\na : HasQuotient.Quotient (Polynomial (HasQuotient.Quotient R I)) (Ideal.span (Singleton.singleton (Polynomial.map (Ideal.Quotient.mk I) f)))\n⊢ Eq ((AdjoinRoot.quotEquivQuotMap f I).symm a) ((AdjoinRoot.quotAdjoinRootEquivQuotPolynomialQuot I f).symm a)","decl":"/-- Promote `AdjoinRoot.quotAdjoinRootEquivQuotPolynomialQuot` to an alg_equiv. -/\n@[simps!]\nnoncomputable def quotEquivQuotMap (f : R[X]) (I : Ideal R) :\n    (AdjoinRoot f ⧸ Ideal.map (of f) I) ≃ₐ[R]\n      (R ⧸ I)[X] ⧸ Ideal.span ({Polynomial.map (Ideal.Quotient.mk I) f} : Set (R ⧸ I)[X]) :=\n  AlgEquiv.ofRingEquiv\n    (show ∀ x, (quotAdjoinRootEquivQuotPolynomialQuot I f) (algebraMap R _ x) = algebraMap R _ x\n      from fun x => by\n      have :\n        algebraMap R (AdjoinRoot f ⧸ Ideal.map (of f) I) x =\n          Ideal.Quotient.mk (Ideal.map (AdjoinRoot.of f) I) ((mk f) (C x)) :=\n        rfl\n      rw [this, quotAdjoinRootEquivQuotPolynomialQuot_mk_of, map_C]\n      -- Porting note: the following `rfl` was not needed\n      rfl)\n\n"}
{"name":"AdjoinRoot.quotEquivQuotMap_apply_mk","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf g : Polynomial R\nI : Ideal R\n⊢ Eq ((AdjoinRoot.quotEquivQuotMap f I) ((Ideal.Quotient.mk (Ideal.map (AdjoinRoot.of f) I)) ((AdjoinRoot.mk f) g))) ((Ideal.Quotient.mk (Ideal.span (Singleton.singleton (Polynomial.map (Ideal.Quotient.mk I) f)))) (Polynomial.map (Ideal.Quotient.mk I) g))","decl":"@[simp]\ntheorem quotEquivQuotMap_apply_mk (f g : R[X]) (I : Ideal R) :\n    AdjoinRoot.quotEquivQuotMap f I (Ideal.Quotient.mk (Ideal.map (of f) I) (AdjoinRoot.mk f g)) =\n      Ideal.Quotient.mk (Ideal.span ({Polynomial.map (Ideal.Quotient.mk I) f} : Set (R ⧸ I)[X]))\n      (g.map (Ideal.Quotient.mk I)) := by\n  rw [AdjoinRoot.quotEquivQuotMap_apply, AdjoinRoot.quotAdjoinRootEquivQuotPolynomialQuot_mk_of]\n\n"}
{"name":"AdjoinRoot.quotEquivQuotMap_symm_apply_mk","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf g : Polynomial R\nI : Ideal R\n⊢ Eq ((AdjoinRoot.quotEquivQuotMap f I).symm ((Ideal.Quotient.mk (Ideal.span (Singleton.singleton (Polynomial.map (Ideal.Quotient.mk I) f)))) (Polynomial.map (Ideal.Quotient.mk I) g))) ((Ideal.Quotient.mk (Ideal.map (AdjoinRoot.of f) I)) ((AdjoinRoot.mk f) g))","decl":"theorem quotEquivQuotMap_symm_apply_mk (f g : R[X]) (I : Ideal R) :\n    (AdjoinRoot.quotEquivQuotMap f I).symm (Ideal.Quotient.mk _\n      (Polynomial.map (Ideal.Quotient.mk I) g)) =\n        Ideal.Quotient.mk (Ideal.map (of f) I) (AdjoinRoot.mk f g) := by\n  rw [AdjoinRoot.quotEquivQuotMap_symm_apply,\n    AdjoinRoot.quotAdjoinRootEquivQuotPolynomialQuot_symm_mk_mk]\n\n"}
{"name":"PowerBasis.quotientEquivQuotientMinpolyMap_apply","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\npb : PowerBasis R S\nI : Ideal R\na✝ : HasQuotient.Quotient S (Ideal.map (algebraMap R S) I)\n⊢ Eq ((pb.quotientEquivQuotientMinpolyMap I) a✝) ((AdjoinRoot.quotAdjoinRootEquivQuotPolynomialQuot I (minpoly R pb.gen)) ((Ideal.quotientMap (Ideal.map (AdjoinRoot.of (minpoly R pb.gen)) I) ↑(↑(AdjoinRoot.equiv' (minpoly R pb.gen) pb ⋯ ⋯)).symm ⋯) a✝))","decl":"/-- Let `α` have minimal polynomial `f` over `R` and `I` be an ideal of `R`,\nthen `R[α] / (I) = (R[x] / (f)) / pS = (R/p)[x] / (f mod p)`. -/\n@[simps!]\nnoncomputable def quotientEquivQuotientMinpolyMap (pb : PowerBasis R S) (I : Ideal R) :\n    (S ⧸ I.map (algebraMap R S)) ≃ₐ[R]\n      Polynomial (R ⧸ I) ⧸\n        Ideal.span ({(minpoly R pb.gen).map (Ideal.Quotient.mk I)} : Set (Polynomial (R ⧸ I))) :=\n  (ofRingEquiv\n        (show ∀ x,\n            (Ideal.quotientEquiv _ (Ideal.map (AdjoinRoot.of (minpoly R pb.gen)) I)\n                  (AdjoinRoot.equiv' (minpoly R pb.gen) pb\n                        (by rw [AdjoinRoot.aeval_eq, AdjoinRoot.mk_self])\n                        (minpoly.aeval _ _)).symm.toRingEquiv\n                  (by rw [Ideal.map_map, AlgEquiv.toRingEquiv_eq_coe,\n                      ← AlgEquiv.coe_ringHom_commutes, ← AdjoinRoot.algebraMap_eq,\n                      AlgHom.comp_algebraMap]))\n                (algebraMap R (S ⧸ I.map (algebraMap R S)) x) = algebraMap R _ x from fun x => by\n                  rw [← Ideal.Quotient.mk_algebraMap, Ideal.quotientEquiv_apply,\n                    RingHom.toFun_eq_coe, Ideal.quotientMap_mk, AlgEquiv.toRingEquiv_eq_coe,\n                    RingEquiv.coe_toRingHom, AlgEquiv.coe_ringEquiv, AlgEquiv.commutes,\n                    Quotient.mk_algebraMap])).trans (AdjoinRoot.quotEquivQuotMap _ _)\n\n-- This lemma should have the simp tag but this causes a lint issue.\n"}
{"name":"PowerBasis.quotientEquivQuotientMinpolyMap_symm_apply","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\npb : PowerBasis R S\nI : Ideal R\na✝ : HasQuotient.Quotient (Polynomial (HasQuotient.Quotient R I)) (Ideal.span (Singleton.singleton (Polynomial.map (Ideal.Quotient.mk I) (minpoly R pb.gen))))\n⊢ Eq ((pb.quotientEquivQuotientMinpolyMap I).symm a✝) ((↑↑(AlgEquiv.ofRingEquiv ⋯)).symm ((↑↑(AdjoinRoot.quotEquivQuotMap (minpoly R pb.gen) I)).symm a✝))","decl":"/-- Let `α` have minimal polynomial `f` over `R` and `I` be an ideal of `R`,\nthen `R[α] / (I) = (R[x] / (f)) / pS = (R/p)[x] / (f mod p)`. -/\n@[simps!]\nnoncomputable def quotientEquivQuotientMinpolyMap (pb : PowerBasis R S) (I : Ideal R) :\n    (S ⧸ I.map (algebraMap R S)) ≃ₐ[R]\n      Polynomial (R ⧸ I) ⧸\n        Ideal.span ({(minpoly R pb.gen).map (Ideal.Quotient.mk I)} : Set (Polynomial (R ⧸ I))) :=\n  (ofRingEquiv\n        (show ∀ x,\n            (Ideal.quotientEquiv _ (Ideal.map (AdjoinRoot.of (minpoly R pb.gen)) I)\n                  (AdjoinRoot.equiv' (minpoly R pb.gen) pb\n                        (by rw [AdjoinRoot.aeval_eq, AdjoinRoot.mk_self])\n                        (minpoly.aeval _ _)).symm.toRingEquiv\n                  (by rw [Ideal.map_map, AlgEquiv.toRingEquiv_eq_coe,\n                      ← AlgEquiv.coe_ringHom_commutes, ← AdjoinRoot.algebraMap_eq,\n                      AlgHom.comp_algebraMap]))\n                (algebraMap R (S ⧸ I.map (algebraMap R S)) x) = algebraMap R _ x from fun x => by\n                  rw [← Ideal.Quotient.mk_algebraMap, Ideal.quotientEquiv_apply,\n                    RingHom.toFun_eq_coe, Ideal.quotientMap_mk, AlgEquiv.toRingEquiv_eq_coe,\n                    RingEquiv.coe_toRingHom, AlgEquiv.coe_ringEquiv, AlgEquiv.commutes,\n                    Quotient.mk_algebraMap])).trans (AdjoinRoot.quotEquivQuotMap _ _)\n\n-- This lemma should have the simp tag but this causes a lint issue.\n"}
{"name":"PowerBasis.quotientEquivQuotientMinpolyMap_apply_mk","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\npb : PowerBasis R S\nI : Ideal R\ng : Polynomial R\n⊢ Eq ((pb.quotientEquivQuotientMinpolyMap I) ((Ideal.Quotient.mk (Ideal.map (algebraMap R S) I)) ((Polynomial.aeval pb.gen) g))) ((Ideal.Quotient.mk (Ideal.span (Singleton.singleton (Polynomial.map (Ideal.Quotient.mk I) (minpoly R pb.gen))))) (Polynomial.map (Ideal.Quotient.mk I) g))","decl":"theorem quotientEquivQuotientMinpolyMap_apply_mk (pb : PowerBasis R S) (I : Ideal R) (g : R[X]) :\n    pb.quotientEquivQuotientMinpolyMap I (Ideal.Quotient.mk (I.map (algebraMap R S))\n      (aeval pb.gen g)) = Ideal.Quotient.mk\n        (Ideal.span ({(minpoly R pb.gen).map (Ideal.Quotient.mk I)} : Set (Polynomial (R ⧸ I))))\n          (g.map (Ideal.Quotient.mk I)) := by\n  rw [PowerBasis.quotientEquivQuotientMinpolyMap, AlgEquiv.trans_apply, AlgEquiv.ofRingEquiv_apply,\n    quotientEquiv_mk, AlgEquiv.coe_ringEquiv', AdjoinRoot.equiv'_symm_apply, PowerBasis.lift_aeval,\n    AdjoinRoot.aeval_eq, AdjoinRoot.quotEquivQuotMap_apply_mk]\n\n-- This lemma should have the simp tag but this causes a lint issue.\n"}
{"name":"PowerBasis.quotientEquivQuotientMinpolyMap_symm_apply_mk","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\npb : PowerBasis R S\nI : Ideal R\ng : Polynomial R\n⊢ Eq ((pb.quotientEquivQuotientMinpolyMap I).symm ((Ideal.Quotient.mk (Ideal.span (Singleton.singleton (Polynomial.map (Ideal.Quotient.mk I) (minpoly R pb.gen))))) (Polynomial.map (Ideal.Quotient.mk I) g))) ((Ideal.Quotient.mk (Ideal.map (algebraMap R S) I)) ((Polynomial.aeval pb.gen) g))","decl":"theorem quotientEquivQuotientMinpolyMap_symm_apply_mk (pb : PowerBasis R S) (I : Ideal R)\n    (g : R[X]) :\n    (pb.quotientEquivQuotientMinpolyMap I).symm (Ideal.Quotient.mk (Ideal.span\n      ({(minpoly R pb.gen).map (Ideal.Quotient.mk I)} : Set (Polynomial (R ⧸ I))))\n        (g.map (Ideal.Quotient.mk I))) = Ideal.Quotient.mk (I.map (algebraMap R S))\n          (aeval pb.gen g) := by\n  simp only [quotientEquivQuotientMinpolyMap, toRingEquiv_eq_coe, symm_trans_apply,\n    quotEquivQuotMap_symm_apply_mk, ofRingEquiv_symm_apply, quotientEquiv_symm_mk,\n    toRingEquiv_symm, RingEquiv.symm_symm, AdjoinRoot.equiv'_apply, coe_ringEquiv, liftHom_mk,\n    symm_toRingEquiv]\n\n"}
{"name":"Irreducible.exists_dvd_monic_irreducible_of_isIntegral","module":"Mathlib.RingTheory.AdjoinRoot","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁴ : CommRing K\ninst✝³ : IsDomain K\ninst✝² : Field L\ninst✝¹ : Algebra K L\ninst✝ : Algebra.IsIntegral K L\nf : Polynomial L\nhf : Irreducible f\n⊢ Exists fun g => And g.Monic (And (Irreducible g) (Dvd.dvd f (Polynomial.map (algebraMap K L) g)))","decl":"/-- If `L / K` is an integral extension, `K` is a domain, `L` is a field, then any irreducible\npolynomial over `L` divides some monic irreducible polynomial over `K`. -/\ntheorem Irreducible.exists_dvd_monic_irreducible_of_isIntegral {K L : Type*}\n    [CommRing K] [IsDomain K] [Field L] [Algebra K L] [Algebra.IsIntegral K L] {f : L[X]}\n    (hf : Irreducible f) : ∃ g : K[X], g.Monic ∧ Irreducible g ∧ f ∣ g.map (algebraMap K L) := by\n  haveI := Fact.mk hf\n  have h := hf.ne_zero\n  have h2 := isIntegral_trans (R := K) _ (AdjoinRoot.isIntegral_root h)\n  have h3 := (AdjoinRoot.minpoly_root h) ▸ minpoly.dvd_map_of_isScalarTower K L (AdjoinRoot.root f)\n  exact ⟨_, minpoly.monic h2, minpoly.irreducible h2, dvd_of_mul_right_dvd h3⟩\n"}
