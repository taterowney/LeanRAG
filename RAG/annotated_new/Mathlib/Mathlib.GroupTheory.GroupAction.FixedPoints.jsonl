{"name":"AddAction.fixedBy_neg","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ng : G\n⊢ Eq (AddAction.fixedBy α (Neg.neg g)) (AddAction.fixedBy α g)","decl":"variable (α) in\n/-- In a multiplicative group action, the points fixed by `g` are also fixed by `g⁻¹` -/\n@[to_additive (attr := simp)\n  \"In an additive group action, the points fixed by `g` are also fixed by `g⁻¹`\"]\ntheorem fixedBy_inv (g : G) : fixedBy α g⁻¹ = fixedBy α g := by\n  ext\n  rw [mem_fixedBy, mem_fixedBy, inv_smul_eq_iff, eq_comm]\n\n"}
{"name":"MulAction.fixedBy_inv","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\ng : G\n⊢ Eq (MulAction.fixedBy α (Inv.inv g)) (MulAction.fixedBy α g)","decl":"variable (α) in\n/-- In a multiplicative group action, the points fixed by `g` are also fixed by `g⁻¹` -/\n@[to_additive (attr := simp)\n  \"In an additive group action, the points fixed by `g` are also fixed by `g⁻¹`\"]\ntheorem fixedBy_inv (g : G) : fixedBy α g⁻¹ = fixedBy α g := by\n  ext\n  rw [mem_fixedBy, mem_fixedBy, inv_smul_eq_iff, eq_comm]\n\n"}
{"name":"MulAction.smul_mem_fixedBy_iff_mem_fixedBy","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\na : α\ng : G\n⊢ Iff (Membership.mem (MulAction.fixedBy α g) (HSMul.hSMul g a)) (Membership.mem (MulAction.fixedBy α g) a)","decl":"@[to_additive]\ntheorem smul_mem_fixedBy_iff_mem_fixedBy {a : α} {g : G} :\n    g • a ∈ fixedBy α g ↔ a ∈ fixedBy α g := by\n  rw [mem_fixedBy, smul_left_cancel_iff]\n  rfl\n\n"}
{"name":"AddAction.vadd_mem_fixedBy_iff_mem_fixedBy","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\na : α\ng : G\n⊢ Iff (Membership.mem (AddAction.fixedBy α g) (HVAdd.hVAdd g a)) (Membership.mem (AddAction.fixedBy α g) a)","decl":"@[to_additive]\ntheorem smul_mem_fixedBy_iff_mem_fixedBy {a : α} {g : G} :\n    g • a ∈ fixedBy α g ↔ a ∈ fixedBy α g := by\n  rw [mem_fixedBy, smul_left_cancel_iff]\n  rfl\n\n"}
{"name":"MulAction.smul_inv_mem_fixedBy_iff_mem_fixedBy","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\na : α\ng : G\n⊢ Iff (Membership.mem (MulAction.fixedBy α g) (HSMul.hSMul (Inv.inv g) a)) (Membership.mem (MulAction.fixedBy α g) a)","decl":"@[to_additive]\ntheorem smul_inv_mem_fixedBy_iff_mem_fixedBy {a : α} {g : G} :\n    g⁻¹ • a ∈ fixedBy α g ↔ a ∈ fixedBy α g := by\n  rw [← fixedBy_inv, smul_mem_fixedBy_iff_mem_fixedBy, fixedBy_inv]\n\n"}
{"name":"AddAction.vadd_neg_mem_fixedBy_iff_mem_fixedBy","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\na : α\ng : G\n⊢ Iff (Membership.mem (AddAction.fixedBy α g) (HVAdd.hVAdd (Neg.neg g) a)) (Membership.mem (AddAction.fixedBy α g) a)","decl":"@[to_additive]\ntheorem smul_inv_mem_fixedBy_iff_mem_fixedBy {a : α} {g : G} :\n    g⁻¹ • a ∈ fixedBy α g ↔ a ∈ fixedBy α g := by\n  rw [← fixedBy_inv, smul_mem_fixedBy_iff_mem_fixedBy, fixedBy_inv]\n\n"}
{"name":"AddAction.minimalPeriod_eq_one_iff_fixedBy","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\na : α\ng : G\n⊢ Iff (Eq (Function.minimalPeriod (fun x => HVAdd.hVAdd g x) a) 1) (Membership.mem (AddAction.fixedBy α g) a)","decl":"@[to_additive minimalPeriod_eq_one_iff_fixedBy]\ntheorem minimalPeriod_eq_one_iff_fixedBy {a : α} {g : G} :\n    Function.minimalPeriod (fun x => g • x) a = 1 ↔ a ∈ fixedBy α g :=\n  Function.minimalPeriod_eq_one_iff_isFixedPt\n\n"}
{"name":"MulAction.minimalPeriod_eq_one_iff_fixedBy","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\na : α\ng : G\n⊢ Iff (Eq (Function.minimalPeriod (fun x => HSMul.hSMul g x) a) 1) (Membership.mem (MulAction.fixedBy α g) a)","decl":"@[to_additive minimalPeriod_eq_one_iff_fixedBy]\ntheorem minimalPeriod_eq_one_iff_fixedBy {a : α} {g : G} :\n    Function.minimalPeriod (fun x => g • x) a = 1 ↔ a ∈ fixedBy α g :=\n  Function.minimalPeriod_eq_one_iff_isFixedPt\n\n"}
{"name":"AddAction.fixedBy_subset_fixedBy_zsmul","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ng : G\nj : Int\n⊢ HasSubset.Subset (AddAction.fixedBy α g) (AddAction.fixedBy α (HSMul.hSMul j g))","decl":"variable (α) in\n@[to_additive]\ntheorem fixedBy_subset_fixedBy_zpow (g : G) (j : ℤ) :\n    fixedBy α g ⊆ fixedBy α (g ^ j) := by\n  intro a a_in_fixedBy\n  rw [mem_fixedBy, zpow_smul_eq_iff_minimalPeriod_dvd,\n    minimalPeriod_eq_one_iff_fixedBy.mpr a_in_fixedBy, Int.natCast_one]\n  exact one_dvd j\n\n"}
{"name":"MulAction.fixedBy_subset_fixedBy_zpow","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\ng : G\nj : Int\n⊢ HasSubset.Subset (MulAction.fixedBy α g) (MulAction.fixedBy α (HPow.hPow g j))","decl":"variable (α) in\n@[to_additive]\ntheorem fixedBy_subset_fixedBy_zpow (g : G) (j : ℤ) :\n    fixedBy α g ⊆ fixedBy α (g ^ j) := by\n  intro a a_in_fixedBy\n  rw [mem_fixedBy, zpow_smul_eq_iff_minimalPeriod_dvd,\n    minimalPeriod_eq_one_iff_fixedBy.mpr a_in_fixedBy, Int.natCast_one]\n  exact one_dvd j\n\n"}
{"name":"MulAction.fixedBy_one_eq_univ","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\n⊢ Eq (MulAction.fixedBy α 1) Set.univ","decl":"variable (M α) in\n@[to_additive (attr := simp)]\ntheorem fixedBy_one_eq_univ : fixedBy α (1 : M) = Set.univ :=\n  Set.eq_univ_iff_forall.mpr <| one_smul M\n\n"}
{"name":"AddAction.fixedBy_zero_eq_univ","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\n⊢ Eq (AddAction.fixedBy α 0) Set.univ","decl":"variable (M α) in\n@[to_additive (attr := simp)]\ntheorem fixedBy_one_eq_univ : fixedBy α (1 : M) = Set.univ :=\n  Set.eq_univ_iff_forall.mpr <| one_smul M\n\n"}
{"name":"MulAction.fixedBy_mul","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\nm₁ m₂ : M\n⊢ HasSubset.Subset (Inter.inter (MulAction.fixedBy α m₁) (MulAction.fixedBy α m₂)) (MulAction.fixedBy α (HMul.hMul m₁ m₂))","decl":"variable (α) in\n@[to_additive]\ntheorem fixedBy_mul (m₁ m₂ : M) : fixedBy α m₁ ∩ fixedBy α m₂ ⊆ fixedBy α (m₁ * m₂) := by\n  intro a ⟨h₁, h₂⟩\n  rw [mem_fixedBy, mul_smul, h₂, h₁]\n\n"}
{"name":"AddAction.fixedBy_add","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\nm₁ m₂ : M\n⊢ HasSubset.Subset (Inter.inter (AddAction.fixedBy α m₁) (AddAction.fixedBy α m₂)) (AddAction.fixedBy α (HAdd.hAdd m₁ m₂))","decl":"variable (α) in\n@[to_additive]\ntheorem fixedBy_mul (m₁ m₂ : M) : fixedBy α m₁ ∩ fixedBy α m₂ ⊆ fixedBy α (m₁ * m₂) := by\n  intro a ⟨h₁, h₂⟩\n  rw [mem_fixedBy, mul_smul, h₂, h₁]\n\n"}
{"name":"MulAction.smul_fixedBy","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\ng h : G\n⊢ Eq (HSMul.hSMul h (MulAction.fixedBy α g)) (MulAction.fixedBy α (HMul.hMul (HMul.hMul h g) (Inv.inv h)))","decl":"variable (α) in\n@[to_additive]\ntheorem smul_fixedBy (g h : G) :\n    h • fixedBy α g = fixedBy α (h * g * h⁻¹) := by\n  ext a\n  simp_rw [Set.mem_smul_set_iff_inv_smul_mem, mem_fixedBy, mul_smul, smul_eq_iff_eq_inv_smul h]\n\n"}
{"name":"AddAction.vadd_fixedBy","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ng h : G\n⊢ Eq (HVAdd.hVAdd h (AddAction.fixedBy α g)) (AddAction.fixedBy α (HAdd.hAdd (HAdd.hAdd h g) (Neg.neg h)))","decl":"variable (α) in\n@[to_additive]\ntheorem smul_fixedBy (g h : G) :\n    h • fixedBy α g = fixedBy α (h * g * h⁻¹) := by\n  ext a\n  simp_rw [Set.mem_smul_set_iff_inv_smul_mem, mem_fixedBy, mul_smul, smul_eq_iff_eq_inv_smul h]\n\n"}
{"name":"MulAction.set_mem_fixedBy_iff","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\ns : Set α\ng : G\n⊢ Iff (Membership.mem (MulAction.fixedBy (Set α) g) s) (∀ (x : α), Iff (Membership.mem s (HSMul.hSMul g x)) (Membership.mem s x))","decl":"/--\nIf a set `s : Set α` is in `fixedBy (Set α) g`, then all points of `s` will stay in `s` after being\nmoved by `g`.\n-/\n@[to_additive \"If a set `s : Set α` is in `fixedBy (Set α) g`, then all points of `s` will stay in\n`s` after being moved by `g`.\"]\ntheorem set_mem_fixedBy_iff (s : Set α) (g : G) :\n    s ∈ fixedBy (Set α) g ↔ ∀ x, g • x ∈ s ↔ x ∈ s := by\n  simp_rw [mem_fixedBy, ← eq_inv_smul_iff, Set.ext_iff, Set.mem_inv_smul_set_iff, Iff.comm]\n\n"}
{"name":"AddAction.set_mem_fixedBy_iff","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ns : Set α\ng : G\n⊢ Iff (Membership.mem (AddAction.fixedBy (Set α) g) s) (∀ (x : α), Iff (Membership.mem s (HVAdd.hVAdd g x)) (Membership.mem s x))","decl":"/--\nIf a set `s : Set α` is in `fixedBy (Set α) g`, then all points of `s` will stay in `s` after being\nmoved by `g`.\n-/\n@[to_additive \"If a set `s : Set α` is in `fixedBy (Set α) g`, then all points of `s` will stay in\n`s` after being moved by `g`.\"]\ntheorem set_mem_fixedBy_iff (s : Set α) (g : G) :\n    s ∈ fixedBy (Set α) g ↔ ∀ x, g • x ∈ s ↔ x ∈ s := by\n  simp_rw [mem_fixedBy, ← eq_inv_smul_iff, Set.ext_iff, Set.mem_inv_smul_set_iff, Iff.comm]\n\n"}
{"name":"MulAction.smul_mem_of_set_mem_fixedBy","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\ns : Set α\ng : G\ns_in_fixedBy : Membership.mem (MulAction.fixedBy (Set α) g) s\nx : α\n⊢ Iff (Membership.mem s (HSMul.hSMul g x)) (Membership.mem s x)","decl":"theorem smul_mem_of_set_mem_fixedBy {s : Set α} {g : G} (s_in_fixedBy : s ∈ fixedBy (Set α) g)\n    {x : α} : g • x ∈ s ↔ x ∈ s := (set_mem_fixedBy_iff s g).mp s_in_fixedBy x\n\n"}
{"name":"AddAction.set_mem_fixedBy_of_subset_fixedBy","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ns : Set α\ng : G\ns_ss_fixedBy : HasSubset.Subset s (AddAction.fixedBy α g)\n⊢ Membership.mem (AddAction.fixedBy (Set α) g) s","decl":"/--\nIf `s ⊆ fixedBy α g`, then `g • s = s`, which means that `s ∈ fixedBy (Set α) g`.\n\nNote that the reverse implication is in general not true, as `s ∈ fixedBy (Set α) g` is a\nweaker statement (it allows for points `x ∈ s` for which `g • x ≠ x` and `g • x ∈ s`).\n-/\n@[to_additive \"If `s ⊆ fixedBy α g`, then `g +ᵥ s = s`, which means that `s ∈ fixedBy (Set α) g`.\n\nNote that the reverse implication is in general not true, as `s ∈ fixedBy (Set α) g` is a\nweaker statement (it allows for points `x ∈ s` for which `g +ᵥ x ≠ x` and `g +ᵥ x ∈ s`).\"]\ntheorem set_mem_fixedBy_of_subset_fixedBy {s : Set α} {g : G} (s_ss_fixedBy : s ⊆ fixedBy α g) :\n    s ∈ fixedBy (Set α) g := by\n  rw [← fixedBy_inv]\n  ext x\n  rw [Set.mem_inv_smul_set_iff]\n  refine ⟨fun gxs => ?xs, fun xs => (s_ss_fixedBy xs).symm ▸ xs⟩\n  rw [← fixedBy_inv] at s_ss_fixedBy\n  rwa [← s_ss_fixedBy gxs, inv_smul_smul] at gxs\n\n"}
{"name":"MulAction.set_mem_fixedBy_of_subset_fixedBy","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\ns : Set α\ng : G\ns_ss_fixedBy : HasSubset.Subset s (MulAction.fixedBy α g)\n⊢ Membership.mem (MulAction.fixedBy (Set α) g) s","decl":"/--\nIf `s ⊆ fixedBy α g`, then `g • s = s`, which means that `s ∈ fixedBy (Set α) g`.\n\nNote that the reverse implication is in general not true, as `s ∈ fixedBy (Set α) g` is a\nweaker statement (it allows for points `x ∈ s` for which `g • x ≠ x` and `g • x ∈ s`).\n-/\n@[to_additive \"If `s ⊆ fixedBy α g`, then `g +ᵥ s = s`, which means that `s ∈ fixedBy (Set α) g`.\n\nNote that the reverse implication is in general not true, as `s ∈ fixedBy (Set α) g` is a\nweaker statement (it allows for points `x ∈ s` for which `g +ᵥ x ≠ x` and `g +ᵥ x ∈ s`).\"]\ntheorem set_mem_fixedBy_of_subset_fixedBy {s : Set α} {g : G} (s_ss_fixedBy : s ⊆ fixedBy α g) :\n    s ∈ fixedBy (Set α) g := by\n  rw [← fixedBy_inv]\n  ext x\n  rw [Set.mem_inv_smul_set_iff]\n  refine ⟨fun gxs => ?xs, fun xs => (s_ss_fixedBy xs).symm ▸ xs⟩\n  rw [← fixedBy_inv] at s_ss_fixedBy\n  rwa [← s_ss_fixedBy gxs, inv_smul_smul] at gxs\n\n"}
{"name":"MulAction.smul_subset_of_set_mem_fixedBy","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\ns t : Set α\ng : G\nt_ss_s : HasSubset.Subset t s\ns_in_fixedBy : Membership.mem (MulAction.fixedBy (Set α) g) s\n⊢ HasSubset.Subset (HSMul.hSMul g t) s","decl":"theorem smul_subset_of_set_mem_fixedBy {s t : Set α} {g : G} (t_ss_s : t ⊆ s)\n    (s_in_fixedBy : s ∈ fixedBy (Set α) g) : g • t ⊆ s :=\n  (Set.smul_set_subset_smul_set_iff.mpr t_ss_s).trans s_in_fixedBy.subset\n\n"}
{"name":"AddAction.set_mem_fixedBy_of_movedBy_subset","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ns : Set α\ng : G\ns_subset : HasSubset.Subset (HasCompl.compl (AddAction.fixedBy α g)) s\n⊢ Membership.mem (AddAction.fixedBy (Set α) g) s","decl":"/-- If `(fixedBy α g)ᶜ ⊆ s`, then `g` cannot move a point of `s` outside of `s`. -/\n@[to_additive \"If `(fixedBy α g)ᶜ ⊆ s`, then `g` cannot move a point of `s` outside of `s`.\"]\ntheorem set_mem_fixedBy_of_movedBy_subset {s : Set α} {g : G} (s_subset : (fixedBy α g)ᶜ ⊆ s) :\n    s ∈ fixedBy (Set α) g := by\n  rw [← fixedBy_inv]\n  ext a\n  rw [Set.mem_inv_smul_set_iff]\n  by_cases a ∈ fixedBy α g\n  case pos a_fixed =>\n    rw [a_fixed]\n  case neg a_moved =>\n    constructor <;> (intro; apply s_subset)\n    · exact a_moved\n    · rwa [Set.mem_compl_iff, smul_mem_fixedBy_iff_mem_fixedBy]\n\n"}
{"name":"MulAction.set_mem_fixedBy_of_movedBy_subset","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\ns : Set α\ng : G\ns_subset : HasSubset.Subset (HasCompl.compl (MulAction.fixedBy α g)) s\n⊢ Membership.mem (MulAction.fixedBy (Set α) g) s","decl":"/-- If `(fixedBy α g)ᶜ ⊆ s`, then `g` cannot move a point of `s` outside of `s`. -/\n@[to_additive \"If `(fixedBy α g)ᶜ ⊆ s`, then `g` cannot move a point of `s` outside of `s`.\"]\ntheorem set_mem_fixedBy_of_movedBy_subset {s : Set α} {g : G} (s_subset : (fixedBy α g)ᶜ ⊆ s) :\n    s ∈ fixedBy (Set α) g := by\n  rw [← fixedBy_inv]\n  ext a\n  rw [Set.mem_inv_smul_set_iff]\n  by_cases a ∈ fixedBy α g\n  case pos a_fixed =>\n    rw [a_fixed]\n  case neg a_moved =>\n    constructor <;> (intro; apply s_subset)\n    · exact a_moved\n    · rwa [Set.mem_compl_iff, smul_mem_fixedBy_iff_mem_fixedBy]\n\n"}
{"name":"AddAction.fixedBy_mem_fixedBy_of_addCommute","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ng h : G\ncomm : AddCommute g h\n⊢ Membership.mem (AddAction.fixedBy (Set α) h) (AddAction.fixedBy α g)","decl":"/--\nIf `g` and `h` commute, then `g` fixes `h • x` iff `g` fixes `x`.\nThis is equivalent to say that the set `fixedBy α g` is fixed by `h`.\n-/\n@[to_additive \"If `g` and `h` commute, then `g` fixes `h +ᵥ x` iff `g` fixes `x`.\nThis is equivalent to say that the set `fixedBy α g` is fixed by `h`.\n\"]\ntheorem fixedBy_mem_fixedBy_of_commute {g h : G} (comm : Commute g h) :\n    (fixedBy α g) ∈ fixedBy (Set α) h := by\n  ext x\n  rw [Set.mem_smul_set_iff_inv_smul_mem, mem_fixedBy, ← mul_smul, comm.inv_right, mul_smul,\n    smul_left_cancel_iff, mem_fixedBy]\n\n"}
{"name":"MulAction.fixedBy_mem_fixedBy_of_commute","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\ng h : G\ncomm : Commute g h\n⊢ Membership.mem (MulAction.fixedBy (Set α) h) (MulAction.fixedBy α g)","decl":"/--\nIf `g` and `h` commute, then `g` fixes `h • x` iff `g` fixes `x`.\nThis is equivalent to say that the set `fixedBy α g` is fixed by `h`.\n-/\n@[to_additive \"If `g` and `h` commute, then `g` fixes `h +ᵥ x` iff `g` fixes `x`.\nThis is equivalent to say that the set `fixedBy α g` is fixed by `h`.\n\"]\ntheorem fixedBy_mem_fixedBy_of_commute {g h : G} (comm : Commute g h) :\n    (fixedBy α g) ∈ fixedBy (Set α) h := by\n  ext x\n  rw [Set.mem_smul_set_iff_inv_smul_mem, mem_fixedBy, ← mul_smul, comm.inv_right, mul_smul,\n    smul_left_cancel_iff, mem_fixedBy]\n\n"}
{"name":"AddAction.vadd_zsmul_fixedBy_eq_of_addCommute","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ng h : G\ncomm : AddCommute g h\nj : Int\n⊢ Eq (HVAdd.hVAdd (HSMul.hSMul j h) (AddAction.fixedBy α g)) (AddAction.fixedBy α g)","decl":"/--\nIf `g` and `h` commute, then `g` fixes `(h ^ j) • x` iff `g` fixes `x`.\n-/\n@[to_additive \"If `g` and `h` commute, then `g` fixes `(j • h) +ᵥ x` iff `g` fixes `x`.\"]\ntheorem smul_zpow_fixedBy_eq_of_commute {g h : G} (comm : Commute g h) (j : ℤ) :\n    h ^ j • fixedBy α g = fixedBy α g :=\n  fixedBy_subset_fixedBy_zpow (Set α) h j (fixedBy_mem_fixedBy_of_commute comm)\n\n"}
{"name":"MulAction.smul_zpow_fixedBy_eq_of_commute","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\ng h : G\ncomm : Commute g h\nj : Int\n⊢ Eq (HSMul.hSMul (HPow.hPow h j) (MulAction.fixedBy α g)) (MulAction.fixedBy α g)","decl":"/--\nIf `g` and `h` commute, then `g` fixes `(h ^ j) • x` iff `g` fixes `x`.\n-/\n@[to_additive \"If `g` and `h` commute, then `g` fixes `(j • h) +ᵥ x` iff `g` fixes `x`.\"]\ntheorem smul_zpow_fixedBy_eq_of_commute {g h : G} (comm : Commute g h) (j : ℤ) :\n    h ^ j • fixedBy α g = fixedBy α g :=\n  fixedBy_subset_fixedBy_zpow (Set α) h j (fixedBy_mem_fixedBy_of_commute comm)\n\n"}
{"name":"MulAction.movedBy_mem_fixedBy_of_commute","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\ng h : G\ncomm : Commute g h\n⊢ Membership.mem (MulAction.fixedBy (Set α) h) (HasCompl.compl (MulAction.fixedBy α g))","decl":"/--\nIf `g` and `h` commute, then `g` moves `h • x` iff `g` moves `x`.\nThis is equivalent to say that the set `(fixedBy α g)ᶜ` is fixed by `h`.\n-/\n@[to_additive \"If `g` and `h` commute, then `g` moves `h +ᵥ x` iff `g` moves `x`.\nThis is equivalent to say that the set `(fixedBy α g)ᶜ` is fixed by `h`.\"]\ntheorem movedBy_mem_fixedBy_of_commute {g h : G} (comm : Commute g h) :\n    (fixedBy α g)ᶜ ∈ fixedBy (Set α) h := by\n  rw [mem_fixedBy, Set.smul_set_compl, fixedBy_mem_fixedBy_of_commute comm]\n\n"}
{"name":"AddAction.movedBy_mem_fixedBy_of_addCommute","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ng h : G\ncomm : AddCommute g h\n⊢ Membership.mem (AddAction.fixedBy (Set α) h) (HasCompl.compl (AddAction.fixedBy α g))","decl":"/--\nIf `g` and `h` commute, then `g` moves `h • x` iff `g` moves `x`.\nThis is equivalent to say that the set `(fixedBy α g)ᶜ` is fixed by `h`.\n-/\n@[to_additive \"If `g` and `h` commute, then `g` moves `h +ᵥ x` iff `g` moves `x`.\nThis is equivalent to say that the set `(fixedBy α g)ᶜ` is fixed by `h`.\"]\ntheorem movedBy_mem_fixedBy_of_commute {g h : G} (comm : Commute g h) :\n    (fixedBy α g)ᶜ ∈ fixedBy (Set α) h := by\n  rw [mem_fixedBy, Set.smul_set_compl, fixedBy_mem_fixedBy_of_commute comm]\n\n"}
{"name":"AddAction.vadd_zsmul_movedBy_eq_of_addCommute","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ng h : G\ncomm : AddCommute g h\nj : Int\n⊢ Eq (HVAdd.hVAdd (HSMul.hSMul j h) (HasCompl.compl (AddAction.fixedBy α g))) (HasCompl.compl (AddAction.fixedBy α g))","decl":"/--\nIf `g` and `h` commute, then `g` moves `h ^ j • x` iff `g` moves `x`.\n-/\n@[to_additive \"If `g` and `h` commute, then `g` moves `(j • h) +ᵥ x` iff `g` moves `x`.\"]\ntheorem smul_zpow_movedBy_eq_of_commute {g h : G} (comm : Commute g h) (j : ℤ) :\n    h ^ j • (fixedBy α g)ᶜ = (fixedBy α g)ᶜ :=\n  fixedBy_subset_fixedBy_zpow (Set α) h j (movedBy_mem_fixedBy_of_commute comm)\n\n"}
{"name":"MulAction.smul_zpow_movedBy_eq_of_commute","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\ng h : G\ncomm : Commute g h\nj : Int\n⊢ Eq (HSMul.hSMul (HPow.hPow h j) (HasCompl.compl (MulAction.fixedBy α g))) (HasCompl.compl (MulAction.fixedBy α g))","decl":"/--\nIf `g` and `h` commute, then `g` moves `h ^ j • x` iff `g` moves `x`.\n-/\n@[to_additive \"If `g` and `h` commute, then `g` moves `(j • h) +ᵥ x` iff `g` moves `x`.\"]\ntheorem smul_zpow_movedBy_eq_of_commute {g h : G} (comm : Commute g h) (j : ℤ) :\n    h ^ j • (fixedBy α g)ᶜ = (fixedBy α g)ᶜ :=\n  fixedBy_subset_fixedBy_zpow (Set α) h j (movedBy_mem_fixedBy_of_commute comm)\n\n"}
{"name":"AddAction.fixedBy_eq_univ_iff_eq_zero","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : AddAction M α\ninst✝ : FaithfulVAdd M α\nm : M\n⊢ Iff (Eq (AddAction.fixedBy α m) Set.univ) (Eq m 0)","decl":"/-- If the multiplicative action of `M` on `α` is faithful,\nthen `fixedBy α m = Set.univ` implies that `m = 1`. -/\n@[to_additive \"If the additive action of `M` on `α` is faithful,\nthen `fixedBy α m = Set.univ` implies that `m = 1`.\"]\ntheorem fixedBy_eq_univ_iff_eq_one {m : M} : fixedBy α m = Set.univ ↔ m = 1 := by\n  rw [← (smul_left_injective' (M := M) (α := α)).eq_iff, Set.eq_univ_iff_forall]\n  simp_rw [funext_iff, one_smul, mem_fixedBy]\n\n"}
{"name":"MulAction.fixedBy_eq_univ_iff_eq_one","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝² : Monoid M\ninst✝¹ : MulAction M α\ninst✝ : FaithfulSMul M α\nm : M\n⊢ Iff (Eq (MulAction.fixedBy α m) Set.univ) (Eq m 1)","decl":"/-- If the multiplicative action of `M` on `α` is faithful,\nthen `fixedBy α m = Set.univ` implies that `m = 1`. -/\n@[to_additive \"If the additive action of `M` on `α` is faithful,\nthen `fixedBy α m = Set.univ` implies that `m = 1`.\"]\ntheorem fixedBy_eq_univ_iff_eq_one {m : M} : fixedBy α m = Set.univ ↔ m = 1 := by\n  rw [← (smul_left_injective' (M := M) (α := α)).eq_iff, Set.eq_univ_iff_forall]\n  simp_rw [funext_iff, one_smul, mem_fixedBy]\n\n"}
{"name":"MulAction.not_commute_of_disjoint_movedBy_preimage","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : FaithfulSMul G α\ng h : G\nne_one : Ne g 1\ndisjoint : Disjoint (HasCompl.compl (MulAction.fixedBy α g)) (HSMul.hSMul h (HasCompl.compl (MulAction.fixedBy α g)))\n⊢ Not (Commute g h)","decl":"/--\nIf the image of the `(fixedBy α g)ᶜ` set by the pointwise action of `h: G`\nis disjoint from `(fixedBy α g)ᶜ`, then `g` and `h` cannot commute.\n-/\n@[to_additive \"If the image of the `(fixedBy α g)ᶜ` set by the pointwise action of `h: G`\nis disjoint from `(fixedBy α g)ᶜ`, then `g` and `h` cannot commute.\"]\ntheorem not_commute_of_disjoint_movedBy_preimage {g h : G} (ne_one : g ≠ 1)\n    (disjoint : Disjoint (fixedBy α g)ᶜ (h • (fixedBy α g)ᶜ)) : ¬Commute g h := by\n  contrapose! ne_one with comm\n  rwa [movedBy_mem_fixedBy_of_commute comm, disjoint_self, Set.bot_eq_empty, ← Set.compl_univ,\n    compl_inj_iff, fixedBy_eq_univ_iff_eq_one] at disjoint\n\n"}
{"name":"AddAction.not_addCommute_of_disjoint_movedBy_preimage","module":"Mathlib.GroupTheory.GroupAction.FixedPoints","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : FaithfulVAdd G α\ng h : G\nne_one : Ne g 0\ndisjoint : Disjoint (HasCompl.compl (AddAction.fixedBy α g)) (HVAdd.hVAdd h (HasCompl.compl (AddAction.fixedBy α g)))\n⊢ Not (AddCommute g h)","decl":"/--\nIf the image of the `(fixedBy α g)ᶜ` set by the pointwise action of `h: G`\nis disjoint from `(fixedBy α g)ᶜ`, then `g` and `h` cannot commute.\n-/\n@[to_additive \"If the image of the `(fixedBy α g)ᶜ` set by the pointwise action of `h: G`\nis disjoint from `(fixedBy α g)ᶜ`, then `g` and `h` cannot commute.\"]\ntheorem not_commute_of_disjoint_movedBy_preimage {g h : G} (ne_one : g ≠ 1)\n    (disjoint : Disjoint (fixedBy α g)ᶜ (h • (fixedBy α g)ᶜ)) : ¬Commute g h := by\n  contrapose! ne_one with comm\n  rwa [movedBy_mem_fixedBy_of_commute comm, disjoint_self, Set.bot_eq_empty, ← Set.compl_univ,\n    compl_inj_iff, fixedBy_eq_univ_iff_eq_one] at disjoint\n\n"}
