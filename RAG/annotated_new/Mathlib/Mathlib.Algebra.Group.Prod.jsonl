{"name":"Prod.fst_add","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Add M\ninst✝ : Add N\np q : Prod M N\n⊢ Eq (HAdd.hAdd p q).1 (HAdd.hAdd p.1 q.1)","decl":"@[to_additive (attr := simp)]\ntheorem fst_mul [Mul M] [Mul N] (p q : M × N) : (p * q).1 = p.1 * q.1 :=\n  rfl\n\n"}
{"name":"Prod.fst_mul","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Mul M\ninst✝ : Mul N\np q : Prod M N\n⊢ Eq (HMul.hMul p q).1 (HMul.hMul p.1 q.1)","decl":"@[to_additive (attr := simp)]\ntheorem fst_mul [Mul M] [Mul N] (p q : M × N) : (p * q).1 = p.1 * q.1 :=\n  rfl\n\n"}
{"name":"Prod.snd_mul","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Mul M\ninst✝ : Mul N\np q : Prod M N\n⊢ Eq (HMul.hMul p q).2 (HMul.hMul p.2 q.2)","decl":"@[to_additive (attr := simp)]\ntheorem snd_mul [Mul M] [Mul N] (p q : M × N) : (p * q).2 = p.2 * q.2 :=\n  rfl\n\n"}
{"name":"Prod.snd_add","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Add M\ninst✝ : Add N\np q : Prod M N\n⊢ Eq (HAdd.hAdd p q).2 (HAdd.hAdd p.2 q.2)","decl":"@[to_additive (attr := simp)]\ntheorem snd_mul [Mul M] [Mul N] (p q : M × N) : (p * q).2 = p.2 * q.2 :=\n  rfl\n\n"}
{"name":"Prod.mk_add_mk","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Add M\ninst✝ : Add N\na₁ a₂ : M\nb₁ b₂ : N\n⊢ Eq (HAdd.hAdd { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ }) { fst := HAdd.hAdd a₁ a₂, snd := HAdd.hAdd b₁ b₂ }","decl":"@[to_additive (attr := simp)]\ntheorem mk_mul_mk [Mul M] [Mul N] (a₁ a₂ : M) (b₁ b₂ : N) :\n    (a₁, b₁) * (a₂, b₂) = (a₁ * a₂, b₁ * b₂) :=\n  rfl\n\n"}
{"name":"Prod.mk_mul_mk","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Mul M\ninst✝ : Mul N\na₁ a₂ : M\nb₁ b₂ : N\n⊢ Eq (HMul.hMul { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ }) { fst := HMul.hMul a₁ a₂, snd := HMul.hMul b₁ b₂ }","decl":"@[to_additive (attr := simp)]\ntheorem mk_mul_mk [Mul M] [Mul N] (a₁ a₂ : M) (b₁ b₂ : N) :\n    (a₁, b₁) * (a₂, b₂) = (a₁ * a₂, b₁ * b₂) :=\n  rfl\n\n"}
{"name":"Prod.swap_mul","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Mul M\ninst✝ : Mul N\np q : Prod M N\n⊢ Eq (HMul.hMul p q).swap (HMul.hMul p.swap q.swap)","decl":"@[to_additive (attr := simp)]\ntheorem swap_mul [Mul M] [Mul N] (p q : M × N) : (p * q).swap = p.swap * q.swap :=\n  rfl\n\n"}
{"name":"Prod.swap_add","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Add M\ninst✝ : Add N\np q : Prod M N\n⊢ Eq (HAdd.hAdd p q).swap (HAdd.hAdd p.swap q.swap)","decl":"@[to_additive (attr := simp)]\ntheorem swap_mul [Mul M] [Mul N] (p q : M × N) : (p * q).swap = p.swap * q.swap :=\n  rfl\n\n"}
{"name":"Prod.add_def","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Add M\ninst✝ : Add N\np q : Prod M N\n⊢ Eq (HAdd.hAdd p q) { fst := HAdd.hAdd p.1 q.1, snd := HAdd.hAdd p.2 q.2 }","decl":"@[to_additive]\ntheorem mul_def [Mul M] [Mul N] (p q : M × N) : p * q = (p.1 * q.1, p.2 * q.2) :=\n  rfl\n\n"}
{"name":"Prod.mul_def","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Mul M\ninst✝ : Mul N\np q : Prod M N\n⊢ Eq (HMul.hMul p q) { fst := HMul.hMul p.1 q.1, snd := HMul.hMul p.2 q.2 }","decl":"@[to_additive]\ntheorem mul_def [Mul M] [Mul N] (p q : M × N) : p * q = (p.1 * q.1, p.2 * q.2) :=\n  rfl\n\n"}
{"name":"Prod.one_mk_mul_one_mk","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Monoid M\ninst✝ : Mul N\nb₁ b₂ : N\n⊢ Eq (HMul.hMul { fst := 1, snd := b₁ } { fst := 1, snd := b₂ }) { fst := 1, snd := HMul.hMul b₁ b₂ }","decl":"@[to_additive]\ntheorem one_mk_mul_one_mk [Monoid M] [Mul N] (b₁ b₂ : N) :\n    ((1 : M), b₁) * (1, b₂) = (1, b₁ * b₂) := by\n  rw [mk_mul_mk, mul_one]\n\n"}
{"name":"Prod.zero_mk_add_zero_mk","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : AddMonoid M\ninst✝ : Add N\nb₁ b₂ : N\n⊢ Eq (HAdd.hAdd { fst := 0, snd := b₁ } { fst := 0, snd := b₂ }) { fst := 0, snd := HAdd.hAdd b₁ b₂ }","decl":"@[to_additive]\ntheorem one_mk_mul_one_mk [Monoid M] [Mul N] (b₁ b₂ : N) :\n    ((1 : M), b₁) * (1, b₂) = (1, b₁ * b₂) := by\n  rw [mk_mul_mk, mul_one]\n\n"}
{"name":"Prod.mk_one_mul_mk_one","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Mul M\ninst✝ : Monoid N\na₁ a₂ : M\n⊢ Eq (HMul.hMul { fst := a₁, snd := 1 } { fst := a₂, snd := 1 }) { fst := HMul.hMul a₁ a₂, snd := 1 }","decl":"@[to_additive]\ntheorem mk_one_mul_mk_one [Mul M] [Monoid N] (a₁ a₂ : M) :\n    (a₁, (1 : N)) * (a₂, 1) = (a₁ * a₂, 1) := by\n  rw [mk_mul_mk, mul_one]\n\n"}
{"name":"Prod.mk_zero_add_mk_zero","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Add M\ninst✝ : AddMonoid N\na₁ a₂ : M\n⊢ Eq (HAdd.hAdd { fst := a₁, snd := 0 } { fst := a₂, snd := 0 }) { fst := HAdd.hAdd a₁ a₂, snd := 0 }","decl":"@[to_additive]\ntheorem mk_one_mul_mk_one [Mul M] [Monoid N] (a₁ a₂ : M) :\n    (a₁, (1 : N)) * (a₂, 1) = (a₁ * a₂, 1) := by\n  rw [mk_mul_mk, mul_one]\n\n"}
{"name":"Prod.fst_one","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : One M\ninst✝ : One N\n⊢ Eq 1.1 1","decl":"@[to_additive (attr := simp)]\ntheorem fst_one [One M] [One N] : (1 : M × N).1 = 1 :=\n  rfl\n\n"}
{"name":"Prod.fst_zero","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Zero M\ninst✝ : Zero N\n⊢ Eq 0.1 0","decl":"@[to_additive (attr := simp)]\ntheorem fst_one [One M] [One N] : (1 : M × N).1 = 1 :=\n  rfl\n\n"}
{"name":"Prod.snd_zero","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Zero M\ninst✝ : Zero N\n⊢ Eq 0.2 0","decl":"@[to_additive (attr := simp)]\ntheorem snd_one [One M] [One N] : (1 : M × N).2 = 1 :=\n  rfl\n\n"}
{"name":"Prod.snd_one","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : One M\ninst✝ : One N\n⊢ Eq 1.2 1","decl":"@[to_additive (attr := simp)]\ntheorem snd_one [One M] [One N] : (1 : M × N).2 = 1 :=\n  rfl\n\n"}
{"name":"Prod.zero_eq_mk","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Zero M\ninst✝ : Zero N\n⊢ Eq 0 { fst := 0, snd := 0 }","decl":"@[to_additive]\ntheorem one_eq_mk [One M] [One N] : (1 : M × N) = (1, 1) :=\n  rfl\n\n"}
{"name":"Prod.one_eq_mk","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : One M\ninst✝ : One N\n⊢ Eq 1 { fst := 1, snd := 1 }","decl":"@[to_additive]\ntheorem one_eq_mk [One M] [One N] : (1 : M × N) = (1, 1) :=\n  rfl\n\n"}
{"name":"Prod.mk_zero_zero","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Zero M\ninst✝ : Zero N\n⊢ Eq { fst := 0, snd := 0 } 0","decl":"@[to_additive (attr := simp)]\ntheorem mk_one_one [One M] [One N] : ((1 : M), (1 : N)) = 1 := rfl\n\n"}
{"name":"Prod.mk_one_one","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : One M\ninst✝ : One N\n⊢ Eq { fst := 1, snd := 1 } 1","decl":"@[to_additive (attr := simp)]\ntheorem mk_one_one [One M] [One N] : ((1 : M), (1 : N)) = 1 := rfl\n\n"}
{"name":"Prod.mk_eq_one","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : One M\ninst✝ : One N\nx : M\ny : N\n⊢ Iff (Eq { fst := x, snd := y } 1) (And (Eq x 1) (Eq y 1))","decl":"@[to_additive (attr := simp)]\ntheorem mk_eq_one [One M] [One N] {x : M} {y : N} : (x, y) = 1 ↔ x = 1 ∧ y = 1 :=\n  mk.inj_iff\n\n"}
{"name":"Prod.mk_eq_zero","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Zero M\ninst✝ : Zero N\nx : M\ny : N\n⊢ Iff (Eq { fst := x, snd := y } 0) (And (Eq x 0) (Eq y 0))","decl":"@[to_additive (attr := simp)]\ntheorem mk_eq_one [One M] [One N] {x : M} {y : N} : (x, y) = 1 ↔ x = 1 ∧ y = 1 :=\n  mk.inj_iff\n\n"}
{"name":"Prod.swap_one","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : One M\ninst✝ : One N\n⊢ Eq (Prod.swap 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem swap_one [One M] [One N] : (1 : M × N).swap = 1 :=\n  rfl\n\n"}
{"name":"Prod.swap_zero","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Zero M\ninst✝ : Zero N\n⊢ Eq (Prod.swap 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem swap_one [One M] [One N] : (1 : M × N).swap = 1 :=\n  rfl\n\n"}
{"name":"Prod.fst_mul_snd","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\np : Prod M N\n⊢ Eq (HMul.hMul { fst := p.1, snd := 1 } { fst := 1, snd := p.2 }) p","decl":"@[to_additive]\ntheorem fst_mul_snd [MulOneClass M] [MulOneClass N] (p : M × N) : (p.fst, 1) * (1, p.snd) = p :=\n  Prod.ext (mul_one p.1) (one_mul p.2)\n\n"}
{"name":"Prod.fst_add_snd","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\np : Prod M N\n⊢ Eq (HAdd.hAdd { fst := p.1, snd := 0 } { fst := 0, snd := p.2 }) p","decl":"@[to_additive]\ntheorem fst_mul_snd [MulOneClass M] [MulOneClass N] (p : M × N) : (p.fst, 1) * (1, p.snd) = p :=\n  Prod.ext (mul_one p.1) (one_mul p.2)\n\n"}
{"name":"Prod.fst_inv","module":"Mathlib.Algebra.Group.Prod","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Inv G\ninst✝ : Inv H\np : Prod G H\n⊢ Eq (Inv.inv p).1 (Inv.inv p.1)","decl":"@[to_additive (attr := simp)]\ntheorem fst_inv [Inv G] [Inv H] (p : G × H) : p⁻¹.1 = p.1⁻¹ :=\n  rfl\n\n"}
{"name":"Prod.fst_neg","module":"Mathlib.Algebra.Group.Prod","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Neg G\ninst✝ : Neg H\np : Prod G H\n⊢ Eq (Neg.neg p).1 (Neg.neg p.1)","decl":"@[to_additive (attr := simp)]\ntheorem fst_inv [Inv G] [Inv H] (p : G × H) : p⁻¹.1 = p.1⁻¹ :=\n  rfl\n\n"}
{"name":"Prod.snd_neg","module":"Mathlib.Algebra.Group.Prod","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Neg G\ninst✝ : Neg H\np : Prod G H\n⊢ Eq (Neg.neg p).2 (Neg.neg p.2)","decl":"@[to_additive (attr := simp)]\ntheorem snd_inv [Inv G] [Inv H] (p : G × H) : p⁻¹.2 = p.2⁻¹ :=\n  rfl\n\n"}
{"name":"Prod.snd_inv","module":"Mathlib.Algebra.Group.Prod","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Inv G\ninst✝ : Inv H\np : Prod G H\n⊢ Eq (Inv.inv p).2 (Inv.inv p.2)","decl":"@[to_additive (attr := simp)]\ntheorem snd_inv [Inv G] [Inv H] (p : G × H) : p⁻¹.2 = p.2⁻¹ :=\n  rfl\n\n"}
{"name":"Prod.inv_mk","module":"Mathlib.Algebra.Group.Prod","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Inv G\ninst✝ : Inv H\na : G\nb : H\n⊢ Eq (Inv.inv { fst := a, snd := b }) { fst := Inv.inv a, snd := Inv.inv b }","decl":"@[to_additive (attr := simp)]\ntheorem inv_mk [Inv G] [Inv H] (a : G) (b : H) : (a, b)⁻¹ = (a⁻¹, b⁻¹) :=\n  rfl\n\n"}
{"name":"Prod.neg_mk","module":"Mathlib.Algebra.Group.Prod","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Neg G\ninst✝ : Neg H\na : G\nb : H\n⊢ Eq (Neg.neg { fst := a, snd := b }) { fst := Neg.neg a, snd := Neg.neg b }","decl":"@[to_additive (attr := simp)]\ntheorem inv_mk [Inv G] [Inv H] (a : G) (b : H) : (a, b)⁻¹ = (a⁻¹, b⁻¹) :=\n  rfl\n\n"}
{"name":"Prod.swap_neg","module":"Mathlib.Algebra.Group.Prod","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Neg G\ninst✝ : Neg H\np : Prod G H\n⊢ Eq (Neg.neg p).swap (Neg.neg p.swap)","decl":"@[to_additive (attr := simp)]\ntheorem swap_inv [Inv G] [Inv H] (p : G × H) : p⁻¹.swap = p.swap⁻¹ :=\n  rfl\n\n"}
{"name":"Prod.swap_inv","module":"Mathlib.Algebra.Group.Prod","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Inv G\ninst✝ : Inv H\np : Prod G H\n⊢ Eq (Inv.inv p).swap (Inv.inv p.swap)","decl":"@[to_additive (attr := simp)]\ntheorem swap_inv [Inv G] [Inv H] (p : G × H) : p⁻¹.swap = p.swap⁻¹ :=\n  rfl\n\n"}
{"name":"Prod.fst_div","module":"Mathlib.Algebra.Group.Prod","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Div G\ninst✝ : Div H\na b : Prod G H\n⊢ Eq (HDiv.hDiv a b).1 (HDiv.hDiv a.1 b.1)","decl":"@[to_additive (attr := simp)]\ntheorem fst_div [Div G] [Div H] (a b : G × H) : (a / b).1 = a.1 / b.1 :=\n  rfl\n\n"}
{"name":"Prod.fst_sub","module":"Mathlib.Algebra.Group.Prod","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Sub G\ninst✝ : Sub H\na b : Prod G H\n⊢ Eq (HSub.hSub a b).1 (HSub.hSub a.1 b.1)","decl":"@[to_additive (attr := simp)]\ntheorem fst_div [Div G] [Div H] (a b : G × H) : (a / b).1 = a.1 / b.1 :=\n  rfl\n\n"}
{"name":"Prod.snd_sub","module":"Mathlib.Algebra.Group.Prod","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Sub G\ninst✝ : Sub H\na b : Prod G H\n⊢ Eq (HSub.hSub a b).2 (HSub.hSub a.2 b.2)","decl":"@[to_additive (attr := simp)]\ntheorem snd_div [Div G] [Div H] (a b : G × H) : (a / b).2 = a.2 / b.2 :=\n  rfl\n\n"}
{"name":"Prod.snd_div","module":"Mathlib.Algebra.Group.Prod","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Div G\ninst✝ : Div H\na b : Prod G H\n⊢ Eq (HDiv.hDiv a b).2 (HDiv.hDiv a.2 b.2)","decl":"@[to_additive (attr := simp)]\ntheorem snd_div [Div G] [Div H] (a b : G × H) : (a / b).2 = a.2 / b.2 :=\n  rfl\n\n"}
{"name":"Prod.mk_div_mk","module":"Mathlib.Algebra.Group.Prod","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Div G\ninst✝ : Div H\nx₁ x₂ : G\ny₁ y₂ : H\n⊢ Eq (HDiv.hDiv { fst := x₁, snd := y₁ } { fst := x₂, snd := y₂ }) { fst := HDiv.hDiv x₁ x₂, snd := HDiv.hDiv y₁ y₂ }","decl":"@[to_additive (attr := simp)]\ntheorem mk_div_mk [Div G] [Div H] (x₁ x₂ : G) (y₁ y₂ : H) :\n    (x₁, y₁) / (x₂, y₂) = (x₁ / x₂, y₁ / y₂) :=\n  rfl\n\n"}
{"name":"Prod.mk_sub_mk","module":"Mathlib.Algebra.Group.Prod","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Sub G\ninst✝ : Sub H\nx₁ x₂ : G\ny₁ y₂ : H\n⊢ Eq (HSub.hSub { fst := x₁, snd := y₁ } { fst := x₂, snd := y₂ }) { fst := HSub.hSub x₁ x₂, snd := HSub.hSub y₁ y₂ }","decl":"@[to_additive (attr := simp)]\ntheorem mk_div_mk [Div G] [Div H] (x₁ x₂ : G) (y₁ y₂ : H) :\n    (x₁, y₁) / (x₂, y₂) = (x₁ / x₂, y₁ / y₂) :=\n  rfl\n\n"}
{"name":"Prod.swap_sub","module":"Mathlib.Algebra.Group.Prod","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Sub G\ninst✝ : Sub H\na b : Prod G H\n⊢ Eq (HSub.hSub a b).swap (HSub.hSub a.swap b.swap)","decl":"@[to_additive (attr := simp)]\ntheorem swap_div [Div G] [Div H] (a b : G × H) : (a / b).swap = a.swap / b.swap :=\n  rfl\n\n"}
{"name":"Prod.swap_div","module":"Mathlib.Algebra.Group.Prod","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Div G\ninst✝ : Div H\na b : Prod G H\n⊢ Eq (HDiv.hDiv a b).swap (HDiv.hDiv a.swap b.swap)","decl":"@[to_additive (attr := simp)]\ntheorem swap_div [Div G] [Div H] (a b : G × H) : (a / b).swap = a.swap / b.swap :=\n  rfl\n\n"}
{"name":"Prod.div_def","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Div M\ninst✝ : Div N\na b : Prod M N\n⊢ Eq (HDiv.hDiv a b) { fst := HDiv.hDiv a.1 b.1, snd := HDiv.hDiv a.2 b.2 }","decl":"@[to_additive] lemma div_def [Div M] [Div N] (a b : M × N) : a / b = (a.1 / b.1, a.2 / b.2) := rfl\n\n"}
{"name":"Prod.sub_def","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Sub M\ninst✝ : Sub N\na b : Prod M N\n⊢ Eq (HSub.hSub a b) { fst := HSub.hSub a.1 b.1, snd := HSub.hSub a.2 b.2 }","decl":"@[to_additive] lemma div_def [Div M] [Div N] (a b : M × N) : a / b = (a.1 / b.1, a.2 / b.2) := rfl\n\n"}
{"name":"Prod.instIsAddLeftCancel","module":"Mathlib.Algebra.Group.Prod","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝³ : Add G\ninst✝² : Add H\ninst✝¹ : IsLeftCancelAdd G\ninst✝ : IsLeftCancelAdd H\n⊢ IsLeftCancelAdd (Prod G H)","decl":"@[to_additive]\ninstance [Mul G] [Mul H] [IsLeftCancelMul G] [IsLeftCancelMul H] : IsLeftCancelMul (G × H) where\n  mul_left_cancel _ _ _ h :=\n      Prod.ext (mul_left_cancel (Prod.ext_iff.1 h).1) (mul_left_cancel (Prod.ext_iff.1 h).2)\n\n"}
{"name":"Prod.instIsLeftCancelMul","module":"Mathlib.Algebra.Group.Prod","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝³ : Mul G\ninst✝² : Mul H\ninst✝¹ : IsLeftCancelMul G\ninst✝ : IsLeftCancelMul H\n⊢ IsLeftCancelMul (Prod G H)","decl":"@[to_additive]\ninstance [Mul G] [Mul H] [IsLeftCancelMul G] [IsLeftCancelMul H] : IsLeftCancelMul (G × H) where\n  mul_left_cancel _ _ _ h :=\n      Prod.ext (mul_left_cancel (Prod.ext_iff.1 h).1) (mul_left_cancel (Prod.ext_iff.1 h).2)\n\n"}
{"name":"Prod.instIsRightCancelMul","module":"Mathlib.Algebra.Group.Prod","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝³ : Mul G\ninst✝² : Mul H\ninst✝¹ : IsRightCancelMul G\ninst✝ : IsRightCancelMul H\n⊢ IsRightCancelMul (Prod G H)","decl":"@[to_additive]\ninstance [Mul G] [Mul H] [IsRightCancelMul G] [IsRightCancelMul H] : IsRightCancelMul (G × H) where\n  mul_right_cancel _ _ _ h :=\n      Prod.ext (mul_right_cancel (Prod.ext_iff.1 h).1) (mul_right_cancel (Prod.ext_iff.1 h).2)\n\n"}
{"name":"Prod.instIsAddRightCancel","module":"Mathlib.Algebra.Group.Prod","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝³ : Add G\ninst✝² : Add H\ninst✝¹ : IsRightCancelAdd G\ninst✝ : IsRightCancelAdd H\n⊢ IsRightCancelAdd (Prod G H)","decl":"@[to_additive]\ninstance [Mul G] [Mul H] [IsRightCancelMul G] [IsRightCancelMul H] : IsRightCancelMul (G × H) where\n  mul_right_cancel _ _ _ h :=\n      Prod.ext (mul_right_cancel (Prod.ext_iff.1 h).1) (mul_right_cancel (Prod.ext_iff.1 h).2)\n\n"}
{"name":"Prod.instIsCancelMul","module":"Mathlib.Algebra.Group.Prod","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝³ : Mul G\ninst✝² : Mul H\ninst✝¹ : IsCancelMul G\ninst✝ : IsCancelMul H\n⊢ IsCancelMul (Prod G H)","decl":"@[to_additive]\ninstance [Mul G] [Mul H] [IsCancelMul G] [IsCancelMul H] : IsCancelMul (G × H) where\n\n"}
{"name":"Prod.instIsAddCancel","module":"Mathlib.Algebra.Group.Prod","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝³ : Add G\ninst✝² : Add H\ninst✝¹ : IsCancelAdd G\ninst✝ : IsCancelAdd H\n⊢ IsCancelAdd (Prod G H)","decl":"@[to_additive]\ninstance [Mul G] [Mul H] [IsCancelMul G] [IsCancelMul H] : IsCancelMul (G × H) where\n\n"}
{"name":"SemiconjBy.prod","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Mul M\ninst✝ : Mul N\nx y z : Prod M N\nhm : SemiconjBy x.1 y.1 z.1\nhn : SemiconjBy x.2 y.2 z.2\n⊢ SemiconjBy x y z","decl":"@[to_additive AddSemiconjBy.prod]\ntheorem SemiconjBy.prod {x y z : M × N}\n    (hm : SemiconjBy x.1 y.1 z.1) (hn : SemiconjBy x.2 y.2 z.2) : SemiconjBy x y z :=\n  Prod.ext hm hn\n\n"}
{"name":"AddSemiconjBy.prod","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Add M\ninst✝ : Add N\nx y z : Prod M N\nhm : AddSemiconjBy x.1 y.1 z.1\nhn : AddSemiconjBy x.2 y.2 z.2\n⊢ AddSemiconjBy x y z","decl":"@[to_additive AddSemiconjBy.prod]\ntheorem SemiconjBy.prod {x y z : M × N}\n    (hm : SemiconjBy x.1 y.1 z.1) (hn : SemiconjBy x.2 y.2 z.2) : SemiconjBy x y z :=\n  Prod.ext hm hn\n\n"}
{"name":"Prod.addSemiconjBy_iff","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Add M\ninst✝ : Add N\nx y z : Prod M N\n⊢ Iff (AddSemiconjBy x y z) (And (AddSemiconjBy x.1 y.1 z.1) (AddSemiconjBy x.2 y.2 z.2))","decl":"@[to_additive]\ntheorem Prod.semiconjBy_iff {x y z : M × N} :\n    SemiconjBy x y z ↔ SemiconjBy x.1 y.1 z.1 ∧ SemiconjBy x.2 y.2 z.2 := Prod.ext_iff\n\n"}
{"name":"Prod.semiconjBy_iff","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Mul M\ninst✝ : Mul N\nx y z : Prod M N\n⊢ Iff (SemiconjBy x y z) (And (SemiconjBy x.1 y.1 z.1) (SemiconjBy x.2 y.2 z.2))","decl":"@[to_additive]\ntheorem Prod.semiconjBy_iff {x y z : M × N} :\n    SemiconjBy x y z ↔ SemiconjBy x.1 y.1 z.1 ∧ SemiconjBy x.2 y.2 z.2 := Prod.ext_iff\n\n"}
{"name":"AddCommute.prod","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Add M\ninst✝ : Add N\nx y : Prod M N\nhm : AddCommute x.1 y.1\nhn : AddCommute x.2 y.2\n⊢ AddCommute x y","decl":"@[to_additive AddCommute.prod]\ntheorem Commute.prod {x y : M × N} (hm : Commute x.1 y.1) (hn : Commute x.2 y.2) : Commute x y :=\n  SemiconjBy.prod hm hn\n\n"}
{"name":"Commute.prod","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Mul M\ninst✝ : Mul N\nx y : Prod M N\nhm : Commute x.1 y.1\nhn : Commute x.2 y.2\n⊢ Commute x y","decl":"@[to_additive AddCommute.prod]\ntheorem Commute.prod {x y : M × N} (hm : Commute x.1 y.1) (hn : Commute x.2 y.2) : Commute x y :=\n  SemiconjBy.prod hm hn\n\n"}
{"name":"Prod.commute_iff","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Mul M\ninst✝ : Mul N\nx y : Prod M N\n⊢ Iff (Commute x y) (And (Commute x.1 y.1) (Commute x.2 y.2))","decl":"@[to_additive]\ntheorem Prod.commute_iff {x y : M × N} :\n    Commute x y ↔ Commute x.1 y.1 ∧ Commute x.2 y.2 := semiconjBy_iff\n\n"}
{"name":"Prod.addCommute_iff","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Add M\ninst✝ : Add N\nx y : Prod M N\n⊢ Iff (AddCommute x y) (And (AddCommute x.1 y.1) (AddCommute x.2 y.2))","decl":"@[to_additive]\ntheorem Prod.commute_iff {x y : M × N} :\n    Commute x y ↔ Commute x.1 y.1 ∧ Commute x.2 y.2 := semiconjBy_iff\n\n"}
{"name":"AddHom.coe_fst","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Add M\ninst✝ : Add N\n⊢ Eq (⇑(AddHom.fst M N)) Prod.fst","decl":"@[to_additive (attr := simp)]\ntheorem coe_fst : ⇑(fst M N) = Prod.fst :=\n  rfl\n\n"}
{"name":"MulHom.coe_fst","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Mul M\ninst✝ : Mul N\n⊢ Eq (⇑(MulHom.fst M N)) Prod.fst","decl":"@[to_additive (attr := simp)]\ntheorem coe_fst : ⇑(fst M N) = Prod.fst :=\n  rfl\n\n"}
{"name":"AddHom.coe_snd","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Add M\ninst✝ : Add N\n⊢ Eq (⇑(AddHom.snd M N)) Prod.snd","decl":"@[to_additive (attr := simp)]\ntheorem coe_snd : ⇑(snd M N) = Prod.snd :=\n  rfl\n\n"}
{"name":"MulHom.coe_snd","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Mul M\ninst✝ : Mul N\n⊢ Eq (⇑(MulHom.snd M N)) Prod.snd","decl":"@[to_additive (attr := simp)]\ntheorem coe_snd : ⇑(snd M N) = Prod.snd :=\n  rfl\n\n"}
{"name":"AddHom.coe_prod","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : Add M\ninst✝¹ : Add N\ninst✝ : Add P\nf : AddHom M N\ng : AddHom M P\n⊢ Eq (⇑(f.prod g)) (Pi.prod ⇑f ⇑g)","decl":"@[to_additive coe_prod]\ntheorem coe_prod (f : M →ₙ* N) (g : M →ₙ* P) : ⇑(f.prod g) = Pi.prod f g :=\n  rfl\n\n"}
{"name":"MulHom.coe_prod","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : Mul M\ninst✝¹ : Mul N\ninst✝ : Mul P\nf : MulHom M N\ng : MulHom M P\n⊢ Eq (⇑(f.prod g)) (Pi.prod ⇑f ⇑g)","decl":"@[to_additive coe_prod]\ntheorem coe_prod (f : M →ₙ* N) (g : M →ₙ* P) : ⇑(f.prod g) = Pi.prod f g :=\n  rfl\n\n"}
{"name":"AddHom.prod_apply","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : Add M\ninst✝¹ : Add N\ninst✝ : Add P\nf : AddHom M N\ng : AddHom M P\nx : M\n⊢ Eq ((f.prod g) x) { fst := f x, snd := g x }","decl":"@[to_additive (attr := simp) prod_apply]\ntheorem prod_apply (f : M →ₙ* N) (g : M →ₙ* P) (x) : f.prod g x = (f x, g x) :=\n  rfl\n\n"}
{"name":"MulHom.prod_apply","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : Mul M\ninst✝¹ : Mul N\ninst✝ : Mul P\nf : MulHom M N\ng : MulHom M P\nx : M\n⊢ Eq ((f.prod g) x) { fst := f x, snd := g x }","decl":"@[to_additive (attr := simp) prod_apply]\ntheorem prod_apply (f : M →ₙ* N) (g : M →ₙ* P) (x) : f.prod g x = (f x, g x) :=\n  rfl\n\n"}
{"name":"MulHom.fst_comp_prod","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : Mul M\ninst✝¹ : Mul N\ninst✝ : Mul P\nf : MulHom M N\ng : MulHom M P\n⊢ Eq ((MulHom.fst N P).comp (f.prod g)) f","decl":"@[to_additive (attr := simp) fst_comp_prod]\ntheorem fst_comp_prod (f : M →ₙ* N) (g : M →ₙ* P) : (fst N P).comp (f.prod g) = f :=\n  ext fun _ => rfl\n\n"}
{"name":"AddHom.fst_comp_prod","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : Add M\ninst✝¹ : Add N\ninst✝ : Add P\nf : AddHom M N\ng : AddHom M P\n⊢ Eq ((AddHom.fst N P).comp (f.prod g)) f","decl":"@[to_additive (attr := simp) fst_comp_prod]\ntheorem fst_comp_prod (f : M →ₙ* N) (g : M →ₙ* P) : (fst N P).comp (f.prod g) = f :=\n  ext fun _ => rfl\n\n"}
{"name":"MulHom.snd_comp_prod","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : Mul M\ninst✝¹ : Mul N\ninst✝ : Mul P\nf : MulHom M N\ng : MulHom M P\n⊢ Eq ((MulHom.snd N P).comp (f.prod g)) g","decl":"@[to_additive (attr := simp) snd_comp_prod]\ntheorem snd_comp_prod (f : M →ₙ* N) (g : M →ₙ* P) : (snd N P).comp (f.prod g) = g :=\n  ext fun _ => rfl\n\n"}
{"name":"AddHom.snd_comp_prod","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : Add M\ninst✝¹ : Add N\ninst✝ : Add P\nf : AddHom M N\ng : AddHom M P\n⊢ Eq ((AddHom.snd N P).comp (f.prod g)) g","decl":"@[to_additive (attr := simp) snd_comp_prod]\ntheorem snd_comp_prod (f : M →ₙ* N) (g : M →ₙ* P) : (snd N P).comp (f.prod g) = g :=\n  ext fun _ => rfl\n\n"}
{"name":"MulHom.prod_unique","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : Mul M\ninst✝¹ : Mul N\ninst✝ : Mul P\nf : MulHom M (Prod N P)\n⊢ Eq (((MulHom.fst N P).comp f).prod ((MulHom.snd N P).comp f)) f","decl":"@[to_additive (attr := simp) prod_unique]\ntheorem prod_unique (f : M →ₙ* N × P) : ((fst N P).comp f).prod ((snd N P).comp f) = f :=\n  ext fun x => by simp only [prod_apply, coe_fst, coe_snd, comp_apply]\n\n"}
{"name":"AddHom.prod_unique","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : Add M\ninst✝¹ : Add N\ninst✝ : Add P\nf : AddHom M (Prod N P)\n⊢ Eq (((AddHom.fst N P).comp f).prod ((AddHom.snd N P).comp f)) f","decl":"@[to_additive (attr := simp) prod_unique]\ntheorem prod_unique (f : M →ₙ* N × P) : ((fst N P).comp f).prod ((snd N P).comp f) = f :=\n  ext fun x => by simp only [prod_apply, coe_fst, coe_snd, comp_apply]\n\n"}
{"name":"MulHom.prodMap_def","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nM' : Type u_6\nN' : Type u_7\ninst✝³ : Mul M\ninst✝² : Mul N\ninst✝¹ : Mul M'\ninst✝ : Mul N'\nf : MulHom M M'\ng : MulHom N N'\n⊢ Eq (f.prodMap g) ((f.comp (MulHom.fst M N)).prod (g.comp (MulHom.snd M N)))","decl":"@[to_additive prodMap_def]\ntheorem prodMap_def : prodMap f g = (f.comp (fst M N)).prod (g.comp (snd M N)) :=\n  rfl\n\n"}
{"name":"AddHom.prodMap_def","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nM' : Type u_6\nN' : Type u_7\ninst✝³ : Add M\ninst✝² : Add N\ninst✝¹ : Add M'\ninst✝ : Add N'\nf : AddHom M M'\ng : AddHom N N'\n⊢ Eq (f.prodMap g) ((f.comp (AddHom.fst M N)).prod (g.comp (AddHom.snd M N)))","decl":"@[to_additive prodMap_def]\ntheorem prodMap_def : prodMap f g = (f.comp (fst M N)).prod (g.comp (snd M N)) :=\n  rfl\n\n"}
{"name":"MulHom.coe_prodMap","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nM' : Type u_6\nN' : Type u_7\ninst✝³ : Mul M\ninst✝² : Mul N\ninst✝¹ : Mul M'\ninst✝ : Mul N'\nf : MulHom M M'\ng : MulHom N N'\n⊢ Eq (⇑(f.prodMap g)) (Prod.map ⇑f ⇑g)","decl":"@[to_additive (attr := simp) coe_prodMap]\ntheorem coe_prodMap : ⇑(prodMap f g) = Prod.map f g :=\n  rfl\n\n"}
{"name":"AddHom.coe_prodMap","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nM' : Type u_6\nN' : Type u_7\ninst✝³ : Add M\ninst✝² : Add N\ninst✝¹ : Add M'\ninst✝ : Add N'\nf : AddHom M M'\ng : AddHom N N'\n⊢ Eq (⇑(f.prodMap g)) (Prod.map ⇑f ⇑g)","decl":"@[to_additive (attr := simp) coe_prodMap]\ntheorem coe_prodMap : ⇑(prodMap f g) = Prod.map f g :=\n  rfl\n\n"}
{"name":"MulHom.prod_comp_prodMap","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\nM' : Type u_6\nN' : Type u_7\ninst✝⁴ : Mul M\ninst✝³ : Mul N\ninst✝² : Mul M'\ninst✝¹ : Mul N'\ninst✝ : Mul P\nf : MulHom P M\ng : MulHom P N\nf' : MulHom M M'\ng' : MulHom N N'\n⊢ Eq ((f'.prodMap g').comp (f.prod g)) ((f'.comp f).prod (g'.comp g))","decl":"@[to_additive prod_comp_prodMap]\ntheorem prod_comp_prodMap (f : P →ₙ* M) (g : P →ₙ* N) (f' : M →ₙ* M') (g' : N →ₙ* N') :\n    (f'.prodMap g').comp (f.prod g) = (f'.comp f).prod (g'.comp g) :=\n  rfl\n\n"}
{"name":"AddHom.prod_comp_prodMap","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\nM' : Type u_6\nN' : Type u_7\ninst✝⁴ : Add M\ninst✝³ : Add N\ninst✝² : Add M'\ninst✝¹ : Add N'\ninst✝ : Add P\nf : AddHom P M\ng : AddHom P N\nf' : AddHom M M'\ng' : AddHom N N'\n⊢ Eq ((f'.prodMap g').comp (f.prod g)) ((f'.comp f).prod (g'.comp g))","decl":"@[to_additive prod_comp_prodMap]\ntheorem prod_comp_prodMap (f : P →ₙ* M) (g : P →ₙ* N) (f' : M →ₙ* M') (g' : N →ₙ* N') :\n    (f'.prodMap g').comp (f.prod g) = (f'.comp f).prod (g'.comp g) :=\n  rfl\n\n"}
{"name":"AddHom.coprod_apply","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : Add M\ninst✝¹ : Add N\ninst✝ : AddCommSemigroup P\nf : AddHom M P\ng : AddHom N P\np : Prod M N\n⊢ Eq ((f.coprod g) p) (HAdd.hAdd (f p.1) (g p.2))","decl":"@[to_additive (attr := simp)]\ntheorem coprod_apply (p : M × N) : f.coprod g p = f p.1 * g p.2 :=\n  rfl\n\n"}
{"name":"MulHom.coprod_apply","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : Mul M\ninst✝¹ : Mul N\ninst✝ : CommSemigroup P\nf : MulHom M P\ng : MulHom N P\np : Prod M N\n⊢ Eq ((f.coprod g) p) (HMul.hMul (f p.1) (g p.2))","decl":"@[to_additive (attr := simp)]\ntheorem coprod_apply (p : M × N) : f.coprod g p = f p.1 * g p.2 :=\n  rfl\n\n"}
{"name":"AddHom.comp_coprod","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝³ : Add M\ninst✝² : Add N\ninst✝¹ : AddCommSemigroup P\nQ : Type u_6\ninst✝ : AddCommSemigroup Q\nh : AddHom P Q\nf : AddHom M P\ng : AddHom N P\n⊢ Eq (h.comp (f.coprod g)) ((h.comp f).coprod (h.comp g))","decl":"@[to_additive]\ntheorem comp_coprod {Q : Type*} [CommSemigroup Q] (h : P →ₙ* Q) (f : M →ₙ* P) (g : N →ₙ* P) :\n    h.comp (f.coprod g) = (h.comp f).coprod (h.comp g) :=\n  ext fun x => by simp\n\n"}
{"name":"MulHom.comp_coprod","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝³ : Mul M\ninst✝² : Mul N\ninst✝¹ : CommSemigroup P\nQ : Type u_6\ninst✝ : CommSemigroup Q\nh : MulHom P Q\nf : MulHom M P\ng : MulHom N P\n⊢ Eq (h.comp (f.coprod g)) ((h.comp f).coprod (h.comp g))","decl":"@[to_additive]\ntheorem comp_coprod {Q : Type*} [CommSemigroup Q] (h : P →ₙ* Q) (f : M →ₙ* P) (g : N →ₙ* P) :\n    h.comp (f.coprod g) = (h.comp f).coprod (h.comp g) :=\n  ext fun x => by simp\n\n"}
{"name":"MonoidHom.coe_fst","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq (⇑(MonoidHom.fst M N)) Prod.fst","decl":"@[to_additive (attr := simp)]\ntheorem coe_fst : ⇑(fst M N) = Prod.fst :=\n  rfl\n\n"}
{"name":"AddMonoidHom.coe_fst","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq (⇑(AddMonoidHom.fst M N)) Prod.fst","decl":"@[to_additive (attr := simp)]\ntheorem coe_fst : ⇑(fst M N) = Prod.fst :=\n  rfl\n\n"}
{"name":"MonoidHom.coe_snd","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq (⇑(MonoidHom.snd M N)) Prod.snd","decl":"@[to_additive (attr := simp)]\ntheorem coe_snd : ⇑(snd M N) = Prod.snd :=\n  rfl\n\n"}
{"name":"AddMonoidHom.coe_snd","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq (⇑(AddMonoidHom.snd M N)) Prod.snd","decl":"@[to_additive (attr := simp)]\ntheorem coe_snd : ⇑(snd M N) = Prod.snd :=\n  rfl\n\n"}
{"name":"AddMonoidHom.inl_apply","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nx : M\n⊢ Eq ((AddMonoidHom.inl M N) x) { fst := x, snd := 0 }","decl":"@[to_additive (attr := simp)]\ntheorem inl_apply (x) : inl M N x = (x, 1) :=\n  rfl\n\n"}
{"name":"MonoidHom.inl_apply","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nx : M\n⊢ Eq ((MonoidHom.inl M N) x) { fst := x, snd := 1 }","decl":"@[to_additive (attr := simp)]\ntheorem inl_apply (x) : inl M N x = (x, 1) :=\n  rfl\n\n"}
{"name":"MonoidHom.inr_apply","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\ny : N\n⊢ Eq ((MonoidHom.inr M N) y) { fst := 1, snd := y }","decl":"@[to_additive (attr := simp)]\ntheorem inr_apply (y) : inr M N y = (1, y) :=\n  rfl\n\n"}
{"name":"AddMonoidHom.inr_apply","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\ny : N\n⊢ Eq ((AddMonoidHom.inr M N) y) { fst := 0, snd := y }","decl":"@[to_additive (attr := simp)]\ntheorem inr_apply (y) : inr M N y = (1, y) :=\n  rfl\n\n"}
{"name":"AddMonoidHom.fst_comp_inl","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq ((AddMonoidHom.fst M N).comp (AddMonoidHom.inl M N)) (AddMonoidHom.id M)","decl":"@[to_additive (attr := simp)]\ntheorem fst_comp_inl : (fst M N).comp (inl M N) = id M :=\n  rfl\n\n"}
{"name":"MonoidHom.fst_comp_inl","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq ((MonoidHom.fst M N).comp (MonoidHom.inl M N)) (MonoidHom.id M)","decl":"@[to_additive (attr := simp)]\ntheorem fst_comp_inl : (fst M N).comp (inl M N) = id M :=\n  rfl\n\n"}
{"name":"AddMonoidHom.snd_comp_inl","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq ((AddMonoidHom.snd M N).comp (AddMonoidHom.inl M N)) 0","decl":"@[to_additive (attr := simp)]\ntheorem snd_comp_inl : (snd M N).comp (inl M N) = 1 :=\n  rfl\n\n"}
{"name":"MonoidHom.snd_comp_inl","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq ((MonoidHom.snd M N).comp (MonoidHom.inl M N)) 1","decl":"@[to_additive (attr := simp)]\ntheorem snd_comp_inl : (snd M N).comp (inl M N) = 1 :=\n  rfl\n\n"}
{"name":"AddMonoidHom.fst_comp_inr","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq ((AddMonoidHom.fst M N).comp (AddMonoidHom.inr M N)) 0","decl":"@[to_additive (attr := simp)]\ntheorem fst_comp_inr : (fst M N).comp (inr M N) = 1 :=\n  rfl\n\n"}
{"name":"MonoidHom.fst_comp_inr","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq ((MonoidHom.fst M N).comp (MonoidHom.inr M N)) 1","decl":"@[to_additive (attr := simp)]\ntheorem fst_comp_inr : (fst M N).comp (inr M N) = 1 :=\n  rfl\n\n"}
{"name":"MonoidHom.snd_comp_inr","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq ((MonoidHom.snd M N).comp (MonoidHom.inr M N)) (MonoidHom.id N)","decl":"@[to_additive (attr := simp)]\ntheorem snd_comp_inr : (snd M N).comp (inr M N) = id N :=\n  rfl\n\n"}
{"name":"AddMonoidHom.snd_comp_inr","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq ((AddMonoidHom.snd M N).comp (AddMonoidHom.inr M N)) (AddMonoidHom.id N)","decl":"@[to_additive (attr := simp)]\ntheorem snd_comp_inr : (snd M N).comp (inr M N) = id N :=\n  rfl\n\n"}
{"name":"MonoidHom.commute_inl_inr","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nm : M\nn : N\n⊢ Commute ((MonoidHom.inl M N) m) ((MonoidHom.inr M N) n)","decl":"@[to_additive]\ntheorem commute_inl_inr (m : M) (n : N) : Commute (inl M N m) (inr M N n) :=\n  Commute.prod (.one_right m) (.one_left n)\n\n"}
{"name":"AddMonoidHom.addCommute_inl_inr","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nm : M\nn : N\n⊢ AddCommute ((AddMonoidHom.inl M N) m) ((AddMonoidHom.inr M N) n)","decl":"@[to_additive]\ntheorem commute_inl_inr (m : M) (n : N) : Commute (inl M N m) (inr M N n) :=\n  Commute.prod (.one_right m) (.one_left n)\n\n"}
{"name":"AddMonoidHom.coe_prod","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\nf : AddMonoidHom M N\ng : AddMonoidHom M P\n⊢ Eq (⇑(f.prod g)) (Pi.prod ⇑f ⇑g)","decl":"@[to_additive coe_prod]\ntheorem coe_prod (f : M →* N) (g : M →* P) : ⇑(f.prod g) = Pi.prod f g :=\n  rfl\n\n"}
{"name":"MonoidHom.coe_prod","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\nf : MonoidHom M N\ng : MonoidHom M P\n⊢ Eq (⇑(f.prod g)) (Pi.prod ⇑f ⇑g)","decl":"@[to_additive coe_prod]\ntheorem coe_prod (f : M →* N) (g : M →* P) : ⇑(f.prod g) = Pi.prod f g :=\n  rfl\n\n"}
{"name":"AddMonoidHom.prod_apply","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\nf : AddMonoidHom M N\ng : AddMonoidHom M P\nx : M\n⊢ Eq ((f.prod g) x) { fst := f x, snd := g x }","decl":"@[to_additive (attr := simp) prod_apply]\ntheorem prod_apply (f : M →* N) (g : M →* P) (x) : f.prod g x = (f x, g x) :=\n  rfl\n\n"}
{"name":"MonoidHom.prod_apply","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\nf : MonoidHom M N\ng : MonoidHom M P\nx : M\n⊢ Eq ((f.prod g) x) { fst := f x, snd := g x }","decl":"@[to_additive (attr := simp) prod_apply]\ntheorem prod_apply (f : M →* N) (g : M →* P) (x) : f.prod g x = (f x, g x) :=\n  rfl\n\n"}
{"name":"MonoidHom.fst_comp_prod","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\nf : MonoidHom M N\ng : MonoidHom M P\n⊢ Eq ((MonoidHom.fst N P).comp (f.prod g)) f","decl":"@[to_additive (attr := simp) fst_comp_prod]\ntheorem fst_comp_prod (f : M →* N) (g : M →* P) : (fst N P).comp (f.prod g) = f :=\n  ext fun _ => rfl\n\n"}
{"name":"AddMonoidHom.fst_comp_prod","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\nf : AddMonoidHom M N\ng : AddMonoidHom M P\n⊢ Eq ((AddMonoidHom.fst N P).comp (f.prod g)) f","decl":"@[to_additive (attr := simp) fst_comp_prod]\ntheorem fst_comp_prod (f : M →* N) (g : M →* P) : (fst N P).comp (f.prod g) = f :=\n  ext fun _ => rfl\n\n"}
{"name":"MonoidHom.snd_comp_prod","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\nf : MonoidHom M N\ng : MonoidHom M P\n⊢ Eq ((MonoidHom.snd N P).comp (f.prod g)) g","decl":"@[to_additive (attr := simp) snd_comp_prod]\ntheorem snd_comp_prod (f : M →* N) (g : M →* P) : (snd N P).comp (f.prod g) = g :=\n  ext fun _ => rfl\n\n"}
{"name":"AddMonoidHom.snd_comp_prod","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\nf : AddMonoidHom M N\ng : AddMonoidHom M P\n⊢ Eq ((AddMonoidHom.snd N P).comp (f.prod g)) g","decl":"@[to_additive (attr := simp) snd_comp_prod]\ntheorem snd_comp_prod (f : M →* N) (g : M →* P) : (snd N P).comp (f.prod g) = g :=\n  ext fun _ => rfl\n\n"}
{"name":"AddMonoidHom.prod_unique","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\nf : AddMonoidHom M (Prod N P)\n⊢ Eq (((AddMonoidHom.fst N P).comp f).prod ((AddMonoidHom.snd N P).comp f)) f","decl":"@[to_additive (attr := simp) prod_unique]\ntheorem prod_unique (f : M →* N × P) : ((fst N P).comp f).prod ((snd N P).comp f) = f :=\n  ext fun x => by simp only [prod_apply, coe_fst, coe_snd, comp_apply]\n\n"}
{"name":"MonoidHom.prod_unique","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\nf : MonoidHom M (Prod N P)\n⊢ Eq (((MonoidHom.fst N P).comp f).prod ((MonoidHom.snd N P).comp f)) f","decl":"@[to_additive (attr := simp) prod_unique]\ntheorem prod_unique (f : M →* N × P) : ((fst N P).comp f).prod ((snd N P).comp f) = f :=\n  ext fun x => by simp only [prod_apply, coe_fst, coe_snd, comp_apply]\n\n"}
{"name":"AddMonoidHom.prodMap_def","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\nM' : Type u_6\nN' : Type u_7\ninst✝¹ : AddZeroClass M'\ninst✝ : AddZeroClass N'\nf : AddMonoidHom M M'\ng : AddMonoidHom N N'\n⊢ Eq (f.prodMap g) ((f.comp (AddMonoidHom.fst M N)).prod (g.comp (AddMonoidHom.snd M N)))","decl":"@[to_additive prodMap_def]\ntheorem prodMap_def : prodMap f g = (f.comp (fst M N)).prod (g.comp (snd M N)) :=\n  rfl\n\n"}
{"name":"MonoidHom.prodMap_def","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\nM' : Type u_6\nN' : Type u_7\ninst✝¹ : MulOneClass M'\ninst✝ : MulOneClass N'\nf : MonoidHom M M'\ng : MonoidHom N N'\n⊢ Eq (f.prodMap g) ((f.comp (MonoidHom.fst M N)).prod (g.comp (MonoidHom.snd M N)))","decl":"@[to_additive prodMap_def]\ntheorem prodMap_def : prodMap f g = (f.comp (fst M N)).prod (g.comp (snd M N)) :=\n  rfl\n\n"}
{"name":"MonoidHom.coe_prodMap","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\nM' : Type u_6\nN' : Type u_7\ninst✝¹ : MulOneClass M'\ninst✝ : MulOneClass N'\nf : MonoidHom M M'\ng : MonoidHom N N'\n⊢ Eq (⇑(f.prodMap g)) (Prod.map ⇑f ⇑g)","decl":"@[to_additive (attr := simp) coe_prodMap]\ntheorem coe_prodMap : ⇑(prodMap f g) = Prod.map f g :=\n  rfl\n\n"}
{"name":"AddMonoidHom.coe_prodMap","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\nM' : Type u_6\nN' : Type u_7\ninst✝¹ : AddZeroClass M'\ninst✝ : AddZeroClass N'\nf : AddMonoidHom M M'\ng : AddMonoidHom N N'\n⊢ Eq (⇑(f.prodMap g)) (Prod.map ⇑f ⇑g)","decl":"@[to_additive (attr := simp) coe_prodMap]\ntheorem coe_prodMap : ⇑(prodMap f g) = Prod.map f g :=\n  rfl\n\n"}
{"name":"MonoidHom.prod_comp_prodMap","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝⁴ : MulOneClass M\ninst✝³ : MulOneClass N\nM' : Type u_6\nN' : Type u_7\ninst✝² : MulOneClass M'\ninst✝¹ : MulOneClass N'\ninst✝ : MulOneClass P\nf : MonoidHom P M\ng : MonoidHom P N\nf' : MonoidHom M M'\ng' : MonoidHom N N'\n⊢ Eq ((f'.prodMap g').comp (f.prod g)) ((f'.comp f).prod (g'.comp g))","decl":"@[to_additive prod_comp_prodMap]\ntheorem prod_comp_prodMap (f : P →* M) (g : P →* N) (f' : M →* M') (g' : N →* N') :\n    (f'.prodMap g').comp (f.prod g) = (f'.comp f).prod (g'.comp g) :=\n  rfl\n\n"}
{"name":"AddMonoidHom.prod_comp_prodMap","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝⁴ : AddZeroClass M\ninst✝³ : AddZeroClass N\nM' : Type u_6\nN' : Type u_7\ninst✝² : AddZeroClass M'\ninst✝¹ : AddZeroClass N'\ninst✝ : AddZeroClass P\nf : AddMonoidHom P M\ng : AddMonoidHom P N\nf' : AddMonoidHom M M'\ng' : AddMonoidHom N N'\n⊢ Eq ((f'.prodMap g').comp (f.prod g)) ((f'.comp f).prod (g'.comp g))","decl":"@[to_additive prod_comp_prodMap]\ntheorem prod_comp_prodMap (f : P →* M) (g : P →* N) (f' : M →* M') (g' : N →* N') :\n    (f'.prodMap g').comp (f.prod g) = (f'.comp f).prod (g'.comp g) :=\n  rfl\n\n"}
{"name":"MonoidHom.coprod_apply","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : CommMonoid P\nf : MonoidHom M P\ng : MonoidHom N P\np : Prod M N\n⊢ Eq ((f.coprod g) p) (HMul.hMul (f p.1) (g p.2))","decl":"@[to_additive (attr := simp)]\ntheorem coprod_apply (p : M × N) : f.coprod g p = f p.1 * g p.2 :=\n  rfl\n\n"}
{"name":"AddMonoidHom.coprod_apply","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddCommMonoid P\nf : AddMonoidHom M P\ng : AddMonoidHom N P\np : Prod M N\n⊢ Eq ((f.coprod g) p) (HAdd.hAdd (f p.1) (g p.2))","decl":"@[to_additive (attr := simp)]\ntheorem coprod_apply (p : M × N) : f.coprod g p = f p.1 * g p.2 :=\n  rfl\n\n"}
{"name":"AddMonoidHom.coprod_comp_inl","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddCommMonoid P\nf : AddMonoidHom M P\ng : AddMonoidHom N P\n⊢ Eq ((f.coprod g).comp (AddMonoidHom.inl M N)) f","decl":"@[to_additive (attr := simp)]\ntheorem coprod_comp_inl : (f.coprod g).comp (inl M N) = f :=\n  ext fun x => by simp [coprod_apply]\n\n"}
{"name":"MonoidHom.coprod_comp_inl","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : CommMonoid P\nf : MonoidHom M P\ng : MonoidHom N P\n⊢ Eq ((f.coprod g).comp (MonoidHom.inl M N)) f","decl":"@[to_additive (attr := simp)]\ntheorem coprod_comp_inl : (f.coprod g).comp (inl M N) = f :=\n  ext fun x => by simp [coprod_apply]\n\n"}
{"name":"MonoidHom.coprod_comp_inr","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : CommMonoid P\nf : MonoidHom M P\ng : MonoidHom N P\n⊢ Eq ((f.coprod g).comp (MonoidHom.inr M N)) g","decl":"@[to_additive (attr := simp)]\ntheorem coprod_comp_inr : (f.coprod g).comp (inr M N) = g :=\n  ext fun x => by simp [coprod_apply]\n\n"}
{"name":"AddMonoidHom.coprod_comp_inr","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddCommMonoid P\nf : AddMonoidHom M P\ng : AddMonoidHom N P\n⊢ Eq ((f.coprod g).comp (AddMonoidHom.inr M N)) g","decl":"@[to_additive (attr := simp)]\ntheorem coprod_comp_inr : (f.coprod g).comp (inr M N) = g :=\n  ext fun x => by simp [coprod_apply]\n\n"}
{"name":"AddMonoidHom.coprod_unique","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddCommMonoid P\nf : AddMonoidHom (Prod M N) P\n⊢ Eq ((f.comp (AddMonoidHom.inl M N)).coprod (f.comp (AddMonoidHom.inr M N))) f","decl":"@[to_additive (attr := simp)]\ntheorem coprod_unique (f : M × N →* P) : (f.comp (inl M N)).coprod (f.comp (inr M N)) = f :=\n  ext fun x => by simp [coprod_apply, inl_apply, inr_apply, ← map_mul]\n\n"}
{"name":"MonoidHom.coprod_unique","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : CommMonoid P\nf : MonoidHom (Prod M N) P\n⊢ Eq ((f.comp (MonoidHom.inl M N)).coprod (f.comp (MonoidHom.inr M N))) f","decl":"@[to_additive (attr := simp)]\ntheorem coprod_unique (f : M × N →* P) : (f.comp (inl M N)).coprod (f.comp (inr M N)) = f :=\n  ext fun x => by simp [coprod_apply, inl_apply, inr_apply, ← map_mul]\n\n"}
{"name":"AddMonoidHom.coprod_inl_inr","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_6\nN : Type u_7\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\n⊢ Eq ((AddMonoidHom.inl M N).coprod (AddMonoidHom.inr M N)) (AddMonoidHom.id (Prod M N))","decl":"@[to_additive (attr := simp)]\ntheorem coprod_inl_inr {M N : Type*} [CommMonoid M] [CommMonoid N] :\n    (inl M N).coprod (inr M N) = id (M × N) :=\n  coprod_unique (id <| M × N)\n\n"}
{"name":"MonoidHom.coprod_inl_inr","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_6\nN : Type u_7\ninst✝¹ : CommMonoid M\ninst✝ : CommMonoid N\n⊢ Eq ((MonoidHom.inl M N).coprod (MonoidHom.inr M N)) (MonoidHom.id (Prod M N))","decl":"@[to_additive (attr := simp)]\ntheorem coprod_inl_inr {M N : Type*} [CommMonoid M] [CommMonoid N] :\n    (inl M N).coprod (inr M N) = id (M × N) :=\n  coprod_unique (id <| M × N)\n\n"}
{"name":"AddMonoidHom.comp_coprod","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\ninst✝¹ : AddCommMonoid P\nQ : Type u_6\ninst✝ : AddCommMonoid Q\nh : AddMonoidHom P Q\nf : AddMonoidHom M P\ng : AddMonoidHom N P\n⊢ Eq (h.comp (f.coprod g)) ((h.comp f).coprod (h.comp g))","decl":"@[to_additive]\ntheorem comp_coprod {Q : Type*} [CommMonoid Q] (h : P →* Q) (f : M →* P) (g : N →* P) :\n    h.comp (f.coprod g) = (h.comp f).coprod (h.comp g) :=\n  ext fun x => by simp\n\n"}
{"name":"MonoidHom.comp_coprod","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\ninst✝¹ : CommMonoid P\nQ : Type u_6\ninst✝ : CommMonoid Q\nh : MonoidHom P Q\nf : MonoidHom M P\ng : MonoidHom N P\n⊢ Eq (h.comp (f.coprod g)) ((h.comp f).coprod (h.comp g))","decl":"@[to_additive]\ntheorem comp_coprod {Q : Type*} [CommMonoid Q] (h : P →* Q) (f : M →* P) (g : N →* P) :\n    h.comp (f.coprod g) = (h.comp f).coprod (h.comp g) :=\n  ext fun x => by simp\n\n"}
{"name":"AddEquiv.coe_prodComm","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq (⇑AddEquiv.prodComm) Prod.swap","decl":"@[to_additive (attr := simp) coe_prodComm]\ntheorem coe_prodComm : ⇑(prodComm : M × N ≃* N × M) = Prod.swap :=\n  rfl\n\n"}
{"name":"MulEquiv.coe_prodComm","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq (⇑MulEquiv.prodComm) Prod.swap","decl":"@[to_additive (attr := simp) coe_prodComm]\ntheorem coe_prodComm : ⇑(prodComm : M × N ≃* N × M) = Prod.swap :=\n  rfl\n\n"}
{"name":"MulEquiv.coe_prodComm_symm","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq (⇑MulEquiv.prodComm.symm) Prod.swap","decl":"@[to_additive (attr := simp) coe_prodComm_symm]\ntheorem coe_prodComm_symm : ⇑(prodComm : M × N ≃* N × M).symm = Prod.swap :=\n  rfl\n\n"}
{"name":"AddEquiv.coe_prodComm_symm","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq (⇑AddEquiv.prodComm.symm) Prod.swap","decl":"@[to_additive (attr := simp) coe_prodComm_symm]\ntheorem coe_prodComm_symm : ⇑(prodComm : M × N ≃* N × M).symm = Prod.swap :=\n  rfl\n\n"}
{"name":"AddEquiv.coe_prodAssoc","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\n⊢ Eq ⇑AddEquiv.prodAssoc ⇑(Equiv.prodAssoc M N P)","decl":"@[to_additive (attr := simp) coe_prodAssoc]\ntheorem coe_prodAssoc : ⇑(prodAssoc : (M × N) × P ≃* M × (N × P)) = Equiv.prodAssoc M N P :=\n  rfl\n\n"}
{"name":"MulEquiv.coe_prodAssoc","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\n⊢ Eq ⇑MulEquiv.prodAssoc ⇑(Equiv.prodAssoc M N P)","decl":"@[to_additive (attr := simp) coe_prodAssoc]\ntheorem coe_prodAssoc : ⇑(prodAssoc : (M × N) × P ≃* M × (N × P)) = Equiv.prodAssoc M N P :=\n  rfl\n\n"}
{"name":"MulEquiv.coe_prodAssoc_symm","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\n⊢ Eq ⇑MulEquiv.prodAssoc.symm ⇑(Equiv.prodAssoc M N P).symm","decl":"@[to_additive (attr := simp) coe_prodAssoc_symm]\ntheorem coe_prodAssoc_symm :\n    ⇑(prodAssoc : (M × N) × P ≃* M × (N × P)).symm = (Equiv.prodAssoc M N P).symm :=\n  rfl\n\n"}
{"name":"AddEquiv.coe_prodAssoc_symm","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\nP : Type u_5\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\n⊢ Eq ⇑AddEquiv.prodAssoc.symm ⇑(Equiv.prodAssoc M N P).symm","decl":"@[to_additive (attr := simp) coe_prodAssoc_symm]\ntheorem coe_prodAssoc_symm :\n    ⇑(prodAssoc : (M × N) × P ≃* M × (N × P)).symm = (Equiv.prodAssoc M N P).symm :=\n  rfl\n\n"}
{"name":"AddEquiv.prodProdProdComm_apply","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\nM' : Type u_6\nN' : Type u_7\ninst✝¹ : AddZeroClass N'\ninst✝ : AddZeroClass M'\nmnmn : Prod (Prod M N) (Prod M' N')\n⊢ Eq ((AddEquiv.prodProdProdComm M N M' N') mnmn) { fst := { fst := mnmn.1.1, snd := mnmn.2.1 }, snd := { fst := mnmn.1.2, snd := mnmn.2.2 } }","decl":"/-- Four-way commutativity of `Prod`. The name matches `mul_mul_mul_comm`. -/\n@[to_additive (attr := simps apply) prodProdProdComm\n    \"Four-way commutativity of `Prod`.\\nThe name matches `mul_mul_mul_comm`\"]\ndef prodProdProdComm : (M × N) × M' × N' ≃* (M × M') × N × N' :=\n  { Equiv.prodProdProdComm M N M' N' with\n    toFun := fun mnmn => ((mnmn.1.1, mnmn.2.1), (mnmn.1.2, mnmn.2.2))\n    invFun := fun mmnn => ((mmnn.1.1, mmnn.2.1), (mmnn.1.2, mmnn.2.2))\n    map_mul' := fun _mnmn _mnmn' => rfl }\n\n"}
{"name":"MulEquiv.prodProdProdComm_apply","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\nM' : Type u_6\nN' : Type u_7\ninst✝¹ : MulOneClass N'\ninst✝ : MulOneClass M'\nmnmn : Prod (Prod M N) (Prod M' N')\n⊢ Eq ((MulEquiv.prodProdProdComm M N M' N') mnmn) { fst := { fst := mnmn.1.1, snd := mnmn.2.1 }, snd := { fst := mnmn.1.2, snd := mnmn.2.2 } }","decl":"/-- Four-way commutativity of `Prod`. The name matches `mul_mul_mul_comm`. -/\n@[to_additive (attr := simps apply) prodProdProdComm\n    \"Four-way commutativity of `Prod`.\\nThe name matches `mul_mul_mul_comm`\"]\ndef prodProdProdComm : (M × N) × M' × N' ≃* (M × M') × N × N' :=\n  { Equiv.prodProdProdComm M N M' N' with\n    toFun := fun mnmn => ((mnmn.1.1, mnmn.2.1), (mnmn.1.2, mnmn.2.2))\n    invFun := fun mmnn => ((mmnn.1.1, mmnn.2.1), (mmnn.1.2, mmnn.2.2))\n    map_mul' := fun _mnmn _mnmn' => rfl }\n\n"}
{"name":"AddEquiv.prodProdProdComm_toEquiv","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\nM' : Type u_6\nN' : Type u_7\ninst✝¹ : AddZeroClass N'\ninst✝ : AddZeroClass M'\n⊢ Eq (↑(AddEquiv.prodProdProdComm M N M' N')) (Equiv.prodProdProdComm M N M' N')","decl":"@[to_additive (attr := simp) prodProdProdComm_toEquiv]\ntheorem prodProdProdComm_toEquiv :\n    (prodProdProdComm M N M' N' : _ ≃ _) = Equiv.prodProdProdComm M N M' N' :=\n  rfl\n\n"}
{"name":"MulEquiv.prodProdProdComm_toEquiv","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\nM' : Type u_6\nN' : Type u_7\ninst✝¹ : MulOneClass N'\ninst✝ : MulOneClass M'\n⊢ Eq (↑(MulEquiv.prodProdProdComm M N M' N')) (Equiv.prodProdProdComm M N M' N')","decl":"@[to_additive (attr := simp) prodProdProdComm_toEquiv]\ntheorem prodProdProdComm_toEquiv :\n    (prodProdProdComm M N M' N' : _ ≃ _) = Equiv.prodProdProdComm M N M' N' :=\n  rfl\n\n"}
{"name":"MulEquiv.prodProdProdComm_symm","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\nM' : Type u_6\nN' : Type u_7\ninst✝¹ : MulOneClass N'\ninst✝ : MulOneClass M'\n⊢ Eq (MulEquiv.prodProdProdComm M N M' N').symm (MulEquiv.prodProdProdComm M M' N N')","decl":"@[simp]\ntheorem prodProdProdComm_symm : (prodProdProdComm M N M' N').symm = prodProdProdComm M M' N N' :=\n  rfl\n\n"}
{"name":"Prod.isAddUnit_iff","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nx : Prod M N\n⊢ Iff (IsAddUnit x) (And (IsAddUnit x.1) (IsAddUnit x.2))","decl":"@[to_additive]\nlemma _root_.Prod.isUnit_iff {x : M × N} : IsUnit x ↔ IsUnit x.1 ∧ IsUnit x.2 where\n  mp h := ⟨(prodUnits h.unit).1.isUnit, (prodUnits h.unit).2.isUnit⟩\n  mpr h := (prodUnits.symm (h.1.unit, h.2.unit)).isUnit\n\n"}
{"name":"Prod.isUnit_iff","module":"Mathlib.Algebra.Group.Prod","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nx : Prod M N\n⊢ Iff (IsUnit x) (And (IsUnit x.1) (IsUnit x.2))","decl":"@[to_additive]\nlemma _root_.Prod.isUnit_iff {x : M × N} : IsUnit x ↔ IsUnit x.1 ∧ IsUnit x.2 where\n  mp h := ⟨(prodUnits h.unit).1.isUnit, (prodUnits h.unit).2.isUnit⟩\n  mpr h := (prodUnits.symm (h.1.unit, h.2.unit)).isUnit\n\n"}
{"name":"Units.embedProduct_apply","module":"Mathlib.Algebra.Group.Prod","initialProofState":"α : Type u_6\ninst✝ : Monoid α\nx : Units α\n⊢ Eq ((Units.embedProduct α) x) { fst := ↑x, snd := MulOpposite.op ↑(Inv.inv x) }","decl":"/-- Canonical homomorphism of monoids from `αˣ` into `α × αᵐᵒᵖ`.\nUsed mainly to define the natural topology of `αˣ`. -/\n@[to_additive (attr := simps)\n      \"Canonical homomorphism of additive monoids from `AddUnits α` into `α × αᵃᵒᵖ`.\n      Used mainly to define the natural topology of `AddUnits α`.\"]\ndef embedProduct (α : Type*) [Monoid α] : αˣ →* α × αᵐᵒᵖ where\n  toFun x := ⟨x, op ↑x⁻¹⟩\n  map_one' := by\n    simp only [inv_one, eq_self_iff_true, Units.val_one, op_one, Prod.mk_eq_one, and_self_iff]\n  map_mul' x y := by simp only [mul_inv_rev, op_mul, Units.val_mul, Prod.mk_mul_mk]\n\n"}
{"name":"AddUnits.embedProduct_apply","module":"Mathlib.Algebra.Group.Prod","initialProofState":"α : Type u_6\ninst✝ : AddMonoid α\nx : AddUnits α\n⊢ Eq ((AddUnits.embedProduct α) x) { fst := ↑x, snd := AddOpposite.op ↑(Neg.neg x) }","decl":"/-- Canonical homomorphism of monoids from `αˣ` into `α × αᵐᵒᵖ`.\nUsed mainly to define the natural topology of `αˣ`. -/\n@[to_additive (attr := simps)\n      \"Canonical homomorphism of additive monoids from `AddUnits α` into `α × αᵃᵒᵖ`.\n      Used mainly to define the natural topology of `AddUnits α`.\"]\ndef embedProduct (α : Type*) [Monoid α] : αˣ →* α × αᵐᵒᵖ where\n  toFun x := ⟨x, op ↑x⁻¹⟩\n  map_one' := by\n    simp only [inv_one, eq_self_iff_true, Units.val_one, op_one, Prod.mk_eq_one, and_self_iff]\n  map_mul' x y := by simp only [mul_inv_rev, op_mul, Units.val_mul, Prod.mk_mul_mk]\n\n"}
{"name":"Units.embedProduct_injective","module":"Mathlib.Algebra.Group.Prod","initialProofState":"α : Type u_6\ninst✝ : Monoid α\n⊢ Function.Injective ⇑(Units.embedProduct α)","decl":"@[to_additive]\ntheorem embedProduct_injective (α : Type*) [Monoid α] : Function.Injective (embedProduct α) :=\n  fun _ _ h => Units.ext <| (congr_arg Prod.fst h :)\n\n"}
{"name":"AddUnits.embedProduct_injective","module":"Mathlib.Algebra.Group.Prod","initialProofState":"α : Type u_6\ninst✝ : AddMonoid α\n⊢ Function.Injective ⇑(AddUnits.embedProduct α)","decl":"@[to_additive]\ntheorem embedProduct_injective (α : Type*) [Monoid α] : Function.Injective (embedProduct α) :=\n  fun _ _ h => Units.ext <| (congr_arg Prod.fst h :)\n\n"}
{"name":"mulMulHom_apply","module":"Mathlib.Algebra.Group.Prod","initialProofState":"α : Type u_6\ninst✝ : CommSemigroup α\na : Prod α α\n⊢ Eq (mulMulHom a) (HMul.hMul a.1 a.2)","decl":"/-- Multiplication as a multiplicative homomorphism. -/\n@[to_additive (attr := simps) \"Addition as an additive homomorphism.\"]\ndef mulMulHom [CommSemigroup α] :\n    α × α →ₙ* α where\n  toFun a := a.1 * a.2\n  map_mul' _ _ := mul_mul_mul_comm _ _ _ _\n\n"}
{"name":"addAddHom_apply","module":"Mathlib.Algebra.Group.Prod","initialProofState":"α : Type u_6\ninst✝ : AddCommSemigroup α\na : Prod α α\n⊢ Eq (addAddHom a) (HAdd.hAdd a.1 a.2)","decl":"/-- Multiplication as a multiplicative homomorphism. -/\n@[to_additive (attr := simps) \"Addition as an additive homomorphism.\"]\ndef mulMulHom [CommSemigroup α] :\n    α × α →ₙ* α where\n  toFun a := a.1 * a.2\n  map_mul' _ _ := mul_mul_mul_comm _ _ _ _\n\n"}
{"name":"addAddMonoidHom_apply","module":"Mathlib.Algebra.Group.Prod","initialProofState":"α : Type u_6\ninst✝ : AddCommMonoid α\na✝ : Prod α α\n⊢ Eq (addAddMonoidHom a✝) (addAddHom.toFun a✝)","decl":"/-- Multiplication as a monoid homomorphism. -/\n@[to_additive (attr := simps) \"Addition as an additive monoid homomorphism.\"]\ndef mulMonoidHom [CommMonoid α] : α × α →* α :=\n  { mulMulHom with map_one' := mul_one _ }\n\n"}
{"name":"mulMonoidHom_apply","module":"Mathlib.Algebra.Group.Prod","initialProofState":"α : Type u_6\ninst✝ : CommMonoid α\na✝ : Prod α α\n⊢ Eq (mulMonoidHom a✝) (mulMulHom.toFun a✝)","decl":"/-- Multiplication as a monoid homomorphism. -/\n@[to_additive (attr := simps) \"Addition as an additive monoid homomorphism.\"]\ndef mulMonoidHom [CommMonoid α] : α × α →* α :=\n  { mulMulHom with map_one' := mul_one _ }\n\n"}
{"name":"divMonoidHom_apply","module":"Mathlib.Algebra.Group.Prod","initialProofState":"α : Type u_6\ninst✝ : DivisionCommMonoid α\na : Prod α α\n⊢ Eq (divMonoidHom a) (HDiv.hDiv a.1 a.2)","decl":"/-- Division as a monoid homomorphism. -/\n@[to_additive (attr := simps) \"Subtraction as an additive monoid homomorphism.\"]\ndef divMonoidHom [DivisionCommMonoid α] : α × α →* α where\n  toFun a := a.1 / a.2\n  map_one' := div_one _\n  map_mul' _ _ := mul_div_mul_comm _ _ _ _\n\n"}
{"name":"subAddMonoidHom_apply","module":"Mathlib.Algebra.Group.Prod","initialProofState":"α : Type u_6\ninst✝ : SubtractionCommMonoid α\na : Prod α α\n⊢ Eq (subAddMonoidHom a) (HSub.hSub a.1 a.2)","decl":"/-- Division as a monoid homomorphism. -/\n@[to_additive (attr := simps) \"Subtraction as an additive monoid homomorphism.\"]\ndef divMonoidHom [DivisionCommMonoid α] : α × α →* α where\n  toFun a := a.1 / a.2\n  map_one' := div_one _\n  map_mul' _ _ := mul_div_mul_comm _ _ _ _\n\n"}
