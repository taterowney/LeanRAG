{"name":"FirstOrder.Language.PartialEquiv.mk.injEq","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\ndom✝ : L.Substructure M\ncod✝ : L.Substructure N\ntoEquiv✝ : L.Equiv (Subtype fun x => Membership.mem dom✝ x) (Subtype fun x => Membership.mem cod✝ x)\ndom : L.Substructure M\ncod : L.Substructure N\ntoEquiv : L.Equiv (Subtype fun x => Membership.mem dom x) (Subtype fun x => Membership.mem cod x)\n⊢ Eq (Eq { dom := dom✝, cod := cod✝, toEquiv := toEquiv✝ } { dom := dom, cod := cod, toEquiv := toEquiv }) (And (Eq dom✝ dom) (And (Eq cod✝ cod) (HEq toEquiv✝ toEquiv)))","decl":"/-- A partial `L`-equivalence, implemented as an equivalence between substructures. -/\nstructure PartialEquiv where\n  /-- The substructure which is the domain of the equivalence. -/\n  dom : L.Substructure M\n  /-- The substructure which is the codomain of the equivalence. -/\n  cod : L.Substructure N\n  /-- The equivalence between the two subdomains. -/\n  toEquiv : dom ≃[L] cod\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.mk.sizeOf_spec","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝³ : L.Structure M\ninst✝² : L.Structure N\ninst✝¹ : SizeOf M\ninst✝ : SizeOf N\ndom : L.Substructure M\ncod : L.Substructure N\ntoEquiv : L.Equiv (Subtype fun x => Membership.mem dom x) (Subtype fun x => Membership.mem cod x)\n⊢ Eq (SizeOf.sizeOf { dom := dom, cod := cod, toEquiv := toEquiv }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf dom)) (SizeOf.sizeOf cod)) (SizeOf.sizeOf toEquiv))","decl":"/-- A partial `L`-equivalence, implemented as an equivalence between substructures. -/\nstructure PartialEquiv where\n  /-- The substructure which is the domain of the equivalence. -/\n  dom : L.Substructure M\n  /-- The substructure which is the codomain of the equivalence. -/\n  cod : L.Substructure N\n  /-- The equivalence between the two subdomains. -/\n  toEquiv : dom ≃[L] cod\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.mk.inj","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\ndom✝ : L.Substructure M\ncod✝ : L.Substructure N\ntoEquiv✝ : L.Equiv (Subtype fun x => Membership.mem dom✝ x) (Subtype fun x => Membership.mem cod✝ x)\ndom : L.Substructure M\ncod : L.Substructure N\ntoEquiv : L.Equiv (Subtype fun x => Membership.mem dom x) (Subtype fun x => Membership.mem cod x)\nx✝ : Eq { dom := dom✝, cod := cod✝, toEquiv := toEquiv✝ } { dom := dom, cod := cod, toEquiv := toEquiv }\n⊢ And (Eq dom✝ dom) (And (Eq cod✝ cod) (HEq toEquiv✝ toEquiv))","decl":"/-- A partial `L`-equivalence, implemented as an equivalence between substructures. -/\nstructure PartialEquiv where\n  /-- The substructure which is the domain of the equivalence. -/\n  dom : L.Substructure M\n  /-- The substructure which is the codomain of the equivalence. -/\n  cod : L.Substructure N\n  /-- The equivalence between the two subdomains. -/\n  toEquiv : dom ≃[L] cod\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.symm_symm","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.PartialEquiv M N\n⊢ Eq f.symm.symm f","decl":"@[simp]\ntheorem symm_symm (f : M ≃ₚ[L] N) : f.symm.symm = f :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.symm_apply","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.PartialEquiv M N\nx : Subtype fun x => Membership.mem f.cod x\n⊢ Eq (f.symm.toEquiv x) (f.toEquiv.symm x)","decl":"@[simp]\ntheorem symm_apply (f : M ≃ₚ[L] N) (x : f.cod) : f.symm.toEquiv x = f.toEquiv.symm x :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.le_def","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf g : L.PartialEquiv M N\n⊢ Iff (LE.le f g) (Exists fun h => Eq (g.cod.subtype.comp (g.toEquiv.toEmbedding.comp (FirstOrder.Language.Substructure.inclusion h))) (f.cod.subtype.comp f.toEquiv.toEmbedding))","decl":"theorem le_def (f g : M ≃ₚ[L] N) : f ≤ g ↔ ∃ h : f.dom ≤ g.dom,\n    (subtype _).comp (g.toEquiv.toEmbedding.comp (Substructure.inclusion h)) =\n      (subtype _).comp f.toEquiv.toEmbedding :=\n  Iff.rfl\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.dom_le_dom","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf g : L.PartialEquiv M N\na✝ : LE.le f g\n⊢ LE.le f.dom g.dom","decl":"@[gcongr] theorem dom_le_dom {f g : M ≃ₚ[L] N} : f ≤ g → f.dom ≤ g.dom := fun ⟨le, _⟩ ↦ le\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.cod_le_cod","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf g : L.PartialEquiv M N\na✝ : LE.le f g\n⊢ LE.le f.cod g.cod","decl":"@[gcongr] theorem cod_le_cod {f g : M ≃ₚ[L] N} : f ≤ g → f.cod ≤ g.cod := by\n  rintro ⟨_, eq_fun⟩ n hn\n  let m := f.toEquiv.symm ⟨n, hn⟩\n  have  : ((subtype _).comp f.toEquiv.toEmbedding) m = n := by simp only [m, Embedding.comp_apply,\n    Equiv.coe_toEmbedding, Equiv.apply_symm_apply, coeSubtype]\n  rw [← this, ← eq_fun]\n  simp only [Embedding.comp_apply, coe_inclusion, Equiv.coe_toEmbedding, coeSubtype,\n    SetLike.coe_mem]\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.subtype_toEquiv_inclusion","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf g : L.PartialEquiv M N\nh : LE.le f g\n⊢ Eq (g.cod.subtype.comp (g.toEquiv.toEmbedding.comp (FirstOrder.Language.Substructure.inclusion ⋯))) (f.cod.subtype.comp f.toEquiv.toEmbedding)","decl":"theorem subtype_toEquiv_inclusion {f g : M ≃ₚ[L] N} (h : f ≤ g) :\n    (subtype _).comp (g.toEquiv.toEmbedding.comp (Substructure.inclusion (dom_le_dom h))) =\n      (subtype _).comp f.toEquiv.toEmbedding := by\n  let ⟨_, eq⟩ := h; exact eq\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.toEquiv_inclusion","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf g : L.PartialEquiv M N\nh : LE.le f g\n⊢ Eq (g.toEquiv.toEmbedding.comp (FirstOrder.Language.Substructure.inclusion ⋯)) ((FirstOrder.Language.Substructure.inclusion ⋯).comp f.toEquiv.toEmbedding)","decl":"theorem toEquiv_inclusion {f g : M ≃ₚ[L] N} (h : f ≤ g) :\n    g.toEquiv.toEmbedding.comp (Substructure.inclusion (dom_le_dom h)) =\n      (Substructure.inclusion (cod_le_cod h)).comp f.toEquiv.toEmbedding := by\n  rw [← (subtype _).comp_inj, subtype_toEquiv_inclusion h]\n  ext\n  simp\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.toEquiv_inclusion_apply","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf g : L.PartialEquiv M N\nh : LE.le f g\nx : Subtype fun x => Membership.mem f.dom x\n⊢ Eq (g.toEquiv ((FirstOrder.Language.Substructure.inclusion ⋯) x)) ((FirstOrder.Language.Substructure.inclusion ⋯) (f.toEquiv x))","decl":"theorem toEquiv_inclusion_apply {f g : M ≃ₚ[L] N} (h : f ≤ g) (x : f.dom) :\n    g.toEquiv (Substructure.inclusion (dom_le_dom h) x) =\n      Substructure.inclusion (cod_le_cod h) (f.toEquiv x) := by\n  apply (subtype _).injective\n  change (subtype _).comp (g.toEquiv.toEmbedding.comp (inclusion _)) x = _\n  rw [subtype_toEquiv_inclusion h]\n  simp\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.le_iff","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf g : L.PartialEquiv M N\n⊢ Iff (LE.le f g) (Exists fun dom_le_dom => Exists fun cod_le_cod => ∀ (x : Subtype fun x => Membership.mem f.dom x), Eq ((FirstOrder.Language.Substructure.inclusion cod_le_cod) (f.toEquiv x)) (g.toEquiv ((FirstOrder.Language.Substructure.inclusion dom_le_dom) x)))","decl":"theorem le_iff {f g : M ≃ₚ[L] N} : f ≤ g ↔\n    ∃ dom_le_dom : f.dom ≤ g.dom,\n    ∃ cod_le_cod : f.cod ≤ g.cod,\n    ∀ x, inclusion cod_le_cod (f.toEquiv x) = g.toEquiv (inclusion dom_le_dom x) := by\n  constructor\n  · exact fun h ↦ ⟨dom_le_dom h, cod_le_cod h,\n      by intro x; apply (subtype _).inj'; rwa [toEquiv_inclusion_apply]⟩\n  · rintro ⟨dom_le_dom, le_cod, h_eq⟩\n    rw [le_def]\n    exact ⟨dom_le_dom, by ext; change subtype _ (g.toEquiv _) = _; rw [← h_eq]; rfl⟩\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.le_trans","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf g h : L.PartialEquiv M N\na✝¹ : LE.le f g\na✝ : LE.le g h\n⊢ LE.le f h","decl":"theorem le_trans (f g h : M ≃ₚ[L] N) : f ≤ g → g ≤ h → f ≤ h := by\n  rintro ⟨le_fg, eq_fg⟩ ⟨le_gh, eq_gh⟩\n  refine ⟨le_fg.trans le_gh, ?_⟩\n  rw [← eq_fg, ← Embedding.comp_assoc (g := g.toEquiv.toEmbedding), ← eq_gh]\n  ext\n  simp\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.symm_le_symm","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf g : L.PartialEquiv M N\nhfg : LE.le f g\n⊢ LE.le f.symm g.symm","decl":"@[gcongr] lemma symm_le_symm {f g : M ≃ₚ[L] N} (hfg : f ≤ g) : f.symm ≤ g.symm := by\n  rw [le_iff]\n  refine ⟨cod_le_cod hfg, dom_le_dom hfg, ?_⟩\n  intro x\n  apply g.toEquiv.injective\n  change g.toEquiv (inclusion _ (f.toEquiv.symm x)) = g.toEquiv (g.toEquiv.symm _)\n  rw [g.toEquiv.apply_symm_apply, (Equiv.apply_symm_apply f.toEquiv x).symm,\n    f.toEquiv.symm_apply_apply]\n  exact toEquiv_inclusion_apply hfg _\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.monotone_symm","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\n⊢ Monotone fun f => f.symm","decl":"theorem monotone_symm : Monotone (fun (f : M ≃ₚ[L] N) ↦ f.symm) := fun _ _ => symm_le_symm\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.symm_le_iff","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.PartialEquiv M N\ng : L.PartialEquiv N M\n⊢ Iff (LE.le f.symm g) (LE.le f g.symm)","decl":"theorem symm_le_iff {f : M ≃ₚ[L] N} {g : N ≃ₚ[L] M} : f.symm ≤ g ↔ f ≤ g.symm :=\n  ⟨by intro h; rw [← f.symm_symm]; exact monotone_symm h,\n    by intro h; rw  [← g.symm_symm]; exact monotone_symm h⟩\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.ext","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf g : L.PartialEquiv M N\nh_dom : Eq f.dom g.dom\na✝ : ∀ (x : M) (h : Membership.mem f.dom x), Eq (f.cod.subtype (f.toEquiv ⟨x, h⟩)) (g.cod.subtype (g.toEquiv ⟨x, ⋯⟩))\n⊢ Eq f g","decl":"theorem ext {f g : M ≃ₚ[L] N} (h_dom : f.dom = g.dom) : (∀ x : M, ∀ h : x ∈ f.dom,\n    subtype _ (f.toEquiv ⟨x, h⟩) = subtype _ (g.toEquiv ⟨x, (h_dom ▸ h)⟩)) → f = g := by\n  intro h\n  rcases f with ⟨dom_f, cod_f, equiv_f⟩\n  cases h_dom\n  apply le_antisymm <;> (rw [le_def]; use le_rfl; ext ⟨x, hx⟩)\n  · exact (h x hx).symm\n  · exact h x hx\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.ext_iff","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf g : L.PartialEquiv M N\n⊢ Iff (Eq f g) (Exists fun h_dom => ∀ (x : M) (h : Membership.mem f.dom x), Eq (f.cod.subtype (f.toEquiv ⟨x, h⟩)) (g.cod.subtype (g.toEquiv ⟨x, ⋯⟩)))","decl":"theorem ext_iff {f g : M ≃ₚ[L] N} : f = g ↔ ∃ h_dom : f.dom = g.dom,\n    ∀ x : M, ∀ h : x ∈ f.dom,\n    subtype _ (f.toEquiv ⟨x, h⟩) = subtype _ (g.toEquiv ⟨x, (h_dom ▸ h)⟩) := by\n  constructor\n  · intro h_eq\n    rcases f with ⟨dom_f, cod_f, equiv_f⟩\n    cases h_eq\n    exact ⟨rfl, fun _ _ ↦ rfl⟩\n  · rintro ⟨h, H⟩; exact ext h H\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.monotone_dom","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\n⊢ Monotone fun f => f.dom","decl":"theorem monotone_dom : Monotone (fun f : M ≃ₚ[L] N ↦ f.dom) := fun _ _ ↦ dom_le_dom\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.monotone_cod","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\n⊢ Monotone fun f => f.cod","decl":"theorem monotone_cod : Monotone (fun f : M ≃ₚ[L] N ↦ f.cod) := fun _ _ ↦ cod_le_cod\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.domRestrict_le","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.PartialEquiv M N\nA : L.Substructure M\nh : LE.le A f.dom\n⊢ LE.le (f.domRestrict h) f","decl":"theorem domRestrict_le (f : M ≃ₚ[L] N) {A : L.Substructure M} (h : A ≤ f.dom) :\n    f.domRestrict h ≤ f := ⟨h, rfl⟩\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.le_domRestrict","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf g : L.PartialEquiv M N\nA : L.Substructure M\nhf : LE.le f.dom A\nhg : LE.le A g.dom\nhfg : LE.le f g\n⊢ LE.le f (g.domRestrict hg)","decl":"theorem le_domRestrict (f g : M ≃ₚ[L] N) {A : L.Substructure M} (hf : f.dom ≤ A)\n    (hg : A ≤ g.dom) (hfg : f ≤ g) : f ≤ g.domRestrict hg :=\n  ⟨hf, by rw [← (subtype_toEquiv_inclusion hfg)]; rfl⟩\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.codRestrict_le","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.PartialEquiv M N\nA : L.Substructure N\nh : LE.le A f.cod\n⊢ LE.le (f.codRestrict h) f","decl":"theorem codRestrict_le (f : M ≃ₚ[L] N) {A : L.Substructure N} (h : A ≤ f.cod) :\n    codRestrict f h ≤ f :=\n  symm_le_iff.2 (f.symm.domRestrict_le h)\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.le_codRestrict","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf g : L.PartialEquiv M N\nA : L.Substructure N\nhf : LE.le f.cod A\nhg : LE.le A g.cod\nhfg : LE.le f g\n⊢ LE.le f (g.codRestrict hg)","decl":"theorem le_codRestrict (f g : M ≃ₚ[L] N) {A : L.Substructure N} (hf : f.cod ≤ A)\n    (hg : A ≤ g.cod) (hfg : f ≤ g) : f ≤ g.codRestrict hg :=\n  symm_le_iff.1 (le_domRestrict f.symm g.symm hf hg (monotone_symm hfg))\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.toEmbedding_apply","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.PartialEquiv M N\nm : Subtype fun x => Membership.mem f.dom x\n⊢ Eq (f.toEmbedding m) ↑(f.toEquiv m)","decl":"@[simp]\ntheorem toEmbedding_apply {f : M ≃ₚ[L] N} (m : f.dom) :\n    f.toEmbedding m = f.toEquiv m :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.toEmbeddingOfEqTop__apply","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.PartialEquiv M N\nh : Eq f.dom Top.top\nm : M\n⊢ Eq ((FirstOrder.Language.PartialEquiv.toEmbeddingOfEqTop h) m) ↑(f.toEquiv ⟨m, ⋯⟩)","decl":"@[simp]\ntheorem toEmbeddingOfEqTop__apply {f : M ≃ₚ[L] N} (h : f.dom = ⊤) (m : M) :\n    toEmbeddingOfEqTop h m = f.toEquiv ⟨m, h.symm ▸ mem_top m⟩ := by\n  rcases f with ⟨dom, cod, g⟩\n  cases h\n  rfl\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.toEquivOfEqTop_toEmbedding","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.PartialEquiv M N\nh_dom : Eq f.dom Top.top\nh_cod : Eq f.cod Top.top\n⊢ Eq (FirstOrder.Language.PartialEquiv.toEquivOfEqTop h_dom h_cod).toEmbedding (FirstOrder.Language.PartialEquiv.toEmbeddingOfEqTop h_dom)","decl":"@[simp]\ntheorem toEquivOfEqTop_toEmbedding {f : M ≃ₚ[L] N} (h_dom : f.dom = ⊤)\n    (h_cod : f.cod = ⊤) :\n    (toEquivOfEqTop h_dom h_cod).toEmbedding = toEmbeddingOfEqTop h_dom := by\n  rcases f with ⟨dom, cod, g⟩\n  cases h_dom\n  cases h_cod\n  rfl\n\n"}
{"name":"FirstOrder.Language.PartialEquiv.dom_fg_iff_cod_fg","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\nN : Type u_1\ninst✝ : L.Structure N\nf : L.PartialEquiv M N\n⊢ Iff f.dom.FG f.cod.FG","decl":"theorem dom_fg_iff_cod_fg {N : Type*} [L.Structure N] (f : M ≃ₚ[L] N) :\n    f.dom.FG ↔ f.cod.FG := by\n  rw [Substructure.fg_iff_structure_fg, f.toEquiv.fg_iff, Substructure.fg_iff_structure_fg]\n\n"}
{"name":"FirstOrder.Language.Embedding.toPartialEquiv_injective","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\n⊢ Function.Injective fun f => f.toPartialEquiv","decl":"theorem toPartialEquiv_injective :\n    Function.Injective (fun f : M ↪[L] N ↦ f.toPartialEquiv) := by\n  intro _ _ h\n  ext\n  rw [PartialEquiv.ext_iff] at h\n  rcases h with ⟨_, H⟩\n  exact H _ (Substructure.mem_top _)\n\n"}
{"name":"FirstOrder.Language.Embedding.toEmbedding_toPartialEquiv","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Embedding M N\n⊢ Eq (FirstOrder.Language.PartialEquiv.toEmbeddingOfEqTop ⋯) f","decl":"@[simp]\ntheorem toEmbedding_toPartialEquiv (f : M ↪[L] N) :\n    PartialEquiv.toEmbeddingOfEqTop (f := f.toPartialEquiv) rfl = f :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Embedding.toPartialEquiv_toEmbedding","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.PartialEquiv M N\nh : Eq f.dom Top.top\n⊢ Eq (FirstOrder.Language.PartialEquiv.toEmbeddingOfEqTop h).toPartialEquiv f","decl":"@[simp]\ntheorem toPartialEquiv_toEmbedding {f :  M ≃ₚ[L] N} (h : f.dom = ⊤) :\n    (PartialEquiv.toEmbeddingOfEqTop h).toPartialEquiv = f := by\n  rcases f with ⟨_, _, _⟩\n  cases h\n  apply PartialEquiv.ext\n  · intro _ _\n    rfl\n  · rfl\n\n"}
{"name":"FirstOrder.Language.DirectLimit.instDirectedSystemSubtypeMemSubstructureDomCoeOrderHomPartialEquivEmbeddingInclusion","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\nι : Type u_1\ninst✝ : Preorder ι\nS : OrderHom ι (L.PartialEquiv M N)\n⊢ DirectedSystem (fun i => Subtype fun x => Membership.mem (S i).dom x) fun x x_1 h => ⇑(FirstOrder.Language.Substructure.inclusion ⋯)","decl":"instance : DirectedSystem (fun i ↦ (S i).dom)\n    (fun _ _ h ↦ Substructure.inclusion (dom_le_dom (S.monotone h))) where\n  map_self _ _ := rfl\n  map_map _ _ _ _ _ _ := rfl\n\n"}
{"name":"FirstOrder.Language.DirectLimit.instDirectedSystemSubtypeMemSubstructureCodCoeOrderHomPartialEquivEmbeddingInclusion","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\nι : Type u_1\ninst✝ : Preorder ι\nS : OrderHom ι (L.PartialEquiv M N)\n⊢ DirectedSystem (fun i => Subtype fun x => Membership.mem (S i).cod x) fun x x_1 h => ⇑(FirstOrder.Language.Substructure.inclusion ⋯)","decl":"instance : DirectedSystem (fun i ↦ (S i).cod)\n    (fun _ _ h ↦ Substructure.inclusion (cod_le_cod (S.monotone h))) where\n  map_self _ _ := rfl\n  map_map _ _ _ _ _ _ := rfl\n\n"}
{"name":"FirstOrder.Language.DirectLimit.dom_partialEquivLimit","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝⁴ : L.Structure M\ninst✝³ : L.Structure N\nι : Type u_1\ninst✝² : Preorder ι\ninst✝¹ : Nonempty ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nS : OrderHom ι (L.PartialEquiv M N)\n⊢ Eq (FirstOrder.Language.DirectLimit.partialEquivLimit S).dom (iSup fun x => (S x).dom)","decl":"@[simp]\ntheorem dom_partialEquivLimit : (partialEquivLimit S).dom = iSup (fun x ↦ (S x).dom) := rfl\n\n"}
{"name":"FirstOrder.Language.DirectLimit.cod_partialEquivLimit","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝⁴ : L.Structure M\ninst✝³ : L.Structure N\nι : Type u_1\ninst✝² : Preorder ι\ninst✝¹ : Nonempty ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nS : OrderHom ι (L.PartialEquiv M N)\n⊢ Eq (FirstOrder.Language.DirectLimit.partialEquivLimit S).cod (iSup fun x => (S x).cod)","decl":"@[simp]\ntheorem cod_partialEquivLimit : (partialEquivLimit S).cod = iSup (fun x ↦ (S x).cod) := rfl\n\n"}
{"name":"FirstOrder.Language.DirectLimit.partialEquivLimit_comp_inclusion","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝⁴ : L.Structure M\ninst✝³ : L.Structure N\nι : Type u_1\ninst✝² : Preorder ι\ninst✝¹ : Nonempty ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nS : OrderHom ι (L.PartialEquiv M N)\ni : ι\n⊢ Eq ((FirstOrder.Language.DirectLimit.partialEquivLimit S).toEquiv.toEmbedding.comp (FirstOrder.Language.Substructure.inclusion ⋯)) ((FirstOrder.Language.Substructure.inclusion ⋯).comp (S i).toEquiv.toEmbedding)","decl":"@[simp]\nlemma partialEquivLimit_comp_inclusion {i : ι} :\n    (partialEquivLimit S).toEquiv.toEmbedding.comp (Substructure.inclusion (le_iSup _ i)) =\n    (Substructure.inclusion (le_iSup _ i)).comp (S i).toEquiv.toEmbedding := by\n  simp only [partialEquivLimit, Equiv.comp_toEmbedding, Embedding.comp_assoc]\n  rw [Equiv_isup_symm_inclusion]\n  congr\n\n"}
{"name":"FirstOrder.Language.DirectLimit.le_partialEquivLimit","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝⁴ : L.Structure M\ninst✝³ : L.Structure N\nι : Type u_1\ninst✝² : Preorder ι\ninst✝¹ : Nonempty ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nS : OrderHom ι (L.PartialEquiv M N)\ni : ι\n⊢ LE.le (S i) (FirstOrder.Language.DirectLimit.partialEquivLimit S)","decl":"theorem le_partialEquivLimit (i : ι) : S i ≤ partialEquivLimit S :=\n  ⟨le_iSup (f := fun i ↦ (S i).dom) _, by\n    #adaptation_note /-- https://github.com/leanprover/lean4/pull/5020\n    these two `simp` calls cannot be combined. -/\n    simp only [partialEquivLimit_comp_inclusion]\n    simp only [cod_partialEquivLimit, dom_partialEquivLimit, ← Embedding.comp_assoc,\n      subtype_comp_inclusion]⟩\n\n"}
{"name":"FirstOrder.Language.countable_self_fgequiv_of_countable","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\ninst✝ : Countable M\n⊢ Countable (L.FGEquiv M M)","decl":"theorem countable_self_fgequiv_of_countable [Countable M] :\n    Countable (L.FGEquiv M M) := by\n  let g : L.FGEquiv M M →\n      Σ U : { S : L.Substructure M // S.FG }, U.val →[L] M :=\n    fun f ↦ ⟨⟨f.val.dom, f.prop⟩, (subtype _).toHom.comp f.val.toEquiv.toHom⟩\n  have g_inj : Function.Injective g := by\n    intro f f' h\n    ext\n    let ⟨⟨dom_f, cod_f, equiv_f⟩, f_fin⟩ := f\n    cases congr_arg (·.1) h\n    apply PartialEquiv.ext (by rfl)\n    simp only [g, Sigma.mk.inj_iff, heq_eq_eq, true_and] at h\n    exact fun x hx ↦ congr_fun (congr_arg (↑) h) ⟨x, hx⟩\n  have : ∀ U : { S : L.Substructure M // S.FG }, Structure.FG L U.val :=\n    fun U ↦ (U.val.fg_iff_structure_fg.1 U.prop)\n  exact Function.Embedding.countable ⟨g, g_inj⟩\n\n"}
{"name":"FirstOrder.Language.FGEquiv.symm_coe","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.FGEquiv M N\n⊢ Eq (↑f.symm) (↑f).symm","decl":"/-- Maps to the symmetric finitely-generated partial equivalence. -/\n@[simps]\ndef FGEquiv.symm (f : L.FGEquiv M N) : L.FGEquiv N M := ⟨f.1.symm, f.1.dom_fg_iff_cod_fg.1 f.2⟩\n\n"}
{"name":"FirstOrder.Language.isExtensionPair_iff_cod","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\n⊢ Iff (L.IsExtensionPair M N) (∀ (f : L.FGEquiv N M) (m : M), Exists fun g => And (Membership.mem (↑g).cod m) (LE.le f g))","decl":"lemma isExtensionPair_iff_cod : L.IsExtensionPair M N ↔\n    ∀ (f : L.FGEquiv N M) (m : M), ∃ g, m ∈ g.1.cod ∧ f ≤ g := by\n  refine Iff.intro ?_ ?_ <;>\n  · intro h f m\n    obtain ⟨g, h1, h2⟩ := h f.symm m\n    exact ⟨g.symm, h1, monotone_symm h2⟩\n\n"}
{"name":"FirstOrder.Language.isExtensionPair_iff_exists_embedding_closure_singleton_sup","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\n⊢ Iff (L.IsExtensionPair M N) (∀ (S : L.Substructure M), S.FG → ∀ (f : L.Embedding (Subtype fun x => Membership.mem S x) N) (m : M), Exists fun g => Eq f (g.comp (FirstOrder.Language.Substructure.inclusion ⋯)))","decl":"/-- An alternate characterization of an extension pair is that every finitely generated partial\nisomorphism can be extended to include any particular element of the domain. -/\ntheorem isExtensionPair_iff_exists_embedding_closure_singleton_sup :\n    L.IsExtensionPair M N ↔\n    ∀ (S : L.Substructure M) (_ : S.FG) (f : S ↪[L] N) (m : M),\n      ∃ g : (closure L {m} ⊔ S : L.Substructure M) ↪[L] N, f =\n        g.comp (Substructure.inclusion le_sup_right) := by\n  refine ⟨fun h S S_FG f m => ?_, fun h ⟨f, f_FG⟩ m => ?_⟩\n  · obtain ⟨⟨f', hf'⟩, mf', ff'1, ff'2⟩ := h ⟨⟨S, _, f.equivRange⟩, S_FG⟩ m\n    refine ⟨f'.toEmbedding.comp (Substructure.inclusion ?_), ?_⟩\n    · simp only [sup_le_iff, ff'1, closure_le, singleton_subset_iff, SetLike.mem_coe, mf',\n        and_self]\n    · ext ⟨x, hx⟩\n      rw [Embedding.subtype_equivRange] at ff'2\n      simp only [← ff'2, Embedding.comp_apply, Substructure.coe_inclusion, inclusion_mk,\n        Equiv.coe_toEmbedding, coeSubtype, PartialEquiv.toEmbedding_apply]\n  · obtain ⟨f', eq_f'⟩ := h f.dom f_FG f.toEmbedding m\n    refine ⟨⟨⟨closure L {m} ⊔ f.dom, f'.toHom.range, f'.equivRange⟩,\n      (fg_closure_singleton _).sup f_FG⟩,\n      subset_closure.trans (le_sup_left : (closure L) {m} ≤ _) (mem_singleton m),\n      ⟨le_sup_right, Embedding.ext (fun _ => ?_)⟩⟩\n    rw [PartialEquiv.toEmbedding] at eq_f'\n    simp only [Embedding.comp_apply, Substructure.coe_inclusion, Equiv.coe_toEmbedding, coeSubtype,\n      Embedding.equivRange_apply, eq_f']\n\n"}
{"name":"FirstOrder.Language.IsExtensionPair.cod","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\na✝ : L.IsExtensionPair M N\nf : L.FGEquiv N M\nm : M\n⊢ Exists fun g => And (Membership.mem (↑g).cod m) (LE.le f g)","decl":"protected alias ⟨cod, _⟩ := isExtensionPair_iff_cod\n\n"}
{"name":"FirstOrder.Language.embedding_from_cg","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nM_cg : FirstOrder.Language.Structure.CG L M\ng : L.FGEquiv M N\nH : L.IsExtensionPair M N\n⊢ Exists fun f => LE.le (↑g) f.toPartialEquiv","decl":"/-- For a countably generated structure `M` and a structure `N`, if any partial equivalence\nbetween finitely generated substructures can be extended to any element in the domain,\nthen there exists an embedding of `M` in `N`. -/\ntheorem embedding_from_cg (M_cg : Structure.CG L M) (g : L.FGEquiv M N)\n    (H : L.IsExtensionPair M N) :\n    ∃ f : M ↪[L] N, g ≤ f.toPartialEquiv := by\n  rcases M_cg with ⟨X, _, X_gen⟩\n  have _ : Countable (↑X : Type _) := by simpa only [countable_coe_iff]\n  have _ : Encodable (↑X : Type _) := Encodable.ofCountable _\n  let D : X → Order.Cofinal (FGEquiv L M N) := fun x ↦ H.definedAtLeft x\n  let S : ℕ →o M ≃ₚ[L] N :=\n    ⟨Subtype.val ∘ (Order.sequenceOfCofinals g D),\n      (Subtype.mono_coe _).comp (Order.sequenceOfCofinals.monotone _ _)⟩\n  let F := DirectLimit.partialEquivLimit S\n  have _ : X ⊆ F.dom := by\n    intro x hx\n    have := Order.sequenceOfCofinals.encode_mem g D ⟨x, hx⟩\n    exact dom_le_dom\n      (le_partialEquivLimit S (Encodable.encode (⟨x, hx⟩ : X) + 1)) this\n  have isTop : F.dom = ⊤ := by rwa [← top_le_iff, ← X_gen, Substructure.closure_le]\n  exact ⟨toEmbeddingOfEqTop isTop,\n        by convert (le_partialEquivLimit S 0); apply Embedding.toPartialEquiv_toEmbedding⟩\n\n"}
{"name":"FirstOrder.Language.equiv_between_cg","module":"Mathlib.ModelTheory.PartialEquiv","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nM_cg : FirstOrder.Language.Structure.CG L M\nN_cg : FirstOrder.Language.Structure.CG L N\ng : L.FGEquiv M N\next_dom : L.IsExtensionPair M N\next_cod : L.IsExtensionPair N M\n⊢ Exists fun f => LE.le (↑g) f.toEmbedding.toPartialEquiv","decl":"/-- For two countably generated structure `M` and `N`, if any PartialEquiv\nbetween finitely generated substructures can be extended to any element in the domain and to\nany element in the codomain, then there exists an equivalence between `M` and `N`. -/\ntheorem equiv_between_cg (M_cg : Structure.CG L M) (N_cg : Structure.CG L N)\n    (g : L.FGEquiv M N)\n    (ext_dom : L.IsExtensionPair M N)\n    (ext_cod : L.IsExtensionPair N M) :\n    ∃ f : M ≃[L] N, g ≤ f.toEmbedding.toPartialEquiv := by\n  rcases M_cg with ⟨X, X_count, X_gen⟩\n  rcases N_cg with ⟨Y, Y_count, Y_gen⟩\n  have _ : Countable (↑X : Type _) := by simpa only [countable_coe_iff]\n  have _ : Encodable (↑X : Type _) := Encodable.ofCountable _\n  have _ : Countable (↑Y : Type _) := by simpa only [countable_coe_iff]\n  have _ : Encodable (↑Y : Type _) := Encodable.ofCountable _\n  let D : Sum X Y → Order.Cofinal (FGEquiv L M N) := fun p ↦\n    Sum.recOn p (fun x ↦ ext_dom.definedAtLeft x) (fun y ↦ ext_cod.definedAtRight y)\n  let S : ℕ →o M ≃ₚ[L] N :=\n    ⟨Subtype.val ∘ (Order.sequenceOfCofinals g D),\n      (Subtype.mono_coe _).comp (Order.sequenceOfCofinals.monotone _ _)⟩\n  let F := @DirectLimit.partialEquivLimit L M N _ _ ℕ _ _ _ S\n  have _ : X ⊆ F.dom := by\n    intro x hx\n    have := Order.sequenceOfCofinals.encode_mem g D (Sum.inl ⟨x, hx⟩)\n    exact dom_le_dom\n      (le_partialEquivLimit S (Encodable.encode (Sum.inl (⟨x, hx⟩ : X)) + 1)) this\n  have _ : Y ⊆ F.cod := by\n    intro y hy\n    have := Order.sequenceOfCofinals.encode_mem g D (Sum.inr ⟨y, hy⟩)\n    exact cod_le_cod\n      (le_partialEquivLimit S (Encodable.encode (Sum.inr (⟨y, hy⟩ : Y)) + 1)) this\n  have dom_top : F.dom = ⊤ := by rwa [← top_le_iff, ← X_gen, Substructure.closure_le]\n  have cod_top : F.cod = ⊤ := by rwa [← top_le_iff, ← Y_gen, Substructure.closure_le]\n  refine ⟨toEquivOfEqTop dom_top cod_top, ?_⟩\n  convert le_partialEquivLimit S 0\n  rw [toEquivOfEqTop_toEmbedding]\n  apply Embedding.toPartialEquiv_toEmbedding\n\n"}
