{"name":"contraction_of_isPowMul_of_boundedWrt","module":"Mathlib.Analysis.Normed.Ring.IsPowMulFaithful","initialProofState":"F : Type u_1\nŒ± : outParam (Type u_2)\ninst‚úù¬≥ : Ring Œ±\ninst‚úù¬≤ : FunLike F Œ± Real\ninst‚úù¬π : RingSeminormClass F Œ± Real\nŒ≤ : Type u_3\ninst‚úù : Ring Œ≤\nnŒ± : F\nnŒ≤ : Œ≤ ‚Üí Real\nhŒ≤ : IsPowMul nŒ≤\nf : RingHom Œ± Œ≤\nhf : RingHom.IsBoundedWrt (‚áënŒ±) nŒ≤ f\nx : Œ±\n‚ä¢ LE.le (nŒ≤ (f x)) (nŒ± x)","decl":"/-- If `f : Œ± ‚Üí+* Œ≤` is bounded with respect to a ring seminorm `nŒ±` on `Œ±` and a\n  power-multiplicative function `nŒ≤ : Œ≤ ‚Üí ‚Ñù`, then `‚àÄ x : Œ±, nŒ≤ (f x) ‚â§ nŒ± x`. -/\ntheorem contraction_of_isPowMul_of_boundedWrt {F : Type*} {Œ± : outParam (Type*)} [Ring Œ±]\n    [FunLike F Œ± ‚Ñù] [RingSeminormClass F Œ± ‚Ñù] {Œ≤ : Type*} [Ring Œ≤] (nŒ± : F) {nŒ≤ : Œ≤ ‚Üí ‚Ñù}\n    (hŒ≤ : IsPowMul nŒ≤) {f : Œ± ‚Üí+* Œ≤} (hf : f.IsBoundedWrt nŒ± nŒ≤) (x : Œ±) : nŒ≤ (f x) ‚â§ nŒ± x := by\n  obtain ‚ü®C, hC0, hC‚ü© := hf\n  have hlim : Tendsto (fun n : ‚Ñï => C ^ (1 / (n : ‚Ñù)) * nŒ± x) atTop (ùìù (nŒ± x)) := by\n    nth_rewrite 2 [‚Üê one_mul (nŒ± x)]\n    exact ((rpow_zero C ‚ñ∏ ContinuousAt.tendsto (continuousAt_const_rpow (ne_of_gt hC0))).comp\n      (tendsto_const_div_atTop_nhds_zero_nat 1)).mul tendsto_const_nhds\n  apply ge_of_tendsto hlim\n  simp only [eventually_atTop, ge_iff_le]\n  use 1\n  intro n hn\n  have h : (C ^ (1 / n : ‚Ñù)) ^ n = C := by\n    have hn0 : (n : ‚Ñù) ‚â† 0 := Nat.cast_ne_zero.mpr (ne_of_gt hn)\n    rw [‚Üê rpow_natCast, ‚Üê rpow_mul (le_of_lt hC0), one_div, inv_mul_cancel‚ÇÄ hn0, rpow_one]\n  apply le_of_pow_le_pow_left‚ÇÄ (ne_of_gt hn)\n    (mul_nonneg (rpow_nonneg (le_of_lt hC0) _) (apply_nonneg _ _))\n  ¬∑ rw [mul_pow, h, ‚Üê hŒ≤ _ hn, ‚Üê RingHom.map_pow]\n    apply le_trans (hC (x ^ n))\n    rw [mul_le_mul_left hC0]\n    exact map_pow_le_pow _ _ (Nat.one_le_iff_ne_zero.mp hn)\n\n"}
{"name":"contraction_of_isPowMul","module":"Mathlib.Analysis.Normed.Ring.IsPowMulFaithful","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : SeminormedRing Œ±\ninst‚úù : SeminormedRing Œ≤\nhŒ≤ : IsPowMul Norm.norm\nf : RingHom Œ± Œ≤\nhf : f.IsBounded\nx : Œ±\n‚ä¢ LE.le (Norm.norm (f x)) (Norm.norm x)","decl":"/-- Given a bounded `f : Œ± ‚Üí+* Œ≤` between seminormed rings, is the seminorm on `Œ≤` is\n  power-multiplicative, then `f` is a contraction. -/\ntheorem contraction_of_isPowMul {Œ± Œ≤ : Type*} [SeminormedRing Œ±] [SeminormedRing Œ≤]\n    (hŒ≤ : IsPowMul (norm : Œ≤ ‚Üí ‚Ñù)) {f : Œ± ‚Üí+* Œ≤} (hf : f.IsBounded) (x : Œ±) : norm (f x) ‚â§ norm x :=\n  contraction_of_isPowMul_of_boundedWrt (SeminormedRing.toRingSeminorm Œ±) hŒ≤ hf x\n\n"}
{"name":"eq_seminorms","module":"Mathlib.Analysis.Normed.Ring.IsPowMulFaithful","initialProofState":"F : Type u_1\nŒ± : outParam (Type u_2)\ninst‚úù¬≤ : Ring Œ±\ninst‚úù¬π : FunLike F Œ± Real\ninst‚úù : RingSeminormClass F Œ± Real\nf g : F\nhfpm : IsPowMul ‚áëf\nhgpm : IsPowMul ‚áëg\nhfg : Exists fun r => Exists fun x => ‚àÄ (a : Œ±), LE.le (f a) (HMul.hMul r (g a))\nhgf : Exists fun r => Exists fun x => ‚àÄ (a : Œ±), LE.le (g a) (HMul.hMul r (f a))\n‚ä¢ Eq f g","decl":"/-- Given two power-multiplicative ring seminorms `f, g` on `Œ±`, if `f` is bounded by a positive\n  multiple of `g` and vice versa, then `f = g`. -/\ntheorem eq_seminorms {F : Type*} {Œ± : outParam (Type*)} [Ring Œ±] [FunLike F Œ± ‚Ñù]\n    [RingSeminormClass F Œ± ‚Ñù] {f g : F} (hfpm : IsPowMul f) (hgpm : IsPowMul g)\n    (hfg : ‚àÉ (r : ‚Ñù) (_ : 0 < r), ‚àÄ a : Œ±, f a ‚â§ r * g a)\n    (hgf : ‚àÉ (r : ‚Ñù) (_ : 0 < r), ‚àÄ a : Œ±, g a ‚â§ r * f a) : f = g := by\n  obtain ‚ü®r, hr0, hr‚ü© := hfg\n  obtain ‚ü®s, hs0, hs‚ü© := hgf\n  have hle : RingHom.IsBoundedWrt f g (RingHom.id _) := ‚ü®s, hs0, hs‚ü©\n  have hge : RingHom.IsBoundedWrt g f (RingHom.id _) := ‚ü®r, hr0, hr‚ü©\n  rw [‚Üê Function.Injective.eq_iff DFunLike.coe_injective']\n  ext x\n  exact le_antisymm (contraction_of_isPowMul_of_boundedWrt g hfpm hge x)\n    (contraction_of_isPowMul_of_boundedWrt f hgpm hle x)\n\n"}
{"name":"eq_of_powMul_faithful","module":"Mathlib.Analysis.Normed.Ring.IsPowMulFaithful","initialProofState":"R : Type u_1\nS : Type u_2\ninst‚úù¬≤ : NormedCommRing R\ninst‚úù¬π : CommRing S\ninst‚úù : Algebra R S\nf‚ÇÅ : AlgebraNorm R S\nhf‚ÇÅ_pm : IsPowMul ‚áëf‚ÇÅ\nf‚ÇÇ : AlgebraNorm R S\nhf‚ÇÇ_pm : IsPowMul ‚áëf‚ÇÇ\nh_eq : ‚àÄ (y : S), Exists fun C‚ÇÅ => Exists fun C‚ÇÇ => Exists fun x => Exists fun x => ‚àÄ (x : Subtype fun x => Membership.mem (Algebra.adjoin R (Singleton.singleton y)) x), And (LE.le (f‚ÇÅ ‚Üëx) (HMul.hMul C‚ÇÅ (f‚ÇÇ ‚Üëx))) (LE.le (f‚ÇÇ ‚Üëx) (HMul.hMul C‚ÇÇ (f‚ÇÅ ‚Üëx)))\n‚ä¢ Eq f‚ÇÅ f‚ÇÇ","decl":"/-- If `R` is a normed commutative ring and `f‚ÇÅ` and `f‚ÇÇ` are two power-multiplicative `R`-algebra\n  norms on `S`, then if `f‚ÇÅ` and `f‚ÇÇ` are equivalent on every  subring `R[y]` for `y : S`, it\n  follows that `f‚ÇÅ = f‚ÇÇ` [BGR, Proposition 3.1.5/1][bosch-guntzer-remmert]. -/\ntheorem eq_of_powMul_faithful (f‚ÇÅ : AlgebraNorm R S) (hf‚ÇÅ_pm : IsPowMul f‚ÇÅ) (f‚ÇÇ : AlgebraNorm R S)\n    (hf‚ÇÇ_pm : IsPowMul f‚ÇÇ)\n    (h_eq : ‚àÄ y : S, ‚àÉ (C‚ÇÅ C‚ÇÇ : ‚Ñù) (_ : 0 < C‚ÇÅ) (_ : 0 < C‚ÇÇ),\n      ‚àÄ x : Algebra.adjoin R {y}, f‚ÇÅ x.val ‚â§ C‚ÇÅ * f‚ÇÇ x.val ‚àß f‚ÇÇ x.val ‚â§ C‚ÇÇ * f‚ÇÅ x.val) :\n    f‚ÇÅ = f‚ÇÇ := by\n  ext x\n  set g‚ÇÅ : AlgebraNorm R (Algebra.adjoin R ({x} : Set S)) := AlgebraNorm.restriction _ f‚ÇÅ\n  set g‚ÇÇ : AlgebraNorm R (Algebra.adjoin R ({x} : Set S)) := AlgebraNorm.restriction _ f‚ÇÇ\n  have hg‚ÇÅ_pm : IsPowMul g‚ÇÅ := IsPowMul.restriction _ hf‚ÇÅ_pm\n  have hg‚ÇÇ_pm : IsPowMul g‚ÇÇ := IsPowMul.restriction _ hf‚ÇÇ_pm\n  let y : Algebra.adjoin R ({x} : Set S) := ‚ü®x, Algebra.self_mem_adjoin_singleton R x‚ü©\n  have hy : x = y.val := rfl\n  have h1 : f‚ÇÅ y.val = g‚ÇÅ y := rfl\n  have h2 : f‚ÇÇ y.val = g‚ÇÇ y := rfl\n  obtain ‚ü®C‚ÇÅ, C‚ÇÇ, hC‚ÇÅ_pos, hC‚ÇÇ_pos, hC‚ü© := h_eq x\n  obtain ‚ü®hC‚ÇÅ, hC‚ÇÇ‚ü© := forall_and.mp hC\n  rw [hy, h1, h2, eq_seminorms hg‚ÇÅ_pm hg‚ÇÇ_pm ‚ü®C‚ÇÅ, hC‚ÇÅ_pos, hC‚ÇÅ‚ü© ‚ü®C‚ÇÇ, hC‚ÇÇ_pos, hC‚ÇÇ‚ü©]\n"}
