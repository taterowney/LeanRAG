{"name":"Equiv.Perm.closure_isCycle","module":"Mathlib.GroupTheory.Perm.Closure","initialProofState":"β : Type u_3\ninst✝ : Finite β\n⊢ Eq (Subgroup.closure (setOf fun σ => σ.IsCycle)) Top.top","decl":"theorem closure_isCycle : closure { σ : Perm β | IsCycle σ } = ⊤ := by\n  classical\n    cases nonempty_fintype β\n    exact\n      top_le_iff.mp (le_trans (ge_of_eq closure_isSwap) (closure_mono fun _ => IsSwap.isCycle))\n\n"}
{"name":"Equiv.Perm.closure_cycle_adjacent_swap","module":"Mathlib.GroupTheory.Perm.Closure","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nσ : Equiv.Perm α\nh1 : σ.IsCycle\nh2 : Eq σ.support Finset.univ\nx : α\n⊢ Eq (Subgroup.closure (Insert.insert σ (Singleton.singleton (Equiv.swap x (σ x))))) Top.top","decl":"theorem closure_cycle_adjacent_swap {σ : Perm α} (h1 : IsCycle σ) (h2 : σ.support = univ) (x : α) :\n    closure ({σ, swap x (σ x)} : Set (Perm α)) = ⊤ := by\n  let H := closure ({σ, swap x (σ x)} : Set (Perm α))\n  have h3 : σ ∈ H := subset_closure (Set.mem_insert σ _)\n  have h4 : swap x (σ x) ∈ H := subset_closure (Set.mem_insert_of_mem _ (Set.mem_singleton _))\n  have step1 : ∀ n : ℕ, swap ((σ ^ n) x) ((σ ^ (n + 1) : Perm α) x) ∈ H := by\n    intro n\n    induction n with\n    | zero => exact subset_closure (Set.mem_insert_of_mem _ (Set.mem_singleton _))\n    | succ n ih =>\n      convert H.mul_mem (H.mul_mem h3 ih) (H.inv_mem h3)\n      simp_rw [mul_swap_eq_swap_mul, mul_inv_cancel_right, pow_succ', coe_mul, comp_apply]\n  have step2 : ∀ n : ℕ, swap x ((σ ^ n) x) ∈ H := by\n    intro n\n    induction n with\n    | zero =>\n      simp only [pow_zero, coe_one, id_eq, swap_self, Set.mem_singleton_iff]\n      convert H.one_mem\n    | succ n ih =>\n      by_cases h5 : x = (σ ^ n) x\n      · rw [pow_succ', mul_apply, ← h5]\n        exact h4\n      by_cases h6 : x = (σ ^ (n + 1) : Perm α) x\n      · rw [← h6, swap_self]\n        exact H.one_mem\n      rw [swap_comm, ← swap_mul_swap_mul_swap h5 h6]\n      exact H.mul_mem (H.mul_mem (step1 n) ih) (step1 n)\n  have step3 : ∀ y : α, swap x y ∈ H := by\n    intro y\n    have hx : x ∈ univ := Finset.mem_univ x\n    rw [← h2, mem_support] at hx\n    have hy : y ∈ univ := Finset.mem_univ y\n    rw [← h2, mem_support] at hy\n    cases' IsCycle.exists_pow_eq h1 hx hy with n hn\n    rw [← hn]\n    exact step2 n\n  have step4 : ∀ y z : α, swap y z ∈ H := by\n    intro y z\n    by_cases h5 : z = x\n    · rw [h5, swap_comm]\n      exact step3 y\n    by_cases h6 : z = y\n    · rw [h6, swap_self]\n      exact H.one_mem\n    rw [← swap_mul_swap_mul_swap h5 h6, swap_comm z x]\n    exact H.mul_mem (H.mul_mem (step3 y) (step3 z)) (step3 y)\n  rw [eq_top_iff, ← closure_isSwap, closure_le]\n  rintro τ ⟨y, z, _, h6⟩\n  rw [h6]\n  exact step4 y z\n\n"}
{"name":"Equiv.Perm.closure_cycle_coprime_swap","module":"Mathlib.GroupTheory.Perm.Closure","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nn : Nat\nσ : Equiv.Perm α\nh0 : n.Coprime (Fintype.card α)\nh1 : σ.IsCycle\nh2 : Eq σ.support Finset.univ\nx : α\n⊢ Eq (Subgroup.closure (Insert.insert σ (Singleton.singleton (Equiv.swap x ((HPow.hPow σ n) x))))) Top.top","decl":"theorem closure_cycle_coprime_swap {n : ℕ} {σ : Perm α} (h0 : Nat.Coprime n (Fintype.card α))\n    (h1 : IsCycle σ) (h2 : σ.support = Finset.univ) (x : α) :\n    closure ({σ, swap x ((σ ^ n) x)} : Set (Perm α)) = ⊤ := by\n  rw [← Finset.card_univ, ← h2, ← h1.orderOf] at h0\n  cases' exists_pow_eq_self_of_coprime h0 with m hm\n  have h2' : (σ ^ n).support = univ := Eq.trans (support_pow_coprime h0) h2\n  have h1' : IsCycle ((σ ^ n) ^ (m : ℤ)) := by rwa [← hm] at h1\n  replace h1' : IsCycle (σ ^ n) :=\n    h1'.of_pow (le_trans (support_pow_le σ n) (ge_of_eq (congr_arg support hm)))\n  rw [eq_top_iff, ← closure_cycle_adjacent_swap h1' h2' x, closure_le, Set.insert_subset_iff]\n  exact\n    ⟨Subgroup.pow_mem (closure _) (subset_closure (Set.mem_insert σ _)) n,\n      Set.singleton_subset_iff.mpr (subset_closure (Set.mem_insert_of_mem _ (Set.mem_singleton _)))⟩\n\n"}
{"name":"Equiv.Perm.closure_prime_cycle_swap","module":"Mathlib.GroupTheory.Perm.Closure","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nσ τ : Equiv.Perm α\nh0 : Nat.Prime (Fintype.card α)\nh1 : σ.IsCycle\nh2 : Eq σ.support Finset.univ\nh3 : τ.IsSwap\n⊢ Eq (Subgroup.closure (Insert.insert σ (Singleton.singleton τ))) Top.top","decl":"theorem closure_prime_cycle_swap {σ τ : Perm α} (h0 : (Fintype.card α).Prime) (h1 : IsCycle σ)\n    (h2 : σ.support = Finset.univ) (h3 : IsSwap τ) : closure ({σ, τ} : Set (Perm α)) = ⊤ := by\n  obtain ⟨x, y, h4, h5⟩ := h3\n  obtain ⟨i, hi⟩ :=\n    h1.exists_pow_eq (mem_support.mp ((Finset.ext_iff.mp h2 x).mpr (Finset.mem_univ x)))\n      (mem_support.mp ((Finset.ext_iff.mp h2 y).mpr (Finset.mem_univ y)))\n  rw [h5, ← hi]\n  refine closure_cycle_coprime_swap\n    (Nat.Coprime.symm (h0.coprime_iff_not_dvd.mpr fun h => h4 ?_)) h1 h2 x\n  cases' h with m hm\n  rwa [hm, pow_mul, ← Finset.card_univ, ← h2, ← h1.orderOf, pow_orderOf_eq_one, one_pow,\n    one_apply] at hi\n\n"}
