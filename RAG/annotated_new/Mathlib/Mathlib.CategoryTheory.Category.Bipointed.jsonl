{"name":"Bipointed.mk.inj","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X‚úù : Type u\ntoProd‚úù : Prod X‚úù X‚úù\nX : Type u\ntoProd : Prod X X\nx‚úù : Eq { X := X‚úù, toProd := toProd‚úù } { X := X, toProd := toProd }\n‚ä¢ And (Eq X‚úù X) (HEq toProd‚úù toProd)","decl":"/-- The category of bipointed types. -/\nstructure Bipointed : Type (u + 1) where\n  /-- The underlying type of a bipointed type. -/\n  protected X : Type u\n  /-- The two points of a bipointed type, bundled together as a pair. -/\n  toProd : X √ó X\n\n"}
{"name":"Bipointed.mk.injEq","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X‚úù : Type u\ntoProd‚úù : Prod X‚úù X‚úù\nX : Type u\ntoProd : Prod X X\n‚ä¢ Eq (Eq { X := X‚úù, toProd := toProd‚úù } { X := X, toProd := toProd }) (And (Eq X‚úù X) (HEq toProd‚úù toProd))","decl":"/-- The category of bipointed types. -/\nstructure Bipointed : Type (u + 1) where\n  /-- The underlying type of a bipointed type. -/\n  protected X : Type u\n  /-- The two points of a bipointed type, bundled together as a pair. -/\n  toProd : X √ó X\n\n"}
{"name":"Bipointed.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Type u\ntoProd : Prod X X\n‚ä¢ Eq (SizeOf.sizeOf { X := X, toProd := toProd }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf X)) (SizeOf.sizeOf toProd))","decl":"/-- The category of bipointed types. -/\nstructure Bipointed : Type (u + 1) where\n  /-- The underlying type of a bipointed type. -/\n  protected X : Type u\n  /-- The two points of a bipointed type, bundled together as a pair. -/\n  toProd : X √ó X\n\n"}
{"name":"Bipointed.coe_of","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Type u_1\nto_prod : Prod X X\n‚ä¢ Eq (Bipointed.of to_prod).X X","decl":"@[simp]\ntheorem coe_of {X : Type*} (to_prod : X √ó X) : ‚Ü•(of to_prod) = X :=\n  rfl\n\n"}
{"name":"Bipointed.Hom.map_snd","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X Y : Bipointed\nself : X.Hom Y\n‚ä¢ Eq (self.toFun X.toProd.2) Y.toProd.2","decl":"/-- Morphisms in `Bipointed`. -/\n@[ext]\nprotected structure Hom (X Y : Bipointed.{u}) : Type u where\n  /-- The underlying function of a morphism of bipointed types. -/\n  toFun : X ‚Üí Y\n  map_fst : toFun X.toProd.1 = Y.toProd.1\n  map_snd : toFun X.toProd.2 = Y.toProd.2\n\n"}
{"name":"Bipointed.Hom.ext_iff","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X Y : Bipointed\nx y : X.Hom Y\n‚ä¢ Iff (Eq x y) (Eq x.toFun y.toFun)","decl":"/-- Morphisms in `Bipointed`. -/\n@[ext]\nprotected structure Hom (X Y : Bipointed.{u}) : Type u where\n  /-- The underlying function of a morphism of bipointed types. -/\n  toFun : X ‚Üí Y\n  map_fst : toFun X.toProd.1 = Y.toProd.1\n  map_snd : toFun X.toProd.2 = Y.toProd.2\n\n"}
{"name":"Bipointed.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X Y : Bipointed\ntoFun : X.X ‚Üí Y.X\nmap_fst : Eq (toFun X.toProd.1) Y.toProd.1\nmap_snd : Eq (toFun X.toProd.2) Y.toProd.2\n‚ä¢ Eq (SizeOf.sizeOf { toFun := toFun, map_fst := map_fst, map_snd := map_snd }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf map_fst)) (SizeOf.sizeOf map_snd))","decl":"/-- Morphisms in `Bipointed`. -/\n@[ext]\nprotected structure Hom (X Y : Bipointed.{u}) : Type u where\n  /-- The underlying function of a morphism of bipointed types. -/\n  toFun : X ‚Üí Y\n  map_fst : toFun X.toProd.1 = Y.toProd.1\n  map_snd : toFun X.toProd.2 = Y.toProd.2\n\n"}
{"name":"Bipointed.Hom.map_fst","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X Y : Bipointed\nself : X.Hom Y\n‚ä¢ Eq (self.toFun X.toProd.1) Y.toProd.1","decl":"/-- Morphisms in `Bipointed`. -/\n@[ext]\nprotected structure Hom (X Y : Bipointed.{u}) : Type u where\n  /-- The underlying function of a morphism of bipointed types. -/\n  toFun : X ‚Üí Y\n  map_fst : toFun X.toProd.1 = Y.toProd.1\n  map_snd : toFun X.toProd.2 = Y.toProd.2\n\n"}
{"name":"Bipointed.Hom.ext","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X Y : Bipointed\nx y : X.Hom Y\ntoFun : Eq x.toFun y.toFun\n‚ä¢ Eq x y","decl":"/-- Morphisms in `Bipointed`. -/\n@[ext]\nprotected structure Hom (X Y : Bipointed.{u}) : Type u where\n  /-- The underlying function of a morphism of bipointed types. -/\n  toFun : X ‚Üí Y\n  map_fst : toFun X.toProd.1 = Y.toProd.1\n  map_snd : toFun X.toProd.2 = Y.toProd.2\n\n"}
{"name":"Bipointed.Hom.mk.inj","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X Y : Bipointed\ntoFun‚úù : X.X ‚Üí Y.X\nmap_fst‚úù : Eq (toFun‚úù X.toProd.1) Y.toProd.1\nmap_snd‚úù : Eq (toFun‚úù X.toProd.2) Y.toProd.2\ntoFun : X.X ‚Üí Y.X\nmap_fst : Eq (toFun X.toProd.1) Y.toProd.1\nmap_snd : Eq (toFun X.toProd.2) Y.toProd.2\nx‚úù : Eq { toFun := toFun‚úù, map_fst := map_fst‚úù, map_snd := map_snd‚úù } { toFun := toFun, map_fst := map_fst, map_snd := map_snd }\n‚ä¢ Eq toFun‚úù toFun","decl":"/-- Morphisms in `Bipointed`. -/\n@[ext]\nprotected structure Hom (X Y : Bipointed.{u}) : Type u where\n  /-- The underlying function of a morphism of bipointed types. -/\n  toFun : X ‚Üí Y\n  map_fst : toFun X.toProd.1 = Y.toProd.1\n  map_snd : toFun X.toProd.2 = Y.toProd.2\n\n"}
{"name":"Bipointed.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X Y : Bipointed\ntoFun‚úù : X.X ‚Üí Y.X\nmap_fst‚úù : Eq (toFun‚úù X.toProd.1) Y.toProd.1\nmap_snd‚úù : Eq (toFun‚úù X.toProd.2) Y.toProd.2\ntoFun : X.X ‚Üí Y.X\nmap_fst : Eq (toFun X.toProd.1) Y.toProd.1\nmap_snd : Eq (toFun X.toProd.2) Y.toProd.2\n‚ä¢ Eq (Eq { toFun := toFun‚úù, map_fst := map_fst‚úù, map_snd := map_snd‚úù } { toFun := toFun, map_fst := map_fst, map_snd := map_snd }) (Eq toFun‚úù toFun)","decl":"/-- Morphisms in `Bipointed`. -/\n@[ext]\nprotected structure Hom (X Y : Bipointed.{u}) : Type u where\n  /-- The underlying function of a morphism of bipointed types. -/\n  toFun : X ‚Üí Y\n  map_fst : toFun X.toProd.1 = Y.toProd.1\n  map_snd : toFun X.toProd.2 = Y.toProd.2\n\n"}
{"name":"Bipointed.Hom.id_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Bipointed\na : X.X\n‚ä¢ Eq ((Bipointed.Hom.id X).toFun a) (id a)","decl":"/-- The identity morphism of `X : Bipointed`. -/\n@[simps]\nnonrec def id (X : Bipointed) : Bipointed.Hom X X :=\n  ‚ü®id, rfl, rfl‚ü©\n\n"}
{"name":"Bipointed.Hom.comp_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X Y Z : Bipointed\nf : X.Hom Y\ng : Y.Hom Z\na‚úù : X.X\n‚ä¢ Eq ((f.comp g).toFun a‚úù) (Function.comp g.toFun f.toFun a‚úù)","decl":"/-- Composition of morphisms of `Bipointed`. -/\n@[simps]\ndef comp {X Y Z : Bipointed.{u}} (f : Bipointed.Hom X Y) (g : Bipointed.Hom Y Z) :\n    Bipointed.Hom X Z :=\n  ‚ü®g.toFun ‚àò f.toFun, by rw [Function.comp_apply, f.map_fst, g.map_fst], by\n    rw [Function.comp_apply, f.map_snd, g.map_snd]‚ü©\n\n"}
{"name":"Bipointed.swap_obj_toProd","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Bipointed\n‚ä¢ Eq (Bipointed.swap.obj X).toProd X.toProd.swap","decl":"/-- Swaps the pointed elements of a bipointed type. `Prod.swap` as a functor. -/\n@[simps]\ndef swap : Bipointed ‚•§ Bipointed where\n  obj X := ‚ü®X, X.toProd.swap‚ü©\n  map f := ‚ü®f.toFun, f.map_snd, f.map_fst‚ü©\n\n"}
{"name":"Bipointed.swap_obj_X","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Bipointed\n‚ä¢ Eq (Bipointed.swap.obj X).X X.X","decl":"/-- Swaps the pointed elements of a bipointed type. `Prod.swap` as a functor. -/\n@[simps]\ndef swap : Bipointed ‚•§ Bipointed where\n  obj X := ‚ü®X, X.toProd.swap‚ü©\n  map f := ‚ü®f.toFun, f.map_snd, f.map_fst‚ü©\n\n"}
{"name":"Bipointed.swap_map_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X‚úù Y‚úù : Bipointed\nf : Quiver.Hom X‚úù Y‚úù\na‚úù : X‚úù.X\n‚ä¢ Eq ((Bipointed.swap.map f).toFun a‚úù) (f.toFun a‚úù)","decl":"/-- Swaps the pointed elements of a bipointed type. `Prod.swap` as a functor. -/\n@[simps]\ndef swap : Bipointed ‚•§ Bipointed where\n  obj X := ‚ü®X, X.toProd.swap‚ü©\n  map f := ‚ü®f.toFun, f.map_snd, f.map_fst‚ü©\n\n"}
{"name":"Bipointed.swapEquiv_functor_obj_toProd","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Bipointed\n‚ä¢ Eq (Bipointed.swapEquiv.functor.obj X).toProd X.toProd.swap","decl":"/-- The equivalence between `Bipointed` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\ndef swapEquiv : Bipointed ‚âå Bipointed where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"Bipointed.swapEquiv_functor_map_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X‚úù Y‚úù : Bipointed\nf : Quiver.Hom X‚úù Y‚úù\na‚úù : X‚úù.X\n‚ä¢ Eq ((Bipointed.swapEquiv.functor.map f).toFun a‚úù) (f.toFun a‚úù)","decl":"/-- The equivalence between `Bipointed` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\ndef swapEquiv : Bipointed ‚âå Bipointed where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"Bipointed.swapEquiv_unitIso_inv_app_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Bipointed\na : ((CategoryTheory.Functor.id Bipointed).obj X).X\n‚ä¢ Eq ((Bipointed.swapEquiv.unitIso.inv.app X).toFun a) a","decl":"/-- The equivalence between `Bipointed` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\ndef swapEquiv : Bipointed ‚âå Bipointed where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"Bipointed.swapEquiv_unitIso_hom_app_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Bipointed\na : ((CategoryTheory.Functor.id Bipointed).obj X).X\n‚ä¢ Eq ((Bipointed.swapEquiv.unitIso.hom.app X).toFun a) a","decl":"/-- The equivalence between `Bipointed` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\ndef swapEquiv : Bipointed ‚âå Bipointed where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"Bipointed.swapEquiv_inverse_obj_toProd","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Bipointed\n‚ä¢ Eq (Bipointed.swapEquiv.inverse.obj X).toProd X.toProd.swap","decl":"/-- The equivalence between `Bipointed` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\ndef swapEquiv : Bipointed ‚âå Bipointed where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"Bipointed.swapEquiv_counitIso_hom_app_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Bipointed\na : ((Bipointed.swap.comp Bipointed.swap).obj X).X\n‚ä¢ Eq ((Bipointed.swapEquiv.counitIso.hom.app X).toFun a) a","decl":"/-- The equivalence between `Bipointed` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\ndef swapEquiv : Bipointed ‚âå Bipointed where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"Bipointed.swapEquiv_functor_obj_X","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Bipointed\n‚ä¢ Eq (Bipointed.swapEquiv.functor.obj X).X X.X","decl":"/-- The equivalence between `Bipointed` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\ndef swapEquiv : Bipointed ‚âå Bipointed where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"Bipointed.swapEquiv_inverse_map_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X‚úù Y‚úù : Bipointed\nf : Quiver.Hom X‚úù Y‚úù\na‚úù : X‚úù.X\n‚ä¢ Eq ((Bipointed.swapEquiv.inverse.map f).toFun a‚úù) (f.toFun a‚úù)","decl":"/-- The equivalence between `Bipointed` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\ndef swapEquiv : Bipointed ‚âå Bipointed where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"Bipointed.swapEquiv_inverse_obj_X","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Bipointed\n‚ä¢ Eq (Bipointed.swapEquiv.inverse.obj X).X X.X","decl":"/-- The equivalence between `Bipointed` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\ndef swapEquiv : Bipointed ‚âå Bipointed where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"Bipointed.swapEquiv_counitIso_inv_app_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Bipointed\na : ((Bipointed.swap.comp Bipointed.swap).obj X).X\n‚ä¢ Eq ((Bipointed.swapEquiv.counitIso.inv.app X).toFun a) a","decl":"/-- The equivalence between `Bipointed` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\ndef swapEquiv : Bipointed ‚âå Bipointed where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"Bipointed.swapEquiv_symm","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"‚ä¢ Eq Bipointed.swapEquiv.symm Bipointed.swapEquiv","decl":"@[simp]\ntheorem swapEquiv_symm : swapEquiv.symm = swapEquiv :=\n  rfl\n\n"}
{"name":"bipointedToPointedFst_comp_forget","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"‚ä¢ Eq (bipointedToPointedFst.comp (CategoryTheory.forget Pointed)) (CategoryTheory.forget Bipointed)","decl":"@[simp]\ntheorem bipointedToPointedFst_comp_forget :\n    bipointedToPointedFst ‚ãô forget Pointed = forget Bipointed :=\n  rfl\n\n"}
{"name":"bipointedToPointedSnd_comp_forget","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"‚ä¢ Eq (bipointedToPointedSnd.comp (CategoryTheory.forget Pointed)) (CategoryTheory.forget Bipointed)","decl":"@[simp]\ntheorem bipointedToPointedSnd_comp_forget :\n    bipointedToPointedSnd ‚ãô forget Pointed = forget Bipointed :=\n  rfl\n\n"}
{"name":"swap_comp_bipointedToPointedFst","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"‚ä¢ Eq (Bipointed.swap.comp bipointedToPointedFst) bipointedToPointedSnd","decl":"@[simp]\ntheorem swap_comp_bipointedToPointedFst :\n    Bipointed.swap ‚ãô bipointedToPointedFst = bipointedToPointedSnd :=\n  rfl\n\n"}
{"name":"swap_comp_bipointedToPointedSnd","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"‚ä¢ Eq (Bipointed.swap.comp bipointedToPointedSnd) bipointedToPointedFst","decl":"@[simp]\ntheorem swap_comp_bipointedToPointedSnd :\n    Bipointed.swap ‚ãô bipointedToPointedSnd = bipointedToPointedFst :=\n  rfl\n\n"}
{"name":"pointedToBipointedFst_comp_swap","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"‚ä¢ Eq (pointedToBipointedFst.comp Bipointed.swap) pointedToBipointedSnd","decl":"@[simp]\ntheorem pointedToBipointedFst_comp_swap :\n    pointedToBipointedFst ‚ãô Bipointed.swap = pointedToBipointedSnd :=\n  rfl\n\n"}
{"name":"pointedToBipointedSnd_comp_swap","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"‚ä¢ Eq (pointedToBipointedSnd.comp Bipointed.swap) pointedToBipointedFst","decl":"@[simp]\ntheorem pointedToBipointedSnd_comp_swap :\n    pointedToBipointedSnd ‚ãô Bipointed.swap = pointedToBipointedFst :=\n  rfl\n\n"}
{"name":"pointedToBipointedCompBipointedToPointedFst_inv_app_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Pointed\na : ((CategoryTheory.Functor.id Pointed).obj X).X\n‚ä¢ Eq ((pointedToBipointedCompBipointedToPointedFst.inv.app X).toFun a) a","decl":"/-- `BipointedToPointed_fst` is inverse to `PointedToBipointed`. -/\n@[simps!]\ndef pointedToBipointedCompBipointedToPointedFst :\n    pointedToBipointed ‚ãô bipointedToPointedFst ‚âÖ ùü≠ _ :=\n  NatIso.ofComponents fun X =>\n    { hom := ‚ü®id, rfl‚ü©\n      inv := ‚ü®id, rfl‚ü© }\n\n"}
{"name":"pointedToBipointedCompBipointedToPointedFst_hom_app_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Pointed\na : ((pointedToBipointed.comp bipointedToPointedFst).obj X).X\n‚ä¢ Eq ((pointedToBipointedCompBipointedToPointedFst.hom.app X).toFun a) a","decl":"/-- `BipointedToPointed_fst` is inverse to `PointedToBipointed`. -/\n@[simps!]\ndef pointedToBipointedCompBipointedToPointedFst :\n    pointedToBipointed ‚ãô bipointedToPointedFst ‚âÖ ùü≠ _ :=\n  NatIso.ofComponents fun X =>\n    { hom := ‚ü®id, rfl‚ü©\n      inv := ‚ü®id, rfl‚ü© }\n\n"}
{"name":"pointedToBipointedCompBipointedToPointedSnd_inv_app_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Pointed\na : ((CategoryTheory.Functor.id Pointed).obj X).X\n‚ä¢ Eq ((pointedToBipointedCompBipointedToPointedSnd.inv.app X).toFun a) a","decl":"/-- `BipointedToPointed_snd` is inverse to `PointedToBipointed`. -/\n@[simps!]\ndef pointedToBipointedCompBipointedToPointedSnd :\n    pointedToBipointed ‚ãô bipointedToPointedSnd ‚âÖ ùü≠ _ :=\n  NatIso.ofComponents fun X =>\n    { hom := ‚ü®id, rfl‚ü©\n      inv := ‚ü®id, rfl‚ü© }\n\n"}
{"name":"pointedToBipointedCompBipointedToPointedSnd_hom_app_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Pointed\na : ((pointedToBipointed.comp bipointedToPointedSnd).obj X).X\n‚ä¢ Eq ((pointedToBipointedCompBipointedToPointedSnd.hom.app X).toFun a) a","decl":"/-- `BipointedToPointed_snd` is inverse to `PointedToBipointed`. -/\n@[simps!]\ndef pointedToBipointedCompBipointedToPointedSnd :\n    pointedToBipointed ‚ãô bipointedToPointedSnd ‚âÖ ùü≠ _ :=\n  NatIso.ofComponents fun X =>\n    { hom := ‚ü®id, rfl‚ü©\n      inv := ‚ü®id, rfl‚ü© }\n\n"}
