{"name":"Bipointed.mk.inj","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X✝ : Type u\ntoProd✝ : Prod X✝ X✝\nX : Type u\ntoProd : Prod X X\nx✝ : Eq { X := X✝, toProd := toProd✝ } { X := X, toProd := toProd }\n⊢ And (Eq X✝ X) (HEq toProd✝ toProd)","decl":"/-- The category of bipointed types. -/\nstructure Bipointed : Type (u + 1) where\n  /-- The underlying type of a bipointed type. -/\n  protected X : Type u\n  /-- The two points of a bipointed type, bundled together as a pair. -/\n  toProd : X × X\n\n"}
{"name":"Bipointed.mk.injEq","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X✝ : Type u\ntoProd✝ : Prod X✝ X✝\nX : Type u\ntoProd : Prod X X\n⊢ Eq (Eq { X := X✝, toProd := toProd✝ } { X := X, toProd := toProd }) (And (Eq X✝ X) (HEq toProd✝ toProd))","decl":"/-- The category of bipointed types. -/\nstructure Bipointed : Type (u + 1) where\n  /-- The underlying type of a bipointed type. -/\n  protected X : Type u\n  /-- The two points of a bipointed type, bundled together as a pair. -/\n  toProd : X × X\n\n"}
{"name":"Bipointed.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Type u\ntoProd : Prod X X\n⊢ Eq (SizeOf.sizeOf { X := X, toProd := toProd }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf X)) (SizeOf.sizeOf toProd))","decl":"/-- The category of bipointed types. -/\nstructure Bipointed : Type (u + 1) where\n  /-- The underlying type of a bipointed type. -/\n  protected X : Type u\n  /-- The two points of a bipointed type, bundled together as a pair. -/\n  toProd : X × X\n\n"}
{"name":"Bipointed.coe_of","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Type u_1\nto_prod : Prod X X\n⊢ Eq (Bipointed.of to_prod).X X","decl":"@[simp]\ntheorem coe_of {X : Type*} (to_prod : X × X) : ↥(of to_prod) = X :=\n  rfl\n\n"}
{"name":"Bipointed.Hom.map_snd","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X Y : Bipointed\nself : X.Hom Y\n⊢ Eq (self.toFun X.toProd.2) Y.toProd.2","decl":"/-- Morphisms in `Bipointed`. -/\n@[ext]\nprotected structure Hom (X Y : Bipointed.{u}) : Type u where\n  /-- The underlying function of a morphism of bipointed types. -/\n  toFun : X → Y\n  map_fst : toFun X.toProd.1 = Y.toProd.1\n  map_snd : toFun X.toProd.2 = Y.toProd.2\n\n"}
{"name":"Bipointed.Hom.ext_iff","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X Y : Bipointed\nx y : X.Hom Y\n⊢ Iff (Eq x y) (Eq x.toFun y.toFun)","decl":"/-- Morphisms in `Bipointed`. -/\n@[ext]\nprotected structure Hom (X Y : Bipointed.{u}) : Type u where\n  /-- The underlying function of a morphism of bipointed types. -/\n  toFun : X → Y\n  map_fst : toFun X.toProd.1 = Y.toProd.1\n  map_snd : toFun X.toProd.2 = Y.toProd.2\n\n"}
{"name":"Bipointed.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X Y : Bipointed\ntoFun : X.X → Y.X\nmap_fst : Eq (toFun X.toProd.1) Y.toProd.1\nmap_snd : Eq (toFun X.toProd.2) Y.toProd.2\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, map_fst := map_fst, map_snd := map_snd }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf map_fst)) (SizeOf.sizeOf map_snd))","decl":"/-- Morphisms in `Bipointed`. -/\n@[ext]\nprotected structure Hom (X Y : Bipointed.{u}) : Type u where\n  /-- The underlying function of a morphism of bipointed types. -/\n  toFun : X → Y\n  map_fst : toFun X.toProd.1 = Y.toProd.1\n  map_snd : toFun X.toProd.2 = Y.toProd.2\n\n"}
{"name":"Bipointed.Hom.map_fst","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X Y : Bipointed\nself : X.Hom Y\n⊢ Eq (self.toFun X.toProd.1) Y.toProd.1","decl":"/-- Morphisms in `Bipointed`. -/\n@[ext]\nprotected structure Hom (X Y : Bipointed.{u}) : Type u where\n  /-- The underlying function of a morphism of bipointed types. -/\n  toFun : X → Y\n  map_fst : toFun X.toProd.1 = Y.toProd.1\n  map_snd : toFun X.toProd.2 = Y.toProd.2\n\n"}
{"name":"Bipointed.Hom.ext","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X Y : Bipointed\nx y : X.Hom Y\ntoFun : Eq x.toFun y.toFun\n⊢ Eq x y","decl":"/-- Morphisms in `Bipointed`. -/\n@[ext]\nprotected structure Hom (X Y : Bipointed.{u}) : Type u where\n  /-- The underlying function of a morphism of bipointed types. -/\n  toFun : X → Y\n  map_fst : toFun X.toProd.1 = Y.toProd.1\n  map_snd : toFun X.toProd.2 = Y.toProd.2\n\n"}
{"name":"Bipointed.Hom.mk.inj","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X Y : Bipointed\ntoFun✝ : X.X → Y.X\nmap_fst✝ : Eq (toFun✝ X.toProd.1) Y.toProd.1\nmap_snd✝ : Eq (toFun✝ X.toProd.2) Y.toProd.2\ntoFun : X.X → Y.X\nmap_fst : Eq (toFun X.toProd.1) Y.toProd.1\nmap_snd : Eq (toFun X.toProd.2) Y.toProd.2\nx✝ : Eq { toFun := toFun✝, map_fst := map_fst✝, map_snd := map_snd✝ } { toFun := toFun, map_fst := map_fst, map_snd := map_snd }\n⊢ Eq toFun✝ toFun","decl":"/-- Morphisms in `Bipointed`. -/\n@[ext]\nprotected structure Hom (X Y : Bipointed.{u}) : Type u where\n  /-- The underlying function of a morphism of bipointed types. -/\n  toFun : X → Y\n  map_fst : toFun X.toProd.1 = Y.toProd.1\n  map_snd : toFun X.toProd.2 = Y.toProd.2\n\n"}
{"name":"Bipointed.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X Y : Bipointed\ntoFun✝ : X.X → Y.X\nmap_fst✝ : Eq (toFun✝ X.toProd.1) Y.toProd.1\nmap_snd✝ : Eq (toFun✝ X.toProd.2) Y.toProd.2\ntoFun : X.X → Y.X\nmap_fst : Eq (toFun X.toProd.1) Y.toProd.1\nmap_snd : Eq (toFun X.toProd.2) Y.toProd.2\n⊢ Eq (Eq { toFun := toFun✝, map_fst := map_fst✝, map_snd := map_snd✝ } { toFun := toFun, map_fst := map_fst, map_snd := map_snd }) (Eq toFun✝ toFun)","decl":"/-- Morphisms in `Bipointed`. -/\n@[ext]\nprotected structure Hom (X Y : Bipointed.{u}) : Type u where\n  /-- The underlying function of a morphism of bipointed types. -/\n  toFun : X → Y\n  map_fst : toFun X.toProd.1 = Y.toProd.1\n  map_snd : toFun X.toProd.2 = Y.toProd.2\n\n"}
{"name":"Bipointed.Hom.id_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Bipointed\na : X.X\n⊢ Eq ((Bipointed.Hom.id X).toFun a) (id a)","decl":"/-- The identity morphism of `X : Bipointed`. -/\n@[simps]\nnonrec def id (X : Bipointed) : Bipointed.Hom X X :=\n  ⟨id, rfl, rfl⟩\n\n"}
{"name":"Bipointed.Hom.comp_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X Y Z : Bipointed\nf : X.Hom Y\ng : Y.Hom Z\na✝ : X.X\n⊢ Eq ((f.comp g).toFun a✝) (Function.comp g.toFun f.toFun a✝)","decl":"/-- Composition of morphisms of `Bipointed`. -/\n@[simps]\ndef comp {X Y Z : Bipointed.{u}} (f : Bipointed.Hom X Y) (g : Bipointed.Hom Y Z) :\n    Bipointed.Hom X Z :=\n  ⟨g.toFun ∘ f.toFun, by rw [Function.comp_apply, f.map_fst, g.map_fst], by\n    rw [Function.comp_apply, f.map_snd, g.map_snd]⟩\n\n"}
{"name":"Bipointed.swap_obj_toProd","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Bipointed\n⊢ Eq (Bipointed.swap.obj X).toProd X.toProd.swap","decl":"/-- Swaps the pointed elements of a bipointed type. `Prod.swap` as a functor. -/\n@[simps]\ndef swap : Bipointed ⥤ Bipointed where\n  obj X := ⟨X, X.toProd.swap⟩\n  map f := ⟨f.toFun, f.map_snd, f.map_fst⟩\n\n"}
{"name":"Bipointed.swap_obj_X","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Bipointed\n⊢ Eq (Bipointed.swap.obj X).X X.X","decl":"/-- Swaps the pointed elements of a bipointed type. `Prod.swap` as a functor. -/\n@[simps]\ndef swap : Bipointed ⥤ Bipointed where\n  obj X := ⟨X, X.toProd.swap⟩\n  map f := ⟨f.toFun, f.map_snd, f.map_fst⟩\n\n"}
{"name":"Bipointed.swap_map_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X✝ Y✝ : Bipointed\nf : Quiver.Hom X✝ Y✝\na✝ : X✝.X\n⊢ Eq ((Bipointed.swap.map f).toFun a✝) (f.toFun a✝)","decl":"/-- Swaps the pointed elements of a bipointed type. `Prod.swap` as a functor. -/\n@[simps]\ndef swap : Bipointed ⥤ Bipointed where\n  obj X := ⟨X, X.toProd.swap⟩\n  map f := ⟨f.toFun, f.map_snd, f.map_fst⟩\n\n"}
{"name":"Bipointed.swapEquiv_functor_obj_toProd","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Bipointed\n⊢ Eq (Bipointed.swapEquiv.functor.obj X).toProd X.toProd.swap","decl":"/-- The equivalence between `Bipointed` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\ndef swapEquiv : Bipointed ≌ Bipointed where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"Bipointed.swapEquiv_functor_map_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X✝ Y✝ : Bipointed\nf : Quiver.Hom X✝ Y✝\na✝ : X✝.X\n⊢ Eq ((Bipointed.swapEquiv.functor.map f).toFun a✝) (f.toFun a✝)","decl":"/-- The equivalence between `Bipointed` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\ndef swapEquiv : Bipointed ≌ Bipointed where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"Bipointed.swapEquiv_unitIso_inv_app_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Bipointed\na : ((CategoryTheory.Functor.id Bipointed).obj X).X\n⊢ Eq ((Bipointed.swapEquiv.unitIso.inv.app X).toFun a) a","decl":"/-- The equivalence between `Bipointed` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\ndef swapEquiv : Bipointed ≌ Bipointed where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"Bipointed.swapEquiv_unitIso_hom_app_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Bipointed\na : ((CategoryTheory.Functor.id Bipointed).obj X).X\n⊢ Eq ((Bipointed.swapEquiv.unitIso.hom.app X).toFun a) a","decl":"/-- The equivalence between `Bipointed` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\ndef swapEquiv : Bipointed ≌ Bipointed where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"Bipointed.swapEquiv_inverse_obj_toProd","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Bipointed\n⊢ Eq (Bipointed.swapEquiv.inverse.obj X).toProd X.toProd.swap","decl":"/-- The equivalence between `Bipointed` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\ndef swapEquiv : Bipointed ≌ Bipointed where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"Bipointed.swapEquiv_counitIso_hom_app_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Bipointed\na : ((Bipointed.swap.comp Bipointed.swap).obj X).X\n⊢ Eq ((Bipointed.swapEquiv.counitIso.hom.app X).toFun a) a","decl":"/-- The equivalence between `Bipointed` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\ndef swapEquiv : Bipointed ≌ Bipointed where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"Bipointed.swapEquiv_functor_obj_X","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Bipointed\n⊢ Eq (Bipointed.swapEquiv.functor.obj X).X X.X","decl":"/-- The equivalence between `Bipointed` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\ndef swapEquiv : Bipointed ≌ Bipointed where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"Bipointed.swapEquiv_inverse_map_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X✝ Y✝ : Bipointed\nf : Quiver.Hom X✝ Y✝\na✝ : X✝.X\n⊢ Eq ((Bipointed.swapEquiv.inverse.map f).toFun a✝) (f.toFun a✝)","decl":"/-- The equivalence between `Bipointed` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\ndef swapEquiv : Bipointed ≌ Bipointed where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"Bipointed.swapEquiv_inverse_obj_X","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Bipointed\n⊢ Eq (Bipointed.swapEquiv.inverse.obj X).X X.X","decl":"/-- The equivalence between `Bipointed` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\ndef swapEquiv : Bipointed ≌ Bipointed where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"Bipointed.swapEquiv_counitIso_inv_app_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Bipointed\na : ((Bipointed.swap.comp Bipointed.swap).obj X).X\n⊢ Eq ((Bipointed.swapEquiv.counitIso.inv.app X).toFun a) a","decl":"/-- The equivalence between `Bipointed` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\ndef swapEquiv : Bipointed ≌ Bipointed where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"Bipointed.swapEquiv_symm","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"⊢ Eq Bipointed.swapEquiv.symm Bipointed.swapEquiv","decl":"@[simp]\ntheorem swapEquiv_symm : swapEquiv.symm = swapEquiv :=\n  rfl\n\n"}
{"name":"bipointedToPointedFst_comp_forget","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"⊢ Eq (bipointedToPointedFst.comp (CategoryTheory.forget Pointed)) (CategoryTheory.forget Bipointed)","decl":"@[simp]\ntheorem bipointedToPointedFst_comp_forget :\n    bipointedToPointedFst ⋙ forget Pointed = forget Bipointed :=\n  rfl\n\n"}
{"name":"bipointedToPointedSnd_comp_forget","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"⊢ Eq (bipointedToPointedSnd.comp (CategoryTheory.forget Pointed)) (CategoryTheory.forget Bipointed)","decl":"@[simp]\ntheorem bipointedToPointedSnd_comp_forget :\n    bipointedToPointedSnd ⋙ forget Pointed = forget Bipointed :=\n  rfl\n\n"}
{"name":"swap_comp_bipointedToPointedFst","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"⊢ Eq (Bipointed.swap.comp bipointedToPointedFst) bipointedToPointedSnd","decl":"@[simp]\ntheorem swap_comp_bipointedToPointedFst :\n    Bipointed.swap ⋙ bipointedToPointedFst = bipointedToPointedSnd :=\n  rfl\n\n"}
{"name":"swap_comp_bipointedToPointedSnd","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"⊢ Eq (Bipointed.swap.comp bipointedToPointedSnd) bipointedToPointedFst","decl":"@[simp]\ntheorem swap_comp_bipointedToPointedSnd :\n    Bipointed.swap ⋙ bipointedToPointedSnd = bipointedToPointedFst :=\n  rfl\n\n"}
{"name":"pointedToBipointedFst_comp_swap","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"⊢ Eq (pointedToBipointedFst.comp Bipointed.swap) pointedToBipointedSnd","decl":"@[simp]\ntheorem pointedToBipointedFst_comp_swap :\n    pointedToBipointedFst ⋙ Bipointed.swap = pointedToBipointedSnd :=\n  rfl\n\n"}
{"name":"pointedToBipointedSnd_comp_swap","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"⊢ Eq (pointedToBipointedSnd.comp Bipointed.swap) pointedToBipointedFst","decl":"@[simp]\ntheorem pointedToBipointedSnd_comp_swap :\n    pointedToBipointedSnd ⋙ Bipointed.swap = pointedToBipointedFst :=\n  rfl\n\n"}
{"name":"pointedToBipointedCompBipointedToPointedFst_inv_app_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Pointed\na : ((CategoryTheory.Functor.id Pointed).obj X).X\n⊢ Eq ((pointedToBipointedCompBipointedToPointedFst.inv.app X).toFun a) a","decl":"/-- `BipointedToPointed_fst` is inverse to `PointedToBipointed`. -/\n@[simps!]\ndef pointedToBipointedCompBipointedToPointedFst :\n    pointedToBipointed ⋙ bipointedToPointedFst ≅ 𝟭 _ :=\n  NatIso.ofComponents fun X =>\n    { hom := ⟨id, rfl⟩\n      inv := ⟨id, rfl⟩ }\n\n"}
{"name":"pointedToBipointedCompBipointedToPointedFst_hom_app_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Pointed\na : ((pointedToBipointed.comp bipointedToPointedFst).obj X).X\n⊢ Eq ((pointedToBipointedCompBipointedToPointedFst.hom.app X).toFun a) a","decl":"/-- `BipointedToPointed_fst` is inverse to `PointedToBipointed`. -/\n@[simps!]\ndef pointedToBipointedCompBipointedToPointedFst :\n    pointedToBipointed ⋙ bipointedToPointedFst ≅ 𝟭 _ :=\n  NatIso.ofComponents fun X =>\n    { hom := ⟨id, rfl⟩\n      inv := ⟨id, rfl⟩ }\n\n"}
{"name":"pointedToBipointedCompBipointedToPointedSnd_inv_app_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Pointed\na : ((CategoryTheory.Functor.id Pointed).obj X).X\n⊢ Eq ((pointedToBipointedCompBipointedToPointedSnd.inv.app X).toFun a) a","decl":"/-- `BipointedToPointed_snd` is inverse to `PointedToBipointed`. -/\n@[simps!]\ndef pointedToBipointedCompBipointedToPointedSnd :\n    pointedToBipointed ⋙ bipointedToPointedSnd ≅ 𝟭 _ :=\n  NatIso.ofComponents fun X =>\n    { hom := ⟨id, rfl⟩\n      inv := ⟨id, rfl⟩ }\n\n"}
{"name":"pointedToBipointedCompBipointedToPointedSnd_hom_app_toFun","module":"Mathlib.CategoryTheory.Category.Bipointed","initialProofState":"X : Pointed\na : ((pointedToBipointed.comp bipointedToPointedSnd).obj X).X\n⊢ Eq ((pointedToBipointedCompBipointedToPointedSnd.hom.app X).toFun a) a","decl":"/-- `BipointedToPointed_snd` is inverse to `PointedToBipointed`. -/\n@[simps!]\ndef pointedToBipointedCompBipointedToPointedSnd :\n    pointedToBipointed ⋙ bipointedToPointedSnd ≅ 𝟭 _ :=\n  NatIso.ofComponents fun X =>\n    { hom := ⟨id, rfl⟩\n      inv := ⟨id, rfl⟩ }\n\n"}
