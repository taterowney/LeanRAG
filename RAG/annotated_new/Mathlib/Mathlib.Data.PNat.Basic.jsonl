{"name":"PNat.instWellFoundedLT","module":"Mathlib.Data.PNat.Basic","initialProofState":"⊢ WellFoundedLT PNat","decl":"instance instWellFoundedLT : WellFoundedLT ℕ+ := WellFoundedRelation.isWellFounded\n\n"}
{"name":"PNat.one_add_natPred","module":"Mathlib.Data.PNat.Basic","initialProofState":"n : PNat\n⊢ Eq (HAdd.hAdd 1 n.natPred) ↑n","decl":"@[simp]\ntheorem one_add_natPred (n : ℕ+) : 1 + n.natPred = n := by\n  rw [natPred, add_tsub_cancel_iff_le.mpr <| show 1 ≤ (n : ℕ) from n.2]\n\n"}
{"name":"PNat.natPred_add_one","module":"Mathlib.Data.PNat.Basic","initialProofState":"n : PNat\n⊢ Eq (HAdd.hAdd n.natPred 1) ↑n","decl":"@[simp]\ntheorem natPred_add_one (n : ℕ+) : n.natPred + 1 = n :=\n  (add_comm _ _).trans n.one_add_natPred\n\n"}
{"name":"PNat.natPred_strictMono","module":"Mathlib.Data.PNat.Basic","initialProofState":"⊢ StrictMono PNat.natPred","decl":"@[mono]\ntheorem natPred_strictMono : StrictMono natPred := fun m _ h => Nat.pred_lt_pred m.2.ne' h\n\n"}
{"name":"PNat.natPred_monotone","module":"Mathlib.Data.PNat.Basic","initialProofState":"⊢ Monotone PNat.natPred","decl":"@[mono]\ntheorem natPred_monotone : Monotone natPred :=\n  natPred_strictMono.monotone\n\n"}
{"name":"PNat.natPred_injective","module":"Mathlib.Data.PNat.Basic","initialProofState":"⊢ Function.Injective PNat.natPred","decl":"theorem natPred_injective : Function.Injective natPred :=\n  natPred_strictMono.injective\n\n"}
{"name":"PNat.natPred_lt_natPred","module":"Mathlib.Data.PNat.Basic","initialProofState":"m n : PNat\n⊢ Iff (LT.lt m.natPred n.natPred) (LT.lt m n)","decl":"@[simp]\ntheorem natPred_lt_natPred {m n : ℕ+} : m.natPred < n.natPred ↔ m < n :=\n  natPred_strictMono.lt_iff_lt\n\n"}
{"name":"PNat.natPred_le_natPred","module":"Mathlib.Data.PNat.Basic","initialProofState":"m n : PNat\n⊢ Iff (LE.le m.natPred n.natPred) (LE.le m n)","decl":"@[simp]\ntheorem natPred_le_natPred {m n : ℕ+} : m.natPred ≤ n.natPred ↔ m ≤ n :=\n  natPred_strictMono.le_iff_le\n\n"}
{"name":"PNat.natPred_inj","module":"Mathlib.Data.PNat.Basic","initialProofState":"m n : PNat\n⊢ Iff (Eq m.natPred n.natPred) (Eq m n)","decl":"@[simp]\ntheorem natPred_inj {m n : ℕ+} : m.natPred = n.natPred ↔ m = n :=\n  natPred_injective.eq_iff\n\n"}
{"name":"PNat.val_ofNat","module":"Mathlib.Data.PNat.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Eq (↑(OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp, norm_cast]\nlemma val_ofNat (n : ℕ) [NeZero n] :\n    ((ofNat(n) : ℕ+) : ℕ) = OfNat.ofNat n :=\n  rfl\n\n"}
{"name":"PNat.mk_ofNat","module":"Mathlib.Data.PNat.Basic","initialProofState":"n : Nat\nh : LT.lt 0 n\n⊢ Eq ⟨OfNat.ofNat n, h⟩ (OfNat.ofNat n)","decl":"@[simp]\nlemma mk_ofNat (n : ℕ) (h : 0 < n) :\n    @Eq ℕ+ (⟨ofNat(n), h⟩ : ℕ+) (haveI : NeZero n := ⟨h.ne'⟩; OfNat.ofNat n) :=\n  rfl\n\n"}
{"name":"Nat.succPNat_strictMono","module":"Mathlib.Data.PNat.Basic","initialProofState":"⊢ StrictMono Nat.succPNat","decl":"@[mono]\ntheorem succPNat_strictMono : StrictMono succPNat := fun _ _ => Nat.succ_lt_succ\n\n"}
{"name":"Nat.succPNat_mono","module":"Mathlib.Data.PNat.Basic","initialProofState":"⊢ Monotone Nat.succPNat","decl":"@[mono]\ntheorem succPNat_mono : Monotone succPNat :=\n  succPNat_strictMono.monotone\n\n"}
{"name":"Nat.succPNat_lt_succPNat","module":"Mathlib.Data.PNat.Basic","initialProofState":"m n : Nat\n⊢ Iff (LT.lt m.succPNat n.succPNat) (LT.lt m n)","decl":"@[simp]\ntheorem succPNat_lt_succPNat {m n : ℕ} : m.succPNat < n.succPNat ↔ m < n :=\n  succPNat_strictMono.lt_iff_lt\n\n"}
{"name":"Nat.succPNat_le_succPNat","module":"Mathlib.Data.PNat.Basic","initialProofState":"m n : Nat\n⊢ Iff (LE.le m.succPNat n.succPNat) (LE.le m n)","decl":"@[simp]\ntheorem succPNat_le_succPNat {m n : ℕ} : m.succPNat ≤ n.succPNat ↔ m ≤ n :=\n  succPNat_strictMono.le_iff_le\n\n"}
{"name":"Nat.succPNat_injective","module":"Mathlib.Data.PNat.Basic","initialProofState":"⊢ Function.Injective Nat.succPNat","decl":"theorem succPNat_injective : Function.Injective succPNat :=\n  succPNat_strictMono.injective\n\n"}
{"name":"Nat.succPNat_inj","module":"Mathlib.Data.PNat.Basic","initialProofState":"n m : Nat\n⊢ Iff (Eq n.succPNat m.succPNat) (Eq n m)","decl":"@[simp]\ntheorem succPNat_inj {n m : ℕ} : succPNat n = succPNat m ↔ n = m :=\n  succPNat_injective.eq_iff\n\n"}
{"name":"PNat.coe_inj","module":"Mathlib.Data.PNat.Basic","initialProofState":"m n : PNat\n⊢ Iff (Eq ↑m ↑n) (Eq m n)","decl":"/-- We now define a long list of structures on `ℕ+` induced by\n similar structures on `ℕ`. Most of these behave in a completely\n obvious way, but there are a few things to be said about\n subtraction, division and powers.\n-/\n@[simp, norm_cast]\ntheorem coe_inj {m n : ℕ+} : (m : ℕ) = n ↔ m = n :=\n  SetCoe.ext_iff\n\n"}
{"name":"PNat.add_coe","module":"Mathlib.Data.PNat.Basic","initialProofState":"m n : PNat\n⊢ Eq (↑(HAdd.hAdd m n)) (HAdd.hAdd ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem add_coe (m n : ℕ+) : ((m + n : ℕ+) : ℕ) = m + n :=\n  rfl\n\n"}
{"name":"PNat.addLeftMono","module":"Mathlib.Data.PNat.Basic","initialProofState":"⊢ AddLeftMono PNat","decl":"instance addLeftMono : AddLeftMono ℕ+ :=\n  Positive.addLeftMono\n\n"}
{"name":"PNat.addLeftStrictMono","module":"Mathlib.Data.PNat.Basic","initialProofState":"⊢ AddLeftStrictMono PNat","decl":"instance addLeftStrictMono : AddLeftStrictMono ℕ+ :=\n  Positive.addLeftStrictMono\n\n"}
{"name":"PNat.addLeftReflectLE","module":"Mathlib.Data.PNat.Basic","initialProofState":"⊢ AddLeftReflectLE PNat","decl":"instance addLeftReflectLE : AddLeftReflectLE ℕ+ :=\n  Positive.addLeftReflectLE\n\n"}
{"name":"PNat.addLeftReflectLT","module":"Mathlib.Data.PNat.Basic","initialProofState":"⊢ AddLeftReflectLT PNat","decl":"instance addLeftReflectLT : AddLeftReflectLT ℕ+ :=\n  Positive.addLeftReflectLT\n\n"}
{"name":"OrderIso.pnatIsoNat_apply","module":"Mathlib.Data.PNat.Basic","initialProofState":"⊢ Eq (⇑OrderIso.pnatIsoNat) PNat.natPred","decl":"/-- The order isomorphism between ℕ and ℕ+ given by `succ`. -/\n@[simps! (config := .asFn) apply]\ndef _root_.OrderIso.pnatIsoNat : ℕ+ ≃o ℕ where\n  toEquiv := Equiv.pnatEquivNat\n  map_rel_iff' := natPred_le_natPred\n\n"}
{"name":"OrderIso.pnatIsoNat_symm_apply","module":"Mathlib.Data.PNat.Basic","initialProofState":"⊢ Eq (⇑OrderIso.pnatIsoNat.symm) Nat.succPNat","decl":"@[simp]\ntheorem _root_.OrderIso.pnatIsoNat_symm_apply : OrderIso.pnatIsoNat.symm = Nat.succPNat :=\n  rfl\n\n"}
{"name":"PNat.lt_add_one_iff","module":"Mathlib.Data.PNat.Basic","initialProofState":"a b : PNat\n⊢ Iff (LT.lt a (HAdd.hAdd b 1)) (LE.le a b)","decl":"theorem lt_add_one_iff : ∀ {a b : ℕ+}, a < b + 1 ↔ a ≤ b := Nat.lt_add_one_iff\n\n"}
{"name":"PNat.add_one_le_iff","module":"Mathlib.Data.PNat.Basic","initialProofState":"a b : PNat\n⊢ Iff (LE.le (HAdd.hAdd a 1) b) (LT.lt a b)","decl":"theorem add_one_le_iff : ∀ {a b : ℕ+}, a + 1 ≤ b ↔ a < b := Nat.add_one_le_iff\n\n"}
{"name":"PNat.bot_eq_one","module":"Mathlib.Data.PNat.Basic","initialProofState":"⊢ Eq Bot.bot 1","decl":"@[simp]\ntheorem bot_eq_one : (⊥ : ℕ+) = 1 :=\n  rfl\n\n"}
{"name":"PNat.recOn_one","module":"Mathlib.Data.PNat.Basic","initialProofState":"p : PNat → Sort u_1\none : p 1\nsucc : (n : PNat) → p n → p (HAdd.hAdd n 1)\n⊢ Eq (PNat.recOn 1 one succ) one","decl":"@[simp]\ntheorem recOn_one {p} (one succ) : @PNat.recOn 1 p one succ = one :=\n  rfl\n\n"}
{"name":"PNat.recOn_succ","module":"Mathlib.Data.PNat.Basic","initialProofState":"n : PNat\np : PNat → Sort u_1\none : p 1\nsucc : (n : PNat) → p n → p (HAdd.hAdd n 1)\n⊢ Eq ((HAdd.hAdd n 1).recOn one succ) (succ n (n.recOn one succ))","decl":"@[simp]\ntheorem recOn_succ (n : ℕ+) {p : ℕ+ → Sort*} (one succ) :\n    @PNat.recOn (n + 1) p one succ = succ n (@PNat.recOn n p one succ) := by\n  cases' n with n h\n  cases n <;> [exact absurd h (by decide); rfl]\n\n"}
{"name":"PNat.ofNat_le_ofNat","module":"Mathlib.Data.PNat.Basic","initialProofState":"m n : Nat\ninst✝¹ : NeZero m\ninst✝ : NeZero n\n⊢ Iff (LE.le (OfNat.ofNat m) (OfNat.ofNat n)) (LE.le (OfNat.ofNat m) (OfNat.ofNat n))","decl":"@[simp]\ntheorem ofNat_le_ofNat {m n : ℕ} [NeZero m] [NeZero n] :\n    (ofNat(m) : ℕ+) ≤ ofNat(n) ↔ OfNat.ofNat m ≤ OfNat.ofNat n :=\n  .rfl\n\n"}
{"name":"PNat.ofNat_lt_ofNat","module":"Mathlib.Data.PNat.Basic","initialProofState":"m n : Nat\ninst✝¹ : NeZero m\ninst✝ : NeZero n\n⊢ Iff (LT.lt (OfNat.ofNat m) (OfNat.ofNat n)) (LT.lt (OfNat.ofNat m) (OfNat.ofNat n))","decl":"@[simp]\ntheorem ofNat_lt_ofNat {m n : ℕ} [NeZero m] [NeZero n] :\n    (ofNat(m) : ℕ+) < ofNat(n) ↔ OfNat.ofNat m < OfNat.ofNat n :=\n  .rfl\n\n"}
{"name":"PNat.ofNat_inj","module":"Mathlib.Data.PNat.Basic","initialProofState":"m n : Nat\ninst✝¹ : NeZero m\ninst✝ : NeZero n\n⊢ Iff (Eq (OfNat.ofNat m) (OfNat.ofNat n)) (Eq (OfNat.ofNat m) (OfNat.ofNat n))","decl":"@[simp]\ntheorem ofNat_inj {m n : ℕ} [NeZero m] [NeZero n] :\n    (ofNat(m) : ℕ+) = ofNat(n) ↔ OfNat.ofNat m = OfNat.ofNat n :=\n  Subtype.mk_eq_mk\n\n"}
{"name":"PNat.mul_coe","module":"Mathlib.Data.PNat.Basic","initialProofState":"m n : PNat\n⊢ Eq (↑(HMul.hMul m n)) (HMul.hMul ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem mul_coe (m n : ℕ+) : ((m * n : ℕ+) : ℕ) = m * n :=\n  rfl\n\n"}
{"name":"PNat.coe_coeMonoidHom","module":"Mathlib.Data.PNat.Basic","initialProofState":"⊢ Eq (⇑PNat.coeMonoidHom) Coe.coe","decl":"@[simp]\ntheorem coe_coeMonoidHom : (coeMonoidHom : ℕ+ → ℕ) = Coe.coe :=\n  rfl\n\n"}
{"name":"PNat.le_one_iff","module":"Mathlib.Data.PNat.Basic","initialProofState":"n : PNat\n⊢ Iff (LE.le n 1) (Eq n 1)","decl":"@[simp]\ntheorem le_one_iff {n : ℕ+} : n ≤ 1 ↔ n = 1 :=\n  le_bot_iff\n\n"}
{"name":"PNat.lt_add_left","module":"Mathlib.Data.PNat.Basic","initialProofState":"n m : PNat\n⊢ LT.lt n (HAdd.hAdd m n)","decl":"theorem lt_add_left (n m : ℕ+) : n < m + n :=\n  lt_add_of_pos_left _ m.2\n\n"}
{"name":"PNat.lt_add_right","module":"Mathlib.Data.PNat.Basic","initialProofState":"n m : PNat\n⊢ LT.lt n (HAdd.hAdd n m)","decl":"theorem lt_add_right (n m : ℕ+) : n < n + m :=\n  (lt_add_left n m).trans_eq (add_comm _ _)\n\n"}
{"name":"PNat.pow_coe","module":"Mathlib.Data.PNat.Basic","initialProofState":"m : PNat\nn : Nat\n⊢ Eq (↑(HPow.hPow m n)) (HPow.hPow (↑m) n)","decl":"@[simp, norm_cast]\ntheorem pow_coe (m : ℕ+) (n : ℕ) : ↑(m ^ n) = (m : ℕ) ^ n :=\n  rfl\n\n"}
{"name":"PNat.one_lt_of_lt","module":"Mathlib.Data.PNat.Basic","initialProofState":"a b : PNat\nhab : LT.lt a b\n⊢ LT.lt 1 b","decl":"/-- b is greater one if any a is less than b -/\ntheorem one_lt_of_lt {a b : ℕ+} (hab : a < b) : 1 < b := bot_le.trans_lt hab\n\n"}
{"name":"PNat.add_one","module":"Mathlib.Data.PNat.Basic","initialProofState":"a : PNat\n⊢ Eq (HAdd.hAdd a 1) (↑a).succPNat","decl":"theorem add_one (a : ℕ+) : a + 1 = succPNat a := rfl\n\n"}
{"name":"PNat.lt_succ_self","module":"Mathlib.Data.PNat.Basic","initialProofState":"a : PNat\n⊢ LT.lt a (↑a).succPNat","decl":"theorem lt_succ_self (a : ℕ+) : a < succPNat a := lt.base a\n\n"}
{"name":"PNat.sub_coe","module":"Mathlib.Data.PNat.Basic","initialProofState":"a b : PNat\n⊢ Eq (↑(HSub.hSub a b)) (ite (LT.lt b a) (HSub.hSub ↑a ↑b) 1)","decl":"theorem sub_coe (a b : ℕ+) : ((a - b : ℕ+) : ℕ) = ite (b < a) (a - b : ℕ) 1 := by\n  change (toPNat' _ : ℕ) = ite _ _ _\n  split_ifs with h\n  · exact toPNat'_coe (tsub_pos_of_lt h)\n  · rw [tsub_eq_zero_iff_le.mpr (le_of_not_gt h : (a : ℕ) ≤ b)]\n    rfl\n\n"}
{"name":"PNat.sub_le","module":"Mathlib.Data.PNat.Basic","initialProofState":"a b : PNat\n⊢ LE.le (HSub.hSub a b) a","decl":"theorem sub_le (a b : ℕ+) : a - b ≤ a := by\n  rw [← coe_le_coe, sub_coe]\n  split_ifs with h\n  · exact Nat.sub_le a b\n  · exact a.2\n\n"}
{"name":"PNat.le_sub_one_of_lt","module":"Mathlib.Data.PNat.Basic","initialProofState":"a b : PNat\nhab : LT.lt a b\n⊢ LE.le a (HSub.hSub b 1)","decl":"theorem le_sub_one_of_lt {a b : ℕ+} (hab : a < b) : a ≤ b - (1 : ℕ+) := by\n  rw [← coe_le_coe, sub_coe]\n  split_ifs with h\n  · exact Nat.le_pred_of_lt hab\n  · exact hab.le.trans (le_of_not_lt h)\n\n"}
{"name":"PNat.add_sub_of_lt","module":"Mathlib.Data.PNat.Basic","initialProofState":"a b : PNat\na✝ : LT.lt a b\n⊢ Eq (HAdd.hAdd a (HSub.hSub b a)) b","decl":"theorem add_sub_of_lt {a b : ℕ+} : a < b → a + (b - a) = b :=\n  fun h =>\n    PNat.eq <| by\n      rw [add_coe, sub_coe, if_pos h]\n      exact add_tsub_cancel_of_le h.le\n\n"}
{"name":"PNat.sub_add_of_lt","module":"Mathlib.Data.PNat.Basic","initialProofState":"a b : PNat\nh : LT.lt b a\n⊢ Eq (HAdd.hAdd (HSub.hSub a b) b) a","decl":"theorem sub_add_of_lt {a b : ℕ+} (h : b < a) : a - b + b = a := by\n  rw [add_comm, add_sub_of_lt h]\n\n"}
{"name":"PNat.add_sub","module":"Mathlib.Data.PNat.Basic","initialProofState":"a b : PNat\n⊢ Eq (HSub.hSub (HAdd.hAdd a b) b) a","decl":"@[simp]\ntheorem add_sub {a b : ℕ+} : a + b - b = a :=\n  add_right_cancel (sub_add_of_lt (lt_add_left _ _))\n\n"}
{"name":"PNat.exists_eq_succ_of_ne_one","module":"Mathlib.Data.PNat.Basic","initialProofState":"n : PNat\nx✝ : Ne n 1\n⊢ Exists fun k => Eq n (HAdd.hAdd k 1)","decl":"/-- If `n : ℕ+` is different from `1`, then it is the successor of some `k : ℕ+`. -/\ntheorem exists_eq_succ_of_ne_one : ∀ {n : ℕ+} (_ : n ≠ 1), ∃ k : ℕ+, n = k + 1\n  | ⟨1, _⟩, h₁ => False.elim <| h₁ rfl\n  | ⟨n + 2, _⟩, _ => ⟨⟨n + 1, by simp⟩, rfl⟩\n\n"}
{"name":"PNat.modDivAux_spec","module":"Mathlib.Data.PNat.Basic","initialProofState":"k : PNat\nr q : Nat\nx✝ : Not (And (Eq r 0) (Eq q 0))\n⊢ Eq (HAdd.hAdd (↑(k.modDivAux r q).1) (HMul.hMul (↑k) (k.modDivAux r q).2)) (HAdd.hAdd r (HMul.hMul (↑k) q))","decl":"/-- Lemmas with div, dvd and mod operations -/\ntheorem modDivAux_spec :\n    ∀ (k : ℕ+) (r q : ℕ) (_ : ¬(r = 0 ∧ q = 0)),\n      ((modDivAux k r q).1 : ℕ) + k * (modDivAux k r q).2 = r + k * q\n  | _, 0, 0, h => (h ⟨rfl, rfl⟩).elim\n  | k, 0, q + 1, _ => by\n    change (k : ℕ) + (k : ℕ) * (q + 1).pred = 0 + (k : ℕ) * (q + 1)\n    rw [Nat.pred_succ, Nat.mul_succ, zero_add, add_comm]\n  | _, _ + 1, _, _ => rfl\n\n"}
{"name":"PNat.mod_add_div","module":"Mathlib.Data.PNat.Basic","initialProofState":"m k : PNat\n⊢ Eq (HAdd.hAdd (↑(m.mod k)) (HMul.hMul (↑k) (m.div k))) ↑m","decl":"theorem mod_add_div (m k : ℕ+) : (mod m k + k * div m k : ℕ) = m := by\n  let h₀ := Nat.mod_add_div (m : ℕ) (k : ℕ)\n  have : ¬((m : ℕ) % (k : ℕ) = 0 ∧ (m : ℕ) / (k : ℕ) = 0) := by\n    rintro ⟨hr, hq⟩\n    rw [hr, hq, mul_zero, zero_add] at h₀\n    exact (m.ne_zero h₀.symm).elim\n  have := modDivAux_spec k ((m : ℕ) % (k : ℕ)) ((m : ℕ) / (k : ℕ)) this\n  exact this.trans h₀\n\n"}
{"name":"PNat.div_add_mod","module":"Mathlib.Data.PNat.Basic","initialProofState":"m k : PNat\n⊢ Eq (HAdd.hAdd (HMul.hMul (↑k) (m.div k)) ↑(m.mod k)) ↑m","decl":"theorem div_add_mod (m k : ℕ+) : (k * div m k + mod m k : ℕ) = m :=\n  (add_comm _ _).trans (mod_add_div _ _)\n\n"}
{"name":"PNat.mod_add_div'","module":"Mathlib.Data.PNat.Basic","initialProofState":"m k : PNat\n⊢ Eq (HAdd.hAdd (↑(m.mod k)) (HMul.hMul (m.div k) ↑k)) ↑m","decl":"theorem mod_add_div' (m k : ℕ+) : (mod m k + div m k * k : ℕ) = m := by\n  rw [mul_comm]\n  exact mod_add_div _ _\n\n"}
{"name":"PNat.div_add_mod'","module":"Mathlib.Data.PNat.Basic","initialProofState":"m k : PNat\n⊢ Eq (HAdd.hAdd (HMul.hMul (m.div k) ↑k) ↑(m.mod k)) ↑m","decl":"theorem div_add_mod' (m k : ℕ+) : (div m k * k + mod m k : ℕ) = m := by\n  rw [mul_comm]\n  exact div_add_mod _ _\n\n"}
{"name":"PNat.mod_le","module":"Mathlib.Data.PNat.Basic","initialProofState":"m k : PNat\n⊢ And (LE.le (m.mod k) m) (LE.le (m.mod k) k)","decl":"theorem mod_le (m k : ℕ+) : mod m k ≤ m ∧ mod m k ≤ k := by\n  change (mod m k : ℕ) ≤ (m : ℕ) ∧ (mod m k : ℕ) ≤ (k : ℕ)\n  rw [mod_coe]\n  split_ifs with h\n  · have hm : (m : ℕ) > 0 := m.pos\n    rw [← Nat.mod_add_div (m : ℕ) (k : ℕ), h, zero_add] at hm ⊢\n    by_cases h₁ : (m : ℕ) / (k : ℕ) = 0\n    · rw [h₁, mul_zero] at hm\n      exact (lt_irrefl _ hm).elim\n    · let h₂ : (k : ℕ) * 1 ≤ k * (m / k) :=\n        -- Porting note: Specified type of `h₂` explicitly because `rw` could not unify\n        -- `succ 0` with `1`.\n        Nat.mul_le_mul_left (k : ℕ) (Nat.succ_le_of_lt (Nat.pos_of_ne_zero h₁))\n      rw [mul_one] at h₂\n      exact ⟨h₂, le_refl (k : ℕ)⟩\n  · exact ⟨Nat.mod_le (m : ℕ) (k : ℕ), (Nat.mod_lt (m : ℕ) k.pos).le⟩\n\n"}
{"name":"PNat.dvd_iff","module":"Mathlib.Data.PNat.Basic","initialProofState":"k m : PNat\n⊢ Iff (Dvd.dvd k m) (Dvd.dvd ↑k ↑m)","decl":"theorem dvd_iff {k m : ℕ+} : k ∣ m ↔ (k : ℕ) ∣ (m : ℕ) := by\n  constructor <;> intro h\n  · rcases h with ⟨_, rfl⟩\n    apply dvd_mul_right\n  · rcases h with ⟨a, h⟩\n    obtain ⟨n, rfl⟩ := Nat.exists_eq_succ_of_ne_zero (n := a) <| by\n      rintro rfl\n      simp only [mul_zero, ne_zero] at h\n    use ⟨n.succ, n.succ_pos⟩\n    rw [← coe_inj, h, mul_coe, mk_coe]\n\n"}
{"name":"PNat.dvd_iff'","module":"Mathlib.Data.PNat.Basic","initialProofState":"k m : PNat\n⊢ Iff (Dvd.dvd k m) (Eq (m.mod k) k)","decl":"theorem dvd_iff' {k m : ℕ+} : k ∣ m ↔ mod m k = k := by\n  rw [dvd_iff]\n  rw [Nat.dvd_iff_mod_eq_zero]; constructor\n  · intro h\n    apply PNat.eq\n    rw [mod_coe, if_pos h]\n  · intro h\n    by_cases h' : (m : ℕ) % (k : ℕ) = 0\n    · exact h'\n    · replace h : (mod m k : ℕ) = (k : ℕ) := congr_arg _ h\n      rw [mod_coe, if_neg h'] at h\n      exact ((Nat.mod_lt (m : ℕ) k.pos).ne h).elim\n\n"}
{"name":"PNat.le_of_dvd","module":"Mathlib.Data.PNat.Basic","initialProofState":"m n : PNat\na✝ : Dvd.dvd m n\n⊢ LE.le m n","decl":"theorem le_of_dvd {m n : ℕ+} : m ∣ n → m ≤ n := by\n  rw [dvd_iff']\n  intro h\n  rw [← h]\n  apply (mod_le n m).left\n\n"}
{"name":"PNat.mul_div_exact","module":"Mathlib.Data.PNat.Basic","initialProofState":"m k : PNat\nh : Dvd.dvd k m\n⊢ Eq (HMul.hMul k (m.divExact k)) m","decl":"theorem mul_div_exact {m k : ℕ+} (h : k ∣ m) : k * divExact m k = m := by\n  apply PNat.eq; rw [mul_coe]\n  change (k : ℕ) * (div m k).succ = m\n  rw [← div_add_mod m k, dvd_iff'.mp h, Nat.mul_succ]\n\n"}
{"name":"PNat.dvd_antisymm","module":"Mathlib.Data.PNat.Basic","initialProofState":"m n : PNat\na✝¹ : Dvd.dvd m n\na✝ : Dvd.dvd n m\n⊢ Eq m n","decl":"theorem dvd_antisymm {m n : ℕ+} : m ∣ n → n ∣ m → m = n := fun hmn hnm =>\n  (le_of_dvd hmn).antisymm (le_of_dvd hnm)\n\n"}
{"name":"PNat.dvd_one_iff","module":"Mathlib.Data.PNat.Basic","initialProofState":"n : PNat\n⊢ Iff (Dvd.dvd n 1) (Eq n 1)","decl":"theorem dvd_one_iff (n : ℕ+) : n ∣ 1 ↔ n = 1 :=\n  ⟨fun h => dvd_antisymm h (one_dvd n), fun h => h.symm ▸ dvd_refl 1⟩\n\n"}
{"name":"PNat.pos_of_div_pos","module":"Mathlib.Data.PNat.Basic","initialProofState":"n : PNat\na : Nat\nh : Dvd.dvd a ↑n\n⊢ LT.lt 0 a","decl":"theorem pos_of_div_pos {n : ℕ+} {a : ℕ} (h : a ∣ n) : 0 < a := by\n  apply pos_iff_ne_zero.2\n  intro hzero\n  rw [hzero] at h\n  exact PNat.ne_zero n (eq_zero_of_zero_dvd h)\n\n"}
