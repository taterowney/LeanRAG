{"name":"Equiv.Perm.decomposeFin_symm_of_refl","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\n⊢ Eq (Equiv.Perm.decomposeFin.symm { fst := p, snd := Equiv.refl (Fin n) }) (Equiv.swap 0 p)","decl":"@[simp]\ntheorem Equiv.Perm.decomposeFin_symm_of_refl {n : ℕ} (p : Fin (n + 1)) :\n    Equiv.Perm.decomposeFin.symm (p, Equiv.refl _) = swap 0 p := by\n  simp [Equiv.Perm.decomposeFin, Equiv.permCongr_def]\n\n"}
{"name":"Equiv.Perm.decomposeFin_symm_of_one","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\n⊢ Eq (Equiv.Perm.decomposeFin.symm { fst := p, snd := 1 }) (Equiv.swap 0 p)","decl":"@[simp]\ntheorem Equiv.Perm.decomposeFin_symm_of_one {n : ℕ} (p : Fin (n + 1)) :\n    Equiv.Perm.decomposeFin.symm (p, 1) = swap 0 p :=\n  Equiv.Perm.decomposeFin_symm_of_refl p\n\n"}
{"name":"Equiv.Perm.decomposeFin_symm_apply_zero","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\ne : Equiv.Perm (Fin n)\n⊢ Eq ((Equiv.Perm.decomposeFin.symm { fst := p, snd := e }) 0) p","decl":"@[simp]\ntheorem Equiv.Perm.decomposeFin_symm_apply_zero {n : ℕ} (p : Fin (n + 1)) (e : Perm (Fin n)) :\n    Equiv.Perm.decomposeFin.symm (p, e) 0 = p := by simp [Equiv.Perm.decomposeFin]\n\n"}
{"name":"Equiv.Perm.decomposeFin_symm_apply_succ","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\ne : Equiv.Perm (Fin n)\np : Fin (HAdd.hAdd n 1)\nx : Fin n\n⊢ Eq ((Equiv.Perm.decomposeFin.symm { fst := p, snd := e }) x.succ) ((Equiv.swap 0 p) (e x).succ)","decl":"@[simp]\ntheorem Equiv.Perm.decomposeFin_symm_apply_succ {n : ℕ} (e : Perm (Fin n)) (p : Fin (n + 1))\n    (x : Fin n) : Equiv.Perm.decomposeFin.symm (p, e) x.succ = swap 0 p (e x).succ := by\n  refine Fin.cases ?_ ?_ p\n  · simp [Equiv.Perm.decomposeFin, EquivFunctor.map]\n  · intro i\n    by_cases h : i = e x\n    · simp [h, Equiv.Perm.decomposeFin, EquivFunctor.map]\n    · simp [h, Fin.succ_ne_zero, Equiv.Perm.decomposeFin, EquivFunctor.map,\n        swap_apply_def, Ne.symm h]\n\n"}
{"name":"Equiv.Perm.decomposeFin_symm_apply_one","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\ne : Equiv.Perm (Fin (HAdd.hAdd n 1))\np : Fin (HAdd.hAdd n 2)\n⊢ Eq ((Equiv.Perm.decomposeFin.symm { fst := p, snd := e }) 1) ((Equiv.swap 0 p) (e 0).succ)","decl":"@[simp]\ntheorem Equiv.Perm.decomposeFin_symm_apply_one {n : ℕ} (e : Perm (Fin (n + 1))) (p : Fin (n + 2)) :\n    Equiv.Perm.decomposeFin.symm (p, e) 1 = swap 0 p (e 0).succ := by\n  rw [← Fin.succ_zero_eq_one, Equiv.Perm.decomposeFin_symm_apply_succ e p 0]\n\n"}
{"name":"Equiv.Perm.decomposeFin.symm_sign","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\ne : Equiv.Perm (Fin n)\n⊢ Eq (Equiv.Perm.sign (Equiv.Perm.decomposeFin.symm { fst := p, snd := e })) (HMul.hMul (ite (Eq p 0) 1 (-1)) (Equiv.Perm.sign e))","decl":"@[simp]\ntheorem Equiv.Perm.decomposeFin.symm_sign {n : ℕ} (p : Fin (n + 1)) (e : Perm (Fin n)) :\n    Perm.sign (Equiv.Perm.decomposeFin.symm (p, e)) = ite (p = 0) 1 (-1) * Perm.sign e := by\n  refine Fin.cases ?_ ?_ p <;> simp [Equiv.Perm.decomposeFin, Fin.succ_ne_zero]\n\n"}
{"name":"Finset.univ_perm_fin_succ","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\n⊢ Eq Finset.univ (Finset.map Equiv.Perm.decomposeFin.symm.toEmbedding Finset.univ)","decl":"/-- The set of all permutations of `Fin (n + 1)` can be constructed by augmenting the set of\npermutations of `Fin n` by each element of `Fin (n + 1)` in turn. -/\ntheorem Finset.univ_perm_fin_succ {n : ℕ} :\n    @Finset.univ (Perm <| Fin n.succ) _ =\n      (Finset.univ : Finset <| Fin n.succ × Perm (Fin n)).map\n        Equiv.Perm.decomposeFin.symm.toEmbedding :=\n  (Finset.univ_map_equiv_to_embedding _).symm\n\n"}
{"name":"finRotate_succ_eq_decomposeFin","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\n⊢ Eq (finRotate n.succ) (Equiv.Perm.decomposeFin.symm { fst := 1, snd := finRotate n })","decl":"theorem finRotate_succ_eq_decomposeFin {n : ℕ} :\n    finRotate n.succ = decomposeFin.symm (1, finRotate n) := by\n  ext i\n  cases n; · simp\n  refine Fin.cases ?_ (fun i => ?_) i\n  · simp\n  rw [coe_finRotate, decomposeFin_symm_apply_succ, if_congr i.succ_eq_last_succ rfl rfl]\n  split_ifs with h\n  · simp [h]\n  · rw [Fin.val_succ, Function.Injective.map_swap Fin.val_injective, Fin.val_succ, coe_finRotate,\n      if_neg h, Fin.val_zero, Fin.val_one,\n      swap_apply_of_ne_of_ne (Nat.succ_ne_zero _) (Nat.succ_succ_ne_one _)]\n\n"}
{"name":"sign_finRotate","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\n⊢ Eq (Equiv.Perm.sign (finRotate (HAdd.hAdd n 1))) (HPow.hPow (-1) n)","decl":"@[simp]\ntheorem sign_finRotate (n : ℕ) : Perm.sign (finRotate (n + 1)) = (-1) ^ n := by\n  induction n with\n  | zero => simp\n  | succ n ih =>\n    rw [finRotate_succ_eq_decomposeFin]\n    simp [ih, pow_succ]\n\n"}
{"name":"support_finRotate","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\n⊢ Eq (finRotate (HAdd.hAdd n 2)).support Finset.univ","decl":"@[simp]\ntheorem support_finRotate {n : ℕ} : support (finRotate (n + 2)) = Finset.univ := by\n  ext\n  simp\n\n"}
{"name":"support_finRotate_of_le","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\nh : LE.le 2 n\n⊢ Eq (finRotate n).support Finset.univ","decl":"theorem support_finRotate_of_le {n : ℕ} (h : 2 ≤ n) : support (finRotate n) = Finset.univ := by\n  obtain ⟨m, rfl⟩ := exists_add_of_le h\n  rw [add_comm, support_finRotate]\n\n"}
{"name":"isCycle_finRotate","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\n⊢ (finRotate (HAdd.hAdd n 2)).IsCycle","decl":"theorem isCycle_finRotate {n : ℕ} : IsCycle (finRotate (n + 2)) := by\n  refine ⟨0, by simp, fun x hx' => ⟨x, ?_⟩⟩\n  clear hx'\n  cases' x with x hx\n  rw [zpow_natCast, Fin.ext_iff, Fin.val_mk]\n  induction' x with x ih; · rfl\n  rw [pow_succ', Perm.mul_apply, coe_finRotate_of_ne_last, ih (lt_trans x.lt_succ_self hx)]\n  rw [Ne, Fin.ext_iff, ih (lt_trans x.lt_succ_self hx), Fin.val_last]\n  exact ne_of_lt (Nat.lt_of_succ_lt_succ hx)\n\n"}
{"name":"isCycle_finRotate_of_le","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\nh : LE.le 2 n\n⊢ (finRotate n).IsCycle","decl":"theorem isCycle_finRotate_of_le {n : ℕ} (h : 2 ≤ n) : IsCycle (finRotate n) := by\n  obtain ⟨m, rfl⟩ := exists_add_of_le h\n  rw [add_comm]\n  exact isCycle_finRotate\n\n"}
{"name":"cycleType_finRotate","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\n⊢ Eq (finRotate (HAdd.hAdd n 2)).cycleType (Singleton.singleton (HAdd.hAdd n 2))","decl":"@[simp]\ntheorem cycleType_finRotate {n : ℕ} : cycleType (finRotate (n + 2)) = {n + 2} := by\n  rw [isCycle_finRotate.cycleType, support_finRotate, ← Fintype.card, Fintype.card_fin]\n  rfl\n\n"}
{"name":"cycleType_finRotate_of_le","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\nh : LE.le 2 n\n⊢ Eq (finRotate n).cycleType (Singleton.singleton n)","decl":"theorem cycleType_finRotate_of_le {n : ℕ} (h : 2 ≤ n) : cycleType (finRotate n) = {n} := by\n  obtain ⟨m, rfl⟩ := exists_add_of_le h\n  rw [add_comm, cycleType_finRotate]\n\n"}
{"name":"Fin.cycleRange_of_gt","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\ni j : Fin n\nh : LT.lt i j\n⊢ Eq (i.cycleRange j) j","decl":"theorem cycleRange_of_gt {n : ℕ} {i j : Fin n} (h : i < j) : cycleRange i j = j := by\n  rw [cycleRange, ofLeftInverse'_eq_ofInjective,\n    ← Function.Embedding.toEquivRange_eq_ofInjective, ← viaFintypeEmbedding,\n    viaFintypeEmbedding_apply_not_mem_range]\n  simpa\n\n"}
{"name":"Fin.cycleRange_of_le","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\ninst✝ : NeZero n\ni j : Fin n\nh : LE.le j i\n⊢ Eq (i.cycleRange j) (ite (Eq j i) 0 (HAdd.hAdd j 1))","decl":"theorem cycleRange_of_le {n : ℕ} [NeZero n] {i j : Fin n} (h : j ≤ i) :\n    cycleRange i j = if j = i then 0 else j + 1 := by\n  cases n\n  · subsingleton\n  have : j = (Fin.castLE (Nat.succ_le_of_lt i.is_lt))\n    ⟨j, lt_of_le_of_lt h (Nat.lt_succ_self i)⟩ := by simp\n  ext\n  erw [this, cycleRange, ofLeftInverse'_eq_ofInjective, ←\n    Function.Embedding.toEquivRange_eq_ofInjective, ← viaFintypeEmbedding,\n    viaFintypeEmbedding_apply_image, Function.Embedding.coeFn_mk,\n    coe_castLE, coe_finRotate]\n  simp only [Fin.ext_iff, val_last, val_mk, val_zero, Fin.eta, castLE_mk]\n  split_ifs with heq\n  · rfl\n  · rw [Fin.val_add_one_of_lt]\n    exact lt_of_lt_of_le (lt_of_le_of_ne h (mt (congr_arg _) heq)) (le_last i)\n\n"}
{"name":"Fin.coe_cycleRange_of_le","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\ni j : Fin n\nh : LE.le j i\n⊢ Eq (↑(i.cycleRange j)) (ite (Eq j i) 0 (HAdd.hAdd (↑j) 1))","decl":"theorem coe_cycleRange_of_le {n : ℕ} {i j : Fin n} (h : j ≤ i) :\n    (cycleRange i j : ℕ) = if j = i then 0 else (j : ℕ) + 1 := by\n  cases' n with n\n  · exact absurd le_rfl i.pos.not_le\n  rw [cycleRange_of_le h]\n  split_ifs with h'\n  · rfl\n  exact\n    val_add_one_of_lt\n      (calc\n        (j : ℕ) < i := Fin.lt_iff_val_lt_val.mp (lt_of_le_of_ne h h')\n        _ ≤ n := Nat.lt_succ_iff.mp i.2)\n\n"}
{"name":"Fin.cycleRange_of_lt","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\ninst✝ : NeZero n\ni j : Fin n\nh : LT.lt j i\n⊢ Eq (i.cycleRange j) (HAdd.hAdd j 1)","decl":"theorem cycleRange_of_lt {n : ℕ} [NeZero n] {i j : Fin n} (h : j < i) : cycleRange i j = j + 1 := by\n  rw [cycleRange_of_le h.le, if_neg h.ne]\n\n"}
{"name":"Fin.coe_cycleRange_of_lt","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\ni j : Fin n\nh : LT.lt j i\n⊢ Eq (↑(i.cycleRange j)) (HAdd.hAdd (↑j) 1)","decl":"theorem coe_cycleRange_of_lt {n : ℕ} {i j : Fin n} (h : j < i) :\n    (cycleRange i j : ℕ) = j + 1 := by rw [coe_cycleRange_of_le h.le, if_neg h.ne]\n\n"}
{"name":"Fin.cycleRange_of_eq","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\ninst✝ : NeZero n\ni j : Fin n\nh : Eq j i\n⊢ Eq (i.cycleRange j) 0","decl":"theorem cycleRange_of_eq {n : ℕ} [NeZero n] {i j : Fin n} (h : j = i) : cycleRange i j = 0 := by\n  rw [cycleRange_of_le h.le, if_pos h]\n\n"}
{"name":"Fin.cycleRange_self","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\ninst✝ : NeZero n\ni : Fin n\n⊢ Eq (i.cycleRange i) 0","decl":"@[simp]\ntheorem cycleRange_self {n : ℕ} [NeZero n] (i : Fin n) : cycleRange i i = 0 :=\n  cycleRange_of_eq rfl\n\n"}
{"name":"Fin.cycleRange_apply","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\ninst✝ : NeZero n\ni j : Fin n\n⊢ Eq (i.cycleRange j) (ite (LT.lt j i) (HAdd.hAdd j 1) (ite (Eq j i) 0 j))","decl":"theorem cycleRange_apply {n : ℕ} [NeZero n] (i j : Fin n) :\n    cycleRange i j = if j < i then j + 1 else if j = i then 0 else j := by\n  split_ifs with h₁ h₂\n  · exact cycleRange_of_lt h₁\n  · exact cycleRange_of_eq h₂\n  · exact cycleRange_of_gt (lt_of_le_of_ne (le_of_not_gt h₁) (Ne.symm h₂))\n\n"}
{"name":"Fin.cycleRange_zero","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Eq (Fin.cycleRange 0) 1","decl":"@[simp]\ntheorem cycleRange_zero (n : ℕ) [NeZero n] : cycleRange (0 : Fin n) = 1 := by\n  ext j\n  rcases (Fin.zero_le' j).eq_or_lt with rfl | hj\n  · simp\n  · rw [cycleRange_of_gt hj, one_apply]\n\n"}
{"name":"Fin.cycleRange_last","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\n⊢ Eq (Fin.last n).cycleRange (finRotate (HAdd.hAdd n 1))","decl":"@[simp]\ntheorem cycleRange_last (n : ℕ) : cycleRange (last n) = finRotate (n + 1) := by\n  ext i\n  rw [coe_cycleRange_of_le (le_last _), coe_finRotate]\n\n"}
{"name":"Fin.cycleRange_mk_zero","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\nh : LT.lt 0 n\n⊢ Eq ⟨0, h⟩.cycleRange 1","decl":"@[simp]\ntheorem cycleRange_mk_zero {n : ℕ} (h : 0 < n) : cycleRange ⟨0, h⟩ = 1 :=\n  have : NeZero n := .of_pos h\n  cycleRange_zero n\n\n"}
{"name":"Fin.cycleRange_zero'","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\nh : LT.lt 0 n\n⊢ Eq ⟨0, h⟩.cycleRange 1","decl":"@[deprecated (since := \"2025-01-28\")]\nalias cycleRange_zero' := cycleRange_mk_zero\n\n"}
{"name":"Fin.sign_cycleRange","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\ni : Fin n\n⊢ Eq (Equiv.Perm.sign i.cycleRange) (HPow.hPow (-1) ↑i)","decl":"@[simp]\ntheorem sign_cycleRange {n : ℕ} (i : Fin n) : Perm.sign (cycleRange i) = (-1) ^ (i : ℕ) := by\n  simp [cycleRange]\n\n"}
{"name":"Fin.succAbove_cycleRange","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\ni j : Fin n\n⊢ Eq (i.succ.succAbove (i.cycleRange j)) ((Equiv.swap 0 i.succ) j.succ)","decl":"@[simp]\ntheorem succAbove_cycleRange {n : ℕ} (i j : Fin n) :\n    i.succ.succAbove (i.cycleRange j) = swap 0 i.succ j.succ := by\n  cases n\n  · rcases j with ⟨_, ⟨⟩⟩\n  rcases lt_trichotomy j i with (hlt | heq | hgt)\n  · have : castSucc (j + 1) = j.succ := by\n      ext\n      rw [coe_castSucc, val_succ, Fin.val_add_one_of_lt (lt_of_lt_of_le hlt i.le_last)]\n    rw [Fin.cycleRange_of_lt hlt, Fin.succAbove_of_castSucc_lt, this, swap_apply_of_ne_of_ne]\n    · apply Fin.succ_ne_zero\n    · exact (Fin.succ_injective _).ne hlt.ne\n    · rw [Fin.lt_iff_val_lt_val]\n      simpa [this] using hlt\n  · rw [heq, Fin.cycleRange_self, Fin.succAbove_of_castSucc_lt, swap_apply_right, Fin.castSucc_zero]\n    · rw [Fin.castSucc_zero]\n      apply Fin.succ_pos\n  · rw [Fin.cycleRange_of_gt hgt, Fin.succAbove_of_le_castSucc, swap_apply_of_ne_of_ne]\n    · apply Fin.succ_ne_zero\n    · apply (Fin.succ_injective _).ne hgt.ne.symm\n    · simpa [Fin.le_iff_val_le_val] using hgt\n\n"}
{"name":"Fin.cycleRange_succAbove","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nj : Fin n\n⊢ Eq (i.cycleRange (i.succAbove j)) j.succ","decl":"@[simp]\ntheorem cycleRange_succAbove {n : ℕ} (i : Fin (n + 1)) (j : Fin n) :\n    i.cycleRange (i.succAbove j) = j.succ := by\n  cases' lt_or_ge (castSucc j) i with h h\n  · rw [Fin.succAbove_of_castSucc_lt _ _ h, Fin.cycleRange_of_lt h, Fin.coeSucc_eq_succ]\n  · rw [Fin.succAbove_of_le_castSucc _ _ h, Fin.cycleRange_of_gt (Fin.le_castSucc_iff.mp h)]\n\n"}
{"name":"Fin.cycleRange_symm_zero","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\ninst✝ : NeZero n\ni : Fin n\n⊢ Eq ((Equiv.symm i.cycleRange) 0) i","decl":"@[simp]\ntheorem cycleRange_symm_zero {n : ℕ} [NeZero n] (i : Fin n) : i.cycleRange.symm 0 = i :=\n  i.cycleRange.injective (by simp)\n\n"}
{"name":"Fin.cycleRange_symm_succ","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nj : Fin n\n⊢ Eq ((Equiv.symm i.cycleRange) j.succ) (i.succAbove j)","decl":"@[simp]\ntheorem cycleRange_symm_succ {n : ℕ} (i : Fin (n + 1)) (j : Fin n) :\n    i.cycleRange.symm j.succ = i.succAbove j :=\n  i.cycleRange.injective (by simp)\n\n"}
{"name":"Fin.isCycle_cycleRange","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\ninst✝ : NeZero n\ni : Fin n\nh0 : Ne i 0\n⊢ i.cycleRange.IsCycle","decl":"theorem isCycle_cycleRange {n : ℕ} [NeZero n] {i : Fin n} (h0 : i ≠ 0) :\n    IsCycle (cycleRange i) := by\n  cases' i with i hi\n  cases i\n  · exact (h0 rfl).elim\n  exact isCycle_finRotate.extendDomain _\n\n"}
{"name":"Fin.cycleType_cycleRange","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\ninst✝ : NeZero n\ni : Fin n\nh0 : Ne i 0\n⊢ Eq i.cycleRange.cycleType (Singleton.singleton (HAdd.hAdd (↑i) 1))","decl":"@[simp]\ntheorem cycleType_cycleRange {n : ℕ} [NeZero n] {i : Fin n} (h0 : i ≠ 0) :\n    cycleType (cycleRange i) = {(i + 1 : ℕ)} := by\n  cases' i with i hi\n  cases i\n  · exact (h0 rfl).elim\n  rw [cycleRange, cycleType_extendDomain]\n  exact cycleType_finRotate\n\n"}
{"name":"Fin.isThreeCycle_cycleRange_two","module":"Mathlib.GroupTheory.Perm.Fin","initialProofState":"n : Nat\n⊢ (Fin.cycleRange 2).IsThreeCycle","decl":"theorem isThreeCycle_cycleRange_two {n : ℕ} : IsThreeCycle (cycleRange 2 : Perm (Fin (n + 3))) := by\n  rw [IsThreeCycle, cycleType_cycleRange] <;> simp [Fin.ext_iff]\n\n"}
