{"name":"Submodule.goursatFst_toAddSubgroup","module":"Mathlib.LinearAlgebra.Goursat","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nL : Submodule R (Prod M N)\n⊢ Eq L.goursatFst.toAddSubgroup L.toAddSubgroup.goursatFst","decl":"lemma goursatFst_toAddSubgroup :\n    (goursatFst L).toAddSubgroup = L.toAddSubgroup.goursatFst := by\n  ext x\n  simp [mem_toAddSubgroup, goursatFst, AddSubgroup.mem_goursatFst]\n\n"}
{"name":"Submodule.goursatSnd_toAddSubgroup","module":"Mathlib.LinearAlgebra.Goursat","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nL : Submodule R (Prod M N)\n⊢ Eq L.goursatSnd.toAddSubgroup L.toAddSubgroup.goursatSnd","decl":"lemma goursatSnd_toAddSubgroup :\n    (goursatSnd L).toAddSubgroup = L.toAddSubgroup.goursatSnd := by\n  ext x\n  simp [mem_toAddSubgroup, goursatSnd, AddSubgroup.mem_goursatSnd]\n\n"}
{"name":"Submodule.goursatFst_prod_goursatSnd_le","module":"Mathlib.LinearAlgebra.Goursat","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nL : Submodule R (Prod M N)\n⊢ LE.le (L.goursatFst.prod L.goursatSnd) L","decl":"variable (L) in\nlemma goursatFst_prod_goursatSnd_le : L.goursatFst.prod L.goursatSnd ≤ L := by\n  simpa only [← toAddSubgroup_le, goursatFst_toAddSubgroup, goursatSnd_toAddSubgroup]\n    using L.toAddSubgroup.goursatFst_prod_goursatSnd_le\n\n"}
{"name":"Submodule.goursat_surjective","module":"Mathlib.LinearAlgebra.Goursat","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nL : Submodule R (Prod M N)\nhL₁ : Function.Surjective (Function.comp Prod.fst ⇑L.subtype)\nhL₂ : Function.Surjective (Function.comp Prod.snd ⇑L.subtype)\n⊢ Exists fun e => Eq (LinearMap.range ((L.goursatFst.mkQ.prodMap L.goursatSnd.mkQ).comp L.subtype)) (↑e).graph","decl":"include hL₁ hL₂ in\n/-- **Goursat's lemma** for a submodule of a product with surjective projections.\n\nIf `L` is a submodule of `M × N` which projects fully on both factors, then there exist submodules\n`M' ≤ M` and `N' ≤ N` such that `M' × N' ≤ L` and the image of `L` in `(M ⧸ M') × (N ⧸ N')` is the\ngraph of an isomorphism of `R`-modules `(M ⧸ M') ≃ (N ⧸ N')`.\n\n`M` and `N` can be explicitly constructed as `L.goursatFst` and `L.goursatSnd` respectively. -/\nlemma goursat_surjective : ∃ e : (M ⧸ L.goursatFst) ≃ₗ[R] N ⧸ L.goursatSnd,\n    LinearMap.range ((L.goursatFst.mkQ.prodMap L.goursatSnd.mkQ).comp L.subtype) = e.graph := by\n  -- apply add-group result\n  obtain ⟨(e : M ⧸ L.goursatFst ≃+ N ⧸ L.goursatSnd), he⟩ :=\n    L.toAddSubgroup.goursat_surjective hL₁ hL₂\n  -- check R-linearity of the map\n  have (r : R) (x : M ⧸ L.goursatFst) : e (r • x) = r • e x := by\n    show (r • x, r • e x) ∈ e.toAddMonoidHom.graph\n    rw [← he, ← Prod.smul_mk]\n    have : (x, e x) ∈ e.toAddMonoidHom.graph := rfl\n    rw [← he, AddMonoidHom.mem_range] at this\n    rcases this with ⟨⟨l, hl⟩, hl'⟩\n    use ⟨r • l, L.smul_mem r hl⟩\n    rw [← hl']\n    rfl\n  -- define the map as an R-linear equiv\n  use { e with map_smul' := this }\n  rw [← toAddSubgroup_injective.eq_iff]\n  convert he using 1\n  ext v\n  rw [mem_toAddSubgroup, mem_graph_iff, Eq.comm]\n  rfl\n\n"}
{"name":"Submodule.goursat","module":"Mathlib.LinearAlgebra.Goursat","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nL : Submodule R (Prod M N)\n⊢ Exists fun M' => Exists fun N' => Exists fun M'' => Exists fun N'' => Exists fun e => Eq L (Submodule.map (M'.subtype.prodMap N'.subtype) (Submodule.comap (M''.mkQ.prodMap N''.mkQ) (↑e).graph))","decl":"/-- **Goursat's lemma** for an arbitrary submodule of a product.\n\nIf `L` is a submodule of `M × N`, then there exist submodules `M'' ≤ M' ≤ M` and `N'' ≤ N' ≤ N` such\nthat `L ≤ M' × N'`, and `L` is (the image in `M × N` of) the preimage of the graph of an `R`-linear\nisomorphism `M' ⧸ M'' ≃ N' ⧸ N''`. -/\nlemma goursat : ∃ (M' : Submodule R M) (N' : Submodule R N) (M'' : Submodule R M')\n    (N'' : Submodule R N') (e : (M' ⧸ M'') ≃ₗ[R] N' ⧸ N''),\n    L = (e.graph.comap <| M''.mkQ.prodMap N''.mkQ).map (M'.subtype.prodMap N'.subtype) := by\n  let M' := L.map (LinearMap.fst ..)\n  let N' := L.map (LinearMap.snd ..)\n  let P : L →ₗ[R] M' := (LinearMap.fst ..).submoduleMap L\n  let Q : L →ₗ[R] N' := (LinearMap.snd ..).submoduleMap L\n  let L' : Submodule R (M' × N') := LinearMap.range (P.prod Q)\n  have hL₁' : Surjective (Prod.fst ∘ L'.subtype) := by\n    simp only [← coe_fst (R := R), ← coe_comp, ← range_eq_top, LinearMap.range_comp, range_subtype]\n    simpa only [L', ← LinearMap.range_comp, fst_prod, range_eq_top] using\n      (LinearMap.fst ..).submoduleMap_surjective L\n  have hL₂' : Surjective (Prod.snd ∘ L'.subtype) := by\n    simp only [← coe_snd (R := R), ← coe_comp, ← range_eq_top, LinearMap.range_comp, range_subtype]\n    simpa only [L', ← LinearMap.range_comp, snd_prod, range_eq_top] using\n      (LinearMap.snd ..).submoduleMap_surjective L\n  obtain ⟨e, he⟩ := goursat_surjective hL₁' hL₂'\n  use M', N', L'.goursatFst, L'.goursatSnd, e\n  rw [← he]\n  simp only [LinearMap.range_comp, Submodule.range_subtype, L']\n  rw [comap_map_eq_self]\n  · ext ⟨m, n⟩\n    constructor\n    · intro hmn\n      simp only [mem_map, LinearMap.mem_range, prod_apply, Subtype.exists, Prod.exists, coe_prodMap,\n        coe_subtype, Prod.map_apply, Prod.mk.injEq, exists_and_right, exists_eq_right_right,\n        exists_eq_right, M', N', fst_apply, snd_apply]\n      exact ⟨⟨n, hmn⟩, ⟨m, hmn⟩, ⟨m, n, hmn, rfl⟩⟩\n    · simp only [mem_map, LinearMap.mem_range, prod_apply, Subtype.exists, Prod.exists,\n        coe_prodMap, coe_subtype, Prod.map_apply, Prod.mk.injEq, exists_and_right,\n        exists_eq_right_right, exists_eq_right, forall_exists_index, Pi.prod]\n      rintro hm hn m₁ n₁ hm₁n₁ ⟨hP, hQ⟩\n      simp only [Subtype.ext_iff] at hP hQ\n      rwa [← hP, ← hQ]\n  · convert goursatFst_prod_goursatSnd_le (range <| P.prod Q)\n    ext ⟨m, n⟩\n    simp_rw [mem_ker, coe_prodMap, Prod.map_apply, Submodule.mem_prod, Prod.zero_eq_mk,\n      Prod.ext_iff, ← mem_ker, ker_mkQ]\n\n"}
