{"name":"CategoryTheory.Subpresheaf.le_sheafify","module":"Mathlib.CategoryTheory.Sites.Subsheaf","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nG : CategoryTheory.Subpresheaf F\n⊢ LE.le G (CategoryTheory.Subpresheaf.sheafify J G)","decl":"theorem Subpresheaf.le_sheafify : G ≤ G.sheafify J := by\n  intro U s hs\n  change _ ∈ J _\n  convert J.top_mem U.unop -- Porting note: `U.unop` can not be inferred now\n  rw [eq_top_iff]\n  rintro V i -\n  exact G.map i.op hs\n\n"}
{"name":"CategoryTheory.Subpresheaf.eq_sheafify","module":"Mathlib.CategoryTheory.Sites.Subsheaf","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nG : CategoryTheory.Subpresheaf F\nh : CategoryTheory.Presieve.IsSheaf J F\nhG : CategoryTheory.Presieve.IsSheaf J G.toPresheaf\n⊢ Eq G (CategoryTheory.Subpresheaf.sheafify J G)","decl":"theorem Subpresheaf.eq_sheafify (h : Presieve.IsSheaf J F) (hG : Presieve.IsSheaf J G.toPresheaf) :\n    G = G.sheafify J := by\n  apply (G.le_sheafify J).antisymm\n  intro U s hs\n  suffices ((hG _ hs).amalgamate _ (G.family_of_elements_compatible s)).1 = s by\n    rw [← this]\n    exact ((hG _ hs).amalgamate _ (G.family_of_elements_compatible s)).2\n  apply (h _ hs).isSeparatedFor.ext\n  intro V i hi\n  exact (congr_arg Subtype.val ((hG _ hs).valid_glue (G.family_of_elements_compatible s) _ hi) :)\n\n"}
{"name":"CategoryTheory.Subpresheaf.sheafify_isSheaf","module":"Mathlib.CategoryTheory.Sites.Subsheaf","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nG : CategoryTheory.Subpresheaf F\nhF : CategoryTheory.Presieve.IsSheaf J F\n⊢ CategoryTheory.Presieve.IsSheaf J (CategoryTheory.Subpresheaf.sheafify J G).toPresheaf","decl":"theorem Subpresheaf.sheafify_isSheaf (hF : Presieve.IsSheaf J F) :\n    Presieve.IsSheaf J (G.sheafify J).toPresheaf := by\n  intro U S hS x hx\n  let S' := Sieve.bind S fun Y f hf => G.sieveOfSection (x f hf).1\n  have := fun (V) (i : V ⟶ U) (hi : S' i) => hi\n  -- Porting note: change to explicit variable so that `choose` can find the correct\n  -- dependent functions. Thus everything follows need two additional explicit variables.\n  choose W i₁ i₂ hi₂ h₁ h₂ using this\n  dsimp [-Sieve.bind_apply] at *\n  let x'' : Presieve.FamilyOfElements F S' := fun V i hi => F.map (i₁ V i hi).op (x _ (hi₂ V i hi))\n  have H : ∀ s, x.IsAmalgamation s ↔ x''.IsAmalgamation s.1 := by\n    intro s\n    constructor\n    · intro H V i hi\n      dsimp only [x'']\n      conv_lhs => rw [← h₂ _ _ hi]\n      rw [← H _ (hi₂ _ _ hi)]\n      exact FunctorToTypes.map_comp_apply F (i₂ _ _ hi).op (i₁ _ _ hi).op _\n    · intro H V i hi\n      refine Subtype.ext ?_\n      apply (hF _ (x i hi).2).isSeparatedFor.ext\n      intro V' i' hi'\n      have hi'' : S' (i' ≫ i) := ⟨_, _, _, hi, hi', rfl⟩\n      have := H _ hi''\n      rw [op_comp, F.map_comp] at this\n      exact this.trans (congr_arg Subtype.val (hx _ _ (hi₂ _ _ hi'') hi (h₂ _ _ hi'')))\n  have : x''.Compatible := by\n    intro V₁ V₂ V₃ g₁ g₂ g₃ g₄ S₁ S₂ e\n    rw [← FunctorToTypes.map_comp_apply, ← FunctorToTypes.map_comp_apply]\n    exact\n      congr_arg Subtype.val\n        (hx (g₁ ≫ i₁ _ _ S₁) (g₂ ≫ i₁ _ _ S₂) (hi₂ _ _ S₁) (hi₂ _ _ S₂)\n        (by simp only [Category.assoc, h₂, e]))\n  obtain ⟨t, ht, ht'⟩ := hF _ (J.bind_covering hS fun V i hi => (x i hi).2) _ this\n  refine ⟨⟨t, _⟩, (H ⟨t, ?_⟩).mpr ht, fun y hy => Subtype.ext (ht' _ ((H _).mp hy))⟩\n  refine J.superset_covering ?_ (J.bind_covering hS fun V i hi => (x i hi).2)\n  intro V i hi\n  dsimp\n  rw [ht _ hi]\n  exact h₁ _ _ hi\n\n"}
{"name":"CategoryTheory.Subpresheaf.eq_sheafify_iff","module":"Mathlib.CategoryTheory.Sites.Subsheaf","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nG : CategoryTheory.Subpresheaf F\nh : CategoryTheory.Presieve.IsSheaf J F\n⊢ Iff (Eq G (CategoryTheory.Subpresheaf.sheafify J G)) (CategoryTheory.Presieve.IsSheaf J G.toPresheaf)","decl":"theorem Subpresheaf.eq_sheafify_iff (h : Presieve.IsSheaf J F) :\n    G = G.sheafify J ↔ Presieve.IsSheaf J G.toPresheaf :=\n  ⟨fun e => e.symm ▸ G.sheafify_isSheaf h, G.eq_sheafify h⟩\n\n"}
{"name":"CategoryTheory.Subpresheaf.isSheaf_iff","module":"Mathlib.CategoryTheory.Sites.Subsheaf","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nG : CategoryTheory.Subpresheaf F\nh : CategoryTheory.Presieve.IsSheaf J F\n⊢ Iff (CategoryTheory.Presieve.IsSheaf J G.toPresheaf) (∀ (U : Opposite C) (s : F.obj U), Membership.mem (J (Opposite.unop U)) (G.sieveOfSection s) → Membership.mem (G.obj U) s)","decl":"theorem Subpresheaf.isSheaf_iff (h : Presieve.IsSheaf J F) :\n    Presieve.IsSheaf J G.toPresheaf ↔\n      ∀ (U) (s : F.obj U), G.sieveOfSection s ∈ J (unop U) → s ∈ G.obj U := by\n  rw [← G.eq_sheafify_iff h]\n  change _ ↔ G.sheafify J ≤ G\n  exact ⟨Eq.ge, (G.le_sheafify J).antisymm⟩\n\n"}
{"name":"CategoryTheory.Subpresheaf.sheafify_sheafify","module":"Mathlib.CategoryTheory.Sites.Subsheaf","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nG : CategoryTheory.Subpresheaf F\nh : CategoryTheory.Presieve.IsSheaf J F\n⊢ Eq (CategoryTheory.Subpresheaf.sheafify J (CategoryTheory.Subpresheaf.sheafify J G)) (CategoryTheory.Subpresheaf.sheafify J G)","decl":"theorem Subpresheaf.sheafify_sheafify (h : Presieve.IsSheaf J F) :\n    (G.sheafify J).sheafify J = G.sheafify J :=\n  ((Subpresheaf.eq_sheafify_iff _ h).mpr <| G.sheafify_isSheaf h).symm\n\n"}
{"name":"CategoryTheory.Subpresheaf.to_sheafifyLift","module":"Mathlib.CategoryTheory.Sites.Subsheaf","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF F' : CategoryTheory.Functor (Opposite C) (Type w)\nG : CategoryTheory.Subpresheaf F\nf : Quiver.Hom G.toPresheaf F'\nh : CategoryTheory.Presieve.IsSheaf J F'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subpresheaf.homOfLe ⋯) (G.sheafifyLift f h)) f","decl":"theorem Subpresheaf.to_sheafifyLift (f : G.toPresheaf ⟶ F') (h : Presieve.IsSheaf J F') :\n    Subpresheaf.homOfLe (G.le_sheafify J) ≫ G.sheafifyLift f h = f := by\n  ext U s\n  apply (h _ ((Subpresheaf.homOfLe (G.le_sheafify J)).app U s).prop).isSeparatedFor.ext\n  intro V i hi\n  have := elementwise_of% f.naturality\n  -- Porting note: filled in some underscores where Lean3 could automatically fill.\n  exact (Presieve.IsSheafFor.valid_glue (h _ ((homOfLe (_ : G ≤ sheafify J G)).app U s).2)\n    ((G.family_of_elements_compatible _).compPresheafMap _) _ hi).trans (this _ _)\n\n"}
{"name":"CategoryTheory.Subpresheaf.to_sheafify_lift_unique","module":"Mathlib.CategoryTheory.Sites.Subsheaf","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF F' : CategoryTheory.Functor (Opposite C) (Type w)\nG : CategoryTheory.Subpresheaf F\nh : CategoryTheory.Presieve.IsSheaf J F'\nl₁ l₂ : Quiver.Hom (CategoryTheory.Subpresheaf.sheafify J G).toPresheaf F'\ne : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subpresheaf.homOfLe ⋯) l₁) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subpresheaf.homOfLe ⋯) l₂)\n⊢ Eq l₁ l₂","decl":"theorem Subpresheaf.to_sheafify_lift_unique (h : Presieve.IsSheaf J F')\n    (l₁ l₂ : (G.sheafify J).toPresheaf ⟶ F')\n    (e : Subpresheaf.homOfLe (G.le_sheafify J) ≫ l₁ = Subpresheaf.homOfLe (G.le_sheafify J) ≫ l₂) :\n    l₁ = l₂ := by\n  ext U ⟨s, hs⟩\n  apply (h _ hs).isSeparatedFor.ext\n  rintro V i hi\n  dsimp at hi\n  rw [← FunctorToTypes.naturality, ← FunctorToTypes.naturality]\n  exact (congr_fun (congr_app e <| op V) ⟨_, hi⟩ :)\n\n"}
{"name":"CategoryTheory.Subpresheaf.sheafify_le","module":"Mathlib.CategoryTheory.Sites.Subsheaf","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nG G' : CategoryTheory.Subpresheaf F\nh : LE.le G G'\nhF : CategoryTheory.Presieve.IsSheaf J F\nhG' : CategoryTheory.Presieve.IsSheaf J G'.toPresheaf\n⊢ LE.le (CategoryTheory.Subpresheaf.sheafify J G) G'","decl":"theorem Subpresheaf.sheafify_le (h : G ≤ G') (hF : Presieve.IsSheaf J F)\n    (hG' : Presieve.IsSheaf J G'.toPresheaf) : G.sheafify J ≤ G' := by\n  intro U x hx\n  convert ((G.sheafifyLift (Subpresheaf.homOfLe h) hG').app U ⟨x, hx⟩).2\n  apply (hF _ hx).isSeparatedFor.ext\n  intro V i hi\n  have :=\n    congr_arg (fun f : G.toPresheaf ⟶ G'.toPresheaf => (NatTrans.app f (op V) ⟨_, hi⟩).1)\n      (G.to_sheafifyLift (Subpresheaf.homOfLe h) hG')\n  convert this.symm\n  rw [← Subpresheaf.nat_trans_naturality]\n  rfl\n\n"}
{"name":"CategoryTheory.Subpresheaf.toRangeSheafify_app_coe","module":"Mathlib.CategoryTheory.Sites.Subsheaf","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF F' : CategoryTheory.Functor (Opposite C) (Type w)\nf : Quiver.Hom F' F\nX : Opposite C\na✝ : F'.obj X\n⊢ Eq ↑((CategoryTheory.Subpresheaf.toRangeSheafify J f).app X a✝) ↑((CategoryTheory.Subpresheaf.toRange f).app X a✝)","decl":"/-- A morphism factors through the sheafification of the image presheaf. -/\n@[simps!]\ndef Subpresheaf.toRangeSheafify (f : F' ⟶ F) : F' ⟶ ((Subpresheaf.range f).sheafify J).toPresheaf :=\n  toRange f ≫ Subpresheaf.homOfLe ((range f).le_sheafify J)\n\n\n"}
{"name":"CategoryTheory.Sheaf.image_val","module":"Mathlib.CategoryTheory.Sites.Subsheaf","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF F' : CategoryTheory.Sheaf J (Type w)\nf : Quiver.Hom F F'\n⊢ Eq (CategoryTheory.Sheaf.image f).val (CategoryTheory.Subpresheaf.sheafify J (CategoryTheory.Subpresheaf.range f.val)).toPresheaf","decl":"/-- The image sheaf of a morphism between sheaves, defined to be the sheafification of\n`image_presheaf`. -/\n@[simps]\ndef Sheaf.image {F F' : Sheaf J (Type w)} (f : F ⟶ F') : Sheaf J (Type w) :=\n  ⟨((Subpresheaf.range f.1).sheafify J).toPresheaf, by\n    rw [isSheaf_iff_isSheaf_of_type]\n    apply Subpresheaf.sheafify_isSheaf\n    rw [← isSheaf_iff_isSheaf_of_type]\n    exact F'.2⟩\n\n"}
{"name":"CategoryTheory.Sheaf.toImage_val","module":"Mathlib.CategoryTheory.Sites.Subsheaf","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF F' : CategoryTheory.Sheaf J (Type w)\nf : Quiver.Hom F F'\n⊢ Eq (CategoryTheory.Sheaf.toImage f).val (CategoryTheory.Subpresheaf.toRangeSheafify J f.val)","decl":"/-- A morphism factors through the image sheaf. -/\n@[simps]\ndef Sheaf.toImage {F F' : Sheaf J (Type w)} (f : F ⟶ F') : F ⟶ Sheaf.image f :=\n  ⟨Subpresheaf.toRangeSheafify J f.1⟩\n\n"}
{"name":"CategoryTheory.Sheaf.imageι_val","module":"Mathlib.CategoryTheory.Sites.Subsheaf","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF F' : CategoryTheory.Sheaf J (Type w)\nf : Quiver.Hom F F'\n⊢ Eq (CategoryTheory.Sheaf.imageι f).val (CategoryTheory.Subpresheaf.sheafify J (CategoryTheory.Subpresheaf.range f.val)).ι","decl":"/-- The inclusion of the image sheaf to the target. -/\n@[simps]\ndef Sheaf.imageι {F F' : Sheaf J (Type w)} (f : F ⟶ F') : Sheaf.image f ⟶ F' :=\n  ⟨Subpresheaf.ι _⟩\n\n\n"}
{"name":"CategoryTheory.Sheaf.toImage_ι_assoc","module":"Mathlib.CategoryTheory.Sites.Subsheaf","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF F' : CategoryTheory.Sheaf J (Type w)\nf : Quiver.Hom F F'\nZ : CategoryTheory.Sheaf J (Type w)\nh : Quiver.Hom F' Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Sheaf.toImage f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Sheaf.imageι f) h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc (attr := simp)]\ntheorem Sheaf.toImage_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :\n    toImage f ≫ imageι f = f := by\n  ext1\n  simp [Subpresheaf.toRangeSheafify]\n\n"}
{"name":"CategoryTheory.Sheaf.toImage_ι","module":"Mathlib.CategoryTheory.Sites.Subsheaf","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF F' : CategoryTheory.Sheaf J (Type w)\nf : Quiver.Hom F F'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Sheaf.toImage f) (CategoryTheory.Sheaf.imageι f)) f","decl":"@[reassoc (attr := simp)]\ntheorem Sheaf.toImage_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :\n    toImage f ≫ imageι f = f := by\n  ext1\n  simp [Subpresheaf.toRangeSheafify]\n\n"}
{"name":"CategoryTheory.instMonoSheafTypeImageι","module":"Mathlib.CategoryTheory.Sites.Subsheaf","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF F' : CategoryTheory.Sheaf J (Type w)\nf : Quiver.Hom F F'\n⊢ CategoryTheory.Mono (CategoryTheory.Sheaf.imageι f)","decl":"instance {F F' : Sheaf J (Type w)} (f : F ⟶ F') : Mono (Sheaf.imageι f) :=\n  (sheafToPresheaf J _).mono_of_mono_map\n    (by\n      dsimp\n      infer_instance)\n\n"}
{"name":"CategoryTheory.instEpiSheafTypeToImage","module":"Mathlib.CategoryTheory.Sites.Subsheaf","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF F' : CategoryTheory.Sheaf J (Type w)\nf : Quiver.Hom F F'\n⊢ CategoryTheory.Epi (CategoryTheory.Sheaf.toImage f)","decl":"instance {F F' : Sheaf J (Type w)} (f : F ⟶ F') : Epi (Sheaf.toImage f) := by\n  refine ⟨@fun G' g₁ g₂ e => ?_⟩\n  ext U ⟨s, hx⟩\n  apply ((isSheaf_iff_isSheaf_of_type J _).mp G'.2 _ hx).isSeparatedFor.ext\n  rintro V i ⟨y, e'⟩\n  change (g₁.val.app _ ≫ G'.val.map _) _ = (g₂.val.app _ ≫ G'.val.map _) _\n  rw [← NatTrans.naturality, ← NatTrans.naturality]\n  have E : (Sheaf.toImage f).val.app (op V) y = (Sheaf.image f).val.map i.op ⟨s, hx⟩ :=\n    Subtype.ext e'\n  have := congr_arg (fun f : F ⟶ G' => (Sheaf.Hom.val f).app _ y) e\n  dsimp at this ⊢\n  convert this <;> exact E.symm\n\n"}
{"name":"CategoryTheory.instHasImagesSheafType","module":"Mathlib.CategoryTheory.Sites.Subsheaf","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\n⊢ CategoryTheory.Limits.HasImages (CategoryTheory.Sheaf J (Type (max v u)))","decl":"instance : Limits.HasImages (Sheaf J (Type max v u)) :=\n  ⟨fun f => ⟨⟨imageFactorization f⟩⟩⟩\n\n"}
{"name":"CategoryTheory.toImageSheaf_ι","module":"Mathlib.CategoryTheory.Sites.Subsheaf","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF F' : CategoryTheory.Sheaf J (Type w)\nf : Quiver.Hom F F'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Sheaf.toImage f) (CategoryTheory.Sheaf.imageι f)) f","decl":"@[deprecated (since := \"2025-01-25\")] alias toImageSheaf_ι := Sheaf.toImage_ι\n\n"}
