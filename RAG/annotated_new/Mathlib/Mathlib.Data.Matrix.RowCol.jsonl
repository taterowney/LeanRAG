{"name":"Matrix.col_apply","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nα : Type v\nι : Type u_6\nw : m → α\ni : m\nj : ι\n⊢ Eq (Matrix.col ι w i j) (w i)","decl":"@[simp]\ntheorem col_apply {ι : Type*} (w : m → α) (i) (j : ι) : col ι w i j = w i :=\n  rfl\n\n"}
{"name":"Matrix.row_apply","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"n : Type u_3\nα : Type v\nι : Type u_6\nv : n → α\ni : ι\nj : n\n⊢ Eq (Matrix.row ι v i j) (v j)","decl":"@[simp]\ntheorem row_apply (v : n → α) (i : ι) (j) : row ι v i j = v j :=\n  rfl\n\n"}
{"name":"Matrix.col_injective","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nα : Type v\nι : Type u_6\ninst✝ : Nonempty ι\n⊢ Function.Injective (Matrix.col ι)","decl":"theorem col_injective [Nonempty ι] : Function.Injective (col ι : (m → α) → Matrix m ι α) := by\n  inhabit ι\n  exact fun _x _y h => funext fun i => congr_fun₂ h i default\n\n"}
{"name":"Matrix.col_inj","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nα : Type v\nι : Type u_6\ninst✝ : Nonempty ι\nv w : m → α\n⊢ Iff (Eq (Matrix.col ι v) (Matrix.col ι w)) (Eq v w)","decl":"@[simp] theorem col_inj [Nonempty ι] {v w : m → α} : col ι v = col ι w ↔ v = w :=\n  col_injective.eq_iff\n\n"}
{"name":"Matrix.col_zero","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nα : Type v\nι : Type u_6\ninst✝ : Zero α\n⊢ Eq (Matrix.col ι 0) 0","decl":"@[simp] theorem col_zero [Zero α] : col ι (0 : m → α) = 0 := rfl\n\n"}
{"name":"Matrix.col_eq_zero","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nα : Type v\nι : Type u_6\ninst✝¹ : Zero α\ninst✝ : Nonempty ι\nv : m → α\n⊢ Iff (Eq (Matrix.col ι v) 0) (Eq v 0)","decl":"@[simp] theorem col_eq_zero [Zero α] [Nonempty ι] (v : m → α) : col ι v = 0 ↔ v = 0 := col_inj\n\n"}
{"name":"Matrix.col_add","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nα : Type v\nι : Type u_6\ninst✝ : Add α\nv w : m → α\n⊢ Eq (Matrix.col ι (HAdd.hAdd v w)) (HAdd.hAdd (Matrix.col ι v) (Matrix.col ι w))","decl":"@[simp]\ntheorem col_add [Add α] (v w : m → α) : col ι (v + w) = col ι v + col ι w := by\n  ext\n  rfl\n\n"}
{"name":"Matrix.col_smul","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nR : Type u_5\nα : Type v\nι : Type u_6\ninst✝ : SMul R α\nx : R\nv : m → α\n⊢ Eq (Matrix.col ι (HSMul.hSMul x v)) (HSMul.hSMul x (Matrix.col ι v))","decl":"@[simp]\ntheorem col_smul [SMul R α] (x : R) (v : m → α) : col ι (x • v) = x • col ι v := by\n  ext\n  rfl\n\n"}
{"name":"Matrix.row_injective","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"n : Type u_3\nα : Type v\nι : Type u_6\ninst✝ : Nonempty ι\n⊢ Function.Injective (Matrix.row ι)","decl":"theorem row_injective [Nonempty ι] : Function.Injective (row ι : (n → α) → Matrix ι n α) := by\n  inhabit ι\n  exact fun _x _y h => funext fun j => congr_fun₂ h default j\n\n"}
{"name":"Matrix.row_inj","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"n : Type u_3\nα : Type v\nι : Type u_6\ninst✝ : Nonempty ι\nv w : n → α\n⊢ Iff (Eq (Matrix.row ι v) (Matrix.row ι w)) (Eq v w)","decl":"@[simp] theorem row_inj [Nonempty ι] {v w : n → α} : row ι v = row ι w ↔ v = w :=\n  row_injective.eq_iff\n\n"}
{"name":"Matrix.row_zero","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"n : Type u_3\nα : Type v\nι : Type u_6\ninst✝ : Zero α\n⊢ Eq (Matrix.row ι 0) 0","decl":"@[simp] theorem row_zero [Zero α] : row ι (0 : n → α) = 0 := rfl\n\n"}
{"name":"Matrix.row_eq_zero","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"n : Type u_3\nα : Type v\nι : Type u_6\ninst✝¹ : Zero α\ninst✝ : Nonempty ι\nv : n → α\n⊢ Iff (Eq (Matrix.row ι v) 0) (Eq v 0)","decl":"@[simp] theorem row_eq_zero [Zero α] [Nonempty ι] (v : n → α) : row ι v = 0 ↔ v = 0 := row_inj\n\n"}
{"name":"Matrix.row_add","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nα : Type v\nι : Type u_6\ninst✝ : Add α\nv w : m → α\n⊢ Eq (Matrix.row ι (HAdd.hAdd v w)) (HAdd.hAdd (Matrix.row ι v) (Matrix.row ι w))","decl":"@[simp]\ntheorem row_add [Add α] (v w : m → α) : row ι (v + w) = row ι v + row ι w := by\n  ext\n  rfl\n\n"}
{"name":"Matrix.row_smul","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nR : Type u_5\nα : Type v\nι : Type u_6\ninst✝ : SMul R α\nx : R\nv : m → α\n⊢ Eq (Matrix.row ι (HSMul.hSMul x v)) (HSMul.hSMul x (Matrix.row ι v))","decl":"@[simp]\ntheorem row_smul [SMul R α] (x : R) (v : m → α) : row ι (x • v) = x • row ι v := by\n  ext\n  rfl\n\n"}
{"name":"Matrix.transpose_col","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nα : Type v\nι : Type u_6\nv : m → α\n⊢ Eq (Matrix.col ι v).transpose (Matrix.row ι v)","decl":"@[simp]\ntheorem transpose_col (v : m → α) : (Matrix.col ι v)ᵀ = Matrix.row ι v := by\n  ext\n  rfl\n\n"}
{"name":"Matrix.transpose_row","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nα : Type v\nι : Type u_6\nv : m → α\n⊢ Eq (Matrix.row ι v).transpose (Matrix.col ι v)","decl":"@[simp]\ntheorem transpose_row (v : m → α) : (Matrix.row ι v)ᵀ = Matrix.col ι v := by\n  ext\n  rfl\n\n"}
{"name":"Matrix.conjTranspose_col","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nα : Type v\nι : Type u_6\ninst✝ : Star α\nv : m → α\n⊢ Eq (Matrix.col ι v).conjTranspose (Matrix.row ι (Star.star v))","decl":"@[simp]\ntheorem conjTranspose_col [Star α] (v : m → α) : (col ι v)ᴴ = row ι (star v) := by\n  ext\n  rfl\n\n"}
{"name":"Matrix.conjTranspose_row","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nα : Type v\nι : Type u_6\ninst✝ : Star α\nv : m → α\n⊢ Eq (Matrix.row ι v).conjTranspose (Matrix.col ι (Star.star v))","decl":"@[simp]\ntheorem conjTranspose_row [Star α] (v : m → α) : (row ι v)ᴴ = col ι (star v) := by\n  ext\n  rfl\n\n"}
{"name":"Matrix.row_vecMul","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nι : Type u_6\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nM : Matrix m n α\nv : m → α\n⊢ Eq (Matrix.row ι (Matrix.vecMul v M)) (HMul.hMul (Matrix.row ι v) M)","decl":"theorem row_vecMul [Fintype m] [NonUnitalNonAssocSemiring α] (M : Matrix m n α) (v : m → α) :\n    Matrix.row ι (v ᵥ* M) = Matrix.row ι v * M := by\n  ext\n  rfl\n\n"}
{"name":"Matrix.col_vecMul","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nι : Type u_6\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nM : Matrix m n α\nv : m → α\n⊢ Eq (Matrix.col ι (Matrix.vecMul v M)) (HMul.hMul (Matrix.row ι v) M).transpose","decl":"theorem col_vecMul [Fintype m] [NonUnitalNonAssocSemiring α] (M : Matrix m n α) (v : m → α) :\n    Matrix.col ι (v ᵥ* M) = (Matrix.row ι v * M)ᵀ := by\n  ext\n  rfl\n\n"}
{"name":"Matrix.col_mulVec","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nι : Type u_6\ninst✝¹ : Fintype n\ninst✝ : NonUnitalNonAssocSemiring α\nM : Matrix m n α\nv : n → α\n⊢ Eq (Matrix.col ι (M.mulVec v)) (HMul.hMul M (Matrix.col ι v))","decl":"theorem col_mulVec [Fintype n] [NonUnitalNonAssocSemiring α] (M : Matrix m n α) (v : n → α) :\n    Matrix.col ι (M *ᵥ v) = M * Matrix.col ι v := by\n  ext\n  rfl\n\n"}
{"name":"Matrix.row_mulVec","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nι : Type u_6\ninst✝¹ : Fintype n\ninst✝ : NonUnitalNonAssocSemiring α\nM : Matrix m n α\nv : n → α\n⊢ Eq (Matrix.row ι (M.mulVec v)) (HMul.hMul M (Matrix.col ι v)).transpose","decl":"theorem row_mulVec [Fintype n] [NonUnitalNonAssocSemiring α] (M : Matrix m n α) (v : n → α) :\n    Matrix.row ι (M *ᵥ v) = (M * Matrix.col ι v)ᵀ := by\n  ext\n  rfl\n\n"}
{"name":"Matrix.row_mulVec_eq_const","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nα : Type v\nι : Type u_6\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nv w : m → α\n⊢ Eq ((Matrix.row ι v).mulVec w) (Function.const ι (dotProduct v w))","decl":"theorem row_mulVec_eq_const [Fintype m] [NonUnitalNonAssocSemiring α] (v w : m → α) :\n    Matrix.row ι v *ᵥ w = Function.const _ (v ⬝ᵥ w) := rfl\n\n"}
{"name":"Matrix.mulVec_col_eq_const","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nα : Type v\nι : Type u_6\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nv w : m → α\n⊢ Eq (Matrix.vecMul v (Matrix.col ι w)) (Function.const ι (dotProduct v w))","decl":"theorem mulVec_col_eq_const [Fintype m] [NonUnitalNonAssocSemiring α] (v w : m → α) :\n    v ᵥ* Matrix.col ι w = Function.const _ (v ⬝ᵥ w) := rfl\n\n"}
{"name":"Matrix.row_mul_col","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nα : Type v\nι : Type u_6\ninst✝² : Fintype m\ninst✝¹ : Mul α\ninst✝ : AddCommMonoid α\nv w : m → α\n⊢ Eq (HMul.hMul (Matrix.row ι v) (Matrix.col ι w)) (Matrix.of fun x x => dotProduct v w)","decl":"theorem row_mul_col [Fintype m] [Mul α] [AddCommMonoid α] (v w : m → α) :\n    row ι v * col ι w = of fun _ _ => v ⬝ᵥ w :=\n  rfl\n\n"}
{"name":"Matrix.row_mul_col_apply","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nα : Type v\nι : Type u_6\ninst✝² : Fintype m\ninst✝¹ : Mul α\ninst✝ : AddCommMonoid α\nv w : m → α\ni j : ι\n⊢ Eq (HMul.hMul (Matrix.row ι v) (Matrix.col ι w) i j) (dotProduct v w)","decl":"@[simp]\ntheorem row_mul_col_apply [Fintype m] [Mul α] [AddCommMonoid α] (v w : m → α) (i j) :\n    (row ι v * col ι w) i j = v ⬝ᵥ w :=\n  rfl\n\n"}
{"name":"Matrix.diag_col_mul_row","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"n : Type u_3\nα : Type v\nι : Type u_6\ninst✝² : Mul α\ninst✝¹ : AddCommMonoid α\ninst✝ : Unique ι\na b : n → α\n⊢ Eq (HMul.hMul (Matrix.col ι a) (Matrix.row ι b)).diag (HMul.hMul a b)","decl":"@[simp]\ntheorem diag_col_mul_row [Mul α] [AddCommMonoid α] [Unique ι] (a b : n → α) :\n    diag (col ι a * row ι b) = a * b := by\n  ext\n  simp [Matrix.mul_apply, col, row]\n\n"}
{"name":"Matrix.vecMulVec_eq","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nι : Type u_6\ninst✝² : Mul α\ninst✝¹ : AddCommMonoid α\ninst✝ : Unique ι\nw : m → α\nv : n → α\n⊢ Eq (Matrix.vecMulVec w v) (HMul.hMul (Matrix.col ι w) (Matrix.row ι v))","decl":"theorem vecMulVec_eq [Mul α] [AddCommMonoid α] [Unique ι] (w : m → α) (v : n → α) :\n    vecMulVec w v = col ι w * row ι v := by\n  ext\n  simp [vecMulVec, mul_apply]\n\n"}
{"name":"Matrix.updateRow_self","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nM : Matrix m n α\ni : m\nb : n → α\ninst✝ : DecidableEq m\n⊢ Eq (M.updateRow i b i) b","decl":"@[simp]\ntheorem updateRow_self [DecidableEq m] : updateRow M i b i = b :=\n  -- Porting note: (implicit arg) added `(β := _)`\n  Function.update_self (β := fun _ => (n → α)) i b M\n\n"}
{"name":"Matrix.updateCol_self","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nM : Matrix m n α\ni : m\nj : n\nc : m → α\ninst✝ : DecidableEq n\n⊢ Eq (M.updateCol j c i j) (c i)","decl":"@[simp]\ntheorem updateCol_self [DecidableEq n] : updateCol M j c i j = c i :=\n  -- Porting note: (implicit arg) added `(β := _)`\n  Function.update_self (β := fun _ => α) j (c i) (M i)\n\n"}
{"name":"Matrix.updateColumn_self","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nM : Matrix m n α\ni : m\nj : n\nc : m → α\ninst✝ : DecidableEq n\n⊢ Eq (M.updateCol j c i j) (c i)","decl":"@[deprecated (since := \"2024-12-11\")] alias updateColumn_self := updateCol_self\n\n"}
{"name":"Matrix.updateRow_ne","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nM : Matrix m n α\ni : m\nb : n → α\ninst✝ : DecidableEq m\ni' : m\ni_ne : Ne i' i\n⊢ Eq (M.updateRow i b i') (M i')","decl":"@[simp]\ntheorem updateRow_ne [DecidableEq m] {i' : m} (i_ne : i' ≠ i) : updateRow M i b i' = M i' :=\n  -- Porting note: (implicit arg) added `(β := _)`\n  Function.update_of_ne (β := fun _ => (n → α)) i_ne b M\n\n"}
{"name":"Matrix.updateCol_ne","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nM : Matrix m n α\ni : m\nj : n\nc : m → α\ninst✝ : DecidableEq n\nj' : n\nj_ne : Ne j' j\n⊢ Eq (M.updateCol j c i j') (M i j')","decl":"@[simp]\ntheorem updateCol_ne [DecidableEq n] {j' : n} (j_ne : j' ≠ j) :\n    updateCol M j c i j' = M i j' :=\n  -- Porting note: (implicit arg) added `(β := _)`\n  Function.update_of_ne (β := fun _ => α) j_ne (c i) (M i)\n\n"}
{"name":"Matrix.updateColumn_ne","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nM : Matrix m n α\ni : m\nj : n\nc : m → α\ninst✝ : DecidableEq n\nj' : n\nj_ne : Ne j' j\n⊢ Eq (M.updateCol j c i j') (M i j')","decl":"@[deprecated (since := \"2024-12-11\")] alias updateColumn_ne := updateCol_ne\n\n"}
{"name":"Matrix.updateRow_apply","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nM : Matrix m n α\ni : m\nj : n\nb : n → α\ninst✝ : DecidableEq m\ni' : m\n⊢ Eq (M.updateRow i b i' j) (ite (Eq i' i) (b j) (M i' j))","decl":"theorem updateRow_apply [DecidableEq m] {i' : m} :\n    updateRow M i b i' j = if i' = i then b j else M i' j := by\n  by_cases h : i' = i\n  · rw [h, updateRow_self, if_pos rfl]\n  · rw [updateRow_ne h, if_neg h]\n\n"}
{"name":"Matrix.updateCol_apply","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nM : Matrix m n α\ni : m\nj : n\nc : m → α\ninst✝ : DecidableEq n\nj' : n\n⊢ Eq (M.updateCol j c i j') (ite (Eq j' j) (c i) (M i j'))","decl":"theorem updateCol_apply [DecidableEq n] {j' : n} :\n    updateCol M j c i j' = if j' = j then c i else M i j' := by\n  by_cases h : j' = j\n  · rw [h, updateCol_self, if_pos rfl]\n  · rw [updateCol_ne h, if_neg h]\n\n"}
{"name":"Matrix.updateColumn_apply","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nM : Matrix m n α\ni : m\nj : n\nc : m → α\ninst✝ : DecidableEq n\nj' : n\n⊢ Eq (M.updateCol j c i j') (ite (Eq j' j) (c i) (M i j'))","decl":"@[deprecated (since := \"2024-12-11\")] alias updateColumn_apply := updateCol_apply\n\n"}
{"name":"Matrix.updateCol_subsingleton","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\ninst✝ : Subsingleton n\nA : Matrix m n R\ni : n\nb : m → R\n⊢ Eq (A.updateCol i b) ((Matrix.col (Fin 1) b).submatrix id (Function.const n 0))","decl":"@[simp]\ntheorem updateCol_subsingleton [Subsingleton n] (A : Matrix m n R) (i : n) (b : m → R) :\n    A.updateCol i b = (col (Fin 1) b).submatrix id (Function.const n 0) := by\n  ext x y\n  simp [updateCol_apply, Subsingleton.elim i y]\n\n"}
{"name":"Matrix.updateColumn_subsingleton","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\ninst✝ : Subsingleton n\nA : Matrix m n R\ni : n\nb : m → R\n⊢ Eq (A.updateCol i b) ((Matrix.col (Fin 1) b).submatrix id (Function.const n 0))","decl":"@[deprecated (since := \"2024-12-11\")] alias updateColumn_subsingleton := updateCol_subsingleton\n\n"}
{"name":"Matrix.updateRow_subsingleton","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\ninst✝ : Subsingleton m\nA : Matrix m n R\ni : m\nb : n → R\n⊢ Eq (A.updateRow i b) ((Matrix.row (Fin 1) b).submatrix (Function.const m 0) id)","decl":"@[simp]\ntheorem updateRow_subsingleton [Subsingleton m] (A : Matrix m n R) (i : m) (b : n → R) :\n    A.updateRow i b = (row (Fin 1) b).submatrix (Function.const m 0) id := by\n  ext x y\n  simp [updateCol_apply, Subsingleton.elim i x]\n\n"}
{"name":"Matrix.map_updateRow","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nβ : Type w\nM : Matrix m n α\ni : m\nb : n → α\ninst✝ : DecidableEq m\nf : α → β\n⊢ Eq ((M.updateRow i b).map f) ((M.map f).updateRow i (Function.comp f b))","decl":"theorem map_updateRow [DecidableEq m] (f : α → β) :\n    map (updateRow M i b) f = updateRow (M.map f) i (f ∘ b) := by\n  ext\n  rw [updateRow_apply, map_apply, map_apply, updateRow_apply]\n  exact apply_ite f _ _ _\n\n"}
{"name":"Matrix.map_updateCol","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nβ : Type w\nM : Matrix m n α\nj : n\nc : m → α\ninst✝ : DecidableEq n\nf : α → β\n⊢ Eq ((M.updateCol j c).map f) ((M.map f).updateCol j (Function.comp f c))","decl":"theorem map_updateCol [DecidableEq n] (f : α → β) :\n    map (updateCol M j c) f = updateCol (M.map f) j (f ∘ c) := by\n  ext\n  rw [updateCol_apply, map_apply, map_apply, updateCol_apply]\n  exact apply_ite f _ _ _\n\n"}
{"name":"Matrix.map_updateColumn","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nβ : Type w\nM : Matrix m n α\nj : n\nc : m → α\ninst✝ : DecidableEq n\nf : α → β\n⊢ Eq ((M.updateCol j c).map f) ((M.map f).updateCol j (Function.comp f c))","decl":"@[deprecated (since := \"2024-12-11\")] alias map_updateColumn := map_updateCol\n\n"}
{"name":"Matrix.updateRow_transpose","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nM : Matrix m n α\nj : n\nc : m → α\ninst✝ : DecidableEq n\n⊢ Eq (M.transpose.updateRow j c) (M.updateCol j c).transpose","decl":"theorem updateRow_transpose [DecidableEq n] : updateRow Mᵀ j c = (updateCol M j c)ᵀ := by\n  ext\n  rw [transpose_apply, updateRow_apply, updateCol_apply]\n  rfl\n\n"}
{"name":"Matrix.updateCol_transpose","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nM : Matrix m n α\ni : m\nb : n → α\ninst✝ : DecidableEq m\n⊢ Eq (M.transpose.updateCol i b) (M.updateRow i b).transpose","decl":"theorem updateCol_transpose [DecidableEq m] : updateCol Mᵀ i b = (updateRow M i b)ᵀ := by\n  ext\n  rw [transpose_apply, updateRow_apply, updateCol_apply]\n  rfl\n\n"}
{"name":"Matrix.updateColumn_transpose","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nM : Matrix m n α\ni : m\nb : n → α\ninst✝ : DecidableEq m\n⊢ Eq (M.transpose.updateCol i b) (M.updateRow i b).transpose","decl":"@[deprecated (since := \"2024-12-11\")] alias updateColumn_transpose := updateCol_transpose\n\n"}
{"name":"Matrix.updateRow_conjTranspose","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nM : Matrix m n α\nj : n\nc : m → α\ninst✝¹ : DecidableEq n\ninst✝ : Star α\n⊢ Eq (M.conjTranspose.updateRow j (Star.star c)) (M.updateCol j c).conjTranspose","decl":"theorem updateRow_conjTranspose [DecidableEq n] [Star α] :\n    updateRow Mᴴ j (star c) = (updateCol M j c)ᴴ := by\n  rw [conjTranspose, conjTranspose, transpose_map, transpose_map, updateRow_transpose,\n    map_updateCol]\n  rfl\n\n"}
{"name":"Matrix.updateCol_conjTranspose","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nM : Matrix m n α\ni : m\nb : n → α\ninst✝¹ : DecidableEq m\ninst✝ : Star α\n⊢ Eq (M.conjTranspose.updateCol i (Star.star b)) (M.updateRow i b).conjTranspose","decl":"theorem updateCol_conjTranspose [DecidableEq m] [Star α] :\n    updateCol Mᴴ i (star b) = (updateRow M i b)ᴴ := by\n  rw [conjTranspose, conjTranspose, transpose_map, transpose_map, updateCol_transpose,\n    map_updateRow]\n  rfl\n\n"}
{"name":"Matrix.updateColumn_conjTranspose","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nM : Matrix m n α\ni : m\nb : n → α\ninst✝¹ : DecidableEq m\ninst✝ : Star α\n⊢ Eq (M.conjTranspose.updateCol i (Star.star b)) (M.updateRow i b).conjTranspose","decl":"@[deprecated (since := \"2024-12-11\")] alias updateColumn_conjTranspose := updateCol_conjTranspose\n\n"}
{"name":"Matrix.updateRow_eq_self","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : DecidableEq m\nA : Matrix m n α\ni : m\n⊢ Eq (A.updateRow i (A i)) A","decl":"@[simp]\ntheorem updateRow_eq_self [DecidableEq m] (A : Matrix m n α) (i : m) : A.updateRow i (A i) = A :=\n  Function.update_eq_self i A\n\n"}
{"name":"Matrix.updateCol_eq_self","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : DecidableEq n\nA : Matrix m n α\ni : n\n⊢ Eq (A.updateCol i fun j => A j i) A","decl":"@[simp]\ntheorem updateCol_eq_self [DecidableEq n] (A : Matrix m n α) (i : n) :\n    (A.updateCol i fun j => A j i) = A :=\n  funext fun j => Function.update_eq_self i (A j)\n\n"}
{"name":"Matrix.updateColumn_eq_self","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : DecidableEq n\nA : Matrix m n α\ni : n\n⊢ Eq (A.updateCol i fun j => A j i) A","decl":"@[deprecated (since := \"2024-12-11\")] alias updateColumn_eq_self := updateCol_eq_self\n\n"}
{"name":"Matrix.diagonal_updateCol_single","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Zero α\nv : n → α\ni : n\nx : α\n⊢ Eq ((Matrix.diagonal v).updateCol i (Pi.single i x)) (Matrix.diagonal (Function.update v i x))","decl":"theorem diagonal_updateCol_single [DecidableEq n] [Zero α] (v : n → α) (i : n) (x : α) :\n    (diagonal v).updateCol i (Pi.single i x) = diagonal (Function.update v i x) := by\n  ext j k\n  obtain rfl | hjk := eq_or_ne j k\n  · rw [diagonal_apply_eq]\n    obtain rfl | hji := eq_or_ne j i\n    · rw [updateCol_self, Pi.single_eq_same, Function.update_self]\n    · rw [updateCol_ne hji, diagonal_apply_eq, Function.update_of_ne hji]\n  · rw [diagonal_apply_ne _ hjk]\n    obtain rfl | hki := eq_or_ne k i\n    · rw [updateCol_self, Pi.single_eq_of_ne hjk]\n    · rw [updateCol_ne hki, diagonal_apply_ne _ hjk]\n\n"}
{"name":"Matrix.diagonal_updateColumn_single","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Zero α\nv : n → α\ni : n\nx : α\n⊢ Eq ((Matrix.diagonal v).updateCol i (Pi.single i x)) (Matrix.diagonal (Function.update v i x))","decl":"@[deprecated (since := \"2024-12-11\")]\nalias diagonal_updateColumn_single := diagonal_updateCol_single\n\n"}
{"name":"Matrix.diagonal_updateRow_single","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Zero α\nv : n → α\ni : n\nx : α\n⊢ Eq ((Matrix.diagonal v).updateRow i (Pi.single i x)) (Matrix.diagonal (Function.update v i x))","decl":"theorem diagonal_updateRow_single [DecidableEq n] [Zero α] (v : n → α) (i : n) (x : α) :\n    (diagonal v).updateRow i (Pi.single i x) = diagonal (Function.update v i x) := by\n  rw [← diagonal_transpose, updateRow_transpose, diagonal_updateCol_single, diagonal_transpose]\n\n"}
{"name":"Matrix.updateRow_submatrix_equiv","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝¹ : DecidableEq l\ninst✝ : DecidableEq m\nA : Matrix m n α\ni : l\nr : o → α\ne : Equiv l m\nf : Equiv o n\n⊢ Eq ((A.submatrix ⇑e ⇑f).updateRow i r) ((A.updateRow (e i) fun j => r (f.symm j)).submatrix ⇑e ⇑f)","decl":"theorem updateRow_submatrix_equiv [DecidableEq l] [DecidableEq m] (A : Matrix m n α) (i : l)\n    (r : o → α) (e : l ≃ m) (f : o ≃ n) :\n    updateRow (A.submatrix e f) i r = (A.updateRow (e i) fun j => r (f.symm j)).submatrix e f := by\n  ext i' j\n  simp only [submatrix_apply, updateRow_apply, Equiv.apply_eq_iff_eq, Equiv.symm_apply_apply]\n\n"}
{"name":"Matrix.submatrix_updateRow_equiv","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝¹ : DecidableEq l\ninst✝ : DecidableEq m\nA : Matrix m n α\ni : m\nr : n → α\ne : Equiv l m\nf : Equiv o n\n⊢ Eq ((A.updateRow i r).submatrix ⇑e ⇑f) ((A.submatrix ⇑e ⇑f).updateRow (e.symm i) fun i => r (f i))","decl":"theorem submatrix_updateRow_equiv [DecidableEq l] [DecidableEq m] (A : Matrix m n α) (i : m)\n    (r : n → α) (e : l ≃ m) (f : o ≃ n) :\n    (A.updateRow i r).submatrix e f = updateRow (A.submatrix e f) (e.symm i) fun i => r (f i) :=\n  Eq.trans (by simp_rw [Equiv.apply_symm_apply]) (updateRow_submatrix_equiv A _ _ e f).symm\n\n"}
{"name":"Matrix.updateCol_submatrix_equiv","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝¹ : DecidableEq o\ninst✝ : DecidableEq n\nA : Matrix m n α\nj : o\nc : l → α\ne : Equiv l m\nf : Equiv o n\n⊢ Eq ((A.submatrix ⇑e ⇑f).updateCol j c) ((A.updateCol (f j) fun i => c (e.symm i)).submatrix ⇑e ⇑f)","decl":"theorem updateCol_submatrix_equiv [DecidableEq o] [DecidableEq n] (A : Matrix m n α) (j : o)\n    (c : l → α) (e : l ≃ m) (f : o ≃ n) : updateCol (A.submatrix e f) j c =\n    (A.updateCol (f j) fun i => c (e.symm i)).submatrix e f := by\n  simpa only [← transpose_submatrix, updateRow_transpose] using\n    congr_arg transpose (updateRow_submatrix_equiv Aᵀ j c f e)\n\n"}
{"name":"Matrix.updateColumn_submatrix_equiv","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝¹ : DecidableEq o\ninst✝ : DecidableEq n\nA : Matrix m n α\nj : o\nc : l → α\ne : Equiv l m\nf : Equiv o n\n⊢ Eq ((A.submatrix ⇑e ⇑f).updateCol j c) ((A.updateCol (f j) fun i => c (e.symm i)).submatrix ⇑e ⇑f)","decl":"@[deprecated (since := \"2024-12-11\")]\nalias updateColumn_submatrix_equiv := updateCol_submatrix_equiv\n\n"}
{"name":"Matrix.submatrix_updateCol_equiv","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝¹ : DecidableEq o\ninst✝ : DecidableEq n\nA : Matrix m n α\nj : n\nc : m → α\ne : Equiv l m\nf : Equiv o n\n⊢ Eq ((A.updateCol j c).submatrix ⇑e ⇑f) ((A.submatrix ⇑e ⇑f).updateCol (f.symm j) fun i => c (e i))","decl":"theorem submatrix_updateCol_equiv [DecidableEq o] [DecidableEq n] (A : Matrix m n α) (j : n)\n    (c : m → α) (e : l ≃ m) (f : o ≃ n) : (A.updateCol j c).submatrix e f =\n    updateCol (A.submatrix e f) (f.symm j) fun i => c (e i) :=\n  Eq.trans (by simp_rw [Equiv.apply_symm_apply]) (updateCol_submatrix_equiv A _ _ e f).symm\n\n"}
{"name":"Matrix.submatrix_updateColumn_equiv","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝¹ : DecidableEq o\ninst✝ : DecidableEq n\nA : Matrix m n α\nj : n\nc : m → α\ne : Equiv l m\nf : Equiv o n\n⊢ Eq ((A.updateCol j c).submatrix ⇑e ⇑f) ((A.submatrix ⇑e ⇑f).updateCol (f.symm j) fun i => c (e i))","decl":"@[deprecated (since := \"2024-12-11\")]\nalias submatrix_updateColumn_equiv := submatrix_updateCol_equiv\n\n"}
{"name":"Matrix.updateRow_reindex","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝¹ : DecidableEq l\ninst✝ : DecidableEq m\nA : Matrix m n α\ni : l\nr : o → α\ne : Equiv m l\nf : Equiv n o\n⊢ Eq (((Matrix.reindex e f) A).updateRow i r) ((Matrix.reindex e f) (A.updateRow (e.symm i) fun j => r (f j)))","decl":"theorem updateRow_reindex [DecidableEq l] [DecidableEq m] (A : Matrix m n α) (i : l) (r : o → α)\n    (e : m ≃ l) (f : n ≃ o) :\n    updateRow (reindex e f A) i r = reindex e f (A.updateRow (e.symm i) fun j => r (f j)) :=\n  updateRow_submatrix_equiv _ _ _ _ _\n\n"}
{"name":"Matrix.reindex_updateRow","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝¹ : DecidableEq l\ninst✝ : DecidableEq m\nA : Matrix m n α\ni : m\nr : n → α\ne : Equiv m l\nf : Equiv n o\n⊢ Eq ((Matrix.reindex e f) (A.updateRow i r)) (((Matrix.reindex e f) A).updateRow (e i) fun i => r (f.symm i))","decl":"theorem reindex_updateRow [DecidableEq l] [DecidableEq m] (A : Matrix m n α) (i : m) (r : n → α)\n    (e : m ≃ l) (f : n ≃ o) :\n    reindex e f (A.updateRow i r) = updateRow (reindex e f A) (e i) fun i => r (f.symm i) :=\n  submatrix_updateRow_equiv _ _ _ _ _\n\n"}
{"name":"Matrix.updateCol_reindex","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝¹ : DecidableEq o\ninst✝ : DecidableEq n\nA : Matrix m n α\nj : o\nc : l → α\ne : Equiv m l\nf : Equiv n o\n⊢ Eq (((Matrix.reindex e f) A).updateCol j c) ((Matrix.reindex e f) (A.updateCol (f.symm j) fun i => c (e i)))","decl":"theorem updateCol_reindex [DecidableEq o] [DecidableEq n] (A : Matrix m n α) (j : o) (c : l → α)\n    (e : m ≃ l) (f : n ≃ o) :\n    updateCol (reindex e f A) j c = reindex e f (A.updateCol (f.symm j) fun i => c (e i)) :=\n  updateCol_submatrix_equiv _ _ _ _ _\n\n"}
{"name":"Matrix.updateColumn_reindex","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝¹ : DecidableEq o\ninst✝ : DecidableEq n\nA : Matrix m n α\nj : o\nc : l → α\ne : Equiv m l\nf : Equiv n o\n⊢ Eq (((Matrix.reindex e f) A).updateCol j c) ((Matrix.reindex e f) (A.updateCol (f.symm j) fun i => c (e i)))","decl":"@[deprecated (since := \"2024-12-11\")] alias updateColumn_reindex := updateCol_reindex\n\n"}
{"name":"Matrix.reindex_updateCol","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝¹ : DecidableEq o\ninst✝ : DecidableEq n\nA : Matrix m n α\nj : n\nc : m → α\ne : Equiv m l\nf : Equiv n o\n⊢ Eq ((Matrix.reindex e f) (A.updateCol j c)) (((Matrix.reindex e f) A).updateCol (f j) fun i => c (e.symm i))","decl":"theorem reindex_updateCol [DecidableEq o] [DecidableEq n] (A : Matrix m n α) (j : n) (c : m → α)\n    (e : m ≃ l) (f : n ≃ o) :\n    reindex e f (A.updateCol j c) = updateCol (reindex e f A) (f j) fun i => c (e.symm i) :=\n  submatrix_updateCol_equiv _ _ _ _ _\n\n"}
{"name":"Matrix.reindex_updateColumn","module":"Mathlib.Data.Matrix.RowCol","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝¹ : DecidableEq o\ninst✝ : DecidableEq n\nA : Matrix m n α\nj : n\nc : m → α\ne : Equiv m l\nf : Equiv n o\n⊢ Eq ((Matrix.reindex e f) (A.updateCol j c)) (((Matrix.reindex e f) A).updateCol (f j) fun i => c (e.symm i))","decl":"@[deprecated (since := \"2024-12-11\")] alias reindex_updateColumn := reindex_updateCol\n\n"}
