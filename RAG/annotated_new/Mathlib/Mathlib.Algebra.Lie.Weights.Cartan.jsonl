{"name":"LieAlgebra.zero_rootSpace_eq_top_of_nilpotent","module":"Mathlib.Algebra.Lie.Weights.Cartan","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : LieRing.IsNilpotent L\n⊢ Eq (LieAlgebra.rootSpace Top.top 0) Top.top","decl":"theorem zero_rootSpace_eq_top_of_nilpotent [LieRing.IsNilpotent L] :\n    rootSpace (⊤ : LieSubalgebra R L) 0 = ⊤ :=\n  zero_genWeightSpace_eq_top_of_nilpotent L\n\n"}
{"name":"LieAlgebra.rootSpace_comap_eq_genWeightSpace","module":"Mathlib.Algebra.Lie.Weights.Cartan","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\nH : LieSubalgebra R L\ninst✝ : LieRing.IsNilpotent (Subtype fun x => Membership.mem H x)\nχ : (Subtype fun x => Membership.mem H x) → R\n⊢ Eq (LieSubmodule.comap H.incl' (LieAlgebra.rootSpace H χ)) (LieModule.genWeightSpace (Subtype fun x => Membership.mem H x) χ)","decl":"@[simp]\ntheorem rootSpace_comap_eq_genWeightSpace (χ : H → R) :\n    (rootSpace H χ).comap H.incl' = genWeightSpace H χ :=\n  comap_genWeightSpace_eq_of_injective Subtype.coe_injective\n\n"}
{"name":"LieAlgebra.lie_mem_genWeightSpace_of_mem_genWeightSpace","module":"Mathlib.Algebra.Lie.Weights.Cartan","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\nH : LieSubalgebra R L\ninst✝⁴ : LieRing.IsNilpotent (Subtype fun x => Membership.mem H x)\nM : Type u_3\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nχ₁ χ₂ : (Subtype fun x => Membership.mem H x) → R\nx : L\nm : M\nhx : Membership.mem (LieAlgebra.rootSpace H χ₁) x\nhm : Membership.mem (LieModule.genWeightSpace M χ₂) m\n⊢ Membership.mem (LieModule.genWeightSpace M (HAdd.hAdd χ₁ χ₂)) (Bracket.bracket x m)","decl":"theorem lie_mem_genWeightSpace_of_mem_genWeightSpace {χ₁ χ₂ : H → R} {x : L} {m : M}\n    (hx : x ∈ rootSpace H χ₁) (hm : m ∈ genWeightSpace M χ₂) :\n    ⁅x, m⁆ ∈ genWeightSpace M (χ₁ + χ₂) := by\n  rw [genWeightSpace, LieSubmodule.mem_iInf]\n  intro y\n  replace hx : x ∈ genWeightSpaceOf L (χ₁ y) y := by\n    rw [rootSpace, genWeightSpace, LieSubmodule.mem_iInf] at hx; exact hx y\n  replace hm : m ∈ genWeightSpaceOf M (χ₂ y) y := by\n    rw [genWeightSpace, LieSubmodule.mem_iInf] at hm; exact hm y\n  exact lie_mem_maxGenEigenspace_toEnd hx hm\n\n"}
{"name":"LieAlgebra.toEnd_pow_apply_mem","module":"Mathlib.Algebra.Lie.Weights.Cartan","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\nH : LieSubalgebra R L\ninst✝⁴ : LieRing.IsNilpotent (Subtype fun x => Membership.mem H x)\nM : Type u_3\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nχ₁ χ₂ : (Subtype fun x => Membership.mem H x) → R\nx : L\nm : M\nhx : Membership.mem (LieAlgebra.rootSpace H χ₁) x\nhm : Membership.mem (LieModule.genWeightSpace M χ₂) m\nn : Nat\n⊢ Membership.mem (LieModule.genWeightSpace M (HAdd.hAdd (HSMul.hSMul n χ₁) χ₂)) ((HPow.hPow ((LieModule.toEnd R L M) x) n) m)","decl":"lemma toEnd_pow_apply_mem {χ₁ χ₂ : H → R} {x : L} {m : M}\n    (hx : x ∈ rootSpace H χ₁) (hm : m ∈ genWeightSpace M χ₂) (n) :\n    (toEnd R L M x ^ n : Module.End R M) m ∈ genWeightSpace M (n • χ₁ + χ₂) := by\n  induction n with\n  | zero => simpa using hm\n  | succ n IH =>\n    simp only [pow_succ', LinearMap.mul_apply, toEnd_apply_apply,\n      Nat.cast_add, Nat.cast_one, rootSpace]\n    convert lie_mem_genWeightSpace_of_mem_genWeightSpace hx IH using 2\n    rw [succ_nsmul, ← add_assoc, add_comm (n • _)]\n\n"}
{"name":"LieAlgebra.coe_rootSpaceWeightSpaceProduct_tmul","module":"Mathlib.Algebra.Lie.Weights.Cartan","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\nH : LieSubalgebra R L\ninst✝⁴ : LieRing.IsNilpotent (Subtype fun x => Membership.mem H x)\nM : Type u_3\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nχ₁ χ₂ χ₃ : (Subtype fun x => Membership.mem H x) → R\nhχ : Eq (HAdd.hAdd χ₁ χ₂) χ₃\nx : Subtype fun x => Membership.mem (LieAlgebra.rootSpace H χ₁) x\nm : Subtype fun x => Membership.mem (LieModule.genWeightSpace M χ₂) x\n⊢ Eq (↑((LieAlgebra.rootSpaceWeightSpaceProduct R L H M χ₁ χ₂ χ₃ hχ) (TensorProduct.tmul R x m))) (Bracket.bracket ↑x ↑m)","decl":"@[simp]\ntheorem coe_rootSpaceWeightSpaceProduct_tmul (χ₁ χ₂ χ₃ : H → R) (hχ : χ₁ + χ₂ = χ₃)\n    (x : rootSpace H χ₁) (m : genWeightSpace M χ₂) :\n    (rootSpaceWeightSpaceProduct R L H M χ₁ χ₂ χ₃ hχ (x ⊗ₜ m) : M) = ⁅(x : L), (m : M)⁆ := by\n  simp only [rootSpaceWeightSpaceProduct, rootSpaceWeightSpaceProductAux, coe_liftLie_eq_lift_coe,\n    AddHom.toFun_eq_coe, LinearMap.coe_toAddHom, lift_apply, LinearMap.coe_mk, AddHom.coe_mk,\n    Submodule.coe_mk]\n\n"}
{"name":"LieAlgebra.mapsTo_toEnd_genWeightSpace_add_of_mem_rootSpace","module":"Mathlib.Algebra.Lie.Weights.Cartan","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\nH : LieSubalgebra R L\ninst✝⁴ : LieRing.IsNilpotent (Subtype fun x => Membership.mem H x)\nM : Type u_3\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nα χ : (Subtype fun x => Membership.mem H x) → R\nx : L\nhx : Membership.mem (LieAlgebra.rootSpace H α) x\n⊢ Set.MapsTo ⇑((LieModule.toEnd R L M) x) ↑(LieModule.genWeightSpace M χ) ↑(LieModule.genWeightSpace M (HAdd.hAdd α χ))","decl":"theorem mapsTo_toEnd_genWeightSpace_add_of_mem_rootSpace (α χ : H → R)\n    {x : L} (hx : x ∈ rootSpace H α) :\n    MapsTo (toEnd R L M x) (genWeightSpace M χ) (genWeightSpace M (α + χ)) := by\n  intro m hm\n  let x' : rootSpace H α := ⟨x, hx⟩\n  let m' : genWeightSpace M χ := ⟨m, hm⟩\n  exact (rootSpaceWeightSpaceProduct R L H M α χ (α + χ) rfl (x' ⊗ₜ m')).property\n\n"}
{"name":"LieAlgebra.rootSpaceProduct_def","module":"Mathlib.Algebra.Lie.Weights.Cartan","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\nH : LieSubalgebra R L\ninst✝ : LieRing.IsNilpotent (Subtype fun x => Membership.mem H x)\n⊢ Eq (LieAlgebra.rootSpaceProduct R L H) (LieAlgebra.rootSpaceWeightSpaceProduct R L H L)","decl":"@[simp]\ntheorem rootSpaceProduct_def : rootSpaceProduct R L H = rootSpaceWeightSpaceProduct R L H L := rfl\n\n"}
{"name":"LieAlgebra.rootSpaceProduct_tmul","module":"Mathlib.Algebra.Lie.Weights.Cartan","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\nH : LieSubalgebra R L\ninst✝ : LieRing.IsNilpotent (Subtype fun x => Membership.mem H x)\nχ₁ χ₂ χ₃ : (Subtype fun x => Membership.mem H x) → R\nhχ : Eq (HAdd.hAdd χ₁ χ₂) χ₃\nx : Subtype fun x => Membership.mem (LieAlgebra.rootSpace H χ₁) x\ny : Subtype fun x => Membership.mem (LieAlgebra.rootSpace H χ₂) x\n⊢ Eq (↑((LieAlgebra.rootSpaceProduct R L H χ₁ χ₂ χ₃ hχ) (TensorProduct.tmul R x y))) (Bracket.bracket ↑x ↑y)","decl":"theorem rootSpaceProduct_tmul\n    (χ₁ χ₂ χ₃ : H → R) (hχ : χ₁ + χ₂ = χ₃) (x : rootSpace H χ₁) (y : rootSpace H χ₂) :\n    (rootSpaceProduct R L H χ₁ χ₂ χ₃ hχ (x ⊗ₜ y) : L) = ⁅(x : L), (y : L)⁆ := by\n  simp only [rootSpaceProduct_def, coe_rootSpaceWeightSpaceProduct_tmul]\n\n"}
{"name":"LieAlgebra.coe_zeroRootSubalgebra","module":"Mathlib.Algebra.Lie.Weights.Cartan","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\nH : LieSubalgebra R L\ninst✝ : LieRing.IsNilpotent (Subtype fun x => Membership.mem H x)\n⊢ Eq (LieAlgebra.zeroRootSubalgebra R L H).toSubmodule ↑(LieAlgebra.rootSpace H 0)","decl":"@[simp]\ntheorem coe_zeroRootSubalgebra : (zeroRootSubalgebra R L H : Submodule R L) = rootSpace H 0 := rfl\n\n"}
{"name":"LieAlgebra.mem_zeroRootSubalgebra","module":"Mathlib.Algebra.Lie.Weights.Cartan","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\nH : LieSubalgebra R L\ninst✝ : LieRing.IsNilpotent (Subtype fun x => Membership.mem H x)\nx : L\n⊢ Iff (Membership.mem (LieAlgebra.zeroRootSubalgebra R L H) x) (∀ (y : Subtype fun x => Membership.mem H x), Exists fun k => Eq ((HPow.hPow ((LieModule.toEnd R (Subtype fun x => Membership.mem H x) L) y) k) x) 0)","decl":"theorem mem_zeroRootSubalgebra (x : L) :\n    x ∈ zeroRootSubalgebra R L H ↔ ∀ y : H, ∃ k : ℕ, (toEnd R H L y ^ k) x = 0 := by\n  change x ∈ rootSpace H 0 ↔ _\n  simp only [mem_genWeightSpace, Pi.zero_apply, zero_smul, sub_zero]\n\n"}
{"name":"LieAlgebra.toLieSubmodule_le_rootSpace_zero","module":"Mathlib.Algebra.Lie.Weights.Cartan","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\nH : LieSubalgebra R L\ninst✝ : LieRing.IsNilpotent (Subtype fun x => Membership.mem H x)\n⊢ LE.le H.toLieSubmodule (LieAlgebra.rootSpace H 0)","decl":"theorem toLieSubmodule_le_rootSpace_zero : H.toLieSubmodule ≤ rootSpace H 0 := by\n  intro x hx\n  simp only [LieSubalgebra.mem_toLieSubmodule] at hx\n  simp only [mem_genWeightSpace, Pi.zero_apply, sub_zero, zero_smul]\n  intro y\n  obtain ⟨k, hk⟩ := IsNilpotent.nilpotent R H H\n  use k\n  let f : Module.End R H := toEnd R H H y\n  let g : Module.End R L := toEnd R H L y\n  have hfg : g.comp (H : Submodule R L).subtype = (H : Submodule R L).subtype.comp f := by\n    ext z\n    simp only [toEnd_apply_apply, Submodule.subtype_apply,\n      LieSubalgebra.coe_bracket_of_module, LieSubalgebra.coe_bracket, Function.comp_apply,\n      LinearMap.coe_comp]\n    rfl\n  change (g ^ k).comp (H : Submodule R L).subtype ⟨x, hx⟩ = 0\n  rw [LinearMap.commute_pow_left_of_commute hfg k]\n  have h := iterate_toEnd_mem_lowerCentralSeries R H H y ⟨x, hx⟩ k\n  rw [hk, LieSubmodule.mem_bot] at h\n  simp only [Submodule.subtype_apply, Function.comp_apply, LinearMap.pow_apply, LinearMap.coe_comp,\n    Submodule.coe_eq_zero]\n  exact h\n\n"}
{"name":"LieAlgebra.instNontrivialSubtypeMemLieSubmoduleLieSubalgebraGenWeightSpaceOfNatForall","module":"Mathlib.Algebra.Lie.Weights.Cartan","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\nH : LieSubalgebra R L\ninst✝¹ : LieRing.IsNilpotent (Subtype fun x => Membership.mem H x)\ninst✝ : Nontrivial (Subtype fun x => Membership.mem H x)\n⊢ Nontrivial (Subtype fun x => Membership.mem (LieModule.genWeightSpace L 0) x)","decl":"/-- This enables the instance `Zero (Weight R H L)`. -/\ninstance [Nontrivial H] : Nontrivial (genWeightSpace L (0 : H → R)) := by\n  obtain ⟨⟨x, hx⟩, ⟨y, hy⟩, e⟩ := exists_pair_ne H\n  exact ⟨⟨x, toLieSubmodule_le_rootSpace_zero R L H hx⟩,\n    ⟨y, toLieSubmodule_le_rootSpace_zero R L H hy⟩, by simpa using e⟩\n\n"}
{"name":"LieAlgebra.le_zeroRootSubalgebra","module":"Mathlib.Algebra.Lie.Weights.Cartan","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\nH : LieSubalgebra R L\ninst✝ : LieRing.IsNilpotent (Subtype fun x => Membership.mem H x)\n⊢ LE.le H (LieAlgebra.zeroRootSubalgebra R L H)","decl":"theorem le_zeroRootSubalgebra : H ≤ zeroRootSubalgebra R L H := by\n  rw [← LieSubalgebra.toSubmodule_le_toSubmodule, ← H.coe_toLieSubmodule,\n    coe_zeroRootSubalgebra, LieSubmodule.toSubmodule_le_toSubmodule]\n  exact toLieSubmodule_le_rootSpace_zero R L H\n\n"}
{"name":"LieAlgebra.zeroRootSubalgebra_normalizer_eq_self","module":"Mathlib.Algebra.Lie.Weights.Cartan","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\nH : LieSubalgebra R L\ninst✝ : LieRing.IsNilpotent (Subtype fun x => Membership.mem H x)\n⊢ Eq (LieAlgebra.zeroRootSubalgebra R L H).normalizer (LieAlgebra.zeroRootSubalgebra R L H)","decl":"@[simp]\ntheorem zeroRootSubalgebra_normalizer_eq_self :\n    (zeroRootSubalgebra R L H).normalizer = zeroRootSubalgebra R L H := by\n  refine le_antisymm ?_ (LieSubalgebra.le_normalizer _)\n  intro x hx\n  rw [LieSubalgebra.mem_normalizer_iff] at hx\n  rw [mem_zeroRootSubalgebra]\n  rintro ⟨y, hy⟩\n  specialize hx y (le_zeroRootSubalgebra R L H hy)\n  rw [mem_zeroRootSubalgebra] at hx\n  obtain ⟨k, hk⟩ := hx ⟨y, hy⟩\n  rw [← lie_skew, LinearMap.map_neg, neg_eq_zero] at hk\n  use k + 1\n  rw [LinearMap.iterate_succ, LinearMap.coe_comp, Function.comp_apply, toEnd_apply_apply,\n    LieSubalgebra.coe_bracket_of_module, Submodule.coe_mk, hk]\n\n"}
{"name":"LieAlgebra.is_cartan_of_zeroRootSubalgebra_eq","module":"Mathlib.Algebra.Lie.Weights.Cartan","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\nH : LieSubalgebra R L\ninst✝ : LieRing.IsNilpotent (Subtype fun x => Membership.mem H x)\nh : Eq (LieAlgebra.zeroRootSubalgebra R L H) H\n⊢ H.IsCartanSubalgebra","decl":"/-- If the zero root subalgebra of a nilpotent Lie subalgebra `H` is just `H` then `H` is a Cartan\nsubalgebra.\n\nWhen `L` is Noetherian, it follows from Engel's theorem that the converse holds. See\n`LieAlgebra.zeroRootSubalgebra_eq_iff_is_cartan` -/\ntheorem is_cartan_of_zeroRootSubalgebra_eq (h : zeroRootSubalgebra R L H = H) :\n    H.IsCartanSubalgebra :=\n  { nilpotent := inferInstance\n    self_normalizing := by rw [← h]; exact zeroRootSubalgebra_normalizer_eq_self R L H }\n\n"}
{"name":"LieAlgebra.zeroRootSubalgebra_eq_of_is_cartan","module":"Mathlib.Algebra.Lie.Weights.Cartan","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\nH : LieSubalgebra R L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : IsNoetherian R L\n⊢ Eq (LieAlgebra.zeroRootSubalgebra R L H) H","decl":"@[simp]\ntheorem zeroRootSubalgebra_eq_of_is_cartan (H : LieSubalgebra R L) [H.IsCartanSubalgebra]\n    [IsNoetherian R L] : zeroRootSubalgebra R L H = H := by\n  refine le_antisymm ?_ (le_zeroRootSubalgebra R L H)\n  suffices rootSpace H 0 ≤ H.toLieSubmodule by exact fun x hx => this hx\n  obtain ⟨k, hk⟩ := (rootSpace H 0).isNilpotent_iff_exists_self_le_ucs.mp (by infer_instance)\n  exact hk.trans (LieSubmodule.ucs_le_of_normalizer_eq_self (by simp) k)\n\n"}
{"name":"LieAlgebra.zeroRootSubalgebra_eq_iff_is_cartan","module":"Mathlib.Algebra.Lie.Weights.Cartan","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\nH : LieSubalgebra R L\ninst✝¹ : LieRing.IsNilpotent (Subtype fun x => Membership.mem H x)\ninst✝ : IsNoetherian R L\n⊢ Iff (Eq (LieAlgebra.zeroRootSubalgebra R L H) H) H.IsCartanSubalgebra","decl":"theorem zeroRootSubalgebra_eq_iff_is_cartan [IsNoetherian R L] :\n    zeroRootSubalgebra R L H = H ↔ H.IsCartanSubalgebra :=\n  ⟨is_cartan_of_zeroRootSubalgebra_eq R L H, by intros; simp⟩\n\n"}
{"name":"LieAlgebra.rootSpace_zero_eq","module":"Mathlib.Algebra.Lie.Weights.Cartan","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\nH : LieSubalgebra R L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : IsNoetherian R L\n⊢ Eq (LieAlgebra.rootSpace H 0) H.toLieSubmodule","decl":"@[simp]\ntheorem rootSpace_zero_eq (H : LieSubalgebra R L) [H.IsCartanSubalgebra] [IsNoetherian R L] :\n    rootSpace H 0 = H.toLieSubmodule := by\n  rw [← LieSubmodule.toSubmodule_inj, ← coe_zeroRootSubalgebra,\n    zeroRootSubalgebra_eq_of_is_cartan R L H, LieSubalgebra.coe_toLieSubmodule]\n\n"}
{"name":"LieAlgebra.mem_corootSpace","module":"Mathlib.Algebra.Lie.Weights.Cartan","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : LieAlgebra R L\nH : LieSubalgebra R L\ninst✝² : LieRing.IsNilpotent (Subtype fun x => Membership.mem H x)\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : IsNoetherian R L\nα : (Subtype fun x => Membership.mem H x) → R\nx : Subtype fun x => Membership.mem H x\n⊢ Iff (Membership.mem (LieAlgebra.corootSpace α) x) (Membership.mem (Submodule.span R (setOf fun x => Exists fun y => And (Membership.mem (LieAlgebra.rootSpace H α) y) (Exists fun z => And (Membership.mem (LieAlgebra.rootSpace H (Neg.neg α)) z) (Eq (Bracket.bracket y z) x)))) ↑x)","decl":"lemma mem_corootSpace {x : H} :\n    x ∈ corootSpace α ↔\n    (x : L) ∈ Submodule.span R {⁅y, z⁆ | (y ∈ rootSpace H α) (z ∈ rootSpace H (-α))} := by\n  have : x ∈ corootSpace α ↔\n      (x : L) ∈ LieSubmodule.map H.toLieSubmodule.incl (corootSpace α) := by\n    rw [corootSpace]\n    simp only [rootSpaceProduct_def, LieModuleHom.mem_range, LieSubmodule.mem_map,\n      LieSubmodule.incl_apply, SetLike.coe_eq_coe, exists_eq_right]\n    rfl\n  simp_rw [this, corootSpace, ← LieModuleHom.map_top, ← LieSubmodule.mem_toSubmodule,\n    LieSubmodule.toSubmodule_map, LieSubmodule.top_toSubmodule, ← TensorProduct.span_tmul_eq_top,\n    LinearMap.map_span, Set.image, Set.mem_setOf_eq, exists_exists_exists_and_eq]\n  change (x : L) ∈ Submodule.span R\n    {x | ∃ (a : rootSpace H α) (b : rootSpace H (-α)), ⁅(a : L), (b : L)⁆ = x} ↔ _\n  simp\n\n"}
{"name":"LieAlgebra.mem_corootSpace'","module":"Mathlib.Algebra.Lie.Weights.Cartan","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : LieAlgebra R L\nH : LieSubalgebra R L\ninst✝² : LieRing.IsNilpotent (Subtype fun x => Membership.mem H x)\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : IsNoetherian R L\nα : (Subtype fun x => Membership.mem H x) → R\nx : Subtype fun x => Membership.mem H x\n⊢ Iff (Membership.mem (LieAlgebra.corootSpace α) x) (Membership.mem (Submodule.span R (setOf fun x => Exists fun y => And (Membership.mem (LieAlgebra.rootSpace H α) y) (Exists fun z => And (Membership.mem (LieAlgebra.rootSpace H (Neg.neg α)) z) (Eq (Bracket.bracket y z) ↑x)))) x)","decl":"lemma mem_corootSpace' {x : H} :\n    x ∈ corootSpace α ↔\n    x ∈ Submodule.span R ({⁅y, z⁆ | (y ∈ rootSpace H α) (z ∈ rootSpace H (-α))} : Set H) := by\n  set s : Set H := ({⁅y, z⁆ | (y ∈ rootSpace H α) (z ∈ rootSpace H (-α))} : Set H)\n  suffices H.subtype '' s = {⁅y, z⁆ | (y ∈ rootSpace H α) (z ∈ rootSpace H (-α))} by\n    obtain ⟨x, hx⟩ := x\n    erw [← (H : Submodule R L).injective_subtype.mem_set_image (s := Submodule.span R s)]\n    rw [mem_image]\n    simp_rw [SetLike.mem_coe]\n    rw [← Submodule.mem_map, Submodule.coe_subtype, Submodule.map_span, mem_corootSpace, ← this]\n  ext u\n  simp only [Submodule.coe_subtype, mem_image, Subtype.exists, LieSubalgebra.mem_toSubmodule,\n    exists_and_right, exists_eq_right, mem_setOf_eq, s]\n  refine ⟨fun ⟨_, y, hy, z, hz, hyz⟩ ↦ ⟨y, hy, z, hz, hyz⟩,\n    fun ⟨y, hy, z, hz, hyz⟩ ↦ ⟨?_, y, hy, z, hz, hyz⟩⟩\n  convert\n    (rootSpaceProduct R L H α (-α) 0 (add_neg_cancel α) (⟨y, hy⟩ ⊗ₜ[R] ⟨z, hz⟩)).property using 0\n  simp [hyz]\n\n"}
