{"name":"List.length_splitLengths","module":"Mathlib.Data.List.SplitLengths","initialProofState":"α : Type u_1\nl : List α\nsz : List Nat\n⊢ Eq (sz.splitLengths l).length sz.length","decl":"@[simp]\ntheorem length_splitLengths : (sz.splitLengths l).length = sz.length := by\n  induction sz generalizing l <;> simp [splitLengths, *]\n\n"}
{"name":"List.splitLengths_nil","module":"Mathlib.Data.List.SplitLengths","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (List.nil.splitLengths l) List.nil","decl":"@[simp]\nlemma splitLengths_nil : [].splitLengths l = [] := rfl\n\n"}
{"name":"List.splitLengths_cons","module":"Mathlib.Data.List.SplitLengths","initialProofState":"α : Type u_1\nl : List α\nsz : List Nat\nn : Nat\n⊢ Eq ((List.cons n sz).splitLengths l) (List.cons (List.take n l) (sz.splitLengths (List.drop n l)))","decl":"@[simp]\nlemma splitLengths_cons (n : ℕ) :\n    (n :: sz).splitLengths l = l.take n :: sz.splitLengths (l.drop n) := by\n  simp [splitLengths]\n\n"}
{"name":"List.take_splitLength","module":"Mathlib.Data.List.SplitLengths","initialProofState":"α : Type u_1\nl : List α\nsz : List Nat\ni : Nat\n⊢ Eq (List.take i (sz.splitLengths l)) ((List.take i sz).splitLengths l)","decl":"theorem take_splitLength (i : ℕ) : (sz.splitLengths l).take i = (sz.take i).splitLengths l := by\n  induction i generalizing sz l\n  case zero => simp\n  case succ i hi =>\n    cases sz\n    · simp\n    · simp only [splitLengths_cons, take_succ_cons, cons.injEq, true_and, hi]\n\n"}
{"name":"List.length_splitLengths_getElem_le","module":"Mathlib.Data.List.SplitLengths","initialProofState":"α : Type u_1\nl : List α\nsz : List Nat\ni : Nat\nhi : LT.lt i (sz.splitLengths l).length\n⊢ LE.le (GetElem.getElem (sz.splitLengths l) i ⋯).length (GetElem.getElem sz i ⋯)","decl":"theorem length_splitLengths_getElem_le {i : ℕ} {hi : i < (sz.splitLengths l).length} :\n    (sz.splitLengths l)[i].length ≤ sz[i]'(by simpa using hi) := by\n  induction sz generalizing l i\n  · simp at hi\n  case cons head tail tail_ih =>\n    simp only [splitLengths_cons]\n    cases i\n    · simp\n    · simp only [getElem_cons_succ, tail_ih]\n\n"}
{"name":"List.flatten_splitLengths","module":"Mathlib.Data.List.SplitLengths","initialProofState":"α : Type u_1\nl : List α\nsz : List Nat\nh : LE.le l.length sz.sum\n⊢ Eq (sz.splitLengths l).flatten l","decl":"theorem flatten_splitLengths (h : l.length ≤ sz.sum) : (sz.splitLengths l).flatten = l := by\n  induction sz generalizing l\n  · simp_all\n  case cons head tail ih =>\n    simp only [splitLengths_cons, flatten_cons]\n    rw [ih, take_append_drop]\n    simpa [add_comm] using h\n\n"}
{"name":"List.map_splitLengths_length","module":"Mathlib.Data.List.SplitLengths","initialProofState":"α : Type u_1\nl : List α\nsz : List Nat\nh : LE.le sz.sum l.length\n⊢ Eq (List.map List.length (sz.splitLengths l)) sz","decl":"theorem map_splitLengths_length (h : sz.sum ≤ l.length) :\n    (sz.splitLengths l).map length = sz := by\n  induction sz generalizing l\n  · simp\n  case cons head tail ih =>\n    simp only [sum_cons] at h\n    simp only [splitLengths_cons, map_cons, length_take, cons.injEq, min_eq_left_iff]\n    rw [ih]\n    · simp [Nat.le_of_add_right_le h]\n    · simp [Nat.le_sub_of_add_le' h]\n\n"}
{"name":"List.length_splitLengths_getElem_eq","module":"Mathlib.Data.List.SplitLengths","initialProofState":"α : Type u_1\nl : List α\nsz : List Nat\ni : Nat\nhi : LT.lt i sz.length\nh : LE.le (List.take (HAdd.hAdd i 1) sz).sum l.length\n⊢ Eq (GetElem.getElem (sz.splitLengths l) i ⋯).length (GetElem.getElem sz i ⋯)","decl":"theorem length_splitLengths_getElem_eq {i : ℕ} (hi : i < sz.length)\n    (h : (sz.take (i + 1)).sum ≤ l.length) :\n    ((sz.splitLengths l)[i]'(by simpa)).length = sz[i] := by\n  rw [List.getElem_take' (hj := i.lt_add_one)]\n  simp only [take_splitLength]\n  conv_rhs =>\n    rw [List.getElem_take' (hj := i.lt_add_one)]\n    simp (config := {singlePass := true}) only [← map_splitLengths_length l _ h]\n    rw [getElem_map]\n\n"}
{"name":"List.splitLengths_length_getElem","module":"Mathlib.Data.List.SplitLengths","initialProofState":"α : Type u_2\nl : List α\nsz : List Nat\nh : LE.le sz.sum l.length\ni : Nat\nhi : LT.lt i (sz.splitLengths l).length\n⊢ Eq (GetElem.getElem (sz.splitLengths l) i ⋯).length (GetElem.getElem sz i ⋯)","decl":"theorem splitLengths_length_getElem {α : Type*} (l : List α) (sz : List ℕ)\n    (h : sz.sum ≤ l.length) (i : ℕ) (hi : i < (sz.splitLengths l).length) :\n    (sz.splitLengths l)[i].length = sz[i]'(by simpa using hi) := by\n  have := map_splitLengths_length l sz h\n  rw [← List.getElem_map List.length]\n  · simp [this]\n  · simpa using hi\n\n"}
{"name":"List.length_mem_splitLengths","module":"Mathlib.Data.List.SplitLengths","initialProofState":"α : Type u_2\nl : List α\nsz : List Nat\nb : Nat\nh : ∀ (n : Nat), Membership.mem sz n → LE.le n b\nl₂ : List α\na✝ : Membership.mem (sz.splitLengths l) l₂\n⊢ LE.le l₂.length b","decl":"theorem length_mem_splitLengths {α : Type*} (l : List α) (sz : List ℕ) (b : ℕ)\n    (h : ∀ n ∈ sz, n ≤ b) : ∀ l₂ ∈ sz.splitLengths l, l₂.length ≤ b := by\n  rw [← List.forall_getElem]\n  intro i hi\n  have := length_splitLengths_getElem_le l sz (hi := hi)\n  have := h (sz[i]'(by simpa using hi)) (getElem_mem ..)\n  omega\n\n"}
