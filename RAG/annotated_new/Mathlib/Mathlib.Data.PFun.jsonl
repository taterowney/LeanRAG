{"name":"PFun.mem_dom","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\nx : α\n⊢ Iff (Membership.mem f.Dom x) (Exists fun y => Membership.mem (f x) y)","decl":"@[simp]\ntheorem mem_dom (f : α →. β) (x : α) : x ∈ Dom f ↔ ∃ y, y ∈ f x := by simp [Dom, Part.dom_iff_mem]\n\n"}
{"name":"PFun.dom_mk","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\np : α → Prop\nf : (a : α) → p a → β\n⊢ Eq (PFun.Dom fun x => { Dom := p x, get := f x }) (setOf fun x => p x)","decl":"@[simp]\ntheorem dom_mk (p : α → Prop) (f : ∀ a, p a → β) : (PFun.Dom fun x => ⟨p x, f x⟩) = { x | p x } :=\n  rfl\n\n"}
{"name":"PFun.dom_eq","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\n⊢ Eq f.Dom (setOf fun x => Exists fun y => Membership.mem (f x) y)","decl":"theorem dom_eq (f : α →. β) : Dom f = { x | ∃ y, y ∈ f x } :=\n  Set.ext (mem_dom f)\n\n"}
{"name":"PFun.fn_apply","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\na : α\n⊢ Eq (f.fn a) (f a).get","decl":"@[simp]\ntheorem fn_apply (f : α →. β) (a : α) : f.fn a = (f a).get :=\n  rfl\n\n"}
{"name":"PFun.ext'","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : PFun α β\nH1 : ∀ (a : α), Iff (Membership.mem f.Dom a) (Membership.mem g.Dom a)\nH2 : ∀ (a : α) (p : f.Dom a) (q : g.Dom a), Eq (f.fn a p) (g.fn a q)\n⊢ Eq f g","decl":"/-- Partial function extensionality -/\ntheorem ext' {f g : α →. β} (H1 : ∀ a, a ∈ Dom f ↔ a ∈ Dom g) (H2 : ∀ a p q, f.fn a p = g.fn a q) :\n    f = g :=\n  funext fun a => Part.ext' (H1 a) (H2 a)\n\n"}
{"name":"PFun.ext","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : PFun α β\nH : ∀ (a : α) (b : β), Iff (Membership.mem (f a) b) (Membership.mem (g a) b)\n⊢ Eq f g","decl":"theorem ext {f g : α →. β} (H : ∀ a b, b ∈ f a ↔ b ∈ g a) : f = g :=\n  funext fun a => Part.ext (H a)\n\n"}
{"name":"PFun.asSubtype_eq_of_mem","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\nx : α\ny : β\nfxy : Membership.mem (f x) y\ndomx : Membership.mem f.Dom x\n⊢ Eq (f.asSubtype ⟨x, domx⟩) y","decl":"theorem asSubtype_eq_of_mem {f : α →. β} {x : α} {y : β} (fxy : y ∈ f x) (domx : x ∈ f.Dom) :\n    f.asSubtype ⟨x, domx⟩ = y :=\n  Part.mem_unique (Part.get_mem _) fxy\n\n"}
{"name":"PFun.coe_val","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na : α\n⊢ Eq (↑f a) (Part.some (f a))","decl":"@[simp]\ntheorem coe_val (f : α → β) (a : α) : (f : α →. β) a = Part.some (f a) :=\n  rfl\n\n"}
{"name":"PFun.dom_coe","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (↑f).Dom Set.univ","decl":"@[simp]\ntheorem dom_coe (f : α → β) : (f : α →. β).Dom = Set.univ :=\n  rfl\n\n"}
{"name":"PFun.lift_injective","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Function.Injective PFun.lift","decl":"theorem lift_injective : Injective (PFun.lift : (α → β) → α →. β) := fun _ _ h =>\n  funext fun a => Part.some_injective <| congr_fun h a\n\n"}
{"name":"PFun.mem_restrict","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\ns : Set α\nh : HasSubset.Subset s f.Dom\na : α\nb : β\n⊢ Iff (Membership.mem (f.restrict h a) b) (And (Membership.mem s a) (Membership.mem (f a) b))","decl":"@[simp]\ntheorem mem_restrict {f : α →. β} {s : Set α} (h : s ⊆ f.Dom) (a : α) (b : β) :\n    b ∈ f.restrict h a ↔ a ∈ s ∧ b ∈ f a := by simp [restrict]\n\n"}
{"name":"PFun.mem_res","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\na : α\nb : β\n⊢ Iff (Membership.mem (PFun.res f s a) b) (And (Membership.mem s a) (Eq (f a) b))","decl":"theorem mem_res (f : α → β) (s : Set α) (a : α) (b : β) : b ∈ res f s a ↔ a ∈ s ∧ f a = b := by\n  simp [res, @eq_comm _ b]\n\n"}
{"name":"PFun.res_univ","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (PFun.res f Set.univ) ↑f","decl":"theorem res_univ (f : α → β) : PFun.res f Set.univ = f :=\n  rfl\n\n"}
{"name":"PFun.dom_iff_graph","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\nx : α\n⊢ Iff (Membership.mem f.Dom x) (Exists fun y => Membership.mem f.graph { fst := x, snd := y })","decl":"theorem dom_iff_graph (f : α →. β) (x : α) : x ∈ f.Dom ↔ ∃ y, (x, y) ∈ f.graph :=\n  Part.dom_iff_mem\n\n"}
{"name":"PFun.lift_graph","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na : α\nb : β\n⊢ Iff (Membership.mem (↑f).graph { fst := a, snd := b }) (Eq (f a) b)","decl":"theorem lift_graph {f : α → β} {a b} : (a, b) ∈ (f : α →. β).graph ↔ f a = b :=\n  show (∃ _ : True, f a = b) ↔ f a = b by simp\n\n"}
{"name":"PFun.bind_apply","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : PFun α β\ng : β → PFun α γ\na : α\n⊢ Eq (f.bind g a) ((f a).bind fun b => g b a)","decl":"@[simp]\ntheorem bind_apply (f : α →. β) (g : β → α →. γ) (a : α) : f.bind g a = (f a).bind fun b => g b a :=\n  rfl\n\n"}
{"name":"PFun.lawfulMonad","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\n⊢ LawfulMonad (PFun α)","decl":"instance lawfulMonad : LawfulMonad (PFun α) := LawfulMonad.mk'\n  (bind_pure_comp := fun _ _ => funext fun _ => Part.bind_some_eq_map _ _)\n  (id_map := fun f => by funext a; dsimp [Functor.map, PFun.map]; cases f a; rfl)\n  (pure_bind := fun x f => funext fun _ => Part.bind_some _ (f x))\n  (bind_assoc := fun f g k => funext fun a => (f a).bind_assoc (fun b => g b a) fun b => k b a)\n\n"}
{"name":"PFun.pure_defined","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\np : Set α\nx : β\n⊢ HasSubset.Subset p (PFun.pure x).Dom","decl":"theorem pure_defined (p : Set α) (x : β) : p ⊆ (@PFun.pure α _ x).Dom :=\n  p.subset_univ\n\n"}
{"name":"PFun.bind_defined","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_7\nβ γ : Type u_8\np : Set α\nf : PFun α β\ng : β → PFun α γ\nH1 : HasSubset.Subset p f.Dom\nH2 : ∀ (x : β), HasSubset.Subset p (g x).Dom\n⊢ HasSubset.Subset p (Bind.bind f g).Dom","decl":"theorem bind_defined {α β γ} (p : Set α) {f : α →. β} {g : β → α →. γ} (H1 : p ⊆ f.Dom)\n    (H2 : ∀ x, p ⊆ (g x).Dom) : p ⊆ (f >>= g).Dom := fun a ha =>\n  (⟨H1 ha, H2 _ ha⟩ : (f >>= g).Dom a)\n\n"}
{"name":"PFun.dom_of_mem_fix","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α (Sum β α)\na : α\nb : β\nh : Membership.mem (f.fix a) b\n⊢ (f a).Dom","decl":"theorem dom_of_mem_fix {f : α →. β ⊕ α} {a : α} {b : β} (h : b ∈ f.fix a) : (f a).Dom := by\n  let ⟨h₁, h₂⟩ := Part.mem_assert_iff.1 h\n  rw [WellFounded.fixFEq] at h₂; exact h₂.fst.fst\n\n"}
{"name":"PFun.mem_fix_iff","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α (Sum β α)\na : α\nb : β\n⊢ Iff (Membership.mem (f.fix a) b) (Or (Membership.mem (f a) (Sum.inl b)) (Exists fun a' => And (Membership.mem (f a) (Sum.inr a')) (Membership.mem (f.fix a') b)))","decl":"theorem mem_fix_iff {f : α →. β ⊕ α} {a : α} {b : β} :\n    b ∈ f.fix a ↔ Sum.inl b ∈ f a ∨ ∃ a', Sum.inr a' ∈ f a ∧ b ∈ f.fix a' :=\n  ⟨fun h => by\n    let ⟨h₁, h₂⟩ := Part.mem_assert_iff.1 h\n    rw [WellFounded.fixFEq] at h₂\n    simp only [Part.mem_assert_iff] at h₂\n    cases' h₂ with h₂ h₃\n    split at h₃\n    next e => simp only [Part.mem_some_iff] at h₃; subst b; exact Or.inl ⟨h₂, e⟩\n    next e => exact Or.inr ⟨_, ⟨_, e⟩, Part.mem_assert _ h₃⟩,\n   fun h => by\n    simp only [fix, Part.mem_assert_iff]\n    rcases h with (⟨h₁, h₂⟩ | ⟨a', h, h₃⟩)\n    · refine ⟨⟨_, fun y h' => ?_⟩, ?_⟩\n      · injection Part.mem_unique ⟨h₁, h₂⟩ h'\n      · rw [WellFounded.fixFEq]\n        -- Porting note: used to be simp [h₁, h₂]\n        apply Part.mem_assert h₁\n        split\n        next e =>\n          injection h₂.symm.trans e with h; simp [h]\n        next e =>\n          injection h₂.symm.trans e\n    · simp only [fix, Part.mem_assert_iff] at h₃\n      cases' h₃ with h₃ h₄\n      refine ⟨⟨_, fun y h' => ?_⟩, ?_⟩\n      · injection Part.mem_unique h h' with e\n        exact e ▸ h₃\n      · cases' h with h₁ h₂\n        rw [WellFounded.fixFEq]\n        -- Porting note: used to be simp [h₁, h₂, h₄]\n        apply Part.mem_assert h₁\n        split\n        next e =>\n          injection h₂.symm.trans e\n        next e =>\n          injection h₂.symm.trans e; subst a'; exact h₄⟩\n\n"}
{"name":"PFun.fix_stop","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α (Sum β α)\nb : β\na : α\nhb : Membership.mem (f a) (Sum.inl b)\n⊢ Membership.mem (f.fix a) b","decl":"/-- If advancing one step from `a` leads to `b : β`, then `f.fix a = b` -/\ntheorem fix_stop {f : α →. β ⊕ α} {b : β} {a : α} (hb : Sum.inl b ∈ f a) : b ∈ f.fix a := by\n  rw [PFun.mem_fix_iff]\n  exact Or.inl hb\n\n"}
{"name":"PFun.fix_fwd_eq","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α (Sum β α)\na a' : α\nha' : Membership.mem (f a) (Sum.inr a')\n⊢ Eq (f.fix a) (f.fix a')","decl":"/-- If advancing one step from `a` on `f` leads to `a' : α`, then `f.fix a = f.fix a'` -/\ntheorem fix_fwd_eq {f : α →. β ⊕ α} {a a' : α} (ha' : Sum.inr a' ∈ f a) : f.fix a = f.fix a' := by\n  ext b; constructor\n  · intro h\n    obtain h' | ⟨a, h', e'⟩ := mem_fix_iff.1 h <;> cases Part.mem_unique ha' h'\n    exact e'\n  · intro h\n    rw [PFun.mem_fix_iff]\n    exact Or.inr ⟨a', ha', h⟩\n\n"}
{"name":"PFun.fix_fwd","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α (Sum β α)\nb : β\na a' : α\nhb : Membership.mem (f.fix a) b\nha' : Membership.mem (f a) (Sum.inr a')\n⊢ Membership.mem (f.fix a') b","decl":"theorem fix_fwd {f : α →. β ⊕ α} {b : β} {a a' : α} (hb : b ∈ f.fix a) (ha' : Sum.inr a' ∈ f a) :\n    b ∈ f.fix a' := by rwa [← fix_fwd_eq ha']\n\n"}
{"name":"PFun.fixInduction_spec","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nC : α → Sort u_7\nf : PFun α (Sum β α)\nb : β\na : α\nh : Membership.mem (f.fix a) b\nH : (a' : α) → Membership.mem (f.fix a') b → ((a'' : α) → Membership.mem (f a') (Sum.inr a'') → C a'') → C a'\n⊢ Eq (PFun.fixInduction h H) (H a h fun x h' => PFun.fixInduction ⋯ H)","decl":"theorem fixInduction_spec {C : α → Sort*} {f : α →. β ⊕ α} {b : β} {a : α} (h : b ∈ f.fix a)\n    (H : ∀ a', b ∈ f.fix a' → (∀ a'', Sum.inr a'' ∈ f a' → C a'') → C a') :\n    @fixInduction _ _ C _ _ _ h H = H a h fun _ h' => fixInduction (fix_fwd h h') H := by\n  unfold fixInduction\n  generalize_proofs\n  induction ‹Acc _ _›\n  rfl\n\n"}
{"name":"PFun.fixInduction'_stop","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nC : α → Sort u_7\nf : PFun α (Sum β α)\nb : β\na : α\nh : Membership.mem (f.fix a) b\nfa : Membership.mem (f a) (Sum.inl b)\nhbase : (a_final : α) → Membership.mem (f a_final) (Sum.inl b) → C a_final\nhind : (a₀ a₁ : α) → Membership.mem (f.fix a₁) b → Membership.mem (f a₀) (Sum.inr a₁) → C a₁ → C a₀\n⊢ Eq (PFun.fixInduction' h hbase hind) (hbase a fa)","decl":"theorem fixInduction'_stop {C : α → Sort*} {f : α →. β ⊕ α} {b : β} {a : α} (h : b ∈ f.fix a)\n    (fa : Sum.inl b ∈ f a) (hbase : ∀ a_final : α, Sum.inl b ∈ f a_final → C a_final)\n    (hind : ∀ a₀ a₁ : α, b ∈ f.fix a₁ → Sum.inr a₁ ∈ f a₀ → C a₁ → C a₀) :\n    @fixInduction' _ _ C _ _ _ h hbase hind = hbase a fa := by\n  unfold fixInduction'\n  rw [fixInduction_spec]\n  -- Porting note: the explicit motive required because `simp` behaves differently\n  refine Eq.rec (motive := fun x e ↦\n      Sum.casesOn x ?_ ?_ (Eq.trans (Part.get_eq_of_mem fa (dom_of_mem_fix h)) e) = hbase a fa) ?_\n    (Part.get_eq_of_mem fa (dom_of_mem_fix h)).symm\n  simp\n\n"}
{"name":"PFun.fixInduction'_fwd","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nC : α → Sort u_7\nf : PFun α (Sum β α)\nb : β\na a' : α\nh : Membership.mem (f.fix a) b\nh' : Membership.mem (f.fix a') b\nfa : Membership.mem (f a) (Sum.inr a')\nhbase : (a_final : α) → Membership.mem (f a_final) (Sum.inl b) → C a_final\nhind : (a₀ a₁ : α) → Membership.mem (f.fix a₁) b → Membership.mem (f a₀) (Sum.inr a₁) → C a₁ → C a₀\n⊢ Eq (PFun.fixInduction' h hbase hind) (hind a a' h' fa (PFun.fixInduction' h' hbase hind))","decl":"theorem fixInduction'_fwd {C : α → Sort*} {f : α →. β ⊕ α} {b : β} {a a' : α} (h : b ∈ f.fix a)\n    (h' : b ∈ f.fix a') (fa : Sum.inr a' ∈ f a)\n    (hbase : ∀ a_final : α, Sum.inl b ∈ f a_final → C a_final)\n    (hind : ∀ a₀ a₁ : α, b ∈ f.fix a₁ → Sum.inr a₁ ∈ f a₀ → C a₁ → C a₀) :\n    @fixInduction' _ _ C _ _ _ h hbase hind = hind a a' h' fa (fixInduction' h' hbase hind) := by\n  unfold fixInduction'\n  rw [fixInduction_spec]\n  -- Porting note: the explicit motive required because `simp` behaves differently\n  refine Eq.rec (motive := fun x e =>\n      Sum.casesOn (motive := fun y => (f a).get (dom_of_mem_fix h) = y → C a) x ?_ ?_\n      (Eq.trans (Part.get_eq_of_mem fa (dom_of_mem_fix h)) e) = _) ?_\n    (Part.get_eq_of_mem fa (dom_of_mem_fix h)).symm\n  simp\n\n"}
{"name":"PFun.image_def","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\ns : Set α\n⊢ Eq (f.image s) (setOf fun y => Exists fun x => And (Membership.mem s x) (Membership.mem (f x) y))","decl":"theorem image_def (s : Set α) : f.image s = { y | ∃ x ∈ s, y ∈ f x } :=\n  rfl\n\n"}
{"name":"PFun.mem_image","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\ny : β\ns : Set α\n⊢ Iff (Membership.mem (f.image s) y) (Exists fun x => And (Membership.mem s x) (Membership.mem (f x) y))","decl":"theorem mem_image (y : β) (s : Set α) : y ∈ f.image s ↔ ∃ x ∈ s, y ∈ f x :=\n  Iff.rfl\n\n"}
{"name":"PFun.image_mono","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\ns t : Set α\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset (f.image s) (f.image t)","decl":"theorem image_mono {s t : Set α} (h : s ⊆ t) : f.image s ⊆ f.image t :=\n  Rel.image_mono _ h\n\n"}
{"name":"PFun.image_inter","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\ns t : Set α\n⊢ HasSubset.Subset (f.image (Inter.inter s t)) (Inter.inter (f.image s) (f.image t))","decl":"theorem image_inter (s t : Set α) : f.image (s ∩ t) ⊆ f.image s ∩ f.image t :=\n  Rel.image_inter _ s t\n\n"}
{"name":"PFun.image_union","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\ns t : Set α\n⊢ Eq (f.image (Union.union s t)) (Union.union (f.image s) (f.image t))","decl":"theorem image_union (s t : Set α) : f.image (s ∪ t) = f.image s ∪ f.image t :=\n  Rel.image_union _ s t\n\n"}
{"name":"PFun.Preimage_def","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\ns : Set β\n⊢ Eq (f.preimage s) (setOf fun x => Exists fun y => And (Membership.mem s y) (Membership.mem (f x) y))","decl":"theorem Preimage_def (s : Set β) : f.preimage s = { x | ∃ y ∈ s, y ∈ f x } :=\n  rfl\n\n"}
{"name":"PFun.mem_preimage","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\ns : Set β\nx : α\n⊢ Iff (Membership.mem (f.preimage s) x) (Exists fun y => And (Membership.mem s y) (Membership.mem (f x) y))","decl":"@[simp]\ntheorem mem_preimage (s : Set β) (x : α) : x ∈ f.preimage s ↔ ∃ y ∈ s, y ∈ f x :=\n  Iff.rfl\n\n"}
{"name":"PFun.preimage_subset_dom","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\ns : Set β\n⊢ HasSubset.Subset (f.preimage s) f.Dom","decl":"theorem preimage_subset_dom (s : Set β) : f.preimage s ⊆ f.Dom := fun _ ⟨y, _, fxy⟩ =>\n  Part.dom_iff_mem.mpr ⟨y, fxy⟩\n\n"}
{"name":"PFun.preimage_mono","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\ns t : Set β\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset (f.preimage s) (f.preimage t)","decl":"theorem preimage_mono {s t : Set β} (h : s ⊆ t) : f.preimage s ⊆ f.preimage t :=\n  Rel.preimage_mono _ h\n\n"}
{"name":"PFun.preimage_inter","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\ns t : Set β\n⊢ HasSubset.Subset (f.preimage (Inter.inter s t)) (Inter.inter (f.preimage s) (f.preimage t))","decl":"theorem preimage_inter (s t : Set β) : f.preimage (s ∩ t) ⊆ f.preimage s ∩ f.preimage t :=\n  Rel.preimage_inter _ s t\n\n"}
{"name":"PFun.preimage_union","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\ns t : Set β\n⊢ Eq (f.preimage (Union.union s t)) (Union.union (f.preimage s) (f.preimage t))","decl":"theorem preimage_union (s t : Set β) : f.preimage (s ∪ t) = f.preimage s ∪ f.preimage t :=\n  Rel.preimage_union _ s t\n\n"}
{"name":"PFun.preimage_univ","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\n⊢ Eq (f.preimage Set.univ) f.Dom","decl":"theorem preimage_univ : f.preimage Set.univ = f.Dom := by ext; simp [mem_preimage, mem_dom]\n\n"}
{"name":"PFun.coe_preimage","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\n⊢ Eq ((↑f).preimage s) (Set.preimage f s)","decl":"theorem coe_preimage (f : α → β) (s : Set β) : (f : α →. β).preimage s = f ⁻¹' s := by ext; simp\n\n"}
{"name":"PFun.core_def","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\ns : Set β\n⊢ Eq (f.core s) (setOf fun x => ∀ (y : β), Membership.mem (f x) y → Membership.mem s y)","decl":"theorem core_def (s : Set β) : f.core s = { x | ∀ y, y ∈ f x → y ∈ s } :=\n  rfl\n\n"}
{"name":"PFun.mem_core","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\nx : α\ns : Set β\n⊢ Iff (Membership.mem (f.core s) x) (∀ (y : β), Membership.mem (f x) y → Membership.mem s y)","decl":"@[simp]\ntheorem mem_core (x : α) (s : Set β) : x ∈ f.core s ↔ ∀ y, y ∈ f x → y ∈ s :=\n  Iff.rfl\n\n"}
{"name":"PFun.compl_dom_subset_core","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\ns : Set β\n⊢ HasSubset.Subset (HasCompl.compl f.Dom) (f.core s)","decl":"theorem compl_dom_subset_core (s : Set β) : f.Domᶜ ⊆ f.core s := fun x hx y fxy =>\n  absurd ((mem_dom f x).mpr ⟨y, fxy⟩) hx\n\n"}
{"name":"PFun.core_mono","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\ns t : Set β\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset (f.core s) (f.core t)","decl":"theorem core_mono {s t : Set β} (h : s ⊆ t) : f.core s ⊆ f.core t :=\n  Rel.core_mono _ h\n\n"}
{"name":"PFun.core_inter","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\ns t : Set β\n⊢ Eq (f.core (Inter.inter s t)) (Inter.inter (f.core s) (f.core t))","decl":"theorem core_inter (s t : Set β) : f.core (s ∩ t) = f.core s ∩ f.core t :=\n  Rel.core_inter _ s t\n\n"}
{"name":"PFun.mem_core_res","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\nt : Set β\nx : α\n⊢ Iff (Membership.mem ((PFun.res f s).core t) x) (Membership.mem s x → Membership.mem t (f x))","decl":"theorem mem_core_res (f : α → β) (s : Set α) (t : Set β) (x : α) :\n    x ∈ (res f s).core t ↔ x ∈ s → f x ∈ t := by simp [mem_core, mem_res]\n\n"}
{"name":"PFun.core_res","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\nt : Set β\n⊢ Eq ((PFun.res f s).core t) (Union.union (HasCompl.compl s) (Set.preimage f t))","decl":"theorem core_res (f : α → β) (s : Set α) (t : Set β) : (res f s).core t = sᶜ ∪ f ⁻¹' t := by\n  ext x\n  rw [mem_core_res]\n  by_cases h : x ∈ s <;> simp [h]\n\n"}
{"name":"PFun.core_restrict","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\n⊢ Eq ((↑f).core s) (Set.preimage f s)","decl":"theorem core_restrict (f : α → β) (s : Set β) : (f : α →. β).core s = s.preimage f := by\n  ext x; simp [core_def]\n\n"}
{"name":"PFun.preimage_subset_core","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\ns : Set β\n⊢ HasSubset.Subset (f.preimage s) (f.core s)","decl":"theorem preimage_subset_core (f : α →. β) (s : Set β) : f.preimage s ⊆ f.core s :=\n  fun _ ⟨y, ys, fxy⟩ y' fxy' =>\n  have : y = y' := Part.mem_unique fxy fxy'\n  this ▸ ys\n\n"}
{"name":"PFun.preimage_eq","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\ns : Set β\n⊢ Eq (f.preimage s) (Inter.inter (f.core s) f.Dom)","decl":"theorem preimage_eq (f : α →. β) (s : Set β) : f.preimage s = f.core s ∩ f.Dom :=\n  Set.eq_of_subset_of_subset (Set.subset_inter (f.preimage_subset_core s) (f.preimage_subset_dom s))\n    fun x ⟨xcore, xdom⟩ =>\n    let y := (f x).get xdom\n    have ys : y ∈ s := xcore _ (Part.get_mem _)\n    show x ∈ f.preimage s from ⟨(f x).get xdom, ys, Part.get_mem _⟩\n\n"}
{"name":"PFun.core_eq","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\ns : Set β\n⊢ Eq (f.core s) (Union.union (f.preimage s) (HasCompl.compl f.Dom))","decl":"theorem core_eq (f : α →. β) (s : Set β) : f.core s = f.preimage s ∪ f.Domᶜ := by\n  rw [preimage_eq, Set.inter_union_distrib_right, Set.union_comm (Dom f), Set.compl_union_self,\n    Set.inter_univ, Set.union_eq_self_of_subset_right (f.compl_dom_subset_core s)]\n\n"}
{"name":"PFun.preimage_asSubtype","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\ns : Set β\n⊢ Eq (Set.preimage f.asSubtype s) (Set.preimage Subtype.val (f.preimage s))","decl":"theorem preimage_asSubtype (f : α →. β) (s : Set β) :\n    f.asSubtype ⁻¹' s = Subtype.val ⁻¹' f.preimage s := by\n  ext x\n  simp only [Set.mem_preimage, Set.mem_setOf_eq, PFun.asSubtype, PFun.mem_preimage]\n  show f.fn x.val _ ∈ s ↔ ∃ y ∈ s, y ∈ f x.val\n  exact\n    Iff.intro (fun h => ⟨_, h, Part.get_mem _⟩) fun ⟨y, ys, fxy⟩ =>\n      have : f.fn x.val x.property ∈ f x.val := Part.get_mem _\n      Part.mem_unique fxy this ▸ ys\n\n"}
{"name":"PFun.dom_toSubtype","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\np : β → Prop\nf : α → β\n⊢ Eq (PFun.toSubtype p f).Dom (setOf fun a => p (f a))","decl":"@[simp]\ntheorem dom_toSubtype (p : β → Prop) (f : α → β) : (toSubtype p f).Dom = { a | p (f a) } :=\n  rfl\n\n"}
{"name":"PFun.toSubtype_apply","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\np : β → Prop\nf : α → β\na : α\n⊢ Eq (PFun.toSubtype p f a) { Dom := p (f a), get := Subtype.mk (f a) }","decl":"@[simp]\ntheorem toSubtype_apply (p : β → Prop) (f : α → β) (a : α) :\n    toSubtype p f a = ⟨p (f a), Subtype.mk _⟩ :=\n  rfl\n\n"}
{"name":"PFun.dom_toSubtype_apply_iff","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\np : β → Prop\nf : α → β\na : α\n⊢ Iff (PFun.toSubtype p f a).Dom (p (f a))","decl":"theorem dom_toSubtype_apply_iff {p : β → Prop} {f : α → β} {a : α} :\n    (toSubtype p f a).Dom ↔ p (f a) :=\n  Iff.rfl\n\n"}
{"name":"PFun.mem_toSubtype_iff","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\np : β → Prop\nf : α → β\na : α\nb : Subtype p\n⊢ Iff (Membership.mem (PFun.toSubtype p f a) b) (Eq (↑b) (f a))","decl":"theorem mem_toSubtype_iff {p : β → Prop} {f : α → β} {a : α} {b : Subtype p} :\n    b ∈ toSubtype p f a ↔ ↑b = f a := by\n  rw [toSubtype_apply, Part.mem_mk_iff, exists_subtype_mk_eq_iff, eq_comm]\n\n"}
{"name":"PFun.coe_id","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_7\n⊢ Eq (↑id) (PFun.id α)","decl":"@[simp, norm_cast]\ntheorem coe_id (α : Type*) : ((id : α → α) : α →. α) = PFun.id α :=\n  rfl\n\n"}
{"name":"PFun.id_apply","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\na : α\n⊢ Eq (PFun.id α a) (Part.some a)","decl":"@[simp]\ntheorem id_apply (a : α) : PFun.id α a = Part.some a :=\n  rfl\n\n"}
{"name":"PFun.comp_apply","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : PFun β γ\ng : PFun α β\na : α\n⊢ Eq (f.comp g a) ((g a).bind f)","decl":"@[simp]\ntheorem comp_apply (f : β →. γ) (g : α →. β) (a : α) : f.comp g a = (g a).bind f :=\n  rfl\n\n"}
{"name":"PFun.id_comp","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\n⊢ Eq ((PFun.id β).comp f) f","decl":"@[simp]\ntheorem id_comp (f : α →. β) : (PFun.id β).comp f = f :=\n  ext fun _ _ => by simp\n\n"}
{"name":"PFun.comp_id","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nf : PFun α β\n⊢ Eq (f.comp (PFun.id α)) f","decl":"@[simp]\ntheorem comp_id (f : α →. β) : f.comp (PFun.id α) = f :=\n  ext fun _ _ => by simp\n\n"}
{"name":"PFun.dom_comp","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : PFun β γ\ng : PFun α β\n⊢ Eq (f.comp g).Dom (g.preimage f.Dom)","decl":"@[simp]\ntheorem dom_comp (f : β →. γ) (g : α →. β) : (f.comp g).Dom = g.preimage f.Dom := by\n  ext\n  simp_rw [mem_preimage, mem_dom, comp_apply, Part.mem_bind_iff, ← exists_and_right]\n  rw [exists_comm]\n  simp_rw [and_comm]\n\n"}
{"name":"PFun.preimage_comp","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : PFun β γ\ng : PFun α β\ns : Set γ\n⊢ Eq ((f.comp g).preimage s) (g.preimage (f.preimage s))","decl":"@[simp]\ntheorem preimage_comp (f : β →. γ) (g : α →. β) (s : Set γ) :\n    (f.comp g).preimage s = g.preimage (f.preimage s) := by\n  ext\n  simp_rw [mem_preimage, comp_apply, Part.mem_bind_iff, ← exists_and_right, ← exists_and_left]\n  rw [exists_comm]\n  simp_rw [and_assoc, and_comm]\n\n"}
{"name":"PFun.Part.bind_comp","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : PFun β γ\ng : PFun α β\na : Part α\n⊢ Eq (a.bind (f.comp g)) ((a.bind g).bind f)","decl":"@[simp]\ntheorem Part.bind_comp (f : β →. γ) (g : α →. β) (a : Part α) :\n    a.bind (f.comp g) = (a.bind g).bind f := by\n  ext c\n  simp_rw [Part.mem_bind_iff, comp_apply, Part.mem_bind_iff, ← exists_and_right, ← exists_and_left]\n  rw [exists_comm]\n  simp_rw [and_assoc]\n\n"}
{"name":"PFun.comp_assoc","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : PFun γ δ\ng : PFun β γ\nh : PFun α β\n⊢ Eq ((f.comp g).comp h) (f.comp (g.comp h))","decl":"@[simp]\ntheorem comp_assoc (f : γ →. δ) (g : β →. γ) (h : α →. β) : (f.comp g).comp h = f.comp (g.comp h) :=\n  ext fun _ _ => by simp only [comp_apply, Part.bind_comp]\n\n-- This can't be `simp`\n"}
{"name":"PFun.coe_comp","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ng : β → γ\nf : α → β\n⊢ Eq (↑(Function.comp g f)) ((↑g).comp ↑f)","decl":"theorem coe_comp (g : β → γ) (f : α → β) : ((g ∘ f : α → γ) : α →. γ) = (g : β →. γ).comp f :=\n  ext fun _ _ => by simp only [coe_val, comp_apply, Function.comp, Part.bind_some]\n\n"}
{"name":"PFun.dom_prodLift","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : PFun α β\ng : PFun α γ\n⊢ Eq (f.prodLift g).Dom (setOf fun x => And (f x).Dom (g x).Dom)","decl":"@[simp]\ntheorem dom_prodLift (f : α →. β) (g : α →. γ) :\n    (f.prodLift g).Dom = { x | (f x).Dom ∧ (g x).Dom } :=\n  rfl\n\n"}
{"name":"PFun.get_prodLift","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : PFun α β\ng : PFun α γ\nx : α\nh : (f.prodLift g x).Dom\n⊢ Eq ((f.prodLift g x).get h) { fst := (f x).get ⋯, snd := (g x).get ⋯ }","decl":"theorem get_prodLift (f : α →. β) (g : α →. γ) (x : α) (h) :\n    (f.prodLift g x).get h = ((f x).get h.1, (g x).get h.2) :=\n  rfl\n\n"}
{"name":"PFun.prodLift_apply","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : PFun α β\ng : PFun α γ\nx : α\n⊢ Eq (f.prodLift g x) { Dom := And (f x).Dom (g x).Dom, get := fun h => { fst := (f x).get ⋯, snd := (g x).get ⋯ } }","decl":"@[simp]\ntheorem prodLift_apply (f : α →. β) (g : α →. γ) (x : α) :\n    f.prodLift g x = ⟨(f x).Dom ∧ (g x).Dom, fun h => ((f x).get h.1, (g x).get h.2)⟩ :=\n  rfl\n\n"}
{"name":"PFun.mem_prodLift","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : PFun α β\ng : PFun α γ\nx : α\ny : Prod β γ\n⊢ Iff (Membership.mem (f.prodLift g x) y) (And (Membership.mem (f x) y.1) (Membership.mem (g x) y.2))","decl":"theorem mem_prodLift {f : α →. β} {g : α →. γ} {x : α} {y : β × γ} :\n    y ∈ f.prodLift g x ↔ y.1 ∈ f x ∧ y.2 ∈ g x := by\n  trans ∃ hp hq, (f x).get hp = y.1 ∧ (g x).get hq = y.2\n  · simp only [prodLift, Part.mem_mk_iff, And.exists, Prod.ext_iff]\n  -- Porting note: was just `[exists_and_left, exists_and_right]`\n  · simp only [exists_and_left, exists_and_right, Membership.mem, Part.Mem]\n\n"}
{"name":"PFun.dom_prodMap","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : PFun α γ\ng : PFun β δ\n⊢ Eq (f.prodMap g).Dom (setOf fun x => And (f x.1).Dom (g x.2).Dom)","decl":"@[simp]\ntheorem dom_prodMap (f : α →. γ) (g : β →. δ) :\n    (f.prodMap g).Dom = { x | (f x.1).Dom ∧ (g x.2).Dom } :=\n  rfl\n\n"}
{"name":"PFun.get_prodMap","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : PFun α γ\ng : PFun β δ\nx : Prod α β\nh : (f.prodMap g x).Dom\n⊢ Eq ((f.prodMap g x).get h) { fst := (f x.1).get ⋯, snd := (g x.2).get ⋯ }","decl":"theorem get_prodMap (f : α →. γ) (g : β →. δ) (x : α × β) (h) :\n    (f.prodMap g x).get h = ((f x.1).get h.1, (g x.2).get h.2) :=\n  rfl\n\n"}
{"name":"PFun.prodMap_apply","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : PFun α γ\ng : PFun β δ\nx : Prod α β\n⊢ Eq (f.prodMap g x) { Dom := And (f x.1).Dom (g x.2).Dom, get := fun h => { fst := (f x.1).get ⋯, snd := (g x.2).get ⋯ } }","decl":"@[simp]\ntheorem prodMap_apply (f : α →. γ) (g : β →. δ) (x : α × β) :\n    f.prodMap g x = ⟨(f x.1).Dom ∧ (g x.2).Dom, fun h => ((f x.1).get h.1, (g x.2).get h.2)⟩ :=\n  rfl\n\n"}
{"name":"PFun.mem_prodMap","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : PFun α γ\ng : PFun β δ\nx : Prod α β\ny : Prod γ δ\n⊢ Iff (Membership.mem (f.prodMap g x) y) (And (Membership.mem (f x.1) y.1) (Membership.mem (g x.2) y.2))","decl":"theorem mem_prodMap {f : α →. γ} {g : β →. δ} {x : α × β} {y : γ × δ} :\n    y ∈ f.prodMap g x ↔ y.1 ∈ f x.1 ∧ y.2 ∈ g x.2 := by\n  trans ∃ hp hq, (f x.1).get hp = y.1 ∧ (g x.2).get hq = y.2\n  · simp only [prodMap, Part.mem_mk_iff, And.exists, Prod.ext_iff]\n  · simp only [exists_and_left, exists_and_right, Membership.mem, Part.Mem]\n\n"}
{"name":"PFun.prodLift_fst_comp_snd_comp","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : PFun α γ\ng : PFun β δ\n⊢ Eq ((f.comp ↑Prod.fst).prodLift (g.comp ↑Prod.snd)) (f.prodMap g)","decl":"@[simp]\ntheorem prodLift_fst_comp_snd_comp (f : α →. γ) (g : β →. δ) :\n    prodLift (f.comp ((Prod.fst : α × β → α) : α × β →. α))\n        (g.comp ((Prod.snd : α × β → β) : α × β →. β)) =\n      prodMap f g :=\n  ext fun a => by simp\n\n"}
{"name":"PFun.prodMap_id_id","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Eq ((PFun.id α).prodMap (PFun.id β)) (PFun.id (Prod α β))","decl":"@[simp]\ntheorem prodMap_id_id : (PFun.id α).prodMap (PFun.id β) = PFun.id _ :=\n  ext fun _ _ ↦ by simp [eq_comm]\n\n"}
{"name":"PFun.prodMap_comp_comp","module":"Mathlib.Data.PFun","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nε : Type u_5\nι : Type u_6\nf₁ : PFun α β\nf₂ : PFun β γ\ng₁ : PFun δ ε\ng₂ : PFun ε ι\n⊢ Eq ((f₂.comp f₁).prodMap (g₂.comp g₁)) ((f₂.prodMap g₂).comp (f₁.prodMap g₁))","decl":"@[simp]\ntheorem prodMap_comp_comp (f₁ : α →. β) (f₂ : β →. γ) (g₁ : δ →. ε) (g₂ : ε →. ι) :\n    (f₂.comp f₁).prodMap (g₂.comp g₁) = (f₂.prodMap g₂).comp (f₁.prodMap g₁) := -- by\n  -- Porting note: was `by tidy`, below is a golfed version of the `tidy?` proof\n  ext <| fun ⟨_, _⟩ ⟨_, _⟩ ↦\n  ⟨fun ⟨⟨⟨h1l1, h1l2⟩, ⟨h1r1, h1r2⟩⟩, h2⟩ ↦ ⟨⟨⟨h1l1, h1r1⟩, ⟨h1l2, h1r2⟩⟩, h2⟩,\n   fun ⟨⟨⟨h1l1, h1r1⟩, ⟨h1l2, h1r2⟩⟩, h2⟩ ↦ ⟨⟨⟨h1l1, h1l2⟩, ⟨h1r1, h1r2⟩⟩, h2⟩⟩\n\n"}
