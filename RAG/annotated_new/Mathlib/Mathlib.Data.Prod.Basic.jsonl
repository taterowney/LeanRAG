{"name":"Prod.swap_eq_iff_eq_swap","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nx : Prod α β\ny : Prod β α\n⊢ Iff (Eq x.swap y) (Eq x y.swap)","decl":"lemma swap_eq_iff_eq_swap {x : α × β} {y : β × α} : x.swap = y ↔ x = y.swap := by aesop\n\n"}
{"name":"Prod.mk.eta","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\np : Prod α β\n⊢ Eq { fst := p.fst, snd := p.snd } p","decl":"@[simp]\ntheorem mk.eta : ∀ {p : α × β}, (p.1, p.2) = p\n  | (_, _) => rfl\n\n"}
{"name":"Prod.forall'","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\np : α → β → Prop\n⊢ Iff (∀ (x : Prod α β), p x.fst x.snd) (∀ (a : α) (b : β), p a b)","decl":"theorem forall' {p : α → β → Prop} : (∀ x : α × β, p x.1 x.2) ↔ ∀ a b, p a b :=\n  Prod.forall\n\n"}
{"name":"Prod.exists'","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\np : α → β → Prop\n⊢ Iff (Exists fun x => p x.fst x.snd) (Exists fun a => Exists fun b => p a b)","decl":"theorem exists' {p : α → β → Prop} : (∃ x : α × β, p x.1 x.2) ↔ ∃ a b, p a b :=\n  Prod.exists\n\n"}
{"name":"Prod.snd_comp_mk","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nx : α\n⊢ Eq (Function.comp Prod.snd (Prod.mk x)) id","decl":"@[simp]\ntheorem snd_comp_mk (x : α) : Prod.snd ∘ (Prod.mk x : β → α × β) = id :=\n  rfl\n\n"}
{"name":"Prod.fst_comp_mk","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nx : α\n⊢ Eq (Function.comp Prod.fst (Prod.mk x)) (Function.const β x)","decl":"@[simp]\ntheorem fst_comp_mk (x : α) : Prod.fst ∘ (Prod.mk x : β → α × β) = Function.const β x :=\n  rfl\n\n"}
{"name":"Prod.map_mk","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : α → β\ng : γ → δ\nx : α\ny : γ\n⊢ Eq (Prod.map f g { fst := x, snd := y }) { fst := f x, snd := g y }","decl":"@[deprecated (since := \"2024-10-17\")] alias map_mk := map_apply\n\n"}
{"name":"Prod.map_apply'","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : α → γ\ng : β → δ\np : Prod α β\n⊢ Eq (Prod.map f g p) { fst := f p.fst, snd := g p.snd }","decl":"theorem map_apply' (f : α → γ) (g : β → δ) (p : α × β) : map f g p = (f p.1, g p.2) :=\n  rfl\n\n"}
{"name":"Prod.map_fst'","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : α → γ\ng : β → δ\n⊢ Eq (Function.comp Prod.fst (Prod.map f g)) (Function.comp f Prod.fst)","decl":"theorem map_fst' (f : α → γ) (g : β → δ) : Prod.fst ∘ map f g = f ∘ Prod.fst :=\n  funext <| map_fst f g\n\n"}
{"name":"Prod.map_snd'","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : α → γ\ng : β → δ\n⊢ Eq (Function.comp Prod.snd (Prod.map f g)) (Function.comp g Prod.snd)","decl":"theorem map_snd' (f : α → γ) (g : β → δ) : Prod.snd ∘ map f g = g ∘ Prod.snd :=\n  funext <| map_snd f g\n\n-- Porting note: `@[simp]` tag removed because auto-generated `mk.injEq` simplifies LHS\n-- @[simp]\n"}
{"name":"Prod.mk.inj_iff","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\na₁ a₂ : α\nb₁ b₂ : β\n⊢ Iff (Eq { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ }) (And (Eq a₁ a₂) (Eq b₁ b₂))","decl":"theorem mk.inj_iff {a₁ a₂ : α} {b₁ b₂ : β} : (a₁, b₁) = (a₂, b₂) ↔ a₁ = a₂ ∧ b₁ = b₂ :=\n  Iff.of_eq (mk.injEq _ _ _ _)\n\n"}
{"name":"Prod.mk.inj_left","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_5\nβ : Type u_6\na : α\n⊢ Function.Injective (Prod.mk a)","decl":"theorem mk.inj_left {α β : Type*} (a : α) : Function.Injective (Prod.mk a : β → α × β) := by\n  intro b₁ b₂ h\n  simpa only [true_and, Prod.mk.inj_iff, eq_self_iff_true] using h\n\n"}
{"name":"Prod.mk.inj_right","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_5\nβ : Type u_6\nb : β\n⊢ Function.Injective fun a => { fst := a, snd := b }","decl":"theorem mk.inj_right {α β : Type*} (b : β) :\n    Function.Injective (fun a ↦ Prod.mk a b : α → α × β) := by\n  intro b₁ b₂ h\n  simpa only [and_true, eq_self_iff_true, mk.inj_iff] using h\n\n"}
{"name":"Prod.mk_inj_left","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\nb₁ b₂ : β\n⊢ Iff (Eq { fst := a, snd := b₁ } { fst := a, snd := b₂ }) (Eq b₁ b₂)","decl":"lemma mk_inj_left {a : α} {b₁ b₂ : β} : (a, b₁) = (a, b₂) ↔ b₁ = b₂ := (mk.inj_left _).eq_iff\n\n"}
{"name":"Prod.mk_inj_right","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\na₁ a₂ : α\nb : β\n⊢ Iff (Eq { fst := a₁, snd := b } { fst := a₂, snd := b }) (Eq a₁ a₂)","decl":"lemma mk_inj_right {a₁ a₂ : α} {b : β} : (a₁, b) = (a₂, b) ↔ a₁ = a₂ := (mk.inj_right _).eq_iff\n\n"}
{"name":"Prod.map_def","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : α → γ\ng : β → δ\n⊢ Eq (Prod.map f g) fun p => { fst := f p.fst, snd := g p.snd }","decl":"theorem map_def {f : α → γ} {g : β → δ} : Prod.map f g = fun p : α × β ↦ (f p.1, g p.2) :=\n  funext fun p ↦ Prod.ext (map_fst f g p) (map_snd f g p)\n\n"}
{"name":"Prod.id_prod","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Eq (fun p => { fst := p.fst, snd := p.snd }) id","decl":"theorem id_prod : (fun p : α × β ↦ (p.1, p.2)) = id :=\n  rfl\n\n"}
{"name":"Prod.map_iterate","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → α\ng : β → β\nn : Nat\n⊢ Eq (Nat.iterate (Prod.map f g) n) (Prod.map (Nat.iterate f n) (Nat.iterate g n))","decl":"@[simp]\ntheorem map_iterate (f : α → α) (g : β → β) (n : ℕ) :\n    (Prod.map f g)^[n] = Prod.map f^[n] g^[n] := by induction n <;> simp [*, Prod.map_comp_map]\n\n"}
{"name":"Prod.fst_surjective","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nh : Nonempty β\n⊢ Function.Surjective Prod.fst","decl":"theorem fst_surjective [h : Nonempty β] : Function.Surjective (@fst α β) :=\n  fun x ↦ h.elim fun y ↦ ⟨⟨x, y⟩, rfl⟩\n\n"}
{"name":"Prod.snd_surjective","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nh : Nonempty α\n⊢ Function.Surjective Prod.snd","decl":"theorem snd_surjective [h : Nonempty α] : Function.Surjective (@snd α β) :=\n  fun y ↦ h.elim fun x ↦ ⟨⟨x, y⟩, rfl⟩\n\n"}
{"name":"Prod.fst_injective","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Subsingleton β\n⊢ Function.Injective Prod.fst","decl":"theorem fst_injective [Subsingleton β] : Function.Injective (@fst α β) :=\n  fun _ _ h ↦ Prod.ext h (Subsingleton.elim _ _)\n\n"}
{"name":"Prod.snd_injective","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Subsingleton α\n⊢ Function.Injective Prod.snd","decl":"theorem snd_injective [Subsingleton α] : Function.Injective (@snd α β) :=\n  fun _ _ h ↦ Prod.ext (Subsingleton.elim _ _) h\n\n"}
{"name":"Prod.swap_leftInverse","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Function.LeftInverse Prod.swap Prod.swap","decl":"@[simp]\ntheorem swap_leftInverse : Function.LeftInverse (@swap α β) swap :=\n  swap_swap\n\n"}
{"name":"Prod.swap_rightInverse","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Function.RightInverse Prod.swap Prod.swap","decl":"@[simp]\ntheorem swap_rightInverse : Function.RightInverse (@swap α β) swap :=\n  swap_swap\n\n"}
{"name":"Prod.swap_injective","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Function.Injective Prod.swap","decl":"theorem swap_injective : Function.Injective (@swap α β) :=\n  swap_leftInverse.injective\n\n"}
{"name":"Prod.swap_surjective","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Function.Surjective Prod.swap","decl":"theorem swap_surjective : Function.Surjective (@swap α β) :=\n  swap_leftInverse.surjective\n\n"}
{"name":"Prod.swap_bijective","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Function.Bijective Prod.swap","decl":"theorem swap_bijective : Function.Bijective (@swap α β) :=\n  ⟨swap_injective, swap_surjective⟩\n\n"}
{"name":"Function.Semiconj.swap_map","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → α\ng : β → β\n⊢ Function.Semiconj Prod.swap (Prod.map f g) (Prod.map g f)","decl":"theorem _root_.Function.Semiconj.swap_map (f : α → α) (g : β → β) :\n    Function.Semiconj swap (map f g) (map g f) :=\n  Function.semiconj_iff_comp_eq.2 (map_comp_swap g f).symm\n\n"}
{"name":"Prod.eq_iff_fst_eq_snd_eq","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\np q : Prod α β\n⊢ Iff (Eq p q) (And (Eq p.fst q.fst) (Eq p.snd q.snd))","decl":"theorem eq_iff_fst_eq_snd_eq : ∀ {p q : α × β}, p = q ↔ p.1 = q.1 ∧ p.2 = q.2\n  | ⟨p₁, p₂⟩, ⟨q₁, q₂⟩ => by simp\n\n"}
{"name":"Prod.fst_eq_iff","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\np : Prod α β\nx : α\n⊢ Iff (Eq p.fst x) (Eq p { fst := x, snd := p.snd })","decl":"theorem fst_eq_iff : ∀ {p : α × β} {x : α}, p.1 = x ↔ p = (x, p.2)\n  | ⟨a, b⟩, x => by simp\n\n"}
{"name":"Prod.snd_eq_iff","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\np : Prod α β\nx : β\n⊢ Iff (Eq p.snd x) (Eq p { fst := p.fst, snd := x })","decl":"theorem snd_eq_iff : ∀ {p : α × β} {x : β}, p.2 = x ↔ p = (p.1, x)\n  | ⟨a, b⟩, x => by simp\n\n"}
{"name":"Prod.lex_iff","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nx y : Prod α β\n⊢ Iff (Prod.Lex r s x y) (Or (r x.fst y.fst) (And (Eq x.fst y.fst) (s x.snd y.snd)))","decl":"lemma lex_iff : Prod.Lex r s x y ↔ r x.1 y.1 ∨ x.1 = y.1 ∧ s x.2 y.2 := lex_def\n\n"}
{"name":"Prod.Lex.refl_left","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsRefl α r\nx : Prod α β\n⊢ Prod.Lex r s x x","decl":"@[refl]\ntheorem Lex.refl_left (r : α → α → Prop) (s : β → β → Prop) [IsRefl α r] : ∀ x, Prod.Lex r s x x\n  | (_, _) => Lex.left _ _ (refl _)\n\n"}
{"name":"Prod.instIsReflLex","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsRefl α r\n⊢ IsRefl (Prod α β) (Prod.Lex r s)","decl":"instance {r : α → α → Prop} {s : β → β → Prop} [IsRefl α r] : IsRefl (α × β) (Prod.Lex r s) :=\n  ⟨Lex.refl_left _ _⟩\n\n"}
{"name":"Prod.Lex.refl_right","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsRefl β s\nx : Prod α β\n⊢ Prod.Lex r s x x","decl":"@[refl]\ntheorem Lex.refl_right (r : α → α → Prop) (s : β → β → Prop) [IsRefl β s] : ∀ x, Prod.Lex r s x x\n  | (_, _) => Lex.right _ (refl _)\n\n"}
{"name":"Prod.instIsReflLex_1","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsRefl β s\n⊢ IsRefl (Prod α β) (Prod.Lex r s)","decl":"instance {r : α → α → Prop} {s : β → β → Prop} [IsRefl β s] : IsRefl (α × β) (Prod.Lex r s) :=\n  ⟨Lex.refl_right _ _⟩\n\n"}
{"name":"Prod.isIrrefl","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsIrrefl α r\ninst✝ : IsIrrefl β s\n⊢ IsIrrefl (Prod α β) (Prod.Lex r s)","decl":"instance isIrrefl [IsIrrefl α r] [IsIrrefl β s] : IsIrrefl (α × β) (Prod.Lex r s) :=\n  ⟨by rintro ⟨i, a⟩ (⟨_, _, h⟩ | ⟨_, h⟩) <;> exact irrefl _ h⟩\n\n"}
{"name":"Prod.Lex.trans","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsTrans α r\ninst✝ : IsTrans β s\nx y z : Prod α β\na✝¹ : Prod.Lex r s x y\na✝ : Prod.Lex r s y z\n⊢ Prod.Lex r s x z","decl":"@[trans]\ntheorem Lex.trans {r : α → α → Prop} {s : β → β → Prop} [IsTrans α r] [IsTrans β s] :\n    ∀ {x y z : α × β}, Prod.Lex r s x y → Prod.Lex r s y z → Prod.Lex r s x z\n  | (_, _), (_, _), (_, _), left  _ _ hxy₁, left  _ _ hyz₁ => left  _ _ (_root_.trans hxy₁ hyz₁)\n  | (_, _), (_, _), (_, _), left  _ _ hxy₁, right _ _      => left  _ _ hxy₁\n  | (_, _), (_, _), (_, _), right _ _,      left  _ _ hyz₁ => left  _ _ hyz₁\n  | (_, _), (_, _), (_, _), right _ hxy₂,   right _ hyz₂   => right _ (_root_.trans hxy₂ hyz₂)\n\n"}
{"name":"Prod.instIsTransLex","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsTrans α r\ninst✝ : IsTrans β s\n⊢ IsTrans (Prod α β) (Prod.Lex r s)","decl":"instance {r : α → α → Prop} {s : β → β → Prop} [IsTrans α r] [IsTrans β s] :\n  IsTrans (α × β) (Prod.Lex r s) :=\n  ⟨fun _ _ _ ↦ Lex.trans⟩\n\n"}
{"name":"Prod.instIsAntisymmLexOfIsStrictOrder","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsStrictOrder α r\ninst✝ : IsAntisymm β s\n⊢ IsAntisymm (Prod α β) (Prod.Lex r s)","decl":"instance {r : α → α → Prop} {s : β → β → Prop} [IsStrictOrder α r] [IsAntisymm β s] :\n    IsAntisymm (α × β) (Prod.Lex r s) :=\n  ⟨fun x₁ x₂ h₁₂ h₂₁ ↦\n    match x₁, x₂, h₁₂, h₂₁ with\n    | (a, _), (_, _), .left  _ _ hr₁, .left  _ _ hr₂ => (irrefl a (_root_.trans hr₁ hr₂)).elim\n    | (_, _), (_, _), .left  _ _ hr₁, .right _ _     => (irrefl _ hr₁).elim\n    | (_, _), (_, _), .right _ _,     .left  _ _ hr₂ => (irrefl _ hr₂).elim\n    | (_, _), (_, _), .right _ hs₁,   .right _ hs₂   => antisymm hs₁ hs₂ ▸ rfl⟩\n\n"}
{"name":"Prod.isTotal_left","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsTotal α r\n⊢ IsTotal (Prod α β) (Prod.Lex r s)","decl":"instance isTotal_left {r : α → α → Prop} {s : β → β → Prop} [IsTotal α r] :\n    IsTotal (α × β) (Prod.Lex r s) :=\n  ⟨fun ⟨a₁, _⟩ ⟨a₂, _⟩ ↦ (IsTotal.total a₁ a₂).imp (Lex.left _ _) (Lex.left _ _)⟩\n\n"}
{"name":"Prod.isTotal_right","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsTrichotomous α r\ninst✝ : IsTotal β s\n⊢ IsTotal (Prod α β) (Prod.Lex r s)","decl":"instance isTotal_right {r : α → α → Prop} {s : β → β → Prop} [IsTrichotomous α r] [IsTotal β s] :\n    IsTotal (α × β) (Prod.Lex r s) :=\n  ⟨fun ⟨i, a⟩ ⟨j, b⟩ ↦ by\n    obtain hij | rfl | hji := trichotomous_of r i j\n    · exact Or.inl (.left _ _ hij)\n    · exact (total_of s a b).imp (.right _) (.right _)\n    · exact Or.inr (.left _ _ hji) ⟩\n\n"}
{"name":"Prod.IsTrichotomous","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsTrichotomous α r\ninst✝ : IsTrichotomous β s\n⊢ IsTrichotomous (Prod α β) (Prod.Lex r s)","decl":"instance IsTrichotomous [IsTrichotomous α r] [IsTrichotomous β s] :\n  IsTrichotomous (α × β) (Prod.Lex r s) :=\n⟨fun ⟨i, a⟩ ⟨j, b⟩ ↦ by\n  obtain hij | rfl | hji := trichotomous_of r i j\n  { exact Or.inl (Lex.left _ _ hij) }\n  { exact (trichotomous_of (s) a b).imp3 (Lex.right _) (congr_arg _) (Lex.right _) }\n  { exact Or.inr (Or.inr <| Lex.left _ _ hji) }⟩\n\n"}
{"name":"Function.Injective.prodMap","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : α → γ\ng : β → δ\nhf : Function.Injective f\nhg : Function.Injective g\n⊢ Function.Injective (Prod.map f g)","decl":"theorem Injective.prodMap (hf : Injective f) (hg : Injective g) : Injective (map f g) :=\n  fun _ _ h ↦ Prod.ext (hf <| congr_arg Prod.fst h) (hg <| congr_arg Prod.snd h)\n\n"}
{"name":"Function.Surjective.prodMap","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : α → γ\ng : β → δ\nhf : Function.Surjective f\nhg : Function.Surjective g\n⊢ Function.Surjective (Prod.map f g)","decl":"theorem Surjective.prodMap (hf : Surjective f) (hg : Surjective g) : Surjective (map f g) :=\n  fun p ↦\n  let ⟨x, hx⟩ := hf p.1\n  let ⟨y, hy⟩ := hg p.2\n  ⟨(x, y), Prod.ext hx hy⟩\n\n"}
{"name":"Function.Bijective.prodMap","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : α → γ\ng : β → δ\nhf : Function.Bijective f\nhg : Function.Bijective g\n⊢ Function.Bijective (Prod.map f g)","decl":"theorem Bijective.prodMap (hf : Bijective f) (hg : Bijective g) : Bijective (map f g) :=\n  ⟨hf.1.prodMap hg.1, hf.2.prodMap hg.2⟩\n\n"}
{"name":"Function.LeftInverse.prodMap","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf₁ : α → β\ng₁ : γ → δ\nf₂ : β → α\ng₂ : δ → γ\nhf : Function.LeftInverse f₁ f₂\nhg : Function.LeftInverse g₁ g₂\n⊢ Function.LeftInverse (Prod.map f₁ g₁) (Prod.map f₂ g₂)","decl":"theorem LeftInverse.prodMap (hf : LeftInverse f₁ f₂) (hg : LeftInverse g₁ g₂) :\n    LeftInverse (map f₁ g₁) (map f₂ g₂) :=\n  fun a ↦ by rw [Prod.map_map, hf.comp_eq_id, hg.comp_eq_id, map_id, id]\n\n"}
{"name":"Function.RightInverse.prodMap","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf₁ : α → β\ng₁ : γ → δ\nf₂ : β → α\ng₂ : δ → γ\na✝¹ : Function.RightInverse f₁ f₂\na✝ : Function.RightInverse g₁ g₂\n⊢ Function.RightInverse (Prod.map f₁ g₁) (Prod.map f₂ g₂)","decl":"theorem RightInverse.prodMap :\n    RightInverse f₁ f₂ → RightInverse g₁ g₂ → RightInverse (map f₁ g₁) (map f₂ g₂) :=\n  LeftInverse.prodMap\n\n"}
{"name":"Function.Involutive.prodMap","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → α\ng : β → β\na✝¹ : Function.Involutive f\na✝ : Function.Involutive g\n⊢ Function.Involutive (Prod.map f g)","decl":"theorem Involutive.prodMap {f : α → α} {g : β → β} :\n    Involutive f → Involutive g → Involutive (map f g) :=\n  LeftInverse.prodMap\n\n"}
{"name":"Prod.map_injective","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ninst✝¹ : Nonempty α\ninst✝ : Nonempty β\nf : α → γ\ng : β → δ\n⊢ Iff (Function.Injective (Prod.map f g)) (And (Function.Injective f) (Function.Injective g))","decl":"@[simp]\ntheorem map_injective [Nonempty α] [Nonempty β] {f : α → γ} {g : β → δ} :\n    Injective (map f g) ↔ Injective f ∧ Injective g :=\n  ⟨fun h =>\n    ⟨fun a₁ a₂ ha => by\n      inhabit β\n      injection\n        @h (a₁, default) (a₂, default) (congr_arg (fun c : γ => Prod.mk c (g default)) ha :),\n      fun b₁ b₂ hb => by\n      inhabit α\n      injection @h (default, b₁) (default, b₂) (congr_arg (Prod.mk (f default)) hb :)⟩,\n    fun h => h.1.prodMap h.2⟩\n\n"}
{"name":"Prod.map_surjective","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ninst✝¹ : Nonempty γ\ninst✝ : Nonempty δ\nf : α → γ\ng : β → δ\n⊢ Iff (Function.Surjective (Prod.map f g)) (And (Function.Surjective f) (Function.Surjective g))","decl":"@[simp]\ntheorem map_surjective [Nonempty γ] [Nonempty δ] {f : α → γ} {g : β → δ} :\n    Surjective (map f g) ↔ Surjective f ∧ Surjective g :=\n  ⟨fun h =>\n    ⟨fun c => by\n      inhabit δ\n      obtain ⟨⟨a, b⟩, h⟩ := h (c, default)\n      exact ⟨a, congr_arg Prod.fst h⟩,\n      fun d => by\n      inhabit γ\n      obtain ⟨⟨a, b⟩, h⟩ := h (default, d)\n      exact ⟨b, congr_arg Prod.snd h⟩⟩,\n    fun h => h.1.prodMap h.2⟩\n\n"}
{"name":"Prod.map_bijective","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ninst✝¹ : Nonempty α\ninst✝ : Nonempty β\nf : α → γ\ng : β → δ\n⊢ Iff (Function.Bijective (Prod.map f g)) (And (Function.Bijective f) (Function.Bijective g))","decl":"@[simp]\ntheorem map_bijective [Nonempty α] [Nonempty β] {f : α → γ} {g : β → δ} :\n    Bijective (map f g) ↔ Bijective f ∧ Bijective g := by\n  haveI := Nonempty.map f ‹_›\n  haveI := Nonempty.map g ‹_›\n  exact (map_injective.and map_surjective).trans and_and_and_comm\n\n"}
{"name":"Prod.map_leftInverse","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ninst✝¹ : Nonempty β\ninst✝ : Nonempty δ\nf₁ : α → β\ng₁ : γ → δ\nf₂ : β → α\ng₂ : δ → γ\n⊢ Iff (Function.LeftInverse (Prod.map f₁ g₁) (Prod.map f₂ g₂)) (And (Function.LeftInverse f₁ f₂) (Function.LeftInverse g₁ g₂))","decl":"@[simp]\ntheorem map_leftInverse [Nonempty β] [Nonempty δ] {f₁ : α → β} {g₁ : γ → δ} {f₂ : β → α}\n    {g₂ : δ → γ} : LeftInverse (map f₁ g₁) (map f₂ g₂) ↔ LeftInverse f₁ f₂ ∧ LeftInverse g₁ g₂ :=\n  ⟨fun h =>\n    ⟨fun b => by\n      inhabit δ\n      exact congr_arg Prod.fst (h (b, default)),\n      fun d => by\n      inhabit β\n      exact congr_arg Prod.snd (h (default, d))⟩,\n    fun h => h.1.prodMap h.2 ⟩\n\n"}
{"name":"Prod.map_rightInverse","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ninst✝¹ : Nonempty α\ninst✝ : Nonempty γ\nf₁ : α → β\ng₁ : γ → δ\nf₂ : β → α\ng₂ : δ → γ\n⊢ Iff (Function.RightInverse (Prod.map f₁ g₁) (Prod.map f₂ g₂)) (And (Function.RightInverse f₁ f₂) (Function.RightInverse g₁ g₂))","decl":"@[simp]\ntheorem map_rightInverse [Nonempty α] [Nonempty γ] {f₁ : α → β} {g₁ : γ → δ} {f₂ : β → α}\n    {g₂ : δ → γ} : RightInverse (map f₁ g₁) (map f₂ g₂) ↔ RightInverse f₁ f₂ ∧ RightInverse g₁ g₂ :=\n  map_leftInverse\n\n"}
{"name":"Prod.map_involutive","module":"Mathlib.Data.Prod.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Nonempty α\ninst✝ : Nonempty β\nf : α → α\ng : β → β\n⊢ Iff (Function.Involutive (Prod.map f g)) (And (Function.Involutive f) (Function.Involutive g))","decl":"@[simp]\ntheorem map_involutive [Nonempty α] [Nonempty β] {f : α → α} {g : β → β} :\n    Involutive (map f g) ↔ Involutive f ∧ Involutive g :=\n  map_leftInverse\n\n"}
