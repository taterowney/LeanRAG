{"name":"MonotoneOn.congr","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf₁ f₂ : α → β\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nh₁ : MonotoneOn f₁ s\nh : Set.EqOn f₁ f₂ s\n⊢ MonotoneOn f₂ s","decl":"theorem _root_.MonotoneOn.congr (h₁ : MonotoneOn f₁ s) (h : s.EqOn f₁ f₂) : MonotoneOn f₂ s := by\n  intro a ha b hb hab\n  rw [← h ha, ← h hb]\n  exact h₁ ha hb hab\n\n"}
{"name":"AntitoneOn.congr","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf₁ f₂ : α → β\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nh₁ : AntitoneOn f₁ s\nh : Set.EqOn f₁ f₂ s\n⊢ AntitoneOn f₂ s","decl":"theorem _root_.AntitoneOn.congr (h₁ : AntitoneOn f₁ s) (h : s.EqOn f₁ f₂) : AntitoneOn f₂ s :=\n  h₁.dual_right.congr h\n\n"}
{"name":"StrictMonoOn.congr","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf₁ f₂ : α → β\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nh₁ : StrictMonoOn f₁ s\nh : Set.EqOn f₁ f₂ s\n⊢ StrictMonoOn f₂ s","decl":"theorem _root_.StrictMonoOn.congr (h₁ : StrictMonoOn f₁ s) (h : s.EqOn f₁ f₂) :\n    StrictMonoOn f₂ s := by\n  intro a ha b hb hab\n  rw [← h ha, ← h hb]\n  exact h₁ ha hb hab\n\n"}
{"name":"StrictAntiOn.congr","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf₁ f₂ : α → β\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nh₁ : StrictAntiOn f₁ s\nh : Set.EqOn f₁ f₂ s\n⊢ StrictAntiOn f₂ s","decl":"theorem _root_.StrictAntiOn.congr (h₁ : StrictAntiOn f₁ s) (h : s.EqOn f₁ f₂) : StrictAntiOn f₂ s :=\n  h₁.dual_right.congr h\n\n"}
{"name":"Set.EqOn.congr_monotoneOn","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf₁ f₂ : α → β\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nh : Set.EqOn f₁ f₂ s\n⊢ Iff (MonotoneOn f₁ s) (MonotoneOn f₂ s)","decl":"theorem EqOn.congr_monotoneOn (h : s.EqOn f₁ f₂) : MonotoneOn f₁ s ↔ MonotoneOn f₂ s :=\n  ⟨fun h₁ => h₁.congr h, fun h₂ => h₂.congr h.symm⟩\n\n"}
{"name":"Set.EqOn.congr_antitoneOn","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf₁ f₂ : α → β\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nh : Set.EqOn f₁ f₂ s\n⊢ Iff (AntitoneOn f₁ s) (AntitoneOn f₂ s)","decl":"theorem EqOn.congr_antitoneOn (h : s.EqOn f₁ f₂) : AntitoneOn f₁ s ↔ AntitoneOn f₂ s :=\n  ⟨fun h₁ => h₁.congr h, fun h₂ => h₂.congr h.symm⟩\n\n"}
{"name":"Set.EqOn.congr_strictMonoOn","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf₁ f₂ : α → β\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nh : Set.EqOn f₁ f₂ s\n⊢ Iff (StrictMonoOn f₁ s) (StrictMonoOn f₂ s)","decl":"theorem EqOn.congr_strictMonoOn (h : s.EqOn f₁ f₂) : StrictMonoOn f₁ s ↔ StrictMonoOn f₂ s :=\n  ⟨fun h₁ => h₁.congr h, fun h₂ => h₂.congr h.symm⟩\n\n"}
{"name":"Set.EqOn.congr_strictAntiOn","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf₁ f₂ : α → β\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nh : Set.EqOn f₁ f₂ s\n⊢ Iff (StrictAntiOn f₁ s) (StrictAntiOn f₂ s)","decl":"theorem EqOn.congr_strictAntiOn (h : s.EqOn f₁ f₂) : StrictAntiOn f₁ s ↔ StrictAntiOn f₂ s :=\n  ⟨fun h₁ => h₁.congr h, fun h₂ => h₂.congr h.symm⟩\n\n"}
{"name":"MonotoneOn.mono","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ns s₂ : Set α\nf : α → β\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nh : MonotoneOn f s\nh' : HasSubset.Subset s₂ s\n⊢ MonotoneOn f s₂","decl":"theorem _root_.MonotoneOn.mono (h : MonotoneOn f s) (h' : s₂ ⊆ s) : MonotoneOn f s₂ :=\n  fun _ hx _ hy => h (h' hx) (h' hy)\n\n"}
{"name":"AntitoneOn.mono","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ns s₂ : Set α\nf : α → β\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nh : AntitoneOn f s\nh' : HasSubset.Subset s₂ s\n⊢ AntitoneOn f s₂","decl":"theorem _root_.AntitoneOn.mono (h : AntitoneOn f s) (h' : s₂ ⊆ s) : AntitoneOn f s₂ :=\n  fun _ hx _ hy => h (h' hx) (h' hy)\n\n"}
{"name":"StrictMonoOn.mono","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ns s₂ : Set α\nf : α → β\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nh : StrictMonoOn f s\nh' : HasSubset.Subset s₂ s\n⊢ StrictMonoOn f s₂","decl":"theorem _root_.StrictMonoOn.mono (h : StrictMonoOn f s) (h' : s₂ ⊆ s) : StrictMonoOn f s₂ :=\n  fun _ hx _ hy => h (h' hx) (h' hy)\n\n"}
{"name":"StrictAntiOn.mono","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ns s₂ : Set α\nf : α → β\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nh : StrictAntiOn f s\nh' : HasSubset.Subset s₂ s\n⊢ StrictAntiOn f s₂","decl":"theorem _root_.StrictAntiOn.mono (h : StrictAntiOn f s) (h' : s₂ ⊆ s) : StrictAntiOn f s₂ :=\n  fun _ hx _ hy => h (h' hx) (h' hy)\n\n"}
{"name":"MonotoneOn.monotone","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nh : MonotoneOn f s\n⊢ Monotone (Function.comp f Subtype.val)","decl":"protected theorem _root_.MonotoneOn.monotone (h : MonotoneOn f s) :\n    Monotone (f ∘ Subtype.val : s → β) :=\n  fun x y hle => h x.coe_prop y.coe_prop hle\n\n"}
{"name":"AntitoneOn.monotone","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nh : AntitoneOn f s\n⊢ Antitone (Function.comp f Subtype.val)","decl":"protected theorem _root_.AntitoneOn.monotone (h : AntitoneOn f s) :\n    Antitone (f ∘ Subtype.val : s → β) :=\n  fun x y hle => h x.coe_prop y.coe_prop hle\n\n"}
{"name":"StrictMonoOn.strictMono","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nh : StrictMonoOn f s\n⊢ StrictMono (Function.comp f Subtype.val)","decl":"protected theorem _root_.StrictMonoOn.strictMono (h : StrictMonoOn f s) :\n    StrictMono (f ∘ Subtype.val : s → β) :=\n  fun x y hlt => h x.coe_prop y.coe_prop hlt\n\n"}
{"name":"StrictAntiOn.strictAnti","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nh : StrictAntiOn f s\n⊢ StrictAnti (Function.comp f Subtype.val)","decl":"protected theorem _root_.StrictAntiOn.strictAnti (h : StrictAntiOn f s) :\n    StrictAnti (f ∘ Subtype.val : s → β) :=\n  fun x y hlt => h x.coe_prop y.coe_prop hlt\n\n"}
{"name":"Set.MonotoneOn_insert_iff","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na : α\n⊢ Iff (MonotoneOn f (Insert.insert a s)) (And (∀ (b : α), Membership.mem s b → LE.le b a → LE.le (f b) (f a)) (And (∀ (b : α), Membership.mem s b → LE.le a b → LE.le (f a) (f b)) (MonotoneOn f s)))","decl":"lemma MonotoneOn_insert_iff {a : α} :\n    MonotoneOn f (insert a s) ↔\n       (∀ b ∈ s, b ≤ a → f b ≤ f a) ∧ (∀ b ∈ s, a ≤ b → f a ≤ f b) ∧ MonotoneOn f s := by\n  simp [MonotoneOn, forall_and]\n\n"}
{"name":"Set.AntitoneOn_insert_iff","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na : α\n⊢ Iff (AntitoneOn f (Insert.insert a s)) (And (∀ (b : α), Membership.mem s b → LE.le b a → LE.le (f a) (f b)) (And (∀ (b : α), Membership.mem s b → LE.le a b → LE.le (f b) (f a)) (AntitoneOn f s)))","decl":"lemma AntitoneOn_insert_iff {a : α} :\n    AntitoneOn f (insert a s) ↔\n       (∀ b ∈ s, b ≤ a → f a ≤ f b) ∧ (∀ b ∈ s, a ≤ b → f b ≤ f a) ∧ AntitoneOn f s :=\n  @MonotoneOn_insert_iff α βᵒᵈ _ _ _ _ _\n\n"}
{"name":"Monotone.restrict","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nh : Monotone f\ns : Set α\n⊢ Monotone (s.restrict f)","decl":"protected theorem restrict (h : Monotone f) (s : Set α) : Monotone (s.restrict f) := fun _ _ hxy =>\n  h hxy\n\n"}
{"name":"Monotone.codRestrict","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nh : Monotone f\ns : Set β\nhs : ∀ (x : α), Membership.mem s (f x)\n⊢ Monotone (Set.codRestrict f s hs)","decl":"protected theorem codRestrict (h : Monotone f) {s : Set β} (hs : ∀ x, f x ∈ s) :\n    Monotone (s.codRestrict f hs) :=\n  h\n\n"}
{"name":"Monotone.rangeFactorization","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nh : Monotone f\n⊢ Monotone (Set.rangeFactorization f)","decl":"protected theorem rangeFactorization (h : Monotone f) : Monotone (Set.rangeFactorization f) :=\n  h\n\n"}
{"name":"StrictMonoOn.injOn","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\nH : StrictMonoOn f s\n⊢ Set.InjOn f s","decl":"theorem StrictMonoOn.injOn [LinearOrder α] [Preorder β] {f : α → β} {s : Set α}\n    (H : StrictMonoOn f s) : s.InjOn f := fun x hx y hy hxy =>\n  show Ordering.eq.Compares x y from (H.compares hx hy).1 hxy\n\n"}
{"name":"StrictAntiOn.injOn","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\nH : StrictAntiOn f s\n⊢ Set.InjOn f s","decl":"theorem StrictAntiOn.injOn [LinearOrder α] [Preorder β] {f : α → β} {s : Set α}\n    (H : StrictAntiOn f s) : s.InjOn f :=\n  @StrictMonoOn.injOn α βᵒᵈ _ _ f s H\n\n"}
{"name":"StrictMonoOn.comp","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : β → γ\nf : α → β\ns : Set α\nt : Set β\nhg : StrictMonoOn g t\nhf : StrictMonoOn f s\nhs : Set.MapsTo f s t\n⊢ StrictMonoOn (Function.comp g f) s","decl":"theorem StrictMonoOn.comp [Preorder α] [Preorder β] [Preorder γ] {g : β → γ} {f : α → β} {s : Set α}\n    {t : Set β} (hg : StrictMonoOn g t) (hf : StrictMonoOn f s) (hs : Set.MapsTo f s t) :\n    StrictMonoOn (g ∘ f) s := fun _x hx _y hy hxy => hg (hs hx) (hs hy) <| hf hx hy hxy\n\n"}
{"name":"StrictMonoOn.comp_strictAntiOn","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : β → γ\nf : α → β\ns : Set α\nt : Set β\nhg : StrictMonoOn g t\nhf : StrictAntiOn f s\nhs : Set.MapsTo f s t\n⊢ StrictAntiOn (Function.comp g f) s","decl":"theorem StrictMonoOn.comp_strictAntiOn [Preorder α] [Preorder β] [Preorder γ] {g : β → γ}\n    {f : α → β} {s : Set α} {t : Set β} (hg : StrictMonoOn g t) (hf : StrictAntiOn f s)\n    (hs : Set.MapsTo f s t) : StrictAntiOn (g ∘ f) s := fun _x hx _y hy hxy =>\n  hg (hs hy) (hs hx) <| hf hx hy hxy\n\n"}
{"name":"StrictAntiOn.comp","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : β → γ\nf : α → β\ns : Set α\nt : Set β\nhg : StrictAntiOn g t\nhf : StrictAntiOn f s\nhs : Set.MapsTo f s t\n⊢ StrictMonoOn (Function.comp g f) s","decl":"theorem StrictAntiOn.comp [Preorder α] [Preorder β] [Preorder γ] {g : β → γ} {f : α → β} {s : Set α}\n    {t : Set β} (hg : StrictAntiOn g t) (hf : StrictAntiOn f s) (hs : Set.MapsTo f s t) :\n    StrictMonoOn (g ∘ f) s := fun _x hx _y hy hxy => hg (hs hy) (hs hx) <| hf hx hy hxy\n\n"}
{"name":"StrictAntiOn.comp_strictMonoOn","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : β → γ\nf : α → β\ns : Set α\nt : Set β\nhg : StrictAntiOn g t\nhf : StrictMonoOn f s\nhs : Set.MapsTo f s t\n⊢ StrictAntiOn (Function.comp g f) s","decl":"theorem StrictAntiOn.comp_strictMonoOn [Preorder α] [Preorder β] [Preorder γ] {g : β → γ}\n    {f : α → β} {s : Set α} {t : Set β} (hg : StrictAntiOn g t) (hf : StrictMonoOn f s)\n    (hs : Set.MapsTo f s t) : StrictAntiOn (g ∘ f) s := fun _x hx _y hy hxy =>\n  hg (hs hx) (hs hy) <| hf hx hy hxy\n\n"}
{"name":"strictMono_restrict","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\n⊢ Iff (StrictMono (s.restrict f)) (StrictMonoOn f s)","decl":"@[simp]\ntheorem strictMono_restrict [Preorder α] [Preorder β] {f : α → β} {s : Set α} :\n    StrictMono (s.restrict f) ↔ StrictMonoOn f s := by simp [Set.restrict, StrictMono, StrictMonoOn]\n\n"}
{"name":"StrictMono.of_restrict","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\na✝ : StrictMono (s.restrict f)\n⊢ StrictMonoOn f s","decl":"alias ⟨_root_.StrictMono.of_restrict, _root_.StrictMonoOn.restrict⟩ := strictMono_restrict\n\n"}
{"name":"StrictMonoOn.restrict","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\na✝ : StrictMonoOn f s\n⊢ StrictMono (s.restrict f)","decl":"alias ⟨_root_.StrictMono.of_restrict, _root_.StrictMonoOn.restrict⟩ := strictMono_restrict\n\n"}
{"name":"StrictMono.codRestrict","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nhf : StrictMono f\ns : Set β\nhs : ∀ (x : α), Membership.mem s (f x)\n⊢ StrictMono (Set.codRestrict f s hs)","decl":"theorem StrictMono.codRestrict [Preorder α] [Preorder β] {f : α → β} (hf : StrictMono f)\n    {s : Set β} (hs : ∀ x, f x ∈ s) : StrictMono (Set.codRestrict f s hs) :=\n  hf\n\n"}
{"name":"strictMonoOn_insert_iff","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\n⊢ Iff (StrictMonoOn f (Insert.insert a s)) (And (∀ (b : α), Membership.mem s b → LT.lt b a → LT.lt (f b) (f a)) (And (∀ (b : α), Membership.mem s b → LT.lt a b → LT.lt (f a) (f b)) (StrictMonoOn f s)))","decl":"lemma strictMonoOn_insert_iff [Preorder α] [Preorder β] {f : α → β} {s : Set α} {a : α} :\n    StrictMonoOn f (insert a s) ↔\n       (∀ b ∈ s, b < a → f b < f a) ∧ (∀ b ∈ s, a < b → f a < f b) ∧ StrictMonoOn f s := by\n  simp [StrictMonoOn, forall_and]\n\n"}
{"name":"strictAntiOn_insert_iff","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\n⊢ Iff (StrictAntiOn f (Insert.insert a s)) (And (∀ (b : α), Membership.mem s b → LT.lt b a → LT.lt (f a) (f b)) (And (∀ (b : α), Membership.mem s b → LT.lt a b → LT.lt (f b) (f a)) (StrictAntiOn f s)))","decl":"lemma strictAntiOn_insert_iff [Preorder α] [Preorder β] {f : α → β} {s : Set α} {a : α} :\n    StrictAntiOn f (insert a s) ↔\n       (∀ b ∈ s, b < a → f a < f b) ∧ (∀ b ∈ s, a < b → f b < f a) ∧ StrictAntiOn f s :=\n  @strictMonoOn_insert_iff α βᵒᵈ _ _ _ _ _\n\n"}
{"name":"Function.monotoneOn_of_rightInvOn_of_mapsTo","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : PartialOrder α\ninst✝ : LinearOrder β\nφ : β → α\nψ : α → β\nt : Set β\ns : Set α\nhφ : MonotoneOn φ t\nφψs : Set.RightInvOn ψ φ s\nψts : Set.MapsTo ψ s t\n⊢ MonotoneOn ψ s","decl":"theorem monotoneOn_of_rightInvOn_of_mapsTo {α β : Type*} [PartialOrder α] [LinearOrder β]\n    {φ : β → α} {ψ : α → β} {t : Set β} {s : Set α} (hφ : MonotoneOn φ t)\n    (φψs : Set.RightInvOn ψ φ s) (ψts : Set.MapsTo ψ s t) : MonotoneOn ψ s := by\n  rintro x xs y ys l\n  rcases le_total (ψ x) (ψ y) with (ψxy|ψyx)\n  · exact ψxy\n  · have := hφ (ψts ys) (ψts xs) ψyx\n    rw [φψs.eq ys, φψs.eq xs] at this\n    induction le_antisymm l this\n    exact le_refl _\n\n"}
{"name":"Function.antitoneOn_of_rightInvOn_of_mapsTo","module":"Mathlib.Data.Set.Monotone","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : LinearOrder β\nφ : β → α\nψ : α → β\nt : Set β\ns : Set α\nhφ : AntitoneOn φ t\nφψs : Set.RightInvOn ψ φ s\nψts : Set.MapsTo ψ s t\n⊢ AntitoneOn ψ s","decl":"theorem antitoneOn_of_rightInvOn_of_mapsTo [PartialOrder α] [LinearOrder β]\n    {φ : β → α} {ψ : α → β} {t : Set β} {s : Set α} (hφ : AntitoneOn φ t)\n    (φψs : Set.RightInvOn ψ φ s) (ψts : Set.MapsTo ψ s t) : AntitoneOn ψ s :=\n  (monotoneOn_of_rightInvOn_of_mapsTo hφ.dual_left φψs ψts).dual_right\n\n"}
