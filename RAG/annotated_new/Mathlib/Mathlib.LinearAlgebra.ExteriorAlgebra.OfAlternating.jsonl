{"name":"ExteriorAlgebra.liftAlternating_ι","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.OfAlternating","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : (i : Nat) → AlternatingMap R M N (Fin i)\nm : M\n⊢ Eq ((ExteriorAlgebra.liftAlternating f) ((ExteriorAlgebra.ι R) m)) ((f 1) (Matrix.vecCons m Matrix.vecEmpty))","decl":"@[simp]\ntheorem liftAlternating_ι (f : ∀ i, M [⋀^Fin i]→ₗ[R] N) (m : M) :\n    liftAlternating (R := R) (M := M) (N := N) f (ι R m) = f 1 ![m] := by\n  dsimp [liftAlternating]\n  rw [foldl_ι, LinearMap.mk₂_apply, AlternatingMap.curryLeft_apply_apply]\n  congr\n  -- Porting note: In Lean 3, `congr` could use the `[Subsingleton (Fin 0 → M)]` instance to finish\n  -- the proof. Here, the instance can be synthesized but `congr` does not use it so the following\n  -- line is provided.\n  rw [Matrix.zero_empty]\n\n"}
{"name":"ExteriorAlgebra.liftAlternating_ι_mul","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.OfAlternating","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : (i : Nat) → AlternatingMap R M N (Fin i)\nm : M\nx : ExteriorAlgebra R M\n⊢ Eq ((ExteriorAlgebra.liftAlternating f) (HMul.hMul ((ExteriorAlgebra.ι R) m) x)) ((ExteriorAlgebra.liftAlternating fun i => (f i.succ).curryLeft m) x)","decl":"theorem liftAlternating_ι_mul (f : ∀ i, M [⋀^Fin i]→ₗ[R] N) (m : M)\n    (x : ExteriorAlgebra R M) :\n    liftAlternating (R := R) (M := M) (N := N) f (ι R m * x) =\n    liftAlternating (R := R) (M := M) (N := N) (fun i => (f i.succ).curryLeft m) x := by\n  dsimp [liftAlternating]\n  rw [foldl_mul, foldl_ι]\n  rfl\n\n"}
{"name":"ExteriorAlgebra.liftAlternating_one","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.OfAlternating","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : (i : Nat) → AlternatingMap R M N (Fin i)\n⊢ Eq ((ExteriorAlgebra.liftAlternating f) 1) ((f 0) 0)","decl":"@[simp]\ntheorem liftAlternating_one (f : ∀ i, M [⋀^Fin i]→ₗ[R] N) :\n    liftAlternating (R := R) (M := M) (N := N) f (1 : ExteriorAlgebra R M) = f 0 0 := by\n  dsimp [liftAlternating]\n  rw [foldl_one]\n\n"}
{"name":"ExteriorAlgebra.liftAlternating_algebraMap","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.OfAlternating","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : (i : Nat) → AlternatingMap R M N (Fin i)\nr : R\n⊢ Eq ((ExteriorAlgebra.liftAlternating f) ((algebraMap R (ExteriorAlgebra R M)) r)) (HSMul.hSMul r ((f 0) 0))","decl":"@[simp]\ntheorem liftAlternating_algebraMap (f : ∀ i, M [⋀^Fin i]→ₗ[R] N) (r : R) :\n    liftAlternating (R := R) (M := M) (N := N) f (algebraMap _ (ExteriorAlgebra R M) r) =\n    r • f 0 0 := by\n  rw [Algebra.algebraMap_eq_smul_one, map_smul, liftAlternating_one]\n\n"}
{"name":"ExteriorAlgebra.liftAlternating_apply_ιMulti","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.OfAlternating","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nn : Nat\nf : (i : Nat) → AlternatingMap R M N (Fin i)\nv : Fin n → M\n⊢ Eq ((ExteriorAlgebra.liftAlternating f) ((ExteriorAlgebra.ιMulti R n) v)) ((f n) v)","decl":"@[simp]\ntheorem liftAlternating_apply_ιMulti {n : ℕ} (f : ∀ i, M [⋀^Fin i]→ₗ[R] N)\n    (v : Fin n → M) : liftAlternating (R := R) (M := M) (N := N) f (ιMulti R n v) = f n v := by\n  rw [ιMulti_apply]\n  -- Porting note: `v` is generalized automatically so it was removed from the next line\n  induction' n with n ih generalizing f\n  · -- Porting note: Lean does not automatically synthesize the instance\n    -- `[Subsingleton (Fin 0 → M)]` which is needed for `Subsingleton.elim 0 v` on line 114.\n    letI : Subsingleton (Fin 0 → M) := by infer_instance\n    rw [List.ofFn_zero, List.prod_nil, liftAlternating_one, Subsingleton.elim 0 v]\n  · rw [List.ofFn_succ, List.prod_cons, liftAlternating_ι_mul, ih,\n      AlternatingMap.curryLeft_apply_apply]\n    congr\n    exact Matrix.cons_head_tail _\n\n"}
{"name":"ExteriorAlgebra.liftAlternating_comp_ιMulti","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.OfAlternating","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nn : Nat\nf : (i : Nat) → AlternatingMap R M N (Fin i)\n⊢ Eq ((ExteriorAlgebra.liftAlternating f).compAlternatingMap (ExteriorAlgebra.ιMulti R n)) (f n)","decl":"@[simp]\ntheorem liftAlternating_comp_ιMulti {n : ℕ} (f : ∀ i, M [⋀^Fin i]→ₗ[R] N) :\n    (liftAlternating (R := R) (M := M) (N := N) f).compAlternatingMap (ιMulti R n) = f n :=\n  AlternatingMap.ext <| liftAlternating_apply_ιMulti f\n\n"}
{"name":"ExteriorAlgebra.liftAlternating_comp","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.OfAlternating","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nN' : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : AddCommGroup N'\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R N'\ng : LinearMap (RingHom.id R) N N'\nf : (i : Nat) → AlternatingMap R M N (Fin i)\n⊢ Eq (ExteriorAlgebra.liftAlternating fun i => g.compAlternatingMap (f i)) (g.comp (ExteriorAlgebra.liftAlternating f))","decl":"@[simp]\ntheorem liftAlternating_comp (g : N →ₗ[R] N') (f : ∀ i, M [⋀^Fin i]→ₗ[R] N) :\n    (liftAlternating (R := R) (M := M) (N := N') fun i => g.compAlternatingMap (f i)) =\n    g ∘ₗ liftAlternating (R := R) (M := M) (N := N) f := by\n  ext v\n  rw [LinearMap.comp_apply]\n  induction' v using CliffordAlgebra.left_induction with r x y hx hy x m hx generalizing f\n  · rw [liftAlternating_algebraMap, liftAlternating_algebraMap, map_smul,\n      LinearMap.compAlternatingMap_apply]\n  · rw [map_add, map_add, map_add, hx, hy]\n  · rw [liftAlternating_ι_mul, liftAlternating_ι_mul, ← hx]\n    simp_rw [AlternatingMap.curryLeft_compAlternatingMap]\n\n"}
{"name":"ExteriorAlgebra.liftAlternating_ιMulti","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.OfAlternating","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Eq (ExteriorAlgebra.liftAlternating (ExteriorAlgebra.ιMulti R)) LinearMap.id","decl":"@[simp]\ntheorem liftAlternating_ιMulti :\n    liftAlternating (R := R) (M := M) (N := ExteriorAlgebra R M) (ιMulti R) =\n    (LinearMap.id : ExteriorAlgebra R M →ₗ[R] ExteriorAlgebra R M) := by\n  ext v\n  dsimp\n  induction' v using CliffordAlgebra.left_induction with r x y hx hy x m hx\n  · rw [liftAlternating_algebraMap, ιMulti_zero_apply, Algebra.algebraMap_eq_smul_one]\n  · rw [map_add, hx, hy]\n  · simp_rw [liftAlternating_ι_mul, ιMulti_succ_curryLeft, liftAlternating_comp,\n      LinearMap.comp_apply, LinearMap.mulLeft_apply, hx]\n\n"}
{"name":"ExteriorAlgebra.liftAlternatingEquiv_apply","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.OfAlternating","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\na : (i : Nat) → AlternatingMap R M N (Fin i)\n⊢ Eq (ExteriorAlgebra.liftAlternatingEquiv a) (ExteriorAlgebra.liftAlternating a)","decl":"/-- `ExteriorAlgebra.liftAlternating` is an equivalence. -/\n@[simps apply symm_apply]\ndef liftAlternatingEquiv : (∀ i, M [⋀^Fin i]→ₗ[R] N) ≃ₗ[R] ExteriorAlgebra R M →ₗ[R] N where\n  toFun := liftAlternating (R := R)\n  map_add' := map_add _\n  map_smul' := map_smul _\n  invFun F i := F.compAlternatingMap (ιMulti R i)\n  left_inv _ := funext fun _ => liftAlternating_comp_ιMulti _\n  right_inv F :=\n    (liftAlternating_comp _ _).trans <| by rw [liftAlternating_ιMulti, LinearMap.comp_id]\n\n"}
{"name":"ExteriorAlgebra.liftAlternatingEquiv_symm_apply","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.OfAlternating","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nF : LinearMap (RingHom.id R) (ExteriorAlgebra R M) N\ni : Nat\n⊢ Eq (ExteriorAlgebra.liftAlternatingEquiv.symm F i) (F.compAlternatingMap (ExteriorAlgebra.ιMulti R i))","decl":"/-- `ExteriorAlgebra.liftAlternating` is an equivalence. -/\n@[simps apply symm_apply]\ndef liftAlternatingEquiv : (∀ i, M [⋀^Fin i]→ₗ[R] N) ≃ₗ[R] ExteriorAlgebra R M →ₗ[R] N where\n  toFun := liftAlternating (R := R)\n  map_add' := map_add _\n  map_smul' := map_smul _\n  invFun F i := F.compAlternatingMap (ιMulti R i)\n  left_inv _ := funext fun _ => liftAlternating_comp_ιMulti _\n  right_inv F :=\n    (liftAlternating_comp _ _).trans <| by rw [liftAlternating_ιMulti, LinearMap.comp_id]\n\n"}
{"name":"ExteriorAlgebra.lhom_ext_iff","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.OfAlternating","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf g : LinearMap (RingHom.id R) (ExteriorAlgebra R M) N\n⊢ Iff (Eq f g) (∀ (i : Nat), Eq (f.compAlternatingMap (ExteriorAlgebra.ιMulti R i)) (g.compAlternatingMap (ExteriorAlgebra.ιMulti R i)))","decl":"/-- To show that two linear maps from the exterior algebra agree, it suffices to show they agree on\nthe exterior powers.\n\nSee note [partially-applied ext lemmas] -/\n@[ext]\ntheorem lhom_ext ⦃f g : ExteriorAlgebra R M →ₗ[R] N⦄\n    (h : ∀ i, f.compAlternatingMap (ιMulti R i) = g.compAlternatingMap (ιMulti R i)) : f = g :=\n  liftAlternatingEquiv.symm.injective <| funext h\n\n"}
{"name":"ExteriorAlgebra.lhom_ext","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.OfAlternating","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf g : LinearMap (RingHom.id R) (ExteriorAlgebra R M) N\nh : ∀ (i : Nat), Eq (f.compAlternatingMap (ExteriorAlgebra.ιMulti R i)) (g.compAlternatingMap (ExteriorAlgebra.ιMulti R i))\n⊢ Eq f g","decl":"/-- To show that two linear maps from the exterior algebra agree, it suffices to show they agree on\nthe exterior powers.\n\nSee note [partially-applied ext lemmas] -/\n@[ext]\ntheorem lhom_ext ⦃f g : ExteriorAlgebra R M →ₗ[R] N⦄\n    (h : ∀ i, f.compAlternatingMap (ιMulti R i) = g.compAlternatingMap (ιMulti R i)) : f = g :=\n  liftAlternatingEquiv.symm.injective <| funext h\n\n"}
