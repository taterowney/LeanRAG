{"name":"AlgebraicGeometry.instHasTerminalScheme","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"‚ä¢ CategoryTheory.Limits.HasTerminal AlgebraicGeometry.Scheme","decl":"instance : HasTerminal Scheme :=\n  hasTerminal_of_hasTerminal_of_preservesLimit Scheme.Spec\n\n"}
{"name":"AlgebraicGeometry.instIsAffineTerminalScheme","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"‚ä¢ AlgebraicGeometry.IsAffine (CategoryTheory.Limits.terminal AlgebraicGeometry.Scheme)","decl":"instance : IsAffine (‚ä§_ Scheme.{u}) :=\n  isAffine_of_isIso (PreservesTerminal.iso Scheme.Spec).inv\n\n"}
{"name":"AlgebraicGeometry.instHasFiniteLimitsScheme","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"‚ä¢ CategoryTheory.Limits.HasFiniteLimits AlgebraicGeometry.Scheme","decl":"instance : HasFiniteLimits Scheme :=\n  hasFiniteLimits_of_hasTerminal_and_pullbacks\n\n"}
{"name":"AlgebraicGeometry.instIsOverTerminalScheme","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst‚úù¬π : X.Over (CategoryTheory.Limits.terminal AlgebraicGeometry.Scheme)\ninst‚úù : Y.Over (CategoryTheory.Limits.terminal AlgebraicGeometry.Scheme)\nf : Quiver.Hom X Y\n‚ä¢ AlgebraicGeometry.Scheme.Hom.IsOver f (CategoryTheory.Limits.terminal AlgebraicGeometry.Scheme)","decl":"instance {X Y : Scheme.{u}} [X.Over (‚ä§_ Scheme)] [Y.Over (‚ä§_ Scheme)] (f : X ‚ü∂ Y) :\n    @Scheme.Hom.IsOver _ _ f (‚ä§_ Scheme) ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫ := ‚ü®Subsingleton.elim _ _‚ü©\n\n"}
{"name":"AlgebraicGeometry.instSubsingletonOverTerminalScheme","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"X : AlgebraicGeometry.Scheme\n‚ä¢ Subsingleton (X.Over (CategoryTheory.Limits.terminal AlgebraicGeometry.Scheme))","decl":"instance {X : Scheme} : Subsingleton (X.Over (‚ä§_ Scheme)) :=\n  ‚ü®fun ‚ü®a‚ü© ‚ü®b‚ü© ‚Ü¶ by simp [Subsingleton.elim a b]‚ü©\n\n"}
{"name":"AlgebraicGeometry.Scheme.emptyTo_c_app","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"X : AlgebraicGeometry.Scheme\nx‚úù : Opposite (TopologicalSpace.Opens ‚Üë‚ÜëX.toPresheafedSpace)\n‚ä¢ Eq (X.emptyTo.c.app x‚úù) (CommRingCat.punitIsTerminal.from (X.presheaf.obj x‚úù))","decl":"/-- The map from the empty scheme. -/\n@[simps]\ndef Scheme.emptyTo (X : Scheme.{u}) : ‚àÖ ‚ü∂ X :=\n  ‚ü®{  base := ‚ü®fun x => PEmpty.elim x, by fun_prop‚ü©\n      c := { app := fun _ => CommRingCat.punitIsTerminal.from _ } }, fun x => PEmpty.elim x‚ü©\n\n"}
{"name":"AlgebraicGeometry.Scheme.emptyTo_base_apply","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ‚Üë‚ÜëEmptyCollection.emptyCollection.toPresheafedSpace\n‚ä¢ Eq (X.emptyTo.base x) (PEmpty.elim x)","decl":"/-- The map from the empty scheme. -/\n@[simps]\ndef Scheme.emptyTo (X : Scheme.{u}) : ‚àÖ ‚ü∂ X :=\n  ‚ü®{  base := ‚ü®fun x => PEmpty.elim x, by fun_prop‚ü©\n      c := { app := fun _ => CommRingCat.punitIsTerminal.from _ } }, fun x => PEmpty.elim x‚ü©\n\n"}
{"name":"AlgebraicGeometry.Scheme.empty_ext","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"X : AlgebraicGeometry.Scheme\nf g : Quiver.Hom EmptyCollection.emptyCollection X\n‚ä¢ Eq f g","decl":"@[ext]\ntheorem Scheme.empty_ext {X : Scheme.{u}} (f g : ‚àÖ ‚ü∂ X) : f = g :=\n  Scheme.Hom.ext' (Subsingleton.elim (Œ± := ‚àÖ ‚ü∂ _) _ _)\n\n"}
{"name":"AlgebraicGeometry.Scheme.empty_ext_iff","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"X : AlgebraicGeometry.Scheme\nf g : Quiver.Hom EmptyCollection.emptyCollection X\n‚ä¢ Iff (Eq f g) True","decl":"@[ext]\ntheorem Scheme.empty_ext {X : Scheme.{u}} (f g : ‚àÖ ‚ü∂ X) : f = g :=\n  Scheme.Hom.ext' (Subsingleton.elim (Œ± := ‚àÖ ‚ü∂ _) _ _)\n\n"}
{"name":"AlgebraicGeometry.Scheme.eq_emptyTo","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"X : AlgebraicGeometry.Scheme\nf : Quiver.Hom EmptyCollection.emptyCollection X\n‚ä¢ Eq f X.emptyTo","decl":"theorem Scheme.eq_emptyTo {X : Scheme.{u}} (f : ‚àÖ ‚ü∂ X) : f = Scheme.emptyTo X :=\n  Scheme.empty_ext f (Scheme.emptyTo X)\n\n"}
{"name":"AlgebraicGeometry.emptyIsInitial_to","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"‚ä¢ Eq AlgebraicGeometry.emptyIsInitial.to AlgebraicGeometry.Scheme.emptyTo","decl":"@[simp]\ntheorem emptyIsInitial_to : emptyIsInitial.to = Scheme.emptyTo :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.instIsEmptyŒ±TopologicalSpaceCarrierCommRingCatEmptyCollectionScheme","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"‚ä¢ IsEmpty ‚Üë‚ÜëEmptyCollection.emptyCollection.toPresheafedSpace","decl":"instance : IsEmpty (‚àÖ : Scheme.{u}) :=\n  show IsEmpty PEmpty by infer_instance\n\n"}
{"name":"AlgebraicGeometry.spec_punit_isEmpty","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"‚ä¢ IsEmpty ‚Üë‚Üë(AlgebraicGeometry.Spec (CommRingCat.of PUnit.{u + 1})).toPresheafedSpace","decl":"instance spec_punit_isEmpty : IsEmpty (Spec (CommRingCat.of PUnit.{u+1})) :=\n  inferInstanceAs <| IsEmpty (PrimeSpectrum PUnit)\n\n"}
{"name":"AlgebraicGeometry.isOpenImmersion_of_isEmpty","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù : IsEmpty ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ AlgebraicGeometry.IsOpenImmersion f","decl":"instance (priority := 100) isOpenImmersion_of_isEmpty {X Y : Scheme} (f : X ‚ü∂ Y)\n    [IsEmpty X] : IsOpenImmersion f := by\n  apply (config := { allowSynthFailures := true }) IsOpenImmersion.of_stalk_iso\n  ¬∑ exact .of_isEmpty (X := X) _\n  ¬∑ intro (i : X); exact isEmptyElim i\n\n"}
{"name":"AlgebraicGeometry.isIso_of_isEmpty","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù : IsEmpty ‚Üë‚ÜëY.toPresheafedSpace\n‚ä¢ CategoryTheory.IsIso f","decl":"instance (priority := 100) isIso_of_isEmpty {X Y : Scheme} (f : X ‚ü∂ Y) [IsEmpty Y] :\n    IsIso f := by\n  haveI : IsEmpty X := f.base.1.isEmpty\n  have : Epi f.base := by\n    rw [TopCat.epi_iff_surjective]; rintro (x : Y)\n    exact isEmptyElim x\n  apply IsOpenImmersion.to_iso\n\n"}
{"name":"AlgebraicGeometry.isAffine_of_isEmpty","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : IsEmpty ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ AlgebraicGeometry.IsAffine X","decl":"instance (priority := 100) isAffine_of_isEmpty {X : Scheme} [IsEmpty X] : IsAffine X :=\n  isAffine_of_isIso (inv (emptyIsInitial.to X) ‚â´ emptyIsInitial.to (Spec (.of PUnit)))\n\n"}
{"name":"AlgebraicGeometry.instHasInitialScheme","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"‚ä¢ CategoryTheory.Limits.HasInitial AlgebraicGeometry.Scheme","decl":"instance : HasInitial Scheme.{u} :=\n  hasInitial_of_unique ‚àÖ\n\n"}
{"name":"AlgebraicGeometry.initial_isEmpty","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"‚ä¢ IsEmpty ‚Üë‚Üë(CategoryTheory.Limits.initial AlgebraicGeometry.Scheme).toPresheafedSpace","decl":"instance initial_isEmpty : IsEmpty (‚ä•_ Scheme) :=\n  ‚ü®fun x => ((initial.to Scheme.empty :).base x).elim‚ü©\n\n"}
{"name":"AlgebraicGeometry.isAffineOpen_bot","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"X : AlgebraicGeometry.Scheme\n‚ä¢ AlgebraicGeometry.IsAffineOpen Bot.bot","decl":"theorem isAffineOpen_bot (X : Scheme) : IsAffineOpen (‚ä• : X.Opens) :=\n  @isAffine_of_isEmpty _ (inferInstanceAs (IsEmpty (‚àÖ : Set X)))\n\n"}
{"name":"AlgebraicGeometry.instHasStrictInitialObjectsScheme","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"‚ä¢ CategoryTheory.Limits.HasStrictInitialObjects AlgebraicGeometry.Scheme","decl":"instance : HasStrictInitialObjects Scheme :=\n  hasStrictInitialObjects_of_initial_is_strict fun A f => by infer_instance\n\n"}
{"name":"AlgebraicGeometry.disjointGlueData'_f","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\nx‚úù¬≤ x‚úù¬π : Œπ\nx‚úù : Ne x‚úù¬≤ x‚úù¬π\n‚ä¢ Eq ((AlgebraicGeometry.disjointGlueData' f).f x‚úù¬≤ x‚úù¬π x‚úù) (f x‚úù¬≤).emptyTo","decl":"/-- (Implementation Detail) The glue data associated to a disjoint union. -/\n@[simps]\nnoncomputable\ndef disjointGlueData' : GlueData' Scheme where\n  J := Œπ\n  U := f\n  V _ _ _ := ‚àÖ\n  f _ _ _ := Scheme.emptyTo _\n  t _ _ _ := ùüô _\n  t' _ _ _ _ _ _ := Limits.pullback.fst _ _ ‚â´ Scheme.emptyTo _\n  t_fac _ _ _ _ _ _ := emptyIsInitial.strict_hom_ext _ _\n  t_inv _ _ _ := Category.comp_id _\n  cocycle _ _ _ _ _ _ := (emptyIsInitial.ofStrict (pullback.fst _ _)).hom_ext _ _\n  f_mono _ _ := by dsimp only; infer_instance\n\n"}
{"name":"AlgebraicGeometry.disjointGlueData'_U","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\na‚úù : Œπ\n‚ä¢ Eq ((AlgebraicGeometry.disjointGlueData' f).U a‚úù) (f a‚úù)","decl":"/-- (Implementation Detail) The glue data associated to a disjoint union. -/\n@[simps]\nnoncomputable\ndef disjointGlueData' : GlueData' Scheme where\n  J := Œπ\n  U := f\n  V _ _ _ := ‚àÖ\n  f _ _ _ := Scheme.emptyTo _\n  t _ _ _ := ùüô _\n  t' _ _ _ _ _ _ := Limits.pullback.fst _ _ ‚â´ Scheme.emptyTo _\n  t_fac _ _ _ _ _ _ := emptyIsInitial.strict_hom_ext _ _\n  t_inv _ _ _ := Category.comp_id _\n  cocycle _ _ _ _ _ _ := (emptyIsInitial.ofStrict (pullback.fst _ _)).hom_ext _ _\n  f_mono _ _ := by dsimp only; infer_instance\n\n"}
{"name":"AlgebraicGeometry.disjointGlueData'_t","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\nx‚úù¬≤ x‚úù¬π : Œπ\nx‚úù : Ne x‚úù¬≤ x‚úù¬π\n‚ä¢ Eq ((AlgebraicGeometry.disjointGlueData' f).t x‚úù¬≤ x‚úù¬π x‚úù) (CategoryTheory.CategoryStruct.id ((fun x x_1 x => EmptyCollection.emptyCollection) x‚úù¬≤ x‚úù¬π x‚úù))","decl":"/-- (Implementation Detail) The glue data associated to a disjoint union. -/\n@[simps]\nnoncomputable\ndef disjointGlueData' : GlueData' Scheme where\n  J := Œπ\n  U := f\n  V _ _ _ := ‚àÖ\n  f _ _ _ := Scheme.emptyTo _\n  t _ _ _ := ùüô _\n  t' _ _ _ _ _ _ := Limits.pullback.fst _ _ ‚â´ Scheme.emptyTo _\n  t_fac _ _ _ _ _ _ := emptyIsInitial.strict_hom_ext _ _\n  t_inv _ _ _ := Category.comp_id _\n  cocycle _ _ _ _ _ _ := (emptyIsInitial.ofStrict (pullback.fst _ _)).hom_ext _ _\n  f_mono _ _ := by dsimp only; infer_instance\n\n"}
{"name":"AlgebraicGeometry.disjointGlueData'_J","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\n‚ä¢ Eq (AlgebraicGeometry.disjointGlueData' f).J Œπ","decl":"/-- (Implementation Detail) The glue data associated to a disjoint union. -/\n@[simps]\nnoncomputable\ndef disjointGlueData' : GlueData' Scheme where\n  J := Œπ\n  U := f\n  V _ _ _ := ‚àÖ\n  f _ _ _ := Scheme.emptyTo _\n  t _ _ _ := ùüô _\n  t' _ _ _ _ _ _ := Limits.pullback.fst _ _ ‚â´ Scheme.emptyTo _\n  t_fac _ _ _ _ _ _ := emptyIsInitial.strict_hom_ext _ _\n  t_inv _ _ _ := Category.comp_id _\n  cocycle _ _ _ _ _ _ := (emptyIsInitial.ofStrict (pullback.fst _ _)).hom_ext _ _\n  f_mono _ _ := by dsimp only; infer_instance\n\n"}
{"name":"AlgebraicGeometry.disjointGlueData'_t'","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\nx‚úù‚Åµ x‚úù‚Å¥ x‚úù¬≥ : Œπ\nx‚úù¬≤ : Ne x‚úù‚Åµ x‚úù‚Å¥\nx‚úù¬π : Ne x‚úù‚Åµ x‚úù¬≥\nx‚úù : Ne x‚úù‚Å¥ x‚úù¬≥\n‚ä¢ Eq ((AlgebraicGeometry.disjointGlueData' f).t' x‚úù‚Åµ x‚úù‚Å¥ x‚úù¬≥ x‚úù¬≤ x‚úù¬π x‚úù) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst ((fun x x_1 x_2 => (f x).emptyTo) x‚úù‚Åµ x‚úù‚Å¥ x‚úù¬≤) ((fun x x_1 x_2 => (f x).emptyTo) x‚úù‚Åµ x‚úù¬≥ x‚úù¬π)) (CategoryTheory.Limits.pullback ((fun x x_1 x_2 => (f x).emptyTo) x‚úù‚Å¥ x‚úù¬≥ x‚úù) ((fun x x_1 x_2 => (f x).emptyTo) x‚úù‚Å¥ x‚úù‚Åµ ‚ãØ)).emptyTo)","decl":"/-- (Implementation Detail) The glue data associated to a disjoint union. -/\n@[simps]\nnoncomputable\ndef disjointGlueData' : GlueData' Scheme where\n  J := Œπ\n  U := f\n  V _ _ _ := ‚àÖ\n  f _ _ _ := Scheme.emptyTo _\n  t _ _ _ := ùüô _\n  t' _ _ _ _ _ _ := Limits.pullback.fst _ _ ‚â´ Scheme.emptyTo _\n  t_fac _ _ _ _ _ _ := emptyIsInitial.strict_hom_ext _ _\n  t_inv _ _ _ := Category.comp_id _\n  cocycle _ _ _ _ _ _ := (emptyIsInitial.ofStrict (pullback.fst _ _)).hom_ext _ _\n  f_mono _ _ := by dsimp only; infer_instance\n\n"}
{"name":"AlgebraicGeometry.disjointGlueData'_V","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\nx‚úù¬≤ x‚úù¬π : Œπ\nx‚úù : Ne x‚úù¬≤ x‚úù¬π\n‚ä¢ Eq ((AlgebraicGeometry.disjointGlueData' f).V x‚úù¬≤ x‚úù¬π x‚úù) EmptyCollection.emptyCollection","decl":"/-- (Implementation Detail) The glue data associated to a disjoint union. -/\n@[simps]\nnoncomputable\ndef disjointGlueData' : GlueData' Scheme where\n  J := Œπ\n  U := f\n  V _ _ _ := ‚àÖ\n  f _ _ _ := Scheme.emptyTo _\n  t _ _ _ := ùüô _\n  t' _ _ _ _ _ _ := Limits.pullback.fst _ _ ‚â´ Scheme.emptyTo _\n  t_fac _ _ _ _ _ _ := emptyIsInitial.strict_hom_ext _ _\n  t_inv _ _ _ := Category.comp_id _\n  cocycle _ _ _ _ _ _ := (emptyIsInitial.ofStrict (pullback.fst _ _)).hom_ext _ _\n  f_mono _ _ := by dsimp only; infer_instance\n\n"}
{"name":"AlgebraicGeometry.disjointGlueData_t","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\ni j : (AlgebraicGeometry.disjointGlueData' f).J\n‚ä¢ Eq ((AlgebraicGeometry.disjointGlueData f).t i j) (dite (Eq i j) (fun h => CategoryTheory.eqToHom ‚ãØ) fun h => CategoryTheory.eqToHom ‚ãØ)","decl":"/-- (Implementation Detail) The glue data associated to a disjoint union. -/\n@[simps! J V U f t]\nnoncomputable\ndef disjointGlueData : Scheme.GlueData where\n  __ := GlueData.ofGlueData' (disjointGlueData' f)\n  f_open i j := by\n    dsimp only [GlueData.ofGlueData', GlueData'.f', disjointGlueData']\n    split <;> infer_instance\n\n"}
{"name":"AlgebraicGeometry.disjointGlueData_J","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\n‚ä¢ Eq (AlgebraicGeometry.disjointGlueData f).J Œπ","decl":"/-- (Implementation Detail) The glue data associated to a disjoint union. -/\n@[simps! J V U f t]\nnoncomputable\ndef disjointGlueData : Scheme.GlueData where\n  __ := GlueData.ofGlueData' (disjointGlueData' f)\n  f_open i j := by\n    dsimp only [GlueData.ofGlueData', GlueData'.f', disjointGlueData']\n    split <;> infer_instance\n\n"}
{"name":"AlgebraicGeometry.disjointGlueData_f","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\ni j : (AlgebraicGeometry.disjointGlueData' f).J\n‚ä¢ Eq ((AlgebraicGeometry.disjointGlueData f).f i j) ((AlgebraicGeometry.disjointGlueData' f).f' i j)","decl":"/-- (Implementation Detail) The glue data associated to a disjoint union. -/\n@[simps! J V U f t]\nnoncomputable\ndef disjointGlueData : Scheme.GlueData where\n  __ := GlueData.ofGlueData' (disjointGlueData' f)\n  f_open i j := by\n    dsimp only [GlueData.ofGlueData', GlueData'.f', disjointGlueData']\n    split <;> infer_instance\n\n"}
{"name":"AlgebraicGeometry.disjointGlueData_U","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\na‚úù : (AlgebraicGeometry.disjointGlueData' f).J\n‚ä¢ Eq ((AlgebraicGeometry.disjointGlueData f).U a‚úù) (f a‚úù)","decl":"/-- (Implementation Detail) The glue data associated to a disjoint union. -/\n@[simps! J V U f t]\nnoncomputable\ndef disjointGlueData : Scheme.GlueData where\n  __ := GlueData.ofGlueData' (disjointGlueData' f)\n  f_open i j := by\n    dsimp only [GlueData.ofGlueData', GlueData'.f', disjointGlueData']\n    split <;> infer_instance\n\n"}
{"name":"AlgebraicGeometry.disjointGlueData_V","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\nij : Prod (AlgebraicGeometry.disjointGlueData' f).J (AlgebraicGeometry.disjointGlueData' f).J\n‚ä¢ Eq ((AlgebraicGeometry.disjointGlueData f).V ij) (ite (Eq ij.1 ij.2) (f ij.1) EmptyCollection.emptyCollection)","decl":"/-- (Implementation Detail) The glue data associated to a disjoint union. -/\n@[simps! J V U f t]\nnoncomputable\ndef disjointGlueData : Scheme.GlueData where\n  __ := GlueData.ofGlueData' (disjointGlueData' f)\n  f_open i j := by\n    dsimp only [GlueData.ofGlueData', GlueData'.f', disjointGlueData']\n    split <;> infer_instance\n\n"}
{"name":"AlgebraicGeometry.instPreservesColimitsOfShapeSchemeTopCatDiscreteForgetToTop","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete Œπ) AlgebraicGeometry.Scheme.forgetToTop","decl":"instance : PreservesColimitsOfShape (Discrete Œπ) Scheme.forgetToTop.{u} :=\n  inferInstanceAs (PreservesColimitsOfShape (Discrete Œπ) (Scheme.forgetToLocallyRingedSpace ‚ãô\n      LocallyRingedSpace.forgetToSheafedSpace ‚ãô SheafedSpace.forget CommRingCat))\n\n"}
{"name":"AlgebraicGeometry.instHasCoproductsScheme","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"‚ä¢ CategoryTheory.Limits.HasCoproducts AlgebraicGeometry.Scheme","decl":"instance : HasCoproducts.{u} Scheme.{u} :=\n  fun _ ‚Ü¶ ‚ü®fun _ ‚Ü¶ hasColimit_of_created _ Scheme.forgetToLocallyRingedSpace‚ü©\n\n"}
{"name":"AlgebraicGeometry.instHasCoproductsScheme_1","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"‚ä¢ CategoryTheory.Limits.HasCoproducts AlgebraicGeometry.Scheme","decl":"instance : HasCoproducts.{0} Scheme.{u} := has_smallest_coproducts_of_hasCoproducts\n\n"}
{"name":"AlgebraicGeometry.instPreservesColimitsOfShapeSchemeTopCatDiscreteForgetToTop_1","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete Œπ) AlgebraicGeometry.Scheme.forgetToTop","decl":"noncomputable\ninstance {Œπ : Type} : PreservesColimitsOfShape (Discrete Œπ) Scheme.forgetToTop.{u} :=\n  preservesColimitsOfShape_of_equiv\n    (Discrete.equivalence Equiv.ulift : Discrete (ULift.{u} Œπ) ‚âå _) _\n\n"}
{"name":"AlgebraicGeometry.instPreservesColimitsOfShapeSchemeLocallyRingedSpaceDiscreteForgetToLocallyRingedSpace","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete Œπ) AlgebraicGeometry.Scheme.forgetToLocallyRingedSpace","decl":"noncomputable\ninstance {Œπ : Type} :\n    PreservesColimitsOfShape (Discrete Œπ) Scheme.forgetToLocallyRingedSpace.{u} :=\n  preservesColimitsOfShape_of_equiv\n    (Discrete.equivalence Equiv.ulift : Discrete (ULift.{u} Œπ) ‚âå _) _\n\n"}
{"name":"AlgebraicGeometry.Œπ_sigmaIsoGlued_inv_assoc","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\ni : (AlgebraicGeometry.disjointGlueData f).J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (CategoryTheory.Limits.sigmaObj f) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.disjointGlueData f).Œπ i) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.sigmaIsoGlued f).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Œπ f i) h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_sigmaIsoGlued_inv (i) : (disjointGlueData f).Œπ i ‚â´ (sigmaIsoGlued f).inv = Sigma.Œπ f i := by\n  apply Scheme.forgetToLocallyRingedSpace.map_injective\n  dsimp [sigmaIsoGlued]\n  simp only [Category.assoc]\n  refine ((disjointGlueData f).Œπ_gluedIso_hom_assoc Scheme.forgetToLocallyRingedSpace i _).trans ?_\n  refine (colimit.isoColimitCocone_Œπ_inv_assoc\n    ‚ü®_, toLocallyRingedSpaceCoproductCofanIsColimit f‚ü© ‚ü®i‚ü© _).trans ?_\n  exact Œπ_comp_sigmaComparison Scheme.forgetToLocallyRingedSpace _ _\n\n"}
{"name":"AlgebraicGeometry.Œπ_sigmaIsoGlued_inv","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\ni : (AlgebraicGeometry.disjointGlueData f).J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.disjointGlueData f).Œπ i) (AlgebraicGeometry.sigmaIsoGlued f).inv) (CategoryTheory.Limits.Sigma.Œπ f i)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_sigmaIsoGlued_inv (i) : (disjointGlueData f).Œπ i ‚â´ (sigmaIsoGlued f).inv = Sigma.Œπ f i := by\n  apply Scheme.forgetToLocallyRingedSpace.map_injective\n  dsimp [sigmaIsoGlued]\n  simp only [Category.assoc]\n  refine ((disjointGlueData f).Œπ_gluedIso_hom_assoc Scheme.forgetToLocallyRingedSpace i _).trans ?_\n  refine (colimit.isoColimitCocone_Œπ_inv_assoc\n    ‚ü®_, toLocallyRingedSpaceCoproductCofanIsColimit f‚ü© ‚ü®i‚ü© _).trans ?_\n  exact Œπ_comp_sigmaComparison Scheme.forgetToLocallyRingedSpace _ _\n\n"}
{"name":"AlgebraicGeometry.Œπ_sigmaIsoGlued_hom_assoc","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\ni : Œπ\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (AlgebraicGeometry.disjointGlueData f).glued Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Œπ f i) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.sigmaIsoGlued f).hom h)) (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.disjointGlueData f).Œπ i) h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_sigmaIsoGlued_hom (i) :\n    Sigma.Œπ f i ‚â´ (sigmaIsoGlued f).hom = (disjointGlueData f).Œπ i := by\n  rw [‚Üê Œπ_sigmaIsoGlued_inv, Category.assoc, Iso.inv_hom_id, Category.comp_id]\n\n"}
{"name":"AlgebraicGeometry.Œπ_sigmaIsoGlued_hom","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\ni : Œπ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Œπ f i) (AlgebraicGeometry.sigmaIsoGlued f).hom) ((AlgebraicGeometry.disjointGlueData f).Œπ i)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_sigmaIsoGlued_hom (i) :\n    Sigma.Œπ f i ‚â´ (sigmaIsoGlued f).hom = (disjointGlueData f).Œπ i := by\n  rw [‚Üê Œπ_sigmaIsoGlued_inv, Category.assoc, Iso.inv_hom_id, Category.comp_id]\n\n"}
{"name":"AlgebraicGeometry.instIsOpenImmersionŒπScheme","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\ni : Œπ\n‚ä¢ AlgebraicGeometry.IsOpenImmersion (CategoryTheory.Limits.Sigma.Œπ f i)","decl":"instance (i) : IsOpenImmersion (Sigma.Œπ f i) := by\n  rw [‚Üê Œπ_sigmaIsoGlued_inv]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.sigmaŒπ_eq_iff","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\ni j : Œπ\nx : ‚Üë‚Üë(f i).toPresheafedSpace\ny : ‚Üë‚Üë(f j).toPresheafedSpace\n‚ä¢ Iff (Eq ((CategoryTheory.Limits.Sigma.Œπ f i).base x) ((CategoryTheory.Limits.Sigma.Œπ f j).base y)) (Eq ‚ü®i, x‚ü© ‚ü®j, y‚ü©)","decl":"lemma sigmaŒπ_eq_iff (i j : Œπ) (x y) :\n    (Sigma.Œπ f i).base x = (Sigma.Œπ f j).base y ‚Üî\n      (Sigma.mk i x : Œ£ i, f i) = Sigma.mk j y := by\n  constructor\n  ¬∑ intro H\n    rw [‚Üê Œπ_sigmaIsoGlued_inv, ‚Üê Œπ_sigmaIsoGlued_inv] at H\n    erw [(TopCat.homeoOfIso\n      (Scheme.forgetToTop.mapIso (sigmaIsoGlued f))).symm.injective.eq_iff] at H\n    by_cases h : i = j\n    ¬∑ subst h\n      simp only [Sigma.mk.inj_iff, heq_eq_eq, true_and]\n      exact ((disjointGlueData f).Œπ i).isOpenEmbedding.injective H\n    ¬∑ obtain ‚ü®z, _‚ü© := (Scheme.GlueData.Œπ_eq_iff _ _ _ _ _).mp H\n      ¬∑ simp only [disjointGlueData_J, disjointGlueData_V, h, ‚ÜìreduceIte] at z\n        cases z\n  ¬∑ rintro ‚ü®rfl‚ü©\n    rfl\n\n"}
{"name":"AlgebraicGeometry.disjoint_opensRange_sigmaŒπ","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\ni j : Œπ\nh : Ne i j\n‚ä¢ Disjoint (AlgebraicGeometry.Scheme.Hom.opensRange (CategoryTheory.Limits.Sigma.Œπ f i)) (AlgebraicGeometry.Scheme.Hom.opensRange (CategoryTheory.Limits.Sigma.Œπ f j))","decl":"/-- The images of each component in the coproduct is disjoint. -/\nlemma disjoint_opensRange_sigmaŒπ (i j : Œπ) (h : i ‚â† j) :\n    Disjoint (Sigma.Œπ f i).opensRange (Sigma.Œπ f j).opensRange := by\n  intro U hU hU' x hx\n  obtain ‚ü®x, rfl‚ü© := hU hx\n  obtain ‚ü®y, hy‚ü© := hU' hx\n  obtain ‚ü®rfl‚ü© := (sigmaŒπ_eq_iff _ _ _ _ _).mp hy\n  cases h rfl\n\n"}
{"name":"AlgebraicGeometry.exists_sigmaŒπ_eq","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\nx : ‚Üë‚Üë(CategoryTheory.Limits.sigmaObj f).toPresheafedSpace\n‚ä¢ Exists fun i => Exists fun y => Eq ((CategoryTheory.Limits.Sigma.Œπ f i).base y) x","decl":"lemma exists_sigmaŒπ_eq (x : (‚àê f :)) : ‚àÉ i y, (Sigma.Œπ f i).base y = x := by\n  obtain ‚ü®i, y, e‚ü© := (disjointGlueData f).Œπ_jointly_surjective ((sigmaIsoGlued f).hom.base x)\n  refine ‚ü®i, y, (sigmaIsoGlued f).hom.isOpenEmbedding.injective ?_‚ü©\n  rwa [‚Üê Scheme.comp_base_apply, Œπ_sigmaIsoGlued_hom]\n\n"}
{"name":"AlgebraicGeometry.iSup_opensRange_sigmaŒπ","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\n‚ä¢ Eq (iSup fun i => AlgebraicGeometry.Scheme.Hom.opensRange (CategoryTheory.Limits.Sigma.Œπ f i)) Top.top","decl":"lemma iSup_opensRange_sigmaŒπ : ‚®Ü i, (Sigma.Œπ f i).opensRange = ‚ä§ :=\n  eq_top_iff.mpr fun x ‚Ü¶ by simpa using exists_sigmaŒπ_eq f x\n\n"}
{"name":"AlgebraicGeometry.sigmaOpenCover_map","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\nb : Œπ\n‚ä¢ Eq ((AlgebraicGeometry.sigmaOpenCover f).map b) (CategoryTheory.Limits.Sigma.Œπ f b)","decl":"/-- The open cover of the coproduct. -/\n@[simps obj map]\nnoncomputable\ndef sigmaOpenCover : (‚àê f).OpenCover where\n  J := Œπ\n  obj := f\n  map := Sigma.Œπ f\n  f x := (exists_sigmaŒπ_eq f x).choose\n  covers x := (exists_sigmaŒπ_eq f x).choose_spec\n\n"}
{"name":"AlgebraicGeometry.sigmaOpenCover_obj","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\na‚úù : Œπ\n‚ä¢ Eq ((AlgebraicGeometry.sigmaOpenCover f).obj a‚úù) (f a‚úù)","decl":"/-- The open cover of the coproduct. -/\n@[simps obj map]\nnoncomputable\ndef sigmaOpenCover : (‚àê f).OpenCover where\n  J := Œπ\n  obj := f\n  map := Sigma.Œπ f\n  f x := (exists_sigmaŒπ_eq f x).choose\n  covers x := (exists_sigmaŒπ_eq f x).choose_spec\n\n"}
{"name":"AlgebraicGeometry.sigmaMk_mk","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\ni : Œπ\nx : ‚Üë‚Üë(f i).toPresheafedSpace\n‚ä¢ Eq ((AlgebraicGeometry.sigmaMk f) ‚ü®i, x‚ü©) ((CategoryTheory.Limits.Sigma.Œπ f i).base x)","decl":"@[simp]\nlemma sigmaMk_mk (i) (x : f i) :\n    sigmaMk f (.mk i x) = (Sigma.Œπ f i).base x := by\n  show ((TopCat.sigmaCofan (fun x ‚Ü¶ (f x).toTopCat)).inj i ‚â´\n    (colimit.isoColimitCocone ‚ü®_, TopCat.sigmaCofanIsColimit _‚ü©).inv ‚â´ _) x =\n      Scheme.forgetToTop.map (Sigma.Œπ f i) x\n  congr 1\n  refine (colimit.isoColimitCocone_Œπ_inv_assoc ‚ü®_, TopCat.sigmaCofanIsColimit _‚ü© _ _).trans ?_\n  exact Œπ_comp_sigmaComparison Scheme.forgetToTop _ _\n\n"}
{"name":"AlgebraicGeometry.isOpenImmersion_sigmaDesc","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nŒ± : (i : Œπ) ‚Üí Quiver.Hom (f i) X\ninst‚úù : ‚àÄ (i : Œπ), AlgebraicGeometry.IsOpenImmersion (Œ± i)\nhŒ± : Pairwise (Function.onFun Disjoint fun x => Set.range ‚áë(Œ± x).base)\n‚ä¢ AlgebraicGeometry.IsOpenImmersion (CategoryTheory.Limits.Sigma.desc Œ±)","decl":"open scoped Function in\nlemma isOpenImmersion_sigmaDesc\n    {X : Scheme} (Œ± : ‚àÄ i, f i ‚ü∂ X) [‚àÄ i, IsOpenImmersion (Œ± i)]\n    (hŒ± : Pairwise (Disjoint on (Set.range <| Œ± ¬∑ |>.base))) :\n    IsOpenImmersion (Sigma.desc Œ±) := by\n  rw [IsOpenImmersion.iff_stalk_iso]\n  constructor\n  ¬∑ suffices Topology.IsOpenEmbedding ((Sigma.desc Œ±).base ‚àò sigmaMk f) by\n      convert this.comp (sigmaMk f).symm.isOpenEmbedding; ext; simp\n    refine .of_continuous_injective_isOpenMap ?_ ?_ ?_\n    ¬∑ fun_prop\n    ¬∑ rintro ‚ü®ix, x‚ü© ‚ü®iy, y‚ü© e\n      have : (Œ± ix).base x = (Œ± iy).base y := by\n        simpa [‚Üê Scheme.comp_base_apply] using e\n      obtain rfl : ix = iy := by\n        by_contra h\n        exact Set.disjoint_iff_forall_ne.mp (hŒ± h) ‚ü®x, rfl‚ü© ‚ü®y, this.symm‚ü© rfl\n      rw [(Œ± ix).isOpenEmbedding.injective this]\n    ¬∑ rw [isOpenMap_sigma]\n      intro i\n      simpa [‚Üê Scheme.comp_base_apply] using (Œ± i).isOpenEmbedding.isOpenMap\n  ¬∑ intro x\n    have ‚ü®y, hy‚ü© := (sigmaOpenCover f).covers x\n    rw [‚Üê hy]\n    refine IsIso.of_isIso_fac_right (g := ((sigmaOpenCover f).map _).stalkMap y)\n      (h := (X.presheaf.stalkCongr (.of_eq ?_)).hom ‚â´ (Œ± _).stalkMap _) ?_\n    ¬∑ simp [‚Üê Scheme.comp_base_apply]\n    ¬∑ simp [‚Üê Scheme.stalkMap_comp, Scheme.stalkMap_congr_hom _ _ (Sigma.Œπ_desc _ _)]\n\n\n"}
{"name":"AlgebraicGeometry.Œπ_left_coprodIsoSigma_inv","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"X Y : AlgebraicGeometry.Scheme\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Œπ (fun i => CategoryTheory.Limits.WalkingPair.casesOn i.down X Y) { down := CategoryTheory.Limits.WalkingPair.left }) (AlgebraicGeometry.coprodIsoSigma X Y).inv) CategoryTheory.Limits.coprod.inl","decl":"lemma Œπ_left_coprodIsoSigma_inv : Sigma.Œπ _ ‚ü®.left‚ü© ‚â´ (coprodIsoSigma X Y).inv = coprod.inl :=\n  Sigma.Œπ_comp_map' _ _ _\n\n"}
{"name":"AlgebraicGeometry.Œπ_right_coprodIsoSigma_inv","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"X Y : AlgebraicGeometry.Scheme\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Œπ (fun i => CategoryTheory.Limits.WalkingPair.casesOn i.down X Y) { down := CategoryTheory.Limits.WalkingPair.right }) (AlgebraicGeometry.coprodIsoSigma X Y).inv) CategoryTheory.Limits.coprod.inr","decl":"lemma Œπ_right_coprodIsoSigma_inv : Sigma.Œπ _ ‚ü®.right‚ü© ‚â´ (coprodIsoSigma X Y).inv = coprod.inr :=\n  Sigma.Œπ_comp_map' _ _ _\n\n"}
{"name":"AlgebraicGeometry.instIsOpenImmersionInlScheme","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"X Y : AlgebraicGeometry.Scheme\n‚ä¢ AlgebraicGeometry.IsOpenImmersion CategoryTheory.Limits.coprod.inl","decl":"instance : IsOpenImmersion (coprod.inl : X ‚ü∂ X ‚®ø Y) := by\n  rw [‚Üê Œπ_left_coprodIsoSigma_inv]; infer_instance\n\n"}
{"name":"AlgebraicGeometry.instIsOpenImmersionInrScheme","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"X Y : AlgebraicGeometry.Scheme\n‚ä¢ AlgebraicGeometry.IsOpenImmersion CategoryTheory.Limits.coprod.inr","decl":"instance : IsOpenImmersion (coprod.inr : Y ‚ü∂ X ‚®ø Y) := by\n  rw [‚Üê Œπ_right_coprodIsoSigma_inv]; infer_instance\n\n"}
{"name":"AlgebraicGeometry.isCompl_range_inl_inr","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"X Y : AlgebraicGeometry.Scheme\n‚ä¢ IsCompl (Set.range ‚áëCategoryTheory.Limits.coprod.inl.base) (Set.range ‚áëCategoryTheory.Limits.coprod.inr.base)","decl":"lemma isCompl_range_inl_inr :\n    IsCompl (Set.range (coprod.inl : X ‚ü∂ X ‚®ø Y).base)\n      (Set.range (coprod.inr : Y ‚ü∂ X ‚®ø Y).base) :=\n  ((TopCat.binaryCofan_isColimit_iff _).mp\n    ‚ü®mapIsColimitOfPreservesOfIsColimit Scheme.forgetToTop _ _ (coprodIsCoprod X Y)‚ü©).2.2\n\n"}
{"name":"AlgebraicGeometry.isCompl_opensRange_inl_inr","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"X Y : AlgebraicGeometry.Scheme\n‚ä¢ IsCompl (AlgebraicGeometry.Scheme.Hom.opensRange CategoryTheory.Limits.coprod.inl) (AlgebraicGeometry.Scheme.Hom.opensRange CategoryTheory.Limits.coprod.inr)","decl":"lemma isCompl_opensRange_inl_inr :\n    IsCompl (coprod.inl : X ‚ü∂ X ‚®ø Y).opensRange (coprod.inr : Y ‚ü∂ X ‚®ø Y).opensRange := by\n  convert isCompl_range_inl_inr X Y\n  simp only [isCompl_iff, disjoint_iff, codisjoint_iff, ‚Üê TopologicalSpace.Opens.coe_inj]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.coprodMk_inl","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"X Y : AlgebraicGeometry.Scheme\nx : ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ Eq ((AlgebraicGeometry.coprodMk X Y) (Sum.inl x)) (CategoryTheory.Limits.coprod.inl.base x)","decl":"@[simp]\nlemma coprodMk_inl (x : X) :\n    coprodMk X Y (.inl x) = (coprod.inl : X ‚ü∂ X ‚®ø Y).base x := by\n  show ((TopCat.binaryCofan X Y).inl ‚â´\n    (colimit.isoColimitCocone ‚ü®_, TopCat.binaryCofanIsColimit _ _‚ü©).inv ‚â´ _) x =\n      Scheme.forgetToTop.map coprod.inl x\n  congr 1\n  refine (colimit.isoColimitCocone_Œπ_inv_assoc ‚ü®_, TopCat.binaryCofanIsColimit _ _‚ü© _ _).trans ?_\n  exact coprodComparison_inl Scheme.forgetToTop\n\n"}
{"name":"AlgebraicGeometry.coprodMk_inr","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"X Y : AlgebraicGeometry.Scheme\nx : ‚Üë‚ÜëY.toPresheafedSpace\n‚ä¢ Eq ((AlgebraicGeometry.coprodMk X Y) (Sum.inr x)) (CategoryTheory.Limits.coprod.inr.base x)","decl":"@[simp]\nlemma coprodMk_inr (x : Y) :\n    coprodMk X Y (.inr x) = (coprod.inr : Y ‚ü∂ X ‚®ø Y).base x := by\n  show ((TopCat.binaryCofan X Y).inr ‚â´\n    (colimit.isoColimitCocone ‚ü®_, TopCat.binaryCofanIsColimit _ _‚ü©).inv ‚â´ _) x =\n      Scheme.forgetToTop.map coprod.inr x\n  congr 1\n  refine (colimit.isoColimitCocone_Œπ_inv_assoc ‚ü®_, TopCat.binaryCofanIsColimit _ _‚ü© _ _).trans ?_\n  exact coprodComparison_inr Scheme.forgetToTop\n\n"}
{"name":"AlgebraicGeometry.coprodSpec_inl_assoc","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"R S : Type u\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (AlgebraicGeometry.Spec (CommRingCat.of (Prod R S))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.coprodSpec R S) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (RingHom.fst R S))) h)","decl":"@[simp, reassoc]\nlemma coprodSpec_inl : coprod.inl ‚â´ coprodSpec R S =\n    Spec.map (CommRingCat.ofHom <| RingHom.fst R S) :=\n  coprod.inl_desc _ _\n\n"}
{"name":"AlgebraicGeometry.coprodSpec_inl","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"R S : Type u\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl (AlgebraicGeometry.coprodSpec R S)) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (RingHom.fst R S)))","decl":"@[simp, reassoc]\nlemma coprodSpec_inl : coprod.inl ‚â´ coprodSpec R S =\n    Spec.map (CommRingCat.ofHom <| RingHom.fst R S) :=\n  coprod.inl_desc _ _\n\n"}
{"name":"AlgebraicGeometry.coprodSpec_inr_assoc","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"R S : Type u\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (AlgebraicGeometry.Spec (CommRingCat.of (Prod R S))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.coprodSpec R S) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (RingHom.snd R S))) h)","decl":"@[simp, reassoc]\nlemma coprodSpec_inr : coprod.inr ‚â´ coprodSpec R S =\n    Spec.map (CommRingCat.ofHom <| RingHom.snd R S) :=\n  coprod.inr_desc _ _\n\n"}
{"name":"AlgebraicGeometry.coprodSpec_inr","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"R S : Type u\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr (AlgebraicGeometry.coprodSpec R S)) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (RingHom.snd R S)))","decl":"@[simp, reassoc]\nlemma coprodSpec_inr : coprod.inr ‚â´ coprodSpec R S =\n    Spec.map (CommRingCat.ofHom <| RingHom.snd R S) :=\n  coprod.inr_desc _ _\n\n"}
{"name":"AlgebraicGeometry.coprodSpec_coprodMk","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"R S : Type u\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nx : Sum ‚Üë‚Üë(AlgebraicGeometry.Spec (CommRingCat.of R)).toPresheafedSpace ‚Üë‚Üë(AlgebraicGeometry.Spec (CommRingCat.of S)).toPresheafedSpace\n‚ä¢ Eq ((AlgebraicGeometry.coprodSpec R S).base ((AlgebraicGeometry.coprodMk (AlgebraicGeometry.Spec (CommRingCat.of R)) (AlgebraicGeometry.Spec (CommRingCat.of S))) x)) ((PrimeSpectrum.primeSpectrumProd R S).symm x)","decl":"lemma coprodSpec_coprodMk (x) :\n    (coprodSpec R S).base (coprodMk _ _ x) = (PrimeSpectrum.primeSpectrumProd R S).symm x := by\n  apply PrimeSpectrum.ext\n  obtain (x | x) := x <;>\n    simp only [coprodMk_inl, coprodMk_inr, ‚Üê Scheme.comp_base_apply,\n      coprodSpec, coprod.inl_desc, coprod.inr_desc]\n  ¬∑ show Ideal.comap _ _ = x.asIdeal.prod ‚ä§\n    ext; simp [Ideal.prod, CommRingCat.ofHom]\n  ¬∑ show Ideal.comap _ _ = Ideal.prod ‚ä§ x.asIdeal\n    ext; simp [Ideal.prod, CommRingCat.ofHom]\n\n"}
{"name":"AlgebraicGeometry.coprodSpec_apply","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"R S : Type u\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nx : ‚Üë‚Üë(CategoryTheory.Limits.coprod (AlgebraicGeometry.Spec (CommRingCat.of R)) (AlgebraicGeometry.Spec (CommRingCat.of S))).toPresheafedSpace\n‚ä¢ Eq ((AlgebraicGeometry.coprodSpec R S).base x) ((PrimeSpectrum.primeSpectrumProd R S).symm ((AlgebraicGeometry.coprodMk (AlgebraicGeometry.Spec (CommRingCat.of R)) (AlgebraicGeometry.Spec (CommRingCat.of S))).symm x))","decl":"lemma coprodSpec_apply (x) :\n    (coprodSpec R S).base x = (PrimeSpectrum.primeSpectrumProd R S).symm\n      ((coprodMk (Spec (.of R)) (Spec (.of S))).symm x) := by\n  rw [‚Üê coprodSpec_coprodMk, Homeomorph.apply_symm_apply]\n\n"}
{"name":"AlgebraicGeometry.isIso_stalkMap_coprodSpec","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"R S : Type u\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nx : ‚Üë‚Üë(CategoryTheory.Limits.coprod (AlgebraicGeometry.Spec (CommRingCat.of R)) (AlgebraicGeometry.Spec (CommRingCat.of S))).toPresheafedSpace\n‚ä¢ CategoryTheory.IsIso (AlgebraicGeometry.Scheme.Hom.stalkMap (AlgebraicGeometry.coprodSpec R S) x)","decl":"lemma isIso_stalkMap_coprodSpec (x) :\n    IsIso ((coprodSpec R S).stalkMap x) := by\n  obtain ‚ü®x | x, rfl‚ü© := (coprodMk _ _).surjective x\n  ¬∑ have := Scheme.stalkMap_comp coprod.inl (coprodSpec R S) x\n    rw [‚Üê IsIso.comp_inv_eq, Scheme.stalkMap_congr_hom _ (Spec.map _) (coprodSpec_inl R S)] at this\n    rw [coprodMk_inl, ‚Üê this]\n    letI := (RingHom.fst R S).toAlgebra\n    have := IsLocalization.away_fst (R := R) (S := S)\n    have : IsOpenImmersion (Spec.map (CommRingCat.ofHom (RingHom.fst R S))) :=\n      IsOpenImmersion.of_isLocalization (1, 0)\n    infer_instance\n  ¬∑ have := Scheme.stalkMap_comp coprod.inr (coprodSpec R S) x\n    rw [‚Üê IsIso.comp_inv_eq, Scheme.stalkMap_congr_hom _ (Spec.map _) (coprodSpec_inr R S)] at this\n    rw [coprodMk_inr, ‚Üê this]\n    letI := (RingHom.snd R S).toAlgebra\n    have := IsLocalization.away_snd (R := R) (S := S)\n    have : IsOpenImmersion (Spec.map (CommRingCat.ofHom (RingHom.snd R S))) :=\n      IsOpenImmersion.of_isLocalization (0, 1)\n    infer_instance\n\n"}
{"name":"AlgebraicGeometry.instIsIsoSchemeCoprodSpec","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"R S : Type u\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\n‚ä¢ CategoryTheory.IsIso (AlgebraicGeometry.coprodSpec R S)","decl":"instance : IsIso (coprodSpec R S) := by\n  rw [isIso_iff_stalk_iso]\n  refine ‚ü®?_, isIso_stalkMap_coprodSpec R S‚ü©\n  convert_to IsIso (TopCat.isoOfHomeo (X := Spec (.of (R √ó S))) <|\n    PrimeSpectrum.primeSpectrumProdHomeo.trans (coprodMk (Spec (.of R)) (Spec (.of S)))).inv\n  ¬∑ ext x; exact coprodSpec_apply R S x\n  ¬∑ infer_instance\n\n"}
{"name":"AlgebraicGeometry.instIsIsoSchemeCoprodComparisonOppositeCommRingCatSpec","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"R S : Opposite CommRingCat\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison AlgebraicGeometry.Scheme.Spec R S)","decl":"instance (R S : CommRingCat·µí·µñ) : IsIso (coprodComparison Scheme.Spec R S) := by\n  obtain ‚ü®R‚ü© := R; obtain ‚ü®S‚ü© := S\n  have : coprodComparison Scheme.Spec (.op R) (.op S) ‚â´ (Spec.map\n    ((limit.isoLimitCone ‚ü®_, CommRingCat.prodFanIsLimit R S‚ü©).inv ‚â´\n      (opProdIsoCoprod R S).unop.inv)) = coprodSpec R S := by\n    ext1\n    ¬∑ rw [coprodComparison_inl_assoc, coprodSpec, coprod.inl_desc, Scheme.Spec_map,\n        ‚Üê Spec.map_comp, Category.assoc, Iso.unop_inv, opProdIsoCoprod_inv_inl,\n        limit.isoLimitCone_inv_œÄ]\n      rfl\n    ¬∑ rw [coprodComparison_inr_assoc, coprodSpec, coprod.inr_desc, Scheme.Spec_map,\n        ‚Üê Spec.map_comp, Category.assoc, Iso.unop_inv, opProdIsoCoprod_inv_inr,\n        limit.isoLimitCone_inv_œÄ]\n      rfl\n  rw [(IsIso.eq_comp_inv _).mpr this]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.instPreservesColimitsOfShapeOppositeCommRingCatSchemeDiscreteWalkingPairSpec","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"‚ä¢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) AlgebraicGeometry.Scheme.Spec","decl":"noncomputable\ninstance : PreservesColimitsOfShape (Discrete WalkingPair) Scheme.Spec :=\n  ‚ü®fun {_} ‚Ü¶\n    have (X Y : CommRingCat·µí·µñ) := PreservesColimitPair.of_iso_coprod_comparison Scheme.Spec X Y\n    preservesColimit_of_iso_diagram _ (diagramIsoPair _).symm‚ü©\n\n"}
{"name":"AlgebraicGeometry.instPreservesColimitsOfShapeOppositeCommRingCatSchemeDiscretePEmptySpec","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"‚ä¢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) AlgebraicGeometry.Scheme.Spec","decl":"noncomputable\ninstance : PreservesColimitsOfShape (Discrete PEmpty.{1}) Scheme.Spec := by\n  have : IsEmpty (Scheme.Spec.obj (‚ä•_ CommRingCat·µí·µñ)) :=\n    @Function.isEmpty _ _ spec_punit_isEmpty (Scheme.Spec.mapIso\n      (initialIsoIsInitial (initialOpOfTerminal CommRingCat.punitIsTerminal))).hom.base\n  have := preservesInitial_of_iso Scheme.Spec (asIso (initial.to _))\n  exact preservesColimitsOfShape_pempty_of_preservesInitial _\n\n"}
{"name":"AlgebraicGeometry.instPreservesColimitsOfShapeOppositeCommRingCatSchemeDiscreteSpecOfFintype","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"J : Type u_1\ninst‚úù : Fintype J\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete J) AlgebraicGeometry.Scheme.Spec","decl":"noncomputable\ninstance {J} [Fintype J] : PreservesColimitsOfShape (Discrete J) Scheme.Spec :=\n  preservesFiniteCoproductsOfPreservesBinaryAndInitial _ _\n\n"}
{"name":"AlgebraicGeometry.instPreservesColimitsOfShapeOppositeCommRingCatSchemeDiscreteSpecOfFinite","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"J : Type u_1\ninst‚úù : Finite J\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete J) AlgebraicGeometry.Scheme.Spec","decl":"noncomputable\ninstance {J : Type*} [Finite J] : PreservesColimitsOfShape (Discrete J) Scheme.Spec :=\n  letI := (nonempty_fintype J).some\n  preservesColimitsOfShape_of_equiv (Discrete.equivalence (Fintype.equivFin _).symm) _\n\n"}
{"name":"AlgebraicGeometry.Œπ_sigmaSpec","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nR : Œπ ‚Üí CommRingCat\ni : Œπ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Œπ (fun i => AlgebraicGeometry.Spec (R i)) i) (AlgebraicGeometry.sigmaSpec R)) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (Pi.evalRingHom (fun i => ‚Üë(R i)) i)))","decl":"@[reassoc (attr := simp)]\nlemma Œπ_sigmaSpec (R : Œπ ‚Üí CommRingCat) (i) :\n    Sigma.Œπ _ i ‚â´ sigmaSpec R = Spec.map (CommRingCat.ofHom (Pi.evalRingHom _ i)) :=\n  Sigma.Œπ_desc _ _\n\n"}
{"name":"AlgebraicGeometry.Œπ_sigmaSpec_assoc","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nR : Œπ ‚Üí CommRingCat\ni : Œπ\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (AlgebraicGeometry.Spec (CommRingCat.of ((i : Œπ) ‚Üí ‚Üë(R i)))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Œπ (fun i => AlgebraicGeometry.Spec (R i)) i) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.sigmaSpec R) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (Pi.evalRingHom (fun i => ‚Üë(R i)) i))) h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_sigmaSpec (R : Œπ ‚Üí CommRingCat) (i) :\n    Sigma.Œπ _ i ‚â´ sigmaSpec R = Spec.map (CommRingCat.ofHom (Pi.evalRingHom _ i)) :=\n  Sigma.Œπ_desc _ _\n\n"}
{"name":"AlgebraicGeometry.instIsOpenImmersionMapOfHomForallEvalRingHom","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\ni : Œπ\nR : Œπ ‚Üí Type (max u_1 u)\ninst‚úù : (i : Œπ) ‚Üí CommRing (R i)\n‚ä¢ AlgebraicGeometry.IsOpenImmersion (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (Pi.evalRingHom (fun x => R x) i)))","decl":"instance (i) (R : Œπ ‚Üí Type _) [‚àÄ i, CommRing (R i)] :\n    IsOpenImmersion (Spec.map (CommRingCat.ofHom (Pi.evalRingHom (R ¬∑) i))) := by\n  classical\n  letI := (Pi.evalRingHom R i).toAlgebra\n  have : IsLocalization.Away (Function.update (Œ≤ := R) 0 i 1) (R i) := by\n    apply IsLocalization.away_of_isIdempotentElem_of_mul\n    ¬∑ ext j; by_cases h : j = i <;> aesop\n    ¬∑ intro x y\n      constructor\n      ¬∑ intro e; ext j; by_cases h : j = i <;> aesop\n      ¬∑ intro e; simpa using congr_fun e i\n    ¬∑ exact Function.surjective_eval _\n  exact IsOpenImmersion.of_isLocalization (Function.update 0 i 1)\n\n"}
{"name":"AlgebraicGeometry.instIsOpenImmersionSigmaSpec","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nR : Œπ ‚Üí CommRingCat\n‚ä¢ AlgebraicGeometry.IsOpenImmersion (AlgebraicGeometry.sigmaSpec R)","decl":"instance (R : Œπ ‚Üí CommRingCat) : IsOpenImmersion (sigmaSpec R) := by\n  classical\n  apply isOpenImmersion_sigmaDesc\n  intro ix iy h\n  refine Set.disjoint_iff_forall_ne.mpr ?_\n  rintro _ ‚ü®x, rfl‚ü© _ ‚ü®y, rfl‚ü© e\n  have : DFinsupp.single (Œ≤ := (R ¬∑)) iy 1 iy ‚àà y.asIdeal :=\n    (PrimeSpectrum.ext_iff.mp e).le (x := DFinsupp.single iy 1)\n      (show DFinsupp.single (Œ≤ := (R ¬∑)) iy 1 ix ‚àà x.asIdeal by simp [h.symm])\n  simp [‚Üê Ideal.eq_top_iff_one, y.2.ne_top] at this\n\n"}
{"name":"AlgebraicGeometry.instIsIsoSchemeSigmaSpecOfFinite","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\ninst‚úù : Finite Œπ\nR : Œπ ‚Üí CommRingCat\n‚ä¢ CategoryTheory.IsIso (AlgebraicGeometry.sigmaSpec R)","decl":"instance [Finite Œπ] (R : Œπ ‚Üí CommRingCat) : IsIso (sigmaSpec R) := by\n  have : sigmaSpec R =\n      (colimit.isoColimitCocone ‚ü®_,\n        (IsColimit.precomposeHomEquiv Discrete.natIsoFunctor.symm _).symm (isColimitOfPreserves\n          Scheme.Spec (Fan.IsLimit.op (CommRingCat.piFanIsLimit R)))‚ü©).hom := by\n    ext1; simp; rfl\n  rw [this]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.instIsAffineSigmaObjSchemeOfFinite","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí AlgebraicGeometry.Scheme\ninst‚úù¬π : Finite Œπ\ninst‚úù : ‚àÄ (i : Œπ), AlgebraicGeometry.IsAffine (f i)\n‚ä¢ AlgebraicGeometry.IsAffine (CategoryTheory.Limits.sigmaObj f)","decl":"instance [Finite Œπ] [‚àÄ i, IsAffine (f i)] : IsAffine (‚àê f) :=\n  isAffine_of_isIso ((Sigma.mapIso (fun i ‚Ü¶ (f i).isoSpec)).hom ‚â´ sigmaSpec _)\n\n"}
{"name":"AlgebraicGeometry.instIsAffineCoprodScheme","module":"Mathlib.AlgebraicGeometry.Limits","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst‚úù¬π : AlgebraicGeometry.IsAffine X\ninst‚úù : AlgebraicGeometry.IsAffine Y\n‚ä¢ AlgebraicGeometry.IsAffine (CategoryTheory.Limits.coprod X Y)","decl":"instance [IsAffine X] [IsAffine Y] : IsAffine (X ‚®ø Y) :=\n  isAffine_of_isIso ((coprod.mapIso X.isoSpec Y.isoSpec).hom ‚â´ coprodSpec _ _)\n\n"}
