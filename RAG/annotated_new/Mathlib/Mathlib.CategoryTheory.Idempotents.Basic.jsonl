{"name":"CategoryTheory.IsIdempotentComplete.idempotents_split","module":"Mathlib.CategoryTheory.Idempotents.Basic","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nself : CategoryTheory.IsIdempotentComplete C\nX : C\np : Quiver.Hom X X\na‚úù : Eq (CategoryTheory.CategoryStruct.comp p p) p\n‚ä¢ Exists fun Y => Exists fun i => Exists fun e => And (Eq (CategoryTheory.CategoryStruct.comp i e) (CategoryTheory.CategoryStruct.id Y)) (Eq (CategoryTheory.CategoryStruct.comp e i) p)","decl":"/-- A category is idempotent complete iff all idempotent endomorphisms `p`\nsplit as a composition `p = e ‚â´ i` with `i ‚â´ e = ùüô _` -/\nclass IsIdempotentComplete : Prop where\n  /-- A category is idempotent complete iff all idempotent endomorphisms `p`\n    split as a composition `p = e ‚â´ i` with `i ‚â´ e = ùüô _` -/\n  idempotents_split :\n    ‚àÄ (X : C) (p : X ‚ü∂ X), p ‚â´ p = p ‚Üí ‚àÉ (Y : C) (i : Y ‚ü∂ X) (e : X ‚ü∂ Y), i ‚â´ e = ùüô Y ‚àß e ‚â´ i = p\n\n"}
{"name":"CategoryTheory.Idempotents.isIdempotentComplete_iff_hasEqualizer_of_id_and_idempotent","module":"Mathlib.CategoryTheory.Idempotents.Basic","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\n‚ä¢ Iff (CategoryTheory.IsIdempotentComplete C) (‚àÄ (X : C) (p : Quiver.Hom X X), Eq (CategoryTheory.CategoryStruct.comp p p) p ‚Üí CategoryTheory.Limits.HasEqualizer (CategoryTheory.CategoryStruct.id X) p)","decl":"/-- A category is idempotent complete iff for all idempotent endomorphisms,\nthe equalizer of the identity and this idempotent exists. -/\ntheorem isIdempotentComplete_iff_hasEqualizer_of_id_and_idempotent :\n    IsIdempotentComplete C ‚Üî ‚àÄ (X : C) (p : X ‚ü∂ X), p ‚â´ p = p ‚Üí HasEqualizer (ùüô X) p := by\n  constructor\n  ¬∑ intro\n    intro X p hp\n    rcases IsIdempotentComplete.idempotents_split X p hp with ‚ü®Y, i, e, ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©‚ü©\n    exact\n      ‚ü®Nonempty.intro\n          { cone := Fork.ofŒπ i (show i ‚â´ ùüô X = i ‚â´ p by rw [comp_id, ‚Üê h‚ÇÇ, ‚Üê assoc, h‚ÇÅ, id_comp])\n            isLimit := by\n              apply Fork.IsLimit.mk'\n              intro s\n              refine ‚ü®s.Œπ ‚â´ e, ?_‚ü©\n              constructor\n              ¬∑ erw [assoc, h‚ÇÇ, ‚Üê Limits.Fork.condition s, comp_id]\n              ¬∑ intro m hm\n                rw [Fork.Œπ_ofŒπ] at hm\n                rw [‚Üê hm]\n                simp only [‚Üê hm, assoc, h‚ÇÅ]\n                exact (comp_id m).symm }‚ü©\n  ¬∑ intro h\n    refine ‚ü®?_‚ü©\n    intro X p hp\n    haveI : HasEqualizer (ùüô X) p := h X p hp\n    refine ‚ü®equalizer (ùüô X) p, equalizer.Œπ (ùüô X) p,\n      equalizer.lift p (show p ‚â´ ùüô X = p ‚â´ p by rw [hp, comp_id]), ?_, equalizer.lift_Œπ _ _‚ü©\n    ext\n    simp only [assoc, limit.lift_œÄ, Eq.ndrec, id_eq, eq_mpr_eq_cast, Fork.ofŒπ_pt,\n      Fork.ofŒπ_œÄ_app, id_comp]\n    rw [‚Üê equalizer.condition, comp_id]\n\n"}
{"name":"CategoryTheory.Idempotents.idem_of_id_sub_idem","module":"Mathlib.CategoryTheory.Idempotents.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Preadditive C\nX : C\np : Quiver.Hom X X\nhp : Eq (CategoryTheory.CategoryStruct.comp p p) p\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (HSub.hSub (CategoryTheory.CategoryStruct.id X) p) (HSub.hSub (CategoryTheory.CategoryStruct.id X) p)) (HSub.hSub (CategoryTheory.CategoryStruct.id X) p)","decl":"/-- In a preadditive category, when `p : X ‚ü∂ X` is idempotent,\nthen `ùüô X - p` is also idempotent. -/\ntheorem idem_of_id_sub_idem [Preadditive C] {X : C} (p : X ‚ü∂ X) (hp : p ‚â´ p = p) :\n    (ùüô _ - p) ‚â´ (ùüô _ - p) = ùüô _ - p := by\n  simp only [comp_sub, sub_comp, id_comp, comp_id, hp, sub_self, sub_zero]\n\n"}
{"name":"CategoryTheory.Idempotents.isIdempotentComplete_iff_idempotents_have_kernels","module":"Mathlib.CategoryTheory.Idempotents.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Preadditive C\n‚ä¢ Iff (CategoryTheory.IsIdempotentComplete C) (‚àÄ (X : C) (p : Quiver.Hom X X), Eq (CategoryTheory.CategoryStruct.comp p p) p ‚Üí CategoryTheory.Limits.HasKernel p)","decl":"/-- A preadditive category is pseudoabelian iff all idempotent endomorphisms have a kernel. -/\ntheorem isIdempotentComplete_iff_idempotents_have_kernels [Preadditive C] :\n    IsIdempotentComplete C ‚Üî ‚àÄ (X : C) (p : X ‚ü∂ X), p ‚â´ p = p ‚Üí HasKernel p := by\n  rw [isIdempotentComplete_iff_hasEqualizer_of_id_and_idempotent]\n  constructor\n  ¬∑ intro h X p hp\n    haveI : HasEqualizer (ùüô X) (ùüô X - p) := h X (ùüô _ - p) (idem_of_id_sub_idem p hp)\n    convert hasKernel_of_hasEqualizer (ùüô X) (ùüô X - p)\n    rw [sub_sub_cancel]\n  ¬∑ intro h X p hp\n    haveI : HasKernel (ùüô _ - p) := h X (ùüô _ - p) (idem_of_id_sub_idem p hp)\n    apply Preadditive.hasEqualizer_of_hasKernel\n\n"}
{"name":"CategoryTheory.Idempotents.isIdempotentComplete_of_abelian","module":"Mathlib.CategoryTheory.Idempotents.Basic","initialProofState":"D : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_2} D\ninst‚úù : CategoryTheory.Abelian D\n‚ä¢ CategoryTheory.IsIdempotentComplete D","decl":"/-- An abelian category is idempotent complete. -/\ninstance (priority := 100) isIdempotentComplete_of_abelian (D : Type*) [Category D] [Abelian D] :\n    IsIdempotentComplete D := by\n  rw [isIdempotentComplete_iff_idempotents_have_kernels]\n  intros\n  infer_instance\n\n"}
{"name":"CategoryTheory.Idempotents.split_imp_of_iso","module":"Mathlib.CategoryTheory.Idempotents.Basic","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX X' : C\nœÜ : CategoryTheory.Iso X X'\np : Quiver.Hom X X\np' : Quiver.Hom X' X'\nhpp' : Eq (CategoryTheory.CategoryStruct.comp p œÜ.hom) (CategoryTheory.CategoryStruct.comp œÜ.hom p')\nh : Exists fun Y => Exists fun i => Exists fun e => And (Eq (CategoryTheory.CategoryStruct.comp i e) (CategoryTheory.CategoryStruct.id Y)) (Eq (CategoryTheory.CategoryStruct.comp e i) p)\n‚ä¢ Exists fun Y' => Exists fun i' => Exists fun e' => And (Eq (CategoryTheory.CategoryStruct.comp i' e') (CategoryTheory.CategoryStruct.id Y')) (Eq (CategoryTheory.CategoryStruct.comp e' i') p')","decl":"theorem split_imp_of_iso {X X' : C} (œÜ : X ‚âÖ X') (p : X ‚ü∂ X) (p' : X' ‚ü∂ X')\n    (hpp' : p ‚â´ œÜ.hom = œÜ.hom ‚â´ p')\n    (h : ‚àÉ (Y : C) (i : Y ‚ü∂ X) (e : X ‚ü∂ Y), i ‚â´ e = ùüô Y ‚àß e ‚â´ i = p) :\n    ‚àÉ (Y' : C) (i' : Y' ‚ü∂ X') (e' : X' ‚ü∂ Y'), i' ‚â´ e' = ùüô Y' ‚àß e' ‚â´ i' = p' := by\n  rcases h with ‚ü®Y, i, e, ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©‚ü©\n  use Y, i ‚â´ œÜ.hom, œÜ.inv ‚â´ e\n  constructor\n  ¬∑ slice_lhs 2 3 => rw [œÜ.hom_inv_id]\n    rw [id_comp, h‚ÇÅ]\n  ¬∑ slice_lhs 2 3 => rw [h‚ÇÇ]\n    rw [hpp', ‚Üê assoc, œÜ.inv_hom_id, id_comp]\n\n"}
{"name":"CategoryTheory.Idempotents.split_iff_of_iso","module":"Mathlib.CategoryTheory.Idempotents.Basic","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX X' : C\nœÜ : CategoryTheory.Iso X X'\np : Quiver.Hom X X\np' : Quiver.Hom X' X'\nhpp' : Eq (CategoryTheory.CategoryStruct.comp p œÜ.hom) (CategoryTheory.CategoryStruct.comp œÜ.hom p')\n‚ä¢ Iff (Exists fun Y => Exists fun i => Exists fun e => And (Eq (CategoryTheory.CategoryStruct.comp i e) (CategoryTheory.CategoryStruct.id Y)) (Eq (CategoryTheory.CategoryStruct.comp e i) p)) (Exists fun Y' => Exists fun i' => Exists fun e' => And (Eq (CategoryTheory.CategoryStruct.comp i' e') (CategoryTheory.CategoryStruct.id Y')) (Eq (CategoryTheory.CategoryStruct.comp e' i') p'))","decl":"theorem split_iff_of_iso {X X' : C} (œÜ : X ‚âÖ X') (p : X ‚ü∂ X) (p' : X' ‚ü∂ X')\n    (hpp' : p ‚â´ œÜ.hom = œÜ.hom ‚â´ p') :\n    (‚àÉ (Y : C) (i : Y ‚ü∂ X) (e : X ‚ü∂ Y), i ‚â´ e = ùüô Y ‚àß e ‚â´ i = p) ‚Üî\n      ‚àÉ (Y' : C) (i' : Y' ‚ü∂ X') (e' : X' ‚ü∂ Y'), i' ‚â´ e' = ùüô Y' ‚àß e' ‚â´ i' = p' := by\n  constructor\n  ¬∑ exact split_imp_of_iso œÜ p p' hpp'\n  ¬∑ apply split_imp_of_iso œÜ.symm p' p\n    rw [‚Üê comp_id p, ‚Üê œÜ.hom_inv_id]\n    slice_rhs 2 3 => rw [hpp']\n    slice_rhs 1 2 => erw [œÜ.inv_hom_id]\n    simp only [id_comp]\n    rfl\n\n"}
{"name":"CategoryTheory.Idempotents.Equivalence.isIdempotentComplete","module":"Mathlib.CategoryTheory.Idempotents.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst‚úù : CategoryTheory.Category.{u_3, u_2} D\nŒµ : CategoryTheory.Equivalence C D\nh : CategoryTheory.IsIdempotentComplete C\n‚ä¢ CategoryTheory.IsIdempotentComplete D","decl":"theorem Equivalence.isIdempotentComplete {D : Type*} [Category D] (Œµ : C ‚âå D)\n    (h : IsIdempotentComplete C) : IsIdempotentComplete D := by\n  refine ‚ü®?_‚ü©\n  intro X' p hp\n  let œÜ := Œµ.counitIso.symm.app X'\n  erw [split_iff_of_iso œÜ p (œÜ.inv ‚â´ p ‚â´ œÜ.hom)\n      (by\n        slice_rhs 1 2 => rw [œÜ.hom_inv_id]\n        rw [id_comp])]\n  rcases IsIdempotentComplete.idempotents_split (Œµ.inverse.obj X') (Œµ.inverse.map p)\n      (by rw [‚Üê Œµ.inverse.map_comp, hp]) with\n    ‚ü®Y, i, e, ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©‚ü©\n  use Œµ.functor.obj Y, Œµ.functor.map i, Œµ.functor.map e\n  constructor\n  ¬∑ rw [‚Üê Œµ.functor.map_comp, h‚ÇÅ, Œµ.functor.map_id]\n  ¬∑ simp only [‚Üê Œµ.functor.map_comp, h‚ÇÇ, Equivalence.fun_inv_map]\n    rfl\n\n"}
{"name":"CategoryTheory.Idempotents.isIdempotentComplete_iff_of_equivalence","module":"Mathlib.CategoryTheory.Idempotents.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst‚úù : CategoryTheory.Category.{u_3, u_2} D\nŒµ : CategoryTheory.Equivalence C D\n‚ä¢ Iff (CategoryTheory.IsIdempotentComplete C) (CategoryTheory.IsIdempotentComplete D)","decl":"/-- If `C` and `D` are equivalent categories, that `C` is idempotent complete iff `D` is. -/\ntheorem isIdempotentComplete_iff_of_equivalence {D : Type*} [Category D] (Œµ : C ‚âå D) :\n    IsIdempotentComplete C ‚Üî IsIdempotentComplete D := by\n  constructor\n  ¬∑ exact Equivalence.isIdempotentComplete Œµ\n  ¬∑ exact Equivalence.isIdempotentComplete Œµ.symm\n\n"}
{"name":"CategoryTheory.Idempotents.isIdempotentComplete_of_isIdempotentComplete_opposite","module":"Mathlib.CategoryTheory.Idempotents.Basic","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nh : CategoryTheory.IsIdempotentComplete (Opposite C)\n‚ä¢ CategoryTheory.IsIdempotentComplete C","decl":"theorem isIdempotentComplete_of_isIdempotentComplete_opposite (h : IsIdempotentComplete C·µí·µñ) :\n    IsIdempotentComplete C := by\n  refine ‚ü®?_‚ü©\n  intro X p hp\n  rcases IsIdempotentComplete.idempotents_split (op X) p.op (by rw [‚Üê op_comp, hp]) with\n    ‚ü®Y, i, e, ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©‚ü©\n  use Y.unop, e.unop, i.unop\n  constructor\n  ¬∑ simp only [‚Üê unop_comp, h‚ÇÅ]\n    rfl\n  ¬∑ simp only [‚Üê unop_comp, h‚ÇÇ]\n    rfl\n\n"}
{"name":"CategoryTheory.Idempotents.isIdempotentComplete_iff_opposite","module":"Mathlib.CategoryTheory.Idempotents.Basic","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\n‚ä¢ Iff (CategoryTheory.IsIdempotentComplete (Opposite C)) (CategoryTheory.IsIdempotentComplete C)","decl":"theorem isIdempotentComplete_iff_opposite : IsIdempotentComplete C·µí·µñ ‚Üî IsIdempotentComplete C := by\n  constructor\n  ¬∑ exact isIdempotentComplete_of_isIdempotentComplete_opposite\n  ¬∑ intro h\n    apply isIdempotentComplete_of_isIdempotentComplete_opposite\n    rw [isIdempotentComplete_iff_of_equivalence (opOpEquivalence C)]\n    exact h\n\n"}
{"name":"CategoryTheory.Idempotents.instIsIdempotentCompleteOpposite","module":"Mathlib.CategoryTheory.Idempotents.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.IsIdempotentComplete C\n‚ä¢ CategoryTheory.IsIdempotentComplete (Opposite C)","decl":"instance [IsIdempotentComplete C] : IsIdempotentComplete C·µí·µñ := by\n  rwa [isIdempotentComplete_iff_opposite]\n\n"}
