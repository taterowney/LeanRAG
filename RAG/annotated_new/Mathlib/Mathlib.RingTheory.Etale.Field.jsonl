{"name":"Algebra.FormallyEtale.of_isSeparable_aux","module":"Mathlib.RingTheory.Etale.Field","initialProofState":"K L : Type u\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\ninst✝¹ : Algebra.IsSeparable K L\ninst✝ : Algebra.EssFiniteType K L\n⊢ Algebra.FormallyEtale K L","decl":"/--\nThis is a weaker version of `of_isSeparable` that additionally assumes `EssFiniteType K L`.\nUse that instead.\n\nThis is Iversen Corollary II.5.3.\n-/\ntheorem of_isSeparable_aux [Algebra.IsSeparable K L] [EssFiniteType K L] :\n    FormallyEtale K L := by\n  -- We already know that for field extensions\n  -- IsSeparable + EssFiniteType => FormallyUnramified + Finite\n  have := FormallyUnramified.of_isSeparable K L\n  have := FormallyUnramified.finite_of_free (R := K) (S := L)\n  constructor\n  -- We shall show that any `f : L → B/I` can be lifted to `L → B` if `I^2 = ⊥`\n  intros B _ _ I h\n  refine ⟨FormallyUnramified.iff_comp_injective.mp (FormallyUnramified.of_isSeparable K L) I h, ?_⟩\n  intro f\n  -- By separability and finiteness, we may assume `L = K(α)` with `p` the minpoly of `α`.\n  let pb := Field.powerBasisOfFiniteOfSeparable K L\n  -- Let `x : B` such that `f(α) = x` in `B / I`.\n  obtain ⟨x, hx⟩ := Ideal.Quotient.mk_surjective (f pb.gen)\n  have helper : ∀ x, IsScalarTower.toAlgHom K B (B ⧸ I) x = Ideal.Quotient.mk I x := fun _ ↦ rfl\n  -- Then `p(x) = 0 mod I`, and the goal is to find some `ε ∈ I` such that\n  -- `p(x + ε) = p(x) + ε p'(x) = 0`, and we will get our lift into `B`.\n  have hx' : Ideal.Quotient.mk I (aeval x (minpoly K pb.gen)) = 0 := by\n    rw [← helper, ← aeval_algHom_apply, helper, hx, aeval_algHom_apply, minpoly.aeval, map_zero]\n  -- Since `p` is separable, `-p'(x)` is invertible in `B ⧸ I`,\n  obtain ⟨u, hu⟩ : ∃ u, (aeval x) (derivative (minpoly K pb.gen)) * u + 1 ∈ I := by\n    have := (isUnit_iff_ne_zero.mpr ((Algebra.IsSeparable.isSeparable K\n      pb.gen).aeval_derivative_ne_zero (minpoly.aeval K _))).map f\n    rw [← aeval_algHom_apply, ← hx, ← helper, aeval_algHom_apply, helper] at this\n    obtain ⟨u, hu⟩ := Ideal.Quotient.mk_surjective (-this.unit⁻¹ : B ⧸ I)\n    use u\n    rw [← Ideal.Quotient.eq_zero_iff_mem, map_add, map_mul, map_one, hu, mul_neg,\n      IsUnit.mul_val_inv, neg_add_cancel]\n  -- And `ε = p(x)/(-p'(x))` works.\n  use pb.liftEquiv.symm ⟨x + u * aeval x (minpoly K pb.gen), ?_⟩\n  · apply pb.algHom_ext\n    simp [hx, hx']\n  · rw [← eval_map_algebraMap, Polynomial.eval_add_of_sq_eq_zero, derivative_map,\n      ← one_mul (eval x _), eval_map_algebraMap, eval_map_algebraMap, ← mul_assoc, ← add_mul,\n      ← Ideal.mem_bot, ← h, pow_two, add_comm]\n    · exact Ideal.mul_mem_mul hu (Ideal.Quotient.eq_zero_iff_mem.mp hx')\n    rw [← Ideal.mem_bot, ← h]\n    apply Ideal.pow_mem_pow\n    rw [← Ideal.Quotient.eq_zero_iff_mem, map_mul, hx', mul_zero]\n\n"}
{"name":"Algebra.FormallyEtale.of_isSeparable","module":"Mathlib.RingTheory.Etale.Field","initialProofState":"K L : Type u\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\ninst✝ : Algebra.IsSeparable K L\n⊢ Algebra.FormallyEtale K L","decl":"open scoped IntermediateField in\nlemma of_isSeparable [Algebra.IsSeparable K L] : FormallyEtale K L := by\n  constructor\n  intros B _ _ I h\n  -- We shall show that any `f : L → B/I` can be lifted to `L → B` if `I^2 = ⊥`.\n  -- But we already know that there exists a unique lift for every finite subfield of `L`\n  -- by `of_isSeparable_aux`, so we can glue them all together.\n  refine ⟨FormallyUnramified.iff_comp_injective.mp (FormallyUnramified.of_isSeparable K L) I h, ?_⟩\n  intro f\n  have : ∀ k : L, ∃! g : K⟮k⟯ →ₐ[K] B,\n      (Ideal.Quotient.mkₐ K I).comp g = f.comp (IsScalarTower.toAlgHom K _ L) := by\n    intro k\n    have := IsSeparable.of_algHom _ _ (IsScalarTower.toAlgHom K (K⟮k⟯) L)\n    have := IntermediateField.adjoin.finiteDimensional\n      (Algebra.IsSeparable.isSeparable K k).isIntegral\n    have := FormallyEtale.of_isSeparable_aux K (K⟮k⟯)\n    have := FormallyEtale.comp_bijective (R := K) (A := K⟮k⟯) I h\n    exact this.existsUnique _\n  choose g hg₁ hg₂ using this\n  have hg₃ : ∀ x y (h : x ∈ K⟮y⟯), g y ⟨x, h⟩ = g x (IntermediateField.AdjoinSimple.gen K x) := by\n    intro x y h\n    have e : K⟮x⟯ ≤ K⟮y⟯ := by\n      rw [IntermediateField.adjoin_le_iff]\n      rintro _ rfl\n      exact h\n    rw [← hg₂ _ ((g _).comp (IntermediateField.inclusion e))]\n    · rfl\n    apply AlgHom.ext\n    intro ⟨a, _⟩\n    rw [← AlgHom.comp_assoc, hg₁, AlgHom.comp_assoc]\n    simp\n  have H : ∀ x y : L, ∃ α : L, x ∈ K⟮α⟯ ∧ y ∈ K⟮α⟯ := by\n    intro x y\n    have : FiniteDimensional K K⟮x, y⟯ := by\n      apply IntermediateField.finiteDimensional_adjoin\n      intro x _; exact (Algebra.IsSeparable.isSeparable K x).isIntegral\n    have := IsSeparable.of_algHom _ _ (IsScalarTower.toAlgHom K (K⟮x, y⟯) L)\n    obtain ⟨⟨α, hα⟩, e⟩ := Field.exists_primitive_element K K⟮x,y⟯\n    apply_fun (IntermediateField.map (IntermediateField.val _)) at e\n    rw [IntermediateField.adjoin_map, ← AlgHom.fieldRange_eq_map] at e\n    simp only [IntermediateField.coe_val, Set.image_singleton,\n      IntermediateField.fieldRange_val] at e\n    have hx : x ∈ K⟮α⟯ := e ▸ IntermediateField.subset_adjoin K {x, y} (by simp)\n    have hy : y ∈ K⟮α⟯ := e ▸ IntermediateField.subset_adjoin K {x, y} (by simp)\n    exact ⟨α, hx, hy⟩\n  refine ⟨⟨⟨⟨⟨fun x ↦ g x (IntermediateField.AdjoinSimple.gen K x), ?_⟩, ?_⟩, ?_, ?_⟩, ?_⟩, ?_⟩\n  · show g 1 1 = 1; rw [map_one]\n  · intros x y\n    obtain ⟨α, hx, hy⟩ := H x y\n    simp only [← hg₃ _ _ hx, ← hg₃ _ _ hy, ← map_mul, ← hg₃ _ _ (mul_mem hx hy)]\n    rfl\n  · show g 0 0 = 0; rw [map_zero]\n  · intros x y\n    obtain ⟨α, hx, hy⟩ := H x y\n    simp only [← hg₃ _ _ hx, ← hg₃ _ _ hy, ← map_add, ← hg₃ _ _ (add_mem hx hy)]\n    rfl\n  · intro r\n    show g _ (algebraMap K _ r) = _\n    rw [AlgHom.commutes]\n  · ext x\n    simpa using AlgHom.congr_fun (hg₁ x) (IntermediateField.AdjoinSimple.gen K x)\n\n"}
{"name":"Algebra.FormallyEtale.iff_isSeparable","module":"Mathlib.RingTheory.Etale.Field","initialProofState":"K L : Type u\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\ninst✝ : Algebra.EssFiniteType K L\n⊢ Iff (Algebra.FormallyEtale K L) (Algebra.IsSeparable K L)","decl":"theorem iff_isSeparable [EssFiniteType K L] :\n    FormallyEtale K L ↔ Algebra.IsSeparable K L :=\n  ⟨fun _ ↦ FormallyUnramified.isSeparable K L, fun _ ↦ of_isSeparable K L⟩\n\n"}
{"name":"Algebra.FormallyEtale.iff_exists_algEquiv_prod","module":"Mathlib.RingTheory.Etale.Field","initialProofState":"K A : Type u\ninst✝³ : Field K\ninst✝² : CommRing A\ninst✝¹ : Algebra K A\ninst✝ : Algebra.EssFiniteType K A\n⊢ Iff (Algebra.FormallyEtale K A) (Exists fun I => Exists fun x => Exists fun Ai => Exists fun x => Exists fun x_1 => Exists fun x_2 => ∀ (i : I), Algebra.IsSeparable K (Ai i))","decl":"attribute [local instance] IsArtinianRing.fieldOfSubtypeIsMaximal in\n/--\nIf `A` is an essentially of finite type algebra over a field `K`, then `A` is formally étale\nover `K` if and only if `A` is a finite product of separable field extensions.\n-/\ntheorem iff_exists_algEquiv_prod [EssFiniteType K A] :\n    FormallyEtale K A ↔\n      ∃ (I : Type u) (_ : Finite I) (Ai : I → Type u) (_ : ∀ i, Field (Ai i))\n        (_ : ∀ i, Algebra K (Ai i)) (_ : A ≃ₐ[K] Π i, Ai i),\n        ∀ i, Algebra.IsSeparable K (Ai i) := by\n  classical\n  constructor\n  · intro H\n    have := FormallyUnramified.finite_of_free K A\n    have := FormallyUnramified.isReduced_of_field K A\n    have : IsArtinianRing A := isArtinian_of_tower K inferInstance\n    letI : Fintype (MaximalSpectrum A) := (nonempty_fintype _).some\n    let v (i : MaximalSpectrum A) : A := (IsArtinianRing.equivPi A).symm (Pi.single i 1)\n    let e : A ≃ₐ[K] _ := { __ := IsArtinianRing.equivPi A, commutes' := fun r ↦ rfl }\n    have := (FormallyEtale.iff_of_equiv e).mp inferInstance\n    rw [FormallyEtale.pi_iff] at this\n    exact ⟨_, inferInstance, _, _, _, e, fun I ↦ (iff_isSeparable _ _).mp inferInstance⟩\n  · intro ⟨I, _, Ai, _, _, e, _⟩\n    rw [FormallyEtale.iff_of_equiv e, FormallyEtale.pi_iff]\n    have (i) : EssFiniteType K (Ai i) := by\n      letI := ((Pi.evalRingHom Ai i).comp e.toRingHom).toAlgebra\n      have : IsScalarTower K A (Ai i) :=\n        .of_algebraMap_eq fun r ↦ by simp [RingHom.algebraMap_toAlgebra]\n      have : Algebra.FiniteType A (Ai i) := .of_surjective inferInstance (Algebra.ofId _ _)\n        (RingHomSurjective.is_surjective (σ := Pi.evalRingHom Ai i).comp e.surjective)\n      exact EssFiniteType.comp K A (Ai i)\n    exact fun I ↦ (iff_isSeparable _ _).mpr inferInstance\n\n"}
{"name":"Algebra.Etale.iff_exists_algEquiv_prod","module":"Mathlib.RingTheory.Etale.Field","initialProofState":"K A : Type u\ninst✝² : Field K\ninst✝¹ : CommRing A\ninst✝ : Algebra K A\n⊢ Iff (Algebra.Etale K A) (Exists fun I => Exists fun x => Exists fun Ai => Exists fun x => Exists fun x_1 => Exists fun x_2 => ∀ (i : I), And (Module.Finite K (Ai i)) (Algebra.IsSeparable K (Ai i)))","decl":"/--\n`A` is étale over a field `K` if and only if\n`A` is a finite product of finite separable field extensions.\n-/\ntheorem Algebra.Etale.iff_exists_algEquiv_prod :\n    Etale K A ↔\n      ∃ (I : Type u) (_ : Finite I) (Ai : I → Type u) (_ : ∀ i, Field (Ai i))\n        (_ : ∀ i, Algebra K (Ai i)) (_ : A ≃ₐ[K] Π i, Ai i),\n        ∀ i, Module.Finite K (Ai i) ∧ Algebra.IsSeparable K (Ai i) := by\n  constructor\n  · intro H\n    obtain ⟨I, _, Ai, _, _, e, _⟩ := (FormallyEtale.iff_exists_algEquiv_prod K A).mp inferInstance\n    have := FormallyUnramified.finite_of_free K A\n    exact ⟨_, ‹_›, _, _, _, e, fun i ↦ ⟨.of_surjective ((LinearMap.proj i).comp e.toLinearMap)\n      ((Function.surjective_eval i).comp e.surjective), inferInstance⟩⟩\n  · intro ⟨I, _, Ai, _, _, e, H⟩\n    choose h₁ h₂ using H\n    have := Module.Finite.of_surjective e.symm.toLinearMap e.symm.surjective\n    refine ⟨?_, FinitePresentation.of_finiteType.mp inferInstance⟩\n    exact (FormallyEtale.iff_exists_algEquiv_prod K A).mpr ⟨_, inferInstance, _, _, _, e, h₂⟩\n"}
