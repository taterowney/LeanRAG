{"name":"CategoryTheory.LiftableCone.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝³ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nc : CategoryTheory.Limits.Cone (K.comp F)\ninst✝² : SizeOf C\ninst✝¹ : SizeOf D\ninst✝ : SizeOf J\nliftedCone : CategoryTheory.Limits.Cone K\nvalidLift : CategoryTheory.Iso (F.mapCone liftedCone) c\n⊢ Eq (SizeOf.sizeOf { liftedCone := liftedCone, validLift := validLift }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf liftedCone)) (SizeOf.sizeOf validLift))","decl":"/-- Define the lift of a cone: For a cone `c` for `K ⋙ F`, give a cone for `K`\nwhich is a lift of `c`, i.e. the image of it under `F` is (iso) to `c`.\n\nWe will then use this as part of the definition of creation of limits:\nevery limit cone has a lift.\n\nNote this definition is really only useful when `c` is a limit already.\n-/\nstructure LiftableCone (K : J ⥤ C) (F : C ⥤ D) (c : Cone (K ⋙ F)) where\n  /-- a cone in the source category of the functor -/\n  liftedCone : Cone K\n  /-- the isomorphism expressing that `liftedCone` lifts the given cone -/\n  validLift : F.mapCone liftedCone ≅ c\n\n"}
{"name":"CategoryTheory.LiftableCone.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nc : CategoryTheory.Limits.Cone (K.comp F)\nliftedCone✝ : CategoryTheory.Limits.Cone K\nvalidLift✝ : CategoryTheory.Iso (F.mapCone liftedCone✝) c\nliftedCone : CategoryTheory.Limits.Cone K\nvalidLift : CategoryTheory.Iso (F.mapCone liftedCone) c\n⊢ Eq (Eq { liftedCone := liftedCone✝, validLift := validLift✝ } { liftedCone := liftedCone, validLift := validLift }) (And (Eq liftedCone✝ liftedCone) (HEq validLift✝ validLift))","decl":"/-- Define the lift of a cone: For a cone `c` for `K ⋙ F`, give a cone for `K`\nwhich is a lift of `c`, i.e. the image of it under `F` is (iso) to `c`.\n\nWe will then use this as part of the definition of creation of limits:\nevery limit cone has a lift.\n\nNote this definition is really only useful when `c` is a limit already.\n-/\nstructure LiftableCone (K : J ⥤ C) (F : C ⥤ D) (c : Cone (K ⋙ F)) where\n  /-- a cone in the source category of the functor -/\n  liftedCone : Cone K\n  /-- the isomorphism expressing that `liftedCone` lifts the given cone -/\n  validLift : F.mapCone liftedCone ≅ c\n\n"}
{"name":"CategoryTheory.LiftableCone.mk.inj","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nc : CategoryTheory.Limits.Cone (K.comp F)\nliftedCone✝ : CategoryTheory.Limits.Cone K\nvalidLift✝ : CategoryTheory.Iso (F.mapCone liftedCone✝) c\nliftedCone : CategoryTheory.Limits.Cone K\nvalidLift : CategoryTheory.Iso (F.mapCone liftedCone) c\nx✝ : Eq { liftedCone := liftedCone✝, validLift := validLift✝ } { liftedCone := liftedCone, validLift := validLift }\n⊢ And (Eq liftedCone✝ liftedCone) (HEq validLift✝ validLift)","decl":"/-- Define the lift of a cone: For a cone `c` for `K ⋙ F`, give a cone for `K`\nwhich is a lift of `c`, i.e. the image of it under `F` is (iso) to `c`.\n\nWe will then use this as part of the definition of creation of limits:\nevery limit cone has a lift.\n\nNote this definition is really only useful when `c` is a limit already.\n-/\nstructure LiftableCone (K : J ⥤ C) (F : C ⥤ D) (c : Cone (K ⋙ F)) where\n  /-- a cone in the source category of the functor -/\n  liftedCone : Cone K\n  /-- the isomorphism expressing that `liftedCone` lifts the given cone -/\n  validLift : F.mapCone liftedCone ≅ c\n\n"}
{"name":"CategoryTheory.LiftableCocone.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝³ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nc : CategoryTheory.Limits.Cocone (K.comp F)\ninst✝² : SizeOf C\ninst✝¹ : SizeOf D\ninst✝ : SizeOf J\nliftedCocone : CategoryTheory.Limits.Cocone K\nvalidLift : CategoryTheory.Iso (F.mapCocone liftedCocone) c\n⊢ Eq (SizeOf.sizeOf { liftedCocone := liftedCocone, validLift := validLift }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf liftedCocone)) (SizeOf.sizeOf validLift))","decl":"/-- Define the lift of a cocone: For a cocone `c` for `K ⋙ F`, give a cocone for\n`K` which is a lift of `c`, i.e. the image of it under `F` is (iso) to `c`.\n\nWe will then use this as part of the definition of creation of colimits:\nevery limit cocone has a lift.\n\nNote this definition is really only useful when `c` is a colimit already.\n-/\nstructure LiftableCocone (K : J ⥤ C) (F : C ⥤ D) (c : Cocone (K ⋙ F)) where\n  /-- a cocone in the source category of the functor -/\n  liftedCocone : Cocone K\n  /-- the isomorphism expressing that `liftedCocone` lifts the given cocone -/\n  validLift : F.mapCocone liftedCocone ≅ c\n\n"}
{"name":"CategoryTheory.LiftableCocone.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nc : CategoryTheory.Limits.Cocone (K.comp F)\nliftedCocone✝ : CategoryTheory.Limits.Cocone K\nvalidLift✝ : CategoryTheory.Iso (F.mapCocone liftedCocone✝) c\nliftedCocone : CategoryTheory.Limits.Cocone K\nvalidLift : CategoryTheory.Iso (F.mapCocone liftedCocone) c\n⊢ Eq (Eq { liftedCocone := liftedCocone✝, validLift := validLift✝ } { liftedCocone := liftedCocone, validLift := validLift }) (And (Eq liftedCocone✝ liftedCocone) (HEq validLift✝ validLift))","decl":"/-- Define the lift of a cocone: For a cocone `c` for `K ⋙ F`, give a cocone for\n`K` which is a lift of `c`, i.e. the image of it under `F` is (iso) to `c`.\n\nWe will then use this as part of the definition of creation of colimits:\nevery limit cocone has a lift.\n\nNote this definition is really only useful when `c` is a colimit already.\n-/\nstructure LiftableCocone (K : J ⥤ C) (F : C ⥤ D) (c : Cocone (K ⋙ F)) where\n  /-- a cocone in the source category of the functor -/\n  liftedCocone : Cocone K\n  /-- the isomorphism expressing that `liftedCocone` lifts the given cocone -/\n  validLift : F.mapCocone liftedCocone ≅ c\n\n"}
{"name":"CategoryTheory.LiftableCocone.mk.inj","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nc : CategoryTheory.Limits.Cocone (K.comp F)\nliftedCocone✝ : CategoryTheory.Limits.Cocone K\nvalidLift✝ : CategoryTheory.Iso (F.mapCocone liftedCocone✝) c\nliftedCocone : CategoryTheory.Limits.Cocone K\nvalidLift : CategoryTheory.Iso (F.mapCocone liftedCocone) c\nx✝ : Eq { liftedCocone := liftedCocone✝, validLift := validLift✝ } { liftedCocone := liftedCocone, validLift := validLift }\n⊢ And (Eq liftedCocone✝ liftedCocone) (HEq validLift✝ validLift)","decl":"/-- Define the lift of a cocone: For a cocone `c` for `K ⋙ F`, give a cocone for\n`K` which is a lift of `c`, i.e. the image of it under `F` is (iso) to `c`.\n\nWe will then use this as part of the definition of creation of colimits:\nevery limit cocone has a lift.\n\nNote this definition is really only useful when `c` is a colimit already.\n-/\nstructure LiftableCocone (K : J ⥤ C) (F : C ⥤ D) (c : Cocone (K ⋙ F)) where\n  /-- a cocone in the source category of the functor -/\n  liftedCocone : Cocone K\n  /-- the isomorphism expressing that `liftedCocone` lifts the given cocone -/\n  validLift : F.mapCocone liftedCocone ≅ c\n\n"}
{"name":"CategoryTheory.CreatesLimit.toReflectsLimit","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nself : CategoryTheory.CreatesLimit K F\n⊢ CategoryTheory.Limits.ReflectsLimit K F","decl":"/-- Definition 3.3.1 of [Riehl].\nWe say that `F` creates limits of `K` if, given any limit cone `c` for `K ⋙ F`\n(i.e. below) we can lift it to a cone \"above\", and further that `F` reflects\nlimits for `K`.\n\nIf `F` reflects isomorphisms, it suffices to show only that the lifted cone is\na limit - see `createsLimitOfReflectsIso`.\n-/\nclass CreatesLimit (K : J ⥤ C) (F : C ⥤ D) extends ReflectsLimit K F where\n  /-- any limit cone can be lifted to a cone above -/\n  lifts : ∀ c, IsLimit c → LiftableCone K F c\n\n"}
{"name":"CategoryTheory.CreatesColimit.toReflectsColimit","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nself : CategoryTheory.CreatesColimit K F\n⊢ CategoryTheory.Limits.ReflectsColimit K F","decl":"/-- Dual of definition 3.3.1 of [Riehl].\nWe say that `F` creates colimits of `K` if, given any limit cocone `c` for\n`K ⋙ F` (i.e. below) we can lift it to a cocone \"above\", and further that `F`\nreflects limits for `K`.\n\nIf `F` reflects isomorphisms, it suffices to show only that the lifted cocone is\na limit - see `createsColimitOfReflectsIso`.\n-/\nclass CreatesColimit (K : J ⥤ C) (F : C ⥤ D) extends ReflectsColimit K F where\n  /-- any limit cocone can be lifted to a cocone above -/\n  lifts : ∀ c, IsColimit c → LiftableCocone K F c\n\n"}
{"name":"CategoryTheory.liftedLimitMapsToOriginal_inv_map_π","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.CreatesLimit K F\nc : CategoryTheory.Limits.Cone (K.comp F)\nt : CategoryTheory.Limits.IsLimit c\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.liftedLimitMapsToOriginal t).inv.hom (F.map ((CategoryTheory.liftLimit t).π.app j))) (c.π.app j)","decl":"lemma liftedLimitMapsToOriginal_inv_map_π\n    {K : J ⥤ C} {F : C ⥤ D} [CreatesLimit K F] {c : Cone (K ⋙ F)} (t : IsLimit c) (j : J) :\n      (liftedLimitMapsToOriginal t).inv.hom ≫ F.map ((liftLimit t).π.app j) = c.π.app j := by\n  rw [show F.map ((liftLimit t).π.app j) = (liftedLimitMapsToOriginal t).hom.hom ≫ c.π.app j\n    from (by simp), ← Category.assoc, ← Cone.category_comp_hom]\n  simp\n\n"}
{"name":"CategoryTheory.hasLimit_of_created","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.HasLimit (K.comp F)\ninst✝ : CategoryTheory.CreatesLimit K F\n⊢ CategoryTheory.Limits.HasLimit K","decl":"/-- If `F` creates the limit of `K` and `K ⋙ F` has a limit, then `K` has a limit. -/\ntheorem hasLimit_of_created (K : J ⥤ C) (F : C ⥤ D) [HasLimit (K ⋙ F)] [CreatesLimit K F] :\n    HasLimit K :=\n  HasLimit.mk\n    { cone := liftLimit (limit.isLimit (K ⋙ F))\n      isLimit := liftedLimitIsLimit _ }\n\n"}
{"name":"CategoryTheory.hasLimitsOfShape_of_hasLimitsOfShape_createsLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape J D\ninst✝ : CategoryTheory.CreatesLimitsOfShape J F\n⊢ CategoryTheory.Limits.HasLimitsOfShape J C","decl":"/-- If `F` creates limits of shape `J`, and `D` has limits of shape `J`, then\n`C` has limits of shape `J`.\n-/\ntheorem hasLimitsOfShape_of_hasLimitsOfShape_createsLimitsOfShape (F : C ⥤ D) [HasLimitsOfShape J D]\n    [CreatesLimitsOfShape J F] : HasLimitsOfShape J C :=\n  ⟨fun G => hasLimit_of_created G F⟩\n\n"}
{"name":"CategoryTheory.hasLimits_of_hasLimits_createsLimits","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfSize.{w, w', v₂, u₂} D\ninst✝ : CategoryTheory.CreatesLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{w, w', v₁, u₁} C","decl":"/-- If `F` creates limits, and `D` has all limits, then `C` has all limits. -/\ntheorem hasLimits_of_hasLimits_createsLimits (F : C ⥤ D) [HasLimitsOfSize.{w, w'} D]\n    [CreatesLimitsOfSize.{w, w'} F] : HasLimitsOfSize.{w, w'} C :=\n  ⟨fun _ _ => hasLimitsOfShape_of_hasLimitsOfShape_createsLimitsOfShape F⟩\n\n-- Interface to the `CreatesColimit` class.\n"}
{"name":"CategoryTheory.hasColimit_of_created","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.HasColimit (K.comp F)\ninst✝ : CategoryTheory.CreatesColimit K F\n⊢ CategoryTheory.Limits.HasColimit K","decl":"/-- If `F` creates the limit of `K` and `K ⋙ F` has a limit, then `K` has a limit. -/\ntheorem hasColimit_of_created (K : J ⥤ C) (F : C ⥤ D) [HasColimit (K ⋙ F)] [CreatesColimit K F] :\n    HasColimit K :=\n  HasColimit.mk\n    { cocone := liftColimit (colimit.isColimit (K ⋙ F))\n      isColimit := liftedColimitIsColimit _ }\n\n"}
{"name":"CategoryTheory.hasColimitsOfShape_of_hasColimitsOfShape_createsColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape J D\ninst✝ : CategoryTheory.CreatesColimitsOfShape J F\n⊢ CategoryTheory.Limits.HasColimitsOfShape J C","decl":"/-- If `F` creates colimits of shape `J`, and `D` has colimits of shape `J`, then\n`C` has colimits of shape `J`.\n-/\ntheorem hasColimitsOfShape_of_hasColimitsOfShape_createsColimitsOfShape (F : C ⥤ D)\n    [HasColimitsOfShape J D] [CreatesColimitsOfShape J F] : HasColimitsOfShape J C :=\n  ⟨fun G => hasColimit_of_created G F⟩\n\n"}
{"name":"CategoryTheory.hasColimits_of_hasColimits_createsColimits","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfSize.{w, w', v₂, u₂} D\ninst✝ : CategoryTheory.CreatesColimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F\n⊢ CategoryTheory.Limits.HasColimitsOfSize.{w, w', v₁, u₁} C","decl":"/-- If `F` creates colimits, and `D` has all colimits, then `C` has all colimits. -/\ntheorem hasColimits_of_hasColimits_createsColimits (F : C ⥤ D) [HasColimitsOfSize.{w, w'} D]\n    [CreatesColimitsOfSize.{w, w'} F] : HasColimitsOfSize.{w, w'} C :=\n  ⟨fun _ _ => hasColimitsOfShape_of_hasColimitsOfShape_createsColimitsOfShape F⟩\n\n"}
{"name":"CategoryTheory.reflectsLimitsOfShapeOfCreatesLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.CreatesLimitsOfShape J F\n⊢ CategoryTheory.Limits.ReflectsLimitsOfShape J F","decl":"instance (priority := 10) reflectsLimitsOfShapeOfCreatesLimitsOfShape (F : C ⥤ D)\n    [CreatesLimitsOfShape J F] : ReflectsLimitsOfShape J F where\n\n"}
{"name":"CategoryTheory.reflectsLimitsOfCreatesLimits","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.CreatesLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F\n⊢ CategoryTheory.Limits.ReflectsLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F","decl":"instance (priority := 10) reflectsLimitsOfCreatesLimits (F : C ⥤ D)\n    [CreatesLimitsOfSize.{w, w'} F] : ReflectsLimitsOfSize.{w, w'} F where\n\n"}
{"name":"CategoryTheory.reflectsColimitsOfShapeOfCreatesColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.CreatesColimitsOfShape J F\n⊢ CategoryTheory.Limits.ReflectsColimitsOfShape J F","decl":"instance (priority := 10) reflectsColimitsOfShapeOfCreatesColimitsOfShape (F : C ⥤ D)\n    [CreatesColimitsOfShape J F] : ReflectsColimitsOfShape J F where\n\n"}
{"name":"CategoryTheory.reflectsColimitsOfCreatesColimits","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.CreatesColimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F\n⊢ CategoryTheory.Limits.ReflectsColimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F","decl":"instance (priority := 10) reflectsColimitsOfCreatesColimits (F : C ⥤ D)\n    [CreatesColimitsOfSize.{w, w'} F] : ReflectsColimitsOfSize.{w, w'} F where\n\n"}
{"name":"CategoryTheory.LiftsToLimit.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nc : CategoryTheory.Limits.Cone (K.comp F)\nt : CategoryTheory.Limits.IsLimit c\ntoLiftableCone✝ : CategoryTheory.LiftableCone K F c\nmakesLimit✝ : CategoryTheory.Limits.IsLimit toLiftableCone✝.liftedCone\ntoLiftableCone : CategoryTheory.LiftableCone K F c\nmakesLimit : CategoryTheory.Limits.IsLimit toLiftableCone.liftedCone\n⊢ Eq (Eq { toLiftableCone := toLiftableCone✝, makesLimit := makesLimit✝ } { toLiftableCone := toLiftableCone, makesLimit := makesLimit }) (And (Eq toLiftableCone✝ toLiftableCone) (HEq makesLimit✝ makesLimit))","decl":"/-- A helper to show a functor creates limits. In particular, if we can show\nthat for any limit cone `c` for `K ⋙ F`, there is a lift of it which is\na limit and `F` reflects isomorphisms, then `F` creates limits.\nUsually, `F` creating limits says that _any_ lift of `c` is a limit, but\nhere we only need to show that our particular lift of `c` is a limit.\n-/\nstructure LiftsToLimit (K : J ⥤ C) (F : C ⥤ D) (c : Cone (K ⋙ F)) (t : IsLimit c) extends\n  LiftableCone K F c where\n  /-- the lifted cone is limit -/\n  makesLimit : IsLimit liftedCone\n\n"}
{"name":"CategoryTheory.LiftsToLimit.mk.inj","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nc : CategoryTheory.Limits.Cone (K.comp F)\nt : CategoryTheory.Limits.IsLimit c\ntoLiftableCone✝ : CategoryTheory.LiftableCone K F c\nmakesLimit✝ : CategoryTheory.Limits.IsLimit toLiftableCone✝.liftedCone\ntoLiftableCone : CategoryTheory.LiftableCone K F c\nmakesLimit : CategoryTheory.Limits.IsLimit toLiftableCone.liftedCone\nx✝ : Eq { toLiftableCone := toLiftableCone✝, makesLimit := makesLimit✝ } { toLiftableCone := toLiftableCone, makesLimit := makesLimit }\n⊢ And (Eq toLiftableCone✝ toLiftableCone) (HEq makesLimit✝ makesLimit)","decl":"/-- A helper to show a functor creates limits. In particular, if we can show\nthat for any limit cone `c` for `K ⋙ F`, there is a lift of it which is\na limit and `F` reflects isomorphisms, then `F` creates limits.\nUsually, `F` creating limits says that _any_ lift of `c` is a limit, but\nhere we only need to show that our particular lift of `c` is a limit.\n-/\nstructure LiftsToLimit (K : J ⥤ C) (F : C ⥤ D) (c : Cone (K ⋙ F)) (t : IsLimit c) extends\n  LiftableCone K F c where\n  /-- the lifted cone is limit -/\n  makesLimit : IsLimit liftedCone\n\n"}
{"name":"CategoryTheory.LiftsToLimit.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝³ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nc : CategoryTheory.Limits.Cone (K.comp F)\nt : CategoryTheory.Limits.IsLimit c\ninst✝² : SizeOf C\ninst✝¹ : SizeOf D\ninst✝ : SizeOf J\ntoLiftableCone : CategoryTheory.LiftableCone K F c\nmakesLimit : CategoryTheory.Limits.IsLimit toLiftableCone.liftedCone\n⊢ Eq (SizeOf.sizeOf { toLiftableCone := toLiftableCone, makesLimit := makesLimit }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toLiftableCone)) (SizeOf.sizeOf makesLimit))","decl":"/-- A helper to show a functor creates limits. In particular, if we can show\nthat for any limit cone `c` for `K ⋙ F`, there is a lift of it which is\na limit and `F` reflects isomorphisms, then `F` creates limits.\nUsually, `F` creating limits says that _any_ lift of `c` is a limit, but\nhere we only need to show that our particular lift of `c` is a limit.\n-/\nstructure LiftsToLimit (K : J ⥤ C) (F : C ⥤ D) (c : Cone (K ⋙ F)) (t : IsLimit c) extends\n  LiftableCone K F c where\n  /-- the lifted cone is limit -/\n  makesLimit : IsLimit liftedCone\n\n"}
{"name":"CategoryTheory.LiftsToColimit.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nc : CategoryTheory.Limits.Cocone (K.comp F)\nt : CategoryTheory.Limits.IsColimit c\ntoLiftableCocone✝ : CategoryTheory.LiftableCocone K F c\nmakesColimit✝ : CategoryTheory.Limits.IsColimit toLiftableCocone✝.liftedCocone\ntoLiftableCocone : CategoryTheory.LiftableCocone K F c\nmakesColimit : CategoryTheory.Limits.IsColimit toLiftableCocone.liftedCocone\n⊢ Eq (Eq { toLiftableCocone := toLiftableCocone✝, makesColimit := makesColimit✝ } { toLiftableCocone := toLiftableCocone, makesColimit := makesColimit }) (And (Eq toLiftableCocone✝ toLiftableCocone) (HEq makesColimit✝ makesColimit))","decl":"/-- A helper to show a functor creates colimits. In particular, if we can show\nthat for any limit cocone `c` for `K ⋙ F`, there is a lift of it which is\na limit and `F` reflects isomorphisms, then `F` creates colimits.\nUsually, `F` creating colimits says that _any_ lift of `c` is a colimit, but\nhere we only need to show that our particular lift of `c` is a colimit.\n-/\nstructure LiftsToColimit (K : J ⥤ C) (F : C ⥤ D) (c : Cocone (K ⋙ F)) (t : IsColimit c) extends\n  LiftableCocone K F c where\n  /-- the lifted cocone is colimit -/\n  makesColimit : IsColimit liftedCocone\n\n"}
{"name":"CategoryTheory.LiftsToColimit.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝³ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nc : CategoryTheory.Limits.Cocone (K.comp F)\nt : CategoryTheory.Limits.IsColimit c\ninst✝² : SizeOf C\ninst✝¹ : SizeOf D\ninst✝ : SizeOf J\ntoLiftableCocone : CategoryTheory.LiftableCocone K F c\nmakesColimit : CategoryTheory.Limits.IsColimit toLiftableCocone.liftedCocone\n⊢ Eq (SizeOf.sizeOf { toLiftableCocone := toLiftableCocone, makesColimit := makesColimit }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toLiftableCocone)) (SizeOf.sizeOf makesColimit))","decl":"/-- A helper to show a functor creates colimits. In particular, if we can show\nthat for any limit cocone `c` for `K ⋙ F`, there is a lift of it which is\na limit and `F` reflects isomorphisms, then `F` creates colimits.\nUsually, `F` creating colimits says that _any_ lift of `c` is a colimit, but\nhere we only need to show that our particular lift of `c` is a colimit.\n-/\nstructure LiftsToColimit (K : J ⥤ C) (F : C ⥤ D) (c : Cocone (K ⋙ F)) (t : IsColimit c) extends\n  LiftableCocone K F c where\n  /-- the lifted cocone is colimit -/\n  makesColimit : IsColimit liftedCocone\n\n"}
{"name":"CategoryTheory.LiftsToColimit.mk.inj","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nc : CategoryTheory.Limits.Cocone (K.comp F)\nt : CategoryTheory.Limits.IsColimit c\ntoLiftableCocone✝ : CategoryTheory.LiftableCocone K F c\nmakesColimit✝ : CategoryTheory.Limits.IsColimit toLiftableCocone✝.liftedCocone\ntoLiftableCocone : CategoryTheory.LiftableCocone K F c\nmakesColimit : CategoryTheory.Limits.IsColimit toLiftableCocone.liftedCocone\nx✝ : Eq { toLiftableCocone := toLiftableCocone✝, makesColimit := makesColimit✝ } { toLiftableCocone := toLiftableCocone, makesColimit := makesColimit }\n⊢ And (Eq toLiftableCocone✝ toLiftableCocone) (HEq makesColimit✝ makesColimit)","decl":"/-- A helper to show a functor creates colimits. In particular, if we can show\nthat for any limit cocone `c` for `K ⋙ F`, there is a lift of it which is\na limit and `F` reflects isomorphisms, then `F` creates colimits.\nUsually, `F` creating colimits says that _any_ lift of `c` is a colimit, but\nhere we only need to show that our particular lift of `c` is a colimit.\n-/\nstructure LiftsToColimit (K : J ⥤ C) (F : C ⥤ D) (c : Cocone (K ⋙ F)) (t : IsColimit c) extends\n  LiftableCocone K F c where\n  /-- the lifted cocone is colimit -/\n  makesColimit : IsColimit liftedCocone\n\n"}
{"name":"CategoryTheory.preservesLimit_of_createsLimit_and_hasLimit","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.CreatesLimit K F\ninst✝ : CategoryTheory.Limits.HasLimit (K.comp F)\n⊢ CategoryTheory.Limits.PreservesLimit K F","decl":"/-- `F` preserves the limit of `K` if it creates the limit and `K ⋙ F` has the limit. -/\ninstance (priority := 100) preservesLimit_of_createsLimit_and_hasLimit (K : J ⥤ C) (F : C ⥤ D)\n    [CreatesLimit K F] [HasLimit (K ⋙ F)] : PreservesLimit K F where\n  preserves t := ⟨IsLimit.ofIsoLimit (limit.isLimit _)\n    ((liftedLimitMapsToOriginal (limit.isLimit _)).symm ≪≫\n      (Cones.functoriality K F).mapIso ((liftedLimitIsLimit (limit.isLimit _)).uniqueUpToIso t))⟩\n\n"}
{"name":"CategoryTheory.preservesLimitOfCreatesLimitAndHasLimit","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.CreatesLimit K F\ninst✝ : CategoryTheory.Limits.HasLimit (K.comp F)\n⊢ CategoryTheory.Limits.PreservesLimit K F","decl":"@[deprecated \"No deprecation message was provided.\" (since := \"2024-11-19\")]\nlemma preservesLimitOfCreatesLimitAndHasLimit (K : J ⥤ C) (F : C ⥤ D)\n    [CreatesLimit K F] [HasLimit (K ⋙ F)] : PreservesLimit K F :=\n  preservesLimit_of_createsLimit_and_hasLimit _ _\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.preservesLimitOfShape_of_createsLimitsOfShape_and_hasLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.CreatesLimitsOfShape J F\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J D\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J F","decl":"/-- `F` preserves the limit of shape `J` if it creates these limits and `D` has them. -/\ninstance (priority := 100) preservesLimitOfShape_of_createsLimitsOfShape_and_hasLimitsOfShape\n    (F : C ⥤ D) [CreatesLimitsOfShape J F] [HasLimitsOfShape J D] : PreservesLimitsOfShape J F where\n\n"}
{"name":"CategoryTheory.preservesLimitOfShapeOfCreatesLimitsOfShapeAndHasLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.CreatesLimitsOfShape J F\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J D\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J F","decl":"@[deprecated \"No deprecation message was provided.\" (since := \"2024-11-19\")]\nlemma preservesLimitOfShapeOfCreatesLimitsOfShapeAndHasLimitsOfShape\n    (F : C ⥤ D) [CreatesLimitsOfShape J F] [HasLimitsOfShape J D] :\n    PreservesLimitsOfShape J F :=\n  preservesLimitOfShape_of_createsLimitsOfShape_and_hasLimitsOfShape _\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.preservesLimits_of_createsLimits_and_hasLimits","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.CreatesLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F\ninst✝ : CategoryTheory.Limits.HasLimitsOfSize.{w, w', v₂, u₂} D\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F","decl":"/-- `F` preserves limits if it creates limits and `D` has limits. -/\ninstance (priority := 100) preservesLimits_of_createsLimits_and_hasLimits (F : C ⥤ D)\n    [CreatesLimitsOfSize.{w, w'} F] [HasLimitsOfSize.{w, w'} D] :\n    PreservesLimitsOfSize.{w, w'} F where\n\n"}
{"name":"CategoryTheory.preservesLimitsOfCreatesLimitsAndHasLimits","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.CreatesLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F\ninst✝ : CategoryTheory.Limits.HasLimitsOfSize.{w, w', v₂, u₂} D\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F","decl":"@[deprecated \"No deprecation message was provided.\" (since := \"2024-11-19\")]\nlemma preservesLimitsOfCreatesLimitsAndHasLimits (F : C ⥤ D)\n    [CreatesLimitsOfSize.{w, w'} F] [HasLimitsOfSize.{w, w'} D] :\n    PreservesLimitsOfSize.{w, w'} F :=\n  preservesLimits_of_createsLimits_and_hasLimits _\n\n"}
{"name":"CategoryTheory.preservesColimit_of_createsColimit_and_hasColimit","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.CreatesColimit K F\ninst✝ : CategoryTheory.Limits.HasColimit (K.comp F)\n⊢ CategoryTheory.Limits.PreservesColimit K F","decl":"/-- `F` preserves the colimit of `K` if it creates the colimit and `K ⋙ F` has the colimit. -/\ninstance (priority := 100) preservesColimit_of_createsColimit_and_hasColimit (K : J ⥤ C) (F : C ⥤ D)\n    [CreatesColimit K F] [HasColimit (K ⋙ F)] : PreservesColimit K F where\n  preserves t :=\n    ⟨IsColimit.ofIsoColimit (colimit.isColimit _)\n      ((liftedColimitMapsToOriginal (colimit.isColimit _)).symm ≪≫\n        (Cocones.functoriality K F).mapIso\n          ((liftedColimitIsColimit (colimit.isColimit _)).uniqueUpToIso t))⟩\n\n"}
{"name":"CategoryTheory.preservesColimitOfCreatesColimitAndHasColimit","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.CreatesColimit K F\ninst✝ : CategoryTheory.Limits.HasColimit (K.comp F)\n⊢ CategoryTheory.Limits.PreservesColimit K F","decl":"@[deprecated \"No deprecation message was provided.\" (since := \"2024-11-19\")]\nlemma preservesColimitOfCreatesColimitAndHasColimit (K : J ⥤ C) (F : C ⥤ D)\n    [CreatesColimit K F] [HasColimit (K ⋙ F)] : PreservesColimit K F :=\n  preservesColimit_of_createsColimit_and_hasColimit _ _\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.preservesColimitOfShape_of_createsColimitsOfShape_and_hasColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.CreatesColimitsOfShape J F\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J D\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape J F","decl":"/-- `F` preserves the colimit of shape `J` if it creates these colimits and `D` has them. -/\ninstance (priority := 100) preservesColimitOfShape_of_createsColimitsOfShape_and_hasColimitsOfShape\n    (F : C ⥤ D) [CreatesColimitsOfShape J F] [HasColimitsOfShape J D] :\n    PreservesColimitsOfShape J F where\n\n"}
{"name":"CategoryTheory.preservesColimitOfShapeOfCreatesColimitsOfShapeAndHasColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.CreatesColimitsOfShape J F\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J D\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape J F","decl":"@[deprecated \"No deprecation message was provided.\" (since := \"2024-11-19\")]\nlemma preservesColimitOfShapeOfCreatesColimitsOfShapeAndHasColimitsOfShape\n    (F : C ⥤ D) [CreatesColimitsOfShape J F] [HasColimitsOfShape J D] :\n    PreservesColimitsOfShape J F :=\n  preservesColimitOfShape_of_createsColimitsOfShape_and_hasColimitsOfShape _\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.preservesColimits_of_createsColimits_and_hasColimits","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.CreatesColimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F\ninst✝ : CategoryTheory.Limits.HasColimitsOfSize.{w, w', v₂, u₂} D\n⊢ CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F","decl":"/-- `F` preserves limits if it creates limits and `D` has limits. -/\ninstance (priority := 100) preservesColimits_of_createsColimits_and_hasColimits (F : C ⥤ D)\n    [CreatesColimitsOfSize.{w, w'} F] [HasColimitsOfSize.{w, w'} D] :\n    PreservesColimitsOfSize.{w, w'} F where\n\n"}
{"name":"CategoryTheory.preservesColimitsOfCreatesColimitsAndHasColimits","module":"Mathlib.CategoryTheory.Limits.Creates","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.CreatesColimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F\ninst✝ : CategoryTheory.Limits.HasColimitsOfSize.{w, w', v₂, u₂} D\n⊢ CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F","decl":"@[deprecated \"No deprecation message was provided.\" (since := \"2024-11-19\")]\nlemma preservesColimitsOfCreatesColimitsAndHasColimits (F : C ⥤ D)\n    [CreatesColimitsOfSize.{w, w'} F] [HasColimitsOfSize.{w, w'} D] :\n    PreservesColimitsOfSize.{w, w'} F :=\n  preservesColimits_of_createsColimits_and_hasColimits _\n\n"}
