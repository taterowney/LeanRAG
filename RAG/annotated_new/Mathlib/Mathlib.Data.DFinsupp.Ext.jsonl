{"name":"DFinsupp.add_closure_iUnion_range_single","module":"Mathlib.Data.DFinsupp.Ext","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → AddZeroClass (β i)\n⊢ Eq (AddSubmonoid.closure (Set.iUnion fun i => Set.range (DFinsupp.single i))) Top.top","decl":"@[simp]\ntheorem add_closure_iUnion_range_single :\n    AddSubmonoid.closure (⋃ i : ι, Set.range (single i : β i → Π₀ i, β i)) = ⊤ :=\n  top_unique fun x _ => by\n    apply DFinsupp.induction x\n    · exact AddSubmonoid.zero_mem _\n    exact fun a b f _ _ hf =>\n      AddSubmonoid.add_mem _\n        (AddSubmonoid.subset_closure <| Set.mem_iUnion.2 ⟨a, Set.mem_range_self _⟩) hf\n\n"}
{"name":"DFinsupp.addHom_ext","module":"Mathlib.Data.DFinsupp.Ext","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → AddZeroClass (β i)\nγ : Type w\ninst✝ : AddZeroClass γ\nf g : AddMonoidHom (DFinsupp fun i => β i) γ\nH : ∀ (i : ι) (y : β i), Eq (f (DFinsupp.single i y)) (g (DFinsupp.single i y))\n⊢ Eq f g","decl":"/-- If two additive homomorphisms from `Π₀ i, β i` are equal on each `single a b`, then\nthey are equal. -/\ntheorem addHom_ext {γ : Type w} [AddZeroClass γ] ⦃f g : (Π₀ i, β i) →+ γ⦄\n    (H : ∀ (i : ι) (y : β i), f (single i y) = g (single i y)) : f = g := by\n  refine AddMonoidHom.eq_of_eqOn_denseM add_closure_iUnion_range_single fun f hf => ?_\n  simp only [Set.mem_iUnion, Set.mem_range] at hf\n  rcases hf with ⟨x, y, rfl⟩\n  apply H\n\n"}
{"name":"DFinsupp.addHom_ext'","module":"Mathlib.Data.DFinsupp.Ext","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → AddZeroClass (β i)\nγ : Type w\ninst✝ : AddZeroClass γ\nf g : AddMonoidHom (DFinsupp fun i => β i) γ\nH : ∀ (x : ι), Eq (f.comp (DFinsupp.singleAddHom β x)) (g.comp (DFinsupp.singleAddHom β x))\n⊢ Eq f g","decl":"/-- If two additive homomorphisms from `Π₀ i, β i` are equal on each `single a b`, then\nthey are equal.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem addHom_ext' {γ : Type w} [AddZeroClass γ] ⦃f g : (Π₀ i, β i) →+ γ⦄\n    (H : ∀ x, f.comp (singleAddHom β x) = g.comp (singleAddHom β x)) : f = g :=\n  addHom_ext fun x => DFunLike.congr_fun (H x)\n\n"}
{"name":"DFinsupp.addHom_ext'_iff","module":"Mathlib.Data.DFinsupp.Ext","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → AddZeroClass (β i)\nγ : Type w\ninst✝ : AddZeroClass γ\nf g : AddMonoidHom (DFinsupp fun i => β i) γ\n⊢ Iff (Eq f g) (∀ (x : ι), Eq (f.comp (DFinsupp.singleAddHom β x)) (g.comp (DFinsupp.singleAddHom β x)))","decl":"/-- If two additive homomorphisms from `Π₀ i, β i` are equal on each `single a b`, then\nthey are equal.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem addHom_ext' {γ : Type w} [AddZeroClass γ] ⦃f g : (Π₀ i, β i) →+ γ⦄\n    (H : ∀ x, f.comp (singleAddHom β x) = g.comp (singleAddHom β x)) : f = g :=\n  addHom_ext fun x => DFunLike.congr_fun (H x)\n\n"}
