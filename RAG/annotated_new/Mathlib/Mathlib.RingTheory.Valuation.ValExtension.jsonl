{"name":"IsValExtension.val_isEquiv_comap","module":"Mathlib.RingTheory.Valuation.ValExtension","initialProofState":"R : Type u_1\nA : Type u_2\nΓR : Type u_3\nΓA : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : Ring A\ninst✝² : LinearOrderedCommMonoidWithZero ΓR\ninst✝¹ : LinearOrderedCommMonoidWithZero ΓA\ninst✝ : Algebra R A\nvR : Valuation R ΓR\nvA : Valuation A ΓA\nself : IsValExtension vR vA\n⊢ vR.IsEquiv (Valuation.comap (algebraMap R A) vA)","decl":"/--\nThe class `IsValExtension R A` states that the valuation of `A` is an extension of the valuation\non `R`. More precisely, the valuation on `R` is equivalent to the comap of the valuation on `A`.\n-/\nclass IsValExtension : Prop where\n  /-- The valuation on `R` is equivalent to the comap of the valuation on `A` -/\n  val_isEquiv_comap : vR.IsEquiv <| vA.comap (algebraMap R A)\n\n"}
{"name":"IsValExtension.val_map_le_iff","module":"Mathlib.RingTheory.Valuation.ValExtension","initialProofState":"R : Type u_1\nA : Type u_2\nΓR : Type u_3\nΓA : Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : Ring A\ninst✝³ : LinearOrderedCommMonoidWithZero ΓR\ninst✝² : LinearOrderedCommMonoidWithZero ΓA\ninst✝¹ : Algebra R A\nvR : Valuation R ΓR\nvA : Valuation A ΓA\ninst✝ : IsValExtension vR vA\nx y : R\n⊢ Iff (LE.le (vA ((algebraMap R A) x)) (vA ((algebraMap R A) y))) (LE.le (vR x) (vR y))","decl":"theorem val_map_le_iff (x y : R) : vA (algebraMap R A x) ≤ vA (algebraMap R A y) ↔ vR x ≤ vR y :=\n  val_isEquiv_comap.symm x y\n\n"}
{"name":"IsValExtension.val_map_lt_iff","module":"Mathlib.RingTheory.Valuation.ValExtension","initialProofState":"R : Type u_1\nA : Type u_2\nΓR : Type u_3\nΓA : Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : Ring A\ninst✝³ : LinearOrderedCommMonoidWithZero ΓR\ninst✝² : LinearOrderedCommMonoidWithZero ΓA\ninst✝¹ : Algebra R A\nvR : Valuation R ΓR\nvA : Valuation A ΓA\ninst✝ : IsValExtension vR vA\nx y : R\n⊢ Iff (LT.lt (vA ((algebraMap R A) x)) (vA ((algebraMap R A) y))) (LT.lt (vR x) (vR y))","decl":"theorem val_map_lt_iff (x y : R) : vA (algebraMap R A x) < vA (algebraMap R A y) ↔ vR x < vR y := by\n  simpa only [not_le] using ((val_map_le_iff vR vA _ _).not)\n\n"}
{"name":"IsValExtension.val_map_eq_iff","module":"Mathlib.RingTheory.Valuation.ValExtension","initialProofState":"R : Type u_1\nA : Type u_2\nΓR : Type u_3\nΓA : Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : Ring A\ninst✝³ : LinearOrderedCommMonoidWithZero ΓR\ninst✝² : LinearOrderedCommMonoidWithZero ΓA\ninst✝¹ : Algebra R A\nvR : Valuation R ΓR\nvA : Valuation A ΓA\ninst✝ : IsValExtension vR vA\nx y : R\n⊢ Iff (Eq (vA ((algebraMap R A) x)) (vA ((algebraMap R A) y))) (Eq (vR x) (vR y))","decl":"theorem val_map_eq_iff (x y : R) : vA (algebraMap R A x) = vA (algebraMap R A y) ↔ vR x = vR y :=\n  (IsEquiv.val_eq val_isEquiv_comap).symm\n\n"}
{"name":"IsValExtension.val_map_le_one_iff","module":"Mathlib.RingTheory.Valuation.ValExtension","initialProofState":"R : Type u_1\nA : Type u_2\nΓR : Type u_3\nΓA : Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : Ring A\ninst✝³ : LinearOrderedCommMonoidWithZero ΓR\ninst✝² : LinearOrderedCommMonoidWithZero ΓA\ninst✝¹ : Algebra R A\nvR : Valuation R ΓR\nvA : Valuation A ΓA\ninst✝ : IsValExtension vR vA\nx : R\n⊢ Iff (LE.le (vA ((algebraMap R A) x)) 1) (LE.le (vR x) 1)","decl":"theorem val_map_le_one_iff (x : R) : vA (algebraMap R A x) ≤ 1 ↔ vR x ≤ 1 := by\n  simpa only [_root_.map_one] using val_map_le_iff vR vA x 1\n\n"}
{"name":"IsValExtension.val_map_lt_one_iff","module":"Mathlib.RingTheory.Valuation.ValExtension","initialProofState":"R : Type u_1\nA : Type u_2\nΓR : Type u_3\nΓA : Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : Ring A\ninst✝³ : LinearOrderedCommMonoidWithZero ΓR\ninst✝² : LinearOrderedCommMonoidWithZero ΓA\ninst✝¹ : Algebra R A\nvR : Valuation R ΓR\nvA : Valuation A ΓA\ninst✝ : IsValExtension vR vA\nx : R\n⊢ Iff (LT.lt (vA ((algebraMap R A) x)) 1) (LT.lt (vR x) 1)","decl":"theorem val_map_lt_one_iff (x : R) : vA (algebraMap R A x) < 1 ↔ vR x < 1 := by\n  simpa only [_root_.map_one, not_le] using (val_map_le_iff vR vA 1 x).not\n\n"}
{"name":"IsValExtension.val_map_eq_one_iff","module":"Mathlib.RingTheory.Valuation.ValExtension","initialProofState":"R : Type u_1\nA : Type u_2\nΓR : Type u_3\nΓA : Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : Ring A\ninst✝³ : LinearOrderedCommMonoidWithZero ΓR\ninst✝² : LinearOrderedCommMonoidWithZero ΓA\ninst✝¹ : Algebra R A\nvR : Valuation R ΓR\nvA : Valuation A ΓA\ninst✝ : IsValExtension vR vA\nx : R\n⊢ Iff (Eq (vA ((algebraMap R A) x)) 1) (Eq (vR x) 1)","decl":"theorem val_map_eq_one_iff (x : R) : vA (algebraMap R A x) = 1 ↔ vR x = 1 := by\n  simpa only [le_antisymm_iff, _root_.map_one] using\n    and_congr (val_map_le_iff vR vA x 1) (val_map_le_iff vR vA 1 x)\n\n"}
{"name":"IsValExtension.id","module":"Mathlib.RingTheory.Valuation.ValExtension","initialProofState":"R : Type u_1\nΓR : Type u_3\ninst✝¹ : CommRing R\ninst✝ : LinearOrderedCommMonoidWithZero ΓR\nvR : Valuation R ΓR\n⊢ IsValExtension vR vR","decl":"instance id : IsValExtension vR vR where\n  val_isEquiv_comap := by\n    simp only [Algebra.id.map_eq_id, comap_id, IsEquiv.refl]\n\n"}
{"name":"IsValExtension.ofComapInteger","module":"Mathlib.RingTheory.Valuation.ValExtension","initialProofState":"A : Type u_2\ninst✝⁴ : Ring A\nK : Type u_5\ninst✝³ : Field K\ninst✝² : Algebra K A\nΓA : Type u_7\nΓK : Type u_8\ninst✝¹ : LinearOrderedCommGroupWithZero ΓK\ninst✝ : LinearOrderedCommGroupWithZero ΓA\nvK : Valuation K ΓK\nvA : Valuation A ΓA\nh : Eq (Subring.comap (algebraMap K A) vA.integer) vK.integer\n⊢ IsValExtension vK vA","decl":"/--\nWhen `K` is a field, if the preimage of the valuation integers of `A` equals to the valuation\nintegers of `K`, then the valuation on `A` is an extension of the valuation on `K`.\n-/\ntheorem ofComapInteger (h : vA.integer.comap (algebraMap K A) = vK.integer) :\n    IsValExtension vK vA where\n  val_isEquiv_comap := by\n    rw [isEquiv_iff_val_le_one]\n    intro x\n    simp_rw [← Valuation.mem_integer_iff, ← h, Subring.mem_comap, mem_integer_iff, comap_apply]\n\n"}
{"name":"IsValExtension.val_smul","module":"Mathlib.RingTheory.Valuation.ValExtension","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : Ring A\ninst✝³ : Algebra R A\nΓR : Type u_6\nΓA : Type u_7\ninst✝² : LinearOrderedCommGroupWithZero ΓR\ninst✝¹ : LinearOrderedCommGroupWithZero ΓA\nvR : Valuation R ΓR\nvA : Valuation A ΓA\ninst✝ : IsValExtension vR vA\nr : Subtype fun x => Membership.mem vR.integer x\na : Subtype fun x => Membership.mem vA.integer x\n⊢ Eq (↑(HSMul.hSMul r a)) (HSMul.hSMul ↑r ↑a)","decl":"@[simp, norm_cast]\ntheorem val_smul (r : vR.integer) (a : vA.integer) : ↑(r • a : vA.integer) = (r : R) • (a : A) := by\n  rfl\n\n"}
{"name":"IsValExtension.val_algebraMap","module":"Mathlib.RingTheory.Valuation.ValExtension","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : Ring A\ninst✝³ : Algebra R A\nΓR : Type u_6\nΓA : Type u_7\ninst✝² : LinearOrderedCommGroupWithZero ΓR\ninst✝¹ : LinearOrderedCommGroupWithZero ΓA\nvR : Valuation R ΓR\nvA : Valuation A ΓA\ninst✝ : IsValExtension vR vA\nr : Subtype fun x => Membership.mem vR.integer x\n⊢ Eq (↑((algebraMap (Subtype fun x => Membership.mem vR.integer x) (Subtype fun x => Membership.mem vA.integer x)) r)) ((algebraMap R A) ↑r)","decl":"@[simp, norm_cast]\ntheorem val_algebraMap (r : vR.integer) :\n    ((algebraMap vR.integer vA.integer) r : A) = (algebraMap R A) (r : R) := by\n  rfl\n\n"}
{"name":"IsValExtension.instIsScalarTowerInteger","module":"Mathlib.RingTheory.Valuation.ValExtension","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : Ring A\ninst✝³ : Algebra R A\nΓR : Type u_6\nΓA : Type u_7\ninst✝² : LinearOrderedCommGroupWithZero ΓR\ninst✝¹ : LinearOrderedCommGroupWithZero ΓA\nvR : Valuation R ΓR\nvA : Valuation A ΓA\ninst✝ : IsValExtension vR vA\n⊢ IsScalarTower (Subtype fun x => Membership.mem vR.integer x) (Subtype fun x => Membership.mem vA.integer x) A","decl":"instance instIsScalarTowerInteger : IsScalarTower vR.integer vA.integer A where\n  smul_assoc x y z := by\n    simp only [Algebra.smul_def]\n    exact mul_assoc _ _ _\n\n"}
{"name":"IsValExtension.instNoZeroSMulDivisorsInteger","module":"Mathlib.RingTheory.Valuation.ValExtension","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : Ring A\ninst✝⁴ : Algebra R A\nΓR : Type u_6\nΓA : Type u_7\ninst✝³ : LinearOrderedCommGroupWithZero ΓR\ninst✝² : LinearOrderedCommGroupWithZero ΓA\nvR : Valuation R ΓR\nvA : Valuation A ΓA\ninst✝¹ : IsValExtension vR vA\ninst✝ : NoZeroSMulDivisors R A\n⊢ NoZeroSMulDivisors (Subtype fun x => Membership.mem vR.integer x) (Subtype fun x => Membership.mem vA.integer x)","decl":"instance instNoZeroSMulDivisorsInteger [NoZeroSMulDivisors R A] :\n    NoZeroSMulDivisors vR.integer vA.integer := by\n  refine ⟨fun {x y} e ↦ ?_⟩\n  have : (x : R) • (y : A) = 0 := by simpa [Subtype.ext_iff, Algebra.smul_def] using e\n  simpa only [Subtype.ext_iff, smul_eq_zero] using this\n\n"}
{"name":"IsValExtension.algebraMap_injective","module":"Mathlib.RingTheory.Valuation.ValExtension","initialProofState":"A : Type u_2\ninst✝⁶ : Ring A\nK : Type u_5\ninst✝⁵ : Field K\ninst✝⁴ : Algebra K A\nΓA : Type u_7\nΓK : Type u_8\ninst✝³ : LinearOrderedCommGroupWithZero ΓK\ninst✝² : LinearOrderedCommGroupWithZero ΓA\nvK : Valuation K ΓK\nvA : Valuation A ΓA\ninst✝¹ : IsValExtension vK vA\ninst✝ : Nontrivial A\n⊢ Function.Injective ⇑(algebraMap (Subtype fun x => Membership.mem vK.integer x) (Subtype fun x => Membership.mem vA.integer x))","decl":"theorem algebraMap_injective [IsValExtension vK vA] [Nontrivial A] :\n    Function.Injective (algebraMap vK.integer vA.integer) := by\n  intro x y h\n  simp only [Subtype.ext_iff, val_algebraMap] at h\n  ext\n  apply RingHom.injective (algebraMap K A) h\n\n"}
{"name":"IsValExtension.instIsLocalHomValuationInteger","module":"Mathlib.RingTheory.Valuation.ValExtension","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nΓR : Type u_6\ninst✝⁵ : LinearOrderedCommGroupWithZero ΓR\nvR : Valuation R ΓR\nS : Type u_9\nΓS : Type u_10\ninst✝⁴ : CommRing S\ninst✝³ : LinearOrderedCommGroupWithZero ΓS\ninst✝² : Algebra R S\ninst✝¹ : IsLocalHom (algebraMap R S)\nvS : Valuation S ΓS\ninst✝ : IsValExtension vR vS\n⊢ IsLocalHom (algebraMap (Subtype fun x => Membership.mem vR.integer x) (Subtype fun x => Membership.mem vS.integer x))","decl":"@[instance]\ntheorem instIsLocalHomValuationInteger {S ΓS: Type*} [CommRing S]\n    [LinearOrderedCommGroupWithZero ΓS]\n    [Algebra R S] [IsLocalHom (algebraMap R S)] {vS : Valuation S ΓS}\n    [IsValExtension vR vS] : IsLocalHom (algebraMap vR.integer vS.integer) where\n  map_nonunit r hr := by\n    apply (Valuation.integer.integers (v := vR)).isUnit_of_one\n    · exact (isUnit_map_iff (algebraMap R S) _).mp (hr.map (algebraMap _ S))\n    · apply (Valuation.integer.integers (v := vS)).one_of_isUnit at hr\n      exact (val_map_eq_one_iff vR vS _).mp hr\n\n"}
{"name":"IsValExtension.instIsLocalRingHomValuationInteger","module":"Mathlib.RingTheory.Valuation.ValExtension","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nΓR : Type u_6\ninst✝⁵ : LinearOrderedCommGroupWithZero ΓR\nvR : Valuation R ΓR\nS : Type u_9\nΓS : Type u_10\ninst✝⁴ : CommRing S\ninst✝³ : LinearOrderedCommGroupWithZero ΓS\ninst✝² : Algebra R S\ninst✝¹ : IsLocalHom (algebraMap R S)\nvS : Valuation S ΓS\ninst✝ : IsValExtension vR vS\n⊢ IsLocalHom (algebraMap (Subtype fun x => Membership.mem vR.integer x) (Subtype fun x => Membership.mem vS.integer x))","decl":"@[deprecated (since := \"2024-10-10\")]\nalias instIsLocalRingHomValuationInteger := instIsLocalHomValuationInteger\n\n"}
