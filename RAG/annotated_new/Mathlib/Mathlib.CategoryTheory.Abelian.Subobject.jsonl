{"name":"CategoryTheory.Abelian.subobjectIsoSubobjectOp_symm_apply","module":"Mathlib.CategoryTheory.Abelian.Subobject","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nX : C\na : OrderDual (CategoryTheory.Subobject { unop := X })\n⊢ Eq ((RelIso.symm (CategoryTheory.Abelian.subobjectIsoSubobjectOp X)) a) (CategoryTheory.Subobject.lift (fun x f x_1 => CategoryTheory.Subobject.mk (CategoryTheory.Limits.kernel.ι f.unop)) ⋯ a)","decl":"/-- In an abelian category, the subobjects and quotient objects of an object `X` are\n    order-isomorphic via taking kernels and cokernels.\n    Implemented here using subobjects in the opposite category,\n    since mathlib does not have a notion of quotient objects at the time of writing. -/\n@[simps!]\ndef subobjectIsoSubobjectOp [Abelian C] (X : C) : Subobject X ≃o (Subobject (op X))ᵒᵈ := by\n  refine OrderIso.ofHomInv (cokernelOrderHom X) (kernelOrderHom X) ?_ ?_\n  · change (cokernelOrderHom X).comp (kernelOrderHom X) = _\n    refine OrderHom.ext _ _ (funext (Subobject.ind _ ?_))\n    intro A f hf\n    dsimp only [OrderHom.comp_coe, Function.comp_apply, kernelOrderHom_coe, Subobject.lift_mk,\n      cokernelOrderHom_coe, OrderHom.id_coe, id]\n    refine Subobject.mk_eq_mk_of_comm _ _\n        ⟨?_, ?_, Quiver.Hom.unop_inj ?_, Quiver.Hom.unop_inj ?_⟩ ?_\n    · exact (Abelian.epiDesc f.unop _ (cokernel.condition (kernel.ι f.unop))).op\n    · exact (cokernel.desc _ _ (kernel.condition f.unop)).op\n    · rw [← cancel_epi (cokernel.π (kernel.ι f.unop))]\n      simp only [unop_comp, Quiver.Hom.unop_op, unop_id_op, cokernel.π_desc_assoc,\n        comp_epiDesc, Category.comp_id]\n    · simp only [← cancel_epi f.unop, unop_comp, Quiver.Hom.unop_op, unop_id, comp_epiDesc_assoc,\n        cokernel.π_desc, Category.comp_id]\n    · exact Quiver.Hom.unop_inj (by simp only [unop_comp, Quiver.Hom.unop_op, comp_epiDesc])\n  · change (kernelOrderHom X).comp (cokernelOrderHom X) = _\n    refine OrderHom.ext _ _ (funext (Subobject.ind _ ?_))\n    intro A f hf\n    dsimp only [OrderHom.comp_coe, Function.comp_apply, cokernelOrderHom_coe, Subobject.lift_mk,\n      kernelOrderHom_coe, OrderHom.id_coe, id, unop_op, Quiver.Hom.unop_op]\n    refine Subobject.mk_eq_mk_of_comm _ _ ⟨?_, ?_, ?_, ?_⟩ ?_\n    · exact Abelian.monoLift f _ (kernel.condition (cokernel.π f))\n    · exact kernel.lift _ _ (cokernel.condition f)\n    · simp only [← cancel_mono (kernel.ι (cokernel.π f)), Category.assoc, image.fac, monoLift_comp,\n        Category.id_comp]\n    · simp only [← cancel_mono f, Category.assoc, monoLift_comp, image.fac, Category.id_comp]\n    · simp only [monoLift_comp]\n\n"}
{"name":"CategoryTheory.Abelian.subobjectIsoSubobjectOp_apply","module":"Mathlib.CategoryTheory.Abelian.Subobject","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nX : C\na : CategoryTheory.Subobject X\n⊢ Eq ((CategoryTheory.Abelian.subobjectIsoSubobjectOp X) a) (CategoryTheory.Subobject.lift (fun x f x_1 => CategoryTheory.Subobject.mk (CategoryTheory.Limits.cokernel.π f).op) ⋯ a)","decl":"/-- In an abelian category, the subobjects and quotient objects of an object `X` are\n    order-isomorphic via taking kernels and cokernels.\n    Implemented here using subobjects in the opposite category,\n    since mathlib does not have a notion of quotient objects at the time of writing. -/\n@[simps!]\ndef subobjectIsoSubobjectOp [Abelian C] (X : C) : Subobject X ≃o (Subobject (op X))ᵒᵈ := by\n  refine OrderIso.ofHomInv (cokernelOrderHom X) (kernelOrderHom X) ?_ ?_\n  · change (cokernelOrderHom X).comp (kernelOrderHom X) = _\n    refine OrderHom.ext _ _ (funext (Subobject.ind _ ?_))\n    intro A f hf\n    dsimp only [OrderHom.comp_coe, Function.comp_apply, kernelOrderHom_coe, Subobject.lift_mk,\n      cokernelOrderHom_coe, OrderHom.id_coe, id]\n    refine Subobject.mk_eq_mk_of_comm _ _\n        ⟨?_, ?_, Quiver.Hom.unop_inj ?_, Quiver.Hom.unop_inj ?_⟩ ?_\n    · exact (Abelian.epiDesc f.unop _ (cokernel.condition (kernel.ι f.unop))).op\n    · exact (cokernel.desc _ _ (kernel.condition f.unop)).op\n    · rw [← cancel_epi (cokernel.π (kernel.ι f.unop))]\n      simp only [unop_comp, Quiver.Hom.unop_op, unop_id_op, cokernel.π_desc_assoc,\n        comp_epiDesc, Category.comp_id]\n    · simp only [← cancel_epi f.unop, unop_comp, Quiver.Hom.unop_op, unop_id, comp_epiDesc_assoc,\n        cokernel.π_desc, Category.comp_id]\n    · exact Quiver.Hom.unop_inj (by simp only [unop_comp, Quiver.Hom.unop_op, comp_epiDesc])\n  · change (kernelOrderHom X).comp (cokernelOrderHom X) = _\n    refine OrderHom.ext _ _ (funext (Subobject.ind _ ?_))\n    intro A f hf\n    dsimp only [OrderHom.comp_coe, Function.comp_apply, cokernelOrderHom_coe, Subobject.lift_mk,\n      kernelOrderHom_coe, OrderHom.id_coe, id, unop_op, Quiver.Hom.unop_op]\n    refine Subobject.mk_eq_mk_of_comm _ _ ⟨?_, ?_, ?_, ?_⟩ ?_\n    · exact Abelian.monoLift f _ (kernel.condition (cokernel.π f))\n    · exact kernel.lift _ _ (cokernel.condition f)\n    · simp only [← cancel_mono (kernel.ι (cokernel.π f)), Category.assoc, image.fac, monoLift_comp,\n        Category.id_comp]\n    · simp only [← cancel_mono f, Category.assoc, monoLift_comp, image.fac, Category.id_comp]\n    · simp only [monoLift_comp]\n\n"}
{"name":"CategoryTheory.Abelian.wellPowered_opposite","module":"Mathlib.CategoryTheory.Abelian.Subobject","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.LocallySmall.{w, v, u} C\ninst✝ : CategoryTheory.WellPowered.{w, v, u} C\n⊢ CategoryTheory.WellPowered.{w, v, u} (Opposite C)","decl":"/-- A well-powered abelian category is also well-copowered. -/\ninstance wellPowered_opposite [Abelian C] [LocallySmall.{w} C] [WellPowered.{w} C] :\n    WellPowered.{w} Cᵒᵖ where\n  subobject_small X :=\n    (small_congr (subobjectIsoSubobjectOp (unop X)).toEquiv).1 inferInstance\n\n"}
