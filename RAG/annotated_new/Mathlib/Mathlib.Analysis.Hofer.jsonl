{"name":"hofer","module":"Mathlib.Analysis.Hofer","initialProofState":"X : Type u_1\ninstโยน : MetricSpace X\ninstโ : CompleteSpace X\nx : X\nฮต : Real\nฮต_pos : LT.lt 0 ฮต\nฯ : X โ Real\ncont : Continuous ฯ\nnonneg : โ (y : X), LE.le 0 (ฯ y)\nโข Exists fun ฮต' => And (GT.gt ฮต' 0) (Exists fun x' => And (LE.le ฮต' ฮต) (And (LE.le (Dist.dist x' x) (HMul.hMul 2 ฮต)) (And (LE.le (HMul.hMul ฮต (ฯ x)) (HMul.hMul ฮต' (ฯ x'))) (โ (y : X), LE.le (Dist.dist x' y) ฮต' โ LE.le (ฯ y) (HMul.hMul 2 (ฯ x'))))))","decl":"theorem hofer {X : Type*} [MetricSpace X] [CompleteSpace X] (x : X) (ฮต : โ) (ฮต_pos : 0 < ฮต)\n    {ฯ : X โ โ} (cont : Continuous ฯ) (nonneg : โ y, 0 โค ฯ y) : โ ฮต' > 0, โ x' : X,\n    ฮต' โค ฮต โง d x' x โค 2 * ฮต โง ฮต * ฯ x โค ฮต' * ฯ x' โง โ y, d x' y โค ฮต' โ ฯ y โค 2 * ฯ x' := by\n  by_contra H\n  have reformulation : โ (x') (k : โ), ฮต * ฯ x โค ฮต / 2 ^ k * ฯ x' โ 2 ^ k * ฯ x โค ฯ x' := by\n    intro x' k\n    rw [div_mul_eq_mul_div, le_div_iffโ, mul_assoc, mul_le_mul_left ฮต_pos, mul_comm]\n    positivity\n  -- Now let's specialize to `ฮต/2^k`\n  replace H : โ k : โ, โ x', d x' x โค 2 * ฮต โง 2 ^ k * ฯ x โค ฯ x' โ\n      โ y, d x' y โค ฮต / 2 ^ k โง 2 * ฯ x' < ฯ y := by\n    intro k x'\n    push_neg at H\n    have := H (ฮต / 2 ^ k) (by positivity) x' (div_le_self ฮต_pos.le <| one_le_powโ one_le_two)\n    simpa [reformulation] using this\n  haveI : Nonempty X := โจxโฉ\n  choose! F hF using H\n  -- Use the axiom of choice\n  -- Now define u by induction starting at x, with u_{n+1} = F(n, u_n)\n  let u : โ โ X := fun n => Nat.recOn n x F\n  -- The properties of F translate to properties of u\n  have hu :\n    โ n,\n      d (u n) x โค 2 * ฮต โง 2 ^ n * ฯ x โค ฯ (u n) โ\n        d (u n) (u <| n + 1) โค ฮต / 2 ^ n โง 2 * ฯ (u n) < ฯ (u <| n + 1) := by\n    exact fun n โฆ hF n (u n)\n  -- Key properties of u, to be proven by induction\n  have key : โ n, d (u n) (u (n + 1)) โค ฮต / 2 ^ n โง 2 * ฯ (u n) < ฯ (u (n + 1)) := by\n    intro n\n    induction n using Nat.case_strong_induction_on with\n    | hz => simpa [u, ฮต_pos.le] using hu 0\n    | hi n IH =>\n      have A : d (u (n + 1)) x โค 2 * ฮต := by\n        rw [dist_comm]\n        let r := range (n + 1) -- range (n+1) = {0, ..., n}\n        calc\n          d (u 0) (u (n + 1)) โค โ i โ r, d (u i) (u <| i + 1) := dist_le_range_sum_dist u (n + 1)\n          _ โค โ i โ r, ฮต / 2 ^ i :=\n            (sum_le_sum fun i i_in => (IH i <| Nat.lt_succ_iff.mp <| Finset.mem_range.mp i_in).1)\n          _ = (โ i โ r, (1 / 2 : โ) ^ i) * ฮต := by\n            rw [Finset.sum_mul]\n            field_simp\n          _ โค 2 * ฮต := by gcongr; apply sum_geometric_two_le\n      have B : 2 ^ (n + 1) * ฯ x โค ฯ (u (n + 1)) := by\n        refine @geom_le (ฯ โ u) _ zero_le_two (n + 1) fun m hm => ?_\n        exact (IH _ <| Nat.lt_add_one_iff.1 hm).2.le\n      exact hu (n + 1) โจA, Bโฉ\n  cases' forall_and.mp key with keyโ keyโ\n  -- Hence u is Cauchy\n  have cauchy_u : CauchySeq u := by\n    refine cauchySeq_of_le_geometric _ ฮต one_half_lt_one fun n => ?_\n    simpa only [one_div, inv_pow] using keyโ n\n  -- So u converges to some y\n  obtain โจy, limyโฉ : โ y, Tendsto u atTop (๐ y) := CompleteSpace.complete cauchy_u\n  -- And ฯ โ u goes to +โ\n  have lim_top : Tendsto (ฯ โ u) atTop atTop := by\n    let v n := (ฯ โ u) (n + 1)\n    suffices Tendsto v atTop atTop by rwa [tendsto_add_atTop_iff_nat] at this\n    have hvโ : 0 < v 0 := by\n      calc\n        0 โค 2 * ฯ (u 0) := by specialize nonneg x; positivity\n        _ < ฯ (u (0 + 1)) := keyโ 0\n    apply tendsto_atTop_of_geom_le hvโ one_lt_two\n    exact fun n => (keyโ (n + 1)).le\n  -- But ฯ โ u also needs to go to ฯ(y)\n  have lim : Tendsto (ฯ โ u) atTop (๐ (ฯ y)) := Tendsto.comp cont.continuousAt limy\n  -- So we have our contradiction!\n  exact not_tendsto_atTop_of_tendsto_nhds lim lim_top\n"}
