{"name":"Representation.trivial_def","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\nV : Type u_3\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\ninst✝¹ : AddCommMonoid V\ninst✝ : Module k V\ng : G\nv : V\n⊢ Eq (((Representation.trivial k) g) v) v","decl":"theorem trivial_def (g : G) (v : V) : trivial k (V := V) g v = v :=\n  rfl\n\n"}
{"name":"Representation.IsTrivial.out","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\nV : Type u_3\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\ninst✝¹ : AddCommMonoid V\ninst✝ : Module k V\nρ : Representation k G V\nself : ρ.IsTrivial\ng : G\nx : V\n⊢ Eq ((ρ g) x) x","decl":"/-- A predicate for representations that fix every element. -/\nclass IsTrivial (ρ : Representation k G V) : Prop where\n  out : ∀ g x, ρ g x = x := by aesop\n\n"}
{"name":"Representation.instIsTrivialTrivial","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\nV : Type u_3\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\ninst✝¹ : AddCommMonoid V\ninst✝ : Module k V\n⊢ (Representation.trivial k).IsTrivial","decl":"instance : IsTrivial (trivial k (G := G) (V := V)) where\n\n"}
{"name":"Representation.apply_eq_self","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\nV : Type u_3\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\ninst✝¹ : AddCommMonoid V\ninst✝ : Module k V\nρ : Representation k G V\ng : G\nx : V\nh : ρ.IsTrivial\n⊢ Eq ((ρ g) x) x","decl":"@[simp] theorem apply_eq_self\n    (ρ : Representation k G V) (g : G) (x : V) [h : IsTrivial ρ] :\n    ρ g x = x := h.out g x\n\n"}
{"name":"Representation.asAlgebraHom_def","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\nV : Type u_3\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\ninst✝¹ : AddCommMonoid V\ninst✝ : Module k V\nρ : Representation k G V\n⊢ Eq ρ.asAlgebraHom ((MonoidAlgebra.lift k G (LinearMap (RingHom.id k) V V)) ρ)","decl":"theorem asAlgebraHom_def : asAlgebraHom ρ = (lift k G _) ρ :=\n  rfl\n\n"}
{"name":"Representation.asAlgebraHom_single","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\nV : Type u_3\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\ninst✝¹ : AddCommMonoid V\ninst✝ : Module k V\nρ : Representation k G V\ng : G\nr : k\n⊢ Eq (ρ.asAlgebraHom (Finsupp.single g r)) (HSMul.hSMul r (ρ g))","decl":"@[simp]\ntheorem asAlgebraHom_single (g : G) (r : k) : asAlgebraHom ρ (Finsupp.single g r) = r • ρ g := by\n  simp only [asAlgebraHom_def, MonoidAlgebra.lift_single]\n\n"}
{"name":"Representation.asAlgebraHom_single_one","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\nV : Type u_3\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\ninst✝¹ : AddCommMonoid V\ninst✝ : Module k V\nρ : Representation k G V\ng : G\n⊢ Eq (ρ.asAlgebraHom (Finsupp.single g 1)) (ρ g)","decl":"theorem asAlgebraHom_single_one (g : G) : asAlgebraHom ρ (Finsupp.single g 1) = ρ g := by simp\n\n"}
{"name":"Representation.asAlgebraHom_of","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\nV : Type u_3\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\ninst✝¹ : AddCommMonoid V\ninst✝ : Module k V\nρ : Representation k G V\ng : G\n⊢ Eq (ρ.asAlgebraHom ((MonoidAlgebra.of k G) g)) (ρ g)","decl":"theorem asAlgebraHom_of (g : G) : asAlgebraHom ρ (of k G g) = ρ g := by\n  simp only [MonoidAlgebra.of_apply, asAlgebraHom_single, one_smul]\n\n"}
{"name":"Representation.asModuleEquiv_map_smul","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\nV : Type u_3\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\ninst✝¹ : AddCommMonoid V\ninst✝ : Module k V\nρ : Representation k G V\nr : MonoidAlgebra k G\nx : ρ.asModule\n⊢ Eq (ρ.asModuleEquiv (HSMul.hSMul r x)) ((ρ.asAlgebraHom r) (ρ.asModuleEquiv x))","decl":"@[simp]\ntheorem asModuleEquiv_map_smul (r : MonoidAlgebra k G) (x : ρ.asModule) :\n    ρ.asModuleEquiv (r • x) = ρ.asAlgebraHom r (ρ.asModuleEquiv x) :=\n  rfl\n\n"}
{"name":"Representation.asModuleEquiv_symm_map_smul","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\nV : Type u_3\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\ninst✝¹ : AddCommMonoid V\ninst✝ : Module k V\nρ : Representation k G V\nr : k\nx : V\n⊢ Eq (ρ.asModuleEquiv.symm (HSMul.hSMul r x)) (HSMul.hSMul ((algebraMap k (MonoidAlgebra k G)) r) (ρ.asModuleEquiv.symm x))","decl":"@[simp]\ntheorem asModuleEquiv_symm_map_smul (r : k) (x : V) :\n    ρ.asModuleEquiv.symm (r • x) = algebraMap k (MonoidAlgebra k G) r • ρ.asModuleEquiv.symm x := by\n  apply_fun ρ.asModuleEquiv\n  simp\n\n"}
{"name":"Representation.asModuleEquiv_symm_map_rho","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\nV : Type u_3\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\ninst✝¹ : AddCommMonoid V\ninst✝ : Module k V\nρ : Representation k G V\ng : G\nx : V\n⊢ Eq (ρ.asModuleEquiv.symm ((ρ g) x)) (HSMul.hSMul ((MonoidAlgebra.of k G) g) (ρ.asModuleEquiv.symm x))","decl":"@[simp]\ntheorem asModuleEquiv_symm_map_rho (g : G) (x : V) :\n    ρ.asModuleEquiv.symm (ρ g x) = MonoidAlgebra.of k G g • ρ.asModuleEquiv.symm x := by\n  apply_fun ρ.asModuleEquiv\n  simp\n\n"}
{"name":"Representation.ofModule_asAlgebraHom_apply_apply","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : Module (MonoidAlgebra k G) M\nr : MonoidAlgebra k G\nm : RestrictScalars k (MonoidAlgebra k G) M\n⊢ Eq (((Representation.ofModule M).asAlgebraHom r) m) ((RestrictScalars.addEquiv k (MonoidAlgebra k G) M).symm (HSMul.hSMul r ((RestrictScalars.addEquiv k (MonoidAlgebra k G) M) m)))","decl":"@[simp]\ntheorem ofModule_asAlgebraHom_apply_apply (r : MonoidAlgebra k G)\n    (m : RestrictScalars k (MonoidAlgebra k G) M) :\n    ((ofModule M).asAlgebraHom r) m =\n      (RestrictScalars.addEquiv _ _ _).symm (r • RestrictScalars.addEquiv _ _ _ m) := by\n  apply MonoidAlgebra.induction_on r\n  · intro g\n    simp only [one_smul, MonoidAlgebra.lift_symm_apply, MonoidAlgebra.of_apply,\n      Representation.asAlgebraHom_single, Representation.ofModule, AddEquiv.apply_eq_iff_eq,\n      RestrictScalars.lsmul_apply_apply]\n  · intro f g fw gw\n    simp only [fw, gw, map_add, add_smul, LinearMap.add_apply]\n  · intro r f w\n    simp only [w, map_smul, LinearMap.smul_apply, RestrictScalars.addEquiv_symm_map_smul_smul]\n\n"}
{"name":"Representation.ofModule_asModule_act","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\nV : Type u_3\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\ninst✝¹ : AddCommMonoid V\ninst✝ : Module k V\nρ : Representation k G V\ng : G\nx : RestrictScalars k (MonoidAlgebra k G) ρ.asModule\n⊢ Eq (((Representation.ofModule ρ.asModule) g) x) ((RestrictScalars.addEquiv k (MonoidAlgebra k G) ρ.asModule).symm (ρ.asModuleEquiv.symm ((ρ g) (ρ.asModuleEquiv ((RestrictScalars.addEquiv k (MonoidAlgebra k G) ρ.asModule) x)))))","decl":"@[simp]\ntheorem ofModule_asModule_act (g : G) (x : RestrictScalars k (MonoidAlgebra k G) ρ.asModule) :\n    ofModule (k := k) (G := G) ρ.asModule g x = -- Porting note: more help with implicit\n      (RestrictScalars.addEquiv _ _ _).symm\n        (ρ.asModuleEquiv.symm (ρ g (ρ.asModuleEquiv (RestrictScalars.addEquiv _ _ _ x)))) := by\n  apply_fun RestrictScalars.addEquiv _ _ ρ.asModule using\n    (RestrictScalars.addEquiv _ _ ρ.asModule).injective\n  dsimp [ofModule, RestrictScalars.lsmul_apply_apply]\n  simp\n\n"}
{"name":"Representation.smul_ofModule_asModule","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : Module (MonoidAlgebra k G) M\nr : MonoidAlgebra k G\nm : (Representation.ofModule M).asModule\n⊢ Eq ((RestrictScalars.addEquiv k (MonoidAlgebra k G) M) ((Representation.ofModule M).asModuleEquiv (HSMul.hSMul r m))) (HSMul.hSMul r ((RestrictScalars.addEquiv k (MonoidAlgebra k G) M) ((Representation.ofModule M).asModuleEquiv m)))","decl":"theorem smul_ofModule_asModule (r : MonoidAlgebra k G) (m : (ofModule M).asModule) :\n    (RestrictScalars.addEquiv k _ _) ((ofModule M).asModuleEquiv (r • m)) =\n      r • (RestrictScalars.addEquiv k _ _) ((ofModule M).asModuleEquiv (G := G) m) := by\n  dsimp\n  simp only [AddEquiv.apply_symm_apply, ofModule_asAlgebraHom_apply_apply]\n\n"}
{"name":"Representation.ofMulAction_def","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\ninst✝² : CommSemiring k\nG : Type u_2\ninst✝¹ : Monoid G\nH : Type u_3\ninst✝ : MulAction G H\ng : G\n⊢ Eq ((Representation.ofMulAction k G H) g) (Finsupp.lmapDomain k k fun x => HSMul.hSMul g x)","decl":"theorem ofMulAction_def (g : G) : ofMulAction k G H g = Finsupp.lmapDomain k k (g • ·) :=\n  rfl\n\n"}
{"name":"Representation.ofMulAction_single","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\ninst✝² : CommSemiring k\nG : Type u_2\ninst✝¹ : Monoid G\nH : Type u_3\ninst✝ : MulAction G H\ng : G\nx : H\nr : k\n⊢ Eq (((Representation.ofMulAction k G H) g) (Finsupp.single x r)) (Finsupp.single (HSMul.hSMul g x) r)","decl":"theorem ofMulAction_single (g : G) (x : H) (r : k) :\n    ofMulAction k G H g (Finsupp.single x r) = Finsupp.single (g • x) r :=\n  Finsupp.mapDomain_single\n\n"}
{"name":"Representation.ofDistribMulAction_apply_apply","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\nA : Type u_3\ninst✝⁵ : CommSemiring k\ninst✝⁴ : Monoid G\ninst✝³ : AddCommMonoid A\ninst✝² : Module k A\ninst✝¹ : DistribMulAction G A\ninst✝ : SMulCommClass G k A\ng : G\na : A\n⊢ Eq (((Representation.ofDistribMulAction k G A) g) a) (HSMul.hSMul g a)","decl":"@[simp] theorem ofDistribMulAction_apply_apply (g : G) (a : A) :\n    ofDistribMulAction k G A g a = g • a := rfl\n\n"}
{"name":"Representation.ofMulDistribMulAction_apply_apply","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"M : Type u_1\nG : Type u_2\ninst✝² : Monoid M\ninst✝¹ : CommGroup G\ninst✝ : MulDistribMulAction M G\ng : M\na : Additive G\n⊢ Eq (((Representation.ofMulDistribMulAction M G) g) a) (Additive.ofMul (HSMul.hSMul g (Additive.toMul a)))","decl":"@[simp] theorem ofMulDistribMulAction_apply_apply (g : M) (a : Additive G) :\n    ofMulDistribMulAction M G g a = Additive.ofMul (g • a.toMul) := rfl\n\n"}
{"name":"Representation.ofMulAction_apply","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝² : CommSemiring k\ninst✝¹ : Group G\nH : Type u_4\ninst✝ : MulAction G H\ng : G\nf : Finsupp H k\nh : H\n⊢ Eq ((((Representation.ofMulAction k G H) g) f) h) (f (HSMul.hSMul (Inv.inv g) h))","decl":"@[simp]\ntheorem ofMulAction_apply {H : Type*} [MulAction G H] (g : G) (f : H →₀ k) (h : H) :\n    ofMulAction k G H g f h = f (g⁻¹ • h) := by\n  conv_lhs => rw [← smul_inv_smul g h]\n  let h' := g⁻¹ • h\n  change ofMulAction k G H g f (g • h') = f h'\n  have hg : Function.Injective (g • · : H → H) := by\n    intro h₁ h₂\n    simp\n  simp only [ofMulAction_def, Finsupp.lmapDomain_apply, Finsupp.mapDomain_apply, hg]\n\n-- Porting note: did not need this in ML3; noncomputable because IR check complains\n"}
{"name":"Representation.ofMulAction_self_smul_eq_mul","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝¹ : CommSemiring k\ninst✝ : Group G\nx : MonoidAlgebra k G\ny : (Representation.ofMulAction k G G).asModule\n⊢ Eq (HSMul.hSMul x y) (HMul.hMul x y)","decl":"theorem ofMulAction_self_smul_eq_mul (x : MonoidAlgebra k G) (y : (ofMulAction k G G).asModule) :\n    x • y = (x * y : MonoidAlgebra k G) := -- by\n  -- Porting note: trouble figuring out the motive\n  x.induction_on (p := fun z => z • y = z * y)\n    (fun g => by\n      show asAlgebraHom (ofMulAction k G G) _ _ = _; ext\n      simp only [MonoidAlgebra.of_apply, asAlgebraHom_single, one_smul,\n        ofMulAction_apply, smul_eq_mul]\n      -- Porting note: single_mul_apply not firing in simp\n      rw [MonoidAlgebra.single_mul_apply, one_mul]\n    )\n    (fun x y hx hy => by simp only [hx, hy, add_mul, add_smul]) fun r x hx => by\n    show asAlgebraHom (ofMulAction k G G) _ _ = _  -- Porting note: was simpa [← hx]\n    simp only [map_smul, smul_apply, Algebra.smul_mul_assoc]\n    rw [← hx]\n    rfl\n\n"}
{"name":"Representation.ofMulActionSelfAsModuleEquiv_apply","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝¹ : CommSemiring k\ninst✝ : Group G\na✝ : (Representation.ofMulAction k G G).asModule\n⊢ Eq (Representation.ofMulActionSelfAsModuleEquiv a✝) ((Representation.ofMulAction k G G).asModuleEquiv.toFun a✝)","decl":"/-- If we equip `k[G]` with the `k`-linear `G`-representation induced by the left regular action of\n`G` on itself, the resulting object is isomorphic as a `k[G]`-module to `k[G]` with its natural\n`k[G]`-module structure. -/\n@[simps]\nnoncomputable def ofMulActionSelfAsModuleEquiv :\n    (ofMulAction k G G).asModule ≃ₗ[MonoidAlgebra k G] MonoidAlgebra k G :=\n  { asModuleEquiv _ with map_smul' := ofMulAction_self_smul_eq_mul }\n\n"}
{"name":"Representation.ofMulActionSelfAsModuleEquiv_symm_apply","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝¹ : CommSemiring k\ninst✝ : Group G\na✝ : Finsupp G k\n⊢ Eq (Representation.ofMulActionSelfAsModuleEquiv.symm a✝) ((Representation.ofMulAction k G G).asModuleEquiv.invFun a✝)","decl":"/-- If we equip `k[G]` with the `k`-linear `G`-representation induced by the left regular action of\n`G` on itself, the resulting object is isomorphic as a `k[G]`-module to `k[G]` with its natural\n`k[G]`-module structure. -/\n@[simps]\nnoncomputable def ofMulActionSelfAsModuleEquiv :\n    (ofMulAction k G G).asModule ≃ₗ[MonoidAlgebra k G] MonoidAlgebra k G :=\n  { asModuleEquiv _ with map_smul' := ofMulAction_self_smul_eq_mul }\n\n"}
{"name":"Representation.asGroupHom_apply","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\nV : Type u_3\ninst✝³ : CommSemiring k\ninst✝² : Group G\ninst✝¹ : AddCommMonoid V\ninst✝ : Module k V\nρ : Representation k G V\ng : G\n⊢ Eq (↑(ρ.asGroupHom g)) (ρ g)","decl":"theorem asGroupHom_apply (g : G) : ↑(asGroupHom ρ g) = ρ g := by\n  simp only [asGroupHom, MonoidHom.coe_toHomUnits]\n\n"}
{"name":"Representation.tprod_apply","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\nV : Type u_3\nW : Type u_4\ninst✝⁵ : CommSemiring k\ninst✝⁴ : Monoid G\ninst✝³ : AddCommMonoid V\ninst✝² : Module k V\ninst✝¹ : AddCommMonoid W\ninst✝ : Module k W\nρV : Representation k G V\nρW : Representation k G W\ng : G\n⊢ Eq ((ρV.tprod ρW) g) (TensorProduct.map (ρV g) (ρW g))","decl":"@[simp]\ntheorem tprod_apply (g : G) : (ρV ⊗ ρW) g = TensorProduct.map (ρV g) (ρW g) :=\n  rfl\n\n"}
{"name":"Representation.smul_tprod_one_asModule","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\nV : Type u_3\nW : Type u_4\ninst✝⁵ : CommSemiring k\ninst✝⁴ : Monoid G\ninst✝³ : AddCommMonoid V\ninst✝² : Module k V\ninst✝¹ : AddCommMonoid W\ninst✝ : Module k W\nρV : Representation k G V\nr : MonoidAlgebra k G\nx : V\ny : W\n⊢ let x' := x;\n  let z := TensorProduct.tmul k x y;\n  Eq (HSMul.hSMul r z) (TensorProduct.tmul k (HSMul.hSMul r x') y)","decl":"theorem smul_tprod_one_asModule (r : MonoidAlgebra k G) (x : V) (y : W) :\n    -- Porting note: required to since Lean 4 doesn't unfold asModule\n    let x' : ρV.asModule := x\n    let z : (ρV.tprod 1).asModule := x ⊗ₜ y\n    r • z = (r • x') ⊗ₜ y := by\n  show asAlgebraHom (ρV ⊗ 1) _ _ = asAlgebraHom ρV _ _ ⊗ₜ _\n  simp only [asAlgebraHom_def, MonoidAlgebra.lift_apply, tprod_apply, MonoidHom.one_apply,\n    LinearMap.finsupp_sum_apply, LinearMap.smul_apply, TensorProduct.map_tmul, LinearMap.one_apply]\n  simp only [Finsupp.sum, TensorProduct.sum_tmul]\n  rfl\n\n"}
{"name":"Representation.smul_one_tprod_asModule","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\nV : Type u_3\nW : Type u_4\ninst✝⁵ : CommSemiring k\ninst✝⁴ : Monoid G\ninst✝³ : AddCommMonoid V\ninst✝² : Module k V\ninst✝¹ : AddCommMonoid W\ninst✝ : Module k W\nρW : Representation k G W\nr : MonoidAlgebra k G\nx : V\ny : W\n⊢ let y' := y;\n  let z := TensorProduct.tmul k x y;\n  Eq (HSMul.hSMul r z) (TensorProduct.tmul k x (HSMul.hSMul r y'))","decl":"theorem smul_one_tprod_asModule (r : MonoidAlgebra k G) (x : V) (y : W) :\n    -- Porting note: required to since Lean 4 doesn't unfold asModule\n    let y' : ρW.asModule := y\n    let z : (1 ⊗ ρW).asModule := x ⊗ₜ y\n    r • z = x ⊗ₜ (r • y') := by\n  show asAlgebraHom (1 ⊗ ρW) _ _ = _ ⊗ₜ asAlgebraHom ρW _ _\n  simp only [asAlgebraHom_def, MonoidAlgebra.lift_apply, tprod_apply, MonoidHom.one_apply,\n    LinearMap.finsupp_sum_apply, LinearMap.smul_apply, TensorProduct.map_tmul, LinearMap.one_apply]\n  simp only [Finsupp.sum, TensorProduct.tmul_sum, TensorProduct.tmul_smul]\n\n"}
{"name":"Representation.linHom_apply","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\nV : Type u_3\nW : Type u_4\ninst✝⁵ : CommSemiring k\ninst✝⁴ : Group G\ninst✝³ : AddCommMonoid V\ninst✝² : Module k V\ninst✝¹ : AddCommMonoid W\ninst✝ : Module k W\nρV : Representation k G V\nρW : Representation k G W\ng : G\nf : LinearMap (RingHom.id k) V W\n⊢ Eq (((ρV.linHom ρW) g) f) ((ρW g).comp (f.comp (ρV (Inv.inv g))))","decl":"@[simp]\ntheorem linHom_apply (g : G) (f : V →ₗ[k] W) : (linHom ρV ρW) g f = ρW g ∘ₗ f ∘ₗ ρV g⁻¹ :=\n  rfl\n\n"}
{"name":"Representation.dual_apply","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\nV : Type u_3\ninst✝³ : CommSemiring k\ninst✝² : Group G\ninst✝¹ : AddCommMonoid V\ninst✝ : Module k V\nρV : Representation k G V\ng : G\n⊢ Eq (ρV.dual g) (Module.Dual.transpose (ρV (Inv.inv g)))","decl":"@[simp]\ntheorem dual_apply (g : G) : (dual ρV) g = Module.Dual.transpose (R := k) (ρV g⁻¹) :=\n  rfl\n\n"}
{"name":"Representation.dualTensorHom_comm","module":"Mathlib.RepresentationTheory.Basic","initialProofState":"k : Type u_1\nG : Type u_2\nV : Type u_3\nW : Type u_4\ninst✝⁵ : CommSemiring k\ninst✝⁴ : Group G\ninst✝³ : AddCommMonoid V\ninst✝² : Module k V\ninst✝¹ : AddCommMonoid W\ninst✝ : Module k W\nρV : Representation k G V\nρW : Representation k G W\ng : G\n⊢ Eq ((dualTensorHom k V W).comp (TensorProduct.map (ρV.dual g) (ρW g))) (((ρV.linHom ρW) g).comp (dualTensorHom k V W))","decl":"/-- Given $k$-modules $V, W$, there is a homomorphism $φ : V^* ⊗ W → Hom_k(V, W)$\n(implemented by `dualTensorHom` in `Mathlib.LinearAlgebra.Contraction`).\nGiven representations of $G$ on $V$ and $W$,there are representations of $G$ on $V^* ⊗ W$ and on\n$Hom_k(V, W)$.\nThis lemma says that $φ$ is $G$-linear.\n-/\ntheorem dualTensorHom_comm (g : G) :\n    dualTensorHom k V W ∘ₗ TensorProduct.map (ρV.dual g) (ρW g) =\n      (linHom ρV ρW) g ∘ₗ dualTensorHom k V W := by\n  ext; simp [Module.Dual.transpose_apply]\n\n"}
