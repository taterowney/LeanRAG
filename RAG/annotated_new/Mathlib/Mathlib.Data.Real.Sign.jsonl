{"name":"Real.sign_of_neg","module":"Mathlib.Data.Real.Sign","initialProofState":"r : Real\nhr : LT.lt r 0\n⊢ Eq r.sign (-1)","decl":"theorem sign_of_neg {r : ℝ} (hr : r < 0) : sign r = -1 := by rw [sign, if_pos hr]\n\n"}
{"name":"Real.sign_of_pos","module":"Mathlib.Data.Real.Sign","initialProofState":"r : Real\nhr : LT.lt 0 r\n⊢ Eq r.sign 1","decl":"theorem sign_of_pos {r : ℝ} (hr : 0 < r) : sign r = 1 := by rw [sign, if_pos hr, if_neg hr.not_lt]\n\n"}
{"name":"Real.sign_zero","module":"Mathlib.Data.Real.Sign","initialProofState":"⊢ Eq (Real.sign 0) 0","decl":"@[simp]\ntheorem sign_zero : sign 0 = 0 := by rw [sign, if_neg (lt_irrefl _), if_neg (lt_irrefl _)]\n\n"}
{"name":"Real.sign_one","module":"Mathlib.Data.Real.Sign","initialProofState":"⊢ Eq (Real.sign 1) 1","decl":"@[simp]\ntheorem sign_one : sign 1 = 1 :=\n  sign_of_pos <| by norm_num\n\n"}
{"name":"Real.sign_apply_eq","module":"Mathlib.Data.Real.Sign","initialProofState":"r : Real\n⊢ Or (Eq r.sign (-1)) (Or (Eq r.sign 0) (Eq r.sign 1))","decl":"theorem sign_apply_eq (r : ℝ) : sign r = -1 ∨ sign r = 0 ∨ sign r = 1 := by\n  obtain hn | rfl | hp := lt_trichotomy r (0 : ℝ)\n  · exact Or.inl <| sign_of_neg hn\n  · exact Or.inr <| Or.inl <| sign_zero\n  · exact Or.inr <| Or.inr <| sign_of_pos hp\n\n"}
{"name":"Real.sign_apply_eq_of_ne_zero","module":"Mathlib.Data.Real.Sign","initialProofState":"r : Real\nh : Ne r 0\n⊢ Or (Eq r.sign (-1)) (Eq r.sign 1)","decl":"/-- This lemma is useful for working with `ℝˣ` -/\ntheorem sign_apply_eq_of_ne_zero (r : ℝ) (h : r ≠ 0) : sign r = -1 ∨ sign r = 1 :=\n  h.lt_or_lt.imp sign_of_neg sign_of_pos\n\n"}
{"name":"Real.sign_eq_zero_iff","module":"Mathlib.Data.Real.Sign","initialProofState":"r : Real\n⊢ Iff (Eq r.sign 0) (Eq r 0)","decl":"@[simp]\ntheorem sign_eq_zero_iff {r : ℝ} : sign r = 0 ↔ r = 0 := by\n  refine ⟨fun h => ?_, fun h => h.symm ▸ sign_zero⟩\n  obtain hn | rfl | hp := lt_trichotomy r (0 : ℝ)\n  · rw [sign_of_neg hn, neg_eq_zero] at h\n    exact (one_ne_zero h).elim\n  · rfl\n  · rw [sign_of_pos hp] at h\n    exact (one_ne_zero h).elim\n\n"}
{"name":"Real.sign_intCast","module":"Mathlib.Data.Real.Sign","initialProofState":"z : Int\n⊢ Eq (↑z).sign ↑z.sign","decl":"theorem sign_intCast (z : ℤ) : sign (z : ℝ) = ↑(Int.sign z) := by\n  obtain hn | rfl | hp := lt_trichotomy z (0 : ℤ)\n  · rw [sign_of_neg (Int.cast_lt_zero.mpr hn), Int.sign_eq_neg_one_of_neg hn, Int.cast_neg,\n      Int.cast_one]\n  · rw [Int.cast_zero, sign_zero, Int.sign_zero, Int.cast_zero]\n  · rw [sign_of_pos (Int.cast_pos.mpr hp), Int.sign_eq_one_of_pos hp, Int.cast_one]\n\n"}
{"name":"Real.sign_neg","module":"Mathlib.Data.Real.Sign","initialProofState":"r : Real\n⊢ Eq (Neg.neg r).sign (Neg.neg r.sign)","decl":"theorem sign_neg {r : ℝ} : sign (-r) = -sign r := by\n  obtain hn | rfl | hp := lt_trichotomy r (0 : ℝ)\n  · rw [sign_of_neg hn, sign_of_pos (neg_pos.mpr hn), neg_neg]\n  · rw [sign_zero, neg_zero, sign_zero]\n  · rw [sign_of_pos hp, sign_of_neg (neg_lt_zero.mpr hp)]\n\n"}
{"name":"Real.sign_mul_nonneg","module":"Mathlib.Data.Real.Sign","initialProofState":"r : Real\n⊢ LE.le 0 (HMul.hMul r.sign r)","decl":"theorem sign_mul_nonneg (r : ℝ) : 0 ≤ sign r * r := by\n  obtain hn | rfl | hp := lt_trichotomy r (0 : ℝ)\n  · rw [sign_of_neg hn]\n    exact mul_nonneg_of_nonpos_of_nonpos (by norm_num) hn.le\n  · rw [mul_zero]\n  · rw [sign_of_pos hp, one_mul]\n    exact hp.le\n\n"}
{"name":"Real.sign_mul_pos_of_ne_zero","module":"Mathlib.Data.Real.Sign","initialProofState":"r : Real\nhr : Ne r 0\n⊢ LT.lt 0 (HMul.hMul r.sign r)","decl":"theorem sign_mul_pos_of_ne_zero (r : ℝ) (hr : r ≠ 0) : 0 < sign r * r := by\n  refine lt_of_le_of_ne (sign_mul_nonneg r) fun h => hr ?_\n  have hs0 := (zero_eq_mul.mp h).resolve_right hr\n  exact sign_eq_zero_iff.mp hs0\n\n"}
{"name":"Real.inv_sign","module":"Mathlib.Data.Real.Sign","initialProofState":"r : Real\n⊢ Eq (Inv.inv r.sign) r.sign","decl":"@[simp]\ntheorem inv_sign (r : ℝ) : (sign r)⁻¹ = sign r := by\n  obtain hn | hz | hp := sign_apply_eq r\n  · rw [hn]\n    norm_num\n  · rw [hz]\n    exact inv_zero\n  · rw [hp]\n    exact inv_one\n\n"}
{"name":"Real.sign_inv","module":"Mathlib.Data.Real.Sign","initialProofState":"r : Real\n⊢ Eq (Inv.inv r).sign r.sign","decl":"@[simp]\ntheorem sign_inv (r : ℝ) : sign r⁻¹ = sign r := by\n  obtain hn | rfl | hp := lt_trichotomy r (0 : ℝ)\n  · rw [sign_of_neg hn, sign_of_neg (inv_lt_zero.mpr hn)]\n  · rw [sign_zero, inv_zero, sign_zero]\n  · rw [sign_of_pos hp, sign_of_pos (inv_pos.mpr hp)]\n\n"}
