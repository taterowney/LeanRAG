{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.isIso_map","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} J\ninst✝ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh : F.IsEventuallyConstantTo i₀\ni j : J\nφ : Quiver.Hom i j\nπ : Quiver.Hom j i₀\n⊢ CategoryTheory.IsIso (F.map φ)","decl":"lemma isIso_map {i j : J} (φ : i ⟶ j) (π : j ⟶ i₀) : IsIso (F.map φ) := by\n  have := h π\n  have := h (φ ≫ π)\n  exact IsIso.of_isIso_fac_right (F.map_comp φ π).symm\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.precomp","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} J\ninst✝ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh : F.IsEventuallyConstantTo i₀\nj : J\nf : Quiver.Hom j i₀\n⊢ F.IsEventuallyConstantTo j","decl":"lemma precomp {j : J} (f : j ⟶ i₀) : F.IsEventuallyConstantTo j :=\n  fun _ φ ↦ h.isIso_map φ f\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.isoMap_hom","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} J\ninst✝ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh : F.IsEventuallyConstantTo i₀\ni j : J\nφ : Quiver.Hom i j\nhφ : Nonempty (Quiver.Hom j i₀)\n⊢ Eq (h.isoMap φ hφ).hom (F.map φ)","decl":"/-- The isomorphism `F.obj i ≅ F.obj j` induced by `φ : i ⟶ j`,\nwhen `h : F.IsEventuallyConstantTo i₀` and there exists a map `j ⟶ i₀`. -/\n@[simps! hom]\nnoncomputable def isoMap : F.obj i ≅ F.obj j :=\n  have := h.isIso_map φ hφ.some\n  asIso (F.map φ)\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.isoMap_hom_inv_id","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} J\ninst✝ : CategoryTheory.Category.{u_3, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh : F.IsEventuallyConstantTo i₀\ni j : J\nφ : Quiver.Hom i j\nhφ : Nonempty (Quiver.Hom j i₀)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map φ) (h.isoMap φ hφ).inv) (CategoryTheory.CategoryStruct.id (F.obj i))","decl":"@[reassoc (attr := simp)]\nlemma isoMap_hom_inv_id : F.map φ ≫ (h.isoMap φ hφ).inv = 𝟙 _ :=\n  (h.isoMap φ hφ).hom_inv_id\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.isoMap_hom_inv_id_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} J\ninst✝ : CategoryTheory.Category.{u_3, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh✝ : F.IsEventuallyConstantTo i₀\ni j : J\nφ : Quiver.Hom i j\nhφ : Nonempty (Quiver.Hom j i₀)\nZ : C\nh : Quiver.Hom (F.obj i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map φ) (CategoryTheory.CategoryStruct.comp (h✝.isoMap φ hφ).inv h)) h","decl":"@[reassoc (attr := simp)]\nlemma isoMap_hom_inv_id : F.map φ ≫ (h.isoMap φ hφ).inv = 𝟙 _ :=\n  (h.isoMap φ hφ).hom_inv_id\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.isoMap_inv_hom_id_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} J\ninst✝ : CategoryTheory.Category.{u_3, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh✝ : F.IsEventuallyConstantTo i₀\ni j : J\nφ : Quiver.Hom i j\nhφ : Nonempty (Quiver.Hom j i₀)\nZ : C\nh : Quiver.Hom (F.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (h✝.isoMap φ hφ).inv (CategoryTheory.CategoryStruct.comp (F.map φ) h)) h","decl":"@[reassoc (attr := simp)]\nlemma isoMap_inv_hom_id : (h.isoMap φ hφ).inv ≫ F.map φ = 𝟙 _ :=\n  (h.isoMap φ hφ).inv_hom_id\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.isoMap_inv_hom_id","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} J\ninst✝ : CategoryTheory.Category.{u_3, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh : F.IsEventuallyConstantTo i₀\ni j : J\nφ : Quiver.Hom i j\nhφ : Nonempty (Quiver.Hom j i₀)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (h.isoMap φ hφ).inv (F.map φ)) (CategoryTheory.CategoryStruct.id (F.obj j))","decl":"@[reassoc (attr := simp)]\nlemma isoMap_inv_hom_id : (h.isoMap φ hφ).inv ≫ F.map φ = 𝟙 _ :=\n  (h.isoMap φ hφ).inv_hom_id\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.coneπApp_eq","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh : F.IsEventuallyConstantTo i₀\ninst✝ : CategoryTheory.IsCofiltered J\nj j' : J\nα : Quiver.Hom j' i₀\nβ : Quiver.Hom j' j\n⊢ Eq (h.coneπApp j) (CategoryTheory.CategoryStruct.comp (h.isoMap α ⋯).inv (F.map β))","decl":"lemma coneπApp_eq (j j' : J) (α : j' ⟶ i₀) (β : j' ⟶ j) :\n    h.coneπApp j = (h.isoMap α ⟨𝟙 _⟩).inv ≫ F.map β := by\n  obtain ⟨s, γ, δ, h₁, h₂⟩ := IsCofiltered.bowtie\n    (IsCofiltered.minToRight i₀ j) β (IsCofiltered.minToLeft i₀ j) α\n  dsimp [coneπApp]\n  rw [← cancel_epi ((h.isoMap α ⟨𝟙 _⟩).hom), isoMap_hom, isoMap_hom_inv_id_assoc,\n    ← cancel_epi (h.isoMap δ ⟨α⟩).hom, isoMap_hom,\n    ← F.map_comp δ β, ← h₁, F.map_comp, ← F.map_comp_assoc, ← h₂, F.map_comp_assoc,\n    isoMap_hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.coneπApp_eq_id","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh : F.IsEventuallyConstantTo i₀\ninst✝ : CategoryTheory.IsCofiltered J\n⊢ Eq (h.coneπApp i₀) (CategoryTheory.CategoryStruct.id (F.obj i₀))","decl":"@[simp]\nlemma coneπApp_eq_id : h.coneπApp i₀ = 𝟙 _ := by\n  rw [h.coneπApp_eq i₀ i₀ (𝟙 _) (𝟙 _), h.isoMap_inv_hom_id]\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.cone_pt","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh : F.IsEventuallyConstantTo i₀\ninst✝ : CategoryTheory.IsCofiltered J\n⊢ Eq h.cone.pt (F.obj i₀)","decl":"/-- Given `h : F.IsEventuallyConstantTo i₀`, this is the (limit) cone for `F` whose\npoint is `F.obj i₀`. -/\n@[simps]\nnoncomputable def cone : Cone F where\n  pt := F.obj i₀\n  π :=\n    { app := h.coneπApp\n      naturality := fun j j' φ ↦ by\n        dsimp\n        rw [id_comp]\n        let i := IsCofiltered.min i₀ j\n        let α : i ⟶ i₀ := IsCofiltered.minToLeft _ _\n        let β : i ⟶ j := IsCofiltered.minToRight _ _\n        rw [h.coneπApp_eq j _ α β, assoc, h.coneπApp_eq j' _ α (β ≫ φ), map_comp] }\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.cone_π_app","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh : F.IsEventuallyConstantTo i₀\ninst✝ : CategoryTheory.IsCofiltered J\nj : J\n⊢ Eq (h.cone.π.app j) (h.coneπApp j)","decl":"/-- Given `h : F.IsEventuallyConstantTo i₀`, this is the (limit) cone for `F` whose\npoint is `F.obj i₀`. -/\n@[simps]\nnoncomputable def cone : Cone F where\n  pt := F.obj i₀\n  π :=\n    { app := h.coneπApp\n      naturality := fun j j' φ ↦ by\n        dsimp\n        rw [id_comp]\n        let i := IsCofiltered.min i₀ j\n        let α : i ⟶ i₀ := IsCofiltered.minToLeft _ _\n        let β : i ⟶ j := IsCofiltered.minToRight _ _\n        rw [h.coneπApp_eq j _ α β, assoc, h.coneπApp_eq j' _ α (β ≫ φ), map_comp] }\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.hasLimit","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh : F.IsEventuallyConstantTo i₀\ninst✝ : CategoryTheory.IsCofiltered J\n⊢ CategoryTheory.Limits.HasLimit F","decl":"lemma hasLimit : HasLimit F := ⟨_, h.isLimitCone⟩\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.isIso_π_of_isLimit","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh : F.IsEventuallyConstantTo i₀\ninst✝ : CategoryTheory.IsCofiltered J\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsLimit c\n⊢ CategoryTheory.IsIso (c.π.app i₀)","decl":"lemma isIso_π_of_isLimit {c : Cone F} (hc : IsLimit c) :\n    IsIso (c.π.app i₀) := by\n  simp only [← IsLimit.conePointUniqueUpToIso_hom_comp hc h.isLimitCone i₀,\n    cone_π_app, coneπApp_eq_id, cone_pt, comp_id]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.isIso_π_of_isLimit'","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh : F.IsEventuallyConstantTo i₀\ninst✝ : CategoryTheory.IsCofiltered J\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsLimit c\nj : J\nπ : Quiver.Hom j i₀\n⊢ CategoryTheory.IsIso (c.π.app j)","decl":"/-- More general version of `isIso_π_of_isLimit`. -/\nlemma isIso_π_of_isLimit' {c : Cone F} (hc : IsLimit c) (j : J) (π : j ⟶ i₀) :\n    IsIso (c.π.app j) :=\n  (h.precomp π).isIso_π_of_isLimit hc\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.isIso_map","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} J\ninst✝ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh : F.IsEventuallyConstantFrom i₀\ni j : J\nφ : Quiver.Hom i j\nι : Quiver.Hom i₀ i\n⊢ CategoryTheory.IsIso (F.map φ)","decl":"lemma isIso_map {i j : J} (φ : i ⟶ j) (ι : i₀ ⟶ i) : IsIso (F.map φ) := by\n  have := h ι\n  have := h (ι ≫ φ)\n  exact IsIso.of_isIso_fac_left (F.map_comp ι φ).symm\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.postcomp","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} J\ninst✝ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh : F.IsEventuallyConstantFrom i₀\nj : J\nf : Quiver.Hom i₀ j\n⊢ F.IsEventuallyConstantFrom j","decl":"lemma postcomp {j : J} (f : i₀ ⟶ j) : F.IsEventuallyConstantFrom j :=\n  fun _ φ ↦ h.isIso_map φ f\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.isoMap_hom","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} J\ninst✝ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh : F.IsEventuallyConstantFrom i₀\ni j : J\nφ : Quiver.Hom i j\nhφ : Nonempty (Quiver.Hom i₀ i)\n⊢ Eq (h.isoMap φ hφ).hom (F.map φ)","decl":"/-- The isomorphism `F.obj i ≅ F.obj j` induced by `φ : i ⟶ j`,\nwhen `h : F.IsEventuallyConstantFrom i₀` and there exists a map `i₀ ⟶ i`. -/\n@[simps! hom]\nnoncomputable def isoMap : F.obj i ≅ F.obj j :=\n  have := h.isIso_map φ hφ.some\n  asIso (F.map φ)\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.isoMap_hom_inv_id_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} J\ninst✝ : CategoryTheory.Category.{u_3, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh✝ : F.IsEventuallyConstantFrom i₀\ni j : J\nφ : Quiver.Hom i j\nhφ : Nonempty (Quiver.Hom i₀ i)\nZ : C\nh : Quiver.Hom (F.obj i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map φ) (CategoryTheory.CategoryStruct.comp (h✝.isoMap φ hφ).inv h)) h","decl":"@[reassoc (attr := simp)]\nlemma isoMap_hom_inv_id : F.map φ ≫ (h.isoMap φ hφ).inv = 𝟙 _ :=\n  (h.isoMap φ hφ).hom_inv_id\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.isoMap_hom_inv_id","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} J\ninst✝ : CategoryTheory.Category.{u_3, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh : F.IsEventuallyConstantFrom i₀\ni j : J\nφ : Quiver.Hom i j\nhφ : Nonempty (Quiver.Hom i₀ i)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map φ) (h.isoMap φ hφ).inv) (CategoryTheory.CategoryStruct.id (F.obj i))","decl":"@[reassoc (attr := simp)]\nlemma isoMap_hom_inv_id : F.map φ ≫ (h.isoMap φ hφ).inv = 𝟙 _ :=\n  (h.isoMap φ hφ).hom_inv_id\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.isoMap_inv_hom_id","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} J\ninst✝ : CategoryTheory.Category.{u_3, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh : F.IsEventuallyConstantFrom i₀\ni j : J\nφ : Quiver.Hom i j\nhφ : Nonempty (Quiver.Hom i₀ i)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (h.isoMap φ hφ).inv (F.map φ)) (CategoryTheory.CategoryStruct.id (F.obj j))","decl":"@[reassoc (attr := simp)]\nlemma isoMap_inv_hom_id : (h.isoMap φ hφ).inv ≫ F.map φ = 𝟙 _ :=\n  (h.isoMap φ hφ).inv_hom_id\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.isoMap_inv_hom_id_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} J\ninst✝ : CategoryTheory.Category.{u_3, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh✝ : F.IsEventuallyConstantFrom i₀\ni j : J\nφ : Quiver.Hom i j\nhφ : Nonempty (Quiver.Hom i₀ i)\nZ : C\nh : Quiver.Hom (F.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (h✝.isoMap φ hφ).inv (CategoryTheory.CategoryStruct.comp (F.map φ) h)) h","decl":"@[reassoc (attr := simp)]\nlemma isoMap_inv_hom_id : (h.isoMap φ hφ).inv ≫ F.map φ = 𝟙 _ :=\n  (h.isoMap φ hφ).inv_hom_id\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.coconeιApp_eq","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh : F.IsEventuallyConstantFrom i₀\ninst✝ : CategoryTheory.IsFiltered J\nj j' : J\nα : Quiver.Hom j j'\nβ : Quiver.Hom i₀ j'\n⊢ Eq (h.coconeιApp j) (CategoryTheory.CategoryStruct.comp (F.map α) (h.isoMap β ⋯).inv)","decl":"lemma coconeιApp_eq (j j' : J) (α : j ⟶ j') (β : i₀ ⟶ j') :\n    h.coconeιApp j = F.map α ≫ (h.isoMap β ⟨𝟙 _⟩).inv  := by\n  obtain ⟨s, γ, δ, h₁, h₂⟩ := IsFiltered.bowtie\n    (IsFiltered.leftToMax i₀ j) β (IsFiltered.rightToMax i₀ j) α\n  dsimp [coconeιApp]\n  rw [← cancel_mono ((h.isoMap β ⟨𝟙 _⟩).hom), assoc, assoc, isoMap_hom, isoMap_inv_hom_id,\n    comp_id, ← cancel_mono (h.isoMap δ ⟨β⟩).hom, isoMap_hom, assoc, assoc, ← F.map_comp α δ,\n    ← h₂, F.map_comp, ← F.map_comp β δ, ← h₁, F.map_comp, isoMap_inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.coconeιApp_eq_id","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh : F.IsEventuallyConstantFrom i₀\ninst✝ : CategoryTheory.IsFiltered J\n⊢ Eq (h.coconeιApp i₀) (CategoryTheory.CategoryStruct.id (F.obj i₀))","decl":"@[simp]\nlemma coconeιApp_eq_id : h.coconeιApp i₀ = 𝟙 _ := by\n  rw [h.coconeιApp_eq i₀ i₀ (𝟙 _) (𝟙 _), h.isoMap_hom_inv_id]\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.cocone_ι_app","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh : F.IsEventuallyConstantFrom i₀\ninst✝ : CategoryTheory.IsFiltered J\nj : J\n⊢ Eq (h.cocone.ι.app j) (h.coconeιApp j)","decl":"/-- Given `h : F.IsEventuallyConstantFrom i₀`, this is the (limit) cocone for `F` whose\npoint is `F.obj i₀`. -/\n@[simps]\nnoncomputable def cocone : Cocone F where\n  pt := F.obj i₀\n  ι :=\n    { app := h.coconeιApp\n      naturality := fun j j' φ ↦ by\n        dsimp\n        rw [comp_id]\n        let i := IsFiltered.max i₀ j'\n        let α : i₀ ⟶ i := IsFiltered.leftToMax _ _\n        let β : j' ⟶ i := IsFiltered.rightToMax _ _\n        rw [h.coconeιApp_eq j' _ β α, h.coconeιApp_eq j _ (φ ≫ β) α, map_comp, assoc] }\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.cocone_pt","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh : F.IsEventuallyConstantFrom i₀\ninst✝ : CategoryTheory.IsFiltered J\n⊢ Eq h.cocone.pt (F.obj i₀)","decl":"/-- Given `h : F.IsEventuallyConstantFrom i₀`, this is the (limit) cocone for `F` whose\npoint is `F.obj i₀`. -/\n@[simps]\nnoncomputable def cocone : Cocone F where\n  pt := F.obj i₀\n  ι :=\n    { app := h.coconeιApp\n      naturality := fun j j' φ ↦ by\n        dsimp\n        rw [comp_id]\n        let i := IsFiltered.max i₀ j'\n        let α : i₀ ⟶ i := IsFiltered.leftToMax _ _\n        let β : j' ⟶ i := IsFiltered.rightToMax _ _\n        rw [h.coconeιApp_eq j' _ β α, h.coconeιApp_eq j _ (φ ≫ β) α, map_comp, assoc] }\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.hasColimit","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh : F.IsEventuallyConstantFrom i₀\ninst✝ : CategoryTheory.IsFiltered J\n⊢ CategoryTheory.Limits.HasColimit F","decl":"lemma hasColimit : HasColimit F := ⟨_, h.isColimitCocone⟩\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.isIso_ι_of_isColimit","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh : F.IsEventuallyConstantFrom i₀\ninst✝ : CategoryTheory.IsFiltered J\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\n⊢ CategoryTheory.IsIso (c.ι.app i₀)","decl":"lemma isIso_ι_of_isColimit {c : Cocone F} (hc : IsColimit c) :\n    IsIso (c.ι.app i₀) := by\n  simp only [← IsColimit.comp_coconePointUniqueUpToIso_inv hc h.isColimitCocone i₀,\n    cocone_ι_app, coconeιApp_eq_id, id_comp]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.isIso_ι_of_isColimit'","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni₀ : J\nh : F.IsEventuallyConstantFrom i₀\ninst✝ : CategoryTheory.IsFiltered J\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\nj : J\nι : Quiver.Hom i₀ j\n⊢ CategoryTheory.IsIso (c.ι.app j)","decl":"/-- More general version of `isIso_ι_of_isColimit`. -/\nlemma isIso_ι_of_isColimit' {c : Cocone F} (hc : IsColimit c) (j : J) (ι : i₀ ⟶ j) :\n    IsIso (c.ι.app j) :=\n  (h.postcomp ι).isIso_ι_of_isColimit hc\n\n"}
{"name":"CategoryTheory.IsCofiltered.IsEventuallyConstant.exists_isEventuallyConstantTo","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} J\ninst✝ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\nself : CategoryTheory.IsCofiltered.IsEventuallyConstant F\n⊢ Exists fun j => F.IsEventuallyConstantTo j","decl":"/-- A functor `F : J ⥤ C` from a cofiltered category is eventually constant if there\nexists `j : J`, such that for any `f : i ⟶ j`, the induced map `F.map f` is an isomorphism. -/\nclass IsEventuallyConstant : Prop where\n  exists_isEventuallyConstantTo : ∃ (j : J), F.IsEventuallyConstantTo j\n\n"}
{"name":"CategoryTheory.IsCofiltered.instHasLimitOfIsEventuallyConstant","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\nhF : CategoryTheory.IsCofiltered.IsEventuallyConstant F\ninst✝ : CategoryTheory.IsCofiltered J\n⊢ CategoryTheory.Limits.HasLimit F","decl":"instance [hF : IsEventuallyConstant F] [IsCofiltered J] : HasLimit F := by\n  obtain ⟨j, h⟩ := hF.exists_isEventuallyConstantTo\n  exact h.hasLimit\n\n"}
{"name":"CategoryTheory.IsFiltered.IsEventuallyConstant.exists_isEventuallyConstantFrom","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} J\ninst✝ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\nself : CategoryTheory.IsFiltered.IsEventuallyConstant F\n⊢ Exists fun i => F.IsEventuallyConstantFrom i","decl":"/-- A functor `F : J ⥤ C` from a filtered category is eventually constant if there\nexists `i : J`, such that for any `f : i ⟶ j`, the induced map `F.map f` is an isomorphism. -/\nclass IsEventuallyConstant : Prop where\n  exists_isEventuallyConstantFrom : ∃ (i : J), F.IsEventuallyConstantFrom i\n\n"}
{"name":"CategoryTheory.IsFiltered.instHasColimitOfIsEventuallyConstant","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\nhF : CategoryTheory.IsFiltered.IsEventuallyConstant F\ninst✝ : CategoryTheory.IsFiltered J\n⊢ CategoryTheory.Limits.HasColimit F","decl":"instance [hF : IsEventuallyConstant F] [IsFiltered J] : HasColimit F := by\n  obtain ⟨j, h⟩ := hF.exists_isEventuallyConstantFrom\n  exact h.hasColimit\n\n"}
