{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.isIso_map","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh : F.IsEventuallyConstantTo i‚ÇÄ\ni j : J\nœÜ : Quiver.Hom i j\nœÄ : Quiver.Hom j i‚ÇÄ\n‚ä¢ CategoryTheory.IsIso (F.map œÜ)","decl":"lemma isIso_map {i j : J} (œÜ : i ‚ü∂ j) (œÄ : j ‚ü∂ i‚ÇÄ) : IsIso (F.map œÜ) := by\n  have := h œÄ\n  have := h (œÜ ‚â´ œÄ)\n  exact IsIso.of_isIso_fac_right (F.map_comp œÜ œÄ).symm\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.precomp","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh : F.IsEventuallyConstantTo i‚ÇÄ\nj : J\nf : Quiver.Hom j i‚ÇÄ\n‚ä¢ F.IsEventuallyConstantTo j","decl":"lemma precomp {j : J} (f : j ‚ü∂ i‚ÇÄ) : F.IsEventuallyConstantTo j :=\n  fun _ œÜ ‚Ü¶ h.isIso_map œÜ f\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.isoMap_hom","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh : F.IsEventuallyConstantTo i‚ÇÄ\ni j : J\nœÜ : Quiver.Hom i j\nhœÜ : Nonempty (Quiver.Hom j i‚ÇÄ)\n‚ä¢ Eq (h.isoMap œÜ hœÜ).hom (F.map œÜ)","decl":"/-- The isomorphism `F.obj i ‚âÖ F.obj j` induced by `œÜ : i ‚ü∂ j`,\nwhen `h : F.IsEventuallyConstantTo i‚ÇÄ` and there exists a map `j ‚ü∂ i‚ÇÄ`. -/\n@[simps! hom]\nnoncomputable def isoMap : F.obj i ‚âÖ F.obj j :=\n  have := h.isIso_map œÜ hœÜ.some\n  asIso (F.map œÜ)\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.isoMap_hom_inv_id","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} J\ninst‚úù : CategoryTheory.Category.{u_3, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh : F.IsEventuallyConstantTo i‚ÇÄ\ni j : J\nœÜ : Quiver.Hom i j\nhœÜ : Nonempty (Quiver.Hom j i‚ÇÄ)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map œÜ) (h.isoMap œÜ hœÜ).inv) (CategoryTheory.CategoryStruct.id (F.obj i))","decl":"@[reassoc (attr := simp)]\nlemma isoMap_hom_inv_id : F.map œÜ ‚â´ (h.isoMap œÜ hœÜ).inv = ùüô _ :=\n  (h.isoMap œÜ hœÜ).hom_inv_id\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.isoMap_hom_inv_id_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} J\ninst‚úù : CategoryTheory.Category.{u_3, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh‚úù : F.IsEventuallyConstantTo i‚ÇÄ\ni j : J\nœÜ : Quiver.Hom i j\nhœÜ : Nonempty (Quiver.Hom j i‚ÇÄ)\nZ : C\nh : Quiver.Hom (F.obj i) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map œÜ) (CategoryTheory.CategoryStruct.comp (h‚úù.isoMap œÜ hœÜ).inv h)) h","decl":"@[reassoc (attr := simp)]\nlemma isoMap_hom_inv_id : F.map œÜ ‚â´ (h.isoMap œÜ hœÜ).inv = ùüô _ :=\n  (h.isoMap œÜ hœÜ).hom_inv_id\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.isoMap_inv_hom_id_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} J\ninst‚úù : CategoryTheory.Category.{u_3, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh‚úù : F.IsEventuallyConstantTo i‚ÇÄ\ni j : J\nœÜ : Quiver.Hom i j\nhœÜ : Nonempty (Quiver.Hom j i‚ÇÄ)\nZ : C\nh : Quiver.Hom (F.obj j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (h‚úù.isoMap œÜ hœÜ).inv (CategoryTheory.CategoryStruct.comp (F.map œÜ) h)) h","decl":"@[reassoc (attr := simp)]\nlemma isoMap_inv_hom_id : (h.isoMap œÜ hœÜ).inv ‚â´ F.map œÜ = ùüô _ :=\n  (h.isoMap œÜ hœÜ).inv_hom_id\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.isoMap_inv_hom_id","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} J\ninst‚úù : CategoryTheory.Category.{u_3, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh : F.IsEventuallyConstantTo i‚ÇÄ\ni j : J\nœÜ : Quiver.Hom i j\nhœÜ : Nonempty (Quiver.Hom j i‚ÇÄ)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (h.isoMap œÜ hœÜ).inv (F.map œÜ)) (CategoryTheory.CategoryStruct.id (F.obj j))","decl":"@[reassoc (attr := simp)]\nlemma isoMap_inv_hom_id : (h.isoMap œÜ hœÜ).inv ‚â´ F.map œÜ = ùüô _ :=\n  (h.isoMap œÜ hœÜ).inv_hom_id\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.coneœÄApp_eq","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh : F.IsEventuallyConstantTo i‚ÇÄ\ninst‚úù : CategoryTheory.IsCofiltered J\nj j' : J\nŒ± : Quiver.Hom j' i‚ÇÄ\nŒ≤ : Quiver.Hom j' j\n‚ä¢ Eq (h.coneœÄApp j) (CategoryTheory.CategoryStruct.comp (h.isoMap Œ± ‚ãØ).inv (F.map Œ≤))","decl":"lemma coneœÄApp_eq (j j' : J) (Œ± : j' ‚ü∂ i‚ÇÄ) (Œ≤ : j' ‚ü∂ j) :\n    h.coneœÄApp j = (h.isoMap Œ± ‚ü®ùüô _‚ü©).inv ‚â´ F.map Œ≤ := by\n  obtain ‚ü®s, Œ≥, Œ¥, h‚ÇÅ, h‚ÇÇ‚ü© := IsCofiltered.bowtie\n    (IsCofiltered.minToRight i‚ÇÄ j) Œ≤ (IsCofiltered.minToLeft i‚ÇÄ j) Œ±\n  dsimp [coneœÄApp]\n  rw [‚Üê cancel_epi ((h.isoMap Œ± ‚ü®ùüô _‚ü©).hom), isoMap_hom, isoMap_hom_inv_id_assoc,\n    ‚Üê cancel_epi (h.isoMap Œ¥ ‚ü®Œ±‚ü©).hom, isoMap_hom,\n    ‚Üê F.map_comp Œ¥ Œ≤, ‚Üê h‚ÇÅ, F.map_comp, ‚Üê F.map_comp_assoc, ‚Üê h‚ÇÇ, F.map_comp_assoc,\n    isoMap_hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.coneœÄApp_eq_id","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} J\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh : F.IsEventuallyConstantTo i‚ÇÄ\ninst‚úù : CategoryTheory.IsCofiltered J\n‚ä¢ Eq (h.coneœÄApp i‚ÇÄ) (CategoryTheory.CategoryStruct.id (F.obj i‚ÇÄ))","decl":"@[simp]\nlemma coneœÄApp_eq_id : h.coneœÄApp i‚ÇÄ = ùüô _ := by\n  rw [h.coneœÄApp_eq i‚ÇÄ i‚ÇÄ (ùüô _) (ùüô _), h.isoMap_inv_hom_id]\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.cone_pt","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh : F.IsEventuallyConstantTo i‚ÇÄ\ninst‚úù : CategoryTheory.IsCofiltered J\n‚ä¢ Eq h.cone.pt (F.obj i‚ÇÄ)","decl":"/-- Given `h : F.IsEventuallyConstantTo i‚ÇÄ`, this is the (limit) cone for `F` whose\npoint is `F.obj i‚ÇÄ`. -/\n@[simps]\nnoncomputable def cone : Cone F where\n  pt := F.obj i‚ÇÄ\n  œÄ :=\n    { app := h.coneœÄApp\n      naturality := fun j j' œÜ ‚Ü¶ by\n        dsimp\n        rw [id_comp]\n        let i := IsCofiltered.min i‚ÇÄ j\n        let Œ± : i ‚ü∂ i‚ÇÄ := IsCofiltered.minToLeft _ _\n        let Œ≤ : i ‚ü∂ j := IsCofiltered.minToRight _ _\n        rw [h.coneœÄApp_eq j _ Œ± Œ≤, assoc, h.coneœÄApp_eq j' _ Œ± (Œ≤ ‚â´ œÜ), map_comp] }\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.cone_œÄ_app","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh : F.IsEventuallyConstantTo i‚ÇÄ\ninst‚úù : CategoryTheory.IsCofiltered J\nj : J\n‚ä¢ Eq (h.cone.œÄ.app j) (h.coneœÄApp j)","decl":"/-- Given `h : F.IsEventuallyConstantTo i‚ÇÄ`, this is the (limit) cone for `F` whose\npoint is `F.obj i‚ÇÄ`. -/\n@[simps]\nnoncomputable def cone : Cone F where\n  pt := F.obj i‚ÇÄ\n  œÄ :=\n    { app := h.coneœÄApp\n      naturality := fun j j' œÜ ‚Ü¶ by\n        dsimp\n        rw [id_comp]\n        let i := IsCofiltered.min i‚ÇÄ j\n        let Œ± : i ‚ü∂ i‚ÇÄ := IsCofiltered.minToLeft _ _\n        let Œ≤ : i ‚ü∂ j := IsCofiltered.minToRight _ _\n        rw [h.coneœÄApp_eq j _ Œ± Œ≤, assoc, h.coneœÄApp_eq j' _ Œ± (Œ≤ ‚â´ œÜ), map_comp] }\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.hasLimit","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh : F.IsEventuallyConstantTo i‚ÇÄ\ninst‚úù : CategoryTheory.IsCofiltered J\n‚ä¢ CategoryTheory.Limits.HasLimit F","decl":"lemma hasLimit : HasLimit F := ‚ü®_, h.isLimitCone‚ü©\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.isIso_œÄ_of_isLimit","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh : F.IsEventuallyConstantTo i‚ÇÄ\ninst‚úù : CategoryTheory.IsCofiltered J\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsLimit c\n‚ä¢ CategoryTheory.IsIso (c.œÄ.app i‚ÇÄ)","decl":"lemma isIso_œÄ_of_isLimit {c : Cone F} (hc : IsLimit c) :\n    IsIso (c.œÄ.app i‚ÇÄ) := by\n  simp only [‚Üê IsLimit.conePointUniqueUpToIso_hom_comp hc h.isLimitCone i‚ÇÄ,\n    cone_œÄ_app, coneœÄApp_eq_id, cone_pt, comp_id]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantTo.isIso_œÄ_of_isLimit'","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh : F.IsEventuallyConstantTo i‚ÇÄ\ninst‚úù : CategoryTheory.IsCofiltered J\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsLimit c\nj : J\nœÄ : Quiver.Hom j i‚ÇÄ\n‚ä¢ CategoryTheory.IsIso (c.œÄ.app j)","decl":"/-- More general version of `isIso_œÄ_of_isLimit`. -/\nlemma isIso_œÄ_of_isLimit' {c : Cone F} (hc : IsLimit c) (j : J) (œÄ : j ‚ü∂ i‚ÇÄ) :\n    IsIso (c.œÄ.app j) :=\n  (h.precomp œÄ).isIso_œÄ_of_isLimit hc\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.isIso_map","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh : F.IsEventuallyConstantFrom i‚ÇÄ\ni j : J\nœÜ : Quiver.Hom i j\nŒπ : Quiver.Hom i‚ÇÄ i\n‚ä¢ CategoryTheory.IsIso (F.map œÜ)","decl":"lemma isIso_map {i j : J} (œÜ : i ‚ü∂ j) (Œπ : i‚ÇÄ ‚ü∂ i) : IsIso (F.map œÜ) := by\n  have := h Œπ\n  have := h (Œπ ‚â´ œÜ)\n  exact IsIso.of_isIso_fac_left (F.map_comp Œπ œÜ).symm\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.postcomp","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh : F.IsEventuallyConstantFrom i‚ÇÄ\nj : J\nf : Quiver.Hom i‚ÇÄ j\n‚ä¢ F.IsEventuallyConstantFrom j","decl":"lemma postcomp {j : J} (f : i‚ÇÄ ‚ü∂ j) : F.IsEventuallyConstantFrom j :=\n  fun _ œÜ ‚Ü¶ h.isIso_map œÜ f\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.isoMap_hom","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh : F.IsEventuallyConstantFrom i‚ÇÄ\ni j : J\nœÜ : Quiver.Hom i j\nhœÜ : Nonempty (Quiver.Hom i‚ÇÄ i)\n‚ä¢ Eq (h.isoMap œÜ hœÜ).hom (F.map œÜ)","decl":"/-- The isomorphism `F.obj i ‚âÖ F.obj j` induced by `œÜ : i ‚ü∂ j`,\nwhen `h : F.IsEventuallyConstantFrom i‚ÇÄ` and there exists a map `i‚ÇÄ ‚ü∂ i`. -/\n@[simps! hom]\nnoncomputable def isoMap : F.obj i ‚âÖ F.obj j :=\n  have := h.isIso_map œÜ hœÜ.some\n  asIso (F.map œÜ)\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.isoMap_hom_inv_id_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} J\ninst‚úù : CategoryTheory.Category.{u_3, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh‚úù : F.IsEventuallyConstantFrom i‚ÇÄ\ni j : J\nœÜ : Quiver.Hom i j\nhœÜ : Nonempty (Quiver.Hom i‚ÇÄ i)\nZ : C\nh : Quiver.Hom (F.obj i) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map œÜ) (CategoryTheory.CategoryStruct.comp (h‚úù.isoMap œÜ hœÜ).inv h)) h","decl":"@[reassoc (attr := simp)]\nlemma isoMap_hom_inv_id : F.map œÜ ‚â´ (h.isoMap œÜ hœÜ).inv = ùüô _ :=\n  (h.isoMap œÜ hœÜ).hom_inv_id\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.isoMap_hom_inv_id","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} J\ninst‚úù : CategoryTheory.Category.{u_3, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh : F.IsEventuallyConstantFrom i‚ÇÄ\ni j : J\nœÜ : Quiver.Hom i j\nhœÜ : Nonempty (Quiver.Hom i‚ÇÄ i)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map œÜ) (h.isoMap œÜ hœÜ).inv) (CategoryTheory.CategoryStruct.id (F.obj i))","decl":"@[reassoc (attr := simp)]\nlemma isoMap_hom_inv_id : F.map œÜ ‚â´ (h.isoMap œÜ hœÜ).inv = ùüô _ :=\n  (h.isoMap œÜ hœÜ).hom_inv_id\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.isoMap_inv_hom_id","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} J\ninst‚úù : CategoryTheory.Category.{u_3, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh : F.IsEventuallyConstantFrom i‚ÇÄ\ni j : J\nœÜ : Quiver.Hom i j\nhœÜ : Nonempty (Quiver.Hom i‚ÇÄ i)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (h.isoMap œÜ hœÜ).inv (F.map œÜ)) (CategoryTheory.CategoryStruct.id (F.obj j))","decl":"@[reassoc (attr := simp)]\nlemma isoMap_inv_hom_id : (h.isoMap œÜ hœÜ).inv ‚â´ F.map œÜ = ùüô _ :=\n  (h.isoMap œÜ hœÜ).inv_hom_id\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.isoMap_inv_hom_id_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} J\ninst‚úù : CategoryTheory.Category.{u_3, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh‚úù : F.IsEventuallyConstantFrom i‚ÇÄ\ni j : J\nœÜ : Quiver.Hom i j\nhœÜ : Nonempty (Quiver.Hom i‚ÇÄ i)\nZ : C\nh : Quiver.Hom (F.obj j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (h‚úù.isoMap œÜ hœÜ).inv (CategoryTheory.CategoryStruct.comp (F.map œÜ) h)) h","decl":"@[reassoc (attr := simp)]\nlemma isoMap_inv_hom_id : (h.isoMap œÜ hœÜ).inv ‚â´ F.map œÜ = ùüô _ :=\n  (h.isoMap œÜ hœÜ).inv_hom_id\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.coconeŒπApp_eq","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh : F.IsEventuallyConstantFrom i‚ÇÄ\ninst‚úù : CategoryTheory.IsFiltered J\nj j' : J\nŒ± : Quiver.Hom j j'\nŒ≤ : Quiver.Hom i‚ÇÄ j'\n‚ä¢ Eq (h.coconeŒπApp j) (CategoryTheory.CategoryStruct.comp (F.map Œ±) (h.isoMap Œ≤ ‚ãØ).inv)","decl":"lemma coconeŒπApp_eq (j j' : J) (Œ± : j ‚ü∂ j') (Œ≤ : i‚ÇÄ ‚ü∂ j') :\n    h.coconeŒπApp j = F.map Œ± ‚â´ (h.isoMap Œ≤ ‚ü®ùüô _‚ü©).inv  := by\n  obtain ‚ü®s, Œ≥, Œ¥, h‚ÇÅ, h‚ÇÇ‚ü© := IsFiltered.bowtie\n    (IsFiltered.leftToMax i‚ÇÄ j) Œ≤ (IsFiltered.rightToMax i‚ÇÄ j) Œ±\n  dsimp [coconeŒπApp]\n  rw [‚Üê cancel_mono ((h.isoMap Œ≤ ‚ü®ùüô _‚ü©).hom), assoc, assoc, isoMap_hom, isoMap_inv_hom_id,\n    comp_id, ‚Üê cancel_mono (h.isoMap Œ¥ ‚ü®Œ≤‚ü©).hom, isoMap_hom, assoc, assoc, ‚Üê F.map_comp Œ± Œ¥,\n    ‚Üê h‚ÇÇ, F.map_comp, ‚Üê F.map_comp Œ≤ Œ¥, ‚Üê h‚ÇÅ, F.map_comp, isoMap_inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.coconeŒπApp_eq_id","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} J\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh : F.IsEventuallyConstantFrom i‚ÇÄ\ninst‚úù : CategoryTheory.IsFiltered J\n‚ä¢ Eq (h.coconeŒπApp i‚ÇÄ) (CategoryTheory.CategoryStruct.id (F.obj i‚ÇÄ))","decl":"@[simp]\nlemma coconeŒπApp_eq_id : h.coconeŒπApp i‚ÇÄ = ùüô _ := by\n  rw [h.coconeŒπApp_eq i‚ÇÄ i‚ÇÄ (ùüô _) (ùüô _), h.isoMap_hom_inv_id]\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.cocone_Œπ_app","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh : F.IsEventuallyConstantFrom i‚ÇÄ\ninst‚úù : CategoryTheory.IsFiltered J\nj : J\n‚ä¢ Eq (h.cocone.Œπ.app j) (h.coconeŒπApp j)","decl":"/-- Given `h : F.IsEventuallyConstantFrom i‚ÇÄ`, this is the (limit) cocone for `F` whose\npoint is `F.obj i‚ÇÄ`. -/\n@[simps]\nnoncomputable def cocone : Cocone F where\n  pt := F.obj i‚ÇÄ\n  Œπ :=\n    { app := h.coconeŒπApp\n      naturality := fun j j' œÜ ‚Ü¶ by\n        dsimp\n        rw [comp_id]\n        let i := IsFiltered.max i‚ÇÄ j'\n        let Œ± : i‚ÇÄ ‚ü∂ i := IsFiltered.leftToMax _ _\n        let Œ≤ : j' ‚ü∂ i := IsFiltered.rightToMax _ _\n        rw [h.coconeŒπApp_eq j' _ Œ≤ Œ±, h.coconeŒπApp_eq j _ (œÜ ‚â´ Œ≤) Œ±, map_comp, assoc] }\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.cocone_pt","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh : F.IsEventuallyConstantFrom i‚ÇÄ\ninst‚úù : CategoryTheory.IsFiltered J\n‚ä¢ Eq h.cocone.pt (F.obj i‚ÇÄ)","decl":"/-- Given `h : F.IsEventuallyConstantFrom i‚ÇÄ`, this is the (limit) cocone for `F` whose\npoint is `F.obj i‚ÇÄ`. -/\n@[simps]\nnoncomputable def cocone : Cocone F where\n  pt := F.obj i‚ÇÄ\n  Œπ :=\n    { app := h.coconeŒπApp\n      naturality := fun j j' œÜ ‚Ü¶ by\n        dsimp\n        rw [comp_id]\n        let i := IsFiltered.max i‚ÇÄ j'\n        let Œ± : i‚ÇÄ ‚ü∂ i := IsFiltered.leftToMax _ _\n        let Œ≤ : j' ‚ü∂ i := IsFiltered.rightToMax _ _\n        rw [h.coconeŒπApp_eq j' _ Œ≤ Œ±, h.coconeŒπApp_eq j _ (œÜ ‚â´ Œ≤) Œ±, map_comp, assoc] }\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.hasColimit","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh : F.IsEventuallyConstantFrom i‚ÇÄ\ninst‚úù : CategoryTheory.IsFiltered J\n‚ä¢ CategoryTheory.Limits.HasColimit F","decl":"lemma hasColimit : HasColimit F := ‚ü®_, h.isColimitCocone‚ü©\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.isIso_Œπ_of_isColimit","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh : F.IsEventuallyConstantFrom i‚ÇÄ\ninst‚úù : CategoryTheory.IsFiltered J\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ CategoryTheory.IsIso (c.Œπ.app i‚ÇÄ)","decl":"lemma isIso_Œπ_of_isColimit {c : Cocone F} (hc : IsColimit c) :\n    IsIso (c.Œπ.app i‚ÇÄ) := by\n  simp only [‚Üê IsColimit.comp_coconePointUniqueUpToIso_inv hc h.isColimitCocone i‚ÇÄ,\n    cocone_Œπ_app, coconeŒπApp_eq_id, id_comp]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Functor.IsEventuallyConstantFrom.isIso_Œπ_of_isColimit'","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\ni‚ÇÄ : J\nh : F.IsEventuallyConstantFrom i‚ÇÄ\ninst‚úù : CategoryTheory.IsFiltered J\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\nj : J\nŒπ : Quiver.Hom i‚ÇÄ j\n‚ä¢ CategoryTheory.IsIso (c.Œπ.app j)","decl":"/-- More general version of `isIso_Œπ_of_isColimit`. -/\nlemma isIso_Œπ_of_isColimit' {c : Cocone F} (hc : IsColimit c) (j : J) (Œπ : i‚ÇÄ ‚ü∂ j) :\n    IsIso (c.Œπ.app j) :=\n  (h.postcomp Œπ).isIso_Œπ_of_isColimit hc\n\n"}
{"name":"CategoryTheory.IsCofiltered.IsEventuallyConstant.exists_isEventuallyConstantTo","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\nself : CategoryTheory.IsCofiltered.IsEventuallyConstant F\n‚ä¢ Exists fun j => F.IsEventuallyConstantTo j","decl":"/-- A functor `F : J ‚•§ C` from a cofiltered category is eventually constant if there\nexists `j : J`, such that for any `f : i ‚ü∂ j`, the induced map `F.map f` is an isomorphism. -/\nclass IsEventuallyConstant : Prop where\n  exists_isEventuallyConstantTo : ‚àÉ (j : J), F.IsEventuallyConstantTo j\n\n"}
{"name":"CategoryTheory.IsCofiltered.instHasLimitOfIsEventuallyConstant","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\nhF : CategoryTheory.IsCofiltered.IsEventuallyConstant F\ninst‚úù : CategoryTheory.IsCofiltered J\n‚ä¢ CategoryTheory.Limits.HasLimit F","decl":"instance [hF : IsEventuallyConstant F] [IsCofiltered J] : HasLimit F := by\n  obtain ‚ü®j, h‚ü© := hF.exists_isEventuallyConstantTo\n  exact h.hasLimit\n\n"}
{"name":"CategoryTheory.IsFiltered.IsEventuallyConstant.exists_isEventuallyConstantFrom","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\nself : CategoryTheory.IsFiltered.IsEventuallyConstant F\n‚ä¢ Exists fun i => F.IsEventuallyConstantFrom i","decl":"/-- A functor `F : J ‚•§ C` from a filtered category is eventually constant if there\nexists `i : J`, such that for any `f : i ‚ü∂ j`, the induced map `F.map f` is an isomorphism. -/\nclass IsEventuallyConstant : Prop where\n  exists_isEventuallyConstantFrom : ‚àÉ (i : J), F.IsEventuallyConstantFrom i\n\n"}
{"name":"CategoryTheory.IsFiltered.instHasColimitOfIsEventuallyConstant","module":"Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\nhF : CategoryTheory.IsFiltered.IsEventuallyConstant F\ninst‚úù : CategoryTheory.IsFiltered J\n‚ä¢ CategoryTheory.Limits.HasColimit F","decl":"instance [hF : IsEventuallyConstant F] [IsFiltered J] : HasColimit F := by\n  obtain ‚ü®j, h‚ü© := hF.exists_isEventuallyConstantFrom\n  exact h.hasColimit\n\n"}
