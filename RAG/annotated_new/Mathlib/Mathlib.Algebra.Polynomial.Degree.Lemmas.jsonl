{"name":"Polynomial.natDegree_comp_le","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\n⊢ LE.le (p.comp q).natDegree (HMul.hMul p.natDegree q.natDegree)","decl":"theorem natDegree_comp_le : natDegree (p.comp q) ≤ natDegree p * natDegree q :=\n  letI := Classical.decEq R\n  if h0 : p.comp q = 0 then by rw [h0, natDegree_zero]; exact Nat.zero_le _\n  else\n    WithBot.coe_le_coe.1 <|\n      calc\n        ↑(natDegree (p.comp q)) = degree (p.comp q) := (degree_eq_natDegree h0).symm\n        _ = _ := congr_arg degree comp_eq_sum_left\n        _ ≤ _ := degree_sum_le _ _\n        _ ≤ _ :=\n          Finset.sup_le fun n hn =>\n            calc\n              degree (C (coeff p n) * q ^ n) ≤ degree (C (coeff p n)) + degree (q ^ n) :=\n                degree_mul_le _ _\n              _ ≤ natDegree (C (coeff p n)) + n • degree q :=\n                (add_le_add degree_le_natDegree (degree_pow_le _ _))\n              _ ≤ natDegree (C (coeff p n)) + n • ↑(natDegree q) :=\n                (add_le_add_left (nsmul_le_nsmul_right (@degree_le_natDegree _ _ q) n) _)\n              _ = (n * natDegree q : ℕ) := by\n                rw [natDegree_C, Nat.cast_zero, zero_add, nsmul_eq_mul]\n                simp\n              _ ≤ (natDegree p * natDegree q : ℕ) :=\n                WithBot.coe_le_coe.2 <|\n                  mul_le_mul_of_nonneg_right (le_natDegree_of_ne_zero (mem_support_iff.1 hn))\n                    (Nat.zero_le _)\n\n"}
{"name":"Polynomial.natDegree_comp_eq_of_mul_ne_zero","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\nh : Ne (HMul.hMul p.leadingCoeff (HPow.hPow q.leadingCoeff p.natDegree)) 0\n⊢ Eq (p.comp q).natDegree (HMul.hMul p.natDegree q.natDegree)","decl":"theorem natDegree_comp_eq_of_mul_ne_zero (h : p.leadingCoeff * q.leadingCoeff ^ p.natDegree ≠ 0) :\n    natDegree (p.comp q) = natDegree p * natDegree q := by\n  by_cases hq : natDegree q = 0\n  · exact le_antisymm natDegree_comp_le (by simp [hq])\n  apply natDegree_eq_of_le_of_coeff_ne_zero natDegree_comp_le\n  rwa [coeff_comp_degree_mul_degree hq]\n\n"}
{"name":"Polynomial.degree_pos_of_root","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\na : R\ninst✝ : Semiring R\np : Polynomial R\nhp : Ne p 0\nh : p.IsRoot a\n⊢ LT.lt 0 p.degree","decl":"theorem degree_pos_of_root {p : R[X]} (hp : p ≠ 0) (h : IsRoot p a) : 0 < degree p :=\n  lt_of_not_ge fun hlt => by\n    have := eq_C_of_degree_le_zero hlt\n    rw [IsRoot, this, eval_C] at h\n    simp only [h, RingHom.map_zero] at this\n    exact hp this\n\n"}
{"name":"Polynomial.natDegree_le_iff_coeff_eq_zero","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\nn : Nat\ninst✝ : Semiring R\np : Polynomial R\n⊢ Iff (LE.le p.natDegree n) (∀ (N : Nat), LT.lt n N → Eq (p.coeff N) 0)","decl":"theorem natDegree_le_iff_coeff_eq_zero : p.natDegree ≤ n ↔ ∀ N : ℕ, n < N → p.coeff N = 0 := by\n  simp_rw [natDegree_le_iff_degree_le, degree_le_iff_coeff_zero, Nat.cast_lt]\n\n"}
{"name":"Polynomial.natDegree_add_le_iff_left","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\np q : Polynomial R\nqn : LE.le q.natDegree n\n⊢ Iff (LE.le (HAdd.hAdd p q).natDegree n) (LE.le p.natDegree n)","decl":"theorem natDegree_add_le_iff_left {n : ℕ} (p q : R[X]) (qn : q.natDegree ≤ n) :\n    (p + q).natDegree ≤ n ↔ p.natDegree ≤ n := by\n  refine ⟨fun h => ?_, fun h => natDegree_add_le_of_degree_le h qn⟩\n  refine natDegree_le_iff_coeff_eq_zero.mpr fun m hm => ?_\n  convert natDegree_le_iff_coeff_eq_zero.mp h m hm using 1\n  rw [coeff_add, natDegree_le_iff_coeff_eq_zero.mp qn _ hm, add_zero]\n\n"}
{"name":"Polynomial.natDegree_add_le_iff_right","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\np q : Polynomial R\npn : LE.le p.natDegree n\n⊢ Iff (LE.le (HAdd.hAdd p q).natDegree n) (LE.le q.natDegree n)","decl":"theorem natDegree_add_le_iff_right {n : ℕ} (p q : R[X]) (pn : p.natDegree ≤ n) :\n    (p + q).natDegree ≤ n ↔ q.natDegree ≤ n := by\n  rw [add_comm]\n  exact natDegree_add_le_iff_left _ _ pn\n\n-- TODO: Do we really want the following two lemmas? They are straightforward consequences of a\n-- more atomic lemma\n"}
{"name":"Polynomial.natDegree_C_mul_le","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\ninst✝ : Semiring R\na : R\nf : Polynomial R\n⊢ LE.le (HMul.hMul (Polynomial.C a) f).natDegree f.natDegree","decl":"theorem natDegree_C_mul_le (a : R) (f : R[X]) : (C a * f).natDegree ≤ f.natDegree := by\n  simpa using natDegree_mul_le (p := C a)\n\n"}
{"name":"Polynomial.natDegree_mul_C_le","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\ninst✝ : Semiring R\nf : Polynomial R\na : R\n⊢ LE.le (HMul.hMul f (Polynomial.C a)).natDegree f.natDegree","decl":"theorem natDegree_mul_C_le (f : R[X]) (a : R) : (f * C a).natDegree ≤ f.natDegree := by\n  simpa using natDegree_mul_le (q := C a)\n\n"}
{"name":"Polynomial.eq_natDegree_of_le_mem_support","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\nn : Nat\ninst✝ : Semiring R\np : Polynomial R\npn : LE.le p.natDegree n\nns : Membership.mem p.support n\n⊢ Eq p.natDegree n","decl":"theorem eq_natDegree_of_le_mem_support (pn : p.natDegree ≤ n) (ns : n ∈ p.support) :\n    p.natDegree = n :=\n  le_antisymm pn (le_natDegree_of_mem_supp _ ns)\n\n"}
{"name":"Polynomial.natDegree_C_mul_eq_of_mul_eq_one","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\na : R\ninst✝ : Semiring R\np : Polynomial R\nai : R\nau : Eq (HMul.hMul ai a) 1\n⊢ Eq (HMul.hMul (Polynomial.C a) p).natDegree p.natDegree","decl":"theorem natDegree_C_mul_eq_of_mul_eq_one {ai : R} (au : ai * a = 1) :\n    (C a * p).natDegree = p.natDegree :=\n  le_antisymm (natDegree_C_mul_le a p)\n    (calc\n      p.natDegree = (1 * p).natDegree := by nth_rw 1 [← one_mul p]\n      _ = (C ai * (C a * p)).natDegree := by rw [← C_1, ← au, RingHom.map_mul, ← mul_assoc]\n      _ ≤ (C a * p).natDegree := natDegree_C_mul_le ai (C a * p))\n\n"}
{"name":"Polynomial.natDegree_mul_C_eq_of_mul_eq_one","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\na : R\ninst✝ : Semiring R\np : Polynomial R\nai : R\nau : Eq (HMul.hMul a ai) 1\n⊢ Eq (HMul.hMul p (Polynomial.C a)).natDegree p.natDegree","decl":"theorem natDegree_mul_C_eq_of_mul_eq_one {ai : R} (au : a * ai = 1) :\n    (p * C a).natDegree = p.natDegree :=\n  le_antisymm (natDegree_mul_C_le p a)\n    (calc\n      p.natDegree = (p * 1).natDegree := by nth_rw 1 [← mul_one p]\n      _ = (p * C a * C ai).natDegree := by rw [← C_1, ← au, RingHom.map_mul, ← mul_assoc]\n      _ ≤ (p * C a).natDegree := natDegree_mul_C_le (p * C a) ai)\n\n"}
{"name":"Polynomial.natDegree_mul_C_eq_of_mul_ne_zero","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\na : R\ninst✝ : Semiring R\np : Polynomial R\nh : Ne (HMul.hMul p.leadingCoeff a) 0\n⊢ Eq (HMul.hMul p (Polynomial.C a)).natDegree p.natDegree","decl":"/-- Although not explicitly stated, the assumptions of lemma `nat_degree_mul_C_eq_of_mul_ne_zero`\nforce the polynomial `p` to be non-zero, via `p.leading_coeff ≠ 0`.\n-/\ntheorem natDegree_mul_C_eq_of_mul_ne_zero (h : p.leadingCoeff * a ≠ 0) :\n    (p * C a).natDegree = p.natDegree := by\n  refine eq_natDegree_of_le_mem_support (natDegree_mul_C_le p a) ?_\n  refine mem_support_iff.mpr ?_\n  rwa [coeff_mul_C]\n\n"}
{"name":"Polynomial.natDegree_C_mul_of_mul_ne_zero","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\na : R\ninst✝ : Semiring R\np : Polynomial R\nh : Ne (HMul.hMul a p.leadingCoeff) 0\n⊢ Eq (HMul.hMul (Polynomial.C a) p).natDegree p.natDegree","decl":"/-- Although not explicitly stated, the assumptions of lemma `nat_degree_C_mul_eq_of_mul_ne_zero`\nforce the polynomial `p` to be non-zero, via `p.leading_coeff ≠ 0`.\n-/\ntheorem natDegree_C_mul_of_mul_ne_zero (h : a * p.leadingCoeff ≠ 0) :\n    (C a * p).natDegree = p.natDegree := by\n  refine eq_natDegree_of_le_mem_support (natDegree_C_mul_le a p) ?_\n  refine mem_support_iff.mpr ?_\n  rwa [coeff_C_mul]\n\n"}
{"name":"Polynomial.natDegree_C_mul_eq_of_mul_ne_zero","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\na : R\ninst✝ : Semiring R\np : Polynomial R\nh : Ne (HMul.hMul a p.leadingCoeff) 0\n⊢ Eq (HMul.hMul (Polynomial.C a) p).natDegree p.natDegree","decl":"@[deprecated (since := \"2025-01-03\")]\nalias natDegree_C_mul_eq_of_mul_ne_zero := natDegree_C_mul_of_mul_ne_zero\n\n"}
{"name":"Polynomial.degree_C_mul_of_mul_ne_zero","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\na : R\ninst✝ : Semiring R\np : Polynomial R\nh : Ne (HMul.hMul a p.leadingCoeff) 0\n⊢ Eq (HMul.hMul (Polynomial.C a) p).degree p.degree","decl":"lemma degree_C_mul_of_mul_ne_zero (h : a * p.leadingCoeff ≠ 0) : (C a * p).degree = p.degree := by\n  rw [degree_mul' (by simpa)]; simp [left_ne_zero_of_mul h]\n\n"}
{"name":"Polynomial.natDegree_add_coeff_mul","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\ninst✝ : Semiring R\nf g : Polynomial R\n⊢ Eq ((HMul.hMul f g).coeff (HAdd.hAdd f.natDegree g.natDegree)) (HMul.hMul (f.coeff f.natDegree) (g.coeff g.natDegree))","decl":"theorem natDegree_add_coeff_mul (f g : R[X]) :\n    (f * g).coeff (f.natDegree + g.natDegree) = f.coeff f.natDegree * g.coeff g.natDegree := by\n  simp only [coeff_natDegree, coeff_mul_degree_add_degree]\n\n"}
{"name":"Polynomial.natDegree_lt_coeff_mul","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\nm n : Nat\ninst✝ : Semiring R\np q : Polynomial R\nh : LT.lt (HAdd.hAdd p.natDegree q.natDegree) (HAdd.hAdd m n)\n⊢ Eq ((HMul.hMul p q).coeff (HAdd.hAdd m n)) 0","decl":"theorem natDegree_lt_coeff_mul (h : p.natDegree + q.natDegree < m + n) :\n    (p * q).coeff (m + n) = 0 :=\n  coeff_eq_zero_of_natDegree_lt (natDegree_mul_le.trans_lt h)\n\n"}
{"name":"Polynomial.coeff_mul_of_natDegree_le","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\nm n : Nat\ninst✝ : Semiring R\np q : Polynomial R\npm : LE.le p.natDegree m\nqn : LE.le q.natDegree n\n⊢ Eq ((HMul.hMul p q).coeff (HAdd.hAdd m n)) (HMul.hMul (p.coeff m) (q.coeff n))","decl":"theorem coeff_mul_of_natDegree_le (pm : p.natDegree ≤ m) (qn : q.natDegree ≤ n) :\n    (p * q).coeff (m + n) = p.coeff m * q.coeff n := by\n  simp_rw [← Polynomial.toFinsupp_apply, toFinsupp_mul]\n  refine AddMonoidAlgebra.apply_add_of_supDegree_le ?_ Function.injective_id ?_ ?_\n  · simp\n  · rwa [supDegree_eq_natDegree, id_eq]\n  · rwa [supDegree_eq_natDegree, id_eq]\n\n"}
{"name":"Polynomial.coeff_pow_of_natDegree_le","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\nm n : Nat\ninst✝ : Semiring R\np : Polynomial R\npn : LE.le p.natDegree n\n⊢ Eq ((HPow.hPow p m).coeff (HMul.hMul m n)) (HPow.hPow (p.coeff n) m)","decl":"theorem coeff_pow_of_natDegree_le (pn : p.natDegree ≤ n) :\n    (p ^ m).coeff (m * n) = p.coeff n ^ m := by\n  induction' m with m hm\n  · simp\n  · rw [pow_succ, pow_succ, ← hm, Nat.succ_mul, coeff_mul_of_natDegree_le _ pn]\n    refine natDegree_pow_le.trans (le_trans ?_ (le_refl _))\n    exact mul_le_mul_of_nonneg_left pn m.zero_le\n\n"}
{"name":"Polynomial.coeff_pow_eq_ite_of_natDegree_le_of_le","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\nm n : Nat\ninst✝ : Semiring R\np : Polynomial R\no : Nat\npn : LE.le p.natDegree n\nmno : LE.le (HMul.hMul m n) o\n⊢ Eq ((HPow.hPow p m).coeff o) (ite (Eq o (HMul.hMul m n)) (HPow.hPow (p.coeff n) m) 0)","decl":"theorem coeff_pow_eq_ite_of_natDegree_le_of_le {o : ℕ}\n    (pn : natDegree p ≤ n) (mno : m * n ≤ o) :\n    coeff (p ^ m) o = if o = m * n then (coeff p n) ^ m else 0 := by\n  rcases eq_or_ne o (m * n) with rfl | h\n  · simpa only [ite_true] using coeff_pow_of_natDegree_le pn\n  · simpa only [h, ite_false] using coeff_eq_zero_of_natDegree_lt <|\n      lt_of_le_of_lt (natDegree_pow_le_of_le m pn) (lt_of_le_of_ne mno h.symm)\n\n"}
{"name":"Polynomial.coeff_add_eq_left_of_lt","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\nn : Nat\ninst✝ : Semiring R\np q : Polynomial R\nqn : LT.lt q.natDegree n\n⊢ Eq ((HAdd.hAdd p q).coeff n) (p.coeff n)","decl":"theorem coeff_add_eq_left_of_lt (qn : q.natDegree < n) : (p + q).coeff n = p.coeff n :=\n  (coeff_add _ _ _).trans <|\n    (congr_arg _ <| coeff_eq_zero_of_natDegree_lt <| qn).trans <| add_zero _\n\n"}
{"name":"Polynomial.coeff_add_eq_right_of_lt","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\nn : Nat\ninst✝ : Semiring R\np q : Polynomial R\npn : LT.lt p.natDegree n\n⊢ Eq ((HAdd.hAdd p q).coeff n) (q.coeff n)","decl":"theorem coeff_add_eq_right_of_lt (pn : p.natDegree < n) : (p + q).coeff n = q.coeff n := by\n  rw [add_comm]\n  exact coeff_add_eq_left_of_lt pn\n\n"}
{"name":"Polynomial.degree_sum_eq_of_disjoint","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\nS : Type v\ninst✝ : Semiring R\nf : S → Polynomial R\ns : Finset S\nh : (setOf fun i => And (Membership.mem s i) (Ne (f i) 0)).Pairwise (Function.onFun Ne (Function.comp Polynomial.degree f))\n⊢ Eq (s.sum f).degree (s.sup fun i => (f i).degree)","decl":"theorem degree_sum_eq_of_disjoint (f : S → R[X]) (s : Finset S)\n    (h : Set.Pairwise { i | i ∈ s ∧ f i ≠ 0 } (Ne on degree ∘ f)) :\n    degree (s.sum f) = s.sup fun i => degree (f i) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.sum_insert, not_false_iff, Finset.sup_insert]\n    specialize IH (h.mono fun _ => by simp +contextual)\n    rcases lt_trichotomy (degree (f x)) (degree (s.sum f)) with (H | H | H)\n    · rw [← IH, sup_eq_right.mpr H.le, degree_add_eq_right_of_degree_lt H]\n    · rcases s.eq_empty_or_nonempty with (rfl | hs)\n      · simp\n      obtain ⟨y, hy, hy'⟩ := Finset.exists_mem_eq_sup s hs fun i => degree (f i)\n      rw [IH, hy'] at H\n      by_cases hx0 : f x = 0\n      · simp [hx0, IH]\n      have hy0 : f y ≠ 0 := by\n        contrapose! H\n        simpa [H, degree_eq_bot] using hx0\n      refine absurd H (h ?_ ?_ fun H => hx ?_)\n      · simp [hx0]\n      · simp [hy, hy0]\n      · exact H.symm ▸ hy\n    · rw [← IH, sup_eq_left.mpr H.le, degree_add_eq_left_of_degree_lt H]\n\n"}
{"name":"Polynomial.natDegree_sum_eq_of_disjoint","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\nS : Type v\ninst✝ : Semiring R\nf : S → Polynomial R\ns : Finset S\nh : (setOf fun i => And (Membership.mem s i) (Ne (f i) 0)).Pairwise (Function.onFun Ne (Function.comp Polynomial.natDegree f))\n⊢ Eq (s.sum f).natDegree (s.sup fun i => (f i).natDegree)","decl":"theorem natDegree_sum_eq_of_disjoint (f : S → R[X]) (s : Finset S)\n    (h : Set.Pairwise { i | i ∈ s ∧ f i ≠ 0 } (Ne on natDegree ∘ f)) :\n    natDegree (s.sum f) = s.sup fun i => natDegree (f i) := by\n  by_cases H : ∃ x ∈ s, f x ≠ 0\n  · obtain ⟨x, hx, hx'⟩ := H\n    have hs : s.Nonempty := ⟨x, hx⟩\n    refine natDegree_eq_of_degree_eq_some ?_\n    rw [degree_sum_eq_of_disjoint]\n    · rw [← Finset.sup'_eq_sup hs, ← Finset.sup'_eq_sup hs,\n        Nat.cast_withBot, Finset.coe_sup' hs, ←\n        Finset.sup'_eq_sup hs]\n      refine le_antisymm ?_ ?_\n      · rw [Finset.sup'_le_iff]\n        intro b hb\n        by_cases hb' : f b = 0\n        · simpa [hb'] using hs\n        rw [degree_eq_natDegree hb', Nat.cast_withBot]\n        exact Finset.le_sup' (fun i : S => (natDegree (f i) : WithBot ℕ)) hb\n      · rw [Finset.sup'_le_iff]\n        intro b hb\n        simp only [Finset.le_sup'_iff, exists_prop, Function.comp_apply]\n        by_cases hb' : f b = 0\n        · refine ⟨x, hx, ?_⟩\n          contrapose! hx'\n          simpa [← Nat.cast_withBot, hb', degree_eq_bot] using hx'\n        exact ⟨b, hb, (degree_eq_natDegree hb').ge⟩\n    · exact h.imp fun x y hxy hxy' => hxy (natDegree_eq_of_degree_eq hxy')\n  · push_neg at H\n    rw [Finset.sum_eq_zero H, natDegree_zero, eq_comm, show 0 = ⊥ from rfl, Finset.sup_eq_bot_iff]\n    intro x hx\n    simp [H x hx]\n\n"}
{"name":"Polynomial.natDegree_pos_of_eval₂_root","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\np : Polynomial R\nhp : Ne p 0\nf : RingHom R S\nz : S\nhz : Eq (Polynomial.eval₂ f z p) 0\ninj : ∀ (x : R), Eq (f x) 0 → Eq x 0\n⊢ LT.lt 0 p.natDegree","decl":"theorem natDegree_pos_of_eval₂_root {p : R[X]} (hp : p ≠ 0) (f : R →+* S) {z : S}\n    (hz : eval₂ f z p = 0) (inj : ∀ x : R, f x = 0 → x = 0) : 0 < natDegree p :=\n  lt_of_not_ge fun hlt => by\n    have A : p = C (p.coeff 0) := eq_C_of_natDegree_le_zero hlt\n    rw [A, eval₂_C] at hz\n    simp only [inj (p.coeff 0) hz, RingHom.map_zero] at A\n    exact hp A\n\n"}
{"name":"Polynomial.degree_pos_of_eval₂_root","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\np : Polynomial R\nhp : Ne p 0\nf : RingHom R S\nz : S\nhz : Eq (Polynomial.eval₂ f z p) 0\ninj : ∀ (x : R), Eq (f x) 0 → Eq x 0\n⊢ LT.lt 0 p.degree","decl":"theorem degree_pos_of_eval₂_root {p : R[X]} (hp : p ≠ 0) (f : R →+* S) {z : S}\n    (hz : eval₂ f z p = 0) (inj : ∀ x : R, f x = 0 → x = 0) : 0 < degree p :=\n  natDegree_pos_iff_degree_pos.mp (natDegree_pos_of_eval₂_root hp f hz inj)\n\n"}
{"name":"Polynomial.coe_lt_degree","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\n⊢ Iff (LT.lt (↑n) p.degree) (LT.lt n p.natDegree)","decl":"@[simp]\ntheorem coe_lt_degree {p : R[X]} {n : ℕ} : (n : WithBot ℕ) < degree p ↔ n < natDegree p := by\n  by_cases h : p = 0\n  · simp [h]\n  simp [degree_eq_natDegree h, Nat.cast_lt]\n\n"}
{"name":"Polynomial.degree_map_eq_iff","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial R\n⊢ Iff (Eq (Polynomial.map f p).degree p.degree) (Or (Ne (f p.leadingCoeff) 0) (Eq p 0))","decl":"@[simp]\ntheorem degree_map_eq_iff {f : R →+* S} {p : Polynomial R} :\n    degree (map f p) = degree p ↔ f (leadingCoeff p) ≠ 0 ∨ p = 0 := by\n  rcases eq_or_ne p 0 with h|h\n  · simp [h]\n  simp only [h, or_false]\n  refine ⟨fun h2 ↦ ?_, degree_map_eq_of_leadingCoeff_ne_zero f⟩\n  have h3 : natDegree (map f p) = natDegree p := by simp_rw [natDegree, h2]\n  have h4 : map f p ≠ 0 := by\n    rwa [ne_eq, ← degree_eq_bot, h2, degree_eq_bot]\n  rwa [← coeff_natDegree, ← coeff_map, ← h3, coeff_natDegree, ne_eq, leadingCoeff_eq_zero]\n\n"}
{"name":"Polynomial.natDegree_map_eq_iff","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial R\n⊢ Iff (Eq (Polynomial.map f p).natDegree p.natDegree) (Or (Ne (f p.leadingCoeff) 0) (Eq p.natDegree 0))","decl":"@[simp]\ntheorem natDegree_map_eq_iff {f : R →+* S} {p : Polynomial R} :\n    natDegree (map f p) = natDegree p ↔ f (p.leadingCoeff) ≠ 0 ∨ natDegree p = 0 := by\n  rcases eq_or_ne (natDegree p) 0 with h|h\n  · simp_rw [h, ne_eq, or_true, iff_true, ← Nat.le_zero, ← h, natDegree_map_le]\n  have h2 : p ≠ 0 := by rintro rfl; simp at h\n  simp_all [natDegree, WithBot.unbot'_eq_unbot'_iff]\n\n"}
{"name":"Polynomial.natDegree_pos_of_nextCoeff_ne_zero","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nh : Ne p.nextCoeff 0\n⊢ LT.lt 0 p.natDegree","decl":"theorem natDegree_pos_of_nextCoeff_ne_zero (h : p.nextCoeff ≠ 0) : 0 < p.natDegree := by\n  rw [nextCoeff] at h\n  by_cases hpz : p.natDegree = 0\n  · simp_all only [ne_eq, zero_le, ite_true, not_true_eq_false]\n  · apply Nat.zero_lt_of_ne_zero hpz\n\n"}
{"name":"Polynomial.natDegree_sub","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\ninst✝ : Ring R\np q : Polynomial R\n⊢ Eq (HSub.hSub p q).natDegree (HSub.hSub q p).natDegree","decl":"theorem natDegree_sub : (p - q).natDegree = (q - p).natDegree := by rw [← natDegree_neg, neg_sub]\n\n"}
{"name":"Polynomial.natDegree_sub_le_iff_left","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\nn : Nat\ninst✝ : Ring R\np q : Polynomial R\nqn : LE.le q.natDegree n\n⊢ Iff (LE.le (HSub.hSub p q).natDegree n) (LE.le p.natDegree n)","decl":"theorem natDegree_sub_le_iff_left (qn : q.natDegree ≤ n) :\n    (p - q).natDegree ≤ n ↔ p.natDegree ≤ n := by\n  rw [← natDegree_neg] at qn\n  rw [sub_eq_add_neg, natDegree_add_le_iff_left _ _ qn]\n\n"}
{"name":"Polynomial.natDegree_sub_le_iff_right","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\nn : Nat\ninst✝ : Ring R\np q : Polynomial R\npn : LE.le p.natDegree n\n⊢ Iff (LE.le (HSub.hSub p q).natDegree n) (LE.le q.natDegree n)","decl":"theorem natDegree_sub_le_iff_right (pn : p.natDegree ≤ n) :\n    (p - q).natDegree ≤ n ↔ q.natDegree ≤ n := by rwa [natDegree_sub, natDegree_sub_le_iff_left]\n\n"}
{"name":"Polynomial.coeff_sub_eq_left_of_lt","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\nn : Nat\ninst✝ : Ring R\np q : Polynomial R\ndg : LT.lt q.natDegree n\n⊢ Eq ((HSub.hSub p q).coeff n) (p.coeff n)","decl":"theorem coeff_sub_eq_left_of_lt (dg : q.natDegree < n) : (p - q).coeff n = p.coeff n := by\n  rw [← natDegree_neg] at dg\n  rw [sub_eq_add_neg, coeff_add_eq_left_of_lt dg]\n\n"}
{"name":"Polynomial.coeff_sub_eq_neg_right_of_lt","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\nn : Nat\ninst✝ : Ring R\np q : Polynomial R\ndf : LT.lt p.natDegree n\n⊢ Eq ((HSub.hSub p q).coeff n) (Neg.neg (q.coeff n))","decl":"theorem coeff_sub_eq_neg_right_of_lt (df : p.natDegree < n) : (p - q).coeff n = -q.coeff n := by\n  rwa [sub_eq_add_neg, coeff_add_eq_right_of_lt, coeff_neg]\n\n"}
{"name":"Polynomial.nextCoeff_C_mul_X_add_C","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\ninst✝ : Semiring R\na : R\nha : Ne a 0\nc : R\n⊢ Eq (HAdd.hAdd (HMul.hMul (Polynomial.C a) Polynomial.X) (Polynomial.C c)).nextCoeff c","decl":"@[simp]\nlemma nextCoeff_C_mul_X_add_C (ha : a ≠ 0) (c : R) : nextCoeff (C a * X + C c) = c := by\n  rw [nextCoeff_of_natDegree_pos] <;> simp [ha]\n\n"}
{"name":"Polynomial.natDegree_eq_one","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Iff (Eq p.natDegree 1) (Exists fun a => And (Ne a 0) (Exists fun b => Eq (HAdd.hAdd (HMul.hMul (Polynomial.C a) Polynomial.X) (Polynomial.C b)) p))","decl":"lemma natDegree_eq_one : p.natDegree = 1 ↔ ∃ a ≠ 0, ∃ b, C a * X + C b = p := by\n  refine ⟨fun hp ↦ ⟨p.coeff 1, fun h ↦ ?_, p.coeff 0, ?_⟩, ?_⟩\n  · rw [← hp, coeff_natDegree, leadingCoeff_eq_zero] at h\n    aesop\n  · ext n\n    obtain _ | _ | n := n\n    · simp\n    · simp\n    · simp only [coeff_add, coeff_mul_X, coeff_C_succ, add_zero]\n      rw [coeff_eq_zero_of_natDegree_lt]\n      simp [hp]\n  · rintro ⟨a, ha, b, rfl⟩\n    simp [ha]\n\n"}
{"name":"Polynomial.degree_mul_C","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\ninst✝¹ : Semiring R\np : Polynomial R\na : R\ninst✝ : NoZeroDivisors R\na0 : Ne a 0\n⊢ Eq (HMul.hMul p (Polynomial.C a)).degree p.degree","decl":"theorem degree_mul_C (a0 : a ≠ 0) : (p * C a).degree = p.degree := by\n  rw [degree_mul, degree_C a0, add_zero]\n\n"}
{"name":"Polynomial.degree_C_mul","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\ninst✝¹ : Semiring R\np : Polynomial R\na : R\ninst✝ : NoZeroDivisors R\na0 : Ne a 0\n⊢ Eq (HMul.hMul (Polynomial.C a) p).degree p.degree","decl":"theorem degree_C_mul (a0 : a ≠ 0) : (C a * p).degree = p.degree := by\n  rw [degree_mul, degree_C a0, zero_add]\n\n"}
{"name":"Polynomial.natDegree_mul_C","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\ninst✝¹ : Semiring R\np : Polynomial R\na : R\ninst✝ : NoZeroDivisors R\na0 : Ne a 0\n⊢ Eq (HMul.hMul p (Polynomial.C a)).natDegree p.natDegree","decl":"theorem natDegree_mul_C (a0 : a ≠ 0) : (p * C a).natDegree = p.natDegree := by\n  simp only [natDegree, degree_mul_C a0]\n\n"}
{"name":"Polynomial.natDegree_C_mul","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\ninst✝¹ : Semiring R\np : Polynomial R\na : R\ninst✝ : NoZeroDivisors R\na0 : Ne a 0\n⊢ Eq (HMul.hMul (Polynomial.C a) p).natDegree p.natDegree","decl":"theorem natDegree_C_mul (a0 : a ≠ 0) : (C a * p).natDegree = p.natDegree := by\n  simp only [natDegree, degree_C_mul a0]\n\n"}
{"name":"Polynomial.natDegree_comp","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\ninst✝¹ : Semiring R\np q : Polynomial R\ninst✝ : NoZeroDivisors R\n⊢ Eq (p.comp q).natDegree (HMul.hMul p.natDegree q.natDegree)","decl":"theorem natDegree_comp : natDegree (p.comp q) = natDegree p * natDegree q := by\n  by_cases q0 : q.natDegree = 0\n  · rw [degree_le_zero_iff.mp (natDegree_eq_zero_iff_degree_le_zero.mp q0), comp_C, natDegree_C,\n      natDegree_C, mul_zero]\n  · by_cases p0 : p = 0\n    · simp only [p0, zero_comp, natDegree_zero, zero_mul]\n    · simp only [Ne, mul_eq_zero, leadingCoeff_eq_zero, p0, natDegree_comp_eq_of_mul_ne_zero,\n        ne_zero_of_natDegree_gt (Nat.pos_of_ne_zero q0), not_false_eq_true, pow_ne_zero, or_self]\n\n"}
{"name":"Polynomial.natDegree_iterate_comp","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\ninst✝¹ : Semiring R\np q : Polynomial R\ninst✝ : NoZeroDivisors R\nk : Nat\n⊢ Eq (Nat.iterate p.comp k q).natDegree (HMul.hMul (HPow.hPow p.natDegree k) q.natDegree)","decl":"@[simp]\ntheorem natDegree_iterate_comp (k : ℕ) :\n    (p.comp^[k] q).natDegree = p.natDegree ^ k * q.natDegree := by\n  induction k with\n  | zero => simp\n  | succ k IH => rw [Function.iterate_succ_apply', natDegree_comp, IH, pow_succ', mul_assoc]\n\n"}
{"name":"Polynomial.leadingCoeff_comp","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\ninst✝¹ : Semiring R\np q : Polynomial R\ninst✝ : NoZeroDivisors R\nhq : Ne q.natDegree 0\n⊢ Eq (p.comp q).leadingCoeff (HMul.hMul p.leadingCoeff (HPow.hPow q.leadingCoeff p.natDegree))","decl":"theorem leadingCoeff_comp (hq : natDegree q ≠ 0) :\n    leadingCoeff (p.comp q) = leadingCoeff p * leadingCoeff q ^ natDegree p := by\n  rw [← coeff_comp_degree_mul_degree hq, ← natDegree_comp, coeff_natDegree]\n\n"}
{"name":"Polynomial.comp_neg_X_leadingCoeff_eq","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\n⊢ Eq (p.comp (Neg.neg Polynomial.X)).leadingCoeff (HMul.hMul (HPow.hPow (-1) p.natDegree) p.leadingCoeff)","decl":"@[simp] lemma comp_neg_X_leadingCoeff_eq [Ring R] (p : R[X]) :\n    (p.comp (-X)).leadingCoeff = (-1) ^ p.natDegree * p.leadingCoeff := by\n  nontriviality R\n  by_cases h : p = 0\n  · simp [h]\n  rw [Polynomial.leadingCoeff, natDegree_comp_eq_of_mul_ne_zero, coeff_comp_degree_mul_degree] <;>\n  simp [((Commute.neg_one_left _).pow_left _).eq, h]\n\n"}
{"name":"Polynomial.comp_eq_zero_iff","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : NoZeroDivisors R\np q : Polynomial R\n⊢ Iff (Eq (p.comp q) 0) (Or (Eq p 0) (And (Eq (Polynomial.eval (q.coeff 0) p) 0) (Eq q (Polynomial.C (q.coeff 0)))))","decl":"lemma comp_eq_zero_iff [Semiring R] [NoZeroDivisors R] {p q : R[X]} :\n    p.comp q = 0 ↔ p = 0 ∨ p.eval (q.coeff 0) = 0 ∧ q = C (q.coeff 0) := by\n  refine ⟨fun h ↦ ?_, Or.rec (fun h ↦ by simp [h]) fun h ↦ by rw [h.2, comp_C, h.1, C_0]⟩\n  have key : p.natDegree = 0 ∨ q.natDegree = 0 := by\n    rw [← mul_eq_zero, ← natDegree_comp, h, natDegree_zero]\n  obtain key | key := Or.imp eq_C_of_natDegree_eq_zero eq_C_of_natDegree_eq_zero key\n  · rw [key, C_comp] at h\n    exact Or.inl (key.trans h)\n  · rw [key, comp_C, C_eq_zero] at h\n    exact Or.inr ⟨h, key⟩\n\n"}
{"name":"Polynomial.irreducible_mul_leadingCoeff_inv","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\np : Polynomial K\n⊢ Iff (Irreducible (HMul.hMul p (Polynomial.C (Inv.inv p.leadingCoeff)))) (Irreducible p)","decl":"@[simp]\ntheorem irreducible_mul_leadingCoeff_inv {p : K[X]} :\n    Irreducible (p * C (leadingCoeff p)⁻¹) ↔ Irreducible p := by\n  by_cases hp0 : p = 0\n  · simp [hp0]\n  exact irreducible_mul_isUnit\n    (isUnit_C.mpr (IsUnit.mk0 _ (inv_ne_zero (leadingCoeff_ne_zero.mpr hp0))))\n\n"}
{"name":"Polynomial.dvd_mul_leadingCoeff_inv","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\np q : Polynomial K\nhp0 : Ne p 0\n⊢ Iff (Dvd.dvd q (HMul.hMul p (Polynomial.C (Inv.inv p.leadingCoeff)))) (Dvd.dvd q p)","decl":"@[simp] lemma dvd_mul_leadingCoeff_inv {p q : K[X]} (hp0 : p ≠ 0) :\n    q ∣ p * C (leadingCoeff p)⁻¹ ↔ q ∣ p :=\n  IsUnit.dvd_mul_right <| isUnit_C.mpr <| IsUnit.mk0 _ <|\n    inv_ne_zero <| leadingCoeff_ne_zero.mpr hp0\n\n"}
{"name":"Polynomial.monic_mul_leadingCoeff_inv","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\np : Polynomial K\nh : Ne p 0\n⊢ (HMul.hMul p (Polynomial.C (Inv.inv p.leadingCoeff))).Monic","decl":"theorem monic_mul_leadingCoeff_inv {p : K[X]} (h : p ≠ 0) : Monic (p * C (leadingCoeff p)⁻¹) := by\n  rw [Monic, leadingCoeff_mul, leadingCoeff_C,\n    mul_inv_cancel₀ (show leadingCoeff p ≠ 0 from mt leadingCoeff_eq_zero.1 h)]\n\n-- `simp` normal form of `degree_mul_leadingCoeff_inv`\n"}
{"name":"Polynomial.degree_leadingCoeff_inv","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\np : Polynomial K\nhp0 : Ne p 0\n⊢ Eq (Polynomial.C (Inv.inv p.leadingCoeff)).degree 0","decl":"@[simp] lemma degree_leadingCoeff_inv {p : K[X]} (hp0 : p ≠ 0) :\n    degree (C (leadingCoeff p)⁻¹) = 0 :=\n  degree_C (inv_ne_zero <| leadingCoeff_ne_zero.mpr hp0)\n\n"}
{"name":"Polynomial.degree_mul_leadingCoeff_inv","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\np q : Polynomial K\nh : Ne q 0\n⊢ Eq (HMul.hMul p (Polynomial.C (Inv.inv q.leadingCoeff))).degree p.degree","decl":"theorem degree_mul_leadingCoeff_inv (p : K[X]) {q : K[X]} (h : q ≠ 0) :\n    degree (p * C (leadingCoeff q)⁻¹) = degree p := by\n  have h₁ : (leadingCoeff q)⁻¹ ≠ 0 := inv_ne_zero (mt leadingCoeff_eq_zero.1 h)\n  rw [degree_mul_C h₁]\n\n"}
{"name":"Polynomial.natDegree_mul_leadingCoeff_inv","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\np q : Polynomial K\nh : Ne q 0\n⊢ Eq (HMul.hMul p (Polynomial.C (Inv.inv q.leadingCoeff))).natDegree p.natDegree","decl":"theorem natDegree_mul_leadingCoeff_inv (p : K[X]) {q : K[X]} (h : q ≠ 0) :\n    natDegree (p * C (leadingCoeff q)⁻¹) = natDegree p :=\n  natDegree_eq_of_degree_eq (degree_mul_leadingCoeff_inv _ h)\n\n"}
{"name":"Polynomial.degree_mul_leadingCoeff_self_inv","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\np : Polynomial K\n⊢ Eq (HMul.hMul p (Polynomial.C (Inv.inv p.leadingCoeff))).degree p.degree","decl":"theorem degree_mul_leadingCoeff_self_inv (p : K[X]) :\n    degree (p * C (leadingCoeff p)⁻¹) = degree p := by\n  by_cases hp : p = 0\n  · simp [hp]\n  exact degree_mul_leadingCoeff_inv _ hp\n\n"}
{"name":"Polynomial.natDegree_mul_leadingCoeff_self_inv","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\np : Polynomial K\n⊢ Eq (HMul.hMul p (Polynomial.C (Inv.inv p.leadingCoeff))).natDegree p.natDegree","decl":"theorem natDegree_mul_leadingCoeff_self_inv (p : K[X]) :\n    natDegree (p * C (leadingCoeff p)⁻¹) = natDegree p :=\n  natDegree_eq_of_degree_eq (degree_mul_leadingCoeff_self_inv _)\n\n-- `simp` normal form of `degree_mul_leadingCoeff_self_inv`\n"}
{"name":"Polynomial.degree_add_degree_leadingCoeff_inv","module":"Mathlib.Algebra.Polynomial.Degree.Lemmas","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\np : Polynomial K\n⊢ Eq (HAdd.hAdd p.degree (Polynomial.C (Inv.inv p.leadingCoeff)).degree) p.degree","decl":"@[simp] lemma degree_add_degree_leadingCoeff_inv (p : K[X]) :\n    degree p + degree (C (leadingCoeff p)⁻¹) = degree p := by\n  rw [← degree_mul, degree_mul_leadingCoeff_self_inv]\n\n"}
