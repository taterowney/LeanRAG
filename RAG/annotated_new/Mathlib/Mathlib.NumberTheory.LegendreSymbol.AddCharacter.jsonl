{"name":"AddChar.val_mem_rootsOfUnity","module":"Mathlib.NumberTheory.LegendreSymbol.AddCharacter","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nR' : Type v\ninst✝ : CommMonoid R'\nφ : AddChar R R'\na : R\nh : LT.lt 0 (ringChar R)\n⊢ Membership.mem (rootsOfUnity (↑(ringChar R).toPNat') R') ⋯.unit","decl":"/-- The values of an additive character on a ring of positive characteristic are roots of unity. -/\nlemma val_mem_rootsOfUnity (φ : AddChar R R') (a : R) (h : 0 < ringChar R) :\n    (φ.val_isUnit a).unit ∈ rootsOfUnity (ringChar R).toPNat' R' := by\n  simp only [mem_rootsOfUnity', IsUnit.unit_spec, Nat.toPNat'_coe, h, ↓reduceIte,\n    ← map_nsmul_eq_pow, nsmul_eq_mul, CharP.cast_eq_zero, zero_mul, map_zero_eq_one]\n\n"}
{"name":"AddChar.IsPrimitive.compMulHom_of_isPrimitive","module":"Mathlib.NumberTheory.LegendreSymbol.AddCharacter","initialProofState":"R : Type u\ninst✝² : CommRing R\nR' : Type v\ninst✝¹ : CommMonoid R'\nR'' : Type u_1\ninst✝ : CommMonoid R''\nφ : AddChar R R'\nf : MonoidHom R' R''\nhφ : φ.IsPrimitive\nhf : Function.Injective ⇑f\n⊢ (f.compAddChar φ).IsPrimitive","decl":"/-- The composition of a primitive additive character with an injective mooid homomorphism\nis also primitive. -/\nlemma IsPrimitive.compMulHom_of_isPrimitive {R'' : Type*} [CommMonoid R''] {φ : AddChar R R'}\n    {f : R' →* R''} (hφ : φ.IsPrimitive) (hf : Function.Injective f) :\n    (f.compAddChar φ).IsPrimitive := fun a ha ↦ by\n  simpa [DFunLike.ext_iff] using (MonoidHom.compAddChar_injective_right f hf).ne (hφ ha)\n\n"}
{"name":"AddChar.to_mulShift_inj_of_isPrimitive","module":"Mathlib.NumberTheory.LegendreSymbol.AddCharacter","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nR' : Type v\ninst✝ : CommMonoid R'\nψ : AddChar R R'\nhψ : ψ.IsPrimitive\n⊢ Function.Injective ψ.mulShift","decl":"/-- The map associating to `a : R` the multiplicative shift of `ψ` by `a`\nis injective when `ψ` is primitive. -/\ntheorem to_mulShift_inj_of_isPrimitive {ψ : AddChar R R'} (hψ : IsPrimitive ψ) :\n    Function.Injective ψ.mulShift := by\n  intro a b h\n  apply_fun fun x => x * mulShift ψ (-b) at h\n  simp only [mulShift_mul, mulShift_zero, add_neg_cancel, mulShift_apply] at h\n  simpa [← sub_eq_add_neg, sub_eq_zero] using (hψ · h)\n\n-- `AddCommGroup.equiv_direct_sum_zmod_of_fintype`\n-- gives the structure theorem for finite abelian groups.\n-- This could be used to show that the map above is a bijection.\n-- We leave this for a later occasion.\n"}
{"name":"AddChar.IsPrimitive.of_ne_one","module":"Mathlib.NumberTheory.LegendreSymbol.AddCharacter","initialProofState":"R' : Type v\ninst✝¹ : CommMonoid R'\nF : Type u\ninst✝ : Field F\nψ : AddChar F R'\nhψ : Ne ψ 1\n⊢ ψ.IsPrimitive","decl":"/-- When `R` is a field `F`, then a nontrivial additive character is primitive -/\ntheorem IsPrimitive.of_ne_one {F : Type u} [Field F] {ψ : AddChar F R'} (hψ : ψ ≠ 1) :\n    IsPrimitive ψ :=\n  fun a ha h ↦ hψ <| by simpa [mulShift_mulShift, ha] using congr_arg (mulShift · a⁻¹) h\n\n"}
{"name":"AddChar.not_isPrimitive_mulShift","module":"Mathlib.NumberTheory.LegendreSymbol.AddCharacter","initialProofState":"R : Type u\ninst✝² : CommRing R\nR' : Type v\ninst✝¹ : CommMonoid R'\ninst✝ : Finite R\ne : AddChar R R'\nr : R\nhr : Not (IsUnit r)\n⊢ Not (e.mulShift r).IsPrimitive","decl":"/-- If `r` is not a unit, then `e.mulShift r` is not primitive. -/\nlemma not_isPrimitive_mulShift [Finite R] (e : AddChar R R') {r : R}\n    (hr : ¬ IsUnit r) : ¬ IsPrimitive (e.mulShift r) := by\n  simp only [IsPrimitive, not_forall]\n  simp only [isUnit_iff_mem_nonZeroDivisors_of_finite, mem_nonZeroDivisors_iff, not_forall] at hr\n  rcases hr with ⟨x, h, h'⟩\n  exact ⟨x, h', by simp only [mulShift_mulShift, mul_comm r, h, mulShift_zero, not_ne_iff]⟩\n\n"}
{"name":"AddChar.PrimitiveAddChar.mk.injEq","module":"Mathlib.NumberTheory.LegendreSymbol.AddCharacter","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nR' : Type v\ninst✝ : Field R'\nn✝ : PNat\nchar✝ : AddChar R (CyclotomicField n✝ R')\nprim✝ : char✝.IsPrimitive\nn : PNat\nchar : AddChar R (CyclotomicField n R')\nprim : char.IsPrimitive\n⊢ Eq (Eq { n := n✝, char := char✝, prim := prim✝ } { n := n, char := char, prim := prim }) (And (Eq n✝ n) (HEq char✝ char))","decl":"/-- Definition for a primitive additive character on a finite ring `R` into a cyclotomic extension\nof a field `R'`. It records which cyclotomic extension it is, the character, and the\nfact that the character is primitive. -/\nstructure PrimitiveAddChar (R : Type u) [CommRing R] (R' : Type v) [Field R'] where\n  /-- The first projection from `PrimitiveAddChar`, giving the cyclotomic field. -/\n  n : ℕ+\n  /-- The second projection from `PrimitiveAddChar`, giving the character. -/\n  char : AddChar R (CyclotomicField n R')\n  /-- The third projection from `PrimitiveAddChar`, showing that `χ.char` is primitive. -/\n  prim : IsPrimitive char\n\n"}
{"name":"AddChar.PrimitiveAddChar.prim","module":"Mathlib.NumberTheory.LegendreSymbol.AddCharacter","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nR' : Type v\ninst✝ : Field R'\nself : AddChar.PrimitiveAddChar R R'\n⊢ self.char.IsPrimitive","decl":"/-- Definition for a primitive additive character on a finite ring `R` into a cyclotomic extension\nof a field `R'`. It records which cyclotomic extension it is, the character, and the\nfact that the character is primitive. -/\nstructure PrimitiveAddChar (R : Type u) [CommRing R] (R' : Type v) [Field R'] where\n  /-- The first projection from `PrimitiveAddChar`, giving the cyclotomic field. -/\n  n : ℕ+\n  /-- The second projection from `PrimitiveAddChar`, giving the character. -/\n  char : AddChar R (CyclotomicField n R')\n  /-- The third projection from `PrimitiveAddChar`, showing that `χ.char` is primitive. -/\n  prim : IsPrimitive char\n\n"}
{"name":"AddChar.PrimitiveAddChar.mk.sizeOf_spec","module":"Mathlib.NumberTheory.LegendreSymbol.AddCharacter","initialProofState":"R : Type u\ninst✝³ : CommRing R\nR' : Type v\ninst✝² : Field R'\ninst✝¹ : SizeOf R\ninst✝ : SizeOf R'\nn : PNat\nchar : AddChar R (CyclotomicField n R')\nprim : char.IsPrimitive\n⊢ Eq (SizeOf.sizeOf { n := n, char := char, prim := prim }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf n)) (SizeOf.sizeOf char))","decl":"/-- Definition for a primitive additive character on a finite ring `R` into a cyclotomic extension\nof a field `R'`. It records which cyclotomic extension it is, the character, and the\nfact that the character is primitive. -/\nstructure PrimitiveAddChar (R : Type u) [CommRing R] (R' : Type v) [Field R'] where\n  /-- The first projection from `PrimitiveAddChar`, giving the cyclotomic field. -/\n  n : ℕ+\n  /-- The second projection from `PrimitiveAddChar`, giving the character. -/\n  char : AddChar R (CyclotomicField n R')\n  /-- The third projection from `PrimitiveAddChar`, showing that `χ.char` is primitive. -/\n  prim : IsPrimitive char\n\n"}
{"name":"AddChar.PrimitiveAddChar.mk.inj","module":"Mathlib.NumberTheory.LegendreSymbol.AddCharacter","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nR' : Type v\ninst✝ : Field R'\nn✝ : PNat\nchar✝ : AddChar R (CyclotomicField n✝ R')\nprim✝ : char✝.IsPrimitive\nn : PNat\nchar : AddChar R (CyclotomicField n R')\nprim : char.IsPrimitive\nx✝ : Eq { n := n✝, char := char✝, prim := prim✝ } { n := n, char := char, prim := prim }\n⊢ And (Eq n✝ n) (HEq char✝ char)","decl":"/-- Definition for a primitive additive character on a finite ring `R` into a cyclotomic extension\nof a field `R'`. It records which cyclotomic extension it is, the character, and the\nfact that the character is primitive. -/\nstructure PrimitiveAddChar (R : Type u) [CommRing R] (R' : Type v) [Field R'] where\n  /-- The first projection from `PrimitiveAddChar`, giving the cyclotomic field. -/\n  n : ℕ+\n  /-- The second projection from `PrimitiveAddChar`, giving the character. -/\n  char : AddChar R (CyclotomicField n R')\n  /-- The third projection from `PrimitiveAddChar`, showing that `χ.char` is primitive. -/\n  prim : IsPrimitive char\n\n"}
{"name":"AddChar.exists_divisor_of_not_isPrimitive","module":"Mathlib.NumberTheory.LegendreSymbol.AddCharacter","initialProofState":"N : Nat\ninst✝¹ : NeZero N\nR : Type u_1\ninst✝ : CommRing R\ne : AddChar (ZMod N) R\nhe : Not e.IsPrimitive\n⊢ Exists fun d => And (Dvd.dvd d N) (And (LT.lt d N) (Eq (e.mulShift ↑d) 1))","decl":"/-- If `e` is not primitive, then `e.mulShift d = 1` for some proper divisor `d` of `N`. -/\nlemma exists_divisor_of_not_isPrimitive (he : ¬e.IsPrimitive) :\n    ∃ d : ℕ, d ∣ N ∧ d < N ∧ e.mulShift d = 1 := by\n  simp_rw [IsPrimitive, not_forall, not_ne_iff] at he\n  rcases he with ⟨b, hb_ne, hb⟩\n  -- We have `AddChar.mulShift e b = 1`, but `b ≠ 0`.\n  obtain ⟨d, hd, u, hu, rfl⟩ := b.eq_unit_mul_divisor\n  refine ⟨d, hd, lt_of_le_of_ne (Nat.le_of_dvd (NeZero.pos _) hd) ?_, ?_⟩\n  · exact fun h ↦ by simp only [h, ZMod.natCast_self, mul_zero, ne_eq, not_true_eq_false] at hb_ne\n  · rw [← mulShift_unit_eq_one_iff _ hu, ← hb, mul_comm]\n    ext1 y\n    rw [mulShift_apply, mulShift_apply, mulShift_apply, mul_assoc]\n\n"}
{"name":"AddChar.zmodChar_apply","module":"Mathlib.NumberTheory.LegendreSymbol.AddCharacter","initialProofState":"C : Type v\ninst✝¹ : CommMonoid C\nn : Nat\ninst✝ : NeZero n\nζ : C\nhζ : Eq (HPow.hPow ζ n) 1\na : ZMod n\n⊢ Eq ((AddChar.zmodChar n hζ) a) (HPow.hPow ζ a.val)","decl":"/-- The additive character on `ZMod n` defined using `ζ` sends `a` to `ζ^a`. -/\ntheorem zmodChar_apply {n : ℕ} [NeZero n] {ζ : C} (hζ : ζ ^ n = 1) (a : ZMod n) :\n    zmodChar n hζ a = ζ ^ a.val :=\n  rfl\n\n"}
{"name":"AddChar.zmodChar_apply'","module":"Mathlib.NumberTheory.LegendreSymbol.AddCharacter","initialProofState":"C : Type v\ninst✝¹ : CommMonoid C\nn : Nat\ninst✝ : NeZero n\nζ : C\nhζ : Eq (HPow.hPow ζ n) 1\na : Nat\n⊢ Eq ((AddChar.zmodChar n hζ) ↑a) (HPow.hPow ζ a)","decl":"theorem zmodChar_apply' {n : ℕ} [NeZero n] {ζ : C} (hζ : ζ ^ n = 1) (a : ℕ) :\n    zmodChar n hζ a = ζ ^ a := by\n  rw [pow_eq_pow_mod a hζ, zmodChar_apply, ZMod.val_natCast a]\n\n"}
{"name":"AddChar.zmod_char_ne_one_iff","module":"Mathlib.NumberTheory.LegendreSymbol.AddCharacter","initialProofState":"C : Type v\ninst✝¹ : CommMonoid C\nn : Nat\ninst✝ : NeZero n\nψ : AddChar (ZMod n) C\n⊢ Iff (Ne ψ 1) (Ne (ψ 1) 1)","decl":"/-- An additive character on `ZMod n` is nontrivial iff it takes a value `≠ 1` on `1`. -/\ntheorem zmod_char_ne_one_iff (n : ℕ) [NeZero n] (ψ : AddChar (ZMod n) C) : ψ ≠ 1 ↔ ψ 1 ≠ 1 := by\n  rw [ne_one_iff]\n  refine ⟨?_, fun h => ⟨_, h⟩⟩\n  contrapose!\n  rintro h₁ a\n  have ha₁ : a = a.val • (1 : ZMod ↑n) := by\n    rw [nsmul_eq_mul, mul_one]; exact (ZMod.natCast_zmod_val a).symm\n  rw [ha₁, map_nsmul_eq_pow, h₁, one_pow]\n\n"}
{"name":"AddChar.IsPrimitive.zmod_char_eq_one_iff","module":"Mathlib.NumberTheory.LegendreSymbol.AddCharacter","initialProofState":"C : Type v\ninst✝¹ : CommMonoid C\nn : Nat\ninst✝ : NeZero n\nψ : AddChar (ZMod n) C\nhψ : ψ.IsPrimitive\na : ZMod n\n⊢ Iff (Eq (ψ a) 1) (Eq a 0)","decl":"/-- A primitive additive character on `ZMod n` takes the value `1` only at `0`. -/\ntheorem IsPrimitive.zmod_char_eq_one_iff (n : ℕ) [NeZero n]\n    {ψ : AddChar (ZMod n) C} (hψ : IsPrimitive ψ) (a : ZMod n) :\n    ψ a = 1 ↔ a = 0 := by\n  refine ⟨fun h => not_imp_comm.mp (@hψ a) ?_, fun ha => by rw [ha, map_zero_eq_one]⟩\n  rw [zmod_char_ne_one_iff n (mulShift ψ a), mulShift_apply, mul_one, h, Classical.not_not]\n\n"}
{"name":"AddChar.zmod_char_primitive_of_eq_one_only_at_zero","module":"Mathlib.NumberTheory.LegendreSymbol.AddCharacter","initialProofState":"C : Type v\ninst✝ : CommMonoid C\nn : Nat\nψ : AddChar (ZMod n) C\nhψ : ∀ (a : ZMod n), Eq (ψ a) 1 → Eq a 0\n⊢ ψ.IsPrimitive","decl":"/-- The converse: if the additive character takes the value `1` only at `0`,\nthen it is primitive. -/\ntheorem zmod_char_primitive_of_eq_one_only_at_zero (n : ℕ) (ψ : AddChar (ZMod n) C)\n    (hψ : ∀ a, ψ a = 1 → a = 0) : IsPrimitive ψ := by\n  refine fun a ha hf => ?_\n  have h : mulShift ψ a 1 = (1 : AddChar (ZMod n) C) (1 : ZMod n) :=\n    congr_fun (congr_arg (↑) hf) 1\n  rw [mulShift_apply, mul_one] at h; norm_cast at h\n  exact ha (hψ a h)\n\n"}
{"name":"AddChar.zmodChar_primitive_of_primitive_root","module":"Mathlib.NumberTheory.LegendreSymbol.AddCharacter","initialProofState":"C : Type v\ninst✝¹ : CommMonoid C\nn : Nat\ninst✝ : NeZero n\nζ : C\nh : IsPrimitiveRoot ζ n\n⊢ (AddChar.zmodChar n ⋯).IsPrimitive","decl":"/-- The additive character on `ZMod n` associated to a primitive `n`th root of unity\nis primitive -/\ntheorem zmodChar_primitive_of_primitive_root (n : ℕ) [NeZero n] {ζ : C} (h : IsPrimitiveRoot ζ n) :\n    IsPrimitive (zmodChar n ((IsPrimitiveRoot.iff_def ζ n).mp h).left) := by\n  apply zmod_char_primitive_of_eq_one_only_at_zero\n  intro a ha\n  rw [zmodChar_apply, ← pow_zero ζ] at ha\n  exact (ZMod.val_eq_zero a).mp (IsPrimitiveRoot.pow_inj h (ZMod.val_lt a) (NeZero.pos _) ha)\n\n"}
{"name":"AddChar.sum_eq_zero_of_ne_one","module":"Mathlib.NumberTheory.LegendreSymbol.AddCharacter","initialProofState":"R : Type u_1\ninst✝³ : AddGroup R\ninst✝² : Fintype R\nR' : Type u_2\ninst✝¹ : CommRing R'\ninst✝ : IsDomain R'\nψ : AddChar R R'\nhψ : Ne ψ 1\n⊢ Eq (Finset.univ.sum fun a => ψ a) 0","decl":"/-- The sum over the values of a nontrivial additive character vanishes if the target ring\nis a domain. -/\ntheorem sum_eq_zero_of_ne_one [IsDomain R'] {ψ : AddChar R R'} (hψ : ψ ≠ 1) : ∑ a, ψ a = 0 := by\n  rcases ne_one_iff.1 hψ with ⟨b, hb⟩\n  have h₁ : ∑ a : R, ψ (b + a) = ∑ a : R, ψ a :=\n    Fintype.sum_bijective _ (AddGroup.addLeft_bijective b) _ _ fun x => rfl\n  simp_rw [map_add_eq_mul] at h₁\n  have h₂ : ∑ a : R, ψ a = Finset.univ.sum ↑ψ := rfl\n  rw [← Finset.mul_sum, h₂] at h₁\n  exact eq_zero_of_mul_eq_self_left hb h₁\n\n"}
{"name":"AddChar.sum_eq_card_of_eq_one","module":"Mathlib.NumberTheory.LegendreSymbol.AddCharacter","initialProofState":"R : Type u_1\ninst✝² : AddGroup R\ninst✝¹ : Fintype R\nR' : Type u_2\ninst✝ : CommRing R'\nψ : AddChar R R'\nhψ : Eq ψ 1\n⊢ Eq (Finset.univ.sum fun a => ψ a) ↑(Fintype.card R)","decl":"/-- The sum over the values of the trivial additive character is the cardinality of the source. -/\ntheorem sum_eq_card_of_eq_one {ψ : AddChar R R'} (hψ : ψ = 1) :\n    ∑ a, ψ a = Fintype.card R := by simp [hψ]\n\n"}
{"name":"AddChar.sum_mulShift","module":"Mathlib.NumberTheory.LegendreSymbol.AddCharacter","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : Fintype R\ninst✝² : DecidableEq R\nR' : Type u_2\ninst✝¹ : CommRing R'\ninst✝ : IsDomain R'\nψ : AddChar R R'\nb : R\nhψ : ψ.IsPrimitive\n⊢ Eq (Finset.univ.sum fun x => ψ (HMul.hMul x b)) ↑(ite (Eq b 0) (Fintype.card R) 0)","decl":"/-- The sum over the values of `mulShift ψ b` for `ψ` primitive is zero when `b ≠ 0`\nand `#R` otherwise. -/\ntheorem sum_mulShift {R : Type*} [CommRing R] [Fintype R] [DecidableEq R]\n    {R' : Type*} [CommRing R'] [IsDomain R'] {ψ : AddChar R R'} (b : R)\n    (hψ : IsPrimitive ψ) : ∑ x : R, ψ (x * b) = if b = 0 then Fintype.card R else 0 := by\n  split_ifs with h\n  · -- case `b = 0`\n    simp only [h, mul_zero, map_zero_eq_one, Finset.sum_const, Nat.smul_one_eq_cast]\n    rfl\n  · -- case `b ≠ 0`\n    simp_rw [mul_comm]\n    exact mod_cast sum_eq_zero_of_ne_one (hψ h)\n\n"}
{"name":"AddChar.starComp_eq_inv","module":"Mathlib.NumberTheory.LegendreSymbol.AddCharacter","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nhR : LT.lt 0 (ringChar R)\nφ : AddChar R Complex\n⊢ Eq ((↑(starRingEnd Complex)).compAddChar φ) (Inv.inv φ)","decl":"/-- Post-composing an additive character to `ℂ` with complex conjugation gives the inverse\ncharacter. -/\nlemma starComp_eq_inv (hR : 0 < ringChar R) {φ : AddChar R ℂ} :\n    (starRingEnd ℂ).compAddChar φ = φ⁻¹ := by\n  ext1 a\n  simp only [RingHom.toMonoidHom_eq_coe, MonoidHom.coe_compAddChar, MonoidHom.coe_coe,\n    Function.comp_apply, inv_apply']\n  have H := Complex.norm_eq_one_of_mem_rootsOfUnity <| φ.val_mem_rootsOfUnity a hR\n  exact (Complex.inv_eq_conj H).symm\n\n"}
{"name":"AddChar.starComp_apply","module":"Mathlib.NumberTheory.LegendreSymbol.AddCharacter","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nhR : LT.lt 0 (ringChar R)\nφ : AddChar R Complex\na : R\n⊢ Eq ((starRingEnd Complex) (φ a)) ((Inv.inv φ) a)","decl":"lemma starComp_apply (hR : 0 < ringChar R) {φ : AddChar R ℂ} (a : R) :\n    (starRingEnd ℂ) (φ a) = φ⁻¹ a := by\n  rw [← starComp_eq_inv hR]\n  rfl\n\n"}
{"name":"AddChar.FiniteField.primitiveChar_to_Complex_isPrimitive","module":"Mathlib.NumberTheory.LegendreSymbol.AddCharacter","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : Finite F\n⊢ (AddChar.FiniteField.primitiveChar_to_Complex F).IsPrimitive","decl":"lemma FiniteField.primitiveChar_to_Complex_isPrimitive :\n    (primitiveChar_to_Complex F).IsPrimitive := by\n  refine IsPrimitive.compMulHom_of_isPrimitive (PrimitiveAddChar.prim _) ?_\n  let nn := (primitiveChar F ℂ <| ringChar_ne F).n\n  exact (IsCyclotomicExtension.algEquiv nn ℂ (CyclotomicField nn ℂ) ℂ).injective\n\n"}
