{"name":"LinearMap.BilinMap.tensorDistrib_tmul","module":"Mathlib.LinearAlgebra.BilinearForm.TensorProduct","initialProofState":"R : Type uR\nA : Type uA\nM₁ : Type uM₁\nM₂ : Type uM₂\nN₁ : Type uN₁\nN₂ : Type uN₂\ninst✝¹⁶ : CommSemiring R\ninst✝¹⁵ : CommSemiring A\ninst✝¹⁴ : AddCommMonoid M₁\ninst✝¹³ : AddCommMonoid M₂\ninst✝¹² : AddCommMonoid N₁\ninst✝¹¹ : AddCommMonoid N₂\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : Module R M₁\ninst✝⁸ : Module A M₁\ninst✝⁷ : Module R N₁\ninst✝⁶ : Module A N₁\ninst✝⁵ : SMulCommClass R A M₁\ninst✝⁴ : IsScalarTower R A M₁\ninst✝³ : SMulCommClass R A N₁\ninst✝² : IsScalarTower R A N₁\ninst✝¹ : Module R M₂\ninst✝ : Module R N₂\nB₁ : LinearMap.BilinMap A M₁ N₁\nB₂ : LinearMap.BilinMap R M₂ N₂\nm₁ : M₁\nm₂ : M₂\nm₁' : M₁\nm₂' : M₂\n⊢ Eq ((((LinearMap.BilinMap.tensorDistrib R A) (TensorProduct.tmul R B₁ B₂)) (TensorProduct.tmul R m₁ m₂)) (TensorProduct.tmul R m₁' m₂')) (TensorProduct.tmul R ((B₁ m₁) m₁') ((B₂ m₂) m₂'))","decl":"@[simp]\ntheorem tensorDistrib_tmul (B₁ : BilinMap A M₁ N₁) (B₂ : BilinMap R M₂ N₂) (m₁ : M₁) (m₂ : M₂)\n    (m₁' : M₁) (m₂' : M₂) :\n    tensorDistrib R A (B₁ ⊗ₜ B₂) (m₁ ⊗ₜ m₂) (m₁' ⊗ₜ m₂')\n      = B₁ m₁ m₁' ⊗ₜ B₂ m₂ m₂' :=\n  rfl\n\n"}
{"name":"LinearMap.BilinMap.tmul_isSymm","module":"Mathlib.LinearAlgebra.BilinearForm.TensorProduct","initialProofState":"R : Type uR\nA : Type uA\nM₁ : Type uM₁\nM₂ : Type uM₂\nN₁ : Type uN₁\nN₂ : Type uN₂\ninst✝¹⁶ : CommSemiring R\ninst✝¹⁵ : CommSemiring A\ninst✝¹⁴ : AddCommMonoid M₁\ninst✝¹³ : AddCommMonoid M₂\ninst✝¹² : AddCommMonoid N₁\ninst✝¹¹ : AddCommMonoid N₂\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : Module R M₁\ninst✝⁸ : Module A M₁\ninst✝⁷ : Module R N₁\ninst✝⁶ : Module A N₁\ninst✝⁵ : SMulCommClass R A M₁\ninst✝⁴ : IsScalarTower R A M₁\ninst✝³ : SMulCommClass R A N₁\ninst✝² : IsScalarTower R A N₁\ninst✝¹ : Module R M₂\ninst✝ : Module R N₂\nB₁ : LinearMap.BilinMap A M₁ N₁\nB₂ : LinearMap.BilinMap R M₂ N₂\nhB₁ : ∀ (x y : M₁), Eq ((B₁ x) y) ((B₁ y) x)\nhB₂ : ∀ (x y : M₂), Eq ((B₂ x) y) ((B₂ y) x)\nx y : TensorProduct R M₁ M₂\n⊢ Eq (((B₁.tmul B₂) x) y) (((B₁.tmul B₂) y) x)","decl":"attribute [local ext] TensorProduct.ext in\n/-- A tensor product of symmetric bilinear maps is symmetric. -/\nlemma tmul_isSymm {B₁ : BilinMap A M₁ N₁} {B₂ : BilinMap R M₂ N₂}\n    (hB₁ : ∀ x y, B₁ x y = B₁ y x) (hB₂ : ∀ x y, B₂ x y = B₂ y x)\n    (x y : M₁ ⊗[R] M₂) :\n    B₁.tmul B₂ x y = B₁.tmul B₂ y x := by\n  revert x y\n  rw [isSymm_iff_eq_flip]\n  aesop\n\n"}
{"name":"LinearMap.BilinMap.baseChange_tmul","module":"Mathlib.LinearAlgebra.BilinearForm.TensorProduct","initialProofState":"R : Type uR\nA : Type uA\nM₂ : Type uM₂\nN₂ : Type uN₂\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring A\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid N₂\ninst✝² : Algebra R A\ninst✝¹ : Module R M₂\ninst✝ : Module R N₂\nB₂ : LinearMap.BilinMap R M₂ N₂\na : A\nm₂ : M₂\na' : A\nm₂' : M₂\n⊢ Eq (((LinearMap.BilinMap.baseChange A B₂) (TensorProduct.tmul R a m₂)) (TensorProduct.tmul R a' m₂')) (TensorProduct.tmul R (HMul.hMul a a') ((B₂ m₂) m₂'))","decl":"@[simp]\ntheorem baseChange_tmul (B₂ : BilinMap R M₂ N₂) (a : A) (m₂ : M₂)\n    (a' : A) (m₂' : M₂) :\n    B₂.baseChange A (a ⊗ₜ m₂) (a' ⊗ₜ m₂') = (a * a') ⊗ₜ (B₂ m₂ m₂')  :=\n  rfl\n\n"}
{"name":"LinearMap.BilinMap.baseChange_isSymm","module":"Mathlib.LinearAlgebra.BilinearForm.TensorProduct","initialProofState":"R : Type uR\nA : Type uA\nM₂ : Type uM₂\nN₂ : Type uN₂\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring A\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid N₂\ninst✝² : Algebra R A\ninst✝¹ : Module R M₂\ninst✝ : Module R N₂\nB₂ : LinearMap.BilinMap R M₂ N₂\nhB₂ : ∀ (x y : M₂), Eq ((B₂ x) y) ((B₂ y) x)\nx y : TensorProduct R A M₂\n⊢ Eq (((LinearMap.BilinMap.baseChange A B₂) x) y) (((LinearMap.BilinMap.baseChange A B₂) y) x)","decl":"lemma baseChange_isSymm {B₂ : BilinMap R M₂ N₂} (hB₂ : ∀ x y, B₂ x y = B₂ y x) (x y : A ⊗[R] M₂) :\n    B₂.baseChange A x y = B₂.baseChange A y x :=\n  tmul_isSymm mul_comm hB₂ x y\n\n"}
{"name":"LinearMap.BilinForm.tensorDistrib_tmul","module":"Mathlib.LinearAlgebra.BilinearForm.TensorProduct","initialProofState":"R : Type uR\nA : Type uA\nM₁ : Type uM₁\nM₂ : Type uM₂\ninst✝⁹ : CommSemiring R\ninst✝⁸ : CommSemiring A\ninst✝⁷ : AddCommMonoid M₁\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : Algebra R A\ninst✝⁴ : Module R M₁\ninst✝³ : Module A M₁\ninst✝² : SMulCommClass R A M₁\ninst✝¹ : IsScalarTower R A M₁\ninst✝ : Module R M₂\nB₁ : LinearMap.BilinForm A M₁\nB₂ : LinearMap.BilinForm R M₂\nm₁ : M₁\nm₂ : M₂\nm₁' : M₁\nm₂' : M₂\n⊢ Eq ((((LinearMap.BilinForm.tensorDistrib R A) (TensorProduct.tmul R B₁ B₂)) (TensorProduct.tmul R m₁ m₂)) (TensorProduct.tmul R m₁' m₂')) (HSMul.hSMul ((B₂ m₂) m₂') ((B₁ m₁) m₁'))","decl":"variable (R A) in\n\n-- TODO: make the RHS `MulOpposite.op (B₂ m₂ m₂') • B₁ m₁ m₁'` so that this has a nicer defeq for\n-- `R = A` of `B₁ m₁ m₁' * B₂ m₂ m₂'`, as it did before the generalization in https://github.com/leanprover-community/mathlib4/pull/6306.\n@[simp]\ntheorem tensorDistrib_tmul (B₁ : BilinForm A M₁) (B₂ : BilinForm R M₂) (m₁ : M₁) (m₂ : M₂)\n    (m₁' : M₁) (m₂' : M₂) :\n    tensorDistrib R A (B₁ ⊗ₜ B₂) (m₁ ⊗ₜ m₂) (m₁' ⊗ₜ m₂')\n      = B₂ m₂ m₂' • B₁ m₁ m₁' :=\n  rfl\n\n"}
{"name":"LinearMap.IsSymm.tmul","module":"Mathlib.LinearAlgebra.BilinearForm.TensorProduct","initialProofState":"R : Type uR\nA : Type uA\nM₁ : Type uM₁\nM₂ : Type uM₂\ninst✝⁹ : CommSemiring R\ninst✝⁸ : CommSemiring A\ninst✝⁷ : AddCommMonoid M₁\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : Algebra R A\ninst✝⁴ : Module R M₁\ninst✝³ : Module A M₁\ninst✝² : SMulCommClass R A M₁\ninst✝¹ : IsScalarTower R A M₁\ninst✝ : Module R M₂\nB₁ : LinearMap.BilinForm A M₁\nB₂ : LinearMap.BilinForm R M₂\nhB₁ : LinearMap.IsSymm B₁\nhB₂ : LinearMap.IsSymm B₂\n⊢ LinearMap.IsSymm (B₁.tmul B₂)","decl":"attribute [local ext] TensorProduct.ext in\n/-- A tensor product of symmetric bilinear forms is symmetric. -/\nlemma _root_.LinearMap.IsSymm.tmul {B₁ : BilinForm A M₁} {B₂ : BilinForm R M₂}\n    (hB₁ : B₁.IsSymm) (hB₂ : B₂.IsSymm) : (B₁.tmul B₂).IsSymm := by\n  rw [LinearMap.isSymm_iff_eq_flip]\n  ext x₁ x₂ y₁ y₂\n  exact congr_arg₂ (HSMul.hSMul) (hB₂ x₂ y₂) (hB₁ x₁ y₁)\n\n"}
{"name":"LinearMap.BilinForm.baseChange_tmul","module":"Mathlib.LinearAlgebra.BilinearForm.TensorProduct","initialProofState":"R : Type uR\nA : Type uA\nM₂ : Type uM₂\ninst✝⁴ : CommSemiring R\ninst✝³ : CommSemiring A\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Algebra R A\ninst✝ : Module R M₂\nB₂ : LinearMap.BilinForm R M₂\na : A\nm₂ : M₂\na' : A\nm₂' : M₂\n⊢ Eq (((LinearMap.BilinForm.baseChange A B₂) (TensorProduct.tmul R a m₂)) (TensorProduct.tmul R a' m₂')) (HSMul.hSMul ((B₂ m₂) m₂') (HMul.hMul a a'))","decl":"@[simp]\ntheorem baseChange_tmul (B₂ : BilinForm R M₂) (a : A) (m₂ : M₂)\n    (a' : A) (m₂' : M₂) :\n    B₂.baseChange A (a ⊗ₜ m₂) (a' ⊗ₜ m₂') = (B₂ m₂ m₂') • (a * a') :=\n  rfl\n\n"}
{"name":"LinearMap.BilinForm.IsSymm.baseChange","module":"Mathlib.LinearAlgebra.BilinearForm.TensorProduct","initialProofState":"R : Type uR\nA : Type uA\nM₂ : Type uM₂\ninst✝⁴ : CommSemiring R\ninst✝³ : CommSemiring A\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Algebra R A\ninst✝ : Module R M₂\nB₂ : LinearMap.BilinForm R M₂\nhB₂ : LinearMap.IsSymm B₂\n⊢ LinearMap.IsSymm (LinearMap.BilinForm.baseChange A B₂)","decl":"variable (A) in\n/-- The base change of a symmetric bilinear form is symmetric. -/\nlemma IsSymm.baseChange {B₂ : BilinForm R M₂} (hB₂ : B₂.IsSymm) : (B₂.baseChange A).IsSymm :=\n  IsSymm.tmul mul_comm hB₂\n\n"}
{"name":"LinearMap.BilinForm.tensorDistribEquiv_tmul","module":"Mathlib.LinearAlgebra.BilinearForm.TensorProduct","initialProofState":"R : Type uR\nM₁ : Type uM₁\nM₂ : Type uM₂\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M₁\ninst✝⁶ : AddCommGroup M₂\ninst✝⁵ : Module R M₁\ninst✝⁴ : Module R M₂\ninst✝³ : Module.Free R M₁\ninst✝² : Module.Finite R M₁\ninst✝¹ : Module.Free R M₂\ninst✝ : Module.Finite R M₂\nB₁ : LinearMap.BilinForm R M₁\nB₂ : LinearMap.BilinForm R M₂\nm₁ : M₁\nm₂ : M₂\nm₁' : M₁\nm₂' : M₂\n⊢ Eq ((((LinearMap.BilinForm.tensorDistribEquiv R) (TensorProduct.tmul R B₁ B₂)) (TensorProduct.tmul R m₁ m₂)) (TensorProduct.tmul R m₁' m₂')) (HMul.hMul ((B₁ m₁) m₁') ((B₂ m₂) m₂'))","decl":"@[simp]\ntheorem tensorDistribEquiv_tmul (B₁ : BilinForm R M₁) (B₂ : BilinForm R M₂) (m₁ : M₁) (m₂ : M₂)\n    (m₁' : M₁) (m₂' : M₂) :\n    tensorDistribEquiv R (M₁ := M₁) (M₂ := M₂) (B₁ ⊗ₜ[R] B₂) (m₁ ⊗ₜ m₂) (m₁' ⊗ₜ m₂')\n      = B₁ m₁ m₁' * B₂ m₂ m₂' :=\n  rfl\n\n"}
{"name":"LinearMap.BilinForm.tensorDistribEquiv_toLinearMap","module":"Mathlib.LinearAlgebra.BilinearForm.TensorProduct","initialProofState":"R : Type uR\nM₁ : Type uM₁\nM₂ : Type uM₂\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M₁\ninst✝⁶ : AddCommGroup M₂\ninst✝⁵ : Module R M₁\ninst✝⁴ : Module R M₂\ninst✝³ : Module.Free R M₁\ninst✝² : Module.Finite R M₁\ninst✝¹ : Module.Free R M₂\ninst✝ : Module.Finite R M₂\n⊢ Eq (↑(LinearMap.BilinForm.tensorDistribEquiv R)) (LinearMap.BilinForm.tensorDistrib R R)","decl":"variable (R M₁ M₂) in\n-- TODO: make this `rfl`\n@[simp]\ntheorem tensorDistribEquiv_toLinearMap :\n    (tensorDistribEquiv R (M₁ := M₁) (M₂ := M₂)).toLinearMap = tensorDistrib R R := by\n  ext B₁ B₂ : 3\n  ext\n  exact mul_comm _ _\n\n"}
{"name":"LinearMap.BilinForm.tensorDistribEquiv_apply","module":"Mathlib.LinearAlgebra.BilinearForm.TensorProduct","initialProofState":"R : Type uR\nM₁ : Type uM₁\nM₂ : Type uM₂\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M₁\ninst✝⁶ : AddCommGroup M₂\ninst✝⁵ : Module R M₁\ninst✝⁴ : Module R M₂\ninst✝³ : Module.Free R M₁\ninst✝² : Module.Finite R M₁\ninst✝¹ : Module.Free R M₂\ninst✝ : Module.Finite R M₂\nB : TensorProduct R (LinearMap.BilinForm R M₁) (LinearMap.BilinForm R M₂)\n⊢ Eq ((LinearMap.BilinForm.tensorDistribEquiv R) B) ((LinearMap.BilinForm.tensorDistrib R R) B)","decl":"@[simp]\ntheorem tensorDistribEquiv_apply (B : BilinForm R M₁ ⊗ BilinForm R M₂) :\n    tensorDistribEquiv R (M₁ := M₁) (M₂ := M₂) B = tensorDistrib R R B :=\n  DFunLike.congr_fun (tensorDistribEquiv_toLinearMap R M₁ M₂) B\n\n"}
