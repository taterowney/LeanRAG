{"name":"localCohomology.moduleCat_enoughProjectives'","module":"Mathlib.Algebra.Homology.LocalCohomology","initialProofState":"R : Type u\ninst✝ : CommRing R\n⊢ CategoryTheory.EnoughProjectives (ModuleCat R)","decl":"instance moduleCat_enoughProjectives' : EnoughProjectives (ModuleCat.{u} R) :=\n  ModuleCat.moduleCat_enoughProjectives.{u}\n\n"}
{"name":"localCohomology.hasColimitDiagram","module":"Mathlib.Algebra.Homology.LocalCohomology","initialProofState":"R : Type (max u v)\ninst✝¹ : CommRing R\nD : Type v\ninst✝ : CategoryTheory.SmallCategory D\nI : CategoryTheory.Functor D (Ideal R)\ni : Nat\n⊢ CategoryTheory.Limits.HasColimit (localCohomology.diagram I i)","decl":"lemma hasColimitDiagram (I : D ⥤ Ideal R) (i : ℕ) :\n    HasColimit (diagram I i) := inferInstance\n\n/-\nIn this definition we do not assume any special property of the diagram `I`, but the relevant case\nwill be where `I` is (cofinal with) the diagram of powers of a single given ideal.\n\nBelow, we give two equivalent definitions of the usual local cohomology with support\nin an ideal `J`, `localCohomology` and `localCohomology.ofSelfLERadical`.\n -/\n"}
{"name":"localCohomology.ideal_powers_initial","module":"Mathlib.Algebra.Homology.LocalCohomology","initialProofState":"R : Type u\ninst✝ : CommRing R\nJ : Ideal R\nhR : IsNoetherian R R\n⊢ (localCohomology.idealPowersToSelfLERadical J).Initial","decl":"/-- The diagram of powers of `J` is initial in the diagram of all ideals with\nradical containing `J`. This uses noetherianness. -/\ninstance ideal_powers_initial [hR : IsNoetherian R R] :\n    Functor.Initial (idealPowersToSelfLERadical J) where\n  out J' := by\n    apply (config := {allowSynthFailures := true }) zigzag_isConnected\n    · obtain ⟨k, hk⟩ := Ideal.exists_pow_le_of_le_radical_of_fg J'.2 (isNoetherian_def.mp hR _)\n      exact ⟨CostructuredArrow.mk (⟨⟨hk⟩⟩ : (idealPowersToSelfLERadical J).obj (op k) ⟶ J')⟩\n    · intro j1 j2\n      apply Relation.ReflTransGen.single\n      -- The inclusions `J^n1 ≤ J'` and `J^n2 ≤ J'` always form a triangle, based on\n      -- which exponent is larger.\n      rcases le_total (unop j1.left) (unop j2.left) with h | h\n      · right; exact ⟨CostructuredArrow.homMk (homOfLE h).op rfl⟩\n      · left; exact ⟨CostructuredArrow.homMk (homOfLE h).op rfl⟩\n\n"}
{"name":"localCohomology.SelfLERadical.cast_isEquivalence","module":"Mathlib.Algebra.Homology.LocalCohomology","initialProofState":"R : Type u\ninst✝ : CommRing R\nJ K : Ideal R\nhJK : Eq J.radical K.radical\n⊢ (localCohomology.SelfLERadical.cast hJK).IsEquivalence","decl":"instance SelfLERadical.cast_isEquivalence (hJK : J.radical = K.radical) :\n    (SelfLERadical.cast hJK).IsEquivalence :=\n  (castEquivalence hJK).isEquivalence_functor\n\n"}
