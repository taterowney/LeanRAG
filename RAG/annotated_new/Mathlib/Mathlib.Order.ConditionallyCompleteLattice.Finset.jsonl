{"name":"Finset.Nonempty.csSup_eq_max'","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"α : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder α\ns : Finset α\nh : s.Nonempty\n⊢ Eq (SupSet.sSup ↑s) (s.max' h)","decl":"theorem Finset.Nonempty.csSup_eq_max' {s : Finset α} (h : s.Nonempty) : sSup ↑s = s.max' h :=\n  eq_of_forall_ge_iff fun _ => (csSup_le_iff s.bddAbove h.to_set).trans (s.max'_le_iff h).symm\n\n"}
{"name":"Finset.Nonempty.csInf_eq_min'","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"α : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder α\ns : Finset α\nh : s.Nonempty\n⊢ Eq (InfSet.sInf ↑s) (s.min' h)","decl":"theorem Finset.Nonempty.csInf_eq_min' {s : Finset α} (h : s.Nonempty) : sInf ↑s = s.min' h :=\n  @Finset.Nonempty.csSup_eq_max' αᵒᵈ _ s h\n\n"}
{"name":"Finset.Nonempty.csSup_mem","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"α : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder α\ns : Finset α\nh : s.Nonempty\n⊢ Membership.mem s (SupSet.sSup ↑s)","decl":"theorem Finset.Nonempty.csSup_mem {s : Finset α} (h : s.Nonempty) : sSup (s : Set α) ∈ s := by\n  rw [h.csSup_eq_max']\n  exact s.max'_mem _\n\n"}
{"name":"Finset.Nonempty.csInf_mem","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"α : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder α\ns : Finset α\nh : s.Nonempty\n⊢ Membership.mem s (InfSet.sInf ↑s)","decl":"theorem Finset.Nonempty.csInf_mem {s : Finset α} (h : s.Nonempty) : sInf (s : Set α) ∈ s :=\n  @Finset.Nonempty.csSup_mem αᵒᵈ _ _ h\n\n"}
{"name":"Set.Nonempty.csSup_mem","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"α : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder α\ns : Set α\nh : s.Nonempty\nhs : s.Finite\n⊢ Membership.mem s (SupSet.sSup s)","decl":"theorem Set.Nonempty.csSup_mem (h : s.Nonempty) (hs : s.Finite) : sSup s ∈ s := by\n  lift s to Finset α using hs\n  exact Finset.Nonempty.csSup_mem h\n\n"}
{"name":"Set.Nonempty.csInf_mem","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"α : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder α\ns : Set α\nh : s.Nonempty\nhs : s.Finite\n⊢ Membership.mem s (InfSet.sInf s)","decl":"theorem Set.Nonempty.csInf_mem (h : s.Nonempty) (hs : s.Finite) : sInf s ∈ s :=\n  @Set.Nonempty.csSup_mem αᵒᵈ _ _ h hs\n\n"}
{"name":"Set.Finite.csSup_lt_iff","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"α : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder α\ns : Set α\na : α\nhs : s.Finite\nh : s.Nonempty\n⊢ Iff (LT.lt (SupSet.sSup s) a) (∀ (x : α), Membership.mem s x → LT.lt x a)","decl":"theorem Set.Finite.csSup_lt_iff (hs : s.Finite) (h : s.Nonempty) : sSup s < a ↔ ∀ x ∈ s, x < a :=\n  ⟨fun h _ hx => (le_csSup hs.bddAbove hx).trans_lt h, fun H => H _ <| h.csSup_mem hs⟩\n\n"}
{"name":"Set.Finite.lt_csInf_iff","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"α : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder α\ns : Set α\na : α\nhs : s.Finite\nh : s.Nonempty\n⊢ Iff (LT.lt a (InfSet.sInf s)) (∀ (x : α), Membership.mem s x → LT.lt a x)","decl":"theorem Set.Finite.lt_csInf_iff (hs : s.Finite) (h : s.Nonempty) : a < sInf s ↔ ∀ x ∈ s, a < x :=\n  @Set.Finite.csSup_lt_iff αᵒᵈ _ _ _ hs h\n\n"}
{"name":"Finset.ciSup_eq_max'_image","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder α\nf : ι → α\ns : Finset ι\nh : Exists fun x => And (Membership.mem s x) (LE.le (SupSet.sSup EmptyCollection.emptyCollection) (f x))\nh' : autoParam (Finset.image f s).Nonempty _auto✝\n⊢ Eq (iSup fun i => iSup fun h => f i) ((Finset.image f s).max' h')","decl":"theorem Finset.ciSup_eq_max'_image {s : Finset ι} (h : ∃ x ∈ s, sSup ∅ ≤ f x)\n    (h' : (s.image f).Nonempty := by classical exact image_nonempty.mpr (h.imp fun _ ↦ And.left)) :\n    ⨆ i ∈ s, f i = (s.image f).max' h' := by\n  classical\n  rw [iSup, ← h'.csSup_eq_max', coe_image]\n  refine csSup_eq_csSup_of_forall_exists_le ?_ ?_\n  · simp only [ciSup_eq_ite, dite_eq_ite, Set.mem_range, Set.mem_image, mem_coe,\n      exists_exists_and_eq_and, forall_exists_index, forall_apply_eq_imp_iff]\n    intro i\n    split_ifs\n    · exact ⟨_, by assumption, le_rfl⟩\n    · obtain ⟨a, ha, ha'⟩ := h\n      exact ⟨a, ha, ha'⟩\n  · simp only [Set.mem_image, mem_coe, ciSup_eq_ite, dite_eq_ite, Set.mem_range,\n      exists_exists_eq_and, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂]\n    intro i hi\n    refine ⟨i, ?_⟩\n    simp [hi]\n\n"}
{"name":"Finset.ciInf_eq_min'_image","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder α\nf : ι → α\ns : Finset ι\nh : Exists fun x => And (Membership.mem s x) (LE.le (f x) (InfSet.sInf EmptyCollection.emptyCollection))\nh' : autoParam (Finset.image f s).Nonempty _auto✝\n⊢ Eq (iInf fun i => iInf fun h => f i) ((Finset.image f s).min' h')","decl":"theorem Finset.ciInf_eq_min'_image {s : Finset ι} (h : ∃ x ∈ s, f x ≤ sInf ∅)\n    (h' : (s.image f).Nonempty := by classical exact image_nonempty.mpr (h.imp fun _ ↦ And.left)) :\n    ⨅ i ∈ s, f i = (s.image f).min' h' := by\n  classical\n  rw [← OrderDual.toDual_inj, toDual_min', toDual_iInf]\n  simp only [Function.comp_apply, toDual_iInf]\n  rw [ciSup_eq_max'_image _ h]\n  simp only [image_image]\n  congr\n\n"}
{"name":"Finset.ciSup_mem_image","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder α\nf : ι → α\ns : Finset ι\nh : Exists fun x => And (Membership.mem s x) (LE.le (SupSet.sSup EmptyCollection.emptyCollection) (f x))\n⊢ Membership.mem (Finset.image f s) (iSup fun i => iSup fun h => f i)","decl":"theorem Finset.ciSup_mem_image {s : Finset ι} (h : ∃ x ∈ s, sSup ∅ ≤ f x) :\n    ⨆ i ∈ s, f i ∈ s.image f := by\n  rw [ciSup_eq_max'_image _ h]\n  exact max'_mem (image f s) _\n\n"}
{"name":"Finset.ciInf_mem_image","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder α\nf : ι → α\ns : Finset ι\nh : Exists fun x => And (Membership.mem s x) (LE.le (f x) (InfSet.sInf EmptyCollection.emptyCollection))\n⊢ Membership.mem (Finset.image f s) (iInf fun i => iInf fun h => f i)","decl":"theorem Finset.ciInf_mem_image {s : Finset ι} (h : ∃ x ∈ s, f x ≤ sInf ∅) :\n    ⨅ i ∈ s, f i ∈ s.image f := by\n  rw [ciInf_eq_min'_image _ h]\n  exact min'_mem (image f s) _\n\n"}
{"name":"Set.Finite.ciSup_mem_image","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder α\nf : ι → α\ns : Set ι\nhs : s.Finite\nh : Exists fun x => And (Membership.mem s x) (LE.le (SupSet.sSup EmptyCollection.emptyCollection) (f x))\n⊢ Membership.mem (Set.image f s) (iSup fun i => iSup fun h => f i)","decl":"theorem Set.Finite.ciSup_mem_image {s : Set ι} (hs : s.Finite) (h : ∃ x ∈ s, sSup ∅ ≤ f x) :\n    ⨆ i ∈ s, f i ∈ f '' s := by\n  lift s to Finset ι using hs\n  simp only [Finset.mem_coe] at h\n  simpa using Finset.ciSup_mem_image f h\n\n"}
{"name":"Set.Finite.ciInf_mem_image","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder α\nf : ι → α\ns : Set ι\nhs : s.Finite\nh : Exists fun x => And (Membership.mem s x) (LE.le (f x) (InfSet.sInf EmptyCollection.emptyCollection))\n⊢ Membership.mem (Set.image f s) (iInf fun i => iInf fun h => f i)","decl":"theorem Set.Finite.ciInf_mem_image {s : Set ι} (hs : s.Finite) (h : ∃ x ∈ s, f x ≤ sInf ∅) :\n    ⨅ i ∈ s, f i ∈ f '' s := by\n  lift s to Finset ι using hs\n  simp only [Finset.mem_coe] at h\n  simpa using Finset.ciInf_mem_image f h\n\n"}
{"name":"Set.Finite.ciSup_lt_iff","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder α\na : α\ns : Set ι\nf : ι → α\nhs : s.Finite\nh : Exists fun x => And (Membership.mem s x) (LE.le (SupSet.sSup EmptyCollection.emptyCollection) (f x))\n⊢ Iff (LT.lt (iSup fun i => iSup fun h => f i) a) (∀ (x : ι), Membership.mem s x → LT.lt (f x) a)","decl":"theorem Set.Finite.ciSup_lt_iff {s : Set ι} {f : ι → α} (hs : s.Finite)\n    (h : ∃ x ∈ s, sSup ∅ ≤ f x) :\n    ⨆ i ∈ s, f i < a ↔ ∀ x ∈ s, f x < a := by\n  constructor\n  · intro h x hx\n    refine h.trans_le' (le_csSup ?_ ?_)\n    · classical\n      refine (((hs.image f).union (finite_singleton (sSup ∅))).subset ?_).bddAbove\n      intro\n      simp only [ciSup_eq_ite, dite_eq_ite, mem_range, union_singleton, mem_insert_iff, mem_image,\n        forall_exists_index]\n      intro x hx\n      split_ifs at hx\n      · exact Or.inr ⟨_, by assumption, hx⟩\n      · simp_all\n    · simp only [mem_range]\n      refine ⟨x, ?_⟩\n      simp [hx]\n  · intro H\n    have := hs.ciSup_mem_image _ h\n    simp only [mem_image] at this\n    obtain ⟨_, hmem, hx⟩ := this\n    rw [← hx]\n    exact H _ hmem\n\n"}
{"name":"Set.Finite.lt_ciInf_iff","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder α\na : α\ns : Set ι\nf : ι → α\nhs : s.Finite\nh : Exists fun x => And (Membership.mem s x) (LE.le (f x) (InfSet.sInf EmptyCollection.emptyCollection))\n⊢ Iff (LT.lt a (iInf fun i => iInf fun h => f i)) (∀ (x : ι), Membership.mem s x → LT.lt a (f x))","decl":"theorem Set.Finite.lt_ciInf_iff {s : Set ι} {f : ι → α} (hs : s.Finite)\n    (h : ∃ x ∈ s, f x ≤ sInf ∅) :\n    a < ⨅ i ∈ s, f i ↔ ∀ x ∈ s, a < f x := by\n  constructor\n  · intro h x hx\n    refine h.trans_le (csInf_le ?_ ?_)\n    · classical\n      refine (((hs.image f).union (finite_singleton (sInf ∅))).subset ?_).bddBelow\n      intro\n      simp only [ciInf_eq_ite, dite_eq_ite, mem_range, union_singleton, mem_insert_iff, mem_image,\n        forall_exists_index]\n      intro x hx\n      split_ifs at hx\n      · exact Or.inr ⟨_, by assumption, hx⟩\n      · simp_all\n    · simp only [mem_range]\n      refine ⟨x, ?_⟩\n      simp [hx]\n  · intro H\n    have := hs.ciInf_mem_image _ h\n    simp only [mem_image] at this\n    obtain ⟨_, hmem, hx⟩ := this\n    rw [← hx]\n    exact H _ hmem\n\n"}
{"name":"List.iSup_mem_map_of_exists_sSup_empty_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder α\nl : List ι\nf : ι → α\nh : Exists fun x => And (Membership.mem l x) (LE.le (SupSet.sSup EmptyCollection.emptyCollection) (f x))\n⊢ Membership.mem (List.map f l) (iSup fun x => iSup fun h => f x)","decl":"lemma List.iSup_mem_map_of_exists_sSup_empty_le {l : List ι} (f : ι → α)\n    (h : ∃ x ∈ l, sSup ∅ ≤ f x) :\n    ⨆ x ∈ l, f x ∈ l.map f := by\n  classical\n  simpa using l.toFinset.ciSup_mem_image f (by simpa using h)\n\n"}
{"name":"List.iInf_mem_map_of_exists_le_sInf_empty","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder α\nl : List ι\nf : ι → α\nh : Exists fun x => And (Membership.mem l x) (LE.le (f x) (InfSet.sInf EmptyCollection.emptyCollection))\n⊢ Membership.mem (List.map f l) (iInf fun x => iInf fun h => f x)","decl":"lemma List.iInf_mem_map_of_exists_le_sInf_empty {l : List ι} (f : ι → α)\n    (h : ∃ x ∈ l, f x ≤ sInf ∅) :\n    ⨅ x ∈ l, f x ∈ l.map f := by\n  classical\n  simpa using l.toFinset.ciInf_mem_image f (by simpa using h)\n\n"}
{"name":"Multiset.iSup_mem_map_of_exists_sSup_empty_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder α\ns : Multiset ι\nf : ι → α\nh : Exists fun x => And (Membership.mem s x) (LE.le (SupSet.sSup EmptyCollection.emptyCollection) (f x))\n⊢ Membership.mem (Multiset.map f s) (iSup fun x => iSup fun h => f x)","decl":"lemma Multiset.iSup_mem_map_of_exists_sSup_empty_le {s : Multiset ι} (f : ι → α)\n    (h : ∃ x ∈ s, sSup ∅ ≤ f x) :\n    ⨆ x ∈ s, f x ∈ s.map f := by\n  classical\n  simpa using s.toFinset.ciSup_mem_image f (by simpa using h)\n\n"}
{"name":"Multiset.iInf_mem_map_of_exists_le_sInf_empty","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder α\ns : Multiset ι\nf : ι → α\nh : Exists fun x => And (Membership.mem s x) (LE.le (f x) (InfSet.sInf EmptyCollection.emptyCollection))\n⊢ Membership.mem (Multiset.map f s) (iInf fun x => iInf fun h => f x)","decl":"lemma Multiset.iInf_mem_map_of_exists_le_sInf_empty {s : Multiset ι} (f : ι → α)\n    (h : ∃ x ∈ s, f x ≤ sInf ∅) :\n    ⨅ x ∈ s, f x ∈ s.map f := by\n  classical\n  simpa using s.toFinset.ciInf_mem_image f (by simpa using h)\n\n"}
{"name":"exists_eq_ciSup_of_finite","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : Nonempty ι\ninst✝ : Finite ι\nf : ι → α\n⊢ Exists fun i => Eq (f i) (iSup fun i => f i)","decl":"theorem exists_eq_ciSup_of_finite [Nonempty ι] [Finite ι] {f : ι → α} : ∃ i, f i = ⨆ i, f i :=\n  Nonempty.csSup_mem (range_nonempty f) (finite_range f)\n\n"}
{"name":"exists_eq_ciInf_of_finite","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : Nonempty ι\ninst✝ : Finite ι\nf : ι → α\n⊢ Exists fun i => Eq (f i) (iInf fun i => f i)","decl":"theorem exists_eq_ciInf_of_finite [Nonempty ι] [Finite ι] {f : ι → α} : ∃ i, f i = ⨅ i, f i :=\n  Nonempty.csInf_mem (range_nonempty f) (finite_range f)\n\n"}
{"name":"Finset.sup'_eq_csSup_image","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : ConditionallyCompleteLattice α\ns : Finset ι\nH : s.Nonempty\nf : ι → α\n⊢ Eq (s.sup' H f) (SupSet.sSup (Set.image f ↑s))","decl":"theorem sup'_eq_csSup_image (s : Finset ι) (H : s.Nonempty) (f : ι → α) :\n    s.sup' H f = sSup (f '' s) :=\n  eq_of_forall_ge_iff fun a => by\n    simp [csSup_le_iff (s.finite_toSet.image f).bddAbove (H.to_set.image f)]\n\n"}
{"name":"Finset.inf'_eq_csInf_image","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : ConditionallyCompleteLattice α\ns : Finset ι\nH : s.Nonempty\nf : ι → α\n⊢ Eq (s.inf' H f) (InfSet.sInf (Set.image f ↑s))","decl":"theorem inf'_eq_csInf_image (s : Finset ι) (H : s.Nonempty) (f : ι → α) :\n    s.inf' H f = sInf (f '' s) :=\n  sup'_eq_csSup_image (α := αᵒᵈ) _ H _\n\n"}
{"name":"Finset.sup'_id_eq_csSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"α : Type u_2\ninst✝ : ConditionallyCompleteLattice α\ns : Finset α\nhs : s.Nonempty\n⊢ Eq (s.sup' hs id) (SupSet.sSup ↑s)","decl":"theorem sup'_id_eq_csSup (s : Finset α) (hs) : s.sup' hs id = sSup s := by\n  rw [sup'_eq_csSup_image s hs, Set.image_id]\n\n"}
{"name":"Finset.inf'_id_eq_csInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"α : Type u_2\ninst✝ : ConditionallyCompleteLattice α\ns : Finset α\nhs : s.Nonempty\n⊢ Eq (s.inf' hs id) (InfSet.sInf ↑s)","decl":"theorem inf'_id_eq_csInf (s : Finset α) (hs) : s.inf' hs id = sInf s :=\n  sup'_id_eq_csSup (α := αᵒᵈ) _ hs\n\n"}
{"name":"Finset.sup'_univ_eq_ciSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : Fintype ι\ninst✝ : Nonempty ι\nf : ι → α\n⊢ Eq (Finset.univ.sup' ⋯ f) (iSup fun i => f i)","decl":"lemma sup'_univ_eq_ciSup (f : ι → α) : univ.sup' univ_nonempty f = ⨆ i, f i := by\n  simp [sup'_eq_csSup_image, iSup]\n\n"}
{"name":"Finset.inf'_univ_eq_ciInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : Fintype ι\ninst✝ : Nonempty ι\nf : ι → α\n⊢ Eq (Finset.univ.inf' ⋯ f) (iInf fun i => f i)","decl":"lemma inf'_univ_eq_ciInf (f : ι → α) : univ.inf' univ_nonempty f = ⨅ i, f i := by\n  simp [inf'_eq_csInf_image, iInf]\n\n"}
{"name":"Finset.sup_univ_eq_ciSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : ConditionallyCompleteLinearOrderBot α\ninst✝ : Fintype ι\nf : ι → α\n⊢ Eq (Finset.univ.sup f) (iSup fun i => f i)","decl":"lemma sup_univ_eq_ciSup [Fintype ι] (f : ι → α) : univ.sup f = ⨆ i, f i :=\n  le_antisymm\n    (Finset.sup_le fun _ _ => le_ciSup (finite_range _).bddAbove _)\n    (ciSup_le' fun _ => Finset.le_sup (mem_univ _))\n\n"}
{"name":"Finset.Nonempty.ciSup_eq_max'_image","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : ConditionallyCompleteLinearOrderBot α\nf : ι → α\ns : Finset ι\nh : s.Nonempty\nh' : optParam (Finset.image f s).Nonempty ⋯\n⊢ Eq (iSup fun i => iSup fun h => f i) ((Finset.image f s).max' h')","decl":"theorem Finset.Nonempty.ciSup_eq_max'_image {s : Finset ι} (h : s.Nonempty)\n    (h' : (s.image f).Nonempty := h.image f) :\n    ⨆ i ∈ s, f i = (s.image f).max' h' :=\n  s.ciSup_eq_max'_image _ (h.imp (by simp)) _\n\n"}
{"name":"Finset.Nonempty.ciSup_mem_image","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : ConditionallyCompleteLinearOrderBot α\nf : ι → α\ns : Finset ι\nh : s.Nonempty\n⊢ Membership.mem (Finset.image f s) (iSup fun i => iSup fun h => f i)","decl":"theorem Finset.Nonempty.ciSup_mem_image {s : Finset ι} (h : s.Nonempty) :\n    ⨆ i ∈ s, f i ∈ s.image f :=\n  s.ciSup_mem_image _ (h.imp (by simp))\n\n"}
{"name":"Set.Nonempty.ciSup_mem_image","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : ConditionallyCompleteLinearOrderBot α\nf : ι → α\ns : Set ι\nh : s.Nonempty\nhs : s.Finite\n⊢ Membership.mem (Set.image f s) (iSup fun i => iSup fun h => f i)","decl":"theorem Set.Nonempty.ciSup_mem_image {s : Set ι} (h : s.Nonempty) (hs : s.Finite) :\n    ⨆ i ∈ s, f i ∈ f '' s :=\n  hs.ciSup_mem_image _ (h.imp (by simp))\n\n"}
{"name":"Set.Nonempty.ciSup_lt_iff","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : ConditionallyCompleteLinearOrderBot α\ns : Set ι\na : α\nf : ι → α\nh : s.Nonempty\nhs : s.Finite\n⊢ Iff (LT.lt (iSup fun i => iSup fun h => f i) a) (∀ (x : ι), Membership.mem s x → LT.lt (f x) a)","decl":"theorem Set.Nonempty.ciSup_lt_iff {s : Set ι} {a : α} {f : ι → α} (h : s.Nonempty) (hs : s.Finite) :\n    ⨆ i ∈ s, f i < a ↔ ∀ x ∈ s, f x < a :=\n  hs.ciSup_lt_iff (h.imp (by simp))\n\n"}
{"name":"List.iSup_mem_map_of_ne_nil","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : ConditionallyCompleteLinearOrderBot α\nl : List ι\nf : ι → α\nh : Ne l List.nil\n⊢ Membership.mem (List.map f l) (iSup fun x => iSup fun h => f x)","decl":"lemma List.iSup_mem_map_of_ne_nil {l : List ι} (f : ι → α) (h : l ≠ []) :\n    ⨆ x ∈ l, f x ∈ l.map f :=\n  l.iSup_mem_map_of_exists_sSup_empty_le _ (by simpa using exists_mem_of_ne_nil _ h)\n\n"}
{"name":"Multiset.iSup_mem_map_of_ne_zero","module":"Mathlib.Order.ConditionallyCompleteLattice.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : ConditionallyCompleteLinearOrderBot α\ns : Multiset ι\nf : ι → α\nh : Ne s 0\n⊢ Membership.mem (Multiset.map f s) (iSup fun x => iSup fun h => f x)","decl":"lemma Multiset.iSup_mem_map_of_ne_zero {s : Multiset ι} (f : ι → α) (h : s ≠ 0) :\n    ⨆ x ∈ s, f x ∈ s.map f :=\n  s.iSup_mem_map_of_exists_sSup_empty_le _ (by simpa using exists_mem_of_ne_zero h)\n\n"}
