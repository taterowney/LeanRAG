{"name":"FreeLieAlgebra.Rel.brecOn","module":"Mathlib.Algebra.Lie.Free","initialProofState":"R : Type u\nX : Type v\ninst✝ : CommRing R\nmotive✝ : (a a_1 : FreeNonUnitalNonAssocAlgebra R X) → FreeLieAlgebra.Rel R X a a_1 → Prop\na✝¹ a✝ : FreeNonUnitalNonAssocAlgebra R X\nx✝ : FreeLieAlgebra.Rel R X a✝¹ a✝\nih✝ : ∀ (a a_1 : FreeNonUnitalNonAssocAlgebra R X) (x : FreeLieAlgebra.Rel R X a a_1), x.below → motive✝ a a_1 x\n⊢ motive✝ a✝¹ a✝ x✝","decl":"/-- The quotient of `lib R X` by the equivalence relation generated by this relation will give us\nthe free Lie algebra. -/\ninductive Rel : lib R X → lib R X → Prop\n  | lie_self (a : lib R X) : Rel (a * a) 0\n  | leibniz_lie (a b c : lib R X) : Rel (a * (b * c)) (a * b * c + b * (a * c))\n  | smul (t : R) {a b : lib R X} : Rel a b → Rel (t • a) (t • b)\n  | add_right {a b : lib R X} (c : lib R X) : Rel a b → Rel (a + c) (b + c)\n  | mul_left (a : lib R X) {b c : lib R X} : Rel b c → Rel (a * b) (a * c)\n  | mul_right {a b : lib R X} (c : lib R X) : Rel a b → Rel (a * c) (b * c)\n\n"}
{"name":"FreeLieAlgebra.Rel.addLeft","module":"Mathlib.Algebra.Lie.Free","initialProofState":"R : Type u\nX : Type v\ninst✝ : CommRing R\na b c : FreeNonUnitalNonAssocAlgebra R X\nh : FreeLieAlgebra.Rel R X b c\n⊢ FreeLieAlgebra.Rel R X (HAdd.hAdd a b) (HAdd.hAdd a c)","decl":"theorem Rel.addLeft (a : lib R X) {b c : lib R X} (h : Rel R X b c) : Rel R X (a + b) (a + c) := by\n  rw [add_comm _ b, add_comm _ c]; exact h.add_right _\n\n"}
{"name":"FreeLieAlgebra.Rel.neg","module":"Mathlib.Algebra.Lie.Free","initialProofState":"R : Type u\nX : Type v\ninst✝ : CommRing R\na b : FreeNonUnitalNonAssocAlgebra R X\nh : FreeLieAlgebra.Rel R X a b\n⊢ FreeLieAlgebra.Rel R X (Neg.neg a) (Neg.neg b)","decl":"theorem Rel.neg {a b : lib R X} (h : Rel R X a b) : Rel R X (-a) (-b) := by\n  simpa only [neg_one_smul] using h.smul (-1)\n\n"}
{"name":"FreeLieAlgebra.Rel.subLeft","module":"Mathlib.Algebra.Lie.Free","initialProofState":"R : Type u\nX : Type v\ninst✝ : CommRing R\na b c : FreeNonUnitalNonAssocAlgebra R X\nh : FreeLieAlgebra.Rel R X b c\n⊢ FreeLieAlgebra.Rel R X (HSub.hSub a b) (HSub.hSub a c)","decl":"theorem Rel.subLeft (a : lib R X) {b c : lib R X} (h : Rel R X b c) : Rel R X (a - b) (a - c) := by\n  simpa only [sub_eq_add_neg] using h.neg.addLeft a\n\n"}
{"name":"FreeLieAlgebra.Rel.subRight","module":"Mathlib.Algebra.Lie.Free","initialProofState":"R : Type u\nX : Type v\ninst✝ : CommRing R\na b c : FreeNonUnitalNonAssocAlgebra R X\nh : FreeLieAlgebra.Rel R X a b\n⊢ FreeLieAlgebra.Rel R X (HSub.hSub a c) (HSub.hSub b c)","decl":"theorem Rel.subRight {a b : lib R X} (c : lib R X) (h : Rel R X a b) : Rel R X (a - c) (b - c) := by\n  simpa only [sub_eq_add_neg] using h.add_right (-c)\n\n"}
{"name":"FreeLieAlgebra.Rel.smulOfTower","module":"Mathlib.Algebra.Lie.Free","initialProofState":"R : Type u\nX : Type v\ninst✝³ : CommRing R\nS : Type u_1\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S R\ninst✝ : IsScalarTower S R R\nt : S\na b : FreeNonUnitalNonAssocAlgebra R X\nh : FreeLieAlgebra.Rel R X a b\n⊢ FreeLieAlgebra.Rel R X (HSMul.hSMul t a) (HSMul.hSMul t b)","decl":"theorem Rel.smulOfTower {S : Type*} [Monoid S] [DistribMulAction S R] [IsScalarTower S R R] (t : S)\n    (a b : lib R X) (h : Rel R X a b) : Rel R X (t • a) (t • b) := by\n  rw [← smul_one_smul R t a, ← smul_one_smul R t b]\n  exact h.smul _\n\n"}
{"name":"FreeLieAlgebra.instIsCentralScalar","module":"Mathlib.Algebra.Lie.Free","initialProofState":"R : Type u\nX : Type v\ninst✝⁵ : CommRing R\nS : Type u_1\ninst✝⁴ : Monoid S\ninst✝³ : DistribMulAction S R\ninst✝² : DistribMulAction (MulOpposite S) R\ninst✝¹ : IsScalarTower S R R\ninst✝ : IsCentralScalar S R\n⊢ IsCentralScalar S (FreeLieAlgebra R X)","decl":"instance {S : Type*} [Monoid S] [DistribMulAction S R] [DistribMulAction Sᵐᵒᵖ R]\n    [IsScalarTower S R R] [IsCentralScalar S R] : IsCentralScalar S (FreeLieAlgebra R X) where\n  op_smul_eq_smul t := Quot.ind fun a => congr_arg (Quot.mk _) (op_smul_eq_smul t a)\n\n"}
{"name":"FreeLieAlgebra.liftAux_map_smul","module":"Mathlib.Algebra.Lie.Free","initialProofState":"R : Type u\nX : Type v\ninst✝² : CommRing R\nL : Type w\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nf : X → L\nt : R\na : FreeNonUnitalNonAssocAlgebra R X\n⊢ Eq ((FreeLieAlgebra.liftAux R f) (HSMul.hSMul t a)) (HSMul.hSMul t ((FreeLieAlgebra.liftAux R f) a))","decl":"theorem liftAux_map_smul (f : X → L) (t : R) (a : lib R X) :\n    liftAux R f (t • a) = t • liftAux R f a :=\n  NonUnitalAlgHom.map_smul _ t a\n\n"}
{"name":"FreeLieAlgebra.liftAux_map_add","module":"Mathlib.Algebra.Lie.Free","initialProofState":"R : Type u\nX : Type v\ninst✝² : CommRing R\nL : Type w\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nf : X → L\na b : FreeNonUnitalNonAssocAlgebra R X\n⊢ Eq ((FreeLieAlgebra.liftAux R f) (HAdd.hAdd a b)) (HAdd.hAdd ((FreeLieAlgebra.liftAux R f) a) ((FreeLieAlgebra.liftAux R f) b))","decl":"theorem liftAux_map_add (f : X → L) (a b : lib R X) :\n    liftAux R f (a + b) = liftAux R f a + liftAux R f b :=\n  NonUnitalAlgHom.map_add _ a b\n\n"}
{"name":"FreeLieAlgebra.liftAux_map_mul","module":"Mathlib.Algebra.Lie.Free","initialProofState":"R : Type u\nX : Type v\ninst✝² : CommRing R\nL : Type w\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nf : X → L\na b : FreeNonUnitalNonAssocAlgebra R X\n⊢ Eq ((FreeLieAlgebra.liftAux R f) (HMul.hMul a b)) (Bracket.bracket ((FreeLieAlgebra.liftAux R f) a) ((FreeLieAlgebra.liftAux R f) b))","decl":"theorem liftAux_map_mul (f : X → L) (a b : lib R X) :\n    liftAux R f (a * b) = ⁅liftAux R f a, liftAux R f b⁆ :=\n  NonUnitalAlgHom.map_mul _ a b\n\n"}
{"name":"FreeLieAlgebra.liftAux_spec","module":"Mathlib.Algebra.Lie.Free","initialProofState":"R : Type u\nX : Type v\ninst✝² : CommRing R\nL : Type w\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nf : X → L\na b : FreeNonUnitalNonAssocAlgebra R X\nh : FreeLieAlgebra.Rel R X a b\n⊢ Eq ((FreeLieAlgebra.liftAux R f) a) ((FreeLieAlgebra.liftAux R f) b)","decl":"theorem liftAux_spec (f : X → L) (a b : lib R X) (h : FreeLieAlgebra.Rel R X a b) :\n    liftAux R f a = liftAux R f b := by\n  induction h with\n  | lie_self a' => simp only [liftAux_map_mul, NonUnitalAlgHom.map_zero, lie_self]\n  | leibniz_lie a' b' c' =>\n    simp only [liftAux_map_mul, liftAux_map_add, sub_add_cancel, lie_lie]\n  | smul b' _ h₂ => simp only [liftAux_map_smul, h₂]\n  | add_right c' _ h₂ => simp only [liftAux_map_add, h₂]\n  | mul_left c' _ h₂ => simp only [liftAux_map_mul, h₂]\n  | mul_right c' _ h₂ => simp only [liftAux_map_mul, h₂]\n\n"}
{"name":"FreeLieAlgebra.lift_symm_apply","module":"Mathlib.Algebra.Lie.Free","initialProofState":"R : Type u\nX : Type v\ninst✝² : CommRing R\nL : Type w\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nF : LieHom R (FreeLieAlgebra R X) L\n⊢ Eq ((FreeLieAlgebra.lift R).symm F) (Function.comp (⇑F) (FreeLieAlgebra.of R))","decl":"@[simp]\ntheorem lift_symm_apply (F : FreeLieAlgebra R X →ₗ⁅R⁆ L) : (lift R).symm F = F ∘ of R := rfl\n\n"}
{"name":"FreeLieAlgebra.of_comp_lift","module":"Mathlib.Algebra.Lie.Free","initialProofState":"R : Type u\nX : Type v\ninst✝² : CommRing R\nL : Type w\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nf : X → L\n⊢ Eq (Function.comp (⇑((FreeLieAlgebra.lift R) f)) (FreeLieAlgebra.of R)) f","decl":"@[simp]\ntheorem of_comp_lift (f : X → L) : lift R f ∘ of R = f := (lift R).left_inv f\n\n"}
{"name":"FreeLieAlgebra.lift_unique","module":"Mathlib.Algebra.Lie.Free","initialProofState":"R : Type u\nX : Type v\ninst✝² : CommRing R\nL : Type w\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nf : X → L\ng : LieHom R (FreeLieAlgebra R X) L\n⊢ Iff (Eq (Function.comp (⇑g) (FreeLieAlgebra.of R)) f) (Eq g ((FreeLieAlgebra.lift R) f))","decl":"@[simp]\ntheorem lift_unique (f : X → L) (g : FreeLieAlgebra R X →ₗ⁅R⁆ L) : g ∘ of R = f ↔ g = lift R f :=\n  (lift R).symm_apply_eq\n\n"}
{"name":"FreeLieAlgebra.lift_of_apply","module":"Mathlib.Algebra.Lie.Free","initialProofState":"R : Type u\nX : Type v\ninst✝² : CommRing R\nL : Type w\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nf : X → L\nx : X\n⊢ Eq (((FreeLieAlgebra.lift R) f) (FreeLieAlgebra.of R x)) (f x)","decl":"@[simp]\ntheorem lift_of_apply (f : X → L) (x) : lift R f (of R x) = f x := by\n  rw [← @Function.comp_apply _ _ _ (lift R f) (of R) x, of_comp_lift]\n\n"}
{"name":"FreeLieAlgebra.lift_comp_of","module":"Mathlib.Algebra.Lie.Free","initialProofState":"R : Type u\nX : Type v\ninst✝² : CommRing R\nL : Type w\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nF : LieHom R (FreeLieAlgebra R X) L\n⊢ Eq ((FreeLieAlgebra.lift R) (Function.comp (⇑F) (FreeLieAlgebra.of R))) F","decl":"@[simp]\ntheorem lift_comp_of (F : FreeLieAlgebra R X →ₗ⁅R⁆ L) : lift R (F ∘ of R) = F := by\n  rw [← lift_symm_apply]; exact (lift R).apply_symm_apply F\n\n"}
{"name":"FreeLieAlgebra.hom_ext_iff","module":"Mathlib.Algebra.Lie.Free","initialProofState":"R : Type u\nX : Type v\ninst✝² : CommRing R\nL : Type w\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nF₁ F₂ : LieHom R (FreeLieAlgebra R X) L\n⊢ Iff (Eq F₁ F₂) (∀ (x : X), Eq (F₁ (FreeLieAlgebra.of R x)) (F₂ (FreeLieAlgebra.of R x)))","decl":"@[ext]\ntheorem hom_ext {F₁ F₂ : FreeLieAlgebra R X →ₗ⁅R⁆ L} (h : ∀ x, F₁ (of R x) = F₂ (of R x)) :\n    F₁ = F₂ :=\n  have h' : (lift R).symm F₁ = (lift R).symm F₂ := by ext; simp [h]\n  (lift R).symm.injective h'\n\n"}
{"name":"FreeLieAlgebra.hom_ext","module":"Mathlib.Algebra.Lie.Free","initialProofState":"R : Type u\nX : Type v\ninst✝² : CommRing R\nL : Type w\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nF₁ F₂ : LieHom R (FreeLieAlgebra R X) L\nh : ∀ (x : X), Eq (F₁ (FreeLieAlgebra.of R x)) (F₂ (FreeLieAlgebra.of R x))\n⊢ Eq F₁ F₂","decl":"@[ext]\ntheorem hom_ext {F₁ F₂ : FreeLieAlgebra R X →ₗ⁅R⁆ L} (h : ∀ x, F₁ (of R x) = F₂ (of R x)) :\n    F₁ = F₂ :=\n  have h' : (lift R).symm F₁ = (lift R).symm F₂ := by ext; simp [h]\n  (lift R).symm.injective h'\n\n"}
{"name":"FreeLieAlgebra.universalEnvelopingEquivFreeAlgebra_apply","module":"Mathlib.Algebra.Lie.Free","initialProofState":"R : Type u\nX : Type v\ninst✝ : CommRing R\na : UniversalEnvelopingAlgebra R (FreeLieAlgebra R X)\n⊢ Eq ((FreeLieAlgebra.universalEnvelopingEquivFreeAlgebra R X) a) (((UniversalEnvelopingAlgebra.lift R) ((FreeLieAlgebra.lift R) (FreeAlgebra.ι R))) a)","decl":"/-- The universal enveloping algebra of the free Lie algebra is just the free unital associative\nalgebra. -/\n@[simps!]\ndef universalEnvelopingEquivFreeAlgebra :\n    UniversalEnvelopingAlgebra R (FreeLieAlgebra R X) ≃ₐ[R] FreeAlgebra R X :=\n  AlgEquiv.ofAlgHom (UniversalEnvelopingAlgebra.lift R <| FreeLieAlgebra.lift R <| FreeAlgebra.ι R)\n    (FreeAlgebra.lift R <| UniversalEnvelopingAlgebra.ι R ∘ FreeLieAlgebra.of R) (by ext; simp)\n    (by ext; simp)\n\n"}
{"name":"FreeLieAlgebra.universalEnvelopingEquivFreeAlgebra_symm_apply","module":"Mathlib.Algebra.Lie.Free","initialProofState":"R : Type u\nX : Type v\ninst✝ : CommRing R\na : FreeAlgebra R X\n⊢ Eq ((FreeLieAlgebra.universalEnvelopingEquivFreeAlgebra R X).symm a) (((FreeAlgebra.lift R) (Function.comp (⇑(UniversalEnvelopingAlgebra.ι R)) (FreeLieAlgebra.of R))) a)","decl":"/-- The universal enveloping algebra of the free Lie algebra is just the free unital associative\nalgebra. -/\n@[simps!]\ndef universalEnvelopingEquivFreeAlgebra :\n    UniversalEnvelopingAlgebra R (FreeLieAlgebra R X) ≃ₐ[R] FreeAlgebra R X :=\n  AlgEquiv.ofAlgHom (UniversalEnvelopingAlgebra.lift R <| FreeLieAlgebra.lift R <| FreeAlgebra.ι R)\n    (FreeAlgebra.lift R <| UniversalEnvelopingAlgebra.ι R ∘ FreeLieAlgebra.of R) (by ext; simp)\n    (by ext; simp)\n\n"}
