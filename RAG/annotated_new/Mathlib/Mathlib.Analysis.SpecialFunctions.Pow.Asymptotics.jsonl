{"name":"tendsto_rpow_atTop","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"y : Real\nhy : LT.lt 0 y\n‚ä¢ Filter.Tendsto (fun x => HPow.hPow x y) Filter.atTop Filter.atTop","decl":"/-- The function `x ^ y` tends to `+‚àû` at `+‚àû` for any positive real `y`. -/\ntheorem tendsto_rpow_atTop {y : ‚Ñù} (hy : 0 < y) : Tendsto (fun x : ‚Ñù => x ^ y) atTop atTop := by\n  rw [tendsto_atTop_atTop]\n  intro b\n  use max b 0 ^ (1 / y)\n  intro x hx\n  exact\n    le_of_max_le_left\n      (by\n        convert rpow_le_rpow (rpow_nonneg (le_max_right b 0) (1 / y)) hx (le_of_lt hy)\n          using 1\n        rw [‚Üê rpow_mul (le_max_right b 0), (eq_div_iff (ne_of_gt hy)).mp rfl, Real.rpow_one])\n\n"}
{"name":"tendsto_rpow_neg_atTop","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"y : Real\nhy : LT.lt 0 y\n‚ä¢ Filter.Tendsto (fun x => HPow.hPow x (Neg.neg y)) Filter.atTop (nhds 0)","decl":"/-- The function `x ^ (-y)` tends to `0` at `+‚àû` for any positive real `y`. -/\ntheorem tendsto_rpow_neg_atTop {y : ‚Ñù} (hy : 0 < y) : Tendsto (fun x : ‚Ñù => x ^ (-y)) atTop (ùìù 0) :=\n  Tendsto.congr' (eventuallyEq_of_mem (Ioi_mem_atTop 0) fun _ hx => (rpow_neg (le_of_lt hx) y).symm)\n    (tendsto_rpow_atTop hy).inv_tendsto_atTop\n\n"}
{"name":"tendsto_rpow_atTop_of_base_lt_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"b : Real\nhb‚ÇÄ : LT.lt (-1) b\nhb‚ÇÅ : LT.lt b 1\n‚ä¢ Filter.Tendsto (fun x => HPow.hPow b x) Filter.atTop (nhds 0)","decl":"open Asymptotics in\nlemma tendsto_rpow_atTop_of_base_lt_one (b : ‚Ñù) (hb‚ÇÄ : -1 < b) (hb‚ÇÅ : b < 1) :\n    Tendsto (b ^ ¬∑ : ‚Ñù ‚Üí ‚Ñù) atTop (ùìù (0 : ‚Ñù)) := by\n  rcases lt_trichotomy b 0 with hb|rfl|hb\n  case inl => -- b < 0\n    simp_rw [Real.rpow_def_of_nonpos hb.le, hb.ne, ite_false]\n    rw [‚Üê isLittleO_const_iff (c := (1 : ‚Ñù)) one_ne_zero, (one_mul (1 : ‚Ñù)).symm]\n    refine IsLittleO.mul_isBigO ?exp ?cos\n    case exp =>\n      rw [isLittleO_const_iff one_ne_zero]\n      refine tendsto_exp_atBot.comp <| (tendsto_const_mul_atBot_of_neg ?_).mpr tendsto_id\n      rw [‚Üê log_neg_eq_log, log_neg_iff (by linarith)]\n      linarith\n    case cos =>\n      rw [isBigO_iff]\n      exact ‚ü®1, Eventually.of_forall fun x => by simp [Real.abs_cos_le_one]‚ü©\n  case inr.inl => -- b = 0\n    refine Tendsto.mono_right ?_ (Iff.mpr pure_le_nhds_iff rfl)\n    rw [tendsto_pure]\n    filter_upwards [eventually_ne_atTop 0] with _ hx\n    simp [hx]\n  case inr.inr => -- b > 0\n    simp_rw [Real.rpow_def_of_pos hb]\n    refine tendsto_exp_atBot.comp <| (tendsto_const_mul_atBot_of_neg ?_).mpr tendsto_id\n    exact (log_neg_iff hb).mpr hb‚ÇÅ\n\n"}
{"name":"tendsto_rpow_atTop_of_base_gt_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"b : Real\nhb : LT.lt 1 b\n‚ä¢ Filter.Tendsto (fun x => HPow.hPow b x) Filter.atBot (nhds 0)","decl":"lemma tendsto_rpow_atTop_of_base_gt_one (b : ‚Ñù) (hb : 1 < b) :\n    Tendsto (b ^ ¬∑ : ‚Ñù ‚Üí ‚Ñù) atBot (ùìù (0 : ‚Ñù)) := by\n  simp_rw [Real.rpow_def_of_pos (by positivity : 0 < b)]\n  refine tendsto_exp_atBot.comp <| (tendsto_const_mul_atBot_of_pos ?_).mpr tendsto_id\n  exact (log_pos_iff (by positivity)).mpr <| by aesop\n\n"}
{"name":"tendsto_rpow_atBot_of_base_lt_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"b : Real\nhb‚ÇÄ : LT.lt 0 b\nhb‚ÇÅ : LT.lt b 1\n‚ä¢ Filter.Tendsto (fun x => HPow.hPow b x) Filter.atBot Filter.atTop","decl":"lemma tendsto_rpow_atBot_of_base_lt_one (b : ‚Ñù) (hb‚ÇÄ : 0 < b) (hb‚ÇÅ : b < 1) :\n    Tendsto (b ^ ¬∑ : ‚Ñù ‚Üí ‚Ñù) atBot atTop := by\n  simp_rw [Real.rpow_def_of_pos (by positivity : 0 < b)]\n  refine tendsto_exp_atTop.comp <| (tendsto_const_mul_atTop_iff_neg <| tendsto_id (Œ± := ‚Ñù)).mpr ?_\n  exact (log_neg_iff hb‚ÇÄ).mpr hb‚ÇÅ\n\n"}
{"name":"tendsto_rpow_atBot_of_base_gt_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"b : Real\nhb : LT.lt 1 b\n‚ä¢ Filter.Tendsto (fun x => HPow.hPow b x) Filter.atBot (nhds 0)","decl":"lemma tendsto_rpow_atBot_of_base_gt_one (b : ‚Ñù) (hb : 1 < b) :\n    Tendsto (b ^ ¬∑ : ‚Ñù ‚Üí ‚Ñù) atBot (ùìù 0) := by\n  simp_rw [Real.rpow_def_of_pos (by positivity : 0 < b)]\n  refine tendsto_exp_atBot.comp <| (tendsto_const_mul_atBot_iff_pos <| tendsto_id (Œ± := ‚Ñù)).mpr ?_\n  exact (log_pos_iff (by positivity)).mpr <| by aesop\n\n\n"}
{"name":"tendsto_rpow_div_mul_add","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"a b c : Real\nhb : Ne 0 b\n‚ä¢ Filter.Tendsto (fun x => HPow.hPow x (HDiv.hDiv a (HAdd.hAdd (HMul.hMul b x) c))) Filter.atTop (nhds 1)","decl":"/-- The function `x ^ (a / (b * x + c))` tends to `1` at `+‚àû`, for any real numbers `a`, `b`, and\n`c` such that `b` is nonzero. -/\ntheorem tendsto_rpow_div_mul_add (a b c : ‚Ñù) (hb : 0 ‚â† b) :\n    Tendsto (fun x => x ^ (a / (b * x + c))) atTop (ùìù 1) := by\n  refine\n    Tendsto.congr' ?_\n      ((tendsto_exp_nhds_zero_nhds_one.comp\n            (by\n              simpa only [mul_zero, pow_one] using\n                (tendsto_const_nhds (x := a)).mul\n                  (tendsto_div_pow_mul_exp_add_atTop b c 1 hb))).comp\n        tendsto_log_atTop)\n  apply eventuallyEq_of_mem (Ioi_mem_atTop (0 : ‚Ñù))\n  intro x hx\n  simp only [Set.mem_Ioi, Function.comp_apply] at hx ‚ä¢\n  rw [exp_log hx, ‚Üê exp_log (rpow_pos_of_pos hx (a / (b * x + c))), log_rpow hx (a / (b * x + c))]\n  field_simp\n\n"}
{"name":"tendsto_rpow_div","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"‚ä¢ Filter.Tendsto (fun x => HPow.hPow x (HDiv.hDiv 1 x)) Filter.atTop (nhds 1)","decl":"/-- The function `x ^ (1 / x)` tends to `1` at `+‚àû`. -/\ntheorem tendsto_rpow_div : Tendsto (fun x => x ^ ((1 : ‚Ñù) / x)) atTop (ùìù 1) := by\n  convert tendsto_rpow_div_mul_add (1 : ‚Ñù) _ (0 : ‚Ñù) zero_ne_one\n  ring\n\n"}
{"name":"tendsto_rpow_neg_div","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"‚ä¢ Filter.Tendsto (fun x => HPow.hPow x (HDiv.hDiv (-1) x)) Filter.atTop (nhds 1)","decl":"/-- The function `x ^ (-1 / x)` tends to `1` at `+‚àû`. -/\ntheorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(1 : ‚Ñù) / x)) atTop (ùìù 1) := by\n  convert tendsto_rpow_div_mul_add (-(1 : ‚Ñù)) _ (0 : ‚Ñù) zero_ne_one\n  ring\n\n"}
{"name":"tendsto_exp_div_rpow_atTop","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"s : Real\n‚ä¢ Filter.Tendsto (fun x => HDiv.hDiv (Real.exp x) (HPow.hPow x s)) Filter.atTop Filter.atTop","decl":"/-- The function `exp(x) / x ^ s` tends to `+‚àû` at `+‚àû`, for any real number `s`. -/\ntheorem tendsto_exp_div_rpow_atTop (s : ‚Ñù) : Tendsto (fun x : ‚Ñù => exp x / x ^ s) atTop atTop := by\n  cases' archimedean_iff_nat_lt.1 Real.instArchimedean s with n hn\n  refine tendsto_atTop_mono' _ ?_ (tendsto_exp_div_pow_atTop n)\n  filter_upwards [eventually_gt_atTop (0 : ‚Ñù), eventually_ge_atTop (1 : ‚Ñù)] with x hx‚ÇÄ hx‚ÇÅ\n  gcongr\n  simpa using rpow_le_rpow_of_exponent_le hx‚ÇÅ hn.le\n\n"}
{"name":"tendsto_exp_mul_div_rpow_atTop","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"s b : Real\nhb : LT.lt 0 b\n‚ä¢ Filter.Tendsto (fun x => HDiv.hDiv (Real.exp (HMul.hMul b x)) (HPow.hPow x s)) Filter.atTop Filter.atTop","decl":"/-- The function `exp (b * x) / x ^ s` tends to `+‚àû` at `+‚àû`, for any real `s` and `b > 0`. -/\ntheorem tendsto_exp_mul_div_rpow_atTop (s : ‚Ñù) (b : ‚Ñù) (hb : 0 < b) :\n    Tendsto (fun x : ‚Ñù => exp (b * x) / x ^ s) atTop atTop := by\n  refine ((tendsto_rpow_atTop hb).comp (tendsto_exp_div_rpow_atTop (s / b))).congr' ?_\n  filter_upwards [eventually_ge_atTop (0 : ‚Ñù)] with x hx‚ÇÄ\n  simp [Real.div_rpow, (exp_pos x).le, rpow_nonneg, ‚Üê Real.rpow_mul, ‚Üê exp_mul,\n    mul_comm x, hb.ne', *]\n\n"}
{"name":"tendsto_rpow_mul_exp_neg_mul_atTop_nhds_zero","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"s b : Real\nhb : LT.lt 0 b\n‚ä¢ Filter.Tendsto (fun x => HMul.hMul (HPow.hPow x s) (Real.exp (HMul.hMul (Neg.neg b) x))) Filter.atTop (nhds 0)","decl":"/-- The function `x ^ s * exp (-b * x)` tends to `0` at `+‚àû`, for any real `s` and `b > 0`. -/\ntheorem tendsto_rpow_mul_exp_neg_mul_atTop_nhds_zero (s : ‚Ñù) (b : ‚Ñù) (hb : 0 < b) :\n    Tendsto (fun x : ‚Ñù => x ^ s * exp (-b * x)) atTop (ùìù 0) := by\n  refine (tendsto_exp_mul_div_rpow_atTop s b hb).inv_tendsto_atTop.congr' ?_\n  filter_upwards with x using by simp [exp_neg, inv_div, div_eq_mul_inv _ (exp _)]\n\n"}
{"name":"NNReal.tendsto_rpow_atTop","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"y : Real\nhy : LT.lt 0 y\n‚ä¢ Filter.Tendsto (fun x => HPow.hPow x y) Filter.atTop Filter.atTop","decl":"nonrec theorem NNReal.tendsto_rpow_atTop {y : ‚Ñù} (hy : 0 < y) :\n    Tendsto (fun x : ‚Ñù‚â•0 => x ^ y) atTop atTop := by\n  rw [Filter.tendsto_atTop_atTop]\n  intro b\n  obtain ‚ü®c, hc‚ü© := tendsto_atTop_atTop.mp (tendsto_rpow_atTop hy) b\n  use c.toNNReal\n  intro a ha\n  exact mod_cast hc a (Real.toNNReal_le_iff_le_coe.mp ha)\n\n"}
{"name":"ENNReal.tendsto_rpow_at_top","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"y : Real\nhy : LT.lt 0 y\n‚ä¢ Filter.Tendsto (fun x => HPow.hPow x y) (nhds Top.top) (nhds Top.top)","decl":"theorem ENNReal.tendsto_rpow_at_top {y : ‚Ñù} (hy : 0 < y) :\n    Tendsto (fun x : ‚Ñù‚â•0‚àû => x ^ y) (ùìù ‚ä§) (ùìù ‚ä§) := by\n  rw [ENNReal.tendsto_nhds_top_iff_nnreal]\n  intro x\n  obtain ‚ü®c, _, hc‚ü© :=\n    (atTop_basis_Ioi.tendsto_iff atTop_basis_Ioi).mp (NNReal.tendsto_rpow_atTop hy) x trivial\n  have hc' : Set.Ioi ‚Üëc ‚àà ùìù (‚ä§ : ‚Ñù‚â•0‚àû) := Ioi_mem_nhds ENNReal.coe_lt_top\n  filter_upwards [hc'] with a ha\n  by_cases ha' : a = ‚ä§\n  ¬∑ simp [ha', hy]\n  lift a to ‚Ñù‚â•0 using ha'\n  -- Porting note: reduced defeq abuse\n  simp only [Set.mem_Ioi, coe_lt_coe] at ha hc\n  rw [‚Üê ENNReal.coe_rpow_of_nonneg _ hy.le]\n  exact mod_cast hc a ha\n\n"}
{"name":"Complex.isTheta_exp_arg_mul_im","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf g : Œ± ‚Üí Complex\nhl : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l fun x => abs (g x).im\n‚ä¢ Asymptotics.IsTheta l (fun x => Real.exp (HMul.hMul (f x).arg (g x).im)) fun x => 1","decl":"theorem isTheta_exp_arg_mul_im (hl : IsBoundedUnder (¬∑ ‚â§ ¬∑) l fun x => |(g x).im|) :\n    (fun x => Real.exp (arg (f x) * im (g x))) =Œò[l] fun _ => (1 : ‚Ñù) := by\n  rcases hl with ‚ü®b, hb‚ü©\n  refine Real.isTheta_exp_comp_one.2 ‚ü®œÄ * b, ?_‚ü©\n  rw [eventually_map] at hb ‚ä¢\n  refine hb.mono fun x hx => ?_\n  rw [abs_mul]\n  exact mul_le_mul (abs_arg_le_pi _) hx (abs_nonneg _) Real.pi_pos.le\n\n"}
{"name":"Complex.isBigO_cpow_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf g : Œ± ‚Üí Complex\nhl : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l fun x => abs (g x).im\n‚ä¢ Asymptotics.IsBigO l (fun x => HPow.hPow (f x) (g x)) fun x => HPow.hPow (Complex.abs (f x)) (g x).re","decl":"theorem isBigO_cpow_rpow (hl : IsBoundedUnder (¬∑ ‚â§ ¬∑) l fun x => |(g x).im|) :\n    (fun x => f x ^ g x) =O[l] fun x => abs (f x) ^ (g x).re :=\n  calc\n    (fun x => f x ^ g x) =O[l]\n        (show Œ± ‚Üí ‚Ñù from fun x => abs (f x) ^ (g x).re / Real.exp (arg (f x) * im (g x))) :=\n      isBigO_of_le _ fun _ => (abs_cpow_le _ _).trans (le_abs_self _)\n    _ =Œò[l] (show Œ± ‚Üí ‚Ñù from fun x => abs (f x) ^ (g x).re / (1 : ‚Ñù)) :=\n      ((isTheta_refl _ _).div (isTheta_exp_arg_mul_im hl))\n    _ =·∂†[l] (show Œ± ‚Üí ‚Ñù from fun x => abs (f x) ^ (g x).re) := by\n      simp only [ofReal_one, div_one]\n      rfl\n\n"}
{"name":"Complex.isTheta_cpow_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf g : Œ± ‚Üí Complex\nhl_im : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l fun x => abs (g x).im\nhl : Filter.Eventually (fun x => Eq (f x) 0 ‚Üí Eq (g x).re 0 ‚Üí Eq (g x) 0) l\n‚ä¢ Asymptotics.IsTheta l (fun x => HPow.hPow (f x) (g x)) fun x => HPow.hPow (Complex.abs (f x)) (g x).re","decl":"theorem isTheta_cpow_rpow (hl_im : IsBoundedUnder (¬∑ ‚â§ ¬∑) l fun x => |(g x).im|)\n    (hl : ‚àÄ·∂† x in l, f x = 0 ‚Üí re (g x) = 0 ‚Üí g x = 0) :\n    (fun x => f x ^ g x) =Œò[l] fun x => abs (f x) ^ (g x).re :=\n  calc\n    (fun x => f x ^ g x) =Œò[l]\n        (fun x => abs (f x) ^ (g x).re / Real.exp (arg (f x) * im (g x))) :=\n      .of_norm_eventuallyEq <| hl.mono fun _ => abs_cpow_of_imp\n    _ =Œò[l] fun x => abs (f x) ^ (g x).re / (1 : ‚Ñù) :=\n      (isTheta_refl _ _).div (isTheta_exp_arg_mul_im hl_im)\n    _ =·∂†[l] (fun x => abs (f x) ^ (g x).re) := by\n      simp only [ofReal_one, div_one]\n      rfl\n\n"}
{"name":"Complex.isTheta_cpow_const_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf : Œ± ‚Üí Complex\nb : Complex\nhl : Eq b.re 0 ‚Üí Ne b 0 ‚Üí Filter.Eventually (fun x => Ne (f x) 0) l\n‚ä¢ Asymptotics.IsTheta l (fun x => HPow.hPow (f x) b) fun x => HPow.hPow (Complex.abs (f x)) b.re","decl":"theorem isTheta_cpow_const_rpow {b : ‚ÑÇ} (hl : b.re = 0 ‚Üí b ‚â† 0 ‚Üí ‚àÄ·∂† x in l, f x ‚â† 0) :\n    (fun x => f x ^ b) =Œò[l] fun x => abs (f x) ^ b.re :=\n  isTheta_cpow_rpow isBoundedUnder_const <| by\n    simpa only [eventually_imp_distrib_right, not_imp_not, Imp.swap (a := b.re = 0)] using hl\n\n"}
{"name":"Asymptotics.IsBigOWith.rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"Œ± : Type u_1\nr c : Real\nl : Filter Œ±\nf g : Œ± ‚Üí Real\nh : Asymptotics.IsBigOWith c l f g\nhc : LE.le 0 c\nhr : LE.le 0 r\nhg : l.EventuallyLE 0 g\n‚ä¢ Asymptotics.IsBigOWith (HPow.hPow c r) l (fun x => HPow.hPow (f x) r) fun x => HPow.hPow (g x) r","decl":"theorem IsBigOWith.rpow (h : IsBigOWith c l f g) (hc : 0 ‚â§ c) (hr : 0 ‚â§ r) (hg : 0 ‚â§·∂†[l] g) :\n    IsBigOWith (c ^ r) l (fun x => f x ^ r) fun x => g x ^ r := by\n  apply IsBigOWith.of_bound\n  filter_upwards [hg, h.bound] with x hgx hx\n  calc\n    |f x ^ r| ‚â§ |f x| ^ r := abs_rpow_le_abs_rpow _ _\n    _ ‚â§ (c * |g x|) ^ r := rpow_le_rpow (abs_nonneg _) hx hr\n    _ = c ^ r * |g x ^ r| := by rw [mul_rpow hc (abs_nonneg _), abs_rpow_of_nonneg hgx]\n\n"}
{"name":"Asymptotics.IsBigO.rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"Œ± : Type u_1\nr : Real\nl : Filter Œ±\nf g : Œ± ‚Üí Real\nhr : LE.le 0 r\nhg : l.EventuallyLE 0 g\nh : Asymptotics.IsBigO l f g\n‚ä¢ Asymptotics.IsBigO l (fun x => HPow.hPow (f x) r) fun x => HPow.hPow (g x) r","decl":"theorem IsBigO.rpow (hr : 0 ‚â§ r) (hg : 0 ‚â§·∂†[l] g) (h : f =O[l] g) :\n    (fun x => f x ^ r) =O[l] fun x => g x ^ r :=\n  let ‚ü®_, hc, h'‚ü© := h.exists_nonneg\n  (h'.rpow hc hr hg).isBigO\n\n"}
{"name":"Asymptotics.IsTheta.rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"Œ± : Type u_1\nr : Real\nl : Filter Œ±\nf g : Œ± ‚Üí Real\nhr : LE.le 0 r\nhf : l.EventuallyLE 0 f\nhg : l.EventuallyLE 0 g\nh : Asymptotics.IsTheta l f g\n‚ä¢ Asymptotics.IsTheta l (fun x => HPow.hPow (f x) r) fun x => HPow.hPow (g x) r","decl":"theorem IsTheta.rpow (hr : 0 ‚â§ r) (hf : 0 ‚â§·∂†[l] f) (hg : 0 ‚â§·∂†[l] g) (h : f =Œò[l] g) :\n    (fun x => f x ^ r) =Œò[l] fun x => g x ^ r :=\n  ‚ü®h.1.rpow hr hg, h.2.rpow hr hf‚ü©\n\n"}
{"name":"Asymptotics.IsLittleO.rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"Œ± : Type u_1\nr : Real\nl : Filter Œ±\nf g : Œ± ‚Üí Real\nhr : LT.lt 0 r\nhg : l.EventuallyLE 0 g\nh : Asymptotics.IsLittleO l f g\n‚ä¢ Asymptotics.IsLittleO l (fun x => HPow.hPow (f x) r) fun x => HPow.hPow (g x) r","decl":"theorem IsLittleO.rpow (hr : 0 < r) (hg : 0 ‚â§·∂†[l] g) (h : f =o[l] g) :\n    (fun x => f x ^ r) =o[l] fun x => g x ^ r := by\n  refine .of_isBigOWith fun c hc ‚Ü¶ ?_\n  rw [‚Üê rpow_inv_rpow hc.le hr.ne']\n  refine (h.forall_isBigOWith ?_).rpow ?_ ?_ hg <;> positivity\n\n"}
{"name":"Asymptotics.IsBigO.sqrt","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf g : Œ± ‚Üí Real\nhfg : Asymptotics.IsBigO l f g\nhg : l.EventuallyLE 0 g\n‚ä¢ Asymptotics.IsBigO l (fun x => (f x).sqrt) fun x => (g x).sqrt","decl":"protected lemma IsBigO.sqrt (hfg : f =O[l] g) (hg : 0 ‚â§·∂†[l] g) :\n    (Real.sqrt <| f ¬∑) =O[l] (Real.sqrt <| g ¬∑) := by\n  simpa [Real.sqrt_eq_rpow] using hfg.rpow one_half_pos.le hg\n\n"}
{"name":"Asymptotics.IsLittleO.sqrt","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf g : Œ± ‚Üí Real\nhfg : Asymptotics.IsLittleO l f g\nhg : l.EventuallyLE 0 g\n‚ä¢ Asymptotics.IsLittleO l (fun x => (f x).sqrt) fun x => (g x).sqrt","decl":"protected lemma IsLittleO.sqrt (hfg : f =o[l] g) (hg : 0 ‚â§·∂†[l] g) :\n    (Real.sqrt <| f ¬∑) =o[l] (Real.sqrt <| g ¬∑) := by\n  simpa [Real.sqrt_eq_rpow] using hfg.rpow one_half_pos hg\n\n"}
{"name":"Asymptotics.IsTheta.sqrt","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf g : Œ± ‚Üí Real\nhfg : Asymptotics.IsTheta l f g\nhf : l.EventuallyLE 0 f\nhg : l.EventuallyLE 0 g\n‚ä¢ Asymptotics.IsTheta l (fun x => (f x).sqrt) fun x => (g x).sqrt","decl":"protected lemma IsTheta.sqrt (hfg : f =Œò[l] g) (hf : 0 ‚â§·∂†[l] f) (hg : 0 ‚â§·∂†[l] g) :\n    (Real.sqrt <| f ¬∑) =Œò[l] (Real.sqrt <| g ¬∑) :=\n  ‚ü®hfg.1.sqrt hg, hfg.2.sqrt hf‚ü©\n\n"}
{"name":"isLittleO_rpow_exp_pos_mul_atTop","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"s b : Real\nhb : LT.lt 0 b\n‚ä¢ Asymptotics.IsLittleO Filter.atTop (fun x => HPow.hPow x s) fun x => Real.exp (HMul.hMul b x)","decl":"/-- `x ^ s = o(exp(b * x))` as `x ‚Üí ‚àû` for any real `s` and positive `b`. -/\ntheorem isLittleO_rpow_exp_pos_mul_atTop (s : ‚Ñù) {b : ‚Ñù} (hb : 0 < b) :\n    (fun x : ‚Ñù => x ^ s) =o[atTop] fun x => exp (b * x) :=\n  isLittleO_of_tendsto (fun _ h => absurd h (exp_pos _).ne') <| by\n    simpa only [div_eq_mul_inv, exp_neg, neg_mul] using\n      tendsto_rpow_mul_exp_neg_mul_atTop_nhds_zero s b hb\n\n"}
{"name":"isLittleO_zpow_exp_pos_mul_atTop","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"k : Int\nb : Real\nhb : LT.lt 0 b\n‚ä¢ Asymptotics.IsLittleO Filter.atTop (fun x => HPow.hPow x k) fun x => Real.exp (HMul.hMul b x)","decl":"/-- `x ^ k = o(exp(b * x))` as `x ‚Üí ‚àû` for any integer `k` and positive `b`. -/\ntheorem isLittleO_zpow_exp_pos_mul_atTop (k : ‚Ñ§) {b : ‚Ñù} (hb : 0 < b) :\n    (fun x : ‚Ñù => x ^ k) =o[atTop] fun x => exp (b * x) := by\n  simpa only [Real.rpow_intCast] using isLittleO_rpow_exp_pos_mul_atTop k hb\n\n"}
{"name":"isLittleO_pow_exp_pos_mul_atTop","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"k : Nat\nb : Real\nhb : LT.lt 0 b\n‚ä¢ Asymptotics.IsLittleO Filter.atTop (fun x => HPow.hPow x k) fun x => Real.exp (HMul.hMul b x)","decl":"/-- `x ^ k = o(exp(b * x))` as `x ‚Üí ‚àû` for any natural `k` and positive `b`. -/\ntheorem isLittleO_pow_exp_pos_mul_atTop (k : ‚Ñï) {b : ‚Ñù} (hb : 0 < b) :\n    (fun x : ‚Ñù => x ^ k) =o[atTop] fun x => exp (b * x) := by\n  simpa using isLittleO_zpow_exp_pos_mul_atTop k hb\n\n"}
{"name":"isLittleO_rpow_exp_atTop","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"s : Real\n‚ä¢ Asymptotics.IsLittleO Filter.atTop (fun x => HPow.hPow x s) Real.exp","decl":"/-- `x ^ s = o(exp x)` as `x ‚Üí ‚àû` for any real `s`. -/\ntheorem isLittleO_rpow_exp_atTop (s : ‚Ñù) : (fun x : ‚Ñù => x ^ s) =o[atTop] exp := by\n  simpa only [one_mul] using isLittleO_rpow_exp_pos_mul_atTop s one_pos\n\n"}
{"name":"isLittleO_exp_neg_mul_rpow_atTop","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"a : Real\nha : LT.lt 0 a\nb : Real\n‚ä¢ Asymptotics.IsLittleO Filter.atTop (fun x => Real.exp (HMul.hMul (Neg.neg a) x)) fun x => HPow.hPow x b","decl":"/-- `exp (-a * x) = o(x ^ s)` as `x ‚Üí ‚àû`, for any positive `a` and real `s`. -/\ntheorem isLittleO_exp_neg_mul_rpow_atTop {a : ‚Ñù} (ha : 0 < a) (b : ‚Ñù) :\n    IsLittleO atTop (fun x : ‚Ñù => exp (-a * x)) fun x : ‚Ñù => x ^ b := by\n  apply isLittleO_of_tendsto'\n  ¬∑ refine (eventually_gt_atTop 0).mono fun t ht h => ?_\n    rw [rpow_eq_zero_iff_of_nonneg ht.le] at h\n    exact (ht.ne' h.1).elim\n  ¬∑ refine (tendsto_exp_mul_div_rpow_atTop (-b) a ha).inv_tendsto_atTop.congr' ?_\n    refine (eventually_ge_atTop 0).mono fun t ht => ?_\n    field_simp [Real.exp_neg, rpow_neg ht]\n\n"}
{"name":"isLittleO_log_rpow_atTop","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"r : Real\nhr : LT.lt 0 r\n‚ä¢ Asymptotics.IsLittleO Filter.atTop Real.log fun x => HPow.hPow x r","decl":"theorem isLittleO_log_rpow_atTop {r : ‚Ñù} (hr : 0 < r) : log =o[atTop] fun x => x ^ r :=\n  calc\n    log =O[atTop] fun x => r * log x := isBigO_self_const_mul _ hr.ne' _ _\n    _ =·∂†[atTop] fun x => log (x ^ r) :=\n      ((eventually_gt_atTop 0).mono fun _ hx => (log_rpow hx _).symm)\n    _ =o[atTop] fun x => x ^ r := isLittleO_log_id_atTop.comp_tendsto (tendsto_rpow_atTop hr)\n\n"}
{"name":"isLittleO_log_rpow_rpow_atTop","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"s r : Real\nhs : LT.lt 0 s\n‚ä¢ Asymptotics.IsLittleO Filter.atTop (fun x => HPow.hPow (Real.log x) r) fun x => HPow.hPow x s","decl":"theorem isLittleO_log_rpow_rpow_atTop {s : ‚Ñù} (r : ‚Ñù) (hs : 0 < s) :\n    (fun x => log x ^ r) =o[atTop] fun x => x ^ s :=\n  let r' := max r 1\n  have hr : 0 < r' := lt_max_iff.2 <| Or.inr one_pos\n  have H : 0 < s / r' := div_pos hs hr\n  calc\n    (fun x => log x ^ r) =O[atTop] fun x => log x ^ r' :=\n      .of_norm_eventuallyLE <| by\n        filter_upwards [tendsto_log_atTop.eventually_ge_atTop 1] with x hx\n        rw [Real.norm_of_nonneg (by positivity)]\n        gcongr\n        exacts [hx, le_max_left _ _]\n    _ =o[atTop] fun x => (x ^ (s / r')) ^ r' :=\n      ((isLittleO_log_rpow_atTop H).rpow hr <|\n        (_root_.tendsto_rpow_atTop H).eventually <| eventually_ge_atTop 0)\n    _ =·∂†[atTop] fun x => x ^ s :=\n      (eventually_ge_atTop 0).mono fun x hx ‚Ü¶ by simp only [‚Üê rpow_mul hx, div_mul_cancel‚ÇÄ _ hr.ne']\n\n"}
{"name":"isLittleO_abs_log_rpow_rpow_nhds_zero","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"s r : Real\nhs : LT.lt s 0\n‚ä¢ Asymptotics.IsLittleO (nhdsWithin 0 (Set.Ioi 0)) (fun x => HPow.hPow (abs (Real.log x)) r) fun x => HPow.hPow x s","decl":"theorem isLittleO_abs_log_rpow_rpow_nhds_zero {s : ‚Ñù} (r : ‚Ñù) (hs : s < 0) :\n    (fun x => |log x| ^ r) =o[ùìù[>] 0] fun x => x ^ s :=\n  ((isLittleO_log_rpow_rpow_atTop r (neg_pos.2 hs)).comp_tendsto tendsto_inv_nhdsGT_zero).congr'\n    (mem_of_superset (Icc_mem_nhdsGT one_pos) fun x hx => by\n      simp [abs_of_nonpos, log_nonpos hx.1 hx.2])\n    (eventually_mem_nhdsWithin.mono fun x hx => by\n      rw [Function.comp_apply, inv_rpow hx.out.le, rpow_neg hx.out.le, inv_inv])\n\n"}
{"name":"isLittleO_log_rpow_nhds_zero","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"r : Real\nhr : LT.lt r 0\n‚ä¢ Asymptotics.IsLittleO (nhdsWithin 0 (Set.Ioi 0)) Real.log fun x => HPow.hPow x r","decl":"theorem isLittleO_log_rpow_nhds_zero {r : ‚Ñù} (hr : r < 0) : log =o[ùìù[>] 0] fun x => x ^ r :=\n  (isLittleO_abs_log_rpow_rpow_nhds_zero 1 hr).neg_left.congr'\n    (mem_of_superset (Icc_mem_nhdsGT one_pos) fun x hx => by\n      simp [abs_of_nonpos (log_nonpos hx.1 hx.2)])\n    .rfl\n\n"}
{"name":"tendsto_log_div_rpow_nhds_zero","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"r : Real\nhr : LT.lt r 0\n‚ä¢ Filter.Tendsto (fun x => HDiv.hDiv (Real.log x) (HPow.hPow x r)) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0)","decl":"theorem tendsto_log_div_rpow_nhds_zero {r : ‚Ñù} (hr : r < 0) :\n    Tendsto (fun x => log x / x ^ r) (ùìù[>] 0) (ùìù 0) :=\n  (isLittleO_log_rpow_nhds_zero hr).tendsto_div_nhds_zero\n\n"}
{"name":"tendsto_log_mul_rpow_nhds_zero","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"r : Real\nhr : LT.lt 0 r\n‚ä¢ Filter.Tendsto (fun x => HMul.hMul (Real.log x) (HPow.hPow x r)) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0)","decl":"theorem tendsto_log_mul_rpow_nhds_zero {r : ‚Ñù} (hr : 0 < r) :\n    Tendsto (fun x => log x * x ^ r) (ùìù[>] 0) (ùìù 0) :=\n  (tendsto_log_div_rpow_nhds_zero <| neg_lt_zero.2 hr).congr' <|\n    eventually_mem_nhdsWithin.mono fun x hx => by rw [rpow_neg hx.out.le, div_inv_eq_mul]\n\n"}
{"name":"tendsto_log_mul_self_nhds_zero_left","module":"Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics","initialProofState":"‚ä¢ Filter.Tendsto (fun x => HMul.hMul (Real.log x) x) (nhdsWithin 0 (Set.Iio 0)) (nhds 0)","decl":"lemma tendsto_log_mul_self_nhds_zero_left : Filter.Tendsto (fun x ‚Ü¶ log x * x) (ùìù[<] 0) (ùìù 0) := by\n  have h := tendsto_log_mul_rpow_nhds_zero zero_lt_one\n  simp only [Real.rpow_one] at h\n  have h_eq : ‚àÄ x ‚àà Set.Iio 0, (- (fun x ‚Ü¶ log x * x) ‚àò (fun x ‚Ü¶ |x|)) x = log x * x := by\n    simp only [Set.mem_Iio, Pi.neg_apply, Function.comp_apply, log_abs]\n    intro x hx\n    simp only [abs_of_nonpos hx.le, mul_neg, neg_neg]\n  refine tendsto_nhdsWithin_congr h_eq ?_\n  nth_rewrite 3 [‚Üê neg_zero]\n  refine (h.comp (tendsto_abs_nhdsWithin_zero.mono_left ?_)).neg\n  refine nhdsWithin_mono 0 (fun x hx ‚Ü¶ ?_)\n  simp only [Set.mem_Iio] at hx\n  simp only [Set.mem_compl_iff, Set.mem_singleton_iff, hx.ne, not_false_eq_true]\n"}
