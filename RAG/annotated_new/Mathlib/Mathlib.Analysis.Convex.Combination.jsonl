{"name":"Finset.centerMass_empty","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nι : Type u_5\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\nw : ι → R\nz : ι → E\n⊢ Eq (EmptyCollection.emptyCollection.centerMass w z) 0","decl":"theorem Finset.centerMass_empty : (∅ : Finset ι).centerMass w z = 0 := by\n  simp only [centerMass, sum_empty, smul_zero]\n\n"}
{"name":"Finset.centerMass_pair","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nι : Type u_5\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ni j : ι\nw : ι → R\nz : ι → E\nhne : Ne i j\n⊢ Eq ((Insert.insert i (Singleton.singleton j)).centerMass w z) (HAdd.hAdd (HSMul.hSMul (HDiv.hDiv (w i) (HAdd.hAdd (w i) (w j))) (z i)) (HSMul.hSMul (HDiv.hDiv (w j) (HAdd.hAdd (w i) (w j))) (z j)))","decl":"open scoped Classical in\ntheorem Finset.centerMass_pair (hne : i ≠ j) :\n    ({i, j} : Finset ι).centerMass w z = (w i / (w i + w j)) • z i + (w j / (w i + w j)) • z j := by\n  simp only [centerMass, sum_pair hne]\n  module\n\n"}
{"name":"Finset.centerMass_insert","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nι : Type u_5\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ni : ι\nt : Finset ι\nw : ι → R\nz : ι → E\nha : Not (Membership.mem t i)\nhw : Ne (t.sum fun j => w j) 0\n⊢ Eq ((Insert.insert i t).centerMass w z) (HAdd.hAdd (HSMul.hSMul (HDiv.hDiv (w i) (HAdd.hAdd (w i) (t.sum fun j => w j))) (z i)) (HSMul.hSMul (HDiv.hDiv (t.sum fun j => w j) (HAdd.hAdd (w i) (t.sum fun j => w j))) (t.centerMass w z)))","decl":"open scoped Classical in\ntheorem Finset.centerMass_insert (ha : i ∉ t) (hw : ∑ j ∈ t, w j ≠ 0) :\n    (insert i t).centerMass w z =\n      (w i / (w i + ∑ j ∈ t, w j)) • z i +\n        ((∑ j ∈ t, w j) / (w i + ∑ j ∈ t, w j)) • t.centerMass w z := by\n  simp only [centerMass, sum_insert ha, smul_add, (mul_smul _ _ _).symm, ← div_eq_inv_mul]\n  congr 2\n  rw [div_mul_eq_mul_div, mul_inv_cancel₀ hw, one_div]\n\n"}
{"name":"Finset.centerMass_singleton","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nι : Type u_5\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ni : ι\nw : ι → R\nz : ι → E\nhw : Ne (w i) 0\n⊢ Eq ((Singleton.singleton i).centerMass w z) (z i)","decl":"theorem Finset.centerMass_singleton (hw : w i ≠ 0) : ({i} : Finset ι).centerMass w z = z i := by\n  rw [centerMass, sum_singleton, sum_singleton]\n  match_scalars\n  field_simp\n\n"}
{"name":"Finset.centerMass_neg_left","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nι : Type u_5\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\nt : Finset ι\nw : ι → R\nz : ι → E\n⊢ Eq (t.centerMass (Neg.neg w) z) (t.centerMass w z)","decl":"@[simp] lemma Finset.centerMass_neg_left : t.centerMass (-w) z = t.centerMass w z := by\n  simp [centerMass, inv_neg]\n\n"}
{"name":"Finset.centerMass_smul_left","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nR' : Type u_2\nE : Type u_3\nι : Type u_5\ninst✝⁹ : LinearOrderedField R\ninst✝⁸ : LinearOrderedField R'\ninst✝⁷ : AddCommGroup E\ninst✝⁶ : Module R E\nt : Finset ι\nw : ι → R\nz : ι → E\nc : R'\ninst✝⁵ : Module R' R\ninst✝⁴ : Module R' E\ninst✝³ : SMulCommClass R' R R\ninst✝² : IsScalarTower R' R R\ninst✝¹ : SMulCommClass R R' E\ninst✝ : IsScalarTower R' R E\nhc : Ne c 0\n⊢ Eq (t.centerMass (HSMul.hSMul c w) z) (t.centerMass w z)","decl":"lemma Finset.centerMass_smul_left {c : R'} [Module R' R] [Module R' E] [SMulCommClass R' R R]\n    [IsScalarTower R' R R] [SMulCommClass R R' E] [IsScalarTower R' R E] (hc : c ≠ 0) :\n    t.centerMass (c • w) z = t.centerMass w z := by\n  simp [centerMass, -smul_assoc, smul_assoc c, ← smul_sum, smul_inv₀, smul_smul_smul_comm, hc]\n\n"}
{"name":"Finset.centerMass_eq_of_sum_1","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nι : Type u_5\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\nt : Finset ι\nw : ι → R\nz : ι → E\nhw : Eq (t.sum fun i => w i) 1\n⊢ Eq (t.centerMass w z) (t.sum fun i => HSMul.hSMul (w i) (z i))","decl":"theorem Finset.centerMass_eq_of_sum_1 (hw : ∑ i ∈ t, w i = 1) :\n    t.centerMass w z = ∑ i ∈ t, w i • z i := by\n  simp only [Finset.centerMass, hw, inv_one, one_smul]\n\n"}
{"name":"Finset.centerMass_smul","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nι : Type u_5\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\nc : R\nt : Finset ι\nw : ι → R\nz : ι → E\n⊢ Eq (t.centerMass w fun i => HSMul.hSMul c (z i)) (HSMul.hSMul c (t.centerMass w z))","decl":"theorem Finset.centerMass_smul : (t.centerMass w fun i => c • z i) = c • t.centerMass w z := by\n  simp only [Finset.centerMass, Finset.smul_sum, (mul_smul _ _ _).symm, mul_comm c, mul_assoc]\n\n"}
{"name":"Finset.centerMass_segment'","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nι : Type u_5\nι' : Type u_6\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ns : Finset ι\nt : Finset ι'\nws : ι → R\nzs : ι → E\nwt : ι' → R\nzt : ι' → E\nhws : Eq (s.sum fun i => ws i) 1\nhwt : Eq (t.sum fun i => wt i) 1\na b : R\nhab : Eq (HAdd.hAdd a b) 1\n⊢ Eq (HAdd.hAdd (HSMul.hSMul a (s.centerMass ws zs)) (HSMul.hSMul b (t.centerMass wt zt))) ((s.disjSum t).centerMass (Sum.elim (fun i => HMul.hMul a (ws i)) fun j => HMul.hMul b (wt j)) (Sum.elim zs zt))","decl":"/-- A convex combination of two centers of mass is a center of mass as well. This version\ndeals with two different index types. -/\ntheorem Finset.centerMass_segment' (s : Finset ι) (t : Finset ι') (ws : ι → R) (zs : ι → E)\n    (wt : ι' → R) (zt : ι' → E) (hws : ∑ i ∈ s, ws i = 1) (hwt : ∑ i ∈ t, wt i = 1) (a b : R)\n    (hab : a + b = 1) : a • s.centerMass ws zs + b • t.centerMass wt zt = (s.disjSum t).centerMass\n    (Sum.elim (fun i => a * ws i) fun j => b * wt j) (Sum.elim zs zt) := by\n  rw [s.centerMass_eq_of_sum_1 _ hws, t.centerMass_eq_of_sum_1 _ hwt, smul_sum, smul_sum, ←\n    Finset.sum_sum_elim, Finset.centerMass_eq_of_sum_1]\n  · congr with ⟨⟩ <;> simp only [Sum.elim_inl, Sum.elim_inr, mul_smul]\n  · rw [sum_sum_elim, ← mul_sum, ← mul_sum, hws, hwt, mul_one, mul_one, hab]\n\n"}
{"name":"Finset.centerMass_segment","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nι : Type u_5\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ns : Finset ι\nw₁ w₂ : ι → R\nz : ι → E\nhw₁ : Eq (s.sum fun i => w₁ i) 1\nhw₂ : Eq (s.sum fun i => w₂ i) 1\na b : R\nhab : Eq (HAdd.hAdd a b) 1\n⊢ Eq (HAdd.hAdd (HSMul.hSMul a (s.centerMass w₁ z)) (HSMul.hSMul b (s.centerMass w₂ z))) (s.centerMass (fun i => HAdd.hAdd (HMul.hMul a (w₁ i)) (HMul.hMul b (w₂ i))) z)","decl":"/-- A convex combination of two centers of mass is a center of mass as well. This version\nworks if two centers of mass share the set of original points. -/\ntheorem Finset.centerMass_segment (s : Finset ι) (w₁ w₂ : ι → R) (z : ι → E)\n    (hw₁ : ∑ i ∈ s, w₁ i = 1) (hw₂ : ∑ i ∈ s, w₂ i = 1) (a b : R) (hab : a + b = 1) :\n    a • s.centerMass w₁ z + b • s.centerMass w₂ z =\n    s.centerMass (fun i => a * w₁ i + b * w₂ i) z := by\n  have hw : (∑ i ∈ s, (a * w₁ i + b * w₂ i)) = 1 := by\n    simp only [← mul_sum, sum_add_distrib, mul_one, *]\n  simp only [Finset.centerMass_eq_of_sum_1, Finset.centerMass_eq_of_sum_1 _ _ hw,\n    smul_sum, sum_add_distrib, add_smul, mul_smul, *]\n\n"}
{"name":"Finset.centerMass_ite_eq","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nι : Type u_5\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ni : ι\nt : Finset ι\nz : ι → E\nhi : Membership.mem t i\n⊢ Eq (t.centerMass (fun j => ite (Eq i j) 1 0) z) (z i)","decl":"open scoped Classical in\ntheorem Finset.centerMass_ite_eq (hi : i ∈ t) :\n    t.centerMass (fun j => if i = j then (1 : R) else 0) z = z i := by\n  rw [Finset.centerMass_eq_of_sum_1]\n  · trans ∑ j ∈ t, if i = j then z i else 0\n    · congr with i\n      split_ifs with h\n      exacts [h ▸ one_smul _ _, zero_smul _ _]\n    · rw [sum_ite_eq, if_pos hi]\n  · rw [sum_ite_eq, if_pos hi]\n\n"}
{"name":"Finset.centerMass_subset","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nι : Type u_5\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\nt : Finset ι\nw : ι → R\nz : ι → E\nt' : Finset ι\nht : HasSubset.Subset t t'\nh : ∀ (i : ι), Membership.mem t' i → Not (Membership.mem t i) → Eq (w i) 0\n⊢ Eq (t.centerMass w z) (t'.centerMass w z)","decl":"theorem Finset.centerMass_subset {t' : Finset ι} (ht : t ⊆ t') (h : ∀ i ∈ t', i ∉ t → w i = 0) :\n    t.centerMass w z = t'.centerMass w z := by\n  rw [centerMass, sum_subset ht h, smul_sum, centerMass, smul_sum]\n  apply sum_subset ht\n  intro i hit' hit\n  rw [h i hit' hit, zero_smul, smul_zero]\n\n"}
{"name":"Finset.centerMass_filter_ne_zero","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nι : Type u_5\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\nt : Finset ι\nw : ι → R\nz : ι → E\n⊢ Eq ((Finset.filter (fun i => Ne (w i) 0) t).centerMass w z) (t.centerMass w z)","decl":"theorem Finset.centerMass_filter_ne_zero : {i ∈ t | w i ≠ 0}.centerMass w z = t.centerMass w z :=\n  Finset.centerMass_subset z (filter_subset _ _) fun i hit hit' => by\n    simpa only [hit, mem_filter, true_and, Ne, Classical.not_not] using hit'\n\n"}
{"name":"Finset.centerMass_le_sup","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nι : Type u_5\nα : Type u_7\ninst✝³ : LinearOrderedField R\ninst✝² : LinearOrderedAddCommGroup α\ninst✝¹ : Module R α\ninst✝ : OrderedSMul R α\ns : Finset ι\nf : ι → α\nw : ι → R\nhw₀ : ∀ (i : ι), Membership.mem s i → LE.le 0 (w i)\nhw₁ : LT.lt 0 (s.sum fun i => w i)\n⊢ LE.le (s.centerMass w f) (s.sup' ⋯ f)","decl":"theorem centerMass_le_sup {s : Finset ι} {f : ι → α} {w : ι → R} (hw₀ : ∀ i ∈ s, 0 ≤ w i)\n    (hw₁ : 0 < ∑ i ∈ s, w i) :\n    s.centerMass w f ≤ s.sup' (nonempty_of_ne_empty <| by rintro rfl; simp at hw₁) f := by\n  rw [centerMass, inv_smul_le_iff_of_pos hw₁, sum_smul]\n  exact sum_le_sum fun i hi => smul_le_smul_of_nonneg_left (le_sup' _ hi) <| hw₀ i hi\n\n"}
{"name":"Finset.inf_le_centerMass","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nι : Type u_5\nα : Type u_7\ninst✝³ : LinearOrderedField R\ninst✝² : LinearOrderedAddCommGroup α\ninst✝¹ : Module R α\ninst✝ : OrderedSMul R α\ns : Finset ι\nf : ι → α\nw : ι → R\nhw₀ : ∀ (i : ι), Membership.mem s i → LE.le 0 (w i)\nhw₁ : LT.lt 0 (s.sum fun i => w i)\n⊢ LE.le (s.inf' ⋯ f) (s.centerMass w f)","decl":"theorem inf_le_centerMass {s : Finset ι} {f : ι → α} {w : ι → R} (hw₀ : ∀ i ∈ s, 0 ≤ w i)\n    (hw₁ : 0 < ∑ i ∈ s, w i) :\n    s.inf' (nonempty_of_ne_empty <| by rintro rfl; simp at hw₁) f ≤ s.centerMass w f :=\n  @centerMass_le_sup R _ αᵒᵈ _ _ _ _ _ _ _ hw₀ hw₁\n\n"}
{"name":"Finset.centerMass_of_sum_add_sum_eq_zero","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nι : Type u_5\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\nw : ι → R\nz : ι → E\ns t : Finset ι\nhw : Eq (HAdd.hAdd (s.sum fun i => w i) (t.sum fun i => w i)) 0\nhz : Eq (HAdd.hAdd (s.sum fun i => HSMul.hSMul (w i) (z i)) (t.sum fun i => HSMul.hSMul (w i) (z i))) 0\n⊢ Eq (s.centerMass w z) (t.centerMass w z)","decl":"lemma Finset.centerMass_of_sum_add_sum_eq_zero {s t : Finset ι}\n    (hw : ∑ i ∈ s, w i + ∑ i ∈ t, w i = 0) (hz : ∑ i ∈ s, w i • z i + ∑ i ∈ t, w i • z i = 0) :\n    s.centerMass w z = t.centerMass w z := by\n  simp [centerMass, eq_neg_of_add_eq_zero_right hw, eq_neg_of_add_eq_zero_left hz, ← neg_inv]\n\n"}
{"name":"Convex.centerMass_mem","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nι : Type u_5\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ns : Set E\nt : Finset ι\nw : ι → R\nz : ι → E\nhs : Convex R s\na✝² : ∀ (i : ι), Membership.mem t i → LE.le 0 (w i)\na✝¹ : LT.lt 0 (t.sum fun i => w i)\na✝ : ∀ (i : ι), Membership.mem t i → Membership.mem s (z i)\n⊢ Membership.mem s (t.centerMass w z)","decl":"/-- The center of mass of a finite subset of a convex set belongs to the set\nprovided that all weights are non-negative, and the total weight is positive. -/\ntheorem Convex.centerMass_mem (hs : Convex R s) :\n    (∀ i ∈ t, 0 ≤ w i) → (0 < ∑ i ∈ t, w i) → (∀ i ∈ t, z i ∈ s) → t.centerMass w z ∈ s := by\n  classical\n  induction' t using Finset.induction with i t hi ht\n  · simp [lt_irrefl]\n  intro h₀ hpos hmem\n  have zi : z i ∈ s := hmem _ (mem_insert_self _ _)\n  have hs₀ : ∀ j ∈ t, 0 ≤ w j := fun j hj => h₀ j <| mem_insert_of_mem hj\n  rw [sum_insert hi] at hpos\n  by_cases hsum_t : ∑ j ∈ t, w j = 0\n  · have ws : ∀ j ∈ t, w j = 0 := (sum_eq_zero_iff_of_nonneg hs₀).1 hsum_t\n    have wz : ∑ j ∈ t, w j • z j = 0 := sum_eq_zero fun i hi => by simp [ws i hi]\n    simp only [centerMass, sum_insert hi, wz, hsum_t, add_zero]\n    simp only [hsum_t, add_zero] at hpos\n    rw [← mul_smul, inv_mul_cancel₀ (ne_of_gt hpos), one_smul]\n    exact zi\n  · rw [Finset.centerMass_insert _ _ _ hi hsum_t]\n    refine convex_iff_div.1 hs zi (ht hs₀ ?_ ?_) ?_ (sum_nonneg hs₀) hpos\n    · exact lt_of_le_of_ne (sum_nonneg hs₀) (Ne.symm hsum_t)\n    · intro j hj\n      exact hmem j (mem_insert_of_mem hj)\n    · exact h₀ _ (mem_insert_self _ _)\n\n"}
{"name":"Convex.sum_mem","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nι : Type u_5\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ns : Set E\nt : Finset ι\nw : ι → R\nz : ι → E\nhs : Convex R s\nh₀ : ∀ (i : ι), Membership.mem t i → LE.le 0 (w i)\nh₁ : Eq (t.sum fun i => w i) 1\nhz : ∀ (i : ι), Membership.mem t i → Membership.mem s (z i)\n⊢ Membership.mem s (t.sum fun i => HSMul.hSMul (w i) (z i))","decl":"theorem Convex.sum_mem (hs : Convex R s) (h₀ : ∀ i ∈ t, 0 ≤ w i) (h₁ : ∑ i ∈ t, w i = 1)\n    (hz : ∀ i ∈ t, z i ∈ s) : (∑ i ∈ t, w i • z i) ∈ s := by\n  simpa only [h₁, centerMass, inv_one, one_smul] using\n    hs.centerMass_mem h₀ (h₁.symm ▸ zero_lt_one) hz\n\n"}
{"name":"Convex.finsum_mem","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\nι : Sort u_8\nw : ι → R\nz : ι → E\ns : Set E\nhs : Convex R s\nh₀ : ∀ (i : ι), LE.le 0 (w i)\nh₁ : Eq (finsum fun i => w i) 1\nhz : ∀ (i : ι), Ne (w i) 0 → Membership.mem s (z i)\n⊢ Membership.mem s (finsum fun i => HSMul.hSMul (w i) (z i))","decl":"/-- A version of `Convex.sum_mem` for `finsum`s. If `s` is a convex set, `w : ι → R` is a family of\nnonnegative weights with sum one and `z : ι → E` is a family of elements of a module over `R` such\nthat `z i ∈ s` whenever `w i ≠ 0`, then the sum `∑ᶠ i, w i • z i` belongs to `s`. See also\n`PartitionOfUnity.finsum_smul_mem_convex`. -/\ntheorem Convex.finsum_mem {ι : Sort*} {w : ι → R} {z : ι → E} {s : Set E} (hs : Convex R s)\n    (h₀ : ∀ i, 0 ≤ w i) (h₁ : ∑ᶠ i, w i = 1) (hz : ∀ i, w i ≠ 0 → z i ∈ s) :\n    (∑ᶠ i, w i • z i) ∈ s := by\n  have hfin_w : (support (w ∘ PLift.down)).Finite := by\n    by_contra H\n    rw [finsum, dif_neg H] at h₁\n    exact zero_ne_one h₁\n  have hsub : support ((fun i => w i • z i) ∘ PLift.down) ⊆ hfin_w.toFinset :=\n    (support_smul_subset_left _ _).trans hfin_w.coe_toFinset.ge\n  rw [finsum_eq_sum_plift_of_support_subset hsub]\n  refine hs.sum_mem (fun _ _ => h₀ _) ?_ fun i hi => hz _ ?_\n  · rwa [finsum, dif_pos hfin_w] at h₁\n  · rwa [hfin_w.mem_toFinset] at hi\n\n"}
{"name":"convex_iff_sum_mem","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ns : Set E\n⊢ Iff (Convex R s) (∀ (t : Finset E) (w : E → R), (∀ (i : E), Membership.mem t i → LE.le 0 (w i)) → Eq (t.sum fun i => w i) 1 → (∀ (x : E), Membership.mem t x → Membership.mem s x) → Membership.mem s (t.sum fun x => HSMul.hSMul (w x) x))","decl":"theorem convex_iff_sum_mem : Convex R s ↔ ∀ (t : Finset E) (w : E → R),\n    (∀ i ∈ t, 0 ≤ w i) → ∑ i ∈ t, w i = 1 → (∀ x ∈ t, x ∈ s) → (∑ x ∈ t, w x • x) ∈ s := by\n  classical\n  refine ⟨fun hs t w hw₀ hw₁ hts => hs.sum_mem hw₀ hw₁ hts, ?_⟩\n  intro h x hx y hy a b ha hb hab\n  by_cases h_cases : x = y\n  · rw [h_cases, ← add_smul, hab, one_smul]\n    exact hy\n  · convert h {x, y} (fun z => if z = y then b else a) _ _ _\n    -- Porting note: Original proof had 2 `simp_intro i hi`\n    · simp only [sum_pair h_cases, if_neg h_cases, if_pos trivial]\n    · intro i _\n      simp only\n      split_ifs <;> assumption\n    · simp only [sum_pair h_cases, if_neg h_cases, if_pos trivial, hab]\n    · intro i hi\n      simp only [Finset.mem_singleton, Finset.mem_insert] at hi\n      cases hi <;> subst i <;> assumption\n\n"}
{"name":"Finset.centerMass_mem_convexHull","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nι : Type u_5\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ns : Set E\nt : Finset ι\nw : ι → R\nhw₀ : ∀ (i : ι), Membership.mem t i → LE.le 0 (w i)\nhws : LT.lt 0 (t.sum fun i => w i)\nz : ι → E\nhz : ∀ (i : ι), Membership.mem t i → Membership.mem s (z i)\n⊢ Membership.mem ((convexHull R) s) (t.centerMass w z)","decl":"theorem Finset.centerMass_mem_convexHull (t : Finset ι) {w : ι → R} (hw₀ : ∀ i ∈ t, 0 ≤ w i)\n    (hws : 0 < ∑ i ∈ t, w i) {z : ι → E} (hz : ∀ i ∈ t, z i ∈ s) :\n    t.centerMass w z ∈ convexHull R s :=\n  (convex_convexHull R s).centerMass_mem hw₀ hws fun i hi => subset_convexHull R s <| hz i hi\n\n"}
{"name":"Finset.centerMass_mem_convexHull_of_nonpos","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nι : Type u_5\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ns : Set E\nw : ι → R\nz : ι → E\nt : Finset ι\nhw₀ : ∀ (i : ι), Membership.mem t i → LE.le (w i) 0\nhws : LT.lt (t.sum fun i => w i) 0\nhz : ∀ (i : ι), Membership.mem t i → Membership.mem s (z i)\n⊢ Membership.mem ((convexHull R) s) (t.centerMass w z)","decl":"/-- A version of `Finset.centerMass_mem_convexHull` for when the weights are nonpositive. -/\nlemma Finset.centerMass_mem_convexHull_of_nonpos (t : Finset ι) (hw₀ : ∀ i ∈ t, w i ≤ 0)\n    (hws : ∑ i ∈ t, w i < 0) (hz : ∀ i ∈ t, z i ∈ s) : t.centerMass w z ∈ convexHull R s := by\n  rw [← centerMass_neg_left]\n  exact Finset.centerMass_mem_convexHull _ (fun _i hi ↦ neg_nonneg.2 <| hw₀ _ hi) (by simpa) hz\n\n"}
{"name":"Finset.centerMass_id_mem_convexHull","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\nt : Finset E\nw : E → R\nhw₀ : ∀ (i : E), Membership.mem t i → LE.le 0 (w i)\nhws : LT.lt 0 (t.sum fun i => w i)\n⊢ Membership.mem ((convexHull R) ↑t) (t.centerMass w id)","decl":"/-- A refinement of `Finset.centerMass_mem_convexHull` when the indexed family is a `Finset` of\nthe space. -/\ntheorem Finset.centerMass_id_mem_convexHull (t : Finset E) {w : E → R} (hw₀ : ∀ i ∈ t, 0 ≤ w i)\n    (hws : 0 < ∑ i ∈ t, w i) : t.centerMass w id ∈ convexHull R (t : Set E) :=\n  t.centerMass_mem_convexHull hw₀ hws fun _ => mem_coe.2\n\n"}
{"name":"Finset.centerMass_id_mem_convexHull_of_nonpos","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\nt : Finset E\nw : E → R\nhw₀ : ∀ (i : E), Membership.mem t i → LE.le (w i) 0\nhws : LT.lt (t.sum fun i => w i) 0\n⊢ Membership.mem ((convexHull R) ↑t) (t.centerMass w id)","decl":"/-- A version of `Finset.centerMass_mem_convexHull` for when the weights are nonpositive. -/\nlemma Finset.centerMass_id_mem_convexHull_of_nonpos (t : Finset E) {w : E → R}\n    (hw₀ : ∀ i ∈ t, w i ≤ 0) (hws : ∑ i ∈ t, w i < 0) :\n    t.centerMass w id ∈ convexHull R (t : Set E) :=\n  t.centerMass_mem_convexHull_of_nonpos hw₀ hws fun _ ↦ mem_coe.2\n\n"}
{"name":"affineCombination_eq_centerMass","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\nι : Type u_8\nt : Finset ι\np : ι → E\nw : ι → R\nhw₂ : Eq (t.sum fun i => w i) 1\n⊢ Eq ((Finset.affineCombination R t p) w) (t.centerMass w p)","decl":"theorem affineCombination_eq_centerMass {ι : Type*} {t : Finset ι} {p : ι → E} {w : ι → R}\n    (hw₂ : ∑ i ∈ t, w i = 1) : t.affineCombination R p w = centerMass t w p := by\n  rw [affineCombination_eq_weightedVSubOfPoint_vadd_of_sum_eq_one _ w _ hw₂ (0 : E),\n    Finset.weightedVSubOfPoint_apply, vadd_eq_add, add_zero, t.centerMass_eq_of_sum_1 _ hw₂]\n  simp_rw [vsub_eq_sub, sub_zero]\n\n"}
{"name":"affineCombination_mem_convexHull","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nι : Type u_5\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ns : Finset ι\nv : ι → E\nw : ι → R\nhw₀ : ∀ (i : ι), Membership.mem s i → LE.le 0 (w i)\nhw₁ : Eq (s.sum w) 1\n⊢ Membership.mem ((convexHull R) (Set.range v)) ((Finset.affineCombination R s v) w)","decl":"theorem affineCombination_mem_convexHull {s : Finset ι} {v : ι → E} {w : ι → R}\n    (hw₀ : ∀ i ∈ s, 0 ≤ w i) (hw₁ : s.sum w = 1) :\n    s.affineCombination R v w ∈ convexHull R (range v) := by\n  rw [affineCombination_eq_centerMass hw₁]\n  apply s.centerMass_mem_convexHull hw₀\n  · simp [hw₁]\n  · simp\n\n"}
{"name":"Finset.centroid_eq_centerMass","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nι : Type u_5\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ns : Finset ι\nhs : s.Nonempty\np : ι → E\n⊢ Eq (Finset.centroid R s p) (s.centerMass (Finset.centroidWeights R s) p)","decl":"/-- The centroid can be regarded as a center of mass. -/\n@[simp]\ntheorem Finset.centroid_eq_centerMass (s : Finset ι) (hs : s.Nonempty) (p : ι → E) :\n    s.centroid R p = s.centerMass (s.centroidWeights R) p :=\n  affineCombination_eq_centerMass (s.sum_centroidWeights_eq_one_of_nonempty R hs)\n\n"}
{"name":"Finset.centroid_mem_convexHull","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ns : Finset E\nhs : s.Nonempty\n⊢ Membership.mem ((convexHull R) ↑s) (Finset.centroid R s id)","decl":"theorem Finset.centroid_mem_convexHull (s : Finset E) (hs : s.Nonempty) :\n    s.centroid R id ∈ convexHull R (s : Set E) := by\n  rw [s.centroid_eq_centerMass hs]\n  apply s.centerMass_id_mem_convexHull\n  · simp only [inv_nonneg, imp_true_iff, Nat.cast_nonneg, Finset.centroidWeights_apply]\n  · have hs_card : (#s : R) ≠ 0 := by simp [Finset.nonempty_iff_ne_empty.mp hs]\n    simp only [hs_card, Finset.sum_const, nsmul_eq_mul, mul_inv_cancel₀, Ne, not_false_iff,\n      Finset.centroidWeights_apply, zero_lt_one]\n\n"}
{"name":"convexHull_range_eq_exists_affineCombination","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nι : Type u_5\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\nv : ι → E\n⊢ Eq ((convexHull R) (Set.range v)) (setOf fun x => Exists fun s => Exists fun w => And (∀ (i : ι), Membership.mem s i → LE.le 0 (w i)) (And (Eq (s.sum w) 1) (Eq ((Finset.affineCombination R s v) w) x)))","decl":"theorem convexHull_range_eq_exists_affineCombination (v : ι → E) : convexHull R (range v) =\n    { x | ∃ (s : Finset ι) (w : ι → R), (∀ i ∈ s, 0 ≤ w i) ∧ s.sum w = 1 ∧\n      s.affineCombination R v w = x } := by\n  classical\n  refine Subset.antisymm (convexHull_min ?_ ?_) ?_\n  · intro x hx\n    obtain ⟨i, hi⟩ := Set.mem_range.mp hx\n    exact ⟨{i}, Function.const ι (1 : R), by simp, by simp, by simp [hi]⟩\n  · rintro x ⟨s, w, hw₀, hw₁, rfl⟩ y ⟨s', w', hw₀', hw₁', rfl⟩ a b ha hb hab\n    let W : ι → R := fun i => (if i ∈ s then a * w i else 0) + if i ∈ s' then b * w' i else 0\n    have hW₁ : (s ∪ s').sum W = 1 := by\n      rw [sum_add_distrib, ← sum_subset subset_union_left,\n        ← sum_subset subset_union_right, sum_ite_of_true,\n        sum_ite_of_true, ← mul_sum, ← mul_sum, hw₁, hw₁', ← add_mul, hab,\n        mul_one] <;> intros <;> simp_all\n    refine ⟨s ∪ s', W, ?_, hW₁, ?_⟩\n    · rintro i -\n      by_cases hi : i ∈ s <;> by_cases hi' : i ∈ s' <;>\n        simp [W, hi, hi', add_nonneg, mul_nonneg ha (hw₀ i _), mul_nonneg hb (hw₀' i _)]\n    · simp_rw [W, affineCombination_eq_linear_combination (s ∪ s') v _ hW₁,\n        affineCombination_eq_linear_combination s v w hw₁,\n        affineCombination_eq_linear_combination s' v w' hw₁', add_smul, sum_add_distrib]\n      rw [← sum_subset subset_union_left, ← sum_subset subset_union_right]\n      · simp only [ite_smul, sum_ite_of_true fun _ hi => hi, mul_smul, ← smul_sum]\n      · intro i _ hi'\n        simp [hi']\n      · intro i _ hi'\n        simp [hi']\n  · rintro x ⟨s, w, hw₀, hw₁, rfl⟩\n    exact affineCombination_mem_convexHull hw₀ hw₁\n\n"}
{"name":"convexHull_eq","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ns : Set E\n⊢ Eq ((convexHull R) s) (setOf fun x => Exists fun ι => Exists fun t => Exists fun w => Exists fun z => And (∀ (i : ι), Membership.mem t i → LE.le 0 (w i)) (And (Eq (t.sum fun i => w i) 1) (And (∀ (i : ι), Membership.mem t i → Membership.mem s (z i)) (Eq (t.centerMass w z) x))))","decl":"/--\nConvex hull of `s` is equal to the set of all centers of masses of `Finset`s `t`, `z '' t ⊆ s`.\nFor universe reasons, you shouldn't use this lemma to prove that a given center of mass belongs\nto the convex hull. Use convexity of the convex hull instead.\n-/\ntheorem convexHull_eq (s : Set E) : convexHull R s =\n    { x : E | ∃ (ι : Type) (t : Finset ι) (w : ι → R) (z : ι → E), (∀ i ∈ t, 0 ≤ w i) ∧\n      ∑ i ∈ t, w i = 1 ∧ (∀ i ∈ t, z i ∈ s) ∧ t.centerMass w z = x } := by\n  refine Subset.antisymm (convexHull_min ?_ ?_) ?_\n  · intro x hx\n    use PUnit, {PUnit.unit}, fun _ => 1, fun _ => x, fun _ _ => zero_le_one, sum_singleton _ _,\n      fun _ _ => hx\n    simp only [Finset.centerMass, Finset.sum_singleton, inv_one, one_smul]\n  · rintro x ⟨ι, sx, wx, zx, hwx₀, hwx₁, hzx, rfl⟩ y ⟨ι', sy, wy, zy, hwy₀, hwy₁, hzy, rfl⟩ a b ha\n      hb hab\n    rw [Finset.centerMass_segment' _ _ _ _ _ _ hwx₁ hwy₁ _ _ hab]\n    refine ⟨_, _, _, _, ?_, ?_, ?_, rfl⟩\n    · rintro i hi\n      rw [Finset.mem_disjSum] at hi\n      rcases hi with (⟨j, hj, rfl⟩ | ⟨j, hj, rfl⟩) <;> simp only [Sum.elim_inl, Sum.elim_inr] <;>\n        apply_rules [mul_nonneg, hwx₀, hwy₀]\n    · simp [Finset.sum_sum_elim, ← mul_sum, *]\n    · intro i hi\n      rw [Finset.mem_disjSum] at hi\n      rcases hi with (⟨j, hj, rfl⟩ | ⟨j, hj, rfl⟩) <;> apply_rules [hzx, hzy]\n  · rintro _ ⟨ι, t, w, z, hw₀, hw₁, hz, rfl⟩\n    exact t.centerMass_mem_convexHull hw₀ (hw₁.symm ▸ zero_lt_one) hz\n\n"}
{"name":"mem_convexHull_of_exists_fintype","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nι : Type u_5\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup E\ninst✝¹ : Module R E\ns : Set E\nx : E\ninst✝ : Fintype ι\nw : ι → R\nz : ι → E\nhw₀ : ∀ (i : ι), LE.le 0 (w i)\nhw₁ : Eq (Finset.univ.sum fun i => w i) 1\nhz : ∀ (i : ι), Membership.mem s (z i)\nhx : Eq (Finset.univ.sum fun i => HSMul.hSMul (w i) (z i)) x\n⊢ Membership.mem ((convexHull R) s) x","decl":"/-- Universe polymorphic version of the reverse implication of `mem_convexHull_iff_exists_fintype`.\n-/\nlemma mem_convexHull_of_exists_fintype {s : Set E} {x : E} [Fintype ι] (w : ι → R) (z : ι → E)\n    (hw₀ : ∀ i, 0 ≤ w i) (hw₁ : ∑ i, w i = 1) (hz : ∀ i, z i ∈ s) (hx : ∑ i, w i • z i = x) :\n    x ∈ convexHull R s := by\n  rw [← hx, ← centerMass_eq_of_sum_1 _ _ hw₁]\n  exact centerMass_mem_convexHull _ (by simpa using hw₀) (by simp [hw₁]) (by simpa using hz)\n\n"}
{"name":"mem_convexHull_iff_exists_fintype","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ns : Set E\nx : E\n⊢ Iff (Membership.mem ((convexHull R) s) x) (Exists fun ι => Exists fun x_1 => Exists fun w => Exists fun z => And (∀ (i : ι), LE.le 0 (w i)) (And (Eq (Finset.univ.sum fun i => w i) 1) (And (∀ (i : ι), Membership.mem s (z i)) (Eq (Finset.univ.sum fun i => HSMul.hSMul (w i) (z i)) x))))","decl":"/-- The convex hull of `s` is equal to the set of centers of masses of finite families of points in\n`s`.\n\nFor universe reasons, you shouldn't use this lemma to prove that a given center of mass belongs\nto the convex hull. Use `mem_convexHull_of_exists_fintype` of the convex hull instead. -/\nlemma mem_convexHull_iff_exists_fintype {s : Set E} {x : E} :\n    x ∈ convexHull R s ↔ ∃ (ι : Type) (_ : Fintype ι) (w : ι → R) (z : ι → E), (∀ i, 0 ≤ w i) ∧\n      ∑ i, w i = 1 ∧ (∀ i, z i ∈ s) ∧ ∑ i, w i • z i = x := by\n  constructor\n  · simp only [convexHull_eq, mem_setOf_eq]\n    rintro ⟨ι, t, w, z, h⟩\n    refine ⟨t, inferInstance, w ∘ (↑), z ∘ (↑), ?_⟩\n    simpa [← sum_attach t, centerMass_eq_of_sum_1 _ _ h.2.1] using h\n  · rintro ⟨ι, _, w, z, hw₀, hw₁, hz, hx⟩\n    exact mem_convexHull_of_exists_fintype w z hw₀ hw₁ hz hx\n\n"}
{"name":"Finset.convexHull_eq","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ns : Finset E\n⊢ Eq ((convexHull R) ↑s) (setOf fun x => Exists fun w => And (∀ (y : E), Membership.mem s y → LE.le 0 (w y)) (And (Eq (s.sum fun y => w y) 1) (Eq (s.centerMass w id) x)))","decl":"theorem Finset.convexHull_eq (s : Finset E) : convexHull R ↑s =\n    { x : E | ∃ w : E → R, (∀ y ∈ s, 0 ≤ w y) ∧ ∑ y ∈ s, w y = 1 ∧ s.centerMass w id = x } := by\n  classical\n  refine Set.Subset.antisymm (convexHull_min ?_ ?_) ?_\n  · intro x hx\n    rw [Finset.mem_coe] at hx\n    refine ⟨_, ?_, ?_, Finset.centerMass_ite_eq _ _ _ hx⟩\n    · intros\n      split_ifs\n      exacts [zero_le_one, le_refl 0]\n    · rw [Finset.sum_ite_eq, if_pos hx]\n  · rintro x ⟨wx, hwx₀, hwx₁, rfl⟩ y ⟨wy, hwy₀, hwy₁, rfl⟩ a b ha hb hab\n    rw [Finset.centerMass_segment _ _ _ _ hwx₁ hwy₁ _ _ hab]\n    refine ⟨_, ?_, ?_, rfl⟩\n    · rintro i hi\n      apply_rules [add_nonneg, mul_nonneg, hwx₀, hwy₀]\n    · simp only [Finset.sum_add_distrib, ← mul_sum, mul_one, *]\n  · rintro _ ⟨w, hw₀, hw₁, rfl⟩\n    exact\n      s.centerMass_mem_convexHull (fun x hx => hw₀ _ hx) (hw₁.symm ▸ zero_lt_one) fun x hx => hx\n\n"}
{"name":"Finset.mem_convexHull","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ns : Finset E\nx : E\n⊢ Iff (Membership.mem ((convexHull R) ↑s) x) (Exists fun w => And (∀ (y : E), Membership.mem s y → LE.le 0 (w y)) (And (Eq (s.sum fun y => w y) 1) (Eq (s.centerMass w id) x)))","decl":"theorem Finset.mem_convexHull {s : Finset E} {x : E} : x ∈ convexHull R (s : Set E) ↔\n    ∃ w : E → R, (∀ y ∈ s, 0 ≤ w y) ∧ ∑ y ∈ s, w y = 1 ∧ s.centerMass w id = x := by\n  rw [Finset.convexHull_eq, Set.mem_setOf_eq]\n\n"}
{"name":"Finset.mem_convexHull'","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ns : Finset E\nx : E\n⊢ Iff (Membership.mem ((convexHull R) ↑s) x) (Exists fun w => And (∀ (y : E), Membership.mem s y → LE.le 0 (w y)) (And (Eq (s.sum fun y => w y) 1) (Eq (s.sum fun y => HSMul.hSMul (w y) y) x)))","decl":"/-- This is a version of `Finset.mem_convexHull` stated without `Finset.centerMass`. -/\nlemma Finset.mem_convexHull' {s : Finset E} {x : E} :\n    x ∈ convexHull R (s : Set E) ↔\n      ∃ w : E → R, (∀ y ∈ s, 0 ≤ w y) ∧ ∑ y ∈ s, w y = 1 ∧ ∑ y ∈ s, w y • y = x := by\n  rw [mem_convexHull]\n  refine exists_congr fun w ↦ and_congr_right' <| and_congr_right fun hw ↦ ?_\n  simp_rw [centerMass_eq_of_sum_1 _ _ hw, id_eq]\n\n"}
{"name":"Set.Finite.convexHull_eq","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ns : Set E\nhs : s.Finite\n⊢ Eq ((convexHull R) s) (setOf fun x => Exists fun w => And (∀ (y : E), Membership.mem s y → LE.le 0 (w y)) (And (Eq (hs.toFinset.sum fun y => w y) 1) (Eq (hs.toFinset.centerMass w id) x)))","decl":"theorem Set.Finite.convexHull_eq {s : Set E} (hs : s.Finite) : convexHull R s =\n    { x : E | ∃ w : E → R, (∀ y ∈ s, 0 ≤ w y) ∧ ∑ y ∈ hs.toFinset, w y = 1 ∧\n      hs.toFinset.centerMass w id = x } := by\n  simpa only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, exists_prop] using\n    hs.toFinset.convexHull_eq\n\n"}
{"name":"convexHull_eq_union_convexHull_finite_subsets","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ns : Set E\n⊢ Eq ((convexHull R) s) (Set.iUnion fun t => Set.iUnion fun x => (convexHull R) ↑t)","decl":"/-- A weak version of Carathéodory's theorem. -/\ntheorem convexHull_eq_union_convexHull_finite_subsets (s : Set E) :\n    convexHull R s = ⋃ (t : Finset E) (_ : ↑t ⊆ s), convexHull R ↑t := by\n  classical\n  refine Subset.antisymm ?_ ?_\n  · rw [_root_.convexHull_eq]\n    rintro x ⟨ι, t, w, z, hw₀, hw₁, hz, rfl⟩\n    simp only [mem_iUnion]\n    refine ⟨t.image z, ?_, ?_⟩\n    · rw [coe_image, Set.image_subset_iff]\n      exact hz\n    · apply t.centerMass_mem_convexHull hw₀\n      · simp only [hw₁, zero_lt_one]\n      · exact fun i hi => Finset.mem_coe.2 (Finset.mem_image_of_mem _ hi)\n  · exact iUnion_subset fun i => iUnion_subset convexHull_mono\n\n"}
{"name":"mk_mem_convexHull_prod","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝⁴ : LinearOrderedField R\ninst✝³ : AddCommGroup E\ninst✝² : AddCommGroup F\ninst✝¹ : Module R E\ninst✝ : Module R F\ns : Set E\nt : Set F\nx : E\ny : F\nhx : Membership.mem ((convexHull R) s) x\nhy : Membership.mem ((convexHull R) t) y\n⊢ Membership.mem ((convexHull R) (SProd.sprod s t)) { fst := x, snd := y }","decl":"theorem mk_mem_convexHull_prod {t : Set F} {x : E} {y : F} (hx : x ∈ convexHull R s)\n    (hy : y ∈ convexHull R t) : (x, y) ∈ convexHull R (s ×ˢ t) := by\n  rw [mem_convexHull_iff_exists_fintype] at hx hy ⊢\n  obtain ⟨ι, _, w, f, hw₀, hw₁, hfs, hf⟩ := hx\n  obtain ⟨κ, _, v, g, hv₀, hv₁, hgt, hg⟩ := hy\n  have h_sum : ∑ i : ι × κ, w i.1 * v i.2 = 1 := by\n    rw [Fintype.sum_prod_type, ← sum_mul_sum, hw₁, hv₁, mul_one]\n  refine ⟨ι × κ, inferInstance, fun p => w p.1 * v p.2, fun p ↦ (f p.1, g p.2),\n    fun p ↦ mul_nonneg (hw₀ _) (hv₀ _), h_sum, fun p ↦ ⟨hfs _, hgt _⟩, ?_⟩\n  ext\n  · simp_rw [Prod.fst_sum, Prod.smul_mk, Fintype.sum_prod_type, mul_comm (w _), mul_smul,\n      sum_comm (γ := ι), ← Fintype.sum_smul_sum, hv₁, one_smul, hf]\n  · simp_rw [Prod.snd_sum, Prod.smul_mk, Fintype.sum_prod_type, mul_smul, ← Fintype.sum_smul_sum,\n      hw₁, one_smul, hg]\n\n"}
{"name":"convexHull_prod","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝⁴ : LinearOrderedField R\ninst✝³ : AddCommGroup E\ninst✝² : AddCommGroup F\ninst✝¹ : Module R E\ninst✝ : Module R F\ns : Set E\nt : Set F\n⊢ Eq ((convexHull R) (SProd.sprod s t)) (SProd.sprod ((convexHull R) s) ((convexHull R) t))","decl":"@[simp]\ntheorem convexHull_prod (s : Set E) (t : Set F) :\n    convexHull R (s ×ˢ t) = convexHull R s ×ˢ convexHull R t :=\n  Subset.antisymm\n      (convexHull_min (prod_mono (subset_convexHull _ _) <| subset_convexHull _ _) <|\n        (convex_convexHull _ _).prod <| convex_convexHull _ _) <|\n    prod_subset_iff.2 fun _ hx _ => mk_mem_convexHull_prod hx\n\n"}
{"name":"convexHull_add","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ns t : Set E\n⊢ Eq ((convexHull R) (HAdd.hAdd s t)) (HAdd.hAdd ((convexHull R) s) ((convexHull R) t))","decl":"theorem convexHull_add (s t : Set E) : convexHull R (s + t) = convexHull R s + convexHull R t := by\n  simp_rw [← add_image_prod, ← IsLinearMap.isLinearMap_add.image_convexHull, convexHull_prod]\n\n"}
{"name":"convexHullAddMonoidHom_apply","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\na : Set E\n⊢ Eq ((convexHullAddMonoidHom R E) a) ((convexHull R) a)","decl":"/-- `convexHull` is an additive monoid morphism under pointwise addition. -/\n@[simps]\ndef convexHullAddMonoidHom : Set E →+ Set E where\n  toFun := convexHull R\n  map_add' := convexHull_add\n  map_zero' := convexHull_zero\n\n"}
{"name":"convexHull_sub","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ns t : Set E\n⊢ Eq ((convexHull R) (HSub.hSub s t)) (HSub.hSub ((convexHull R) s) ((convexHull R) t))","decl":"theorem convexHull_sub (s t : Set E) : convexHull R (s - t) = convexHull R s - convexHull R t := by\n  simp_rw [sub_eq_add_neg, convexHull_add, ← convexHull_neg]\n\n"}
{"name":"convexHull_list_sum","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\nl : List (Set E)\n⊢ Eq ((convexHull R) l.sum) (List.map (⇑(convexHull R)) l).sum","decl":"theorem convexHull_list_sum (l : List (Set E)) : convexHull R l.sum = (l.map <| convexHull R).sum :=\n  map_list_sum (convexHullAddMonoidHom R E) l\n\n"}
{"name":"convexHull_multiset_sum","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ns : Multiset (Set E)\n⊢ Eq ((convexHull R) s.sum) (Multiset.map (⇑(convexHull R)) s).sum","decl":"theorem convexHull_multiset_sum (s : Multiset (Set E)) :\n    convexHull R s.sum = (s.map <| convexHull R).sum :=\n  map_multiset_sum (convexHullAddMonoidHom R E) s\n\n"}
{"name":"convexHull_sum","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\nι : Type u_8\ns : Finset ι\nt : ι → Set E\n⊢ Eq ((convexHull R) (s.sum fun i => t i)) (s.sum fun i => (convexHull R) (t i))","decl":"theorem convexHull_sum {ι} (s : Finset ι) (t : ι → Set E) :\n    convexHull R (∑ i ∈ s, t i) = ∑ i ∈ s, convexHull R (t i) :=\n  map_sum (convexHullAddMonoidHom R E) _ _\n\n"}
{"name":"convexHull_basis_eq_stdSimplex","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nι : Type u_5\ninst✝¹ : LinearOrderedField R\ninst✝ : Fintype ι\n⊢ Eq ((convexHull R) (Set.range fun i j => ite (Eq i j) 1 0)) (stdSimplex R ι)","decl":"open scoped Classical in\n/-- `stdSimplex 𝕜 ι` is the convex hull of the canonical basis in `ι → 𝕜`. -/\ntheorem convexHull_basis_eq_stdSimplex :\n    convexHull R (range fun i j : ι => if i = j then (1 : R) else 0) = stdSimplex R ι := by\n  refine Subset.antisymm (convexHull_min ?_ (convex_stdSimplex R ι)) ?_\n  · rintro _ ⟨i, rfl⟩\n    exact ite_eq_mem_stdSimplex R i\n  · rintro w ⟨hw₀, hw₁⟩\n    rw [pi_eq_sum_univ w, ← Finset.univ.centerMass_eq_of_sum_1 _ hw₁]\n    exact Finset.univ.centerMass_mem_convexHull (fun i _ => hw₀ i) (hw₁.symm ▸ zero_lt_one)\n      fun i _ => mem_range_self i\n\n"}
{"name":"Set.Finite.convexHull_eq_image","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ns : Set E\nhs : s.Finite\n⊢ Eq ((convexHull R) s) (Set.image (⇑(Finset.univ.sum fun x => (LinearMap.proj x).smulRight ↑x)) (stdSimplex R ↑s))","decl":"/-- The convex hull of a finite set is the image of the standard simplex in `s → ℝ`\nunder the linear map sending each function `w` to `∑ x ∈ s, w x • x`.\n\nSince we have no sums over finite sets, we use sum over `@Finset.univ _ hs.fintype`.\nThe map is defined in terms of operations on `(s → ℝ) →ₗ[ℝ] ℝ` so that later we will not need\nto prove that this map is linear. -/\ntheorem Set.Finite.convexHull_eq_image {s : Set E} (hs : s.Finite) : convexHull R s =\n    haveI := hs.fintype\n    (⇑(∑ x : s, (@LinearMap.proj R s _ (fun _ => R) _ _ x).smulRight x.1)) '' stdSimplex R s := by\n  classical\n  letI := hs.fintype\n  rw [← convexHull_basis_eq_stdSimplex, LinearMap.image_convexHull, ← Set.range_comp]\n  apply congr_arg\n  simp_rw [Function.comp_def]\n  convert Subtype.range_coe.symm\n  simp [LinearMap.sum_apply, ite_smul, Finset.filter_eq, Finset.mem_univ]\n\n"}
{"name":"mem_Icc_of_mem_stdSimplex","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nι : Type u_5\ninst✝¹ : LinearOrderedField R\ninst✝ : Fintype ι\nf : ι → R\nhf : Membership.mem (stdSimplex R ι) f\nx : ι\n⊢ Membership.mem (Set.Icc 0 1) (f x)","decl":"/-- All values of a function `f ∈ stdSimplex 𝕜 ι` belong to `[0, 1]`. -/\ntheorem mem_Icc_of_mem_stdSimplex (hf : f ∈ stdSimplex R ι) (x) : f x ∈ Icc (0 : R) 1 :=\n  ⟨hf.1 x, hf.2 ▸ Finset.single_le_sum (fun y _ => hf.1 y) (Finset.mem_univ x)⟩\n\n"}
{"name":"AffineBasis.convexHull_eq_nonneg_coord","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\nι : Type u_8\nb : AffineBasis ι R E\n⊢ Eq ((convexHull R) (Set.range ⇑b)) (setOf fun x => ∀ (i : ι), LE.le 0 ((b.coord i) x))","decl":"/-- The convex hull of an affine basis is the intersection of the half-spaces defined by the\ncorresponding barycentric coordinates. -/\ntheorem AffineBasis.convexHull_eq_nonneg_coord {ι : Type*} (b : AffineBasis ι R E) :\n    convexHull R (range b) = { x | ∀ i, 0 ≤ b.coord i x } := by\n  rw [convexHull_range_eq_exists_affineCombination]\n  ext x\n  refine ⟨?_, fun hx => ?_⟩\n  · rintro ⟨s, w, hw₀, hw₁, rfl⟩ i\n    by_cases hi : i ∈ s\n    · rw [b.coord_apply_combination_of_mem hi hw₁]\n      exact hw₀ i hi\n    · rw [b.coord_apply_combination_of_not_mem hi hw₁]\n  · have hx' : x ∈ affineSpan R (range b) := by\n      rw [b.tot]\n      exact AffineSubspace.mem_top R E x\n    obtain ⟨s, w, hw₁, rfl⟩ := (mem_affineSpan_iff_eq_affineCombination R E).mp hx'\n    refine ⟨s, w, ?_, hw₁, rfl⟩\n    intro i hi\n    specialize hx i\n    rw [b.coord_apply_combination_of_mem hi hw₁] at hx\n    exact hx\n\n"}
{"name":"AffineIndependent.convexHull_inter","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\ns t₁ t₂ : Finset E\nhs : AffineIndependent R Subtype.val\nht₁ : HasSubset.Subset t₁ s\nht₂ : HasSubset.Subset t₂ s\n⊢ Eq ((convexHull R) (Inter.inter ↑t₁ ↑t₂)) (Inter.inter ((convexHull R) ↑t₁) ((convexHull R) ↑t₂))","decl":"/-- Two simplices glue nicely if the union of their vertices is affine independent. -/\nlemma AffineIndependent.convexHull_inter (hs : AffineIndependent R ((↑) : s → E))\n    (ht₁ : t₁ ⊆ s) (ht₂ : t₂ ⊆ s) :\n    convexHull R (t₁ ∩ t₂ : Set E) = convexHull R t₁ ∩ convexHull R t₂ := by\n  classical\n  refine (Set.subset_inter (convexHull_mono inf_le_left) <|\n    convexHull_mono inf_le_right).antisymm ?_\n  simp_rw [Set.subset_def, mem_inter_iff, Set.inf_eq_inter, ← coe_inter, mem_convexHull']\n  rintro x ⟨⟨w₁, h₁w₁, h₂w₁, h₃w₁⟩, w₂, -, h₂w₂, h₃w₂⟩\n  let w (x : E) : R := (if x ∈ t₁ then w₁ x else 0) - if x ∈ t₂ then w₂ x else 0\n  have h₁w : ∑ i ∈ s, w i = 0 := by simp [w, Finset.inter_eq_right.2, *]\n  replace hs := hs.eq_zero_of_sum_eq_zero_subtype h₁w <| by\n    simp only [w, sub_smul, zero_smul, ite_smul, Finset.sum_sub_distrib, ← Finset.sum_filter, h₃w₁,\n      Finset.filter_mem_eq_inter, Finset.inter_eq_right.2 ht₁, Finset.inter_eq_right.2 ht₂, h₃w₂,\n      sub_self]\n  have ht (x) (hx₁ : x ∈ t₁) (hx₂ : x ∉ t₂) : w₁ x = 0 := by\n    simpa [w, hx₁, hx₂] using hs _ (ht₁ hx₁)\n  refine ⟨w₁, ?_, ?_, ?_⟩\n  · simp only [and_imp, Finset.mem_inter]\n    exact fun y hy₁ _ ↦ h₁w₁ y hy₁\n  all_goals\n  · rwa [sum_subset inter_subset_left]\n    rintro x\n    simp_intro hx₁ hx₂\n    simp [ht x hx₁ hx₂]\n\n"}
{"name":"AffineIndependent.convexHull_inter'","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝² : LinearOrderedField R\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\nt₁ t₂ : Finset E\nhs : AffineIndependent R Subtype.val\n⊢ Eq ((convexHull R) (Inter.inter ↑t₁ ↑t₂)) (Inter.inter ((convexHull R) ↑t₁) ((convexHull R) ↑t₂))","decl":"open scoped Classical in\n/-- Two simplices glue nicely if the union of their vertices is affine independent.\n\nNote that `AffineIndependent.convexHull_inter` should be more versatile in most use cases. -/\nlemma AffineIndependent.convexHull_inter' (hs : AffineIndependent R ((↑) : ↑(t₁ ∪ t₂) → E)) :\n    convexHull R (t₁ ∩ t₂ : Set E) = convexHull R t₁ ∩ convexHull R t₂ :=\n  hs.convexHull_inter subset_union_left subset_union_right\n\n"}
{"name":"mem_convexHull_pi","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"𝕜 : Type u_1\nι : Type u_2\nE : ι → Type u_3\ninst✝³ : Finite ι\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : (i : ι) → AddCommGroup (E i)\ninst✝ : (i : ι) → Module 𝕜 (E i)\ns : Set ι\nt : (i : ι) → Set (E i)\nx : (i : ι) → E i\nh : ∀ (i : ι), Membership.mem s i → Membership.mem ((convexHull 𝕜) (t i)) (x i)\n⊢ Membership.mem ((convexHull 𝕜) (s.pi t)) x","decl":"lemma mem_convexHull_pi (h : ∀ i ∈ s, x i ∈ convexHull 𝕜 (t i)) : x ∈ convexHull 𝕜 (s.pi t) := by\n  classical\n  cases nonempty_fintype ι\n  wlog hs : s = Set.univ generalizing s t\n  · rw [← pi_univ_ite]\n    refine this (fun i _ ↦ ?_) rfl\n    split_ifs with hi\n    · exact h i hi\n    · simp\n  subst hs\n  simp only [Set.mem_univ, mem_convexHull_iff_exists_fintype, true_implies, Set.mem_pi] at h\n  choose κ _ w f hw₀ hw₁ hft hf using h\n  refine mem_convexHull_of_exists_fintype (fun k : Π i, κ i ↦ ∏ i, w i (k i)) (fun g i ↦ f _ (g i))\n    (fun g ↦ prod_nonneg fun _ _ ↦ hw₀ _ _) ?_ (fun _ _ _ ↦ hft _ _) ?_\n  · rw [← Fintype.prod_sum]\n    exact prod_eq_one fun _ _ ↦ hw₁ _\n  ext i\n  calc\n    _ = ∑ g : ∀ i, κ i, (∏ i, w i (g i)) • f i (g i) := by\n      simp only [Finset.sum_apply, Pi.smul_apply]\n    _ = ∑ j : κ i, ∑ g : {g : ∀ k, κ k // g i = j},\n          (∏ k, w k (g.1 k)) • f i ((g : ∀ i, κ i) i) := by\n      rw [← Fintype.sum_fiberwise fun g : ∀ k, κ k ↦ g i]\n    _ = ∑ j : κ i, (∑ g : {g : ∀ k, κ k // g i = j}, ∏ k, w k (g.1 k)) • f i j := by\n      simp_rw [sum_smul]\n      congr! with j _ g _\n      exact g.2\n    _ = ∑ j : κ i, w i j • f i j := ?_\n    _ = x i := hf _\n  congr! with j _\n  calc\n    ∑ g : {g : ∀ k, κ k // g i = j}, ∏ k, w k (g.1 k)\n      = ∑ g ∈ piFinset fun k ↦ if hk : k = i then hk ▸ {j} else univ, ∏ k, w k (g k) :=\n      Finset.sum_bij' (fun g _ ↦ g) (fun g hg ↦ ⟨g, by simpa using mem_piFinset.1 hg i⟩)\n        (by aesop) (by simp) (by simp) (by simp) (by simp)\n    _ = w i j := by\n      rw [← prod_univ_sum, ← prod_mul_prod_compl, Finset.prod_singleton, Finset.sum_eq_single,\n        Finset.prod_eq_one, mul_one] <;> simp +contextual [hw₁]\n\n"}
{"name":"convexHull_pi","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"𝕜 : Type u_1\nι : Type u_2\nE : ι → Type u_3\ninst✝³ : Finite ι\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : (i : ι) → AddCommGroup (E i)\ninst✝ : (i : ι) → Module 𝕜 (E i)\ns : Set ι\nt : (i : ι) → Set (E i)\n⊢ Eq ((convexHull 𝕜) (s.pi t)) (s.pi fun i => (convexHull 𝕜) (t i))","decl":"@[simp] lemma convexHull_pi (s : Set ι) (t : Π i, Set (E i)) :\n    convexHull 𝕜 (s.pi t) = s.pi (fun i ↦ convexHull 𝕜 (t i)) :=\n  Set.Subset.antisymm (convexHull_min (Set.pi_mono fun _ _ ↦ subset_convexHull _ _) <| convex_pi <|\n    fun _ _ ↦ convex_convexHull _ _) fun _ ↦ mem_convexHull_pi\n\n"}
