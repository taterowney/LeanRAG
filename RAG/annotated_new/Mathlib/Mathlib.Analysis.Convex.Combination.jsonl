{"name":"Finset.centerMass_empty","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\nw : Î¹ â†’ R\nz : Î¹ â†’ E\nâŠ¢ Eq (EmptyCollection.emptyCollection.centerMass w z) 0","decl":"theorem Finset.centerMass_empty : (âˆ… : Finset Î¹).centerMass w z = 0 := by\n  simp only [centerMass, sum_empty, smul_zero]\n\n"}
{"name":"Finset.centerMass_pair","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ni j : Î¹\nw : Î¹ â†’ R\nz : Î¹ â†’ E\nhne : Ne i j\nâŠ¢ Eq ((Insert.insert i (Singleton.singleton j)).centerMass w z) (HAdd.hAdd (HSMul.hSMul (HDiv.hDiv (w i) (HAdd.hAdd (w i) (w j))) (z i)) (HSMul.hSMul (HDiv.hDiv (w j) (HAdd.hAdd (w i) (w j))) (z j)))","decl":"open scoped Classical in\ntheorem Finset.centerMass_pair (hne : i â‰  j) :\n    ({i, j} : Finset Î¹).centerMass w z = (w i / (w i + w j)) â€¢ z i + (w j / (w i + w j)) â€¢ z j := by\n  simp only [centerMass, sum_pair hne]\n  module\n\n"}
{"name":"Finset.centerMass_insert","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ni : Î¹\nt : Finset Î¹\nw : Î¹ â†’ R\nz : Î¹ â†’ E\nha : Not (Membership.mem t i)\nhw : Ne (t.sum fun j => w j) 0\nâŠ¢ Eq ((Insert.insert i t).centerMass w z) (HAdd.hAdd (HSMul.hSMul (HDiv.hDiv (w i) (HAdd.hAdd (w i) (t.sum fun j => w j))) (z i)) (HSMul.hSMul (HDiv.hDiv (t.sum fun j => w j) (HAdd.hAdd (w i) (t.sum fun j => w j))) (t.centerMass w z)))","decl":"open scoped Classical in\ntheorem Finset.centerMass_insert (ha : i âˆ‰ t) (hw : âˆ‘ j âˆˆ t, w j â‰  0) :\n    (insert i t).centerMass w z =\n      (w i / (w i + âˆ‘ j âˆˆ t, w j)) â€¢ z i +\n        ((âˆ‘ j âˆˆ t, w j) / (w i + âˆ‘ j âˆˆ t, w j)) â€¢ t.centerMass w z := by\n  simp only [centerMass, sum_insert ha, smul_add, (mul_smul _ _ _).symm, â† div_eq_inv_mul]\n  congr 2\n  rw [div_mul_eq_mul_div, mul_inv_cancelâ‚€ hw, one_div]\n\n"}
{"name":"Finset.centerMass_singleton","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ni : Î¹\nw : Î¹ â†’ R\nz : Î¹ â†’ E\nhw : Ne (w i) 0\nâŠ¢ Eq ((Singleton.singleton i).centerMass w z) (z i)","decl":"theorem Finset.centerMass_singleton (hw : w i â‰  0) : ({i} : Finset Î¹).centerMass w z = z i := by\n  rw [centerMass, sum_singleton, sum_singleton]\n  match_scalars\n  field_simp\n\n"}
{"name":"Finset.centerMass_neg_left","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\nt : Finset Î¹\nw : Î¹ â†’ R\nz : Î¹ â†’ E\nâŠ¢ Eq (t.centerMass (Neg.neg w) z) (t.centerMass w z)","decl":"@[simp] lemma Finset.centerMass_neg_left : t.centerMass (-w) z = t.centerMass w z := by\n  simp [centerMass, inv_neg]\n\n"}
{"name":"Finset.centerMass_smul_left","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nR' : Type u_2\nE : Type u_3\nÎ¹ : Type u_5\ninstâœâ¹ : LinearOrderedField R\ninstâœâ¸ : LinearOrderedField R'\ninstâœâ· : AddCommGroup E\ninstâœâ¶ : Module R E\nt : Finset Î¹\nw : Î¹ â†’ R\nz : Î¹ â†’ E\nc : R'\ninstâœâµ : Module R' R\ninstâœâ´ : Module R' E\ninstâœÂ³ : SMulCommClass R' R R\ninstâœÂ² : IsScalarTower R' R R\ninstâœÂ¹ : SMulCommClass R R' E\ninstâœ : IsScalarTower R' R E\nhc : Ne c 0\nâŠ¢ Eq (t.centerMass (HSMul.hSMul c w) z) (t.centerMass w z)","decl":"lemma Finset.centerMass_smul_left {c : R'} [Module R' R] [Module R' E] [SMulCommClass R' R R]\n    [IsScalarTower R' R R] [SMulCommClass R R' E] [IsScalarTower R' R E] (hc : c â‰  0) :\n    t.centerMass (c â€¢ w) z = t.centerMass w z := by\n  simp [centerMass, -smul_assoc, smul_assoc c, â† smul_sum, smul_invâ‚€, smul_smul_smul_comm, hc]\n\n"}
{"name":"Finset.centerMass_eq_of_sum_1","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\nt : Finset Î¹\nw : Î¹ â†’ R\nz : Î¹ â†’ E\nhw : Eq (t.sum fun i => w i) 1\nâŠ¢ Eq (t.centerMass w z) (t.sum fun i => HSMul.hSMul (w i) (z i))","decl":"theorem Finset.centerMass_eq_of_sum_1 (hw : âˆ‘ i âˆˆ t, w i = 1) :\n    t.centerMass w z = âˆ‘ i âˆˆ t, w i â€¢ z i := by\n  simp only [Finset.centerMass, hw, inv_one, one_smul]\n\n"}
{"name":"Finset.centerMass_smul","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\nc : R\nt : Finset Î¹\nw : Î¹ â†’ R\nz : Î¹ â†’ E\nâŠ¢ Eq (t.centerMass w fun i => HSMul.hSMul c (z i)) (HSMul.hSMul c (t.centerMass w z))","decl":"theorem Finset.centerMass_smul : (t.centerMass w fun i => c â€¢ z i) = c â€¢ t.centerMass w z := by\n  simp only [Finset.centerMass, Finset.smul_sum, (mul_smul _ _ _).symm, mul_comm c, mul_assoc]\n\n"}
{"name":"Finset.centerMass_segment'","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\nÎ¹' : Type u_6\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ns : Finset Î¹\nt : Finset Î¹'\nws : Î¹ â†’ R\nzs : Î¹ â†’ E\nwt : Î¹' â†’ R\nzt : Î¹' â†’ E\nhws : Eq (s.sum fun i => ws i) 1\nhwt : Eq (t.sum fun i => wt i) 1\na b : R\nhab : Eq (HAdd.hAdd a b) 1\nâŠ¢ Eq (HAdd.hAdd (HSMul.hSMul a (s.centerMass ws zs)) (HSMul.hSMul b (t.centerMass wt zt))) ((s.disjSum t).centerMass (Sum.elim (fun i => HMul.hMul a (ws i)) fun j => HMul.hMul b (wt j)) (Sum.elim zs zt))","decl":"/-- A convex combination of two centers of mass is a center of mass as well. This version\ndeals with two different index types. -/\ntheorem Finset.centerMass_segment' (s : Finset Î¹) (t : Finset Î¹') (ws : Î¹ â†’ R) (zs : Î¹ â†’ E)\n    (wt : Î¹' â†’ R) (zt : Î¹' â†’ E) (hws : âˆ‘ i âˆˆ s, ws i = 1) (hwt : âˆ‘ i âˆˆ t, wt i = 1) (a b : R)\n    (hab : a + b = 1) : a â€¢ s.centerMass ws zs + b â€¢ t.centerMass wt zt = (s.disjSum t).centerMass\n    (Sum.elim (fun i => a * ws i) fun j => b * wt j) (Sum.elim zs zt) := by\n  rw [s.centerMass_eq_of_sum_1 _ hws, t.centerMass_eq_of_sum_1 _ hwt, smul_sum, smul_sum, â†\n    Finset.sum_sum_elim, Finset.centerMass_eq_of_sum_1]\n  Â· congr with âŸ¨âŸ© <;> simp only [Sum.elim_inl, Sum.elim_inr, mul_smul]\n  Â· rw [sum_sum_elim, â† mul_sum, â† mul_sum, hws, hwt, mul_one, mul_one, hab]\n\n"}
{"name":"Finset.centerMass_segment","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ns : Finset Î¹\nwâ‚ wâ‚‚ : Î¹ â†’ R\nz : Î¹ â†’ E\nhwâ‚ : Eq (s.sum fun i => wâ‚ i) 1\nhwâ‚‚ : Eq (s.sum fun i => wâ‚‚ i) 1\na b : R\nhab : Eq (HAdd.hAdd a b) 1\nâŠ¢ Eq (HAdd.hAdd (HSMul.hSMul a (s.centerMass wâ‚ z)) (HSMul.hSMul b (s.centerMass wâ‚‚ z))) (s.centerMass (fun i => HAdd.hAdd (HMul.hMul a (wâ‚ i)) (HMul.hMul b (wâ‚‚ i))) z)","decl":"/-- A convex combination of two centers of mass is a center of mass as well. This version\nworks if two centers of mass share the set of original points. -/\ntheorem Finset.centerMass_segment (s : Finset Î¹) (wâ‚ wâ‚‚ : Î¹ â†’ R) (z : Î¹ â†’ E)\n    (hwâ‚ : âˆ‘ i âˆˆ s, wâ‚ i = 1) (hwâ‚‚ : âˆ‘ i âˆˆ s, wâ‚‚ i = 1) (a b : R) (hab : a + b = 1) :\n    a â€¢ s.centerMass wâ‚ z + b â€¢ s.centerMass wâ‚‚ z =\n    s.centerMass (fun i => a * wâ‚ i + b * wâ‚‚ i) z := by\n  have hw : (âˆ‘ i âˆˆ s, (a * wâ‚ i + b * wâ‚‚ i)) = 1 := by\n    simp only [â† mul_sum, sum_add_distrib, mul_one, *]\n  simp only [Finset.centerMass_eq_of_sum_1, Finset.centerMass_eq_of_sum_1 _ _ hw,\n    smul_sum, sum_add_distrib, add_smul, mul_smul, *]\n\n"}
{"name":"Finset.centerMass_ite_eq","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ni : Î¹\nt : Finset Î¹\nz : Î¹ â†’ E\nhi : Membership.mem t i\nâŠ¢ Eq (t.centerMass (fun j => ite (Eq i j) 1 0) z) (z i)","decl":"open scoped Classical in\ntheorem Finset.centerMass_ite_eq (hi : i âˆˆ t) :\n    t.centerMass (fun j => if i = j then (1 : R) else 0) z = z i := by\n  rw [Finset.centerMass_eq_of_sum_1]\n  Â· trans âˆ‘ j âˆˆ t, if i = j then z i else 0\n    Â· congr with i\n      split_ifs with h\n      exacts [h â–¸ one_smul _ _, zero_smul _ _]\n    Â· rw [sum_ite_eq, if_pos hi]\n  Â· rw [sum_ite_eq, if_pos hi]\n\n"}
{"name":"Finset.centerMass_subset","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\nt : Finset Î¹\nw : Î¹ â†’ R\nz : Î¹ â†’ E\nt' : Finset Î¹\nht : HasSubset.Subset t t'\nh : âˆ€ (i : Î¹), Membership.mem t' i â†’ Not (Membership.mem t i) â†’ Eq (w i) 0\nâŠ¢ Eq (t.centerMass w z) (t'.centerMass w z)","decl":"theorem Finset.centerMass_subset {t' : Finset Î¹} (ht : t âŠ† t') (h : âˆ€ i âˆˆ t', i âˆ‰ t â†’ w i = 0) :\n    t.centerMass w z = t'.centerMass w z := by\n  rw [centerMass, sum_subset ht h, smul_sum, centerMass, smul_sum]\n  apply sum_subset ht\n  intro i hit' hit\n  rw [h i hit' hit, zero_smul, smul_zero]\n\n"}
{"name":"Finset.centerMass_filter_ne_zero","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\nt : Finset Î¹\nw : Î¹ â†’ R\nz : Î¹ â†’ E\nâŠ¢ Eq ((Finset.filter (fun i => Ne (w i) 0) t).centerMass w z) (t.centerMass w z)","decl":"theorem Finset.centerMass_filter_ne_zero : {i âˆˆ t | w i â‰  0}.centerMass w z = t.centerMass w z :=\n  Finset.centerMass_subset z (filter_subset _ _) fun i hit hit' => by\n    simpa only [hit, mem_filter, true_and, Ne, Classical.not_not] using hit'\n\n"}
{"name":"Finset.centerMass_le_sup","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nÎ¹ : Type u_5\nÎ± : Type u_7\ninstâœÂ³ : LinearOrderedField R\ninstâœÂ² : LinearOrderedAddCommGroup Î±\ninstâœÂ¹ : Module R Î±\ninstâœ : OrderedSMul R Î±\ns : Finset Î¹\nf : Î¹ â†’ Î±\nw : Î¹ â†’ R\nhwâ‚€ : âˆ€ (i : Î¹), Membership.mem s i â†’ LE.le 0 (w i)\nhwâ‚ : LT.lt 0 (s.sum fun i => w i)\nâŠ¢ LE.le (s.centerMass w f) (s.sup' â‹¯ f)","decl":"theorem centerMass_le_sup {s : Finset Î¹} {f : Î¹ â†’ Î±} {w : Î¹ â†’ R} (hwâ‚€ : âˆ€ i âˆˆ s, 0 â‰¤ w i)\n    (hwâ‚ : 0 < âˆ‘ i âˆˆ s, w i) :\n    s.centerMass w f â‰¤ s.sup' (nonempty_of_ne_empty <| by rintro rfl; simp at hwâ‚) f := by\n  rw [centerMass, inv_smul_le_iff_of_pos hwâ‚, sum_smul]\n  exact sum_le_sum fun i hi => smul_le_smul_of_nonneg_left (le_sup' _ hi) <| hwâ‚€ i hi\n\n"}
{"name":"Finset.inf_le_centerMass","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nÎ¹ : Type u_5\nÎ± : Type u_7\ninstâœÂ³ : LinearOrderedField R\ninstâœÂ² : LinearOrderedAddCommGroup Î±\ninstâœÂ¹ : Module R Î±\ninstâœ : OrderedSMul R Î±\ns : Finset Î¹\nf : Î¹ â†’ Î±\nw : Î¹ â†’ R\nhwâ‚€ : âˆ€ (i : Î¹), Membership.mem s i â†’ LE.le 0 (w i)\nhwâ‚ : LT.lt 0 (s.sum fun i => w i)\nâŠ¢ LE.le (s.inf' â‹¯ f) (s.centerMass w f)","decl":"theorem inf_le_centerMass {s : Finset Î¹} {f : Î¹ â†’ Î±} {w : Î¹ â†’ R} (hwâ‚€ : âˆ€ i âˆˆ s, 0 â‰¤ w i)\n    (hwâ‚ : 0 < âˆ‘ i âˆˆ s, w i) :\n    s.inf' (nonempty_of_ne_empty <| by rintro rfl; simp at hwâ‚) f â‰¤ s.centerMass w f :=\n  @centerMass_le_sup R _ Î±áµ’áµˆ _ _ _ _ _ _ _ hwâ‚€ hwâ‚\n\n"}
{"name":"Finset.centerMass_of_sum_add_sum_eq_zero","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\nw : Î¹ â†’ R\nz : Î¹ â†’ E\ns t : Finset Î¹\nhw : Eq (HAdd.hAdd (s.sum fun i => w i) (t.sum fun i => w i)) 0\nhz : Eq (HAdd.hAdd (s.sum fun i => HSMul.hSMul (w i) (z i)) (t.sum fun i => HSMul.hSMul (w i) (z i))) 0\nâŠ¢ Eq (s.centerMass w z) (t.centerMass w z)","decl":"lemma Finset.centerMass_of_sum_add_sum_eq_zero {s t : Finset Î¹}\n    (hw : âˆ‘ i âˆˆ s, w i + âˆ‘ i âˆˆ t, w i = 0) (hz : âˆ‘ i âˆˆ s, w i â€¢ z i + âˆ‘ i âˆˆ t, w i â€¢ z i = 0) :\n    s.centerMass w z = t.centerMass w z := by\n  simp [centerMass, eq_neg_of_add_eq_zero_right hw, eq_neg_of_add_eq_zero_left hz, â† neg_inv]\n\n"}
{"name":"Convex.centerMass_mem","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ns : Set E\nt : Finset Î¹\nw : Î¹ â†’ R\nz : Î¹ â†’ E\nhs : Convex R s\naâœÂ² : âˆ€ (i : Î¹), Membership.mem t i â†’ LE.le 0 (w i)\naâœÂ¹ : LT.lt 0 (t.sum fun i => w i)\naâœ : âˆ€ (i : Î¹), Membership.mem t i â†’ Membership.mem s (z i)\nâŠ¢ Membership.mem s (t.centerMass w z)","decl":"/-- The center of mass of a finite subset of a convex set belongs to the set\nprovided that all weights are non-negative, and the total weight is positive. -/\ntheorem Convex.centerMass_mem (hs : Convex R s) :\n    (âˆ€ i âˆˆ t, 0 â‰¤ w i) â†’ (0 < âˆ‘ i âˆˆ t, w i) â†’ (âˆ€ i âˆˆ t, z i âˆˆ s) â†’ t.centerMass w z âˆˆ s := by\n  classical\n  induction' t using Finset.induction with i t hi ht\n  Â· simp [lt_irrefl]\n  intro hâ‚€ hpos hmem\n  have zi : z i âˆˆ s := hmem _ (mem_insert_self _ _)\n  have hsâ‚€ : âˆ€ j âˆˆ t, 0 â‰¤ w j := fun j hj => hâ‚€ j <| mem_insert_of_mem hj\n  rw [sum_insert hi] at hpos\n  by_cases hsum_t : âˆ‘ j âˆˆ t, w j = 0\n  Â· have ws : âˆ€ j âˆˆ t, w j = 0 := (sum_eq_zero_iff_of_nonneg hsâ‚€).1 hsum_t\n    have wz : âˆ‘ j âˆˆ t, w j â€¢ z j = 0 := sum_eq_zero fun i hi => by simp [ws i hi]\n    simp only [centerMass, sum_insert hi, wz, hsum_t, add_zero]\n    simp only [hsum_t, add_zero] at hpos\n    rw [â† mul_smul, inv_mul_cancelâ‚€ (ne_of_gt hpos), one_smul]\n    exact zi\n  Â· rw [Finset.centerMass_insert _ _ _ hi hsum_t]\n    refine convex_iff_div.1 hs zi (ht hsâ‚€ ?_ ?_) ?_ (sum_nonneg hsâ‚€) hpos\n    Â· exact lt_of_le_of_ne (sum_nonneg hsâ‚€) (Ne.symm hsum_t)\n    Â· intro j hj\n      exact hmem j (mem_insert_of_mem hj)\n    Â· exact hâ‚€ _ (mem_insert_self _ _)\n\n"}
{"name":"Convex.sum_mem","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ns : Set E\nt : Finset Î¹\nw : Î¹ â†’ R\nz : Î¹ â†’ E\nhs : Convex R s\nhâ‚€ : âˆ€ (i : Î¹), Membership.mem t i â†’ LE.le 0 (w i)\nhâ‚ : Eq (t.sum fun i => w i) 1\nhz : âˆ€ (i : Î¹), Membership.mem t i â†’ Membership.mem s (z i)\nâŠ¢ Membership.mem s (t.sum fun i => HSMul.hSMul (w i) (z i))","decl":"theorem Convex.sum_mem (hs : Convex R s) (hâ‚€ : âˆ€ i âˆˆ t, 0 â‰¤ w i) (hâ‚ : âˆ‘ i âˆˆ t, w i = 1)\n    (hz : âˆ€ i âˆˆ t, z i âˆˆ s) : (âˆ‘ i âˆˆ t, w i â€¢ z i) âˆˆ s := by\n  simpa only [hâ‚, centerMass, inv_one, one_smul] using\n    hs.centerMass_mem hâ‚€ (hâ‚.symm â–¸ zero_lt_one) hz\n\n"}
{"name":"Convex.finsum_mem","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\nÎ¹ : Sort u_8\nw : Î¹ â†’ R\nz : Î¹ â†’ E\ns : Set E\nhs : Convex R s\nhâ‚€ : âˆ€ (i : Î¹), LE.le 0 (w i)\nhâ‚ : Eq (finsum fun i => w i) 1\nhz : âˆ€ (i : Î¹), Ne (w i) 0 â†’ Membership.mem s (z i)\nâŠ¢ Membership.mem s (finsum fun i => HSMul.hSMul (w i) (z i))","decl":"/-- A version of `Convex.sum_mem` for `finsum`s. If `s` is a convex set, `w : Î¹ â†’ R` is a family of\nnonnegative weights with sum one and `z : Î¹ â†’ E` is a family of elements of a module over `R` such\nthat `z i âˆˆ s` whenever `w i â‰  0`, then the sum `âˆ‘á¶  i, w i â€¢ z i` belongs to `s`. See also\n`PartitionOfUnity.finsum_smul_mem_convex`. -/\ntheorem Convex.finsum_mem {Î¹ : Sort*} {w : Î¹ â†’ R} {z : Î¹ â†’ E} {s : Set E} (hs : Convex R s)\n    (hâ‚€ : âˆ€ i, 0 â‰¤ w i) (hâ‚ : âˆ‘á¶  i, w i = 1) (hz : âˆ€ i, w i â‰  0 â†’ z i âˆˆ s) :\n    (âˆ‘á¶  i, w i â€¢ z i) âˆˆ s := by\n  have hfin_w : (support (w âˆ˜ PLift.down)).Finite := by\n    by_contra H\n    rw [finsum, dif_neg H] at hâ‚\n    exact zero_ne_one hâ‚\n  have hsub : support ((fun i => w i â€¢ z i) âˆ˜ PLift.down) âŠ† hfin_w.toFinset :=\n    (support_smul_subset_left _ _).trans hfin_w.coe_toFinset.ge\n  rw [finsum_eq_sum_plift_of_support_subset hsub]\n  refine hs.sum_mem (fun _ _ => hâ‚€ _) ?_ fun i hi => hz _ ?_\n  Â· rwa [finsum, dif_pos hfin_w] at hâ‚\n  Â· rwa [hfin_w.mem_toFinset] at hi\n\n"}
{"name":"convex_iff_sum_mem","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ns : Set E\nâŠ¢ Iff (Convex R s) (âˆ€ (t : Finset E) (w : E â†’ R), (âˆ€ (i : E), Membership.mem t i â†’ LE.le 0 (w i)) â†’ Eq (t.sum fun i => w i) 1 â†’ (âˆ€ (x : E), Membership.mem t x â†’ Membership.mem s x) â†’ Membership.mem s (t.sum fun x => HSMul.hSMul (w x) x))","decl":"theorem convex_iff_sum_mem : Convex R s â†” âˆ€ (t : Finset E) (w : E â†’ R),\n    (âˆ€ i âˆˆ t, 0 â‰¤ w i) â†’ âˆ‘ i âˆˆ t, w i = 1 â†’ (âˆ€ x âˆˆ t, x âˆˆ s) â†’ (âˆ‘ x âˆˆ t, w x â€¢ x) âˆˆ s := by\n  classical\n  refine âŸ¨fun hs t w hwâ‚€ hwâ‚ hts => hs.sum_mem hwâ‚€ hwâ‚ hts, ?_âŸ©\n  intro h x hx y hy a b ha hb hab\n  by_cases h_cases : x = y\n  Â· rw [h_cases, â† add_smul, hab, one_smul]\n    exact hy\n  Â· convert h {x, y} (fun z => if z = y then b else a) _ _ _\n    -- Porting note: Original proof had 2 `simp_intro i hi`\n    Â· simp only [sum_pair h_cases, if_neg h_cases, if_pos trivial]\n    Â· intro i _\n      simp only\n      split_ifs <;> assumption\n    Â· simp only [sum_pair h_cases, if_neg h_cases, if_pos trivial, hab]\n    Â· intro i hi\n      simp only [Finset.mem_singleton, Finset.mem_insert] at hi\n      cases hi <;> subst i <;> assumption\n\n"}
{"name":"Finset.centerMass_mem_convexHull","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ns : Set E\nt : Finset Î¹\nw : Î¹ â†’ R\nhwâ‚€ : âˆ€ (i : Î¹), Membership.mem t i â†’ LE.le 0 (w i)\nhws : LT.lt 0 (t.sum fun i => w i)\nz : Î¹ â†’ E\nhz : âˆ€ (i : Î¹), Membership.mem t i â†’ Membership.mem s (z i)\nâŠ¢ Membership.mem ((convexHull R) s) (t.centerMass w z)","decl":"theorem Finset.centerMass_mem_convexHull (t : Finset Î¹) {w : Î¹ â†’ R} (hwâ‚€ : âˆ€ i âˆˆ t, 0 â‰¤ w i)\n    (hws : 0 < âˆ‘ i âˆˆ t, w i) {z : Î¹ â†’ E} (hz : âˆ€ i âˆˆ t, z i âˆˆ s) :\n    t.centerMass w z âˆˆ convexHull R s :=\n  (convex_convexHull R s).centerMass_mem hwâ‚€ hws fun i hi => subset_convexHull R s <| hz i hi\n\n"}
{"name":"Finset.centerMass_mem_convexHull_of_nonpos","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ns : Set E\nw : Î¹ â†’ R\nz : Î¹ â†’ E\nt : Finset Î¹\nhwâ‚€ : âˆ€ (i : Î¹), Membership.mem t i â†’ LE.le (w i) 0\nhws : LT.lt (t.sum fun i => w i) 0\nhz : âˆ€ (i : Î¹), Membership.mem t i â†’ Membership.mem s (z i)\nâŠ¢ Membership.mem ((convexHull R) s) (t.centerMass w z)","decl":"/-- A version of `Finset.centerMass_mem_convexHull` for when the weights are nonpositive. -/\nlemma Finset.centerMass_mem_convexHull_of_nonpos (t : Finset Î¹) (hwâ‚€ : âˆ€ i âˆˆ t, w i â‰¤ 0)\n    (hws : âˆ‘ i âˆˆ t, w i < 0) (hz : âˆ€ i âˆˆ t, z i âˆˆ s) : t.centerMass w z âˆˆ convexHull R s := by\n  rw [â† centerMass_neg_left]\n  exact Finset.centerMass_mem_convexHull _ (fun _i hi â†¦ neg_nonneg.2 <| hwâ‚€ _ hi) (by simpa) hz\n\n"}
{"name":"Finset.centerMass_id_mem_convexHull","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\nt : Finset E\nw : E â†’ R\nhwâ‚€ : âˆ€ (i : E), Membership.mem t i â†’ LE.le 0 (w i)\nhws : LT.lt 0 (t.sum fun i => w i)\nâŠ¢ Membership.mem ((convexHull R) â†‘t) (t.centerMass w id)","decl":"/-- A refinement of `Finset.centerMass_mem_convexHull` when the indexed family is a `Finset` of\nthe space. -/\ntheorem Finset.centerMass_id_mem_convexHull (t : Finset E) {w : E â†’ R} (hwâ‚€ : âˆ€ i âˆˆ t, 0 â‰¤ w i)\n    (hws : 0 < âˆ‘ i âˆˆ t, w i) : t.centerMass w id âˆˆ convexHull R (t : Set E) :=\n  t.centerMass_mem_convexHull hwâ‚€ hws fun _ => mem_coe.2\n\n"}
{"name":"Finset.centerMass_id_mem_convexHull_of_nonpos","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\nt : Finset E\nw : E â†’ R\nhwâ‚€ : âˆ€ (i : E), Membership.mem t i â†’ LE.le (w i) 0\nhws : LT.lt (t.sum fun i => w i) 0\nâŠ¢ Membership.mem ((convexHull R) â†‘t) (t.centerMass w id)","decl":"/-- A version of `Finset.centerMass_mem_convexHull` for when the weights are nonpositive. -/\nlemma Finset.centerMass_id_mem_convexHull_of_nonpos (t : Finset E) {w : E â†’ R}\n    (hwâ‚€ : âˆ€ i âˆˆ t, w i â‰¤ 0) (hws : âˆ‘ i âˆˆ t, w i < 0) :\n    t.centerMass w id âˆˆ convexHull R (t : Set E) :=\n  t.centerMass_mem_convexHull_of_nonpos hwâ‚€ hws fun _ â†¦ mem_coe.2\n\n"}
{"name":"affineCombination_eq_centerMass","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\nÎ¹ : Type u_8\nt : Finset Î¹\np : Î¹ â†’ E\nw : Î¹ â†’ R\nhwâ‚‚ : Eq (t.sum fun i => w i) 1\nâŠ¢ Eq ((Finset.affineCombination R t p) w) (t.centerMass w p)","decl":"theorem affineCombination_eq_centerMass {Î¹ : Type*} {t : Finset Î¹} {p : Î¹ â†’ E} {w : Î¹ â†’ R}\n    (hwâ‚‚ : âˆ‘ i âˆˆ t, w i = 1) : t.affineCombination R p w = centerMass t w p := by\n  rw [affineCombination_eq_weightedVSubOfPoint_vadd_of_sum_eq_one _ w _ hwâ‚‚ (0 : E),\n    Finset.weightedVSubOfPoint_apply, vadd_eq_add, add_zero, t.centerMass_eq_of_sum_1 _ hwâ‚‚]\n  simp_rw [vsub_eq_sub, sub_zero]\n\n"}
{"name":"affineCombination_mem_convexHull","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ns : Finset Î¹\nv : Î¹ â†’ E\nw : Î¹ â†’ R\nhwâ‚€ : âˆ€ (i : Î¹), Membership.mem s i â†’ LE.le 0 (w i)\nhwâ‚ : Eq (s.sum w) 1\nâŠ¢ Membership.mem ((convexHull R) (Set.range v)) ((Finset.affineCombination R s v) w)","decl":"theorem affineCombination_mem_convexHull {s : Finset Î¹} {v : Î¹ â†’ E} {w : Î¹ â†’ R}\n    (hwâ‚€ : âˆ€ i âˆˆ s, 0 â‰¤ w i) (hwâ‚ : s.sum w = 1) :\n    s.affineCombination R v w âˆˆ convexHull R (range v) := by\n  rw [affineCombination_eq_centerMass hwâ‚]\n  apply s.centerMass_mem_convexHull hwâ‚€\n  Â· simp [hwâ‚]\n  Â· simp\n\n"}
{"name":"Finset.centroid_eq_centerMass","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ns : Finset Î¹\nhs : s.Nonempty\np : Î¹ â†’ E\nâŠ¢ Eq (Finset.centroid R s p) (s.centerMass (Finset.centroidWeights R s) p)","decl":"/-- The centroid can be regarded as a center of mass. -/\n@[simp]\ntheorem Finset.centroid_eq_centerMass (s : Finset Î¹) (hs : s.Nonempty) (p : Î¹ â†’ E) :\n    s.centroid R p = s.centerMass (s.centroidWeights R) p :=\n  affineCombination_eq_centerMass (s.sum_centroidWeights_eq_one_of_nonempty R hs)\n\n"}
{"name":"Finset.centroid_mem_convexHull","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ns : Finset E\nhs : s.Nonempty\nâŠ¢ Membership.mem ((convexHull R) â†‘s) (Finset.centroid R s id)","decl":"theorem Finset.centroid_mem_convexHull (s : Finset E) (hs : s.Nonempty) :\n    s.centroid R id âˆˆ convexHull R (s : Set E) := by\n  rw [s.centroid_eq_centerMass hs]\n  apply s.centerMass_id_mem_convexHull\n  Â· simp only [inv_nonneg, imp_true_iff, Nat.cast_nonneg, Finset.centroidWeights_apply]\n  Â· have hs_card : (#s : R) â‰  0 := by simp [Finset.nonempty_iff_ne_empty.mp hs]\n    simp only [hs_card, Finset.sum_const, nsmul_eq_mul, mul_inv_cancelâ‚€, Ne, not_false_iff,\n      Finset.centroidWeights_apply, zero_lt_one]\n\n"}
{"name":"convexHull_range_eq_exists_affineCombination","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\nv : Î¹ â†’ E\nâŠ¢ Eq ((convexHull R) (Set.range v)) (setOf fun x => Exists fun s => Exists fun w => And (âˆ€ (i : Î¹), Membership.mem s i â†’ LE.le 0 (w i)) (And (Eq (s.sum w) 1) (Eq ((Finset.affineCombination R s v) w) x)))","decl":"theorem convexHull_range_eq_exists_affineCombination (v : Î¹ â†’ E) : convexHull R (range v) =\n    { x | âˆƒ (s : Finset Î¹) (w : Î¹ â†’ R), (âˆ€ i âˆˆ s, 0 â‰¤ w i) âˆ§ s.sum w = 1 âˆ§\n      s.affineCombination R v w = x } := by\n  classical\n  refine Subset.antisymm (convexHull_min ?_ ?_) ?_\n  Â· intro x hx\n    obtain âŸ¨i, hiâŸ© := Set.mem_range.mp hx\n    exact âŸ¨{i}, Function.const Î¹ (1 : R), by simp, by simp, by simp [hi]âŸ©\n  Â· rintro x âŸ¨s, w, hwâ‚€, hwâ‚, rflâŸ© y âŸ¨s', w', hwâ‚€', hwâ‚', rflâŸ© a b ha hb hab\n    let W : Î¹ â†’ R := fun i => (if i âˆˆ s then a * w i else 0) + if i âˆˆ s' then b * w' i else 0\n    have hWâ‚ : (s âˆª s').sum W = 1 := by\n      rw [sum_add_distrib, â† sum_subset subset_union_left,\n        â† sum_subset subset_union_right, sum_ite_of_true,\n        sum_ite_of_true, â† mul_sum, â† mul_sum, hwâ‚, hwâ‚', â† add_mul, hab,\n        mul_one] <;> intros <;> simp_all\n    refine âŸ¨s âˆª s', W, ?_, hWâ‚, ?_âŸ©\n    Â· rintro i -\n      by_cases hi : i âˆˆ s <;> by_cases hi' : i âˆˆ s' <;>\n        simp [W, hi, hi', add_nonneg, mul_nonneg ha (hwâ‚€ i _), mul_nonneg hb (hwâ‚€' i _)]\n    Â· simp_rw [W, affineCombination_eq_linear_combination (s âˆª s') v _ hWâ‚,\n        affineCombination_eq_linear_combination s v w hwâ‚,\n        affineCombination_eq_linear_combination s' v w' hwâ‚', add_smul, sum_add_distrib]\n      rw [â† sum_subset subset_union_left, â† sum_subset subset_union_right]\n      Â· simp only [ite_smul, sum_ite_of_true fun _ hi => hi, mul_smul, â† smul_sum]\n      Â· intro i _ hi'\n        simp [hi']\n      Â· intro i _ hi'\n        simp [hi']\n  Â· rintro x âŸ¨s, w, hwâ‚€, hwâ‚, rflâŸ©\n    exact affineCombination_mem_convexHull hwâ‚€ hwâ‚\n\n"}
{"name":"convexHull_eq","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ns : Set E\nâŠ¢ Eq ((convexHull R) s) (setOf fun x => Exists fun Î¹ => Exists fun t => Exists fun w => Exists fun z => And (âˆ€ (i : Î¹), Membership.mem t i â†’ LE.le 0 (w i)) (And (Eq (t.sum fun i => w i) 1) (And (âˆ€ (i : Î¹), Membership.mem t i â†’ Membership.mem s (z i)) (Eq (t.centerMass w z) x))))","decl":"/--\nConvex hull of `s` is equal to the set of all centers of masses of `Finset`s `t`, `z '' t âŠ† s`.\nFor universe reasons, you shouldn't use this lemma to prove that a given center of mass belongs\nto the convex hull. Use convexity of the convex hull instead.\n-/\ntheorem convexHull_eq (s : Set E) : convexHull R s =\n    { x : E | âˆƒ (Î¹ : Type) (t : Finset Î¹) (w : Î¹ â†’ R) (z : Î¹ â†’ E), (âˆ€ i âˆˆ t, 0 â‰¤ w i) âˆ§\n      âˆ‘ i âˆˆ t, w i = 1 âˆ§ (âˆ€ i âˆˆ t, z i âˆˆ s) âˆ§ t.centerMass w z = x } := by\n  refine Subset.antisymm (convexHull_min ?_ ?_) ?_\n  Â· intro x hx\n    use PUnit, {PUnit.unit}, fun _ => 1, fun _ => x, fun _ _ => zero_le_one, sum_singleton _ _,\n      fun _ _ => hx\n    simp only [Finset.centerMass, Finset.sum_singleton, inv_one, one_smul]\n  Â· rintro x âŸ¨Î¹, sx, wx, zx, hwxâ‚€, hwxâ‚, hzx, rflâŸ© y âŸ¨Î¹', sy, wy, zy, hwyâ‚€, hwyâ‚, hzy, rflâŸ© a b ha\n      hb hab\n    rw [Finset.centerMass_segment' _ _ _ _ _ _ hwxâ‚ hwyâ‚ _ _ hab]\n    refine âŸ¨_, _, _, _, ?_, ?_, ?_, rflâŸ©\n    Â· rintro i hi\n      rw [Finset.mem_disjSum] at hi\n      rcases hi with (âŸ¨j, hj, rflâŸ© | âŸ¨j, hj, rflâŸ©) <;> simp only [Sum.elim_inl, Sum.elim_inr] <;>\n        apply_rules [mul_nonneg, hwxâ‚€, hwyâ‚€]\n    Â· simp [Finset.sum_sum_elim, â† mul_sum, *]\n    Â· intro i hi\n      rw [Finset.mem_disjSum] at hi\n      rcases hi with (âŸ¨j, hj, rflâŸ© | âŸ¨j, hj, rflâŸ©) <;> apply_rules [hzx, hzy]\n  Â· rintro _ âŸ¨Î¹, t, w, z, hwâ‚€, hwâ‚, hz, rflâŸ©\n    exact t.centerMass_mem_convexHull hwâ‚€ (hwâ‚.symm â–¸ zero_lt_one) hz\n\n"}
{"name":"mem_convexHull_of_exists_fintype","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nÎ¹ : Type u_5\ninstâœÂ³ : LinearOrderedField R\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module R E\ns : Set E\nx : E\ninstâœ : Fintype Î¹\nw : Î¹ â†’ R\nz : Î¹ â†’ E\nhwâ‚€ : âˆ€ (i : Î¹), LE.le 0 (w i)\nhwâ‚ : Eq (Finset.univ.sum fun i => w i) 1\nhz : âˆ€ (i : Î¹), Membership.mem s (z i)\nhx : Eq (Finset.univ.sum fun i => HSMul.hSMul (w i) (z i)) x\nâŠ¢ Membership.mem ((convexHull R) s) x","decl":"/-- Universe polymorphic version of the reverse implication of `mem_convexHull_iff_exists_fintype`.\n-/\nlemma mem_convexHull_of_exists_fintype {s : Set E} {x : E} [Fintype Î¹] (w : Î¹ â†’ R) (z : Î¹ â†’ E)\n    (hwâ‚€ : âˆ€ i, 0 â‰¤ w i) (hwâ‚ : âˆ‘ i, w i = 1) (hz : âˆ€ i, z i âˆˆ s) (hx : âˆ‘ i, w i â€¢ z i = x) :\n    x âˆˆ convexHull R s := by\n  rw [â† hx, â† centerMass_eq_of_sum_1 _ _ hwâ‚]\n  exact centerMass_mem_convexHull _ (by simpa using hwâ‚€) (by simp [hwâ‚]) (by simpa using hz)\n\n"}
{"name":"mem_convexHull_iff_exists_fintype","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ns : Set E\nx : E\nâŠ¢ Iff (Membership.mem ((convexHull R) s) x) (Exists fun Î¹ => Exists fun x_1 => Exists fun w => Exists fun z => And (âˆ€ (i : Î¹), LE.le 0 (w i)) (And (Eq (Finset.univ.sum fun i => w i) 1) (And (âˆ€ (i : Î¹), Membership.mem s (z i)) (Eq (Finset.univ.sum fun i => HSMul.hSMul (w i) (z i)) x))))","decl":"/-- The convex hull of `s` is equal to the set of centers of masses of finite families of points in\n`s`.\n\nFor universe reasons, you shouldn't use this lemma to prove that a given center of mass belongs\nto the convex hull. Use `mem_convexHull_of_exists_fintype` of the convex hull instead. -/\nlemma mem_convexHull_iff_exists_fintype {s : Set E} {x : E} :\n    x âˆˆ convexHull R s â†” âˆƒ (Î¹ : Type) (_ : Fintype Î¹) (w : Î¹ â†’ R) (z : Î¹ â†’ E), (âˆ€ i, 0 â‰¤ w i) âˆ§\n      âˆ‘ i, w i = 1 âˆ§ (âˆ€ i, z i âˆˆ s) âˆ§ âˆ‘ i, w i â€¢ z i = x := by\n  constructor\n  Â· simp only [convexHull_eq, mem_setOf_eq]\n    rintro âŸ¨Î¹, t, w, z, hâŸ©\n    refine âŸ¨t, inferInstance, w âˆ˜ (â†‘), z âˆ˜ (â†‘), ?_âŸ©\n    simpa [â† sum_attach t, centerMass_eq_of_sum_1 _ _ h.2.1] using h\n  Â· rintro âŸ¨Î¹, _, w, z, hwâ‚€, hwâ‚, hz, hxâŸ©\n    exact mem_convexHull_of_exists_fintype w z hwâ‚€ hwâ‚ hz hx\n\n"}
{"name":"Finset.convexHull_eq","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ns : Finset E\nâŠ¢ Eq ((convexHull R) â†‘s) (setOf fun x => Exists fun w => And (âˆ€ (y : E), Membership.mem s y â†’ LE.le 0 (w y)) (And (Eq (s.sum fun y => w y) 1) (Eq (s.centerMass w id) x)))","decl":"theorem Finset.convexHull_eq (s : Finset E) : convexHull R â†‘s =\n    { x : E | âˆƒ w : E â†’ R, (âˆ€ y âˆˆ s, 0 â‰¤ w y) âˆ§ âˆ‘ y âˆˆ s, w y = 1 âˆ§ s.centerMass w id = x } := by\n  classical\n  refine Set.Subset.antisymm (convexHull_min ?_ ?_) ?_\n  Â· intro x hx\n    rw [Finset.mem_coe] at hx\n    refine âŸ¨_, ?_, ?_, Finset.centerMass_ite_eq _ _ _ hxâŸ©\n    Â· intros\n      split_ifs\n      exacts [zero_le_one, le_refl 0]\n    Â· rw [Finset.sum_ite_eq, if_pos hx]\n  Â· rintro x âŸ¨wx, hwxâ‚€, hwxâ‚, rflâŸ© y âŸ¨wy, hwyâ‚€, hwyâ‚, rflâŸ© a b ha hb hab\n    rw [Finset.centerMass_segment _ _ _ _ hwxâ‚ hwyâ‚ _ _ hab]\n    refine âŸ¨_, ?_, ?_, rflâŸ©\n    Â· rintro i hi\n      apply_rules [add_nonneg, mul_nonneg, hwxâ‚€, hwyâ‚€]\n    Â· simp only [Finset.sum_add_distrib, â† mul_sum, mul_one, *]\n  Â· rintro _ âŸ¨w, hwâ‚€, hwâ‚, rflâŸ©\n    exact\n      s.centerMass_mem_convexHull (fun x hx => hwâ‚€ _ hx) (hwâ‚.symm â–¸ zero_lt_one) fun x hx => hx\n\n"}
{"name":"Finset.mem_convexHull","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ns : Finset E\nx : E\nâŠ¢ Iff (Membership.mem ((convexHull R) â†‘s) x) (Exists fun w => And (âˆ€ (y : E), Membership.mem s y â†’ LE.le 0 (w y)) (And (Eq (s.sum fun y => w y) 1) (Eq (s.centerMass w id) x)))","decl":"theorem Finset.mem_convexHull {s : Finset E} {x : E} : x âˆˆ convexHull R (s : Set E) â†”\n    âˆƒ w : E â†’ R, (âˆ€ y âˆˆ s, 0 â‰¤ w y) âˆ§ âˆ‘ y âˆˆ s, w y = 1 âˆ§ s.centerMass w id = x := by\n  rw [Finset.convexHull_eq, Set.mem_setOf_eq]\n\n"}
{"name":"Finset.mem_convexHull'","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ns : Finset E\nx : E\nâŠ¢ Iff (Membership.mem ((convexHull R) â†‘s) x) (Exists fun w => And (âˆ€ (y : E), Membership.mem s y â†’ LE.le 0 (w y)) (And (Eq (s.sum fun y => w y) 1) (Eq (s.sum fun y => HSMul.hSMul (w y) y) x)))","decl":"/-- This is a version of `Finset.mem_convexHull` stated without `Finset.centerMass`. -/\nlemma Finset.mem_convexHull' {s : Finset E} {x : E} :\n    x âˆˆ convexHull R (s : Set E) â†”\n      âˆƒ w : E â†’ R, (âˆ€ y âˆˆ s, 0 â‰¤ w y) âˆ§ âˆ‘ y âˆˆ s, w y = 1 âˆ§ âˆ‘ y âˆˆ s, w y â€¢ y = x := by\n  rw [mem_convexHull]\n  refine exists_congr fun w â†¦ and_congr_right' <| and_congr_right fun hw â†¦ ?_\n  simp_rw [centerMass_eq_of_sum_1 _ _ hw, id_eq]\n\n"}
{"name":"Set.Finite.convexHull_eq","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ns : Set E\nhs : s.Finite\nâŠ¢ Eq ((convexHull R) s) (setOf fun x => Exists fun w => And (âˆ€ (y : E), Membership.mem s y â†’ LE.le 0 (w y)) (And (Eq (hs.toFinset.sum fun y => w y) 1) (Eq (hs.toFinset.centerMass w id) x)))","decl":"theorem Set.Finite.convexHull_eq {s : Set E} (hs : s.Finite) : convexHull R s =\n    { x : E | âˆƒ w : E â†’ R, (âˆ€ y âˆˆ s, 0 â‰¤ w y) âˆ§ âˆ‘ y âˆˆ hs.toFinset, w y = 1 âˆ§\n      hs.toFinset.centerMass w id = x } := by\n  simpa only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, exists_prop] using\n    hs.toFinset.convexHull_eq\n\n"}
{"name":"convexHull_eq_union_convexHull_finite_subsets","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ns : Set E\nâŠ¢ Eq ((convexHull R) s) (Set.iUnion fun t => Set.iUnion fun x => (convexHull R) â†‘t)","decl":"/-- A weak version of CarathÃ©odory's theorem. -/\ntheorem convexHull_eq_union_convexHull_finite_subsets (s : Set E) :\n    convexHull R s = â‹ƒ (t : Finset E) (_ : â†‘t âŠ† s), convexHull R â†‘t := by\n  classical\n  refine Subset.antisymm ?_ ?_\n  Â· rw [_root_.convexHull_eq]\n    rintro x âŸ¨Î¹, t, w, z, hwâ‚€, hwâ‚, hz, rflâŸ©\n    simp only [mem_iUnion]\n    refine âŸ¨t.image z, ?_, ?_âŸ©\n    Â· rw [coe_image, Set.image_subset_iff]\n      exact hz\n    Â· apply t.centerMass_mem_convexHull hwâ‚€\n      Â· simp only [hwâ‚, zero_lt_one]\n      Â· exact fun i hi => Finset.mem_coe.2 (Finset.mem_image_of_mem _ hi)\n  Â· exact iUnion_subset fun i => iUnion_subset convexHull_mono\n\n"}
{"name":"mk_mem_convexHull_prod","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nF : Type u_4\ninstâœâ´ : LinearOrderedField R\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : AddCommGroup F\ninstâœÂ¹ : Module R E\ninstâœ : Module R F\ns : Set E\nt : Set F\nx : E\ny : F\nhx : Membership.mem ((convexHull R) s) x\nhy : Membership.mem ((convexHull R) t) y\nâŠ¢ Membership.mem ((convexHull R) (SProd.sprod s t)) { fst := x, snd := y }","decl":"theorem mk_mem_convexHull_prod {t : Set F} {x : E} {y : F} (hx : x âˆˆ convexHull R s)\n    (hy : y âˆˆ convexHull R t) : (x, y) âˆˆ convexHull R (s Ã—Ë¢ t) := by\n  rw [mem_convexHull_iff_exists_fintype] at hx hy âŠ¢\n  obtain âŸ¨Î¹, _, w, f, hwâ‚€, hwâ‚, hfs, hfâŸ© := hx\n  obtain âŸ¨Îº, _, v, g, hvâ‚€, hvâ‚, hgt, hgâŸ© := hy\n  have h_sum : âˆ‘ i : Î¹ Ã— Îº, w i.1 * v i.2 = 1 := by\n    rw [Fintype.sum_prod_type, â† sum_mul_sum, hwâ‚, hvâ‚, mul_one]\n  refine âŸ¨Î¹ Ã— Îº, inferInstance, fun p => w p.1 * v p.2, fun p â†¦ (f p.1, g p.2),\n    fun p â†¦ mul_nonneg (hwâ‚€ _) (hvâ‚€ _), h_sum, fun p â†¦ âŸ¨hfs _, hgt _âŸ©, ?_âŸ©\n  ext\n  Â· simp_rw [Prod.fst_sum, Prod.smul_mk, Fintype.sum_prod_type, mul_comm (w _), mul_smul,\n      sum_comm (Î³ := Î¹), â† Fintype.sum_smul_sum, hvâ‚, one_smul, hf]\n  Â· simp_rw [Prod.snd_sum, Prod.smul_mk, Fintype.sum_prod_type, mul_smul, â† Fintype.sum_smul_sum,\n      hwâ‚, one_smul, hg]\n\n"}
{"name":"convexHull_prod","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\nF : Type u_4\ninstâœâ´ : LinearOrderedField R\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : AddCommGroup F\ninstâœÂ¹ : Module R E\ninstâœ : Module R F\ns : Set E\nt : Set F\nâŠ¢ Eq ((convexHull R) (SProd.sprod s t)) (SProd.sprod ((convexHull R) s) ((convexHull R) t))","decl":"@[simp]\ntheorem convexHull_prod (s : Set E) (t : Set F) :\n    convexHull R (s Ã—Ë¢ t) = convexHull R s Ã—Ë¢ convexHull R t :=\n  Subset.antisymm\n      (convexHull_min (prod_mono (subset_convexHull _ _) <| subset_convexHull _ _) <|\n        (convex_convexHull _ _).prod <| convex_convexHull _ _) <|\n    prod_subset_iff.2 fun _ hx _ => mk_mem_convexHull_prod hx\n\n"}
{"name":"convexHull_add","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ns t : Set E\nâŠ¢ Eq ((convexHull R) (HAdd.hAdd s t)) (HAdd.hAdd ((convexHull R) s) ((convexHull R) t))","decl":"theorem convexHull_add (s t : Set E) : convexHull R (s + t) = convexHull R s + convexHull R t := by\n  simp_rw [â† add_image_prod, â† IsLinearMap.isLinearMap_add.image_convexHull, convexHull_prod]\n\n"}
{"name":"convexHullAddMonoidHom_apply","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\na : Set E\nâŠ¢ Eq ((convexHullAddMonoidHom R E) a) ((convexHull R) a)","decl":"/-- `convexHull` is an additive monoid morphism under pointwise addition. -/\n@[simps]\ndef convexHullAddMonoidHom : Set E â†’+ Set E where\n  toFun := convexHull R\n  map_add' := convexHull_add\n  map_zero' := convexHull_zero\n\n"}
{"name":"convexHull_sub","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ns t : Set E\nâŠ¢ Eq ((convexHull R) (HSub.hSub s t)) (HSub.hSub ((convexHull R) s) ((convexHull R) t))","decl":"theorem convexHull_sub (s t : Set E) : convexHull R (s - t) = convexHull R s - convexHull R t := by\n  simp_rw [sub_eq_add_neg, convexHull_add, â† convexHull_neg]\n\n"}
{"name":"convexHull_list_sum","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\nl : List (Set E)\nâŠ¢ Eq ((convexHull R) l.sum) (List.map (â‡‘(convexHull R)) l).sum","decl":"theorem convexHull_list_sum (l : List (Set E)) : convexHull R l.sum = (l.map <| convexHull R).sum :=\n  map_list_sum (convexHullAddMonoidHom R E) l\n\n"}
{"name":"convexHull_multiset_sum","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ns : Multiset (Set E)\nâŠ¢ Eq ((convexHull R) s.sum) (Multiset.map (â‡‘(convexHull R)) s).sum","decl":"theorem convexHull_multiset_sum (s : Multiset (Set E)) :\n    convexHull R s.sum = (s.map <| convexHull R).sum :=\n  map_multiset_sum (convexHullAddMonoidHom R E) s\n\n"}
{"name":"convexHull_sum","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\nÎ¹ : Type u_8\ns : Finset Î¹\nt : Î¹ â†’ Set E\nâŠ¢ Eq ((convexHull R) (s.sum fun i => t i)) (s.sum fun i => (convexHull R) (t i))","decl":"theorem convexHull_sum {Î¹} (s : Finset Î¹) (t : Î¹ â†’ Set E) :\n    convexHull R (âˆ‘ i âˆˆ s, t i) = âˆ‘ i âˆˆ s, convexHull R (t i) :=\n  map_sum (convexHullAddMonoidHom R E) _ _\n\n"}
{"name":"convexHull_basis_eq_stdSimplex","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nÎ¹ : Type u_5\ninstâœÂ¹ : LinearOrderedField R\ninstâœ : Fintype Î¹\nâŠ¢ Eq ((convexHull R) (Set.range fun i j => ite (Eq i j) 1 0)) (stdSimplex R Î¹)","decl":"open scoped Classical in\n/-- `stdSimplex ğ•œ Î¹` is the convex hull of the canonical basis in `Î¹ â†’ ğ•œ`. -/\ntheorem convexHull_basis_eq_stdSimplex :\n    convexHull R (range fun i j : Î¹ => if i = j then (1 : R) else 0) = stdSimplex R Î¹ := by\n  refine Subset.antisymm (convexHull_min ?_ (convex_stdSimplex R Î¹)) ?_\n  Â· rintro _ âŸ¨i, rflâŸ©\n    exact ite_eq_mem_stdSimplex R i\n  Â· rintro w âŸ¨hwâ‚€, hwâ‚âŸ©\n    rw [pi_eq_sum_univ w, â† Finset.univ.centerMass_eq_of_sum_1 _ hwâ‚]\n    exact Finset.univ.centerMass_mem_convexHull (fun i _ => hwâ‚€ i) (hwâ‚.symm â–¸ zero_lt_one)\n      fun i _ => mem_range_self i\n\n"}
{"name":"Set.Finite.convexHull_eq_image","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ns : Set E\nhs : s.Finite\nâŠ¢ Eq ((convexHull R) s) (Set.image (â‡‘(Finset.univ.sum fun x => (LinearMap.proj x).smulRight â†‘x)) (stdSimplex R â†‘s))","decl":"/-- The convex hull of a finite set is the image of the standard simplex in `s â†’ â„`\nunder the linear map sending each function `w` to `âˆ‘ x âˆˆ s, w x â€¢ x`.\n\nSince we have no sums over finite sets, we use sum over `@Finset.univ _ hs.fintype`.\nThe map is defined in terms of operations on `(s â†’ â„) â†’â‚—[â„] â„` so that later we will not need\nto prove that this map is linear. -/\ntheorem Set.Finite.convexHull_eq_image {s : Set E} (hs : s.Finite) : convexHull R s =\n    haveI := hs.fintype\n    (â‡‘(âˆ‘ x : s, (@LinearMap.proj R s _ (fun _ => R) _ _ x).smulRight x.1)) '' stdSimplex R s := by\n  classical\n  letI := hs.fintype\n  rw [â† convexHull_basis_eq_stdSimplex, LinearMap.image_convexHull, â† Set.range_comp]\n  apply congr_arg\n  simp_rw [Function.comp_def]\n  convert Subtype.range_coe.symm\n  simp [LinearMap.sum_apply, ite_smul, Finset.filter_eq, Finset.mem_univ]\n\n"}
{"name":"mem_Icc_of_mem_stdSimplex","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nÎ¹ : Type u_5\ninstâœÂ¹ : LinearOrderedField R\ninstâœ : Fintype Î¹\nf : Î¹ â†’ R\nhf : Membership.mem (stdSimplex R Î¹) f\nx : Î¹\nâŠ¢ Membership.mem (Set.Icc 0 1) (f x)","decl":"/-- All values of a function `f âˆˆ stdSimplex ğ•œ Î¹` belong to `[0, 1]`. -/\ntheorem mem_Icc_of_mem_stdSimplex (hf : f âˆˆ stdSimplex R Î¹) (x) : f x âˆˆ Icc (0 : R) 1 :=\n  âŸ¨hf.1 x, hf.2 â–¸ Finset.single_le_sum (fun y _ => hf.1 y) (Finset.mem_univ x)âŸ©\n\n"}
{"name":"AffineBasis.convexHull_eq_nonneg_coord","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\nÎ¹ : Type u_8\nb : AffineBasis Î¹ R E\nâŠ¢ Eq ((convexHull R) (Set.range â‡‘b)) (setOf fun x => âˆ€ (i : Î¹), LE.le 0 ((b.coord i) x))","decl":"/-- The convex hull of an affine basis is the intersection of the half-spaces defined by the\ncorresponding barycentric coordinates. -/\ntheorem AffineBasis.convexHull_eq_nonneg_coord {Î¹ : Type*} (b : AffineBasis Î¹ R E) :\n    convexHull R (range b) = { x | âˆ€ i, 0 â‰¤ b.coord i x } := by\n  rw [convexHull_range_eq_exists_affineCombination]\n  ext x\n  refine âŸ¨?_, fun hx => ?_âŸ©\n  Â· rintro âŸ¨s, w, hwâ‚€, hwâ‚, rflâŸ© i\n    by_cases hi : i âˆˆ s\n    Â· rw [b.coord_apply_combination_of_mem hi hwâ‚]\n      exact hwâ‚€ i hi\n    Â· rw [b.coord_apply_combination_of_not_mem hi hwâ‚]\n  Â· have hx' : x âˆˆ affineSpan R (range b) := by\n      rw [b.tot]\n      exact AffineSubspace.mem_top R E x\n    obtain âŸ¨s, w, hwâ‚, rflâŸ© := (mem_affineSpan_iff_eq_affineCombination R E).mp hx'\n    refine âŸ¨s, w, ?_, hwâ‚, rflâŸ©\n    intro i hi\n    specialize hx i\n    rw [b.coord_apply_combination_of_mem hi hwâ‚] at hx\n    exact hx\n\n"}
{"name":"AffineIndependent.convexHull_inter","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ns tâ‚ tâ‚‚ : Finset E\nhs : AffineIndependent R Subtype.val\nhtâ‚ : HasSubset.Subset tâ‚ s\nhtâ‚‚ : HasSubset.Subset tâ‚‚ s\nâŠ¢ Eq ((convexHull R) (Inter.inter â†‘tâ‚ â†‘tâ‚‚)) (Inter.inter ((convexHull R) â†‘tâ‚) ((convexHull R) â†‘tâ‚‚))","decl":"/-- Two simplices glue nicely if the union of their vertices is affine independent. -/\nlemma AffineIndependent.convexHull_inter (hs : AffineIndependent R ((â†‘) : s â†’ E))\n    (htâ‚ : tâ‚ âŠ† s) (htâ‚‚ : tâ‚‚ âŠ† s) :\n    convexHull R (tâ‚ âˆ© tâ‚‚ : Set E) = convexHull R tâ‚ âˆ© convexHull R tâ‚‚ := by\n  classical\n  refine (Set.subset_inter (convexHull_mono inf_le_left) <|\n    convexHull_mono inf_le_right).antisymm ?_\n  simp_rw [Set.subset_def, mem_inter_iff, Set.inf_eq_inter, â† coe_inter, mem_convexHull']\n  rintro x âŸ¨âŸ¨wâ‚, hâ‚wâ‚, hâ‚‚wâ‚, hâ‚ƒwâ‚âŸ©, wâ‚‚, -, hâ‚‚wâ‚‚, hâ‚ƒwâ‚‚âŸ©\n  let w (x : E) : R := (if x âˆˆ tâ‚ then wâ‚ x else 0) - if x âˆˆ tâ‚‚ then wâ‚‚ x else 0\n  have hâ‚w : âˆ‘ i âˆˆ s, w i = 0 := by simp [w, Finset.inter_eq_right.2, *]\n  replace hs := hs.eq_zero_of_sum_eq_zero_subtype hâ‚w <| by\n    simp only [w, sub_smul, zero_smul, ite_smul, Finset.sum_sub_distrib, â† Finset.sum_filter, hâ‚ƒwâ‚,\n      Finset.filter_mem_eq_inter, Finset.inter_eq_right.2 htâ‚, Finset.inter_eq_right.2 htâ‚‚, hâ‚ƒwâ‚‚,\n      sub_self]\n  have ht (x) (hxâ‚ : x âˆˆ tâ‚) (hxâ‚‚ : x âˆ‰ tâ‚‚) : wâ‚ x = 0 := by\n    simpa [w, hxâ‚, hxâ‚‚] using hs _ (htâ‚ hxâ‚)\n  refine âŸ¨wâ‚, ?_, ?_, ?_âŸ©\n  Â· simp only [and_imp, Finset.mem_inter]\n    exact fun y hyâ‚ _ â†¦ hâ‚wâ‚ y hyâ‚\n  all_goals\n  Â· rwa [sum_subset inter_subset_left]\n    rintro x\n    simp_intro hxâ‚ hxâ‚‚\n    simp [ht x hxâ‚ hxâ‚‚]\n\n"}
{"name":"AffineIndependent.convexHull_inter'","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"R : Type u_1\nE : Type u_3\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module R E\ntâ‚ tâ‚‚ : Finset E\nhs : AffineIndependent R Subtype.val\nâŠ¢ Eq ((convexHull R) (Inter.inter â†‘tâ‚ â†‘tâ‚‚)) (Inter.inter ((convexHull R) â†‘tâ‚) ((convexHull R) â†‘tâ‚‚))","decl":"open scoped Classical in\n/-- Two simplices glue nicely if the union of their vertices is affine independent.\n\nNote that `AffineIndependent.convexHull_inter` should be more versatile in most use cases. -/\nlemma AffineIndependent.convexHull_inter' (hs : AffineIndependent R ((â†‘) : â†‘(tâ‚ âˆª tâ‚‚) â†’ E)) :\n    convexHull R (tâ‚ âˆ© tâ‚‚ : Set E) = convexHull R tâ‚ âˆ© convexHull R tâ‚‚ :=\n  hs.convexHull_inter subset_union_left subset_union_right\n\n"}
{"name":"mem_convexHull_pi","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\ninstâœÂ³ : Finite Î¹\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœ : (i : Î¹) â†’ Module ğ•œ (E i)\ns : Set Î¹\nt : (i : Î¹) â†’ Set (E i)\nx : (i : Î¹) â†’ E i\nh : âˆ€ (i : Î¹), Membership.mem s i â†’ Membership.mem ((convexHull ğ•œ) (t i)) (x i)\nâŠ¢ Membership.mem ((convexHull ğ•œ) (s.pi t)) x","decl":"lemma mem_convexHull_pi (h : âˆ€ i âˆˆ s, x i âˆˆ convexHull ğ•œ (t i)) : x âˆˆ convexHull ğ•œ (s.pi t) := by\n  classical\n  cases nonempty_fintype Î¹\n  wlog hs : s = Set.univ generalizing s t\n  Â· rw [â† pi_univ_ite]\n    refine this (fun i _ â†¦ ?_) rfl\n    split_ifs with hi\n    Â· exact h i hi\n    Â· simp\n  subst hs\n  simp only [Set.mem_univ, mem_convexHull_iff_exists_fintype, true_implies, Set.mem_pi] at h\n  choose Îº _ w f hwâ‚€ hwâ‚ hft hf using h\n  refine mem_convexHull_of_exists_fintype (fun k : Î  i, Îº i â†¦ âˆ i, w i (k i)) (fun g i â†¦ f _ (g i))\n    (fun g â†¦ prod_nonneg fun _ _ â†¦ hwâ‚€ _ _) ?_ (fun _ _ _ â†¦ hft _ _) ?_\n  Â· rw [â† Fintype.prod_sum]\n    exact prod_eq_one fun _ _ â†¦ hwâ‚ _\n  ext i\n  calc\n    _ = âˆ‘ g : âˆ€ i, Îº i, (âˆ i, w i (g i)) â€¢ f i (g i) := by\n      simp only [Finset.sum_apply, Pi.smul_apply]\n    _ = âˆ‘ j : Îº i, âˆ‘ g : {g : âˆ€ k, Îº k // g i = j},\n          (âˆ k, w k (g.1 k)) â€¢ f i ((g : âˆ€ i, Îº i) i) := by\n      rw [â† Fintype.sum_fiberwise fun g : âˆ€ k, Îº k â†¦ g i]\n    _ = âˆ‘ j : Îº i, (âˆ‘ g : {g : âˆ€ k, Îº k // g i = j}, âˆ k, w k (g.1 k)) â€¢ f i j := by\n      simp_rw [sum_smul]\n      congr! with j _ g _\n      exact g.2\n    _ = âˆ‘ j : Îº i, w i j â€¢ f i j := ?_\n    _ = x i := hf _\n  congr! with j _\n  calc\n    âˆ‘ g : {g : âˆ€ k, Îº k // g i = j}, âˆ k, w k (g.1 k)\n      = âˆ‘ g âˆˆ piFinset fun k â†¦ if hk : k = i then hk â–¸ {j} else univ, âˆ k, w k (g k) :=\n      Finset.sum_bij' (fun g _ â†¦ g) (fun g hg â†¦ âŸ¨g, by simpa using mem_piFinset.1 hg iâŸ©)\n        (by aesop) (by simp) (by simp) (by simp) (by simp)\n    _ = w i j := by\n      rw [â† prod_univ_sum, â† prod_mul_prod_compl, Finset.prod_singleton, Finset.sum_eq_single,\n        Finset.prod_eq_one, mul_one] <;> simp +contextual [hwâ‚]\n\n"}
{"name":"convexHull_pi","module":"Mathlib.Analysis.Convex.Combination","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\ninstâœÂ³ : Finite Î¹\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœ : (i : Î¹) â†’ Module ğ•œ (E i)\ns : Set Î¹\nt : (i : Î¹) â†’ Set (E i)\nâŠ¢ Eq ((convexHull ğ•œ) (s.pi t)) (s.pi fun i => (convexHull ğ•œ) (t i))","decl":"@[simp] lemma convexHull_pi (s : Set Î¹) (t : Î  i, Set (E i)) :\n    convexHull ğ•œ (s.pi t) = s.pi (fun i â†¦ convexHull ğ•œ (t i)) :=\n  Set.Subset.antisymm (convexHull_min (Set.pi_mono fun _ _ â†¦ subset_convexHull _ _) <| convex_pi <|\n    fun _ _ â†¦ convex_convexHull _ _) fun _ â†¦ mem_convexHull_pi\n\n"}
