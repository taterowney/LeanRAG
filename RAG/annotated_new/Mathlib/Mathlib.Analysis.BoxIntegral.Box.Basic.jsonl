{"name":"BoxIntegral.Box.lower_lt_upper","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_2\nself : BoxIntegral.Box ι\ni : ι\n⊢ LT.lt (self.lower i) (self.upper i)","decl":"/-- A nontrivial rectangular box in `ι → ℝ` with corners `lower` and `upper`. Represents the product\nof half-open intervals `(lower i, upper i]`. -/\nstructure Box (ι : Type*) where\n  /-- coordinates of the lower and upper corners of the box -/\n  (lower upper : ι → ℝ)\n  /-- Each lower coordinate is less than its upper coordinate: i.e., the box is non-empty -/\n  lower_lt_upper : ∀ i, lower i < upper i\n\n"}
{"name":"BoxIntegral.Box.mk.sizeOf_spec","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_2\ninst✝ : SizeOf ι\nlower upper : ι → Real\nlower_lt_upper : ∀ (i : ι), LT.lt (lower i) (upper i)\n⊢ Eq (SizeOf.sizeOf { lower := lower, upper := upper, lower_lt_upper := lower_lt_upper }) 1","decl":"/-- A nontrivial rectangular box in `ι → ℝ` with corners `lower` and `upper`. Represents the product\nof half-open intervals `(lower i, upper i]`. -/\nstructure Box (ι : Type*) where\n  /-- coordinates of the lower and upper corners of the box -/\n  (lower upper : ι → ℝ)\n  /-- Each lower coordinate is less than its upper coordinate: i.e., the box is non-empty -/\n  lower_lt_upper : ∀ i, lower i < upper i\n\n"}
{"name":"BoxIntegral.Box.mk.injEq","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_2\nlower✝ upper✝ : ι → Real\nlower_lt_upper✝ : ∀ (i : ι), LT.lt (lower✝ i) (upper✝ i)\nlower upper : ι → Real\nlower_lt_upper : ∀ (i : ι), LT.lt (lower i) (upper i)\n⊢ Eq (Eq { lower := lower✝, upper := upper✝, lower_lt_upper := lower_lt_upper✝ } { lower := lower, upper := upper, lower_lt_upper := lower_lt_upper }) (And (Eq lower✝ lower) (Eq upper✝ upper))","decl":"/-- A nontrivial rectangular box in `ι → ℝ` with corners `lower` and `upper`. Represents the product\nof half-open intervals `(lower i, upper i]`. -/\nstructure Box (ι : Type*) where\n  /-- coordinates of the lower and upper corners of the box -/\n  (lower upper : ι → ℝ)\n  /-- Each lower coordinate is less than its upper coordinate: i.e., the box is non-empty -/\n  lower_lt_upper : ∀ i, lower i < upper i\n\n"}
{"name":"BoxIntegral.Box.mk.inj","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_2\nlower✝ upper✝ : ι → Real\nlower_lt_upper✝ : ∀ (i : ι), LT.lt (lower✝ i) (upper✝ i)\nlower upper : ι → Real\nlower_lt_upper : ∀ (i : ι), LT.lt (lower i) (upper i)\nx✝ : Eq { lower := lower✝, upper := upper✝, lower_lt_upper := lower_lt_upper✝ } { lower := lower, upper := upper, lower_lt_upper := lower_lt_upper }\n⊢ And (Eq lower✝ lower) (Eq upper✝ upper)","decl":"/-- A nontrivial rectangular box in `ι → ℝ` with corners `lower` and `upper`. Represents the product\nof half-open intervals `(lower i, upper i]`. -/\nstructure Box (ι : Type*) where\n  /-- coordinates of the lower and upper corners of the box -/\n  (lower upper : ι → ℝ)\n  /-- Each lower coordinate is less than its upper coordinate: i.e., the box is non-empty -/\n  lower_lt_upper : ∀ i, lower i < upper i\n\n"}
{"name":"BoxIntegral.Box.lower_le_upper","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\n⊢ LE.le I.lower I.upper","decl":"theorem lower_le_upper : I.lower ≤ I.upper :=\n  fun i ↦ (I.lower_lt_upper i).le\n\n"}
{"name":"BoxIntegral.Box.lower_ne_upper","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ni : ι\n⊢ Ne (I.lower i) (I.upper i)","decl":"theorem lower_ne_upper (i) : I.lower i ≠ I.upper i :=\n  (I.lower_lt_upper i).ne\n\n"}
{"name":"BoxIntegral.Box.mem_mk","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nl u x : ι → Real\nH : ∀ (i : ι), LT.lt (l i) (u i)\n⊢ Iff (Membership.mem { lower := l, upper := u, lower_lt_upper := H } x) (∀ (i : ι), Membership.mem (Set.Ioc (l i) (u i)) (x i))","decl":"@[simp]\ntheorem mem_mk {l u x : ι → ℝ} {H} : x ∈ mk l u H ↔ ∀ i, x i ∈ Ioc (l i) (u i) := Iff.rfl\n\n"}
{"name":"BoxIntegral.Box.mem_coe","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nx : ι → Real\n⊢ Iff (Membership.mem (↑I) x) (Membership.mem I x)","decl":"@[simp, norm_cast]\ntheorem mem_coe : x ∈ (I : Set (ι → ℝ)) ↔ x ∈ I := Iff.rfl\n\n"}
{"name":"BoxIntegral.Box.mem_def","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nx : ι → Real\n⊢ Iff (Membership.mem I x) (∀ (i : ι), Membership.mem (Set.Ioc (I.lower i) (I.upper i)) (x i))","decl":"theorem mem_def : x ∈ I ↔ ∀ i, x i ∈ Ioc (I.lower i) (I.upper i) := Iff.rfl\n\n"}
{"name":"BoxIntegral.Box.mem_univ_Ioc","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nx : ι → Real\nI : BoxIntegral.Box ι\n⊢ Iff (Membership.mem (Set.univ.pi fun i => Set.Ioc (I.lower i) (I.upper i)) x) (Membership.mem I x)","decl":"theorem mem_univ_Ioc {I : Box ι} : (x ∈ pi univ fun i ↦ Ioc (I.lower i) (I.upper i)) ↔ x ∈ I :=\n  mem_univ_pi\n\n"}
{"name":"BoxIntegral.Box.coe_eq_pi","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\n⊢ Eq (↑I) (Set.univ.pi fun i => Set.Ioc (I.lower i) (I.upper i))","decl":"theorem coe_eq_pi : (I : Set (ι → ℝ)) = pi univ fun i ↦ Ioc (I.lower i) (I.upper i) :=\n  Set.ext fun _ ↦ mem_univ_Ioc.symm\n\n"}
{"name":"BoxIntegral.Box.upper_mem","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\n⊢ Membership.mem I I.upper","decl":"@[simp]\ntheorem upper_mem : I.upper ∈ I :=\n  fun i ↦ right_mem_Ioc.2 <| I.lower_lt_upper i\n\n"}
{"name":"BoxIntegral.Box.exists_mem","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\n⊢ Exists fun x => Membership.mem I x","decl":"theorem exists_mem : ∃ x, x ∈ I :=\n  ⟨_, I.upper_mem⟩\n\n"}
{"name":"BoxIntegral.Box.nonempty_coe","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\n⊢ (↑I).Nonempty","decl":"theorem nonempty_coe : Set.Nonempty (I : Set (ι → ℝ)) :=\n  I.exists_mem\n\n"}
{"name":"BoxIntegral.Box.coe_ne_empty","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\n⊢ Ne (↑I) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem coe_ne_empty : (I : Set (ι → ℝ)) ≠ ∅ :=\n  I.nonempty_coe.ne_empty\n\n"}
{"name":"BoxIntegral.Box.empty_ne_coe","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\n⊢ Ne EmptyCollection.emptyCollection ↑I","decl":"@[simp]\ntheorem empty_ne_coe : ∅ ≠ (I : Set (ι → ℝ)) :=\n  I.coe_ne_empty.symm\n\n"}
{"name":"BoxIntegral.Box.le_def","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\n⊢ Iff (LE.le I J) (∀ (x : ι → Real), Membership.mem I x → Membership.mem J x)","decl":"theorem le_def : I ≤ J ↔ ∀ x ∈ I, x ∈ J := Iff.rfl\n\n"}
{"name":"BoxIntegral.Box.le_TFAE","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\n⊢ (List.cons (LE.le I J) (List.cons (HasSubset.Subset ↑I ↑J) (List.cons (HasSubset.Subset (Set.Icc I.lower I.upper) (Set.Icc J.lower J.upper)) (List.cons (And (LE.le J.lower I.lower) (LE.le I.upper J.upper)) List.nil)))).TFAE","decl":"theorem le_TFAE : List.TFAE [I ≤ J, (I : Set (ι → ℝ)) ⊆ J,\n    Icc I.lower I.upper ⊆ Icc J.lower J.upper, J.lower ≤ I.lower ∧ I.upper ≤ J.upper] := by\n  tfae_have 1 ↔ 2 := Iff.rfl\n  tfae_have 2 → 3\n  | h => by simpa [coe_eq_pi, closure_pi_set, lower_ne_upper] using closure_mono h\n  tfae_have 3 ↔ 4 := Icc_subset_Icc_iff I.lower_le_upper\n  tfae_have 4 → 2\n  | h, x, hx, i => Ioc_subset_Ioc (h.1 i) (h.2 i) (hx i)\n  tfae_finish\n\n"}
{"name":"BoxIntegral.Box.coe_subset_coe","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\n⊢ Iff (HasSubset.Subset ↑I ↑J) (LE.le I J)","decl":"@[simp, norm_cast]\ntheorem coe_subset_coe : (I : Set (ι → ℝ)) ⊆ J ↔ I ≤ J := Iff.rfl\n\n"}
{"name":"BoxIntegral.Box.le_iff_bounds","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\n⊢ Iff (LE.le I J) (And (LE.le J.lower I.lower) (LE.le I.upper J.upper))","decl":"theorem le_iff_bounds : I ≤ J ↔ J.lower ≤ I.lower ∧ I.upper ≤ J.upper :=\n  (le_TFAE I J).out 0 3\n\n"}
{"name":"BoxIntegral.Box.injective_coe","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\n⊢ Function.Injective BoxIntegral.Box.toSet","decl":"theorem injective_coe : Injective ((↑) : Box ι → Set (ι → ℝ)) := by\n  rintro ⟨l₁, u₁, h₁⟩ ⟨l₂, u₂, h₂⟩ h\n  simp only [Subset.antisymm_iff, coe_subset_coe, le_iff_bounds] at h\n  congr\n  exacts [le_antisymm h.2.1 h.1.1, le_antisymm h.1.2 h.2.2]\n\n"}
{"name":"BoxIntegral.Box.coe_inj","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\n⊢ Iff (Eq ↑I ↑J) (Eq I J)","decl":"@[simp, norm_cast]\ntheorem coe_inj : (I : Set (ι → ℝ)) = J ↔ I = J :=\n  injective_coe.eq_iff\n\n"}
{"name":"BoxIntegral.Box.ext","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nH : ∀ (x : ι → Real), Iff (Membership.mem I x) (Membership.mem J x)\n⊢ Eq I J","decl":"@[ext]\ntheorem ext (H : ∀ x, x ∈ I ↔ x ∈ J) : I = J :=\n  injective_coe <| Set.ext H\n\n"}
{"name":"BoxIntegral.Box.ext_iff","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\n⊢ Iff (Eq I J) (∀ (x : ι → Real), Iff (Membership.mem I x) (Membership.mem J x))","decl":"@[ext]\ntheorem ext (H : ∀ x, x ∈ I ↔ x ∈ J) : I = J :=\n  injective_coe <| Set.ext H\n\n"}
{"name":"BoxIntegral.Box.ne_of_disjoint_coe","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nh : Disjoint ↑I ↑J\n⊢ Ne I J","decl":"theorem ne_of_disjoint_coe (h : Disjoint (I : Set (ι → ℝ)) J) : I ≠ J :=\n  mt coe_inj.2 <| h.ne I.coe_ne_empty\n\n"}
{"name":"BoxIntegral.Box.Icc_def","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\n⊢ Eq (BoxIntegral.Box.Icc I) (Set.Icc I.lower I.upper)","decl":"theorem Icc_def : Box.Icc I = Icc I.lower I.upper := rfl\n\n"}
{"name":"BoxIntegral.Box.upper_mem_Icc","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\n⊢ Membership.mem (BoxIntegral.Box.Icc I) I.upper","decl":"@[simp]\ntheorem upper_mem_Icc (I : Box ι) : I.upper ∈ Box.Icc I :=\n  right_mem_Icc.2 I.lower_le_upper\n\n"}
{"name":"BoxIntegral.Box.lower_mem_Icc","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\n⊢ Membership.mem (BoxIntegral.Box.Icc I) I.lower","decl":"@[simp]\ntheorem lower_mem_Icc (I : Box ι) : I.lower ∈ Box.Icc I :=\n  left_mem_Icc.2 I.lower_le_upper\n\n"}
{"name":"BoxIntegral.Box.isCompact_Icc","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\n⊢ IsCompact (BoxIntegral.Box.Icc I)","decl":"protected theorem isCompact_Icc (I : Box ι) : IsCompact (Box.Icc I) :=\n  isCompact_Icc\n\n"}
{"name":"BoxIntegral.Box.Icc_eq_pi","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\n⊢ Eq (BoxIntegral.Box.Icc I) (Set.univ.pi fun i => Set.Icc (I.lower i) (I.upper i))","decl":"theorem Icc_eq_pi : Box.Icc I = pi univ fun i ↦ Icc (I.lower i) (I.upper i) :=\n  (pi_univ_Icc _ _).symm\n\n"}
{"name":"BoxIntegral.Box.le_iff_Icc","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\n⊢ Iff (LE.le I J) (HasSubset.Subset (BoxIntegral.Box.Icc I) (BoxIntegral.Box.Icc J))","decl":"theorem le_iff_Icc : I ≤ J ↔ Box.Icc I ⊆ Box.Icc J :=\n  (le_TFAE I J).out 0 2\n\n"}
{"name":"BoxIntegral.Box.antitone_lower","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\n⊢ Antitone fun I => I.lower","decl":"theorem antitone_lower : Antitone fun I : Box ι ↦ I.lower :=\n  fun _ _ H ↦ (le_iff_bounds.1 H).1\n\n"}
{"name":"BoxIntegral.Box.monotone_upper","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\n⊢ Monotone fun I => I.upper","decl":"theorem monotone_upper : Monotone fun I : Box ι ↦ I.upper :=\n  fun _ _ H ↦ (le_iff_bounds.1 H).2\n\n"}
{"name":"BoxIntegral.Box.coe_subset_Icc","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\n⊢ HasSubset.Subset (↑I) (BoxIntegral.Box.Icc I)","decl":"theorem coe_subset_Icc : ↑I ⊆ Box.Icc I :=\n  fun _ hx ↦ ⟨fun i ↦ (hx i).1.le, fun i ↦ (hx i).2⟩\n\n"}
{"name":"BoxIntegral.Box.isBounded_Icc","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\ninst✝ : Finite ι\nI : BoxIntegral.Box ι\n⊢ Bornology.IsBounded (BoxIntegral.Box.Icc I)","decl":"theorem isBounded_Icc [Finite ι] (I : Box ι) : Bornology.IsBounded (Box.Icc I) := by\n  cases nonempty_fintype ι\n  exact Metric.isBounded_Icc _ _\n\n"}
{"name":"BoxIntegral.Box.isBounded","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\ninst✝ : Finite ι\nI : BoxIntegral.Box ι\n⊢ Bornology.IsBounded ↑I","decl":"theorem isBounded [Finite ι] (I : Box ι) : Bornology.IsBounded I.toSet :=\n  Bornology.IsBounded.subset I.isBounded_Icc coe_subset_Icc\n\n"}
{"name":"BoxIntegral.Box.coe_bot","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\n⊢ Eq (↑Bot.bot) EmptyCollection.emptyCollection","decl":"@[simp, norm_cast]\ntheorem coe_bot : ((⊥ : WithBot (Box ι)) : Set (ι → ℝ)) = ∅ := rfl\n\n"}
{"name":"BoxIntegral.Box.coe_coe","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\n⊢ Eq ↑↑I ↑I","decl":"@[simp, norm_cast]\ntheorem coe_coe : ((I : WithBot (Box ι)) : Set (ι → ℝ)) = I := rfl\n\n"}
{"name":"BoxIntegral.Box.isSome_iff","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI : WithBot (BoxIntegral.Box ι)\n⊢ Iff (Eq (Option.isSome I) Bool.true) (↑I).Nonempty","decl":"theorem isSome_iff : ∀ {I : WithBot (Box ι)}, I.isSome ↔ (I : Set (ι → ℝ)).Nonempty\n  | ⊥ => by\n    erw [Option.isSome]\n    simp\n  | (I : Box ι) => by\n    erw [Option.isSome]\n    simp [I.nonempty_coe]\n\n"}
{"name":"BoxIntegral.Box.biUnion_coe_eq_coe","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI : WithBot (BoxIntegral.Box ι)\n⊢ Eq (Set.iUnion fun J => Set.iUnion fun x => ↑J) ↑I","decl":"theorem biUnion_coe_eq_coe (I : WithBot (Box ι)) :\n    ⋃ (J : Box ι) (_ : ↑J = I), (J : Set (ι → ℝ)) = I := by\n  induction I <;> simp [WithBot.coe_eq_coe]\n\n"}
{"name":"BoxIntegral.Box.withBotCoe_subset_iff","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI J : WithBot (BoxIntegral.Box ι)\n⊢ Iff (HasSubset.Subset ↑I ↑J) (LE.le I J)","decl":"@[simp, norm_cast]\ntheorem withBotCoe_subset_iff {I J : WithBot (Box ι)} : (I : Set (ι → ℝ)) ⊆ J ↔ I ≤ J := by\n  induction I; · simp\n  induction J; · simp [subset_empty_iff]\n  simp [le_def]\n\n"}
{"name":"BoxIntegral.Box.withBotCoe_inj","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI J : WithBot (BoxIntegral.Box ι)\n⊢ Iff (Eq ↑I ↑J) (Eq I J)","decl":"@[simp, norm_cast]\ntheorem withBotCoe_inj {I J : WithBot (Box ι)} : (I : Set (ι → ℝ)) = J ↔ I = J := by\n  simp only [Subset.antisymm_iff, ← le_antisymm_iff, withBotCoe_subset_iff]\n\n"}
{"name":"BoxIntegral.Box.mk'_eq_bot","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nl u : ι → Real\n⊢ Iff (Eq (BoxIntegral.Box.mk' l u) Bot.bot) (Exists fun i => LE.le (u i) (l i))","decl":"@[simp]\ntheorem mk'_eq_bot {l u : ι → ℝ} : mk' l u = ⊥ ↔ ∃ i, u i ≤ l i := by\n  rw [mk']\n  split_ifs with h <;> simpa using h\n\n"}
{"name":"BoxIntegral.Box.mk'_eq_coe","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nl u : ι → Real\n⊢ Iff (Eq (BoxIntegral.Box.mk' l u) ↑I) (And (Eq l I.lower) (Eq u I.upper))","decl":"@[simp]\ntheorem mk'_eq_coe {l u : ι → ℝ} : mk' l u = I ↔ l = I.lower ∧ u = I.upper := by\n  cases' I with lI uI hI; rw [mk']; split_ifs with h\n  · simp [WithBot.coe_eq_coe]\n  · suffices l = lI → u ≠ uI by simpa\n    rintro rfl rfl\n    exact h hI\n\n"}
{"name":"BoxIntegral.Box.coe_mk'","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nl u : ι → Real\n⊢ Eq (↑(BoxIntegral.Box.mk' l u)) (Set.univ.pi fun i => Set.Ioc (l i) (u i))","decl":"@[simp]\ntheorem coe_mk' (l u : ι → ℝ) : (mk' l u : Set (ι → ℝ)) = pi univ fun i ↦ Ioc (l i) (u i) := by\n  rw [mk']; split_ifs with h\n  · exact coe_eq_pi _\n  · rcases not_forall.mp h with ⟨i, hi⟩\n    rw [coe_bot, univ_pi_eq_empty]\n    exact Ioc_eq_empty hi\n\n"}
{"name":"BoxIntegral.Box.coe_inf","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI J : WithBot (BoxIntegral.Box ι)\n⊢ Eq (↑(Min.min I J)) (Inter.inter ↑I ↑J)","decl":"@[simp]\ntheorem coe_inf (I J : WithBot (Box ι)) : (↑(I ⊓ J) : Set (ι → ℝ)) = (I : Set _) ∩ J := by\n  induction I\n  · change ∅ = _\n    simp\n  induction J\n  · change ∅ = _\n    simp\n  change ((mk' _ _ : WithBot (Box ι)) : Set (ι → ℝ)) = _\n  simp only [coe_eq_pi, ← pi_inter_distrib, Ioc_inter_Ioc, Pi.sup_apply, Pi.inf_apply, coe_mk',\n    coe_coe]\n\n"}
{"name":"BoxIntegral.Box.disjoint_withBotCoe","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI J : WithBot (BoxIntegral.Box ι)\n⊢ Iff (Disjoint ↑I ↑J) (Disjoint I J)","decl":"@[simp, norm_cast]\ntheorem disjoint_withBotCoe {I J : WithBot (Box ι)} :\n    Disjoint (I : Set (ι → ℝ)) J ↔ Disjoint I J := by\n  simp only [disjoint_iff_inf_le, ← withBotCoe_subset_iff, coe_inf]\n  rfl\n\n"}
{"name":"BoxIntegral.Box.disjoint_coe","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\n⊢ Iff (Disjoint ↑I ↑J) (Disjoint ↑I ↑J)","decl":"theorem disjoint_coe : Disjoint (I : WithBot (Box ι)) J ↔ Disjoint (I : Set (ι → ℝ)) J :=\n  disjoint_withBotCoe.symm\n\n"}
{"name":"BoxIntegral.Box.not_disjoint_coe_iff_nonempty_inter","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\n⊢ Iff (Not (Disjoint ↑I ↑J)) (Inter.inter ↑I ↑J).Nonempty","decl":"theorem not_disjoint_coe_iff_nonempty_inter :\n    ¬Disjoint (I : WithBot (Box ι)) J ↔ (I ∩ J : Set (ι → ℝ)).Nonempty := by\n  rw [disjoint_coe, Set.not_disjoint_iff_nonempty_inter]\n\n"}
{"name":"BoxIntegral.Box.face_lower","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"n : Nat\nI : BoxIntegral.Box (Fin (HAdd.hAdd n 1))\ni : Fin (HAdd.hAdd n 1)\na✝ : Fin n\n⊢ Eq ((I.face i).lower a✝) (I.lower (i.succAbove a✝))","decl":"/-- Face of a box in `ℝⁿ⁺¹ = Fin (n + 1) → ℝ`: the box in `ℝⁿ = Fin n → ℝ` with corners at\n`I.lower ∘ Fin.succAbove i` and `I.upper ∘ Fin.succAbove i`. -/\n@[simps (config := { simpRhs := true })]\ndef face {n} (I : Box (Fin (n + 1))) (i : Fin (n + 1)) : Box (Fin n) :=\n  ⟨I.lower ∘ Fin.succAbove i, I.upper ∘ Fin.succAbove i, fun _ ↦ I.lower_lt_upper _⟩\n\n"}
{"name":"BoxIntegral.Box.face_upper","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"n : Nat\nI : BoxIntegral.Box (Fin (HAdd.hAdd n 1))\ni : Fin (HAdd.hAdd n 1)\na✝ : Fin n\n⊢ Eq ((I.face i).upper a✝) (I.upper (i.succAbove a✝))","decl":"/-- Face of a box in `ℝⁿ⁺¹ = Fin (n + 1) → ℝ`: the box in `ℝⁿ = Fin n → ℝ` with corners at\n`I.lower ∘ Fin.succAbove i` and `I.upper ∘ Fin.succAbove i`. -/\n@[simps (config := { simpRhs := true })]\ndef face {n} (I : Box (Fin (n + 1))) (i : Fin (n + 1)) : Box (Fin n) :=\n  ⟨I.lower ∘ Fin.succAbove i, I.upper ∘ Fin.succAbove i, fun _ ↦ I.lower_lt_upper _⟩\n\n"}
{"name":"BoxIntegral.Box.face_mk","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"n : Nat\nl u : Fin (HAdd.hAdd n 1) → Real\nh : ∀ (i : Fin (HAdd.hAdd n 1)), LT.lt (l i) (u i)\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq ({ lower := l, upper := u, lower_lt_upper := h }.face i) { lower := Function.comp l i.succAbove, upper := Function.comp u i.succAbove, lower_lt_upper := ⋯ }","decl":"@[simp]\ntheorem face_mk {n} (l u : Fin (n + 1) → ℝ) (h : ∀ i, l i < u i) (i : Fin (n + 1)) :\n    face ⟨l, u, h⟩ i = ⟨l ∘ Fin.succAbove i, u ∘ Fin.succAbove i, fun _ ↦ h _⟩ := rfl\n\n"}
{"name":"BoxIntegral.Box.face_mono","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"n : Nat\nI J : BoxIntegral.Box (Fin (HAdd.hAdd n 1))\nh : LE.le I J\ni : Fin (HAdd.hAdd n 1)\n⊢ LE.le (I.face i) (J.face i)","decl":"@[gcongr, mono]\ntheorem face_mono {n} {I J : Box (Fin (n + 1))} (h : I ≤ J) (i : Fin (n + 1)) :\n    face I i ≤ face J i :=\n  fun _ hx _ ↦ Ioc_subset_Ioc ((le_iff_bounds.1 h).1 _) ((le_iff_bounds.1 h).2 _) (hx _)\n\n"}
{"name":"BoxIntegral.Box.monotone_face","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ Monotone fun I => I.face i","decl":"theorem monotone_face {n} (i : Fin (n + 1)) : Monotone fun I ↦ face I i :=\n  fun _ _ h ↦ face_mono h i\n\n"}
{"name":"BoxIntegral.Box.mapsTo_insertNth_face_Icc","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"n : Nat\nI : BoxIntegral.Box (Fin (HAdd.hAdd n 1))\ni : Fin (HAdd.hAdd n 1)\nx : Real\nhx : Membership.mem (Set.Icc (I.lower i) (I.upper i)) x\n⊢ Set.MapsTo (i.insertNth x) (BoxIntegral.Box.Icc (I.face i)) (BoxIntegral.Box.Icc I)","decl":"theorem mapsTo_insertNth_face_Icc {n} (I : Box (Fin (n + 1))) {i : Fin (n + 1)} {x : ℝ}\n    (hx : x ∈ Icc (I.lower i) (I.upper i)) :\n    MapsTo (i.insertNth x) (Box.Icc (I.face i)) (Box.Icc I) :=\n  fun _ hy ↦ Fin.insertNth_mem_Icc.2 ⟨hx, hy⟩\n\n"}
{"name":"BoxIntegral.Box.mapsTo_insertNth_face","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"n : Nat\nI : BoxIntegral.Box (Fin (HAdd.hAdd n 1))\ni : Fin (HAdd.hAdd n 1)\nx : Real\nhx : Membership.mem (Set.Ioc (I.lower i) (I.upper i)) x\n⊢ Set.MapsTo (i.insertNth x) ↑(I.face i) ↑I","decl":"theorem mapsTo_insertNth_face {n} (I : Box (Fin (n + 1))) {i : Fin (n + 1)} {x : ℝ}\n    (hx : x ∈ Ioc (I.lower i) (I.upper i)) :\n    MapsTo (i.insertNth x) (I.face i : Set (_ → _)) (I : Set (_ → _)) := by\n  intro y hy\n  simp_rw [mem_coe, mem_def, i.forall_iff_succAbove, Fin.insertNth_apply_same,\n    Fin.insertNth_apply_succAbove]\n  exact ⟨hx, hy⟩\n\n"}
{"name":"BoxIntegral.Box.continuousOn_face_Icc","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nn : Nat\nf : (Fin (HAdd.hAdd n 1) → Real) → X\nI : BoxIntegral.Box (Fin (HAdd.hAdd n 1))\nh : ContinuousOn f (BoxIntegral.Box.Icc I)\ni : Fin (HAdd.hAdd n 1)\nx : Real\nhx : Membership.mem (Set.Icc (I.lower i) (I.upper i)) x\n⊢ ContinuousOn (Function.comp f (i.insertNth x)) (BoxIntegral.Box.Icc (I.face i))","decl":"theorem continuousOn_face_Icc {X} [TopologicalSpace X] {n} {f : (Fin (n + 1) → ℝ) → X}\n    {I : Box (Fin (n + 1))} (h : ContinuousOn f (Box.Icc I)) {i : Fin (n + 1)} {x : ℝ}\n    (hx : x ∈ Icc (I.lower i) (I.upper i)) :\n    ContinuousOn (f ∘ i.insertNth x) (Box.Icc (I.face i)) :=\n  h.comp (continuousOn_const.finInsertNth i continuousOn_id) (I.mapsTo_insertNth_face_Icc hx)\n\n"}
{"name":"BoxIntegral.Box.Ioo_subset_coe","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\n⊢ HasSubset.Subset (BoxIntegral.Box.Ioo I) ↑I","decl":"theorem Ioo_subset_coe (I : Box ι) : Box.Ioo I ⊆ I :=\n  fun _ hx i ↦ Ioo_subset_Ioc_self (hx i trivial)\n\n"}
{"name":"BoxIntegral.Box.Ioo_subset_Icc","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\n⊢ HasSubset.Subset (BoxIntegral.Box.Ioo I) (BoxIntegral.Box.Icc I)","decl":"protected theorem Ioo_subset_Icc (I : Box ι) : Box.Ioo I ⊆ Box.Icc I :=\n  I.Ioo_subset_coe.trans coe_subset_Icc\n\n"}
{"name":"BoxIntegral.Box.iUnion_Ioo_of_tendsto","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\ninst✝ : Finite ι\nI : BoxIntegral.Box ι\nJ : Nat → BoxIntegral.Box ι\nhJ : Monotone J\nhl : Filter.Tendsto (Function.comp BoxIntegral.Box.lower J) Filter.atTop (nhds I.lower)\nhu : Filter.Tendsto (Function.comp BoxIntegral.Box.upper J) Filter.atTop (nhds I.upper)\n⊢ Eq (Set.iUnion fun n => BoxIntegral.Box.Ioo (J n)) (BoxIntegral.Box.Ioo I)","decl":"theorem iUnion_Ioo_of_tendsto [Finite ι] {I : Box ι} {J : ℕ → Box ι} (hJ : Monotone J)\n    (hl : Tendsto (lower ∘ J) atTop (𝓝 I.lower)) (hu : Tendsto (upper ∘ J) atTop (𝓝 I.upper)) :\n    ⋃ n, Box.Ioo (J n) = Box.Ioo I :=\n  have hl' : ∀ i, Antitone fun n ↦ (J n).lower i :=\n    fun i ↦ (monotone_eval i).comp_antitone (antitone_lower.comp_monotone hJ)\n  have hu' : ∀ i, Monotone fun n ↦ (J n).upper i :=\n    fun i ↦ (monotone_eval i).comp (monotone_upper.comp hJ)\n  calc\n    ⋃ n, Box.Ioo (J n) = pi univ fun i ↦ ⋃ n, Ioo ((J n).lower i) ((J n).upper i) :=\n      iUnion_univ_pi_of_monotone fun i ↦ (hl' i).Ioo (hu' i)\n    _ = Box.Ioo I :=\n      pi_congr rfl fun i _ ↦\n        iUnion_Ioo_of_mono_of_isGLB_of_isLUB (hl' i) (hu' i)\n          (isGLB_of_tendsto_atTop (hl' i) (tendsto_pi_nhds.1 hl _))\n          (isLUB_of_tendsto_atTop (hu' i) (tendsto_pi_nhds.1 hu _))\n\n"}
{"name":"BoxIntegral.Box.exists_seq_mono_tendsto","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\n⊢ Exists fun J => And (∀ (n : Nat), HasSubset.Subset (BoxIntegral.Box.Icc (J n)) (BoxIntegral.Box.Ioo I)) (And (Filter.Tendsto (Function.comp BoxIntegral.Box.lower ⇑J) Filter.atTop (nhds I.lower)) (Filter.Tendsto (Function.comp BoxIntegral.Box.upper ⇑J) Filter.atTop (nhds I.upper)))","decl":"theorem exists_seq_mono_tendsto (I : Box ι) :\n    ∃ J : ℕ →o Box ι,\n      (∀ n, Box.Icc (J n) ⊆ Box.Ioo I) ∧\n        Tendsto (lower ∘ J) atTop (𝓝 I.lower) ∧ Tendsto (upper ∘ J) atTop (𝓝 I.upper) := by\n  choose a b ha_anti hb_mono ha_mem hb_mem hab ha_tendsto hb_tendsto using\n    fun i ↦ exists_seq_strictAnti_strictMono_tendsto (I.lower_lt_upper i)\n  exact\n    ⟨⟨fun k ↦ ⟨flip a k, flip b k, fun i ↦ hab _ _ _⟩, fun k l hkl ↦\n        le_iff_bounds.2 ⟨fun i ↦ (ha_anti i).antitone hkl, fun i ↦ (hb_mono i).monotone hkl⟩⟩,\n      fun n x hx i _ ↦ ⟨(ha_mem _ _).1.trans_le (hx.1 _), (hx.2 _).trans_lt (hb_mem _ _).2⟩,\n      tendsto_pi_nhds.2 ha_tendsto, tendsto_pi_nhds.2 hb_tendsto⟩\n\n"}
{"name":"BoxIntegral.Box.distortion_eq_of_sub_eq_div","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI J : BoxIntegral.Box ι\nr : Real\nh : ∀ (i : ι), Eq (HSub.hSub (I.upper i) (I.lower i)) (HDiv.hDiv (HSub.hSub (J.upper i) (J.lower i)) r)\n⊢ Eq I.distortion J.distortion","decl":"theorem distortion_eq_of_sub_eq_div {I J : Box ι} {r : ℝ}\n    (h : ∀ i, I.upper i - I.lower i = (J.upper i - J.lower i) / r) :\n    distortion I = distortion J := by\n  simp only [distortion, nndist_pi_def, Real.nndist_eq', h, map_div₀]\n  congr 1 with i\n  have : 0 < r := by\n    by_contra hr\n    have := div_nonpos_of_nonneg_of_nonpos (sub_nonneg.2 <| J.lower_le_upper i) (not_lt.1 hr)\n    rw [← h] at this\n    exact this.not_lt (sub_pos.2 <| I.lower_lt_upper i)\n  have hn0 := (map_ne_zero Real.nnabs).2 this.ne'\n  simp_rw [NNReal.finset_sup_div, div_div_div_cancel_right₀ hn0]\n\n"}
{"name":"BoxIntegral.Box.nndist_le_distortion_mul","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\ni : ι\n⊢ LE.le (NNDist.nndist I.lower I.upper) (HMul.hMul I.distortion (NNDist.nndist (I.lower i) (I.upper i)))","decl":"theorem nndist_le_distortion_mul (I : Box ι) (i : ι) :\n    nndist I.lower I.upper ≤ I.distortion * nndist (I.lower i) (I.upper i) :=\n  calc\n    nndist I.lower I.upper =\n        nndist I.lower I.upper / nndist (I.lower i) (I.upper i) * nndist (I.lower i) (I.upper i) :=\n      (div_mul_cancel₀ _ <| mt nndist_eq_zero.1 (I.lower_lt_upper i).ne).symm\n    _ ≤ I.distortion * nndist (I.lower i) (I.upper i) := by\n      apply mul_le_mul_right'\n      apply Finset.le_sup (Finset.mem_univ i)\n\n"}
{"name":"BoxIntegral.Box.dist_le_distortion_mul","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\ni : ι\n⊢ LE.le (Dist.dist I.lower I.upper) (HMul.hMul (↑I.distortion) (HSub.hSub (I.upper i) (I.lower i)))","decl":"theorem dist_le_distortion_mul (I : Box ι) (i : ι) :\n    dist I.lower I.upper ≤ I.distortion * (I.upper i - I.lower i) := by\n  have A : I.lower i - I.upper i < 0 := sub_neg.2 (I.lower_lt_upper i)\n  simpa only [← NNReal.coe_le_coe, ← dist_nndist, NNReal.coe_mul, Real.dist_eq, abs_of_neg A,\n    neg_sub] using I.nndist_le_distortion_mul i\n\n"}
{"name":"BoxIntegral.Box.diam_Icc_le_of_distortion_le","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\ni : ι\nc : NNReal\nh : LE.le I.distortion c\n⊢ LE.le (Metric.diam (BoxIntegral.Box.Icc I)) (HMul.hMul (↑c) (HSub.hSub (I.upper i) (I.lower i)))","decl":"theorem diam_Icc_le_of_distortion_le (I : Box ι) (i : ι) {c : ℝ≥0} (h : I.distortion ≤ c) :\n    diam (Box.Icc I) ≤ c * (I.upper i - I.lower i) :=\n  have : (0 : ℝ) ≤ c * (I.upper i - I.lower i) :=\n    mul_nonneg c.coe_nonneg (sub_nonneg.2 <| I.lower_le_upper _)\n  diam_le_of_forall_dist_le this fun x hx y hy ↦\n    calc\n      dist x y ≤ dist I.lower I.upper := Real.dist_le_of_mem_pi_Icc hx hy\n      _ ≤ I.distortion * (I.upper i - I.lower i) := I.dist_le_distortion_mul i\n      _ ≤ c * (I.upper i - I.lower i) := by gcongr; exact sub_nonneg.2 (I.lower_le_upper i)\n\n"}
