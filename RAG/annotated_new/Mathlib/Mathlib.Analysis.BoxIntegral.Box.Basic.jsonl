{"name":"BoxIntegral.Box.lower_lt_upper","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_2\nself : BoxIntegral.Box Œπ\ni : Œπ\n‚ä¢ LT.lt (self.lower i) (self.upper i)","decl":"/-- A nontrivial rectangular box in `Œπ ‚Üí ‚Ñù` with corners `lower` and `upper`. Represents the product\nof half-open intervals `(lower i, upper i]`. -/\nstructure Box (Œπ : Type*) where\n  /-- coordinates of the lower and upper corners of the box -/\n  (lower upper : Œπ ‚Üí ‚Ñù)\n  /-- Each lower coordinate is less than its upper coordinate: i.e., the box is non-empty -/\n  lower_lt_upper : ‚àÄ i, lower i < upper i\n\n"}
{"name":"BoxIntegral.Box.mk.sizeOf_spec","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_2\ninst‚úù : SizeOf Œπ\nlower upper : Œπ ‚Üí Real\nlower_lt_upper : ‚àÄ (i : Œπ), LT.lt (lower i) (upper i)\n‚ä¢ Eq (SizeOf.sizeOf { lower := lower, upper := upper, lower_lt_upper := lower_lt_upper }) 1","decl":"/-- A nontrivial rectangular box in `Œπ ‚Üí ‚Ñù` with corners `lower` and `upper`. Represents the product\nof half-open intervals `(lower i, upper i]`. -/\nstructure Box (Œπ : Type*) where\n  /-- coordinates of the lower and upper corners of the box -/\n  (lower upper : Œπ ‚Üí ‚Ñù)\n  /-- Each lower coordinate is less than its upper coordinate: i.e., the box is non-empty -/\n  lower_lt_upper : ‚àÄ i, lower i < upper i\n\n"}
{"name":"BoxIntegral.Box.mk.injEq","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_2\nlower‚úù upper‚úù : Œπ ‚Üí Real\nlower_lt_upper‚úù : ‚àÄ (i : Œπ), LT.lt (lower‚úù i) (upper‚úù i)\nlower upper : Œπ ‚Üí Real\nlower_lt_upper : ‚àÄ (i : Œπ), LT.lt (lower i) (upper i)\n‚ä¢ Eq (Eq { lower := lower‚úù, upper := upper‚úù, lower_lt_upper := lower_lt_upper‚úù } { lower := lower, upper := upper, lower_lt_upper := lower_lt_upper }) (And (Eq lower‚úù lower) (Eq upper‚úù upper))","decl":"/-- A nontrivial rectangular box in `Œπ ‚Üí ‚Ñù` with corners `lower` and `upper`. Represents the product\nof half-open intervals `(lower i, upper i]`. -/\nstructure Box (Œπ : Type*) where\n  /-- coordinates of the lower and upper corners of the box -/\n  (lower upper : Œπ ‚Üí ‚Ñù)\n  /-- Each lower coordinate is less than its upper coordinate: i.e., the box is non-empty -/\n  lower_lt_upper : ‚àÄ i, lower i < upper i\n\n"}
{"name":"BoxIntegral.Box.mk.inj","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_2\nlower‚úù upper‚úù : Œπ ‚Üí Real\nlower_lt_upper‚úù : ‚àÄ (i : Œπ), LT.lt (lower‚úù i) (upper‚úù i)\nlower upper : Œπ ‚Üí Real\nlower_lt_upper : ‚àÄ (i : Œπ), LT.lt (lower i) (upper i)\nx‚úù : Eq { lower := lower‚úù, upper := upper‚úù, lower_lt_upper := lower_lt_upper‚úù } { lower := lower, upper := upper, lower_lt_upper := lower_lt_upper }\n‚ä¢ And (Eq lower‚úù lower) (Eq upper‚úù upper)","decl":"/-- A nontrivial rectangular box in `Œπ ‚Üí ‚Ñù` with corners `lower` and `upper`. Represents the product\nof half-open intervals `(lower i, upper i]`. -/\nstructure Box (Œπ : Type*) where\n  /-- coordinates of the lower and upper corners of the box -/\n  (lower upper : Œπ ‚Üí ‚Ñù)\n  /-- Each lower coordinate is less than its upper coordinate: i.e., the box is non-empty -/\n  lower_lt_upper : ‚àÄ i, lower i < upper i\n\n"}
{"name":"BoxIntegral.Box.lower_le_upper","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI : BoxIntegral.Box Œπ\n‚ä¢ LE.le I.lower I.upper","decl":"theorem lower_le_upper : I.lower ‚â§ I.upper :=\n  fun i ‚Ü¶ (I.lower_lt_upper i).le\n\n"}
{"name":"BoxIntegral.Box.lower_ne_upper","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI : BoxIntegral.Box Œπ\ni : Œπ\n‚ä¢ Ne (I.lower i) (I.upper i)","decl":"theorem lower_ne_upper (i) : I.lower i ‚â† I.upper i :=\n  (I.lower_lt_upper i).ne\n\n"}
{"name":"BoxIntegral.Box.mem_mk","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nl u x : Œπ ‚Üí Real\nH : ‚àÄ (i : Œπ), LT.lt (l i) (u i)\n‚ä¢ Iff (Membership.mem { lower := l, upper := u, lower_lt_upper := H } x) (‚àÄ (i : Œπ), Membership.mem (Set.Ioc (l i) (u i)) (x i))","decl":"@[simp]\ntheorem mem_mk {l u x : Œπ ‚Üí ‚Ñù} {H} : x ‚àà mk l u H ‚Üî ‚àÄ i, x i ‚àà Ioc (l i) (u i) := Iff.rfl\n\n"}
{"name":"BoxIntegral.Box.mem_coe","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI : BoxIntegral.Box Œπ\nx : Œπ ‚Üí Real\n‚ä¢ Iff (Membership.mem (‚ÜëI) x) (Membership.mem I x)","decl":"@[simp, norm_cast]\ntheorem mem_coe : x ‚àà (I : Set (Œπ ‚Üí ‚Ñù)) ‚Üî x ‚àà I := Iff.rfl\n\n"}
{"name":"BoxIntegral.Box.mem_def","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI : BoxIntegral.Box Œπ\nx : Œπ ‚Üí Real\n‚ä¢ Iff (Membership.mem I x) (‚àÄ (i : Œπ), Membership.mem (Set.Ioc (I.lower i) (I.upper i)) (x i))","decl":"theorem mem_def : x ‚àà I ‚Üî ‚àÄ i, x i ‚àà Ioc (I.lower i) (I.upper i) := Iff.rfl\n\n"}
{"name":"BoxIntegral.Box.mem_univ_Ioc","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nx : Œπ ‚Üí Real\nI : BoxIntegral.Box Œπ\n‚ä¢ Iff (Membership.mem (Set.univ.pi fun i => Set.Ioc (I.lower i) (I.upper i)) x) (Membership.mem I x)","decl":"theorem mem_univ_Ioc {I : Box Œπ} : (x ‚àà pi univ fun i ‚Ü¶ Ioc (I.lower i) (I.upper i)) ‚Üî x ‚àà I :=\n  mem_univ_pi\n\n"}
{"name":"BoxIntegral.Box.coe_eq_pi","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI : BoxIntegral.Box Œπ\n‚ä¢ Eq (‚ÜëI) (Set.univ.pi fun i => Set.Ioc (I.lower i) (I.upper i))","decl":"theorem coe_eq_pi : (I : Set (Œπ ‚Üí ‚Ñù)) = pi univ fun i ‚Ü¶ Ioc (I.lower i) (I.upper i) :=\n  Set.ext fun _ ‚Ü¶ mem_univ_Ioc.symm\n\n"}
{"name":"BoxIntegral.Box.upper_mem","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI : BoxIntegral.Box Œπ\n‚ä¢ Membership.mem I I.upper","decl":"@[simp]\ntheorem upper_mem : I.upper ‚àà I :=\n  fun i ‚Ü¶ right_mem_Ioc.2 <| I.lower_lt_upper i\n\n"}
{"name":"BoxIntegral.Box.exists_mem","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI : BoxIntegral.Box Œπ\n‚ä¢ Exists fun x => Membership.mem I x","decl":"theorem exists_mem : ‚àÉ x, x ‚àà I :=\n  ‚ü®_, I.upper_mem‚ü©\n\n"}
{"name":"BoxIntegral.Box.nonempty_coe","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI : BoxIntegral.Box Œπ\n‚ä¢ (‚ÜëI).Nonempty","decl":"theorem nonempty_coe : Set.Nonempty (I : Set (Œπ ‚Üí ‚Ñù)) :=\n  I.exists_mem\n\n"}
{"name":"BoxIntegral.Box.coe_ne_empty","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI : BoxIntegral.Box Œπ\n‚ä¢ Ne (‚ÜëI) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem coe_ne_empty : (I : Set (Œπ ‚Üí ‚Ñù)) ‚â† ‚àÖ :=\n  I.nonempty_coe.ne_empty\n\n"}
{"name":"BoxIntegral.Box.empty_ne_coe","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI : BoxIntegral.Box Œπ\n‚ä¢ Ne EmptyCollection.emptyCollection ‚ÜëI","decl":"@[simp]\ntheorem empty_ne_coe : ‚àÖ ‚â† (I : Set (Œπ ‚Üí ‚Ñù)) :=\n  I.coe_ne_empty.symm\n\n"}
{"name":"BoxIntegral.Box.le_def","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI J : BoxIntegral.Box Œπ\n‚ä¢ Iff (LE.le I J) (‚àÄ (x : Œπ ‚Üí Real), Membership.mem I x ‚Üí Membership.mem J x)","decl":"theorem le_def : I ‚â§ J ‚Üî ‚àÄ x ‚àà I, x ‚àà J := Iff.rfl\n\n"}
{"name":"BoxIntegral.Box.le_TFAE","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI J : BoxIntegral.Box Œπ\n‚ä¢ (List.cons (LE.le I J) (List.cons (HasSubset.Subset ‚ÜëI ‚ÜëJ) (List.cons (HasSubset.Subset (Set.Icc I.lower I.upper) (Set.Icc J.lower J.upper)) (List.cons (And (LE.le J.lower I.lower) (LE.le I.upper J.upper)) List.nil)))).TFAE","decl":"theorem le_TFAE : List.TFAE [I ‚â§ J, (I : Set (Œπ ‚Üí ‚Ñù)) ‚äÜ J,\n    Icc I.lower I.upper ‚äÜ Icc J.lower J.upper, J.lower ‚â§ I.lower ‚àß I.upper ‚â§ J.upper] := by\n  tfae_have 1 ‚Üî 2 := Iff.rfl\n  tfae_have 2 ‚Üí 3\n  | h => by simpa [coe_eq_pi, closure_pi_set, lower_ne_upper] using closure_mono h\n  tfae_have 3 ‚Üî 4 := Icc_subset_Icc_iff I.lower_le_upper\n  tfae_have 4 ‚Üí 2\n  | h, x, hx, i => Ioc_subset_Ioc (h.1 i) (h.2 i) (hx i)\n  tfae_finish\n\n"}
{"name":"BoxIntegral.Box.coe_subset_coe","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI J : BoxIntegral.Box Œπ\n‚ä¢ Iff (HasSubset.Subset ‚ÜëI ‚ÜëJ) (LE.le I J)","decl":"@[simp, norm_cast]\ntheorem coe_subset_coe : (I : Set (Œπ ‚Üí ‚Ñù)) ‚äÜ J ‚Üî I ‚â§ J := Iff.rfl\n\n"}
{"name":"BoxIntegral.Box.le_iff_bounds","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI J : BoxIntegral.Box Œπ\n‚ä¢ Iff (LE.le I J) (And (LE.le J.lower I.lower) (LE.le I.upper J.upper))","decl":"theorem le_iff_bounds : I ‚â§ J ‚Üî J.lower ‚â§ I.lower ‚àß I.upper ‚â§ J.upper :=\n  (le_TFAE I J).out 0 3\n\n"}
{"name":"BoxIntegral.Box.injective_coe","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\n‚ä¢ Function.Injective BoxIntegral.Box.toSet","decl":"theorem injective_coe : Injective ((‚Üë) : Box Œπ ‚Üí Set (Œπ ‚Üí ‚Ñù)) := by\n  rintro ‚ü®l‚ÇÅ, u‚ÇÅ, h‚ÇÅ‚ü© ‚ü®l‚ÇÇ, u‚ÇÇ, h‚ÇÇ‚ü© h\n  simp only [Subset.antisymm_iff, coe_subset_coe, le_iff_bounds] at h\n  congr\n  exacts [le_antisymm h.2.1 h.1.1, le_antisymm h.1.2 h.2.2]\n\n"}
{"name":"BoxIntegral.Box.coe_inj","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI J : BoxIntegral.Box Œπ\n‚ä¢ Iff (Eq ‚ÜëI ‚ÜëJ) (Eq I J)","decl":"@[simp, norm_cast]\ntheorem coe_inj : (I : Set (Œπ ‚Üí ‚Ñù)) = J ‚Üî I = J :=\n  injective_coe.eq_iff\n\n"}
{"name":"BoxIntegral.Box.ext","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI J : BoxIntegral.Box Œπ\nH : ‚àÄ (x : Œπ ‚Üí Real), Iff (Membership.mem I x) (Membership.mem J x)\n‚ä¢ Eq I J","decl":"@[ext]\ntheorem ext (H : ‚àÄ x, x ‚àà I ‚Üî x ‚àà J) : I = J :=\n  injective_coe <| Set.ext H\n\n"}
{"name":"BoxIntegral.Box.ext_iff","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI J : BoxIntegral.Box Œπ\n‚ä¢ Iff (Eq I J) (‚àÄ (x : Œπ ‚Üí Real), Iff (Membership.mem I x) (Membership.mem J x))","decl":"@[ext]\ntheorem ext (H : ‚àÄ x, x ‚àà I ‚Üî x ‚àà J) : I = J :=\n  injective_coe <| Set.ext H\n\n"}
{"name":"BoxIntegral.Box.ne_of_disjoint_coe","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI J : BoxIntegral.Box Œπ\nh : Disjoint ‚ÜëI ‚ÜëJ\n‚ä¢ Ne I J","decl":"theorem ne_of_disjoint_coe (h : Disjoint (I : Set (Œπ ‚Üí ‚Ñù)) J) : I ‚â† J :=\n  mt coe_inj.2 <| h.ne I.coe_ne_empty\n\n"}
{"name":"BoxIntegral.Box.Icc_def","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI : BoxIntegral.Box Œπ\n‚ä¢ Eq (BoxIntegral.Box.Icc I) (Set.Icc I.lower I.upper)","decl":"theorem Icc_def : Box.Icc I = Icc I.lower I.upper := rfl\n\n"}
{"name":"BoxIntegral.Box.upper_mem_Icc","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI : BoxIntegral.Box Œπ\n‚ä¢ Membership.mem (BoxIntegral.Box.Icc I) I.upper","decl":"@[simp]\ntheorem upper_mem_Icc (I : Box Œπ) : I.upper ‚àà Box.Icc I :=\n  right_mem_Icc.2 I.lower_le_upper\n\n"}
{"name":"BoxIntegral.Box.lower_mem_Icc","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI : BoxIntegral.Box Œπ\n‚ä¢ Membership.mem (BoxIntegral.Box.Icc I) I.lower","decl":"@[simp]\ntheorem lower_mem_Icc (I : Box Œπ) : I.lower ‚àà Box.Icc I :=\n  left_mem_Icc.2 I.lower_le_upper\n\n"}
{"name":"BoxIntegral.Box.isCompact_Icc","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI : BoxIntegral.Box Œπ\n‚ä¢ IsCompact (BoxIntegral.Box.Icc I)","decl":"protected theorem isCompact_Icc (I : Box Œπ) : IsCompact (Box.Icc I) :=\n  isCompact_Icc\n\n"}
{"name":"BoxIntegral.Box.Icc_eq_pi","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI : BoxIntegral.Box Œπ\n‚ä¢ Eq (BoxIntegral.Box.Icc I) (Set.univ.pi fun i => Set.Icc (I.lower i) (I.upper i))","decl":"theorem Icc_eq_pi : Box.Icc I = pi univ fun i ‚Ü¶ Icc (I.lower i) (I.upper i) :=\n  (pi_univ_Icc _ _).symm\n\n"}
{"name":"BoxIntegral.Box.le_iff_Icc","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI J : BoxIntegral.Box Œπ\n‚ä¢ Iff (LE.le I J) (HasSubset.Subset (BoxIntegral.Box.Icc I) (BoxIntegral.Box.Icc J))","decl":"theorem le_iff_Icc : I ‚â§ J ‚Üî Box.Icc I ‚äÜ Box.Icc J :=\n  (le_TFAE I J).out 0 2\n\n"}
{"name":"BoxIntegral.Box.antitone_lower","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\n‚ä¢ Antitone fun I => I.lower","decl":"theorem antitone_lower : Antitone fun I : Box Œπ ‚Ü¶ I.lower :=\n  fun _ _ H ‚Ü¶ (le_iff_bounds.1 H).1\n\n"}
{"name":"BoxIntegral.Box.monotone_upper","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\n‚ä¢ Monotone fun I => I.upper","decl":"theorem monotone_upper : Monotone fun I : Box Œπ ‚Ü¶ I.upper :=\n  fun _ _ H ‚Ü¶ (le_iff_bounds.1 H).2\n\n"}
{"name":"BoxIntegral.Box.coe_subset_Icc","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI : BoxIntegral.Box Œπ\n‚ä¢ HasSubset.Subset (‚ÜëI) (BoxIntegral.Box.Icc I)","decl":"theorem coe_subset_Icc : ‚ÜëI ‚äÜ Box.Icc I :=\n  fun _ hx ‚Ü¶ ‚ü®fun i ‚Ü¶ (hx i).1.le, fun i ‚Ü¶ (hx i).2‚ü©\n\n"}
{"name":"BoxIntegral.Box.isBounded_Icc","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\ninst‚úù : Finite Œπ\nI : BoxIntegral.Box Œπ\n‚ä¢ Bornology.IsBounded (BoxIntegral.Box.Icc I)","decl":"theorem isBounded_Icc [Finite Œπ] (I : Box Œπ) : Bornology.IsBounded (Box.Icc I) := by\n  cases nonempty_fintype Œπ\n  exact Metric.isBounded_Icc _ _\n\n"}
{"name":"BoxIntegral.Box.isBounded","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\ninst‚úù : Finite Œπ\nI : BoxIntegral.Box Œπ\n‚ä¢ Bornology.IsBounded ‚ÜëI","decl":"theorem isBounded [Finite Œπ] (I : Box Œπ) : Bornology.IsBounded I.toSet :=\n  Bornology.IsBounded.subset I.isBounded_Icc coe_subset_Icc\n\n"}
{"name":"BoxIntegral.Box.coe_bot","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\n‚ä¢ Eq (‚ÜëBot.bot) EmptyCollection.emptyCollection","decl":"@[simp, norm_cast]\ntheorem coe_bot : ((‚ä• : WithBot (Box Œπ)) : Set (Œπ ‚Üí ‚Ñù)) = ‚àÖ := rfl\n\n"}
{"name":"BoxIntegral.Box.coe_coe","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI : BoxIntegral.Box Œπ\n‚ä¢ Eq ‚Üë‚ÜëI ‚ÜëI","decl":"@[simp, norm_cast]\ntheorem coe_coe : ((I : WithBot (Box Œπ)) : Set (Œπ ‚Üí ‚Ñù)) = I := rfl\n\n"}
{"name":"BoxIntegral.Box.isSome_iff","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI : WithBot (BoxIntegral.Box Œπ)\n‚ä¢ Iff (Eq (Option.isSome I) Bool.true) (‚ÜëI).Nonempty","decl":"theorem isSome_iff : ‚àÄ {I : WithBot (Box Œπ)}, I.isSome ‚Üî (I : Set (Œπ ‚Üí ‚Ñù)).Nonempty\n  | ‚ä• => by\n    erw [Option.isSome]\n    simp\n  | (I : Box Œπ) => by\n    erw [Option.isSome]\n    simp [I.nonempty_coe]\n\n"}
{"name":"BoxIntegral.Box.biUnion_coe_eq_coe","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI : WithBot (BoxIntegral.Box Œπ)\n‚ä¢ Eq (Set.iUnion fun J => Set.iUnion fun x => ‚ÜëJ) ‚ÜëI","decl":"theorem biUnion_coe_eq_coe (I : WithBot (Box Œπ)) :\n    ‚ãÉ (J : Box Œπ) (_ : ‚ÜëJ = I), (J : Set (Œπ ‚Üí ‚Ñù)) = I := by\n  induction I <;> simp [WithBot.coe_eq_coe]\n\n"}
{"name":"BoxIntegral.Box.withBotCoe_subset_iff","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI J : WithBot (BoxIntegral.Box Œπ)\n‚ä¢ Iff (HasSubset.Subset ‚ÜëI ‚ÜëJ) (LE.le I J)","decl":"@[simp, norm_cast]\ntheorem withBotCoe_subset_iff {I J : WithBot (Box Œπ)} : (I : Set (Œπ ‚Üí ‚Ñù)) ‚äÜ J ‚Üî I ‚â§ J := by\n  induction I; ¬∑ simp\n  induction J; ¬∑ simp [subset_empty_iff]\n  simp [le_def]\n\n"}
{"name":"BoxIntegral.Box.withBotCoe_inj","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI J : WithBot (BoxIntegral.Box Œπ)\n‚ä¢ Iff (Eq ‚ÜëI ‚ÜëJ) (Eq I J)","decl":"@[simp, norm_cast]\ntheorem withBotCoe_inj {I J : WithBot (Box Œπ)} : (I : Set (Œπ ‚Üí ‚Ñù)) = J ‚Üî I = J := by\n  simp only [Subset.antisymm_iff, ‚Üê le_antisymm_iff, withBotCoe_subset_iff]\n\n"}
{"name":"BoxIntegral.Box.mk'_eq_bot","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nl u : Œπ ‚Üí Real\n‚ä¢ Iff (Eq (BoxIntegral.Box.mk' l u) Bot.bot) (Exists fun i => LE.le (u i) (l i))","decl":"@[simp]\ntheorem mk'_eq_bot {l u : Œπ ‚Üí ‚Ñù} : mk' l u = ‚ä• ‚Üî ‚àÉ i, u i ‚â§ l i := by\n  rw [mk']\n  split_ifs with h <;> simpa using h\n\n"}
{"name":"BoxIntegral.Box.mk'_eq_coe","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI : BoxIntegral.Box Œπ\nl u : Œπ ‚Üí Real\n‚ä¢ Iff (Eq (BoxIntegral.Box.mk' l u) ‚ÜëI) (And (Eq l I.lower) (Eq u I.upper))","decl":"@[simp]\ntheorem mk'_eq_coe {l u : Œπ ‚Üí ‚Ñù} : mk' l u = I ‚Üî l = I.lower ‚àß u = I.upper := by\n  cases' I with lI uI hI; rw [mk']; split_ifs with h\n  ¬∑ simp [WithBot.coe_eq_coe]\n  ¬∑ suffices l = lI ‚Üí u ‚â† uI by simpa\n    rintro rfl rfl\n    exact h hI\n\n"}
{"name":"BoxIntegral.Box.coe_mk'","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nl u : Œπ ‚Üí Real\n‚ä¢ Eq (‚Üë(BoxIntegral.Box.mk' l u)) (Set.univ.pi fun i => Set.Ioc (l i) (u i))","decl":"@[simp]\ntheorem coe_mk' (l u : Œπ ‚Üí ‚Ñù) : (mk' l u : Set (Œπ ‚Üí ‚Ñù)) = pi univ fun i ‚Ü¶ Ioc (l i) (u i) := by\n  rw [mk']; split_ifs with h\n  ¬∑ exact coe_eq_pi _\n  ¬∑ rcases not_forall.mp h with ‚ü®i, hi‚ü©\n    rw [coe_bot, univ_pi_eq_empty]\n    exact Ioc_eq_empty hi\n\n"}
{"name":"BoxIntegral.Box.coe_inf","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI J : WithBot (BoxIntegral.Box Œπ)\n‚ä¢ Eq (‚Üë(Min.min I J)) (Inter.inter ‚ÜëI ‚ÜëJ)","decl":"@[simp]\ntheorem coe_inf (I J : WithBot (Box Œπ)) : (‚Üë(I ‚äì J) : Set (Œπ ‚Üí ‚Ñù)) = (I : Set _) ‚à© J := by\n  induction I\n  ¬∑ change ‚àÖ = _\n    simp\n  induction J\n  ¬∑ change ‚àÖ = _\n    simp\n  change ((mk' _ _ : WithBot (Box Œπ)) : Set (Œπ ‚Üí ‚Ñù)) = _\n  simp only [coe_eq_pi, ‚Üê pi_inter_distrib, Ioc_inter_Ioc, Pi.sup_apply, Pi.inf_apply, coe_mk',\n    coe_coe]\n\n"}
{"name":"BoxIntegral.Box.disjoint_withBotCoe","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI J : WithBot (BoxIntegral.Box Œπ)\n‚ä¢ Iff (Disjoint ‚ÜëI ‚ÜëJ) (Disjoint I J)","decl":"@[simp, norm_cast]\ntheorem disjoint_withBotCoe {I J : WithBot (Box Œπ)} :\n    Disjoint (I : Set (Œπ ‚Üí ‚Ñù)) J ‚Üî Disjoint I J := by\n  simp only [disjoint_iff_inf_le, ‚Üê withBotCoe_subset_iff, coe_inf]\n  rfl\n\n"}
{"name":"BoxIntegral.Box.disjoint_coe","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI J : BoxIntegral.Box Œπ\n‚ä¢ Iff (Disjoint ‚ÜëI ‚ÜëJ) (Disjoint ‚ÜëI ‚ÜëJ)","decl":"theorem disjoint_coe : Disjoint (I : WithBot (Box Œπ)) J ‚Üî Disjoint (I : Set (Œπ ‚Üí ‚Ñù)) J :=\n  disjoint_withBotCoe.symm\n\n"}
{"name":"BoxIntegral.Box.not_disjoint_coe_iff_nonempty_inter","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI J : BoxIntegral.Box Œπ\n‚ä¢ Iff (Not (Disjoint ‚ÜëI ‚ÜëJ)) (Inter.inter ‚ÜëI ‚ÜëJ).Nonempty","decl":"theorem not_disjoint_coe_iff_nonempty_inter :\n    ¬¨Disjoint (I : WithBot (Box Œπ)) J ‚Üî (I ‚à© J : Set (Œπ ‚Üí ‚Ñù)).Nonempty := by\n  rw [disjoint_coe, Set.not_disjoint_iff_nonempty_inter]\n\n"}
{"name":"BoxIntegral.Box.face_lower","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"n : Nat\nI : BoxIntegral.Box (Fin (HAdd.hAdd n 1))\ni : Fin (HAdd.hAdd n 1)\na‚úù : Fin n\n‚ä¢ Eq ((I.face i).lower a‚úù) (I.lower (i.succAbove a‚úù))","decl":"/-- Face of a box in `‚Ñù‚Åø‚Å∫¬π = Fin (n + 1) ‚Üí ‚Ñù`: the box in `‚Ñù‚Åø = Fin n ‚Üí ‚Ñù` with corners at\n`I.lower ‚àò Fin.succAbove i` and `I.upper ‚àò Fin.succAbove i`. -/\n@[simps (config := { simpRhs := true })]\ndef face {n} (I : Box (Fin (n + 1))) (i : Fin (n + 1)) : Box (Fin n) :=\n  ‚ü®I.lower ‚àò Fin.succAbove i, I.upper ‚àò Fin.succAbove i, fun _ ‚Ü¶ I.lower_lt_upper _‚ü©\n\n"}
{"name":"BoxIntegral.Box.face_upper","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"n : Nat\nI : BoxIntegral.Box (Fin (HAdd.hAdd n 1))\ni : Fin (HAdd.hAdd n 1)\na‚úù : Fin n\n‚ä¢ Eq ((I.face i).upper a‚úù) (I.upper (i.succAbove a‚úù))","decl":"/-- Face of a box in `‚Ñù‚Åø‚Å∫¬π = Fin (n + 1) ‚Üí ‚Ñù`: the box in `‚Ñù‚Åø = Fin n ‚Üí ‚Ñù` with corners at\n`I.lower ‚àò Fin.succAbove i` and `I.upper ‚àò Fin.succAbove i`. -/\n@[simps (config := { simpRhs := true })]\ndef face {n} (I : Box (Fin (n + 1))) (i : Fin (n + 1)) : Box (Fin n) :=\n  ‚ü®I.lower ‚àò Fin.succAbove i, I.upper ‚àò Fin.succAbove i, fun _ ‚Ü¶ I.lower_lt_upper _‚ü©\n\n"}
{"name":"BoxIntegral.Box.face_mk","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"n : Nat\nl u : Fin (HAdd.hAdd n 1) ‚Üí Real\nh : ‚àÄ (i : Fin (HAdd.hAdd n 1)), LT.lt (l i) (u i)\ni : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq ({ lower := l, upper := u, lower_lt_upper := h }.face i) { lower := Function.comp l i.succAbove, upper := Function.comp u i.succAbove, lower_lt_upper := ‚ãØ }","decl":"@[simp]\ntheorem face_mk {n} (l u : Fin (n + 1) ‚Üí ‚Ñù) (h : ‚àÄ i, l i < u i) (i : Fin (n + 1)) :\n    face ‚ü®l, u, h‚ü© i = ‚ü®l ‚àò Fin.succAbove i, u ‚àò Fin.succAbove i, fun _ ‚Ü¶ h _‚ü© := rfl\n\n"}
{"name":"BoxIntegral.Box.face_mono","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"n : Nat\nI J : BoxIntegral.Box (Fin (HAdd.hAdd n 1))\nh : LE.le I J\ni : Fin (HAdd.hAdd n 1)\n‚ä¢ LE.le (I.face i) (J.face i)","decl":"@[gcongr, mono]\ntheorem face_mono {n} {I J : Box (Fin (n + 1))} (h : I ‚â§ J) (i : Fin (n + 1)) :\n    face I i ‚â§ face J i :=\n  fun _ hx _ ‚Ü¶ Ioc_subset_Ioc ((le_iff_bounds.1 h).1 _) ((le_iff_bounds.1 h).2 _) (hx _)\n\n"}
{"name":"BoxIntegral.Box.monotone_face","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\n‚ä¢ Monotone fun I => I.face i","decl":"theorem monotone_face {n} (i : Fin (n + 1)) : Monotone fun I ‚Ü¶ face I i :=\n  fun _ _ h ‚Ü¶ face_mono h i\n\n"}
{"name":"BoxIntegral.Box.mapsTo_insertNth_face_Icc","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"n : Nat\nI : BoxIntegral.Box (Fin (HAdd.hAdd n 1))\ni : Fin (HAdd.hAdd n 1)\nx : Real\nhx : Membership.mem (Set.Icc (I.lower i) (I.upper i)) x\n‚ä¢ Set.MapsTo (i.insertNth x) (BoxIntegral.Box.Icc (I.face i)) (BoxIntegral.Box.Icc I)","decl":"theorem mapsTo_insertNth_face_Icc {n} (I : Box (Fin (n + 1))) {i : Fin (n + 1)} {x : ‚Ñù}\n    (hx : x ‚àà Icc (I.lower i) (I.upper i)) :\n    MapsTo (i.insertNth x) (Box.Icc (I.face i)) (Box.Icc I) :=\n  fun _ hy ‚Ü¶ Fin.insertNth_mem_Icc.2 ‚ü®hx, hy‚ü©\n\n"}
{"name":"BoxIntegral.Box.mapsTo_insertNth_face","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"n : Nat\nI : BoxIntegral.Box (Fin (HAdd.hAdd n 1))\ni : Fin (HAdd.hAdd n 1)\nx : Real\nhx : Membership.mem (Set.Ioc (I.lower i) (I.upper i)) x\n‚ä¢ Set.MapsTo (i.insertNth x) ‚Üë(I.face i) ‚ÜëI","decl":"theorem mapsTo_insertNth_face {n} (I : Box (Fin (n + 1))) {i : Fin (n + 1)} {x : ‚Ñù}\n    (hx : x ‚àà Ioc (I.lower i) (I.upper i)) :\n    MapsTo (i.insertNth x) (I.face i : Set (_ ‚Üí _)) (I : Set (_ ‚Üí _)) := by\n  intro y hy\n  simp_rw [mem_coe, mem_def, i.forall_iff_succAbove, Fin.insertNth_apply_same,\n    Fin.insertNth_apply_succAbove]\n  exact ‚ü®hx, hy‚ü©\n\n"}
{"name":"BoxIntegral.Box.continuousOn_face_Icc","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"X : Type u_2\ninst‚úù : TopologicalSpace X\nn : Nat\nf : (Fin (HAdd.hAdd n 1) ‚Üí Real) ‚Üí X\nI : BoxIntegral.Box (Fin (HAdd.hAdd n 1))\nh : ContinuousOn f (BoxIntegral.Box.Icc I)\ni : Fin (HAdd.hAdd n 1)\nx : Real\nhx : Membership.mem (Set.Icc (I.lower i) (I.upper i)) x\n‚ä¢ ContinuousOn (Function.comp f (i.insertNth x)) (BoxIntegral.Box.Icc (I.face i))","decl":"theorem continuousOn_face_Icc {X} [TopologicalSpace X] {n} {f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí X}\n    {I : Box (Fin (n + 1))} (h : ContinuousOn f (Box.Icc I)) {i : Fin (n + 1)} {x : ‚Ñù}\n    (hx : x ‚àà Icc (I.lower i) (I.upper i)) :\n    ContinuousOn (f ‚àò i.insertNth x) (Box.Icc (I.face i)) :=\n  h.comp (continuousOn_const.finInsertNth i continuousOn_id) (I.mapsTo_insertNth_face_Icc hx)\n\n"}
{"name":"BoxIntegral.Box.Ioo_subset_coe","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI : BoxIntegral.Box Œπ\n‚ä¢ HasSubset.Subset (BoxIntegral.Box.Ioo I) ‚ÜëI","decl":"theorem Ioo_subset_coe (I : Box Œπ) : Box.Ioo I ‚äÜ I :=\n  fun _ hx i ‚Ü¶ Ioo_subset_Ioc_self (hx i trivial)\n\n"}
{"name":"BoxIntegral.Box.Ioo_subset_Icc","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI : BoxIntegral.Box Œπ\n‚ä¢ HasSubset.Subset (BoxIntegral.Box.Ioo I) (BoxIntegral.Box.Icc I)","decl":"protected theorem Ioo_subset_Icc (I : Box Œπ) : Box.Ioo I ‚äÜ Box.Icc I :=\n  I.Ioo_subset_coe.trans coe_subset_Icc\n\n"}
{"name":"BoxIntegral.Box.iUnion_Ioo_of_tendsto","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\ninst‚úù : Finite Œπ\nI : BoxIntegral.Box Œπ\nJ : Nat ‚Üí BoxIntegral.Box Œπ\nhJ : Monotone J\nhl : Filter.Tendsto (Function.comp BoxIntegral.Box.lower J) Filter.atTop (nhds I.lower)\nhu : Filter.Tendsto (Function.comp BoxIntegral.Box.upper J) Filter.atTop (nhds I.upper)\n‚ä¢ Eq (Set.iUnion fun n => BoxIntegral.Box.Ioo (J n)) (BoxIntegral.Box.Ioo I)","decl":"theorem iUnion_Ioo_of_tendsto [Finite Œπ] {I : Box Œπ} {J : ‚Ñï ‚Üí Box Œπ} (hJ : Monotone J)\n    (hl : Tendsto (lower ‚àò J) atTop (ùìù I.lower)) (hu : Tendsto (upper ‚àò J) atTop (ùìù I.upper)) :\n    ‚ãÉ n, Box.Ioo (J n) = Box.Ioo I :=\n  have hl' : ‚àÄ i, Antitone fun n ‚Ü¶ (J n).lower i :=\n    fun i ‚Ü¶ (monotone_eval i).comp_antitone (antitone_lower.comp_monotone hJ)\n  have hu' : ‚àÄ i, Monotone fun n ‚Ü¶ (J n).upper i :=\n    fun i ‚Ü¶ (monotone_eval i).comp (monotone_upper.comp hJ)\n  calc\n    ‚ãÉ n, Box.Ioo (J n) = pi univ fun i ‚Ü¶ ‚ãÉ n, Ioo ((J n).lower i) ((J n).upper i) :=\n      iUnion_univ_pi_of_monotone fun i ‚Ü¶ (hl' i).Ioo (hu' i)\n    _ = Box.Ioo I :=\n      pi_congr rfl fun i _ ‚Ü¶\n        iUnion_Ioo_of_mono_of_isGLB_of_isLUB (hl' i) (hu' i)\n          (isGLB_of_tendsto_atTop (hl' i) (tendsto_pi_nhds.1 hl _))\n          (isLUB_of_tendsto_atTop (hu' i) (tendsto_pi_nhds.1 hu _))\n\n"}
{"name":"BoxIntegral.Box.exists_seq_mono_tendsto","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\nI : BoxIntegral.Box Œπ\n‚ä¢ Exists fun J => And (‚àÄ (n : Nat), HasSubset.Subset (BoxIntegral.Box.Icc (J n)) (BoxIntegral.Box.Ioo I)) (And (Filter.Tendsto (Function.comp BoxIntegral.Box.lower ‚áëJ) Filter.atTop (nhds I.lower)) (Filter.Tendsto (Function.comp BoxIntegral.Box.upper ‚áëJ) Filter.atTop (nhds I.upper)))","decl":"theorem exists_seq_mono_tendsto (I : Box Œπ) :\n    ‚àÉ J : ‚Ñï ‚Üío Box Œπ,\n      (‚àÄ n, Box.Icc (J n) ‚äÜ Box.Ioo I) ‚àß\n        Tendsto (lower ‚àò J) atTop (ùìù I.lower) ‚àß Tendsto (upper ‚àò J) atTop (ùìù I.upper) := by\n  choose a b ha_anti hb_mono ha_mem hb_mem hab ha_tendsto hb_tendsto using\n    fun i ‚Ü¶ exists_seq_strictAnti_strictMono_tendsto (I.lower_lt_upper i)\n  exact\n    ‚ü®‚ü®fun k ‚Ü¶ ‚ü®flip a k, flip b k, fun i ‚Ü¶ hab _ _ _‚ü©, fun k l hkl ‚Ü¶\n        le_iff_bounds.2 ‚ü®fun i ‚Ü¶ (ha_anti i).antitone hkl, fun i ‚Ü¶ (hb_mono i).monotone hkl‚ü©‚ü©,\n      fun n x hx i _ ‚Ü¶ ‚ü®(ha_mem _ _).1.trans_le (hx.1 _), (hx.2 _).trans_lt (hb_mem _ _).2‚ü©,\n      tendsto_pi_nhds.2 ha_tendsto, tendsto_pi_nhds.2 hb_tendsto‚ü©\n\n"}
{"name":"BoxIntegral.Box.distortion_eq_of_sub_eq_div","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nI J : BoxIntegral.Box Œπ\nr : Real\nh : ‚àÄ (i : Œπ), Eq (HSub.hSub (I.upper i) (I.lower i)) (HDiv.hDiv (HSub.hSub (J.upper i) (J.lower i)) r)\n‚ä¢ Eq I.distortion J.distortion","decl":"theorem distortion_eq_of_sub_eq_div {I J : Box Œπ} {r : ‚Ñù}\n    (h : ‚àÄ i, I.upper i - I.lower i = (J.upper i - J.lower i) / r) :\n    distortion I = distortion J := by\n  simp only [distortion, nndist_pi_def, Real.nndist_eq', h, map_div‚ÇÄ]\n  congr 1 with i\n  have : 0 < r := by\n    by_contra hr\n    have := div_nonpos_of_nonneg_of_nonpos (sub_nonneg.2 <| J.lower_le_upper i) (not_lt.1 hr)\n    rw [‚Üê h] at this\n    exact this.not_lt (sub_pos.2 <| I.lower_lt_upper i)\n  have hn0 := (map_ne_zero Real.nnabs).2 this.ne'\n  simp_rw [NNReal.finset_sup_div, div_div_div_cancel_right‚ÇÄ hn0]\n\n"}
{"name":"BoxIntegral.Box.nndist_le_distortion_mul","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nI : BoxIntegral.Box Œπ\ni : Œπ\n‚ä¢ LE.le (NNDist.nndist I.lower I.upper) (HMul.hMul I.distortion (NNDist.nndist (I.lower i) (I.upper i)))","decl":"theorem nndist_le_distortion_mul (I : Box Œπ) (i : Œπ) :\n    nndist I.lower I.upper ‚â§ I.distortion * nndist (I.lower i) (I.upper i) :=\n  calc\n    nndist I.lower I.upper =\n        nndist I.lower I.upper / nndist (I.lower i) (I.upper i) * nndist (I.lower i) (I.upper i) :=\n      (div_mul_cancel‚ÇÄ _ <| mt nndist_eq_zero.1 (I.lower_lt_upper i).ne).symm\n    _ ‚â§ I.distortion * nndist (I.lower i) (I.upper i) := by\n      apply mul_le_mul_right'\n      apply Finset.le_sup (Finset.mem_univ i)\n\n"}
{"name":"BoxIntegral.Box.dist_le_distortion_mul","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nI : BoxIntegral.Box Œπ\ni : Œπ\n‚ä¢ LE.le (Dist.dist I.lower I.upper) (HMul.hMul (‚ÜëI.distortion) (HSub.hSub (I.upper i) (I.lower i)))","decl":"theorem dist_le_distortion_mul (I : Box Œπ) (i : Œπ) :\n    dist I.lower I.upper ‚â§ I.distortion * (I.upper i - I.lower i) := by\n  have A : I.lower i - I.upper i < 0 := sub_neg.2 (I.lower_lt_upper i)\n  simpa only [‚Üê NNReal.coe_le_coe, ‚Üê dist_nndist, NNReal.coe_mul, Real.dist_eq, abs_of_neg A,\n    neg_sub] using I.nndist_le_distortion_mul i\n\n"}
{"name":"BoxIntegral.Box.diam_Icc_le_of_distortion_le","module":"Mathlib.Analysis.BoxIntegral.Box.Basic","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nI : BoxIntegral.Box Œπ\ni : Œπ\nc : NNReal\nh : LE.le I.distortion c\n‚ä¢ LE.le (Metric.diam (BoxIntegral.Box.Icc I)) (HMul.hMul (‚Üëc) (HSub.hSub (I.upper i) (I.lower i)))","decl":"theorem diam_Icc_le_of_distortion_le (I : Box Œπ) (i : Œπ) {c : ‚Ñù‚â•0} (h : I.distortion ‚â§ c) :\n    diam (Box.Icc I) ‚â§ c * (I.upper i - I.lower i) :=\n  have : (0 : ‚Ñù) ‚â§ c * (I.upper i - I.lower i) :=\n    mul_nonneg c.coe_nonneg (sub_nonneg.2 <| I.lower_le_upper _)\n  diam_le_of_forall_dist_le this fun x hx y hy ‚Ü¶\n    calc\n      dist x y ‚â§ dist I.lower I.upper := Real.dist_le_of_mem_pi_Icc hx hy\n      _ ‚â§ I.distortion * (I.upper i - I.lower i) := I.dist_le_distortion_mul i\n      _ ‚â§ c * (I.upper i - I.lower i) := by gcongr; exact sub_nonneg.2 (I.lower_le_upper i)\n\n"}
