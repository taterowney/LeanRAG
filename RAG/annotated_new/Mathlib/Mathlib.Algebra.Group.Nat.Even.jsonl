{"name":"Nat.even_iff","module":"Mathlib.Algebra.Group.Nat.Even","initialProofState":"n : Nat\n⊢ Iff (Even n) (Eq (HMod.hMod n 2) 0)","decl":"lemma even_iff : Even n ↔ n % 2 = 0 where\n  mp := fun ⟨m, hm⟩ ↦ by simp [← Nat.two_mul, hm]\n  mpr h := ⟨n / 2, (mod_add_div n 2).symm.trans (by simp [← Nat.two_mul, h])⟩\n\n"}
{"name":"Nat.not_even_iff","module":"Mathlib.Algebra.Group.Nat.Even","initialProofState":"n : Nat\n⊢ Iff (Not (Even n)) (Eq (HMod.hMod n 2) 1)","decl":"lemma not_even_iff : ¬ Even n ↔ n % 2 = 1 := by rw [even_iff, mod_two_not_eq_zero]\n\n"}
{"name":"Nat.two_dvd_ne_zero","module":"Mathlib.Algebra.Group.Nat.Even","initialProofState":"n : Nat\n⊢ Iff (Not (Dvd.dvd 2 n)) (Eq (HMod.hMod n 2) 1)","decl":"@[simp] lemma two_dvd_ne_zero : ¬2 ∣ n ↔ n % 2 = 1 :=\n  (even_iff_exists_two_nsmul _).symm.not.trans not_even_iff\n\n"}
{"name":"Nat.not_even_one","module":"Mathlib.Algebra.Group.Nat.Even","initialProofState":"⊢ Not (Even 1)","decl":"@[simp] lemma not_even_one : ¬Even 1 := by simp [even_iff]\n\n"}
{"name":"Nat.even_add","module":"Mathlib.Algebra.Group.Nat.Even","initialProofState":"m n : Nat\n⊢ Iff (Even (HAdd.hAdd m n)) (Iff (Even m) (Even n))","decl":"@[parity_simps] lemma even_add : Even (m + n) ↔ (Even m ↔ Even n) := by\n  rcases mod_two_eq_zero_or_one m with h₁ | h₁ <;> rcases mod_two_eq_zero_or_one n with h₂ | h₂ <;>\n    simp [even_iff, h₁, h₂, Nat.add_mod]\n\n"}
{"name":"Nat.even_add_one","module":"Mathlib.Algebra.Group.Nat.Even","initialProofState":"n : Nat\n⊢ Iff (Even (HAdd.hAdd n 1)) (Not (Even n))","decl":"@[parity_simps] lemma even_add_one : Even (n + 1) ↔ ¬Even n := by simp [even_add]\n\n"}
{"name":"Nat.succ_mod_two_eq_zero_iff","module":"Mathlib.Algebra.Group.Nat.Even","initialProofState":"m : Nat\n⊢ Iff (Eq (HMod.hMod (HAdd.hAdd m 1) 2) 0) (Eq (HMod.hMod m 2) 1)","decl":"lemma succ_mod_two_eq_zero_iff : (m + 1) % 2 = 0 ↔ m % 2 = 1 := by\n  simp [← Nat.even_iff, ← Nat.not_even_iff, parity_simps]\n\n"}
{"name":"Nat.succ_mod_two_eq_one_iff","module":"Mathlib.Algebra.Group.Nat.Even","initialProofState":"m : Nat\n⊢ Iff (Eq (HMod.hMod (HAdd.hAdd m 1) 2) 1) (Eq (HMod.hMod m 2) 0)","decl":"lemma succ_mod_two_eq_one_iff : (m + 1) % 2 = 1 ↔ m % 2 = 0 := by\n  simp [← Nat.even_iff, ← Nat.not_even_iff, parity_simps]\n\n"}
{"name":"Nat.two_not_dvd_two_mul_add_one","module":"Mathlib.Algebra.Group.Nat.Even","initialProofState":"n : Nat\n⊢ Not (Dvd.dvd 2 (HAdd.hAdd (HMul.hMul 2 n) 1))","decl":"lemma two_not_dvd_two_mul_add_one (n : ℕ) : ¬2 ∣ 2 * n + 1 := by simp [add_mod]\n\n"}
{"name":"Nat.two_not_dvd_two_mul_sub_one","module":"Mathlib.Algebra.Group.Nat.Even","initialProofState":"n : Nat\na✝ : LT.lt 0 n\n⊢ Not (Dvd.dvd 2 (HSub.hSub (HMul.hMul 2 n) 1))","decl":"lemma two_not_dvd_two_mul_sub_one : ∀ {n}, 0 < n → ¬2 ∣ 2 * n - 1\n  | n + 1, _ => two_not_dvd_two_mul_add_one n\n\n"}
{"name":"Nat.even_sub","module":"Mathlib.Algebra.Group.Nat.Even","initialProofState":"m n : Nat\nh : LE.le n m\n⊢ Iff (Even (HSub.hSub m n)) (Iff (Even m) (Even n))","decl":"@[parity_simps] lemma even_sub (h : n ≤ m) : Even (m - n) ↔ (Even m ↔ Even n) := by\n  conv_rhs => rw [← Nat.sub_add_cancel h, even_add]\n  by_cases h : Even n <;> simp [h]\n\n"}
{"name":"Nat.even_mul","module":"Mathlib.Algebra.Group.Nat.Even","initialProofState":"m n : Nat\n⊢ Iff (Even (HMul.hMul m n)) (Or (Even m) (Even n))","decl":"@[parity_simps] lemma even_mul : Even (m * n) ↔ Even m ∨ Even n := by\n  rcases mod_two_eq_zero_or_one m with h₁ | h₁ <;> rcases mod_two_eq_zero_or_one n with h₂ | h₂ <;>\n    simp [even_iff, h₁, h₂, Nat.mul_mod]\n\n"}
{"name":"Nat.even_pow","module":"Mathlib.Algebra.Group.Nat.Even","initialProofState":"m n : Nat\n⊢ Iff (Even (HPow.hPow m n)) (And (Even m) (Ne n 0))","decl":"/-- If `m` and `n` are natural numbers, then the natural number `m^n` is even\nif and only if `m` is even and `n` is positive. -/\n@[parity_simps] lemma even_pow : Even (m ^ n) ↔ Even m ∧ n ≠ 0 := by\n  induction n <;> simp +contextual [*, pow_succ', even_mul]\n\n"}
{"name":"Nat.even_pow'","module":"Mathlib.Algebra.Group.Nat.Even","initialProofState":"m n : Nat\nh : Ne n 0\n⊢ Iff (Even (HPow.hPow m n)) (Even m)","decl":"lemma even_pow' (h : n ≠ 0) : Even (m ^ n) ↔ Even m := even_pow.trans <| and_iff_left h\n\n"}
{"name":"Nat.even_mul_succ_self","module":"Mathlib.Algebra.Group.Nat.Even","initialProofState":"n : Nat\n⊢ Even (HMul.hMul n (HAdd.hAdd n 1))","decl":"lemma even_mul_succ_self (n : ℕ) : Even (n * (n + 1)) := by rw [even_mul, even_add_one]; exact em _\n\n"}
{"name":"Nat.even_mul_pred_self","module":"Mathlib.Algebra.Group.Nat.Even","initialProofState":"n : Nat\n⊢ Even (HMul.hMul n (HSub.hSub n 1))","decl":"lemma even_mul_pred_self : ∀ n : ℕ, Even (n * (n - 1))\n  | 0 => .zero\n  | (n + 1) => mul_comm (n + 1 - 1) (n + 1) ▸ even_mul_succ_self n\n\n"}
{"name":"Nat.two_mul_div_two_of_even","module":"Mathlib.Algebra.Group.Nat.Even","initialProofState":"n : Nat\na✝ : Even n\n⊢ Eq (HMul.hMul 2 (HDiv.hDiv n 2)) n","decl":"lemma two_mul_div_two_of_even : Even n → 2 * (n / 2) = n := fun h ↦\n  Nat.mul_div_cancel_left' ((even_iff_exists_two_nsmul _).1 h)\n\n"}
{"name":"Nat.div_two_mul_two_of_even","module":"Mathlib.Algebra.Group.Nat.Even","initialProofState":"n : Nat\na✝ : Even n\n⊢ Eq (HMul.hMul (HDiv.hDiv n 2) 2) n","decl":"lemma div_two_mul_two_of_even : Even n → n / 2 * 2 = n :=\n  fun h ↦ Nat.div_mul_cancel ((even_iff_exists_two_nsmul _).1 h)\n\n"}
{"name":"Nat.one_lt_of_ne_zero_of_even","module":"Mathlib.Algebra.Group.Nat.Even","initialProofState":"n : Nat\nh0 : Ne n 0\nhn : Even n\n⊢ LT.lt 1 n","decl":"theorem one_lt_of_ne_zero_of_even (h0 : n ≠ 0) (hn : Even n) : 1 < n := by\n  refine Nat.one_lt_iff_ne_zero_and_ne_one.mpr (And.intro h0 ?_)\n  intro h\n  rw [h] at hn\n  exact Nat.not_even_one hn\n\n"}
{"name":"Nat.add_one_lt_of_even","module":"Mathlib.Algebra.Group.Nat.Even","initialProofState":"m n : Nat\nhn : Even n\nhm : Even m\nhnm : LT.lt n m\n⊢ LT.lt (HAdd.hAdd n 1) m","decl":"theorem add_one_lt_of_even (hn : Even n) (hm : Even m) (hnm : n < m) :\n    n + 1 < m := by\n  rcases hn with ⟨n, rfl⟩\n  rcases hm with ⟨m, rfl⟩\n  omega\n\n-- Here are examples of how `parity_simps` can be used with `Nat`.\n"}
