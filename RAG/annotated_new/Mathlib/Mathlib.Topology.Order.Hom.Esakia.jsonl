{"name":"PseudoEpimorphism.exists_map_eq_of_map_le'","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nself : PseudoEpimorphism α β\na : α\nb : β\na✝ : LE.le (self.toFun a) b\n⊢ Exists fun c => And (LE.le a c) (Eq (self.toFun c) b)","decl":"/-- The type of pseudo-epimorphisms, aka p-morphisms, aka bounded maps, from `α` to `β`. -/\nstructure PseudoEpimorphism (α β : Type*) [Preorder α] [Preorder β] extends α →o β where\n  exists_map_eq_of_map_le' ⦃a : α⦄ ⦃b : β⦄ : toFun a ≤ b → ∃ c, a ≤ c ∧ toFun c = b\n\n"}
{"name":"PseudoEpimorphism.mk.sizeOf_spec","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoOrderHom : OrderHom α β\nexists_map_eq_of_map_le' : ∀ ⦃a : α⦄ ⦃b : β⦄, LE.le (toOrderHom.toFun a) b → Exists fun c => And (LE.le a c) (Eq (toOrderHom.toFun c) b)\n⊢ Eq (SizeOf.sizeOf { toOrderHom := toOrderHom, exists_map_eq_of_map_le' := exists_map_eq_of_map_le' }) (HAdd.hAdd 1 (SizeOf.sizeOf toOrderHom))","decl":"/-- The type of pseudo-epimorphisms, aka p-morphisms, aka bounded maps, from `α` to `β`. -/\nstructure PseudoEpimorphism (α β : Type*) [Preorder α] [Preorder β] extends α →o β where\n  exists_map_eq_of_map_le' ⦃a : α⦄ ⦃b : β⦄ : toFun a ≤ b → ∃ c, a ≤ c ∧ toFun c = b\n\n"}
{"name":"PseudoEpimorphism.mk.injEq","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ntoOrderHom✝ : OrderHom α β\nexists_map_eq_of_map_le'✝ : ∀ ⦃a : α⦄ ⦃b : β⦄, LE.le (toOrderHom✝.toFun a) b → Exists fun c => And (LE.le a c) (Eq (toOrderHom✝.toFun c) b)\ntoOrderHom : OrderHom α β\nexists_map_eq_of_map_le' : ∀ ⦃a : α⦄ ⦃b : β⦄, LE.le (toOrderHom.toFun a) b → Exists fun c => And (LE.le a c) (Eq (toOrderHom.toFun c) b)\n⊢ Eq (Eq { toOrderHom := toOrderHom✝, exists_map_eq_of_map_le' := exists_map_eq_of_map_le'✝ } { toOrderHom := toOrderHom, exists_map_eq_of_map_le' := exists_map_eq_of_map_le' }) (Eq toOrderHom✝ toOrderHom)","decl":"/-- The type of pseudo-epimorphisms, aka p-morphisms, aka bounded maps, from `α` to `β`. -/\nstructure PseudoEpimorphism (α β : Type*) [Preorder α] [Preorder β] extends α →o β where\n  exists_map_eq_of_map_le' ⦃a : α⦄ ⦃b : β⦄ : toFun a ≤ b → ∃ c, a ≤ c ∧ toFun c = b\n\n"}
{"name":"PseudoEpimorphism.mk.inj","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ntoOrderHom✝ : OrderHom α β\nexists_map_eq_of_map_le'✝ : ∀ ⦃a : α⦄ ⦃b : β⦄, LE.le (toOrderHom✝.toFun a) b → Exists fun c => And (LE.le a c) (Eq (toOrderHom✝.toFun c) b)\ntoOrderHom : OrderHom α β\nexists_map_eq_of_map_le' : ∀ ⦃a : α⦄ ⦃b : β⦄, LE.le (toOrderHom.toFun a) b → Exists fun c => And (LE.le a c) (Eq (toOrderHom.toFun c) b)\nx✝ : Eq { toOrderHom := toOrderHom✝, exists_map_eq_of_map_le' := exists_map_eq_of_map_le'✝ } { toOrderHom := toOrderHom, exists_map_eq_of_map_le' := exists_map_eq_of_map_le' }\n⊢ Eq toOrderHom✝ toOrderHom","decl":"/-- The type of pseudo-epimorphisms, aka p-morphisms, aka bounded maps, from `α` to `β`. -/\nstructure PseudoEpimorphism (α β : Type*) [Preorder α] [Preorder β] extends α →o β where\n  exists_map_eq_of_map_le' ⦃a : α⦄ ⦃b : β⦄ : toFun a ≤ b → ∃ c, a ≤ c ∧ toFun c = b\n\n"}
{"name":"EsakiaHom.mk.inj","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : TopologicalSpace α\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace β\ninst✝ : Preorder β\ntoContinuousOrderHom✝ : ContinuousOrderHom α β\nexists_map_eq_of_map_le'✝ : ∀ ⦃a : α⦄ ⦃b : β⦄, LE.le (toContinuousOrderHom✝.toFun a) b → Exists fun c => And (LE.le a c) (Eq (toContinuousOrderHom✝.toFun c) b)\ntoContinuousOrderHom : ContinuousOrderHom α β\nexists_map_eq_of_map_le' : ∀ ⦃a : α⦄ ⦃b : β⦄, LE.le (toContinuousOrderHom.toFun a) b → Exists fun c => And (LE.le a c) (Eq (toContinuousOrderHom.toFun c) b)\nx✝ : Eq { toContinuousOrderHom := toContinuousOrderHom✝, exists_map_eq_of_map_le' := exists_map_eq_of_map_le'✝ } { toContinuousOrderHom := toContinuousOrderHom, exists_map_eq_of_map_le' := exists_map_eq_of_map_le' }\n⊢ Eq toContinuousOrderHom✝ toContinuousOrderHom","decl":"/-- The type of Esakia morphisms, aka continuous pseudo-epimorphisms, from `α` to `β`. -/\nstructure EsakiaHom (α β : Type*) [TopologicalSpace α] [Preorder α] [TopologicalSpace β]\n  [Preorder β] extends α →Co β where\n  exists_map_eq_of_map_le' ⦃a : α⦄ ⦃b : β⦄ : toFun a ≤ b → ∃ c, a ≤ c ∧ toFun c = b\n\n"}
{"name":"EsakiaHom.mk.injEq","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : TopologicalSpace α\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace β\ninst✝ : Preorder β\ntoContinuousOrderHom✝ : ContinuousOrderHom α β\nexists_map_eq_of_map_le'✝ : ∀ ⦃a : α⦄ ⦃b : β⦄, LE.le (toContinuousOrderHom✝.toFun a) b → Exists fun c => And (LE.le a c) (Eq (toContinuousOrderHom✝.toFun c) b)\ntoContinuousOrderHom : ContinuousOrderHom α β\nexists_map_eq_of_map_le' : ∀ ⦃a : α⦄ ⦃b : β⦄, LE.le (toContinuousOrderHom.toFun a) b → Exists fun c => And (LE.le a c) (Eq (toContinuousOrderHom.toFun c) b)\n⊢ Eq (Eq { toContinuousOrderHom := toContinuousOrderHom✝, exists_map_eq_of_map_le' := exists_map_eq_of_map_le'✝ } { toContinuousOrderHom := toContinuousOrderHom, exists_map_eq_of_map_le' := exists_map_eq_of_map_le' }) (Eq toContinuousOrderHom✝ toContinuousOrderHom)","decl":"/-- The type of Esakia morphisms, aka continuous pseudo-epimorphisms, from `α` to `β`. -/\nstructure EsakiaHom (α β : Type*) [TopologicalSpace α] [Preorder α] [TopologicalSpace β]\n  [Preorder β] extends α →Co β where\n  exists_map_eq_of_map_le' ⦃a : α⦄ ⦃b : β⦄ : toFun a ≤ b → ∃ c, a ≤ c ∧ toFun c = b\n\n"}
{"name":"EsakiaHom.mk.sizeOf_spec","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : Preorder α\ninst✝³ : TopologicalSpace β\ninst✝² : Preorder β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoContinuousOrderHom : ContinuousOrderHom α β\nexists_map_eq_of_map_le' : ∀ ⦃a : α⦄ ⦃b : β⦄, LE.le (toContinuousOrderHom.toFun a) b → Exists fun c => And (LE.le a c) (Eq (toContinuousOrderHom.toFun c) b)\n⊢ Eq (SizeOf.sizeOf { toContinuousOrderHom := toContinuousOrderHom, exists_map_eq_of_map_le' := exists_map_eq_of_map_le' }) (HAdd.hAdd 1 (SizeOf.sizeOf toContinuousOrderHom))","decl":"/-- The type of Esakia morphisms, aka continuous pseudo-epimorphisms, from `α` to `β`. -/\nstructure EsakiaHom (α β : Type*) [TopologicalSpace α] [Preorder α] [TopologicalSpace β]\n  [Preorder β] extends α →Co β where\n  exists_map_eq_of_map_le' ⦃a : α⦄ ⦃b : β⦄ : toFun a ≤ b → ∃ c, a ≤ c ∧ toFun c = b\n\n"}
{"name":"EsakiaHom.exists_map_eq_of_map_le'","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : TopologicalSpace α\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace β\ninst✝ : Preorder β\nself : EsakiaHom α β\na : α\nb : β\na✝ : LE.le (self.toFun a) b\n⊢ Exists fun c => And (LE.le a c) (Eq (self.toFun c) b)","decl":"/-- The type of Esakia morphisms, aka continuous pseudo-epimorphisms, from `α` to `β`. -/\nstructure EsakiaHom (α β : Type*) [TopologicalSpace α] [Preorder α] [TopologicalSpace β]\n  [Preorder β] extends α →Co β where\n  exists_map_eq_of_map_le' ⦃a : α⦄ ⦃b : β⦄ : toFun a ≤ b → ∃ c, a ≤ c ∧ toFun c = b\n\n"}
{"name":"PseudoEpimorphismClass.toRelHomClass","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"F : Type u_6\nα : outParam (Type u_7)\nβ : outParam (Type u_8)\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : FunLike F α β\nself : PseudoEpimorphismClass F α β\n⊢ RelHomClass F (fun x1 x2 => LE.le x1 x2) fun x1 x2 => LE.le x1 x2","decl":"/-- `PseudoEpimorphismClass F α β` states that `F` is a type of `⊔`-preserving morphisms.\n\nYou should extend this class when you extend `PseudoEpimorphism`. -/\nclass PseudoEpimorphismClass (F : Type*) (α β : outParam Type*)\n    [Preorder α] [Preorder β] [FunLike F α β]\n    extends RelHomClass F ((· ≤ ·) : α → α → Prop) ((· ≤ ·) : β → β → Prop) : Prop where\n  exists_map_eq_of_map_le (f : F) ⦃a : α⦄ ⦃b : β⦄ : f a ≤ b → ∃ c, a ≤ c ∧ f c = b\n\n"}
{"name":"PseudoEpimorphismClass.exists_map_eq_of_map_le","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"F : Type u_6\nα : outParam (Type u_7)\nβ : outParam (Type u_8)\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : FunLike F α β\nself : PseudoEpimorphismClass F α β\nf : F\na : α\nb : β\na✝ : LE.le (f a) b\n⊢ Exists fun c => And (LE.le a c) (Eq (f c) b)","decl":"/-- `PseudoEpimorphismClass F α β` states that `F` is a type of `⊔`-preserving morphisms.\n\nYou should extend this class when you extend `PseudoEpimorphism`. -/\nclass PseudoEpimorphismClass (F : Type*) (α β : outParam Type*)\n    [Preorder α] [Preorder β] [FunLike F α β]\n    extends RelHomClass F ((· ≤ ·) : α → α → Prop) ((· ≤ ·) : β → β → Prop) : Prop where\n  exists_map_eq_of_map_le (f : F) ⦃a : α⦄ ⦃b : β⦄ : f a ≤ b → ∃ c, a ≤ c ∧ f c = b\n\n"}
{"name":"EsakiaHomClass.toContinuousOrderHomClass","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"F : Type u_6\nα : outParam (Type u_7)\nβ : outParam (Type u_8)\ninst✝⁴ : TopologicalSpace α\ninst✝³ : Preorder α\ninst✝² : TopologicalSpace β\ninst✝¹ : Preorder β\ninst✝ : FunLike F α β\nself : EsakiaHomClass F α β\n⊢ ContinuousOrderHomClass F α β","decl":"/-- `EsakiaHomClass F α β` states that `F` is a type of lattice morphisms.\n\nYou should extend this class when you extend `EsakiaHom`. -/\nclass EsakiaHomClass (F : Type*) (α β : outParam Type*) [TopologicalSpace α] [Preorder α]\n    [TopologicalSpace β] [Preorder β] [FunLike F α β]\n    extends ContinuousOrderHomClass F α β : Prop where\n  exists_map_eq_of_map_le (f : F) ⦃a : α⦄ ⦃b : β⦄ : f a ≤ b → ∃ c, a ≤ c ∧ f c = b\n\n"}
{"name":"EsakiaHomClass.exists_map_eq_of_map_le","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"F : Type u_6\nα : outParam (Type u_7)\nβ : outParam (Type u_8)\ninst✝⁴ : TopologicalSpace α\ninst✝³ : Preorder α\ninst✝² : TopologicalSpace β\ninst✝¹ : Preorder β\ninst✝ : FunLike F α β\nself : EsakiaHomClass F α β\nf : F\na : α\nb : β\na✝ : LE.le (f a) b\n⊢ Exists fun c => And (LE.le a c) (Eq (f c) b)","decl":"/-- `EsakiaHomClass F α β` states that `F` is a type of lattice morphisms.\n\nYou should extend this class when you extend `EsakiaHom`. -/\nclass EsakiaHomClass (F : Type*) (α β : outParam Type*) [TopologicalSpace α] [Preorder α]\n    [TopologicalSpace β] [Preorder β] [FunLike F α β]\n    extends ContinuousOrderHomClass F α β : Prop where\n  exists_map_eq_of_map_le (f : F) ⦃a : α⦄ ⦃b : β⦄ : f a ≤ b → ∃ c, a ≤ c ∧ f c = b\n\n"}
{"name":"PseudoEpimorphismClass.toTopHomClass","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : FunLike F α β\ninst✝⁴ : PartialOrder α\ninst✝³ : OrderTop α\ninst✝² : Preorder β\ninst✝¹ : OrderTop β\ninst✝ : PseudoEpimorphismClass F α β\n⊢ TopHomClass F α β","decl":"instance (priority := 100) PseudoEpimorphismClass.toTopHomClass [PartialOrder α] [OrderTop α]\n    [Preorder β] [OrderTop β] [PseudoEpimorphismClass F α β] : TopHomClass F α β where\n  map_top f := by\n    let ⟨b, h⟩ := exists_map_eq_of_map_le f (@le_top _ _ _ <| f ⊤)\n    rw [← top_le_iff.1 h.1, h.2]\n\n-- See note [lower instance priority]\n"}
{"name":"EsakiaHomClass.toPseudoEpimorphismClass","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : FunLike F α β\ninst✝⁴ : TopologicalSpace α\ninst✝³ : Preorder α\ninst✝² : TopologicalSpace β\ninst✝¹ : Preorder β\ninst✝ : EsakiaHomClass F α β\n⊢ PseudoEpimorphismClass F α β","decl":"instance (priority := 100) EsakiaHomClass.toPseudoEpimorphismClass [TopologicalSpace α] [Preorder α]\n    [TopologicalSpace β] [Preorder β] [EsakiaHomClass F α β] : PseudoEpimorphismClass F α β :=\n  { ‹EsakiaHomClass F α β› with\n    map_rel := ContinuousOrderHomClass.map_monotone }\n\n"}
{"name":"OrderIsoClass.toPseudoEpimorphismClass","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : EquivLike F α β\ninst✝ : OrderIsoClass F α β\n⊢ PseudoEpimorphismClass F α β","decl":"instance (priority := 100) OrderIsoClass.toPseudoEpimorphismClass [Preorder α] [Preorder β]\n    [EquivLike F α β] [OrderIsoClass F α β] : PseudoEpimorphismClass F α β where\n  exists_map_eq_of_map_le f _a b h :=\n    ⟨EquivLike.inv f b, (le_map_inv_iff f).2 h, EquivLike.right_inv _ _⟩\n\n"}
{"name":"PseudoEpimorphism.instPseudoEpimorphismClass","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\n⊢ PseudoEpimorphismClass (PseudoEpimorphism α β) α β","decl":"instance : PseudoEpimorphismClass (PseudoEpimorphism α β) α β where\n  map_rel f _ _ h := f.monotone' h\n  exists_map_eq_of_map_le := PseudoEpimorphism.exists_map_eq_of_map_le'\n\n"}
{"name":"PseudoEpimorphism.toOrderHom_eq_coe","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : PseudoEpimorphism α β\n⊢ Eq ⇑f.toOrderHom ⇑f","decl":"@[simp]\ntheorem toOrderHom_eq_coe (f : PseudoEpimorphism α β) : ⇑f.toOrderHom = f := rfl\n\n"}
{"name":"PseudoEpimorphism.toFun_eq_coe","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : PseudoEpimorphism α β\n⊢ Eq f.toFun ⇑f","decl":"theorem toFun_eq_coe {f : PseudoEpimorphism α β} : f.toFun = (f : α → β) := rfl\n\n"}
{"name":"PseudoEpimorphism.ext_iff","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf g : PseudoEpimorphism α β\n⊢ Iff (Eq f g) (∀ (a : α), Eq (f a) (g a))","decl":"@[ext]\ntheorem ext {f g : PseudoEpimorphism α β} (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"PseudoEpimorphism.ext","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf g : PseudoEpimorphism α β\nh : ∀ (a : α), Eq (f a) (g a)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : PseudoEpimorphism α β} (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"PseudoEpimorphism.coe_copy","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : PseudoEpimorphism α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"@[simp]\ntheorem coe_copy (f : PseudoEpimorphism α β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' := rfl\n\n"}
{"name":"PseudoEpimorphism.copy_eq","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : PseudoEpimorphism α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) f","decl":"theorem copy_eq (f : PseudoEpimorphism α β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"PseudoEpimorphism.coe_id","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\ninst✝ : Preorder α\n⊢ Eq (⇑(PseudoEpimorphism.id α)) id","decl":"@[simp, norm_cast]\ntheorem coe_id : ⇑(PseudoEpimorphism.id α) = id := rfl\n\n"}
{"name":"PseudoEpimorphism.coe_id_orderHom","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\ninst✝ : Preorder α\n⊢ Eq (↑(PseudoEpimorphism.id α)) OrderHom.id","decl":"@[simp, norm_cast]\ntheorem coe_id_orderHom : (PseudoEpimorphism.id α : α →o α) = OrderHom.id := rfl\n\n"}
{"name":"PseudoEpimorphism.id_apply","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na : α\n⊢ Eq ((PseudoEpimorphism.id α) a) a","decl":"@[simp]\ntheorem id_apply (a : α) : PseudoEpimorphism.id α a = a := rfl\n\n"}
{"name":"PseudoEpimorphism.coe_comp","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : PseudoEpimorphism β γ\nf : PseudoEpimorphism α β\n⊢ Eq (⇑(g.comp f)) (Function.comp ⇑g ⇑f)","decl":"@[simp]\ntheorem coe_comp (g : PseudoEpimorphism β γ) (f : PseudoEpimorphism α β) :\n    (g.comp f : α → γ) = g ∘ f := rfl\n\n"}
{"name":"PseudoEpimorphism.coe_comp_orderHom","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : PseudoEpimorphism β γ\nf : PseudoEpimorphism α β\n⊢ Eq (↑(g.comp f)) ((↑g).comp ↑f)","decl":"@[simp]\ntheorem coe_comp_orderHom (g : PseudoEpimorphism β γ) (f : PseudoEpimorphism α β) :\n    (g.comp f : α →o γ) = (g : β →o γ).comp f := rfl\n\n"}
{"name":"PseudoEpimorphism.comp_apply","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : PseudoEpimorphism β γ\nf : PseudoEpimorphism α β\na : α\n⊢ Eq ((g.comp f) a) (g (f a))","decl":"@[simp]\ntheorem comp_apply (g : PseudoEpimorphism β γ) (f : PseudoEpimorphism α β) (a : α) :\n    (g.comp f) a = g (f a) := rfl\n\n"}
{"name":"PseudoEpimorphism.comp_assoc","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nδ : Type u_5\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Preorder γ\ninst✝ : Preorder δ\nh : PseudoEpimorphism γ δ\ng : PseudoEpimorphism β γ\nf : PseudoEpimorphism α β\n⊢ Eq ((h.comp g).comp f) (h.comp (g.comp f))","decl":"@[simp]\ntheorem comp_assoc (h : PseudoEpimorphism γ δ) (g : PseudoEpimorphism β γ)\n    (f : PseudoEpimorphism α β) : (h.comp g).comp f = h.comp (g.comp f) := rfl\n\n"}
{"name":"PseudoEpimorphism.comp_id","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : PseudoEpimorphism α β\n⊢ Eq (f.comp (PseudoEpimorphism.id α)) f","decl":"@[simp]\ntheorem comp_id (f : PseudoEpimorphism α β) : f.comp (PseudoEpimorphism.id α) = f :=\n  ext fun _ => rfl\n\n"}
{"name":"PseudoEpimorphism.id_comp","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : PseudoEpimorphism α β\n⊢ Eq ((PseudoEpimorphism.id β).comp f) f","decl":"@[simp]\ntheorem id_comp (f : PseudoEpimorphism α β) : (PseudoEpimorphism.id β).comp f = f :=\n  ext fun _ => rfl\n\n"}
{"name":"PseudoEpimorphism.cancel_right","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng₁ g₂ : PseudoEpimorphism β γ\nf : PseudoEpimorphism α β\nhf : Function.Surjective ⇑f\n⊢ Iff (Eq (g₁.comp f) (g₂.comp f)) (Eq g₁ g₂)","decl":"@[simp]\ntheorem cancel_right {g₁ g₂ : PseudoEpimorphism β γ} {f : PseudoEpimorphism α β}\n    (hf : Surjective f) : g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=\n  ⟨fun h => ext <| hf.forall.2 <| DFunLike.ext_iff.1 h, congr_arg (comp · f)⟩\n\n"}
{"name":"PseudoEpimorphism.cancel_left","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : PseudoEpimorphism β γ\nf₁ f₂ : PseudoEpimorphism α β\nhg : Function.Injective ⇑g\n⊢ Iff (Eq (g.comp f₁) (g.comp f₂)) (Eq f₁ f₂)","decl":"@[simp]\ntheorem cancel_left {g : PseudoEpimorphism β γ} {f₁ f₂ : PseudoEpimorphism α β} (hg : Injective g) :\n    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=\n  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩\n\n"}
{"name":"EsakiaHom.instEsakiaHomClass","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace β\ninst✝ : Preorder β\n⊢ EsakiaHomClass (EsakiaHom α β) α β","decl":"instance : EsakiaHomClass (EsakiaHom α β) α β where\n  map_monotone f := f.monotone'\n  map_continuous f := f.continuous_toFun\n  exists_map_eq_of_map_le f := f.exists_map_eq_of_map_le'\n\n"}
{"name":"EsakiaHom.toContinuousOrderHom_coe","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace β\ninst✝ : Preorder β\nf : EsakiaHom α β\n⊢ Eq ⇑f.toContinuousOrderHom ⇑f","decl":"@[simp]\ntheorem toContinuousOrderHom_coe {f : EsakiaHom α β} :\n    f.toContinuousOrderHom = (f : α → β) := rfl\n\n"}
{"name":"EsakiaHom.toFun_eq_coe","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace β\ninst✝ : Preorder β\nf : EsakiaHom α β\n⊢ Eq f.toFun ⇑f","decl":"theorem toFun_eq_coe {f : EsakiaHom α β} : f.toFun = (f : α → β) := rfl\n\n"}
{"name":"EsakiaHom.ext_iff","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace β\ninst✝ : Preorder β\nf g : EsakiaHom α β\n⊢ Iff (Eq f g) (∀ (a : α), Eq (f a) (g a))","decl":"@[ext]\ntheorem ext {f g : EsakiaHom α β} (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"EsakiaHom.ext","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace β\ninst✝ : Preorder β\nf g : EsakiaHom α β\nh : ∀ (a : α), Eq (f a) (g a)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : EsakiaHom α β} (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"EsakiaHom.coe_copy","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace β\ninst✝ : Preorder β\nf : EsakiaHom α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"@[simp]\ntheorem coe_copy (f : EsakiaHom α β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' := rfl\n\n"}
{"name":"EsakiaHom.copy_eq","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace β\ninst✝ : Preorder β\nf : EsakiaHom α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) f","decl":"theorem copy_eq (f : EsakiaHom α β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"EsakiaHom.coe_id","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : Preorder α\n⊢ Eq (⇑(EsakiaHom.id α)) id","decl":"@[simp, norm_cast]\ntheorem coe_id : ⇑(EsakiaHom.id α) = id := rfl\n\n"}
{"name":"EsakiaHom.coe_id_pseudoEpimorphism","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : Preorder α\n⊢ Eq { toOrderHom := ↑(EsakiaHom.id α), exists_map_eq_of_map_le' := ⋯ } (PseudoEpimorphism.id α)","decl":"@[simp, norm_cast]\ntheorem coe_id_pseudoEpimorphism :\n    (EsakiaHom.id α : PseudoEpimorphism α α) = PseudoEpimorphism.id α := rfl\n\n"}
{"name":"EsakiaHom.id_apply","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : Preorder α\na : α\n⊢ Eq ((EsakiaHom.id α) a) a","decl":"@[simp]\ntheorem id_apply (a : α) : EsakiaHom.id α a = a := rfl\n\n"}
{"name":"EsakiaHom.coe_id_continuousOrderHom","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : Preorder α\n⊢ Eq (↑(EsakiaHom.id α)) (ContinuousOrderHom.id α)","decl":"@[simp, norm_cast]\ntheorem coe_id_continuousOrderHom : (EsakiaHom.id α : α →Co α) = ContinuousOrderHom.id α := rfl\n\n"}
{"name":"EsakiaHom.coe_comp_continuousOrderHom","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : Preorder α\ninst✝³ : TopologicalSpace β\ninst✝² : Preorder β\ninst✝¹ : TopologicalSpace γ\ninst✝ : Preorder γ\ng : EsakiaHom β γ\nf : EsakiaHom α β\n⊢ Eq (↑(g.comp f)) ((↑g).comp ↑f)","decl":"@[simp]\ntheorem coe_comp_continuousOrderHom (g : EsakiaHom β γ) (f : EsakiaHom α β) :\n    (g.comp f : α →Co γ) = (g : β →Co γ).comp f := rfl\n\n"}
{"name":"EsakiaHom.coe_comp_pseudoEpimorphism","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : Preorder α\ninst✝³ : TopologicalSpace β\ninst✝² : Preorder β\ninst✝¹ : TopologicalSpace γ\ninst✝ : Preorder γ\ng : EsakiaHom β γ\nf : EsakiaHom α β\n⊢ Eq { toOrderHom := ↑(g.comp f), exists_map_eq_of_map_le' := ⋯ } ({ toOrderHom := ↑g, exists_map_eq_of_map_le' := ⋯ }.comp { toOrderHom := ↑f, exists_map_eq_of_map_le' := ⋯ })","decl":"@[simp]\ntheorem coe_comp_pseudoEpimorphism (g : EsakiaHom β γ) (f : EsakiaHom α β) :\n    (g.comp f : PseudoEpimorphism α γ) = (g : PseudoEpimorphism β γ).comp f := rfl\n\n"}
{"name":"EsakiaHom.coe_comp","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : Preorder α\ninst✝³ : TopologicalSpace β\ninst✝² : Preorder β\ninst✝¹ : TopologicalSpace γ\ninst✝ : Preorder γ\ng : EsakiaHom β γ\nf : EsakiaHom α β\n⊢ Eq (⇑(g.comp f)) (Function.comp ⇑g ⇑f)","decl":"@[simp]\ntheorem coe_comp (g : EsakiaHom β γ) (f : EsakiaHom α β) : (g.comp f : α → γ) = g ∘ f := rfl\n\n"}
{"name":"EsakiaHom.comp_apply","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : Preorder α\ninst✝³ : TopologicalSpace β\ninst✝² : Preorder β\ninst✝¹ : TopologicalSpace γ\ninst✝ : Preorder γ\ng : EsakiaHom β γ\nf : EsakiaHom α β\na : α\n⊢ Eq ((g.comp f) a) (g (f a))","decl":"@[simp]\ntheorem comp_apply (g : EsakiaHom β γ) (f : EsakiaHom α β) (a : α) : (g.comp f) a = g (f a) := rfl\n\n"}
{"name":"EsakiaHom.comp_assoc","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nδ : Type u_5\ninst✝⁷ : TopologicalSpace α\ninst✝⁶ : Preorder α\ninst✝⁵ : TopologicalSpace β\ninst✝⁴ : Preorder β\ninst✝³ : TopologicalSpace γ\ninst✝² : Preorder γ\ninst✝¹ : TopologicalSpace δ\ninst✝ : Preorder δ\nh : EsakiaHom γ δ\ng : EsakiaHom β γ\nf : EsakiaHom α β\n⊢ Eq ((h.comp g).comp f) (h.comp (g.comp f))","decl":"@[simp]\ntheorem comp_assoc (h : EsakiaHom γ δ) (g : EsakiaHom β γ) (f : EsakiaHom α β) :\n    (h.comp g).comp f = h.comp (g.comp f) := rfl\n\n"}
{"name":"EsakiaHom.comp_id","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace β\ninst✝ : Preorder β\nf : EsakiaHom α β\n⊢ Eq (f.comp (EsakiaHom.id α)) f","decl":"@[simp]\ntheorem comp_id (f : EsakiaHom α β) : f.comp (EsakiaHom.id α) = f :=\n  ext fun _ => rfl\n\n"}
{"name":"EsakiaHom.id_comp","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace β\ninst✝ : Preorder β\nf : EsakiaHom α β\n⊢ Eq ((EsakiaHom.id β).comp f) f","decl":"@[simp]\ntheorem id_comp (f : EsakiaHom α β) : (EsakiaHom.id β).comp f = f :=\n  ext fun _ => rfl\n\n"}
{"name":"EsakiaHom.cancel_right","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : Preorder α\ninst✝³ : TopologicalSpace β\ninst✝² : Preorder β\ninst✝¹ : TopologicalSpace γ\ninst✝ : Preorder γ\ng₁ g₂ : EsakiaHom β γ\nf : EsakiaHom α β\nhf : Function.Surjective ⇑f\n⊢ Iff (Eq (g₁.comp f) (g₂.comp f)) (Eq g₁ g₂)","decl":"@[simp]\ntheorem cancel_right {g₁ g₂ : EsakiaHom β γ} {f : EsakiaHom α β} (hf : Surjective f) :\n    g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=\n  ⟨fun h => ext <| hf.forall.2 <| DFunLike.ext_iff.1 h, congr_arg (comp · f)⟩\n\n"}
{"name":"EsakiaHom.cancel_left","module":"Mathlib.Topology.Order.Hom.Esakia","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : Preorder α\ninst✝³ : TopologicalSpace β\ninst✝² : Preorder β\ninst✝¹ : TopologicalSpace γ\ninst✝ : Preorder γ\ng : EsakiaHom β γ\nf₁ f₂ : EsakiaHom α β\nhg : Function.Injective ⇑g\n⊢ Iff (Eq (g.comp f₁) (g.comp f₂)) (Eq f₁ f₂)","decl":"@[simp]\ntheorem cancel_left {g : EsakiaHom β γ} {f₁ f₂ : EsakiaHom α β} (hg : Injective g) :\n    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=\n  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩\n\n"}
