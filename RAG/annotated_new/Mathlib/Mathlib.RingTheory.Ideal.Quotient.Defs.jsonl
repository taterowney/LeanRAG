{"name":"Ideal.Quotient.ringHom_ext","module":"Mathlib.RingTheory.Ideal.Quotient.Defs","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nI : Ideal R\nS : Type v\ninst✝ : NonAssocSemiring S\nf g : RingHom (HasQuotient.Quotient R I) S\nh : Eq (f.comp (Ideal.Quotient.mk I)) (g.comp (Ideal.Quotient.mk I))\n⊢ Eq f g","decl":"/-- Two `RingHom`s from the quotient by an ideal are equal if their\ncompositions with `Ideal.Quotient.mk'` are equal.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext 1100]\ntheorem ringHom_ext [NonAssocSemiring S] ⦃f g : R ⧸ I →+* S⦄ (h : f.comp (mk I) = g.comp (mk I)) :\n    f = g :=\n  RingHom.ext fun x => Quotient.inductionOn' x <| (RingHom.congr_fun h :)\n\n"}
{"name":"Ideal.Quotient.ringHom_ext_iff","module":"Mathlib.RingTheory.Ideal.Quotient.Defs","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nI : Ideal R\nS : Type v\ninst✝ : NonAssocSemiring S\nf g : RingHom (HasQuotient.Quotient R I) S\n⊢ Iff (Eq f g) (Eq (f.comp (Ideal.Quotient.mk I)) (g.comp (Ideal.Quotient.mk I)))","decl":"/-- Two `RingHom`s from the quotient by an ideal are equal if their\ncompositions with `Ideal.Quotient.mk'` are equal.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext 1100]\ntheorem ringHom_ext [NonAssocSemiring S] ⦃f g : R ⧸ I →+* S⦄ (h : f.comp (mk I) = g.comp (mk I)) :\n    f = g :=\n  RingHom.ext fun x => Quotient.inductionOn' x <| (RingHom.congr_fun h :)\n\n"}
{"name":"Ideal.Quotient.eq","module":"Mathlib.RingTheory.Ideal.Quotient.Defs","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nx y : R\n⊢ Iff (Eq ((Ideal.Quotient.mk I) x) ((Ideal.Quotient.mk I) y)) (Membership.mem I (HSub.hSub x y))","decl":"protected theorem eq : mk I x = mk I y ↔ x - y ∈ I :=\n  Submodule.Quotient.eq I\n\n"}
{"name":"Ideal.Quotient.mk_eq_mk","module":"Mathlib.RingTheory.Ideal.Quotient.Defs","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nx : R\n⊢ Eq (Submodule.Quotient.mk x) ((Ideal.Quotient.mk I) x)","decl":"@[simp]\ntheorem mk_eq_mk (x : R) : (Submodule.Quotient.mk x : R ⧸ I) = mk I x := rfl\n\n"}
{"name":"Ideal.Quotient.eq_zero_iff_mem","module":"Mathlib.RingTheory.Ideal.Quotient.Defs","initialProofState":"R : Type u\ninst✝ : CommRing R\na : R\nI : Ideal R\n⊢ Iff (Eq ((Ideal.Quotient.mk I) a) 0) (Membership.mem I a)","decl":"theorem eq_zero_iff_mem {I : Ideal R} : mk I a = 0 ↔ a ∈ I :=\n  Submodule.Quotient.mk_eq_zero _\n\n"}
{"name":"Ideal.Quotient.mk_eq_mk_iff_sub_mem","module":"Mathlib.RingTheory.Ideal.Quotient.Defs","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nx y : R\n⊢ Iff (Eq ((Ideal.Quotient.mk I) x) ((Ideal.Quotient.mk I) y)) (Membership.mem I (HSub.hSub x y))","decl":"theorem mk_eq_mk_iff_sub_mem (x y : R) : mk I x = mk I y ↔ x - y ∈ I := by\n  rw [← eq_zero_iff_mem, map_sub, sub_eq_zero]\n\n"}
{"name":"Ideal.Quotient.mk_surjective","module":"Mathlib.RingTheory.Ideal.Quotient.Defs","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Function.Surjective ⇑(Ideal.Quotient.mk I)","decl":"theorem mk_surjective : Function.Surjective (mk I) := fun y =>\n  Quotient.inductionOn' y fun x => Exists.intro x rfl\n\n"}
{"name":"Ideal.Quotient.instRingHomSurjectiveQuotientMk","module":"Mathlib.RingTheory.Ideal.Quotient.Defs","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ RingHomSurjective (Ideal.Quotient.mk I)","decl":"instance : RingHomSurjective (mk I) :=\n  ⟨mk_surjective⟩\n\n"}
{"name":"Ideal.Quotient.quotient_ring_saturate","module":"Mathlib.RingTheory.Ideal.Quotient.Defs","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\ns : Set R\n⊢ Eq (Set.preimage (⇑(Ideal.Quotient.mk I)) (Set.image (⇑(Ideal.Quotient.mk I)) s)) (Set.iUnion fun x => Set.image (fun y => HAdd.hAdd (↑x) y) s)","decl":"/-- If `I` is an ideal of a commutative ring `R`, if `q : R → R/I` is the quotient map, and if\n`s ⊆ R` is a subset, then `q⁻¹(q(s)) = ⋃ᵢ(i + s)`, the union running over all `i ∈ I`. -/\ntheorem quotient_ring_saturate (I : Ideal R) (s : Set R) :\n    mk I ⁻¹' (mk I '' s) = ⋃ x : I, (fun y => x.1 + y) '' s := by\n  ext x\n  simp only [mem_preimage, mem_image, mem_iUnion, Ideal.Quotient.eq]\n  exact\n    ⟨fun ⟨a, a_in, h⟩ => ⟨⟨_, I.neg_mem h⟩, a, a_in, by simp⟩, fun ⟨⟨i, hi⟩, a, ha, Eq⟩ =>\n      ⟨a, ha, by rw [← Eq, sub_add_eq_sub_sub_swap, sub_self, zero_sub]; exact I.neg_mem hi⟩⟩\n\n"}
{"name":"Ideal.Quotient.lift_mk","module":"Mathlib.RingTheory.Ideal.Quotient.Defs","initialProofState":"R : Type u\ninst✝¹ : CommRing R\na : R\nS : Type v\ninst✝ : Semiring S\nI : Ideal R\nf : RingHom R S\nH : ∀ (a : R), Membership.mem I a → Eq (f a) 0\n⊢ Eq ((Ideal.Quotient.lift I f H) ((Ideal.Quotient.mk I) a)) (f a)","decl":"@[simp]\ntheorem lift_mk (I : Ideal R) (f : R →+* S) (H : ∀ a : R, a ∈ I → f a = 0) :\n    lift I f H (mk I a) = f a :=\n  rfl\n\n"}
{"name":"Ideal.Quotient.lift_surjective_of_surjective","module":"Mathlib.RingTheory.Ideal.Quotient.Defs","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nS : Type v\ninst✝ : Semiring S\nI : Ideal R\nf : RingHom R S\nH : ∀ (a : R), Membership.mem I a → Eq (f a) 0\nhf : Function.Surjective ⇑f\n⊢ Function.Surjective ⇑(Ideal.Quotient.lift I f H)","decl":"theorem lift_surjective_of_surjective (I : Ideal R) {f : R →+* S} (H : ∀ a : R, a ∈ I → f a = 0)\n    (hf : Function.Surjective f) : Function.Surjective (Ideal.Quotient.lift I f H) := by\n  intro y\n  obtain ⟨x, rfl⟩ := hf y\n  use Ideal.Quotient.mk I x\n  simp only [Ideal.Quotient.lift_mk]\n\n"}
{"name":"Ideal.Quotient.factor_mk","module":"Mathlib.RingTheory.Ideal.Quotient.Defs","initialProofState":"R : Type u\ninst✝ : CommRing R\nS T : Ideal R\nH : LE.le S T\nx : R\n⊢ Eq ((Ideal.Quotient.factor S T H) ((Ideal.Quotient.mk S) x)) ((Ideal.Quotient.mk T) x)","decl":"@[simp]\ntheorem factor_mk (S T : Ideal R) (H : S ≤ T) (x : R) : factor S T H (mk S x) = mk T x :=\n  rfl\n\n"}
{"name":"Ideal.Quotient.factor_comp_mk","module":"Mathlib.RingTheory.Ideal.Quotient.Defs","initialProofState":"R : Type u\ninst✝ : CommRing R\nS T : Ideal R\nH : LE.le S T\n⊢ Eq ((Ideal.Quotient.factor S T H).comp (Ideal.Quotient.mk S)) (Ideal.Quotient.mk T)","decl":"@[simp]\ntheorem factor_comp_mk (S T : Ideal R) (H : S ≤ T) : (factor S T H).comp (mk S) = mk T := by\n  ext x\n  rw [RingHom.comp_apply, factor_mk]\n\n"}
{"name":"Ideal.quotEquivOfEq_mk","module":"Mathlib.RingTheory.Ideal.Quotient.Defs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI J : Ideal R\nh : Eq I J\nx : R\n⊢ Eq ((Ideal.quotEquivOfEq h) ((Ideal.Quotient.mk I) x)) ((Ideal.Quotient.mk J) x)","decl":"@[simp]\ntheorem quotEquivOfEq_mk {R : Type*} [CommRing R] {I J : Ideal R} (h : I = J) (x : R) :\n    quotEquivOfEq h (Ideal.Quotient.mk I x) = Ideal.Quotient.mk J x :=\n  rfl\n\n"}
{"name":"Ideal.quotEquivOfEq_symm","module":"Mathlib.RingTheory.Ideal.Quotient.Defs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI J : Ideal R\nh : Eq I J\n⊢ Eq (Ideal.quotEquivOfEq h).symm (Ideal.quotEquivOfEq ⋯)","decl":"@[simp]\ntheorem quotEquivOfEq_symm {R : Type*} [CommRing R] {I J : Ideal R} (h : I = J) :\n    (Ideal.quotEquivOfEq h).symm = Ideal.quotEquivOfEq h.symm := by ext; rfl\n\n"}
