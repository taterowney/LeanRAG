{"name":"Matroid.circuit_def","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC : Set α\n⊢ Iff (M.Circuit C) (Minimal M.Dep C)","decl":"lemma circuit_def : M.Circuit C ↔ Minimal M.Dep C := Iff.rfl\n\n"}
{"name":"Matroid.Circuit.dep","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC : Set α\nhC : M.Circuit C\n⊢ M.Dep C","decl":"lemma Circuit.dep (hC : M.Circuit C) : M.Dep C :=\n  hC.prop\n\n"}
{"name":"Matroid.Circuit.not_indep","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC : Set α\nhC : M.Circuit C\n⊢ Not (M.Indep C)","decl":"lemma Circuit.not_indep (hC : M.Circuit C) : ¬ M.Indep C :=\n  hC.dep.not_indep\n\n"}
{"name":"Matroid.Circuit.minimal","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC : Set α\nhC : M.Circuit C\n⊢ Minimal M.Dep C","decl":"lemma Circuit.minimal (hC : M.Circuit C) : Minimal M.Dep C :=\n  hC\n\n"}
{"name":"Matroid.Circuit.subset_ground","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC : Set α\nhC : M.Circuit C\n⊢ HasSubset.Subset C M.E","decl":"@[aesop unsafe 20% (rule_sets := [Matroid])]\nlemma Circuit.subset_ground (hC : M.Circuit C) : C ⊆ M.E :=\n  hC.dep.subset_ground\n\n"}
{"name":"Matroid.Circuit.nonempty","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC : Set α\nhC : M.Circuit C\n⊢ C.Nonempty","decl":"lemma Circuit.nonempty (hC : M.Circuit C) : C.Nonempty :=\n  hC.dep.nonempty\n\n"}
{"name":"Matroid.empty_not_circuit","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Not (M.Circuit EmptyCollection.emptyCollection)","decl":"lemma empty_not_circuit (M : Matroid α) : ¬M.Circuit ∅ :=\n  fun h ↦ by simpa using h.nonempty\n\n"}
{"name":"Matroid.circuit_iff","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC : Set α\n⊢ Iff (M.Circuit C) (And (M.Dep C) (∀ ⦃D : Set α⦄, M.Dep D → HasSubset.Subset D C → Eq D C))","decl":"lemma circuit_iff : M.Circuit C ↔ M.Dep C ∧ ∀ ⦃D⦄, M.Dep D → D ⊆ C → D = C := by\n  simp_rw [circuit_def, minimal_subset_iff, eq_comm (a := C)]\n\n"}
{"name":"Matroid.Circuit.ssubset_indep","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC X : Set α\nhC : M.Circuit C\nhXC : HasSSubset.SSubset X C\n⊢ M.Indep X","decl":"lemma Circuit.ssubset_indep (hC : M.Circuit C) (hXC : X ⊂ C) : M.Indep X := by\n  rw [← not_dep_iff (hXC.subset.trans hC.subset_ground)]\n  exact fun h ↦ hXC.ne ((circuit_iff.1 hC).2 h hXC.subset)\n\n"}
{"name":"Matroid.Circuit.minimal_not_indep","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC : Set α\nhC : M.Circuit C\n⊢ Minimal (fun x => Not (M.Indep x)) C","decl":"lemma Circuit.minimal_not_indep (hC : M.Circuit C) : Minimal (¬ M.Indep ·) C := by\n  simp_rw [minimal_iff_forall_ssubset, and_iff_right hC.not_indep, not_not]\n  exact fun ⦃t⦄ a ↦ ssubset_indep hC a\n\n"}
{"name":"Matroid.circuit_iff_minimal_not_indep","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC : Set α\nhCE : HasSubset.Subset C M.E\n⊢ Iff (M.Circuit C) (Minimal (fun x => Not (M.Indep x)) C)","decl":"lemma circuit_iff_minimal_not_indep (hCE : C ⊆ M.E) : M.Circuit C ↔ Minimal (¬ M.Indep ·) C :=\n  ⟨Circuit.minimal_not_indep, fun h ↦ ⟨(not_indep_iff hCE).1 h.prop,\n    fun _ hJ hJC ↦ (h.eq_of_superset hJ.not_indep hJC).le⟩⟩\n\n"}
{"name":"Matroid.Circuit.diff_singleton_indep","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC : Set α\ne : α\nhC : M.Circuit C\nhe : Membership.mem C e\n⊢ M.Indep (SDiff.sdiff C (Singleton.singleton e))","decl":"lemma Circuit.diff_singleton_indep (hC : M.Circuit C) (he : e ∈ C) : M.Indep (C \\ {e}) :=\n  hC.ssubset_indep (diff_singleton_sSubset.2 he)\n\n"}
{"name":"Matroid.circuit_iff_forall_ssubset","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC : Set α\n⊢ Iff (M.Circuit C) (And (M.Dep C) (∀ ⦃I : Set α⦄, HasSSubset.SSubset I C → M.Indep I))","decl":"lemma circuit_iff_forall_ssubset : M.Circuit C ↔ M.Dep C ∧ ∀ ⦃I⦄, I ⊂ C → M.Indep I := by\n  rw [Circuit, minimal_iff_forall_ssubset, and_congr_right_iff]\n  exact fun h ↦ ⟨fun h' I hIC ↦ ((not_dep_iff (hIC.subset.trans h.subset_ground)).1 (h' hIC)),\n    fun h I hIC ↦ (h hIC).not_dep⟩\n\n"}
{"name":"Matroid.circuit_antichain","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ IsAntichain (fun x1 x2 => HasSubset.Subset x1 x2) (setOf M.Circuit)","decl":"lemma circuit_antichain : IsAntichain (· ⊆ ·) (setOf M.Circuit) :=\n  fun _ hC _ hC' hne hss ↦ hne <| (Circuit.minimal hC').eq_of_subset hC.dep hss\n\n"}
{"name":"Matroid.Circuit.eq_of_not_indep_subset","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC X : Set α\nhC : M.Circuit C\nhX : Not (M.Indep X)\nhXC : HasSubset.Subset X C\n⊢ Eq X C","decl":"lemma Circuit.eq_of_not_indep_subset (hC : M.Circuit C) (hX : ¬ M.Indep X) (hXC : X ⊆ C) :\n    X = C :=\n  eq_of_le_of_not_lt hXC (hX ∘ hC.ssubset_indep)\n\n"}
{"name":"Matroid.Circuit.eq_of_dep_subset","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC X : Set α\nhC : M.Circuit C\nhX : M.Dep X\nhXC : HasSubset.Subset X C\n⊢ Eq X C","decl":"lemma Circuit.eq_of_dep_subset (hC : M.Circuit C) (hX : M.Dep X) (hXC : X ⊆ C) : X = C :=\n  hC.eq_of_not_indep_subset hX.not_indep hXC\n\n"}
{"name":"Matroid.Circuit.not_ssubset","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC C' : Set α\nhC : M.Circuit C\nhC' : M.Circuit C'\n⊢ Not (HasSSubset.SSubset C' C)","decl":"lemma Circuit.not_ssubset (hC : M.Circuit C) (hC' : M.Circuit C') : ¬C' ⊂ C :=\n  fun h' ↦ h'.ne (hC.eq_of_dep_subset hC'.dep h'.subset)\n\n"}
{"name":"Matroid.Circuit.eq_of_subset_circuit","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC C' : Set α\nhC : M.Circuit C\nhC' : M.Circuit C'\nh : HasSubset.Subset C C'\n⊢ Eq C C'","decl":"lemma Circuit.eq_of_subset_circuit (hC : M.Circuit C) (hC' : M.Circuit C') (h : C ⊆ C') : C = C' :=\n  hC'.eq_of_dep_subset hC.dep h\n\n"}
{"name":"Matroid.Circuit.eq_of_superset_circuit","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC C' : Set α\nhC : M.Circuit C\nhC' : M.Circuit C'\nh : HasSubset.Subset C' C\n⊢ Eq C C'","decl":"lemma Circuit.eq_of_superset_circuit (hC : M.Circuit C) (hC' : M.Circuit C') (h : C' ⊆ C) :\n    C = C' :=\n  (hC'.eq_of_subset_circuit hC h).symm\n\n"}
{"name":"Matroid.circuit_iff_dep_forall_diff_singleton_indep","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC : Set α\n⊢ Iff (M.Circuit C) (And (M.Dep C) (∀ (e : α), Membership.mem C e → M.Indep (SDiff.sdiff C (Singleton.singleton e))))","decl":"lemma circuit_iff_dep_forall_diff_singleton_indep :\n    M.Circuit C ↔ M.Dep C ∧ ∀ e ∈ C, M.Indep (C \\ {e}) := by\n  wlog hCE : C ⊆ M.E\n  · exact iff_of_false (hCE ∘ Circuit.subset_ground) (fun h ↦ hCE h.1.subset_ground)\n  simp [circuit_iff_minimal_not_indep hCE, ← not_indep_iff hCE,\n    minimal_iff_forall_diff_singleton (P := (¬ M.Indep ·))\n    (fun _ _ hY hYX hX ↦ hY <| hX.subset hYX)]\n\n"}
{"name":"Matroid.Indep.insert_circuit_of_forall","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\ne : α\nhI : M.Indep I\nheI : Not (Membership.mem I e)\nhe : Membership.mem (M.closure I) e\nh : ∀ (f : α), Membership.mem I f → Not (Membership.mem (M.closure (SDiff.sdiff I (Singleton.singleton f))) e)\n⊢ M.Circuit (Insert.insert e I)","decl":"lemma Indep.insert_circuit_of_forall (hI : M.Indep I) (heI : e ∉ I) (he : e ∈ M.closure I)\n    (h : ∀ f ∈ I, e ∉ M.closure (I \\ {f})) : M.Circuit (insert e I) := by\n  rw [circuit_iff_dep_forall_diff_singleton_indep, hI.insert_dep_iff, and_iff_right ⟨he, heI⟩]\n  rintro f (rfl | hfI)\n  · simpa [heI]\n  rw [← insert_diff_singleton_comm (by rintro rfl; contradiction),\n    (hI.diff _).insert_indep_iff_of_not_mem (by simp [heI])]\n  exact ⟨mem_ground_of_mem_closure he, h f hfI⟩\n\n"}
{"name":"Matroid.Indep.insert_circuit_of_forall_of_nontrivial","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\ne : α\nhI : M.Indep I\nhInt : I.Nontrivial\nhe : Membership.mem (M.closure I) e\nh : ∀ (f : α), Membership.mem I f → Not (Membership.mem (M.closure (SDiff.sdiff I (Singleton.singleton f))) e)\n⊢ M.Circuit (Insert.insert e I)","decl":"lemma Indep.insert_circuit_of_forall_of_nontrivial (hI : M.Indep I) (hInt : I.Nontrivial)\n    (he : e ∈ M.closure I) (h : ∀ f ∈ I, e ∉ M.closure (I \\ {f})) : M.Circuit (insert e I) := by\n  refine hI.insert_circuit_of_forall (fun heI ↦ ?_) he h\n  obtain ⟨f, hf, hne⟩ := hInt.exists_ne e\n  exact h f hf (mem_closure_of_mem' _ (by simp [heI, hne.symm]))\n\n"}
{"name":"Matroid.Circuit.diff_singleton_basis","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC : Set α\ne : α\nhC : M.Circuit C\nhe : Membership.mem C e\n⊢ M.Basis (SDiff.sdiff C (Singleton.singleton e)) C","decl":"lemma Circuit.diff_singleton_basis (hC : M.Circuit C) (he : e ∈ C) : M.Basis (C \\ {e}) C := by\n  nth_rw 2 [← insert_eq_of_mem he]\n  rw [← insert_diff_singleton, (hC.diff_singleton_indep he).basis_insert_iff,\n    insert_diff_singleton, insert_eq_of_mem he]\n  exact Or.inl hC.dep\n\n"}
{"name":"Matroid.Circuit.basis_iff_eq_diff_singleton","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC I : Set α\nhC : M.Circuit C\n⊢ Iff (M.Basis I C) (Exists fun e => And (Membership.mem C e) (Eq I (SDiff.sdiff C (Singleton.singleton e))))","decl":"lemma Circuit.basis_iff_eq_diff_singleton (hC : M.Circuit C) :\n    M.Basis I C ↔ ∃ e ∈ C, I = C \\ {e} := by\n  refine ⟨fun h ↦ ?_, ?_⟩\n  · obtain ⟨e, he⟩ := exists_of_ssubset\n      (h.subset.ssubset_of_ne (by rintro rfl; exact hC.dep.not_indep h.indep))\n    exact ⟨e, he.1, h.eq_of_subset_indep (hC.diff_singleton_indep he.1)\n      (subset_diff_singleton h.subset he.2) diff_subset⟩\n  rintro ⟨e, he, rfl⟩\n  exact hC.diff_singleton_basis he\n\n"}
{"name":"Matroid.Circuit.basis_iff_insert_eq","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC I : Set α\nhC : M.Circuit C\n⊢ Iff (M.Basis I C) (Exists fun e => And (Membership.mem (SDiff.sdiff C I) e) (Eq C (Insert.insert e I)))","decl":"lemma Circuit.basis_iff_insert_eq (hC : M.Circuit C) :\n    M.Basis I C ↔ ∃ e ∈ C \\ I, C = insert e I := by\n  rw [hC.basis_iff_eq_diff_singleton]\n  refine ⟨fun ⟨e, he, hI⟩ ↦ ⟨e, ⟨he, fun heI ↦ (hI.subset heI).2 rfl⟩, ?_⟩,\n    fun ⟨e, he, hC⟩ ↦ ⟨e, he.1, ?_⟩⟩\n  · rw [hI, insert_diff_singleton, insert_eq_of_mem he]\n  rw [hC, insert_diff_self_of_not_mem he.2]\n\n"}
{"name":"Matroid.Circuit.closure_diff_singleton_eq","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC : Set α\nhC : M.Circuit C\ne : α\n⊢ Eq (M.closure (SDiff.sdiff C (Singleton.singleton e))) (M.closure C)","decl":"lemma Circuit.closure_diff_singleton_eq (hC : M.Circuit C) (e : α) :\n    M.closure (C \\ {e}) = M.closure C :=\n  (em (e ∈ C)).elim\n    (fun he ↦ by rw [(hC.diff_singleton_basis he).closure_eq_closure])\n    (fun he ↦ by rw [diff_singleton_eq_self he])\n\n"}
{"name":"Matroid.Circuit.subset_closure_diff_singleton","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC : Set α\nhC : M.Circuit C\ne : α\n⊢ HasSubset.Subset C (M.closure (SDiff.sdiff C (Singleton.singleton e)))","decl":"lemma Circuit.subset_closure_diff_singleton (hC : M.Circuit C) (e : α) :\n    C ⊆ M.closure (C \\ {e}) := by\n  rw [hC.closure_diff_singleton_eq]\n  exact M.subset_closure _ hC.subset_ground\n\n"}
{"name":"Matroid.Circuit.mem_closure_diff_singleton_of_mem","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC : Set α\ne : α\nhC : M.Circuit C\nheC : Membership.mem C e\n⊢ Membership.mem (M.closure (SDiff.sdiff C (Singleton.singleton e))) e","decl":"lemma Circuit.mem_closure_diff_singleton_of_mem (hC : M.Circuit C) (heC : e ∈ C) :\n    e ∈ M.closure (C \\ {e}) :=\n  (hC.subset_closure_diff_singleton e) heC\n\n"}
{"name":"Matroid.Circuit.circuit_restrict_of_subset","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC R : Set α\nhC : M.Circuit C\nhCR : HasSubset.Subset C R\n⊢ (M.restrict R).Circuit C","decl":"lemma Circuit.circuit_restrict_of_subset (hC : M.Circuit C) (hCR : C ⊆ R) : (M ↾ R).Circuit C := by\n  simp_rw [circuit_iff, restrict_dep_iff, dep_iff, and_imp] at *\n  exact ⟨⟨hC.1.1, hCR⟩, fun I hI _ hIC ↦ hC.2 hI (hIC.trans hC.1.2) hIC⟩\n\n"}
{"name":"Matroid.restrict_circuit_iff","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC R : Set α\nhR : autoParam (HasSubset.Subset R M.E) _auto✝\n⊢ Iff ((M.restrict R).Circuit C) (And (M.Circuit C) (HasSubset.Subset C R))","decl":"lemma restrict_circuit_iff (hR : R ⊆ M.E := by aesop_mat) :\n    (M ↾ R).Circuit C ↔ M.Circuit C ∧ C ⊆ R := by\n  refine ⟨?_, fun h ↦ h.1.circuit_restrict_of_subset h.2⟩\n  simp_rw [circuit_iff, restrict_dep_iff, and_imp, dep_iff]\n  exact fun hC hCR h ↦ ⟨⟨⟨hC,hCR.trans hR⟩,fun I hI hIC ↦ h hI.1 (hIC.trans hCR) hIC⟩,hCR⟩\n\n"}
{"name":"Matroid.fundCircuit_eq_sInter","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\ne : α\nhe : Membership.mem (M.closure I) e\n⊢ Eq (M.fundCircuit e I) (Insert.insert e (setOf fun J => And (HasSubset.Subset J I) (Membership.mem (M.closure J) e)).sInter)","decl":"lemma fundCircuit_eq_sInter (he : e ∈ M.closure I) :\n    M.fundCircuit e I = insert e (⋂₀ {J | J ⊆ I ∧ e ∈ M.closure J}) := by\n  rw [fundCircuit]\n  simp_rw [closure_subset_closure_iff_subset_closure\n    (show {e} ⊆ M.E by simpa using mem_ground_of_mem_closure he), singleton_subset_iff]\n  rw [inter_eq_self_of_subset_right (sInter_subset_of_mem (by simpa))]\n\n"}
{"name":"Matroid.fundCircuit_subset_insert","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\ne : α\nI : Set α\n⊢ HasSubset.Subset (M.fundCircuit e I) (Insert.insert e I)","decl":"lemma fundCircuit_subset_insert (M : Matroid α) (e : α) (I : Set α) :\n    M.fundCircuit e I ⊆ insert e I :=\n  insert_subset_insert inter_subset_left\n\n"}
{"name":"Matroid.fundCircuit_subset_ground","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\ne : α\nhe : Membership.mem M.E e\nhI : autoParam (HasSubset.Subset I M.E) _auto✝\n⊢ HasSubset.Subset (M.fundCircuit e I) M.E","decl":"lemma fundCircuit_subset_ground (he : e ∈ M.E) (hI : I ⊆ M.E := by aesop_mat) :\n    M.fundCircuit e I ⊆ M.E :=\n  (M.fundCircuit_subset_insert e I).trans (insert_subset he hI)\n\n"}
{"name":"Matroid.mem_fundCircuit","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\ne : α\nI : Set α\n⊢ Membership.mem (M.fundCircuit e I) e","decl":"lemma mem_fundCircuit (M : Matroid α) (e : α) (I : Set α) : e ∈ fundCircuit M e I :=\n  mem_insert ..\n\n"}
{"name":"Matroid.fundCircuit_diff_eq_inter","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nI : Set α\ne : α\nM : Matroid α\nheI : Not (Membership.mem I e)\n⊢ Eq (SDiff.sdiff (M.fundCircuit e I) (Singleton.singleton e)) (Inter.inter (M.fundCircuit e I) I)","decl":"lemma fundCircuit_diff_eq_inter (M : Matroid α) (heI : e ∉ I) :\n    (M.fundCircuit e I) \\ {e} = (M.fundCircuit e I) ∩ I :=\n  (subset_inter diff_subset (by simp [fundCircuit_subset_insert])).antisymm\n    (subset_diff_singleton inter_subset_left (by simp [heI]))\n\n"}
{"name":"Matroid.fundCircuit_eq_of_mem","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nX : Set α\ne : α\nheX : Membership.mem X e\n⊢ Eq (M.fundCircuit e X) (Singleton.singleton e)","decl":"/-- The fundamental circuit of `e` and `X` has the junk value `{e}` if `e ∈ X` -/\nlemma fundCircuit_eq_of_mem (heX : e ∈ X) : M.fundCircuit e X = {e} := by\n  suffices h : ∀ a ∈ X, (∀ t ⊆ X, M.closure {e} ⊆ M.closure t → a ∈ t) → a = e by\n    simpa [subset_antisymm_iff, fundCircuit]\n  exact fun b hbX h ↦ h _ (singleton_subset_iff.2 heX) Subset.rfl\n\n"}
{"name":"Matroid.fundCircuit_eq_of_not_mem_ground","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nX : Set α\ne : α\nheX : Not (Membership.mem M.E e)\n⊢ Eq (M.fundCircuit e X) (Singleton.singleton e)","decl":"lemma fundCircuit_eq_of_not_mem_ground (heX : e ∉ M.E) : M.fundCircuit e X = {e} := by\n  suffices h : ∀ a ∈ X, (∀ t ⊆ X, M.closure {e} ⊆ M.closure t → a ∈ t) → a = e by\n    simpa [subset_antisymm_iff, fundCircuit]\n  simp_rw [← M.closure_inter_ground {e}, singleton_inter_eq_empty.2 heX]\n  exact fun a haX h ↦ by simpa using h ∅ (empty_subset X) rfl.subset\n\n"}
{"name":"Matroid.Indep.fundCircuit_circuit","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\ne : α\nhI : M.Indep I\nhecl : Membership.mem (M.closure I) e\nheI : Not (Membership.mem I e)\n⊢ M.Circuit (M.fundCircuit e I)","decl":"lemma Indep.fundCircuit_circuit (hI : M.Indep I) (hecl : e ∈ M.closure I) (heI : e ∉ I) :\n    M.Circuit (M.fundCircuit e I) := by\n  have aux : ⋂₀ {J | J ⊆ I ∧ e ∈ M.closure J} ⊆ I := sInter_subset_of_mem (by simpa)\n  rw [fundCircuit_eq_sInter hecl]\n  refine (hI.subset aux).insert_circuit_of_forall ?_ ?_ ?_\n  · simp [show ∃ x ⊆ I, e ∈ M.closure x ∧ e ∉ x from ⟨I, by simp [hecl, heI]⟩]\n  · rw [hI.closure_sInter_eq_biInter_closure_of_forall_subset ⟨I, by simpa⟩ (by simp +contextual)]\n    simp\n  simp only [mem_sInter, mem_setOf_eq, and_imp]\n  exact fun f hf hecl ↦ (hf _ (diff_subset.trans aux) hecl).2 rfl\n\n"}
{"name":"Matroid.Indep.mem_fundCircuit_iff","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\ne x : α\nhI : M.Indep I\nhecl : Membership.mem (M.closure I) e\nheI : Not (Membership.mem I e)\n⊢ Iff (Membership.mem (M.fundCircuit e I) x) (M.Indep (SDiff.sdiff (Insert.insert e I) (Singleton.singleton x)))","decl":"lemma Indep.mem_fundCircuit_iff (hI : M.Indep I) (hecl : e ∈ M.closure I) (heI : e ∉ I) :\n    x ∈ M.fundCircuit e I ↔ M.Indep (insert e I \\ {x}) := by\n  obtain rfl | hne := eq_or_ne x e\n  · simp [hI.diff, mem_fundCircuit]\n  suffices (∀ t ⊆ I, e ∈ M.closure t → x ∈ t) ↔ e ∉ M.closure (I \\ {x}) by\n    simpa [fundCircuit_eq_sInter hecl, hne, ← insert_diff_singleton_comm hne.symm,\n      (hI.diff _).insert_indep_iff, mem_ground_of_mem_closure hecl, heI]\n  refine ⟨fun h hecl ↦ (h _ diff_subset hecl).2 rfl, fun h J hJ heJ ↦ by_contra fun hxJ ↦ h ?_⟩\n  exact M.closure_subset_closure (subset_diff_singleton hJ hxJ) heJ\n\n"}
{"name":"Matroid.Base.fundCircuit_circuit","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nx : α\nB : Set α\nhB : M.Base B\nhxE : Membership.mem M.E x\nhxB : Not (Membership.mem B x)\n⊢ M.Circuit (M.fundCircuit x B)","decl":"lemma Base.fundCircuit_circuit {B : Set α} (hB : M.Base B) (hxE : x ∈ M.E) (hxB : x ∉ B) :\n    M.Circuit (M.fundCircuit x B) :=\n  hB.indep.fundCircuit_circuit (by rwa [hB.closure_eq]) hxB\n\n"}
{"name":"Matroid.Circuit.eq_fundCircuit_of_subset","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nC I : Set α\ne : α\nhC : M.Circuit C\nhI : M.Indep I\nhCss : HasSubset.Subset C (Insert.insert e I)\n⊢ Eq C (M.fundCircuit e I)","decl":"/-- For `I` independent, `M.fundCircuit e I` is the only circuit contained in `insert e I`. -/\nlemma Circuit.eq_fundCircuit_of_subset (hC : M.Circuit C) (hI : M.Indep I) (hCss : C ⊆ insert e I) :\n    C = M.fundCircuit e I := by\n  obtain hCI | ⟨heC, hCeI⟩ := subset_insert_iff.1 hCss\n  · exact (hC.not_indep (hI.subset hCI)).elim\n  suffices hss : M.fundCircuit e I ⊆ C by\n    refine hC.eq_of_superset_circuit (hI.fundCircuit_circuit ?_ fun heI ↦ ?_) hss\n    · rw [hI.mem_closure_iff]\n      exact .inl (hC.dep.superset hCss (insert_subset (hC.subset_ground heC) hI.subset_ground))\n    exact hC.not_indep (hI.subset (hCss.trans (by simp [heI])))\n  rw [fundCircuit_eq_sInter <|\n    M.closure_subset_closure hCeI <| hC.mem_closure_diff_singleton_of_mem heC]\n  refine insert_subset heC <| (sInter_subset_of_mem (t := C \\ {e}) ?_).trans diff_subset\n  simp [hCss, hC.mem_closure_diff_singleton_of_mem heC]\n\n"}
{"name":"Matroid.fundCircuit_restrict","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\ne : α\nR : Set α\nhIR : HasSubset.Subset I R\nheR : Membership.mem R e\nhR : HasSubset.Subset R M.E\n⊢ Eq ((M.restrict R).fundCircuit e I) (M.fundCircuit e I)","decl":"lemma fundCircuit_restrict {R : Set α} (hIR : I ⊆ R) (heR : e ∈ R) (hR : R ⊆ M.E) :\n    (M ↾ R).fundCircuit e I = M.fundCircuit e I := by\n  simp_rw [fundCircuit, M.restrict_closure_eq (R := R) (X := {e}) (by simpa)]\n  refine subset_antisymm (insert_subset_insert (inter_subset_inter_right _ ?_))\n    (insert_subset_insert (inter_subset_inter_right _ ?_))\n  · refine subset_sInter fun J ⟨hJI, heJ⟩ ↦ sInter_subset_of_mem ⟨hJI, ?_⟩\n    simp only [restrict_closure_eq', union_subset_iff, subset_union_right, and_true]\n    refine (inter_subset_inter_left _ ?_).trans subset_union_left\n    rwa [inter_eq_self_of_subset_left (hJI.trans hIR)]\n  refine subset_sInter fun J ⟨hJI, heJ⟩ ↦ sInter_subset_of_mem\n    ⟨hJI, M.closure_subset_closure_of_subset_closure ?_⟩\n  rw [restrict_closure_eq _ (hJI.trans hIR) hR] at heJ\n  simp only [subset_inter_iff, inter_subset_right, and_true] at heJ\n  exact subset_trans (by simpa [M.mem_closure_of_mem' (mem_singleton e) (hR heR)]) heJ\n\n"}
{"name":"Matroid.fundCircuit_restrict_univ","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nI : Set α\ne : α\nM : Matroid α\n⊢ Eq ((M.restrict Set.univ).fundCircuit e I) (M.fundCircuit e I)","decl":"@[simp] lemma fundCircuit_restrict_univ (M : Matroid α) :\n    (M ↾ univ).fundCircuit e I = M.fundCircuit e I := by\n  have aux (A B) : M.closure A ⊆ B ∪ univ \\ M.E ↔ M.closure A ⊆ B := by\n    refine ⟨fun h ↦ ?_, fun h ↦ h.trans subset_union_left⟩\n    refine (subset_inter h (M.closure_subset_ground A)).trans ?_\n    simp [union_inter_distrib_right]\n  simp [fundCircuit, aux]\n\n"}
{"name":"Matroid.Dep.exists_circuit_subset","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nX : Set α\nhX : M.Dep X\n⊢ Exists fun C => And (HasSubset.Subset C X) (M.Circuit C)","decl":"lemma Dep.exists_circuit_subset (hX : M.Dep X) : ∃ C, C ⊆ X ∧ M.Circuit C := by\n  obtain ⟨I, hI⟩ := M.exists_basis X\n  obtain ⟨e, heX, heI⟩ := exists_of_ssubset\n    (hI.subset.ssubset_of_ne (by rintro rfl; exact hI.indep.not_dep hX))\n  exact ⟨M.fundCircuit e I, (M.fundCircuit_subset_insert e I).trans (insert_subset heX hI.subset),\n    hI.indep.fundCircuit_circuit (hI.subset_closure heX) heI⟩\n\n"}
{"name":"Matroid.dep_iff_superset_circuit","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nX : Set α\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ Iff (M.Dep X) (Exists fun C => And (HasSubset.Subset C X) (M.Circuit C))","decl":"lemma dep_iff_superset_circuit (hX : X ⊆ M.E := by aesop_mat) :\n    M.Dep X ↔ ∃ C, C ⊆ X ∧ M.Circuit C :=\n  ⟨Dep.exists_circuit_subset, fun ⟨C, hCX, hC⟩ ↦ hC.dep.superset hCX⟩\n\n"}
{"name":"Matroid.dep_iff_superset_circuit'","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nX : Set α\n⊢ Iff (M.Dep X) (And (Exists fun C => And (HasSubset.Subset C X) (M.Circuit C)) (HasSubset.Subset X M.E))","decl":"/-- A version of `Matroid.dep_iff_superset_circuit` that has the supportedness hypothesis\nas part of the equivalence, rather than a hypothesis. -/\nlemma dep_iff_superset_circuit' : M.Dep X ↔ (∃ C, C ⊆ X ∧ M.Circuit C) ∧ X ⊆ M.E :=\n  ⟨fun h ↦ ⟨h.exists_circuit_subset, h.subset_ground⟩, fun ⟨⟨C, hCX, hC⟩, h⟩ ↦ hC.dep.superset hCX⟩\n\n"}
{"name":"Matroid.indep_iff_forall_subset_not_circuit'","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\n⊢ Iff (M.Indep I) (And (∀ (C : Set α), HasSubset.Subset C I → Not (M.Circuit C)) (HasSubset.Subset I M.E))","decl":"/-- A version of `Matroid.indep_iff_forall_subset_not_circuit` that has the supportedness hypothesis\nas part of the equivalence, rather than a hypothesis. -/\nlemma indep_iff_forall_subset_not_circuit' :\n    M.Indep I ↔ (∀ C, C ⊆ I → ¬M.Circuit C) ∧ I ⊆ M.E := by\n  simp_rw [indep_iff_not_dep, dep_iff_superset_circuit']\n  aesop\n\n"}
{"name":"Matroid.indep_iff_forall_subset_not_circuit","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\nhI : autoParam (HasSubset.Subset I M.E) _auto✝\n⊢ Iff (M.Indep I) (∀ (C : Set α), HasSubset.Subset C I → Not (M.Circuit C))","decl":"lemma indep_iff_forall_subset_not_circuit (hI : I ⊆ M.E := by aesop_mat) :\n    M.Indep I ↔ ∀ C, C ⊆ I → ¬M.Circuit C := by\n  rw [indep_iff_forall_subset_not_circuit', and_iff_left hI]\n\n"}
{"name":"Matroid.ext_circuit","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM₁ M₂ : Matroid α\nhE : Eq M₁.E M₂.E\nh : ∀ ⦃C : Set α⦄, HasSubset.Subset C M₁.E → Iff (M₁.Circuit C) (M₂.Circuit C)\n⊢ Eq M₁ M₂","decl":"lemma ext_circuit {M₁ M₂ : Matroid α} (hE : M₁.E = M₂.E)\n    (h : ∀ ⦃C⦄, C ⊆ M₁.E → (M₁.Circuit C ↔ M₂.Circuit C)) : M₁ = M₂ := by\n  have h' {C} : M₁.Circuit C ↔ M₂.Circuit C :=\n    (em (C ⊆ M₁.E)).elim (h (C := C)) (fun hC ↦ iff_of_false (mt Circuit.subset_ground hC)\n      (mt Circuit.subset_ground fun hss ↦ hC (hss.trans_eq hE.symm)))\n  refine ext_indep hE fun I hI ↦ ?_\n  simp_rw [indep_iff_forall_subset_not_circuit hI, h',\n    indep_iff_forall_subset_not_circuit (hI.trans_eq hE)]\n\n"}
{"name":"Matroid.ext_circuit_not_indep","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM₁ M₂ : Matroid α\nhE : Eq M₁.E M₂.E\nh₁ : ∀ (C : Set α), M₁.Circuit C → Not (M₂.Indep C)\nh₂ : ∀ (C : Set α), M₂.Circuit C → Not (M₁.Indep C)\n⊢ Eq M₁ M₂","decl":"/-- A stronger version of `Matroid.ext_circuit`:\ntwo matroids on the same ground set are equal if no circuit of one is independent in the other. -/\nlemma ext_circuit_not_indep {M₁ M₂ : Matroid α} (hE : M₁.E = M₂.E)\n    (h₁ : ∀ C, M₁.Circuit C → ¬ M₂.Indep C) (h₂ : ∀ C, M₂.Circuit C → ¬ M₁.Indep C) :\n    M₁ = M₂ := by\n  refine ext_circuit hE fun C hCE ↦ ⟨fun hC ↦ ?_, fun hC ↦ ?_⟩\n  · obtain ⟨C', hC'C, hC'⟩ := ((not_indep_iff (by rwa [← hE])).1 (h₁ C hC)).exists_circuit_subset\n    rwa [← hC.eq_of_not_indep_subset (h₂ C' hC') hC'C]\n  obtain ⟨C', hC'C, hC'⟩ := ((not_indep_iff hCE).1 (h₂ C hC)).exists_circuit_subset\n  rwa [← hC.eq_of_not_indep_subset (h₁ C' hC') hC'C]\n\n"}
{"name":"Matroid.ext_iff_circuit","module":"Mathlib.Data.Matroid.Circuit","initialProofState":"α : Type u_1\nM₁ M₂ : Matroid α\n⊢ Iff (Eq M₁ M₂) (And (Eq M₁.E M₂.E) (∀ (C : Set α), Iff (M₁.Circuit C) (M₂.Circuit C)))","decl":"lemma ext_iff_circuit {M₁ M₂ : Matroid α} :\n    M₁ = M₂ ↔ M₁.E = M₂.E ∧ ∀ C, M₁.Circuit C ↔ M₂.Circuit C :=\n  ⟨fun h ↦ by simp [h], fun h ↦ ext_circuit h.1 fun C hC ↦ h.2 (C := C)⟩\n\n"}
