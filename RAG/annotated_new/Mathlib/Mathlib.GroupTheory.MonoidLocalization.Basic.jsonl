{"name":"AddSubmonoid.LocalizationMap.map_add_units'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nself : S.LocalizationMap N\ny : Subtype fun x => Membership.mem S x\n⊢ IsAddUnit ((↑self.toAddMonoidHom).toFun ↑y)","decl":"/-- The type of AddMonoid homomorphisms satisfying the characteristic predicate: if `f : M →+ N`\nsatisfies this predicate, then `N` is isomorphic to the localization of `M` at `S`. -/\nstructure LocalizationMap extends AddMonoidHom M N where\n  map_add_units' : ∀ y : S, IsAddUnit (toFun y)\n  surj' : ∀ z : N, ∃ x : M × S, z + toFun x.2 = toFun x.1\n  exists_of_eq : ∀ x y, toFun x = toFun y → ∃ c : S, ↑c + x = ↑c + y\n\n-- Porting note: no docstrings for AddSubmonoid.LocalizationMap\n"}
{"name":"AddSubmonoid.LocalizationMap.exists_of_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nself : S.LocalizationMap N\nx y : M\na✝ : Eq ((↑self.toAddMonoidHom).toFun x) ((↑self.toAddMonoidHom).toFun y)\n⊢ Exists fun c => Eq (HAdd.hAdd (↑c) x) (HAdd.hAdd (↑c) y)","decl":"/-- The type of AddMonoid homomorphisms satisfying the characteristic predicate: if `f : M →+ N`\nsatisfies this predicate, then `N` is isomorphic to the localization of `M` at `S`. -/\nstructure LocalizationMap extends AddMonoidHom M N where\n  map_add_units' : ∀ y : S, IsAddUnit (toFun y)\n  surj' : ∀ z : N, ∃ x : M × S, z + toFun x.2 = toFun x.1\n  exists_of_eq : ∀ x y, toFun x = toFun y → ∃ c : S, ↑c + x = ↑c + y\n\n-- Porting note: no docstrings for AddSubmonoid.LocalizationMap\n"}
{"name":"AddSubmonoid.LocalizationMap.mk.inj","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\ntoAddMonoidHom✝ : AddMonoidHom M N\nmap_add_units'✝ : ∀ (y : Subtype fun x => Membership.mem S x), IsAddUnit ((↑toAddMonoidHom✝).toFun ↑y)\nsurj'✝ : ∀ (z : N), Exists fun x => Eq (HAdd.hAdd z ((↑toAddMonoidHom✝).toFun ↑x.2)) ((↑toAddMonoidHom✝).toFun x.1)\nexists_of_eq✝ : ∀ (x y : M), Eq ((↑toAddMonoidHom✝).toFun x) ((↑toAddMonoidHom✝).toFun y) → Exists fun c => Eq (HAdd.hAdd (↑c) x) (HAdd.hAdd (↑c) y)\ntoAddMonoidHom : AddMonoidHom M N\nmap_add_units' : ∀ (y : Subtype fun x => Membership.mem S x), IsAddUnit ((↑toAddMonoidHom).toFun ↑y)\nsurj' : ∀ (z : N), Exists fun x => Eq (HAdd.hAdd z ((↑toAddMonoidHom).toFun ↑x.2)) ((↑toAddMonoidHom).toFun x.1)\nexists_of_eq : ∀ (x y : M), Eq ((↑toAddMonoidHom).toFun x) ((↑toAddMonoidHom).toFun y) → Exists fun c => Eq (HAdd.hAdd (↑c) x) (HAdd.hAdd (↑c) y)\nx✝ : Eq { toAddMonoidHom := toAddMonoidHom✝, map_add_units' := map_add_units'✝, surj' := surj'✝, exists_of_eq := exists_of_eq✝ } { toAddMonoidHom := toAddMonoidHom, map_add_units' := map_add_units', surj' := surj', exists_of_eq := exists_of_eq }\n⊢ Eq toAddMonoidHom✝ toAddMonoidHom","decl":"/-- The type of AddMonoid homomorphisms satisfying the characteristic predicate: if `f : M →+ N`\nsatisfies this predicate, then `N` is isomorphic to the localization of `M` at `S`. -/\nstructure LocalizationMap extends AddMonoidHom M N where\n  map_add_units' : ∀ y : S, IsAddUnit (toFun y)\n  surj' : ∀ z : N, ∃ x : M × S, z + toFun x.2 = toFun x.1\n  exists_of_eq : ∀ x y, toFun x = toFun y → ∃ c : S, ↑c + x = ↑c + y\n\n-- Porting note: no docstrings for AddSubmonoid.LocalizationMap\n"}
{"name":"AddSubmonoid.LocalizationMap.mk.injEq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\ntoAddMonoidHom✝ : AddMonoidHom M N\nmap_add_units'✝ : ∀ (y : Subtype fun x => Membership.mem S x), IsAddUnit ((↑toAddMonoidHom✝).toFun ↑y)\nsurj'✝ : ∀ (z : N), Exists fun x => Eq (HAdd.hAdd z ((↑toAddMonoidHom✝).toFun ↑x.2)) ((↑toAddMonoidHom✝).toFun x.1)\nexists_of_eq✝ : ∀ (x y : M), Eq ((↑toAddMonoidHom✝).toFun x) ((↑toAddMonoidHom✝).toFun y) → Exists fun c => Eq (HAdd.hAdd (↑c) x) (HAdd.hAdd (↑c) y)\ntoAddMonoidHom : AddMonoidHom M N\nmap_add_units' : ∀ (y : Subtype fun x => Membership.mem S x), IsAddUnit ((↑toAddMonoidHom).toFun ↑y)\nsurj' : ∀ (z : N), Exists fun x => Eq (HAdd.hAdd z ((↑toAddMonoidHom).toFun ↑x.2)) ((↑toAddMonoidHom).toFun x.1)\nexists_of_eq : ∀ (x y : M), Eq ((↑toAddMonoidHom).toFun x) ((↑toAddMonoidHom).toFun y) → Exists fun c => Eq (HAdd.hAdd (↑c) x) (HAdd.hAdd (↑c) y)\n⊢ Eq (Eq { toAddMonoidHom := toAddMonoidHom✝, map_add_units' := map_add_units'✝, surj' := surj'✝, exists_of_eq := exists_of_eq✝ } { toAddMonoidHom := toAddMonoidHom, map_add_units' := map_add_units', surj' := surj', exists_of_eq := exists_of_eq }) (Eq toAddMonoidHom✝ toAddMonoidHom)","decl":"/-- The type of AddMonoid homomorphisms satisfying the characteristic predicate: if `f : M →+ N`\nsatisfies this predicate, then `N` is isomorphic to the localization of `M` at `S`. -/\nstructure LocalizationMap extends AddMonoidHom M N where\n  map_add_units' : ∀ y : S, IsAddUnit (toFun y)\n  surj' : ∀ z : N, ∃ x : M × S, z + toFun x.2 = toFun x.1\n  exists_of_eq : ∀ x y, toFun x = toFun y → ∃ c : S, ↑c + x = ↑c + y\n\n-- Porting note: no docstrings for AddSubmonoid.LocalizationMap\n"}
{"name":"AddSubmonoid.LocalizationMap.mk.sizeOf_spec","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝² : AddCommMonoid N\ninst✝¹ : SizeOf M\ninst✝ : SizeOf N\ntoAddMonoidHom : AddMonoidHom M N\nmap_add_units' : ∀ (y : Subtype fun x => Membership.mem S x), IsAddUnit ((↑toAddMonoidHom).toFun ↑y)\nsurj' : ∀ (z : N), Exists fun x => Eq (HAdd.hAdd z ((↑toAddMonoidHom).toFun ↑x.2)) ((↑toAddMonoidHom).toFun x.1)\nexists_of_eq : ∀ (x y : M), Eq ((↑toAddMonoidHom).toFun x) ((↑toAddMonoidHom).toFun y) → Exists fun c => Eq (HAdd.hAdd (↑c) x) (HAdd.hAdd (↑c) y)\n⊢ Eq (SizeOf.sizeOf { toAddMonoidHom := toAddMonoidHom, map_add_units' := map_add_units', surj' := surj', exists_of_eq := exists_of_eq }) (HAdd.hAdd 1 (SizeOf.sizeOf toAddMonoidHom))","decl":"/-- The type of AddMonoid homomorphisms satisfying the characteristic predicate: if `f : M →+ N`\nsatisfies this predicate, then `N` is isomorphic to the localization of `M` at `S`. -/\nstructure LocalizationMap extends AddMonoidHom M N where\n  map_add_units' : ∀ y : S, IsAddUnit (toFun y)\n  surj' : ∀ z : N, ∃ x : M × S, z + toFun x.2 = toFun x.1\n  exists_of_eq : ∀ x y, toFun x = toFun y → ∃ c : S, ↑c + x = ↑c + y\n\n-- Porting note: no docstrings for AddSubmonoid.LocalizationMap\n"}
{"name":"AddSubmonoid.LocalizationMap.surj'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nself : S.LocalizationMap N\nz : N\n⊢ Exists fun x => Eq (HAdd.hAdd z ((↑self.toAddMonoidHom).toFun ↑x.2)) ((↑self.toAddMonoidHom).toFun x.1)","decl":"/-- The type of AddMonoid homomorphisms satisfying the characteristic predicate: if `f : M →+ N`\nsatisfies this predicate, then `N` is isomorphic to the localization of `M` at `S`. -/\nstructure LocalizationMap extends AddMonoidHom M N where\n  map_add_units' : ∀ y : S, IsAddUnit (toFun y)\n  surj' : ∀ z : N, ∃ x : M × S, z + toFun x.2 = toFun x.1\n  exists_of_eq : ∀ x y, toFun x = toFun y → ∃ c : S, ↑c + x = ↑c + y\n\n-- Porting note: no docstrings for AddSubmonoid.LocalizationMap\n"}
{"name":"Submonoid.LocalizationMap.mk.inj","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\ntoMonoidHom✝ : MonoidHom M N\nmap_units'✝ : ∀ (y : Subtype fun x => Membership.mem S x), IsUnit ((↑toMonoidHom✝).toFun ↑y)\nsurj'✝ : ∀ (z : N), Exists fun x => Eq (HMul.hMul z ((↑toMonoidHom✝).toFun ↑x.2)) ((↑toMonoidHom✝).toFun x.1)\nexists_of_eq✝ : ∀ (x y : M), Eq ((↑toMonoidHom✝).toFun x) ((↑toMonoidHom✝).toFun y) → Exists fun c => Eq (HMul.hMul (↑c) x) (HMul.hMul (↑c) y)\ntoMonoidHom : MonoidHom M N\nmap_units' : ∀ (y : Subtype fun x => Membership.mem S x), IsUnit ((↑toMonoidHom).toFun ↑y)\nsurj' : ∀ (z : N), Exists fun x => Eq (HMul.hMul z ((↑toMonoidHom).toFun ↑x.2)) ((↑toMonoidHom).toFun x.1)\nexists_of_eq : ∀ (x y : M), Eq ((↑toMonoidHom).toFun x) ((↑toMonoidHom).toFun y) → Exists fun c => Eq (HMul.hMul (↑c) x) (HMul.hMul (↑c) y)\nx✝ : Eq { toMonoidHom := toMonoidHom✝, map_units' := map_units'✝, surj' := surj'✝, exists_of_eq := exists_of_eq✝ } { toMonoidHom := toMonoidHom, map_units' := map_units', surj' := surj', exists_of_eq := exists_of_eq }\n⊢ Eq toMonoidHom✝ toMonoidHom","decl":"/-- The type of monoid homomorphisms satisfying the characteristic predicate: if `f : M →* N`\nsatisfies this predicate, then `N` is isomorphic to the localization of `M` at `S`. -/\nstructure LocalizationMap extends MonoidHom M N where\n  map_units' : ∀ y : S, IsUnit (toFun y)\n  surj' : ∀ z : N, ∃ x : M × S, z * toFun x.2 = toFun x.1\n  exists_of_eq : ∀ x y, toFun x = toFun y → ∃ c : S, ↑c * x = c * y\n\n-- Porting note: no docstrings for Submonoid.LocalizationMap\n"}
{"name":"Submonoid.LocalizationMap.exists_of_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nself : S.LocalizationMap N\nx y : M\na✝ : Eq ((↑self.toMonoidHom).toFun x) ((↑self.toMonoidHom).toFun y)\n⊢ Exists fun c => Eq (HMul.hMul (↑c) x) (HMul.hMul (↑c) y)","decl":"/-- The type of monoid homomorphisms satisfying the characteristic predicate: if `f : M →* N`\nsatisfies this predicate, then `N` is isomorphic to the localization of `M` at `S`. -/\nstructure LocalizationMap extends MonoidHom M N where\n  map_units' : ∀ y : S, IsUnit (toFun y)\n  surj' : ∀ z : N, ∃ x : M × S, z * toFun x.2 = toFun x.1\n  exists_of_eq : ∀ x y, toFun x = toFun y → ∃ c : S, ↑c * x = c * y\n\n-- Porting note: no docstrings for Submonoid.LocalizationMap\n"}
{"name":"Submonoid.LocalizationMap.mk.sizeOf_spec","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝² : CommMonoid N\ninst✝¹ : SizeOf M\ninst✝ : SizeOf N\ntoMonoidHom : MonoidHom M N\nmap_units' : ∀ (y : Subtype fun x => Membership.mem S x), IsUnit ((↑toMonoidHom).toFun ↑y)\nsurj' : ∀ (z : N), Exists fun x => Eq (HMul.hMul z ((↑toMonoidHom).toFun ↑x.2)) ((↑toMonoidHom).toFun x.1)\nexists_of_eq : ∀ (x y : M), Eq ((↑toMonoidHom).toFun x) ((↑toMonoidHom).toFun y) → Exists fun c => Eq (HMul.hMul (↑c) x) (HMul.hMul (↑c) y)\n⊢ Eq (SizeOf.sizeOf { toMonoidHom := toMonoidHom, map_units' := map_units', surj' := surj', exists_of_eq := exists_of_eq }) (HAdd.hAdd 1 (SizeOf.sizeOf toMonoidHom))","decl":"/-- The type of monoid homomorphisms satisfying the characteristic predicate: if `f : M →* N`\nsatisfies this predicate, then `N` is isomorphic to the localization of `M` at `S`. -/\nstructure LocalizationMap extends MonoidHom M N where\n  map_units' : ∀ y : S, IsUnit (toFun y)\n  surj' : ∀ z : N, ∃ x : M × S, z * toFun x.2 = toFun x.1\n  exists_of_eq : ∀ x y, toFun x = toFun y → ∃ c : S, ↑c * x = c * y\n\n-- Porting note: no docstrings for Submonoid.LocalizationMap\n"}
{"name":"Submonoid.LocalizationMap.map_units'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nself : S.LocalizationMap N\ny : Subtype fun x => Membership.mem S x\n⊢ IsUnit ((↑self.toMonoidHom).toFun ↑y)","decl":"/-- The type of monoid homomorphisms satisfying the characteristic predicate: if `f : M →* N`\nsatisfies this predicate, then `N` is isomorphic to the localization of `M` at `S`. -/\nstructure LocalizationMap extends MonoidHom M N where\n  map_units' : ∀ y : S, IsUnit (toFun y)\n  surj' : ∀ z : N, ∃ x : M × S, z * toFun x.2 = toFun x.1\n  exists_of_eq : ∀ x y, toFun x = toFun y → ∃ c : S, ↑c * x = c * y\n\n-- Porting note: no docstrings for Submonoid.LocalizationMap\n"}
{"name":"Submonoid.LocalizationMap.surj'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nself : S.LocalizationMap N\nz : N\n⊢ Exists fun x => Eq (HMul.hMul z ((↑self.toMonoidHom).toFun ↑x.2)) ((↑self.toMonoidHom).toFun x.1)","decl":"/-- The type of monoid homomorphisms satisfying the characteristic predicate: if `f : M →* N`\nsatisfies this predicate, then `N` is isomorphic to the localization of `M` at `S`. -/\nstructure LocalizationMap extends MonoidHom M N where\n  map_units' : ∀ y : S, IsUnit (toFun y)\n  surj' : ∀ z : N, ∃ x : M × S, z * toFun x.2 = toFun x.1\n  exists_of_eq : ∀ x y, toFun x = toFun y → ∃ c : S, ↑c * x = c * y\n\n-- Porting note: no docstrings for Submonoid.LocalizationMap\n"}
{"name":"Submonoid.LocalizationMap.mk.injEq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\ntoMonoidHom✝ : MonoidHom M N\nmap_units'✝ : ∀ (y : Subtype fun x => Membership.mem S x), IsUnit ((↑toMonoidHom✝).toFun ↑y)\nsurj'✝ : ∀ (z : N), Exists fun x => Eq (HMul.hMul z ((↑toMonoidHom✝).toFun ↑x.2)) ((↑toMonoidHom✝).toFun x.1)\nexists_of_eq✝ : ∀ (x y : M), Eq ((↑toMonoidHom✝).toFun x) ((↑toMonoidHom✝).toFun y) → Exists fun c => Eq (HMul.hMul (↑c) x) (HMul.hMul (↑c) y)\ntoMonoidHom : MonoidHom M N\nmap_units' : ∀ (y : Subtype fun x => Membership.mem S x), IsUnit ((↑toMonoidHom).toFun ↑y)\nsurj' : ∀ (z : N), Exists fun x => Eq (HMul.hMul z ((↑toMonoidHom).toFun ↑x.2)) ((↑toMonoidHom).toFun x.1)\nexists_of_eq : ∀ (x y : M), Eq ((↑toMonoidHom).toFun x) ((↑toMonoidHom).toFun y) → Exists fun c => Eq (HMul.hMul (↑c) x) (HMul.hMul (↑c) y)\n⊢ Eq (Eq { toMonoidHom := toMonoidHom✝, map_units' := map_units'✝, surj' := surj'✝, exists_of_eq := exists_of_eq✝ } { toMonoidHom := toMonoidHom, map_units' := map_units', surj' := surj', exists_of_eq := exists_of_eq }) (Eq toMonoidHom✝ toMonoidHom)","decl":"/-- The type of monoid homomorphisms satisfying the characteristic predicate: if `f : M →* N`\nsatisfies this predicate, then `N` is isomorphic to the localization of `M` at `S`. -/\nstructure LocalizationMap extends MonoidHom M N where\n  map_units' : ∀ y : S, IsUnit (toFun y)\n  surj' : ∀ z : N, ∃ x : M × S, z * toFun x.2 = toFun x.1\n  exists_of_eq : ∀ x y, toFun x = toFun y → ∃ c : S, ↑c * x = c * y\n\n-- Porting note: no docstrings for Submonoid.LocalizationMap\n"}
{"name":"AddLocalization.r_eq_r'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\n⊢ Eq (AddLocalization.r S) (AddLocalization.r' S)","decl":"/-- The congruence relation used to localize a `CommMonoid` at a submonoid can be expressed\nequivalently as an infimum (see `Localization.r`) or explicitly\n(see `Localization.r'`). -/\n@[to_additive AddLocalization.r_eq_r'\n    \"The additive congruence relation used to localize an `AddCommMonoid` at a submonoid can be\nexpressed equivalently as an infimum (see `AddLocalization.r`) or explicitly\n(see `AddLocalization.r'`).\"]\ntheorem r_eq_r' : r S = r' S :=\n  le_antisymm (sInf_le fun _ ↦ ⟨1, by simp⟩) <|\n    le_sInf fun b H ⟨p, q⟩ ⟨x, y⟩ ⟨t, ht⟩ ↦ by\n      rw [← one_mul (p, q), ← one_mul (x, y)]\n      refine b.trans (b.mul (H (t * y)) (b.refl _)) ?_\n      convert b.symm (b.mul (H (t * q)) (b.refl (x, y))) using 1\n      dsimp only [Prod.mk_mul_mk, Submonoid.coe_mul] at ht ⊢\n      simp_rw [mul_assoc, ht, mul_comm y q]\n\n"}
{"name":"Localization.r_eq_r'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\n⊢ Eq (Localization.r S) (Localization.r' S)","decl":"/-- The congruence relation used to localize a `CommMonoid` at a submonoid can be expressed\nequivalently as an infimum (see `Localization.r`) or explicitly\n(see `Localization.r'`). -/\n@[to_additive AddLocalization.r_eq_r'\n    \"The additive congruence relation used to localize an `AddCommMonoid` at a submonoid can be\nexpressed equivalently as an infimum (see `AddLocalization.r`) or explicitly\n(see `AddLocalization.r'`).\"]\ntheorem r_eq_r' : r S = r' S :=\n  le_antisymm (sInf_le fun _ ↦ ⟨1, by simp⟩) <|\n    le_sInf fun b H ⟨p, q⟩ ⟨x, y⟩ ⟨t, ht⟩ ↦ by\n      rw [← one_mul (p, q), ← one_mul (x, y)]\n      refine b.trans (b.mul (H (t * y)) (b.refl _)) ?_\n      convert b.symm (b.mul (H (t * q)) (b.refl (x, y))) using 1\n      dsimp only [Prod.mk_mul_mk, Submonoid.coe_mul] at ht ⊢\n      simp_rw [mul_assoc, ht, mul_comm y q]\n\n"}
{"name":"Localization.r_iff_exists","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\nx y : Prod M (Subtype fun x => Membership.mem S x)\n⊢ Iff ((Localization.r S) x y) (Exists fun c => Eq (HMul.hMul (↑c) (HMul.hMul (↑y.2) x.1)) (HMul.hMul (↑c) (HMul.hMul (↑x.2) y.1)))","decl":"@[to_additive AddLocalization.r_iff_exists]\ntheorem r_iff_exists {x y : M × S} : r S x y ↔ ∃ c : S, ↑c * (↑y.2 * x.1) = c * (x.2 * y.1) := by\n  rw [r_eq_r' S]; rfl\n\n"}
{"name":"AddLocalization.r_iff_exists","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\nx y : Prod M (Subtype fun x => Membership.mem S x)\n⊢ Iff ((AddLocalization.r S) x y) (Exists fun c => Eq (HAdd.hAdd (↑c) (HAdd.hAdd (↑y.2) x.1)) (HAdd.hAdd (↑c) (HAdd.hAdd (↑x.2) y.1)))","decl":"@[to_additive AddLocalization.r_iff_exists]\ntheorem r_iff_exists {x y : M × S} : r S x y ↔ ∃ c : S, ↑c * (↑y.2 * x.1) = c * (x.2 * y.1) := by\n  rw [r_eq_r' S]; rfl\n\n"}
{"name":"Localization.r_iff_oreEqv_r","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\nx y : Prod M (Subtype fun x => Membership.mem S x)\n⊢ Iff ((Localization.r S) x y) ((OreLocalization.oreEqv S M) x y)","decl":"@[to_additive AddLocalization.r_iff_oreEqv_r]\ntheorem r_iff_oreEqv_r {x y : M × S} : r S x y ↔ (OreLocalization.oreEqv S M).r x y := by\n  simp only [r_iff_exists, Subtype.exists, exists_prop, OreLocalization.oreEqv, smul_eq_mul,\n    Submonoid.mk_smul]\n  constructor\n  · rintro ⟨u, hu, e⟩\n    exact ⟨_, mul_mem hu x.2.2, u * y.2, by rw [mul_assoc, mul_assoc, ← e], mul_right_comm _ _ _⟩\n  · rintro ⟨u, hu, v, e₁, e₂⟩\n    exact ⟨u, hu, by rw [← mul_assoc, e₂, mul_right_comm, ← e₁, mul_assoc, mul_comm y.1]⟩\n\n"}
{"name":"AddLocalization.r_iff_oreEqv_r","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\nx y : Prod M (Subtype fun x => Membership.mem S x)\n⊢ Iff ((AddLocalization.r S) x y) ((AddOreLocalization.oreEqv S M) x y)","decl":"@[to_additive AddLocalization.r_iff_oreEqv_r]\ntheorem r_iff_oreEqv_r {x y : M × S} : r S x y ↔ (OreLocalization.oreEqv S M).r x y := by\n  simp only [r_iff_exists, Subtype.exists, exists_prop, OreLocalization.oreEqv, smul_eq_mul,\n    Submonoid.mk_smul]\n  constructor\n  · rintro ⟨u, hu, e⟩\n    exact ⟨_, mul_mem hu x.2.2, u * y.2, by rw [mul_assoc, mul_assoc, ← e], mul_right_comm _ _ _⟩\n  · rintro ⟨u, hu, v, e₁, e₂⟩\n    exact ⟨u, hu, by rw [← mul_assoc, e₂, mul_right_comm, ← e₁, mul_assoc, mul_comm y.1]⟩\n\n"}
{"name":"AddLocalization.mk_eq_mk_iff","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\na c : M\nb d : Subtype fun x => Membership.mem S x\n⊢ Iff (Eq (AddLocalization.mk a b) (AddLocalization.mk c d)) ((AddLocalization.r S) { fst := a, snd := b } { fst := c, snd := d })","decl":"@[to_additive]\ntheorem mk_eq_mk_iff {a c : M} {b d : S} : mk a b = mk c d ↔ r S ⟨a, b⟩ ⟨c, d⟩ := by\n  rw [mk, mk, OreLocalization.oreDiv_eq_iff, r_iff_oreEqv_r]; rfl\n\n"}
{"name":"Localization.mk_eq_mk_iff","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\na c : M\nb d : Subtype fun x => Membership.mem S x\n⊢ Iff (Eq (Localization.mk a b) (Localization.mk c d)) ((Localization.r S) { fst := a, snd := b } { fst := c, snd := d })","decl":"@[to_additive]\ntheorem mk_eq_mk_iff {a c : M} {b d : S} : mk a b = mk c d ↔ r S ⟨a, b⟩ ⟨c, d⟩ := by\n  rw [mk, mk, OreLocalization.oreDiv_eq_iff, r_iff_oreEqv_r]; rfl\n\n"}
{"name":"AddLocalization.mk_add","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\na c : M\nb d : Subtype fun x => Membership.mem S x\n⊢ Eq (HAdd.hAdd (AddLocalization.mk a b) (AddLocalization.mk c d)) (AddLocalization.mk (HAdd.hAdd a c) (HAdd.hAdd b d))","decl":"@[to_additive]\ntheorem mk_mul (a c : M) (b d : S) : mk a b * mk c d = mk (a * c) (b * d) :=\n  mul_comm b d ▸ OreLocalization.oreDiv_mul_oreDiv\n\n"}
{"name":"Localization.mk_mul","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\na c : M\nb d : Subtype fun x => Membership.mem S x\n⊢ Eq (HMul.hMul (Localization.mk a b) (Localization.mk c d)) (Localization.mk (HMul.hMul a c) (HMul.hMul b d))","decl":"@[to_additive]\ntheorem mk_mul (a c : M) (b d : S) : mk a b * mk c d = mk (a * c) (b * d) :=\n  mul_comm b d ▸ OreLocalization.oreDiv_mul_oreDiv\n\n"}
{"name":"AddLocalization.mk_zero","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\n⊢ Eq (AddLocalization.mk 0 0) 0","decl":"unseal OreLocalization.one in\n@[to_additive]\ntheorem mk_one : mk 1 (1 : S) = 1 := OreLocalization.one_def\n\n"}
{"name":"Localization.mk_one","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\n⊢ Eq (Localization.mk 1 1) 1","decl":"unseal OreLocalization.one in\n@[to_additive]\ntheorem mk_one : mk 1 (1 : S) = 1 := OreLocalization.one_def\n\n"}
{"name":"Localization.mk_pow","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\nn : Nat\na : M\nb : Subtype fun x => Membership.mem S x\n⊢ Eq (HPow.hPow (Localization.mk a b) n) (Localization.mk (HPow.hPow a n) (HPow.hPow b n))","decl":"@[to_additive]\ntheorem mk_pow (n : ℕ) (a : M) (b : S) : mk a b ^ n = mk (a ^ n) (b ^ n) := by\n  induction n <;> simp [pow_succ, *, ← mk_mul, ← mk_one]\n\n-- Porting note: mathport translated `rec` to `ndrec` in the name of this lemma\n"}
{"name":"AddLocalization.mk_nsmul","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\nn : Nat\na : M\nb : Subtype fun x => Membership.mem S x\n⊢ Eq (HSMul.hSMul n (AddLocalization.mk a b)) (AddLocalization.mk (HSMul.hSMul n a) (HSMul.hSMul n b))","decl":"@[to_additive]\ntheorem mk_pow (n : ℕ) (a : M) (b : S) : mk a b ^ n = mk (a ^ n) (b ^ n) := by\n  induction n <;> simp [pow_succ, *, ← mk_mul, ← mk_one]\n\n-- Porting note: mathport translated `rec` to `ndrec` in the name of this lemma\n"}
{"name":"Localization.ndrec_mk","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\np : Localization S → Sort u\nf : (a : M) → (b : Subtype fun x => Membership.mem S x) → p (Localization.mk a b)\nH : ∀ {a c : M} {b d : Subtype fun x => Membership.mem S x} (h : (Localization.r S) { fst := a, snd := b } { fst := c, snd := d }), Eq (Eq.ndrec (f a b) ⋯) (f c d)\na : M\nb : Subtype fun x => Membership.mem S x\n⊢ Eq (Localization.rec f H (Localization.mk a b)) (f a b)","decl":"@[to_additive (attr := simp)]\ntheorem ndrec_mk {p : Localization S → Sort u} (f : ∀ (a : M) (b : S), p (mk a b)) (H) (a : M)\n    (b : S) : (rec f H (mk a b) : p (mk a b)) = f a b := rfl\n\n"}
{"name":"AddLocalization.ndrec_mk","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\np : AddLocalization S → Sort u\nf : (a : M) → (b : Subtype fun x => Membership.mem S x) → p (AddLocalization.mk a b)\nH : ∀ {a c : M} {b d : Subtype fun x => Membership.mem S x} (h : (AddLocalization.r S) { fst := a, snd := b } { fst := c, snd := d }), Eq (Eq.ndrec (f a b) ⋯) (f c d)\na : M\nb : Subtype fun x => Membership.mem S x\n⊢ Eq (AddLocalization.rec f H (AddLocalization.mk a b)) (f a b)","decl":"@[to_additive (attr := simp)]\ntheorem ndrec_mk {p : Localization S → Sort u} (f : ∀ (a : M) (b : S), p (mk a b)) (H) (a : M)\n    (b : S) : (rec f H (mk a b) : p (mk a b)) = f a b := rfl\n\n"}
{"name":"AddLocalization.liftOn_mk","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\np : Sort u\nf : M → (Subtype fun x => Membership.mem S x) → p\nH : ∀ {a c : M} {b d : Subtype fun x => Membership.mem S x}, (AddLocalization.r S) { fst := a, snd := b } { fst := c, snd := d } → Eq (f a b) (f c d)\na : M\nb : Subtype fun x => Membership.mem S x\n⊢ Eq ((AddLocalization.mk a b).liftOn f H) (f a b)","decl":"@[to_additive]\ntheorem liftOn_mk {p : Sort u} (f : M → S → p) (H) (a : M) (b : S) :\n    liftOn (mk a b) f H = f a b := rfl\n\n"}
{"name":"Localization.liftOn_mk","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\np : Sort u\nf : M → (Subtype fun x => Membership.mem S x) → p\nH : ∀ {a c : M} {b d : Subtype fun x => Membership.mem S x}, (Localization.r S) { fst := a, snd := b } { fst := c, snd := d } → Eq (f a b) (f c d)\na : M\nb : Subtype fun x => Membership.mem S x\n⊢ Eq ((Localization.mk a b).liftOn f H) (f a b)","decl":"@[to_additive]\ntheorem liftOn_mk {p : Sort u} (f : M → S → p) (H) (a : M) (b : S) :\n    liftOn (mk a b) f H = f a b := rfl\n\n"}
{"name":"Localization.ind","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\np : Localization S → Prop\nH : ∀ (y : Prod M (Subtype fun x => Membership.mem S x)), p (Localization.mk y.1 y.2)\nx : Localization S\n⊢ p x","decl":"@[to_additive (attr := elab_as_elim, induction_eliminator, cases_eliminator)]\ntheorem ind {p : Localization S → Prop} (H : ∀ y : M × S, p (mk y.1 y.2)) (x) : p x :=\n  rec (fun a b ↦ H (a, b)) (fun _ ↦ rfl) x\n\n"}
{"name":"AddLocalization.ind","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\np : AddLocalization S → Prop\nH : ∀ (y : Prod M (Subtype fun x => Membership.mem S x)), p (AddLocalization.mk y.1 y.2)\nx : AddLocalization S\n⊢ p x","decl":"@[to_additive (attr := elab_as_elim, induction_eliminator, cases_eliminator)]\ntheorem ind {p : Localization S → Prop} (H : ∀ y : M × S, p (mk y.1 y.2)) (x) : p x :=\n  rec (fun a b ↦ H (a, b)) (fun _ ↦ rfl) x\n\n"}
{"name":"AddLocalization.induction_on","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\np : AddLocalization S → Prop\nx : AddLocalization S\nH : ∀ (y : Prod M (Subtype fun x => Membership.mem S x)), p (AddLocalization.mk y.1 y.2)\n⊢ p x","decl":"@[to_additive (attr := elab_as_elim)]\ntheorem induction_on {p : Localization S → Prop} (x) (H : ∀ y : M × S, p (mk y.1 y.2)) : p x :=\n  ind H x\n\n"}
{"name":"Localization.induction_on","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\np : Localization S → Prop\nx : Localization S\nH : ∀ (y : Prod M (Subtype fun x => Membership.mem S x)), p (Localization.mk y.1 y.2)\n⊢ p x","decl":"@[to_additive (attr := elab_as_elim)]\ntheorem induction_on {p : Localization S → Prop} (x) (H : ∀ y : M × S, p (mk y.1 y.2)) : p x :=\n  ind H x\n\n"}
{"name":"Localization.liftOn₂_mk","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\np : Sort u_4\nf : M → (Subtype fun x => Membership.mem S x) → M → (Subtype fun x => Membership.mem S x) → p\nH : ∀ {a a' : M} {b b' : Subtype fun x => Membership.mem S x} {c c' : M} {d d' : Subtype fun x => Membership.mem S x}, (Localization.r S) { fst := a, snd := b } { fst := a', snd := b' } → (Localization.r S) { fst := c, snd := d } { fst := c', snd := d' } → Eq (f a b c d) (f a' b' c' d')\na c : M\nb d : Subtype fun x => Membership.mem S x\n⊢ Eq ((Localization.mk a b).liftOn₂ (Localization.mk c d) f H) (f a b c d)","decl":"@[to_additive]\ntheorem liftOn₂_mk {p : Sort*} (f : M → S → M → S → p) (H) (a c : M) (b d : S) :\n    liftOn₂ (mk a b) (mk c d) f H = f a b c d := rfl\n\n"}
{"name":"AddLocalization.liftOn₂_mk","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\np : Sort u_4\nf : M → (Subtype fun x => Membership.mem S x) → M → (Subtype fun x => Membership.mem S x) → p\nH : ∀ {a a' : M} {b b' : Subtype fun x => Membership.mem S x} {c c' : M} {d d' : Subtype fun x => Membership.mem S x}, (AddLocalization.r S) { fst := a, snd := b } { fst := a', snd := b' } → (AddLocalization.r S) { fst := c, snd := d } { fst := c', snd := d' } → Eq (f a b c d) (f a' b' c' d')\na c : M\nb d : Subtype fun x => Membership.mem S x\n⊢ Eq ((AddLocalization.mk a b).liftOn₂ (AddLocalization.mk c d) f H) (f a b c d)","decl":"@[to_additive]\ntheorem liftOn₂_mk {p : Sort*} (f : M → S → M → S → p) (H) (a c : M) (b d : S) :\n    liftOn₂ (mk a b) (mk c d) f H = f a b c d := rfl\n\n"}
{"name":"Localization.induction_on₂","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\np : Localization S → Localization S → Prop\nx y : Localization S\nH : ∀ (x y : Prod M (Subtype fun x => Membership.mem S x)), p (Localization.mk x.1 x.2) (Localization.mk y.1 y.2)\n⊢ p x y","decl":"@[to_additive (attr := elab_as_elim)]\ntheorem induction_on₂ {p : Localization S → Localization S → Prop} (x y)\n    (H : ∀ x y : M × S, p (mk x.1 x.2) (mk y.1 y.2)) : p x y :=\n  induction_on x fun x ↦ induction_on y <| H x\n\n"}
{"name":"AddLocalization.induction_on₂","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\np : AddLocalization S → AddLocalization S → Prop\nx y : AddLocalization S\nH : ∀ (x y : Prod M (Subtype fun x => Membership.mem S x)), p (AddLocalization.mk x.1 x.2) (AddLocalization.mk y.1 y.2)\n⊢ p x y","decl":"@[to_additive (attr := elab_as_elim)]\ntheorem induction_on₂ {p : Localization S → Localization S → Prop} (x y)\n    (H : ∀ x y : M × S, p (mk x.1 x.2) (mk y.1 y.2)) : p x y :=\n  induction_on x fun x ↦ induction_on y <| H x\n\n"}
{"name":"AddLocalization.induction_on₃","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\np : AddLocalization S → AddLocalization S → AddLocalization S → Prop\nx y z : AddLocalization S\nH : ∀ (x y z : Prod M (Subtype fun x => Membership.mem S x)), p (AddLocalization.mk x.1 x.2) (AddLocalization.mk y.1 y.2) (AddLocalization.mk z.1 z.2)\n⊢ p x y z","decl":"@[to_additive (attr := elab_as_elim)]\ntheorem induction_on₃ {p : Localization S → Localization S → Localization S → Prop} (x y z)\n    (H : ∀ x y z : M × S, p (mk x.1 x.2) (mk y.1 y.2) (mk z.1 z.2)) : p x y z :=\n  induction_on₂ x y fun x y ↦ induction_on z <| H x y\n\n"}
{"name":"Localization.induction_on₃","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\np : Localization S → Localization S → Localization S → Prop\nx y z : Localization S\nH : ∀ (x y z : Prod M (Subtype fun x => Membership.mem S x)), p (Localization.mk x.1 x.2) (Localization.mk y.1 y.2) (Localization.mk z.1 z.2)\n⊢ p x y z","decl":"@[to_additive (attr := elab_as_elim)]\ntheorem induction_on₃ {p : Localization S → Localization S → Localization S → Prop} (x y z)\n    (H : ∀ x y z : M × S, p (mk x.1 x.2) (mk y.1 y.2) (mk z.1 z.2)) : p x y z :=\n  induction_on₂ x y fun x y ↦ induction_on z <| H x y\n\n"}
{"name":"AddLocalization.zero_rel","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\ny : Subtype fun x => Membership.mem S x\n⊢ (AddLocalization.r S) 0 { fst := ↑y, snd := y }","decl":"@[to_additive]\ntheorem one_rel (y : S) : r S 1 (y, y) := fun _ hb ↦ hb y\n\n"}
{"name":"Localization.one_rel","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\ny : Subtype fun x => Membership.mem S x\n⊢ (Localization.r S) 1 { fst := ↑y, snd := y }","decl":"@[to_additive]\ntheorem one_rel (y : S) : r S 1 (y, y) := fun _ hb ↦ hb y\n\n"}
{"name":"AddLocalization.r_of_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\nx y : Prod M (Subtype fun x => Membership.mem S x)\nh : Eq (HAdd.hAdd (↑y.2) x.1) (HAdd.hAdd (↑x.2) y.1)\n⊢ (AddLocalization.r S) x y","decl":"@[to_additive]\ntheorem r_of_eq {x y : M × S} (h : ↑y.2 * x.1 = ↑x.2 * y.1) : r S x y :=\n  r_iff_exists.2 ⟨1, by rw [h]⟩\n\n"}
{"name":"Localization.r_of_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\nx y : Prod M (Subtype fun x => Membership.mem S x)\nh : Eq (HMul.hMul (↑y.2) x.1) (HMul.hMul (↑x.2) y.1)\n⊢ (Localization.r S) x y","decl":"@[to_additive]\ntheorem r_of_eq {x y : M × S} (h : ↑y.2 * x.1 = ↑x.2 * y.1) : r S x y :=\n  r_iff_exists.2 ⟨1, by rw [h]⟩\n\n"}
{"name":"AddLocalization.mk_self","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\na : Subtype fun x => Membership.mem S x\n⊢ Eq (AddLocalization.mk (↑a) a) 0","decl":"@[to_additive]\ntheorem mk_self (a : S) : mk (a : M) a = 1 := by\n  symm\n  rw [← mk_one, mk_eq_mk_iff]\n  exact one_rel a\n\n"}
{"name":"Localization.mk_self","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\na : Subtype fun x => Membership.mem S x\n⊢ Eq (Localization.mk (↑a) a) 1","decl":"@[to_additive]\ntheorem mk_self (a : S) : mk (a : M) a = 1 := by\n  symm\n  rw [← mk_one, mk_eq_mk_iff]\n  exact one_rel a\n\n"}
{"name":"Localization.smul_mk","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nR : Type u_4\ninst✝¹ : SMul R M\ninst✝ : IsScalarTower R M M\nc : R\na : M\nb : Subtype fun x => Membership.mem S x\n⊢ Eq (HSMul.hSMul c (Localization.mk a b)) (Localization.mk (HSMul.hSMul c a) b)","decl":"theorem smul_mk [SMul R M] [IsScalarTower R M M] (c : R) (a b) :\n    c • (mk a b : Localization S) = mk (c • a) b := by\n  rw [mk, mk, ← OreLocalization.smul_one_oreDiv_one_smul, OreLocalization.oreDiv_smul_oreDiv]\n  show (c • 1) • a /ₒ (b * 1) = _\n  rw [smul_assoc, one_smul, mul_one]\n\n-- move me\n"}
{"name":"Localization.instSMulCommClassOfIsScalarTower","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"R : Type u_7\nM : Type u_8\ninst✝² : CommMonoid M\ninst✝¹ : SMul R M\ninst✝ : IsScalarTower R M M\n⊢ SMulCommClass R M M","decl":"instance {R M : Type*} [CommMonoid M] [SMul R M] [IsScalarTower R M M] : SMulCommClass R M M where\n  smul_comm r s x := by\n    rw [← one_smul M (s • x), ← smul_assoc, smul_comm, smul_assoc, one_smul]\n\n-- Note: Previously there was a `MulDistribMulAction R (Localization S)`.\n-- It was removed as it is not the correct action.\n\n"}
{"name":"Submonoid.LocalizationMap.ext","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf g : S.LocalizationMap N\nh : ∀ (x : M), Eq (f.toMap x) (g.toMap x)\n⊢ Eq f g","decl":"@[to_additive (attr := ext)]\ntheorem ext {f g : LocalizationMap S N} (h : ∀ x, f.toMap x = g.toMap x) : f = g := by\n  rcases f with ⟨⟨⟩⟩\n  rcases g with ⟨⟨⟩⟩\n  simp only [mk.injEq, MonoidHom.mk.injEq]\n  exact OneHom.ext h\n\n"}
{"name":"Submonoid.LocalizationMap.ext_iff","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf g : S.LocalizationMap N\n⊢ Iff (Eq f g) (∀ (x : M), Eq (f.toMap x) (g.toMap x))","decl":"@[to_additive (attr := ext)]\ntheorem ext {f g : LocalizationMap S N} (h : ∀ x, f.toMap x = g.toMap x) : f = g := by\n  rcases f with ⟨⟨⟩⟩\n  rcases g with ⟨⟨⟩⟩\n  simp only [mk.injEq, MonoidHom.mk.injEq]\n  exact OneHom.ext h\n\n"}
{"name":"AddSubmonoid.LocalizationMap.ext","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf g : S.LocalizationMap N\nh : ∀ (x : M), Eq (f.toMap x) (g.toMap x)\n⊢ Eq f g","decl":"@[to_additive (attr := ext)]\ntheorem ext {f g : LocalizationMap S N} (h : ∀ x, f.toMap x = g.toMap x) : f = g := by\n  rcases f with ⟨⟨⟩⟩\n  rcases g with ⟨⟨⟩⟩\n  simp only [mk.injEq, MonoidHom.mk.injEq]\n  exact OneHom.ext h\n\n"}
{"name":"AddSubmonoid.LocalizationMap.ext_iff","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf g : S.LocalizationMap N\n⊢ Iff (Eq f g) (∀ (x : M), Eq (f.toMap x) (g.toMap x))","decl":"@[to_additive (attr := ext)]\ntheorem ext {f g : LocalizationMap S N} (h : ∀ x, f.toMap x = g.toMap x) : f = g := by\n  rcases f with ⟨⟨⟩⟩\n  rcases g with ⟨⟨⟩⟩\n  simp only [mk.injEq, MonoidHom.mk.injEq]\n  exact OneHom.ext h\n\n"}
{"name":"AddSubmonoid.LocalizationMap.toMap_injective","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\n⊢ Function.Injective AddSubmonoid.LocalizationMap.toMap","decl":"@[to_additive]\ntheorem toMap_injective : Function.Injective (@LocalizationMap.toMap _ _ S N _) :=\n  fun _ _ h ↦ ext <| DFunLike.ext_iff.1 h\n\n"}
{"name":"Submonoid.LocalizationMap.toMap_injective","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\n⊢ Function.Injective Submonoid.LocalizationMap.toMap","decl":"@[to_additive]\ntheorem toMap_injective : Function.Injective (@LocalizationMap.toMap _ _ S N _) :=\n  fun _ _ h ↦ ext <| DFunLike.ext_iff.1 h\n\n"}
{"name":"AddSubmonoid.LocalizationMap.map_addUnits","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\ny : Subtype fun x => Membership.mem S x\n⊢ IsAddUnit (f.toMap ↑y)","decl":"@[to_additive]\ntheorem map_units (f : LocalizationMap S N) (y : S) : IsUnit (f.toMap y) :=\n  f.2 y\n\n"}
{"name":"Submonoid.LocalizationMap.map_units","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\ny : Subtype fun x => Membership.mem S x\n⊢ IsUnit (f.toMap ↑y)","decl":"@[to_additive]\ntheorem map_units (f : LocalizationMap S N) (y : S) : IsUnit (f.toMap y) :=\n  f.2 y\n\n"}
{"name":"AddSubmonoid.LocalizationMap.surj","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nz : N\n⊢ Exists fun x => Eq (HAdd.hAdd z (f.toMap ↑x.2)) (f.toMap x.1)","decl":"@[to_additive]\ntheorem surj (f : LocalizationMap S N) (z : N) : ∃ x : M × S, z * f.toMap x.2 = f.toMap x.1 :=\n  f.3 z\n\n"}
{"name":"Submonoid.LocalizationMap.surj","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nz : N\n⊢ Exists fun x => Eq (HMul.hMul z (f.toMap ↑x.2)) (f.toMap x.1)","decl":"@[to_additive]\ntheorem surj (f : LocalizationMap S N) (z : N) : ∃ x : M × S, z * f.toMap x.2 = f.toMap x.1 :=\n  f.3 z\n\n"}
{"name":"AddSubmonoid.LocalizationMap.surj₂","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nz w : N\n⊢ Exists fun z' => Exists fun w' => Exists fun d => And (Eq (HAdd.hAdd z (f.toMap ↑d)) (f.toMap z')) (Eq (HAdd.hAdd w (f.toMap ↑d)) (f.toMap w'))","decl":"/-- Given a localization map `f : M →* N`, and `z w : N`, there exist `z' w' : M` and `d : S`\nsuch that `f z' / f d = z` and `f w' / f d = w`. -/\n@[to_additive\n    \"Given a localization map `f : M →+ N`, and `z w : N`, there exist `z' w' : M` and `d : S`\nsuch that `f z' - f d = z` and `f w' - f d = w`.\"]\ntheorem surj₂ (f : LocalizationMap S N) (z w : N) : ∃ z' w' : M, ∃ d : S,\n    (z * f.toMap d = f.toMap z') ∧  (w * f.toMap d = f.toMap w') := by\n  let ⟨a, ha⟩ := surj f z\n  let ⟨b, hb⟩ := surj f w\n  refine ⟨a.1 * b.2, a.2 * b.1, a.2 * b.2, ?_, ?_⟩\n  · simp_rw [mul_def, map_mul, ← ha]\n    exact (mul_assoc z _ _).symm\n  · simp_rw [mul_def, map_mul, ← hb]\n    exact mul_left_comm w _ _\n\n"}
{"name":"Submonoid.LocalizationMap.surj₂","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nz w : N\n⊢ Exists fun z' => Exists fun w' => Exists fun d => And (Eq (HMul.hMul z (f.toMap ↑d)) (f.toMap z')) (Eq (HMul.hMul w (f.toMap ↑d)) (f.toMap w'))","decl":"/-- Given a localization map `f : M →* N`, and `z w : N`, there exist `z' w' : M` and `d : S`\nsuch that `f z' / f d = z` and `f w' / f d = w`. -/\n@[to_additive\n    \"Given a localization map `f : M →+ N`, and `z w : N`, there exist `z' w' : M` and `d : S`\nsuch that `f z' - f d = z` and `f w' - f d = w`.\"]\ntheorem surj₂ (f : LocalizationMap S N) (z w : N) : ∃ z' w' : M, ∃ d : S,\n    (z * f.toMap d = f.toMap z') ∧  (w * f.toMap d = f.toMap w') := by\n  let ⟨a, ha⟩ := surj f z\n  let ⟨b, hb⟩ := surj f w\n  refine ⟨a.1 * b.2, a.2 * b.1, a.2 * b.2, ?_, ?_⟩\n  · simp_rw [mul_def, map_mul, ← ha]\n    exact (mul_assoc z _ _).symm\n  · simp_rw [mul_def, map_mul, ← hb]\n    exact mul_left_comm w _ _\n\n"}
{"name":"Submonoid.LocalizationMap.eq_iff_exists","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx y : M\n⊢ Iff (Eq (f.toMap x) (f.toMap y)) (Exists fun c => Eq (HMul.hMul (↑c) x) (HMul.hMul (↑c) y))","decl":"@[to_additive]\ntheorem eq_iff_exists (f : LocalizationMap S N) {x y} :\n    f.toMap x = f.toMap y ↔ ∃ c : S, ↑c * x = c * y := Iff.intro (f.4 x y)\n  fun ⟨c, h⟩ ↦ by\n    replace h := congr_arg f.toMap h\n    rw [map_mul, map_mul] at h\n    exact (f.map_units c).mul_right_inj.mp h\n\n"}
{"name":"AddSubmonoid.LocalizationMap.eq_iff_exists","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx y : M\n⊢ Iff (Eq (f.toMap x) (f.toMap y)) (Exists fun c => Eq (HAdd.hAdd (↑c) x) (HAdd.hAdd (↑c) y))","decl":"@[to_additive]\ntheorem eq_iff_exists (f : LocalizationMap S N) {x y} :\n    f.toMap x = f.toMap y ↔ ∃ c : S, ↑c * x = c * y := Iff.intro (f.4 x y)\n  fun ⟨c, h⟩ ↦ by\n    replace h := congr_arg f.toMap h\n    rw [map_mul, map_mul] at h\n    exact (f.map_units c).mul_right_inj.mp h\n\n"}
{"name":"Submonoid.LocalizationMap.sec_spec","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nz : N\n⊢ Eq (HMul.hMul z (f.toMap ↑(f.sec z).2)) (f.toMap (f.sec z).1)","decl":"@[to_additive]\ntheorem sec_spec {f : LocalizationMap S N} (z : N) :\n    z * f.toMap (f.sec z).2 = f.toMap (f.sec z).1 := Classical.choose_spec <| f.surj z\n\n"}
{"name":"AddSubmonoid.LocalizationMap.sec_spec","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nz : N\n⊢ Eq (HAdd.hAdd z (f.toMap ↑(f.sec z).2)) (f.toMap (f.sec z).1)","decl":"@[to_additive]\ntheorem sec_spec {f : LocalizationMap S N} (z : N) :\n    z * f.toMap (f.sec z).2 = f.toMap (f.sec z).1 := Classical.choose_spec <| f.surj z\n\n"}
{"name":"AddSubmonoid.LocalizationMap.sec_spec'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nz : N\n⊢ Eq (f.toMap (f.sec z).1) (HAdd.hAdd (f.toMap ↑(f.sec z).2) z)","decl":"@[to_additive]\ntheorem sec_spec' {f : LocalizationMap S N} (z : N) :\n    f.toMap (f.sec z).1 = f.toMap (f.sec z).2 * z := by rw [mul_comm, sec_spec]\n\n"}
{"name":"Submonoid.LocalizationMap.sec_spec'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nz : N\n⊢ Eq (f.toMap (f.sec z).1) (HMul.hMul (f.toMap ↑(f.sec z).2) z)","decl":"@[to_additive]\ntheorem sec_spec' {f : LocalizationMap S N} (z : N) :\n    f.toMap (f.sec z).1 = f.toMap (f.sec z).2 * z := by rw [mul_comm, sec_spec]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.add_neg_left","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : AddMonoidHom M N\nh : ∀ (y : Subtype fun x => Membership.mem S x), IsAddUnit (f ↑y)\ny : Subtype fun x => Membership.mem S x\nw z : N\n⊢ Iff (Eq (HAdd.hAdd w ↑(Neg.neg ((IsAddUnit.liftRight (f.restrict S) h) y))) z) (Eq w (HAdd.hAdd (f ↑y) z))","decl":"/-- Given a MonoidHom `f : M →* N` and Submonoid `S ⊆ M` such that `f(S) ⊆ Nˣ`, for all\n`w, z : N` and `y ∈ S`, we have `w * (f y)⁻¹ = z ↔ w = f y * z`. -/\n@[to_additive\n    \"Given an AddMonoidHom `f : M →+ N` and Submonoid `S ⊆ M` such that\n`f(S) ⊆ AddUnits N`, for all `w, z : N` and `y ∈ S`, we have `w - f y = z ↔ w = f y + z`.\"]\ntheorem mul_inv_left {f : M →* N} (h : ∀ y : S, IsUnit (f y)) (y : S) (w z : N) :\n    w * (IsUnit.liftRight (f.restrict S) h y)⁻¹ = z ↔ w = f y * z := by\n  rw [mul_comm]\n  exact Units.inv_mul_eq_iff_eq_mul (IsUnit.liftRight (f.restrict S) h y)\n\n"}
{"name":"Submonoid.LocalizationMap.mul_inv_left","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : MonoidHom M N\nh : ∀ (y : Subtype fun x => Membership.mem S x), IsUnit (f ↑y)\ny : Subtype fun x => Membership.mem S x\nw z : N\n⊢ Iff (Eq (HMul.hMul w ↑(Inv.inv ((IsUnit.liftRight (f.restrict S) h) y))) z) (Eq w (HMul.hMul (f ↑y) z))","decl":"/-- Given a MonoidHom `f : M →* N` and Submonoid `S ⊆ M` such that `f(S) ⊆ Nˣ`, for all\n`w, z : N` and `y ∈ S`, we have `w * (f y)⁻¹ = z ↔ w = f y * z`. -/\n@[to_additive\n    \"Given an AddMonoidHom `f : M →+ N` and Submonoid `S ⊆ M` such that\n`f(S) ⊆ AddUnits N`, for all `w, z : N` and `y ∈ S`, we have `w - f y = z ↔ w = f y + z`.\"]\ntheorem mul_inv_left {f : M →* N} (h : ∀ y : S, IsUnit (f y)) (y : S) (w z : N) :\n    w * (IsUnit.liftRight (f.restrict S) h y)⁻¹ = z ↔ w = f y * z := by\n  rw [mul_comm]\n  exact Units.inv_mul_eq_iff_eq_mul (IsUnit.liftRight (f.restrict S) h y)\n\n"}
{"name":"AddSubmonoid.LocalizationMap.add_neg_right","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : AddMonoidHom M N\nh : ∀ (y : Subtype fun x => Membership.mem S x), IsAddUnit (f ↑y)\ny : Subtype fun x => Membership.mem S x\nw z : N\n⊢ Iff (Eq z (HAdd.hAdd w ↑(Neg.neg ((IsAddUnit.liftRight (f.restrict S) h) y)))) (Eq (HAdd.hAdd z (f ↑y)) w)","decl":"/-- Given a MonoidHom `f : M →* N` and Submonoid `S ⊆ M` such that `f(S) ⊆ Nˣ`, for all\n`w, z : N` and `y ∈ S`, we have `z = w * (f y)⁻¹ ↔ z * f y = w`. -/\n@[to_additive\n    \"Given an AddMonoidHom `f : M →+ N` and Submonoid `S ⊆ M` such that\n`f(S) ⊆ AddUnits N`, for all `w, z : N` and `y ∈ S`, we have `z = w - f y ↔ z + f y = w`.\"]\ntheorem mul_inv_right {f : M →* N} (h : ∀ y : S, IsUnit (f y)) (y : S) (w z : N) :\n    z = w * (IsUnit.liftRight (f.restrict S) h y)⁻¹ ↔ z * f y = w := by\n  rw [eq_comm, mul_inv_left h, mul_comm, eq_comm]\n\n"}
{"name":"Submonoid.LocalizationMap.mul_inv_right","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : MonoidHom M N\nh : ∀ (y : Subtype fun x => Membership.mem S x), IsUnit (f ↑y)\ny : Subtype fun x => Membership.mem S x\nw z : N\n⊢ Iff (Eq z (HMul.hMul w ↑(Inv.inv ((IsUnit.liftRight (f.restrict S) h) y)))) (Eq (HMul.hMul z (f ↑y)) w)","decl":"/-- Given a MonoidHom `f : M →* N` and Submonoid `S ⊆ M` such that `f(S) ⊆ Nˣ`, for all\n`w, z : N` and `y ∈ S`, we have `z = w * (f y)⁻¹ ↔ z * f y = w`. -/\n@[to_additive\n    \"Given an AddMonoidHom `f : M →+ N` and Submonoid `S ⊆ M` such that\n`f(S) ⊆ AddUnits N`, for all `w, z : N` and `y ∈ S`, we have `z = w - f y ↔ z + f y = w`.\"]\ntheorem mul_inv_right {f : M →* N} (h : ∀ y : S, IsUnit (f y)) (y : S) (w z : N) :\n    z = w * (IsUnit.liftRight (f.restrict S) h y)⁻¹ ↔ z * f y = w := by\n  rw [eq_comm, mul_inv_left h, mul_comm, eq_comm]\n\n"}
{"name":"Submonoid.LocalizationMap.mul_inv","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : MonoidHom M N\nh : ∀ (y : Subtype fun x => Membership.mem S x), IsUnit (f ↑y)\nx₁ x₂ : M\ny₁ y₂ : Subtype fun x => Membership.mem S x\n⊢ Iff (Eq (HMul.hMul (f x₁) ↑(Inv.inv ((IsUnit.liftRight (f.restrict S) h) y₁))) (HMul.hMul (f x₂) ↑(Inv.inv ((IsUnit.liftRight (f.restrict S) h) y₂)))) (Eq (f (HMul.hMul x₁ ↑y₂)) (f (HMul.hMul x₂ ↑y₁)))","decl":"/-- Given a MonoidHom `f : M →* N` and Submonoid `S ⊆ M` such that\n`f(S) ⊆ Nˣ`, for all `x₁ x₂ : M` and `y₁, y₂ ∈ S`, we have\n`f x₁ * (f y₁)⁻¹ = f x₂ * (f y₂)⁻¹ ↔ f (x₁ * y₂) = f (x₂ * y₁)`. -/\n@[to_additive (attr := simp)\n    \"Given an AddMonoidHom `f : M →+ N` and Submonoid `S ⊆ M` such that\n`f(S) ⊆ AddUnits N`, for all `x₁ x₂ : M` and `y₁, y₂ ∈ S`, we have\n`f x₁ - f y₁ = f x₂ - f y₂ ↔ f (x₁ + y₂) = f (x₂ + y₁)`.\"]\ntheorem mul_inv {f : M →* N} (h : ∀ y : S, IsUnit (f y)) {x₁ x₂} {y₁ y₂ : S} :\n    f x₁ * (IsUnit.liftRight (f.restrict S) h y₁)⁻¹ =\n        f x₂ * (IsUnit.liftRight (f.restrict S) h y₂)⁻¹ ↔\n      f (x₁ * y₂) = f (x₂ * y₁) := by\n  rw [mul_inv_right h, mul_assoc, mul_comm _ (f y₂), ← mul_assoc, mul_inv_left h, mul_comm x₂,\n    f.map_mul, f.map_mul]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.add_neg","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : AddMonoidHom M N\nh : ∀ (y : Subtype fun x => Membership.mem S x), IsAddUnit (f ↑y)\nx₁ x₂ : M\ny₁ y₂ : Subtype fun x => Membership.mem S x\n⊢ Iff (Eq (HAdd.hAdd (f x₁) ↑(Neg.neg ((IsAddUnit.liftRight (f.restrict S) h) y₁))) (HAdd.hAdd (f x₂) ↑(Neg.neg ((IsAddUnit.liftRight (f.restrict S) h) y₂)))) (Eq (f (HAdd.hAdd x₁ ↑y₂)) (f (HAdd.hAdd x₂ ↑y₁)))","decl":"/-- Given a MonoidHom `f : M →* N` and Submonoid `S ⊆ M` such that\n`f(S) ⊆ Nˣ`, for all `x₁ x₂ : M` and `y₁, y₂ ∈ S`, we have\n`f x₁ * (f y₁)⁻¹ = f x₂ * (f y₂)⁻¹ ↔ f (x₁ * y₂) = f (x₂ * y₁)`. -/\n@[to_additive (attr := simp)\n    \"Given an AddMonoidHom `f : M →+ N` and Submonoid `S ⊆ M` such that\n`f(S) ⊆ AddUnits N`, for all `x₁ x₂ : M` and `y₁, y₂ ∈ S`, we have\n`f x₁ - f y₁ = f x₂ - f y₂ ↔ f (x₁ + y₂) = f (x₂ + y₁)`.\"]\ntheorem mul_inv {f : M →* N} (h : ∀ y : S, IsUnit (f y)) {x₁ x₂} {y₁ y₂ : S} :\n    f x₁ * (IsUnit.liftRight (f.restrict S) h y₁)⁻¹ =\n        f x₂ * (IsUnit.liftRight (f.restrict S) h y₂)⁻¹ ↔\n      f (x₁ * y₂) = f (x₂ * y₁) := by\n  rw [mul_inv_right h, mul_assoc, mul_comm _ (f y₂), ← mul_assoc, mul_inv_left h, mul_comm x₂,\n    f.map_mul, f.map_mul]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.neg_inj","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : AddMonoidHom M N\nhf : ∀ (y : Subtype fun x => Membership.mem S x), IsAddUnit (f ↑y)\ny z : Subtype fun x => Membership.mem S x\nh : Eq (Neg.neg ((IsAddUnit.liftRight (f.restrict S) hf) y)) (Neg.neg ((IsAddUnit.liftRight (f.restrict S) hf) z))\n⊢ Eq (f ↑y) (f ↑z)","decl":"/-- Given a MonoidHom `f : M →* N` and Submonoid `S ⊆ M` such that `f(S) ⊆ Nˣ`, for all\n`y, z ∈ S`, we have `(f y)⁻¹ = (f z)⁻¹ → f y = f z`. -/\n@[to_additive\n    \"Given an AddMonoidHom `f : M →+ N` and Submonoid `S ⊆ M` such that\n`f(S) ⊆ AddUnits N`, for all `y, z ∈ S`, we have `- (f y) = - (f z) → f y = f z`.\"]\ntheorem inv_inj {f : M →* N} (hf : ∀ y : S, IsUnit (f y)) {y z : S}\n    (h : (IsUnit.liftRight (f.restrict S) hf y)⁻¹ = (IsUnit.liftRight (f.restrict S) hf z)⁻¹) :\n      f y = f z := by\n  rw [← mul_one (f y), eq_comm, ← mul_inv_left hf y (f z) 1, h]\n  exact Units.inv_mul (IsUnit.liftRight (f.restrict S) hf z)⁻¹\n\n"}
{"name":"Submonoid.LocalizationMap.inv_inj","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : MonoidHom M N\nhf : ∀ (y : Subtype fun x => Membership.mem S x), IsUnit (f ↑y)\ny z : Subtype fun x => Membership.mem S x\nh : Eq (Inv.inv ((IsUnit.liftRight (f.restrict S) hf) y)) (Inv.inv ((IsUnit.liftRight (f.restrict S) hf) z))\n⊢ Eq (f ↑y) (f ↑z)","decl":"/-- Given a MonoidHom `f : M →* N` and Submonoid `S ⊆ M` such that `f(S) ⊆ Nˣ`, for all\n`y, z ∈ S`, we have `(f y)⁻¹ = (f z)⁻¹ → f y = f z`. -/\n@[to_additive\n    \"Given an AddMonoidHom `f : M →+ N` and Submonoid `S ⊆ M` such that\n`f(S) ⊆ AddUnits N`, for all `y, z ∈ S`, we have `- (f y) = - (f z) → f y = f z`.\"]\ntheorem inv_inj {f : M →* N} (hf : ∀ y : S, IsUnit (f y)) {y z : S}\n    (h : (IsUnit.liftRight (f.restrict S) hf y)⁻¹ = (IsUnit.liftRight (f.restrict S) hf z)⁻¹) :\n      f y = f z := by\n  rw [← mul_one (f y), eq_comm, ← mul_inv_left hf y (f z) 1, h]\n  exact Units.inv_mul (IsUnit.liftRight (f.restrict S) hf z)⁻¹\n\n"}
{"name":"AddSubmonoid.LocalizationMap.neg_unique","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : AddMonoidHom M N\nh : ∀ (y : Subtype fun x => Membership.mem S x), IsAddUnit (f ↑y)\ny : Subtype fun x => Membership.mem S x\nz : N\nH : Eq (HAdd.hAdd (f ↑y) z) 0\n⊢ Eq (↑(Neg.neg ((IsAddUnit.liftRight (f.restrict S) h) y))) z","decl":"/-- Given a MonoidHom `f : M →* N` and Submonoid `S ⊆ M` such that `f(S) ⊆ Nˣ`, for all\n`y ∈ S`, `(f y)⁻¹` is unique. -/\n@[to_additive\n    \"Given an AddMonoidHom `f : M →+ N` and Submonoid `S ⊆ M` such that\n`f(S) ⊆ AddUnits N`, for all `y ∈ S`, `- (f y)` is unique.\"]\ntheorem inv_unique {f : M →* N} (h : ∀ y : S, IsUnit (f y)) {y : S} {z : N} (H : f y * z = 1) :\n    (IsUnit.liftRight (f.restrict S) h y)⁻¹ = z := by\n  rw [← one_mul _⁻¹, Units.val_mul, mul_inv_left]\n  exact H.symm\n\n"}
{"name":"Submonoid.LocalizationMap.inv_unique","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : MonoidHom M N\nh : ∀ (y : Subtype fun x => Membership.mem S x), IsUnit (f ↑y)\ny : Subtype fun x => Membership.mem S x\nz : N\nH : Eq (HMul.hMul (f ↑y) z) 1\n⊢ Eq (↑(Inv.inv ((IsUnit.liftRight (f.restrict S) h) y))) z","decl":"/-- Given a MonoidHom `f : M →* N` and Submonoid `S ⊆ M` such that `f(S) ⊆ Nˣ`, for all\n`y ∈ S`, `(f y)⁻¹` is unique. -/\n@[to_additive\n    \"Given an AddMonoidHom `f : M →+ N` and Submonoid `S ⊆ M` such that\n`f(S) ⊆ AddUnits N`, for all `y ∈ S`, `- (f y)` is unique.\"]\ntheorem inv_unique {f : M →* N} (h : ∀ y : S, IsUnit (f y)) {y : S} {z : N} (H : f y * z = 1) :\n    (IsUnit.liftRight (f.restrict S) h y)⁻¹ = z := by\n  rw [← one_mul _⁻¹, Units.val_mul, mul_inv_left]\n  exact H.symm\n\n"}
{"name":"AddSubmonoid.LocalizationMap.map_right_cancel","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx y : M\nc : Subtype fun x => Membership.mem S x\nh : Eq (f.toMap (HAdd.hAdd (↑c) x)) (f.toMap (HAdd.hAdd (↑c) y))\n⊢ Eq (f.toMap x) (f.toMap y)","decl":"@[to_additive]\ntheorem map_right_cancel {x y} {c : S} (h : f.toMap (c * x) = f.toMap (c * y)) :\n    f.toMap x = f.toMap y := by\n  rw [f.toMap.map_mul, f.toMap.map_mul] at h\n  let ⟨u, hu⟩ := f.map_units c\n  rw [← hu] at h\n  exact (Units.mul_right_inj u).1 h\n\n"}
{"name":"Submonoid.LocalizationMap.map_right_cancel","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx y : M\nc : Subtype fun x => Membership.mem S x\nh : Eq (f.toMap (HMul.hMul (↑c) x)) (f.toMap (HMul.hMul (↑c) y))\n⊢ Eq (f.toMap x) (f.toMap y)","decl":"@[to_additive]\ntheorem map_right_cancel {x y} {c : S} (h : f.toMap (c * x) = f.toMap (c * y)) :\n    f.toMap x = f.toMap y := by\n  rw [f.toMap.map_mul, f.toMap.map_mul] at h\n  let ⟨u, hu⟩ := f.map_units c\n  rw [← hu] at h\n  exact (Units.mul_right_inj u).1 h\n\n"}
{"name":"Submonoid.LocalizationMap.map_left_cancel","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx y : M\nc : Subtype fun x => Membership.mem S x\nh : Eq (f.toMap (HMul.hMul x ↑c)) (f.toMap (HMul.hMul y ↑c))\n⊢ Eq (f.toMap x) (f.toMap y)","decl":"@[to_additive]\ntheorem map_left_cancel {x y} {c : S} (h : f.toMap (x * c) = f.toMap (y * c)) :\n    f.toMap x = f.toMap y :=\n  f.map_right_cancel (c := c) <| by rw [mul_comm _ x, mul_comm _ y, h]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.map_left_cancel","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx y : M\nc : Subtype fun x => Membership.mem S x\nh : Eq (f.toMap (HAdd.hAdd x ↑c)) (f.toMap (HAdd.hAdd y ↑c))\n⊢ Eq (f.toMap x) (f.toMap y)","decl":"@[to_additive]\ntheorem map_left_cancel {x y} {c : S} (h : f.toMap (x * c) = f.toMap (y * c)) :\n    f.toMap x = f.toMap y :=\n  f.map_right_cancel (c := c) <| by rw [mul_comm _ x, mul_comm _ y, h]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.mk'_add","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx₁ x₂ : M\ny₁ y₂ : Subtype fun x => Membership.mem S x\n⊢ Eq (f.mk' (HAdd.hAdd x₁ x₂) (HAdd.hAdd y₁ y₂)) (HAdd.hAdd (f.mk' x₁ y₁) (f.mk' x₂ y₂))","decl":"@[to_additive]\ntheorem mk'_mul (x₁ x₂ : M) (y₁ y₂ : S) : f.mk' (x₁ * x₂) (y₁ * y₂) = f.mk' x₁ y₁ * f.mk' x₂ y₂ :=\n  (mul_inv_left f.map_units _ _ _).2 <|\n    show _ = _ * (_ * _ * (_ * _)) by\n      rw [← mul_assoc, ← mul_assoc, mul_inv_right f.map_units, mul_assoc, mul_assoc,\n          mul_comm _ (f.toMap x₂), ← mul_assoc, ← mul_assoc, mul_inv_right f.map_units,\n          Submonoid.coe_mul, f.toMap.map_mul, f.toMap.map_mul]\n      ac_rfl\n\n"}
{"name":"Submonoid.LocalizationMap.mk'_mul","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx₁ x₂ : M\ny₁ y₂ : Subtype fun x => Membership.mem S x\n⊢ Eq (f.mk' (HMul.hMul x₁ x₂) (HMul.hMul y₁ y₂)) (HMul.hMul (f.mk' x₁ y₁) (f.mk' x₂ y₂))","decl":"@[to_additive]\ntheorem mk'_mul (x₁ x₂ : M) (y₁ y₂ : S) : f.mk' (x₁ * x₂) (y₁ * y₂) = f.mk' x₁ y₁ * f.mk' x₂ y₂ :=\n  (mul_inv_left f.map_units _ _ _).2 <|\n    show _ = _ * (_ * _ * (_ * _)) by\n      rw [← mul_assoc, ← mul_assoc, mul_inv_right f.map_units, mul_assoc, mul_assoc,\n          mul_comm _ (f.toMap x₂), ← mul_assoc, ← mul_assoc, mul_inv_right f.map_units,\n          Submonoid.coe_mul, f.toMap.map_mul, f.toMap.map_mul]\n      ac_rfl\n\n"}
{"name":"AddSubmonoid.LocalizationMap.mk'_zero","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx : M\n⊢ Eq (f.mk' x 0) (f.toMap x)","decl":"@[to_additive]\ntheorem mk'_one (x) : f.mk' x (1 : S) = f.toMap x := by\n  rw [mk', MonoidHom.map_one]\n  exact mul_one _\n\n"}
{"name":"Submonoid.LocalizationMap.mk'_one","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx : M\n⊢ Eq (f.mk' x 1) (f.toMap x)","decl":"@[to_additive]\ntheorem mk'_one (x) : f.mk' x (1 : S) = f.toMap x := by\n  rw [mk', MonoidHom.map_one]\n  exact mul_one _\n\n"}
{"name":"AddSubmonoid.LocalizationMap.mk'_sec","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nz : N\n⊢ Eq (f.mk' (f.sec z).1 (f.sec z).2) z","decl":"/-- Given a localization map `f : M →* N` for a submonoid `S ⊆ M`, for all `z : N` we have that if\n`x : M, y ∈ S` are such that `z * f y = f x`, then `f x * (f y)⁻¹ = z`. -/\n@[to_additive (attr := simp)\n    \"Given a localization map `f : M →+ N` for a Submonoid `S ⊆ M`, for all `z : N`\nwe have that if `x : M, y ∈ S` are such that `z + f y = f x`, then `f x - f y = z`.\"]\ntheorem mk'_sec (z : N) : f.mk' (f.sec z).1 (f.sec z).2 = z :=\n  show _ * _ = _ by rw [← sec_spec, mul_inv_left, mul_comm]\n\n"}
{"name":"Submonoid.LocalizationMap.mk'_sec","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nz : N\n⊢ Eq (f.mk' (f.sec z).1 (f.sec z).2) z","decl":"/-- Given a localization map `f : M →* N` for a submonoid `S ⊆ M`, for all `z : N` we have that if\n`x : M, y ∈ S` are such that `z * f y = f x`, then `f x * (f y)⁻¹ = z`. -/\n@[to_additive (attr := simp)\n    \"Given a localization map `f : M →+ N` for a Submonoid `S ⊆ M`, for all `z : N`\nwe have that if `x : M, y ∈ S` are such that `z + f y = f x`, then `f x - f y = z`.\"]\ntheorem mk'_sec (z : N) : f.mk' (f.sec z).1 (f.sec z).2 = z :=\n  show _ * _ = _ by rw [← sec_spec, mul_inv_left, mul_comm]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.mk'_surjective","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nz : N\n⊢ Exists fun x => Exists fun y => Eq (f.mk' x y) z","decl":"@[to_additive]\ntheorem mk'_surjective (z : N) : ∃ (x : _) (y : S), f.mk' x y = z :=\n  ⟨(f.sec z).1, (f.sec z).2, f.mk'_sec z⟩\n\n"}
{"name":"Submonoid.LocalizationMap.mk'_surjective","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nz : N\n⊢ Exists fun x => Exists fun y => Eq (f.mk' x y) z","decl":"@[to_additive]\ntheorem mk'_surjective (z : N) : ∃ (x : _) (y : S), f.mk' x y = z :=\n  ⟨(f.sec z).1, (f.sec z).2, f.mk'_sec z⟩\n\n"}
{"name":"Submonoid.LocalizationMap.mk'_spec","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq (HMul.hMul (f.mk' x y) (f.toMap ↑y)) (f.toMap x)","decl":"@[to_additive]\ntheorem mk'_spec (x) (y : S) : f.mk' x y * f.toMap y = f.toMap x :=\n  show _ * _ * _ = _ by rw [mul_assoc, mul_comm _ (f.toMap y), ← mul_assoc, mul_inv_left, mul_comm]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.mk'_spec","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq (HAdd.hAdd (f.mk' x y) (f.toMap ↑y)) (f.toMap x)","decl":"@[to_additive]\ntheorem mk'_spec (x) (y : S) : f.mk' x y * f.toMap y = f.toMap x :=\n  show _ * _ * _ = _ by rw [mul_assoc, mul_comm _ (f.toMap y), ← mul_assoc, mul_inv_left, mul_comm]\n\n"}
{"name":"Submonoid.LocalizationMap.mk'_spec'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq (HMul.hMul (f.toMap ↑y) (f.mk' x y)) (f.toMap x)","decl":"@[to_additive]\ntheorem mk'_spec' (x) (y : S) : f.toMap y * f.mk' x y = f.toMap x := by rw [mul_comm, mk'_spec]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.mk'_spec'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq (HAdd.hAdd (f.toMap ↑y) (f.mk' x y)) (f.toMap x)","decl":"@[to_additive]\ntheorem mk'_spec' (x) (y : S) : f.toMap y * f.mk' x y = f.toMap x := by rw [mul_comm, mk'_spec]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.eq_mk'_iff_add_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx : M\ny : Subtype fun x => Membership.mem S x\nz : N\n⊢ Iff (Eq z (f.mk' x y)) (Eq (HAdd.hAdd z (f.toMap ↑y)) (f.toMap x))","decl":"@[to_additive]\ntheorem eq_mk'_iff_mul_eq {x} {y : S} {z} : z = f.mk' x y ↔ z * f.toMap y = f.toMap x :=\n  ⟨fun H ↦ by rw [H, mk'_spec], fun H ↦ by rw [mk', mul_inv_right, H]⟩\n\n"}
{"name":"Submonoid.LocalizationMap.eq_mk'_iff_mul_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx : M\ny : Subtype fun x => Membership.mem S x\nz : N\n⊢ Iff (Eq z (f.mk' x y)) (Eq (HMul.hMul z (f.toMap ↑y)) (f.toMap x))","decl":"@[to_additive]\ntheorem eq_mk'_iff_mul_eq {x} {y : S} {z} : z = f.mk' x y ↔ z * f.toMap y = f.toMap x :=\n  ⟨fun H ↦ by rw [H, mk'_spec], fun H ↦ by rw [mk', mul_inv_right, H]⟩\n\n"}
{"name":"Submonoid.LocalizationMap.mk'_eq_iff_eq_mul","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx : M\ny : Subtype fun x => Membership.mem S x\nz : N\n⊢ Iff (Eq (f.mk' x y) z) (Eq (f.toMap x) (HMul.hMul z (f.toMap ↑y)))","decl":"@[to_additive]\ntheorem mk'_eq_iff_eq_mul {x} {y : S} {z} : f.mk' x y = z ↔ f.toMap x = z * f.toMap y := by\n  rw [eq_comm, eq_mk'_iff_mul_eq, eq_comm]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.mk'_eq_iff_eq_add","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx : M\ny : Subtype fun x => Membership.mem S x\nz : N\n⊢ Iff (Eq (f.mk' x y) z) (Eq (f.toMap x) (HAdd.hAdd z (f.toMap ↑y)))","decl":"@[to_additive]\ntheorem mk'_eq_iff_eq_mul {x} {y : S} {z} : f.mk' x y = z ↔ f.toMap x = z * f.toMap y := by\n  rw [eq_comm, eq_mk'_iff_mul_eq, eq_comm]\n\n"}
{"name":"Submonoid.LocalizationMap.mk'_eq_iff_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx₁ x₂ : M\ny₁ y₂ : Subtype fun x => Membership.mem S x\n⊢ Iff (Eq (f.mk' x₁ y₁) (f.mk' x₂ y₂)) (Eq (f.toMap (HMul.hMul (↑y₂) x₁)) (f.toMap (HMul.hMul (↑y₁) x₂)))","decl":"@[to_additive]\ntheorem mk'_eq_iff_eq {x₁ x₂} {y₁ y₂ : S} :\n    f.mk' x₁ y₁ = f.mk' x₂ y₂ ↔ f.toMap (y₂ * x₁) = f.toMap (y₁ * x₂) :=\n  ⟨fun H ↦ by\n    rw [f.toMap.map_mul, f.toMap.map_mul, f.mk'_eq_iff_eq_mul.1 H,← mul_assoc, mk'_spec',\n      mul_comm ((toMap f) x₂) _],\n    fun H ↦ by\n    rw [mk'_eq_iff_eq_mul, mk', mul_assoc, mul_comm _ (f.toMap y₁), ← mul_assoc, ←\n      f.toMap.map_mul, mul_comm x₂, ← H, ← mul_comm x₁, f.toMap.map_mul,\n      mul_inv_right f.map_units]⟩\n\n"}
{"name":"AddSubmonoid.LocalizationMap.mk'_eq_iff_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx₁ x₂ : M\ny₁ y₂ : Subtype fun x => Membership.mem S x\n⊢ Iff (Eq (f.mk' x₁ y₁) (f.mk' x₂ y₂)) (Eq (f.toMap (HAdd.hAdd (↑y₂) x₁)) (f.toMap (HAdd.hAdd (↑y₁) x₂)))","decl":"@[to_additive]\ntheorem mk'_eq_iff_eq {x₁ x₂} {y₁ y₂ : S} :\n    f.mk' x₁ y₁ = f.mk' x₂ y₂ ↔ f.toMap (y₂ * x₁) = f.toMap (y₁ * x₂) :=\n  ⟨fun H ↦ by\n    rw [f.toMap.map_mul, f.toMap.map_mul, f.mk'_eq_iff_eq_mul.1 H,← mul_assoc, mk'_spec',\n      mul_comm ((toMap f) x₂) _],\n    fun H ↦ by\n    rw [mk'_eq_iff_eq_mul, mk', mul_assoc, mul_comm _ (f.toMap y₁), ← mul_assoc, ←\n      f.toMap.map_mul, mul_comm x₂, ← H, ← mul_comm x₁, f.toMap.map_mul,\n      mul_inv_right f.map_units]⟩\n\n"}
{"name":"Submonoid.LocalizationMap.mk'_eq_iff_eq'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx₁ x₂ : M\ny₁ y₂ : Subtype fun x => Membership.mem S x\n⊢ Iff (Eq (f.mk' x₁ y₁) (f.mk' x₂ y₂)) (Eq (f.toMap (HMul.hMul x₁ ↑y₂)) (f.toMap (HMul.hMul x₂ ↑y₁)))","decl":"@[to_additive]\ntheorem mk'_eq_iff_eq' {x₁ x₂} {y₁ y₂ : S} :\n    f.mk' x₁ y₁ = f.mk' x₂ y₂ ↔ f.toMap (x₁ * y₂) = f.toMap (x₂ * y₁) := by\n  simp only [f.mk'_eq_iff_eq, mul_comm]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.mk'_eq_iff_eq'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx₁ x₂ : M\ny₁ y₂ : Subtype fun x => Membership.mem S x\n⊢ Iff (Eq (f.mk' x₁ y₁) (f.mk' x₂ y₂)) (Eq (f.toMap (HAdd.hAdd x₁ ↑y₂)) (f.toMap (HAdd.hAdd x₂ ↑y₁)))","decl":"@[to_additive]\ntheorem mk'_eq_iff_eq' {x₁ x₂} {y₁ y₂ : S} :\n    f.mk' x₁ y₁ = f.mk' x₂ y₂ ↔ f.toMap (x₁ * y₂) = f.toMap (x₂ * y₁) := by\n  simp only [f.mk'_eq_iff_eq, mul_comm]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\na₁ b₁ : M\na₂ b₂ : Subtype fun x => Membership.mem S x\n⊢ Iff (Eq (f.mk' a₁ a₂) (f.mk' b₁ b₂)) (Exists fun c => Eq (HAdd.hAdd (↑c) (HAdd.hAdd (↑b₂) a₁)) (HAdd.hAdd (↑c) (HAdd.hAdd (↑a₂) b₁)))","decl":"@[to_additive]\nprotected theorem eq {a₁ b₁} {a₂ b₂ : S} :\n    f.mk' a₁ a₂ = f.mk' b₁ b₂ ↔ ∃ c : S, ↑c * (↑b₂ * a₁) = c * (a₂ * b₁) :=\n  f.mk'_eq_iff_eq.trans <| f.eq_iff_exists\n\n"}
{"name":"Submonoid.LocalizationMap.eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\na₁ b₁ : M\na₂ b₂ : Subtype fun x => Membership.mem S x\n⊢ Iff (Eq (f.mk' a₁ a₂) (f.mk' b₁ b₂)) (Exists fun c => Eq (HMul.hMul (↑c) (HMul.hMul (↑b₂) a₁)) (HMul.hMul (↑c) (HMul.hMul (↑a₂) b₁)))","decl":"@[to_additive]\nprotected theorem eq {a₁ b₁} {a₂ b₂ : S} :\n    f.mk' a₁ a₂ = f.mk' b₁ b₂ ↔ ∃ c : S, ↑c * (↑b₂ * a₁) = c * (a₂ * b₁) :=\n  f.mk'_eq_iff_eq.trans <| f.eq_iff_exists\n\n"}
{"name":"AddSubmonoid.LocalizationMap.eq'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\na₁ b₁ : M\na₂ b₂ : Subtype fun x => Membership.mem S x\n⊢ Iff (Eq (f.mk' a₁ a₂) (f.mk' b₁ b₂)) ((AddLocalization.r S) { fst := a₁, snd := a₂ } { fst := b₁, snd := b₂ })","decl":"@[to_additive]\nprotected theorem eq' {a₁ b₁} {a₂ b₂ : S} :\n    f.mk' a₁ a₂ = f.mk' b₁ b₂ ↔ Localization.r S (a₁, a₂) (b₁, b₂) := by\n  rw [f.eq, Localization.r_iff_exists]\n\n"}
{"name":"Submonoid.LocalizationMap.eq'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\na₁ b₁ : M\na₂ b₂ : Subtype fun x => Membership.mem S x\n⊢ Iff (Eq (f.mk' a₁ a₂) (f.mk' b₁ b₂)) ((Localization.r S) { fst := a₁, snd := a₂ } { fst := b₁, snd := b₂ })","decl":"@[to_additive]\nprotected theorem eq' {a₁ b₁} {a₂ b₂ : S} :\n    f.mk' a₁ a₂ = f.mk' b₁ b₂ ↔ Localization.r S (a₁, a₂) (b₁, b₂) := by\n  rw [f.eq, Localization.r_iff_exists]\n\n"}
{"name":"Submonoid.LocalizationMap.eq_iff_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\ng : S.LocalizationMap P\nx y : M\n⊢ Iff (Eq (f.toMap x) (f.toMap y)) (Eq (g.toMap x) (g.toMap y))","decl":"@[to_additive]\ntheorem eq_iff_eq (g : LocalizationMap S P) {x y} : f.toMap x = f.toMap y ↔ g.toMap x = g.toMap y :=\n  f.eq_iff_exists.trans g.eq_iff_exists.symm\n\n"}
{"name":"AddSubmonoid.LocalizationMap.eq_iff_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\ng : S.LocalizationMap P\nx y : M\n⊢ Iff (Eq (f.toMap x) (f.toMap y)) (Eq (g.toMap x) (g.toMap y))","decl":"@[to_additive]\ntheorem eq_iff_eq (g : LocalizationMap S P) {x y} : f.toMap x = f.toMap y ↔ g.toMap x = g.toMap y :=\n  f.eq_iff_exists.trans g.eq_iff_exists.symm\n\n"}
{"name":"AddSubmonoid.LocalizationMap.mk'_eq_iff_mk'_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\ng : S.LocalizationMap P\nx₁ x₂ : M\ny₁ y₂ : Subtype fun x => Membership.mem S x\n⊢ Iff (Eq (f.mk' x₁ y₁) (f.mk' x₂ y₂)) (Eq (g.mk' x₁ y₁) (g.mk' x₂ y₂))","decl":"@[to_additive]\ntheorem mk'_eq_iff_mk'_eq (g : LocalizationMap S P) {x₁ x₂} {y₁ y₂ : S} :\n    f.mk' x₁ y₁ = f.mk' x₂ y₂ ↔ g.mk' x₁ y₁ = g.mk' x₂ y₂ :=\n  f.eq'.trans g.eq'.symm\n\n"}
{"name":"Submonoid.LocalizationMap.mk'_eq_iff_mk'_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\ng : S.LocalizationMap P\nx₁ x₂ : M\ny₁ y₂ : Subtype fun x => Membership.mem S x\n⊢ Iff (Eq (f.mk' x₁ y₁) (f.mk' x₂ y₂)) (Eq (g.mk' x₁ y₁) (g.mk' x₂ y₂))","decl":"@[to_additive]\ntheorem mk'_eq_iff_mk'_eq (g : LocalizationMap S P) {x₁ x₂} {y₁ y₂ : S} :\n    f.mk' x₁ y₁ = f.mk' x₂ y₂ ↔ g.mk' x₁ y₁ = g.mk' x₂ y₂ :=\n  f.eq'.trans g.eq'.symm\n\n"}
{"name":"AddSubmonoid.LocalizationMap.exists_of_sec_mk'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Exists fun c => Eq (HAdd.hAdd (↑c) (HAdd.hAdd (↑(f.sec (f.mk' x y)).2) x)) (HAdd.hAdd (↑c) (HAdd.hAdd (↑y) (f.sec (f.mk' x y)).1))","decl":"/-- Given a Localization map `f : M →* N` for a Submonoid `S ⊆ M`, for all `x₁ : M` and `y₁ ∈ S`,\nif `x₂ : M, y₂ ∈ S` are such that `f x₁ * (f y₁)⁻¹ * f y₂ = f x₂`, then there exists `c ∈ S`\nsuch that `x₁ * y₂ * c = x₂ * y₁ * c`. -/\n@[to_additive\n    \"Given a Localization map `f : M →+ N` for a Submonoid `S ⊆ M`, for all `x₁ : M`\nand `y₁ ∈ S`, if `x₂ : M, y₂ ∈ S` are such that `(f x₁ - f y₁) + f y₂ = f x₂`, then there exists\n`c ∈ S` such that `x₁ + y₂ + c = x₂ + y₁ + c`.\"]\ntheorem exists_of_sec_mk' (x) (y : S) :\n    ∃ c : S, ↑c * (↑(f.sec <| f.mk' x y).2 * x) = c * (y * (f.sec <| f.mk' x y).1) :=\n  f.eq_iff_exists.1 <| f.mk'_eq_iff_eq.1 <| (mk'_sec _ _).symm\n\n"}
{"name":"Submonoid.LocalizationMap.exists_of_sec_mk'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Exists fun c => Eq (HMul.hMul (↑c) (HMul.hMul (↑(f.sec (f.mk' x y)).2) x)) (HMul.hMul (↑c) (HMul.hMul (↑y) (f.sec (f.mk' x y)).1))","decl":"/-- Given a Localization map `f : M →* N` for a Submonoid `S ⊆ M`, for all `x₁ : M` and `y₁ ∈ S`,\nif `x₂ : M, y₂ ∈ S` are such that `f x₁ * (f y₁)⁻¹ * f y₂ = f x₂`, then there exists `c ∈ S`\nsuch that `x₁ * y₂ * c = x₂ * y₁ * c`. -/\n@[to_additive\n    \"Given a Localization map `f : M →+ N` for a Submonoid `S ⊆ M`, for all `x₁ : M`\nand `y₁ ∈ S`, if `x₂ : M, y₂ ∈ S` are such that `(f x₁ - f y₁) + f y₂ = f x₂`, then there exists\n`c ∈ S` such that `x₁ + y₂ + c = x₂ + y₁ + c`.\"]\ntheorem exists_of_sec_mk' (x) (y : S) :\n    ∃ c : S, ↑c * (↑(f.sec <| f.mk' x y).2 * x) = c * (y * (f.sec <| f.mk' x y).1) :=\n  f.eq_iff_exists.1 <| f.mk'_eq_iff_eq.1 <| (mk'_sec _ _).symm\n\n"}
{"name":"AddSubmonoid.LocalizationMap.mk'_eq_of_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\na₁ b₁ : M\na₂ b₂ : Subtype fun x => Membership.mem S x\nH : Eq (HAdd.hAdd (↑a₂) b₁) (HAdd.hAdd (↑b₂) a₁)\n⊢ Eq (f.mk' a₁ a₂) (f.mk' b₁ b₂)","decl":"@[to_additive]\ntheorem mk'_eq_of_eq {a₁ b₁ : M} {a₂ b₂ : S} (H : ↑a₂ * b₁ = ↑b₂ * a₁) :\n    f.mk' a₁ a₂ = f.mk' b₁ b₂ :=\n  f.mk'_eq_iff_eq.2 <| H ▸ rfl\n\n"}
{"name":"Submonoid.LocalizationMap.mk'_eq_of_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\na₁ b₁ : M\na₂ b₂ : Subtype fun x => Membership.mem S x\nH : Eq (HMul.hMul (↑a₂) b₁) (HMul.hMul (↑b₂) a₁)\n⊢ Eq (f.mk' a₁ a₂) (f.mk' b₁ b₂)","decl":"@[to_additive]\ntheorem mk'_eq_of_eq {a₁ b₁ : M} {a₂ b₂ : S} (H : ↑a₂ * b₁ = ↑b₂ * a₁) :\n    f.mk' a₁ a₂ = f.mk' b₁ b₂ :=\n  f.mk'_eq_iff_eq.2 <| H ▸ rfl\n\n"}
{"name":"AddSubmonoid.LocalizationMap.mk'_eq_of_eq'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\na₁ b₁ : M\na₂ b₂ : Subtype fun x => Membership.mem S x\nH : Eq (HAdd.hAdd b₁ ↑a₂) (HAdd.hAdd a₁ ↑b₂)\n⊢ Eq (f.mk' a₁ a₂) (f.mk' b₁ b₂)","decl":"@[to_additive]\ntheorem mk'_eq_of_eq' {a₁ b₁ : M} {a₂ b₂ : S} (H : b₁ * ↑a₂ = a₁ * ↑b₂) :\n    f.mk' a₁ a₂ = f.mk' b₁ b₂ :=\n  f.mk'_eq_of_eq <| by simpa only [mul_comm] using H\n\n"}
{"name":"Submonoid.LocalizationMap.mk'_eq_of_eq'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\na₁ b₁ : M\na₂ b₂ : Subtype fun x => Membership.mem S x\nH : Eq (HMul.hMul b₁ ↑a₂) (HMul.hMul a₁ ↑b₂)\n⊢ Eq (f.mk' a₁ a₂) (f.mk' b₁ b₂)","decl":"@[to_additive]\ntheorem mk'_eq_of_eq' {a₁ b₁ : M} {a₂ b₂ : S} (H : b₁ * ↑a₂ = a₁ * ↑b₂) :\n    f.mk' a₁ a₂ = f.mk' b₁ b₂ :=\n  f.mk'_eq_of_eq <| by simpa only [mul_comm] using H\n\n"}
{"name":"Submonoid.LocalizationMap.mk'_cancel","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\na : M\nb c : Subtype fun x => Membership.mem S x\n⊢ Eq (f.mk' (HMul.hMul a ↑c) (HMul.hMul b c)) (f.mk' a b)","decl":"@[to_additive]\ntheorem mk'_cancel (a : M) (b c : S) :\n    f.mk' (a * c) (b * c) = f.mk' a b :=\n  mk'_eq_of_eq' f (by rw [Submonoid.coe_mul, mul_comm (b : M), mul_assoc])\n\n"}
{"name":"AddSubmonoid.LocalizationMap.mk'_cancel","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\na : M\nb c : Subtype fun x => Membership.mem S x\n⊢ Eq (f.mk' (HAdd.hAdd a ↑c) (HAdd.hAdd b c)) (f.mk' a b)","decl":"@[to_additive]\ntheorem mk'_cancel (a : M) (b c : S) :\n    f.mk' (a * c) (b * c) = f.mk' a b :=\n  mk'_eq_of_eq' f (by rw [Submonoid.coe_mul, mul_comm (b : M), mul_assoc])\n\n"}
{"name":"Submonoid.LocalizationMap.mk'_eq_of_same","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\na b : M\nd : Subtype fun x => Membership.mem S x\n⊢ Iff (Eq (f.mk' a d) (f.mk' b d)) (Exists fun c => Eq (HMul.hMul (↑c) a) (HMul.hMul (↑c) b))","decl":"@[to_additive]\ntheorem mk'_eq_of_same {a b} {d : S} :\n    f.mk' a d = f.mk' b d ↔ ∃ c : S, c * a = c * b := by\n  rw [mk'_eq_iff_eq', map_mul, map_mul, ← eq_iff_exists f]\n  exact (map_units f d).mul_left_inj\n\n"}
{"name":"AddSubmonoid.LocalizationMap.mk'_eq_of_same","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\na b : M\nd : Subtype fun x => Membership.mem S x\n⊢ Iff (Eq (f.mk' a d) (f.mk' b d)) (Exists fun c => Eq (HAdd.hAdd (↑c) a) (HAdd.hAdd (↑c) b))","decl":"@[to_additive]\ntheorem mk'_eq_of_same {a b} {d : S} :\n    f.mk' a d = f.mk' b d ↔ ∃ c : S, c * a = c * b := by\n  rw [mk'_eq_iff_eq', map_mul, map_mul, ← eq_iff_exists f]\n  exact (map_units f d).mul_left_inj\n\n"}
{"name":"AddSubmonoid.LocalizationMap.mk'_self'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\ny : Subtype fun x => Membership.mem S x\n⊢ Eq (f.mk' (↑y) y) 0","decl":"@[to_additive (attr := simp)]\ntheorem mk'_self' (y : S) : f.mk' (y : M) y = 1 :=\n  show _ * _ = _ by rw [mul_inv_left, mul_one]\n\n"}
{"name":"Submonoid.LocalizationMap.mk'_self'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\ny : Subtype fun x => Membership.mem S x\n⊢ Eq (f.mk' (↑y) y) 1","decl":"@[to_additive (attr := simp)]\ntheorem mk'_self' (y : S) : f.mk' (y : M) y = 1 :=\n  show _ * _ = _ by rw [mul_inv_left, mul_one]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.mk'_self","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx : M\nH : Membership.mem S x\n⊢ Eq (f.mk' x ⟨x, H⟩) 0","decl":"@[to_additive (attr := simp)]\ntheorem mk'_self (x) (H : x ∈ S) : f.mk' x ⟨x, H⟩ = 1 := mk'_self' f ⟨x, H⟩\n\n"}
{"name":"Submonoid.LocalizationMap.mk'_self","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx : M\nH : Membership.mem S x\n⊢ Eq (f.mk' x ⟨x, H⟩) 1","decl":"@[to_additive (attr := simp)]\ntheorem mk'_self (x) (H : x ∈ S) : f.mk' x ⟨x, H⟩ = 1 := mk'_self' f ⟨x, H⟩\n\n"}
{"name":"AddSubmonoid.LocalizationMap.add_mk'_eq_mk'_of_add","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx₁ x₂ : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq (HAdd.hAdd (f.toMap x₁) (f.mk' x₂ y)) (f.mk' (HAdd.hAdd x₁ x₂) y)","decl":"@[to_additive]\ntheorem mul_mk'_eq_mk'_of_mul (x₁ x₂) (y : S) : f.toMap x₁ * f.mk' x₂ y = f.mk' (x₁ * x₂) y := by\n  rw [← mk'_one, ← mk'_mul, one_mul]\n\n"}
{"name":"Submonoid.LocalizationMap.mul_mk'_eq_mk'_of_mul","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx₁ x₂ : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq (HMul.hMul (f.toMap x₁) (f.mk' x₂ y)) (f.mk' (HMul.hMul x₁ x₂) y)","decl":"@[to_additive]\ntheorem mul_mk'_eq_mk'_of_mul (x₁ x₂) (y : S) : f.toMap x₁ * f.mk' x₂ y = f.mk' (x₁ * x₂) y := by\n  rw [← mk'_one, ← mk'_mul, one_mul]\n\n"}
{"name":"Submonoid.LocalizationMap.mk'_mul_eq_mk'_of_mul","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx₁ x₂ : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq (HMul.hMul (f.mk' x₂ y) (f.toMap x₁)) (f.mk' (HMul.hMul x₁ x₂) y)","decl":"@[to_additive]\ntheorem mk'_mul_eq_mk'_of_mul (x₁ x₂) (y : S) : f.mk' x₂ y * f.toMap x₁ = f.mk' (x₁ * x₂) y := by\n  rw [mul_comm, mul_mk'_eq_mk'_of_mul]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.mk'_add_eq_mk'_of_add","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx₁ x₂ : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq (HAdd.hAdd (f.mk' x₂ y) (f.toMap x₁)) (f.mk' (HAdd.hAdd x₁ x₂) y)","decl":"@[to_additive]\ntheorem mk'_mul_eq_mk'_of_mul (x₁ x₂) (y : S) : f.mk' x₂ y * f.toMap x₁ = f.mk' (x₁ * x₂) y := by\n  rw [mul_comm, mul_mk'_eq_mk'_of_mul]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.add_mk'_zero_eq_mk'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq (HAdd.hAdd (f.toMap x) (f.mk' 0 y)) (f.mk' x y)","decl":"@[to_additive]\ntheorem mul_mk'_one_eq_mk' (x) (y : S) : f.toMap x * f.mk' 1 y = f.mk' x y := by\n  rw [mul_mk'_eq_mk'_of_mul, mul_one]\n\n"}
{"name":"Submonoid.LocalizationMap.mul_mk'_one_eq_mk'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq (HMul.hMul (f.toMap x) (f.mk' 1 y)) (f.mk' x y)","decl":"@[to_additive]\ntheorem mul_mk'_one_eq_mk' (x) (y : S) : f.toMap x * f.mk' 1 y = f.mk' x y := by\n  rw [mul_mk'_eq_mk'_of_mul, mul_one]\n\n"}
{"name":"Submonoid.LocalizationMap.mk'_mul_cancel_right","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq (f.mk' (HMul.hMul x ↑y) y) (f.toMap x)","decl":"@[to_additive (attr := simp)]\ntheorem mk'_mul_cancel_right (x : M) (y : S) : f.mk' (x * y) y = f.toMap x := by\n  rw [← mul_mk'_one_eq_mk', f.toMap.map_mul, mul_assoc, mul_mk'_one_eq_mk', mk'_self', mul_one]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.mk'_add_cancel_right","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq (f.mk' (HAdd.hAdd x ↑y) y) (f.toMap x)","decl":"@[to_additive (attr := simp)]\ntheorem mk'_mul_cancel_right (x : M) (y : S) : f.mk' (x * y) y = f.toMap x := by\n  rw [← mul_mk'_one_eq_mk', f.toMap.map_mul, mul_assoc, mul_mk'_one_eq_mk', mk'_self', mul_one]\n\n"}
{"name":"Submonoid.LocalizationMap.mk'_mul_cancel_left","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq (f.mk' (HMul.hMul (↑y) x) y) (f.toMap x)","decl":"@[to_additive]\ntheorem mk'_mul_cancel_left (x) (y : S) : f.mk' ((y : M) * x) y = f.toMap x := by\n  rw [mul_comm, mk'_mul_cancel_right]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.mk'_add_cancel_left","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq (f.mk' (HAdd.hAdd (↑y) x) y) (f.toMap x)","decl":"@[to_additive]\ntheorem mk'_mul_cancel_left (x) (y : S) : f.mk' ((y : M) * x) y = f.toMap x := by\n  rw [mul_comm, mk'_mul_cancel_right]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.isAddUnit_comp","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\nj : AddMonoidHom N P\ny : Subtype fun x => Membership.mem S x\n⊢ IsAddUnit ((j.comp f.toMap) ↑y)","decl":"@[to_additive]\ntheorem isUnit_comp (j : N →* P) (y : S) : IsUnit (j.comp f.toMap y) :=\n  ⟨Units.map j <| IsUnit.liftRight (f.toMap.restrict S) f.map_units y,\n    show j _ = j _ from congr_arg j <| IsUnit.coe_liftRight (f.toMap.restrict S) f.map_units _⟩\n\n"}
{"name":"Submonoid.LocalizationMap.isUnit_comp","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\nj : MonoidHom N P\ny : Subtype fun x => Membership.mem S x\n⊢ IsUnit ((j.comp f.toMap) ↑y)","decl":"@[to_additive]\ntheorem isUnit_comp (j : N →* P) (y : S) : IsUnit (j.comp f.toMap y) :=\n  ⟨Units.map j <| IsUnit.liftRight (f.toMap.restrict S) f.map_units y,\n    show j _ = j _ from congr_arg j <| IsUnit.coe_liftRight (f.toMap.restrict S) f.map_units _⟩\n\n"}
{"name":"Submonoid.LocalizationMap.eq_of_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\ng : MonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsUnit (g ↑y)\nx y : M\nh : Eq (f.toMap x) (f.toMap y)\n⊢ Eq (g x) (g y)","decl":"/-- Given a Localization map `f : M →* N` for a Submonoid `S ⊆ M` and a map of `CommMonoid`s\n`g : M →* P` such that `g(S) ⊆ Units P`, `f x = f y → g x = g y` for all `x y : M`. -/\n@[to_additive\n    \"Given a Localization map `f : M →+ N` for a Submonoid `S ⊆ M` and a map of\n`AddCommMonoid`s `g : M →+ P` such that `g(S) ⊆ AddUnits P`, `f x = f y → g x = g y`\nfor all `x y : M`.\"]\ntheorem eq_of_eq (hg : ∀ y : S, IsUnit (g y)) {x y} (h : f.toMap x = f.toMap y) : g x = g y := by\n  obtain ⟨c, hc⟩ := f.eq_iff_exists.1 h\n  rw [← one_mul (g x), ← IsUnit.liftRight_inv_mul (g.restrict S) hg c]\n  show _ * g c * _ = _\n  rw [mul_assoc, ← g.map_mul, hc, mul_comm, mul_inv_left hg, g.map_mul]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.eq_of_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\ng : AddMonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsAddUnit (g ↑y)\nx y : M\nh : Eq (f.toMap x) (f.toMap y)\n⊢ Eq (g x) (g y)","decl":"/-- Given a Localization map `f : M →* N` for a Submonoid `S ⊆ M` and a map of `CommMonoid`s\n`g : M →* P` such that `g(S) ⊆ Units P`, `f x = f y → g x = g y` for all `x y : M`. -/\n@[to_additive\n    \"Given a Localization map `f : M →+ N` for a Submonoid `S ⊆ M` and a map of\n`AddCommMonoid`s `g : M →+ P` such that `g(S) ⊆ AddUnits P`, `f x = f y → g x = g y`\nfor all `x y : M`.\"]\ntheorem eq_of_eq (hg : ∀ y : S, IsUnit (g y)) {x y} (h : f.toMap x = f.toMap y) : g x = g y := by\n  obtain ⟨c, hc⟩ := f.eq_iff_exists.1 h\n  rw [← one_mul (g x), ← IsUnit.liftRight_inv_mul (g.restrict S) hg c]\n  show _ * g c * _ = _\n  rw [mul_assoc, ← g.map_mul, hc, mul_comm, mul_inv_left hg, g.map_mul]\n\n"}
{"name":"Submonoid.LocalizationMap.comp_eq_of_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝² : CommMonoid N\nP : Type u_3\ninst✝¹ : CommMonoid P\nf : S.LocalizationMap N\ng : MonoidHom M P\nT : Submonoid P\nQ : Type u_4\ninst✝ : CommMonoid Q\nhg : ∀ (y : Subtype fun x => Membership.mem S x), Membership.mem T (g ↑y)\nk : T.LocalizationMap Q\nx y : M\nh : Eq (f.toMap x) (f.toMap y)\n⊢ Eq (k.toMap (g x)) (k.toMap (g y))","decl":"/-- Given `CommMonoid`s `M, P`, Localization maps `f : M →* N, k : P →* Q` for Submonoids\n`S, T` respectively, and `g : M →* P` such that `g(S) ⊆ T`, `f x = f y` implies\n`k (g x) = k (g y)`. -/\n@[to_additive\n    \"Given `AddCommMonoid`s `M, P`, Localization maps `f : M →+ N, k : P →+ Q` for Submonoids\n`S, T` respectively, and `g : M →+ P` such that `g(S) ⊆ T`, `f x = f y`\nimplies `k (g x) = k (g y)`.\"]\ntheorem comp_eq_of_eq {T : Submonoid P} {Q : Type*} [CommMonoid Q] (hg : ∀ y : S, g y ∈ T)\n    (k : LocalizationMap T Q) {x y} (h : f.toMap x = f.toMap y) : k.toMap (g x) = k.toMap (g y) :=\n  f.eq_of_eq (fun y : S ↦ show IsUnit (k.toMap.comp g y) from k.map_units ⟨g y, hg y⟩) h\n\n"}
{"name":"AddSubmonoid.LocalizationMap.comp_eq_of_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝² : AddCommMonoid N\nP : Type u_3\ninst✝¹ : AddCommMonoid P\nf : S.LocalizationMap N\ng : AddMonoidHom M P\nT : AddSubmonoid P\nQ : Type u_4\ninst✝ : AddCommMonoid Q\nhg : ∀ (y : Subtype fun x => Membership.mem S x), Membership.mem T (g ↑y)\nk : T.LocalizationMap Q\nx y : M\nh : Eq (f.toMap x) (f.toMap y)\n⊢ Eq (k.toMap (g x)) (k.toMap (g y))","decl":"/-- Given `CommMonoid`s `M, P`, Localization maps `f : M →* N, k : P →* Q` for Submonoids\n`S, T` respectively, and `g : M →* P` such that `g(S) ⊆ T`, `f x = f y` implies\n`k (g x) = k (g y)`. -/\n@[to_additive\n    \"Given `AddCommMonoid`s `M, P`, Localization maps `f : M →+ N, k : P →+ Q` for Submonoids\n`S, T` respectively, and `g : M →+ P` such that `g(S) ⊆ T`, `f x = f y`\nimplies `k (g x) = k (g y)`.\"]\ntheorem comp_eq_of_eq {T : Submonoid P} {Q : Type*} [CommMonoid Q] (hg : ∀ y : S, g y ∈ T)\n    (k : LocalizationMap T Q) {x y} (h : f.toMap x = f.toMap y) : k.toMap (g x) = k.toMap (g y) :=\n  f.eq_of_eq (fun y : S ↦ show IsUnit (k.toMap.comp g y) from k.map_units ⟨g y, hg y⟩) h\n\n"}
{"name":"Submonoid.LocalizationMap.lift_mk'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\ng : MonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsUnit (g ↑y)\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq ((f.lift hg) (f.mk' x y)) (HMul.hMul (g x) ↑(Inv.inv ((IsUnit.liftRight (g.restrict S) hg) y)))","decl":"/-- Given a Localization map `f : M →* N` for a Submonoid `S ⊆ M` and a map of `CommMonoid`s\n`g : M →* P` such that `g y` is invertible for all `y : S`, the homomorphism induced from\n`N` to `P` maps `f x * (f y)⁻¹` to `g x * (g y)⁻¹` for all `x : M, y ∈ S`. -/\n@[to_additive\n    \"Given a Localization map `f : M →+ N` for a Submonoid `S ⊆ M` and a map of\n`AddCommMonoid`s `g : M →+ P` such that `g y` is invertible for all `y : S`, the homomorphism\ninduced from `N` to `P` maps `f x - f y` to `g x - g y` for all `x : M, y ∈ S`.\"]\ntheorem lift_mk' (x y) : f.lift hg (f.mk' x y) = g x * (IsUnit.liftRight (g.restrict S) hg y)⁻¹ :=\n  (mul_inv hg).2 <|\n    f.eq_of_eq hg <| by\n      simp_rw [f.toMap.map_mul, sec_spec', mul_assoc, f.mk'_spec, mul_comm]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.lift_mk'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\ng : AddMonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsAddUnit (g ↑y)\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq ((f.lift hg) (f.mk' x y)) (HAdd.hAdd (g x) ↑(Neg.neg ((IsAddUnit.liftRight (g.restrict S) hg) y)))","decl":"/-- Given a Localization map `f : M →* N` for a Submonoid `S ⊆ M` and a map of `CommMonoid`s\n`g : M →* P` such that `g y` is invertible for all `y : S`, the homomorphism induced from\n`N` to `P` maps `f x * (f y)⁻¹` to `g x * (g y)⁻¹` for all `x : M, y ∈ S`. -/\n@[to_additive\n    \"Given a Localization map `f : M →+ N` for a Submonoid `S ⊆ M` and a map of\n`AddCommMonoid`s `g : M →+ P` such that `g y` is invertible for all `y : S`, the homomorphism\ninduced from `N` to `P` maps `f x - f y` to `g x - g y` for all `x : M, y ∈ S`.\"]\ntheorem lift_mk' (x y) : f.lift hg (f.mk' x y) = g x * (IsUnit.liftRight (g.restrict S) hg y)⁻¹ :=\n  (mul_inv hg).2 <|\n    f.eq_of_eq hg <| by\n      simp_rw [f.toMap.map_mul, sec_spec', mul_assoc, f.mk'_spec, mul_comm]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.lift_spec","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\ng : AddMonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsAddUnit (g ↑y)\nz : N\nv : P\n⊢ Iff (Eq ((f.lift hg) z) v) (Eq (g (f.sec z).1) (HAdd.hAdd (g ↑(f.sec z).2) v))","decl":"/-- Given a Localization map `f : M →* N` for a Submonoid `S ⊆ M`, if a `CommMonoid` map\n`g : M →* P` induces a map `f.lift hg : N →* P` then for all `z : N, v : P`, we have\n`f.lift hg z = v ↔ g x = g y * v`, where `x : M, y ∈ S` are such that `z * f y = f x`. -/\n@[to_additive\n    \"Given a Localization map `f : M →+ N` for a Submonoid `S ⊆ M`, if an\n`AddCommMonoid` map `g : M →+ P` induces a map `f.lift hg : N →+ P` then for all\n`z : N, v : P`, we have `f.lift hg z = v ↔ g x = g y + v`, where `x : M, y ∈ S` are such that\n`z + f y = f x`.\"]\ntheorem lift_spec (z v) : f.lift hg z = v ↔ g (f.sec z).1 = g (f.sec z).2 * v :=\n  mul_inv_left hg _ _ v\n\n"}
{"name":"Submonoid.LocalizationMap.lift_spec","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\ng : MonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsUnit (g ↑y)\nz : N\nv : P\n⊢ Iff (Eq ((f.lift hg) z) v) (Eq (g (f.sec z).1) (HMul.hMul (g ↑(f.sec z).2) v))","decl":"/-- Given a Localization map `f : M →* N` for a Submonoid `S ⊆ M`, if a `CommMonoid` map\n`g : M →* P` induces a map `f.lift hg : N →* P` then for all `z : N, v : P`, we have\n`f.lift hg z = v ↔ g x = g y * v`, where `x : M, y ∈ S` are such that `z * f y = f x`. -/\n@[to_additive\n    \"Given a Localization map `f : M →+ N` for a Submonoid `S ⊆ M`, if an\n`AddCommMonoid` map `g : M →+ P` induces a map `f.lift hg : N →+ P` then for all\n`z : N, v : P`, we have `f.lift hg z = v ↔ g x = g y + v`, where `x : M, y ∈ S` are such that\n`z + f y = f x`.\"]\ntheorem lift_spec (z v) : f.lift hg z = v ↔ g (f.sec z).1 = g (f.sec z).2 * v :=\n  mul_inv_left hg _ _ v\n\n"}
{"name":"Submonoid.LocalizationMap.lift_spec_mul","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\ng : MonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsUnit (g ↑y)\nz : N\nw v : P\n⊢ Iff (Eq (HMul.hMul ((f.lift hg) z) w) v) (Eq (HMul.hMul (g (f.sec z).1) w) (HMul.hMul (g ↑(f.sec z).2) v))","decl":"/-- Given a Localization map `f : M →* N` for a Submonoid `S ⊆ M`, if a `CommMonoid` map\n`g : M →* P` induces a map `f.lift hg : N →* P` then for all `z : N, v w : P`, we have\n`f.lift hg z * w = v ↔ g x * w = g y * v`, where `x : M, y ∈ S` are such that\n`z * f y = f x`. -/\n@[to_additive\n    \"Given a Localization map `f : M →+ N` for a Submonoid `S ⊆ M`, if an `AddCommMonoid` map\n`g : M →+ P` induces a map `f.lift hg : N →+ P` then for all\n`z : N, v w : P`, we have `f.lift hg z + w = v ↔ g x + w = g y + v`, where `x : M, y ∈ S` are such\nthat `z + f y = f x`.\"]\ntheorem lift_spec_mul (z w v) : f.lift hg z * w = v ↔ g (f.sec z).1 * w = g (f.sec z).2 * v := by\n  erw [mul_comm, ← mul_assoc, mul_inv_left hg, mul_comm]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.lift_spec_add","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\ng : AddMonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsAddUnit (g ↑y)\nz : N\nw v : P\n⊢ Iff (Eq (HAdd.hAdd ((f.lift hg) z) w) v) (Eq (HAdd.hAdd (g (f.sec z).1) w) (HAdd.hAdd (g ↑(f.sec z).2) v))","decl":"/-- Given a Localization map `f : M →* N` for a Submonoid `S ⊆ M`, if a `CommMonoid` map\n`g : M →* P` induces a map `f.lift hg : N →* P` then for all `z : N, v w : P`, we have\n`f.lift hg z * w = v ↔ g x * w = g y * v`, where `x : M, y ∈ S` are such that\n`z * f y = f x`. -/\n@[to_additive\n    \"Given a Localization map `f : M →+ N` for a Submonoid `S ⊆ M`, if an `AddCommMonoid` map\n`g : M →+ P` induces a map `f.lift hg : N →+ P` then for all\n`z : N, v w : P`, we have `f.lift hg z + w = v ↔ g x + w = g y + v`, where `x : M, y ∈ S` are such\nthat `z + f y = f x`.\"]\ntheorem lift_spec_mul (z w v) : f.lift hg z * w = v ↔ g (f.sec z).1 * w = g (f.sec z).2 * v := by\n  erw [mul_comm, ← mul_assoc, mul_inv_left hg, mul_comm]\n\n"}
{"name":"Submonoid.LocalizationMap.lift_mk'_spec","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\ng : MonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsUnit (g ↑y)\nx : M\nv : P\ny : Subtype fun x => Membership.mem S x\n⊢ Iff (Eq ((f.lift hg) (f.mk' x y)) v) (Eq (g x) (HMul.hMul (g ↑y) v))","decl":"@[to_additive]\ntheorem lift_mk'_spec (x v) (y : S) : f.lift hg (f.mk' x y) = v ↔ g x = g y * v := by\n  rw [f.lift_mk' hg]; exact mul_inv_left hg _ _ _\n\n"}
{"name":"AddSubmonoid.LocalizationMap.lift_mk'_spec","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\ng : AddMonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsAddUnit (g ↑y)\nx : M\nv : P\ny : Subtype fun x => Membership.mem S x\n⊢ Iff (Eq ((f.lift hg) (f.mk' x y)) v) (Eq (g x) (HAdd.hAdd (g ↑y) v))","decl":"@[to_additive]\ntheorem lift_mk'_spec (x v) (y : S) : f.lift hg (f.mk' x y) = v ↔ g x = g y * v := by\n  rw [f.lift_mk' hg]; exact mul_inv_left hg _ _ _\n\n"}
{"name":"AddSubmonoid.LocalizationMap.lift_add_right","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\ng : AddMonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsAddUnit (g ↑y)\nz : N\n⊢ Eq (HAdd.hAdd ((f.lift hg) z) (g ↑(f.sec z).2)) (g (f.sec z).1)","decl":"/-- Given a Localization map `f : M →* N` for a Submonoid `S ⊆ M`, if a `CommMonoid` map\n`g : M →* P` induces a map `f.lift hg : N →* P` then for all `z : N`, we have\n`f.lift hg z * g y = g x`, where `x : M, y ∈ S` are such that `z * f y = f x`. -/\n@[to_additive\n    \"Given a Localization map `f : M →+ N` for a Submonoid `S ⊆ M`, if an `AddCommMonoid`\nmap `g : M →+ P` induces a map `f.lift hg : N →+ P` then for all `z : N`, we have\n`f.lift hg z + g y = g x`, where `x : M, y ∈ S` are such that `z + f y = f x`.\"]\ntheorem lift_mul_right (z) : f.lift hg z * g (f.sec z).2 = g (f.sec z).1 := by\n  erw [mul_assoc, IsUnit.liftRight_inv_mul, mul_one]\n\n"}
{"name":"Submonoid.LocalizationMap.lift_mul_right","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\ng : MonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsUnit (g ↑y)\nz : N\n⊢ Eq (HMul.hMul ((f.lift hg) z) (g ↑(f.sec z).2)) (g (f.sec z).1)","decl":"/-- Given a Localization map `f : M →* N` for a Submonoid `S ⊆ M`, if a `CommMonoid` map\n`g : M →* P` induces a map `f.lift hg : N →* P` then for all `z : N`, we have\n`f.lift hg z * g y = g x`, where `x : M, y ∈ S` are such that `z * f y = f x`. -/\n@[to_additive\n    \"Given a Localization map `f : M →+ N` for a Submonoid `S ⊆ M`, if an `AddCommMonoid`\nmap `g : M →+ P` induces a map `f.lift hg : N →+ P` then for all `z : N`, we have\n`f.lift hg z + g y = g x`, where `x : M, y ∈ S` are such that `z + f y = f x`.\"]\ntheorem lift_mul_right (z) : f.lift hg z * g (f.sec z).2 = g (f.sec z).1 := by\n  erw [mul_assoc, IsUnit.liftRight_inv_mul, mul_one]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.lift_add_left","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\ng : AddMonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsAddUnit (g ↑y)\nz : N\n⊢ Eq (HAdd.hAdd (g ↑(f.sec z).2) ((f.lift hg) z)) (g (f.sec z).1)","decl":"/-- Given a Localization map `f : M →* N` for a Submonoid `S ⊆ M`, if a `CommMonoid` map\n`g : M →* P` induces a map `f.lift hg : N →* P` then for all `z : N`, we have\n`g y * f.lift hg z = g x`, where `x : M, y ∈ S` are such that `z * f y = f x`. -/\n@[to_additive\n    \"Given a Localization map `f : M →+ N` for a Submonoid `S ⊆ M`, if an `AddCommMonoid` map\n`g : M →+ P` induces a map `f.lift hg : N →+ P` then for all `z : N`, we have\n`g y + f.lift hg z = g x`, where `x : M, y ∈ S` are such that `z + f y = f x`.\"]\ntheorem lift_mul_left (z) : g (f.sec z).2 * f.lift hg z = g (f.sec z).1 := by\n  rw [mul_comm, lift_mul_right]\n\n"}
{"name":"Submonoid.LocalizationMap.lift_mul_left","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\ng : MonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsUnit (g ↑y)\nz : N\n⊢ Eq (HMul.hMul (g ↑(f.sec z).2) ((f.lift hg) z)) (g (f.sec z).1)","decl":"/-- Given a Localization map `f : M →* N` for a Submonoid `S ⊆ M`, if a `CommMonoid` map\n`g : M →* P` induces a map `f.lift hg : N →* P` then for all `z : N`, we have\n`g y * f.lift hg z = g x`, where `x : M, y ∈ S` are such that `z * f y = f x`. -/\n@[to_additive\n    \"Given a Localization map `f : M →+ N` for a Submonoid `S ⊆ M`, if an `AddCommMonoid` map\n`g : M →+ P` induces a map `f.lift hg : N →+ P` then for all `z : N`, we have\n`g y + f.lift hg z = g x`, where `x : M, y ∈ S` are such that `z + f y = f x`.\"]\ntheorem lift_mul_left (z) : g (f.sec z).2 * f.lift hg z = g (f.sec z).1 := by\n  rw [mul_comm, lift_mul_right]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.lift_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\ng : AddMonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsAddUnit (g ↑y)\nx : M\n⊢ Eq ((f.lift hg) (f.toMap x)) (g x)","decl":"@[to_additive (attr := simp)]\ntheorem lift_eq (x : M) : f.lift hg (f.toMap x) = g x := by\n  rw [lift_spec, ← g.map_mul]; exact f.eq_of_eq hg (by rw [sec_spec', f.toMap.map_mul])\n\n"}
{"name":"Submonoid.LocalizationMap.lift_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\ng : MonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsUnit (g ↑y)\nx : M\n⊢ Eq ((f.lift hg) (f.toMap x)) (g x)","decl":"@[to_additive (attr := simp)]\ntheorem lift_eq (x : M) : f.lift hg (f.toMap x) = g x := by\n  rw [lift_spec, ← g.map_mul]; exact f.eq_of_eq hg (by rw [sec_spec', f.toMap.map_mul])\n\n"}
{"name":"Submonoid.LocalizationMap.lift_eq_iff","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\ng : MonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsUnit (g ↑y)\nx y : Prod M (Subtype fun x => Membership.mem S x)\n⊢ Iff (Eq ((f.lift hg) (f.mk' x.1 x.2)) ((f.lift hg) (f.mk' y.1 y.2))) (Eq (g (HMul.hMul x.1 ↑y.2)) (g (HMul.hMul y.1 ↑x.2)))","decl":"@[to_additive]\ntheorem lift_eq_iff {x y : M × S} :\n    f.lift hg (f.mk' x.1 x.2) = f.lift hg (f.mk' y.1 y.2) ↔ g (x.1 * y.2) = g (y.1 * x.2) := by\n  rw [lift_mk', lift_mk', mul_inv hg]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.lift_eq_iff","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\ng : AddMonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsAddUnit (g ↑y)\nx y : Prod M (Subtype fun x => Membership.mem S x)\n⊢ Iff (Eq ((f.lift hg) (f.mk' x.1 x.2)) ((f.lift hg) (f.mk' y.1 y.2))) (Eq (g (HAdd.hAdd x.1 ↑y.2)) (g (HAdd.hAdd y.1 ↑x.2)))","decl":"@[to_additive]\ntheorem lift_eq_iff {x y : M × S} :\n    f.lift hg (f.mk' x.1 x.2) = f.lift hg (f.mk' y.1 y.2) ↔ g (x.1 * y.2) = g (y.1 * x.2) := by\n  rw [lift_mk', lift_mk', mul_inv hg]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.lift_comp","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\ng : AddMonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsAddUnit (g ↑y)\n⊢ Eq ((f.lift hg).comp f.toMap) g","decl":"@[to_additive (attr := simp)]\ntheorem lift_comp : (f.lift hg).comp f.toMap = g := by ext; exact f.lift_eq hg _\n\n"}
{"name":"Submonoid.LocalizationMap.lift_comp","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\ng : MonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsUnit (g ↑y)\n⊢ Eq ((f.lift hg).comp f.toMap) g","decl":"@[to_additive (attr := simp)]\ntheorem lift_comp : (f.lift hg).comp f.toMap = g := by ext; exact f.lift_eq hg _\n\n"}
{"name":"Submonoid.LocalizationMap.lift_of_comp","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\nj : MonoidHom N P\n⊢ Eq (f.lift ⋯) j","decl":"@[to_additive (attr := simp)]\ntheorem lift_of_comp (j : N →* P) : f.lift (f.isUnit_comp j) = j := by\n  ext\n  simp_rw [lift_spec, MonoidHom.comp_apply, ← j.map_mul, sec_spec']\n\n"}
{"name":"AddSubmonoid.LocalizationMap.lift_of_comp","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\nj : AddMonoidHom N P\n⊢ Eq (f.lift ⋯) j","decl":"@[to_additive (attr := simp)]\ntheorem lift_of_comp (j : N →* P) : f.lift (f.isUnit_comp j) = j := by\n  ext\n  simp_rw [lift_spec, MonoidHom.comp_apply, ← j.map_mul, sec_spec']\n\n"}
{"name":"AddSubmonoid.LocalizationMap.epic_of_localizationMap","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\nj k : AddMonoidHom N P\nh : ∀ (a : M), Eq ((j.comp f.toMap) a) ((k.comp f.toMap) a)\n⊢ Eq j k","decl":"@[to_additive]\ntheorem epic_of_localizationMap {j k : N →* P} (h : ∀ a, j.comp f.toMap a = k.comp f.toMap a) :\n    j = k := by\n  rw [← f.lift_of_comp j, ← f.lift_of_comp k]\n  congr 1 with x; exact h x\n\n"}
{"name":"Submonoid.LocalizationMap.epic_of_localizationMap","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\nj k : MonoidHom N P\nh : ∀ (a : M), Eq ((j.comp f.toMap) a) ((k.comp f.toMap) a)\n⊢ Eq j k","decl":"@[to_additive]\ntheorem epic_of_localizationMap {j k : N →* P} (h : ∀ a, j.comp f.toMap a = k.comp f.toMap a) :\n    j = k := by\n  rw [← f.lift_of_comp j, ← f.lift_of_comp k]\n  congr 1 with x; exact h x\n\n"}
{"name":"AddSubmonoid.LocalizationMap.lift_unique","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\ng : AddMonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsAddUnit (g ↑y)\nj : AddMonoidHom N P\nhj : ∀ (x : M), Eq (j (f.toMap x)) (g x)\n⊢ Eq (f.lift hg) j","decl":"@[to_additive]\ntheorem lift_unique {j : N →* P} (hj : ∀ x, j (f.toMap x) = g x) : f.lift hg = j := by\n  ext\n  rw [lift_spec, ← hj, ← hj, ← j.map_mul]\n  apply congr_arg\n  rw [← sec_spec']\n\n"}
{"name":"Submonoid.LocalizationMap.lift_unique","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\ng : MonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsUnit (g ↑y)\nj : MonoidHom N P\nhj : ∀ (x : M), Eq (j (f.toMap x)) (g x)\n⊢ Eq (f.lift hg) j","decl":"@[to_additive]\ntheorem lift_unique {j : N →* P} (hj : ∀ x, j (f.toMap x) = g x) : f.lift hg = j := by\n  ext\n  rw [lift_spec, ← hj, ← hj, ← j.map_mul]\n  apply congr_arg\n  rw [← sec_spec']\n\n"}
{"name":"Submonoid.LocalizationMap.lift_id","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx : N\n⊢ Eq ((f.lift ⋯) x) x","decl":"@[to_additive (attr := simp)]\ntheorem lift_id (x) : f.lift f.map_units x = x :=\n  DFunLike.ext_iff.1 (f.lift_of_comp <| MonoidHom.id N) x\n\n"}
{"name":"AddSubmonoid.LocalizationMap.lift_id","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx : N\n⊢ Eq ((f.lift ⋯) x) x","decl":"@[to_additive (attr := simp)]\ntheorem lift_id (x) : f.lift f.map_units x = x :=\n  DFunLike.ext_iff.1 (f.lift_of_comp <| MonoidHom.id N) x\n\n"}
{"name":"AddSubmonoid.LocalizationMap.lift_comp_lift","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝² : AddCommMonoid N\nf : S.LocalizationMap N\nT : AddSubmonoid M\nhST : LE.le S T\nQ : Type u_4\ninst✝¹ : AddCommMonoid Q\nk : T.LocalizationMap Q\nA : Type u_5\ninst✝ : AddCommMonoid A\nl : AddMonoidHom M A\nhl : ∀ (w : Subtype fun x => Membership.mem T x), IsAddUnit (l ↑w)\n⊢ Eq ((k.lift hl).comp (f.lift ⋯)) (f.lift ⋯)","decl":"/-- Given Localization maps `f : M →* N` for a Submonoid `S ⊆ M` and\n`k : M →* Q` for a Submonoid `T ⊆ M`, such that `S ≤ T`, and we have\n`l : M →* A`, the composition of the induced map `f.lift` for `k` with\nthe induced map `k.lift` for `l` is equal to the induced map `f.lift` for `l`. -/\n@[to_additive\n    \"Given Localization maps `f : M →+ N` for a Submonoid `S ⊆ M` and\n`k : M →+ Q` for a Submonoid `T ⊆ M`, such that `S ≤ T`, and we have\n`l : M →+ A`, the composition of the induced map `f.lift` for `k` with\nthe induced map `k.lift` for `l` is equal to the induced map `f.lift` for `l`\"]\ntheorem lift_comp_lift {T : Submonoid M} (hST : S ≤ T) {Q : Type*} [CommMonoid Q]\n    (k : LocalizationMap T Q) {A : Type*} [CommMonoid A] {l : M →* A}\n    (hl : ∀ w : T, IsUnit (l w)) :\n    (k.lift hl).comp (f.lift (map_units k ⟨_, hST ·.2⟩)) =\n    f.lift (hl ⟨_, hST ·.2⟩) := .symm <|\n  lift_unique _ _ fun x ↦ by rw [← MonoidHom.comp_apply,\n    MonoidHom.comp_assoc, lift_comp, lift_comp]\n\n"}
{"name":"Submonoid.LocalizationMap.lift_comp_lift","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝² : CommMonoid N\nf : S.LocalizationMap N\nT : Submonoid M\nhST : LE.le S T\nQ : Type u_4\ninst✝¹ : CommMonoid Q\nk : T.LocalizationMap Q\nA : Type u_5\ninst✝ : CommMonoid A\nl : MonoidHom M A\nhl : ∀ (w : Subtype fun x => Membership.mem T x), IsUnit (l ↑w)\n⊢ Eq ((k.lift hl).comp (f.lift ⋯)) (f.lift ⋯)","decl":"/-- Given Localization maps `f : M →* N` for a Submonoid `S ⊆ M` and\n`k : M →* Q` for a Submonoid `T ⊆ M`, such that `S ≤ T`, and we have\n`l : M →* A`, the composition of the induced map `f.lift` for `k` with\nthe induced map `k.lift` for `l` is equal to the induced map `f.lift` for `l`. -/\n@[to_additive\n    \"Given Localization maps `f : M →+ N` for a Submonoid `S ⊆ M` and\n`k : M →+ Q` for a Submonoid `T ⊆ M`, such that `S ≤ T`, and we have\n`l : M →+ A`, the composition of the induced map `f.lift` for `k` with\nthe induced map `k.lift` for `l` is equal to the induced map `f.lift` for `l`\"]\ntheorem lift_comp_lift {T : Submonoid M} (hST : S ≤ T) {Q : Type*} [CommMonoid Q]\n    (k : LocalizationMap T Q) {A : Type*} [CommMonoid A] {l : M →* A}\n    (hl : ∀ w : T, IsUnit (l w)) :\n    (k.lift hl).comp (f.lift (map_units k ⟨_, hST ·.2⟩)) =\n    f.lift (hl ⟨_, hST ·.2⟩) := .symm <|\n  lift_unique _ _ fun x ↦ by rw [← MonoidHom.comp_apply,\n    MonoidHom.comp_assoc, lift_comp, lift_comp]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.lift_comp_lift_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝² : AddCommMonoid N\nf : S.LocalizationMap N\nQ : Type u_4\ninst✝¹ : AddCommMonoid Q\nk : S.LocalizationMap Q\nA : Type u_5\ninst✝ : AddCommMonoid A\nl : AddMonoidHom M A\nhl : ∀ (w : Subtype fun x => Membership.mem S x), IsAddUnit (l ↑w)\n⊢ Eq ((k.lift hl).comp (f.lift ⋯)) (f.lift hl)","decl":"@[to_additive]\ntheorem lift_comp_lift_eq {Q : Type*} [CommMonoid Q] (k : LocalizationMap S Q)\n    {A : Type*} [CommMonoid A] {l : M →* A} (hl : ∀ w : S, IsUnit (l w)) :\n    (k.lift hl).comp (f.lift k.map_units) = f.lift hl :=\n  lift_comp_lift f le_rfl k hl\n\n"}
{"name":"Submonoid.LocalizationMap.lift_comp_lift_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝² : CommMonoid N\nf : S.LocalizationMap N\nQ : Type u_4\ninst✝¹ : CommMonoid Q\nk : S.LocalizationMap Q\nA : Type u_5\ninst✝ : CommMonoid A\nl : MonoidHom M A\nhl : ∀ (w : Subtype fun x => Membership.mem S x), IsUnit (l ↑w)\n⊢ Eq ((k.lift hl).comp (f.lift ⋯)) (f.lift hl)","decl":"@[to_additive]\ntheorem lift_comp_lift_eq {Q : Type*} [CommMonoid Q] (k : LocalizationMap S Q)\n    {A : Type*} [CommMonoid A] {l : M →* A} (hl : ∀ w : S, IsUnit (l w)) :\n    (k.lift hl).comp (f.lift k.map_units) = f.lift hl :=\n  lift_comp_lift f le_rfl k hl\n\n"}
{"name":"Submonoid.LocalizationMap.lift_left_inverse","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\nk : S.LocalizationMap P\nz : N\n⊢ Eq ((k.lift ⋯) ((f.lift ⋯) z)) z","decl":"/-- Given two Localization maps `f : M →* N, k : M →* P` for a Submonoid `S ⊆ M`, the hom\nfrom `P` to `N` induced by `f` is left inverse to the hom from `N` to `P` induced by `k`. -/\n@[to_additive (attr := simp)\n    \"Given two Localization maps `f : M →+ N, k : M →+ P` for a Submonoid `S ⊆ M`, the hom\nfrom `P` to `N` induced by `f` is left inverse to the hom from `N` to `P` induced by `k`.\"]\ntheorem lift_left_inverse {k : LocalizationMap S P} (z : N) :\n    k.lift f.map_units (f.lift k.map_units z) = z :=\n  (DFunLike.congr_fun (lift_comp_lift_eq f k f.map_units) z).trans (lift_id f z)\n\n"}
{"name":"AddSubmonoid.LocalizationMap.lift_left_inverse","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\nk : S.LocalizationMap P\nz : N\n⊢ Eq ((k.lift ⋯) ((f.lift ⋯) z)) z","decl":"/-- Given two Localization maps `f : M →* N, k : M →* P` for a Submonoid `S ⊆ M`, the hom\nfrom `P` to `N` induced by `f` is left inverse to the hom from `N` to `P` induced by `k`. -/\n@[to_additive (attr := simp)\n    \"Given two Localization maps `f : M →+ N, k : M →+ P` for a Submonoid `S ⊆ M`, the hom\nfrom `P` to `N` induced by `f` is left inverse to the hom from `N` to `P` induced by `k`.\"]\ntheorem lift_left_inverse {k : LocalizationMap S P} (z : N) :\n    k.lift f.map_units (f.lift k.map_units z) = z :=\n  (DFunLike.congr_fun (lift_comp_lift_eq f k f.map_units) z).trans (lift_id f z)\n\n"}
{"name":"AddSubmonoid.LocalizationMap.lift_surjective_iff","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\ng : AddMonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsAddUnit (g ↑y)\n⊢ Iff (Function.Surjective ⇑(f.lift hg)) (∀ (v : P), Exists fun x => Eq (HAdd.hAdd v (g ↑x.2)) (g x.1))","decl":"@[to_additive]\ntheorem lift_surjective_iff :\n    Function.Surjective (f.lift hg) ↔ ∀ v : P, ∃ x : M × S, v * g x.2 = g x.1 := by\n  constructor\n  · intro H v\n    obtain ⟨z, hz⟩ := H v\n    obtain ⟨x, hx⟩ := f.surj z\n    use x\n    rw [← hz, f.eq_mk'_iff_mul_eq.2 hx, lift_mk', mul_assoc, mul_comm _ (g ↑x.2),\n      ← MonoidHom.restrict_apply, IsUnit.mul_liftRight_inv (g.restrict S) hg, mul_one]\n  · intro H v\n    obtain ⟨x, hx⟩ := H v\n    use f.mk' x.1 x.2\n    rw [lift_mk', mul_inv_left hg, mul_comm, ← hx]\n\n"}
{"name":"Submonoid.LocalizationMap.lift_surjective_iff","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\ng : MonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsUnit (g ↑y)\n⊢ Iff (Function.Surjective ⇑(f.lift hg)) (∀ (v : P), Exists fun x => Eq (HMul.hMul v (g ↑x.2)) (g x.1))","decl":"@[to_additive]\ntheorem lift_surjective_iff :\n    Function.Surjective (f.lift hg) ↔ ∀ v : P, ∃ x : M × S, v * g x.2 = g x.1 := by\n  constructor\n  · intro H v\n    obtain ⟨z, hz⟩ := H v\n    obtain ⟨x, hx⟩ := f.surj z\n    use x\n    rw [← hz, f.eq_mk'_iff_mul_eq.2 hx, lift_mk', mul_assoc, mul_comm _ (g ↑x.2),\n      ← MonoidHom.restrict_apply, IsUnit.mul_liftRight_inv (g.restrict S) hg, mul_one]\n  · intro H v\n    obtain ⟨x, hx⟩ := H v\n    use f.mk' x.1 x.2\n    rw [lift_mk', mul_inv_left hg, mul_comm, ← hx]\n\n"}
{"name":"Submonoid.LocalizationMap.lift_injective_iff","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\ng : MonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsUnit (g ↑y)\n⊢ Iff (Function.Injective ⇑(f.lift hg)) (∀ (x y : M), Iff (Eq (f.toMap x) (f.toMap y)) (Eq (g x) (g y)))","decl":"@[to_additive]\ntheorem lift_injective_iff :\n    Function.Injective (f.lift hg) ↔ ∀ x y, f.toMap x = f.toMap y ↔ g x = g y := by\n  constructor\n  · intro H x y\n    constructor\n    · exact f.eq_of_eq hg\n    · intro h\n      rw [← f.lift_eq hg, ← f.lift_eq hg] at h\n      exact H h\n  · intro H z w h\n    obtain ⟨_, _⟩ := f.surj z\n    obtain ⟨_, _⟩ := f.surj w\n    rw [← f.mk'_sec z, ← f.mk'_sec w]\n    exact (mul_inv f.map_units).2 ((H _ _).2 <| (mul_inv hg).1 h)\n\n"}
{"name":"AddSubmonoid.LocalizationMap.lift_injective_iff","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\ng : AddMonoidHom M P\nhg : ∀ (y : Subtype fun x => Membership.mem S x), IsAddUnit (g ↑y)\n⊢ Iff (Function.Injective ⇑(f.lift hg)) (∀ (x y : M), Iff (Eq (f.toMap x) (f.toMap y)) (Eq (g x) (g y)))","decl":"@[to_additive]\ntheorem lift_injective_iff :\n    Function.Injective (f.lift hg) ↔ ∀ x y, f.toMap x = f.toMap y ↔ g x = g y := by\n  constructor\n  · intro H x y\n    constructor\n    · exact f.eq_of_eq hg\n    · intro h\n      rw [← f.lift_eq hg, ← f.lift_eq hg] at h\n      exact H h\n  · intro H z w h\n    obtain ⟨_, _⟩ := f.surj z\n    obtain ⟨_, _⟩ := f.surj w\n    rw [← f.mk'_sec z, ← f.mk'_sec w]\n    exact (mul_inv f.map_units).2 ((H _ _).2 <| (mul_inv hg).1 h)\n\n"}
{"name":"AddSubmonoid.LocalizationMap.map_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝² : AddCommMonoid N\nP : Type u_3\ninst✝¹ : AddCommMonoid P\nf : S.LocalizationMap N\ng : AddMonoidHom M P\nT : AddSubmonoid P\nhy : ∀ (y : Subtype fun x => Membership.mem S x), Membership.mem T (g ↑y)\nQ : Type u_4\ninst✝ : AddCommMonoid Q\nk : T.LocalizationMap Q\nx : M\n⊢ Eq ((f.map hy k) (f.toMap x)) (k.toMap (g x))","decl":"@[to_additive]\ntheorem map_eq (x) : f.map hy k (f.toMap x) = k.toMap (g x) :=\n  f.lift_eq (fun y ↦ k.map_units ⟨g y, hy y⟩) x\n\n"}
{"name":"Submonoid.LocalizationMap.map_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝² : CommMonoid N\nP : Type u_3\ninst✝¹ : CommMonoid P\nf : S.LocalizationMap N\ng : MonoidHom M P\nT : Submonoid P\nhy : ∀ (y : Subtype fun x => Membership.mem S x), Membership.mem T (g ↑y)\nQ : Type u_4\ninst✝ : CommMonoid Q\nk : T.LocalizationMap Q\nx : M\n⊢ Eq ((f.map hy k) (f.toMap x)) (k.toMap (g x))","decl":"@[to_additive]\ntheorem map_eq (x) : f.map hy k (f.toMap x) = k.toMap (g x) :=\n  f.lift_eq (fun y ↦ k.map_units ⟨g y, hy y⟩) x\n\n"}
{"name":"Submonoid.LocalizationMap.map_comp","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝² : CommMonoid N\nP : Type u_3\ninst✝¹ : CommMonoid P\nf : S.LocalizationMap N\ng : MonoidHom M P\nT : Submonoid P\nhy : ∀ (y : Subtype fun x => Membership.mem S x), Membership.mem T (g ↑y)\nQ : Type u_4\ninst✝ : CommMonoid Q\nk : T.LocalizationMap Q\n⊢ Eq ((f.map hy k).comp f.toMap) (k.toMap.comp g)","decl":"@[to_additive (attr := simp)]\ntheorem map_comp : (f.map hy k).comp f.toMap = k.toMap.comp g :=\n  f.lift_comp fun y ↦ k.map_units ⟨g y, hy y⟩\n\n"}
{"name":"AddSubmonoid.LocalizationMap.map_comp","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝² : AddCommMonoid N\nP : Type u_3\ninst✝¹ : AddCommMonoid P\nf : S.LocalizationMap N\ng : AddMonoidHom M P\nT : AddSubmonoid P\nhy : ∀ (y : Subtype fun x => Membership.mem S x), Membership.mem T (g ↑y)\nQ : Type u_4\ninst✝ : AddCommMonoid Q\nk : T.LocalizationMap Q\n⊢ Eq ((f.map hy k).comp f.toMap) (k.toMap.comp g)","decl":"@[to_additive (attr := simp)]\ntheorem map_comp : (f.map hy k).comp f.toMap = k.toMap.comp g :=\n  f.lift_comp fun y ↦ k.map_units ⟨g y, hy y⟩\n\n"}
{"name":"Submonoid.LocalizationMap.map_mk'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝² : CommMonoid N\nP : Type u_3\ninst✝¹ : CommMonoid P\nf : S.LocalizationMap N\ng : MonoidHom M P\nT : Submonoid P\nhy : ∀ (y : Subtype fun x => Membership.mem S x), Membership.mem T (g ↑y)\nQ : Type u_4\ninst✝ : CommMonoid Q\nk : T.LocalizationMap Q\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq ((f.map hy k) (f.mk' x y)) (k.mk' (g x) ⟨g ↑y, ⋯⟩)","decl":"@[to_additive]\ntheorem map_mk' (x) (y : S) : f.map hy k (f.mk' x y) = k.mk' (g x) ⟨g y, hy y⟩ := by\n  rw [map, lift_mk', mul_inv_left]\n  show k.toMap (g x) = k.toMap (g y) * _\n  rw [mul_mk'_eq_mk'_of_mul]\n  exact (k.mk'_mul_cancel_left (g x) ⟨g y, hy y⟩).symm\n\n"}
{"name":"AddSubmonoid.LocalizationMap.map_mk'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝² : AddCommMonoid N\nP : Type u_3\ninst✝¹ : AddCommMonoid P\nf : S.LocalizationMap N\ng : AddMonoidHom M P\nT : AddSubmonoid P\nhy : ∀ (y : Subtype fun x => Membership.mem S x), Membership.mem T (g ↑y)\nQ : Type u_4\ninst✝ : AddCommMonoid Q\nk : T.LocalizationMap Q\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq ((f.map hy k) (f.mk' x y)) (k.mk' (g x) ⟨g ↑y, ⋯⟩)","decl":"@[to_additive]\ntheorem map_mk' (x) (y : S) : f.map hy k (f.mk' x y) = k.mk' (g x) ⟨g y, hy y⟩ := by\n  rw [map, lift_mk', mul_inv_left]\n  show k.toMap (g x) = k.toMap (g y) * _\n  rw [mul_mk'_eq_mk'_of_mul]\n  exact (k.mk'_mul_cancel_left (g x) ⟨g y, hy y⟩).symm\n\n"}
{"name":"AddSubmonoid.LocalizationMap.map_spec","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝² : AddCommMonoid N\nP : Type u_3\ninst✝¹ : AddCommMonoid P\nf : S.LocalizationMap N\ng : AddMonoidHom M P\nT : AddSubmonoid P\nhy : ∀ (y : Subtype fun x => Membership.mem S x), Membership.mem T (g ↑y)\nQ : Type u_4\ninst✝ : AddCommMonoid Q\nk : T.LocalizationMap Q\nz : N\nu : Q\n⊢ Iff (Eq ((f.map hy k) z) u) (Eq (k.toMap (g (f.sec z).1)) (HAdd.hAdd (k.toMap (g ↑(f.sec z).2)) u))","decl":"/-- Given Localization maps `f : M →* N, k : P →* Q` for Submonoids `S, T` respectively, if a\n`CommMonoid` homomorphism `g : M →* P` induces a `f.map hy k : N →* Q`, then for all `z : N`,\n`u : Q`, we have `f.map hy k z = u ↔ k (g x) = k (g y) * u` where `x : M, y ∈ S` are such that\n`z * f y = f x`. -/\n@[to_additive\n    \"Given Localization maps `f : M →+ N, k : P →+ Q` for Submonoids `S, T` respectively, if an\n`AddCommMonoid` homomorphism `g : M →+ P` induces a `f.map hy k : N →+ Q`, then for all `z : N`,\n`u : Q`, we have `f.map hy k z = u ↔ k (g x) = k (g y) + u` where `x : M, y ∈ S` are such that\n`z + f y = f x`.\"]\ntheorem map_spec (z u) : f.map hy k z = u ↔ k.toMap (g (f.sec z).1) = k.toMap (g (f.sec z).2) * u :=\n  f.lift_spec (fun y ↦ k.map_units ⟨g y, hy y⟩) _ _\n\n"}
{"name":"Submonoid.LocalizationMap.map_spec","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝² : CommMonoid N\nP : Type u_3\ninst✝¹ : CommMonoid P\nf : S.LocalizationMap N\ng : MonoidHom M P\nT : Submonoid P\nhy : ∀ (y : Subtype fun x => Membership.mem S x), Membership.mem T (g ↑y)\nQ : Type u_4\ninst✝ : CommMonoid Q\nk : T.LocalizationMap Q\nz : N\nu : Q\n⊢ Iff (Eq ((f.map hy k) z) u) (Eq (k.toMap (g (f.sec z).1)) (HMul.hMul (k.toMap (g ↑(f.sec z).2)) u))","decl":"/-- Given Localization maps `f : M →* N, k : P →* Q` for Submonoids `S, T` respectively, if a\n`CommMonoid` homomorphism `g : M →* P` induces a `f.map hy k : N →* Q`, then for all `z : N`,\n`u : Q`, we have `f.map hy k z = u ↔ k (g x) = k (g y) * u` where `x : M, y ∈ S` are such that\n`z * f y = f x`. -/\n@[to_additive\n    \"Given Localization maps `f : M →+ N, k : P →+ Q` for Submonoids `S, T` respectively, if an\n`AddCommMonoid` homomorphism `g : M →+ P` induces a `f.map hy k : N →+ Q`, then for all `z : N`,\n`u : Q`, we have `f.map hy k z = u ↔ k (g x) = k (g y) + u` where `x : M, y ∈ S` are such that\n`z + f y = f x`.\"]\ntheorem map_spec (z u) : f.map hy k z = u ↔ k.toMap (g (f.sec z).1) = k.toMap (g (f.sec z).2) * u :=\n  f.lift_spec (fun y ↦ k.map_units ⟨g y, hy y⟩) _ _\n\n"}
{"name":"AddSubmonoid.LocalizationMap.map_add_right","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝² : AddCommMonoid N\nP : Type u_3\ninst✝¹ : AddCommMonoid P\nf : S.LocalizationMap N\ng : AddMonoidHom M P\nT : AddSubmonoid P\nhy : ∀ (y : Subtype fun x => Membership.mem S x), Membership.mem T (g ↑y)\nQ : Type u_4\ninst✝ : AddCommMonoid Q\nk : T.LocalizationMap Q\nz : N\n⊢ Eq (HAdd.hAdd ((f.map hy k) z) (k.toMap (g ↑(f.sec z).2))) (k.toMap (g (f.sec z).1))","decl":"/-- Given Localization maps `f : M →* N, k : P →* Q` for Submonoids `S, T` respectively, if a\n`CommMonoid` homomorphism `g : M →* P` induces a `f.map hy k : N →* Q`, then for all `z : N`,\nwe have `f.map hy k z * k (g y) = k (g x)` where `x : M, y ∈ S` are such that\n`z * f y = f x`. -/\n@[to_additive\n    \"Given Localization maps `f : M →+ N, k : P →+ Q` for Submonoids `S, T` respectively, if an\n`AddCommMonoid` homomorphism `g : M →+ P` induces a `f.map hy k : N →+ Q`, then for all `z : N`,\nwe have `f.map hy k z + k (g y) = k (g x)` where `x : M, y ∈ S` are such that\n`z + f y = f x`.\"]\ntheorem map_mul_right (z) : f.map hy k z * k.toMap (g (f.sec z).2) = k.toMap (g (f.sec z).1) :=\n  f.lift_mul_right (fun y ↦ k.map_units ⟨g y, hy y⟩) _\n\n"}
{"name":"Submonoid.LocalizationMap.map_mul_right","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝² : CommMonoid N\nP : Type u_3\ninst✝¹ : CommMonoid P\nf : S.LocalizationMap N\ng : MonoidHom M P\nT : Submonoid P\nhy : ∀ (y : Subtype fun x => Membership.mem S x), Membership.mem T (g ↑y)\nQ : Type u_4\ninst✝ : CommMonoid Q\nk : T.LocalizationMap Q\nz : N\n⊢ Eq (HMul.hMul ((f.map hy k) z) (k.toMap (g ↑(f.sec z).2))) (k.toMap (g (f.sec z).1))","decl":"/-- Given Localization maps `f : M →* N, k : P →* Q` for Submonoids `S, T` respectively, if a\n`CommMonoid` homomorphism `g : M →* P` induces a `f.map hy k : N →* Q`, then for all `z : N`,\nwe have `f.map hy k z * k (g y) = k (g x)` where `x : M, y ∈ S` are such that\n`z * f y = f x`. -/\n@[to_additive\n    \"Given Localization maps `f : M →+ N, k : P →+ Q` for Submonoids `S, T` respectively, if an\n`AddCommMonoid` homomorphism `g : M →+ P` induces a `f.map hy k : N →+ Q`, then for all `z : N`,\nwe have `f.map hy k z + k (g y) = k (g x)` where `x : M, y ∈ S` are such that\n`z + f y = f x`.\"]\ntheorem map_mul_right (z) : f.map hy k z * k.toMap (g (f.sec z).2) = k.toMap (g (f.sec z).1) :=\n  f.lift_mul_right (fun y ↦ k.map_units ⟨g y, hy y⟩) _\n\n"}
{"name":"Submonoid.LocalizationMap.map_mul_left","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝² : CommMonoid N\nP : Type u_3\ninst✝¹ : CommMonoid P\nf : S.LocalizationMap N\ng : MonoidHom M P\nT : Submonoid P\nhy : ∀ (y : Subtype fun x => Membership.mem S x), Membership.mem T (g ↑y)\nQ : Type u_4\ninst✝ : CommMonoid Q\nk : T.LocalizationMap Q\nz : N\n⊢ Eq (HMul.hMul (k.toMap (g ↑(f.sec z).2)) ((f.map hy k) z)) (k.toMap (g (f.sec z).1))","decl":"/-- Given Localization maps `f : M →* N, k : P →* Q` for Submonoids `S, T` respectively, if a\n`CommMonoid` homomorphism `g : M →* P` induces a `f.map hy k : N →* Q`, then for all `z : N`,\nwe have `k (g y) * f.map hy k z = k (g x)` where `x : M, y ∈ S` are such that\n`z * f y = f x`. -/\n@[to_additive\n    \"Given Localization maps `f : M →+ N, k : P →+ Q` for Submonoids `S, T` respectively if an\n`AddCommMonoid` homomorphism `g : M →+ P` induces a `f.map hy k : N →+ Q`, then for all `z : N`,\nwe have `k (g y) + f.map hy k z = k (g x)` where `x : M, y ∈ S` are such that\n`z + f y = f x`.\"]\ntheorem map_mul_left (z) : k.toMap (g (f.sec z).2) * f.map hy k z = k.toMap (g (f.sec z).1) := by\n  rw [mul_comm, f.map_mul_right]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.map_add_left","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝² : AddCommMonoid N\nP : Type u_3\ninst✝¹ : AddCommMonoid P\nf : S.LocalizationMap N\ng : AddMonoidHom M P\nT : AddSubmonoid P\nhy : ∀ (y : Subtype fun x => Membership.mem S x), Membership.mem T (g ↑y)\nQ : Type u_4\ninst✝ : AddCommMonoid Q\nk : T.LocalizationMap Q\nz : N\n⊢ Eq (HAdd.hAdd (k.toMap (g ↑(f.sec z).2)) ((f.map hy k) z)) (k.toMap (g (f.sec z).1))","decl":"/-- Given Localization maps `f : M →* N, k : P →* Q` for Submonoids `S, T` respectively, if a\n`CommMonoid` homomorphism `g : M →* P` induces a `f.map hy k : N →* Q`, then for all `z : N`,\nwe have `k (g y) * f.map hy k z = k (g x)` where `x : M, y ∈ S` are such that\n`z * f y = f x`. -/\n@[to_additive\n    \"Given Localization maps `f : M →+ N, k : P →+ Q` for Submonoids `S, T` respectively if an\n`AddCommMonoid` homomorphism `g : M →+ P` induces a `f.map hy k : N →+ Q`, then for all `z : N`,\nwe have `k (g y) + f.map hy k z = k (g x)` where `x : M, y ∈ S` are such that\n`z + f y = f x`.\"]\ntheorem map_mul_left (z) : k.toMap (g (f.sec z).2) * f.map hy k z = k.toMap (g (f.sec z).1) := by\n  rw [mul_comm, f.map_mul_right]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.map_id","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nz : N\n⊢ Eq ((f.map ⋯ f) z) z","decl":"@[to_additive (attr := simp)]\ntheorem map_id (z : N) : f.map (fun y ↦ show MonoidHom.id M y ∈ S from y.2) f z = z :=\n  f.lift_id z\n\n"}
{"name":"Submonoid.LocalizationMap.map_id","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nz : N\n⊢ Eq ((f.map ⋯ f) z) z","decl":"@[to_additive (attr := simp)]\ntheorem map_id (z : N) : f.map (fun y ↦ show MonoidHom.id M y ∈ S from y.2) f z = z :=\n  f.lift_id z\n\n"}
{"name":"AddSubmonoid.LocalizationMap.map_comp_map","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝⁵ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝⁴ : AddCommMonoid N\nP : Type u_3\ninst✝³ : AddCommMonoid P\nf : S.LocalizationMap N\ng : AddMonoidHom M P\nT : AddSubmonoid P\nhy : ∀ (y : Subtype fun x => Membership.mem S x), Membership.mem T (g ↑y)\nQ : Type u_4\ninst✝² : AddCommMonoid Q\nk : T.LocalizationMap Q\nA : Type u_5\ninst✝¹ : AddCommMonoid A\nU : AddSubmonoid A\nR : Type u_6\ninst✝ : AddCommMonoid R\nj : U.LocalizationMap R\nl : AddMonoidHom P A\nhl : ∀ (w : Subtype fun x => Membership.mem T x), Membership.mem U (l ↑w)\n⊢ Eq ((k.map hl j).comp (f.map hy k)) (f.map ⋯ j)","decl":"/-- If `CommMonoid` homs `g : M →* P, l : P →* A` induce maps of localizations, the composition\nof the induced maps equals the map of localizations induced by `l ∘ g`. -/\n@[to_additive\n    \"If `AddCommMonoid` homs `g : M →+ P, l : P →+ A` induce maps of localizations, the composition\nof the induced maps equals the map of localizations induced by `l ∘ g`.\"]\ntheorem map_comp_map {A : Type*} [CommMonoid A] {U : Submonoid A} {R} [CommMonoid R]\n    (j : LocalizationMap U R) {l : P →* A} (hl : ∀ w : T, l w ∈ U) :\n    (k.map hl j).comp (f.map hy k) =\n    f.map (fun x ↦ show l.comp g x ∈ U from hl ⟨g x, hy x⟩) j := by\n  ext z\n  show j.toMap _ * _ = j.toMap (l _) * _\n  rw [mul_inv_left, ← mul_assoc, mul_inv_right]\n  show j.toMap _ * j.toMap (l (g _)) = j.toMap (l _) * _\n  rw [← j.toMap.map_mul, ← j.toMap.map_mul, ← l.map_mul, ← l.map_mul]\n  exact\n    k.comp_eq_of_eq hl j\n      (by rw [k.toMap.map_mul, k.toMap.map_mul, sec_spec', mul_assoc, map_mul_right])\n\n"}
{"name":"Submonoid.LocalizationMap.map_comp_map","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝⁵ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝⁴ : CommMonoid N\nP : Type u_3\ninst✝³ : CommMonoid P\nf : S.LocalizationMap N\ng : MonoidHom M P\nT : Submonoid P\nhy : ∀ (y : Subtype fun x => Membership.mem S x), Membership.mem T (g ↑y)\nQ : Type u_4\ninst✝² : CommMonoid Q\nk : T.LocalizationMap Q\nA : Type u_5\ninst✝¹ : CommMonoid A\nU : Submonoid A\nR : Type u_6\ninst✝ : CommMonoid R\nj : U.LocalizationMap R\nl : MonoidHom P A\nhl : ∀ (w : Subtype fun x => Membership.mem T x), Membership.mem U (l ↑w)\n⊢ Eq ((k.map hl j).comp (f.map hy k)) (f.map ⋯ j)","decl":"/-- If `CommMonoid` homs `g : M →* P, l : P →* A` induce maps of localizations, the composition\nof the induced maps equals the map of localizations induced by `l ∘ g`. -/\n@[to_additive\n    \"If `AddCommMonoid` homs `g : M →+ P, l : P →+ A` induce maps of localizations, the composition\nof the induced maps equals the map of localizations induced by `l ∘ g`.\"]\ntheorem map_comp_map {A : Type*} [CommMonoid A] {U : Submonoid A} {R} [CommMonoid R]\n    (j : LocalizationMap U R) {l : P →* A} (hl : ∀ w : T, l w ∈ U) :\n    (k.map hl j).comp (f.map hy k) =\n    f.map (fun x ↦ show l.comp g x ∈ U from hl ⟨g x, hy x⟩) j := by\n  ext z\n  show j.toMap _ * _ = j.toMap (l _) * _\n  rw [mul_inv_left, ← mul_assoc, mul_inv_right]\n  show j.toMap _ * j.toMap (l (g _)) = j.toMap (l _) * _\n  rw [← j.toMap.map_mul, ← j.toMap.map_mul, ← l.map_mul, ← l.map_mul]\n  exact\n    k.comp_eq_of_eq hl j\n      (by rw [k.toMap.map_mul, k.toMap.map_mul, sec_spec', mul_assoc, map_mul_right])\n\n"}
{"name":"Submonoid.LocalizationMap.map_map","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝⁵ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝⁴ : CommMonoid N\nP : Type u_3\ninst✝³ : CommMonoid P\nf : S.LocalizationMap N\ng : MonoidHom M P\nT : Submonoid P\nhy : ∀ (y : Subtype fun x => Membership.mem S x), Membership.mem T (g ↑y)\nQ : Type u_4\ninst✝² : CommMonoid Q\nk : T.LocalizationMap Q\nA : Type u_5\ninst✝¹ : CommMonoid A\nU : Submonoid A\nR : Type u_6\ninst✝ : CommMonoid R\nj : U.LocalizationMap R\nl : MonoidHom P A\nhl : ∀ (w : Subtype fun x => Membership.mem T x), Membership.mem U (l ↑w)\nx : N\n⊢ Eq ((k.map hl j) ((f.map hy k) x)) ((f.map ⋯ j) x)","decl":"/-- If `CommMonoid` homs `g : M →* P, l : P →* A` induce maps of localizations, the composition\nof the induced maps equals the map of localizations induced by `l ∘ g`. -/\n@[to_additive\n    \"If `AddCommMonoid` homs `g : M →+ P, l : P →+ A` induce maps of localizations, the composition\nof the induced maps equals the map of localizations induced by `l ∘ g`.\"]\ntheorem map_map {A : Type*} [CommMonoid A] {U : Submonoid A} {R} [CommMonoid R]\n    (j : LocalizationMap U R) {l : P →* A} (hl : ∀ w : T, l w ∈ U) (x) :\n    k.map hl j (f.map hy k x) = f.map (fun x ↦ show l.comp g x ∈ U from hl ⟨g x, hy x⟩) j x := by\n-- Porting note: Lean has a hard time figuring out what the implicit arguments should be\n-- when calling `map_comp_map`. Hence the original line below has to be replaced by a much more\n-- explicit one\n--  rw [← f.map_comp_map hy j hl]\n  rw [← @map_comp_map M _ S N _ P _ f g T hy Q _ k A _ U R _ j l hl]\n  simp only [MonoidHom.coe_comp, comp_apply]\n\n"}
{"name":"AddSubmonoid.LocalizationMap.map_map","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝⁵ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝⁴ : AddCommMonoid N\nP : Type u_3\ninst✝³ : AddCommMonoid P\nf : S.LocalizationMap N\ng : AddMonoidHom M P\nT : AddSubmonoid P\nhy : ∀ (y : Subtype fun x => Membership.mem S x), Membership.mem T (g ↑y)\nQ : Type u_4\ninst✝² : AddCommMonoid Q\nk : T.LocalizationMap Q\nA : Type u_5\ninst✝¹ : AddCommMonoid A\nU : AddSubmonoid A\nR : Type u_6\ninst✝ : AddCommMonoid R\nj : U.LocalizationMap R\nl : AddMonoidHom P A\nhl : ∀ (w : Subtype fun x => Membership.mem T x), Membership.mem U (l ↑w)\nx : N\n⊢ Eq ((k.map hl j) ((f.map hy k) x)) ((f.map ⋯ j) x)","decl":"/-- If `CommMonoid` homs `g : M →* P, l : P →* A` induce maps of localizations, the composition\nof the induced maps equals the map of localizations induced by `l ∘ g`. -/\n@[to_additive\n    \"If `AddCommMonoid` homs `g : M →+ P, l : P →+ A` induce maps of localizations, the composition\nof the induced maps equals the map of localizations induced by `l ∘ g`.\"]\ntheorem map_map {A : Type*} [CommMonoid A] {U : Submonoid A} {R} [CommMonoid R]\n    (j : LocalizationMap U R) {l : P →* A} (hl : ∀ w : T, l w ∈ U) (x) :\n    k.map hl j (f.map hy k x) = f.map (fun x ↦ show l.comp g x ∈ U from hl ⟨g x, hy x⟩) j x := by\n-- Porting note: Lean has a hard time figuring out what the implicit arguments should be\n-- when calling `map_comp_map`. Hence the original line below has to be replaced by a much more\n-- explicit one\n--  rw [← f.map_comp_map hy j hl]\n  rw [← @map_comp_map M _ S N _ P _ f g T hy Q _ k A _ U R _ j l hl]\n  simp only [MonoidHom.coe_comp, comp_apply]\n\n"}
{"name":"Submonoid.LocalizationMap.map_injective_of_injective","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝² : CommMonoid N\nP : Type u_3\ninst✝¹ : CommMonoid P\nf : S.LocalizationMap N\ng : MonoidHom M P\nQ : Type u_4\ninst✝ : CommMonoid Q\nhg : Function.Injective ⇑g\nk : (Submonoid.map g S).LocalizationMap Q\n⊢ Function.Injective ⇑(f.map ⋯ k)","decl":"/-- Given an injective `CommMonoid` homomorphism `g : M →* P`, and a submonoid `S ⊆ M`,\nthe induced monoid homomorphism from the localization of `M` at `S` to the\nlocalization of `P` at `g S`, is injective.\n-/\n@[to_additive \"Given an injective `AddCommMonoid` homomorphism `g : M →+ P`, and a\nsubmonoid `S ⊆ M`, the induced monoid homomorphism from the localization of `M` at `S`\nto the localization of `P` at `g S`, is injective. \"]\ntheorem map_injective_of_injective (hg : Injective g) (k : LocalizationMap (S.map g) Q) :\n    Injective (map f (apply_coe_mem_map g S) k) := fun z w hizw ↦ by\n  set i := map f (apply_coe_mem_map g S) k\n  have ifkg (a : M) : i (f.toMap a) = k.toMap (g a) := map_eq f (apply_coe_mem_map g S) a\n  let ⟨z', w', x, hxz, hxw⟩ := surj₂ f z w\n  have : k.toMap (g z') = k.toMap (g w') := by\n    rw [← ifkg, ← ifkg, ← hxz, ← hxw, map_mul, map_mul, hizw]\n  obtain ⟨⟨_, c, hc, rfl⟩, eq⟩ := k.exists_of_eq _ _ this\n  simp_rw [← map_mul, hg.eq_iff] at eq\n  rw [← (f.map_units x).mul_left_inj, hxz, hxw, f.eq_iff_exists]\n  exact ⟨⟨c, hc⟩, eq⟩\n\n"}
{"name":"AddSubmonoid.LocalizationMap.map_injective_of_injective","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝² : AddCommMonoid N\nP : Type u_3\ninst✝¹ : AddCommMonoid P\nf : S.LocalizationMap N\ng : AddMonoidHom M P\nQ : Type u_4\ninst✝ : AddCommMonoid Q\nhg : Function.Injective ⇑g\nk : (AddSubmonoid.map g S).LocalizationMap Q\n⊢ Function.Injective ⇑(f.map ⋯ k)","decl":"/-- Given an injective `CommMonoid` homomorphism `g : M →* P`, and a submonoid `S ⊆ M`,\nthe induced monoid homomorphism from the localization of `M` at `S` to the\nlocalization of `P` at `g S`, is injective.\n-/\n@[to_additive \"Given an injective `AddCommMonoid` homomorphism `g : M →+ P`, and a\nsubmonoid `S ⊆ M`, the induced monoid homomorphism from the localization of `M` at `S`\nto the localization of `P` at `g S`, is injective. \"]\ntheorem map_injective_of_injective (hg : Injective g) (k : LocalizationMap (S.map g) Q) :\n    Injective (map f (apply_coe_mem_map g S) k) := fun z w hizw ↦ by\n  set i := map f (apply_coe_mem_map g S) k\n  have ifkg (a : M) : i (f.toMap a) = k.toMap (g a) := map_eq f (apply_coe_mem_map g S) a\n  let ⟨z', w', x, hxz, hxw⟩ := surj₂ f z w\n  have : k.toMap (g z') = k.toMap (g w') := by\n    rw [← ifkg, ← ifkg, ← hxz, ← hxw, map_mul, map_mul, hizw]\n  obtain ⟨⟨_, c, hc, rfl⟩, eq⟩ := k.exists_of_eq _ _ this\n  simp_rw [← map_mul, hg.eq_iff] at eq\n  rw [← (f.map_units x).mul_left_inj, hxz, hxw, f.eq_iff_exists]\n  exact ⟨⟨c, hc⟩, eq⟩\n\n"}
{"name":"Submonoid.LocalizationMap.map_surjective_of_surjective","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝² : CommMonoid N\nP : Type u_3\ninst✝¹ : CommMonoid P\nf : S.LocalizationMap N\ng : MonoidHom M P\nQ : Type u_4\ninst✝ : CommMonoid Q\nhg : Function.Surjective ⇑g\nk : (Submonoid.map g S).LocalizationMap Q\n⊢ Function.Surjective ⇑(f.map ⋯ k)","decl":"/-- Given a surjective `CommMonoid` homomorphism `g : M →* P`, and a submonoid `S ⊆ M`,\nthe induced monoid homomorphism from the localization of `M` at `S` to the\nlocalization of `P` at `g S`, is surjective.\n-/\n@[to_additive \"Given a surjective `AddCommMonoid` homomorphism `g : M →+ P`, and a\nsubmonoid `S ⊆ M`, the induced monoid homomorphism from the localization of `M` at `S`\nto the localization of `P` at `g S`, is surjective. \"]\ntheorem map_surjective_of_surjective (hg : Surjective g) (k : LocalizationMap (S.map g) Q) :\n    Surjective (map f (apply_coe_mem_map g S) k) := fun z ↦ by\n  obtain ⟨y, ⟨y', s, hs, rfl⟩, rfl⟩ := k.mk'_surjective z\n  obtain ⟨x, rfl⟩ := hg y\n  use f.mk' x ⟨s, hs⟩\n  rw [map_mk']\n\n"}
{"name":"AddSubmonoid.LocalizationMap.map_surjective_of_surjective","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝² : AddCommMonoid N\nP : Type u_3\ninst✝¹ : AddCommMonoid P\nf : S.LocalizationMap N\ng : AddMonoidHom M P\nQ : Type u_4\ninst✝ : AddCommMonoid Q\nhg : Function.Surjective ⇑g\nk : (AddSubmonoid.map g S).LocalizationMap Q\n⊢ Function.Surjective ⇑(f.map ⋯ k)","decl":"/-- Given a surjective `CommMonoid` homomorphism `g : M →* P`, and a submonoid `S ⊆ M`,\nthe induced monoid homomorphism from the localization of `M` at `S` to the\nlocalization of `P` at `g S`, is surjective.\n-/\n@[to_additive \"Given a surjective `AddCommMonoid` homomorphism `g : M →+ P`, and a\nsubmonoid `S ⊆ M`, the induced monoid homomorphism from the localization of `M` at `S`\nto the localization of `P` at `g S`, is surjective. \"]\ntheorem map_surjective_of_surjective (hg : Surjective g) (k : LocalizationMap (S.map g) Q) :\n    Surjective (map f (apply_coe_mem_map g S) k) := fun z ↦ by\n  obtain ⟨y, ⟨y', s, hs, rfl⟩, rfl⟩ := k.mk'_surjective z\n  obtain ⟨x, rfl⟩ := hg y\n  use f.mk' x ⟨s, hs⟩\n  rw [map_mk']\n\n"}
{"name":"AddSubmonoid.LocalizationMap.addEquivOfLocalizations_apply","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\nk : S.LocalizationMap P\nx : N\n⊢ Eq ((f.addEquivOfLocalizations k) x) ((f.lift ⋯) x)","decl":"@[to_additive (attr := simp)]\ntheorem mulEquivOfLocalizations_apply {k : LocalizationMap S P} {x} :\n    f.mulEquivOfLocalizations k x = f.lift k.map_units x := rfl\n\n"}
{"name":"Submonoid.LocalizationMap.mulEquivOfLocalizations_apply","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\nk : S.LocalizationMap P\nx : N\n⊢ Eq ((f.mulEquivOfLocalizations k) x) ((f.lift ⋯) x)","decl":"@[to_additive (attr := simp)]\ntheorem mulEquivOfLocalizations_apply {k : LocalizationMap S P} {x} :\n    f.mulEquivOfLocalizations k x = f.lift k.map_units x := rfl\n\n"}
{"name":"AddSubmonoid.LocalizationMap.addEquivOfLocalizations_symm_apply","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\nk : S.LocalizationMap P\nx : P\n⊢ Eq ((f.addEquivOfLocalizations k).symm x) ((k.lift ⋯) x)","decl":"@[to_additive (attr := simp)]\ntheorem mulEquivOfLocalizations_symm_apply {k : LocalizationMap S P} {x} :\n    (f.mulEquivOfLocalizations k).symm x = k.lift f.map_units x := rfl\n\n"}
{"name":"Submonoid.LocalizationMap.mulEquivOfLocalizations_symm_apply","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\nk : S.LocalizationMap P\nx : P\n⊢ Eq ((f.mulEquivOfLocalizations k).symm x) ((k.lift ⋯) x)","decl":"@[to_additive (attr := simp)]\ntheorem mulEquivOfLocalizations_symm_apply {k : LocalizationMap S P} {x} :\n    (f.mulEquivOfLocalizations k).symm x = k.lift f.map_units x := rfl\n\n"}
{"name":"Submonoid.LocalizationMap.mulEquivOfLocalizations_symm_eq_mulEquivOfLocalizations","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\nk : S.LocalizationMap P\n⊢ Eq (k.mulEquivOfLocalizations f).symm (f.mulEquivOfLocalizations k)","decl":"@[to_additive]\ntheorem mulEquivOfLocalizations_symm_eq_mulEquivOfLocalizations {k : LocalizationMap S P} :\n    (k.mulEquivOfLocalizations f).symm = f.mulEquivOfLocalizations k := rfl\n\n"}
{"name":"AddSubmonoid.LocalizationMap.addEquivOfLocalizations_symm_eq_addEquivOfLocalizations","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\nk : S.LocalizationMap P\n⊢ Eq (k.addEquivOfLocalizations f).symm (f.addEquivOfLocalizations k)","decl":"@[to_additive]\ntheorem mulEquivOfLocalizations_symm_eq_mulEquivOfLocalizations {k : LocalizationMap S P} :\n    (k.mulEquivOfLocalizations f).symm = f.mulEquivOfLocalizations k := rfl\n\n"}
{"name":"Submonoid.LocalizationMap.ofMulEquivOfLocalizations_apply","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\nk : MulEquiv N P\nx : M\n⊢ Eq ((f.ofMulEquivOfLocalizations k).toMap x) (k (f.toMap x))","decl":"@[to_additive (attr := simp)]\ntheorem ofMulEquivOfLocalizations_apply {k : N ≃* P} (x) :\n    (f.ofMulEquivOfLocalizations k).toMap x = k (f.toMap x) := rfl\n\n"}
{"name":"AddSubmonoid.LocalizationMap.ofAddEquivOfLocalizations_apply","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\nk : AddEquiv N P\nx : M\n⊢ Eq ((f.ofAddEquivOfLocalizations k).toMap x) (k (f.toMap x))","decl":"@[to_additive (attr := simp)]\ntheorem ofMulEquivOfLocalizations_apply {k : N ≃* P} (x) :\n    (f.ofMulEquivOfLocalizations k).toMap x = k (f.toMap x) := rfl\n\n"}
{"name":"AddSubmonoid.LocalizationMap.ofAddEquivOfLocalizations_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\nk : AddEquiv N P\n⊢ Eq (f.ofAddEquivOfLocalizations k).toMap (k.toAddMonoidHom.comp f.toMap)","decl":"@[to_additive]\ntheorem ofMulEquivOfLocalizations_eq {k : N ≃* P} :\n    (f.ofMulEquivOfLocalizations k).toMap = k.toMonoidHom.comp f.toMap := rfl\n\n"}
{"name":"Submonoid.LocalizationMap.ofMulEquivOfLocalizations_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\nk : MulEquiv N P\n⊢ Eq (f.ofMulEquivOfLocalizations k).toMap (k.toMonoidHom.comp f.toMap)","decl":"@[to_additive]\ntheorem ofMulEquivOfLocalizations_eq {k : N ≃* P} :\n    (f.ofMulEquivOfLocalizations k).toMap = k.toMonoidHom.comp f.toMap := rfl\n\n"}
{"name":"AddSubmonoid.LocalizationMap.symm_comp_ofAddEquivOfLocalizations_apply","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\nk : AddEquiv N P\nx : M\n⊢ Eq (k.symm ((f.ofAddEquivOfLocalizations k).toMap x)) (f.toMap x)","decl":"@[to_additive]\ntheorem symm_comp_ofMulEquivOfLocalizations_apply {k : N ≃* P} (x) :\n    k.symm ((f.ofMulEquivOfLocalizations k).toMap x) = f.toMap x := k.symm_apply_apply (f.toMap x)\n\n"}
{"name":"Submonoid.LocalizationMap.symm_comp_ofMulEquivOfLocalizations_apply","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\nk : MulEquiv N P\nx : M\n⊢ Eq (k.symm ((f.ofMulEquivOfLocalizations k).toMap x)) (f.toMap x)","decl":"@[to_additive]\ntheorem symm_comp_ofMulEquivOfLocalizations_apply {k : N ≃* P} (x) :\n    k.symm ((f.ofMulEquivOfLocalizations k).toMap x) = f.toMap x := k.symm_apply_apply (f.toMap x)\n\n"}
{"name":"Submonoid.LocalizationMap.symm_comp_ofMulEquivOfLocalizations_apply'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\nk : MulEquiv P N\nx : M\n⊢ Eq (k ((f.ofMulEquivOfLocalizations k.symm).toMap x)) (f.toMap x)","decl":"@[to_additive]\ntheorem symm_comp_ofMulEquivOfLocalizations_apply' {k : P ≃* N} (x) :\n    k ((f.ofMulEquivOfLocalizations k.symm).toMap x) = f.toMap x := k.apply_symm_apply (f.toMap x)\n\n"}
{"name":"AddSubmonoid.LocalizationMap.symm_comp_ofAddEquivOfLocalizations_apply'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\nk : AddEquiv P N\nx : M\n⊢ Eq (k ((f.ofAddEquivOfLocalizations k.symm).toMap x)) (f.toMap x)","decl":"@[to_additive]\ntheorem symm_comp_ofMulEquivOfLocalizations_apply' {k : P ≃* N} (x) :\n    k ((f.ofMulEquivOfLocalizations k.symm).toMap x) = f.toMap x := k.apply_symm_apply (f.toMap x)\n\n"}
{"name":"AddSubmonoid.LocalizationMap.ofAddEquivOfLocalizations_eq_iff_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\nk : AddEquiv N P\nx : M\ny : P\n⊢ Iff (Eq ((f.ofAddEquivOfLocalizations k).toMap x) y) (Eq (f.toMap x) (k.symm y))","decl":"@[to_additive]\ntheorem ofMulEquivOfLocalizations_eq_iff_eq {k : N ≃* P} {x y} :\n    (f.ofMulEquivOfLocalizations k).toMap x = y ↔ f.toMap x = k.symm y :=\n  k.toEquiv.eq_symm_apply.symm\n\n"}
{"name":"Submonoid.LocalizationMap.ofMulEquivOfLocalizations_eq_iff_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\nk : MulEquiv N P\nx : M\ny : P\n⊢ Iff (Eq ((f.ofMulEquivOfLocalizations k).toMap x) y) (Eq (f.toMap x) (k.symm y))","decl":"@[to_additive]\ntheorem ofMulEquivOfLocalizations_eq_iff_eq {k : N ≃* P} {x y} :\n    (f.ofMulEquivOfLocalizations k).toMap x = y ↔ f.toMap x = k.symm y :=\n  k.toEquiv.eq_symm_apply.symm\n\n"}
{"name":"AddSubmonoid.LocalizationMap.addEquivOfLocalizations_right_inv","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\nk : S.LocalizationMap P\n⊢ Eq (f.ofAddEquivOfLocalizations (f.addEquivOfLocalizations k)) k","decl":"@[to_additive addEquivOfLocalizations_right_inv]\ntheorem mulEquivOfLocalizations_right_inv (k : LocalizationMap S P) :\n    f.ofMulEquivOfLocalizations (f.mulEquivOfLocalizations k) = k :=\n  toMap_injective <| f.lift_comp k.map_units\n\n"}
{"name":"Submonoid.LocalizationMap.mulEquivOfLocalizations_right_inv","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\nk : S.LocalizationMap P\n⊢ Eq (f.ofMulEquivOfLocalizations (f.mulEquivOfLocalizations k)) k","decl":"@[to_additive addEquivOfLocalizations_right_inv]\ntheorem mulEquivOfLocalizations_right_inv (k : LocalizationMap S P) :\n    f.ofMulEquivOfLocalizations (f.mulEquivOfLocalizations k) = k :=\n  toMap_injective <| f.lift_comp k.map_units\n\n"}
{"name":"Submonoid.LocalizationMap.mulEquivOfLocalizations_right_inv_apply","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\nk : S.LocalizationMap P\nx : M\n⊢ Eq ((f.ofMulEquivOfLocalizations (f.mulEquivOfLocalizations k)).toMap x) (k.toMap x)","decl":"@[to_additive addEquivOfLocalizations_right_inv_apply]\ntheorem mulEquivOfLocalizations_right_inv_apply {k : LocalizationMap S P} {x} :\n    (f.ofMulEquivOfLocalizations (f.mulEquivOfLocalizations k)).toMap x = k.toMap x := by simp\n\n"}
{"name":"AddSubmonoid.LocalizationMap.addEquivOfLocalizations_right_inv_apply","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\nk : S.LocalizationMap P\nx : M\n⊢ Eq ((f.ofAddEquivOfLocalizations (f.addEquivOfLocalizations k)).toMap x) (k.toMap x)","decl":"@[to_additive addEquivOfLocalizations_right_inv_apply]\ntheorem mulEquivOfLocalizations_right_inv_apply {k : LocalizationMap S P} {x} :\n    (f.ofMulEquivOfLocalizations (f.mulEquivOfLocalizations k)).toMap x = k.toMap x := by simp\n\n"}
{"name":"Submonoid.LocalizationMap.mulEquivOfLocalizations_left_inv","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\nk : MulEquiv N P\n⊢ Eq (f.mulEquivOfLocalizations (f.ofMulEquivOfLocalizations k)) k","decl":"@[to_additive]\ntheorem mulEquivOfLocalizations_left_inv (k : N ≃* P) :\n    f.mulEquivOfLocalizations (f.ofMulEquivOfLocalizations k) = k :=\n  DFunLike.ext _ _ fun x ↦ DFunLike.ext_iff.1 (f.lift_of_comp k.toMonoidHom) x\n\n"}
{"name":"AddSubmonoid.LocalizationMap.addEquivOfLocalizations_left_neg","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\nk : AddEquiv N P\n⊢ Eq (f.addEquivOfLocalizations (f.ofAddEquivOfLocalizations k)) k","decl":"@[to_additive]\ntheorem mulEquivOfLocalizations_left_inv (k : N ≃* P) :\n    f.mulEquivOfLocalizations (f.ofMulEquivOfLocalizations k) = k :=\n  DFunLike.ext _ _ fun x ↦ DFunLike.ext_iff.1 (f.lift_of_comp k.toMonoidHom) x\n\n"}
{"name":"AddSubmonoid.LocalizationMap.addEquivOfLocalizations_left_neg_apply","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\nk : AddEquiv N P\nx : N\n⊢ Eq ((f.addEquivOfLocalizations (f.ofAddEquivOfLocalizations k)) x) (k x)","decl":"@[to_additive]\ntheorem mulEquivOfLocalizations_left_inv_apply {k : N ≃* P} (x) :\n    f.mulEquivOfLocalizations (f.ofMulEquivOfLocalizations k) x = k x := by simp\n\n"}
{"name":"Submonoid.LocalizationMap.mulEquivOfLocalizations_left_inv_apply","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\nk : MulEquiv N P\nx : N\n⊢ Eq ((f.mulEquivOfLocalizations (f.ofMulEquivOfLocalizations k)) x) (k x)","decl":"@[to_additive]\ntheorem mulEquivOfLocalizations_left_inv_apply {k : N ≃* P} (x) :\n    f.mulEquivOfLocalizations (f.ofMulEquivOfLocalizations k) x = k x := by simp\n\n"}
{"name":"Submonoid.LocalizationMap.ofMulEquivOfLocalizations_id","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\n⊢ Eq (f.ofMulEquivOfLocalizations (MulEquiv.refl N)) f","decl":"@[to_additive (attr := simp)]\ntheorem ofMulEquivOfLocalizations_id : f.ofMulEquivOfLocalizations (MulEquiv.refl N) = f := by\n  ext; rfl\n\n"}
{"name":"AddSubmonoid.LocalizationMap.ofAddEquivOfLocalizations_id","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\n⊢ Eq (f.ofAddEquivOfLocalizations (AddEquiv.refl N)) f","decl":"@[to_additive (attr := simp)]\ntheorem ofMulEquivOfLocalizations_id : f.ofMulEquivOfLocalizations (MulEquiv.refl N) = f := by\n  ext; rfl\n\n"}
{"name":"Submonoid.LocalizationMap.ofMulEquivOfLocalizations_comp","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝² : CommMonoid N\nP : Type u_3\ninst✝¹ : CommMonoid P\nf : S.LocalizationMap N\nQ : Type u_4\ninst✝ : CommMonoid Q\nk : MulEquiv N P\nj : MulEquiv P Q\n⊢ Eq (f.ofMulEquivOfLocalizations (k.trans j)).toMap (j.toMonoidHom.comp (f.ofMulEquivOfLocalizations k).toMap)","decl":"@[to_additive]\ntheorem ofMulEquivOfLocalizations_comp {k : N ≃* P} {j : P ≃* Q} :\n    (f.ofMulEquivOfLocalizations (k.trans j)).toMap =\n      j.toMonoidHom.comp (f.ofMulEquivOfLocalizations k).toMap := by\n  ext; rfl\n\n"}
{"name":"AddSubmonoid.LocalizationMap.ofAddEquivOfLocalizations_comp","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝² : AddCommMonoid N\nP : Type u_3\ninst✝¹ : AddCommMonoid P\nf : S.LocalizationMap N\nQ : Type u_4\ninst✝ : AddCommMonoid Q\nk : AddEquiv N P\nj : AddEquiv P Q\n⊢ Eq (f.ofAddEquivOfLocalizations (k.trans j)).toMap (j.toAddMonoidHom.comp (f.ofAddEquivOfLocalizations k).toMap)","decl":"@[to_additive]\ntheorem ofMulEquivOfLocalizations_comp {k : N ≃* P} {j : P ≃* Q} :\n    (f.ofMulEquivOfLocalizations (k.trans j)).toMap =\n      j.toMonoidHom.comp (f.ofMulEquivOfLocalizations k).toMap := by\n  ext; rfl\n\n"}
{"name":"Submonoid.LocalizationMap.ofMulEquivOfDom_apply","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\nT : Submonoid P\nk : MulEquiv P M\nH : Eq (Submonoid.map k.toMonoidHom T) S\nx : P\n⊢ Eq ((f.ofMulEquivOfDom H).toMap x) (f.toMap (k x))","decl":"@[to_additive (attr := simp)]\ntheorem ofMulEquivOfDom_apply {k : P ≃* M} (H : T.map k.toMonoidHom = S) (x) :\n    (f.ofMulEquivOfDom H).toMap x = f.toMap (k x) := rfl\n\n"}
{"name":"AddSubmonoid.LocalizationMap.ofAddEquivOfDom_apply","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\nT : AddSubmonoid P\nk : AddEquiv P M\nH : Eq (AddSubmonoid.map k.toAddMonoidHom T) S\nx : P\n⊢ Eq ((f.ofAddEquivOfDom H).toMap x) (f.toMap (k x))","decl":"@[to_additive (attr := simp)]\ntheorem ofMulEquivOfDom_apply {k : P ≃* M} (H : T.map k.toMonoidHom = S) (x) :\n    (f.ofMulEquivOfDom H).toMap x = f.toMap (k x) := rfl\n\n"}
{"name":"Submonoid.LocalizationMap.ofMulEquivOfDom_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\nT : Submonoid P\nk : MulEquiv P M\nH : Eq (Submonoid.map k.toMonoidHom T) S\n⊢ Eq (f.ofMulEquivOfDom H).toMap (f.toMap.comp k.toMonoidHom)","decl":"@[to_additive]\ntheorem ofMulEquivOfDom_eq {k : P ≃* M} (H : T.map k.toMonoidHom = S) :\n    (f.ofMulEquivOfDom H).toMap = f.toMap.comp k.toMonoidHom := rfl\n\n"}
{"name":"AddSubmonoid.LocalizationMap.ofAddEquivOfDom_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\nT : AddSubmonoid P\nk : AddEquiv P M\nH : Eq (AddSubmonoid.map k.toAddMonoidHom T) S\n⊢ Eq (f.ofAddEquivOfDom H).toMap (f.toMap.comp k.toAddMonoidHom)","decl":"@[to_additive]\ntheorem ofMulEquivOfDom_eq {k : P ≃* M} (H : T.map k.toMonoidHom = S) :\n    (f.ofMulEquivOfDom H).toMap = f.toMap.comp k.toMonoidHom := rfl\n\n"}
{"name":"AddSubmonoid.LocalizationMap.ofAddEquivOfDom_comp_symm","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\nT : AddSubmonoid P\nk : AddEquiv P M\nH : Eq (AddSubmonoid.map k.toAddMonoidHom T) S\nx : M\n⊢ Eq ((f.ofAddEquivOfDom H).toMap (k.symm x)) (f.toMap x)","decl":"@[to_additive]\ntheorem ofMulEquivOfDom_comp_symm {k : P ≃* M} (H : T.map k.toMonoidHom = S) (x) :\n    (f.ofMulEquivOfDom H).toMap (k.symm x) = f.toMap x :=\n  congr_arg f.toMap <| k.apply_symm_apply x\n\n"}
{"name":"Submonoid.LocalizationMap.ofMulEquivOfDom_comp_symm","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\nT : Submonoid P\nk : MulEquiv P M\nH : Eq (Submonoid.map k.toMonoidHom T) S\nx : M\n⊢ Eq ((f.ofMulEquivOfDom H).toMap (k.symm x)) (f.toMap x)","decl":"@[to_additive]\ntheorem ofMulEquivOfDom_comp_symm {k : P ≃* M} (H : T.map k.toMonoidHom = S) (x) :\n    (f.ofMulEquivOfDom H).toMap (k.symm x) = f.toMap x :=\n  congr_arg f.toMap <| k.apply_symm_apply x\n\n"}
{"name":"Submonoid.LocalizationMap.ofMulEquivOfDom_comp","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoid N\nP : Type u_3\ninst✝ : CommMonoid P\nf : S.LocalizationMap N\nT : Submonoid P\nk : MulEquiv M P\nH : Eq (Submonoid.map k.symm.toMonoidHom T) S\nx : M\n⊢ Eq ((f.ofMulEquivOfDom H).toMap (k x)) (f.toMap x)","decl":"@[to_additive]\ntheorem ofMulEquivOfDom_comp {k : M ≃* P} (H : T.map k.symm.toMonoidHom = S) (x) :\n    (f.ofMulEquivOfDom H).toMap (k x) = f.toMap x := congr_arg f.toMap <| k.symm_apply_apply x\n\n"}
{"name":"AddSubmonoid.LocalizationMap.ofAddEquivOfDom_comp","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝¹ : AddCommMonoid N\nP : Type u_3\ninst✝ : AddCommMonoid P\nf : S.LocalizationMap N\nT : AddSubmonoid P\nk : AddEquiv M P\nH : Eq (AddSubmonoid.map k.symm.toAddMonoidHom T) S\nx : M\n⊢ Eq ((f.ofAddEquivOfDom H).toMap (k x)) (f.toMap x)","decl":"@[to_additive]\ntheorem ofMulEquivOfDom_comp {k : M ≃* P} (H : T.map k.symm.toMonoidHom = S) (x) :\n    (f.ofMulEquivOfDom H).toMap (k x) = f.toMap x := congr_arg f.toMap <| k.symm_apply_apply x\n\n"}
{"name":"Submonoid.LocalizationMap.ofMulEquivOfDom_id","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\n⊢ Eq (f.ofMulEquivOfDom ⋯) f","decl":"/-- A special case of `f ∘ id = f`, `f` a Localization map. -/\n@[to_additive (attr := simp) \"A special case of `f ∘ id = f`, `f` a Localization map.\"]\ntheorem ofMulEquivOfDom_id :\n    f.ofMulEquivOfDom\n        (show S.map (MulEquiv.refl M).toMonoidHom = S from\n          Submonoid.ext fun x ↦ ⟨fun ⟨_, hy, h⟩ ↦ h ▸ hy, fun h ↦ ⟨x, h, rfl⟩⟩) = f := by\n  ext; rfl\n\n"}
{"name":"AddSubmonoid.LocalizationMap.ofAddEquivOfDom_id","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\n⊢ Eq (f.ofAddEquivOfDom ⋯) f","decl":"/-- A special case of `f ∘ id = f`, `f` a Localization map. -/\n@[to_additive (attr := simp) \"A special case of `f ∘ id = f`, `f` a Localization map.\"]\ntheorem ofMulEquivOfDom_id :\n    f.ofMulEquivOfDom\n        (show S.map (MulEquiv.refl M).toMonoidHom = S from\n          Submonoid.ext fun x ↦ ⟨fun ⟨_, hy, h⟩ ↦ h ▸ hy, fun h ↦ ⟨x, h, rfl⟩⟩) = f := by\n  ext; rfl\n\n"}
{"name":"AddSubmonoid.LocalizationMap.addEquivOfAddEquiv_eq_map_apply","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝² : AddCommMonoid N\nP : Type u_3\ninst✝¹ : AddCommMonoid P\nf : S.LocalizationMap N\nT : AddSubmonoid P\nQ : Type u_4\ninst✝ : AddCommMonoid Q\nk : T.LocalizationMap Q\nj : AddEquiv M P\nH : Eq (AddSubmonoid.map j.toAddMonoidHom S) T\nx : N\n⊢ Eq ((f.addEquivOfAddEquiv k H) x) ((f.map ⋯ k) x)","decl":"@[to_additive (attr := simp)]\ntheorem mulEquivOfMulEquiv_eq_map_apply {k : LocalizationMap T Q} {j : M ≃* P}\n    (H : S.map j.toMonoidHom = T) (x) :\n    f.mulEquivOfMulEquiv k H x =\n      f.map (fun y : S ↦ show j.toMonoidHom y ∈ T from H ▸ Set.mem_image_of_mem j y.2) k x := rfl\n\n"}
{"name":"Submonoid.LocalizationMap.mulEquivOfMulEquiv_eq_map_apply","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝² : CommMonoid N\nP : Type u_3\ninst✝¹ : CommMonoid P\nf : S.LocalizationMap N\nT : Submonoid P\nQ : Type u_4\ninst✝ : CommMonoid Q\nk : T.LocalizationMap Q\nj : MulEquiv M P\nH : Eq (Submonoid.map j.toMonoidHom S) T\nx : N\n⊢ Eq ((f.mulEquivOfMulEquiv k H) x) ((f.map ⋯ k) x)","decl":"@[to_additive (attr := simp)]\ntheorem mulEquivOfMulEquiv_eq_map_apply {k : LocalizationMap T Q} {j : M ≃* P}\n    (H : S.map j.toMonoidHom = T) (x) :\n    f.mulEquivOfMulEquiv k H x =\n      f.map (fun y : S ↦ show j.toMonoidHom y ∈ T from H ▸ Set.mem_image_of_mem j y.2) k x := rfl\n\n"}
{"name":"AddSubmonoid.LocalizationMap.addEquivOfAddEquiv_eq_map","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝² : AddCommMonoid N\nP : Type u_3\ninst✝¹ : AddCommMonoid P\nf : S.LocalizationMap N\nT : AddSubmonoid P\nQ : Type u_4\ninst✝ : AddCommMonoid Q\nk : T.LocalizationMap Q\nj : AddEquiv M P\nH : Eq (AddSubmonoid.map j.toAddMonoidHom S) T\n⊢ Eq (f.addEquivOfAddEquiv k H).toAddMonoidHom (f.map ⋯ k)","decl":"@[to_additive]\ntheorem mulEquivOfMulEquiv_eq_map {k : LocalizationMap T Q} {j : M ≃* P}\n    (H : S.map j.toMonoidHom = T) :\n    (f.mulEquivOfMulEquiv k H).toMonoidHom =\n      f.map (fun y : S ↦ show j.toMonoidHom y ∈ T from H ▸ Set.mem_image_of_mem j y.2) k := rfl\n\n"}
{"name":"Submonoid.LocalizationMap.mulEquivOfMulEquiv_eq_map","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝² : CommMonoid N\nP : Type u_3\ninst✝¹ : CommMonoid P\nf : S.LocalizationMap N\nT : Submonoid P\nQ : Type u_4\ninst✝ : CommMonoid Q\nk : T.LocalizationMap Q\nj : MulEquiv M P\nH : Eq (Submonoid.map j.toMonoidHom S) T\n⊢ Eq (f.mulEquivOfMulEquiv k H).toMonoidHom (f.map ⋯ k)","decl":"@[to_additive]\ntheorem mulEquivOfMulEquiv_eq_map {k : LocalizationMap T Q} {j : M ≃* P}\n    (H : S.map j.toMonoidHom = T) :\n    (f.mulEquivOfMulEquiv k H).toMonoidHom =\n      f.map (fun y : S ↦ show j.toMonoidHom y ∈ T from H ▸ Set.mem_image_of_mem j y.2) k := rfl\n\n"}
{"name":"Submonoid.LocalizationMap.mulEquivOfMulEquiv_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝² : CommMonoid N\nP : Type u_3\ninst✝¹ : CommMonoid P\nf : S.LocalizationMap N\nT : Submonoid P\nQ : Type u_4\ninst✝ : CommMonoid Q\nk : T.LocalizationMap Q\nj : MulEquiv M P\nH : Eq (Submonoid.map j.toMonoidHom S) T\nx : M\n⊢ Eq ((f.mulEquivOfMulEquiv k H) (f.toMap x)) (k.toMap (j x))","decl":"@[to_additive (attr := simp, nolint simpNF)]\ntheorem mulEquivOfMulEquiv_eq {k : LocalizationMap T Q} {j : M ≃* P} (H : S.map j.toMonoidHom = T)\n    (x) :\n    f.mulEquivOfMulEquiv k H (f.toMap x) = k.toMap (j x) :=\n  f.map_eq (fun y : S ↦ H ▸ Set.mem_image_of_mem j y.2) _\n\n"}
{"name":"AddSubmonoid.LocalizationMap.addEquivOfAddEquiv_eq","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝² : AddCommMonoid N\nP : Type u_3\ninst✝¹ : AddCommMonoid P\nf : S.LocalizationMap N\nT : AddSubmonoid P\nQ : Type u_4\ninst✝ : AddCommMonoid Q\nk : T.LocalizationMap Q\nj : AddEquiv M P\nH : Eq (AddSubmonoid.map j.toAddMonoidHom S) T\nx : M\n⊢ Eq ((f.addEquivOfAddEquiv k H) (f.toMap x)) (k.toMap (j x))","decl":"@[to_additive (attr := simp, nolint simpNF)]\ntheorem mulEquivOfMulEquiv_eq {k : LocalizationMap T Q} {j : M ≃* P} (H : S.map j.toMonoidHom = T)\n    (x) :\n    f.mulEquivOfMulEquiv k H (f.toMap x) = k.toMap (j x) :=\n  f.map_eq (fun y : S ↦ H ▸ Set.mem_image_of_mem j y.2) _\n\n"}
{"name":"Submonoid.LocalizationMap.mulEquivOfMulEquiv_mk'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝² : CommMonoid N\nP : Type u_3\ninst✝¹ : CommMonoid P\nf : S.LocalizationMap N\nT : Submonoid P\nQ : Type u_4\ninst✝ : CommMonoid Q\nk : T.LocalizationMap Q\nj : MulEquiv M P\nH : Eq (Submonoid.map j.toMonoidHom S) T\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq ((f.mulEquivOfMulEquiv k H) (f.mk' x y)) (k.mk' (j x) ⟨j ↑y, ⋯⟩)","decl":"@[to_additive (attr := simp, nolint simpNF)]\ntheorem mulEquivOfMulEquiv_mk' {k : LocalizationMap T Q} {j : M ≃* P} (H : S.map j.toMonoidHom = T)\n    (x y) :\n    f.mulEquivOfMulEquiv k H (f.mk' x y) = k.mk' (j x) ⟨j y, H ▸ Set.mem_image_of_mem j y.2⟩ :=\n  f.map_mk' (fun y : S ↦ H ▸ Set.mem_image_of_mem j y.2) _ _\n\n"}
{"name":"AddSubmonoid.LocalizationMap.addEquivOfAddEquiv_mk'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝² : AddCommMonoid N\nP : Type u_3\ninst✝¹ : AddCommMonoid P\nf : S.LocalizationMap N\nT : AddSubmonoid P\nQ : Type u_4\ninst✝ : AddCommMonoid Q\nk : T.LocalizationMap Q\nj : AddEquiv M P\nH : Eq (AddSubmonoid.map j.toAddMonoidHom S) T\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq ((f.addEquivOfAddEquiv k H) (f.mk' x y)) (k.mk' (j x) ⟨j ↑y, ⋯⟩)","decl":"@[to_additive (attr := simp, nolint simpNF)]\ntheorem mulEquivOfMulEquiv_mk' {k : LocalizationMap T Q} {j : M ≃* P} (H : S.map j.toMonoidHom = T)\n    (x y) :\n    f.mulEquivOfMulEquiv k H (f.mk' x y) = k.mk' (j x) ⟨j y, H ▸ Set.mem_image_of_mem j y.2⟩ :=\n  f.map_mk' (fun y : S ↦ H ▸ Set.mem_image_of_mem j y.2) _ _\n\n"}
{"name":"Submonoid.LocalizationMap.of_mulEquivOfMulEquiv_apply","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝² : CommMonoid N\nP : Type u_3\ninst✝¹ : CommMonoid P\nf : S.LocalizationMap N\nT : Submonoid P\nQ : Type u_4\ninst✝ : CommMonoid Q\nk : T.LocalizationMap Q\nj : MulEquiv M P\nH : Eq (Submonoid.map j.toMonoidHom S) T\nx : M\n⊢ Eq ((f.ofMulEquivOfLocalizations (f.mulEquivOfMulEquiv k H)).toMap x) (k.toMap (j x))","decl":"@[to_additive (attr := simp, nolint simpNF)]\ntheorem of_mulEquivOfMulEquiv_apply {k : LocalizationMap T Q} {j : M ≃* P}\n    (H : S.map j.toMonoidHom = T) (x) :\n    (f.ofMulEquivOfLocalizations (f.mulEquivOfMulEquiv k H)).toMap x = k.toMap (j x) :=\n  Submonoid.LocalizationMap.ext_iff.1 (f.mulEquivOfLocalizations_right_inv (k.ofMulEquivOfDom H)) x\n\n"}
{"name":"AddSubmonoid.LocalizationMap.of_addEquivOfAddEquiv_apply","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝² : AddCommMonoid N\nP : Type u_3\ninst✝¹ : AddCommMonoid P\nf : S.LocalizationMap N\nT : AddSubmonoid P\nQ : Type u_4\ninst✝ : AddCommMonoid Q\nk : T.LocalizationMap Q\nj : AddEquiv M P\nH : Eq (AddSubmonoid.map j.toAddMonoidHom S) T\nx : M\n⊢ Eq ((f.ofAddEquivOfLocalizations (f.addEquivOfAddEquiv k H)).toMap x) (k.toMap (j x))","decl":"@[to_additive (attr := simp, nolint simpNF)]\ntheorem of_mulEquivOfMulEquiv_apply {k : LocalizationMap T Q} {j : M ≃* P}\n    (H : S.map j.toMonoidHom = T) (x) :\n    (f.ofMulEquivOfLocalizations (f.mulEquivOfMulEquiv k H)).toMap x = k.toMap (j x) :=\n  Submonoid.LocalizationMap.ext_iff.1 (f.mulEquivOfLocalizations_right_inv (k.ofMulEquivOfDom H)) x\n\n"}
{"name":"AddSubmonoid.LocalizationMap.of_addEquivOfAddEquiv","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝² : AddCommMonoid N\nP : Type u_3\ninst✝¹ : AddCommMonoid P\nf : S.LocalizationMap N\nT : AddSubmonoid P\nQ : Type u_4\ninst✝ : AddCommMonoid Q\nk : T.LocalizationMap Q\nj : AddEquiv M P\nH : Eq (AddSubmonoid.map j.toAddMonoidHom S) T\n⊢ Eq (f.ofAddEquivOfLocalizations (f.addEquivOfAddEquiv k H)).toMap (k.toMap.comp j.toAddMonoidHom)","decl":"@[to_additive]\ntheorem of_mulEquivOfMulEquiv {k : LocalizationMap T Q} {j : M ≃* P} (H : S.map j.toMonoidHom = T) :\n    (f.ofMulEquivOfLocalizations (f.mulEquivOfMulEquiv k H)).toMap = k.toMap.comp j.toMonoidHom :=\n  MonoidHom.ext <| f.of_mulEquivOfMulEquiv_apply H\n\n"}
{"name":"Submonoid.LocalizationMap.of_mulEquivOfMulEquiv","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝² : CommMonoid N\nP : Type u_3\ninst✝¹ : CommMonoid P\nf : S.LocalizationMap N\nT : Submonoid P\nQ : Type u_4\ninst✝ : CommMonoid Q\nk : T.LocalizationMap Q\nj : MulEquiv M P\nH : Eq (Submonoid.map j.toMonoidHom S) T\n⊢ Eq (f.ofMulEquivOfLocalizations (f.mulEquivOfMulEquiv k H)).toMap (k.toMap.comp j.toMonoidHom)","decl":"@[to_additive]\ntheorem of_mulEquivOfMulEquiv {k : LocalizationMap T Q} {j : M ≃* P} (H : S.map j.toMonoidHom = T) :\n    (f.ofMulEquivOfLocalizations (f.mulEquivOfMulEquiv k H)).toMap = k.toMap.comp j.toMonoidHom :=\n  MonoidHom.ext <| f.of_mulEquivOfMulEquiv_apply H\n\n"}
{"name":"AddLocalization.mk_zero_eq_addMonoidOf_mk","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\nx : M\n⊢ Eq (AddLocalization.mk x 0) ((AddLocalization.addMonoidOf S).toMap x)","decl":"@[to_additive]\ntheorem mk_one_eq_monoidOf_mk (x) : mk x 1 = (monoidOf S).toMap x := rfl\n\n"}
{"name":"Localization.mk_one_eq_monoidOf_mk","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\nx : M\n⊢ Eq (Localization.mk x 1) ((Localization.monoidOf S).toMap x)","decl":"@[to_additive]\ntheorem mk_one_eq_monoidOf_mk (x) : mk x 1 = (monoidOf S).toMap x := rfl\n\n"}
{"name":"AddLocalization.mk_eq_addMonoidOf_mk'_apply","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq (AddLocalization.mk x y) ((AddLocalization.addMonoidOf S).mk' x y)","decl":"@[to_additive]\ntheorem mk_eq_monoidOf_mk'_apply (x y) : mk x y = (monoidOf S).mk' x y :=\n  show _ = _ * _ from\n    (Submonoid.LocalizationMap.mul_inv_right (monoidOf S).map_units _ _ _).2 <| by\n      rw [← mk_one_eq_monoidOf_mk, ← mk_one_eq_monoidOf_mk, mk_mul x y y 1, mul_comm y 1]\n      conv => rhs; rw [← mul_one 1]; rw [← mul_one x]\n      exact mk_eq_mk_iff.2 (Con.symm _ <| (Localization.r S).mul (Con.refl _ (x, 1)) <| one_rel _)\n\n"}
{"name":"Localization.mk_eq_monoidOf_mk'_apply","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq (Localization.mk x y) ((Localization.monoidOf S).mk' x y)","decl":"@[to_additive]\ntheorem mk_eq_monoidOf_mk'_apply (x y) : mk x y = (monoidOf S).mk' x y :=\n  show _ = _ * _ from\n    (Submonoid.LocalizationMap.mul_inv_right (monoidOf S).map_units _ _ _).2 <| by\n      rw [← mk_one_eq_monoidOf_mk, ← mk_one_eq_monoidOf_mk, mk_mul x y y 1, mul_comm y 1]\n      conv => rhs; rw [← mul_one 1]; rw [← mul_one x]\n      exact mk_eq_mk_iff.2 (Con.symm _ <| (Localization.r S).mul (Con.refl _ (x, 1)) <| one_rel _)\n\n"}
{"name":"AddLocalization.mk_eq_addMonoidOf_mk'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\n⊢ Eq AddLocalization.mk (AddLocalization.addMonoidOf S).mk'","decl":"@[to_additive]\ntheorem mk_eq_monoidOf_mk' : mk = (monoidOf S).mk' :=\n  funext fun _ ↦ funext fun _ ↦ mk_eq_monoidOf_mk'_apply _ _\n\n"}
{"name":"Localization.mk_eq_monoidOf_mk'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\n⊢ Eq Localization.mk (Localization.monoidOf S).mk'","decl":"@[to_additive]\ntheorem mk_eq_monoidOf_mk' : mk = (monoidOf S).mk' :=\n  funext fun _ ↦ funext fun _ ↦ mk_eq_monoidOf_mk'_apply _ _\n\n"}
{"name":"AddLocalization.liftOn_mk'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\np : Sort u\nf : M → (Subtype fun x => Membership.mem S x) → p\nH : ∀ {a c : M} {b d : Subtype fun x => Membership.mem S x}, (AddLocalization.r S) { fst := a, snd := b } { fst := c, snd := d } → Eq (f a b) (f c d)\na : M\nb : Subtype fun x => Membership.mem S x\n⊢ Eq (((AddLocalization.addMonoidOf S).mk' a b).liftOn f H) (f a b)","decl":"@[to_additive (attr := simp)]\ntheorem liftOn_mk' {p : Sort u} (f : M → S → p) (H) (a : M) (b : S) :\n    liftOn ((monoidOf S).mk' a b) f H = f a b := by rw [← mk_eq_monoidOf_mk', liftOn_mk]\n\n"}
{"name":"Localization.liftOn_mk'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\np : Sort u\nf : M → (Subtype fun x => Membership.mem S x) → p\nH : ∀ {a c : M} {b d : Subtype fun x => Membership.mem S x}, (Localization.r S) { fst := a, snd := b } { fst := c, snd := d } → Eq (f a b) (f c d)\na : M\nb : Subtype fun x => Membership.mem S x\n⊢ Eq (((Localization.monoidOf S).mk' a b).liftOn f H) (f a b)","decl":"@[to_additive (attr := simp)]\ntheorem liftOn_mk' {p : Sort u} (f : M → S → p) (H) (a : M) (b : S) :\n    liftOn ((monoidOf S).mk' a b) f H = f a b := by rw [← mk_eq_monoidOf_mk', liftOn_mk]\n\n"}
{"name":"Localization.liftOn₂_mk'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\np : Sort u_4\nf : M → (Subtype fun x => Membership.mem S x) → M → (Subtype fun x => Membership.mem S x) → p\nH : ∀ {a a' : M} {b b' : Subtype fun x => Membership.mem S x} {c c' : M} {d d' : Subtype fun x => Membership.mem S x}, (Localization.r S) { fst := a, snd := b } { fst := a', snd := b' } → (Localization.r S) { fst := c, snd := d } { fst := c', snd := d' } → Eq (f a b c d) (f a' b' c' d')\na c : M\nb d : Subtype fun x => Membership.mem S x\n⊢ Eq (((Localization.monoidOf S).mk' a b).liftOn₂ ((Localization.monoidOf S).mk' c d) f H) (f a b c d)","decl":"@[to_additive (attr := simp)]\ntheorem liftOn₂_mk' {p : Sort*} (f : M → S → M → S → p) (H) (a c : M) (b d : S) :\n    liftOn₂ ((monoidOf S).mk' a b) ((monoidOf S).mk' c d) f H = f a b c d := by\n  rw [← mk_eq_monoidOf_mk', liftOn₂_mk]\n\n"}
{"name":"AddLocalization.liftOn₂_mk'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\np : Sort u_4\nf : M → (Subtype fun x => Membership.mem S x) → M → (Subtype fun x => Membership.mem S x) → p\nH : ∀ {a a' : M} {b b' : Subtype fun x => Membership.mem S x} {c c' : M} {d d' : Subtype fun x => Membership.mem S x}, (AddLocalization.r S) { fst := a, snd := b } { fst := a', snd := b' } → (AddLocalization.r S) { fst := c, snd := d } { fst := c', snd := d' } → Eq (f a b c d) (f a' b' c' d')\na c : M\nb d : Subtype fun x => Membership.mem S x\n⊢ Eq (((AddLocalization.addMonoidOf S).mk' a b).liftOn₂ ((AddLocalization.addMonoidOf S).mk' c d) f H) (f a b c d)","decl":"@[to_additive (attr := simp)]\ntheorem liftOn₂_mk' {p : Sort*} (f : M → S → M → S → p) (H) (a c : M) (b d : S) :\n    liftOn₂ ((monoidOf S).mk' a b) ((monoidOf S).mk' c d) f H = f a b c d := by\n  rw [← mk_eq_monoidOf_mk', liftOn₂_mk]\n\n"}
{"name":"Localization.mulEquivOfQuotient_apply","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx : Localization S\n⊢ Eq ((Localization.mulEquivOfQuotient f) x) (((Localization.monoidOf S).lift ⋯) x)","decl":"@[to_additive (attr := simp)]\ntheorem mulEquivOfQuotient_apply (x) : mulEquivOfQuotient f x = (monoidOf S).lift f.map_units x :=\n  rfl\n\n"}
{"name":"AddLocalization.addEquivOfQuotient_apply","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx : AddLocalization S\n⊢ Eq ((AddLocalization.addEquivOfQuotient f) x) (((AddLocalization.addMonoidOf S).lift ⋯) x)","decl":"@[to_additive (attr := simp)]\ntheorem mulEquivOfQuotient_apply (x) : mulEquivOfQuotient f x = (monoidOf S).lift f.map_units x :=\n  rfl\n\n"}
{"name":"Localization.mulEquivOfQuotient_mk'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq ((Localization.mulEquivOfQuotient f) ((Localization.monoidOf S).mk' x y)) (f.mk' x y)","decl":"@[to_additive (attr := simp, nolint simpNF)]\ntheorem mulEquivOfQuotient_mk' (x y) : mulEquivOfQuotient f ((monoidOf S).mk' x y) = f.mk' x y :=\n  (monoidOf S).lift_mk' _ _ _\n\n"}
{"name":"AddLocalization.addEquivOfQuotient_mk'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq ((AddLocalization.addEquivOfQuotient f) ((AddLocalization.addMonoidOf S).mk' x y)) (f.mk' x y)","decl":"@[to_additive (attr := simp, nolint simpNF)]\ntheorem mulEquivOfQuotient_mk' (x y) : mulEquivOfQuotient f ((monoidOf S).mk' x y) = f.mk' x y :=\n  (monoidOf S).lift_mk' _ _ _\n\n"}
{"name":"AddLocalization.addEquivOfQuotient_mk","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq ((AddLocalization.addEquivOfQuotient f) (AddLocalization.mk x y)) (f.mk' x y)","decl":"@[to_additive]\ntheorem mulEquivOfQuotient_mk (x y) : mulEquivOfQuotient f (mk x y) = f.mk' x y := by\n  rw [mk_eq_monoidOf_mk'_apply]; exact mulEquivOfQuotient_mk' _ _\n\n"}
{"name":"Localization.mulEquivOfQuotient_mk","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq ((Localization.mulEquivOfQuotient f) (Localization.mk x y)) (f.mk' x y)","decl":"@[to_additive]\ntheorem mulEquivOfQuotient_mk (x y) : mulEquivOfQuotient f (mk x y) = f.mk' x y := by\n  rw [mk_eq_monoidOf_mk'_apply]; exact mulEquivOfQuotient_mk' _ _\n\n"}
{"name":"Localization.mulEquivOfQuotient_monoidOf","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx : M\n⊢ Eq ((Localization.mulEquivOfQuotient f) ((Localization.monoidOf S).toMap x)) (f.toMap x)","decl":"@[to_additive]\ntheorem mulEquivOfQuotient_monoidOf (x) :\n    mulEquivOfQuotient f ((monoidOf S).toMap x) = f.toMap x := by simp\n\n"}
{"name":"AddLocalization.addEquivOfQuotient_addMonoidOf","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx : M\n⊢ Eq ((AddLocalization.addEquivOfQuotient f) ((AddLocalization.addMonoidOf S).toMap x)) (f.toMap x)","decl":"@[to_additive]\ntheorem mulEquivOfQuotient_monoidOf (x) :\n    mulEquivOfQuotient f ((monoidOf S).toMap x) = f.toMap x := by simp\n\n"}
{"name":"AddLocalization.addEquivOfQuotient_symm_mk'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq ((AddLocalization.addEquivOfQuotient f).symm (f.mk' x y)) ((AddLocalization.addMonoidOf S).mk' x y)","decl":"@[to_additive (attr := simp)]\ntheorem mulEquivOfQuotient_symm_mk' (x y) :\n    (mulEquivOfQuotient f).symm (f.mk' x y) = (monoidOf S).mk' x y :=\n  f.lift_mk' (monoidOf S).map_units _ _\n\n"}
{"name":"Localization.mulEquivOfQuotient_symm_mk'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq ((Localization.mulEquivOfQuotient f).symm (f.mk' x y)) ((Localization.monoidOf S).mk' x y)","decl":"@[to_additive (attr := simp)]\ntheorem mulEquivOfQuotient_symm_mk' (x y) :\n    (mulEquivOfQuotient f).symm (f.mk' x y) = (monoidOf S).mk' x y :=\n  f.lift_mk' (monoidOf S).map_units _ _\n\n"}
{"name":"Localization.mulEquivOfQuotient_symm_mk","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq ((Localization.mulEquivOfQuotient f).symm (f.mk' x y)) (Localization.mk x y)","decl":"@[to_additive]\ntheorem mulEquivOfQuotient_symm_mk (x y) : (mulEquivOfQuotient f).symm (f.mk' x y) = mk x y := by\n  rw [mk_eq_monoidOf_mk'_apply]; exact mulEquivOfQuotient_symm_mk' _ _\n\n"}
{"name":"AddLocalization.addEquivOfQuotient_symm_mk","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq ((AddLocalization.addEquivOfQuotient f).symm (f.mk' x y)) (AddLocalization.mk x y)","decl":"@[to_additive]\ntheorem mulEquivOfQuotient_symm_mk (x y) : (mulEquivOfQuotient f).symm (f.mk' x y) = mk x y := by\n  rw [mk_eq_monoidOf_mk'_apply]; exact mulEquivOfQuotient_symm_mk' _ _\n\n"}
{"name":"Localization.mulEquivOfQuotient_symm_monoidOf","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\nx : M\n⊢ Eq ((Localization.mulEquivOfQuotient f).symm (f.toMap x)) ((Localization.monoidOf S).toMap x)","decl":"@[to_additive (attr := simp)]\ntheorem mulEquivOfQuotient_symm_monoidOf (x) :\n    (mulEquivOfQuotient f).symm (f.toMap x) = (monoidOf S).toMap x :=\n  f.lift_eq (monoidOf S).map_units _\n\n"}
{"name":"AddLocalization.addEquivOfQuotient_symm_addMonoidOf","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\nN : Type u_2\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\nx : M\n⊢ Eq ((AddLocalization.addEquivOfQuotient f).symm (f.toMap x)) ((AddLocalization.addMonoidOf S).toMap x)","decl":"@[to_additive (attr := simp)]\ntheorem mulEquivOfQuotient_symm_monoidOf (x) :\n    (mulEquivOfQuotient f).symm (f.toMap x) = (monoidOf S).toMap x :=\n  f.lift_eq (monoidOf S).map_units _\n\n"}
{"name":"AddLocalization.mk_left_injective","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"α : Type u_1\ninst✝ : AddCancelCommMonoid α\ns : AddSubmonoid α\nb : Subtype fun x => Membership.mem s x\n⊢ Function.Injective fun a => AddLocalization.mk a b","decl":"@[to_additive]\ntheorem mk_left_injective (b : s) : Injective fun a => mk a b := fun c d h => by\n  simpa [mk_eq_mk_iff, r_iff_exists] using h\n\n"}
{"name":"Localization.mk_left_injective","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoid α\ns : Submonoid α\nb : Subtype fun x => Membership.mem s x\n⊢ Function.Injective fun a => Localization.mk a b","decl":"@[to_additive]\ntheorem mk_left_injective (b : s) : Injective fun a => mk a b := fun c d h => by\n  simpa [mk_eq_mk_iff, r_iff_exists] using h\n\n"}
{"name":"AddLocalization.mk_eq_mk_iff'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"α : Type u_1\ninst✝ : AddCancelCommMonoid α\ns : AddSubmonoid α\na₁ b₁ : α\na₂ b₂ : Subtype fun x => Membership.mem s x\n⊢ Iff (Eq (AddLocalization.mk a₁ a₂) (AddLocalization.mk b₁ b₂)) (Eq (HAdd.hAdd (↑b₂) a₁) (HAdd.hAdd (↑a₂) b₁))","decl":"@[to_additive]\ntheorem mk_eq_mk_iff' : mk a₁ a₂ = mk b₁ b₂ ↔ ↑b₂ * a₁ = a₂ * b₁ := by\n  simp_rw [mk_eq_mk_iff, r_iff_exists, mul_left_cancel_iff, exists_const]\n\n"}
{"name":"Localization.mk_eq_mk_iff'","module":"Mathlib.GroupTheory.MonoidLocalization.Basic","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoid α\ns : Submonoid α\na₁ b₁ : α\na₂ b₂ : Subtype fun x => Membership.mem s x\n⊢ Iff (Eq (Localization.mk a₁ a₂) (Localization.mk b₁ b₂)) (Eq (HMul.hMul (↑b₂) a₁) (HMul.hMul (↑a₂) b₁))","decl":"@[to_additive]\ntheorem mk_eq_mk_iff' : mk a₁ a₂ = mk b₁ b₂ ↔ ↑b₂ * a₁ = a₂ * b₁ := by\n  simp_rw [mk_eq_mk_iff, r_iff_exists, mul_left_cancel_iff, exists_const]\n\n"}
