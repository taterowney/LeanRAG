{"name":"CategoryTheory.Bicategory.Strict.rightUnitor_eqToIso","module":"Mathlib.CategoryTheory.Bicategory.Strict","initialProofState":"B : Type u\ninstâœ : CategoryTheory.Bicategory B\nself : CategoryTheory.Bicategory.Strict B\na b : B\nf : Quiver.Hom a b\nâŠ¢ Eq (CategoryTheory.Bicategory.rightUnitor f) (CategoryTheory.eqToIso â‹¯)","decl":"/-- A bicategory is called `Strict` if the left unitors, the right unitors, and the associators are\nisomorphisms given by equalities.\n-/\nclass Bicategory.Strict : Prop where\n  /-- Identity morphisms are left identities for composition. -/\n  id_comp : âˆ€ {a b : B} (f : a âŸ¶ b), ğŸ™ a â‰« f = f := by aesop_cat\n  /-- Identity morphisms are right identities for composition. -/\n  comp_id : âˆ€ {a b : B} (f : a âŸ¶ b), f â‰« ğŸ™ b = f := by aesop_cat\n  /-- Composition in a bicategory is associative. -/\n  assoc : âˆ€ {a b c d : B} (f : a âŸ¶ b) (g : b âŸ¶ c) (h : c âŸ¶ d), (f â‰« g) â‰« h = f â‰« g â‰« h := by\n    aesop_cat\n  /-- The left unitors are given by equalities -/\n  leftUnitor_eqToIso : âˆ€ {a b : B} (f : a âŸ¶ b), Î»_ f = eqToIso (id_comp f) := by aesop_cat\n  /-- The right unitors are given by equalities -/\n  rightUnitor_eqToIso : âˆ€ {a b : B} (f : a âŸ¶ b), Ï_ f = eqToIso (comp_id f) := by aesop_cat\n  /-- The associators are given by equalities -/\n  associator_eqToIso :\n    âˆ€ {a b c d : B} (f : a âŸ¶ b) (g : b âŸ¶ c) (h : c âŸ¶ d), Î±_ f g h = eqToIso (assoc f g h) := by\n    aesop_cat\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Bicategory.Strict.assoc","module":"Mathlib.CategoryTheory.Bicategory.Strict","initialProofState":"B : Type u\ninstâœ : CategoryTheory.Bicategory B\nself : CategoryTheory.Bicategory.Strict B\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g) h) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g h))","decl":"/-- A bicategory is called `Strict` if the left unitors, the right unitors, and the associators are\nisomorphisms given by equalities.\n-/\nclass Bicategory.Strict : Prop where\n  /-- Identity morphisms are left identities for composition. -/\n  id_comp : âˆ€ {a b : B} (f : a âŸ¶ b), ğŸ™ a â‰« f = f := by aesop_cat\n  /-- Identity morphisms are right identities for composition. -/\n  comp_id : âˆ€ {a b : B} (f : a âŸ¶ b), f â‰« ğŸ™ b = f := by aesop_cat\n  /-- Composition in a bicategory is associative. -/\n  assoc : âˆ€ {a b c d : B} (f : a âŸ¶ b) (g : b âŸ¶ c) (h : c âŸ¶ d), (f â‰« g) â‰« h = f â‰« g â‰« h := by\n    aesop_cat\n  /-- The left unitors are given by equalities -/\n  leftUnitor_eqToIso : âˆ€ {a b : B} (f : a âŸ¶ b), Î»_ f = eqToIso (id_comp f) := by aesop_cat\n  /-- The right unitors are given by equalities -/\n  rightUnitor_eqToIso : âˆ€ {a b : B} (f : a âŸ¶ b), Ï_ f = eqToIso (comp_id f) := by aesop_cat\n  /-- The associators are given by equalities -/\n  associator_eqToIso :\n    âˆ€ {a b c d : B} (f : a âŸ¶ b) (g : b âŸ¶ c) (h : c âŸ¶ d), Î±_ f g h = eqToIso (assoc f g h) := by\n    aesop_cat\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Bicategory.Strict.associator_eqToIso","module":"Mathlib.CategoryTheory.Bicategory.Strict","initialProofState":"B : Type u\ninstâœ : CategoryTheory.Bicategory B\nself : CategoryTheory.Bicategory.Strict B\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\nâŠ¢ Eq (CategoryTheory.Bicategory.associator f g h) (CategoryTheory.eqToIso â‹¯)","decl":"/-- A bicategory is called `Strict` if the left unitors, the right unitors, and the associators are\nisomorphisms given by equalities.\n-/\nclass Bicategory.Strict : Prop where\n  /-- Identity morphisms are left identities for composition. -/\n  id_comp : âˆ€ {a b : B} (f : a âŸ¶ b), ğŸ™ a â‰« f = f := by aesop_cat\n  /-- Identity morphisms are right identities for composition. -/\n  comp_id : âˆ€ {a b : B} (f : a âŸ¶ b), f â‰« ğŸ™ b = f := by aesop_cat\n  /-- Composition in a bicategory is associative. -/\n  assoc : âˆ€ {a b c d : B} (f : a âŸ¶ b) (g : b âŸ¶ c) (h : c âŸ¶ d), (f â‰« g) â‰« h = f â‰« g â‰« h := by\n    aesop_cat\n  /-- The left unitors are given by equalities -/\n  leftUnitor_eqToIso : âˆ€ {a b : B} (f : a âŸ¶ b), Î»_ f = eqToIso (id_comp f) := by aesop_cat\n  /-- The right unitors are given by equalities -/\n  rightUnitor_eqToIso : âˆ€ {a b : B} (f : a âŸ¶ b), Ï_ f = eqToIso (comp_id f) := by aesop_cat\n  /-- The associators are given by equalities -/\n  associator_eqToIso :\n    âˆ€ {a b c d : B} (f : a âŸ¶ b) (g : b âŸ¶ c) (h : c âŸ¶ d), Î±_ f g h = eqToIso (assoc f g h) := by\n    aesop_cat\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Bicategory.Strict.comp_id","module":"Mathlib.CategoryTheory.Bicategory.Strict","initialProofState":"B : Type u\ninstâœ : CategoryTheory.Bicategory B\nself : CategoryTheory.Bicategory.Strict B\na b : B\nf : Quiver.Hom a b\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.id b)) f","decl":"/-- A bicategory is called `Strict` if the left unitors, the right unitors, and the associators are\nisomorphisms given by equalities.\n-/\nclass Bicategory.Strict : Prop where\n  /-- Identity morphisms are left identities for composition. -/\n  id_comp : âˆ€ {a b : B} (f : a âŸ¶ b), ğŸ™ a â‰« f = f := by aesop_cat\n  /-- Identity morphisms are right identities for composition. -/\n  comp_id : âˆ€ {a b : B} (f : a âŸ¶ b), f â‰« ğŸ™ b = f := by aesop_cat\n  /-- Composition in a bicategory is associative. -/\n  assoc : âˆ€ {a b c d : B} (f : a âŸ¶ b) (g : b âŸ¶ c) (h : c âŸ¶ d), (f â‰« g) â‰« h = f â‰« g â‰« h := by\n    aesop_cat\n  /-- The left unitors are given by equalities -/\n  leftUnitor_eqToIso : âˆ€ {a b : B} (f : a âŸ¶ b), Î»_ f = eqToIso (id_comp f) := by aesop_cat\n  /-- The right unitors are given by equalities -/\n  rightUnitor_eqToIso : âˆ€ {a b : B} (f : a âŸ¶ b), Ï_ f = eqToIso (comp_id f) := by aesop_cat\n  /-- The associators are given by equalities -/\n  associator_eqToIso :\n    âˆ€ {a b c d : B} (f : a âŸ¶ b) (g : b âŸ¶ c) (h : c âŸ¶ d), Î±_ f g h = eqToIso (assoc f g h) := by\n    aesop_cat\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Bicategory.Strict.leftUnitor_eqToIso","module":"Mathlib.CategoryTheory.Bicategory.Strict","initialProofState":"B : Type u\ninstâœ : CategoryTheory.Bicategory B\nself : CategoryTheory.Bicategory.Strict B\na b : B\nf : Quiver.Hom a b\nâŠ¢ Eq (CategoryTheory.Bicategory.leftUnitor f) (CategoryTheory.eqToIso â‹¯)","decl":"/-- A bicategory is called `Strict` if the left unitors, the right unitors, and the associators are\nisomorphisms given by equalities.\n-/\nclass Bicategory.Strict : Prop where\n  /-- Identity morphisms are left identities for composition. -/\n  id_comp : âˆ€ {a b : B} (f : a âŸ¶ b), ğŸ™ a â‰« f = f := by aesop_cat\n  /-- Identity morphisms are right identities for composition. -/\n  comp_id : âˆ€ {a b : B} (f : a âŸ¶ b), f â‰« ğŸ™ b = f := by aesop_cat\n  /-- Composition in a bicategory is associative. -/\n  assoc : âˆ€ {a b c d : B} (f : a âŸ¶ b) (g : b âŸ¶ c) (h : c âŸ¶ d), (f â‰« g) â‰« h = f â‰« g â‰« h := by\n    aesop_cat\n  /-- The left unitors are given by equalities -/\n  leftUnitor_eqToIso : âˆ€ {a b : B} (f : a âŸ¶ b), Î»_ f = eqToIso (id_comp f) := by aesop_cat\n  /-- The right unitors are given by equalities -/\n  rightUnitor_eqToIso : âˆ€ {a b : B} (f : a âŸ¶ b), Ï_ f = eqToIso (comp_id f) := by aesop_cat\n  /-- The associators are given by equalities -/\n  associator_eqToIso :\n    âˆ€ {a b c d : B} (f : a âŸ¶ b) (g : b âŸ¶ c) (h : c âŸ¶ d), Î±_ f g h = eqToIso (assoc f g h) := by\n    aesop_cat\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Bicategory.Strict.id_comp","module":"Mathlib.CategoryTheory.Bicategory.Strict","initialProofState":"B : Type u\ninstâœ : CategoryTheory.Bicategory B\nself : CategoryTheory.Bicategory.Strict B\na b : B\nf : Quiver.Hom a b\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id a) f) f","decl":"/-- A bicategory is called `Strict` if the left unitors, the right unitors, and the associators are\nisomorphisms given by equalities.\n-/\nclass Bicategory.Strict : Prop where\n  /-- Identity morphisms are left identities for composition. -/\n  id_comp : âˆ€ {a b : B} (f : a âŸ¶ b), ğŸ™ a â‰« f = f := by aesop_cat\n  /-- Identity morphisms are right identities for composition. -/\n  comp_id : âˆ€ {a b : B} (f : a âŸ¶ b), f â‰« ğŸ™ b = f := by aesop_cat\n  /-- Composition in a bicategory is associative. -/\n  assoc : âˆ€ {a b c d : B} (f : a âŸ¶ b) (g : b âŸ¶ c) (h : c âŸ¶ d), (f â‰« g) â‰« h = f â‰« g â‰« h := by\n    aesop_cat\n  /-- The left unitors are given by equalities -/\n  leftUnitor_eqToIso : âˆ€ {a b : B} (f : a âŸ¶ b), Î»_ f = eqToIso (id_comp f) := by aesop_cat\n  /-- The right unitors are given by equalities -/\n  rightUnitor_eqToIso : âˆ€ {a b : B} (f : a âŸ¶ b), Ï_ f = eqToIso (comp_id f) := by aesop_cat\n  /-- The associators are given by equalities -/\n  associator_eqToIso :\n    âˆ€ {a b c d : B} (f : a âŸ¶ b) (g : b âŸ¶ c) (h : c âŸ¶ d), Î±_ f g h = eqToIso (assoc f g h) := by\n    aesop_cat\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Bicategory.whiskerLeft_eqToHom","module":"Mathlib.CategoryTheory.Bicategory.Strict","initialProofState":"B : Type u\ninstâœ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom a b\ng h : Quiver.Hom b c\nÎ· : Eq g h\nâŠ¢ Eq (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.eqToHom Î·)) (CategoryTheory.eqToHom â‹¯)","decl":"@[simp]\ntheorem whiskerLeft_eqToHom {a b c : B} (f : a âŸ¶ b) {g h : b âŸ¶ c} (Î· : g = h) :\n    f â— eqToHom Î· = eqToHom (congr_argâ‚‚ (Â· â‰« Â·) rfl Î·) := by\n  cases Î·\n  simp only [whiskerLeft_id, eqToHom_refl]\n\n"}
{"name":"CategoryTheory.Bicategory.eqToHom_whiskerRight","module":"Mathlib.CategoryTheory.Bicategory.Strict","initialProofState":"B : Type u\ninstâœ : CategoryTheory.Bicategory B\na b c : B\nf g : Quiver.Hom a b\nÎ· : Eq f g\nh : Quiver.Hom b c\nâŠ¢ Eq (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.eqToHom Î·) h) (CategoryTheory.eqToHom â‹¯)","decl":"@[simp]\ntheorem eqToHom_whiskerRight {a b c : B} {f g : a âŸ¶ b} (Î· : f = g) (h : b âŸ¶ c) :\n    eqToHom Î· â–· h = eqToHom (congr_argâ‚‚ (Â· â‰« Â·) Î· rfl) := by\n  cases Î·\n  simp only [id_whiskerRight, eqToHom_refl]\n\n"}
