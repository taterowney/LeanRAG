{"name":"CategoryTheory.Bicategory.Strict.rightUnitor_eqToIso","module":"Mathlib.CategoryTheory.Bicategory.Strict","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\nself : CategoryTheory.Bicategory.Strict B\na b : B\nf : Quiver.Hom a b\n⊢ Eq (CategoryTheory.Bicategory.rightUnitor f) (CategoryTheory.eqToIso ⋯)","decl":"/-- A bicategory is called `Strict` if the left unitors, the right unitors, and the associators are\nisomorphisms given by equalities.\n-/\nclass Bicategory.Strict : Prop where\n  /-- Identity morphisms are left identities for composition. -/\n  id_comp : ∀ {a b : B} (f : a ⟶ b), 𝟙 a ≫ f = f := by aesop_cat\n  /-- Identity morphisms are right identities for composition. -/\n  comp_id : ∀ {a b : B} (f : a ⟶ b), f ≫ 𝟙 b = f := by aesop_cat\n  /-- Composition in a bicategory is associative. -/\n  assoc : ∀ {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d), (f ≫ g) ≫ h = f ≫ g ≫ h := by\n    aesop_cat\n  /-- The left unitors are given by equalities -/\n  leftUnitor_eqToIso : ∀ {a b : B} (f : a ⟶ b), λ_ f = eqToIso (id_comp f) := by aesop_cat\n  /-- The right unitors are given by equalities -/\n  rightUnitor_eqToIso : ∀ {a b : B} (f : a ⟶ b), ρ_ f = eqToIso (comp_id f) := by aesop_cat\n  /-- The associators are given by equalities -/\n  associator_eqToIso :\n    ∀ {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d), α_ f g h = eqToIso (assoc f g h) := by\n    aesop_cat\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Bicategory.Strict.assoc","module":"Mathlib.CategoryTheory.Bicategory.Strict","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\nself : CategoryTheory.Bicategory.Strict B\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g) h) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g h))","decl":"/-- A bicategory is called `Strict` if the left unitors, the right unitors, and the associators are\nisomorphisms given by equalities.\n-/\nclass Bicategory.Strict : Prop where\n  /-- Identity morphisms are left identities for composition. -/\n  id_comp : ∀ {a b : B} (f : a ⟶ b), 𝟙 a ≫ f = f := by aesop_cat\n  /-- Identity morphisms are right identities for composition. -/\n  comp_id : ∀ {a b : B} (f : a ⟶ b), f ≫ 𝟙 b = f := by aesop_cat\n  /-- Composition in a bicategory is associative. -/\n  assoc : ∀ {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d), (f ≫ g) ≫ h = f ≫ g ≫ h := by\n    aesop_cat\n  /-- The left unitors are given by equalities -/\n  leftUnitor_eqToIso : ∀ {a b : B} (f : a ⟶ b), λ_ f = eqToIso (id_comp f) := by aesop_cat\n  /-- The right unitors are given by equalities -/\n  rightUnitor_eqToIso : ∀ {a b : B} (f : a ⟶ b), ρ_ f = eqToIso (comp_id f) := by aesop_cat\n  /-- The associators are given by equalities -/\n  associator_eqToIso :\n    ∀ {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d), α_ f g h = eqToIso (assoc f g h) := by\n    aesop_cat\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Bicategory.Strict.associator_eqToIso","module":"Mathlib.CategoryTheory.Bicategory.Strict","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\nself : CategoryTheory.Bicategory.Strict B\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\n⊢ Eq (CategoryTheory.Bicategory.associator f g h) (CategoryTheory.eqToIso ⋯)","decl":"/-- A bicategory is called `Strict` if the left unitors, the right unitors, and the associators are\nisomorphisms given by equalities.\n-/\nclass Bicategory.Strict : Prop where\n  /-- Identity morphisms are left identities for composition. -/\n  id_comp : ∀ {a b : B} (f : a ⟶ b), 𝟙 a ≫ f = f := by aesop_cat\n  /-- Identity morphisms are right identities for composition. -/\n  comp_id : ∀ {a b : B} (f : a ⟶ b), f ≫ 𝟙 b = f := by aesop_cat\n  /-- Composition in a bicategory is associative. -/\n  assoc : ∀ {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d), (f ≫ g) ≫ h = f ≫ g ≫ h := by\n    aesop_cat\n  /-- The left unitors are given by equalities -/\n  leftUnitor_eqToIso : ∀ {a b : B} (f : a ⟶ b), λ_ f = eqToIso (id_comp f) := by aesop_cat\n  /-- The right unitors are given by equalities -/\n  rightUnitor_eqToIso : ∀ {a b : B} (f : a ⟶ b), ρ_ f = eqToIso (comp_id f) := by aesop_cat\n  /-- The associators are given by equalities -/\n  associator_eqToIso :\n    ∀ {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d), α_ f g h = eqToIso (assoc f g h) := by\n    aesop_cat\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Bicategory.Strict.comp_id","module":"Mathlib.CategoryTheory.Bicategory.Strict","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\nself : CategoryTheory.Bicategory.Strict B\na b : B\nf : Quiver.Hom a b\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.id b)) f","decl":"/-- A bicategory is called `Strict` if the left unitors, the right unitors, and the associators are\nisomorphisms given by equalities.\n-/\nclass Bicategory.Strict : Prop where\n  /-- Identity morphisms are left identities for composition. -/\n  id_comp : ∀ {a b : B} (f : a ⟶ b), 𝟙 a ≫ f = f := by aesop_cat\n  /-- Identity morphisms are right identities for composition. -/\n  comp_id : ∀ {a b : B} (f : a ⟶ b), f ≫ 𝟙 b = f := by aesop_cat\n  /-- Composition in a bicategory is associative. -/\n  assoc : ∀ {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d), (f ≫ g) ≫ h = f ≫ g ≫ h := by\n    aesop_cat\n  /-- The left unitors are given by equalities -/\n  leftUnitor_eqToIso : ∀ {a b : B} (f : a ⟶ b), λ_ f = eqToIso (id_comp f) := by aesop_cat\n  /-- The right unitors are given by equalities -/\n  rightUnitor_eqToIso : ∀ {a b : B} (f : a ⟶ b), ρ_ f = eqToIso (comp_id f) := by aesop_cat\n  /-- The associators are given by equalities -/\n  associator_eqToIso :\n    ∀ {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d), α_ f g h = eqToIso (assoc f g h) := by\n    aesop_cat\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Bicategory.Strict.leftUnitor_eqToIso","module":"Mathlib.CategoryTheory.Bicategory.Strict","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\nself : CategoryTheory.Bicategory.Strict B\na b : B\nf : Quiver.Hom a b\n⊢ Eq (CategoryTheory.Bicategory.leftUnitor f) (CategoryTheory.eqToIso ⋯)","decl":"/-- A bicategory is called `Strict` if the left unitors, the right unitors, and the associators are\nisomorphisms given by equalities.\n-/\nclass Bicategory.Strict : Prop where\n  /-- Identity morphisms are left identities for composition. -/\n  id_comp : ∀ {a b : B} (f : a ⟶ b), 𝟙 a ≫ f = f := by aesop_cat\n  /-- Identity morphisms are right identities for composition. -/\n  comp_id : ∀ {a b : B} (f : a ⟶ b), f ≫ 𝟙 b = f := by aesop_cat\n  /-- Composition in a bicategory is associative. -/\n  assoc : ∀ {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d), (f ≫ g) ≫ h = f ≫ g ≫ h := by\n    aesop_cat\n  /-- The left unitors are given by equalities -/\n  leftUnitor_eqToIso : ∀ {a b : B} (f : a ⟶ b), λ_ f = eqToIso (id_comp f) := by aesop_cat\n  /-- The right unitors are given by equalities -/\n  rightUnitor_eqToIso : ∀ {a b : B} (f : a ⟶ b), ρ_ f = eqToIso (comp_id f) := by aesop_cat\n  /-- The associators are given by equalities -/\n  associator_eqToIso :\n    ∀ {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d), α_ f g h = eqToIso (assoc f g h) := by\n    aesop_cat\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Bicategory.Strict.id_comp","module":"Mathlib.CategoryTheory.Bicategory.Strict","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\nself : CategoryTheory.Bicategory.Strict B\na b : B\nf : Quiver.Hom a b\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id a) f) f","decl":"/-- A bicategory is called `Strict` if the left unitors, the right unitors, and the associators are\nisomorphisms given by equalities.\n-/\nclass Bicategory.Strict : Prop where\n  /-- Identity morphisms are left identities for composition. -/\n  id_comp : ∀ {a b : B} (f : a ⟶ b), 𝟙 a ≫ f = f := by aesop_cat\n  /-- Identity morphisms are right identities for composition. -/\n  comp_id : ∀ {a b : B} (f : a ⟶ b), f ≫ 𝟙 b = f := by aesop_cat\n  /-- Composition in a bicategory is associative. -/\n  assoc : ∀ {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d), (f ≫ g) ≫ h = f ≫ g ≫ h := by\n    aesop_cat\n  /-- The left unitors are given by equalities -/\n  leftUnitor_eqToIso : ∀ {a b : B} (f : a ⟶ b), λ_ f = eqToIso (id_comp f) := by aesop_cat\n  /-- The right unitors are given by equalities -/\n  rightUnitor_eqToIso : ∀ {a b : B} (f : a ⟶ b), ρ_ f = eqToIso (comp_id f) := by aesop_cat\n  /-- The associators are given by equalities -/\n  associator_eqToIso :\n    ∀ {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d), α_ f g h = eqToIso (assoc f g h) := by\n    aesop_cat\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Bicategory.whiskerLeft_eqToHom","module":"Mathlib.CategoryTheory.Bicategory.Strict","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom a b\ng h : Quiver.Hom b c\nη : Eq g h\n⊢ Eq (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.eqToHom η)) (CategoryTheory.eqToHom ⋯)","decl":"@[simp]\ntheorem whiskerLeft_eqToHom {a b c : B} (f : a ⟶ b) {g h : b ⟶ c} (η : g = h) :\n    f ◁ eqToHom η = eqToHom (congr_arg₂ (· ≫ ·) rfl η) := by\n  cases η\n  simp only [whiskerLeft_id, eqToHom_refl]\n\n"}
{"name":"CategoryTheory.Bicategory.eqToHom_whiskerRight","module":"Mathlib.CategoryTheory.Bicategory.Strict","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b c : B\nf g : Quiver.Hom a b\nη : Eq f g\nh : Quiver.Hom b c\n⊢ Eq (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.eqToHom η) h) (CategoryTheory.eqToHom ⋯)","decl":"@[simp]\ntheorem eqToHom_whiskerRight {a b c : B} {f g : a ⟶ b} (η : f = g) (h : b ⟶ c) :\n    eqToHom η ▷ h = eqToHom (congr_arg₂ (· ≫ ·) η rfl) := by\n  cases η\n  simp only [id_whiskerRight, eqToHom_refl]\n\n"}
