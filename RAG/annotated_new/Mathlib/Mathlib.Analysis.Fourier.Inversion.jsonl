{"name":"Real.tendsto_integral_cexp_sq_smul","module":"Mathlib.Analysis.Fourier.Inversion","initialProofState":"V : Type u_1\nE : Type u_2\ninst✝⁶ : NormedAddCommGroup V\ninst✝⁵ : InnerProductSpace Real V\ninst✝⁴ : MeasurableSpace V\ninst✝³ : BorelSpace V\ninst✝² : FiniteDimensional Real V\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : V → E\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\n⊢ Filter.Tendsto (fun c => MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => HSMul.hSMul (Complex.exp (HMul.hMul (Neg.neg ↑(Inv.inv c)) (HPow.hPow (↑(Norm.norm v)) 2))) (f v)) Filter.atTop (nhds (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => f v))","decl":"lemma tendsto_integral_cexp_sq_smul (hf : Integrable f) :\n    Tendsto (fun (c : ℝ) ↦ (∫ v : V, cexp (- c⁻¹ * ‖v‖^2) • f v))\n      atTop (𝓝 (∫ v : V, f v)) := by\n  apply tendsto_integral_filter_of_dominated_convergence _ _ _ hf.norm\n  · filter_upwards with v\n    nth_rewrite 2 [show f v = cexp (- (0 : ℝ) * ‖v‖^2) • f v by simp]\n    apply (Tendsto.cexp _).smul_const\n    exact tendsto_inv_atTop_zero.ofReal.neg.mul_const _\n  · filter_upwards with c using\n      AEStronglyMeasurable.smul (Continuous.aestronglyMeasurable (by fun_prop)) hf.1\n  · filter_upwards [Ici_mem_atTop (0 : ℝ)] with c (hc : 0 ≤ c)\n    filter_upwards with v\n    simp only [ofReal_inv, neg_mul, norm_smul, Complex.norm_eq_abs]\n    norm_cast\n    conv_rhs => rw [← one_mul (‖f v‖)]\n    gcongr\n    simp only [abs_exp, exp_le_one_iff, Left.neg_nonpos_iff]\n    positivity\n\n"}
{"name":"Real.tendsto_integral_gaussian_smul","module":"Mathlib.Analysis.Fourier.Inversion","initialProofState":"V : Type u_1\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup V\ninst✝⁶ : InnerProductSpace Real V\ninst✝⁵ : MeasurableSpace V\ninst✝⁴ : BorelSpace V\ninst✝³ : FiniteDimensional Real V\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\nf : V → E\ninst✝ : CompleteSpace E\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nh'f : MeasureTheory.Integrable (Real.fourierIntegral f) MeasureTheory.MeasureSpace.volume\nv : V\n⊢ Filter.Tendsto (fun c => MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun w => HSMul.hSMul (HMul.hMul (HPow.hPow (HMul.hMul ↑Real.pi ↑c) (HDiv.hDiv (↑(Module.finrank Real V)) 2)) (Complex.exp (HMul.hMul (HMul.hMul (Neg.neg (HPow.hPow (↑Real.pi) 2)) ↑c) (HPow.hPow (↑(Norm.norm (HSub.hSub v w))) 2)))) (f w)) Filter.atTop (nhds (Real.fourierIntegralInv (Real.fourierIntegral f) v))","decl":"lemma tendsto_integral_gaussian_smul (hf : Integrable f) (h'f : Integrable (𝓕 f)) (v : V) :\n    Tendsto (fun (c : ℝ) ↦\n      ∫ w : V, ((π * c) ^ (finrank ℝ V / 2 : ℂ) * cexp (-π ^ 2 * c * ‖v - w‖ ^ 2)) • f w)\n    atTop (𝓝 (𝓕⁻ (𝓕 f) v)) := by\n  have A : Tendsto (fun (c : ℝ) ↦ (∫ w : V, cexp (- c⁻¹ * ‖w‖^2 + 2 * π * I * ⟪v, w⟫)\n       • (𝓕 f) w)) atTop (𝓝 (𝓕⁻ (𝓕 f) v)) := by\n    have : Integrable (fun w ↦ 𝐞 ⟪w, v⟫ • (𝓕 f) w) := by\n      have B : Continuous fun p : V × V => (- innerₗ V) p.1 p.2 := continuous_inner.neg\n      simpa using\n        (VectorFourier.fourierIntegral_convergent_iff Real.continuous_fourierChar B v).2 h'f\n    convert tendsto_integral_cexp_sq_smul this using 4 with c w\n    · rw [Submonoid.smul_def, Real.fourierChar_apply, smul_smul, ← Complex.exp_add, real_inner_comm]\n      congr 3\n      simp only [ofReal_mul, ofReal_ofNat]\n      ring\n    · simp [fourierIntegralInv_eq]\n  have B : Tendsto (fun (c : ℝ) ↦ (∫ w : V,\n        𝓕 (fun w ↦ cexp (- c⁻¹ * ‖w‖^2 + 2 * π * I * ⟪v, w⟫)) w • f w)) atTop\n      (𝓝 (𝓕⁻ (𝓕 f) v)) := by\n    apply A.congr'\n    filter_upwards [Ioi_mem_atTop 0] with c (hc : 0 < c)\n    have J : Integrable (fun w ↦ cexp (- c⁻¹ * ‖w‖^2 + 2 * π * I * ⟪v, w⟫)) :=\n      GaussianFourier.integrable_cexp_neg_mul_sq_norm_add (by simpa) _ _\n    simpa using (VectorFourier.integral_fourierIntegral_smul_eq_flip (L := innerₗ V)\n      Real.continuous_fourierChar continuous_inner J hf).symm\n  apply B.congr'\n  filter_upwards [Ioi_mem_atTop 0] with c (hc : 0 < c)\n  congr with w\n  rw [fourierIntegral_gaussian_innerProductSpace' (by simpa)]\n  congr\n  · simp\n  · simp; ring\n\n"}
{"name":"Real.tendsto_integral_gaussian_smul'","module":"Mathlib.Analysis.Fourier.Inversion","initialProofState":"V : Type u_1\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup V\ninst✝⁶ : InnerProductSpace Real V\ninst✝⁵ : MeasurableSpace V\ninst✝⁴ : BorelSpace V\ninst✝³ : FiniteDimensional Real V\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\nf : V → E\ninst✝ : CompleteSpace E\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nv : V\nh'f : ContinuousAt f v\n⊢ Filter.Tendsto (fun c => MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun w => HSMul.hSMul (HMul.hMul (HPow.hPow (HMul.hMul ↑Real.pi ↑c) (HDiv.hDiv (↑(Module.finrank Real V)) 2)) (Complex.exp (HMul.hMul (HMul.hMul (Neg.neg (HPow.hPow (↑Real.pi) 2)) ↑c) (HPow.hPow (↑(Norm.norm (HSub.hSub v w))) 2)))) (f w)) Filter.atTop (nhds (f v))","decl":"lemma tendsto_integral_gaussian_smul' (hf : Integrable f) {v : V} (h'f : ContinuousAt f v) :\n    Tendsto (fun (c : ℝ) ↦\n      ∫ w : V, ((π * c : ℂ) ^ (finrank ℝ V / 2 : ℂ) * cexp (-π ^ 2 * c * ‖v - w‖ ^ 2)) • f w)\n    atTop (𝓝 (f v)) := by\n  let φ : V → ℝ := fun w ↦ π ^ (finrank ℝ V / 2 : ℝ) * Real.exp (-π^2 * ‖w‖^2)\n  have A : Tendsto (fun (c : ℝ) ↦ ∫ w : V, (c ^ finrank ℝ V * φ (c • (v - w))) • f w)\n      atTop (𝓝 (f v)) := by\n    apply tendsto_integral_comp_smul_smul_of_integrable'\n    · exact fun x ↦ by positivity\n    · rw [integral_mul_left, GaussianFourier.integral_rexp_neg_mul_sq_norm (by positivity)]\n      nth_rewrite 2 [← pow_one π]\n      rw [← rpow_natCast, ← rpow_natCast, ← rpow_sub pi_pos, ← rpow_mul pi_nonneg,\n        ← rpow_add pi_pos]\n      ring_nf\n      exact rpow_zero _\n    · have A : Tendsto (fun (w : V) ↦ π^2 * ‖w‖^2) (cobounded V) atTop := by\n        rw [tendsto_const_mul_atTop_of_pos (by positivity)]\n        apply (tendsto_pow_atTop two_ne_zero).comp tendsto_norm_cobounded_atTop\n      have B := tendsto_rpow_mul_exp_neg_mul_atTop_nhds_zero (finrank ℝ V / 2) 1\n        zero_lt_one |>.comp A |>.const_mul (π ^ (-finrank ℝ V / 2 : ℝ))\n      rw [mul_zero] at B\n      convert B using 2 with x\n      simp only [neg_mul, one_mul, Function.comp_apply, ← mul_assoc, ← rpow_natCast, φ]\n      congr 1\n      rw [mul_rpow (by positivity) (by positivity), ← rpow_mul pi_nonneg,\n        ← rpow_mul (norm_nonneg _), ← mul_assoc, ← rpow_add pi_pos, mul_comm]\n      congr <;> ring\n    · exact hf\n    · exact h'f\n  have B : Tendsto\n      (fun (c : ℝ) ↦ ∫ w : V, ((c^(1/2 : ℝ)) ^ finrank ℝ V * φ ((c^(1/2 : ℝ)) • (v - w))) • f w)\n      atTop (𝓝 (f v)) :=\n    A.comp (tendsto_rpow_atTop (by norm_num))\n  apply B.congr'\n  filter_upwards [Ioi_mem_atTop 0] with c (hc : 0 < c)\n  congr with w\n  rw [← coe_smul]\n  congr\n  rw [ofReal_mul, ofReal_mul, ofReal_exp, ← mul_assoc]\n  congr\n  · rw [mul_cpow_ofReal_nonneg pi_nonneg hc.le, ← rpow_natCast, ← rpow_mul hc.le, mul_comm,\n      ofReal_cpow pi_nonneg, ofReal_cpow hc.le]\n    simp [div_eq_inv_mul]\n  · norm_cast\n    simp only [one_div, norm_smul, Real.norm_eq_abs, mul_pow, _root_.sq_abs, neg_mul, neg_inj,\n      ← rpow_natCast, ← rpow_mul hc.le, mul_assoc]\n    norm_num\n\n"}
{"name":"MeasureTheory.Integrable.fourier_inversion","module":"Mathlib.Analysis.Fourier.Inversion","initialProofState":"V : Type u_1\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup V\ninst✝⁶ : InnerProductSpace Real V\ninst✝⁵ : MeasurableSpace V\ninst✝⁴ : BorelSpace V\ninst✝³ : FiniteDimensional Real V\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\nf : V → E\ninst✝ : CompleteSpace E\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nh'f : MeasureTheory.Integrable (Real.fourierIntegral f) MeasureTheory.MeasureSpace.volume\nv : V\nhv : ContinuousAt f v\n⊢ Eq (Real.fourierIntegralInv (Real.fourierIntegral f) v) (f v)","decl":"/-- **Fourier inversion formula**: If a function `f` on a finite-dimensional real inner product\nspace is integrable, and its Fourier transform `𝓕 f` is also integrable, then `𝓕⁻ (𝓕 f) = f` at\ncontinuity points of `f`. -/\ntheorem MeasureTheory.Integrable.fourier_inversion\n    (hf : Integrable f) (h'f : Integrable (𝓕 f)) {v : V}\n    (hv : ContinuousAt f v) : 𝓕⁻ (𝓕 f) v = f v :=\n  tendsto_nhds_unique (Real.tendsto_integral_gaussian_smul hf h'f v)\n    (Real.tendsto_integral_gaussian_smul' hf hv)\n\n"}
{"name":"Continuous.fourier_inversion","module":"Mathlib.Analysis.Fourier.Inversion","initialProofState":"V : Type u_1\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup V\ninst✝⁶ : InnerProductSpace Real V\ninst✝⁵ : MeasurableSpace V\ninst✝⁴ : BorelSpace V\ninst✝³ : FiniteDimensional Real V\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\nf : V → E\ninst✝ : CompleteSpace E\nh : Continuous f\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nh'f : MeasureTheory.Integrable (Real.fourierIntegral f) MeasureTheory.MeasureSpace.volume\n⊢ Eq (Real.fourierIntegralInv (Real.fourierIntegral f)) f","decl":"/-- **Fourier inversion formula**: If a function `f` on a finite-dimensional real inner product\nspace is continuous, integrable, and its Fourier transform `𝓕 f` is also integrable,\nthen `𝓕⁻ (𝓕 f) = f`. -/\ntheorem Continuous.fourier_inversion (h : Continuous f)\n    (hf : Integrable f) (h'f : Integrable (𝓕 f)) :\n    𝓕⁻ (𝓕 f) = f := by\n  ext v\n  exact hf.fourier_inversion h'f h.continuousAt\n\n"}
{"name":"MeasureTheory.Integrable.fourier_inversion_inv","module":"Mathlib.Analysis.Fourier.Inversion","initialProofState":"V : Type u_1\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup V\ninst✝⁶ : InnerProductSpace Real V\ninst✝⁵ : MeasurableSpace V\ninst✝⁴ : BorelSpace V\ninst✝³ : FiniteDimensional Real V\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\nf : V → E\ninst✝ : CompleteSpace E\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nh'f : MeasureTheory.Integrable (Real.fourierIntegral f) MeasureTheory.MeasureSpace.volume\nv : V\nhv : ContinuousAt f v\n⊢ Eq (Real.fourierIntegral (Real.fourierIntegralInv f) v) (f v)","decl":"/-- **Fourier inversion formula**: If a function `f` on a finite-dimensional real inner product\nspace is integrable, and its Fourier transform `𝓕 f` is also integrable, then `𝓕 (𝓕⁻ f) = f` at\ncontinuity points of `f`. -/\ntheorem MeasureTheory.Integrable.fourier_inversion_inv\n    (hf : Integrable f) (h'f : Integrable (𝓕 f)) {v : V}\n    (hv : ContinuousAt f v) : 𝓕 (𝓕⁻ f) v = f v := by\n  rw [fourierIntegralInv_comm]\n  exact fourier_inversion hf h'f hv\n\n"}
{"name":"Continuous.fourier_inversion_inv","module":"Mathlib.Analysis.Fourier.Inversion","initialProofState":"V : Type u_1\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup V\ninst✝⁶ : InnerProductSpace Real V\ninst✝⁵ : MeasurableSpace V\ninst✝⁴ : BorelSpace V\ninst✝³ : FiniteDimensional Real V\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\nf : V → E\ninst✝ : CompleteSpace E\nh : Continuous f\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nh'f : MeasureTheory.Integrable (Real.fourierIntegral f) MeasureTheory.MeasureSpace.volume\n⊢ Eq (Real.fourierIntegral (Real.fourierIntegralInv f)) f","decl":"/-- **Fourier inversion formula**: If a function `f` on a finite-dimensional real inner product\nspace is continuous, integrable, and its Fourier transform `𝓕 f` is also integrable,\nthen `𝓕 (𝓕⁻ f) = f`. -/\ntheorem Continuous.fourier_inversion_inv (h : Continuous f)\n    (hf : Integrable f) (h'f : Integrable (𝓕 f)) :\n    𝓕 (𝓕⁻ f) = f := by\n  ext v\n  exact hf.fourier_inversion_inv h'f h.continuousAt\n"}
