{"name":"Real.tendsto_integral_cexp_sq_smul","module":"Mathlib.Analysis.Fourier.Inversion","initialProofState":"V : Type u_1\nE : Type u_2\ninstâœâ¶ : NormedAddCommGroup V\ninstâœâµ : InnerProductSpace Real V\ninstâœâ´ : MeasurableSpace V\ninstâœÂ³ : BorelSpace V\ninstâœÂ² : FiniteDimensional Real V\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : V â†’ E\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nâŠ¢ Filter.Tendsto (fun c => MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => HSMul.hSMul (Complex.exp (HMul.hMul (Neg.neg â†‘(Inv.inv c)) (HPow.hPow (â†‘(Norm.norm v)) 2))) (f v)) Filter.atTop (nhds (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => f v))","decl":"lemma tendsto_integral_cexp_sq_smul (hf : Integrable f) :\n    Tendsto (fun (c : â„) â†¦ (âˆ« v : V, cexp (- câ»Â¹ * â€–vâ€–^2) â€¢ f v))\n      atTop (ğ“ (âˆ« v : V, f v)) := by\n  apply tendsto_integral_filter_of_dominated_convergence _ _ _ hf.norm\n  Â· filter_upwards with v\n    nth_rewrite 2 [show f v = cexp (- (0 : â„) * â€–vâ€–^2) â€¢ f v by simp]\n    apply (Tendsto.cexp _).smul_const\n    exact tendsto_inv_atTop_zero.ofReal.neg.mul_const _\n  Â· filter_upwards with c using\n      AEStronglyMeasurable.smul (Continuous.aestronglyMeasurable (by fun_prop)) hf.1\n  Â· filter_upwards [Ici_mem_atTop (0 : â„)] with c (hc : 0 â‰¤ c)\n    filter_upwards with v\n    simp only [ofReal_inv, neg_mul, norm_smul, Complex.norm_eq_abs]\n    norm_cast\n    conv_rhs => rw [â† one_mul (â€–f vâ€–)]\n    gcongr\n    simp only [abs_exp, exp_le_one_iff, Left.neg_nonpos_iff]\n    positivity\n\n"}
{"name":"Real.tendsto_integral_gaussian_smul","module":"Mathlib.Analysis.Fourier.Inversion","initialProofState":"V : Type u_1\nE : Type u_2\ninstâœâ· : NormedAddCommGroup V\ninstâœâ¶ : InnerProductSpace Real V\ninstâœâµ : MeasurableSpace V\ninstâœâ´ : BorelSpace V\ninstâœÂ³ : FiniteDimensional Real V\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Complex E\nf : V â†’ E\ninstâœ : CompleteSpace E\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nh'f : MeasureTheory.Integrable (Real.fourierIntegral f) MeasureTheory.MeasureSpace.volume\nv : V\nâŠ¢ Filter.Tendsto (fun c => MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun w => HSMul.hSMul (HMul.hMul (HPow.hPow (HMul.hMul â†‘Real.pi â†‘c) (HDiv.hDiv (â†‘(Module.finrank Real V)) 2)) (Complex.exp (HMul.hMul (HMul.hMul (Neg.neg (HPow.hPow (â†‘Real.pi) 2)) â†‘c) (HPow.hPow (â†‘(Norm.norm (HSub.hSub v w))) 2)))) (f w)) Filter.atTop (nhds (Real.fourierIntegralInv (Real.fourierIntegral f) v))","decl":"lemma tendsto_integral_gaussian_smul (hf : Integrable f) (h'f : Integrable (ğ“• f)) (v : V) :\n    Tendsto (fun (c : â„) â†¦\n      âˆ« w : V, ((Ï€ * c) ^ (finrank â„ V / 2 : â„‚) * cexp (-Ï€ ^ 2 * c * â€–v - wâ€– ^ 2)) â€¢ f w)\n    atTop (ğ“ (ğ“•â» (ğ“• f) v)) := by\n  have A : Tendsto (fun (c : â„) â†¦ (âˆ« w : V, cexp (- câ»Â¹ * â€–wâ€–^2 + 2 * Ï€ * I * âŸªv, wâŸ«)\n       â€¢ (ğ“• f) w)) atTop (ğ“ (ğ“•â» (ğ“• f) v)) := by\n    have : Integrable (fun w â†¦ ğ âŸªw, vâŸ« â€¢ (ğ“• f) w) := by\n      have B : Continuous fun p : V Ã— V => (- innerâ‚— V) p.1 p.2 := continuous_inner.neg\n      simpa using\n        (VectorFourier.fourierIntegral_convergent_iff Real.continuous_fourierChar B v).2 h'f\n    convert tendsto_integral_cexp_sq_smul this using 4 with c w\n    Â· rw [Submonoid.smul_def, Real.fourierChar_apply, smul_smul, â† Complex.exp_add, real_inner_comm]\n      congr 3\n      simp only [ofReal_mul, ofReal_ofNat]\n      ring\n    Â· simp [fourierIntegralInv_eq]\n  have B : Tendsto (fun (c : â„) â†¦ (âˆ« w : V,\n        ğ“• (fun w â†¦ cexp (- câ»Â¹ * â€–wâ€–^2 + 2 * Ï€ * I * âŸªv, wâŸ«)) w â€¢ f w)) atTop\n      (ğ“ (ğ“•â» (ğ“• f) v)) := by\n    apply A.congr'\n    filter_upwards [Ioi_mem_atTop 0] with c (hc : 0 < c)\n    have J : Integrable (fun w â†¦ cexp (- câ»Â¹ * â€–wâ€–^2 + 2 * Ï€ * I * âŸªv, wâŸ«)) :=\n      GaussianFourier.integrable_cexp_neg_mul_sq_norm_add (by simpa) _ _\n    simpa using (VectorFourier.integral_fourierIntegral_smul_eq_flip (L := innerâ‚— V)\n      Real.continuous_fourierChar continuous_inner J hf).symm\n  apply B.congr'\n  filter_upwards [Ioi_mem_atTop 0] with c (hc : 0 < c)\n  congr with w\n  rw [fourierIntegral_gaussian_innerProductSpace' (by simpa)]\n  congr\n  Â· simp\n  Â· simp; ring\n\n"}
{"name":"Real.tendsto_integral_gaussian_smul'","module":"Mathlib.Analysis.Fourier.Inversion","initialProofState":"V : Type u_1\nE : Type u_2\ninstâœâ· : NormedAddCommGroup V\ninstâœâ¶ : InnerProductSpace Real V\ninstâœâµ : MeasurableSpace V\ninstâœâ´ : BorelSpace V\ninstâœÂ³ : FiniteDimensional Real V\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Complex E\nf : V â†’ E\ninstâœ : CompleteSpace E\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nv : V\nh'f : ContinuousAt f v\nâŠ¢ Filter.Tendsto (fun c => MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun w => HSMul.hSMul (HMul.hMul (HPow.hPow (HMul.hMul â†‘Real.pi â†‘c) (HDiv.hDiv (â†‘(Module.finrank Real V)) 2)) (Complex.exp (HMul.hMul (HMul.hMul (Neg.neg (HPow.hPow (â†‘Real.pi) 2)) â†‘c) (HPow.hPow (â†‘(Norm.norm (HSub.hSub v w))) 2)))) (f w)) Filter.atTop (nhds (f v))","decl":"lemma tendsto_integral_gaussian_smul' (hf : Integrable f) {v : V} (h'f : ContinuousAt f v) :\n    Tendsto (fun (c : â„) â†¦\n      âˆ« w : V, ((Ï€ * c : â„‚) ^ (finrank â„ V / 2 : â„‚) * cexp (-Ï€ ^ 2 * c * â€–v - wâ€– ^ 2)) â€¢ f w)\n    atTop (ğ“ (f v)) := by\n  let Ï† : V â†’ â„ := fun w â†¦ Ï€ ^ (finrank â„ V / 2 : â„) * Real.exp (-Ï€^2 * â€–wâ€–^2)\n  have A : Tendsto (fun (c : â„) â†¦ âˆ« w : V, (c ^ finrank â„ V * Ï† (c â€¢ (v - w))) â€¢ f w)\n      atTop (ğ“ (f v)) := by\n    apply tendsto_integral_comp_smul_smul_of_integrable'\n    Â· exact fun x â†¦ by positivity\n    Â· rw [integral_mul_left, GaussianFourier.integral_rexp_neg_mul_sq_norm (by positivity)]\n      nth_rewrite 2 [â† pow_one Ï€]\n      rw [â† rpow_natCast, â† rpow_natCast, â† rpow_sub pi_pos, â† rpow_mul pi_nonneg,\n        â† rpow_add pi_pos]\n      ring_nf\n      exact rpow_zero _\n    Â· have A : Tendsto (fun (w : V) â†¦ Ï€^2 * â€–wâ€–^2) (cobounded V) atTop := by\n        rw [tendsto_const_mul_atTop_of_pos (by positivity)]\n        apply (tendsto_pow_atTop two_ne_zero).comp tendsto_norm_cobounded_atTop\n      have B := tendsto_rpow_mul_exp_neg_mul_atTop_nhds_zero (finrank â„ V / 2) 1\n        zero_lt_one |>.comp A |>.const_mul (Ï€ ^ (-finrank â„ V / 2 : â„))\n      rw [mul_zero] at B\n      convert B using 2 with x\n      simp only [neg_mul, one_mul, Function.comp_apply, â† mul_assoc, â† rpow_natCast, Ï†]\n      congr 1\n      rw [mul_rpow (by positivity) (by positivity), â† rpow_mul pi_nonneg,\n        â† rpow_mul (norm_nonneg _), â† mul_assoc, â† rpow_add pi_pos, mul_comm]\n      congr <;> ring\n    Â· exact hf\n    Â· exact h'f\n  have B : Tendsto\n      (fun (c : â„) â†¦ âˆ« w : V, ((c^(1/2 : â„)) ^ finrank â„ V * Ï† ((c^(1/2 : â„)) â€¢ (v - w))) â€¢ f w)\n      atTop (ğ“ (f v)) :=\n    A.comp (tendsto_rpow_atTop (by norm_num))\n  apply B.congr'\n  filter_upwards [Ioi_mem_atTop 0] with c (hc : 0 < c)\n  congr with w\n  rw [â† coe_smul]\n  congr\n  rw [ofReal_mul, ofReal_mul, ofReal_exp, â† mul_assoc]\n  congr\n  Â· rw [mul_cpow_ofReal_nonneg pi_nonneg hc.le, â† rpow_natCast, â† rpow_mul hc.le, mul_comm,\n      ofReal_cpow pi_nonneg, ofReal_cpow hc.le]\n    simp [div_eq_inv_mul]\n  Â· norm_cast\n    simp only [one_div, norm_smul, Real.norm_eq_abs, mul_pow, _root_.sq_abs, neg_mul, neg_inj,\n      â† rpow_natCast, â† rpow_mul hc.le, mul_assoc]\n    norm_num\n\n"}
{"name":"MeasureTheory.Integrable.fourier_inversion","module":"Mathlib.Analysis.Fourier.Inversion","initialProofState":"V : Type u_1\nE : Type u_2\ninstâœâ· : NormedAddCommGroup V\ninstâœâ¶ : InnerProductSpace Real V\ninstâœâµ : MeasurableSpace V\ninstâœâ´ : BorelSpace V\ninstâœÂ³ : FiniteDimensional Real V\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Complex E\nf : V â†’ E\ninstâœ : CompleteSpace E\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nh'f : MeasureTheory.Integrable (Real.fourierIntegral f) MeasureTheory.MeasureSpace.volume\nv : V\nhv : ContinuousAt f v\nâŠ¢ Eq (Real.fourierIntegralInv (Real.fourierIntegral f) v) (f v)","decl":"/-- **Fourier inversion formula**: If a function `f` on a finite-dimensional real inner product\nspace is integrable, and its Fourier transform `ğ“• f` is also integrable, then `ğ“•â» (ğ“• f) = f` at\ncontinuity points of `f`. -/\ntheorem MeasureTheory.Integrable.fourier_inversion\n    (hf : Integrable f) (h'f : Integrable (ğ“• f)) {v : V}\n    (hv : ContinuousAt f v) : ğ“•â» (ğ“• f) v = f v :=\n  tendsto_nhds_unique (Real.tendsto_integral_gaussian_smul hf h'f v)\n    (Real.tendsto_integral_gaussian_smul' hf hv)\n\n"}
{"name":"Continuous.fourier_inversion","module":"Mathlib.Analysis.Fourier.Inversion","initialProofState":"V : Type u_1\nE : Type u_2\ninstâœâ· : NormedAddCommGroup V\ninstâœâ¶ : InnerProductSpace Real V\ninstâœâµ : MeasurableSpace V\ninstâœâ´ : BorelSpace V\ninstâœÂ³ : FiniteDimensional Real V\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Complex E\nf : V â†’ E\ninstâœ : CompleteSpace E\nh : Continuous f\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nh'f : MeasureTheory.Integrable (Real.fourierIntegral f) MeasureTheory.MeasureSpace.volume\nâŠ¢ Eq (Real.fourierIntegralInv (Real.fourierIntegral f)) f","decl":"/-- **Fourier inversion formula**: If a function `f` on a finite-dimensional real inner product\nspace is continuous, integrable, and its Fourier transform `ğ“• f` is also integrable,\nthen `ğ“•â» (ğ“• f) = f`. -/\ntheorem Continuous.fourier_inversion (h : Continuous f)\n    (hf : Integrable f) (h'f : Integrable (ğ“• f)) :\n    ğ“•â» (ğ“• f) = f := by\n  ext v\n  exact hf.fourier_inversion h'f h.continuousAt\n\n"}
{"name":"MeasureTheory.Integrable.fourier_inversion_inv","module":"Mathlib.Analysis.Fourier.Inversion","initialProofState":"V : Type u_1\nE : Type u_2\ninstâœâ· : NormedAddCommGroup V\ninstâœâ¶ : InnerProductSpace Real V\ninstâœâµ : MeasurableSpace V\ninstâœâ´ : BorelSpace V\ninstâœÂ³ : FiniteDimensional Real V\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Complex E\nf : V â†’ E\ninstâœ : CompleteSpace E\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nh'f : MeasureTheory.Integrable (Real.fourierIntegral f) MeasureTheory.MeasureSpace.volume\nv : V\nhv : ContinuousAt f v\nâŠ¢ Eq (Real.fourierIntegral (Real.fourierIntegralInv f) v) (f v)","decl":"/-- **Fourier inversion formula**: If a function `f` on a finite-dimensional real inner product\nspace is integrable, and its Fourier transform `ğ“• f` is also integrable, then `ğ“• (ğ“•â» f) = f` at\ncontinuity points of `f`. -/\ntheorem MeasureTheory.Integrable.fourier_inversion_inv\n    (hf : Integrable f) (h'f : Integrable (ğ“• f)) {v : V}\n    (hv : ContinuousAt f v) : ğ“• (ğ“•â» f) v = f v := by\n  rw [fourierIntegralInv_comm]\n  exact fourier_inversion hf h'f hv\n\n"}
{"name":"Continuous.fourier_inversion_inv","module":"Mathlib.Analysis.Fourier.Inversion","initialProofState":"V : Type u_1\nE : Type u_2\ninstâœâ· : NormedAddCommGroup V\ninstâœâ¶ : InnerProductSpace Real V\ninstâœâµ : MeasurableSpace V\ninstâœâ´ : BorelSpace V\ninstâœÂ³ : FiniteDimensional Real V\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Complex E\nf : V â†’ E\ninstâœ : CompleteSpace E\nh : Continuous f\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nh'f : MeasureTheory.Integrable (Real.fourierIntegral f) MeasureTheory.MeasureSpace.volume\nâŠ¢ Eq (Real.fourierIntegral (Real.fourierIntegralInv f)) f","decl":"/-- **Fourier inversion formula**: If a function `f` on a finite-dimensional real inner product\nspace is continuous, integrable, and its Fourier transform `ğ“• f` is also integrable,\nthen `ğ“• (ğ“•â» f) = f`. -/\ntheorem Continuous.fourier_inversion_inv (h : Continuous f)\n    (hf : Integrable f) (h'f : Integrable (ğ“• f)) :\n    ğ“• (ğ“•â» f) = f := by\n  ext v\n  exact hf.fourier_inversion_inv h'f h.continuousAt\n"}
