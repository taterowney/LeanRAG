{"name":"hallMatchingsOn.nonempty","module":"Mathlib.Combinatorics.Hall.Basic","initialProofState":"ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), LE.le s.card (s.biUnion t).card\nι' : Finset ι\n⊢ Nonempty ↑(hallMatchingsOn t ι')","decl":"/-- When the Hall condition is satisfied, the set of matchings on a finite set is nonempty.\nThis is where `Finset.all_card_le_biUnion_card_iff_existsInjective'` comes into the argument. -/\ntheorem hallMatchingsOn.nonempty {ι : Type u} {α : Type v} [DecidableEq α] (t : ι → Finset α)\n    (h : ∀ s : Finset ι, #s ≤ #(s.biUnion t)) (ι' : Finset ι) :\n    Nonempty (hallMatchingsOn t ι') := by\n  classical\n    refine ⟨Classical.indefiniteDescription _ ?_⟩\n    apply (all_card_le_biUnion_card_iff_existsInjective' fun i : ι' => t i).mp\n    intro s'\n    convert h (s'.image (↑)) using 1\n    · simp only [card_image_of_injective s' Subtype.coe_injective]\n    · rw [image_biUnion]\n\n"}
{"name":"hallMatchingsOn.finite","module":"Mathlib.Combinatorics.Hall.Basic","initialProofState":"ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\n⊢ Finite ↑(hallMatchingsOn t ι')","decl":"instance hallMatchingsOn.finite {ι : Type u} {α : Type v} (t : ι → Finset α) (ι' : Finset ι) :\n    Finite (hallMatchingsOn t ι') := by\n  classical\n    rw [hallMatchingsOn]\n    let g : hallMatchingsOn t ι' → ι' → ι'.biUnion t := by\n      rintro f i\n      refine ⟨f.val i, ?_⟩\n      rw [mem_biUnion]\n      exact ⟨i, i.property, f.property.2 i⟩\n    apply Finite.of_injective g\n    intro f f' h\n    ext a\n    rw [funext_iff] at h\n    simpa [g] using h a\n\n"}
{"name":"Finset.all_card_le_biUnion_card_iff_exists_injective","module":"Mathlib.Combinatorics.Hall.Basic","initialProofState":"ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ Iff (∀ (s : Finset ι), LE.le s.card (s.biUnion t).card) (Exists fun f => And (Function.Injective f) (∀ (x : ι), Membership.mem (t x) (f x)))","decl":"/-- This is the version of **Hall's Marriage Theorem** in terms of indexed\nfamilies of finite sets `t : ι → Finset α`.  It states that there is a\nset of distinct representatives if and only if every union of `k` of the\nsets has at least `k` elements.\n\nRecall that `s.biUnion t` is the union of all the sets `t i` for `i ∈ s`.\n\nThis theorem is bootstrapped from `Finset.all_card_le_biUnion_card_iff_exists_injective'`,\nwhich has the additional constraint that `ι` is a `Fintype`.\n-/\ntheorem Finset.all_card_le_biUnion_card_iff_exists_injective {ι : Type u} {α : Type v}\n    [DecidableEq α] (t : ι → Finset α) :\n    (∀ s : Finset ι, #s ≤ #(s.biUnion t)) ↔\n      ∃ f : ι → α, Function.Injective f ∧ ∀ x, f x ∈ t x := by\n  constructor\n  · intro h\n    -- Set up the functor\n    haveI : ∀ ι' : (Finset ι)ᵒᵖ, Nonempty ((hallMatchingsFunctor t).obj ι') := fun ι' =>\n      hallMatchingsOn.nonempty t h ι'.unop\n    classical\n      haveI : ∀ ι' : (Finset ι)ᵒᵖ, Finite ((hallMatchingsFunctor t).obj ι') := by\n        intro ι'\n        rw [hallMatchingsFunctor]\n        infer_instance\n      -- Apply the compactness argument\n      obtain ⟨u, hu⟩ := nonempty_sections_of_finite_inverse_system (hallMatchingsFunctor t)\n      -- Interpret the resulting section of the inverse limit\n      refine ⟨?_, ?_, ?_⟩\n      ·-- Build the matching function from the section\n        exact fun i =>\n          (u (Opposite.op ({i} : Finset ι))).val ⟨i, by simp only [Opposite.unop_op, mem_singleton]⟩\n      · -- Show that it is injective\n        intro i i'\n        have subi : ({i} : Finset ι) ⊆ {i, i'} := by simp\n        have subi' : ({i'} : Finset ι) ⊆ {i, i'} := by simp\n        rw [← Finset.le_iff_subset] at subi subi'\n        simp only\n        rw [← hu (CategoryTheory.homOfLE subi).op, ← hu (CategoryTheory.homOfLE subi').op]\n        let uii' := u (Opposite.op ({i, i'} : Finset ι))\n        exact fun h => Subtype.mk_eq_mk.mp (uii'.property.1 h)\n      · -- Show that it maps each index to the corresponding finite set\n        intro i\n        apply (u (Opposite.op ({i} : Finset ι))).property.2\n  · -- The reverse direction is a straightforward cardinality argument\n    rintro ⟨f, hf₁, hf₂⟩ s\n    rw [← Finset.card_image_of_injective s hf₁]\n    apply Finset.card_le_card\n    intro\n    rw [Finset.mem_image, Finset.mem_biUnion]\n    rintro ⟨x, hx, rfl⟩\n    exact ⟨x, hx, hf₂ x⟩\n\n"}
{"name":"Fintype.all_card_le_rel_image_card_iff_exists_injective","module":"Mathlib.Combinatorics.Hall.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r (Singleton.singleton a))\n⊢ Iff (∀ (A : Finset α), LE.le A.card (Fintype.card ↑(Rel.image r ↑A))) (Exists fun f => And (Function.Injective f) (∀ (x : α), r x (f x)))","decl":"/-- This is a version of **Hall's Marriage Theorem** in terms of a relation\nbetween types `α` and `β` such that `α` is finite and the image of\neach `x : α` is finite (it suffices for `β` to be finite; see\n`Fintype.all_card_le_filter_rel_iff_exists_injective`).  There is\na transversal of the relation (an injective function `α → β` whose graph is\na subrelation of the relation) iff every subset of\n`k` terms of `α` is related to at least `k` terms of `β`.\n\nNote: if `[Fintype β]`, then there exist instances for `[∀ (a : α), Fintype (Rel.image r {a})]`.\n-/\ntheorem Fintype.all_card_le_rel_image_card_iff_exists_injective {α : Type u} {β : Type v}\n    [DecidableEq β] (r : α → β → Prop) [∀ a : α, Fintype (Rel.image r {a})] :\n    (∀ A : Finset α, #A ≤ Fintype.card (Rel.image r A)) ↔\n      ∃ f : α → β, Function.Injective f ∧ ∀ x, r x (f x) := by\n  let r' a := (Rel.image r {a}).toFinset\n  have h : ∀ A : Finset α, Fintype.card (Rel.image r A) = #(A.biUnion r') := by\n    intro A\n    rw [← Set.toFinset_card]\n    apply congr_arg\n    ext b\n    simp [r', Rel.image]\n  have h' : ∀ (f : α → β) (x), r x (f x) ↔ f x ∈ r' x := by simp [r', Rel.image]\n  simp only [h, h']\n  apply Finset.all_card_le_biUnion_card_iff_exists_injective\n\n-- TODO: decidable_pred makes Yael sad. When an appropriate decidable_rel-like exists, fix it.\n"}
{"name":"Fintype.all_card_le_filter_rel_iff_exists_injective","module":"Mathlib.Combinatorics.Hall.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\n⊢ Iff (∀ (A : Finset α), LE.le A.card (Finset.filter (fun b => Exists fun a => And (Membership.mem A a) (r a b)) Finset.univ).card) (Exists fun f => And (Function.Injective f) (∀ (x : α), r x (f x)))","decl":"/-- This is a version of **Hall's Marriage Theorem** in terms of a relation to a finite type.\nThere is a transversal of the relation (an injective function `α → β` whose graph is a subrelation\nof the relation) iff every subset of `k` terms of `α` is related to at least `k` terms of `β`.\n\nIt is like `Fintype.all_card_le_rel_image_card_iff_exists_injective` but uses `Finset.filter`\nrather than `Rel.image`.\n-/\ntheorem Fintype.all_card_le_filter_rel_iff_exists_injective {α : Type u} {β : Type v} [Fintype β]\n    (r : α → β → Prop) [∀ a, DecidablePred (r a)] :\n    (∀ A : Finset α, #A ≤ #{b | ∃ a ∈ A, r a b}) ↔ ∃ f : α → β, Injective f ∧ ∀ x, r x (f x) := by\n  haveI := Classical.decEq β\n  let r' a : Finset β := {b | r a b}\n  have h : ∀ A : Finset α, ({b | ∃ a ∈ A, r a b} : Finset _) = A.biUnion r' := by\n    intro A\n    ext b\n    simp [r']\n  have h' : ∀ (f : α → β) (x), r x (f x) ↔ f x ∈ r' x := by simp [r']\n  simp_rw [h, h']\n  apply Finset.all_card_le_biUnion_card_iff_exists_injective\n"}
