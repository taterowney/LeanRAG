{"name":"Equiv.Perm.Disjoint.symm","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nf g : Equiv.Perm α\na✝ : f.Disjoint g\n⊢ g.Disjoint f","decl":"@[symm]\ntheorem Disjoint.symm : Disjoint f g → Disjoint g f := by simp only [Disjoint, or_comm, imp_self]\n\n"}
{"name":"Equiv.Perm.Disjoint.symmetric","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\n⊢ Symmetric Equiv.Perm.Disjoint","decl":"theorem Disjoint.symmetric : Symmetric (@Disjoint α) := fun _ _ => Disjoint.symm\n\n"}
{"name":"Equiv.Perm.instIsSymmDisjoint","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\n⊢ IsSymm (Equiv.Perm α) Equiv.Perm.Disjoint","decl":"instance : IsSymm (Perm α) Disjoint :=\n  ⟨Disjoint.symmetric⟩\n\n"}
{"name":"Equiv.Perm.disjoint_comm","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nf g : Equiv.Perm α\n⊢ Iff (f.Disjoint g) (g.Disjoint f)","decl":"theorem disjoint_comm : Disjoint f g ↔ Disjoint g f :=\n  ⟨Disjoint.symm, Disjoint.symm⟩\n\n"}
{"name":"Equiv.Perm.Disjoint.commute","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nf g : Equiv.Perm α\nh : f.Disjoint g\n⊢ Commute f g","decl":"theorem Disjoint.commute (h : Disjoint f g) : Commute f g :=\n  Equiv.ext fun x =>\n    (h x).elim\n      (fun hf =>\n        (h (g x)).elim (fun hg => by simp [mul_apply, hf, hg]) fun hg => by\n          simp [mul_apply, hf, g.injective hg])\n      fun hg =>\n      (h (f x)).elim (fun hf => by simp [mul_apply, f.injective hf, hg]) fun hf => by\n        simp [mul_apply, hf, hg]\n\n"}
{"name":"Equiv.Perm.disjoint_one_left","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nf : Equiv.Perm α\n⊢ Equiv.Perm.Disjoint 1 f","decl":"@[simp]\ntheorem disjoint_one_left (f : Perm α) : Disjoint 1 f := fun _ => Or.inl rfl\n\n"}
{"name":"Equiv.Perm.disjoint_one_right","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nf : Equiv.Perm α\n⊢ f.Disjoint 1","decl":"@[simp]\ntheorem disjoint_one_right (f : Perm α) : Disjoint f 1 := fun _ => Or.inr rfl\n\n"}
{"name":"Equiv.Perm.disjoint_iff_eq_or_eq","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nf g : Equiv.Perm α\n⊢ Iff (f.Disjoint g) (∀ (x : α), Or (Eq (f x) x) (Eq (g x) x))","decl":"theorem disjoint_iff_eq_or_eq : Disjoint f g ↔ ∀ x : α, f x = x ∨ g x = x :=\n  Iff.rfl\n\n"}
{"name":"Equiv.Perm.disjoint_refl_iff","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nf : Equiv.Perm α\n⊢ Iff (f.Disjoint f) (Eq f 1)","decl":"@[simp]\ntheorem disjoint_refl_iff : Disjoint f f ↔ f = 1 := by\n  refine ⟨fun h => ?_, fun h => h.symm ▸ disjoint_one_left 1⟩\n  ext x\n  cases' h x with hx hx <;> simp [hx]\n\n"}
{"name":"Equiv.Perm.Disjoint.inv_left","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nf g : Equiv.Perm α\nh : f.Disjoint g\n⊢ (Inv.inv f).Disjoint g","decl":"theorem Disjoint.inv_left (h : Disjoint f g) : Disjoint f⁻¹ g := by\n  intro x\n  rw [inv_eq_iff_eq, eq_comm]\n  exact h x\n\n"}
{"name":"Equiv.Perm.Disjoint.inv_right","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nf g : Equiv.Perm α\nh : f.Disjoint g\n⊢ f.Disjoint (Inv.inv g)","decl":"theorem Disjoint.inv_right (h : Disjoint f g) : Disjoint f g⁻¹ :=\n  h.symm.inv_left.symm\n\n"}
{"name":"Equiv.Perm.disjoint_inv_left_iff","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nf g : Equiv.Perm α\n⊢ Iff ((Inv.inv f).Disjoint g) (f.Disjoint g)","decl":"@[simp]\ntheorem disjoint_inv_left_iff : Disjoint f⁻¹ g ↔ Disjoint f g := by\n  refine ⟨fun h => ?_, Disjoint.inv_left⟩\n  convert h.inv_left\n\n"}
{"name":"Equiv.Perm.disjoint_inv_right_iff","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nf g : Equiv.Perm α\n⊢ Iff (f.Disjoint (Inv.inv g)) (f.Disjoint g)","decl":"@[simp]\ntheorem disjoint_inv_right_iff : Disjoint f g⁻¹ ↔ Disjoint f g := by\n  rw [disjoint_comm, disjoint_inv_left_iff, disjoint_comm]\n\n"}
{"name":"Equiv.Perm.Disjoint.mul_left","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nf g h : Equiv.Perm α\nH1 : f.Disjoint h\nH2 : g.Disjoint h\n⊢ (HMul.hMul f g).Disjoint h","decl":"theorem Disjoint.mul_left (H1 : Disjoint f h) (H2 : Disjoint g h) : Disjoint (f * g) h := fun x =>\n  by cases H1 x <;> cases H2 x <;> simp [*]\n\n"}
{"name":"Equiv.Perm.Disjoint.mul_right","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nf g h : Equiv.Perm α\nH1 : f.Disjoint g\nH2 : f.Disjoint h\n⊢ f.Disjoint (HMul.hMul g h)","decl":"theorem Disjoint.mul_right (H1 : Disjoint f g) (H2 : Disjoint f h) : Disjoint f (g * h) := by\n  rw [disjoint_comm]\n  exact H1.symm.mul_left H2.symm\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: make it `@[simp]`\n"}
{"name":"Equiv.Perm.disjoint_conj","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nf g h : Equiv.Perm α\n⊢ Iff ((HMul.hMul (HMul.hMul h f) (Inv.inv h)).Disjoint (HMul.hMul (HMul.hMul h g) (Inv.inv h))) (f.Disjoint g)","decl":"theorem disjoint_conj (h : Perm α) : Disjoint (h * f * h⁻¹) (h * g * h⁻¹) ↔ Disjoint f g :=\n  (h⁻¹).forall_congr fun {_} ↦ by simp only [mul_apply, eq_inv_iff_eq]\n\n"}
{"name":"Equiv.Perm.Disjoint.conj","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nf g : Equiv.Perm α\nH : f.Disjoint g\nh : Equiv.Perm α\n⊢ (HMul.hMul (HMul.hMul h f) (Inv.inv h)).Disjoint (HMul.hMul (HMul.hMul h g) (Inv.inv h))","decl":"theorem Disjoint.conj (H : Disjoint f g) (h : Perm α) : Disjoint (h * f * h⁻¹) (h * g * h⁻¹) :=\n  (disjoint_conj h).2 H\n\n"}
{"name":"Equiv.Perm.disjoint_prod_right","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nf : Equiv.Perm α\nl : List (Equiv.Perm α)\nh : ∀ (g : Equiv.Perm α), Membership.mem l g → f.Disjoint g\n⊢ f.Disjoint l.prod","decl":"theorem disjoint_prod_right (l : List (Perm α)) (h : ∀ g ∈ l, Disjoint f g) :\n    Disjoint f l.prod := by\n  induction' l with g l ih\n  · exact disjoint_one_right _\n  · rw [List.prod_cons]\n    exact (h _ (List.mem_cons_self _ _)).mul_right (ih fun g hg => h g (List.mem_cons_of_mem _ hg))\n\n"}
{"name":"Equiv.Perm.disjoint_noncommProd_right","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ng : Equiv.Perm α\nι : Type u_2\nk : ι → Equiv.Perm α\ns : Finset ι\nhs : (↑s).Pairwise fun i j => Commute (k i) (k j)\nhg : ∀ (i : ι), Membership.mem s i → g.Disjoint (k i)\n⊢ g.Disjoint (s.noncommProd k hs)","decl":"theorem disjoint_noncommProd_right {ι : Type*} {k : ι → Perm α} {s : Finset ι}\n    (hs : Set.Pairwise s fun i j ↦ Commute (k i) (k j))\n    (hg : ∀ i ∈ s, g.Disjoint (k i)) :\n    Disjoint g (s.noncommProd k (hs)) :=\n  noncommProd_induction s k hs g.Disjoint (fun _ _ ↦ Disjoint.mul_right) (disjoint_one_right g) hg\n\n"}
{"name":"Equiv.Perm.disjoint_prod_perm","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nl₁ l₂ : List (Equiv.Perm α)\nhl : List.Pairwise Equiv.Perm.Disjoint l₁\nhp : l₁.Perm l₂\n⊢ Eq l₁.prod l₂.prod","decl":"open scoped List in\ntheorem disjoint_prod_perm {l₁ l₂ : List (Perm α)} (hl : l₁.Pairwise Disjoint) (hp : l₁ ~ l₂) :\n    l₁.prod = l₂.prod :=\n  hp.prod_eq' <| hl.imp Disjoint.commute\n\n"}
{"name":"Equiv.Perm.nodup_of_pairwise_disjoint","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nl : List (Equiv.Perm α)\nh1 : Not (Membership.mem l 1)\nh2 : List.Pairwise Equiv.Perm.Disjoint l\n⊢ l.Nodup","decl":"theorem nodup_of_pairwise_disjoint {l : List (Perm α)} (h1 : (1 : Perm α) ∉ l)\n    (h2 : l.Pairwise Disjoint) : l.Nodup := by\n  refine List.Pairwise.imp_of_mem ?_ h2\n  intro τ σ h_mem _ h_disjoint _\n  subst τ\n  suffices (σ : Perm α) = 1 by\n    rw [this] at h_mem\n    exact h1 h_mem\n  exact ext fun a => or_self_iff.mp (h_disjoint a)\n\n"}
{"name":"Equiv.Perm.pow_apply_eq_self_of_apply_eq_self","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nf : Equiv.Perm α\nx : α\nhfx : Eq (f x) x\nn : Nat\n⊢ Eq ((HPow.hPow f n) x) x","decl":"theorem pow_apply_eq_self_of_apply_eq_self {x : α} (hfx : f x = x) : ∀ n : ℕ, (f ^ n) x = x\n  | 0 => rfl\n  | n + 1 => by rw [pow_succ, mul_apply, hfx, pow_apply_eq_self_of_apply_eq_self hfx n]\n\n"}
{"name":"Equiv.Perm.zpow_apply_eq_self_of_apply_eq_self","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nf : Equiv.Perm α\nx : α\nhfx : Eq (f x) x\nn : Int\n⊢ Eq ((HPow.hPow f n) x) x","decl":"theorem zpow_apply_eq_self_of_apply_eq_self {x : α} (hfx : f x = x) : ∀ n : ℤ, (f ^ n) x = x\n  | (n : ℕ) => pow_apply_eq_self_of_apply_eq_self hfx n\n  | Int.negSucc n => by rw [zpow_negSucc, inv_eq_iff_eq, pow_apply_eq_self_of_apply_eq_self hfx]\n\n"}
{"name":"Equiv.Perm.pow_apply_eq_of_apply_apply_eq_self","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nf : Equiv.Perm α\nx : α\nhffx : Eq (f (f x)) x\nn : Nat\n⊢ Or (Eq ((HPow.hPow f n) x) x) (Eq ((HPow.hPow f n) x) (f x))","decl":"theorem pow_apply_eq_of_apply_apply_eq_self {x : α} (hffx : f (f x) = x) :\n    ∀ n : ℕ, (f ^ n) x = x ∨ (f ^ n) x = f x\n  | 0 => Or.inl rfl\n  | n + 1 =>\n    (pow_apply_eq_of_apply_apply_eq_self hffx n).elim\n      (fun h => Or.inr (by rw [pow_succ', mul_apply, h]))\n      fun h => Or.inl (by rw [pow_succ', mul_apply, h, hffx])\n\n"}
{"name":"Equiv.Perm.zpow_apply_eq_of_apply_apply_eq_self","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nf : Equiv.Perm α\nx : α\nhffx : Eq (f (f x)) x\ni : Int\n⊢ Or (Eq ((HPow.hPow f i) x) x) (Eq ((HPow.hPow f i) x) (f x))","decl":"theorem zpow_apply_eq_of_apply_apply_eq_self {x : α} (hffx : f (f x) = x) :\n    ∀ i : ℤ, (f ^ i) x = x ∨ (f ^ i) x = f x\n  | (n : ℕ) => pow_apply_eq_of_apply_apply_eq_self hffx n\n  | Int.negSucc n => by\n    rw [zpow_negSucc, inv_eq_iff_eq, ← f.injective.eq_iff, ← mul_apply, ← pow_succ', eq_comm,\n      inv_eq_iff_eq, ← mul_apply, ← pow_succ, @eq_comm _ x, or_comm]\n    exact pow_apply_eq_of_apply_apply_eq_self hffx _\n\n"}
{"name":"Equiv.Perm.Disjoint.mul_apply_eq_iff","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nσ τ : Equiv.Perm α\nhστ : σ.Disjoint τ\na : α\n⊢ Iff (Eq ((HMul.hMul σ τ) a) a) (And (Eq (σ a) a) (Eq (τ a) a))","decl":"theorem Disjoint.mul_apply_eq_iff {σ τ : Perm α} (hστ : Disjoint σ τ) {a : α} :\n    (σ * τ) a = a ↔ σ a = a ∧ τ a = a := by\n  refine ⟨fun h => ?_, fun h => by rw [mul_apply, h.2, h.1]⟩\n  cases' hστ a with hσ hτ\n  · exact ⟨hσ, σ.injective (h.trans hσ.symm)⟩\n  · exact ⟨(congr_arg σ hτ).symm.trans h, hτ⟩\n\n"}
{"name":"Equiv.Perm.Disjoint.mul_eq_one_iff","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nσ τ : Equiv.Perm α\nhστ : σ.Disjoint τ\n⊢ Iff (Eq (HMul.hMul σ τ) 1) (And (Eq σ 1) (Eq τ 1))","decl":"theorem Disjoint.mul_eq_one_iff {σ τ : Perm α} (hστ : Disjoint σ τ) :\n    σ * τ = 1 ↔ σ = 1 ∧ τ = 1 := by\n  simp_rw [Perm.ext_iff, one_apply, hστ.mul_apply_eq_iff, forall_and]\n\n"}
{"name":"Equiv.Perm.Disjoint.zpow_disjoint_zpow","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nσ τ : Equiv.Perm α\nhστ : σ.Disjoint τ\nm n : Int\n⊢ (HPow.hPow σ m).Disjoint (HPow.hPow τ n)","decl":"theorem Disjoint.zpow_disjoint_zpow {σ τ : Perm α} (hστ : Disjoint σ τ) (m n : ℤ) :\n    Disjoint (σ ^ m) (τ ^ n) := fun x =>\n  Or.imp (fun h => zpow_apply_eq_self_of_apply_eq_self h m)\n    (fun h => zpow_apply_eq_self_of_apply_eq_self h n) (hστ x)\n\n"}
{"name":"Equiv.Perm.Disjoint.pow_disjoint_pow","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nσ τ : Equiv.Perm α\nhστ : σ.Disjoint τ\nm n : Nat\n⊢ (HPow.hPow σ m).Disjoint (HPow.hPow τ n)","decl":"theorem Disjoint.pow_disjoint_pow {σ τ : Perm α} (hστ : Disjoint σ τ) (m n : ℕ) :\n    Disjoint (σ ^ m) (τ ^ n) :=\n  hστ.zpow_disjoint_zpow m n\n\n"}
{"name":"Equiv.Perm.ofSubtype_swap_eq","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\np : α → Prop\ninst✝ : DecidablePred p\nx y : Subtype p\n⊢ Eq (Equiv.Perm.ofSubtype (Equiv.swap x y)) (Equiv.swap ↑x ↑y)","decl":"@[simp]\ntheorem ofSubtype_swap_eq {p : α → Prop} [DecidablePred p] (x y : Subtype p) :\n    ofSubtype (Equiv.swap x y) = Equiv.swap ↑x ↑y :=\n  Equiv.ext fun z => by\n    by_cases hz : p z\n    · rw [swap_apply_def, ofSubtype_apply_of_mem _ hz]\n      split_ifs with hzx hzy\n      · simp_rw [hzx, Subtype.coe_eta, swap_apply_left]\n      · simp_rw [hzy, Subtype.coe_eta, swap_apply_right]\n      · rw [swap_apply_of_ne_of_ne] <;>\n        simp [Subtype.ext_iff, *]\n    · rw [ofSubtype_apply_of_not_mem _ hz, swap_apply_of_ne_of_ne]\n      · intro h\n        apply hz\n        rw [h]\n        exact Subtype.prop x\n      intro h\n      apply hz\n      rw [h]\n      exact Subtype.prop y\n\n"}
{"name":"Equiv.Perm.IsSwap.of_subtype_isSwap","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\np : α → Prop\ninst✝ : DecidablePred p\nf : Equiv.Perm (Subtype p)\nh : f.IsSwap\n⊢ (Equiv.Perm.ofSubtype f).IsSwap","decl":"theorem IsSwap.of_subtype_isSwap {p : α → Prop} [DecidablePred p] {f : Perm (Subtype p)}\n    (h : f.IsSwap) : (ofSubtype f).IsSwap :=\n  let ⟨⟨x, hx⟩, ⟨y, hy⟩, hxy⟩ := h\n  ⟨x, y, by\n    simp only [Ne, Subtype.ext_iff] at hxy\n    exact hxy.1, by\n    rw [hxy.2, ofSubtype_swap_eq]⟩\n\n"}
{"name":"Equiv.Perm.ne_and_ne_of_swap_mul_apply_ne_self","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nf : Equiv.Perm α\nx y : α\nhy : Ne ((HMul.hMul (Equiv.swap x (f x)) f) y) y\n⊢ And (Ne (f y) y) (Ne y x)","decl":"theorem ne_and_ne_of_swap_mul_apply_ne_self {f : Perm α} {x y : α} (hy : (swap x (f x) * f) y ≠ y) :\n    f y ≠ y ∧ y ≠ x := by\n  simp only [swap_apply_def, mul_apply, f.injective.eq_iff] at *\n  by_cases h : f y = x\n  · constructor <;> intro <;> simp_all only [if_true, eq_self_iff_true, not_true, Ne]\n  · split_ifs at hy with h <;> try { simp [*] at * }\n\n"}
{"name":"Equiv.Perm.set_support_inv_eq","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\np : Equiv.Perm α\n⊢ Eq (setOf fun x => Ne ((Inv.inv p) x) x) (setOf fun x => Ne (p x) x)","decl":"theorem set_support_inv_eq : { x | p⁻¹ x ≠ x } = { x | p x ≠ x } := by\n  ext x\n  simp only [Set.mem_setOf_eq, Ne]\n  rw [inv_def, symm_apply_eq, eq_comm]\n\n"}
{"name":"Equiv.Perm.set_support_apply_mem","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\np : Equiv.Perm α\na : α\n⊢ Iff (Membership.mem (setOf fun x => Ne (p x) x) (p a)) (Membership.mem (setOf fun x => Ne (p x) x) a)","decl":"theorem set_support_apply_mem {p : Perm α} {a : α} :\n    p a ∈ { x | p x ≠ x } ↔ a ∈ { x | p x ≠ x } := by simp\n\n"}
{"name":"Equiv.Perm.set_support_zpow_subset","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\np : Equiv.Perm α\nn : Int\n⊢ HasSubset.Subset (setOf fun x => Ne ((HPow.hPow p n) x) x) (setOf fun x => Ne (p x) x)","decl":"theorem set_support_zpow_subset (n : ℤ) : { x | (p ^ n) x ≠ x } ⊆ { x | p x ≠ x } := by\n  intro x\n  simp only [Set.mem_setOf_eq, Ne]\n  intro hx H\n  simp [zpow_apply_eq_self_of_apply_eq_self H] at hx\n\n"}
{"name":"Equiv.Perm.set_support_mul_subset","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\np q : Equiv.Perm α\n⊢ HasSubset.Subset (setOf fun x => Ne ((HMul.hMul p q) x) x) (Union.union (setOf fun x => Ne (p x) x) (setOf fun x => Ne (q x) x))","decl":"theorem set_support_mul_subset : { x | (p * q) x ≠ x } ⊆ { x | p x ≠ x } ∪ { x | q x ≠ x } := by\n  intro x\n  simp only [Perm.coe_mul, Function.comp_apply, Ne, Set.mem_union, Set.mem_setOf_eq]\n  by_cases hq : q x = x <;> simp [hq]\n\n"}
{"name":"Equiv.Perm.apply_pow_apply_eq_iff","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nf : Equiv.Perm α\nn : Nat\nx : α\n⊢ Iff (Eq (f ((HPow.hPow f n) x)) ((HPow.hPow f n) x)) (Eq (f x) x)","decl":"@[simp]\ntheorem apply_pow_apply_eq_iff (f : Perm α) (n : ℕ) {x : α} :\n    f ((f ^ n) x) = (f ^ n) x ↔ f x = x := by\n  rw [← mul_apply, Commute.self_pow f, mul_apply, apply_eq_iff_eq]\n\n"}
{"name":"Equiv.Perm.apply_zpow_apply_eq_iff","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\nf : Equiv.Perm α\nn : Int\nx : α\n⊢ Iff (Eq (f ((HPow.hPow f n) x)) ((HPow.hPow f n) x)) (Eq (f x) x)","decl":"@[simp]\ntheorem apply_zpow_apply_eq_iff (f : Perm α) (n : ℤ) {x : α} :\n    f ((f ^ n) x) = (f ^ n) x ↔ f x = x := by\n  rw [← mul_apply, Commute.self_zpow f, mul_apply, apply_eq_iff_eq]\n\n"}
{"name":"Equiv.Perm.mem_support","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\nx : α\n⊢ Iff (Membership.mem f.support x) (Ne (f x) x)","decl":"@[simp]\ntheorem mem_support {x : α} : x ∈ f.support ↔ f x ≠ x := by\n  rw [support, mem_filter, and_iff_right (mem_univ x)]\n\n"}
{"name":"Equiv.Perm.not_mem_support","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\nx : α\n⊢ Iff (Not (Membership.mem f.support x)) (Eq (f x) x)","decl":"theorem not_mem_support {x : α} : x ∉ f.support ↔ f x = x := by simp\n\n"}
{"name":"Equiv.Perm.coe_support_eq_set_support","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\n⊢ Eq (↑f.support) (setOf fun x => Ne (f x) x)","decl":"theorem coe_support_eq_set_support (f : Perm α) : (f.support : Set α) = { x | f x ≠ x } := by\n  ext\n  simp\n\n"}
{"name":"Equiv.Perm.support_eq_empty_iff","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nσ : Equiv.Perm α\n⊢ Iff (Eq σ.support EmptyCollection.emptyCollection) (Eq σ 1)","decl":"@[simp]\ntheorem support_eq_empty_iff {σ : Perm α} : σ.support = ∅ ↔ σ = 1 := by\n  simp_rw [Finset.ext_iff, mem_support, Finset.not_mem_empty, iff_false, not_not,\n    Equiv.Perm.ext_iff, one_apply]\n\n"}
{"name":"Equiv.Perm.support_one","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n⊢ Eq (Equiv.Perm.support 1) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem support_one : (1 : Perm α).support = ∅ := by rw [support_eq_empty_iff]\n\n"}
{"name":"Equiv.Perm.support_refl","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n⊢ Eq (Equiv.Perm.support (Equiv.refl α)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem support_refl : support (Equiv.refl α) = ∅ :=\n  support_one\n\n"}
{"name":"Equiv.Perm.support_congr","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf g : Equiv.Perm α\nh : HasSubset.Subset f.support g.support\nh' : ∀ (x : α), Membership.mem g.support x → Eq (f x) (g x)\n⊢ Eq f g","decl":"theorem support_congr (h : f.support ⊆ g.support) (h' : ∀ x ∈ g.support, f x = g x) : f = g := by\n  ext x\n  by_cases hx : x ∈ g.support\n  · exact h' x hx\n  · rw [not_mem_support.mp hx, ← not_mem_support]\n    exact fun H => hx (h H)\n\n"}
{"name":"Equiv.Perm.mem_support_iff_of_commute","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng c : Equiv.Perm α\nhgc : Commute g c\nx : α\n⊢ Iff (Membership.mem c.support x) (Membership.mem c.support (g x))","decl":"/-- If g and c commute, then g stabilizes the support of c -/\ntheorem mem_support_iff_of_commute {g c : Perm α} (hgc : Commute g c) (x : α) :\n    x ∈ c.support ↔ g x ∈ c.support := by\n  simp only [mem_support, not_iff_not, ← mul_apply]\n  rw [← hgc, mul_apply, Equiv.apply_eq_iff_eq]\n\n"}
{"name":"Equiv.Perm.support_mul_le","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf g : Equiv.Perm α\n⊢ LE.le (HMul.hMul f g).support (Max.max f.support g.support)","decl":"theorem support_mul_le (f g : Perm α) : (f * g).support ≤ f.support ⊔ g.support := fun x => by\n  simp only [sup_eq_union]\n  rw [mem_union, mem_support, mem_support, mem_support, mul_apply, ← not_and_or, not_imp_not]\n  rintro ⟨hf, hg⟩\n  rw [hg, hf]\n\n"}
{"name":"Equiv.Perm.exists_mem_support_of_mem_support_prod","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nl : List (Equiv.Perm α)\nx : α\nhx : Membership.mem l.prod.support x\n⊢ Exists fun f => And (Membership.mem l f) (Membership.mem f.support x)","decl":"theorem exists_mem_support_of_mem_support_prod {l : List (Perm α)} {x : α}\n    (hx : x ∈ l.prod.support) : ∃ f : Perm α, f ∈ l ∧ x ∈ f.support := by\n  contrapose! hx\n  simp_rw [mem_support, not_not] at hx ⊢\n  induction' l with f l ih\n  · rfl\n  · rw [List.prod_cons, mul_apply, ih, hx]\n    · simp only [List.find?, List.mem_cons, true_or]\n    intros f' hf'\n    refine hx f' ?_\n    simp only [List.find?, List.mem_cons]\n    exact Or.inr hf'\n\n"}
{"name":"Equiv.Perm.support_pow_le","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nσ : Equiv.Perm α\nn : Nat\n⊢ LE.le (HPow.hPow σ n).support σ.support","decl":"theorem support_pow_le (σ : Perm α) (n : ℕ) : (σ ^ n).support ≤ σ.support := fun _ h1 =>\n  mem_support.mpr fun h2 => mem_support.mp h1 (pow_apply_eq_self_of_apply_eq_self h2 n)\n\n"}
{"name":"Equiv.Perm.support_inv","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nσ : Equiv.Perm α\n⊢ Eq (Inv.inv σ).support σ.support","decl":"@[simp]\ntheorem support_inv (σ : Perm α) : support σ⁻¹ = σ.support := by\n  simp_rw [Finset.ext_iff, mem_support, not_iff_not, inv_eq_iff_eq.trans eq_comm, imp_true_iff]\n\n"}
{"name":"Equiv.Perm.apply_mem_support","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\nx : α\n⊢ Iff (Membership.mem f.support (f x)) (Membership.mem f.support x)","decl":"theorem apply_mem_support {x : α} : f x ∈ f.support ↔ x ∈ f.support := by\n  rw [mem_support, mem_support, Ne, Ne, apply_eq_iff_eq]\n\n"}
{"name":"Equiv.Perm.isInvariant_of_support_le","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nc : Equiv.Perm α\ns : Finset α\nhcs : LE.le c.support s\nx : α\n⊢ Iff (Membership.mem s x) (Membership.mem s (c x))","decl":"/-- The support of a permutation is invariant -/\ntheorem isInvariant_of_support_le {c : Perm α} {s : Finset α} (hcs : c.support ≤ s) (x : α) :\n    x ∈ s ↔ c x ∈ s := by\n  by_cases hx' : x ∈ c.support\n  · simp only [hcs hx', true_iff, hcs (apply_mem_support.mpr hx')]\n  · rw [not_mem_support.mp hx']\n\n"}
{"name":"Equiv.Perm.ofSubtype_eq_iff","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng c : Equiv.Perm α\ns : Finset α\nhg : ∀ (x : α), Iff (Membership.mem s x) (Membership.mem s (g x))\n⊢ Iff (Eq (Equiv.Perm.ofSubtype (g.subtypePerm hg)) c) (And (LE.le c.support s) (∀ (hc' : ∀ (x : α), Iff (Membership.mem s x) (Membership.mem s (c x))), Eq (c.subtypePerm hc') (g.subtypePerm hg)))","decl":"/-- A permutation c is the extension of a restriction of g to s\n  iff its support is contained in s and its restriction is that of g -/\nlemma ofSubtype_eq_iff {g c : Equiv.Perm α} {s : Finset α}\n    (hg : ∀ x, x ∈ s ↔ g x ∈ s) :\n    ofSubtype (g.subtypePerm hg) = c ↔\n      c.support ≤ s ∧\n      ∀ (hc' : ∀ x, x ∈ s ↔ c x ∈ s), c.subtypePerm hc' = g.subtypePerm hg := by\n  simp only [Equiv.ext_iff, subtypePerm_apply, Subtype.mk.injEq, Subtype.forall]\n  constructor\n  · intro h\n    constructor\n    · intro a ha\n      by_contra ha'\n      rw [mem_support, ← h a, ofSubtype_apply_of_not_mem (p := (· ∈ s)) _ ha'] at ha\n      exact ha rfl\n    · intro _ a ha\n      rw [← h a, ofSubtype_apply_of_mem (p := (· ∈ s)) _ ha, subtypePerm_apply]\n  · rintro ⟨hc, h⟩ a\n    specialize h (isInvariant_of_support_le hc)\n    by_cases ha : a ∈ s\n    · rw [h a ha, ofSubtype_apply_of_mem (p := (· ∈ s)) _ ha, subtypePerm_apply]\n    · rw [ofSubtype_apply_of_not_mem (p := (· ∈ s)) _ ha, eq_comm, ← not_mem_support]\n      exact Finset.not_mem_mono hc ha\n\n"}
{"name":"Equiv.Perm.support_ofSubtype","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\np : α → Prop\ninst✝ : DecidablePred p\nu : Equiv.Perm (Subtype p)\n⊢ Eq (Equiv.Perm.ofSubtype u).support (Finset.map (Function.Embedding.subtype p) u.support)","decl":"theorem support_ofSubtype {p : α → Prop} [DecidablePred p] (u : Perm (Subtype p)) :\n    (ofSubtype u).support = u.support.map (Function.Embedding.subtype p) := by\n  ext x\n  simp only [mem_support, ne_eq, Finset.mem_map, Function.Embedding.coe_subtype, Subtype.exists,\n    exists_and_right, exists_eq_right, not_iff_comm, not_exists, not_not]\n  by_cases hx : p x\n  · simp only [forall_prop_of_true hx, ofSubtype_apply_of_mem u hx, ← Subtype.coe_inj]\n  · simp only [forall_prop_of_false hx, true_iff, ofSubtype_apply_of_not_mem u hx]\n\n"}
{"name":"Equiv.Perm.mem_support_of_mem_noncommProd_support","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : Fintype β\ns : Finset α\nf : α → Equiv.Perm β\ncomm : (↑s).Pairwise (Function.onFun Commute f)\nx : β\nhx : Membership.mem (s.noncommProd f comm).support x\n⊢ Exists fun a => And (Membership.mem s a) (Membership.mem (f a).support x)","decl":"theorem mem_support_of_mem_noncommProd_support {α β : Type*} [DecidableEq β] [Fintype β]\n    {s : Finset α} {f : α → Perm β}\n    {comm : (s : Set α).Pairwise (Commute on f)} {x : β} (hx : x ∈ (s.noncommProd f comm).support) :\n    ∃ a ∈ s, x ∈ (f a).support := by\n  contrapose! hx\n  classical\n  revert hx comm s\n  apply Finset.induction\n  · simp\n  · intro a s ha ih comm hs\n    rw [Finset.noncommProd_insert_of_not_mem s a f comm ha]\n    apply mt (Finset.mem_of_subset (support_mul_le _ _))\n    rw [Finset.sup_eq_union, Finset.not_mem_union]\n    exact ⟨hs a (s.mem_insert_self a), ih (fun a ha ↦ hs a (Finset.mem_insert_of_mem ha))⟩\n\n"}
{"name":"Equiv.Perm.pow_apply_mem_support","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\nn : Nat\nx : α\n⊢ Iff (Membership.mem f.support ((HPow.hPow f n) x)) (Membership.mem f.support x)","decl":"theorem pow_apply_mem_support {n : ℕ} {x : α} : (f ^ n) x ∈ f.support ↔ x ∈ f.support := by\n  simp only [mem_support, ne_eq, apply_pow_apply_eq_iff]\n\n"}
{"name":"Equiv.Perm.zpow_apply_mem_support","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\nn : Int\nx : α\n⊢ Iff (Membership.mem f.support ((HPow.hPow f n) x)) (Membership.mem f.support x)","decl":"theorem zpow_apply_mem_support {n : ℤ} {x : α} : (f ^ n) x ∈ f.support ↔ x ∈ f.support := by\n  simp only [mem_support, ne_eq, apply_zpow_apply_eq_iff]\n\n"}
{"name":"Equiv.Perm.pow_eq_on_of_mem_support","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf g : Equiv.Perm α\nh : ∀ (x : α), Membership.mem (Inter.inter f.support g.support) x → Eq (f x) (g x)\nk : Nat\nx : α\na✝ : Membership.mem (Inter.inter f.support g.support) x\n⊢ Eq ((HPow.hPow f k) x) ((HPow.hPow g k) x)","decl":"theorem pow_eq_on_of_mem_support (h : ∀ x ∈ f.support ∩ g.support, f x = g x) (k : ℕ) :\n    ∀ x ∈ f.support ∩ g.support, (f ^ k) x = (g ^ k) x := by\n  induction' k with k hk\n  · simp\n  · intro x hx\n    rw [pow_succ, mul_apply, pow_succ, mul_apply, h _ hx, hk]\n    rwa [mem_inter, apply_mem_support, ← h _ hx, apply_mem_support, ← mem_inter]\n\n"}
{"name":"Equiv.Perm.disjoint_iff_disjoint_support","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf g : Equiv.Perm α\n⊢ Iff (f.Disjoint g) (Disjoint f.support g.support)","decl":"theorem disjoint_iff_disjoint_support : Disjoint f g ↔ _root_.Disjoint f.support g.support := by\n  simp [disjoint_iff_eq_or_eq, disjoint_iff, disjoint_iff, Finset.ext_iff, not_and_or,\n    imp_iff_not_or]\n\n"}
{"name":"Equiv.Perm.Disjoint.disjoint_support","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf g : Equiv.Perm α\nh : f.Disjoint g\n⊢ Disjoint f.support g.support","decl":"theorem Disjoint.disjoint_support (h : Disjoint f g) : _root_.Disjoint f.support g.support :=\n  disjoint_iff_disjoint_support.1 h\n\n"}
{"name":"Equiv.Perm.Disjoint.support_mul","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf g : Equiv.Perm α\nh : f.Disjoint g\n⊢ Eq (HMul.hMul f g).support (Union.union f.support g.support)","decl":"theorem Disjoint.support_mul (h : Disjoint f g) : (f * g).support = f.support ∪ g.support := by\n  refine le_antisymm (support_mul_le _ _) fun a => ?_\n  rw [mem_union, mem_support, mem_support, mem_support, mul_apply, ← not_and_or, not_imp_not]\n  exact\n    (h a).elim (fun hf h => ⟨hf, f.apply_eq_iff_eq.mp (h.trans hf.symm)⟩) fun hg h =>\n      ⟨(congr_arg f hg).symm.trans h, hg⟩\n\n"}
{"name":"Equiv.Perm.support_prod_of_pairwise_disjoint","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nl : List (Equiv.Perm α)\nh : List.Pairwise Equiv.Perm.Disjoint l\n⊢ Eq l.prod.support (List.foldr (fun x1 x2 => Max.max x1 x2) Bot.bot (List.map Equiv.Perm.support l))","decl":"theorem support_prod_of_pairwise_disjoint (l : List (Perm α)) (h : l.Pairwise Disjoint) :\n    l.prod.support = (l.map support).foldr (· ⊔ ·) ⊥ := by\n  induction' l with hd tl hl\n  · simp\n  · rw [List.pairwise_cons] at h\n    have : Disjoint hd tl.prod := disjoint_prod_right _ h.left\n    simp [this.support_mul, hl h.right]\n\n"}
{"name":"Equiv.Perm.support_noncommProd","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nι : Type u_2\nk : ι → Equiv.Perm α\ns : Finset ι\nhs : (↑s).Pairwise fun i j => (k i).Disjoint (k j)\n⊢ Eq (s.noncommProd k ⋯).support (s.biUnion fun i => (k i).support)","decl":"theorem support_noncommProd {ι : Type*} {k : ι → Perm α} {s : Finset ι}\n    (hs : Set.Pairwise s fun i j ↦ Disjoint (k i) (k j)) :\n    (s.noncommProd k (hs.imp (fun _ _ ↦ Perm.Disjoint.commute))).support =\n      s.biUnion fun i ↦ (k i).support := by\n  classical\n  induction s using Finset.induction_on with\n  | empty => simp\n  | @insert i s hi hrec =>\n    have hs' : (s : Set ι).Pairwise fun i j ↦ Disjoint (k i) (k j) :=\n      hs.mono (by simp only [Finset.coe_insert, Set.subset_insert])\n    rw [Finset.noncommProd_insert_of_not_mem _ _ _ _ hi, Finset.biUnion_insert]\n    rw [Equiv.Perm.Disjoint.support_mul, hrec hs']\n    apply disjoint_noncommProd_right\n    intro j hj\n    apply hs _ _ (ne_of_mem_of_not_mem hj hi).symm <;>\n      simp only [Finset.coe_insert, Set.mem_insert_iff, Finset.mem_coe, hj, or_true, true_or]\n\n"}
{"name":"Equiv.Perm.support_prod_le","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nl : List (Equiv.Perm α)\n⊢ LE.le l.prod.support (List.foldr (fun x1 x2 => Max.max x1 x2) Bot.bot (List.map Equiv.Perm.support l))","decl":"theorem support_prod_le (l : List (Perm α)) : l.prod.support ≤ (l.map support).foldr (· ⊔ ·) ⊥ := by\n  induction' l with hd tl hl\n  · simp\n  · rw [List.prod_cons, List.map_cons, List.foldr_cons]\n    refine (support_mul_le hd tl.prod).trans ?_\n    exact sup_le_sup le_rfl hl\n\n"}
{"name":"Equiv.Perm.support_zpow_le","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nσ : Equiv.Perm α\nn : Int\n⊢ LE.le (HPow.hPow σ n).support σ.support","decl":"theorem support_zpow_le (σ : Perm α) (n : ℤ) : (σ ^ n).support ≤ σ.support := fun _ h1 =>\n  mem_support.mpr fun h2 => mem_support.mp h1 (zpow_apply_eq_self_of_apply_eq_self h2 n)\n\n"}
{"name":"Equiv.Perm.support_swap","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nx y : α\nh : Ne x y\n⊢ Eq (Equiv.swap x y).support (Insert.insert x (Singleton.singleton y))","decl":"@[simp]\ntheorem support_swap {x y : α} (h : x ≠ y) : support (swap x y) = {x, y} := by\n  ext z\n  by_cases hx : z = x\n  any_goals simpa [hx] using h.symm\n  by_cases hy : z = y\n  · simpa [swap_apply_of_ne_of_ne, hx, hy] using h\n  · simp [swap_apply_of_ne_of_ne, hx, hy]\n\n"}
{"name":"Equiv.Perm.support_swap_iff","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nx y : α\n⊢ Iff (Eq (Equiv.swap x y).support (Insert.insert x (Singleton.singleton y))) (Ne x y)","decl":"theorem support_swap_iff (x y : α) : support (swap x y) = {x, y} ↔ x ≠ y := by\n  refine ⟨fun h => ?_, fun h => support_swap h⟩\n  rintro rfl\n  simp [Finset.ext_iff] at h\n\n"}
{"name":"Equiv.Perm.support_swap_mul_swap","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nx y z : α\nh : (List.cons x (List.cons y (List.cons z List.nil))).Nodup\n⊢ Eq (HMul.hMul (Equiv.swap x y) (Equiv.swap y z)).support (Insert.insert x (Insert.insert y (Singleton.singleton z)))","decl":"theorem support_swap_mul_swap {x y z : α} (h : List.Nodup [x, y, z]) :\n    support (swap x y * swap y z) = {x, y, z} := by\n  simp only [List.not_mem_nil, and_true, List.mem_cons, not_false_iff, List.nodup_cons,\n    List.mem_singleton, and_self_iff, List.nodup_nil] at h\n  push_neg at h\n  apply le_antisymm\n  · convert support_mul_le (swap x y) (swap y z) using 1\n    rw [support_swap h.left.left, support_swap h.right.left]\n    simp [Finset.ext_iff]\n  · intro\n    simp only [mem_insert, mem_singleton]\n    rintro (rfl | rfl | rfl | _) <;>\n      simp [swap_apply_of_ne_of_ne, h.left.left, h.left.left.symm, h.left.right.symm,\n        h.left.right.left.symm, h.right.left.symm]\n\n"}
{"name":"Equiv.Perm.support_swap_mul_ge_support_diff","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\nx y : α\n⊢ LE.le (SDiff.sdiff f.support (Insert.insert x (Singleton.singleton y))) (HMul.hMul (Equiv.swap x y) f).support","decl":"theorem support_swap_mul_ge_support_diff (f : Perm α) (x y : α) :\n    f.support \\ {x, y} ≤ (swap x y * f).support := by\n  intro\n  simp only [and_imp, Perm.coe_mul, Function.comp_apply, Ne, mem_support, mem_insert, mem_sdiff,\n    mem_singleton]\n  push_neg\n  rintro ha ⟨hx, hy⟩ H\n  rw [swap_apply_eq_iff, swap_apply_of_ne_of_ne hx hy] at H\n  exact ha H\n\n"}
{"name":"Equiv.Perm.support_swap_mul_eq","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\nx : α\nh : Ne (f (f x)) x\n⊢ Eq (HMul.hMul (Equiv.swap x (f x)) f).support (SDiff.sdiff f.support (Singleton.singleton x))","decl":"theorem support_swap_mul_eq (f : Perm α) (x : α) (h : f (f x) ≠ x) :\n    (swap x (f x) * f).support = f.support \\ {x} := by\n  by_cases hx : f x = x\n  · simp [hx, sdiff_singleton_eq_erase, not_mem_support.mpr hx, erase_eq_of_not_mem]\n  ext z\n  by_cases hzx : z = x\n  · simp [hzx]\n  by_cases hzf : z = f x\n  · simp [hzf, hx, h, swap_apply_of_ne_of_ne]\n  by_cases hzfx : f z = x\n  · simp [Ne.symm hzx, hzx, Ne.symm hzf, hzfx]\n  · simp [Ne.symm hzx, hzx, Ne.symm hzf, hzfx, f.injective.ne hzx, swap_apply_of_ne_of_ne]\n\n"}
{"name":"Equiv.Perm.mem_support_swap_mul_imp_mem_support_ne","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\nx y : α\nhy : Membership.mem (HMul.hMul (Equiv.swap x (f x)) f).support y\n⊢ And (Membership.mem f.support y) (Ne y x)","decl":"theorem mem_support_swap_mul_imp_mem_support_ne {x y : α} (hy : y ∈ support (swap x (f x) * f)) :\n    y ∈ support f ∧ y ≠ x := by\n  simp only [mem_support, swap_apply_def, mul_apply, f.injective.eq_iff] at *\n  by_cases h : f y = x\n  · constructor <;> intro <;> simp_all only [if_true, eq_self_iff_true, not_true, Ne]\n  · split_ifs at hy with heq\n    · subst heq; exact ⟨h, hy⟩\n    · exact ⟨hy, heq⟩\n\n"}
{"name":"Equiv.Perm.Disjoint.mem_imp","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf g : Equiv.Perm α\nh : f.Disjoint g\nx : α\nhx : Membership.mem f.support x\n⊢ Not (Membership.mem g.support x)","decl":"theorem Disjoint.mem_imp (h : Disjoint f g) {x : α} (hx : x ∈ f.support) : x ∉ g.support :=\n  disjoint_left.mp h.disjoint_support hx\n\n"}
{"name":"Equiv.Perm.eq_on_support_mem_disjoint","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\nl : List (Equiv.Perm α)\nh : Membership.mem l f\nhl : List.Pairwise Equiv.Perm.Disjoint l\nx : α\na✝ : Membership.mem f.support x\n⊢ Eq (f x) (l.prod x)","decl":"theorem eq_on_support_mem_disjoint {l : List (Perm α)} (h : f ∈ l) (hl : l.Pairwise Disjoint) :\n    ∀ x ∈ f.support, f x = l.prod x := by\n  induction' l with hd tl IH\n  · simp at h\n  · intro x hx\n    rw [List.pairwise_cons] at hl\n    rw [List.mem_cons] at h\n    rcases h with (rfl | h)\n    · rw [List.prod_cons, mul_apply,\n        not_mem_support.mp ((disjoint_prod_right tl hl.left).mem_imp hx)]\n    · rw [List.prod_cons, mul_apply, ← IH h hl.right _ hx, eq_comm, ← not_mem_support]\n      refine (hl.left _ h).symm.mem_imp ?_\n      simpa using hx\n\n"}
{"name":"Equiv.Perm.Disjoint.mono","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf g x y : Equiv.Perm α\nh : f.Disjoint g\nhf : LE.le x.support f.support\nhg : LE.le y.support g.support\n⊢ x.Disjoint y","decl":"theorem Disjoint.mono {x y : Perm α} (h : Disjoint f g) (hf : x.support ≤ f.support)\n    (hg : y.support ≤ g.support) : Disjoint x y := by\n  rw [disjoint_iff_disjoint_support] at h ⊢\n  exact h.mono hf hg\n\n"}
{"name":"Equiv.Perm.support_le_prod_of_mem","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\nl : List (Equiv.Perm α)\nh : Membership.mem l f\nhl : List.Pairwise Equiv.Perm.Disjoint l\n⊢ LE.le f.support l.prod.support","decl":"theorem support_le_prod_of_mem {l : List (Perm α)} (h : f ∈ l) (hl : l.Pairwise Disjoint) :\n    f.support ≤ l.prod.support := by\n  intro x hx\n  rwa [mem_support, ← eq_on_support_mem_disjoint h hl _ hx, ← mem_support]\n\n"}
{"name":"Equiv.Perm.support_extend_domain","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝⁴ : DecidableEq α\ninst✝³ : Fintype α\nβ : Type u_2\ninst✝² : DecidableEq β\ninst✝¹ : Fintype β\np : β → Prop\ninst✝ : DecidablePred p\nf : Equiv α (Subtype p)\ng : Equiv.Perm α\n⊢ Eq (g.extendDomain f).support (Finset.map f.asEmbedding g.support)","decl":"@[simp]\ntheorem support_extend_domain (f : α ≃ Subtype p) {g : Perm α} :\n    support (g.extendDomain f) = g.support.map f.asEmbedding := by\n  ext b\n  simp only [exists_prop, Function.Embedding.coeFn_mk, toEmbedding_apply, mem_map, Ne,\n    Function.Embedding.trans_apply, mem_support]\n  by_cases pb : p b\n  · rw [extendDomain_apply_subtype _ _ pb]\n    constructor\n    · rintro h\n      refine ⟨f.symm ⟨b, pb⟩, ?_, by simp⟩\n      contrapose! h\n      simp [h]\n    · rintro ⟨a, ha, hb⟩\n      contrapose! ha\n      obtain rfl : a = f.symm ⟨b, pb⟩ := by\n        rw [eq_symm_apply]\n        exact Subtype.coe_injective hb\n      rw [eq_symm_apply]\n      exact Subtype.coe_injective ha\n  · rw [extendDomain_apply_not_subtype _ _ pb]\n    simp only [not_exists, false_iff, not_and, eq_self_iff_true, not_true]\n    rintro a _ rfl\n    exact pb (Subtype.prop _)\n\n"}
{"name":"Equiv.Perm.card_support_extend_domain","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝⁴ : DecidableEq α\ninst✝³ : Fintype α\nβ : Type u_2\ninst✝² : DecidableEq β\ninst✝¹ : Fintype β\np : β → Prop\ninst✝ : DecidablePred p\nf : Equiv α (Subtype p)\ng : Equiv.Perm α\n⊢ Eq (g.extendDomain f).support.card g.support.card","decl":"theorem card_support_extend_domain (f : α ≃ Subtype p) {g : Perm α} :\n    #(g.extendDomain f).support = #g.support := by simp\n\n"}
{"name":"Equiv.Perm.card_support_eq_zero","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\n⊢ Iff (Eq f.support.card 0) (Eq f 1)","decl":"theorem card_support_eq_zero {f : Perm α} : #f.support = 0 ↔ f = 1 := by\n  rw [Finset.card_eq_zero, support_eq_empty_iff]\n\n"}
{"name":"Equiv.Perm.one_lt_card_support_of_ne_one","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\nh : Ne f 1\n⊢ LT.lt 1 f.support.card","decl":"theorem one_lt_card_support_of_ne_one {f : Perm α} (h : f ≠ 1) : 1 < #f.support := by\n  simp_rw [one_lt_card_iff, mem_support, ← not_or]\n  contrapose! h\n  ext a\n  specialize h (f a) a\n  rwa [apply_eq_iff_eq, or_self_iff, or_self_iff] at h\n\n"}
{"name":"Equiv.Perm.card_support_ne_one","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\n⊢ Ne f.support.card 1","decl":"theorem card_support_ne_one (f : Perm α) : #f.support ≠ 1 := by\n  by_cases h : f = 1\n  · exact ne_of_eq_of_ne (card_support_eq_zero.mpr h) zero_ne_one\n  · exact ne_of_gt (one_lt_card_support_of_ne_one h)\n\n"}
{"name":"Equiv.Perm.card_support_le_one","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\n⊢ Iff (LE.le f.support.card 1) (Eq f 1)","decl":"@[simp]\ntheorem card_support_le_one {f : Perm α} : #f.support ≤ 1 ↔ f = 1 := by\n  rw [le_iff_lt_or_eq, Nat.lt_succ_iff, Nat.le_zero, card_support_eq_zero, or_iff_not_imp_right,\n    imp_iff_right f.card_support_ne_one]\n\n"}
{"name":"Equiv.Perm.two_le_card_support_of_ne_one","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\nh : Ne f 1\n⊢ LE.le 2 f.support.card","decl":"theorem two_le_card_support_of_ne_one {f : Perm α} (h : f ≠ 1) : 2 ≤ #f.support :=\n  one_lt_card_support_of_ne_one h\n\n"}
{"name":"Equiv.Perm.card_support_swap_mul","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\nx : α\nhx : Ne (f x) x\n⊢ LT.lt (HMul.hMul (Equiv.swap x (f x)) f).support.card f.support.card","decl":"theorem card_support_swap_mul {f : Perm α} {x : α} (hx : f x ≠ x) :\n    #(swap x (f x) * f).support < #f.support :=\n  Finset.card_lt_card\n    ⟨fun _ hz => (mem_support_swap_mul_imp_mem_support_ne hz).left, fun h =>\n      absurd (h (mem_support.2 hx)) (mt mem_support.1 (by simp))⟩\n\n"}
{"name":"Equiv.Perm.card_support_swap","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nx y : α\nhxy : Ne x y\n⊢ Eq (Equiv.swap x y).support.card 2","decl":"theorem card_support_swap {x y : α} (hxy : x ≠ y) : #(swap x y).support = 2 :=\n  show #(swap x y).support = #⟨x ::ₘ y ::ₘ 0, by simp [hxy]⟩ from\n    congr_arg card <| by simp [support_swap hxy, *, Finset.ext_iff]\n\n"}
{"name":"Equiv.Perm.card_support_eq_two","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\n⊢ Iff (Eq f.support.card 2) f.IsSwap","decl":"@[simp]\ntheorem card_support_eq_two {f : Perm α} : #f.support = 2 ↔ IsSwap f := by\n  constructor <;> intro h\n  · obtain ⟨x, t, hmem, hins, ht⟩ := card_eq_succ.1 h\n    obtain ⟨y, rfl⟩ := card_eq_one.1 ht\n    rw [mem_singleton] at hmem\n    refine ⟨x, y, hmem, ?_⟩\n    ext a\n    have key : ∀ b, f b ≠ b ↔ _ := fun b => by rw [← mem_support, ← hins, mem_insert, mem_singleton]\n    by_cases ha : f a = a\n    · have ha' := not_or.mp (mt (key a).mpr (not_not.mpr ha))\n      rw [ha, swap_apply_of_ne_of_ne ha'.1 ha'.2]\n    · have ha' := (key (f a)).mp (mt f.apply_eq_iff_eq.mp ha)\n      obtain rfl | rfl := (key a).mp ha\n      · rw [Or.resolve_left ha' ha, swap_apply_left]\n      · rw [Or.resolve_right ha' ha, swap_apply_right]\n  · obtain ⟨x, y, hxy, rfl⟩ := h\n    exact card_support_swap hxy\n\n"}
{"name":"Equiv.Perm.Disjoint.card_support_mul","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf g : Equiv.Perm α\nh : f.Disjoint g\n⊢ Eq (HMul.hMul f g).support.card (HAdd.hAdd f.support.card g.support.card)","decl":"theorem Disjoint.card_support_mul (h : Disjoint f g) :\n    #(f * g).support = #f.support + #g.support := by\n  rw [← Finset.card_union_of_disjoint]\n  · congr\n    ext\n    simp [h.support_mul]\n  · simpa using h.disjoint_support\n\n"}
{"name":"Equiv.Perm.card_support_prod_list_of_pairwise_disjoint","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nl : List (Equiv.Perm α)\nh : List.Pairwise Equiv.Perm.Disjoint l\n⊢ Eq l.prod.support.card (List.map (Function.comp Finset.card Equiv.Perm.support) l).sum","decl":"theorem card_support_prod_list_of_pairwise_disjoint {l : List (Perm α)} (h : l.Pairwise Disjoint) :\n    #l.prod.support = (l.map (card ∘ support)).sum := by\n  induction' l with a t ih\n  · exact card_support_eq_zero.mpr rfl\n  · obtain ⟨ha, ht⟩ := List.pairwise_cons.1 h\n    rw [List.prod_cons, List.map_cons, List.sum_cons, ← ih ht]\n    exact (disjoint_prod_right _ ha).card_support_mul\n\n"}
{"name":"Equiv.Perm.support_subtype_perm","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nf : Equiv.Perm α\nh : ∀ (x : α), Iff (Membership.mem s x) (Membership.mem s (f x))\n⊢ Eq (f.subtypePerm h).support (Finset.filter (fun x => Ne (f ↑x) ↑x) Finset.univ)","decl":"@[simp]\ntheorem support_subtype_perm [DecidableEq α] {s : Finset α} (f : Perm α) (h) :\n    (f.subtypePerm h : Perm s).support = ({x | f x ≠ x} : Finset s) := by\n  ext; simp [Subtype.ext_iff]\n\n"}
{"name":"Equiv.Perm.fixed_point_card_lt_of_ne_one","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nσ : Equiv.Perm α\nh : Ne σ 1\n⊢ LT.lt (Finset.filter (fun x => Eq (σ x) x) Finset.univ).card (HSub.hSub (Fintype.card α) 1)","decl":"theorem fixed_point_card_lt_of_ne_one [DecidableEq α] [Fintype α] {σ : Perm α} (h : σ ≠ 1) :\n    #{x | σ x = x} < Fintype.card α - 1 := by\n  rw [Nat.lt_sub_iff_add_lt, ← Nat.lt_sub_iff_add_lt', ← Finset.card_compl, Finset.compl_filter]\n  exact one_lt_card_support_of_ne_one h\n\n"}
{"name":"Equiv.Perm.support_conj","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ τ : Equiv.Perm α\n⊢ Eq (HMul.hMul (HMul.hMul σ τ) (Inv.inv σ)).support (Finset.map (Equiv.toEmbedding σ) τ.support)","decl":"@[simp]\ntheorem support_conj : (σ * τ * σ⁻¹).support = τ.support.map σ.toEmbedding := by\n  ext\n  simp only [mem_map_equiv, Perm.coe_mul, Function.comp_apply, Ne, Perm.mem_support,\n    Equiv.eq_symm_apply, inv_def]\n\n"}
{"name":"Equiv.Perm.card_support_conj","module":"Mathlib.GroupTheory.Perm.Support","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ τ : Equiv.Perm α\n⊢ Eq (HMul.hMul (HMul.hMul σ τ) (Inv.inv σ)).support.card τ.support.card","decl":"theorem card_support_conj : #(σ * τ * σ⁻¹).support = #τ.support := by simp\n\n"}
