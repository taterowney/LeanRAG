{"name":"RingHom.locally_iff_finite","module":"Mathlib.RingTheory.RingHom.Locally","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nR S : Type u\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\n⊢ Iff (RingHom.Locally (fun {R S} [CommRing R] [CommRing S] => P) f) (Exists fun s => Exists fun x => ∀ (t : S), Membership.mem s t → P ((algebraMap S (Localization.Away t)).comp f))","decl":"lemma locally_iff_finite (f : R →+* S) :\n    Locally P f ↔ ∃ (s : Finset S) (_ : Ideal.span (s : Set S) = ⊤),\n      ∀ t ∈ s, P ((algebraMap S (Localization.Away t)).comp f) := by\n  constructor\n  · intro ⟨s, hsone, hs⟩\n    obtain ⟨s', h₁, h₂⟩ := (Ideal.span_eq_top_iff_finite s).mp hsone\n    exact ⟨s', h₂, fun t ht ↦ hs t (h₁ ht)⟩\n  · intro ⟨s, hsone, hs⟩\n    use s, hsone, hs\n\n"}
{"name":"RingHom.locally_of_exists","module":"Mathlib.RingTheory.RingHom.Locally","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nR S : Type u\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\nhP : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nf : RingHom R S\nι : Type u_1\ns : ι → S\nhsone : Eq (Ideal.span (Set.range s)) Top.top\nSₜ : ι → Type u\ninst✝² : (i : ι) → CommRing (Sₜ i)\ninst✝¹ : (i : ι) → Algebra S (Sₜ i)\ninst✝ : ∀ (i : ι), IsLocalization.Away (s i) (Sₜ i)\nhf : ∀ (i : ι), P ((algebraMap S (Sₜ i)).comp f)\n⊢ RingHom.Locally (fun {R S} [CommRing R] [CommRing S] => P) f","decl":"/-- If `P` respects isomorphisms, to check `P` holds locally for `f : R →+* S`, it suffices\nto check `P` holds on a standard open cover. -/\nlemma locally_of_exists (hP : RespectsIso P) (f : R →+* S) {ι : Type*} (s : ι → S)\n    (hsone : Ideal.span (Set.range s) = ⊤)\n    (Sₜ : ι → Type u) [∀ i, CommRing (Sₜ i)] [∀ i, Algebra S (Sₜ i)]\n    [∀ i, IsLocalization.Away (s i) (Sₜ i)] (hf : ∀ i, P ((algebraMap S (Sₜ i)).comp f)) :\n    Locally P f := by\n  use Set.range s, hsone\n  rintro - ⟨i, rfl⟩\n  let e : Localization.Away (s i) ≃+* Sₜ i :=\n    (IsLocalization.algEquiv (Submonoid.powers (s i)) _ _).toRingEquiv\n  have : algebraMap S (Localization.Away (s i)) = e.symm.toRingHom.comp (algebraMap S (Sₜ i)) :=\n    RingHom.ext (fun x ↦ (AlgEquiv.commutes (IsLocalization.algEquiv _ _ _).symm _).symm)\n  rw [this, RingHom.comp_assoc]\n  exact hP.left _ _ (hf i)\n\n"}
{"name":"RingHom.locally_iff_exists","module":"Mathlib.RingTheory.RingHom.Locally","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nR S : Type u\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nhP : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nf : RingHom R S\n⊢ Iff (RingHom.Locally (fun {R S} [CommRing R] [CommRing S] => P) f) (Exists fun ι => Exists fun s => Exists fun x => Exists fun Sₜ => Exists fun x => Exists fun x_1 => Exists fun x_2 => ∀ (i : ι), P ((algebraMap S (Sₜ i)).comp f))","decl":"/-- Equivalence variant of `locally_of_exists`. This is sometimes easier to use, if the\n`IsLocalization.Away` instance can't be automatically inferred. -/\nlemma locally_iff_exists (hP : RespectsIso P) (f : R →+* S) :\n    Locally P f ↔ ∃ (ι : Type u) (s : ι → S) (_ : Ideal.span (Set.range s) = ⊤) (Sₜ : ι → Type u)\n      (_ : (i : ι) → CommRing (Sₜ i)) (_ : (i : ι) → Algebra S (Sₜ i))\n      (_ : (i : ι) → IsLocalization.Away (s i : S) (Sₜ i)),\n      ∀ i, P ((algebraMap S (Sₜ i)).comp f) :=\n  ⟨fun ⟨s, hsone, hs⟩ ↦ ⟨s, fun t : s ↦ (t : S), by simpa, fun t ↦ Localization.Away (t : S),\n      inferInstance, inferInstance, inferInstance, fun t ↦ hs t.val t.property⟩,\n    fun ⟨ι, s, hsone, Sₜ, _, _, hislocal, hs⟩ ↦ locally_of_exists hP f s hsone Sₜ hs⟩\n\n"}
{"name":"RingHom.locally_iff_isLocalization","module":"Mathlib.RingTheory.RingHom.Locally","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nR S : Type u\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nhP : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nf : RingHom R S\n⊢ Iff (RingHom.Locally (fun {R S} [CommRing R] [CommRing S] => P) f) (Exists fun s => Exists fun x => ∀ (t : S), Membership.mem s t → ∀ (Sₜ : Type u) [inst : CommRing Sₜ] [inst_1 : Algebra S Sₜ] [inst_2 : IsLocalization.Away t Sₜ], P ((algebraMap S Sₜ).comp f))","decl":"/-- In the definition of `Locally` we may replace `Localization.Away` with an arbitrary\nalgebra satisfying `IsLocalization.Away`. -/\nlemma locally_iff_isLocalization (hP : RespectsIso P) (f : R →+* S) :\n    Locally P f ↔ ∃ (s : Finset S) (_ : Ideal.span (s : Set S) = ⊤),\n      ∀ t ∈ s, ∀ (Sₜ : Type u) [CommRing Sₜ] [Algebra S Sₜ] [IsLocalization.Away t Sₜ],\n      P ((algebraMap S Sₜ).comp f) := by\n  rw [locally_iff_finite P f]\n  refine ⟨fun ⟨s, hsone, hs⟩ ↦ ⟨s, hsone, fun t ht Sₜ _ _ _ ↦ ?_⟩, fun ⟨s, hsone, hs⟩ ↦ ?_⟩\n  · let e : Localization.Away t ≃+* Sₜ :=\n      (IsLocalization.algEquiv (Submonoid.powers t) _ _).toRingEquiv\n    have : algebraMap S Sₜ = e.toRingHom.comp (algebraMap S (Localization.Away t)) :=\n      RingHom.ext (fun x ↦ (AlgEquiv.commutes (IsLocalization.algEquiv _ _ _) _).symm)\n    rw [this, RingHom.comp_assoc]\n    exact hP.left _ _ (hs t ht)\n  · exact ⟨s, hsone, fun t ht ↦ hs t ht _⟩\n\n"}
{"name":"RingHom.locally_of","module":"Mathlib.RingTheory.RingHom.Locally","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nR S : Type u\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nhP : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nf : RingHom R S\nhf : P f\n⊢ RingHom.Locally (fun {R S} [CommRing R] [CommRing S] => P) f","decl":"/-- If `f` satisfies `P`, then in particular it satisfies `Locally P`. -/\nlemma locally_of (hP : RespectsIso P) (f : R →+* S) (hf : P f) : Locally P f := by\n  use {1}\n  let e : S ≃+* Localization.Away (1 : S) :=\n    (IsLocalization.atUnits S (Submonoid.powers 1) (by simp)).toRingEquiv\n  simp only [Set.mem_singleton_iff, forall_eq, Ideal.span_singleton_one, exists_const]\n  exact hP.left f e hf\n\n"}
{"name":"RingHom.locally_of_locally","module":"Mathlib.RingTheory.RingHom.Locally","initialProofState":"P Q : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhPQ : ∀ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] {f : RingHom R S}, P f → Q f\nR S : Type u\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nhf : RingHom.Locally (fun {R S} [CommRing R] [CommRing S] => P) f\n⊢ RingHom.Locally (fun {R S} [CommRing R] [CommRing S] => Q) f","decl":"lemma locally_of_locally {Q : ∀ {R S : Type u} [CommRing R] [CommRing S], (R →+* S) → Prop}\n    (hPQ : ∀ {R S : Type u} [CommRing R] [CommRing S] {f : R →+* S}, P f → Q f)\n    {R S : Type u} [CommRing R] [CommRing S] {f : R →+* S} (hf : Locally P f) : Locally Q f := by\n  obtain ⟨s, hsone, hs⟩ := hf\n  exact ⟨s, hsone, fun t ht ↦ hPQ (hs t ht)⟩\n\n"}
{"name":"RingHom.locally_iff_of_localizationSpanTarget","module":"Mathlib.RingTheory.RingHom.Locally","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhPi : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nhPs : RingHom.OfLocalizationSpanTarget fun {R S} [CommRing R] [CommRing S] => P\nR S : Type u\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\n⊢ Iff (RingHom.Locally (fun {R S} [CommRing R] [CommRing S] => P) f) (P f)","decl":"/-- If `P` is local on the target, then `Locally P` coincides with `P`. -/\nlemma locally_iff_of_localizationSpanTarget (hPi : RespectsIso P)\n    (hPs : OfLocalizationSpanTarget P) {R S : Type u} [CommRing R] [CommRing S] (f : R →+* S) :\n    Locally P f ↔ P f :=\n  ⟨fun ⟨s, hsone, hs⟩ ↦ hPs f s hsone (fun a ↦ hs a.val a.property), locally_of hPi f⟩\n\n"}
{"name":"RingHom.locally_ofLocalizationSpanTarget","module":"Mathlib.RingTheory.RingHom.Locally","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\n⊢ RingHom.OfLocalizationSpanTarget fun {R S} [CommRing R] [CommRing S] => RingHom.Locally fun {R S} [CommRing R] [CommRing S] => P","decl":"/-- `Locally P` is local on the target. -/\nlemma locally_ofLocalizationSpanTarget (hP : RespectsIso P) :\n    OfLocalizationSpanTarget (Locally P) := by\n  intro R S _ _ f s hsone hs\n  choose t htone ht using hs\n  rw [locally_iff_exists hP]\n  refine ⟨(a : s) × t a, IsLocalization.Away.mulNumerator s t,\n      IsLocalization.Away.span_range_mulNumerator_eq_top hsone htone,\n      fun ⟨a, b⟩ ↦ Localization.Away b.val, inferInstance, inferInstance, fun ⟨a, b⟩ ↦ ?_, ?_⟩\n  · haveI : IsLocalization.Away ((algebraMap S (Localization.Away a.val))\n        (IsLocalization.Away.sec a.val b.val).1) (Localization.Away b.val) := by\n      apply IsLocalization.Away.of_associated (r := b.val)\n      rw [← IsLocalization.Away.sec_spec]\n      apply associated_mul_unit_right\n      rw [map_pow _ _]\n      exact IsUnit.pow _ (IsLocalization.Away.algebraMap_isUnit _)\n    apply IsLocalization.Away.mul' (Localization.Away a.val) (Localization.Away b.val)\n  · intro ⟨a, b⟩\n    rw [IsScalarTower.algebraMap_eq S (Localization.Away a.val) (Localization.Away b.val)]\n    apply ht _ _ b.property\n\n"}
{"name":"RingHom.locally_respectsIso","module":"Mathlib.RingTheory.RingHom.Locally","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhPi : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\n⊢ RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => RingHom.Locally fun {R S} [CommRing R] [CommRing S] => P","decl":"/-- If `P` respects isomorphism, so does `Locally P`. -/\nlemma locally_respectsIso (hPi : RespectsIso P) : RespectsIso (Locally P) where\n  left {R S T} _ _ _ f e := fun ⟨s, hsone, hs⟩ ↦ by\n    refine ⟨e '' s, ?_, ?_⟩\n    · rw [← Ideal.map_span, hsone, Ideal.map_top]\n    · rintro - ⟨a, ha, rfl⟩\n      let e' : Localization.Away a ≃+* Localization.Away (e a) :=\n        IsLocalization.ringEquivOfRingEquiv _ _ e (Submonoid.map_powers e a)\n      have : (algebraMap T (Localization.Away (e a))).comp e.toRingHom =\n          e'.toRingHom.comp (algebraMap S (Localization.Away a)) := by\n        ext x\n        simp [e']\n      rw [← RingHom.comp_assoc, this, RingHom.comp_assoc]\n      apply hPi.left\n      exact hs a ha\n  right {R S T} _ _ _ f e := fun ⟨s, hsone, hs⟩ ↦\n    ⟨s, hsone, fun a ha ↦ (RingHom.comp_assoc _ _ _).symm ▸ hPi.right _ _ (hs a ha)⟩\n\n"}
{"name":"RingHom.locally_holdsForLocalizationAway","module":"Mathlib.RingTheory.RingHom.Locally","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhPa : RingHom.HoldsForLocalizationAway fun {R S} [CommRing R] [CommRing S] => P\n⊢ RingHom.HoldsForLocalizationAway fun {R S} [CommRing R] [CommRing S] => RingHom.Locally fun {R S} [CommRing R] [CommRing S] => P","decl":"/-- If `P` holds for localization away maps, then so does `Locally P`. -/\nlemma locally_holdsForLocalizationAway (hPa : HoldsForLocalizationAway P) :\n    HoldsForLocalizationAway (Locally P) := by\n  introv R _\n  use {1}\n  simp only [Set.mem_singleton_iff, forall_eq, Ideal.span_singleton_one, exists_const]\n  let e : S ≃ₐ[R] (Localization.Away (1 : S)) :=\n    (IsLocalization.atUnits S (Submonoid.powers 1) (by simp)).restrictScalars R\n  haveI : IsLocalization.Away r (Localization.Away (1 : S)) :=\n    IsLocalization.isLocalization_of_algEquiv (Submonoid.powers r) e\n  rw [← IsScalarTower.algebraMap_eq]\n  apply hPa _ r\n\n"}
{"name":"RingHom.locally_stableUnderComposition","module":"Mathlib.RingTheory.RingHom.Locally","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhPi : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nhPl : RingHom.LocalizationPreserves fun {R S} [CommRing R] [CommRing S] => P\nhPc : RingHom.StableUnderComposition fun {R S} [CommRing R] [CommRing S] => P\n⊢ RingHom.StableUnderComposition fun {R S} [CommRing R] [CommRing S] => RingHom.Locally fun {R S} [CommRing R] [CommRing S] => P","decl":"/-- If `P` preserves localizations, then `Locally P` is stable under composition if `P` is. -/\nlemma locally_stableUnderComposition (hPi : RespectsIso P) (hPl : LocalizationPreserves P)\n    (hPc : StableUnderComposition P) :\n    StableUnderComposition (Locally P) := by\n  classical\n  intro R S T _ _ _ f g hf hg\n  rw [locally_iff_finite] at hf hg\n  obtain ⟨sf, hsfone, hsf⟩ := hf\n  obtain ⟨sg, hsgone, hsg⟩ := hg\n  rw [locally_iff_exists hPi]\n  refine ⟨sf × sg, fun (a, b) ↦ g a * b, ?_,\n      fun (a, b) ↦ Localization.Away ((algebraMap T (Localization.Away b.val)) (g a.val)),\n      inferInstance, inferInstance, inferInstance, ?_⟩\n  · rw [eq_top_iff, ← hsgone, Ideal.span_le]\n    intro t ht\n    have : 1 ∈ Ideal.span (Set.range <| fun a : sf ↦ a.val) := by simp [hsfone]\n    simp only [mem_ideal_span_range_iff_exists_fun, SetLike.mem_coe] at this ⊢\n    obtain ⟨cf, hcf⟩ := this\n    let cg : sg → T := Pi.single ⟨t, ht⟩ 1\n    use fun (a, b) ↦ g (cf a) * cg b\n    simp [cg, Pi.single_apply, Fintype.sum_prod_type, ← mul_assoc, ← Finset.sum_mul, ← map_mul,\n      ← map_sum, hcf] at hcf ⊢\n  · intro ⟨a, b⟩\n    let g' := (algebraMap T (Localization.Away b.val)).comp g\n    let a' := (algebraMap T (Localization.Away b.val)) (g a.val)\n    have : (algebraMap T <| Localization.Away a').comp (g.comp f) =\n        (Localization.awayMap g' a.val).comp ((algebraMap S (Localization.Away a.val)).comp f) := by\n      ext x\n      simp only [coe_comp, Function.comp_apply, a']\n      change _ = Localization.awayMap g' a.val (algebraMap S _ (f x))\n      simp only [Localization.awayMap, IsLocalization.Away.map, IsLocalization.map_eq]\n      rfl\n    simp only [this, a']\n    apply hPc _ _ (hsf a.val a.property)\n    apply @hPl _ _ _ _ g' _ _ _ _ _ _ _ _ ?_ (hsg b.val b.property)\n    exact IsLocalization.Away.instMapRingHomPowersOfCoe (Localization.Away (g' a.val)) a.val\n\n"}
{"name":"RingHom.locally_StableUnderCompositionWithLocalizationAwayTarget","module":"Mathlib.RingTheory.RingHom.Locally","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP0 : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nhPa : RingHom.StableUnderCompositionWithLocalizationAwayTarget fun {R S} [CommRing R] [CommRing S] => P\n⊢ RingHom.StableUnderCompositionWithLocalizationAwayTarget fun {R S} [CommRing R] [CommRing S] => RingHom.Locally fun {R S} [CommRing R] [CommRing S] => P","decl":"/-- If `P` is stable under composition with localization away maps on the right,\nthen so is `Locally P`. -/\nlemma locally_StableUnderCompositionWithLocalizationAwayTarget\n    (hP0 : RespectsIso P)\n    (hPa : StableUnderCompositionWithLocalizationAwayTarget P) :\n    StableUnderCompositionWithLocalizationAwayTarget (Locally P) := by\n  intro R S T _ _ _ _ t _ f hf\n  simp only [locally_iff_isLocalization hP0 f] at hf\n  obtain ⟨s, hsone, hs⟩ := hf\n  refine ⟨algebraMap S T '' s, ?_, ?_⟩\n  · rw [← Ideal.map_span, hsone, Ideal.map_top]\n  · rintro - ⟨a, ha, rfl⟩\n    letI : Algebra (Localization.Away a) (Localization.Away (algebraMap S T a)) :=\n      (IsLocalization.Away.map _ _ (algebraMap S T) a).toAlgebra\n    have : (algebraMap (Localization.Away a) (Localization.Away (algebraMap S T a))).comp\n        (algebraMap S (Localization.Away a)) =\n        (algebraMap T (Localization.Away (algebraMap S T a))).comp (algebraMap S T) := by\n      simp [algebraMap_toAlgebra, IsLocalization.Away.map]\n    rw [← comp_assoc, ← this, comp_assoc]\n    haveI : IsScalarTower S (Localization.Away a) (Localization.Away ((algebraMap S T) a)) := by\n      apply IsScalarTower.of_algebraMap_eq\n      intro x\n      simp [algebraMap_toAlgebra, IsLocalization.Away.map, ← IsScalarTower.algebraMap_apply]\n    haveI : IsLocalization.Away (algebraMap S (Localization.Away a) t)\n        (Localization.Away (algebraMap S T a)) :=\n      IsLocalization.Away.commutes _ T ((Localization.Away (algebraMap S T a))) a t\n    apply hPa _ (algebraMap S (Localization.Away a) t)\n    apply hs a ha\n\n"}
{"name":"RingHom.locally_StableUnderCompositionWithLocalizationAwaySource","module":"Mathlib.RingTheory.RingHom.Locally","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhPa : RingHom.StableUnderCompositionWithLocalizationAwaySource fun {R S} [CommRing R] [CommRing S] => P\n⊢ RingHom.StableUnderCompositionWithLocalizationAwaySource fun {R S} [CommRing R] [CommRing S] => RingHom.Locally fun {R S} [CommRing R] [CommRing S] => P","decl":"/-- If `P` is stable under composition with localization away maps on the left,\nthen so is `Locally P`. -/\nlemma locally_StableUnderCompositionWithLocalizationAwaySource\n    (hPa : StableUnderCompositionWithLocalizationAwaySource P) :\n    StableUnderCompositionWithLocalizationAwaySource (Locally P) := by\n  intro R S T _ _ _ _ r _ f ⟨s, hsone, hs⟩\n  refine ⟨s, hsone, fun t ht ↦ ?_⟩\n  rw [← comp_assoc]\n  exact hPa _ r _ (hs t ht)\n\n"}
{"name":"RingHom.locally_isStableUnderBaseChange","module":"Mathlib.RingTheory.RingHom.Locally","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhPi : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nhPb : RingHom.IsStableUnderBaseChange fun {R S} [CommRing R] [CommRing S] => P\n⊢ RingHom.IsStableUnderBaseChange fun {R S} [CommRing R] [CommRing S] => RingHom.Locally fun {R S} [CommRing R] [CommRing S] => P","decl":"attribute [local instance] Algebra.TensorProduct.rightAlgebra in\n/-- If `P` is stable under base change, then so is `Locally P`. -/\nlemma locally_isStableUnderBaseChange (hPi : RespectsIso P) (hPb : IsStableUnderBaseChange P) :\n    IsStableUnderBaseChange (Locally P) := by\n  apply IsStableUnderBaseChange.mk _ (locally_respectsIso hPi)\n  introv hf\n  obtain ⟨s, hsone, hs⟩ := hf\n  rw [locally_iff_exists hPi]\n  letI (a : s) : Algebra (S ⊗[R] T) (S ⊗[R] Localization.Away a.val) :=\n    (Algebra.TensorProduct.map (AlgHom.id R S) (IsScalarTower.toAlgHom R _ _)).toRingHom.toAlgebra\n  letI (a : s) : Algebra T (S ⊗[R] Localization.Away a.val) :=\n    ((algebraMap _ (S ⊗[R] Localization.Away a.val)).comp (algebraMap T (S ⊗[R] T))).toAlgebra\n  haveI (a : s) : IsScalarTower T (S ⊗[R] T) (S ⊗[R] Localization.Away a.val) :=\n    IsScalarTower.of_algebraMap_eq' rfl\n  haveI (a : s) : IsScalarTower T (Localization.Away a.val) (S ⊗[R] Localization.Away a.val) :=\n    IsScalarTower.of_algebraMap_eq' rfl\n  haveI (a : s) : IsScalarTower S (S ⊗[R] T) (S ⊗[R] Localization.Away a.val) :=\n      IsScalarTower.of_algebraMap_eq <| by\n    intro x\n    simp [RingHom.algebraMap_toAlgebra]\n  haveI (a : s) : Algebra.IsPushout T (Localization.Away a.val) (S ⊗[R] T)\n      (S ⊗[R] Localization.Away a.val) := by\n    rw [← Algebra.IsPushout.comp_iff (R := R) (R' := S)]\n    infer_instance\n  refine ⟨s, fun a ↦ Algebra.TensorProduct.includeRight a.val, ?_,\n      fun a ↦ (S ⊗[R] Localization.Away a.val), inferInstance, inferInstance, ?_, ?_⟩\n  · rw [← Set.image_eq_range, ← Ideal.map_span, hsone, Ideal.map_top]\n  · intro a\n    convert_to IsLocalization (Algebra.algebraMapSubmonoid (S ⊗[R] T) (Submonoid.powers a.val))\n        (S ⊗[R] Localization.Away a.val)\n    · simp only [Algebra.TensorProduct.includeRight_apply, Algebra.algebraMapSubmonoid,\n        Submonoid.map_powers]\n      rfl\n    · rw [← isLocalizedModule_iff_isLocalization, isLocalizedModule_iff_isBaseChange\n        (S := Submonoid.powers a.val) (A := Localization.Away a.val)]\n      exact Algebra.IsPushout.out\n  · intro a\n    have : (algebraMap (S ⊗[R] T) (S ⊗[R] Localization.Away a.val)).comp\n        Algebra.TensorProduct.includeLeftRingHom =\n        Algebra.TensorProduct.includeLeftRingHom := by\n      ext x\n      simp [RingHom.algebraMap_toAlgebra]\n    rw [this]\n    apply hPb R (Localization.Away a.val)\n    rw [IsScalarTower.algebraMap_eq R T (Localization.Away a.val)]\n    apply hs a a.property\n\n"}
{"name":"RingHom.locally_localizationAwayPreserves","module":"Mathlib.RingTheory.RingHom.Locally","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhPl : RingHom.LocalizationAwayPreserves fun {R S} [CommRing R] [CommRing S] => P\n⊢ RingHom.LocalizationAwayPreserves fun {R S} [CommRing R] [CommRing S] => RingHom.Locally fun {R S} [CommRing R] [CommRing S] => P","decl":"/-- If `P` is preserved by localization away, then so is `Locally P`. -/\nlemma locally_localizationAwayPreserves (hPl : LocalizationAwayPreserves P) :\n    LocalizationAwayPreserves (Locally P) := by\n  introv R hf\n  obtain ⟨s, hsone, hs⟩ := hf\n  rw [locally_iff_exists hPl.respectsIso]\n  let rₐ (a : s) : Localization.Away a.val := algebraMap _ _ (f r)\n  let Sₐ (a : s) := Localization.Away (rₐ a)\n  haveI (a : s) :\n      IsLocalization.Away (((algebraMap S (Localization.Away a.val)).comp f) r) (Sₐ a) :=\n    inferInstanceAs (IsLocalization.Away (rₐ a) (Sₐ a))\n  haveI (a : s) : IsLocalization (Algebra.algebraMapSubmonoid (Localization.Away a.val)\n    (Submonoid.map f (Submonoid.powers r))) (Sₐ a) := by\n    convert inferInstanceAs (IsLocalization.Away (rₐ a) (Sₐ a))\n    simp [rₐ, Sₐ, Algebra.algebraMapSubmonoid]\n  have H (a : s) : Submonoid.powers (f r) ≤\n      (Submonoid.powers (rₐ a)).comap (algebraMap S (Localization.Away a.val)) := by\n    simp [rₐ, Sₐ, Submonoid.powers_le]\n  letI (a : s) : Algebra S' (Sₐ a) :=\n    (IsLocalization.map (Sₐ a) (algebraMap S (Localization.Away a.val)) (H a)).toAlgebra\n  haveI (a : s) : IsScalarTower S S' (Sₐ a) :=\n    IsScalarTower.of_algebraMap_eq' (IsLocalization.map_comp (H a)).symm\n  refine ⟨s, fun a ↦ algebraMap S S' a.val, ?_, Sₐ,\n      inferInstance, inferInstance, fun a ↦ ?_, fun a ↦ ?_⟩\n  · rw [← Set.image_eq_range, ← Ideal.map_span, hsone, Ideal.map_top]\n  · convert IsLocalization.commutes (T := Sₐ a) (M₁ := (Submonoid.powers r).map f) (S₁ := S')\n      (S₂ := Localization.Away a.val) (M₂ := Submonoid.powers a.val)\n    simp [Algebra.algebraMapSubmonoid]\n  · rw [algebraMap_toAlgebra, IsLocalization.Away.map, IsLocalization.map_comp_map]\n    exact hPl ((algebraMap _ (Localization.Away a.val)).comp f) r R' (Sₐ a) (hs _ a.2)\n\n"}
{"name":"RingHom.locally_localizationPreserves","module":"Mathlib.RingTheory.RingHom.Locally","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhPl : RingHom.LocalizationPreserves fun {R S} [CommRing R] [CommRing S] => P\n⊢ RingHom.LocalizationPreserves fun {R S} [CommRing R] [CommRing S] => RingHom.Locally fun {R S} [CommRing R] [CommRing S] => P","decl":"/-- If `P` is preserved by localizations, then so is `Locally P`. -/\nlemma locally_localizationPreserves (hPl : LocalizationPreserves P) :\n    LocalizationPreserves (Locally P) := by\n  introv R hf\n  obtain ⟨s, hsone, hs⟩ := hf\n  rw [locally_iff_exists hPl.away.respectsIso]\n  let Mₐ (a : s) : Submonoid (Localization.Away a.val) :=\n    (M.map f).map (algebraMap S (Localization.Away a.val))\n  let Sₐ (a : s) := Localization (Mₐ a)\n  have hM (a : s) : M.map ((algebraMap S (Localization.Away a.val)).comp f) = Mₐ a :=\n    (M.map_map _ _).symm\n  haveI (a : s) :\n      IsLocalization (M.map ((algebraMap S (Localization.Away a.val)).comp f)) (Sₐ a) := by\n    rw [hM]\n    infer_instance\n  haveI (a : s) :\n      IsLocalization (Algebra.algebraMapSubmonoid (Localization.Away a.val) (M.map f)) (Sₐ a) :=\n    inferInstanceAs <| IsLocalization (Mₐ a) (Sₐ a)\n  letI (a : s) : Algebra S' (Sₐ a) :=\n    (IsLocalization.map (Sₐ a) (algebraMap S (Localization.Away a.val))\n      (M.map f).le_comap_map).toAlgebra\n  haveI (a : s) : IsScalarTower S S' (Sₐ a) :=\n    IsScalarTower.of_algebraMap_eq' (IsLocalization.map_comp (M.map f).le_comap_map).symm\n  refine ⟨s, fun a ↦ algebraMap S S' a.val, ?_, Sₐ,\n      inferInstance, inferInstance, fun a ↦ ?_, fun a ↦ ?_⟩\n  · rw [← Set.image_eq_range, ← Ideal.map_span, hsone, Ideal.map_top]\n  · convert IsLocalization.commutes (T := Sₐ a) (M₁ := M.map f) (S₁ := S')\n      (S₂ := Localization.Away a.val) (M₂ := Submonoid.powers a.val)\n    simp [Algebra.algebraMapSubmonoid]\n  · rw [algebraMap_toAlgebra, IsLocalization.map_comp_map]\n    apply hPl\n    exact hs a.val a.property\n\n"}
{"name":"RingHom.locally_propertyIsLocal","module":"Mathlib.RingTheory.RingHom.Locally","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhPl : RingHom.LocalizationAwayPreserves fun {R S} [CommRing R] [CommRing S] => P\nhPa : RingHom.StableUnderCompositionWithLocalizationAway fun {R S} [CommRing R] [CommRing S] => P\n⊢ RingHom.PropertyIsLocal fun {R S} [CommRing R] [CommRing S] => RingHom.Locally fun {R S} [CommRing R] [CommRing S] => P","decl":"/-- If `P` is preserved by localizations and stable under composition with localization\naway maps, then `Locally P` is a local property of ring homomorphisms. -/\nlemma locally_propertyIsLocal (hPl : LocalizationAwayPreserves P)\n    (hPa : StableUnderCompositionWithLocalizationAway P) : PropertyIsLocal (Locally P) where\n  localizationAwayPreserves := locally_localizationAwayPreserves hPl\n  StableUnderCompositionWithLocalizationAwayTarget :=\n    locally_StableUnderCompositionWithLocalizationAwayTarget hPl.respectsIso hPa.right\n  ofLocalizationSpan := (locally_ofLocalizationSpanTarget hPl.respectsIso).ofLocalizationSpan\n    (locally_StableUnderCompositionWithLocalizationAwaySource hPa.left)\n  ofLocalizationSpanTarget := locally_ofLocalizationSpanTarget hPl.respectsIso\n\n"}
