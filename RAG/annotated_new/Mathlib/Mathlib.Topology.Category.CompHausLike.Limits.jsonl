{"name":"CompHausLike.finiteCoproduct.ι_desc","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nα : Type w\ninst✝¹ : Finite α\nX : α → CompHausLike P\ninst✝ : CompHausLike.HasExplicitFiniteCoproduct X\nB : CompHausLike P\ne : (a : α) → Quiver.Hom (X a) B\na : α\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CompHausLike.finiteCoproduct.ι X a) (CompHausLike.finiteCoproduct.desc X e)) (e a)","decl":"@[reassoc (attr := simp)]\nlemma finiteCoproduct.ι_desc {B : CompHausLike P} (e : (a : α) → (X a ⟶ B)) (a : α) :\n    finiteCoproduct.ι X a ≫ finiteCoproduct.desc X e = e a := rfl\n\n"}
{"name":"CompHausLike.finiteCoproduct.ι_desc_assoc","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nα : Type w\ninst✝¹ : Finite α\nX : α → CompHausLike P\ninst✝ : CompHausLike.HasExplicitFiniteCoproduct X\nB : CompHausLike P\ne : (a : α) → Quiver.Hom (X a) B\na : α\nZ : CompHausLike P\nh : Quiver.Hom B Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CompHausLike.finiteCoproduct.ι X a) (CategoryTheory.CategoryStruct.comp (CompHausLike.finiteCoproduct.desc X e) h)) (CategoryTheory.CategoryStruct.comp (e a) h)","decl":"@[reassoc (attr := simp)]\nlemma finiteCoproduct.ι_desc {B : CompHausLike P} (e : (a : α) → (X a ⟶ B)) (a : α) :\n    finiteCoproduct.ι X a ≫ finiteCoproduct.desc X e = e a := rfl\n\n"}
{"name":"CompHausLike.finiteCoproduct.hom_ext","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nα : Type w\ninst✝¹ : Finite α\nX : α → CompHausLike P\ninst✝ : CompHausLike.HasExplicitFiniteCoproduct X\nB : CompHausLike P\nf g : Quiver.Hom (CompHausLike.finiteCoproduct X) B\nh : ∀ (a : α), Eq (CategoryTheory.CategoryStruct.comp (CompHausLike.finiteCoproduct.ι X a) f) (CategoryTheory.CategoryStruct.comp (CompHausLike.finiteCoproduct.ι X a) g)\n⊢ Eq f g","decl":"lemma finiteCoproduct.hom_ext {B : CompHausLike P} (f g : finiteCoproduct X ⟶ B)\n    (h : ∀ a : α, finiteCoproduct.ι X a ≫ f = finiteCoproduct.ι X a ≫ g) : f = g := by\n  ext ⟨a, x⟩\n  specialize h a\n  apply_fun (fun q ↦ q x) at h\n  exact h\n\n"}
{"name":"CompHausLike.finiteCoproduct.ι_injective","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nα : Type w\ninst✝¹ : Finite α\nX : α → CompHausLike P\ninst✝ : CompHausLike.HasExplicitFiniteCoproduct X\na : α\n⊢ Function.Injective ⇑(CompHausLike.finiteCoproduct.ι X a)","decl":"lemma finiteCoproduct.ι_injective (a : α) : Function.Injective (finiteCoproduct.ι X a) := by\n  intro x y hxy\n  exact eq_of_heq (Sigma.ext_iff.mp hxy).2\n\n"}
{"name":"CompHausLike.finiteCoproduct.ι_jointly_surjective","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nα : Type w\ninst✝¹ : Finite α\nX : α → CompHausLike P\ninst✝ : CompHausLike.HasExplicitFiniteCoproduct X\nR : ↑(CompHausLike.finiteCoproduct X).toTop\n⊢ Exists fun a => Exists fun r => Eq R ((CompHausLike.finiteCoproduct.ι X a) r)","decl":"lemma finiteCoproduct.ι_jointly_surjective (R : finiteCoproduct X) :\n    ∃ (a : α) (r : X a), R = finiteCoproduct.ι X a r := ⟨R.fst, R.snd, rfl⟩\n\n"}
{"name":"CompHausLike.finiteCoproduct.ι_desc_apply","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nα : Type w\ninst✝¹ : Finite α\nX : α → CompHausLike P\ninst✝ : CompHausLike.HasExplicitFiniteCoproduct X\nB : CompHausLike P\nπ : (a : α) → Quiver.Hom (X a) B\na : α\nx : (CategoryTheory.forget (CompHausLike P)).obj (X a)\n⊢ Eq ((CompHausLike.finiteCoproduct.desc X π) ((CompHausLike.finiteCoproduct.ι X a) x)) ((π a) x)","decl":"lemma finiteCoproduct.ι_desc_apply {B : CompHausLike P} {π : (a : α) → X a ⟶ B} (a : α) :\n    ∀ x, finiteCoproduct.desc X π (finiteCoproduct.ι X a x) = π a x := by\n  intro x\n  change (ι X a ≫ desc X π) _ = _\n  simp only [ι_desc]\n\n"}
{"name":"CompHausLike.instHasCoproduct","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nα : Type w\ninst✝¹ : Finite α\nX : α → CompHausLike P\ninst✝ : CompHausLike.HasExplicitFiniteCoproduct X\n⊢ CategoryTheory.Limits.HasCoproduct X","decl":"instance : HasCoproduct X where\n  exists_colimit := ⟨finiteCoproduct.cofan X, finiteCoproduct.isColimit X⟩\n\n"}
{"name":"CompHausLike.HasExplicitFiniteCoproducts.hasProp","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nself : CompHausLike.HasExplicitFiniteCoproducts P\nα : Type w\ninst✝ : Finite α\nX : α → CompHausLike P\n⊢ CompHausLike.HasExplicitFiniteCoproduct X","decl":"variable (P) in\n/--\nA typeclass describing the property that forming all finite disjoint unions is stable under the\nproperty `P`.\n-/\nclass HasExplicitFiniteCoproducts : Prop where\n  hasProp {α : Type w} [Finite α] (X : α → CompHausLike.{max u w} P) : HasExplicitFiniteCoproduct X\n\n/-\nThis linter complains that the universes `u` and `w` only occur together, but `w` appears by itself\nin the indexing type of the coproduct. In almost all cases, `w` will be either `0` or `u`, but we\nwant to allow both possibilities.\n-/\n"}
{"name":"CompHausLike.instHasColimitsOfShapeDiscreteOfHasExplicitFiniteCoproductsOfFinite","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\ninst✝¹ : CompHausLike.HasExplicitFiniteCoproducts P\nα : Type w\ninst✝ : Finite α\n⊢ CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete α) (CompHausLike P)","decl":"instance [HasExplicitFiniteCoproducts.{w} P] (α : Type w) [Finite α] :\n    HasColimitsOfShape (Discrete α) (CompHausLike P) where\n  has_colimit _ := hasColimitOfIso Discrete.natIsoFunctor\n\n"}
{"name":"CompHausLike.instHasFiniteCoproductsOfHasExplicitFiniteCoproducts","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\ninst✝ : CompHausLike.HasExplicitFiniteCoproducts P\n⊢ CategoryTheory.Limits.HasFiniteCoproducts (CompHausLike P)","decl":"instance [HasExplicitFiniteCoproducts.{w} P] : HasFiniteCoproducts (CompHausLike.{max u w} P) where\n  out n := by\n    let α := ULift.{w} (Fin n)\n    let e : Discrete α ≌ Discrete (Fin n) := Discrete.equivalence Equiv.ulift\n    exact hasColimitsOfShape_of_equivalence e\n\n"}
{"name":"CompHausLike.finiteCoproduct.isOpenEmbedding_ι","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nα : Type w\ninst✝¹ : Finite α\nX : α → CompHausLike P\ninst✝ : CompHausLike.HasExplicitFiniteCoproduct X\na : α\n⊢ Topology.IsOpenEmbedding ⇑(CompHausLike.finiteCoproduct.ι X a)","decl":"/-- The inclusion maps into the explicit finite coproduct are open embeddings. -/\nlemma finiteCoproduct.isOpenEmbedding_ι (a : α) :\n    IsOpenEmbedding (finiteCoproduct.ι X a) :=\n  .sigmaMk (σ := fun a ↦ X a)\n\n"}
{"name":"CompHausLike.finiteCoproduct.openEmbedding_ι","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nα : Type w\ninst✝¹ : Finite α\nX : α → CompHausLike P\ninst✝ : CompHausLike.HasExplicitFiniteCoproduct X\na : α\n⊢ Topology.IsOpenEmbedding ⇑(CompHausLike.finiteCoproduct.ι X a)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias finiteCoproduct.openEmbedding_ι := finiteCoproduct.isOpenEmbedding_ι\n\n"}
{"name":"CompHausLike.Sigma.isOpenEmbedding_ι","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nα : Type w\ninst✝¹ : Finite α\nX : α → CompHausLike P\ninst✝ : CompHausLike.HasExplicitFiniteCoproduct X\na : α\n⊢ Topology.IsOpenEmbedding ⇑(CategoryTheory.Limits.Sigma.ι X a)","decl":"/-- The inclusion maps into the abstract finite coproduct are open embeddings. -/\nlemma Sigma.isOpenEmbedding_ι (a : α) :\n    IsOpenEmbedding (Sigma.ι X a) := by\n  refine IsOpenEmbedding.of_comp _ (homeoOfIso ((colimit.isColimit _).coconePointUniqueUpToIso\n    (finiteCoproduct.isColimit X))).isOpenEmbedding ?_\n  convert finiteCoproduct.isOpenEmbedding_ι X a\n  ext x\n  change (Sigma.ι X a ≫ _) x = _\n  simp\n\n"}
{"name":"CompHausLike.Sigma.openEmbedding_ι","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nα : Type w\ninst✝¹ : Finite α\nX : α → CompHausLike P\ninst✝ : CompHausLike.HasExplicitFiniteCoproduct X\na : α\n⊢ Topology.IsOpenEmbedding ⇑(CategoryTheory.Limits.Sigma.ι X a)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias Sigma.openEmbedding_ι := Sigma.isOpenEmbedding_ι\n\n"}
{"name":"CompHausLike.instPreservesFiniteCoproductsTopCatCompHausLikeToTopOfHasExplicitFiniteCoproducts","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\ninst✝ : CompHausLike.HasExplicitFiniteCoproducts P\n⊢ CategoryTheory.Limits.PreservesFiniteCoproducts (CompHausLike.compHausLikeToTop P)","decl":"/-- The functor to `TopCat` preserves finite coproducts if they exist. -/\ninstance (P) [HasExplicitFiniteCoproducts.{0} P] :\n    PreservesFiniteCoproducts (compHausLikeToTop P) := by\n  refine ⟨fun J hJ ↦ ⟨fun {F} ↦ ?_⟩⟩\n  suffices PreservesColimit (Discrete.functor (F.obj ∘ Discrete.mk)) (compHausLikeToTop P) from\n    preservesColimit_of_iso_diagram _ Discrete.natIsoFunctor.symm\n  apply preservesColimit_of_preserves_colimit_cocone (CompHausLike.finiteCoproduct.isColimit _)\n  exact TopCat.sigmaCofanIsColimit _\n\n"}
{"name":"CompHausLike.instPreservesFiniteCoproductsToCompHausLike","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P P' : TopCat → Prop\nh : ∀ (X : CompHausLike P), P X.toTop → P' X.toTop\n⊢ CategoryTheory.Limits.PreservesFiniteCoproducts (CompHausLike.toCompHausLike h)","decl":"/-- The functor to another `CompHausLike` preserves finite coproducts if they exist. -/\nnoncomputable instance {P' : TopCat.{u} → Prop}\n    (h : ∀ (X : CompHausLike P), P X.toTop → P' X.toTop) :\n    PreservesFiniteCoproducts (toCompHausLike h) := by\n  have : PreservesFiniteCoproducts (toCompHausLike h ⋙ compHausLikeToTop P') :=\n    inferInstanceAs (PreservesFiniteCoproducts (compHausLikeToTop _))\n  exact preservesFiniteCoproducts_of_reflects_of_preserves (toCompHausLike h) (compHausLikeToTop P')\n\n"}
{"name":"CompHausLike.pullback.condition","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nX Y B : CompHausLike P\nf : Quiver.Hom X B\ng : Quiver.Hom Y B\ninst✝ : CompHausLike.HasExplicitPullback f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CompHausLike.pullback.fst f g) f) (CategoryTheory.CategoryStruct.comp (CompHausLike.pullback.snd f g) g)","decl":"@[reassoc]\nlemma pullback.condition : pullback.fst f g ≫ f = pullback.snd f g ≫ g := by\n  ext ⟨_,h⟩; exact h\n\n"}
{"name":"CompHausLike.pullback.condition_assoc","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nX Y B : CompHausLike P\nf : Quiver.Hom X B\ng : Quiver.Hom Y B\ninst✝ : CompHausLike.HasExplicitPullback f g\nZ : CompHausLike P\nh : Quiver.Hom B Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CompHausLike.pullback.fst f g) (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp (CompHausLike.pullback.snd f g) (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc]\nlemma pullback.condition : pullback.fst f g ≫ f = pullback.snd f g ≫ g := by\n  ext ⟨_,h⟩; exact h\n\n"}
{"name":"CompHausLike.pullback.lift_fst","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nX Y B : CompHausLike P\nf : Quiver.Hom X B\ng : Quiver.Hom Y B\ninst✝ : CompHausLike.HasExplicitPullback f g\nZ : CompHausLike P\na : Quiver.Hom Z X\nb : Quiver.Hom Z Y\nw : Eq (CategoryTheory.CategoryStruct.comp a f) (CategoryTheory.CategoryStruct.comp b g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CompHausLike.pullback.lift f g a b w) (CompHausLike.pullback.fst f g)) a","decl":"@[reassoc (attr := simp)]\nlemma pullback.lift_fst {Z : CompHausLike P} (a : Z ⟶ X) (b : Z ⟶ Y) (w : a ≫ f = b ≫ g) :\n    pullback.lift f g a b w ≫ pullback.fst f g = a := rfl\n\n"}
{"name":"CompHausLike.pullback.lift_fst_assoc","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nX Y B : CompHausLike P\nf : Quiver.Hom X B\ng : Quiver.Hom Y B\ninst✝ : CompHausLike.HasExplicitPullback f g\nZ✝ : CompHausLike P\na : Quiver.Hom Z✝ X\nb : Quiver.Hom Z✝ Y\nw : Eq (CategoryTheory.CategoryStruct.comp a f) (CategoryTheory.CategoryStruct.comp b g)\nZ : CompHausLike P\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CompHausLike.pullback.lift f g a b w) (CategoryTheory.CategoryStruct.comp (CompHausLike.pullback.fst f g) h)) (CategoryTheory.CategoryStruct.comp a h)","decl":"@[reassoc (attr := simp)]\nlemma pullback.lift_fst {Z : CompHausLike P} (a : Z ⟶ X) (b : Z ⟶ Y) (w : a ≫ f = b ≫ g) :\n    pullback.lift f g a b w ≫ pullback.fst f g = a := rfl\n\n"}
{"name":"CompHausLike.pullback.lift_snd","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nX Y B : CompHausLike P\nf : Quiver.Hom X B\ng : Quiver.Hom Y B\ninst✝ : CompHausLike.HasExplicitPullback f g\nZ : CompHausLike P\na : Quiver.Hom Z X\nb : Quiver.Hom Z Y\nw : Eq (CategoryTheory.CategoryStruct.comp a f) (CategoryTheory.CategoryStruct.comp b g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CompHausLike.pullback.lift f g a b w) (CompHausLike.pullback.snd f g)) b","decl":"@[reassoc (attr := simp)]\nlemma pullback.lift_snd {Z : CompHausLike P} (a : Z ⟶ X) (b : Z ⟶ Y) (w : a ≫ f = b ≫ g) :\n    pullback.lift f g a b w ≫ pullback.snd f g = b := rfl\n\n"}
{"name":"CompHausLike.pullback.lift_snd_assoc","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nX Y B : CompHausLike P\nf : Quiver.Hom X B\ng : Quiver.Hom Y B\ninst✝ : CompHausLike.HasExplicitPullback f g\nZ✝ : CompHausLike P\na : Quiver.Hom Z✝ X\nb : Quiver.Hom Z✝ Y\nw : Eq (CategoryTheory.CategoryStruct.comp a f) (CategoryTheory.CategoryStruct.comp b g)\nZ : CompHausLike P\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CompHausLike.pullback.lift f g a b w) (CategoryTheory.CategoryStruct.comp (CompHausLike.pullback.snd f g) h)) (CategoryTheory.CategoryStruct.comp b h)","decl":"@[reassoc (attr := simp)]\nlemma pullback.lift_snd {Z : CompHausLike P} (a : Z ⟶ X) (b : Z ⟶ Y) (w : a ≫ f = b ≫ g) :\n    pullback.lift f g a b w ≫ pullback.snd f g = b := rfl\n\n"}
{"name":"CompHausLike.pullback.hom_ext","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nX Y B : CompHausLike P\nf : Quiver.Hom X B\ng : Quiver.Hom Y B\ninst✝ : CompHausLike.HasExplicitPullback f g\nZ : CompHausLike P\na b : Quiver.Hom Z (CompHausLike.pullback f g)\nhfst : Eq (CategoryTheory.CategoryStruct.comp a (CompHausLike.pullback.fst f g)) (CategoryTheory.CategoryStruct.comp b (CompHausLike.pullback.fst f g))\nhsnd : Eq (CategoryTheory.CategoryStruct.comp a (CompHausLike.pullback.snd f g)) (CategoryTheory.CategoryStruct.comp b (CompHausLike.pullback.snd f g))\n⊢ Eq a b","decl":"lemma pullback.hom_ext {Z : CompHausLike P} (a b : Z ⟶ pullback f g)\n    (hfst : a ≫ pullback.fst f g = b ≫ pullback.fst f g)\n    (hsnd : a ≫ pullback.snd f g = b ≫ pullback.snd f g) : a = b := by\n  ext z\n  apply_fun (fun q ↦ q z) at hfst hsnd\n  apply Subtype.ext\n  apply Prod.ext\n  · exact hfst\n  · exact hsnd\n\n"}
{"name":"CompHausLike.pullback.cone_pt","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nX Y B : CompHausLike P\nf : Quiver.Hom X B\ng : Quiver.Hom Y B\ninst✝ : CompHausLike.HasExplicitPullback f g\n⊢ Eq (CompHausLike.pullback.cone f g).pt (CompHausLike.pullback f g)","decl":"/--\nThe pullback cone whose cone point is the explicit pullback.\n-/\n@[simps! pt π]\ndef pullback.cone : Limits.PullbackCone f g :=\n  Limits.PullbackCone.mk (pullback.fst f g) (pullback.snd f g) (pullback.condition f g)\n\n"}
{"name":"CompHausLike.pullback.cone_π","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nX Y B : CompHausLike P\nf : Quiver.Hom X B\ng : Quiver.Hom Y B\ninst✝ : CompHausLike.HasExplicitPullback f g\n⊢ Eq (CompHausLike.pullback.cone f g).π { app := fun j => Option.rec (CategoryTheory.CategoryStruct.comp (CompHausLike.pullback.fst f g) f) (fun val => CategoryTheory.Limits.WalkingPair.rec (CompHausLike.pullback.fst f g) (CompHausLike.pullback.snd f g) val) j, naturality := ⋯ }","decl":"/--\nThe pullback cone whose cone point is the explicit pullback.\n-/\n@[simps! pt π]\ndef pullback.cone : Limits.PullbackCone f g :=\n  Limits.PullbackCone.mk (pullback.fst f g) (pullback.snd f g) (pullback.condition f g)\n\n"}
{"name":"CompHausLike.pullback.isLimit_lift","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nX Y B : CompHausLike P\nf : Quiver.Hom X B\ng : Quiver.Hom Y B\ninst✝ : CompHausLike.HasExplicitPullback f g\ns : CategoryTheory.Limits.PullbackCone f g\n⊢ Eq ((CompHausLike.pullback.isLimit f g).lift s) (CompHausLike.pullback.lift f g s.fst s.snd ⋯)","decl":"/--\nThe explicit pullback cone is a limit cone.\n-/\n@[simps! lift]\ndef pullback.isLimit : Limits.IsLimit (pullback.cone f g) :=\n  Limits.PullbackCone.isLimitAux _\n    (fun s ↦ pullback.lift f g s.fst s.snd s.condition)\n    (fun _ ↦ pullback.lift_fst _ _ _ _ _)\n    (fun _ ↦ pullback.lift_snd _ _ _ _ _)\n    (fun _ _ hm ↦ pullback.hom_ext _ _ _ _ (hm .left) (hm .right))\n\n"}
{"name":"CompHausLike.instHasLimitWalkingCospanCospan","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nX Y B : CompHausLike P\nf : Quiver.Hom X B\ng : Quiver.Hom Y B\ninst✝ : CompHausLike.HasExplicitPullback f g\n⊢ CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan f g)","decl":"instance : HasLimit (cospan f g) where\n  exists_limit := ⟨⟨pullback.cone f g, pullback.isLimit f g⟩⟩\n\n"}
{"name":"CompHausLike.instPreservesLimitTopCatWalkingCospanCospanCompHausLikeToTop","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nX Y B : CompHausLike P\nf : Quiver.Hom X B\ng : Quiver.Hom Y B\ninst✝ : CompHausLike.HasExplicitPullback f g\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) (CompHausLike.compHausLikeToTop P)","decl":"/-- The functor to `TopCat` preserves pullbacks. -/\nnoncomputable instance : PreservesLimit (cospan f g) (compHausLikeToTop P) :=\n  preservesLimit_of_createsLimit_and_hasLimit _ _\n\n"}
{"name":"CompHausLike.instPreservesLimitWalkingCospanCospanToCompHausLike","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nX Y B : CompHausLike P\nf : Quiver.Hom X B\ng : Quiver.Hom Y B\nP' : TopCat → Prop\nh : ∀ (X : CompHausLike P), P X.toTop → P' X.toTop\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) (CompHausLike.toCompHausLike h)","decl":"/-- The functor to another `CompHausLike` preserves pullbacks. -/\nnoncomputable instance {P' : TopCat → Prop}\n    (h : ∀ (X : CompHausLike P), P X.toTop → P' X.toTop) :\n    PreservesLimit (cospan f g) (toCompHausLike h) := by\n  have : PreservesLimit (cospan f g) (toCompHausLike h ⋙ compHausLikeToTop P') :=\n    inferInstanceAs (PreservesLimit _ (compHausLikeToTop _))\n  exact preservesLimit_of_reflects_of_preserves (toCompHausLike h) (compHausLikeToTop P')\n\n"}
{"name":"CompHausLike.HasExplicitPullbacks.hasProp","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\nself : CompHausLike.HasExplicitPullbacks P\nX Y B : CompHausLike P\nf : Quiver.Hom X B\ng : Quiver.Hom Y B\n⊢ CompHausLike.HasExplicitPullback f g","decl":"variable (P) in\n/--\nA typeclass describing the property that forming all explicit pullbacks is stable under the\nproperty `P`.\n-/\nclass HasExplicitPullbacks : Prop where\n  hasProp {X Y B : CompHausLike P} (f : X ⟶ B) (g : Y ⟶ B) : HasExplicitPullback f g\n\n"}
{"name":"CompHausLike.instHasPullbacksOfHasExplicitPullbacks","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\ninst✝ : CompHausLike.HasExplicitPullbacks P\n⊢ CategoryTheory.Limits.HasPullbacks (CompHausLike P)","decl":"instance [HasExplicitPullbacks P] : HasPullbacks (CompHausLike P) where\n  has_limit F := hasLimitOfIso (diagramIsoCospan F).symm\n\n"}
{"name":"CompHausLike.HasExplicitPullbacksOfInclusions.hasProp","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\ninst✝ : CompHausLike.HasExplicitFiniteCoproducts P\nself : CompHausLike.HasExplicitPullbacksOfInclusions P\nX Y Z : CompHausLike P\nf : Quiver.Hom Z (CategoryTheory.Limits.coprod X Y)\n⊢ CompHausLike.HasExplicitPullback CategoryTheory.Limits.coprod.inl f","decl":"variable (P) in\n/--\nA typeclass describing the property that explicit pullbacks along inclusion maps into disjoint\nunions is stable under the property `P`.\n-/\nclass HasExplicitPullbacksOfInclusions [HasExplicitFiniteCoproducts.{0} P] : Prop where\n  hasProp : ∀ {X Y Z : CompHausLike P} (f : Z ⟶ X ⨿ Y), HasExplicitPullback coprod.inl f\n\n"}
{"name":"CompHausLike.instHasExplicitPullbacksOfInclusionsOfHasExplicitPullbacks","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\ninst✝¹ : CompHausLike.HasExplicitPullbacks P\ninst✝ : CompHausLike.HasExplicitFiniteCoproducts P\n⊢ CompHausLike.HasExplicitPullbacksOfInclusions P","decl":"instance [HasExplicitPullbacks P] [HasExplicitFiniteCoproducts.{0} P] :\n    HasExplicitPullbacksOfInclusions P where\n  hasProp _ := inferInstance\n\n"}
{"name":"CompHausLike.instHasPullbacksOfInclusionsOfHasExplicitPullbacksOfInclusions","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\ninst✝¹ : CompHausLike.HasExplicitFiniteCoproducts P\ninst✝ : CompHausLike.HasExplicitPullbacksOfInclusions P\n⊢ CategoryTheory.HasPullbacksOfInclusions (CompHausLike P)","decl":"instance [HasExplicitPullbacksOfInclusions P] : HasPullbacksOfInclusions (CompHausLike P) where\n  hasPullbackInl _ := inferInstance\n\n"}
{"name":"CompHausLike.hasPullbacksOfInclusions","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\ninst✝ : CompHausLike.HasExplicitFiniteCoproducts P\nhP' : ∀ ⦃X Y B : CompHausLike P⦄ (f : Quiver.Hom X B) (g : Quiver.Hom Y B), Topology.IsOpenEmbedding ⇑f → CompHausLike.HasExplicitPullback f g\n⊢ CompHausLike.HasExplicitPullbacksOfInclusions P","decl":"theorem hasPullbacksOfInclusions\n    (hP' : ∀ ⦃X Y B : CompHausLike.{u} P⦄ (f : X ⟶ B) (g : Y ⟶ B)\n      (_ : IsOpenEmbedding f), HasExplicitPullback f g) :\n    HasExplicitPullbacksOfInclusions P :=\n  { hasProp := by\n      intro _ _ _ f\n      apply hP'\n      exact Sigma.isOpenEmbedding_ι _ _ }\n\n"}
{"name":"CompHausLike.instPreservesPullbacksOfInclusionsTopCatCompHausLikeToTopOfHasExplicitPullbacksOfInclusions","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\ninst✝¹ : CompHausLike.HasExplicitFiniteCoproducts P\ninst✝ : CompHausLike.HasExplicitPullbacksOfInclusions P\n⊢ CategoryTheory.PreservesPullbacksOfInclusions (CompHausLike.compHausLikeToTop P)","decl":"/-- The functor to `TopCat` preserves pullbacks of inclusions if they exist. -/\nnoncomputable instance [HasExplicitPullbacksOfInclusions P] :\n    PreservesPullbacksOfInclusions (compHausLikeToTop P) :=\n  { preservesPullbackInl := by\n      intros X Y Z f\n      infer_instance }\n\n"}
{"name":"CompHausLike.instFinitaryExtensiveOfHasExplicitPullbacksOfInclusions","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\ninst✝¹ : CompHausLike.HasExplicitFiniteCoproducts P\ninst✝ : CompHausLike.HasExplicitPullbacksOfInclusions P\n⊢ CategoryTheory.FinitaryExtensive (CompHausLike P)","decl":"instance [HasExplicitPullbacksOfInclusions P] : FinitaryExtensive (CompHausLike P) :=\n  finitaryExtensive_of_preserves_and_reflects (compHausLikeToTop P)\n\n"}
{"name":"CompHausLike.finitaryExtensive","module":"Mathlib.Topology.Category.CompHausLike.Limits","initialProofState":"P : TopCat → Prop\ninst✝ : CompHausLike.HasExplicitFiniteCoproducts P\nhP' : ∀ ⦃X Y B : CompHausLike P⦄ (f : Quiver.Hom X B) (g : Quiver.Hom Y B), Topology.IsOpenEmbedding ⇑f → CompHausLike.HasExplicitPullback f g\n⊢ CategoryTheory.FinitaryExtensive (CompHausLike P)","decl":"theorem finitaryExtensive (hP' : ∀ ⦃X Y B : CompHausLike.{u} P⦄ (f : X ⟶ B) (g : Y ⟶ B)\n    (_ : IsOpenEmbedding f), HasExplicitPullback f g) :\n      FinitaryExtensive (CompHausLike P) :=\n  have := hasPullbacksOfInclusions hP'\n  finitaryExtensive_of_preserves_and_reflects (compHausLikeToTop P)\n\n"}
