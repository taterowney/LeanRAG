{"name":"MvPolynomial.supported_eq_range_rename","module":"Mathlib.Algebra.MvPolynomial.Supported","initialProofState":"σ : Type u_1\nR : Type u\ninst✝ : CommSemiring R\ns : Set σ\n⊢ Eq (MvPolynomial.supported R s) (MvPolynomial.rename Subtype.val).range","decl":"theorem supported_eq_range_rename (s : Set σ) : supported R s = (rename ((↑) : s → σ)).range := by\n  rw [supported, Set.image_eq_range, adjoin_range_eq_range_aeval, rename]\n  congr\n\n"}
{"name":"MvPolynomial.supportedEquivMvPolynomial_symm_C","module":"Mathlib.Algebra.MvPolynomial.Supported","initialProofState":"σ : Type u_1\nR : Type u\ninst✝ : CommSemiring R\ns : Set σ\nx : R\n⊢ Eq ((MvPolynomial.supportedEquivMvPolynomial s).symm (MvPolynomial.C x)) ((algebraMap R (Subtype fun x => Membership.mem (MvPolynomial.supported R s) x)) x)","decl":"@[simp]\ntheorem supportedEquivMvPolynomial_symm_C (s : Set σ) (x : R) :\n    (supportedEquivMvPolynomial s).symm (C x) = algebraMap R (supported R s) x := by\n  ext1\n  simp [supportedEquivMvPolynomial, MvPolynomial.algebraMap_eq]\n\n"}
{"name":"MvPolynomial.supportedEquivMvPolynomial_symm_X","module":"Mathlib.Algebra.MvPolynomial.Supported","initialProofState":"σ : Type u_1\nR : Type u\ninst✝ : CommSemiring R\ns : Set σ\ni : ↑s\n⊢ Eq (↑((MvPolynomial.supportedEquivMvPolynomial s).symm (MvPolynomial.X i))) (MvPolynomial.X ↑i)","decl":"@[simp]\ntheorem supportedEquivMvPolynomial_symm_X (s : Set σ) (i : s) :\n    (↑((supportedEquivMvPolynomial s).symm (X i : MvPolynomial s R)) : MvPolynomial σ R) = X ↑i :=\n  by simp [supportedEquivMvPolynomial]\n\n"}
{"name":"MvPolynomial.mem_supported","module":"Mathlib.Algebra.MvPolynomial.Supported","initialProofState":"σ : Type u_1\nR : Type u\ninst✝ : CommSemiring R\np : MvPolynomial σ R\ns : Set σ\n⊢ Iff (Membership.mem (MvPolynomial.supported R s) p) (HasSubset.Subset (↑p.vars) s)","decl":"theorem mem_supported : p ∈ supported R s ↔ ↑p.vars ⊆ s := by\n  classical\n  rw [supported_eq_range_rename, AlgHom.mem_range]\n  constructor\n  · rintro ⟨p, rfl⟩\n    refine _root_.trans (Finset.coe_subset.2 (vars_rename _ _)) ?_\n    simp\n  · intro hs\n    exact exists_rename_eq_of_vars_subset_range p ((↑) : s → σ) Subtype.val_injective (by simpa)\n\n"}
{"name":"MvPolynomial.supported_eq_vars_subset","module":"Mathlib.Algebra.MvPolynomial.Supported","initialProofState":"σ : Type u_1\nR : Type u\ninst✝ : CommSemiring R\ns : Set σ\n⊢ Eq (↑(MvPolynomial.supported R s)) (setOf fun p => HasSubset.Subset (↑p.vars) s)","decl":"theorem supported_eq_vars_subset : (supported R s : Set (MvPolynomial σ R)) = { p | ↑p.vars ⊆ s } :=\n  Set.ext fun _ ↦ mem_supported\n\n"}
{"name":"MvPolynomial.mem_supported_vars","module":"Mathlib.Algebra.MvPolynomial.Supported","initialProofState":"σ : Type u_1\nR : Type u\ninst✝ : CommSemiring R\np : MvPolynomial σ R\n⊢ Membership.mem (MvPolynomial.supported R ↑p.vars) p","decl":"@[simp]\ntheorem mem_supported_vars (p : MvPolynomial σ R) : p ∈ supported R (↑p.vars : Set σ) := by\n  rw [mem_supported]\n\n"}
{"name":"MvPolynomial.supported_eq_adjoin_X","module":"Mathlib.Algebra.MvPolynomial.Supported","initialProofState":"σ : Type u_1\nR : Type u\ninst✝ : CommSemiring R\ns : Set σ\n⊢ Eq (MvPolynomial.supported R s) (Algebra.adjoin R (Set.image MvPolynomial.X s))","decl":"theorem supported_eq_adjoin_X : supported R s = Algebra.adjoin R (X '' s) := rfl\n\n"}
{"name":"MvPolynomial.supported_univ","module":"Mathlib.Algebra.MvPolynomial.Supported","initialProofState":"σ : Type u_1\nR : Type u\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.supported R Set.univ) Top.top","decl":"@[simp]\ntheorem supported_univ : supported R (Set.univ : Set σ) = ⊤ := by\n  simp [Algebra.eq_top_iff, mem_supported]\n\n"}
{"name":"MvPolynomial.supported_empty","module":"Mathlib.Algebra.MvPolynomial.Supported","initialProofState":"σ : Type u_1\nR : Type u\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.supported R EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem supported_empty : supported R (∅ : Set σ) = ⊥ := by simp [supported_eq_adjoin_X]\n\n"}
{"name":"MvPolynomial.supported_mono","module":"Mathlib.Algebra.MvPolynomial.Supported","initialProofState":"σ : Type u_1\nR : Type u\ninst✝ : CommSemiring R\ns t : Set σ\nst : HasSubset.Subset s t\n⊢ LE.le (MvPolynomial.supported R s) (MvPolynomial.supported R t)","decl":"theorem supported_mono (st : s ⊆ t) : supported R s ≤ supported R t :=\n  Algebra.adjoin_mono (Set.image_subset _ st)\n\n"}
{"name":"MvPolynomial.X_mem_supported","module":"Mathlib.Algebra.MvPolynomial.Supported","initialProofState":"σ : Type u_1\nR : Type u\ninst✝¹ : CommSemiring R\ns : Set σ\ninst✝ : Nontrivial R\ni : σ\n⊢ Iff (Membership.mem (MvPolynomial.supported R s) (MvPolynomial.X i)) (Membership.mem s i)","decl":"@[simp]\ntheorem X_mem_supported [Nontrivial R] {i : σ} : X i ∈ supported R s ↔ i ∈ s := by\n  simp [mem_supported]\n\n"}
{"name":"MvPolynomial.supported_le_supported_iff","module":"Mathlib.Algebra.MvPolynomial.Supported","initialProofState":"σ : Type u_1\nR : Type u\ninst✝¹ : CommSemiring R\ns t : Set σ\ninst✝ : Nontrivial R\n⊢ Iff (LE.le (MvPolynomial.supported R s) (MvPolynomial.supported R t)) (HasSubset.Subset s t)","decl":"@[simp]\ntheorem supported_le_supported_iff [Nontrivial R] : supported R s ≤ supported R t ↔ s ⊆ t := by\n  constructor\n  · intro h i\n    simpa using @h (X i)\n  · exact supported_mono\n\n"}
{"name":"MvPolynomial.supported_strictMono","module":"Mathlib.Algebra.MvPolynomial.Supported","initialProofState":"σ : Type u_1\nR : Type u\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\n⊢ StrictMono (MvPolynomial.supported R)","decl":"theorem supported_strictMono [Nontrivial R] :\n    StrictMono (supported R : Set σ → Subalgebra R (MvPolynomial σ R)) :=\n  strictMono_of_le_iff_le fun _ _ ↦ supported_le_supported_iff.symm\n\n"}
{"name":"MvPolynomial.exists_restrict_to_vars","module":"Mathlib.Algebra.MvPolynomial.Supported","initialProofState":"σ : Type u_1\ns : Set σ\nR : Type u_2\ninst✝ : CommRing R\nF : MvPolynomial σ Int\nhF : HasSubset.Subset (↑F.vars) s\n⊢ Exists fun f => ∀ (x : σ → R), Eq (f (Function.comp x Subtype.val)) ((MvPolynomial.aeval x) F)","decl":"theorem exists_restrict_to_vars (R : Type*) [CommRing R] {F : MvPolynomial σ ℤ}\n    (hF : ↑F.vars ⊆ s) : ∃ f : (s → R) → R, ∀ x : σ → R, f (x ∘ (↑) : s → R) = aeval x F := by\n  rw [← mem_supported, supported_eq_range_rename, AlgHom.mem_range] at hF\n  cases' hF with F' hF'\n  use fun z ↦ aeval z F'\n  intro x\n  simp only [← hF', aeval_rename]\n\n"}
