{"name":"coe_add_coe","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"M : Type u_3\nS : Type u_6\ninst✝² : AddMonoid M\ninst✝¹ : SetLike S M\ninst✝ : AddSubmonoidClass S M\nH : S\n⊢ Eq (HAdd.hAdd ↑H ↑H) ↑H","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma coe_mul_coe [SetLike S M] [SubmonoidClass S M] (H : S) : H * H = (H : Set M) := by\n  aesop (add simp mem_mul)\n\n"}
{"name":"coe_mul_coe","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"M : Type u_3\nS : Type u_6\ninst✝² : Monoid M\ninst✝¹ : SetLike S M\ninst✝ : SubmonoidClass S M\nH : S\n⊢ Eq (HMul.hMul ↑H ↑H) ↑H","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma coe_mul_coe [SetLike S M] [SubmonoidClass S M] (H : S) : H * H = (H : Set M) := by\n  aesop (add simp mem_mul)\n\n"}
{"name":"coe_set_pow","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"M : Type u_3\nS : Type u_6\ninst✝² : Monoid M\ninst✝¹ : SetLike S M\ninst✝ : SubmonoidClass S M\nn : Nat\nhn : Ne n 0\nH : S\n⊢ Eq (HPow.hPow (↑H) n) ↑H","decl":"set_option linter.unusedVariables false in\n@[to_additive (attr := simp)]\nlemma coe_set_pow [SetLike S M] [SubmonoidClass S M] :\n    ∀ {n} (hn : n ≠ 0) (H : S), (H ^ n : Set M) = H\n  | 1, _, H => by simp\n  | n + 2, _, H => by rw [pow_succ, coe_set_pow n.succ_ne_zero, coe_mul_coe]\n\n"}
{"name":"coe_set_nsmul","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"M : Type u_3\nS : Type u_6\ninst✝² : AddMonoid M\ninst✝¹ : SetLike S M\ninst✝ : AddSubmonoidClass S M\nn : Nat\nhn : Ne n 0\nH : S\n⊢ Eq (HSMul.hSMul n ↑H) ↑H","decl":"set_option linter.unusedVariables false in\n@[to_additive (attr := simp)]\nlemma coe_set_pow [SetLike S M] [SubmonoidClass S M] :\n    ∀ {n} (hn : n ≠ 0) (H : S), (H ^ n : Set M) = H\n  | 1, _, H => by simp\n  | n + 2, _, H => by rw [pow_succ, coe_set_pow n.succ_ne_zero, coe_mul_coe]\n\n"}
{"name":"AddSubmonoid.add_subset","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"M : Type u_3\ninst✝ : AddMonoid M\ns t : Set M\nS : AddSubmonoid M\nhs : HasSubset.Subset s ↑S\nht : HasSubset.Subset t ↑S\n⊢ HasSubset.Subset (HAdd.hAdd s t) ↑S","decl":"@[to_additive]\ntheorem mul_subset {S : Submonoid M} (hs : s ⊆ S) (ht : t ⊆ S) : s * t ⊆ S :=\n  mul_subset_iff.2 fun _x hx _y hy ↦ mul_mem (hs hx) (ht hy)\n\n"}
{"name":"Submonoid.mul_subset","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"M : Type u_3\ninst✝ : Monoid M\ns t : Set M\nS : Submonoid M\nhs : HasSubset.Subset s ↑S\nht : HasSubset.Subset t ↑S\n⊢ HasSubset.Subset (HMul.hMul s t) ↑S","decl":"@[to_additive]\ntheorem mul_subset {S : Submonoid M} (hs : s ⊆ S) (ht : t ⊆ S) : s * t ⊆ S :=\n  mul_subset_iff.2 fun _x hx _y hy ↦ mul_mem (hs hx) (ht hy)\n\n"}
{"name":"AddSubmonoid.add_subset_closure","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"M : Type u_3\ninst✝ : AddMonoid M\ns t u : Set M\nhs : HasSubset.Subset s u\nht : HasSubset.Subset t u\n⊢ HasSubset.Subset (HAdd.hAdd s t) ↑(AddSubmonoid.closure u)","decl":"@[to_additive]\ntheorem mul_subset_closure (hs : s ⊆ u) (ht : t ⊆ u) : s * t ⊆ Submonoid.closure u :=\n  mul_subset (Subset.trans hs Submonoid.subset_closure) (Subset.trans ht Submonoid.subset_closure)\n\n"}
{"name":"Submonoid.mul_subset_closure","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"M : Type u_3\ninst✝ : Monoid M\ns t u : Set M\nhs : HasSubset.Subset s u\nht : HasSubset.Subset t u\n⊢ HasSubset.Subset (HMul.hMul s t) ↑(Submonoid.closure u)","decl":"@[to_additive]\ntheorem mul_subset_closure (hs : s ⊆ u) (ht : t ⊆ u) : s * t ⊆ Submonoid.closure u :=\n  mul_subset (Subset.trans hs Submonoid.subset_closure) (Subset.trans ht Submonoid.subset_closure)\n\n"}
{"name":"AddSubmonoid.coe_add_self_eq","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"M : Type u_3\ninst✝ : AddMonoid M\ns : AddSubmonoid M\n⊢ Eq (HAdd.hAdd ↑s ↑s) ↑s","decl":"@[to_additive]\ntheorem coe_mul_self_eq (s : Submonoid M) : (s : Set M) * s = s := by\n  ext x\n  refine ⟨?_, fun h => ⟨x, h, 1, s.one_mem, mul_one x⟩⟩\n  rintro ⟨a, ha, b, hb, rfl⟩\n  exact s.mul_mem ha hb\n\n"}
{"name":"Submonoid.coe_mul_self_eq","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"M : Type u_3\ninst✝ : Monoid M\ns : Submonoid M\n⊢ Eq (HMul.hMul ↑s ↑s) ↑s","decl":"@[to_additive]\ntheorem coe_mul_self_eq (s : Submonoid M) : (s : Set M) * s = s := by\n  ext x\n  refine ⟨?_, fun h => ⟨x, h, 1, s.one_mem, mul_one x⟩⟩\n  rintro ⟨a, ha, b, hb, rfl⟩\n  exact s.mul_mem ha hb\n\n"}
{"name":"AddSubmonoid.closure_add_le","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"M : Type u_3\ninst✝ : AddMonoid M\nS T : Set M\n⊢ LE.le (AddSubmonoid.closure (HAdd.hAdd S T)) (Max.max (AddSubmonoid.closure S) (AddSubmonoid.closure T))","decl":"@[to_additive]\ntheorem closure_mul_le (S T : Set M) : closure (S * T) ≤ closure S ⊔ closure T :=\n  sInf_le fun _x ⟨_s, hs, _t, ht, hx⟩ => hx ▸\n    (closure S ⊔ closure T).mul_mem (SetLike.le_def.mp le_sup_left <| subset_closure hs)\n      (SetLike.le_def.mp le_sup_right <| subset_closure ht)\n\n"}
{"name":"Submonoid.closure_mul_le","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"M : Type u_3\ninst✝ : Monoid M\nS T : Set M\n⊢ LE.le (Submonoid.closure (HMul.hMul S T)) (Max.max (Submonoid.closure S) (Submonoid.closure T))","decl":"@[to_additive]\ntheorem closure_mul_le (S T : Set M) : closure (S * T) ≤ closure S ⊔ closure T :=\n  sInf_le fun _x ⟨_s, hs, _t, ht, hx⟩ => hx ▸\n    (closure S ⊔ closure T).mul_mem (SetLike.le_def.mp le_sup_left <| subset_closure hs)\n      (SetLike.le_def.mp le_sup_right <| subset_closure ht)\n\n"}
{"name":"AddSubmonoid.closure_nsmul_le","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"M : Type u_3\ninst✝ : AddMonoid M\ns : Set M\nn : Nat\na✝ : Ne n 0\n⊢ LE.le (AddSubmonoid.closure (HSMul.hSMul n s)) (AddSubmonoid.closure s)","decl":"@[to_additive]\nlemma closure_pow_le : ∀ {n}, n ≠ 0 → closure (s ^ n) ≤ closure s\n  | 1, _ => by simp\n  | n + 2, _ =>\n    calc\n      closure (s ^ (n + 2))\n      _ = closure (s ^ (n + 1) * s) := by rw [pow_succ]\n      _ ≤ closure (s ^ (n + 1)) ⊔ closure s := closure_mul_le ..\n      _ ≤ closure s ⊔ closure s := by gcongr ?_ ⊔ _; exact closure_pow_le n.succ_ne_zero\n      _ = closure s := sup_idem _\n\n"}
{"name":"Submonoid.closure_pow_le","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"M : Type u_3\ninst✝ : Monoid M\ns : Set M\nn : Nat\na✝ : Ne n 0\n⊢ LE.le (Submonoid.closure (HPow.hPow s n)) (Submonoid.closure s)","decl":"@[to_additive]\nlemma closure_pow_le : ∀ {n}, n ≠ 0 → closure (s ^ n) ≤ closure s\n  | 1, _ => by simp\n  | n + 2, _ =>\n    calc\n      closure (s ^ (n + 2))\n      _ = closure (s ^ (n + 1) * s) := by rw [pow_succ]\n      _ ≤ closure (s ^ (n + 1)) ⊔ closure s := closure_mul_le ..\n      _ ≤ closure s ⊔ closure s := by gcongr ?_ ⊔ _; exact closure_pow_le n.succ_ne_zero\n      _ = closure s := sup_idem _\n\n"}
{"name":"AddSubmonoid.closure_nsmul","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"M : Type u_3\ninst✝ : AddMonoid M\ns : Set M\nn : Nat\nhs : Membership.mem s 0\nhn : Ne n 0\n⊢ Eq (AddSubmonoid.closure (HSMul.hSMul n s)) (AddSubmonoid.closure s)","decl":"@[to_additive]\nlemma closure_pow {n : ℕ} (hs : 1 ∈ s) (hn : n ≠ 0) : closure (s ^ n) = closure s :=\n  (closure_pow_le hn).antisymm <| by gcongr; exact subset_pow hs hn\n\n"}
{"name":"Submonoid.closure_pow","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"M : Type u_3\ninst✝ : Monoid M\ns : Set M\nn : Nat\nhs : Membership.mem s 1\nhn : Ne n 0\n⊢ Eq (Submonoid.closure (HPow.hPow s n)) (Submonoid.closure s)","decl":"@[to_additive]\nlemma closure_pow {n : ℕ} (hs : 1 ∈ s) (hn : n ≠ 0) : closure (s ^ n) = closure s :=\n  (closure_pow_le hn).antisymm <| by gcongr; exact subset_pow hs hn\n\n"}
{"name":"AddSubmonoid.sup_eq_closure_add","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"M : Type u_3\ninst✝ : AddMonoid M\nH K : AddSubmonoid M\n⊢ Eq (Max.max H K) (AddSubmonoid.closure (HAdd.hAdd ↑H ↑K))","decl":"@[to_additive]\ntheorem sup_eq_closure_mul (H K : Submonoid M) : H ⊔ K = closure ((H : Set M) * (K : Set M)) :=\n  le_antisymm\n    (sup_le (fun h hh => subset_closure ⟨h, hh, 1, K.one_mem, mul_one h⟩) fun k hk =>\n      subset_closure ⟨1, H.one_mem, k, hk, one_mul k⟩)\n    ((closure_mul_le _ _).trans <| by rw [closure_eq, closure_eq])\n\n"}
{"name":"Submonoid.sup_eq_closure_mul","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"M : Type u_3\ninst✝ : Monoid M\nH K : Submonoid M\n⊢ Eq (Max.max H K) (Submonoid.closure (HMul.hMul ↑H ↑K))","decl":"@[to_additive]\ntheorem sup_eq_closure_mul (H K : Submonoid M) : H ⊔ K = closure ((H : Set M) * (K : Set M)) :=\n  le_antisymm\n    (sup_le (fun h hh => subset_closure ⟨h, hh, 1, K.one_mem, mul_one h⟩) fun k hk =>\n      subset_closure ⟨1, H.one_mem, k, hk, one_mul k⟩)\n    ((closure_mul_le _ _).trans <| by rw [closure_eq, closure_eq])\n\n"}
{"name":"AddSubmonoid.nsmul_vadd_mem_closure_vadd","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"M : Type u_3\ninst✝³ : AddMonoid M\nN : Type u_7\ninst✝² : AddCommMonoid N\ninst✝¹ : AddAction M N\ninst✝ : VAddAssocClass M N N\nr : M\ns : Set N\nx : N\nhx : Membership.mem (AddSubmonoid.closure s) x\n⊢ Exists fun n => Membership.mem (AddSubmonoid.closure (HVAdd.hVAdd r s)) (HVAdd.hVAdd (HSMul.hSMul n r) x)","decl":"@[to_additive]\ntheorem pow_smul_mem_closure_smul {N : Type*} [CommMonoid N] [MulAction M N] [IsScalarTower M N N]\n    (r : M) (s : Set N) {x : N} (hx : x ∈ closure s) : ∃ n : ℕ, r ^ n • x ∈ closure (r • s) := by\n  induction hx using closure_induction with\n  | mem x hx => exact ⟨1, subset_closure ⟨_, hx, by rw [pow_one]⟩⟩\n  | one => exact ⟨0, by simpa using one_mem _⟩\n  | mul x y _ _ hx hy =>\n    obtain ⟨⟨nx, hx⟩, ⟨ny, hy⟩⟩ := And.intro hx hy\n    use ny + nx\n    rw [pow_add, mul_smul, ← smul_mul_assoc, mul_comm, ← smul_mul_assoc]\n    exact mul_mem hy hx\n\n"}
{"name":"Submonoid.pow_smul_mem_closure_smul","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"M : Type u_3\ninst✝³ : Monoid M\nN : Type u_7\ninst✝² : CommMonoid N\ninst✝¹ : MulAction M N\ninst✝ : IsScalarTower M N N\nr : M\ns : Set N\nx : N\nhx : Membership.mem (Submonoid.closure s) x\n⊢ Exists fun n => Membership.mem (Submonoid.closure (HSMul.hSMul r s)) (HSMul.hSMul (HPow.hPow r n) x)","decl":"@[to_additive]\ntheorem pow_smul_mem_closure_smul {N : Type*} [CommMonoid N] [MulAction M N] [IsScalarTower M N N]\n    (r : M) (s : Set N) {x : N} (hx : x ∈ closure s) : ∃ n : ℕ, r ^ n • x ∈ closure (r • s) := by\n  induction hx using closure_induction with\n  | mem x hx => exact ⟨1, subset_closure ⟨_, hx, by rw [pow_one]⟩⟩\n  | one => exact ⟨0, by simpa using one_mem _⟩\n  | mul x y _ _ hx hy =>\n    obtain ⟨⟨nx, hx⟩, ⟨ny, hy⟩⟩ := And.intro hx hy\n    use ny + nx\n    rw [pow_add, mul_smul, ← smul_mul_assoc, mul_comm, ← smul_mul_assoc]\n    exact mul_mem hy hx\n\n"}
{"name":"Submonoid.coe_inv","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nS : Submonoid G\n⊢ Eq (↑(Inv.inv S)) (Inv.inv ↑S)","decl":"@[to_additive (attr := simp)]\ntheorem coe_inv (S : Submonoid G) : ↑S⁻¹ = (S : Set G)⁻¹ :=\n  rfl\n\n"}
{"name":"AddSubmonoid.coe_neg","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nS : AddSubmonoid G\n⊢ Eq (↑(Neg.neg S)) (Neg.neg ↑S)","decl":"@[to_additive (attr := simp)]\ntheorem coe_inv (S : Submonoid G) : ↑S⁻¹ = (S : Set G)⁻¹ :=\n  rfl\n\n"}
{"name":"AddSubmonoid.mem_neg","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\ng : G\nS : AddSubmonoid G\n⊢ Iff (Membership.mem (Neg.neg S) g) (Membership.mem S (Neg.neg g))","decl":"@[to_additive (attr := simp)]\ntheorem mem_inv {g : G} {S : Submonoid G} : g ∈ S⁻¹ ↔ g⁻¹ ∈ S :=\n  Iff.rfl\n\n"}
{"name":"Submonoid.mem_inv","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\ng : G\nS : Submonoid G\n⊢ Iff (Membership.mem (Inv.inv S) g) (Membership.mem S (Inv.inv g))","decl":"@[to_additive (attr := simp)]\ntheorem mem_inv {g : G} {S : Submonoid G} : g ∈ S⁻¹ ↔ g⁻¹ ∈ S :=\n  Iff.rfl\n\n"}
{"name":"Submonoid.inv_le_inv","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nS T : Submonoid G\n⊢ Iff (LE.le (Inv.inv S) (Inv.inv T)) (LE.le S T)","decl":"@[to_additive (attr := simp)]\ntheorem inv_le_inv (S T : Submonoid G) : S⁻¹ ≤ T⁻¹ ↔ S ≤ T :=\n  SetLike.coe_subset_coe.symm.trans Set.inv_subset_inv\n\n"}
{"name":"AddSubmonoid.neg_le_neg","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nS T : AddSubmonoid G\n⊢ Iff (LE.le (Neg.neg S) (Neg.neg T)) (LE.le S T)","decl":"@[to_additive (attr := simp)]\ntheorem inv_le_inv (S T : Submonoid G) : S⁻¹ ≤ T⁻¹ ↔ S ≤ T :=\n  SetLike.coe_subset_coe.symm.trans Set.inv_subset_inv\n\n"}
{"name":"Submonoid.inv_le","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nS T : Submonoid G\n⊢ Iff (LE.le (Inv.inv S) T) (LE.le S (Inv.inv T))","decl":"@[to_additive]\ntheorem inv_le (S T : Submonoid G) : S⁻¹ ≤ T ↔ S ≤ T⁻¹ :=\n  SetLike.coe_subset_coe.symm.trans Set.inv_subset\n\n"}
{"name":"AddSubmonoid.neg_le","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nS T : AddSubmonoid G\n⊢ Iff (LE.le (Neg.neg S) T) (LE.le S (Neg.neg T))","decl":"@[to_additive]\ntheorem inv_le (S T : Submonoid G) : S⁻¹ ≤ T ↔ S ≤ T⁻¹ :=\n  SetLike.coe_subset_coe.symm.trans Set.inv_subset\n\n"}
{"name":"AddSubmonoid.coe_negOrderIso_symm_apply","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\na✝ : AddSubmonoid G\n⊢ Eq (↑((RelIso.symm AddSubmonoid.negOrderIso) a✝)) (Neg.neg ↑a✝)","decl":"/-- Pointwise inversion of submonoids as an order isomorphism. -/\n@[to_additive (attr := simps!) \"Pointwise negation of additive submonoids as an order isomorphism\"]\ndef invOrderIso : Submonoid G ≃o Submonoid G where\n  toEquiv := Equiv.inv _\n  map_rel_iff' := inv_le_inv _ _\n\n"}
{"name":"Submonoid.coe_invOrderIso_apply","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\na✝ : Submonoid G\n⊢ Eq (↑(Submonoid.invOrderIso a✝)) (Inv.inv ↑a✝)","decl":"/-- Pointwise inversion of submonoids as an order isomorphism. -/\n@[to_additive (attr := simps!) \"Pointwise negation of additive submonoids as an order isomorphism\"]\ndef invOrderIso : Submonoid G ≃o Submonoid G where\n  toEquiv := Equiv.inv _\n  map_rel_iff' := inv_le_inv _ _\n\n"}
{"name":"Submonoid.coe_invOrderIso_symm_apply","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\na✝ : Submonoid G\n⊢ Eq (↑((RelIso.symm Submonoid.invOrderIso) a✝)) (Inv.inv ↑a✝)","decl":"/-- Pointwise inversion of submonoids as an order isomorphism. -/\n@[to_additive (attr := simps!) \"Pointwise negation of additive submonoids as an order isomorphism\"]\ndef invOrderIso : Submonoid G ≃o Submonoid G where\n  toEquiv := Equiv.inv _\n  map_rel_iff' := inv_le_inv _ _\n\n"}
{"name":"AddSubmonoid.coe_negOrderIso_apply","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\na✝ : AddSubmonoid G\n⊢ Eq (↑(AddSubmonoid.negOrderIso a✝)) (Neg.neg ↑a✝)","decl":"/-- Pointwise inversion of submonoids as an order isomorphism. -/\n@[to_additive (attr := simps!) \"Pointwise negation of additive submonoids as an order isomorphism\"]\ndef invOrderIso : Submonoid G ≃o Submonoid G where\n  toEquiv := Equiv.inv _\n  map_rel_iff' := inv_le_inv _ _\n\n"}
{"name":"AddSubmonoid.closure_neg","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\ns : Set G\n⊢ Eq (AddSubmonoid.closure (Neg.neg s)) (Neg.neg (AddSubmonoid.closure s))","decl":"@[to_additive]\ntheorem closure_inv (s : Set G) : closure s⁻¹ = (closure s)⁻¹ := by\n  apply le_antisymm\n  · rw [closure_le, coe_inv, ← Set.inv_subset, inv_inv]\n    exact subset_closure\n  · rw [inv_le, closure_le, coe_inv, ← Set.inv_subset]\n    exact subset_closure\n\n"}
{"name":"Submonoid.closure_inv","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\ns : Set G\n⊢ Eq (Submonoid.closure (Inv.inv s)) (Inv.inv (Submonoid.closure s))","decl":"@[to_additive]\ntheorem closure_inv (s : Set G) : closure s⁻¹ = (closure s)⁻¹ := by\n  apply le_antisymm\n  · rw [closure_le, coe_inv, ← Set.inv_subset, inv_inv]\n    exact subset_closure\n  · rw [inv_le, closure_le, coe_inv, ← Set.inv_subset]\n    exact subset_closure\n\n"}
{"name":"AddSubmonoid.neg_inf","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nS T : AddSubmonoid G\n⊢ Eq (Neg.neg (Min.min S T)) (Min.min (Neg.neg S) (Neg.neg T))","decl":"@[to_additive (attr := simp)]\ntheorem inv_inf (S T : Submonoid G) : (S ⊓ T)⁻¹ = S⁻¹ ⊓ T⁻¹ :=\n  SetLike.coe_injective Set.inter_inv\n\n"}
{"name":"Submonoid.inv_inf","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nS T : Submonoid G\n⊢ Eq (Inv.inv (Min.min S T)) (Min.min (Inv.inv S) (Inv.inv T))","decl":"@[to_additive (attr := simp)]\ntheorem inv_inf (S T : Submonoid G) : (S ⊓ T)⁻¹ = S⁻¹ ⊓ T⁻¹ :=\n  SetLike.coe_injective Set.inter_inv\n\n"}
{"name":"AddSubmonoid.neg_sup","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nS T : AddSubmonoid G\n⊢ Eq (Neg.neg (Max.max S T)) (Max.max (Neg.neg S) (Neg.neg T))","decl":"@[to_additive (attr := simp)]\ntheorem inv_sup (S T : Submonoid G) : (S ⊔ T)⁻¹ = S⁻¹ ⊔ T⁻¹ :=\n  (invOrderIso : Submonoid G ≃o Submonoid G).map_sup S T\n\n"}
{"name":"Submonoid.inv_sup","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nS T : Submonoid G\n⊢ Eq (Inv.inv (Max.max S T)) (Max.max (Inv.inv S) (Inv.inv T))","decl":"@[to_additive (attr := simp)]\ntheorem inv_sup (S T : Submonoid G) : (S ⊔ T)⁻¹ = S⁻¹ ⊔ T⁻¹ :=\n  (invOrderIso : Submonoid G ≃o Submonoid G).map_sup S T\n\n"}
{"name":"AddSubmonoid.neg_bot","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\n⊢ Eq (Neg.neg Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem inv_bot : (⊥ : Submonoid G)⁻¹ = ⊥ :=\n  SetLike.coe_injective <| (Set.inv_singleton 1).trans <| congr_arg _ inv_one\n\n"}
{"name":"Submonoid.inv_bot","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\n⊢ Eq (Inv.inv Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem inv_bot : (⊥ : Submonoid G)⁻¹ = ⊥ :=\n  SetLike.coe_injective <| (Set.inv_singleton 1).trans <| congr_arg _ inv_one\n\n"}
{"name":"Submonoid.inv_top","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\n⊢ Eq (Inv.inv Top.top) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem inv_top : (⊤ : Submonoid G)⁻¹ = ⊤ :=\n  SetLike.coe_injective <| Set.inv_univ\n\n"}
{"name":"AddSubmonoid.neg_top","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\n⊢ Eq (Neg.neg Top.top) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem inv_top : (⊤ : Submonoid G)⁻¹ = ⊤ :=\n  SetLike.coe_injective <| Set.inv_univ\n\n"}
{"name":"AddSubmonoid.neg_iInf","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nι : Sort u_7\nS : ι → AddSubmonoid G\n⊢ Eq (Neg.neg (iInf fun i => S i)) (iInf fun i => Neg.neg (S i))","decl":"@[to_additive (attr := simp)]\ntheorem inv_iInf {ι : Sort*} (S : ι → Submonoid G) : (⨅ i, S i)⁻¹ = ⨅ i, (S i)⁻¹ :=\n  (invOrderIso : Submonoid G ≃o Submonoid G).map_iInf _\n\n"}
{"name":"Submonoid.inv_iInf","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nι : Sort u_7\nS : ι → Submonoid G\n⊢ Eq (Inv.inv (iInf fun i => S i)) (iInf fun i => Inv.inv (S i))","decl":"@[to_additive (attr := simp)]\ntheorem inv_iInf {ι : Sort*} (S : ι → Submonoid G) : (⨅ i, S i)⁻¹ = ⨅ i, (S i)⁻¹ :=\n  (invOrderIso : Submonoid G ≃o Submonoid G).map_iInf _\n\n"}
{"name":"AddSubmonoid.neg_iSup","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nι : Sort u_7\nS : ι → AddSubmonoid G\n⊢ Eq (Neg.neg (iSup fun i => S i)) (iSup fun i => Neg.neg (S i))","decl":"@[to_additive (attr := simp)]\ntheorem inv_iSup {ι : Sort*} (S : ι → Submonoid G) : (⨆ i, S i)⁻¹ = ⨆ i, (S i)⁻¹ :=\n  (invOrderIso : Submonoid G ≃o Submonoid G).map_iSup _\n\n"}
{"name":"Submonoid.inv_iSup","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nι : Sort u_7\nS : ι → Submonoid G\n⊢ Eq (Inv.inv (iSup fun i => S i)) (iSup fun i => Inv.inv (S i))","decl":"@[to_additive (attr := simp)]\ntheorem inv_iSup {ι : Sort*} (S : ι → Submonoid G) : (⨆ i, S i)⁻¹ = ⨆ i, (S i)⁻¹ :=\n  (invOrderIso : Submonoid G ≃o Submonoid G).map_iSup _\n\n"}
{"name":"Submonoid.coe_pointwise_smul","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Monoid α\ninst✝ : MulDistribMulAction α M\na : α\nS : Submonoid M\n⊢ Eq (↑(HSMul.hSMul a S)) (HSMul.hSMul a ↑S)","decl":"@[simp]\ntheorem coe_pointwise_smul (a : α) (S : Submonoid M) : ↑(a • S) = a • (S : Set M) :=\n  rfl\n\n"}
{"name":"Submonoid.smul_mem_pointwise_smul","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Monoid α\ninst✝ : MulDistribMulAction α M\nm : M\na : α\nS : Submonoid M\na✝ : Membership.mem S m\n⊢ Membership.mem (HSMul.hSMul a S) (HSMul.hSMul a m)","decl":"theorem smul_mem_pointwise_smul (m : M) (a : α) (S : Submonoid M) : m ∈ S → a • m ∈ a • S :=\n  (Set.smul_mem_smul_set : _ → _ ∈ a • (S : Set M))\n\n"}
{"name":"Submonoid.instCovariantClassHSMulLe","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Monoid α\ninst✝ : MulDistribMulAction α M\n⊢ CovariantClass α (Submonoid M) HSMul.hSMul LE.le","decl":"instance : CovariantClass α (Submonoid M) HSMul.hSMul LE.le :=\n  ⟨fun _ _ => image_subset _⟩\n\n"}
{"name":"Submonoid.mem_smul_pointwise_iff_exists","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Monoid α\ninst✝ : MulDistribMulAction α M\nm : M\na : α\nS : Submonoid M\n⊢ Iff (Membership.mem (HSMul.hSMul a S) m) (Exists fun s => And (Membership.mem S s) (Eq (HSMul.hSMul a s) m))","decl":"theorem mem_smul_pointwise_iff_exists (m : M) (a : α) (S : Submonoid M) :\n    m ∈ a • S ↔ ∃ s : M, s ∈ S ∧ a • s = m :=\n  (Set.mem_smul_set : m ∈ a • (S : Set M) ↔ _)\n\n"}
{"name":"Submonoid.smul_bot","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Monoid α\ninst✝ : MulDistribMulAction α M\na : α\n⊢ Eq (HSMul.hSMul a Bot.bot) Bot.bot","decl":"@[simp]\ntheorem smul_bot (a : α) : a • (⊥ : Submonoid M) = ⊥ :=\n  map_bot _\n\n"}
{"name":"Submonoid.smul_sup","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Monoid α\ninst✝ : MulDistribMulAction α M\na : α\nS T : Submonoid M\n⊢ Eq (HSMul.hSMul a (Max.max S T)) (Max.max (HSMul.hSMul a S) (HSMul.hSMul a T))","decl":"theorem smul_sup (a : α) (S T : Submonoid M) : a • (S ⊔ T) = a • S ⊔ a • T :=\n  map_sup _ _ _\n\n"}
{"name":"Submonoid.smul_closure","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Monoid α\ninst✝ : MulDistribMulAction α M\na : α\ns : Set M\n⊢ Eq (HSMul.hSMul a (Submonoid.closure s)) (Submonoid.closure (HSMul.hSMul a s))","decl":"theorem smul_closure (a : α) (s : Set M) : a • closure s = closure (a • s) :=\n  MonoidHom.map_mclosure _ _\n\n"}
{"name":"Submonoid.pointwise_isCentralScalar","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝⁴ : Monoid M\ninst✝³ : Monoid α\ninst✝² : MulDistribMulAction α M\ninst✝¹ : MulDistribMulAction (MulOpposite α) M\ninst✝ : IsCentralScalar α M\n⊢ IsCentralScalar α (Submonoid M)","decl":"lemma pointwise_isCentralScalar [MulDistribMulAction αᵐᵒᵖ M] [IsCentralScalar α M] :\n    IsCentralScalar α (Submonoid M) :=\n  ⟨fun _ S => (congr_arg fun f : Monoid.End M => S.map f) <| MonoidHom.ext <| op_smul_eq_smul _⟩\n\n"}
{"name":"Submonoid.smul_mem_pointwise_smul_iff","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Group α\ninst✝ : MulDistribMulAction α M\na : α\nS : Submonoid M\nx : M\n⊢ Iff (Membership.mem (HSMul.hSMul a S) (HSMul.hSMul a x)) (Membership.mem S x)","decl":"@[simp]\ntheorem smul_mem_pointwise_smul_iff {a : α} {S : Submonoid M} {x : M} : a • x ∈ a • S ↔ x ∈ S :=\n  smul_mem_smul_set_iff\n\n"}
{"name":"Submonoid.mem_pointwise_smul_iff_inv_smul_mem","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Group α\ninst✝ : MulDistribMulAction α M\na : α\nS : Submonoid M\nx : M\n⊢ Iff (Membership.mem (HSMul.hSMul a S) x) (Membership.mem S (HSMul.hSMul (Inv.inv a) x))","decl":"theorem mem_pointwise_smul_iff_inv_smul_mem {a : α} {S : Submonoid M} {x : M} :\n    x ∈ a • S ↔ a⁻¹ • x ∈ S :=\n  mem_smul_set_iff_inv_smul_mem\n\n"}
{"name":"Submonoid.mem_inv_pointwise_smul_iff","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Group α\ninst✝ : MulDistribMulAction α M\na : α\nS : Submonoid M\nx : M\n⊢ Iff (Membership.mem (HSMul.hSMul (Inv.inv a) S) x) (Membership.mem S (HSMul.hSMul a x))","decl":"theorem mem_inv_pointwise_smul_iff {a : α} {S : Submonoid M} {x : M} : x ∈ a⁻¹ • S ↔ a • x ∈ S :=\n  mem_inv_smul_set_iff\n\n"}
{"name":"Submonoid.pointwise_smul_le_pointwise_smul_iff","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Group α\ninst✝ : MulDistribMulAction α M\na : α\nS T : Submonoid M\n⊢ Iff (LE.le (HSMul.hSMul a S) (HSMul.hSMul a T)) (LE.le S T)","decl":"@[simp]\ntheorem pointwise_smul_le_pointwise_smul_iff {a : α} {S T : Submonoid M} : a • S ≤ a • T ↔ S ≤ T :=\n  smul_set_subset_smul_set_iff\n\n"}
{"name":"Submonoid.pointwise_smul_subset_iff","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Group α\ninst✝ : MulDistribMulAction α M\na : α\nS T : Submonoid M\n⊢ Iff (LE.le (HSMul.hSMul a S) T) (LE.le S (HSMul.hSMul (Inv.inv a) T))","decl":"theorem pointwise_smul_subset_iff {a : α} {S T : Submonoid M} : a • S ≤ T ↔ S ≤ a⁻¹ • T :=\n  smul_set_subset_iff_subset_inv_smul_set\n\n"}
{"name":"Submonoid.subset_pointwise_smul_iff","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Group α\ninst✝ : MulDistribMulAction α M\na : α\nS T : Submonoid M\n⊢ Iff (LE.le S (HSMul.hSMul a T)) (LE.le (HSMul.hSMul (Inv.inv a) S) T)","decl":"theorem subset_pointwise_smul_iff {a : α} {S T : Submonoid M} : S ≤ a • T ↔ a⁻¹ • S ≤ T :=\n  subset_smul_set_iff\n\n"}
{"name":"Submonoid.smul_mem_pointwise_smul_iff₀","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝² : Monoid M\ninst✝¹ : GroupWithZero α\ninst✝ : MulDistribMulAction α M\na : α\nha : Ne a 0\nS : Submonoid M\nx : M\n⊢ Iff (Membership.mem (HSMul.hSMul a S) (HSMul.hSMul a x)) (Membership.mem S x)","decl":"@[simp]\ntheorem smul_mem_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) (S : Submonoid M) (x : M) :\n    a • x ∈ a • S ↔ x ∈ S :=\n  smul_mem_smul_set_iff₀ ha (S : Set M) x\n\n"}
{"name":"Submonoid.mem_pointwise_smul_iff_inv_smul_mem₀","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝² : Monoid M\ninst✝¹ : GroupWithZero α\ninst✝ : MulDistribMulAction α M\na : α\nha : Ne a 0\nS : Submonoid M\nx : M\n⊢ Iff (Membership.mem (HSMul.hSMul a S) x) (Membership.mem S (HSMul.hSMul (Inv.inv a) x))","decl":"theorem mem_pointwise_smul_iff_inv_smul_mem₀ {a : α} (ha : a ≠ 0) (S : Submonoid M) (x : M) :\n    x ∈ a • S ↔ a⁻¹ • x ∈ S :=\n  mem_smul_set_iff_inv_smul_mem₀ ha (S : Set M) x\n\n"}
{"name":"Submonoid.mem_inv_pointwise_smul_iff₀","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝² : Monoid M\ninst✝¹ : GroupWithZero α\ninst✝ : MulDistribMulAction α M\na : α\nha : Ne a 0\nS : Submonoid M\nx : M\n⊢ Iff (Membership.mem (HSMul.hSMul (Inv.inv a) S) x) (Membership.mem S (HSMul.hSMul a x))","decl":"theorem mem_inv_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) (S : Submonoid M) (x : M) :\n    x ∈ a⁻¹ • S ↔ a • x ∈ S :=\n  mem_inv_smul_set_iff₀ ha (S : Set M) x\n\n"}
{"name":"Submonoid.pointwise_smul_le_pointwise_smul_iff₀","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝² : Monoid M\ninst✝¹ : GroupWithZero α\ninst✝ : MulDistribMulAction α M\na : α\nha : Ne a 0\nS T : Submonoid M\n⊢ Iff (LE.le (HSMul.hSMul a S) (HSMul.hSMul a T)) (LE.le S T)","decl":"@[simp]\ntheorem pointwise_smul_le_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) {S T : Submonoid M} :\n    a • S ≤ a • T ↔ S ≤ T :=\n  smul_set_subset_smul_set_iff₀ ha\n\n"}
{"name":"Submonoid.pointwise_smul_le_iff₀","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝² : Monoid M\ninst✝¹ : GroupWithZero α\ninst✝ : MulDistribMulAction α M\na : α\nha : Ne a 0\nS T : Submonoid M\n⊢ Iff (LE.le (HSMul.hSMul a S) T) (LE.le S (HSMul.hSMul (Inv.inv a) T))","decl":"theorem pointwise_smul_le_iff₀ {a : α} (ha : a ≠ 0) {S T : Submonoid M} : a • S ≤ T ↔ S ≤ a⁻¹ • T :=\n  smul_set_subset_iff₀ ha\n\n"}
{"name":"Submonoid.le_pointwise_smul_iff₀","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝² : Monoid M\ninst✝¹ : GroupWithZero α\ninst✝ : MulDistribMulAction α M\na : α\nha : Ne a 0\nS T : Submonoid M\n⊢ Iff (LE.le S (HSMul.hSMul a T)) (LE.le (HSMul.hSMul (Inv.inv a) S) T)","decl":"theorem le_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) {S T : Submonoid M} : S ≤ a • T ↔ a⁻¹ • S ≤ T :=\n  subset_smul_set_iff₀ ha\n\n"}
{"name":"Submonoid.mem_closure_inv","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_7\ninst✝ : Group G\nS : Set G\nx : G\n⊢ Iff (Membership.mem (Submonoid.closure (Inv.inv S)) x) (Membership.mem (Submonoid.closure S) (Inv.inv x))","decl":"@[to_additive]\ntheorem mem_closure_inv {G : Type*} [Group G] (S : Set G) (x : G) :\n    x ∈ Submonoid.closure S⁻¹ ↔ x⁻¹ ∈ Submonoid.closure S := by rw [closure_inv, mem_inv]\n\n"}
{"name":"AddSubmonoid.mem_closure_neg","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"G : Type u_7\ninst✝ : AddGroup G\nS : Set G\nx : G\n⊢ Iff (Membership.mem (AddSubmonoid.closure (Neg.neg S)) x) (Membership.mem (AddSubmonoid.closure S) (Neg.neg x))","decl":"@[to_additive]\ntheorem mem_closure_inv {G : Type*} [Group G] (S : Set G) (x : G) :\n    x ∈ Submonoid.closure S⁻¹ ↔ x⁻¹ ∈ Submonoid.closure S := by rw [closure_inv, mem_inv]\n\n"}
{"name":"AddSubmonoid.coe_pointwise_smul","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : Monoid α\ninst✝ : DistribMulAction α A\na : α\nS : AddSubmonoid A\n⊢ Eq (↑(HSMul.hSMul a S)) (HSMul.hSMul a ↑S)","decl":"@[simp]\ntheorem coe_pointwise_smul (a : α) (S : AddSubmonoid A) : ↑(a • S) = a • (S : Set A) :=\n  rfl\n\n"}
{"name":"AddSubmonoid.smul_mem_pointwise_smul","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : Monoid α\ninst✝ : DistribMulAction α A\nm : A\na : α\nS : AddSubmonoid A\na✝ : Membership.mem S m\n⊢ Membership.mem (HSMul.hSMul a S) (HSMul.hSMul a m)","decl":"theorem smul_mem_pointwise_smul (m : A) (a : α) (S : AddSubmonoid A) : m ∈ S → a • m ∈ a • S :=\n  (Set.smul_mem_smul_set : _ → _ ∈ a • (S : Set A))\n\n"}
{"name":"AddSubmonoid.mem_smul_pointwise_iff_exists","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : Monoid α\ninst✝ : DistribMulAction α A\nm : A\na : α\nS : AddSubmonoid A\n⊢ Iff (Membership.mem (HSMul.hSMul a S) m) (Exists fun s => And (Membership.mem S s) (Eq (HSMul.hSMul a s) m))","decl":"theorem mem_smul_pointwise_iff_exists (m : A) (a : α) (S : AddSubmonoid A) :\n    m ∈ a • S ↔ ∃ s : A, s ∈ S ∧ a • s = m :=\n  (Set.mem_smul_set : m ∈ a • (S : Set A) ↔ _)\n\n"}
{"name":"AddSubmonoid.smul_bot","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : Monoid α\ninst✝ : DistribMulAction α A\na : α\n⊢ Eq (HSMul.hSMul a Bot.bot) Bot.bot","decl":"@[simp]\ntheorem smul_bot (a : α) : a • (⊥ : AddSubmonoid A) = ⊥ :=\n  map_bot _\n\n"}
{"name":"AddSubmonoid.smul_sup","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : Monoid α\ninst✝ : DistribMulAction α A\na : α\nS T : AddSubmonoid A\n⊢ Eq (HSMul.hSMul a (Max.max S T)) (Max.max (HSMul.hSMul a S) (HSMul.hSMul a T))","decl":"theorem smul_sup (a : α) (S T : AddSubmonoid A) : a • (S ⊔ T) = a • S ⊔ a • T :=\n  map_sup _ _ _\n\n"}
{"name":"AddSubmonoid.smul_closure","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : Monoid α\ninst✝ : DistribMulAction α A\na : α\ns : Set A\n⊢ Eq (HSMul.hSMul a (AddSubmonoid.closure s)) (AddSubmonoid.closure (HSMul.hSMul a s))","decl":"@[simp]\ntheorem smul_closure (a : α) (s : Set A) : a • closure s = closure (a • s) :=\n  AddMonoidHom.map_mclosure _ _\n\n"}
{"name":"AddSubmonoid.pointwise_isCentralScalar","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nA : Type u_5\ninst✝⁴ : AddMonoid A\ninst✝³ : Monoid α\ninst✝² : DistribMulAction α A\ninst✝¹ : DistribMulAction (MulOpposite α) A\ninst✝ : IsCentralScalar α A\n⊢ IsCentralScalar α (AddSubmonoid A)","decl":"lemma pointwise_isCentralScalar [DistribMulAction αᵐᵒᵖ A] [IsCentralScalar α A] :\n    IsCentralScalar α (AddSubmonoid A) :=\n  ⟨fun _ S =>\n    (congr_arg fun f : AddMonoid.End A => S.map f) <| AddMonoidHom.ext <| op_smul_eq_smul _⟩\n\n"}
{"name":"AddSubmonoid.smul_mem_pointwise_smul_iff","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : Group α\ninst✝ : DistribMulAction α A\na : α\nS : AddSubmonoid A\nx : A\n⊢ Iff (Membership.mem (HSMul.hSMul a S) (HSMul.hSMul a x)) (Membership.mem S x)","decl":"@[simp]\ntheorem smul_mem_pointwise_smul_iff {a : α} {S : AddSubmonoid A} {x : A} : a • x ∈ a • S ↔ x ∈ S :=\n  smul_mem_smul_set_iff\n\n"}
{"name":"AddSubmonoid.mem_pointwise_smul_iff_inv_smul_mem","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : Group α\ninst✝ : DistribMulAction α A\na : α\nS : AddSubmonoid A\nx : A\n⊢ Iff (Membership.mem (HSMul.hSMul a S) x) (Membership.mem S (HSMul.hSMul (Inv.inv a) x))","decl":"theorem mem_pointwise_smul_iff_inv_smul_mem {a : α} {S : AddSubmonoid A} {x : A} :\n    x ∈ a • S ↔ a⁻¹ • x ∈ S :=\n  mem_smul_set_iff_inv_smul_mem\n\n"}
{"name":"AddSubmonoid.mem_inv_pointwise_smul_iff","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : Group α\ninst✝ : DistribMulAction α A\na : α\nS : AddSubmonoid A\nx : A\n⊢ Iff (Membership.mem (HSMul.hSMul (Inv.inv a) S) x) (Membership.mem S (HSMul.hSMul a x))","decl":"theorem mem_inv_pointwise_smul_iff {a : α} {S : AddSubmonoid A} {x : A} : x ∈ a⁻¹ • S ↔ a • x ∈ S :=\n  mem_inv_smul_set_iff\n\n"}
{"name":"AddSubmonoid.pointwise_smul_le_pointwise_smul_iff","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : Group α\ninst✝ : DistribMulAction α A\na : α\nS T : AddSubmonoid A\n⊢ Iff (LE.le (HSMul.hSMul a S) (HSMul.hSMul a T)) (LE.le S T)","decl":"@[simp]\ntheorem pointwise_smul_le_pointwise_smul_iff {a : α} {S T : AddSubmonoid A} :\n    a • S ≤ a • T ↔ S ≤ T :=\n  smul_set_subset_smul_set_iff\n\n"}
{"name":"AddSubmonoid.pointwise_smul_le_iff","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : Group α\ninst✝ : DistribMulAction α A\na : α\nS T : AddSubmonoid A\n⊢ Iff (LE.le (HSMul.hSMul a S) T) (LE.le S (HSMul.hSMul (Inv.inv a) T))","decl":"theorem pointwise_smul_le_iff {a : α} {S T : AddSubmonoid A} : a • S ≤ T ↔ S ≤ a⁻¹ • T :=\n  smul_set_subset_iff_subset_inv_smul_set\n\n"}
{"name":"AddSubmonoid.le_pointwise_smul_iff","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : Group α\ninst✝ : DistribMulAction α A\na : α\nS T : AddSubmonoid A\n⊢ Iff (LE.le S (HSMul.hSMul a T)) (LE.le (HSMul.hSMul (Inv.inv a) S) T)","decl":"theorem le_pointwise_smul_iff {a : α} {S T : AddSubmonoid A} : S ≤ a • T ↔ a⁻¹ • S ≤ T :=\n  subset_smul_set_iff\n\n"}
{"name":"AddSubmonoid.smul_mem_pointwise_smul_iff₀","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : GroupWithZero α\ninst✝ : DistribMulAction α A\na : α\nha : Ne a 0\nS : AddSubmonoid A\nx : A\n⊢ Iff (Membership.mem (HSMul.hSMul a S) (HSMul.hSMul a x)) (Membership.mem S x)","decl":"@[simp]\ntheorem smul_mem_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) (S : AddSubmonoid A) (x : A) :\n    a • x ∈ a • S ↔ x ∈ S :=\n  smul_mem_smul_set_iff₀ ha (S : Set A) x\n\n"}
{"name":"AddSubmonoid.mem_pointwise_smul_iff_inv_smul_mem₀","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : GroupWithZero α\ninst✝ : DistribMulAction α A\na : α\nha : Ne a 0\nS : AddSubmonoid A\nx : A\n⊢ Iff (Membership.mem (HSMul.hSMul a S) x) (Membership.mem S (HSMul.hSMul (Inv.inv a) x))","decl":"theorem mem_pointwise_smul_iff_inv_smul_mem₀ {a : α} (ha : a ≠ 0) (S : AddSubmonoid A) (x : A) :\n    x ∈ a • S ↔ a⁻¹ • x ∈ S :=\n  mem_smul_set_iff_inv_smul_mem₀ ha (S : Set A) x\n\n"}
{"name":"AddSubmonoid.mem_inv_pointwise_smul_iff₀","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : GroupWithZero α\ninst✝ : DistribMulAction α A\na : α\nha : Ne a 0\nS : AddSubmonoid A\nx : A\n⊢ Iff (Membership.mem (HSMul.hSMul (Inv.inv a) S) x) (Membership.mem S (HSMul.hSMul a x))","decl":"theorem mem_inv_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) (S : AddSubmonoid A) (x : A) :\n    x ∈ a⁻¹ • S ↔ a • x ∈ S :=\n  mem_inv_smul_set_iff₀ ha (S : Set A) x\n\n"}
{"name":"AddSubmonoid.pointwise_smul_le_pointwise_smul_iff₀","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : GroupWithZero α\ninst✝ : DistribMulAction α A\na : α\nha : Ne a 0\nS T : AddSubmonoid A\n⊢ Iff (LE.le (HSMul.hSMul a S) (HSMul.hSMul a T)) (LE.le S T)","decl":"@[simp]\ntheorem pointwise_smul_le_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) {S T : AddSubmonoid A} :\n    a • S ≤ a • T ↔ S ≤ T :=\n  smul_set_subset_smul_set_iff₀ ha\n\n"}
{"name":"AddSubmonoid.pointwise_smul_le_iff₀","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : GroupWithZero α\ninst✝ : DistribMulAction α A\na : α\nha : Ne a 0\nS T : AddSubmonoid A\n⊢ Iff (LE.le (HSMul.hSMul a S) T) (LE.le S (HSMul.hSMul (Inv.inv a) T))","decl":"theorem pointwise_smul_le_iff₀ {a : α} (ha : a ≠ 0) {S T : AddSubmonoid A} :\n    a • S ≤ T ↔ S ≤ a⁻¹ • T :=\n  smul_set_subset_iff₀ ha\n\n"}
{"name":"AddSubmonoid.le_pointwise_smul_iff₀","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : GroupWithZero α\ninst✝ : DistribMulAction α A\na : α\nha : Ne a 0\nS T : AddSubmonoid A\n⊢ Iff (LE.le S (HSMul.hSMul a T)) (LE.le (HSMul.hSMul (Inv.inv a) S) T)","decl":"theorem le_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) {S T : AddSubmonoid A} :\n    S ≤ a • T ↔ a⁻¹ • S ≤ T :=\n  subset_smul_set_iff₀ ha\n\n"}
{"name":"AddSubmonoid.one_eq_mrange","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\ninst✝ : AddMonoidWithOne R\n⊢ Eq 1 (AddMonoidHom.mrange (Nat.castAddMonoidHom R))","decl":"theorem one_eq_mrange : (1 : AddSubmonoid R) = AddMonoidHom.mrange (Nat.castAddMonoidHom R) :=\n  rfl\n\n"}
{"name":"AddSubmonoid.natCast_mem_one","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\ninst✝ : AddMonoidWithOne R\nn : Nat\n⊢ Membership.mem 1 ↑n","decl":"theorem natCast_mem_one (n : ℕ) : (n : R) ∈ (1 : AddSubmonoid R) :=\n  ⟨_, rfl⟩\n\n"}
{"name":"AddSubmonoid.mem_one","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\ninst✝ : AddMonoidWithOne R\nx : R\n⊢ Iff (Membership.mem 1 x) (Exists fun n => Eq (↑n) x)","decl":"@[simp]\ntheorem mem_one {x : R} : x ∈ (1 : AddSubmonoid R) ↔ ∃ n : ℕ, ↑n = x :=\n  Iff.rfl\n\n"}
{"name":"AddSubmonoid.one_eq_closure","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\ninst✝ : AddMonoidWithOne R\n⊢ Eq 1 (AddSubmonoid.closure (Singleton.singleton 1))","decl":"theorem one_eq_closure : (1 : AddSubmonoid R) = closure {1} := by\n  rw [closure_singleton_eq, one_eq_mrange]\n  congr 1\n  ext\n  simp\n\n"}
{"name":"AddSubmonoid.one_eq_closure_one_set","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\ninst✝ : AddMonoidWithOne R\n⊢ Eq 1 (AddSubmonoid.closure 1)","decl":"theorem one_eq_closure_one_set : (1 : AddSubmonoid R) = closure 1 :=\n  one_eq_closure\n\n"}
{"name":"AddSubmonoid.smul_mem_smul","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : AddMonoid R\ninst✝ : DistribSMul R A\nM : AddSubmonoid R\nN : AddSubmonoid A\nm : R\nn : A\nhm : Membership.mem M m\nhn : Membership.mem N n\n⊢ Membership.mem (HSMul.hSMul M N) (HSMul.hSMul m n)","decl":"theorem smul_mem_smul (hm : m ∈ M) (hn : n ∈ N) : m • n ∈ M • N :=\n  (le_iSup _ ⟨m, hm⟩ : _ ≤ M • N) ⟨n, hn, by rfl⟩\n\n"}
{"name":"AddSubmonoid.smul_le","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : AddMonoid R\ninst✝ : DistribSMul R A\nM : AddSubmonoid R\nN P : AddSubmonoid A\n⊢ Iff (LE.le (HSMul.hSMul M N) P) (∀ (m : R), Membership.mem M m → ∀ (n : A), Membership.mem N n → Membership.mem P (HSMul.hSMul m n))","decl":"theorem smul_le : M • N ≤ P ↔ ∀ m ∈ M, ∀ n ∈ N, m • n ∈ P :=\n  ⟨fun H _m hm _n hn => H <| smul_mem_smul hm hn, fun H =>\n    iSup_le fun ⟨m, hm⟩ => map_le_iff_le_comap.2 fun n hn => H m hm n hn⟩\n\n"}
{"name":"AddSubmonoid.smul_induction_on","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : AddMonoid R\ninst✝ : DistribSMul R A\nM : AddSubmonoid R\nN : AddSubmonoid A\nC : A → Prop\na : A\nha : Membership.mem (HSMul.hSMul M N) a\nhm : ∀ (m : R), Membership.mem M m → ∀ (n : A), Membership.mem N n → C (HSMul.hSMul m n)\nhadd : ∀ (x y : A), C x → C y → C (HAdd.hAdd x y)\n⊢ C a","decl":"@[elab_as_elim]\nprotected theorem smul_induction_on {C : A → Prop} {a : A} (ha : a ∈ M • N)\n    (hm : ∀ m ∈ M, ∀ n ∈ N, C (m • n)) (hadd : ∀ x y, C x → C y → C (x + y)) : C a :=\n  (@smul_le _ _ _ _ _ _ _ ⟨⟨setOf C, hadd _ _⟩, by\n    simpa only [smul_zero] using hm _ (zero_mem _) _ (zero_mem _)⟩).2 hm ha\n\n"}
{"name":"AddSubmonoid.addSubmonoid_smul_bot","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : AddMonoid R\ninst✝ : DistribSMul R A\nS : AddSubmonoid R\n⊢ Eq (HSMul.hSMul S Bot.bot) Bot.bot","decl":"@[simp]\ntheorem addSubmonoid_smul_bot (S : AddSubmonoid R) : S • (⊥ : AddSubmonoid A) = ⊥ :=\n  eq_bot_iff.2 <| smul_le.2 fun m _ n hn => by\n    rw [AddSubmonoid.mem_bot] at hn ⊢; rw [hn, smul_zero]\n\n"}
{"name":"AddSubmonoid.smul_le_smul","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : AddMonoid R\ninst✝ : DistribSMul R A\nM M' : AddSubmonoid R\nN P : AddSubmonoid A\nh : LE.le M M'\nhnp : LE.le N P\n⊢ LE.le (HSMul.hSMul M N) (HSMul.hSMul M' P)","decl":"theorem smul_le_smul (h : M ≤ M') (hnp : N ≤ P) : M • N ≤ M' • P :=\n  smul_le.2 fun _m hm _n hn => smul_mem_smul (h hm) (hnp hn)\n\n"}
{"name":"AddSubmonoid.smul_le_smul_left","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : AddMonoid R\ninst✝ : DistribSMul R A\nM M' : AddSubmonoid R\nP : AddSubmonoid A\nh : LE.le M M'\n⊢ LE.le (HSMul.hSMul M P) (HSMul.hSMul M' P)","decl":"theorem smul_le_smul_left (h : M ≤ M') : M • P ≤ M' • P :=\n  smul_le_smul h le_rfl\n\n"}
{"name":"AddSubmonoid.smul_le_smul_right","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : AddMonoid R\ninst✝ : DistribSMul R A\nM : AddSubmonoid R\nN P : AddSubmonoid A\nh : LE.le N P\n⊢ LE.le (HSMul.hSMul M N) (HSMul.hSMul M P)","decl":"theorem smul_le_smul_right (h : N ≤ P) : M • N ≤ M • P :=\n  smul_le_smul le_rfl h\n\n"}
{"name":"AddSubmonoid.smul_subset_smul","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : AddMonoid R\ninst✝ : DistribSMul R A\nM : AddSubmonoid R\nN : AddSubmonoid A\n⊢ HasSubset.Subset (HSMul.hSMul ↑M ↑N) ↑(HSMul.hSMul M N)","decl":"theorem smul_subset_smul : (↑M : Set R) • (↑N : Set A) ⊆ (↑(M • N) : Set A) :=\n  smul_subset_iff.2 fun _i hi _j hj ↦ smul_mem_smul hi hj\n\n"}
{"name":"AddSubmonoid.addSubmonoid_smul_sup","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : AddMonoid R\ninst✝ : DistribSMul R A\nM : AddSubmonoid R\nN P : AddSubmonoid A\n⊢ Eq (HSMul.hSMul M (Max.max N P)) (Max.max (HSMul.hSMul M N) (HSMul.hSMul M P))","decl":"theorem addSubmonoid_smul_sup : M • (N ⊔ P) = M • N ⊔ M • P :=\n  le_antisymm (smul_le.mpr fun m hm np hnp ↦ by\n    refine closure_induction (p := (fun _ ↦ _ • · ∈ _)) ?_ ?_ ?_ (sup_eq_closure N P ▸ hnp)\n    · rintro x (hx | hx)\n      exacts [le_sup_left (a := M • N) (smul_mem_smul hm hx),\n        le_sup_right (a := M • N) (smul_mem_smul hm hx)]\n    · apply (smul_zero (A := A) m).symm ▸ (M • N ⊔ M • P).zero_mem\n    · intros _ _ _ _ h1 h2; rw [smul_add]; exact add_mem h1 h2)\n  (sup_le (smul_le_smul_right le_sup_left) <| smul_le_smul_right le_sup_right)\n\n"}
{"name":"AddSubmonoid.smul_iSup","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : AddMonoid R\ninst✝ : DistribSMul R A\nι : Sort u_7\nT : AddSubmonoid R\nS : ι → AddSubmonoid A\n⊢ Eq (HSMul.hSMul T (iSup fun i => S i)) (iSup fun i => HSMul.hSMul T (S i))","decl":"theorem smul_iSup (T : AddSubmonoid R) (S : ι → AddSubmonoid A) : (T • ⨆ i, S i) = ⨆ i, T • S i :=\n  le_antisymm (smul_le.mpr fun t ht s hs ↦ iSup_induction _ (C := (t • · ∈ _)) hs\n    (fun i s hs ↦ mem_iSup_of_mem i <| smul_mem_smul ht hs)\n    (by simp_rw [smul_zero]; apply zero_mem) fun x y ↦ by simp_rw [smul_add]; apply add_mem)\n  (iSup_le fun i ↦ smul_le_smul_right <| le_iSup _ i)\n\n"}
{"name":"AddSubmonoid.mul_mem_mul","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\ninst✝ : NonUnitalNonAssocSemiring R\nM N : AddSubmonoid R\nm n : R\nhm : Membership.mem M m\nhn : Membership.mem N n\n⊢ Membership.mem (HMul.hMul M N) (HMul.hMul m n)","decl":"theorem mul_mem_mul {M N : AddSubmonoid R} {m n : R} (hm : m ∈ M) (hn : n ∈ N) : m * n ∈ M * N :=\n  smul_mem_smul hm hn\n\n"}
{"name":"AddSubmonoid.mul_le","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\ninst✝ : NonUnitalNonAssocSemiring R\nM N P : AddSubmonoid R\n⊢ Iff (LE.le (HMul.hMul M N) P) (∀ (m : R), Membership.mem M m → ∀ (n : R), Membership.mem N n → Membership.mem P (HMul.hMul m n))","decl":"theorem mul_le {M N P : AddSubmonoid R} : M * N ≤ P ↔ ∀ m ∈ M, ∀ n ∈ N, m * n ∈ P :=\n  smul_le\n\n"}
{"name":"AddSubmonoid.mul_induction_on","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\ninst✝ : NonUnitalNonAssocSemiring R\nM N : AddSubmonoid R\nC : R → Prop\nr : R\nhr : Membership.mem (HMul.hMul M N) r\nhm : ∀ (m : R), Membership.mem M m → ∀ (n : R), Membership.mem N n → C (HMul.hMul m n)\nha : ∀ (x y : R), C x → C y → C (HAdd.hAdd x y)\n⊢ C r","decl":"@[elab_as_elim]\nprotected theorem mul_induction_on {M N : AddSubmonoid R} {C : R → Prop} {r : R} (hr : r ∈ M * N)\n    (hm : ∀ m ∈ M, ∀ n ∈ N, C (m * n)) (ha : ∀ x y, C x → C y → C (x + y)) : C r :=\n  AddSubmonoid.smul_induction_on hr hm ha\n\n-- this proof is copied directly from `Submodule.span_mul_span`\n-- Porting note: proof rewritten\n-- need `add_smul` to generalize to `SMul`\n"}
{"name":"AddSubmonoid.closure_mul_closure","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\ninst✝ : NonUnitalNonAssocSemiring R\nS T : Set R\n⊢ Eq (HMul.hMul (AddSubmonoid.closure S) (AddSubmonoid.closure T)) (AddSubmonoid.closure (HMul.hMul S T))","decl":"theorem closure_mul_closure (S T : Set R) : closure S * closure T = closure (S * T) := by\n  apply le_antisymm\n  · refine mul_le.2 fun a ha b hb => ?_\n    rw [← AddMonoidHom.mulRight_apply, ← AddSubmonoid.mem_comap]\n    refine (closure_le.2 fun a' ha' => ?_) ha\n    change b ∈ (closure (S * T)).comap (AddMonoidHom.mulLeft a')\n    refine (closure_le.2 fun b' hb' => ?_) hb\n    change a' * b' ∈ closure (S * T)\n    exact subset_closure (Set.mul_mem_mul ha' hb')\n  · rw [closure_le]\n    rintro _ ⟨a, ha, b, hb, rfl⟩\n    exact mul_mem_mul (subset_closure ha) (subset_closure hb)\n\n"}
{"name":"AddSubmonoid.mul_eq_closure_mul_set","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\ninst✝ : NonUnitalNonAssocSemiring R\nM N : AddSubmonoid R\n⊢ Eq (HMul.hMul M N) (AddSubmonoid.closure (HMul.hMul ↑M ↑N))","decl":"theorem mul_eq_closure_mul_set (M N : AddSubmonoid R) :\n    M * N = closure ((M : Set R) * (N : Set R)) := by\n  rw [← closure_mul_closure, closure_eq, closure_eq]\n\n"}
{"name":"AddSubmonoid.mul_bot","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\ninst✝ : NonUnitalNonAssocSemiring R\nS : AddSubmonoid R\n⊢ Eq (HMul.hMul S Bot.bot) Bot.bot","decl":"@[simp]\ntheorem mul_bot (S : AddSubmonoid R) : S * ⊥ = ⊥ :=\n  addSubmonoid_smul_bot S\n\n-- need `zero_smul` to generalize to `SMul`\n"}
{"name":"AddSubmonoid.bot_mul","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\ninst✝ : NonUnitalNonAssocSemiring R\nS : AddSubmonoid R\n⊢ Eq (HMul.hMul Bot.bot S) Bot.bot","decl":"@[simp]\ntheorem bot_mul (S : AddSubmonoid R) : ⊥ * S = ⊥ :=\n  eq_bot_iff.2 <| mul_le.2 fun m hm n _ => by\n    rw [AddSubmonoid.mem_bot] at hm ⊢; rw [hm, zero_mul]\n\n"}
{"name":"AddSubmonoid.mul_le_mul","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\ninst✝ : NonUnitalNonAssocSemiring R\nM N P Q : AddSubmonoid R\nhmp : LE.le M P\nhnq : LE.le N Q\n⊢ LE.le (HMul.hMul M N) (HMul.hMul P Q)","decl":"@[mono, gcongr] lemma mul_le_mul (hmp : M ≤ P) (hnq : N ≤ Q) : M * N ≤ P * Q := smul_le_smul hmp hnq\n\n"}
{"name":"AddSubmonoid.mul_le_mul_left","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\ninst✝ : NonUnitalNonAssocSemiring R\nM N P : AddSubmonoid R\nh : LE.le M N\n⊢ LE.le (HMul.hMul M P) (HMul.hMul N P)","decl":"@[gcongr] lemma mul_le_mul_left (h : M ≤ N) : M * P ≤ N * P := smul_le_smul_left h\n"}
{"name":"AddSubmonoid.mul_le_mul_right","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\ninst✝ : NonUnitalNonAssocSemiring R\nM N P : AddSubmonoid R\nh : LE.le N P\n⊢ LE.le (HMul.hMul M N) (HMul.hMul M P)","decl":"@[gcongr] lemma mul_le_mul_right (h : N ≤ P) : M * N ≤ M * P := smul_le_smul_right h\n\n"}
{"name":"AddSubmonoid.mul_subset_mul","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\ninst✝ : NonUnitalNonAssocSemiring R\nM N : AddSubmonoid R\n⊢ HasSubset.Subset (HMul.hMul ↑M ↑N) ↑(HMul.hMul M N)","decl":"theorem mul_subset_mul : (↑M : Set R) * (↑N : Set R) ⊆ (↑(M * N) : Set R) :=\n  smul_subset_smul\n\n"}
{"name":"AddSubmonoid.mul_sup","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\ninst✝ : NonUnitalNonAssocSemiring R\nM N P : AddSubmonoid R\n⊢ Eq (HMul.hMul M (Max.max N P)) (Max.max (HMul.hMul M N) (HMul.hMul M P))","decl":"theorem mul_sup : M * (N ⊔ P) = M * N ⊔ M * P :=\n  addSubmonoid_smul_sup\n\n-- need `zero_smul` and `add_smul` to generalize to `SMul`\n"}
{"name":"AddSubmonoid.sup_mul","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\ninst✝ : NonUnitalNonAssocSemiring R\nM N P : AddSubmonoid R\n⊢ Eq (HMul.hMul (Max.max M N) P) (Max.max (HMul.hMul M P) (HMul.hMul N P))","decl":"theorem sup_mul : (M ⊔ N) * P = M * P ⊔ N * P :=\n  le_antisymm (mul_le.mpr fun mn hmn p hp ↦ by\n    obtain ⟨m, hm, n, hn, rfl⟩ := mem_sup.mp hmn\n    rw [right_distrib]; exact add_mem_sup (mul_mem_mul hm hp) <| mul_mem_mul hn hp)\n    (sup_le (mul_le_mul_left le_sup_left) <| mul_le_mul_left le_sup_right)\n\n"}
{"name":"AddSubmonoid.iSup_mul","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\ninst✝ : NonUnitalNonAssocSemiring R\nι : Sort u_7\nS : ι → AddSubmonoid R\nT : AddSubmonoid R\n⊢ Eq (HMul.hMul (iSup fun i => S i) T) (iSup fun i => HMul.hMul (S i) T)","decl":"theorem iSup_mul (S : ι → AddSubmonoid R) (T : AddSubmonoid R) : (⨆ i, S i) * T = ⨆ i, S i * T :=\n  le_antisymm (mul_le.mpr fun s hs t ht ↦ iSup_induction _ (C := (· * t ∈ _)) hs\n      (fun i s hs ↦ mem_iSup_of_mem i <| mul_mem_mul hs ht) (by simp_rw [zero_mul]; apply zero_mem)\n      fun _ _ ↦ by simp_rw [right_distrib]; apply add_mem) <|\n    iSup_le fun i ↦ mul_le_mul_left (le_iSup _ i)\n\n"}
{"name":"AddSubmonoid.mul_iSup","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\ninst✝ : NonUnitalNonAssocSemiring R\nι : Sort u_7\nT : AddSubmonoid R\nS : ι → AddSubmonoid R\n⊢ Eq (HMul.hMul T (iSup fun i => S i)) (iSup fun i => HMul.hMul T (S i))","decl":"theorem mul_iSup (T : AddSubmonoid R) (S : ι → AddSubmonoid R) : (T * ⨆ i, S i) = ⨆ i, T * S i :=\n  smul_iSup T S\n\n"}
{"name":"AddSubmonoid.mul_comm_of_commute","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\ninst✝ : NonUnitalNonAssocSemiring R\nM N : AddSubmonoid R\nh : ∀ (m : R), Membership.mem M m → ∀ (n : R), Membership.mem N n → Commute m n\n⊢ Eq (HMul.hMul M N) (HMul.hMul N M)","decl":"theorem mul_comm_of_commute (h : ∀ m ∈ M, ∀ n ∈ N, Commute m n) : M * N = N * M :=\n  le_antisymm (mul_le.mpr fun m hm n hn ↦ h m hm n hn ▸ mul_mem_mul hn hm)\n    (mul_le.mpr fun n hn m hm ↦ h m hm n hn ▸ mul_mem_mul hm hn)\n\n"}
{"name":"AddSubmonoid.closure_pow","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\ninst✝ : Semiring R\ns : Set R\nn : Nat\n⊢ Eq (HPow.hPow (AddSubmonoid.closure s) n) (AddSubmonoid.closure (HPow.hPow s n))","decl":"theorem closure_pow (s : Set R) : ∀ n : ℕ, closure s ^ n = closure (s ^ n)\n  | 0 => by rw [pow_zero, pow_zero, one_eq_closure_one_set]\n  | n + 1 => by rw [pow_succ, pow_succ, closure_pow s n, closure_mul_closure]\n\n"}
{"name":"AddSubmonoid.pow_eq_closure_pow_set","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\ninst✝ : Semiring R\ns : AddSubmonoid R\nn : Nat\n⊢ Eq (HPow.hPow s n) (AddSubmonoid.closure (HPow.hPow (↑s) n))","decl":"theorem pow_eq_closure_pow_set (s : AddSubmonoid R) (n : ℕ) :\n    s ^ n = closure ((s : Set R) ^ n) := by\n  rw [← closure_pow, closure_eq]\n\n"}
{"name":"AddSubmonoid.pow_subset_pow","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"R : Type u_4\ninst✝ : Semiring R\ns : AddSubmonoid R\nn : Nat\n⊢ HasSubset.Subset (HPow.hPow (↑s) n) ↑(HPow.hPow s n)","decl":"theorem pow_subset_pow {s : AddSubmonoid R} {n : ℕ} : (↑s : Set R) ^ n ⊆ ↑(s ^ n) :=\n  (pow_eq_closure_pow_set s n).symm ▸ subset_closure\n\n"}
{"name":"Set.IsPWO.addSubmonoid_closure","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\ninst✝ : OrderedCancelAddCommMonoid α\ns : Set α\nhpos : ∀ (x : α), Membership.mem s x → LE.le 0 x\nh : s.IsPWO\n⊢ (↑(AddSubmonoid.closure s)).IsPWO","decl":"@[to_additive]\ntheorem submonoid_closure (hpos : ∀ x : α, x ∈ s → 1 ≤ x) (h : s.IsPWO) :\n    IsPWO (Submonoid.closure s : Set α) := by\n  rw [Submonoid.closure_eq_image_prod]\n  refine (h.partiallyWellOrderedOn_sublistForall₂ (· ≤ ·)).image_of_monotone_on ?_\n  exact fun l1 _ l2 hl2 h12 => h12.prod_le_prod' fun x hx => hpos x <| hl2 x hx\n\n"}
{"name":"Set.IsPWO.submonoid_closure","module":"Mathlib.Algebra.Group.Submonoid.Pointwise","initialProofState":"α : Type u_1\ninst✝ : OrderedCancelCommMonoid α\ns : Set α\nhpos : ∀ (x : α), Membership.mem s x → LE.le 1 x\nh : s.IsPWO\n⊢ (↑(Submonoid.closure s)).IsPWO","decl":"@[to_additive]\ntheorem submonoid_closure (hpos : ∀ x : α, x ∈ s → 1 ≤ x) (h : s.IsPWO) :\n    IsPWO (Submonoid.closure s : Set α) := by\n  rw [Submonoid.closure_eq_image_prod]\n  refine (h.partiallyWellOrderedOn_sublistForall₂ (· ≤ ·)).image_of_monotone_on ?_\n  exact fun l1 _ l2 hl2 h12 => h12.prod_le_prod' fun x hx => hpos x <| hl2 x hx\n\n"}
