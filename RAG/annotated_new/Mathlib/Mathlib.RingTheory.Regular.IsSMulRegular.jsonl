{"name":"LinearEquiv.isSMulRegular_congr'","module":"Mathlib.RingTheory.Regular.IsSMulRegular","initialProofState":"R : Type u_3\nS : Type u_2\nM : Type u_4\nN : Type u_1\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\nσ : RingHom R S\nσ' : RingHom S R\ninst✝⁵ : RingHomInvPair σ σ'\ninst✝⁴ : RingHomInvPair σ' σ\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module S N\ne : LinearEquiv σ M N\nr : R\n⊢ Iff (IsSMulRegular M r) (IsSMulRegular N (σ r))","decl":"lemma LinearEquiv.isSMulRegular_congr' [AddCommMonoid N] [Module S N]\n    (e : M ≃ₛₗ[σ] N) (r : R) : IsSMulRegular M r ↔ IsSMulRegular N (σ r) :=\n  e.toEquiv.isSMulRegular_congr (e.map_smul' r)\n\n"}
{"name":"LinearEquiv.isSMulRegular_congr","module":"Mathlib.RingTheory.Regular.IsSMulRegular","initialProofState":"R : Type u_2\nM : Type u_3\nN : Type u_1\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\ne : LinearEquiv (RingHom.id R) M N\nr : R\n⊢ Iff (IsSMulRegular M r) (IsSMulRegular N r)","decl":"lemma LinearEquiv.isSMulRegular_congr [AddCommMonoid N] [Module R N]\n    (e : M ≃ₗ[R] N) (r : R) : IsSMulRegular M r ↔ IsSMulRegular N r :=\n  e.isSMulRegular_congr' r\n\n"}
{"name":"IsSMulRegular.submodule","module":"Mathlib.RingTheory.Regular.IsSMulRegular","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nN : Submodule R M\nr : R\nh : IsSMulRegular M r\n⊢ IsSMulRegular (Subtype fun x => Membership.mem N x) r","decl":"lemma IsSMulRegular.submodule [Semiring R] [AddCommMonoid M] [Module R M]\n    (N : Submodule R M) (r : R) (h : IsSMulRegular M r) : IsSMulRegular N r :=\n  h.of_injective N.subtype N.injective_subtype\n\n"}
{"name":"IsSMulRegular.lTensor","module":"Mathlib.RingTheory.Regular.IsSMulRegular","initialProofState":"R : Type u_1\nM : Type u_3\nM' : Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\ninst✝ : Module.Flat R M\nr : R\nh : IsSMulRegular M' r\n⊢ IsSMulRegular (TensorProduct R M M') r","decl":"lemma IsSMulRegular.lTensor : IsSMulRegular (M ⊗[R] M') r :=\n  have h1 := congrArg DFunLike.coe (LinearMap.lTensor_smul_action M M' r)\n  h1.subst (Module.Flat.lTensor_preserves_injective_linearMap _ h)\n\n"}
{"name":"IsSMulRegular.rTensor","module":"Mathlib.RingTheory.Regular.IsSMulRegular","initialProofState":"R : Type u_1\nM : Type u_3\nM' : Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\ninst✝ : Module.Flat R M\nr : R\nh : IsSMulRegular M' r\n⊢ IsSMulRegular (TensorProduct R M' M) r","decl":"lemma IsSMulRegular.rTensor : IsSMulRegular (M' ⊗[R] M) r :=\n  have h1 := congrArg DFunLike.coe (LinearMap.rTensor_smul_action M M' r)\n  h1.subst (Module.Flat.rTensor_preserves_injective_linearMap _ h)\n\n"}
{"name":"isSMulRegular_algebraMap_iff","module":"Mathlib.RingTheory.Regular.IsSMulRegular","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring S\ninst✝⁴ : Algebra R S\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\nr : R\n⊢ Iff (IsSMulRegular M ((algebraMap R S) r)) (IsSMulRegular M r)","decl":"lemma isSMulRegular_algebraMap_iff [CommSemiring R] [Semiring S] [Algebra R S]\n    [AddCommMonoid M] [Module R M] [Module S M] [IsScalarTower R S M] (r : R) :\n    IsSMulRegular M (algebraMap R S r) ↔ IsSMulRegular M r :=\n  (Equiv.refl M).isSMulRegular_congr (algebraMap_smul S r)\n\n"}
{"name":"isSMulRegular_iff_smul_eq_zero_imp_eq_zero","module":"Mathlib.RingTheory.Regular.IsSMulRegular","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\n⊢ Iff (IsSMulRegular M r) (∀ (x : M), Eq (HSMul.hSMul r x) 0 → Eq x 0)","decl":"lemma isSMulRegular_iff_smul_eq_zero_imp_eq_zero :\n    IsSMulRegular M r ↔ ∀ x : M, r • x = 0 → x = 0 :=\n  Iff.trans (Module.toAddMonoidEnd R M r).ker_eq_bot_iff.symm\n    <| AddSubgroup.eq_bot_iff_forall _\n\n"}
{"name":"isSMulRegular_iff_mem_nonZeroSMulDivisors","module":"Mathlib.RingTheory.Regular.IsSMulRegular","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\n⊢ Iff (IsSMulRegular M r) (Membership.mem (nonZeroSMulDivisors R M) r)","decl":"lemma isSMulRegular_iff_mem_nonZeroSMulDivisors :\n    IsSMulRegular M r ↔ r ∈ nonZeroSMulDivisors R M :=\n  isSMulRegular_iff_smul_eq_zero_imp_eq_zero M r\n\n"}
{"name":"isSMulRegular_of_smul_eq_zero_imp_eq_zero","module":"Mathlib.RingTheory.Regular.IsSMulRegular","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\nh : ∀ (x : M), Eq (HSMul.hSMul r x) 0 → Eq x 0\n⊢ IsSMulRegular M r","decl":"lemma isSMulRegular_of_smul_eq_zero_imp_eq_zero\n    (h : ∀ x : M, r • x = 0 → x = 0) : IsSMulRegular M r :=\n  (isSMulRegular_iff_smul_eq_zero_imp_eq_zero M r).mpr h\n\n"}
{"name":"isSMulRegular_on_submodule_iff_mem_imp_smul_eq_zero_imp_eq_zero","module":"Mathlib.RingTheory.Regular.IsSMulRegular","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nN : Submodule R M\nr : R\n⊢ Iff (IsSMulRegular (Subtype fun x => Membership.mem N x) r) (∀ (x : M), Membership.mem N x → Eq (HSMul.hSMul r x) 0 → Eq x 0)","decl":"lemma isSMulRegular_on_submodule_iff_mem_imp_smul_eq_zero_imp_eq_zero :\n    IsSMulRegular N r ↔ ∀ x ∈ N, r • x = 0 → x = 0 :=\n  Iff.trans (isSMulRegular_iff_smul_eq_zero_imp_eq_zero N r) <|\n    Iff.trans Subtype.forall <| by\n      simp only [SetLike.mk_smul_mk, Submodule.mk_eq_zero]\n\n"}
{"name":"isSMulRegular_on_quot_iff_smul_mem_implies_mem","module":"Mathlib.RingTheory.Regular.IsSMulRegular","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nN : Submodule R M\nr : R\n⊢ Iff (IsSMulRegular (HasQuotient.Quotient M N) r) (∀ (x : M), Membership.mem N (HSMul.hSMul r x) → Membership.mem N x)","decl":"lemma isSMulRegular_on_quot_iff_smul_mem_implies_mem :\n    IsSMulRegular (M ⧸ N) r ↔ ∀ x : M, r • x ∈ N → x ∈ N :=\n  Iff.trans (isSMulRegular_iff_smul_eq_zero_imp_eq_zero _ r) <|\n    Iff.trans N.mkQ_surjective.forall <| by\n      simp_rw [← map_smul, N.mkQ_apply, Submodule.Quotient.mk_eq_zero]\n\n"}
{"name":"mem_of_isSMulRegular_on_quot_of_smul_mem","module":"Mathlib.RingTheory.Regular.IsSMulRegular","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nN : Submodule R M\nr : R\nh1 : IsSMulRegular (HasQuotient.Quotient M N) r\nx : M\nh2 : Membership.mem N (HSMul.hSMul r x)\n⊢ Membership.mem N x","decl":"lemma mem_of_isSMulRegular_on_quot_of_smul_mem (h1 : IsSMulRegular (M ⧸ N) r)\n    {x : M} (h2 : r • x ∈ N) : x ∈ N :=\n  (isSMulRegular_on_quot_iff_smul_mem_implies_mem N r).mp h1 x h2\n\n"}
{"name":"isSMulRegular_of_range_eq_ker","module":"Mathlib.RingTheory.Regular.IsSMulRegular","initialProofState":"R : Type u_1\nM : Type u_3\nM' : Type u_4\nM'' : Type u_5\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : AddCommGroup M'\ninst✝² : Module R M'\ninst✝¹ : AddCommGroup M''\ninst✝ : Module R M''\nr : R\nf : LinearMap (RingHom.id R) M M'\ng : LinearMap (RingHom.id R) M' M''\nhf : Function.Injective ⇑f\nhfg : Eq (LinearMap.range f) (LinearMap.ker g)\nh1 : IsSMulRegular M r\nh2 : IsSMulRegular M'' r\n⊢ IsSMulRegular M' r","decl":"/-- Given a left exact sequence `0 → M → M' → M''`, if `r` is regular on both\n`M` and `M''` it's regular `M'` too. -/\nlemma isSMulRegular_of_range_eq_ker {f : M →ₗ[R] M'} {g : M' →ₗ[R] M''}\n    (hf : Function.Injective f) (hfg : LinearMap.range f = LinearMap.ker g)\n    (h1 : IsSMulRegular M r) (h2 : IsSMulRegular M'' r) :\n    IsSMulRegular M' r := by\n  refine isSMulRegular_of_smul_eq_zero_imp_eq_zero ?_\n  intro x hx\n  obtain ⟨y, ⟨⟩⟩ := (congrArg (x ∈ ·) hfg).mpr <| h2.eq_zero_of_smul_eq_zero <|\n    Eq.trans (g.map_smul r x).symm <| Eq.trans (congrArg _ hx) g.map_zero\n  refine Eq.trans (congrArg f (h1.eq_zero_of_smul_eq_zero ?_)) f.map_zero\n  exact hf <| Eq.trans (f.map_smul r y) <| Eq.trans hx f.map_zero.symm\n\n"}
{"name":"isSMulRegular_of_isSMulRegular_on_submodule_on_quotient","module":"Mathlib.RingTheory.Regular.IsSMulRegular","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nN : Submodule R M\nr : R\nh1 : IsSMulRegular (Subtype fun x => Membership.mem N x) r\nh2 : IsSMulRegular (HasQuotient.Quotient M N) r\n⊢ IsSMulRegular M r","decl":"lemma isSMulRegular_of_isSMulRegular_on_submodule_on_quotient\n    (h1 : IsSMulRegular N r) (h2 : IsSMulRegular (M ⧸ N) r) : IsSMulRegular M r :=\n  isSMulRegular_of_range_eq_ker N.injective_subtype\n    (Eq.trans N.range_subtype N.ker_mkQ.symm) h1 h2\n\n"}
{"name":"biUnion_associatedPrimes_eq_compl_regular","module":"Mathlib.RingTheory.Regular.IsSMulRegular","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsNoetherianRing R\n⊢ Eq (Set.iUnion fun p => Set.iUnion fun h => ↑p) (HasCompl.compl (setOf fun r => IsSMulRegular M r))","decl":"variable (R) in\nlemma biUnion_associatedPrimes_eq_compl_regular [IsNoetherianRing R] :\n    ⋃ p ∈ associatedPrimes R M, p = { r : R | IsSMulRegular M r }ᶜ :=\n  Eq.trans (biUnion_associatedPrimes_eq_zero_divisors R M) <| by\n    simp_rw [Set.compl_setOf, isSMulRegular_iff_smul_eq_zero_imp_eq_zero,\n      not_forall, exists_prop, and_comm]\n\n"}
{"name":"isSMulRegular_iff_ker_lsmul_eq_bot","module":"Mathlib.RingTheory.Regular.IsSMulRegular","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\n⊢ Iff (IsSMulRegular M r) (Eq (LinearMap.ker ((LinearMap.lsmul R M) r)) Bot.bot)","decl":"lemma isSMulRegular_iff_ker_lsmul_eq_bot :\n    IsSMulRegular M r ↔ LinearMap.ker (LinearMap.lsmul R M r) = ⊥ :=\n  isSMulRegular_iff_torsionBy_eq_bot M r\n\n"}
{"name":"isSMulRegular_on_submodule_iff_disjoint_ker_lsmul_submodule","module":"Mathlib.RingTheory.Regular.IsSMulRegular","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nN : Submodule R M\nr : R\n⊢ Iff (IsSMulRegular (Subtype fun x => Membership.mem N x) r) (Disjoint (LinearMap.ker ((LinearMap.lsmul R M) r)) N)","decl":"lemma isSMulRegular_on_submodule_iff_disjoint_ker_lsmul_submodule :\n    IsSMulRegular N r ↔ Disjoint (LinearMap.ker (LinearMap.lsmul R M r)) N :=\n  Iff.trans (isSMulRegular_on_submodule_iff_mem_imp_smul_eq_zero_imp_eq_zero N r) <|\n    Iff.symm <| Iff.trans disjoint_comm disjoint_def\n\n"}
{"name":"isSMulRegular_on_quot_iff_lsmul_comap_le","module":"Mathlib.RingTheory.Regular.IsSMulRegular","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nN : Submodule R M\nr : R\n⊢ Iff (IsSMulRegular (HasQuotient.Quotient M N) r) (LE.le (Submodule.comap ((LinearMap.lsmul R M) r) N) N)","decl":"lemma isSMulRegular_on_quot_iff_lsmul_comap_le :\n    IsSMulRegular (M ⧸ N) r ↔ N.comap (LinearMap.lsmul R M r) ≤ N :=\n  isSMulRegular_on_quot_iff_smul_mem_implies_mem N r\n\n"}
{"name":"isSMulRegular_on_quot_iff_lsmul_comap_eq","module":"Mathlib.RingTheory.Regular.IsSMulRegular","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nN : Submodule R M\nr : R\n⊢ Iff (IsSMulRegular (HasQuotient.Quotient M N) r) (Eq (Submodule.comap ((LinearMap.lsmul R M) r) N) N)","decl":"lemma isSMulRegular_on_quot_iff_lsmul_comap_eq :\n    IsSMulRegular (M ⧸ N) r ↔ N.comap (LinearMap.lsmul R M r) = N :=\n  Iff.trans (isSMulRegular_on_quot_iff_lsmul_comap_le N r) <|\n    LE.le.le_iff_eq (fun _ => N.smul_mem r)\n\n"}
{"name":"IsSMulRegular.isSMulRegular_on_quot_iff_smul_top_inf_eq_smul","module":"Mathlib.RingTheory.Regular.IsSMulRegular","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nN : Submodule R M\nr : R\na✝ : IsSMulRegular M r\n⊢ Iff (IsSMulRegular (HasQuotient.Quotient M N) r) (LE.le (Min.min (HSMul.hSMul r Top.top) N) (HSMul.hSMul r N))","decl":"lemma IsSMulRegular.isSMulRegular_on_quot_iff_smul_top_inf_eq_smul :\n    IsSMulRegular M r → (IsSMulRegular (M ⧸ N) r ↔ r • ⊤ ⊓ N ≤ r • N) := by\n  intro (h : Function.Injective (DistribMulAction.toLinearMap R M r))\n  rw [isSMulRegular_on_quot_iff_lsmul_comap_le, ← map_le_map_iff_of_injective h,\n    ← LinearMap.lsmul_eq_DistribMulAction_toLinearMap,\n    map_comap_eq, LinearMap.range_eq_map]; rfl\n\n"}
{"name":"isSMulRegular_of_ker_lsmul_eq_bot","module":"Mathlib.RingTheory.Regular.IsSMulRegular","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\nh : Eq (LinearMap.ker ((LinearMap.lsmul R M) r)) Bot.bot\n⊢ IsSMulRegular M r","decl":"lemma isSMulRegular_of_ker_lsmul_eq_bot\n    (h : LinearMap.ker (LinearMap.lsmul R M r) = ⊥) :\n    IsSMulRegular M r :=\n  (isSMulRegular_iff_ker_lsmul_eq_bot M r).mpr h\n\n"}
{"name":"smul_top_inf_eq_smul_of_isSMulRegular_on_quot","module":"Mathlib.RingTheory.Regular.IsSMulRegular","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nN : Submodule R M\nr : R\na✝ : IsSMulRegular (HasQuotient.Quotient M N) r\n⊢ LE.le (Min.min (HSMul.hSMul r Top.top) N) (HSMul.hSMul r N)","decl":"variable {N} in\nlemma smul_top_inf_eq_smul_of_isSMulRegular_on_quot :\n    IsSMulRegular (M ⧸ N) r → r • ⊤ ⊓ N ≤ r • N := by\n  convert map_mono ∘ (isSMulRegular_on_quot_iff_lsmul_comap_le N r).mp using 2\n  exact Eq.trans (congrArg (· ⊓ N) (map_top _)) (map_comap_eq _ _).symm\n\n-- Who knew this didn't rely on exactness at the right!?\n"}
{"name":"QuotSMulTop.map_first_exact_on_four_term_exact_of_isSMulRegular_last","module":"Mathlib.RingTheory.Regular.IsSMulRegular","initialProofState":"R : Type u_1\nM : Type u_3\nM' : Type u_4\nM'' : Type u_5\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup M'\ninst✝⁴ : Module R M'\ninst✝³ : AddCommGroup M''\ninst✝² : Module R M''\nM''' : Type u_6\ninst✝¹ : AddCommGroup M'''\ninst✝ : Module R M'''\nr : R\nf₁ : LinearMap (RingHom.id R) M M'\nf₂ : LinearMap (RingHom.id R) M' M''\nf₃ : LinearMap (RingHom.id R) M'' M'''\nh₁₂ : Function.Exact ⇑f₁ ⇑f₂\nh₂₃ : Function.Exact ⇑f₂ ⇑f₃\nh : IsSMulRegular M''' r\n⊢ Function.Exact ⇑((QuotSMulTop.map r) f₁) ⇑((QuotSMulTop.map r) f₂)","decl":"open Function in\nlemma QuotSMulTop.map_first_exact_on_four_term_exact_of_isSMulRegular_last\n    {M'''} [AddCommGroup M'''] [Module R M''']\n    {r : R} {f₁ : M →ₗ[R] M'} {f₂ : M' →ₗ[R] M''} {f₃ : M'' →ₗ[R] M'''}\n    (h₁₂ : Exact f₁ f₂) (h₂₃ : Exact f₂ f₃) (h : IsSMulRegular M''' r) :\n    Exact (map r f₁) (map r f₂) :=\n  suffices IsSMulRegular (M'' ⧸ LinearMap.range f₂) r by\n    dsimp [map, mapQLinear]\n    rw [Exact.exact_mapQ_iff h₁₂, map_pointwise_smul, Submodule.map_top, inf_comm]\n    exact smul_top_inf_eq_smul_of_isSMulRegular_on_quot this\n  h.of_injective _ <| LinearMap.ker_eq_bot.mp <|\n    ker_liftQ_eq_bot' _ _ h₂₃.linearMap_ker_eq.symm\n\n"}
