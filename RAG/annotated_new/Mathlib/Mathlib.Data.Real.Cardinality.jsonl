{"name":"Cardinal.cantorFunctionAux_true","module":"Mathlib.Data.Real.Cardinality","initialProofState":"c : Real\nf : Nat ‚Üí Bool\nn : Nat\nh : Eq (f n) Bool.true\n‚ä¢ Eq (Cardinal.cantorFunctionAux c f n) (HPow.hPow c n)","decl":"@[simp]\ntheorem cantorFunctionAux_true (h : f n = true) : cantorFunctionAux c f n = c ^ n := by\n  simp [cantorFunctionAux, h]\n\n"}
{"name":"Cardinal.cantorFunctionAux_false","module":"Mathlib.Data.Real.Cardinality","initialProofState":"c : Real\nf : Nat ‚Üí Bool\nn : Nat\nh : Eq (f n) Bool.false\n‚ä¢ Eq (Cardinal.cantorFunctionAux c f n) 0","decl":"@[simp]\ntheorem cantorFunctionAux_false (h : f n = false) : cantorFunctionAux c f n = 0 := by\n  simp [cantorFunctionAux, h]\n\n"}
{"name":"Cardinal.cantorFunctionAux_nonneg","module":"Mathlib.Data.Real.Cardinality","initialProofState":"c : Real\nf : Nat ‚Üí Bool\nn : Nat\nh : LE.le 0 c\n‚ä¢ LE.le 0 (Cardinal.cantorFunctionAux c f n)","decl":"theorem cantorFunctionAux_nonneg (h : 0 ‚â§ c) : 0 ‚â§ cantorFunctionAux c f n := by\n  cases h' : f n\n  ¬∑ simp [h']\n  ¬∑ simpa [h'] using pow_nonneg h _\n\n"}
{"name":"Cardinal.cantorFunctionAux_eq","module":"Mathlib.Data.Real.Cardinality","initialProofState":"c : Real\nf g : Nat ‚Üí Bool\nn : Nat\nh : Eq (f n) (g n)\n‚ä¢ Eq (Cardinal.cantorFunctionAux c f n) (Cardinal.cantorFunctionAux c g n)","decl":"theorem cantorFunctionAux_eq (h : f n = g n) :\n    cantorFunctionAux c f n = cantorFunctionAux c g n := by simp [cantorFunctionAux, h]\n\n"}
{"name":"Cardinal.cantorFunctionAux_zero","module":"Mathlib.Data.Real.Cardinality","initialProofState":"c : Real\nf : Nat ‚Üí Bool\n‚ä¢ Eq (Cardinal.cantorFunctionAux c f 0) (cond (f 0) 1 0)","decl":"theorem cantorFunctionAux_zero (f : ‚Ñï ‚Üí Bool) : cantorFunctionAux c f 0 = cond (f 0) 1 0 := by\n  cases h : f 0 <;> simp [h]\n\n"}
{"name":"Cardinal.cantorFunctionAux_succ","module":"Mathlib.Data.Real.Cardinality","initialProofState":"c : Real\nf : Nat ‚Üí Bool\n‚ä¢ Eq (fun n => Cardinal.cantorFunctionAux c f (HAdd.hAdd n 1)) fun n => HMul.hMul c (Cardinal.cantorFunctionAux c (fun n => f (HAdd.hAdd n 1)) n)","decl":"theorem cantorFunctionAux_succ (f : ‚Ñï ‚Üí Bool) :\n    (fun n => cantorFunctionAux c f (n + 1)) = fun n =>\n      c * cantorFunctionAux c (fun n => f (n + 1)) n := by\n  ext n\n  cases h : f (n + 1) <;> simp [h, _root_.pow_succ']\n\n"}
{"name":"Cardinal.summable_cantor_function","module":"Mathlib.Data.Real.Cardinality","initialProofState":"c : Real\nf : Nat ‚Üí Bool\nh1 : LE.le 0 c\nh2 : LT.lt c 1\n‚ä¢ Summable (Cardinal.cantorFunctionAux c f)","decl":"theorem summable_cantor_function (f : ‚Ñï ‚Üí Bool) (h1 : 0 ‚â§ c) (h2 : c < 1) :\n    Summable (cantorFunctionAux c f) := by\n  apply (summable_geometric_of_lt_one h1 h2).summable_of_eq_zero_or_self\n  intro n; cases h : f n <;> simp [h]\n\n"}
{"name":"Cardinal.cantorFunction_le","module":"Mathlib.Data.Real.Cardinality","initialProofState":"c : Real\nf g : Nat ‚Üí Bool\nh1 : LE.le 0 c\nh2 : LT.lt c 1\nh3 : ‚àÄ (n : Nat), Eq (f n) Bool.true ‚Üí Eq (g n) Bool.true\n‚ä¢ LE.le (Cardinal.cantorFunction c f) (Cardinal.cantorFunction c g)","decl":"theorem cantorFunction_le (h1 : 0 ‚â§ c) (h2 : c < 1) (h3 : ‚àÄ n, f n ‚Üí g n) :\n    cantorFunction c f ‚â§ cantorFunction c g := by\n  apply tsum_le_tsum _ (summable_cantor_function f h1 h2) (summable_cantor_function g h1 h2)\n  intro n; cases h : f n\n  ¬∑ simp [h, cantorFunctionAux_nonneg h1]\n  replace h3 : g n = true := h3 n h; simp [h, h3]\n\n"}
{"name":"Cardinal.cantorFunction_succ","module":"Mathlib.Data.Real.Cardinality","initialProofState":"c : Real\nf : Nat ‚Üí Bool\nh1 : LE.le 0 c\nh2 : LT.lt c 1\n‚ä¢ Eq (Cardinal.cantorFunction c f) (HAdd.hAdd (cond (f 0) 1 0) (HMul.hMul c (Cardinal.cantorFunction c fun n => f (HAdd.hAdd n 1))))","decl":"theorem cantorFunction_succ (f : ‚Ñï ‚Üí Bool) (h1 : 0 ‚â§ c) (h2 : c < 1) :\n    cantorFunction c f = cond (f 0) 1 0 + c * cantorFunction c fun n => f (n + 1) := by\n  rw [cantorFunction, tsum_eq_zero_add (summable_cantor_function f h1 h2)]\n  rw [cantorFunctionAux_succ, tsum_mul_left, cantorFunctionAux, _root_.pow_zero]\n  rfl\n\n"}
{"name":"Cardinal.increasing_cantorFunction","module":"Mathlib.Data.Real.Cardinality","initialProofState":"c : Real\nh1 : LT.lt 0 c\nh2 : LT.lt c (1 / 2)\nn : Nat\nf g : Nat ‚Üí Bool\nhn : ‚àÄ (k : Nat), LT.lt k n ‚Üí Eq (f k) (g k)\nfn : Eq (f n) Bool.false\ngn : Eq (g n) Bool.true\n‚ä¢ LT.lt (Cardinal.cantorFunction c f) (Cardinal.cantorFunction c g)","decl":"/-- `cantorFunction c` is strictly increasing with if `0 < c < 1/2`, if we endow `‚Ñï ‚Üí Bool` with a\nlexicographic order. The lexicographic order doesn't exist for these infinitary products, so we\nexplicitly write out what it means. -/\ntheorem increasing_cantorFunction (h1 : 0 < c) (h2 : c < 1 / 2) {n : ‚Ñï} {f g : ‚Ñï ‚Üí Bool}\n    (hn : ‚àÄ k < n, f k = g k) (fn : f n = false) (gn : g n = true) :\n    cantorFunction c f < cantorFunction c g := by\n  have h3 : c < 1 := by\n    apply h2.trans\n    norm_num\n  induction' n with n ih generalizing f g\n  ¬∑ let f_max : ‚Ñï ‚Üí Bool := fun n => Nat.rec false (fun _ _ => true) n\n    have hf_max : ‚àÄ n, f n ‚Üí f_max n := by\n      intro n hn\n      cases n\n      ¬∑ rw [fn] at hn\n        contradiction\n      apply rfl\n    let g_min : ‚Ñï ‚Üí Bool := fun n => Nat.rec true (fun _ _ => false) n\n    have hg_min : ‚àÄ n, g_min n ‚Üí g n := by\n      intro n hn\n      cases n\n      ¬∑ rw [gn]\n      simp at hn\n    apply (cantorFunction_le (le_of_lt h1) h3 hf_max).trans_lt\n    refine lt_of_lt_of_le ?_ (cantorFunction_le (le_of_lt h1) h3 hg_min)\n    have : c / (1 - c) < 1 := by\n      rw [div_lt_one, lt_sub_iff_add_lt]\n      ¬∑ convert _root_.add_lt_add h2 h2\n        norm_num\n      rwa [sub_pos]\n    convert this\n    ¬∑ rw [cantorFunction_succ _ (le_of_lt h1) h3, div_eq_mul_inv, ‚Üê\n        tsum_geometric_of_lt_one (le_of_lt h1) h3]\n      apply zero_add\n    ¬∑ refine (tsum_eq_single 0 ?_).trans ?_\n      ¬∑ intro n hn\n        cases n\n        ¬∑ contradiction\n        rfl\n      ¬∑ exact cantorFunctionAux_zero _\n  rw [cantorFunction_succ f (le_of_lt h1) h3, cantorFunction_succ g (le_of_lt h1) h3]\n  rw [hn 0 <| zero_lt_succ n]\n  apply add_lt_add_left\n  rw [mul_lt_mul_left h1]\n  exact ih (fun k hk => hn _ <| Nat.succ_lt_succ hk) fn gn\n\n"}
{"name":"Cardinal.cantorFunction_injective","module":"Mathlib.Data.Real.Cardinality","initialProofState":"c : Real\nh1 : LT.lt 0 c\nh2 : LT.lt c (1 / 2)\n‚ä¢ Function.Injective (Cardinal.cantorFunction c)","decl":"/-- `cantorFunction c` is injective if `0 < c < 1/2`. -/\ntheorem cantorFunction_injective (h1 : 0 < c) (h2 : c < 1 / 2) :\n    Function.Injective (cantorFunction c) := by\n  intro f g hfg\n  classical\n    by_contra h\n    revert hfg\n    have : ‚àÉ n, f n ‚â† g n := by\n      rw [‚Üê not_forall]\n      intro h'\n      apply h\n      ext\n      apply h'\n    let n := Nat.find this\n    have hn : ‚àÄ k : ‚Ñï, k < n ‚Üí f k = g k := by\n      intro k hk\n      apply of_not_not\n      exact Nat.find_min this hk\n    cases fn : f n\n    ¬∑ apply _root_.ne_of_lt\n      refine increasing_cantorFunction h1 h2 hn fn ?_\n      apply Bool.eq_true_of_not_eq_false\n      rw [‚Üê fn]\n      apply Ne.symm\n      exact Nat.find_spec this\n    ¬∑ apply _root_.ne_of_gt\n      refine increasing_cantorFunction h1 h2 (fun k hk => (hn k hk).symm) ?_ fn\n      apply Bool.eq_false_of_not_eq_true\n      rw [‚Üê fn]\n      apply Ne.symm\n      exact Nat.find_spec this\n\n"}
{"name":"Cardinal.mk_real","module":"Mathlib.Data.Real.Cardinality","initialProofState":"‚ä¢ Eq (Cardinal.mk Real) Cardinal.continuum","decl":"/-- The cardinality of the reals, as a type. -/\ntheorem mk_real : #‚Ñù = ùî† := by\n  apply le_antisymm\n  ¬∑ rw [Real.equivCauchy.cardinal_eq]\n    apply mk_quotient_le.trans\n    apply (mk_subtype_le _).trans_eq\n    rw [‚Üê power_def, mk_nat, mkRat, aleph0_power_aleph0]\n  ¬∑ convert mk_le_of_injective (cantorFunction_injective _ _)\n    ¬∑ rw [‚Üê power_def, mk_bool, mk_nat, two_power_aleph0]\n    ¬∑ exact 1 / 3\n    ¬∑ norm_num\n    ¬∑ norm_num\n\n"}
{"name":"Cardinal.mk_univ_real","module":"Mathlib.Data.Real.Cardinality","initialProofState":"‚ä¢ Eq (Cardinal.mk ‚ÜëSet.univ) Cardinal.continuum","decl":"/-- The cardinality of the reals, as a set. -/\ntheorem mk_univ_real : #(Set.univ : Set ‚Ñù) = ùî† := by rw [mk_univ, mk_real]\n\n"}
{"name":"Cardinal.instUncountableReal","module":"Mathlib.Data.Real.Cardinality","initialProofState":"‚ä¢ Uncountable Real","decl":"/-- **Non-Denumerability of the Continuum**: The reals are not countable. -/\ninstance : Uncountable ‚Ñù := by\n  rw [‚Üê aleph0_lt_mk_iff, mk_real]\n  exact aleph0_lt_continuum\n\n"}
{"name":"Cardinal.not_countable_real","module":"Mathlib.Data.Real.Cardinality","initialProofState":"‚ä¢ Not Set.univ.Countable","decl":"theorem not_countable_real : ¬¨(Set.univ : Set ‚Ñù).Countable :=\n  not_countable_univ\n\n"}
{"name":"Cardinal.mk_Ioi_real","module":"Mathlib.Data.Real.Cardinality","initialProofState":"a : Real\n‚ä¢ Eq (Cardinal.mk ‚Üë(Set.Ioi a)) Cardinal.continuum","decl":"/-- The cardinality of the interval (a, ‚àû). -/\ntheorem mk_Ioi_real (a : ‚Ñù) : #(Ioi a) = ùî† := by\n  refine le_antisymm (mk_real ‚ñ∏ mk_set_le _) ?_\n  rw [‚Üê not_lt]\n  intro h\n  refine _root_.ne_of_lt ?_ mk_univ_real\n  have hu : Iio a ‚à™ {a} ‚à™ Ioi a = Set.univ := by\n    convert @Iic_union_Ioi ‚Ñù _ _\n    exact Iio_union_right\n  rw [‚Üê hu]\n  refine lt_of_le_of_lt (mk_union_le _ _) ?_\n  refine lt_of_le_of_lt (add_le_add_right (mk_union_le _ _) _) ?_\n  have h2 : (fun x => a + a - x) '' Ioi a = Iio a := by\n    convert @image_const_sub_Ioi ‚Ñù _ _ _\n    simp\n  rw [‚Üê h2]\n  refine add_lt_of_lt (cantor _).le ?_ h\n  refine add_lt_of_lt (cantor _).le (mk_image_le.trans_lt h) ?_\n  rw [mk_singleton]\n  exact one_lt_aleph0.trans (cantor _)\n\n"}
{"name":"Cardinal.mk_Ici_real","module":"Mathlib.Data.Real.Cardinality","initialProofState":"a : Real\n‚ä¢ Eq (Cardinal.mk ‚Üë(Set.Ici a)) Cardinal.continuum","decl":"/-- The cardinality of the interval [a, ‚àû). -/\ntheorem mk_Ici_real (a : ‚Ñù) : #(Ici a) = ùî† :=\n  le_antisymm (mk_real ‚ñ∏ mk_set_le _) (mk_Ioi_real a ‚ñ∏ mk_le_mk_of_subset Ioi_subset_Ici_self)\n\n"}
{"name":"Cardinal.mk_Iio_real","module":"Mathlib.Data.Real.Cardinality","initialProofState":"a : Real\n‚ä¢ Eq (Cardinal.mk ‚Üë(Set.Iio a)) Cardinal.continuum","decl":"/-- The cardinality of the interval (-‚àû, a). -/\ntheorem mk_Iio_real (a : ‚Ñù) : #(Iio a) = ùî† := by\n  refine le_antisymm (mk_real ‚ñ∏ mk_set_le _) ?_\n  have h2 : (fun x => a + a - x) '' Iio a = Ioi a := by\n    simp only [image_const_sub_Iio, add_sub_cancel_right]\n  exact mk_Ioi_real a ‚ñ∏ h2 ‚ñ∏ mk_image_le\n\n"}
{"name":"Cardinal.mk_Iic_real","module":"Mathlib.Data.Real.Cardinality","initialProofState":"a : Real\n‚ä¢ Eq (Cardinal.mk ‚Üë(Set.Iic a)) Cardinal.continuum","decl":"/-- The cardinality of the interval (-‚àû, a]. -/\ntheorem mk_Iic_real (a : ‚Ñù) : #(Iic a) = ùî† :=\n  le_antisymm (mk_real ‚ñ∏ mk_set_le _) (mk_Iio_real a ‚ñ∏ mk_le_mk_of_subset Iio_subset_Iic_self)\n\n"}
{"name":"Cardinal.mk_Ioo_real","module":"Mathlib.Data.Real.Cardinality","initialProofState":"a b : Real\nh : LT.lt a b\n‚ä¢ Eq (Cardinal.mk ‚Üë(Set.Ioo a b)) Cardinal.continuum","decl":"/-- The cardinality of the interval (a, b). -/\ntheorem mk_Ioo_real {a b : ‚Ñù} (h : a < b) : #(Ioo a b) = ùî† := by\n  refine le_antisymm (mk_real ‚ñ∏ mk_set_le _) ?_\n  have h1 : #((fun x => x - a) '' Ioo a b) ‚â§ #(Ioo a b) := mk_image_le\n  refine le_trans ?_ h1\n  rw [image_sub_const_Ioo, sub_self]\n  replace h := sub_pos_of_lt h\n  have h2 : #(Inv.inv '' Ioo 0 (b - a)) ‚â§ #(Ioo 0 (b - a)) := mk_image_le\n  refine le_trans ?_ h2\n  rw [image_inv_eq_inv, inv_Ioo_0_left h, mk_Ioi_real]\n\n"}
{"name":"Cardinal.mk_Ico_real","module":"Mathlib.Data.Real.Cardinality","initialProofState":"a b : Real\nh : LT.lt a b\n‚ä¢ Eq (Cardinal.mk ‚Üë(Set.Ico a b)) Cardinal.continuum","decl":"/-- The cardinality of the interval [a, b). -/\ntheorem mk_Ico_real {a b : ‚Ñù} (h : a < b) : #(Ico a b) = ùî† :=\n  le_antisymm (mk_real ‚ñ∏ mk_set_le _) (mk_Ioo_real h ‚ñ∏ mk_le_mk_of_subset Ioo_subset_Ico_self)\n\n"}
{"name":"Cardinal.mk_Icc_real","module":"Mathlib.Data.Real.Cardinality","initialProofState":"a b : Real\nh : LT.lt a b\n‚ä¢ Eq (Cardinal.mk ‚Üë(Set.Icc a b)) Cardinal.continuum","decl":"/-- The cardinality of the interval [a, b]. -/\ntheorem mk_Icc_real {a b : ‚Ñù} (h : a < b) : #(Icc a b) = ùî† :=\n  le_antisymm (mk_real ‚ñ∏ mk_set_le _) (mk_Ioo_real h ‚ñ∏ mk_le_mk_of_subset Ioo_subset_Icc_self)\n\n"}
{"name":"Cardinal.mk_Ioc_real","module":"Mathlib.Data.Real.Cardinality","initialProofState":"a b : Real\nh : LT.lt a b\n‚ä¢ Eq (Cardinal.mk ‚Üë(Set.Ioc a b)) Cardinal.continuum","decl":"/-- The cardinality of the interval (a, b]. -/\ntheorem mk_Ioc_real {a b : ‚Ñù} (h : a < b) : #(Ioc a b) = ùî† :=\n  le_antisymm (mk_real ‚ñ∏ mk_set_le _) (mk_Ioo_real h ‚ñ∏ mk_le_mk_of_subset Ioo_subset_Ioc_self)\n\n"}
