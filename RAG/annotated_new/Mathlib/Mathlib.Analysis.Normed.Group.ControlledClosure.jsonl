{"name":"controlled_closure_of_complete","module":"Mathlib.Analysis.Normed.Group.ControlledClosure","initialProofState":"G : Type u_1\ninst‚úù¬≤ : NormedAddCommGroup G\ninst‚úù¬π : CompleteSpace G\nH : Type u_2\ninst‚úù : NormedAddCommGroup H\nf : NormedAddGroupHom G H\nK : AddSubgroup H\nC Œµ : Real\nhC : LT.lt 0 C\nhŒµ : LT.lt 0 Œµ\nhyp : f.SurjectiveOnWith K C\n‚ä¢ f.SurjectiveOnWith K.topologicalClosure (HAdd.hAdd C Œµ)","decl":"/-- Given `f : NormedAddGroupHom G H` for some complete `G` and a subgroup `K` of `H`, if every\nelement `x` of `K` has a preimage under `f` whose norm is at most `C*‚Äñx‚Äñ` then the same holds for\nelements of the (topological) closure of `K` with constant `C+Œµ` instead of `C`, for any\npositive `Œµ`.\n-/\ntheorem controlled_closure_of_complete {f : NormedAddGroupHom G H} {K : AddSubgroup H} {C Œµ : ‚Ñù}\n    (hC : 0 < C) (hŒµ : 0 < Œµ) (hyp : f.SurjectiveOnWith K C) :\n    f.SurjectiveOnWith K.topologicalClosure (C + Œµ) := by\n  rintro (h : H) (h_in : h ‚àà K.topologicalClosure)\n  -- We first get rid of the easy case where `h = 0`.\n  by_cases hyp_h : h = 0\n  ¬∑ rw [hyp_h]\n    use 0\n    simp\n  /- The desired preimage will be constructed as the sum of a series. Convergence of\n    the series will be guaranteed by completeness of `G`. We first write `h` as the sum\n    of a sequence `v` of elements of `K` which starts close to `h` and then quickly goes to zero.\n    The sequence `b` below quantifies this. -/\n  set b : ‚Ñï ‚Üí ‚Ñù := fun i => (1 / 2) ^ i * (Œµ * ‚Äñh‚Äñ / 2) / C\n  have b_pos (i) : 0 < b i := by field_simp [b, hC, hyp_h]\n  obtain\n    ‚ü®v : ‚Ñï ‚Üí H, lim_v : Tendsto (fun n : ‚Ñï => ‚àë k ‚àà range (n + 1), v k) atTop (ùìù h), v_in :\n      ‚àÄ n, v n ‚àà K, hv‚ÇÄ : ‚Äñv 0 - h‚Äñ < b 0, hv : ‚àÄ n > 0, ‚Äñv n‚Äñ < b n‚ü© :=\n    controlled_sum_of_mem_closure h_in b_pos\n  /- The controlled surjectivity assumption on `f` allows to build preimages `u n` for all\n    elements `v n` of the `v` sequence. -/\n  have : ‚àÄ n, ‚àÉ m' : G, f m' = v n ‚àß ‚Äñm'‚Äñ ‚â§ C * ‚Äñv n‚Äñ := fun n : ‚Ñï => hyp (v n) (v_in n)\n  choose u hu hnorm_u using this\n  /- The desired series `s` is then obtained by summing `u`. We then check our choice of\n    `b` ensures `s` is Cauchy. -/\n  set s : ‚Ñï ‚Üí G := fun n => ‚àë k ‚àà range (n + 1), u k\n  have : CauchySeq s := by\n    apply NormedAddCommGroup.cauchy_series_of_le_geometric'' (by norm_num) one_half_lt_one\n    ¬∑ rintro n (hn : n ‚â• 1)\n      calc\n        ‚Äñu n‚Äñ ‚â§ C * ‚Äñv n‚Äñ := hnorm_u n\n        _ ‚â§ C * b n := by gcongr; exact (hv _ <| Nat.succ_le_iff.mp hn).le\n        _ = (1 / 2) ^ n * (Œµ * ‚Äñh‚Äñ / 2) := by simp [b, mul_div_cancel‚ÇÄ _ hC.ne.symm]\n        _ = Œµ * ‚Äñh‚Äñ / 2 * (1 / 2) ^ n := mul_comm _ _\n  -- We now show that the limit `g` of `s` is the desired preimage.\n  obtain ‚ü®g : G, hg‚ü© := cauchySeq_tendsto_of_complete this\n  refine ‚ü®g, ?_, ?_‚ü©\n  ¬∑ -- We indeed get a preimage. First note:\n    have : f ‚àò s = fun n => ‚àë k ‚àà range (n + 1), v k := by\n      ext n\n      simp [s, map_sum, hu]\n    /- In the above equality, the left-hand-side converges to `f g` by continuity of `f` and\n      definition of `g` while the right-hand-side converges to `h` by construction of `v` so\n      `g` is indeed a preimage of `h`. -/\n    rw [‚Üê this] at lim_v\n    exact tendsto_nhds_unique ((f.continuous.tendsto g).comp hg) lim_v\n  ¬∑ -- Then we need to estimate the norm of `g`, using our careful choice of `b`.\n    suffices ‚àÄ n, ‚Äñs n‚Äñ ‚â§ (C + Œµ) * ‚Äñh‚Äñ from\n      le_of_tendsto' (continuous_norm.continuousAt.tendsto.comp hg) this\n    intro n\n    have hnorm‚ÇÄ : ‚Äñu 0‚Äñ ‚â§ C * b 0 + C * ‚Äñh‚Äñ := by\n      have :=\n        calc\n          ‚Äñv 0‚Äñ ‚â§ ‚Äñh‚Äñ + ‚Äñv 0 - h‚Äñ := norm_le_insert' _ _\n          _ ‚â§ ‚Äñh‚Äñ + b 0 := by gcongr\n      calc\n        ‚Äñu 0‚Äñ ‚â§ C * ‚Äñv 0‚Äñ := hnorm_u 0\n        _ ‚â§ C * (‚Äñh‚Äñ + b 0) := by gcongr\n        _ = C * b 0 + C * ‚Äñh‚Äñ := by rw [add_comm, mul_add]\n    have : (‚àë k ‚àà range (n + 1), C * b k) ‚â§ Œµ * ‚Äñh‚Äñ :=\n      calc (‚àë k ‚àà range (n + 1), C * b k)\n        _ = (‚àë k ‚àà range (n + 1), (1 / 2 : ‚Ñù) ^ k) * (Œµ * ‚Äñh‚Äñ / 2) := by\n          simp only [b, mul_div_cancel‚ÇÄ _ hC.ne.symm, ‚Üê sum_mul]\n        _ ‚â§ 2 * (Œµ * ‚Äñh‚Äñ / 2) := by gcongr; apply sum_geometric_two_le\n        _ = Œµ * ‚Äñh‚Äñ := mul_div_cancel‚ÇÄ _ two_ne_zero\n    calc\n      ‚Äñs n‚Äñ ‚â§ ‚àë k ‚àà range (n + 1), ‚Äñu k‚Äñ := norm_sum_le _ _\n      _ = (‚àë k ‚àà range n, ‚Äñu (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := sum_range_succ' _ _\n      _ ‚â§ (‚àë k ‚àà range n, C * ‚Äñv (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := by gcongr; apply hnorm_u\n      _ ‚â§ (‚àë k ‚àà range n, C * b (k + 1)) + (C * b 0 + C * ‚Äñh‚Äñ) := by\n        gcongr with k; exact (hv _ k.succ_pos).le\n      _ = (‚àë k ‚àà range (n + 1), C * b k) + C * ‚Äñh‚Äñ := by rw [‚Üê add_assoc, sum_range_succ']\n      _ ‚â§ (C + Œµ) * ‚Äñh‚Äñ := by\n        rw [add_comm, add_mul]\n        apply add_le_add_left this\n\n"}
{"name":"controlled_closure_range_of_complete","module":"Mathlib.Analysis.Normed.Group.ControlledClosure","initialProofState":"G : Type u_1\ninst‚úù¬≥ : NormedAddCommGroup G\ninst‚úù¬≤ : CompleteSpace G\nH : Type u_2\ninst‚úù¬π : NormedAddCommGroup H\nf : NormedAddGroupHom G H\nK : Type u_3\ninst‚úù : SeminormedAddCommGroup K\nj : NormedAddGroupHom K H\nhj : ‚àÄ (x : K), Eq (Norm.norm (j x)) (Norm.norm x)\nC Œµ : Real\nhC : LT.lt 0 C\nhŒµ : LT.lt 0 Œµ\nhyp : ‚àÄ (k : K), Exists fun g => And (Eq (f g) (j k)) (LE.le (Norm.norm g) (HMul.hMul C (Norm.norm k)))\n‚ä¢ f.SurjectiveOnWith j.range.topologicalClosure (HAdd.hAdd C Œµ)","decl":"/-- Given `f : NormedAddGroupHom G H` for some complete `G`, if every element `x` of the image of\nan isometric immersion `j : NormedAddGroupHom K H` has a preimage under `f` whose norm is at most\n`C*‚Äñx‚Äñ` then the same holds for elements of the (topological) closure of this image with constant\n`C+Œµ` instead of `C`, for any positive `Œµ`.\nThis is useful in particular if `j` is the inclusion of a normed group into its completion\n(in this case the closure is the full target group).\n-/\ntheorem controlled_closure_range_of_complete {f : NormedAddGroupHom G H} {K : Type*}\n    [SeminormedAddCommGroup K] {j : NormedAddGroupHom K H} (hj : ‚àÄ x, ‚Äñj x‚Äñ = ‚Äñx‚Äñ) {C Œµ : ‚Ñù}\n    (hC : 0 < C) (hŒµ : 0 < Œµ) (hyp : ‚àÄ k, ‚àÉ g, f g = j k ‚àß ‚Äñg‚Äñ ‚â§ C * ‚Äñk‚Äñ) :\n    f.SurjectiveOnWith j.range.topologicalClosure (C + Œµ) := by\n  replace hyp : ‚àÄ h ‚àà j.range, ‚àÉ g, f g = h ‚àß ‚Äñg‚Äñ ‚â§ C * ‚Äñh‚Äñ := by\n    intro h h_in\n    rcases (j.mem_range _).mp h_in with ‚ü®k, rfl‚ü©\n    rw [hj]\n    exact hyp k\n  exact controlled_closure_of_complete hC hŒµ hyp\n"}
