{"name":"Matrix.trace_diagonal","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"R : Type u_6\ninst✝² : AddCommMonoid R\no : Type u_8\ninst✝¹ : Fintype o\ninst✝ : DecidableEq o\nd : o → R\n⊢ Eq (Matrix.diagonal d).trace (Finset.univ.sum fun i => d i)","decl":"lemma trace_diagonal {o} [Fintype o] [DecidableEq o] (d : o → R) :\n    trace (diagonal d) = ∑ i, d i := by\n  simp only [trace, diag_apply, diagonal_apply_eq]\n\n"}
{"name":"Matrix.trace_zero","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"n : Type u_3\nR : Type u_6\ninst✝¹ : Fintype n\ninst✝ : AddCommMonoid R\n⊢ Eq (Matrix.trace 0) 0","decl":"@[simp]\ntheorem trace_zero : trace (0 : Matrix n n R) = 0 :=\n  (Finset.sum_const (0 : R)).trans <| smul_zero _\n\n"}
{"name":"Matrix.trace_eq_zero_of_isEmpty","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"n : Type u_3\nR : Type u_6\ninst✝² : Fintype n\ninst✝¹ : AddCommMonoid R\ninst✝ : IsEmpty n\nA : Matrix n n R\n⊢ Eq A.trace 0","decl":"@[simp]\nlemma trace_eq_zero_of_isEmpty [IsEmpty n] (A : Matrix n n R) : trace A = 0 := by simp [trace]\n\n"}
{"name":"Matrix.trace_add","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"n : Type u_3\nR : Type u_6\ninst✝¹ : Fintype n\ninst✝ : AddCommMonoid R\nA B : Matrix n n R\n⊢ Eq (HAdd.hAdd A B).trace (HAdd.hAdd A.trace B.trace)","decl":"@[simp]\ntheorem trace_add (A B : Matrix n n R) : trace (A + B) = trace A + trace B :=\n  Finset.sum_add_distrib\n\n"}
{"name":"Matrix.trace_smul","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"n : Type u_3\nα : Type u_5\nR : Type u_6\ninst✝³ : Fintype n\ninst✝² : AddCommMonoid R\ninst✝¹ : Monoid α\ninst✝ : DistribMulAction α R\nr : α\nA : Matrix n n R\n⊢ Eq (HSMul.hSMul r A).trace (HSMul.hSMul r A.trace)","decl":"@[simp]\ntheorem trace_smul [Monoid α] [DistribMulAction α R] (r : α) (A : Matrix n n R) :\n    trace (r • A) = r • trace A :=\n  Finset.smul_sum.symm\n\n"}
{"name":"Matrix.trace_transpose","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"n : Type u_3\nR : Type u_6\ninst✝¹ : Fintype n\ninst✝ : AddCommMonoid R\nA : Matrix n n R\n⊢ Eq A.transpose.trace A.trace","decl":"@[simp]\ntheorem trace_transpose (A : Matrix n n R) : trace Aᵀ = trace A :=\n  rfl\n\n"}
{"name":"Matrix.trace_conjTranspose","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"n : Type u_3\nR : Type u_6\ninst✝² : Fintype n\ninst✝¹ : AddCommMonoid R\ninst✝ : StarAddMonoid R\nA : Matrix n n R\n⊢ Eq A.conjTranspose.trace (Star.star A.trace)","decl":"@[simp]\ntheorem trace_conjTranspose [StarAddMonoid R] (A : Matrix n n R) : trace Aᴴ = star (trace A) :=\n  (star_sum _ _).symm\n\n"}
{"name":"Matrix.traceAddMonoidHom_apply","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"n : Type u_3\nR : Type u_6\ninst✝¹ : Fintype n\ninst✝ : AddCommMonoid R\nA : Matrix n n R\n⊢ Eq ((Matrix.traceAddMonoidHom n R) A) A.trace","decl":"/-- `Matrix.trace` as an `AddMonoidHom` -/\n@[simps]\ndef traceAddMonoidHom : Matrix n n R →+ R where\n  toFun := trace\n  map_zero' := trace_zero n R\n  map_add' := trace_add\n\n"}
{"name":"Matrix.traceLinearMap_apply","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"n : Type u_3\nα : Type u_5\nR : Type u_6\ninst✝³ : Fintype n\ninst✝² : AddCommMonoid R\ninst✝¹ : Semiring α\ninst✝ : Module α R\nA : Matrix n n R\n⊢ Eq ((Matrix.traceLinearMap n α R) A) A.trace","decl":"/-- `Matrix.trace` as a `LinearMap` -/\n@[simps]\ndef traceLinearMap [Semiring α] [Module α R] : Matrix n n R →ₗ[α] R where\n  toFun := trace\n  map_add' := trace_add\n  map_smul' := trace_smul\n\n"}
{"name":"Matrix.trace_list_sum","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"n : Type u_3\nR : Type u_6\ninst✝¹ : Fintype n\ninst✝ : AddCommMonoid R\nl : List (Matrix n n R)\n⊢ Eq l.sum.trace (List.map Matrix.trace l).sum","decl":"@[simp]\ntheorem trace_list_sum (l : List (Matrix n n R)) : trace l.sum = (l.map trace).sum :=\n  map_list_sum (traceAddMonoidHom n R) l\n\n"}
{"name":"Matrix.trace_multiset_sum","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"n : Type u_3\nR : Type u_6\ninst✝¹ : Fintype n\ninst✝ : AddCommMonoid R\ns : Multiset (Matrix n n R)\n⊢ Eq s.sum.trace (Multiset.map Matrix.trace s).sum","decl":"@[simp]\ntheorem trace_multiset_sum (s : Multiset (Matrix n n R)) : trace s.sum = (s.map trace).sum :=\n  map_multiset_sum (traceAddMonoidHom n R) s\n\n"}
{"name":"Matrix.trace_sum","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"ι : Type u_1\nn : Type u_3\nR : Type u_6\ninst✝¹ : Fintype n\ninst✝ : AddCommMonoid R\ns : Finset ι\nf : ι → Matrix n n R\n⊢ Eq (s.sum fun i => f i).trace (s.sum fun i => (f i).trace)","decl":"@[simp]\ntheorem trace_sum (s : Finset ι) (f : ι → Matrix n n R) :\n    trace (∑ i ∈ s, f i) = ∑ i ∈ s, trace (f i) :=\n  map_sum (traceAddMonoidHom n R) f s\n\n"}
{"name":"AddMonoidHom.map_trace","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"n : Type u_3\nR : Type u_6\nS : Type u_7\ninst✝⁴ : Fintype n\ninst✝³ : AddCommMonoid R\ninst✝² : AddCommMonoid S\nF : Type u_8\ninst✝¹ : FunLike F R S\ninst✝ : AddMonoidHomClass F R S\nf : F\nA : Matrix n n R\n⊢ Eq (f A.trace) ((↑f).mapMatrix A).trace","decl":"theorem _root_.AddMonoidHom.map_trace [AddCommMonoid S] {F : Type*} [FunLike F R S]\n    [AddMonoidHomClass F R S] (f : F) (A : Matrix n n R) :\n    f (trace A) = trace ((f : R →+ S).mapMatrix A) :=\n  map_sum f (fun i => diag A i) Finset.univ\n\n"}
{"name":"Matrix.trace_blockDiagonal","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"n : Type u_3\np : Type u_4\nR : Type u_6\ninst✝³ : Fintype n\ninst✝² : Fintype p\ninst✝¹ : AddCommMonoid R\ninst✝ : DecidableEq p\nM : p → Matrix n n R\n⊢ Eq (Matrix.blockDiagonal M).trace (Finset.univ.sum fun i => (M i).trace)","decl":"lemma trace_blockDiagonal [DecidableEq p] (M : p → Matrix n n R) :\n    trace (blockDiagonal M) = ∑ i, trace (M i) := by\n  simp [blockDiagonal, trace, Finset.sum_comm (γ := n), Fintype.sum_prod_type]\n\n"}
{"name":"Matrix.trace_blockDiagonal'","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"p : Type u_4\nR : Type u_6\ninst✝³ : Fintype p\ninst✝² : AddCommMonoid R\ninst✝¹ : DecidableEq p\nm : p → Type u_8\ninst✝ : (i : p) → Fintype (m i)\nM : (i : p) → Matrix (m i) (m i) R\n⊢ Eq (Matrix.blockDiagonal' M).trace (Finset.univ.sum fun i => (M i).trace)","decl":"lemma trace_blockDiagonal' [DecidableEq p] {m : p → Type*} [∀ i, Fintype (m i)]\n    (M : ∀ i, Matrix (m i) (m i) R) :\n    trace (blockDiagonal' M) = ∑ i, trace (M i) := by\n  simp [blockDiagonal', trace, Finset.sum_sigma']\n\n"}
{"name":"Matrix.trace_sub","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"n : Type u_3\nR : Type u_6\ninst✝¹ : Fintype n\ninst✝ : AddCommGroup R\nA B : Matrix n n R\n⊢ Eq (HSub.hSub A B).trace (HSub.hSub A.trace B.trace)","decl":"@[simp]\ntheorem trace_sub (A B : Matrix n n R) : trace (A - B) = trace A - trace B :=\n  Finset.sum_sub_distrib\n\n"}
{"name":"Matrix.trace_neg","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"n : Type u_3\nR : Type u_6\ninst✝¹ : Fintype n\ninst✝ : AddCommGroup R\nA : Matrix n n R\n⊢ Eq (Neg.neg A).trace (Neg.neg A.trace)","decl":"@[simp]\ntheorem trace_neg (A : Matrix n n R) : trace (-A) = -trace A :=\n  Finset.sum_neg_distrib\n\n"}
{"name":"Matrix.trace_one","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"n : Type u_3\nR : Type u_6\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : AddCommMonoidWithOne R\n⊢ Eq (Matrix.trace 1) ↑(Fintype.card n)","decl":"@[simp]\ntheorem trace_one : trace (1 : Matrix n n R) = Fintype.card n := by\n  simp_rw [trace, diag_one, Pi.one_def, Finset.sum_const, nsmul_one, Finset.card_univ]\n\n"}
{"name":"Matrix.trace_transpose_mul","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_6\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : AddCommMonoid R\ninst✝ : Mul R\nA : Matrix m n R\nB : Matrix n m R\n⊢ Eq (HMul.hMul A.transpose B.transpose).trace (HMul.hMul A B).trace","decl":"@[simp]\ntheorem trace_transpose_mul [AddCommMonoid R] [Mul R] (A : Matrix m n R) (B : Matrix n m R) :\n    trace (Aᵀ * Bᵀ) = trace (A * B) :=\n  Finset.sum_comm\n\n"}
{"name":"Matrix.trace_mul_comm","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_6\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : AddCommMonoid R\ninst✝ : CommSemigroup R\nA : Matrix m n R\nB : Matrix n m R\n⊢ Eq (HMul.hMul A B).trace (HMul.hMul B A).trace","decl":"theorem trace_mul_comm [AddCommMonoid R] [CommSemigroup R] (A : Matrix m n R) (B : Matrix n m R) :\n    trace (A * B) = trace (B * A) := by rw [← trace_transpose, ← trace_transpose_mul, transpose_mul]\n\n"}
{"name":"Matrix.trace_mul_cycle","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"m : Type u_2\nn : Type u_3\np : Type u_4\nR : Type u_6\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : Fintype p\ninst✝ : NonUnitalCommSemiring R\nA : Matrix m n R\nB : Matrix n p R\nC : Matrix p m R\n⊢ Eq (HMul.hMul (HMul.hMul A B) C).trace (HMul.hMul (HMul.hMul C A) B).trace","decl":"theorem trace_mul_cycle [NonUnitalCommSemiring R] (A : Matrix m n R) (B : Matrix n p R)\n    (C : Matrix p m R) : trace (A * B * C) = trace (C * A * B) := by\n  rw [trace_mul_comm, Matrix.mul_assoc]\n\n"}
{"name":"Matrix.trace_mul_cycle'","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"m : Type u_2\nn : Type u_3\np : Type u_4\nR : Type u_6\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : Fintype p\ninst✝ : NonUnitalCommSemiring R\nA : Matrix m n R\nB : Matrix n p R\nC : Matrix p m R\n⊢ Eq (HMul.hMul A (HMul.hMul B C)).trace (HMul.hMul C (HMul.hMul A B)).trace","decl":"theorem trace_mul_cycle' [NonUnitalCommSemiring R] (A : Matrix m n R) (B : Matrix n p R)\n    (C : Matrix p m R) : trace (A * (B * C)) = trace (C * (A * B)) := by\n  rw [← Matrix.mul_assoc, trace_mul_comm]\n\n"}
{"name":"Matrix.trace_col_mul_row","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"n : Type u_3\nR : Type u_6\ninst✝² : Fintype n\nι : Type u_8\ninst✝¹ : Unique ι\ninst✝ : NonUnitalNonAssocSemiring R\na b : n → R\n⊢ Eq (HMul.hMul (Matrix.col ι a) (Matrix.row ι b)).trace (dotProduct a b)","decl":"@[simp]\ntheorem trace_col_mul_row {ι : Type*} [Unique ι] [NonUnitalNonAssocSemiring R] (a b : n → R) :\n    trace (col ι a * row ι b) = dotProduct a b := by\n  apply Finset.sum_congr rfl\n  simp [mul_apply]\n\n"}
{"name":"Matrix.trace_submatrix_succ","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"R : Type u_6\nn : Nat\ninst✝ : NonUnitalNonAssocSemiring R\nM : Matrix (Fin n.succ) (Fin n.succ) R\n⊢ Eq (HAdd.hAdd (M 0 0) (M.submatrix Fin.succ Fin.succ).trace) M.trace","decl":"lemma trace_submatrix_succ {n : ℕ} [NonUnitalNonAssocSemiring R]\n    (M : Matrix (Fin n.succ) (Fin n.succ) R) :\n    M 0 0 + trace (submatrix M Fin.succ Fin.succ) = trace M := by\n  delta trace\n  rw [← (finSuccEquiv n).symm.sum_comp]\n  simp\n\n"}
{"name":"Matrix.trace_units_conj","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"m : Type u_2\nR : Type u_6\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : CommSemiring R\nM : Units (Matrix m m R)\nN : Matrix m m R\n⊢ Eq (HMul.hMul (HMul.hMul (↑M) N) ↑(Inv.inv M)).trace N.trace","decl":"theorem trace_units_conj (M : (Matrix m m R)ˣ) (N : Matrix m m R) :\n    trace ((M : Matrix _ _ _) * N * (↑M⁻¹ : Matrix _ _ _)) = trace N := by\n  rw [trace_mul_cycle, Units.inv_mul, one_mul]\n\n"}
{"name":"Matrix.trace_units_conj'","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"m : Type u_2\nR : Type u_6\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : CommSemiring R\nM : Units (Matrix m m R)\nN : Matrix m m R\n⊢ Eq (HMul.hMul (HMul.hMul (↑(Inv.inv M)) N) ↑M).trace N.trace","decl":"set_option linter.docPrime false in\n-- TODO(https://github.com/leanprover-community/mathlib4/issues/6607): fix elaboration so that the ascription isn't needed\ntheorem trace_units_conj' (M : (Matrix m m R)ˣ) (N : Matrix m m R) :\n    trace ((↑M⁻¹ : Matrix _ _ _) * N * (↑M : Matrix _ _ _)) = trace N :=\n  trace_units_conj M⁻¹ N\n\n"}
{"name":"Matrix.trace_fin_zero","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"R : Type u_6\ninst✝ : AddCommMonoid R\nA : Matrix (Fin 0) (Fin 0) R\n⊢ Eq A.trace 0","decl":"@[simp]\ntheorem trace_fin_zero (A : Matrix (Fin 0) (Fin 0) R) : trace A = 0 :=\n  rfl\n\n"}
{"name":"Matrix.trace_fin_one","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"R : Type u_6\ninst✝ : AddCommMonoid R\nA : Matrix (Fin 1) (Fin 1) R\n⊢ Eq A.trace (A 0 0)","decl":"theorem trace_fin_one (A : Matrix (Fin 1) (Fin 1) R) : trace A = A 0 0 :=\n  add_zero _\n\n"}
{"name":"Matrix.trace_fin_two","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"R : Type u_6\ninst✝ : AddCommMonoid R\nA : Matrix (Fin 2) (Fin 2) R\n⊢ Eq A.trace (HAdd.hAdd (A 0 0) (A 1 1))","decl":"theorem trace_fin_two (A : Matrix (Fin 2) (Fin 2) R) : trace A = A 0 0 + A 1 1 :=\n  congr_arg (_ + ·) (add_zero (A 1 1))\n\n"}
{"name":"Matrix.trace_fin_three","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"R : Type u_6\ninst✝ : AddCommMonoid R\nA : Matrix (Fin 3) (Fin 3) R\n⊢ Eq A.trace (HAdd.hAdd (HAdd.hAdd (A 0 0) (A 1 1)) (A 2 2))","decl":"theorem trace_fin_three (A : Matrix (Fin 3) (Fin 3) R) : trace A = A 0 0 + A 1 1 + A 2 2 := by\n  rw [← add_zero (A 2 2), add_assoc]\n  rfl\n\n"}
{"name":"Matrix.trace_fin_one_of","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"R : Type u_6\ninst✝ : AddCommMonoid R\na : R\n⊢ Eq (Matrix.of (Matrix.vecCons (Matrix.vecCons a Matrix.vecEmpty) Matrix.vecEmpty)).trace a","decl":"@[simp]\ntheorem trace_fin_one_of (a : R) : trace !![a] = a :=\n  trace_fin_one _\n\n"}
{"name":"Matrix.trace_fin_two_of","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"R : Type u_6\ninst✝ : AddCommMonoid R\na b c d : R\n⊢ Eq (Matrix.of (Matrix.vecCons (Matrix.vecCons a (Matrix.vecCons b Matrix.vecEmpty)) (Matrix.vecCons (Matrix.vecCons c (Matrix.vecCons d Matrix.vecEmpty)) Matrix.vecEmpty))).trace (HAdd.hAdd a d)","decl":"@[simp]\ntheorem trace_fin_two_of (a b c d : R) : trace !![a, b; c, d] = a + d :=\n  trace_fin_two _\n\n"}
{"name":"Matrix.trace_fin_three_of","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"R : Type u_6\ninst✝ : AddCommMonoid R\na b c d e f g h i : R\n⊢ Eq (Matrix.of (Matrix.vecCons (Matrix.vecCons a (Matrix.vecCons b (Matrix.vecCons c Matrix.vecEmpty))) (Matrix.vecCons (Matrix.vecCons d (Matrix.vecCons e (Matrix.vecCons f Matrix.vecEmpty))) (Matrix.vecCons (Matrix.vecCons g (Matrix.vecCons h (Matrix.vecCons i Matrix.vecEmpty))) Matrix.vecEmpty)))).trace (HAdd.hAdd (HAdd.hAdd a e) i)","decl":"@[simp]\ntheorem trace_fin_three_of (a b c d e f g h i : R) :\n    trace !![a, b, c; d, e, f; g, h, i] = a + e + i :=\n  trace_fin_three _\n\n"}
{"name":"Matrix.StdBasisMatrix.trace_zero","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"n : Type u_10\nα : Type u_12\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : AddCommMonoid α\ni j : n\nc : α\nh : Ne j i\n⊢ Eq (Matrix.stdBasisMatrix i j c).trace 0","decl":"@[simp]\ntheorem trace_zero (h : j ≠ i) : trace (stdBasisMatrix i j c) = 0 := by\n  -- Porting note: added `-diag_apply`\n  simp [trace, -diag_apply, h]\n\n"}
{"name":"Matrix.StdBasisMatrix.trace_eq","module":"Mathlib.LinearAlgebra.Matrix.Trace","initialProofState":"n : Type u_10\nα : Type u_12\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : AddCommMonoid α\ni : n\nc : α\n⊢ Eq (Matrix.stdBasisMatrix i i c).trace c","decl":"@[simp]\ntheorem trace_eq : trace (stdBasisMatrix i i c) = c := by\n  -- Porting note: added `-diag_apply`\n  simp [trace, -diag_apply]\n\n"}
