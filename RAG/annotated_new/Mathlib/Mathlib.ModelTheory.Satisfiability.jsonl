{"name":"FirstOrder.Language.Theory.Model.isSatisfiable","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nM : Type w\ninst✝² : Nonempty M\ninst✝¹ : L.Structure M\ninst✝ : FirstOrder.Language.Theory.Model M T\n⊢ T.IsSatisfiable","decl":"theorem Model.isSatisfiable (M : Type w) [Nonempty M] [L.Structure M] [M ⊨ T] :\n    T.IsSatisfiable :=\n  ⟨((⊥ : Substructure _ (ModelType.of T M)).elementarySkolem₁Reduct.toModel T).shrink⟩\n\n"}
{"name":"FirstOrder.Language.Theory.IsSatisfiable.mono","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT T' : L.Theory\nh : T'.IsSatisfiable\nhs : HasSubset.Subset T T'\n⊢ T.IsSatisfiable","decl":"theorem IsSatisfiable.mono (h : T'.IsSatisfiable) (hs : T ⊆ T') : T.IsSatisfiable :=\n  ⟨(Theory.Model.mono (ModelType.is_model h.some) hs).bundled⟩\n\n"}
{"name":"FirstOrder.Language.Theory.isSatisfiable_empty","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\n⊢ EmptyCollection.emptyCollection.IsSatisfiable","decl":"theorem isSatisfiable_empty (L : Language.{u, v}) : IsSatisfiable (∅ : L.Theory) :=\n  ⟨default⟩\n\n"}
{"name":"FirstOrder.Language.Theory.isSatisfiable_of_isSatisfiable_onTheory","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nL' : FirstOrder.Language\nφ : L.LHom L'\nh : (φ.onTheory T).IsSatisfiable\n⊢ T.IsSatisfiable","decl":"theorem isSatisfiable_of_isSatisfiable_onTheory {L' : Language.{w, w'}} (φ : L →ᴸ L')\n    (h : (φ.onTheory T).IsSatisfiable) : T.IsSatisfiable :=\n  Model.isSatisfiable (h.some.reduct φ)\n\n"}
{"name":"FirstOrder.Language.Theory.isSatisfiable_onTheory_iff","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nL' : FirstOrder.Language\nφ : L.LHom L'\nh : φ.Injective\n⊢ Iff (φ.onTheory T).IsSatisfiable T.IsSatisfiable","decl":"theorem isSatisfiable_onTheory_iff {L' : Language.{w, w'}} {φ : L →ᴸ L'} (h : φ.Injective) :\n    (φ.onTheory T).IsSatisfiable ↔ T.IsSatisfiable := by\n  classical\n    refine ⟨isSatisfiable_of_isSatisfiable_onTheory φ, fun h' => ?_⟩\n    haveI : Inhabited h'.some := Classical.inhabited_of_nonempty'\n    exact Model.isSatisfiable (h'.some.defaultExpansion h)\n\n"}
{"name":"FirstOrder.Language.Theory.IsSatisfiable.isFinitelySatisfiable","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nh : T.IsSatisfiable\n⊢ T.IsFinitelySatisfiable","decl":"theorem IsSatisfiable.isFinitelySatisfiable (h : T.IsSatisfiable) : T.IsFinitelySatisfiable :=\n  fun _ => h.mono\n\n"}
{"name":"FirstOrder.Language.Theory.isSatisfiable_iff_isFinitelySatisfiable","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT : L.Theory\n⊢ Iff T.IsSatisfiable T.IsFinitelySatisfiable","decl":"/-- The **Compactness Theorem of first-order logic**: A theory is satisfiable if and only if it is\nfinitely satisfiable. -/\ntheorem isSatisfiable_iff_isFinitelySatisfiable {T : L.Theory} :\n    T.IsSatisfiable ↔ T.IsFinitelySatisfiable :=\n  ⟨Theory.IsSatisfiable.isFinitelySatisfiable, fun h => by\n    classical\n      set M : Finset T → Type max u v := fun T0 : Finset T =>\n        (h (T0.map (Function.Embedding.subtype fun x => x ∈ T)) T0.map_subtype_subset).some.Carrier\n      let M' := Filter.Product (Ultrafilter.of (Filter.atTop : Filter (Finset T))) M\n      have h' : M' ⊨ T := by\n        refine ⟨fun φ hφ => ?_⟩\n        rw [Ultraproduct.sentence_realize]\n        refine\n          Filter.Eventually.filter_mono (Ultrafilter.of_le _)\n            (Filter.eventually_atTop.2\n              ⟨{⟨φ, hφ⟩}, fun s h' =>\n                Theory.realize_sentence_of_mem (s.map (Function.Embedding.subtype fun x => x ∈ T))\n                  ?_⟩)\n        simp only [Finset.coe_map, Function.Embedding.coe_subtype, Set.mem_image, Finset.mem_coe,\n          Subtype.exists, Subtype.coe_mk, exists_and_right, exists_eq_right]\n        exact ⟨hφ, h' (Finset.mem_singleton_self _)⟩\n      exact ⟨ModelType.of T M'⟩⟩\n\n"}
{"name":"FirstOrder.Language.Theory.isSatisfiable_directed_union_iff","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nι : Type u_1\ninst✝ : Nonempty ι\nT : ι → L.Theory\nh : Directed (fun x1 x2 => HasSubset.Subset x1 x2) T\n⊢ Iff (FirstOrder.Language.Theory.IsSatisfiable (Set.iUnion fun i => T i)) (∀ (i : ι), (T i).IsSatisfiable)","decl":"theorem isSatisfiable_directed_union_iff {ι : Type*} [Nonempty ι] {T : ι → L.Theory}\n    (h : Directed (· ⊆ ·) T) : Theory.IsSatisfiable (⋃ i, T i) ↔ ∀ i, (T i).IsSatisfiable := by\n  refine ⟨fun h' i => h'.mono (Set.subset_iUnion _ _), fun h' => ?_⟩\n  rw [isSatisfiable_iff_isFinitelySatisfiable, IsFinitelySatisfiable]\n  intro T0 hT0\n  obtain ⟨i, hi⟩ := h.exists_mem_subset_of_finset_subset_biUnion hT0\n  exact (h' i).mono hi\n\n"}
{"name":"FirstOrder.Language.Theory.isSatisfiable_union_distinctConstantsTheory_of_card_le","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nα : Type w\nT : L.Theory\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : L.Structure M\ninst✝ : FirstOrder.Language.Theory.Model M T\nh : LE.le (Cardinal.lift.{w', w} (Cardinal.mk ↑s)) (Cardinal.lift.{w, w'} (Cardinal.mk M))\n⊢ (Union.union ((L.lhomWithConstants α).onTheory T) (L.distinctConstantsTheory s)).IsSatisfiable","decl":"theorem isSatisfiable_union_distinctConstantsTheory_of_card_le (T : L.Theory) (s : Set α)\n    (M : Type w') [Nonempty M] [L.Structure M] [M ⊨ T]\n    (h : Cardinal.lift.{w'} #s ≤ Cardinal.lift.{w} #M) :\n    ((L.lhomWithConstants α).onTheory T ∪ L.distinctConstantsTheory s).IsSatisfiable := by\n  haveI : Inhabited M := Classical.inhabited_of_nonempty inferInstance\n  rw [Cardinal.lift_mk_le'] at h\n  letI : (constantsOn α).Structure M := constantsOn.structure (Function.extend (↑) h.some default)\n  have : M ⊨ (L.lhomWithConstants α).onTheory T ∪ L.distinctConstantsTheory s := by\n    refine ((LHom.onTheory_model _ _).2 inferInstance).union ?_\n    rw [model_distinctConstantsTheory]\n    refine fun a as b bs ab => ?_\n    rw [← Subtype.coe_mk a as, ← Subtype.coe_mk b bs, ← Subtype.ext_iff]\n    exact\n      h.some.injective\n        ((Subtype.coe_injective.extend_apply h.some default ⟨a, as⟩).symm.trans\n          (ab.trans (Subtype.coe_injective.extend_apply h.some default ⟨b, bs⟩)))\n  exact Model.isSatisfiable M\n\n"}
{"name":"FirstOrder.Language.Theory.isSatisfiable_union_distinctConstantsTheory_of_infinite","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nα : Type w\nT : L.Theory\ns : Set α\nM : Type w'\ninst✝² : L.Structure M\ninst✝¹ : FirstOrder.Language.Theory.Model M T\ninst✝ : Infinite M\n⊢ (Union.union ((L.lhomWithConstants α).onTheory T) (L.distinctConstantsTheory s)).IsSatisfiable","decl":"theorem isSatisfiable_union_distinctConstantsTheory_of_infinite (T : L.Theory) (s : Set α)\n    (M : Type w') [L.Structure M] [M ⊨ T] [Infinite M] :\n    ((L.lhomWithConstants α).onTheory T ∪ L.distinctConstantsTheory s).IsSatisfiable := by\n  classical\n    rw [distinctConstantsTheory_eq_iUnion, Set.union_iUnion, isSatisfiable_directed_union_iff]\n    · exact fun t =>\n        isSatisfiable_union_distinctConstantsTheory_of_card_le T _ M\n          ((lift_le_aleph0.2 (finset_card_lt_aleph0 _).le).trans\n            (aleph0_le_lift.2 (aleph0_le_mk M)))\n    · apply Monotone.directed_le\n      refine monotone_const.union (monotone_distinctConstantsTheory.comp ?_)\n      simp only [Finset.coe_map, Function.Embedding.coe_subtype]\n      exact Monotone.comp (g := Set.image ((↑) : s → α)) (f := ((↑) : Finset s → Set s))\n        Set.monotone_image fun _ _ => Finset.coe_subset.2\n\n"}
{"name":"FirstOrder.Language.Theory.exists_large_model_of_infinite_model","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nκ : Cardinal.{w}\nM : Type w'\ninst✝² : L.Structure M\ninst✝¹ : FirstOrder.Language.Theory.Model M T\ninst✝ : Infinite M\n⊢ Exists fun N => LE.le (Cardinal.lift.{max u v w, w} κ) (Cardinal.mk ↑N)","decl":"/-- Any theory with an infinite model has arbitrarily large models. -/\ntheorem exists_large_model_of_infinite_model (T : L.Theory) (κ : Cardinal.{w}) (M : Type w')\n    [L.Structure M] [M ⊨ T] [Infinite M] :\n    ∃ N : ModelType.{_, _, max u v w} T, Cardinal.lift.{max u v w} κ ≤ #N := by\n  obtain ⟨N⟩ :=\n    isSatisfiable_union_distinctConstantsTheory_of_infinite T (Set.univ : Set κ.out) M\n  refine ⟨(N.is_model.mono Set.subset_union_left).bundled.reduct _, ?_⟩\n  haveI : N ⊨ distinctConstantsTheory _ _ := N.is_model.mono Set.subset_union_right\n  rw [ModelType.reduct_Carrier, coe_of]\n  refine _root_.trans (lift_le.2 (le_of_eq (Cardinal.mk_out κ).symm)) ?_\n  rw [← mk_univ]\n  refine\n    (card_le_of_model_distinctConstantsTheory L Set.univ N).trans (lift_le.{max u v w}.1 ?_)\n  rw [lift_lift]\n\n"}
{"name":"FirstOrder.Language.Theory.isSatisfiable_iUnion_iff_isSatisfiable_iUnion_finset","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nι : Type u_1\nT : ι → L.Theory\n⊢ Iff (FirstOrder.Language.Theory.IsSatisfiable (Set.iUnion fun i => T i)) (∀ (s : Finset ι), FirstOrder.Language.Theory.IsSatisfiable (Set.iUnion fun i => Set.iUnion fun h => T i))","decl":"theorem isSatisfiable_iUnion_iff_isSatisfiable_iUnion_finset {ι : Type*} (T : ι → L.Theory) :\n    IsSatisfiable (⋃ i, T i) ↔ ∀ s : Finset ι, IsSatisfiable (⋃ i ∈ s, T i) := by\n  classical\n    refine\n      ⟨fun h s => h.mono (Set.iUnion_mono fun _ => Set.iUnion_subset_iff.2 fun _ => refl _),\n        fun h => ?_⟩\n    rw [isSatisfiable_iff_isFinitelySatisfiable]\n    intro s hs\n    rw [Set.iUnion_eq_iUnion_finset] at hs\n    obtain ⟨t, ht⟩ := Directed.exists_mem_subset_of_finset_subset_biUnion (by\n      exact Monotone.directed_le fun t1 t2 (h : ∀ ⦃x⦄, x ∈ t1 → x ∈ t2) =>\n        Set.iUnion_mono fun _ => Set.iUnion_mono' fun h1 => ⟨h h1, refl _⟩) hs\n    exact (h t).mono ht\n\n"}
{"name":"FirstOrder.Language.exists_elementaryEmbedding_card_eq_of_le","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝¹ : L.Structure M\ninst✝ : Nonempty M\nκ : Cardinal.{w}\nh1 : LE.le Cardinal.aleph0 κ\nh2 : LE.le (Cardinal.lift.{w, max u v} L.card) (Cardinal.lift.{max u v, w} κ)\nh3 : LE.le (Cardinal.lift.{w', w} κ) (Cardinal.lift.{w, w'} (Cardinal.mk M))\n⊢ Exists fun N => And (Nonempty (L.ElementaryEmbedding (↑N) M)) (Eq (Cardinal.mk ↑N) κ)","decl":"/-- A version of The Downward Löwenheim–Skolem theorem where the structure `N` elementarily embeds\ninto `M`, but is not by type a substructure of `M`, and thus can be chosen to belong to the universe\nof the cardinal `κ`.\n -/\ntheorem exists_elementaryEmbedding_card_eq_of_le (M : Type w') [L.Structure M] [Nonempty M]\n    (κ : Cardinal.{w}) (h1 : ℵ₀ ≤ κ) (h2 : lift.{w} L.card ≤ Cardinal.lift.{max u v} κ)\n    (h3 : lift.{w'} κ ≤ Cardinal.lift.{w} #M) :\n    ∃ N : Bundled L.Structure, Nonempty (N ↪ₑ[L] M) ∧ #N = κ := by\n  obtain ⟨S, _, hS⟩ := exists_elementarySubstructure_card_eq L ∅ κ h1 (by simp) h2 h3\n  have : Small.{w} S := by\n    rw [← lift_inj.{_, w + 1}, lift_lift, lift_lift] at hS\n    exact small_iff_lift_mk_lt_univ.2 (lt_of_eq_of_lt hS κ.lift_lt_univ')\n  refine\n    ⟨(equivShrink S).bundledInduced L,\n      ⟨S.subtype.comp (Equiv.bundledInducedEquiv L _).symm.toElementaryEmbedding⟩,\n      lift_inj.1 (_root_.trans ?_ hS)⟩\n  simp only [Equiv.bundledInduced_α, lift_mk_shrink']\n\n"}
{"name":"FirstOrder.Language.exists_elementaryEmbedding_card_eq_of_ge","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝ : L.Structure M\niM : Infinite M\nκ : Cardinal.{w}\nh1 : LE.le (Cardinal.lift.{w, max u v} L.card) (Cardinal.lift.{max u v, w} κ)\nh2 : LE.le (Cardinal.lift.{w, w'} (Cardinal.mk M)) (Cardinal.lift.{w', w} κ)\n⊢ Exists fun N => And (Nonempty (L.ElementaryEmbedding M ↑N)) (Eq (Cardinal.mk ↑N) κ)","decl":"/-- The **Upward Löwenheim–Skolem Theorem**: If `κ` is a cardinal greater than the cardinalities of\n`L` and an infinite `L`-structure `M`, then `M` has an elementary extension of cardinality `κ`. -/\ntheorem exists_elementaryEmbedding_card_eq_of_ge (M : Type w') [L.Structure M] [iM : Infinite M]\n    (κ : Cardinal.{w}) (h1 : Cardinal.lift.{w} L.card ≤ Cardinal.lift.{max u v} κ)\n    (h2 : Cardinal.lift.{w} #M ≤ Cardinal.lift.{w'} κ) :\n    ∃ N : Bundled L.Structure, Nonempty (M ↪ₑ[L] N) ∧ #N = κ := by\n  obtain ⟨N0, hN0⟩ := (L.elementaryDiagram M).exists_large_model_of_infinite_model κ M\n  rw [← lift_le.{max u v}, lift_lift, lift_lift] at h2\n  obtain ⟨N, ⟨NN0⟩, hN⟩ :=\n    exists_elementaryEmbedding_card_eq_of_le (L[[M]]) N0 κ\n      (aleph0_le_lift.1 ((aleph0_le_lift.2 (aleph0_le_mk M)).trans h2))\n      (by\n        simp only [card_withConstants, lift_add, lift_lift]\n        rw [add_comm, add_eq_max (aleph0_le_lift.2 (infinite_iff.1 iM)), max_le_iff]\n        rw [← lift_le.{w'}, lift_lift, lift_lift] at h1\n        exact ⟨h2, h1⟩)\n      (hN0.trans (by rw [← lift_umax, lift_id]))\n  letI := (lhomWithConstants L M).reduct N\n  haveI h : N ⊨ L.elementaryDiagram M :=\n    (NN0.theory_model_iff (L.elementaryDiagram M)).2 inferInstance\n  refine ⟨Bundled.of N, ⟨?_⟩, hN⟩\n  apply ElementaryEmbedding.ofModelsElementaryDiagram L M N\n\n"}
{"name":"FirstOrder.Language.exists_elementaryEmbedding_card_eq","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝ : L.Structure M\niM : Infinite M\nκ : Cardinal.{w}\nh1 : LE.le Cardinal.aleph0 κ\nh2 : LE.le (Cardinal.lift.{w, max u v} L.card) (Cardinal.lift.{max u v, w} κ)\n⊢ Exists fun N => And (Or (Nonempty (L.ElementaryEmbedding (↑N) M)) (Nonempty (L.ElementaryEmbedding M ↑N))) (Eq (Cardinal.mk ↑N) κ)","decl":"/-- The Löwenheim–Skolem Theorem: If `κ` is a cardinal greater than the cardinalities of `L`\nand an infinite `L`-structure `M`, then there is an elementary embedding in the appropriate\ndirection between then `M` and a structure of cardinality `κ`. -/\ntheorem exists_elementaryEmbedding_card_eq (M : Type w') [L.Structure M] [iM : Infinite M]\n    (κ : Cardinal.{w}) (h1 : ℵ₀ ≤ κ) (h2 : lift.{w} L.card ≤ Cardinal.lift.{max u v} κ) :\n    ∃ N : Bundled L.Structure, (Nonempty (N ↪ₑ[L] M) ∨ Nonempty (M ↪ₑ[L] N)) ∧ #N = κ := by\n  cases le_or_gt (lift.{w'} κ) (Cardinal.lift.{w} #M) with\n  | inl h =>\n    obtain ⟨N, hN1, hN2⟩ := exists_elementaryEmbedding_card_eq_of_le L M κ h1 h2 h\n    exact ⟨N, Or.inl hN1, hN2⟩\n  | inr h =>\n    obtain ⟨N, hN1, hN2⟩ := exists_elementaryEmbedding_card_eq_of_ge L M κ h2 (le_of_lt h)\n    exact ⟨N, Or.inr hN1, hN2⟩\n\n"}
{"name":"FirstOrder.Language.exists_elementarilyEquivalent_card_eq","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝¹ : L.Structure M\ninst✝ : Infinite M\nκ : Cardinal.{w}\nh1 : LE.le Cardinal.aleph0 κ\nh2 : LE.le (Cardinal.lift.{w, max u v} L.card) (Cardinal.lift.{max u v, w} κ)\n⊢ Exists fun N => And (L.ElementarilyEquivalent M ↑N) (Eq (Cardinal.mk ↑N) κ)","decl":"/-- A consequence of the Löwenheim–Skolem Theorem: If `κ` is a cardinal greater than the\ncardinalities of `L` and an infinite `L`-structure `M`, then there is a structure of cardinality `κ`\nelementarily equivalent to `M`. -/\ntheorem exists_elementarilyEquivalent_card_eq (M : Type w') [L.Structure M] [Infinite M]\n    (κ : Cardinal.{w}) (h1 : ℵ₀ ≤ κ) (h2 : lift.{w} L.card ≤ Cardinal.lift.{max u v} κ) :\n    ∃ N : CategoryTheory.Bundled L.Structure, (M ≅[L] N) ∧ #N = κ := by\n  obtain ⟨N, NM | MN, hNκ⟩ := exists_elementaryEmbedding_card_eq L M κ h1 h2\n  · exact ⟨N, NM.some.elementarilyEquivalent.symm, hNκ⟩\n  · exact ⟨N, MN.some.elementarilyEquivalent, hNκ⟩\n\n"}
{"name":"FirstOrder.Language.Theory.exists_model_card_eq","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nh : Exists fun M => Infinite ↑M\nκ : Cardinal.{w}\nh1 : LE.le Cardinal.aleph0 κ\nh2 : LE.le (Cardinal.lift.{w, max u v} L.card) (Cardinal.lift.{max u v, w} κ)\n⊢ Exists fun N => Eq (Cardinal.mk ↑N) κ","decl":"theorem exists_model_card_eq (h : ∃ M : ModelType.{u, v, max u v} T, Infinite M) (κ : Cardinal.{w})\n    (h1 : ℵ₀ ≤ κ) (h2 : Cardinal.lift.{w} L.card ≤ Cardinal.lift.{max u v} κ) :\n    ∃ N : ModelType.{u, v, w} T, #N = κ := by\n  cases h with\n  | intro M MI =>\n    haveI := MI\n    obtain ⟨N, hN, rfl⟩ := exists_elementarilyEquivalent_card_eq L M κ h1 h2\n    haveI : Nonempty N := hN.nonempty\n    exact ⟨hN.theory_model.bundled, rfl⟩\n\n"}
{"name":"FirstOrder.Language.Theory.models_formula_iff","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nφ : L.Formula α\n⊢ Iff (T.ModelsBoundedFormula φ) (∀ (M : T.ModelType) (v : α → ↑M), φ.Realize v)","decl":"theorem models_formula_iff {φ : L.Formula α} :\n    T ⊨ᵇ φ ↔ ∀ (M : ModelType.{u, v, max u v w} T) (v : α → M), φ.Realize v :=\n  forall_congr' fun _ => forall_congr' fun _ => Unique.forall_iff\n\n"}
{"name":"FirstOrder.Language.Theory.models_sentence_iff","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nφ : L.Sentence\n⊢ Iff (T.ModelsBoundedFormula φ) (∀ (M : T.ModelType), FirstOrder.Language.Sentence.Realize (↑M) φ)","decl":"theorem models_sentence_iff {φ : L.Sentence} : T ⊨ᵇ φ ↔ ∀ M : ModelType.{u, v, max u v} T, M ⊨ φ :=\n  models_formula_iff.trans (forall_congr' fun _ => Unique.forall_iff)\n\n"}
{"name":"FirstOrder.Language.Theory.models_sentence_of_mem","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nφ : L.Sentence\nh : Membership.mem T φ\n⊢ T.ModelsBoundedFormula φ","decl":"theorem models_sentence_of_mem {φ : L.Sentence} (h : φ ∈ T) : T ⊨ᵇ φ :=\n  models_sentence_iff.2 fun _ => realize_sentence_of_mem T h\n\n"}
{"name":"FirstOrder.Language.Theory.models_iff_not_satisfiable","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nφ : L.Sentence\n⊢ Iff (T.ModelsBoundedFormula φ) (Not (Union.union T (Singleton.singleton (FirstOrder.Language.Formula.not φ))).IsSatisfiable)","decl":"theorem models_iff_not_satisfiable (φ : L.Sentence) : T ⊨ᵇ φ ↔ ¬IsSatisfiable (T ∪ {φ.not}) := by\n  rw [models_sentence_iff, IsSatisfiable]\n  refine\n    ⟨fun h1 h2 =>\n      (Sentence.realize_not _).1\n        (realize_sentence_of_mem (T ∪ {Formula.not φ})\n          (Set.subset_union_right (Set.mem_singleton _)))\n        (h1 (h2.some.subtheoryModel Set.subset_union_left)),\n      fun h M => ?_⟩\n  contrapose! h\n  rw [← Sentence.realize_not] at h\n  refine\n    ⟨{  Carrier := M\n        is_model := ⟨fun ψ hψ => hψ.elim (realize_sentence_of_mem _) fun h' => ?_⟩ }⟩\n  rw [Set.mem_singleton_iff.1 h']\n  exact h\n\n"}
{"name":"FirstOrder.Language.Theory.ModelsBoundedFormula.realize_sentence","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nφ : L.Sentence\nh : T.ModelsBoundedFormula φ\nM : Type u_1\ninst✝² : L.Structure M\ninst✝¹ : FirstOrder.Language.Theory.Model M T\ninst✝ : Nonempty M\n⊢ FirstOrder.Language.Sentence.Realize M φ","decl":"theorem ModelsBoundedFormula.realize_sentence {φ : L.Sentence} (h : T ⊨ᵇ φ) (M : Type*)\n    [L.Structure M] [M ⊨ T] [Nonempty M] : M ⊨ φ := by\n  rw [models_iff_not_satisfiable] at h\n  contrapose! h\n  have : M ⊨ T ∪ {Formula.not φ} := by\n    simp only [Set.union_singleton, model_iff, Set.mem_insert_iff, forall_eq_or_imp,\n      Sentence.realize_not]\n    rw [← model_iff]\n    exact ⟨h, inferInstance⟩\n  exact Model.isSatisfiable M\n\n"}
{"name":"FirstOrder.Language.Theory.models_formula_iff_onTheory_models_equivSentence","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nφ : L.Formula α\n⊢ Iff (T.ModelsBoundedFormula φ) (((L.lhomWithConstants α).onTheory T).ModelsBoundedFormula (FirstOrder.Language.Formula.equivSentence φ))","decl":"theorem models_formula_iff_onTheory_models_equivSentence {φ : L.Formula α} :\n    T ⊨ᵇ φ ↔ (L.lhomWithConstants α).onTheory T ⊨ᵇ Formula.equivSentence φ := by\n  refine ⟨fun h => models_sentence_iff.2 (fun M => ?_),\n    fun h => models_formula_iff.2 (fun M v => ?_)⟩\n  · letI := (L.lhomWithConstants α).reduct M\n    have : (L.lhomWithConstants α).IsExpansionOn M := LHom.isExpansionOn_reduct _ _\n      -- why doesn't that instance just work?\n    rw [Formula.realize_equivSentence]\n    have : M ⊨ T := (LHom.onTheory_model _ _).1 M.is_model -- why isn't M.is_model inferInstance?\n    let M' := Theory.ModelType.of T M\n    exact h M' (fun a => (L.con a : M)) _\n  · letI : (constantsOn α).Structure M := constantsOn.structure v\n    have : M ⊨ (L.lhomWithConstants α).onTheory T := (LHom.onTheory_model _ _).2 inferInstance\n    exact (Formula.realize_equivSentence _ _).1 (h.realize_sentence M)\n\n"}
{"name":"FirstOrder.Language.Theory.ModelsBoundedFormula.realize_formula","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nφ : L.Formula α\nh : T.ModelsBoundedFormula φ\nM : Type u_1\ninst✝² : L.Structure M\ninst✝¹ : FirstOrder.Language.Theory.Model M T\ninst✝ : Nonempty M\nv : α → M\n⊢ φ.Realize v","decl":"theorem ModelsBoundedFormula.realize_formula {φ : L.Formula α} (h : T ⊨ᵇ φ) (M : Type*)\n    [L.Structure M] [M ⊨ T] [Nonempty M] {v : α → M} : φ.Realize v := by\n  rw [models_formula_iff_onTheory_models_equivSentence] at h\n  letI : (constantsOn α).Structure M := constantsOn.structure v\n  have : M ⊨ (L.lhomWithConstants α).onTheory T := (LHom.onTheory_model _ _).2 inferInstance\n  exact (Formula.realize_equivSentence _ _).1 (h.realize_sentence M)\n\n"}
{"name":"FirstOrder.Language.Theory.models_toFormula_iff","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ : L.BoundedFormula α n\n⊢ Iff (T.ModelsBoundedFormula φ.toFormula) (T.ModelsBoundedFormula φ)","decl":"theorem models_toFormula_iff {φ : L.BoundedFormula α n} : T ⊨ᵇ φ.toFormula ↔ T ⊨ᵇ φ := by\n  refine ⟨fun h M v xs => ?_, ?_⟩\n  · have h' : φ.toFormula.Realize (Sum.elim v xs) := h.realize_formula M\n    simp only [BoundedFormula.realize_toFormula, Sum.elim_comp_inl, Sum.elim_comp_inr] at h'\n    exact h'\n  · simp only [models_formula_iff, BoundedFormula.realize_toFormula]\n    exact fun h M v => h M _ _\n\n"}
{"name":"FirstOrder.Language.Theory.ModelsBoundedFormula.realize_boundedFormula","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ : L.BoundedFormula α n\nh : T.ModelsBoundedFormula φ\nM : Type u_1\ninst✝² : L.Structure M\ninst✝¹ : FirstOrder.Language.Theory.Model M T\ninst✝ : Nonempty M\nv : α → M\nxs : Fin n → M\n⊢ φ.Realize v xs","decl":"theorem ModelsBoundedFormula.realize_boundedFormula\n    {φ : L.BoundedFormula α n} (h : T ⊨ᵇ φ) (M : Type*)\n    [L.Structure M] [M ⊨ T] [Nonempty M] {v : α → M} {xs : Fin n → M} : φ.Realize v xs := by\n  have h' : φ.toFormula.Realize (Sum.elim v xs) := (models_toFormula_iff.2 h).realize_formula M\n  simp only [BoundedFormula.realize_toFormula, Sum.elim_comp_inl, Sum.elim_comp_inr] at h'\n  exact h'\n\n"}
{"name":"FirstOrder.Language.Theory.models_of_models_theory","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nT' : L.Theory\nh : ∀ (φ : L.Sentence), Membership.mem T' φ → T.ModelsBoundedFormula φ\nφ : L.Formula α\nhφ : T'.ModelsBoundedFormula φ\n⊢ T.ModelsBoundedFormula φ","decl":"theorem models_of_models_theory {T' : L.Theory}\n    (h : ∀ φ : L.Sentence, φ ∈ T' → T ⊨ᵇ φ)\n    {φ : L.Formula α} (hφ : T' ⊨ᵇ φ) : T ⊨ᵇ φ := fun M => by\n  have hM : M ⊨ T' := T'.model_iff.2 (fun ψ hψ => (h ψ hψ).realize_sentence M)\n  let M' : ModelType T' := ⟨M⟩\n  exact hφ M'\n\n"}
{"name":"FirstOrder.Language.Theory.models_iff_finset_models","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nφ : L.Sentence\n⊢ Iff (T.ModelsBoundedFormula φ) (Exists fun T0 => And (HasSubset.Subset (↑T0) T) (FirstOrder.Language.Theory.ModelsBoundedFormula (↑T0) φ))","decl":"/-- An alternative statement of the Compactness Theorem. A formula `φ` is modeled by a\ntheory iff there is a finite subset `T0` of the theory such that `φ` is modeled by `T0` -/\ntheorem models_iff_finset_models {φ : L.Sentence} :\n    T ⊨ᵇ φ ↔ ∃ T0 : Finset L.Sentence, (T0 : L.Theory) ⊆ T ∧ (T0 : L.Theory) ⊨ᵇ φ := by\n  simp only [models_iff_not_satisfiable]\n  rw [← not_iff_not, not_not, isSatisfiable_iff_isFinitelySatisfiable, IsFinitelySatisfiable]\n  push_neg\n  letI := Classical.decEq (Sentence L)\n  constructor\n  · intro h T0 hT0\n    simpa using h (T0 ∪ {Formula.not φ})\n      (by\n        simp only [Finset.coe_union, Finset.coe_singleton]\n        exact Set.union_subset_union hT0 (Set.Subset.refl _))\n  · intro h T0 hT0\n    exact IsSatisfiable.mono (h (T0.erase (Formula.not φ))\n      (by simpa using hT0)) (by simp)\n\n"}
{"name":"FirstOrder.Language.Theory.IsComplete.models_not_iff","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nh : T.IsComplete\nφ : L.Sentence\n⊢ Iff (T.ModelsBoundedFormula (FirstOrder.Language.Formula.not φ)) (Not (T.ModelsBoundedFormula φ))","decl":"theorem models_not_iff (h : T.IsComplete) (φ : L.Sentence) : T ⊨ᵇ φ.not ↔ ¬T ⊨ᵇ φ := by\n  cases' h.2 φ with hφ hφn\n  · simp only [hφ, not_true, iff_false]\n    rw [models_sentence_iff, not_forall]\n    refine ⟨h.1.some, ?_⟩\n    simp only [Sentence.realize_not, Classical.not_not]\n    exact models_sentence_iff.1 hφ _\n  · simp only [hφn, true_iff]\n    intro hφ\n    rw [models_sentence_iff] at *\n    exact hφn h.1.some (hφ _)\n\n"}
{"name":"FirstOrder.Language.Theory.IsComplete.realize_sentence_iff","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nh : T.IsComplete\nφ : L.Sentence\nM : Type u_1\ninst✝² : L.Structure M\ninst✝¹ : FirstOrder.Language.Theory.Model M T\ninst✝ : Nonempty M\n⊢ Iff (FirstOrder.Language.Sentence.Realize M φ) (T.ModelsBoundedFormula φ)","decl":"theorem realize_sentence_iff (h : T.IsComplete) (φ : L.Sentence) (M : Type*) [L.Structure M]\n    [M ⊨ T] [Nonempty M] : M ⊨ φ ↔ T ⊨ᵇ φ := by\n  cases' h.2 φ with hφ hφn\n  · exact iff_of_true (hφ.realize_sentence M) hφ\n  · exact\n      iff_of_false ((Sentence.realize_not M).1 (hφn.realize_sentence M))\n        ((h.models_not_iff φ).1 hφn)\n\n"}
{"name":"FirstOrder.Language.Theory.IsMaximal.isComplete","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nh : T.IsMaximal\n⊢ T.IsComplete","decl":"theorem IsMaximal.isComplete (h : T.IsMaximal) : T.IsComplete :=\n  h.imp_right (forall_imp fun _ => Or.imp models_sentence_of_mem models_sentence_of_mem)\n\n"}
{"name":"FirstOrder.Language.Theory.IsMaximal.mem_or_not_mem","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nh : T.IsMaximal\nφ : L.Sentence\n⊢ Or (Membership.mem T φ) (Membership.mem T (FirstOrder.Language.Formula.not φ))","decl":"theorem IsMaximal.mem_or_not_mem (h : T.IsMaximal) (φ : L.Sentence) : φ ∈ T ∨ φ.not ∈ T :=\n  h.2 φ\n\n"}
{"name":"FirstOrder.Language.Theory.IsMaximal.mem_of_models","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nh : T.IsMaximal\nφ : L.Sentence\nhφ : T.ModelsBoundedFormula φ\n⊢ Membership.mem T φ","decl":"theorem IsMaximal.mem_of_models (h : T.IsMaximal) {φ : L.Sentence} (hφ : T ⊨ᵇ φ) : φ ∈ T := by\n  refine (h.mem_or_not_mem φ).resolve_right fun con => ?_\n  rw [models_iff_not_satisfiable, Set.union_singleton, Set.insert_eq_of_mem con] at hφ\n  exact hφ h.1\n\n"}
{"name":"FirstOrder.Language.Theory.IsMaximal.mem_iff_models","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nh : T.IsMaximal\nφ : L.Sentence\n⊢ Iff (Membership.mem T φ) (T.ModelsBoundedFormula φ)","decl":"theorem IsMaximal.mem_iff_models (h : T.IsMaximal) (φ : L.Sentence) : φ ∈ T ↔ T ⊨ᵇ φ :=\n  ⟨models_sentence_of_mem, h.mem_of_models⟩\n\n"}
{"name":"FirstOrder.Language.completeTheory.isSatisfiable","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\ninst✝ : Nonempty M\n⊢ (L.completeTheory M).IsSatisfiable","decl":"theorem isSatisfiable [Nonempty M] : (L.completeTheory M).IsSatisfiable :=\n  Theory.Model.isSatisfiable M\n\n"}
{"name":"FirstOrder.Language.completeTheory.mem_or_not_mem","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nφ : L.Sentence\n⊢ Or (Membership.mem (L.completeTheory M) φ) (Membership.mem (L.completeTheory M) (FirstOrder.Language.Formula.not φ))","decl":"theorem mem_or_not_mem (φ : L.Sentence) : φ ∈ L.completeTheory M ∨ φ.not ∈ L.completeTheory M := by\n  simp_rw [completeTheory, Set.mem_setOf_eq, Sentence.Realize, Formula.realize_not, or_not]\n\n"}
{"name":"FirstOrder.Language.completeTheory.isMaximal","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\ninst✝ : Nonempty M\n⊢ (L.completeTheory M).IsMaximal","decl":"theorem isMaximal [Nonempty M] : (L.completeTheory M).IsMaximal :=\n  ⟨isSatisfiable L M, mem_or_not_mem L M⟩\n\n"}
{"name":"FirstOrder.Language.completeTheory.isComplete","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\ninst✝ : Nonempty M\n⊢ (L.completeTheory M).IsComplete","decl":"theorem isComplete [Nonempty M] : (L.completeTheory M).IsComplete :=\n  (completeTheory.isMaximal L M).isComplete\n\n"}
{"name":"Cardinal.Categorical.isComplete","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"L : FirstOrder.Language\nκ : Cardinal.{w}\nT : L.Theory\nh : κ.Categorical T\nh1 : LE.le Cardinal.aleph0 κ\nh2 : LE.le (Cardinal.lift.{w, max u v} L.card) (Cardinal.lift.{max u v, w} κ)\nhS : T.IsSatisfiable\nhT : ∀ (M : T.ModelType), Infinite ↑M\n⊢ T.IsComplete","decl":"/-- The Łoś–Vaught Test : a criterion for categorical theories to be complete. -/\ntheorem Categorical.isComplete (h : κ.Categorical T) (h1 : ℵ₀ ≤ κ)\n    (h2 : Cardinal.lift.{w} L.card ≤ Cardinal.lift.{max u v} κ) (hS : T.IsSatisfiable)\n    (hT : ∀ M : Theory.ModelType.{u, v, max u v} T, Infinite M) : T.IsComplete :=\n  ⟨hS, fun φ => by\n    obtain ⟨_, _⟩ := Theory.exists_model_card_eq ⟨hS.some, hT hS.some⟩ κ h1 h2\n    rw [Theory.models_sentence_iff, Theory.models_sentence_iff]\n    by_contra! con\n    obtain ⟨⟨MF, hMF⟩, MT, hMT⟩ := con\n    rw [Sentence.realize_not, Classical.not_not] at hMT\n    refine hMF ?_\n    haveI := hT MT\n    haveI := hT MF\n    obtain ⟨NT, MNT, hNT⟩ := exists_elementarilyEquivalent_card_eq L MT κ h1 h2\n    obtain ⟨NF, MNF, hNF⟩ := exists_elementarilyEquivalent_card_eq L MF κ h1 h2\n    obtain ⟨TF⟩ := h (MNT.toModel T) (MNF.toModel T) hNT hNF\n    exact\n      ((MNT.realize_sentence φ).trans\n        ((StrongHomClass.realize_sentence TF φ).trans (MNF.realize_sentence φ).symm)).1 hMT⟩\n\n"}
{"name":"Cardinal.empty_theory_categorical","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"κ : Cardinal.{w}\nT : FirstOrder.Language.empty.Theory\n⊢ κ.Categorical T","decl":"theorem empty_theory_categorical (T : Language.empty.Theory) : κ.Categorical T := fun M N hM hN =>\n  by rw [empty.nonempty_equiv_iff, hM, hN]\n\n"}
{"name":"Cardinal.empty_infinite_Theory_isComplete","module":"Mathlib.ModelTheory.Satisfiability","initialProofState":"⊢ FirstOrder.Language.empty.infiniteTheory.IsComplete","decl":"theorem empty_infinite_Theory_isComplete : Language.empty.infiniteTheory.IsComplete :=\n  (empty_theory_categorical.{0} ℵ₀ _).isComplete ℵ₀ _ le_rfl (by simp)\n    ⟨by\n      haveI : Language.empty.Structure ℕ := emptyStructure\n      exact ((model_infiniteTheory_iff Language.empty).2 (inferInstanceAs (Infinite ℕ))).bundled⟩\n    fun M => (model_infiniteTheory_iff Language.empty).1 M.is_model\n\n"}
