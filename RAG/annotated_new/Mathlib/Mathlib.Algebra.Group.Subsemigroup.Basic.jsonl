{"name":"Subsemigroup.coe_sInf","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\nS : Set (Subsemigroup M)\n⊢ Eq (↑(InfSet.sInf S)) (Set.iInter fun s => Set.iInter fun h => ↑s)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_sInf (S : Set (Subsemigroup M)) : ((sInf S : Subsemigroup M) : Set M) = ⋂ s ∈ S, ↑s :=\n  rfl\n\n"}
{"name":"AddSubsemigroup.coe_sInf","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Add M\nS : Set (AddSubsemigroup M)\n⊢ Eq (↑(InfSet.sInf S)) (Set.iInter fun s => Set.iInter fun h => ↑s)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_sInf (S : Set (Subsemigroup M)) : ((sInf S : Subsemigroup M) : Set M) = ⋂ s ∈ S, ↑s :=\n  rfl\n\n"}
{"name":"AddSubsemigroup.mem_sInf","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Add M\nS : Set (AddSubsemigroup M)\nx : M\n⊢ Iff (Membership.mem (InfSet.sInf S) x) (∀ (p : AddSubsemigroup M), Membership.mem S p → Membership.mem p x)","decl":"@[to_additive]\ntheorem mem_sInf {S : Set (Subsemigroup M)} {x : M} : x ∈ sInf S ↔ ∀ p ∈ S, x ∈ p :=\n  Set.mem_iInter₂\n\n"}
{"name":"Subsemigroup.mem_sInf","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\nS : Set (Subsemigroup M)\nx : M\n⊢ Iff (Membership.mem (InfSet.sInf S) x) (∀ (p : Subsemigroup M), Membership.mem S p → Membership.mem p x)","decl":"@[to_additive]\ntheorem mem_sInf {S : Set (Subsemigroup M)} {x : M} : x ∈ sInf S ↔ ∀ p ∈ S, x ∈ p :=\n  Set.mem_iInter₂\n\n"}
{"name":"AddSubsemigroup.mem_iInf","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Add M\nι : Sort u_3\nS : ι → AddSubsemigroup M\nx : M\n⊢ Iff (Membership.mem (iInf fun i => S i) x) (∀ (i : ι), Membership.mem (S i) x)","decl":"@[to_additive]\ntheorem mem_iInf {ι : Sort*} {S : ι → Subsemigroup M} {x : M} : (x ∈ ⨅ i, S i) ↔ ∀ i, x ∈ S i := by\n  simp only [iInf, mem_sInf, Set.forall_mem_range]\n\n"}
{"name":"Subsemigroup.mem_iInf","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\nι : Sort u_3\nS : ι → Subsemigroup M\nx : M\n⊢ Iff (Membership.mem (iInf fun i => S i) x) (∀ (i : ι), Membership.mem (S i) x)","decl":"@[to_additive]\ntheorem mem_iInf {ι : Sort*} {S : ι → Subsemigroup M} {x : M} : (x ∈ ⨅ i, S i) ↔ ∀ i, x ∈ S i := by\n  simp only [iInf, mem_sInf, Set.forall_mem_range]\n\n"}
{"name":"AddSubsemigroup.coe_iInf","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Add M\nι : Sort u_3\nS : ι → AddSubsemigroup M\n⊢ Eq (↑(iInf fun i => S i)) (Set.iInter fun i => ↑(S i))","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_iInf {ι : Sort*} {S : ι → Subsemigroup M} : (↑(⨅ i, S i) : Set M) = ⋂ i, S i := by\n  simp only [iInf, coe_sInf, Set.biInter_range]\n\n"}
{"name":"Subsemigroup.coe_iInf","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\nι : Sort u_3\nS : ι → Subsemigroup M\n⊢ Eq (↑(iInf fun i => S i)) (Set.iInter fun i => ↑(S i))","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_iInf {ι : Sort*} {S : ι → Subsemigroup M} : (↑(⨅ i, S i) : Set M) = ⋂ i, S i := by\n  simp only [iInf, coe_sInf, Set.biInter_range]\n\n"}
{"name":"AddSubsemigroup.mem_closure","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Add M\ns : Set M\nx : M\n⊢ Iff (Membership.mem (AddSubsemigroup.closure s) x) (∀ (S : AddSubsemigroup M), HasSubset.Subset s ↑S → Membership.mem S x)","decl":"@[to_additive]\ntheorem mem_closure {x : M} : x ∈ closure s ↔ ∀ S : Subsemigroup M, s ⊆ S → x ∈ S :=\n  mem_sInf\n\n"}
{"name":"Subsemigroup.mem_closure","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\ns : Set M\nx : M\n⊢ Iff (Membership.mem (Subsemigroup.closure s) x) (∀ (S : Subsemigroup M), HasSubset.Subset s ↑S → Membership.mem S x)","decl":"@[to_additive]\ntheorem mem_closure {x : M} : x ∈ closure s ↔ ∀ S : Subsemigroup M, s ⊆ S → x ∈ S :=\n  mem_sInf\n\n"}
{"name":"Subsemigroup.subset_closure","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\ns : Set M\n⊢ HasSubset.Subset s ↑(Subsemigroup.closure s)","decl":"/-- The subsemigroup generated by a set includes the set. -/\n@[to_additive (attr := simp, aesop safe 20 apply (rule_sets := [SetLike]))\n  \"The `AddSubsemigroup` generated by a set includes the set.\"]\ntheorem subset_closure : s ⊆ closure s := fun _ hx => mem_closure.2 fun _ hS => hS hx\n\n"}
{"name":"AddSubsemigroup.subset_closure","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Add M\ns : Set M\n⊢ HasSubset.Subset s ↑(AddSubsemigroup.closure s)","decl":"/-- The subsemigroup generated by a set includes the set. -/\n@[to_additive (attr := simp, aesop safe 20 apply (rule_sets := [SetLike]))\n  \"The `AddSubsemigroup` generated by a set includes the set.\"]\ntheorem subset_closure : s ⊆ closure s := fun _ hx => mem_closure.2 fun _ hS => hS hx\n\n"}
{"name":"AddSubsemigroup.not_mem_of_not_mem_closure","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Add M\ns : Set M\nP : M\nhP : Not (Membership.mem (AddSubsemigroup.closure s) P)\n⊢ Not (Membership.mem s P)","decl":"@[to_additive]\ntheorem not_mem_of_not_mem_closure {P : M} (hP : P ∉ closure s) : P ∉ s := fun h =>\n  hP (subset_closure h)\n\n"}
{"name":"Subsemigroup.not_mem_of_not_mem_closure","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\ns : Set M\nP : M\nhP : Not (Membership.mem (Subsemigroup.closure s) P)\n⊢ Not (Membership.mem s P)","decl":"@[to_additive]\ntheorem not_mem_of_not_mem_closure {P : M} (hP : P ∉ closure s) : P ∉ s := fun h =>\n  hP (subset_closure h)\n\n"}
{"name":"Subsemigroup.closure_le","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\ns : Set M\nS : Subsemigroup M\n⊢ Iff (LE.le (Subsemigroup.closure s) S) (HasSubset.Subset s ↑S)","decl":"/-- A subsemigroup `S` includes `closure s` if and only if it includes `s`. -/\n@[to_additive (attr := simp)\n  \"An additive subsemigroup `S` includes `closure s` if and only if it includes `s`\"]\ntheorem closure_le : closure s ≤ S ↔ s ⊆ S :=\n  ⟨Subset.trans subset_closure, fun h => sInf_le h⟩\n\n"}
{"name":"AddSubsemigroup.closure_le","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Add M\ns : Set M\nS : AddSubsemigroup M\n⊢ Iff (LE.le (AddSubsemigroup.closure s) S) (HasSubset.Subset s ↑S)","decl":"/-- A subsemigroup `S` includes `closure s` if and only if it includes `s`. -/\n@[to_additive (attr := simp)\n  \"An additive subsemigroup `S` includes `closure s` if and only if it includes `s`\"]\ntheorem closure_le : closure s ≤ S ↔ s ⊆ S :=\n  ⟨Subset.trans subset_closure, fun h => sInf_le h⟩\n\n"}
{"name":"Subsemigroup.closure_mono","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\ns t : Set M\nh : HasSubset.Subset s t\n⊢ LE.le (Subsemigroup.closure s) (Subsemigroup.closure t)","decl":"/-- subsemigroup closure of a set is monotone in its argument: if `s ⊆ t`,\nthen `closure s ≤ closure t`. -/\n@[to_additive (attr := gcongr) \"Additive subsemigroup closure of a set is monotone in its argument:\nif `s ⊆ t`, then `closure s ≤ closure t`\"]\ntheorem closure_mono ⦃s t : Set M⦄ (h : s ⊆ t) : closure s ≤ closure t :=\n  closure_le.2 <| Subset.trans h subset_closure\n\n"}
{"name":"AddSubsemigroup.closure_mono","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Add M\ns t : Set M\nh : HasSubset.Subset s t\n⊢ LE.le (AddSubsemigroup.closure s) (AddSubsemigroup.closure t)","decl":"/-- subsemigroup closure of a set is monotone in its argument: if `s ⊆ t`,\nthen `closure s ≤ closure t`. -/\n@[to_additive (attr := gcongr) \"Additive subsemigroup closure of a set is monotone in its argument:\nif `s ⊆ t`, then `closure s ≤ closure t`\"]\ntheorem closure_mono ⦃s t : Set M⦄ (h : s ⊆ t) : closure s ≤ closure t :=\n  closure_le.2 <| Subset.trans h subset_closure\n\n"}
{"name":"AddSubsemigroup.closure_eq_of_le","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Add M\ns : Set M\nS : AddSubsemigroup M\nh₁ : HasSubset.Subset s ↑S\nh₂ : LE.le S (AddSubsemigroup.closure s)\n⊢ Eq (AddSubsemigroup.closure s) S","decl":"@[to_additive]\ntheorem closure_eq_of_le (h₁ : s ⊆ S) (h₂ : S ≤ closure s) : closure s = S :=\n  le_antisymm (closure_le.2 h₁) h₂\n\n"}
{"name":"Subsemigroup.closure_eq_of_le","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\ns : Set M\nS : Subsemigroup M\nh₁ : HasSubset.Subset s ↑S\nh₂ : LE.le S (Subsemigroup.closure s)\n⊢ Eq (Subsemigroup.closure s) S","decl":"@[to_additive]\ntheorem closure_eq_of_le (h₁ : s ⊆ S) (h₂ : S ≤ closure s) : closure s = S :=\n  le_antisymm (closure_le.2 h₁) h₂\n\n"}
{"name":"AddSubsemigroup.closure_induction","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Add M\ns : Set M\np : (x : M) → Membership.mem (AddSubsemigroup.closure s) x → Prop\nmem : ∀ (x : M) (h : Membership.mem s x), p x ⋯\nmul : ∀ (x y : M) (hx : Membership.mem (AddSubsemigroup.closure s) x) (hy : Membership.mem (AddSubsemigroup.closure s) y), p x hx → p y hy → p (HAdd.hAdd x y) ⋯\nx : M\nhx : Membership.mem (AddSubsemigroup.closure s) x\n⊢ p x hx","decl":"/-- An induction principle for closure membership. If `p` holds for all elements of `s`, and\nis preserved under multiplication, then `p` holds for all elements of the closure of `s`. -/\n@[to_additive (attr := elab_as_elim) \"An induction principle for additive closure membership. If `p`\n  holds for all elements of `s`, and is preserved under addition, then `p` holds for all\n  elements of the additive closure of `s`.\"]\ntheorem closure_induction {p : (x : M) → x ∈ closure s → Prop}\n    (mem : ∀ (x) (h : x ∈ s), p x (subset_closure h))\n    (mul : ∀ x y hx hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) {x} (hx : x ∈ closure s) :\n    p x hx :=\n  let S : Subsemigroup M :=\n    { carrier := { x | ∃ hx, p x hx }\n      mul_mem' := fun ⟨_, hpx⟩ ⟨_, hpy⟩ ↦ ⟨_, mul _ _ _ _ hpx hpy⟩ }\n  closure_le (S := S) |>.mpr (fun y hy ↦ ⟨subset_closure hy, mem y hy⟩) hx |>.elim fun _ ↦ id\n\n"}
{"name":"Subsemigroup.closure_induction","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\ns : Set M\np : (x : M) → Membership.mem (Subsemigroup.closure s) x → Prop\nmem : ∀ (x : M) (h : Membership.mem s x), p x ⋯\nmul : ∀ (x y : M) (hx : Membership.mem (Subsemigroup.closure s) x) (hy : Membership.mem (Subsemigroup.closure s) y), p x hx → p y hy → p (HMul.hMul x y) ⋯\nx : M\nhx : Membership.mem (Subsemigroup.closure s) x\n⊢ p x hx","decl":"/-- An induction principle for closure membership. If `p` holds for all elements of `s`, and\nis preserved under multiplication, then `p` holds for all elements of the closure of `s`. -/\n@[to_additive (attr := elab_as_elim) \"An induction principle for additive closure membership. If `p`\n  holds for all elements of `s`, and is preserved under addition, then `p` holds for all\n  elements of the additive closure of `s`.\"]\ntheorem closure_induction {p : (x : M) → x ∈ closure s → Prop}\n    (mem : ∀ (x) (h : x ∈ s), p x (subset_closure h))\n    (mul : ∀ x y hx hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) {x} (hx : x ∈ closure s) :\n    p x hx :=\n  let S : Subsemigroup M :=\n    { carrier := { x | ∃ hx, p x hx }\n      mul_mem' := fun ⟨_, hpx⟩ ⟨_, hpy⟩ ↦ ⟨_, mul _ _ _ _ hpx hpy⟩ }\n  closure_le (S := S) |>.mpr (fun y hy ↦ ⟨subset_closure hy, mem y hy⟩) hx |>.elim fun _ ↦ id\n\n"}
{"name":"Subsemigroup.closure_induction'","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\ns : Set M\np : (x : M) → Membership.mem (Subsemigroup.closure s) x → Prop\nmem : ∀ (x : M) (h : Membership.mem s x), p x ⋯\nmul : ∀ (x y : M) (hx : Membership.mem (Subsemigroup.closure s) x) (hy : Membership.mem (Subsemigroup.closure s) y), p x hx → p y hy → p (HMul.hMul x y) ⋯\nx : M\nhx : Membership.mem (Subsemigroup.closure s) x\n⊢ p x hx","decl":"@[deprecated closure_induction (since := \"2024-10-09\")]\nalias closure_induction' := closure_induction\n\n"}
{"name":"AddSubsemigroup.closure_induction₂","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Add M\ns : Set M\np : (x y : M) → Membership.mem (AddSubsemigroup.closure s) x → Membership.mem (AddSubsemigroup.closure s) y → Prop\nmem : ∀ (x y : M) (hx : Membership.mem s x) (hy : Membership.mem s y), p x y ⋯ ⋯\nmul_left : ∀ (x y z : M) (hx : Membership.mem (AddSubsemigroup.closure s) x) (hy : Membership.mem (AddSubsemigroup.closure s) y) (hz : Membership.mem (AddSubsemigroup.closure s) z), p x z hx hz → p y z hy hz → p (HAdd.hAdd x y) z ⋯ hz\nmul_right : ∀ (x y z : M) (hx : Membership.mem (AddSubsemigroup.closure s) x) (hy : Membership.mem (AddSubsemigroup.closure s) y) (hz : Membership.mem (AddSubsemigroup.closure s) z), p z x hz hx → p z y hz hy → p z (HAdd.hAdd x y) hz ⋯\nx y : M\nhx : Membership.mem (AddSubsemigroup.closure s) x\nhy : Membership.mem (AddSubsemigroup.closure s) y\n⊢ p x y hx hy","decl":"/-- An induction principle for closure membership for predicates with two arguments. -/\n@[to_additive (attr := elab_as_elim) \"An induction principle for additive closure membership for\n  predicates with two arguments.\"]\ntheorem closure_induction₂ {p : (x y : M) → x ∈ closure s → y ∈ closure s → Prop}\n    (mem : ∀ (x) (y) (hx : x ∈ s) (hy : y ∈ s), p x y (subset_closure hx) (subset_closure hy))\n    (mul_left : ∀ x y z hx hy hz, p x z hx hz → p y z hy hz → p (x * y) z (mul_mem hx hy) hz)\n    (mul_right : ∀ x y z hx hy hz, p z x hz hx → p z y hz hy → p z (x * y) hz (mul_mem hx hy))\n    {x y : M} (hx : x ∈ closure s) (hy : y ∈ closure s) : p x y hx hy := by\n  induction hx using closure_induction with\n  | mem z hz => induction hy using closure_induction with\n    | mem _ h => exact mem _ _ hz h\n    | mul _ _ _ _ h₁ h₂ => exact mul_right _ _ _ _ _ _ h₁ h₂\n  | mul _ _ _ _ h₁ h₂ => exact mul_left _ _ _ _ _ hy h₁ h₂\n\n"}
{"name":"Subsemigroup.closure_induction₂","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\ns : Set M\np : (x y : M) → Membership.mem (Subsemigroup.closure s) x → Membership.mem (Subsemigroup.closure s) y → Prop\nmem : ∀ (x y : M) (hx : Membership.mem s x) (hy : Membership.mem s y), p x y ⋯ ⋯\nmul_left : ∀ (x y z : M) (hx : Membership.mem (Subsemigroup.closure s) x) (hy : Membership.mem (Subsemigroup.closure s) y) (hz : Membership.mem (Subsemigroup.closure s) z), p x z hx hz → p y z hy hz → p (HMul.hMul x y) z ⋯ hz\nmul_right : ∀ (x y z : M) (hx : Membership.mem (Subsemigroup.closure s) x) (hy : Membership.mem (Subsemigroup.closure s) y) (hz : Membership.mem (Subsemigroup.closure s) z), p z x hz hx → p z y hz hy → p z (HMul.hMul x y) hz ⋯\nx y : M\nhx : Membership.mem (Subsemigroup.closure s) x\nhy : Membership.mem (Subsemigroup.closure s) y\n⊢ p x y hx hy","decl":"/-- An induction principle for closure membership for predicates with two arguments. -/\n@[to_additive (attr := elab_as_elim) \"An induction principle for additive closure membership for\n  predicates with two arguments.\"]\ntheorem closure_induction₂ {p : (x y : M) → x ∈ closure s → y ∈ closure s → Prop}\n    (mem : ∀ (x) (y) (hx : x ∈ s) (hy : y ∈ s), p x y (subset_closure hx) (subset_closure hy))\n    (mul_left : ∀ x y z hx hy hz, p x z hx hz → p y z hy hz → p (x * y) z (mul_mem hx hy) hz)\n    (mul_right : ∀ x y z hx hy hz, p z x hz hx → p z y hz hy → p z (x * y) hz (mul_mem hx hy))\n    {x y : M} (hx : x ∈ closure s) (hy : y ∈ closure s) : p x y hx hy := by\n  induction hx using closure_induction with\n  | mem z hz => induction hy using closure_induction with\n    | mem _ h => exact mem _ _ hz h\n    | mul _ _ _ _ h₁ h₂ => exact mul_right _ _ _ _ _ _ h₁ h₂\n  | mul _ _ _ _ h₁ h₂ => exact mul_left _ _ _ _ _ hy h₁ h₂\n\n"}
{"name":"AddSubsemigroup.dense_induction","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Add M\np : M → Prop\ns : Set M\nclosure : Eq (AddSubsemigroup.closure s) Top.top\nmem : ∀ (x : M), Membership.mem s x → p x\nmul : ∀ (x y : M), p x → p y → p (HAdd.hAdd x y)\nx : M\n⊢ p x","decl":"/-- If `s` is a dense set in a magma `M`, `Subsemigroup.closure s = ⊤`, then in order to prove that\nsome predicate `p` holds for all `x : M` it suffices to verify `p x` for `x ∈ s`,\nand verify that `p x` and `p y` imply `p (x * y)`. -/\n@[to_additive (attr := elab_as_elim) \"If `s` is a dense set in an additive monoid `M`,\n  `AddSubsemigroup.closure s = ⊤`, then in order to prove that some predicate `p` holds\n  for all `x : M` it suffices to verify `p x` for `x ∈ s`, and verify that `p x` and `p y` imply\n  `p (x + y)`.\"]\ntheorem dense_induction {p : M → Prop} (s : Set M) (closure : closure s = ⊤)\n    (mem : ∀ x ∈ s, p x) (mul : ∀ x y, p x → p y → p (x * y)) (x : M) :\n    p x := by\n  induction closure.symm ▸ mem_top x using closure_induction with\n  | mem _ h => exact mem _ h\n  | mul _ _ _ _ h₁ h₂ => exact mul _ _ h₁ h₂\n\n/- The argument `s : Set M` is explicit in `Subsemigroup.dense_induction` because the type of the\ninduction variable, namely `x : M`, does not reference `x`. Making `s` explicit allows the user\nto apply the induction principle while deferring the proof of `closure s = ⊤` without creating\nmetavariables, as in the following example. -/\n"}
{"name":"Subsemigroup.dense_induction","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\np : M → Prop\ns : Set M\nclosure : Eq (Subsemigroup.closure s) Top.top\nmem : ∀ (x : M), Membership.mem s x → p x\nmul : ∀ (x y : M), p x → p y → p (HMul.hMul x y)\nx : M\n⊢ p x","decl":"/-- If `s` is a dense set in a magma `M`, `Subsemigroup.closure s = ⊤`, then in order to prove that\nsome predicate `p` holds for all `x : M` it suffices to verify `p x` for `x ∈ s`,\nand verify that `p x` and `p y` imply `p (x * y)`. -/\n@[to_additive (attr := elab_as_elim) \"If `s` is a dense set in an additive monoid `M`,\n  `AddSubsemigroup.closure s = ⊤`, then in order to prove that some predicate `p` holds\n  for all `x : M` it suffices to verify `p x` for `x ∈ s`, and verify that `p x` and `p y` imply\n  `p (x + y)`.\"]\ntheorem dense_induction {p : M → Prop} (s : Set M) (closure : closure s = ⊤)\n    (mem : ∀ x ∈ s, p x) (mul : ∀ x y, p x → p y → p (x * y)) (x : M) :\n    p x := by\n  induction closure.symm ▸ mem_top x using closure_induction with\n  | mem _ h => exact mem _ h\n  | mul _ _ _ _ h₁ h₂ => exact mul _ _ h₁ h₂\n\n/- The argument `s : Set M` is explicit in `Subsemigroup.dense_induction` because the type of the\ninduction variable, namely `x : M`, does not reference `x`. Making `s` explicit allows the user\nto apply the induction principle while deferring the proof of `closure s = ⊤` without creating\nmetavariables, as in the following example. -/\n"}
{"name":"Subsemigroup.closure_eq","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\nS : Subsemigroup M\n⊢ Eq (Subsemigroup.closure ↑S) S","decl":"/-- Closure of a subsemigroup `S` equals `S`. -/\n@[to_additive (attr := simp) \"Additive closure of an additive subsemigroup `S` equals `S`\"]\ntheorem closure_eq : closure (S : Set M) = S :=\n  (Subsemigroup.gi M).l_u_eq S\n\n"}
{"name":"AddSubsemigroup.closure_eq","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Add M\nS : AddSubsemigroup M\n⊢ Eq (AddSubsemigroup.closure ↑S) S","decl":"/-- Closure of a subsemigroup `S` equals `S`. -/\n@[to_additive (attr := simp) \"Additive closure of an additive subsemigroup `S` equals `S`\"]\ntheorem closure_eq : closure (S : Set M) = S :=\n  (Subsemigroup.gi M).l_u_eq S\n\n"}
{"name":"Subsemigroup.closure_empty","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\n⊢ Eq (Subsemigroup.closure EmptyCollection.emptyCollection) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem closure_empty : closure (∅ : Set M) = ⊥ :=\n  (Subsemigroup.gi M).gc.l_bot\n\n"}
{"name":"AddSubsemigroup.closure_empty","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Add M\n⊢ Eq (AddSubsemigroup.closure EmptyCollection.emptyCollection) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem closure_empty : closure (∅ : Set M) = ⊥ :=\n  (Subsemigroup.gi M).gc.l_bot\n\n"}
{"name":"Subsemigroup.closure_univ","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\n⊢ Eq (Subsemigroup.closure Set.univ) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem closure_univ : closure (univ : Set M) = ⊤ :=\n  @coe_top M _ ▸ closure_eq ⊤\n\n"}
{"name":"AddSubsemigroup.closure_univ","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Add M\n⊢ Eq (AddSubsemigroup.closure Set.univ) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem closure_univ : closure (univ : Set M) = ⊤ :=\n  @coe_top M _ ▸ closure_eq ⊤\n\n"}
{"name":"Subsemigroup.closure_union","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\ns t : Set M\n⊢ Eq (Subsemigroup.closure (Union.union s t)) (Max.max (Subsemigroup.closure s) (Subsemigroup.closure t))","decl":"@[to_additive]\ntheorem closure_union (s t : Set M) : closure (s ∪ t) = closure s ⊔ closure t :=\n  (Subsemigroup.gi M).gc.l_sup\n\n"}
{"name":"AddSubsemigroup.closure_union","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Add M\ns t : Set M\n⊢ Eq (AddSubsemigroup.closure (Union.union s t)) (Max.max (AddSubsemigroup.closure s) (AddSubsemigroup.closure t))","decl":"@[to_additive]\ntheorem closure_union (s t : Set M) : closure (s ∪ t) = closure s ⊔ closure t :=\n  (Subsemigroup.gi M).gc.l_sup\n\n"}
{"name":"AddSubsemigroup.closure_iUnion","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Add M\nι : Sort u_3\ns : ι → Set M\n⊢ Eq (AddSubsemigroup.closure (Set.iUnion fun i => s i)) (iSup fun i => AddSubsemigroup.closure (s i))","decl":"@[to_additive]\ntheorem closure_iUnion {ι} (s : ι → Set M) : closure (⋃ i, s i) = ⨆ i, closure (s i) :=\n  (Subsemigroup.gi M).gc.l_iSup\n\n"}
{"name":"Subsemigroup.closure_iUnion","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\nι : Sort u_3\ns : ι → Set M\n⊢ Eq (Subsemigroup.closure (Set.iUnion fun i => s i)) (iSup fun i => Subsemigroup.closure (s i))","decl":"@[to_additive]\ntheorem closure_iUnion {ι} (s : ι → Set M) : closure (⋃ i, s i) = ⨆ i, closure (s i) :=\n  (Subsemigroup.gi M).gc.l_iSup\n\n"}
{"name":"AddSubsemigroup.closure_singleton_le_iff_mem","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Add M\nm : M\np : AddSubsemigroup M\n⊢ Iff (LE.le (AddSubsemigroup.closure (Singleton.singleton m)) p) (Membership.mem p m)","decl":"@[to_additive]\ntheorem closure_singleton_le_iff_mem (m : M) (p : Subsemigroup M) : closure {m} ≤ p ↔ m ∈ p := by\n  rw [closure_le, singleton_subset_iff, SetLike.mem_coe]\n\n"}
{"name":"Subsemigroup.closure_singleton_le_iff_mem","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\nm : M\np : Subsemigroup M\n⊢ Iff (LE.le (Subsemigroup.closure (Singleton.singleton m)) p) (Membership.mem p m)","decl":"@[to_additive]\ntheorem closure_singleton_le_iff_mem (m : M) (p : Subsemigroup M) : closure {m} ≤ p ↔ m ∈ p := by\n  rw [closure_le, singleton_subset_iff, SetLike.mem_coe]\n\n"}
{"name":"AddSubsemigroup.mem_iSup","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Add M\nι : Sort u_3\np : ι → AddSubsemigroup M\nm : M\n⊢ Iff (Membership.mem (iSup fun i => p i) m) (∀ (N : AddSubsemigroup M), (∀ (i : ι), LE.le (p i) N) → Membership.mem N m)","decl":"@[to_additive]\ntheorem mem_iSup {ι : Sort*} (p : ι → Subsemigroup M) {m : M} :\n    (m ∈ ⨆ i, p i) ↔ ∀ N, (∀ i, p i ≤ N) → m ∈ N := by\n  rw [← closure_singleton_le_iff_mem, le_iSup_iff]\n  simp only [closure_singleton_le_iff_mem]\n\n"}
{"name":"Subsemigroup.mem_iSup","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\nι : Sort u_3\np : ι → Subsemigroup M\nm : M\n⊢ Iff (Membership.mem (iSup fun i => p i) m) (∀ (N : Subsemigroup M), (∀ (i : ι), LE.le (p i) N) → Membership.mem N m)","decl":"@[to_additive]\ntheorem mem_iSup {ι : Sort*} (p : ι → Subsemigroup M) {m : M} :\n    (m ∈ ⨆ i, p i) ↔ ∀ N, (∀ i, p i ≤ N) → m ∈ N := by\n  rw [← closure_singleton_le_iff_mem, le_iSup_iff]\n  simp only [closure_singleton_le_iff_mem]\n\n"}
{"name":"AddSubsemigroup.iSup_eq_closure","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Add M\nι : Sort u_3\np : ι → AddSubsemigroup M\n⊢ Eq (iSup fun i => p i) (AddSubsemigroup.closure (Set.iUnion fun i => ↑(p i)))","decl":"@[to_additive]\ntheorem iSup_eq_closure {ι : Sort*} (p : ι → Subsemigroup M) :\n    ⨆ i, p i = Subsemigroup.closure (⋃ i, (p i : Set M)) := by\n  simp_rw [Subsemigroup.closure_iUnion, Subsemigroup.closure_eq]\n\n"}
{"name":"Subsemigroup.iSup_eq_closure","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\nι : Sort u_3\np : ι → Subsemigroup M\n⊢ Eq (iSup fun i => p i) (Subsemigroup.closure (Set.iUnion fun i => ↑(p i)))","decl":"@[to_additive]\ntheorem iSup_eq_closure {ι : Sort*} (p : ι → Subsemigroup M) :\n    ⨆ i, p i = Subsemigroup.closure (⋃ i, (p i : Set M)) := by\n  simp_rw [Subsemigroup.closure_iUnion, Subsemigroup.closure_eq]\n\n"}
{"name":"MulHom.eqOn_closure","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf g : MulHom M N\ns : Set M\nh : Set.EqOn (⇑f) (⇑g) s\n⊢ Set.EqOn ⇑f ⇑g ↑(Subsemigroup.closure s)","decl":"/-- If two mul homomorphisms are equal on a set, then they are equal on its subsemigroup closure. -/\n@[to_additive \"If two add homomorphisms are equal on a set,\n  then they are equal on its additive subsemigroup closure.\"]\ntheorem eqOn_closure {f g : M →ₙ* N} {s : Set M} (h : Set.EqOn f g s) :\n    Set.EqOn f g (closure s) :=\n  show closure s ≤ f.eqLocus g from closure_le.2 h\n\n"}
{"name":"AddHom.eqOn_closure","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf g : AddHom M N\ns : Set M\nh : Set.EqOn (⇑f) (⇑g) s\n⊢ Set.EqOn ⇑f ⇑g ↑(AddSubsemigroup.closure s)","decl":"/-- If two mul homomorphisms are equal on a set, then they are equal on its subsemigroup closure. -/\n@[to_additive \"If two add homomorphisms are equal on a set,\n  then they are equal on its additive subsemigroup closure.\"]\ntheorem eqOn_closure {f g : M →ₙ* N} {s : Set M} (h : Set.EqOn f g s) :\n    Set.EqOn f g (closure s) :=\n  show closure s ≤ f.eqLocus g from closure_le.2 h\n\n"}
{"name":"AddHom.eq_of_eqOn_dense","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\ns : Set M\nhs : Eq (AddSubsemigroup.closure s) Top.top\nf g : AddHom M N\nh : Set.EqOn (⇑f) (⇑g) s\n⊢ Eq f g","decl":"@[to_additive]\ntheorem eq_of_eqOn_dense {s : Set M} (hs : closure s = ⊤) {f g : M →ₙ* N} (h : s.EqOn f g) :\n    f = g :=\n  eq_of_eqOn_top <| hs ▸ eqOn_closure h\n\n"}
{"name":"MulHom.eq_of_eqOn_dense","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\ns : Set M\nhs : Eq (Subsemigroup.closure s) Top.top\nf g : MulHom M N\nh : Set.EqOn (⇑f) (⇑g) s\n⊢ Eq f g","decl":"@[to_additive]\ntheorem eq_of_eqOn_dense {s : Set M} (hs : closure s = ⊤) {f g : M →ₙ* N} (h : s.EqOn f g) :\n    f = g :=\n  eq_of_eqOn_top <| hs ▸ eqOn_closure h\n\n"}
{"name":"MulHom.coe_ofDense","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Semigroup M\ninst✝ : Semigroup N\ns : Set M\nf : M → N\nhs : Eq (Subsemigroup.closure s) Top.top\nhmul : ∀ (x y : M), Membership.mem s y → Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\n⊢ Eq (⇑(MulHom.ofDense f hs hmul)) f","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_ofDense [Semigroup M] [Semigroup N] {s : Set M} (f : M → N) (hs : closure s = ⊤)\n    (hmul) : (ofDense f hs hmul : M → N) = f :=\n  rfl\n\n"}
{"name":"AddHom.coe_ofDense","module":"Mathlib.Algebra.Group.Subsemigroup.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddSemigroup M\ninst✝ : AddSemigroup N\ns : Set M\nf : M → N\nhs : Eq (AddSubsemigroup.closure s) Top.top\nhmul : ∀ (x y : M), Membership.mem s y → Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\n⊢ Eq (⇑(AddHom.ofDense f hs hmul)) f","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_ofDense [Semigroup M] [Semigroup N] {s : Set M} (f : M → N) (hs : closure s = ⊤)\n    (hmul) : (ofDense f hs hmul : M → N) = f :=\n  rfl\n\n"}
