{"name":"mul_right_bijective_of_finite₀","module":"Mathlib.RingTheory.IntegralDomain","initialProofState":"M : Type u_1\ninst✝¹ : CancelMonoidWithZero M\ninst✝ : Finite M\na : M\nha : Ne a 0\n⊢ Function.Bijective fun b => HMul.hMul a b","decl":"theorem mul_right_bijective_of_finite₀ {a : M} (ha : a ≠ 0) : Bijective fun b => a * b :=\n  Finite.injective_iff_bijective.1 <| mul_right_injective₀ ha\n\n"}
{"name":"mul_left_bijective_of_finite₀","module":"Mathlib.RingTheory.IntegralDomain","initialProofState":"M : Type u_1\ninst✝¹ : CancelMonoidWithZero M\ninst✝ : Finite M\na : M\nha : Ne a 0\n⊢ Function.Bijective fun b => HMul.hMul b a","decl":"theorem mul_left_bijective_of_finite₀ {a : M} (ha : a ≠ 0) : Bijective fun b => b * a :=\n  Finite.injective_iff_bijective.1 <| mul_left_injective₀ ha\n\n"}
{"name":"exists_eq_pow_of_mul_eq_pow_of_coprime","module":"Mathlib.RingTheory.IntegralDomain","initialProofState":"R : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : IsDomain R\ninst✝¹ : GCDMonoid R\ninst✝ : Subsingleton (Units R)\na b c : R\nn : Nat\ncp : IsCoprime a b\nh : Eq (HMul.hMul a b) (HPow.hPow c n)\n⊢ Exists fun d => Eq a (HPow.hPow d n)","decl":"theorem exists_eq_pow_of_mul_eq_pow_of_coprime {R : Type*} [CommSemiring R] [IsDomain R]\n    [GCDMonoid R] [Subsingleton Rˣ] {a b c : R} {n : ℕ} (cp : IsCoprime a b) (h : a * b = c ^ n) :\n    ∃ d : R, a = d ^ n := by\n  refine exists_eq_pow_of_mul_eq_pow (isUnit_of_dvd_one ?_) h\n  obtain ⟨x, y, hxy⟩ := cp\n  rw [← hxy]\n  exact  -- Porting note: added `GCDMonoid.` twice\n    dvd_add (dvd_mul_of_dvd_right (GCDMonoid.gcd_dvd_left _ _) _)\n      (dvd_mul_of_dvd_right (GCDMonoid.gcd_dvd_right _ _) _)\n\n"}
{"name":"Finset.exists_eq_pow_of_mul_eq_pow_of_coprime","module":"Mathlib.RingTheory.IntegralDomain","initialProofState":"ι : Type u_2\nR : Type u_3\ninst✝³ : CommSemiring R\ninst✝² : IsDomain R\ninst✝¹ : GCDMonoid R\ninst✝ : Subsingleton (Units R)\nn : Nat\nc : R\ns : Finset ι\nf : ι → R\nh : ∀ (i : ι), Membership.mem s i → ∀ (j : ι), Membership.mem s j → Ne i j → IsCoprime (f i) (f j)\nhprod : Eq (s.prod fun i => f i) (HPow.hPow c n)\ni : ι\na✝ : Membership.mem s i\n⊢ Exists fun d => Eq (f i) (HPow.hPow d n)","decl":"nonrec\ntheorem Finset.exists_eq_pow_of_mul_eq_pow_of_coprime {ι R : Type*} [CommSemiring R] [IsDomain R]\n    [GCDMonoid R] [Subsingleton Rˣ] {n : ℕ} {c : R} {s : Finset ι} {f : ι → R}\n    (h : ∀ i ∈ s, ∀ j ∈ s, i ≠ j → IsCoprime (f i) (f j))\n    (hprod : ∏ i ∈ s, f i = c ^ n) : ∀ i ∈ s, ∃ d : R, f i = d ^ n := by\n  classical\n    intro i hi\n    rw [← insert_erase hi, prod_insert (not_mem_erase i s)] at hprod\n    refine\n      exists_eq_pow_of_mul_eq_pow_of_coprime\n        (IsCoprime.prod_right fun j hj => h i hi j (erase_subset i s hj) fun hij => ?_) hprod\n    rw [hij] at hj\n    exact (s.not_mem_erase _) hj\n\n"}
{"name":"Finite.isField_of_domain","module":"Mathlib.RingTheory.IntegralDomain","initialProofState":"R : Type u_3\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : Finite R\n⊢ IsField R","decl":"theorem Finite.isField_of_domain (R) [CommRing R] [IsDomain R] [Finite R] : IsField R := by\n  cases nonempty_fintype R\n  exact @Field.toIsField R (@Fintype.fieldOfDomain R _ _ (Classical.decEq R) _)\n\n"}
{"name":"card_nthRoots_subgroup_units","module":"Mathlib.RingTheory.IntegralDomain","initialProofState":"R : Type u_1\nG : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDomain R\ninst✝² : Group G\ninst✝¹ : Fintype G\ninst✝ : DecidableEq G\nf : MonoidHom G R\nhf : Function.Injective ⇑f\nn : Nat\nhn : LT.lt 0 n\ng₀ : G\n⊢ LE.le (Finset.filter (fun g => Eq (HPow.hPow g n) g₀) Finset.univ).card (Polynomial.nthRoots n (f g₀)).card","decl":"theorem card_nthRoots_subgroup_units [Fintype G] [DecidableEq G] (f : G →* R) (hf : Injective f)\n    {n : ℕ} (hn : 0 < n) (g₀ : G) :\n    #{g | g ^ n = g₀} ≤ Multiset.card (nthRoots n (f g₀)) := by\n  haveI : DecidableEq R := Classical.decEq _\n  calc\n    _ ≤ #(nthRoots n (f g₀)).toFinset := card_le_card_of_injOn f (by aesop) hf.injOn\n    _ ≤ _ := (nthRoots n (f g₀)).toFinset_card_le\n\n"}
{"name":"isCyclic_of_subgroup_isDomain","module":"Mathlib.RingTheory.IntegralDomain","initialProofState":"R : Type u_1\nG : Type u_2\ninst✝³ : CommRing R\ninst✝² : IsDomain R\ninst✝¹ : Group G\ninst✝ : Finite G\nf : MonoidHom G R\nhf : Function.Injective ⇑f\n⊢ IsCyclic G","decl":"/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem isCyclic_of_subgroup_isDomain [Finite G] (f : G →* R) (hf : Injective f) : IsCyclic G := by\n  classical\n    cases nonempty_fintype G\n    apply isCyclic_of_card_pow_eq_one_le\n    intro n hn\n    exact le_trans (card_nthRoots_subgroup_units f hf hn 1) (card_nthRoots n (f 1))\n\n"}
{"name":"instIsCyclicUnitsOfFinite","module":"Mathlib.RingTheory.IntegralDomain","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : Finite (Units R)\n⊢ IsCyclic (Units R)","decl":"/-- The unit group of a finite integral domain is cyclic.\n\nTo support `ℤˣ` and other infinite monoids with finite groups of units, this requires only\n`Finite Rˣ` rather than deducing it from `Finite R`. -/\ninstance [Finite Rˣ] : IsCyclic Rˣ :=\n  isCyclic_of_subgroup_isDomain (Units.coeHom R) <| Units.ext\n\n"}
{"name":"subgroup_units_cyclic","module":"Mathlib.RingTheory.IntegralDomain","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nS : Subgroup (Units R)\n⊢ IsCyclic (Subtype fun x => Membership.mem S x)","decl":"/-- A finite subgroup of the units of an integral domain is cyclic. -/\ninstance subgroup_units_cyclic : IsCyclic S := by\n  -- Porting note: the original proof used a `coe`, but I was not able to get it to work.\n  apply isCyclic_of_subgroup_isDomain (R := R) (G := S) _ _\n  · exact MonoidHom.mk (OneHom.mk (fun s => ↑s.val) rfl) (by simp)\n  · exact Units.ext.comp Subtype.val_injective\n\n"}
{"name":"Polynomial.div_eq_quo_add_rem_div","module":"Mathlib.RingTheory.IntegralDomain","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDomain R\nK : Type\ninst✝² : Field K\ninst✝¹ : Algebra (Polynomial R) K\ninst✝ : IsFractionRing (Polynomial R) K\nf g : Polynomial R\nhg : g.Monic\n⊢ Exists fun q => Exists fun r => And (LT.lt r.degree g.degree) (Eq (HDiv.hDiv ((algebraMap (Polynomial R) K) f) ((algebraMap (Polynomial R) K) g)) (HAdd.hAdd ((algebraMap (Polynomial R) K) q) (HDiv.hDiv ((algebraMap (Polynomial R) K) r) ((algebraMap (Polynomial R) K) g))))","decl":"theorem div_eq_quo_add_rem_div (f : R[X]) {g : R[X]} (hg : g.Monic) :\n    ∃ q r : R[X], r.degree < g.degree ∧\n      (algebraMap R[X] K f) / (algebraMap R[X] K g) =\n        algebraMap R[X] K q + (algebraMap R[X] K r) / (algebraMap R[X] K g) := by\n  refine ⟨f /ₘ g, f %ₘ g, ?_, ?_⟩\n  · exact degree_modByMonic_lt _ hg\n  · have hg' : algebraMap R[X] K g ≠ 0 :=\n      -- Porting note: the proof was `by exact_mod_cast Monic.ne_zero hg`\n      (map_ne_zero_iff _ (IsFractionRing.injective R[X] K)).mpr (Monic.ne_zero hg)\n    field_simp [hg']\n    -- Porting note: `norm_cast` was here, but does nothing.\n    rw [add_comm, mul_comm, ← map_mul, ← map_add, modByMonic_add_div f hg]\n\n"}
{"name":"sum_hom_units_eq_zero","module":"Mathlib.RingTheory.IntegralDomain","initialProofState":"R : Type u_1\nG : Type u_2\ninst✝³ : CommRing R\ninst✝² : IsDomain R\ninst✝¹ : Group G\ninst✝ : Fintype G\nf : MonoidHom G R\nhf : Ne f 1\n⊢ Eq (Finset.univ.sum fun g => f g) 0","decl":"/-- In an integral domain, a sum indexed by a nontrivial homomorphism from a finite group is zero.\n-/\ntheorem sum_hom_units_eq_zero (f : G →* R) (hf : f ≠ 1) : ∑ g : G, f g = 0 := by\n  classical\n    obtain ⟨x, hx⟩ : ∃ x : MonoidHom.range f.toHomUnits,\n        ∀ y : MonoidHom.range f.toHomUnits, y ∈ Submonoid.powers x :=\n      IsCyclic.exists_monoid_generator\n    have hx1 : x ≠ 1 := by\n      rintro rfl\n      apply hf\n      ext g\n      rw [MonoidHom.one_apply]\n      cases' hx ⟨f.toHomUnits g, g, rfl⟩ with n hn\n      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,\n        eq_comm] at hn\n    replace hx1 : (x.val : R) - 1 ≠ 0 := -- Porting note: was `(x : R)`\n      fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))\n    let c := #{g | f.toHomUnits g = 1}\n    calc\n      ∑ g : G, f g = ∑ g : G, (f.toHomUnits g : R) := rfl\n      _ = ∑ u ∈ univ.image f.toHomUnits, #{g | f.toHomUnits g = u} • (u : R) :=\n        sum_comp ((↑) : Rˣ → R) f.toHomUnits\n      _ = ∑ u ∈ univ.image f.toHomUnits, c • (u : R) :=\n        (sum_congr rfl fun u hu => congr_arg₂ _ ?_ rfl)\n      -- remaining goal 1, proven below\n      -- Porting note: have to change `(b : R)` into `((b : Rˣ) : R)`\n      _ = ∑ b : MonoidHom.range f.toHomUnits, c • ((b : Rˣ) : R) :=\n        (Finset.sum_subtype _ (by simp) _)\n      _ = c • ∑ b : MonoidHom.range f.toHomUnits, ((b : Rˣ) : R) := smul_sum.symm\n      _ = c • (0 : R) := congr_arg₂ _ rfl ?_\n      -- remaining goal 2, proven below\n      _ = (0 : R) := smul_zero _\n    · -- remaining goal 1\n      show #{g : G | f.toHomUnits g = u} = c\n      apply MonoidHom.card_fiber_eq_of_mem_range f.toHomUnits\n      · simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu\n      · exact ⟨1, f.toHomUnits.map_one⟩\n    -- remaining goal 2\n    show (∑ b : MonoidHom.range f.toHomUnits, ((b : Rˣ) : R)) = 0\n    calc\n      (∑ b : MonoidHom.range f.toHomUnits, ((b : Rˣ) : R))\n        = ∑ n ∈ range (orderOf x), ((x : Rˣ) : R) ^ n :=\n        Eq.symm <|\n          sum_nbij (x ^ ·) (by simp only [mem_univ, forall_true_iff])\n            (by simpa using pow_injOn_Iio_orderOf)\n            (fun b _ => let ⟨n, hn⟩ := hx b\n              ⟨n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),\n               -- Porting note: have to use `dsimp` to apply the function\n               by dsimp at hn ⊢; rw [pow_mod_orderOf, hn]⟩)\n            (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,\n                Units.val_pow_eq_pow_val])\n      _ = 0 := ?_\n\n    rw [← mul_left_inj' hx1, zero_mul, geom_sum_mul]\n    norm_cast\n    simp [pow_orderOf_eq_one]\n\n"}
{"name":"sum_hom_units","module":"Mathlib.RingTheory.IntegralDomain","initialProofState":"R : Type u_1\nG : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDomain R\ninst✝² : Group G\ninst✝¹ : Fintype G\nf : MonoidHom G R\ninst✝ : Decidable (Eq f 1)\n⊢ Eq (Finset.univ.sum fun g => f g) ↑(ite (Eq f 1) (Fintype.card G) 0)","decl":"/-- In an integral domain, a sum indexed by a homomorphism from a finite group is zero,\nunless the homomorphism is trivial, in which case the sum is equal to the cardinality of the group.\n-/\ntheorem sum_hom_units (f : G →* R) [Decidable (f = 1)] :\n    ∑ g : G, f g = if f = 1 then Fintype.card G else 0 := by\n  split_ifs with h\n  · simp [h, card_univ]\n  · rw [cast_zero] -- Porting note: added\n    exact sum_hom_units_eq_zero f h\n\n"}
