{"name":"KaehlerDifferential.tensorKaehlerEquivOfFormallyEtale_apply","module":"Mathlib.RingTheory.Etale.Kaehler","initialProofState":"R S T : Type u\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : CommRing T\ninst✝⁴ : Algebra R S\ninst✝³ : Algebra R T\ninst✝² : Algebra S T\ninst✝¹ : IsScalarTower R S T\ninst✝ : Algebra.FormallyEtale S T\na✝ : TensorProduct S T (KaehlerDifferential R S)\n⊢ Eq ((KaehlerDifferential.tensorKaehlerEquivOfFormallyEtale R S T) a✝) ((KaehlerDifferential.mapBaseChange R S T) a✝)","decl":"/--\nThe canonical isomorphism `T ⊗[S] Ω[S⁄R] ≃ₗ[T] Ω[T⁄R]` for `T` a formally etale `S`-algebra.\nAlso see `S ⊗[R] Ω[A⁄R] ≃ₗ[S] Ω[S ⊗[R] A⁄S]` at `KaehlerDifferential.tensorKaehlerEquiv`.\n-/\n@[simps! apply] noncomputable\ndef KaehlerDifferential.tensorKaehlerEquivOfFormallyEtale [Algebra.FormallyEtale S T] :\n    T ⊗[S] Ω[S⁄R] ≃ₗ[T] Ω[T⁄R] := by\n  refine LinearEquiv.ofBijective (mapBaseChange R S T)\n    ⟨?_, fun x ↦ (KaehlerDifferential.exact_mapBaseChange_map R S T x).mp (Subsingleton.elim _ _)⟩\n  rw [injective_iff_map_eq_zero]\n  intros x hx\n  obtain ⟨x, rfl⟩ := (Algebra.H1Cotangent.exact_δ_mapBaseChange R S T x).mp hx\n  rw [Subsingleton.elim x 0, map_zero]\n\n"}
{"name":"KaehlerDifferential.tensorKaehlerEquivOfFormallyEtale_symm_D_algebraMap","module":"Mathlib.RingTheory.Etale.Kaehler","initialProofState":"R S T : Type u\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : CommRing T\ninst✝⁴ : Algebra R S\ninst✝³ : Algebra R T\ninst✝² : Algebra S T\ninst✝¹ : IsScalarTower R S T\ninst✝ : Algebra.FormallyEtale S T\ns : S\n⊢ Eq ((KaehlerDifferential.tensorKaehlerEquivOfFormallyEtale R S T).symm ((KaehlerDifferential.D R T) ((algebraMap S T) s))) (TensorProduct.tmul S 1 ((KaehlerDifferential.D R S) s))","decl":"lemma KaehlerDifferential.tensorKaehlerEquivOfFormallyEtale_symm_D_algebraMap\n    [Algebra.FormallyEtale S T] (s : S) :\n    (tensorKaehlerEquivOfFormallyEtale R S T).symm (D R T (algebraMap S T s)) = 1 ⊗ₜ D R S s := by\n  rw [LinearEquiv.symm_apply_eq, tensorKaehlerEquivOfFormallyEtale_apply, mapBaseChange_tmul,\n    one_smul, map_D]\n\n"}
{"name":"KaehlerDifferential.isBaseChange_of_formallyEtale","module":"Mathlib.RingTheory.Etale.Kaehler","initialProofState":"R S T : Type u\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : CommRing T\ninst✝⁴ : Algebra R S\ninst✝³ : Algebra R T\ninst✝² : Algebra S T\ninst✝¹ : IsScalarTower R S T\ninst✝ : Algebra.FormallyEtale S T\n⊢ IsBaseChange T (KaehlerDifferential.map R R S T)","decl":"lemma KaehlerDifferential.isBaseChange_of_formallyEtale [Algebra.FormallyEtale S T] :\n    IsBaseChange T (map R R S T) := by\n  show Function.Bijective _\n  convert (tensorKaehlerEquivOfFormallyEtale R S T).bijective using 1\n  show _ = ((tensorKaehlerEquivOfFormallyEtale\n    R S T).toLinearMap.restrictScalars S : T ⊗[S] Ω[S⁄R] → _)\n  congr!\n  ext\n  simp\n\n"}
{"name":"KaehlerDifferential.isLocalizedModule_map","module":"Mathlib.RingTheory.Etale.Kaehler","initialProofState":"R S T : Type u\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : CommRing T\ninst✝⁴ : Algebra R S\ninst✝³ : Algebra R T\ninst✝² : Algebra S T\ninst✝¹ : IsScalarTower R S T\nM : Submonoid S\ninst✝ : IsLocalization M T\n⊢ IsLocalizedModule M (KaehlerDifferential.map R R S T)","decl":"instance KaehlerDifferential.isLocalizedModule_map (M : Submonoid S) [IsLocalization M T] :\n    IsLocalizedModule M (map R R S T) :=\n  have := Algebra.FormallyEtale.of_isLocalization (Rₘ := T) M\n  (isLocalizedModule_iff_isBaseChange M T _).mpr (isBaseChange_of_formallyEtale R S T)\n\n"}
{"name":"Algebra.Extension.tensorCotangentInvFun_smul_mk","module":"Mathlib.RingTheory.Etale.Kaehler","initialProofState":"R S T : Type u\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : CommRing T\ninst✝² : Algebra R S\ninst✝¹ : Algebra R T\ninst✝ : Algebra S T\nP : Algebra.Extension R S\nQ : Algebra.Extension R T\nf : P.Hom Q\nalg : Algebra P.Ring Q.Ring\nhalg : Eq (algebraMap P.Ring Q.Ring) f.toRingHom\nH : Function.Bijective ⇑(LinearMap.liftBaseChange Q.Ring (f.mapKer halg))\nx : Q.Ring\ny : Subtype fun x => Membership.mem P.ker x\n⊢ Eq ((Algebra.Extension.tensorCotangentInvFun f halg H) (HSMul.hSMul x (Algebra.Extension.Cotangent.mk ⟨f.toRingHom ↑y, ⋯⟩))) (HSMul.hSMul x (TensorProduct.tmul S 1 (Algebra.Extension.Cotangent.mk y)))","decl":"omit [IsScalarTower R S T] in\nlemma tensorCotangentInvFun_smul_mk\n    [alg : Algebra P.Ring Q.Ring] (halg : algebraMap P.Ring Q.Ring = f.toRingHom)\n    (H : Function.Bijective ((f.mapKer halg).liftBaseChange Q.Ring)) (x : Q.Ring) (y : P.ker) :\n    tensorCotangentInvFun f halg H (x • .mk ⟨f.toRingHom y, (f.mapKer halg y).2⟩) =\n      x • 1 ⊗ₜ .mk y := by\n  letI := ((algebraMap S T).comp (algebraMap P.Ring S)).toAlgebra\n  haveI : IsScalarTower P.Ring S T := .of_algebraMap_eq' rfl\n  haveI : IsScalarTower P.Ring Q.Ring T :=\n    .of_algebraMap_eq fun r ↦ halg ▸ (f.algebraMap_toRingHom r).symm\n  letI e := LinearEquiv.ofBijective _ H\n  trans tensorCotangentInvFun f halg H (.mk ((f.mapKer halg).liftBaseChange Q.Ring (x ⊗ₜ y)))\n  · simp; rfl\n  show ((TensorProduct.mk _ _ _ 1).restrictScalars _ ∘ₗ Cotangent.mk).liftBaseChange _\n    (e.symm (e (x ⊗ₜ y))) = _\n  rw [e.symm_apply_apply]\n  simp\n\n"}
{"name":"Algebra.tensorH1CotangentOfIsLocalization_toLinearMap","module":"Mathlib.RingTheory.Etale.Kaehler","initialProofState":"R S T : Type u\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : CommRing T\ninst✝⁴ : Algebra R S\ninst✝³ : Algebra R T\ninst✝² : Algebra S T\ninst✝¹ : IsScalarTower R S T\nM : Submonoid S\ninst✝ : IsLocalization M T\n⊢ Eq (↑(Algebra.tensorH1CotangentOfIsLocalization R T M)) (LinearMap.liftBaseChange T (Algebra.H1Cotangent.map R R S T))","decl":"lemma tensorH1CotangentOfIsLocalization_toLinearMap\n    (M : Submonoid S) [IsLocalization M T] :\n    (tensorH1CotangentOfIsLocalization R T M).toLinearMap =\n      (Algebra.H1Cotangent.map R R S T).liftBaseChange T := by\n  ext x : 3\n  simp only [AlgebraTensorModule.curry_apply, curry_apply, LinearMap.coe_restrictScalars,\n    LinearEquiv.coe_coe, LinearMap.liftBaseChange_tmul, one_smul]\n  simp only [tensorH1CotangentOfIsLocalization, Generators.toExtension_Ring,\n    Generators.toExtension_commRing, Generators.self_vars, Generators.toExtension_algebra₂,\n    Generators.self_algebra, AlgHom.toRingHom_eq_coe, Extension.tensorH1Cotangent,\n    LinearEquiv.ofBijective_apply, LinearMap.liftBaseChange_tmul, one_smul,\n    Extension.equivH1CotangentOfFormallySmooth,  LinearEquiv.trans_apply]\n  letI P : Extension R S := (Generators.self R S).toExtension\n  letI M' := M.comap (algebraMap P.Ring S)\n  letI fQ : Localization M' →ₐ[R] T := IsLocalization.liftAlgHom (M := M')\n    (f := (IsScalarTower.toAlgHom R S T).comp (IsScalarTower.toAlgHom R P.Ring S)) (fun ⟨y, hy⟩ ↦\n    by simpa using IsLocalization.map_units T ⟨algebraMap P.Ring S y, hy⟩)\n  letI Q : Extension R T := .ofSurjective fQ (by\n    intro x\n    obtain ⟨x, ⟨s, hs⟩, rfl⟩ := IsLocalization.mk'_surjective M x\n    obtain ⟨x, rfl⟩ := P.algebraMap_surjective x\n    obtain ⟨s, rfl⟩ := P.algebraMap_surjective s\n    refine ⟨IsLocalization.mk' _ x ⟨s, show s ∈ M' from hs⟩, ?_⟩\n    simp only [fQ, IsLocalization.coe_liftAlgHom, AlgHom.toRingHom_eq_coe]\n    rw [IsLocalization.lift_mk'_spec]\n    simp)\n  letI f : (Generators.self R T).toExtension.Hom Q :=\n  { toRingHom := (MvPolynomial.aeval Q.σ).toRingHom\n    toRingHom_algebraMap := (MvPolynomial.aeval Q.σ).commutes\n    algebraMap_toRingHom := by\n      have : (IsScalarTower.toAlgHom R Q.Ring T).comp (MvPolynomial.aeval Q.σ) =\n          IsScalarTower.toAlgHom _ (Generators.self R T).toExtension.Ring _ := by\n        ext i\n        show _ = algebraMap (Generators.self R T).Ring _ (.X i)\n        simp\n      exact DFunLike.congr_fun this }\n  rw [← Extension.H1Cotangent.equivOfFormallySmooth_symm, LinearEquiv.symm_apply_eq,\n    @Extension.H1Cotangent.equivOfFormallySmooth_apply (f := f),\n    Algebra.H1Cotangent.map, ← (Extension.H1Cotangent.map f).coe_restrictScalars S,\n    ← LinearMap.comp_apply, ← Extension.H1Cotangent.map_comp, Extension.H1Cotangent.map_eq]\n\n"}
{"name":"Algebra.H1Cotangent.isLocalizedModule","module":"Mathlib.RingTheory.Etale.Kaehler","initialProofState":"R S T : Type u\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : CommRing T\ninst✝⁴ : Algebra R S\ninst✝³ : Algebra R T\ninst✝² : Algebra S T\ninst✝¹ : IsScalarTower R S T\nM : Submonoid S\ninst✝ : IsLocalization M T\n⊢ IsLocalizedModule M (Algebra.H1Cotangent.map R R S T)","decl":"instance H1Cotangent.isLocalizedModule (M : Submonoid S) [IsLocalization M T] :\n    IsLocalizedModule M (Algebra.H1Cotangent.map R R S T) := by\n  rw [isLocalizedModule_iff_isBaseChange M T]\n  show Function.Bijective ((Algebra.H1Cotangent.map R R S T).liftBaseChange T)\n  rw [← tensorH1CotangentOfIsLocalization_toLinearMap R T M]\n  exact (tensorH1CotangentOfIsLocalization R T M).bijective\n\n"}
