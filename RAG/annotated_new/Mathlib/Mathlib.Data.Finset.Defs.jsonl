{"name":"Finset.mk.sizeOf_spec","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_4\ninst✝ : SizeOf α\nval : Multiset α\nnodup : val.Nodup\n⊢ Eq (SizeOf.sizeOf { val := val, nodup := nodup }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf val)) (SizeOf.sizeOf nodup))","decl":"/-- `Finset α` is the type of finite sets of elements of `α`. It is implemented\n  as a multiset (a list up to permutation) which has no duplicate elements. -/\nstructure Finset (α : Type*) where\n  /-- The underlying multiset -/\n  val : Multiset α\n  /-- `val` contains no duplicates -/\n  nodup : Nodup val\n\n"}
{"name":"Finset.nodup","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_4\nself : Finset α\n⊢ self.val.Nodup","decl":"/-- `Finset α` is the type of finite sets of elements of `α`. It is implemented\n  as a multiset (a list up to permutation) which has no duplicate elements. -/\nstructure Finset (α : Type*) where\n  /-- The underlying multiset -/\n  val : Multiset α\n  /-- `val` contains no duplicates -/\n  nodup : Nodup val\n\n"}
{"name":"Finset.mk.injEq","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_4\nval✝ : Multiset α\nnodup✝ : val✝.Nodup\nval : Multiset α\nnodup : val.Nodup\n⊢ Eq (Eq { val := val✝, nodup := nodup✝ } { val := val, nodup := nodup }) (Eq val✝ val)","decl":"/-- `Finset α` is the type of finite sets of elements of `α`. It is implemented\n  as a multiset (a list up to permutation) which has no duplicate elements. -/\nstructure Finset (α : Type*) where\n  /-- The underlying multiset -/\n  val : Multiset α\n  /-- `val` contains no duplicates -/\n  nodup : Nodup val\n\n"}
{"name":"Finset.mk.inj","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_4\nval✝ : Multiset α\nnodup✝ : val✝.Nodup\nval : Multiset α\nnodup : val.Nodup\nx✝ : Eq { val := val✝, nodup := nodup✝ } { val := val, nodup := nodup }\n⊢ Eq val✝ val","decl":"/-- `Finset α` is the type of finite sets of elements of `α`. It is implemented\n  as a multiset (a list up to permutation) which has no duplicate elements. -/\nstructure Finset (α : Type*) where\n  /-- The underlying multiset -/\n  val : Multiset α\n  /-- `val` contains no duplicates -/\n  nodup : Nodup val\n\n"}
{"name":"Multiset.canLiftFinset","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_4\n⊢ CanLift (Multiset α) (Finset α) Finset.val Multiset.Nodup","decl":"instance Multiset.canLiftFinset {α} : CanLift (Multiset α) (Finset α) Finset.val Multiset.Nodup :=\n  ⟨fun m hm => ⟨⟨m, hm⟩, rfl⟩⟩\n\n"}
{"name":"Finset.eq_of_veq","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns t : Finset α\na✝ : Eq s.val t.val\n⊢ Eq s t","decl":"theorem eq_of_veq : ∀ {s t : Finset α}, s.1 = t.1 → s = t\n  | ⟨s, _⟩, ⟨t, _⟩, h => by cases h; rfl\n\n"}
{"name":"Finset.val_injective","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\n⊢ Function.Injective Finset.val","decl":"theorem val_injective : Injective (val : Finset α → Multiset α) := fun _ _ => eq_of_veq\n\n"}
{"name":"Finset.val_inj","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns t : Finset α\n⊢ Iff (Eq s.val t.val) (Eq s t)","decl":"@[simp]\ntheorem val_inj {s t : Finset α} : s.1 = t.1 ↔ s = t :=\n  val_injective.eq_iff\n\n"}
{"name":"Finset.mem_def","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\na : α\ns : Finset α\n⊢ Iff (Membership.mem s a) (Membership.mem s.val a)","decl":"theorem mem_def {a : α} {s : Finset α} : a ∈ s ↔ a ∈ s.1 :=\n  Iff.rfl\n\n"}
{"name":"Finset.mem_val","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\na : α\ns : Finset α\n⊢ Iff (Membership.mem s.val a) (Membership.mem s a)","decl":"@[simp]\ntheorem mem_val {a : α} {s : Finset α} : a ∈ s.1 ↔ a ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Finset.mem_mk","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\na : α\ns : Multiset α\nnd : s.Nodup\n⊢ Iff (Membership.mem { val := s, nodup := nd } a) (Membership.mem s a)","decl":"@[simp]\ntheorem mem_mk {a : α} {s nd} : a ∈ @Finset.mk α s nd ↔ a ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Finset.forall_mem_not_eq","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns : Finset α\na : α\n⊢ Iff (∀ (b : α), Membership.mem s b → Not (Eq a b)) (Not (Membership.mem s a))","decl":"@[simp] lemma forall_mem_not_eq {s : Finset α} {a : α} : (∀ b ∈ s, ¬ a = b) ↔ a ∉ s := by aesop\n"}
{"name":"Finset.forall_mem_not_eq'","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns : Finset α\na : α\n⊢ Iff (∀ (b : α), Membership.mem s b → Not (Eq b a)) (Not (Membership.mem s a))","decl":"@[simp] lemma forall_mem_not_eq' {s : Finset α} {a : α} : (∀ b ∈ s, ¬ b = a) ↔ a ∉ s := by aesop\n\n"}
{"name":"Finset.mem_coe","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\na : α\ns : Finset α\n⊢ Iff (Membership.mem (↑s) a) (Membership.mem s a)","decl":"@[simp, norm_cast]\ntheorem mem_coe {a : α} {s : Finset α} : a ∈ (s : Set α) ↔ a ∈ (s : Finset α) :=\n  Iff.rfl\n\n"}
{"name":"Finset.setOf_mem","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_4\ns : Finset α\n⊢ Eq (setOf fun a => Membership.mem s a) ↑s","decl":"@[simp]\ntheorem setOf_mem {α} {s : Finset α} : { a | a ∈ s } = s :=\n  rfl\n\n"}
{"name":"Finset.coe_mem","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns : Finset α\nx : ↑↑s\n⊢ Membership.mem s ↑x","decl":"@[simp]\ntheorem coe_mem {s : Finset α} (x : (s : Set α)) : ↑x ∈ s :=\n  x.2\n\n"}
{"name":"Finset.mk_coe","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns : Finset α\nx : ↑↑s\nh : Membership.mem ↑s ↑x\n⊢ Eq ⟨↑x, h⟩ x","decl":"theorem mk_coe {s : Finset α} (x : (s : Set α)) {h} : (⟨x, h⟩ : (s : Set α)) = x :=\n  Subtype.coe_eta _ _\n\n"}
{"name":"Finset.ext","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns₁ s₂ : Finset α\nh : ∀ (a : α), Iff (Membership.mem s₁ a) (Membership.mem s₂ a)\n⊢ Eq s₁ s₂","decl":"@[ext]\ntheorem ext {s₁ s₂ : Finset α} (h : ∀ a, a ∈ s₁ ↔ a ∈ s₂) : s₁ = s₂ :=\n  (val_inj.symm.trans <| s₁.nodup.ext s₂.nodup).mpr h\n\n"}
{"name":"Finset.ext_iff","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns₁ s₂ : Finset α\n⊢ Iff (Eq s₁ s₂) (∀ (a : α), Iff (Membership.mem s₁ a) (Membership.mem s₂ a))","decl":"@[ext]\ntheorem ext {s₁ s₂ : Finset α} (h : ∀ a, a ∈ s₁ ↔ a ∈ s₂) : s₁ = s₂ :=\n  (val_inj.symm.trans <| s₁.nodup.ext s₂.nodup).mpr h\n\n"}
{"name":"Finset.coe_inj","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns₁ s₂ : Finset α\n⊢ Iff (Eq ↑s₁ ↑s₂) (Eq s₁ s₂)","decl":"@[simp, norm_cast]\ntheorem coe_inj {s₁ s₂ : Finset α} : (s₁ : Set α) = s₂ ↔ s₁ = s₂ :=\n  Set.ext_iff.trans Finset.ext_iff.symm\n\n"}
{"name":"Finset.coe_injective","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_4\n⊢ Function.Injective Finset.toSet","decl":"theorem coe_injective {α} : Injective ((↑) : Finset α → Set α) := fun _s _t => coe_inj.1\n\n"}
{"name":"Finset.forall_coe","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_4\ns : Finset α\np : (Subtype fun x => Membership.mem s x) → Prop\n⊢ Iff (∀ (x : Subtype fun x => Membership.mem s x), p x) (∀ (x : α) (h : Membership.mem s x), p ⟨x, h⟩)","decl":"protected theorem forall_coe {α : Type*} (s : Finset α) (p : s → Prop) :\n    (∀ x : s, p x) ↔ ∀ (x : α) (h : x ∈ s), p ⟨x, h⟩ :=\n  Subtype.forall\n\n"}
{"name":"Finset.exists_coe","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_4\ns : Finset α\np : (Subtype fun x => Membership.mem s x) → Prop\n⊢ Iff (Exists fun x => p x) (Exists fun x => Exists fun h => p ⟨x, h⟩)","decl":"protected theorem exists_coe {α : Type*} (s : Finset α) (p : s → Prop) :\n    (∃ x : s, p x) ↔ ∃ (x : α) (h : x ∈ s), p ⟨x, h⟩ :=\n  Subtype.exists\n\n"}
{"name":"Finset.PiFinsetCoe.canLift","module":"Mathlib.Data.Finset.Defs","initialProofState":"ι : Type u_4\nα : ι → Type u_5\n_ne : ∀ (i : ι), Nonempty (α i)\ns : Finset ι\n⊢ CanLift ((i : Subtype fun x => Membership.mem s x) → α ↑i) ((i : ι) → α i) (fun f i => f ↑i) fun x => True","decl":"instance PiFinsetCoe.canLift (ι : Type*) (α : ι → Type*) [_ne : ∀ i, Nonempty (α i)]\n    (s : Finset ι) : CanLift (∀ i : s, α i) (∀ i, α i) (fun f i => f i) fun _ => True :=\n  PiSubtype.canLift ι α (· ∈ s)\n\n"}
{"name":"Finset.PiFinsetCoe.canLift'","module":"Mathlib.Data.Finset.Defs","initialProofState":"ι : Type u_4\nα : Type u_5\n_ne : Nonempty α\ns : Finset ι\n⊢ CanLift ((Subtype fun x => Membership.mem s x) → α) (ι → α) (fun f i => f ↑i) fun x => True","decl":"instance PiFinsetCoe.canLift' (ι α : Type*) [_ne : Nonempty α] (s : Finset ι) :\n    CanLift (s → α) (ι → α) (fun f i => f i) fun _ => True :=\n  PiFinsetCoe.canLift ι (fun _ => α) s\n\n"}
{"name":"Finset.FinsetCoe.canLift","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns : Finset α\n⊢ CanLift α (Subtype fun x => Membership.mem s x) Subtype.val fun a => Membership.mem s a","decl":"instance FinsetCoe.canLift (s : Finset α) : CanLift α s (↑) fun a => a ∈ s where\n  prf a ha := ⟨⟨a, ha⟩, rfl⟩\n\n"}
{"name":"Finset.coe_sort_coe","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq (↑↑s) (Subtype fun x => Membership.mem s x)","decl":"@[simp, norm_cast]\ntheorem coe_sort_coe (s : Finset α) : ((s : Set α) : Sort _) = s :=\n  rfl\n\n"}
{"name":"Finset.subset_of_le","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns t : Finset α\na✝ : LE.le s t\n⊢ HasSubset.Subset s t","decl":"theorem subset_of_le : s ≤ t → s ⊆ t := id\n\n"}
{"name":"Finset.instIsReflSubset","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\n⊢ IsRefl (Finset α) fun x1 x2 => HasSubset.Subset x1 x2","decl":"instance : IsRefl (Finset α) (· ⊆ ·) :=\n  show IsRefl (Finset α) (· ≤ ·) by infer_instance\n\n"}
{"name":"Finset.instIsTransSubset","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\n⊢ IsTrans (Finset α) fun x1 x2 => HasSubset.Subset x1 x2","decl":"instance : IsTrans (Finset α) (· ⊆ ·) :=\n  show IsTrans (Finset α) (· ≤ ·) by infer_instance\n\n"}
{"name":"Finset.instIsAntisymmSubset","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\n⊢ IsAntisymm (Finset α) fun x1 x2 => HasSubset.Subset x1 x2","decl":"instance : IsAntisymm (Finset α) (· ⊆ ·) :=\n  show IsAntisymm (Finset α) (· ≤ ·) by infer_instance\n\n"}
{"name":"Finset.instIsIrreflSSubset","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\n⊢ IsIrrefl (Finset α) fun x1 x2 => HasSSubset.SSubset x1 x2","decl":"instance : IsIrrefl (Finset α) (· ⊂ ·) :=\n  show IsIrrefl (Finset α) (· < ·) by infer_instance\n\n"}
{"name":"Finset.instIsTransSSubset","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\n⊢ IsTrans (Finset α) fun x1 x2 => HasSSubset.SSubset x1 x2","decl":"instance : IsTrans (Finset α) (· ⊂ ·) :=\n  show IsTrans (Finset α) (· < ·) by infer_instance\n\n"}
{"name":"Finset.instIsAsymmSSubset","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\n⊢ IsAsymm (Finset α) fun x1 x2 => HasSSubset.SSubset x1 x2","decl":"instance : IsAsymm (Finset α) (· ⊂ ·) :=\n  show IsAsymm (Finset α) (· < ·) by infer_instance\n\n"}
{"name":"Finset.instIsNonstrictStrictOrderSubsetSSubset","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\n⊢ IsNonstrictStrictOrder (Finset α) (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2","decl":"instance : IsNonstrictStrictOrder (Finset α) (· ⊆ ·) (· ⊂ ·) :=\n  ⟨fun _ _ => Iff.rfl⟩\n\n"}
{"name":"Finset.subset_def","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns t : Finset α\n⊢ Iff (HasSubset.Subset s t) (HasSubset.Subset s.val t.val)","decl":"theorem subset_def : s ⊆ t ↔ s.1 ⊆ t.1 :=\n  Iff.rfl\n\n"}
{"name":"Finset.ssubset_def","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns t : Finset α\n⊢ Iff (HasSSubset.SSubset s t) (And (HasSubset.Subset s t) (Not (HasSubset.Subset t s)))","decl":"theorem ssubset_def : s ⊂ t ↔ s ⊆ t ∧ ¬t ⊆ s :=\n  Iff.rfl\n\n"}
{"name":"Finset.Subset.refl","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns : Finset α\n⊢ HasSubset.Subset s s","decl":"theorem Subset.refl (s : Finset α) : s ⊆ s :=\n  Multiset.Subset.refl _\n\n"}
{"name":"Finset.Subset.rfl","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns : Finset α\n⊢ HasSubset.Subset s s","decl":"protected theorem Subset.rfl {s : Finset α} : s ⊆ s :=\n  Subset.refl _\n\n"}
{"name":"Finset.subset_of_eq","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns t : Finset α\nh : Eq s t\n⊢ HasSubset.Subset s t","decl":"protected theorem subset_of_eq {s t : Finset α} (h : s = t) : s ⊆ t :=\n  h ▸ Subset.refl _\n\n"}
{"name":"Finset.Subset.trans","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns₁ s₂ s₃ : Finset α\na✝¹ : HasSubset.Subset s₁ s₂\na✝ : HasSubset.Subset s₂ s₃\n⊢ HasSubset.Subset s₁ s₃","decl":"theorem Subset.trans {s₁ s₂ s₃ : Finset α} : s₁ ⊆ s₂ → s₂ ⊆ s₃ → s₁ ⊆ s₃ :=\n  Multiset.Subset.trans\n\n"}
{"name":"Finset.Superset.trans","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns₁ s₂ s₃ : Finset α\na✝¹ : Superset s₁ s₂\na✝ : Superset s₂ s₃\n⊢ Superset s₁ s₃","decl":"theorem Superset.trans {s₁ s₂ s₃ : Finset α} : s₁ ⊇ s₂ → s₂ ⊇ s₃ → s₁ ⊇ s₃ := fun h' h =>\n  Subset.trans h h'\n\n"}
{"name":"Finset.mem_of_subset","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns₁ s₂ : Finset α\na : α\na✝¹ : HasSubset.Subset s₁ s₂\na✝ : Membership.mem s₁ a\n⊢ Membership.mem s₂ a","decl":"theorem mem_of_subset {s₁ s₂ : Finset α} {a : α} : s₁ ⊆ s₂ → a ∈ s₁ → a ∈ s₂ :=\n  Multiset.mem_of_subset\n\n"}
{"name":"Finset.not_mem_mono","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns t : Finset α\nh : HasSubset.Subset s t\na : α\na✝ : Not (Membership.mem t a)\n⊢ Not (Membership.mem s a)","decl":"theorem not_mem_mono {s t : Finset α} (h : s ⊆ t) {a : α} : a ∉ t → a ∉ s :=\n  mt <| @h _\n\n"}
{"name":"Finset.not_mem_subset","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns t : Finset α\nh : HasSubset.Subset s t\na : α\na✝ : Not (Membership.mem t a)\n⊢ Not (Membership.mem s a)","decl":"alias not_mem_subset := not_mem_mono\n\n"}
{"name":"Finset.Subset.antisymm","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns₁ s₂ : Finset α\nH₁ : HasSubset.Subset s₁ s₂\nH₂ : HasSubset.Subset s₂ s₁\n⊢ Eq s₁ s₂","decl":"theorem Subset.antisymm {s₁ s₂ : Finset α} (H₁ : s₁ ⊆ s₂) (H₂ : s₂ ⊆ s₁) : s₁ = s₂ :=\n  ext fun a => ⟨@H₁ a, @H₂ a⟩\n\n"}
{"name":"Finset.subset_iff","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns₁ s₂ : Finset α\n⊢ Iff (HasSubset.Subset s₁ s₂) (∀ ⦃x : α⦄, Membership.mem s₁ x → Membership.mem s₂ x)","decl":"theorem subset_iff {s₁ s₂ : Finset α} : s₁ ⊆ s₂ ↔ ∀ ⦃x⦄, x ∈ s₁ → x ∈ s₂ :=\n  Iff.rfl\n\n"}
{"name":"Finset.coe_subset","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns₁ s₂ : Finset α\n⊢ Iff (HasSubset.Subset ↑s₁ ↑s₂) (HasSubset.Subset s₁ s₂)","decl":"@[simp, norm_cast]\ntheorem coe_subset {s₁ s₂ : Finset α} : (s₁ : Set α) ⊆ s₂ ↔ s₁ ⊆ s₂ :=\n  Iff.rfl\n\n"}
{"name":"Finset.GCongr.coe_subset_coe","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns₁ s₂ : Finset α\na✝ : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset ↑s₁ ↑s₂","decl":"@[gcongr] protected alias ⟨_, GCongr.coe_subset_coe⟩ := coe_subset\n\n"}
{"name":"Finset.val_le_iff","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns₁ s₂ : Finset α\n⊢ Iff (LE.le s₁.val s₂.val) (HasSubset.Subset s₁ s₂)","decl":"@[simp]\ntheorem val_le_iff {s₁ s₂ : Finset α} : s₁.1 ≤ s₂.1 ↔ s₁ ⊆ s₂ :=\n  le_iff_subset s₁.2\n\n"}
{"name":"Finset.Subset.antisymm_iff","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns₁ s₂ : Finset α\n⊢ Iff (Eq s₁ s₂) (And (HasSubset.Subset s₁ s₂) (HasSubset.Subset s₂ s₁))","decl":"theorem Subset.antisymm_iff {s₁ s₂ : Finset α} : s₁ = s₂ ↔ s₁ ⊆ s₂ ∧ s₂ ⊆ s₁ :=\n  le_antisymm_iff\n\n"}
{"name":"Finset.not_subset","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns t : Finset α\n⊢ Iff (Not (HasSubset.Subset s t)) (Exists fun x => And (Membership.mem s x) (Not (Membership.mem t x)))","decl":"theorem not_subset : ¬s ⊆ t ↔ ∃ x ∈ s, x ∉ t := by simp only [← coe_subset, Set.not_subset, mem_coe]\n\n"}
{"name":"Finset.le_eq_subset","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\n⊢ Eq (fun x1 x2 => LE.le x1 x2) fun x1 x2 => HasSubset.Subset x1 x2","decl":"@[simp]\ntheorem le_eq_subset : ((· ≤ ·) : Finset α → Finset α → Prop) = (· ⊆ ·) :=\n  rfl\n\n"}
{"name":"Finset.lt_eq_subset","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\n⊢ Eq (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2","decl":"@[simp]\ntheorem lt_eq_subset : ((· < ·) : Finset α → Finset α → Prop) = (· ⊂ ·) :=\n  rfl\n\n"}
{"name":"Finset.le_iff_subset","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns₁ s₂ : Finset α\n⊢ Iff (LE.le s₁ s₂) (HasSubset.Subset s₁ s₂)","decl":"theorem le_iff_subset {s₁ s₂ : Finset α} : s₁ ≤ s₂ ↔ s₁ ⊆ s₂ :=\n  Iff.rfl\n\n"}
{"name":"Finset.lt_iff_ssubset","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns₁ s₂ : Finset α\n⊢ Iff (LT.lt s₁ s₂) (HasSSubset.SSubset s₁ s₂)","decl":"theorem lt_iff_ssubset {s₁ s₂ : Finset α} : s₁ < s₂ ↔ s₁ ⊂ s₂ :=\n  Iff.rfl\n\n"}
{"name":"Finset.coe_ssubset","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns₁ s₂ : Finset α\n⊢ Iff (HasSSubset.SSubset ↑s₁ ↑s₂) (HasSSubset.SSubset s₁ s₂)","decl":"@[simp, norm_cast]\ntheorem coe_ssubset {s₁ s₂ : Finset α} : (s₁ : Set α) ⊂ s₂ ↔ s₁ ⊂ s₂ :=\n  show (s₁ : Set α) ⊂ s₂ ↔ s₁ ⊆ s₂ ∧ ¬s₂ ⊆ s₁ by simp only [Set.ssubset_def, Finset.coe_subset]\n\n"}
{"name":"Finset.val_lt_iff","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns₁ s₂ : Finset α\n⊢ Iff (LT.lt s₁.val s₂.val) (HasSSubset.SSubset s₁ s₂)","decl":"@[simp]\ntheorem val_lt_iff {s₁ s₂ : Finset α} : s₁.1 < s₂.1 ↔ s₁ ⊂ s₂ :=\n  and_congr val_le_iff <| not_congr val_le_iff\n\n"}
{"name":"Finset.val_strictMono","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\n⊢ StrictMono Finset.val","decl":"lemma val_strictMono : StrictMono (val : Finset α → Multiset α) := fun _ _ ↦ val_lt_iff.2\n\n"}
{"name":"Finset.ssubset_iff_subset_ne","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns t : Finset α\n⊢ Iff (HasSSubset.SSubset s t) (And (HasSubset.Subset s t) (Ne s t))","decl":"theorem ssubset_iff_subset_ne {s t : Finset α} : s ⊂ t ↔ s ⊆ t ∧ s ≠ t :=\n  @lt_iff_le_and_ne _ _ s t\n\n"}
{"name":"Finset.ssubset_iff_of_subset","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns₁ s₂ : Finset α\nh : HasSubset.Subset s₁ s₂\n⊢ Iff (HasSSubset.SSubset s₁ s₂) (Exists fun x => And (Membership.mem s₂ x) (Not (Membership.mem s₁ x)))","decl":"theorem ssubset_iff_of_subset {s₁ s₂ : Finset α} (h : s₁ ⊆ s₂) : s₁ ⊂ s₂ ↔ ∃ x ∈ s₂, x ∉ s₁ :=\n  Set.ssubset_iff_of_subset h\n\n"}
{"name":"Finset.ssubset_of_ssubset_of_subset","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns₁ s₂ s₃ : Finset α\nhs₁s₂ : HasSSubset.SSubset s₁ s₂\nhs₂s₃ : HasSubset.Subset s₂ s₃\n⊢ HasSSubset.SSubset s₁ s₃","decl":"theorem ssubset_of_ssubset_of_subset {s₁ s₂ s₃ : Finset α} (hs₁s₂ : s₁ ⊂ s₂) (hs₂s₃ : s₂ ⊆ s₃) :\n    s₁ ⊂ s₃ :=\n  Set.ssubset_of_ssubset_of_subset hs₁s₂ hs₂s₃\n\n"}
{"name":"Finset.ssubset_of_subset_of_ssubset","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns₁ s₂ s₃ : Finset α\nhs₁s₂ : HasSubset.Subset s₁ s₂\nhs₂s₃ : HasSSubset.SSubset s₂ s₃\n⊢ HasSSubset.SSubset s₁ s₃","decl":"theorem ssubset_of_subset_of_ssubset {s₁ s₂ s₃ : Finset α} (hs₁s₂ : s₁ ⊆ s₂) (hs₂s₃ : s₂ ⊂ s₃) :\n    s₁ ⊂ s₃ :=\n  Set.ssubset_of_subset_of_ssubset hs₁s₂ hs₂s₃\n\n"}
{"name":"Finset.exists_of_ssubset","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns₁ s₂ : Finset α\nh : HasSSubset.SSubset s₁ s₂\n⊢ Exists fun x => And (Membership.mem s₂ x) (Not (Membership.mem s₁ x))","decl":"theorem exists_of_ssubset {s₁ s₂ : Finset α} (h : s₁ ⊂ s₂) : ∃ x ∈ s₂, x ∉ s₁ :=\n  Set.exists_of_ssubset h\n\n"}
{"name":"Finset.isWellFounded_ssubset","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\n⊢ IsWellFounded (Finset α) fun x1 x2 => HasSSubset.SSubset x1 x2","decl":"instance isWellFounded_ssubset : IsWellFounded (Finset α) (· ⊂ ·) :=\n  Subrelation.isWellFounded (InvImage _ _) val_lt_iff.2\n\n"}
{"name":"Finset.wellFoundedLT","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\n⊢ WellFoundedLT (Finset α)","decl":"instance wellFoundedLT : WellFoundedLT (Finset α) :=\n  Finset.isWellFounded_ssubset\n\n"}
{"name":"Finset.coe_coeEmb","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\n⊢ Eq (⇑Finset.coeEmb) Finset.toSet","decl":"@[simp]\ntheorem coe_coeEmb : ⇑(coeEmb : Finset α ↪o Set α) = ((↑) : Finset α → Set α) :=\n  rfl\n\n"}
{"name":"Finset.sizeOf_lt_sizeOf_of_mem","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ninst✝ : SizeOf α\nx : α\ns : Finset α\nhx : Membership.mem s x\n⊢ LT.lt (SizeOf.sizeOf x) (SizeOf.sizeOf s)","decl":"theorem sizeOf_lt_sizeOf_of_mem [SizeOf α] {x : α} {s : Finset α} (hx : x ∈ s) :\n    SizeOf.sizeOf x < SizeOf.sizeOf s := by\n  cases s\n  dsimp [SizeOf.sizeOf, SizeOf.sizeOf, Multiset.sizeOf]\n  rw [Nat.add_comm]\n  refine lt_trans ?_ (Nat.lt_succ_self _)\n  exact Multiset.sizeOf_lt_sizeOf_of_mem hx\n\n"}
{"name":"Finset.pairwise_subtype_iff_pairwise_finset'","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nr : β → β → Prop\nf : α → β\n⊢ Iff (Pairwise (Function.onFun r fun x => f ↑x)) ((↑s).Pairwise (Function.onFun r f))","decl":"theorem pairwise_subtype_iff_pairwise_finset' (r : β → β → Prop) (f : α → β) :\n    Pairwise (r on fun x : s => f x) ↔ (s : Set α).Pairwise (r on f) :=\n  pairwise_subtype_iff_pairwise_set (s : Set α) (r on f)\n\n"}
{"name":"Finset.pairwise_subtype_iff_pairwise_finset","module":"Mathlib.Data.Finset.Defs","initialProofState":"α : Type u_1\ns : Finset α\nr : α → α → Prop\n⊢ Iff (Pairwise (Function.onFun r fun x => ↑x)) ((↑s).Pairwise r)","decl":"theorem pairwise_subtype_iff_pairwise_finset (r : α → α → Prop) :\n    Pairwise (r on fun x : s => x) ↔ (s : Set α).Pairwise r :=\n  pairwise_subtype_iff_pairwise_finset' r id\n\n"}
