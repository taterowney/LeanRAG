{"name":"hasBinaryProducts_of_hasTerminal_and_pullbacks","module":"Mathlib.CategoryTheory.Limits.Constructions.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\n⊢ CategoryTheory.Limits.HasBinaryProducts C","decl":"/-- Any category with pullbacks and terminal object has binary products. -/\ntheorem hasBinaryProducts_of_hasTerminal_and_pullbacks [HasTerminal C] [HasPullbacks C] :\n    HasBinaryProducts C :=\n  { has_limit := fun F => HasLimit.mk (limitConeOfTerminalAndPullbacks F) }\n\n"}
{"name":"preservesBinaryProducts_of_preservesTerminal_and_pullbacks","module":"Mathlib.CategoryTheory.Limits.Constructions.BinaryProducts","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\ninst✝³ : CategoryTheory.Limits.HasTerminal C\ninst✝² : CategoryTheory.Limits.HasPullbacks C\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) F\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingCospan F\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F","decl":"/-- A functor that preserves terminal objects and pullbacks preserves binary products. -/\nlemma preservesBinaryProducts_of_preservesTerminal_and_pullbacks [HasTerminal C]\n    [HasPullbacks C] [PreservesLimitsOfShape (Discrete.{0} PEmpty) F]\n    [PreservesLimitsOfShape WalkingCospan F] : PreservesLimitsOfShape (Discrete WalkingPair) F :=\n  ⟨fun {K} =>\n    preservesLimit_of_preserves_limit_cone (limitConeOfTerminalAndPullbacks K).2\n      (by\n        apply\n          isBinaryProductOfIsTerminalIsPullback _ _ (isLimitOfHasTerminalOfPreservesLimit F)\n        apply isLimitOfHasPullbackOfPreservesLimit)⟩\n\n"}
{"name":"prodIsoPullback_hom_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasTerminal C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct X Y\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (prodIsoPullback X Y).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.terminal.from X) (CategoryTheory.Limits.terminal.from Y)) h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst h)","decl":"@[reassoc (attr := simp)]\nlemma prodIsoPullback_hom_fst [HasTerminal C] [HasPullbacks C] (X Y : C)\n    [HasBinaryProduct X Y] : (prodIsoPullback X Y).hom ≫ pullback.fst _ _ = prod.fst :=\n  limit.isoLimitCone_hom_π (limitConeOfTerminalAndPullbacks _) ⟨.left⟩\n\n"}
{"name":"prodIsoPullback_hom_fst","module":"Mathlib.CategoryTheory.Limits.Constructions.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasTerminal C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (prodIsoPullback X Y).hom (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.terminal.from X) (CategoryTheory.Limits.terminal.from Y))) CategoryTheory.Limits.prod.fst","decl":"@[reassoc (attr := simp)]\nlemma prodIsoPullback_hom_fst [HasTerminal C] [HasPullbacks C] (X Y : C)\n    [HasBinaryProduct X Y] : (prodIsoPullback X Y).hom ≫ pullback.fst _ _ = prod.fst :=\n  limit.isoLimitCone_hom_π (limitConeOfTerminalAndPullbacks _) ⟨.left⟩\n\n"}
{"name":"prodIsoPullback_hom_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasTerminal C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct X Y\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (prodIsoPullback X Y).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.terminal.from X) (CategoryTheory.Limits.terminal.from Y)) h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd h)","decl":"@[reassoc (attr := simp)]\nlemma prodIsoPullback_hom_snd [HasTerminal C] [HasPullbacks C] (X Y : C)\n    [HasBinaryProduct X Y] : (prodIsoPullback X Y).hom ≫ pullback.snd _ _ = prod.snd :=\n  limit.isoLimitCone_hom_π (limitConeOfTerminalAndPullbacks _) ⟨.right⟩\n\n"}
{"name":"prodIsoPullback_hom_snd","module":"Mathlib.CategoryTheory.Limits.Constructions.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasTerminal C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (prodIsoPullback X Y).hom (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.terminal.from X) (CategoryTheory.Limits.terminal.from Y))) CategoryTheory.Limits.prod.snd","decl":"@[reassoc (attr := simp)]\nlemma prodIsoPullback_hom_snd [HasTerminal C] [HasPullbacks C] (X Y : C)\n    [HasBinaryProduct X Y] : (prodIsoPullback X Y).hom ≫ pullback.snd _ _ = prod.snd :=\n  limit.isoLimitCone_hom_π (limitConeOfTerminalAndPullbacks _) ⟨.right⟩\n\n"}
{"name":"prodIsoPullback_inv_fst","module":"Mathlib.CategoryTheory.Limits.Constructions.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasTerminal C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (prodIsoPullback X Y).inv CategoryTheory.Limits.prod.fst) (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.terminal.from X) (CategoryTheory.Limits.terminal.from Y))","decl":"@[reassoc (attr := simp)]\nlemma prodIsoPullback_inv_fst [HasTerminal C] [HasPullbacks C] (X Y : C)\n    [HasBinaryProduct X Y] : (prodIsoPullback X Y).inv ≫ prod.fst = pullback.fst _ _ :=\n  limit.isoLimitCone_inv_π (limitConeOfTerminalAndPullbacks _) ⟨.left⟩\n\n"}
{"name":"prodIsoPullback_inv_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasTerminal C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct X Y\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (prodIsoPullback X Y).inv (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.terminal.from X) (CategoryTheory.Limits.terminal.from Y)) h)","decl":"@[reassoc (attr := simp)]\nlemma prodIsoPullback_inv_fst [HasTerminal C] [HasPullbacks C] (X Y : C)\n    [HasBinaryProduct X Y] : (prodIsoPullback X Y).inv ≫ prod.fst = pullback.fst _ _ :=\n  limit.isoLimitCone_inv_π (limitConeOfTerminalAndPullbacks _) ⟨.left⟩\n\n"}
{"name":"prodIsoPullback_inv_snd","module":"Mathlib.CategoryTheory.Limits.Constructions.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasTerminal C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (prodIsoPullback X Y).inv CategoryTheory.Limits.prod.snd) (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.terminal.from X) (CategoryTheory.Limits.terminal.from Y))","decl":"@[reassoc (attr := simp)]\nlemma prodIsoPullback_inv_snd [HasTerminal C] [HasPullbacks C] (X Y : C)\n    [HasBinaryProduct X Y] : (prodIsoPullback X Y).inv ≫ prod.snd = pullback.snd _ _ :=\n  limit.isoLimitCone_inv_π (limitConeOfTerminalAndPullbacks _) ⟨.right⟩\n\n"}
{"name":"prodIsoPullback_inv_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasTerminal C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct X Y\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (prodIsoPullback X Y).inv (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.terminal.from X) (CategoryTheory.Limits.terminal.from Y)) h)","decl":"@[reassoc (attr := simp)]\nlemma prodIsoPullback_inv_snd [HasTerminal C] [HasPullbacks C] (X Y : C)\n    [HasBinaryProduct X Y] : (prodIsoPullback X Y).inv ≫ prod.snd = pullback.snd _ _ :=\n  limit.isoLimitCone_inv_π (limitConeOfTerminalAndPullbacks _) ⟨.right⟩\n\n"}
{"name":"hasBinaryCoproducts_of_hasInitial_and_pushouts","module":"Mathlib.CategoryTheory.Limits.Constructions.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasInitial C\ninst✝ : CategoryTheory.Limits.HasPushouts C\n⊢ CategoryTheory.Limits.HasBinaryCoproducts C","decl":"/-- Any category with pushouts and initial object has binary coproducts. -/\ntheorem hasBinaryCoproducts_of_hasInitial_and_pushouts [HasInitial C] [HasPushouts C] :\n    HasBinaryCoproducts C :=\n  { has_colimit := fun F => HasColimit.mk (colimitCoconeOfInitialAndPushouts F) }\n\n"}
{"name":"preservesBinaryCoproducts_of_preservesInitial_and_pushouts","module":"Mathlib.CategoryTheory.Limits.Constructions.BinaryProducts","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\ninst✝³ : CategoryTheory.Limits.HasInitial C\ninst✝² : CategoryTheory.Limits.HasPushouts C\ninst✝¹ : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) F\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingSpan F\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F","decl":"/-- A functor that preserves initial objects and pushouts preserves binary coproducts. -/\nlemma preservesBinaryCoproducts_of_preservesInitial_and_pushouts [HasInitial C]\n    [HasPushouts C] [PreservesColimitsOfShape (Discrete.{0} PEmpty) F]\n    [PreservesColimitsOfShape WalkingSpan F] : PreservesColimitsOfShape (Discrete WalkingPair) F :=\n  ⟨fun {K} =>\n    preservesColimit_of_preserves_colimit_cocone (colimitCoconeOfInitialAndPushouts K).2 (by\n      apply\n        isBinaryCoproductOfIsInitialIsPushout _ _\n          (isColimitOfHasInitialOfPreservesColimit F)\n      apply isColimitOfHasPushoutOfPreservesColimit)⟩\n\n"}
{"name":"inl_coprodIsoPushout_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasInitial C\ninst✝¹ : CategoryTheory.Limits.HasPushouts C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout (CategoryTheory.Limits.initial.to X) (CategoryTheory.Limits.initial.to Y)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl (CategoryTheory.CategoryStruct.comp (coprodIsoPushout X Y).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (CategoryTheory.Limits.initial.to X) (CategoryTheory.Limits.initial.to Y)) h)","decl":"@[reassoc (attr := simp)]\nlemma inl_coprodIsoPushout_hom [HasInitial C] [HasPushouts C] (X Y : C)\n    [HasBinaryCoproduct X Y] : coprod.inl ≫ (coprodIsoPushout X Y).hom = pushout.inl _ _ :=\n  colimit.isoColimitCocone_ι_hom (colimitCoconeOfInitialAndPushouts _) _\n\n"}
{"name":"inl_coprodIsoPushout_hom","module":"Mathlib.CategoryTheory.Limits.Constructions.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasInitial C\ninst✝¹ : CategoryTheory.Limits.HasPushouts C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl (coprodIsoPushout X Y).hom) (CategoryTheory.Limits.pushout.inl (CategoryTheory.Limits.initial.to X) (CategoryTheory.Limits.initial.to Y))","decl":"@[reassoc (attr := simp)]\nlemma inl_coprodIsoPushout_hom [HasInitial C] [HasPushouts C] (X Y : C)\n    [HasBinaryCoproduct X Y] : coprod.inl ≫ (coprodIsoPushout X Y).hom = pushout.inl _ _ :=\n  colimit.isoColimitCocone_ι_hom (colimitCoconeOfInitialAndPushouts _) _\n\n"}
{"name":"inr_coprodIsoPushout_hom","module":"Mathlib.CategoryTheory.Limits.Constructions.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasInitial C\ninst✝¹ : CategoryTheory.Limits.HasPushouts C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr (coprodIsoPushout X Y).hom) (CategoryTheory.Limits.pushout.inr (CategoryTheory.Limits.initial.to X) (CategoryTheory.Limits.initial.to Y))","decl":"@[reassoc (attr := simp)]\nlemma inr_coprodIsoPushout_hom [HasInitial C] [HasPushouts C] (X Y : C)\n    [HasBinaryCoproduct X Y] : coprod.inr ≫ (coprodIsoPushout X Y).hom = pushout.inr _ _ :=\n  colimit.isoColimitCocone_ι_hom (colimitCoconeOfInitialAndPushouts _) _\n\n"}
{"name":"inr_coprodIsoPushout_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasInitial C\ninst✝¹ : CategoryTheory.Limits.HasPushouts C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout (CategoryTheory.Limits.initial.to X) (CategoryTheory.Limits.initial.to Y)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr (CategoryTheory.CategoryStruct.comp (coprodIsoPushout X Y).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr (CategoryTheory.Limits.initial.to X) (CategoryTheory.Limits.initial.to Y)) h)","decl":"@[reassoc (attr := simp)]\nlemma inr_coprodIsoPushout_hom [HasInitial C] [HasPushouts C] (X Y : C)\n    [HasBinaryCoproduct X Y] : coprod.inr ≫ (coprodIsoPushout X Y).hom = pushout.inr _ _ :=\n  colimit.isoColimitCocone_ι_hom (colimitCoconeOfInitialAndPushouts _) _\n\n"}
{"name":"inl_coprodIsoPushout_inv","module":"Mathlib.CategoryTheory.Limits.Constructions.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasInitial C\ninst✝¹ : CategoryTheory.Limits.HasPushouts C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (CategoryTheory.Limits.initial.to X) (CategoryTheory.Limits.initial.to Y)) (coprodIsoPushout X Y).inv) CategoryTheory.Limits.coprod.inl","decl":"@[reassoc (attr := simp)]\nlemma inl_coprodIsoPushout_inv [HasInitial C] [HasPushouts C] (X Y : C)\n    [HasBinaryCoproduct X Y] : pushout.inl _ _ ≫ (coprodIsoPushout X Y).inv = coprod.inl :=\n  colimit.isoColimitCocone_ι_inv (colimitCoconeOfInitialAndPushouts (pair X Y)) ⟨.left⟩\n\n"}
{"name":"inl_coprodIsoPushout_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasInitial C\ninst✝¹ : CategoryTheory.Limits.HasPushouts C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.coprod X Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (CategoryTheory.Limits.initial.to X) (CategoryTheory.Limits.initial.to Y)) (CategoryTheory.CategoryStruct.comp (coprodIsoPushout X Y).inv h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl h)","decl":"@[reassoc (attr := simp)]\nlemma inl_coprodIsoPushout_inv [HasInitial C] [HasPushouts C] (X Y : C)\n    [HasBinaryCoproduct X Y] : pushout.inl _ _ ≫ (coprodIsoPushout X Y).inv = coprod.inl :=\n  colimit.isoColimitCocone_ι_inv (colimitCoconeOfInitialAndPushouts (pair X Y)) ⟨.left⟩\n\n"}
{"name":"inr_coprodIsoPushout_inv","module":"Mathlib.CategoryTheory.Limits.Constructions.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasInitial C\ninst✝¹ : CategoryTheory.Limits.HasPushouts C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr (CategoryTheory.Limits.initial.to X) (CategoryTheory.Limits.initial.to Y)) (coprodIsoPushout X Y).inv) CategoryTheory.Limits.coprod.inr","decl":"@[reassoc (attr := simp)]\nlemma inr_coprodIsoPushout_inv [HasInitial C] [HasPushouts C] (X Y : C)\n    [HasBinaryCoproduct X Y] : pushout.inr _ _ ≫ (coprodIsoPushout X Y).inv = coprod.inr :=\n  colimit.isoColimitCocone_ι_inv (colimitCoconeOfInitialAndPushouts (pair X Y)) ⟨.right⟩\n"}
{"name":"inr_coprodIsoPushout_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasInitial C\ninst✝¹ : CategoryTheory.Limits.HasPushouts C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.coprod X Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr (CategoryTheory.Limits.initial.to X) (CategoryTheory.Limits.initial.to Y)) (CategoryTheory.CategoryStruct.comp (coprodIsoPushout X Y).inv h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr h)","decl":"@[reassoc (attr := simp)]\nlemma inr_coprodIsoPushout_inv [HasInitial C] [HasPushouts C] (X Y : C)\n    [HasBinaryCoproduct X Y] : pushout.inr _ _ ≫ (coprodIsoPushout X Y).inv = coprod.inr :=\n  colimit.isoColimitCocone_ι_inv (colimitCoconeOfInitialAndPushouts (pair X Y)) ⟨.right⟩\n"}
