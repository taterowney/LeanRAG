{"name":"List.Pi.cons_def","module":"Mathlib.Data.List.Pi","initialProofState":"ι : Type u_1\ninst✝ : DecidableEq ι\nα : ι → Sort u_2\ni : ι\nl : List ι\na : α i\nf : (j : ι) → Membership.mem l j → α j\n⊢ Eq (List.Pi.cons i l a f) fun j hj => dite (Eq j i) (fun h => Eq.rec a ⋯) fun h => f j ⋯","decl":"lemma cons_def (a : α i) (f : ∀ j ∈ l, α j) : cons _ _ a f =\n    fun j hj ↦ if h : j = i then h.symm.rec a else f j <| (mem_cons.1 hj).resolve_left h :=\n  rfl\n\n"}
{"name":"Multiset.Pi.cons_coe","module":"Mathlib.Data.List.Pi","initialProofState":"ι : Type u_1\ninst✝ : DecidableEq ι\nα : ι → Sort u_2\ni : ι\nl : List ι\na : α i\nf : (j : ι) → Membership.mem l j → α j\n⊢ Eq (Multiset.Pi.cons (↑l) i a f) (List.Pi.cons i l a f)","decl":"@[simp] lemma _root_.Multiset.Pi.cons_coe {l : List ι} (a : α i) (f : ∀ j ∈ l, α j) :\n    Multiset.Pi.cons l _ a f = cons _ _ a f :=\n  rfl\n\n"}
{"name":"List.Pi.cons_eta","module":"Mathlib.Data.List.Pi","initialProofState":"ι : Type u_1\ninst✝ : DecidableEq ι\nα : ι → Sort u_2\ni : ι\nl : List ι\nf : (j : ι) → Membership.mem (List.cons i l) j → α j\n⊢ Eq (List.Pi.cons i l (List.Pi.head f) (List.Pi.tail f)) f","decl":"@[simp] lemma cons_eta (f : ∀ j ∈ i :: l, α j) :\n    cons _ _ (head f) (tail f) = f :=\n  Multiset.Pi.cons_eta (α := ι) (m := l) f\n\n"}
{"name":"List.Pi.cons_map","module":"Mathlib.Data.List.Pi","initialProofState":"ι : Type u_1\ninst✝ : DecidableEq ι\nα : ι → Sort u_2\ni : ι\nl : List ι\na : α i\nf : (j : ι) → Membership.mem l j → α j\nα' : ι → Sort u_3\nφ : ⦃j : ι⦄ → α j → α' j\n⊢ Eq (List.Pi.cons i l (φ a) fun j hj => φ (f j hj)) fun j hj => φ (List.Pi.cons i l a f j hj)","decl":"lemma cons_map (a : α i) (f : ∀ j ∈ l, α j)\n    {α' : ι → Sort*} (φ : ∀ ⦃j⦄, α j → α' j) :\n    cons _ _ (φ a) (fun j hj ↦ φ (f j hj)) = (fun j hj ↦ φ ((cons _ _ a f) j hj)) :=\n  Multiset.Pi.cons_map _ _ _\n\n"}
{"name":"List.Pi.forall_rel_cons_ext","module":"Mathlib.Data.List.Pi","initialProofState":"ι : Type u_1\ninst✝ : DecidableEq ι\nα : ι → Sort u_2\ni : ι\nl : List ι\nr : ⦃i : ι⦄ → α i → α i → Prop\na₁ a₂ : α i\nf₁ f₂ : (j : ι) → Membership.mem l j → α j\nha : r a₁ a₂\nhf : ∀ (i : ι) (hi : Membership.mem l i), r (f₁ i hi) (f₂ i hi)\nj : ι\nhj : Membership.mem (List.cons i l) j\n⊢ r (List.Pi.cons i l a₁ f₁ j hj) (List.Pi.cons i l a₂ f₂ j hj)","decl":"lemma forall_rel_cons_ext {r : ∀ ⦃i⦄, α i → α i → Prop} {a₁ a₂ : α i} {f₁ f₂ : ∀ j ∈ l, α j}\n    (ha : r a₁ a₂) (hf : ∀ (i : ι) (hi : i ∈ l), r (f₁ i hi) (f₂ i hi)) :\n    ∀ j hj, r (cons _ _ a₁ f₁ j hj) (cons _ _ a₂ f₂ j hj) :=\n  Multiset.Pi.forall_rel_cons_ext (α := ι) (m := l) ha hf\n\n"}
{"name":"List.pi_nil","module":"Mathlib.Data.List.Pi","initialProofState":"ι : Type u_1\ninst✝ : DecidableEq ι\nα : ι → Type u_2\nt : (i : ι) → List (α i)\n⊢ Eq (List.nil.pi t) (List.cons (List.Pi.nil α) List.nil)","decl":"@[simp] lemma pi_nil (t : ∀ i, List (α i)) :\n    pi [] t = [Pi.nil α] :=\n  rfl\n\n"}
{"name":"List.pi_cons","module":"Mathlib.Data.List.Pi","initialProofState":"ι : Type u_1\ninst✝ : DecidableEq ι\nα : ι → Type u_2\ni : ι\nl : List ι\nt : (j : ι) → List (α j)\n⊢ Eq ((List.cons i l).pi t) ((t i).flatMap fun b => List.map (List.Pi.cons i l b) (l.pi t))","decl":"@[simp] lemma pi_cons (i : ι) (l : List ι) (t : ∀ j, List (α j)) :\n    pi (i :: l) t = ((t i).flatMap fun b ↦ (pi l t).map <| Pi.cons _ _ b) :=\n  rfl\n\n"}
{"name":"Multiset.pi_coe","module":"Mathlib.Data.List.Pi","initialProofState":"ι : Type u_1\ninst✝ : DecidableEq ι\nα : ι → Type u_2\nl : List ι\nfs : (i : ι) → List (α i)\n⊢ Eq ((↑l).pi fun x => ↑(fs x)) ↑(l.pi fs)","decl":"lemma _root_.Multiset.pi_coe (l : List ι) (fs : ∀ i, List (α i)) :\n    (l : Multiset ι).pi (fs ·) = (↑(pi l fs) : Multiset (∀ i ∈ l, α i)) := by\n  induction' l with i l ih\n  · change Multiset.pi 0 _ = _\n    simp only [Multiset.coe_singleton, Multiset.pi_zero, pi_nil, Multiset.singleton_inj]\n    ext i hi\n    simp at hi\n  · change Multiset.pi (i ::ₘ ↑l) _ = _\n    simp [ih, Multiset.coe_bind, - Multiset.cons_coe]\n\n"}
{"name":"List.mem_pi","module":"Mathlib.Data.List.Pi","initialProofState":"ι : Type u_1\ninst✝ : DecidableEq ι\nα : ι → Type u_2\nl : List ι\nfs : (i : ι) → List (α i)\nf : (i : ι) → Membership.mem l i → α i\n⊢ Iff (Membership.mem (l.pi fs) f) (∀ (i : ι) (hi : Membership.mem l i), Membership.mem (fs i) (f i hi))","decl":"lemma mem_pi {l : List ι} (fs : ∀ i, List (α i)) :\n    ∀ f : ∀ i ∈ l, α i, (f ∈ pi l fs) ↔ (∀ i (hi : i ∈ l), f i hi ∈ fs i) := by\n  intros f\n  convert @Multiset.mem_pi ι _ α ↑l (fs ·) f using 1\n  rw [Multiset.pi_coe]\n  rfl\n\n"}
