{"name":"IsPrimitiveRoot.iff_def","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nζ : M\nk : Nat\n⊢ Iff (IsPrimitiveRoot ζ k) (And (Eq (HPow.hPow ζ k) 1) (∀ (l : Nat), Eq (HPow.hPow ζ l) 1 → Dvd.dvd k l))","decl":"/-- An element `ζ` is a primitive `k`-th root of unity if `ζ ^ k = 1`,\nand if `l` satisfies `ζ ^ l = 1` then `k ∣ l`. -/\n@[mk_iff IsPrimitiveRoot.iff_def]\nstructure IsPrimitiveRoot (ζ : M) (k : ℕ) : Prop where\n  pow_eq_one : ζ ^ k = 1\n  dvd_of_pow_eq_one : ∀ l : ℕ, ζ ^ l = 1 → k ∣ l\n\n"}
{"name":"IsPrimitiveRoot.pow_eq_one","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nζ : M\nk : Nat\nself : IsPrimitiveRoot ζ k\n⊢ Eq (HPow.hPow ζ k) 1","decl":"/-- An element `ζ` is a primitive `k`-th root of unity if `ζ ^ k = 1`,\nand if `l` satisfies `ζ ^ l = 1` then `k ∣ l`. -/\n@[mk_iff IsPrimitiveRoot.iff_def]\nstructure IsPrimitiveRoot (ζ : M) (k : ℕ) : Prop where\n  pow_eq_one : ζ ^ k = 1\n  dvd_of_pow_eq_one : ∀ l : ℕ, ζ ^ l = 1 → k ∣ l\n\n"}
{"name":"IsPrimitiveRoot.dvd_of_pow_eq_one","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nζ : M\nk : Nat\nself : IsPrimitiveRoot ζ k\nl : Nat\na✝ : Eq (HPow.hPow ζ l) 1\n⊢ Dvd.dvd k l","decl":"/-- An element `ζ` is a primitive `k`-th root of unity if `ζ ^ k = 1`,\nand if `l` satisfies `ζ ^ l = 1` then `k ∣ l`. -/\n@[mk_iff IsPrimitiveRoot.iff_def]\nstructure IsPrimitiveRoot (ζ : M) (k : ℕ) : Prop where\n  pow_eq_one : ζ ^ k = 1\n  dvd_of_pow_eq_one : ∀ l : ℕ, ζ ^ l = 1 → k ∣ l\n\n"}
{"name":"IsPrimitiveRoot.val_toRootsOfUnity_coe","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nμ : M\nn : Nat\ninst✝ : NeZero n\nh : IsPrimitiveRoot μ n\n⊢ Eq (↑↑h.toRootsOfUnity) μ","decl":"/-- Turn a primitive root μ into a member of the `rootsOfUnity` subgroup. -/\n@[simps!]\ndef IsPrimitiveRoot.toRootsOfUnity {μ : M} {n : ℕ} [NeZero n] (h : IsPrimitiveRoot μ n) :\n    rootsOfUnity n M :=\n  rootsOfUnity.mkOfPowEq μ h.pow_eq_one\n\n"}
{"name":"IsPrimitiveRoot.val_inv_toRootsOfUnity_coe","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nμ : M\nn : Nat\ninst✝ : NeZero n\nh : IsPrimitiveRoot μ n\n⊢ Eq (↑(Inv.inv ↑h.toRootsOfUnity)) (HPow.hPow μ (HSub.hSub n 1))","decl":"/-- Turn a primitive root μ into a member of the `rootsOfUnity` subgroup. -/\n@[simps!]\ndef IsPrimitiveRoot.toRootsOfUnity {μ : M} {n : ℕ} [NeZero n] (h : IsPrimitiveRoot μ n) :\n    rootsOfUnity n M :=\n  rootsOfUnity.mkOfPowEq μ h.pow_eq_one\n\n"}
{"name":"mem_primitiveRoots","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\nk : Nat\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nζ : R\nh0 : LT.lt 0 k\n⊢ Iff (Membership.mem (primitiveRoots k R) ζ) (IsPrimitiveRoot ζ k)","decl":"@[simp]\ntheorem mem_primitiveRoots {ζ : R} (h0 : 0 < k) : ζ ∈ primitiveRoots k R ↔ IsPrimitiveRoot ζ k := by\n  classical\n  rw [primitiveRoots, mem_filter, Multiset.mem_toFinset, mem_nthRoots h0, and_iff_right_iff_imp]\n  exact IsPrimitiveRoot.pow_eq_one\n\n"}
{"name":"primitiveRoots_zero","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ Eq (primitiveRoots 0 R) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem primitiveRoots_zero : primitiveRoots 0 R = ∅ := by\n  classical\n  rw [primitiveRoots, nthRoots_zero, Multiset.toFinset_zero, Finset.filter_empty]\n\n"}
{"name":"isPrimitiveRoot_of_mem_primitiveRoots","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\nk : Nat\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nζ : R\nh : Membership.mem (primitiveRoots k R) ζ\n⊢ IsPrimitiveRoot ζ k","decl":"theorem isPrimitiveRoot_of_mem_primitiveRoots {ζ : R} (h : ζ ∈ primitiveRoots k R) :\n    IsPrimitiveRoot ζ k :=\n  k.eq_zero_or_pos.elim (fun hk ↦ by simp [hk] at h) fun hk ↦ (mem_primitiveRoots hk).1 h\n\n"}
{"name":"IsPrimitiveRoot.mk_of_lt","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nk : Nat\nζ : M\nhk : LT.lt 0 k\nh1 : Eq (HPow.hPow ζ k) 1\nh : ∀ (l : Nat), LT.lt 0 l → LT.lt l k → Ne (HPow.hPow ζ l) 1\n⊢ IsPrimitiveRoot ζ k","decl":"theorem mk_of_lt (ζ : M) (hk : 0 < k) (h1 : ζ ^ k = 1) (h : ∀ l : ℕ, 0 < l → l < k → ζ ^ l ≠ 1) :\n    IsPrimitiveRoot ζ k := by\n  refine ⟨h1, fun l hl ↦ ?_⟩\n  suffices k.gcd l = k by exact this ▸ k.gcd_dvd_right l\n  rw [eq_iff_le_not_lt]\n  refine ⟨Nat.le_of_dvd hk (k.gcd_dvd_left l), ?_⟩\n  intro h'; apply h _ (Nat.gcd_pos_of_pos_left _ hk) h'\n  exact pow_gcd_eq_one _ h1 hl\n\n"}
{"name":"IsPrimitiveRoot.of_subsingleton","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\ninst✝ : Subsingleton M\nx : M\n⊢ IsPrimitiveRoot x 1","decl":"@[nontriviality]\ntheorem of_subsingleton [Subsingleton M] (x : M) : IsPrimitiveRoot x 1 :=\n  ⟨Subsingleton.elim _ _, fun _ _ ↦ one_dvd _⟩\n\n"}
{"name":"IsPrimitiveRoot.pow_eq_one_iff_dvd","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nk : Nat\nζ : M\nh : IsPrimitiveRoot ζ k\nl : Nat\n⊢ Iff (Eq (HPow.hPow ζ l) 1) (Dvd.dvd k l)","decl":"theorem pow_eq_one_iff_dvd (h : IsPrimitiveRoot ζ k) (l : ℕ) : ζ ^ l = 1 ↔ k ∣ l :=\n  ⟨h.dvd_of_pow_eq_one l, by\n    rintro ⟨i, rfl⟩; simp only [pow_mul, h.pow_eq_one, one_pow]⟩\n\n"}
{"name":"IsPrimitiveRoot.isUnit","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nk : Nat\nζ : M\nh : IsPrimitiveRoot ζ k\nh0 : LT.lt 0 k\n⊢ IsUnit ζ","decl":"theorem isUnit (h : IsPrimitiveRoot ζ k) (h0 : 0 < k) : IsUnit ζ := by\n  apply isUnit_of_mul_eq_one ζ (ζ ^ (k - 1))\n  rw [← pow_succ', tsub_add_cancel_of_le h0.nat_succ_le, h.pow_eq_one]\n\n"}
{"name":"IsPrimitiveRoot.pow_ne_one_of_pos_of_lt","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nk l : Nat\nζ : M\nh : IsPrimitiveRoot ζ k\nh0 : LT.lt 0 l\nhl : LT.lt l k\n⊢ Ne (HPow.hPow ζ l) 1","decl":"theorem pow_ne_one_of_pos_of_lt (h : IsPrimitiveRoot ζ k) (h0 : 0 < l) (hl : l < k) : ζ ^ l ≠ 1 :=\n  mt (Nat.le_of_dvd h0 ∘ h.dvd_of_pow_eq_one _) <| not_le_of_lt hl\n\n"}
{"name":"IsPrimitiveRoot.ne_one","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nk : Nat\nζ : M\nh : IsPrimitiveRoot ζ k\nhk : LT.lt 1 k\n⊢ Ne ζ 1","decl":"theorem ne_one (h : IsPrimitiveRoot ζ k) (hk : 1 < k) : ζ ≠ 1 :=\n  h.pow_ne_one_of_pos_of_lt zero_lt_one hk ∘ (pow_one ζ).trans\n\n"}
{"name":"IsPrimitiveRoot.pow_inj","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nk : Nat\nζ : M\nh : IsPrimitiveRoot ζ k\ni j : Nat\nhi : LT.lt i k\nhj : LT.lt j k\nH : Eq (HPow.hPow ζ i) (HPow.hPow ζ j)\n⊢ Eq i j","decl":"theorem pow_inj (h : IsPrimitiveRoot ζ k) ⦃i j : ℕ⦄ (hi : i < k) (hj : j < k) (H : ζ ^ i = ζ ^ j) :\n    i = j := by\n  wlog hij : i ≤ j generalizing i j\n  · exact (this hj hi H.symm (le_of_not_le hij)).symm\n  apply le_antisymm hij\n  rw [← tsub_eq_zero_iff_le]\n  apply Nat.eq_zero_of_dvd_of_lt _ (lt_of_le_of_lt tsub_le_self hj)\n  apply h.dvd_of_pow_eq_one\n  rw [← ((h.isUnit (lt_of_le_of_lt (Nat.zero_le _) hi)).pow i).mul_left_inj, ← pow_add,\n    tsub_add_cancel_of_le hij, H, one_mul]\n\n"}
{"name":"IsPrimitiveRoot.one","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\n⊢ IsPrimitiveRoot 1 1","decl":"theorem one : IsPrimitiveRoot (1 : M) 1 :=\n  { pow_eq_one := pow_one _\n    dvd_of_pow_eq_one := fun _ _ ↦ one_dvd _ }\n\n"}
{"name":"IsPrimitiveRoot.one_right_iff","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nζ : M\n⊢ Iff (IsPrimitiveRoot ζ 1) (Eq ζ 1)","decl":"@[simp]\ntheorem one_right_iff : IsPrimitiveRoot ζ 1 ↔ ζ = 1 := by\n  constructor\n  · intro h; rw [← pow_one ζ, h.pow_eq_one]\n  · rintro rfl; exact one\n\n"}
{"name":"IsPrimitiveRoot.coe_submonoidClass_iff","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"k : Nat\nM : Type u_7\nB : Type u_8\ninst✝² : CommMonoid M\ninst✝¹ : SetLike B M\ninst✝ : SubmonoidClass B M\nN : B\nζ : Subtype fun x => Membership.mem N x\n⊢ Iff (IsPrimitiveRoot (↑ζ) k) (IsPrimitiveRoot ζ k)","decl":"@[simp]\ntheorem coe_submonoidClass_iff {M B : Type*} [CommMonoid M] [SetLike B M] [SubmonoidClass B M]\n    {N : B} {ζ : N} : IsPrimitiveRoot (ζ : M) k ↔ IsPrimitiveRoot ζ k := by\n  simp_rw [iff_def]\n  norm_cast\n\n"}
{"name":"IsPrimitiveRoot.coe_units_iff","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nk : Nat\nζ : Units M\n⊢ Iff (IsPrimitiveRoot (↑ζ) k) (IsPrimitiveRoot ζ k)","decl":"@[simp]\ntheorem coe_units_iff {ζ : Mˣ} : IsPrimitiveRoot (ζ : M) k ↔ IsPrimitiveRoot ζ k := by\n  simp only [iff_def, Units.ext_iff, Units.val_pow_eq_pow_val, Units.val_one]\n\n"}
{"name":"IsPrimitiveRoot.isUnit_unit","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nζ : M\nn : Nat\nhn : LT.lt 0 n\nhζ : IsPrimitiveRoot ζ n\n⊢ IsPrimitiveRoot ⋯.unit n","decl":"lemma isUnit_unit {ζ : M} {n} (hn) (hζ : IsPrimitiveRoot ζ n) :\n    IsPrimitiveRoot (hζ.isUnit hn).unit n := coe_units_iff.mp hζ\n\n"}
{"name":"IsPrimitiveRoot.isUnit_unit'","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"G : Type u_3\ninst✝ : DivisionCommMonoid G\nζ : G\nn : Nat\nhn : LT.lt 0 n\nhζ : IsPrimitiveRoot ζ n\n⊢ IsPrimitiveRoot ⋯.unit' n","decl":"lemma isUnit_unit' {ζ : G} {n} (hn) (hζ : IsPrimitiveRoot ζ n) :\n    IsPrimitiveRoot (hζ.isUnit hn).unit' n := coe_units_iff.mp hζ\n\n"}
{"name":"IsPrimitiveRoot.pow_of_coprime","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nk : Nat\nζ : M\nh : IsPrimitiveRoot ζ k\ni : Nat\nhi : i.Coprime k\n⊢ IsPrimitiveRoot (HPow.hPow ζ i) k","decl":"theorem pow_of_coprime (h : IsPrimitiveRoot ζ k) (i : ℕ) (hi : i.Coprime k) :\n    IsPrimitiveRoot (ζ ^ i) k := by\n  by_cases h0 : k = 0\n  · subst k; simp_all only [pow_one, Nat.coprime_zero_right]\n  rcases h.isUnit (Nat.pos_of_ne_zero h0) with ⟨ζ, rfl⟩\n  rw [← Units.val_pow_eq_pow_val]\n  rw [coe_units_iff] at h ⊢\n  refine\n    { pow_eq_one := by rw [← pow_mul', pow_mul, h.pow_eq_one, one_pow]\n      dvd_of_pow_eq_one := fun l hl ↦ h.dvd_of_pow_eq_one l ?_ }\n  rw [← pow_one ζ, ← zpow_natCast ζ, ← hi.gcd_eq_one, Nat.gcd_eq_gcd_ab, zpow_add, mul_pow,\n    ← zpow_natCast, ← zpow_mul, mul_right_comm]\n  simp only [zpow_mul, hl, h.pow_eq_one, one_zpow, one_pow, one_mul, zpow_natCast]\n\n"}
{"name":"IsPrimitiveRoot.pow_of_prime","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nk : Nat\nζ : M\nh : IsPrimitiveRoot ζ k\np : Nat\nhprime : Nat.Prime p\nhdiv : Not (Dvd.dvd p k)\n⊢ IsPrimitiveRoot (HPow.hPow ζ p) k","decl":"theorem pow_of_prime (h : IsPrimitiveRoot ζ k) {p : ℕ} (hprime : Nat.Prime p) (hdiv : ¬p ∣ k) :\n    IsPrimitiveRoot (ζ ^ p) k :=\n  h.pow_of_coprime p (hprime.coprime_iff_not_dvd.2 hdiv)\n\n"}
{"name":"IsPrimitiveRoot.pow_iff_coprime","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nk : Nat\nζ : M\nh : IsPrimitiveRoot ζ k\nh0 : LT.lt 0 k\ni : Nat\n⊢ Iff (IsPrimitiveRoot (HPow.hPow ζ i) k) (i.Coprime k)","decl":"theorem pow_iff_coprime (h : IsPrimitiveRoot ζ k) (h0 : 0 < k) (i : ℕ) :\n    IsPrimitiveRoot (ζ ^ i) k ↔ i.Coprime k := by\n  refine ⟨fun hi ↦ ?_, h.pow_of_coprime i⟩\n  obtain ⟨a, ha⟩ := i.gcd_dvd_left k\n  obtain ⟨b, hb⟩ := i.gcd_dvd_right k\n  suffices b = k by\n    rwa [this, eq_comm, Nat.mul_left_eq_self_iff h0, ← Nat.coprime_iff_gcd_eq_one] at hb\n  rw [ha] at hi\n  rw [mul_comm] at hb\n  apply Nat.dvd_antisymm ⟨i.gcd k, hb⟩ (hi.dvd_of_pow_eq_one b _)\n  rw [← pow_mul', ← mul_assoc, ← hb, pow_mul, h.pow_eq_one, one_pow]\n\n"}
{"name":"IsPrimitiveRoot.orderOf","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nζ : M\n⊢ IsPrimitiveRoot ζ (orderOf ζ)","decl":"protected theorem orderOf (ζ : M) : IsPrimitiveRoot ζ (orderOf ζ) :=\n  ⟨pow_orderOf_eq_one ζ, fun _ ↦ orderOf_dvd_of_pow_eq_one⟩\n\n"}
{"name":"IsPrimitiveRoot.unique","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nk l : Nat\nζ : M\nhk : IsPrimitiveRoot ζ k\nhl : IsPrimitiveRoot ζ l\n⊢ Eq k l","decl":"theorem unique {ζ : M} (hk : IsPrimitiveRoot ζ k) (hl : IsPrimitiveRoot ζ l) : k = l :=\n  Nat.dvd_antisymm (hk.2 _ hl.1) (hl.2 _ hk.1)\n\n"}
{"name":"IsPrimitiveRoot.eq_orderOf","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nk : Nat\nζ : M\nh : IsPrimitiveRoot ζ k\n⊢ Eq k (orderOf ζ)","decl":"theorem eq_orderOf (h : IsPrimitiveRoot ζ k) : k = orderOf ζ :=\n  h.unique (IsPrimitiveRoot.orderOf ζ)\n\n"}
{"name":"IsPrimitiveRoot.iff","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nk : Nat\nζ : M\nhk : LT.lt 0 k\n⊢ Iff (IsPrimitiveRoot ζ k) (And (Eq (HPow.hPow ζ k) 1) (∀ (l : Nat), LT.lt 0 l → LT.lt l k → Ne (HPow.hPow ζ l) 1))","decl":"protected theorem iff (hk : 0 < k) :\n    IsPrimitiveRoot ζ k ↔ ζ ^ k = 1 ∧ ∀ l : ℕ, 0 < l → l < k → ζ ^ l ≠ 1 := by\n  refine ⟨fun h ↦ ⟨h.pow_eq_one, fun l hl' hl ↦ ?_⟩,\n    fun ⟨hζ, hl⟩ ↦ IsPrimitiveRoot.mk_of_lt ζ hk hζ hl⟩\n  rw [h.eq_orderOf] at hl\n  exact pow_ne_one_of_lt_orderOf hl'.ne' hl\n\n"}
{"name":"IsPrimitiveRoot.not_iff","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nk : Nat\nζ : M\n⊢ Iff (Not (IsPrimitiveRoot ζ k)) (Ne (orderOf ζ) k)","decl":"protected theorem not_iff : ¬IsPrimitiveRoot ζ k ↔ orderOf ζ ≠ k :=\n  ⟨fun h hk ↦ h <| hk ▸ IsPrimitiveRoot.orderOf ζ,\n    fun h hk ↦ h.symm <| hk.unique <| IsPrimitiveRoot.orderOf ζ⟩\n\n"}
{"name":"IsPrimitiveRoot.pow_mul_pow_lcm","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nk : Nat\nζ ζ' : M\nk' : Nat\nhζ : IsPrimitiveRoot ζ k\nhζ' : IsPrimitiveRoot ζ' k'\nhk : Ne k 0\nhk' : Ne k' 0\n⊢ IsPrimitiveRoot (HMul.hMul (HPow.hPow ζ (HDiv.hDiv k (k.factorizationLCMLeft k'))) (HPow.hPow ζ' (HDiv.hDiv k' (k.factorizationLCMRight k')))) (k.lcm k')","decl":"theorem pow_mul_pow_lcm {ζ' : M} {k' : ℕ} (hζ : IsPrimitiveRoot ζ k) (hζ' : IsPrimitiveRoot ζ' k')\n    (hk : k ≠ 0) (hk' : k' ≠ 0) :\n    IsPrimitiveRoot\n      (ζ ^ (k / Nat.factorizationLCMLeft k k') * ζ' ^ (k' / Nat.factorizationLCMRight k k'))\n      (Nat.lcm k k') := by\n  convert IsPrimitiveRoot.orderOf _\n  convert ((Commute.all ζ ζ').orderOf_mul_pow_eq_lcm\n    (by simpa [← hζ.eq_orderOf]) (by simpa [← hζ'.eq_orderOf])).symm using 2\n  all_goals simp [hζ.eq_orderOf, hζ'.eq_orderOf]\n\n"}
{"name":"IsPrimitiveRoot.pow_of_dvd","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nk : Nat\nζ : M\nh : IsPrimitiveRoot ζ k\np : Nat\nhp : Ne p 0\nhdiv : Dvd.dvd p k\n⊢ IsPrimitiveRoot (HPow.hPow ζ p) (HDiv.hDiv k p)","decl":"theorem pow_of_dvd (h : IsPrimitiveRoot ζ k) {p : ℕ} (hp : p ≠ 0) (hdiv : p ∣ k) :\n    IsPrimitiveRoot (ζ ^ p) (k / p) := by\n  rw [h.eq_orderOf] at hdiv ⊢\n  rw [← orderOf_pow_of_dvd hp hdiv]\n  exact IsPrimitiveRoot.orderOf _\n\n"}
{"name":"IsPrimitiveRoot.mem_rootsOfUnity","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nζ : Units M\nn : Nat\nh : IsPrimitiveRoot ζ n\n⊢ Membership.mem (rootsOfUnity n M) ζ","decl":"protected theorem mem_rootsOfUnity {ζ : Mˣ} {n : ℕ} (h : IsPrimitiveRoot ζ n) :\n    ζ ∈ rootsOfUnity n M :=\n  h.pow_eq_one\n\n"}
{"name":"IsPrimitiveRoot.pow","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nζ : M\nn a b : Nat\nhn : LT.lt 0 n\nh : IsPrimitiveRoot ζ n\nhprod : Eq n (HMul.hMul a b)\n⊢ IsPrimitiveRoot (HPow.hPow ζ a) b","decl":"/-- If there is an `n`-th primitive root of unity in `R` and `b` divides `n`,\nthen there is a `b`-th primitive root of unity in `R`. -/\ntheorem pow {n : ℕ} {a b : ℕ} (hn : 0 < n) (h : IsPrimitiveRoot ζ n) (hprod : n = a * b) :\n    IsPrimitiveRoot (ζ ^ a) b := by\n  subst n\n  simp only [iff_def, ← pow_mul, h.pow_eq_one, true_and]\n  intro l hl\n  exact Nat.dvd_of_mul_dvd_mul_left (Nat.pos_of_mul_pos_right hn) <| h.dvd_of_pow_eq_one _ hl\n\n"}
{"name":"IsPrimitiveRoot.injOn_pow","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nn : Nat\nζ : M\nhζ : IsPrimitiveRoot ζ n\n⊢ Set.InjOn (fun x => HPow.hPow ζ x) ↑(Finset.range n)","decl":"lemma injOn_pow {n : ℕ} {ζ : M} (hζ : IsPrimitiveRoot ζ n) :\n    Set.InjOn (ζ ^ ·) (Finset.range n) := by\n  intros i hi j hj e\n  rw [Finset.coe_range, Set.mem_Iio] at hi hj\n  exact hζ.pow_inj hi hj e\n\n"}
{"name":"IsPrimitiveRoot.map_of_injective","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\nN : Type u_2\nF : Type u_6\ninst✝³ : CommMonoid M\ninst✝² : CommMonoid N\nk : Nat\nζ : M\nf : F\ninst✝¹ : FunLike F M N\ninst✝ : MonoidHomClass F M N\nh : IsPrimitiveRoot ζ k\nhf : Function.Injective ⇑f\n⊢ IsPrimitiveRoot (f ζ) k","decl":"theorem map_of_injective [MonoidHomClass F M N] (h : IsPrimitiveRoot ζ k) (hf : Injective f) :\n    IsPrimitiveRoot (f ζ) k where\n  pow_eq_one := by rw [← map_pow, h.pow_eq_one, map_one]\n  dvd_of_pow_eq_one := by\n    rw [h.eq_orderOf]\n    intro l hl\n    rw [← map_pow, ← map_one f] at hl\n    exact orderOf_dvd_of_pow_eq_one (hf hl)\n\n"}
{"name":"IsPrimitiveRoot.of_map_of_injective","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\nN : Type u_2\nF : Type u_6\ninst✝³ : CommMonoid M\ninst✝² : CommMonoid N\nk : Nat\nζ : M\nf : F\ninst✝¹ : FunLike F M N\ninst✝ : MonoidHomClass F M N\nh : IsPrimitiveRoot (f ζ) k\nhf : Function.Injective ⇑f\n⊢ IsPrimitiveRoot ζ k","decl":"theorem of_map_of_injective [MonoidHomClass F M N] (h : IsPrimitiveRoot (f ζ) k)\n    (hf : Injective f) : IsPrimitiveRoot ζ k where\n  pow_eq_one := by apply_fun f; rw [map_pow, map_one, h.pow_eq_one]\n  dvd_of_pow_eq_one := by\n    rw [h.eq_orderOf]\n    intro l hl\n    apply_fun f at hl\n    rw [map_pow, map_one] at hl\n    exact orderOf_dvd_of_pow_eq_one hl\n\n"}
{"name":"IsPrimitiveRoot.map_iff_of_injective","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_1\nN : Type u_2\nF : Type u_6\ninst✝³ : CommMonoid M\ninst✝² : CommMonoid N\nk : Nat\nζ : M\nf : F\ninst✝¹ : FunLike F M N\ninst✝ : MonoidHomClass F M N\nhf : Function.Injective ⇑f\n⊢ Iff (IsPrimitiveRoot (f ζ) k) (IsPrimitiveRoot ζ k)","decl":"theorem map_iff_of_injective [MonoidHomClass F M N] (hf : Injective f) :\n    IsPrimitiveRoot (f ζ) k ↔ IsPrimitiveRoot ζ k :=\n  ⟨fun h => h.of_map_of_injective hf, fun h => h.map_of_injective hf⟩\n\n"}
{"name":"IsPrimitiveRoot.zero","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M₀ : Type u_7\ninst✝¹ : CommMonoidWithZero M₀\ninst✝ : Nontrivial M₀\n⊢ IsPrimitiveRoot 0 0","decl":"theorem zero [Nontrivial M₀] : IsPrimitiveRoot (0 : M₀) 0 :=\n  ⟨pow_zero 0, fun l hl ↦ by simpa [zero_pow_eq] using hl⟩\n\n"}
{"name":"IsPrimitiveRoot.ne_zero","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"k : Nat\nM₀ : Type u_7\ninst✝¹ : CommMonoidWithZero M₀\ninst✝ : Nontrivial M₀\nζ : M₀\nh : IsPrimitiveRoot ζ k\na✝ : Ne k 0\n⊢ Ne ζ 0","decl":"protected theorem ne_zero [Nontrivial M₀] {ζ : M₀} (h : IsPrimitiveRoot ζ k) : k ≠ 0 → ζ ≠ 0 :=\n  mt fun hn ↦ h.unique (hn.symm ▸ IsPrimitiveRoot.zero)\n\n"}
{"name":"IsPrimitiveRoot.injOn_pow_mul","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M₀ : Type u_7\ninst✝ : CancelCommMonoidWithZero M₀\nn : Nat\nζ : M₀\nhζ : IsPrimitiveRoot ζ n\nα : M₀\nhα : Ne α 0\n⊢ Set.InjOn (fun x => HMul.hMul (HPow.hPow ζ x) α) ↑(Finset.range n)","decl":"lemma injOn_pow_mul {n : ℕ} {ζ : M₀} (hζ : IsPrimitiveRoot ζ n) {α : M₀} (hα : α ≠ 0) :\n    Set.InjOn (ζ ^ · * α) (Finset.range n) :=\n  fun i hi j hj e ↦\n    hζ.injOn_pow hi hj (by simpa [mul_eq_mul_right_iff, or_iff_left hα] using e)\n\n"}
{"name":"IsPrimitiveRoot.zpow_eq_one","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"G : Type u_3\ninst✝ : DivisionCommMonoid G\nk : Nat\nζ : G\nh : IsPrimitiveRoot ζ k\n⊢ Eq (HPow.hPow ζ ↑k) 1","decl":"theorem zpow_eq_one (h : IsPrimitiveRoot ζ k) : ζ ^ (k : ℤ) = 1 := by\n  exact_mod_cast h.pow_eq_one\n\n"}
{"name":"IsPrimitiveRoot.zpow_eq_one_iff_dvd","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"G : Type u_3\ninst✝ : DivisionCommMonoid G\nk : Nat\nζ : G\nh : IsPrimitiveRoot ζ k\nl : Int\n⊢ Iff (Eq (HPow.hPow ζ l) 1) (Dvd.dvd (↑k) l)","decl":"theorem zpow_eq_one_iff_dvd (h : IsPrimitiveRoot ζ k) (l : ℤ) : ζ ^ l = 1 ↔ (k : ℤ) ∣ l := by\n  by_cases h0 : 0 ≤ l\n  · lift l to ℕ using h0; exact_mod_cast h.pow_eq_one_iff_dvd l\n  · have : 0 ≤ -l := (Int.neg_pos_of_neg <| Int.lt_of_not_ge h0).le\n    lift -l to ℕ using this with l' hl'\n    rw [← dvd_neg, ← hl']\n    norm_cast\n    rw [← h.pow_eq_one_iff_dvd, ← inv_inj, ← zpow_neg, ← hl', zpow_natCast, inv_one]\n\n"}
{"name":"IsPrimitiveRoot.inv","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"G : Type u_3\ninst✝ : DivisionCommMonoid G\nk : Nat\nζ : G\nh : IsPrimitiveRoot ζ k\n⊢ IsPrimitiveRoot (Inv.inv ζ) k","decl":"theorem inv (h : IsPrimitiveRoot ζ k) : IsPrimitiveRoot ζ⁻¹ k :=\n  { pow_eq_one := by simp only [h.pow_eq_one, inv_one, eq_self_iff_true, inv_pow]\n    dvd_of_pow_eq_one := by\n      intro l hl\n      apply h.dvd_of_pow_eq_one l\n      rw [← inv_inj, ← inv_pow, hl, inv_one] }\n\n"}
{"name":"IsPrimitiveRoot.inv_iff","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"G : Type u_3\ninst✝ : DivisionCommMonoid G\nk : Nat\nζ : G\n⊢ Iff (IsPrimitiveRoot (Inv.inv ζ) k) (IsPrimitiveRoot ζ k)","decl":"@[simp]\ntheorem inv_iff : IsPrimitiveRoot ζ⁻¹ k ↔ IsPrimitiveRoot ζ k :=\n  ⟨fun h ↦ inv_inv ζ ▸ inv h, fun h ↦ inv h⟩\n\n"}
{"name":"IsPrimitiveRoot.zpow_of_gcd_eq_one","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"G : Type u_3\ninst✝ : DivisionCommMonoid G\nk : Nat\nζ : G\nh : IsPrimitiveRoot ζ k\ni : Int\nhi : Eq (i.gcd ↑k) 1\n⊢ IsPrimitiveRoot (HPow.hPow ζ i) k","decl":"theorem zpow_of_gcd_eq_one (h : IsPrimitiveRoot ζ k) (i : ℤ) (hi : i.gcd k = 1) :\n    IsPrimitiveRoot (ζ ^ i) k := by\n  by_cases h0 : 0 ≤ i\n  · lift i to ℕ using h0\n    exact_mod_cast h.pow_of_coprime i hi\n  have : 0 ≤ -i := (Int.neg_pos_of_neg <| Int.lt_of_not_ge h0).le\n  lift -i to ℕ using this with i' hi'\n  rw [← inv_iff, ← zpow_neg, ← hi', zpow_natCast]\n  apply h.pow_of_coprime\n  rwa [Int.gcd, ← Int.natAbs_neg, ← hi'] at hi\n\n"}
{"name":"IsPrimitiveRoot.sub_one_ne_zero","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝ : CommRing R\nn : Nat\nζ : R\nhn : LT.lt 1 n\nhζ : IsPrimitiveRoot ζ n\n⊢ Ne (HSub.hSub ζ 1) 0","decl":"theorem sub_one_ne_zero (hn : 1 < n) (hζ : IsPrimitiveRoot ζ n) : ζ - 1 ≠ 0 :=\n  sub_ne_zero.mpr <| hζ.ne_one hn\n\n"}
{"name":"IsPrimitiveRoot.primitiveRoots_one","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ Eq (primitiveRoots 1 R) (Singleton.singleton 1)","decl":"@[simp]\ntheorem primitiveRoots_one : primitiveRoots 1 R = {(1 : R)} := by\n  refine Finset.eq_singleton_iff_unique_mem.2 ⟨?_, fun x hx ↦ ?_⟩\n  · simp only [IsPrimitiveRoot.one_right_iff, mem_primitiveRoots zero_lt_one]\n  · rwa [mem_primitiveRoots zero_lt_one, IsPrimitiveRoot.one_right_iff] at hx\n\n"}
{"name":"IsPrimitiveRoot.neZero'","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\nζ : R\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\nn : Nat\ninst✝ : NeZero n\nhζ : IsPrimitiveRoot ζ n\n⊢ NeZero ↑n","decl":"theorem neZero' {n : ℕ} [NeZero n] (hζ : IsPrimitiveRoot ζ n) : NeZero ((n : ℕ) : R) := by\n  let p := ringChar R\n  have hfin := Nat.finiteMultiplicity_iff.2 ⟨CharP.char_ne_one R p, NeZero.pos n⟩\n  obtain ⟨m, hm⟩ := hfin.exists_eq_pow_mul_and_not_dvd\n  by_cases hp : p ∣ n\n  · obtain ⟨k, hk⟩ := Nat.exists_eq_succ_of_ne_zero (multiplicity_pos_of_dvd hp).ne'\n    have : NeZero p := NeZero.of_pos (Nat.pos_of_dvd_of_pos hp (NeZero.pos n))\n    have hpri : Fact p.Prime := CharP.char_is_prime_of_pos R p\n    have := hζ.pow_eq_one\n    rw [hm.1, hk, pow_succ', mul_assoc, pow_mul', ← frobenius_def, ← frobenius_one p] at this\n    exfalso\n    have hpos : 0 < p ^ k * m :=\n      mul_pos (pow_pos hpri.1.pos _) <| Nat.pos_of_ne_zero (fun H ↦ hm.2 <| H ▸ p.dvd_zero)\n    refine hζ.pow_ne_one_of_pos_of_lt hpos ?_ (frobenius_inj R p this)\n    rw [hm.1, hk, pow_succ', mul_assoc, mul_comm p]\n    exact lt_mul_of_one_lt_right hpos hpri.1.one_lt\n  · exact NeZero.of_not_dvd R hp\n\n"}
{"name":"IsPrimitiveRoot.mem_nthRootsFinset","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\nk : Nat\nζ : R\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nhζ : IsPrimitiveRoot ζ k\nhk : LT.lt 0 k\n⊢ Membership.mem (Polynomial.nthRootsFinset k R) ζ","decl":"nonrec theorem mem_nthRootsFinset (hζ : IsPrimitiveRoot ζ k) (hk : 0 < k) :\n    ζ ∈ nthRootsFinset k R :=\n  (mem_nthRootsFinset hk).2 hζ.pow_eq_one\n\n"}
{"name":"IsPrimitiveRoot.eq_neg_one_of_two_right","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝¹ : CommRing R\ninst✝ : NoZeroDivisors R\nζ : R\nh : IsPrimitiveRoot ζ 2\n⊢ Eq ζ (-1)","decl":"theorem eq_neg_one_of_two_right [NoZeroDivisors R] {ζ : R} (h : IsPrimitiveRoot ζ 2) : ζ = -1 :=\n  (sq_eq_one_iff.mp h.pow_eq_one).resolve_left <| ne_one h one_lt_two\n\n"}
{"name":"IsPrimitiveRoot.neg_one","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝¹ : CommRing R\np : Nat\ninst✝ : Nontrivial R\nh : CharP R p\nhp : Ne p 2\n⊢ IsPrimitiveRoot (-1) 2","decl":"theorem neg_one (p : ℕ) [Nontrivial R] [h : CharP R p] (hp : p ≠ 2) :\n    IsPrimitiveRoot (-1 : R) 2 := by\n  convert IsPrimitiveRoot.orderOf (-1 : R)\n  rw [orderOf_neg_one, if_neg <| by rwa [ringChar.eq_iff.mpr h]]\n\n"}
{"name":"IsPrimitiveRoot.geom_sum_eq_zero","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\nk : Nat\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nζ : R\nhζ : IsPrimitiveRoot ζ k\nhk : LT.lt 1 k\n⊢ Eq ((Finset.range k).sum fun i => HPow.hPow ζ i) 0","decl":"/-- If `1 < k` then `(∑ i ∈ range k, ζ ^ i) = 0`. -/\ntheorem geom_sum_eq_zero [IsDomain R] {ζ : R} (hζ : IsPrimitiveRoot ζ k) (hk : 1 < k) :\n    ∑ i ∈ range k, ζ ^ i = 0 := by\n  refine eq_zero_of_ne_zero_of_mul_left_eq_zero (sub_ne_zero_of_ne (hζ.ne_one hk).symm) ?_\n  rw [mul_neg_geom_sum, hζ.pow_eq_one, sub_self]\n\n"}
{"name":"IsPrimitiveRoot.pow_sub_one_eq","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\nk : Nat\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nζ : R\nhζ : IsPrimitiveRoot ζ k\nhk : LT.lt 1 k\n⊢ Eq (HPow.hPow ζ k.pred) (Neg.neg ((Finset.range k.pred).sum fun i => HPow.hPow ζ i))","decl":"/-- If `1 < k`, then `ζ ^ k.pred = -(∑ i ∈ range k.pred, ζ ^ i)`. -/\ntheorem pow_sub_one_eq [IsDomain R] {ζ : R} (hζ : IsPrimitiveRoot ζ k) (hk : 1 < k) :\n    ζ ^ k.pred = -∑ i ∈ range k.pred, ζ ^ i := by\n  rw [eq_neg_iff_add_eq_zero, add_comm, ← sum_range_succ, ← Nat.succ_eq_add_one,\n    Nat.succ_pred_eq_of_pos (pos_of_gt hk), hζ.geom_sum_eq_zero hk]\n\n"}
{"name":"IsPrimitiveRoot.zmodEquivZPowers_apply_coe_int","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\nk : Nat\ninst✝ : CommRing R\nζ : Units R\nh : IsPrimitiveRoot ζ k\ni : Int\n⊢ Eq (h.zmodEquivZPowers ↑i) (Additive.ofMul ⟨HPow.hPow ζ i, ⋯⟩)","decl":"@[simp]\ntheorem zmodEquivZPowers_apply_coe_int (i : ℤ) :\n    h.zmodEquivZPowers i = Additive.ofMul (⟨ζ ^ i, i, rfl⟩ : Subgroup.zpowers ζ) := by\n  rw [zmodEquivZPowers, AddEquiv.ofBijective_apply] -- Porting note: Original proof didn't have `rw`\n  exact AddMonoidHom.liftOfRightInverse_comp_apply _ _ ZMod.intCast_rightInverse _ _\n\n"}
{"name":"IsPrimitiveRoot.zmodEquivZPowers_apply_coe_nat","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\nk : Nat\ninst✝ : CommRing R\nζ : Units R\nh : IsPrimitiveRoot ζ k\ni : Nat\n⊢ Eq (h.zmodEquivZPowers ↑i) (Additive.ofMul ⟨HPow.hPow ζ i, ⋯⟩)","decl":"@[simp]\ntheorem zmodEquivZPowers_apply_coe_nat (i : ℕ) :\n    h.zmodEquivZPowers i = Additive.ofMul (⟨ζ ^ i, i, rfl⟩ : Subgroup.zpowers ζ) := by\n  have : (i : ZMod k) = (i : ℤ) := by norm_cast\n  simp only [this, zmodEquivZPowers_apply_coe_int, zpow_natCast]\n\n"}
{"name":"IsPrimitiveRoot.zmodEquivZPowers_symm_apply_zpow","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\nk : Nat\ninst✝ : CommRing R\nζ : Units R\nh : IsPrimitiveRoot ζ k\ni : Int\n⊢ Eq (h.zmodEquivZPowers.symm (Additive.ofMul ⟨HPow.hPow ζ i, ⋯⟩)) ↑i","decl":"@[simp]\ntheorem zmodEquivZPowers_symm_apply_zpow (i : ℤ) :\n    h.zmodEquivZPowers.symm (Additive.ofMul (⟨ζ ^ i, i, rfl⟩ : Subgroup.zpowers ζ)) = i := by\n  rw [← h.zmodEquivZPowers.symm_apply_apply i, zmodEquivZPowers_apply_coe_int]\n\n"}
{"name":"IsPrimitiveRoot.zmodEquivZPowers_symm_apply_zpow'","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\nk : Nat\ninst✝ : CommRing R\nζ : Units R\nh : IsPrimitiveRoot ζ k\ni : Int\n⊢ Eq (h.zmodEquivZPowers.symm ⟨HPow.hPow ζ i, ⋯⟩) ↑i","decl":"@[simp]\ntheorem zmodEquivZPowers_symm_apply_zpow' (i : ℤ) : h.zmodEquivZPowers.symm ⟨ζ ^ i, i, rfl⟩ = i :=\n  h.zmodEquivZPowers_symm_apply_zpow i\n\n"}
{"name":"IsPrimitiveRoot.zmodEquivZPowers_symm_apply_pow","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\nk : Nat\ninst✝ : CommRing R\nζ : Units R\nh : IsPrimitiveRoot ζ k\ni : Nat\n⊢ Eq (h.zmodEquivZPowers.symm (Additive.ofMul ⟨HPow.hPow ζ i, ⋯⟩)) ↑i","decl":"@[simp]\ntheorem zmodEquivZPowers_symm_apply_pow (i : ℕ) :\n    h.zmodEquivZPowers.symm (Additive.ofMul (⟨ζ ^ i, i, rfl⟩ : Subgroup.zpowers ζ)) = i := by\n  rw [← h.zmodEquivZPowers.symm_apply_apply i, zmodEquivZPowers_apply_coe_nat]\n\n"}
{"name":"IsPrimitiveRoot.zmodEquivZPowers_symm_apply_pow'","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\nk : Nat\ninst✝ : CommRing R\nζ : Units R\nh : IsPrimitiveRoot ζ k\ni : Nat\n⊢ Eq (h.zmodEquivZPowers.symm ⟨HPow.hPow ζ i, ⋯⟩) ↑i","decl":"@[simp]\ntheorem zmodEquivZPowers_symm_apply_pow' (i : ℕ) : h.zmodEquivZPowers.symm ⟨ζ ^ i, i, rfl⟩ = i :=\n  h.zmodEquivZPowers_symm_apply_pow i\n\n"}
{"name":"IsPrimitiveRoot.zpowers_eq","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\nk : Nat\ninst✝ : NeZero k\nζ : Units R\nh : IsPrimitiveRoot ζ k\n⊢ Eq (Subgroup.zpowers ζ) (rootsOfUnity k R)","decl":"theorem zpowers_eq {k : ℕ} [NeZero k] {ζ : Rˣ} (h : IsPrimitiveRoot ζ k) :\n    Subgroup.zpowers ζ = rootsOfUnity k R := by\n  apply SetLike.coe_injective\n  have F : Fintype (Subgroup.zpowers ζ) := Fintype.ofEquiv _ h.zmodEquivZPowers.toEquiv\n  refine\n    @Set.eq_of_subset_of_card_le Rˣ _ _ F (rootsOfUnity.fintype R k)\n      (Subgroup.zpowers_le_of_mem <| show ζ ∈ rootsOfUnity k R from h.pow_eq_one) ?_\n  calc\n    Fintype.card (rootsOfUnity k R) ≤ k := card_rootsOfUnity R k\n    _ = Fintype.card (ZMod k) := (ZMod.card k).symm\n    _ = Fintype.card (Subgroup.zpowers ζ) := Fintype.card_congr h.zmodEquivZPowers.toEquiv\n\n"}
{"name":"IsPrimitiveRoot.map_rootsOfUnity","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : IsDomain R\nS : Type u_7\nF : Type u_8\ninst✝⁴ : CommRing S\ninst✝³ : IsDomain S\ninst✝² : FunLike F R S\ninst✝¹ : MonoidHomClass F R S\nζ : R\nn : Nat\ninst✝ : NeZero n\nhζ : IsPrimitiveRoot ζ n\nf : F\nhf : Function.Injective ⇑f\n⊢ Eq (Subgroup.map (Units.map ↑f) (rootsOfUnity n R)) (rootsOfUnity n S)","decl":"lemma map_rootsOfUnity {S F} [CommRing S] [IsDomain S] [FunLike F R S] [MonoidHomClass F R S]\n    {ζ : R} {n : ℕ} [NeZero n] (hζ : IsPrimitiveRoot ζ n) {f : F} (hf : Function.Injective f) :\n    (rootsOfUnity n R).map (Units.map f) = rootsOfUnity n S := by\n  letI : CommMonoid Sˣ := inferInstance\n  replace hζ := hζ.isUnit_unit <| NeZero.pos n\n  rw [← hζ.zpowers_eq,\n    ← (hζ.map_of_injective (Units.map_injective (f := (f : R →* S)) hf)).zpowers_eq,\n    MonoidHom.map_zpowers]\n\n"}
{"name":"val_rootsOfUnityEquivOfPrimitiveRoots_apply_coe","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : IsDomain R\nS : Type u_7\nF : Type u_8\ninst✝⁴ : CommRing S\ninst✝³ : IsDomain S\ninst✝² : FunLike F R S\ninst✝¹ : MonoidHomClass F R S\nn : Nat\ninst✝ : NeZero n\nf : F\nhf : Function.Injective ⇑f\nhζ : (primitiveRoots n R).Nonempty\na✝ : Subtype fun x => Membership.mem (rootsOfUnity n R) x\n⊢ Eq (↑↑((rootsOfUnityEquivOfPrimitiveRoots hf hζ) a✝)) (f ↑↑a✝)","decl":"/-- If `R` contains an `n`-th primitive root, and `S/R` is a ring extension,\nthen the `n`-th roots of unity in `R` and `S` are isomorphic.\nAlso see `IsPrimitiveRoot.map_rootsOfUnity` for the equality as `Subgroup Sˣ`. -/\n@[simps! (config := .lemmasOnly) apply_coe_val apply_coe_inv_val]\nnoncomputable\ndef _root_.rootsOfUnityEquivOfPrimitiveRoots {S F} [CommRing S] [IsDomain S]\n    [FunLike F R S] [MonoidHomClass F R S]\n    {n : ℕ} [NeZero n] {f : F} (hf : Function.Injective f) (hζ : (primitiveRoots n R).Nonempty) :\n    (rootsOfUnity n R) ≃* rootsOfUnity n S :=\n  (Subgroup.equivMapOfInjective _ (Units.map f) (Units.map_injective hf)).trans\n    (MulEquiv.subgroupCongr <|\n      ((mem_primitiveRoots <| NeZero.pos n).mp hζ.choose_spec).map_rootsOfUnity hf)\n\n"}
{"name":"rootsOfUnityEquivOfPrimitiveRoots_apply_coe_inv_val","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : IsDomain R\nS : Type u_7\nF : Type u_8\ninst✝⁴ : CommRing S\ninst✝³ : IsDomain S\ninst✝² : FunLike F R S\ninst✝¹ : MonoidHomClass F R S\nn : Nat\ninst✝ : NeZero n\nf : F\nhf : Function.Injective ⇑f\nhζ : (primitiveRoots n R).Nonempty\na✝ : Subtype fun x => Membership.mem (rootsOfUnity n R) x\n⊢ Eq ⋯ ⋯","decl":"/-- If `R` contains an `n`-th primitive root, and `S/R` is a ring extension,\nthen the `n`-th roots of unity in `R` and `S` are isomorphic.\nAlso see `IsPrimitiveRoot.map_rootsOfUnity` for the equality as `Subgroup Sˣ`. -/\n@[simps! (config := .lemmasOnly) apply_coe_val apply_coe_inv_val]\nnoncomputable\ndef _root_.rootsOfUnityEquivOfPrimitiveRoots {S F} [CommRing S] [IsDomain S]\n    [FunLike F R S] [MonoidHomClass F R S]\n    {n : ℕ} [NeZero n] {f : F} (hf : Function.Injective f) (hζ : (primitiveRoots n R).Nonempty) :\n    (rootsOfUnity n R) ≃* rootsOfUnity n S :=\n  (Subgroup.equivMapOfInjective _ (Units.map f) (Units.map_injective hf)).trans\n    (MulEquiv.subgroupCongr <|\n      ((mem_primitiveRoots <| NeZero.pos n).mp hζ.choose_spec).map_rootsOfUnity hf)\n\n"}
{"name":"rootsOfUnityEquivOfPrimitiveRoots_symm_apply","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : IsDomain R\nS : Type u_7\nF : Type u_8\ninst✝⁴ : CommRing S\ninst✝³ : IsDomain S\ninst✝² : FunLike F R S\ninst✝¹ : MonoidHomClass F R S\nn : Nat\ninst✝ : NeZero n\nf : F\nhf : Function.Injective ⇑f\nhζ : (primitiveRoots n R).Nonempty\nη : Subtype fun x => Membership.mem (rootsOfUnity n S) x\n⊢ Eq (f ↑↑((rootsOfUnityEquivOfPrimitiveRoots hf hζ).symm η)) ↑↑η","decl":"lemma _root_.rootsOfUnityEquivOfPrimitiveRoots_symm_apply\n    {S F} [CommRing S] [IsDomain S] [FunLike F R S] [MonoidHomClass F R S] {n : ℕ} [NeZero n]\n    {f : F} (hf : Function.Injective f) (hζ : (primitiveRoots n R).Nonempty) (η) :\n    f ((rootsOfUnityEquivOfPrimitiveRoots hf hζ).symm η : Rˣ) = (η : Sˣ) := by\n  obtain ⟨ε, rfl⟩ := (rootsOfUnityEquivOfPrimitiveRoots hf hζ).surjective η\n  rw [MulEquiv.symm_apply_apply, val_rootsOfUnityEquivOfPrimitiveRoots_apply_coe]\n\n-- Porting note: rephrased the next few lemmas to avoid `∃ (Prop)`\n"}
{"name":"IsPrimitiveRoot.eq_pow_of_mem_rootsOfUnity","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\nk : Nat\ninst✝ : NeZero k\nζ ξ : Units R\nh : IsPrimitiveRoot ζ k\nhξ : Membership.mem (rootsOfUnity k R) ξ\n⊢ Exists fun i => And (LT.lt i k) (Eq (HPow.hPow ζ i) ξ)","decl":"theorem eq_pow_of_mem_rootsOfUnity {k : ℕ} [NeZero k] {ζ ξ : Rˣ} (h : IsPrimitiveRoot ζ k)\n    (hξ : ξ ∈ rootsOfUnity k R) : ∃ i < k, ζ ^ i = ξ := by\n  obtain ⟨n, rfl⟩ : ∃ n : ℤ, ζ ^ n = ξ := by rwa [← h.zpowers_eq] at hξ\n  have hk0 : (0 : ℤ) < k := mod_cast NeZero.pos k\n  let i := n % k\n  have hi0 : 0 ≤ i := Int.emod_nonneg _ (ne_of_gt hk0)\n  lift i to ℕ using hi0 with i₀ hi₀\n  refine ⟨i₀, ?_, ?_⟩\n  · zify; rw [hi₀]; exact Int.emod_lt_of_pos _ hk0\n  · rw [← zpow_natCast, hi₀, ← Int.emod_add_ediv n k, zpow_add, zpow_mul, h.zpow_eq_one, one_zpow,\n      mul_one]\n\n"}
{"name":"IsPrimitiveRoot.eq_pow_of_pow_eq_one","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\nk : Nat\ninst✝ : NeZero k\nζ ξ : R\nh : IsPrimitiveRoot ζ k\nhξ : Eq (HPow.hPow ξ k) 1\n⊢ Exists fun i => And (LT.lt i k) (Eq (HPow.hPow ζ i) ξ)","decl":"theorem eq_pow_of_pow_eq_one {k : ℕ} [NeZero k] {ζ ξ : R} (h : IsPrimitiveRoot ζ k)\n    (hξ : ξ ^ k = 1) :\n    ∃ i < k, ζ ^ i = ξ := by\n  lift ζ to Rˣ using h.isUnit <| NeZero.pos k\n  lift ξ to Rˣ using isUnit_ofPowEqOne hξ <| NeZero.ne k\n  simp only [← Units.val_pow_eq_pow_val, ← Units.ext_iff]\n  rw [coe_units_iff] at h\n  exact h.eq_pow_of_mem_rootsOfUnity <| (mem_rootsOfUnity' k ξ).mpr hξ\n\n"}
{"name":"IsPrimitiveRoot.isPrimitiveRoot_iff'","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\nk : Nat\ninst✝ : NeZero k\nζ ξ : Units R\nh : IsPrimitiveRoot ζ k\n⊢ Iff (IsPrimitiveRoot ξ k) (Exists fun i => And (LT.lt i k) (And (i.Coprime k) (Eq (HPow.hPow ζ i) ξ)))","decl":"theorem isPrimitiveRoot_iff' {k : ℕ} [NeZero k] {ζ ξ : Rˣ} (h : IsPrimitiveRoot ζ k) :\n    IsPrimitiveRoot ξ k ↔ ∃ i < k, i.Coprime k ∧ ζ ^ i = ξ := by\n  constructor\n  · intro hξ\n    obtain ⟨i, hik, rfl⟩ := h.eq_pow_of_mem_rootsOfUnity hξ.pow_eq_one\n    rw [h.pow_iff_coprime <| NeZero.pos k] at hξ\n    exact ⟨i, hik, hξ, rfl⟩\n  · rintro ⟨i, -, hi, rfl⟩; exact h.pow_of_coprime i hi\n\n"}
{"name":"IsPrimitiveRoot.isPrimitiveRoot_iff","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\nk : Nat\ninst✝ : NeZero k\nζ ξ : R\nh : IsPrimitiveRoot ζ k\n⊢ Iff (IsPrimitiveRoot ξ k) (Exists fun i => And (LT.lt i k) (And (i.Coprime k) (Eq (HPow.hPow ζ i) ξ)))","decl":"theorem isPrimitiveRoot_iff {k : ℕ} [NeZero k] {ζ ξ : R} (h : IsPrimitiveRoot ζ k) :\n    IsPrimitiveRoot ξ k ↔ ∃ i < k, i.Coprime k ∧ ζ ^ i = ξ := by\n  constructor\n  · intro hξ\n    obtain ⟨i, hik, rfl⟩ := h.eq_pow_of_pow_eq_one hξ.pow_eq_one\n    rw [h.pow_iff_coprime <| NeZero.pos k] at hξ\n    exact ⟨i, hik, hξ, rfl⟩\n  · rintro ⟨i, -, hi, rfl⟩; exact h.pow_of_coprime i hi\n\n"}
{"name":"IsPrimitiveRoot.nthRoots_eq","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nn : Nat\nζ : R\nhζ : IsPrimitiveRoot ζ n\nα a : R\ne : Eq (HPow.hPow α n) a\n⊢ Eq (Polynomial.nthRoots n a) (Multiset.map (fun x => HMul.hMul (HPow.hPow ζ x) α) (Multiset.range n))","decl":"theorem nthRoots_eq {n : ℕ} {ζ : R} (hζ : IsPrimitiveRoot ζ n) {α a : R} (e : α ^ n = a) :\n    nthRoots n a = (Multiset.range n).map (ζ ^ · * α) := by\n  obtain (rfl | hn) := n.eq_zero_or_pos; · simp\n  by_cases hα : α = 0\n  · rw [hα, zero_pow hn.ne'] at e\n    simp only [hα, e.symm, nthRoots_zero_right, mul_zero,\n      Finset.range_val, Multiset.map_const', Multiset.card_range]\n  classical\n  symm; apply Multiset.eq_of_le_of_card_le\n  · rw [← Finset.range_val,\n      ← Finset.image_val_of_injOn (hζ.injOn_pow_mul hα), Finset.val_le_iff_val_subset]\n    intro x hx\n    simp only [Finset.image_val, Finset.range_val, Multiset.mem_dedup, Multiset.mem_map,\n      Multiset.mem_range] at hx\n    obtain ⟨m, _, rfl⟩ := hx\n    rw [mem_nthRoots hn, mul_pow, e, ← pow_mul, mul_comm m,\n      pow_mul, hζ.pow_eq_one, one_pow, one_mul]\n  · simpa only [Multiset.card_map, Multiset.card_range] using card_nthRoots n a\n\n"}
{"name":"IsPrimitiveRoot.card_nthRoots","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nn : Nat\nζ : R\nhζ : IsPrimitiveRoot ζ n\na : R\n⊢ Eq (Polynomial.nthRoots n a).card (ite (Exists fun α => Eq (HPow.hPow α n) a) n 0)","decl":"open scoped Classical in\ntheorem card_nthRoots {n : ℕ} {ζ : R} (hζ : IsPrimitiveRoot ζ n) (a : R) :\n    Multiset.card (nthRoots n a) = if ∃ α, α ^ n = a then n else 0 := by\n  split_ifs with h\n  · obtain ⟨α, hα⟩ := h\n    rw [nthRoots_eq hζ hα, Multiset.card_map, Multiset.card_range]\n  · obtain (rfl|hn) := n.eq_zero_or_pos; · simp\n    push_neg at h\n    simpa only [Multiset.card_eq_zero, Multiset.eq_zero_iff_forall_not_mem, mem_nthRoots hn]\n\n"}
{"name":"IsPrimitiveRoot.card_rootsOfUnity'","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝² : CommRing R\nζ : Units R\ninst✝¹ : IsDomain R\nn : Nat\ninst✝ : NeZero n\nh : IsPrimitiveRoot ζ n\n⊢ Eq (Fintype.card (Subtype fun x => Membership.mem (rootsOfUnity n R) x)) n","decl":"/-- A variant of `IsPrimitiveRoot.card_rootsOfUnity` for `ζ : Rˣ`. -/\ntheorem card_rootsOfUnity' {n : ℕ} [NeZero n] (h : IsPrimitiveRoot ζ n) :\n    Fintype.card (rootsOfUnity n R) = n := by\n  let e := h.zmodEquivZPowers\n  have : Fintype (Subgroup.zpowers ζ) := Fintype.ofEquiv _ e.toEquiv\n  calc\n    Fintype.card (rootsOfUnity n R) = Fintype.card (Subgroup.zpowers ζ) :=\n      Fintype.card_congr <| by rw [h.zpowers_eq]\n    _ = Fintype.card (ZMod n) := Fintype.card_congr e.toEquiv.symm\n    _ = n := ZMod.card n\n\n"}
{"name":"IsPrimitiveRoot.card_rootsOfUnity","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\nζ : R\nn : Nat\ninst✝ : NeZero n\nh : IsPrimitiveRoot ζ n\n⊢ Eq (Fintype.card (Subtype fun x => Membership.mem (rootsOfUnity n R) x)) n","decl":"theorem card_rootsOfUnity {ζ : R} {n : ℕ} [NeZero n] (h : IsPrimitiveRoot ζ n) :\n    Fintype.card (rootsOfUnity n R) = n := by\n  obtain ⟨ζ, hζ⟩ := h.isUnit <| NeZero.pos n\n  rw [← hζ, IsPrimitiveRoot.coe_units_iff] at h\n  exact h.card_rootsOfUnity'\n\n"}
{"name":"IsPrimitiveRoot.card_nthRoots_one","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nζ : R\nn : Nat\nh : IsPrimitiveRoot ζ n\n⊢ Eq (Polynomial.nthRoots n 1).card n","decl":"/-- The cardinality of the multiset `nthRoots ↑n (1 : R)` is `n`\nif there is a primitive root of unity in `R`. -/\ntheorem card_nthRoots_one {ζ : R} {n : ℕ} (h : IsPrimitiveRoot ζ n) :\n    Multiset.card (nthRoots n (1 : R)) = n := by\n  rw [card_nthRoots h, if_pos ⟨ζ, h.pow_eq_one⟩]\n\n"}
{"name":"IsPrimitiveRoot.nthRoots_nodup","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nζ : R\nn : Nat\nh : IsPrimitiveRoot ζ n\na : R\nha : Ne a 0\n⊢ (Polynomial.nthRoots n a).Nodup","decl":"theorem nthRoots_nodup {ζ : R} {n : ℕ} (h : IsPrimitiveRoot ζ n) {a : R} (ha : a ≠ 0) :\n    (nthRoots n a).Nodup := by\n  obtain (rfl | hn) := n.eq_zero_or_pos; · simp\n  by_cases h : ∃ α, α ^ n = a\n  · obtain ⟨α, hα⟩ := h\n    by_cases hα' : α = 0\n    · exact (ha (by rwa [hα', zero_pow hn.ne', eq_comm] at hα)).elim\n    rw [nthRoots_eq h hα, Multiset.nodup_map_iff_inj_on (Multiset.nodup_range n)]\n    exact h.injOn_pow_mul hα'\n  · suffices nthRoots n a = 0 by simp [this]\n    push_neg at h\n    simpa only [Multiset.card_eq_zero, Multiset.eq_zero_iff_forall_not_mem, mem_nthRoots hn]\n\n"}
{"name":"IsPrimitiveRoot.nthRoots_one_nodup","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nζ : R\nn : Nat\nh : IsPrimitiveRoot ζ n\n⊢ (Polynomial.nthRoots n 1).Nodup","decl":"/-- The multiset `nthRoots ↑n (1 : R)` has no repeated elements\nif there is a primitive root of unity in `R`. -/\ntheorem nthRoots_one_nodup {ζ : R} {n : ℕ} (h : IsPrimitiveRoot ζ n) :\n    (nthRoots n (1 : R)).Nodup :=\n  h.nthRoots_nodup one_ne_zero\n\n"}
{"name":"IsPrimitiveRoot.card_nthRootsFinset","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nζ : R\nn : Nat\nh : IsPrimitiveRoot ζ n\n⊢ Eq (Polynomial.nthRootsFinset n R).card n","decl":"@[simp]\ntheorem card_nthRootsFinset {ζ : R} {n : ℕ} (h : IsPrimitiveRoot ζ n) :\n    #(nthRootsFinset n R) = n := by\n  classical\n  rw [nthRootsFinset, ← Multiset.toFinset_eq (nthRoots_one_nodup h), card_mk, h.card_nthRoots_one]\n\n"}
{"name":"IsPrimitiveRoot.card_primitiveRoots","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nζ : R\nk : Nat\nh : IsPrimitiveRoot ζ k\n⊢ Eq (primitiveRoots k R).card k.totient","decl":"/-- If an integral domain has a primitive `k`-th root of unity, then it has `φ k` of them. -/\ntheorem card_primitiveRoots {ζ : R} {k : ℕ} (h : IsPrimitiveRoot ζ k) :\n    #(primitiveRoots k R) = φ k := by\n  by_cases h0 : k = 0\n  · simp [h0]\n  have : NeZero k := ⟨h0⟩\n  symm\n  refine Finset.card_bij (fun i _ ↦ ζ ^ i) ?_ ?_ ?_\n  · simp only [and_imp, mem_filter, mem_range, mem_univ]\n    rintro i - hi\n    rw [mem_primitiveRoots (Nat.pos_of_ne_zero h0)]\n    exact h.pow_of_coprime i hi.symm\n  · simp only [and_imp, mem_filter, mem_range, mem_univ]\n    rintro i hi - j hj - H\n    exact h.pow_inj hi hj H\n  · simp only [exists_prop, mem_filter, mem_range, mem_univ]\n    intro ξ hξ\n    rw [mem_primitiveRoots (Nat.pos_of_ne_zero h0), h.isPrimitiveRoot_iff] at hξ\n    rcases hξ with ⟨i, hin, hi, H⟩\n    exact ⟨i, ⟨hin, hi.symm⟩, H⟩\n\n"}
{"name":"IsPrimitiveRoot.disjoint","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nk l : Nat\nh : Ne k l\n⊢ Disjoint (primitiveRoots k R) (primitiveRoots l R)","decl":"/-- The sets `primitiveRoots k R` are pairwise disjoint. -/\ntheorem disjoint {k l : ℕ} (h : k ≠ l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=\n  Finset.disjoint_left.2 fun _ hk hl ↦\n    h <|\n      (isPrimitiveRoot_of_mem_primitiveRoots hk).unique <| isPrimitiveRoot_of_mem_primitiveRoots hl\n\n"}
{"name":"IsPrimitiveRoot.nthRoots_one_eq_biUnion_primitiveRoots","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nζ : R\nn : Nat\nh : IsPrimitiveRoot ζ n\n⊢ Eq (Polynomial.nthRootsFinset n R) (n.divisors.biUnion fun i => primitiveRoots i R)","decl":"open scoped Classical in\n/-- `nthRoots n` as a `Finset` is equal to the union of `primitiveRoots i R` for `i ∣ n`\nif there is a primitive `n`th root of unity in `R`. -/\ntheorem nthRoots_one_eq_biUnion_primitiveRoots {ζ : R} {n : ℕ}\n    (h : IsPrimitiveRoot ζ n) :\n    nthRootsFinset n R = (Nat.divisors n).biUnion fun i ↦ primitiveRoots i R := by\n  by_cases hn : n = 0\n  · simp only [hn, nthRootsFinset_zero, Nat.divisors_zero, biUnion_empty]\n  have : NeZero n := ⟨hn⟩\n  exact nthRoots_one_eq_biUnion_primitiveRoots' h\n\n"}
{"name":"IsPrimitiveRoot.coe_autToPow_apply","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝⁴ : CommRing S\ninst✝³ : IsDomain S\nμ : S\nn : Nat\nhμ : IsPrimitiveRoot μ n\ninst✝² : CommRing R\ninst✝¹ : Algebra R S\ninst✝ : NeZero n\nf : AlgEquiv R S S\n⊢ Eq ↑((IsPrimitiveRoot.autToPow R hμ) f) ↑⋯.choose","decl":"theorem coe_autToPow_apply [NeZero n] (f : S ≃ₐ[R] S) :\n    (autToPow R hμ f : ZMod n) =\n      ((map_rootsOfUnity_eq_pow_self f hμ.toRootsOfUnity).choose : ZMod n) :=\n  rfl\n\n"}
{"name":"IsPrimitiveRoot.autToPow_spec","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝⁴ : CommRing S\ninst✝³ : IsDomain S\nμ : S\nn : Nat\nhμ : IsPrimitiveRoot μ n\ninst✝² : CommRing R\ninst✝¹ : Algebra R S\ninst✝ : NeZero n\nf : AlgEquiv R S S\n⊢ Eq (HPow.hPow μ (↑((IsPrimitiveRoot.autToPow R hμ) f)).val) (f μ)","decl":"@[simp]\ntheorem autToPow_spec [NeZero n] (f : S ≃ₐ[R] S) : μ ^ (hμ.autToPow R f : ZMod n).val = f μ := by\n  rw [IsPrimitiveRoot.coe_autToPow_apply]\n  generalize_proofs h\n  refine (?_ : ((hμ.toRootsOfUnity : Sˣ) : S) ^ _ = _).trans h.choose_spec.symm\n  rw [← rootsOfUnity.coe_pow, ← rootsOfUnity.coe_pow]\n  congr 2\n  rw [pow_eq_pow_iff_modEq, ZMod.val_natCast]\n  conv => enter [2, 2]; rw [hμ.eq_orderOf]\n  rw [← Subgroup.orderOf_coe, ← orderOf_units]\n  exact Nat.mod_modEq _ _\n\n"}
{"name":"IsCyclic.exists_apply_ne_one","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"G : Type u_7\nG' : Type u_8\ninst✝³ : CommGroup G\ninst✝² : IsCyclic G\ninst✝¹ : Finite G\ninst✝ : CommGroup G'\nhG' : Exists fun ζ => IsPrimitiveRoot ζ (Nat.card G)\na : G\nha : Ne a 1\n⊢ Exists fun φ => Ne (φ a) 1","decl":"/-- If `G` is cyclic of order `n` and `G'` contains a primitive `n`th root of unity,\nthen for each `a : G` with `a ≠ 1` there is a homomorphism `φ : G →* G'` such that `φ a ≠ 1`. -/\nlemma IsCyclic.exists_apply_ne_one {G G' : Type*} [CommGroup G] [IsCyclic G] [Finite G]\n    [CommGroup G'] (hG' : ∃ ζ : G', IsPrimitiveRoot ζ (Nat.card G)) ⦃a : G⦄ (ha : a ≠ 1) :\n    ∃ φ : G →* G', φ a ≠ 1 := by\n  let inst : Fintype G := Fintype.ofFinite _\n  obtain ⟨ζ, hζ⟩ := hG'\n  -- pick a generator `g` of `G`\n  obtain ⟨g, hg⟩ := IsCyclic.exists_generator (α := G)\n  have hζg : orderOf ζ ∣ orderOf g := by\n    rw [← hζ.eq_orderOf, orderOf_eq_card_of_forall_mem_zpowers hg, Nat.card_eq_fintype_card]\n  -- use the homomorphism `φ` given by `g ↦ ζ`\n  let φ := monoidHomOfForallMemZpowers hg hζg\n  have hφg : IsPrimitiveRoot (φ g) (Nat.card G) := by\n    rwa [monoidHomOfForallMemZpowers_apply_gen hg hζg]\n  use φ\n  contrapose! ha\n  specialize hg a\n  rw [← mem_powers_iff_mem_zpowers, Submonoid.mem_powers_iff] at hg\n  obtain ⟨k, hk⟩ := hg\n  rw [← hk, map_pow] at ha\n  obtain ⟨l, rfl⟩ := (hφg.pow_eq_one_iff_dvd k).mp ha\n  rw [← hk, pow_mul, Nat.card_eq_fintype_card, pow_card_eq_one, one_pow]\n\n"}
{"name":"ZMod.exists_monoidHom_apply_ne_one","module":"Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots","initialProofState":"M : Type u_7\ninst✝¹ : CommMonoid M\nn : Nat\ninst✝ : NeZero n\nhG : Exists fun ζ => IsPrimitiveRoot ζ n\na : ZMod n\nha : Ne a 0\n⊢ Exists fun φ => Ne (φ (Multiplicative.ofAdd a)) 1","decl":"/-- If `M` is a commutative group that contains a primitive `n`th root of unity\nand `a : ZMod n` is nonzero, then there exists a group homomorphism `φ` from the\nadditive group `ZMod n` to the multiplicative group `Mˣ` such that `φ a ≠ 1`. -/\nlemma ZMod.exists_monoidHom_apply_ne_one {M : Type*} [CommMonoid M] {n : ℕ} [NeZero n]\n    (hG : ∃ ζ : M, IsPrimitiveRoot ζ n) {a : ZMod n} (ha : a ≠ 0) :\n    ∃ φ : Multiplicative (ZMod n) →* Mˣ, φ (Multiplicative.ofAdd a) ≠ 1 := by\n  obtain ⟨ζ, hζ⟩ := hG\n  have hc : n = Nat.card (Multiplicative (ZMod n)) := by\n    simp only [Nat.card_eq_fintype_card, Fintype.card_multiplicative, card]\n  exact IsCyclic.exists_apply_ne_one\n    (hc ▸ ⟨hζ.toRootsOfUnity.val, IsPrimitiveRoot.coe_units_iff.mp hζ⟩) <|\n    by simp only [ne_eq, ofAdd_eq_one, ha, not_false_eq_true]\n\n"}
