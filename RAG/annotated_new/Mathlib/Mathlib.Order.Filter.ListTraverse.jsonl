{"name":"Filter.sequence_mono","module":"Mathlib.Order.Filter.ListTraverse","initialProofState":"α : Type u\nas bs : List (Filter α)\na✝ : List.Forall₂ (fun x1 x2 => LE.le x1 x2) as bs\n⊢ LE.le (sequence as) (sequence bs)","decl":"theorem sequence_mono : ∀ as bs : List (Filter α), Forall₂ (· ≤ ·) as bs → sequence as ≤ sequence bs\n  | [], [], Forall₂.nil => le_rfl\n  | _::as, _::bs, Forall₂.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n\n"}
{"name":"Filter.mem_traverse","module":"Mathlib.Order.Filter.ListTraverse","initialProofState":"α β γ : Type u\nf : β → Filter α\ns : γ → Set α\nfs : List β\nus : List γ\na✝ : List.Forall₂ (fun b c => Membership.mem (f b) (s c)) fs us\n⊢ Membership.mem (Traversable.traverse f fs) (Traversable.traverse s us)","decl":"theorem mem_traverse :\n    ∀ (fs : List β) (us : List γ),\n      Forall₂ (fun b c => s c ∈ f b) fs us → traverse s us ∈ traverse f fs\n  | [], [], Forall₂.nil => mem_pure.2 <| mem_singleton _\n  | _::fs, _::us, Forall₂.cons h hs => seq_mem_seq (image_mem_map h) (mem_traverse fs us hs)\n\n-- TODO: add a `Filter.HasBasis` statement\n"}
{"name":"Filter.mem_traverse_iff","module":"Mathlib.Order.Filter.ListTraverse","initialProofState":"α β : Type u\nf : β → Filter α\nfs : List β\nt : Set (List α)\n⊢ Iff (Membership.mem (Traversable.traverse f fs) t) (Exists fun us => And (List.Forall₂ (fun b s => Membership.mem (f b) s) fs us) (HasSubset.Subset (sequence us) t))","decl":"theorem mem_traverse_iff (fs : List β) (t : Set (List α)) :\n    t ∈ traverse f fs ↔\n      ∃ us : List (Set α), Forall₂ (fun b (s : Set α) => s ∈ f b) fs us ∧ sequence us ⊆ t := by\n  constructor\n  · induction fs generalizing t with\n    | nil =>\n      simp only [sequence, mem_pure, imp_self, forall₂_nil_left_iff, exists_eq_left, Set.pure_def,\n        singleton_subset_iff, traverse_nil]\n    | cons b fs ih =>\n      intro ht\n      rcases mem_seq_iff.1 ht with ⟨u, hu, v, hv, ht⟩\n      rcases mem_map_iff_exists_image.1 hu with ⟨w, hw, hwu⟩\n      rcases ih v hv with ⟨us, hus, hu⟩\n      exact ⟨w::us, Forall₂.cons hw hus, (Set.seq_mono hwu hu).trans ht⟩\n  · rintro ⟨us, hus, hs⟩\n    exact mem_of_superset (mem_traverse _ _ hus) hs\n\n"}
