{"name":"MeasureTheory.JordanDecomposition.ext","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_2\ninst✝ : MeasurableSpace α\nx y : MeasureTheory.JordanDecomposition α\nposPart : Eq x.posPart y.posPart\nnegPart : Eq x.negPart y.negPart\n⊢ Eq x y","decl":"/-- A Jordan decomposition of a measurable space is a pair of mutually singular,\nfinite measures. -/\n@[ext]\nstructure JordanDecomposition (α : Type*) [MeasurableSpace α] where\n  (posPart negPart : Measure α)\n  [posPart_finite : IsFiniteMeasure posPart]\n  [negPart_finite : IsFiniteMeasure negPart]\n  mutuallySingular : posPart ⟂ₘ negPart\n\n"}
{"name":"MeasureTheory.JordanDecomposition.mutuallySingular","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_2\ninst✝ : MeasurableSpace α\nself : MeasureTheory.JordanDecomposition α\n⊢ self.posPart.MutuallySingular self.negPart","decl":"/-- A Jordan decomposition of a measurable space is a pair of mutually singular,\nfinite measures. -/\n@[ext]\nstructure JordanDecomposition (α : Type*) [MeasurableSpace α] where\n  (posPart negPart : Measure α)\n  [posPart_finite : IsFiniteMeasure posPart]\n  [negPart_finite : IsFiniteMeasure negPart]\n  mutuallySingular : posPart ⟂ₘ negPart\n\n"}
{"name":"MeasureTheory.JordanDecomposition.mk.injEq","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_2\ninst✝ : MeasurableSpace α\nposPart✝ negPart✝ : MeasureTheory.Measure α\nposPart_finite✝ : MeasureTheory.IsFiniteMeasure posPart✝\nnegPart_finite✝ : MeasureTheory.IsFiniteMeasure negPart✝\nmutuallySingular✝ : posPart✝.MutuallySingular negPart✝\nposPart negPart : MeasureTheory.Measure α\nposPart_finite : MeasureTheory.IsFiniteMeasure posPart\nnegPart_finite : MeasureTheory.IsFiniteMeasure negPart\nmutuallySingular : posPart.MutuallySingular negPart\n⊢ Eq (Eq (MeasureTheory.JordanDecomposition.mk posPart✝ negPart✝ mutuallySingular✝) (MeasureTheory.JordanDecomposition.mk posPart negPart mutuallySingular)) (And (Eq posPart✝ posPart) (Eq negPart✝ negPart))","decl":"/-- A Jordan decomposition of a measurable space is a pair of mutually singular,\nfinite measures. -/\n@[ext]\nstructure JordanDecomposition (α : Type*) [MeasurableSpace α] where\n  (posPart negPart : Measure α)\n  [posPart_finite : IsFiniteMeasure posPart]\n  [negPart_finite : IsFiniteMeasure negPart]\n  mutuallySingular : posPart ⟂ₘ negPart\n\n"}
{"name":"MeasureTheory.JordanDecomposition.mk.sizeOf_spec","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : SizeOf α\nposPart negPart : MeasureTheory.Measure α\nposPart_finite : MeasureTheory.IsFiniteMeasure posPart\nnegPart_finite : MeasureTheory.IsFiniteMeasure negPart\nmutuallySingular : posPart.MutuallySingular negPart\n⊢ Eq (SizeOf.sizeOf (MeasureTheory.JordanDecomposition.mk posPart negPart mutuallySingular)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf posPart)) (SizeOf.sizeOf negPart)) (SizeOf.sizeOf posPart_finite)) (SizeOf.sizeOf negPart_finite)) (SizeOf.sizeOf mutuallySingular))","decl":"/-- A Jordan decomposition of a measurable space is a pair of mutually singular,\nfinite measures. -/\n@[ext]\nstructure JordanDecomposition (α : Type*) [MeasurableSpace α] where\n  (posPart negPart : Measure α)\n  [posPart_finite : IsFiniteMeasure posPart]\n  [negPart_finite : IsFiniteMeasure negPart]\n  mutuallySingular : posPart ⟂ₘ negPart\n\n"}
{"name":"MeasureTheory.JordanDecomposition.mk.inj","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_2\ninst✝ : MeasurableSpace α\nposPart✝ negPart✝ : MeasureTheory.Measure α\nposPart_finite✝ : MeasureTheory.IsFiniteMeasure posPart✝\nnegPart_finite✝ : MeasureTheory.IsFiniteMeasure negPart✝\nmutuallySingular✝ : posPart✝.MutuallySingular negPart✝\nposPart negPart : MeasureTheory.Measure α\nposPart_finite : MeasureTheory.IsFiniteMeasure posPart\nnegPart_finite : MeasureTheory.IsFiniteMeasure negPart\nmutuallySingular : posPart.MutuallySingular negPart\nx✝ : Eq (MeasureTheory.JordanDecomposition.mk posPart✝ negPart✝ mutuallySingular✝) (MeasureTheory.JordanDecomposition.mk posPart negPart mutuallySingular)\n⊢ And (Eq posPart✝ posPart) (Eq negPart✝ negPart)","decl":"/-- A Jordan decomposition of a measurable space is a pair of mutually singular,\nfinite measures. -/\n@[ext]\nstructure JordanDecomposition (α : Type*) [MeasurableSpace α] where\n  (posPart negPart : Measure α)\n  [posPart_finite : IsFiniteMeasure posPart]\n  [negPart_finite : IsFiniteMeasure negPart]\n  mutuallySingular : posPart ⟂ₘ negPart\n\n"}
{"name":"MeasureTheory.JordanDecomposition.negPart_finite","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_2\ninst✝ : MeasurableSpace α\nself : MeasureTheory.JordanDecomposition α\n⊢ MeasureTheory.IsFiniteMeasure self.negPart","decl":"/-- A Jordan decomposition of a measurable space is a pair of mutually singular,\nfinite measures. -/\n@[ext]\nstructure JordanDecomposition (α : Type*) [MeasurableSpace α] where\n  (posPart negPart : Measure α)\n  [posPart_finite : IsFiniteMeasure posPart]\n  [negPart_finite : IsFiniteMeasure negPart]\n  mutuallySingular : posPart ⟂ₘ negPart\n\n"}
{"name":"MeasureTheory.JordanDecomposition.ext_iff","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_2\ninst✝ : MeasurableSpace α\nx y : MeasureTheory.JordanDecomposition α\n⊢ Iff (Eq x y) (And (Eq x.posPart y.posPart) (Eq x.negPart y.negPart))","decl":"/-- A Jordan decomposition of a measurable space is a pair of mutually singular,\nfinite measures. -/\n@[ext]\nstructure JordanDecomposition (α : Type*) [MeasurableSpace α] where\n  (posPart negPart : Measure α)\n  [posPart_finite : IsFiniteMeasure posPart]\n  [negPart_finite : IsFiniteMeasure negPart]\n  mutuallySingular : posPart ⟂ₘ negPart\n\n"}
{"name":"MeasureTheory.JordanDecomposition.posPart_finite","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_2\ninst✝ : MeasurableSpace α\nself : MeasureTheory.JordanDecomposition α\n⊢ MeasureTheory.IsFiniteMeasure self.posPart","decl":"/-- A Jordan decomposition of a measurable space is a pair of mutually singular,\nfinite measures. -/\n@[ext]\nstructure JordanDecomposition (α : Type*) [MeasurableSpace α] where\n  (posPart negPart : Measure α)\n  [posPart_finite : IsFiniteMeasure posPart]\n  [negPart_finite : IsFiniteMeasure negPart]\n  mutuallySingular : posPart ⟂ₘ negPart\n\n"}
{"name":"MeasureTheory.JordanDecomposition.zero_posPart","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Eq (MeasureTheory.JordanDecomposition.posPart 0) 0","decl":"@[simp]\ntheorem zero_posPart : (0 : JordanDecomposition α).posPart = 0 :=\n  rfl\n\n"}
{"name":"MeasureTheory.JordanDecomposition.zero_negPart","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Eq (MeasureTheory.JordanDecomposition.negPart 0) 0","decl":"@[simp]\ntheorem zero_negPart : (0 : JordanDecomposition α).negPart = 0 :=\n  rfl\n\n"}
{"name":"MeasureTheory.JordanDecomposition.neg_posPart","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nj : MeasureTheory.JordanDecomposition α\n⊢ Eq (Neg.neg j).posPart j.negPart","decl":"@[simp]\ntheorem neg_posPart : (-j).posPart = j.negPart :=\n  rfl\n\n"}
{"name":"MeasureTheory.JordanDecomposition.neg_negPart","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nj : MeasureTheory.JordanDecomposition α\n⊢ Eq (Neg.neg j).negPart j.posPart","decl":"@[simp]\ntheorem neg_negPart : (-j).negPart = j.posPart :=\n  rfl\n\n"}
{"name":"MeasureTheory.JordanDecomposition.smul_posPart","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nj : MeasureTheory.JordanDecomposition α\nr : NNReal\n⊢ Eq (HSMul.hSMul r j).posPart (HSMul.hSMul r j.posPart)","decl":"@[simp]\ntheorem smul_posPart (r : ℝ≥0) : (r • j).posPart = r • j.posPart :=\n  rfl\n\n"}
{"name":"MeasureTheory.JordanDecomposition.smul_negPart","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nj : MeasureTheory.JordanDecomposition α\nr : NNReal\n⊢ Eq (HSMul.hSMul r j).negPart (HSMul.hSMul r j.negPart)","decl":"@[simp]\ntheorem smul_negPart (r : ℝ≥0) : (r • j).negPart = r • j.negPart :=\n  rfl\n\n"}
{"name":"MeasureTheory.JordanDecomposition.real_smul_def","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nr : Real\nj : MeasureTheory.JordanDecomposition α\n⊢ Eq (HSMul.hSMul r j) (ite (LE.le 0 r) (HSMul.hSMul r.toNNReal j) (Neg.neg (HSMul.hSMul (Neg.neg r).toNNReal j)))","decl":"theorem real_smul_def (r : ℝ) (j : JordanDecomposition α) :\n    r • j = if 0 ≤ r then r.toNNReal • j else -((-r).toNNReal • j) :=\n  rfl\n\n"}
{"name":"MeasureTheory.JordanDecomposition.coe_smul","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nj : MeasureTheory.JordanDecomposition α\nr : NNReal\n⊢ Eq (HSMul.hSMul (↑r) j) (HSMul.hSMul r j)","decl":"@[simp]\ntheorem coe_smul (r : ℝ≥0) : (r : ℝ) • j = r • j := by\n  -- Porting note: replaced `show`\n  rw [real_smul_def, if_pos (NNReal.coe_nonneg r), Real.toNNReal_coe]\n\n"}
{"name":"MeasureTheory.JordanDecomposition.real_smul_nonneg","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nj : MeasureTheory.JordanDecomposition α\nr : Real\nhr : LE.le 0 r\n⊢ Eq (HSMul.hSMul r j) (HSMul.hSMul r.toNNReal j)","decl":"theorem real_smul_nonneg (r : ℝ) (hr : 0 ≤ r) : r • j = r.toNNReal • j :=\n  dif_pos hr\n\n"}
{"name":"MeasureTheory.JordanDecomposition.real_smul_neg","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nj : MeasureTheory.JordanDecomposition α\nr : Real\nhr : LT.lt r 0\n⊢ Eq (HSMul.hSMul r j) (Neg.neg (HSMul.hSMul (Neg.neg r).toNNReal j))","decl":"theorem real_smul_neg (r : ℝ) (hr : r < 0) : r • j = -((-r).toNNReal • j) :=\n  dif_neg (not_le.2 hr)\n\n"}
{"name":"MeasureTheory.JordanDecomposition.real_smul_posPart_nonneg","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nj : MeasureTheory.JordanDecomposition α\nr : Real\nhr : LE.le 0 r\n⊢ Eq (HSMul.hSMul r j).posPart (HSMul.hSMul r.toNNReal j.posPart)","decl":"theorem real_smul_posPart_nonneg (r : ℝ) (hr : 0 ≤ r) :\n    (r • j).posPart = r.toNNReal • j.posPart := by\n  rw [real_smul_def, ← smul_posPart, if_pos hr]\n\n"}
{"name":"MeasureTheory.JordanDecomposition.real_smul_negPart_nonneg","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nj : MeasureTheory.JordanDecomposition α\nr : Real\nhr : LE.le 0 r\n⊢ Eq (HSMul.hSMul r j).negPart (HSMul.hSMul r.toNNReal j.negPart)","decl":"theorem real_smul_negPart_nonneg (r : ℝ) (hr : 0 ≤ r) :\n    (r • j).negPart = r.toNNReal • j.negPart := by\n  rw [real_smul_def, ← smul_negPart, if_pos hr]\n\n"}
{"name":"MeasureTheory.JordanDecomposition.real_smul_posPart_neg","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nj : MeasureTheory.JordanDecomposition α\nr : Real\nhr : LT.lt r 0\n⊢ Eq (HSMul.hSMul r j).posPart (HSMul.hSMul (Neg.neg r).toNNReal j.negPart)","decl":"theorem real_smul_posPart_neg (r : ℝ) (hr : r < 0) :\n    (r • j).posPart = (-r).toNNReal • j.negPart := by\n  rw [real_smul_def, ← smul_negPart, if_neg (not_le.2 hr), neg_posPart]\n\n"}
{"name":"MeasureTheory.JordanDecomposition.real_smul_negPart_neg","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nj : MeasureTheory.JordanDecomposition α\nr : Real\nhr : LT.lt r 0\n⊢ Eq (HSMul.hSMul r j).negPart (HSMul.hSMul (Neg.neg r).toNNReal j.posPart)","decl":"theorem real_smul_negPart_neg (r : ℝ) (hr : r < 0) :\n    (r • j).negPart = (-r).toNNReal • j.posPart := by\n  rw [real_smul_def, ← smul_posPart, if_neg (not_le.2 hr), neg_negPart]\n\n"}
{"name":"MeasureTheory.JordanDecomposition.toSignedMeasure_zero","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Eq (MeasureTheory.JordanDecomposition.toSignedMeasure 0) 0","decl":"theorem toSignedMeasure_zero : (0 : JordanDecomposition α).toSignedMeasure = 0 := by\n  ext1 i hi\n  -- Porting note: replaced `erw` by adding further lemmas\n  rw [toSignedMeasure, toSignedMeasure_sub_apply hi, zero_posPart, zero_negPart, sub_self,\n    VectorMeasure.coe_zero, Pi.zero_apply]\n\n"}
{"name":"MeasureTheory.JordanDecomposition.toSignedMeasure_neg","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nj : MeasureTheory.JordanDecomposition α\n⊢ Eq (Neg.neg j).toSignedMeasure (Neg.neg j.toSignedMeasure)","decl":"theorem toSignedMeasure_neg : (-j).toSignedMeasure = -j.toSignedMeasure := by\n  ext1 i hi\n  -- Porting note: removed `rfl` after the `rw` by adding further steps.\n  rw [neg_apply, toSignedMeasure, toSignedMeasure, toSignedMeasure_sub_apply hi,\n    toSignedMeasure_sub_apply hi, neg_sub, neg_posPart, neg_negPart]\n\n"}
{"name":"MeasureTheory.JordanDecomposition.toSignedMeasure_smul","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nj : MeasureTheory.JordanDecomposition α\nr : NNReal\n⊢ Eq (HSMul.hSMul r j).toSignedMeasure (HSMul.hSMul r j.toSignedMeasure)","decl":"theorem toSignedMeasure_smul (r : ℝ≥0) : (r • j).toSignedMeasure = r • j.toSignedMeasure := by\n  ext1 i hi\n  rw [VectorMeasure.smul_apply, toSignedMeasure, toSignedMeasure,\n    toSignedMeasure_sub_apply hi, toSignedMeasure_sub_apply hi, smul_sub, smul_posPart,\n    smul_negPart, ← ENNReal.toReal_smul, ← ENNReal.toReal_smul, Measure.smul_apply,\n    Measure.smul_apply]\n\n"}
{"name":"MeasureTheory.JordanDecomposition.exists_compl_positive_negative","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nj : MeasureTheory.JordanDecomposition α\n⊢ Exists fun S => And (MeasurableSet S) (And (LE.le (MeasureTheory.VectorMeasure.restrict j.toSignedMeasure S) (MeasureTheory.VectorMeasure.restrict 0 S)) (And (LE.le (MeasureTheory.VectorMeasure.restrict 0 (HasCompl.compl S)) (MeasureTheory.VectorMeasure.restrict j.toSignedMeasure (HasCompl.compl S))) (And (Eq (j.posPart S) 0) (Eq (j.negPart (HasCompl.compl S)) 0))))","decl":"/-- A Jordan decomposition provides a Hahn decomposition. -/\ntheorem exists_compl_positive_negative :\n    ∃ S : Set α,\n      MeasurableSet S ∧\n        j.toSignedMeasure ≤[S] 0 ∧\n          0 ≤[Sᶜ] j.toSignedMeasure ∧ j.posPart S = 0 ∧ j.negPart Sᶜ = 0 := by\n  obtain ⟨S, hS₁, hS₂, hS₃⟩ := j.mutuallySingular\n  refine ⟨S, hS₁, ?_, ?_, hS₂, hS₃⟩\n  · refine restrict_le_restrict_of_subset_le _ _ fun A hA hA₁ => ?_\n    rw [toSignedMeasure, toSignedMeasure_sub_apply hA,\n      show j.posPart A = 0 from nonpos_iff_eq_zero.1 (hS₂ ▸ measure_mono hA₁), ENNReal.zero_toReal,\n      zero_sub, neg_le, zero_apply, neg_zero]\n    exact ENNReal.toReal_nonneg\n  · refine restrict_le_restrict_of_subset_le _ _ fun A hA hA₁ => ?_\n    rw [toSignedMeasure, toSignedMeasure_sub_apply hA,\n      show j.negPart A = 0 from nonpos_iff_eq_zero.1 (hS₃ ▸ measure_mono hA₁), ENNReal.zero_toReal,\n      sub_zero]\n    exact ENNReal.toReal_nonneg\n\n"}
{"name":"MeasureTheory.SignedMeasure.toJordanDecomposition_spec","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\n⊢ Exists fun i => Exists fun hi₁ => Exists fun hi₂ => Exists fun hi₃ => And (Eq s.toJordanDecomposition.posPart (s.toMeasureOfZeroLE i hi₁ hi₂)) (Eq s.toJordanDecomposition.negPart (s.toMeasureOfLEZero (HasCompl.compl i) ⋯ hi₃))","decl":"theorem toJordanDecomposition_spec (s : SignedMeasure α) :\n    ∃ (i : Set α) (hi₁ : MeasurableSet i) (hi₂ : 0 ≤[i] s) (hi₃ : s ≤[iᶜ] 0),\n      s.toJordanDecomposition.posPart = s.toMeasureOfZeroLE i hi₁ hi₂ ∧\n        s.toJordanDecomposition.negPart = s.toMeasureOfLEZero iᶜ hi₁.compl hi₃ := by\n  set i := s.exists_compl_positive_negative.choose\n  obtain ⟨hi₁, hi₂, hi₃⟩ := s.exists_compl_positive_negative.choose_spec\n  exact ⟨i, hi₁, hi₂, hi₃, rfl, rfl⟩\n\n"}
{"name":"MeasureTheory.SignedMeasure.toSignedMeasure_toJordanDecomposition","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\n⊢ Eq s.toJordanDecomposition.toSignedMeasure s","decl":"/-- **The Jordan decomposition theorem**: Given a signed measure `s`, there exists a pair of\nmutually singular measures `μ` and `ν` such that `s = μ - ν`. In this case, the measures `μ`\nand `ν` are given by `s.toJordanDecomposition.posPart` and\n`s.toJordanDecomposition.negPart` respectively.\n\nNote that we use `MeasureTheory.JordanDecomposition.toSignedMeasure` to represent the\nsigned measure corresponding to\n`s.toJordanDecomposition.posPart - s.toJordanDecomposition.negPart`. -/\n@[simp]\ntheorem toSignedMeasure_toJordanDecomposition (s : SignedMeasure α) :\n    s.toJordanDecomposition.toSignedMeasure = s := by\n  obtain ⟨i, hi₁, hi₂, hi₃, hμ, hν⟩ := s.toJordanDecomposition_spec\n  simp only [JordanDecomposition.toSignedMeasure, hμ, hν]\n  ext k hk\n  rw [toSignedMeasure_sub_apply hk, toMeasureOfZeroLE_apply _ hi₂ hi₁ hk,\n    toMeasureOfLEZero_apply _ hi₃ hi₁.compl hk]\n  simp only [ENNReal.coe_toReal, NNReal.coe_mk, ENNReal.some_eq_coe, sub_neg_eq_add]\n  rw [← of_union _ (MeasurableSet.inter hi₁ hk) (MeasurableSet.inter hi₁.compl hk),\n    Set.inter_comm i, Set.inter_comm iᶜ, Set.inter_union_compl _ _]\n  exact (disjoint_compl_right.inf_left _).inf_right _\n\n"}
{"name":"MeasureTheory.SignedMeasure.subset_positive_null_set","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nu v w : Set α\nhu : MeasurableSet u\nhv : MeasurableSet v\nhw : MeasurableSet w\nhsu : LE.le (MeasureTheory.VectorMeasure.restrict 0 u) (MeasureTheory.VectorMeasure.restrict s u)\nhw₁ : Eq (↑s w) 0\nhw₂ : HasSubset.Subset w u\nhwt : HasSubset.Subset v w\n⊢ Eq (↑s v) 0","decl":"/-- A subset `v` of a null-set `w` has zero measure if `w` is a subset of a positive set `u`. -/\ntheorem subset_positive_null_set (hu : MeasurableSet u) (hv : MeasurableSet v)\n    (hw : MeasurableSet w) (hsu : 0 ≤[u] s) (hw₁ : s w = 0) (hw₂ : w ⊆ u) (hwt : v ⊆ w) :\n    s v = 0 := by\n  have : s v + s (w \\ v) = 0 := by\n    rw [← hw₁, ← of_union Set.disjoint_sdiff_right hv (hw.diff hv), Set.union_diff_self,\n      Set.union_eq_self_of_subset_left hwt]\n  have h₁ := nonneg_of_zero_le_restrict _ (restrict_le_restrict_subset _ _ hu hsu (hwt.trans hw₂))\n  have h₂ : 0 ≤ s (w \\ v) :=\n    nonneg_of_zero_le_restrict _\n      (restrict_le_restrict_subset _ _ hu hsu (diff_subset.trans hw₂))\n  linarith\n\n"}
{"name":"MeasureTheory.SignedMeasure.subset_negative_null_set","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nu v w : Set α\nhu : MeasurableSet u\nhv : MeasurableSet v\nhw : MeasurableSet w\nhsu : LE.le (MeasureTheory.VectorMeasure.restrict s u) (MeasureTheory.VectorMeasure.restrict 0 u)\nhw₁ : Eq (↑s w) 0\nhw₂ : HasSubset.Subset w u\nhwt : HasSubset.Subset v w\n⊢ Eq (↑s v) 0","decl":"/-- A subset `v` of a null-set `w` has zero measure if `w` is a subset of a negative set `u`. -/\ntheorem subset_negative_null_set (hu : MeasurableSet u) (hv : MeasurableSet v)\n    (hw : MeasurableSet w) (hsu : s ≤[u] 0) (hw₁ : s w = 0) (hw₂ : w ⊆ u) (hwt : v ⊆ w) :\n    s v = 0 := by\n  rw [← s.neg_le_neg_iff _ hu, neg_zero] at hsu\n  have := subset_positive_null_set hu hv hw hsu\n  simp only [Pi.neg_apply, neg_eq_zero, coe_neg] at this\n  exact this hw₁ hw₂ hwt\n\n"}
{"name":"MeasureTheory.SignedMeasure.of_diff_eq_zero_of_symmDiff_eq_zero_positive","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nu v : Set α\nhu : MeasurableSet u\nhv : MeasurableSet v\nhsu : LE.le (MeasureTheory.VectorMeasure.restrict 0 u) (MeasureTheory.VectorMeasure.restrict s u)\nhsv : LE.le (MeasureTheory.VectorMeasure.restrict 0 v) (MeasureTheory.VectorMeasure.restrict s v)\nhs : Eq (↑s (symmDiff u v)) 0\n⊢ And (Eq (↑s (SDiff.sdiff u v)) 0) (Eq (↑s (SDiff.sdiff v u)) 0)","decl":"/-- If the symmetric difference of two positive sets is a null-set, then so are the differences\nbetween the two sets. -/\ntheorem of_diff_eq_zero_of_symmDiff_eq_zero_positive (hu : MeasurableSet u) (hv : MeasurableSet v)\n    (hsu : 0 ≤[u] s) (hsv : 0 ≤[v] s) (hs : s (u ∆ v) = 0) : s (u \\ v) = 0 ∧ s (v \\ u) = 0 := by\n  rw [restrict_le_restrict_iff] at hsu hsv\n  on_goal 1 =>\n    have a := hsu (hu.diff hv) diff_subset\n    have b := hsv (hv.diff hu) diff_subset\n    erw [of_union (Set.disjoint_of_subset_left diff_subset disjoint_sdiff_self_right)\n        (hu.diff hv) (hv.diff hu)] at hs\n    rw [zero_apply] at a b\n    constructor\n  all_goals first | linarith | assumption\n\n"}
{"name":"MeasureTheory.SignedMeasure.of_diff_eq_zero_of_symmDiff_eq_zero_negative","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nu v : Set α\nhu : MeasurableSet u\nhv : MeasurableSet v\nhsu : LE.le (MeasureTheory.VectorMeasure.restrict s u) (MeasureTheory.VectorMeasure.restrict 0 u)\nhsv : LE.le (MeasureTheory.VectorMeasure.restrict s v) (MeasureTheory.VectorMeasure.restrict 0 v)\nhs : Eq (↑s (symmDiff u v)) 0\n⊢ And (Eq (↑s (SDiff.sdiff u v)) 0) (Eq (↑s (SDiff.sdiff v u)) 0)","decl":"/-- If the symmetric difference of two negative sets is a null-set, then so are the differences\nbetween the two sets. -/\ntheorem of_diff_eq_zero_of_symmDiff_eq_zero_negative (hu : MeasurableSet u) (hv : MeasurableSet v)\n    (hsu : s ≤[u] 0) (hsv : s ≤[v] 0) (hs : s (u ∆ v) = 0) : s (u \\ v) = 0 ∧ s (v \\ u) = 0 := by\n  rw [← s.neg_le_neg_iff _ hu, neg_zero] at hsu\n  rw [← s.neg_le_neg_iff _ hv, neg_zero] at hsv\n  have := of_diff_eq_zero_of_symmDiff_eq_zero_positive hu hv hsu hsv\n  simp only [Pi.neg_apply, neg_eq_zero, coe_neg] at this\n  exact this hs\n\n"}
{"name":"MeasureTheory.SignedMeasure.of_inter_eq_of_symmDiff_eq_zero_positive","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nu v w : Set α\nhu : MeasurableSet u\nhv : MeasurableSet v\nhw : MeasurableSet w\nhsu : LE.le (MeasureTheory.VectorMeasure.restrict 0 u) (MeasureTheory.VectorMeasure.restrict s u)\nhsv : LE.le (MeasureTheory.VectorMeasure.restrict 0 v) (MeasureTheory.VectorMeasure.restrict s v)\nhs : Eq (↑s (symmDiff u v)) 0\n⊢ Eq (↑s (Inter.inter w u)) (↑s (Inter.inter w v))","decl":"theorem of_inter_eq_of_symmDiff_eq_zero_positive (hu : MeasurableSet u) (hv : MeasurableSet v)\n    (hw : MeasurableSet w) (hsu : 0 ≤[u] s) (hsv : 0 ≤[v] s) (hs : s (u ∆ v) = 0) :\n    s (w ∩ u) = s (w ∩ v) := by\n  have hwuv : s ((w ∩ u) ∆ (w ∩ v)) = 0 := by\n    refine\n      subset_positive_null_set (hu.union hv) ((hw.inter hu).symmDiff (hw.inter hv))\n        (hu.symmDiff hv) (restrict_le_restrict_union _ _ hu hsu hv hsv) hs\n        Set.symmDiff_subset_union ?_\n    rw [← Set.inter_symmDiff_distrib_left]\n    exact Set.inter_subset_right\n  obtain ⟨huv, hvu⟩ :=\n    of_diff_eq_zero_of_symmDiff_eq_zero_positive (hw.inter hu) (hw.inter hv)\n      (restrict_le_restrict_subset _ _ hu hsu (w.inter_subset_right))\n      (restrict_le_restrict_subset _ _ hv hsv (w.inter_subset_right)) hwuv\n  rw [← of_diff_of_diff_eq_zero (hw.inter hu) (hw.inter hv) hvu, huv, zero_add]\n\n"}
{"name":"MeasureTheory.SignedMeasure.of_inter_eq_of_symmDiff_eq_zero_negative","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nu v w : Set α\nhu : MeasurableSet u\nhv : MeasurableSet v\nhw : MeasurableSet w\nhsu : LE.le (MeasureTheory.VectorMeasure.restrict s u) (MeasureTheory.VectorMeasure.restrict 0 u)\nhsv : LE.le (MeasureTheory.VectorMeasure.restrict s v) (MeasureTheory.VectorMeasure.restrict 0 v)\nhs : Eq (↑s (symmDiff u v)) 0\n⊢ Eq (↑s (Inter.inter w u)) (↑s (Inter.inter w v))","decl":"theorem of_inter_eq_of_symmDiff_eq_zero_negative (hu : MeasurableSet u) (hv : MeasurableSet v)\n    (hw : MeasurableSet w) (hsu : s ≤[u] 0) (hsv : s ≤[v] 0) (hs : s (u ∆ v) = 0) :\n    s (w ∩ u) = s (w ∩ v) := by\n  rw [← s.neg_le_neg_iff _ hu, neg_zero] at hsu\n  rw [← s.neg_le_neg_iff _ hv, neg_zero] at hsv\n  have := of_inter_eq_of_symmDiff_eq_zero_positive hu hv hw hsu hsv\n  simp only [Pi.neg_apply, neg_inj, neg_eq_zero, coe_neg] at this\n  exact this hs\n\n"}
{"name":"MeasureTheory.JordanDecomposition.toSignedMeasure_injective","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Function.Injective MeasureTheory.JordanDecomposition.toSignedMeasure","decl":"/-- The Jordan decomposition of a signed measure is unique. -/\ntheorem toSignedMeasure_injective : Injective <| @JordanDecomposition.toSignedMeasure α _ := by\n  /- The main idea is that two Jordan decompositions of a signed measure provide two\n    Hahn decompositions for that measure. Then, from `of_symmDiff_compl_positive_negative`,\n    the symmetric difference of the two Hahn decompositions has measure zero, thus, allowing us to\n    show the equality of the underlying measures of the Jordan decompositions. -/\n  intro j₁ j₂ hj\n  -- obtain the two Hahn decompositions from the Jordan decompositions\n  obtain ⟨S, hS₁, hS₂, hS₃, hS₄, hS₅⟩ := j₁.exists_compl_positive_negative\n  obtain ⟨T, hT₁, hT₂, hT₃, hT₄, hT₅⟩ := j₂.exists_compl_positive_negative\n  rw [← hj] at hT₂ hT₃\n  -- the symmetric differences of the two Hahn decompositions have measure zero\n  obtain ⟨hST₁, -⟩ :=\n    of_symmDiff_compl_positive_negative hS₁.compl hT₁.compl ⟨hS₃, (compl_compl S).symm ▸ hS₂⟩\n      ⟨hT₃, (compl_compl T).symm ▸ hT₂⟩\n  -- it suffices to show the Jordan decompositions have the same positive parts\n  refine eq_of_posPart_eq_posPart ?_ hj\n  ext1 i hi\n  -- we see that the positive parts of the two Jordan decompositions are equal to their\n  -- associated signed measures restricted on their associated Hahn decompositions\n  have hμ₁ : (j₁.posPart i).toReal = j₁.toSignedMeasure (i ∩ Sᶜ) := by\n    rw [toSignedMeasure, toSignedMeasure_sub_apply (hi.inter hS₁.compl),\n      show j₁.negPart (i ∩ Sᶜ) = 0 from\n        nonpos_iff_eq_zero.1 (hS₅ ▸ measure_mono Set.inter_subset_right),\n      ENNReal.zero_toReal, sub_zero]\n    conv_lhs => rw [← Set.inter_union_compl i S]\n    rw [measure_union,\n      show j₁.posPart (i ∩ S) = 0 from\n        nonpos_iff_eq_zero.1 (hS₄ ▸ measure_mono Set.inter_subset_right),\n      zero_add]\n    · refine\n        Set.disjoint_of_subset_left Set.inter_subset_right\n          (Set.disjoint_of_subset_right Set.inter_subset_right disjoint_compl_right)\n    · exact hi.inter hS₁.compl\n  have hμ₂ : (j₂.posPart i).toReal = j₂.toSignedMeasure (i ∩ Tᶜ) := by\n    rw [toSignedMeasure, toSignedMeasure_sub_apply (hi.inter hT₁.compl),\n      show j₂.negPart (i ∩ Tᶜ) = 0 from\n        nonpos_iff_eq_zero.1 (hT₅ ▸ measure_mono Set.inter_subset_right),\n      ENNReal.zero_toReal, sub_zero]\n    conv_lhs => rw [← Set.inter_union_compl i T]\n    rw [measure_union,\n      show j₂.posPart (i ∩ T) = 0 from\n        nonpos_iff_eq_zero.1 (hT₄ ▸ measure_mono Set.inter_subset_right),\n      zero_add]\n    · exact\n        Set.disjoint_of_subset_left Set.inter_subset_right\n          (Set.disjoint_of_subset_right Set.inter_subset_right disjoint_compl_right)\n    · exact hi.inter hT₁.compl\n  -- since the two signed measures associated with the Jordan decompositions are the same,\n  -- and the symmetric difference of the Hahn decompositions have measure zero, the result follows\n  rw [← ENNReal.toReal_eq_toReal (measure_ne_top _ _) (measure_ne_top _ _), hμ₁, hμ₂, ← hj]\n  exact of_inter_eq_of_symmDiff_eq_zero_positive hS₁.compl hT₁.compl hi hS₃ hT₃ hST₁\n\n"}
{"name":"MeasureTheory.JordanDecomposition.toJordanDecomposition_toSignedMeasure","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nj : MeasureTheory.JordanDecomposition α\n⊢ Eq j.toSignedMeasure.toJordanDecomposition j","decl":"@[simp]\ntheorem toJordanDecomposition_toSignedMeasure (j : JordanDecomposition α) :\n    j.toSignedMeasure.toJordanDecomposition = j :=\n  (@toSignedMeasure_injective _ _ j j.toSignedMeasure.toJordanDecomposition (by simp)).symm\n\n"}
{"name":"MeasureTheory.SignedMeasure.toJordanDecompositionEquiv_symm_apply","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_2\ninst✝ : MeasurableSpace α\nj : MeasureTheory.JordanDecomposition α\n⊢ Eq ((MeasureTheory.SignedMeasure.toJordanDecompositionEquiv α).symm j) j.toSignedMeasure","decl":"/-- `MeasureTheory.SignedMeasure.toJordanDecomposition` and\n`MeasureTheory.JordanDecomposition.toSignedMeasure` form an `Equiv`. -/\n@[simps apply symm_apply]\ndef toJordanDecompositionEquiv (α : Type*) [MeasurableSpace α] :\n    SignedMeasure α ≃ JordanDecomposition α where\n  toFun := toJordanDecomposition\n  invFun := toSignedMeasure\n  left_inv := toSignedMeasure_toJordanDecomposition\n  right_inv := toJordanDecomposition_toSignedMeasure\n\n"}
{"name":"MeasureTheory.SignedMeasure.toJordanDecompositionEquiv_apply","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_2\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\n⊢ Eq ((MeasureTheory.SignedMeasure.toJordanDecompositionEquiv α) s) s.toJordanDecomposition","decl":"/-- `MeasureTheory.SignedMeasure.toJordanDecomposition` and\n`MeasureTheory.JordanDecomposition.toSignedMeasure` form an `Equiv`. -/\n@[simps apply symm_apply]\ndef toJordanDecompositionEquiv (α : Type*) [MeasurableSpace α] :\n    SignedMeasure α ≃ JordanDecomposition α where\n  toFun := toJordanDecomposition\n  invFun := toSignedMeasure\n  left_inv := toSignedMeasure_toJordanDecomposition\n  right_inv := toJordanDecomposition_toSignedMeasure\n\n"}
{"name":"MeasureTheory.SignedMeasure.toJordanDecomposition_zero","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Eq (MeasureTheory.SignedMeasure.toJordanDecomposition 0) 0","decl":"theorem toJordanDecomposition_zero : (0 : SignedMeasure α).toJordanDecomposition = 0 := by\n  apply toSignedMeasure_injective\n  simp [toSignedMeasure_zero]\n\n"}
{"name":"MeasureTheory.SignedMeasure.toJordanDecomposition_neg","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\n⊢ Eq (Neg.neg s).toJordanDecomposition (Neg.neg s.toJordanDecomposition)","decl":"theorem toJordanDecomposition_neg (s : SignedMeasure α) :\n    (-s).toJordanDecomposition = -s.toJordanDecomposition := by\n  apply toSignedMeasure_injective\n  simp [toSignedMeasure_neg]\n\n"}
{"name":"MeasureTheory.SignedMeasure.toJordanDecomposition_smul","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nr : NNReal\n⊢ Eq (HSMul.hSMul r s).toJordanDecomposition (HSMul.hSMul r s.toJordanDecomposition)","decl":"theorem toJordanDecomposition_smul (s : SignedMeasure α) (r : ℝ≥0) :\n    (r • s).toJordanDecomposition = r • s.toJordanDecomposition := by\n  apply toSignedMeasure_injective\n  simp [toSignedMeasure_smul]\n\n"}
{"name":"MeasureTheory.SignedMeasure.toJordanDecomposition_smul_real","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nr : Real\n⊢ Eq (HSMul.hSMul r s).toJordanDecomposition (HSMul.hSMul r s.toJordanDecomposition)","decl":"theorem toJordanDecomposition_smul_real (s : SignedMeasure α) (r : ℝ) :\n    (r • s).toJordanDecomposition = r • s.toJordanDecomposition := by\n  by_cases hr : 0 ≤ r\n  · exact toJordanDecomposition_smul_real_nonneg s r hr\n  · ext1\n    · rw [real_smul_posPart_neg _ _ (not_le.1 hr),\n        show r • s = -(-r • s) by rw [neg_smul, neg_neg], toJordanDecomposition_neg, neg_posPart,\n        toJordanDecomposition_smul_real_nonneg, ← smul_negPart, real_smul_nonneg]\n      all_goals exact Left.nonneg_neg_iff.2 (le_of_lt (not_le.1 hr))\n    · rw [real_smul_negPart_neg _ _ (not_le.1 hr),\n        show r • s = -(-r • s) by rw [neg_smul, neg_neg], toJordanDecomposition_neg, neg_negPart,\n        toJordanDecomposition_smul_real_nonneg, ← smul_posPart, real_smul_nonneg]\n      all_goals exact Left.nonneg_neg_iff.2 (le_of_lt (not_le.1 hr))\n\n"}
{"name":"MeasureTheory.SignedMeasure.toJordanDecomposition_eq","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nj : MeasureTheory.JordanDecomposition α\nh : Eq s j.toSignedMeasure\n⊢ Eq s.toJordanDecomposition j","decl":"theorem toJordanDecomposition_eq {s : SignedMeasure α} {j : JordanDecomposition α}\n    (h : s = j.toSignedMeasure) : s.toJordanDecomposition = j := by\n  rw [h, toJordanDecomposition_toSignedMeasure]\n\n"}
{"name":"MeasureTheory.SignedMeasure.totalVariation_zero","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Eq (MeasureTheory.SignedMeasure.totalVariation 0) 0","decl":"theorem totalVariation_zero : (0 : SignedMeasure α).totalVariation = 0 := by\n  simp [totalVariation, toJordanDecomposition_zero]\n\n"}
{"name":"MeasureTheory.SignedMeasure.totalVariation_neg","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\n⊢ Eq (Neg.neg s).totalVariation s.totalVariation","decl":"theorem totalVariation_neg (s : SignedMeasure α) : (-s).totalVariation = s.totalVariation := by\n  simp [totalVariation, toJordanDecomposition_neg, add_comm]\n\n"}
{"name":"MeasureTheory.SignedMeasure.null_of_totalVariation_zero","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\ni : Set α\nhs : Eq (s.totalVariation i) 0\n⊢ Eq (↑s i) 0","decl":"theorem null_of_totalVariation_zero (s : SignedMeasure α) {i : Set α}\n    (hs : s.totalVariation i = 0) : s i = 0 := by\n  rw [totalVariation, Measure.coe_add, Pi.add_apply, add_eq_zero] at hs\n  rw [← toSignedMeasure_toJordanDecomposition s, toSignedMeasure, VectorMeasure.coe_sub,\n    Pi.sub_apply, Measure.toSignedMeasure_apply, Measure.toSignedMeasure_apply]\n  by_cases hi : MeasurableSet i\n  · rw [if_pos hi, if_pos hi]; simp [hs.1, hs.2]\n  · simp [if_neg hi]\n\n"}
{"name":"MeasureTheory.SignedMeasure.absolutelyContinuous_ennreal_iff","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.VectorMeasure α ENNReal\n⊢ Iff (MeasureTheory.VectorMeasure.AbsolutelyContinuous s μ) (s.totalVariation.AbsolutelyContinuous μ.ennrealToMeasure)","decl":"theorem absolutelyContinuous_ennreal_iff (s : SignedMeasure α) (μ : VectorMeasure α ℝ≥0∞) :\n    s ≪ᵥ μ ↔ s.totalVariation ≪ μ.ennrealToMeasure := by\n  constructor <;> intro h\n  · refine Measure.AbsolutelyContinuous.mk fun S hS₁ hS₂ => ?_\n    obtain ⟨i, hi₁, hi₂, hi₃, hpos, hneg⟩ := s.toJordanDecomposition_spec\n    rw [totalVariation, Measure.add_apply, hpos, hneg, toMeasureOfZeroLE_apply _ _ _ hS₁,\n      toMeasureOfLEZero_apply _ _ _ hS₁]\n    rw [← VectorMeasure.AbsolutelyContinuous.ennrealToMeasure] at h\n    -- Porting note: added `NNReal.eq_iff`\n    simp [h (measure_mono_null (i.inter_subset_right) hS₂),\n      h (measure_mono_null (iᶜ.inter_subset_right) hS₂), NNReal.eq_iff]\n  · refine VectorMeasure.AbsolutelyContinuous.mk fun S hS₁ hS₂ => ?_\n    rw [← VectorMeasure.ennrealToMeasure_apply hS₁] at hS₂\n    exact null_of_totalVariation_zero s (h hS₂)\n\n"}
{"name":"MeasureTheory.SignedMeasure.totalVariation_absolutelyContinuous_iff","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\n⊢ Iff (s.totalVariation.AbsolutelyContinuous μ) (And (s.toJordanDecomposition.posPart.AbsolutelyContinuous μ) (s.toJordanDecomposition.negPart.AbsolutelyContinuous μ))","decl":"theorem totalVariation_absolutelyContinuous_iff (s : SignedMeasure α) (μ : Measure α) :\n    s.totalVariation ≪ μ ↔\n      s.toJordanDecomposition.posPart ≪ μ ∧ s.toJordanDecomposition.negPart ≪ μ := by\n  constructor <;> intro h\n  · constructor\n    all_goals\n      refine Measure.AbsolutelyContinuous.mk fun S _ hS₂ => ?_\n      have := h hS₂\n      rw [totalVariation, Measure.add_apply, add_eq_zero] at this\n    exacts [this.1, this.2]\n  · refine Measure.AbsolutelyContinuous.mk fun S _ hS₂ => ?_\n    rw [totalVariation, Measure.add_apply, h.1 hS₂, h.2 hS₂, add_zero]\n\n-- TODO: Generalize to vector measures once total variation on vector measures is defined\n"}
{"name":"MeasureTheory.SignedMeasure.mutuallySingular_iff","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns t : MeasureTheory.SignedMeasure α\n⊢ Iff (MeasureTheory.VectorMeasure.MutuallySingular s t) (s.totalVariation.MutuallySingular t.totalVariation)","decl":"theorem mutuallySingular_iff (s t : SignedMeasure α) :\n    s ⟂ᵥ t ↔ s.totalVariation ⟂ₘ t.totalVariation := by\n  constructor\n  · rintro ⟨u, hmeas, hu₁, hu₂⟩\n    obtain ⟨i, hi₁, hi₂, hi₃, hipos, hineg⟩ := s.toJordanDecomposition_spec\n    obtain ⟨j, hj₁, hj₂, hj₃, hjpos, hjneg⟩ := t.toJordanDecomposition_spec\n    refine ⟨u, hmeas, ?_, ?_⟩\n    · rw [totalVariation, Measure.add_apply, hipos, hineg, toMeasureOfZeroLE_apply _ _ _ hmeas,\n        toMeasureOfLEZero_apply _ _ _ hmeas]\n      -- Porting note: added `NNReal.eq_iff`\n      simp [hu₁ _ Set.inter_subset_right, NNReal.eq_iff]\n    · rw [totalVariation, Measure.add_apply, hjpos, hjneg,\n        toMeasureOfZeroLE_apply _ _ _ hmeas.compl,\n        toMeasureOfLEZero_apply _ _ _ hmeas.compl]\n      -- Porting note: added `NNReal.eq_iff`\n      simp [hu₂ _ Set.inter_subset_right, NNReal.eq_iff]\n  · rintro ⟨u, hmeas, hu₁, hu₂⟩\n    exact\n      ⟨u, hmeas, fun t htu => null_of_totalVariation_zero _ (measure_mono_null htu hu₁),\n        fun t htv => null_of_totalVariation_zero _ (measure_mono_null htv hu₂)⟩\n\n"}
{"name":"MeasureTheory.SignedMeasure.mutuallySingular_ennreal_iff","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.VectorMeasure α ENNReal\n⊢ Iff (MeasureTheory.VectorMeasure.MutuallySingular s μ) (s.totalVariation.MutuallySingular μ.ennrealToMeasure)","decl":"theorem mutuallySingular_ennreal_iff (s : SignedMeasure α) (μ : VectorMeasure α ℝ≥0∞) :\n    s ⟂ᵥ μ ↔ s.totalVariation ⟂ₘ μ.ennrealToMeasure := by\n  constructor\n  · rintro ⟨u, hmeas, hu₁, hu₂⟩\n    obtain ⟨i, hi₁, hi₂, hi₃, hpos, hneg⟩ := s.toJordanDecomposition_spec\n    refine ⟨u, hmeas, ?_, ?_⟩\n    · rw [totalVariation, Measure.add_apply, hpos, hneg, toMeasureOfZeroLE_apply _ _ _ hmeas,\n        toMeasureOfLEZero_apply _ _ _ hmeas]\n      -- Porting note: added `NNReal.eq_iff`\n      simp [hu₁ _ Set.inter_subset_right, NNReal.eq_iff]\n    · rw [VectorMeasure.ennrealToMeasure_apply hmeas.compl]\n      exact hu₂ _ (Set.Subset.refl _)\n  · rintro ⟨u, hmeas, hu₁, hu₂⟩\n    refine\n      VectorMeasure.MutuallySingular.mk u hmeas\n        (fun t htu _ => null_of_totalVariation_zero _ (measure_mono_null htu hu₁)) fun t htv hmt =>\n        ?_\n    rw [← VectorMeasure.ennrealToMeasure_apply hmt]\n    exact measure_mono_null htv hu₂\n\n"}
{"name":"MeasureTheory.SignedMeasure.totalVariation_mutuallySingular_iff","module":"Mathlib.MeasureTheory.Decomposition.Jordan","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\n⊢ Iff (s.totalVariation.MutuallySingular μ) (And (s.toJordanDecomposition.posPart.MutuallySingular μ) (s.toJordanDecomposition.negPart.MutuallySingular μ))","decl":"theorem totalVariation_mutuallySingular_iff (s : SignedMeasure α) (μ : Measure α) :\n    s.totalVariation ⟂ₘ μ ↔\n      s.toJordanDecomposition.posPart ⟂ₘ μ ∧ s.toJordanDecomposition.negPart ⟂ₘ μ :=\n  Measure.MutuallySingular.add_left_iff\n\n"}
