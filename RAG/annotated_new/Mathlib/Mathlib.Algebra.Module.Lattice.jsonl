{"name":"Submodule.IsLattice.fg","module":"Mathlib.Algebra.Module.Lattice","initialProofState":"R : Type u_1\ninst✝⁸ : CommRing R\nA : outParam (Type u_2)\ninst✝⁷ : CommRing A\ninst✝⁶ : Algebra R A\nV : Type u_3\ninst✝⁵ : AddCommMonoid V\ninst✝⁴ : Module R V\ninst✝³ : Module A V\ninst✝² : IsScalarTower R A V\ninst✝¹ : Algebra R A\ninst✝ : IsScalarTower R A V\nM : Submodule R V\nself : Submodule.IsLattice A M\n⊢ M.FG","decl":"/--\nAn `R`-submodule `M` of `V` is a lattice if it is finitely generated\nand spans `V` as an `A`-module.\n\nNote 1: `A` is marked as an `outParam` here. In practice this should not cause issues, since\n`R` and `A` are fixed, where typically `A` is the fraction field of `R`.\n\nNote 2: In the case `R = ℤ` and `A = K` a field, there is also `IsZLattice` where the finitely\ngenerated condition is replaced by having the discrete topology. -/\nclass IsLattice (A : outParam Type*) [CommRing A] [Algebra R A]\n    {V : Type*} [AddCommMonoid V] [Module R V] [Module A V] [IsScalarTower R A V]\n    [Algebra R A] [IsScalarTower R A V] (M : Submodule R V) : Prop where\n  fg : M.FG\n  span_eq_top : Submodule.span A (M : Set V) = ⊤\n\n"}
{"name":"Submodule.IsLattice.span_eq_top","module":"Mathlib.Algebra.Module.Lattice","initialProofState":"R : Type u_1\ninst✝⁸ : CommRing R\nA : outParam (Type u_2)\ninst✝⁷ : CommRing A\ninst✝⁶ : Algebra R A\nV : Type u_3\ninst✝⁵ : AddCommMonoid V\ninst✝⁴ : Module R V\ninst✝³ : Module A V\ninst✝² : IsScalarTower R A V\ninst✝¹ : Algebra R A\ninst✝ : IsScalarTower R A V\nM : Submodule R V\nself : Submodule.IsLattice A M\n⊢ Eq (Submodule.span A ↑M) Top.top","decl":"/--\nAn `R`-submodule `M` of `V` is a lattice if it is finitely generated\nand spans `V` as an `A`-module.\n\nNote 1: `A` is marked as an `outParam` here. In practice this should not cause issues, since\n`R` and `A` are fixed, where typically `A` is the fraction field of `R`.\n\nNote 2: In the case `R = ℤ` and `A = K` a field, there is also `IsZLattice` where the finitely\ngenerated condition is replaced by having the discrete topology. -/\nclass IsLattice (A : outParam Type*) [CommRing A] [Algebra R A]\n    {V : Type*} [AddCommMonoid V] [Module R V] [Module A V] [IsScalarTower R A V]\n    [Algebra R A] [IsScalarTower R A V] (M : Submodule R V) : Prop where\n  fg : M.FG\n  span_eq_top : Submodule.span A (M : Set V) = ⊤\n\n"}
{"name":"Submodule.IsLattice.finite","module":"Mathlib.Algebra.Module.Lattice","initialProofState":"R : Type u_1\ninst✝⁷ : CommRing R\nA : Type u_2\ninst✝⁶ : CommRing A\ninst✝⁵ : Algebra R A\nV : Type u_3\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module R V\ninst✝² : Module A V\ninst✝¹ : IsScalarTower R A V\nM : Submodule R V\ninst✝ : Submodule.IsLattice A M\n⊢ Module.Finite R (Subtype fun x => Membership.mem M x)","decl":"/-- Any `R`-lattice is finite. -/\ninstance finite [IsLattice A M] : Module.Finite R M := by\n  rw [Module.Finite.iff_fg]\n  exact IsLattice.fg\n\n"}
{"name":"Submodule.IsLattice.smul","module":"Mathlib.Algebra.Module.Lattice","initialProofState":"R : Type u_1\ninst✝⁷ : CommRing R\nA : Type u_2\ninst✝⁶ : CommRing A\ninst✝⁵ : Algebra R A\nV : Type u_3\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module R V\ninst✝² : Module A V\ninst✝¹ : IsScalarTower R A V\nM : Submodule R V\ninst✝ : Submodule.IsLattice A M\na : Units A\n⊢ Submodule.IsLattice A (HSMul.hSMul a M)","decl":"/-- The action of `Aˣ` on `R`-submodules of `V` preserves `IsLattice`. -/\ninstance smul [IsLattice A M] (a : Aˣ) : IsLattice A (a • M : Submodule R V) where\n  fg := by\n    obtain ⟨s, rfl⟩ := IsLattice.fg (M := M)\n    rw [Submodule.smul_span]\n    have : Finite (a • (s : Set V) : Set V) := Finite.Set.finite_image _ _\n    exact Submodule.fg_span (Set.toFinite (a • (s : Set V)))\n  span_eq_top := by\n    rw [Submodule.coe_pointwise_smul, ← Submodule.smul_span, IsLattice.span_eq_top]\n    ext x\n    refine ⟨fun _ ↦ trivial, fun _ ↦ ?_⟩\n    rw [show x = a • a⁻¹ • x by simp]\n    exact Submodule.smul_mem_pointwise_smul _ _ _ (by trivial)\n\n"}
{"name":"Submodule.IsLattice.of_le_of_isLattice_of_fg","module":"Mathlib.Algebra.Module.Lattice","initialProofState":"R : Type u_1\ninst✝⁷ : CommRing R\nA : Type u_2\ninst✝⁶ : CommRing A\ninst✝⁵ : Algebra R A\nV : Type u_3\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module R V\ninst✝² : Module A V\ninst✝¹ : IsScalarTower R A V\nM N : Submodule R V\nhle : LE.le M N\ninst✝ : Submodule.IsLattice A M\nhfg : N.FG\n⊢ Submodule.IsLattice A N","decl":"lemma of_le_of_isLattice_of_fg {M N : Submodule R V} (hle : M ≤ N) [IsLattice A M]\n    (hfg : N.FG) : IsLattice A N :=\n  ⟨hfg, eq_top_iff.mpr <|\n    le_trans (by rw [IsLattice.span_eq_top]) (Submodule.span_mono hle)⟩\n\n"}
{"name":"Submodule.IsLattice.sup","module":"Mathlib.Algebra.Module.Lattice","initialProofState":"R : Type u_1\ninst✝⁸ : CommRing R\nA : Type u_2\ninst✝⁷ : CommRing A\ninst✝⁶ : Algebra R A\nV : Type u_3\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module R V\ninst✝³ : Module A V\ninst✝² : IsScalarTower R A V\nM N : Submodule R V\ninst✝¹ : Submodule.IsLattice A M\ninst✝ : Submodule.IsLattice A N\n⊢ Submodule.IsLattice A (Max.max M N)","decl":"/-- The supremum of two lattices is a lattice. -/\ninstance sup (M N : Submodule R V) [IsLattice A M] [IsLattice A N] :\n    IsLattice A (M ⊔ N) :=\n  of_le_of_isLattice_of_fg A le_sup_left (Submodule.FG.sup IsLattice.fg IsLattice.fg)\n\n"}
{"name":"Submodule.span_range_eq_top_of_injective_of_rank_le","module":"Mathlib.Algebra.Module.Lattice","initialProofState":"R : Type u_1\ninst✝¹¹ : CommRing R\nK : Type u_2\ninst✝¹⁰ : Field K\ninst✝⁹ : Algebra R K\nM N : Type u\ninst✝⁸ : IsDomain R\ninst✝⁷ : IsFractionRing R K\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R N\ninst✝² : Module K N\ninst✝¹ : IsScalarTower R K N\ninst✝ : Module.Finite K N\nf : LinearMap (RingHom.id R) M N\nhf : Function.Injective ⇑f\nh : LE.le (Module.rank K N) (Module.rank R M)\n⊢ Eq (Submodule.span K ↑(LinearMap.range f)) Top.top","decl":"lemma _root_.Submodule.span_range_eq_top_of_injective_of_rank_le {M N : Type u} [IsDomain R]\n    [IsFractionRing R K] [AddCommGroup M] [Module R M]\n    [AddCommGroup N] [Module R N] [Module K N] [IsScalarTower R K N] [Module.Finite K N]\n    {f : M →ₗ[R] N} (hf : Function.Injective f) (h : Module.rank K N ≤ Module.rank R M) :\n    Submodule.span K (LinearMap.range f : Set N) = ⊤ := by\n  obtain ⟨s, hs, hli⟩ := exists_set_linearIndependent R M\n  replace hli := hli.map' f (LinearMap.ker_eq_bot.mpr hf)\n  rw [LinearIndependent.iff_fractionRing (R := R) (K := K)] at hli\n  replace hs : Cardinal.mk s = Module.rank K N :=\n    le_antisymm (LinearIndependent.cardinal_le_rank hli) (hs ▸ h)\n  rw [← Module.finrank_eq_rank, Cardinal.mk_eq_nat_iff_fintype] at hs\n  obtain ⟨hfin, hcard⟩ := hs\n  have hsubset : Set.range (fun x : s ↦ f x.val) ⊆ (LinearMap.range f : Set N) := by\n    rintro x ⟨a, rfl⟩\n    simp\n  rw [eq_top_iff, ← LinearIndependent.span_eq_top_of_card_eq_finrank' hli hcard]\n  exact Submodule.span_mono hsubset\n\n"}
{"name":"Basis.extendOfIsLattice_apply","module":"Mathlib.Algebra.Module.Lattice","initialProofState":"R : Type u_1\ninst✝⁸ : CommRing R\nK : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : Algebra R K\nV : Type u_3\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module K V\ninst✝³ : Module R V\ninst✝² : IsScalarTower R K V\ninst✝¹ : IsFractionRing R K\nκ : Type u_4\nM : Submodule R V\ninst✝ : Submodule.IsLattice K M\nb : Basis κ R (Subtype fun x => Membership.mem M x)\nk : κ\n⊢ Eq ((Basis.extendOfIsLattice K b) k) ↑(b k)","decl":"@[simp]\nlemma _root_.Basis.extendOfIsLattice_apply [IsFractionRing R K] {κ : Type*}\n    {M : Submodule R V} [IsLattice K M] (b : Basis κ R M) (k : κ) :\n    b.extendOfIsLattice K k = (b k).val := by\n  simp [Basis.extendOfIsLattice]\n\n"}
{"name":"Submodule.IsLattice.of_rank_le","module":"Mathlib.Algebra.Module.Lattice","initialProofState":"R : Type u_1\ninst✝⁹ : CommRing R\nK : Type u_2\ninst✝⁸ : Field K\ninst✝⁷ : Algebra R K\nV : Type u_3\ninst✝⁶ : AddCommGroup V\ninst✝⁵ : Module K V\ninst✝⁴ : Module R V\ninst✝³ : IsScalarTower R K V\ninst✝² : IsDomain R\ninst✝¹ : Module.Finite K V\ninst✝ : IsFractionRing R K\nM : Submodule R V\nhfg : M.FG\nhr : LE.le (Module.rank K V) (Module.rank R (Subtype fun x => Membership.mem M x))\n⊢ Submodule.IsLattice K M","decl":"/-- A finitely-generated `R`-submodule of `V` of rank at least the `K`-rank of `V`\nis a lattice. -/\nlemma of_rank_le [Module.Finite K V] [IsFractionRing R K] {M : Submodule R V}\n    (hfg : M.FG) (hr : Module.rank K V ≤ Module.rank R M) : IsLattice K M where\n  fg := hfg\n  span_eq_top := by\n    simpa using Submodule.span_range_eq_top_of_injective_of_rank_le M.injective_subtype hr\n\n"}
{"name":"Submodule.IsLattice.free","module":"Mathlib.Algebra.Module.Lattice","initialProofState":"R : Type u_1\ninst✝⁸ : CommRing R\nK : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : Algebra R K\nV : Type u_3\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module K V\ninst✝³ : Module R V\ninst✝² : IsScalarTower R K V\ninst✝¹ : NoZeroSMulDivisors R K\nM : Submodule R V\ninst✝ : Submodule.IsLattice K M\n⊢ Module.Free R (Subtype fun x => Membership.mem M x)","decl":"/-- Any lattice over a PID is a free `R`-module.\nNote that under our conditions, `NoZeroSMulDivisors R K` simply says that `algebraMap R K` is\ninjective. -/\ninstance free [NoZeroSMulDivisors R K] (M : Submodule R V) [IsLattice K M] : Module.Free R M := by\n  haveI : NoZeroSMulDivisors R V := by\n    apply NoZeroSMulDivisors.of_algebraMap_injective' (A := K)\n    exact NoZeroSMulDivisors.algebraMap_injective R K\n  -- any torsion free finite module over a PID is free\n  infer_instance\n\n"}
{"name":"Submodule.IsLattice.rank'","module":"Mathlib.Algebra.Module.Lattice","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommRing R\nK : Type u_2\ninst✝⁹ : Field K\ninst✝⁸ : Algebra R K\nV : Type u_3\ninst✝⁷ : AddCommGroup V\ninst✝⁶ : Module K V\ninst✝⁵ : Module R V\ninst✝⁴ : IsScalarTower R K V\ninst✝³ : IsDomain R\ninst✝² : IsPrincipalIdealRing R\ninst✝¹ : IsFractionRing R K\nM : Submodule R V\ninst✝ : Submodule.IsLattice K M\n⊢ Eq (Module.rank R (Subtype fun x => Membership.mem M x)) (Module.rank K V)","decl":"/-- Any lattice has `R`-rank equal to the `K`-rank of `V`. -/\nlemma rank' [IsFractionRing R K] (M : Submodule R V) [IsLattice K M] :\n    Module.rank R M = Module.rank K V := by\n  let b := Module.Free.chooseBasis R M\n  rw [rank_eq_card_basis b, ← rank_eq_card_basis (b.extendOfIsLattice K)]\n\n"}
{"name":"Submodule.IsLattice.rank_of_pi","module":"Mathlib.Algebra.Module.Lattice","initialProofState":"R : Type u_1\ninst✝⁷ : CommRing R\nK : Type u_2\ninst✝⁶ : Field K\ninst✝⁵ : Algebra R K\ninst✝⁴ : IsDomain R\ninst✝³ : IsPrincipalIdealRing R\nι : Type u_4\ninst✝² : Fintype ι\ninst✝¹ : IsFractionRing R K\nM : Submodule R (ι → K)\ninst✝ : Submodule.IsLattice K M\n⊢ Eq (Module.rank R (Subtype fun x => Membership.mem M x)) ↑(Fintype.card ι)","decl":"/-- Any `R`-lattice in `ι → K` has `#ι` as `R`-rank. -/\nlemma rank_of_pi {ι : Type*} [Fintype ι] [IsFractionRing R K] (M : Submodule R (ι → K))\n    [IsLattice K M] : Module.rank R M = Fintype.card ι := by\n  rw [IsLattice.rank' K M]\n  simp\n\n"}
{"name":"Submodule.IsLattice.finrank_of_pi","module":"Mathlib.Algebra.Module.Lattice","initialProofState":"R : Type u_1\ninst✝⁷ : CommRing R\nK : Type u_2\ninst✝⁶ : Field K\ninst✝⁵ : Algebra R K\ninst✝⁴ : IsDomain R\ninst✝³ : IsPrincipalIdealRing R\nι : Type u_4\ninst✝² : Fintype ι\ninst✝¹ : IsFractionRing R K\nM : Submodule R (ι → K)\ninst✝ : Submodule.IsLattice K M\n⊢ Eq (Module.finrank R (Subtype fun x => Membership.mem M x)) (Fintype.card ι)","decl":"/-- `Module.finrank` version of `IsLattice.rank`. -/\nlemma finrank_of_pi {ι : Type*} [Fintype ι] [IsFractionRing R K] (M : Submodule R (ι → K))\n    [IsLattice K M] : Module.finrank R M = Fintype.card ι :=\n  Module.finrank_eq_of_rank_eq (IsLattice.rank_of_pi K M)\n\n"}
{"name":"Submodule.IsLattice.inf","module":"Mathlib.Algebra.Module.Lattice","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommRing R\nK : Type u_2\ninst✝⁹ : Field K\ninst✝⁸ : Algebra R K\nV : Type u_3\ninst✝⁷ : AddCommGroup V\ninst✝⁶ : Module K V\ninst✝⁵ : Module R V\ninst✝⁴ : IsScalarTower R K V\ninst✝³ : Module.Finite K V\ninst✝² : IsFractionRing R K\nM N : Submodule R V\ninst✝¹ : Submodule.IsLattice K M\ninst✝ : Submodule.IsLattice K N\n⊢ Submodule.IsLattice K (Min.min M N)","decl":"/-- The intersection of two lattices is a lattice. -/\ninstance inf [Module.Finite K V] [IsFractionRing R K] (M N : Submodule R V)\n    [IsLattice K M] [IsLattice K N] : IsLattice K (M ⊓ N) where\n  fg := by\n    have : IsNoetherian R ↥(M ⊓ N) := isNoetherian_of_le inf_le_left\n    rw [← Module.Finite.iff_fg]\n    infer_instance\n  span_eq_top := by\n    rw [← range_subtype (M ⊓ N)]\n    apply Submodule.span_range_eq_top_of_injective_of_rank_le (M ⊓ N).injective_subtype\n    have h := Submodule.rank_sup_add_rank_inf_eq M N\n    rw [IsLattice.rank' K M, IsLattice.rank' K N, IsLattice.rank'] at h\n    rw [Cardinal.eq_of_add_eq_add_left h (Module.rank_lt_aleph0 K V)]\n\n"}
