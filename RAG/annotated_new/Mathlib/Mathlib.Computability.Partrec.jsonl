{"name":"Nat.rfind_spec","module":"Mathlib.Computability.Partrec","initialProofState":"p : PFun Nat Bool\nn : Nat\nh : Membership.mem (Nat.rfind p) n\n⊢ Membership.mem (p n) Bool.true","decl":"theorem rfind_spec {p : ℕ →. Bool} {n : ℕ} (h : n ∈ rfind p) : true ∈ p n :=\n  h.snd ▸ (rfindX p h.fst).2.1\n\n"}
{"name":"Nat.rfind_min","module":"Mathlib.Computability.Partrec","initialProofState":"p : PFun Nat Bool\nn : Nat\nh : Membership.mem (Nat.rfind p) n\nm : Nat\na✝ : LT.lt m n\n⊢ Membership.mem (p m) Bool.false","decl":"theorem rfind_min {p : ℕ →. Bool} {n : ℕ} (h : n ∈ rfind p) : ∀ {m : ℕ}, m < n → false ∈ p m :=\n  @(h.snd ▸ @((rfindX p h.fst).2.2))\n\n"}
{"name":"Nat.rfind_dom","module":"Mathlib.Computability.Partrec","initialProofState":"p : PFun Nat Bool\n⊢ Iff (Nat.rfind p).Dom (Exists fun n => And (Membership.mem (p n) Bool.true) (∀ {m : Nat}, LT.lt m n → (p m).Dom))","decl":"@[simp]\ntheorem rfind_dom {p : ℕ →. Bool} :\n    (rfind p).Dom ↔ ∃ n, true ∈ p n ∧ ∀ {m : ℕ}, m < n → (p m).Dom :=\n  Iff.rfl\n\n"}
{"name":"Nat.rfind_dom'","module":"Mathlib.Computability.Partrec","initialProofState":"p : PFun Nat Bool\n⊢ Iff (Nat.rfind p).Dom (Exists fun n => And (Membership.mem (p n) Bool.true) (∀ {m : Nat}, LE.le m n → (p m).Dom))","decl":"theorem rfind_dom' {p : ℕ →. Bool} :\n    (rfind p).Dom ↔ ∃ n, true ∈ p n ∧ ∀ {m : ℕ}, m ≤ n → (p m).Dom :=\n  exists_congr fun _ =>\n    and_congr_right fun pn =>\n      ⟨fun H _ h => (Decidable.eq_or_lt_of_le h).elim (fun e => e.symm ▸ pn.fst) (H _), fun H _ h =>\n        H (le_of_lt h)⟩\n\n"}
{"name":"Nat.mem_rfind","module":"Mathlib.Computability.Partrec","initialProofState":"p : PFun Nat Bool\nn : Nat\n⊢ Iff (Membership.mem (Nat.rfind p) n) (And (Membership.mem (p n) Bool.true) (∀ {m : Nat}, LT.lt m n → Membership.mem (p m) Bool.false))","decl":"@[simp]\ntheorem mem_rfind {p : ℕ →. Bool} {n : ℕ} :\n    n ∈ rfind p ↔ true ∈ p n ∧ ∀ {m : ℕ}, m < n → false ∈ p m :=\n  ⟨fun h => ⟨rfind_spec h, @rfind_min _ _ h⟩, fun ⟨h₁, h₂⟩ => by\n    let ⟨m, hm⟩ := dom_iff_mem.1 <| (@rfind_dom p).2 ⟨_, h₁, fun {m} mn => (h₂ mn).fst⟩\n    rcases lt_trichotomy m n with (h | h | h)\n    · injection mem_unique (h₂ h) (rfind_spec hm)\n    · rwa [← h]\n    · injection mem_unique h₁ (rfind_min hm h)⟩\n\n"}
{"name":"Nat.rfind_min'","module":"Mathlib.Computability.Partrec","initialProofState":"p : Nat → Bool\nm : Nat\npm : Eq (p m) Bool.true\n⊢ Exists fun n => And (Membership.mem (Nat.rfind ↑p) n) (LE.le n m)","decl":"theorem rfind_min' {p : ℕ → Bool} {m : ℕ} (pm : p m) : ∃ n ∈ rfind p, n ≤ m :=\n  have : true ∈ (p : ℕ →. Bool) m := ⟨trivial, pm⟩\n  let ⟨n, hn⟩ := dom_iff_mem.1 <| (@rfind_dom p).2 ⟨m, this, fun {_} _ => ⟨⟩⟩\n  ⟨n, hn, not_lt.1 fun h => by injection mem_unique this (rfind_min hn h)⟩\n\n"}
{"name":"Nat.rfind_zero_none","module":"Mathlib.Computability.Partrec","initialProofState":"p : PFun Nat Bool\np0 : Eq (p 0) Part.none\n⊢ Eq (Nat.rfind p) Part.none","decl":"theorem rfind_zero_none (p : ℕ →. Bool) (p0 : p 0 = Part.none) : rfind p = Part.none :=\n  eq_none_iff.2 fun _ h =>\n    let ⟨_, _, h₂⟩ := rfind_dom'.1 h.fst\n    (p0 ▸ h₂ (zero_le _) : (@Part.none Bool).Dom)\n\n"}
{"name":"Nat.rfindOpt_spec","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nf : Nat → Option α\na : α\nh : Membership.mem (Nat.rfindOpt f) a\n⊢ Exists fun n => Membership.mem (f n) a","decl":"theorem rfindOpt_spec {α} {f : ℕ → Option α} {a} (h : a ∈ rfindOpt f) : ∃ n, a ∈ f n :=\n  let ⟨n, _, h₂⟩ := mem_bind_iff.1 h\n  ⟨n, mem_coe.1 h₂⟩\n\n"}
{"name":"Nat.rfindOpt_dom","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nf : Nat → Option α\n⊢ Iff (Nat.rfindOpt f).Dom (Exists fun n => Exists fun a => Membership.mem (f n) a)","decl":"theorem rfindOpt_dom {α} {f : ℕ → Option α} : (rfindOpt f).Dom ↔ ∃ n a, a ∈ f n :=\n  ⟨fun h => (rfindOpt_spec ⟨h, rfl⟩).imp fun _ h => ⟨_, h⟩, fun h => by\n    have h' : ∃ n, (f n).isSome := h.imp fun n => Option.isSome_iff_exists.2\n    have s := Nat.find_spec h'\n    have fd : (rfind fun n => (f n).isSome).Dom :=\n      ⟨Nat.find h', by simpa using s.symm, fun _ _ => trivial⟩\n    refine ⟨fd, ?_⟩\n    have := rfind_spec (get_mem fd)\n    simpa using this⟩\n\n"}
{"name":"Nat.rfindOpt_mono","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nf : Nat → Option α\nH : ∀ {a : α} {m n : Nat}, LE.le m n → Membership.mem (f m) a → Membership.mem (f n) a\na : α\n⊢ Iff (Membership.mem (Nat.rfindOpt f) a) (Exists fun n => Membership.mem (f n) a)","decl":"theorem rfindOpt_mono {α} {f : ℕ → Option α} (H : ∀ {a m n}, m ≤ n → a ∈ f m → a ∈ f n) {a} :\n    a ∈ rfindOpt f ↔ ∃ n, a ∈ f n :=\n  ⟨rfindOpt_spec, fun ⟨n, h⟩ => by\n    have h' := rfindOpt_dom.2 ⟨_, _, h⟩\n    cases' rfindOpt_spec ⟨h', rfl⟩ with k hk\n    have := (H (le_max_left _ _) h).symm.trans (H (le_max_right _ _) hk)\n    simp at this; simp [this, get_mem]⟩\n\n"}
{"name":"Nat.Partrec.brecOn","module":"Mathlib.Computability.Partrec","initialProofState":"motive✝ : (a : PFun Nat Nat) → Nat.Partrec a → Prop\na✝ : PFun Nat Nat\nx✝ : Nat.Partrec a✝\nih✝ : ∀ (a : PFun Nat Nat) (x : Nat.Partrec a), x.below → motive✝ a x\n⊢ motive✝ a✝ x✝","decl":"/-- `PartRec f` means that the partial function `f : ℕ → ℕ` is partially recursive. -/\ninductive Partrec : (ℕ →. ℕ) → Prop\n  | zero : Partrec (pure 0)\n  | succ : Partrec succ\n  | left : Partrec ↑fun n : ℕ => n.unpair.1\n  | right : Partrec ↑fun n : ℕ => n.unpair.2\n  | pair {f g} : Partrec f → Partrec g → Partrec fun n => pair <$> f n <*> g n\n  | comp {f g} : Partrec f → Partrec g → Partrec fun n => g n >>= f\n  | prec {f g} : Partrec f → Partrec g → Partrec (unpaired fun a n =>\n      n.rec (f a) fun y IH => do let i ← IH; g (pair a (pair y i)))\n  | rfind {f} : Partrec f → Partrec fun a => rfind fun n => (fun m => m = 0) <$> f (pair a n)\n\n"}
{"name":"Nat.Partrec.of_eq","module":"Mathlib.Computability.Partrec","initialProofState":"f g : PFun Nat Nat\nhf : Nat.Partrec f\nH : ∀ (n : Nat), Eq (f n) (g n)\n⊢ Nat.Partrec g","decl":"theorem of_eq {f g : ℕ →. ℕ} (hf : Partrec f) (H : ∀ n, f n = g n) : Partrec g :=\n  (funext H : f = g) ▸ hf\n\n"}
{"name":"Nat.Partrec.of_eq_tot","module":"Mathlib.Computability.Partrec","initialProofState":"f : PFun Nat Nat\ng : Nat → Nat\nhf : Nat.Partrec f\nH : ∀ (n : Nat), Membership.mem (f n) (g n)\n⊢ Nat.Partrec ↑g","decl":"theorem of_eq_tot {f : ℕ →. ℕ} {g : ℕ → ℕ} (hf : Partrec f) (H : ∀ n, g n ∈ f n) : Partrec g :=\n  hf.of_eq fun n => eq_some_iff.2 (H n)\n\n"}
{"name":"Nat.Partrec.of_primrec","module":"Mathlib.Computability.Partrec","initialProofState":"f : Nat → Nat\nhf : Nat.Primrec f\n⊢ Nat.Partrec ↑f","decl":"theorem of_primrec {f : ℕ → ℕ} (hf : Nat.Primrec f) : Partrec f := by\n  induction hf with\n  | zero => exact zero\n  | succ => exact succ\n  | left => exact left\n  | right => exact right\n  | pair _ _ pf pg =>\n    refine (pf.pair pg).of_eq_tot fun n => ?_\n    simp [Seq.seq]\n  | comp _ _ pf pg =>\n    refine (pf.comp pg).of_eq_tot fun n => (by simp)\n  | prec _ _ pf pg =>\n    refine (pf.prec pg).of_eq_tot fun n => ?_\n    simp only [unpaired, PFun.coe_val, bind_eq_bind]\n    induction n.unpair.2 with\n    | zero => simp\n    | succ m IH =>\n      simp only [mem_bind_iff, mem_some_iff]\n      exact ⟨_, IH, rfl⟩\n\n"}
{"name":"Nat.Partrec.some","module":"Mathlib.Computability.Partrec","initialProofState":"⊢ Nat.Partrec Part.some","decl":"protected theorem some : Partrec some :=\n  of_primrec Primrec.id\n\n"}
{"name":"Nat.Partrec.none","module":"Mathlib.Computability.Partrec","initialProofState":"⊢ Nat.Partrec fun x => Part.none","decl":"theorem none : Partrec fun _ => none :=\n  (of_primrec (Nat.Primrec.const 1)).rfind.of_eq fun _ =>\n    eq_none_iff.2 fun _ ⟨h, _⟩ => by simp at h\n\n"}
{"name":"Nat.Partrec.prec'","module":"Mathlib.Computability.Partrec","initialProofState":"f g h : PFun Nat Nat\nhf : Nat.Partrec f\nhg : Nat.Partrec g\nhh : Nat.Partrec h\n⊢ Nat.Partrec fun a => (f a).bind fun n => Nat.rec (g a) (fun y IH => Bind.bind IH fun i => h (Nat.pair a (Nat.pair y i))) n","decl":"theorem prec' {f g h} (hf : Partrec f) (hg : Partrec g) (hh : Partrec h) :\n    Partrec fun a => (f a).bind fun n => n.rec (g a)\n      fun y IH => do {let i ← IH; h (Nat.pair a (Nat.pair y i))} :=\n  ((prec hg hh).comp (pair Partrec.some hf)).of_eq fun a =>\n    ext fun s => by simp [Seq.seq]\n\n"}
{"name":"Nat.Partrec.ppred","module":"Mathlib.Computability.Partrec","initialProofState":"⊢ Nat.Partrec fun n => ↑n.ppred","decl":"theorem ppred : Partrec fun n => ppred n :=\n  have : Primrec₂ fun n m => if n = Nat.succ m then 0 else 1 :=\n    (Primrec.ite\n      (@PrimrecRel.comp _ _ _ _ _ _ _ _ _ _\n        Primrec.eq Primrec.fst (_root_.Primrec.succ.comp Primrec.snd))\n      (_root_.Primrec.const 0) (_root_.Primrec.const 1)).to₂\n  (of_primrec (Primrec₂.unpaired'.2 this)).rfind.of_eq fun n => by\n    cases n <;> simp\n    · exact\n        eq_none_iff.2 fun a ⟨⟨m, h, _⟩, _⟩ => by\n          simp [show 0 ≠ m.succ by intro h; injection h] at h\n    · refine eq_some_iff.2 ?_\n      simp only [mem_rfind, not_true, IsEmpty.forall_iff, decide_true, mem_some_iff,\n        false_eq_decide_iff, true_and]\n      intro m h\n      simp [ne_of_gt h]\n\n"}
{"name":"Primrec.to_comp","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf : α → σ\nhf : Primrec f\n⊢ Computable f","decl":"theorem Primrec.to_comp {α σ} [Primcodable α] [Primcodable σ] {f : α → σ} (hf : Primrec f) :\n    Computable f :=\n  (Nat.Partrec.ppred.comp (Nat.Partrec.of_primrec hf)).of_eq fun n => by\n    simp; cases decode (α := α) n <;> simp\n\n"}
{"name":"Primrec₂.to_comp","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → β → σ\nhf : Primrec₂ f\n⊢ Computable₂ f","decl":"nonrec theorem Primrec₂.to_comp {α β σ} [Primcodable α] [Primcodable β] [Primcodable σ]\n    {f : α → β → σ} (hf : Primrec₂ f) : Computable₂ f :=\n  hf.to_comp\n\n"}
{"name":"Computable.partrec","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf : α → σ\nhf : Computable f\n⊢ Partrec ↑f","decl":"protected theorem Computable.partrec {α σ} [Primcodable α] [Primcodable σ] {f : α → σ}\n    (hf : Computable f) : Partrec (f : α →. σ) :=\n  hf\n\n"}
{"name":"Computable₂.partrec₂","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → β → σ\nhf : Computable₂ f\n⊢ Partrec₂ fun a => ↑(f a)","decl":"protected theorem Computable₂.partrec₂ {α β σ} [Primcodable α] [Primcodable β] [Primcodable σ]\n    {f : α → β → σ} (hf : Computable₂ f) : Partrec₂ fun a => (f a : β →. σ) :=\n  hf\n\n"}
{"name":"Computable.of_eq","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_4\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf g : α → σ\nhf : Computable f\nH : ∀ (n : α), Eq (f n) (g n)\n⊢ Computable g","decl":"theorem of_eq {f g : α → σ} (hf : Computable f) (H : ∀ n, f n = g n) : Computable g :=\n  (funext H : f = g) ▸ hf\n\n"}
{"name":"Computable.const","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_4\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\ns : σ\n⊢ Computable fun x => s","decl":"theorem const (s : σ) : Computable fun _ : α => s :=\n  (Primrec.const _).to_comp\n\n"}
{"name":"Computable.ofOption","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable β\nf : α → Option β\nhf : Computable f\n⊢ Partrec fun a => ↑(f a)","decl":"theorem ofOption {f : α → Option β} (hf : Computable f) : Partrec fun a => (f a : Part β) :=\n  (Nat.Partrec.ppred.comp hf).of_eq fun n => by\n    cases' decode (α := α) n with a <;> simp\n    cases' f a with b <;> simp\n\n"}
{"name":"Computable.to₂","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_4\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : Prod α β → σ\nhf : Computable f\n⊢ Computable₂ fun a b => f { fst := a, snd := b }","decl":"theorem to₂ {f : α × β → σ} (hf : Computable f) : Computable₂ fun a b => f (a, b) :=\n  hf.of_eq fun ⟨_, _⟩ => rfl\n\n"}
{"name":"Computable.id","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Computable id","decl":"protected theorem id : Computable (@id α) :=\n  Primrec.id.to_comp\n\n"}
{"name":"Computable.fst","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable β\n⊢ Computable Prod.fst","decl":"theorem fst : Computable (@Prod.fst α β) :=\n  Primrec.fst.to_comp\n\n"}
{"name":"Computable.snd","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable β\n⊢ Computable Prod.snd","decl":"theorem snd : Computable (@Prod.snd α β) :=\n  Primrec.snd.to_comp\n\n"}
{"name":"Computable.pair","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable γ\nf : α → β\ng : α → γ\nhf : Computable f\nhg : Computable g\n⊢ Computable fun a => { fst := f a, snd := g a }","decl":"nonrec theorem pair {f : α → β} {g : α → γ} (hf : Computable f) (hg : Computable g) :\n    Computable fun a => (f a, g a) :=\n  (hf.pair hg).of_eq fun n => by cases decode (α := α) n <;> simp [Seq.seq]\n\n"}
{"name":"Computable.unpair","module":"Mathlib.Computability.Partrec","initialProofState":"⊢ Computable Nat.unpair","decl":"theorem unpair : Computable Nat.unpair :=\n  Primrec.unpair.to_comp\n\n"}
{"name":"Computable.succ","module":"Mathlib.Computability.Partrec","initialProofState":"⊢ Computable Nat.succ","decl":"theorem succ : Computable Nat.succ :=\n  Primrec.succ.to_comp\n\n"}
{"name":"Computable.pred","module":"Mathlib.Computability.Partrec","initialProofState":"⊢ Computable Nat.pred","decl":"theorem pred : Computable Nat.pred :=\n  Primrec.pred.to_comp\n\n"}
{"name":"Computable.nat_bodd","module":"Mathlib.Computability.Partrec","initialProofState":"⊢ Computable Nat.bodd","decl":"theorem nat_bodd : Computable Nat.bodd :=\n  Primrec.nat_bodd.to_comp\n\n"}
{"name":"Computable.nat_div2","module":"Mathlib.Computability.Partrec","initialProofState":"⊢ Computable Nat.div2","decl":"theorem nat_div2 : Computable Nat.div2 :=\n  Primrec.nat_div2.to_comp\n\n"}
{"name":"Computable.sum_inl","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable β\n⊢ Computable Sum.inl","decl":"theorem sum_inl : Computable (@Sum.inl α β) :=\n  Primrec.sum_inl.to_comp\n\n"}
{"name":"Computable.sum_inr","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable β\n⊢ Computable Sum.inr","decl":"theorem sum_inr : Computable (@Sum.inr α β) :=\n  Primrec.sum_inr.to_comp\n\n"}
{"name":"Computable.list_cons","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Computable₂ List.cons","decl":"theorem list_cons : Computable₂ (@List.cons α) :=\n  Primrec.list_cons.to_comp\n\n"}
{"name":"Computable.list_reverse","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Computable List.reverse","decl":"theorem list_reverse : Computable (@List.reverse α) :=\n  Primrec.list_reverse.to_comp\n\n"}
{"name":"Computable.list_get?","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Computable₂ List.get?","decl":"theorem list_get? : Computable₂ (@List.get? α) :=\n  Primrec.list_get?.to_comp\n\n"}
{"name":"Computable.list_append","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Computable₂ fun x1 x2 => HAppend.hAppend x1 x2","decl":"theorem list_append : Computable₂ ((· ++ ·) : List α → List α → List α) :=\n  Primrec.list_append.to_comp\n\n"}
{"name":"Computable.list_concat","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Computable₂ fun l a => HAppend.hAppend l (List.cons a List.nil)","decl":"theorem list_concat : Computable₂ fun l (a : α) => l ++ [a] :=\n  Primrec.list_concat.to_comp\n\n"}
{"name":"Computable.list_length","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Computable List.length","decl":"theorem list_length : Computable (@List.length α) :=\n  Primrec.list_length.to_comp\n\n"}
{"name":"Computable.vector_cons","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nn : Nat\n⊢ Computable₂ List.Vector.cons","decl":"theorem vector_cons {n} : Computable₂ (@List.Vector.cons α n) :=\n  Primrec.vector_cons.to_comp\n\n"}
{"name":"Computable.vector_toList","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nn : Nat\n⊢ Computable List.Vector.toList","decl":"theorem vector_toList {n} : Computable (@List.Vector.toList α n) :=\n  Primrec.vector_toList.to_comp\n\n"}
{"name":"Computable.vector_length","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nn : Nat\n⊢ Computable List.Vector.length","decl":"theorem vector_length {n} : Computable (@List.Vector.length α n) :=\n  Primrec.vector_length.to_comp\n\n"}
{"name":"Computable.vector_head","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nn : Nat\n⊢ Computable List.Vector.head","decl":"theorem vector_head {n} : Computable (@List.Vector.head α n) :=\n  Primrec.vector_head.to_comp\n\n"}
{"name":"Computable.vector_tail","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nn : Nat\n⊢ Computable List.Vector.tail","decl":"theorem vector_tail {n} : Computable (@List.Vector.tail α n) :=\n  Primrec.vector_tail.to_comp\n\n"}
{"name":"Computable.vector_get","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nn : Nat\n⊢ Computable₂ List.Vector.get","decl":"theorem vector_get {n} : Computable₂ (@List.Vector.get α n) :=\n  Primrec.vector_get.to_comp\n\n"}
{"name":"Computable.vector_ofFn'","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nn : Nat\n⊢ Computable List.Vector.ofFn","decl":"theorem vector_ofFn' {n} : Computable (@List.Vector.ofFn α n) :=\n  Primrec.vector_ofFn'.to_comp\n\n"}
{"name":"Computable.fin_app","module":"Mathlib.Computability.Partrec","initialProofState":"σ : Type u_4\ninst✝ : Primcodable σ\nn : Nat\n⊢ Computable₂ id","decl":"theorem fin_app {n} : Computable₂ (@id (Fin n → σ)) :=\n  Primrec.fin_app.to_comp\n\n"}
{"name":"Computable.encode","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Computable Encodable.encode","decl":"protected theorem encode : Computable (@encode α _) :=\n  Primrec.encode.to_comp\n\n"}
{"name":"Computable.decode","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Computable Encodable.decode","decl":"protected theorem decode : Computable (decode (α := α)) :=\n  Primrec.decode.to_comp\n\n"}
{"name":"Computable.ofNat","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_5\ninst✝ : Denumerable α\n⊢ Computable (Denumerable.ofNat α)","decl":"protected theorem ofNat (α) [Denumerable α] : Computable (ofNat α) :=\n  (Primrec.ofNat _).to_comp\n\n"}
{"name":"Computable.encode_iff","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_4\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf : α → σ\n⊢ Iff (Computable fun a => Encodable.encode (f a)) (Computable f)","decl":"theorem encode_iff {f : α → σ} : (Computable fun a => encode (f a)) ↔ Computable f :=\n  Iff.rfl\n\n"}
{"name":"Computable.option_some","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Computable Option.some","decl":"theorem option_some : Computable (@Option.some α) :=\n  Primrec.option_some.to_comp\n\n"}
{"name":"Partrec.of_eq","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_3\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf g : PFun α σ\nhf : Partrec f\nH : ∀ (n : α), Eq (f n) (g n)\n⊢ Partrec g","decl":"theorem of_eq {f g : α →. σ} (hf : Partrec f) (H : ∀ n, f n = g n) : Partrec g :=\n  (funext H : f = g) ▸ hf\n\n"}
{"name":"Partrec.of_eq_tot","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_3\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf : PFun α σ\ng : α → σ\nhf : Partrec f\nH : ∀ (n : α), Membership.mem (f n) (g n)\n⊢ Computable g","decl":"theorem of_eq_tot {f : α →. σ} {g : α → σ} (hf : Partrec f) (H : ∀ n, g n ∈ f n) : Computable g :=\n  hf.of_eq fun a => eq_some_iff.2 (H a)\n\n"}
{"name":"Partrec.none","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_3\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\n⊢ Partrec fun x => Part.none","decl":"theorem none : Partrec fun _ : α => @Part.none σ :=\n  Nat.Partrec.none.of_eq fun n => by cases decode (α := α) n <;> simp\n\n"}
{"name":"Partrec.some","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Partrec Part.some","decl":"protected theorem some : Partrec (@Part.some α) :=\n  Computable.id\n\n"}
{"name":"Decidable.Partrec.const'","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable σ\ns : Part σ\ninst✝ : Decidable s.Dom\n⊢ Partrec fun x => s","decl":"theorem _root_.Decidable.Partrec.const' (s : Part σ) [Decidable s.Dom] : Partrec fun _ : α => s :=\n  (Computable.ofOption (const (toOption s))).of_eq fun _ => of_toOption s\n\n"}
{"name":"Partrec.const'","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_3\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\ns : Part σ\n⊢ Partrec fun x => s","decl":"theorem const' (s : Part σ) : Partrec fun _ : α => s :=\n  haveI := Classical.dec s.Dom\n  Decidable.Partrec.const' s\n\n"}
{"name":"Partrec.bind","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : PFun α β\ng : α → PFun β σ\nhf : Partrec f\nhg : Partrec₂ g\n⊢ Partrec fun a => (f a).bind (g a)","decl":"protected theorem bind {f : α →. β} {g : α → β →. σ} (hf : Partrec f) (hg : Partrec₂ g) :\n    Partrec fun a => (f a).bind (g a) :=\n  (hg.comp (Nat.Partrec.some.pair hf)).of_eq fun n => by\n    simp [Seq.seq]; cases' e : decode (α := α) n with a <;> simp [e, encodek]\n\n"}
{"name":"Partrec.map","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : PFun α β\ng : α → β → σ\nhf : Partrec f\nhg : Computable₂ g\n⊢ Partrec fun a => Part.map (g a) (f a)","decl":"theorem map {f : α →. β} {g : α → β → σ} (hf : Partrec f) (hg : Computable₂ g) :\n    Partrec fun a => (f a).map (g a) := by\n  simpa [bind_some_eq_map] using Partrec.bind (g := fun a x => some (g a x)) hf hg\n\n"}
{"name":"Partrec.to₂","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : PFun (Prod α β) σ\nhf : Partrec f\n⊢ Partrec₂ fun a b => f { fst := a, snd := b }","decl":"theorem to₂ {f : α × β →. σ} (hf : Partrec f) : Partrec₂ fun a b => f (a, b) :=\n  hf.of_eq fun ⟨_, _⟩ => rfl\n\n"}
{"name":"Partrec.nat_rec","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_3\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf : α → Nat\ng : PFun α σ\nh : α → PFun (Prod Nat σ) σ\nhf : Computable f\nhg : Partrec g\nhh : Partrec₂ h\n⊢ Partrec fun a => Nat.rec (g a) (fun y IH => IH.bind fun i => h a { fst := y, snd := i }) (f a)","decl":"theorem nat_rec {f : α → ℕ} {g : α →. σ} {h : α → ℕ × σ →. σ} (hf : Computable f) (hg : Partrec g)\n    (hh : Partrec₂ h) : Partrec fun a => (f a).rec (g a) fun y IH => IH.bind fun i => h a (y, i) :=\n  (Nat.Partrec.prec' hf hg hh).of_eq fun n => by\n    cases' e : decode (α := α) n with a <;> simp [e]\n    induction' f a with m IH <;> simp\n    rw [IH, Part.bind_map]\n    congr; funext s\n    simp [encodek]\n\n"}
{"name":"Partrec.comp","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : PFun β σ\ng : α → β\nhf : Partrec f\nhg : Computable g\n⊢ Partrec fun a => f (g a)","decl":"nonrec theorem comp {f : β →. σ} {g : α → β} (hf : Partrec f) (hg : Computable g) :\n    Partrec fun a => f (g a) :=\n  (hf.comp hg).of_eq fun n => by simp; cases' e : decode (α := α) n with a <;> simp [e, encodek]\n\n"}
{"name":"Partrec.nat_iff","module":"Mathlib.Computability.Partrec","initialProofState":"f : PFun Nat Nat\n⊢ Iff (Partrec f) (Nat.Partrec f)","decl":"theorem nat_iff {f : ℕ →. ℕ} : Partrec f ↔ Nat.Partrec f := by simp [Partrec, map_id']\n\n"}
{"name":"Partrec.map_encode_iff","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_3\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf : PFun α σ\n⊢ Iff (Partrec fun a => Part.map Encodable.encode (f a)) (Partrec f)","decl":"theorem map_encode_iff {f : α →. σ} : (Partrec fun a => (f a).map encode) ↔ Partrec f :=\n  Iff.rfl\n\n"}
{"name":"Partrec₂.unpaired","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nf : Nat → PFun Nat α\n⊢ Iff (Partrec (Nat.unpaired f)) (Partrec₂ f)","decl":"theorem unpaired {f : ℕ → ℕ →. α} : Partrec (Nat.unpaired f) ↔ Partrec₂ f :=\n  ⟨fun h => by simpa using Partrec.comp (g := fun p : ℕ × ℕ => (p.1, p.2)) h Primrec₂.pair.to_comp,\n    fun h => h.comp Primrec.unpair.to_comp⟩\n\n"}
{"name":"Partrec₂.unpaired'","module":"Mathlib.Computability.Partrec","initialProofState":"f : Nat → PFun Nat Nat\n⊢ Iff (Nat.Partrec (Nat.unpaired f)) (Partrec₂ f)","decl":"theorem unpaired' {f : ℕ → ℕ →. ℕ} : Nat.Partrec (Nat.unpaired f) ↔ Partrec₂ f :=\n  Partrec.nat_iff.symm.trans unpaired\n\n"}
{"name":"Partrec₂.comp","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ : Type u_5\ninst✝³ : Primcodable α\ninst✝² : Primcodable β\ninst✝¹ : Primcodable γ\ninst✝ : Primcodable σ\nf : β → PFun γ σ\ng : α → β\nh : α → γ\nhf : Partrec₂ f\nhg : Computable g\nhh : Computable h\n⊢ Partrec fun a => f (g a) (h a)","decl":"nonrec theorem comp {f : β → γ →. σ} {g : α → β} {h : α → γ} (hf : Partrec₂ f) (hg : Computable g)\n    (hh : Computable h) : Partrec fun a => f (g a) (h a) :=\n  hf.comp (hg.pair hh)\n\n"}
{"name":"Partrec₂.comp₂","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nσ : Type u_5\ninst✝⁴ : Primcodable α\ninst✝³ : Primcodable β\ninst✝² : Primcodable γ\ninst✝¹ : Primcodable δ\ninst✝ : Primcodable σ\nf : γ → PFun δ σ\ng : α → β → γ\nh : α → β → δ\nhf : Partrec₂ f\nhg : Computable₂ g\nhh : Computable₂ h\n⊢ Partrec₂ fun a b => f (g a b) (h a b)","decl":"theorem comp₂ {f : γ → δ →. σ} {g : α → β → γ} {h : α → β → δ} (hf : Partrec₂ f)\n    (hg : Computable₂ g) (hh : Computable₂ h) : Partrec₂ fun a b => f (g a b) (h a b) :=\n  hf.comp hg hh\n\n"}
{"name":"Computable.comp","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_4\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : β → σ\ng : α → β\nhf : Computable f\nhg : Computable g\n⊢ Computable fun a => f (g a)","decl":"nonrec theorem comp {f : β → σ} {g : α → β} (hf : Computable f) (hg : Computable g) :\n    Computable fun a => f (g a) :=\n  hf.comp hg\n\n"}
{"name":"Computable.comp₂","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ : Type u_4\ninst✝³ : Primcodable α\ninst✝² : Primcodable β\ninst✝¹ : Primcodable γ\ninst✝ : Primcodable σ\nf : γ → σ\ng : α → β → γ\nhf : Computable f\nhg : Computable₂ g\n⊢ Computable₂ fun a b => f (g a b)","decl":"theorem comp₂ {f : γ → σ} {g : α → β → γ} (hf : Computable f) (hg : Computable₂ g) :\n    Computable₂ fun a b => f (g a b) :=\n  hf.comp hg\n\n"}
{"name":"Computable₂.mk","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_5\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → β → σ\nhf : Computable fun p => f p.1 p.2\n⊢ Computable₂ f","decl":"theorem mk {f : α → β → σ} (hf : Computable fun p : α × β => f p.1 p.2) : Computable₂ f := hf\n\n"}
{"name":"Computable₂.comp","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ : Type u_5\ninst✝³ : Primcodable α\ninst✝² : Primcodable β\ninst✝¹ : Primcodable γ\ninst✝ : Primcodable σ\nf : β → γ → σ\ng : α → β\nh : α → γ\nhf : Computable₂ f\nhg : Computable g\nhh : Computable h\n⊢ Computable fun a => f (g a) (h a)","decl":"nonrec theorem comp {f : β → γ → σ} {g : α → β} {h : α → γ} (hf : Computable₂ f)\n    (hg : Computable g) (hh : Computable h) : Computable fun a => f (g a) (h a) :=\n  hf.comp (hg.pair hh)\n\n"}
{"name":"Computable₂.comp₂","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nσ : Type u_5\ninst✝⁴ : Primcodable α\ninst✝³ : Primcodable β\ninst✝² : Primcodable γ\ninst✝¹ : Primcodable δ\ninst✝ : Primcodable σ\nf : γ → δ → σ\ng : α → β → γ\nh : α → β → δ\nhf : Computable₂ f\nhg : Computable₂ g\nhh : Computable₂ h\n⊢ Computable₂ fun a b => f (g a b) (h a b)","decl":"theorem comp₂ {f : γ → δ → σ} {g : α → β → γ} {h : α → β → δ} (hf : Computable₂ f)\n    (hg : Computable₂ g) (hh : Computable₂ h) : Computable₂ fun a b => f (g a b) (h a b) :=\n  hf.comp hg hh\n\n"}
{"name":"Partrec.rfind","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\np : α → PFun Nat Bool\nhp : Partrec₂ p\n⊢ Partrec fun a => Nat.rfind (p a)","decl":"theorem rfind {p : α → ℕ →. Bool} (hp : Partrec₂ p) : Partrec fun a => Nat.rfind (p a) :=\n  (Nat.Partrec.rfind <|\n        hp.map ((Primrec.dom_bool fun b => cond b 0 1).comp Primrec.snd).to₂.to_comp).of_eq\n    fun n => by\n    cases' e : decode (α := α) n with a <;> simp [e, Nat.rfind_zero_none, map_id']\n    congr; funext n\n    simp only [map_map, Function.comp]\n    refine map_id' (fun b => ?_) _\n    cases b <;> rfl\n\n"}
{"name":"Partrec.rfindOpt","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf : α → Nat → Option σ\nhf : Computable₂ f\n⊢ Partrec fun a => Nat.rfindOpt (f a)","decl":"theorem rfindOpt {f : α → ℕ → Option σ} (hf : Computable₂ f) :\n    Partrec fun a => Nat.rfindOpt (f a) :=\n  (rfind (Primrec.option_isSome.to_comp.comp hf).partrec.to₂).bind (ofOption hf)\n\n"}
{"name":"Partrec.nat_casesOn_right","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf : α → Nat\ng : α → σ\nh : α → PFun Nat σ\nhf : Computable f\nhg : Computable g\nhh : Partrec₂ h\n⊢ Partrec fun a => Nat.casesOn (f a) (Part.some (g a)) (h a)","decl":"theorem nat_casesOn_right {f : α → ℕ} {g : α → σ} {h : α → ℕ →. σ} (hf : Computable f)\n    (hg : Computable g) (hh : Partrec₂ h) : Partrec fun a => (f a).casesOn (some (g a)) (h a) :=\n  (nat_rec hf hg (hh.comp fst (pred.comp <| hf.comp fst)).to₂).of_eq fun a => by\n    simp only [PFun.coe_val, Nat.pred_eq_sub_one]; cases' f a with n <;> simp\n    refine ext fun b => ⟨fun H => ?_, fun H => ?_⟩\n    · rcases mem_bind_iff.1 H with ⟨c, _, h₂⟩\n      exact h₂\n    · have : ∀ m, (Nat.rec (motive := fun _ => Part σ)\n          (Part.some (g a)) (fun y IH => IH.bind fun _ => h a n) m).Dom := by\n        intro m\n        induction m <;> simp [*, H.fst]\n      exact ⟨⟨this n, H.fst⟩, H.snd⟩\n\n"}
{"name":"Partrec.bind_decode₂_iff","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf : PFun α σ\n⊢ Iff (Partrec f) (Nat.Partrec fun n => (↑(Encodable.decode₂ α n)).bind fun a => Part.map Encodable.encode (f a))","decl":"theorem bind_decode₂_iff {f : α →. σ} :\n    Partrec f ↔ Nat.Partrec fun n => Part.bind (decode₂ α n) fun a => (f a).map encode :=\n  ⟨fun hf =>\n    nat_iff.1 <|\n      (Computable.ofOption Primrec.decode₂.to_comp).bind <|\n        (map hf (Computable.encode.comp snd).to₂).comp snd,\n    fun h =>\n    map_encode_iff.1 <| by simpa [encodek₂] using (nat_iff.2 h).comp (@Computable.encode α _)⟩\n\n"}
{"name":"Partrec.vector_mOfFn","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nn : Nat\nf : Fin n → PFun α σ\na✝ : ∀ (i : Fin n), Partrec (f i)\n⊢ Partrec fun a => List.Vector.mOfFn fun i => f i a","decl":"theorem vector_mOfFn :\n    ∀ {n} {f : Fin n → α →. σ},\n      (∀ i, Partrec (f i)) → Partrec fun a : α => Vector.mOfFn fun i => f i a\n  | 0, _, _ => const _\n  | n + 1, f, hf => by\n    simp only [Vector.mOfFn, Nat.add_eq, Nat.add_zero, pure_eq_some, bind_eq_bind]\n    exact\n      (hf 0).bind\n        (Partrec.bind ((vector_mOfFn fun i => hf i.succ).comp fst)\n          (Primrec.vector_cons.to_comp.comp (snd.comp fst) snd))\n\n"}
{"name":"Vector.mOfFn_part_some","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nn : Nat\nf : Fin n → α\n⊢ Eq (List.Vector.mOfFn fun i => Part.some (f i)) (Part.some (List.Vector.ofFn f))","decl":"@[simp]\ntheorem Vector.mOfFn_part_some {α n} :\n    ∀ f : Fin n → α,\n      (List.Vector.mOfFn fun i => Part.some (f i)) = Part.some (List.Vector.ofFn f) :=\n  Vector.mOfFn_pure\n\n"}
{"name":"Computable.option_some_iff","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_4\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf : α → σ\n⊢ Iff (Computable fun a => Option.some (f a)) (Computable f)","decl":"theorem option_some_iff {f : α → σ} : (Computable fun a => Option.some (f a)) ↔ Computable f :=\n  ⟨fun h => encode_iff.1 <| Primrec.pred.to_comp.comp <| encode_iff.2 h, option_some.comp⟩\n\n"}
{"name":"Computable.bind_decode_iff","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_4\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → β → Option σ\n⊢ Iff (Computable₂ fun a n => (Encodable.decode n).bind (f a)) (Computable₂ f)","decl":"theorem bind_decode_iff {f : α → β → Option σ} :\n    (Computable₂ fun a n => (decode (α := β) n).bind (f a)) ↔ Computable₂ f :=\n  ⟨fun hf =>\n    Nat.Partrec.of_eq\n      (((Partrec.nat_iff.2\n        (Nat.Partrec.ppred.comp <| Nat.Partrec.of_primrec <| Primcodable.prim (α := β))).comp\n            snd).bind\n        (Computable.comp hf fst).to₂.partrec₂)\n      fun n => by\n        simp only [decode_prod_val, decode_nat, Option.map_some', PFun.coe_val, bind_eq_bind,\n          bind_some, Part.map_bind, map_some]\n        cases decode (α := α) n.unpair.1 <;> simp\n        cases decode (α := β) n.unpair.2 <;> simp,\n    fun hf => by\n    have :\n      Partrec fun a : α × ℕ =>\n        (encode (decode (α := β) a.2)).casesOn (some Option.none)\n          fun n => Part.map (f a.1) (decode (α := β) n) :=\n      Partrec.nat_casesOn_right\n        (h := fun (a : α × ℕ) (n : ℕ) ↦ map (fun b ↦ f a.1 b) (Part.ofOption (decode n)))\n        (Primrec.encdec.to_comp.comp snd) (const Option.none)\n        ((ofOption (Computable.decode.comp snd)).map (hf.comp (fst.comp <| fst.comp fst) snd).to₂)\n    refine this.of_eq fun a => ?_\n    simp; cases decode (α := β) a.2 <;> simp [encodek]⟩\n\n"}
{"name":"Computable.map_decode_iff","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_4\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → β → σ\n⊢ Iff (Computable₂ fun a n => Option.map (f a) (Encodable.decode n)) (Computable₂ f)","decl":"theorem map_decode_iff {f : α → β → σ} :\n    (Computable₂ fun a n => (decode (α := β) n).map (f a)) ↔ Computable₂ f := by\n  convert (bind_decode_iff (f := fun a => Option.some ∘ f a)).trans option_some_iff\n  apply Option.map_eq_bind\n\n"}
{"name":"Computable.nat_rec","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_4\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf : α → Nat\ng : α → σ\nh : α → Prod Nat σ → σ\nhf : Computable f\nhg : Computable g\nhh : Computable₂ h\n⊢ Computable fun a => Nat.rec (g a) (fun y IH => h a { fst := y, snd := IH }) (f a)","decl":"theorem nat_rec {f : α → ℕ} {g : α → σ} {h : α → ℕ × σ → σ} (hf : Computable f) (hg : Computable g)\n    (hh : Computable₂ h) :\n    Computable fun a => Nat.rec (motive := fun _ => σ) (g a) (fun y IH => h a (y, IH)) (f a) :=\n  (Partrec.nat_rec hf hg hh.partrec₂).of_eq fun a => by simp; induction f a <;> simp [*]\n\n"}
{"name":"Computable.nat_casesOn","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_4\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf : α → Nat\ng : α → σ\nh : α → Nat → σ\nhf : Computable f\nhg : Computable g\nhh : Computable₂ h\n⊢ Computable fun a => Nat.casesOn (f a) (g a) (h a)","decl":"theorem nat_casesOn {f : α → ℕ} {g : α → σ} {h : α → ℕ → σ} (hf : Computable f) (hg : Computable g)\n    (hh : Computable₂ h) :\n    Computable fun a => Nat.casesOn (motive := fun _ => σ) (f a) (g a) (h a) :=\n  nat_rec hf hg (hh.comp fst <| fst.comp snd).to₂\n\n"}
{"name":"Computable.cond","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_4\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nc : α → Bool\nf g : α → σ\nhc : Computable c\nhf : Computable f\nhg : Computable g\n⊢ Computable fun a => cond (c a) (f a) (g a)","decl":"theorem cond {c : α → Bool} {f : α → σ} {g : α → σ} (hc : Computable c) (hf : Computable f)\n    (hg : Computable g) : Computable fun a => cond (c a) (f a) (g a) :=\n  (nat_casesOn (encode_iff.2 hc) hg (hf.comp fst).to₂).of_eq fun a => by cases c a <;> rfl\n\n"}
{"name":"Computable.option_casesOn","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_4\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\no : α → Option β\nf : α → σ\ng : α → β → σ\nho : Computable o\nhf : Computable f\nhg : Computable₂ g\n⊢ Computable fun a => Option.casesOn (o a) (f a) (g a)","decl":"theorem option_casesOn {o : α → Option β} {f : α → σ} {g : α → β → σ} (ho : Computable o)\n    (hf : Computable f) (hg : Computable₂ g) :\n    @Computable _ σ _ _ fun a => Option.casesOn (o a) (f a) (g a) :=\n  option_some_iff.1 <|\n    (nat_casesOn (encode_iff.2 ho) (option_some_iff.2 hf) (map_decode_iff.2 hg)).of_eq fun a => by\n      cases o a <;> simp [encodek]\n\n"}
{"name":"Computable.option_bind","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_4\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → Option β\ng : α → β → Option σ\nhf : Computable f\nhg : Computable₂ g\n⊢ Computable fun a => (f a).bind (g a)","decl":"theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)\n    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=\n  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl\n\n"}
{"name":"Computable.option_map","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_4\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → Option β\ng : α → β → σ\nhf : Computable f\nhg : Computable₂ g\n⊢ Computable fun a => Option.map (g a) (f a)","decl":"theorem option_map {f : α → Option β} {g : α → β → σ} (hf : Computable f) (hg : Computable₂ g) :\n    Computable fun a => (f a).map (g a) := by\n  convert option_bind hf (option_some.comp₂ hg)\n  apply Option.map_eq_bind\n\n"}
{"name":"Computable.option_getD","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable β\nf : α → Option β\ng : α → β\nhf : Computable f\nhg : Computable g\n⊢ Computable fun a => (f a).getD (g a)","decl":"theorem option_getD {f : α → Option β} {g : α → β} (hf : Computable f) (hg : Computable g) :\n    Computable fun a => (f a).getD (g a) :=\n  (Computable.option_casesOn hf hg (show Computable₂ fun _ b => b from Computable.snd)).of_eq\n    fun a => by cases f a <;> rfl\n\n"}
{"name":"Computable.subtype_mk","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\nf : α → β\np : β → Prop\ninst✝ : DecidablePred p\nh : ∀ (a : α), p (f a)\nhp : PrimrecPred p\nhf : Computable f\n⊢ Computable fun a => ⟨f a, ⋯⟩","decl":"theorem subtype_mk {f : α → β} {p : β → Prop} [DecidablePred p] {h : ∀ a, p (f a)}\n    (hp : PrimrecPred p) (hf : Computable f) :\n    @Computable _ _ _ (Primcodable.subtype hp) fun a => (⟨f a, h a⟩ : Subtype p) :=\n  hf\n\n"}
{"name":"Computable.sum_casesOn","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ : Type u_4\ninst✝³ : Primcodable α\ninst✝² : Primcodable β\ninst✝¹ : Primcodable γ\ninst✝ : Primcodable σ\nf : α → Sum β γ\ng : α → β → σ\nh : α → γ → σ\nhf : Computable f\nhg : Computable₂ g\nhh : Computable₂ h\n⊢ Computable fun a => Sum.casesOn (f a) (g a) (h a)","decl":"theorem sum_casesOn {f : α → β ⊕ γ} {g : α → β → σ} {h : α → γ → σ} (hf : Computable f)\n    (hg : Computable₂ g) (hh : Computable₂ h) :\n    @Computable _ σ _ _ fun a => Sum.casesOn (f a) (g a) (h a) :=\n  option_some_iff.1 <|\n    (cond (nat_bodd.comp <| encode_iff.2 hf)\n          (option_map (Computable.decode.comp <| nat_div2.comp <| encode_iff.2 hf) hh)\n          (option_map (Computable.decode.comp <| nat_div2.comp <| encode_iff.2 hf) hg)).of_eq\n      fun a => by\n        cases' f a with b c <;> simp [Nat.div2_val]\n\n"}
{"name":"Computable.nat_strong_rec","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_4\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf : α → Nat → σ\ng : α → List σ → Option σ\nhg : Computable₂ g\nH : ∀ (a : α) (n : Nat), Eq (g a (List.map (f a) (List.range n))) (Option.some (f a n))\n⊢ Computable₂ f","decl":"theorem nat_strong_rec (f : α → ℕ → σ) {g : α → List σ → Option σ} (hg : Computable₂ g)\n    (H : ∀ a n, g a ((List.range n).map (f a)) = Option.some (f a n)) : Computable₂ f :=\n  suffices Computable₂ fun a n => (List.range n).map (f a) from\n    option_some_iff.1 <|\n      (list_get?.comp (this.comp fst (succ.comp snd)) snd).to₂.of_eq fun a => by\n        simp [List.getElem?_range (Nat.lt_succ_self a.2)]\n  option_some_iff.1 <|\n    (nat_rec snd (const (Option.some []))\n          (to₂ <|\n            option_bind (snd.comp snd) <|\n              to₂ <|\n                option_map (hg.comp (fst.comp <| fst.comp fst) snd)\n                  (to₂ <| list_concat.comp (snd.comp fst) snd))).of_eq\n      fun a => by\n      induction' a.2 with n IH; · rfl\n      simp [IH, H, List.range_succ]\n\n"}
{"name":"Computable.list_ofFn","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_4\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nn : Nat\nf : Fin n → α → σ\na✝ : ∀ (i : Fin n), Computable (f i)\n⊢ Computable fun a => List.ofFn fun i => f i a","decl":"theorem list_ofFn :\n    ∀ {n} {f : Fin n → α → σ},\n      (∀ i, Computable (f i)) → Computable fun a => List.ofFn fun i => f i a\n  | 0, _, _ => by\n    simp only [List.ofFn_zero]\n    exact const []\n  | n + 1, f, hf => by\n    simp only [List.ofFn_succ]\n    exact list_cons.comp (hf 0) (list_ofFn fun i => hf i.succ)\n\n"}
{"name":"Computable.vector_ofFn","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_4\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nn : Nat\nf : Fin n → α → σ\nhf : ∀ (i : Fin n), Computable (f i)\n⊢ Computable fun a => List.Vector.ofFn fun i => f i a","decl":"theorem vector_ofFn {n} {f : Fin n → α → σ} (hf : ∀ i, Computable (f i)) :\n    Computable fun a => List.Vector.ofFn fun i => f i a :=\n  (Partrec.vector_mOfFn hf).of_eq fun a => by simp\n\n"}
{"name":"Partrec.option_some_iff","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_4\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf : PFun α σ\n⊢ Iff (Partrec fun a => Part.map Option.some (f a)) (Partrec f)","decl":"theorem option_some_iff {f : α →. σ} : (Partrec fun a => (f a).map Option.some) ↔ Partrec f :=\n  ⟨fun h => (Nat.Partrec.ppred.comp h).of_eq fun n => by simp [Part.bind_assoc, bind_some_eq_map],\n    fun hf => hf.map (option_some.comp snd).to₂⟩\n\n"}
{"name":"Partrec.option_casesOn_right","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_4\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\no : α → Option β\nf : α → σ\ng : α → PFun β σ\nho : Computable o\nhf : Computable f\nhg : Partrec₂ g\n⊢ Partrec fun a => Option.casesOn (o a) (Part.some (f a)) (g a)","decl":"theorem option_casesOn_right {o : α → Option β} {f : α → σ} {g : α → β →. σ} (ho : Computable o)\n    (hf : Computable f) (hg : Partrec₂ g) :\n    @Partrec _ σ _ _ fun a => Option.casesOn (o a) (Part.some (f a)) (g a) :=\n  have :\n    Partrec fun a : α =>\n      Nat.casesOn (encode (o a)) (Part.some (f a)) (fun n => Part.bind (decode (α := β) n) (g a)) :=\n    nat_casesOn_right (h := fun a n ↦ Part.bind (ofOption (decode n)) fun b ↦ g a b)\n      (encode_iff.2 ho) hf.partrec <|\n        ((@Computable.decode β _).comp snd).ofOption.bind (hg.comp (fst.comp fst) snd).to₂\n  this.of_eq fun a => by cases' o a with b <;> simp [encodek]\n\n"}
{"name":"Partrec.sum_casesOn_right","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ : Type u_4\ninst✝³ : Primcodable α\ninst✝² : Primcodable β\ninst✝¹ : Primcodable γ\ninst✝ : Primcodable σ\nf : α → Sum β γ\ng : α → β → σ\nh : α → PFun γ σ\nhf : Computable f\nhg : Computable₂ g\nhh : Partrec₂ h\n⊢ Partrec fun a => Sum.casesOn (f a) (fun b => Part.some (g a b)) (h a)","decl":"theorem sum_casesOn_right {f : α → β ⊕ γ} {g : α → β → σ} {h : α → γ →. σ} (hf : Computable f)\n    (hg : Computable₂ g) (hh : Partrec₂ h) :\n    @Partrec _ σ _ _ fun a => Sum.casesOn (f a) (fun b => Part.some (g a b)) (h a) :=\n  have :\n    Partrec fun a =>\n      (Option.casesOn (Sum.casesOn (f a) (fun _ => Option.none) Option.some : Option γ)\n          (some (Sum.casesOn (f a) (fun b => some (g a b)) fun _ => Option.none)) fun c =>\n          (h a c).map Option.some :\n        Part (Option σ)) :=\n    option_casesOn_right (g := fun a n => Part.map Option.some (h a n))\n      (sum_casesOn hf (const Option.none).to₂ (option_some.comp snd).to₂)\n      (sum_casesOn (g := fun a n => Option.some (g a n)) hf (option_some.comp hg)\n        (const Option.none).to₂)\n      (option_some_iff.2 hh)\n  option_some_iff.1 <| this.of_eq fun a => by cases f a <;> simp\n\n"}
{"name":"Partrec.sum_casesOn_left","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ : Type u_4\ninst✝³ : Primcodable α\ninst✝² : Primcodable β\ninst✝¹ : Primcodable γ\ninst✝ : Primcodable σ\nf : α → Sum β γ\ng : α → PFun β σ\nh : α → γ → σ\nhf : Computable f\nhg : Partrec₂ g\nhh : Computable₂ h\n⊢ Partrec fun a => Sum.casesOn (f a) (g a) fun c => Part.some (h a c)","decl":"theorem sum_casesOn_left {f : α → β ⊕ γ} {g : α → β →. σ} {h : α → γ → σ} (hf : Computable f)\n    (hg : Partrec₂ g) (hh : Computable₂ h) :\n    @Partrec _ σ _ _ fun a => Sum.casesOn (f a) (g a) fun c => Part.some (h a c) :=\n  (sum_casesOn_right (sum_casesOn hf (sum_inr.comp snd).to₂ (sum_inl.comp snd).to₂) hh hg).of_eq\n    fun a => by cases f a <;> simp\n\n"}
{"name":"Partrec.fix_aux","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_5\nσ : Type u_6\nf : PFun α (Sum σ α)\na : α\nb : σ\n⊢ let F := fun a n => Nat.rec (Part.some (Sum.inr a)) (fun x IH => IH.bind fun s => Sum.casesOn s (fun x => Part.some s) f) n;\n  Iff (Exists fun n => And (And (Exists fun b' => Membership.mem (F a n) (Sum.inl b')) (∀ {m : Nat}, LT.lt m n → Exists fun b => Membership.mem (F a m) (Sum.inr b))) (Membership.mem (F a n) (Sum.inl b))) (Membership.mem (f.fix a) b)","decl":"theorem fix_aux {α σ} (f : α →. σ ⊕ α) (a : α) (b : σ) :\n    let F : α → ℕ →. σ ⊕ α := fun a n =>\n      n.rec (some (Sum.inr a)) fun _ IH => IH.bind fun s => Sum.casesOn s (fun _ => Part.some s) f\n    (∃ n : ℕ,\n        ((∃ b' : σ, Sum.inl b' ∈ F a n) ∧ ∀ {m : ℕ}, m < n → ∃ b : α, Sum.inr b ∈ F a m) ∧\n          Sum.inl b ∈ F a n) ↔\n      b ∈ PFun.fix f a := by\n  intro F; refine ⟨fun h => ?_, fun h => ?_⟩\n  · rcases h with ⟨n, ⟨_x, h₁⟩, h₂⟩\n    have : ∀ m a', Sum.inr a' ∈ F a m → b ∈ PFun.fix f a' → b ∈ PFun.fix f a := by\n      intro m a' am ba\n      induction' m with m IH generalizing a' <;> simp [F] at am\n      · rwa [← am]\n      rcases am with ⟨a₂, am₂, fa₂⟩\n      exact IH _ am₂ (PFun.mem_fix_iff.2 (Or.inr ⟨_, fa₂, ba⟩))\n    cases n <;> simp [F] at h₂\n    rcases h₂ with (h₂ | ⟨a', am', fa'⟩)\n    · cases' h₁ (Nat.lt_succ_self _) with a' h\n      injection mem_unique h h₂\n    · exact this _ _ am' (PFun.mem_fix_iff.2 (Or.inl fa'))\n  · suffices ∀ a', b ∈ PFun.fix f a' → ∀ k, Sum.inr a' ∈ F a k →\n        ∃ n, Sum.inl b ∈ F a n ∧ ∀ m < n, k ≤ m → ∃ a₂, Sum.inr a₂ ∈ F a m by\n      rcases this _ h 0 (by simp [F]) with ⟨n, hn₁, hn₂⟩\n      exact ⟨_, ⟨⟨_, hn₁⟩, fun {m} mn => hn₂ m mn (Nat.zero_le _)⟩, hn₁⟩\n    intro a₁ h₁\n    apply @PFun.fixInduction _ _ _ _ _ _ h₁\n    intro a₂ h₂ IH k hk\n    rcases PFun.mem_fix_iff.1 h₂ with (h₂ | ⟨a₃, am₃, _⟩)\n    · refine ⟨k.succ, ?_, fun m mk km => ⟨a₂, ?_⟩⟩\n      · simpa [F] using Or.inr ⟨_, hk, h₂⟩\n      · rwa [le_antisymm (Nat.le_of_lt_succ mk) km]\n    · rcases IH _ am₃ k.succ (by simpa [F] using ⟨_, hk, am₃⟩) with ⟨n, hn₁, hn₂⟩\n      refine ⟨n, hn₁, fun m mn km => ?_⟩\n      cases' km.lt_or_eq_dec with km km\n      · exact hn₂ _ mn km\n      · exact km ▸ ⟨_, hk⟩\n\n"}
{"name":"Partrec.fix","module":"Mathlib.Computability.Partrec","initialProofState":"α : Type u_1\nσ : Type u_4\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf : PFun α (Sum σ α)\nhf : Partrec f\n⊢ Partrec f.fix","decl":"theorem fix {f : α →. σ ⊕ α} (hf : Partrec f) : Partrec (PFun.fix f) := by\n  let F : α → ℕ →. σ ⊕ α := fun a n =>\n    n.rec (some (Sum.inr a)) fun _ IH => IH.bind fun s => Sum.casesOn s (fun _ => Part.some s) f\n  have hF : Partrec₂ F :=\n    Partrec.nat_rec snd (sum_inr.comp fst).partrec\n      (sum_casesOn_right (snd.comp snd) (snd.comp <| snd.comp fst).to₂ (hf.comp snd).to₂).to₂\n  let p a n := @Part.map _ Bool (fun s => Sum.casesOn s (fun _ => true) fun _ => false) (F a n)\n  have hp : Partrec₂ p :=\n    hF.map ((sum_casesOn Computable.id (const true).to₂ (const false).to₂).comp snd).to₂\n  exact (hp.rfind.bind (hF.bind (sum_casesOn_right snd snd.to₂ none.to₂).to₂).to₂).of_eq fun a =>\n    ext fun b => by simpa [p] using fix_aux f _ _\n\n"}
