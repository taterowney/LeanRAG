{"name":"CategoryTheory.Square.fac","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.f‚ÇÅ‚ÇÇ self.f‚ÇÇ‚ÇÑ) (CategoryTheory.CategoryStruct.comp self.f‚ÇÅ‚ÇÉ self.f‚ÇÉ‚ÇÑ)","decl":"/-- The category of commutative squares in a category. -/\nstructure Square where\n  /-- the top-left object -/\n  {X‚ÇÅ : C}\n  /-- the top-right object -/\n  {X‚ÇÇ : C}\n  /-- the bottom-left object -/\n  {X‚ÇÉ : C}\n  /-- the bottom-right object -/\n  {X‚ÇÑ : C}\n  /-- the top morphism -/\n  f‚ÇÅ‚ÇÇ : X‚ÇÅ ‚ü∂ X‚ÇÇ\n  /-- the left morphism -/\n  f‚ÇÅ‚ÇÉ : X‚ÇÅ ‚ü∂ X‚ÇÉ\n  /-- the right morphism -/\n  f‚ÇÇ‚ÇÑ : X‚ÇÇ ‚ü∂ X‚ÇÑ\n  /-- the bottom morphism -/\n  f‚ÇÉ‚ÇÑ : X‚ÇÉ ‚ü∂ X‚ÇÑ\n  fac : f‚ÇÅ‚ÇÇ ‚â´ f‚ÇÇ‚ÇÑ = f‚ÇÅ‚ÇÉ ‚â´ f‚ÇÉ‚ÇÑ\n\n"}
{"name":"CategoryTheory.Square.mk.injEq","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚ÇÅ‚úù X‚ÇÇ‚úù X‚ÇÉ‚úù X‚ÇÑ‚úù : C\nf‚ÇÅ‚ÇÇ‚úù : Quiver.Hom X‚ÇÅ‚úù X‚ÇÇ‚úù\nf‚ÇÅ‚ÇÉ‚úù : Quiver.Hom X‚ÇÅ‚úù X‚ÇÉ‚úù\nf‚ÇÇ‚ÇÑ‚úù : Quiver.Hom X‚ÇÇ‚úù X‚ÇÑ‚úù\nf‚ÇÉ‚ÇÑ‚úù : Quiver.Hom X‚ÇÉ‚úù X‚ÇÑ‚úù\nfac‚úù : Eq (CategoryTheory.CategoryStruct.comp f‚ÇÅ‚ÇÇ‚úù f‚ÇÇ‚ÇÑ‚úù) (CategoryTheory.CategoryStruct.comp f‚ÇÅ‚ÇÉ‚úù f‚ÇÉ‚ÇÑ‚úù)\nX‚ÇÅ X‚ÇÇ X‚ÇÉ X‚ÇÑ : C\nf‚ÇÅ‚ÇÇ : Quiver.Hom X‚ÇÅ X‚ÇÇ\nf‚ÇÅ‚ÇÉ : Quiver.Hom X‚ÇÅ X‚ÇÉ\nf‚ÇÇ‚ÇÑ : Quiver.Hom X‚ÇÇ X‚ÇÑ\nf‚ÇÉ‚ÇÑ : Quiver.Hom X‚ÇÉ X‚ÇÑ\nfac : Eq (CategoryTheory.CategoryStruct.comp f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÑ) (CategoryTheory.CategoryStruct.comp f‚ÇÅ‚ÇÉ f‚ÇÉ‚ÇÑ)\n‚ä¢ Eq (Eq (CategoryTheory.Square.mk f‚ÇÅ‚ÇÇ‚úù f‚ÇÅ‚ÇÉ‚úù f‚ÇÇ‚ÇÑ‚úù f‚ÇÉ‚ÇÑ‚úù fac‚úù) (CategoryTheory.Square.mk f‚ÇÅ‚ÇÇ f‚ÇÅ‚ÇÉ f‚ÇÇ‚ÇÑ f‚ÇÉ‚ÇÑ fac)) (And (Eq X‚ÇÅ‚úù X‚ÇÅ) (And (Eq X‚ÇÇ‚úù X‚ÇÇ) (And (Eq X‚ÇÉ‚úù X‚ÇÉ) (And (Eq X‚ÇÑ‚úù X‚ÇÑ) (And (HEq f‚ÇÅ‚ÇÇ‚úù f‚ÇÅ‚ÇÇ) (And (HEq f‚ÇÅ‚ÇÉ‚úù f‚ÇÅ‚ÇÉ) (And (HEq f‚ÇÇ‚ÇÑ‚úù f‚ÇÇ‚ÇÑ) (HEq f‚ÇÉ‚ÇÑ‚úù f‚ÇÉ‚ÇÑ))))))))","decl":"/-- The category of commutative squares in a category. -/\nstructure Square where\n  /-- the top-left object -/\n  {X‚ÇÅ : C}\n  /-- the top-right object -/\n  {X‚ÇÇ : C}\n  /-- the bottom-left object -/\n  {X‚ÇÉ : C}\n  /-- the bottom-right object -/\n  {X‚ÇÑ : C}\n  /-- the top morphism -/\n  f‚ÇÅ‚ÇÇ : X‚ÇÅ ‚ü∂ X‚ÇÇ\n  /-- the left morphism -/\n  f‚ÇÅ‚ÇÉ : X‚ÇÅ ‚ü∂ X‚ÇÉ\n  /-- the right morphism -/\n  f‚ÇÇ‚ÇÑ : X‚ÇÇ ‚ü∂ X‚ÇÑ\n  /-- the bottom morphism -/\n  f‚ÇÉ‚ÇÑ : X‚ÇÉ ‚ü∂ X‚ÇÑ\n  fac : f‚ÇÅ‚ÇÇ ‚â´ f‚ÇÇ‚ÇÑ = f‚ÇÅ‚ÇÉ ‚â´ f‚ÇÉ‚ÇÑ\n\n"}
{"name":"CategoryTheory.Square.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : SizeOf C\nX‚ÇÅ X‚ÇÇ X‚ÇÉ X‚ÇÑ : C\nf‚ÇÅ‚ÇÇ : Quiver.Hom X‚ÇÅ X‚ÇÇ\nf‚ÇÅ‚ÇÉ : Quiver.Hom X‚ÇÅ X‚ÇÉ\nf‚ÇÇ‚ÇÑ : Quiver.Hom X‚ÇÇ X‚ÇÑ\nf‚ÇÉ‚ÇÑ : Quiver.Hom X‚ÇÉ X‚ÇÑ\nfac : Eq (CategoryTheory.CategoryStruct.comp f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÑ) (CategoryTheory.CategoryStruct.comp f‚ÇÅ‚ÇÉ f‚ÇÉ‚ÇÑ)\n‚ä¢ Eq (SizeOf.sizeOf (CategoryTheory.Square.mk f‚ÇÅ‚ÇÇ f‚ÇÅ‚ÇÉ f‚ÇÇ‚ÇÑ f‚ÇÉ‚ÇÑ fac)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf X‚ÇÅ)) (SizeOf.sizeOf X‚ÇÇ)) (SizeOf.sizeOf X‚ÇÉ)) (SizeOf.sizeOf X‚ÇÑ)) (SizeOf.sizeOf f‚ÇÅ‚ÇÇ)) (SizeOf.sizeOf f‚ÇÅ‚ÇÉ)) (SizeOf.sizeOf f‚ÇÇ‚ÇÑ)) (SizeOf.sizeOf f‚ÇÉ‚ÇÑ)) (SizeOf.sizeOf fac))","decl":"/-- The category of commutative squares in a category. -/\nstructure Square where\n  /-- the top-left object -/\n  {X‚ÇÅ : C}\n  /-- the top-right object -/\n  {X‚ÇÇ : C}\n  /-- the bottom-left object -/\n  {X‚ÇÉ : C}\n  /-- the bottom-right object -/\n  {X‚ÇÑ : C}\n  /-- the top morphism -/\n  f‚ÇÅ‚ÇÇ : X‚ÇÅ ‚ü∂ X‚ÇÇ\n  /-- the left morphism -/\n  f‚ÇÅ‚ÇÉ : X‚ÇÅ ‚ü∂ X‚ÇÉ\n  /-- the right morphism -/\n  f‚ÇÇ‚ÇÑ : X‚ÇÇ ‚ü∂ X‚ÇÑ\n  /-- the bottom morphism -/\n  f‚ÇÉ‚ÇÑ : X‚ÇÉ ‚ü∂ X‚ÇÑ\n  fac : f‚ÇÅ‚ÇÇ ‚â´ f‚ÇÇ‚ÇÑ = f‚ÇÅ‚ÇÉ ‚â´ f‚ÇÉ‚ÇÑ\n\n"}
{"name":"CategoryTheory.Square.mk.inj","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚ÇÅ‚úù X‚ÇÇ‚úù X‚ÇÉ‚úù X‚ÇÑ‚úù : C\nf‚ÇÅ‚ÇÇ‚úù : Quiver.Hom X‚ÇÅ‚úù X‚ÇÇ‚úù\nf‚ÇÅ‚ÇÉ‚úù : Quiver.Hom X‚ÇÅ‚úù X‚ÇÉ‚úù\nf‚ÇÇ‚ÇÑ‚úù : Quiver.Hom X‚ÇÇ‚úù X‚ÇÑ‚úù\nf‚ÇÉ‚ÇÑ‚úù : Quiver.Hom X‚ÇÉ‚úù X‚ÇÑ‚úù\nfac‚úù : Eq (CategoryTheory.CategoryStruct.comp f‚ÇÅ‚ÇÇ‚úù f‚ÇÇ‚ÇÑ‚úù) (CategoryTheory.CategoryStruct.comp f‚ÇÅ‚ÇÉ‚úù f‚ÇÉ‚ÇÑ‚úù)\nX‚ÇÅ X‚ÇÇ X‚ÇÉ X‚ÇÑ : C\nf‚ÇÅ‚ÇÇ : Quiver.Hom X‚ÇÅ X‚ÇÇ\nf‚ÇÅ‚ÇÉ : Quiver.Hom X‚ÇÅ X‚ÇÉ\nf‚ÇÇ‚ÇÑ : Quiver.Hom X‚ÇÇ X‚ÇÑ\nf‚ÇÉ‚ÇÑ : Quiver.Hom X‚ÇÉ X‚ÇÑ\nfac : Eq (CategoryTheory.CategoryStruct.comp f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÑ) (CategoryTheory.CategoryStruct.comp f‚ÇÅ‚ÇÉ f‚ÇÉ‚ÇÑ)\nx‚úù : Eq (CategoryTheory.Square.mk f‚ÇÅ‚ÇÇ‚úù f‚ÇÅ‚ÇÉ‚úù f‚ÇÇ‚ÇÑ‚úù f‚ÇÉ‚ÇÑ‚úù fac‚úù) (CategoryTheory.Square.mk f‚ÇÅ‚ÇÇ f‚ÇÅ‚ÇÉ f‚ÇÇ‚ÇÑ f‚ÇÉ‚ÇÑ fac)\n‚ä¢ And (Eq X‚ÇÅ‚úù X‚ÇÅ) (And (Eq X‚ÇÇ‚úù X‚ÇÇ) (And (Eq X‚ÇÉ‚úù X‚ÇÉ) (And (Eq X‚ÇÑ‚úù X‚ÇÑ) (And (HEq f‚ÇÅ‚ÇÇ‚úù f‚ÇÅ‚ÇÇ) (And (HEq f‚ÇÅ‚ÇÉ‚úù f‚ÇÅ‚ÇÉ) (And (HEq f‚ÇÇ‚ÇÑ‚úù f‚ÇÇ‚ÇÑ) (HEq f‚ÇÉ‚ÇÑ‚úù f‚ÇÉ‚ÇÑ)))))))","decl":"/-- The category of commutative squares in a category. -/\nstructure Square where\n  /-- the top-left object -/\n  {X‚ÇÅ : C}\n  /-- the top-right object -/\n  {X‚ÇÇ : C}\n  /-- the bottom-left object -/\n  {X‚ÇÉ : C}\n  /-- the bottom-right object -/\n  {X‚ÇÑ : C}\n  /-- the top morphism -/\n  f‚ÇÅ‚ÇÇ : X‚ÇÅ ‚ü∂ X‚ÇÇ\n  /-- the left morphism -/\n  f‚ÇÅ‚ÇÉ : X‚ÇÅ ‚ü∂ X‚ÇÉ\n  /-- the right morphism -/\n  f‚ÇÇ‚ÇÑ : X‚ÇÇ ‚ü∂ X‚ÇÑ\n  /-- the bottom morphism -/\n  f‚ÇÉ‚ÇÑ : X‚ÇÉ ‚ü∂ X‚ÇÑ\n  fac : f‚ÇÅ‚ÇÇ ‚â´ f‚ÇÇ‚ÇÑ = f‚ÇÅ‚ÇÉ ‚â´ f‚ÇÉ‚ÇÑ\n\n"}
{"name":"CategoryTheory.Square.commSq","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ CategoryTheory.CommSq sq.f‚ÇÅ‚ÇÇ sq.f‚ÇÅ‚ÇÉ sq.f‚ÇÇ‚ÇÑ sq.f‚ÇÉ‚ÇÑ","decl":"lemma commSq (sq : Square C) : CommSq sq.f‚ÇÅ‚ÇÇ sq.f‚ÇÅ‚ÇÉ sq.f‚ÇÇ‚ÇÑ sq.f‚ÇÉ‚ÇÑ where\n  w := sq.fac\n\n"}
{"name":"CategoryTheory.Square.Hom.ext_iff","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq‚ÇÅ sq‚ÇÇ : CategoryTheory.Square C\nx y : sq‚ÇÅ.Hom sq‚ÇÇ\n‚ä¢ Iff (Eq x y) (And (Eq x.œÑ‚ÇÅ y.œÑ‚ÇÅ) (And (Eq x.œÑ‚ÇÇ y.œÑ‚ÇÇ) (And (Eq x.œÑ‚ÇÉ y.œÑ‚ÇÉ) (Eq x.œÑ‚ÇÑ y.œÑ‚ÇÑ))))","decl":"/-- A morphism between two commutative squares consists of 4 morphisms\nwhich extend these two squares into a commuting cube. -/\n@[ext]\nstructure Hom (sq‚ÇÅ sq‚ÇÇ : Square C) where\n  /-- the top-left morphism -/\n  œÑ‚ÇÅ : sq‚ÇÅ.X‚ÇÅ ‚ü∂ sq‚ÇÇ.X‚ÇÅ\n  /-- the top-right morphism -/\n  œÑ‚ÇÇ : sq‚ÇÅ.X‚ÇÇ ‚ü∂ sq‚ÇÇ.X‚ÇÇ\n  /-- the bottom-left morphism -/\n  œÑ‚ÇÉ : sq‚ÇÅ.X‚ÇÉ ‚ü∂ sq‚ÇÇ.X‚ÇÉ\n  /-- the bottom-right morphism -/\n  œÑ‚ÇÑ : sq‚ÇÅ.X‚ÇÑ ‚ü∂ sq‚ÇÇ.X‚ÇÑ\n  comm‚ÇÅ‚ÇÇ : sq‚ÇÅ.f‚ÇÅ‚ÇÇ ‚â´ œÑ‚ÇÇ = œÑ‚ÇÅ ‚â´ sq‚ÇÇ.f‚ÇÅ‚ÇÇ := by aesop_cat\n  comm‚ÇÅ‚ÇÉ : sq‚ÇÅ.f‚ÇÅ‚ÇÉ ‚â´ œÑ‚ÇÉ = œÑ‚ÇÅ ‚â´ sq‚ÇÇ.f‚ÇÅ‚ÇÉ := by aesop_cat\n  comm‚ÇÇ‚ÇÑ : sq‚ÇÅ.f‚ÇÇ‚ÇÑ ‚â´ œÑ‚ÇÑ = œÑ‚ÇÇ ‚â´ sq‚ÇÇ.f‚ÇÇ‚ÇÑ := by aesop_cat\n  comm‚ÇÉ‚ÇÑ : sq‚ÇÅ.f‚ÇÉ‚ÇÑ ‚â´ œÑ‚ÇÑ = œÑ‚ÇÉ ‚â´ sq‚ÇÇ.f‚ÇÉ‚ÇÑ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Square.Hom.comm‚ÇÉ‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq‚ÇÅ sq‚ÇÇ : CategoryTheory.Square C\nself : sq‚ÇÅ.Hom sq‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÉ‚ÇÑ self.œÑ‚ÇÑ) (CategoryTheory.CategoryStruct.comp self.œÑ‚ÇÉ sq‚ÇÇ.f‚ÇÉ‚ÇÑ)","decl":"/-- A morphism between two commutative squares consists of 4 morphisms\nwhich extend these two squares into a commuting cube. -/\n@[ext]\nstructure Hom (sq‚ÇÅ sq‚ÇÇ : Square C) where\n  /-- the top-left morphism -/\n  œÑ‚ÇÅ : sq‚ÇÅ.X‚ÇÅ ‚ü∂ sq‚ÇÇ.X‚ÇÅ\n  /-- the top-right morphism -/\n  œÑ‚ÇÇ : sq‚ÇÅ.X‚ÇÇ ‚ü∂ sq‚ÇÇ.X‚ÇÇ\n  /-- the bottom-left morphism -/\n  œÑ‚ÇÉ : sq‚ÇÅ.X‚ÇÉ ‚ü∂ sq‚ÇÇ.X‚ÇÉ\n  /-- the bottom-right morphism -/\n  œÑ‚ÇÑ : sq‚ÇÅ.X‚ÇÑ ‚ü∂ sq‚ÇÇ.X‚ÇÑ\n  comm‚ÇÅ‚ÇÇ : sq‚ÇÅ.f‚ÇÅ‚ÇÇ ‚â´ œÑ‚ÇÇ = œÑ‚ÇÅ ‚â´ sq‚ÇÇ.f‚ÇÅ‚ÇÇ := by aesop_cat\n  comm‚ÇÅ‚ÇÉ : sq‚ÇÅ.f‚ÇÅ‚ÇÉ ‚â´ œÑ‚ÇÉ = œÑ‚ÇÅ ‚â´ sq‚ÇÇ.f‚ÇÅ‚ÇÉ := by aesop_cat\n  comm‚ÇÇ‚ÇÑ : sq‚ÇÅ.f‚ÇÇ‚ÇÑ ‚â´ œÑ‚ÇÑ = œÑ‚ÇÇ ‚â´ sq‚ÇÇ.f‚ÇÇ‚ÇÑ := by aesop_cat\n  comm‚ÇÉ‚ÇÑ : sq‚ÇÅ.f‚ÇÉ‚ÇÑ ‚â´ œÑ‚ÇÑ = œÑ‚ÇÉ ‚â´ sq‚ÇÇ.f‚ÇÉ‚ÇÑ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Square.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nsq‚ÇÅ sq‚ÇÇ : CategoryTheory.Square C\ninst‚úù : SizeOf C\nœÑ‚ÇÅ : Quiver.Hom sq‚ÇÅ.X‚ÇÅ sq‚ÇÇ.X‚ÇÅ\nœÑ‚ÇÇ : Quiver.Hom sq‚ÇÅ.X‚ÇÇ sq‚ÇÇ.X‚ÇÇ\nœÑ‚ÇÉ : Quiver.Hom sq‚ÇÅ.X‚ÇÉ sq‚ÇÇ.X‚ÇÉ\nœÑ‚ÇÑ : Quiver.Hom sq‚ÇÅ.X‚ÇÑ sq‚ÇÇ.X‚ÇÑ\ncomm‚ÇÅ‚ÇÇ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÅ‚ÇÇ œÑ‚ÇÇ) (CategoryTheory.CategoryStruct.comp œÑ‚ÇÅ sq‚ÇÇ.f‚ÇÅ‚ÇÇ)) _auto‚úù\ncomm‚ÇÅ‚ÇÉ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÅ‚ÇÉ œÑ‚ÇÉ) (CategoryTheory.CategoryStruct.comp œÑ‚ÇÅ sq‚ÇÇ.f‚ÇÅ‚ÇÉ)) _auto‚úù\ncomm‚ÇÇ‚ÇÑ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÇ‚ÇÑ œÑ‚ÇÑ) (CategoryTheory.CategoryStruct.comp œÑ‚ÇÇ sq‚ÇÇ.f‚ÇÇ‚ÇÑ)) _auto‚úù\ncomm‚ÇÉ‚ÇÑ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÉ‚ÇÑ œÑ‚ÇÑ) (CategoryTheory.CategoryStruct.comp œÑ‚ÇÉ sq‚ÇÇ.f‚ÇÉ‚ÇÑ)) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { œÑ‚ÇÅ := œÑ‚ÇÅ, œÑ‚ÇÇ := œÑ‚ÇÇ, œÑ‚ÇÉ := œÑ‚ÇÉ, œÑ‚ÇÑ := œÑ‚ÇÑ, comm‚ÇÅ‚ÇÇ := comm‚ÇÅ‚ÇÇ, comm‚ÇÅ‚ÇÉ := comm‚ÇÅ‚ÇÉ, comm‚ÇÇ‚ÇÑ := comm‚ÇÇ‚ÇÑ, comm‚ÇÉ‚ÇÑ := comm‚ÇÉ‚ÇÑ }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf œÑ‚ÇÅ)) (SizeOf.sizeOf œÑ‚ÇÇ)) (SizeOf.sizeOf œÑ‚ÇÉ)) (SizeOf.sizeOf œÑ‚ÇÑ)) (SizeOf.sizeOf comm‚ÇÅ‚ÇÇ)) (SizeOf.sizeOf comm‚ÇÅ‚ÇÉ)) (SizeOf.sizeOf comm‚ÇÇ‚ÇÑ)) (SizeOf.sizeOf comm‚ÇÉ‚ÇÑ))","decl":"/-- A morphism between two commutative squares consists of 4 morphisms\nwhich extend these two squares into a commuting cube. -/\n@[ext]\nstructure Hom (sq‚ÇÅ sq‚ÇÇ : Square C) where\n  /-- the top-left morphism -/\n  œÑ‚ÇÅ : sq‚ÇÅ.X‚ÇÅ ‚ü∂ sq‚ÇÇ.X‚ÇÅ\n  /-- the top-right morphism -/\n  œÑ‚ÇÇ : sq‚ÇÅ.X‚ÇÇ ‚ü∂ sq‚ÇÇ.X‚ÇÇ\n  /-- the bottom-left morphism -/\n  œÑ‚ÇÉ : sq‚ÇÅ.X‚ÇÉ ‚ü∂ sq‚ÇÇ.X‚ÇÉ\n  /-- the bottom-right morphism -/\n  œÑ‚ÇÑ : sq‚ÇÅ.X‚ÇÑ ‚ü∂ sq‚ÇÇ.X‚ÇÑ\n  comm‚ÇÅ‚ÇÇ : sq‚ÇÅ.f‚ÇÅ‚ÇÇ ‚â´ œÑ‚ÇÇ = œÑ‚ÇÅ ‚â´ sq‚ÇÇ.f‚ÇÅ‚ÇÇ := by aesop_cat\n  comm‚ÇÅ‚ÇÉ : sq‚ÇÅ.f‚ÇÅ‚ÇÉ ‚â´ œÑ‚ÇÉ = œÑ‚ÇÅ ‚â´ sq‚ÇÇ.f‚ÇÅ‚ÇÉ := by aesop_cat\n  comm‚ÇÇ‚ÇÑ : sq‚ÇÅ.f‚ÇÇ‚ÇÑ ‚â´ œÑ‚ÇÑ = œÑ‚ÇÇ ‚â´ sq‚ÇÇ.f‚ÇÇ‚ÇÑ := by aesop_cat\n  comm‚ÇÉ‚ÇÑ : sq‚ÇÅ.f‚ÇÉ‚ÇÑ ‚â´ œÑ‚ÇÑ = œÑ‚ÇÉ ‚â´ sq‚ÇÇ.f‚ÇÉ‚ÇÑ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Square.Hom.comm‚ÇÅ‚ÇÉ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq‚ÇÅ sq‚ÇÇ : CategoryTheory.Square C\nself : sq‚ÇÅ.Hom sq‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÅ‚ÇÉ self.œÑ‚ÇÉ) (CategoryTheory.CategoryStruct.comp self.œÑ‚ÇÅ sq‚ÇÇ.f‚ÇÅ‚ÇÉ)","decl":"/-- A morphism between two commutative squares consists of 4 morphisms\nwhich extend these two squares into a commuting cube. -/\n@[ext]\nstructure Hom (sq‚ÇÅ sq‚ÇÇ : Square C) where\n  /-- the top-left morphism -/\n  œÑ‚ÇÅ : sq‚ÇÅ.X‚ÇÅ ‚ü∂ sq‚ÇÇ.X‚ÇÅ\n  /-- the top-right morphism -/\n  œÑ‚ÇÇ : sq‚ÇÅ.X‚ÇÇ ‚ü∂ sq‚ÇÇ.X‚ÇÇ\n  /-- the bottom-left morphism -/\n  œÑ‚ÇÉ : sq‚ÇÅ.X‚ÇÉ ‚ü∂ sq‚ÇÇ.X‚ÇÉ\n  /-- the bottom-right morphism -/\n  œÑ‚ÇÑ : sq‚ÇÅ.X‚ÇÑ ‚ü∂ sq‚ÇÇ.X‚ÇÑ\n  comm‚ÇÅ‚ÇÇ : sq‚ÇÅ.f‚ÇÅ‚ÇÇ ‚â´ œÑ‚ÇÇ = œÑ‚ÇÅ ‚â´ sq‚ÇÇ.f‚ÇÅ‚ÇÇ := by aesop_cat\n  comm‚ÇÅ‚ÇÉ : sq‚ÇÅ.f‚ÇÅ‚ÇÉ ‚â´ œÑ‚ÇÉ = œÑ‚ÇÅ ‚â´ sq‚ÇÇ.f‚ÇÅ‚ÇÉ := by aesop_cat\n  comm‚ÇÇ‚ÇÑ : sq‚ÇÅ.f‚ÇÇ‚ÇÑ ‚â´ œÑ‚ÇÑ = œÑ‚ÇÇ ‚â´ sq‚ÇÇ.f‚ÇÇ‚ÇÑ := by aesop_cat\n  comm‚ÇÉ‚ÇÑ : sq‚ÇÅ.f‚ÇÉ‚ÇÑ ‚â´ œÑ‚ÇÑ = œÑ‚ÇÉ ‚â´ sq‚ÇÇ.f‚ÇÉ‚ÇÑ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Square.Hom.comm‚ÇÇ‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq‚ÇÅ sq‚ÇÇ : CategoryTheory.Square C\nself : sq‚ÇÅ.Hom sq‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÇ‚ÇÑ self.œÑ‚ÇÑ) (CategoryTheory.CategoryStruct.comp self.œÑ‚ÇÇ sq‚ÇÇ.f‚ÇÇ‚ÇÑ)","decl":"/-- A morphism between two commutative squares consists of 4 morphisms\nwhich extend these two squares into a commuting cube. -/\n@[ext]\nstructure Hom (sq‚ÇÅ sq‚ÇÇ : Square C) where\n  /-- the top-left morphism -/\n  œÑ‚ÇÅ : sq‚ÇÅ.X‚ÇÅ ‚ü∂ sq‚ÇÇ.X‚ÇÅ\n  /-- the top-right morphism -/\n  œÑ‚ÇÇ : sq‚ÇÅ.X‚ÇÇ ‚ü∂ sq‚ÇÇ.X‚ÇÇ\n  /-- the bottom-left morphism -/\n  œÑ‚ÇÉ : sq‚ÇÅ.X‚ÇÉ ‚ü∂ sq‚ÇÇ.X‚ÇÉ\n  /-- the bottom-right morphism -/\n  œÑ‚ÇÑ : sq‚ÇÅ.X‚ÇÑ ‚ü∂ sq‚ÇÇ.X‚ÇÑ\n  comm‚ÇÅ‚ÇÇ : sq‚ÇÅ.f‚ÇÅ‚ÇÇ ‚â´ œÑ‚ÇÇ = œÑ‚ÇÅ ‚â´ sq‚ÇÇ.f‚ÇÅ‚ÇÇ := by aesop_cat\n  comm‚ÇÅ‚ÇÉ : sq‚ÇÅ.f‚ÇÅ‚ÇÉ ‚â´ œÑ‚ÇÉ = œÑ‚ÇÅ ‚â´ sq‚ÇÇ.f‚ÇÅ‚ÇÉ := by aesop_cat\n  comm‚ÇÇ‚ÇÑ : sq‚ÇÅ.f‚ÇÇ‚ÇÑ ‚â´ œÑ‚ÇÑ = œÑ‚ÇÇ ‚â´ sq‚ÇÇ.f‚ÇÇ‚ÇÑ := by aesop_cat\n  comm‚ÇÉ‚ÇÑ : sq‚ÇÅ.f‚ÇÉ‚ÇÑ ‚â´ œÑ‚ÇÑ = œÑ‚ÇÉ ‚â´ sq‚ÇÇ.f‚ÇÉ‚ÇÑ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Square.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq‚ÇÅ sq‚ÇÇ : CategoryTheory.Square C\nœÑ‚ÇÅ‚úù : Quiver.Hom sq‚ÇÅ.X‚ÇÅ sq‚ÇÇ.X‚ÇÅ\nœÑ‚ÇÇ‚úù : Quiver.Hom sq‚ÇÅ.X‚ÇÇ sq‚ÇÇ.X‚ÇÇ\nœÑ‚ÇÉ‚úù : Quiver.Hom sq‚ÇÅ.X‚ÇÉ sq‚ÇÇ.X‚ÇÉ\nœÑ‚ÇÑ‚úù : Quiver.Hom sq‚ÇÅ.X‚ÇÑ sq‚ÇÇ.X‚ÇÑ\ncomm‚ÇÅ‚ÇÇ‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÅ‚ÇÇ œÑ‚ÇÇ‚úù) (CategoryTheory.CategoryStruct.comp œÑ‚ÇÅ‚úù sq‚ÇÇ.f‚ÇÅ‚ÇÇ)) _auto‚úù\ncomm‚ÇÅ‚ÇÉ‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÅ‚ÇÉ œÑ‚ÇÉ‚úù) (CategoryTheory.CategoryStruct.comp œÑ‚ÇÅ‚úù sq‚ÇÇ.f‚ÇÅ‚ÇÉ)) _auto‚úù\ncomm‚ÇÇ‚ÇÑ‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÇ‚ÇÑ œÑ‚ÇÑ‚úù) (CategoryTheory.CategoryStruct.comp œÑ‚ÇÇ‚úù sq‚ÇÇ.f‚ÇÇ‚ÇÑ)) _auto‚úù\ncomm‚ÇÉ‚ÇÑ‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÉ‚ÇÑ œÑ‚ÇÑ‚úù) (CategoryTheory.CategoryStruct.comp œÑ‚ÇÉ‚úù sq‚ÇÇ.f‚ÇÉ‚ÇÑ)) _auto‚úù\nœÑ‚ÇÅ : Quiver.Hom sq‚ÇÅ.X‚ÇÅ sq‚ÇÇ.X‚ÇÅ\nœÑ‚ÇÇ : Quiver.Hom sq‚ÇÅ.X‚ÇÇ sq‚ÇÇ.X‚ÇÇ\nœÑ‚ÇÉ : Quiver.Hom sq‚ÇÅ.X‚ÇÉ sq‚ÇÇ.X‚ÇÉ\nœÑ‚ÇÑ : Quiver.Hom sq‚ÇÅ.X‚ÇÑ sq‚ÇÇ.X‚ÇÑ\ncomm‚ÇÅ‚ÇÇ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÅ‚ÇÇ œÑ‚ÇÇ) (CategoryTheory.CategoryStruct.comp œÑ‚ÇÅ sq‚ÇÇ.f‚ÇÅ‚ÇÇ)) _auto‚úù\ncomm‚ÇÅ‚ÇÉ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÅ‚ÇÉ œÑ‚ÇÉ) (CategoryTheory.CategoryStruct.comp œÑ‚ÇÅ sq‚ÇÇ.f‚ÇÅ‚ÇÉ)) _auto‚úù\ncomm‚ÇÇ‚ÇÑ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÇ‚ÇÑ œÑ‚ÇÑ) (CategoryTheory.CategoryStruct.comp œÑ‚ÇÇ sq‚ÇÇ.f‚ÇÇ‚ÇÑ)) _auto‚úù\ncomm‚ÇÉ‚ÇÑ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÉ‚ÇÑ œÑ‚ÇÑ) (CategoryTheory.CategoryStruct.comp œÑ‚ÇÉ sq‚ÇÇ.f‚ÇÉ‚ÇÑ)) _auto‚úù\n‚ä¢ Eq (Eq { œÑ‚ÇÅ := œÑ‚ÇÅ‚úù, œÑ‚ÇÇ := œÑ‚ÇÇ‚úù, œÑ‚ÇÉ := œÑ‚ÇÉ‚úù, œÑ‚ÇÑ := œÑ‚ÇÑ‚úù, comm‚ÇÅ‚ÇÇ := comm‚ÇÅ‚ÇÇ‚úù, comm‚ÇÅ‚ÇÉ := comm‚ÇÅ‚ÇÉ‚úù, comm‚ÇÇ‚ÇÑ := comm‚ÇÇ‚ÇÑ‚úù, comm‚ÇÉ‚ÇÑ := comm‚ÇÉ‚ÇÑ‚úù } { œÑ‚ÇÅ := œÑ‚ÇÅ, œÑ‚ÇÇ := œÑ‚ÇÇ, œÑ‚ÇÉ := œÑ‚ÇÉ, œÑ‚ÇÑ := œÑ‚ÇÑ, comm‚ÇÅ‚ÇÇ := comm‚ÇÅ‚ÇÇ, comm‚ÇÅ‚ÇÉ := comm‚ÇÅ‚ÇÉ, comm‚ÇÇ‚ÇÑ := comm‚ÇÇ‚ÇÑ, comm‚ÇÉ‚ÇÑ := comm‚ÇÉ‚ÇÑ }) (And (Eq œÑ‚ÇÅ‚úù œÑ‚ÇÅ) (And (Eq œÑ‚ÇÇ‚úù œÑ‚ÇÇ) (And (Eq œÑ‚ÇÉ‚úù œÑ‚ÇÉ) (Eq œÑ‚ÇÑ‚úù œÑ‚ÇÑ))))","decl":"/-- A morphism between two commutative squares consists of 4 morphisms\nwhich extend these two squares into a commuting cube. -/\n@[ext]\nstructure Hom (sq‚ÇÅ sq‚ÇÇ : Square C) where\n  /-- the top-left morphism -/\n  œÑ‚ÇÅ : sq‚ÇÅ.X‚ÇÅ ‚ü∂ sq‚ÇÇ.X‚ÇÅ\n  /-- the top-right morphism -/\n  œÑ‚ÇÇ : sq‚ÇÅ.X‚ÇÇ ‚ü∂ sq‚ÇÇ.X‚ÇÇ\n  /-- the bottom-left morphism -/\n  œÑ‚ÇÉ : sq‚ÇÅ.X‚ÇÉ ‚ü∂ sq‚ÇÇ.X‚ÇÉ\n  /-- the bottom-right morphism -/\n  œÑ‚ÇÑ : sq‚ÇÅ.X‚ÇÑ ‚ü∂ sq‚ÇÇ.X‚ÇÑ\n  comm‚ÇÅ‚ÇÇ : sq‚ÇÅ.f‚ÇÅ‚ÇÇ ‚â´ œÑ‚ÇÇ = œÑ‚ÇÅ ‚â´ sq‚ÇÇ.f‚ÇÅ‚ÇÇ := by aesop_cat\n  comm‚ÇÅ‚ÇÉ : sq‚ÇÅ.f‚ÇÅ‚ÇÉ ‚â´ œÑ‚ÇÉ = œÑ‚ÇÅ ‚â´ sq‚ÇÇ.f‚ÇÅ‚ÇÉ := by aesop_cat\n  comm‚ÇÇ‚ÇÑ : sq‚ÇÅ.f‚ÇÇ‚ÇÑ ‚â´ œÑ‚ÇÑ = œÑ‚ÇÇ ‚â´ sq‚ÇÇ.f‚ÇÇ‚ÇÑ := by aesop_cat\n  comm‚ÇÉ‚ÇÑ : sq‚ÇÅ.f‚ÇÉ‚ÇÑ ‚â´ œÑ‚ÇÑ = œÑ‚ÇÉ ‚â´ sq‚ÇÇ.f‚ÇÉ‚ÇÑ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Square.Hom.comm‚ÇÅ‚ÇÇ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq‚ÇÅ sq‚ÇÇ : CategoryTheory.Square C\nself : sq‚ÇÅ.Hom sq‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÅ‚ÇÇ self.œÑ‚ÇÇ) (CategoryTheory.CategoryStruct.comp self.œÑ‚ÇÅ sq‚ÇÇ.f‚ÇÅ‚ÇÇ)","decl":"/-- A morphism between two commutative squares consists of 4 morphisms\nwhich extend these two squares into a commuting cube. -/\n@[ext]\nstructure Hom (sq‚ÇÅ sq‚ÇÇ : Square C) where\n  /-- the top-left morphism -/\n  œÑ‚ÇÅ : sq‚ÇÅ.X‚ÇÅ ‚ü∂ sq‚ÇÇ.X‚ÇÅ\n  /-- the top-right morphism -/\n  œÑ‚ÇÇ : sq‚ÇÅ.X‚ÇÇ ‚ü∂ sq‚ÇÇ.X‚ÇÇ\n  /-- the bottom-left morphism -/\n  œÑ‚ÇÉ : sq‚ÇÅ.X‚ÇÉ ‚ü∂ sq‚ÇÇ.X‚ÇÉ\n  /-- the bottom-right morphism -/\n  œÑ‚ÇÑ : sq‚ÇÅ.X‚ÇÑ ‚ü∂ sq‚ÇÇ.X‚ÇÑ\n  comm‚ÇÅ‚ÇÇ : sq‚ÇÅ.f‚ÇÅ‚ÇÇ ‚â´ œÑ‚ÇÇ = œÑ‚ÇÅ ‚â´ sq‚ÇÇ.f‚ÇÅ‚ÇÇ := by aesop_cat\n  comm‚ÇÅ‚ÇÉ : sq‚ÇÅ.f‚ÇÅ‚ÇÉ ‚â´ œÑ‚ÇÉ = œÑ‚ÇÅ ‚â´ sq‚ÇÇ.f‚ÇÅ‚ÇÉ := by aesop_cat\n  comm‚ÇÇ‚ÇÑ : sq‚ÇÅ.f‚ÇÇ‚ÇÑ ‚â´ œÑ‚ÇÑ = œÑ‚ÇÇ ‚â´ sq‚ÇÇ.f‚ÇÇ‚ÇÑ := by aesop_cat\n  comm‚ÇÉ‚ÇÑ : sq‚ÇÅ.f‚ÇÉ‚ÇÑ ‚â´ œÑ‚ÇÑ = œÑ‚ÇÉ ‚â´ sq‚ÇÇ.f‚ÇÉ‚ÇÑ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Square.Hom.mk.inj","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq‚ÇÅ sq‚ÇÇ : CategoryTheory.Square C\nœÑ‚ÇÅ‚úù : Quiver.Hom sq‚ÇÅ.X‚ÇÅ sq‚ÇÇ.X‚ÇÅ\nœÑ‚ÇÇ‚úù : Quiver.Hom sq‚ÇÅ.X‚ÇÇ sq‚ÇÇ.X‚ÇÇ\nœÑ‚ÇÉ‚úù : Quiver.Hom sq‚ÇÅ.X‚ÇÉ sq‚ÇÇ.X‚ÇÉ\nœÑ‚ÇÑ‚úù : Quiver.Hom sq‚ÇÅ.X‚ÇÑ sq‚ÇÇ.X‚ÇÑ\ncomm‚ÇÅ‚ÇÇ‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÅ‚ÇÇ œÑ‚ÇÇ‚úù) (CategoryTheory.CategoryStruct.comp œÑ‚ÇÅ‚úù sq‚ÇÇ.f‚ÇÅ‚ÇÇ)) _auto‚úù\ncomm‚ÇÅ‚ÇÉ‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÅ‚ÇÉ œÑ‚ÇÉ‚úù) (CategoryTheory.CategoryStruct.comp œÑ‚ÇÅ‚úù sq‚ÇÇ.f‚ÇÅ‚ÇÉ)) _auto‚úù\ncomm‚ÇÇ‚ÇÑ‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÇ‚ÇÑ œÑ‚ÇÑ‚úù) (CategoryTheory.CategoryStruct.comp œÑ‚ÇÇ‚úù sq‚ÇÇ.f‚ÇÇ‚ÇÑ)) _auto‚úù\ncomm‚ÇÉ‚ÇÑ‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÉ‚ÇÑ œÑ‚ÇÑ‚úù) (CategoryTheory.CategoryStruct.comp œÑ‚ÇÉ‚úù sq‚ÇÇ.f‚ÇÉ‚ÇÑ)) _auto‚úù\nœÑ‚ÇÅ : Quiver.Hom sq‚ÇÅ.X‚ÇÅ sq‚ÇÇ.X‚ÇÅ\nœÑ‚ÇÇ : Quiver.Hom sq‚ÇÅ.X‚ÇÇ sq‚ÇÇ.X‚ÇÇ\nœÑ‚ÇÉ : Quiver.Hom sq‚ÇÅ.X‚ÇÉ sq‚ÇÇ.X‚ÇÉ\nœÑ‚ÇÑ : Quiver.Hom sq‚ÇÅ.X‚ÇÑ sq‚ÇÇ.X‚ÇÑ\ncomm‚ÇÅ‚ÇÇ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÅ‚ÇÇ œÑ‚ÇÇ) (CategoryTheory.CategoryStruct.comp œÑ‚ÇÅ sq‚ÇÇ.f‚ÇÅ‚ÇÇ)) _auto‚úù\ncomm‚ÇÅ‚ÇÉ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÅ‚ÇÉ œÑ‚ÇÉ) (CategoryTheory.CategoryStruct.comp œÑ‚ÇÅ sq‚ÇÇ.f‚ÇÅ‚ÇÉ)) _auto‚úù\ncomm‚ÇÇ‚ÇÑ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÇ‚ÇÑ œÑ‚ÇÑ) (CategoryTheory.CategoryStruct.comp œÑ‚ÇÇ sq‚ÇÇ.f‚ÇÇ‚ÇÑ)) _auto‚úù\ncomm‚ÇÉ‚ÇÑ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÉ‚ÇÑ œÑ‚ÇÑ) (CategoryTheory.CategoryStruct.comp œÑ‚ÇÉ sq‚ÇÇ.f‚ÇÉ‚ÇÑ)) _auto‚úù\nx‚úù : Eq { œÑ‚ÇÅ := œÑ‚ÇÅ‚úù, œÑ‚ÇÇ := œÑ‚ÇÇ‚úù, œÑ‚ÇÉ := œÑ‚ÇÉ‚úù, œÑ‚ÇÑ := œÑ‚ÇÑ‚úù, comm‚ÇÅ‚ÇÇ := comm‚ÇÅ‚ÇÇ‚úù, comm‚ÇÅ‚ÇÉ := comm‚ÇÅ‚ÇÉ‚úù, comm‚ÇÇ‚ÇÑ := comm‚ÇÇ‚ÇÑ‚úù, comm‚ÇÉ‚ÇÑ := comm‚ÇÉ‚ÇÑ‚úù } { œÑ‚ÇÅ := œÑ‚ÇÅ, œÑ‚ÇÇ := œÑ‚ÇÇ, œÑ‚ÇÉ := œÑ‚ÇÉ, œÑ‚ÇÑ := œÑ‚ÇÑ, comm‚ÇÅ‚ÇÇ := comm‚ÇÅ‚ÇÇ, comm‚ÇÅ‚ÇÉ := comm‚ÇÅ‚ÇÉ, comm‚ÇÇ‚ÇÑ := comm‚ÇÇ‚ÇÑ, comm‚ÇÉ‚ÇÑ := comm‚ÇÉ‚ÇÑ }\n‚ä¢ And (Eq œÑ‚ÇÅ‚úù œÑ‚ÇÅ) (And (Eq œÑ‚ÇÇ‚úù œÑ‚ÇÇ) (And (Eq œÑ‚ÇÉ‚úù œÑ‚ÇÉ) (Eq œÑ‚ÇÑ‚úù œÑ‚ÇÑ)))","decl":"/-- A morphism between two commutative squares consists of 4 morphisms\nwhich extend these two squares into a commuting cube. -/\n@[ext]\nstructure Hom (sq‚ÇÅ sq‚ÇÇ : Square C) where\n  /-- the top-left morphism -/\n  œÑ‚ÇÅ : sq‚ÇÅ.X‚ÇÅ ‚ü∂ sq‚ÇÇ.X‚ÇÅ\n  /-- the top-right morphism -/\n  œÑ‚ÇÇ : sq‚ÇÅ.X‚ÇÇ ‚ü∂ sq‚ÇÇ.X‚ÇÇ\n  /-- the bottom-left morphism -/\n  œÑ‚ÇÉ : sq‚ÇÅ.X‚ÇÉ ‚ü∂ sq‚ÇÇ.X‚ÇÉ\n  /-- the bottom-right morphism -/\n  œÑ‚ÇÑ : sq‚ÇÅ.X‚ÇÑ ‚ü∂ sq‚ÇÇ.X‚ÇÑ\n  comm‚ÇÅ‚ÇÇ : sq‚ÇÅ.f‚ÇÅ‚ÇÇ ‚â´ œÑ‚ÇÇ = œÑ‚ÇÅ ‚â´ sq‚ÇÇ.f‚ÇÅ‚ÇÇ := by aesop_cat\n  comm‚ÇÅ‚ÇÉ : sq‚ÇÅ.f‚ÇÅ‚ÇÉ ‚â´ œÑ‚ÇÉ = œÑ‚ÇÅ ‚â´ sq‚ÇÇ.f‚ÇÅ‚ÇÉ := by aesop_cat\n  comm‚ÇÇ‚ÇÑ : sq‚ÇÅ.f‚ÇÇ‚ÇÑ ‚â´ œÑ‚ÇÑ = œÑ‚ÇÇ ‚â´ sq‚ÇÇ.f‚ÇÇ‚ÇÑ := by aesop_cat\n  comm‚ÇÉ‚ÇÑ : sq‚ÇÅ.f‚ÇÉ‚ÇÑ ‚â´ œÑ‚ÇÑ = œÑ‚ÇÉ ‚â´ sq‚ÇÇ.f‚ÇÉ‚ÇÑ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Square.Hom.ext","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq‚ÇÅ sq‚ÇÇ : CategoryTheory.Square C\nx y : sq‚ÇÅ.Hom sq‚ÇÇ\nœÑ‚ÇÅ : Eq x.œÑ‚ÇÅ y.œÑ‚ÇÅ\nœÑ‚ÇÇ : Eq x.œÑ‚ÇÇ y.œÑ‚ÇÇ\nœÑ‚ÇÉ : Eq x.œÑ‚ÇÉ y.œÑ‚ÇÉ\nœÑ‚ÇÑ : Eq x.œÑ‚ÇÑ y.œÑ‚ÇÑ\n‚ä¢ Eq x y","decl":"/-- A morphism between two commutative squares consists of 4 morphisms\nwhich extend these two squares into a commuting cube. -/\n@[ext]\nstructure Hom (sq‚ÇÅ sq‚ÇÇ : Square C) where\n  /-- the top-left morphism -/\n  œÑ‚ÇÅ : sq‚ÇÅ.X‚ÇÅ ‚ü∂ sq‚ÇÇ.X‚ÇÅ\n  /-- the top-right morphism -/\n  œÑ‚ÇÇ : sq‚ÇÅ.X‚ÇÇ ‚ü∂ sq‚ÇÇ.X‚ÇÇ\n  /-- the bottom-left morphism -/\n  œÑ‚ÇÉ : sq‚ÇÅ.X‚ÇÉ ‚ü∂ sq‚ÇÇ.X‚ÇÉ\n  /-- the bottom-right morphism -/\n  œÑ‚ÇÑ : sq‚ÇÅ.X‚ÇÑ ‚ü∂ sq‚ÇÇ.X‚ÇÑ\n  comm‚ÇÅ‚ÇÇ : sq‚ÇÅ.f‚ÇÅ‚ÇÇ ‚â´ œÑ‚ÇÇ = œÑ‚ÇÅ ‚â´ sq‚ÇÇ.f‚ÇÅ‚ÇÇ := by aesop_cat\n  comm‚ÇÅ‚ÇÉ : sq‚ÇÅ.f‚ÇÅ‚ÇÉ ‚â´ œÑ‚ÇÉ = œÑ‚ÇÅ ‚â´ sq‚ÇÇ.f‚ÇÅ‚ÇÉ := by aesop_cat\n  comm‚ÇÇ‚ÇÑ : sq‚ÇÅ.f‚ÇÇ‚ÇÑ ‚â´ œÑ‚ÇÑ = œÑ‚ÇÇ ‚â´ sq‚ÇÇ.f‚ÇÇ‚ÇÑ := by aesop_cat\n  comm‚ÇÉ‚ÇÑ : sq‚ÇÅ.f‚ÇÉ‚ÇÑ ‚â´ œÑ‚ÇÑ = œÑ‚ÇÉ ‚â´ sq‚ÇÇ.f‚ÇÉ‚ÇÑ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Square.Hom.comm‚ÇÅ‚ÇÇ_assoc","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq‚ÇÅ sq‚ÇÇ : CategoryTheory.Square C\nself : sq‚ÇÅ.Hom sq‚ÇÇ\nZ : C\nh : Quiver.Hom sq‚ÇÇ.X‚ÇÇ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÅ‚ÇÇ (CategoryTheory.CategoryStruct.comp self.œÑ‚ÇÇ h)) (CategoryTheory.CategoryStruct.comp self.œÑ‚ÇÅ (CategoryTheory.CategoryStruct.comp sq‚ÇÇ.f‚ÇÅ‚ÇÇ h))","decl":"attribute [reassoc (attr := simp)] comm‚ÇÅ‚ÇÇ comm‚ÇÅ‚ÇÉ comm‚ÇÇ‚ÇÑ comm‚ÇÉ‚ÇÑ\n\n"}
{"name":"CategoryTheory.Square.Hom.comm‚ÇÉ‚ÇÑ_assoc","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq‚ÇÅ sq‚ÇÇ : CategoryTheory.Square C\nself : sq‚ÇÅ.Hom sq‚ÇÇ\nZ : C\nh : Quiver.Hom sq‚ÇÇ.X‚ÇÑ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÉ‚ÇÑ (CategoryTheory.CategoryStruct.comp self.œÑ‚ÇÑ h)) (CategoryTheory.CategoryStruct.comp self.œÑ‚ÇÉ (CategoryTheory.CategoryStruct.comp sq‚ÇÇ.f‚ÇÉ‚ÇÑ h))","decl":"attribute [reassoc (attr := simp)] comm‚ÇÅ‚ÇÇ comm‚ÇÅ‚ÇÉ comm‚ÇÇ‚ÇÑ comm‚ÇÉ‚ÇÑ\n\n"}
{"name":"CategoryTheory.Square.Hom.comm‚ÇÅ‚ÇÉ_assoc","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq‚ÇÅ sq‚ÇÇ : CategoryTheory.Square C\nself : sq‚ÇÅ.Hom sq‚ÇÇ\nZ : C\nh : Quiver.Hom sq‚ÇÇ.X‚ÇÉ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÅ‚ÇÉ (CategoryTheory.CategoryStruct.comp self.œÑ‚ÇÉ h)) (CategoryTheory.CategoryStruct.comp self.œÑ‚ÇÅ (CategoryTheory.CategoryStruct.comp sq‚ÇÇ.f‚ÇÅ‚ÇÉ h))","decl":"attribute [reassoc (attr := simp)] comm‚ÇÅ‚ÇÇ comm‚ÇÅ‚ÇÉ comm‚ÇÇ‚ÇÑ comm‚ÇÉ‚ÇÑ\n\n"}
{"name":"CategoryTheory.Square.Hom.comm‚ÇÇ‚ÇÑ_assoc","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq‚ÇÅ sq‚ÇÇ : CategoryTheory.Square C\nself : sq‚ÇÅ.Hom sq‚ÇÇ\nZ : C\nh : Quiver.Hom sq‚ÇÇ.X‚ÇÑ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp sq‚ÇÅ.f‚ÇÇ‚ÇÑ (CategoryTheory.CategoryStruct.comp self.œÑ‚ÇÑ h)) (CategoryTheory.CategoryStruct.comp self.œÑ‚ÇÇ (CategoryTheory.CategoryStruct.comp sq‚ÇÇ.f‚ÇÇ‚ÇÑ h))","decl":"attribute [reassoc (attr := simp)] comm‚ÇÅ‚ÇÇ comm‚ÇÅ‚ÇÉ comm‚ÇÇ‚ÇÑ comm‚ÇÉ‚ÇÑ\n\n"}
{"name":"CategoryTheory.Square.Hom.id_œÑ‚ÇÇ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.Hom.id sq).œÑ‚ÇÇ (CategoryTheory.CategoryStruct.id sq.X‚ÇÇ)","decl":"/-- The identity of a commutative square. -/\n@[simps]\ndef id (sq : Square C) : Hom sq sq where\n  œÑ‚ÇÅ := ùüô _\n  œÑ‚ÇÇ := ùüô _\n  œÑ‚ÇÉ := ùüô _\n  œÑ‚ÇÑ := ùüô _\n\n"}
{"name":"CategoryTheory.Square.Hom.id_œÑ‚ÇÅ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.Hom.id sq).œÑ‚ÇÅ (CategoryTheory.CategoryStruct.id sq.X‚ÇÅ)","decl":"/-- The identity of a commutative square. -/\n@[simps]\ndef id (sq : Square C) : Hom sq sq where\n  œÑ‚ÇÅ := ùüô _\n  œÑ‚ÇÇ := ùüô _\n  œÑ‚ÇÉ := ùüô _\n  œÑ‚ÇÑ := ùüô _\n\n"}
{"name":"CategoryTheory.Square.Hom.id_œÑ‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.Hom.id sq).œÑ‚ÇÑ (CategoryTheory.CategoryStruct.id sq.X‚ÇÑ)","decl":"/-- The identity of a commutative square. -/\n@[simps]\ndef id (sq : Square C) : Hom sq sq where\n  œÑ‚ÇÅ := ùüô _\n  œÑ‚ÇÇ := ùüô _\n  œÑ‚ÇÉ := ùüô _\n  œÑ‚ÇÑ := ùüô _\n\n"}
{"name":"CategoryTheory.Square.Hom.id_œÑ‚ÇÉ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.Hom.id sq).œÑ‚ÇÉ (CategoryTheory.CategoryStruct.id sq.X‚ÇÉ)","decl":"/-- The identity of a commutative square. -/\n@[simps]\ndef id (sq : Square C) : Hom sq sq where\n  œÑ‚ÇÅ := ùüô _\n  œÑ‚ÇÇ := ùüô _\n  œÑ‚ÇÉ := ùüô _\n  œÑ‚ÇÑ := ùüô _\n\n"}
{"name":"CategoryTheory.Square.Hom.comp_œÑ‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq‚ÇÅ sq‚ÇÇ sq‚ÇÉ : CategoryTheory.Square C\nf : sq‚ÇÅ.Hom sq‚ÇÇ\ng : sq‚ÇÇ.Hom sq‚ÇÉ\n‚ä¢ Eq (f.comp g).œÑ‚ÇÑ (CategoryTheory.CategoryStruct.comp f.œÑ‚ÇÑ g.œÑ‚ÇÑ)","decl":"/-- The composition of morphisms of squares. -/\n@[simps]\ndef comp {sq‚ÇÅ sq‚ÇÇ sq‚ÇÉ : Square C} (f : Hom sq‚ÇÅ sq‚ÇÇ) (g : Hom sq‚ÇÇ sq‚ÇÉ) : Hom sq‚ÇÅ sq‚ÇÉ where\n  œÑ‚ÇÅ := f.œÑ‚ÇÅ ‚â´ g.œÑ‚ÇÅ\n  œÑ‚ÇÇ := f.œÑ‚ÇÇ ‚â´ g.œÑ‚ÇÇ\n  œÑ‚ÇÉ := f.œÑ‚ÇÉ ‚â´ g.œÑ‚ÇÉ\n  œÑ‚ÇÑ := f.œÑ‚ÇÑ ‚â´ g.œÑ‚ÇÑ\n\n"}
{"name":"CategoryTheory.Square.Hom.comp_œÑ‚ÇÇ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq‚ÇÅ sq‚ÇÇ sq‚ÇÉ : CategoryTheory.Square C\nf : sq‚ÇÅ.Hom sq‚ÇÇ\ng : sq‚ÇÇ.Hom sq‚ÇÉ\n‚ä¢ Eq (f.comp g).œÑ‚ÇÇ (CategoryTheory.CategoryStruct.comp f.œÑ‚ÇÇ g.œÑ‚ÇÇ)","decl":"/-- The composition of morphisms of squares. -/\n@[simps]\ndef comp {sq‚ÇÅ sq‚ÇÇ sq‚ÇÉ : Square C} (f : Hom sq‚ÇÅ sq‚ÇÇ) (g : Hom sq‚ÇÇ sq‚ÇÉ) : Hom sq‚ÇÅ sq‚ÇÉ where\n  œÑ‚ÇÅ := f.œÑ‚ÇÅ ‚â´ g.œÑ‚ÇÅ\n  œÑ‚ÇÇ := f.œÑ‚ÇÇ ‚â´ g.œÑ‚ÇÇ\n  œÑ‚ÇÉ := f.œÑ‚ÇÉ ‚â´ g.œÑ‚ÇÉ\n  œÑ‚ÇÑ := f.œÑ‚ÇÑ ‚â´ g.œÑ‚ÇÑ\n\n"}
{"name":"CategoryTheory.Square.Hom.comp_œÑ‚ÇÉ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq‚ÇÅ sq‚ÇÇ sq‚ÇÉ : CategoryTheory.Square C\nf : sq‚ÇÅ.Hom sq‚ÇÇ\ng : sq‚ÇÇ.Hom sq‚ÇÉ\n‚ä¢ Eq (f.comp g).œÑ‚ÇÉ (CategoryTheory.CategoryStruct.comp f.œÑ‚ÇÉ g.œÑ‚ÇÉ)","decl":"/-- The composition of morphisms of squares. -/\n@[simps]\ndef comp {sq‚ÇÅ sq‚ÇÇ sq‚ÇÉ : Square C} (f : Hom sq‚ÇÅ sq‚ÇÇ) (g : Hom sq‚ÇÇ sq‚ÇÉ) : Hom sq‚ÇÅ sq‚ÇÉ where\n  œÑ‚ÇÅ := f.œÑ‚ÇÅ ‚â´ g.œÑ‚ÇÅ\n  œÑ‚ÇÇ := f.œÑ‚ÇÇ ‚â´ g.œÑ‚ÇÇ\n  œÑ‚ÇÉ := f.œÑ‚ÇÉ ‚â´ g.œÑ‚ÇÉ\n  œÑ‚ÇÑ := f.œÑ‚ÇÑ ‚â´ g.œÑ‚ÇÑ\n\n"}
{"name":"CategoryTheory.Square.Hom.comp_œÑ‚ÇÅ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq‚ÇÅ sq‚ÇÇ sq‚ÇÉ : CategoryTheory.Square C\nf : sq‚ÇÅ.Hom sq‚ÇÇ\ng : sq‚ÇÇ.Hom sq‚ÇÉ\n‚ä¢ Eq (f.comp g).œÑ‚ÇÅ (CategoryTheory.CategoryStruct.comp f.œÑ‚ÇÅ g.œÑ‚ÇÅ)","decl":"/-- The composition of morphisms of squares. -/\n@[simps]\ndef comp {sq‚ÇÅ sq‚ÇÇ sq‚ÇÉ : Square C} (f : Hom sq‚ÇÅ sq‚ÇÇ) (g : Hom sq‚ÇÇ sq‚ÇÉ) : Hom sq‚ÇÅ sq‚ÇÉ where\n  œÑ‚ÇÅ := f.œÑ‚ÇÅ ‚â´ g.œÑ‚ÇÅ\n  œÑ‚ÇÇ := f.œÑ‚ÇÇ ‚â´ g.œÑ‚ÇÇ\n  œÑ‚ÇÉ := f.œÑ‚ÇÉ ‚â´ g.œÑ‚ÇÉ\n  œÑ‚ÇÑ := f.œÑ‚ÇÑ ‚â´ g.œÑ‚ÇÑ\n\n"}
{"name":"CategoryTheory.Square.category_id_œÑ‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id sq).œÑ‚ÇÑ (CategoryTheory.CategoryStruct.id sq.X‚ÇÑ)","decl":"@[simps!]\ninstance category : Category (Square C) where\n  Hom := Hom\n  id := Hom.id\n  comp := Hom.comp\n\n"}
{"name":"CategoryTheory.Square.category_id_œÑ‚ÇÉ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id sq).œÑ‚ÇÉ (CategoryTheory.CategoryStruct.id sq.X‚ÇÉ)","decl":"@[simps!]\ninstance category : Category (Square C) where\n  Hom := Hom\n  id := Hom.id\n  comp := Hom.comp\n\n"}
{"name":"CategoryTheory.Square.category_comp_œÑ‚ÇÇ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù Z‚úù : CategoryTheory.Square C\nf : X‚úù.Hom Y‚úù\ng : Y‚úù.Hom Z‚úù\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).œÑ‚ÇÇ (CategoryTheory.CategoryStruct.comp f.œÑ‚ÇÇ g.œÑ‚ÇÇ)","decl":"@[simps!]\ninstance category : Category (Square C) where\n  Hom := Hom\n  id := Hom.id\n  comp := Hom.comp\n\n"}
{"name":"CategoryTheory.Square.category_id_œÑ‚ÇÇ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id sq).œÑ‚ÇÇ (CategoryTheory.CategoryStruct.id sq.X‚ÇÇ)","decl":"@[simps!]\ninstance category : Category (Square C) where\n  Hom := Hom\n  id := Hom.id\n  comp := Hom.comp\n\n"}
{"name":"CategoryTheory.Square.category_comp_œÑ‚ÇÉ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù Z‚úù : CategoryTheory.Square C\nf : X‚úù.Hom Y‚úù\ng : Y‚úù.Hom Z‚úù\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).œÑ‚ÇÉ (CategoryTheory.CategoryStruct.comp f.œÑ‚ÇÉ g.œÑ‚ÇÉ)","decl":"@[simps!]\ninstance category : Category (Square C) where\n  Hom := Hom\n  id := Hom.id\n  comp := Hom.comp\n\n"}
{"name":"CategoryTheory.Square.category_comp_œÑ‚ÇÅ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù Z‚úù : CategoryTheory.Square C\nf : X‚úù.Hom Y‚úù\ng : Y‚úù.Hom Z‚úù\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).œÑ‚ÇÅ (CategoryTheory.CategoryStruct.comp f.œÑ‚ÇÅ g.œÑ‚ÇÅ)","decl":"@[simps!]\ninstance category : Category (Square C) where\n  Hom := Hom\n  id := Hom.id\n  comp := Hom.comp\n\n"}
{"name":"CategoryTheory.Square.category_id_œÑ‚ÇÅ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id sq).œÑ‚ÇÅ (CategoryTheory.CategoryStruct.id sq.X‚ÇÅ)","decl":"@[simps!]\ninstance category : Category (Square C) where\n  Hom := Hom\n  id := Hom.id\n  comp := Hom.comp\n\n"}
{"name":"CategoryTheory.Square.category_comp_œÑ‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù Z‚úù : CategoryTheory.Square C\nf : X‚úù.Hom Y‚úù\ng : Y‚úù.Hom Z‚úù\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).œÑ‚ÇÑ (CategoryTheory.CategoryStruct.comp f.œÑ‚ÇÑ g.œÑ‚ÇÑ)","decl":"@[simps!]\ninstance category : Category (Square C) where\n  Hom := Hom\n  id := Hom.id\n  comp := Hom.comp\n\n"}
{"name":"CategoryTheory.Square.hom_ext","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq‚ÇÅ sq‚ÇÇ : CategoryTheory.Square C\nf g : Quiver.Hom sq‚ÇÅ sq‚ÇÇ\nh‚ÇÅ : Eq f.œÑ‚ÇÅ g.œÑ‚ÇÅ\nh‚ÇÇ : Eq f.œÑ‚ÇÇ g.œÑ‚ÇÇ\nh‚ÇÉ : Eq f.œÑ‚ÇÉ g.œÑ‚ÇÉ\nh‚ÇÑ : Eq f.œÑ‚ÇÑ g.œÑ‚ÇÑ\n‚ä¢ Eq f g","decl":"@[ext]\nlemma hom_ext {sq‚ÇÅ sq‚ÇÇ : Square C} {f g : sq‚ÇÅ ‚ü∂ sq‚ÇÇ}\n    (h‚ÇÅ : f.œÑ‚ÇÅ = g.œÑ‚ÇÅ) (h‚ÇÇ : f.œÑ‚ÇÇ = g.œÑ‚ÇÇ)\n    (h‚ÇÉ : f.œÑ‚ÇÉ = g.œÑ‚ÇÉ) (h‚ÇÑ : f.œÑ‚ÇÑ = g.œÑ‚ÇÑ) : f = g :=\n  Hom.ext h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ\n\n"}
{"name":"CategoryTheory.Square.hom_ext_iff","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq‚ÇÅ sq‚ÇÇ : CategoryTheory.Square C\nf g : Quiver.Hom sq‚ÇÅ sq‚ÇÇ\n‚ä¢ Iff (Eq f g) (And (Eq f.œÑ‚ÇÅ g.œÑ‚ÇÅ) (And (Eq f.œÑ‚ÇÇ g.œÑ‚ÇÇ) (And (Eq f.œÑ‚ÇÉ g.œÑ‚ÇÉ) (Eq f.œÑ‚ÇÑ g.œÑ‚ÇÑ))))","decl":"@[ext]\nlemma hom_ext {sq‚ÇÅ sq‚ÇÇ : Square C} {f g : sq‚ÇÅ ‚ü∂ sq‚ÇÇ}\n    (h‚ÇÅ : f.œÑ‚ÇÅ = g.œÑ‚ÇÅ) (h‚ÇÇ : f.œÑ‚ÇÇ = g.œÑ‚ÇÇ)\n    (h‚ÇÉ : f.œÑ‚ÇÉ = g.œÑ‚ÇÉ) (h‚ÇÑ : f.œÑ‚ÇÑ = g.œÑ‚ÇÑ) : f = g :=\n  Hom.ext h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ\n\n"}
{"name":"CategoryTheory.Square.flip_X‚ÇÅ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq sq.flip.X‚ÇÅ sq.X‚ÇÅ","decl":"/-- Flipping a square by switching the top-right and the bottom-left objects. -/\n@[simps]\ndef flip (sq : Square C) : Square C where\n  fac := sq.fac.symm\n\n"}
{"name":"CategoryTheory.Square.flip_X‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq sq.flip.X‚ÇÑ sq.X‚ÇÑ","decl":"/-- Flipping a square by switching the top-right and the bottom-left objects. -/\n@[simps]\ndef flip (sq : Square C) : Square C where\n  fac := sq.fac.symm\n\n"}
{"name":"CategoryTheory.Square.flip_f‚ÇÇ‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq sq.flip.f‚ÇÇ‚ÇÑ sq.f‚ÇÉ‚ÇÑ","decl":"/-- Flipping a square by switching the top-right and the bottom-left objects. -/\n@[simps]\ndef flip (sq : Square C) : Square C where\n  fac := sq.fac.symm\n\n"}
{"name":"CategoryTheory.Square.flip_X‚ÇÇ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq sq.flip.X‚ÇÇ sq.X‚ÇÉ","decl":"/-- Flipping a square by switching the top-right and the bottom-left objects. -/\n@[simps]\ndef flip (sq : Square C) : Square C where\n  fac := sq.fac.symm\n\n"}
{"name":"CategoryTheory.Square.flip_f‚ÇÅ‚ÇÉ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq sq.flip.f‚ÇÅ‚ÇÉ sq.f‚ÇÅ‚ÇÇ","decl":"/-- Flipping a square by switching the top-right and the bottom-left objects. -/\n@[simps]\ndef flip (sq : Square C) : Square C where\n  fac := sq.fac.symm\n\n"}
{"name":"CategoryTheory.Square.flip_f‚ÇÉ‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq sq.flip.f‚ÇÉ‚ÇÑ sq.f‚ÇÇ‚ÇÑ","decl":"/-- Flipping a square by switching the top-right and the bottom-left objects. -/\n@[simps]\ndef flip (sq : Square C) : Square C where\n  fac := sq.fac.symm\n\n"}
{"name":"CategoryTheory.Square.flip_f‚ÇÅ‚ÇÇ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq sq.flip.f‚ÇÅ‚ÇÇ sq.f‚ÇÅ‚ÇÉ","decl":"/-- Flipping a square by switching the top-right and the bottom-left objects. -/\n@[simps]\ndef flip (sq : Square C) : Square C where\n  fac := sq.fac.symm\n\n"}
{"name":"CategoryTheory.Square.flip_X‚ÇÉ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq sq.flip.X‚ÇÉ sq.X‚ÇÇ","decl":"/-- Flipping a square by switching the top-right and the bottom-left objects. -/\n@[simps]\ndef flip (sq : Square C) : Square C where\n  fac := sq.fac.symm\n\n"}
{"name":"CategoryTheory.Square.flipFunctor_map_œÑ‚ÇÉ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Square C\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.flipFunctor.map œÜ).œÑ‚ÇÉ œÜ.œÑ‚ÇÇ","decl":"/-- The functor which flips commutative squares. -/\n@[simps]\ndef flipFunctor : Square C ‚•§ Square C where\n  obj := flip\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.œÑ‚ÇÅ\n      œÑ‚ÇÇ := œÜ.œÑ‚ÇÉ\n      œÑ‚ÇÉ := œÜ.œÑ‚ÇÇ\n      œÑ‚ÇÑ := œÜ.œÑ‚ÇÑ }\n\n"}
{"name":"CategoryTheory.Square.flipFunctor_map_œÑ‚ÇÇ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Square C\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.flipFunctor.map œÜ).œÑ‚ÇÇ œÜ.œÑ‚ÇÉ","decl":"/-- The functor which flips commutative squares. -/\n@[simps]\ndef flipFunctor : Square C ‚•§ Square C where\n  obj := flip\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.œÑ‚ÇÅ\n      œÑ‚ÇÇ := œÜ.œÑ‚ÇÉ\n      œÑ‚ÇÉ := œÜ.œÑ‚ÇÇ\n      œÑ‚ÇÑ := œÜ.œÑ‚ÇÑ }\n\n"}
{"name":"CategoryTheory.Square.flipFunctor_map_œÑ‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Square C\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.flipFunctor.map œÜ).œÑ‚ÇÑ œÜ.œÑ‚ÇÑ","decl":"/-- The functor which flips commutative squares. -/\n@[simps]\ndef flipFunctor : Square C ‚•§ Square C where\n  obj := flip\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.œÑ‚ÇÅ\n      œÑ‚ÇÇ := œÜ.œÑ‚ÇÉ\n      œÑ‚ÇÉ := œÜ.œÑ‚ÇÇ\n      œÑ‚ÇÑ := œÜ.œÑ‚ÇÑ }\n\n"}
{"name":"CategoryTheory.Square.flipFunctor_obj","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.flipFunctor.obj sq) sq.flip","decl":"/-- The functor which flips commutative squares. -/\n@[simps]\ndef flipFunctor : Square C ‚•§ Square C where\n  obj := flip\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.œÑ‚ÇÅ\n      œÑ‚ÇÇ := œÜ.œÑ‚ÇÉ\n      œÑ‚ÇÉ := œÜ.œÑ‚ÇÇ\n      œÑ‚ÇÑ := œÜ.œÑ‚ÇÑ }\n\n"}
{"name":"CategoryTheory.Square.flipFunctor_map_œÑ‚ÇÅ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Square C\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.flipFunctor.map œÜ).œÑ‚ÇÅ œÜ.œÑ‚ÇÅ","decl":"/-- The functor which flips commutative squares. -/\n@[simps]\ndef flipFunctor : Square C ‚•§ Square C where\n  obj := flip\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.œÑ‚ÇÅ\n      œÑ‚ÇÇ := œÜ.œÑ‚ÇÉ\n      œÑ‚ÇÉ := œÜ.œÑ‚ÇÇ\n      œÑ‚ÇÑ := œÜ.œÑ‚ÇÑ }\n\n"}
{"name":"CategoryTheory.Square.flipEquivalence_unitIso","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Eq CategoryTheory.Square.flipEquivalence.unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id (CategoryTheory.Square C)))","decl":"/-- Flipping commutative squares is an auto-equivalence. -/\n@[simps]\ndef flipEquivalence : Square C ‚âå Square C where\n  functor := flipFunctor\n  inverse := flipFunctor\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Square.flipEquivalence_counitIso","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Eq CategoryTheory.Square.flipEquivalence.counitIso (CategoryTheory.Iso.refl (CategoryTheory.Square.flipFunctor.comp CategoryTheory.Square.flipFunctor))","decl":"/-- Flipping commutative squares is an auto-equivalence. -/\n@[simps]\ndef flipEquivalence : Square C ‚âå Square C where\n  functor := flipFunctor\n  inverse := flipFunctor\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Square.flipEquivalence_functor","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Eq CategoryTheory.Square.flipEquivalence.functor CategoryTheory.Square.flipFunctor","decl":"/-- Flipping commutative squares is an auto-equivalence. -/\n@[simps]\ndef flipEquivalence : Square C ‚âå Square C where\n  functor := flipFunctor\n  inverse := flipFunctor\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Square.flipEquivalence_inverse","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Eq CategoryTheory.Square.flipEquivalence.inverse CategoryTheory.Square.flipFunctor","decl":"/-- Flipping commutative squares is an auto-equivalence. -/\n@[simps]\ndef flipEquivalence : Square C ‚âå Square C where\n  functor := flipFunctor\n  inverse := flipFunctor\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor_map_right_right","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Square C\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.toArrowArrowFunctor.map œÜ).right.right œÜ.œÑ‚ÇÑ","decl":"/-- The functor `Square C ‚•§ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor : Square C ‚•§ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac : Arrow.mk sq.f‚ÇÅ‚ÇÉ ‚ü∂ Arrow.mk sq.f‚ÇÇ‚ÇÑ)\n  map œÜ := Arrow.homMk (Arrow.homMk _ _ œÜ.comm‚ÇÅ‚ÇÉ.symm)\n    (Arrow.homMk _ _ œÜ.comm‚ÇÇ‚ÇÑ.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor_map_right_left","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Square C\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.toArrowArrowFunctor.map œÜ).right.left œÜ.œÑ‚ÇÇ","decl":"/-- The functor `Square C ‚•§ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor : Square C ‚•§ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac : Arrow.mk sq.f‚ÇÅ‚ÇÉ ‚ü∂ Arrow.mk sq.f‚ÇÇ‚ÇÑ)\n  map œÜ := Arrow.homMk (Arrow.homMk _ _ œÜ.comm‚ÇÅ‚ÇÉ.symm)\n    (Arrow.homMk _ _ œÜ.comm‚ÇÇ‚ÇÑ.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor_obj_right_right","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.toArrowArrowFunctor.obj sq).right.right sq.X‚ÇÑ","decl":"/-- The functor `Square C ‚•§ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor : Square C ‚•§ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac : Arrow.mk sq.f‚ÇÅ‚ÇÉ ‚ü∂ Arrow.mk sq.f‚ÇÇ‚ÇÑ)\n  map œÜ := Arrow.homMk (Arrow.homMk _ _ œÜ.comm‚ÇÅ‚ÇÉ.symm)\n    (Arrow.homMk _ _ œÜ.comm‚ÇÇ‚ÇÑ.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor_map_left_right","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Square C\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.toArrowArrowFunctor.map œÜ).left.right œÜ.œÑ‚ÇÉ","decl":"/-- The functor `Square C ‚•§ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor : Square C ‚•§ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac : Arrow.mk sq.f‚ÇÅ‚ÇÉ ‚ü∂ Arrow.mk sq.f‚ÇÇ‚ÇÑ)\n  map œÜ := Arrow.homMk (Arrow.homMk _ _ œÜ.comm‚ÇÅ‚ÇÉ.symm)\n    (Arrow.homMk _ _ œÜ.comm‚ÇÇ‚ÇÑ.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor_obj_right_hom","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.toArrowArrowFunctor.obj sq).right.hom sq.f‚ÇÇ‚ÇÑ","decl":"/-- The functor `Square C ‚•§ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor : Square C ‚•§ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac : Arrow.mk sq.f‚ÇÅ‚ÇÉ ‚ü∂ Arrow.mk sq.f‚ÇÇ‚ÇÑ)\n  map œÜ := Arrow.homMk (Arrow.homMk _ _ œÜ.comm‚ÇÅ‚ÇÉ.symm)\n    (Arrow.homMk _ _ œÜ.comm‚ÇÇ‚ÇÑ.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor_obj_left_right","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.toArrowArrowFunctor.obj sq).left.right sq.X‚ÇÉ","decl":"/-- The functor `Square C ‚•§ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor : Square C ‚•§ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac : Arrow.mk sq.f‚ÇÅ‚ÇÉ ‚ü∂ Arrow.mk sq.f‚ÇÇ‚ÇÑ)\n  map œÜ := Arrow.homMk (Arrow.homMk _ _ œÜ.comm‚ÇÅ‚ÇÉ.symm)\n    (Arrow.homMk _ _ œÜ.comm‚ÇÇ‚ÇÑ.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor_obj_left_hom","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.toArrowArrowFunctor.obj sq).left.hom sq.f‚ÇÅ‚ÇÉ","decl":"/-- The functor `Square C ‚•§ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor : Square C ‚•§ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac : Arrow.mk sq.f‚ÇÅ‚ÇÉ ‚ü∂ Arrow.mk sq.f‚ÇÇ‚ÇÑ)\n  map œÜ := Arrow.homMk (Arrow.homMk _ _ œÜ.comm‚ÇÅ‚ÇÉ.symm)\n    (Arrow.homMk _ _ œÜ.comm‚ÇÇ‚ÇÑ.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor_map_left_left","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Square C\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.toArrowArrowFunctor.map œÜ).left.left œÜ.œÑ‚ÇÅ","decl":"/-- The functor `Square C ‚•§ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor : Square C ‚•§ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac : Arrow.mk sq.f‚ÇÅ‚ÇÉ ‚ü∂ Arrow.mk sq.f‚ÇÇ‚ÇÑ)\n  map œÜ := Arrow.homMk (Arrow.homMk _ _ œÜ.comm‚ÇÅ‚ÇÉ.symm)\n    (Arrow.homMk _ _ œÜ.comm‚ÇÇ‚ÇÑ.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor_obj_hom_left","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.toArrowArrowFunctor.obj sq).hom.left sq.f‚ÇÅ‚ÇÇ","decl":"/-- The functor `Square C ‚•§ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor : Square C ‚•§ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac : Arrow.mk sq.f‚ÇÅ‚ÇÉ ‚ü∂ Arrow.mk sq.f‚ÇÇ‚ÇÑ)\n  map œÜ := Arrow.homMk (Arrow.homMk _ _ œÜ.comm‚ÇÅ‚ÇÉ.symm)\n    (Arrow.homMk _ _ œÜ.comm‚ÇÇ‚ÇÑ.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor_obj_hom_right","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.toArrowArrowFunctor.obj sq).hom.right sq.f‚ÇÉ‚ÇÑ","decl":"/-- The functor `Square C ‚•§ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor : Square C ‚•§ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac : Arrow.mk sq.f‚ÇÅ‚ÇÉ ‚ü∂ Arrow.mk sq.f‚ÇÇ‚ÇÑ)\n  map œÜ := Arrow.homMk (Arrow.homMk _ _ œÜ.comm‚ÇÅ‚ÇÉ.symm)\n    (Arrow.homMk _ _ œÜ.comm‚ÇÇ‚ÇÑ.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor_obj_left_left","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.toArrowArrowFunctor.obj sq).left.left sq.X‚ÇÅ","decl":"/-- The functor `Square C ‚•§ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor : Square C ‚•§ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac : Arrow.mk sq.f‚ÇÅ‚ÇÉ ‚ü∂ Arrow.mk sq.f‚ÇÇ‚ÇÑ)\n  map œÜ := Arrow.homMk (Arrow.homMk _ _ œÜ.comm‚ÇÅ‚ÇÉ.symm)\n    (Arrow.homMk _ _ œÜ.comm‚ÇÇ‚ÇÑ.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor_obj_right_left","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.toArrowArrowFunctor.obj sq).right.left sq.X‚ÇÇ","decl":"/-- The functor `Square C ‚•§ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor : Square C ‚•§ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac : Arrow.mk sq.f‚ÇÅ‚ÇÉ ‚ü∂ Arrow.mk sq.f‚ÇÇ‚ÇÑ)\n  map œÜ := Arrow.homMk (Arrow.homMk _ _ œÜ.comm‚ÇÅ‚ÇÉ.symm)\n    (Arrow.homMk _ _ œÜ.comm‚ÇÇ‚ÇÑ.symm)\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor_obj_f‚ÇÉ‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n‚ä¢ Eq (CategoryTheory.Square.fromArrowArrowFunctor.obj f).f‚ÇÉ‚ÇÑ f.hom.right","decl":"/-- The functor `Arrow (Arrow C) ‚•§ Square C` which sends\na morphism `Arrow.mk f ‚ü∂ Arrow.mk g` to the commutative square\nwith `f` on the left side and `g` on the right side. -/\n@[simps!]\ndef fromArrowArrowFunctor : Arrow (Arrow C) ‚•§ Square C where\n  obj f := { fac := f.hom.w }\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.left.left\n      œÑ‚ÇÇ := œÜ.right.left\n      œÑ‚ÇÉ := œÜ.left.right\n      œÑ‚ÇÑ := œÜ.right.right\n      comm‚ÇÅ‚ÇÇ := Arrow.leftFunc.congr_map œÜ.w.symm\n      comm‚ÇÅ‚ÇÉ := œÜ.left.w.symm\n      comm‚ÇÇ‚ÇÑ := œÜ.right.w.symm\n      comm‚ÇÉ‚ÇÑ := Arrow.rightFunc.congr_map œÜ.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor_obj_X‚ÇÉ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n‚ä¢ Eq (CategoryTheory.Square.fromArrowArrowFunctor.obj f).X‚ÇÉ f.left.right","decl":"/-- The functor `Arrow (Arrow C) ‚•§ Square C` which sends\na morphism `Arrow.mk f ‚ü∂ Arrow.mk g` to the commutative square\nwith `f` on the left side and `g` on the right side. -/\n@[simps!]\ndef fromArrowArrowFunctor : Arrow (Arrow C) ‚•§ Square C where\n  obj f := { fac := f.hom.w }\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.left.left\n      œÑ‚ÇÇ := œÜ.right.left\n      œÑ‚ÇÉ := œÜ.left.right\n      œÑ‚ÇÑ := œÜ.right.right\n      comm‚ÇÅ‚ÇÇ := Arrow.leftFunc.congr_map œÜ.w.symm\n      comm‚ÇÅ‚ÇÉ := œÜ.left.w.symm\n      comm‚ÇÇ‚ÇÑ := œÜ.right.w.symm\n      comm‚ÇÉ‚ÇÑ := Arrow.rightFunc.congr_map œÜ.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor_map_œÑ‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Arrow (CategoryTheory.Arrow C)\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.fromArrowArrowFunctor.map œÜ).œÑ‚ÇÑ œÜ.right.right","decl":"/-- The functor `Arrow (Arrow C) ‚•§ Square C` which sends\na morphism `Arrow.mk f ‚ü∂ Arrow.mk g` to the commutative square\nwith `f` on the left side and `g` on the right side. -/\n@[simps!]\ndef fromArrowArrowFunctor : Arrow (Arrow C) ‚•§ Square C where\n  obj f := { fac := f.hom.w }\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.left.left\n      œÑ‚ÇÇ := œÜ.right.left\n      œÑ‚ÇÉ := œÜ.left.right\n      œÑ‚ÇÑ := œÜ.right.right\n      comm‚ÇÅ‚ÇÇ := Arrow.leftFunc.congr_map œÜ.w.symm\n      comm‚ÇÅ‚ÇÉ := œÜ.left.w.symm\n      comm‚ÇÇ‚ÇÑ := œÜ.right.w.symm\n      comm‚ÇÉ‚ÇÑ := Arrow.rightFunc.congr_map œÜ.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor_map_œÑ‚ÇÅ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Arrow (CategoryTheory.Arrow C)\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.fromArrowArrowFunctor.map œÜ).œÑ‚ÇÅ œÜ.left.left","decl":"/-- The functor `Arrow (Arrow C) ‚•§ Square C` which sends\na morphism `Arrow.mk f ‚ü∂ Arrow.mk g` to the commutative square\nwith `f` on the left side and `g` on the right side. -/\n@[simps!]\ndef fromArrowArrowFunctor : Arrow (Arrow C) ‚•§ Square C where\n  obj f := { fac := f.hom.w }\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.left.left\n      œÑ‚ÇÇ := œÜ.right.left\n      œÑ‚ÇÉ := œÜ.left.right\n      œÑ‚ÇÑ := œÜ.right.right\n      comm‚ÇÅ‚ÇÇ := Arrow.leftFunc.congr_map œÜ.w.symm\n      comm‚ÇÅ‚ÇÉ := œÜ.left.w.symm\n      comm‚ÇÇ‚ÇÑ := œÜ.right.w.symm\n      comm‚ÇÉ‚ÇÑ := Arrow.rightFunc.congr_map œÜ.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor_obj_f‚ÇÇ‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n‚ä¢ Eq (CategoryTheory.Square.fromArrowArrowFunctor.obj f).f‚ÇÇ‚ÇÑ f.right.hom","decl":"/-- The functor `Arrow (Arrow C) ‚•§ Square C` which sends\na morphism `Arrow.mk f ‚ü∂ Arrow.mk g` to the commutative square\nwith `f` on the left side and `g` on the right side. -/\n@[simps!]\ndef fromArrowArrowFunctor : Arrow (Arrow C) ‚•§ Square C where\n  obj f := { fac := f.hom.w }\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.left.left\n      œÑ‚ÇÇ := œÜ.right.left\n      œÑ‚ÇÉ := œÜ.left.right\n      œÑ‚ÇÑ := œÜ.right.right\n      comm‚ÇÅ‚ÇÇ := Arrow.leftFunc.congr_map œÜ.w.symm\n      comm‚ÇÅ‚ÇÉ := œÜ.left.w.symm\n      comm‚ÇÇ‚ÇÑ := œÜ.right.w.symm\n      comm‚ÇÉ‚ÇÑ := Arrow.rightFunc.congr_map œÜ.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor_obj_f‚ÇÅ‚ÇÉ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n‚ä¢ Eq (CategoryTheory.Square.fromArrowArrowFunctor.obj f).f‚ÇÅ‚ÇÉ f.left.hom","decl":"/-- The functor `Arrow (Arrow C) ‚•§ Square C` which sends\na morphism `Arrow.mk f ‚ü∂ Arrow.mk g` to the commutative square\nwith `f` on the left side and `g` on the right side. -/\n@[simps!]\ndef fromArrowArrowFunctor : Arrow (Arrow C) ‚•§ Square C where\n  obj f := { fac := f.hom.w }\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.left.left\n      œÑ‚ÇÇ := œÜ.right.left\n      œÑ‚ÇÉ := œÜ.left.right\n      œÑ‚ÇÑ := œÜ.right.right\n      comm‚ÇÅ‚ÇÇ := Arrow.leftFunc.congr_map œÜ.w.symm\n      comm‚ÇÅ‚ÇÉ := œÜ.left.w.symm\n      comm‚ÇÇ‚ÇÑ := œÜ.right.w.symm\n      comm‚ÇÉ‚ÇÑ := Arrow.rightFunc.congr_map œÜ.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor_obj_f‚ÇÅ‚ÇÇ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n‚ä¢ Eq (CategoryTheory.Square.fromArrowArrowFunctor.obj f).f‚ÇÅ‚ÇÇ f.hom.left","decl":"/-- The functor `Arrow (Arrow C) ‚•§ Square C` which sends\na morphism `Arrow.mk f ‚ü∂ Arrow.mk g` to the commutative square\nwith `f` on the left side and `g` on the right side. -/\n@[simps!]\ndef fromArrowArrowFunctor : Arrow (Arrow C) ‚•§ Square C where\n  obj f := { fac := f.hom.w }\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.left.left\n      œÑ‚ÇÇ := œÜ.right.left\n      œÑ‚ÇÉ := œÜ.left.right\n      œÑ‚ÇÑ := œÜ.right.right\n      comm‚ÇÅ‚ÇÇ := Arrow.leftFunc.congr_map œÜ.w.symm\n      comm‚ÇÅ‚ÇÉ := œÜ.left.w.symm\n      comm‚ÇÇ‚ÇÑ := œÜ.right.w.symm\n      comm‚ÇÉ‚ÇÑ := Arrow.rightFunc.congr_map œÜ.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor_obj_X‚ÇÅ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n‚ä¢ Eq (CategoryTheory.Square.fromArrowArrowFunctor.obj f).X‚ÇÅ f.left.left","decl":"/-- The functor `Arrow (Arrow C) ‚•§ Square C` which sends\na morphism `Arrow.mk f ‚ü∂ Arrow.mk g` to the commutative square\nwith `f` on the left side and `g` on the right side. -/\n@[simps!]\ndef fromArrowArrowFunctor : Arrow (Arrow C) ‚•§ Square C where\n  obj f := { fac := f.hom.w }\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.left.left\n      œÑ‚ÇÇ := œÜ.right.left\n      œÑ‚ÇÉ := œÜ.left.right\n      œÑ‚ÇÑ := œÜ.right.right\n      comm‚ÇÅ‚ÇÇ := Arrow.leftFunc.congr_map œÜ.w.symm\n      comm‚ÇÅ‚ÇÉ := œÜ.left.w.symm\n      comm‚ÇÇ‚ÇÑ := œÜ.right.w.symm\n      comm‚ÇÉ‚ÇÑ := Arrow.rightFunc.congr_map œÜ.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor_map_œÑ‚ÇÉ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Arrow (CategoryTheory.Arrow C)\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.fromArrowArrowFunctor.map œÜ).œÑ‚ÇÉ œÜ.left.right","decl":"/-- The functor `Arrow (Arrow C) ‚•§ Square C` which sends\na morphism `Arrow.mk f ‚ü∂ Arrow.mk g` to the commutative square\nwith `f` on the left side and `g` on the right side. -/\n@[simps!]\ndef fromArrowArrowFunctor : Arrow (Arrow C) ‚•§ Square C where\n  obj f := { fac := f.hom.w }\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.left.left\n      œÑ‚ÇÇ := œÜ.right.left\n      œÑ‚ÇÉ := œÜ.left.right\n      œÑ‚ÇÑ := œÜ.right.right\n      comm‚ÇÅ‚ÇÇ := Arrow.leftFunc.congr_map œÜ.w.symm\n      comm‚ÇÅ‚ÇÉ := œÜ.left.w.symm\n      comm‚ÇÇ‚ÇÑ := œÜ.right.w.symm\n      comm‚ÇÉ‚ÇÑ := Arrow.rightFunc.congr_map œÜ.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor_map_œÑ‚ÇÇ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Arrow (CategoryTheory.Arrow C)\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.fromArrowArrowFunctor.map œÜ).œÑ‚ÇÇ œÜ.right.left","decl":"/-- The functor `Arrow (Arrow C) ‚•§ Square C` which sends\na morphism `Arrow.mk f ‚ü∂ Arrow.mk g` to the commutative square\nwith `f` on the left side and `g` on the right side. -/\n@[simps!]\ndef fromArrowArrowFunctor : Arrow (Arrow C) ‚•§ Square C where\n  obj f := { fac := f.hom.w }\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.left.left\n      œÑ‚ÇÇ := œÜ.right.left\n      œÑ‚ÇÉ := œÜ.left.right\n      œÑ‚ÇÑ := œÜ.right.right\n      comm‚ÇÅ‚ÇÇ := Arrow.leftFunc.congr_map œÜ.w.symm\n      comm‚ÇÅ‚ÇÉ := œÜ.left.w.symm\n      comm‚ÇÇ‚ÇÑ := œÜ.right.w.symm\n      comm‚ÇÉ‚ÇÑ := Arrow.rightFunc.congr_map œÜ.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor_obj_X‚ÇÇ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n‚ä¢ Eq (CategoryTheory.Square.fromArrowArrowFunctor.obj f).X‚ÇÇ f.right.left","decl":"/-- The functor `Arrow (Arrow C) ‚•§ Square C` which sends\na morphism `Arrow.mk f ‚ü∂ Arrow.mk g` to the commutative square\nwith `f` on the left side and `g` on the right side. -/\n@[simps!]\ndef fromArrowArrowFunctor : Arrow (Arrow C) ‚•§ Square C where\n  obj f := { fac := f.hom.w }\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.left.left\n      œÑ‚ÇÇ := œÜ.right.left\n      œÑ‚ÇÉ := œÜ.left.right\n      œÑ‚ÇÑ := œÜ.right.right\n      comm‚ÇÅ‚ÇÇ := Arrow.leftFunc.congr_map œÜ.w.symm\n      comm‚ÇÅ‚ÇÉ := œÜ.left.w.symm\n      comm‚ÇÇ‚ÇÑ := œÜ.right.w.symm\n      comm‚ÇÉ‚ÇÑ := Arrow.rightFunc.congr_map œÜ.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor_obj_X‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n‚ä¢ Eq (CategoryTheory.Square.fromArrowArrowFunctor.obj f).X‚ÇÑ f.right.right","decl":"/-- The functor `Arrow (Arrow C) ‚•§ Square C` which sends\na morphism `Arrow.mk f ‚ü∂ Arrow.mk g` to the commutative square\nwith `f` on the left side and `g` on the right side. -/\n@[simps!]\ndef fromArrowArrowFunctor : Arrow (Arrow C) ‚•§ Square C where\n  obj f := { fac := f.hom.w }\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.left.left\n      œÑ‚ÇÇ := œÜ.right.left\n      œÑ‚ÇÉ := œÜ.left.right\n      œÑ‚ÇÑ := œÜ.right.right\n      comm‚ÇÅ‚ÇÇ := Arrow.leftFunc.congr_map œÜ.w.symm\n      comm‚ÇÅ‚ÇÉ := œÜ.left.w.symm\n      comm‚ÇÇ‚ÇÑ := œÜ.right.w.symm\n      comm‚ÇÉ‚ÇÑ := Arrow.rightFunc.congr_map œÜ.w.symm }\n\n"}
{"name":"CategoryTheory.Square.arrowArrowEquivalence_inverse","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Eq CategoryTheory.Square.arrowArrowEquivalence.inverse CategoryTheory.Square.fromArrowArrowFunctor","decl":"/-- The equivalence `Square C ‚âå Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps]\ndef arrowArrowEquivalence : Square C ‚âå Arrow (Arrow C) where\n  functor := toArrowArrowFunctor\n  inverse := fromArrowArrowFunctor\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Square.arrowArrowEquivalence_counitIso","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Eq CategoryTheory.Square.arrowArrowEquivalence.counitIso (CategoryTheory.Iso.refl (CategoryTheory.Square.fromArrowArrowFunctor.comp CategoryTheory.Square.toArrowArrowFunctor))","decl":"/-- The equivalence `Square C ‚âå Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps]\ndef arrowArrowEquivalence : Square C ‚âå Arrow (Arrow C) where\n  functor := toArrowArrowFunctor\n  inverse := fromArrowArrowFunctor\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Square.arrowArrowEquivalence_unitIso","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Eq CategoryTheory.Square.arrowArrowEquivalence.unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id (CategoryTheory.Square C)))","decl":"/-- The equivalence `Square C ‚âå Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps]\ndef arrowArrowEquivalence : Square C ‚âå Arrow (Arrow C) where\n  functor := toArrowArrowFunctor\n  inverse := fromArrowArrowFunctor\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Square.arrowArrowEquivalence_functor","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Eq CategoryTheory.Square.arrowArrowEquivalence.functor CategoryTheory.Square.toArrowArrowFunctor","decl":"/-- The equivalence `Square C ‚âå Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps]\ndef arrowArrowEquivalence : Square C ‚âå Arrow (Arrow C) where\n  functor := toArrowArrowFunctor\n  inverse := fromArrowArrowFunctor\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor'_obj_right_left","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.toArrowArrowFunctor'.obj sq).right.left sq.X‚ÇÉ","decl":"/-- The functor `Square C ‚•§ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor' : Square C ‚•§ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac.symm : Arrow.mk sq.f‚ÇÅ‚ÇÇ ‚ü∂ Arrow.mk sq.f‚ÇÉ‚ÇÑ)\n  map œÜ := Arrow.homMk (Arrow.homMk _ _ œÜ.comm‚ÇÅ‚ÇÇ.symm)\n    (Arrow.homMk _ _ œÜ.comm‚ÇÉ‚ÇÑ.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor'_map_left_left","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Square C\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.toArrowArrowFunctor'.map œÜ).left.left œÜ.œÑ‚ÇÅ","decl":"/-- The functor `Square C ‚•§ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor' : Square C ‚•§ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac.symm : Arrow.mk sq.f‚ÇÅ‚ÇÇ ‚ü∂ Arrow.mk sq.f‚ÇÉ‚ÇÑ)\n  map œÜ := Arrow.homMk (Arrow.homMk _ _ œÜ.comm‚ÇÅ‚ÇÇ.symm)\n    (Arrow.homMk _ _ œÜ.comm‚ÇÉ‚ÇÑ.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor'_obj_right_hom","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.toArrowArrowFunctor'.obj sq).right.hom sq.f‚ÇÉ‚ÇÑ","decl":"/-- The functor `Square C ‚•§ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor' : Square C ‚•§ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac.symm : Arrow.mk sq.f‚ÇÅ‚ÇÇ ‚ü∂ Arrow.mk sq.f‚ÇÉ‚ÇÑ)\n  map œÜ := Arrow.homMk (Arrow.homMk _ _ œÜ.comm‚ÇÅ‚ÇÇ.symm)\n    (Arrow.homMk _ _ œÜ.comm‚ÇÉ‚ÇÑ.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor'_obj_left_right","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.toArrowArrowFunctor'.obj sq).left.right sq.X‚ÇÇ","decl":"/-- The functor `Square C ‚•§ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor' : Square C ‚•§ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac.symm : Arrow.mk sq.f‚ÇÅ‚ÇÇ ‚ü∂ Arrow.mk sq.f‚ÇÉ‚ÇÑ)\n  map œÜ := Arrow.homMk (Arrow.homMk _ _ œÜ.comm‚ÇÅ‚ÇÇ.symm)\n    (Arrow.homMk _ _ œÜ.comm‚ÇÉ‚ÇÑ.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor'_map_right_right","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Square C\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.toArrowArrowFunctor'.map œÜ).right.right œÜ.œÑ‚ÇÑ","decl":"/-- The functor `Square C ‚•§ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor' : Square C ‚•§ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac.symm : Arrow.mk sq.f‚ÇÅ‚ÇÇ ‚ü∂ Arrow.mk sq.f‚ÇÉ‚ÇÑ)\n  map œÜ := Arrow.homMk (Arrow.homMk _ _ œÜ.comm‚ÇÅ‚ÇÇ.symm)\n    (Arrow.homMk _ _ œÜ.comm‚ÇÉ‚ÇÑ.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor'_obj_hom_left","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.toArrowArrowFunctor'.obj sq).hom.left sq.f‚ÇÅ‚ÇÉ","decl":"/-- The functor `Square C ‚•§ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor' : Square C ‚•§ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac.symm : Arrow.mk sq.f‚ÇÅ‚ÇÇ ‚ü∂ Arrow.mk sq.f‚ÇÉ‚ÇÑ)\n  map œÜ := Arrow.homMk (Arrow.homMk _ _ œÜ.comm‚ÇÅ‚ÇÇ.symm)\n    (Arrow.homMk _ _ œÜ.comm‚ÇÉ‚ÇÑ.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor'_map_left_right","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Square C\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.toArrowArrowFunctor'.map œÜ).left.right œÜ.œÑ‚ÇÇ","decl":"/-- The functor `Square C ‚•§ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor' : Square C ‚•§ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac.symm : Arrow.mk sq.f‚ÇÅ‚ÇÇ ‚ü∂ Arrow.mk sq.f‚ÇÉ‚ÇÑ)\n  map œÜ := Arrow.homMk (Arrow.homMk _ _ œÜ.comm‚ÇÅ‚ÇÇ.symm)\n    (Arrow.homMk _ _ œÜ.comm‚ÇÉ‚ÇÑ.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor'_obj_right_right","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.toArrowArrowFunctor'.obj sq).right.right sq.X‚ÇÑ","decl":"/-- The functor `Square C ‚•§ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor' : Square C ‚•§ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac.symm : Arrow.mk sq.f‚ÇÅ‚ÇÇ ‚ü∂ Arrow.mk sq.f‚ÇÉ‚ÇÑ)\n  map œÜ := Arrow.homMk (Arrow.homMk _ _ œÜ.comm‚ÇÅ‚ÇÇ.symm)\n    (Arrow.homMk _ _ œÜ.comm‚ÇÉ‚ÇÑ.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor'_obj_left_hom","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.toArrowArrowFunctor'.obj sq).left.hom sq.f‚ÇÅ‚ÇÇ","decl":"/-- The functor `Square C ‚•§ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor' : Square C ‚•§ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac.symm : Arrow.mk sq.f‚ÇÅ‚ÇÇ ‚ü∂ Arrow.mk sq.f‚ÇÉ‚ÇÑ)\n  map œÜ := Arrow.homMk (Arrow.homMk _ _ œÜ.comm‚ÇÅ‚ÇÇ.symm)\n    (Arrow.homMk _ _ œÜ.comm‚ÇÉ‚ÇÑ.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor'_obj_left_left","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.toArrowArrowFunctor'.obj sq).left.left sq.X‚ÇÅ","decl":"/-- The functor `Square C ‚•§ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor' : Square C ‚•§ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac.symm : Arrow.mk sq.f‚ÇÅ‚ÇÇ ‚ü∂ Arrow.mk sq.f‚ÇÉ‚ÇÑ)\n  map œÜ := Arrow.homMk (Arrow.homMk _ _ œÜ.comm‚ÇÅ‚ÇÇ.symm)\n    (Arrow.homMk _ _ œÜ.comm‚ÇÉ‚ÇÑ.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor'_obj_hom_right","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.toArrowArrowFunctor'.obj sq).hom.right sq.f‚ÇÇ‚ÇÑ","decl":"/-- The functor `Square C ‚•§ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor' : Square C ‚•§ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac.symm : Arrow.mk sq.f‚ÇÅ‚ÇÇ ‚ü∂ Arrow.mk sq.f‚ÇÉ‚ÇÑ)\n  map œÜ := Arrow.homMk (Arrow.homMk _ _ œÜ.comm‚ÇÅ‚ÇÇ.symm)\n    (Arrow.homMk _ _ œÜ.comm‚ÇÉ‚ÇÑ.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor'_map_right_left","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Square C\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.toArrowArrowFunctor'.map œÜ).right.left œÜ.œÑ‚ÇÉ","decl":"/-- The functor `Square C ‚•§ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor' : Square C ‚•§ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac.symm : Arrow.mk sq.f‚ÇÅ‚ÇÇ ‚ü∂ Arrow.mk sq.f‚ÇÉ‚ÇÑ)\n  map œÜ := Arrow.homMk (Arrow.homMk _ _ œÜ.comm‚ÇÅ‚ÇÇ.symm)\n    (Arrow.homMk _ _ œÜ.comm‚ÇÉ‚ÇÑ.symm)\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor'_obj_X‚ÇÇ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n‚ä¢ Eq (CategoryTheory.Square.fromArrowArrowFunctor'.obj f).X‚ÇÇ f.left.right","decl":"/-- The functor `Arrow (Arrow C) ‚•§ Square C` which sends\na morphism `Arrow.mk f ‚ü∂ Arrow.mk g` to the commutative square\nwith `f` on the top side and `g` on the bottom side. -/\n@[simps!]\ndef fromArrowArrowFunctor' : Arrow (Arrow C) ‚•§ Square C where\n  obj f := { fac := f.hom.w.symm }\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.left.left\n      œÑ‚ÇÇ := œÜ.left.right\n      œÑ‚ÇÉ := œÜ.right.left\n      œÑ‚ÇÑ := œÜ.right.right\n      comm‚ÇÅ‚ÇÇ := œÜ.left.w.symm\n      comm‚ÇÅ‚ÇÉ := Arrow.leftFunc.congr_map œÜ.w.symm\n      comm‚ÇÇ‚ÇÑ := Arrow.rightFunc.congr_map œÜ.w.symm\n      comm‚ÇÉ‚ÇÑ := œÜ.right.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor'_map_œÑ‚ÇÅ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Arrow (CategoryTheory.Arrow C)\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.fromArrowArrowFunctor'.map œÜ).œÑ‚ÇÅ œÜ.left.left","decl":"/-- The functor `Arrow (Arrow C) ‚•§ Square C` which sends\na morphism `Arrow.mk f ‚ü∂ Arrow.mk g` to the commutative square\nwith `f` on the top side and `g` on the bottom side. -/\n@[simps!]\ndef fromArrowArrowFunctor' : Arrow (Arrow C) ‚•§ Square C where\n  obj f := { fac := f.hom.w.symm }\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.left.left\n      œÑ‚ÇÇ := œÜ.left.right\n      œÑ‚ÇÉ := œÜ.right.left\n      œÑ‚ÇÑ := œÜ.right.right\n      comm‚ÇÅ‚ÇÇ := œÜ.left.w.symm\n      comm‚ÇÅ‚ÇÉ := Arrow.leftFunc.congr_map œÜ.w.symm\n      comm‚ÇÇ‚ÇÑ := Arrow.rightFunc.congr_map œÜ.w.symm\n      comm‚ÇÉ‚ÇÑ := œÜ.right.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor'_obj_f‚ÇÇ‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n‚ä¢ Eq (CategoryTheory.Square.fromArrowArrowFunctor'.obj f).f‚ÇÇ‚ÇÑ f.hom.right","decl":"/-- The functor `Arrow (Arrow C) ‚•§ Square C` which sends\na morphism `Arrow.mk f ‚ü∂ Arrow.mk g` to the commutative square\nwith `f` on the top side and `g` on the bottom side. -/\n@[simps!]\ndef fromArrowArrowFunctor' : Arrow (Arrow C) ‚•§ Square C where\n  obj f := { fac := f.hom.w.symm }\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.left.left\n      œÑ‚ÇÇ := œÜ.left.right\n      œÑ‚ÇÉ := œÜ.right.left\n      œÑ‚ÇÑ := œÜ.right.right\n      comm‚ÇÅ‚ÇÇ := œÜ.left.w.symm\n      comm‚ÇÅ‚ÇÉ := Arrow.leftFunc.congr_map œÜ.w.symm\n      comm‚ÇÇ‚ÇÑ := Arrow.rightFunc.congr_map œÜ.w.symm\n      comm‚ÇÉ‚ÇÑ := œÜ.right.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor'_obj_X‚ÇÉ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n‚ä¢ Eq (CategoryTheory.Square.fromArrowArrowFunctor'.obj f).X‚ÇÉ f.right.left","decl":"/-- The functor `Arrow (Arrow C) ‚•§ Square C` which sends\na morphism `Arrow.mk f ‚ü∂ Arrow.mk g` to the commutative square\nwith `f` on the top side and `g` on the bottom side. -/\n@[simps!]\ndef fromArrowArrowFunctor' : Arrow (Arrow C) ‚•§ Square C where\n  obj f := { fac := f.hom.w.symm }\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.left.left\n      œÑ‚ÇÇ := œÜ.left.right\n      œÑ‚ÇÉ := œÜ.right.left\n      œÑ‚ÇÑ := œÜ.right.right\n      comm‚ÇÅ‚ÇÇ := œÜ.left.w.symm\n      comm‚ÇÅ‚ÇÉ := Arrow.leftFunc.congr_map œÜ.w.symm\n      comm‚ÇÇ‚ÇÑ := Arrow.rightFunc.congr_map œÜ.w.symm\n      comm‚ÇÉ‚ÇÑ := œÜ.right.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor'_obj_X‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n‚ä¢ Eq (CategoryTheory.Square.fromArrowArrowFunctor'.obj f).X‚ÇÑ f.right.right","decl":"/-- The functor `Arrow (Arrow C) ‚•§ Square C` which sends\na morphism `Arrow.mk f ‚ü∂ Arrow.mk g` to the commutative square\nwith `f` on the top side and `g` on the bottom side. -/\n@[simps!]\ndef fromArrowArrowFunctor' : Arrow (Arrow C) ‚•§ Square C where\n  obj f := { fac := f.hom.w.symm }\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.left.left\n      œÑ‚ÇÇ := œÜ.left.right\n      œÑ‚ÇÉ := œÜ.right.left\n      œÑ‚ÇÑ := œÜ.right.right\n      comm‚ÇÅ‚ÇÇ := œÜ.left.w.symm\n      comm‚ÇÅ‚ÇÉ := Arrow.leftFunc.congr_map œÜ.w.symm\n      comm‚ÇÇ‚ÇÑ := Arrow.rightFunc.congr_map œÜ.w.symm\n      comm‚ÇÉ‚ÇÑ := œÜ.right.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor'_obj_f‚ÇÅ‚ÇÇ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n‚ä¢ Eq (CategoryTheory.Square.fromArrowArrowFunctor'.obj f).f‚ÇÅ‚ÇÇ f.left.hom","decl":"/-- The functor `Arrow (Arrow C) ‚•§ Square C` which sends\na morphism `Arrow.mk f ‚ü∂ Arrow.mk g` to the commutative square\nwith `f` on the top side and `g` on the bottom side. -/\n@[simps!]\ndef fromArrowArrowFunctor' : Arrow (Arrow C) ‚•§ Square C where\n  obj f := { fac := f.hom.w.symm }\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.left.left\n      œÑ‚ÇÇ := œÜ.left.right\n      œÑ‚ÇÉ := œÜ.right.left\n      œÑ‚ÇÑ := œÜ.right.right\n      comm‚ÇÅ‚ÇÇ := œÜ.left.w.symm\n      comm‚ÇÅ‚ÇÉ := Arrow.leftFunc.congr_map œÜ.w.symm\n      comm‚ÇÇ‚ÇÑ := Arrow.rightFunc.congr_map œÜ.w.symm\n      comm‚ÇÉ‚ÇÑ := œÜ.right.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor'_map_œÑ‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Arrow (CategoryTheory.Arrow C)\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.fromArrowArrowFunctor'.map œÜ).œÑ‚ÇÑ œÜ.right.right","decl":"/-- The functor `Arrow (Arrow C) ‚•§ Square C` which sends\na morphism `Arrow.mk f ‚ü∂ Arrow.mk g` to the commutative square\nwith `f` on the top side and `g` on the bottom side. -/\n@[simps!]\ndef fromArrowArrowFunctor' : Arrow (Arrow C) ‚•§ Square C where\n  obj f := { fac := f.hom.w.symm }\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.left.left\n      œÑ‚ÇÇ := œÜ.left.right\n      œÑ‚ÇÉ := œÜ.right.left\n      œÑ‚ÇÑ := œÜ.right.right\n      comm‚ÇÅ‚ÇÇ := œÜ.left.w.symm\n      comm‚ÇÅ‚ÇÉ := Arrow.leftFunc.congr_map œÜ.w.symm\n      comm‚ÇÇ‚ÇÑ := Arrow.rightFunc.congr_map œÜ.w.symm\n      comm‚ÇÉ‚ÇÑ := œÜ.right.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor'_obj_X‚ÇÅ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n‚ä¢ Eq (CategoryTheory.Square.fromArrowArrowFunctor'.obj f).X‚ÇÅ f.left.left","decl":"/-- The functor `Arrow (Arrow C) ‚•§ Square C` which sends\na morphism `Arrow.mk f ‚ü∂ Arrow.mk g` to the commutative square\nwith `f` on the top side and `g` on the bottom side. -/\n@[simps!]\ndef fromArrowArrowFunctor' : Arrow (Arrow C) ‚•§ Square C where\n  obj f := { fac := f.hom.w.symm }\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.left.left\n      œÑ‚ÇÇ := œÜ.left.right\n      œÑ‚ÇÉ := œÜ.right.left\n      œÑ‚ÇÑ := œÜ.right.right\n      comm‚ÇÅ‚ÇÇ := œÜ.left.w.symm\n      comm‚ÇÅ‚ÇÉ := Arrow.leftFunc.congr_map œÜ.w.symm\n      comm‚ÇÇ‚ÇÑ := Arrow.rightFunc.congr_map œÜ.w.symm\n      comm‚ÇÉ‚ÇÑ := œÜ.right.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor'_map_œÑ‚ÇÇ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Arrow (CategoryTheory.Arrow C)\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.fromArrowArrowFunctor'.map œÜ).œÑ‚ÇÇ œÜ.left.right","decl":"/-- The functor `Arrow (Arrow C) ‚•§ Square C` which sends\na morphism `Arrow.mk f ‚ü∂ Arrow.mk g` to the commutative square\nwith `f` on the top side and `g` on the bottom side. -/\n@[simps!]\ndef fromArrowArrowFunctor' : Arrow (Arrow C) ‚•§ Square C where\n  obj f := { fac := f.hom.w.symm }\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.left.left\n      œÑ‚ÇÇ := œÜ.left.right\n      œÑ‚ÇÉ := œÜ.right.left\n      œÑ‚ÇÑ := œÜ.right.right\n      comm‚ÇÅ‚ÇÇ := œÜ.left.w.symm\n      comm‚ÇÅ‚ÇÉ := Arrow.leftFunc.congr_map œÜ.w.symm\n      comm‚ÇÇ‚ÇÑ := Arrow.rightFunc.congr_map œÜ.w.symm\n      comm‚ÇÉ‚ÇÑ := œÜ.right.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor'_obj_f‚ÇÉ‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n‚ä¢ Eq (CategoryTheory.Square.fromArrowArrowFunctor'.obj f).f‚ÇÉ‚ÇÑ f.right.hom","decl":"/-- The functor `Arrow (Arrow C) ‚•§ Square C` which sends\na morphism `Arrow.mk f ‚ü∂ Arrow.mk g` to the commutative square\nwith `f` on the top side and `g` on the bottom side. -/\n@[simps!]\ndef fromArrowArrowFunctor' : Arrow (Arrow C) ‚•§ Square C where\n  obj f := { fac := f.hom.w.symm }\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.left.left\n      œÑ‚ÇÇ := œÜ.left.right\n      œÑ‚ÇÉ := œÜ.right.left\n      œÑ‚ÇÑ := œÜ.right.right\n      comm‚ÇÅ‚ÇÇ := œÜ.left.w.symm\n      comm‚ÇÅ‚ÇÉ := Arrow.leftFunc.congr_map œÜ.w.symm\n      comm‚ÇÇ‚ÇÑ := Arrow.rightFunc.congr_map œÜ.w.symm\n      comm‚ÇÉ‚ÇÑ := œÜ.right.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor'_map_œÑ‚ÇÉ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Arrow (CategoryTheory.Arrow C)\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.fromArrowArrowFunctor'.map œÜ).œÑ‚ÇÉ œÜ.right.left","decl":"/-- The functor `Arrow (Arrow C) ‚•§ Square C` which sends\na morphism `Arrow.mk f ‚ü∂ Arrow.mk g` to the commutative square\nwith `f` on the top side and `g` on the bottom side. -/\n@[simps!]\ndef fromArrowArrowFunctor' : Arrow (Arrow C) ‚•§ Square C where\n  obj f := { fac := f.hom.w.symm }\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.left.left\n      œÑ‚ÇÇ := œÜ.left.right\n      œÑ‚ÇÉ := œÜ.right.left\n      œÑ‚ÇÑ := œÜ.right.right\n      comm‚ÇÅ‚ÇÇ := œÜ.left.w.symm\n      comm‚ÇÅ‚ÇÉ := Arrow.leftFunc.congr_map œÜ.w.symm\n      comm‚ÇÇ‚ÇÑ := Arrow.rightFunc.congr_map œÜ.w.symm\n      comm‚ÇÉ‚ÇÑ := œÜ.right.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor'_obj_f‚ÇÅ‚ÇÉ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n‚ä¢ Eq (CategoryTheory.Square.fromArrowArrowFunctor'.obj f).f‚ÇÅ‚ÇÉ f.hom.left","decl":"/-- The functor `Arrow (Arrow C) ‚•§ Square C` which sends\na morphism `Arrow.mk f ‚ü∂ Arrow.mk g` to the commutative square\nwith `f` on the top side and `g` on the bottom side. -/\n@[simps!]\ndef fromArrowArrowFunctor' : Arrow (Arrow C) ‚•§ Square C where\n  obj f := { fac := f.hom.w.symm }\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.left.left\n      œÑ‚ÇÇ := œÜ.left.right\n      œÑ‚ÇÉ := œÜ.right.left\n      œÑ‚ÇÑ := œÜ.right.right\n      comm‚ÇÅ‚ÇÇ := œÜ.left.w.symm\n      comm‚ÇÅ‚ÇÉ := Arrow.leftFunc.congr_map œÜ.w.symm\n      comm‚ÇÇ‚ÇÑ := Arrow.rightFunc.congr_map œÜ.w.symm\n      comm‚ÇÉ‚ÇÑ := œÜ.right.w.symm }\n\n"}
{"name":"CategoryTheory.Square.arrowArrowEquivalence'_inverse","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Eq CategoryTheory.Square.arrowArrowEquivalence'.inverse CategoryTheory.Square.fromArrowArrowFunctor'","decl":"/-- The equivalence `Square C ‚âå Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps]\ndef arrowArrowEquivalence' : Square C ‚âå Arrow (Arrow C) where\n  functor := toArrowArrowFunctor'\n  inverse := fromArrowArrowFunctor'\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Square.arrowArrowEquivalence'_functor","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Eq CategoryTheory.Square.arrowArrowEquivalence'.functor CategoryTheory.Square.toArrowArrowFunctor'","decl":"/-- The equivalence `Square C ‚âå Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps]\ndef arrowArrowEquivalence' : Square C ‚âå Arrow (Arrow C) where\n  functor := toArrowArrowFunctor'\n  inverse := fromArrowArrowFunctor'\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Square.arrowArrowEquivalence'_unitIso","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Eq CategoryTheory.Square.arrowArrowEquivalence'.unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id (CategoryTheory.Square C)))","decl":"/-- The equivalence `Square C ‚âå Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps]\ndef arrowArrowEquivalence' : Square C ‚âå Arrow (Arrow C) where\n  functor := toArrowArrowFunctor'\n  inverse := fromArrowArrowFunctor'\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Square.arrowArrowEquivalence'_counitIso","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Eq CategoryTheory.Square.arrowArrowEquivalence'.counitIso (CategoryTheory.Iso.refl (CategoryTheory.Square.fromArrowArrowFunctor'.comp CategoryTheory.Square.toArrowArrowFunctor'))","decl":"/-- The equivalence `Square C ‚âå Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps]\ndef arrowArrowEquivalence' : Square C ‚âå Arrow (Arrow C) where\n  functor := toArrowArrowFunctor'\n  inverse := fromArrowArrowFunctor'\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Square.evaluation‚ÇÅ_map","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Square C\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.evaluation‚ÇÅ.map œÜ) œÜ.œÑ‚ÇÅ","decl":"/-- The top-left evaluation `Square C ‚•§ C`. -/\n@[simps]\ndef evaluation‚ÇÅ : Square C ‚•§ C where\n  obj sq := sq.X‚ÇÅ\n  map œÜ := œÜ.œÑ‚ÇÅ\n\n"}
{"name":"CategoryTheory.Square.evaluation‚ÇÅ_obj","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.evaluation‚ÇÅ.obj sq) sq.X‚ÇÅ","decl":"/-- The top-left evaluation `Square C ‚•§ C`. -/\n@[simps]\ndef evaluation‚ÇÅ : Square C ‚•§ C where\n  obj sq := sq.X‚ÇÅ\n  map œÜ := œÜ.œÑ‚ÇÅ\n\n"}
{"name":"CategoryTheory.Square.evaluation‚ÇÇ_map","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Square C\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.evaluation‚ÇÇ.map œÜ) œÜ.œÑ‚ÇÇ","decl":"/-- The top-right evaluation `Square C ‚•§ C`. -/\n@[simps]\ndef evaluation‚ÇÇ : Square C ‚•§ C where\n  obj sq := sq.X‚ÇÇ\n  map œÜ := œÜ.œÑ‚ÇÇ\n\n"}
{"name":"CategoryTheory.Square.evaluation‚ÇÇ_obj","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.evaluation‚ÇÇ.obj sq) sq.X‚ÇÇ","decl":"/-- The top-right evaluation `Square C ‚•§ C`. -/\n@[simps]\ndef evaluation‚ÇÇ : Square C ‚•§ C where\n  obj sq := sq.X‚ÇÇ\n  map œÜ := œÜ.œÑ‚ÇÇ\n\n"}
{"name":"CategoryTheory.Square.evaluation‚ÇÉ_obj","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.evaluation‚ÇÉ.obj sq) sq.X‚ÇÉ","decl":"/-- The bottom-left evaluation `Square C ‚•§ C`. -/\n@[simps]\ndef evaluation‚ÇÉ : Square C ‚•§ C where\n  obj sq := sq.X‚ÇÉ\n  map œÜ := œÜ.œÑ‚ÇÉ\n\n"}
{"name":"CategoryTheory.Square.evaluation‚ÇÉ_map","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Square C\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.evaluation‚ÇÉ.map œÜ) œÜ.œÑ‚ÇÉ","decl":"/-- The bottom-left evaluation `Square C ‚•§ C`. -/\n@[simps]\ndef evaluation‚ÇÉ : Square C ‚•§ C where\n  obj sq := sq.X‚ÇÉ\n  map œÜ := œÜ.œÑ‚ÇÉ\n\n"}
{"name":"CategoryTheory.Square.evaluation‚ÇÑ_obj","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq (CategoryTheory.Square.evaluation‚ÇÑ.obj sq) sq.X‚ÇÑ","decl":"/-- The bottom-right evaluation `Square C ‚•§ C`. -/\n@[simps]\ndef evaluation‚ÇÑ : Square C ‚•§ C where\n  obj sq := sq.X‚ÇÑ\n  map œÜ := œÜ.œÑ‚ÇÑ\n\n"}
{"name":"CategoryTheory.Square.evaluation‚ÇÑ_map","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Square C\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.evaluation‚ÇÑ.map œÜ) œÜ.œÑ‚ÇÑ","decl":"/-- The bottom-right evaluation `Square C ‚•§ C`. -/\n@[simps]\ndef evaluation‚ÇÑ : Square C ‚•§ C where\n  obj sq := sq.X‚ÇÑ\n  map œÜ := œÜ.œÑ‚ÇÑ\n\n"}
{"name":"CategoryTheory.Square.op_f‚ÇÅ‚ÇÉ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq sq.op.f‚ÇÅ‚ÇÉ sq.f‚ÇÉ‚ÇÑ.op","decl":"/-- The map `Square C ‚Üí Square C·µí·µñ` which switches `X‚ÇÅ` and `X‚ÇÉ`, but\ndoes not move `X‚ÇÇ` and `X‚ÇÉ`. -/\n@[simps]\nprotected def op (sq : Square C) : Square C·µí·µñ where\n  f‚ÇÅ‚ÇÇ := sq.f‚ÇÇ‚ÇÑ.op\n  f‚ÇÅ‚ÇÉ := sq.f‚ÇÉ‚ÇÑ.op\n  f‚ÇÇ‚ÇÑ := sq.f‚ÇÅ‚ÇÇ.op\n  f‚ÇÉ‚ÇÑ := sq.f‚ÇÅ‚ÇÉ.op\n  fac := Quiver.Hom.unop_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.op_X‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq sq.op.X‚ÇÑ { unop := sq.X‚ÇÅ }","decl":"/-- The map `Square C ‚Üí Square C·µí·µñ` which switches `X‚ÇÅ` and `X‚ÇÉ`, but\ndoes not move `X‚ÇÇ` and `X‚ÇÉ`. -/\n@[simps]\nprotected def op (sq : Square C) : Square C·µí·µñ where\n  f‚ÇÅ‚ÇÇ := sq.f‚ÇÇ‚ÇÑ.op\n  f‚ÇÅ‚ÇÉ := sq.f‚ÇÉ‚ÇÑ.op\n  f‚ÇÇ‚ÇÑ := sq.f‚ÇÅ‚ÇÇ.op\n  f‚ÇÉ‚ÇÑ := sq.f‚ÇÅ‚ÇÉ.op\n  fac := Quiver.Hom.unop_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.op_f‚ÇÇ‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq sq.op.f‚ÇÇ‚ÇÑ sq.f‚ÇÅ‚ÇÇ.op","decl":"/-- The map `Square C ‚Üí Square C·µí·µñ` which switches `X‚ÇÅ` and `X‚ÇÉ`, but\ndoes not move `X‚ÇÇ` and `X‚ÇÉ`. -/\n@[simps]\nprotected def op (sq : Square C) : Square C·µí·µñ where\n  f‚ÇÅ‚ÇÇ := sq.f‚ÇÇ‚ÇÑ.op\n  f‚ÇÅ‚ÇÉ := sq.f‚ÇÉ‚ÇÑ.op\n  f‚ÇÇ‚ÇÑ := sq.f‚ÇÅ‚ÇÇ.op\n  f‚ÇÉ‚ÇÑ := sq.f‚ÇÅ‚ÇÉ.op\n  fac := Quiver.Hom.unop_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.op_f‚ÇÅ‚ÇÇ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq sq.op.f‚ÇÅ‚ÇÇ sq.f‚ÇÇ‚ÇÑ.op","decl":"/-- The map `Square C ‚Üí Square C·µí·µñ` which switches `X‚ÇÅ` and `X‚ÇÉ`, but\ndoes not move `X‚ÇÇ` and `X‚ÇÉ`. -/\n@[simps]\nprotected def op (sq : Square C) : Square C·µí·µñ where\n  f‚ÇÅ‚ÇÇ := sq.f‚ÇÇ‚ÇÑ.op\n  f‚ÇÅ‚ÇÉ := sq.f‚ÇÉ‚ÇÑ.op\n  f‚ÇÇ‚ÇÑ := sq.f‚ÇÅ‚ÇÇ.op\n  f‚ÇÉ‚ÇÑ := sq.f‚ÇÅ‚ÇÉ.op\n  fac := Quiver.Hom.unop_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.op_X‚ÇÇ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq sq.op.X‚ÇÇ { unop := sq.X‚ÇÇ }","decl":"/-- The map `Square C ‚Üí Square C·µí·µñ` which switches `X‚ÇÅ` and `X‚ÇÉ`, but\ndoes not move `X‚ÇÇ` and `X‚ÇÉ`. -/\n@[simps]\nprotected def op (sq : Square C) : Square C·µí·µñ where\n  f‚ÇÅ‚ÇÇ := sq.f‚ÇÇ‚ÇÑ.op\n  f‚ÇÅ‚ÇÉ := sq.f‚ÇÉ‚ÇÑ.op\n  f‚ÇÇ‚ÇÑ := sq.f‚ÇÅ‚ÇÇ.op\n  f‚ÇÉ‚ÇÑ := sq.f‚ÇÅ‚ÇÉ.op\n  fac := Quiver.Hom.unop_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.op_X‚ÇÉ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq sq.op.X‚ÇÉ { unop := sq.X‚ÇÉ }","decl":"/-- The map `Square C ‚Üí Square C·µí·µñ` which switches `X‚ÇÅ` and `X‚ÇÉ`, but\ndoes not move `X‚ÇÇ` and `X‚ÇÉ`. -/\n@[simps]\nprotected def op (sq : Square C) : Square C·µí·µñ where\n  f‚ÇÅ‚ÇÇ := sq.f‚ÇÇ‚ÇÑ.op\n  f‚ÇÅ‚ÇÉ := sq.f‚ÇÉ‚ÇÑ.op\n  f‚ÇÇ‚ÇÑ := sq.f‚ÇÅ‚ÇÇ.op\n  f‚ÇÉ‚ÇÑ := sq.f‚ÇÅ‚ÇÉ.op\n  fac := Quiver.Hom.unop_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.op_f‚ÇÉ‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq sq.op.f‚ÇÉ‚ÇÑ sq.f‚ÇÅ‚ÇÉ.op","decl":"/-- The map `Square C ‚Üí Square C·µí·µñ` which switches `X‚ÇÅ` and `X‚ÇÉ`, but\ndoes not move `X‚ÇÇ` and `X‚ÇÉ`. -/\n@[simps]\nprotected def op (sq : Square C) : Square C·µí·µñ where\n  f‚ÇÅ‚ÇÇ := sq.f‚ÇÇ‚ÇÑ.op\n  f‚ÇÅ‚ÇÉ := sq.f‚ÇÉ‚ÇÑ.op\n  f‚ÇÇ‚ÇÑ := sq.f‚ÇÅ‚ÇÇ.op\n  f‚ÇÉ‚ÇÑ := sq.f‚ÇÅ‚ÇÉ.op\n  fac := Quiver.Hom.unop_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.op_X‚ÇÅ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n‚ä¢ Eq sq.op.X‚ÇÅ { unop := sq.X‚ÇÑ }","decl":"/-- The map `Square C ‚Üí Square C·µí·µñ` which switches `X‚ÇÅ` and `X‚ÇÉ`, but\ndoes not move `X‚ÇÇ` and `X‚ÇÉ`. -/\n@[simps]\nprotected def op (sq : Square C) : Square C·µí·µñ where\n  f‚ÇÅ‚ÇÇ := sq.f‚ÇÇ‚ÇÑ.op\n  f‚ÇÅ‚ÇÉ := sq.f‚ÇÉ‚ÇÑ.op\n  f‚ÇÇ‚ÇÑ := sq.f‚ÇÅ‚ÇÇ.op\n  f‚ÇÉ‚ÇÑ := sq.f‚ÇÅ‚ÇÉ.op\n  fac := Quiver.Hom.unop_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.unop_X‚ÇÅ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square (Opposite C)\n‚ä¢ Eq sq.unop.X‚ÇÅ (Opposite.unop sq.X‚ÇÑ)","decl":"/-- The map `Square C·µí·µñ ‚Üí Square C` which switches `X‚ÇÅ` and `X‚ÇÉ`, but\ndoes not move `X‚ÇÇ` and `X‚ÇÉ`. -/\n@[simps]\nprotected def unop (sq : Square C·µí·µñ) : Square C where\n  f‚ÇÅ‚ÇÇ := sq.f‚ÇÇ‚ÇÑ.unop\n  f‚ÇÅ‚ÇÉ := sq.f‚ÇÉ‚ÇÑ.unop\n  f‚ÇÇ‚ÇÑ := sq.f‚ÇÅ‚ÇÇ.unop\n  f‚ÇÉ‚ÇÑ := sq.f‚ÇÅ‚ÇÉ.unop\n  fac := Quiver.Hom.op_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.unop_f‚ÇÅ‚ÇÉ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square (Opposite C)\n‚ä¢ Eq sq.unop.f‚ÇÅ‚ÇÉ sq.f‚ÇÉ‚ÇÑ.unop","decl":"/-- The map `Square C·µí·µñ ‚Üí Square C` which switches `X‚ÇÅ` and `X‚ÇÉ`, but\ndoes not move `X‚ÇÇ` and `X‚ÇÉ`. -/\n@[simps]\nprotected def unop (sq : Square C·µí·µñ) : Square C where\n  f‚ÇÅ‚ÇÇ := sq.f‚ÇÇ‚ÇÑ.unop\n  f‚ÇÅ‚ÇÉ := sq.f‚ÇÉ‚ÇÑ.unop\n  f‚ÇÇ‚ÇÑ := sq.f‚ÇÅ‚ÇÇ.unop\n  f‚ÇÉ‚ÇÑ := sq.f‚ÇÅ‚ÇÉ.unop\n  fac := Quiver.Hom.op_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.unop_X‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square (Opposite C)\n‚ä¢ Eq sq.unop.X‚ÇÑ (Opposite.unop sq.X‚ÇÅ)","decl":"/-- The map `Square C·µí·µñ ‚Üí Square C` which switches `X‚ÇÅ` and `X‚ÇÉ`, but\ndoes not move `X‚ÇÇ` and `X‚ÇÉ`. -/\n@[simps]\nprotected def unop (sq : Square C·µí·µñ) : Square C where\n  f‚ÇÅ‚ÇÇ := sq.f‚ÇÇ‚ÇÑ.unop\n  f‚ÇÅ‚ÇÉ := sq.f‚ÇÉ‚ÇÑ.unop\n  f‚ÇÇ‚ÇÑ := sq.f‚ÇÅ‚ÇÇ.unop\n  f‚ÇÉ‚ÇÑ := sq.f‚ÇÅ‚ÇÉ.unop\n  fac := Quiver.Hom.op_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.unop_X‚ÇÉ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square (Opposite C)\n‚ä¢ Eq sq.unop.X‚ÇÉ (Opposite.unop sq.X‚ÇÉ)","decl":"/-- The map `Square C·µí·µñ ‚Üí Square C` which switches `X‚ÇÅ` and `X‚ÇÉ`, but\ndoes not move `X‚ÇÇ` and `X‚ÇÉ`. -/\n@[simps]\nprotected def unop (sq : Square C·µí·µñ) : Square C where\n  f‚ÇÅ‚ÇÇ := sq.f‚ÇÇ‚ÇÑ.unop\n  f‚ÇÅ‚ÇÉ := sq.f‚ÇÉ‚ÇÑ.unop\n  f‚ÇÇ‚ÇÑ := sq.f‚ÇÅ‚ÇÇ.unop\n  f‚ÇÉ‚ÇÑ := sq.f‚ÇÅ‚ÇÉ.unop\n  fac := Quiver.Hom.op_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.unop_f‚ÇÉ‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square (Opposite C)\n‚ä¢ Eq sq.unop.f‚ÇÉ‚ÇÑ sq.f‚ÇÅ‚ÇÉ.unop","decl":"/-- The map `Square C·µí·µñ ‚Üí Square C` which switches `X‚ÇÅ` and `X‚ÇÉ`, but\ndoes not move `X‚ÇÇ` and `X‚ÇÉ`. -/\n@[simps]\nprotected def unop (sq : Square C·µí·µñ) : Square C where\n  f‚ÇÅ‚ÇÇ := sq.f‚ÇÇ‚ÇÑ.unop\n  f‚ÇÅ‚ÇÉ := sq.f‚ÇÉ‚ÇÑ.unop\n  f‚ÇÇ‚ÇÑ := sq.f‚ÇÅ‚ÇÇ.unop\n  f‚ÇÉ‚ÇÑ := sq.f‚ÇÅ‚ÇÉ.unop\n  fac := Quiver.Hom.op_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.unop_f‚ÇÇ‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square (Opposite C)\n‚ä¢ Eq sq.unop.f‚ÇÇ‚ÇÑ sq.f‚ÇÅ‚ÇÇ.unop","decl":"/-- The map `Square C·µí·µñ ‚Üí Square C` which switches `X‚ÇÅ` and `X‚ÇÉ`, but\ndoes not move `X‚ÇÇ` and `X‚ÇÉ`. -/\n@[simps]\nprotected def unop (sq : Square C·µí·µñ) : Square C where\n  f‚ÇÅ‚ÇÇ := sq.f‚ÇÇ‚ÇÑ.unop\n  f‚ÇÅ‚ÇÉ := sq.f‚ÇÉ‚ÇÑ.unop\n  f‚ÇÇ‚ÇÑ := sq.f‚ÇÅ‚ÇÇ.unop\n  f‚ÇÉ‚ÇÑ := sq.f‚ÇÅ‚ÇÉ.unop\n  fac := Quiver.Hom.op_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.unop_f‚ÇÅ‚ÇÇ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square (Opposite C)\n‚ä¢ Eq sq.unop.f‚ÇÅ‚ÇÇ sq.f‚ÇÇ‚ÇÑ.unop","decl":"/-- The map `Square C·µí·µñ ‚Üí Square C` which switches `X‚ÇÅ` and `X‚ÇÉ`, but\ndoes not move `X‚ÇÇ` and `X‚ÇÉ`. -/\n@[simps]\nprotected def unop (sq : Square C·µí·µñ) : Square C where\n  f‚ÇÅ‚ÇÇ := sq.f‚ÇÇ‚ÇÑ.unop\n  f‚ÇÅ‚ÇÉ := sq.f‚ÇÉ‚ÇÑ.unop\n  f‚ÇÇ‚ÇÑ := sq.f‚ÇÅ‚ÇÇ.unop\n  f‚ÇÉ‚ÇÑ := sq.f‚ÇÅ‚ÇÉ.unop\n  fac := Quiver.Hom.op_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.unop_X‚ÇÇ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square (Opposite C)\n‚ä¢ Eq sq.unop.X‚ÇÇ (Opposite.unop sq.X‚ÇÇ)","decl":"/-- The map `Square C·µí·µñ ‚Üí Square C` which switches `X‚ÇÅ` and `X‚ÇÉ`, but\ndoes not move `X‚ÇÇ` and `X‚ÇÉ`. -/\n@[simps]\nprotected def unop (sq : Square C·µí·µñ) : Square C where\n  f‚ÇÅ‚ÇÇ := sq.f‚ÇÇ‚ÇÑ.unop\n  f‚ÇÅ‚ÇÉ := sq.f‚ÇÉ‚ÇÑ.unop\n  f‚ÇÇ‚ÇÑ := sq.f‚ÇÅ‚ÇÇ.unop\n  f‚ÇÉ‚ÇÑ := sq.f‚ÇÅ‚ÇÉ.unop\n  fac := Quiver.Hom.op_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.opFunctor_map_œÑ‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : Opposite (CategoryTheory.Square C)\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.opFunctor.map œÜ).œÑ‚ÇÑ œÜ.unop.œÑ‚ÇÅ.op","decl":"/-- The functor `(Square C)·µí·µñ ‚•§ Square C·µí·µñ`. -/\n@[simps]\ndef opFunctor : (Square C)·µí·µñ ‚•§ Square C·µí·µñ where\n  obj sq := sq.unop.op\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.unop.œÑ‚ÇÑ.op\n      œÑ‚ÇÇ := œÜ.unop.œÑ‚ÇÇ.op\n      œÑ‚ÇÉ := œÜ.unop.œÑ‚ÇÉ.op\n      œÑ‚ÇÑ := œÜ.unop.œÑ‚ÇÅ.op\n      comm‚ÇÅ‚ÇÇ := Quiver.Hom.unop_inj (by simp)\n      comm‚ÇÅ‚ÇÉ := Quiver.Hom.unop_inj (by simp)\n      comm‚ÇÇ‚ÇÑ := Quiver.Hom.unop_inj (by simp)\n      comm‚ÇÉ‚ÇÑ := Quiver.Hom.unop_inj (by simp) }\n\n"}
{"name":"CategoryTheory.Square.opFunctor_obj","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsq : Opposite (CategoryTheory.Square C)\n‚ä¢ Eq (CategoryTheory.Square.opFunctor.obj sq) (Opposite.unop sq).op","decl":"/-- The functor `(Square C)·µí·µñ ‚•§ Square C·µí·µñ`. -/\n@[simps]\ndef opFunctor : (Square C)·µí·µñ ‚•§ Square C·µí·µñ where\n  obj sq := sq.unop.op\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.unop.œÑ‚ÇÑ.op\n      œÑ‚ÇÇ := œÜ.unop.œÑ‚ÇÇ.op\n      œÑ‚ÇÉ := œÜ.unop.œÑ‚ÇÉ.op\n      œÑ‚ÇÑ := œÜ.unop.œÑ‚ÇÅ.op\n      comm‚ÇÅ‚ÇÇ := Quiver.Hom.unop_inj (by simp)\n      comm‚ÇÅ‚ÇÉ := Quiver.Hom.unop_inj (by simp)\n      comm‚ÇÇ‚ÇÑ := Quiver.Hom.unop_inj (by simp)\n      comm‚ÇÉ‚ÇÑ := Quiver.Hom.unop_inj (by simp) }\n\n"}
{"name":"CategoryTheory.Square.opFunctor_map_œÑ‚ÇÇ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : Opposite (CategoryTheory.Square C)\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.opFunctor.map œÜ).œÑ‚ÇÇ œÜ.unop.œÑ‚ÇÇ.op","decl":"/-- The functor `(Square C)·µí·µñ ‚•§ Square C·µí·µñ`. -/\n@[simps]\ndef opFunctor : (Square C)·µí·µñ ‚•§ Square C·µí·µñ where\n  obj sq := sq.unop.op\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.unop.œÑ‚ÇÑ.op\n      œÑ‚ÇÇ := œÜ.unop.œÑ‚ÇÇ.op\n      œÑ‚ÇÉ := œÜ.unop.œÑ‚ÇÉ.op\n      œÑ‚ÇÑ := œÜ.unop.œÑ‚ÇÅ.op\n      comm‚ÇÅ‚ÇÇ := Quiver.Hom.unop_inj (by simp)\n      comm‚ÇÅ‚ÇÉ := Quiver.Hom.unop_inj (by simp)\n      comm‚ÇÇ‚ÇÑ := Quiver.Hom.unop_inj (by simp)\n      comm‚ÇÉ‚ÇÑ := Quiver.Hom.unop_inj (by simp) }\n\n"}
{"name":"CategoryTheory.Square.opFunctor_map_œÑ‚ÇÅ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : Opposite (CategoryTheory.Square C)\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.opFunctor.map œÜ).œÑ‚ÇÅ œÜ.unop.œÑ‚ÇÑ.op","decl":"/-- The functor `(Square C)·µí·µñ ‚•§ Square C·µí·µñ`. -/\n@[simps]\ndef opFunctor : (Square C)·µí·µñ ‚•§ Square C·µí·µñ where\n  obj sq := sq.unop.op\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.unop.œÑ‚ÇÑ.op\n      œÑ‚ÇÇ := œÜ.unop.œÑ‚ÇÇ.op\n      œÑ‚ÇÉ := œÜ.unop.œÑ‚ÇÉ.op\n      œÑ‚ÇÑ := œÜ.unop.œÑ‚ÇÅ.op\n      comm‚ÇÅ‚ÇÇ := Quiver.Hom.unop_inj (by simp)\n      comm‚ÇÅ‚ÇÉ := Quiver.Hom.unop_inj (by simp)\n      comm‚ÇÇ‚ÇÑ := Quiver.Hom.unop_inj (by simp)\n      comm‚ÇÉ‚ÇÑ := Quiver.Hom.unop_inj (by simp) }\n\n"}
{"name":"CategoryTheory.Square.opFunctor_map_œÑ‚ÇÉ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : Opposite (CategoryTheory.Square C)\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.opFunctor.map œÜ).œÑ‚ÇÉ œÜ.unop.œÑ‚ÇÉ.op","decl":"/-- The functor `(Square C)·µí·µñ ‚•§ Square C·µí·µñ`. -/\n@[simps]\ndef opFunctor : (Square C)·µí·µñ ‚•§ Square C·µí·µñ where\n  obj sq := sq.unop.op\n  map œÜ :=\n    { œÑ‚ÇÅ := œÜ.unop.œÑ‚ÇÑ.op\n      œÑ‚ÇÇ := œÜ.unop.œÑ‚ÇÇ.op\n      œÑ‚ÇÉ := œÜ.unop.œÑ‚ÇÉ.op\n      œÑ‚ÇÑ := œÜ.unop.œÑ‚ÇÅ.op\n      comm‚ÇÅ‚ÇÇ := Quiver.Hom.unop_inj (by simp)\n      comm‚ÇÅ‚ÇÉ := Quiver.Hom.unop_inj (by simp)\n      comm‚ÇÇ‚ÇÑ := Quiver.Hom.unop_inj (by simp)\n      comm‚ÇÉ‚ÇÑ := Quiver.Hom.unop_inj (by simp) }\n\n"}
{"name":"CategoryTheory.Square.map_f‚ÇÅ‚ÇÇ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nsq : CategoryTheory.Square C\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (sq.map F).f‚ÇÅ‚ÇÇ (F.map sq.f‚ÇÅ‚ÇÇ)","decl":"/-- The image of a commutative square by a functor. -/\n@[simps]\ndef map (sq : Square C) (F : C ‚•§ D) : Square D where\n  f‚ÇÅ‚ÇÇ := F.map sq.f‚ÇÅ‚ÇÇ\n  f‚ÇÅ‚ÇÉ := F.map sq.f‚ÇÅ‚ÇÉ\n  f‚ÇÇ‚ÇÑ := F.map sq.f‚ÇÇ‚ÇÑ\n  f‚ÇÉ‚ÇÑ := F.map sq.f‚ÇÉ‚ÇÑ\n  fac := by simpa using F.congr_map sq.fac\n\n"}
{"name":"CategoryTheory.Square.map_X‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nsq : CategoryTheory.Square C\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (sq.map F).X‚ÇÑ (F.obj sq.X‚ÇÑ)","decl":"/-- The image of a commutative square by a functor. -/\n@[simps]\ndef map (sq : Square C) (F : C ‚•§ D) : Square D where\n  f‚ÇÅ‚ÇÇ := F.map sq.f‚ÇÅ‚ÇÇ\n  f‚ÇÅ‚ÇÉ := F.map sq.f‚ÇÅ‚ÇÉ\n  f‚ÇÇ‚ÇÑ := F.map sq.f‚ÇÇ‚ÇÑ\n  f‚ÇÉ‚ÇÑ := F.map sq.f‚ÇÉ‚ÇÑ\n  fac := by simpa using F.congr_map sq.fac\n\n"}
{"name":"CategoryTheory.Square.map_f‚ÇÇ‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nsq : CategoryTheory.Square C\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (sq.map F).f‚ÇÇ‚ÇÑ (F.map sq.f‚ÇÇ‚ÇÑ)","decl":"/-- The image of a commutative square by a functor. -/\n@[simps]\ndef map (sq : Square C) (F : C ‚•§ D) : Square D where\n  f‚ÇÅ‚ÇÇ := F.map sq.f‚ÇÅ‚ÇÇ\n  f‚ÇÅ‚ÇÉ := F.map sq.f‚ÇÅ‚ÇÉ\n  f‚ÇÇ‚ÇÑ := F.map sq.f‚ÇÇ‚ÇÑ\n  f‚ÇÉ‚ÇÑ := F.map sq.f‚ÇÉ‚ÇÑ\n  fac := by simpa using F.congr_map sq.fac\n\n"}
{"name":"CategoryTheory.Square.map_X‚ÇÅ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nsq : CategoryTheory.Square C\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (sq.map F).X‚ÇÅ (F.obj sq.X‚ÇÅ)","decl":"/-- The image of a commutative square by a functor. -/\n@[simps]\ndef map (sq : Square C) (F : C ‚•§ D) : Square D where\n  f‚ÇÅ‚ÇÇ := F.map sq.f‚ÇÅ‚ÇÇ\n  f‚ÇÅ‚ÇÉ := F.map sq.f‚ÇÅ‚ÇÉ\n  f‚ÇÇ‚ÇÑ := F.map sq.f‚ÇÇ‚ÇÑ\n  f‚ÇÉ‚ÇÑ := F.map sq.f‚ÇÉ‚ÇÑ\n  fac := by simpa using F.congr_map sq.fac\n\n"}
{"name":"CategoryTheory.Square.map_f‚ÇÉ‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nsq : CategoryTheory.Square C\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (sq.map F).f‚ÇÉ‚ÇÑ (F.map sq.f‚ÇÉ‚ÇÑ)","decl":"/-- The image of a commutative square by a functor. -/\n@[simps]\ndef map (sq : Square C) (F : C ‚•§ D) : Square D where\n  f‚ÇÅ‚ÇÇ := F.map sq.f‚ÇÅ‚ÇÇ\n  f‚ÇÅ‚ÇÉ := F.map sq.f‚ÇÅ‚ÇÉ\n  f‚ÇÇ‚ÇÑ := F.map sq.f‚ÇÇ‚ÇÑ\n  f‚ÇÉ‚ÇÑ := F.map sq.f‚ÇÉ‚ÇÑ\n  fac := by simpa using F.congr_map sq.fac\n\n"}
{"name":"CategoryTheory.Square.map_X‚ÇÉ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nsq : CategoryTheory.Square C\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (sq.map F).X‚ÇÉ (F.obj sq.X‚ÇÉ)","decl":"/-- The image of a commutative square by a functor. -/\n@[simps]\ndef map (sq : Square C) (F : C ‚•§ D) : Square D where\n  f‚ÇÅ‚ÇÇ := F.map sq.f‚ÇÅ‚ÇÇ\n  f‚ÇÅ‚ÇÉ := F.map sq.f‚ÇÅ‚ÇÉ\n  f‚ÇÇ‚ÇÑ := F.map sq.f‚ÇÇ‚ÇÑ\n  f‚ÇÉ‚ÇÑ := F.map sq.f‚ÇÉ‚ÇÑ\n  fac := by simpa using F.congr_map sq.fac\n\n"}
{"name":"CategoryTheory.Square.map_f‚ÇÅ‚ÇÉ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nsq : CategoryTheory.Square C\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (sq.map F).f‚ÇÅ‚ÇÉ (F.map sq.f‚ÇÅ‚ÇÉ)","decl":"/-- The image of a commutative square by a functor. -/\n@[simps]\ndef map (sq : Square C) (F : C ‚•§ D) : Square D where\n  f‚ÇÅ‚ÇÇ := F.map sq.f‚ÇÅ‚ÇÇ\n  f‚ÇÅ‚ÇÉ := F.map sq.f‚ÇÅ‚ÇÉ\n  f‚ÇÇ‚ÇÑ := F.map sq.f‚ÇÇ‚ÇÑ\n  f‚ÇÉ‚ÇÑ := F.map sq.f‚ÇÉ‚ÇÑ\n  fac := by simpa using F.congr_map sq.fac\n\n"}
{"name":"CategoryTheory.Square.map_X‚ÇÇ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nsq : CategoryTheory.Square C\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (sq.map F).X‚ÇÇ (F.obj sq.X‚ÇÇ)","decl":"/-- The image of a commutative square by a functor. -/\n@[simps]\ndef map (sq : Square C) (F : C ‚•§ D) : Square D where\n  f‚ÇÅ‚ÇÇ := F.map sq.f‚ÇÅ‚ÇÇ\n  f‚ÇÅ‚ÇÉ := F.map sq.f‚ÇÅ‚ÇÉ\n  f‚ÇÇ‚ÇÑ := F.map sq.f‚ÇÇ‚ÇÑ\n  f‚ÇÉ‚ÇÑ := F.map sq.f‚ÇÉ‚ÇÑ\n  fac := by simpa using F.congr_map sq.fac\n\n"}
{"name":"CategoryTheory.Functor.mapSquare_map_œÑ‚ÇÇ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\nX‚úù Y‚úù : CategoryTheory.Square C\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (F.mapSquare.map œÜ).œÑ‚ÇÇ (F.map œÜ.œÑ‚ÇÇ)","decl":"/-- The functor `Square C ‚•§ Square D` induced by a functor `C ‚•§ D`. -/\n@[simps]\ndef mapSquare (F : C ‚•§ D) : Square C ‚•§ Square D where\n  obj sq := sq.map F\n  map œÜ :=\n    { œÑ‚ÇÅ := F.map œÜ.œÑ‚ÇÅ\n      œÑ‚ÇÇ := F.map œÜ.œÑ‚ÇÇ\n      œÑ‚ÇÉ := F.map œÜ.œÑ‚ÇÉ\n      œÑ‚ÇÑ := F.map œÜ.œÑ‚ÇÑ\n      comm‚ÇÅ‚ÇÇ := by simpa only [Functor.map_comp] using F.congr_map œÜ.comm‚ÇÅ‚ÇÇ\n      comm‚ÇÅ‚ÇÉ := by simpa only [Functor.map_comp] using F.congr_map œÜ.comm‚ÇÅ‚ÇÉ\n      comm‚ÇÇ‚ÇÑ := by simpa only [Functor.map_comp] using F.congr_map œÜ.comm‚ÇÇ‚ÇÑ\n      comm‚ÇÉ‚ÇÑ := by simpa only [Functor.map_comp] using F.congr_map œÜ.comm‚ÇÉ‚ÇÑ }\n\n"}
{"name":"CategoryTheory.Functor.mapSquare_map_œÑ‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\nX‚úù Y‚úù : CategoryTheory.Square C\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (F.mapSquare.map œÜ).œÑ‚ÇÑ (F.map œÜ.œÑ‚ÇÑ)","decl":"/-- The functor `Square C ‚•§ Square D` induced by a functor `C ‚•§ D`. -/\n@[simps]\ndef mapSquare (F : C ‚•§ D) : Square C ‚•§ Square D where\n  obj sq := sq.map F\n  map œÜ :=\n    { œÑ‚ÇÅ := F.map œÜ.œÑ‚ÇÅ\n      œÑ‚ÇÇ := F.map œÜ.œÑ‚ÇÇ\n      œÑ‚ÇÉ := F.map œÜ.œÑ‚ÇÉ\n      œÑ‚ÇÑ := F.map œÜ.œÑ‚ÇÑ\n      comm‚ÇÅ‚ÇÇ := by simpa only [Functor.map_comp] using F.congr_map œÜ.comm‚ÇÅ‚ÇÇ\n      comm‚ÇÅ‚ÇÉ := by simpa only [Functor.map_comp] using F.congr_map œÜ.comm‚ÇÅ‚ÇÉ\n      comm‚ÇÇ‚ÇÑ := by simpa only [Functor.map_comp] using F.congr_map œÜ.comm‚ÇÇ‚ÇÑ\n      comm‚ÇÉ‚ÇÑ := by simpa only [Functor.map_comp] using F.congr_map œÜ.comm‚ÇÉ‚ÇÑ }\n\n"}
{"name":"CategoryTheory.Functor.mapSquare_obj","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\nsq : CategoryTheory.Square C\n‚ä¢ Eq (F.mapSquare.obj sq) (sq.map F)","decl":"/-- The functor `Square C ‚•§ Square D` induced by a functor `C ‚•§ D`. -/\n@[simps]\ndef mapSquare (F : C ‚•§ D) : Square C ‚•§ Square D where\n  obj sq := sq.map F\n  map œÜ :=\n    { œÑ‚ÇÅ := F.map œÜ.œÑ‚ÇÅ\n      œÑ‚ÇÇ := F.map œÜ.œÑ‚ÇÇ\n      œÑ‚ÇÉ := F.map œÜ.œÑ‚ÇÉ\n      œÑ‚ÇÑ := F.map œÜ.œÑ‚ÇÑ\n      comm‚ÇÅ‚ÇÇ := by simpa only [Functor.map_comp] using F.congr_map œÜ.comm‚ÇÅ‚ÇÇ\n      comm‚ÇÅ‚ÇÉ := by simpa only [Functor.map_comp] using F.congr_map œÜ.comm‚ÇÅ‚ÇÉ\n      comm‚ÇÇ‚ÇÑ := by simpa only [Functor.map_comp] using F.congr_map œÜ.comm‚ÇÇ‚ÇÑ\n      comm‚ÇÉ‚ÇÑ := by simpa only [Functor.map_comp] using F.congr_map œÜ.comm‚ÇÉ‚ÇÑ }\n\n"}
{"name":"CategoryTheory.Functor.mapSquare_map_œÑ‚ÇÉ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\nX‚úù Y‚úù : CategoryTheory.Square C\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (F.mapSquare.map œÜ).œÑ‚ÇÉ (F.map œÜ.œÑ‚ÇÉ)","decl":"/-- The functor `Square C ‚•§ Square D` induced by a functor `C ‚•§ D`. -/\n@[simps]\ndef mapSquare (F : C ‚•§ D) : Square C ‚•§ Square D where\n  obj sq := sq.map F\n  map œÜ :=\n    { œÑ‚ÇÅ := F.map œÜ.œÑ‚ÇÅ\n      œÑ‚ÇÇ := F.map œÜ.œÑ‚ÇÇ\n      œÑ‚ÇÉ := F.map œÜ.œÑ‚ÇÉ\n      œÑ‚ÇÑ := F.map œÜ.œÑ‚ÇÑ\n      comm‚ÇÅ‚ÇÇ := by simpa only [Functor.map_comp] using F.congr_map œÜ.comm‚ÇÅ‚ÇÇ\n      comm‚ÇÅ‚ÇÉ := by simpa only [Functor.map_comp] using F.congr_map œÜ.comm‚ÇÅ‚ÇÉ\n      comm‚ÇÇ‚ÇÑ := by simpa only [Functor.map_comp] using F.congr_map œÜ.comm‚ÇÇ‚ÇÑ\n      comm‚ÇÉ‚ÇÑ := by simpa only [Functor.map_comp] using F.congr_map œÜ.comm‚ÇÉ‚ÇÑ }\n\n"}
{"name":"CategoryTheory.Functor.mapSquare_map_œÑ‚ÇÅ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\nX‚úù Y‚úù : CategoryTheory.Square C\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (F.mapSquare.map œÜ).œÑ‚ÇÅ (F.map œÜ.œÑ‚ÇÅ)","decl":"/-- The functor `Square C ‚•§ Square D` induced by a functor `C ‚•§ D`. -/\n@[simps]\ndef mapSquare (F : C ‚•§ D) : Square C ‚•§ Square D where\n  obj sq := sq.map F\n  map œÜ :=\n    { œÑ‚ÇÅ := F.map œÜ.œÑ‚ÇÅ\n      œÑ‚ÇÇ := F.map œÜ.œÑ‚ÇÇ\n      œÑ‚ÇÉ := F.map œÜ.œÑ‚ÇÉ\n      œÑ‚ÇÑ := F.map œÜ.œÑ‚ÇÑ\n      comm‚ÇÅ‚ÇÇ := by simpa only [Functor.map_comp] using F.congr_map œÜ.comm‚ÇÅ‚ÇÇ\n      comm‚ÇÅ‚ÇÉ := by simpa only [Functor.map_comp] using F.congr_map œÜ.comm‚ÇÅ‚ÇÉ\n      comm‚ÇÇ‚ÇÑ := by simpa only [Functor.map_comp] using F.congr_map œÜ.comm‚ÇÇ‚ÇÑ\n      comm‚ÇÉ‚ÇÑ := by simpa only [Functor.map_comp] using F.congr_map œÜ.comm‚ÇÉ‚ÇÑ }\n\n"}
{"name":"CategoryTheory.NatTrans.mapSquare_app_œÑ‚ÇÑ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nœÑ : Quiver.Hom F G\nsq : CategoryTheory.Square C\n‚ä¢ Eq ((CategoryTheory.NatTrans.mapSquare œÑ).app sq).œÑ‚ÇÑ (œÑ.app sq.X‚ÇÑ)","decl":"/-- The natural transformation `F.mapSquare ‚ü∂ G.mapSquare` induces\nby a natural transformation `F ‚ü∂ G`. -/\n@[simps]\ndef NatTrans.mapSquare {F G : C ‚•§ D} (œÑ : F ‚ü∂ G) :\n    F.mapSquare ‚ü∂ G.mapSquare where\n  app sq :=\n    { œÑ‚ÇÅ := œÑ.app _\n      œÑ‚ÇÇ := œÑ.app _\n      œÑ‚ÇÉ := œÑ.app _\n      œÑ‚ÇÑ := œÑ.app _ }\n\n"}
{"name":"CategoryTheory.NatTrans.mapSquare_app_œÑ‚ÇÇ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nœÑ : Quiver.Hom F G\nsq : CategoryTheory.Square C\n‚ä¢ Eq ((CategoryTheory.NatTrans.mapSquare œÑ).app sq).œÑ‚ÇÇ (œÑ.app sq.X‚ÇÇ)","decl":"/-- The natural transformation `F.mapSquare ‚ü∂ G.mapSquare` induces\nby a natural transformation `F ‚ü∂ G`. -/\n@[simps]\ndef NatTrans.mapSquare {F G : C ‚•§ D} (œÑ : F ‚ü∂ G) :\n    F.mapSquare ‚ü∂ G.mapSquare where\n  app sq :=\n    { œÑ‚ÇÅ := œÑ.app _\n      œÑ‚ÇÇ := œÑ.app _\n      œÑ‚ÇÉ := œÑ.app _\n      œÑ‚ÇÑ := œÑ.app _ }\n\n"}
{"name":"CategoryTheory.NatTrans.mapSquare_app_œÑ‚ÇÉ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nœÑ : Quiver.Hom F G\nsq : CategoryTheory.Square C\n‚ä¢ Eq ((CategoryTheory.NatTrans.mapSquare œÑ).app sq).œÑ‚ÇÉ (œÑ.app sq.X‚ÇÉ)","decl":"/-- The natural transformation `F.mapSquare ‚ü∂ G.mapSquare` induces\nby a natural transformation `F ‚ü∂ G`. -/\n@[simps]\ndef NatTrans.mapSquare {F G : C ‚•§ D} (œÑ : F ‚ü∂ G) :\n    F.mapSquare ‚ü∂ G.mapSquare where\n  app sq :=\n    { œÑ‚ÇÅ := œÑ.app _\n      œÑ‚ÇÇ := œÑ.app _\n      œÑ‚ÇÉ := œÑ.app _\n      œÑ‚ÇÑ := œÑ.app _ }\n\n"}
{"name":"CategoryTheory.NatTrans.mapSquare_app_œÑ‚ÇÅ","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nœÑ : Quiver.Hom F G\nsq : CategoryTheory.Square C\n‚ä¢ Eq ((CategoryTheory.NatTrans.mapSquare œÑ).app sq).œÑ‚ÇÅ (œÑ.app sq.X‚ÇÅ)","decl":"/-- The natural transformation `F.mapSquare ‚ü∂ G.mapSquare` induces\nby a natural transformation `F ‚ü∂ G`. -/\n@[simps]\ndef NatTrans.mapSquare {F G : C ‚•§ D} (œÑ : F ‚ü∂ G) :\n    F.mapSquare ‚ü∂ G.mapSquare where\n  app sq :=\n    { œÑ‚ÇÅ := œÑ.app _\n      œÑ‚ÇÇ := œÑ.app _\n      œÑ‚ÇÉ := œÑ.app _\n      œÑ‚ÇÑ := œÑ.app _ }\n\n"}
{"name":"CategoryTheory.Square.mapFunctor_map","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nX‚úù Y‚úù : CategoryTheory.Functor C D\nœÑ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Square.mapFunctor.map œÑ) (CategoryTheory.NatTrans.mapSquare œÑ)","decl":"/-- The functor `(C ‚•§ D) ‚•§ Square C ‚•§ Square D`. -/\n@[simps]\ndef Square.mapFunctor : (C ‚•§ D) ‚•§ Square C ‚•§ Square D where\n  obj F := F.mapSquare\n  map œÑ := NatTrans.mapSquare œÑ\n\n"}
{"name":"CategoryTheory.Square.mapFunctor_obj","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (CategoryTheory.Square.mapFunctor.obj F) F.mapSquare","decl":"/-- The functor `(C ‚•§ D) ‚•§ Square C ‚•§ Square D`. -/\n@[simps]\ndef Square.mapFunctor : (C ‚•§ D) ‚•§ Square C ‚•§ Square D where\n  obj F := F.mapSquare\n  map œÑ := NatTrans.mapSquare œÑ\n\n"}
