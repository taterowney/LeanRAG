{"name":"CategoryTheory.Square.fac","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.f₁₂ self.f₂₄) (CategoryTheory.CategoryStruct.comp self.f₁₃ self.f₃₄)","decl":"/-- The category of commutative squares in a category. -/\nstructure Square where\n  /-- the top-left object -/\n  {X₁ : C}\n  /-- the top-right object -/\n  {X₂ : C}\n  /-- the bottom-left object -/\n  {X₃ : C}\n  /-- the bottom-right object -/\n  {X₄ : C}\n  /-- the top morphism -/\n  f₁₂ : X₁ ⟶ X₂\n  /-- the left morphism -/\n  f₁₃ : X₁ ⟶ X₃\n  /-- the right morphism -/\n  f₂₄ : X₂ ⟶ X₄\n  /-- the bottom morphism -/\n  f₃₄ : X₃ ⟶ X₄\n  fac : f₁₂ ≫ f₂₄ = f₁₃ ≫ f₃₄\n\n"}
{"name":"CategoryTheory.Square.mk.injEq","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX₁✝ X₂✝ X₃✝ X₄✝ : C\nf₁₂✝ : Quiver.Hom X₁✝ X₂✝\nf₁₃✝ : Quiver.Hom X₁✝ X₃✝\nf₂₄✝ : Quiver.Hom X₂✝ X₄✝\nf₃₄✝ : Quiver.Hom X₃✝ X₄✝\nfac✝ : Eq (CategoryTheory.CategoryStruct.comp f₁₂✝ f₂₄✝) (CategoryTheory.CategoryStruct.comp f₁₃✝ f₃₄✝)\nX₁ X₂ X₃ X₄ : C\nf₁₂ : Quiver.Hom X₁ X₂\nf₁₃ : Quiver.Hom X₁ X₃\nf₂₄ : Quiver.Hom X₂ X₄\nf₃₄ : Quiver.Hom X₃ X₄\nfac : Eq (CategoryTheory.CategoryStruct.comp f₁₂ f₂₄) (CategoryTheory.CategoryStruct.comp f₁₃ f₃₄)\n⊢ Eq (Eq (CategoryTheory.Square.mk f₁₂✝ f₁₃✝ f₂₄✝ f₃₄✝ fac✝) (CategoryTheory.Square.mk f₁₂ f₁₃ f₂₄ f₃₄ fac)) (And (Eq X₁✝ X₁) (And (Eq X₂✝ X₂) (And (Eq X₃✝ X₃) (And (Eq X₄✝ X₄) (And (HEq f₁₂✝ f₁₂) (And (HEq f₁₃✝ f₁₃) (And (HEq f₂₄✝ f₂₄) (HEq f₃₄✝ f₃₄))))))))","decl":"/-- The category of commutative squares in a category. -/\nstructure Square where\n  /-- the top-left object -/\n  {X₁ : C}\n  /-- the top-right object -/\n  {X₂ : C}\n  /-- the bottom-left object -/\n  {X₃ : C}\n  /-- the bottom-right object -/\n  {X₄ : C}\n  /-- the top morphism -/\n  f₁₂ : X₁ ⟶ X₂\n  /-- the left morphism -/\n  f₁₃ : X₁ ⟶ X₃\n  /-- the right morphism -/\n  f₂₄ : X₂ ⟶ X₄\n  /-- the bottom morphism -/\n  f₃₄ : X₃ ⟶ X₄\n  fac : f₁₂ ≫ f₂₄ = f₁₃ ≫ f₃₄\n\n"}
{"name":"CategoryTheory.Square.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : SizeOf C\nX₁ X₂ X₃ X₄ : C\nf₁₂ : Quiver.Hom X₁ X₂\nf₁₃ : Quiver.Hom X₁ X₃\nf₂₄ : Quiver.Hom X₂ X₄\nf₃₄ : Quiver.Hom X₃ X₄\nfac : Eq (CategoryTheory.CategoryStruct.comp f₁₂ f₂₄) (CategoryTheory.CategoryStruct.comp f₁₃ f₃₄)\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.Square.mk f₁₂ f₁₃ f₂₄ f₃₄ fac)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf X₁)) (SizeOf.sizeOf X₂)) (SizeOf.sizeOf X₃)) (SizeOf.sizeOf X₄)) (SizeOf.sizeOf f₁₂)) (SizeOf.sizeOf f₁₃)) (SizeOf.sizeOf f₂₄)) (SizeOf.sizeOf f₃₄)) (SizeOf.sizeOf fac))","decl":"/-- The category of commutative squares in a category. -/\nstructure Square where\n  /-- the top-left object -/\n  {X₁ : C}\n  /-- the top-right object -/\n  {X₂ : C}\n  /-- the bottom-left object -/\n  {X₃ : C}\n  /-- the bottom-right object -/\n  {X₄ : C}\n  /-- the top morphism -/\n  f₁₂ : X₁ ⟶ X₂\n  /-- the left morphism -/\n  f₁₃ : X₁ ⟶ X₃\n  /-- the right morphism -/\n  f₂₄ : X₂ ⟶ X₄\n  /-- the bottom morphism -/\n  f₃₄ : X₃ ⟶ X₄\n  fac : f₁₂ ≫ f₂₄ = f₁₃ ≫ f₃₄\n\n"}
{"name":"CategoryTheory.Square.mk.inj","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX₁✝ X₂✝ X₃✝ X₄✝ : C\nf₁₂✝ : Quiver.Hom X₁✝ X₂✝\nf₁₃✝ : Quiver.Hom X₁✝ X₃✝\nf₂₄✝ : Quiver.Hom X₂✝ X₄✝\nf₃₄✝ : Quiver.Hom X₃✝ X₄✝\nfac✝ : Eq (CategoryTheory.CategoryStruct.comp f₁₂✝ f₂₄✝) (CategoryTheory.CategoryStruct.comp f₁₃✝ f₃₄✝)\nX₁ X₂ X₃ X₄ : C\nf₁₂ : Quiver.Hom X₁ X₂\nf₁₃ : Quiver.Hom X₁ X₃\nf₂₄ : Quiver.Hom X₂ X₄\nf₃₄ : Quiver.Hom X₃ X₄\nfac : Eq (CategoryTheory.CategoryStruct.comp f₁₂ f₂₄) (CategoryTheory.CategoryStruct.comp f₁₃ f₃₄)\nx✝ : Eq (CategoryTheory.Square.mk f₁₂✝ f₁₃✝ f₂₄✝ f₃₄✝ fac✝) (CategoryTheory.Square.mk f₁₂ f₁₃ f₂₄ f₃₄ fac)\n⊢ And (Eq X₁✝ X₁) (And (Eq X₂✝ X₂) (And (Eq X₃✝ X₃) (And (Eq X₄✝ X₄) (And (HEq f₁₂✝ f₁₂) (And (HEq f₁₃✝ f₁₃) (And (HEq f₂₄✝ f₂₄) (HEq f₃₄✝ f₃₄)))))))","decl":"/-- The category of commutative squares in a category. -/\nstructure Square where\n  /-- the top-left object -/\n  {X₁ : C}\n  /-- the top-right object -/\n  {X₂ : C}\n  /-- the bottom-left object -/\n  {X₃ : C}\n  /-- the bottom-right object -/\n  {X₄ : C}\n  /-- the top morphism -/\n  f₁₂ : X₁ ⟶ X₂\n  /-- the left morphism -/\n  f₁₃ : X₁ ⟶ X₃\n  /-- the right morphism -/\n  f₂₄ : X₂ ⟶ X₄\n  /-- the bottom morphism -/\n  f₃₄ : X₃ ⟶ X₄\n  fac : f₁₂ ≫ f₂₄ = f₁₃ ≫ f₃₄\n\n"}
{"name":"CategoryTheory.Square.commSq","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ CategoryTheory.CommSq sq.f₁₂ sq.f₁₃ sq.f₂₄ sq.f₃₄","decl":"lemma commSq (sq : Square C) : CommSq sq.f₁₂ sq.f₁₃ sq.f₂₄ sq.f₃₄ where\n  w := sq.fac\n\n"}
{"name":"CategoryTheory.Square.Hom.ext_iff","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq₁ sq₂ : CategoryTheory.Square C\nx y : sq₁.Hom sq₂\n⊢ Iff (Eq x y) (And (Eq x.τ₁ y.τ₁) (And (Eq x.τ₂ y.τ₂) (And (Eq x.τ₃ y.τ₃) (Eq x.τ₄ y.τ₄))))","decl":"/-- A morphism between two commutative squares consists of 4 morphisms\nwhich extend these two squares into a commuting cube. -/\n@[ext]\nstructure Hom (sq₁ sq₂ : Square C) where\n  /-- the top-left morphism -/\n  τ₁ : sq₁.X₁ ⟶ sq₂.X₁\n  /-- the top-right morphism -/\n  τ₂ : sq₁.X₂ ⟶ sq₂.X₂\n  /-- the bottom-left morphism -/\n  τ₃ : sq₁.X₃ ⟶ sq₂.X₃\n  /-- the bottom-right morphism -/\n  τ₄ : sq₁.X₄ ⟶ sq₂.X₄\n  comm₁₂ : sq₁.f₁₂ ≫ τ₂ = τ₁ ≫ sq₂.f₁₂ := by aesop_cat\n  comm₁₃ : sq₁.f₁₃ ≫ τ₃ = τ₁ ≫ sq₂.f₁₃ := by aesop_cat\n  comm₂₄ : sq₁.f₂₄ ≫ τ₄ = τ₂ ≫ sq₂.f₂₄ := by aesop_cat\n  comm₃₄ : sq₁.f₃₄ ≫ τ₄ = τ₃ ≫ sq₂.f₃₄ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Square.Hom.comm₃₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq₁ sq₂ : CategoryTheory.Square C\nself : sq₁.Hom sq₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp sq₁.f₃₄ self.τ₄) (CategoryTheory.CategoryStruct.comp self.τ₃ sq₂.f₃₄)","decl":"/-- A morphism between two commutative squares consists of 4 morphisms\nwhich extend these two squares into a commuting cube. -/\n@[ext]\nstructure Hom (sq₁ sq₂ : Square C) where\n  /-- the top-left morphism -/\n  τ₁ : sq₁.X₁ ⟶ sq₂.X₁\n  /-- the top-right morphism -/\n  τ₂ : sq₁.X₂ ⟶ sq₂.X₂\n  /-- the bottom-left morphism -/\n  τ₃ : sq₁.X₃ ⟶ sq₂.X₃\n  /-- the bottom-right morphism -/\n  τ₄ : sq₁.X₄ ⟶ sq₂.X₄\n  comm₁₂ : sq₁.f₁₂ ≫ τ₂ = τ₁ ≫ sq₂.f₁₂ := by aesop_cat\n  comm₁₃ : sq₁.f₁₃ ≫ τ₃ = τ₁ ≫ sq₂.f₁₃ := by aesop_cat\n  comm₂₄ : sq₁.f₂₄ ≫ τ₄ = τ₂ ≫ sq₂.f₂₄ := by aesop_cat\n  comm₃₄ : sq₁.f₃₄ ≫ τ₄ = τ₃ ≫ sq₂.f₃₄ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Square.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nsq₁ sq₂ : CategoryTheory.Square C\ninst✝ : SizeOf C\nτ₁ : Quiver.Hom sq₁.X₁ sq₂.X₁\nτ₂ : Quiver.Hom sq₁.X₂ sq₂.X₂\nτ₃ : Quiver.Hom sq₁.X₃ sq₂.X₃\nτ₄ : Quiver.Hom sq₁.X₄ sq₂.X₄\ncomm₁₂ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq₁.f₁₂ τ₂) (CategoryTheory.CategoryStruct.comp τ₁ sq₂.f₁₂)) _auto✝\ncomm₁₃ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq₁.f₁₃ τ₃) (CategoryTheory.CategoryStruct.comp τ₁ sq₂.f₁₃)) _auto✝\ncomm₂₄ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq₁.f₂₄ τ₄) (CategoryTheory.CategoryStruct.comp τ₂ sq₂.f₂₄)) _auto✝\ncomm₃₄ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq₁.f₃₄ τ₄) (CategoryTheory.CategoryStruct.comp τ₃ sq₂.f₃₄)) _auto✝\n⊢ Eq (SizeOf.sizeOf { τ₁ := τ₁, τ₂ := τ₂, τ₃ := τ₃, τ₄ := τ₄, comm₁₂ := comm₁₂, comm₁₃ := comm₁₃, comm₂₄ := comm₂₄, comm₃₄ := comm₃₄ }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf τ₁)) (SizeOf.sizeOf τ₂)) (SizeOf.sizeOf τ₃)) (SizeOf.sizeOf τ₄)) (SizeOf.sizeOf comm₁₂)) (SizeOf.sizeOf comm₁₃)) (SizeOf.sizeOf comm₂₄)) (SizeOf.sizeOf comm₃₄))","decl":"/-- A morphism between two commutative squares consists of 4 morphisms\nwhich extend these two squares into a commuting cube. -/\n@[ext]\nstructure Hom (sq₁ sq₂ : Square C) where\n  /-- the top-left morphism -/\n  τ₁ : sq₁.X₁ ⟶ sq₂.X₁\n  /-- the top-right morphism -/\n  τ₂ : sq₁.X₂ ⟶ sq₂.X₂\n  /-- the bottom-left morphism -/\n  τ₃ : sq₁.X₃ ⟶ sq₂.X₃\n  /-- the bottom-right morphism -/\n  τ₄ : sq₁.X₄ ⟶ sq₂.X₄\n  comm₁₂ : sq₁.f₁₂ ≫ τ₂ = τ₁ ≫ sq₂.f₁₂ := by aesop_cat\n  comm₁₃ : sq₁.f₁₃ ≫ τ₃ = τ₁ ≫ sq₂.f₁₃ := by aesop_cat\n  comm₂₄ : sq₁.f₂₄ ≫ τ₄ = τ₂ ≫ sq₂.f₂₄ := by aesop_cat\n  comm₃₄ : sq₁.f₃₄ ≫ τ₄ = τ₃ ≫ sq₂.f₃₄ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Square.Hom.comm₁₃","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq₁ sq₂ : CategoryTheory.Square C\nself : sq₁.Hom sq₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp sq₁.f₁₃ self.τ₃) (CategoryTheory.CategoryStruct.comp self.τ₁ sq₂.f₁₃)","decl":"/-- A morphism between two commutative squares consists of 4 morphisms\nwhich extend these two squares into a commuting cube. -/\n@[ext]\nstructure Hom (sq₁ sq₂ : Square C) where\n  /-- the top-left morphism -/\n  τ₁ : sq₁.X₁ ⟶ sq₂.X₁\n  /-- the top-right morphism -/\n  τ₂ : sq₁.X₂ ⟶ sq₂.X₂\n  /-- the bottom-left morphism -/\n  τ₃ : sq₁.X₃ ⟶ sq₂.X₃\n  /-- the bottom-right morphism -/\n  τ₄ : sq₁.X₄ ⟶ sq₂.X₄\n  comm₁₂ : sq₁.f₁₂ ≫ τ₂ = τ₁ ≫ sq₂.f₁₂ := by aesop_cat\n  comm₁₃ : sq₁.f₁₃ ≫ τ₃ = τ₁ ≫ sq₂.f₁₃ := by aesop_cat\n  comm₂₄ : sq₁.f₂₄ ≫ τ₄ = τ₂ ≫ sq₂.f₂₄ := by aesop_cat\n  comm₃₄ : sq₁.f₃₄ ≫ τ₄ = τ₃ ≫ sq₂.f₃₄ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Square.Hom.comm₂₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq₁ sq₂ : CategoryTheory.Square C\nself : sq₁.Hom sq₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp sq₁.f₂₄ self.τ₄) (CategoryTheory.CategoryStruct.comp self.τ₂ sq₂.f₂₄)","decl":"/-- A morphism between two commutative squares consists of 4 morphisms\nwhich extend these two squares into a commuting cube. -/\n@[ext]\nstructure Hom (sq₁ sq₂ : Square C) where\n  /-- the top-left morphism -/\n  τ₁ : sq₁.X₁ ⟶ sq₂.X₁\n  /-- the top-right morphism -/\n  τ₂ : sq₁.X₂ ⟶ sq₂.X₂\n  /-- the bottom-left morphism -/\n  τ₃ : sq₁.X₃ ⟶ sq₂.X₃\n  /-- the bottom-right morphism -/\n  τ₄ : sq₁.X₄ ⟶ sq₂.X₄\n  comm₁₂ : sq₁.f₁₂ ≫ τ₂ = τ₁ ≫ sq₂.f₁₂ := by aesop_cat\n  comm₁₃ : sq₁.f₁₃ ≫ τ₃ = τ₁ ≫ sq₂.f₁₃ := by aesop_cat\n  comm₂₄ : sq₁.f₂₄ ≫ τ₄ = τ₂ ≫ sq₂.f₂₄ := by aesop_cat\n  comm₃₄ : sq₁.f₃₄ ≫ τ₄ = τ₃ ≫ sq₂.f₃₄ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Square.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq₁ sq₂ : CategoryTheory.Square C\nτ₁✝ : Quiver.Hom sq₁.X₁ sq₂.X₁\nτ₂✝ : Quiver.Hom sq₁.X₂ sq₂.X₂\nτ₃✝ : Quiver.Hom sq₁.X₃ sq₂.X₃\nτ₄✝ : Quiver.Hom sq₁.X₄ sq₂.X₄\ncomm₁₂✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq₁.f₁₂ τ₂✝) (CategoryTheory.CategoryStruct.comp τ₁✝ sq₂.f₁₂)) _auto✝\ncomm₁₃✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq₁.f₁₃ τ₃✝) (CategoryTheory.CategoryStruct.comp τ₁✝ sq₂.f₁₃)) _auto✝\ncomm₂₄✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq₁.f₂₄ τ₄✝) (CategoryTheory.CategoryStruct.comp τ₂✝ sq₂.f₂₄)) _auto✝\ncomm₃₄✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq₁.f₃₄ τ₄✝) (CategoryTheory.CategoryStruct.comp τ₃✝ sq₂.f₃₄)) _auto✝\nτ₁ : Quiver.Hom sq₁.X₁ sq₂.X₁\nτ₂ : Quiver.Hom sq₁.X₂ sq₂.X₂\nτ₃ : Quiver.Hom sq₁.X₃ sq₂.X₃\nτ₄ : Quiver.Hom sq₁.X₄ sq₂.X₄\ncomm₁₂ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq₁.f₁₂ τ₂) (CategoryTheory.CategoryStruct.comp τ₁ sq₂.f₁₂)) _auto✝\ncomm₁₃ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq₁.f₁₃ τ₃) (CategoryTheory.CategoryStruct.comp τ₁ sq₂.f₁₃)) _auto✝\ncomm₂₄ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq₁.f₂₄ τ₄) (CategoryTheory.CategoryStruct.comp τ₂ sq₂.f₂₄)) _auto✝\ncomm₃₄ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq₁.f₃₄ τ₄) (CategoryTheory.CategoryStruct.comp τ₃ sq₂.f₃₄)) _auto✝\n⊢ Eq (Eq { τ₁ := τ₁✝, τ₂ := τ₂✝, τ₃ := τ₃✝, τ₄ := τ₄✝, comm₁₂ := comm₁₂✝, comm₁₃ := comm₁₃✝, comm₂₄ := comm₂₄✝, comm₃₄ := comm₃₄✝ } { τ₁ := τ₁, τ₂ := τ₂, τ₃ := τ₃, τ₄ := τ₄, comm₁₂ := comm₁₂, comm₁₃ := comm₁₃, comm₂₄ := comm₂₄, comm₃₄ := comm₃₄ }) (And (Eq τ₁✝ τ₁) (And (Eq τ₂✝ τ₂) (And (Eq τ₃✝ τ₃) (Eq τ₄✝ τ₄))))","decl":"/-- A morphism between two commutative squares consists of 4 morphisms\nwhich extend these two squares into a commuting cube. -/\n@[ext]\nstructure Hom (sq₁ sq₂ : Square C) where\n  /-- the top-left morphism -/\n  τ₁ : sq₁.X₁ ⟶ sq₂.X₁\n  /-- the top-right morphism -/\n  τ₂ : sq₁.X₂ ⟶ sq₂.X₂\n  /-- the bottom-left morphism -/\n  τ₃ : sq₁.X₃ ⟶ sq₂.X₃\n  /-- the bottom-right morphism -/\n  τ₄ : sq₁.X₄ ⟶ sq₂.X₄\n  comm₁₂ : sq₁.f₁₂ ≫ τ₂ = τ₁ ≫ sq₂.f₁₂ := by aesop_cat\n  comm₁₃ : sq₁.f₁₃ ≫ τ₃ = τ₁ ≫ sq₂.f₁₃ := by aesop_cat\n  comm₂₄ : sq₁.f₂₄ ≫ τ₄ = τ₂ ≫ sq₂.f₂₄ := by aesop_cat\n  comm₃₄ : sq₁.f₃₄ ≫ τ₄ = τ₃ ≫ sq₂.f₃₄ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Square.Hom.comm₁₂","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq₁ sq₂ : CategoryTheory.Square C\nself : sq₁.Hom sq₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp sq₁.f₁₂ self.τ₂) (CategoryTheory.CategoryStruct.comp self.τ₁ sq₂.f₁₂)","decl":"/-- A morphism between two commutative squares consists of 4 morphisms\nwhich extend these two squares into a commuting cube. -/\n@[ext]\nstructure Hom (sq₁ sq₂ : Square C) where\n  /-- the top-left morphism -/\n  τ₁ : sq₁.X₁ ⟶ sq₂.X₁\n  /-- the top-right morphism -/\n  τ₂ : sq₁.X₂ ⟶ sq₂.X₂\n  /-- the bottom-left morphism -/\n  τ₃ : sq₁.X₃ ⟶ sq₂.X₃\n  /-- the bottom-right morphism -/\n  τ₄ : sq₁.X₄ ⟶ sq₂.X₄\n  comm₁₂ : sq₁.f₁₂ ≫ τ₂ = τ₁ ≫ sq₂.f₁₂ := by aesop_cat\n  comm₁₃ : sq₁.f₁₃ ≫ τ₃ = τ₁ ≫ sq₂.f₁₃ := by aesop_cat\n  comm₂₄ : sq₁.f₂₄ ≫ τ₄ = τ₂ ≫ sq₂.f₂₄ := by aesop_cat\n  comm₃₄ : sq₁.f₃₄ ≫ τ₄ = τ₃ ≫ sq₂.f₃₄ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Square.Hom.mk.inj","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq₁ sq₂ : CategoryTheory.Square C\nτ₁✝ : Quiver.Hom sq₁.X₁ sq₂.X₁\nτ₂✝ : Quiver.Hom sq₁.X₂ sq₂.X₂\nτ₃✝ : Quiver.Hom sq₁.X₃ sq₂.X₃\nτ₄✝ : Quiver.Hom sq₁.X₄ sq₂.X₄\ncomm₁₂✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq₁.f₁₂ τ₂✝) (CategoryTheory.CategoryStruct.comp τ₁✝ sq₂.f₁₂)) _auto✝\ncomm₁₃✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq₁.f₁₃ τ₃✝) (CategoryTheory.CategoryStruct.comp τ₁✝ sq₂.f₁₃)) _auto✝\ncomm₂₄✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq₁.f₂₄ τ₄✝) (CategoryTheory.CategoryStruct.comp τ₂✝ sq₂.f₂₄)) _auto✝\ncomm₃₄✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq₁.f₃₄ τ₄✝) (CategoryTheory.CategoryStruct.comp τ₃✝ sq₂.f₃₄)) _auto✝\nτ₁ : Quiver.Hom sq₁.X₁ sq₂.X₁\nτ₂ : Quiver.Hom sq₁.X₂ sq₂.X₂\nτ₃ : Quiver.Hom sq₁.X₃ sq₂.X₃\nτ₄ : Quiver.Hom sq₁.X₄ sq₂.X₄\ncomm₁₂ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq₁.f₁₂ τ₂) (CategoryTheory.CategoryStruct.comp τ₁ sq₂.f₁₂)) _auto✝\ncomm₁₃ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq₁.f₁₃ τ₃) (CategoryTheory.CategoryStruct.comp τ₁ sq₂.f₁₃)) _auto✝\ncomm₂₄ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq₁.f₂₄ τ₄) (CategoryTheory.CategoryStruct.comp τ₂ sq₂.f₂₄)) _auto✝\ncomm₃₄ : autoParam (Eq (CategoryTheory.CategoryStruct.comp sq₁.f₃₄ τ₄) (CategoryTheory.CategoryStruct.comp τ₃ sq₂.f₃₄)) _auto✝\nx✝ : Eq { τ₁ := τ₁✝, τ₂ := τ₂✝, τ₃ := τ₃✝, τ₄ := τ₄✝, comm₁₂ := comm₁₂✝, comm₁₃ := comm₁₃✝, comm₂₄ := comm₂₄✝, comm₃₄ := comm₃₄✝ } { τ₁ := τ₁, τ₂ := τ₂, τ₃ := τ₃, τ₄ := τ₄, comm₁₂ := comm₁₂, comm₁₃ := comm₁₃, comm₂₄ := comm₂₄, comm₃₄ := comm₃₄ }\n⊢ And (Eq τ₁✝ τ₁) (And (Eq τ₂✝ τ₂) (And (Eq τ₃✝ τ₃) (Eq τ₄✝ τ₄)))","decl":"/-- A morphism between two commutative squares consists of 4 morphisms\nwhich extend these two squares into a commuting cube. -/\n@[ext]\nstructure Hom (sq₁ sq₂ : Square C) where\n  /-- the top-left morphism -/\n  τ₁ : sq₁.X₁ ⟶ sq₂.X₁\n  /-- the top-right morphism -/\n  τ₂ : sq₁.X₂ ⟶ sq₂.X₂\n  /-- the bottom-left morphism -/\n  τ₃ : sq₁.X₃ ⟶ sq₂.X₃\n  /-- the bottom-right morphism -/\n  τ₄ : sq₁.X₄ ⟶ sq₂.X₄\n  comm₁₂ : sq₁.f₁₂ ≫ τ₂ = τ₁ ≫ sq₂.f₁₂ := by aesop_cat\n  comm₁₃ : sq₁.f₁₃ ≫ τ₃ = τ₁ ≫ sq₂.f₁₃ := by aesop_cat\n  comm₂₄ : sq₁.f₂₄ ≫ τ₄ = τ₂ ≫ sq₂.f₂₄ := by aesop_cat\n  comm₃₄ : sq₁.f₃₄ ≫ τ₄ = τ₃ ≫ sq₂.f₃₄ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Square.Hom.ext","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq₁ sq₂ : CategoryTheory.Square C\nx y : sq₁.Hom sq₂\nτ₁ : Eq x.τ₁ y.τ₁\nτ₂ : Eq x.τ₂ y.τ₂\nτ₃ : Eq x.τ₃ y.τ₃\nτ₄ : Eq x.τ₄ y.τ₄\n⊢ Eq x y","decl":"/-- A morphism between two commutative squares consists of 4 morphisms\nwhich extend these two squares into a commuting cube. -/\n@[ext]\nstructure Hom (sq₁ sq₂ : Square C) where\n  /-- the top-left morphism -/\n  τ₁ : sq₁.X₁ ⟶ sq₂.X₁\n  /-- the top-right morphism -/\n  τ₂ : sq₁.X₂ ⟶ sq₂.X₂\n  /-- the bottom-left morphism -/\n  τ₃ : sq₁.X₃ ⟶ sq₂.X₃\n  /-- the bottom-right morphism -/\n  τ₄ : sq₁.X₄ ⟶ sq₂.X₄\n  comm₁₂ : sq₁.f₁₂ ≫ τ₂ = τ₁ ≫ sq₂.f₁₂ := by aesop_cat\n  comm₁₃ : sq₁.f₁₃ ≫ τ₃ = τ₁ ≫ sq₂.f₁₃ := by aesop_cat\n  comm₂₄ : sq₁.f₂₄ ≫ τ₄ = τ₂ ≫ sq₂.f₂₄ := by aesop_cat\n  comm₃₄ : sq₁.f₃₄ ≫ τ₄ = τ₃ ≫ sq₂.f₃₄ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Square.Hom.comm₁₂_assoc","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq₁ sq₂ : CategoryTheory.Square C\nself : sq₁.Hom sq₂\nZ : C\nh : Quiver.Hom sq₂.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp sq₁.f₁₂ (CategoryTheory.CategoryStruct.comp self.τ₂ h)) (CategoryTheory.CategoryStruct.comp self.τ₁ (CategoryTheory.CategoryStruct.comp sq₂.f₁₂ h))","decl":"attribute [reassoc (attr := simp)] comm₁₂ comm₁₃ comm₂₄ comm₃₄\n\n"}
{"name":"CategoryTheory.Square.Hom.comm₃₄_assoc","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq₁ sq₂ : CategoryTheory.Square C\nself : sq₁.Hom sq₂\nZ : C\nh : Quiver.Hom sq₂.X₄ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp sq₁.f₃₄ (CategoryTheory.CategoryStruct.comp self.τ₄ h)) (CategoryTheory.CategoryStruct.comp self.τ₃ (CategoryTheory.CategoryStruct.comp sq₂.f₃₄ h))","decl":"attribute [reassoc (attr := simp)] comm₁₂ comm₁₃ comm₂₄ comm₃₄\n\n"}
{"name":"CategoryTheory.Square.Hom.comm₁₃_assoc","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq₁ sq₂ : CategoryTheory.Square C\nself : sq₁.Hom sq₂\nZ : C\nh : Quiver.Hom sq₂.X₃ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp sq₁.f₁₃ (CategoryTheory.CategoryStruct.comp self.τ₃ h)) (CategoryTheory.CategoryStruct.comp self.τ₁ (CategoryTheory.CategoryStruct.comp sq₂.f₁₃ h))","decl":"attribute [reassoc (attr := simp)] comm₁₂ comm₁₃ comm₂₄ comm₃₄\n\n"}
{"name":"CategoryTheory.Square.Hom.comm₂₄_assoc","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq₁ sq₂ : CategoryTheory.Square C\nself : sq₁.Hom sq₂\nZ : C\nh : Quiver.Hom sq₂.X₄ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp sq₁.f₂₄ (CategoryTheory.CategoryStruct.comp self.τ₄ h)) (CategoryTheory.CategoryStruct.comp self.τ₂ (CategoryTheory.CategoryStruct.comp sq₂.f₂₄ h))","decl":"attribute [reassoc (attr := simp)] comm₁₂ comm₁₃ comm₂₄ comm₃₄\n\n"}
{"name":"CategoryTheory.Square.Hom.id_τ₂","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.Hom.id sq).τ₂ (CategoryTheory.CategoryStruct.id sq.X₂)","decl":"/-- The identity of a commutative square. -/\n@[simps]\ndef id (sq : Square C) : Hom sq sq where\n  τ₁ := 𝟙 _\n  τ₂ := 𝟙 _\n  τ₃ := 𝟙 _\n  τ₄ := 𝟙 _\n\n"}
{"name":"CategoryTheory.Square.Hom.id_τ₁","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.Hom.id sq).τ₁ (CategoryTheory.CategoryStruct.id sq.X₁)","decl":"/-- The identity of a commutative square. -/\n@[simps]\ndef id (sq : Square C) : Hom sq sq where\n  τ₁ := 𝟙 _\n  τ₂ := 𝟙 _\n  τ₃ := 𝟙 _\n  τ₄ := 𝟙 _\n\n"}
{"name":"CategoryTheory.Square.Hom.id_τ₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.Hom.id sq).τ₄ (CategoryTheory.CategoryStruct.id sq.X₄)","decl":"/-- The identity of a commutative square. -/\n@[simps]\ndef id (sq : Square C) : Hom sq sq where\n  τ₁ := 𝟙 _\n  τ₂ := 𝟙 _\n  τ₃ := 𝟙 _\n  τ₄ := 𝟙 _\n\n"}
{"name":"CategoryTheory.Square.Hom.id_τ₃","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.Hom.id sq).τ₃ (CategoryTheory.CategoryStruct.id sq.X₃)","decl":"/-- The identity of a commutative square. -/\n@[simps]\ndef id (sq : Square C) : Hom sq sq where\n  τ₁ := 𝟙 _\n  τ₂ := 𝟙 _\n  τ₃ := 𝟙 _\n  τ₄ := 𝟙 _\n\n"}
{"name":"CategoryTheory.Square.Hom.comp_τ₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq₁ sq₂ sq₃ : CategoryTheory.Square C\nf : sq₁.Hom sq₂\ng : sq₂.Hom sq₃\n⊢ Eq (f.comp g).τ₄ (CategoryTheory.CategoryStruct.comp f.τ₄ g.τ₄)","decl":"/-- The composition of morphisms of squares. -/\n@[simps]\ndef comp {sq₁ sq₂ sq₃ : Square C} (f : Hom sq₁ sq₂) (g : Hom sq₂ sq₃) : Hom sq₁ sq₃ where\n  τ₁ := f.τ₁ ≫ g.τ₁\n  τ₂ := f.τ₂ ≫ g.τ₂\n  τ₃ := f.τ₃ ≫ g.τ₃\n  τ₄ := f.τ₄ ≫ g.τ₄\n\n"}
{"name":"CategoryTheory.Square.Hom.comp_τ₂","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq₁ sq₂ sq₃ : CategoryTheory.Square C\nf : sq₁.Hom sq₂\ng : sq₂.Hom sq₃\n⊢ Eq (f.comp g).τ₂ (CategoryTheory.CategoryStruct.comp f.τ₂ g.τ₂)","decl":"/-- The composition of morphisms of squares. -/\n@[simps]\ndef comp {sq₁ sq₂ sq₃ : Square C} (f : Hom sq₁ sq₂) (g : Hom sq₂ sq₃) : Hom sq₁ sq₃ where\n  τ₁ := f.τ₁ ≫ g.τ₁\n  τ₂ := f.τ₂ ≫ g.τ₂\n  τ₃ := f.τ₃ ≫ g.τ₃\n  τ₄ := f.τ₄ ≫ g.τ₄\n\n"}
{"name":"CategoryTheory.Square.Hom.comp_τ₃","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq₁ sq₂ sq₃ : CategoryTheory.Square C\nf : sq₁.Hom sq₂\ng : sq₂.Hom sq₃\n⊢ Eq (f.comp g).τ₃ (CategoryTheory.CategoryStruct.comp f.τ₃ g.τ₃)","decl":"/-- The composition of morphisms of squares. -/\n@[simps]\ndef comp {sq₁ sq₂ sq₃ : Square C} (f : Hom sq₁ sq₂) (g : Hom sq₂ sq₃) : Hom sq₁ sq₃ where\n  τ₁ := f.τ₁ ≫ g.τ₁\n  τ₂ := f.τ₂ ≫ g.τ₂\n  τ₃ := f.τ₃ ≫ g.τ₃\n  τ₄ := f.τ₄ ≫ g.τ₄\n\n"}
{"name":"CategoryTheory.Square.Hom.comp_τ₁","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq₁ sq₂ sq₃ : CategoryTheory.Square C\nf : sq₁.Hom sq₂\ng : sq₂.Hom sq₃\n⊢ Eq (f.comp g).τ₁ (CategoryTheory.CategoryStruct.comp f.τ₁ g.τ₁)","decl":"/-- The composition of morphisms of squares. -/\n@[simps]\ndef comp {sq₁ sq₂ sq₃ : Square C} (f : Hom sq₁ sq₂) (g : Hom sq₂ sq₃) : Hom sq₁ sq₃ where\n  τ₁ := f.τ₁ ≫ g.τ₁\n  τ₂ := f.τ₂ ≫ g.τ₂\n  τ₃ := f.τ₃ ≫ g.τ₃\n  τ₄ := f.τ₄ ≫ g.τ₄\n\n"}
{"name":"CategoryTheory.Square.category_id_τ₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.CategoryStruct.id sq).τ₄ (CategoryTheory.CategoryStruct.id sq.X₄)","decl":"@[simps!]\ninstance category : Category (Square C) where\n  Hom := Hom\n  id := Hom.id\n  comp := Hom.comp\n\n"}
{"name":"CategoryTheory.Square.category_id_τ₃","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.CategoryStruct.id sq).τ₃ (CategoryTheory.CategoryStruct.id sq.X₃)","decl":"@[simps!]\ninstance category : Category (Square C) where\n  Hom := Hom\n  id := Hom.id\n  comp := Hom.comp\n\n"}
{"name":"CategoryTheory.Square.category_comp_τ₂","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ Z✝ : CategoryTheory.Square C\nf : X✝.Hom Y✝\ng : Y✝.Hom Z✝\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).τ₂ (CategoryTheory.CategoryStruct.comp f.τ₂ g.τ₂)","decl":"@[simps!]\ninstance category : Category (Square C) where\n  Hom := Hom\n  id := Hom.id\n  comp := Hom.comp\n\n"}
{"name":"CategoryTheory.Square.category_id_τ₂","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.CategoryStruct.id sq).τ₂ (CategoryTheory.CategoryStruct.id sq.X₂)","decl":"@[simps!]\ninstance category : Category (Square C) where\n  Hom := Hom\n  id := Hom.id\n  comp := Hom.comp\n\n"}
{"name":"CategoryTheory.Square.category_comp_τ₃","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ Z✝ : CategoryTheory.Square C\nf : X✝.Hom Y✝\ng : Y✝.Hom Z✝\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).τ₃ (CategoryTheory.CategoryStruct.comp f.τ₃ g.τ₃)","decl":"@[simps!]\ninstance category : Category (Square C) where\n  Hom := Hom\n  id := Hom.id\n  comp := Hom.comp\n\n"}
{"name":"CategoryTheory.Square.category_comp_τ₁","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ Z✝ : CategoryTheory.Square C\nf : X✝.Hom Y✝\ng : Y✝.Hom Z✝\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).τ₁ (CategoryTheory.CategoryStruct.comp f.τ₁ g.τ₁)","decl":"@[simps!]\ninstance category : Category (Square C) where\n  Hom := Hom\n  id := Hom.id\n  comp := Hom.comp\n\n"}
{"name":"CategoryTheory.Square.category_id_τ₁","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.CategoryStruct.id sq).τ₁ (CategoryTheory.CategoryStruct.id sq.X₁)","decl":"@[simps!]\ninstance category : Category (Square C) where\n  Hom := Hom\n  id := Hom.id\n  comp := Hom.comp\n\n"}
{"name":"CategoryTheory.Square.category_comp_τ₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ Z✝ : CategoryTheory.Square C\nf : X✝.Hom Y✝\ng : Y✝.Hom Z✝\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).τ₄ (CategoryTheory.CategoryStruct.comp f.τ₄ g.τ₄)","decl":"@[simps!]\ninstance category : Category (Square C) where\n  Hom := Hom\n  id := Hom.id\n  comp := Hom.comp\n\n"}
{"name":"CategoryTheory.Square.hom_ext","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq₁ sq₂ : CategoryTheory.Square C\nf g : Quiver.Hom sq₁ sq₂\nh₁ : Eq f.τ₁ g.τ₁\nh₂ : Eq f.τ₂ g.τ₂\nh₃ : Eq f.τ₃ g.τ₃\nh₄ : Eq f.τ₄ g.τ₄\n⊢ Eq f g","decl":"@[ext]\nlemma hom_ext {sq₁ sq₂ : Square C} {f g : sq₁ ⟶ sq₂}\n    (h₁ : f.τ₁ = g.τ₁) (h₂ : f.τ₂ = g.τ₂)\n    (h₃ : f.τ₃ = g.τ₃) (h₄ : f.τ₄ = g.τ₄) : f = g :=\n  Hom.ext h₁ h₂ h₃ h₄\n\n"}
{"name":"CategoryTheory.Square.hom_ext_iff","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq₁ sq₂ : CategoryTheory.Square C\nf g : Quiver.Hom sq₁ sq₂\n⊢ Iff (Eq f g) (And (Eq f.τ₁ g.τ₁) (And (Eq f.τ₂ g.τ₂) (And (Eq f.τ₃ g.τ₃) (Eq f.τ₄ g.τ₄))))","decl":"@[ext]\nlemma hom_ext {sq₁ sq₂ : Square C} {f g : sq₁ ⟶ sq₂}\n    (h₁ : f.τ₁ = g.τ₁) (h₂ : f.τ₂ = g.τ₂)\n    (h₃ : f.τ₃ = g.τ₃) (h₄ : f.τ₄ = g.τ₄) : f = g :=\n  Hom.ext h₁ h₂ h₃ h₄\n\n"}
{"name":"CategoryTheory.Square.flip_X₁","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq sq.flip.X₁ sq.X₁","decl":"/-- Flipping a square by switching the top-right and the bottom-left objects. -/\n@[simps]\ndef flip (sq : Square C) : Square C where\n  fac := sq.fac.symm\n\n"}
{"name":"CategoryTheory.Square.flip_X₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq sq.flip.X₄ sq.X₄","decl":"/-- Flipping a square by switching the top-right and the bottom-left objects. -/\n@[simps]\ndef flip (sq : Square C) : Square C where\n  fac := sq.fac.symm\n\n"}
{"name":"CategoryTheory.Square.flip_f₂₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq sq.flip.f₂₄ sq.f₃₄","decl":"/-- Flipping a square by switching the top-right and the bottom-left objects. -/\n@[simps]\ndef flip (sq : Square C) : Square C where\n  fac := sq.fac.symm\n\n"}
{"name":"CategoryTheory.Square.flip_X₂","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq sq.flip.X₂ sq.X₃","decl":"/-- Flipping a square by switching the top-right and the bottom-left objects. -/\n@[simps]\ndef flip (sq : Square C) : Square C where\n  fac := sq.fac.symm\n\n"}
{"name":"CategoryTheory.Square.flip_f₁₃","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq sq.flip.f₁₃ sq.f₁₂","decl":"/-- Flipping a square by switching the top-right and the bottom-left objects. -/\n@[simps]\ndef flip (sq : Square C) : Square C where\n  fac := sq.fac.symm\n\n"}
{"name":"CategoryTheory.Square.flip_f₃₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq sq.flip.f₃₄ sq.f₂₄","decl":"/-- Flipping a square by switching the top-right and the bottom-left objects. -/\n@[simps]\ndef flip (sq : Square C) : Square C where\n  fac := sq.fac.symm\n\n"}
{"name":"CategoryTheory.Square.flip_f₁₂","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq sq.flip.f₁₂ sq.f₁₃","decl":"/-- Flipping a square by switching the top-right and the bottom-left objects. -/\n@[simps]\ndef flip (sq : Square C) : Square C where\n  fac := sq.fac.symm\n\n"}
{"name":"CategoryTheory.Square.flip_X₃","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq sq.flip.X₃ sq.X₂","decl":"/-- Flipping a square by switching the top-right and the bottom-left objects. -/\n@[simps]\ndef flip (sq : Square C) : Square C where\n  fac := sq.fac.symm\n\n"}
{"name":"CategoryTheory.Square.flipFunctor_map_τ₃","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Square C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.flipFunctor.map φ).τ₃ φ.τ₂","decl":"/-- The functor which flips commutative squares. -/\n@[simps]\ndef flipFunctor : Square C ⥤ Square C where\n  obj := flip\n  map φ :=\n    { τ₁ := φ.τ₁\n      τ₂ := φ.τ₃\n      τ₃ := φ.τ₂\n      τ₄ := φ.τ₄ }\n\n"}
{"name":"CategoryTheory.Square.flipFunctor_map_τ₂","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Square C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.flipFunctor.map φ).τ₂ φ.τ₃","decl":"/-- The functor which flips commutative squares. -/\n@[simps]\ndef flipFunctor : Square C ⥤ Square C where\n  obj := flip\n  map φ :=\n    { τ₁ := φ.τ₁\n      τ₂ := φ.τ₃\n      τ₃ := φ.τ₂\n      τ₄ := φ.τ₄ }\n\n"}
{"name":"CategoryTheory.Square.flipFunctor_map_τ₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Square C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.flipFunctor.map φ).τ₄ φ.τ₄","decl":"/-- The functor which flips commutative squares. -/\n@[simps]\ndef flipFunctor : Square C ⥤ Square C where\n  obj := flip\n  map φ :=\n    { τ₁ := φ.τ₁\n      τ₂ := φ.τ₃\n      τ₃ := φ.τ₂\n      τ₄ := φ.τ₄ }\n\n"}
{"name":"CategoryTheory.Square.flipFunctor_obj","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.flipFunctor.obj sq) sq.flip","decl":"/-- The functor which flips commutative squares. -/\n@[simps]\ndef flipFunctor : Square C ⥤ Square C where\n  obj := flip\n  map φ :=\n    { τ₁ := φ.τ₁\n      τ₂ := φ.τ₃\n      τ₃ := φ.τ₂\n      τ₄ := φ.τ₄ }\n\n"}
{"name":"CategoryTheory.Square.flipFunctor_map_τ₁","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Square C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.flipFunctor.map φ).τ₁ φ.τ₁","decl":"/-- The functor which flips commutative squares. -/\n@[simps]\ndef flipFunctor : Square C ⥤ Square C where\n  obj := flip\n  map φ :=\n    { τ₁ := φ.τ₁\n      τ₂ := φ.τ₃\n      τ₃ := φ.τ₂\n      τ₄ := φ.τ₄ }\n\n"}
{"name":"CategoryTheory.Square.flipEquivalence_unitIso","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Eq CategoryTheory.Square.flipEquivalence.unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id (CategoryTheory.Square C)))","decl":"/-- Flipping commutative squares is an auto-equivalence. -/\n@[simps]\ndef flipEquivalence : Square C ≌ Square C where\n  functor := flipFunctor\n  inverse := flipFunctor\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Square.flipEquivalence_counitIso","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Eq CategoryTheory.Square.flipEquivalence.counitIso (CategoryTheory.Iso.refl (CategoryTheory.Square.flipFunctor.comp CategoryTheory.Square.flipFunctor))","decl":"/-- Flipping commutative squares is an auto-equivalence. -/\n@[simps]\ndef flipEquivalence : Square C ≌ Square C where\n  functor := flipFunctor\n  inverse := flipFunctor\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Square.flipEquivalence_functor","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Eq CategoryTheory.Square.flipEquivalence.functor CategoryTheory.Square.flipFunctor","decl":"/-- Flipping commutative squares is an auto-equivalence. -/\n@[simps]\ndef flipEquivalence : Square C ≌ Square C where\n  functor := flipFunctor\n  inverse := flipFunctor\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Square.flipEquivalence_inverse","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Eq CategoryTheory.Square.flipEquivalence.inverse CategoryTheory.Square.flipFunctor","decl":"/-- Flipping commutative squares is an auto-equivalence. -/\n@[simps]\ndef flipEquivalence : Square C ≌ Square C where\n  functor := flipFunctor\n  inverse := flipFunctor\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor_map_right_right","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Square C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.toArrowArrowFunctor.map φ).right.right φ.τ₄","decl":"/-- The functor `Square C ⥤ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor : Square C ⥤ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac : Arrow.mk sq.f₁₃ ⟶ Arrow.mk sq.f₂₄)\n  map φ := Arrow.homMk (Arrow.homMk _ _ φ.comm₁₃.symm)\n    (Arrow.homMk _ _ φ.comm₂₄.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor_map_right_left","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Square C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.toArrowArrowFunctor.map φ).right.left φ.τ₂","decl":"/-- The functor `Square C ⥤ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor : Square C ⥤ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac : Arrow.mk sq.f₁₃ ⟶ Arrow.mk sq.f₂₄)\n  map φ := Arrow.homMk (Arrow.homMk _ _ φ.comm₁₃.symm)\n    (Arrow.homMk _ _ φ.comm₂₄.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor_obj_right_right","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.toArrowArrowFunctor.obj sq).right.right sq.X₄","decl":"/-- The functor `Square C ⥤ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor : Square C ⥤ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac : Arrow.mk sq.f₁₃ ⟶ Arrow.mk sq.f₂₄)\n  map φ := Arrow.homMk (Arrow.homMk _ _ φ.comm₁₃.symm)\n    (Arrow.homMk _ _ φ.comm₂₄.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor_map_left_right","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Square C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.toArrowArrowFunctor.map φ).left.right φ.τ₃","decl":"/-- The functor `Square C ⥤ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor : Square C ⥤ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac : Arrow.mk sq.f₁₃ ⟶ Arrow.mk sq.f₂₄)\n  map φ := Arrow.homMk (Arrow.homMk _ _ φ.comm₁₃.symm)\n    (Arrow.homMk _ _ φ.comm₂₄.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor_obj_right_hom","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.toArrowArrowFunctor.obj sq).right.hom sq.f₂₄","decl":"/-- The functor `Square C ⥤ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor : Square C ⥤ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac : Arrow.mk sq.f₁₃ ⟶ Arrow.mk sq.f₂₄)\n  map φ := Arrow.homMk (Arrow.homMk _ _ φ.comm₁₃.symm)\n    (Arrow.homMk _ _ φ.comm₂₄.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor_obj_left_right","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.toArrowArrowFunctor.obj sq).left.right sq.X₃","decl":"/-- The functor `Square C ⥤ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor : Square C ⥤ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac : Arrow.mk sq.f₁₃ ⟶ Arrow.mk sq.f₂₄)\n  map φ := Arrow.homMk (Arrow.homMk _ _ φ.comm₁₃.symm)\n    (Arrow.homMk _ _ φ.comm₂₄.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor_obj_left_hom","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.toArrowArrowFunctor.obj sq).left.hom sq.f₁₃","decl":"/-- The functor `Square C ⥤ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor : Square C ⥤ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac : Arrow.mk sq.f₁₃ ⟶ Arrow.mk sq.f₂₄)\n  map φ := Arrow.homMk (Arrow.homMk _ _ φ.comm₁₃.symm)\n    (Arrow.homMk _ _ φ.comm₂₄.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor_map_left_left","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Square C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.toArrowArrowFunctor.map φ).left.left φ.τ₁","decl":"/-- The functor `Square C ⥤ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor : Square C ⥤ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac : Arrow.mk sq.f₁₃ ⟶ Arrow.mk sq.f₂₄)\n  map φ := Arrow.homMk (Arrow.homMk _ _ φ.comm₁₃.symm)\n    (Arrow.homMk _ _ φ.comm₂₄.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor_obj_hom_left","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.toArrowArrowFunctor.obj sq).hom.left sq.f₁₂","decl":"/-- The functor `Square C ⥤ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor : Square C ⥤ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac : Arrow.mk sq.f₁₃ ⟶ Arrow.mk sq.f₂₄)\n  map φ := Arrow.homMk (Arrow.homMk _ _ φ.comm₁₃.symm)\n    (Arrow.homMk _ _ φ.comm₂₄.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor_obj_hom_right","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.toArrowArrowFunctor.obj sq).hom.right sq.f₃₄","decl":"/-- The functor `Square C ⥤ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor : Square C ⥤ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac : Arrow.mk sq.f₁₃ ⟶ Arrow.mk sq.f₂₄)\n  map φ := Arrow.homMk (Arrow.homMk _ _ φ.comm₁₃.symm)\n    (Arrow.homMk _ _ φ.comm₂₄.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor_obj_left_left","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.toArrowArrowFunctor.obj sq).left.left sq.X₁","decl":"/-- The functor `Square C ⥤ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor : Square C ⥤ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac : Arrow.mk sq.f₁₃ ⟶ Arrow.mk sq.f₂₄)\n  map φ := Arrow.homMk (Arrow.homMk _ _ φ.comm₁₃.symm)\n    (Arrow.homMk _ _ φ.comm₂₄.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor_obj_right_left","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.toArrowArrowFunctor.obj sq).right.left sq.X₂","decl":"/-- The functor `Square C ⥤ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor : Square C ⥤ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac : Arrow.mk sq.f₁₃ ⟶ Arrow.mk sq.f₂₄)\n  map φ := Arrow.homMk (Arrow.homMk _ _ φ.comm₁₃.symm)\n    (Arrow.homMk _ _ φ.comm₂₄.symm)\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor_obj_f₃₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n⊢ Eq (CategoryTheory.Square.fromArrowArrowFunctor.obj f).f₃₄ f.hom.right","decl":"/-- The functor `Arrow (Arrow C) ⥤ Square C` which sends\na morphism `Arrow.mk f ⟶ Arrow.mk g` to the commutative square\nwith `f` on the left side and `g` on the right side. -/\n@[simps!]\ndef fromArrowArrowFunctor : Arrow (Arrow C) ⥤ Square C where\n  obj f := { fac := f.hom.w }\n  map φ :=\n    { τ₁ := φ.left.left\n      τ₂ := φ.right.left\n      τ₃ := φ.left.right\n      τ₄ := φ.right.right\n      comm₁₂ := Arrow.leftFunc.congr_map φ.w.symm\n      comm₁₃ := φ.left.w.symm\n      comm₂₄ := φ.right.w.symm\n      comm₃₄ := Arrow.rightFunc.congr_map φ.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor_obj_X₃","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n⊢ Eq (CategoryTheory.Square.fromArrowArrowFunctor.obj f).X₃ f.left.right","decl":"/-- The functor `Arrow (Arrow C) ⥤ Square C` which sends\na morphism `Arrow.mk f ⟶ Arrow.mk g` to the commutative square\nwith `f` on the left side and `g` on the right side. -/\n@[simps!]\ndef fromArrowArrowFunctor : Arrow (Arrow C) ⥤ Square C where\n  obj f := { fac := f.hom.w }\n  map φ :=\n    { τ₁ := φ.left.left\n      τ₂ := φ.right.left\n      τ₃ := φ.left.right\n      τ₄ := φ.right.right\n      comm₁₂ := Arrow.leftFunc.congr_map φ.w.symm\n      comm₁₃ := φ.left.w.symm\n      comm₂₄ := φ.right.w.symm\n      comm₃₄ := Arrow.rightFunc.congr_map φ.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor_map_τ₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Arrow (CategoryTheory.Arrow C)\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.fromArrowArrowFunctor.map φ).τ₄ φ.right.right","decl":"/-- The functor `Arrow (Arrow C) ⥤ Square C` which sends\na morphism `Arrow.mk f ⟶ Arrow.mk g` to the commutative square\nwith `f` on the left side and `g` on the right side. -/\n@[simps!]\ndef fromArrowArrowFunctor : Arrow (Arrow C) ⥤ Square C where\n  obj f := { fac := f.hom.w }\n  map φ :=\n    { τ₁ := φ.left.left\n      τ₂ := φ.right.left\n      τ₃ := φ.left.right\n      τ₄ := φ.right.right\n      comm₁₂ := Arrow.leftFunc.congr_map φ.w.symm\n      comm₁₃ := φ.left.w.symm\n      comm₂₄ := φ.right.w.symm\n      comm₃₄ := Arrow.rightFunc.congr_map φ.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor_map_τ₁","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Arrow (CategoryTheory.Arrow C)\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.fromArrowArrowFunctor.map φ).τ₁ φ.left.left","decl":"/-- The functor `Arrow (Arrow C) ⥤ Square C` which sends\na morphism `Arrow.mk f ⟶ Arrow.mk g` to the commutative square\nwith `f` on the left side and `g` on the right side. -/\n@[simps!]\ndef fromArrowArrowFunctor : Arrow (Arrow C) ⥤ Square C where\n  obj f := { fac := f.hom.w }\n  map φ :=\n    { τ₁ := φ.left.left\n      τ₂ := φ.right.left\n      τ₃ := φ.left.right\n      τ₄ := φ.right.right\n      comm₁₂ := Arrow.leftFunc.congr_map φ.w.symm\n      comm₁₃ := φ.left.w.symm\n      comm₂₄ := φ.right.w.symm\n      comm₃₄ := Arrow.rightFunc.congr_map φ.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor_obj_f₂₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n⊢ Eq (CategoryTheory.Square.fromArrowArrowFunctor.obj f).f₂₄ f.right.hom","decl":"/-- The functor `Arrow (Arrow C) ⥤ Square C` which sends\na morphism `Arrow.mk f ⟶ Arrow.mk g` to the commutative square\nwith `f` on the left side and `g` on the right side. -/\n@[simps!]\ndef fromArrowArrowFunctor : Arrow (Arrow C) ⥤ Square C where\n  obj f := { fac := f.hom.w }\n  map φ :=\n    { τ₁ := φ.left.left\n      τ₂ := φ.right.left\n      τ₃ := φ.left.right\n      τ₄ := φ.right.right\n      comm₁₂ := Arrow.leftFunc.congr_map φ.w.symm\n      comm₁₃ := φ.left.w.symm\n      comm₂₄ := φ.right.w.symm\n      comm₃₄ := Arrow.rightFunc.congr_map φ.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor_obj_f₁₃","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n⊢ Eq (CategoryTheory.Square.fromArrowArrowFunctor.obj f).f₁₃ f.left.hom","decl":"/-- The functor `Arrow (Arrow C) ⥤ Square C` which sends\na morphism `Arrow.mk f ⟶ Arrow.mk g` to the commutative square\nwith `f` on the left side and `g` on the right side. -/\n@[simps!]\ndef fromArrowArrowFunctor : Arrow (Arrow C) ⥤ Square C where\n  obj f := { fac := f.hom.w }\n  map φ :=\n    { τ₁ := φ.left.left\n      τ₂ := φ.right.left\n      τ₃ := φ.left.right\n      τ₄ := φ.right.right\n      comm₁₂ := Arrow.leftFunc.congr_map φ.w.symm\n      comm₁₃ := φ.left.w.symm\n      comm₂₄ := φ.right.w.symm\n      comm₃₄ := Arrow.rightFunc.congr_map φ.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor_obj_f₁₂","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n⊢ Eq (CategoryTheory.Square.fromArrowArrowFunctor.obj f).f₁₂ f.hom.left","decl":"/-- The functor `Arrow (Arrow C) ⥤ Square C` which sends\na morphism `Arrow.mk f ⟶ Arrow.mk g` to the commutative square\nwith `f` on the left side and `g` on the right side. -/\n@[simps!]\ndef fromArrowArrowFunctor : Arrow (Arrow C) ⥤ Square C where\n  obj f := { fac := f.hom.w }\n  map φ :=\n    { τ₁ := φ.left.left\n      τ₂ := φ.right.left\n      τ₃ := φ.left.right\n      τ₄ := φ.right.right\n      comm₁₂ := Arrow.leftFunc.congr_map φ.w.symm\n      comm₁₃ := φ.left.w.symm\n      comm₂₄ := φ.right.w.symm\n      comm₃₄ := Arrow.rightFunc.congr_map φ.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor_obj_X₁","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n⊢ Eq (CategoryTheory.Square.fromArrowArrowFunctor.obj f).X₁ f.left.left","decl":"/-- The functor `Arrow (Arrow C) ⥤ Square C` which sends\na morphism `Arrow.mk f ⟶ Arrow.mk g` to the commutative square\nwith `f` on the left side and `g` on the right side. -/\n@[simps!]\ndef fromArrowArrowFunctor : Arrow (Arrow C) ⥤ Square C where\n  obj f := { fac := f.hom.w }\n  map φ :=\n    { τ₁ := φ.left.left\n      τ₂ := φ.right.left\n      τ₃ := φ.left.right\n      τ₄ := φ.right.right\n      comm₁₂ := Arrow.leftFunc.congr_map φ.w.symm\n      comm₁₃ := φ.left.w.symm\n      comm₂₄ := φ.right.w.symm\n      comm₃₄ := Arrow.rightFunc.congr_map φ.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor_map_τ₃","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Arrow (CategoryTheory.Arrow C)\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.fromArrowArrowFunctor.map φ).τ₃ φ.left.right","decl":"/-- The functor `Arrow (Arrow C) ⥤ Square C` which sends\na morphism `Arrow.mk f ⟶ Arrow.mk g` to the commutative square\nwith `f` on the left side and `g` on the right side. -/\n@[simps!]\ndef fromArrowArrowFunctor : Arrow (Arrow C) ⥤ Square C where\n  obj f := { fac := f.hom.w }\n  map φ :=\n    { τ₁ := φ.left.left\n      τ₂ := φ.right.left\n      τ₃ := φ.left.right\n      τ₄ := φ.right.right\n      comm₁₂ := Arrow.leftFunc.congr_map φ.w.symm\n      comm₁₃ := φ.left.w.symm\n      comm₂₄ := φ.right.w.symm\n      comm₃₄ := Arrow.rightFunc.congr_map φ.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor_map_τ₂","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Arrow (CategoryTheory.Arrow C)\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.fromArrowArrowFunctor.map φ).τ₂ φ.right.left","decl":"/-- The functor `Arrow (Arrow C) ⥤ Square C` which sends\na morphism `Arrow.mk f ⟶ Arrow.mk g` to the commutative square\nwith `f` on the left side and `g` on the right side. -/\n@[simps!]\ndef fromArrowArrowFunctor : Arrow (Arrow C) ⥤ Square C where\n  obj f := { fac := f.hom.w }\n  map φ :=\n    { τ₁ := φ.left.left\n      τ₂ := φ.right.left\n      τ₃ := φ.left.right\n      τ₄ := φ.right.right\n      comm₁₂ := Arrow.leftFunc.congr_map φ.w.symm\n      comm₁₃ := φ.left.w.symm\n      comm₂₄ := φ.right.w.symm\n      comm₃₄ := Arrow.rightFunc.congr_map φ.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor_obj_X₂","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n⊢ Eq (CategoryTheory.Square.fromArrowArrowFunctor.obj f).X₂ f.right.left","decl":"/-- The functor `Arrow (Arrow C) ⥤ Square C` which sends\na morphism `Arrow.mk f ⟶ Arrow.mk g` to the commutative square\nwith `f` on the left side and `g` on the right side. -/\n@[simps!]\ndef fromArrowArrowFunctor : Arrow (Arrow C) ⥤ Square C where\n  obj f := { fac := f.hom.w }\n  map φ :=\n    { τ₁ := φ.left.left\n      τ₂ := φ.right.left\n      τ₃ := φ.left.right\n      τ₄ := φ.right.right\n      comm₁₂ := Arrow.leftFunc.congr_map φ.w.symm\n      comm₁₃ := φ.left.w.symm\n      comm₂₄ := φ.right.w.symm\n      comm₃₄ := Arrow.rightFunc.congr_map φ.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor_obj_X₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n⊢ Eq (CategoryTheory.Square.fromArrowArrowFunctor.obj f).X₄ f.right.right","decl":"/-- The functor `Arrow (Arrow C) ⥤ Square C` which sends\na morphism `Arrow.mk f ⟶ Arrow.mk g` to the commutative square\nwith `f` on the left side and `g` on the right side. -/\n@[simps!]\ndef fromArrowArrowFunctor : Arrow (Arrow C) ⥤ Square C where\n  obj f := { fac := f.hom.w }\n  map φ :=\n    { τ₁ := φ.left.left\n      τ₂ := φ.right.left\n      τ₃ := φ.left.right\n      τ₄ := φ.right.right\n      comm₁₂ := Arrow.leftFunc.congr_map φ.w.symm\n      comm₁₃ := φ.left.w.symm\n      comm₂₄ := φ.right.w.symm\n      comm₃₄ := Arrow.rightFunc.congr_map φ.w.symm }\n\n"}
{"name":"CategoryTheory.Square.arrowArrowEquivalence_inverse","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Eq CategoryTheory.Square.arrowArrowEquivalence.inverse CategoryTheory.Square.fromArrowArrowFunctor","decl":"/-- The equivalence `Square C ≌ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps]\ndef arrowArrowEquivalence : Square C ≌ Arrow (Arrow C) where\n  functor := toArrowArrowFunctor\n  inverse := fromArrowArrowFunctor\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Square.arrowArrowEquivalence_counitIso","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Eq CategoryTheory.Square.arrowArrowEquivalence.counitIso (CategoryTheory.Iso.refl (CategoryTheory.Square.fromArrowArrowFunctor.comp CategoryTheory.Square.toArrowArrowFunctor))","decl":"/-- The equivalence `Square C ≌ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps]\ndef arrowArrowEquivalence : Square C ≌ Arrow (Arrow C) where\n  functor := toArrowArrowFunctor\n  inverse := fromArrowArrowFunctor\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Square.arrowArrowEquivalence_unitIso","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Eq CategoryTheory.Square.arrowArrowEquivalence.unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id (CategoryTheory.Square C)))","decl":"/-- The equivalence `Square C ≌ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps]\ndef arrowArrowEquivalence : Square C ≌ Arrow (Arrow C) where\n  functor := toArrowArrowFunctor\n  inverse := fromArrowArrowFunctor\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Square.arrowArrowEquivalence_functor","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Eq CategoryTheory.Square.arrowArrowEquivalence.functor CategoryTheory.Square.toArrowArrowFunctor","decl":"/-- The equivalence `Square C ≌ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the left morphism of `sq`\nto the right morphism of `sq`. -/\n@[simps]\ndef arrowArrowEquivalence : Square C ≌ Arrow (Arrow C) where\n  functor := toArrowArrowFunctor\n  inverse := fromArrowArrowFunctor\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor'_obj_right_left","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.toArrowArrowFunctor'.obj sq).right.left sq.X₃","decl":"/-- The functor `Square C ⥤ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor' : Square C ⥤ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac.symm : Arrow.mk sq.f₁₂ ⟶ Arrow.mk sq.f₃₄)\n  map φ := Arrow.homMk (Arrow.homMk _ _ φ.comm₁₂.symm)\n    (Arrow.homMk _ _ φ.comm₃₄.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor'_map_left_left","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Square C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.toArrowArrowFunctor'.map φ).left.left φ.τ₁","decl":"/-- The functor `Square C ⥤ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor' : Square C ⥤ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac.symm : Arrow.mk sq.f₁₂ ⟶ Arrow.mk sq.f₃₄)\n  map φ := Arrow.homMk (Arrow.homMk _ _ φ.comm₁₂.symm)\n    (Arrow.homMk _ _ φ.comm₃₄.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor'_obj_right_hom","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.toArrowArrowFunctor'.obj sq).right.hom sq.f₃₄","decl":"/-- The functor `Square C ⥤ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor' : Square C ⥤ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac.symm : Arrow.mk sq.f₁₂ ⟶ Arrow.mk sq.f₃₄)\n  map φ := Arrow.homMk (Arrow.homMk _ _ φ.comm₁₂.symm)\n    (Arrow.homMk _ _ φ.comm₃₄.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor'_obj_left_right","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.toArrowArrowFunctor'.obj sq).left.right sq.X₂","decl":"/-- The functor `Square C ⥤ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor' : Square C ⥤ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac.symm : Arrow.mk sq.f₁₂ ⟶ Arrow.mk sq.f₃₄)\n  map φ := Arrow.homMk (Arrow.homMk _ _ φ.comm₁₂.symm)\n    (Arrow.homMk _ _ φ.comm₃₄.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor'_map_right_right","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Square C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.toArrowArrowFunctor'.map φ).right.right φ.τ₄","decl":"/-- The functor `Square C ⥤ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor' : Square C ⥤ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac.symm : Arrow.mk sq.f₁₂ ⟶ Arrow.mk sq.f₃₄)\n  map φ := Arrow.homMk (Arrow.homMk _ _ φ.comm₁₂.symm)\n    (Arrow.homMk _ _ φ.comm₃₄.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor'_obj_hom_left","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.toArrowArrowFunctor'.obj sq).hom.left sq.f₁₃","decl":"/-- The functor `Square C ⥤ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor' : Square C ⥤ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac.symm : Arrow.mk sq.f₁₂ ⟶ Arrow.mk sq.f₃₄)\n  map φ := Arrow.homMk (Arrow.homMk _ _ φ.comm₁₂.symm)\n    (Arrow.homMk _ _ φ.comm₃₄.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor'_map_left_right","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Square C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.toArrowArrowFunctor'.map φ).left.right φ.τ₂","decl":"/-- The functor `Square C ⥤ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor' : Square C ⥤ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac.symm : Arrow.mk sq.f₁₂ ⟶ Arrow.mk sq.f₃₄)\n  map φ := Arrow.homMk (Arrow.homMk _ _ φ.comm₁₂.symm)\n    (Arrow.homMk _ _ φ.comm₃₄.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor'_obj_right_right","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.toArrowArrowFunctor'.obj sq).right.right sq.X₄","decl":"/-- The functor `Square C ⥤ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor' : Square C ⥤ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac.symm : Arrow.mk sq.f₁₂ ⟶ Arrow.mk sq.f₃₄)\n  map φ := Arrow.homMk (Arrow.homMk _ _ φ.comm₁₂.symm)\n    (Arrow.homMk _ _ φ.comm₃₄.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor'_obj_left_hom","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.toArrowArrowFunctor'.obj sq).left.hom sq.f₁₂","decl":"/-- The functor `Square C ⥤ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor' : Square C ⥤ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac.symm : Arrow.mk sq.f₁₂ ⟶ Arrow.mk sq.f₃₄)\n  map φ := Arrow.homMk (Arrow.homMk _ _ φ.comm₁₂.symm)\n    (Arrow.homMk _ _ φ.comm₃₄.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor'_obj_left_left","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.toArrowArrowFunctor'.obj sq).left.left sq.X₁","decl":"/-- The functor `Square C ⥤ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor' : Square C ⥤ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac.symm : Arrow.mk sq.f₁₂ ⟶ Arrow.mk sq.f₃₄)\n  map φ := Arrow.homMk (Arrow.homMk _ _ φ.comm₁₂.symm)\n    (Arrow.homMk _ _ φ.comm₃₄.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor'_obj_hom_right","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.toArrowArrowFunctor'.obj sq).hom.right sq.f₂₄","decl":"/-- The functor `Square C ⥤ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor' : Square C ⥤ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac.symm : Arrow.mk sq.f₁₂ ⟶ Arrow.mk sq.f₃₄)\n  map φ := Arrow.homMk (Arrow.homMk _ _ φ.comm₁₂.symm)\n    (Arrow.homMk _ _ φ.comm₃₄.symm)\n\n"}
{"name":"CategoryTheory.Square.toArrowArrowFunctor'_map_right_left","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Square C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.toArrowArrowFunctor'.map φ).right.left φ.τ₃","decl":"/-- The functor `Square C ⥤ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps!]\ndef toArrowArrowFunctor' : Square C ⥤ Arrow (Arrow C) where\n  obj sq := Arrow.mk (Arrow.homMk _ _ sq.fac.symm : Arrow.mk sq.f₁₂ ⟶ Arrow.mk sq.f₃₄)\n  map φ := Arrow.homMk (Arrow.homMk _ _ φ.comm₁₂.symm)\n    (Arrow.homMk _ _ φ.comm₃₄.symm)\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor'_obj_X₂","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n⊢ Eq (CategoryTheory.Square.fromArrowArrowFunctor'.obj f).X₂ f.left.right","decl":"/-- The functor `Arrow (Arrow C) ⥤ Square C` which sends\na morphism `Arrow.mk f ⟶ Arrow.mk g` to the commutative square\nwith `f` on the top side and `g` on the bottom side. -/\n@[simps!]\ndef fromArrowArrowFunctor' : Arrow (Arrow C) ⥤ Square C where\n  obj f := { fac := f.hom.w.symm }\n  map φ :=\n    { τ₁ := φ.left.left\n      τ₂ := φ.left.right\n      τ₃ := φ.right.left\n      τ₄ := φ.right.right\n      comm₁₂ := φ.left.w.symm\n      comm₁₃ := Arrow.leftFunc.congr_map φ.w.symm\n      comm₂₄ := Arrow.rightFunc.congr_map φ.w.symm\n      comm₃₄ := φ.right.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor'_map_τ₁","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Arrow (CategoryTheory.Arrow C)\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.fromArrowArrowFunctor'.map φ).τ₁ φ.left.left","decl":"/-- The functor `Arrow (Arrow C) ⥤ Square C` which sends\na morphism `Arrow.mk f ⟶ Arrow.mk g` to the commutative square\nwith `f` on the top side and `g` on the bottom side. -/\n@[simps!]\ndef fromArrowArrowFunctor' : Arrow (Arrow C) ⥤ Square C where\n  obj f := { fac := f.hom.w.symm }\n  map φ :=\n    { τ₁ := φ.left.left\n      τ₂ := φ.left.right\n      τ₃ := φ.right.left\n      τ₄ := φ.right.right\n      comm₁₂ := φ.left.w.symm\n      comm₁₃ := Arrow.leftFunc.congr_map φ.w.symm\n      comm₂₄ := Arrow.rightFunc.congr_map φ.w.symm\n      comm₃₄ := φ.right.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor'_obj_f₂₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n⊢ Eq (CategoryTheory.Square.fromArrowArrowFunctor'.obj f).f₂₄ f.hom.right","decl":"/-- The functor `Arrow (Arrow C) ⥤ Square C` which sends\na morphism `Arrow.mk f ⟶ Arrow.mk g` to the commutative square\nwith `f` on the top side and `g` on the bottom side. -/\n@[simps!]\ndef fromArrowArrowFunctor' : Arrow (Arrow C) ⥤ Square C where\n  obj f := { fac := f.hom.w.symm }\n  map φ :=\n    { τ₁ := φ.left.left\n      τ₂ := φ.left.right\n      τ₃ := φ.right.left\n      τ₄ := φ.right.right\n      comm₁₂ := φ.left.w.symm\n      comm₁₃ := Arrow.leftFunc.congr_map φ.w.symm\n      comm₂₄ := Arrow.rightFunc.congr_map φ.w.symm\n      comm₃₄ := φ.right.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor'_obj_X₃","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n⊢ Eq (CategoryTheory.Square.fromArrowArrowFunctor'.obj f).X₃ f.right.left","decl":"/-- The functor `Arrow (Arrow C) ⥤ Square C` which sends\na morphism `Arrow.mk f ⟶ Arrow.mk g` to the commutative square\nwith `f` on the top side and `g` on the bottom side. -/\n@[simps!]\ndef fromArrowArrowFunctor' : Arrow (Arrow C) ⥤ Square C where\n  obj f := { fac := f.hom.w.symm }\n  map φ :=\n    { τ₁ := φ.left.left\n      τ₂ := φ.left.right\n      τ₃ := φ.right.left\n      τ₄ := φ.right.right\n      comm₁₂ := φ.left.w.symm\n      comm₁₃ := Arrow.leftFunc.congr_map φ.w.symm\n      comm₂₄ := Arrow.rightFunc.congr_map φ.w.symm\n      comm₃₄ := φ.right.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor'_obj_X₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n⊢ Eq (CategoryTheory.Square.fromArrowArrowFunctor'.obj f).X₄ f.right.right","decl":"/-- The functor `Arrow (Arrow C) ⥤ Square C` which sends\na morphism `Arrow.mk f ⟶ Arrow.mk g` to the commutative square\nwith `f` on the top side and `g` on the bottom side. -/\n@[simps!]\ndef fromArrowArrowFunctor' : Arrow (Arrow C) ⥤ Square C where\n  obj f := { fac := f.hom.w.symm }\n  map φ :=\n    { τ₁ := φ.left.left\n      τ₂ := φ.left.right\n      τ₃ := φ.right.left\n      τ₄ := φ.right.right\n      comm₁₂ := φ.left.w.symm\n      comm₁₃ := Arrow.leftFunc.congr_map φ.w.symm\n      comm₂₄ := Arrow.rightFunc.congr_map φ.w.symm\n      comm₃₄ := φ.right.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor'_obj_f₁₂","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n⊢ Eq (CategoryTheory.Square.fromArrowArrowFunctor'.obj f).f₁₂ f.left.hom","decl":"/-- The functor `Arrow (Arrow C) ⥤ Square C` which sends\na morphism `Arrow.mk f ⟶ Arrow.mk g` to the commutative square\nwith `f` on the top side and `g` on the bottom side. -/\n@[simps!]\ndef fromArrowArrowFunctor' : Arrow (Arrow C) ⥤ Square C where\n  obj f := { fac := f.hom.w.symm }\n  map φ :=\n    { τ₁ := φ.left.left\n      τ₂ := φ.left.right\n      τ₃ := φ.right.left\n      τ₄ := φ.right.right\n      comm₁₂ := φ.left.w.symm\n      comm₁₃ := Arrow.leftFunc.congr_map φ.w.symm\n      comm₂₄ := Arrow.rightFunc.congr_map φ.w.symm\n      comm₃₄ := φ.right.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor'_map_τ₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Arrow (CategoryTheory.Arrow C)\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.fromArrowArrowFunctor'.map φ).τ₄ φ.right.right","decl":"/-- The functor `Arrow (Arrow C) ⥤ Square C` which sends\na morphism `Arrow.mk f ⟶ Arrow.mk g` to the commutative square\nwith `f` on the top side and `g` on the bottom side. -/\n@[simps!]\ndef fromArrowArrowFunctor' : Arrow (Arrow C) ⥤ Square C where\n  obj f := { fac := f.hom.w.symm }\n  map φ :=\n    { τ₁ := φ.left.left\n      τ₂ := φ.left.right\n      τ₃ := φ.right.left\n      τ₄ := φ.right.right\n      comm₁₂ := φ.left.w.symm\n      comm₁₃ := Arrow.leftFunc.congr_map φ.w.symm\n      comm₂₄ := Arrow.rightFunc.congr_map φ.w.symm\n      comm₃₄ := φ.right.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor'_obj_X₁","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n⊢ Eq (CategoryTheory.Square.fromArrowArrowFunctor'.obj f).X₁ f.left.left","decl":"/-- The functor `Arrow (Arrow C) ⥤ Square C` which sends\na morphism `Arrow.mk f ⟶ Arrow.mk g` to the commutative square\nwith `f` on the top side and `g` on the bottom side. -/\n@[simps!]\ndef fromArrowArrowFunctor' : Arrow (Arrow C) ⥤ Square C where\n  obj f := { fac := f.hom.w.symm }\n  map φ :=\n    { τ₁ := φ.left.left\n      τ₂ := φ.left.right\n      τ₃ := φ.right.left\n      τ₄ := φ.right.right\n      comm₁₂ := φ.left.w.symm\n      comm₁₃ := Arrow.leftFunc.congr_map φ.w.symm\n      comm₂₄ := Arrow.rightFunc.congr_map φ.w.symm\n      comm₃₄ := φ.right.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor'_map_τ₂","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Arrow (CategoryTheory.Arrow C)\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.fromArrowArrowFunctor'.map φ).τ₂ φ.left.right","decl":"/-- The functor `Arrow (Arrow C) ⥤ Square C` which sends\na morphism `Arrow.mk f ⟶ Arrow.mk g` to the commutative square\nwith `f` on the top side and `g` on the bottom side. -/\n@[simps!]\ndef fromArrowArrowFunctor' : Arrow (Arrow C) ⥤ Square C where\n  obj f := { fac := f.hom.w.symm }\n  map φ :=\n    { τ₁ := φ.left.left\n      τ₂ := φ.left.right\n      τ₃ := φ.right.left\n      τ₄ := φ.right.right\n      comm₁₂ := φ.left.w.symm\n      comm₁₃ := Arrow.leftFunc.congr_map φ.w.symm\n      comm₂₄ := Arrow.rightFunc.congr_map φ.w.symm\n      comm₃₄ := φ.right.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor'_obj_f₃₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n⊢ Eq (CategoryTheory.Square.fromArrowArrowFunctor'.obj f).f₃₄ f.right.hom","decl":"/-- The functor `Arrow (Arrow C) ⥤ Square C` which sends\na morphism `Arrow.mk f ⟶ Arrow.mk g` to the commutative square\nwith `f` on the top side and `g` on the bottom side. -/\n@[simps!]\ndef fromArrowArrowFunctor' : Arrow (Arrow C) ⥤ Square C where\n  obj f := { fac := f.hom.w.symm }\n  map φ :=\n    { τ₁ := φ.left.left\n      τ₂ := φ.left.right\n      τ₃ := φ.right.left\n      τ₄ := φ.right.right\n      comm₁₂ := φ.left.w.symm\n      comm₁₃ := Arrow.leftFunc.congr_map φ.w.symm\n      comm₂₄ := Arrow.rightFunc.congr_map φ.w.symm\n      comm₃₄ := φ.right.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor'_map_τ₃","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Arrow (CategoryTheory.Arrow C)\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.fromArrowArrowFunctor'.map φ).τ₃ φ.right.left","decl":"/-- The functor `Arrow (Arrow C) ⥤ Square C` which sends\na morphism `Arrow.mk f ⟶ Arrow.mk g` to the commutative square\nwith `f` on the top side and `g` on the bottom side. -/\n@[simps!]\ndef fromArrowArrowFunctor' : Arrow (Arrow C) ⥤ Square C where\n  obj f := { fac := f.hom.w.symm }\n  map φ :=\n    { τ₁ := φ.left.left\n      τ₂ := φ.left.right\n      τ₃ := φ.right.left\n      τ₄ := φ.right.right\n      comm₁₂ := φ.left.w.symm\n      comm₁₃ := Arrow.leftFunc.congr_map φ.w.symm\n      comm₂₄ := Arrow.rightFunc.congr_map φ.w.symm\n      comm₃₄ := φ.right.w.symm }\n\n"}
{"name":"CategoryTheory.Square.fromArrowArrowFunctor'_obj_f₁₃","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow (CategoryTheory.Arrow C)\n⊢ Eq (CategoryTheory.Square.fromArrowArrowFunctor'.obj f).f₁₃ f.hom.left","decl":"/-- The functor `Arrow (Arrow C) ⥤ Square C` which sends\na morphism `Arrow.mk f ⟶ Arrow.mk g` to the commutative square\nwith `f` on the top side and `g` on the bottom side. -/\n@[simps!]\ndef fromArrowArrowFunctor' : Arrow (Arrow C) ⥤ Square C where\n  obj f := { fac := f.hom.w.symm }\n  map φ :=\n    { τ₁ := φ.left.left\n      τ₂ := φ.left.right\n      τ₃ := φ.right.left\n      τ₄ := φ.right.right\n      comm₁₂ := φ.left.w.symm\n      comm₁₃ := Arrow.leftFunc.congr_map φ.w.symm\n      comm₂₄ := Arrow.rightFunc.congr_map φ.w.symm\n      comm₃₄ := φ.right.w.symm }\n\n"}
{"name":"CategoryTheory.Square.arrowArrowEquivalence'_inverse","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Eq CategoryTheory.Square.arrowArrowEquivalence'.inverse CategoryTheory.Square.fromArrowArrowFunctor'","decl":"/-- The equivalence `Square C ≌ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps]\ndef arrowArrowEquivalence' : Square C ≌ Arrow (Arrow C) where\n  functor := toArrowArrowFunctor'\n  inverse := fromArrowArrowFunctor'\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Square.arrowArrowEquivalence'_functor","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Eq CategoryTheory.Square.arrowArrowEquivalence'.functor CategoryTheory.Square.toArrowArrowFunctor'","decl":"/-- The equivalence `Square C ≌ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps]\ndef arrowArrowEquivalence' : Square C ≌ Arrow (Arrow C) where\n  functor := toArrowArrowFunctor'\n  inverse := fromArrowArrowFunctor'\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Square.arrowArrowEquivalence'_unitIso","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Eq CategoryTheory.Square.arrowArrowEquivalence'.unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id (CategoryTheory.Square C)))","decl":"/-- The equivalence `Square C ≌ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps]\ndef arrowArrowEquivalence' : Square C ≌ Arrow (Arrow C) where\n  functor := toArrowArrowFunctor'\n  inverse := fromArrowArrowFunctor'\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Square.arrowArrowEquivalence'_counitIso","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Eq CategoryTheory.Square.arrowArrowEquivalence'.counitIso (CategoryTheory.Iso.refl (CategoryTheory.Square.fromArrowArrowFunctor'.comp CategoryTheory.Square.toArrowArrowFunctor'))","decl":"/-- The equivalence `Square C ≌ Arrow (Arrow C)` which sends a\ncommutative square `sq` to the obvious arrow from the top morphism of `sq`\nto the bottom morphism of `sq`. -/\n@[simps]\ndef arrowArrowEquivalence' : Square C ≌ Arrow (Arrow C) where\n  functor := toArrowArrowFunctor'\n  inverse := fromArrowArrowFunctor'\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Square.evaluation₁_map","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Square C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.evaluation₁.map φ) φ.τ₁","decl":"/-- The top-left evaluation `Square C ⥤ C`. -/\n@[simps]\ndef evaluation₁ : Square C ⥤ C where\n  obj sq := sq.X₁\n  map φ := φ.τ₁\n\n"}
{"name":"CategoryTheory.Square.evaluation₁_obj","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.evaluation₁.obj sq) sq.X₁","decl":"/-- The top-left evaluation `Square C ⥤ C`. -/\n@[simps]\ndef evaluation₁ : Square C ⥤ C where\n  obj sq := sq.X₁\n  map φ := φ.τ₁\n\n"}
{"name":"CategoryTheory.Square.evaluation₂_map","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Square C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.evaluation₂.map φ) φ.τ₂","decl":"/-- The top-right evaluation `Square C ⥤ C`. -/\n@[simps]\ndef evaluation₂ : Square C ⥤ C where\n  obj sq := sq.X₂\n  map φ := φ.τ₂\n\n"}
{"name":"CategoryTheory.Square.evaluation₂_obj","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.evaluation₂.obj sq) sq.X₂","decl":"/-- The top-right evaluation `Square C ⥤ C`. -/\n@[simps]\ndef evaluation₂ : Square C ⥤ C where\n  obj sq := sq.X₂\n  map φ := φ.τ₂\n\n"}
{"name":"CategoryTheory.Square.evaluation₃_obj","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.evaluation₃.obj sq) sq.X₃","decl":"/-- The bottom-left evaluation `Square C ⥤ C`. -/\n@[simps]\ndef evaluation₃ : Square C ⥤ C where\n  obj sq := sq.X₃\n  map φ := φ.τ₃\n\n"}
{"name":"CategoryTheory.Square.evaluation₃_map","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Square C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.evaluation₃.map φ) φ.τ₃","decl":"/-- The bottom-left evaluation `Square C ⥤ C`. -/\n@[simps]\ndef evaluation₃ : Square C ⥤ C where\n  obj sq := sq.X₃\n  map φ := φ.τ₃\n\n"}
{"name":"CategoryTheory.Square.evaluation₄_obj","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq (CategoryTheory.Square.evaluation₄.obj sq) sq.X₄","decl":"/-- The bottom-right evaluation `Square C ⥤ C`. -/\n@[simps]\ndef evaluation₄ : Square C ⥤ C where\n  obj sq := sq.X₄\n  map φ := φ.τ₄\n\n"}
{"name":"CategoryTheory.Square.evaluation₄_map","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Square C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.evaluation₄.map φ) φ.τ₄","decl":"/-- The bottom-right evaluation `Square C ⥤ C`. -/\n@[simps]\ndef evaluation₄ : Square C ⥤ C where\n  obj sq := sq.X₄\n  map φ := φ.τ₄\n\n"}
{"name":"CategoryTheory.Square.op_f₁₃","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq sq.op.f₁₃ sq.f₃₄.op","decl":"/-- The map `Square C → Square Cᵒᵖ` which switches `X₁` and `X₃`, but\ndoes not move `X₂` and `X₃`. -/\n@[simps]\nprotected def op (sq : Square C) : Square Cᵒᵖ where\n  f₁₂ := sq.f₂₄.op\n  f₁₃ := sq.f₃₄.op\n  f₂₄ := sq.f₁₂.op\n  f₃₄ := sq.f₁₃.op\n  fac := Quiver.Hom.unop_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.op_X₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq sq.op.X₄ { unop := sq.X₁ }","decl":"/-- The map `Square C → Square Cᵒᵖ` which switches `X₁` and `X₃`, but\ndoes not move `X₂` and `X₃`. -/\n@[simps]\nprotected def op (sq : Square C) : Square Cᵒᵖ where\n  f₁₂ := sq.f₂₄.op\n  f₁₃ := sq.f₃₄.op\n  f₂₄ := sq.f₁₂.op\n  f₃₄ := sq.f₁₃.op\n  fac := Quiver.Hom.unop_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.op_f₂₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq sq.op.f₂₄ sq.f₁₂.op","decl":"/-- The map `Square C → Square Cᵒᵖ` which switches `X₁` and `X₃`, but\ndoes not move `X₂` and `X₃`. -/\n@[simps]\nprotected def op (sq : Square C) : Square Cᵒᵖ where\n  f₁₂ := sq.f₂₄.op\n  f₁₃ := sq.f₃₄.op\n  f₂₄ := sq.f₁₂.op\n  f₃₄ := sq.f₁₃.op\n  fac := Quiver.Hom.unop_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.op_f₁₂","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq sq.op.f₁₂ sq.f₂₄.op","decl":"/-- The map `Square C → Square Cᵒᵖ` which switches `X₁` and `X₃`, but\ndoes not move `X₂` and `X₃`. -/\n@[simps]\nprotected def op (sq : Square C) : Square Cᵒᵖ where\n  f₁₂ := sq.f₂₄.op\n  f₁₃ := sq.f₃₄.op\n  f₂₄ := sq.f₁₂.op\n  f₃₄ := sq.f₁₃.op\n  fac := Quiver.Hom.unop_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.op_X₂","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq sq.op.X₂ { unop := sq.X₂ }","decl":"/-- The map `Square C → Square Cᵒᵖ` which switches `X₁` and `X₃`, but\ndoes not move `X₂` and `X₃`. -/\n@[simps]\nprotected def op (sq : Square C) : Square Cᵒᵖ where\n  f₁₂ := sq.f₂₄.op\n  f₁₃ := sq.f₃₄.op\n  f₂₄ := sq.f₁₂.op\n  f₃₄ := sq.f₁₃.op\n  fac := Quiver.Hom.unop_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.op_X₃","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq sq.op.X₃ { unop := sq.X₃ }","decl":"/-- The map `Square C → Square Cᵒᵖ` which switches `X₁` and `X₃`, but\ndoes not move `X₂` and `X₃`. -/\n@[simps]\nprotected def op (sq : Square C) : Square Cᵒᵖ where\n  f₁₂ := sq.f₂₄.op\n  f₁₃ := sq.f₃₄.op\n  f₂₄ := sq.f₁₂.op\n  f₃₄ := sq.f₁₃.op\n  fac := Quiver.Hom.unop_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.op_f₃₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq sq.op.f₃₄ sq.f₁₃.op","decl":"/-- The map `Square C → Square Cᵒᵖ` which switches `X₁` and `X₃`, but\ndoes not move `X₂` and `X₃`. -/\n@[simps]\nprotected def op (sq : Square C) : Square Cᵒᵖ where\n  f₁₂ := sq.f₂₄.op\n  f₁₃ := sq.f₃₄.op\n  f₂₄ := sq.f₁₂.op\n  f₃₄ := sq.f₁₃.op\n  fac := Quiver.Hom.unop_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.op_X₁","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Eq sq.op.X₁ { unop := sq.X₄ }","decl":"/-- The map `Square C → Square Cᵒᵖ` which switches `X₁` and `X₃`, but\ndoes not move `X₂` and `X₃`. -/\n@[simps]\nprotected def op (sq : Square C) : Square Cᵒᵖ where\n  f₁₂ := sq.f₂₄.op\n  f₁₃ := sq.f₃₄.op\n  f₂₄ := sq.f₁₂.op\n  f₃₄ := sq.f₁₃.op\n  fac := Quiver.Hom.unop_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.unop_X₁","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square (Opposite C)\n⊢ Eq sq.unop.X₁ (Opposite.unop sq.X₄)","decl":"/-- The map `Square Cᵒᵖ → Square C` which switches `X₁` and `X₃`, but\ndoes not move `X₂` and `X₃`. -/\n@[simps]\nprotected def unop (sq : Square Cᵒᵖ) : Square C where\n  f₁₂ := sq.f₂₄.unop\n  f₁₃ := sq.f₃₄.unop\n  f₂₄ := sq.f₁₂.unop\n  f₃₄ := sq.f₁₃.unop\n  fac := Quiver.Hom.op_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.unop_f₁₃","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square (Opposite C)\n⊢ Eq sq.unop.f₁₃ sq.f₃₄.unop","decl":"/-- The map `Square Cᵒᵖ → Square C` which switches `X₁` and `X₃`, but\ndoes not move `X₂` and `X₃`. -/\n@[simps]\nprotected def unop (sq : Square Cᵒᵖ) : Square C where\n  f₁₂ := sq.f₂₄.unop\n  f₁₃ := sq.f₃₄.unop\n  f₂₄ := sq.f₁₂.unop\n  f₃₄ := sq.f₁₃.unop\n  fac := Quiver.Hom.op_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.unop_X₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square (Opposite C)\n⊢ Eq sq.unop.X₄ (Opposite.unop sq.X₁)","decl":"/-- The map `Square Cᵒᵖ → Square C` which switches `X₁` and `X₃`, but\ndoes not move `X₂` and `X₃`. -/\n@[simps]\nprotected def unop (sq : Square Cᵒᵖ) : Square C where\n  f₁₂ := sq.f₂₄.unop\n  f₁₃ := sq.f₃₄.unop\n  f₂₄ := sq.f₁₂.unop\n  f₃₄ := sq.f₁₃.unop\n  fac := Quiver.Hom.op_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.unop_X₃","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square (Opposite C)\n⊢ Eq sq.unop.X₃ (Opposite.unop sq.X₃)","decl":"/-- The map `Square Cᵒᵖ → Square C` which switches `X₁` and `X₃`, but\ndoes not move `X₂` and `X₃`. -/\n@[simps]\nprotected def unop (sq : Square Cᵒᵖ) : Square C where\n  f₁₂ := sq.f₂₄.unop\n  f₁₃ := sq.f₃₄.unop\n  f₂₄ := sq.f₁₂.unop\n  f₃₄ := sq.f₁₃.unop\n  fac := Quiver.Hom.op_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.unop_f₃₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square (Opposite C)\n⊢ Eq sq.unop.f₃₄ sq.f₁₃.unop","decl":"/-- The map `Square Cᵒᵖ → Square C` which switches `X₁` and `X₃`, but\ndoes not move `X₂` and `X₃`. -/\n@[simps]\nprotected def unop (sq : Square Cᵒᵖ) : Square C where\n  f₁₂ := sq.f₂₄.unop\n  f₁₃ := sq.f₃₄.unop\n  f₂₄ := sq.f₁₂.unop\n  f₃₄ := sq.f₁₃.unop\n  fac := Quiver.Hom.op_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.unop_f₂₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square (Opposite C)\n⊢ Eq sq.unop.f₂₄ sq.f₁₂.unop","decl":"/-- The map `Square Cᵒᵖ → Square C` which switches `X₁` and `X₃`, but\ndoes not move `X₂` and `X₃`. -/\n@[simps]\nprotected def unop (sq : Square Cᵒᵖ) : Square C where\n  f₁₂ := sq.f₂₄.unop\n  f₁₃ := sq.f₃₄.unop\n  f₂₄ := sq.f₁₂.unop\n  f₃₄ := sq.f₁₃.unop\n  fac := Quiver.Hom.op_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.unop_f₁₂","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square (Opposite C)\n⊢ Eq sq.unop.f₁₂ sq.f₂₄.unop","decl":"/-- The map `Square Cᵒᵖ → Square C` which switches `X₁` and `X₃`, but\ndoes not move `X₂` and `X₃`. -/\n@[simps]\nprotected def unop (sq : Square Cᵒᵖ) : Square C where\n  f₁₂ := sq.f₂₄.unop\n  f₁₃ := sq.f₃₄.unop\n  f₂₄ := sq.f₁₂.unop\n  f₃₄ := sq.f₁₃.unop\n  fac := Quiver.Hom.op_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.unop_X₂","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square (Opposite C)\n⊢ Eq sq.unop.X₂ (Opposite.unop sq.X₂)","decl":"/-- The map `Square Cᵒᵖ → Square C` which switches `X₁` and `X₃`, but\ndoes not move `X₂` and `X₃`. -/\n@[simps]\nprotected def unop (sq : Square Cᵒᵖ) : Square C where\n  f₁₂ := sq.f₂₄.unop\n  f₁₃ := sq.f₃₄.unop\n  f₂₄ := sq.f₁₂.unop\n  f₃₄ := sq.f₁₃.unop\n  fac := Quiver.Hom.op_inj sq.fac\n\n"}
{"name":"CategoryTheory.Square.opFunctor_map_τ₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : Opposite (CategoryTheory.Square C)\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.opFunctor.map φ).τ₄ φ.unop.τ₁.op","decl":"/-- The functor `(Square C)ᵒᵖ ⥤ Square Cᵒᵖ`. -/\n@[simps]\ndef opFunctor : (Square C)ᵒᵖ ⥤ Square Cᵒᵖ where\n  obj sq := sq.unop.op\n  map φ :=\n    { τ₁ := φ.unop.τ₄.op\n      τ₂ := φ.unop.τ₂.op\n      τ₃ := φ.unop.τ₃.op\n      τ₄ := φ.unop.τ₁.op\n      comm₁₂ := Quiver.Hom.unop_inj (by simp)\n      comm₁₃ := Quiver.Hom.unop_inj (by simp)\n      comm₂₄ := Quiver.Hom.unop_inj (by simp)\n      comm₃₄ := Quiver.Hom.unop_inj (by simp) }\n\n"}
{"name":"CategoryTheory.Square.opFunctor_obj","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : Opposite (CategoryTheory.Square C)\n⊢ Eq (CategoryTheory.Square.opFunctor.obj sq) (Opposite.unop sq).op","decl":"/-- The functor `(Square C)ᵒᵖ ⥤ Square Cᵒᵖ`. -/\n@[simps]\ndef opFunctor : (Square C)ᵒᵖ ⥤ Square Cᵒᵖ where\n  obj sq := sq.unop.op\n  map φ :=\n    { τ₁ := φ.unop.τ₄.op\n      τ₂ := φ.unop.τ₂.op\n      τ₃ := φ.unop.τ₃.op\n      τ₄ := φ.unop.τ₁.op\n      comm₁₂ := Quiver.Hom.unop_inj (by simp)\n      comm₁₃ := Quiver.Hom.unop_inj (by simp)\n      comm₂₄ := Quiver.Hom.unop_inj (by simp)\n      comm₃₄ := Quiver.Hom.unop_inj (by simp) }\n\n"}
{"name":"CategoryTheory.Square.opFunctor_map_τ₂","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : Opposite (CategoryTheory.Square C)\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.opFunctor.map φ).τ₂ φ.unop.τ₂.op","decl":"/-- The functor `(Square C)ᵒᵖ ⥤ Square Cᵒᵖ`. -/\n@[simps]\ndef opFunctor : (Square C)ᵒᵖ ⥤ Square Cᵒᵖ where\n  obj sq := sq.unop.op\n  map φ :=\n    { τ₁ := φ.unop.τ₄.op\n      τ₂ := φ.unop.τ₂.op\n      τ₃ := φ.unop.τ₃.op\n      τ₄ := φ.unop.τ₁.op\n      comm₁₂ := Quiver.Hom.unop_inj (by simp)\n      comm₁₃ := Quiver.Hom.unop_inj (by simp)\n      comm₂₄ := Quiver.Hom.unop_inj (by simp)\n      comm₃₄ := Quiver.Hom.unop_inj (by simp) }\n\n"}
{"name":"CategoryTheory.Square.opFunctor_map_τ₁","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : Opposite (CategoryTheory.Square C)\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.opFunctor.map φ).τ₁ φ.unop.τ₄.op","decl":"/-- The functor `(Square C)ᵒᵖ ⥤ Square Cᵒᵖ`. -/\n@[simps]\ndef opFunctor : (Square C)ᵒᵖ ⥤ Square Cᵒᵖ where\n  obj sq := sq.unop.op\n  map φ :=\n    { τ₁ := φ.unop.τ₄.op\n      τ₂ := φ.unop.τ₂.op\n      τ₃ := φ.unop.τ₃.op\n      τ₄ := φ.unop.τ₁.op\n      comm₁₂ := Quiver.Hom.unop_inj (by simp)\n      comm₁₃ := Quiver.Hom.unop_inj (by simp)\n      comm₂₄ := Quiver.Hom.unop_inj (by simp)\n      comm₃₄ := Quiver.Hom.unop_inj (by simp) }\n\n"}
{"name":"CategoryTheory.Square.opFunctor_map_τ₃","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : Opposite (CategoryTheory.Square C)\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.opFunctor.map φ).τ₃ φ.unop.τ₃.op","decl":"/-- The functor `(Square C)ᵒᵖ ⥤ Square Cᵒᵖ`. -/\n@[simps]\ndef opFunctor : (Square C)ᵒᵖ ⥤ Square Cᵒᵖ where\n  obj sq := sq.unop.op\n  map φ :=\n    { τ₁ := φ.unop.τ₄.op\n      τ₂ := φ.unop.τ₂.op\n      τ₃ := φ.unop.τ₃.op\n      τ₄ := φ.unop.τ₁.op\n      comm₁₂ := Quiver.Hom.unop_inj (by simp)\n      comm₁₃ := Quiver.Hom.unop_inj (by simp)\n      comm₂₄ := Quiver.Hom.unop_inj (by simp)\n      comm₃₄ := Quiver.Hom.unop_inj (by simp) }\n\n"}
{"name":"CategoryTheory.Square.map_f₁₂","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nsq : CategoryTheory.Square C\nF : CategoryTheory.Functor C D\n⊢ Eq (sq.map F).f₁₂ (F.map sq.f₁₂)","decl":"/-- The image of a commutative square by a functor. -/\n@[simps]\ndef map (sq : Square C) (F : C ⥤ D) : Square D where\n  f₁₂ := F.map sq.f₁₂\n  f₁₃ := F.map sq.f₁₃\n  f₂₄ := F.map sq.f₂₄\n  f₃₄ := F.map sq.f₃₄\n  fac := by simpa using F.congr_map sq.fac\n\n"}
{"name":"CategoryTheory.Square.map_X₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nsq : CategoryTheory.Square C\nF : CategoryTheory.Functor C D\n⊢ Eq (sq.map F).X₄ (F.obj sq.X₄)","decl":"/-- The image of a commutative square by a functor. -/\n@[simps]\ndef map (sq : Square C) (F : C ⥤ D) : Square D where\n  f₁₂ := F.map sq.f₁₂\n  f₁₃ := F.map sq.f₁₃\n  f₂₄ := F.map sq.f₂₄\n  f₃₄ := F.map sq.f₃₄\n  fac := by simpa using F.congr_map sq.fac\n\n"}
{"name":"CategoryTheory.Square.map_f₂₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nsq : CategoryTheory.Square C\nF : CategoryTheory.Functor C D\n⊢ Eq (sq.map F).f₂₄ (F.map sq.f₂₄)","decl":"/-- The image of a commutative square by a functor. -/\n@[simps]\ndef map (sq : Square C) (F : C ⥤ D) : Square D where\n  f₁₂ := F.map sq.f₁₂\n  f₁₃ := F.map sq.f₁₃\n  f₂₄ := F.map sq.f₂₄\n  f₃₄ := F.map sq.f₃₄\n  fac := by simpa using F.congr_map sq.fac\n\n"}
{"name":"CategoryTheory.Square.map_X₁","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nsq : CategoryTheory.Square C\nF : CategoryTheory.Functor C D\n⊢ Eq (sq.map F).X₁ (F.obj sq.X₁)","decl":"/-- The image of a commutative square by a functor. -/\n@[simps]\ndef map (sq : Square C) (F : C ⥤ D) : Square D where\n  f₁₂ := F.map sq.f₁₂\n  f₁₃ := F.map sq.f₁₃\n  f₂₄ := F.map sq.f₂₄\n  f₃₄ := F.map sq.f₃₄\n  fac := by simpa using F.congr_map sq.fac\n\n"}
{"name":"CategoryTheory.Square.map_f₃₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nsq : CategoryTheory.Square C\nF : CategoryTheory.Functor C D\n⊢ Eq (sq.map F).f₃₄ (F.map sq.f₃₄)","decl":"/-- The image of a commutative square by a functor. -/\n@[simps]\ndef map (sq : Square C) (F : C ⥤ D) : Square D where\n  f₁₂ := F.map sq.f₁₂\n  f₁₃ := F.map sq.f₁₃\n  f₂₄ := F.map sq.f₂₄\n  f₃₄ := F.map sq.f₃₄\n  fac := by simpa using F.congr_map sq.fac\n\n"}
{"name":"CategoryTheory.Square.map_X₃","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nsq : CategoryTheory.Square C\nF : CategoryTheory.Functor C D\n⊢ Eq (sq.map F).X₃ (F.obj sq.X₃)","decl":"/-- The image of a commutative square by a functor. -/\n@[simps]\ndef map (sq : Square C) (F : C ⥤ D) : Square D where\n  f₁₂ := F.map sq.f₁₂\n  f₁₃ := F.map sq.f₁₃\n  f₂₄ := F.map sq.f₂₄\n  f₃₄ := F.map sq.f₃₄\n  fac := by simpa using F.congr_map sq.fac\n\n"}
{"name":"CategoryTheory.Square.map_f₁₃","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nsq : CategoryTheory.Square C\nF : CategoryTheory.Functor C D\n⊢ Eq (sq.map F).f₁₃ (F.map sq.f₁₃)","decl":"/-- The image of a commutative square by a functor. -/\n@[simps]\ndef map (sq : Square C) (F : C ⥤ D) : Square D where\n  f₁₂ := F.map sq.f₁₂\n  f₁₃ := F.map sq.f₁₃\n  f₂₄ := F.map sq.f₂₄\n  f₃₄ := F.map sq.f₃₄\n  fac := by simpa using F.congr_map sq.fac\n\n"}
{"name":"CategoryTheory.Square.map_X₂","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nsq : CategoryTheory.Square C\nF : CategoryTheory.Functor C D\n⊢ Eq (sq.map F).X₂ (F.obj sq.X₂)","decl":"/-- The image of a commutative square by a functor. -/\n@[simps]\ndef map (sq : Square C) (F : C ⥤ D) : Square D where\n  f₁₂ := F.map sq.f₁₂\n  f₁₃ := F.map sq.f₁₃\n  f₂₄ := F.map sq.f₂₄\n  f₃₄ := F.map sq.f₃₄\n  fac := by simpa using F.congr_map sq.fac\n\n"}
{"name":"CategoryTheory.Functor.mapSquare_map_τ₂","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\nX✝ Y✝ : CategoryTheory.Square C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (F.mapSquare.map φ).τ₂ (F.map φ.τ₂)","decl":"/-- The functor `Square C ⥤ Square D` induced by a functor `C ⥤ D`. -/\n@[simps]\ndef mapSquare (F : C ⥤ D) : Square C ⥤ Square D where\n  obj sq := sq.map F\n  map φ :=\n    { τ₁ := F.map φ.τ₁\n      τ₂ := F.map φ.τ₂\n      τ₃ := F.map φ.τ₃\n      τ₄ := F.map φ.τ₄\n      comm₁₂ := by simpa only [Functor.map_comp] using F.congr_map φ.comm₁₂\n      comm₁₃ := by simpa only [Functor.map_comp] using F.congr_map φ.comm₁₃\n      comm₂₄ := by simpa only [Functor.map_comp] using F.congr_map φ.comm₂₄\n      comm₃₄ := by simpa only [Functor.map_comp] using F.congr_map φ.comm₃₄ }\n\n"}
{"name":"CategoryTheory.Functor.mapSquare_map_τ₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\nX✝ Y✝ : CategoryTheory.Square C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (F.mapSquare.map φ).τ₄ (F.map φ.τ₄)","decl":"/-- The functor `Square C ⥤ Square D` induced by a functor `C ⥤ D`. -/\n@[simps]\ndef mapSquare (F : C ⥤ D) : Square C ⥤ Square D where\n  obj sq := sq.map F\n  map φ :=\n    { τ₁ := F.map φ.τ₁\n      τ₂ := F.map φ.τ₂\n      τ₃ := F.map φ.τ₃\n      τ₄ := F.map φ.τ₄\n      comm₁₂ := by simpa only [Functor.map_comp] using F.congr_map φ.comm₁₂\n      comm₁₃ := by simpa only [Functor.map_comp] using F.congr_map φ.comm₁₃\n      comm₂₄ := by simpa only [Functor.map_comp] using F.congr_map φ.comm₂₄\n      comm₃₄ := by simpa only [Functor.map_comp] using F.congr_map φ.comm₃₄ }\n\n"}
{"name":"CategoryTheory.Functor.mapSquare_obj","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\nsq : CategoryTheory.Square C\n⊢ Eq (F.mapSquare.obj sq) (sq.map F)","decl":"/-- The functor `Square C ⥤ Square D` induced by a functor `C ⥤ D`. -/\n@[simps]\ndef mapSquare (F : C ⥤ D) : Square C ⥤ Square D where\n  obj sq := sq.map F\n  map φ :=\n    { τ₁ := F.map φ.τ₁\n      τ₂ := F.map φ.τ₂\n      τ₃ := F.map φ.τ₃\n      τ₄ := F.map φ.τ₄\n      comm₁₂ := by simpa only [Functor.map_comp] using F.congr_map φ.comm₁₂\n      comm₁₃ := by simpa only [Functor.map_comp] using F.congr_map φ.comm₁₃\n      comm₂₄ := by simpa only [Functor.map_comp] using F.congr_map φ.comm₂₄\n      comm₃₄ := by simpa only [Functor.map_comp] using F.congr_map φ.comm₃₄ }\n\n"}
{"name":"CategoryTheory.Functor.mapSquare_map_τ₃","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\nX✝ Y✝ : CategoryTheory.Square C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (F.mapSquare.map φ).τ₃ (F.map φ.τ₃)","decl":"/-- The functor `Square C ⥤ Square D` induced by a functor `C ⥤ D`. -/\n@[simps]\ndef mapSquare (F : C ⥤ D) : Square C ⥤ Square D where\n  obj sq := sq.map F\n  map φ :=\n    { τ₁ := F.map φ.τ₁\n      τ₂ := F.map φ.τ₂\n      τ₃ := F.map φ.τ₃\n      τ₄ := F.map φ.τ₄\n      comm₁₂ := by simpa only [Functor.map_comp] using F.congr_map φ.comm₁₂\n      comm₁₃ := by simpa only [Functor.map_comp] using F.congr_map φ.comm₁₃\n      comm₂₄ := by simpa only [Functor.map_comp] using F.congr_map φ.comm₂₄\n      comm₃₄ := by simpa only [Functor.map_comp] using F.congr_map φ.comm₃₄ }\n\n"}
{"name":"CategoryTheory.Functor.mapSquare_map_τ₁","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\nX✝ Y✝ : CategoryTheory.Square C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (F.mapSquare.map φ).τ₁ (F.map φ.τ₁)","decl":"/-- The functor `Square C ⥤ Square D` induced by a functor `C ⥤ D`. -/\n@[simps]\ndef mapSquare (F : C ⥤ D) : Square C ⥤ Square D where\n  obj sq := sq.map F\n  map φ :=\n    { τ₁ := F.map φ.τ₁\n      τ₂ := F.map φ.τ₂\n      τ₃ := F.map φ.τ₃\n      τ₄ := F.map φ.τ₄\n      comm₁₂ := by simpa only [Functor.map_comp] using F.congr_map φ.comm₁₂\n      comm₁₃ := by simpa only [Functor.map_comp] using F.congr_map φ.comm₁₃\n      comm₂₄ := by simpa only [Functor.map_comp] using F.congr_map φ.comm₂₄\n      comm₃₄ := by simpa only [Functor.map_comp] using F.congr_map φ.comm₃₄ }\n\n"}
{"name":"CategoryTheory.NatTrans.mapSquare_app_τ₄","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nτ : Quiver.Hom F G\nsq : CategoryTheory.Square C\n⊢ Eq ((CategoryTheory.NatTrans.mapSquare τ).app sq).τ₄ (τ.app sq.X₄)","decl":"/-- The natural transformation `F.mapSquare ⟶ G.mapSquare` induces\nby a natural transformation `F ⟶ G`. -/\n@[simps]\ndef NatTrans.mapSquare {F G : C ⥤ D} (τ : F ⟶ G) :\n    F.mapSquare ⟶ G.mapSquare where\n  app sq :=\n    { τ₁ := τ.app _\n      τ₂ := τ.app _\n      τ₃ := τ.app _\n      τ₄ := τ.app _ }\n\n"}
{"name":"CategoryTheory.NatTrans.mapSquare_app_τ₂","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nτ : Quiver.Hom F G\nsq : CategoryTheory.Square C\n⊢ Eq ((CategoryTheory.NatTrans.mapSquare τ).app sq).τ₂ (τ.app sq.X₂)","decl":"/-- The natural transformation `F.mapSquare ⟶ G.mapSquare` induces\nby a natural transformation `F ⟶ G`. -/\n@[simps]\ndef NatTrans.mapSquare {F G : C ⥤ D} (τ : F ⟶ G) :\n    F.mapSquare ⟶ G.mapSquare where\n  app sq :=\n    { τ₁ := τ.app _\n      τ₂ := τ.app _\n      τ₃ := τ.app _\n      τ₄ := τ.app _ }\n\n"}
{"name":"CategoryTheory.NatTrans.mapSquare_app_τ₃","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nτ : Quiver.Hom F G\nsq : CategoryTheory.Square C\n⊢ Eq ((CategoryTheory.NatTrans.mapSquare τ).app sq).τ₃ (τ.app sq.X₃)","decl":"/-- The natural transformation `F.mapSquare ⟶ G.mapSquare` induces\nby a natural transformation `F ⟶ G`. -/\n@[simps]\ndef NatTrans.mapSquare {F G : C ⥤ D} (τ : F ⟶ G) :\n    F.mapSquare ⟶ G.mapSquare where\n  app sq :=\n    { τ₁ := τ.app _\n      τ₂ := τ.app _\n      τ₃ := τ.app _\n      τ₄ := τ.app _ }\n\n"}
{"name":"CategoryTheory.NatTrans.mapSquare_app_τ₁","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nτ : Quiver.Hom F G\nsq : CategoryTheory.Square C\n⊢ Eq ((CategoryTheory.NatTrans.mapSquare τ).app sq).τ₁ (τ.app sq.X₁)","decl":"/-- The natural transformation `F.mapSquare ⟶ G.mapSquare` induces\nby a natural transformation `F ⟶ G`. -/\n@[simps]\ndef NatTrans.mapSquare {F G : C ⥤ D} (τ : F ⟶ G) :\n    F.mapSquare ⟶ G.mapSquare where\n  app sq :=\n    { τ₁ := τ.app _\n      τ₂ := τ.app _\n      τ₃ := τ.app _\n      τ₄ := τ.app _ }\n\n"}
{"name":"CategoryTheory.Square.mapFunctor_map","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nX✝ Y✝ : CategoryTheory.Functor C D\nτ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Square.mapFunctor.map τ) (CategoryTheory.NatTrans.mapSquare τ)","decl":"/-- The functor `(C ⥤ D) ⥤ Square C ⥤ Square D`. -/\n@[simps]\ndef Square.mapFunctor : (C ⥤ D) ⥤ Square C ⥤ Square D where\n  obj F := F.mapSquare\n  map τ := NatTrans.mapSquare τ\n\n"}
{"name":"CategoryTheory.Square.mapFunctor_obj","module":"Mathlib.CategoryTheory.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\n⊢ Eq (CategoryTheory.Square.mapFunctor.obj F) F.mapSquare","decl":"/-- The functor `(C ⥤ D) ⥤ Square C ⥤ Square D`. -/\n@[simps]\ndef Square.mapFunctor : (C ⥤ D) ⥤ Square C ⥤ Square D where\n  obj F := F.mapSquare\n  map τ := NatTrans.mapSquare τ\n\n"}
