{"name":"Matrix.minpoly_toLin'","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Minpoly","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\n⊢ Eq (minpoly R (Matrix.toLin' M)) (minpoly R M)","decl":"@[simp]\ntheorem minpoly_toLin' : minpoly R (toLin' M) = minpoly R M :=\n  minpoly.algEquiv_eq (toLinAlgEquiv' : Matrix n n R ≃ₐ[R] _) M\n\n"}
{"name":"Matrix.minpoly_toLin","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Minpoly","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nn : Type v\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\nN : Type w\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nb : Basis n R N\nM : Matrix n n R\n⊢ Eq (minpoly R ((Matrix.toLin b b) M)) (minpoly R M)","decl":"@[simp]\ntheorem minpoly_toLin (b : Basis n R N) (M : Matrix n n R) :\n    minpoly R (toLin b b M) = minpoly R M :=\n  minpoly.algEquiv_eq (toLinAlgEquiv b : Matrix n n R ≃ₐ[R] _) M\n\n"}
{"name":"Matrix.isIntegral","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Minpoly","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\n⊢ IsIntegral R M","decl":"theorem isIntegral : IsIntegral R M :=\n  ⟨M.charpoly, ⟨charpoly_monic M, aeval_self_charpoly M⟩⟩\n\n"}
{"name":"Matrix.minpoly_dvd_charpoly","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Minpoly","initialProofState":"n : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nK : Type u_1\ninst✝ : Field K\nM : Matrix n n K\n⊢ Dvd.dvd (minpoly K M) M.charpoly","decl":"theorem minpoly_dvd_charpoly {K : Type*} [Field K] (M : Matrix n n K) : minpoly K M ∣ M.charpoly :=\n  minpoly.dvd _ _ (aeval_self_charpoly M)\n\n"}
{"name":"LinearMap.minpoly_toMatrix'","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Minpoly","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nf : LinearMap (RingHom.id R) (n → R) (n → R)\n⊢ Eq (minpoly R (LinearMap.toMatrix' f)) (minpoly R f)","decl":"@[simp]\ntheorem minpoly_toMatrix' (f : (n → R) →ₗ[R] n → R) : minpoly R (toMatrix' f) = minpoly R f :=\n  minpoly.algEquiv_eq (toMatrixAlgEquiv' : _ ≃ₐ[R] Matrix n n R) f\n\n"}
{"name":"LinearMap.minpoly_toMatrix","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Minpoly","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nn : Type v\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\nN : Type w\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nb : Basis n R N\nf : LinearMap (RingHom.id R) N N\n⊢ Eq (minpoly R ((LinearMap.toMatrix b b) f)) (minpoly R f)","decl":"@[simp]\ntheorem minpoly_toMatrix (b : Basis n R N) (f : N →ₗ[R] N) :\n    minpoly R (toMatrix b b f) = minpoly R f :=\n  minpoly.algEquiv_eq (toMatrixAlgEquiv b : _ ≃ₐ[R] Matrix n n R) f\n\n"}
{"name":"charpoly_leftMulMatrix","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Minpoly","initialProofState":"R : Type u\ninst✝² : CommRing R\nS : Type u_1\ninst✝¹ : Ring S\ninst✝ : Algebra R S\nh : PowerBasis R S\n⊢ Eq ((Algebra.leftMulMatrix h.basis) h.gen).charpoly (minpoly R h.gen)","decl":"/-- The characteristic polynomial of the map `fun x => a * x` is the minimal polynomial of `a`.\n\nIn combination with `det_eq_sign_charpoly_coeff` or `trace_eq_neg_charpoly_coeff`\nand a bit of rewriting, this will allow us to conclude the\nfield norm resp. trace of `x` is the product resp. sum of `x`'s conjugates.\n-/\ntheorem charpoly_leftMulMatrix {S : Type*} [Ring S] [Algebra R S] (h : PowerBasis R S) :\n    (leftMulMatrix h.basis h.gen).charpoly = minpoly R h.gen := by\n  cases subsingleton_or_nontrivial R; · subsingleton\n  apply minpoly.unique' R h.gen (charpoly_monic _)\n  · apply (injective_iff_map_eq_zero (G := S) (leftMulMatrix _)).mp\n      (leftMulMatrix_injective h.basis)\n    rw [← Polynomial.aeval_algHom_apply, aeval_self_charpoly]\n  refine fun q hq => or_iff_not_imp_left.2 fun h0 => ?_\n  rw [Matrix.charpoly_degree_eq_dim, Fintype.card_fin] at hq\n  contrapose! hq; exact h.dim_le_degree_of_root h0 hq\n\n"}
