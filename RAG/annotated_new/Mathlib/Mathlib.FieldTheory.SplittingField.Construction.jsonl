{"name":"Polynomial.irreducible_factor","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"K : Type v\ninst✝ : Field K\nf : Polynomial K\n⊢ Irreducible f.factor","decl":"theorem irreducible_factor (f : K[X]) : Irreducible (factor f) := by\n  rw [factor]\n  split_ifs with H\n  · exact (Classical.choose_spec H).1\n  · exact irreducible_X\n\n"}
{"name":"Polynomial.fact_irreducible_factor","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"K : Type v\ninst✝ : Field K\nf : Polynomial K\n⊢ Fact (Irreducible f.factor)","decl":"/-- See note [fact non-instances]. -/\ntheorem fact_irreducible_factor (f : K[X]) : Fact (Irreducible (factor f)) :=\n  ⟨irreducible_factor f⟩\n\n"}
{"name":"Polynomial.factor_dvd_of_not_isUnit","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"K : Type v\ninst✝ : Field K\nf : Polynomial K\nhf1 : Not (IsUnit f)\n⊢ Dvd.dvd f.factor f","decl":"theorem factor_dvd_of_not_isUnit {f : K[X]} (hf1 : ¬IsUnit f) : factor f ∣ f := by\n  by_cases hf2 : f = 0; · rw [hf2]; exact dvd_zero _\n  rw [factor, dif_pos (WfDvdMonoid.exists_irreducible_factor hf1 hf2)]\n  exact (Classical.choose_spec <| WfDvdMonoid.exists_irreducible_factor hf1 hf2).2\n\n"}
{"name":"Polynomial.factor_dvd_of_degree_ne_zero","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"K : Type v\ninst✝ : Field K\nf : Polynomial K\nhf : Ne f.degree 0\n⊢ Dvd.dvd f.factor f","decl":"theorem factor_dvd_of_degree_ne_zero {f : K[X]} (hf : f.degree ≠ 0) : factor f ∣ f :=\n  factor_dvd_of_not_isUnit (mt degree_eq_zero_of_isUnit hf)\n\n"}
{"name":"Polynomial.factor_dvd_of_natDegree_ne_zero","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"K : Type v\ninst✝ : Field K\nf : Polynomial K\nhf : Ne f.natDegree 0\n⊢ Dvd.dvd f.factor f","decl":"theorem factor_dvd_of_natDegree_ne_zero {f : K[X]} (hf : f.natDegree ≠ 0) : factor f ∣ f :=\n  factor_dvd_of_degree_ne_zero (mt natDegree_eq_of_degree_eq_some hf)\n\n"}
{"name":"Polynomial.isCoprime_iff_aeval_ne_zero","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"K : Type v\ninst✝ : Field K\nf g : Polynomial K\n⊢ Iff (IsCoprime f g) (∀ {A : Type v} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : Algebra K A] (a : A), Or (Ne ((Polynomial.aeval a) f) 0) (Ne ((Polynomial.aeval a) g) 0))","decl":"lemma isCoprime_iff_aeval_ne_zero (f g : K[X]) : IsCoprime f g ↔ ∀ {A : Type v} [CommRing A]\n    [IsDomain A] [Algebra K A] (a : A), aeval a f ≠ 0 ∨ aeval a g ≠ 0 := by\n  refine ⟨fun h => aeval_ne_zero_of_isCoprime h, fun h => isCoprime_of_dvd _ _ ?_ fun x hx _ => ?_⟩\n  · replace h := @h K _ _ _ 0\n    contrapose! h\n    rw [h.left, h.right, map_zero, and_self]\n  · rintro ⟨_, rfl⟩ ⟨_, rfl⟩\n    replace h := not_and_or.mpr <| h <| AdjoinRoot.root x.factor\n    simp only [AdjoinRoot.aeval_eq, AdjoinRoot.mk_eq_zero,\n      dvd_mul_of_dvd_left <| factor_dvd_of_not_isUnit hx, true_and, not_true] at h\n\n"}
{"name":"Polynomial.X_sub_C_mul_removeFactor","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"K : Type v\ninst✝ : Field K\nf : Polynomial K\nhf : Ne f.natDegree 0\n⊢ Eq (HMul.hMul (HSub.hSub Polynomial.X (Polynomial.C (AdjoinRoot.root f.factor))) f.removeFactor) (Polynomial.map (AdjoinRoot.of f.factor) f)","decl":"theorem X_sub_C_mul_removeFactor (f : K[X]) (hf : f.natDegree ≠ 0) :\n    (X - C (AdjoinRoot.root f.factor)) * f.removeFactor = map (AdjoinRoot.of f.factor) f := by\n  let ⟨g, hg⟩ := factor_dvd_of_natDegree_ne_zero hf\n  apply (mul_divByMonic_eq_iff_isRoot\n    (R := AdjoinRoot f.factor) (a := AdjoinRoot.root f.factor)).mpr\n  rw [IsRoot.def, eval_map, hg, eval₂_mul, ← hg, AdjoinRoot.eval₂_root, zero_mul]\n\n"}
{"name":"Polynomial.natDegree_removeFactor","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"K : Type v\ninst✝ : Field K\nf : Polynomial K\n⊢ Eq f.removeFactor.natDegree (HSub.hSub f.natDegree 1)","decl":"theorem natDegree_removeFactor (f : K[X]) : f.removeFactor.natDegree = f.natDegree - 1 := by\n  -- Porting note: `(map (AdjoinRoot.of f.factor) f)` was `_`\n  rw [removeFactor, natDegree_divByMonic (map (AdjoinRoot.of f.factor) f) (monic_X_sub_C _),\n    natDegree_map, natDegree_X_sub_C]\n\n"}
{"name":"Polynomial.natDegree_removeFactor'","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"K : Type v\ninst✝ : Field K\nf : Polynomial K\nn : Nat\nhfn : Eq f.natDegree (HAdd.hAdd n 1)\n⊢ Eq f.removeFactor.natDegree n","decl":"theorem natDegree_removeFactor' {f : K[X]} {n : ℕ} (hfn : f.natDegree = n + 1) :\n    f.removeFactor.natDegree = n := by rw [natDegree_removeFactor, hfn, n.add_sub_cancel]\n\n"}
{"name":"Polynomial.SplittingFieldAux.succ","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"K : Type v\ninst✝ : Field K\nn : Nat\nf : Polynomial K\n⊢ Eq (Polynomial.SplittingFieldAux (HAdd.hAdd n 1) f) (Polynomial.SplittingFieldAux n f.removeFactor)","decl":"theorem succ (n : ℕ) (f : K[X]) :\n    SplittingFieldAux (n + 1) f = SplittingFieldAux n f.removeFactor :=\n  rfl\n\n"}
{"name":"Polynomial.SplittingFieldAux.scalar_tower'","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"K : Type v\ninst✝ : Field K\nn : Nat\nf : Polynomial K\n⊢ IsScalarTower K (AdjoinRoot f.factor) (Polynomial.SplittingFieldAux n f.removeFactor)","decl":"instance scalar_tower' {n : ℕ} {f : K[X]} :\n    IsScalarTower K (AdjoinRoot f.factor) (SplittingFieldAux n f.removeFactor) :=\n  IsScalarTower.of_algebraMap_eq fun _ => rfl\n\n"}
{"name":"Polynomial.SplittingFieldAux.algebraMap_succ","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"K : Type v\ninst✝ : Field K\nn : Nat\nf : Polynomial K\n⊢ Eq (algebraMap K (Polynomial.SplittingFieldAux (HAdd.hAdd n 1) f)) ((algebraMap (AdjoinRoot f.factor) (Polynomial.SplittingFieldAux n f.removeFactor)).comp (AdjoinRoot.of f.factor))","decl":"theorem algebraMap_succ (n : ℕ) (f : K[X]) :\n    algebraMap K (SplittingFieldAux (n + 1) f) =\n      (algebraMap (AdjoinRoot f.factor) (SplittingFieldAux n f.removeFactor)).comp\n        (AdjoinRoot.of f.factor) :=\n  rfl\n\n"}
{"name":"Polynomial.SplittingFieldAux.splits","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"n : Nat\nK : Type u\ninst✝ : Field K\nf : Polynomial K\n_hfn : Eq f.natDegree n\n⊢ Polynomial.Splits (algebraMap K (Polynomial.SplittingFieldAux n f)) f","decl":"protected theorem splits (n : ℕ) :\n    ∀ {K : Type u} [Field K],\n      ∀ (f : K[X]) (_hfn : f.natDegree = n), Splits (algebraMap K <| SplittingFieldAux n f) f :=\n  Nat.recOn (motive := fun n => ∀ {K : Type u} [Field K],\n      ∀ (f : K[X]) (_hfn : f.natDegree = n), Splits (algebraMap K <| SplittingFieldAux n f) f) n\n    (fun {_} _ _ hf =>\n      splits_of_degree_le_one _\n        (le_trans degree_le_natDegree <| hf.symm ▸ WithBot.coe_le_coe.2 zero_le_one))\n    fun n ih {K} _ f hf => by\n    rw [← splits_id_iff_splits, algebraMap_succ, ← map_map, splits_id_iff_splits,\n      ← X_sub_C_mul_removeFactor f fun h => by rw [h] at hf; cases hf]\n    exact splits_mul _ (splits_X_sub_C _) (ih _ (natDegree_removeFactor' hf))\n\n"}
{"name":"Polynomial.SplittingFieldAux.adjoin_rootSet","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"n : Nat\nK : Type u\ninst✝ : Field K\nf : Polynomial K\n_hfn : Eq f.natDegree n\n⊢ Eq (Algebra.adjoin K (f.rootSet (Polynomial.SplittingFieldAux n f))) Top.top","decl":"theorem adjoin_rootSet (n : ℕ) :\n    ∀ {K : Type u} [Field K],\n      ∀ (f : K[X]) (_hfn : f.natDegree = n),\n        Algebra.adjoin K (f.rootSet (SplittingFieldAux n f)) = ⊤ :=\n  Nat.recOn (motive := fun n =>\n    ∀ {K : Type u} [Field K],\n      ∀ (f : K[X]) (_hfn : f.natDegree = n),\n        Algebra.adjoin K (f.rootSet (SplittingFieldAux n f)) = ⊤)\n    n (fun {_} _ _ _hf => Algebra.eq_top_iff.2 fun x => Subalgebra.range_le _ ⟨x, rfl⟩)\n    fun n ih {K} _ f hfn => by\n    have hndf : f.natDegree ≠ 0 := by intro h; rw [h] at hfn; cases hfn\n    have hfn0 : f ≠ 0 := by intro h; rw [h] at hndf; exact hndf rfl\n    have hmf0 : map (algebraMap K (SplittingFieldAux n.succ f)) f ≠ 0 := map_ne_zero hfn0\n    classical\n    rw [rootSet_def, aroots_def]\n    rw [algebraMap_succ, ← map_map, ← X_sub_C_mul_removeFactor _ hndf, Polynomial.map_mul] at hmf0 ⊢\n    -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n    erw [roots_mul hmf0, Polynomial.map_sub, map_X, map_C, roots_X_sub_C, Multiset.toFinset_add,\n      Finset.coe_union, Multiset.toFinset_singleton, Finset.coe_singleton,\n      Algebra.adjoin_union_eq_adjoin_adjoin, ← Set.image_singleton,\n      Algebra.adjoin_algebraMap K (SplittingFieldAux n f.removeFactor),\n      AdjoinRoot.adjoinRoot_eq_top, Algebra.map_top]\n    /- Porting note: was `rw [IsScalarTower.adjoin_range_toAlgHom K (AdjoinRoot f.factor)\n        (SplittingFieldAux n f.removeFactor)]` -/\n    have := IsScalarTower.adjoin_range_toAlgHom K (AdjoinRoot f.factor)\n        (SplittingFieldAux n f.removeFactor)\n        (f.removeFactor.rootSet (SplittingFieldAux n f.removeFactor))\n    refine this.trans ?_\n    rw [ih _ (natDegree_removeFactor' hfn), Subalgebra.restrictScalars_top]\n\n"}
{"name":"Polynomial.SplittingFieldAux.instIsSplittingFieldNatDegree","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"K : Type v\ninst✝ : Field K\nf : Polynomial K\n⊢ Polynomial.IsSplittingField K (Polynomial.SplittingFieldAux f.natDegree f) f","decl":"instance (f : K[X]) : IsSplittingField K (SplittingFieldAux f.natDegree f) f :=\n  ⟨SplittingFieldAux.splits _ _ rfl, SplittingFieldAux.adjoin_rootSet _ _ rfl⟩\n\n"}
{"name":"Polynomial.SplittingField.isScalarTower","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"K : Type v\ninst✝² : Field K\nf : Polynomial K\nR : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : Algebra R K\n⊢ IsScalarTower R K f.SplittingField","decl":"instance isScalarTower {R : Type*} [CommSemiring R] [Algebra R K] :\n    IsScalarTower R K (SplittingField f) :=\n  Ideal.Quotient.isScalarTower _ _ _\n\n"}
{"name":"Polynomial.SplittingField.instCharZero","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"K : Type v\ninst✝¹ : Field K\nf : Polynomial K\ninst✝ : CharZero K\n⊢ CharZero f.SplittingField","decl":"instance instCharZero [CharZero K] : CharZero (SplittingField f) :=\n  charZero_of_injective_algebraMap (algebraMap K _).injective\n\n"}
{"name":"Polynomial.SplittingField.instCharP","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"K : Type v\ninst✝¹ : Field K\nf : Polynomial K\np : Nat\ninst✝ : CharP K p\n⊢ CharP f.SplittingField p","decl":"instance instCharP (p : ℕ) [CharP K p] : CharP (SplittingField f) p :=\n  charP_of_injective_algebraMap (algebraMap K _).injective p\n\n"}
{"name":"Polynomial.SplittingField.instExpChar","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"K : Type v\ninst✝¹ : Field K\nf : Polynomial K\np : Nat\ninst✝ : ExpChar K p\n⊢ ExpChar f.SplittingField p","decl":"instance instExpChar (p : ℕ) [ExpChar K p] : ExpChar (SplittingField f) p :=\n  expChar_of_injective_algebraMap (algebraMap K _).injective p\n\n"}
{"name":"Polynomial.IsSplittingField.splittingField","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"K : Type v\ninst✝ : Field K\nf : Polynomial K\n⊢ Polynomial.IsSplittingField K f.SplittingField f","decl":"instance _root_.Polynomial.IsSplittingField.splittingField (f : K[X]) :\n    IsSplittingField K (SplittingField f) f :=\n  IsSplittingField.of_algEquiv _ f (algEquivSplittingFieldAux f).symm\n\n"}
{"name":"Polynomial.SplittingField.splits","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"K : Type v\ninst✝ : Field K\nf : Polynomial K\n⊢ Polynomial.Splits (algebraMap K f.SplittingField) f","decl":"@[stacks 09HU \"Splitting part\"]\nprotected theorem splits : Splits (algebraMap K (SplittingField f)) f :=\n  IsSplittingField.splits f.SplittingField f\n\n"}
{"name":"Polynomial.SplittingField.adjoin_rootSet","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"K : Type v\ninst✝ : Field K\nf : Polynomial K\n⊢ Eq (Algebra.adjoin K (f.rootSet f.SplittingField)) Top.top","decl":"theorem adjoin_rootSet : Algebra.adjoin K (f.rootSet (SplittingField f)) = ⊤ :=\n  Polynomial.IsSplittingField.adjoin_rootSet _ f\n\n"}
{"name":"Polynomial.IsSplittingField.instFiniteDimensionalSplittingField","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"K : Type v\ninst✝ : Field K\nf : Polynomial K\n⊢ FiniteDimensional K f.SplittingField","decl":"instance (f : K[X]) : FiniteDimensional K f.SplittingField :=\n  finiteDimensional f.SplittingField f\n\n"}
{"name":"Polynomial.IsSplittingField.instFiniteSplittingField","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"K : Type v\ninst✝¹ : Field K\ninst✝ : Finite K\nf : Polynomial K\n⊢ Finite f.SplittingField","decl":"instance [Finite K] (f : K[X]) : Finite f.SplittingField :=\n  Module.finite_of_finite K\n\n"}
{"name":"Polynomial.IsSplittingField.instNoZeroSMulDivisorsSplittingField","module":"Mathlib.FieldTheory.SplittingField.Construction","initialProofState":"K : Type v\ninst✝ : Field K\nf : Polynomial K\n⊢ NoZeroSMulDivisors K f.SplittingField","decl":"instance (f : K[X]) : NoZeroSMulDivisors K f.SplittingField :=\n  inferInstance\n\n"}
